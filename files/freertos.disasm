
.\files\freertos.out:	file format elf32-littlearm

Disassembly of section .vectors:

00000000 <_vectors>:
;         LDR pc, reset_addr          // Reset
       0: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x20 <reset_addr>
;         LDR pc, undefined_addr      // Undefined Instruction
       4: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x24 <undefined_addr>
;         LDR pc, svc_addr            // Software interrupt
       8: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x28 <svc_addr>
;         LDR pc, prefetch_abort_addr // Abort (prefetch)
       c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x2c <prefetch_abort_addr>
;         LDR pc, data_abort_addr     // Abort (data)
      10: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x30 <data_abort_addr>
;         LDR pc, reserved_addr       // rsvd
      14: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x34 <reserved_addr>
;         LDR pc, irq_addr            // IRQ
      18: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x38 <irq_addr>
;         LDR pc, fiq_addr            // FIQ
      1c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x3c <fiq_addr>

00000020 <reset_addr>:
      20: 74 11 0b 70  	.word	0x700b1174

00000024 <undefined_addr>:
      24: 81 06 0b 70  	.word	0x700b0681

00000028 <svc_addr>:
      28: 6c 07 0b 70  	.word	0x700b076c

0000002c <prefetch_abort_addr>:
      2c: c1 06 0b 70  	.word	0x700b06c1

00000030 <data_abort_addr>:
      30: 90 09 0b 70  	.word	0x700b0990

00000034 <reserved_addr>:
      34: 41 06 0b 70  	.word	0x700b0641

00000038 <irq_addr>:
      38: dc 07 0b 70  	.word	0x700b07dc

0000003c <fiq_addr>:
      3c: d1 04 0b 70  	.word	0x700b04d1

Disassembly of section .text.hwi:

700afdc0 <HwiP_enableInt>:
; {
700afdc0: b580         	push	{r7, lr}
700afdc2: b084         	sub	sp, #0x10
700afdc4: 9003         	str	r0, [sp, #0xc]
;     Hwip_dataAndInstructionBarrier();
700afdc6: f7ff ff53    	bl	0x700afc70 <Hwip_dataAndInstructionBarrier> @ imm = #-0x15a
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_EN(intNum));
700afdca: f642 10e8    	movw	r0, #0x29e8
700afdce: f2c7 000b    	movt	r0, #0x700b
700afdd2: 6801         	ldr	r1, [r0]
700afdd4: 9803         	ldr	r0, [sp, #0xc]
700afdd6: f400 70f0    	and	r0, r0, #0x1e0
700afdda: 4408         	add	r0, r1
700afddc: f500 6081    	add.w	r0, r0, #0x408
700afde0: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700afde2: 9803         	ldr	r0, [sp, #0xc]
700afde4: f000 001f    	and	r0, r0, #0x1f
700afde8: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700afdea: 9901         	ldr	r1, [sp, #0x4]
700afdec: 2001         	movs	r0, #0x1
700afdee: 4088         	lsls	r0, r1
700afdf0: 9902         	ldr	r1, [sp, #0x8]
700afdf2: 6008         	str	r0, [r1]
; }
700afdf4: b004         	add	sp, #0x10
700afdf6: bd80         	pop	{r7, pc}
700afdf8: bf00         	nop
700afdfa: bf00         	nop
700afdfc: bf00         	nop
700afdfe: bf00         	nop

700afe00 <HwiP_disableInt>:
; {
700afe00: b580         	push	{r7, lr}
700afe02: b084         	sub	sp, #0x10
700afe04: 9003         	str	r0, [sp, #0xc]
700afe06: 2000         	movs	r0, #0x0
;     uint32_t isEnable = 0;
700afe08: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(intNum));
700afe0a: f642 10e8    	movw	r0, #0x29e8
700afe0e: f2c7 000b    	movt	r0, #0x700b
700afe12: 6801         	ldr	r1, [r0]
700afe14: 9803         	ldr	r0, [sp, #0xc]
700afe16: f400 70f0    	and	r0, r0, #0x1e0
700afe1a: 4408         	add	r0, r1
700afe1c: f200 400c    	addw	r0, r0, #0x40c
700afe20: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700afe22: 9803         	ldr	r0, [sp, #0xc]
700afe24: f000 001f    	and	r0, r0, #0x1f
700afe28: 9001         	str	r0, [sp, #0x4]
;     if( (*addr & ((uint32_t)0x1 << bitPos))!=0U)
700afe2a: 9802         	ldr	r0, [sp, #0x8]
700afe2c: 6800         	ldr	r0, [r0]
700afe2e: 9901         	ldr	r1, [sp, #0x4]
700afe30: 40c8         	lsrs	r0, r1
700afe32: 07c0         	lsls	r0, r0, #0x1f
700afe34: b118         	cbz	r0, 0x700afe3e <HwiP_disableInt+0x3e> @ imm = #0x6
700afe36: e7ff         	b	0x700afe38 <HwiP_disableInt+0x38> @ imm = #-0x2
700afe38: 2001         	movs	r0, #0x1
;         isEnable = 1;
700afe3a: 9000         	str	r0, [sp]
;     }
700afe3c: e7ff         	b	0x700afe3e <HwiP_disableInt+0x3e> @ imm = #-0x2
;     *addr = ((uint32_t)0x1 << bitPos);
700afe3e: 9901         	ldr	r1, [sp, #0x4]
700afe40: 2001         	movs	r0, #0x1
700afe42: 4088         	lsls	r0, r1
700afe44: 9902         	ldr	r1, [sp, #0x8]
700afe46: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700afe48: f7ff ff12    	bl	0x700afc70 <Hwip_dataAndInstructionBarrier> @ imm = #-0x1dc
;     return isEnable;
700afe4c: 9800         	ldr	r0, [sp]
700afe4e: b004         	add	sp, #0x10
700afe50: bd80         	pop	{r7, pc}
700afe52: bf00         	nop
700afe54: bf00         	nop
700afe56: bf00         	nop
700afe58: bf00         	nop
700afe5a: bf00         	nop
700afe5c: bf00         	nop
700afe5e: bf00         	nop

700afe60 <HwiP_restoreInt>:
; {
700afe60: b580         	push	{r7, lr}
700afe62: b082         	sub	sp, #0x8
700afe64: 9001         	str	r0, [sp, #0x4]
700afe66: 9100         	str	r1, [sp]
;     if(oldIntState!=0U)
700afe68: 9800         	ldr	r0, [sp]
700afe6a: b120         	cbz	r0, 0x700afe76 <HwiP_restoreInt+0x16> @ imm = #0x8
700afe6c: e7ff         	b	0x700afe6e <HwiP_restoreInt+0xe> @ imm = #-0x2
;         HwiP_enableInt(intNum);
700afe6e: 9801         	ldr	r0, [sp, #0x4]
700afe70: f7ff ffa6    	bl	0x700afdc0 <HwiP_enableInt> @ imm = #-0xb4
;     }
700afe74: e003         	b	0x700afe7e <HwiP_restoreInt+0x1e> @ imm = #0x6
;        (void) HwiP_disableInt(intNum);
700afe76: 9801         	ldr	r0, [sp, #0x4]
700afe78: f7ff ffc2    	bl	0x700afe00 <HwiP_disableInt> @ imm = #-0x7c
700afe7c: e7ff         	b	0x700afe7e <HwiP_restoreInt+0x1e> @ imm = #-0x2
; }
700afe7e: b002         	add	sp, #0x8
700afe80: bd80         	pop	{r7, pc}
700afe82: bf00         	nop
700afe84: bf00         	nop
700afe86: bf00         	nop
700afe88: bf00         	nop
700afe8a: bf00         	nop
700afe8c: bf00         	nop
700afe8e: bf00         	nop

700afe90 <HwiP_clearInt>:
; {
700afe90: b083         	sub	sp, #0xc
700afe92: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_STS(intNum));
700afe94: f642 10e8    	movw	r0, #0x29e8
700afe98: f2c7 000b    	movt	r0, #0x700b
700afe9c: 6801         	ldr	r1, [r0]
700afe9e: 9802         	ldr	r0, [sp, #0x8]
700afea0: f400 70f0    	and	r0, r0, #0x1e0
700afea4: 4408         	add	r0, r1
700afea6: f200 4004    	addw	r0, r0, #0x404
700afeaa: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700afeac: 9802         	ldr	r0, [sp, #0x8]
700afeae: f000 001f    	and	r0, r0, #0x1f
700afeb2: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)0x1 << bitPos);
700afeb4: 9900         	ldr	r1, [sp]
700afeb6: 2001         	movs	r0, #0x1
700afeb8: 4088         	lsls	r0, r1
700afeba: 9901         	ldr	r1, [sp, #0x4]
700afebc: 6008         	str	r0, [r1]
; }
700afebe: b003         	add	sp, #0xc
700afec0: 4770         	bx	lr
700afec2: bf00         	nop
700afec4: bf00         	nop
700afec6: bf00         	nop
700afec8: bf00         	nop
700afeca: bf00         	nop
700afecc: bf00         	nop
700afece: bf00         	nop

700afed0 <HwiP_post>:
; {
700afed0: b580         	push	{r7, lr}
700afed2: b084         	sub	sp, #0x10
700afed4: 9003         	str	r0, [sp, #0xc]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_RAW(intNum));
700afed6: f642 10e8    	movw	r0, #0x29e8
700afeda: f2c7 000b    	movt	r0, #0x700b
700afede: 6801         	ldr	r1, [r0]
700afee0: 9803         	ldr	r0, [sp, #0xc]
700afee2: f400 70f0    	and	r0, r0, #0x1e0
700afee6: 4408         	add	r0, r1
700afee8: f500 6080    	add.w	r0, r0, #0x400
700afeec: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700afeee: 9803         	ldr	r0, [sp, #0xc]
700afef0: f000 001f    	and	r0, r0, #0x1f
700afef4: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700afef6: 9901         	ldr	r1, [sp, #0x4]
700afef8: 2001         	movs	r0, #0x1
700afefa: 4088         	lsls	r0, r1
700afefc: 9902         	ldr	r1, [sp, #0x8]
700afefe: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700aff00: f7ff feb6    	bl	0x700afc70 <Hwip_dataAndInstructionBarrier> @ imm = #-0x294
; }
700aff04: b004         	add	sp, #0x10
700aff06: bd80         	pop	{r7, pc}
700aff08: bf00         	nop
700aff0a: bf00         	nop
700aff0c: bf00         	nop
700aff0e: bf00         	nop

700aff10 <HwiP_Params_init>:
; {
700aff10: b081         	sub	sp, #0x4
700aff12: 9000         	str	r0, [sp]
;     params->intNum = 0;
700aff14: 9900         	ldr	r1, [sp]
700aff16: 2000         	movs	r0, #0x0
700aff18: 6008         	str	r0, [r1]
;     params->callback = NULL;
700aff1a: 9900         	ldr	r1, [sp]
700aff1c: 6048         	str	r0, [r1, #0x4]
;     params->args = NULL;
700aff1e: 9900         	ldr	r1, [sp]
700aff20: 6088         	str	r0, [r1, #0x8]
;     params->eventId = 0; /* NOT USED */
700aff22: 9900         	ldr	r1, [sp]
700aff24: 8188         	strh	r0, [r1, #0xc]
;     params->priority = (HwiP_MAX_PRIORITY-1U);
700aff26: 9a00         	ldr	r2, [sp]
700aff28: 210f         	movs	r1, #0xf
700aff2a: 7391         	strb	r1, [r2, #0xe]
;     params->isFIQ = 0;
700aff2c: 9900         	ldr	r1, [sp]
700aff2e: 73c8         	strb	r0, [r1, #0xf]
;     params->isPulse = 0;
700aff30: 9900         	ldr	r1, [sp]
700aff32: 7408         	strb	r0, [r1, #0x10]
; }
700aff34: b001         	add	sp, #0x4
700aff36: 4770         	bx	lr
700aff38: bf00         	nop
700aff3a: bf00         	nop
700aff3c: bf00         	nop
700aff3e: bf00         	nop

700aff40 <HwiP_construct>:
; {
700aff40: b580         	push	{r7, lr}
700aff42: b084         	sub	sp, #0x10
700aff44: 9003         	str	r0, [sp, #0xc]
700aff46: 9102         	str	r1, [sp, #0x8]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700aff48: 9803         	ldr	r0, [sp, #0xc]
700aff4a: 9001         	str	r0, [sp, #0x4]
700aff4c: 2001         	movs	r0, #0x1
;     DebugP_assertNoLog( sizeof(HwiP_Struct) <= sizeof(HwiP_Object) );
700aff4e: f001 f9a7    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x134e
;     DebugP_assertNoLog( params->callback != NULL );
700aff52: 9802         	ldr	r0, [sp, #0x8]
700aff54: 6840         	ldr	r0, [r0, #0x4]
700aff56: 2800         	cmp	r0, #0x0
700aff58: bf18         	it	ne
700aff5a: 2001         	movne	r0, #0x1
700aff5c: f001 f9a0    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x1340
;     DebugP_assertNoLog( params->intNum < HwiP_MAX_INTERRUPTS );
700aff60: 9802         	ldr	r0, [sp, #0x8]
700aff62: 6801         	ldr	r1, [r0]
700aff64: 2000         	movs	r0, #0x0
700aff66: 9000         	str	r0, [sp]
700aff68: f5b1 7f00    	cmp.w	r1, #0x200
700aff6c: bf38         	it	lo
700aff6e: 2001         	movlo	r0, #0x1
700aff70: f001 f996    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x132c
700aff74: 9800         	ldr	r0, [sp]
;     DebugP_assertNoLog( params->priority < HwiP_MAX_PRIORITY );
700aff76: 9902         	ldr	r1, [sp, #0x8]
700aff78: 7b89         	ldrb	r1, [r1, #0xe]
700aff7a: 2910         	cmp	r1, #0x10
700aff7c: bf38         	it	lo
700aff7e: 2001         	movlo	r0, #0x1
700aff80: f001 f98e    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x131c
;     (void) HwiP_disableInt(params->intNum);
700aff84: 9802         	ldr	r0, [sp, #0x8]
700aff86: 6800         	ldr	r0, [r0]
700aff88: f7ff ff3a    	bl	0x700afe00 <HwiP_disableInt> @ imm = #-0x18c
;     HwiP_clearInt(params->intNum);
700aff8c: 9802         	ldr	r0, [sp, #0x8]
700aff8e: 6800         	ldr	r0, [r0]
700aff90: f7ff ff7e    	bl	0x700afe90 <HwiP_clearInt> @ imm = #-0x104
;     HwiP_setAsFIQ(params->intNum, params->isFIQ);
700aff94: 9902         	ldr	r1, [sp, #0x8]
700aff96: 6808         	ldr	r0, [r1]
700aff98: 7bc9         	ldrb	r1, [r1, #0xf]
700aff9a: f000 f841    	bl	0x700b0020 <HwiP_setAsFIQ> @ imm = #0x82
;     HwiP_setPri(params->intNum, params->priority);
700aff9e: 9902         	ldr	r1, [sp, #0x8]
700affa0: 6808         	ldr	r0, [r1]
700affa2: 7b89         	ldrb	r1, [r1, #0xe]
700affa4: f000 f86c    	bl	0x700b0080 <HwiP_setPri> @ imm = #0xd8
;     HwiP_setAsPulse(params->intNum, params->isPulse);
700affa8: 9902         	ldr	r1, [sp, #0x8]
700affaa: 6808         	ldr	r0, [r1]
700affac: 7c09         	ldrb	r1, [r1, #0x10]
700affae: f000 f87f    	bl	0x700b00b0 <HwiP_setAsPulse> @ imm = #0xfe
;     if(params->isFIQ != 0U)
700affb2: 9802         	ldr	r0, [sp, #0x8]
700affb4: 7bc0         	ldrb	r0, [r0, #0xf]
700affb6: b148         	cbz	r0, 0x700affcc <HwiP_construct+0x8c> @ imm = #0x12
700affb8: e7ff         	b	0x700affba <HwiP_construct+0x7a> @ imm = #-0x2
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_fiq_handler);
700affba: 9802         	ldr	r0, [sp, #0x8]
700affbc: 6800         	ldr	r0, [r0]
700affbe: f240 41d1    	movw	r1, #0x4d1
700affc2: f2c7 010b    	movt	r1, #0x700b
700affc6: f000 f8a3    	bl	0x700b0110 <HwiP_setVecAddr> @ imm = #0x146
;     }
700affca: e008         	b	0x700affde <HwiP_construct+0x9e> @ imm = #0x10
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_irq_handler);
700affcc: 9802         	ldr	r0, [sp, #0x8]
700affce: 6800         	ldr	r0, [r0]
700affd0: f240 71dc    	movw	r1, #0x7dc
700affd4: f2c7 010b    	movt	r1, #0x700b
700affd8: f000 f89a    	bl	0x700b0110 <HwiP_setVecAddr> @ imm = #0x134
700affdc: e7ff         	b	0x700affde <HwiP_construct+0x9e> @ imm = #-0x2
;     gHwiCtrl.isr[params->intNum] = params->callback;
700affde: 9802         	ldr	r0, [sp, #0x8]
700affe0: 6802         	ldr	r2, [r0]
700affe2: 6840         	ldr	r0, [r0, #0x4]
700affe4: f240 0100    	movw	r1, #0x0
700affe8: f2c7 0108    	movt	r1, #0x7008
700affec: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[params->intNum] = params->args;
700afff0: 9802         	ldr	r0, [sp, #0x8]
700afff2: 6802         	ldr	r2, [r0]
700afff4: 6880         	ldr	r0, [r0, #0x8]
700afff6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700afffa: f8c1 0800    	str.w	r0, [r1, #0x800]
;     obj->intNum = params->intNum;
700afffe: 9802         	ldr	r0, [sp, #0x8]
700b0000: 6800         	ldr	r0, [r0]
700b0002: 9901         	ldr	r1, [sp, #0x4]
700b0004: 6008         	str	r0, [r1]
;     HwiP_enableInt(params->intNum);
700b0006: 9802         	ldr	r0, [sp, #0x8]
700b0008: 6800         	ldr	r0, [r0]
700b000a: f7ff fed9    	bl	0x700afdc0 <HwiP_enableInt> @ imm = #-0x24e
700b000e: 2000         	movs	r0, #0x0
;     return SystemP_SUCCESS;
700b0010: b004         	add	sp, #0x10
700b0012: bd80         	pop	{r7, pc}
700b0014: bf00         	nop
700b0016: bf00         	nop
700b0018: bf00         	nop
700b001a: bf00         	nop
700b001c: bf00         	nop
700b001e: bf00         	nop

700b0020 <HwiP_setAsFIQ>:
; {
700b0020: b084         	sub	sp, #0x10
700b0022: 9003         	str	r0, [sp, #0xc]
700b0024: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(intNum));
700b0026: f642 10e8    	movw	r0, #0x29e8
700b002a: f2c7 000b    	movt	r0, #0x700b
700b002e: 6801         	ldr	r1, [r0]
700b0030: 9803         	ldr	r0, [sp, #0xc]
700b0032: f400 70f0    	and	r0, r0, #0x1e0
700b0036: 4408         	add	r0, r1
700b0038: f500 6083    	add.w	r0, r0, #0x418
700b003c: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700b003e: 9803         	ldr	r0, [sp, #0xc]
700b0040: f000 001f    	and	r0, r0, #0x1f
700b0044: 9000         	str	r0, [sp]
;     if(isFIQ != 0U)
700b0046: 9802         	ldr	r0, [sp, #0x8]
700b0048: b148         	cbz	r0, 0x700b005e <HwiP_setAsFIQ+0x3e> @ imm = #0x12
700b004a: e7ff         	b	0x700b004c <HwiP_setAsFIQ+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700b004c: 9900         	ldr	r1, [sp]
700b004e: 2001         	movs	r0, #0x1
700b0050: fa00 f201    	lsl.w	r2, r0, r1
700b0054: 9901         	ldr	r1, [sp, #0x4]
700b0056: 6808         	ldr	r0, [r1]
700b0058: 4310         	orrs	r0, r2
700b005a: 6008         	str	r0, [r1]
;     }
700b005c: e008         	b	0x700b0070 <HwiP_setAsFIQ+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700b005e: 9900         	ldr	r1, [sp]
700b0060: 2001         	movs	r0, #0x1
700b0062: fa00 f201    	lsl.w	r2, r0, r1
700b0066: 9901         	ldr	r1, [sp, #0x4]
700b0068: 6808         	ldr	r0, [r1]
700b006a: 4390         	bics	r0, r2
700b006c: 6008         	str	r0, [r1]
700b006e: e7ff         	b	0x700b0070 <HwiP_setAsFIQ+0x50> @ imm = #-0x2
; }
700b0070: b004         	add	sp, #0x10
700b0072: 4770         	bx	lr
700b0074: bf00         	nop
700b0076: bf00         	nop
700b0078: bf00         	nop
700b007a: bf00         	nop
700b007c: bf00         	nop
700b007e: bf00         	nop

700b0080 <HwiP_setPri>:
; {
700b0080: b083         	sub	sp, #0xc
700b0082: 9002         	str	r0, [sp, #0x8]
700b0084: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_PRI(intNum));
700b0086: f642 10e8    	movw	r0, #0x29e8
700b008a: f2c7 000b    	movt	r0, #0x700b
700b008e: 6800         	ldr	r0, [r0]
700b0090: 9902         	ldr	r1, [sp, #0x8]
700b0092: eb00 0081    	add.w	r0, r0, r1, lsl #2
700b0096: f500 5080    	add.w	r0, r0, #0x1000
700b009a: 9000         	str	r0, [sp]
;     *addr = (priority & 0xFu);
700b009c: 9801         	ldr	r0, [sp, #0x4]
700b009e: f000 000f    	and	r0, r0, #0xf
700b00a2: 9900         	ldr	r1, [sp]
700b00a4: 6008         	str	r0, [r1]
; }
700b00a6: b003         	add	sp, #0xc
700b00a8: 4770         	bx	lr
700b00aa: bf00         	nop
700b00ac: bf00         	nop
700b00ae: bf00         	nop

700b00b0 <HwiP_setAsPulse>:
; {
700b00b0: b084         	sub	sp, #0x10
700b00b2: 9003         	str	r0, [sp, #0xc]
700b00b4: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700b00b6: f642 10e8    	movw	r0, #0x29e8
700b00ba: f2c7 000b    	movt	r0, #0x700b
700b00be: 6801         	ldr	r1, [r0]
700b00c0: 9803         	ldr	r0, [sp, #0xc]
700b00c2: f400 70f0    	and	r0, r0, #0x1e0
700b00c6: 4408         	add	r0, r1
700b00c8: f200 401c    	addw	r0, r0, #0x41c
700b00cc: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700b00ce: 9803         	ldr	r0, [sp, #0xc]
700b00d0: f000 001f    	and	r0, r0, #0x1f
700b00d4: 9000         	str	r0, [sp]
;     if(isPulse != 0U)
700b00d6: 9802         	ldr	r0, [sp, #0x8]
700b00d8: b148         	cbz	r0, 0x700b00ee <HwiP_setAsPulse+0x3e> @ imm = #0x12
700b00da: e7ff         	b	0x700b00dc <HwiP_setAsPulse+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700b00dc: 9900         	ldr	r1, [sp]
700b00de: 2001         	movs	r0, #0x1
700b00e0: fa00 f201    	lsl.w	r2, r0, r1
700b00e4: 9901         	ldr	r1, [sp, #0x4]
700b00e6: 6808         	ldr	r0, [r1]
700b00e8: 4310         	orrs	r0, r2
700b00ea: 6008         	str	r0, [r1]
;     }
700b00ec: e008         	b	0x700b0100 <HwiP_setAsPulse+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700b00ee: 9900         	ldr	r1, [sp]
700b00f0: 2001         	movs	r0, #0x1
700b00f2: fa00 f201    	lsl.w	r2, r0, r1
700b00f6: 9901         	ldr	r1, [sp, #0x4]
700b00f8: 6808         	ldr	r0, [r1]
700b00fa: 4390         	bics	r0, r2
700b00fc: 6008         	str	r0, [r1]
700b00fe: e7ff         	b	0x700b0100 <HwiP_setAsPulse+0x50> @ imm = #-0x2
; }
700b0100: b004         	add	sp, #0x10
700b0102: 4770         	bx	lr
700b0104: bf00         	nop
700b0106: bf00         	nop
700b0108: bf00         	nop
700b010a: bf00         	nop
700b010c: bf00         	nop
700b010e: bf00         	nop

700b0110 <HwiP_setVecAddr>:
; {
700b0110: b083         	sub	sp, #0xc
700b0112: 9002         	str	r0, [sp, #0x8]
700b0114: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_VEC(intNum));
700b0116: f642 10e8    	movw	r0, #0x29e8
700b011a: f2c7 000b    	movt	r0, #0x700b
700b011e: 6800         	ldr	r0, [r0]
700b0120: 9902         	ldr	r1, [sp, #0x8]
700b0122: eb00 0081    	add.w	r0, r0, r1, lsl #2
700b0126: f500 5000    	add.w	r0, r0, #0x2000
700b012a: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)vecAddr & 0xFFFFFFFCU);
700b012c: 9801         	ldr	r0, [sp, #0x4]
700b012e: f020 0003    	bic	r0, r0, #0x3
700b0132: 9900         	ldr	r1, [sp]
700b0134: 6008         	str	r0, [r1]
; }
700b0136: b003         	add	sp, #0xc
700b0138: 4770         	bx	lr
700b013a: bf00         	nop
700b013c: bf00         	nop
700b013e: bf00         	nop

700b0140 <HwiP_destruct>:
; {
700b0140: b580         	push	{r7, lr}
700b0142: b084         	sub	sp, #0x10
700b0144: 9003         	str	r0, [sp, #0xc]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700b0146: 9803         	ldr	r0, [sp, #0xc]
700b0148: 9002         	str	r0, [sp, #0x8]
;    (void) HwiP_disableInt(obj->intNum);
700b014a: 9802         	ldr	r0, [sp, #0x8]
700b014c: 6800         	ldr	r0, [r0]
700b014e: f7ff fe57    	bl	0x700afe00 <HwiP_disableInt> @ imm = #-0x352
;     HwiP_clearInt(obj->intNum);
700b0152: 9802         	ldr	r0, [sp, #0x8]
700b0154: 6800         	ldr	r0, [r0]
700b0156: f7ff fe9b    	bl	0x700afe90 <HwiP_clearInt> @ imm = #-0x2ca
;     HwiP_setAsFIQ(obj->intNum, 0);
700b015a: 9802         	ldr	r0, [sp, #0x8]
700b015c: 6800         	ldr	r0, [r0]
700b015e: 2100         	movs	r1, #0x0
700b0160: 9101         	str	r1, [sp, #0x4]
700b0162: f7ff ff5d    	bl	0x700b0020 <HwiP_setAsFIQ> @ imm = #-0x146
;     HwiP_setPri(obj->intNum, HwiP_MAX_PRIORITY-1U);
700b0166: 9802         	ldr	r0, [sp, #0x8]
700b0168: 6800         	ldr	r0, [r0]
700b016a: 210f         	movs	r1, #0xf
700b016c: f7ff ff88    	bl	0x700b0080 <HwiP_setPri> @ imm = #-0xf0
700b0170: 9901         	ldr	r1, [sp, #0x4]
;     HwiP_setAsPulse(obj->intNum, 0);
700b0172: 9802         	ldr	r0, [sp, #0x8]
700b0174: 6800         	ldr	r0, [r0]
700b0176: f7ff ff9b    	bl	0x700b00b0 <HwiP_setAsPulse> @ imm = #-0xca
;     HwiP_setVecAddr(obj->intNum, (uintptr_t)HwiP_irq_handler);
700b017a: 9802         	ldr	r0, [sp, #0x8]
700b017c: 6800         	ldr	r0, [r0]
700b017e: f240 71dc    	movw	r1, #0x7dc
700b0182: f2c7 010b    	movt	r1, #0x700b
700b0186: f7ff ffc3    	bl	0x700b0110 <HwiP_setVecAddr> @ imm = #-0x7a
700b018a: 9801         	ldr	r0, [sp, #0x4]
;     gHwiCtrl.isr[obj->intNum] = NULL;
700b018c: 9902         	ldr	r1, [sp, #0x8]
700b018e: 680a         	ldr	r2, [r1]
700b0190: f240 0100    	movw	r1, #0x0
700b0194: f2c7 0108    	movt	r1, #0x7008
700b0198: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[obj->intNum] = NULL;
700b019c: 9a02         	ldr	r2, [sp, #0x8]
700b019e: 6812         	ldr	r2, [r2]
700b01a0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700b01a4: f8c1 0800    	str.w	r0, [r1, #0x800]
; }
700b01a8: b004         	add	sp, #0x10
700b01aa: bd80         	pop	{r7, pc}
700b01ac: bf00         	nop
700b01ae: bf00         	nop

700b01b0 <HwiP_init>:
; {
700b01b0: b580         	push	{r7, lr}
700b01b2: b084         	sub	sp, #0x10
;     (void) HwiP_disable();
700b01b4: f000 ebb4    	blx	0x700b0920 <HwiP_disable> @ imm = #0x768
;     (void) HwiP_disableFIQ();
700b01b8: f000 ebba    	blx	0x700b0930 <HwiP_disableFIQ> @ imm = #0x774
;     DebugP_assertNoLog(gHwiConfig.intcBaseAddr != 0U);
700b01bc: f642 10e8    	movw	r0, #0x29e8
700b01c0: f2c7 000b    	movt	r0, #0x700b
700b01c4: 6800         	ldr	r0, [r0]
700b01c6: 2800         	cmp	r0, #0x0
700b01c8: bf18         	it	ne
700b01ca: 2001         	movne	r0, #0x1
700b01cc: f001 f868    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x10d0
;     gHwiCtrl.spuriousIRQCount = 0;
700b01d0: f240 0100    	movw	r1, #0x0
700b01d4: f2c7 0108    	movt	r1, #0x7008
700b01d8: f44f 5280    	mov.w	r2, #0x1000
700b01dc: 2000         	movs	r0, #0x0
700b01de: 5088         	str	r0, [r1, r2]
700b01e0: f241 0204    	movw	r2, #0x1004
;     gHwiCtrl.spuriousFIQCount = 0;
700b01e4: 5088         	str	r0, [r1, r2]
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700b01e6: 9003         	str	r0, [sp, #0xc]
700b01e8: e7ff         	b	0x700b01ea <HwiP_init+0x3a> @ imm = #-0x2
700b01ea: 9903         	ldr	r1, [sp, #0xc]
700b01ec: 2000         	movs	r0, #0x0
700b01ee: ebb0 2f51    	cmp.w	r0, r1, lsr #9
700b01f2: d11d         	bne	0x700b0230 <HwiP_init+0x80> @ imm = #0x3a
700b01f4: e7ff         	b	0x700b01f6 <HwiP_init+0x46> @ imm = #-0x2
;         gHwiCtrl.isr[i] = NULL;
700b01f6: 9a03         	ldr	r2, [sp, #0xc]
700b01f8: f240 0100    	movw	r1, #0x0
700b01fc: f2c7 0108    	movt	r1, #0x7008
700b0200: 2000         	movs	r0, #0x0
700b0202: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gHwiCtrl.isrArgs[i] = NULL;
700b0206: 9a03         	ldr	r2, [sp, #0xc]
700b0208: eb01 0182    	add.w	r1, r1, r2, lsl #2
700b020c: f8c1 0800    	str.w	r0, [r1, #0x800]
;         HwiP_setPri(i, 0xF);
700b0210: 9803         	ldr	r0, [sp, #0xc]
700b0212: 210f         	movs	r1, #0xf
700b0214: f7ff ff34    	bl	0x700b0080 <HwiP_setPri> @ imm = #-0x198
;         HwiP_setVecAddr(i, (uintptr_t)HwiP_irq_handler);
700b0218: 9803         	ldr	r0, [sp, #0xc]
700b021a: f240 71dc    	movw	r1, #0x7dc
700b021e: f2c7 010b    	movt	r1, #0x700b
700b0222: f7ff ff75    	bl	0x700b0110 <HwiP_setVecAddr> @ imm = #-0x116
;     }
700b0226: e7ff         	b	0x700b0228 <HwiP_init+0x78> @ imm = #-0x2
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700b0228: 9803         	ldr	r0, [sp, #0xc]
700b022a: 3001         	adds	r0, #0x1
700b022c: 9003         	str	r0, [sp, #0xc]
700b022e: e7dc         	b	0x700b01ea <HwiP_init+0x3a> @ imm = #-0x48
700b0230: 2000         	movs	r0, #0x0
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700b0232: 9003         	str	r0, [sp, #0xc]
700b0234: e7ff         	b	0x700b0236 <HwiP_init+0x86> @ imm = #-0x2
700b0236: 9803         	ldr	r0, [sp, #0xc]
700b0238: 280f         	cmp	r0, #0xf
700b023a: d838         	bhi	0x700b02ae <HwiP_init+0xfe> @ imm = #0x70
700b023c: e7ff         	b	0x700b023e <HwiP_init+0x8e> @ imm = #-0x2
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(i*INTERRUPT_VALUE));
700b023e: f642 11e8    	movw	r1, #0x29e8
700b0242: f2c7 010b    	movt	r1, #0x700b
700b0246: 6808         	ldr	r0, [r1]
700b0248: 9a03         	ldr	r2, [sp, #0xc]
700b024a: f002 020f    	and	r2, r2, #0xf
700b024e: eb00 1042    	add.w	r0, r0, r2, lsl #5
700b0252: f200 400c    	addw	r0, r0, #0x40c
700b0256: 9002         	str	r0, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700b0258: 9a02         	ldr	r2, [sp, #0x8]
700b025a: f04f 30ff    	mov.w	r0, #0xffffffff
700b025e: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_STS(i*INTERRUPT_VALUE));
700b0260: 680a         	ldr	r2, [r1]
700b0262: 9b03         	ldr	r3, [sp, #0xc]
700b0264: f003 030f    	and	r3, r3, #0xf
700b0268: eb02 1243    	add.w	r2, r2, r3, lsl #5
700b026c: f202 4204    	addw	r2, r2, #0x404
700b0270: 9202         	str	r2, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700b0272: 9a02         	ldr	r2, [sp, #0x8]
700b0274: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(i*INTERRUPT_VALUE));
700b0276: 6808         	ldr	r0, [r1]
700b0278: 9a03         	ldr	r2, [sp, #0xc]
700b027a: f002 020f    	and	r2, r2, #0xf
700b027e: eb00 1042    	add.w	r0, r0, r2, lsl #5
700b0282: f200 401c    	addw	r0, r0, #0x41c
700b0286: 9002         	str	r0, [sp, #0x8]
;         *addr = 0x0u;
700b0288: 9a02         	ldr	r2, [sp, #0x8]
700b028a: 2000         	movs	r0, #0x0
700b028c: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(i*INTERRUPT_VALUE));
700b028e: 6809         	ldr	r1, [r1]
700b0290: 9a03         	ldr	r2, [sp, #0xc]
700b0292: f002 020f    	and	r2, r2, #0xf
700b0296: eb01 1142    	add.w	r1, r1, r2, lsl #5
700b029a: f501 6183    	add.w	r1, r1, #0x418
700b029e: 9102         	str	r1, [sp, #0x8]
;         *addr = 0x0u;
700b02a0: 9902         	ldr	r1, [sp, #0x8]
700b02a2: 6008         	str	r0, [r1]
;     }
700b02a4: e7ff         	b	0x700b02a6 <HwiP_init+0xf6> @ imm = #-0x2
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700b02a6: 9803         	ldr	r0, [sp, #0xc]
700b02a8: 3001         	adds	r0, #0x1
700b02aa: 9003         	str	r0, [sp, #0xc]
700b02ac: e7c3         	b	0x700b0236 <HwiP_init+0x86> @ imm = #-0x7a
;         gdummy = HwiP_getIRQVecAddr();
700b02ae: f000 f817    	bl	0x700b02e0 <HwiP_getIRQVecAddr> @ imm = #0x2e
700b02b2: f245 010c    	movw	r1, #0x500c
700b02b6: f2c7 0108    	movt	r1, #0x7008
700b02ba: 9100         	str	r1, [sp]
700b02bc: 6008         	str	r0, [r1]
;         gdummy = HwiP_getFIQVecAddr();
700b02be: f000 f81f    	bl	0x700b0300 <HwiP_getFIQVecAddr> @ imm = #0x3e
700b02c2: 9900         	ldr	r1, [sp]
700b02c4: 6008         	str	r0, [r1]
700b02c6: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700b02c8: 9001         	str	r0, [sp, #0x4]
700b02ca: f000 f829    	bl	0x700b0320 <HwiP_ackIRQ> @ imm = #0x52
700b02ce: 9801         	ldr	r0, [sp, #0x4]
;         HwiP_ackFIQ(0);
700b02d0: f000 f836    	bl	0x700b0340 <HwiP_ackFIQ> @ imm = #0x6c
;     HwiP_enableVIC();
700b02d4: f000 eb48    	blx	0x700b0968 <HwiP_enableVIC> @ imm = #0x690
;     HwiP_enableFIQ();
700b02d8: f000 eb3a    	blx	0x700b0950 <HwiP_enableFIQ> @ imm = #0x674
; }
700b02dc: b004         	add	sp, #0x10
700b02de: bd80         	pop	{r7, pc}

700b02e0 <HwiP_getIRQVecAddr>:
; {
700b02e0: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b02e2: f642 10e8    	movw	r0, #0x29e8
700b02e6: f2c7 000b    	movt	r0, #0x700b
700b02ea: 6800         	ldr	r0, [r0]
700b02ec: 3018         	adds	r0, #0x18
700b02ee: 9000         	str	r0, [sp]
;     return *addr;
700b02f0: 9800         	ldr	r0, [sp]
700b02f2: 6800         	ldr	r0, [r0]
700b02f4: b001         	add	sp, #0x4
700b02f6: 4770         	bx	lr
700b02f8: bf00         	nop
700b02fa: bf00         	nop
700b02fc: bf00         	nop
700b02fe: bf00         	nop

700b0300 <HwiP_getFIQVecAddr>:
; {
700b0300: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0302: f642 10e8    	movw	r0, #0x29e8
700b0306: f2c7 000b    	movt	r0, #0x700b
700b030a: 6800         	ldr	r0, [r0]
700b030c: 301c         	adds	r0, #0x1c
700b030e: 9000         	str	r0, [sp]
;     return *addr;
700b0310: 9800         	ldr	r0, [sp]
700b0312: 6800         	ldr	r0, [r0]
700b0314: b001         	add	sp, #0x4
700b0316: 4770         	bx	lr
700b0318: bf00         	nop
700b031a: bf00         	nop
700b031c: bf00         	nop
700b031e: bf00         	nop

700b0320 <HwiP_ackIRQ>:
; {
700b0320: b082         	sub	sp, #0x8
700b0322: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b0324: f642 10e8    	movw	r0, #0x29e8
700b0328: f2c7 000b    	movt	r0, #0x700b
700b032c: 6800         	ldr	r0, [r0]
700b032e: 3018         	adds	r0, #0x18
700b0330: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0332: 9801         	ldr	r0, [sp, #0x4]
700b0334: 9900         	ldr	r1, [sp]
700b0336: 6008         	str	r0, [r1]
; }
700b0338: b002         	add	sp, #0x8
700b033a: 4770         	bx	lr
700b033c: bf00         	nop
700b033e: bf00         	nop

700b0340 <HwiP_ackFIQ>:
; {
700b0340: b082         	sub	sp, #0x8
700b0342: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0344: f642 10e8    	movw	r0, #0x29e8
700b0348: f2c7 000b    	movt	r0, #0x700b
700b034c: 6800         	ldr	r0, [r0]
700b034e: 301c         	adds	r0, #0x1c
700b0350: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0352: 9801         	ldr	r0, [sp, #0x4]
700b0354: 9900         	ldr	r1, [sp]
700b0356: 6008         	str	r0, [r1]
; }
700b0358: b002         	add	sp, #0x8
700b035a: 4770         	bx	lr
700b035c: bf00         	nop
700b035e: bf00         	nop

700b0360 <HwiP_inISR>:
; {
700b0360: b580         	push	{r7, lr}
700b0362: b082         	sub	sp, #0x8
;     uint32_t mode = (HwiP_getCPSR() & 0x1FU);
700b0364: f000 eb10    	blx	0x700b0988 <HwiP_getCPSR> @ imm = #0x620
700b0368: f000 001f    	and	r0, r0, #0x1f
700b036c: 9001         	str	r0, [sp, #0x4]
700b036e: 2000         	movs	r0, #0x0
;     uint32_t result =0;
700b0370: 9000         	str	r0, [sp]
;     if(mode != ARMV7R_SYSTEM_MODE)
700b0372: 9801         	ldr	r0, [sp, #0x4]
700b0374: 281f         	cmp	r0, #0x1f
700b0376: d003         	beq	0x700b0380 <HwiP_inISR+0x20> @ imm = #0x6
700b0378: e7ff         	b	0x700b037a <HwiP_inISR+0x1a> @ imm = #-0x2
700b037a: 2001         	movs	r0, #0x1
;          result= 1;
700b037c: 9000         	str	r0, [sp]
;     }
700b037e: e7ff         	b	0x700b0380 <HwiP_inISR+0x20> @ imm = #-0x2
;     return result;
700b0380: 9800         	ldr	r0, [sp]
700b0382: b002         	add	sp, #0x8
700b0384: bd80         	pop	{r7, pc}
		...
700b038e: 0000         	movs	r0, r0

700b0390 <HwiP_irq_handler_c>:
; {
700b0390: b580         	push	{r7, lr}
700b0392: b086         	sub	sp, #0x18
700b0394: a804         	add	r0, sp, #0x10
;     status = HwiP_getIRQ(&intNum);
700b0396: f000 f843    	bl	0x700b0420 <HwiP_getIRQ> @ imm = #0x86
700b039a: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700b039c: 9805         	ldr	r0, [sp, #0x14]
700b039e: bb78         	cbnz	r0, 0x700b0400 <HwiP_irq_handler_c+0x70> @ imm = #0x5e
700b03a0: e7ff         	b	0x700b03a2 <HwiP_irq_handler_c+0x12> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700b03a2: 9804         	ldr	r0, [sp, #0x10]
700b03a4: f000 f864    	bl	0x700b0470 <HwiP_isPulse> @ imm = #0xc8
700b03a8: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700b03aa: 9803         	ldr	r0, [sp, #0xc]
700b03ac: b120         	cbz	r0, 0x700b03b8 <HwiP_irq_handler_c+0x28> @ imm = #0x8
700b03ae: e7ff         	b	0x700b03b0 <HwiP_irq_handler_c+0x20> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b03b0: 9804         	ldr	r0, [sp, #0x10]
700b03b2: f7ff fd6d    	bl	0x700afe90 <HwiP_clearInt> @ imm = #-0x526
;         }
700b03b6: e7ff         	b	0x700b03b8 <HwiP_irq_handler_c+0x28> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700b03b8: 9904         	ldr	r1, [sp, #0x10]
700b03ba: f240 0000    	movw	r0, #0x0
700b03be: f2c7 0008    	movt	r0, #0x7008
700b03c2: f850 1021    	ldr.w	r1, [r0, r1, lsl #2]
700b03c6: 9102         	str	r1, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700b03c8: 9904         	ldr	r1, [sp, #0x10]
700b03ca: eb00 0081    	add.w	r0, r0, r1, lsl #2
700b03ce: f8d0 0800    	ldr.w	r0, [r0, #0x800]
700b03d2: 9001         	str	r0, [sp, #0x4]
;         HwiP_enable();
700b03d4: f000 eab4    	blx	0x700b0940 <HwiP_enable> @ imm = #0x568
;         if(isr!=NULL)
700b03d8: 9802         	ldr	r0, [sp, #0x8]
700b03da: b120         	cbz	r0, 0x700b03e6 <HwiP_irq_handler_c+0x56> @ imm = #0x8
700b03dc: e7ff         	b	0x700b03de <HwiP_irq_handler_c+0x4e> @ imm = #-0x2
;             isr(args);
700b03de: 9902         	ldr	r1, [sp, #0x8]
700b03e0: 9801         	ldr	r0, [sp, #0x4]
700b03e2: 4788         	blx	r1
;         }
700b03e4: e7ff         	b	0x700b03e6 <HwiP_irq_handler_c+0x56> @ imm = #-0x2
;         (void)HwiP_disable();
700b03e6: f000 ea9c    	blx	0x700b0920 <HwiP_disable> @ imm = #0x538
;         if(isPulse == 0U)
700b03ea: 9803         	ldr	r0, [sp, #0xc]
700b03ec: b920         	cbnz	r0, 0x700b03f8 <HwiP_irq_handler_c+0x68> @ imm = #0x8
700b03ee: e7ff         	b	0x700b03f0 <HwiP_irq_handler_c+0x60> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b03f0: 9804         	ldr	r0, [sp, #0x10]
700b03f2: f7ff fd4d    	bl	0x700afe90 <HwiP_clearInt> @ imm = #-0x566
;         }
700b03f6: e7ff         	b	0x700b03f8 <HwiP_irq_handler_c+0x68> @ imm = #-0x2
;         HwiP_ackIRQ(intNum);
700b03f8: 9804         	ldr	r0, [sp, #0x10]
700b03fa: f000 f859    	bl	0x700b04b0 <HwiP_ackIRQ> @ imm = #0xb2
;     }
700b03fe: e00c         	b	0x700b041a <HwiP_irq_handler_c+0x8a> @ imm = #0x18
;         gHwiCtrl.spuriousIRQCount++;
700b0400: f240 0100    	movw	r1, #0x0
700b0404: f2c7 0108    	movt	r1, #0x7008
700b0408: f44f 5280    	mov.w	r2, #0x1000
700b040c: 5888         	ldr	r0, [r1, r2]
700b040e: 3001         	adds	r0, #0x1
700b0410: 5088         	str	r0, [r1, r2]
700b0412: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700b0414: f000 f84c    	bl	0x700b04b0 <HwiP_ackIRQ> @ imm = #0x98
700b0418: e7ff         	b	0x700b041a <HwiP_irq_handler_c+0x8a> @ imm = #-0x2
; }
700b041a: b006         	add	sp, #0x18
700b041c: bd80         	pop	{r7, pc}
700b041e: bf00         	nop

700b0420 <HwiP_getIRQ>:
; {
700b0420: b084         	sub	sp, #0x10
700b0422: 9003         	str	r0, [sp, #0xc]
700b0424: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700b0428: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700b042a: 9903         	ldr	r1, [sp, #0xc]
700b042c: 2000         	movs	r0, #0x0
700b042e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTIRQ);
700b0430: f642 10e8    	movw	r0, #0x29e8
700b0434: f2c7 000b    	movt	r0, #0x700b
700b0438: 6800         	ldr	r0, [r0]
700b043a: 3020         	adds	r0, #0x20
700b043c: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700b043e: 9802         	ldr	r0, [sp, #0x8]
700b0440: 6800         	ldr	r0, [r0]
700b0442: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700b0444: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700b0448: 0600         	lsls	r0, r0, #0x18
700b044a: 2800         	cmp	r0, #0x0
700b044c: d508         	bpl	0x700b0460 <HwiP_getIRQ+0x40> @ imm = #0x10
700b044e: e7ff         	b	0x700b0450 <HwiP_getIRQ+0x30> @ imm = #-0x2
;         *intNum = (value & (HwiP_MAX_INTERRUPTS-1U));
700b0450: 9800         	ldr	r0, [sp]
700b0452: f36f 205f    	bfc	r0, #9, #23
700b0456: 9903         	ldr	r1, [sp, #0xc]
700b0458: 6008         	str	r0, [r1]
700b045a: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700b045c: 9001         	str	r0, [sp, #0x4]
;     }
700b045e: e7ff         	b	0x700b0460 <HwiP_getIRQ+0x40> @ imm = #-0x2
;     return status;
700b0460: 9801         	ldr	r0, [sp, #0x4]
700b0462: b004         	add	sp, #0x10
700b0464: 4770         	bx	lr
700b0466: bf00         	nop
700b0468: bf00         	nop
700b046a: bf00         	nop
700b046c: bf00         	nop
700b046e: bf00         	nop

700b0470 <HwiP_isPulse>:
; {
700b0470: b083         	sub	sp, #0xc
700b0472: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700b0474: f642 10e8    	movw	r0, #0x29e8
700b0478: f2c7 000b    	movt	r0, #0x700b
700b047c: 6801         	ldr	r1, [r0]
700b047e: 9802         	ldr	r0, [sp, #0x8]
700b0480: f400 70f0    	and	r0, r0, #0x1e0
700b0484: 4408         	add	r0, r1
700b0486: f200 401c    	addw	r0, r0, #0x41c
700b048a: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700b048c: 9802         	ldr	r0, [sp, #0x8]
700b048e: f000 001f    	and	r0, r0, #0x1f
700b0492: 9000         	str	r0, [sp]
;     return ((*addr >> bitPos) & 0x1u );
700b0494: 9801         	ldr	r0, [sp, #0x4]
700b0496: 6800         	ldr	r0, [r0]
700b0498: 9900         	ldr	r1, [sp]
700b049a: 40c8         	lsrs	r0, r1
700b049c: f000 0001    	and	r0, r0, #0x1
700b04a0: b003         	add	sp, #0xc
700b04a2: 4770         	bx	lr
700b04a4: bf00         	nop
700b04a6: bf00         	nop
700b04a8: bf00         	nop
700b04aa: bf00         	nop
700b04ac: bf00         	nop
700b04ae: bf00         	nop

700b04b0 <HwiP_ackIRQ>:
; {
700b04b0: b082         	sub	sp, #0x8
700b04b2: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b04b4: f642 10e8    	movw	r0, #0x29e8
700b04b8: f2c7 000b    	movt	r0, #0x700b
700b04bc: 6800         	ldr	r0, [r0]
700b04be: 3018         	adds	r0, #0x18
700b04c0: 9000         	str	r0, [sp]
;     *addr= intNum;
700b04c2: 9801         	ldr	r0, [sp, #0x4]
700b04c4: 9900         	ldr	r1, [sp]
700b04c6: 6008         	str	r0, [r1]
; }
700b04c8: b002         	add	sp, #0x8
700b04ca: 4770         	bx	lr
700b04cc: bf00         	nop
700b04ce: bf00         	nop

700b04d0 <HwiP_fiq_handler>:
; {
700b04d0: b5df         	push	{r0, r1, r2, r3, r4, r6, r7, lr}
700b04d2: af06         	add	r7, sp, #0x18
700b04d4: b086         	sub	sp, #0x18
700b04d6: 466c         	mov	r4, sp
700b04d8: f36f 0402    	bfc	r4, #0, #3
700b04dc: 46a5         	mov	sp, r4
;     gdummy = HwiP_getFIQVecAddr();
700b04de: f000 f867    	bl	0x700b05b0 <HwiP_getFIQVecAddr> @ imm = #0xce
700b04e2: f244 188c    	movw	r8, #0x418c
700b04e6: f2c7 0808    	movt	r8, #0x7008
700b04ea: f8c8 0000    	str.w	r0, [r8]
700b04ee: a804         	add	r0, sp, #0x10
;     status = HwiP_getFIQ(&intNum);
700b04f0: f000 f86e    	bl	0x700b05d0 <HwiP_getFIQ> @ imm = #0xdc
700b04f4: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700b04f6: f8dd 8014    	ldr.w	r8, [sp, #0x14]
700b04fa: f1b8 0f00    	cmp.w	r8, #0x0
700b04fe: d13b         	bne	0x700b0578 <HwiP_fiq_handler+0xa8> @ imm = #0x76
700b0500: e7ff         	b	0x700b0502 <HwiP_fiq_handler+0x32> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700b0502: 9804         	ldr	r0, [sp, #0x10]
700b0504: f7ff ffb4    	bl	0x700b0470 <HwiP_isPulse> @ imm = #-0x98
700b0508: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700b050a: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700b050e: f1b8 0f00    	cmp.w	r8, #0x0
700b0512: d004         	beq	0x700b051e <HwiP_fiq_handler+0x4e> @ imm = #0x8
700b0514: e7ff         	b	0x700b0516 <HwiP_fiq_handler+0x46> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b0516: 9804         	ldr	r0, [sp, #0x10]
700b0518: f7ff fcba    	bl	0x700afe90 <HwiP_clearInt> @ imm = #-0x68c
;         }
700b051c: e7ff         	b	0x700b051e <HwiP_fiq_handler+0x4e> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700b051e: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700b0522: f240 0800    	movw	r8, #0x0
700b0526: f2c7 0808    	movt	r8, #0x7008
700b052a: f858 9029    	ldr.w	r9, [r8, r9, lsl #2]
700b052e: f8cd 9008    	str.w	r9, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700b0532: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700b0536: eb08 0889    	add.w	r8, r8, r9, lsl #2
700b053a: f8d8 8800    	ldr.w	r8, [r8, #0x800]
700b053e: f8cd 8004    	str.w	r8, [sp, #0x4]
;         if(isr!=NULL)
700b0542: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700b0546: f1b8 0f00    	cmp.w	r8, #0x0
700b054a: d005         	beq	0x700b0558 <HwiP_fiq_handler+0x88> @ imm = #0xa
700b054c: e7ff         	b	0x700b054e <HwiP_fiq_handler+0x7e> @ imm = #-0x2
;             isr(args);
700b054e: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700b0552: 9801         	ldr	r0, [sp, #0x4]
700b0554: 47c0         	blx	r8
;         }
700b0556: e7ff         	b	0x700b0558 <HwiP_fiq_handler+0x88> @ imm = #-0x2
;         (void)HwiP_disableFIQ();
700b0558: f000 e9ea    	blx	0x700b0930 <HwiP_disableFIQ> @ imm = #0x3d4
;         if(isPulse == 0U)
700b055c: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700b0560: f1b8 0f00    	cmp.w	r8, #0x0
700b0564: d104         	bne	0x700b0570 <HwiP_fiq_handler+0xa0> @ imm = #0x8
700b0566: e7ff         	b	0x700b0568 <HwiP_fiq_handler+0x98> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b0568: 9804         	ldr	r0, [sp, #0x10]
700b056a: f7ff fc91    	bl	0x700afe90 <HwiP_clearInt> @ imm = #-0x6de
;         }
700b056e: e7ff         	b	0x700b0570 <HwiP_fiq_handler+0xa0> @ imm = #-0x2
;         HwiP_ackFIQ(intNum);
700b0570: 9804         	ldr	r0, [sp, #0x10]
700b0572: f000 f855    	bl	0x700b0620 <HwiP_ackFIQ> @ imm = #0xaa
;     }
700b0576: e00f         	b	0x700b0598 <HwiP_fiq_handler+0xc8> @ imm = #0x1e
;         gHwiCtrl.spuriousFIQCount++;
700b0578: f240 0900    	movw	r9, #0x0
700b057c: f2c7 0908    	movt	r9, #0x7008
700b0580: f241 0a04    	movw	r10, #0x1004
700b0584: f859 800a    	ldr.w	r8, [r9, r10]
700b0588: f108 0801    	add.w	r8, r8, #0x1
700b058c: f849 800a    	str.w	r8, [r9, r10]
700b0590: 2000         	movs	r0, #0x0
;         HwiP_ackFIQ(0);
700b0592: f000 f845    	bl	0x700b0620 <HwiP_ackFIQ> @ imm = #0x8a
700b0596: e7ff         	b	0x700b0598 <HwiP_fiq_handler+0xc8> @ imm = #-0x2
; }
700b0598: f1a7 0418    	sub.w	r4, r7, #0x18
700b059c: 46a5         	mov	sp, r4
700b059e: e8bd 40df    	pop.w	{r0, r1, r2, r3, r4, r6, r7, lr}
700b05a2: f3de 8f04    	subs	pc, lr, #0x4
700b05a6: bf00         	nop
700b05a8: bf00         	nop
700b05aa: bf00         	nop
700b05ac: bf00         	nop
700b05ae: bf00         	nop

700b05b0 <HwiP_getFIQVecAddr>:
; {
700b05b0: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b05b2: f642 10e8    	movw	r0, #0x29e8
700b05b6: f2c7 000b    	movt	r0, #0x700b
700b05ba: 6800         	ldr	r0, [r0]
700b05bc: 301c         	adds	r0, #0x1c
700b05be: 9000         	str	r0, [sp]
;     return *addr;
700b05c0: 9800         	ldr	r0, [sp]
700b05c2: 6800         	ldr	r0, [r0]
700b05c4: b001         	add	sp, #0x4
700b05c6: 4770         	bx	lr
700b05c8: bf00         	nop
700b05ca: bf00         	nop
700b05cc: bf00         	nop
700b05ce: bf00         	nop

700b05d0 <HwiP_getFIQ>:
; {
700b05d0: b084         	sub	sp, #0x10
700b05d2: 9003         	str	r0, [sp, #0xc]
700b05d4: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700b05d8: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700b05da: 9903         	ldr	r1, [sp, #0xc]
700b05dc: 2000         	movs	r0, #0x0
700b05de: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTFIQ);
700b05e0: f642 10e8    	movw	r0, #0x29e8
700b05e4: f2c7 000b    	movt	r0, #0x700b
700b05e8: 6800         	ldr	r0, [r0]
700b05ea: 3024         	adds	r0, #0x24
700b05ec: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700b05ee: 9802         	ldr	r0, [sp, #0x8]
700b05f0: 6800         	ldr	r0, [r0]
700b05f2: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700b05f4: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700b05f8: 0600         	lsls	r0, r0, #0x18
700b05fa: 2800         	cmp	r0, #0x0
700b05fc: d508         	bpl	0x700b0610 <HwiP_getFIQ+0x40> @ imm = #0x10
700b05fe: e7ff         	b	0x700b0600 <HwiP_getFIQ+0x30> @ imm = #-0x2
;         *intNum = (value & 0x3FFU);
700b0600: 9800         	ldr	r0, [sp]
700b0602: f36f 209f    	bfc	r0, #10, #22
700b0606: 9903         	ldr	r1, [sp, #0xc]
700b0608: 6008         	str	r0, [r1]
700b060a: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700b060c: 9001         	str	r0, [sp, #0x4]
;     }
700b060e: e7ff         	b	0x700b0610 <HwiP_getFIQ+0x40> @ imm = #-0x2
;     return status;
700b0610: 9801         	ldr	r0, [sp, #0x4]
700b0612: b004         	add	sp, #0x10
700b0614: 4770         	bx	lr
700b0616: bf00         	nop
700b0618: bf00         	nop
700b061a: bf00         	nop
700b061c: bf00         	nop
700b061e: bf00         	nop

700b0620 <HwiP_ackFIQ>:
; {
700b0620: b082         	sub	sp, #0x8
700b0622: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0624: f642 10e8    	movw	r0, #0x29e8
700b0628: f2c7 000b    	movt	r0, #0x700b
700b062c: 6800         	ldr	r0, [r0]
700b062e: 301c         	adds	r0, #0x1c
700b0630: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0632: 9801         	ldr	r0, [sp, #0x4]
700b0634: 9900         	ldr	r1, [sp]
700b0636: 6008         	str	r0, [r1]
; }
700b0638: b002         	add	sp, #0x8
700b063a: 4770         	bx	lr
700b063c: bf00         	nop
700b063e: bf00         	nop

700b0640 <HwiP_reserved_handler>:
; {
700b0640: b5d0         	push	{r4, r6, r7, lr}
700b0642: af02         	add	r7, sp, #0x8
700b0644: b082         	sub	sp, #0x8
700b0646: 466c         	mov	r4, sp
700b0648: f36f 0402    	bfc	r4, #0, #3
700b064c: 46a5         	mov	sp, r4
700b064e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0652: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U) { ; }
700b0656: e7ff         	b	0x700b0658 <HwiP_reserved_handler+0x18> @ imm = #-0x2
700b0658: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b065c: f1be 0f00    	cmp.w	lr, #0x0
700b0660: d001         	beq	0x700b0666 <HwiP_reserved_handler+0x26> @ imm = #0x2
700b0662: e7ff         	b	0x700b0664 <HwiP_reserved_handler+0x24> @ imm = #-0x2
700b0664: e7f8         	b	0x700b0658 <HwiP_reserved_handler+0x18> @ imm = #-0x10
; }
700b0666: f1a7 0408    	sub.w	r4, r7, #0x8
700b066a: 46a5         	mov	sp, r4
700b066c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b0670: f3de 8f00    	subs	pc, lr, #0x0
700b0674: bf00         	nop
700b0676: bf00         	nop
700b0678: bf00         	nop
700b067a: bf00         	nop
700b067c: bf00         	nop
700b067e: bf00         	nop

700b0680 <HwiP_undefined_handler>:
; {
700b0680: b5d0         	push	{r4, r6, r7, lr}
700b0682: af02         	add	r7, sp, #0x8
700b0684: b082         	sub	sp, #0x8
700b0686: 466c         	mov	r4, sp
700b0688: f36f 0402    	bfc	r4, #0, #3
700b068c: 46a5         	mov	sp, r4
700b068e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0692: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){  ; }
700b0696: e7ff         	b	0x700b0698 <HwiP_undefined_handler+0x18> @ imm = #-0x2
700b0698: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b069c: f1be 0f00    	cmp.w	lr, #0x0
700b06a0: d001         	beq	0x700b06a6 <HwiP_undefined_handler+0x26> @ imm = #0x2
700b06a2: e7ff         	b	0x700b06a4 <HwiP_undefined_handler+0x24> @ imm = #-0x2
700b06a4: e7f8         	b	0x700b0698 <HwiP_undefined_handler+0x18> @ imm = #-0x10
; }
700b06a6: f1a7 0408    	sub.w	r4, r7, #0x8
700b06aa: 46a5         	mov	sp, r4
700b06ac: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b06b0: f3de 8f00    	subs	pc, lr, #0x0
700b06b4: bf00         	nop
700b06b6: bf00         	nop
700b06b8: bf00         	nop
700b06ba: bf00         	nop
700b06bc: bf00         	nop
700b06be: bf00         	nop

700b06c0 <HwiP_prefetch_abort_handler>:
; {
700b06c0: b5d0         	push	{r4, r6, r7, lr}
700b06c2: af02         	add	r7, sp, #0x8
700b06c4: b082         	sub	sp, #0x8
700b06c6: 466c         	mov	r4, sp
700b06c8: f36f 0402    	bfc	r4, #0, #3
700b06cc: 46a5         	mov	sp, r4
700b06ce: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b06d2: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U)  { ;}
700b06d6: e7ff         	b	0x700b06d8 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x2
700b06d8: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b06dc: f1be 0f00    	cmp.w	lr, #0x0
700b06e0: d001         	beq	0x700b06e6 <HwiP_prefetch_abort_handler+0x26> @ imm = #0x2
700b06e2: e7ff         	b	0x700b06e4 <HwiP_prefetch_abort_handler+0x24> @ imm = #-0x2
700b06e4: e7f8         	b	0x700b06d8 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x10
; }
700b06e6: f1a7 0408    	sub.w	r4, r7, #0x8
700b06ea: 46a5         	mov	sp, r4
700b06ec: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b06f0: f3de 8f04    	subs	pc, lr, #0x4
700b06f4: bf00         	nop
700b06f6: bf00         	nop
700b06f8: bf00         	nop
700b06fa: bf00         	nop
700b06fc: bf00         	nop
700b06fe: bf00         	nop

700b0700 <HwiP_data_abort_handler_c>:
; {
700b0700: b5d0         	push	{r4, r6, r7, lr}
700b0702: af02         	add	r7, sp, #0x8
700b0704: b082         	sub	sp, #0x8
700b0706: 466c         	mov	r4, sp
700b0708: f36f 0402    	bfc	r4, #0, #3
700b070c: 46a5         	mov	sp, r4
700b070e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0712: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){ ; }
700b0716: e7ff         	b	0x700b0718 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x2
700b0718: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b071c: f1be 0f00    	cmp.w	lr, #0x0
700b0720: d001         	beq	0x700b0726 <HwiP_data_abort_handler_c+0x26> @ imm = #0x2
700b0722: e7ff         	b	0x700b0724 <HwiP_data_abort_handler_c+0x24> @ imm = #-0x2
700b0724: e7f8         	b	0x700b0718 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x10
; }
700b0726: f1a7 0408    	sub.w	r4, r7, #0x8
700b072a: 46a5         	mov	sp, r4
700b072c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b0730: f3de 8f04    	subs	pc, lr, #0x4

700b0734 <vPortRestoreTaskContext>:
;         CPS     #SYS_MODE
700b0734: f102001f     	cps	#0x1f
;         portRESTORE_CONTEXT
700b0738: e59f01c8     	ldr	r0, [pc, #0x1c8]        @ 0x700b0908 <pxCurrentTCBConst>
700b073c: e5901000     	ldr	r1, [r0]
700b0740: e591d000     	ldr	sp, [r1]
700b0744: e59f01c0     	ldr	r0, [pc, #0x1c0]        @ 0x700b090c <ulPortTaskHasFPUContextConst>
700b0748: e49d1004     	ldr	r1, [sp], #4
700b074c: e5801000     	str	r1, [r0]
700b0750: e3510000     	cmp	r1, #0
700b0754: 149d0004     	ldrne	r0, [sp], #4
700b0758: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b075c: 1ee10a10     	vmsrne	fpscr, r0
700b0760: f57ff01f     	clrex
700b0764: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b0768: f8bd0a00     	rfeia	sp!

700b076c <HwiP_svc_handler>:
;         portSAVE_CONTEXT
700b076c: f96d051f     	srsdb	sp!, #0x1f
700b0770: f102001f     	cps	#0x1f
700b0774: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b0778: e59f218c     	ldr	r2, [pc, #0x18c]        @ 0x700b090c <ulPortTaskHasFPUContextConst>
700b077c: e5923000     	ldr	r3, [r2]
700b0780: e3530000     	cmp	r3, #0
700b0784: 1ef11a10     	vmrsne	r1, fpscr
700b0788: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b078c: 152d1004     	strne	r1, [sp, #-0x4]!
700b0790: e52d3004     	str	r3, [sp, #-0x4]!
700b0794: e59f016c     	ldr	r0, [pc, #0x16c]        @ 0x700b0908 <pxCurrentTCBConst>
700b0798: e5901000     	ldr	r1, [r0]
700b079c: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700b07a0: e59f0168     	ldr	r0, [pc, #0x168]        @ 0x700b0910 <vTaskSwitchContextConst>
;         BLX     R0
700b07a4: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700b07a8: e59f0158     	ldr	r0, [pc, #0x158]        @ 0x700b0908 <pxCurrentTCBConst>
700b07ac: e5901000     	ldr	r1, [r0]
700b07b0: e591d000     	ldr	sp, [r1]
700b07b4: e59f0150     	ldr	r0, [pc, #0x150]        @ 0x700b090c <ulPortTaskHasFPUContextConst>
700b07b8: e49d1004     	ldr	r1, [sp], #4
700b07bc: e5801000     	str	r1, [r0]
700b07c0: e3510000     	cmp	r1, #0
700b07c4: 149d0004     	ldrne	r0, [sp], #4
700b07c8: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b07cc: 1ee10a10     	vmsrne	fpscr, r0
700b07d0: f57ff01f     	clrex
700b07d4: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b07d8: f8bd0a00     	rfeia	sp!

700b07dc <HwiP_irq_handler>:
;         SUB             lr, lr, #4
700b07dc: e24ee004     	sub	lr, lr, #4
;         PUSH    {lr}
700b07e0: e52de004     	str	lr, [sp, #-0x4]!
;         MRS     lr, SPSR
700b07e4: e14fe000     	mrs	lr, spsr
;         PUSH    {lr}
700b07e8: e52de004     	str	lr, [sp, #-0x4]!
;         CPS  #SVC_MODE
700b07ec: f1020013     	cps	#0x13
;         PUSH    {r0-r4, r12}
700b07f0: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         LDR     r3, ulPortInterruptNestingConst
700b07f4: e59f3118     	ldr	r3, [pc, #0x118]        @ 0x700b0914 <ulPortInterruptNestingConst>
;         LDR     r1, [r3]
700b07f8: e5931000     	ldr	r1, [r3]
;         ADD     r4, r1, #1
700b07fc: e2814001     	add	r4, r1, #1
;         STR     r4, [r3]
700b0800: e5834000     	str	r4, [r3]
;         FMRX  R0, FPSCR
700b0804: eef10a10     	vmrs	r0, fpscr
;         VPUSH {D0-D15}
700b0808: ed2d0b20     	vpush	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         PUSH  {R0}
700b080c: e52d0004     	str	r0, [sp, #-0x4]!
;         MOV     r2, sp
700b0810: e1a0200d     	mov	r2, sp
;         AND     r2, r2, #4
700b0814: e2022004     	and	r2, r2, #4
;         SUB     sp, sp, r2
700b0818: e04dd002     	sub	sp, sp, r2
;         PUSH    {r0-r4, lr}
700b081c: e92d401f     	push	{r0, r1, r2, r3, r4, lr}
;         LDR     r1, vApplicationIRQHandlerConst
700b0820: e59f10f0     	ldr	r1, [pc, #0xf0]         @ 0x700b0918 <vApplicationIRQHandlerConst>
;         BLX     r1
700b0824: e12fff31     	blx	r1
;         POP     {r0-r4, lr}
700b0828: e8bd401f     	pop	{r0, r1, r2, r3, r4, lr}
;         ADD     sp, sp, r2
700b082c: e08dd002     	add	sp, sp, r2
;         CPSID   i
700b0830: f10c0080     	cpsid	i
;         DSB
700b0834: f57ff04f     	dsb	sy
;         ISB
700b0838: f57ff06f     	isb	sy
;         POP   {R0}
700b083c: e49d0004     	ldr	r0, [sp], #4
;         VPOP  {D0-D15}
700b0840: ecbd0b20     	vpop	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         VMSR  FPSCR, R0
700b0844: eee10a10     	vmsr	fpscr, r0
;         STR     r1, [r3]
700b0848: e5831000     	str	r1, [r3]
;         CMP     r1, #0
700b084c: e3510000     	cmp	r1, #0
;         BNE     exit_without_switch
700b0850: 1a000003     	bne	0x700b0864 <exit_without_switch> @ imm = #0xc
;         LDR     r1, =ulPortYieldRequired
700b0854: e59f10c0     	ldr	r1, [pc, #0xc0]         @ 0x700b091c <vApplicationIRQHandlerConst+0x4>
;         LDR     r0, [r1]
700b0858: e5910000     	ldr	r0, [r1]
;         CMP     r0, #0
700b085c: e3500000     	cmp	r0, #0
;         BNE     switch_before_exit
700b0860: 1a000005     	bne	0x700b087c <switch_before_exit> @ imm = #0x14

700b0864 <exit_without_switch>:
;         POP     {r0-r4, r12}
700b0864: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700b0868: f1020012     	cps	#0x12
;         POP     {LR}
700b086c: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700b0870: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700b0874: e49de004     	ldr	lr, [sp], #4
;         MOVS    PC, LR
700b0878: e1b0f00e     	movs	pc, lr

700b087c <switch_before_exit>:
;         MOV     r0, #0
700b087c: e3a00000     	mov	r0, #0
;         STR     r0, [r1]
700b0880: e5810000     	str	r0, [r1]
;         POP     {r0-r4, r12}
700b0884: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700b0888: f1020012     	cps	#0x12
;         POP     {LR}
700b088c: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700b0890: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700b0894: e49de004     	ldr	lr, [sp], #4
;         portSAVE_CONTEXT
700b0898: f96d051f     	srsdb	sp!, #0x1f
700b089c: f102001f     	cps	#0x1f
700b08a0: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b08a4: e59f2060     	ldr	r2, [pc, #0x60]         @ 0x700b090c <ulPortTaskHasFPUContextConst>
700b08a8: e5923000     	ldr	r3, [r2]
700b08ac: e3530000     	cmp	r3, #0
700b08b0: 1ef11a10     	vmrsne	r1, fpscr
700b08b4: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b08b8: 152d1004     	strne	r1, [sp, #-0x4]!
700b08bc: e52d3004     	str	r3, [sp, #-0x4]!
700b08c0: e59f0040     	ldr	r0, [pc, #0x40]         @ 0x700b0908 <pxCurrentTCBConst>
700b08c4: e5901000     	ldr	r1, [r0]
700b08c8: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700b08cc: e59f003c     	ldr	r0, [pc, #0x3c]         @ 0x700b0910 <vTaskSwitchContextConst>
;         BLX     R0
700b08d0: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700b08d4: e59f002c     	ldr	r0, [pc, #0x2c]         @ 0x700b0908 <pxCurrentTCBConst>
700b08d8: e5901000     	ldr	r1, [r0]
700b08dc: e591d000     	ldr	sp, [r1]
700b08e0: e59f0024     	ldr	r0, [pc, #0x24]         @ 0x700b090c <ulPortTaskHasFPUContextConst>
700b08e4: e49d1004     	ldr	r1, [sp], #4
700b08e8: e5801000     	str	r1, [r0]
700b08ec: e3510000     	cmp	r1, #0
700b08f0: 149d0004     	ldrne	r0, [sp], #4
700b08f4: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b08f8: 1ee10a10     	vmsrne	fpscr, r0
700b08fc: f57ff01f     	clrex
700b0900: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b0904: f8bd0a00     	rfeia	sp!

700b0908 <pxCurrentTCBConst>:
700b0908: 00 2a 0b 70  	.word	0x700b2a00

700b090c <ulPortTaskHasFPUContextConst>:
700b090c: 14 2a 0b 70  	.word	0x700b2a14

700b0910 <vTaskSwitchContextConst>:
700b0910: a1 68 0a 70  	.word	0x700a68a1

700b0914 <ulPortInterruptNestingConst>:
700b0914: 0c 2a 0b 70  	.word	0x700b2a0c

700b0918 <vApplicationIRQHandlerConst>:
700b0918: 91 03 0b 70  	.word	0x700b0391
700b091c: 18 2a 0b 70  	.word	0x700b2a18

700b0920 <HwiP_disable>:
;         mrs     r0, cpsr
700b0920: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x80
700b0924: e380c080     	orr	r12, r0, #128
;         msr     cpsr_cf, r12
700b0928: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b092c: e12fff1e     	bx	lr

700b0930 <HwiP_disableFIQ>:
;         mrs     r0, cpsr
700b0930: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x40
700b0934: e380c040     	orr	r12, r0, #64
;         msr     cpsr_cf, r12
700b0938: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b093c: e12fff1e     	bx	lr

700b0940 <HwiP_enable>:
;         mrs     r0, cpsr
700b0940: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x80
700b0944: e3c0c080     	bic	r12, r0, #128
;         msr     cpsr_cf, r12
700b0948: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b094c: e12fff1e     	bx	lr

700b0950 <HwiP_enableFIQ>:
;         mrs     r0, cpsr
700b0950: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x40
700b0954: e3c0c040     	bic	r12, r0, #64
;         msr     cpsr_cf, r12
700b0958: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b095c: e12fff1e     	bx	lr

700b0960 <HwiP_restore>:
;         msr     cpsr_cf, r0
700b0960: e129f000     	msr	CPSR_fc, r0
;         bx      LR
700b0964: e12fff1e     	bx	lr

700b0968 <HwiP_enableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700b0968: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR     r0, r0, #(1<<24)         /* Set VE mask (VIC controller provides handler address for IRQ) */
700b096c: e3800401     	orr	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700b0970: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b0974: e12fff1e     	bx	lr

700b0978 <HwiP_disableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700b0978: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC     r0, r0, #(1<<24)         /* Clear VE mask (VIC controller provides handler address for IRQ) */
700b097c: e3c00401     	bic	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700b0980: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b0984: e12fff1e     	bx	lr

700b0988 <HwiP_getCPSR>:
;         mrs     r0, cpsr
700b0988: e10f0000     	mrs	r0, apsr
;         bx      LR
700b098c: e12fff1e     	bx	lr

700b0990 <HwiP_data_abort_handler>:
;         PUSH	{r0-r4, r12}
700b0990: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         MRS r0, SPSR
700b0994: e14f0000     	mrs	r0, spsr
;         AND r1, r0, #0x20
700b0998: e2001020     	and	r1, r0, #32
;         CMP R1, #0
700b099c: e3510000     	cmp	r1, #0
;         BEQ ARM_STATE
700b09a0: 0a000000     	beq	0x700b09a8 <ARM_STATE>  @ imm = #0x0
;         SUB lr, lr, #2
700b09a4: e24ee002     	sub	lr, lr, #2

700b09a8 <ARM_STATE>:
;         SUB lr, lr, #4
700b09a8: e24ee004     	sub	lr, lr, #4

700b09ac <END>:
;         PUSH	{lr}
700b09ac: e52de004     	str	lr, [sp, #-0x4]!
;         MRS	lr, SPSR
700b09b0: e14fe000     	mrs	lr, spsr
;         PUSH	{lr}
700b09b4: e52de004     	str	lr, [sp, #-0x4]!
;         LDR	r1, HwiP_data_abort_handler_const
700b09b8: e59f1014     	ldr	r1, [pc, #0x14]         @ 0x700b09d4 <HwiP_data_abort_handler_const>
;         BLX	r1
700b09bc: e12fff31     	blx	r1
;         POP	{LR}
700b09c0: e49de004     	ldr	lr, [sp], #4
;         MSR	SPSR_cxsf, LR
700b09c4: e16ff00e     	msr	SPSR_fsxc, lr
;         POP	{LR}
700b09c8: e49de004     	ldr	lr, [sp], #4
;         POP	{r0-r4, r12}
700b09cc: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         MOVS	PC, LR
700b09d0: e1b0f00e     	movs	pc, lr

700b09d4 <HwiP_data_abort_handler_const>:
700b09d4: 01 07 0b 70  	.word	0x700b0701
700b09d8: 00 00 00 00  	.word	0x00000000
700b09dc: 00 00 00 00  	.word	0x00000000

Disassembly of section .text.cache:

700b09e0 <CacheP_disableL1d>:
;         push    {r0-r7, r9-r11, lr}
700b09e0: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b09e4: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x0004         // clear C bit
700b09e8: e3c00004     	bic	r0, r0, #4
;         dsb
700b09ec: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0 // L1D cache disabled
700b09f0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700b09f4: e3000c0c     	movw	r0, #0xc0c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700b09f8: e347000b     	movt	r0, #0x700b
;         blx     r0
700b09fc: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700b0a00: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0a04: e12fff1e     	bx	lr

700b0a08 <CacheP_disableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b0a08: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1000         // clear I bit
700b0a0c: e3c00a01     	bic	r0, r0, #4096
;         mcr     p15, #0, r0, c1, c0, #0 // L1P cache disabled
700b0a10: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700b0a14: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         isb
700b0a18: f57ff06f     	isb	sy
;         bx      lr
700b0a1c: e12fff1e     	bx	lr

700b0a20 <CacheP_enableL1d>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCR register
700b0a20: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x0004          // set C bit (bit 2) to 1
700b0a24: e3800004     	orr	r0, r0, #4
;         dsb
700b0a28: f57ff04f     	dsb	sy
;         mcr     p15, #0, r1, c15, c5, #0 // Invalidate entire data cache
700b0a2c: ee0f1f15     	mcr	p15, #0x0, r1, c15, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0  // L1D cache enabled
700b0a30: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      lr
700b0a34: e12fff1e     	bx	lr

700b0a38 <CacheP_enableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b0a38: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1000         // set I bit (bit 12) to 1
700b0a3c: e3800a01     	orr	r0, r0, #4096
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700b0a40: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0 // ICache enabled
700b0a44: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb
700b0a48: f57ff06f     	isb	sy
;         bx      lr
700b0a4c: e12fff1e     	bx	lr

700b0a50 <CacheP_invL1d>:
;         push    {r4}
700b0a50: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700b0a54: e0801001     	add	r1, r0, r1
;         ldr     r3, l1dCacheLineSizeInvL1dAddr
700b0a58: e59f3024     	ldr	r3, [pc, #0x24]         @ 0x700b0a84 <l1dCacheLineSizeInvL1dAddr>
;         ldr     r3, [r3]
700b0a5c: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700b0a60: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700b0a64: e1c00004     	bic	r0, r0, r4

700b0a68 <invL1dCache_loop>:
;         mcr     p15, #0, r0, c7, c6, #1 // invalidate single entry in L1D cache
700b0a68: ee070f36     	mcr	p15, #0x0, r0, c7, c6, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700b0a6c: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700b0a70: e1500001     	cmp	r0, r1
;         blo     invL1dCache_loop        // loop if > 0
700b0a74: 3afffffb     	blo	0x700b0a68 <invL1dCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700b0a78: f57ff04f     	dsb	sy
;         pop     {r4}
700b0a7c: e49d4004     	ldr	r4, [sp], #4
;         bx      lr                      // return
700b0a80: e12fff1e     	bx	lr

700b0a84 <l1dCacheLineSizeInvL1dAddr>:
700b0a84: 34 26 0b 70  	.word	0x700b2634

700b0a88 <CacheP_invL1p>:
;         push    {r4}
700b0a88: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700b0a8c: e0801001     	add	r1, r0, r1
;         ldr     r3, l1pCacheLineSizeAddr
700b0a90: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700b0ac0 <l1pCacheLineSizeAddr>
;         ldr     r3, [r3]
700b0a94: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700b0a98: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700b0a9c: e1c00004     	bic	r0, r0, r4

700b0aa0 <invL1pCache_loop>:
;         mcr     p15, #0, r0, c7, c5, #1 // invalidate single entry in ICache
700b0aa0: ee070f35     	mcr	p15, #0x0, r0, c7, c5, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700b0aa4: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700b0aa8: e1500001     	cmp	r0, r1
;         blo     invL1pCache_loop        // loop if > 0
700b0aac: 3afffffb     	blo	0x700b0aa0 <invL1pCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700b0ab0: f57ff04f     	dsb	sy
;         isb                             // flush instruction pipeline
700b0ab4: f57ff06f     	isb	sy
;         pop     {r4}
700b0ab8: e49d4004     	ldr	r4, [sp], #4
;         bx      lr
700b0abc: e12fff1e     	bx	lr

700b0ac0 <l1pCacheLineSizeAddr>:
700b0ac0: 38 26 0b 70  	.word	0x700b2638

700b0ac4 <CacheP_invL1dAll>:
;         mcr     p15, #0, r0, c15, c5, #0 // Invalidate entire data cache
700b0ac4: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         bx      lr                       // return
700b0ac8: e12fff1e     	bx	lr

700b0acc <CacheP_invL1pAll>:
;         mcr     p15, #0, r0, c7, c5, #0 // invalidate all entries in ICache
700b0acc: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         bx      lr                      // return
700b0ad0: e12fff1e     	bx	lr

700b0ad4 <CacheP_wb>:
;         push    {r4, r5}
700b0ad4: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700b0ad8: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700b0adc: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbAddr
700b0ae0: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700b0b0c <l1dCacheLineSizeWbAddr>
;         ldr     r4, [r4]
700b0ae4: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700b0ae8: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align address to cache line
700b0aec: e1c00005     	bic	r0, r0, r5

700b0af0 <writeback>:
;         mcr     p15, #0, r0, c7, c10, #1 // write back a cache line
700b0af0: ee070f3a     	mcr	p15, #0x0, r0, c7, c10, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700b0af4: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700b0af8: e1500001     	cmp	r0, r1
;         blo     writeback                // loop if count > 0
700b0afc: 3afffffb     	blo	0x700b0af0 <writeback>  @ imm = #-0x14
;         dsb                              // drain write buffer
700b0b00: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700b0b04: e8bd0030     	pop	{r4, r5}
;         bx      lr
700b0b08: e12fff1e     	bx	lr

700b0b0c <l1dCacheLineSizeWbAddr>:
700b0b0c: 34 26 0b 70  	.word	0x700b2634

700b0b10 <CacheP_wbInv>:
;         push    {r4, r5}
700b0b10: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700b0b14: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700b0b18: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbInvAddr
700b0b1c: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700b0b48 <l1dCacheLineSizeWbInvAddr>
;         ldr     r4, [r4]
700b0b20: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700b0b24: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align blockPtr to cache line
700b0b28: e1c00005     	bic	r0, r0, r5

700b0b2c <writebackInv>:
;         mcr     p15, #0, r0, c7, c14, #1 // writeback inv a cache line
700b0b2c: ee070f3e     	mcr	p15, #0x0, r0, c7, c14, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700b0b30: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700b0b34: e1500001     	cmp	r0, r1
;         blo     writebackInv             // loop if count > 0
700b0b38: 3afffffb     	blo	0x700b0b2c <writebackInv> @ imm = #-0x14
;         dsb                              // drain write buffer
700b0b3c: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700b0b40: e8bd0030     	pop	{r4, r5}
;         bx      lr
700b0b44: e12fff1e     	bx	lr

700b0b48 <l1dCacheLineSizeWbInvAddr>:
700b0b48: 34 26 0b 70  	.word	0x700b2634

700b0b4c <CacheP_wbAll>:
;         stmfd   sp!, {r0-r7, r9-r11, lr}
700b0b4c: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         dmb                             // Ensure all previous memory accesses
700b0b50: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700b0b54: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700b0b58: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700b0b5c: e1a03ba3     	lsr	r3, r3, #23
;         beq     wbafinished             // if loc is 0, then no need to clean
700b0b60: 0a00001d     	beq	0x700b0bdc <wbafinished> @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700b0b64: e3a0a000     	mov	r10, #0

700b0b68 <wbaloop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700b0b68: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700b0b6c: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700b0b70: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700b0b74: e3510002     	cmp	r1, #2
;         blt     wbaskip                 // skip if no cache, or just i-cache
700b0b78: ba000014     	blt	0x700b0bd0 <wbaskip>    @ imm = #0x50
;         mrs     r6, cpsr
700b0b7c: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700b0b80: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0b84: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700b0b88: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700b0b8c: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700b0b90: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700b0b94: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700b0b98: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700b0b9c: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700b0ba0: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700b0ba4: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700b0ba8: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700b0bac: e01776a1     	ands	r7, r7, r1, lsr #13

700b0bb0 <wbaloop2>:
;         mov     r9, r4                  // create working copy of max way size
700b0bb0: e1a09004     	mov	r9, r4

700b0bb4 <wbaloop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700b0bb4: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700b0bb8: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c10, #2 // clean line by set/way
700b0bbc: ee07bf5a     	mcr	p15, #0x0, r11, c7, c10, #0x2
;         subs    r9, r9, #1              // decrement the way
700b0bc0: e2599001     	subs	r9, r9, #1
;         bge     wbaloop3
700b0bc4: aafffffa     	bge	0x700b0bb4 <wbaloop3>   @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700b0bc8: e2577001     	subs	r7, r7, #1
;         bge     wbaloop2
700b0bcc: aafffff7     	bge	0x700b0bb0 <wbaloop2>   @ imm = #-0x24

700b0bd0 <wbaskip>:
;         add     r10, r10, #2            // increment cache number
700b0bd0: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700b0bd4: e153000a     	cmp	r3, r10
;         bgt     wbaloop1
700b0bd8: caffffe2     	bgt	0x700b0b68 <wbaloop1>   @ imm = #-0x78

700b0bdc <wbafinished>:
;         mov     r10, #0                 // switch back to cache level 0
700b0bdc: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0be0: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700b0be4: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700b0be8: f57ff06f     	isb	sy
;         ldmfd   sp!, {r0-r7, r9-r11, lr}
700b0bec: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0bf0: e12fff1e     	bx	lr

700b0bf4 <CacheP_wbInvAll>:
;         push    {r0-r7, r9-r11, lr}
700b0bf4: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700b0bf8: e3000c0c     	movw	r0, #0xc0c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700b0bfc: e347000b     	movt	r0, #0x700b
;         blx     r0
700b0c00: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700b0c04: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0c08: e12fff1e     	bx	lr

700b0c0c <CacheP_wbInvAllAsm>:
;         dmb                             // Ensure all previous memory accesses
700b0c0c: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700b0c10: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700b0c14: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700b0c18: e1a03ba3     	lsr	r3, r3, #23
;         beq     finished                // if loc is 0, then no need to clean
700b0c1c: 0a00001d     	beq	0x700b0c98 <finished>   @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700b0c20: e3a0a000     	mov	r10, #0

700b0c24 <loop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700b0c24: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700b0c28: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700b0c2c: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700b0c30: e3510002     	cmp	r1, #2
;         blt     skip                    // skip if no cache, or just i-cache
700b0c34: ba000014     	blt	0x700b0c8c <skip>       @ imm = #0x50
;         mrs     r6, cpsr
700b0c38: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700b0c3c: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0c40: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700b0c44: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700b0c48: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700b0c4c: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700b0c50: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700b0c54: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700b0c58: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700b0c5c: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700b0c60: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700b0c64: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700b0c68: e01776a1     	ands	r7, r7, r1, lsr #13

700b0c6c <loop2>:
;         mov     r9, r4                  // create working copy of max way size
700b0c6c: e1a09004     	mov	r9, r4

700b0c70 <loop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700b0c70: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700b0c74: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c14, #2 // clean & invalidate by set/way
700b0c78: ee07bf5e     	mcr	p15, #0x0, r11, c7, c14, #0x2
;         subs    r9, r9, #1              // decrement the way
700b0c7c: e2599001     	subs	r9, r9, #1
;         bge     loop3
700b0c80: aafffffa     	bge	0x700b0c70 <loop3>      @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700b0c84: e2577001     	subs	r7, r7, #1
;         bge     loop2
700b0c88: aafffff7     	bge	0x700b0c6c <loop2>      @ imm = #-0x24

700b0c8c <skip>:
;         add     r10, r10, #2            // increment cache number
700b0c8c: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700b0c90: e153000a     	cmp	r3, r10
;         bgt     loop1
700b0c94: caffffe2     	bgt	0x700b0c24 <loop1>      @ imm = #-0x78

700b0c98 <finished>:
;         mov     r10, #0                 // swith back to cache level 0
700b0c98: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0c9c: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700b0ca0: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700b0ca4: f57ff06f     	isb	sy
;         bx      lr
700b0ca8: e12fff1e     	bx	lr

700b0cac <CacheP_getEnabled>:
;         mov     r0, #0
700b0cac: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0 // fetch Control Register into r1
700b0cb0: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1000             // test I bit (bit 12) for L1P
700b0cb4: e3110a01     	tst	r1, #4096
;         addne   r0, r0, #1              // if I is true, L1P is enabled
700b0cb8: 12800001     	addne	r0, r0, #1
;         tst     r1, #0x0004             // test C bit (bit 2) for L1D
700b0cbc: e3110004     	tst	r1, #4
;         addne   r0, r0, #2              // if C bit is true, L1D is enabled
700b0cc0: 12800002     	addne	r0, r0, #2
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0cc4: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         tst     r1, #0x0002             // test L2EN bit (bit 1) for L2EN
700b0cc8: e3110002     	tst	r1, #2
;         beq     getEnabledDone
700b0ccc: 0a000003     	beq	0x700b0ce0 <getEnabledDone> @ imm = #0xc
;         tst     r0, #0x0001
700b0cd0: e3100001     	tst	r0, #1
;         addne   r0, r0, #4              // If L2EN and L1P then L2P
700b0cd4: 12800004     	addne	r0, r0, #4
;         tst     r0, #0x0002
700b0cd8: e3100002     	tst	r0, #2
;         addne   r0, r0, #8              // If L2EN and L1D then L2D
700b0cdc: 12800008     	addne	r0, r0, #8

700b0ce0 <getEnabledDone>:
;         bx      lr
700b0ce0: e12fff1e     	bx	lr

700b0ce4 <CacheP_getCacheLevelInfo>:
;         mcr     p15, #2, r0, c0, c0, #0 // write to Cache Size Selection Reg
700b0ce4: ee400f10     	mcr	p15, #0x2, r0, c0, c0, #0x0
;         mrc     p15, #1, r0, c0, c0, #0 // read Cache Size Id Reg
700b0ce8: ee300f10     	mrc	p15, #0x1, r0, c0, c0, #0x0
;         bx      lr
700b0cec: e12fff1e     	bx	lr

700b0cf0 <CacheP_configForceWrThru>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0cf0: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         cmp     r0, #0
700b0cf4: e3500000     	cmp	r0, #0
;         beq     FWT_disable
700b0cf8: 0a000001     	beq	0x700b0d04 <FWT_disable> @ imm = #0x4
;         orr     r1, r1, #(1 << 9)       // set (enable) force write-thru bit
700b0cfc: e3811c02     	orr	r1, r1, #512
;         b       FWT_exit
700b0d00: ea000000     	b	0x700b0d08 <FWT_exit>   @ imm = #0x0

700b0d04 <FWT_disable>:
;         bic     r1, r1, #(1 << 9)       // clear (disable) force write-thru bit
700b0d04: e3c11c02     	bic	r1, r1, #512

700b0d08 <FWT_exit>:
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700b0d08: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700b0d0c: e12fff1e     	bx	lr

700b0d10 <CacheP_setDLFO>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0d10: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         orr     r1, r1, #(1 << 13)      // set DLFO to disable LF optimization
700b0d14: e3811a02     	orr	r1, r1, #8192
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700b0d18: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700b0d1c: e12fff1e     	bx	lr

700b0d20 <CacheP_init>:
; {
700b0d20: b580         	push	{r7, lr}
700b0d22: b084         	sub	sp, #0x10
700b0d24: 2000         	movs	r0, #0x0
;     info = CacheP_getCacheLevelInfo(0);
700b0d26: f7ff efde    	blx	0x700b0ce4 <CacheP_getCacheLevelInfo> @ imm = #-0x44
700b0d2a: 9003         	str	r0, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1dCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700b0d2c: 9803         	ldr	r0, [sp, #0xc]
700b0d2e: f000 0007    	and	r0, r0, #0x7
700b0d32: 1c81         	adds	r1, r0, #0x2
700b0d34: 2004         	movs	r0, #0x4
700b0d36: 9001         	str	r0, [sp, #0x4]
700b0d38: 4088         	lsls	r0, r1
700b0d3a: 3820         	subs	r0, #0x20
700b0d3c: fab0 f080    	clz	r0, r0
700b0d40: 0940         	lsrs	r0, r0, #0x5
700b0d42: f000 faad    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x55a
700b0d46: 2001         	movs	r0, #0x1
;     info = CacheP_getCacheLevelInfo(1);
700b0d48: f7ff efcc    	blx	0x700b0ce4 <CacheP_getCacheLevelInfo> @ imm = #-0x68
700b0d4c: 4601         	mov	r1, r0
700b0d4e: 9801         	ldr	r0, [sp, #0x4]
700b0d50: 9103         	str	r1, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1pCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700b0d52: 9903         	ldr	r1, [sp, #0xc]
700b0d54: f001 0107    	and	r1, r1, #0x7
700b0d58: 3102         	adds	r1, #0x2
700b0d5a: 4088         	lsls	r0, r1
700b0d5c: 3820         	subs	r0, #0x20
700b0d5e: fab0 f080    	clz	r0, r0
700b0d62: 0940         	lsrs	r0, r0, #0x5
700b0d64: f000 fa9c    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x538
;     enabled = CacheP_getEnabled();
700b0d68: f7ff efa0    	blx	0x700b0cac <CacheP_getEnabled> @ imm = #-0xc0
700b0d6c: 9002         	str	r0, [sp, #0x8]
;     if (enabled!=0U) {
700b0d6e: 9802         	ldr	r0, [sp, #0x8]
700b0d70: b120         	cbz	r0, 0x700b0d7c <CacheP_init+0x5c> @ imm = #0x8
700b0d72: e7ff         	b	0x700b0d74 <CacheP_init+0x54> @ imm = #-0x2
700b0d74: 200f         	movs	r0, #0xf
;         CacheP_disable((uint32_t)CacheP_TYPE_ALL);
700b0d76: f000 f81b    	bl	0x700b0db0 <CacheP_disable> @ imm = #0x36
;     }
700b0d7a: e7ff         	b	0x700b0d7c <CacheP_init+0x5c> @ imm = #-0x2
;     if (gCacheConfig.enable!=0U) {
700b0d7c: f241 70c8    	movw	r0, #0x17c8
700b0d80: f2c7 000b    	movt	r0, #0x700b
700b0d84: 6800         	ldr	r0, [r0]
700b0d86: b158         	cbz	r0, 0x700b0da0 <CacheP_init+0x80> @ imm = #0x16
700b0d88: e7ff         	b	0x700b0d8a <CacheP_init+0x6a> @ imm = #-0x2
;          CacheP_configForceWrThru(gCacheConfig.enableForceWrThru);
700b0d8a: f241 70c8    	movw	r0, #0x17c8
700b0d8e: f2c7 000b    	movt	r0, #0x700b
700b0d92: 6840         	ldr	r0, [r0, #0x4]
700b0d94: f7ff efac    	blx	0x700b0cf0 <CacheP_configForceWrThru> @ imm = #-0xa8
700b0d98: 200f         	movs	r0, #0xf
;         CacheP_enable((uint32_t)CacheP_TYPE_ALL);
700b0d9a: f000 f831    	bl	0x700b0e00 <CacheP_enable> @ imm = #0x62
;     }
700b0d9e: e7ff         	b	0x700b0da0 <CacheP_init+0x80> @ imm = #-0x2
; }
700b0da0: b004         	add	sp, #0x10
700b0da2: bd80         	pop	{r7, pc}
700b0da4: bf00         	nop
700b0da6: bf00         	nop
700b0da8: bf00         	nop
700b0daa: bf00         	nop
700b0dac: bf00         	nop
700b0dae: bf00         	nop

700b0db0 <CacheP_disable>:
; {
700b0db0: b580         	push	{r7, lr}
700b0db2: b084         	sub	sp, #0x10
700b0db4: 9003         	str	r0, [sp, #0xc]
;     enabled = CacheP_getEnabled();
700b0db6: f7ff ef7a    	blx	0x700b0cac <CacheP_getEnabled> @ imm = #-0x10c
700b0dba: 9002         	str	r0, [sp, #0x8]
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700b0dbc: 9902         	ldr	r1, [sp, #0x8]
700b0dbe: 9803         	ldr	r0, [sp, #0xc]
700b0dc0: 4008         	ands	r0, r1
700b0dc2: 0780         	lsls	r0, r0, #0x1e
700b0dc4: 2800         	cmp	r0, #0x0
700b0dc6: d509         	bpl	0x700b0ddc <CacheP_disable+0x2c> @ imm = #0x12
700b0dc8: e7ff         	b	0x700b0dca <CacheP_disable+0x1a> @ imm = #-0x2
;         key = HwiP_disable();
700b0dca: f7ff edaa    	blx	0x700b0920 <HwiP_disable> @ imm = #-0x4ac
700b0dce: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1d();             /* Disable L1D Cache */
700b0dd0: f7ff ee06    	blx	0x700b09e0 <CacheP_disableL1d> @ imm = #-0x3f4
;         HwiP_restore(key);
700b0dd4: 9801         	ldr	r0, [sp, #0x4]
700b0dd6: f7ff edc4    	blx	0x700b0960 <HwiP_restore> @ imm = #-0x478
;     }
700b0dda: e7ff         	b	0x700b0ddc <CacheP_disable+0x2c> @ imm = #-0x2
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700b0ddc: 9902         	ldr	r1, [sp, #0x8]
700b0dde: 9803         	ldr	r0, [sp, #0xc]
700b0de0: 4008         	ands	r0, r1
700b0de2: 07c0         	lsls	r0, r0, #0x1f
700b0de4: b148         	cbz	r0, 0x700b0dfa <CacheP_disable+0x4a> @ imm = #0x12
700b0de6: e7ff         	b	0x700b0de8 <CacheP_disable+0x38> @ imm = #-0x2
;         key = HwiP_disable();
700b0de8: f7ff ed9a    	blx	0x700b0920 <HwiP_disable> @ imm = #-0x4cc
700b0dec: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1p();             /* Disable L1P Cache */
700b0dee: f7ff ee0c    	blx	0x700b0a08 <CacheP_disableL1p> @ imm = #-0x3e8
;         HwiP_restore(key);
700b0df2: 9801         	ldr	r0, [sp, #0x4]
700b0df4: f7ff edb4    	blx	0x700b0960 <HwiP_restore> @ imm = #-0x498
;     }
700b0df8: e7ff         	b	0x700b0dfa <CacheP_disable+0x4a> @ imm = #-0x2
; }
700b0dfa: b004         	add	sp, #0x10
700b0dfc: bd80         	pop	{r7, pc}
700b0dfe: bf00         	nop

700b0e00 <CacheP_enable>:
; {
700b0e00: b580         	push	{r7, lr}
700b0e02: b082         	sub	sp, #0x8
700b0e04: 9001         	str	r0, [sp, #0x4]
;     disabled = ~(CacheP_getEnabled());
700b0e06: f7ff ef52    	blx	0x700b0cac <CacheP_getEnabled> @ imm = #-0x15c
700b0e0a: 43c0         	mvns	r0, r0
700b0e0c: 9000         	str	r0, [sp]
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700b0e0e: 9900         	ldr	r1, [sp]
700b0e10: 9801         	ldr	r0, [sp, #0x4]
700b0e12: 4008         	ands	r0, r1
700b0e14: 0780         	lsls	r0, r0, #0x1e
700b0e16: 2800         	cmp	r0, #0x0
700b0e18: d503         	bpl	0x700b0e22 <CacheP_enable+0x22> @ imm = #0x6
700b0e1a: e7ff         	b	0x700b0e1c <CacheP_enable+0x1c> @ imm = #-0x2
;         CacheP_enableL1d();              /* Enable L1D Cache */
700b0e1c: f7ff ee00    	blx	0x700b0a20 <CacheP_enableL1d> @ imm = #-0x400
;     }
700b0e20: e7ff         	b	0x700b0e22 <CacheP_enable+0x22> @ imm = #-0x2
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700b0e22: 9900         	ldr	r1, [sp]
700b0e24: 9801         	ldr	r0, [sp, #0x4]
700b0e26: 4008         	ands	r0, r1
700b0e28: 07c0         	lsls	r0, r0, #0x1f
700b0e2a: b118         	cbz	r0, 0x700b0e34 <CacheP_enable+0x34> @ imm = #0x6
700b0e2c: e7ff         	b	0x700b0e2e <CacheP_enable+0x2e> @ imm = #-0x2
;         CacheP_enableL1p();              /* Enable L1P Cache */
700b0e2e: f7ff ee04    	blx	0x700b0a38 <CacheP_enableL1p> @ imm = #-0x3f8
;     }
700b0e32: e7ff         	b	0x700b0e34 <CacheP_enable+0x34> @ imm = #-0x2
; }
700b0e34: b002         	add	sp, #0x8
700b0e36: bd80         	pop	{r7, pc}
700b0e38: bf00         	nop
700b0e3a: bf00         	nop
700b0e3c: bf00         	nop
700b0e3e: bf00         	nop

700b0e40 <CacheP_inv>:
; {
700b0e40: b580         	push	{r7, lr}
700b0e42: b084         	sub	sp, #0x10
700b0e44: 9003         	str	r0, [sp, #0xc]
700b0e46: 9102         	str	r1, [sp, #0x8]
700b0e48: 9201         	str	r2, [sp, #0x4]
;     if (((type) & ((uint32_t)CacheP_TYPE_L1P))!=0U) {
700b0e4a: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b0e4e: 07c0         	lsls	r0, r0, #0x1f
700b0e50: b128         	cbz	r0, 0x700b0e5e <CacheP_inv+0x1e> @ imm = #0xa
700b0e52: e7ff         	b	0x700b0e54 <CacheP_inv+0x14> @ imm = #-0x2
;         CacheP_invL1p((uint32_t)blockPtr, byteCnt);
700b0e54: 9803         	ldr	r0, [sp, #0xc]
700b0e56: 9902         	ldr	r1, [sp, #0x8]
700b0e58: f7ff ee16    	blx	0x700b0a88 <CacheP_invL1p> @ imm = #-0x3d4
;     }
700b0e5c: e7ff         	b	0x700b0e5e <CacheP_inv+0x1e> @ imm = #-0x2
;     if (((type) & ((uint32_t)CacheP_TYPE_L1D))!=0U) {
700b0e5e: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b0e62: 0780         	lsls	r0, r0, #0x1e
700b0e64: 2800         	cmp	r0, #0x0
700b0e66: d505         	bpl	0x700b0e74 <CacheP_inv+0x34> @ imm = #0xa
700b0e68: e7ff         	b	0x700b0e6a <CacheP_inv+0x2a> @ imm = #-0x2
;         CacheP_invL1d((uint32_t)blockPtr, byteCnt);
700b0e6a: 9803         	ldr	r0, [sp, #0xc]
700b0e6c: 9902         	ldr	r1, [sp, #0x8]
700b0e6e: f7ff edf0    	blx	0x700b0a50 <CacheP_invL1d> @ imm = #-0x420
;     }
700b0e72: e7ff         	b	0x700b0e74 <CacheP_inv+0x34> @ imm = #-0x2
; }
700b0e74: b004         	add	sp, #0x10
700b0e76: bd80         	pop	{r7, pc}
		...

Disassembly of section .text.mpu:

700b0e80 <MpuP_RegionAttrs_init>:
; {
700b0e80: b081         	sub	sp, #0x4
700b0e82: 9000         	str	r0, [sp]
;     region->isExecuteNever = 0;
700b0e84: 9900         	ldr	r1, [sp]
700b0e86: 2000         	movs	r0, #0x0
700b0e88: 7108         	strb	r0, [r1, #0x4]
;     region->accessPerm     = (uint8_t)MpuP_AP_S_RW_U_R;
700b0e8a: 9a00         	ldr	r2, [sp]
700b0e8c: 2102         	movs	r1, #0x2
700b0e8e: 7191         	strb	r1, [r2, #0x6]
;     region->tex            = 0;
700b0e90: 9900         	ldr	r1, [sp]
700b0e92: 7148         	strb	r0, [r1, #0x5]
;     region->isSharable     = 1;
700b0e94: 9a00         	ldr	r2, [sp]
700b0e96: 2101         	movs	r1, #0x1
700b0e98: 70d1         	strb	r1, [r2, #0x3]
;     region->isCacheable    = 0;
700b0e9a: 9900         	ldr	r1, [sp]
700b0e9c: 7048         	strb	r0, [r1, #0x1]
;     region->isBufferable   = 0;
700b0e9e: 9900         	ldr	r1, [sp]
700b0ea0: 7088         	strb	r0, [r1, #0x2]
;     region->isEnable       = 0;
700b0ea2: 9900         	ldr	r1, [sp]
700b0ea4: 7008         	strb	r0, [r1]
;     region->subregionDisableMask = 0;
700b0ea6: 9900         	ldr	r1, [sp]
700b0ea8: 71c8         	strb	r0, [r1, #0x7]
; }
700b0eaa: b001         	add	sp, #0x4
700b0eac: 4770         	bx	lr
700b0eae: bf00         	nop

700b0eb0 <MpuP_setRegion>:
; {
700b0eb0: b580         	push	{r7, lr}
700b0eb2: b08a         	sub	sp, #0x28
700b0eb4: 9009         	str	r0, [sp, #0x24]
700b0eb6: 9108         	str	r1, [sp, #0x20]
700b0eb8: 9207         	str	r2, [sp, #0x1c]
700b0eba: 9306         	str	r3, [sp, #0x18]
;     uint32_t value = size;
700b0ebc: 9807         	ldr	r0, [sp, #0x1c]
700b0ebe: 9000         	str	r0, [sp]
;     DebugP_assertNoLog( regionNum < MpuP_MAX_REGIONS);
700b0ec0: 9909         	ldr	r1, [sp, #0x24]
700b0ec2: 2000         	movs	r0, #0x0
700b0ec4: 2910         	cmp	r1, #0x10
700b0ec6: bf38         	it	lo
700b0ec8: 2001         	movlo	r0, #0x1
700b0eca: f000 f9e9    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x3d2
;     value = (value & (uint32_t)0x1F);
700b0ece: 9800         	ldr	r0, [sp]
700b0ed0: f000 001f    	and	r0, r0, #0x1f
700b0ed4: 9000         	str	r0, [sp]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0ed6: 9806         	ldr	r0, [sp, #0x18]
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700b0ed8: 7801         	ldrb	r1, [r0]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0eda: 79c0         	ldrb	r0, [r0, #0x7]
700b0edc: 0200         	lsls	r0, r0, #0x8
;                   | ((uint32_t)(value            & (uint32_t)0x1F) << (uint32_t)1)
700b0ede: 9a00         	ldr	r2, [sp]
700b0ee0: f002 021f    	and	r2, r2, #0x1f
700b0ee4: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700b0ee8: f001 0101    	and	r1, r1, #0x1
700b0eec: 4408         	add	r0, r1
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0eee: 9004         	str	r0, [sp, #0x10]
;     baseAddress = ((uint32_t)addr & ~( (1U <<((uint64_t)value+1U))-1U ));
700b0ef0: 9808         	ldr	r0, [sp, #0x20]
700b0ef2: 9900         	ldr	r1, [sp]
700b0ef4: 1c4a         	adds	r2, r1, #0x1
700b0ef6: 2101         	movs	r1, #0x1
700b0ef8: 4091         	lsls	r1, r2
700b0efa: 4249         	rsbs	r1, r1, #0
700b0efc: 4008         	ands	r0, r1
700b0efe: 9005         	str	r0, [sp, #0x14]
;     regionAttrs = MpuP_getAttrs(attrs);
700b0f00: 9806         	ldr	r0, [sp, #0x18]
700b0f02: f000 f81d    	bl	0x700b0f40 <MpuP_getAttrs> @ imm = #0x3a
700b0f06: 9003         	str	r0, [sp, #0xc]
;     enabled = MpuP_isEnable();
700b0f08: f000 f84a    	bl	0x700b0fa0 <MpuP_isEnable> @ imm = #0x94
700b0f0c: 9002         	str	r0, [sp, #0x8]
;     MpuP_disable();
700b0f0e: f000 f84f    	bl	0x700b0fb0 <MpuP_disable> @ imm = #0x9e
;     key = HwiP_disable();
700b0f12: f7ff ed06    	blx	0x700b0920 <HwiP_disable> @ imm = #-0x5f4
700b0f16: 9001         	str	r0, [sp, #0x4]
;     MpuP_setRegionAsm(regionNum, baseAddress, sizeAndEnable, regionAttrs);
700b0f18: 9809         	ldr	r0, [sp, #0x24]
700b0f1a: 9905         	ldr	r1, [sp, #0x14]
700b0f1c: 9a04         	ldr	r2, [sp, #0x10]
700b0f1e: 9b03         	ldr	r3, [sp, #0xc]
700b0f20: f000 e90c    	blx	0x700b113c <MpuP_setRegionAsm> @ imm = #0x218
;     HwiP_restore(key);
700b0f24: 9801         	ldr	r0, [sp, #0x4]
700b0f26: f7ff ed1c    	blx	0x700b0960 <HwiP_restore> @ imm = #-0x5c8
;     if (enabled != 0U) {
700b0f2a: 9802         	ldr	r0, [sp, #0x8]
700b0f2c: b118         	cbz	r0, 0x700b0f36 <MpuP_setRegion+0x86> @ imm = #0x6
700b0f2e: e7ff         	b	0x700b0f30 <MpuP_setRegion+0x80> @ imm = #-0x2
;         MpuP_enable();
700b0f30: f000 f85e    	bl	0x700b0ff0 <MpuP_enable> @ imm = #0xbc
;     }
700b0f34: e7ff         	b	0x700b0f36 <MpuP_setRegion+0x86> @ imm = #-0x2
; }
700b0f36: b00a         	add	sp, #0x28
700b0f38: bd80         	pop	{r7, pc}
700b0f3a: bf00         	nop
700b0f3c: bf00         	nop
700b0f3e: bf00         	nop

700b0f40 <MpuP_getAttrs>:
; {
700b0f40: b580         	push	{r7, lr}
700b0f42: b082         	sub	sp, #0x8
700b0f44: 9001         	str	r0, [sp, #0x4]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700b0f46: f8dd c004    	ldr.w	r12, [sp, #0x4]
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700b0f4a: f89c 2001    	ldrb.w	r2, [r12, #0x1]
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700b0f4e: f89c 1002    	ldrb.w	r1, [r12, #0x2]
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700b0f52: f89c 3003    	ldrb.w	r3, [r12, #0x3]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700b0f56: f89c 0004    	ldrb.w	r0, [r12, #0x4]
700b0f5a: f000 0001    	and	r0, r0, #0x1
700b0f5e: 0300         	lsls	r0, r0, #0xc
;         | ((uint32_t)(region->accessPerm     & (uint32_t)0x7) << (uint32_t)8)
700b0f60: f89c e006    	ldrb.w	lr, [r12, #0x6]
700b0f64: f00e 0e07    	and	lr, lr, #0x7
700b0f68: ea40 200e    	orr.w	r0, r0, lr, lsl #8
;         | ((uint32_t)(region->tex            & (uint32_t)0x7) << (uint32_t)3)
700b0f6c: f89c c005    	ldrb.w	r12, [r12, #0x5]
700b0f70: f00c 0c07    	and	r12, r12, #0x7
700b0f74: ea40 00cc    	orr.w	r0, r0, r12, lsl #3
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700b0f78: f003 0301    	and	r3, r3, #0x1
700b0f7c: ea40 0083    	orr.w	r0, r0, r3, lsl #2
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700b0f80: f002 0201    	and	r2, r2, #0x1
700b0f84: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700b0f88: f001 0101    	and	r1, r1, #0x1
700b0f8c: 4408         	add	r0, r1
;     uint32_t regionAttrs =
700b0f8e: 9000         	str	r0, [sp]
;     return regionAttrs;
700b0f90: 9800         	ldr	r0, [sp]
700b0f92: b002         	add	sp, #0x8
700b0f94: bd80         	pop	{r7, pc}
700b0f96: bf00         	nop
700b0f98: bf00         	nop
700b0f9a: bf00         	nop
700b0f9c: bf00         	nop
700b0f9e: bf00         	nop

700b0fa0 <MpuP_isEnable>:
; {
700b0fa0: b580         	push	{r7, lr}
;     return MpuP_isEnableAsm();
700b0fa2: f000 e8c2    	blx	0x700b1128 <MpuP_isEnableAsm> @ imm = #0x184
700b0fa6: bd80         	pop	{r7, pc}
700b0fa8: bf00         	nop
700b0faa: bf00         	nop
700b0fac: bf00         	nop
700b0fae: bf00         	nop

700b0fb0 <MpuP_disable>:
; {
700b0fb0: b580         	push	{r7, lr}
700b0fb2: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()!=0U)
700b0fb4: f7ff fff4    	bl	0x700b0fa0 <MpuP_isEnable> @ imm = #-0x18
700b0fb8: b1a0         	cbz	r0, 0x700b0fe4 <MpuP_disable+0x34> @ imm = #0x28
700b0fba: e7ff         	b	0x700b0fbc <MpuP_disable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700b0fbc: f7ff ecb0    	blx	0x700b0920 <HwiP_disable> @ imm = #-0x6a0
700b0fc0: 9000         	str	r0, [sp]
;         type = CacheP_getEnabled();
700b0fc2: f7ff ee74    	blx	0x700b0cac <CacheP_getEnabled> @ imm = #-0x318
700b0fc6: 9001         	str	r0, [sp, #0x4]
;         CacheP_disable(type);
700b0fc8: 9801         	ldr	r0, [sp, #0x4]
700b0fca: f7ff fef1    	bl	0x700b0db0 <CacheP_disable> @ imm = #-0x21e
;         __asm__ __volatile__ (" dsb" "\n\t": : : "memory");
700b0fce: f3bf 8f4f    	dsb	sy
;         MpuP_disableAsm();
700b0fd2: f000 e882    	blx	0x700b10d8 <MpuP_disableAsm> @ imm = #0x104
;         CacheP_enable(type);
700b0fd6: 9801         	ldr	r0, [sp, #0x4]
700b0fd8: f7ff ff12    	bl	0x700b0e00 <CacheP_enable> @ imm = #-0x1dc
;         HwiP_restore(key);
700b0fdc: 9800         	ldr	r0, [sp]
700b0fde: f7ff ecc0    	blx	0x700b0960 <HwiP_restore> @ imm = #-0x680
;     }
700b0fe2: e7ff         	b	0x700b0fe4 <MpuP_disable+0x34> @ imm = #-0x2
; }
700b0fe4: b002         	add	sp, #0x8
700b0fe6: bd80         	pop	{r7, pc}
700b0fe8: bf00         	nop
700b0fea: bf00         	nop
700b0fec: bf00         	nop
700b0fee: bf00         	nop

700b0ff0 <MpuP_enable>:
; {
700b0ff0: b580         	push	{r7, lr}
700b0ff2: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()==(uint32_t) 0U)
700b0ff4: f7ff ffd4    	bl	0x700b0fa0 <MpuP_isEnable> @ imm = #-0x58
700b0ff8: b9e0         	cbnz	r0, 0x700b1034 <MpuP_enable+0x44> @ imm = #0x38
700b0ffa: e7ff         	b	0x700b0ffc <MpuP_enable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700b0ffc: f7ff ec90    	blx	0x700b0920 <HwiP_disable> @ imm = #-0x6e0
700b1000: 9000         	str	r0, [sp]
;         type = (uint32_t)CacheP_getEnabled();
700b1002: f7ff ee54    	blx	0x700b0cac <CacheP_getEnabled> @ imm = #-0x358
700b1006: 9001         	str	r0, [sp, #0x4]
;         if (type & CacheP_TYPE_L1) {
700b1008: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b100c: 0780         	lsls	r0, r0, #0x1e
700b100e: b120         	cbz	r0, 0x700b101a <MpuP_enable+0x2a> @ imm = #0x8
700b1010: e7ff         	b	0x700b1012 <MpuP_enable+0x22> @ imm = #-0x2
700b1012: 2003         	movs	r0, #0x3
;             CacheP_disable(CacheP_TYPE_L1);
700b1014: f7ff fecc    	bl	0x700b0db0 <CacheP_disable> @ imm = #-0x268
;         }
700b1018: e7ff         	b	0x700b101a <MpuP_enable+0x2a> @ imm = #-0x2
;         MpuP_enableAsm();
700b101a: f000 e872    	blx	0x700b1100 <MpuP_enableAsm> @ imm = #0xe4
;         CacheP_enable(type);
700b101e: 9801         	ldr	r0, [sp, #0x4]
700b1020: f7ff feee    	bl	0x700b0e00 <CacheP_enable> @ imm = #-0x224
;         __asm__  __volatile__ (" dsb" "\n\t": : : "memory");
700b1024: f3bf 8f4f    	dsb	sy
;         __asm__  __volatile__ (" isb" "\n\t": : : "memory");
700b1028: f3bf 8f6f    	isb	sy
;         HwiP_restore(key);
700b102c: 9800         	ldr	r0, [sp]
700b102e: f7ff ec98    	blx	0x700b0960 <HwiP_restore> @ imm = #-0x6d0
;     }
700b1032: e7ff         	b	0x700b1034 <MpuP_enable+0x44> @ imm = #-0x2
; }
700b1034: b002         	add	sp, #0x8
700b1036: bd80         	pop	{r7, pc}
700b1038: bf00         	nop
700b103a: bf00         	nop
700b103c: bf00         	nop
700b103e: bf00         	nop

700b1040 <MpuP_init>:
; {
700b1040: b580         	push	{r7, lr}
700b1042: b082         	sub	sp, #0x8
;     if (MpuP_isEnable()!=0U) {
700b1044: f7ff ffac    	bl	0x700b0fa0 <MpuP_isEnable> @ imm = #-0xa8
700b1048: b118         	cbz	r0, 0x700b1052 <MpuP_init+0x12> @ imm = #0x6
700b104a: e7ff         	b	0x700b104c <MpuP_init+0xc> @ imm = #-0x2
;         MpuP_disable();
700b104c: f7ff ffb0    	bl	0x700b0fb0 <MpuP_disable> @ imm = #-0xa0
;     }
700b1050: e7ff         	b	0x700b1052 <MpuP_init+0x12> @ imm = #-0x2
;     MpuP_disableBRAsm();
700b1052: f000 e84e    	blx	0x700b10f0 <MpuP_disableBRAsm> @ imm = #0x9c
;     DebugP_assertNoLog( gMpuConfig.numRegions < MpuP_MAX_REGIONS);
700b1056: f241 70d0    	movw	r0, #0x17d0
700b105a: f2c7 000b    	movt	r0, #0x700b
700b105e: 6801         	ldr	r1, [r0]
700b1060: 2000         	movs	r0, #0x0
700b1062: 9000         	str	r0, [sp]
700b1064: 2910         	cmp	r1, #0x10
700b1066: bf38         	it	lo
700b1068: 2001         	movlo	r0, #0x1
700b106a: f000 f919    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x232
700b106e: 9800         	ldr	r0, [sp]
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700b1070: 9001         	str	r0, [sp, #0x4]
700b1072: e7ff         	b	0x700b1074 <MpuP_init+0x34> @ imm = #-0x2
700b1074: 9801         	ldr	r0, [sp, #0x4]
700b1076: f241 71d0    	movw	r1, #0x17d0
700b107a: f2c7 010b    	movt	r1, #0x700b
700b107e: 6809         	ldr	r1, [r1]
700b1080: 4288         	cmp	r0, r1
700b1082: d212         	bhs	0x700b10aa <MpuP_init+0x6a> @ imm = #0x24
700b1084: e7ff         	b	0x700b1086 <MpuP_init+0x46> @ imm = #-0x2
;         MpuP_setRegion(i,
700b1086: 9801         	ldr	r0, [sp, #0x4]
;                 (void*)gMpuRegionConfig[i].baseAddr,
700b1088: f241 71dc    	movw	r1, #0x17dc
700b108c: f2c7 010b    	movt	r1, #0x700b
700b1090: eb01 1300    	add.w	r3, r1, r0, lsl #4
700b1094: 0102         	lsls	r2, r0, #0x4
700b1096: 5889         	ldr	r1, [r1, r2]
;                 gMpuRegionConfig[i].size,
700b1098: 685a         	ldr	r2, [r3, #0x4]
;                 &gMpuRegionConfig[i].attrs
700b109a: 3308         	adds	r3, #0x8
;         MpuP_setRegion(i,
700b109c: f7ff ff08    	bl	0x700b0eb0 <MpuP_setRegion> @ imm = #-0x1f0
;     }
700b10a0: e7ff         	b	0x700b10a2 <MpuP_init+0x62> @ imm = #-0x2
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700b10a2: 9801         	ldr	r0, [sp, #0x4]
700b10a4: 3001         	adds	r0, #0x1
700b10a6: 9001         	str	r0, [sp, #0x4]
700b10a8: e7e4         	b	0x700b1074 <MpuP_init+0x34> @ imm = #-0x38
;     if (gMpuConfig.enableBackgroundRegion!=0U) {
700b10aa: f241 70d0    	movw	r0, #0x17d0
700b10ae: f2c7 000b    	movt	r0, #0x700b
700b10b2: 6840         	ldr	r0, [r0, #0x4]
700b10b4: b118         	cbz	r0, 0x700b10be <MpuP_init+0x7e> @ imm = #0x6
700b10b6: e7ff         	b	0x700b10b8 <MpuP_init+0x78> @ imm = #-0x2
;         MpuP_enableBRAsm();
700b10b8: f000 e82e    	blx	0x700b1118 <MpuP_enableBRAsm> @ imm = #0x5c
;     }
700b10bc: e7ff         	b	0x700b10be <MpuP_init+0x7e> @ imm = #-0x2
;     if (gMpuConfig.enableMpu!=0U) {
700b10be: f241 70d0    	movw	r0, #0x17d0
700b10c2: f2c7 000b    	movt	r0, #0x700b
700b10c6: 6880         	ldr	r0, [r0, #0x8]
700b10c8: b118         	cbz	r0, 0x700b10d2 <MpuP_init+0x92> @ imm = #0x6
700b10ca: e7ff         	b	0x700b10cc <MpuP_init+0x8c> @ imm = #-0x2
;         MpuP_enable();
700b10cc: f7ff ff90    	bl	0x700b0ff0 <MpuP_enable> @ imm = #-0xe0
;     }
700b10d0: e7ff         	b	0x700b10d2 <MpuP_init+0x92> @ imm = #-0x2
; }
700b10d2: b002         	add	sp, #0x8
700b10d4: bd80         	pop	{r7, pc}
700b10d6: 0000         	movs	r0, r0

700b10d8 <MpuP_disableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b10d8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1             // clear bit 0 in r0
700b10dc: e3c00001     	bic	r0, r0, #1
;         dsb
700b10e0: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU disabled (bit 0 = 0)
700b10e4: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700b10e8: f57ff06f     	isb	sy
;         bx      LR
700b10ec: e12fff1e     	bx	lr

700b10f0 <MpuP_disableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b10f0: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x20000         // clear bit 17 in r0
700b10f4: e3c00802     	bic	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // disable background region
700b10f8: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b10fc: e12fff1e     	bx	lr

700b1100 <MpuP_enableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b1100: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1             // set bit 0 in r0
700b1104: e3800001     	orr	r0, r0, #1
;         dsb
700b1108: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU enabled (bit 0 = 1)
700b110c: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700b1110: f57ff06f     	isb	sy
;         bx      LR
700b1114: e12fff1e     	bx	lr

700b1118 <MpuP_enableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b1118: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x20000         // set bit 17 in r0
700b111c: e3800802     	orr	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // background region enabled
700b1120: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b1124: e12fff1e     	bx	lr

700b1128 <MpuP_isEnableAsm>:
;         mov     r0, #0
700b1128: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0  // read SCTLR register to r1
700b112c: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1                 // test bit 0
700b1130: e3110001     	tst	r1, #1
;         movne   r0, #1                   // if not 0, MPU is enabled
700b1134: 13a00001     	movne	r0, #1
;         bx      LR
700b1138: e12fff1e     	bx	lr

700b113c <MpuP_setRegionAsm>:
;         mcr     p15, #0, r0, c6, c2, #0  // select MPU region
700b113c: ee060f12     	mcr	p15, #0x0, r0, c6, c2, #0x0
;         mcr     p15, #0, r1, c6, c1, #0  // set region base address
700b1140: ee061f11     	mcr	p15, #0x0, r1, c6, c1, #0x0
;         mcr     p15, #0, r2, c6, c1, #2  // set region size and enable it
700b1144: ee062f51     	mcr	p15, #0x0, r2, c6, c1, #0x2
;         mcr     p15, #0, r3, c6, c1, #4  // set protection attributes
700b1148: ee063f91     	mcr	p15, #0x0, r3, c6, c1, #0x4
;         bx      LR
700b114c: e12fff1e     	bx	lr

Disassembly of section .text.boot:

700b1150 <_c_int00_sbl>:
;         MRC     p15, #0, r1, c0, c0, #5
700b1150: ee101fb0     	mrc	p15, #0x0, r1, c0, c0, #0x5
;         BFC     r1, #8, #24
700b1154: e7df141f     	bfc	r1, #8, #24
;         CMP     r1, #0
700b1158: e3510000     	cmp	r1, #0
;         BNE     _sblLoopForever
700b115c: 1a000001     	bne	0x700b1168 <_sblLoopForever> @ imm = #0x4
;         LDR     r1, _c_int00_addr
700b1160: e59f1008     	ldr	r1, [pc, #0x8]          @ 0x700b1170 <_c_int00_addr>
;         BLX     r1
700b1164: e12fff31     	blx	r1

700b1168 <_sblLoopForever>:
;         WFI
700b1168: e320f003     	wfi
;         B       _sblLoopForever
700b116c: eafffffd     	b	0x700b1168 <_sblLoopForever> @ imm = #-0xc

700b1170 <_c_int00_addr>:
700b1170: 74 11 0b 70  	.word	0x700b1174

700b1174 <_c_int00>:
;         mrs     r0, cpsr
700b1174: e10f0000     	mrs	r0, apsr
;         orr     r0, r0, #0xC0
700b1178: e38000c0     	orr	r0, r0, #192
;         msr     cpsr_cf, r0
700b117c: e129f000     	msr	CPSR_fc, r0
;         MRC      p15,#0x0,r0,c1,c0,#2
700b1180: ee110f50     	mrc	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r3,#0xf00000
700b1184: e3a0360f     	mov	r3, #15728640
;         ORR      r0,r0,r3
700b1188: e1800003     	orr	r0, r0, r3
;         MCR      p15,#0x0,r0,c1,c0,#2
700b118c: ee010f50     	mcr	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r0,#0x40000000
700b1190: e3a00101     	mov	r0, #1073741824
;         FMXR     FPEXC,r0
700b1194: eee80a10     	vmsr	fpexc, r0
;         MRS     r0, cpsr
700b1198: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b119c: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x11  // SET FIQ MODE
700b11a0: e3800011     	orr	r0, r0, #17
;         MSR     cpsr_cf, r0
700b11a4: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_FIQ_STACK_END
700b11a8: e59fd0d4     	ldr	sp, [pc, #0xd4]         @ 0x700b1284 <c_FIQ_STACK_END>
;         MRS     r0, cpsr
700b11ac: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b11b0: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x12  // SET IRQ MODE
700b11b4: e3800012     	orr	r0, r0, #18
;         MSR     cpsr_cf, r0
700b11b8: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_IRQ_STACK_END
700b11bc: e59fd0bc     	ldr	sp, [pc, #0xbc]         @ 0x700b1280 <c_IRQ_STACK_END>
;         MRS     r0, cpsr
700b11c0: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b11c4: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x13  // SET SVC MODE
700b11c8: e3800013     	orr	r0, r0, #19
;         MSR     cpsr_cf, r0
700b11cc: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_SVC_STACK_END
700b11d0: e59fd0b0     	ldr	sp, [pc, #0xb0]         @ 0x700b1288 <c_SVC_STACK_END>
;         MRS     r0, cpsr
700b11d4: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b11d8: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x17  // SET ABORT MODE
700b11dc: e3800017     	orr	r0, r0, #23
;         MSR     cpsr_cf, r0
700b11e0: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_ABORT_STACK_END
700b11e4: e59fd0a0     	ldr	sp, [pc, #0xa0]         @ 0x700b128c <c_ABORT_STACK_END>
;         MRS     r0, cpsr
700b11e8: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b11ec: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1B  // SET ABORT MODE
700b11f0: e380001b     	orr	r0, r0, #27
;         MSR     cpsr_cf, r0
700b11f4: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_UNDEFINED_STACK_END
700b11f8: e59fd090     	ldr	sp, [pc, #0x90]         @ 0x700b1290 <c_UNDEFINED_STACK_END>
;         MRS     r0, cpsr
700b11fc: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b1200: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1F  // SET SYSTEM MODE
700b1204: e380001f     	orr	r0, r0, #31
;         MSR     cpsr_cf, r0
700b1208: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_STACK_END
700b120c: e59fd068     	ldr	sp, [pc, #0x68]         @ 0x700b127c <c_STACK_END>
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700b1210: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC r0, r0, #0x1 << 2      // Disable data cache bit
700b1214: e3c00004     	bic	r0, r0, #4
;         BIC r0, r0, #0x1 << 12     // Disable instruction cache bit
700b1218: e3c00a01     	bic	r0, r0, #4096
;         DSB
700b121c: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700b1220: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB                        // Ensures following instructions are not executed from cache
700b1224: f57ff06f     	isb	sy
;         MRC p15, 0, r1, c1, c0, 1  // Read Auxiliary Control Register
700b1228: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         ORR r1, r1, #(0x1 << 3)    //Enable ECC for Cache
700b122c: e3811008     	orr	r1, r1, #8
;         ORR r1,r1,#(0x1 << 5)
700b1230: e3811020     	orr	r1, r1, #32
;         MCR p15, 0, r1, c1, c0, 1  // Write Auxiliary Control Register
700b1234: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         MCR p15, 0, r0, c15, c5, 0 // Invalidate entire data cache
700b1238: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         MCR p15, 0, r0, c7, c5, 0  // Invalidate entire instruction cache
700b123c: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700b1240: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR r0, r0, #0x1 << 2      // Enable data cache bit
700b1244: e3800004     	orr	r0, r0, #4
;         ORR r0, r0, #0x1 << 12     // Enable instruction cache bit
700b1248: e3800a01     	orr	r0, r0, #4096
;         DSB
700b124c: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700b1250: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB
700b1254: f57ff06f     	isb	sy
;         BL      __mpu_init
700b1258: fa000028     	blx	0x700b1300 <__mpu_init> @ imm = #0xa0
;         BL      _system_pre_init
700b125c: fa00001b     	blx	0x700b12d0 <_system_pre_init> @ imm = #0x6c
;         CMP     R0, #0
700b1260: e3500000     	cmp	r0, #0
;         BEQ     bypass_auto_init
700b1264: 0a000000     	beq	0x700b126c <bypass_auto_init> @ imm = #0x0
;         BL      __TI_auto_init
700b1268: ebffedf6     	bl	0x700aca48 <__TI_auto_init_nobinit_nopinit> @ imm = #-0x4828

700b126c <bypass_auto_init>:
;         BL      main
700b126c: fafffaaf     	blx	0x700afd30 <main>       @ imm = #-0x1544
;         MOV     R0, #1
700b1270: e3a00001     	mov	r0, #1
;         BL      exit
700b1274: eb000025     	bl	0x700b1310 <abort>      @ imm = #0x94

700b1278 <L1>:
; L1:     B       L1
700b1278: eafffffe     	b	0x700b1278 <L1>         @ imm = #-0x8

700b127c <c_STACK_END>:
700b127c: 80 91 09 70  	.word	0x70099180

700b1280 <c_IRQ_STACK_END>:
700b1280: 60 2b 0b 70  	.word	0x700b2b60

700b1284 <c_FIQ_STACK_END>:
700b1284: 60 2c 0b 70  	.word	0x700b2c60

700b1288 <c_SVC_STACK_END>:
700b1288: 60 3c 0b 70  	.word	0x700b3c60

700b128c <c_ABORT_STACK_END>:
700b128c: 60 3d 0b 70  	.word	0x700b3d60

700b1290 <c_UNDEFINED_STACK_END>:
700b1290: 60 3e 0b 70  	.word	0x700b3e60
700b1294: 00 00 00 00  	.word	0x00000000
700b1298: 00 00 00 00  	.word	0x00000000
700b129c: 00 00 00 00  	.word	0x00000000

700b12a0 <_DebugP_assertNoLog>:
; {
700b12a0: b580         	push	{r7, lr}
700b12a2: b082         	sub	sp, #0x8
700b12a4: 9001         	str	r0, [sp, #0x4]
;     if(expression==0)
700b12a6: 9801         	ldr	r0, [sp, #0x4]
700b12a8: b950         	cbnz	r0, 0x700b12c0 <_DebugP_assertNoLog+0x20> @ imm = #0x14
700b12aa: e7ff         	b	0x700b12ac <_DebugP_assertNoLog+0xc> @ imm = #-0x2
700b12ac: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700b12ae: 9000         	str	r0, [sp]
;         (void) HwiP_disable();
700b12b0: f7ff eb36    	blx	0x700b0920 <HwiP_disable> @ imm = #-0x994
;         while(assert_loop!= 0U)
700b12b4: e7ff         	b	0x700b12b6 <_DebugP_assertNoLog+0x16> @ imm = #-0x2
700b12b6: 9800         	ldr	r0, [sp]
700b12b8: b108         	cbz	r0, 0x700b12be <_DebugP_assertNoLog+0x1e> @ imm = #0x2
700b12ba: e7ff         	b	0x700b12bc <_DebugP_assertNoLog+0x1c> @ imm = #-0x2
700b12bc: e7fb         	b	0x700b12b6 <_DebugP_assertNoLog+0x16> @ imm = #-0xa
;     }
700b12be: e7ff         	b	0x700b12c0 <_DebugP_assertNoLog+0x20> @ imm = #-0x2
; }
700b12c0: b002         	add	sp, #0x8
700b12c2: bd80         	pop	{r7, pc}
		...

700b12d0 <_system_pre_init>:
; {
700b12d0: b580         	push	{r7, lr}
700b12d2: b082         	sub	sp, #0x8
;     uint32_t bss_size = ((uintptr_t)&__BSS_END - (uintptr_t)&__BSS_START);
700b12d4: f240 0000    	movw	r0, #0x0
700b12d8: f2c7 0008    	movt	r0, #0x7008
700b12dc: f245 1180    	movw	r1, #0x5180
700b12e0: f2c7 0108    	movt	r1, #0x7008
700b12e4: 1a09         	subs	r1, r1, r0
700b12e6: 9101         	str	r1, [sp, #0x4]
;     (void) memset((void*)&__BSS_START, 0x00, bss_size);
700b12e8: 9901         	ldr	r1, [sp, #0x4]
700b12ea: f7e9 ee54    	blx	0x7009af94 <__aeabi_memclr8> @ imm = #-0x16358
700b12ee: 2001         	movs	r0, #0x1
;     return 1;
700b12f0: b002         	add	sp, #0x8
700b12f2: bd80         	pop	{r7, pc}
		...

700b1300 <__mpu_init>:
; {
700b1300: b580         	push	{r7, lr}
;     MpuP_init();
700b1302: f7ff fe9d    	bl	0x700b1040 <MpuP_init>  @ imm = #-0x2c6
;     CacheP_init();
700b1306: e8bd 4080    	pop.w	{r7, lr}
700b130a: f7ff bd09    	b.w	0x700b0d20 <CacheP_init> @ imm = #-0x5ee
700b130e: 0000         	movs	r0, r0

Disassembly of section .text:abort:

700b1310 <abort>:
700b1310: e320f000     	nop
700b1314: eafffffe     	b	0x700b1314 <abort+0x4>  @ imm = #-0x8

Disassembly of section .text:

70099180 <__TI_printfi_nofloat>:
70099180: e92d4ff0     	push	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099184: e24ddf89     	sub	sp, sp, #548
70099188: e5907000     	ldr	r7, [r0]
7009918c: e1a08000     	mov	r8, r0
70099190: e1a05003     	mov	r5, r3
70099194: e1a06002     	mov	r6, r2
70099198: e58d1220     	str	r1, [sp, #0x220]
7009919c: e1a00007     	mov	r0, r7
700991a0: eb0058ed     	bl	0x700af55c <strlen>     @ imm = #0x163b4
700991a4: e0879000     	add	r9, r7, r0
700991a8: e3a0a000     	mov	r10, #0
700991ac: e28dbf83     	add	r11, sp, #524
700991b0: e3a04000     	mov	r4, #0
700991b4: e3e00000     	mvn	r0, #0
700991b8: e58da21c     	str	r10, [sp, #0x21c]
700991bc: e1570009     	cmp	r7, r9
700991c0: 2a0000a4     	bhs	0x70099458 <__TI_printfi_nofloat+0x2d8> @ imm = #0x290
700991c4: e2877001     	add	r7, r7, #1
700991c8: e58da20c     	str	r10, [sp, #0x20c]
700991cc: e5cda218     	strb	r10, [sp, #0x218]
700991d0: e58da210     	str	r10, [sp, #0x210]
700991d4: e58d0214     	str	r0, [sp, #0x214]
700991d8: e5570001     	ldrb	r0, [r7, #-0x1]
700991dc: e3500000     	cmp	r0, #0
700991e0: 0a00009c     	beq	0x70099458 <__TI_printfi_nofloat+0x2d8> @ imm = #0x270
700991e4: e3500025     	cmp	r0, #37
700991e8: 0a000005     	beq	0x70099204 <__TI_printfi_nofloat+0x84> @ imm = #0x14
700991ec: e1a01006     	mov	r1, r6
700991f0: e5887000     	str	r7, [r8]
700991f4: e12fff35     	blx	r5
700991f8: e2844001     	add	r4, r4, #1
700991fc: e2877001     	add	r7, r7, #1
70099200: eafffff4     	b	0x700991d8 <__TI_printfi_nofloat+0x58> @ imm = #-0x30
70099204: e1a0000b     	mov	r0, r11
70099208: e1a01008     	mov	r1, r8
7009920c: e58d421c     	str	r4, [sp, #0x21c]
70099210: e5887000     	str	r7, [r8]
70099214: eb000092     	bl	0x70099464 <pproc_fflags___TI_printfi_nofloat> @ imm = #0x248
70099218: e1a0000b     	mov	r0, r11
7009921c: e1a01008     	mov	r1, r8
70099220: e28d2e22     	add	r2, sp, #544
70099224: eb0000a8     	bl	0x700994cc <_pproc_fwp___TI_printfi_nofloat> @ imm = #0x2a0
70099228: e5980000     	ldr	r0, [r8]
7009922c: e5d02000     	ldrb	r2, [r0]
70099230: e2421068     	sub	r1, r2, #104
70099234: e1a010e1     	ror	r1, r1, #1
70099238: e3510009     	cmp	r1, #9
7009923c: 8a000026     	bhi	0x700992dc <__TI_printfi_nofloat+0x15c> @ imm = #0x98
70099240: e28f3000     	add	r3, pc, #0
70099244: e793f101     	ldr	pc, [r3, r1, lsl #2]
70099248: 70 92 09 70  	.word	0x70099270
7009924c: 8c 92 09 70  	.word	0x7009928c
70099250: 98 92 09 70  	.word	0x70099298
70099254: dc 92 09 70  	.word	0x700992dc
70099258: dc 92 09 70  	.word	0x700992dc
7009925c: dc 92 09 70  	.word	0x700992dc
70099260: b8 92 09 70  	.word	0x700992b8
70099264: dc 92 09 70  	.word	0x700992dc
70099268: dc 92 09 70  	.word	0x700992dc
7009926c: c4 92 09 70  	.word	0x700992c4
70099270: e1a01000     	mov	r1, r0
70099274: e59d220c     	ldr	r2, [sp, #0x20c]
70099278: e5f13001     	ldrb	r3, [r1, #0x1]!
7009927c: e3530068     	cmp	r3, #104
70099280: 1a00005b     	bne	0x700993f4 <__TI_printfi_nofloat+0x274> @ imm = #0x16c
70099284: e3822c02     	orr	r2, r2, #512
70099288: ea000008     	b	0x700992b0 <__TI_printfi_nofloat+0x130> @ imm = #0x20
7009928c: e59d120c     	ldr	r1, [sp, #0x20c]
70099290: e3812b02     	orr	r2, r1, #2048
70099294: ea00000c     	b	0x700992cc <__TI_printfi_nofloat+0x14c> @ imm = #0x30
70099298: e1a01000     	mov	r1, r0
7009929c: e59d220c     	ldr	r2, [sp, #0x20c]
700992a0: e5f13001     	ldrb	r3, [r1, #0x1]!
700992a4: e353006c     	cmp	r3, #108
700992a8: 1a000053     	bne	0x700993fc <__TI_printfi_nofloat+0x27c> @ imm = #0x14c
700992ac: e3822c01     	orr	r2, r2, #256
700992b0: e2801002     	add	r1, r0, #2
700992b4: ea000005     	b	0x700992d0 <__TI_printfi_nofloat+0x150> @ imm = #0x14
700992b8: e59d120c     	ldr	r1, [sp, #0x20c]
700992bc: e3812a02     	orr	r2, r1, #8192
700992c0: ea000001     	b	0x700992cc <__TI_printfi_nofloat+0x14c> @ imm = #0x4
700992c4: e59d120c     	ldr	r1, [sp, #0x20c]
700992c8: e3812a01     	orr	r2, r1, #4096
700992cc: e2801001     	add	r1, r0, #1
700992d0: e58d220c     	str	r2, [sp, #0x20c]
700992d4: e5d12000     	ldrb	r2, [r1]
700992d8: e1a00001     	mov	r0, r1
700992dc: e2807001     	add	r7, r0, #1
700992e0: e5cd2218     	strb	r2, [sp, #0x218]
700992e4: e3520073     	cmp	r2, #115
700992e8: e5887000     	str	r7, [r8]
700992ec: 0a00001a     	beq	0x7009935c <__TI_printfi_nofloat+0x1dc> @ imm = #0x68
700992f0: e352006e     	cmp	r2, #110
700992f4: 1a000022     	bne	0x70099384 <__TI_printfi_nofloat+0x204> @ imm = #0x88
700992f8: e59d020c     	ldr	r0, [sp, #0x20c]
700992fc: e3031f60     	movw	r1, #0x3f60
70099300: e0000001     	and	r0, r0, r1
70099304: e3500020     	cmp	r0, #32
70099308: 0a00003e     	beq	0x70099408 <__TI_printfi_nofloat+0x288> @ imm = #0xf8
7009930c: e3500040     	cmp	r0, #64
70099310: 0a000041     	beq	0x7009941c <__TI_printfi_nofloat+0x29c> @ imm = #0x104
70099314: e3a0a000     	mov	r10, #0
70099318: e3500a02     	cmp	r0, #8192
7009931c: 0a00002f     	beq	0x700993e0 <__TI_printfi_nofloat+0x260> @ imm = #0xbc
70099320: e3500c02     	cmp	r0, #512
70099324: 0a000042     	beq	0x70099434 <__TI_printfi_nofloat+0x2b4> @ imm = #0x108
70099328: e3500b02     	cmp	r0, #2048
7009932c: 0a000003     	beq	0x70099340 <__TI_printfi_nofloat+0x1c0> @ imm = #0xc
70099330: e3500a01     	cmp	r0, #4096
70099334: 0a000029     	beq	0x700993e0 <__TI_printfi_nofloat+0x260> @ imm = #0xa4
70099338: e3500c01     	cmp	r0, #256
7009933c: 1a000027     	bne	0x700993e0 <__TI_printfi_nofloat+0x260> @ imm = #0x9c
70099340: e59d0220     	ldr	r0, [sp, #0x220]
70099344: e1a03fc4     	asr	r3, r4, #31
70099348: e4901004     	ldr	r1, [r0], #4
7009934c: e58d0220     	str	r0, [sp, #0x220]
70099350: e5814000     	str	r4, [r1]
70099354: e5813004     	str	r3, [r1, #0x4]
70099358: ea000039     	b	0x70099444 <__TI_printfi_nofloat+0x2c4> @ imm = #0xe4
7009935c: e5dd020c     	ldrb	r0, [sp, #0x20c]
70099360: e3100040     	tst	r0, #64
70099364: 1a000016     	bne	0x700993c4 <__TI_printfi_nofloat+0x244> @ imm = #0x58
70099368: e1a0000b     	mov	r0, r11
7009936c: e1a01006     	mov	r1, r6
70099370: e28d2e22     	add	r2, sp, #544
70099374: e28d3f87     	add	r3, sp, #540
70099378: e58d5000     	str	r5, [sp]
7009937c: eb0000f9     	bl	0x70099768 <_pproc_str___TI_printfi_nofloat> @ imm = #0x3e4
70099380: ea00002f     	b	0x70099444 <__TI_printfi_nofloat+0x2c4> @ imm = #0xbc
70099384: e28da00e     	add	r10, sp, #14
70099388: e1a0100b     	mov	r1, r11
7009938c: e28d2e22     	add	r2, sp, #544
70099390: e1a0000a     	mov	r0, r10
70099394: eb000138     	bl	0x7009987c <_setfield___TI_printfi_nofloat> @ imm = #0x4e0
70099398: e59d3248     	ldr	r3, [sp, #0x248]
7009939c: e1a02000     	mov	r2, r0
700993a0: e1a0000a     	mov	r0, r10
700993a4: e1a01006     	mov	r1, r6
700993a8: e12fff33     	blx	r3
700993ac: e3700001     	cmn	r0, #1
700993b0: 10800004     	addne	r0, r0, r4
700993b4: e3a0a000     	mov	r10, #0
700993b8: e1a04000     	mov	r4, r0
700993bc: e58d021c     	str	r0, [sp, #0x21c]
700993c0: ea000020     	b	0x70099448 <__TI_printfi_nofloat+0x2c8> @ imm = #0x80
700993c4: e1a0000b     	mov	r0, r11
700993c8: e1a01006     	mov	r1, r6
700993cc: e28d2e22     	add	r2, sp, #544
700993d0: e28d3f87     	add	r3, sp, #540
700993d4: e58d5000     	str	r5, [sp]
700993d8: eb000092     	bl	0x70099628 <_pproc_wstr___TI_printfi_nofloat> @ imm = #0x248
700993dc: ea000018     	b	0x70099444 <__TI_printfi_nofloat+0x2c4> @ imm = #0x60
700993e0: e59d0220     	ldr	r0, [sp, #0x220]
700993e4: e4901004     	ldr	r1, [r0], #4
700993e8: e58d0220     	str	r0, [sp, #0x220]
700993ec: e5814000     	str	r4, [r1]
700993f0: ea000013     	b	0x70099444 <__TI_printfi_nofloat+0x2c4> @ imm = #0x4c
700993f4: e3820020     	orr	r0, r2, #32
700993f8: ea000000     	b	0x70099400 <__TI_printfi_nofloat+0x280> @ imm = #0x0
700993fc: e3820040     	orr	r0, r2, #64
70099400: e58d020c     	str	r0, [sp, #0x20c]
70099404: eaffffb2     	b	0x700992d4 <__TI_printfi_nofloat+0x154> @ imm = #-0x138
70099408: e59d0220     	ldr	r0, [sp, #0x220]
7009940c: e4901004     	ldr	r1, [r0], #4
70099410: e58d0220     	str	r0, [sp, #0x220]
70099414: e1c140b0     	strh	r4, [r1]
70099418: ea000003     	b	0x7009942c <__TI_printfi_nofloat+0x2ac> @ imm = #0xc
7009941c: e59d0220     	ldr	r0, [sp, #0x220]
70099420: e4901004     	ldr	r1, [r0], #4
70099424: e58d0220     	str	r0, [sp, #0x220]
70099428: e5814000     	str	r4, [r1]
7009942c: e3a0a000     	mov	r10, #0
70099430: ea000003     	b	0x70099444 <__TI_printfi_nofloat+0x2c4> @ imm = #0xc
70099434: e59d0220     	ldr	r0, [sp, #0x220]
70099438: e4901004     	ldr	r1, [r0], #4
7009943c: e58d0220     	str	r0, [sp, #0x220]
70099440: e5c14000     	strb	r4, [r1]
70099444: e59d421c     	ldr	r4, [sp, #0x21c]
70099448: e3e00000     	mvn	r0, #0
7009944c: e3740001     	cmn	r4, #1
70099450: 1affff59     	bne	0x700991bc <__TI_printfi_nofloat+0x3c> @ imm = #-0x29c
70099454: e3e04000     	mvn	r4, #0
70099458: e1a00004     	mov	r0, r4
7009945c: e28ddf89     	add	sp, sp, #548
70099460: e8bd8ff0     	pop	{r4, r5, r6, r7, r8, r9, r10, r11, pc}

70099464 <pproc_fflags___TI_printfi_nofloat>:
70099464: e591c000     	ldr	r12, [r1]
70099468: e5dc3000     	ldrb	r3, [r12]
7009946c: e3530020     	cmp	r3, #32
70099470: 0a00000a     	beq	0x700994a0 <pproc_fflags___TI_printfi_nofloat+0x3c> @ imm = #0x28
70099474: e3530023     	cmp	r3, #35
70099478: 0a00000a     	beq	0x700994a8 <pproc_fflags___TI_printfi_nofloat+0x44> @ imm = #0x28
7009947c: e3530030     	cmp	r3, #48
70099480: 0a00000a     	beq	0x700994b0 <pproc_fflags___TI_printfi_nofloat+0x4c> @ imm = #0x28
70099484: e3a02001     	mov	r2, #1
70099488: e353002d     	cmp	r3, #45
7009948c: 0a000008     	beq	0x700994b4 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x20
70099490: e353002b     	cmp	r3, #43
70099494: 112fff1e     	bxne	lr
70099498: e3a02002     	mov	r2, #2
7009949c: ea000004     	b	0x700994b4 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x10
700994a0: e3a02004     	mov	r2, #4
700994a4: ea000002     	b	0x700994b4 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x8
700994a8: e3a02008     	mov	r2, #8
700994ac: ea000000     	b	0x700994b4 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x0
700994b0: e3a02010     	mov	r2, #16
700994b4: e5903000     	ldr	r3, [r0]
700994b8: e1832002     	orr	r2, r3, r2
700994bc: e28c3001     	add	r3, r12, #1
700994c0: e5802000     	str	r2, [r0]
700994c4: e5813000     	str	r3, [r1]
700994c8: eaffffe5     	b	0x70099464 <pproc_fflags___TI_printfi_nofloat> @ imm = #-0x6c

700994cc <_pproc_fwp___TI_printfi_nofloat>:
700994cc: e92d48ff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r11, lr}
700994d0: e1a05001     	mov	r5, r1
700994d4: e5911000     	ldr	r1, [r1]
700994d8: e1a06002     	mov	r6, r2
700994dc: e1a04000     	mov	r4, r0
700994e0: e5d13000     	ldrb	r3, [r1]
700994e4: e353002a     	cmp	r3, #42
700994e8: 1a00000f     	bne	0x7009952c <_pproc_fwp___TI_printfi_nofloat+0x60> @ imm = #0x3c
700994ec: e5960000     	ldr	r0, [r6]
700994f0: e2801004     	add	r1, r0, #4
700994f4: e5861000     	str	r1, [r6]
700994f8: e5900000     	ldr	r0, [r0]
700994fc: e3700001     	cmn	r0, #1
70099500: e5840004     	str	r0, [r4, #0x4]
70099504: ca000004     	bgt	0x7009951c <_pproc_fwp___TI_printfi_nofloat+0x50> @ imm = #0x10
70099508: e5941000     	ldr	r1, [r4]
7009950c: e2600000     	rsb	r0, r0, #0
70099510: e3811001     	orr	r1, r1, #1
70099514: e5840004     	str	r0, [r4, #0x4]
70099518: e5841000     	str	r1, [r4]
7009951c: e5950000     	ldr	r0, [r5]
70099520: e2807001     	add	r7, r0, #1
70099524: e5857000     	str	r7, [r5]
70099528: ea000015     	b	0x70099584 <_pproc_fwp___TI_printfi_nofloat+0xb8> @ imm = #0x54
7009952c: e3a00000     	mov	r0, #0
70099530: e28d2006     	add	r2, sp, #6
70099534: e2433030     	sub	r3, r3, #48
70099538: e3530009     	cmp	r3, #9
7009953c: 8a000007     	bhi	0x70099560 <_pproc_fwp___TI_printfi_nofloat+0x94> @ imm = #0x1c
70099540: e0813000     	add	r3, r1, r0
70099544: e2837001     	add	r7, r3, #1
70099548: e5857000     	str	r7, [r5]
7009954c: e7d17000     	ldrb	r7, [r1, r0]
70099550: e5d33001     	ldrb	r3, [r3, #0x1]
70099554: e7c27000     	strb	r7, [r2, r0]
70099558: e2800001     	add	r0, r0, #1
7009955c: eafffff4     	b	0x70099534 <_pproc_fwp___TI_printfi_nofloat+0x68> @ imm = #-0x30
70099560: e3a03000     	mov	r3, #0
70099564: e0817000     	add	r7, r1, r0
70099568: e7c23000     	strb	r3, [r2, r0]
7009956c: e5dd2006     	ldrb	r2, [sp, #0x6]
70099570: e3520000     	cmp	r2, #0
70099574: 0a000002     	beq	0x70099584 <_pproc_fwp___TI_printfi_nofloat+0xb8> @ imm = #0x8
70099578: e28d0006     	add	r0, sp, #6
7009957c: eb004812     	bl	0x700ab5cc <atoi>       @ imm = #0x12048
70099580: e5840004     	str	r0, [r4, #0x4]
70099584: e5d70000     	ldrb	r0, [r7]
70099588: e350002e     	cmp	r0, #46
7009958c: 18bd88ff     	popne	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
70099590: e2870001     	add	r0, r7, #1
70099594: e5850000     	str	r0, [r5]
70099598: e5d72001     	ldrb	r2, [r7, #0x1]
7009959c: e352002a     	cmp	r2, #42
700995a0: 1a000008     	bne	0x700995c8 <_pproc_fwp___TI_printfi_nofloat+0xfc> @ imm = #0x20
700995a4: e5960000     	ldr	r0, [r6]
700995a8: e2801004     	add	r1, r0, #4
700995ac: e5861000     	str	r1, [r6]
700995b0: e5951000     	ldr	r1, [r5]
700995b4: e5900000     	ldr	r0, [r0]
700995b8: e2811001     	add	r1, r1, #1
700995bc: e5840008     	str	r0, [r4, #0x8]
700995c0: e5851000     	str	r1, [r5]
700995c4: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
700995c8: e3a00000     	mov	r0, #0
700995cc: e28d1006     	add	r1, sp, #6
700995d0: e2422030     	sub	r2, r2, #48
700995d4: e3520009     	cmp	r2, #9
700995d8: 8a000007     	bhi	0x700995fc <_pproc_fwp___TI_printfi_nofloat+0x130> @ imm = #0x1c
700995dc: e0872000     	add	r2, r7, r0
700995e0: e2823002     	add	r3, r2, #2
700995e4: e5853000     	str	r3, [r5]
700995e8: e5d23001     	ldrb	r3, [r2, #0x1]
700995ec: e5d22002     	ldrb	r2, [r2, #0x2]
700995f0: e7c13000     	strb	r3, [r1, r0]
700995f4: e2800001     	add	r0, r0, #1
700995f8: eafffff4     	b	0x700995d0 <_pproc_fwp___TI_printfi_nofloat+0x104> @ imm = #-0x30
700995fc: e3a02000     	mov	r2, #0
70099600: e7c12000     	strb	r2, [r1, r0]
70099604: e5dd0006     	ldrb	r0, [sp, #0x6]
70099608: e3500000     	cmp	r0, #0
7009960c: 0a000003     	beq	0x70099620 <_pproc_fwp___TI_printfi_nofloat+0x154> @ imm = #0xc
70099610: e28d0006     	add	r0, sp, #6
70099614: eb0047ec     	bl	0x700ab5cc <atoi>       @ imm = #0x11fb0
70099618: e5840008     	str	r0, [r4, #0x8]
7009961c: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
70099620: e5842008     	str	r2, [r4, #0x8]
70099624: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}

70099628 <_pproc_wstr___TI_printfi_nofloat>:
70099628: e92d4ff8     	push	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
7009962c: e5927000     	ldr	r7, [r2]
70099630: e1a04001     	mov	r4, r1
70099634: e59dc028     	ldr	r12, [sp, #0x28]
70099638: e2876004     	add	r6, r7, #4
7009963c: e5826000     	str	r6, [r2]
70099640: e5976000     	ldr	r6, [r7]
70099644: e3560000     	cmp	r6, #0
70099648: 0a00002d     	beq	0x70099704 <_pproc_wstr___TI_printfi_nofloat+0xdc> @ imm = #0xb4
7009964c: e5907008     	ldr	r7, [r0, #0x8]
70099650: e1a05003     	mov	r5, r3
70099654: e1a09000     	mov	r9, r0
70099658: e1a0800c     	mov	r8, r12
7009965c: e3570000     	cmp	r7, #0
70099660: 4a000003     	bmi	0x70099674 <_pproc_wstr___TI_printfi_nofloat+0x4c> @ imm = #0xc
70099664: e1a00006     	mov	r0, r6
70099668: eb00573c     	bl	0x700af360 <wcslen>     @ imm = #0x15cf0
7009966c: e1570000     	cmp	r7, r0
70099670: 3a000002     	blo	0x70099680 <_pproc_wstr___TI_printfi_nofloat+0x58> @ imm = #0x8
70099674: e1a00006     	mov	r0, r6
70099678: eb005738     	bl	0x700af360 <wcslen>     @ imm = #0x15ce0
7009967c: e1a07000     	mov	r7, r0
70099680: e599a004     	ldr	r10, [r9, #0x4]
70099684: e1a0b007     	mov	r11, r7
70099688: e5950000     	ldr	r0, [r5]
7009968c: e58d5000     	str	r5, [sp]
70099690: e15a0007     	cmp	r10, r7
70099694: c1a0b00a     	movgt	r11, r10
70099698: e080000b     	add	r0, r0, r11
7009969c: e5850000     	str	r0, [r5]
700996a0: da00000b     	ble	0x700996d4 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x2c
700996a4: e5d90000     	ldrb	r0, [r9]
700996a8: e3100001     	tst	r0, #1
700996ac: 1a000008     	bne	0x700996d4 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x20
700996b0: e04b0007     	sub	r0, r11, r7
700996b4: e1c05fc0     	bic	r5, r0, r0, asr #31
700996b8: e3550000     	cmp	r5, #0
700996bc: 0a000004     	beq	0x700996d4 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x10
700996c0: e3a00020     	mov	r0, #32
700996c4: e1a01004     	mov	r1, r4
700996c8: e12fff38     	blx	r8
700996cc: e2455001     	sub	r5, r5, #1
700996d0: eafffff8     	b	0x700996b8 <_pproc_wstr___TI_printfi_nofloat+0x90> @ imm = #-0x20
700996d4: e1c75fc7     	bic	r5, r7, r7, asr #31
700996d8: e3550000     	cmp	r5, #0
700996dc: 0a00000c     	beq	0x70099714 <_pproc_wstr___TI_printfi_nofloat+0xec> @ imm = #0x30
700996e0: e5960000     	ldr	r0, [r6]
700996e4: e3500c01     	cmp	r0, #256
700996e8: 2a000017     	bhs	0x7009974c <_pproc_wstr___TI_printfi_nofloat+0x124> @ imm = #0x5c
700996ec: e6ef0070     	uxtb	r0, r0
700996f0: e1a01004     	mov	r1, r4
700996f4: e2866004     	add	r6, r6, #4
700996f8: e12fff38     	blx	r8
700996fc: e2455001     	sub	r5, r5, #1
70099700: eafffff4     	b	0x700996d8 <_pproc_wstr___TI_printfi_nofloat+0xb0> @ imm = #-0x30
70099704: e3a00000     	mov	r0, #0
70099708: e1a01004     	mov	r1, r4
7009970c: e8bd4ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099710: e12fff1c     	bx	r12
70099714: e15a0007     	cmp	r10, r7
70099718: da000011     	ble	0x70099764 <_pproc_wstr___TI_printfi_nofloat+0x13c> @ imm = #0x44
7009971c: e5d90000     	ldrb	r0, [r9]
70099720: e3100001     	tst	r0, #1
70099724: 08bd8ff8     	popeq	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099728: e04b0007     	sub	r0, r11, r7
7009972c: e1c05fc0     	bic	r5, r0, r0, asr #31
70099730: e3550000     	cmp	r5, #0
70099734: 0a00000a     	beq	0x70099764 <_pproc_wstr___TI_printfi_nofloat+0x13c> @ imm = #0x28
70099738: e3a00020     	mov	r0, #32
7009973c: e1a01004     	mov	r1, r4
70099740: e12fff38     	blx	r8
70099744: e2455001     	sub	r5, r5, #1
70099748: eafffff8     	b	0x70099730 <_pproc_wstr___TI_printfi_nofloat+0x108> @ imm = #-0x20
7009974c: e3e00000     	mvn	r0, #0
70099750: e59d1000     	ldr	r1, [sp]
70099754: e5810000     	str	r0, [r1]
70099758: eb00048d     	bl	0x7009a994 <__aeabi_errno_addr> @ imm = #0x1234
7009975c: e3a01058     	mov	r1, #88
70099760: e5801000     	str	r1, [r0]
70099764: e8bd8ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}

70099768 <_pproc_str___TI_printfi_nofloat>:
70099768: e92d4ff8     	push	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
7009976c: e5927000     	ldr	r7, [r2]
70099770: e1a04001     	mov	r4, r1
70099774: e59dc028     	ldr	r12, [sp, #0x28]
70099778: e2876004     	add	r6, r7, #4
7009977c: e5826000     	str	r6, [r2]
70099780: e5977000     	ldr	r7, [r7]
70099784: e3570000     	cmp	r7, #0
70099788: 0a000037     	beq	0x7009986c <_pproc_str___TI_printfi_nofloat+0x104> @ imm = #0xdc
7009978c: e590b008     	ldr	r11, [r0, #0x8]
70099790: e1a05003     	mov	r5, r3
70099794: e1a08000     	mov	r8, r0
70099798: e1a0600c     	mov	r6, r12
7009979c: e35b0000     	cmp	r11, #0
700997a0: 4a000003     	bmi	0x700997b4 <_pproc_str___TI_printfi_nofloat+0x4c> @ imm = #0xc
700997a4: e1a00007     	mov	r0, r7
700997a8: eb00576b     	bl	0x700af55c <strlen>     @ imm = #0x15dac
700997ac: e15b0000     	cmp	r11, r0
700997b0: 3a000002     	blo	0x700997c0 <_pproc_str___TI_printfi_nofloat+0x58> @ imm = #0x8
700997b4: e1a00007     	mov	r0, r7
700997b8: eb005767     	bl	0x700af55c <strlen>     @ imm = #0x15d9c
700997bc: e1a0b000     	mov	r11, r0
700997c0: e598a004     	ldr	r10, [r8, #0x4]
700997c4: e1a0900b     	mov	r9, r11
700997c8: e5950000     	ldr	r0, [r5]
700997cc: e15a000b     	cmp	r10, r11
700997d0: c1a0900a     	movgt	r9, r10
700997d4: e0800009     	add	r0, r0, r9
700997d8: e5850000     	str	r0, [r5]
700997dc: da00000b     	ble	0x70099810 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x2c
700997e0: e5d80000     	ldrb	r0, [r8]
700997e4: e3100001     	tst	r0, #1
700997e8: 1a000008     	bne	0x70099810 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x20
700997ec: e049000b     	sub	r0, r9, r11
700997f0: e1c05fc0     	bic	r5, r0, r0, asr #31
700997f4: e3550000     	cmp	r5, #0
700997f8: 0a000004     	beq	0x70099810 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x10
700997fc: e3a00020     	mov	r0, #32
70099800: e1a01004     	mov	r1, r4
70099804: e12fff36     	blx	r6
70099808: e2455001     	sub	r5, r5, #1
7009980c: eafffff8     	b	0x700997f4 <_pproc_str___TI_printfi_nofloat+0x8c> @ imm = #-0x20
70099810: e1cb5fcb     	bic	r5, r11, r11, asr #31
70099814: e3550000     	cmp	r5, #0
70099818: 0a000004     	beq	0x70099830 <_pproc_str___TI_printfi_nofloat+0xc8> @ imm = #0x10
7009981c: e4d70001     	ldrb	r0, [r7], #1
70099820: e1a01004     	mov	r1, r4
70099824: e12fff36     	blx	r6
70099828: e2455001     	sub	r5, r5, #1
7009982c: eafffff8     	b	0x70099814 <_pproc_str___TI_printfi_nofloat+0xac> @ imm = #-0x20
70099830: e15a000b     	cmp	r10, r11
70099834: da00000b     	ble	0x70099868 <_pproc_str___TI_printfi_nofloat+0x100> @ imm = #0x2c
70099838: e5d80000     	ldrb	r0, [r8]
7009983c: e3100001     	tst	r0, #1
70099840: 08bd8ff8     	popeq	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099844: e049000b     	sub	r0, r9, r11
70099848: e1c05fc0     	bic	r5, r0, r0, asr #31
7009984c: e3550000     	cmp	r5, #0
70099850: 0a000004     	beq	0x70099868 <_pproc_str___TI_printfi_nofloat+0x100> @ imm = #0x10
70099854: e3a00020     	mov	r0, #32
70099858: e1a01004     	mov	r1, r4
7009985c: e12fff36     	blx	r6
70099860: e2455001     	sub	r5, r5, #1
70099864: eafffff8     	b	0x7009984c <_pproc_str___TI_printfi_nofloat+0xe4> @ imm = #-0x20
70099868: e8bd8ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
7009986c: e3a00000     	mov	r0, #0
70099870: e1a01004     	mov	r1, r4
70099874: e8bd4ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099878: e12fff1c     	bx	r12

7009987c <_setfield___TI_printfi_nofloat>:
7009987c: e92d4ffe     	push	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099880: e1a05001     	mov	r5, r1
70099884: e5918004     	ldr	r8, [r1, #0x4]
70099888: e3a09000     	mov	r9, #0
7009988c: e1a06002     	mov	r6, r2
70099890: e30011fd     	movw	r1, #0x1fd
70099894: e3a02020     	mov	r2, #32
70099898: e1a04000     	mov	r4, r0
7009989c: e58d9004     	str	r9, [sp, #0x4]
700998a0: eb0058ae     	bl	0x700afb60 <__aeabi_memset8> @ imm = #0x162b8
700998a4: e1a0b004     	mov	r11, r4
700998a8: e2842f7f     	add	r2, r4, #508
700998ac: e5eb91fd     	strb	r9, [r11, #0x1fd]!
700998b0: e5d5000c     	ldrb	r0, [r5, #0xc]
700998b4: e58d2008     	str	r2, [sp, #0x8]
700998b8: e2401063     	sub	r1, r0, #99
700998bc: e3510015     	cmp	r1, #21
700998c0: 8a000080     	bhi	0x70099ac8 <_setfield___TI_printfi_nofloat+0x24c> @ imm = #0x200
700998c4: e59f2258     	ldr	r2, [pc, #0x258]        @ 0x70099b24 <_setfield___TI_printfi_nofloat+0x2a8>
700998c8: e3a03001     	mov	r3, #1
700998cc: e1120113     	tst	r2, r3, lsl r1
700998d0: 0a00006b     	beq	0x70099a84 <_setfield___TI_printfi_nofloat+0x208> @ imm = #0x1ac
700998d4: e28d1004     	add	r1, sp, #4
700998d8: e28d2008     	add	r2, sp, #8
700998dc: e1a00005     	mov	r0, r5
700998e0: e1a03006     	mov	r3, r6
700998e4: eb00008f     	bl	0x70099b28 <_pproc_diouxp___TI_printfi_nofloat> @ imm = #0x23c
700998e8: e3a09000     	mov	r9, #0
700998ec: e5d5000c     	ldrb	r0, [r5, #0xc]
700998f0: e240106f     	sub	r1, r0, #111
700998f4: e3510009     	cmp	r1, #9
700998f8: 8a00003c     	bhi	0x700999f0 <_setfield___TI_printfi_nofloat+0x174> @ imm = #0xf0
700998fc: e3a02001     	mov	r2, #1
70099900: e3003243     	movw	r3, #0x243
70099904: e1130112     	tst	r3, r2, lsl r1
70099908: 0a000038     	beq	0x700999f0 <_setfield___TI_printfi_nofloat+0x174> @ imm = #0xe0
7009990c: e3a0a000     	mov	r10, #0
70099910: e5d51000     	ldrb	r1, [r5]
70099914: e0847008     	add	r7, r4, r8
70099918: e59d0008     	ldr	r0, [sp, #0x8]
7009991c: e1a06004     	mov	r6, r4
70099920: e3110001     	tst	r1, #1
70099924: 1a000006     	bne	0x70099944 <_setfield___TI_printfi_nofloat+0xc8> @ imm = #0x18
70099928: e5952004     	ldr	r2, [r5, #0x4]
7009992c: e04b1000     	sub	r1, r11, r0
70099930: e1a06004     	mov	r6, r4
70099934: e1510002     	cmp	r1, r2
70099938: ca000001     	bgt	0x70099944 <_setfield___TI_printfi_nofloat+0xc8> @ imm = #0x4
7009993c: e0471001     	sub	r1, r7, r1
70099940: e2816001     	add	r6, r1, #1
70099944: e2801001     	add	r1, r0, #1
70099948: e1a00006     	mov	r0, r6
7009994c: e3a02000     	mov	r2, #0
70099950: e30031fe     	movw	r3, #0x1fe
70099954: e3a08000     	mov	r8, #0
70099958: eb004f0a     	bl	0x700ad588 <memccpy>    @ imm = #0x13c28
7009995c: e58d0008     	str	r0, [sp, #0x8]
70099960: e3590000     	cmp	r9, #0
70099964: 0a000001     	beq	0x70099970 <_setfield___TI_printfi_nofloat+0xf4> @ imm = #0x4
70099968: e4c08001     	strb	r8, [r0], #1
7009996c: e58d0008     	str	r0, [sp, #0x8]
70099970: e1500007     	cmp	r0, r7
70099974: 8a000006     	bhi	0x70099994 <_setfield___TI_printfi_nofloat+0x118> @ imm = #0x18
70099978: e0471000     	sub	r1, r7, r0
7009997c: e2400001     	sub	r0, r0, #1
70099980: e3a02020     	mov	r2, #32
70099984: e2811001     	add	r1, r1, #1
70099988: eb005874     	bl	0x700afb60 <__aeabi_memset8> @ imm = #0x161d0
7009998c: e3a00000     	mov	r0, #0
70099990: e5c70000     	strb	r0, [r7]
70099994: e5d50000     	ldrb	r0, [r5]
70099998: e3100010     	tst	r0, #16
7009999c: 1a000004     	bne	0x700999b4 <_setfield___TI_printfi_nofloat+0x138> @ imm = #0x10
700999a0: e0461004     	sub	r1, r6, r4
700999a4: e1a00004     	mov	r0, r4
700999a8: e3a02020     	mov	r2, #32
700999ac: eb00586b     	bl	0x700afb60 <__aeabi_memset8> @ imm = #0x161ac
700999b0: ea00002f     	b	0x70099a74 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xbc
700999b4: e1560004     	cmp	r6, r4
700999b8: 0a00002d     	beq	0x70099a74 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xb4
700999bc: e0461004     	sub	r1, r6, r4
700999c0: e1a00004     	mov	r0, r4
700999c4: e3a02030     	mov	r2, #48
700999c8: e3a07030     	mov	r7, #48
700999cc: eb005863     	bl	0x700afb60 <__aeabi_memset8> @ imm = #0x1618c
700999d0: e59d0004     	ldr	r0, [sp, #0x4]
700999d4: e190000a     	orrs	r0, r0, r10
700999d8: 1a00000e     	bne	0x70099a18 <_setfield___TI_printfi_nofloat+0x19c> @ imm = #0x38
700999dc: e5d50000     	ldrb	r0, [r5]
700999e0: e3100004     	tst	r0, #4
700999e4: 1a00000b     	bne	0x70099a18 <_setfield___TI_printfi_nofloat+0x19c> @ imm = #0x2c
700999e8: e1a00004     	mov	r0, r4
700999ec: ea00000d     	b	0x70099a28 <_setfield___TI_printfi_nofloat+0x1ac> @ imm = #0x34
700999f0: e3500058     	cmp	r0, #88
700999f4: 0affffc4     	beq	0x7009990c <_setfield___TI_printfi_nofloat+0x90> @ imm = #-0xf0
700999f8: e5950000     	ldr	r0, [r5]
700999fc: e59d1004     	ldr	r1, [sp, #0x4]
70099a00: e200a002     	and	r10, r0, #2
70099a04: e3510000     	cmp	r1, #0
70099a08: 0a000037     	beq	0x70099aec <_setfield___TI_printfi_nofloat+0x270> @ imm = #0xdc
70099a0c: e3a0002d     	mov	r0, #45
70099a10: e59d1008     	ldr	r1, [sp, #0x8]
70099a14: ea00003f     	b	0x70099b18 <_setfield___TI_printfi_nofloat+0x29c> @ imm = #0xfc
70099a18: e5d61000     	ldrb	r1, [r6]
70099a1c: e1a00004     	mov	r0, r4
70099a20: e4c01001     	strb	r1, [r0], #1
70099a24: e4c67001     	strb	r7, [r6], #1
70099a28: e5d5100c     	ldrb	r1, [r5, #0xc]
70099a2c: e3510041     	cmp	r1, #65
70099a30: 0a00000b     	beq	0x70099a64 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x2c
70099a34: e3510058     	cmp	r1, #88
70099a38: 0a000004     	beq	0x70099a50 <_setfield___TI_printfi_nofloat+0x1d4> @ imm = #0x10
70099a3c: e3510061     	cmp	r1, #97
70099a40: 0a000007     	beq	0x70099a64 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x1c
70099a44: e3510078     	cmp	r1, #120
70099a48: 13510070     	cmpne	r1, #112
70099a4c: 1a000008     	bne	0x70099a74 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0x20
70099a50: e5d52000     	ldrb	r2, [r5]
70099a54: e3120008     	tst	r2, #8
70099a58: 1a000001     	bne	0x70099a64 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x4
70099a5c: e3510061     	cmp	r1, #97
70099a60: 1a000003     	bne	0x70099a74 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xc
70099a64: e5d61001     	ldrb	r1, [r6, #0x1]
70099a68: e3a02030     	mov	r2, #48
70099a6c: e5c01001     	strb	r1, [r0, #0x1]
70099a70: e5c62001     	strb	r2, [r6, #0x1]
70099a74: e1a00004     	mov	r0, r4
70099a78: eb0056b7     	bl	0x700af55c <strlen>     @ imm = #0x15adc
70099a7c: e0800009     	add	r0, r0, r9
70099a80: e8bd8ffe     	pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099a84: e3510000     	cmp	r1, #0
70099a88: 1a00000e     	bne	0x70099ac8 <_setfield___TI_printfi_nofloat+0x24c> @ imm = #0x38
70099a8c: e5960000     	ldr	r0, [r6]
70099a90: e2801004     	add	r1, r0, #4
70099a94: e5861000     	str	r1, [r6]
70099a98: e5900000     	ldr	r0, [r0]
70099a9c: e6ef1070     	uxtb	r1, r0
70099aa0: e5c401fc     	strb	r0, [r4, #0x1fc]
70099aa4: e30001fb     	movw	r0, #0x1fb
70099aa8: e5952000     	ldr	r2, [r5]
70099aac: e16f1f11     	clz	r1, r1
70099ab0: e0840000     	add	r0, r4, r0
70099ab4: e3c22002     	bic	r2, r2, #2
70099ab8: e1a092a1     	lsr	r9, r1, #5
70099abc: e58d0008     	str	r0, [sp, #0x8]
70099ac0: e5852000     	str	r2, [r5]
70099ac4: eaffff88     	b	0x700998ec <_setfield___TI_printfi_nofloat+0x70> @ imm = #-0x1e0
70099ac8: e3500025     	cmp	r0, #37
70099acc: 0a000002     	beq	0x70099adc <_setfield___TI_printfi_nofloat+0x260> @ imm = #0x8
70099ad0: e3500058     	cmp	r0, #88
70099ad4: 0affff7e     	beq	0x700998d4 <_setfield___TI_printfi_nofloat+0x58> @ imm = #-0x208
70099ad8: eaffff84     	b	0x700998f0 <_setfield___TI_printfi_nofloat+0x74> @ imm = #-0x1f0
70099adc: e3a01025     	mov	r1, #37
70099ae0: e3a00001     	mov	r0, #1
70099ae4: e1c410b0     	strh	r1, [r4]
70099ae8: e8bd8ffe     	pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099aec: e35a0000     	cmp	r10, #0
70099af0: 1a000005     	bne	0x70099b0c <_setfield___TI_printfi_nofloat+0x290> @ imm = #0x14
70099af4: e3100004     	tst	r0, #4
70099af8: 0affff83     	beq	0x7009990c <_setfield___TI_printfi_nofloat+0x90> @ imm = #-0x1f4
70099afc: e3a00020     	mov	r0, #32
70099b00: e59d1008     	ldr	r1, [sp, #0x8]
70099b04: e3a0a000     	mov	r10, #0
70099b08: ea000002     	b	0x70099b18 <_setfield___TI_printfi_nofloat+0x29c> @ imm = #0x8
70099b0c: e3a0002b     	mov	r0, #43
70099b10: e59d1008     	ldr	r1, [sp, #0x8]
70099b14: e3a0a001     	mov	r10, #1
70099b18: e4410001     	strb	r0, [r1], #-1
70099b1c: e58d1008     	str	r1, [sp, #0x8]
70099b20: eaffff7a     	b	0x70099910 <_setfield___TI_printfi_nofloat+0x94> @ imm = #-0x218
70099b24: 42 30 24 00  	.word	0x00243042

70099b28 <_pproc_diouxp___TI_printfi_nofloat>:
70099b28: e92d48fc     	push	{r2, r3, r4, r5, r6, r7, r11, lr}
70099b2c: e1a05000     	mov	r5, r0
70099b30: e5900008     	ldr	r0, [r0, #0x8]
70099b34: e1a04002     	mov	r4, r2
70099b38: e1a07001     	mov	r7, r1
70099b3c: e3a06010     	mov	r6, #16
70099b40: e3700001     	cmn	r0, #1
70099b44: c5950000     	ldrgt	r0, [r5]
70099b48: c3c00010     	bicgt	r0, r0, #16
70099b4c: c5850000     	strgt	r0, [r5]
70099b50: d3a00001     	movle	r0, #1
70099b54: d5850008     	strle	r0, [r5, #0x8]
70099b58: e5d5000c     	ldrb	r0, [r5, #0xc]
70099b5c: e3500058     	cmp	r0, #88
70099b60: 0a000005     	beq	0x70099b7c <_pproc_diouxp___TI_printfi_nofloat+0x54> @ imm = #0x14
70099b64: e3500078     	cmp	r0, #120
70099b68: 13500070     	cmpne	r0, #112
70099b6c: 0a000002     	beq	0x70099b7c <_pproc_diouxp___TI_printfi_nofloat+0x54> @ imm = #0x8
70099b70: e350006f     	cmp	r0, #111
70099b74: 13a0600a     	movne	r6, #10
70099b78: 03a06008     	moveq	r6, #8
70099b7c: e1a00005     	mov	r0, r5
70099b80: e1a01003     	mov	r1, r3
70099b84: eb00004d     	bl	0x70099cc0 <_getarg_diouxp___TI_printfi_nofloat> @ imm = #0x134
70099b88: e5952008     	ldr	r2, [r5, #0x8]
70099b8c: e3520000     	cmp	r2, #0
70099b90: 01902001     	orrseq	r2, r0, r1
70099b94: 0a000007     	beq	0x70099bb8 <_pproc_diouxp___TI_printfi_nofloat+0x90> @ imm = #0x1c
70099b98: e5d5300c     	ldrb	r3, [r5, #0xc]
70099b9c: e3530064     	cmp	r3, #100
70099ba0: 1a00000b     	bne	0x70099bd4 <_pproc_diouxp___TI_printfi_nofloat+0xac> @ imm = #0x2c
70099ba4: e3a02064     	mov	r2, #100
70099ba8: e3a03064     	mov	r3, #100
70099bac: e3710001     	cmn	r1, #1
70099bb0: ca000011     	bgt	0x70099bfc <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x44
70099bb4: ea00000b     	b	0x70099be8 <_pproc_diouxp___TI_printfi_nofloat+0xc0> @ imm = #0x2c
70099bb8: e5d50000     	ldrb	r0, [r5]
70099bbc: e3100008     	tst	r0, #8
70099bc0: 0a00003d     	beq	0x70099cbc <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0xf4
70099bc4: e5d5300c     	ldrb	r3, [r5, #0xc]
70099bc8: e3a00000     	mov	r0, #0
70099bcc: e3a01000     	mov	r1, #0
70099bd0: ea000009     	b	0x70099bfc <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x24
70099bd4: e3530069     	cmp	r3, #105
70099bd8: 1a000007     	bne	0x70099bfc <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x1c
70099bdc: e3a02069     	mov	r2, #105
70099be0: e3510000     	cmp	r1, #0
70099be4: 5a000004     	bpl	0x70099bfc <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x10
70099be8: e2700000     	rsbs	r0, r0, #0
70099bec: e3a0c001     	mov	r12, #1
70099bf0: e2e11000     	rsc	r1, r1, #0
70099bf4: e1a03002     	mov	r3, r2
70099bf8: e587c000     	str	r12, [r7]
70099bfc: e1a02006     	mov	r2, r6
70099c00: e58d4000     	str	r4, [sp]
70099c04: eb00009c     	bl	0x70099e7c <_ltostr___TI_printfi_nofloat> @ imm = #0x270
70099c08: e3a01030     	mov	r1, #48
70099c0c: e5952008     	ldr	r2, [r5, #0x8]
70099c10: e1500002     	cmp	r0, r2
70099c14: aa000005     	bge	0x70099c30 <_pproc_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x14
70099c18: e5942000     	ldr	r2, [r4]
70099c1c: e2800001     	add	r0, r0, #1
70099c20: e2423001     	sub	r3, r2, #1
70099c24: e5843000     	str	r3, [r4]
70099c28: e5c21000     	strb	r1, [r2]
70099c2c: eafffff6     	b	0x70099c0c <_pproc_diouxp___TI_printfi_nofloat+0xe4> @ imm = #-0x28
70099c30: e5d5000c     	ldrb	r0, [r5, #0xc]
70099c34: e3500058     	cmp	r0, #88
70099c38: 13500078     	cmpne	r0, #120
70099c3c: 1a00000f     	bne	0x70099c80 <_pproc_diouxp___TI_printfi_nofloat+0x158> @ imm = #0x3c
70099c40: e5d51000     	ldrb	r1, [r5]
70099c44: e3110008     	tst	r1, #8
70099c48: 0a00000e     	beq	0x70099c88 <_pproc_diouxp___TI_printfi_nofloat+0x160> @ imm = #0x38
70099c4c: e5941000     	ldr	r1, [r4]
70099c50: e3500070     	cmp	r0, #112
70099c54: 03000078     	movweq	r0, #0x78
70099c58: e2412001     	sub	r2, r1, #1
70099c5c: e5842000     	str	r2, [r4]
70099c60: e3a02030     	mov	r2, #48
70099c64: e5c10000     	strb	r0, [r1]
70099c68: e5940000     	ldr	r0, [r4]
70099c6c: e2401001     	sub	r1, r0, #1
70099c70: e5841000     	str	r1, [r4]
70099c74: e5c02000     	strb	r2, [r0]
70099c78: e5d5000c     	ldrb	r0, [r5, #0xc]
70099c7c: ea000001     	b	0x70099c88 <_pproc_diouxp___TI_printfi_nofloat+0x160> @ imm = #0x4
70099c80: e3500070     	cmp	r0, #112
70099c84: 0affffed     	beq	0x70099c40 <_pproc_diouxp___TI_printfi_nofloat+0x118> @ imm = #-0x4c
70099c88: e350006f     	cmp	r0, #111
70099c8c: 1a00000a     	bne	0x70099cbc <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0x28
70099c90: e5d50000     	ldrb	r0, [r5]
70099c94: e3100008     	tst	r0, #8
70099c98: 0a000007     	beq	0x70099cbc <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0x1c
70099c9c: e5940000     	ldr	r0, [r4]
70099ca0: e5d01001     	ldrb	r1, [r0, #0x1]
70099ca4: e3510030     	cmp	r1, #48
70099ca8: 08bd88fc     	popeq	{r2, r3, r4, r5, r6, r7, r11, pc}
70099cac: e2401001     	sub	r1, r0, #1
70099cb0: e3a02030     	mov	r2, #48
70099cb4: e5841000     	str	r1, [r4]
70099cb8: e5c02000     	strb	r2, [r0]
70099cbc: e8bd88fc     	pop	{r2, r3, r4, r5, r6, r7, r11, pc}

70099cc0 <_getarg_diouxp___TI_printfi_nofloat>:
70099cc0: e92d4800     	push	{r11, lr}
70099cc4: e5d0200c     	ldrb	r2, [r0, #0xc]
70099cc8: e3520070     	cmp	r2, #112
70099ccc: 1a000002     	bne	0x70099cdc <_getarg_diouxp___TI_printfi_nofloat+0x1c> @ imm = #0x8
70099cd0: e5910000     	ldr	r0, [r1]
70099cd4: e3a03000     	mov	r3, #0
70099cd8: ea000037     	b	0x70099dbc <_getarg_diouxp___TI_printfi_nofloat+0xfc> @ imm = #0xdc
70099cdc: e5900000     	ldr	r0, [r0]
70099ce0: e3033f60     	movw	r3, #0x3f60
70099ce4: e0000003     	and	r0, r0, r3
70099ce8: e3500a02     	cmp	r0, #8192
70099cec: 13500040     	cmpne	r0, #64
70099cf0: 1a000011     	bne	0x70099d3c <_getarg_diouxp___TI_printfi_nofloat+0x7c> @ imm = #0x44
70099cf4: e3a03000     	mov	r3, #0
70099cf8: e242e064     	sub	lr, r2, #100
70099cfc: e35e0014     	cmp	lr, #20
70099d00: 8a00002a     	bhi	0x70099db0 <_getarg_diouxp___TI_printfi_nofloat+0xf0> @ imm = #0xa8
70099d04: e3000800     	movw	r0, #0x800
70099d08: e3a0c001     	mov	r12, #1
70099d0c: e3400012     	movt	r0, #0x12
70099d10: e1100e1c     	tst	r0, r12, lsl lr
70099d14: 1a000027     	bne	0x70099db8 <_getarg_diouxp___TI_printfi_nofloat+0xf8> @ imm = #0x9c
70099d18: e3a00021     	mov	r0, #33
70099d1c: e1100e1c     	tst	r0, r12, lsl lr
70099d20: 0a000022     	beq	0x70099db0 <_getarg_diouxp___TI_printfi_nofloat+0xf0> @ imm = #0x88
70099d24: e5910000     	ldr	r0, [r1]
70099d28: e2802004     	add	r2, r0, #4
70099d2c: e5812000     	str	r2, [r1]
70099d30: e5900000     	ldr	r0, [r0]
70099d34: e1a03fc0     	asr	r3, r0, #31
70099d38: ea000022     	b	0x70099dc8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x88
70099d3c: e3500c01     	cmp	r0, #256
70099d40: 0a000022     	beq	0x70099dd0 <_getarg_diouxp___TI_printfi_nofloat+0x110> @ imm = #0x88
70099d44: e3500c02     	cmp	r0, #512
70099d48: 0a000036     	beq	0x70099e28 <_getarg_diouxp___TI_printfi_nofloat+0x168> @ imm = #0xd8
70099d4c: e3500b02     	cmp	r0, #2048
70099d50: 0a00001e     	beq	0x70099dd0 <_getarg_diouxp___TI_printfi_nofloat+0x110> @ imm = #0x78
70099d54: e3a03000     	mov	r3, #0
70099d58: e242e064     	sub	lr, r2, #100
70099d5c: e3500a01     	cmp	r0, #4096
70099d60: 0affffe5     	beq	0x70099cfc <_getarg_diouxp___TI_printfi_nofloat+0x3c> @ imm = #-0x6c
70099d64: e3500020     	cmp	r0, #32
70099d68: 1affffe3     	bne	0x70099cfc <_getarg_diouxp___TI_printfi_nofloat+0x3c> @ imm = #-0x74
70099d6c: e35e0014     	cmp	lr, #20
70099d70: 8a000007     	bhi	0x70099d94 <_getarg_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x1c
70099d74: e3000800     	movw	r0, #0x800
70099d78: e3a0c001     	mov	r12, #1
70099d7c: e3400012     	movt	r0, #0x12
70099d80: e1100e1c     	tst	r0, r12, lsl lr
70099d84: 1a000004     	bne	0x70099d9c <_getarg_diouxp___TI_printfi_nofloat+0xdc> @ imm = #0x10
70099d88: e3a00021     	mov	r0, #33
70099d8c: e1100e1c     	tst	r0, r12, lsl lr
70099d90: 1affffe3     	bne	0x70099d24 <_getarg_diouxp___TI_printfi_nofloat+0x64> @ imm = #-0x74
70099d94: e3520058     	cmp	r2, #88
70099d98: 1a000035     	bne	0x70099e74 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0xd4
70099d9c: e5910000     	ldr	r0, [r1]
70099da0: e2802004     	add	r2, r0, #4
70099da4: e5812000     	str	r2, [r1]
70099da8: e1d000b0     	ldrh	r0, [r0]
70099dac: ea000005     	b	0x70099dc8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x14
70099db0: e3520058     	cmp	r2, #88
70099db4: 1a00002e     	bne	0x70099e74 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0xb8
70099db8: e5910000     	ldr	r0, [r1]
70099dbc: e2802004     	add	r2, r0, #4
70099dc0: e5812000     	str	r2, [r1]
70099dc4: e5900000     	ldr	r0, [r0]
70099dc8: e1a01003     	mov	r1, r3
70099dcc: e8bd8800     	pop	{r11, pc}
70099dd0: e2420064     	sub	r0, r2, #100
70099dd4: e3500014     	cmp	r0, #20
70099dd8: 8a000007     	bhi	0x70099dfc <_getarg_diouxp___TI_printfi_nofloat+0x13c> @ imm = #0x1c
70099ddc: e3003800     	movw	r3, #0x800
70099de0: e3a0c001     	mov	r12, #1
70099de4: e3403012     	movt	r3, #0x12
70099de8: e113001c     	tst	r3, r12, lsl r0
70099dec: 1a000006     	bne	0x70099e0c <_getarg_diouxp___TI_printfi_nofloat+0x14c> @ imm = #0x18
70099df0: e3a03021     	mov	r3, #33
70099df4: e113001c     	tst	r3, r12, lsl r0
70099df8: 1a000003     	bne	0x70099e0c <_getarg_diouxp___TI_printfi_nofloat+0x14c> @ imm = #0xc
70099dfc: e3a00000     	mov	r0, #0
70099e00: e3a03000     	mov	r3, #0
70099e04: e3520058     	cmp	r2, #88
70099e08: 1affffee     	bne	0x70099dc8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0x48
70099e0c: e5910000     	ldr	r0, [r1]
70099e10: e2800007     	add	r0, r0, #7
70099e14: e3c00007     	bic	r0, r0, #7
70099e18: e2802008     	add	r2, r0, #8
70099e1c: e5812000     	str	r2, [r1]
70099e20: e8900009     	ldm	r0, {r0, r3}
70099e24: eaffffe7     	b	0x70099dc8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0x64
70099e28: e3a03000     	mov	r3, #0
70099e2c: e242e064     	sub	lr, r2, #100
70099e30: e35e0014     	cmp	lr, #20
70099e34: 8a000007     	bhi	0x70099e58 <_getarg_diouxp___TI_printfi_nofloat+0x198> @ imm = #0x1c
70099e38: e3000800     	movw	r0, #0x800
70099e3c: e3a0c001     	mov	r12, #1
70099e40: e3400012     	movt	r0, #0x12
70099e44: e1100e1c     	tst	r0, r12, lsl lr
70099e48: 1a000004     	bne	0x70099e60 <_getarg_diouxp___TI_printfi_nofloat+0x1a0> @ imm = #0x10
70099e4c: e3a00021     	mov	r0, #33
70099e50: e1100e1c     	tst	r0, r12, lsl lr
70099e54: 1affffb2     	bne	0x70099d24 <_getarg_diouxp___TI_printfi_nofloat+0x64> @ imm = #-0x138
70099e58: e3520058     	cmp	r2, #88
70099e5c: 1a000004     	bne	0x70099e74 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0x10
70099e60: e5910000     	ldr	r0, [r1]
70099e64: e2802004     	add	r2, r0, #4
70099e68: e5812000     	str	r2, [r1]
70099e6c: e5d00000     	ldrb	r0, [r0]
70099e70: eaffffd4     	b	0x70099dc8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0xb0
70099e74: e3a00000     	mov	r0, #0
70099e78: eaffffd2     	b	0x70099dc8 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0xb8

70099e7c <_ltostr___TI_printfi_nofloat>:
70099e7c: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
70099e80: e59fc074     	ldr	r12, [pc, #0x74]        @ 0x70099efc <_ltostr___TI_printfi_nofloat+0x80>
70099e84: e1a04002     	mov	r4, r2
70099e88: e59f6070     	ldr	r6, [pc, #0x70]         @ 0x70099f00 <_ltostr___TI_printfi_nofloat+0x84>
70099e8c: e1a05000     	mov	r5, r0
70099e90: e59d8018     	ldr	r8, [sp, #0x18]
70099e94: e3530058     	cmp	r3, #88
70099e98: 01a0600c     	moveq	r6, r12
70099e9c: e1900001     	orrs	r0, r0, r1
70099ea0: 1a00000f     	bne	0x70099ee4 <_ltostr___TI_printfi_nofloat+0x68> @ imm = #0x3c
70099ea4: e5980000     	ldr	r0, [r8]
70099ea8: e3a03030     	mov	r3, #48
70099eac: e2402001     	sub	r2, r0, #1
70099eb0: e5882000     	str	r2, [r8]
70099eb4: e5c03000     	strb	r3, [r0]
70099eb8: ea000009     	b	0x70099ee4 <_ltostr___TI_printfi_nofloat+0x68> @ imm = #0x24
70099ebc: e1a00005     	mov	r0, r5
70099ec0: e1a02004     	mov	r2, r4
70099ec4: eb00000e     	bl	0x70099f04 <_div___TI_printfi_nofloat> @ imm = #0x38
70099ec8: e0625490     	mls	r2, r0, r4, r5
70099ecc: e5983000     	ldr	r3, [r8]
70099ed0: e1a05000     	mov	r5, r0
70099ed4: e2437001     	sub	r7, r3, #1
70099ed8: e7d62002     	ldrb	r2, [r6, r2]
70099edc: e5887000     	str	r7, [r8]
70099ee0: e5c32000     	strb	r2, [r3]
70099ee4: e1950001     	orrs	r0, r5, r1
70099ee8: 1afffff3     	bne	0x70099ebc <_ltostr___TI_printfi_nofloat+0x40> @ imm = #-0x34
70099eec: e5980000     	ldr	r0, [r8]
70099ef0: eb005599     	bl	0x700af55c <strlen>     @ imm = #0x15664
70099ef4: e2400001     	sub	r0, r0, #1
70099ef8: e8bd81f0     	pop	{r4, r5, r6, r7, r8, pc}
70099efc: 5b 20 0b 70  	.word	0x700b205b
70099f00: 6c 20 0b 70  	.word	0x700b206c

70099f04 <_div___TI_printfi_nofloat>:
70099f04: e92d4800     	push	{r11, lr}
70099f08: e3520010     	cmp	r2, #16
70099f0c: 0a000005     	beq	0x70099f28 <_div___TI_printfi_nofloat+0x24> @ imm = #0x14
70099f10: e3520008     	cmp	r2, #8
70099f14: 1a000007     	bne	0x70099f38 <_div___TI_printfi_nofloat+0x34> @ imm = #0x1c
70099f18: e1a001a0     	lsr	r0, r0, #3
70099f1c: e1800e81     	orr	r0, r0, r1, lsl #29
70099f20: e1a011a1     	lsr	r1, r1, #3
70099f24: e8bd8800     	pop	{r11, pc}
70099f28: e1a00220     	lsr	r0, r0, #4
70099f2c: e1800e01     	orr	r0, r0, r1, lsl #28
70099f30: e1a01221     	lsr	r1, r1, #4
70099f34: e8bd8800     	pop	{r11, pc}
70099f38: e3510000     	cmp	r1, #0
70099f3c: 1a000003     	bne	0x70099f50 <_div___TI_printfi_nofloat+0x4c> @ imm = #0xc
70099f40: e1a01002     	mov	r1, r2
70099f44: eb001527     	bl	0x7009f3e8 <__udivsi3>  @ imm = #0x549c
70099f48: e3a01000     	mov	r1, #0
70099f4c: e8bd8800     	pop	{r11, pc}
70099f50: e3a03000     	mov	r3, #0
70099f54: eb00547e     	bl	0x700af154 <__aeabi_uldivmod> @ imm = #0x151f8
70099f58: e8bd8800     	pop	{r11, pc}

70099f5c <__aeabi_memcpy8>:
70099f5c: ea00558e     	b	0x700af59c <TI_memcpy_small> @ imm = #0x15638

70099f60 <_vsnprintf>:
; {
70099f60: e92d 43f0    	push.w	{r4, r5, r6, r7, r8, r9, lr}
70099f64: b0c1         	sub	sp, #0x104
70099f66: f8dd c120    	ldr.w	r12, [sp, #0x120]
70099f6a: f8cd c100    	str.w	r12, [sp, #0x100]
70099f6e: 903f         	str	r0, [sp, #0xfc]
70099f70: 913e         	str	r1, [sp, #0xf8]
70099f72: 923d         	str	r2, [sp, #0xf4]
70099f74: 933c         	str	r3, [sp, #0xf0]
70099f76: 2000         	movs	r0, #0x0
;   size_t idx = 0U;
70099f78: 9037         	str	r0, [sp, #0xdc]
;   if (!buffer) {
70099f7a: 983e         	ldr	r0, [sp, #0xf8]
70099f7c: b930         	cbnz	r0, 0x70099f8c <_vsnprintf+0x2c> @ imm = #0xc
70099f7e: e7ff         	b	0x70099f80 <_vsnprintf+0x20> @ imm = #-0x2
;     out = _out_null;
70099f80: f64f 3071    	movw	r0, #0xfb71
70099f84: f2c7 000a    	movt	r0, #0x700a
70099f88: 903f         	str	r0, [sp, #0xfc]
;   }
70099f8a: e7ff         	b	0x70099f8c <_vsnprintf+0x2c> @ imm = #-0x2
;   while (*format)
70099f8c: e7ff         	b	0x70099f8e <_vsnprintf+0x2e> @ imm = #-0x2
70099f8e: 983c         	ldr	r0, [sp, #0xf0]
70099f90: 7800         	ldrb	r0, [r0]
70099f92: 2800         	cmp	r0, #0x0
70099f94: f000 84e3    	beq.w	0x7009a95e <_vsnprintf+0x9fe> @ imm = #0x9c6
70099f98: e7ff         	b	0x70099f9a <_vsnprintf+0x3a> @ imm = #-0x2
;     if (*format != '%') {
70099f9a: 983c         	ldr	r0, [sp, #0xf0]
70099f9c: 7800         	ldrb	r0, [r0]
70099f9e: 2825         	cmp	r0, #0x25
70099fa0: d00e         	beq	0x70099fc0 <_vsnprintf+0x60> @ imm = #0x1c
70099fa2: e7ff         	b	0x70099fa4 <_vsnprintf+0x44> @ imm = #-0x2
;       out(*format, buffer, idx++, maxlen);
70099fa4: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099fa8: 983c         	ldr	r0, [sp, #0xf0]
70099faa: 7800         	ldrb	r0, [r0]
70099fac: 993e         	ldr	r1, [sp, #0xf8]
70099fae: 9a37         	ldr	r2, [sp, #0xdc]
70099fb0: 1c53         	adds	r3, r2, #0x1
70099fb2: 9337         	str	r3, [sp, #0xdc]
70099fb4: 9b3d         	ldr	r3, [sp, #0xf4]
70099fb6: 47e0         	blx	r12
;       format++;
70099fb8: 983c         	ldr	r0, [sp, #0xf0]
70099fba: 3001         	adds	r0, #0x1
70099fbc: 903c         	str	r0, [sp, #0xf0]
;       continue;
70099fbe: e7e6         	b	0x70099f8e <_vsnprintf+0x2e> @ imm = #-0x34
;       format++;
70099fc0: 983c         	ldr	r0, [sp, #0xf0]
70099fc2: 3001         	adds	r0, #0x1
70099fc4: 903c         	str	r0, [sp, #0xf0]
70099fc6: e7ff         	b	0x70099fc8 <_vsnprintf+0x68> @ imm = #-0x2
70099fc8: 2000         	movs	r0, #0x0
;     flags = 0U;
70099fca: 903b         	str	r0, [sp, #0xec]
;     do {
70099fcc: e7ff         	b	0x70099fce <_vsnprintf+0x6e> @ imm = #-0x2
;       switch (*format) {
70099fce: 983c         	ldr	r0, [sp, #0xf0]
70099fd0: 7800         	ldrb	r0, [r0]
70099fd2: 3820         	subs	r0, #0x20
70099fd4: 4601         	mov	r1, r0
70099fd6: 912a         	str	r1, [sp, #0xa8]
70099fd8: 2810         	cmp	r0, #0x10
70099fda: d83d         	bhi	0x7009a058 <_vsnprintf+0xf8> @ imm = #0x7a
70099fdc: 992a         	ldr	r1, [sp, #0xa8]
70099fde: e8df f001    	tbb	[pc, r1]
70099fe2: 27 3b 3b 31  	.word	0x313b3b27
70099fe6: 3b 3b 3b 3b  	.word	0x3b3b3b3b
70099fea: 3b 3b 3b 1d  	.word	0x1d3b3b3b
70099fee: 3b 13 3b 3b  	.word	0x3b3b133b
70099ff2: 09 00        	.short	0x0009
;         case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
70099ff4: 983b         	ldr	r0, [sp, #0xec]
70099ff6: f040 0001    	orr	r0, r0, #0x1
70099ffa: 903b         	str	r0, [sp, #0xec]
70099ffc: 983c         	ldr	r0, [sp, #0xf0]
70099ffe: 3001         	adds	r0, #0x1
7009a000: 903c         	str	r0, [sp, #0xf0]
7009a002: 2001         	movs	r0, #0x1
7009a004: 9038         	str	r0, [sp, #0xe0]
7009a006: e02a         	b	0x7009a05e <_vsnprintf+0xfe> @ imm = #0x54
;         case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
7009a008: 983b         	ldr	r0, [sp, #0xec]
7009a00a: f040 0002    	orr	r0, r0, #0x2
7009a00e: 903b         	str	r0, [sp, #0xec]
7009a010: 983c         	ldr	r0, [sp, #0xf0]
7009a012: 3001         	adds	r0, #0x1
7009a014: 903c         	str	r0, [sp, #0xf0]
7009a016: 2001         	movs	r0, #0x1
7009a018: 9038         	str	r0, [sp, #0xe0]
7009a01a: e020         	b	0x7009a05e <_vsnprintf+0xfe> @ imm = #0x40
;         case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
7009a01c: 983b         	ldr	r0, [sp, #0xec]
7009a01e: f040 0004    	orr	r0, r0, #0x4
7009a022: 903b         	str	r0, [sp, #0xec]
7009a024: 983c         	ldr	r0, [sp, #0xf0]
7009a026: 3001         	adds	r0, #0x1
7009a028: 903c         	str	r0, [sp, #0xf0]
7009a02a: 2001         	movs	r0, #0x1
7009a02c: 9038         	str	r0, [sp, #0xe0]
7009a02e: e016         	b	0x7009a05e <_vsnprintf+0xfe> @ imm = #0x2c
;         case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
7009a030: 983b         	ldr	r0, [sp, #0xec]
7009a032: f040 0008    	orr	r0, r0, #0x8
7009a036: 903b         	str	r0, [sp, #0xec]
7009a038: 983c         	ldr	r0, [sp, #0xf0]
7009a03a: 3001         	adds	r0, #0x1
7009a03c: 903c         	str	r0, [sp, #0xf0]
7009a03e: 2001         	movs	r0, #0x1
7009a040: 9038         	str	r0, [sp, #0xe0]
7009a042: e00c         	b	0x7009a05e <_vsnprintf+0xfe> @ imm = #0x18
;         case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
7009a044: 983b         	ldr	r0, [sp, #0xec]
7009a046: f040 0010    	orr	r0, r0, #0x10
7009a04a: 903b         	str	r0, [sp, #0xec]
7009a04c: 983c         	ldr	r0, [sp, #0xf0]
7009a04e: 3001         	adds	r0, #0x1
7009a050: 903c         	str	r0, [sp, #0xf0]
7009a052: 2001         	movs	r0, #0x1
7009a054: 9038         	str	r0, [sp, #0xe0]
7009a056: e002         	b	0x7009a05e <_vsnprintf+0xfe> @ imm = #0x4
7009a058: 2000         	movs	r0, #0x0
;         default :                                   n = 0U; break;
7009a05a: 9038         	str	r0, [sp, #0xe0]
7009a05c: e7ff         	b	0x7009a05e <_vsnprintf+0xfe> @ imm = #-0x2
;     } while (n);
7009a05e: e7ff         	b	0x7009a060 <_vsnprintf+0x100> @ imm = #-0x2
7009a060: 9838         	ldr	r0, [sp, #0xe0]
7009a062: 2800         	cmp	r0, #0x0
7009a064: d1b3         	bne	0x70099fce <_vsnprintf+0x6e> @ imm = #-0x9a
7009a066: e7ff         	b	0x7009a068 <_vsnprintf+0x108> @ imm = #-0x2
7009a068: 2000         	movs	r0, #0x0
;     width = 0U;
7009a06a: 903a         	str	r0, [sp, #0xe8]
;     if (_is_digit(*format)) {
7009a06c: 983c         	ldr	r0, [sp, #0xf0]
7009a06e: 7800         	ldrb	r0, [r0]
7009a070: f014 fc56    	bl	0x700ae920 <_is_digit>  @ imm = #0x148ac
7009a074: b128         	cbz	r0, 0x7009a082 <_vsnprintf+0x122> @ imm = #0xa
7009a076: e7ff         	b	0x7009a078 <_vsnprintf+0x118> @ imm = #-0x2
7009a078: a83c         	add	r0, sp, #0xf0
;       width = _atoi(&format);
7009a07a: f014 f849    	bl	0x700ae110 <_atoi>      @ imm = #0x14092
7009a07e: 903a         	str	r0, [sp, #0xe8]
;     }
7009a080: e01e         	b	0x7009a0c0 <_vsnprintf+0x160> @ imm = #0x3c
;     else if (*format == '*') {
7009a082: 983c         	ldr	r0, [sp, #0xf0]
7009a084: 7800         	ldrb	r0, [r0]
7009a086: 282a         	cmp	r0, #0x2a
7009a088: d119         	bne	0x7009a0be <_vsnprintf+0x15e> @ imm = #0x32
7009a08a: e7ff         	b	0x7009a08c <_vsnprintf+0x12c> @ imm = #-0x2
;       const int w = va_arg(va, int);
7009a08c: 9840         	ldr	r0, [sp, #0x100]
7009a08e: 1d01         	adds	r1, r0, #0x4
7009a090: 9140         	str	r1, [sp, #0x100]
7009a092: 6800         	ldr	r0, [r0]
7009a094: 9036         	str	r0, [sp, #0xd8]
;       if (w < 0) {
7009a096: 9836         	ldr	r0, [sp, #0xd8]
7009a098: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009a09c: dc08         	bgt	0x7009a0b0 <_vsnprintf+0x150> @ imm = #0x10
7009a09e: e7ff         	b	0x7009a0a0 <_vsnprintf+0x140> @ imm = #-0x2
;         flags |= FLAGS_LEFT;    // reverse padding
7009a0a0: 983b         	ldr	r0, [sp, #0xec]
7009a0a2: f040 0002    	orr	r0, r0, #0x2
7009a0a6: 903b         	str	r0, [sp, #0xec]
;         width = (unsigned int)-w;
7009a0a8: 9836         	ldr	r0, [sp, #0xd8]
7009a0aa: 4240         	rsbs	r0, r0, #0
7009a0ac: 903a         	str	r0, [sp, #0xe8]
;       }
7009a0ae: e002         	b	0x7009a0b6 <_vsnprintf+0x156> @ imm = #0x4
;         width = (unsigned int)w;
7009a0b0: 9836         	ldr	r0, [sp, #0xd8]
7009a0b2: 903a         	str	r0, [sp, #0xe8]
7009a0b4: e7ff         	b	0x7009a0b6 <_vsnprintf+0x156> @ imm = #-0x2
;       format++;
7009a0b6: 983c         	ldr	r0, [sp, #0xf0]
7009a0b8: 3001         	adds	r0, #0x1
7009a0ba: 903c         	str	r0, [sp, #0xf0]
;     }
7009a0bc: e7ff         	b	0x7009a0be <_vsnprintf+0x15e> @ imm = #-0x2
7009a0be: e7ff         	b	0x7009a0c0 <_vsnprintf+0x160> @ imm = #-0x2
7009a0c0: 2000         	movs	r0, #0x0
;     precision = 0U;
7009a0c2: 9039         	str	r0, [sp, #0xe4]
;     if (*format == '.') {
7009a0c4: 983c         	ldr	r0, [sp, #0xf0]
7009a0c6: 7800         	ldrb	r0, [r0]
7009a0c8: 282e         	cmp	r0, #0x2e
7009a0ca: d12e         	bne	0x7009a12a <_vsnprintf+0x1ca> @ imm = #0x5c
7009a0cc: e7ff         	b	0x7009a0ce <_vsnprintf+0x16e> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;
7009a0ce: 983b         	ldr	r0, [sp, #0xec]
7009a0d0: f440 6080    	orr	r0, r0, #0x400
7009a0d4: 903b         	str	r0, [sp, #0xec]
;       format++;
7009a0d6: 983c         	ldr	r0, [sp, #0xf0]
7009a0d8: 3001         	adds	r0, #0x1
7009a0da: 903c         	str	r0, [sp, #0xf0]
;       if (_is_digit(*format)) {
7009a0dc: 983c         	ldr	r0, [sp, #0xf0]
7009a0de: 7800         	ldrb	r0, [r0]
7009a0e0: f014 fc1e    	bl	0x700ae920 <_is_digit>  @ imm = #0x1483c
7009a0e4: b128         	cbz	r0, 0x7009a0f2 <_vsnprintf+0x192> @ imm = #0xa
7009a0e6: e7ff         	b	0x7009a0e8 <_vsnprintf+0x188> @ imm = #-0x2
7009a0e8: a83c         	add	r0, sp, #0xf0
;         precision = _atoi(&format);
7009a0ea: f014 f811    	bl	0x700ae110 <_atoi>      @ imm = #0x14022
7009a0ee: 9039         	str	r0, [sp, #0xe4]
;       }
7009a0f0: e01a         	b	0x7009a128 <_vsnprintf+0x1c8> @ imm = #0x34
;       else if (*format == '*') {
7009a0f2: 983c         	ldr	r0, [sp, #0xf0]
7009a0f4: 7800         	ldrb	r0, [r0]
7009a0f6: 282a         	cmp	r0, #0x2a
7009a0f8: d115         	bne	0x7009a126 <_vsnprintf+0x1c6> @ imm = #0x2a
7009a0fa: e7ff         	b	0x7009a0fc <_vsnprintf+0x19c> @ imm = #-0x2
;         const int prec = (int)va_arg(va, int);
7009a0fc: 9840         	ldr	r0, [sp, #0x100]
7009a0fe: 1d01         	adds	r1, r0, #0x4
7009a100: 9140         	str	r1, [sp, #0x100]
7009a102: 6800         	ldr	r0, [r0]
7009a104: 9035         	str	r0, [sp, #0xd4]
;         precision = prec > 0 ? (unsigned int)prec : 0U;
7009a106: 9835         	ldr	r0, [sp, #0xd4]
7009a108: 2801         	cmp	r0, #0x1
7009a10a: db03         	blt	0x7009a114 <_vsnprintf+0x1b4> @ imm = #0x6
7009a10c: e7ff         	b	0x7009a10e <_vsnprintf+0x1ae> @ imm = #-0x2
7009a10e: 9835         	ldr	r0, [sp, #0xd4]
7009a110: 9029         	str	r0, [sp, #0xa4]
7009a112: e002         	b	0x7009a11a <_vsnprintf+0x1ba> @ imm = #0x4
7009a114: 2000         	movs	r0, #0x0
;         precision = prec > 0 ? (unsigned int)prec : 0U;
7009a116: 9029         	str	r0, [sp, #0xa4]
7009a118: e7ff         	b	0x7009a11a <_vsnprintf+0x1ba> @ imm = #-0x2
7009a11a: 9829         	ldr	r0, [sp, #0xa4]
7009a11c: 9039         	str	r0, [sp, #0xe4]
;         format++;
7009a11e: 983c         	ldr	r0, [sp, #0xf0]
7009a120: 3001         	adds	r0, #0x1
7009a122: 903c         	str	r0, [sp, #0xf0]
;       }
7009a124: e7ff         	b	0x7009a126 <_vsnprintf+0x1c6> @ imm = #-0x2
7009a126: e7ff         	b	0x7009a128 <_vsnprintf+0x1c8> @ imm = #-0x2
;     }
7009a128: e7ff         	b	0x7009a12a <_vsnprintf+0x1ca> @ imm = #-0x2
;     switch (*format) {
7009a12a: 983c         	ldr	r0, [sp, #0xf0]
7009a12c: 7800         	ldrb	r0, [r0]
7009a12e: 3868         	subs	r0, #0x68
7009a130: 4601         	mov	r1, r0
7009a132: 9128         	str	r1, [sp, #0xa0]
7009a134: 2812         	cmp	r0, #0x12
7009a136: d84e         	bhi	0x7009a1d6 <_vsnprintf+0x276> @ imm = #0x9c
7009a138: 9928         	ldr	r1, [sp, #0xa0]
7009a13a: e8df f001    	tbb	[pc, r1]
7009a13e: 1f 4c 3c 4c  	.word	0x4c3c4c1f
7009a142: 0a 4c 4c 4c  	.word	0x4c4c4c0a
7009a146: 4c 4c 4c 4c  	.word	0x4c4c4c4c
7009a14a: 34 4c 4c 4c  	.word	0x4c4c4c34
7009a14e: 4c 4c 44 00  	.word	0x00444c4c
;         flags |= FLAGS_LONG;
7009a152: 983b         	ldr	r0, [sp, #0xec]
7009a154: f440 7080    	orr	r0, r0, #0x100
7009a158: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a15a: 983c         	ldr	r0, [sp, #0xf0]
7009a15c: 3001         	adds	r0, #0x1
7009a15e: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'l') {
7009a160: 983c         	ldr	r0, [sp, #0xf0]
7009a162: 7800         	ldrb	r0, [r0]
7009a164: 286c         	cmp	r0, #0x6c
7009a166: d108         	bne	0x7009a17a <_vsnprintf+0x21a> @ imm = #0x10
7009a168: e7ff         	b	0x7009a16a <_vsnprintf+0x20a> @ imm = #-0x2
;           flags |= FLAGS_LONG_LONG;
7009a16a: 983b         	ldr	r0, [sp, #0xec]
7009a16c: f440 7000    	orr	r0, r0, #0x200
7009a170: 903b         	str	r0, [sp, #0xec]
;           format++;
7009a172: 983c         	ldr	r0, [sp, #0xf0]
7009a174: 3001         	adds	r0, #0x1
7009a176: 903c         	str	r0, [sp, #0xf0]
;         }
7009a178: e7ff         	b	0x7009a17a <_vsnprintf+0x21a> @ imm = #-0x2
;         break;
7009a17a: e02d         	b	0x7009a1d8 <_vsnprintf+0x278> @ imm = #0x5a
;         flags |= FLAGS_SHORT;
7009a17c: 983b         	ldr	r0, [sp, #0xec]
7009a17e: f040 0080    	orr	r0, r0, #0x80
7009a182: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a184: 983c         	ldr	r0, [sp, #0xf0]
7009a186: 3001         	adds	r0, #0x1
7009a188: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'h') {
7009a18a: 983c         	ldr	r0, [sp, #0xf0]
7009a18c: 7800         	ldrb	r0, [r0]
7009a18e: 2868         	cmp	r0, #0x68
7009a190: d108         	bne	0x7009a1a4 <_vsnprintf+0x244> @ imm = #0x10
7009a192: e7ff         	b	0x7009a194 <_vsnprintf+0x234> @ imm = #-0x2
;           flags |= FLAGS_CHAR;
7009a194: 983b         	ldr	r0, [sp, #0xec]
7009a196: f040 0040    	orr	r0, r0, #0x40
7009a19a: 903b         	str	r0, [sp, #0xec]
;           format++;
7009a19c: 983c         	ldr	r0, [sp, #0xf0]
7009a19e: 3001         	adds	r0, #0x1
7009a1a0: 903c         	str	r0, [sp, #0xf0]
;         }
7009a1a2: e7ff         	b	0x7009a1a4 <_vsnprintf+0x244> @ imm = #-0x2
;         break;
7009a1a4: e018         	b	0x7009a1d8 <_vsnprintf+0x278> @ imm = #0x30
;         flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a1a6: 983b         	ldr	r0, [sp, #0xec]
7009a1a8: f440 7080    	orr	r0, r0, #0x100
7009a1ac: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a1ae: 983c         	ldr	r0, [sp, #0xf0]
7009a1b0: 3001         	adds	r0, #0x1
7009a1b2: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a1b4: e010         	b	0x7009a1d8 <_vsnprintf+0x278> @ imm = #0x20
;         flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a1b6: 983b         	ldr	r0, [sp, #0xec]
7009a1b8: f440 7000    	orr	r0, r0, #0x200
7009a1bc: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a1be: 983c         	ldr	r0, [sp, #0xf0]
7009a1c0: 3001         	adds	r0, #0x1
7009a1c2: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a1c4: e008         	b	0x7009a1d8 <_vsnprintf+0x278> @ imm = #0x10
;         flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a1c6: 983b         	ldr	r0, [sp, #0xec]
7009a1c8: f440 7080    	orr	r0, r0, #0x100
7009a1cc: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a1ce: 983c         	ldr	r0, [sp, #0xf0]
7009a1d0: 3001         	adds	r0, #0x1
7009a1d2: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a1d4: e000         	b	0x7009a1d8 <_vsnprintf+0x278> @ imm = #0x0
;         break;
7009a1d6: e7ff         	b	0x7009a1d8 <_vsnprintf+0x278> @ imm = #-0x2
;     switch (*format) {
7009a1d8: 983c         	ldr	r0, [sp, #0xf0]
7009a1da: 7800         	ldrb	r0, [r0]
7009a1dc: 3825         	subs	r0, #0x25
7009a1de: 4601         	mov	r1, r0
7009a1e0: 9127         	str	r1, [sp, #0x9c]
7009a1e2: 2853         	cmp	r0, #0x53
7009a1e4: f200 83ab    	bhi.w	0x7009a93e <_vsnprintf+0x9de> @ imm = #0x756
7009a1e8: 9927         	ldr	r1, [sp, #0x9c]
7009a1ea: e8df f011    	tbh	[pc, r1, lsl #1]
7009a1ee: 9b 03 a8 03  	.word	0x03a8039b
7009a1f2: a8 03 a8 03  	.word	0x03a803a8
7009a1f6: a8 03 a8 03  	.word	0x03a803a8
7009a1fa: a8 03 a8 03  	.word	0x03a803a8
7009a1fe: a8 03 a8 03  	.word	0x03a803a8
7009a202: a8 03 a8 03  	.word	0x03a803a8
7009a206: a8 03 a8 03  	.word	0x03a803a8
7009a20a: a8 03 a8 03  	.word	0x03a803a8
7009a20e: a8 03 a8 03  	.word	0x03a803a8
7009a212: a8 03 a8 03  	.word	0x03a803a8
7009a216: a8 03 a8 03  	.word	0x03a803a8
7009a21a: a8 03 a8 03  	.word	0x03a803a8
7009a21e: a8 03 a8 03  	.word	0x03a803a8
7009a222: a8 03 a8 03  	.word	0x03a803a8
7009a226: a8 03 a8 03  	.word	0x03a803a8
7009a22a: a8 03 a8 03  	.word	0x03a803a8
7009a22e: 5e 02 32 02  	.word	0x0232025e
7009a232: 5e 02 a8 03  	.word	0x03a8025e
7009a236: a8 03 a8 03  	.word	0x03a803a8
7009a23a: a8 03 a8 03  	.word	0x03a803a8
7009a23e: a8 03 a8 03  	.word	0x03a803a8
7009a242: a8 03 a8 03  	.word	0x03a803a8
7009a246: a8 03 a8 03  	.word	0x03a803a8
7009a24a: a8 03 a8 03  	.word	0x03a803a8
7009a24e: a8 03 a8 03  	.word	0x03a803a8
7009a252: a8 03 54 00  	.word	0x005403a8
7009a256: a8 03 a8 03  	.word	0x03a803a8
7009a25a: a8 03 a8 03  	.word	0x03a803a8
7009a25e: a8 03 a8 03  	.word	0x03a803a8
7009a262: a8 03 a8 03  	.word	0x03a803a8
7009a266: a8 03 54 00  	.word	0x005403a8
7009a26a: 9e 02 54 00  	.word	0x0054029e
7009a26e: 5e 02 32 02  	.word	0x0232025e
7009a272: 5e 02 a8 03  	.word	0x03a8025e
7009a276: 54 00 a8 03  	.word	0x03a80054
7009a27a: a8 03 a8 03  	.word	0x03a803a8
7009a27e: a8 03 a8 03  	.word	0x03a803a8
7009a282: 54 00 6e 03  	.word	0x036e0054
7009a286: a8 03 a8 03  	.word	0x03a803a8
7009a28a: e2 02 a8 03  	.word	0x03a802e2
7009a28e: 54 00 a8 03  	.word	0x03a80054
7009a292: a8 03 54 00  	.word	0x005403a8
;         if (*format == 'x' || *format == 'X') {
7009a296: 983c         	ldr	r0, [sp, #0xf0]
7009a298: 7800         	ldrb	r0, [r0]
7009a29a: 2878         	cmp	r0, #0x78
7009a29c: d005         	beq	0x7009a2aa <_vsnprintf+0x34a> @ imm = #0xa
7009a29e: e7ff         	b	0x7009a2a0 <_vsnprintf+0x340> @ imm = #-0x2
7009a2a0: 983c         	ldr	r0, [sp, #0xf0]
7009a2a2: 7800         	ldrb	r0, [r0]
7009a2a4: 2858         	cmp	r0, #0x58
7009a2a6: d103         	bne	0x7009a2b0 <_vsnprintf+0x350> @ imm = #0x6
7009a2a8: e7ff         	b	0x7009a2aa <_vsnprintf+0x34a> @ imm = #-0x2
7009a2aa: 2010         	movs	r0, #0x10
;           base = 16U;
7009a2ac: 9034         	str	r0, [sp, #0xd0]
;         }
7009a2ae: e018         	b	0x7009a2e2 <_vsnprintf+0x382> @ imm = #0x30
;         else if (*format == 'o') {
7009a2b0: 983c         	ldr	r0, [sp, #0xf0]
7009a2b2: 7800         	ldrb	r0, [r0]
7009a2b4: 286f         	cmp	r0, #0x6f
7009a2b6: d103         	bne	0x7009a2c0 <_vsnprintf+0x360> @ imm = #0x6
7009a2b8: e7ff         	b	0x7009a2ba <_vsnprintf+0x35a> @ imm = #-0x2
7009a2ba: 2008         	movs	r0, #0x8
;           base =  8U;
7009a2bc: 9034         	str	r0, [sp, #0xd0]
;         }
7009a2be: e00f         	b	0x7009a2e0 <_vsnprintf+0x380> @ imm = #0x1e
;         else if (*format == 'b') {
7009a2c0: 983c         	ldr	r0, [sp, #0xf0]
7009a2c2: 7800         	ldrb	r0, [r0]
7009a2c4: 2862         	cmp	r0, #0x62
7009a2c6: d103         	bne	0x7009a2d0 <_vsnprintf+0x370> @ imm = #0x6
7009a2c8: e7ff         	b	0x7009a2ca <_vsnprintf+0x36a> @ imm = #-0x2
7009a2ca: 2002         	movs	r0, #0x2
;           base =  2U;
7009a2cc: 9034         	str	r0, [sp, #0xd0]
;         }
7009a2ce: e006         	b	0x7009a2de <_vsnprintf+0x37e> @ imm = #0xc
7009a2d0: 200a         	movs	r0, #0xa
;           base = 10U;
7009a2d2: 9034         	str	r0, [sp, #0xd0]
;           flags &= ~FLAGS_HASH;   // no hash for dec format
7009a2d4: 983b         	ldr	r0, [sp, #0xec]
7009a2d6: f020 0010    	bic	r0, r0, #0x10
7009a2da: 903b         	str	r0, [sp, #0xec]
7009a2dc: e7ff         	b	0x7009a2de <_vsnprintf+0x37e> @ imm = #-0x2
7009a2de: e7ff         	b	0x7009a2e0 <_vsnprintf+0x380> @ imm = #-0x2
7009a2e0: e7ff         	b	0x7009a2e2 <_vsnprintf+0x382> @ imm = #-0x2
;         if (*format == 'X') {
7009a2e2: 983c         	ldr	r0, [sp, #0xf0]
7009a2e4: 7800         	ldrb	r0, [r0]
7009a2e6: 2858         	cmp	r0, #0x58
7009a2e8: d105         	bne	0x7009a2f6 <_vsnprintf+0x396> @ imm = #0xa
7009a2ea: e7ff         	b	0x7009a2ec <_vsnprintf+0x38c> @ imm = #-0x2
;           flags |= FLAGS_UPPERCASE;
7009a2ec: 983b         	ldr	r0, [sp, #0xec]
7009a2ee: f040 0020    	orr	r0, r0, #0x20
7009a2f2: 903b         	str	r0, [sp, #0xec]
;         }
7009a2f4: e7ff         	b	0x7009a2f6 <_vsnprintf+0x396> @ imm = #-0x2
;         if ((*format != 'i') && (*format != 'd')) {
7009a2f6: 983c         	ldr	r0, [sp, #0xf0]
7009a2f8: 7800         	ldrb	r0, [r0]
7009a2fa: 2869         	cmp	r0, #0x69
7009a2fc: d00a         	beq	0x7009a314 <_vsnprintf+0x3b4> @ imm = #0x14
7009a2fe: e7ff         	b	0x7009a300 <_vsnprintf+0x3a0> @ imm = #-0x2
7009a300: 983c         	ldr	r0, [sp, #0xf0]
7009a302: 7800         	ldrb	r0, [r0]
7009a304: 2864         	cmp	r0, #0x64
7009a306: d005         	beq	0x7009a314 <_vsnprintf+0x3b4> @ imm = #0xa
7009a308: e7ff         	b	0x7009a30a <_vsnprintf+0x3aa> @ imm = #-0x2
;           flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
7009a30a: 983b         	ldr	r0, [sp, #0xec]
7009a30c: f020 000c    	bic	r0, r0, #0xc
7009a310: 903b         	str	r0, [sp, #0xec]
;         }
7009a312: e7ff         	b	0x7009a314 <_vsnprintf+0x3b4> @ imm = #-0x2
;         if (flags & FLAGS_PRECISION) {
7009a314: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a318: 0740         	lsls	r0, r0, #0x1d
7009a31a: 2800         	cmp	r0, #0x0
7009a31c: d505         	bpl	0x7009a32a <_vsnprintf+0x3ca> @ imm = #0xa
7009a31e: e7ff         	b	0x7009a320 <_vsnprintf+0x3c0> @ imm = #-0x2
;           flags &= ~FLAGS_ZEROPAD;
7009a320: 983b         	ldr	r0, [sp, #0xec]
7009a322: f020 0001    	bic	r0, r0, #0x1
7009a326: 903b         	str	r0, [sp, #0xec]
;         }
7009a328: e7ff         	b	0x7009a32a <_vsnprintf+0x3ca> @ imm = #-0x2
;         if ((*format == 'i') || (*format == 'd')) {
7009a32a: 983c         	ldr	r0, [sp, #0xf0]
7009a32c: 7800         	ldrb	r0, [r0]
7009a32e: 2869         	cmp	r0, #0x69
7009a330: d006         	beq	0x7009a340 <_vsnprintf+0x3e0> @ imm = #0xc
7009a332: e7ff         	b	0x7009a334 <_vsnprintf+0x3d4> @ imm = #-0x2
7009a334: 983c         	ldr	r0, [sp, #0xf0]
7009a336: 7800         	ldrb	r0, [r0]
7009a338: 2864         	cmp	r0, #0x64
7009a33a: f040 80e9    	bne.w	0x7009a510 <_vsnprintf+0x5b0> @ imm = #0x1d2
7009a33e: e7ff         	b	0x7009a340 <_vsnprintf+0x3e0> @ imm = #-0x2
;           if (flags & FLAGS_LONG_LONG) {
7009a340: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a344: 0780         	lsls	r0, r0, #0x1e
7009a346: 2800         	cmp	r0, #0x0
7009a348: d550         	bpl	0x7009a3ec <_vsnprintf+0x48c> @ imm = #0xa0
7009a34a: e7ff         	b	0x7009a34c <_vsnprintf+0x3ec> @ imm = #-0x2
;             const long long value = va_arg(va, long long);
7009a34c: 9840         	ldr	r0, [sp, #0x100]
7009a34e: 3007         	adds	r0, #0x7
7009a350: f020 0107    	bic	r1, r0, #0x7
7009a354: f101 0008    	add.w	r0, r1, #0x8
7009a358: 9040         	str	r0, [sp, #0x100]
7009a35a: 6808         	ldr	r0, [r1]
7009a35c: 6849         	ldr	r1, [r1, #0x4]
7009a35e: 9133         	str	r1, [sp, #0xcc]
7009a360: 9032         	str	r0, [sp, #0xc8]
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a362: 983f         	ldr	r0, [sp, #0xfc]
7009a364: 9023         	str	r0, [sp, #0x8c]
7009a366: 983e         	ldr	r0, [sp, #0xf8]
7009a368: 9024         	str	r0, [sp, #0x90]
7009a36a: 9837         	ldr	r0, [sp, #0xdc]
7009a36c: 9025         	str	r0, [sp, #0x94]
7009a36e: 983d         	ldr	r0, [sp, #0xf4]
7009a370: 9026         	str	r0, [sp, #0x98]
7009a372: 9932         	ldr	r1, [sp, #0xc8]
7009a374: 9833         	ldr	r0, [sp, #0xcc]
7009a376: 3901         	subs	r1, #0x1
7009a378: f170 0000    	sbcs	r0, r0, #0x0
7009a37c: db05         	blt	0x7009a38a <_vsnprintf+0x42a> @ imm = #0xa
7009a37e: e7ff         	b	0x7009a380 <_vsnprintf+0x420> @ imm = #-0x2
7009a380: 9932         	ldr	r1, [sp, #0xc8]
7009a382: 9833         	ldr	r0, [sp, #0xcc]
7009a384: 9121         	str	r1, [sp, #0x84]
7009a386: 9022         	str	r0, [sp, #0x88]
7009a388: e008         	b	0x7009a39c <_vsnprintf+0x43c> @ imm = #0x10
7009a38a: 9832         	ldr	r0, [sp, #0xc8]
7009a38c: 9a33         	ldr	r2, [sp, #0xcc]
7009a38e: 4241         	rsbs	r1, r0, #0
7009a390: f04f 0000    	mov.w	r0, #0x0
7009a394: 4190         	sbcs	r0, r2
7009a396: 9121         	str	r1, [sp, #0x84]
7009a398: 9022         	str	r0, [sp, #0x88]
7009a39a: e7ff         	b	0x7009a39c <_vsnprintf+0x43c> @ imm = #-0x2
7009a39c: 9b26         	ldr	r3, [sp, #0x98]
7009a39e: 9a25         	ldr	r2, [sp, #0x94]
7009a3a0: 9924         	ldr	r1, [sp, #0x90]
7009a3a2: 9823         	ldr	r0, [sp, #0x8c]
7009a3a4: f8dd c084    	ldr.w	r12, [sp, #0x84]
7009a3a8: 9c22         	ldr	r4, [sp, #0x88]
7009a3aa: 9d33         	ldr	r5, [sp, #0xcc]
7009a3ac: 9e34         	ldr	r6, [sp, #0xd0]
7009a3ae: 9f39         	ldr	r7, [sp, #0xe4]
7009a3b0: f8dd 80e8    	ldr.w	r8, [sp, #0xe8]
7009a3b4: f8dd 90ec    	ldr.w	r9, [sp, #0xec]
7009a3b8: 46ee         	mov	lr, sp
7009a3ba: f8cd e080    	str.w	lr, [sp, #0x80]
7009a3be: f8ce 9020    	str.w	r9, [lr, #0x20]
7009a3c2: f8ce 801c    	str.w	r8, [lr, #0x1c]
7009a3c6: f8ce 7018    	str.w	r7, [lr, #0x18]
7009a3ca: 2700         	movs	r7, #0x0
7009a3cc: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a3d0: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a3d4: ea4f 75d5    	lsr.w	r5, r5, #0x1f
7009a3d8: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a3dc: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a3e0: f8ce c000    	str.w	r12, [lr]
7009a3e4: f008 fb9c    	bl	0x700a2b20 <_ntoa_long_long> @ imm = #0x8738
7009a3e8: 9037         	str	r0, [sp, #0xdc]
;           }
7009a3ea: e090         	b	0x7009a50e <_vsnprintf+0x5ae> @ imm = #0x120
;           else if (flags & FLAGS_LONG) {
7009a3ec: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a3f0: 07c0         	lsls	r0, r0, #0x1f
7009a3f2: b3b0         	cbz	r0, 0x7009a462 <_vsnprintf+0x502> @ imm = #0x6c
7009a3f4: e7ff         	b	0x7009a3f6 <_vsnprintf+0x496> @ imm = #-0x2
;             const long value = va_arg(va, long);
7009a3f6: 9840         	ldr	r0, [sp, #0x100]
7009a3f8: 1d01         	adds	r1, r0, #0x4
7009a3fa: 9140         	str	r1, [sp, #0x100]
7009a3fc: 6800         	ldr	r0, [r0]
7009a3fe: 9031         	str	r0, [sp, #0xc4]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a400: 983f         	ldr	r0, [sp, #0xfc]
7009a402: 901c         	str	r0, [sp, #0x70]
7009a404: 983e         	ldr	r0, [sp, #0xf8]
7009a406: 901d         	str	r0, [sp, #0x74]
7009a408: 9837         	ldr	r0, [sp, #0xdc]
7009a40a: 901e         	str	r0, [sp, #0x78]
7009a40c: 983d         	ldr	r0, [sp, #0xf4]
7009a40e: 901f         	str	r0, [sp, #0x7c]
7009a410: 9831         	ldr	r0, [sp, #0xc4]
7009a412: 2801         	cmp	r0, #0x1
7009a414: db03         	blt	0x7009a41e <_vsnprintf+0x4be> @ imm = #0x6
7009a416: e7ff         	b	0x7009a418 <_vsnprintf+0x4b8> @ imm = #-0x2
7009a418: 9831         	ldr	r0, [sp, #0xc4]
7009a41a: 901b         	str	r0, [sp, #0x6c]
7009a41c: e003         	b	0x7009a426 <_vsnprintf+0x4c6> @ imm = #0x6
7009a41e: 9831         	ldr	r0, [sp, #0xc4]
7009a420: 4240         	rsbs	r0, r0, #0
7009a422: 901b         	str	r0, [sp, #0x6c]
7009a424: e7ff         	b	0x7009a426 <_vsnprintf+0x4c6> @ imm = #-0x2
7009a426: 9b1f         	ldr	r3, [sp, #0x7c]
7009a428: 9a1e         	ldr	r2, [sp, #0x78]
7009a42a: 991d         	ldr	r1, [sp, #0x74]
7009a42c: 981c         	ldr	r0, [sp, #0x70]
7009a42e: f8dd c06c    	ldr.w	r12, [sp, #0x6c]
7009a432: 9c31         	ldr	r4, [sp, #0xc4]
7009a434: 9d34         	ldr	r5, [sp, #0xd0]
7009a436: 9e39         	ldr	r6, [sp, #0xe4]
7009a438: 9f3a         	ldr	r7, [sp, #0xe8]
7009a43a: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a43e: 46ee         	mov	lr, sp
7009a440: f8ce 8014    	str.w	r8, [lr, #0x14]
7009a444: f8ce 7010    	str.w	r7, [lr, #0x10]
7009a448: f8ce 600c    	str.w	r6, [lr, #0xc]
7009a44c: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a450: 0fe4         	lsrs	r4, r4, #0x1f
7009a452: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a456: f8ce c000    	str.w	r12, [lr]
7009a45a: f00a fb39    	bl	0x700a4ad0 <_ntoa_long> @ imm = #0xa672
7009a45e: 9037         	str	r0, [sp, #0xdc]
;           }
7009a460: e054         	b	0x7009a50c <_vsnprintf+0x5ac> @ imm = #0xa8
;             const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
7009a462: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a466: 0640         	lsls	r0, r0, #0x19
7009a468: 2800         	cmp	r0, #0x0
7009a46a: d506         	bpl	0x7009a47a <_vsnprintf+0x51a> @ imm = #0xc
7009a46c: e7ff         	b	0x7009a46e <_vsnprintf+0x50e> @ imm = #-0x2
7009a46e: 9840         	ldr	r0, [sp, #0x100]
7009a470: 1d01         	adds	r1, r0, #0x4
7009a472: 9140         	str	r1, [sp, #0x100]
7009a474: 7800         	ldrb	r0, [r0]
7009a476: 901a         	str	r0, [sp, #0x68]
7009a478: e015         	b	0x7009a4a6 <_vsnprintf+0x546> @ imm = #0x2a
7009a47a: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a47e: 0600         	lsls	r0, r0, #0x18
7009a480: 2800         	cmp	r0, #0x0
7009a482: d507         	bpl	0x7009a494 <_vsnprintf+0x534> @ imm = #0xe
7009a484: e7ff         	b	0x7009a486 <_vsnprintf+0x526> @ imm = #-0x2
7009a486: 9840         	ldr	r0, [sp, #0x100]
7009a488: 1d01         	adds	r1, r0, #0x4
7009a48a: 9140         	str	r1, [sp, #0x100]
7009a48c: f9b0 0000    	ldrsh.w	r0, [r0]
7009a490: 9019         	str	r0, [sp, #0x64]
7009a492: e005         	b	0x7009a4a0 <_vsnprintf+0x540> @ imm = #0xa
7009a494: 9840         	ldr	r0, [sp, #0x100]
7009a496: 1d01         	adds	r1, r0, #0x4
7009a498: 9140         	str	r1, [sp, #0x100]
7009a49a: 6800         	ldr	r0, [r0]
7009a49c: 9019         	str	r0, [sp, #0x64]
7009a49e: e7ff         	b	0x7009a4a0 <_vsnprintf+0x540> @ imm = #-0x2
7009a4a0: 9819         	ldr	r0, [sp, #0x64]
7009a4a2: 901a         	str	r0, [sp, #0x68]
7009a4a4: e7ff         	b	0x7009a4a6 <_vsnprintf+0x546> @ imm = #-0x2
7009a4a6: 981a         	ldr	r0, [sp, #0x68]
7009a4a8: 9030         	str	r0, [sp, #0xc0]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a4aa: 983f         	ldr	r0, [sp, #0xfc]
7009a4ac: 9015         	str	r0, [sp, #0x54]
7009a4ae: 983e         	ldr	r0, [sp, #0xf8]
7009a4b0: 9016         	str	r0, [sp, #0x58]
7009a4b2: 9837         	ldr	r0, [sp, #0xdc]
7009a4b4: 9017         	str	r0, [sp, #0x5c]
7009a4b6: 983d         	ldr	r0, [sp, #0xf4]
7009a4b8: 9018         	str	r0, [sp, #0x60]
7009a4ba: 9830         	ldr	r0, [sp, #0xc0]
7009a4bc: 2801         	cmp	r0, #0x1
7009a4be: db03         	blt	0x7009a4c8 <_vsnprintf+0x568> @ imm = #0x6
7009a4c0: e7ff         	b	0x7009a4c2 <_vsnprintf+0x562> @ imm = #-0x2
7009a4c2: 9830         	ldr	r0, [sp, #0xc0]
7009a4c4: 9014         	str	r0, [sp, #0x50]
7009a4c6: e003         	b	0x7009a4d0 <_vsnprintf+0x570> @ imm = #0x6
7009a4c8: 9830         	ldr	r0, [sp, #0xc0]
7009a4ca: 4240         	rsbs	r0, r0, #0
7009a4cc: 9014         	str	r0, [sp, #0x50]
7009a4ce: e7ff         	b	0x7009a4d0 <_vsnprintf+0x570> @ imm = #-0x2
7009a4d0: 9b18         	ldr	r3, [sp, #0x60]
7009a4d2: 9a17         	ldr	r2, [sp, #0x5c]
7009a4d4: 9916         	ldr	r1, [sp, #0x58]
7009a4d6: 9815         	ldr	r0, [sp, #0x54]
7009a4d8: f8dd c050    	ldr.w	r12, [sp, #0x50]
7009a4dc: 9c30         	ldr	r4, [sp, #0xc0]
7009a4de: 9d34         	ldr	r5, [sp, #0xd0]
7009a4e0: 9e39         	ldr	r6, [sp, #0xe4]
7009a4e2: 9f3a         	ldr	r7, [sp, #0xe8]
7009a4e4: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a4e8: 46ee         	mov	lr, sp
7009a4ea: f8ce 8014    	str.w	r8, [lr, #0x14]
7009a4ee: f8ce 7010    	str.w	r7, [lr, #0x10]
7009a4f2: f8ce 600c    	str.w	r6, [lr, #0xc]
7009a4f6: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a4fa: 0fe4         	lsrs	r4, r4, #0x1f
7009a4fc: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a500: f8ce c000    	str.w	r12, [lr]
7009a504: f00a fae4    	bl	0x700a4ad0 <_ntoa_long> @ imm = #0xa5c8
7009a508: 9037         	str	r0, [sp, #0xdc]
7009a50a: e7ff         	b	0x7009a50c <_vsnprintf+0x5ac> @ imm = #-0x2
7009a50c: e7ff         	b	0x7009a50e <_vsnprintf+0x5ae> @ imm = #-0x2
;         }
7009a50e: e09c         	b	0x7009a64a <_vsnprintf+0x6ea> @ imm = #0x138
;           if (flags & FLAGS_LONG_LONG) {
7009a510: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a514: 0780         	lsls	r0, r0, #0x1e
7009a516: 2800         	cmp	r0, #0x0
7009a518: d52f         	bpl	0x7009a57a <_vsnprintf+0x61a> @ imm = #0x5e
7009a51a: e7ff         	b	0x7009a51c <_vsnprintf+0x5bc> @ imm = #-0x2
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
7009a51c: 983f         	ldr	r0, [sp, #0xfc]
7009a51e: 993e         	ldr	r1, [sp, #0xf8]
7009a520: 9a37         	ldr	r2, [sp, #0xdc]
7009a522: 9b3d         	ldr	r3, [sp, #0xf4]
7009a524: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a528: f10c 0c07    	add.w	r12, r12, #0x7
7009a52c: f02c 0e07    	bic	lr, r12, #0x7
7009a530: f10e 0c08    	add.w	r12, lr, #0x8
7009a534: f8cd c100    	str.w	r12, [sp, #0x100]
7009a538: f8de c000    	ldr.w	r12, [lr]
7009a53c: f8de 4004    	ldr.w	r4, [lr, #0x4]
7009a540: 9e34         	ldr	r6, [sp, #0xd0]
7009a542: 9d39         	ldr	r5, [sp, #0xe4]
7009a544: 9f3a         	ldr	r7, [sp, #0xe8]
7009a546: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a54a: 46ee         	mov	lr, sp
7009a54c: f8cd e04c    	str.w	lr, [sp, #0x4c]
7009a550: f8ce 8020    	str.w	r8, [lr, #0x20]
7009a554: f8ce 701c    	str.w	r7, [lr, #0x1c]
7009a558: f8ce 5018    	str.w	r5, [lr, #0x18]
7009a55c: 2500         	movs	r5, #0x0
7009a55e: f8ce 5014    	str.w	r5, [lr, #0x14]
7009a562: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a566: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a56a: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a56e: f8ce c000    	str.w	r12, [lr]
7009a572: f008 fad5    	bl	0x700a2b20 <_ntoa_long_long> @ imm = #0x85aa
7009a576: 9037         	str	r0, [sp, #0xdc]
;           }
7009a578: e066         	b	0x7009a648 <_vsnprintf+0x6e8> @ imm = #0xcc
;           else if (flags & FLAGS_LONG) {
7009a57a: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a57e: 07c0         	lsls	r0, r0, #0x1f
7009a580: b310         	cbz	r0, 0x7009a5c8 <_vsnprintf+0x668> @ imm = #0x44
7009a582: e7ff         	b	0x7009a584 <_vsnprintf+0x624> @ imm = #-0x2
;             idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
7009a584: 983f         	ldr	r0, [sp, #0xfc]
7009a586: 993e         	ldr	r1, [sp, #0xf8]
7009a588: 9a37         	ldr	r2, [sp, #0xdc]
7009a58a: 9b3d         	ldr	r3, [sp, #0xf4]
7009a58c: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a590: f10c 0e04    	add.w	lr, r12, #0x4
7009a594: f8cd e100    	str.w	lr, [sp, #0x100]
7009a598: f8dc c000    	ldr.w	r12, [r12]
7009a59c: 9c34         	ldr	r4, [sp, #0xd0]
7009a59e: 9d39         	ldr	r5, [sp, #0xe4]
7009a5a0: 9e3a         	ldr	r6, [sp, #0xe8]
7009a5a2: 9f3b         	ldr	r7, [sp, #0xec]
7009a5a4: 46ee         	mov	lr, sp
7009a5a6: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a5aa: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a5ae: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a5b2: f8ce 4008    	str.w	r4, [lr, #0x8]
7009a5b6: 2400         	movs	r4, #0x0
7009a5b8: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a5bc: f8ce c000    	str.w	r12, [lr]
7009a5c0: f00a fa86    	bl	0x700a4ad0 <_ntoa_long> @ imm = #0xa50c
7009a5c4: 9037         	str	r0, [sp, #0xdc]
;           }
7009a5c6: e03e         	b	0x7009a646 <_vsnprintf+0x6e6> @ imm = #0x7c
;             const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
7009a5c8: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a5cc: 0640         	lsls	r0, r0, #0x19
7009a5ce: 2800         	cmp	r0, #0x0
7009a5d0: d506         	bpl	0x7009a5e0 <_vsnprintf+0x680> @ imm = #0xc
7009a5d2: e7ff         	b	0x7009a5d4 <_vsnprintf+0x674> @ imm = #-0x2
7009a5d4: 9840         	ldr	r0, [sp, #0x100]
7009a5d6: 1d01         	adds	r1, r0, #0x4
7009a5d8: 9140         	str	r1, [sp, #0x100]
7009a5da: 7800         	ldrb	r0, [r0]
7009a5dc: 9012         	str	r0, [sp, #0x48]
7009a5de: e014         	b	0x7009a60a <_vsnprintf+0x6aa> @ imm = #0x28
7009a5e0: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a5e4: 0600         	lsls	r0, r0, #0x18
7009a5e6: 2800         	cmp	r0, #0x0
7009a5e8: d506         	bpl	0x7009a5f8 <_vsnprintf+0x698> @ imm = #0xc
7009a5ea: e7ff         	b	0x7009a5ec <_vsnprintf+0x68c> @ imm = #-0x2
7009a5ec: 9840         	ldr	r0, [sp, #0x100]
7009a5ee: 1d01         	adds	r1, r0, #0x4
7009a5f0: 9140         	str	r1, [sp, #0x100]
7009a5f2: 8800         	ldrh	r0, [r0]
7009a5f4: 9011         	str	r0, [sp, #0x44]
7009a5f6: e005         	b	0x7009a604 <_vsnprintf+0x6a4> @ imm = #0xa
7009a5f8: 9840         	ldr	r0, [sp, #0x100]
7009a5fa: 1d01         	adds	r1, r0, #0x4
7009a5fc: 9140         	str	r1, [sp, #0x100]
7009a5fe: 6800         	ldr	r0, [r0]
7009a600: 9011         	str	r0, [sp, #0x44]
7009a602: e7ff         	b	0x7009a604 <_vsnprintf+0x6a4> @ imm = #-0x2
7009a604: 9811         	ldr	r0, [sp, #0x44]
7009a606: 9012         	str	r0, [sp, #0x48]
7009a608: e7ff         	b	0x7009a60a <_vsnprintf+0x6aa> @ imm = #-0x2
7009a60a: 9812         	ldr	r0, [sp, #0x48]
7009a60c: 902f         	str	r0, [sp, #0xbc]
;             idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
7009a60e: 983f         	ldr	r0, [sp, #0xfc]
7009a610: 993e         	ldr	r1, [sp, #0xf8]
7009a612: 9a37         	ldr	r2, [sp, #0xdc]
7009a614: 9b3d         	ldr	r3, [sp, #0xf4]
7009a616: f8dd c0bc    	ldr.w	r12, [sp, #0xbc]
7009a61a: 9c34         	ldr	r4, [sp, #0xd0]
7009a61c: 9d39         	ldr	r5, [sp, #0xe4]
7009a61e: 9e3a         	ldr	r6, [sp, #0xe8]
7009a620: 9f3b         	ldr	r7, [sp, #0xec]
7009a622: 46ee         	mov	lr, sp
7009a624: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a628: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a62c: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a630: f8ce 4008    	str.w	r4, [lr, #0x8]
7009a634: 2400         	movs	r4, #0x0
7009a636: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a63a: f8ce c000    	str.w	r12, [lr]
7009a63e: f00a fa47    	bl	0x700a4ad0 <_ntoa_long> @ imm = #0xa48e
7009a642: 9037         	str	r0, [sp, #0xdc]
7009a644: e7ff         	b	0x7009a646 <_vsnprintf+0x6e6> @ imm = #-0x2
7009a646: e7ff         	b	0x7009a648 <_vsnprintf+0x6e8> @ imm = #-0x2
7009a648: e7ff         	b	0x7009a64a <_vsnprintf+0x6ea> @ imm = #-0x2
;         format++;
7009a64a: 983c         	ldr	r0, [sp, #0xf0]
7009a64c: 3001         	adds	r0, #0x1
7009a64e: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a650: e183         	b	0x7009a95a <_vsnprintf+0x9fa> @ imm = #0x306
;         if (*format == 'F') flags |= FLAGS_UPPERCASE;
7009a652: 983c         	ldr	r0, [sp, #0xf0]
7009a654: 7800         	ldrb	r0, [r0]
7009a656: 2846         	cmp	r0, #0x46
7009a658: d105         	bne	0x7009a666 <_vsnprintf+0x706> @ imm = #0xa
7009a65a: e7ff         	b	0x7009a65c <_vsnprintf+0x6fc> @ imm = #-0x2
7009a65c: 983b         	ldr	r0, [sp, #0xec]
7009a65e: f040 0020    	orr	r0, r0, #0x20
7009a662: 903b         	str	r0, [sp, #0xec]
7009a664: e7ff         	b	0x7009a666 <_vsnprintf+0x706> @ imm = #-0x2
;         idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
7009a666: 983f         	ldr	r0, [sp, #0xfc]
7009a668: 993e         	ldr	r1, [sp, #0xf8]
7009a66a: 9a37         	ldr	r2, [sp, #0xdc]
7009a66c: 9b3d         	ldr	r3, [sp, #0xf4]
7009a66e: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a672: f10c 0c07    	add.w	r12, r12, #0x7
7009a676: f02c 0c07    	bic	r12, r12, #0x7
7009a67a: f10c 0e08    	add.w	lr, r12, #0x8
7009a67e: f8cd e100    	str.w	lr, [sp, #0x100]
7009a682: ed9c 0b00    	vldr	d0, [r12]
7009a686: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
7009a68a: 9c3a         	ldr	r4, [sp, #0xe8]
7009a68c: 9d3b         	ldr	r5, [sp, #0xec]
7009a68e: 46ee         	mov	lr, sp
7009a690: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a694: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a698: f8ce c000    	str.w	r12, [lr]
7009a69c: f000 fc80    	bl	0x7009afa0 <_ftoa>      @ imm = #0x900
7009a6a0: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009a6a2: 983c         	ldr	r0, [sp, #0xf0]
7009a6a4: 3001         	adds	r0, #0x1
7009a6a6: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a6a8: e157         	b	0x7009a95a <_vsnprintf+0x9fa> @ imm = #0x2ae
;         if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
7009a6aa: 983c         	ldr	r0, [sp, #0xf0]
7009a6ac: 7800         	ldrb	r0, [r0]
7009a6ae: 2867         	cmp	r0, #0x67
7009a6b0: d005         	beq	0x7009a6be <_vsnprintf+0x75e> @ imm = #0xa
7009a6b2: e7ff         	b	0x7009a6b4 <_vsnprintf+0x754> @ imm = #-0x2
7009a6b4: 983c         	ldr	r0, [sp, #0xf0]
7009a6b6: 7800         	ldrb	r0, [r0]
7009a6b8: 2847         	cmp	r0, #0x47
7009a6ba: d105         	bne	0x7009a6c8 <_vsnprintf+0x768> @ imm = #0xa
7009a6bc: e7ff         	b	0x7009a6be <_vsnprintf+0x75e> @ imm = #-0x2
7009a6be: 983b         	ldr	r0, [sp, #0xec]
7009a6c0: f440 6000    	orr	r0, r0, #0x800
7009a6c4: 903b         	str	r0, [sp, #0xec]
7009a6c6: e7ff         	b	0x7009a6c8 <_vsnprintf+0x768> @ imm = #-0x2
;         if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
7009a6c8: 983c         	ldr	r0, [sp, #0xf0]
7009a6ca: 7800         	ldrb	r0, [r0]
7009a6cc: 2845         	cmp	r0, #0x45
7009a6ce: d005         	beq	0x7009a6dc <_vsnprintf+0x77c> @ imm = #0xa
7009a6d0: e7ff         	b	0x7009a6d2 <_vsnprintf+0x772> @ imm = #-0x2
7009a6d2: 983c         	ldr	r0, [sp, #0xf0]
7009a6d4: 7800         	ldrb	r0, [r0]
7009a6d6: 2847         	cmp	r0, #0x47
7009a6d8: d105         	bne	0x7009a6e6 <_vsnprintf+0x786> @ imm = #0xa
7009a6da: e7ff         	b	0x7009a6dc <_vsnprintf+0x77c> @ imm = #-0x2
7009a6dc: 983b         	ldr	r0, [sp, #0xec]
7009a6de: f040 0020    	orr	r0, r0, #0x20
7009a6e2: 903b         	str	r0, [sp, #0xec]
7009a6e4: e7ff         	b	0x7009a6e6 <_vsnprintf+0x786> @ imm = #-0x2
;         idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
7009a6e6: 983f         	ldr	r0, [sp, #0xfc]
7009a6e8: 993e         	ldr	r1, [sp, #0xf8]
7009a6ea: 9a37         	ldr	r2, [sp, #0xdc]
7009a6ec: 9b3d         	ldr	r3, [sp, #0xf4]
7009a6ee: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a6f2: f10c 0c07    	add.w	r12, r12, #0x7
7009a6f6: f02c 0c07    	bic	r12, r12, #0x7
7009a6fa: f10c 0e08    	add.w	lr, r12, #0x8
7009a6fe: f8cd e100    	str.w	lr, [sp, #0x100]
7009a702: ed9c 0b00    	vldr	d0, [r12]
7009a706: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
7009a70a: 9c3a         	ldr	r4, [sp, #0xe8]
7009a70c: 9d3b         	ldr	r5, [sp, #0xec]
7009a70e: 46ee         	mov	lr, sp
7009a710: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a714: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a718: f8ce c000    	str.w	r12, [lr]
7009a71c: f000 fed0    	bl	0x7009b4c0 <_etoa>      @ imm = #0xda0
7009a720: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009a722: 983c         	ldr	r0, [sp, #0xf0]
7009a724: 3001         	adds	r0, #0x1
7009a726: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a728: e117         	b	0x7009a95a <_vsnprintf+0x9fa> @ imm = #0x22e
7009a72a: 2001         	movs	r0, #0x1
;         unsigned int l = 1U;
7009a72c: 902e         	str	r0, [sp, #0xb8]
;         if (!(flags & FLAGS_LEFT)) {
7009a72e: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a732: 0780         	lsls	r0, r0, #0x1e
7009a734: 2800         	cmp	r0, #0x0
7009a736: d413         	bmi	0x7009a760 <_vsnprintf+0x800> @ imm = #0x26
7009a738: e7ff         	b	0x7009a73a <_vsnprintf+0x7da> @ imm = #-0x2
;           while (l++ < width) {
7009a73a: e7ff         	b	0x7009a73c <_vsnprintf+0x7dc> @ imm = #-0x2
7009a73c: 982e         	ldr	r0, [sp, #0xb8]
7009a73e: 1c41         	adds	r1, r0, #0x1
7009a740: 912e         	str	r1, [sp, #0xb8]
7009a742: 993a         	ldr	r1, [sp, #0xe8]
7009a744: 4288         	cmp	r0, r1
7009a746: d20a         	bhs	0x7009a75e <_vsnprintf+0x7fe> @ imm = #0x14
7009a748: e7ff         	b	0x7009a74a <_vsnprintf+0x7ea> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a74a: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a74e: 993e         	ldr	r1, [sp, #0xf8]
7009a750: 9a37         	ldr	r2, [sp, #0xdc]
7009a752: 1c50         	adds	r0, r2, #0x1
7009a754: 9037         	str	r0, [sp, #0xdc]
7009a756: 9b3d         	ldr	r3, [sp, #0xf4]
7009a758: 2020         	movs	r0, #0x20
7009a75a: 47e0         	blx	r12
;           while (l++ < width) {
7009a75c: e7ee         	b	0x7009a73c <_vsnprintf+0x7dc> @ imm = #-0x24
;         }
7009a75e: e7ff         	b	0x7009a760 <_vsnprintf+0x800> @ imm = #-0x2
;         out((char)va_arg(va, int), buffer, idx++, maxlen);
7009a760: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a764: 9840         	ldr	r0, [sp, #0x100]
7009a766: 1d01         	adds	r1, r0, #0x4
7009a768: 9140         	str	r1, [sp, #0x100]
7009a76a: 7800         	ldrb	r0, [r0]
7009a76c: 993e         	ldr	r1, [sp, #0xf8]
7009a76e: 9a37         	ldr	r2, [sp, #0xdc]
7009a770: 1c53         	adds	r3, r2, #0x1
7009a772: 9337         	str	r3, [sp, #0xdc]
7009a774: 9b3d         	ldr	r3, [sp, #0xf4]
7009a776: 47e0         	blx	r12
;         if (flags & FLAGS_LEFT) {
7009a778: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a77c: 0780         	lsls	r0, r0, #0x1e
7009a77e: 2800         	cmp	r0, #0x0
7009a780: d513         	bpl	0x7009a7aa <_vsnprintf+0x84a> @ imm = #0x26
7009a782: e7ff         	b	0x7009a784 <_vsnprintf+0x824> @ imm = #-0x2
;           while (l++ < width) {
7009a784: e7ff         	b	0x7009a786 <_vsnprintf+0x826> @ imm = #-0x2
7009a786: 982e         	ldr	r0, [sp, #0xb8]
7009a788: 1c41         	adds	r1, r0, #0x1
7009a78a: 912e         	str	r1, [sp, #0xb8]
7009a78c: 993a         	ldr	r1, [sp, #0xe8]
7009a78e: 4288         	cmp	r0, r1
7009a790: d20a         	bhs	0x7009a7a8 <_vsnprintf+0x848> @ imm = #0x14
7009a792: e7ff         	b	0x7009a794 <_vsnprintf+0x834> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a794: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a798: 993e         	ldr	r1, [sp, #0xf8]
7009a79a: 9a37         	ldr	r2, [sp, #0xdc]
7009a79c: 1c50         	adds	r0, r2, #0x1
7009a79e: 9037         	str	r0, [sp, #0xdc]
7009a7a0: 9b3d         	ldr	r3, [sp, #0xf4]
7009a7a2: 2020         	movs	r0, #0x20
7009a7a4: 47e0         	blx	r12
;           while (l++ < width) {
7009a7a6: e7ee         	b	0x7009a786 <_vsnprintf+0x826> @ imm = #-0x24
;         }
7009a7a8: e7ff         	b	0x7009a7aa <_vsnprintf+0x84a> @ imm = #-0x2
;         format++;
7009a7aa: 983c         	ldr	r0, [sp, #0xf0]
7009a7ac: 3001         	adds	r0, #0x1
7009a7ae: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a7b0: e0d3         	b	0x7009a95a <_vsnprintf+0x9fa> @ imm = #0x1a6
;         const char* p = va_arg(va, char*);
7009a7b2: 9840         	ldr	r0, [sp, #0x100]
7009a7b4: 1d01         	adds	r1, r0, #0x4
7009a7b6: 9140         	str	r1, [sp, #0x100]
7009a7b8: 6800         	ldr	r0, [r0]
7009a7ba: 902d         	str	r0, [sp, #0xb4]
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
7009a7bc: 982d         	ldr	r0, [sp, #0xb4]
7009a7be: 9010         	str	r0, [sp, #0x40]
7009a7c0: 9839         	ldr	r0, [sp, #0xe4]
7009a7c2: b118         	cbz	r0, 0x7009a7cc <_vsnprintf+0x86c> @ imm = #0x6
7009a7c4: e7ff         	b	0x7009a7c6 <_vsnprintf+0x866> @ imm = #-0x2
7009a7c6: 9839         	ldr	r0, [sp, #0xe4]
7009a7c8: 900f         	str	r0, [sp, #0x3c]
7009a7ca: e003         	b	0x7009a7d4 <_vsnprintf+0x874> @ imm = #0x6
7009a7cc: f04f 30ff    	mov.w	r0, #0xffffffff
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
7009a7d0: 900f         	str	r0, [sp, #0x3c]
7009a7d2: e7ff         	b	0x7009a7d4 <_vsnprintf+0x874> @ imm = #-0x2
7009a7d4: 9810         	ldr	r0, [sp, #0x40]
7009a7d6: 990f         	ldr	r1, [sp, #0x3c]
7009a7d8: f013 f862    	bl	0x700ad8a0 <_strnlen_s> @ imm = #0x130c4
7009a7dc: 902c         	str	r0, [sp, #0xb0]
;         if (flags & FLAGS_PRECISION) {
7009a7de: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a7e2: 0740         	lsls	r0, r0, #0x1d
7009a7e4: 2800         	cmp	r0, #0x0
7009a7e6: d50e         	bpl	0x7009a806 <_vsnprintf+0x8a6> @ imm = #0x1c
7009a7e8: e7ff         	b	0x7009a7ea <_vsnprintf+0x88a> @ imm = #-0x2
;           l = (l < precision ? l : precision);
7009a7ea: 982c         	ldr	r0, [sp, #0xb0]
7009a7ec: 9939         	ldr	r1, [sp, #0xe4]
7009a7ee: 4288         	cmp	r0, r1
7009a7f0: d203         	bhs	0x7009a7fa <_vsnprintf+0x89a> @ imm = #0x6
7009a7f2: e7ff         	b	0x7009a7f4 <_vsnprintf+0x894> @ imm = #-0x2
7009a7f4: 982c         	ldr	r0, [sp, #0xb0]
7009a7f6: 900e         	str	r0, [sp, #0x38]
7009a7f8: e002         	b	0x7009a800 <_vsnprintf+0x8a0> @ imm = #0x4
7009a7fa: 9839         	ldr	r0, [sp, #0xe4]
7009a7fc: 900e         	str	r0, [sp, #0x38]
7009a7fe: e7ff         	b	0x7009a800 <_vsnprintf+0x8a0> @ imm = #-0x2
7009a800: 980e         	ldr	r0, [sp, #0x38]
7009a802: 902c         	str	r0, [sp, #0xb0]
;         }
7009a804: e7ff         	b	0x7009a806 <_vsnprintf+0x8a6> @ imm = #-0x2
;         if (!(flags & FLAGS_LEFT)) {
7009a806: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a80a: 0780         	lsls	r0, r0, #0x1e
7009a80c: 2800         	cmp	r0, #0x0
7009a80e: d413         	bmi	0x7009a838 <_vsnprintf+0x8d8> @ imm = #0x26
7009a810: e7ff         	b	0x7009a812 <_vsnprintf+0x8b2> @ imm = #-0x2
;           while (l++ < width) {
7009a812: e7ff         	b	0x7009a814 <_vsnprintf+0x8b4> @ imm = #-0x2
7009a814: 982c         	ldr	r0, [sp, #0xb0]
7009a816: 1c41         	adds	r1, r0, #0x1
7009a818: 912c         	str	r1, [sp, #0xb0]
7009a81a: 993a         	ldr	r1, [sp, #0xe8]
7009a81c: 4288         	cmp	r0, r1
7009a81e: d20a         	bhs	0x7009a836 <_vsnprintf+0x8d6> @ imm = #0x14
7009a820: e7ff         	b	0x7009a822 <_vsnprintf+0x8c2> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a822: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a826: 993e         	ldr	r1, [sp, #0xf8]
7009a828: 9a37         	ldr	r2, [sp, #0xdc]
7009a82a: 1c50         	adds	r0, r2, #0x1
7009a82c: 9037         	str	r0, [sp, #0xdc]
7009a82e: 9b3d         	ldr	r3, [sp, #0xf4]
7009a830: 2020         	movs	r0, #0x20
7009a832: 47e0         	blx	r12
;           while (l++ < width) {
7009a834: e7ee         	b	0x7009a814 <_vsnprintf+0x8b4> @ imm = #-0x24
;         }
7009a836: e7ff         	b	0x7009a838 <_vsnprintf+0x8d8> @ imm = #-0x2
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a838: e7ff         	b	0x7009a83a <_vsnprintf+0x8da> @ imm = #-0x2
7009a83a: 982d         	ldr	r0, [sp, #0xb4]
7009a83c: 7801         	ldrb	r1, [r0]
7009a83e: 2000         	movs	r0, #0x0
7009a840: 900d         	str	r0, [sp, #0x34]
7009a842: b1a1         	cbz	r1, 0x7009a86e <_vsnprintf+0x90e> @ imm = #0x28
7009a844: e7ff         	b	0x7009a846 <_vsnprintf+0x8e6> @ imm = #-0x2
7009a846: 2001         	movs	r0, #0x1
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a848: f89d 10ed    	ldrb.w	r1, [sp, #0xed]
7009a84c: ea4f 7141    	lsl.w	r1, r1, #0x1d
7009a850: 2900         	cmp	r1, #0x0
7009a852: 900c         	str	r0, [sp, #0x30]
7009a854: d508         	bpl	0x7009a868 <_vsnprintf+0x908> @ imm = #0x10
7009a856: e7ff         	b	0x7009a858 <_vsnprintf+0x8f8> @ imm = #-0x2
7009a858: 9839         	ldr	r0, [sp, #0xe4]
7009a85a: 1e41         	subs	r1, r0, #0x1
7009a85c: 9139         	str	r1, [sp, #0xe4]
7009a85e: 2800         	cmp	r0, #0x0
7009a860: bf18         	it	ne
7009a862: 2001         	movne	r0, #0x1
7009a864: 900c         	str	r0, [sp, #0x30]
7009a866: e7ff         	b	0x7009a868 <_vsnprintf+0x908> @ imm = #-0x2
7009a868: 980c         	ldr	r0, [sp, #0x30]
7009a86a: 900d         	str	r0, [sp, #0x34]
7009a86c: e7ff         	b	0x7009a86e <_vsnprintf+0x90e> @ imm = #-0x2
7009a86e: 980d         	ldr	r0, [sp, #0x34]
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a870: 07c0         	lsls	r0, r0, #0x1f
7009a872: b168         	cbz	r0, 0x7009a890 <_vsnprintf+0x930> @ imm = #0x1a
7009a874: e7ff         	b	0x7009a876 <_vsnprintf+0x916> @ imm = #-0x2
;           out(*(p++), buffer, idx++, maxlen);
7009a876: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a87a: 982d         	ldr	r0, [sp, #0xb4]
7009a87c: 1c41         	adds	r1, r0, #0x1
7009a87e: 912d         	str	r1, [sp, #0xb4]
7009a880: 7800         	ldrb	r0, [r0]
7009a882: 993e         	ldr	r1, [sp, #0xf8]
7009a884: 9a37         	ldr	r2, [sp, #0xdc]
7009a886: 1c53         	adds	r3, r2, #0x1
7009a888: 9337         	str	r3, [sp, #0xdc]
7009a88a: 9b3d         	ldr	r3, [sp, #0xf4]
7009a88c: 47e0         	blx	r12
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a88e: e7d4         	b	0x7009a83a <_vsnprintf+0x8da> @ imm = #-0x58
;         if (flags & FLAGS_LEFT) {
7009a890: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a894: 0780         	lsls	r0, r0, #0x1e
7009a896: 2800         	cmp	r0, #0x0
7009a898: d513         	bpl	0x7009a8c2 <_vsnprintf+0x962> @ imm = #0x26
7009a89a: e7ff         	b	0x7009a89c <_vsnprintf+0x93c> @ imm = #-0x2
;           while (l++ < width) {
7009a89c: e7ff         	b	0x7009a89e <_vsnprintf+0x93e> @ imm = #-0x2
7009a89e: 982c         	ldr	r0, [sp, #0xb0]
7009a8a0: 1c41         	adds	r1, r0, #0x1
7009a8a2: 912c         	str	r1, [sp, #0xb0]
7009a8a4: 993a         	ldr	r1, [sp, #0xe8]
7009a8a6: 4288         	cmp	r0, r1
7009a8a8: d20a         	bhs	0x7009a8c0 <_vsnprintf+0x960> @ imm = #0x14
7009a8aa: e7ff         	b	0x7009a8ac <_vsnprintf+0x94c> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a8ac: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a8b0: 993e         	ldr	r1, [sp, #0xf8]
7009a8b2: 9a37         	ldr	r2, [sp, #0xdc]
7009a8b4: 1c50         	adds	r0, r2, #0x1
7009a8b6: 9037         	str	r0, [sp, #0xdc]
7009a8b8: 9b3d         	ldr	r3, [sp, #0xf4]
7009a8ba: 2020         	movs	r0, #0x20
7009a8bc: 47e0         	blx	r12
;           while (l++ < width) {
7009a8be: e7ee         	b	0x7009a89e <_vsnprintf+0x93e> @ imm = #-0x24
;         }
7009a8c0: e7ff         	b	0x7009a8c2 <_vsnprintf+0x962> @ imm = #-0x2
;         format++;
7009a8c2: 983c         	ldr	r0, [sp, #0xf0]
7009a8c4: 3001         	adds	r0, #0x1
7009a8c6: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a8c8: e047         	b	0x7009a95a <_vsnprintf+0x9fa> @ imm = #0x8e
7009a8ca: 2008         	movs	r0, #0x8
;         width = sizeof(void*) * 2U;
7009a8cc: 903a         	str	r0, [sp, #0xe8]
;         flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
7009a8ce: 983b         	ldr	r0, [sp, #0xec]
7009a8d0: f040 0021    	orr	r0, r0, #0x21
7009a8d4: 903b         	str	r0, [sp, #0xec]
7009a8d6: 2400         	movs	r4, #0x0
;         const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
7009a8d8: f88d 40af    	strb.w	r4, [sp, #0xaf]
;           idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
7009a8dc: 983f         	ldr	r0, [sp, #0xfc]
7009a8de: 993e         	ldr	r1, [sp, #0xf8]
7009a8e0: 9a37         	ldr	r2, [sp, #0xdc]
7009a8e2: 9b3d         	ldr	r3, [sp, #0xf4]
7009a8e4: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a8e8: f10c 0e04    	add.w	lr, r12, #0x4
7009a8ec: f8cd e100    	str.w	lr, [sp, #0x100]
7009a8f0: f8dc c000    	ldr.w	r12, [r12]
7009a8f4: 9d39         	ldr	r5, [sp, #0xe4]
7009a8f6: 9e3a         	ldr	r6, [sp, #0xe8]
7009a8f8: 9f3b         	ldr	r7, [sp, #0xec]
7009a8fa: 46ee         	mov	lr, sp
7009a8fc: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a900: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a904: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a908: 2510         	movs	r5, #0x10
7009a90a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a90e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a912: f8ce c000    	str.w	r12, [lr]
7009a916: f00a f8db    	bl	0x700a4ad0 <_ntoa_long> @ imm = #0xa1b6
7009a91a: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009a91c: 983c         	ldr	r0, [sp, #0xf0]
7009a91e: 3001         	adds	r0, #0x1
7009a920: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a922: e01a         	b	0x7009a95a <_vsnprintf+0x9fa> @ imm = #0x34
;         out('%', buffer, idx++, maxlen);
7009a924: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a928: 993e         	ldr	r1, [sp, #0xf8]
7009a92a: 9a37         	ldr	r2, [sp, #0xdc]
7009a92c: 1c50         	adds	r0, r2, #0x1
7009a92e: 9037         	str	r0, [sp, #0xdc]
7009a930: 9b3d         	ldr	r3, [sp, #0xf4]
7009a932: 2025         	movs	r0, #0x25
7009a934: 47e0         	blx	r12
;         format++;
7009a936: 983c         	ldr	r0, [sp, #0xf0]
7009a938: 3001         	adds	r0, #0x1
7009a93a: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a93c: e00d         	b	0x7009a95a <_vsnprintf+0x9fa> @ imm = #0x1a
;         out(*format, buffer, idx++, maxlen);
7009a93e: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a942: 983c         	ldr	r0, [sp, #0xf0]
7009a944: 7800         	ldrb	r0, [r0]
7009a946: 993e         	ldr	r1, [sp, #0xf8]
7009a948: 9a37         	ldr	r2, [sp, #0xdc]
7009a94a: 1c53         	adds	r3, r2, #0x1
7009a94c: 9337         	str	r3, [sp, #0xdc]
7009a94e: 9b3d         	ldr	r3, [sp, #0xf4]
7009a950: 47e0         	blx	r12
;         format++;
7009a952: 983c         	ldr	r0, [sp, #0xf0]
7009a954: 3001         	adds	r0, #0x1
7009a956: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a958: e7ff         	b	0x7009a95a <_vsnprintf+0x9fa> @ imm = #-0x2
;   while (*format)
7009a95a: f7ff bb18    	b.w	0x70099f8e <_vsnprintf+0x2e> @ imm = #-0x9d0
;   out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
7009a95e: 983f         	ldr	r0, [sp, #0xfc]
7009a960: 900a         	str	r0, [sp, #0x28]
7009a962: 983e         	ldr	r0, [sp, #0xf8]
7009a964: 900b         	str	r0, [sp, #0x2c]
7009a966: 9837         	ldr	r0, [sp, #0xdc]
7009a968: 993d         	ldr	r1, [sp, #0xf4]
7009a96a: 4288         	cmp	r0, r1
7009a96c: d203         	bhs	0x7009a976 <_vsnprintf+0xa16> @ imm = #0x6
7009a96e: e7ff         	b	0x7009a970 <_vsnprintf+0xa10> @ imm = #-0x2
7009a970: 9837         	ldr	r0, [sp, #0xdc]
7009a972: 9009         	str	r0, [sp, #0x24]
7009a974: e003         	b	0x7009a97e <_vsnprintf+0xa1e> @ imm = #0x6
7009a976: 983d         	ldr	r0, [sp, #0xf4]
7009a978: 3801         	subs	r0, #0x1
7009a97a: 9009         	str	r0, [sp, #0x24]
7009a97c: e7ff         	b	0x7009a97e <_vsnprintf+0xa1e> @ imm = #-0x2
7009a97e: f8dd c028    	ldr.w	r12, [sp, #0x28]
7009a982: 990b         	ldr	r1, [sp, #0x2c]
7009a984: 9a09         	ldr	r2, [sp, #0x24]
7009a986: 9b3d         	ldr	r3, [sp, #0xf4]
7009a988: 2000         	movs	r0, #0x0
7009a98a: 47e0         	blx	r12
;   return (int)idx;
7009a98c: 9837         	ldr	r0, [sp, #0xdc]
7009a98e: b041         	add	sp, #0x104
7009a990: e8bd 83f0    	pop.w	{r4, r5, r6, r7, r8, r9, pc}

7009a994 <__aeabi_errno_addr>:
7009a994: e59f0000     	ldr	r0, [pc]                @ 0x7009a99c <__aeabi_errno_addr+0x8>
7009a998: e12fff1e     	bx	lr
7009a99c: c0 29 0b 70  	.word	0x700b29c0

7009a9a0 <Sciclient_rmIrqRouteValidate>:
; {
7009a9a0: b580         	push	{r7, lr}
7009a9a2: b09e         	sub	sp, #0x78
7009a9a4: 901d         	str	r0, [sp, #0x74]
7009a9a6: 2001         	movs	r0, #0x1
;     bool valid = true;
7009a9a8: f88d 0073    	strb.w	r0, [sp, #0x73]
7009a9ac: 2000         	movs	r0, #0x0
;     const struct Sciclient_rmIrqNode *cur_n, *next_n = NULL;
7009a9ae: 9009         	str	r0, [sp, #0x24]
7009a9b0: 9019         	str	r0, [sp, #0x64]
;     bool cur_outp_valid = false, next_inp_valid = false;
7009a9b2: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009a9b6: f88d 005e    	strb.w	r0, [sp, #0x5e]
;     uint16_t cur_outp = 0, next_inp = 0;
7009a9ba: f8ad 0056    	strh.w	r0, [sp, #0x56]
7009a9be: f8ad 0054    	strh.w	r0, [sp, #0x54]
;     struct tisci_msg_rm_get_resource_range_req req = {{0}};
7009a9c2: 9014         	str	r0, [sp, #0x50]
7009a9c4: 9013         	str	r0, [sp, #0x4c]
7009a9c6: 9012         	str	r0, [sp, #0x48]
;     struct tisci_msg_rm_get_resource_range_resp host_resp = {{0}};
7009a9c8: 9011         	str	r0, [sp, #0x44]
7009a9ca: 9010         	str	r0, [sp, #0x40]
7009a9cc: 900f         	str	r0, [sp, #0x3c]
7009a9ce: 900e         	str	r0, [sp, #0x38]
;     struct tisci_msg_rm_get_resource_range_resp all_resp = {{0}};
7009a9d0: 900d         	str	r0, [sp, #0x34]
7009a9d2: 900c         	str	r0, [sp, #0x30]
7009a9d4: 900b         	str	r0, [sp, #0x2c]
7009a9d6: 900a         	str	r0, [sp, #0x28]
;     if (cfg->s_ia == SCICLIENT_RM_DEV_NONE) {
7009a9d8: 981d         	ldr	r0, [sp, #0x74]
7009a9da: 8a00         	ldrh	r0, [r0, #0x10]
7009a9dc: 28ff         	cmp	r0, #0xff
7009a9de: d12c         	bne	0x7009aa3a <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #0x58
7009a9e0: e7ff         	b	0x7009a9e2 <Sciclient_rmIrqRouteValidate+0x42> @ imm = #-0x2
7009a9e2: 2000         	movs	r0, #0x0
;         cur_n = Sciclient_rmPsGetIrqNode(0u);
7009a9e4: f014 fcec    	bl	0x700af3c0 <Sciclient_rmPsGetIrqNode> @ imm = #0x149d8
7009a9e8: 901a         	str	r0, [sp, #0x68]
;         if (cur_n == NULL) {
7009a9ea: 981a         	ldr	r0, [sp, #0x68]
7009a9ec: b920         	cbnz	r0, 0x7009a9f8 <Sciclient_rmIrqRouteValidate+0x58> @ imm = #0x8
7009a9ee: e7ff         	b	0x7009a9f0 <Sciclient_rmIrqRouteValidate+0x50> @ imm = #-0x2
7009a9f0: 2000         	movs	r0, #0x0
;             valid = false;
7009a9f2: f88d 0073    	strb.w	r0, [sp, #0x73]
;         } else {
7009a9f6: e01f         	b	0x7009aa38 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #0x3e
;             cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(0u)];
7009a9f8: 981a         	ldr	r0, [sp, #0x68]
7009a9fa: 6840         	ldr	r0, [r0, #0x4]
7009a9fc: 9008         	str	r0, [sp, #0x20]
7009a9fe: 2000         	movs	r0, #0x0
7009aa00: f013 f8a6    	bl	0x700adb50 <Sciclient_rmPsGetIfIdx> @ imm = #0x1314c
7009aa04: 4601         	mov	r1, r0
7009aa06: 9808         	ldr	r0, [sp, #0x20]
7009aa08: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009aa0c: 9018         	str	r0, [sp, #0x60]
;             if ((cfg->s_idx < cur_if->lbase) ||
7009aa0e: 981d         	ldr	r0, [sp, #0x74]
7009aa10: 8900         	ldrh	r0, [r0, #0x8]
7009aa12: 9918         	ldr	r1, [sp, #0x60]
7009aa14: 8809         	ldrh	r1, [r1]
7009aa16: 4288         	cmp	r0, r1
7009aa18: db09         	blt	0x7009aa2e <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #0x12
7009aa1a: e7ff         	b	0x7009aa1c <Sciclient_rmIrqRouteValidate+0x7c> @ imm = #-0x2
;                 (cfg->s_idx >= (cur_if->lbase + cur_if->len))) {
7009aa1c: 981d         	ldr	r0, [sp, #0x74]
7009aa1e: 8900         	ldrh	r0, [r0, #0x8]
7009aa20: 9a18         	ldr	r2, [sp, #0x60]
7009aa22: 8811         	ldrh	r1, [r2]
7009aa24: 8892         	ldrh	r2, [r2, #0x4]
7009aa26: 4411         	add	r1, r2
;             if ((cfg->s_idx < cur_if->lbase) ||
7009aa28: 4288         	cmp	r0, r1
7009aa2a: db04         	blt	0x7009aa36 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #0x8
7009aa2c: e7ff         	b	0x7009aa2e <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #-0x2
7009aa2e: 2000         	movs	r0, #0x0
;                 valid = false;
7009aa30: f88d 0073    	strb.w	r0, [sp, #0x73]
;             }
7009aa34: e7ff         	b	0x7009aa36 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #-0x2
7009aa36: e7ff         	b	0x7009aa38 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #-0x2
;     }
7009aa38: e7ff         	b	0x7009aa3a <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #-0x2
;     if ((valid == true) &&
7009aa3a: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009aa3e: 07c0         	lsls	r0, r0, #0x1f
7009aa40: b148         	cbz	r0, 0x7009aa56 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x12
7009aa42: e7ff         	b	0x7009aa44 <Sciclient_rmIrqRouteValidate+0xa4> @ imm = #-0x2
;         (Sciclient_rmPsGetPsp() <= 1U)) {
7009aa44: f015 f8fc    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0x151f8
;     if ((valid == true) &&
7009aa48: 2801         	cmp	r0, #0x1
7009aa4a: d804         	bhi	0x7009aa56 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x8
7009aa4c: e7ff         	b	0x7009aa4e <Sciclient_rmIrqRouteValidate+0xae> @ imm = #-0x2
7009aa4e: 2000         	movs	r0, #0x0
;         valid = false;
7009aa50: f88d 0073    	strb.w	r0, [sp, #0x73]
;     }
7009aa54: e7ff         	b	0x7009aa56 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #-0x2
;     if (valid == true) {
7009aa56: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009aa5a: 07c0         	lsls	r0, r0, #0x1f
7009aa5c: b150         	cbz	r0, 0x7009aa74 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #0x14
7009aa5e: e7ff         	b	0x7009aa60 <Sciclient_rmIrqRouteValidate+0xc0> @ imm = #-0x2
;         if (Sciclient_rmIrqCheckLoop(cfg) == true) {
7009aa60: 981d         	ldr	r0, [sp, #0x74]
7009aa62: f00d fdb5    	bl	0x700a85d0 <Sciclient_rmIrqCheckLoop> @ imm = #0xdb6a
7009aa66: b120         	cbz	r0, 0x7009aa72 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #0x8
7009aa68: e7ff         	b	0x7009aa6a <Sciclient_rmIrqRouteValidate+0xca> @ imm = #-0x2
7009aa6a: 2000         	movs	r0, #0x0
;             valid = false;
7009aa6c: f88d 0073    	strb.w	r0, [sp, #0x73]
;         }
7009aa70: e7ff         	b	0x7009aa72 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #-0x2
;     }
7009aa72: e7ff         	b	0x7009aa74 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #-0x2
7009aa74: 2000         	movs	r0, #0x0
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009aa76: f8ad 0070    	strh.w	r0, [sp, #0x70]
7009aa7a: e7ff         	b	0x7009aa7c <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x2
7009aa7c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009aa80: 9006         	str	r0, [sp, #0x18]
7009aa82: f015 f8dd    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0x151ba
7009aa86: 9906         	ldr	r1, [sp, #0x18]
7009aa88: 4602         	mov	r2, r0
7009aa8a: 2000         	movs	r0, #0x0
7009aa8c: 4291         	cmp	r1, r2
7009aa8e: 9007         	str	r0, [sp, #0x1c]
7009aa90: da06         	bge	0x7009aaa0 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #0xc
7009aa92: e7ff         	b	0x7009aa94 <Sciclient_rmIrqRouteValidate+0xf4> @ imm = #-0x2
7009aa94: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009aa98: f000 0001    	and	r0, r0, #0x1
7009aa9c: 9007         	str	r0, [sp, #0x1c]
7009aa9e: e7ff         	b	0x7009aaa0 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #-0x2
7009aaa0: 9807         	ldr	r0, [sp, #0x1c]
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009aaa2: 07c0         	lsls	r0, r0, #0x1f
7009aaa4: 2800         	cmp	r0, #0x0
7009aaa6: f000 826f    	beq.w	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x4de
7009aaaa: e7ff         	b	0x7009aaac <Sciclient_rmIrqRouteValidate+0x10c> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
7009aaac: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009aab0: f014 fc86    	bl	0x700af3c0 <Sciclient_rmPsGetIrqNode> @ imm = #0x1490c
7009aab4: 901a         	str	r0, [sp, #0x68]
;         cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(i)];
7009aab6: 981a         	ldr	r0, [sp, #0x68]
7009aab8: 6840         	ldr	r0, [r0, #0x4]
7009aaba: 9004         	str	r0, [sp, #0x10]
7009aabc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009aac0: f013 f846    	bl	0x700adb50 <Sciclient_rmPsGetIfIdx> @ imm = #0x1308c
7009aac4: 4601         	mov	r1, r0
7009aac6: 9804         	ldr	r0, [sp, #0x10]
7009aac8: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009aacc: 9018         	str	r0, [sp, #0x60]
;         if (i < (Sciclient_rmPsGetPsp() - 1u)) {
7009aace: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009aad2: 9005         	str	r0, [sp, #0x14]
7009aad4: f015 f8b4    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0x15168
7009aad8: 4601         	mov	r1, r0
7009aada: 9805         	ldr	r0, [sp, #0x14]
7009aadc: 3901         	subs	r1, #0x1
7009aade: 4288         	cmp	r0, r1
7009aae0: d20f         	bhs	0x7009ab02 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #0x1e
7009aae2: e7ff         	b	0x7009aae4 <Sciclient_rmIrqRouteValidate+0x144> @ imm = #-0x2
;             next_n = Sciclient_rmPsGetIrqNode(i + 1u);
7009aae4: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009aae8: 3001         	adds	r0, #0x1
7009aaea: b280         	uxth	r0, r0
7009aaec: f014 fc68    	bl	0x700af3c0 <Sciclient_rmPsGetIrqNode> @ imm = #0x148d0
7009aaf0: 9019         	str	r0, [sp, #0x64]
;             if (next_n == NULL) {
7009aaf2: 9819         	ldr	r0, [sp, #0x64]
7009aaf4: b920         	cbnz	r0, 0x7009ab00 <Sciclient_rmIrqRouteValidate+0x160> @ imm = #0x8
7009aaf6: e7ff         	b	0x7009aaf8 <Sciclient_rmIrqRouteValidate+0x158> @ imm = #-0x2
7009aaf8: 2000         	movs	r0, #0x0
;                 valid = false;
7009aafa: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009aafe: e243         	b	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x486
;         }
7009ab00: e7ff         	b	0x7009ab02 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #-0x2
;         if (i > 0u) {
7009ab02: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ab06: b158         	cbz	r0, 0x7009ab20 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #0x16
7009ab08: e7ff         	b	0x7009ab0a <Sciclient_rmIrqRouteValidate+0x16a> @ imm = #-0x2
;             if (Sciclient_rmIrIsIr(cur_n->id) != true) {
7009ab0a: 981a         	ldr	r0, [sp, #0x68]
7009ab0c: 8800         	ldrh	r0, [r0]
7009ab0e: f013 febf    	bl	0x700ae890 <Sciclient_rmIrIsIr> @ imm = #0x13d7e
7009ab12: b920         	cbnz	r0, 0x7009ab1e <Sciclient_rmIrqRouteValidate+0x17e> @ imm = #0x8
7009ab14: e7ff         	b	0x7009ab16 <Sciclient_rmIrqRouteValidate+0x176> @ imm = #-0x2
7009ab16: 2000         	movs	r0, #0x0
;                 valid = false;
7009ab18: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ab1c: e234         	b	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x468
;         }
7009ab1e: e7ff         	b	0x7009ab20 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #-0x2
;         if ((i == 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
7009ab20: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ab24: 2800         	cmp	r0, #0x0
7009ab26: f040 8080    	bne.w	0x7009ac2a <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0x100
7009ab2a: e7ff         	b	0x7009ab2c <Sciclient_rmIrqRouteValidate+0x18c> @ imm = #-0x2
7009ab2c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ab30: 9003         	str	r0, [sp, #0xc]
7009ab32: f015 f885    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0x1510a
7009ab36: 4601         	mov	r1, r0
7009ab38: 9803         	ldr	r0, [sp, #0xc]
7009ab3a: 3901         	subs	r1, #0x1
7009ab3c: 4288         	cmp	r0, r1
7009ab3e: d274         	bhs	0x7009ac2a <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0xe8
7009ab40: e7ff         	b	0x7009ab42 <Sciclient_rmIrqRouteValidate+0x1a2> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cur_n->id) == true) {
7009ab42: 981a         	ldr	r0, [sp, #0x68]
7009ab44: 8800         	ldrh	r0, [r0]
7009ab46: f013 fe8b    	bl	0x700ae860 <Sciclient_rmIaIsIa> @ imm = #0x13d16
7009ab4a: 2800         	cmp	r0, #0x0
7009ab4c: d049         	beq	0x7009abe2 <Sciclient_rmIrqRouteValidate+0x242> @ imm = #0x92
7009ab4e: e7ff         	b	0x7009ab50 <Sciclient_rmIrqRouteValidate+0x1b0> @ imm = #-0x2
7009ab50: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
7009ab52: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
7009ab56: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cfg->vint,
7009ab5a: 9a18         	ldr	r2, [sp, #0x60]
7009ab5c: 8850         	ldrh	r0, [r2, #0x2]
7009ab5e: 991d         	ldr	r1, [sp, #0x74]
7009ab60: 8a49         	ldrh	r1, [r1, #0x12]
7009ab62: 8812         	ldrh	r2, [r2]
7009ab64: 1a89         	subs	r1, r1, r2
7009ab66: 4408         	add	r0, r1
7009ab68: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 cur_outp = cfg->vint;
7009ab6c: 981d         	ldr	r0, [sp, #0x74]
7009ab6e: 8a40         	ldrh	r0, [r0, #0x12]
7009ab70: f8ad 0056    	strh.w	r0, [sp, #0x56]
7009ab74: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
7009ab76: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009ab7a: 9819         	ldr	r0, [sp, #0x64]
7009ab7c: b160         	cbz	r0, 0x7009ab98 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x18
7009ab7e: e7ff         	b	0x7009ab80 <Sciclient_rmIrqRouteValidate+0x1e0> @ imm = #-0x2
7009ab80: 9819         	ldr	r0, [sp, #0x64]
7009ab82: 8800         	ldrh	r0, [r0]
7009ab84: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009ab88: f00b fa9a    	bl	0x700a60c0 <Sciclient_rmIrInpIsFree> @ imm = #0xb534
7009ab8c: b920         	cbnz	r0, 0x7009ab98 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x8
7009ab8e: e7ff         	b	0x7009ab90 <Sciclient_rmIrqRouteValidate+0x1f0> @ imm = #-0x2
7009ab90: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
7009ab92: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
7009ab96: e7ff         	b	0x7009ab98 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #-0x2
;                 if (Sciclient_rmParamIsValid(cfg->valid_params,
7009ab98: 981d         	ldr	r0, [sp, #0x74]
7009ab9a: 6800         	ldr	r0, [r0]
7009ab9c: 2110         	movs	r1, #0x10
7009ab9e: f014 f857    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x140ae
7009aba2: b1e8         	cbz	r0, 0x7009abe0 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #0x3a
7009aba4: e7ff         	b	0x7009aba6 <Sciclient_rmIrqRouteValidate+0x206> @ imm = #-0x2
;                     cur_inp = cfg->global_evt;
7009aba6: 981d         	ldr	r0, [sp, #0x74]
7009aba8: 89c0         	ldrh	r0, [r0, #0xe]
7009abaa: 9016         	str	r0, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
7009abac: 981a         	ldr	r0, [sp, #0x68]
7009abae: 8800         	ldrh	r0, [r0]
;                                       cur_inp) ==
7009abb0: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
7009abb4: f011 fce4    	bl	0x700ac580 <Sciclient_rmIaValidateGlobalEvt> @ imm = #0x119c8
7009abb8: b968         	cbnz	r0, 0x7009abd6 <Sciclient_rmIrqRouteValidate+0x236> @ imm = #0x1a
7009abba: e7ff         	b	0x7009abbc <Sciclient_rmIrqRouteValidate+0x21c> @ imm = #-0x2
;                         if (Sciclient_rmPsSetInp(i, cur_inp) != SystemP_SUCCESS) {
7009abbc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009abc0: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
7009abc4: f012 fb2c    	bl	0x700ad220 <Sciclient_rmPsSetInp> @ imm = #0x12658
7009abc8: b120         	cbz	r0, 0x7009abd4 <Sciclient_rmIrqRouteValidate+0x234> @ imm = #0x8
7009abca: e7ff         	b	0x7009abcc <Sciclient_rmIrqRouteValidate+0x22c> @ imm = #-0x2
7009abcc: 2000         	movs	r0, #0x0
;                             valid = false;
7009abce: f88d 0073    	strb.w	r0, [sp, #0x73]
;                             break;
7009abd2: e1d9         	b	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3b2
;                     } else {
7009abd4: e003         	b	0x7009abde <Sciclient_rmIrqRouteValidate+0x23e> @ imm = #0x6
7009abd6: 2000         	movs	r0, #0x0
;                         valid = false;
7009abd8: f88d 0073    	strb.w	r0, [sp, #0x73]
;                         break;
7009abdc: e1d4         	b	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3a8
;                 }
7009abde: e7ff         	b	0x7009abe0 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #-0x2
;             } else {
7009abe0: e022         	b	0x7009ac28 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #0x44
7009abe2: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
7009abe4: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009abe8: 2000         	movs	r0, #0x0
;                 next_inp_valid = false;
7009abea: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = cfg->s_idx;
7009abee: 981d         	ldr	r0, [sp, #0x74]
7009abf0: 8900         	ldrh	r0, [r0, #0x8]
7009abf2: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
7009abf6: 9a18         	ldr	r2, [sp, #0x60]
7009abf8: 8850         	ldrh	r0, [r2, #0x2]
7009abfa: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009abfe: 8812         	ldrh	r2, [r2]
7009ac00: 1a89         	subs	r1, r1, r2
7009ac02: 4408         	add	r0, r1
7009ac04: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009ac08: 9819         	ldr	r0, [sp, #0x64]
7009ac0a: b160         	cbz	r0, 0x7009ac26 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x18
7009ac0c: e7ff         	b	0x7009ac0e <Sciclient_rmIrqRouteValidate+0x26e> @ imm = #-0x2
7009ac0e: 9819         	ldr	r0, [sp, #0x64]
7009ac10: 8800         	ldrh	r0, [r0]
7009ac12: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009ac16: f00b fa53    	bl	0x700a60c0 <Sciclient_rmIrInpIsFree> @ imm = #0xb4a6
7009ac1a: b920         	cbnz	r0, 0x7009ac26 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x8
7009ac1c: e7ff         	b	0x7009ac1e <Sciclient_rmIrqRouteValidate+0x27e> @ imm = #-0x2
7009ac1e: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
7009ac20: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
7009ac24: e7ff         	b	0x7009ac26 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #-0x2
7009ac26: e7ff         	b	0x7009ac28 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #-0x2
;         }
7009ac28: e7ff         	b	0x7009ac2a <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #-0x2
;         if ((i > 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
7009ac2a: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac2e: 2800         	cmp	r0, #0x0
7009ac30: f000 80c4    	beq.w	0x7009adbc <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x188
7009ac34: e7ff         	b	0x7009ac36 <Sciclient_rmIrqRouteValidate+0x296> @ imm = #-0x2
7009ac36: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac3a: 9002         	str	r0, [sp, #0x8]
7009ac3c: f015 f800    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0x15000
7009ac40: 4601         	mov	r1, r0
7009ac42: 9802         	ldr	r0, [sp, #0x8]
7009ac44: 3901         	subs	r1, #0x1
7009ac46: 4288         	cmp	r0, r1
7009ac48: f080 80b8    	bhs.w	0x7009adbc <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x170
7009ac4c: e7ff         	b	0x7009ac4e <Sciclient_rmIrqRouteValidate+0x2ae> @ imm = #-0x2
;             req.secondary_host = cfg->host;
7009ac4e: 981d         	ldr	r0, [sp, #0x74]
7009ac50: 7900         	ldrb	r0, [r0, #0x4]
7009ac52: f88d 0053    	strb.w	r0, [sp, #0x53]
;             req.type = cur_n->id;
7009ac56: 981a         	ldr	r0, [sp, #0x68]
7009ac58: 8800         	ldrh	r0, [r0]
7009ac5a: f8ad 0050    	strh.w	r0, [sp, #0x50]
7009ac5e: 2000         	movs	r0, #0x0
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
7009ac60: f88d 0052    	strb.w	r0, [sp, #0x52]
7009ac64: a812         	add	r0, sp, #0x48
7009ac66: a90e         	add	r1, sp, #0x38
7009ac68: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
7009ac6c: f010 fb60    	bl	0x700ab330 <Sciclient_rmGetResourceRange> @ imm = #0x106c0
7009ac70: b120         	cbz	r0, 0x7009ac7c <Sciclient_rmIrqRouteValidate+0x2dc> @ imm = #0x8
7009ac72: e7ff         	b	0x7009ac74 <Sciclient_rmIrqRouteValidate+0x2d4> @ imm = #-0x2
7009ac74: 2000         	movs	r0, #0x0
;                 valid = false;
7009ac76: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ac7a: e185         	b	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30a
7009ac7c: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
7009ac7e: f88d 0053    	strb.w	r0, [sp, #0x53]
7009ac82: a812         	add	r0, sp, #0x48
7009ac84: a90a         	add	r1, sp, #0x28
7009ac86: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
7009ac8a: f010 fb51    	bl	0x700ab330 <Sciclient_rmGetResourceRange> @ imm = #0x106a2
7009ac8e: b120         	cbz	r0, 0x7009ac9a <Sciclient_rmIrqRouteValidate+0x2fa> @ imm = #0x8
7009ac90: e7ff         	b	0x7009ac92 <Sciclient_rmIrqRouteValidate+0x2f2> @ imm = #-0x2
7009ac92: 2000         	movs	r0, #0x0
;                 valid = false;
7009ac94: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ac98: e176         	b	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x2ec
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
7009ac9a: 9818         	ldr	r0, [sp, #0x60]
7009ac9c: 8800         	ldrh	r0, [r0]
7009ac9e: f8ad 006e    	strh.w	r0, [sp, #0x6e]
7009aca2: e7ff         	b	0x7009aca4 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x2
7009aca4: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009aca8: 9a18         	ldr	r2, [sp, #0x60]
7009acaa: 8811         	ldrh	r1, [r2]
7009acac: 8892         	ldrh	r2, [r2, #0x4]
7009acae: 4411         	add	r1, r2
7009acb0: 4288         	cmp	r0, r1
7009acb2: f280 8082    	bge.w	0x7009adba <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0x104
7009acb6: e7ff         	b	0x7009acb8 <Sciclient_rmIrqRouteValidate+0x318> @ imm = #-0x2
7009acb8: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
7009acba: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
7009acbe: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = j;
7009acc2: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009acc6: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
7009acca: 9a18         	ldr	r2, [sp, #0x60]
7009accc: 8850         	ldrh	r0, [r2, #0x2]
7009acce: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009acd2: 8812         	ldrh	r2, [r2]
7009acd4: 1a89         	subs	r1, r1, r2
7009acd6: 4408         	add	r0, r1
7009acd8: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((((cur_outp >= host_resp.range_start) &&
7009acdc: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ace0: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009ace4: 4288         	cmp	r0, r1
7009ace6: db0a         	blt	0x7009acfe <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #0x14
7009ace8: e7ff         	b	0x7009acea <Sciclient_rmIrqRouteValidate+0x34a> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start + host_resp.range_num)) ||
7009acea: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009acee: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009acf2: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
7009acf6: 4411         	add	r1, r2
7009acf8: 4288         	cmp	r0, r1
7009acfa: db33         	blt	0x7009ad64 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x66
7009acfc: e7ff         	b	0x7009acfe <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #-0x2
;                      ((cur_outp >= host_resp.range_start_sec) &&
7009acfe: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ad02: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
7009ad06: 4288         	cmp	r0, r1
7009ad08: db0a         	blt	0x7009ad20 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #0x14
7009ad0a: e7ff         	b	0x7009ad0c <Sciclient_rmIrqRouteValidate+0x36c> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start_sec +
7009ad0c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ad10: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                                   host_resp.range_num_sec))) ||
7009ad14: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                       (cur_outp < host_resp.range_start_sec +
7009ad18: 4411         	add	r1, r2
;                                   host_resp.range_num_sec))) ||
7009ad1a: 4288         	cmp	r0, r1
7009ad1c: db22         	blt	0x7009ad64 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x44
7009ad1e: e7ff         	b	0x7009ad20 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #-0x2
;                     (((cur_outp >= all_resp.range_start) &&
7009ad20: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ad24: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009ad28: 4288         	cmp	r0, r1
7009ad2a: db0a         	blt	0x7009ad42 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #0x14
7009ad2c: e7ff         	b	0x7009ad2e <Sciclient_rmIrqRouteValidate+0x38e> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start + all_resp.range_num)) ||
7009ad2e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ad32: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009ad36: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
7009ad3a: 4411         	add	r1, r2
7009ad3c: 4288         	cmp	r0, r1
7009ad3e: db11         	blt	0x7009ad64 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x22
7009ad40: e7ff         	b	0x7009ad42 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #-0x2
;                      ((cur_outp >= all_resp.range_start_sec) &&
7009ad42: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ad46: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
7009ad4a: 4288         	cmp	r0, r1
7009ad4c: db2e         	blt	0x7009adac <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x5c
7009ad4e: e7ff         	b	0x7009ad50 <Sciclient_rmIrqRouteValidate+0x3b0> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start_sec +
7009ad50: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ad54: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                                   all_resp.range_num_sec)))) {
7009ad58: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                       (cur_outp < all_resp.range_start_sec +
7009ad5c: 4411         	add	r1, r2
;                 if ((((cur_outp >= host_resp.range_start) &&
7009ad5e: 4288         	cmp	r0, r1
7009ad60: da24         	bge	0x7009adac <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x48
7009ad62: e7ff         	b	0x7009ad64 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
7009ad64: 981a         	ldr	r0, [sp, #0x68]
7009ad66: 8800         	ldrh	r0, [r0]
7009ad68: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009ad6c: f00e f908    	bl	0x700a8f80 <Sciclient_rmIrOutpIsFree> @ imm = #0xe210
7009ad70: b920         	cbnz	r0, 0x7009ad7c <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #0x8
7009ad72: e7ff         	b	0x7009ad74 <Sciclient_rmIrqRouteValidate+0x3d4> @ imm = #-0x2
7009ad74: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
7009ad76: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
7009ad7a: e7ff         	b	0x7009ad7c <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #-0x2
;                     if (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009ad7c: 9819         	ldr	r0, [sp, #0x64]
7009ad7e: 8800         	ldrh	r0, [r0]
7009ad80: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009ad84: f00b f99c    	bl	0x700a60c0 <Sciclient_rmIrInpIsFree> @ imm = #0xb338
7009ad88: b920         	cbnz	r0, 0x7009ad94 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #0x8
7009ad8a: e7ff         	b	0x7009ad8c <Sciclient_rmIrqRouteValidate+0x3ec> @ imm = #-0x2
7009ad8c: 2001         	movs	r0, #0x1
;                         next_inp_valid = true;
7009ad8e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                     }
7009ad92: e7ff         	b	0x7009ad94 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #-0x2
;                     if ((cur_outp_valid == true) &&
7009ad94: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
7009ad98: 07c0         	lsls	r0, r0, #0x1f
7009ad9a: b130         	cbz	r0, 0x7009adaa <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0xc
7009ad9c: e7ff         	b	0x7009ad9e <Sciclient_rmIrqRouteValidate+0x3fe> @ imm = #-0x2
;                         (next_inp_valid == true)) {
7009ad9e: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
;                     if ((cur_outp_valid == true) &&
7009ada2: 07c0         	lsls	r0, r0, #0x1f
7009ada4: b108         	cbz	r0, 0x7009adaa <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0x2
7009ada6: e7ff         	b	0x7009ada8 <Sciclient_rmIrqRouteValidate+0x408> @ imm = #-0x2
;                         break;
7009ada8: e007         	b	0x7009adba <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0xe
;                 }
7009adaa: e7ff         	b	0x7009adac <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #-0x2
;             }
7009adac: e7ff         	b	0x7009adae <Sciclient_rmIrqRouteValidate+0x40e> @ imm = #-0x2
;                  j++) {
7009adae: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009adb2: 3001         	adds	r0, #0x1
7009adb4: f8ad 006e    	strh.w	r0, [sp, #0x6e]
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
7009adb8: e774         	b	0x7009aca4 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x118
;         }
7009adba: e7ff         	b	0x7009adbc <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #-0x2
;         if (i == (Sciclient_rmPsGetPsp() - 1u)) {
7009adbc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009adc0: 9001         	str	r0, [sp, #0x4]
7009adc2: f014 ff3d    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0x14e7a
7009adc6: 4601         	mov	r1, r0
7009adc8: 9801         	ldr	r0, [sp, #0x4]
7009adca: 3901         	subs	r1, #0x1
7009adcc: 4288         	cmp	r0, r1
7009adce: f040 809f    	bne.w	0x7009af10 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #0x13e
7009add2: e7ff         	b	0x7009add4 <Sciclient_rmIrqRouteValidate+0x434> @ imm = #-0x2
7009add4: 2000         	movs	r0, #0x0
;             cur_outp_valid = false;
7009add6: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009adda: 2101         	movs	r1, #0x1
;             next_inp_valid = true;
7009addc: f88d 105e    	strb.w	r1, [sp, #0x5e]
;             req.secondary_host = cfg->host;
7009ade0: 991d         	ldr	r1, [sp, #0x74]
7009ade2: 7909         	ldrb	r1, [r1, #0x4]
7009ade4: f88d 1053    	strb.w	r1, [sp, #0x53]
;             req.type = cur_n->id;
7009ade8: 991a         	ldr	r1, [sp, #0x68]
7009adea: 8809         	ldrh	r1, [r1]
7009adec: f8ad 1050    	strh.w	r1, [sp, #0x50]
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
7009adf0: f88d 0052    	strb.w	r0, [sp, #0x52]
7009adf4: a812         	add	r0, sp, #0x48
7009adf6: a90e         	add	r1, sp, #0x38
7009adf8: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
7009adfc: f010 fa98    	bl	0x700ab330 <Sciclient_rmGetResourceRange> @ imm = #0x10530
7009ae00: b120         	cbz	r0, 0x7009ae0c <Sciclient_rmIrqRouteValidate+0x46c> @ imm = #0x8
7009ae02: e7ff         	b	0x7009ae04 <Sciclient_rmIrqRouteValidate+0x464> @ imm = #-0x2
7009ae04: 2000         	movs	r0, #0x0
;                 valid = false;
7009ae06: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ae0a: e0bd         	b	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x17a
7009ae0c: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
7009ae0e: f88d 0053    	strb.w	r0, [sp, #0x53]
7009ae12: a812         	add	r0, sp, #0x48
7009ae14: a90a         	add	r1, sp, #0x28
7009ae16: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
7009ae1a: f010 fa89    	bl	0x700ab330 <Sciclient_rmGetResourceRange> @ imm = #0x10512
7009ae1e: b120         	cbz	r0, 0x7009ae2a <Sciclient_rmIrqRouteValidate+0x48a> @ imm = #0x8
7009ae20: e7ff         	b	0x7009ae22 <Sciclient_rmIrqRouteValidate+0x482> @ imm = #-0x2
7009ae22: 2000         	movs	r0, #0x0
;                 valid = false;
7009ae24: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ae28: e0ae         	b	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x15c
;             cur_outp = SCICLIENT_INP_TO_OUTP(cfg->d_irq,
7009ae2a: 9a18         	ldr	r2, [sp, #0x60]
7009ae2c: 8810         	ldrh	r0, [r2]
7009ae2e: 991d         	ldr	r1, [sp, #0x74]
7009ae30: 8989         	ldrh	r1, [r1, #0xc]
7009ae32: 8852         	ldrh	r2, [r2, #0x2]
7009ae34: 1a89         	subs	r1, r1, r2
7009ae36: 4408         	add	r0, r1
7009ae38: f8ad 0056    	strh.w	r0, [sp, #0x56]
;             if ((((cur_outp >= host_resp.range_start) &&
7009ae3c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae40: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009ae44: 4288         	cmp	r0, r1
7009ae46: db0a         	blt	0x7009ae5e <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #0x14
7009ae48: e7ff         	b	0x7009ae4a <Sciclient_rmIrqRouteValidate+0x4aa> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start + host_resp.range_num)) ||
7009ae4a: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae4e: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009ae52: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
7009ae56: 4411         	add	r1, r2
7009ae58: 4288         	cmp	r0, r1
7009ae5a: db33         	blt	0x7009aec4 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x66
7009ae5c: e7ff         	b	0x7009ae5e <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #-0x2
;                  ((cur_outp >= host_resp.range_start_sec) &&
7009ae5e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae62: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
7009ae66: 4288         	cmp	r0, r1
7009ae68: db0a         	blt	0x7009ae80 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #0x14
7009ae6a: e7ff         	b	0x7009ae6c <Sciclient_rmIrqRouteValidate+0x4cc> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start_sec +
7009ae6c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae70: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                               host_resp.range_num_sec))) ||
7009ae74: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                   (cur_outp < host_resp.range_start_sec +
7009ae78: 4411         	add	r1, r2
;                               host_resp.range_num_sec))) ||
7009ae7a: 4288         	cmp	r0, r1
7009ae7c: db22         	blt	0x7009aec4 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x44
7009ae7e: e7ff         	b	0x7009ae80 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #-0x2
;                 (((cur_outp >= all_resp.range_start) &&
7009ae80: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae84: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009ae88: 4288         	cmp	r0, r1
7009ae8a: db0a         	blt	0x7009aea2 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #0x14
7009ae8c: e7ff         	b	0x7009ae8e <Sciclient_rmIrqRouteValidate+0x4ee> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start + all_resp.range_num)) ||
7009ae8e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae92: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009ae96: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
7009ae9a: 4411         	add	r1, r2
7009ae9c: 4288         	cmp	r0, r1
7009ae9e: db11         	blt	0x7009aec4 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x22
7009aea0: e7ff         	b	0x7009aea2 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #-0x2
;                  ((cur_outp >= all_resp.range_start_sec) &&
7009aea2: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aea6: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
7009aeaa: 4288         	cmp	r0, r1
7009aeac: db2f         	blt	0x7009af0e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x5e
7009aeae: e7ff         	b	0x7009aeb0 <Sciclient_rmIrqRouteValidate+0x510> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start_sec +
7009aeb0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aeb4: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                               all_resp.range_num_sec)))) {
7009aeb8: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                   (cur_outp < all_resp.range_start_sec +
7009aebc: 4411         	add	r1, r2
;             if ((((cur_outp >= host_resp.range_start) &&
7009aebe: 4288         	cmp	r0, r1
7009aec0: da25         	bge	0x7009af0e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x4a
7009aec2: e7ff         	b	0x7009aec4 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
7009aec4: 9818         	ldr	r0, [sp, #0x60]
7009aec6: 88c0         	ldrh	r0, [r0, #0x6]
7009aec8: 991d         	ldr	r1, [sp, #0x74]
7009aeca: 8949         	ldrh	r1, [r1, #0xa]
7009aecc: 4288         	cmp	r0, r1
7009aece: d11d         	bne	0x7009af0c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x3a
7009aed0: e7ff         	b	0x7009aed2 <Sciclient_rmIrqRouteValidate+0x532> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
7009aed2: 981d         	ldr	r0, [sp, #0x74]
7009aed4: 8980         	ldrh	r0, [r0, #0xc]
7009aed6: 9918         	ldr	r1, [sp, #0x60]
7009aed8: 8849         	ldrh	r1, [r1, #0x2]
7009aeda: 4288         	cmp	r0, r1
7009aedc: db16         	blt	0x7009af0c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x2c
7009aede: e7ff         	b	0x7009aee0 <Sciclient_rmIrqRouteValidate+0x540> @ imm = #-0x2
;                     (cfg->d_irq < (cur_if->rbase + cur_if->len))) {
7009aee0: 981d         	ldr	r0, [sp, #0x74]
7009aee2: 8980         	ldrh	r0, [r0, #0xc]
7009aee4: 9a18         	ldr	r2, [sp, #0x60]
7009aee6: 8851         	ldrh	r1, [r2, #0x2]
7009aee8: 8892         	ldrh	r2, [r2, #0x4]
7009aeea: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
7009aeec: 4288         	cmp	r0, r1
7009aeee: da0d         	bge	0x7009af0c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x1a
7009aef0: e7ff         	b	0x7009aef2 <Sciclient_rmIrqRouteValidate+0x552> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
7009aef2: 981a         	ldr	r0, [sp, #0x68]
7009aef4: 8800         	ldrh	r0, [r0]
7009aef6: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009aefa: f00e f841    	bl	0x700a8f80 <Sciclient_rmIrOutpIsFree> @ imm = #0xe082
7009aefe: b920         	cbnz	r0, 0x7009af0a <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #0x8
7009af00: e7ff         	b	0x7009af02 <Sciclient_rmIrqRouteValidate+0x562> @ imm = #-0x2
7009af02: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
7009af04: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
7009af08: e7ff         	b	0x7009af0a <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #-0x2
;                 }
7009af0a: e7ff         	b	0x7009af0c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #-0x2
; 	    }
7009af0c: e7ff         	b	0x7009af0e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #-0x2
;         }
7009af0e: e7ff         	b	0x7009af10 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #-0x2
;         if ((cur_outp_valid == true) && (next_inp_valid == true)) {
7009af10: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
7009af14: 07c0         	lsls	r0, r0, #0x1f
7009af16: b360         	cbz	r0, 0x7009af72 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x58
7009af18: e7ff         	b	0x7009af1a <Sciclient_rmIrqRouteValidate+0x57a> @ imm = #-0x2
7009af1a: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
7009af1e: 07c0         	lsls	r0, r0, #0x1f
7009af20: b338         	cbz	r0, 0x7009af72 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x4e
7009af22: e7ff         	b	0x7009af24 <Sciclient_rmIrqRouteValidate+0x584> @ imm = #-0x2
;             if (i < (Sciclient_rmPsGetPsp() - (1u))) {
7009af24: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009af28: 9000         	str	r0, [sp]
7009af2a: f014 fe89    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0x14d12
7009af2e: 4601         	mov	r1, r0
7009af30: 9800         	ldr	r0, [sp]
7009af32: 3901         	subs	r1, #0x1
7009af34: 4288         	cmp	r0, r1
7009af36: d20f         	bhs	0x7009af58 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #0x1e
7009af38: e7ff         	b	0x7009af3a <Sciclient_rmIrqRouteValidate+0x59a> @ imm = #-0x2
;                 if (Sciclient_rmPsSetInp(i + (1u), next_inp) != SystemP_SUCCESS) {
7009af3a: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009af3e: 3001         	adds	r0, #0x1
7009af40: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009af44: b280         	uxth	r0, r0
7009af46: f012 f96b    	bl	0x700ad220 <Sciclient_rmPsSetInp> @ imm = #0x122d6
7009af4a: b120         	cbz	r0, 0x7009af56 <Sciclient_rmIrqRouteValidate+0x5b6> @ imm = #0x8
7009af4c: e7ff         	b	0x7009af4e <Sciclient_rmIrqRouteValidate+0x5ae> @ imm = #-0x2
7009af4e: 2000         	movs	r0, #0x0
;                     valid = false;
7009af50: f88d 0073    	strb.w	r0, [sp, #0x73]
;                     break;
7009af54: e018         	b	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30
;             }
7009af56: e7ff         	b	0x7009af58 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #-0x2
;             if (Sciclient_rmPsSetOutp(i, cur_outp) != SystemP_SUCCESS) {
7009af58: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009af5c: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009af60: f012 f986    	bl	0x700ad270 <Sciclient_rmPsSetOutp> @ imm = #0x1230c
7009af64: b120         	cbz	r0, 0x7009af70 <Sciclient_rmIrqRouteValidate+0x5d0> @ imm = #0x8
7009af66: e7ff         	b	0x7009af68 <Sciclient_rmIrqRouteValidate+0x5c8> @ imm = #-0x2
7009af68: 2000         	movs	r0, #0x0
;                 valid = false;
7009af6a: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009af6e: e00b         	b	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x16
;         } else {
7009af70: e003         	b	0x7009af7a <Sciclient_rmIrqRouteValidate+0x5da> @ imm = #0x6
7009af72: 2000         	movs	r0, #0x0
;             valid = false;
7009af74: f88d 0073    	strb.w	r0, [sp, #0x73]
;             break;
7009af78: e006         	b	0x7009af88 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0xc
;     }
7009af7a: e7ff         	b	0x7009af7c <Sciclient_rmIrqRouteValidate+0x5dc> @ imm = #-0x2
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009af7c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009af80: 3001         	adds	r0, #0x1
7009af82: f8ad 0070    	strh.w	r0, [sp, #0x70]
7009af86: e579         	b	0x7009aa7c <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x50e
;     return valid;
7009af88: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009af8c: f000 0001    	and	r0, r0, #0x1
7009af90: b01e         	add	sp, #0x78
7009af92: bd80         	pop	{r7, pc}

7009af94 <__aeabi_memclr8>:
7009af94: e1a02001     	mov	r2, r1
7009af98: e3b01000     	movs	r1, #0
7009af9c: ea0051e5     	b	0x700af738 <TI_memset_small> @ imm = #0x14794

7009afa0 <_ftoa>:
; {
7009afa0: b570         	push	{r4, r5, r6, lr}
7009afa2: b0a2         	sub	sp, #0x88
7009afa4: f8dd c0a0    	ldr.w	r12, [sp, #0xa0]
7009afa8: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009afac: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009afb0: 9020         	str	r0, [sp, #0x80]
7009afb2: 911f         	str	r1, [sp, #0x7c]
7009afb4: 921e         	str	r2, [sp, #0x78]
7009afb6: 931d         	str	r3, [sp, #0x74]
7009afb8: ed8d 0b1a    	vstr	d0, [sp, #104]
7009afbc: 2000         	movs	r0, #0x0
;   size_t len  = 0U;
7009afbe: 9011         	str	r0, [sp, #0x44]
;   double diff = 0.0;
7009afc0: 900f         	str	r0, [sp, #0x3c]
7009afc2: 900e         	str	r0, [sp, #0x38]
;   if (value != value)
7009afc4: ed9d 0b1a    	vldr	d0, [sp, #104]
7009afc8: eeb4 0b40    	vcmp.f64	d0, d0
7009afcc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009afd0: d71a         	bvc	0x7009b008 <_ftoa+0x68> @ imm = #0x34
7009afd2: e7ff         	b	0x7009afd4 <_ftoa+0x34> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
7009afd4: 9820         	ldr	r0, [sp, #0x80]
7009afd6: 991f         	ldr	r1, [sp, #0x7c]
7009afd8: 9a1e         	ldr	r2, [sp, #0x78]
7009afda: 9b1d         	ldr	r3, [sp, #0x74]
7009afdc: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009afe0: 9c28         	ldr	r4, [sp, #0xa0]
7009afe2: 46ee         	mov	lr, sp
7009afe4: f8ce 400c    	str.w	r4, [lr, #0xc]
7009afe8: f8ce c008    	str.w	r12, [lr, #0x8]
7009afec: f04f 0c03    	mov.w	r12, #0x3
7009aff0: f8ce c004    	str.w	r12, [lr, #0x4]
7009aff4: f242 6c44    	movw	r12, #0x2644
7009aff8: f2c7 0c0b    	movt	r12, #0x700b
7009affc: f8ce c000    	str.w	r12, [lr]
7009b000: f00c fa66    	bl	0x700a74d0 <_out_rev>   @ imm = #0xc4cc
7009b004: 9021         	str	r0, [sp, #0x84]
7009b006: e257         	b	0x7009b4b8 <_ftoa+0x518> @ imm = #0x4ae
;   if (value < -DBL_MAX)
7009b008: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b00c: ed9f 1bd2    	vldr	d1, [pc, #840]          @ 0x7009b358 <_ftoa+0x3b8>
7009b010: eeb4 0b41    	vcmp.f64	d0, d1
7009b014: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b018: d51a         	bpl	0x7009b050 <_ftoa+0xb0> @ imm = #0x34
7009b01a: e7ff         	b	0x7009b01c <_ftoa+0x7c> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
7009b01c: 9820         	ldr	r0, [sp, #0x80]
7009b01e: 991f         	ldr	r1, [sp, #0x7c]
7009b020: 9a1e         	ldr	r2, [sp, #0x78]
7009b022: 9b1d         	ldr	r3, [sp, #0x74]
7009b024: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009b028: 9c28         	ldr	r4, [sp, #0xa0]
7009b02a: 46ee         	mov	lr, sp
7009b02c: f8ce 400c    	str.w	r4, [lr, #0xc]
7009b030: f8ce c008    	str.w	r12, [lr, #0x8]
7009b034: f04f 0c04    	mov.w	r12, #0x4
7009b038: f8ce c004    	str.w	r12, [lr, #0x4]
7009b03c: f242 6c1d    	movw	r12, #0x261d
7009b040: f2c7 0c0b    	movt	r12, #0x700b
7009b044: f8ce c000    	str.w	r12, [lr]
7009b048: f00c fa42    	bl	0x700a74d0 <_out_rev>   @ imm = #0xc484
7009b04c: 9021         	str	r0, [sp, #0x84]
7009b04e: e233         	b	0x7009b4b8 <_ftoa+0x518> @ imm = #0x466
;   if (value > DBL_MAX)
7009b050: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b054: ed9f 1bc2    	vldr	d1, [pc, #776]          @ 0x7009b360 <_ftoa+0x3c0>
7009b058: eeb4 0b41    	vcmp.f64	d0, d1
7009b05c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b060: dd26         	ble	0x7009b0b0 <_ftoa+0x110> @ imm = #0x4c
7009b062: e7ff         	b	0x7009b064 <_ftoa+0xc4> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
7009b064: 9820         	ldr	r0, [sp, #0x80]
7009b066: 991f         	ldr	r1, [sp, #0x7c]
7009b068: 9a1e         	ldr	r2, [sp, #0x78]
7009b06a: 9b1d         	ldr	r3, [sp, #0x74]
7009b06c: 9e28         	ldr	r6, [sp, #0xa0]
7009b06e: f006 0e04    	and	lr, r6, #0x4
7009b072: f242 6427    	movw	r4, #0x2627
7009b076: f2c7 040b    	movt	r4, #0x700b
7009b07a: f242 6c40    	movw	r12, #0x2640
7009b07e: f2c7 0c0b    	movt	r12, #0x700b
7009b082: f1be 0f00    	cmp.w	lr, #0x0
7009b086: bf18         	it	ne
7009b088: 46a4         	movne	r12, r4
7009b08a: 2403         	movs	r4, #0x3
7009b08c: f1be 0f00    	cmp.w	lr, #0x0
7009b090: bf18         	it	ne
7009b092: 2404         	movne	r4, #0x4
7009b094: 9d27         	ldr	r5, [sp, #0x9c]
7009b096: 46ee         	mov	lr, sp
7009b098: f8ce 600c    	str.w	r6, [lr, #0xc]
7009b09c: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b0a0: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b0a4: f8ce c000    	str.w	r12, [lr]
7009b0a8: f00c fa12    	bl	0x700a74d0 <_out_rev>   @ imm = #0xc424
7009b0ac: 9021         	str	r0, [sp, #0x84]
7009b0ae: e203         	b	0x7009b4b8 <_ftoa+0x518> @ imm = #0x406
;   if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
7009b0b0: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b0b4: ed9f 1bac    	vldr	d1, [pc, #688]          @ 0x7009b368 <_ftoa+0x3c8>
7009b0b8: eeb4 0b41    	vcmp.f64	d0, d1
7009b0bc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b0c0: dc0a         	bgt	0x7009b0d8 <_ftoa+0x138> @ imm = #0x14
7009b0c2: e7ff         	b	0x7009b0c4 <_ftoa+0x124> @ imm = #-0x2
7009b0c4: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b0c8: ed9f 1ba9    	vldr	d1, [pc, #676]          @ 0x7009b370 <_ftoa+0x3d0>
7009b0cc: eeb4 0b41    	vcmp.f64	d0, d1
7009b0d0: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b0d4: d515         	bpl	0x7009b102 <_ftoa+0x162> @ imm = #0x2a
7009b0d6: e7ff         	b	0x7009b0d8 <_ftoa+0x138> @ imm = #-0x2
;     return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009b0d8: 9820         	ldr	r0, [sp, #0x80]
7009b0da: 991f         	ldr	r1, [sp, #0x7c]
7009b0dc: 9a1e         	ldr	r2, [sp, #0x78]
7009b0de: 9b1d         	ldr	r3, [sp, #0x74]
7009b0e0: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b0e4: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b0e8: 9c27         	ldr	r4, [sp, #0x9c]
7009b0ea: 9d28         	ldr	r5, [sp, #0xa0]
7009b0ec: 46ee         	mov	lr, sp
7009b0ee: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b0f2: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b0f6: f8ce c000    	str.w	r12, [lr]
7009b0fa: f000 f9e1    	bl	0x7009b4c0 <_etoa>      @ imm = #0x3c2
7009b0fe: 9021         	str	r0, [sp, #0x84]
7009b100: e1da         	b	0x7009b4b8 <_ftoa+0x518> @ imm = #0x3b4
7009b102: f04f 0000    	mov.w	r0, #0x0
;   bool negative = false;
7009b106: f88d 0037    	strb.w	r0, [sp, #0x37]
;   if (value < 0) {
7009b10a: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b10e: eeb5 0b40    	vcmp.f64	d0, #0
7009b112: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b116: d50d         	bpl	0x7009b134 <_ftoa+0x194> @ imm = #0x1a
7009b118: e7ff         	b	0x7009b11a <_ftoa+0x17a> @ imm = #-0x2
7009b11a: f04f 0001    	mov.w	r0, #0x1
;     negative = true;
7009b11e: f88d 0037    	strb.w	r0, [sp, #0x37]
;     value = 0 - value;
7009b122: ed9d 1b1a    	vldr	d1, [sp, #104]
7009b126: ed9f 0b94    	vldr	d0, [pc, #592]          @ 0x7009b378 <_ftoa+0x3d8>
7009b12a: ee30 0b41    	vsub.f64	d0, d0, d1
7009b12e: ed8d 0b1a    	vstr	d0, [sp, #104]
;   }
7009b132: e7ff         	b	0x7009b134 <_ftoa+0x194> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009b134: f89d 00a1    	ldrb.w	r0, [sp, #0xa1]
7009b138: ea4f 7040    	lsl.w	r0, r0, #0x1d
7009b13c: 2800         	cmp	r0, #0x0
7009b13e: d403         	bmi	0x7009b148 <_ftoa+0x1a8> @ imm = #0x6
7009b140: e7ff         	b	0x7009b142 <_ftoa+0x1a2> @ imm = #-0x2
7009b142: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009b144: 9026         	str	r0, [sp, #0x98]
;   }
7009b146: e7ff         	b	0x7009b148 <_ftoa+0x1a8> @ imm = #-0x2
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b148: e7ff         	b	0x7009b14a <_ftoa+0x1aa> @ imm = #-0x2
7009b14a: 9911         	ldr	r1, [sp, #0x44]
7009b14c: 2000         	movs	r0, #0x0
7009b14e: 291f         	cmp	r1, #0x1f
7009b150: 9007         	str	r0, [sp, #0x1c]
7009b152: d807         	bhi	0x7009b164 <_ftoa+0x1c4> @ imm = #0xe
7009b154: e7ff         	b	0x7009b156 <_ftoa+0x1b6> @ imm = #-0x2
7009b156: 9926         	ldr	r1, [sp, #0x98]
7009b158: 2000         	movs	r0, #0x0
7009b15a: 2909         	cmp	r1, #0x9
7009b15c: bf88         	it	hi
7009b15e: 2001         	movhi	r0, #0x1
7009b160: 9007         	str	r0, [sp, #0x1c]
7009b162: e7ff         	b	0x7009b164 <_ftoa+0x1c4> @ imm = #-0x2
7009b164: 9807         	ldr	r0, [sp, #0x1c]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b166: 07c0         	lsls	r0, r0, #0x1f
7009b168: b150         	cbz	r0, 0x7009b180 <_ftoa+0x1e0> @ imm = #0x14
7009b16a: e7ff         	b	0x7009b16c <_ftoa+0x1cc> @ imm = #-0x2
;     buf[len++] = '0';
7009b16c: 9a11         	ldr	r2, [sp, #0x44]
7009b16e: 1c50         	adds	r0, r2, #0x1
7009b170: 9011         	str	r0, [sp, #0x44]
7009b172: a912         	add	r1, sp, #0x48
7009b174: 2030         	movs	r0, #0x30
7009b176: 5488         	strb	r0, [r1, r2]
;     prec--;
7009b178: 9826         	ldr	r0, [sp, #0x98]
7009b17a: 3801         	subs	r0, #0x1
7009b17c: 9026         	str	r0, [sp, #0x98]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b17e: e7e4         	b	0x7009b14a <_ftoa+0x1aa> @ imm = #-0x38
;   int whole = (int)value;
7009b180: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b184: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b188: ed8d 0a0c    	vstr	s0, [sp, #48]
;   double tmp = (value - whole) * pow10[prec];
7009b18c: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b190: ed9d 1a0c    	vldr	s2, [sp, #48]
7009b194: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b198: ee30 0b41    	vsub.f64	d0, d0, d1
7009b19c: 9926         	ldr	r1, [sp, #0x98]
7009b19e: f641 00e0    	movw	r0, #0x18e0
7009b1a2: f2c7 000b    	movt	r0, #0x700b
7009b1a6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009b1aa: ed90 1b00    	vldr	d1, [r0]
7009b1ae: ee20 0b01    	vmul.f64	d0, d0, d1
7009b1b2: ed8d 0b0a    	vstr	d0, [sp, #40]
;   unsigned long frac = (unsigned long)tmp;
7009b1b6: ed9d 0b0a    	vldr	d0, [sp, #40]
7009b1ba: eebc 0bc0    	vcvt.u32.f64	s0, d0
7009b1be: ed8d 0a09    	vstr	s0, [sp, #36]
;   diff = tmp - frac;
7009b1c2: ed9d 0b0a    	vldr	d0, [sp, #40]
7009b1c6: ed9d 1a09    	vldr	s2, [sp, #36]
7009b1ca: eeb8 1b41    	vcvt.f64.u32	d1, s2
7009b1ce: ee30 0b41    	vsub.f64	d0, d0, d1
7009b1d2: ed8d 0b0e    	vstr	d0, [sp, #56]
;   if (diff > 0.5) {
7009b1d6: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b1da: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b1de: eeb4 0b41    	vcmp.f64	d0, d1
7009b1e2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b1e6: dd1e         	ble	0x7009b226 <_ftoa+0x286> @ imm = #0x3c
7009b1e8: e7ff         	b	0x7009b1ea <_ftoa+0x24a> @ imm = #-0x2
;     ++frac;
7009b1ea: 9809         	ldr	r0, [sp, #0x24]
7009b1ec: 3001         	adds	r0, #0x1
7009b1ee: 9009         	str	r0, [sp, #0x24]
;     if (frac >= pow10[prec]) {
7009b1f0: ed9d 0a09    	vldr	s0, [sp, #36]
7009b1f4: eeb8 0b40    	vcvt.f64.u32	d0, s0
7009b1f8: 9926         	ldr	r1, [sp, #0x98]
7009b1fa: f641 00e0    	movw	r0, #0x18e0
7009b1fe: f2c7 000b    	movt	r0, #0x700b
7009b202: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009b206: ed90 1b00    	vldr	d1, [r0]
7009b20a: eeb4 0b41    	vcmp.f64	d0, d1
7009b20e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b212: db07         	blt	0x7009b224 <_ftoa+0x284> @ imm = #0xe
7009b214: e7ff         	b	0x7009b216 <_ftoa+0x276> @ imm = #-0x2
7009b216: f04f 0000    	mov.w	r0, #0x0
;       frac = 0;
7009b21a: 9009         	str	r0, [sp, #0x24]
;       ++whole;
7009b21c: 980c         	ldr	r0, [sp, #0x30]
7009b21e: 3001         	adds	r0, #0x1
7009b220: 900c         	str	r0, [sp, #0x30]
;     }
7009b222: e7ff         	b	0x7009b224 <_ftoa+0x284> @ imm = #-0x2
;   }
7009b224: e018         	b	0x7009b258 <_ftoa+0x2b8> @ imm = #0x30
;   else if (diff < 0.5) {
7009b226: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b22a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b22e: eeb4 0b41    	vcmp.f64	d0, d1
7009b232: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b236: d501         	bpl	0x7009b23c <_ftoa+0x29c> @ imm = #0x2
7009b238: e7ff         	b	0x7009b23a <_ftoa+0x29a> @ imm = #-0x2
;   }
7009b23a: e00c         	b	0x7009b256 <_ftoa+0x2b6> @ imm = #0x18
;   else if ((frac == 0U) || (frac & 1U)) {
7009b23c: 9809         	ldr	r0, [sp, #0x24]
7009b23e: b128         	cbz	r0, 0x7009b24c <_ftoa+0x2ac> @ imm = #0xa
7009b240: e7ff         	b	0x7009b242 <_ftoa+0x2a2> @ imm = #-0x2
7009b242: f89d 0024    	ldrb.w	r0, [sp, #0x24]
7009b246: 07c0         	lsls	r0, r0, #0x1f
7009b248: b120         	cbz	r0, 0x7009b254 <_ftoa+0x2b4> @ imm = #0x8
7009b24a: e7ff         	b	0x7009b24c <_ftoa+0x2ac> @ imm = #-0x2
;     ++frac;
7009b24c: 9809         	ldr	r0, [sp, #0x24]
7009b24e: 3001         	adds	r0, #0x1
7009b250: 9009         	str	r0, [sp, #0x24]
;   }
7009b252: e7ff         	b	0x7009b254 <_ftoa+0x2b4> @ imm = #-0x2
7009b254: e7ff         	b	0x7009b256 <_ftoa+0x2b6> @ imm = #-0x2
7009b256: e7ff         	b	0x7009b258 <_ftoa+0x2b8> @ imm = #-0x2
;   if (prec == 0U) {
7009b258: 9826         	ldr	r0, [sp, #0x98]
7009b25a: bb48         	cbnz	r0, 0x7009b2b0 <_ftoa+0x310> @ imm = #0x52
7009b25c: e7ff         	b	0x7009b25e <_ftoa+0x2be> @ imm = #-0x2
;     diff = value - (double)whole;
7009b25e: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b262: ed9d 1a0c    	vldr	s2, [sp, #48]
7009b266: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b26a: ee30 0b41    	vsub.f64	d0, d0, d1
7009b26e: ed8d 0b0e    	vstr	d0, [sp, #56]
;     if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
7009b272: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b276: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b27a: eeb4 0b41    	vcmp.f64	d0, d1
7009b27e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b282: d50a         	bpl	0x7009b29a <_ftoa+0x2fa> @ imm = #0x14
7009b284: e7ff         	b	0x7009b286 <_ftoa+0x2e6> @ imm = #-0x2
7009b286: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b28a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b28e: eeb4 0b41    	vcmp.f64	d0, d1
7009b292: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b296: dd0a         	ble	0x7009b2ae <_ftoa+0x30e> @ imm = #0x14
7009b298: e7ff         	b	0x7009b29a <_ftoa+0x2fa> @ imm = #-0x2
7009b29a: f89d 0030    	ldrb.w	r0, [sp, #0x30]
7009b29e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009b2a2: b120         	cbz	r0, 0x7009b2ae <_ftoa+0x30e> @ imm = #0x8
7009b2a4: e7ff         	b	0x7009b2a6 <_ftoa+0x306> @ imm = #-0x2
;       ++whole;
7009b2a6: 980c         	ldr	r0, [sp, #0x30]
7009b2a8: 3001         	adds	r0, #0x1
7009b2aa: 900c         	str	r0, [sp, #0x30]
;     }
7009b2ac: e7ff         	b	0x7009b2ae <_ftoa+0x30e> @ imm = #-0x2
;   }
7009b2ae: e04d         	b	0x7009b34c <_ftoa+0x3ac> @ imm = #0x9a
;     unsigned int count = prec;
7009b2b0: 9826         	ldr	r0, [sp, #0x98]
7009b2b2: 9008         	str	r0, [sp, #0x20]
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b2b4: e7ff         	b	0x7009b2b6 <_ftoa+0x316> @ imm = #-0x2
7009b2b6: 9811         	ldr	r0, [sp, #0x44]
7009b2b8: 281f         	cmp	r0, #0x1f
7009b2ba: d821         	bhi	0x7009b300 <_ftoa+0x360> @ imm = #0x42
7009b2bc: e7ff         	b	0x7009b2be <_ftoa+0x31e> @ imm = #-0x2
;       --count;
7009b2be: 9808         	ldr	r0, [sp, #0x20]
7009b2c0: 3801         	subs	r0, #0x1
7009b2c2: 9008         	str	r0, [sp, #0x20]
;       buf[len++] = (char)(48U + (frac % 10U));
7009b2c4: 9809         	ldr	r0, [sp, #0x24]
7009b2c6: f64c 41cd    	movw	r1, #0xcccd
7009b2ca: f6cc 41cc    	movt	r1, #0xcccc
7009b2ce: fba0 3201    	umull	r3, r2, r0, r1
7009b2d2: ea4f 02d2    	lsr.w	r2, r2, #0x3
7009b2d6: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009b2da: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009b2de: f040 0030    	orr	r0, r0, #0x30
7009b2e2: 9b11         	ldr	r3, [sp, #0x44]
7009b2e4: 1c5a         	adds	r2, r3, #0x1
7009b2e6: 9211         	str	r2, [sp, #0x44]
7009b2e8: aa12         	add	r2, sp, #0x48
7009b2ea: 54d0         	strb	r0, [r2, r3]
;       if (!(frac /= 10U)) {
7009b2ec: 9809         	ldr	r0, [sp, #0x24]
7009b2ee: fba0 1001    	umull	r1, r0, r0, r1
7009b2f2: ea4f 00d0    	lsr.w	r0, r0, #0x3
7009b2f6: 9009         	str	r0, [sp, #0x24]
7009b2f8: b908         	cbnz	r0, 0x7009b2fe <_ftoa+0x35e> @ imm = #0x2
7009b2fa: e7ff         	b	0x7009b2fc <_ftoa+0x35c> @ imm = #-0x2
;         break;
7009b2fc: e000         	b	0x7009b300 <_ftoa+0x360> @ imm = #0x0
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b2fe: e7da         	b	0x7009b2b6 <_ftoa+0x316> @ imm = #-0x4c
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b300: e7ff         	b	0x7009b302 <_ftoa+0x362> @ imm = #-0x2
7009b302: 9911         	ldr	r1, [sp, #0x44]
7009b304: 2000         	movs	r0, #0x0
7009b306: 291f         	cmp	r1, #0x1f
7009b308: 9006         	str	r0, [sp, #0x18]
7009b30a: d808         	bhi	0x7009b31e <_ftoa+0x37e> @ imm = #0x10
7009b30c: e7ff         	b	0x7009b30e <_ftoa+0x36e> @ imm = #-0x2
7009b30e: 9808         	ldr	r0, [sp, #0x20]
7009b310: 1e41         	subs	r1, r0, #0x1
7009b312: 9108         	str	r1, [sp, #0x20]
7009b314: 2800         	cmp	r0, #0x0
7009b316: bf18         	it	ne
7009b318: 2001         	movne	r0, #0x1
7009b31a: 9006         	str	r0, [sp, #0x18]
7009b31c: e7ff         	b	0x7009b31e <_ftoa+0x37e> @ imm = #-0x2
7009b31e: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b320: 07c0         	lsls	r0, r0, #0x1f
7009b322: b138         	cbz	r0, 0x7009b334 <_ftoa+0x394> @ imm = #0xe
7009b324: e7ff         	b	0x7009b326 <_ftoa+0x386> @ imm = #-0x2
;       buf[len++] = '0';
7009b326: 9a11         	ldr	r2, [sp, #0x44]
7009b328: 1c50         	adds	r0, r2, #0x1
7009b32a: 9011         	str	r0, [sp, #0x44]
7009b32c: a912         	add	r1, sp, #0x48
7009b32e: 2030         	movs	r0, #0x30
7009b330: 5488         	strb	r0, [r1, r2]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b332: e7e6         	b	0x7009b302 <_ftoa+0x362> @ imm = #-0x34
;     if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b334: 9811         	ldr	r0, [sp, #0x44]
7009b336: 281f         	cmp	r0, #0x1f
7009b338: d807         	bhi	0x7009b34a <_ftoa+0x3aa> @ imm = #0xe
7009b33a: e7ff         	b	0x7009b33c <_ftoa+0x39c> @ imm = #-0x2
;       buf[len++] = '.';
7009b33c: 9a11         	ldr	r2, [sp, #0x44]
7009b33e: 1c50         	adds	r0, r2, #0x1
7009b340: 9011         	str	r0, [sp, #0x44]
7009b342: a912         	add	r1, sp, #0x48
7009b344: 202e         	movs	r0, #0x2e
7009b346: 5488         	strb	r0, [r1, r2]
;     }
7009b348: e7ff         	b	0x7009b34a <_ftoa+0x3aa> @ imm = #-0x2
7009b34a: e7ff         	b	0x7009b34c <_ftoa+0x3ac> @ imm = #-0x2
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b34c: e7ff         	b	0x7009b34e <_ftoa+0x3ae> @ imm = #-0x2
7009b34e: 9811         	ldr	r0, [sp, #0x44]
7009b350: 281f         	cmp	r0, #0x1f
7009b352: d835         	bhi	0x7009b3c0 <_ftoa+0x420> @ imm = #0x6a
7009b354: e014         	b	0x7009b380 <_ftoa+0x3e0> @ imm = #0x28
7009b356: bf00         	nop
7009b358: ff ff ff ff  	.word	0xffffffff
7009b35c: ff ff ef ff  	.word	0xffefffff
7009b360: ff ff ff ff  	.word	0xffffffff
7009b364: ff ff ef 7f  	.word	0x7fefffff
7009b368: 00 00 00 00  	.word	0x00000000
7009b36c: 65 cd cd 41  	.word	0x41cdcd65
7009b370: 00 00 00 00  	.word	0x00000000
7009b374: 65 cd cd c1  	.word	0xc1cdcd65
7009b378: 00 00 00 00  	.word	0x00000000
7009b37c: 00 00 00 00  	.word	0x00000000
;     buf[len++] = (char)(48 + (whole % 10));
7009b380: 980c         	ldr	r0, [sp, #0x30]
7009b382: f246 6167    	movw	r1, #0x6667
7009b386: f2c6 6166    	movt	r1, #0x6666
7009b38a: fb50 f301    	smmul	r3, r0, r1
7009b38e: 089a         	lsrs	r2, r3, #0x2
7009b390: eb02 72d3    	add.w	r2, r2, r3, lsr #31
7009b394: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009b398: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009b39c: 3030         	adds	r0, #0x30
7009b39e: 9b11         	ldr	r3, [sp, #0x44]
7009b3a0: 1c5a         	adds	r2, r3, #0x1
7009b3a2: 9211         	str	r2, [sp, #0x44]
7009b3a4: aa12         	add	r2, sp, #0x48
7009b3a6: 54d0         	strb	r0, [r2, r3]
;     if (!(whole /= 10)) {
7009b3a8: 980c         	ldr	r0, [sp, #0x30]
7009b3aa: fb50 f101    	smmul	r1, r0, r1
7009b3ae: ea4f 00a1    	asr.w	r0, r1, #0x2
7009b3b2: eb00 70d1    	add.w	r0, r0, r1, lsr #31
7009b3b6: 900c         	str	r0, [sp, #0x30]
7009b3b8: b908         	cbnz	r0, 0x7009b3be <_ftoa+0x41e> @ imm = #0x2
7009b3ba: e7ff         	b	0x7009b3bc <_ftoa+0x41c> @ imm = #-0x2
;       break;
7009b3bc: e000         	b	0x7009b3c0 <_ftoa+0x420> @ imm = #0x0
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b3be: e7c6         	b	0x7009b34e <_ftoa+0x3ae> @ imm = #-0x74
;   if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
7009b3c0: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b3c4: 0780         	lsls	r0, r0, #0x1e
7009b3c6: 2800         	cmp	r0, #0x0
7009b3c8: d432         	bmi	0x7009b430 <_ftoa+0x490> @ imm = #0x64
7009b3ca: e7ff         	b	0x7009b3cc <_ftoa+0x42c> @ imm = #-0x2
7009b3cc: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b3d0: 07c0         	lsls	r0, r0, #0x1f
7009b3d2: b368         	cbz	r0, 0x7009b430 <_ftoa+0x490> @ imm = #0x5a
7009b3d4: e7ff         	b	0x7009b3d6 <_ftoa+0x436> @ imm = #-0x2
;     if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009b3d6: 9827         	ldr	r0, [sp, #0x9c]
7009b3d8: b178         	cbz	r0, 0x7009b3fa <_ftoa+0x45a> @ imm = #0x1e
7009b3da: e7ff         	b	0x7009b3dc <_ftoa+0x43c> @ imm = #-0x2
7009b3dc: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009b3e0: 07c0         	lsls	r0, r0, #0x1f
7009b3e2: b930         	cbnz	r0, 0x7009b3f2 <_ftoa+0x452> @ imm = #0xc
7009b3e4: e7ff         	b	0x7009b3e6 <_ftoa+0x446> @ imm = #-0x2
7009b3e6: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b3ea: f010 0f0c    	tst.w	r0, #0xc
7009b3ee: d004         	beq	0x7009b3fa <_ftoa+0x45a> @ imm = #0x8
7009b3f0: e7ff         	b	0x7009b3f2 <_ftoa+0x452> @ imm = #-0x2
;       width--;
7009b3f2: 9827         	ldr	r0, [sp, #0x9c]
7009b3f4: 3801         	subs	r0, #0x1
7009b3f6: 9027         	str	r0, [sp, #0x9c]
;     }
7009b3f8: e7ff         	b	0x7009b3fa <_ftoa+0x45a> @ imm = #-0x2
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b3fa: e7ff         	b	0x7009b3fc <_ftoa+0x45c> @ imm = #-0x2
7009b3fc: 9911         	ldr	r1, [sp, #0x44]
7009b3fe: 9a27         	ldr	r2, [sp, #0x9c]
7009b400: 2000         	movs	r0, #0x0
7009b402: 4291         	cmp	r1, r2
7009b404: 9005         	str	r0, [sp, #0x14]
7009b406: d207         	bhs	0x7009b418 <_ftoa+0x478> @ imm = #0xe
7009b408: e7ff         	b	0x7009b40a <_ftoa+0x46a> @ imm = #-0x2
7009b40a: 9911         	ldr	r1, [sp, #0x44]
7009b40c: 2000         	movs	r0, #0x0
7009b40e: 2920         	cmp	r1, #0x20
7009b410: bf38         	it	lo
7009b412: 2001         	movlo	r0, #0x1
7009b414: 9005         	str	r0, [sp, #0x14]
7009b416: e7ff         	b	0x7009b418 <_ftoa+0x478> @ imm = #-0x2
7009b418: 9805         	ldr	r0, [sp, #0x14]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b41a: 07c0         	lsls	r0, r0, #0x1f
7009b41c: b138         	cbz	r0, 0x7009b42e <_ftoa+0x48e> @ imm = #0xe
7009b41e: e7ff         	b	0x7009b420 <_ftoa+0x480> @ imm = #-0x2
;       buf[len++] = '0';
7009b420: 9a11         	ldr	r2, [sp, #0x44]
7009b422: 1c50         	adds	r0, r2, #0x1
7009b424: 9011         	str	r0, [sp, #0x44]
7009b426: a912         	add	r1, sp, #0x48
7009b428: 2030         	movs	r0, #0x30
7009b42a: 5488         	strb	r0, [r1, r2]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b42c: e7e6         	b	0x7009b3fc <_ftoa+0x45c> @ imm = #-0x34
;   }
7009b42e: e7ff         	b	0x7009b430 <_ftoa+0x490> @ imm = #-0x2
;   if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b430: 9811         	ldr	r0, [sp, #0x44]
7009b432: 281f         	cmp	r0, #0x1f
7009b434: d829         	bhi	0x7009b48a <_ftoa+0x4ea> @ imm = #0x52
7009b436: e7ff         	b	0x7009b438 <_ftoa+0x498> @ imm = #-0x2
;     if (negative) {
7009b438: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009b43c: 07c0         	lsls	r0, r0, #0x1f
7009b43e: b138         	cbz	r0, 0x7009b450 <_ftoa+0x4b0> @ imm = #0xe
7009b440: e7ff         	b	0x7009b442 <_ftoa+0x4a2> @ imm = #-0x2
;       buf[len++] = '-';
7009b442: 9a11         	ldr	r2, [sp, #0x44]
7009b444: 1c50         	adds	r0, r2, #0x1
7009b446: 9011         	str	r0, [sp, #0x44]
7009b448: a912         	add	r1, sp, #0x48
7009b44a: 202d         	movs	r0, #0x2d
7009b44c: 5488         	strb	r0, [r1, r2]
;     }
7009b44e: e01b         	b	0x7009b488 <_ftoa+0x4e8> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009b450: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b454: 0740         	lsls	r0, r0, #0x1d
7009b456: 2800         	cmp	r0, #0x0
7009b458: d507         	bpl	0x7009b46a <_ftoa+0x4ca> @ imm = #0xe
7009b45a: e7ff         	b	0x7009b45c <_ftoa+0x4bc> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009b45c: 9a11         	ldr	r2, [sp, #0x44]
7009b45e: 1c50         	adds	r0, r2, #0x1
7009b460: 9011         	str	r0, [sp, #0x44]
7009b462: a912         	add	r1, sp, #0x48
7009b464: 202b         	movs	r0, #0x2b
7009b466: 5488         	strb	r0, [r1, r2]
;     }
7009b468: e00d         	b	0x7009b486 <_ftoa+0x4e6> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009b46a: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b46e: 0700         	lsls	r0, r0, #0x1c
7009b470: 2800         	cmp	r0, #0x0
7009b472: d507         	bpl	0x7009b484 <_ftoa+0x4e4> @ imm = #0xe
7009b474: e7ff         	b	0x7009b476 <_ftoa+0x4d6> @ imm = #-0x2
;       buf[len++] = ' ';
7009b476: 9a11         	ldr	r2, [sp, #0x44]
7009b478: 1c50         	adds	r0, r2, #0x1
7009b47a: 9011         	str	r0, [sp, #0x44]
7009b47c: a912         	add	r1, sp, #0x48
7009b47e: 2020         	movs	r0, #0x20
7009b480: 5488         	strb	r0, [r1, r2]
;     }
7009b482: e7ff         	b	0x7009b484 <_ftoa+0x4e4> @ imm = #-0x2
7009b484: e7ff         	b	0x7009b486 <_ftoa+0x4e6> @ imm = #-0x2
7009b486: e7ff         	b	0x7009b488 <_ftoa+0x4e8> @ imm = #-0x2
;   }
7009b488: e7ff         	b	0x7009b48a <_ftoa+0x4ea> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009b48a: 9820         	ldr	r0, [sp, #0x80]
7009b48c: 991f         	ldr	r1, [sp, #0x7c]
7009b48e: 9a1e         	ldr	r2, [sp, #0x78]
7009b490: 9b1d         	ldr	r3, [sp, #0x74]
7009b492: f8dd c044    	ldr.w	r12, [sp, #0x44]
7009b496: 9c27         	ldr	r4, [sp, #0x9c]
7009b498: 9d28         	ldr	r5, [sp, #0xa0]
7009b49a: 46ee         	mov	lr, sp
7009b49c: f8ce 500c    	str.w	r5, [lr, #0xc]
7009b4a0: f8ce 4008    	str.w	r4, [lr, #0x8]
7009b4a4: f8ce c004    	str.w	r12, [lr, #0x4]
7009b4a8: f10d 0c48    	add.w	r12, sp, #0x48
7009b4ac: f8ce c000    	str.w	r12, [lr]
7009b4b0: f00c f80e    	bl	0x700a74d0 <_out_rev>   @ imm = #0xc01c
7009b4b4: 9021         	str	r0, [sp, #0x84]
7009b4b6: e7ff         	b	0x7009b4b8 <_ftoa+0x518> @ imm = #-0x2
; }
7009b4b8: 9821         	ldr	r0, [sp, #0x84]
7009b4ba: b022         	add	sp, #0x88
7009b4bc: bd70         	pop	{r4, r5, r6, pc}
7009b4be: 0000         	movs	r0, r0

7009b4c0 <_etoa>:
; {
7009b4c0: b570         	push	{r4, r5, r6, lr}
7009b4c2: b0a8         	sub	sp, #0xa0
7009b4c4: f8dd c0b8    	ldr.w	r12, [sp, #0xb8]
7009b4c8: f8dd c0b4    	ldr.w	r12, [sp, #0xb4]
7009b4cc: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b4d0: 9026         	str	r0, [sp, #0x98]
7009b4d2: 9125         	str	r1, [sp, #0x94]
7009b4d4: 9224         	str	r2, [sp, #0x90]
7009b4d6: 9323         	str	r3, [sp, #0x8c]
7009b4d8: ed8d 0b20    	vstr	d0, [sp, #128]
;   if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
7009b4dc: ed9d 0b20    	vldr	d0, [sp, #128]
7009b4e0: eeb4 0b40    	vcmp.f64	d0, d0
7009b4e4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b4e8: d614         	bvs	0x7009b514 <_etoa+0x54> @ imm = #0x28
7009b4ea: e7ff         	b	0x7009b4ec <_etoa+0x2c> @ imm = #-0x2
7009b4ec: ed9d 0b20    	vldr	d0, [sp, #128]
7009b4f0: ed9f 1bdb    	vldr	d1, [pc, #876]          @ 0x7009b860 <_etoa+0x3a0>
7009b4f4: eeb4 0b41    	vcmp.f64	d0, d1
7009b4f8: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b4fc: dc0a         	bgt	0x7009b514 <_etoa+0x54> @ imm = #0x14
7009b4fe: e7ff         	b	0x7009b500 <_etoa+0x40> @ imm = #-0x2
7009b500: ed9d 0b20    	vldr	d0, [sp, #128]
7009b504: ed9f 1bd8    	vldr	d1, [pc, #864]          @ 0x7009b868 <_etoa+0x3a8>
7009b508: eeb4 0b41    	vcmp.f64	d0, d1
7009b50c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b510: d515         	bpl	0x7009b53e <_etoa+0x7e> @ imm = #0x2a
7009b512: e7ff         	b	0x7009b514 <_etoa+0x54> @ imm = #-0x2
;     return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009b514: 9826         	ldr	r0, [sp, #0x98]
7009b516: 9925         	ldr	r1, [sp, #0x94]
7009b518: 9a24         	ldr	r2, [sp, #0x90]
7009b51a: 9b23         	ldr	r3, [sp, #0x8c]
7009b51c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b520: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b524: 9c2d         	ldr	r4, [sp, #0xb4]
7009b526: 9d2e         	ldr	r5, [sp, #0xb8]
7009b528: 46ee         	mov	lr, sp
7009b52a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b52e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b532: f8ce c000    	str.w	r12, [lr]
7009b536: f7ff fd33    	bl	0x7009afa0 <_ftoa>      @ imm = #-0x59a
7009b53a: 9027         	str	r0, [sp, #0x9c]
7009b53c: e1d8         	b	0x7009b8f0 <_etoa+0x430> @ imm = #0x3b0
;   const bool negative = value < 0;
7009b53e: ed9d 0b20    	vldr	d0, [sp, #128]
7009b542: f04f 0000    	mov.w	r0, #0x0
7009b546: eeb5 0b40    	vcmp.f64	d0, #0
7009b54a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b54e: bf48         	it	mi
7009b550: 2001         	movmi	r0, #0x1
7009b552: f88d 007f    	strb.w	r0, [sp, #0x7f]
;   if (negative) {
7009b556: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009b55a: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009b55e: b138         	cbz	r0, 0x7009b570 <_etoa+0xb0> @ imm = #0xe
7009b560: e7ff         	b	0x7009b562 <_etoa+0xa2> @ imm = #-0x2
;     value = -value;
7009b562: ed9d 0b20    	vldr	d0, [sp, #128]
7009b566: eeb1 0b40    	vneg.f64	d0, d0
7009b56a: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009b56e: e7ff         	b	0x7009b570 <_etoa+0xb0> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009b570: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b574: 0740         	lsls	r0, r0, #0x1d
7009b576: 2800         	cmp	r0, #0x0
7009b578: d403         	bmi	0x7009b582 <_etoa+0xc2> @ imm = #0x6
7009b57a: e7ff         	b	0x7009b57c <_etoa+0xbc> @ imm = #-0x2
7009b57c: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009b57e: 902c         	str	r0, [sp, #0xb0]
;   }
7009b580: e7ff         	b	0x7009b582 <_etoa+0xc2> @ imm = #-0x2
;   conv.F = value;
7009b582: ed9d 0b20    	vldr	d0, [sp, #128]
7009b586: ed8d 0b1c    	vstr	d0, [sp, #112]
;   int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
7009b58a: 981d         	ldr	r0, [sp, #0x74]
7009b58c: f3c0 500a    	ubfx	r0, r0, #0x14, #0xb
7009b590: f2a0 30ff    	subw	r0, r0, #0x3ff
7009b594: 901b         	str	r0, [sp, #0x6c]
;   conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
7009b596: 981d         	ldr	r0, [sp, #0x74]
7009b598: f240 31ff    	movw	r1, #0x3ff
7009b59c: f361 501f    	bfi	r0, r1, #20, #12
7009b5a0: 901d         	str	r0, [sp, #0x74]
;   int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
7009b5a2: ed9d 0a1b    	vldr	s0, [sp, #108]
7009b5a6: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b5aa: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009b8f8 <_etoa+0x438>
7009b5ae: ee20 0b01    	vmul.f64	d0, d0, d1
7009b5b2: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009b900 <_etoa+0x440>
7009b5b6: ee30 1b01    	vadd.f64	d1, d0, d1
7009b5ba: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b5be: eebf 2b08    	vmov.f64	d2, #-1.500000e+00
7009b5c2: ee30 0b02    	vadd.f64	d0, d0, d2
7009b5c6: ed9f 2bd0    	vldr	d2, [pc, #832]          @ 0x7009b908 <_etoa+0x448>
7009b5ca: ee20 0b02    	vmul.f64	d0, d0, d2
7009b5ce: ee30 0b01    	vadd.f64	d0, d0, d1
7009b5d2: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b5d6: ed8d 0a1a    	vstr	s0, [sp, #104]
;   exp2 = (int)(expval * 3.321928094887362 + 0.5);
7009b5da: ed9d 0a1a    	vldr	s0, [sp, #104]
7009b5de: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b5e2: ed9f 1bcb    	vldr	d1, [pc, #812]          @ 0x7009b910 <_etoa+0x450>
7009b5e6: ee20 0b01    	vmul.f64	d0, d0, d1
7009b5ea: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b5ee: ee30 0b01    	vadd.f64	d0, d0, d1
7009b5f2: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b5f6: ed8d 0a1b    	vstr	s0, [sp, #108]
;   const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
7009b5fa: ed9d 0a1a    	vldr	s0, [sp, #104]
7009b5fe: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b602: ed9d 1a1b    	vldr	s2, [sp, #108]
7009b606: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b60a: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009b918 <_etoa+0x458>
7009b60e: ee21 1b02    	vmul.f64	d1, d1, d2
7009b612: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009b920 <_etoa+0x460>
7009b616: ee20 0b02    	vmul.f64	d0, d0, d2
7009b61a: ee30 0b01    	vadd.f64	d0, d0, d1
7009b61e: ed8d 0b18    	vstr	d0, [sp, #96]
;   const double z2 = z * z;
7009b622: ed9d 0b18    	vldr	d0, [sp, #96]
7009b626: ee20 0b00    	vmul.f64	d0, d0, d0
7009b62a: ed8d 0b16    	vstr	d0, [sp, #88]
;   conv.U = (uint64_t)(exp2 + 1023) << 52U;
7009b62e: 981b         	ldr	r0, [sp, #0x6c]
7009b630: f200 30ff    	addw	r0, r0, #0x3ff
7009b634: 0500         	lsls	r0, r0, #0x14
7009b636: 2100         	movs	r1, #0x0
7009b638: 911c         	str	r1, [sp, #0x70]
7009b63a: 901d         	str	r0, [sp, #0x74]
;   conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
7009b63c: ed9d 2b18    	vldr	d2, [sp, #96]
7009b640: ee32 0b02    	vadd.f64	d0, d2, d2
7009b644: eeb0 1b00    	vmov.f64	d1, #2.000000e+00
7009b648: ee31 1b42    	vsub.f64	d1, d1, d2
7009b64c: ed9d 2b16    	vldr	d2, [sp, #88]
7009b650: eeb2 3b0c    	vmov.f64	d3, #1.400000e+01
7009b654: ee82 3b03    	vdiv.f64	d3, d2, d3
7009b658: eeb2 4b04    	vmov.f64	d4, #1.000000e+01
7009b65c: ee33 3b04    	vadd.f64	d3, d3, d4
7009b660: ee82 3b03    	vdiv.f64	d3, d2, d3
7009b664: eeb1 4b08    	vmov.f64	d4, #6.000000e+00
7009b668: ee33 3b04    	vadd.f64	d3, d3, d4
7009b66c: ee82 2b03    	vdiv.f64	d2, d2, d3
7009b670: ee31 1b02    	vadd.f64	d1, d1, d2
7009b674: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b678: eeb7 1b00    	vmov.f64	d1, #1.000000e+00
7009b67c: ee30 1b01    	vadd.f64	d1, d0, d1
7009b680: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b684: ee20 0b01    	vmul.f64	d0, d0, d1
7009b688: ed8d 0b1c    	vstr	d0, [sp, #112]
;   if (value < conv.F) {
7009b68c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b690: ed9d 1b1c    	vldr	d1, [sp, #112]
7009b694: eeb4 0b41    	vcmp.f64	d0, d1
7009b698: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b69c: d50c         	bpl	0x7009b6b8 <_etoa+0x1f8> @ imm = #0x18
7009b69e: e7ff         	b	0x7009b6a0 <_etoa+0x1e0> @ imm = #-0x2
;     expval--;
7009b6a0: 981a         	ldr	r0, [sp, #0x68]
7009b6a2: 3801         	subs	r0, #0x1
7009b6a4: 901a         	str	r0, [sp, #0x68]
;     conv.F /= 10;
7009b6a6: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b6aa: eeb2 1b04    	vmov.f64	d1, #1.000000e+01
7009b6ae: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b6b2: ed8d 0b1c    	vstr	d0, [sp, #112]
;   }
7009b6b6: e7ff         	b	0x7009b6b8 <_etoa+0x1f8> @ imm = #-0x2
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009b6b8: 991a         	ldr	r1, [sp, #0x68]
7009b6ba: f04f 0000    	mov.w	r0, #0x0
7009b6be: 2963         	cmp	r1, #0x63
7009b6c0: 9012         	str	r0, [sp, #0x48]
7009b6c2: dc08         	bgt	0x7009b6d6 <_etoa+0x216> @ imm = #0x10
7009b6c4: e7ff         	b	0x7009b6c6 <_etoa+0x206> @ imm = #-0x2
7009b6c6: 991a         	ldr	r1, [sp, #0x68]
7009b6c8: 2000         	movs	r0, #0x0
7009b6ca: f111 0f64    	cmn.w	r1, #0x64
7009b6ce: bfc8         	it	gt
7009b6d0: 2001         	movgt	r0, #0x1
7009b6d2: 9012         	str	r0, [sp, #0x48]
7009b6d4: e7ff         	b	0x7009b6d6 <_etoa+0x216> @ imm = #-0x2
7009b6d6: 9812         	ldr	r0, [sp, #0x48]
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009b6d8: 07c1         	lsls	r1, r0, #0x1f
7009b6da: 2005         	movs	r0, #0x5
7009b6dc: 2900         	cmp	r1, #0x0
7009b6de: bf18         	it	ne
7009b6e0: 2004         	movne	r0, #0x4
7009b6e2: 9015         	str	r0, [sp, #0x54]
;   if (flags & FLAGS_ADAPT_EXP) {
7009b6e4: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b6e8: ea4f 7000    	lsl.w	r0, r0, #0x1c
7009b6ec: 2800         	cmp	r0, #0x0
7009b6ee: d539         	bpl	0x7009b764 <_etoa+0x2a4> @ imm = #0x72
7009b6f0: e7ff         	b	0x7009b6f2 <_etoa+0x232> @ imm = #-0x2
;     if ((value >= 1e-4) && (value < 1e6)) {
7009b6f2: ed9d 0b20    	vldr	d0, [sp, #128]
7009b6f6: ed9f 1b8c    	vldr	d1, [pc, #560]          @ 0x7009b928 <_etoa+0x468>
7009b6fa: eeb4 0b41    	vcmp.f64	d0, d1
7009b6fe: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b702: db20         	blt	0x7009b746 <_etoa+0x286> @ imm = #0x40
7009b704: e7ff         	b	0x7009b706 <_etoa+0x246> @ imm = #-0x2
7009b706: ed9d 0b20    	vldr	d0, [sp, #128]
7009b70a: ed9f 1b89    	vldr	d1, [pc, #548]          @ 0x7009b930 <_etoa+0x470>
7009b70e: eeb4 0b41    	vcmp.f64	d0, d1
7009b712: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b716: d516         	bpl	0x7009b746 <_etoa+0x286> @ imm = #0x2c
7009b718: e7ff         	b	0x7009b71a <_etoa+0x25a> @ imm = #-0x2
;       if ((int)prec > expval) {
7009b71a: 982c         	ldr	r0, [sp, #0xb0]
7009b71c: 991a         	ldr	r1, [sp, #0x68]
7009b71e: 4288         	cmp	r0, r1
7009b720: dd06         	ble	0x7009b730 <_etoa+0x270> @ imm = #0xc
7009b722: e7ff         	b	0x7009b724 <_etoa+0x264> @ imm = #-0x2
;         prec = (unsigned)((int)prec - expval - 1);
7009b724: 992c         	ldr	r1, [sp, #0xb0]
7009b726: 981a         	ldr	r0, [sp, #0x68]
7009b728: 43c0         	mvns	r0, r0
7009b72a: 4408         	add	r0, r1
7009b72c: 902c         	str	r0, [sp, #0xb0]
;       }
7009b72e: e002         	b	0x7009b736 <_etoa+0x276> @ imm = #0x4
7009b730: 2000         	movs	r0, #0x0
;         prec = 0;
7009b732: 902c         	str	r0, [sp, #0xb0]
7009b734: e7ff         	b	0x7009b736 <_etoa+0x276> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
7009b736: 982e         	ldr	r0, [sp, #0xb8]
7009b738: f440 6080    	orr	r0, r0, #0x400
7009b73c: 902e         	str	r0, [sp, #0xb8]
7009b73e: 2000         	movs	r0, #0x0
;       minwidth = 0U;
7009b740: 9015         	str	r0, [sp, #0x54]
;       expval   = 0;
7009b742: 901a         	str	r0, [sp, #0x68]
;     }
7009b744: e00d         	b	0x7009b762 <_etoa+0x2a2> @ imm = #0x1a
;       if ((prec > 0) && (flags & FLAGS_PRECISION)) {
7009b746: 982c         	ldr	r0, [sp, #0xb0]
7009b748: b150         	cbz	r0, 0x7009b760 <_etoa+0x2a0> @ imm = #0x14
7009b74a: e7ff         	b	0x7009b74c <_etoa+0x28c> @ imm = #-0x2
7009b74c: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b750: 0740         	lsls	r0, r0, #0x1d
7009b752: 2800         	cmp	r0, #0x0
7009b754: d504         	bpl	0x7009b760 <_etoa+0x2a0> @ imm = #0x8
7009b756: e7ff         	b	0x7009b758 <_etoa+0x298> @ imm = #-0x2
;         --prec;
7009b758: 982c         	ldr	r0, [sp, #0xb0]
7009b75a: 3801         	subs	r0, #0x1
7009b75c: 902c         	str	r0, [sp, #0xb0]
;       }
7009b75e: e7ff         	b	0x7009b760 <_etoa+0x2a0> @ imm = #-0x2
7009b760: e7ff         	b	0x7009b762 <_etoa+0x2a2> @ imm = #-0x2
;   }
7009b762: e7ff         	b	0x7009b764 <_etoa+0x2a4> @ imm = #-0x2
;   unsigned int fwidth = width;
7009b764: 982d         	ldr	r0, [sp, #0xb4]
7009b766: 9014         	str	r0, [sp, #0x50]
;   if (width > minwidth) {
7009b768: 982d         	ldr	r0, [sp, #0xb4]
7009b76a: 9915         	ldr	r1, [sp, #0x54]
7009b76c: 4288         	cmp	r0, r1
7009b76e: d905         	bls	0x7009b77c <_etoa+0x2bc> @ imm = #0xa
7009b770: e7ff         	b	0x7009b772 <_etoa+0x2b2> @ imm = #-0x2
;     fwidth -= minwidth;
7009b772: 9915         	ldr	r1, [sp, #0x54]
7009b774: 9814         	ldr	r0, [sp, #0x50]
7009b776: 1a40         	subs	r0, r0, r1
7009b778: 9014         	str	r0, [sp, #0x50]
;   } else {
7009b77a: e002         	b	0x7009b782 <_etoa+0x2c2> @ imm = #0x4
7009b77c: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009b77e: 9014         	str	r0, [sp, #0x50]
7009b780: e7ff         	b	0x7009b782 <_etoa+0x2c2> @ imm = #-0x2
;   if ((flags & FLAGS_LEFT) && minwidth) {
7009b782: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009b786: 0780         	lsls	r0, r0, #0x1e
7009b788: 2800         	cmp	r0, #0x0
7009b78a: d506         	bpl	0x7009b79a <_etoa+0x2da> @ imm = #0xc
7009b78c: e7ff         	b	0x7009b78e <_etoa+0x2ce> @ imm = #-0x2
7009b78e: 9815         	ldr	r0, [sp, #0x54]
7009b790: b118         	cbz	r0, 0x7009b79a <_etoa+0x2da> @ imm = #0x6
7009b792: e7ff         	b	0x7009b794 <_etoa+0x2d4> @ imm = #-0x2
7009b794: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009b796: 9014         	str	r0, [sp, #0x50]
;   }
7009b798: e7ff         	b	0x7009b79a <_etoa+0x2da> @ imm = #-0x2
;   if (expval) {
7009b79a: 981a         	ldr	r0, [sp, #0x68]
7009b79c: b148         	cbz	r0, 0x7009b7b2 <_etoa+0x2f2> @ imm = #0x12
7009b79e: e7ff         	b	0x7009b7a0 <_etoa+0x2e0> @ imm = #-0x2
;     value /= conv.F;
7009b7a0: ed9d 1b1c    	vldr	d1, [sp, #112]
7009b7a4: ed9d 0b20    	vldr	d0, [sp, #128]
7009b7a8: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b7ac: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009b7b0: e7ff         	b	0x7009b7b2 <_etoa+0x2f2> @ imm = #-0x2
;   const size_t start_idx = idx;
7009b7b2: 9824         	ldr	r0, [sp, #0x90]
7009b7b4: 9013         	str	r0, [sp, #0x4c]
;   idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
7009b7b6: 9826         	ldr	r0, [sp, #0x98]
7009b7b8: 900e         	str	r0, [sp, #0x38]
7009b7ba: 9825         	ldr	r0, [sp, #0x94]
7009b7bc: 900f         	str	r0, [sp, #0x3c]
7009b7be: 9824         	ldr	r0, [sp, #0x90]
7009b7c0: 9010         	str	r0, [sp, #0x40]
7009b7c2: 9823         	ldr	r0, [sp, #0x8c]
7009b7c4: 9011         	str	r0, [sp, #0x44]
7009b7c6: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009b7ca: 07c0         	lsls	r0, r0, #0x1f
7009b7cc: b138         	cbz	r0, 0x7009b7de <_etoa+0x31e> @ imm = #0xe
7009b7ce: e7ff         	b	0x7009b7d0 <_etoa+0x310> @ imm = #-0x2
7009b7d0: ed9d 0b20    	vldr	d0, [sp, #128]
7009b7d4: eeb1 0b40    	vneg.f64	d0, d0
7009b7d8: ed8d 0b0c    	vstr	d0, [sp, #48]
7009b7dc: e004         	b	0x7009b7e8 <_etoa+0x328> @ imm = #0x8
7009b7de: ed9d 0b20    	vldr	d0, [sp, #128]
7009b7e2: ed8d 0b0c    	vstr	d0, [sp, #48]
7009b7e6: e7ff         	b	0x7009b7e8 <_etoa+0x328> @ imm = #-0x2
7009b7e8: 9b11         	ldr	r3, [sp, #0x44]
7009b7ea: 9a10         	ldr	r2, [sp, #0x40]
7009b7ec: 990f         	ldr	r1, [sp, #0x3c]
7009b7ee: 980e         	ldr	r0, [sp, #0x38]
7009b7f0: ed9d 0b0c    	vldr	d0, [sp, #48]
7009b7f4: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b7f8: 9c14         	ldr	r4, [sp, #0x50]
7009b7fa: f8dd e0b8    	ldr.w	lr, [sp, #0xb8]
7009b7fe: f42e 6500    	bic	r5, lr, #0x800
7009b802: 46ee         	mov	lr, sp
7009b804: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b808: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b80c: f8ce c000    	str.w	r12, [lr]
7009b810: f7ff fbc6    	bl	0x7009afa0 <_ftoa>      @ imm = #-0x874
7009b814: 9024         	str	r0, [sp, #0x90]
;   if (minwidth) {
7009b816: 9815         	ldr	r0, [sp, #0x54]
7009b818: 2800         	cmp	r0, #0x0
7009b81a: d066         	beq	0x7009b8ea <_etoa+0x42a> @ imm = #0xcc
7009b81c: e7ff         	b	0x7009b81e <_etoa+0x35e> @ imm = #-0x2
;     out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
7009b81e: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b822: 982e         	ldr	r0, [sp, #0xb8]
7009b824: 0681         	lsls	r1, r0, #0x1a
7009b826: 2065         	movs	r0, #0x65
7009b828: 2900         	cmp	r1, #0x0
7009b82a: bf48         	it	mi
7009b82c: 2045         	movmi	r0, #0x45
7009b82e: 9925         	ldr	r1, [sp, #0x94]
7009b830: 9a24         	ldr	r2, [sp, #0x90]
7009b832: 1c53         	adds	r3, r2, #0x1
7009b834: 9324         	str	r3, [sp, #0x90]
7009b836: 9b23         	ldr	r3, [sp, #0x8c]
7009b838: 47e0         	blx	r12
;     idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
7009b83a: 9826         	ldr	r0, [sp, #0x98]
7009b83c: 9008         	str	r0, [sp, #0x20]
7009b83e: 9825         	ldr	r0, [sp, #0x94]
7009b840: 9009         	str	r0, [sp, #0x24]
7009b842: 9824         	ldr	r0, [sp, #0x90]
7009b844: 900a         	str	r0, [sp, #0x28]
7009b846: 9823         	ldr	r0, [sp, #0x8c]
7009b848: 900b         	str	r0, [sp, #0x2c]
7009b84a: 981a         	ldr	r0, [sp, #0x68]
7009b84c: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009b850: dc0e         	bgt	0x7009b870 <_etoa+0x3b0> @ imm = #0x1c
7009b852: e7ff         	b	0x7009b854 <_etoa+0x394> @ imm = #-0x2
7009b854: 981a         	ldr	r0, [sp, #0x68]
7009b856: 4240         	rsbs	r0, r0, #0
7009b858: 9007         	str	r0, [sp, #0x1c]
7009b85a: e00c         	b	0x7009b876 <_etoa+0x3b6> @ imm = #0x18
7009b85c: bf00         	nop
7009b85e: bf00         	nop
7009b860: ff ff ff ff  	.word	0xffffffff
7009b864: ff ff ef 7f  	.word	0x7fefffff
7009b868: ff ff ff ff  	.word	0xffffffff
7009b86c: ff ff ef ff  	.word	0xffefffff
7009b870: 981a         	ldr	r0, [sp, #0x68]
7009b872: 9007         	str	r0, [sp, #0x1c]
7009b874: e7ff         	b	0x7009b876 <_etoa+0x3b6> @ imm = #-0x2
7009b876: 9b0b         	ldr	r3, [sp, #0x2c]
7009b878: 9a0a         	ldr	r2, [sp, #0x28]
7009b87a: 9909         	ldr	r1, [sp, #0x24]
7009b87c: 9808         	ldr	r0, [sp, #0x20]
7009b87e: f8dd c01c    	ldr.w	r12, [sp, #0x1c]
7009b882: 9c1a         	ldr	r4, [sp, #0x68]
7009b884: f8dd e054    	ldr.w	lr, [sp, #0x54]
7009b888: f1ae 0501    	sub.w	r5, lr, #0x1
7009b88c: 46ee         	mov	lr, sp
7009b88e: 2605         	movs	r6, #0x5
7009b890: f8ce 6014    	str.w	r6, [lr, #0x14]
7009b894: f8ce 5010    	str.w	r5, [lr, #0x10]
7009b898: 2500         	movs	r5, #0x0
7009b89a: f8ce 500c    	str.w	r5, [lr, #0xc]
7009b89e: 250a         	movs	r5, #0xa
7009b8a0: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b8a4: ea4f 74d4    	lsr.w	r4, r4, #0x1f
7009b8a8: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b8ac: f8ce c000    	str.w	r12, [lr]
7009b8b0: f009 f90e    	bl	0x700a4ad0 <_ntoa_long> @ imm = #0x921c
7009b8b4: 9024         	str	r0, [sp, #0x90]
;     if (flags & FLAGS_LEFT) {
7009b8b6: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009b8ba: 0780         	lsls	r0, r0, #0x1e
7009b8bc: 2800         	cmp	r0, #0x0
7009b8be: d513         	bpl	0x7009b8e8 <_etoa+0x428> @ imm = #0x26
7009b8c0: e7ff         	b	0x7009b8c2 <_etoa+0x402> @ imm = #-0x2
;       while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
7009b8c2: e7ff         	b	0x7009b8c4 <_etoa+0x404> @ imm = #-0x2
7009b8c4: 9824         	ldr	r0, [sp, #0x90]
7009b8c6: 9913         	ldr	r1, [sp, #0x4c]
7009b8c8: 1a40         	subs	r0, r0, r1
7009b8ca: 992d         	ldr	r1, [sp, #0xb4]
7009b8cc: 4288         	cmp	r0, r1
7009b8ce: d20a         	bhs	0x7009b8e6 <_etoa+0x426> @ imm = #0x14
7009b8d0: e7ff         	b	0x7009b8d2 <_etoa+0x412> @ imm = #-0x2
7009b8d2: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b8d6: 9925         	ldr	r1, [sp, #0x94]
7009b8d8: 9a24         	ldr	r2, [sp, #0x90]
7009b8da: 1c50         	adds	r0, r2, #0x1
7009b8dc: 9024         	str	r0, [sp, #0x90]
7009b8de: 9b23         	ldr	r3, [sp, #0x8c]
7009b8e0: 2020         	movs	r0, #0x20
7009b8e2: 47e0         	blx	r12
7009b8e4: e7ee         	b	0x7009b8c4 <_etoa+0x404> @ imm = #-0x24
;     }
7009b8e6: e7ff         	b	0x7009b8e8 <_etoa+0x428> @ imm = #-0x2
;   }
7009b8e8: e7ff         	b	0x7009b8ea <_etoa+0x42a> @ imm = #-0x2
;   return idx;
7009b8ea: 9824         	ldr	r0, [sp, #0x90]
7009b8ec: 9027         	str	r0, [sp, #0x9c]
7009b8ee: e7ff         	b	0x7009b8f0 <_etoa+0x430> @ imm = #-0x2
; }
7009b8f0: 9827         	ldr	r0, [sp, #0x9c]
7009b8f2: b028         	add	sp, #0xa0
7009b8f4: bd70         	pop	{r4, r5, r6, pc}
7009b8f6: bf00         	nop
7009b8f8: fb 79 9f 50  	.word	0x509f79fb
7009b8fc: 13 44 d3 3f  	.word	0x3fd34413
7009b900: b3 c8 60 8b  	.word	0x8b60c8b3
7009b904: 28 8a c6 3f  	.word	0x3fc68a28
7009b908: 61 43 6f 63  	.word	0x636f4361
7009b90c: a7 87 d2 3f  	.word	0x3fd287a7
7009b910: 71 a3 79 09  	.word	0x0979a371
7009b914: 4f 93 0a 40  	.word	0x400a934f
7009b918: ef 39 fa fe  	.word	0xfefa39ef
7009b91c: 42 2e e6 bf  	.word	0xbfe62e42
7009b920: 16 55 b5 bb  	.word	0xbbb55516
7009b924: b1 6b 02 40  	.word	0x40026bb1
7009b928: 2d 43 1c eb  	.word	0xeb1c432d
7009b92c: e2 36 1a 3f  	.word	0x3f1a36e2
7009b930: 00 00 00 00  	.word	0x00000000
7009b934: 80 84 2e 41  	.word	0x412e8480

7009b938 <_nop>:
7009b938: e12fff1e     	bx	lr
7009b93c: 00000000     	andeq	r0, r0, r0

7009b940 <UART_open>:
; {
7009b940: b580         	push	{r7, lr}
7009b942: b092         	sub	sp, #0x48
7009b944: 9011         	str	r0, [sp, #0x44]
7009b946: 9110         	str	r1, [sp, #0x40]
7009b948: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS;
7009b94a: 900f         	str	r0, [sp, #0x3c]
;     UART_Handle         handle = NULL;
7009b94c: 900e         	str	r0, [sp, #0x38]
;     UART_Config        *config = NULL;
7009b94e: 900d         	str	r0, [sp, #0x34]
;     UART_Object        *object    = NULL;
7009b950: 900c         	str	r0, [sp, #0x30]
;     if(index >= gUartConfigNum)
7009b952: 9811         	ldr	r0, [sp, #0x44]
7009b954: f642 11ec    	movw	r1, #0x29ec
7009b958: f2c7 010b    	movt	r1, #0x700b
7009b95c: 6809         	ldr	r1, [r1]
7009b95e: 4288         	cmp	r0, r1
7009b960: d304         	blo	0x7009b96c <UART_open+0x2c> @ imm = #0x8
7009b962: e7ff         	b	0x7009b964 <UART_open+0x24> @ imm = #-0x2
7009b964: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009b968: 900f         	str	r0, [sp, #0x3c]
;     }
7009b96a: e008         	b	0x7009b97e <UART_open+0x3e> @ imm = #0x10
;         config = &gUartConfig[index];
7009b96c: 9911         	ldr	r1, [sp, #0x44]
7009b96e: f642 10a4    	movw	r0, #0x29a4
7009b972: f2c7 000b    	movt	r0, #0x700b
7009b976: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009b97a: 900d         	str	r0, [sp, #0x34]
7009b97c: e7ff         	b	0x7009b97e <UART_open+0x3e> @ imm = #-0x2
;     DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009b97e: f242 7128    	movw	r1, #0x2728
7009b982: f2c7 010b    	movt	r1, #0x700b
7009b986: f851 0b04    	ldr	r0, [r1], #4
7009b98a: 9103         	str	r1, [sp, #0xc]
7009b98c: 2800         	cmp	r0, #0x0
7009b98e: bf18         	it	ne
7009b990: 2001         	movne	r0, #0x1
7009b992: f641 51c4    	movw	r1, #0x1dc4
7009b996: f2c7 010b    	movt	r1, #0x700b
7009b99a: 466a         	mov	r2, sp
7009b99c: 6011         	str	r1, [r2]
7009b99e: f242 0101    	movw	r1, #0x2001
7009b9a2: f2c7 010b    	movt	r1, #0x700b
7009b9a6: f242 125c    	movw	r2, #0x215c
7009b9aa: f2c7 020b    	movt	r2, #0x700b
7009b9ae: f240 1301    	movw	r3, #0x101
7009b9b2: f00f f88d    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xf11a
7009b9b6: 9803         	ldr	r0, [sp, #0xc]
7009b9b8: f04f 31ff    	mov.w	r1, #0xffffffff
;     (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009b9bc: f00e fe30    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0xec60
;     if(SystemP_SUCCESS  == status)
7009b9c0: 980f         	ldr	r0, [sp, #0x3c]
7009b9c2: bb38         	cbnz	r0, 0x7009ba14 <UART_open+0xd4> @ imm = #0x4e
7009b9c4: e7ff         	b	0x7009b9c6 <UART_open+0x86> @ imm = #-0x2
;         object = config->object;
7009b9c6: 980d         	ldr	r0, [sp, #0x34]
7009b9c8: 6840         	ldr	r0, [r0, #0x4]
7009b9ca: 900c         	str	r0, [sp, #0x30]
;         attrs  = config->attrs;
7009b9cc: 980d         	ldr	r0, [sp, #0x34]
7009b9ce: 6800         	ldr	r0, [r0]
7009b9d0: 900b         	str	r0, [sp, #0x2c]
;         DebugP_assert(NULL_PTR != object);
7009b9d2: 980c         	ldr	r0, [sp, #0x30]
7009b9d4: 2800         	cmp	r0, #0x0
7009b9d6: bf18         	it	ne
7009b9d8: 2001         	movne	r0, #0x1
7009b9da: f641 71ee    	movw	r1, #0x1fee
7009b9de: f2c7 010b    	movt	r1, #0x700b
7009b9e2: 466a         	mov	r2, sp
7009b9e4: 6011         	str	r1, [r2]
7009b9e6: f242 0101    	movw	r1, #0x2001
7009b9ea: f2c7 010b    	movt	r1, #0x700b
7009b9ee: f242 125c    	movw	r2, #0x215c
7009b9f2: f2c7 020b    	movt	r2, #0x700b
7009b9f6: f44f 7384    	mov.w	r3, #0x108
7009b9fa: f00f f869    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xf0d2
;         if(TRUE == object->isOpen)
7009b9fe: 980c         	ldr	r0, [sp, #0x30]
7009ba00: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009ba04: 2801         	cmp	r0, #0x1
7009ba06: d104         	bne	0x7009ba12 <UART_open+0xd2> @ imm = #0x8
7009ba08: e7ff         	b	0x7009ba0a <UART_open+0xca> @ imm = #-0x2
7009ba0a: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009ba0e: 900f         	str	r0, [sp, #0x3c]
;         }
7009ba10: e7ff         	b	0x7009ba12 <UART_open+0xd2> @ imm = #-0x2
;     }
7009ba12: e7ff         	b	0x7009ba14 <UART_open+0xd4> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009ba14: 980f         	ldr	r0, [sp, #0x3c]
7009ba16: 2800         	cmp	r0, #0x0
7009ba18: f040 80cd    	bne.w	0x7009bbb6 <UART_open+0x276> @ imm = #0x19a
7009ba1c: e7ff         	b	0x7009ba1e <UART_open+0xde> @ imm = #-0x2
;         object->handle = (UART_Handle) config;
7009ba1e: 980d         	ldr	r0, [sp, #0x34]
7009ba20: 990c         	ldr	r1, [sp, #0x30]
7009ba22: 6008         	str	r0, [r1]
;         if(NULL != prms)
7009ba24: 9810         	ldr	r0, [sp, #0x40]
7009ba26: b138         	cbz	r0, 0x7009ba38 <UART_open+0xf8> @ imm = #0xe
7009ba28: e7ff         	b	0x7009ba2a <UART_open+0xea> @ imm = #-0x2
;             ( void )memcpy(&object->prms, prms, sizeof(UART_Params));
7009ba2a: 980c         	ldr	r0, [sp, #0x30]
7009ba2c: 3004         	adds	r0, #0x4
7009ba2e: 9910         	ldr	r1, [sp, #0x40]
7009ba30: 2258         	movs	r2, #0x58
7009ba32: f7fe ea94    	blx	0x70099f5c <__aeabi_memcpy8> @ imm = #-0x1ad8
;         }
7009ba36: e004         	b	0x7009ba42 <UART_open+0x102> @ imm = #0x8
;             UART_Params_init(&object->prms);
7009ba38: 980c         	ldr	r0, [sp, #0x30]
7009ba3a: 3004         	adds	r0, #0x4
7009ba3c: f00f f888    	bl	0x700aab50 <UART_Params_init> @ imm = #0xf110
7009ba40: e7ff         	b	0x7009ba42 <UART_open+0x102> @ imm = #-0x2
;         object->uartLld_handle             = &object->uartLld_object;
7009ba42: 990c         	ldr	r1, [sp, #0x30]
7009ba44: f501 7022    	add.w	r0, r1, #0x288
7009ba48: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle                     = object->uartLld_handle;
7009ba4c: 980c         	ldr	r0, [sp, #0x30]
7009ba4e: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009ba52: 9005         	str	r0, [sp, #0x14]
;         object->uartLld_initHandle         = &object->uartLld_initObject;
7009ba54: 990c         	ldr	r1, [sp, #0x30]
7009ba56: f501 7040    	add.w	r0, r1, #0x300
7009ba5a: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;         uartLldInit_handle                 = object->uartLld_initHandle;
7009ba5e: 980c         	ldr	r0, [sp, #0x30]
7009ba60: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
7009ba64: 9004         	str	r0, [sp, #0x10]
;         uartLld_handle->hUartInit          = uartLldInit_handle;
7009ba66: 9804         	ldr	r0, [sp, #0x10]
7009ba68: 9905         	ldr	r1, [sp, #0x14]
7009ba6a: 6048         	str	r0, [r1, #0x4]
;         uartLld_handle->baseAddr           = attrs->baseAddr;
7009ba6c: 980b         	ldr	r0, [sp, #0x2c]
7009ba6e: 6800         	ldr	r0, [r0]
7009ba70: 9905         	ldr	r1, [sp, #0x14]
7009ba72: 6008         	str	r0, [r1]
;         uartLld_handle->args               = (void *)object->handle;
7009ba74: 980c         	ldr	r0, [sp, #0x30]
7009ba76: 6800         	ldr	r0, [r0]
7009ba78: 9905         	ldr	r1, [sp, #0x14]
7009ba7a: 6608         	str	r0, [r1, #0x60]
;         uartLld_handle->writeBuf           = object->writeBuf;
7009ba7c: 980c         	ldr	r0, [sp, #0x30]
7009ba7e: 6dc0         	ldr	r0, [r0, #0x5c]
7009ba80: 9905         	ldr	r1, [sp, #0x14]
7009ba82: 6088         	str	r0, [r1, #0x8]
;         uartLld_handle->writeCount         = object->writeCount;
7009ba84: 980c         	ldr	r0, [sp, #0x30]
7009ba86: 6e00         	ldr	r0, [r0, #0x60]
7009ba88: 9905         	ldr	r1, [sp, #0x14]
7009ba8a: 60c8         	str	r0, [r1, #0xc]
;         uartLld_handle->writeSizeRemaining = object->writeSizeRemaining;
7009ba8c: 980c         	ldr	r0, [sp, #0x30]
7009ba8e: 6e40         	ldr	r0, [r0, #0x64]
7009ba90: 9905         	ldr	r1, [sp, #0x14]
7009ba92: 6108         	str	r0, [r1, #0x10]
;         uartLld_handle->readBuf            = object->readBuf;
7009ba94: 980c         	ldr	r0, [sp, #0x30]
7009ba96: 6e80         	ldr	r0, [r0, #0x68]
7009ba98: 9905         	ldr	r1, [sp, #0x14]
7009ba9a: 6148         	str	r0, [r1, #0x14]
;         uartLld_handle->readCount          = object->readCount;
7009ba9c: 980c         	ldr	r0, [sp, #0x30]
7009ba9e: 6ec0         	ldr	r0, [r0, #0x6c]
7009baa0: 9905         	ldr	r1, [sp, #0x14]
7009baa2: 6188         	str	r0, [r1, #0x18]
;         uartLld_handle->readSizeRemaining  = object->readSizeRemaining;
7009baa4: 980c         	ldr	r0, [sp, #0x30]
7009baa6: 6f00         	ldr	r0, [r0, #0x70]
7009baa8: 9905         	ldr	r1, [sp, #0x14]
7009baaa: 61c8         	str	r0, [r1, #0x1c]
;         uartLld_handle->rxTimeoutCnt       = object->rxTimeoutCnt;
7009baac: 980c         	ldr	r0, [sp, #0x30]
7009baae: 6f40         	ldr	r0, [r0, #0x74]
7009bab0: 9905         	ldr	r1, [sp, #0x14]
7009bab2: 6208         	str	r0, [r1, #0x20]
;         uartLld_handle->readErrorCnt       = object->readErrorCnt;
7009bab4: 980c         	ldr	r0, [sp, #0x30]
7009bab6: 6f80         	ldr	r0, [r0, #0x78]
7009bab8: 9905         	ldr	r1, [sp, #0x14]
7009baba: 6248         	str	r0, [r1, #0x24]
;         uartLld_handle->state              = UART_STATE_RESET;
7009babc: 9905         	ldr	r1, [sp, #0x14]
7009babe: 2000         	movs	r0, #0x0
7009bac0: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->inputClkFreq      = attrs->inputClkFreq;
7009bac2: 990b         	ldr	r1, [sp, #0x2c]
7009bac4: 6849         	ldr	r1, [r1, #0x4]
7009bac6: 9a04         	ldr	r2, [sp, #0x10]
7009bac8: 6011         	str	r1, [r2]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009baca: 990c         	ldr	r1, [sp, #0x30]
7009bacc: 6849         	ldr	r1, [r1, #0x4]
7009bace: 9a04         	ldr	r2, [sp, #0x10]
7009bad0: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009bad2: 990c         	ldr	r1, [sp, #0x30]
7009bad4: 6849         	ldr	r1, [r1, #0x4]
7009bad6: 9a04         	ldr	r2, [sp, #0x10]
7009bad8: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->dataLength        = object->prms.dataLength;
7009bada: 990c         	ldr	r1, [sp, #0x30]
7009badc: 6889         	ldr	r1, [r1, #0x8]
7009bade: 9a04         	ldr	r2, [sp, #0x10]
7009bae0: 6091         	str	r1, [r2, #0x8]
;         uartLldInit_handle->stopBits          = object->prms.stopBits;
7009bae2: 990c         	ldr	r1, [sp, #0x30]
7009bae4: 68c9         	ldr	r1, [r1, #0xc]
7009bae6: 9a04         	ldr	r2, [sp, #0x10]
7009bae8: 60d1         	str	r1, [r2, #0xc]
;         uartLldInit_handle->parityType        = object->prms.parityType;
7009baea: 990c         	ldr	r1, [sp, #0x30]
7009baec: 6909         	ldr	r1, [r1, #0x10]
7009baee: 9a04         	ldr	r2, [sp, #0x10]
7009baf0: 6111         	str	r1, [r2, #0x10]
;         uartLldInit_handle->readReturnMode    = object->prms.readReturnMode;
7009baf2: 990c         	ldr	r1, [sp, #0x30]
7009baf4: 6989         	ldr	r1, [r1, #0x18]
7009baf6: 9a04         	ldr	r2, [sp, #0x10]
7009baf8: 6151         	str	r1, [r2, #0x14]
;         uartLldInit_handle->hwFlowControl     = object->prms.hwFlowControl;
7009bafa: 990c         	ldr	r1, [sp, #0x30]
7009bafc: 6a89         	ldr	r1, [r1, #0x28]
7009bafe: 9a04         	ldr	r2, [sp, #0x10]
7009bb00: 6191         	str	r1, [r2, #0x18]
;         uartLldInit_handle->hwFlowControlThr  = object->prms.hwFlowControlThr;
7009bb02: 990c         	ldr	r1, [sp, #0x30]
7009bb04: 6ac9         	ldr	r1, [r1, #0x2c]
7009bb06: 9a04         	ldr	r2, [sp, #0x10]
7009bb08: 61d1         	str	r1, [r2, #0x1c]
;         uartLldInit_handle->intrNum           = object->prms.intrNum;
7009bb0a: 990c         	ldr	r1, [sp, #0x30]
7009bb0c: 6b49         	ldr	r1, [r1, #0x34]
7009bb0e: 9a04         	ldr	r2, [sp, #0x10]
7009bb10: 6251         	str	r1, [r2, #0x24]
;         uartLldInit_handle->transferMode      = object->prms.transferMode;
7009bb12: 990c         	ldr	r1, [sp, #0x30]
7009bb14: 6b09         	ldr	r1, [r1, #0x30]
7009bb16: 9a04         	ldr	r2, [sp, #0x10]
7009bb18: 6211         	str	r1, [r2, #0x20]
;         uartLldInit_handle->intrPriority      = object->prms.intrPriority;
7009bb1a: 990c         	ldr	r1, [sp, #0x30]
7009bb1c: f891 1038    	ldrb.w	r1, [r1, #0x38]
7009bb20: 9a04         	ldr	r2, [sp, #0x10]
7009bb22: f882 1028    	strb.w	r1, [r2, #0x28]
;         uartLldInit_handle->operMode          = object->prms.operMode;
7009bb26: 990c         	ldr	r1, [sp, #0x30]
7009bb28: 6c49         	ldr	r1, [r1, #0x44]
7009bb2a: 9a04         	ldr	r2, [sp, #0x10]
7009bb2c: 62d1         	str	r1, [r2, #0x2c]
;         uartLldInit_handle->rxTrigLvl         = object->prms.rxTrigLvl;
7009bb2e: 990c         	ldr	r1, [sp, #0x30]
7009bb30: 6c89         	ldr	r1, [r1, #0x48]
7009bb32: 9a04         	ldr	r2, [sp, #0x10]
7009bb34: 6391         	str	r1, [r2, #0x38]
;         uartLldInit_handle->txTrigLvl         = object->prms.txTrigLvl;
7009bb36: 990c         	ldr	r1, [sp, #0x30]
7009bb38: 6cc9         	ldr	r1, [r1, #0x4c]
7009bb3a: 9a04         	ldr	r2, [sp, #0x10]
7009bb3c: 63d1         	str	r1, [r2, #0x3c]
;         uartLldInit_handle->uartDmaHandle     = NULL;
7009bb3e: 9904         	ldr	r1, [sp, #0x10]
7009bb40: 6488         	str	r0, [r1, #0x48]
;         uartLldInit_handle->dmaChCfg          = NULL;
7009bb42: 9904         	ldr	r1, [sp, #0x10]
7009bb44: 64c8         	str	r0, [r1, #0x4c]
;         uartLldInit_handle->rxEvtNum          = object->prms.rxEvtNum;
7009bb46: 980c         	ldr	r0, [sp, #0x30]
7009bb48: 6d00         	ldr	r0, [r0, #0x50]
7009bb4a: 9904         	ldr	r1, [sp, #0x10]
7009bb4c: 6408         	str	r0, [r1, #0x40]
;         uartLldInit_handle->txEvtNum          = object->prms.txEvtNum;
7009bb4e: 980c         	ldr	r0, [sp, #0x30]
7009bb50: 6d40         	ldr	r0, [r0, #0x54]
7009bb52: 9904         	ldr	r1, [sp, #0x10]
7009bb54: 6448         	str	r0, [r1, #0x44]
;         uartLldInit_handle->writeMode         = object->prms.writeMode;
7009bb56: 980c         	ldr	r0, [sp, #0x30]
7009bb58: 69c0         	ldr	r0, [r0, #0x1c]
7009bb5a: 9904         	ldr	r1, [sp, #0x10]
7009bb5c: 6348         	str	r0, [r1, #0x34]
;         uartLldInit_handle->readMode          = object->prms.readMode;
7009bb5e: 980c         	ldr	r0, [sp, #0x30]
7009bb60: 6940         	ldr	r0, [r0, #0x14]
7009bb62: 9904         	ldr	r1, [sp, #0x10]
7009bb64: 6308         	str	r0, [r1, #0x30]
;         uartLldInit_handle->timeGuardVal      = object->prms.timeGuardVal;
7009bb66: 980c         	ldr	r0, [sp, #0x30]
7009bb68: 6d80         	ldr	r0, [r0, #0x58]
7009bb6a: 9904         	ldr	r1, [sp, #0x10]
7009bb6c: 6508         	str	r0, [r1, #0x50]
;         uartLldInit_handle->clockP_get        = ClockP_getTicks;
7009bb6e: 9904         	ldr	r1, [sp, #0x10]
7009bb70: f64f 40a1    	movw	r0, #0xfca1
7009bb74: f2c7 000a    	movt	r0, #0x700a
7009bb78: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->clockP_usecToTick = ClockP_usecToTicks;
7009bb7a: 9904         	ldr	r1, [sp, #0x10]
7009bb7c: f24f 20a1    	movw	r0, #0xf2a1
7009bb80: f2c7 000a    	movt	r0, #0x700a
7009bb84: 6588         	str	r0, [r1, #0x58]
;         uartLldInit_handle->readCompleteCallbackFxn =  UART_lld_readCompleteCallback;
7009bb86: 9904         	ldr	r1, [sp, #0x10]
7009bb88: f24c 50e1    	movw	r0, #0xc5e1
7009bb8c: f2c7 000a    	movt	r0, #0x700a
7009bb90: 65c8         	str	r0, [r1, #0x5c]
;         uartLldInit_handle->writeCompleteCallbackFxn = UART_lld_writeCompleteCallback;
7009bb92: 9904         	ldr	r1, [sp, #0x10]
7009bb94: f24c 5021    	movw	r0, #0xc521
7009bb98: f2c7 000a    	movt	r0, #0x700a
7009bb9c: 6608         	str	r0, [r1, #0x60]
;         uartLldInit_handle->errorCallbackFxn =         UART_lld_errorCallback;
7009bb9e: 9904         	ldr	r1, [sp, #0x10]
7009bba0: f64f 40b1    	movw	r0, #0xfcb1
7009bba4: f2c7 000a    	movt	r0, #0x700a
7009bba8: 6648         	str	r0, [r1, #0x64]
;         status = UART_checkOpenParams(&object->prms);
7009bbaa: 980c         	ldr	r0, [sp, #0x30]
7009bbac: 3004         	adds	r0, #0x4
7009bbae: f011 ff17    	bl	0x700ad9e0 <UART_checkOpenParams> @ imm = #0x11e2e
7009bbb2: 900f         	str	r0, [sp, #0x3c]
;     }
7009bbb4: e7ff         	b	0x7009bbb6 <UART_open+0x276> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009bbb6: 980f         	ldr	r0, [sp, #0x3c]
7009bbb8: 2800         	cmp	r0, #0x0
7009bbba: f040 80b8    	bne.w	0x7009bd2e <UART_open+0x3ee> @ imm = #0x170
7009bbbe: e7ff         	b	0x7009bbc0 <UART_open+0x280> @ imm = #-0x2
;         uartLld_handle->state = UART_STATE_RESET;
7009bbc0: 9905         	ldr	r1, [sp, #0x14]
7009bbc2: 2000         	movs	r0, #0x0
7009bbc4: 6548         	str	r0, [r1, #0x54]
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009bbc6: 980c         	ldr	r0, [sp, #0x30]
7009bbc8: 6b00         	ldr	r0, [r0, #0x30]
7009bbca: 2803         	cmp	r0, #0x3
7009bbcc: d117         	bne	0x7009bbfe <UART_open+0x2be> @ imm = #0x2e
7009bbce: e7ff         	b	0x7009bbd0 <UART_open+0x290> @ imm = #-0x2
;             uartLldInit_handle->uartDmaHandle = (UART_DmaHandle) gUartDmaHandle[index];
7009bbd0: 9911         	ldr	r1, [sp, #0x44]
7009bbd2: f242 6070    	movw	r0, #0x2670
7009bbd6: f2c7 000b    	movt	r0, #0x700b
7009bbda: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009bbde: 9904         	ldr	r1, [sp, #0x10]
7009bbe0: 6488         	str	r0, [r1, #0x48]
;             uartLldInit_handle->dmaChCfg      = gUartDmaChConfig[index];
7009bbe2: 9911         	ldr	r1, [sp, #0x44]
7009bbe4: f642 10f0    	movw	r0, #0x29f0
7009bbe8: f2c7 000b    	movt	r0, #0x700b
7009bbec: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009bbf0: 9904         	ldr	r1, [sp, #0x10]
7009bbf2: 64c8         	str	r0, [r1, #0x4c]
;             status = UART_lld_initDma(uartLld_handle);
7009bbf4: 9805         	ldr	r0, [sp, #0x14]
7009bbf6: f006 f91b    	bl	0x700a1e30 <UART_lld_initDma> @ imm = #0x6236
7009bbfa: 900f         	str	r0, [sp, #0x3c]
;         }
7009bbfc: e008         	b	0x7009bc10 <UART_open+0x2d0> @ imm = #0x10
;             status = UART_lld_init(uartLld_handle);
7009bbfe: 9805         	ldr	r0, [sp, #0x14]
7009bc00: f007 fb36    	bl	0x700a3270 <UART_lld_init> @ imm = #0x766c
7009bc04: 900f         	str	r0, [sp, #0x3c]
;             object->uartDmaHandle = NULL;
7009bc06: 990c         	ldr	r1, [sp, #0x30]
7009bc08: 2000         	movs	r0, #0x0
7009bc0a: f8c1 0280    	str.w	r0, [r1, #0x280]
7009bc0e: e7ff         	b	0x7009bc10 <UART_open+0x2d0> @ imm = #-0x2
;         if(SystemP_SUCCESS == status)
7009bc10: 980f         	ldr	r0, [sp, #0x3c]
7009bc12: 2800         	cmp	r0, #0x0
7009bc14: f040 808a    	bne.w	0x7009bd2c <UART_open+0x3ec> @ imm = #0x114
7009bc18: e7ff         	b	0x7009bc1a <UART_open+0x2da> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&object->lockObj);
7009bc1a: 980c         	ldr	r0, [sp, #0x30]
7009bc1c: 308c         	adds	r0, #0x8c
7009bc1e: f00f fc67    	bl	0x700ab4f0 <SemaphoreP_constructMutex> @ imm = #0xf8ce
7009bc22: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bc24: 980f         	ldr	r0, [sp, #0x3c]
7009bc26: b930         	cbnz	r0, 0x7009bc36 <UART_open+0x2f6> @ imm = #0xc
7009bc28: e7ff         	b	0x7009bc2a <UART_open+0x2ea> @ imm = #-0x2
;                 object->lock = &object->lockObj;
7009bc2a: 990c         	ldr	r1, [sp, #0x30]
7009bc2c: f101 008c    	add.w	r0, r1, #0x8c
7009bc30: f8c1 0088    	str.w	r0, [r1, #0x88]
;             }
7009bc34: e7ff         	b	0x7009bc36 <UART_open+0x2f6> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->readTransferSemObj, 0U);
7009bc36: 980c         	ldr	r0, [sp, #0x30]
7009bc38: f500 7094    	add.w	r0, r0, #0x128
7009bc3c: 2100         	movs	r1, #0x0
7009bc3e: f00c f8a7    	bl	0x700a7d90 <SemaphoreP_constructBinary> @ imm = #0xc14e
7009bc42: 4601         	mov	r1, r0
7009bc44: 980f         	ldr	r0, [sp, #0x3c]
7009bc46: 4408         	add	r0, r1
7009bc48: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bc4a: 980f         	ldr	r0, [sp, #0x3c]
7009bc4c: b958         	cbnz	r0, 0x7009bc66 <UART_open+0x326> @ imm = #0x16
7009bc4e: e7ff         	b	0x7009bc50 <UART_open+0x310> @ imm = #-0x2
;                 object->readTransferSem = &object->readTransferSemObj;
7009bc50: 990c         	ldr	r1, [sp, #0x30]
7009bc52: f501 7094    	add.w	r0, r1, #0x128
7009bc56: f8c1 0124    	str.w	r0, [r1, #0x124]
;                 uartLld_handle->readTransferMutex = object->readTransferSem;
7009bc5a: 980c         	ldr	r0, [sp, #0x30]
7009bc5c: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009bc60: 9905         	ldr	r1, [sp, #0x14]
7009bc62: 6588         	str	r0, [r1, #0x58]
;             }
7009bc64: e7ff         	b	0x7009bc66 <UART_open+0x326> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->writeTransferSemObj, 0U);
7009bc66: 980c         	ldr	r0, [sp, #0x30]
7009bc68: f500 70e2    	add.w	r0, r0, #0x1c4
7009bc6c: 2100         	movs	r1, #0x0
7009bc6e: f00c f88f    	bl	0x700a7d90 <SemaphoreP_constructBinary> @ imm = #0xc11e
7009bc72: 4601         	mov	r1, r0
7009bc74: 980f         	ldr	r0, [sp, #0x3c]
7009bc76: 4408         	add	r0, r1
7009bc78: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bc7a: 980f         	ldr	r0, [sp, #0x3c]
7009bc7c: b958         	cbnz	r0, 0x7009bc96 <UART_open+0x356> @ imm = #0x16
7009bc7e: e7ff         	b	0x7009bc80 <UART_open+0x340> @ imm = #-0x2
;                 object->writeTransferSem = &object->writeTransferSemObj;
7009bc80: 990c         	ldr	r1, [sp, #0x30]
7009bc82: f501 70e2    	add.w	r0, r1, #0x1c4
7009bc86: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;                 uartLld_handle->writeTransferMutex = object->writeTransferSem;
7009bc8a: 980c         	ldr	r0, [sp, #0x30]
7009bc8c: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009bc90: 9905         	ldr	r1, [sp, #0x14]
7009bc92: 65c8         	str	r0, [r1, #0x5c]
;             }
7009bc94: e7ff         	b	0x7009bc96 <UART_open+0x356> @ imm = #-0x2
;             if((UART_CONFIG_MODE_INTERRUPT == object->prms.transferMode) && (TRUE != object->prms.skipIntrReg))
7009bc96: 980c         	ldr	r0, [sp, #0x30]
7009bc98: 6b00         	ldr	r0, [r0, #0x30]
7009bc9a: 2801         	cmp	r0, #0x1
7009bc9c: d145         	bne	0x7009bd2a <UART_open+0x3ea> @ imm = #0x8a
7009bc9e: e7ff         	b	0x7009bca0 <UART_open+0x360> @ imm = #-0x2
7009bca0: 980c         	ldr	r0, [sp, #0x30]
7009bca2: 6bc0         	ldr	r0, [r0, #0x3c]
7009bca4: 2801         	cmp	r0, #0x1
7009bca6: d040         	beq	0x7009bd2a <UART_open+0x3ea> @ imm = #0x80
7009bca8: e7ff         	b	0x7009bcaa <UART_open+0x36a> @ imm = #-0x2
;                 DebugP_assert(object->prms.intrNum != 0xFFFFU);
7009bcaa: 980c         	ldr	r0, [sp, #0x30]
7009bcac: 6b40         	ldr	r0, [r0, #0x34]
7009bcae: f64f 71ff    	movw	r1, #0xffff
7009bcb2: 1a40         	subs	r0, r0, r1
7009bcb4: bf18         	it	ne
7009bcb6: 2001         	movne	r0, #0x1
7009bcb8: f641 41ec    	movw	r1, #0x1cec
7009bcbc: f2c7 010b    	movt	r1, #0x700b
7009bcc0: 466a         	mov	r2, sp
7009bcc2: 6011         	str	r1, [r2]
7009bcc4: f242 0101    	movw	r1, #0x2001
7009bcc8: f2c7 010b    	movt	r1, #0x700b
7009bccc: f242 125c    	movw	r2, #0x215c
7009bcd0: f2c7 020b    	movt	r2, #0x700b
7009bcd4: f44f 73bf    	mov.w	r3, #0x17e
7009bcd8: f00e fefa    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xedf4
7009bcdc: a806         	add	r0, sp, #0x18
;                 HwiP_Params_init(&hwiPrms);
7009bcde: 9002         	str	r0, [sp, #0x8]
7009bce0: f014 f916    	bl	0x700aff10 <HwiP_Params_init> @ imm = #0x1422c
7009bce4: 9902         	ldr	r1, [sp, #0x8]
;                 hwiPrms.intNum      = object->prms.intrNum;
7009bce6: 980c         	ldr	r0, [sp, #0x30]
7009bce8: 6b40         	ldr	r0, [r0, #0x34]
7009bcea: 9006         	str	r0, [sp, #0x18]
;                 hwiPrms.callback    = &UART_lld_controllerIsr;
7009bcec: f64f 6061    	movw	r0, #0xfe61
7009bcf0: f2c7 0009    	movt	r0, #0x7009
7009bcf4: 9007         	str	r0, [sp, #0x1c]
;                 hwiPrms.priority    = object->prms.intrPriority;
7009bcf6: 980c         	ldr	r0, [sp, #0x30]
7009bcf8: f890 0038    	ldrb.w	r0, [r0, #0x38]
7009bcfc: f88d 0026    	strb.w	r0, [sp, #0x26]
;                 hwiPrms.args        = (void *) uartLld_handle;
7009bd00: 9805         	ldr	r0, [sp, #0x14]
7009bd02: 9008         	str	r0, [sp, #0x20]
;                 status += HwiP_construct(&object->hwiObj, &hwiPrms);
7009bd04: 980c         	ldr	r0, [sp, #0x30]
7009bd06: f500 7018    	add.w	r0, r0, #0x260
7009bd0a: f014 f919    	bl	0x700aff40 <HwiP_construct> @ imm = #0x14232
7009bd0e: 4601         	mov	r1, r0
7009bd10: 980f         	ldr	r0, [sp, #0x3c]
7009bd12: 4408         	add	r0, r1
7009bd14: 900f         	str	r0, [sp, #0x3c]
;                 if(SystemP_SUCCESS == status)
7009bd16: 980f         	ldr	r0, [sp, #0x3c]
7009bd18: b930         	cbnz	r0, 0x7009bd28 <UART_open+0x3e8> @ imm = #0xc
7009bd1a: e7ff         	b	0x7009bd1c <UART_open+0x3dc> @ imm = #-0x2
;                     object->hwiHandle = &object->hwiObj;
7009bd1c: 990c         	ldr	r1, [sp, #0x30]
7009bd1e: f501 7018    	add.w	r0, r1, #0x260
7009bd22: f8c1 025c    	str.w	r0, [r1, #0x25c]
;                 }
7009bd26: e7ff         	b	0x7009bd28 <UART_open+0x3e8> @ imm = #-0x2
;             }
7009bd28: e7ff         	b	0x7009bd2a <UART_open+0x3ea> @ imm = #-0x2
;         }
7009bd2a: e7ff         	b	0x7009bd2c <UART_open+0x3ec> @ imm = #-0x2
;     }
7009bd2c: e7ff         	b	0x7009bd2e <UART_open+0x3ee> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009bd2e: 980f         	ldr	r0, [sp, #0x3c]
7009bd30: b938         	cbnz	r0, 0x7009bd42 <UART_open+0x402> @ imm = #0xe
7009bd32: e7ff         	b	0x7009bd34 <UART_open+0x3f4> @ imm = #-0x2
;         object->isOpen = TRUE;
7009bd34: 990c         	ldr	r1, [sp, #0x30]
7009bd36: 2001         	movs	r0, #0x1
7009bd38: f8c1 0084    	str.w	r0, [r1, #0x84]
;         handle = (UART_Handle) config;
7009bd3c: 980d         	ldr	r0, [sp, #0x34]
7009bd3e: 900e         	str	r0, [sp, #0x38]
;     }
7009bd40: e7ff         	b	0x7009bd42 <UART_open+0x402> @ imm = #-0x2
;     SemaphoreP_post(&gUartDrvObj.lockObj);
7009bd42: f242 7028    	movw	r0, #0x2728
7009bd46: f2c7 000b    	movt	r0, #0x700b
7009bd4a: 3004         	adds	r0, #0x4
7009bd4c: f010 f830    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x10060
;     if(SystemP_SUCCESS != status)
7009bd50: 980f         	ldr	r0, [sp, #0x3c]
7009bd52: b140         	cbz	r0, 0x7009bd66 <UART_open+0x426> @ imm = #0x10
7009bd54: e7ff         	b	0x7009bd56 <UART_open+0x416> @ imm = #-0x2
;         if(NULL != config)
7009bd56: 980d         	ldr	r0, [sp, #0x34]
7009bd58: b120         	cbz	r0, 0x7009bd64 <UART_open+0x424> @ imm = #0x8
7009bd5a: e7ff         	b	0x7009bd5c <UART_open+0x41c> @ imm = #-0x2
;             UART_close((UART_Handle) config);
7009bd5c: 980d         	ldr	r0, [sp, #0x34]
7009bd5e: f003 fec7    	bl	0x7009faf0 <UART_close> @ imm = #0x3d8e
;         }
7009bd62: e7ff         	b	0x7009bd64 <UART_open+0x424> @ imm = #-0x2
;     }
7009bd64: e7ff         	b	0x7009bd66 <UART_open+0x426> @ imm = #-0x2
;     return (handle);
7009bd66: 980e         	ldr	r0, [sp, #0x38]
7009bd68: b012         	add	sp, #0x48
7009bd6a: bd80         	pop	{r7, pc}
7009bd6c: 0000         	movs	r0, r0
7009bd6e: 0000         	movs	r0, r0

7009bd70 <Udma_chAllocResource>:
; {
7009bd70: b580         	push	{r7, lr}
7009bd72: b088         	sub	sp, #0x20
7009bd74: 9007         	str	r0, [sp, #0x1c]
7009bd76: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK, tempRetVal;
7009bd78: 9006         	str	r0, [sp, #0x18]
7009bd7a: f64f 70ff    	movw	r0, #0xffff
;     uint16_t                ringNum = UDMA_RING_INVALID;
7009bd7e: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     drvHandle = chHandle->drvHandle;
7009bd82: 9807         	ldr	r0, [sp, #0x1c]
7009bd84: 6e80         	ldr	r0, [r0, #0x68]
7009bd86: 9004         	str	r0, [sp, #0x10]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009bd88: 9807         	ldr	r0, [sp, #0x1c]
7009bd8a: 7800         	ldrb	r0, [r0]
7009bd8c: 0740         	lsls	r0, r0, #0x1d
7009bd8e: 2800         	cmp	r0, #0x0
7009bd90: d54d         	bpl	0x7009be2e <Udma_chAllocResource+0xbe> @ imm = #0x9a
7009bd92: e7ff         	b	0x7009bd94 <Udma_chAllocResource+0x24> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009bd94: 9807         	ldr	r0, [sp, #0x1c]
7009bd96: 7800         	ldrb	r0, [r0]
7009bd98: 0640         	lsls	r0, r0, #0x19
7009bd9a: 2800         	cmp	r0, #0x0
7009bd9c: d508         	bpl	0x7009bdb0 <Udma_chAllocResource+0x40> @ imm = #0x10
7009bd9e: e7ff         	b	0x7009bda0 <Udma_chAllocResource+0x30> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyHcCh(chHandle->chPrms.chNum, drvHandle);
7009bda0: 9807         	ldr	r0, [sp, #0x1c]
7009bda2: 6840         	ldr	r0, [r0, #0x4]
7009bda4: 9904         	ldr	r1, [sp, #0x10]
7009bda6: f007 fd5b    	bl	0x700a3860 <Udma_rmAllocBlkCopyHcCh> @ imm = #0x7ab6
;             chHandle->txChNum =
7009bdaa: 9907         	ldr	r1, [sp, #0x1c]
7009bdac: 66c8         	str	r0, [r1, #0x6c]
;         }
7009bdae: e016         	b	0x7009bdde <Udma_chAllocResource+0x6e> @ imm = #0x2c
;         else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009bdb0: 9807         	ldr	r0, [sp, #0x1c]
7009bdb2: 7800         	ldrb	r0, [r0]
7009bdb4: 0600         	lsls	r0, r0, #0x18
7009bdb6: 2800         	cmp	r0, #0x0
7009bdb8: d508         	bpl	0x7009bdcc <Udma_chAllocResource+0x5c> @ imm = #0x10
7009bdba: e7ff         	b	0x7009bdbc <Udma_chAllocResource+0x4c> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyUhcCh(chHandle->chPrms.chNum, drvHandle);
7009bdbc: 9807         	ldr	r0, [sp, #0x1c]
7009bdbe: 6840         	ldr	r0, [r0, #0x4]
7009bdc0: 9904         	ldr	r1, [sp, #0x10]
7009bdc2: f007 fde5    	bl	0x700a3990 <Udma_rmAllocBlkCopyUhcCh> @ imm = #0x7bca
;             chHandle->txChNum =
7009bdc6: 9907         	ldr	r1, [sp, #0x1c]
7009bdc8: 66c8         	str	r0, [r1, #0x6c]
;         }
7009bdca: e007         	b	0x7009bddc <Udma_chAllocResource+0x6c> @ imm = #0xe
;                 Udma_rmAllocBlkCopyCh(chHandle->chPrms.chNum, drvHandle);
7009bdcc: 9807         	ldr	r0, [sp, #0x1c]
7009bdce: 6840         	ldr	r0, [r0, #0x4]
7009bdd0: 9904         	ldr	r1, [sp, #0x10]
7009bdd2: f007 fcad    	bl	0x700a3730 <Udma_rmAllocBlkCopyCh> @ imm = #0x795a
;             chHandle->txChNum =
7009bdd6: 9907         	ldr	r1, [sp, #0x1c]
7009bdd8: 66c8         	str	r0, [r1, #0x6c]
7009bdda: e7ff         	b	0x7009bddc <Udma_chAllocResource+0x6c> @ imm = #-0x2
7009bddc: e7ff         	b	0x7009bdde <Udma_chAllocResource+0x6e> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009bdde: 9807         	ldr	r0, [sp, #0x1c]
7009bde0: 6ec0         	ldr	r0, [r0, #0x6c]
7009bde2: f510 3f80    	cmn.w	r0, #0x10000
7009bde6: d104         	bne	0x7009bdf2 <Udma_chAllocResource+0x82> @ imm = #0x8
7009bde8: e7ff         	b	0x7009bdea <Udma_chAllocResource+0x7a> @ imm = #-0x2
7009bdea: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009bdee: 9006         	str	r0, [sp, #0x18]
;         }
7009bdf0: e01c         	b	0x7009be2c <Udma_chAllocResource+0xbc> @ imm = #0x38
;             if (UDMA_INST_TYPE_LCDMA_BCDMA == chHandle->drvHandle->instType)
7009bdf2: 9807         	ldr	r0, [sp, #0x1c]
7009bdf4: 6e80         	ldr	r0, [r0, #0x68]
7009bdf6: 6800         	ldr	r0, [r0]
7009bdf8: 2801         	cmp	r0, #0x1
7009bdfa: d10b         	bne	0x7009be14 <Udma_chAllocResource+0xa4> @ imm = #0x16
7009bdfc: e7ff         	b	0x7009bdfe <Udma_chAllocResource+0x8e> @ imm = #-0x2
;                 chHandle->rxChNum     = UDMA_DMA_CH_INVALID;
7009bdfe: 9907         	ldr	r1, [sp, #0x1c]
7009be00: 2000         	movs	r0, #0x0
7009be02: f6cf 70ff    	movt	r0, #0xffff
7009be06: 6708         	str	r0, [r1, #0x70]
;                 chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009be08: 9907         	ldr	r1, [sp, #0x1c]
7009be0a: 2004         	movs	r0, #0x4
7009be0c: f6cf 70ff    	movt	r0, #0xffff
7009be10: 67c8         	str	r0, [r1, #0x7c]
;             }
7009be12: e00a         	b	0x7009be2a <Udma_chAllocResource+0xba> @ imm = #0x14
;                 chHandle->rxChNum = chHandle->txChNum;
7009be14: 9907         	ldr	r1, [sp, #0x1c]
7009be16: 6ec8         	ldr	r0, [r1, #0x6c]
7009be18: 6708         	str	r0, [r1, #0x70]
;                     chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
7009be1a: 9907         	ldr	r1, [sp, #0x1c]
7009be1c: 6f08         	ldr	r0, [r1, #0x70]
7009be1e: 9a04         	ldr	r2, [sp, #0x10]
7009be20: f8d2 20d8    	ldr.w	r2, [r2, #0xd8]
7009be24: 4410         	add	r0, r2
;                 chHandle->peerThreadId =
7009be26: 67c8         	str	r0, [r1, #0x7c]
7009be28: e7ff         	b	0x7009be2a <Udma_chAllocResource+0xba> @ imm = #-0x2
7009be2a: e7ff         	b	0x7009be2c <Udma_chAllocResource+0xbc> @ imm = #-0x2
;     }
7009be2c: e0bd         	b	0x7009bfaa <Udma_chAllocResource+0x23a> @ imm = #0x17a
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009be2e: 9807         	ldr	r0, [sp, #0x1c]
7009be30: 7800         	ldrb	r0, [r0]
7009be32: 07c0         	lsls	r0, r0, #0x1f
7009be34: 2800         	cmp	r0, #0x0
7009be36: d03f         	beq	0x7009beb8 <Udma_chAllocResource+0x148> @ imm = #0x7e
7009be38: e7ff         	b	0x7009be3a <Udma_chAllocResource+0xca> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009be3a: 9807         	ldr	r0, [sp, #0x1c]
7009be3c: 7800         	ldrb	r0, [r0]
7009be3e: 0640         	lsls	r0, r0, #0x19
7009be40: 2800         	cmp	r0, #0x0
7009be42: d508         	bpl	0x7009be56 <Udma_chAllocResource+0xe6> @ imm = #0x10
7009be44: e7ff         	b	0x7009be46 <Udma_chAllocResource+0xd6> @ imm = #-0x2
;                     Udma_rmAllocTxHcCh(chHandle->chPrms.chNum, drvHandle);
7009be46: 9807         	ldr	r0, [sp, #0x1c]
7009be48: 6840         	ldr	r0, [r0, #0x4]
7009be4a: 9904         	ldr	r1, [sp, #0x10]
7009be4c: f008 f898    	bl	0x700a3f80 <Udma_rmAllocTxHcCh> @ imm = #0x8130
;                 chHandle->txChNum =
7009be50: 9907         	ldr	r1, [sp, #0x1c]
7009be52: 66c8         	str	r0, [r1, #0x6c]
;             }
7009be54: e025         	b	0x7009bea2 <Udma_chAllocResource+0x132> @ imm = #0x4a
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009be56: 9807         	ldr	r0, [sp, #0x1c]
7009be58: 7840         	ldrb	r0, [r0, #0x1]
7009be5a: 07c0         	lsls	r0, r0, #0x1f
7009be5c: b148         	cbz	r0, 0x7009be72 <Udma_chAllocResource+0x102> @ imm = #0x12
7009be5e: e7ff         	b	0x7009be60 <Udma_chAllocResource+0xf0> @ imm = #-0x2
;                     Udma_rmAllocMappedTxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009be60: 9a07         	ldr	r2, [sp, #0x1c]
7009be62: 9904         	ldr	r1, [sp, #0x10]
7009be64: 6850         	ldr	r0, [r2, #0x4]
7009be66: 68d2         	ldr	r2, [r2, #0xc]
7009be68: f005 fe82    	bl	0x700a1b70 <Udma_rmAllocMappedTxCh> @ imm = #0x5d04
;                 chHandle->txChNum =
7009be6c: 9907         	ldr	r1, [sp, #0x1c]
7009be6e: 66c8         	str	r0, [r1, #0x6c]
;             }
7009be70: e016         	b	0x7009bea0 <Udma_chAllocResource+0x130> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009be72: 9807         	ldr	r0, [sp, #0x1c]
7009be74: 7800         	ldrb	r0, [r0]
7009be76: 0600         	lsls	r0, r0, #0x18
7009be78: 2800         	cmp	r0, #0x0
7009be7a: d508         	bpl	0x7009be8e <Udma_chAllocResource+0x11e> @ imm = #0x10
7009be7c: e7ff         	b	0x7009be7e <Udma_chAllocResource+0x10e> @ imm = #-0x2
;                     Udma_rmAllocTxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009be7e: 9807         	ldr	r0, [sp, #0x1c]
7009be80: 6840         	ldr	r0, [r0, #0x4]
7009be82: 9904         	ldr	r1, [sp, #0x10]
7009be84: f008 f914    	bl	0x700a40b0 <Udma_rmAllocTxUhcCh> @ imm = #0x8228
;                 chHandle->txChNum =
7009be88: 9907         	ldr	r1, [sp, #0x1c]
7009be8a: 66c8         	str	r0, [r1, #0x6c]
;             }
7009be8c: e007         	b	0x7009be9e <Udma_chAllocResource+0x12e> @ imm = #0xe
;                     Udma_rmAllocTxCh(chHandle->chPrms.chNum, drvHandle);
7009be8e: 9807         	ldr	r0, [sp, #0x1c]
7009be90: 6840         	ldr	r0, [r0, #0x4]
7009be92: 9904         	ldr	r1, [sp, #0x10]
7009be94: f007 ffdc    	bl	0x700a3e50 <Udma_rmAllocTxCh> @ imm = #0x7fb8
;                 chHandle->txChNum =
7009be98: 9907         	ldr	r1, [sp, #0x1c]
7009be9a: 66c8         	str	r0, [r1, #0x6c]
7009be9c: e7ff         	b	0x7009be9e <Udma_chAllocResource+0x12e> @ imm = #-0x2
7009be9e: e7ff         	b	0x7009bea0 <Udma_chAllocResource+0x130> @ imm = #-0x2
7009bea0: e7ff         	b	0x7009bea2 <Udma_chAllocResource+0x132> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009bea2: 9807         	ldr	r0, [sp, #0x1c]
7009bea4: 6ec0         	ldr	r0, [r0, #0x6c]
7009bea6: f510 3f80    	cmn.w	r0, #0x10000
7009beaa: d104         	bne	0x7009beb6 <Udma_chAllocResource+0x146> @ imm = #0x8
7009beac: e7ff         	b	0x7009beae <Udma_chAllocResource+0x13e> @ imm = #-0x2
7009beae: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009beb2: 9006         	str	r0, [sp, #0x18]
;             }
7009beb4: e7ff         	b	0x7009beb6 <Udma_chAllocResource+0x146> @ imm = #-0x2
;         }
7009beb6: e05c         	b	0x7009bf72 <Udma_chAllocResource+0x202> @ imm = #0xb8
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009beb8: 9807         	ldr	r0, [sp, #0x1c]
7009beba: 7800         	ldrb	r0, [r0]
7009bebc: 0640         	lsls	r0, r0, #0x19
7009bebe: 2800         	cmp	r0, #0x0
7009bec0: d508         	bpl	0x7009bed4 <Udma_chAllocResource+0x164> @ imm = #0x10
7009bec2: e7ff         	b	0x7009bec4 <Udma_chAllocResource+0x154> @ imm = #-0x2
;                     Udma_rmAllocRxHcCh(chHandle->chPrms.chNum, drvHandle);
7009bec4: 9807         	ldr	r0, [sp, #0x1c]
7009bec6: 6840         	ldr	r0, [r0, #0x4]
7009bec8: 9904         	ldr	r1, [sp, #0x10]
7009beca: f007 fe91    	bl	0x700a3bf0 <Udma_rmAllocRxHcCh> @ imm = #0x7d22
;                 chHandle->rxChNum =
7009bece: 9907         	ldr	r1, [sp, #0x1c]
7009bed0: 6708         	str	r0, [r1, #0x70]
;             }
7009bed2: e026         	b	0x7009bf22 <Udma_chAllocResource+0x1b2> @ imm = #0x4c
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009bed4: 9807         	ldr	r0, [sp, #0x1c]
7009bed6: 7840         	ldrb	r0, [r0, #0x1]
7009bed8: 07c0         	lsls	r0, r0, #0x1f
7009beda: b150         	cbz	r0, 0x7009bef2 <Udma_chAllocResource+0x182> @ imm = #0x14
7009bedc: e7ff         	b	0x7009bede <Udma_chAllocResource+0x16e> @ imm = #-0x2
;                     Udma_rmAllocMappedRxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009bede: 9a07         	ldr	r2, [sp, #0x1c]
7009bee0: 9904         	ldr	r1, [sp, #0x10]
7009bee2: 6850         	ldr	r0, [r2, #0x4]
7009bee4: 68d2         	ldr	r2, [r2, #0xc]
7009bee6: 3a04         	subs	r2, #0x4
7009bee8: f005 fd92    	bl	0x700a1a10 <Udma_rmAllocMappedRxCh> @ imm = #0x5b24
;                 chHandle->rxChNum =
7009beec: 9907         	ldr	r1, [sp, #0x1c]
7009beee: 6708         	str	r0, [r1, #0x70]
;             }
7009bef0: e016         	b	0x7009bf20 <Udma_chAllocResource+0x1b0> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009bef2: 9807         	ldr	r0, [sp, #0x1c]
7009bef4: 7800         	ldrb	r0, [r0]
7009bef6: 0600         	lsls	r0, r0, #0x18
7009bef8: 2800         	cmp	r0, #0x0
7009befa: d508         	bpl	0x7009bf0e <Udma_chAllocResource+0x19e> @ imm = #0x10
7009befc: e7ff         	b	0x7009befe <Udma_chAllocResource+0x18e> @ imm = #-0x2
;                     Udma_rmAllocRxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009befe: 9807         	ldr	r0, [sp, #0x1c]
7009bf00: 6840         	ldr	r0, [r0, #0x4]
7009bf02: 9904         	ldr	r1, [sp, #0x10]
7009bf04: f007 ff0c    	bl	0x700a3d20 <Udma_rmAllocRxUhcCh> @ imm = #0x7e18
;                 chHandle->rxChNum =
7009bf08: 9907         	ldr	r1, [sp, #0x1c]
7009bf0a: 6708         	str	r0, [r1, #0x70]
;             }
7009bf0c: e007         	b	0x7009bf1e <Udma_chAllocResource+0x1ae> @ imm = #0xe
;                     Udma_rmAllocRxCh(chHandle->chPrms.chNum, drvHandle);
7009bf0e: 9807         	ldr	r0, [sp, #0x1c]
7009bf10: 6840         	ldr	r0, [r0, #0x4]
7009bf12: 9904         	ldr	r1, [sp, #0x10]
7009bf14: f007 fdd4    	bl	0x700a3ac0 <Udma_rmAllocRxCh> @ imm = #0x7ba8
;                 chHandle->rxChNum =
7009bf18: 9907         	ldr	r1, [sp, #0x1c]
7009bf1a: 6708         	str	r0, [r1, #0x70]
7009bf1c: e7ff         	b	0x7009bf1e <Udma_chAllocResource+0x1ae> @ imm = #-0x2
7009bf1e: e7ff         	b	0x7009bf20 <Udma_chAllocResource+0x1b0> @ imm = #-0x2
7009bf20: e7ff         	b	0x7009bf22 <Udma_chAllocResource+0x1b2> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->rxChNum)
7009bf22: 9807         	ldr	r0, [sp, #0x1c]
7009bf24: 6f00         	ldr	r0, [r0, #0x70]
7009bf26: f510 3f80    	cmn.w	r0, #0x10000
7009bf2a: d104         	bne	0x7009bf36 <Udma_chAllocResource+0x1c6> @ imm = #0x8
7009bf2c: e7ff         	b	0x7009bf2e <Udma_chAllocResource+0x1be> @ imm = #-0x2
7009bf2e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009bf32: 9006         	str	r0, [sp, #0x18]
;             }
7009bf34: e01c         	b	0x7009bf70 <Udma_chAllocResource+0x200> @ imm = #0x38
;                 chHandle->defaultFlow               = &chHandle->defaultFlowObj;
7009bf36: 9907         	ldr	r1, [sp, #0x1c]
7009bf38: f501 70e6    	add.w	r0, r1, #0x1cc
7009bf3c: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
;                 chHandle->defaultFlow->drvHandle    = drvHandle;
7009bf40: 9804         	ldr	r0, [sp, #0x10]
7009bf42: 9907         	ldr	r1, [sp, #0x1c]
7009bf44: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009bf48: 6008         	str	r0, [r1]
;                 chHandle->defaultFlow->flowStart    = chHandle->rxChNum;
7009bf4a: 9907         	ldr	r1, [sp, #0x1c]
7009bf4c: 6f08         	ldr	r0, [r1, #0x70]
7009bf4e: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009bf52: 6048         	str	r0, [r1, #0x4]
;                 chHandle->defaultFlow->flowCnt      = 1U;
7009bf54: 9807         	ldr	r0, [sp, #0x1c]
7009bf56: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009bf5a: 2001         	movs	r0, #0x1
7009bf5c: 6088         	str	r0, [r1, #0x8]
;                 chHandle->defaultFlow->flowInitDone = UDMA_INIT_DONE;
7009bf5e: 9807         	ldr	r0, [sp, #0x1c]
7009bf60: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009bf64: f64a 30cd    	movw	r0, #0xabcd
7009bf68: f6ca 30dc    	movt	r0, #0xabdc
7009bf6c: 60c8         	str	r0, [r1, #0xc]
7009bf6e: e7ff         	b	0x7009bf70 <Udma_chAllocResource+0x200> @ imm = #-0x2
7009bf70: e7ff         	b	0x7009bf72 <Udma_chAllocResource+0x202> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
7009bf72: 9806         	ldr	r0, [sp, #0x18]
7009bf74: b9c0         	cbnz	r0, 0x7009bfa8 <Udma_chAllocResource+0x238> @ imm = #0x30
7009bf76: e7ff         	b	0x7009bf78 <Udma_chAllocResource+0x208> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
7009bf78: 9807         	ldr	r0, [sp, #0x1c]
7009bf7a: 7800         	ldrb	r0, [r0]
7009bf7c: 0700         	lsls	r0, r0, #0x1c
7009bf7e: 2800         	cmp	r0, #0x0
7009bf80: d507         	bpl	0x7009bf92 <Udma_chAllocResource+0x222> @ imm = #0xe
7009bf82: e7ff         	b	0x7009bf84 <Udma_chAllocResource+0x214> @ imm = #-0x2
;                 chHandle->pdmaChNum = chHandle->chPrms.peerChNum;
7009bf84: 9907         	ldr	r1, [sp, #0x1c]
7009bf86: 6888         	ldr	r0, [r1, #0x8]
7009bf88: 6788         	str	r0, [r1, #0x78]
;                 chHandle->peerThreadId = chHandle->pdmaChNum;
7009bf8a: 9907         	ldr	r1, [sp, #0x1c]
7009bf8c: 6f88         	ldr	r0, [r1, #0x78]
7009bf8e: 67c8         	str	r0, [r1, #0x7c]
;             }
7009bf90: e7ff         	b	0x7009bf92 <Udma_chAllocResource+0x222> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)
7009bf92: 9807         	ldr	r0, [sp, #0x1c]
7009bf94: 7800         	ldrb	r0, [r0]
7009bf96: 06c0         	lsls	r0, r0, #0x1b
7009bf98: 2800         	cmp	r0, #0x0
7009bf9a: d504         	bpl	0x7009bfa6 <Udma_chAllocResource+0x236> @ imm = #0x8
7009bf9c: e7ff         	b	0x7009bf9e <Udma_chAllocResource+0x22e> @ imm = #-0x2
;                 chHandle->peerThreadId = chHandle->chPrms.peerChNum;
7009bf9e: 9907         	ldr	r1, [sp, #0x1c]
7009bfa0: 6888         	ldr	r0, [r1, #0x8]
7009bfa2: 67c8         	str	r0, [r1, #0x7c]
;             }
7009bfa4: e7ff         	b	0x7009bfa6 <Udma_chAllocResource+0x236> @ imm = #-0x2
;         }
7009bfa6: e7ff         	b	0x7009bfa8 <Udma_chAllocResource+0x238> @ imm = #-0x2
7009bfa8: e7ff         	b	0x7009bfaa <Udma_chAllocResource+0x23a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009bfaa: 9806         	ldr	r0, [sp, #0x18]
7009bfac: 2800         	cmp	r0, #0x0
7009bfae: f040 8088    	bne.w	0x7009c0c2 <Udma_chAllocResource+0x352> @ imm = #0x110
7009bfb2: e7ff         	b	0x7009bfb4 <Udma_chAllocResource+0x244> @ imm = #-0x2
;         if(NULL_PTR != chHandle->chPrms.fqRingPrms.ringMem)
7009bfb4: 9807         	ldr	r0, [sp, #0x1c]
7009bfb6: 6940         	ldr	r0, [r0, #0x14]
7009bfb8: 2800         	cmp	r0, #0x0
7009bfba: f000 8081    	beq.w	0x7009c0c0 <Udma_chAllocResource+0x350> @ imm = #0x102
7009bfbe: e7ff         	b	0x7009bfc0 <Udma_chAllocResource+0x250> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) ==
7009bfc0: 9807         	ldr	r0, [sp, #0x1c]
7009bfc2: 7800         	ldrb	r0, [r0]
7009bfc4: 0740         	lsls	r0, r0, #0x1d
7009bfc6: 2800         	cmp	r0, #0x0
7009bfc8: d505         	bpl	0x7009bfd6 <Udma_chAllocResource+0x266> @ imm = #0xa
7009bfca: e7ff         	b	0x7009bfcc <Udma_chAllocResource+0x25c> @ imm = #-0x2
;                 ringNum = (uint16_t)chHandle->txChNum;
7009bfcc: 9807         	ldr	r0, [sp, #0x1c]
7009bfce: 6ec0         	ldr	r0, [r0, #0x6c]
7009bfd0: f8ad 000e    	strh.w	r0, [sp, #0xe]
;             }
7009bfd4: e044         	b	0x7009c060 <Udma_chAllocResource+0x2f0> @ imm = #0x88
;                 if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009bfd6: 9807         	ldr	r0, [sp, #0x1c]
7009bfd8: 7840         	ldrb	r0, [r0, #0x1]
7009bfda: 07c0         	lsls	r0, r0, #0x1f
7009bfdc: b338         	cbz	r0, 0x7009c02e <Udma_chAllocResource+0x2be> @ imm = #0x4e
7009bfde: e7ff         	b	0x7009bfe0 <Udma_chAllocResource+0x270> @ imm = #-0x2
;                     chHandle->chPrms.fqRingPrms.mappedRingGrp  = chHandle->chPrms.mappedChGrp;
7009bfe0: 9907         	ldr	r1, [sp, #0x1c]
7009bfe2: 68c8         	ldr	r0, [r1, #0xc]
7009bfe4: 6288         	str	r0, [r1, #0x28]
;                     if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009bfe6: 9807         	ldr	r0, [sp, #0x1c]
7009bfe8: 7800         	ldrb	r0, [r0]
7009bfea: 07c0         	lsls	r0, r0, #0x1f
7009bfec: b178         	cbz	r0, 0x7009c00e <Udma_chAllocResource+0x29e> @ imm = #0x1e
7009bfee: e7ff         	b	0x7009bff0 <Udma_chAllocResource+0x280> @ imm = #-0x2
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->txChNum;
7009bff0: 9907         	ldr	r1, [sp, #0x1c]
7009bff2: 6ec8         	ldr	r0, [r1, #0x6c]
7009bff4: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->txChNum, &chAttr);
7009bff6: 9804         	ldr	r0, [sp, #0x10]
7009bff8: 9a07         	ldr	r2, [sp, #0x1c]
7009bffa: 68d1         	ldr	r1, [r2, #0xc]
7009bffc: 6ed2         	ldr	r2, [r2, #0x6c]
7009bffe: 466b         	mov	r3, sp
7009c000: f00b fe16    	bl	0x700a7c30 <Udma_getMappedChRingAttributes> @ imm = #0xbc2c
7009c004: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009c006: 9800         	ldr	r0, [sp]
7009c008: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                     }
7009c00c: e00e         	b	0x7009c02c <Udma_chAllocResource+0x2bc> @ imm = #0x1c
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->rxChNum;
7009c00e: 9907         	ldr	r1, [sp, #0x1c]
7009c010: 6f08         	ldr	r0, [r1, #0x70]
7009c012: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->rxChNum, &chAttr);
7009c014: 9804         	ldr	r0, [sp, #0x10]
7009c016: 9a07         	ldr	r2, [sp, #0x1c]
7009c018: 68d1         	ldr	r1, [r2, #0xc]
7009c01a: 6f12         	ldr	r2, [r2, #0x70]
7009c01c: 466b         	mov	r3, sp
7009c01e: f00b fe07    	bl	0x700a7c30 <Udma_getMappedChRingAttributes> @ imm = #0xbc0e
7009c022: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009c024: 9800         	ldr	r0, [sp]
7009c026: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009c02a: e7ff         	b	0x7009c02c <Udma_chAllocResource+0x2bc> @ imm = #-0x2
;                 }
7009c02c: e017         	b	0x7009c05e <Udma_chAllocResource+0x2ee> @ imm = #0x2e
;                 else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009c02e: 9807         	ldr	r0, [sp, #0x1c]
7009c030: 7800         	ldrb	r0, [r0]
7009c032: 07c0         	lsls	r0, r0, #0x1f
7009c034: b148         	cbz	r0, 0x7009c04a <Udma_chAllocResource+0x2da> @ imm = #0x12
7009c036: e7ff         	b	0x7009c038 <Udma_chAllocResource+0x2c8> @ imm = #-0x2
;                     ringNum = (uint16_t)(chHandle->txChNum + drvHandle->txChOffset);
7009c038: 9807         	ldr	r0, [sp, #0x1c]
7009c03a: 6ec0         	ldr	r0, [r0, #0x6c]
7009c03c: 9904         	ldr	r1, [sp, #0x10]
7009c03e: f8d1 110c    	ldr.w	r1, [r1, #0x10c]
7009c042: 4408         	add	r0, r1
7009c044: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 }
7009c048: e008         	b	0x7009c05c <Udma_chAllocResource+0x2ec> @ imm = #0x10
;                     ringNum = (uint16_t)(chHandle->rxChNum + drvHandle->rxChOffset);
7009c04a: 9807         	ldr	r0, [sp, #0x1c]
7009c04c: 6f00         	ldr	r0, [r0, #0x70]
7009c04e: 9904         	ldr	r1, [sp, #0x10]
7009c050: f8d1 1114    	ldr.w	r1, [r1, #0x114]
7009c054: 4408         	add	r0, r1
7009c056: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009c05a: e7ff         	b	0x7009c05c <Udma_chAllocResource+0x2ec> @ imm = #-0x2
7009c05c: e7ff         	b	0x7009c05e <Udma_chAllocResource+0x2ee> @ imm = #-0x2
7009c05e: e7ff         	b	0x7009c060 <Udma_chAllocResource+0x2f0> @ imm = #-0x2
;             chHandle->fqRing = &chHandle->fqRingObj;
7009c060: 9907         	ldr	r1, [sp, #0x1c]
7009c062: f101 0090    	add.w	r0, r1, #0x90
7009c066: f8c1 0080    	str.w	r0, [r1, #0x80]
;                          drvHandle,
7009c06a: 9804         	ldr	r0, [sp, #0x10]
;                          chHandle->fqRing,
7009c06c: 9b07         	ldr	r3, [sp, #0x1c]
7009c06e: f8d3 1080    	ldr.w	r1, [r3, #0x80]
;                          ringNum,
7009c072: f8bd 200e    	ldrh.w	r2, [sp, #0xe]
;                          &chHandle->chPrms.fqRingPrms);
7009c076: 3314         	adds	r3, #0x14
;             retVal = Udma_ringAlloc(
7009c078: f002 feca    	bl	0x7009ee10 <Udma_ringAlloc> @ imm = #0x2d94
7009c07c: 9006         	str	r0, [sp, #0x18]
;             if(UDMA_SOK != retVal)
7009c07e: 9806         	ldr	r0, [sp, #0x18]
7009c080: b128         	cbz	r0, 0x7009c08e <Udma_chAllocResource+0x31e> @ imm = #0xa
7009c082: e7ff         	b	0x7009c084 <Udma_chAllocResource+0x314> @ imm = #-0x2
;                 chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009c084: 9907         	ldr	r1, [sp, #0x1c]
7009c086: 2000         	movs	r0, #0x0
7009c088: f8c1 0080    	str.w	r0, [r1, #0x80]
;             }
7009c08c: e017         	b	0x7009c0be <Udma_chAllocResource+0x34e> @ imm = #0x2e
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009c08e: 9807         	ldr	r0, [sp, #0x1c]
7009c090: 7840         	ldrb	r0, [r0, #0x1]
7009c092: 07c0         	lsls	r0, r0, #0x1f
7009c094: b190         	cbz	r0, 0x7009c0bc <Udma_chAllocResource+0x34c> @ imm = #0x24
7009c096: e7ff         	b	0x7009c098 <Udma_chAllocResource+0x328> @ imm = #-0x2
;                     ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX))
7009c098: 9807         	ldr	r0, [sp, #0x1c]
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009c09a: 7800         	ldrb	r0, [r0]
7009c09c: 0780         	lsls	r0, r0, #0x1e
7009c09e: 2800         	cmp	r0, #0x0
7009c0a0: d50c         	bpl	0x7009c0bc <Udma_chAllocResource+0x34c> @ imm = #0x18
7009c0a2: e7ff         	b	0x7009c0a4 <Udma_chAllocResource+0x334> @ imm = #-0x2
;                 chHandle->defaultFlow->flowStart    = chHandle->fqRing->ringNum - drvHandle->rxChOffset;
7009c0a4: 9907         	ldr	r1, [sp, #0x1c]
7009c0a6: f8d1 0080    	ldr.w	r0, [r1, #0x80]
7009c0aa: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009c0ae: 8880         	ldrh	r0, [r0, #0x4]
7009c0b0: 9a04         	ldr	r2, [sp, #0x10]
7009c0b2: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c0b6: 1a80         	subs	r0, r0, r2
7009c0b8: 6048         	str	r0, [r1, #0x4]
;             }
7009c0ba: e7ff         	b	0x7009c0bc <Udma_chAllocResource+0x34c> @ imm = #-0x2
7009c0bc: e7ff         	b	0x7009c0be <Udma_chAllocResource+0x34e> @ imm = #-0x2
;         }
7009c0be: e7ff         	b	0x7009c0c0 <Udma_chAllocResource+0x350> @ imm = #-0x2
;     }
7009c0c0: e7ff         	b	0x7009c0c2 <Udma_chAllocResource+0x352> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c0c2: 9806         	ldr	r0, [sp, #0x18]
7009c0c4: b930         	cbnz	r0, 0x7009c0d4 <Udma_chAllocResource+0x364> @ imm = #0xc
7009c0c6: e7ff         	b	0x7009c0c8 <Udma_chAllocResource+0x358> @ imm = #-0x2
;         chHandle->cqRing = &chHandle->fqRingObj;
7009c0c8: 9907         	ldr	r1, [sp, #0x1c]
7009c0ca: f101 0090    	add.w	r0, r1, #0x90
7009c0ce: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009c0d2: e7ff         	b	0x7009c0d4 <Udma_chAllocResource+0x364> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c0d4: 9806         	ldr	r0, [sp, #0x18]
7009c0d6: b928         	cbnz	r0, 0x7009c0e4 <Udma_chAllocResource+0x374> @ imm = #0xa
7009c0d8: e7ff         	b	0x7009c0da <Udma_chAllocResource+0x36a> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009c0da: 9907         	ldr	r1, [sp, #0x1c]
7009c0dc: 2000         	movs	r0, #0x0
7009c0de: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009c0e2: e7ff         	b	0x7009c0e4 <Udma_chAllocResource+0x374> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009c0e4: 9806         	ldr	r0, [sp, #0x18]
7009c0e6: b148         	cbz	r0, 0x7009c0fc <Udma_chAllocResource+0x38c> @ imm = #0x12
7009c0e8: e7ff         	b	0x7009c0ea <Udma_chAllocResource+0x37a> @ imm = #-0x2
;         tempRetVal = Udma_chFreeResource(chHandle);
7009c0ea: 9807         	ldr	r0, [sp, #0x1c]
7009c0ec: f002 fd88    	bl	0x7009ec00 <Udma_chFreeResource> @ imm = #0x2b10
7009c0f0: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != tempRetVal)
7009c0f2: 9805         	ldr	r0, [sp, #0x14]
7009c0f4: b108         	cbz	r0, 0x7009c0fa <Udma_chAllocResource+0x38a> @ imm = #0x2
7009c0f6: e7ff         	b	0x7009c0f8 <Udma_chAllocResource+0x388> @ imm = #-0x2
;         }
7009c0f8: e7ff         	b	0x7009c0fa <Udma_chAllocResource+0x38a> @ imm = #-0x2
;     }
7009c0fa: e004         	b	0x7009c106 <Udma_chAllocResource+0x396> @ imm = #0x8
;         Udma_chAssignRegOverlay(drvHandle, chHandle);
7009c0fc: 9804         	ldr	r0, [sp, #0x10]
7009c0fe: 9907         	ldr	r1, [sp, #0x1c]
7009c100: f006 f896    	bl	0x700a2230 <Udma_chAssignRegOverlay> @ imm = #0x612c
7009c104: e7ff         	b	0x7009c106 <Udma_chAllocResource+0x396> @ imm = #-0x2
;     return (retVal);
7009c106: 9806         	ldr	r0, [sp, #0x18]
7009c108: b008         	add	sp, #0x20
7009c10a: bd80         	pop	{r7, pc}
7009c10c: 0000         	movs	r0, r0
7009c10e: 0000         	movs	r0, r0

7009c110 <CSL_REG32_WR_RAW>:
; {
7009c110: b082         	sub	sp, #0x8
7009c112: 9001         	str	r0, [sp, #0x4]
7009c114: 9100         	str	r1, [sp]
;     *p = v;
7009c116: 9800         	ldr	r0, [sp]
7009c118: 9901         	ldr	r1, [sp, #0x4]
7009c11a: 6008         	str	r0, [r1]
;     return;
7009c11c: b002         	add	sp, #0x8
7009c11e: 4770         	bx	lr

7009c120 <strcmp>:
7009c120: e5d02000     	ldrb	r2, [r0]
7009c124: e5d13000     	ldrb	r3, [r1]
7009c128: e3520001     	cmp	r2, #1
7009c12c: 21520003     	cmphs	r2, r3
7009c130: 1a004ed2     	bne	0x700afc80 <.Lfastpath_exit> @ imm = #0x13b48
7009c134: e16d41f0     	strd	r4, r5, [sp, #-16]!
7009c138: e1804001     	orr	r4, r0, r1
7009c13c: e1cd60f8     	strd	r6, r7, [sp, #8]
7009c140: e3e0c000     	mvn	r12, #0
7009c144: e1a02e84     	lsl	r2, r4, #29
7009c148: e3520000     	cmp	r2, #0
7009c14c: 0a000013     	beq	0x7009c1a0 <strcmp+0x80> @ imm = #0x4c
7009c150: e0204001     	eor	r4, r0, r1
7009c154: e3140007     	tst	r4, #7
7009c158: 1a00003e     	bne	0x7009c258 <strcmp+0x138> @ imm = #0xf8
7009c15c: e2004007     	and	r4, r0, #7
7009c160: e3c00007     	bic	r0, r0, #7
7009c164: e2045003     	and	r5, r4, #3
7009c168: e3c11007     	bic	r1, r1, #7
7009c16c: e1a05185     	lsl	r5, r5, #3
7009c170: e0c021d0     	ldrd	r2, r3, [r0], #16
7009c174: e3140004     	tst	r4, #4
7009c178: e0c161d0     	ldrd	r6, r7, [r1], #16
7009c17c: e1e0451c     	mvn	r4, r12, lsl r5
7009c180: e1822004     	orr	r2, r2, r4
7009c184: e1866004     	orr	r6, r6, r4
7009c188: 0a000006     	beq	0x7009c1a8 <strcmp+0x88> @ imm = #0x18
7009c18c: e1833004     	orr	r3, r3, r4
7009c190: e1a0200c     	mov	r2, r12
7009c194: e1877004     	orr	r7, r7, r4
7009c198: e1a0600c     	mov	r6, r12
7009c19c: ea000001     	b	0x7009c1a8 <strcmp+0x88> @ imm = #0x4
7009c1a0: e0c021d0     	ldrd	r2, r3, [r0], #16
7009c1a4: e0c161d0     	ldrd	r6, r7, [r1], #16
7009c1a8: e6525f9c     	uadd8	r5, r2, r12
7009c1ac: e0224006     	eor	r4, r2, r6
7009c1b0: e6844fbc     	sel	r4, r4, r12
7009c1b4: e3540000     	cmp	r4, #0
7009c1b8: 1a00001b     	bne	0x7009c22c <strcmp+0x10c> @ imm = #0x6c
7009c1bc: e6535f9c     	uadd8	r5, r3, r12
7009c1c0: e0235007     	eor	r5, r3, r7
7009c1c4: e6855fbc     	sel	r5, r5, r12
7009c1c8: e3550000     	cmp	r5, #0
7009c1cc: 1a00000b     	bne	0x7009c200 <strcmp+0xe0> @ imm = #0x2c
7009c1d0: e14020d8     	ldrd	r2, r3, [r0, #-8]
7009c1d4: e14160d8     	ldrd	r6, r7, [r1, #-8]
7009c1d8: e6525f9c     	uadd8	r5, r2, r12
7009c1dc: e0224006     	eor	r4, r2, r6
7009c1e0: e6844fbc     	sel	r4, r4, r12
7009c1e4: e6535f9c     	uadd8	r5, r3, r12
7009c1e8: e0235007     	eor	r5, r3, r7
7009c1ec: e6855fbc     	sel	r5, r5, r12
7009c1f0: e1955004     	orrs	r5, r5, r4
7009c1f4: 0affffe9     	beq	0x7009c1a0 <strcmp+0x80> @ imm = #-0x5c
7009c1f8: e3540000     	cmp	r4, #0
7009c1fc: 1a00000a     	bne	0x7009c22c <strcmp+0x10c> @ imm = #0x28
7009c200: e6bf5f35     	rev	r5, r5
7009c204: e16f4f15     	clz	r4, r5
7009c208: e3c44007     	bic	r4, r4, #7
7009c20c: e1a01437     	lsr	r1, r7, r4
7009c210: e1cd60d8     	ldrd	r6, r7, [sp, #8]
7009c214: e1a03433     	lsr	r3, r3, r4
7009c218: e20300ff     	and	r0, r3, #255
7009c21c: e20110ff     	and	r1, r1, #255
7009c220: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c224: e0400001     	sub	r0, r0, r1
7009c228: e12fff1e     	bx	lr
7009c22c: e6bf4f34     	rev	r4, r4
7009c230: e16f4f14     	clz	r4, r4
7009c234: e3c44007     	bic	r4, r4, #7
7009c238: e1a01436     	lsr	r1, r6, r4
7009c23c: e1cd60d8     	ldrd	r6, r7, [sp, #8]
7009c240: e1a02432     	lsr	r2, r2, r4
7009c244: e20200ff     	and	r0, r2, #255
7009c248: e20110ff     	and	r1, r1, #255
7009c24c: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c250: e0400001     	sub	r0, r0, r1
7009c254: e12fff1e     	bx	lr
7009c258: e3140003     	tst	r4, #3
7009c25c: 1a000022     	bne	0x7009c2ec <strcmp+0x1cc> @ imm = #0x88
7009c260: e2104003     	ands	r4, r0, #3
7009c264: 1a000017     	bne	0x7009c2c8 <strcmp+0x1a8> @ imm = #0x5c
7009c268: e4902008     	ldr	r2, [r0], #8
7009c26c: e4913008     	ldr	r3, [r1], #8
7009c270: e6525f9c     	uadd8	r5, r2, r12
7009c274: e0225003     	eor	r5, r2, r3
7009c278: e6855fbc     	sel	r5, r5, r12
7009c27c: e3550000     	cmp	r5, #0
7009c280: 1a000006     	bne	0x7009c2a0 <strcmp+0x180> @ imm = #0x18
7009c284: e5102004     	ldr	r2, [r0, #-0x4]
7009c288: e5113004     	ldr	r3, [r1, #-0x4]
7009c28c: e6525f9c     	uadd8	r5, r2, r12
7009c290: e0225003     	eor	r5, r2, r3
7009c294: e6855fbc     	sel	r5, r5, r12
7009c298: e3550000     	cmp	r5, #0
7009c29c: 0afffff1     	beq	0x7009c268 <strcmp+0x148> @ imm = #-0x3c
7009c2a0: e6bf5f35     	rev	r5, r5
7009c2a4: e16f4f15     	clz	r4, r5
7009c2a8: e3c44007     	bic	r4, r4, #7
7009c2ac: e1a01433     	lsr	r1, r3, r4
7009c2b0: e1a02432     	lsr	r2, r2, r4
7009c2b4: e20200ff     	and	r0, r2, #255
7009c2b8: e20110ff     	and	r1, r1, #255
7009c2bc: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c2c0: e0400001     	sub	r0, r0, r1
7009c2c4: e12fff1e     	bx	lr
7009c2c8: e1a04184     	lsl	r4, r4, #3
7009c2cc: e3c00003     	bic	r0, r0, #3
7009c2d0: e4902008     	ldr	r2, [r0], #8
7009c2d4: e3c11003     	bic	r1, r1, #3
7009c2d8: e4913008     	ldr	r3, [r1], #8
7009c2dc: e1e0441c     	mvn	r4, r12, lsl r4
7009c2e0: e1822004     	orr	r2, r2, r4
7009c2e4: e1833004     	orr	r3, r3, r4
7009c2e8: eaffffe0     	b	0x7009c270 <strcmp+0x150> @ imm = #-0x80
7009c2ec: e2104003     	ands	r4, r0, #3
7009c2f0: 0a000015     	beq	0x7009c34c <strcmp+0x22c> @ imm = #0x54
7009c2f4: e0411004     	sub	r1, r1, r4
7009c2f8: e3c00003     	bic	r0, r0, #3
7009c2fc: e1b04f84     	lsls	r4, r4, #31
7009c300: e4902004     	ldr	r2, [r0], #4
7009c304: 0a000006     	beq	0x7009c324 <strcmp+0x204> @ imm = #0x18
7009c308: 2a00000e     	bhs	0x7009c348 <strcmp+0x228> @ imm = #0x38
7009c30c: e5d13002     	ldrb	r3, [r1, #0x2]
7009c310: e6ef4872     	uxtb	r4, r2, ror #16
7009c314: e0544003     	subs	r4, r4, r3
7009c318: 1a000007     	bne	0x7009c33c <strcmp+0x21c> @ imm = #0x1c
7009c31c: e3530000     	cmp	r3, #0
7009c320: 0a000005     	beq	0x7009c33c <strcmp+0x21c> @ imm = #0x14
7009c324: e5d13003     	ldrb	r3, [r1, #0x3]
7009c328: e6ef4c72     	uxtb	r4, r2, ror #24
7009c32c: e0544003     	subs	r4, r4, r3
7009c330: 1a000001     	bne	0x7009c33c <strcmp+0x21c> @ imm = #0x4
7009c334: e3530000     	cmp	r3, #0
7009c338: 1a000002     	bne	0x7009c348 <strcmp+0x228> @ imm = #0x8
7009c33c: e1a00004     	mov	r0, r4
7009c340: e49d4010     	ldr	r4, [sp], #16
7009c344: e12fff1e     	bx	lr
7009c348: e2811004     	add	r1, r1, #4
7009c34c: e4902004     	ldr	r2, [r0], #4
7009c350: e1b04f81     	lsls	r4, r1, #31
7009c354: e3c11003     	bic	r1, r1, #3
7009c358: e4913004     	ldr	r3, [r1], #4
7009c35c: 8a00002f     	bhi	0x7009c420 <strcmp+0x300> @ imm = #0xbc
7009c360: 2a000017     	bhs	0x7009c3c4 <strcmp+0x2a4> @ imm = #0x5c
7009c364: e3c244ff     	bic	r4, r2, #-16777216
7009c368: e6525f9c     	uadd8	r5, r2, r12
7009c36c: e0345423     	eors	r5, r4, r3, lsr #8
7009c370: e6855fbc     	sel	r5, r5, r12
7009c374: 1a000007     	bne	0x7009c398 <strcmp+0x278> @ imm = #0x1c
7009c378: e3550000     	cmp	r5, #0
7009c37c: 1a000007     	bne	0x7009c3a0 <strcmp+0x280> @ imm = #0x1c
7009c380: e4913004     	ldr	r3, [r1], #4
7009c384: e0244002     	eor	r4, r4, r2
7009c388: e1540c03     	cmp	r4, r3, lsl #24
7009c38c: 1a000009     	bne	0x7009c3b8 <strcmp+0x298> @ imm = #0x24
7009c390: e4902004     	ldr	r2, [r0], #4
7009c394: eafffff2     	b	0x7009c364 <strcmp+0x244> @ imm = #-0x38
7009c398: e1a03423     	lsr	r3, r3, #8
7009c39c: ea000037     	b	0x7009c480 <strcmp+0x360> @ imm = #0xdc
7009c3a0: e3d554ff     	bics	r5, r5, #-16777216
7009c3a4: 1a000032     	bne	0x7009c474 <strcmp+0x354> @ imm = #0xc8
7009c3a8: e5d10000     	ldrb	r0, [r1]
7009c3ac: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c3b0: e2600000     	rsb	r0, r0, #0
7009c3b4: e12fff1e     	bx	lr
7009c3b8: e1a02c22     	lsr	r2, r2, #24
7009c3bc: e20330ff     	and	r3, r3, #255
7009c3c0: ea00002e     	b	0x7009c480 <strcmp+0x360> @ imm = #0xb8
7009c3c4: e002482c     	and	r4, r2, r12, lsr #16
7009c3c8: e6525f9c     	uadd8	r5, r2, r12
7009c3cc: e0345823     	eors	r5, r4, r3, lsr #16
7009c3d0: e6855fbc     	sel	r5, r5, r12
7009c3d4: 1a000007     	bne	0x7009c3f8 <strcmp+0x2d8> @ imm = #0x1c
7009c3d8: e3550000     	cmp	r5, #0
7009c3dc: 1a000007     	bne	0x7009c400 <strcmp+0x2e0> @ imm = #0x1c
7009c3e0: e4913004     	ldr	r3, [r1], #4
7009c3e4: e0244002     	eor	r4, r4, r2
7009c3e8: e1540803     	cmp	r4, r3, lsl #16
7009c3ec: 1a000008     	bne	0x7009c414 <strcmp+0x2f4> @ imm = #0x20
7009c3f0: e4902004     	ldr	r2, [r0], #4
7009c3f4: eafffff2     	b	0x7009c3c4 <strcmp+0x2a4> @ imm = #-0x38
7009c3f8: e1a03823     	lsr	r3, r3, #16
7009c3fc: ea00001f     	b	0x7009c480 <strcmp+0x360> @ imm = #0x7c
7009c400: e015582c     	ands	r5, r5, r12, lsr #16
7009c404: 1a00001a     	bne	0x7009c474 <strcmp+0x354> @ imm = #0x68
7009c408: e1d130b0     	ldrh	r3, [r1]
7009c40c: e1a02822     	lsr	r2, r2, #16
7009c410: ea00001a     	b	0x7009c480 <strcmp+0x360> @ imm = #0x68
7009c414: e1a02822     	lsr	r2, r2, #16
7009c418: e003382c     	and	r3, r3, r12, lsr #16
7009c41c: ea000017     	b	0x7009c480 <strcmp+0x360> @ imm = #0x5c
7009c420: e20240ff     	and	r4, r2, #255
7009c424: e6525f9c     	uadd8	r5, r2, r12
7009c428: e0345c23     	eors	r5, r4, r3, lsr #24
7009c42c: e6855fbc     	sel	r5, r5, r12
7009c430: 1a000007     	bne	0x7009c454 <strcmp+0x334> @ imm = #0x1c
7009c434: e3550000     	cmp	r5, #0
7009c438: 1a000007     	bne	0x7009c45c <strcmp+0x33c> @ imm = #0x1c
7009c43c: e4913004     	ldr	r3, [r1], #4
7009c440: e0244002     	eor	r4, r4, r2
7009c444: e1540403     	cmp	r4, r3, lsl #8
7009c448: 1a000006     	bne	0x7009c468 <strcmp+0x348> @ imm = #0x18
7009c44c: e4902004     	ldr	r2, [r0], #4
7009c450: eafffff2     	b	0x7009c420 <strcmp+0x300> @ imm = #-0x38
7009c454: e1a03c23     	lsr	r3, r3, #24
7009c458: ea000008     	b	0x7009c480 <strcmp+0x360> @ imm = #0x20
7009c45c: e31500ff     	tst	r5, #255
7009c460: 1a000003     	bne	0x7009c474 <strcmp+0x354> @ imm = #0xc
7009c464: e5913000     	ldr	r3, [r1]
7009c468: e1a02422     	lsr	r2, r2, #8
7009c46c: e3c334ff     	bic	r3, r3, #-16777216
7009c470: ea000002     	b	0x7009c480 <strcmp+0x360> @ imm = #0x8
7009c474: e3a00000     	mov	r0, #0
7009c478: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c47c: e12fff1e     	bx	lr
7009c480: e6bf2f32     	rev	r2, r2
7009c484: e6bf3f33     	rev	r3, r3
7009c488: e6524f9c     	uadd8	r4, r2, r12
7009c48c: e0224003     	eor	r4, r2, r3
7009c490: e6845fbc     	sel	r5, r4, r12
7009c494: e16f4f15     	clz	r4, r5
7009c498: e1a02412     	lsl	r2, r2, r4
7009c49c: e1a03413     	lsl	r3, r3, r4
7009c4a0: e1a00c22     	lsr	r0, r2, #24
7009c4a4: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c4a8: e0400c23     	sub	r0, r0, r3, lsr #24
7009c4ac: e12fff1e     	bx	lr

7009c4b0 <Udma_chDisableTxChan>:
; {
7009c4b0: b580         	push	{r7, lr}
7009c4b2: b09a         	sub	sp, #0x68
7009c4b4: 9019         	str	r0, [sp, #0x64]
7009c4b6: 9118         	str	r1, [sp, #0x60]
7009c4b8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009c4ba: 9017         	str	r0, [sp, #0x5c]
;     uint32_t            peerRtEnable = 0U, currTimeout = 0U;
7009c4bc: 9016         	str	r0, [sp, #0x58]
7009c4be: 9015         	str	r0, [sp, #0x54]
;     drvHandle = chHandle->drvHandle;
7009c4c0: 9819         	ldr	r0, [sp, #0x64]
7009c4c2: 6e80         	ldr	r0, [r0, #0x68]
7009c4c4: 9014         	str	r0, [sp, #0x50]
7009c4c6: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009c4c8: 9008         	str	r0, [sp, #0x20]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c4ca: 9814         	ldr	r0, [sp, #0x50]
7009c4cc: 6800         	ldr	r0, [r0]
7009c4ce: 2801         	cmp	r0, #0x1
7009c4d0: d10e         	bne	0x7009c4f0 <Udma_chDisableTxChan+0x40> @ imm = #0x1c
7009c4d2: e7ff         	b	0x7009c4d4 <Udma_chDisableTxChan+0x24> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)false, (bool)false);
7009c4d4: 9a14         	ldr	r2, [sp, #0x50]
7009c4d6: f102 0008    	add.w	r0, r2, #0x8
7009c4da: 9919         	ldr	r1, [sp, #0x64]
7009c4dc: 6ec9         	ldr	r1, [r1, #0x6c]
7009c4de: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c4e2: 4411         	add	r1, r2
7009c4e4: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009c4e6: 461a         	mov	r2, r3
7009c4e8: f011 f8ea    	bl	0x700ad6c0 <CSL_bcdmaTeardownTxChan> @ imm = #0x111d4
7009c4ec: 9017         	str	r0, [sp, #0x5c]
;     }
7009c4ee: e00f         	b	0x7009c510 <Udma_chDisableTxChan+0x60> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c4f0: 9814         	ldr	r0, [sp, #0x50]
7009c4f2: 6800         	ldr	r0, [r0]
7009c4f4: 2802         	cmp	r0, #0x2
7009c4f6: d10a         	bne	0x7009c50e <Udma_chDisableTxChan+0x5e> @ imm = #0x14
7009c4f8: e7ff         	b	0x7009c4fa <Udma_chDisableTxChan+0x4a> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009c4fa: 9814         	ldr	r0, [sp, #0x50]
7009c4fc: 3054         	adds	r0, #0x54
7009c4fe: 9919         	ldr	r1, [sp, #0x64]
7009c500: 6ec9         	ldr	r1, [r1, #0x6c]
7009c502: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009c504: 461a         	mov	r2, r3
7009c506: f011 ffa3    	bl	0x700ae450 <CSL_pktdmaTeardownTxChan> @ imm = #0x11f46
7009c50a: 9017         	str	r0, [sp, #0x5c]
;     }
7009c50c: e7ff         	b	0x7009c50e <Udma_chDisableTxChan+0x5e> @ imm = #-0x2
7009c50e: e7ff         	b	0x7009c510 <Udma_chDisableTxChan+0x60> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009c510: 9817         	ldr	r0, [sp, #0x5c]
7009c512: b108         	cbz	r0, 0x7009c518 <Udma_chDisableTxChan+0x68> @ imm = #0x2
7009c514: e7ff         	b	0x7009c516 <Udma_chDisableTxChan+0x66> @ imm = #-0x2
;     }
7009c516: e7ff         	b	0x7009c518 <Udma_chDisableTxChan+0x68> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c518: e7ff         	b	0x7009c51a <Udma_chDisableTxChan+0x6a> @ imm = #-0x2
7009c51a: 9817         	ldr	r0, [sp, #0x5c]
7009c51c: bbc8         	cbnz	r0, 0x7009c592 <Udma_chDisableTxChan+0xe2> @ imm = #0x72
7009c51e: e7ff         	b	0x7009c520 <Udma_chDisableTxChan+0x70> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c520: 9814         	ldr	r0, [sp, #0x50]
7009c522: 6800         	ldr	r0, [r0]
7009c524: 2801         	cmp	r0, #0x1
7009c526: d110         	bne	0x7009c54a <Udma_chDisableTxChan+0x9a> @ imm = #0x20
7009c528: e7ff         	b	0x7009c52a <Udma_chDisableTxChan+0x7a> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c52a: 9a14         	ldr	r2, [sp, #0x50]
7009c52c: f102 0008    	add.w	r0, r2, #0x8
7009c530: 9919         	ldr	r1, [sp, #0x64]
7009c532: 6ec9         	ldr	r1, [r1, #0x6c]
7009c534: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c538: 4411         	add	r1, r2
7009c53a: aa0e         	add	r2, sp, #0x38
7009c53c: f012 fa80    	bl	0x700aea40 <CSL_bcdmaGetTxRT> @ imm = #0x12500
;             if(FALSE == bcdmaRtStatus.enable)
7009c540: 980e         	ldr	r0, [sp, #0x38]
7009c542: b908         	cbnz	r0, 0x7009c548 <Udma_chDisableTxChan+0x98> @ imm = #0x2
7009c544: e7ff         	b	0x7009c546 <Udma_chDisableTxChan+0x96> @ imm = #-0x2
;                 break;
7009c546: e024         	b	0x7009c592 <Udma_chDisableTxChan+0xe2> @ imm = #0x48
;         }
7009c548: e011         	b	0x7009c56e <Udma_chDisableTxChan+0xbe> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c54a: 9814         	ldr	r0, [sp, #0x50]
7009c54c: 6800         	ldr	r0, [r0]
7009c54e: 2802         	cmp	r0, #0x2
7009c550: d10c         	bne	0x7009c56c <Udma_chDisableTxChan+0xbc> @ imm = #0x18
7009c552: e7ff         	b	0x7009c554 <Udma_chDisableTxChan+0xa4> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c554: 9814         	ldr	r0, [sp, #0x50]
7009c556: 3054         	adds	r0, #0x54
7009c558: 9919         	ldr	r1, [sp, #0x64]
7009c55a: 6ec9         	ldr	r1, [r1, #0x6c]
7009c55c: aa09         	add	r2, sp, #0x24
7009c55e: f010 feff    	bl	0x700ad360 <CSL_pktdmaGetTxRT> @ imm = #0x10dfe
;             if(FALSE == pktdmaRtStatus.enable)
7009c562: 9809         	ldr	r0, [sp, #0x24]
7009c564: b908         	cbnz	r0, 0x7009c56a <Udma_chDisableTxChan+0xba> @ imm = #0x2
7009c566: e7ff         	b	0x7009c568 <Udma_chDisableTxChan+0xb8> @ imm = #-0x2
;                 break;
7009c568: e013         	b	0x7009c592 <Udma_chDisableTxChan+0xe2> @ imm = #0x26
;         }
7009c56a: e7ff         	b	0x7009c56c <Udma_chDisableTxChan+0xbc> @ imm = #-0x2
7009c56c: e7ff         	b	0x7009c56e <Udma_chDisableTxChan+0xbe> @ imm = #-0x2
;         if(currTimeout > timeout)
7009c56e: 9815         	ldr	r0, [sp, #0x54]
7009c570: 9918         	ldr	r1, [sp, #0x60]
7009c572: 4288         	cmp	r0, r1
7009c574: d904         	bls	0x7009c580 <Udma_chDisableTxChan+0xd0> @ imm = #0x8
7009c576: e7ff         	b	0x7009c578 <Udma_chDisableTxChan+0xc8> @ imm = #-0x2
7009c578: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009c57c: 9017         	str	r0, [sp, #0x5c]
;         }
7009c57e: e007         	b	0x7009c590 <Udma_chDisableTxChan+0xe0> @ imm = #0xe
7009c580: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009c584: f00e fd24    	bl	0x700aafd0 <ClockP_usleep> @ imm = #0xea48
;             currTimeout++;
7009c588: 9815         	ldr	r0, [sp, #0x54]
7009c58a: 3001         	adds	r0, #0x1
7009c58c: 9015         	str	r0, [sp, #0x54]
7009c58e: e7ff         	b	0x7009c590 <Udma_chDisableTxChan+0xe0> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c590: e7c3         	b	0x7009c51a <Udma_chDisableTxChan+0x6a> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009c592: 9817         	ldr	r0, [sp, #0x5c]
7009c594: 2800         	cmp	r0, #0x0
7009c596: f000 80e4    	beq.w	0x7009c762 <Udma_chDisableTxChan+0x2b2> @ imm = #0x1c8
7009c59a: e7ff         	b	0x7009c59c <Udma_chDisableTxChan+0xec> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c59c: 9814         	ldr	r0, [sp, #0x50]
7009c59e: 6800         	ldr	r0, [r0]
7009c5a0: 2801         	cmp	r0, #0x1
7009c5a2: d10e         	bne	0x7009c5c2 <Udma_chDisableTxChan+0x112> @ imm = #0x1c
7009c5a4: e7ff         	b	0x7009c5a6 <Udma_chDisableTxChan+0xf6> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)true, (bool)false);
7009c5a6: 9a14         	ldr	r2, [sp, #0x50]
7009c5a8: f102 0008    	add.w	r0, r2, #0x8
7009c5ac: 9919         	ldr	r1, [sp, #0x64]
7009c5ae: 6ec9         	ldr	r1, [r1, #0x6c]
7009c5b0: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c5b4: 4411         	add	r1, r2
7009c5b6: 2201         	movs	r2, #0x1
7009c5b8: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009c5ba: f011 f881    	bl	0x700ad6c0 <CSL_bcdmaTeardownTxChan> @ imm = #0x11102
7009c5be: 9017         	str	r0, [sp, #0x5c]
;         }
7009c5c0: e00f         	b	0x7009c5e2 <Udma_chDisableTxChan+0x132> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c5c2: 9814         	ldr	r0, [sp, #0x50]
7009c5c4: 6800         	ldr	r0, [r0]
7009c5c6: 2802         	cmp	r0, #0x2
7009c5c8: d10a         	bne	0x7009c5e0 <Udma_chDisableTxChan+0x130> @ imm = #0x14
7009c5ca: e7ff         	b	0x7009c5cc <Udma_chDisableTxChan+0x11c> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009c5cc: 9814         	ldr	r0, [sp, #0x50]
7009c5ce: 3054         	adds	r0, #0x54
7009c5d0: 9919         	ldr	r1, [sp, #0x64]
7009c5d2: 6ec9         	ldr	r1, [r1, #0x6c]
7009c5d4: 2201         	movs	r2, #0x1
7009c5d6: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009c5d8: f011 ff3a    	bl	0x700ae450 <CSL_pktdmaTeardownTxChan> @ imm = #0x11e74
7009c5dc: 9017         	str	r0, [sp, #0x5c]
;         }
7009c5de: e7ff         	b	0x7009c5e0 <Udma_chDisableTxChan+0x130> @ imm = #-0x2
7009c5e0: e7ff         	b	0x7009c5e2 <Udma_chDisableTxChan+0x132> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009c5e2: 9817         	ldr	r0, [sp, #0x5c]
7009c5e4: b108         	cbz	r0, 0x7009c5ea <Udma_chDisableTxChan+0x13a> @ imm = #0x2
7009c5e6: e7ff         	b	0x7009c5e8 <Udma_chDisableTxChan+0x138> @ imm = #-0x2
;         }
7009c5e8: e7ff         	b	0x7009c5ea <Udma_chDisableTxChan+0x13a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c5ea: 9814         	ldr	r0, [sp, #0x50]
7009c5ec: 6800         	ldr	r0, [r0]
7009c5ee: 2801         	cmp	r0, #0x1
7009c5f0: d128         	bne	0x7009c644 <Udma_chDisableTxChan+0x194> @ imm = #0x50
7009c5f2: e7ff         	b	0x7009c5f4 <Udma_chDisableTxChan+0x144> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs,
7009c5f4: 9a14         	ldr	r2, [sp, #0x50]
7009c5f6: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c5fa: 9919         	ldr	r1, [sp, #0x64]
7009c5fc: 6ec9         	ldr	r1, [r1, #0x6c]
7009c5fe: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c602: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009c604: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaGetChanPeerReg(
7009c606: 46ec         	mov	r12, sp
7009c608: aa16         	add	r2, sp, #0x58
7009c60a: 9206         	str	r2, [sp, #0x18]
7009c60c: f8cc 2000    	str.w	r2, [r12]
7009c610: 2200         	movs	r2, #0x0
7009c612: 9207         	str	r2, [sp, #0x1c]
7009c614: f011 f91c    	bl	0x700ad850 <CSL_bcdmaGetChanPeerReg> @ imm = #0x11238
7009c618: f8dd c018    	ldr.w	r12, [sp, #0x18]
7009c61c: 9a07         	ldr	r2, [sp, #0x1c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009c61e: 9816         	ldr	r0, [sp, #0x58]
7009c620: f040 5080    	orr	r0, r0, #0x10000000
7009c624: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->bcdmaRegs,
7009c626: 9b14         	ldr	r3, [sp, #0x50]
7009c628: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c62c: 9919         	ldr	r1, [sp, #0x64]
7009c62e: 6ec9         	ldr	r1, [r1, #0x6c]
7009c630: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009c634: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009c636: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009c638: 46ee         	mov	lr, sp
7009c63a: f8ce c000    	str.w	r12, [lr]
7009c63e: f011 fbe7    	bl	0x700ade10 <CSL_bcdmaSetChanPeerReg> @ imm = #0x117ce
;         }
7009c642: e025         	b	0x7009c690 <Udma_chDisableTxChan+0x1e0> @ imm = #0x4a
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c644: 9814         	ldr	r0, [sp, #0x50]
7009c646: 6800         	ldr	r0, [r0]
7009c648: 2802         	cmp	r0, #0x2
7009c64a: d120         	bne	0x7009c68e <Udma_chDisableTxChan+0x1de> @ imm = #0x40
7009c64c: e7ff         	b	0x7009c64e <Udma_chDisableTxChan+0x19e> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs,
7009c64e: 9814         	ldr	r0, [sp, #0x50]
7009c650: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c652: 9919         	ldr	r1, [sp, #0x64]
7009c654: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c656: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaGetChanPeerReg(
7009c658: 46ec         	mov	r12, sp
7009c65a: aa16         	add	r2, sp, #0x58
7009c65c: 9204         	str	r2, [sp, #0x10]
7009c65e: f8cc 2000    	str.w	r2, [r12]
7009c662: 2200         	movs	r2, #0x0
7009c664: 9205         	str	r2, [sp, #0x14]
7009c666: f012 f86b    	bl	0x700ae740 <CSL_pktdmaGetChanPeerReg> @ imm = #0x120d6
7009c66a: f8dd c010    	ldr.w	r12, [sp, #0x10]
7009c66e: 9a05         	ldr	r2, [sp, #0x14]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009c670: 9816         	ldr	r0, [sp, #0x58]
7009c672: f040 5080    	orr	r0, r0, #0x10000000
7009c676: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->pktdmaRegs,
7009c678: 9814         	ldr	r0, [sp, #0x50]
7009c67a: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c67c: 9919         	ldr	r1, [sp, #0x64]
7009c67e: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c680: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009c682: 46ee         	mov	lr, sp
7009c684: f8ce c000    	str.w	r12, [lr]
7009c688: f012 f872    	bl	0x700ae770 <CSL_pktdmaSetChanPeerReg> @ imm = #0x120e4
;         }
7009c68c: e7ff         	b	0x7009c68e <Udma_chDisableTxChan+0x1de> @ imm = #-0x2
7009c68e: e7ff         	b	0x7009c690 <Udma_chDisableTxChan+0x1e0> @ imm = #-0x2
7009c690: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009c692: 9015         	str	r0, [sp, #0x54]
;         while(UDMA_SOK == retVal)
7009c694: e7ff         	b	0x7009c696 <Udma_chDisableTxChan+0x1e6> @ imm = #-0x2
7009c696: 9817         	ldr	r0, [sp, #0x5c]
7009c698: 2800         	cmp	r0, #0x0
7009c69a: d161         	bne	0x7009c760 <Udma_chDisableTxChan+0x2b0> @ imm = #0xc2
7009c69c: e7ff         	b	0x7009c69e <Udma_chDisableTxChan+0x1ee> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c69e: 9814         	ldr	r0, [sp, #0x50]
7009c6a0: 6800         	ldr	r0, [r0]
7009c6a2: 2801         	cmp	r0, #0x1
7009c6a4: d126         	bne	0x7009c6f4 <Udma_chDisableTxChan+0x244> @ imm = #0x4c
7009c6a6: e7ff         	b	0x7009c6a8 <Udma_chDisableTxChan+0x1f8> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c6a8: 9a14         	ldr	r2, [sp, #0x50]
7009c6aa: f102 0008    	add.w	r0, r2, #0x8
7009c6ae: 9919         	ldr	r1, [sp, #0x64]
7009c6b0: 6ec9         	ldr	r1, [r1, #0x6c]
7009c6b2: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c6b6: 4411         	add	r1, r2
7009c6b8: aa0e         	add	r2, sp, #0x38
7009c6ba: f012 f9c1    	bl	0x700aea40 <CSL_bcdmaGetTxRT> @ imm = #0x12382
;                     &drvHandle->bcdmaRegs,
7009c6be: 9a14         	ldr	r2, [sp, #0x50]
7009c6c0: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->txChNum + drvHandle->txChOffset,
7009c6c4: 9919         	ldr	r1, [sp, #0x64]
7009c6c6: 6ec9         	ldr	r1, [r1, #0x6c]
7009c6c8: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c6cc: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009c6ce: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009c6d0: 46ec         	mov	r12, sp
7009c6d2: aa16         	add	r2, sp, #0x58
7009c6d4: f8cc 2000    	str.w	r2, [r12]
7009c6d8: 2200         	movs	r2, #0x0
7009c6da: f011 f8b9    	bl	0x700ad850 <CSL_bcdmaGetChanPeerReg> @ imm = #0x11172
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009c6de: 980e         	ldr	r0, [sp, #0x38]
7009c6e0: b938         	cbnz	r0, 0x7009c6f2 <Udma_chDisableTxChan+0x242> @ imm = #0xe
7009c6e2: e7ff         	b	0x7009c6e4 <Udma_chDisableTxChan+0x234> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009c6e4: 9916         	ldr	r1, [sp, #0x58]
7009c6e6: 2000         	movs	r0, #0x0
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009c6e8: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009c6ec: d101         	bne	0x7009c6f2 <Udma_chDisableTxChan+0x242> @ imm = #0x2
7009c6ee: e7ff         	b	0x7009c6f0 <Udma_chDisableTxChan+0x240> @ imm = #-0x2
;                     break;
7009c6f0: e036         	b	0x7009c760 <Udma_chDisableTxChan+0x2b0> @ imm = #0x6c
;             }
7009c6f2: e023         	b	0x7009c73c <Udma_chDisableTxChan+0x28c> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c6f4: 9814         	ldr	r0, [sp, #0x50]
7009c6f6: 6800         	ldr	r0, [r0]
7009c6f8: 2802         	cmp	r0, #0x2
7009c6fa: d11e         	bne	0x7009c73a <Udma_chDisableTxChan+0x28a> @ imm = #0x3c
7009c6fc: e7ff         	b	0x7009c6fe <Udma_chDisableTxChan+0x24e> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c6fe: 9814         	ldr	r0, [sp, #0x50]
7009c700: 3054         	adds	r0, #0x54
7009c702: 9919         	ldr	r1, [sp, #0x64]
7009c704: 6ec9         	ldr	r1, [r1, #0x6c]
7009c706: aa09         	add	r2, sp, #0x24
7009c708: f010 fe2a    	bl	0x700ad360 <CSL_pktdmaGetTxRT> @ imm = #0x10c54
;                     &drvHandle->pktdmaRegs,
7009c70c: 9814         	ldr	r0, [sp, #0x50]
7009c70e: 3054         	adds	r0, #0x54
;                     chHandle->txChNum,
7009c710: 9919         	ldr	r1, [sp, #0x64]
7009c712: 6ec9         	ldr	r1, [r1, #0x6c]
;                     rtEnableRegOffset, &peerRtEnable);
7009c714: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009c716: 46ec         	mov	r12, sp
7009c718: aa16         	add	r2, sp, #0x58
7009c71a: f8cc 2000    	str.w	r2, [r12]
7009c71e: 2200         	movs	r2, #0x0
7009c720: f012 f80e    	bl	0x700ae740 <CSL_pktdmaGetChanPeerReg> @ imm = #0x1201c
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009c724: 9809         	ldr	r0, [sp, #0x24]
7009c726: b938         	cbnz	r0, 0x7009c738 <Udma_chDisableTxChan+0x288> @ imm = #0xe
7009c728: e7ff         	b	0x7009c72a <Udma_chDisableTxChan+0x27a> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009c72a: 9916         	ldr	r1, [sp, #0x58]
7009c72c: 2000         	movs	r0, #0x0
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009c72e: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009c732: d101         	bne	0x7009c738 <Udma_chDisableTxChan+0x288> @ imm = #0x2
7009c734: e7ff         	b	0x7009c736 <Udma_chDisableTxChan+0x286> @ imm = #-0x2
;                     break;
7009c736: e013         	b	0x7009c760 <Udma_chDisableTxChan+0x2b0> @ imm = #0x26
;             }
7009c738: e7ff         	b	0x7009c73a <Udma_chDisableTxChan+0x28a> @ imm = #-0x2
7009c73a: e7ff         	b	0x7009c73c <Udma_chDisableTxChan+0x28c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009c73c: 9815         	ldr	r0, [sp, #0x54]
7009c73e: 9918         	ldr	r1, [sp, #0x60]
7009c740: 4288         	cmp	r0, r1
7009c742: d904         	bls	0x7009c74e <Udma_chDisableTxChan+0x29e> @ imm = #0x8
7009c744: e7ff         	b	0x7009c746 <Udma_chDisableTxChan+0x296> @ imm = #-0x2
7009c746: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009c74a: 9017         	str	r0, [sp, #0x5c]
;             }
7009c74c: e007         	b	0x7009c75e <Udma_chDisableTxChan+0x2ae> @ imm = #0xe
7009c74e: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009c752: f00e fc3d    	bl	0x700aafd0 <ClockP_usleep> @ imm = #0xe87a
;                 currTimeout++;
7009c756: 9815         	ldr	r0, [sp, #0x54]
7009c758: 3001         	adds	r0, #0x1
7009c75a: 9015         	str	r0, [sp, #0x54]
7009c75c: e7ff         	b	0x7009c75e <Udma_chDisableTxChan+0x2ae> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009c75e: e79a         	b	0x7009c696 <Udma_chDisableTxChan+0x1e6> @ imm = #-0xcc
;     }
7009c760: e7ff         	b	0x7009c762 <Udma_chDisableTxChan+0x2b2> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c762: 9817         	ldr	r0, [sp, #0x5c]
7009c764: 2800         	cmp	r0, #0x0
7009c766: d150         	bne	0x7009c80a <Udma_chDisableTxChan+0x35a> @ imm = #0xa0
7009c768: e7ff         	b	0x7009c76a <Udma_chDisableTxChan+0x2ba> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c76a: 9814         	ldr	r0, [sp, #0x50]
7009c76c: 6800         	ldr	r0, [r0]
7009c76e: 2801         	cmp	r0, #0x1
7009c770: d126         	bne	0x7009c7c0 <Udma_chDisableTxChan+0x310> @ imm = #0x4c
7009c772: e7ff         	b	0x7009c774 <Udma_chDisableTxChan+0x2c4> @ imm = #-0x2
7009c774: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009c776: 9003         	str	r0, [sp, #0xc]
7009c778: 900e         	str	r0, [sp, #0x38]
;             bcdmaRtStatus.teardown = FALSE;
7009c77a: 900f         	str	r0, [sp, #0x3c]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009c77c: 9012         	str	r0, [sp, #0x48]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009c77e: 9816         	ldr	r0, [sp, #0x58]
7009c780: f020 4080    	bic	r0, r0, #0x40000000
7009c784: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c786: 9a14         	ldr	r2, [sp, #0x50]
7009c788: f102 0008    	add.w	r0, r2, #0x8
7009c78c: 9919         	ldr	r1, [sp, #0x64]
7009c78e: 6ec9         	ldr	r1, [r1, #0x6c]
7009c790: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c794: 4411         	add	r1, r2
7009c796: aa0e         	add	r2, sp, #0x38
7009c798: f012 f982    	bl	0x700aeaa0 <CSL_bcdmaSetTxRT> @ imm = #0x12304
7009c79c: 9a03         	ldr	r2, [sp, #0xc]
;                 &drvHandle->bcdmaRegs,
7009c79e: 9b14         	ldr	r3, [sp, #0x50]
7009c7a0: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c7a4: 9919         	ldr	r1, [sp, #0x64]
7009c7a6: 6ec9         	ldr	r1, [r1, #0x6c]
7009c7a8: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009c7ac: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009c7ae: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009c7b0: 46ee         	mov	lr, sp
7009c7b2: f10d 0c58    	add.w	r12, sp, #0x58
7009c7b6: f8ce c000    	str.w	r12, [lr]
7009c7ba: f011 fb29    	bl	0x700ade10 <CSL_bcdmaSetChanPeerReg> @ imm = #0x11652
;         }
7009c7be: e023         	b	0x7009c808 <Udma_chDisableTxChan+0x358> @ imm = #0x46
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c7c0: 9814         	ldr	r0, [sp, #0x50]
7009c7c2: 6800         	ldr	r0, [r0]
7009c7c4: 2802         	cmp	r0, #0x2
7009c7c6: d11e         	bne	0x7009c806 <Udma_chDisableTxChan+0x356> @ imm = #0x3c
7009c7c8: e7ff         	b	0x7009c7ca <Udma_chDisableTxChan+0x31a> @ imm = #-0x2
7009c7ca: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009c7cc: 9002         	str	r0, [sp, #0x8]
7009c7ce: 9009         	str	r0, [sp, #0x24]
;             pktdmaRtStatus.teardown = FALSE;
7009c7d0: 900a         	str	r0, [sp, #0x28]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009c7d2: 900d         	str	r0, [sp, #0x34]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009c7d4: 9816         	ldr	r0, [sp, #0x58]
7009c7d6: f020 4080    	bic	r0, r0, #0x40000000
7009c7da: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c7dc: 9814         	ldr	r0, [sp, #0x50]
7009c7de: 3054         	adds	r0, #0x54
7009c7e0: 9919         	ldr	r1, [sp, #0x64]
7009c7e2: 6ec9         	ldr	r1, [r1, #0x6c]
7009c7e4: aa09         	add	r2, sp, #0x24
7009c7e6: f011 fb73    	bl	0x700aded0 <CSL_pktdmaSetTxRT> @ imm = #0x116e6
7009c7ea: 9a02         	ldr	r2, [sp, #0x8]
;                 &drvHandle->pktdmaRegs,
7009c7ec: 9814         	ldr	r0, [sp, #0x50]
7009c7ee: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c7f0: 9919         	ldr	r1, [sp, #0x64]
7009c7f2: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c7f4: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009c7f6: 46ee         	mov	lr, sp
7009c7f8: f10d 0c58    	add.w	r12, sp, #0x58
7009c7fc: f8ce c000    	str.w	r12, [lr]
7009c800: f011 ffb6    	bl	0x700ae770 <CSL_pktdmaSetChanPeerReg> @ imm = #0x11f6c
;         }
7009c804: e7ff         	b	0x7009c806 <Udma_chDisableTxChan+0x356> @ imm = #-0x2
7009c806: e7ff         	b	0x7009c808 <Udma_chDisableTxChan+0x358> @ imm = #-0x2
;     }
7009c808: e7ff         	b	0x7009c80a <Udma_chDisableTxChan+0x35a> @ imm = #-0x2
;     return (retVal);
7009c80a: 9817         	ldr	r0, [sp, #0x5c]
7009c80c: b01a         	add	sp, #0x68
7009c80e: bd80         	pop	{r7, pc}

7009c810 <Udma_eventConfig>:
; {
7009c810: b580         	push	{r7, lr}
7009c812: b098         	sub	sp, #0x60
7009c814: 9017         	str	r0, [sp, #0x5c]
7009c816: 9116         	str	r1, [sp, #0x58]
7009c818: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009c81a: 9001         	str	r0, [sp, #0x4]
7009c81c: 9015         	str	r0, [sp, #0x54]
;     eventPrms = &eventHandle->eventPrms;
7009c81e: 9916         	ldr	r1, [sp, #0x58]
7009c820: 3108         	adds	r1, #0x8
7009c822: 9110         	str	r1, [sp, #0x40]
;     rmIrqReq.valid_params           = 0U;
7009c824: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.global_event           = 0U;
7009c826: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     rmIrqReq.src_id                 = 0U;
7009c82a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.src_index              = 0U;
7009c82e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.dst_id                 = 0U;
7009c832: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.dst_host_irq           = 0U;
7009c836: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     rmIrqReq.ia_id                  = 0U;
7009c83a: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint                   = 0U;
7009c83e: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009c842: f88d 002a    	strb.w	r0, [sp, #0x2a]
7009c846: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009c848: f88d 002b    	strb.w	r0, [sp, #0x2b]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009c84c: 9810         	ldr	r0, [sp, #0x40]
7009c84e: 6800         	ldr	r0, [r0]
7009c850: 2805         	cmp	r0, #0x5
7009c852: d00a         	beq	0x7009c86a <Udma_eventConfig+0x5a> @ imm = #0x14
7009c854: e7ff         	b	0x7009c856 <Udma_eventConfig+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009c856: 9806         	ldr	r0, [sp, #0x18]
7009c858: f040 0010    	orr	r0, r0, #0x10
7009c85c: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009c85e: 9816         	ldr	r0, [sp, #0x58]
7009c860: f010 fd2e    	bl	0x700ad2c0 <Udma_eventGetId> @ imm = #0x10a5c
7009c864: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     }
7009c868: e7ff         	b	0x7009c86a <Udma_eventConfig+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009c86a: 9816         	ldr	r0, [sp, #0x58]
7009c86c: 6d80         	ldr	r0, [r0, #0x58]
7009c86e: f510 3f80    	cmn.w	r0, #0x10000
7009c872: d012         	beq	0x7009c89a <Udma_eventConfig+0x8a> @ imm = #0x24
7009c874: e7ff         	b	0x7009c876 <Udma_eventConfig+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009c876: 9806         	ldr	r0, [sp, #0x18]
7009c878: f040 0001    	orr	r0, r0, #0x1
7009c87c: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009c87e: 9806         	ldr	r0, [sp, #0x18]
7009c880: f040 0002    	orr	r0, r0, #0x2
7009c884: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.dst_id        = drvHandle->devIdCore;
7009c886: 9817         	ldr	r0, [sp, #0x5c]
7009c888: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009c88c: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmIrqReq.dst_host_irq  = (uint16_t)eventHandle->coreIntrNum;
7009c890: 9816         	ldr	r0, [sp, #0x58]
7009c892: 6d80         	ldr	r0, [r0, #0x58]
7009c894: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     }
7009c898: e7ff         	b	0x7009c89a <Udma_eventConfig+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009c89a: 9816         	ldr	r0, [sp, #0x58]
7009c89c: 6980         	ldr	r0, [r0, #0x18]
7009c89e: b128         	cbz	r0, 0x7009c8ac <Udma_eventConfig+0x9c> @ imm = #0xa
7009c8a0: e7ff         	b	0x7009c8a2 <Udma_eventConfig+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009c8a2: 9816         	ldr	r0, [sp, #0x58]
7009c8a4: 6980         	ldr	r0, [r0, #0x18]
7009c8a6: 6cc0         	ldr	r0, [r0, #0x4c]
7009c8a8: 9014         	str	r0, [sp, #0x50]
;     }
7009c8aa: e003         	b	0x7009c8b4 <Udma_eventConfig+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009c8ac: 9816         	ldr	r0, [sp, #0x58]
7009c8ae: 6cc0         	ldr	r0, [r0, #0x4c]
7009c8b0: 9014         	str	r0, [sp, #0x50]
7009c8b2: e7ff         	b	0x7009c8b4 <Udma_eventConfig+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009c8b4: 9806         	ldr	r0, [sp, #0x18]
7009c8b6: f040 0004    	orr	r0, r0, #0x4
7009c8ba: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009c8bc: 9806         	ldr	r0, [sp, #0x18]
7009c8be: f040 0008    	orr	r0, r0, #0x8
7009c8c2: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009c8c4: 9817         	ldr	r0, [sp, #0x5c]
7009c8c6: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009c8ca: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009c8ce: 9814         	ldr	r0, [sp, #0x50]
7009c8d0: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009c8d4: 9816         	ldr	r0, [sp, #0x58]
7009c8d6: 6d00         	ldr	r0, [r0, #0x50]
7009c8d8: f64f 71ff    	movw	r1, #0xffff
7009c8dc: 4288         	cmp	r0, r1
7009c8de: d009         	beq	0x7009c8f4 <Udma_eventConfig+0xe4> @ imm = #0x12
7009c8e0: e7ff         	b	0x7009c8e2 <Udma_eventConfig+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009c8e2: 9806         	ldr	r0, [sp, #0x18]
7009c8e4: f040 0020    	orr	r0, r0, #0x20
7009c8e8: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009c8ea: 9816         	ldr	r0, [sp, #0x58]
7009c8ec: 6d00         	ldr	r0, [r0, #0x50]
7009c8ee: f88d 002a    	strb.w	r0, [sp, #0x2a]
;     }
7009c8f2: e7ff         	b	0x7009c8f4 <Udma_eventConfig+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009c8f4: 9810         	ldr	r0, [sp, #0x40]
7009c8f6: 6800         	ldr	r0, [r0]
7009c8f8: 2801         	cmp	r0, #0x1
7009c8fa: d00a         	beq	0x7009c912 <Udma_eventConfig+0x102> @ imm = #0x14
7009c8fc: e7ff         	b	0x7009c8fe <Udma_eventConfig+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
7009c8fe: 9810         	ldr	r0, [sp, #0x40]
7009c900: 6800         	ldr	r0, [r0]
7009c902: 2802         	cmp	r0, #0x2
7009c904: d005         	beq	0x7009c912 <Udma_eventConfig+0x102> @ imm = #0xa
7009c906: e7ff         	b	0x7009c908 <Udma_eventConfig+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009c908: 9810         	ldr	r0, [sp, #0x40]
7009c90a: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009c90c: 2806         	cmp	r0, #0x6
7009c90e: d14d         	bne	0x7009c9ac <Udma_eventConfig+0x19c> @ imm = #0x9a
7009c910: e7ff         	b	0x7009c912 <Udma_eventConfig+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009c912: 9810         	ldr	r0, [sp, #0x40]
7009c914: 6880         	ldr	r0, [r0, #0x8]
7009c916: 9012         	str	r0, [sp, #0x48]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009c918: 9817         	ldr	r0, [sp, #0x5c]
7009c91a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009c91e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009c922: 9810         	ldr	r0, [sp, #0x40]
7009c924: 6800         	ldr	r0, [r0]
7009c926: 2801         	cmp	r0, #0x1
7009c928: d005         	beq	0x7009c936 <Udma_eventConfig+0x126> @ imm = #0xa
7009c92a: e7ff         	b	0x7009c92c <Udma_eventConfig+0x11c> @ imm = #-0x2
7009c92c: 9810         	ldr	r0, [sp, #0x40]
7009c92e: 6800         	ldr	r0, [r0]
7009c930: 2806         	cmp	r0, #0x6
7009c932: d12e         	bne	0x7009c992 <Udma_eventConfig+0x182> @ imm = #0x5c
7009c934: e7ff         	b	0x7009c936 <Udma_eventConfig+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009c936: 9812         	ldr	r0, [sp, #0x48]
7009c938: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009c93c: 8880         	ldrh	r0, [r0, #0x4]
7009c93e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009c942: 9812         	ldr	r0, [sp, #0x48]
7009c944: 7800         	ldrb	r0, [r0]
7009c946: 0740         	lsls	r0, r0, #0x1d
7009c948: 2800         	cmp	r0, #0x0
7009c94a: d509         	bpl	0x7009c960 <Udma_eventConfig+0x150> @ imm = #0x12
7009c94c: e7ff         	b	0x7009c94e <Udma_eventConfig+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009c94e: 9817         	ldr	r0, [sp, #0x5c]
7009c950: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009c954: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009c958: 4408         	add	r0, r1
7009c95a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009c95e: e017         	b	0x7009c990 <Udma_eventConfig+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009c960: 9812         	ldr	r0, [sp, #0x48]
7009c962: 7800         	ldrb	r0, [r0]
7009c964: 07c0         	lsls	r0, r0, #0x1f
7009c966: b148         	cbz	r0, 0x7009c97c <Udma_eventConfig+0x16c> @ imm = #0x12
7009c968: e7ff         	b	0x7009c96a <Udma_eventConfig+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009c96a: 9817         	ldr	r0, [sp, #0x5c]
7009c96c: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009c970: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009c974: 4408         	add	r0, r1
7009c976: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009c97a: e008         	b	0x7009c98e <Udma_eventConfig+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009c97c: 9817         	ldr	r0, [sp, #0x5c]
7009c97e: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009c982: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009c986: 4408         	add	r0, r1
7009c988: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009c98c: e7ff         	b	0x7009c98e <Udma_eventConfig+0x17e> @ imm = #-0x2
7009c98e: e7ff         	b	0x7009c990 <Udma_eventConfig+0x180> @ imm = #-0x2
;         }
7009c990: e00b         	b	0x7009c9aa <Udma_eventConfig+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009c992: 9812         	ldr	r0, [sp, #0x48]
7009c994: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009c998: 8880         	ldrh	r0, [r0, #0x4]
7009c99a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009c99e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009c9a2: 3014         	adds	r0, #0x14
7009c9a4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009c9a8: e7ff         	b	0x7009c9aa <Udma_eventConfig+0x19a> @ imm = #-0x2
;     }
7009c9aa: e7ff         	b	0x7009c9ac <Udma_eventConfig+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009c9ac: 9810         	ldr	r0, [sp, #0x40]
7009c9ae: 6800         	ldr	r0, [r0]
7009c9b0: 2803         	cmp	r0, #0x3
7009c9b2: d156         	bne	0x7009ca62 <Udma_eventConfig+0x252> @ imm = #0xac
7009c9b4: e7ff         	b	0x7009c9b6 <Udma_eventConfig+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c9b6: 9817         	ldr	r0, [sp, #0x5c]
7009c9b8: 6800         	ldr	r0, [r0]
7009c9ba: 2802         	cmp	r0, #0x2
7009c9bc: d104         	bne	0x7009c9c8 <Udma_eventConfig+0x1b8> @ imm = #0x8
7009c9be: e7ff         	b	0x7009c9c0 <Udma_eventConfig+0x1b0> @ imm = #-0x2
7009c9c0: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009c9c4: 9015         	str	r0, [sp, #0x54]
;         }
7009c9c6: e04b         	b	0x7009ca60 <Udma_eventConfig+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009c9c8: 9810         	ldr	r0, [sp, #0x40]
7009c9ca: 6880         	ldr	r0, [r0, #0x8]
7009c9cc: 9012         	str	r0, [sp, #0x48]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009c9ce: 9817         	ldr	r0, [sp, #0x5c]
7009c9d0: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009c9d4: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009c9d8: 9812         	ldr	r0, [sp, #0x48]
7009c9da: 7800         	ldrb	r0, [r0]
7009c9dc: 0740         	lsls	r0, r0, #0x1d
7009c9de: 2800         	cmp	r0, #0x0
7009c9e0: d50d         	bpl	0x7009c9fe <Udma_eventConfig+0x1ee> @ imm = #0x1a
7009c9e2: e7ff         	b	0x7009c9e4 <Udma_eventConfig+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009c9e4: 9812         	ldr	r0, [sp, #0x48]
7009c9e6: 6ec0         	ldr	r0, [r0, #0x6c]
7009c9e8: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009c9ec: 9817         	ldr	r0, [sp, #0x5c]
7009c9ee: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009c9f2: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009c9f6: 4408         	add	r0, r1
7009c9f8: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009c9fc: e02f         	b	0x7009ca5e <Udma_eventConfig+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009c9fe: 9812         	ldr	r0, [sp, #0x48]
7009ca00: 7800         	ldrb	r0, [r0]
7009ca02: 0780         	lsls	r0, r0, #0x1e
7009ca04: 2800         	cmp	r0, #0x0
7009ca06: d50d         	bpl	0x7009ca24 <Udma_eventConfig+0x214> @ imm = #0x1a
7009ca08: e7ff         	b	0x7009ca0a <Udma_eventConfig+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009ca0a: 9812         	ldr	r0, [sp, #0x48]
7009ca0c: 6f00         	ldr	r0, [r0, #0x70]
7009ca0e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009ca12: 9817         	ldr	r0, [sp, #0x5c]
7009ca14: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009ca18: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009ca1c: 4408         	add	r0, r1
7009ca1e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009ca22: e01b         	b	0x7009ca5c <Udma_eventConfig+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009ca24: 9812         	ldr	r0, [sp, #0x48]
7009ca26: 7800         	ldrb	r0, [r0]
7009ca28: 07c0         	lsls	r0, r0, #0x1f
7009ca2a: b168         	cbz	r0, 0x7009ca48 <Udma_eventConfig+0x238> @ imm = #0x1a
7009ca2c: e7ff         	b	0x7009ca2e <Udma_eventConfig+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009ca2e: 9812         	ldr	r0, [sp, #0x48]
7009ca30: 6ec0         	ldr	r0, [r0, #0x6c]
7009ca32: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009ca36: 9817         	ldr	r0, [sp, #0x5c]
7009ca38: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009ca3c: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009ca40: 4408         	add	r0, r1
7009ca42: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009ca46: e008         	b	0x7009ca5a <Udma_eventConfig+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009ca48: 9817         	ldr	r0, [sp, #0x5c]
7009ca4a: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009ca4e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009ca52: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009ca54: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009ca58: e7ff         	b	0x7009ca5a <Udma_eventConfig+0x24a> @ imm = #-0x2
7009ca5a: e7ff         	b	0x7009ca5c <Udma_eventConfig+0x24c> @ imm = #-0x2
7009ca5c: e7ff         	b	0x7009ca5e <Udma_eventConfig+0x24e> @ imm = #-0x2
7009ca5e: e7ff         	b	0x7009ca60 <Udma_eventConfig+0x250> @ imm = #-0x2
;     }
7009ca60: e7ff         	b	0x7009ca62 <Udma_eventConfig+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009ca62: 9810         	ldr	r0, [sp, #0x40]
7009ca64: 6800         	ldr	r0, [r0]
7009ca66: 2804         	cmp	r0, #0x4
7009ca68: d130         	bne	0x7009cacc <Udma_eventConfig+0x2bc> @ imm = #0x60
7009ca6a: e7ff         	b	0x7009ca6c <Udma_eventConfig+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009ca6c: 9810         	ldr	r0, [sp, #0x40]
7009ca6e: 68c0         	ldr	r0, [r0, #0xc]
7009ca70: 9011         	str	r0, [sp, #0x44]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009ca72: 9817         	ldr	r0, [sp, #0x5c]
7009ca74: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009ca78: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009ca7c: 9811         	ldr	r0, [sp, #0x44]
7009ca7e: 8880         	ldrh	r0, [r0, #0x4]
7009ca80: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009ca84: 9817         	ldr	r0, [sp, #0x5c]
7009ca86: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009ca8a: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009ca8e: 4408         	add	r0, r1
7009ca90: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009ca94: 9811         	ldr	r0, [sp, #0x44]
7009ca96: 6dc0         	ldr	r0, [r0, #0x5c]
7009ca98: 2804         	cmp	r0, #0x4
7009ca9a: d316         	blo	0x7009caca <Udma_eventConfig+0x2ba> @ imm = #0x2c
7009ca9c: e7ff         	b	0x7009ca9e <Udma_eventConfig+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009ca9e: 9811         	ldr	r0, [sp, #0x44]
7009caa0: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009caa2: 2807         	cmp	r0, #0x7
7009caa4: d811         	bhi	0x7009caca <Udma_eventConfig+0x2ba> @ imm = #0x22
7009caa6: e7ff         	b	0x7009caa8 <Udma_eventConfig+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009caa8: 9817         	ldr	r0, [sp, #0x5c]
7009caaa: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009caae: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cab2: 1a40         	subs	r0, r0, r1
7009cab4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009cab8: 9817         	ldr	r0, [sp, #0x5c]
7009caba: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009cabe: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cac2: 4408         	add	r0, r1
7009cac4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         }
7009cac8: e7ff         	b	0x7009caca <Udma_eventConfig+0x2ba> @ imm = #-0x2
;     }
7009caca: e7ff         	b	0x7009cacc <Udma_eventConfig+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009cacc: 9815         	ldr	r0, [sp, #0x54]
7009cace: b9d8         	cbnz	r0, 0x7009cb08 <Udma_eventConfig+0x2f8> @ imm = #0x36
7009cad0: e7ff         	b	0x7009cad2 <Udma_eventConfig+0x2c2> @ imm = #-0x2
;         Udma_eventProgramSteering(drvHandle, eventHandle);
7009cad2: 9817         	ldr	r0, [sp, #0x5c]
7009cad4: 9916         	ldr	r1, [sp, #0x58]
7009cad6: f012 f963    	bl	0x700aeda0 <Udma_eventProgramSteering> @ imm = #0x122c6
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009cada: 9817         	ldr	r0, [sp, #0x5c]
7009cadc: 6800         	ldr	r0, [r0]
7009cade: b130         	cbz	r0, 0x7009caee <Udma_eventConfig+0x2de> @ imm = #0xc
7009cae0: e7ff         	b	0x7009cae2 <Udma_eventConfig+0x2d2> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009cae2: 9810         	ldr	r0, [sp, #0x40]
7009cae4: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009cae6: 2805         	cmp	r0, #0x5
7009cae8: d101         	bne	0x7009caee <Udma_eventConfig+0x2de> @ imm = #0x2
7009caea: e7ff         	b	0x7009caec <Udma_eventConfig+0x2dc> @ imm = #-0x2
;         }
7009caec: e00b         	b	0x7009cb06 <Udma_eventConfig+0x2f6> @ imm = #0x16
7009caee: a804         	add	r0, sp, #0x10
7009caf0: a902         	add	r1, sp, #0x8
7009caf2: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmIrqSet(
7009caf6: f012 fda3    	bl	0x700af640 <Sciclient_rmIrqSet> @ imm = #0x12b46
7009cafa: 9015         	str	r0, [sp, #0x54]
;             if(CSL_PASS != retVal)
7009cafc: 9815         	ldr	r0, [sp, #0x54]
7009cafe: b108         	cbz	r0, 0x7009cb04 <Udma_eventConfig+0x2f4> @ imm = #0x2
7009cb00: e7ff         	b	0x7009cb02 <Udma_eventConfig+0x2f2> @ imm = #-0x2
;             }
7009cb02: e7ff         	b	0x7009cb04 <Udma_eventConfig+0x2f4> @ imm = #-0x2
7009cb04: e7ff         	b	0x7009cb06 <Udma_eventConfig+0x2f6> @ imm = #-0x2
;     }
7009cb06: e7ff         	b	0x7009cb08 <Udma_eventConfig+0x2f8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009cb08: 9815         	ldr	r0, [sp, #0x54]
7009cb0a: bb58         	cbnz	r0, 0x7009cb64 <Udma_eventConfig+0x354> @ imm = #0x56
7009cb0c: e7ff         	b	0x7009cb0e <Udma_eventConfig+0x2fe> @ imm = #-0x2
;         if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009cb0e: 9816         	ldr	r0, [sp, #0x58]
7009cb10: 6d80         	ldr	r0, [r0, #0x58]
7009cb12: f510 3f80    	cmn.w	r0, #0x10000
7009cb16: d024         	beq	0x7009cb62 <Udma_eventConfig+0x352> @ imm = #0x48
7009cb18: e7ff         	b	0x7009cb1a <Udma_eventConfig+0x30a> @ imm = #-0x2
;             coreIntrNum = eventHandle->coreIntrNum;
7009cb1a: 9816         	ldr	r0, [sp, #0x58]
7009cb1c: 6d80         	ldr	r0, [r0, #0x58]
7009cb1e: 9013         	str	r0, [sp, #0x4c]
7009cb20: a80b         	add	r0, sp, #0x2c
;             HwiP_Params_init(&hwiPrms);
7009cb22: 9000         	str	r0, [sp]
7009cb24: f013 f9f4    	bl	0x700aff10 <HwiP_Params_init> @ imm = #0x133e8
7009cb28: 9900         	ldr	r1, [sp]
;             hwiPrms.intNum = coreIntrNum;
7009cb2a: 9813         	ldr	r0, [sp, #0x4c]
7009cb2c: 900b         	str	r0, [sp, #0x2c]
;             hwiPrms.callback = &Udma_eventIsrFxn;
7009cb2e: f645 0081    	movw	r0, #0x5881
7009cb32: f2c7 000a    	movt	r0, #0x700a
7009cb36: 900c         	str	r0, [sp, #0x30]
;             hwiPrms.args = eventHandle;
7009cb38: 9816         	ldr	r0, [sp, #0x58]
7009cb3a: 900d         	str	r0, [sp, #0x34]
;             hwiPrms.priority = eventHandle->eventPrms.intrPriority;
7009cb3c: 9816         	ldr	r0, [sp, #0x58]
7009cb3e: 6a00         	ldr	r0, [r0, #0x20]
7009cb40: f88d 003a    	strb.w	r0, [sp, #0x3a]
;             retVal = HwiP_construct(&eventHandle->hwiObject, &hwiPrms);
7009cb44: 9816         	ldr	r0, [sp, #0x58]
7009cb46: 3068         	adds	r0, #0x68
7009cb48: f013 f9fa    	bl	0x700aff40 <HwiP_construct> @ imm = #0x133f4
7009cb4c: 9015         	str	r0, [sp, #0x54]
;             if(SystemP_SUCCESS != retVal)
7009cb4e: 9815         	ldr	r0, [sp, #0x54]
7009cb50: b108         	cbz	r0, 0x7009cb56 <Udma_eventConfig+0x346> @ imm = #0x2
7009cb52: e7ff         	b	0x7009cb54 <Udma_eventConfig+0x344> @ imm = #-0x2
;             }
7009cb54: e004         	b	0x7009cb60 <Udma_eventConfig+0x350> @ imm = #0x8
;                 eventHandle->hwiHandle = &eventHandle->hwiObject;
7009cb56: 9916         	ldr	r1, [sp, #0x58]
7009cb58: f101 0068    	add.w	r0, r1, #0x68
7009cb5c: 6648         	str	r0, [r1, #0x64]
7009cb5e: e7ff         	b	0x7009cb60 <Udma_eventConfig+0x350> @ imm = #-0x2
;         }
7009cb60: e7ff         	b	0x7009cb62 <Udma_eventConfig+0x352> @ imm = #-0x2
;     }
7009cb62: e7ff         	b	0x7009cb64 <Udma_eventConfig+0x354> @ imm = #-0x2
;     return (retVal);
7009cb64: 9815         	ldr	r0, [sp, #0x54]
7009cb66: b018         	add	sp, #0x60
7009cb68: bd80         	pop	{r7, pc}
7009cb6a: 0000         	movs	r0, r0
7009cb6c: 0000         	movs	r0, r0
7009cb6e: 0000         	movs	r0, r0

7009cb70 <Sciclient_rmIrqGetRoute>:
; {
7009cb70: b580         	push	{r7, lr}
7009cb72: b08e         	sub	sp, #0x38
7009cb74: 900d         	str	r0, [sp, #0x34]
7009cb76: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009cb78: 900c         	str	r0, [sp, #0x30]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cb7a: 980d         	ldr	r0, [sp, #0x34]
7009cb7c: 88c0         	ldrh	r0, [r0, #0x6]
7009cb7e: f011 fe87    	bl	0x700ae890 <Sciclient_rmIrIsIr> @ imm = #0x11d0e
7009cb82: b930         	cbnz	r0, 0x7009cb92 <Sciclient_rmIrqGetRoute+0x22> @ imm = #0xc
7009cb84: e7ff         	b	0x7009cb86 <Sciclient_rmIrqGetRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009cb86: 980d         	ldr	r0, [sp, #0x34]
7009cb88: 8940         	ldrh	r0, [r0, #0xa]
7009cb8a: f011 fe81    	bl	0x700ae890 <Sciclient_rmIrIsIr> @ imm = #0x11d02
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cb8e: b120         	cbz	r0, 0x7009cb9a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #0x8
7009cb90: e7ff         	b	0x7009cb92 <Sciclient_rmIrqGetRoute+0x22> @ imm = #-0x2
7009cb92: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009cb96: 900c         	str	r0, [sp, #0x30]
;     }
7009cb98: e7ff         	b	0x7009cb9a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cb9a: 980c         	ldr	r0, [sp, #0x30]
7009cb9c: 2800         	cmp	r0, #0x0
7009cb9e: d156         	bne	0x7009cc4e <Sciclient_rmIrqGetRoute+0xde> @ imm = #0xac
7009cba0: e7ff         	b	0x7009cba2 <Sciclient_rmIrqGetRoute+0x32> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cba2: 980d         	ldr	r0, [sp, #0x34]
7009cba4: 8a00         	ldrh	r0, [r0, #0x10]
7009cba6: 28ff         	cmp	r0, #0xff
7009cba8: d042         	beq	0x7009cc30 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x84
7009cbaa: e7ff         	b	0x7009cbac <Sciclient_rmIrqGetRoute+0x3c> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cbac: 980d         	ldr	r0, [sp, #0x34]
7009cbae: 6800         	ldr	r0, [r0]
7009cbb0: 2104         	movs	r1, #0x4
7009cbb2: f012 f84d    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x1209a
;              true) &&
7009cbb6: b3d8         	cbz	r0, 0x7009cc30 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x76
7009cbb8: e7ff         	b	0x7009cbba <Sciclient_rmIrqGetRoute+0x4a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cbba: 980d         	ldr	r0, [sp, #0x34]
7009cbbc: 6800         	ldr	r0, [r0]
7009cbbe: 2108         	movs	r1, #0x8
7009cbc0: f012 f846    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x1208c
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cbc4: b3a0         	cbz	r0, 0x7009cc30 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x68
7009cbc6: e7ff         	b	0x7009cbc8 <Sciclient_rmIrqGetRoute+0x58> @ imm = #-0x2
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009cbc8: 980d         	ldr	r0, [sp, #0x34]
7009cbca: 6800         	ldr	r0, [r0]
7009cbcc: 2110         	movs	r1, #0x10
7009cbce: f012 f83f    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x1207e
;                  true) &&
7009cbd2: b1d0         	cbz	r0, 0x7009cc0a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x34
7009cbd4: e7ff         	b	0x7009cbd6 <Sciclient_rmIrqGetRoute+0x66> @ imm = #-0x2
;                 (Sciclient_rmParamIsValid(cfg->valid_params,
7009cbd6: 980d         	ldr	r0, [sp, #0x34]
7009cbd8: 6800         	ldr	r0, [r0]
7009cbda: 2120         	movs	r1, #0x20
7009cbdc: f012 f838    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x12070
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009cbe0: b198         	cbz	r0, 0x7009cc0a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x26
7009cbe2: e7ff         	b	0x7009cbe4 <Sciclient_rmIrqGetRoute+0x74> @ imm = #-0x2
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009cbe4: f8dd c034    	ldr.w	r12, [sp, #0x34]
7009cbe8: f8bc 1010    	ldrh.w	r1, [r12, #0x10]
;                                cfg->vint, cfg->global_evt,
7009cbec: f8bc 2012    	ldrh.w	r2, [r12, #0x12]
7009cbf0: f8bc 300e    	ldrh.w	r3, [r12, #0xe]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009cbf4: f89c 0004    	ldrb.w	r0, [r12, #0x4]
;                                cfg->vint_sb);
7009cbf8: f89c c014    	ldrb.w	r12, [r12, #0x14]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009cbfc: 46ee         	mov	lr, sp
7009cbfe: f8ce c000    	str.w	r12, [lr]
7009cc02: f005 fd0d    	bl	0x700a2620 <Sciclient_rmIaValidateMapping> @ imm = #0x5a1a
7009cc06: 900c         	str	r0, [sp, #0x30]
;             }
7009cc08: e7ff         	b	0x7009cc0a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #-0x2
;             if (r == SystemP_SUCCESS) {
7009cc0a: 980c         	ldr	r0, [sp, #0x30]
7009cc0c: b978         	cbnz	r0, 0x7009cc2e <Sciclient_rmIrqGetRoute+0xbe> @ imm = #0x1e
7009cc0e: e7ff         	b	0x7009cc10 <Sciclient_rmIrqGetRoute+0xa0> @ imm = #-0x2
;                 inp = cfg->global_evt;
7009cc10: 980d         	ldr	r0, [sp, #0x34]
7009cc12: 89c0         	ldrh	r0, [r0, #0xe]
7009cc14: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = cfg->vint;
7009cc18: 980d         	ldr	r0, [sp, #0x34]
7009cc1a: 8a40         	ldrh	r0, [r0, #0x12]
7009cc1c: f8ad 0024    	strh.w	r0, [sp, #0x24]
;                 r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009cc20: 980d         	ldr	r0, [sp, #0x34]
7009cc22: 8a00         	ldrh	r0, [r0, #0x10]
7009cc24: a906         	add	r1, sp, #0x18
7009cc26: f009 f883    	bl	0x700a5d30 <Sciclient_rmIrqGetNode> @ imm = #0x9106
7009cc2a: 900c         	str	r0, [sp, #0x30]
;             }
7009cc2c: e7ff         	b	0x7009cc2e <Sciclient_rmIrqGetRoute+0xbe> @ imm = #-0x2
;         } else {
7009cc2e: e00d         	b	0x7009cc4c <Sciclient_rmIrqGetRoute+0xdc> @ imm = #0x1a
7009cc30: 2000         	movs	r0, #0x0
;             inp = 0u;
7009cc32: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             outp = cfg->s_idx;
7009cc36: 980d         	ldr	r0, [sp, #0x34]
7009cc38: 8900         	ldrh	r0, [r0, #0x8]
7009cc3a: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009cc3e: 980d         	ldr	r0, [sp, #0x34]
7009cc40: 88c0         	ldrh	r0, [r0, #0x6]
7009cc42: a906         	add	r1, sp, #0x18
7009cc44: f009 f874    	bl	0x700a5d30 <Sciclient_rmIrqGetNode> @ imm = #0x90e8
7009cc48: 900c         	str	r0, [sp, #0x30]
7009cc4a: e7ff         	b	0x7009cc4c <Sciclient_rmIrqGetRoute+0xdc> @ imm = #-0x2
;     }
7009cc4c: e7ff         	b	0x7009cc4e <Sciclient_rmIrqGetRoute+0xde> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cc4e: 980c         	ldr	r0, [sp, #0x30]
7009cc50: b948         	cbnz	r0, 0x7009cc66 <Sciclient_rmIrqGetRoute+0xf6> @ imm = #0x12
7009cc52: e7ff         	b	0x7009cc54 <Sciclient_rmIrqGetRoute+0xe4> @ imm = #-0x2
7009cc54: 2001         	movs	r0, #0x1
;         search = true;
7009cc56: f88d 0021    	strb.w	r0, [sp, #0x21]
7009cc5a: 2000         	movs	r0, #0x0
;         rt_complete = false;
7009cc5c: f88d 0020    	strb.w	r0, [sp, #0x20]
;         Sciclient_rmPsInit();
7009cc60: f012 fbbe    	bl	0x700af3e0 <Sciclient_rmPsInit> @ imm = #0x1277c
;     } else {
7009cc64: e003         	b	0x7009cc6e <Sciclient_rmIrqGetRoute+0xfe> @ imm = #0x6
7009cc66: 2000         	movs	r0, #0x0
;         search = false;
7009cc68: f88d 0021    	strb.w	r0, [sp, #0x21]
7009cc6c: e7ff         	b	0x7009cc6e <Sciclient_rmIrqGetRoute+0xfe> @ imm = #-0x2
7009cc6e: 2000         	movs	r0, #0x0
;     for (search_depth = 0u;
7009cc70: f8ad 002e    	strh.w	r0, [sp, #0x2e]
7009cc74: e7ff         	b	0x7009cc76 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x2
;          (search_depth < Sciclient_rmPsGetMaxPsp()) && (search == true);
7009cc76: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cc7a: 9002         	str	r0, [sp, #0x8]
7009cc7c: f013 f838    	bl	0x700afcf0 <Sciclient_rmPsGetMaxPsp> @ imm = #0x13070
7009cc80: 9902         	ldr	r1, [sp, #0x8]
7009cc82: 4602         	mov	r2, r0
7009cc84: 2000         	movs	r0, #0x0
7009cc86: 4291         	cmp	r1, r2
7009cc88: 9003         	str	r0, [sp, #0xc]
7009cc8a: da06         	bge	0x7009cc9a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #0xc
7009cc8c: e7ff         	b	0x7009cc8e <Sciclient_rmIrqGetRoute+0x11e> @ imm = #-0x2
7009cc8e: f89d 0021    	ldrb.w	r0, [sp, #0x21]
7009cc92: f000 0001    	and	r0, r0, #0x1
7009cc96: 9003         	str	r0, [sp, #0xc]
7009cc98: e7ff         	b	0x7009cc9a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #-0x2
7009cc9a: 9803         	ldr	r0, [sp, #0xc]
;     for (search_depth = 0u;
7009cc9c: 07c0         	lsls	r0, r0, #0x1f
7009cc9e: 2800         	cmp	r0, #0x0
7009cca0: f000 80d8    	beq.w	0x7009ce54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x1b0
7009cca4: e7ff         	b	0x7009cca6 <Sciclient_rmIrqGetRoute+0x136> @ imm = #-0x2
7009cca6: 2000         	movs	r0, #0x0
;         push_node = false;
7009cca8: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009ccac: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009ccb0: e7ff         	b	0x7009ccb2 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0x2
7009ccb2: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009ccb6: 9906         	ldr	r1, [sp, #0x18]
7009ccb8: 8849         	ldrh	r1, [r1, #0x2]
7009ccba: 4288         	cmp	r0, r1
7009ccbc: da6b         	bge	0x7009cd96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xd6
7009ccbe: e7ff         	b	0x7009ccc0 <Sciclient_rmIrqGetRoute+0x150> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009ccc0: 9806         	ldr	r0, [sp, #0x18]
7009ccc2: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009ccc6: aa04         	add	r2, sp, #0x10
7009ccc8: f010 fe62    	bl	0x700ad990 <Sciclient_rmIrqGetNodeItf> @ imm = #0x10cc4
7009cccc: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009ccce: 980c         	ldr	r0, [sp, #0x30]
7009ccd0: b108         	cbz	r0, 0x7009ccd6 <Sciclient_rmIrqGetRoute+0x166> @ imm = #0x2
7009ccd2: e7ff         	b	0x7009ccd4 <Sciclient_rmIrqGetRoute+0x164> @ imm = #-0x2
;                 break;
7009ccd4: e05f         	b	0x7009cd96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xbe
;             if ((outp >= cur_if->lbase) &&
7009ccd6: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009ccda: 9904         	ldr	r1, [sp, #0x10]
7009ccdc: 8809         	ldrh	r1, [r1]
7009ccde: 4288         	cmp	r0, r1
7009cce0: db52         	blt	0x7009cd88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0xa4
7009cce2: e7ff         	b	0x7009cce4 <Sciclient_rmIrqGetRoute+0x174> @ imm = #-0x2
;                 (outp < (cur_if->lbase + cur_if->len))) {
7009cce4: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009cce8: 9a04         	ldr	r2, [sp, #0x10]
7009ccea: 8811         	ldrh	r1, [r2]
7009ccec: 8892         	ldrh	r2, [r2, #0x4]
7009ccee: 4411         	add	r1, r2
;             if ((outp >= cur_if->lbase) &&
7009ccf0: 4288         	cmp	r0, r1
7009ccf2: da49         	bge	0x7009cd88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0x92
7009ccf4: e7ff         	b	0x7009ccf6 <Sciclient_rmIrqGetRoute+0x186> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
7009ccf6: 9804         	ldr	r0, [sp, #0x10]
7009ccf8: 88c0         	ldrh	r0, [r0, #0x6]
7009ccfa: 990d         	ldr	r1, [sp, #0x34]
7009ccfc: 8949         	ldrh	r1, [r1, #0xa]
7009ccfe: 4288         	cmp	r0, r1
7009cd00: d110         	bne	0x7009cd24 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x20
7009cd02: e7ff         	b	0x7009cd04 <Sciclient_rmIrqGetRoute+0x194> @ imm = #-0x2
;                     (SCICLIENT_OUTP_TO_INP(outp, cur_if->lbase,
7009cd04: 9a04         	ldr	r2, [sp, #0x10]
7009cd06: 8850         	ldrh	r0, [r2, #0x2]
7009cd08: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009cd0c: 8812         	ldrh	r2, [r2]
7009cd0e: 1a89         	subs	r1, r1, r2
7009cd10: 4408         	add	r0, r1
;                      cfg->d_irq)) {
7009cd12: 990d         	ldr	r1, [sp, #0x34]
7009cd14: 8989         	ldrh	r1, [r1, #0xc]
;                 if ((cur_if->rid == cfg->d_id) &&
7009cd16: 4288         	cmp	r0, r1
7009cd18: d104         	bne	0x7009cd24 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x8
7009cd1a: e7ff         	b	0x7009cd1c <Sciclient_rmIrqGetRoute+0x1ac> @ imm = #-0x2
7009cd1c: 2001         	movs	r0, #0x1
;                     rt_complete = true;
7009cd1e: f88d 0020    	strb.w	r0, [sp, #0x20]
;                     break;
7009cd22: e038         	b	0x7009cd96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x70
;                 if (Sciclient_rmIrIsIr(cur_if->rid) == true) {
7009cd24: 9804         	ldr	r0, [sp, #0x10]
7009cd26: 88c0         	ldrh	r0, [r0, #0x6]
7009cd28: f011 fdb2    	bl	0x700ae890 <Sciclient_rmIrIsIr> @ imm = #0x11b64
7009cd2c: b358         	cbz	r0, 0x7009cd86 <Sciclient_rmIrqGetRoute+0x216> @ imm = #0x56
7009cd2e: e7ff         	b	0x7009cd30 <Sciclient_rmIrqGetRoute+0x1c0> @ imm = #-0x2
;                     r = Sciclient_rmIrqGetNode(cur_if->rid, &next_n);
7009cd30: 9804         	ldr	r0, [sp, #0x10]
7009cd32: 88c0         	ldrh	r0, [r0, #0x6]
7009cd34: a905         	add	r1, sp, #0x14
7009cd36: f008 fffb    	bl	0x700a5d30 <Sciclient_rmIrqGetNode> @ imm = #0x8ff6
7009cd3a: 900c         	str	r0, [sp, #0x30]
;                     if (r != SystemP_SUCCESS) {
7009cd3c: 980c         	ldr	r0, [sp, #0x30]
7009cd3e: b108         	cbz	r0, 0x7009cd44 <Sciclient_rmIrqGetRoute+0x1d4> @ imm = #0x2
7009cd40: e7ff         	b	0x7009cd42 <Sciclient_rmIrqGetRoute+0x1d2> @ imm = #-0x2
;                         break;
7009cd42: e028         	b	0x7009cd96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x50
;                     next_inp = SCICLIENT_OUTP_TO_INP(outp,
7009cd44: 9a04         	ldr	r2, [sp, #0x10]
7009cd46: 8850         	ldrh	r0, [r2, #0x2]
7009cd48: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009cd4c: 8812         	ldrh	r2, [r2]
7009cd4e: 1a89         	subs	r1, r1, r2
7009cd50: 4408         	add	r0, r1
7009cd52: f8ad 0026    	strh.w	r0, [sp, #0x26]
;                     r = Sciclient_rmIrGetOutp(next_n->id, next_inp,
7009cd56: 9805         	ldr	r0, [sp, #0x14]
7009cd58: 8800         	ldrh	r0, [r0]
7009cd5a: f8bd 1026    	ldrh.w	r1, [sp, #0x26]
7009cd5e: f10d 0222    	add.w	r2, sp, #0x22
7009cd62: f008 fc15    	bl	0x700a5590 <Sciclient_rmIrGetOutp> @ imm = #0x882a
7009cd66: 900c         	str	r0, [sp, #0x30]
;                     if (r == SystemP_SUCCESS) {
7009cd68: 980c         	ldr	r0, [sp, #0x30]
7009cd6a: b930         	cbnz	r0, 0x7009cd7a <Sciclient_rmIrqGetRoute+0x20a> @ imm = #0xc
7009cd6c: e7ff         	b	0x7009cd6e <Sciclient_rmIrqGetRoute+0x1fe> @ imm = #-0x2
7009cd6e: 2001         	movs	r0, #0x1
;                         push_node = true;
7009cd70: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009cd74: 2000         	movs	r0, #0x0
;                         r = SystemP_SUCCESS;
7009cd76: 900c         	str	r0, [sp, #0x30]
;                         break;
7009cd78: e00d         	b	0x7009cd96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x1a
;                     if (r != SystemP_FAILURE) {
7009cd7a: 980c         	ldr	r0, [sp, #0x30]
7009cd7c: 3001         	adds	r0, #0x1
7009cd7e: b108         	cbz	r0, 0x7009cd84 <Sciclient_rmIrqGetRoute+0x214> @ imm = #0x2
7009cd80: e7ff         	b	0x7009cd82 <Sciclient_rmIrqGetRoute+0x212> @ imm = #-0x2
;                         break;
7009cd82: e008         	b	0x7009cd96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x10
;                 }
7009cd84: e7ff         	b	0x7009cd86 <Sciclient_rmIrqGetRoute+0x216> @ imm = #-0x2
;             }
7009cd86: e7ff         	b	0x7009cd88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #-0x2
;         }
7009cd88: e7ff         	b	0x7009cd8a <Sciclient_rmIrqGetRoute+0x21a> @ imm = #-0x2
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009cd8a: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009cd8e: 3001         	adds	r0, #0x1
7009cd90: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009cd94: e78d         	b	0x7009ccb2 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0xe6
;         if (r != SystemP_SUCCESS) {
7009cd96: 980c         	ldr	r0, [sp, #0x30]
7009cd98: b108         	cbz	r0, 0x7009cd9e <Sciclient_rmIrqGetRoute+0x22e> @ imm = #0x2
7009cd9a: e7ff         	b	0x7009cd9c <Sciclient_rmIrqGetRoute+0x22c> @ imm = #-0x2
;             break;
7009cd9c: e05a         	b	0x7009ce54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0xb4
;         if ((rt_complete == true) || (push_node == true)) {
7009cd9e: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009cda2: 07c0         	lsls	r0, r0, #0x1f
7009cda4: b930         	cbnz	r0, 0x7009cdb4 <Sciclient_rmIrqGetRoute+0x244> @ imm = #0xc
7009cda6: e7ff         	b	0x7009cda8 <Sciclient_rmIrqGetRoute+0x238> @ imm = #-0x2
7009cda8: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009cdac: 07c0         	lsls	r0, r0, #0x1f
7009cdae: 2800         	cmp	r0, #0x0
7009cdb0: d049         	beq	0x7009ce46 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #0x92
7009cdb2: e7ff         	b	0x7009cdb4 <Sciclient_rmIrqGetRoute+0x244> @ imm = #-0x2
;             r = Sciclient_rmPsPush(cur_n, if_idx);
7009cdb4: 9806         	ldr	r0, [sp, #0x18]
7009cdb6: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009cdba: f00f fb51    	bl	0x700ac460 <Sciclient_rmPsPush> @ imm = #0xf6a2
7009cdbe: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009cdc0: 980c         	ldr	r0, [sp, #0x30]
7009cdc2: b108         	cbz	r0, 0x7009cdc8 <Sciclient_rmIrqGetRoute+0x258> @ imm = #0x2
7009cdc4: e7ff         	b	0x7009cdc6 <Sciclient_rmIrqGetRoute+0x256> @ imm = #-0x2
;                 break;
7009cdc6: e045         	b	0x7009ce54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x8a
;             if ((search_depth > 0u) ||
7009cdc8: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cdcc: b950         	cbnz	r0, 0x7009cde4 <Sciclient_rmIrqGetRoute+0x274> @ imm = #0x14
7009cdce: e7ff         	b	0x7009cdd0 <Sciclient_rmIrqGetRoute+0x260> @ imm = #-0x2
;                 ((search_depth == 0u) &&
7009cdd0: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cdd4: bb28         	cbnz	r0, 0x7009ce22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x4a
7009cdd6: e7ff         	b	0x7009cdd8 <Sciclient_rmIrqGetRoute+0x268> @ imm = #-0x2
;                  (Sciclient_rmIaIsIa(cur_n->id) == true))) {
7009cdd8: 9806         	ldr	r0, [sp, #0x18]
7009cdda: 8800         	ldrh	r0, [r0]
7009cddc: f011 fd40    	bl	0x700ae860 <Sciclient_rmIaIsIa> @ imm = #0x11a80
;             if ((search_depth > 0u) ||
7009cde0: b1f8         	cbz	r0, 0x7009ce22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x3e
7009cde2: e7ff         	b	0x7009cde4 <Sciclient_rmIrqGetRoute+0x274> @ imm = #-0x2
;                 cur_psp = Sciclient_rmPsGetPsp();
7009cde4: f012 ff2c    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0x12e58
7009cde8: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 r = Sciclient_rmPsSetInp(cur_psp - (1u), inp);
7009cdec: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009cdf0: 3801         	subs	r0, #0x1
7009cdf2: f8bd 1028    	ldrh.w	r1, [sp, #0x28]
7009cdf6: b280         	uxth	r0, r0
7009cdf8: f010 fa12    	bl	0x700ad220 <Sciclient_rmPsSetInp> @ imm = #0x10424
7009cdfc: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009cdfe: 980c         	ldr	r0, [sp, #0x30]
7009ce00: b108         	cbz	r0, 0x7009ce06 <Sciclient_rmIrqGetRoute+0x296> @ imm = #0x2
7009ce02: e7ff         	b	0x7009ce04 <Sciclient_rmIrqGetRoute+0x294> @ imm = #-0x2
;                     break;
7009ce04: e026         	b	0x7009ce54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x4c
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009ce06: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009ce0a: 3801         	subs	r0, #0x1
;                         outp);
7009ce0c: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009ce10: b280         	uxth	r0, r0
7009ce12: f010 fa2d    	bl	0x700ad270 <Sciclient_rmPsSetOutp> @ imm = #0x1045a
7009ce16: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009ce18: 980c         	ldr	r0, [sp, #0x30]
7009ce1a: b108         	cbz	r0, 0x7009ce20 <Sciclient_rmIrqGetRoute+0x2b0> @ imm = #0x2
7009ce1c: e7ff         	b	0x7009ce1e <Sciclient_rmIrqGetRoute+0x2ae> @ imm = #-0x2
;                     break;
7009ce1e: e019         	b	0x7009ce54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x32
;             }
7009ce20: e7ff         	b	0x7009ce22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #-0x2
;             if (rt_complete == true) {
7009ce22: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009ce26: 07c0         	lsls	r0, r0, #0x1f
7009ce28: b108         	cbz	r0, 0x7009ce2e <Sciclient_rmIrqGetRoute+0x2be> @ imm = #0x2
7009ce2a: e7ff         	b	0x7009ce2c <Sciclient_rmIrqGetRoute+0x2bc> @ imm = #-0x2
;                 break;
7009ce2c: e012         	b	0x7009ce54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x24
;                 cur_n = next_n;
7009ce2e: 9805         	ldr	r0, [sp, #0x14]
7009ce30: 9006         	str	r0, [sp, #0x18]
;                 inp = next_inp;
7009ce32: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009ce36: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = next_outp;
7009ce3a: f8bd 0022    	ldrh.w	r0, [sp, #0x22]
7009ce3e: f8ad 0024    	strh.w	r0, [sp, #0x24]
7009ce42: e7ff         	b	0x7009ce44 <Sciclient_rmIrqGetRoute+0x2d4> @ imm = #-0x2
;         }
7009ce44: e7ff         	b	0x7009ce46 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #-0x2
;     }
7009ce46: e7ff         	b	0x7009ce48 <Sciclient_rmIrqGetRoute+0x2d8> @ imm = #-0x2
;          search_depth++) {
7009ce48: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009ce4c: 3001         	adds	r0, #0x1
7009ce4e: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;     for (search_depth = 0u;
7009ce52: e710         	b	0x7009cc76 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x1e0
;     if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009ce54: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009ce58: 9001         	str	r0, [sp, #0x4]
7009ce5a: f012 ff49    	bl	0x700afcf0 <Sciclient_rmPsGetMaxPsp> @ imm = #0x12e92
7009ce5e: 4601         	mov	r1, r0
7009ce60: 9801         	ldr	r0, [sp, #0x4]
7009ce62: 4288         	cmp	r0, r1
7009ce64: db04         	blt	0x7009ce70 <Sciclient_rmIrqGetRoute+0x300> @ imm = #0x8
7009ce66: e7ff         	b	0x7009ce68 <Sciclient_rmIrqGetRoute+0x2f8> @ imm = #-0x2
7009ce68: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
7009ce6c: 900c         	str	r0, [sp, #0x30]
;     }
7009ce6e: e7ff         	b	0x7009ce70 <Sciclient_rmIrqGetRoute+0x300> @ imm = #-0x2
;     return r;
7009ce70: 980c         	ldr	r0, [sp, #0x30]
7009ce72: b00e         	add	sp, #0x38
7009ce74: bd80         	pop	{r7, pc}
7009ce76: 0000         	movs	r0, r0

7009ce78 <$Ven$TA$L$PI$$HwiP_enable>:
7009ce78: f8df f000    	ldr.w	pc, [pc, #0x0]          @ 0x7009ce7c <$Ven$TA$L$PI$$HwiP_enable+0x4>
7009ce7c: 40 09 0b 70  	.word	0x700b0940

7009ce80 <Udma_eventReset>:
; {
7009ce80: b580         	push	{r7, lr}
7009ce82: b090         	sub	sp, #0x40
7009ce84: 900f         	str	r0, [sp, #0x3c]
7009ce86: 910e         	str	r1, [sp, #0x38]
7009ce88: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009ce8a: 9001         	str	r0, [sp, #0x4]
7009ce8c: 900d         	str	r0, [sp, #0x34]
;     eventPrms = &eventHandle->eventPrms;
7009ce8e: 990e         	ldr	r1, [sp, #0x38]
7009ce90: 3108         	adds	r1, #0x8
7009ce92: 9109         	str	r1, [sp, #0x24]
;     rmIrqReq.valid_params           = 0U;
7009ce94: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.global_event           = 0U;
7009ce96: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.src_id                 = 0U;
7009ce9a: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     rmIrqReq.src_index              = 0U;
7009ce9e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;     rmIrqReq.dst_id                 = 0U;
7009cea2: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     rmIrqReq.dst_host_irq           = 0U;
7009cea6: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     rmIrqReq.ia_id                  = 0U;
7009ceaa: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint                   = 0U;
7009ceae: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009ceb2: f88d 0022    	strb.w	r0, [sp, #0x22]
7009ceb6: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009ceb8: f88d 0023    	strb.w	r0, [sp, #0x23]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009cebc: 9809         	ldr	r0, [sp, #0x24]
7009cebe: 6800         	ldr	r0, [r0]
7009cec0: 2805         	cmp	r0, #0x5
7009cec2: d00a         	beq	0x7009ceda <Udma_eventReset+0x5a> @ imm = #0x14
7009cec4: e7ff         	b	0x7009cec6 <Udma_eventReset+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009cec6: 9804         	ldr	r0, [sp, #0x10]
7009cec8: f040 0010    	orr	r0, r0, #0x10
7009cecc: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009cece: 980e         	ldr	r0, [sp, #0x38]
7009ced0: f010 f9f6    	bl	0x700ad2c0 <Udma_eventGetId> @ imm = #0x103ec
7009ced4: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     }
7009ced8: e7ff         	b	0x7009ceda <Udma_eventReset+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009ceda: 980e         	ldr	r0, [sp, #0x38]
7009cedc: 6d80         	ldr	r0, [r0, #0x58]
7009cede: f510 3f80    	cmn.w	r0, #0x10000
7009cee2: d012         	beq	0x7009cf0a <Udma_eventReset+0x8a> @ imm = #0x24
7009cee4: e7ff         	b	0x7009cee6 <Udma_eventReset+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009cee6: 9804         	ldr	r0, [sp, #0x10]
7009cee8: f040 0001    	orr	r0, r0, #0x1
7009ceec: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009ceee: 9804         	ldr	r0, [sp, #0x10]
7009cef0: f040 0002    	orr	r0, r0, #0x2
7009cef4: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.dst_id       = drvHandle->devIdCore;
7009cef6: 980f         	ldr	r0, [sp, #0x3c]
7009cef8: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009cefc: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmIrqReq.dst_host_irq = (uint16_t)eventHandle->coreIntrNum;
7009cf00: 980e         	ldr	r0, [sp, #0x38]
7009cf02: 6d80         	ldr	r0, [r0, #0x58]
7009cf04: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     }
7009cf08: e7ff         	b	0x7009cf0a <Udma_eventReset+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009cf0a: 980e         	ldr	r0, [sp, #0x38]
7009cf0c: 6980         	ldr	r0, [r0, #0x18]
7009cf0e: b128         	cbz	r0, 0x7009cf1c <Udma_eventReset+0x9c> @ imm = #0xa
7009cf10: e7ff         	b	0x7009cf12 <Udma_eventReset+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009cf12: 980e         	ldr	r0, [sp, #0x38]
7009cf14: 6980         	ldr	r0, [r0, #0x18]
7009cf16: 6cc0         	ldr	r0, [r0, #0x4c]
7009cf18: 900c         	str	r0, [sp, #0x30]
;     }
7009cf1a: e003         	b	0x7009cf24 <Udma_eventReset+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009cf1c: 980e         	ldr	r0, [sp, #0x38]
7009cf1e: 6cc0         	ldr	r0, [r0, #0x4c]
7009cf20: 900c         	str	r0, [sp, #0x30]
7009cf22: e7ff         	b	0x7009cf24 <Udma_eventReset+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009cf24: 9804         	ldr	r0, [sp, #0x10]
7009cf26: f040 0004    	orr	r0, r0, #0x4
7009cf2a: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009cf2c: 9804         	ldr	r0, [sp, #0x10]
7009cf2e: f040 0008    	orr	r0, r0, #0x8
7009cf32: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009cf34: 980f         	ldr	r0, [sp, #0x3c]
7009cf36: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009cf3a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009cf3e: 980c         	ldr	r0, [sp, #0x30]
7009cf40: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009cf44: 980e         	ldr	r0, [sp, #0x38]
7009cf46: 6d00         	ldr	r0, [r0, #0x50]
7009cf48: f64f 71ff    	movw	r1, #0xffff
7009cf4c: 4288         	cmp	r0, r1
7009cf4e: d009         	beq	0x7009cf64 <Udma_eventReset+0xe4> @ imm = #0x12
7009cf50: e7ff         	b	0x7009cf52 <Udma_eventReset+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009cf52: 9804         	ldr	r0, [sp, #0x10]
7009cf54: f040 0020    	orr	r0, r0, #0x20
7009cf58: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009cf5a: 980e         	ldr	r0, [sp, #0x38]
7009cf5c: 6d00         	ldr	r0, [r0, #0x50]
7009cf5e: f88d 0022    	strb.w	r0, [sp, #0x22]
;     }
7009cf62: e7ff         	b	0x7009cf64 <Udma_eventReset+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009cf64: 9809         	ldr	r0, [sp, #0x24]
7009cf66: 6800         	ldr	r0, [r0]
7009cf68: 2801         	cmp	r0, #0x1
7009cf6a: d00a         	beq	0x7009cf82 <Udma_eventReset+0x102> @ imm = #0x14
7009cf6c: e7ff         	b	0x7009cf6e <Udma_eventReset+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType)||
7009cf6e: 9809         	ldr	r0, [sp, #0x24]
7009cf70: 6800         	ldr	r0, [r0]
7009cf72: 2806         	cmp	r0, #0x6
7009cf74: d005         	beq	0x7009cf82 <Udma_eventReset+0x102> @ imm = #0xa
7009cf76: e7ff         	b	0x7009cf78 <Udma_eventReset+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009cf78: 9809         	ldr	r0, [sp, #0x24]
7009cf7a: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009cf7c: 2802         	cmp	r0, #0x2
7009cf7e: d14d         	bne	0x7009d01c <Udma_eventReset+0x19c> @ imm = #0x9a
7009cf80: e7ff         	b	0x7009cf82 <Udma_eventReset+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009cf82: 9809         	ldr	r0, [sp, #0x24]
7009cf84: 6880         	ldr	r0, [r0, #0x8]
7009cf86: 900b         	str	r0, [sp, #0x2c]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009cf88: 980f         	ldr	r0, [sp, #0x3c]
7009cf8a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009cf8e: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009cf92: 9809         	ldr	r0, [sp, #0x24]
7009cf94: 6800         	ldr	r0, [r0]
7009cf96: 2801         	cmp	r0, #0x1
7009cf98: d005         	beq	0x7009cfa6 <Udma_eventReset+0x126> @ imm = #0xa
7009cf9a: e7ff         	b	0x7009cf9c <Udma_eventReset+0x11c> @ imm = #-0x2
7009cf9c: 9809         	ldr	r0, [sp, #0x24]
7009cf9e: 6800         	ldr	r0, [r0]
7009cfa0: 2806         	cmp	r0, #0x6
7009cfa2: d12e         	bne	0x7009d002 <Udma_eventReset+0x182> @ imm = #0x5c
7009cfa4: e7ff         	b	0x7009cfa6 <Udma_eventReset+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009cfa6: 980b         	ldr	r0, [sp, #0x2c]
7009cfa8: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009cfac: 8880         	ldrh	r0, [r0, #0x4]
7009cfae: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009cfb2: 980b         	ldr	r0, [sp, #0x2c]
7009cfb4: 7800         	ldrb	r0, [r0]
7009cfb6: 0740         	lsls	r0, r0, #0x1d
7009cfb8: 2800         	cmp	r0, #0x0
7009cfba: d509         	bpl	0x7009cfd0 <Udma_eventReset+0x150> @ imm = #0x12
7009cfbc: e7ff         	b	0x7009cfbe <Udma_eventReset+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009cfbe: 980f         	ldr	r0, [sp, #0x3c]
7009cfc0: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009cfc4: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009cfc8: 4408         	add	r0, r1
7009cfca: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009cfce: e017         	b	0x7009d000 <Udma_eventReset+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009cfd0: 980b         	ldr	r0, [sp, #0x2c]
7009cfd2: 7800         	ldrb	r0, [r0]
7009cfd4: 07c0         	lsls	r0, r0, #0x1f
7009cfd6: b148         	cbz	r0, 0x7009cfec <Udma_eventReset+0x16c> @ imm = #0x12
7009cfd8: e7ff         	b	0x7009cfda <Udma_eventReset+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009cfda: 980f         	ldr	r0, [sp, #0x3c]
7009cfdc: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009cfe0: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009cfe4: 4408         	add	r0, r1
7009cfe6: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009cfea: e008         	b	0x7009cffe <Udma_eventReset+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009cfec: 980f         	ldr	r0, [sp, #0x3c]
7009cfee: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009cff2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009cff6: 4408         	add	r0, r1
7009cff8: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009cffc: e7ff         	b	0x7009cffe <Udma_eventReset+0x17e> @ imm = #-0x2
7009cffe: e7ff         	b	0x7009d000 <Udma_eventReset+0x180> @ imm = #-0x2
;         }
7009d000: e00b         	b	0x7009d01a <Udma_eventReset+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009d002: 980b         	ldr	r0, [sp, #0x2c]
7009d004: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009d008: 8880         	ldrh	r0, [r0, #0x4]
7009d00a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009d00e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d012: 3014         	adds	r0, #0x14
7009d014: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d018: e7ff         	b	0x7009d01a <Udma_eventReset+0x19a> @ imm = #-0x2
;     }
7009d01a: e7ff         	b	0x7009d01c <Udma_eventReset+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009d01c: 9809         	ldr	r0, [sp, #0x24]
7009d01e: 6800         	ldr	r0, [r0]
7009d020: 2803         	cmp	r0, #0x3
7009d022: d156         	bne	0x7009d0d2 <Udma_eventReset+0x252> @ imm = #0xac
7009d024: e7ff         	b	0x7009d026 <Udma_eventReset+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d026: 980f         	ldr	r0, [sp, #0x3c]
7009d028: 6800         	ldr	r0, [r0]
7009d02a: 2802         	cmp	r0, #0x2
7009d02c: d104         	bne	0x7009d038 <Udma_eventReset+0x1b8> @ imm = #0x8
7009d02e: e7ff         	b	0x7009d030 <Udma_eventReset+0x1b0> @ imm = #-0x2
7009d030: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009d034: 900d         	str	r0, [sp, #0x34]
;         }
7009d036: e04b         	b	0x7009d0d0 <Udma_eventReset+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009d038: 9809         	ldr	r0, [sp, #0x24]
7009d03a: 6880         	ldr	r0, [r0, #0x8]
7009d03c: 900b         	str	r0, [sp, #0x2c]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009d03e: 980f         	ldr	r0, [sp, #0x3c]
7009d040: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009d044: f8ad 0014    	strh.w	r0, [sp, #0x14]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009d048: 980b         	ldr	r0, [sp, #0x2c]
7009d04a: 7800         	ldrb	r0, [r0]
7009d04c: 0740         	lsls	r0, r0, #0x1d
7009d04e: 2800         	cmp	r0, #0x0
7009d050: d50d         	bpl	0x7009d06e <Udma_eventReset+0x1ee> @ imm = #0x1a
7009d052: e7ff         	b	0x7009d054 <Udma_eventReset+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009d054: 980b         	ldr	r0, [sp, #0x2c]
7009d056: 6ec0         	ldr	r0, [r0, #0x6c]
7009d058: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009d05c: 980f         	ldr	r0, [sp, #0x3c]
7009d05e: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009d062: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d066: 4408         	add	r0, r1
7009d068: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d06c: e02f         	b	0x7009d0ce <Udma_eventReset+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009d06e: 980b         	ldr	r0, [sp, #0x2c]
7009d070: 7800         	ldrb	r0, [r0]
7009d072: 0780         	lsls	r0, r0, #0x1e
7009d074: 2800         	cmp	r0, #0x0
7009d076: d50d         	bpl	0x7009d094 <Udma_eventReset+0x214> @ imm = #0x1a
7009d078: e7ff         	b	0x7009d07a <Udma_eventReset+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009d07a: 980b         	ldr	r0, [sp, #0x2c]
7009d07c: 6f00         	ldr	r0, [r0, #0x70]
7009d07e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009d082: 980f         	ldr	r0, [sp, #0x3c]
7009d084: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009d088: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d08c: 4408         	add	r0, r1
7009d08e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d092: e01b         	b	0x7009d0cc <Udma_eventReset+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009d094: 980b         	ldr	r0, [sp, #0x2c]
7009d096: 7800         	ldrb	r0, [r0]
7009d098: 07c0         	lsls	r0, r0, #0x1f
7009d09a: b168         	cbz	r0, 0x7009d0b8 <Udma_eventReset+0x238> @ imm = #0x1a
7009d09c: e7ff         	b	0x7009d09e <Udma_eventReset+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009d09e: 980b         	ldr	r0, [sp, #0x2c]
7009d0a0: 6ec0         	ldr	r0, [r0, #0x6c]
7009d0a2: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009d0a6: 980f         	ldr	r0, [sp, #0x3c]
7009d0a8: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009d0ac: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d0b0: 4408         	add	r0, r1
7009d0b2: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d0b6: e008         	b	0x7009d0ca <Udma_eventReset+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009d0b8: 980f         	ldr	r0, [sp, #0x3c]
7009d0ba: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009d0be: f8ad 0014    	strh.w	r0, [sp, #0x14]
7009d0c2: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009d0c4: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d0c8: e7ff         	b	0x7009d0ca <Udma_eventReset+0x24a> @ imm = #-0x2
7009d0ca: e7ff         	b	0x7009d0cc <Udma_eventReset+0x24c> @ imm = #-0x2
7009d0cc: e7ff         	b	0x7009d0ce <Udma_eventReset+0x24e> @ imm = #-0x2
7009d0ce: e7ff         	b	0x7009d0d0 <Udma_eventReset+0x250> @ imm = #-0x2
;     }
7009d0d0: e7ff         	b	0x7009d0d2 <Udma_eventReset+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009d0d2: 9809         	ldr	r0, [sp, #0x24]
7009d0d4: 6800         	ldr	r0, [r0]
7009d0d6: 2804         	cmp	r0, #0x4
7009d0d8: d130         	bne	0x7009d13c <Udma_eventReset+0x2bc> @ imm = #0x60
7009d0da: e7ff         	b	0x7009d0dc <Udma_eventReset+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009d0dc: 9809         	ldr	r0, [sp, #0x24]
7009d0de: 68c0         	ldr	r0, [r0, #0xc]
7009d0e0: 900a         	str	r0, [sp, #0x28]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009d0e2: 980f         	ldr	r0, [sp, #0x3c]
7009d0e4: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009d0e8: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009d0ec: 980a         	ldr	r0, [sp, #0x28]
7009d0ee: 8880         	ldrh	r0, [r0, #0x4]
7009d0f0: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009d0f4: 980f         	ldr	r0, [sp, #0x3c]
7009d0f6: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009d0fa: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d0fe: 4408         	add	r0, r1
7009d100: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009d104: 980a         	ldr	r0, [sp, #0x28]
7009d106: 6dc0         	ldr	r0, [r0, #0x5c]
7009d108: 2804         	cmp	r0, #0x4
7009d10a: d316         	blo	0x7009d13a <Udma_eventReset+0x2ba> @ imm = #0x2c
7009d10c: e7ff         	b	0x7009d10e <Udma_eventReset+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009d10e: 980a         	ldr	r0, [sp, #0x28]
7009d110: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009d112: 2807         	cmp	r0, #0x7
7009d114: d811         	bhi	0x7009d13a <Udma_eventReset+0x2ba> @ imm = #0x22
7009d116: e7ff         	b	0x7009d118 <Udma_eventReset+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009d118: 980f         	ldr	r0, [sp, #0x3c]
7009d11a: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009d11e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d122: 1a40         	subs	r0, r0, r1
7009d124: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009d128: 980f         	ldr	r0, [sp, #0x3c]
7009d12a: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009d12e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d132: 4408         	add	r0, r1
7009d134: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         }
7009d138: e7ff         	b	0x7009d13a <Udma_eventReset+0x2ba> @ imm = #-0x2
;     }
7009d13a: e7ff         	b	0x7009d13c <Udma_eventReset+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d13c: 980d         	ldr	r0, [sp, #0x34]
7009d13e: b9b0         	cbnz	r0, 0x7009d16e <Udma_eventReset+0x2ee> @ imm = #0x2c
7009d140: e7ff         	b	0x7009d142 <Udma_eventReset+0x2c2> @ imm = #-0x2
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009d142: 980f         	ldr	r0, [sp, #0x3c]
7009d144: 6800         	ldr	r0, [r0]
7009d146: b130         	cbz	r0, 0x7009d156 <Udma_eventReset+0x2d6> @ imm = #0xc
7009d148: e7ff         	b	0x7009d14a <Udma_eventReset+0x2ca> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009d14a: 9809         	ldr	r0, [sp, #0x24]
7009d14c: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009d14e: 2805         	cmp	r0, #0x5
7009d150: d101         	bne	0x7009d156 <Udma_eventReset+0x2d6> @ imm = #0x2
7009d152: e7ff         	b	0x7009d154 <Udma_eventReset+0x2d4> @ imm = #-0x2
;         }
7009d154: e00a         	b	0x7009d16c <Udma_eventReset+0x2ec> @ imm = #0x14
7009d156: a802         	add	r0, sp, #0x8
7009d158: f04f 31ff    	mov.w	r1, #0xffffffff
;             retVal = Sciclient_rmIrqRelease(&rmIrqReq, UDMA_SCICLIENT_TIMEOUT);
7009d15c: f012 fb68    	bl	0x700af830 <Sciclient_rmIrqRelease> @ imm = #0x126d0
7009d160: 900d         	str	r0, [sp, #0x34]
;             if(CSL_PASS != retVal)
7009d162: 980d         	ldr	r0, [sp, #0x34]
7009d164: b108         	cbz	r0, 0x7009d16a <Udma_eventReset+0x2ea> @ imm = #0x2
7009d166: e7ff         	b	0x7009d168 <Udma_eventReset+0x2e8> @ imm = #-0x2
;             }
7009d168: e7ff         	b	0x7009d16a <Udma_eventReset+0x2ea> @ imm = #-0x2
7009d16a: e7ff         	b	0x7009d16c <Udma_eventReset+0x2ec> @ imm = #-0x2
;     }
7009d16c: e7ff         	b	0x7009d16e <Udma_eventReset+0x2ee> @ imm = #-0x2
;     return (retVal);
7009d16e: 980d         	ldr	r0, [sp, #0x34]
7009d170: b010         	add	sp, #0x40
7009d172: bd80         	pop	{r7, pc}

7009d174 <malloc>:
7009d174: e1a01000     	mov	r1, r0
7009d178: e3a00008     	mov	r0, #8
7009d17c: ea0009ec     	b	0x7009f934 <memalign>   @ imm = #0x27b0

7009d180 <Sciclient_service>:
; {
7009d180: b580         	push	{r7, lr}
7009d182: b094         	sub	sp, #0x50
7009d184: 9013         	str	r0, [sp, #0x4c]
7009d186: 9112         	str	r1, [sp, #0x48]
7009d188: 2000         	movs	r0, #0x0
;     int32_t   status        = SystemP_SUCCESS;
7009d18a: 9011         	str	r0, [sp, #0x44]
7009d18c: 210f         	movs	r1, #0xf
;     uint32_t  contextId     = SCICLIENT_CONTEXT_MAX_NUM;
7009d18e: 9110         	str	r1, [sp, #0x40]
;     uint32_t  initialCount  = 0U;
7009d190: 900f         	str	r0, [sp, #0x3c]
;     uint8_t   localSeqId    = gSciclientHandle.currSeqId;
7009d192: f642 1148    	movw	r1, #0x2948
7009d196: f2c7 010b    	movt	r1, #0x700b
7009d19a: 6809         	ldr	r1, [r1]
7009d19c: f88d 103b    	strb.w	r1, [sp, #0x3b]
;     uint32_t  txPayloadSize = 0U;
7009d1a0: 900d         	str	r0, [sp, #0x34]
;     uint32_t  rxPayloadSize = 0U;
7009d1a2: 900c         	str	r0, [sp, #0x30]
;     uint8_t  *pLocalRespPayload = NULL;
7009d1a4: 900b         	str	r0, [sp, #0x2c]
;     uint8_t  *pSecHeader = NULL;
7009d1a6: 9007         	str	r0, [sp, #0x1c]
;     if((pReqPrm == NULL) || (pRespPrm == NULL) || (pReqPrm->pReqPayload == NULL))
7009d1a8: 9813         	ldr	r0, [sp, #0x4c]
7009d1aa: b138         	cbz	r0, 0x7009d1bc <Sciclient_service+0x3c> @ imm = #0xe
7009d1ac: e7ff         	b	0x7009d1ae <Sciclient_service+0x2e> @ imm = #-0x2
7009d1ae: 9812         	ldr	r0, [sp, #0x48]
7009d1b0: b120         	cbz	r0, 0x7009d1bc <Sciclient_service+0x3c> @ imm = #0x8
7009d1b2: e7ff         	b	0x7009d1b4 <Sciclient_service+0x34> @ imm = #-0x2
7009d1b4: 9813         	ldr	r0, [sp, #0x4c]
7009d1b6: 6880         	ldr	r0, [r0, #0x8]
7009d1b8: b920         	cbnz	r0, 0x7009d1c4 <Sciclient_service+0x44> @ imm = #0x8
7009d1ba: e7ff         	b	0x7009d1bc <Sciclient_service+0x3c> @ imm = #-0x2
7009d1bc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009d1c0: 9011         	str	r0, [sp, #0x44]
;     }
7009d1c2: e09e         	b	0x7009d302 <Sciclient_service+0x182> @ imm = #0x13c
;         contextId = Sciclient_getCurrentContext(pReqPrm->messageType);
7009d1c4: 9813         	ldr	r0, [sp, #0x4c]
7009d1c6: 8800         	ldrh	r0, [r0]
7009d1c8: f00a fc22    	bl	0x700a7a10 <Sciclient_getCurrentContext> @ imm = #0xa844
7009d1cc: 9010         	str	r0, [sp, #0x40]
;         if(contextId < SCICLIENT_CONTEXT_MAX_NUM)
7009d1ce: 9810         	ldr	r0, [sp, #0x40]
7009d1d0: 280e         	cmp	r0, #0xe
7009d1d2: f200 8091    	bhi.w	0x7009d2f8 <Sciclient_service+0x178> @ imm = #0x122
7009d1d6: e7ff         	b	0x7009d1d8 <Sciclient_service+0x58> @ imm = #-0x2
;             txThread = Sciclient_getTxThreadId(contextId);
7009d1d8: 9810         	ldr	r0, [sp, #0x40]
7009d1da: f012 f891    	bl	0x700af300 <Sciclient_getTxThreadId> @ imm = #0x12122
7009d1de: 900a         	str	r0, [sp, #0x28]
;             rxThread = Sciclient_getRxThreadId(contextId);
7009d1e0: 9810         	ldr	r0, [sp, #0x40]
7009d1e2: f012 f87d    	bl	0x700af2e0 <Sciclient_getRxThreadId> @ imm = #0x120fa
7009d1e6: 9009         	str	r0, [sp, #0x24]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009d1e8: 9810         	ldr	r0, [sp, #0x40]
7009d1ea: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d1ee: f241 3020    	movw	r0, #0x1320
7009d1f2: f2c7 000b    	movt	r0, #0x700b
7009d1f6: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009d1fa: b938         	cbnz	r0, 0x7009d20c <Sciclient_service+0x8c> @ imm = #0xe
7009d1fc: e7ff         	b	0x7009d1fe <Sciclient_service+0x7e> @ imm = #-0x2
;                 gSecHeaderSizeWords = sizeof(struct tisci_sec_header)/sizeof(uint32_t);
7009d1fe: f642 2154    	movw	r1, #0x2a54
7009d202: f2c7 010b    	movt	r1, #0x700b
7009d206: 2001         	movs	r0, #0x1
7009d208: 7008         	strb	r0, [r1]
;             }
7009d20a: e006         	b	0x7009d21a <Sciclient_service+0x9a> @ imm = #0xc
;                 gSecHeaderSizeWords = 0;
7009d20c: f642 2154    	movw	r1, #0x2a54
7009d210: f2c7 010b    	movt	r1, #0x700b
7009d214: 2000         	movs	r0, #0x0
7009d216: 7008         	strb	r0, [r1]
7009d218: e7ff         	b	0x7009d21a <Sciclient_service+0x9a> @ imm = #-0x2
;             gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
7009d21a: f642 00c0    	movw	r0, #0x28c0
7009d21e: f2c7 000b    	movt	r0, #0x700b
7009d222: f011 fb05    	bl	0x700ae830 <CSL_secProxyGetMaxMsgSize> @ imm = #0x1160a
7009d226: 3804         	subs	r0, #0x4
7009d228: f642 1148    	movw	r1, #0x2948
7009d22c: f2c7 010b    	movt	r1, #0x700b
7009d230: 6148         	str	r0, [r1, #0x14]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009d232: 9810         	ldr	r0, [sp, #0x40]
7009d234: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d238: f241 3020    	movw	r0, #0x1320
7009d23c: f2c7 000b    	movt	r0, #0x700b
7009d240: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009d244: b940         	cbnz	r0, 0x7009d258 <Sciclient_service+0xd8> @ imm = #0x10
7009d246: e7ff         	b	0x7009d248 <Sciclient_service+0xc8> @ imm = #-0x2
7009d248: 2000         	movs	r0, #0x0
;                 secHeader.integ_check = (uint16_t)0;
7009d24a: f8ad 0014    	strh.w	r0, [sp, #0x14]
;                 secHeader.rsvd = (uint16_t)0;
7009d24e: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d252: a805         	add	r0, sp, #0x14
;                 pSecHeader = (uint8_t * )(&secHeader);
7009d254: 9007         	str	r0, [sp, #0x1c]
;             }
7009d256: e7ff         	b	0x7009d258 <Sciclient_service+0xd8> @ imm = #-0x2
;             if (pReqPrm->reqPayloadSize > 0U)
7009d258: 9813         	ldr	r0, [sp, #0x4c]
7009d25a: 68c0         	ldr	r0, [r0, #0xc]
7009d25c: b128         	cbz	r0, 0x7009d26a <Sciclient_service+0xea> @ imm = #0xa
7009d25e: e7ff         	b	0x7009d260 <Sciclient_service+0xe0> @ imm = #-0x2
;                 txPayloadSize = pReqPrm->reqPayloadSize - sizeof(struct tisci_header);
7009d260: 9813         	ldr	r0, [sp, #0x4c]
7009d262: 68c0         	ldr	r0, [r0, #0xc]
7009d264: 3808         	subs	r0, #0x8
7009d266: 900d         	str	r0, [sp, #0x34]
;             }
7009d268: e002         	b	0x7009d270 <Sciclient_service+0xf0> @ imm = #0x4
7009d26a: 2000         	movs	r0, #0x0
;                 txPayloadSize = 0U;
7009d26c: 900d         	str	r0, [sp, #0x34]
7009d26e: e7ff         	b	0x7009d270 <Sciclient_service+0xf0> @ imm = #-0x2
;             if (txPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009d270: 980d         	ldr	r0, [sp, #0x34]
7009d272: f642 1148    	movw	r1, #0x2948
7009d276: f2c7 010b    	movt	r1, #0x700b
7009d27a: 6949         	ldr	r1, [r1, #0x14]
7009d27c: 3908         	subs	r1, #0x8
7009d27e: 4288         	cmp	r0, r1
7009d280: d904         	bls	0x7009d28c <Sciclient_service+0x10c> @ imm = #0x8
7009d282: e7ff         	b	0x7009d284 <Sciclient_service+0x104> @ imm = #-0x2
7009d284: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d288: 9011         	str	r0, [sp, #0x44]
;             }
7009d28a: e7ff         	b	0x7009d28c <Sciclient_service+0x10c> @ imm = #-0x2
;             if ((txPayloadSize > 0U) && (pReqPrm->pReqPayload == NULL))
7009d28c: 980d         	ldr	r0, [sp, #0x34]
7009d28e: b140         	cbz	r0, 0x7009d2a2 <Sciclient_service+0x122> @ imm = #0x10
7009d290: e7ff         	b	0x7009d292 <Sciclient_service+0x112> @ imm = #-0x2
7009d292: 9813         	ldr	r0, [sp, #0x4c]
7009d294: 6880         	ldr	r0, [r0, #0x8]
7009d296: b920         	cbnz	r0, 0x7009d2a2 <Sciclient_service+0x122> @ imm = #0x8
7009d298: e7ff         	b	0x7009d29a <Sciclient_service+0x11a> @ imm = #-0x2
7009d29a: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d29e: 9011         	str	r0, [sp, #0x44]
;             }
7009d2a0: e7ff         	b	0x7009d2a2 <Sciclient_service+0x122> @ imm = #-0x2
;             if (pRespPrm->respPayloadSize > 0U)
7009d2a2: 9812         	ldr	r0, [sp, #0x48]
7009d2a4: 6880         	ldr	r0, [r0, #0x8]
7009d2a6: b128         	cbz	r0, 0x7009d2b4 <Sciclient_service+0x134> @ imm = #0xa
7009d2a8: e7ff         	b	0x7009d2aa <Sciclient_service+0x12a> @ imm = #-0x2
;                 rxPayloadSize = pRespPrm->respPayloadSize - sizeof(struct tisci_header);
7009d2aa: 9812         	ldr	r0, [sp, #0x48]
7009d2ac: 6880         	ldr	r0, [r0, #0x8]
7009d2ae: 3808         	subs	r0, #0x8
7009d2b0: 900c         	str	r0, [sp, #0x30]
;             }
7009d2b2: e002         	b	0x7009d2ba <Sciclient_service+0x13a> @ imm = #0x4
7009d2b4: 2000         	movs	r0, #0x0
;                 rxPayloadSize = 0U;
7009d2b6: 900c         	str	r0, [sp, #0x30]
7009d2b8: e7ff         	b	0x7009d2ba <Sciclient_service+0x13a> @ imm = #-0x2
;             if (rxPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009d2ba: 980c         	ldr	r0, [sp, #0x30]
7009d2bc: f642 1148    	movw	r1, #0x2948
7009d2c0: f2c7 010b    	movt	r1, #0x700b
7009d2c4: 6949         	ldr	r1, [r1, #0x14]
7009d2c6: 3908         	subs	r1, #0x8
7009d2c8: 4288         	cmp	r0, r1
7009d2ca: d904         	bls	0x7009d2d6 <Sciclient_service+0x156> @ imm = #0x8
7009d2cc: e7ff         	b	0x7009d2ce <Sciclient_service+0x14e> @ imm = #-0x2
7009d2ce: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d2d2: 9011         	str	r0, [sp, #0x44]
;             }
7009d2d4: e7ff         	b	0x7009d2d6 <Sciclient_service+0x156> @ imm = #-0x2
;             if ((rxPayloadSize > 0U) && (pRespPrm->pRespPayload == NULL))
7009d2d6: 980c         	ldr	r0, [sp, #0x30]
7009d2d8: b140         	cbz	r0, 0x7009d2ec <Sciclient_service+0x16c> @ imm = #0x10
7009d2da: e7ff         	b	0x7009d2dc <Sciclient_service+0x15c> @ imm = #-0x2
7009d2dc: 9812         	ldr	r0, [sp, #0x48]
7009d2de: 6840         	ldr	r0, [r0, #0x4]
7009d2e0: b920         	cbnz	r0, 0x7009d2ec <Sciclient_service+0x16c> @ imm = #0x8
7009d2e2: e7ff         	b	0x7009d2e4 <Sciclient_service+0x164> @ imm = #-0x2
7009d2e4: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d2e8: 9011         	str	r0, [sp, #0x44]
;             }
7009d2ea: e004         	b	0x7009d2f6 <Sciclient_service+0x176> @ imm = #0x8
;                 pLocalRespPayload = (uint8_t *)(pRespPrm->pRespPayload + sizeof(struct tisci_header));
7009d2ec: 9812         	ldr	r0, [sp, #0x48]
7009d2ee: 6840         	ldr	r0, [r0, #0x4]
7009d2f0: 3008         	adds	r0, #0x8
7009d2f2: 900b         	str	r0, [sp, #0x2c]
7009d2f4: e7ff         	b	0x7009d2f6 <Sciclient_service+0x176> @ imm = #-0x2
;         }
7009d2f6: e003         	b	0x7009d300 <Sciclient_service+0x180> @ imm = #0x6
7009d2f8: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009d2fc: 9011         	str	r0, [sp, #0x44]
7009d2fe: e7ff         	b	0x7009d300 <Sciclient_service+0x180> @ imm = #-0x2
7009d300: e7ff         	b	0x7009d302 <Sciclient_service+0x182> @ imm = #-0x2
;     key = HwiP_disable();
7009d302: f013 eb0e    	blx	0x700b0920 <HwiP_disable> @ imm = #0x1361c
7009d306: 9008         	str	r0, [sp, #0x20]
;     if (SystemP_SUCCESS == status)
7009d308: 9811         	ldr	r0, [sp, #0x44]
7009d30a: 2800         	cmp	r0, #0x0
7009d30c: d159         	bne	0x7009d3c2 <Sciclient_service+0x242> @ imm = #0xb2
7009d30e: e7ff         	b	0x7009d310 <Sciclient_service+0x190> @ imm = #-0x2
;         Sciclient_secProxyFlush(rxThread);
7009d310: 9809         	ldr	r0, [sp, #0x24]
7009d312: f010 ff9d    	bl	0x700ae250 <Sciclient_secProxyFlush> @ imm = #0x10f3a
;         header = (struct tisci_header*)pReqPrm->pReqPayload;
7009d316: 9813         	ldr	r0, [sp, #0x4c]
7009d318: 6880         	ldr	r0, [r0, #0x8]
7009d31a: 9006         	str	r0, [sp, #0x18]
;         header->type = pReqPrm->messageType;
7009d31c: 9813         	ldr	r0, [sp, #0x4c]
7009d31e: 8800         	ldrh	r0, [r0]
7009d320: 9906         	ldr	r1, [sp, #0x18]
7009d322: 8008         	strh	r0, [r1]
;         header->host = (uint8_t) gSciclientMap[contextId].hostId;
7009d324: 9810         	ldr	r0, [sp, #0x40]
7009d326: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d32a: f241 3020    	movw	r0, #0x1320
7009d32e: f2c7 000b    	movt	r0, #0x700b
7009d332: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009d336: 6840         	ldr	r0, [r0, #0x4]
7009d338: 9906         	ldr	r1, [sp, #0x18]
7009d33a: 7088         	strb	r0, [r1, #0x2]
;         header->seq = localSeqId;
7009d33c: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
7009d340: 9906         	ldr	r1, [sp, #0x18]
7009d342: 70c8         	strb	r0, [r1, #0x3]
;         pFlags = (uint8_t*)&pReqPrm->flags;
7009d344: 9813         	ldr	r0, [sp, #0x4c]
7009d346: 3004         	adds	r0, #0x4
7009d348: 9004         	str	r0, [sp, #0x10]
7009d34a: 2000         	movs	r0, #0x0
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009d34c: 9003         	str	r0, [sp, #0xc]
7009d34e: e7ff         	b	0x7009d350 <Sciclient_service+0x1d0> @ imm = #-0x2
7009d350: 9803         	ldr	r0, [sp, #0xc]
7009d352: 2803         	cmp	r0, #0x3
7009d354: d811         	bhi	0x7009d37a <Sciclient_service+0x1fa> @ imm = #0x22
7009d356: e7ff         	b	0x7009d358 <Sciclient_service+0x1d8> @ imm = #-0x2
;             uint8_t *pDestFlags = ((uint8_t*)&header->flags) + numBytes;
7009d358: 9806         	ldr	r0, [sp, #0x18]
7009d35a: 9903         	ldr	r1, [sp, #0xc]
7009d35c: 4408         	add	r0, r1
7009d35e: 3004         	adds	r0, #0x4
7009d360: 9002         	str	r0, [sp, #0x8]
;             *pDestFlags = *pFlags;
7009d362: 9804         	ldr	r0, [sp, #0x10]
7009d364: 7800         	ldrb	r0, [r0]
7009d366: 9902         	ldr	r1, [sp, #0x8]
7009d368: 7008         	strb	r0, [r1]
;             pFlags++;
7009d36a: 9804         	ldr	r0, [sp, #0x10]
7009d36c: 3001         	adds	r0, #0x1
7009d36e: 9004         	str	r0, [sp, #0x10]
;         }
7009d370: e7ff         	b	0x7009d372 <Sciclient_service+0x1f2> @ imm = #-0x2
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009d372: 9803         	ldr	r0, [sp, #0xc]
7009d374: 3001         	adds	r0, #0x1
7009d376: 9003         	str	r0, [sp, #0xc]
7009d378: e7ea         	b	0x7009d350 <Sciclient_service+0x1d0> @ imm = #-0x2c
;         gSciclientHandle.currSeqId = (gSciclientHandle.currSeqId + 1U) %
7009d37a: f642 1148    	movw	r1, #0x2948
7009d37e: f2c7 010b    	movt	r1, #0x700b
7009d382: 6808         	ldr	r0, [r1]
7009d384: 3001         	adds	r0, #0x1
7009d386: f644 1225    	movw	r2, #0x4925
7009d38a: f2c2 4292    	movt	r2, #0x2492
7009d38e: fba0 3202    	umull	r3, r2, r0, r2
7009d392: 1a83         	subs	r3, r0, r2
7009d394: eb02 0353    	add.w	r3, r2, r3, lsr #1
7009d398: 089a         	lsrs	r2, r3, #0x2
7009d39a: 00d2         	lsls	r2, r2, #0x3
7009d39c: eba2 0293    	sub.w	r2, r2, r3, lsr #2
7009d3a0: 1a80         	subs	r0, r0, r2
7009d3a2: 6008         	str	r0, [r1]
;         status = Sciclient_secProxyVerifyThread(txThread);
7009d3a4: 980a         	ldr	r0, [sp, #0x28]
7009d3a6: f011 fd2b    	bl	0x700aee00 <Sciclient_secProxyVerifyThread> @ imm = #0x11a56
7009d3aa: 9011         	str	r0, [sp, #0x44]
;         if (SystemP_SUCCESS == status)
7009d3ac: 9811         	ldr	r0, [sp, #0x44]
7009d3ae: b938         	cbnz	r0, 0x7009d3c0 <Sciclient_service+0x240> @ imm = #0xe
7009d3b0: e7ff         	b	0x7009d3b2 <Sciclient_service+0x232> @ imm = #-0x2
;             status = Sciclient_secProxyWaitThread(txThread, pReqPrm->timeout);
7009d3b2: 980a         	ldr	r0, [sp, #0x28]
7009d3b4: 9913         	ldr	r1, [sp, #0x4c]
7009d3b6: 6909         	ldr	r1, [r1, #0x10]
7009d3b8: f010 fc6a    	bl	0x700adc90 <Sciclient_secProxyWaitThread> @ imm = #0x108d4
7009d3bc: 9011         	str	r0, [sp, #0x44]
;         }
7009d3be: e7ff         	b	0x7009d3c0 <Sciclient_service+0x240> @ imm = #-0x2
;     }
7009d3c0: e7ff         	b	0x7009d3c2 <Sciclient_service+0x242> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
7009d3c2: 9811         	ldr	r0, [sp, #0x44]
7009d3c4: b9b0         	cbnz	r0, 0x7009d3f4 <Sciclient_service+0x274> @ imm = #0x2c
7009d3c6: e7ff         	b	0x7009d3c8 <Sciclient_service+0x248> @ imm = #-0x2
;         initialCount = Sciclient_secProxyReadThreadCount(rxThread);
7009d3c8: 9809         	ldr	r0, [sp, #0x24]
7009d3ca: f012 fa41    	bl	0x700af850 <Sciclient_secProxyReadThreadCount> @ imm = #0x12482
7009d3ce: 900f         	str	r0, [sp, #0x3c]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009d3d0: 980a         	ldr	r0, [sp, #0x28]
7009d3d2: 9907         	ldr	r1, [sp, #0x1c]
7009d3d4: 9a06         	ldr	r2, [sp, #0x18]
;                               (pReqPrm->pReqPayload + sizeof(struct tisci_header)),
7009d3d6: 9b13         	ldr	r3, [sp, #0x4c]
7009d3d8: 689b         	ldr	r3, [r3, #0x8]
7009d3da: 3308         	adds	r3, #0x8
;                               txPayloadSize);
7009d3dc: f8dd c034    	ldr.w	r12, [sp, #0x34]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009d3e0: 46ee         	mov	lr, sp
7009d3e2: f8ce c000    	str.w	r12, [lr]
7009d3e6: f005 f873    	bl	0x700a24d0 <Sciclient_sendMessage> @ imm = #0x50e6
;         status = Sciclient_secProxyVerifyThread(rxThread);
7009d3ea: 9809         	ldr	r0, [sp, #0x24]
7009d3ec: f011 fd08    	bl	0x700aee00 <Sciclient_secProxyVerifyThread> @ imm = #0x11a10
7009d3f0: 9011         	str	r0, [sp, #0x44]
;     }
7009d3f2: e7ff         	b	0x7009d3f4 <Sciclient_service+0x274> @ imm = #-0x2
;     if ((status == SystemP_SUCCESS) &&
7009d3f4: 9811         	ldr	r0, [sp, #0x44]
7009d3f6: b978         	cbnz	r0, 0x7009d418 <Sciclient_service+0x298> @ imm = #0x1e
7009d3f8: e7ff         	b	0x7009d3fa <Sciclient_service+0x27a> @ imm = #-0x2
;         ((pReqPrm->flags & TISCI_MSG_FLAG_MASK) != 0U))
7009d3fa: 9813         	ldr	r0, [sp, #0x4c]
;     if ((status == SystemP_SUCCESS) &&
7009d3fc: 7900         	ldrb	r0, [r0, #0x4]
7009d3fe: 0780         	lsls	r0, r0, #0x1e
7009d400: b150         	cbz	r0, 0x7009d418 <Sciclient_service+0x298> @ imm = #0x14
7009d402: e7ff         	b	0x7009d404 <Sciclient_service+0x284> @ imm = #-0x2
;         status = Sciclient_waitForMessage(rxThread, pReqPrm->timeout, initialCount, localSeqId);
7009d404: 9809         	ldr	r0, [sp, #0x24]
7009d406: 9913         	ldr	r1, [sp, #0x4c]
7009d408: 6909         	ldr	r1, [r1, #0x10]
7009d40a: 9a0f         	ldr	r2, [sp, #0x3c]
7009d40c: f89d 303b    	ldrb.w	r3, [sp, #0x3b]
7009d410: f008 fd76    	bl	0x700a5f00 <Sciclient_waitForMessage> @ imm = #0x8aec
7009d414: 9011         	str	r0, [sp, #0x44]
;     }
7009d416: e7ff         	b	0x7009d418 <Sciclient_service+0x298> @ imm = #-0x2
;     if(status == SystemP_SUCCESS)
7009d418: 9811         	ldr	r0, [sp, #0x44]
7009d41a: b990         	cbnz	r0, 0x7009d442 <Sciclient_service+0x2c2> @ imm = #0x24
7009d41c: e7ff         	b	0x7009d41e <Sciclient_service+0x29e> @ imm = #-0x2
;         pRespPrm->flags = Sciclient_secProxyReadThread32(rxThread, 1U+gSecHeaderSizeWords);
7009d41e: 9809         	ldr	r0, [sp, #0x24]
7009d420: f642 2154    	movw	r1, #0x2a54
7009d424: f2c7 010b    	movt	r1, #0x700b
7009d428: 7809         	ldrb	r1, [r1]
7009d42a: 3101         	adds	r1, #0x1
7009d42c: b2c9         	uxtb	r1, r1
7009d42e: f011 fa47    	bl	0x700ae8c0 <Sciclient_secProxyReadThread32> @ imm = #0x1148e
7009d432: 9912         	ldr	r1, [sp, #0x48]
7009d434: 6008         	str	r0, [r1]
;         Sciclient_recvMessage(rxThread, pLocalRespPayload, rxPayloadSize);
7009d436: 9809         	ldr	r0, [sp, #0x24]
7009d438: 990b         	ldr	r1, [sp, #0x2c]
7009d43a: 9a0c         	ldr	r2, [sp, #0x30]
7009d43c: f005 fd50    	bl	0x700a2ee0 <Sciclient_recvMessage> @ imm = #0x5aa0
;     }
7009d440: e7ff         	b	0x7009d442 <Sciclient_service+0x2c2> @ imm = #-0x2
;     HwiP_restore(key);
7009d442: 9808         	ldr	r0, [sp, #0x20]
7009d444: f013 ea8c    	blx	0x700b0960 <HwiP_restore> @ imm = #0x13518
;     return status;
7009d448: 9811         	ldr	r0, [sp, #0x44]
7009d44a: b014         	add	sp, #0x50
7009d44c: bd80         	pop	{r7, pc}
7009d44e: 0000         	movs	r0, r0

7009d450 <Udma_chDisableRxChan>:
; {
7009d450: b580         	push	{r7, lr}
7009d452: b096         	sub	sp, #0x58
7009d454: 9015         	str	r0, [sp, #0x54]
7009d456: 9114         	str	r1, [sp, #0x50]
7009d458: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d45a: 9013         	str	r0, [sp, #0x4c]
;     uint32_t            currTimeout = 0U, regVal;
7009d45c: 9012         	str	r0, [sp, #0x48]
;     uint32_t            peerRtEnable = 0U, peerRtEnableBit = 0U;
7009d45e: 9004         	str	r0, [sp, #0x10]
7009d460: 9003         	str	r0, [sp, #0xc]
;     drvHandle = chHandle->drvHandle;
7009d462: 9815         	ldr	r0, [sp, #0x54]
7009d464: 6e80         	ldr	r0, [r0, #0x68]
7009d466: 9010         	str	r0, [sp, #0x40]
7009d468: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009d46a: 9002         	str	r0, [sp, #0x8]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d46c: 9810         	ldr	r0, [sp, #0x40]
7009d46e: 6800         	ldr	r0, [r0]
7009d470: 2801         	cmp	r0, #0x1
7009d472: d115         	bne	0x7009d4a0 <Udma_chDisableRxChan+0x50> @ imm = #0x2a
7009d474: e7ff         	b	0x7009d476 <Udma_chDisableRxChan+0x26> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
7009d476: 9815         	ldr	r0, [sp, #0x54]
7009d478: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009d47c: f500 7008    	add.w	r0, r0, #0x220
7009d480: f012 fbc6    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x1278c
7009d484: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009d486: 9811         	ldr	r0, [sp, #0x44]
7009d488: f040 4080    	orr	r0, r0, #0x40000000
7009d48c: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
7009d48e: 9815         	ldr	r0, [sp, #0x54]
7009d490: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009d494: f500 7008    	add.w	r0, r0, #0x220
7009d498: 9911         	ldr	r1, [sp, #0x44]
7009d49a: f012 fb19    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0x12632
;     }
7009d49e: e01a         	b	0x7009d4d6 <Udma_chDisableRxChan+0x86> @ imm = #0x34
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d4a0: 9810         	ldr	r0, [sp, #0x40]
7009d4a2: 6800         	ldr	r0, [r0]
7009d4a4: 2802         	cmp	r0, #0x2
7009d4a6: d115         	bne	0x7009d4d4 <Udma_chDisableRxChan+0x84> @ imm = #0x2a
7009d4a8: e7ff         	b	0x7009d4aa <Udma_chDisableRxChan+0x5a> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
7009d4aa: 9815         	ldr	r0, [sp, #0x54]
7009d4ac: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009d4b0: f500 7008    	add.w	r0, r0, #0x220
7009d4b4: f012 fbac    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x12758
7009d4b8: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009d4ba: 9811         	ldr	r0, [sp, #0x44]
7009d4bc: f040 4080    	orr	r0, r0, #0x40000000
7009d4c0: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
7009d4c2: 9815         	ldr	r0, [sp, #0x54]
7009d4c4: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009d4c8: f500 7008    	add.w	r0, r0, #0x220
7009d4cc: 9911         	ldr	r1, [sp, #0x44]
7009d4ce: f012 faff    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0x125fe
;     }
7009d4d2: e7ff         	b	0x7009d4d4 <Udma_chDisableRxChan+0x84> @ imm = #-0x2
7009d4d4: e7ff         	b	0x7009d4d6 <Udma_chDisableRxChan+0x86> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009d4d6: e7ff         	b	0x7009d4d8 <Udma_chDisableRxChan+0x88> @ imm = #-0x2
7009d4d8: 9813         	ldr	r0, [sp, #0x4c]
7009d4da: bbc8         	cbnz	r0, 0x7009d550 <Udma_chDisableRxChan+0x100> @ imm = #0x72
7009d4dc: e7ff         	b	0x7009d4de <Udma_chDisableRxChan+0x8e> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d4de: 9810         	ldr	r0, [sp, #0x40]
7009d4e0: 6800         	ldr	r0, [r0]
7009d4e2: 2801         	cmp	r0, #0x1
7009d4e4: d110         	bne	0x7009d508 <Udma_chDisableRxChan+0xb8> @ imm = #0x20
7009d4e6: e7ff         	b	0x7009d4e8 <Udma_chDisableRxChan+0x98> @ imm = #-0x2
;             (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009d4e8: 9a10         	ldr	r2, [sp, #0x40]
7009d4ea: f102 0008    	add.w	r0, r2, #0x8
7009d4ee: 9915         	ldr	r1, [sp, #0x54]
7009d4f0: 6f09         	ldr	r1, [r1, #0x70]
7009d4f2: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d4f6: 4411         	add	r1, r2
7009d4f8: aa0a         	add	r2, sp, #0x28
7009d4fa: f011 fa89    	bl	0x700aea10 <CSL_bcdmaGetRxRT> @ imm = #0x11512
;             if(FALSE == bcdmaRtStatus.enable)
7009d4fe: 980a         	ldr	r0, [sp, #0x28]
7009d500: b908         	cbnz	r0, 0x7009d506 <Udma_chDisableRxChan+0xb6> @ imm = #0x2
7009d502: e7ff         	b	0x7009d504 <Udma_chDisableRxChan+0xb4> @ imm = #-0x2
;                 break;
7009d504: e024         	b	0x7009d550 <Udma_chDisableRxChan+0x100> @ imm = #0x48
;         }
7009d506: e011         	b	0x7009d52c <Udma_chDisableRxChan+0xdc> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d508: 9810         	ldr	r0, [sp, #0x40]
7009d50a: 6800         	ldr	r0, [r0]
7009d50c: 2802         	cmp	r0, #0x2
7009d50e: d10c         	bne	0x7009d52a <Udma_chDisableRxChan+0xda> @ imm = #0x18
7009d510: e7ff         	b	0x7009d512 <Udma_chDisableRxChan+0xc2> @ imm = #-0x2
;             (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009d512: 9810         	ldr	r0, [sp, #0x40]
7009d514: 3054         	adds	r0, #0x54
7009d516: 9915         	ldr	r1, [sp, #0x54]
7009d518: 6f09         	ldr	r1, [r1, #0x70]
7009d51a: aa05         	add	r2, sp, #0x14
7009d51c: f00f fef8    	bl	0x700ad310 <CSL_pktdmaGetRxRT> @ imm = #0xfdf0
;             if(FALSE == pktdmaRtStatus.enable)
7009d520: 9805         	ldr	r0, [sp, #0x14]
7009d522: b908         	cbnz	r0, 0x7009d528 <Udma_chDisableRxChan+0xd8> @ imm = #0x2
7009d524: e7ff         	b	0x7009d526 <Udma_chDisableRxChan+0xd6> @ imm = #-0x2
;                 break;
7009d526: e013         	b	0x7009d550 <Udma_chDisableRxChan+0x100> @ imm = #0x26
;         }
7009d528: e7ff         	b	0x7009d52a <Udma_chDisableRxChan+0xda> @ imm = #-0x2
7009d52a: e7ff         	b	0x7009d52c <Udma_chDisableRxChan+0xdc> @ imm = #-0x2
;         if(currTimeout > timeout)
7009d52c: 9812         	ldr	r0, [sp, #0x48]
7009d52e: 9914         	ldr	r1, [sp, #0x50]
7009d530: 4288         	cmp	r0, r1
7009d532: d904         	bls	0x7009d53e <Udma_chDisableRxChan+0xee> @ imm = #0x8
7009d534: e7ff         	b	0x7009d536 <Udma_chDisableRxChan+0xe6> @ imm = #-0x2
7009d536: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009d53a: 9013         	str	r0, [sp, #0x4c]
;         }
7009d53c: e007         	b	0x7009d54e <Udma_chDisableRxChan+0xfe> @ imm = #0xe
7009d53e: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009d542: f00d fd45    	bl	0x700aafd0 <ClockP_usleep> @ imm = #0xda8a
;             currTimeout++;
7009d546: 9812         	ldr	r0, [sp, #0x48]
7009d548: 3001         	adds	r0, #0x1
7009d54a: 9012         	str	r0, [sp, #0x48]
7009d54c: e7ff         	b	0x7009d54e <Udma_chDisableRxChan+0xfe> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009d54e: e7c3         	b	0x7009d4d8 <Udma_chDisableRxChan+0x88> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009d550: 9813         	ldr	r0, [sp, #0x4c]
7009d552: 2800         	cmp	r0, #0x0
7009d554: f000 8091    	beq.w	0x7009d67a <Udma_chDisableRxChan+0x22a> @ imm = #0x122
7009d558: e7ff         	b	0x7009d55a <Udma_chDisableRxChan+0x10a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d55a: 9810         	ldr	r0, [sp, #0x40]
7009d55c: 6800         	ldr	r0, [r0]
7009d55e: 2801         	cmp	r0, #0x1
7009d560: d10e         	bne	0x7009d580 <Udma_chDisableRxChan+0x130> @ imm = #0x1c
7009d562: e7ff         	b	0x7009d564 <Udma_chDisableRxChan+0x114> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, (bool)true, (bool)false);
7009d564: 9a10         	ldr	r2, [sp, #0x40]
7009d566: f102 0008    	add.w	r0, r2, #0x8
7009d56a: 9915         	ldr	r1, [sp, #0x54]
7009d56c: 6f09         	ldr	r1, [r1, #0x70]
7009d56e: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d572: 4411         	add	r1, r2
7009d574: 2201         	movs	r2, #0x1
7009d576: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownRxChan(
7009d578: f010 f87a    	bl	0x700ad670 <CSL_bcdmaTeardownRxChan> @ imm = #0x100f4
7009d57c: 9013         	str	r0, [sp, #0x4c]
;         }
7009d57e: e00f         	b	0x7009d5a0 <Udma_chDisableRxChan+0x150> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d580: 9810         	ldr	r0, [sp, #0x40]
7009d582: 6800         	ldr	r0, [r0]
7009d584: 2802         	cmp	r0, #0x2
7009d586: d10a         	bne	0x7009d59e <Udma_chDisableRxChan+0x14e> @ imm = #0x14
7009d588: e7ff         	b	0x7009d58a <Udma_chDisableRxChan+0x13a> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->rxChNum, (bool)true, (bool)false);
7009d58a: 9810         	ldr	r0, [sp, #0x40]
7009d58c: 3054         	adds	r0, #0x54
7009d58e: 9915         	ldr	r1, [sp, #0x54]
7009d590: 6f09         	ldr	r1, [r1, #0x70]
7009d592: 2201         	movs	r2, #0x1
7009d594: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownRxChan(
7009d596: f010 ff3b    	bl	0x700ae410 <CSL_pktdmaTeardownRxChan> @ imm = #0x10e76
7009d59a: 9013         	str	r0, [sp, #0x4c]
;         }
7009d59c: e7ff         	b	0x7009d59e <Udma_chDisableRxChan+0x14e> @ imm = #-0x2
7009d59e: e7ff         	b	0x7009d5a0 <Udma_chDisableRxChan+0x150> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009d5a0: 9813         	ldr	r0, [sp, #0x4c]
7009d5a2: b108         	cbz	r0, 0x7009d5a8 <Udma_chDisableRxChan+0x158> @ imm = #0x2
7009d5a4: e7ff         	b	0x7009d5a6 <Udma_chDisableRxChan+0x156> @ imm = #-0x2
;         }
7009d5a6: e7ff         	b	0x7009d5a8 <Udma_chDisableRxChan+0x158> @ imm = #-0x2
7009d5a8: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009d5aa: 9012         	str	r0, [sp, #0x48]
;         while(UDMA_SOK == retVal)
7009d5ac: e7ff         	b	0x7009d5ae <Udma_chDisableRxChan+0x15e> @ imm = #-0x2
7009d5ae: 9813         	ldr	r0, [sp, #0x4c]
7009d5b0: 2800         	cmp	r0, #0x0
7009d5b2: d161         	bne	0x7009d678 <Udma_chDisableRxChan+0x228> @ imm = #0xc2
7009d5b4: e7ff         	b	0x7009d5b6 <Udma_chDisableRxChan+0x166> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d5b6: 9810         	ldr	r0, [sp, #0x40]
7009d5b8: 6800         	ldr	r0, [r0]
7009d5ba: 2801         	cmp	r0, #0x1
7009d5bc: d126         	bne	0x7009d60c <Udma_chDisableRxChan+0x1bc> @ imm = #0x4c
7009d5be: e7ff         	b	0x7009d5c0 <Udma_chDisableRxChan+0x170> @ imm = #-0x2
;                 (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009d5c0: 9a10         	ldr	r2, [sp, #0x40]
7009d5c2: f102 0008    	add.w	r0, r2, #0x8
7009d5c6: 9915         	ldr	r1, [sp, #0x54]
7009d5c8: 6f09         	ldr	r1, [r1, #0x70]
7009d5ca: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d5ce: 4411         	add	r1, r2
7009d5d0: aa0a         	add	r2, sp, #0x28
7009d5d2: f011 fa1d    	bl	0x700aea10 <CSL_bcdmaGetRxRT> @ imm = #0x1143a
;                     &drvHandle->bcdmaRegs,
7009d5d6: 9a10         	ldr	r2, [sp, #0x40]
7009d5d8: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->rxChNum + drvHandle->rxChOffset,
7009d5dc: 9915         	ldr	r1, [sp, #0x54]
7009d5de: 6f09         	ldr	r1, [r1, #0x70]
7009d5e0: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d5e4: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009d5e6: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009d5e8: 46ec         	mov	r12, sp
7009d5ea: aa04         	add	r2, sp, #0x10
7009d5ec: f8cc 2000    	str.w	r2, [r12]
7009d5f0: 2201         	movs	r2, #0x1
7009d5f2: f010 f92d    	bl	0x700ad850 <CSL_bcdmaGetChanPeerReg> @ imm = #0x1025a
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009d5f6: 9804         	ldr	r0, [sp, #0x10]
7009d5f8: 0fc0         	lsrs	r0, r0, #0x1f
7009d5fa: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == bcdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009d5fc: 980a         	ldr	r0, [sp, #0x28]
7009d5fe: b920         	cbnz	r0, 0x7009d60a <Udma_chDisableRxChan+0x1ba> @ imm = #0x8
7009d600: e7ff         	b	0x7009d602 <Udma_chDisableRxChan+0x1b2> @ imm = #-0x2
7009d602: 9803         	ldr	r0, [sp, #0xc]
7009d604: b908         	cbnz	r0, 0x7009d60a <Udma_chDisableRxChan+0x1ba> @ imm = #0x2
7009d606: e7ff         	b	0x7009d608 <Udma_chDisableRxChan+0x1b8> @ imm = #-0x2
;                     break;
7009d608: e036         	b	0x7009d678 <Udma_chDisableRxChan+0x228> @ imm = #0x6c
;             }
7009d60a: e023         	b	0x7009d654 <Udma_chDisableRxChan+0x204> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d60c: 9810         	ldr	r0, [sp, #0x40]
7009d60e: 6800         	ldr	r0, [r0]
7009d610: 2802         	cmp	r0, #0x2
7009d612: d11e         	bne	0x7009d652 <Udma_chDisableRxChan+0x202> @ imm = #0x3c
7009d614: e7ff         	b	0x7009d616 <Udma_chDisableRxChan+0x1c6> @ imm = #-0x2
;                 (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009d616: 9810         	ldr	r0, [sp, #0x40]
7009d618: 3054         	adds	r0, #0x54
7009d61a: 9915         	ldr	r1, [sp, #0x54]
7009d61c: 6f09         	ldr	r1, [r1, #0x70]
7009d61e: aa05         	add	r2, sp, #0x14
7009d620: f00f fe76    	bl	0x700ad310 <CSL_pktdmaGetRxRT> @ imm = #0xfcec
;                     &drvHandle->pktdmaRegs,
7009d624: 9810         	ldr	r0, [sp, #0x40]
7009d626: 3054         	adds	r0, #0x54
;                     chHandle->rxChNum,
7009d628: 9915         	ldr	r1, [sp, #0x54]
7009d62a: 6f09         	ldr	r1, [r1, #0x70]
;                     rtEnableRegOffset, &peerRtEnable);
7009d62c: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009d62e: 46ec         	mov	r12, sp
7009d630: aa04         	add	r2, sp, #0x10
7009d632: f8cc 2000    	str.w	r2, [r12]
7009d636: 2201         	movs	r2, #0x1
7009d638: f011 f882    	bl	0x700ae740 <CSL_pktdmaGetChanPeerReg> @ imm = #0x11104
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009d63c: 9804         	ldr	r0, [sp, #0x10]
7009d63e: 0fc0         	lsrs	r0, r0, #0x1f
7009d640: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == pktdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009d642: 9805         	ldr	r0, [sp, #0x14]
7009d644: b920         	cbnz	r0, 0x7009d650 <Udma_chDisableRxChan+0x200> @ imm = #0x8
7009d646: e7ff         	b	0x7009d648 <Udma_chDisableRxChan+0x1f8> @ imm = #-0x2
7009d648: 9803         	ldr	r0, [sp, #0xc]
7009d64a: b908         	cbnz	r0, 0x7009d650 <Udma_chDisableRxChan+0x200> @ imm = #0x2
7009d64c: e7ff         	b	0x7009d64e <Udma_chDisableRxChan+0x1fe> @ imm = #-0x2
;                     break;
7009d64e: e013         	b	0x7009d678 <Udma_chDisableRxChan+0x228> @ imm = #0x26
;             }
7009d650: e7ff         	b	0x7009d652 <Udma_chDisableRxChan+0x202> @ imm = #-0x2
7009d652: e7ff         	b	0x7009d654 <Udma_chDisableRxChan+0x204> @ imm = #-0x2
;             if(currTimeout > timeout)
7009d654: 9812         	ldr	r0, [sp, #0x48]
7009d656: 9914         	ldr	r1, [sp, #0x50]
7009d658: 4288         	cmp	r0, r1
7009d65a: d904         	bls	0x7009d666 <Udma_chDisableRxChan+0x216> @ imm = #0x8
7009d65c: e7ff         	b	0x7009d65e <Udma_chDisableRxChan+0x20e> @ imm = #-0x2
7009d65e: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009d662: 9013         	str	r0, [sp, #0x4c]
;             }
7009d664: e007         	b	0x7009d676 <Udma_chDisableRxChan+0x226> @ imm = #0xe
7009d666: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009d66a: f00d fcb1    	bl	0x700aafd0 <ClockP_usleep> @ imm = #0xd962
;                 currTimeout++;
7009d66e: 9812         	ldr	r0, [sp, #0x48]
7009d670: 3001         	adds	r0, #0x1
7009d672: 9012         	str	r0, [sp, #0x48]
7009d674: e7ff         	b	0x7009d676 <Udma_chDisableRxChan+0x226> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009d676: e79a         	b	0x7009d5ae <Udma_chDisableRxChan+0x15e> @ imm = #-0xcc
;     }
7009d678: e7ff         	b	0x7009d67a <Udma_chDisableRxChan+0x22a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d67a: 9813         	ldr	r0, [sp, #0x4c]
7009d67c: 2800         	cmp	r0, #0x0
7009d67e: d148         	bne	0x7009d712 <Udma_chDisableRxChan+0x2c2> @ imm = #0x90
7009d680: e7ff         	b	0x7009d682 <Udma_chDisableRxChan+0x232> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d682: 9810         	ldr	r0, [sp, #0x40]
7009d684: 6800         	ldr	r0, [r0]
7009d686: 2801         	cmp	r0, #0x1
7009d688: d122         	bne	0x7009d6d0 <Udma_chDisableRxChan+0x280> @ imm = #0x44
7009d68a: e7ff         	b	0x7009d68c <Udma_chDisableRxChan+0x23c> @ imm = #-0x2
7009d68c: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009d68e: 900b         	str	r0, [sp, #0x2c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009d690: 9804         	ldr	r0, [sp, #0x10]
7009d692: f020 4080    	bic	r0, r0, #0x40000000
7009d696: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009d698: 9a10         	ldr	r2, [sp, #0x40]
7009d69a: f102 0008    	add.w	r0, r2, #0x8
7009d69e: 9915         	ldr	r1, [sp, #0x54]
7009d6a0: 6f09         	ldr	r1, [r1, #0x70]
7009d6a2: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d6a6: 4411         	add	r1, r2
7009d6a8: aa0a         	add	r2, sp, #0x28
;             (void) CSL_bcdmaSetRxRT(
7009d6aa: f011 f9e1    	bl	0x700aea70 <CSL_bcdmaSetRxRT> @ imm = #0x113c2
;                 &drvHandle->bcdmaRegs,
7009d6ae: 9a10         	ldr	r2, [sp, #0x40]
7009d6b0: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->rxChNum + drvHandle->rxChOffset,
7009d6b4: 9915         	ldr	r1, [sp, #0x54]
7009d6b6: 6f09         	ldr	r1, [r1, #0x70]
7009d6b8: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d6bc: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009d6be: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_bcdmaSetChanPeerReg(
7009d6c0: 46ec         	mov	r12, sp
7009d6c2: aa04         	add	r2, sp, #0x10
7009d6c4: f8cc 2000    	str.w	r2, [r12]
7009d6c8: 2201         	movs	r2, #0x1
7009d6ca: f010 fba1    	bl	0x700ade10 <CSL_bcdmaSetChanPeerReg> @ imm = #0x10742
;         }
7009d6ce: e01f         	b	0x7009d710 <Udma_chDisableRxChan+0x2c0> @ imm = #0x3e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d6d0: 9810         	ldr	r0, [sp, #0x40]
7009d6d2: 6800         	ldr	r0, [r0]
7009d6d4: 2802         	cmp	r0, #0x2
7009d6d6: d11a         	bne	0x7009d70e <Udma_chDisableRxChan+0x2be> @ imm = #0x34
7009d6d8: e7ff         	b	0x7009d6da <Udma_chDisableRxChan+0x28a> @ imm = #-0x2
7009d6da: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009d6dc: 9006         	str	r0, [sp, #0x18]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009d6de: 9804         	ldr	r0, [sp, #0x10]
7009d6e0: f020 4080    	bic	r0, r0, #0x40000000
7009d6e4: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009d6e6: 9810         	ldr	r0, [sp, #0x40]
7009d6e8: 3054         	adds	r0, #0x54
7009d6ea: 9915         	ldr	r1, [sp, #0x54]
7009d6ec: 6f09         	ldr	r1, [r1, #0x70]
7009d6ee: aa05         	add	r2, sp, #0x14
;             (void) CSL_pktdmaSetRxRT(
7009d6f0: f010 fbce    	bl	0x700ade90 <CSL_pktdmaSetRxRT> @ imm = #0x1079c
;                 &drvHandle->pktdmaRegs,
7009d6f4: 9810         	ldr	r0, [sp, #0x40]
7009d6f6: 3054         	adds	r0, #0x54
;                 chHandle->rxChNum,
7009d6f8: 9915         	ldr	r1, [sp, #0x54]
7009d6fa: 6f09         	ldr	r1, [r1, #0x70]
;                 rtEnableRegOffset,
7009d6fc: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_pktdmaSetChanPeerReg(
7009d6fe: 46ec         	mov	r12, sp
7009d700: aa04         	add	r2, sp, #0x10
7009d702: f8cc 2000    	str.w	r2, [r12]
7009d706: 2201         	movs	r2, #0x1
7009d708: f011 f832    	bl	0x700ae770 <CSL_pktdmaSetChanPeerReg> @ imm = #0x11064
;         }
7009d70c: e7ff         	b	0x7009d70e <Udma_chDisableRxChan+0x2be> @ imm = #-0x2
7009d70e: e7ff         	b	0x7009d710 <Udma_chDisableRxChan+0x2c0> @ imm = #-0x2
;     }
7009d710: e7ff         	b	0x7009d712 <Udma_chDisableRxChan+0x2c2> @ imm = #-0x2
;     return (retVal);
7009d712: 9813         	ldr	r0, [sp, #0x4c]
7009d714: b016         	add	sp, #0x58
7009d716: bd80         	pop	{r7, pc}
		...

7009d720 <CSL_bcdmaChanOpCfgChan>:
; {
7009d720: b580         	push	{r7, lr}
7009d722: b08a         	sub	sp, #0x28
7009d724: 9009         	str	r0, [sp, #0x24]
7009d726: 9108         	str	r1, [sp, #0x20]
7009d728: 9207         	str	r2, [sp, #0x1c]
7009d72a: 9306         	str	r3, [sp, #0x18]
7009d72c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
7009d72e: 9005         	str	r0, [sp, #0x14]
;     if( pOpData == NULL )
7009d730: 9806         	ldr	r0, [sp, #0x18]
7009d732: b920         	cbnz	r0, 0x7009d73e <CSL_bcdmaChanOpCfgChan+0x1e> @ imm = #0x8
7009d734: e7ff         	b	0x7009d736 <CSL_bcdmaChanOpCfgChan+0x16> @ imm = #-0x2
7009d736: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
7009d73a: 9005         	str	r0, [sp, #0x14]
;     }
7009d73c: e137         	b	0x7009d9ae <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #0x26e
;         switch( chanType )
7009d73e: 9808         	ldr	r0, [sp, #0x20]
7009d740: 9000         	str	r0, [sp]
7009d742: b148         	cbz	r0, 0x7009d758 <CSL_bcdmaChanOpCfgChan+0x38> @ imm = #0x12
7009d744: e7ff         	b	0x7009d746 <CSL_bcdmaChanOpCfgChan+0x26> @ imm = #-0x2
7009d746: 9800         	ldr	r0, [sp]
7009d748: 2801         	cmp	r0, #0x1
7009d74a: d057         	beq	0x7009d7fc <CSL_bcdmaChanOpCfgChan+0xdc> @ imm = #0xae
7009d74c: e7ff         	b	0x7009d74e <CSL_bcdmaChanOpCfgChan+0x2e> @ imm = #-0x2
7009d74e: 9800         	ldr	r0, [sp]
7009d750: 2802         	cmp	r0, #0x2
7009d752: f000 80c1    	beq.w	0x7009d8d8 <CSL_bcdmaChanOpCfgChan+0x1b8> @ imm = #0x182
7009d756: e125         	b	0x7009d9a4 <CSL_bcdmaChanOpCfgChan+0x284> @ imm = #0x24a
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009d758: 9806         	ldr	r0, [sp, #0x18]
7009d75a: 9003         	str	r0, [sp, #0xc]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009d75c: 9803         	ldr	r0, [sp, #0xc]
7009d75e: 6c40         	ldr	r0, [r0, #0x44]
7009d760: 2802         	cmp	r0, #0x2
7009d762: d80a         	bhi	0x7009d77a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0x14
7009d764: e7ff         	b	0x7009d766 <CSL_bcdmaChanOpCfgChan+0x46> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009d766: 9803         	ldr	r0, [sp, #0xc]
7009d768: 6a00         	ldr	r0, [r0, #0x20]
7009d76a: 2807         	cmp	r0, #0x7
7009d76c: d805         	bhi	0x7009d77a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0xa
7009d76e: e7ff         	b	0x7009d770 <CSL_bcdmaChanOpCfgChan+0x50> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009d770: 9803         	ldr	r0, [sp, #0xc]
7009d772: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009d774: 2804         	cmp	r0, #0x4
7009d776: d304         	blo	0x7009d782 <CSL_bcdmaChanOpCfgChan+0x62> @ imm = #0x8
7009d778: e7ff         	b	0x7009d77a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #-0x2
7009d77a: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009d77e: 9005         	str	r0, [sp, #0x14]
;                     }
7009d780: e03b         	b	0x7009d7fa <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #0x76
;                         regVal = CSL_REG32_RD( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG );
7009d782: 9809         	ldr	r0, [sp, #0x24]
7009d784: 6840         	ldr	r0, [r0, #0x4]
7009d786: 9907         	ldr	r1, [sp, #0x1c]
7009d788: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d78c: f012 fa18    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0x12430
7009d790: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_PAUSE_ON_ERR, pChanCfg->pauseOnError );
7009d792: 9804         	ldr	r0, [sp, #0x10]
7009d794: f020 4000    	bic	r0, r0, #0x80000000
7009d798: 9903         	ldr	r1, [sp, #0xc]
7009d79a: 6809         	ldr	r1, [r1]
7009d79c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009d7a0: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, pChanCfg->burstSize );
7009d7a2: 9804         	ldr	r0, [sp, #0x10]
7009d7a4: 9903         	ldr	r1, [sp, #0xc]
7009d7a6: 6c49         	ldr	r1, [r1, #0x44]
7009d7a8: f361 208b    	bfi	r0, r1, #10, #2
7009d7ac: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, regVal );
7009d7ae: 9809         	ldr	r0, [sp, #0x24]
7009d7b0: 6840         	ldr	r0, [r0, #0x4]
7009d7b2: 9907         	ldr	r1, [sp, #0x1c]
7009d7b4: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d7b8: 9904         	ldr	r1, [sp, #0x10]
7009d7ba: f7fe fca9    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x16ae
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009d7be: 9803         	ldr	r0, [sp, #0xc]
7009d7c0: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009d7c2: 6a80         	ldr	r0, [r0, #0x28]
7009d7c4: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009d7c8: f361 701e    	bfi	r0, r1, #28, #3
7009d7cc: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].PRI_CTRL, regVal );
7009d7ce: 9809         	ldr	r0, [sp, #0x24]
7009d7d0: 6840         	ldr	r0, [r0, #0x4]
7009d7d2: 9907         	ldr	r1, [sp, #0x1c]
7009d7d4: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d7d8: 3064         	adds	r0, #0x64
7009d7da: 9904         	ldr	r1, [sp, #0x10]
7009d7dc: f7fe fc98    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x16d0
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_BCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009d7e0: 9809         	ldr	r0, [sp, #0x24]
7009d7e2: 6840         	ldr	r0, [r0, #0x4]
7009d7e4: 9907         	ldr	r1, [sp, #0x1c]
7009d7e6: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d7ea: 3080         	adds	r0, #0x80
7009d7ec: 9903         	ldr	r1, [sp, #0xc]
7009d7ee: 6ac9         	ldr	r1, [r1, #0x2c]
7009d7f0: f001 0103    	and	r1, r1, #0x3
7009d7f4: f7fe fc8c    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x16e8
7009d7f8: e7ff         	b	0x7009d7fa <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #-0x2
;                 break;
7009d7fa: e0d7         	b	0x7009d9ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x1ae
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009d7fc: 9806         	ldr	r0, [sp, #0x18]
7009d7fe: 9002         	str	r0, [sp, #0x8]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009d800: 9802         	ldr	r0, [sp, #0x8]
7009d802: 6c40         	ldr	r0, [r0, #0x44]
7009d804: 2801         	cmp	r0, #0x1
7009d806: d80a         	bhi	0x7009d81e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0x14
7009d808: e7ff         	b	0x7009d80a <CSL_bcdmaChanOpCfgChan+0xea> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009d80a: 9802         	ldr	r0, [sp, #0x8]
7009d80c: 6a00         	ldr	r0, [r0, #0x20]
7009d80e: 2807         	cmp	r0, #0x7
7009d810: d805         	bhi	0x7009d81e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0xa
7009d812: e7ff         	b	0x7009d814 <CSL_bcdmaChanOpCfgChan+0xf4> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009d814: 9802         	ldr	r0, [sp, #0x8]
7009d816: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009d818: 2804         	cmp	r0, #0x4
7009d81a: d304         	blo	0x7009d826 <CSL_bcdmaChanOpCfgChan+0x106> @ imm = #0x8
7009d81c: e7ff         	b	0x7009d81e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #-0x2
7009d81e: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009d822: 9005         	str	r0, [sp, #0x14]
;                     }
7009d824: e057         	b	0x7009d8d6 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #0xae
;                         regVal = CSL_REG32_RD( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG );
7009d826: 9809         	ldr	r0, [sp, #0x24]
7009d828: 68c0         	ldr	r0, [r0, #0xc]
7009d82a: 9907         	ldr	r1, [sp, #0x1c]
7009d82c: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d830: f012 f9c6    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0x1238c
7009d834: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009d836: 9804         	ldr	r0, [sp, #0x10]
7009d838: f020 4000    	bic	r0, r0, #0x80000000
7009d83c: 9902         	ldr	r1, [sp, #0x8]
7009d83e: 6809         	ldr	r1, [r1]
7009d840: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009d844: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, pChanCfg->burstSize );
7009d846: 9804         	ldr	r0, [sp, #0x10]
7009d848: 9902         	ldr	r1, [sp, #0x8]
7009d84a: 6c49         	ldr	r1, [r1, #0x44]
7009d84c: f361 208b    	bfi	r0, r1, #10, #2
7009d850: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_TDTYPE, pChanCfg->tdType );
7009d852: 9804         	ldr	r0, [sp, #0x10]
7009d854: 9902         	ldr	r1, [sp, #0x8]
7009d856: 6c09         	ldr	r1, [r1, #0x40]
7009d858: f361 2049    	bfi	r0, r1, #9, #1
7009d85c: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_NOTDPKT, pChanCfg->bNoTeardownCompletePkt );
7009d85e: 9804         	ldr	r0, [sp, #0x10]
7009d860: f420 7080    	bic	r0, r0, #0x100
7009d864: 9902         	ldr	r1, [sp, #0x8]
7009d866: f891 103c    	ldrb.w	r1, [r1, #0x3c]
7009d86a: f001 0101    	and	r1, r1, #0x1
7009d86e: ea40 2001    	orr.w	r0, r0, r1, lsl #8
7009d872: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, regVal );
7009d874: 9809         	ldr	r0, [sp, #0x24]
7009d876: 68c0         	ldr	r0, [r0, #0xc]
7009d878: 9907         	ldr	r1, [sp, #0x1c]
7009d87a: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d87e: 9904         	ldr	r1, [sp, #0x10]
7009d880: f7fe fc46    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x1774
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009d884: 9802         	ldr	r0, [sp, #0x8]
7009d886: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009d888: 6a80         	ldr	r0, [r0, #0x28]
7009d88a: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009d88e: f361 701e    	bfi	r0, r1, #28, #3
7009d892: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TPRI_CTRL, regVal );
7009d894: 9809         	ldr	r0, [sp, #0x24]
7009d896: 68c0         	ldr	r0, [r0, #0xc]
7009d898: 9907         	ldr	r1, [sp, #0x1c]
7009d89a: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d89e: 3064         	adds	r0, #0x64
7009d8a0: 9904         	ldr	r1, [sp, #0x10]
7009d8a2: f7fe fc35    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x1796
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_TXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009d8a6: 9809         	ldr	r0, [sp, #0x24]
7009d8a8: 68c0         	ldr	r0, [r0, #0xc]
7009d8aa: 9907         	ldr	r1, [sp, #0x1c]
7009d8ac: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d8b0: 3068         	adds	r0, #0x68
7009d8b2: 9902         	ldr	r1, [sp, #0x8]
7009d8b4: f8b1 1048    	ldrh.w	r1, [r1, #0x48]
7009d8b8: f7fe fc2a    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x17ac
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_TXCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009d8bc: 9809         	ldr	r0, [sp, #0x24]
7009d8be: 68c0         	ldr	r0, [r0, #0xc]
7009d8c0: 9907         	ldr	r1, [sp, #0x1c]
7009d8c2: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d8c6: 3080         	adds	r0, #0x80
7009d8c8: 9902         	ldr	r1, [sp, #0x8]
7009d8ca: 6ac9         	ldr	r1, [r1, #0x2c]
7009d8cc: f001 0103    	and	r1, r1, #0x3
7009d8d0: f7fe fc1e    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x17c4
7009d8d4: e7ff         	b	0x7009d8d6 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #-0x2
;                 break;
7009d8d6: e069         	b	0x7009d9ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0xd2
;                     CSL_BcdmaRxChanCfg *pChanCfg = (CSL_BcdmaRxChanCfg *)pOpData;
7009d8d8: 9806         	ldr	r0, [sp, #0x18]
7009d8da: 9001         	str	r0, [sp, #0x4]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009d8dc: 9801         	ldr	r0, [sp, #0x4]
7009d8de: 6bc0         	ldr	r0, [r0, #0x3c]
7009d8e0: 2801         	cmp	r0, #0x1
7009d8e2: d80a         	bhi	0x7009d8fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0x14
7009d8e4: e7ff         	b	0x7009d8e6 <CSL_bcdmaChanOpCfgChan+0x1c6> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009d8e6: 9801         	ldr	r0, [sp, #0x4]
7009d8e8: 6980         	ldr	r0, [r0, #0x18]
7009d8ea: 2807         	cmp	r0, #0x7
7009d8ec: d805         	bhi	0x7009d8fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0xa
7009d8ee: e7ff         	b	0x7009d8f0 <CSL_bcdmaChanOpCfgChan+0x1d0> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009d8f0: 9801         	ldr	r0, [sp, #0x4]
7009d8f2: 6b80         	ldr	r0, [r0, #0x38]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009d8f4: 2804         	cmp	r0, #0x4
7009d8f6: d304         	blo	0x7009d902 <CSL_bcdmaChanOpCfgChan+0x1e2> @ imm = #0x8
7009d8f8: e7ff         	b	0x7009d8fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #-0x2
7009d8fa: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009d8fe: 9005         	str	r0, [sp, #0x14]
;                     }
7009d900: e04f         	b	0x7009d9a2 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #0x9e
;                         regVal = CSL_REG32_RD( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG );
7009d902: 9809         	ldr	r0, [sp, #0x24]
7009d904: 6940         	ldr	r0, [r0, #0x14]
7009d906: 9907         	ldr	r1, [sp, #0x1c]
7009d908: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d90c: f012 f958    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0x122b0
7009d910: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009d912: 9804         	ldr	r0, [sp, #0x10]
7009d914: f020 4000    	bic	r0, r0, #0x80000000
7009d918: 9901         	ldr	r1, [sp, #0x4]
7009d91a: 6809         	ldr	r1, [r1]
7009d91c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009d920: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, pChanCfg->burstSize );
7009d922: 9804         	ldr	r0, [sp, #0x10]
7009d924: 9901         	ldr	r1, [sp, #0x4]
7009d926: 6bc9         	ldr	r1, [r1, #0x3c]
7009d928: f361 208b    	bfi	r0, r1, #10, #2
7009d92c: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_IGNORE_LONG, pChanCfg->bIgnoreLongPkts ? (uint32_t)1U : (uint32_t)0U );
7009d92e: 9804         	ldr	r0, [sp, #0x10]
7009d930: f420 4080    	bic	r0, r0, #0x4000
7009d934: 9901         	ldr	r1, [sp, #0x4]
7009d936: f891 1035    	ldrb.w	r1, [r1, #0x35]
7009d93a: f361 308e    	bfi	r0, r1, #14, #1
7009d93e: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, regVal );
7009d940: 9809         	ldr	r0, [sp, #0x24]
7009d942: 6940         	ldr	r0, [r0, #0x14]
7009d944: 9907         	ldr	r1, [sp, #0x1c]
7009d946: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d94a: 9904         	ldr	r1, [sp, #0x10]
7009d94c: f7fe fbe0    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x1840
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009d950: 9801         	ldr	r0, [sp, #0x4]
7009d952: 6981         	ldr	r1, [r0, #0x18]
;                                  CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009d954: 6a00         	ldr	r0, [r0, #0x20]
7009d956: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009d95a: f361 701e    	bfi	r0, r1, #28, #3
7009d95e: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RPRI_CTRL, regVal );
7009d960: 9809         	ldr	r0, [sp, #0x24]
7009d962: 6940         	ldr	r0, [r0, #0x14]
7009d964: 9907         	ldr	r1, [sp, #0x1c]
7009d966: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d96a: 3064         	adds	r0, #0x64
7009d96c: 9904         	ldr	r1, [sp, #0x10]
7009d96e: f7fe fbcf    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x1862
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_RXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009d972: 9809         	ldr	r0, [sp, #0x24]
7009d974: 6940         	ldr	r0, [r0, #0x14]
7009d976: 9907         	ldr	r1, [sp, #0x1c]
7009d978: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d97c: 3068         	adds	r0, #0x68
7009d97e: 9901         	ldr	r1, [sp, #0x4]
7009d980: f8b1 1040    	ldrh.w	r1, [r1, #0x40]
7009d984: f7fe fbc4    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x1878
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RST_SCHED, CSL_FMK(BCDMA_RXCCFG_CHAN_RST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009d988: 9809         	ldr	r0, [sp, #0x24]
7009d98a: 6940         	ldr	r0, [r0, #0x14]
7009d98c: 9907         	ldr	r1, [sp, #0x1c]
7009d98e: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009d992: 3080         	adds	r0, #0x80
7009d994: 9901         	ldr	r1, [sp, #0x4]
7009d996: 6b89         	ldr	r1, [r1, #0x38]
7009d998: f001 0103    	and	r1, r1, #0x3
7009d99c: f7fe fbb8    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x1890
7009d9a0: e7ff         	b	0x7009d9a2 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #-0x2
;                 break;
7009d9a2: e003         	b	0x7009d9ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x6
7009d9a4: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
7009d9a8: 9005         	str	r0, [sp, #0x14]
;                 break;
7009d9aa: e7ff         	b	0x7009d9ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #-0x2
7009d9ac: e7ff         	b	0x7009d9ae <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #-0x2
;     return retVal;
7009d9ae: 9805         	ldr	r0, [sp, #0x14]
7009d9b0: b00a         	add	sp, #0x28
7009d9b2: bd80         	pop	{r7, pc}
		...

7009d9c0 <TimerP_setup>:
; {
7009d9c0: b510         	push	{r4, lr}
7009d9c2: b096         	sub	sp, #0x58
7009d9c4: 9015         	str	r0, [sp, #0x54]
7009d9c6: 9114         	str	r1, [sp, #0x50]
;     DebugP_assert( baseAddr!=0U);
7009d9c8: 9815         	ldr	r0, [sp, #0x54]
7009d9ca: 2800         	cmp	r0, #0x0
7009d9cc: bf18         	it	ne
7009d9ce: 2001         	movne	r0, #0x1
7009d9d0: f242 01f2    	movw	r1, #0x20f2
7009d9d4: f2c7 010b    	movt	r1, #0x700b
7009d9d8: 466a         	mov	r2, sp
7009d9da: 6011         	str	r1, [r2]
7009d9dc: f641 5189    	movw	r1, #0x1d89
7009d9e0: f2c7 010b    	movt	r1, #0x700b
7009d9e4: 9106         	str	r1, [sp, #0x18]
7009d9e6: f242 02ff    	movw	r2, #0x20ff
7009d9ea: f2c7 020b    	movt	r2, #0x700b
7009d9ee: 9207         	str	r2, [sp, #0x1c]
7009d9f0: 2342         	movs	r3, #0x42
7009d9f2: f00d f86d    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xd0da
7009d9f6: 9906         	ldr	r1, [sp, #0x18]
7009d9f8: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputPreScaler != 0U);
7009d9fa: 9814         	ldr	r0, [sp, #0x50]
7009d9fc: 6800         	ldr	r0, [r0]
7009d9fe: 2800         	cmp	r0, #0x0
7009da00: bf18         	it	ne
7009da02: 2001         	movne	r0, #0x1
7009da04: f641 53a7    	movw	r3, #0x1da7
7009da08: f2c7 030b    	movt	r3, #0x700b
7009da0c: 46ec         	mov	r12, sp
7009da0e: f8cc 3000    	str.w	r3, [r12]
7009da12: 2343         	movs	r3, #0x43
7009da14: f00d f85c    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xd0b8
7009da18: 9906         	ldr	r1, [sp, #0x18]
7009da1a: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputClkHz != 0U);
7009da1c: 9814         	ldr	r0, [sp, #0x50]
7009da1e: 6840         	ldr	r0, [r0, #0x4]
7009da20: 2800         	cmp	r0, #0x0
7009da22: bf18         	it	ne
7009da24: 2001         	movne	r0, #0x1
7009da26: f641 63d8    	movw	r3, #0x1ed8
7009da2a: f2c7 030b    	movt	r3, #0x700b
7009da2e: 46ec         	mov	r12, sp
7009da30: f8cc 3000    	str.w	r3, [r12]
7009da34: 2344         	movs	r3, #0x44
7009da36: f00d f84b    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xd096
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009da3a: 9814         	ldr	r0, [sp, #0x50]
7009da3c: 6881         	ldr	r1, [r0, #0x8]
7009da3e: 2001         	movs	r0, #0x1
7009da40: 9008         	str	r0, [sp, #0x20]
7009da42: b939         	cbnz	r1, 0x7009da54 <TimerP_setup+0x94> @ imm = #0xe
7009da44: e7ff         	b	0x7009da46 <TimerP_setup+0x86> @ imm = #-0x2
7009da46: 9814         	ldr	r0, [sp, #0x50]
7009da48: 68c0         	ldr	r0, [r0, #0xc]
7009da4a: 2800         	cmp	r0, #0x0
7009da4c: bf18         	it	ne
7009da4e: 2001         	movne	r0, #0x1
7009da50: 9008         	str	r0, [sp, #0x20]
7009da52: e7ff         	b	0x7009da54 <TimerP_setup+0x94> @ imm = #-0x2
7009da54: 9808         	ldr	r0, [sp, #0x20]
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009da56: f000 0001    	and	r0, r0, #0x1
7009da5a: f641 1174    	movw	r1, #0x1974
7009da5e: f2c7 010b    	movt	r1, #0x700b
7009da62: 466a         	mov	r2, sp
7009da64: 6011         	str	r1, [r2]
7009da66: f641 5189    	movw	r1, #0x1d89
7009da6a: f2c7 010b    	movt	r1, #0x700b
7009da6e: 9103         	str	r1, [sp, #0xc]
7009da70: f242 02ff    	movw	r2, #0x20ff
7009da74: f2c7 020b    	movt	r2, #0x700b
7009da78: 9204         	str	r2, [sp, #0x10]
7009da7a: 2345         	movs	r3, #0x45
7009da7c: f00d f828    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xd050
7009da80: 9903         	ldr	r1, [sp, #0xc]
7009da82: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( params->inputPreScaler <= 256U);
7009da84: 9814         	ldr	r0, [sp, #0x50]
7009da86: 6803         	ldr	r3, [r0]
7009da88: 2000         	movs	r0, #0x0
7009da8a: 9005         	str	r0, [sp, #0x14]
7009da8c: f5b3 7f80    	cmp.w	r3, #0x100
7009da90: bf98         	it	ls
7009da92: 2001         	movls	r0, #0x1
7009da94: f641 534b    	movw	r3, #0x1d4b
7009da98: f2c7 030b    	movt	r3, #0x700b
7009da9c: 46ec         	mov	r12, sp
7009da9e: f8cc 3000    	str.w	r3, [r12]
7009daa2: 2347         	movs	r3, #0x47
7009daa4: f00d f814    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xd028
7009daa8: 9903         	ldr	r1, [sp, #0xc]
7009daaa: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( (params->inputClkHz % params->inputPreScaler) == 0U);
7009daac: 9814         	ldr	r0, [sp, #0x50]
7009daae: 6803         	ldr	r3, [r0]
7009dab0: f8d0 c004    	ldr.w	r12, [r0, #0x4]
7009dab4: fbbc f0f3    	udiv	r0, r12, r3
7009dab8: fb00 c013    	mls	r0, r0, r3, r12
7009dabc: fab0 f080    	clz	r0, r0
7009dac0: 0940         	lsrs	r0, r0, #0x5
7009dac2: f641 2357    	movw	r3, #0x1a57
7009dac6: f2c7 030b    	movt	r3, #0x700b
7009daca: 46ec         	mov	r12, sp
7009dacc: f8cc 3000    	str.w	r3, [r12]
7009dad0: 2349         	movs	r3, #0x49
7009dad2: f00c fffd    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xcffa
;     TimerP_stop(baseAddr);
7009dad6: 9815         	ldr	r0, [sp, #0x54]
7009dad8: f011 fde2    	bl	0x700af6a0 <TimerP_stop> @ imm = #0x11bc4
;     TimerP_clearOverflowInt(baseAddr);
7009dadc: 9815         	ldr	r0, [sp, #0x54]
7009dade: f011 f83f    	bl	0x700aeb60 <TimerP_clearOverflowInt> @ imm = #0x1107e
7009dae2: 9905         	ldr	r1, [sp, #0x14]
;     timeInNsec = (uint64_t)params->periodInNsec;
7009dae4: 9814         	ldr	r0, [sp, #0x50]
7009dae6: 68c0         	ldr	r0, [r0, #0xc]
7009dae8: 910f         	str	r1, [sp, #0x3c]
7009daea: 900e         	str	r0, [sp, #0x38]
;     if(timeInNsec == 0U)
7009daec: 980e         	ldr	r0, [sp, #0x38]
7009daee: 990f         	ldr	r1, [sp, #0x3c]
7009daf0: 4308         	orrs	r0, r1
7009daf2: b948         	cbnz	r0, 0x7009db08 <TimerP_setup+0x148> @ imm = #0x12
7009daf4: e7ff         	b	0x7009daf6 <TimerP_setup+0x136> @ imm = #-0x2
;         timeInNsec = (uint64_t)params->periodInUsec*1000U;
7009daf6: 9814         	ldr	r0, [sp, #0x50]
7009daf8: 6880         	ldr	r0, [r0, #0x8]
7009dafa: f44f 717a    	mov.w	r1, #0x3e8
7009dafe: fba0 0101    	umull	r0, r1, r0, r1
7009db02: 910f         	str	r1, [sp, #0x3c]
7009db04: 900e         	str	r0, [sp, #0x38]
;     }
7009db06: e7ff         	b	0x7009db08 <TimerP_setup+0x148> @ imm = #-0x2
;     inputClkHz = (uint64_t)params->inputClkHz / (uint64_t)params->inputPreScaler;
7009db08: 9814         	ldr	r0, [sp, #0x50]
7009db0a: 6802         	ldr	r2, [r0]
7009db0c: 6840         	ldr	r0, [r0, #0x4]
7009db0e: 2300         	movs	r3, #0x0
7009db10: 9302         	str	r3, [sp, #0x8]
7009db12: 4619         	mov	r1, r3
7009db14: f011 eb1e    	blx	0x700af154 <__aeabi_uldivmod> @ imm = #0x1163c
7009db18: 9b02         	ldr	r3, [sp, #0x8]
7009db1a: 910d         	str	r1, [sp, #0x34]
7009db1c: 900c         	str	r0, [sp, #0x30]
;     timerCycles =  ( inputClkHz * timeInNsec ) / 1000000000U;
7009db1e: f8dd c030    	ldr.w	r12, [sp, #0x30]
7009db22: 990d         	ldr	r1, [sp, #0x34]
7009db24: 9a0e         	ldr	r2, [sp, #0x38]
7009db26: f8dd e03c    	ldr.w	lr, [sp, #0x3c]
7009db2a: fbac 0402    	umull	r0, r4, r12, r2
7009db2e: fb0c 4c0e    	mla	r12, r12, lr, r4
7009db32: fb01 c102    	mla	r1, r1, r2, r12
7009db36: f64c 2200    	movw	r2, #0xca00
7009db3a: f6c3 329a    	movt	r2, #0x3b9a
7009db3e: f011 eb0a    	blx	0x700af154 <__aeabi_uldivmod> @ imm = #0x11614
7009db42: 4602         	mov	r2, r0
7009db44: 9802         	ldr	r0, [sp, #0x8]
7009db46: 9201         	str	r2, [sp, #0x4]
7009db48: 460a         	mov	r2, r1
7009db4a: 9901         	ldr	r1, [sp, #0x4]
7009db4c: 920b         	str	r2, [sp, #0x2c]
7009db4e: 910a         	str	r1, [sp, #0x28]
;     DebugP_assert( timerCycles < 0xFFFFFFFFU );
7009db50: 9a0a         	ldr	r2, [sp, #0x28]
7009db52: 990b         	ldr	r1, [sp, #0x2c]
7009db54: f1b2 32ff    	subs.w	r2, r2, #0xffffffff
7009db58: f171 0100    	sbcs	r1, r1, #0x0
7009db5c: bf38         	it	lo
7009db5e: 2001         	movlo	r0, #0x1
7009db60: f641 61be    	movw	r1, #0x1ebe
7009db64: f2c7 010b    	movt	r1, #0x700b
7009db68: 466a         	mov	r2, sp
7009db6a: 6011         	str	r1, [r2]
7009db6c: f641 5189    	movw	r1, #0x1d89
7009db70: f2c7 010b    	movt	r1, #0x700b
7009db74: f242 02ff    	movw	r2, #0x20ff
7009db78: f2c7 020b    	movt	r2, #0x700b
7009db7c: 2359         	movs	r3, #0x59
7009db7e: f00c ffa7    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xcf4e
7009db82: 9802         	ldr	r0, [sp, #0x8]
;     countVal = 0xFFFFFFFFu - (timerCycles - 1U);
7009db84: 990a         	ldr	r1, [sp, #0x28]
7009db86: 4249         	rsbs	r1, r1, #0
7009db88: 9111         	str	r1, [sp, #0x44]
;     reloadVal = 0;
7009db8a: 9010         	str	r0, [sp, #0x40]
;     ctrlVal = 0;
7009db8c: 9012         	str	r0, [sp, #0x48]
;     if(params->inputPreScaler>1U)
7009db8e: 9814         	ldr	r0, [sp, #0x50]
7009db90: 6800         	ldr	r0, [r0]
7009db92: 2802         	cmp	r0, #0x2
7009db94: d320         	blo	0x7009dbd8 <TimerP_setup+0x218> @ imm = #0x40
7009db96: e7ff         	b	0x7009db98 <TimerP_setup+0x1d8> @ imm = #-0x2
7009db98: 2008         	movs	r0, #0x8
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009db9a: 9009         	str	r0, [sp, #0x24]
7009db9c: e7ff         	b	0x7009db9e <TimerP_setup+0x1de> @ imm = #-0x2
7009db9e: 9809         	ldr	r0, [sp, #0x24]
7009dba0: b168         	cbz	r0, 0x7009dbbe <TimerP_setup+0x1fe> @ imm = #0x1a
7009dba2: e7ff         	b	0x7009dba4 <TimerP_setup+0x1e4> @ imm = #-0x2
;             if( (params->inputPreScaler & (0x1U << preScaleVal)) != 0U )
7009dba4: 9814         	ldr	r0, [sp, #0x50]
7009dba6: 6800         	ldr	r0, [r0]
7009dba8: 9909         	ldr	r1, [sp, #0x24]
7009dbaa: 40c8         	lsrs	r0, r1
7009dbac: 07c0         	lsls	r0, r0, #0x1f
7009dbae: b108         	cbz	r0, 0x7009dbb4 <TimerP_setup+0x1f4> @ imm = #0x2
7009dbb0: e7ff         	b	0x7009dbb2 <TimerP_setup+0x1f2> @ imm = #-0x2
;                 break;
7009dbb2: e004         	b	0x7009dbbe <TimerP_setup+0x1fe> @ imm = #0x8
;         }
7009dbb4: e7ff         	b	0x7009dbb6 <TimerP_setup+0x1f6> @ imm = #-0x2
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009dbb6: 9809         	ldr	r0, [sp, #0x24]
7009dbb8: 3801         	subs	r0, #0x1
7009dbba: 9009         	str	r0, [sp, #0x24]
7009dbbc: e7ef         	b	0x7009db9e <TimerP_setup+0x1de> @ imm = #-0x22
;         ctrlVal |= (0x1U << 5);
7009dbbe: 9812         	ldr	r0, [sp, #0x48]
7009dbc0: f040 0020    	orr	r0, r0, #0x20
7009dbc4: 9012         	str	r0, [sp, #0x48]
;         ctrlVal |= ( ((preScaleVal - 1U) & 0x7U) << 2);
7009dbc6: 9809         	ldr	r0, [sp, #0x24]
7009dbc8: 3801         	subs	r0, #0x1
7009dbca: f000 0107    	and	r1, r0, #0x7
7009dbce: 9812         	ldr	r0, [sp, #0x48]
7009dbd0: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009dbd4: 9012         	str	r0, [sp, #0x48]
;     }
7009dbd6: e7ff         	b	0x7009dbd8 <TimerP_setup+0x218> @ imm = #-0x2
;     if(params->oneshotMode==0U)
7009dbd8: 9814         	ldr	r0, [sp, #0x50]
7009dbda: 6900         	ldr	r0, [r0, #0x10]
7009dbdc: b938         	cbnz	r0, 0x7009dbee <TimerP_setup+0x22e> @ imm = #0xe
7009dbde: e7ff         	b	0x7009dbe0 <TimerP_setup+0x220> @ imm = #-0x2
;         ctrlVal |= (0x1U << 1);
7009dbe0: 9812         	ldr	r0, [sp, #0x48]
7009dbe2: f040 0002    	orr	r0, r0, #0x2
7009dbe6: 9012         	str	r0, [sp, #0x48]
;         reloadVal = countVal;
7009dbe8: 9811         	ldr	r0, [sp, #0x44]
7009dbea: 9010         	str	r0, [sp, #0x40]
;     }
7009dbec: e7ff         	b	0x7009dbee <TimerP_setup+0x22e> @ imm = #-0x2
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
7009dbee: 9815         	ldr	r0, [sp, #0x54]
7009dbf0: 3038         	adds	r0, #0x38
7009dbf2: 9013         	str	r0, [sp, #0x4c]
;     *addr = ctrlVal;
7009dbf4: 9812         	ldr	r0, [sp, #0x48]
7009dbf6: 9913         	ldr	r1, [sp, #0x4c]
7009dbf8: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
7009dbfa: 9815         	ldr	r0, [sp, #0x54]
7009dbfc: 303c         	adds	r0, #0x3c
7009dbfe: 9013         	str	r0, [sp, #0x4c]
;     *addr = countVal;
7009dc00: 9811         	ldr	r0, [sp, #0x44]
7009dc02: 9913         	ldr	r1, [sp, #0x4c]
7009dc04: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
7009dc06: 9815         	ldr	r0, [sp, #0x54]
7009dc08: 3040         	adds	r0, #0x40
7009dc0a: 9013         	str	r0, [sp, #0x4c]
;     *addr = reloadVal;
7009dc0c: 9810         	ldr	r0, [sp, #0x40]
7009dc0e: 9913         	ldr	r1, [sp, #0x4c]
7009dc10: 6008         	str	r0, [r1]
;     if((params->enableOverflowInt) != 0U)
7009dc12: 9814         	ldr	r0, [sp, #0x50]
7009dc14: 6940         	ldr	r0, [r0, #0x14]
7009dc16: b138         	cbz	r0, 0x7009dc28 <TimerP_setup+0x268> @ imm = #0xe
7009dc18: e7ff         	b	0x7009dc1a <TimerP_setup+0x25a> @ imm = #-0x2
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_ENABLE);
7009dc1a: 9815         	ldr	r0, [sp, #0x54]
7009dc1c: 302c         	adds	r0, #0x2c
7009dc1e: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009dc20: 9913         	ldr	r1, [sp, #0x4c]
7009dc22: 2002         	movs	r0, #0x2
7009dc24: 6008         	str	r0, [r1]
;     }
7009dc26: e006         	b	0x7009dc36 <TimerP_setup+0x276> @ imm = #0xc
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_DISABLE);
7009dc28: 9815         	ldr	r0, [sp, #0x54]
7009dc2a: 3030         	adds	r0, #0x30
7009dc2c: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009dc2e: 9913         	ldr	r1, [sp, #0x4c]
7009dc30: 2002         	movs	r0, #0x2
7009dc32: 6008         	str	r0, [r1]
7009dc34: e7ff         	b	0x7009dc36 <TimerP_setup+0x276> @ imm = #-0x2
; }
7009dc36: b016         	add	sp, #0x58
7009dc38: bd10         	pop	{r4, pc}
7009dc3a: 0000         	movs	r0, r0
7009dc3c: 0000         	movs	r0, r0
7009dc3e: 0000         	movs	r0, r0

7009dc40 <Udma_chConfigRx>:
; {
7009dc40: b580         	push	{r7, lr}
7009dc42: b09c         	sub	sp, #0x70
7009dc44: 901b         	str	r0, [sp, #0x6c]
7009dc46: 911a         	str	r1, [sp, #0x68]
7009dc48: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009dc4a: 9019         	str	r0, [sp, #0x64]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
7009dc4c: 981b         	ldr	r0, [sp, #0x6c]
7009dc4e: 9017         	str	r0, [sp, #0x5c]
;     if((NULL_PTR == chHandleInt) ||
7009dc50: 9817         	ldr	r0, [sp, #0x5c]
7009dc52: b188         	cbz	r0, 0x7009dc78 <Udma_chConfigRx+0x38> @ imm = #0x22
7009dc54: e7ff         	b	0x7009dc56 <Udma_chConfigRx+0x16> @ imm = #-0x2
;         (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009dc56: 9817         	ldr	r0, [sp, #0x5c]
7009dc58: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009dc5c: f64a 31cd    	movw	r1, #0xabcd
7009dc60: f6ca 31dc    	movt	r1, #0xabdc
7009dc64: 4288         	cmp	r0, r1
7009dc66: d107         	bne	0x7009dc78 <Udma_chConfigRx+0x38> @ imm = #0xe
7009dc68: e7ff         	b	0x7009dc6a <Udma_chConfigRx+0x2a> @ imm = #-0x2
;         ((chHandleInt->chType & UDMA_CH_FLAG_RX) != UDMA_CH_FLAG_RX))
7009dc6a: 9817         	ldr	r0, [sp, #0x5c]
7009dc6c: 6800         	ldr	r0, [r0]
7009dc6e: f000 0002    	and	r0, r0, #0x2
;     if((NULL_PTR == chHandleInt) ||
7009dc72: 2802         	cmp	r0, #0x2
7009dc74: d004         	beq	0x7009dc80 <Udma_chConfigRx+0x40> @ imm = #0x8
7009dc76: e7ff         	b	0x7009dc78 <Udma_chConfigRx+0x38> @ imm = #-0x2
7009dc78: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009dc7c: 9019         	str	r0, [sp, #0x64]
;     }
7009dc7e: e7ff         	b	0x7009dc80 <Udma_chConfigRx+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dc80: 9819         	ldr	r0, [sp, #0x64]
7009dc82: b9a8         	cbnz	r0, 0x7009dcb0 <Udma_chConfigRx+0x70> @ imm = #0x2a
7009dc84: e7ff         	b	0x7009dc86 <Udma_chConfigRx+0x46> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009dc86: 9817         	ldr	r0, [sp, #0x5c]
7009dc88: 6e80         	ldr	r0, [r0, #0x68]
7009dc8a: 9018         	str	r0, [sp, #0x60]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009dc8c: 9818         	ldr	r0, [sp, #0x60]
7009dc8e: b150         	cbz	r0, 0x7009dca6 <Udma_chConfigRx+0x66> @ imm = #0x14
7009dc90: e7ff         	b	0x7009dc92 <Udma_chConfigRx+0x52> @ imm = #-0x2
7009dc92: 9818         	ldr	r0, [sp, #0x60]
7009dc94: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009dc98: f64a 31cd    	movw	r1, #0xabcd
7009dc9c: f6ca 31dc    	movt	r1, #0xabdc
7009dca0: 4288         	cmp	r0, r1
7009dca2: d004         	beq	0x7009dcae <Udma_chConfigRx+0x6e> @ imm = #0x8
7009dca4: e7ff         	b	0x7009dca6 <Udma_chConfigRx+0x66> @ imm = #-0x2
7009dca6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009dcaa: 9019         	str	r0, [sp, #0x64]
;         }
7009dcac: e7ff         	b	0x7009dcae <Udma_chConfigRx+0x6e> @ imm = #-0x2
;     }
7009dcae: e7ff         	b	0x7009dcb0 <Udma_chConfigRx+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dcb0: 9819         	ldr	r0, [sp, #0x64]
7009dcb2: 2800         	cmp	r0, #0x0
7009dcb4: f040 80f1    	bne.w	0x7009de9a <Udma_chConfigRx+0x25a> @ imm = #0x1e2
7009dcb8: e7ff         	b	0x7009dcba <Udma_chConfigRx+0x7a> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009dcba: 9818         	ldr	r0, [sp, #0x60]
7009dcbc: 6800         	ldr	r0, [r0]
7009dcbe: 2801         	cmp	r0, #0x1
7009dcc0: d107         	bne	0x7009dcd2 <Udma_chConfigRx+0x92> @ imm = #0xe
7009dcc2: e7ff         	b	0x7009dcc4 <Udma_chConfigRx+0x84> @ imm = #-0x2
;             ((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
7009dcc4: 9817         	ldr	r0, [sp, #0x5c]
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009dcc6: 7800         	ldrb	r0, [r0]
7009dcc8: 0740         	lsls	r0, r0, #0x1d
7009dcca: 2800         	cmp	r0, #0x0
7009dccc: d501         	bpl	0x7009dcd2 <Udma_chConfigRx+0x92> @ imm = #0x2
7009dcce: e7ff         	b	0x7009dcd0 <Udma_chConfigRx+0x90> @ imm = #-0x2
;         }
7009dcd0: e0e2         	b	0x7009de98 <Udma_chConfigRx+0x258> @ imm = #0x1c4
7009dcd2: f645 70ff    	movw	r0, #0x5fff
;             rmUdmaRxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
7009dcd6: 9010         	str	r0, [sp, #0x40]
;             rmUdmaRxReq.nav_id              = drvHandle->devIdUdma;
7009dcd8: 9818         	ldr	r0, [sp, #0x60]
7009dcda: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009dcde: f8ad 0044    	strh.w	r0, [sp, #0x44]
;             rmUdmaRxReq.index               = (uint16_t)chHandleInt->rxChNum;
7009dce2: 9817         	ldr	r0, [sp, #0x5c]
7009dce4: 6f00         	ldr	r0, [r0, #0x70]
7009dce6: f8ad 0046    	strh.w	r0, [sp, #0x46]
;             rmUdmaRxReq.rx_pause_on_err     = rxPrms->pauseOnError;
7009dcea: 981a         	ldr	r0, [sp, #0x68]
7009dcec: 7800         	ldrb	r0, [r0]
7009dcee: f88d 0054    	strb.w	r0, [sp, #0x54]
;             rmUdmaRxReq.rx_atype            = rxPrms->addrType;
7009dcf2: 981a         	ldr	r0, [sp, #0x68]
7009dcf4: 7840         	ldrb	r0, [r0, #0x1]
7009dcf6: f88d 0055    	strb.w	r0, [sp, #0x55]
;             rmUdmaRxReq.rx_chan_type        = rxPrms->chanType;
7009dcfa: 981a         	ldr	r0, [sp, #0x68]
7009dcfc: 7880         	ldrb	r0, [r0, #0x2]
7009dcfe: f88d 0056    	strb.w	r0, [sp, #0x56]
;             rmUdmaRxReq.rx_fetch_size       = rxPrms->fetchWordSize;
7009dd02: 981a         	ldr	r0, [sp, #0x68]
7009dd04: 8880         	ldrh	r0, [r0, #0x4]
7009dd06: f8ad 0048    	strh.w	r0, [sp, #0x48]
;             rmUdmaRxReq.rx_priority         = rxPrms->busPriority;
7009dd0a: 981a         	ldr	r0, [sp, #0x68]
7009dd0c: 7980         	ldrb	r0, [r0, #0x6]
7009dd0e: f88d 004c    	strb.w	r0, [sp, #0x4c]
;             rmUdmaRxReq.rx_qos              = rxPrms->busQos;
7009dd12: 981a         	ldr	r0, [sp, #0x68]
7009dd14: 79c0         	ldrb	r0, [r0, #0x7]
7009dd16: f88d 004d    	strb.w	r0, [sp, #0x4d]
;             rmUdmaRxReq.rx_orderid          = rxPrms->busOrderId;
7009dd1a: 981a         	ldr	r0, [sp, #0x68]
7009dd1c: 7a00         	ldrb	r0, [r0, #0x8]
7009dd1e: f88d 004e    	strb.w	r0, [sp, #0x4e]
;             rmUdmaRxReq.rx_sched_priority   = rxPrms->dmaPriority;
7009dd22: 981a         	ldr	r0, [sp, #0x68]
7009dd24: 7a40         	ldrb	r0, [r0, #0x9]
7009dd26: f88d 004f    	strb.w	r0, [sp, #0x4f]
;             rmUdmaRxReq.flowid_start        = rxPrms->flowIdFwRangeStart;
7009dd2a: 981a         	ldr	r0, [sp, #0x68]
7009dd2c: 8940         	ldrh	r0, [r0, #0xa]
7009dd2e: f8ad 0050    	strh.w	r0, [sp, #0x50]
;             rmUdmaRxReq.flowid_cnt          = rxPrms->flowIdFwRangeCnt;
7009dd32: 981a         	ldr	r0, [sp, #0x68]
7009dd34: 8980         	ldrh	r0, [r0, #0xc]
7009dd36: f8ad 0052    	strh.w	r0, [sp, #0x52]
;             rmUdmaRxReq.rx_ignore_short     = rxPrms->ignoreShortPkts;
7009dd3a: 981a         	ldr	r0, [sp, #0x68]
7009dd3c: 7c80         	ldrb	r0, [r0, #0x12]
7009dd3e: f88d 0057    	strb.w	r0, [sp, #0x57]
;             rmUdmaRxReq.rx_ignore_long      = rxPrms->ignoreLongPkts;
7009dd42: 981a         	ldr	r0, [sp, #0x68]
7009dd44: 7cc0         	ldrb	r0, [r0, #0x13]
7009dd46: f88d 0058    	strb.w	r0, [sp, #0x58]
;             rmUdmaRxReq.rx_burst_size       = rxPrms->burstSize;
7009dd4a: 981a         	ldr	r0, [sp, #0x68]
7009dd4c: 7e00         	ldrb	r0, [r0, #0x18]
7009dd4e: f88d 0059    	strb.w	r0, [sp, #0x59]
;             if(NULL_PTR != chHandleInt->tdCqRing)
7009dd52: 9817         	ldr	r0, [sp, #0x5c]
7009dd54: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009dd58: b138         	cbz	r0, 0x7009dd6a <Udma_chConfigRx+0x12a> @ imm = #0xe
7009dd5a: e7ff         	b	0x7009dd5c <Udma_chConfigRx+0x11c> @ imm = #-0x2
;                 rmUdmaRxReq.rxcq_qnum          = chHandleInt->tdCqRing->ringNum;
7009dd5c: 9817         	ldr	r0, [sp, #0x5c]
7009dd5e: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009dd62: 8880         	ldrh	r0, [r0, #0x4]
7009dd64: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;             }
7009dd68: e004         	b	0x7009dd74 <Udma_chConfigRx+0x134> @ imm = #0x8
7009dd6a: f64f 70ff    	movw	r0, #0xffff
;                 rmUdmaRxReq.rxcq_qnum          = UDMA_RING_INVALID;
7009dd6e: f8ad 004a    	strh.w	r0, [sp, #0x4a]
7009dd72: e7ff         	b	0x7009dd74 <Udma_chConfigRx+0x134> @ imm = #-0x2
7009dd74: a80e         	add	r0, sp, #0x38
7009dd76: a90c         	add	r1, sp, #0x30
7009dd78: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmUdmapRxChCfg(
7009dd7c: f00e fdb0    	bl	0x700ac8e0 <Sciclient_rmUdmapRxChCfg> @ imm = #0xeb60
7009dd80: 9019         	str	r0, [sp, #0x64]
;             if(CSL_PASS != retVal)
7009dd82: 9819         	ldr	r0, [sp, #0x64]
7009dd84: b108         	cbz	r0, 0x7009dd8a <Udma_chConfigRx+0x14a> @ imm = #0x2
7009dd86: e7ff         	b	0x7009dd88 <Udma_chConfigRx+0x148> @ imm = #-0x2
;             }
7009dd88: e7ff         	b	0x7009dd8a <Udma_chConfigRx+0x14a> @ imm = #-0x2
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009dd8a: 9817         	ldr	r0, [sp, #0x5c]
7009dd8c: 6800         	ldr	r0, [r0]
7009dd8e: f000 0008    	and	r0, r0, #0x8
7009dd92: 2808         	cmp	r0, #0x8
7009dd94: d006         	beq	0x7009dda4 <Udma_chConfigRx+0x164> @ imm = #0xc
7009dd96: e7ff         	b	0x7009dd98 <Udma_chConfigRx+0x158> @ imm = #-0x2
;                     ((chHandleInt->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)) &&
7009dd98: 9817         	ldr	r0, [sp, #0x5c]
7009dd9a: 7800         	ldrb	r0, [r0]
7009dd9c: 06c0         	lsls	r0, r0, #0x1b
7009dd9e: 2800         	cmp	r0, #0x0
7009dda0: d569         	bpl	0x7009de76 <Udma_chConfigRx+0x236> @ imm = #0xd2
7009dda2: e7ff         	b	0x7009dda4 <Udma_chConfigRx+0x164> @ imm = #-0x2
;                (TRUE == rxPrms->configDefaultFlow))
7009dda4: 981a         	ldr	r0, [sp, #0x68]
7009dda6: 6940         	ldr	r0, [r0, #0x14]
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009dda8: 2801         	cmp	r0, #0x1
7009ddaa: d164         	bne	0x7009de76 <Udma_chConfigRx+0x236> @ imm = #0xc8
7009ddac: e7ff         	b	0x7009ddae <Udma_chConfigRx+0x16e> @ imm = #-0x2
;                 UdmaFlowPrms_init(&flowPrms, chHandleInt->chType);
7009ddae: 9817         	ldr	r0, [sp, #0x5c]
7009ddb0: 6801         	ldr	r1, [r0]
7009ddb2: a801         	add	r0, sp, #0x4
7009ddb4: f00b fca4    	bl	0x700a9700 <UdmaFlowPrms_init> @ imm = #0xb948
;                 flowPrms.psInfoPresent = rxPrms->flowPsInfoPresent;
7009ddb8: 981a         	ldr	r0, [sp, #0x68]
7009ddba: 7bc0         	ldrb	r0, [r0, #0xf]
7009ddbc: f88d 0009    	strb.w	r0, [sp, #0x9]
;                 flowPrms.einfoPresent  = rxPrms->flowEInfoPresent;
7009ddc0: 981a         	ldr	r0, [sp, #0x68]
7009ddc2: 7b80         	ldrb	r0, [r0, #0xe]
7009ddc4: f88d 0008    	strb.w	r0, [sp, #0x8]
;                 flowPrms.errorHandling = rxPrms->flowErrorHandling;
7009ddc8: 981a         	ldr	r0, [sp, #0x68]
7009ddca: 7c00         	ldrb	r0, [r0, #0x10]
7009ddcc: f88d 000a    	strb.w	r0, [sp, #0xa]
;                 flowPrms.sopOffset     = rxPrms->flowSopOffset;
7009ddd0: 981a         	ldr	r0, [sp, #0x68]
7009ddd2: 7c40         	ldrb	r0, [r0, #0x11]
7009ddd4: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 if(NULL_PTR == chHandleInt->cqRing)
7009ddd8: 9817         	ldr	r0, [sp, #0x5c]
7009ddda: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009ddde: b928         	cbnz	r0, 0x7009ddec <Udma_chConfigRx+0x1ac> @ imm = #0xa
7009dde0: e7ff         	b	0x7009dde2 <Udma_chConfigRx+0x1a2> @ imm = #-0x2
7009dde2: f64f 70ff    	movw	r0, #0xffff
;                     cqRing = UDMA_RING_INVALID;
7009dde6: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 }
7009ddea: e006         	b	0x7009ddfa <Udma_chConfigRx+0x1ba> @ imm = #0xc
;                     cqRing = chHandleInt->cqRing->ringNum;
7009ddec: 9817         	ldr	r0, [sp, #0x5c]
7009ddee: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009ddf2: 8880         	ldrh	r0, [r0, #0x4]
7009ddf4: f8ad 0002    	strh.w	r0, [sp, #0x2]
7009ddf8: e7ff         	b	0x7009ddfa <Udma_chConfigRx+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == chHandleInt->fqRing)
7009ddfa: 9817         	ldr	r0, [sp, #0x5c]
7009ddfc: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009de00: b928         	cbnz	r0, 0x7009de0e <Udma_chConfigRx+0x1ce> @ imm = #0xa
7009de02: e7ff         	b	0x7009de04 <Udma_chConfigRx+0x1c4> @ imm = #-0x2
7009de04: f64f 70ff    	movw	r0, #0xffff
;                     fqRing = UDMA_RING_INVALID;
7009de08: f8ad 0000    	strh.w	r0, [sp]
;                 }
7009de0c: e006         	b	0x7009de1c <Udma_chConfigRx+0x1dc> @ imm = #0xc
;                     fqRing = chHandleInt->fqRing->ringNum;
7009de0e: 9817         	ldr	r0, [sp, #0x5c]
7009de10: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009de14: 8880         	ldrh	r0, [r0, #0x4]
7009de16: f8ad 0000    	strh.w	r0, [sp]
7009de1a: e7ff         	b	0x7009de1c <Udma_chConfigRx+0x1dc> @ imm = #-0x2
;                 flowPrms.defaultRxCQ    = cqRing;
7009de1c: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
7009de20: f8ad 0010    	strh.w	r0, [sp, #0x10]
;                 flowPrms.fdq0Sz0Qnum    = fqRing;
7009de24: f8bd 0000    	ldrh.w	r0, [sp]
7009de28: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 flowPrms.fdq0Sz1Qnum    = fqRing;
7009de2c: f8bd 0000    	ldrh.w	r0, [sp]
7009de30: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 flowPrms.fdq0Sz2Qnum    = fqRing;
7009de34: f8bd 0000    	ldrh.w	r0, [sp]
7009de38: f8ad 002c    	strh.w	r0, [sp, #0x2c]
;                 flowPrms.fdq0Sz3Qnum    = fqRing;
7009de3c: f8bd 0000    	ldrh.w	r0, [sp]
7009de40: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;                 flowPrms.fdq1Qnum       = fqRing;
7009de44: f8bd 0000    	ldrh.w	r0, [sp]
7009de48: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 flowPrms.fdq2Qnum       = fqRing;
7009de4c: f8bd 0000    	ldrh.w	r0, [sp]
7009de50: f8ad 0020    	strh.w	r0, [sp, #0x20]
;                 flowPrms.fdq3Qnum       = fqRing;
7009de54: f8bd 0000    	ldrh.w	r0, [sp]
7009de58: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                 retVal = Udma_flowConfig(chHandleInt->defaultFlow, 0U, &flowPrms);
7009de5c: 9817         	ldr	r0, [sp, #0x5c]
7009de5e: f8d0 01c8    	ldr.w	r0, [r0, #0x1c8]
7009de62: 2100         	movs	r1, #0x0
7009de64: aa01         	add	r2, sp, #0x4
7009de66: f001 f9d3    	bl	0x7009f210 <Udma_flowConfig> @ imm = #0x13a6
7009de6a: 9019         	str	r0, [sp, #0x64]
;                 if(UDMA_SOK != retVal)
7009de6c: 9819         	ldr	r0, [sp, #0x64]
7009de6e: b108         	cbz	r0, 0x7009de74 <Udma_chConfigRx+0x234> @ imm = #0x2
7009de70: e7ff         	b	0x7009de72 <Udma_chConfigRx+0x232> @ imm = #-0x2
;                 }
7009de72: e7ff         	b	0x7009de74 <Udma_chConfigRx+0x234> @ imm = #-0x2
;             }
7009de74: e7ff         	b	0x7009de76 <Udma_chConfigRx+0x236> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009de76: 9819         	ldr	r0, [sp, #0x64]
7009de78: b968         	cbnz	r0, 0x7009de96 <Udma_chConfigRx+0x256> @ imm = #0x1a
7009de7a: e7ff         	b	0x7009de7c <Udma_chConfigRx+0x23c> @ imm = #-0x2
;                 (void) memcpy(&chHandleInt->rxPrms, rxPrms, sizeof(chHandleInt->rxPrms));
7009de7c: 9817         	ldr	r0, [sp, #0x5c]
7009de7e: f500 70fc    	add.w	r0, r0, #0x1f8
7009de82: 991a         	ldr	r1, [sp, #0x68]
7009de84: e8b1 100c    	ldm.w	r1!, {r2, r3, r12}
7009de88: e8a0 100c    	stm.w	r0!, {r2, r3, r12}
7009de8c: e891 500c    	ldm.w	r1, {r2, r3, r12, lr}
7009de90: e880 500c    	stm.w	r0, {r2, r3, r12, lr}
;             }
7009de94: e7ff         	b	0x7009de96 <Udma_chConfigRx+0x256> @ imm = #-0x2
7009de96: e7ff         	b	0x7009de98 <Udma_chConfigRx+0x258> @ imm = #-0x2
;     }
7009de98: e7ff         	b	0x7009de9a <Udma_chConfigRx+0x25a> @ imm = #-0x2
;     return (retVal);
7009de9a: 9819         	ldr	r0, [sp, #0x64]
7009de9c: b01c         	add	sp, #0x70
7009de9e: bd80         	pop	{r7, pc}

7009dea0 <Sciclient_rmIrqFindRoute>:
; {
7009dea0: b580         	push	{r7, lr}
7009dea2: b08a         	sub	sp, #0x28
7009dea4: 9009         	str	r0, [sp, #0x24]
7009dea6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009dea8: 9008         	str	r0, [sp, #0x20]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009deaa: 9809         	ldr	r0, [sp, #0x24]
7009deac: 88c0         	ldrh	r0, [r0, #0x6]
7009deae: f010 fcef    	bl	0x700ae890 <Sciclient_rmIrIsIr> @ imm = #0x109de
7009deb2: b930         	cbnz	r0, 0x7009dec2 <Sciclient_rmIrqFindRoute+0x22> @ imm = #0xc
7009deb4: e7ff         	b	0x7009deb6 <Sciclient_rmIrqFindRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009deb6: 9809         	ldr	r0, [sp, #0x24]
7009deb8: 8940         	ldrh	r0, [r0, #0xa]
7009deba: f010 fce9    	bl	0x700ae890 <Sciclient_rmIrIsIr> @ imm = #0x109d2
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009debe: b120         	cbz	r0, 0x7009deca <Sciclient_rmIrqFindRoute+0x2a> @ imm = #0x8
7009dec0: e7ff         	b	0x7009dec2 <Sciclient_rmIrqFindRoute+0x22> @ imm = #-0x2
7009dec2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009dec6: 9008         	str	r0, [sp, #0x20]
;     }
7009dec8: e7ff         	b	0x7009deca <Sciclient_rmIrqFindRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009deca: 9808         	ldr	r0, [sp, #0x20]
7009decc: bb20         	cbnz	r0, 0x7009df18 <Sciclient_rmIrqFindRoute+0x78> @ imm = #0x48
7009dece: e7ff         	b	0x7009ded0 <Sciclient_rmIrqFindRoute+0x30> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009ded0: 9809         	ldr	r0, [sp, #0x24]
7009ded2: 8a00         	ldrh	r0, [r0, #0x10]
7009ded4: 28ff         	cmp	r0, #0xff
7009ded6: d015         	beq	0x7009df04 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x2a
7009ded8: e7ff         	b	0x7009deda <Sciclient_rmIrqFindRoute+0x3a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009deda: 9809         	ldr	r0, [sp, #0x24]
7009dedc: 6800         	ldr	r0, [r0]
7009dede: 2104         	movs	r1, #0x4
7009dee0: f010 feb6    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x10d6c
;              true) &&
7009dee4: b170         	cbz	r0, 0x7009df04 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x1c
7009dee6: e7ff         	b	0x7009dee8 <Sciclient_rmIrqFindRoute+0x48> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009dee8: 9809         	ldr	r0, [sp, #0x24]
7009deea: 6800         	ldr	r0, [r0]
7009deec: 2108         	movs	r1, #0x8
7009deee: f010 feaf    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x10d5e
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009def2: b138         	cbz	r0, 0x7009df04 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0xe
7009def4: e7ff         	b	0x7009def6 <Sciclient_rmIrqFindRoute+0x56> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009def6: 9809         	ldr	r0, [sp, #0x24]
7009def8: 8a00         	ldrh	r0, [r0, #0x10]
7009defa: a905         	add	r1, sp, #0x14
7009defc: f007 ff18    	bl	0x700a5d30 <Sciclient_rmIrqGetNode> @ imm = #0x7e30
7009df00: 9008         	str	r0, [sp, #0x20]
;         } else {
7009df02: e006         	b	0x7009df12 <Sciclient_rmIrqFindRoute+0x72> @ imm = #0xc
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009df04: 9809         	ldr	r0, [sp, #0x24]
7009df06: 88c0         	ldrh	r0, [r0, #0x6]
7009df08: a905         	add	r1, sp, #0x14
7009df0a: f007 ff11    	bl	0x700a5d30 <Sciclient_rmIrqGetNode> @ imm = #0x7e22
7009df0e: 9008         	str	r0, [sp, #0x20]
7009df10: e7ff         	b	0x7009df12 <Sciclient_rmIrqFindRoute+0x72> @ imm = #-0x2
;         root_n = cur_n;
7009df12: 9805         	ldr	r0, [sp, #0x14]
7009df14: 9004         	str	r0, [sp, #0x10]
;     }
7009df16: e7ff         	b	0x7009df18 <Sciclient_rmIrqFindRoute+0x78> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009df18: 9808         	ldr	r0, [sp, #0x20]
7009df1a: b968         	cbnz	r0, 0x7009df38 <Sciclient_rmIrqFindRoute+0x98> @ imm = #0x1a
7009df1c: e7ff         	b	0x7009df1e <Sciclient_rmIrqFindRoute+0x7e> @ imm = #-0x2
7009df1e: 2001         	movs	r0, #0x1
;         search = true;
7009df20: 9002         	str	r0, [sp, #0x8]
7009df22: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         Sciclient_rmPsInit();
7009df26: f011 fa5b    	bl	0x700af3e0 <Sciclient_rmPsInit> @ imm = #0x114b6
7009df2a: 9802         	ldr	r0, [sp, #0x8]
;         search_depth = 1u;
7009df2c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009df30: 2000         	movs	r0, #0x0
;         if_idx = 0u;
7009df32: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     } else {
7009df36: e003         	b	0x7009df40 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #0x6
7009df38: 2000         	movs	r0, #0x0
;         search = false;
7009df3a: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009df3e: e7ff         	b	0x7009df40 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #-0x2
;     while (search == true) {
7009df40: e7ff         	b	0x7009df42 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x2
7009df42: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009df46: 07c0         	lsls	r0, r0, #0x1f
7009df48: 2800         	cmp	r0, #0x0
7009df4a: f000 80ca    	beq.w	0x7009e0e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x194
7009df4e: e7ff         	b	0x7009df50 <Sciclient_rmIrqFindRoute+0xb0> @ imm = #-0x2
7009df50: 2000         	movs	r0, #0x0
;         node_clear = false;
7009df52: f88d 0019    	strb.w	r0, [sp, #0x19]
;         if (if_idx < cur_n->n_if) {
7009df56: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009df5a: 9905         	ldr	r1, [sp, #0x14]
7009df5c: 8849         	ldrh	r1, [r1, #0x2]
7009df5e: 4288         	cmp	r0, r1
7009df60: f280 8087    	bge.w	0x7009e072 <Sciclient_rmIrqFindRoute+0x1d2> @ imm = #0x10e
7009df64: e7ff         	b	0x7009df66 <Sciclient_rmIrqFindRoute+0xc6> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009df66: 9805         	ldr	r0, [sp, #0x14]
7009df68: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009df6c: aa03         	add	r2, sp, #0xc
7009df6e: f00f fd0f    	bl	0x700ad990 <Sciclient_rmIrqGetNodeItf> @ imm = #0xfa1e
7009df72: 9008         	str	r0, [sp, #0x20]
;             if (r != SystemP_SUCCESS) {
7009df74: 9808         	ldr	r0, [sp, #0x20]
7009df76: b108         	cbz	r0, 0x7009df7c <Sciclient_rmIrqFindRoute+0xdc> @ imm = #0x2
7009df78: e7ff         	b	0x7009df7a <Sciclient_rmIrqFindRoute+0xda> @ imm = #-0x2
;                 break;
7009df7a: e0b2         	b	0x7009e0e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x164
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009df7c: 9805         	ldr	r0, [sp, #0x14]
7009df7e: 8800         	ldrh	r0, [r0]
7009df80: f010 fc6e    	bl	0x700ae860 <Sciclient_rmIaIsIa> @ imm = #0x108dc
7009df84: b9d0         	cbnz	r0, 0x7009dfbc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x34
7009df86: e7ff         	b	0x7009df88 <Sciclient_rmIrqFindRoute+0xe8> @ imm = #-0x2
;                 (Sciclient_rmPsIsEmpty() == true) &&
7009df88: f010 fe7a    	bl	0x700aec80 <Sciclient_rmPsIsEmpty> @ imm = #0x10cf4
7009df8c: b1b0         	cbz	r0, 0x7009dfbc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x2c
7009df8e: e7ff         	b	0x7009df90 <Sciclient_rmIrqFindRoute+0xf0> @ imm = #-0x2
;                 ((cfg->s_idx < cur_if->lbase) ||
7009df90: 9809         	ldr	r0, [sp, #0x24]
7009df92: 8900         	ldrh	r0, [r0, #0x8]
7009df94: 9903         	ldr	r1, [sp, #0xc]
7009df96: 8809         	ldrh	r1, [r1]
7009df98: 4288         	cmp	r0, r1
7009df9a: db09         	blt	0x7009dfb0 <Sciclient_rmIrqFindRoute+0x110> @ imm = #0x12
7009df9c: e7ff         	b	0x7009df9e <Sciclient_rmIrqFindRoute+0xfe> @ imm = #-0x2
;                  (cfg->s_idx >= (cur_if->lbase + cur_if->len)))) {
7009df9e: 9809         	ldr	r0, [sp, #0x24]
7009dfa0: 8900         	ldrh	r0, [r0, #0x8]
7009dfa2: 9a03         	ldr	r2, [sp, #0xc]
7009dfa4: 8811         	ldrh	r1, [r2]
7009dfa6: 8892         	ldrh	r2, [r2, #0x4]
7009dfa8: 4411         	add	r1, r2
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009dfaa: 4288         	cmp	r0, r1
7009dfac: db06         	blt	0x7009dfbc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0xc
7009dfae: e7ff         	b	0x7009dfb0 <Sciclient_rmIrqFindRoute+0x110> @ imm = #-0x2
;                 if_idx++;
7009dfb0: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009dfb4: 3001         	adds	r0, #0x1
7009dfb6: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             } else if (Sciclient_rmPsGetPsp() < search_depth) {
7009dfba: e059         	b	0x7009e070 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #0xb2
7009dfbc: f011 fe40    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0x11c80
7009dfc0: f8bd 101c    	ldrh.w	r1, [sp, #0x1c]
7009dfc4: 4288         	cmp	r0, r1
7009dfc6: da1e         	bge	0x7009e006 <Sciclient_rmIrqFindRoute+0x166> @ imm = #0x3c
7009dfc8: e7ff         	b	0x7009dfca <Sciclient_rmIrqFindRoute+0x12a> @ imm = #-0x2
;                 r = Sciclient_rmPsPush(cur_n, if_idx);
7009dfca: 9805         	ldr	r0, [sp, #0x14]
7009dfcc: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009dfd0: f00e fa46    	bl	0x700ac460 <Sciclient_rmPsPush> @ imm = #0xe48c
7009dfd4: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009dfd6: 9808         	ldr	r0, [sp, #0x20]
7009dfd8: b108         	cbz	r0, 0x7009dfde <Sciclient_rmIrqFindRoute+0x13e> @ imm = #0x2
7009dfda: e7ff         	b	0x7009dfdc <Sciclient_rmIrqFindRoute+0x13c> @ imm = #-0x2
;                     break;
7009dfdc: e081         	b	0x7009e0e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x102
;                 r = Sciclient_rmIrqGetNode(cur_if->rid, &cur_n);
7009dfde: 9803         	ldr	r0, [sp, #0xc]
7009dfe0: 88c0         	ldrh	r0, [r0, #0x6]
7009dfe2: a905         	add	r1, sp, #0x14
7009dfe4: f007 fea4    	bl	0x700a5d30 <Sciclient_rmIrqGetNode> @ imm = #0x7d48
7009dfe8: 9008         	str	r0, [sp, #0x20]
;                 if (cur_n == NULL) {
7009dfea: 9805         	ldr	r0, [sp, #0x14]
7009dfec: b930         	cbnz	r0, 0x7009dffc <Sciclient_rmIrqFindRoute+0x15c> @ imm = #0xc
7009dfee: e7ff         	b	0x7009dff0 <Sciclient_rmIrqFindRoute+0x150> @ imm = #-0x2
7009dff0: 2001         	movs	r0, #0x1
;                     node_clear = true;
7009dff2: f88d 0019    	strb.w	r0, [sp, #0x19]
7009dff6: 2000         	movs	r0, #0x0
;                     r = SystemP_SUCCESS;
7009dff8: 9008         	str	r0, [sp, #0x20]
;                 } else {
7009dffa: e003         	b	0x7009e004 <Sciclient_rmIrqFindRoute+0x164> @ imm = #0x6
7009dffc: 2000         	movs	r0, #0x0
;                     if_idx = 0u;
7009dffe: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e002: e7ff         	b	0x7009e004 <Sciclient_rmIrqFindRoute+0x164> @ imm = #-0x2
;             } else {
7009e004: e033         	b	0x7009e06e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #0x66
;                 if ((cur_if->rid == cfg->d_id) &&
7009e006: 9803         	ldr	r0, [sp, #0xc]
7009e008: 88c0         	ldrh	r0, [r0, #0x6]
7009e00a: 9909         	ldr	r1, [sp, #0x24]
7009e00c: 8949         	ldrh	r1, [r1, #0xa]
7009e00e: 4288         	cmp	r0, r1
7009e010: d127         	bne	0x7009e062 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x4e
7009e012: e7ff         	b	0x7009e014 <Sciclient_rmIrqFindRoute+0x174> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
7009e014: 9809         	ldr	r0, [sp, #0x24]
7009e016: 8980         	ldrh	r0, [r0, #0xc]
7009e018: 9903         	ldr	r1, [sp, #0xc]
7009e01a: 8849         	ldrh	r1, [r1, #0x2]
7009e01c: 4288         	cmp	r0, r1
7009e01e: db20         	blt	0x7009e062 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x40
7009e020: e7ff         	b	0x7009e022 <Sciclient_rmIrqFindRoute+0x182> @ imm = #-0x2
;                     (cfg->d_irq <
7009e022: 9809         	ldr	r0, [sp, #0x24]
7009e024: 8980         	ldrh	r0, [r0, #0xc]
;                      (cur_if->rbase + cur_if->len))) {
7009e026: 9a03         	ldr	r2, [sp, #0xc]
7009e028: 8851         	ldrh	r1, [r2, #0x2]
7009e02a: 8892         	ldrh	r2, [r2, #0x4]
7009e02c: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
7009e02e: 4288         	cmp	r0, r1
7009e030: da17         	bge	0x7009e062 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x2e
7009e032: e7ff         	b	0x7009e034 <Sciclient_rmIrqFindRoute+0x194> @ imm = #-0x2
;                     r = Sciclient_rmPsPush(cur_n, if_idx);
7009e034: 9805         	ldr	r0, [sp, #0x14]
7009e036: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009e03a: f00e fa11    	bl	0x700ac460 <Sciclient_rmPsPush> @ imm = #0xe422
7009e03e: 9008         	str	r0, [sp, #0x20]
;                     if (r != SystemP_SUCCESS) {
7009e040: 9808         	ldr	r0, [sp, #0x20]
7009e042: b108         	cbz	r0, 0x7009e048 <Sciclient_rmIrqFindRoute+0x1a8> @ imm = #0x2
7009e044: e7ff         	b	0x7009e046 <Sciclient_rmIrqFindRoute+0x1a6> @ imm = #-0x2
;                         break;
7009e046: e04c         	b	0x7009e0e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x98
;                     if (Sciclient_rmIrqRouteValidate(cfg) == true) {
7009e048: 9809         	ldr	r0, [sp, #0x24]
7009e04a: f7fc fca9    	bl	0x7009a9a0 <Sciclient_rmIrqRouteValidate> @ imm = #-0x36ae
7009e04e: b108         	cbz	r0, 0x7009e054 <Sciclient_rmIrqFindRoute+0x1b4> @ imm = #0x2
7009e050: e7ff         	b	0x7009e052 <Sciclient_rmIrqFindRoute+0x1b2> @ imm = #-0x2
;                         break;
7009e052: e046         	b	0x7009e0e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x8c
7009e054: a805         	add	r0, sp, #0x14
7009e056: f10d 011a    	add.w	r1, sp, #0x1a
;                         Sciclient_rmPsPop(&cur_n, &if_idx);
7009e05a: f00b fd31    	bl	0x700a9ac0 <Sciclient_rmPsPop> @ imm = #0xba62
7009e05e: e7ff         	b	0x7009e060 <Sciclient_rmIrqFindRoute+0x1c0> @ imm = #-0x2
;                 }
7009e060: e7ff         	b	0x7009e062 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #-0x2
;                 if_idx++;
7009e062: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e066: 3001         	adds	r0, #0x1
7009e068: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e06c: e7ff         	b	0x7009e06e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #-0x2
7009e06e: e7ff         	b	0x7009e070 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #-0x2
;         } else {
7009e070: e003         	b	0x7009e07a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #0x6
7009e072: 2001         	movs	r0, #0x1
;             node_clear = true;
7009e074: f88d 0019    	strb.w	r0, [sp, #0x19]
7009e078: e7ff         	b	0x7009e07a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #-0x2
;         if (node_clear == true) {
7009e07a: f89d 0019    	ldrb.w	r0, [sp, #0x19]
7009e07e: 07c0         	lsls	r0, r0, #0x1f
7009e080: b370         	cbz	r0, 0x7009e0e0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #0x5c
7009e082: e7ff         	b	0x7009e084 <Sciclient_rmIrqFindRoute+0x1e4> @ imm = #-0x2
;             if (Sciclient_rmPsIsEmpty() == true) {
7009e084: f010 fdfc    	bl	0x700aec80 <Sciclient_rmPsIsEmpty> @ imm = #0x10bf8
7009e088: b1c8         	cbz	r0, 0x7009e0be <Sciclient_rmIrqFindRoute+0x21e> @ imm = #0x32
7009e08a: e7ff         	b	0x7009e08c <Sciclient_rmIrqFindRoute+0x1ec> @ imm = #-0x2
;                 search_depth++;
7009e08c: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009e090: 3001         	adds	r0, #0x1
7009e092: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 cur_n = root_n;
7009e096: 9804         	ldr	r0, [sp, #0x10]
7009e098: 9005         	str	r0, [sp, #0x14]
7009e09a: 2000         	movs	r0, #0x0
;                 if_idx = 0u;
7009e09c: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;                 if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009e0a0: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009e0a4: 9001         	str	r0, [sp, #0x4]
7009e0a6: f011 fe23    	bl	0x700afcf0 <Sciclient_rmPsGetMaxPsp> @ imm = #0x11c46
7009e0aa: 4601         	mov	r1, r0
7009e0ac: 9801         	ldr	r0, [sp, #0x4]
7009e0ae: 4288         	cmp	r0, r1
7009e0b0: db04         	blt	0x7009e0bc <Sciclient_rmIrqFindRoute+0x21c> @ imm = #0x8
7009e0b2: e7ff         	b	0x7009e0b4 <Sciclient_rmIrqFindRoute+0x214> @ imm = #-0x2
7009e0b4: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
7009e0b8: 9008         	str	r0, [sp, #0x20]
;                     break;
7009e0ba: e012         	b	0x7009e0e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x24
;             } else {
7009e0bc: e00f         	b	0x7009e0de <Sciclient_rmIrqFindRoute+0x23e> @ imm = #0x1e
7009e0be: a805         	add	r0, sp, #0x14
7009e0c0: f10d 011a    	add.w	r1, sp, #0x1a
;                 r = Sciclient_rmPsPop(&cur_n, &if_idx);
7009e0c4: f00b fcfc    	bl	0x700a9ac0 <Sciclient_rmPsPop> @ imm = #0xb9f8
7009e0c8: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009e0ca: 9808         	ldr	r0, [sp, #0x20]
7009e0cc: b108         	cbz	r0, 0x7009e0d2 <Sciclient_rmIrqFindRoute+0x232> @ imm = #0x2
7009e0ce: e7ff         	b	0x7009e0d0 <Sciclient_rmIrqFindRoute+0x230> @ imm = #-0x2
;                     break;
7009e0d0: e007         	b	0x7009e0e2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0xe
;                 if_idx++;
7009e0d2: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e0d6: 3001         	adds	r0, #0x1
7009e0d8: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e0dc: e7ff         	b	0x7009e0de <Sciclient_rmIrqFindRoute+0x23e> @ imm = #-0x2
;         }
7009e0de: e7ff         	b	0x7009e0e0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #-0x2
;     while (search == true) {
7009e0e0: e72f         	b	0x7009df42 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x1a2
;     return r;
7009e0e2: 9808         	ldr	r0, [sp, #0x20]
7009e0e4: b00a         	add	sp, #0x28
7009e0e6: bd80         	pop	{r7, pc}
		...

7009e0f0 <UART_fifoConfig>:
; {
7009e0f0: b580         	push	{r7, lr}
7009e0f2: b092         	sub	sp, #0x48
7009e0f4: 9011         	str	r0, [sp, #0x44]
7009e0f6: 9110         	str	r1, [sp, #0x40]
7009e0f8: 2000         	movs	r0, #0x0
;     uint32_t fcrValue = 0U;
7009e0fa: 900c         	str	r0, [sp, #0x30]
;     uint32_t txGra = (fifoConfig & UART_FIFO_CONFIG_TXGRA) >> 26;
7009e0fc: 9810         	ldr	r0, [sp, #0x40]
7009e0fe: f3c0 6083    	ubfx	r0, r0, #0x1a, #0x4
7009e102: 900b         	str	r0, [sp, #0x2c]
;     uint32_t rxGra = (fifoConfig & UART_FIFO_CONFIG_RXGRA) >> 22;
7009e104: 9810         	ldr	r0, [sp, #0x40]
7009e106: f3c0 5083    	ubfx	r0, r0, #0x16, #0x4
7009e10a: 900a         	str	r0, [sp, #0x28]
;     uint32_t txTrig = (fifoConfig & UART_FIFO_CONFIG_TXTRIG) >> 14;
7009e10c: 9810         	ldr	r0, [sp, #0x40]
7009e10e: f3c0 3087    	ubfx	r0, r0, #0xe, #0x8
7009e112: 9009         	str	r0, [sp, #0x24]
;     uint32_t rxTrig = (fifoConfig & UART_FIFO_CONFIG_RXTRIG) >> 6;
7009e114: 9810         	ldr	r0, [sp, #0x40]
7009e116: f3c0 1087    	ubfx	r0, r0, #0x6, #0x8
7009e11a: 9008         	str	r0, [sp, #0x20]
;     uint32_t txClr = (fifoConfig & UART_FIFO_CONFIG_TXCLR) >> 5;
7009e11c: 9810         	ldr	r0, [sp, #0x40]
7009e11e: f3c0 1040    	ubfx	r0, r0, #0x5, #0x1
7009e122: 9007         	str	r0, [sp, #0x1c]
;     uint32_t rxClr = (fifoConfig & UART_FIFO_CONFIG_RXCLR) >> 4;
7009e124: 9810         	ldr	r0, [sp, #0x40]
7009e126: f3c0 1000    	ubfx	r0, r0, #0x4, #0x1
7009e12a: 9006         	str	r0, [sp, #0x18]
;     uint32_t dmaEnPath = (fifoConfig & UART_FIFO_CONFIG_DMAENPATH) >> 3;
7009e12c: 9810         	ldr	r0, [sp, #0x40]
7009e12e: f3c0 00c0    	ubfx	r0, r0, #0x3, #0x1
7009e132: 9005         	str	r0, [sp, #0x14]
;     uint32_t dmaMode   = (fifoConfig & UART_FIFO_CONFIG_DMAMODE);
7009e134: 9810         	ldr	r0, [sp, #0x40]
7009e136: f000 0007    	and	r0, r0, #0x7
7009e13a: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
7009e13c: 9811         	ldr	r0, [sp, #0x44]
7009e13e: f00f ff47    	bl	0x700adfd0 <UART_enhanFuncEnable> @ imm = #0xfe8e
7009e142: 900f         	str	r0, [sp, #0x3c]
;     tcrTlrBitVal = UART_subConfigTCRTLRModeEn(baseAddr);
7009e144: 9811         	ldr	r0, [sp, #0x44]
7009e146: f00b f9eb    	bl	0x700a9520 <UART_subConfigTCRTLRModeEn> @ imm = #0xb3d6
7009e14a: 900e         	str	r0, [sp, #0x38]
;     fcrValue |= UART_FCR_FIFO_EN_MASK;
7009e14c: 980c         	ldr	r0, [sp, #0x30]
7009e14e: f040 0001    	orr	r0, r0, #0x1
7009e152: 900c         	str	r0, [sp, #0x30]
;     if(UART_TRIG_LVL_GRANULARITY_1 != rxGra)
7009e154: 980a         	ldr	r0, [sp, #0x28]
7009e156: 2801         	cmp	r0, #0x1
7009e158: d033         	beq	0x7009e1c2 <UART_fifoConfig+0xd2> @ imm = #0x66
7009e15a: e7ff         	b	0x7009e15c <UART_fifoConfig+0x6c> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009e15c: 9811         	ldr	r0, [sp, #0x44]
7009e15e: 3040         	adds	r0, #0x40
7009e160: 2180         	movs	r1, #0x80
7009e162: 2207         	movs	r2, #0x7
7009e164: 2300         	movs	r3, #0x0
7009e166: 9303         	str	r3, [sp, #0xc]
7009e168: f010 fa4a    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x10494
7009e16c: 9b03         	ldr	r3, [sp, #0xc]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009e16e: 9811         	ldr	r0, [sp, #0x44]
7009e170: 301c         	adds	r0, #0x1c
7009e172: 21f0         	movs	r1, #0xf0
7009e174: 2204         	movs	r2, #0x4
7009e176: f010 fa43    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x10486
;         fcrValue &= ~((uint32_t) UART_FCR_RX_FIFO_TRIG_MASK);
7009e17a: 980c         	ldr	r0, [sp, #0x30]
7009e17c: f020 00c0    	bic	r0, r0, #0xc0
7009e180: 900c         	str	r0, [sp, #0x30]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009e182: 9808         	ldr	r0, [sp, #0x20]
7009e184: 2808         	cmp	r0, #0x8
7009e186: d00c         	beq	0x7009e1a2 <UART_fifoConfig+0xb2> @ imm = #0x18
7009e188: e7ff         	b	0x7009e18a <UART_fifoConfig+0x9a> @ imm = #-0x2
;            (UART_RXTRIGLVL_16 == rxTrig) ||
7009e18a: 9808         	ldr	r0, [sp, #0x20]
7009e18c: 2810         	cmp	r0, #0x10
7009e18e: d008         	beq	0x7009e1a2 <UART_fifoConfig+0xb2> @ imm = #0x10
7009e190: e7ff         	b	0x7009e192 <UART_fifoConfig+0xa2> @ imm = #-0x2
;            (UART_RXTRIGLVL_56 == rxTrig) ||
7009e192: 9808         	ldr	r0, [sp, #0x20]
7009e194: 2838         	cmp	r0, #0x38
7009e196: d004         	beq	0x7009e1a2 <UART_fifoConfig+0xb2> @ imm = #0x8
7009e198: e7ff         	b	0x7009e19a <UART_fifoConfig+0xaa> @ imm = #-0x2
;            (UART_RXTRIGLVL_60 == rxTrig))
7009e19a: 9808         	ldr	r0, [sp, #0x20]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009e19c: 283c         	cmp	r0, #0x3c
7009e19e: d107         	bne	0x7009e1b0 <UART_fifoConfig+0xc0> @ imm = #0xe
7009e1a0: e7ff         	b	0x7009e1a2 <UART_fifoConfig+0xb2> @ imm = #-0x2
;             fcrValue |= rxTrig & UART_FCR_RX_FIFO_TRIG_MASK;
7009e1a2: 9808         	ldr	r0, [sp, #0x20]
7009e1a4: f000 01c0    	and	r1, r0, #0xc0
7009e1a8: 980c         	ldr	r0, [sp, #0x30]
7009e1aa: 4308         	orrs	r0, r1
7009e1ac: 900c         	str	r0, [sp, #0x30]
;         }
7009e1ae: e007         	b	0x7009e1c0 <UART_fifoConfig+0xd0> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009e1b0: 9811         	ldr	r0, [sp, #0x44]
7009e1b2: 301c         	adds	r0, #0x1c
7009e1b4: 9b08         	ldr	r3, [sp, #0x20]
7009e1b6: 21f0         	movs	r1, #0xf0
7009e1b8: 2204         	movs	r2, #0x4
7009e1ba: f010 fa21    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x10442
7009e1be: e7ff         	b	0x7009e1c0 <UART_fifoConfig+0xd0> @ imm = #-0x2
;     }
7009e1c0: e01d         	b	0x7009e1fe <UART_fifoConfig+0x10e> @ imm = #0x3a
;         rxTrig &= 0x003FU;
7009e1c2: 9808         	ldr	r0, [sp, #0x20]
7009e1c4: f000 003f    	and	r0, r0, #0x3f
7009e1c8: 9008         	str	r0, [sp, #0x20]
;         tlrValue = (rxTrig & 0x003CU) >> 2;
7009e1ca: 9808         	ldr	r0, [sp, #0x20]
7009e1cc: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009e1d0: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (rxTrig & 0x0003U) << UART_FCR_RX_FIFO_TRIG_SHIFT;
7009e1d2: 9808         	ldr	r0, [sp, #0x20]
7009e1d4: f000 0103    	and	r1, r0, #0x3
7009e1d8: 980c         	ldr	r0, [sp, #0x30]
7009e1da: ea40 1081    	orr.w	r0, r0, r1, lsl #6
7009e1de: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009e1e0: 9811         	ldr	r0, [sp, #0x44]
7009e1e2: 3040         	adds	r0, #0x40
7009e1e4: 2180         	movs	r1, #0x80
7009e1e6: 2207         	movs	r2, #0x7
7009e1e8: 2301         	movs	r3, #0x1
7009e1ea: f010 fa09    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x10412
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA, tlrValue);
7009e1ee: 9811         	ldr	r0, [sp, #0x44]
7009e1f0: 301c         	adds	r0, #0x1c
7009e1f2: 9b0d         	ldr	r3, [sp, #0x34]
7009e1f4: 21f0         	movs	r1, #0xf0
7009e1f6: 2204         	movs	r2, #0x4
7009e1f8: f010 fa02    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x10404
7009e1fc: e7ff         	b	0x7009e1fe <UART_fifoConfig+0x10e> @ imm = #-0x2
;     if(UART_TRIG_LVL_GRANULARITY_1 != txGra)
7009e1fe: 980b         	ldr	r0, [sp, #0x2c]
7009e200: 2801         	cmp	r0, #0x1
7009e202: d033         	beq	0x7009e26c <UART_fifoConfig+0x17c> @ imm = #0x66
7009e204: e7ff         	b	0x7009e206 <UART_fifoConfig+0x116> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009e206: 9811         	ldr	r0, [sp, #0x44]
7009e208: 3040         	adds	r0, #0x40
7009e20a: 2140         	movs	r1, #0x40
7009e20c: 2206         	movs	r2, #0x6
7009e20e: 2300         	movs	r3, #0x0
7009e210: 9302         	str	r3, [sp, #0x8]
7009e212: f010 f9f5    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x103ea
7009e216: 9b02         	ldr	r3, [sp, #0x8]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009e218: 9811         	ldr	r0, [sp, #0x44]
7009e21a: 301c         	adds	r0, #0x1c
7009e21c: 210f         	movs	r1, #0xf
7009e21e: 461a         	mov	r2, r3
7009e220: f010 f9ee    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x103dc
;         fcrValue &= ~((uint32_t) UART_FCR_TX_FIFO_TRIG_MASK);
7009e224: 980c         	ldr	r0, [sp, #0x30]
7009e226: f020 0030    	bic	r0, r0, #0x30
7009e22a: 900c         	str	r0, [sp, #0x30]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009e22c: 9809         	ldr	r0, [sp, #0x24]
7009e22e: 2808         	cmp	r0, #0x8
7009e230: d00c         	beq	0x7009e24c <UART_fifoConfig+0x15c> @ imm = #0x18
7009e232: e7ff         	b	0x7009e234 <UART_fifoConfig+0x144> @ imm = #-0x2
;            (UART_TXTRIGLVL_16 == (txTrig)) ||
7009e234: 9809         	ldr	r0, [sp, #0x24]
7009e236: 2810         	cmp	r0, #0x10
7009e238: d008         	beq	0x7009e24c <UART_fifoConfig+0x15c> @ imm = #0x10
7009e23a: e7ff         	b	0x7009e23c <UART_fifoConfig+0x14c> @ imm = #-0x2
;            (UART_TXTRIGLVL_32 == (txTrig)) ||
7009e23c: 9809         	ldr	r0, [sp, #0x24]
7009e23e: 2820         	cmp	r0, #0x20
7009e240: d004         	beq	0x7009e24c <UART_fifoConfig+0x15c> @ imm = #0x8
7009e242: e7ff         	b	0x7009e244 <UART_fifoConfig+0x154> @ imm = #-0x2
;            (UART_TXTRIGLVL_56 == (txTrig)))
7009e244: 9809         	ldr	r0, [sp, #0x24]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009e246: 2838         	cmp	r0, #0x38
7009e248: d107         	bne	0x7009e25a <UART_fifoConfig+0x16a> @ imm = #0xe
7009e24a: e7ff         	b	0x7009e24c <UART_fifoConfig+0x15c> @ imm = #-0x2
;             fcrValue |= txTrig & UART_FCR_TX_FIFO_TRIG_MASK;
7009e24c: 9809         	ldr	r0, [sp, #0x24]
7009e24e: f000 0130    	and	r1, r0, #0x30
7009e252: 980c         	ldr	r0, [sp, #0x30]
7009e254: 4308         	orrs	r0, r1
7009e256: 900c         	str	r0, [sp, #0x30]
;         }
7009e258: e007         	b	0x7009e26a <UART_fifoConfig+0x17a> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009e25a: 9811         	ldr	r0, [sp, #0x44]
7009e25c: 301c         	adds	r0, #0x1c
7009e25e: 9b09         	ldr	r3, [sp, #0x24]
7009e260: 210f         	movs	r1, #0xf
7009e262: 2200         	movs	r2, #0x0
7009e264: f010 f9cc    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x10398
7009e268: e7ff         	b	0x7009e26a <UART_fifoConfig+0x17a> @ imm = #-0x2
;     }
7009e26a: e01d         	b	0x7009e2a8 <UART_fifoConfig+0x1b8> @ imm = #0x3a
;         txTrig &= 0x003FU;
7009e26c: 9809         	ldr	r0, [sp, #0x24]
7009e26e: f000 003f    	and	r0, r0, #0x3f
7009e272: 9009         	str	r0, [sp, #0x24]
;         tlrValue = (txTrig & 0x003CU) >> 2;
7009e274: 9809         	ldr	r0, [sp, #0x24]
7009e276: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009e27a: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (txTrig & 0x0003U) << UART_FCR_TX_FIFO_TRIG_SHIFT;
7009e27c: 9809         	ldr	r0, [sp, #0x24]
7009e27e: f000 0103    	and	r1, r0, #0x3
7009e282: 980c         	ldr	r0, [sp, #0x30]
7009e284: ea40 1001    	orr.w	r0, r0, r1, lsl #4
7009e288: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009e28a: 9811         	ldr	r0, [sp, #0x44]
7009e28c: 3040         	adds	r0, #0x40
7009e28e: 2140         	movs	r1, #0x40
7009e290: 2206         	movs	r2, #0x6
7009e292: 2301         	movs	r3, #0x1
7009e294: f010 f9b4    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x10368
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA, tlrValue);
7009e298: 9811         	ldr	r0, [sp, #0x44]
7009e29a: 301c         	adds	r0, #0x1c
7009e29c: 9b0d         	ldr	r3, [sp, #0x34]
7009e29e: 210f         	movs	r1, #0xf
7009e2a0: 2200         	movs	r2, #0x0
7009e2a2: f010 f9ad    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x1035a
7009e2a6: e7ff         	b	0x7009e2a8 <UART_fifoConfig+0x1b8> @ imm = #-0x2
;     if(UART_DMA_EN_PATH_FCR == dmaEnPath)
7009e2a8: 9805         	ldr	r0, [sp, #0x14]
7009e2aa: b9a8         	cbnz	r0, 0x7009e2d8 <UART_fifoConfig+0x1e8> @ imm = #0x2a
7009e2ac: e7ff         	b	0x7009e2ae <UART_fifoConfig+0x1be> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009e2ae: 9811         	ldr	r0, [sp, #0x44]
7009e2b0: 3040         	adds	r0, #0x40
7009e2b2: 2101         	movs	r1, #0x1
7009e2b4: 2300         	movs	r3, #0x0
7009e2b6: 461a         	mov	r2, r3
7009e2b8: f010 f9a2    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x10344
;         dmaMode &= 0x1U;
7009e2bc: 9804         	ldr	r0, [sp, #0x10]
7009e2be: f000 0001    	and	r0, r0, #0x1
7009e2c2: 9004         	str	r0, [sp, #0x10]
;         fcrValue &= ~((uint32_t) UART_FCR_DMA_MODE_MASK);
7009e2c4: 980c         	ldr	r0, [sp, #0x30]
7009e2c6: f020 0008    	bic	r0, r0, #0x8
7009e2ca: 900c         	str	r0, [sp, #0x30]
;         fcrValue |= dmaMode << UART_FCR_DMA_MODE_SHIFT;
7009e2cc: 9904         	ldr	r1, [sp, #0x10]
7009e2ce: 980c         	ldr	r0, [sp, #0x30]
7009e2d0: ea40 00c1    	orr.w	r0, r0, r1, lsl #3
7009e2d4: 900c         	str	r0, [sp, #0x30]
;     }
7009e2d6: e013         	b	0x7009e300 <UART_fifoConfig+0x210> @ imm = #0x26
;         dmaMode &= 0x3U;
7009e2d8: 9804         	ldr	r0, [sp, #0x10]
7009e2da: f000 0003    	and	r0, r0, #0x3
7009e2de: 9004         	str	r0, [sp, #0x10]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009e2e0: 9811         	ldr	r0, [sp, #0x44]
7009e2e2: 3040         	adds	r0, #0x40
7009e2e4: 2200         	movs	r2, #0x0
7009e2e6: 2301         	movs	r3, #0x1
7009e2e8: 9301         	str	r3, [sp, #0x4]
7009e2ea: 4619         	mov	r1, r3
7009e2ec: f010 f988    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x10310
7009e2f0: 9a01         	ldr	r2, [sp, #0x4]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_2, dmaMode);
7009e2f2: 9811         	ldr	r0, [sp, #0x44]
7009e2f4: 3040         	adds	r0, #0x40
7009e2f6: 9b04         	ldr	r3, [sp, #0x10]
7009e2f8: 2106         	movs	r1, #0x6
7009e2fa: f010 f981    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x10302
7009e2fe: e7ff         	b	0x7009e300 <UART_fifoConfig+0x210> @ imm = #-0x2
;     fcrValue |= rxClr << UART_FCR_RX_FIFO_CLEAR_SHIFT;
7009e300: 9906         	ldr	r1, [sp, #0x18]
7009e302: 980c         	ldr	r0, [sp, #0x30]
7009e304: ea40 0041    	orr.w	r0, r0, r1, lsl #1
7009e308: 900c         	str	r0, [sp, #0x30]
;     fcrValue |= txClr << UART_FCR_TX_FIFO_CLEAR_SHIFT;
7009e30a: 9907         	ldr	r1, [sp, #0x1c]
7009e30c: 980c         	ldr	r0, [sp, #0x30]
7009e30e: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009e312: 900c         	str	r0, [sp, #0x30]
;     UART_fifoRegisterWrite(baseAddr, fcrValue);
7009e314: 9811         	ldr	r0, [sp, #0x44]
7009e316: 990c         	ldr	r1, [sp, #0x30]
7009e318: f00d fbc2    	bl	0x700abaa0 <UART_fifoRegisterWrite> @ imm = #0xd784
;     UART_tcrTlrBitValRestore(baseAddr, tcrTlrBitVal);
7009e31c: 9811         	ldr	r0, [sp, #0x44]
7009e31e: 990e         	ldr	r1, [sp, #0x38]
7009e320: f00c f816    	bl	0x700aa350 <UART_tcrTlrBitValRestore> @ imm = #0xc02c
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
7009e324: 9811         	ldr	r0, [sp, #0x44]
7009e326: 990f         	ldr	r1, [sp, #0x3c]
7009e328: f010 f98a    	bl	0x700ae640 <UART_enhanFuncBitValRestore> @ imm = #0x10314
;     return fcrValue;
7009e32c: 980c         	ldr	r0, [sp, #0x30]
7009e32e: b012         	add	sp, #0x48
7009e330: bd80         	pop	{r7, pc}
		...
7009e33e: 0000         	movs	r0, r0

7009e340 <_ntoa_format>:
; {
7009e340: b570         	push	{r4, r5, r6, lr}
7009e342: b08c         	sub	sp, #0x30
7009e344: 4684         	mov	r12, r0
7009e346: 9816         	ldr	r0, [sp, #0x58]
7009e348: 9815         	ldr	r0, [sp, #0x54]
7009e34a: 9814         	ldr	r0, [sp, #0x50]
7009e34c: 9813         	ldr	r0, [sp, #0x4c]
7009e34e: 9812         	ldr	r0, [sp, #0x48]
7009e350: f8dd e044    	ldr.w	lr, [sp, #0x44]
7009e354: f8dd e040    	ldr.w	lr, [sp, #0x40]
7009e358: f8cd c02c    	str.w	r12, [sp, #0x2c]
7009e35c: 910a         	str	r1, [sp, #0x28]
7009e35e: 9209         	str	r2, [sp, #0x24]
7009e360: 9308         	str	r3, [sp, #0x20]
7009e362: f88d 001f    	strb.w	r0, [sp, #0x1f]
;   if (!(flags & FLAGS_LEFT)) {
7009e366: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e36a: 0780         	lsls	r0, r0, #0x1e
7009e36c: 2800         	cmp	r0, #0x0
7009e36e: d454         	bmi	0x7009e41a <_ntoa_format+0xda> @ imm = #0xa8
7009e370: e7ff         	b	0x7009e372 <_ntoa_format+0x32> @ imm = #-0x2
;     if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009e372: 9815         	ldr	r0, [sp, #0x54]
7009e374: b1a0         	cbz	r0, 0x7009e3a0 <_ntoa_format+0x60> @ imm = #0x28
7009e376: e7ff         	b	0x7009e378 <_ntoa_format+0x38> @ imm = #-0x2
7009e378: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e37c: 07c0         	lsls	r0, r0, #0x1f
7009e37e: b178         	cbz	r0, 0x7009e3a0 <_ntoa_format+0x60> @ imm = #0x1e
7009e380: e7ff         	b	0x7009e382 <_ntoa_format+0x42> @ imm = #-0x2
7009e382: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009e386: 07c0         	lsls	r0, r0, #0x1f
7009e388: b930         	cbnz	r0, 0x7009e398 <_ntoa_format+0x58> @ imm = #0xc
7009e38a: e7ff         	b	0x7009e38c <_ntoa_format+0x4c> @ imm = #-0x2
7009e38c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e390: f010 0f0c    	tst.w	r0, #0xc
7009e394: d004         	beq	0x7009e3a0 <_ntoa_format+0x60> @ imm = #0x8
7009e396: e7ff         	b	0x7009e398 <_ntoa_format+0x58> @ imm = #-0x2
;       width--;
7009e398: 9815         	ldr	r0, [sp, #0x54]
7009e39a: 3801         	subs	r0, #0x1
7009e39c: 9015         	str	r0, [sp, #0x54]
;     }
7009e39e: e7ff         	b	0x7009e3a0 <_ntoa_format+0x60> @ imm = #-0x2
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e3a0: e7ff         	b	0x7009e3a2 <_ntoa_format+0x62> @ imm = #-0x2
7009e3a2: 9911         	ldr	r1, [sp, #0x44]
7009e3a4: 9a14         	ldr	r2, [sp, #0x50]
7009e3a6: 2000         	movs	r0, #0x0
7009e3a8: 4291         	cmp	r1, r2
7009e3aa: 9006         	str	r0, [sp, #0x18]
7009e3ac: d207         	bhs	0x7009e3be <_ntoa_format+0x7e> @ imm = #0xe
7009e3ae: e7ff         	b	0x7009e3b0 <_ntoa_format+0x70> @ imm = #-0x2
7009e3b0: 9911         	ldr	r1, [sp, #0x44]
7009e3b2: 2000         	movs	r0, #0x0
7009e3b4: 2920         	cmp	r1, #0x20
7009e3b6: bf38         	it	lo
7009e3b8: 2001         	movlo	r0, #0x1
7009e3ba: 9006         	str	r0, [sp, #0x18]
7009e3bc: e7ff         	b	0x7009e3be <_ntoa_format+0x7e> @ imm = #-0x2
7009e3be: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e3c0: 07c0         	lsls	r0, r0, #0x1f
7009e3c2: b138         	cbz	r0, 0x7009e3d4 <_ntoa_format+0x94> @ imm = #0xe
7009e3c4: e7ff         	b	0x7009e3c6 <_ntoa_format+0x86> @ imm = #-0x2
;       buf[len++] = '0';
7009e3c6: 9910         	ldr	r1, [sp, #0x40]
7009e3c8: 9a11         	ldr	r2, [sp, #0x44]
7009e3ca: 1c50         	adds	r0, r2, #0x1
7009e3cc: 9011         	str	r0, [sp, #0x44]
7009e3ce: 2030         	movs	r0, #0x30
7009e3d0: 5488         	strb	r0, [r1, r2]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e3d2: e7e6         	b	0x7009e3a2 <_ntoa_format+0x62> @ imm = #-0x34
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e3d4: e7ff         	b	0x7009e3d6 <_ntoa_format+0x96> @ imm = #-0x2
7009e3d6: 2000         	movs	r0, #0x0
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e3d8: f89d 1058    	ldrb.w	r1, [sp, #0x58]
7009e3dc: ea4f 71c1    	lsl.w	r1, r1, #0x1f
7009e3e0: 9005         	str	r0, [sp, #0x14]
7009e3e2: b171         	cbz	r1, 0x7009e402 <_ntoa_format+0xc2> @ imm = #0x1c
7009e3e4: e7ff         	b	0x7009e3e6 <_ntoa_format+0xa6> @ imm = #-0x2
7009e3e6: 9911         	ldr	r1, [sp, #0x44]
7009e3e8: 9a15         	ldr	r2, [sp, #0x54]
7009e3ea: 2000         	movs	r0, #0x0
7009e3ec: 4291         	cmp	r1, r2
7009e3ee: 9005         	str	r0, [sp, #0x14]
7009e3f0: d207         	bhs	0x7009e402 <_ntoa_format+0xc2> @ imm = #0xe
7009e3f2: e7ff         	b	0x7009e3f4 <_ntoa_format+0xb4> @ imm = #-0x2
7009e3f4: 9911         	ldr	r1, [sp, #0x44]
7009e3f6: 2000         	movs	r0, #0x0
7009e3f8: 2920         	cmp	r1, #0x20
7009e3fa: bf38         	it	lo
7009e3fc: 2001         	movlo	r0, #0x1
7009e3fe: 9005         	str	r0, [sp, #0x14]
7009e400: e7ff         	b	0x7009e402 <_ntoa_format+0xc2> @ imm = #-0x2
7009e402: 9805         	ldr	r0, [sp, #0x14]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e404: 07c0         	lsls	r0, r0, #0x1f
7009e406: b138         	cbz	r0, 0x7009e418 <_ntoa_format+0xd8> @ imm = #0xe
7009e408: e7ff         	b	0x7009e40a <_ntoa_format+0xca> @ imm = #-0x2
;       buf[len++] = '0';
7009e40a: 9910         	ldr	r1, [sp, #0x40]
7009e40c: 9a11         	ldr	r2, [sp, #0x44]
7009e40e: 1c50         	adds	r0, r2, #0x1
7009e410: 9011         	str	r0, [sp, #0x44]
7009e412: 2030         	movs	r0, #0x30
7009e414: 5488         	strb	r0, [r1, r2]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e416: e7de         	b	0x7009e3d6 <_ntoa_format+0x96> @ imm = #-0x44
;   }
7009e418: e7ff         	b	0x7009e41a <_ntoa_format+0xda> @ imm = #-0x2
;   if (flags & FLAGS_HASH) {
7009e41a: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e41e: 06c0         	lsls	r0, r0, #0x1b
7009e420: 2800         	cmp	r0, #0x0
7009e422: d569         	bpl	0x7009e4f8 <_ntoa_format+0x1b8> @ imm = #0xd2
7009e424: e7ff         	b	0x7009e426 <_ntoa_format+0xe6> @ imm = #-0x2
;     if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
7009e426: f89d 0059    	ldrb.w	r0, [sp, #0x59]
7009e42a: 0740         	lsls	r0, r0, #0x1d
7009e42c: 2800         	cmp	r0, #0x0
7009e42e: d41c         	bmi	0x7009e46a <_ntoa_format+0x12a> @ imm = #0x38
7009e430: e7ff         	b	0x7009e432 <_ntoa_format+0xf2> @ imm = #-0x2
7009e432: 9811         	ldr	r0, [sp, #0x44]
7009e434: b1c8         	cbz	r0, 0x7009e46a <_ntoa_format+0x12a> @ imm = #0x32
7009e436: e7ff         	b	0x7009e438 <_ntoa_format+0xf8> @ imm = #-0x2
7009e438: 9811         	ldr	r0, [sp, #0x44]
7009e43a: 9914         	ldr	r1, [sp, #0x50]
7009e43c: 4288         	cmp	r0, r1
7009e43e: d005         	beq	0x7009e44c <_ntoa_format+0x10c> @ imm = #0xa
7009e440: e7ff         	b	0x7009e442 <_ntoa_format+0x102> @ imm = #-0x2
7009e442: 9811         	ldr	r0, [sp, #0x44]
7009e444: 9915         	ldr	r1, [sp, #0x54]
7009e446: 4288         	cmp	r0, r1
7009e448: d10f         	bne	0x7009e46a <_ntoa_format+0x12a> @ imm = #0x1e
7009e44a: e7ff         	b	0x7009e44c <_ntoa_format+0x10c> @ imm = #-0x2
;       len--;
7009e44c: 9811         	ldr	r0, [sp, #0x44]
7009e44e: 3801         	subs	r0, #0x1
7009e450: 9011         	str	r0, [sp, #0x44]
;       if (len && (base == 16U)) {
7009e452: 9811         	ldr	r0, [sp, #0x44]
7009e454: b140         	cbz	r0, 0x7009e468 <_ntoa_format+0x128> @ imm = #0x10
7009e456: e7ff         	b	0x7009e458 <_ntoa_format+0x118> @ imm = #-0x2
7009e458: 9813         	ldr	r0, [sp, #0x4c]
7009e45a: 2810         	cmp	r0, #0x10
7009e45c: d104         	bne	0x7009e468 <_ntoa_format+0x128> @ imm = #0x8
7009e45e: e7ff         	b	0x7009e460 <_ntoa_format+0x120> @ imm = #-0x2
;         len--;
7009e460: 9811         	ldr	r0, [sp, #0x44]
7009e462: 3801         	subs	r0, #0x1
7009e464: 9011         	str	r0, [sp, #0x44]
;       }
7009e466: e7ff         	b	0x7009e468 <_ntoa_format+0x128> @ imm = #-0x2
;     }
7009e468: e7ff         	b	0x7009e46a <_ntoa_format+0x12a> @ imm = #-0x2
;     if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e46a: 9813         	ldr	r0, [sp, #0x4c]
7009e46c: 2810         	cmp	r0, #0x10
7009e46e: d111         	bne	0x7009e494 <_ntoa_format+0x154> @ imm = #0x22
7009e470: e7ff         	b	0x7009e472 <_ntoa_format+0x132> @ imm = #-0x2
7009e472: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e476: 0680         	lsls	r0, r0, #0x1a
7009e478: 2800         	cmp	r0, #0x0
7009e47a: d40b         	bmi	0x7009e494 <_ntoa_format+0x154> @ imm = #0x16
7009e47c: e7ff         	b	0x7009e47e <_ntoa_format+0x13e> @ imm = #-0x2
7009e47e: 9811         	ldr	r0, [sp, #0x44]
7009e480: 281f         	cmp	r0, #0x1f
7009e482: d807         	bhi	0x7009e494 <_ntoa_format+0x154> @ imm = #0xe
7009e484: e7ff         	b	0x7009e486 <_ntoa_format+0x146> @ imm = #-0x2
;       buf[len++] = 'x';
7009e486: 9910         	ldr	r1, [sp, #0x40]
7009e488: 9a11         	ldr	r2, [sp, #0x44]
7009e48a: 1c50         	adds	r0, r2, #0x1
7009e48c: 9011         	str	r0, [sp, #0x44]
7009e48e: 2078         	movs	r0, #0x78
7009e490: 5488         	strb	r0, [r1, r2]
;     }
7009e492: e025         	b	0x7009e4e0 <_ntoa_format+0x1a0> @ imm = #0x4a
;     else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e494: 9813         	ldr	r0, [sp, #0x4c]
7009e496: 2810         	cmp	r0, #0x10
7009e498: d111         	bne	0x7009e4be <_ntoa_format+0x17e> @ imm = #0x22
7009e49a: e7ff         	b	0x7009e49c <_ntoa_format+0x15c> @ imm = #-0x2
7009e49c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e4a0: 0680         	lsls	r0, r0, #0x1a
7009e4a2: 2800         	cmp	r0, #0x0
7009e4a4: d50b         	bpl	0x7009e4be <_ntoa_format+0x17e> @ imm = #0x16
7009e4a6: e7ff         	b	0x7009e4a8 <_ntoa_format+0x168> @ imm = #-0x2
7009e4a8: 9811         	ldr	r0, [sp, #0x44]
7009e4aa: 281f         	cmp	r0, #0x1f
7009e4ac: d807         	bhi	0x7009e4be <_ntoa_format+0x17e> @ imm = #0xe
7009e4ae: e7ff         	b	0x7009e4b0 <_ntoa_format+0x170> @ imm = #-0x2
;       buf[len++] = 'X';
7009e4b0: 9910         	ldr	r1, [sp, #0x40]
7009e4b2: 9a11         	ldr	r2, [sp, #0x44]
7009e4b4: 1c50         	adds	r0, r2, #0x1
7009e4b6: 9011         	str	r0, [sp, #0x44]
7009e4b8: 2058         	movs	r0, #0x58
7009e4ba: 5488         	strb	r0, [r1, r2]
;     }
7009e4bc: e00f         	b	0x7009e4de <_ntoa_format+0x19e> @ imm = #0x1e
;     else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009e4be: 9813         	ldr	r0, [sp, #0x4c]
7009e4c0: 2802         	cmp	r0, #0x2
7009e4c2: d10b         	bne	0x7009e4dc <_ntoa_format+0x19c> @ imm = #0x16
7009e4c4: e7ff         	b	0x7009e4c6 <_ntoa_format+0x186> @ imm = #-0x2
7009e4c6: 9811         	ldr	r0, [sp, #0x44]
7009e4c8: 281f         	cmp	r0, #0x1f
7009e4ca: d807         	bhi	0x7009e4dc <_ntoa_format+0x19c> @ imm = #0xe
7009e4cc: e7ff         	b	0x7009e4ce <_ntoa_format+0x18e> @ imm = #-0x2
;       buf[len++] = 'b';
7009e4ce: 9910         	ldr	r1, [sp, #0x40]
7009e4d0: 9a11         	ldr	r2, [sp, #0x44]
7009e4d2: 1c50         	adds	r0, r2, #0x1
7009e4d4: 9011         	str	r0, [sp, #0x44]
7009e4d6: 2062         	movs	r0, #0x62
7009e4d8: 5488         	strb	r0, [r1, r2]
;     }
7009e4da: e7ff         	b	0x7009e4dc <_ntoa_format+0x19c> @ imm = #-0x2
7009e4dc: e7ff         	b	0x7009e4de <_ntoa_format+0x19e> @ imm = #-0x2
7009e4de: e7ff         	b	0x7009e4e0 <_ntoa_format+0x1a0> @ imm = #-0x2
;     if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009e4e0: 9811         	ldr	r0, [sp, #0x44]
7009e4e2: 281f         	cmp	r0, #0x1f
7009e4e4: d807         	bhi	0x7009e4f6 <_ntoa_format+0x1b6> @ imm = #0xe
7009e4e6: e7ff         	b	0x7009e4e8 <_ntoa_format+0x1a8> @ imm = #-0x2
;       buf[len++] = '0';
7009e4e8: 9910         	ldr	r1, [sp, #0x40]
7009e4ea: 9a11         	ldr	r2, [sp, #0x44]
7009e4ec: 1c50         	adds	r0, r2, #0x1
7009e4ee: 9011         	str	r0, [sp, #0x44]
7009e4f0: 2030         	movs	r0, #0x30
7009e4f2: 5488         	strb	r0, [r1, r2]
;     }
7009e4f4: e7ff         	b	0x7009e4f6 <_ntoa_format+0x1b6> @ imm = #-0x2
;   }
7009e4f6: e7ff         	b	0x7009e4f8 <_ntoa_format+0x1b8> @ imm = #-0x2
;   if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009e4f8: 9811         	ldr	r0, [sp, #0x44]
7009e4fa: 281f         	cmp	r0, #0x1f
7009e4fc: d829         	bhi	0x7009e552 <_ntoa_format+0x212> @ imm = #0x52
7009e4fe: e7ff         	b	0x7009e500 <_ntoa_format+0x1c0> @ imm = #-0x2
;     if (negative) {
7009e500: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009e504: 07c0         	lsls	r0, r0, #0x1f
7009e506: b138         	cbz	r0, 0x7009e518 <_ntoa_format+0x1d8> @ imm = #0xe
7009e508: e7ff         	b	0x7009e50a <_ntoa_format+0x1ca> @ imm = #-0x2
;       buf[len++] = '-';
7009e50a: 9910         	ldr	r1, [sp, #0x40]
7009e50c: 9a11         	ldr	r2, [sp, #0x44]
7009e50e: 1c50         	adds	r0, r2, #0x1
7009e510: 9011         	str	r0, [sp, #0x44]
7009e512: 202d         	movs	r0, #0x2d
7009e514: 5488         	strb	r0, [r1, r2]
;     }
7009e516: e01b         	b	0x7009e550 <_ntoa_format+0x210> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009e518: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e51c: 0740         	lsls	r0, r0, #0x1d
7009e51e: 2800         	cmp	r0, #0x0
7009e520: d507         	bpl	0x7009e532 <_ntoa_format+0x1f2> @ imm = #0xe
7009e522: e7ff         	b	0x7009e524 <_ntoa_format+0x1e4> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009e524: 9910         	ldr	r1, [sp, #0x40]
7009e526: 9a11         	ldr	r2, [sp, #0x44]
7009e528: 1c50         	adds	r0, r2, #0x1
7009e52a: 9011         	str	r0, [sp, #0x44]
7009e52c: 202b         	movs	r0, #0x2b
7009e52e: 5488         	strb	r0, [r1, r2]
;     }
7009e530: e00d         	b	0x7009e54e <_ntoa_format+0x20e> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009e532: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009e536: 0700         	lsls	r0, r0, #0x1c
7009e538: 2800         	cmp	r0, #0x0
7009e53a: d507         	bpl	0x7009e54c <_ntoa_format+0x20c> @ imm = #0xe
7009e53c: e7ff         	b	0x7009e53e <_ntoa_format+0x1fe> @ imm = #-0x2
;       buf[len++] = ' ';
7009e53e: 9910         	ldr	r1, [sp, #0x40]
7009e540: 9a11         	ldr	r2, [sp, #0x44]
7009e542: 1c50         	adds	r0, r2, #0x1
7009e544: 9011         	str	r0, [sp, #0x44]
7009e546: 2020         	movs	r0, #0x20
7009e548: 5488         	strb	r0, [r1, r2]
;     }
7009e54a: e7ff         	b	0x7009e54c <_ntoa_format+0x20c> @ imm = #-0x2
7009e54c: e7ff         	b	0x7009e54e <_ntoa_format+0x20e> @ imm = #-0x2
7009e54e: e7ff         	b	0x7009e550 <_ntoa_format+0x210> @ imm = #-0x2
;   }
7009e550: e7ff         	b	0x7009e552 <_ntoa_format+0x212> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009e552: 980b         	ldr	r0, [sp, #0x2c]
7009e554: 990a         	ldr	r1, [sp, #0x28]
7009e556: 9a09         	ldr	r2, [sp, #0x24]
7009e558: 9b08         	ldr	r3, [sp, #0x20]
7009e55a: f8dd c040    	ldr.w	r12, [sp, #0x40]
7009e55e: 9c11         	ldr	r4, [sp, #0x44]
7009e560: 9d15         	ldr	r5, [sp, #0x54]
7009e562: 9e16         	ldr	r6, [sp, #0x58]
7009e564: 46ee         	mov	lr, sp
7009e566: f8ce 600c    	str.w	r6, [lr, #0xc]
7009e56a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009e56e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009e572: f8ce c000    	str.w	r12, [lr]
7009e576: f008 ffab    	bl	0x700a74d0 <_out_rev>   @ imm = #0x8f56
7009e57a: b00c         	add	sp, #0x30
7009e57c: bd70         	pop	{r4, r5, r6, pc}
7009e57e: 0000         	movs	r0, r0

7009e580 <tm_priority_inheritance_initialize>:
; {
7009e580: b5b0         	push	{r4, r5, r7, lr}
;    tm_setup_pmu();
7009e582: f011 fa65    	bl	0x700afa50 <tm_setup_pmu> @ imm = #0x114ca
;    tm_mutex_create(SHARED_MUTEX_ID);
7009e586: 2001         	movs	r0, #0x1
7009e588: f00e fe22    	bl	0x700ad1d0 <tm_mutex_create> @ imm = #0xec44
;       snprintf(pmu_names[i], PMU_KEY_LEN, "INV%02d", i);
7009e58c: f644 2578    	movw	r5, #0x4a78
7009e590: f242 5402    	movw	r4, #0x2502
7009e594: f2c7 0508    	movt	r5, #0x7008
7009e598: f2c7 040b    	movt	r4, #0x700b
7009e59c: 2108         	movs	r1, #0x8
7009e59e: 2300         	movs	r3, #0x0
7009e5a0: 4628         	mov	r0, r5
7009e5a2: 4622         	mov	r2, r4
7009e5a4: f00c eb52    	blx	0x700aac4c <snprintf>   @ imm = #0xc6a4
7009e5a8: f105 0008    	add.w	r0, r5, #0x8
7009e5ac: 4622         	mov	r2, r4
7009e5ae: 2108         	movs	r1, #0x8
7009e5b0: 2301         	movs	r3, #0x1
7009e5b2: f00c eb4c    	blx	0x700aac4c <snprintf>   @ imm = #0xc698
7009e5b6: f105 0010    	add.w	r0, r5, #0x10
7009e5ba: 4622         	mov	r2, r4
7009e5bc: 2108         	movs	r1, #0x8
7009e5be: 2302         	movs	r3, #0x2
7009e5c0: f00c eb44    	blx	0x700aac4c <snprintf>   @ imm = #0xc688
7009e5c4: f105 0018    	add.w	r0, r5, #0x18
7009e5c8: 4622         	mov	r2, r4
7009e5ca: 2108         	movs	r1, #0x8
7009e5cc: 2303         	movs	r3, #0x3
7009e5ce: f00c eb3e    	blx	0x700aac4c <snprintf>   @ imm = #0xc67c
7009e5d2: f105 0020    	add.w	r0, r5, #0x20
7009e5d6: 4622         	mov	r2, r4
7009e5d8: 2108         	movs	r1, #0x8
7009e5da: 2304         	movs	r3, #0x4
7009e5dc: f00c eb36    	blx	0x700aac4c <snprintf>   @ imm = #0xc66c
7009e5e0: f105 0028    	add.w	r0, r5, #0x28
7009e5e4: 4622         	mov	r2, r4
7009e5e6: 2108         	movs	r1, #0x8
7009e5e8: 2305         	movs	r3, #0x5
7009e5ea: f00c eb30    	blx	0x700aac4c <snprintf>   @ imm = #0xc660
7009e5ee: f105 0030    	add.w	r0, r5, #0x30
7009e5f2: 4622         	mov	r2, r4
7009e5f4: 2108         	movs	r1, #0x8
7009e5f6: 2306         	movs	r3, #0x6
7009e5f8: f00c eb28    	blx	0x700aac4c <snprintf>   @ imm = #0xc650
7009e5fc: f105 0038    	add.w	r0, r5, #0x38
7009e600: 4622         	mov	r2, r4
7009e602: 2108         	movs	r1, #0x8
7009e604: 2307         	movs	r3, #0x7
7009e606: f00c eb22    	blx	0x700aac4c <snprintf>   @ imm = #0xc644
7009e60a: f105 0040    	add.w	r0, r5, #0x40
7009e60e: 4622         	mov	r2, r4
7009e610: 2108         	movs	r1, #0x8
7009e612: 2308         	movs	r3, #0x8
7009e614: f00c eb1a    	blx	0x700aac4c <snprintf>   @ imm = #0xc634
7009e618: f105 0048    	add.w	r0, r5, #0x48
7009e61c: 4622         	mov	r2, r4
7009e61e: 2108         	movs	r1, #0x8
7009e620: 2309         	movs	r3, #0x9
7009e622: f00c eb14    	blx	0x700aac4c <snprintf>   @ imm = #0xc628
7009e626: f105 0050    	add.w	r0, r5, #0x50
7009e62a: 4622         	mov	r2, r4
7009e62c: 2108         	movs	r1, #0x8
7009e62e: 230a         	movs	r3, #0xa
7009e630: f00c eb0c    	blx	0x700aac4c <snprintf>   @ imm = #0xc618
7009e634: f105 0058    	add.w	r0, r5, #0x58
7009e638: 4622         	mov	r2, r4
7009e63a: 2108         	movs	r1, #0x8
7009e63c: 230b         	movs	r3, #0xb
7009e63e: f00c eb06    	blx	0x700aac4c <snprintf>   @ imm = #0xc60c
7009e642: f105 0060    	add.w	r0, r5, #0x60
7009e646: 4622         	mov	r2, r4
7009e648: 2108         	movs	r1, #0x8
7009e64a: 230c         	movs	r3, #0xc
7009e64c: f00c eafe    	blx	0x700aac4c <snprintf>   @ imm = #0xc5fc
7009e650: f105 0068    	add.w	r0, r5, #0x68
7009e654: 4622         	mov	r2, r4
7009e656: 2108         	movs	r1, #0x8
7009e658: 230d         	movs	r3, #0xd
7009e65a: f00c eaf8    	blx	0x700aac4c <snprintf>   @ imm = #0xc5f0
7009e65e: f105 0070    	add.w	r0, r5, #0x70
7009e662: 4622         	mov	r2, r4
7009e664: 2108         	movs	r1, #0x8
7009e666: 230e         	movs	r3, #0xe
7009e668: f00c eaf0    	blx	0x700aac4c <snprintf>   @ imm = #0xc5e0
7009e66c: f105 0078    	add.w	r0, r5, #0x78
7009e670: 4622         	mov	r2, r4
7009e672: 2108         	movs	r1, #0x8
7009e674: 230f         	movs	r3, #0xf
7009e676: f00c eaea    	blx	0x700aac4c <snprintf>   @ imm = #0xc5d4
7009e67a: f105 0080    	add.w	r0, r5, #0x80
7009e67e: 4622         	mov	r2, r4
7009e680: 2108         	movs	r1, #0x8
7009e682: 2310         	movs	r3, #0x10
7009e684: f00c eae2    	blx	0x700aac4c <snprintf>   @ imm = #0xc5c4
7009e688: f105 0088    	add.w	r0, r5, #0x88
7009e68c: 4622         	mov	r2, r4
7009e68e: 2108         	movs	r1, #0x8
7009e690: 2311         	movs	r3, #0x11
7009e692: f00c eadc    	blx	0x700aac4c <snprintf>   @ imm = #0xc5b8
7009e696: f105 0090    	add.w	r0, r5, #0x90
7009e69a: 4622         	mov	r2, r4
7009e69c: 2108         	movs	r1, #0x8
7009e69e: 2312         	movs	r3, #0x12
7009e6a0: f00c ead4    	blx	0x700aac4c <snprintf>   @ imm = #0xc5a8
7009e6a4: f105 0098    	add.w	r0, r5, #0x98
7009e6a8: 4622         	mov	r2, r4
7009e6aa: 2108         	movs	r1, #0x8
7009e6ac: 2313         	movs	r3, #0x13
7009e6ae: f00c eace    	blx	0x700aac4c <snprintf>   @ imm = #0xc59c
7009e6b2: f105 00a0    	add.w	r0, r5, #0xa0
7009e6b6: 4622         	mov	r2, r4
7009e6b8: 2108         	movs	r1, #0x8
7009e6ba: 2314         	movs	r3, #0x14
7009e6bc: f00c eac6    	blx	0x700aac4c <snprintf>   @ imm = #0xc58c
7009e6c0: f105 00a8    	add.w	r0, r5, #0xa8
7009e6c4: 4622         	mov	r2, r4
7009e6c6: 2108         	movs	r1, #0x8
7009e6c8: 2315         	movs	r3, #0x15
7009e6ca: f00c eac0    	blx	0x700aac4c <snprintf>   @ imm = #0xc580
7009e6ce: f105 00b0    	add.w	r0, r5, #0xb0
7009e6d2: 4622         	mov	r2, r4
7009e6d4: 2108         	movs	r1, #0x8
7009e6d6: 2316         	movs	r3, #0x16
7009e6d8: f00c eab8    	blx	0x700aac4c <snprintf>   @ imm = #0xc570
7009e6dc: f105 00b8    	add.w	r0, r5, #0xb8
7009e6e0: 4622         	mov	r2, r4
7009e6e2: 2108         	movs	r1, #0x8
7009e6e4: 2317         	movs	r3, #0x17
7009e6e6: f00c eab2    	blx	0x700aac4c <snprintf>   @ imm = #0xc564
7009e6ea: f105 00c0    	add.w	r0, r5, #0xc0
7009e6ee: 4622         	mov	r2, r4
7009e6f0: 2108         	movs	r1, #0x8
7009e6f2: 2318         	movs	r3, #0x18
7009e6f4: f00c eaaa    	blx	0x700aac4c <snprintf>   @ imm = #0xc554
7009e6f8: f105 00c8    	add.w	r0, r5, #0xc8
7009e6fc: 4622         	mov	r2, r4
7009e6fe: 2108         	movs	r1, #0x8
7009e700: 2319         	movs	r3, #0x19
7009e702: f00c eaa4    	blx	0x700aac4c <snprintf>   @ imm = #0xc548
7009e706: f105 00d0    	add.w	r0, r5, #0xd0
7009e70a: 4622         	mov	r2, r4
7009e70c: 2108         	movs	r1, #0x8
7009e70e: 231a         	movs	r3, #0x1a
7009e710: f00c ea9c    	blx	0x700aac4c <snprintf>   @ imm = #0xc538
7009e714: f105 00d8    	add.w	r0, r5, #0xd8
7009e718: 4622         	mov	r2, r4
7009e71a: 2108         	movs	r1, #0x8
7009e71c: 231b         	movs	r3, #0x1b
7009e71e: f00c ea96    	blx	0x700aac4c <snprintf>   @ imm = #0xc52c
7009e722: f105 00e0    	add.w	r0, r5, #0xe0
7009e726: 4622         	mov	r2, r4
7009e728: 2108         	movs	r1, #0x8
7009e72a: 231c         	movs	r3, #0x1c
7009e72c: f00c ea8e    	blx	0x700aac4c <snprintf>   @ imm = #0xc51c
7009e730: f105 00e8    	add.w	r0, r5, #0xe8
7009e734: 4622         	mov	r2, r4
7009e736: 2108         	movs	r1, #0x8
7009e738: 231d         	movs	r3, #0x1d
7009e73a: f00c ea88    	blx	0x700aac4c <snprintf>   @ imm = #0xc510
7009e73e: f105 00f0    	add.w	r0, r5, #0xf0
7009e742: 4622         	mov	r2, r4
7009e744: 2108         	movs	r1, #0x8
7009e746: 231e         	movs	r3, #0x1e
7009e748: f00c ea80    	blx	0x700aac4c <snprintf>   @ imm = #0xc500
7009e74c: f105 00f8    	add.w	r0, r5, #0xf8
7009e750: 4622         	mov	r2, r4
7009e752: 2108         	movs	r1, #0x8
7009e754: 231f         	movs	r3, #0x1f
7009e756: f00c ea7a    	blx	0x700aac4c <snprintf>   @ imm = #0xc4f4
;    tm_thread_create(LOW_TASK_ID, LOW_TASK_PRIO, LowPrioTask);
7009e75a: f24b 22c1    	movw	r2, #0xb2c1
7009e75e: 2002         	movs	r0, #0x2
7009e760: f2c7 020a    	movt	r2, #0x700a
7009e764: 2114         	movs	r1, #0x14
7009e766: f00f fdf3    	bl	0x700ae350 <tm_thread_create> @ imm = #0xfbe6
;    tm_thread_create(MED_TASK_ID, MED_TASK_PRIO, MedPrioTask);
7009e76a: f641 02b1    	movw	r2, #0x18b1
7009e76e: 2001         	movs	r0, #0x1
7009e770: f2c7 020a    	movt	r2, #0x700a
7009e774: 210a         	movs	r1, #0xa
7009e776: f00f fdeb    	bl	0x700ae350 <tm_thread_create> @ imm = #0xfbd6
;    tm_thread_create(HIGH_TASK_ID, HIGH_TASK_PRIO, HighPrioTask);
7009e77a: f640 72e1    	movw	r2, #0xfe1
7009e77e: 2000         	movs	r0, #0x0
7009e780: f2c7 020a    	movt	r2, #0x700a
7009e784: 2105         	movs	r1, #0x5
7009e786: f00f fde3    	bl	0x700ae350 <tm_thread_create> @ imm = #0xfbc6
;    tm_thread_resume(LOW_TASK_ID);
7009e78a: 2002         	movs	r0, #0x2
7009e78c: f011 f8a0    	bl	0x700af8d0 <tm_thread_resume> @ imm = #0x11140
;    tm_thread_resume(MED_TASK_ID);
7009e790: 2001         	movs	r0, #0x1
7009e792: f011 f89d    	bl	0x700af8d0 <tm_thread_resume> @ imm = #0x1113a
;    tm_thread_resume(HIGH_TASK_ID);
7009e796: 2000         	movs	r0, #0x0
7009e798: f011 f89a    	bl	0x700af8d0 <tm_thread_resume> @ imm = #0x11134
;    printf("[Init] Priority Inheritance detection test started for %d cycles.\r\n", ITERATION_COUNT);
7009e79c: f641 1130    	movw	r1, #0x1930
7009e7a0: 2001         	movs	r0, #0x1
7009e7a2: f2c7 010b    	movt	r1, #0x700b
7009e7a6: 2220         	movs	r2, #0x20
7009e7a8: e8bd 40b0    	pop.w	{r4, r5, r7, lr}
7009e7ac: f00b b9d8    	b.w	0x700a9b60 <_DebugP_logZone> @ imm = #0xb3b0

7009e7b0 <Udma_eventRegister>:
; {
7009e7b0: b5b0         	push	{r4, r5, r7, lr}
7009e7b2: b088         	sub	sp, #0x20
7009e7b4: 9007         	str	r0, [sp, #0x1c]
7009e7b6: 9106         	str	r1, [sp, #0x18]
7009e7b8: 9205         	str	r2, [sp, #0x14]
7009e7ba: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009e7bc: 9004         	str	r0, [sp, #0x10]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009e7be: 9003         	str	r0, [sp, #0xc]
;     if((NULL_PTR == drvHandle) || (NULL_PTR == eventHandle) || (NULL_PTR == eventPrms))
7009e7c0: 9807         	ldr	r0, [sp, #0x1c]
7009e7c2: b130         	cbz	r0, 0x7009e7d2 <Udma_eventRegister+0x22> @ imm = #0xc
7009e7c4: e7ff         	b	0x7009e7c6 <Udma_eventRegister+0x16> @ imm = #-0x2
7009e7c6: 9806         	ldr	r0, [sp, #0x18]
7009e7c8: b118         	cbz	r0, 0x7009e7d2 <Udma_eventRegister+0x22> @ imm = #0x6
7009e7ca: e7ff         	b	0x7009e7cc <Udma_eventRegister+0x1c> @ imm = #-0x2
7009e7cc: 9805         	ldr	r0, [sp, #0x14]
7009e7ce: b920         	cbnz	r0, 0x7009e7da <Udma_eventRegister+0x2a> @ imm = #0x8
7009e7d0: e7ff         	b	0x7009e7d2 <Udma_eventRegister+0x22> @ imm = #-0x2
7009e7d2: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009e7d6: 9004         	str	r0, [sp, #0x10]
;     }
7009e7d8: e7ff         	b	0x7009e7da <Udma_eventRegister+0x2a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e7da: 9804         	ldr	r0, [sp, #0x10]
7009e7dc: b988         	cbnz	r0, 0x7009e802 <Udma_eventRegister+0x52> @ imm = #0x22
7009e7de: e7ff         	b	0x7009e7e0 <Udma_eventRegister+0x30> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009e7e0: 9807         	ldr	r0, [sp, #0x1c]
7009e7e2: 9002         	str	r0, [sp, #0x8]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009e7e4: 9802         	ldr	r0, [sp, #0x8]
7009e7e6: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009e7ea: f64a 31cd    	movw	r1, #0xabcd
7009e7ee: f6ca 31dc    	movt	r1, #0xabdc
7009e7f2: 4288         	cmp	r0, r1
7009e7f4: d004         	beq	0x7009e800 <Udma_eventRegister+0x50> @ imm = #0x8
7009e7f6: e7ff         	b	0x7009e7f8 <Udma_eventRegister+0x48> @ imm = #-0x2
7009e7f8: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009e7fc: 9004         	str	r0, [sp, #0x10]
;         }
7009e7fe: e7ff         	b	0x7009e800 <Udma_eventRegister+0x50> @ imm = #-0x2
;     }
7009e800: e7ff         	b	0x7009e802 <Udma_eventRegister+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e802: 9804         	ldr	r0, [sp, #0x10]
7009e804: b930         	cbnz	r0, 0x7009e814 <Udma_eventRegister+0x64> @ imm = #0xc
7009e806: e7ff         	b	0x7009e808 <Udma_eventRegister+0x58> @ imm = #-0x2
;         retVal = Udma_eventCheckParams(drvHandleInt, eventPrms);
7009e808: 9802         	ldr	r0, [sp, #0x8]
7009e80a: 9905         	ldr	r1, [sp, #0x14]
7009e80c: f006 fd28    	bl	0x700a5260 <Udma_eventCheckParams> @ imm = #0x6a50
7009e810: 9004         	str	r0, [sp, #0x10]
;     }
7009e812: e7ff         	b	0x7009e814 <Udma_eventRegister+0x64> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e814: 9804         	ldr	r0, [sp, #0x10]
7009e816: bbb0         	cbnz	r0, 0x7009e886 <Udma_eventRegister+0xd6> @ imm = #0x6c
7009e818: e7ff         	b	0x7009e81a <Udma_eventRegister+0x6a> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
7009e81a: 9806         	ldr	r0, [sp, #0x18]
7009e81c: 9001         	str	r0, [sp, #0x4]
;             &eventHandleInt->eventPrms, eventPrms, sizeof(eventHandleInt->eventPrms));
7009e81e: 9801         	ldr	r0, [sp, #0x4]
7009e820: 3008         	adds	r0, #0x8
7009e822: 9905         	ldr	r1, [sp, #0x14]
;         (void) memcpy(
7009e824: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009e828: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009e82c: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009e830: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009e834: e891 503c    	ldm.w	r1, {r2, r3, r4, r5, r12, lr}
7009e838: e880 503c    	stm.w	r0, {r2, r3, r4, r5, r12, lr}
;         eventHandleInt->drvHandle       = drvHandleInt;
7009e83c: 9802         	ldr	r0, [sp, #0x8]
7009e83e: 9901         	ldr	r1, [sp, #0x4]
7009e840: 6008         	str	r0, [r1]
;         eventHandleInt->globalEvent     = UDMA_EVENT_INVALID;
7009e842: 9901         	ldr	r1, [sp, #0x4]
7009e844: f64f 70ff    	movw	r0, #0xffff
7009e848: 6488         	str	r0, [r1, #0x48]
;         eventHandleInt->vintrNum        = UDMA_EVENT_INVALID;
7009e84a: 9901         	ldr	r1, [sp, #0x4]
7009e84c: 64c8         	str	r0, [r1, #0x4c]
;         eventHandleInt->vintrBitNum     = UDMA_EVENT_INVALID;
7009e84e: 9901         	ldr	r1, [sp, #0x4]
7009e850: 6508         	str	r0, [r1, #0x50]
;         eventHandleInt->irIntrNum       = UDMA_INTR_INVALID;
7009e852: 9901         	ldr	r1, [sp, #0x4]
7009e854: 2000         	movs	r0, #0x0
7009e856: f6cf 70ff    	movt	r0, #0xffff
7009e85a: 6548         	str	r0, [r1, #0x54]
;         eventHandleInt->coreIntrNum     = UDMA_INTR_INVALID;
7009e85c: 9901         	ldr	r1, [sp, #0x4]
7009e85e: 6588         	str	r0, [r1, #0x58]
;         eventHandleInt->nextEvent       = (Udma_EventHandleInt) NULL_PTR;
7009e860: 9901         	ldr	r1, [sp, #0x4]
7009e862: 2000         	movs	r0, #0x0
7009e864: 65c8         	str	r0, [r1, #0x5c]
;         eventHandleInt->prevEvent       = (Udma_EventHandleInt) NULL_PTR;
7009e866: 9901         	ldr	r1, [sp, #0x4]
7009e868: 6608         	str	r0, [r1, #0x60]
;         eventHandleInt->hwiHandle       = NULL_PTR;
7009e86a: 9901         	ldr	r1, [sp, #0x4]
7009e86c: 6648         	str	r0, [r1, #0x64]
;         eventHandleInt->vintrBitAllocFlag = 0U;
7009e86e: 9901         	ldr	r1, [sp, #0x4]
7009e870: f8c1 008c    	str.w	r0, [r1, #0x8c]
7009e874: f8c1 0088    	str.w	r0, [r1, #0x88]
;         eventHandleInt->pIaGeviRegs     = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
7009e878: 9901         	ldr	r1, [sp, #0x4]
7009e87a: f8c1 0090    	str.w	r0, [r1, #0x90]
;         eventHandleInt->pIaVintrRegs    = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
7009e87e: 9901         	ldr	r1, [sp, #0x4]
7009e880: f8c1 0094    	str.w	r0, [r1, #0x94]
;     }
7009e884: e7ff         	b	0x7009e886 <Udma_eventRegister+0xd6> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e886: 9804         	ldr	r0, [sp, #0x10]
7009e888: 2800         	cmp	r0, #0x0
7009e88a: f040 809f    	bne.w	0x7009e9cc <Udma_eventRegister+0x21c> @ imm = #0x13e
7009e88e: e7ff         	b	0x7009e890 <Udma_eventRegister+0xe0> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009e890: 9802         	ldr	r0, [sp, #0x8]
7009e892: 6800         	ldr	r0, [r0]
7009e894: b130         	cbz	r0, 0x7009e8a4 <Udma_eventRegister+0xf4> @ imm = #0xc
7009e896: e7ff         	b	0x7009e898 <Udma_eventRegister+0xe8> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009e898: 9805         	ldr	r0, [sp, #0x14]
7009e89a: 6800         	ldr	r0, [r0]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009e89c: 2802         	cmp	r0, #0x2
7009e89e: d101         	bne	0x7009e8a4 <Udma_eventRegister+0xf4> @ imm = #0x2
7009e8a0: e7ff         	b	0x7009e8a2 <Udma_eventRegister+0xf2> @ imm = #-0x2
;         }
7009e8a2: e092         	b	0x7009e9ca <Udma_eventRegister+0x21a> @ imm = #0x124
;             retVal = Udma_eventAllocResource(drvHandleInt, eventHandleInt);
7009e8a4: 9802         	ldr	r0, [sp, #0x8]
7009e8a6: 9901         	ldr	r1, [sp, #0x4]
7009e8a8: f000 f89a    	bl	0x7009e9e0 <Udma_eventAllocResource> @ imm = #0x134
7009e8ac: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK == retVal)
7009e8ae: 9804         	ldr	r0, [sp, #0x10]
7009e8b0: b918         	cbnz	r0, 0x7009e8ba <Udma_eventRegister+0x10a> @ imm = #0x6
7009e8b2: e7ff         	b	0x7009e8b4 <Udma_eventRegister+0x104> @ imm = #-0x2
7009e8b4: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009e8b6: 9003         	str	r0, [sp, #0xc]
;             }
7009e8b8: e000         	b	0x7009e8bc <Udma_eventRegister+0x10c> @ imm = #0x0
7009e8ba: e7ff         	b	0x7009e8bc <Udma_eventRegister+0x10c> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009e8bc: 9804         	ldr	r0, [sp, #0x10]
7009e8be: b9a0         	cbnz	r0, 0x7009e8ea <Udma_eventRegister+0x13a> @ imm = #0x28
7009e8c0: e7ff         	b	0x7009e8c2 <Udma_eventRegister+0x112> @ imm = #-0x2
;                 eventHandleInt->eventInitDone = UDMA_INIT_DONE;
7009e8c2: 9901         	ldr	r1, [sp, #0x4]
7009e8c4: f64a 30cd    	movw	r0, #0xabcd
7009e8c8: f6ca 30dc    	movt	r0, #0xabdc
7009e8cc: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 retVal = Udma_eventConfig(drvHandleInt, eventHandleInt);
7009e8d0: 9802         	ldr	r0, [sp, #0x8]
7009e8d2: 9901         	ldr	r1, [sp, #0x4]
7009e8d4: f7fd ff9c    	bl	0x7009c810 <Udma_eventConfig> @ imm = #-0x20c8
7009e8d8: 9004         	str	r0, [sp, #0x10]
;                 if(UDMA_SOK == retVal)
7009e8da: 9804         	ldr	r0, [sp, #0x10]
7009e8dc: b918         	cbnz	r0, 0x7009e8e6 <Udma_eventRegister+0x136> @ imm = #0x6
7009e8de: e7ff         	b	0x7009e8e0 <Udma_eventRegister+0x130> @ imm = #-0x2
7009e8e0: 2001         	movs	r0, #0x1
;                     allocDone = (uint32_t) TRUE;
7009e8e2: 9003         	str	r0, [sp, #0xc]
;                 }
7009e8e4: e000         	b	0x7009e8e8 <Udma_eventRegister+0x138> @ imm = #0x0
7009e8e6: e7ff         	b	0x7009e8e8 <Udma_eventRegister+0x138> @ imm = #-0x2
;             }
7009e8e8: e7ff         	b	0x7009e8ea <Udma_eventRegister+0x13a> @ imm = #-0x2
;             if(UDMA_SOK != retVal)
7009e8ea: 9804         	ldr	r0, [sp, #0x10]
7009e8ec: b170         	cbz	r0, 0x7009e90c <Udma_eventRegister+0x15c> @ imm = #0x1c
7009e8ee: e7ff         	b	0x7009e8f0 <Udma_eventRegister+0x140> @ imm = #-0x2
;                 if(((uint32_t) TRUE) == allocDone)
7009e8f0: 9803         	ldr	r0, [sp, #0xc]
7009e8f2: 2801         	cmp	r0, #0x1
7009e8f4: d109         	bne	0x7009e90a <Udma_eventRegister+0x15a> @ imm = #0x12
7009e8f6: e7ff         	b	0x7009e8f8 <Udma_eventRegister+0x148> @ imm = #-0x2
;                     Udma_eventFreeResource(drvHandleInt, eventHandleInt);
7009e8f8: 9802         	ldr	r0, [sp, #0x8]
7009e8fa: 9901         	ldr	r1, [sp, #0x4]
7009e8fc: f007 f928    	bl	0x700a5b50 <Udma_eventFreeResource> @ imm = #0x7250
;                     eventHandleInt->eventInitDone = UDMA_DEINIT_DONE;
7009e900: 9901         	ldr	r1, [sp, #0x4]
7009e902: 2000         	movs	r0, #0x0
7009e904: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 }
7009e908: e7ff         	b	0x7009e90a <Udma_eventRegister+0x15a> @ imm = #-0x2
;             }
7009e90a: e05d         	b	0x7009e9c8 <Udma_eventRegister+0x218> @ imm = #0xba
;                 eventPrms->intrStatusReg    = &eventHandleInt->pIaVintrRegs->STATUSM;
7009e90c: 9801         	ldr	r0, [sp, #0x4]
7009e90e: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009e912: 3020         	adds	r0, #0x20
7009e914: 9905         	ldr	r1, [sp, #0x14]
7009e916: 6248         	str	r0, [r1, #0x24]
;                 eventPrms->intrClearReg     = &eventHandleInt->pIaVintrRegs->STATUS_CLEAR;
7009e918: 9801         	ldr	r0, [sp, #0x4]
7009e91a: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009e91e: 3018         	adds	r0, #0x18
7009e920: 9905         	ldr	r1, [sp, #0x14]
7009e922: 6288         	str	r0, [r1, #0x28]
;                 if(eventHandleInt->vintrBitNum != UDMA_EVENT_INVALID)
7009e924: 9801         	ldr	r0, [sp, #0x4]
7009e926: 6d00         	ldr	r0, [r0, #0x50]
7009e928: f64f 71ff    	movw	r1, #0xffff
7009e92c: 4288         	cmp	r0, r1
7009e92e: d017         	beq	0x7009e960 <Udma_eventRegister+0x1b0> @ imm = #0x2e
7009e930: e7ff         	b	0x7009e932 <Udma_eventRegister+0x182> @ imm = #-0x2
;                     eventPrms->intrMask     = ((uint64_t)1U << eventHandleInt->vintrBitNum);
7009e932: 9801         	ldr	r0, [sp, #0x4]
7009e934: 6d03         	ldr	r3, [r0, #0x50]
7009e936: f1a3 0120    	sub.w	r1, r3, #0x20
7009e93a: 2201         	movs	r2, #0x1
7009e93c: fa02 fc01    	lsl.w	r12, r2, r1
7009e940: f1c3 0020    	rsb.w	r0, r3, #0x20
7009e944: fa22 f000    	lsr.w	r0, r2, r0
7009e948: 2900         	cmp	r1, #0x0
7009e94a: bf58         	it	pl
7009e94c: 4660         	movpl	r0, r12
7009e94e: fa02 f203    	lsl.w	r2, r2, r3
7009e952: 2900         	cmp	r1, #0x0
7009e954: bf58         	it	pl
7009e956: 2200         	movpl	r2, #0x0
7009e958: 9905         	ldr	r1, [sp, #0x14]
7009e95a: 630a         	str	r2, [r1, #0x30]
7009e95c: 6348         	str	r0, [r1, #0x34]
;                 }
7009e95e: e004         	b	0x7009e96a <Udma_eventRegister+0x1ba> @ imm = #0x8
;                     eventPrms->intrMask     = 0U;
7009e960: 9905         	ldr	r1, [sp, #0x14]
7009e962: 2000         	movs	r0, #0x0
7009e964: 6348         	str	r0, [r1, #0x34]
7009e966: 6308         	str	r0, [r1, #0x30]
7009e968: e7ff         	b	0x7009e96a <Udma_eventRegister+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == eventHandleInt->eventPrms.controllerEventHandle)
7009e96a: 9801         	ldr	r0, [sp, #0x4]
7009e96c: 6980         	ldr	r0, [r0, #0x18]
7009e96e: b948         	cbnz	r0, 0x7009e984 <Udma_eventRegister+0x1d4> @ imm = #0x12
7009e970: e7ff         	b	0x7009e972 <Udma_eventRegister+0x1c2> @ imm = #-0x2
;                     eventPrms->vintrNum     = eventHandleInt->vintrNum;
7009e972: 9801         	ldr	r0, [sp, #0x4]
7009e974: 6cc0         	ldr	r0, [r0, #0x4c]
7009e976: 9905         	ldr	r1, [sp, #0x14]
7009e978: 6388         	str	r0, [r1, #0x38]
;                     eventPrms->coreIntrNum  = eventHandleInt->coreIntrNum;
7009e97a: 9801         	ldr	r0, [sp, #0x4]
7009e97c: 6d80         	ldr	r0, [r0, #0x58]
7009e97e: 9905         	ldr	r1, [sp, #0x14]
7009e980: 63c8         	str	r0, [r1, #0x3c]
;                 }
7009e982: e00a         	b	0x7009e99a <Udma_eventRegister+0x1ea> @ imm = #0x14
;                        ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->vintrNum;
7009e984: 9801         	ldr	r0, [sp, #0x4]
7009e986: 6980         	ldr	r0, [r0, #0x18]
7009e988: 6cc0         	ldr	r0, [r0, #0x4c]
;                     eventPrms->vintrNum       =
7009e98a: 9905         	ldr	r1, [sp, #0x14]
7009e98c: 6388         	str	r0, [r1, #0x38]
;                         ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->coreIntrNum;
7009e98e: 9801         	ldr	r0, [sp, #0x4]
7009e990: 6980         	ldr	r0, [r0, #0x18]
7009e992: 6d80         	ldr	r0, [r0, #0x58]
;                     eventPrms->coreIntrNum    =
7009e994: 9905         	ldr	r1, [sp, #0x14]
7009e996: 63c8         	str	r0, [r1, #0x3c]
7009e998: e7ff         	b	0x7009e99a <Udma_eventRegister+0x1ea> @ imm = #-0x2
;                 eventHandleInt->eventPrms.intrStatusReg   = eventPrms->intrStatusReg;
7009e99a: 9805         	ldr	r0, [sp, #0x14]
7009e99c: 6a40         	ldr	r0, [r0, #0x24]
7009e99e: 9901         	ldr	r1, [sp, #0x4]
7009e9a0: 62c8         	str	r0, [r1, #0x2c]
;                 eventHandleInt->eventPrms.intrClearReg    = eventPrms->intrClearReg;
7009e9a2: 9805         	ldr	r0, [sp, #0x14]
7009e9a4: 6a80         	ldr	r0, [r0, #0x28]
7009e9a6: 9901         	ldr	r1, [sp, #0x4]
7009e9a8: 6308         	str	r0, [r1, #0x30]
;                 eventHandleInt->eventPrms.intrMask        = eventPrms->intrMask;
7009e9aa: 9905         	ldr	r1, [sp, #0x14]
7009e9ac: 6b08         	ldr	r0, [r1, #0x30]
7009e9ae: 6b4a         	ldr	r2, [r1, #0x34]
7009e9b0: 9901         	ldr	r1, [sp, #0x4]
7009e9b2: 63ca         	str	r2, [r1, #0x3c]
7009e9b4: 6388         	str	r0, [r1, #0x38]
;                 eventHandleInt->eventPrms.vintrNum        = eventPrms->vintrNum;
7009e9b6: 9805         	ldr	r0, [sp, #0x14]
7009e9b8: 6b80         	ldr	r0, [r0, #0x38]
7009e9ba: 9901         	ldr	r1, [sp, #0x4]
7009e9bc: 6408         	str	r0, [r1, #0x40]
;                 eventHandleInt->eventPrms.coreIntrNum     = eventPrms->coreIntrNum;
7009e9be: 9805         	ldr	r0, [sp, #0x14]
7009e9c0: 6bc0         	ldr	r0, [r0, #0x3c]
7009e9c2: 9901         	ldr	r1, [sp, #0x4]
7009e9c4: 6448         	str	r0, [r1, #0x44]
7009e9c6: e7ff         	b	0x7009e9c8 <Udma_eventRegister+0x218> @ imm = #-0x2
7009e9c8: e7ff         	b	0x7009e9ca <Udma_eventRegister+0x21a> @ imm = #-0x2
;     }
7009e9ca: e7ff         	b	0x7009e9cc <Udma_eventRegister+0x21c> @ imm = #-0x2
;     return (retVal);
7009e9cc: 9804         	ldr	r0, [sp, #0x10]
7009e9ce: b008         	add	sp, #0x20
7009e9d0: bdb0         	pop	{r4, r5, r7, pc}
		...
7009e9de: 0000         	movs	r0, r0

7009e9e0 <Udma_eventAllocResource>:
; {
7009e9e0: b580         	push	{r7, lr}
7009e9e2: b08a         	sub	sp, #0x28
7009e9e4: 9009         	str	r0, [sp, #0x24]
7009e9e6: 9108         	str	r1, [sp, #0x20]
7009e9e8: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009e9ea: 9007         	str	r0, [sp, #0x1c]
;     eventPrms = &eventHandle->eventPrms;
7009e9ec: 9808         	ldr	r0, [sp, #0x20]
7009e9ee: 3008         	adds	r0, #0x8
7009e9f0: 9004         	str	r0, [sp, #0x10]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009e9f2: 9804         	ldr	r0, [sp, #0x10]
7009e9f4: 6800         	ldr	r0, [r0]
7009e9f6: 2805         	cmp	r0, #0x5
7009e9f8: d01b         	beq	0x7009ea32 <Udma_eventAllocResource+0x52> @ imm = #0x36
7009e9fa: e7ff         	b	0x7009e9fc <Udma_eventAllocResource+0x1c> @ imm = #-0x2
;         eventHandle->globalEvent = Udma_rmAllocEvent(drvHandle);
7009e9fc: 9809         	ldr	r0, [sp, #0x24]
7009e9fe: f009 ffef    	bl	0x700a89e0 <Udma_rmAllocEvent> @ imm = #0x9fde
7009ea02: 9908         	ldr	r1, [sp, #0x20]
7009ea04: 6488         	str	r0, [r1, #0x48]
;         if(UDMA_EVENT_INVALID == eventHandle->globalEvent)
7009ea06: 9808         	ldr	r0, [sp, #0x20]
7009ea08: 6c80         	ldr	r0, [r0, #0x48]
7009ea0a: f64f 71ff    	movw	r1, #0xffff
7009ea0e: 4288         	cmp	r0, r1
7009ea10: d104         	bne	0x7009ea1c <Udma_eventAllocResource+0x3c> @ imm = #0x8
7009ea12: e7ff         	b	0x7009ea14 <Udma_eventAllocResource+0x34> @ imm = #-0x2
7009ea14: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009ea18: 9007         	str	r0, [sp, #0x1c]
;         }
7009ea1a: e009         	b	0x7009ea30 <Udma_eventAllocResource+0x50> @ imm = #0x12
;                 &drvHandle->iaRegs.pImapRegs->GEVI[eventHandle->globalEvent];
7009ea1c: 9809         	ldr	r0, [sp, #0x24]
7009ea1e: f8d0 00a0    	ldr.w	r0, [r0, #0xa0]
7009ea22: 9908         	ldr	r1, [sp, #0x20]
7009ea24: 6c8a         	ldr	r2, [r1, #0x48]
7009ea26: eb00 00c2    	add.w	r0, r0, r2, lsl #3
;             eventHandle->pIaGeviRegs =
7009ea2a: f8c1 0090    	str.w	r0, [r1, #0x90]
7009ea2e: e7ff         	b	0x7009ea30 <Udma_eventAllocResource+0x50> @ imm = #-0x2
;     }
7009ea30: e7ff         	b	0x7009ea32 <Udma_eventAllocResource+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ea32: 9807         	ldr	r0, [sp, #0x1c]
7009ea34: bb00         	cbnz	r0, 0x7009ea78 <Udma_eventAllocResource+0x98> @ imm = #0x40
7009ea36: e7ff         	b	0x7009ea38 <Udma_eventAllocResource+0x58> @ imm = #-0x2
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009ea38: 9804         	ldr	r0, [sp, #0x10]
7009ea3a: 6840         	ldr	r0, [r0, #0x4]
7009ea3c: 2801         	cmp	r0, #0x1
7009ea3e: d009         	beq	0x7009ea54 <Udma_eventAllocResource+0x74> @ imm = #0x12
7009ea40: e7ff         	b	0x7009ea42 <Udma_eventAllocResource+0x62> @ imm = #-0x2
;             ((UDMA_EVENT_MODE_SHARED == eventPrms->eventMode) &&
7009ea42: 9804         	ldr	r0, [sp, #0x10]
7009ea44: 6840         	ldr	r0, [r0, #0x4]
7009ea46: 2802         	cmp	r0, #0x2
7009ea48: d115         	bne	0x7009ea76 <Udma_eventAllocResource+0x96> @ imm = #0x2a
7009ea4a: e7ff         	b	0x7009ea4c <Udma_eventAllocResource+0x6c> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)))
7009ea4c: 9804         	ldr	r0, [sp, #0x10]
7009ea4e: 6900         	ldr	r0, [r0, #0x10]
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009ea50: b988         	cbnz	r0, 0x7009ea76 <Udma_eventAllocResource+0x96> @ imm = #0x22
7009ea52: e7ff         	b	0x7009ea54 <Udma_eventAllocResource+0x74> @ imm = #-0x2
;             eventHandle->vintrNum = Udma_rmAllocVintr(drvHandle);
7009ea54: 9809         	ldr	r0, [sp, #0x24]
7009ea56: f00a f813    	bl	0x700a8a80 <Udma_rmAllocVintr> @ imm = #0xa026
7009ea5a: 9908         	ldr	r1, [sp, #0x20]
7009ea5c: 64c8         	str	r0, [r1, #0x4c]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrNum)
7009ea5e: 9808         	ldr	r0, [sp, #0x20]
7009ea60: 6cc0         	ldr	r0, [r0, #0x4c]
7009ea62: f64f 71ff    	movw	r1, #0xffff
7009ea66: 4288         	cmp	r0, r1
7009ea68: d104         	bne	0x7009ea74 <Udma_eventAllocResource+0x94> @ imm = #0x8
7009ea6a: e7ff         	b	0x7009ea6c <Udma_eventAllocResource+0x8c> @ imm = #-0x2
7009ea6c: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009ea70: 9007         	str	r0, [sp, #0x1c]
;             }
7009ea72: e7ff         	b	0x7009ea74 <Udma_eventAllocResource+0x94> @ imm = #-0x2
;         }
7009ea74: e7ff         	b	0x7009ea76 <Udma_eventAllocResource+0x96> @ imm = #-0x2
;     }
7009ea76: e7ff         	b	0x7009ea78 <Udma_eventAllocResource+0x98> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ea78: 9807         	ldr	r0, [sp, #0x1c]
7009ea7a: b9b8         	cbnz	r0, 0x7009eaac <Udma_eventAllocResource+0xcc> @ imm = #0x2e
7009ea7c: e7ff         	b	0x7009ea7e <Udma_eventAllocResource+0x9e> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009ea7e: 9804         	ldr	r0, [sp, #0x10]
7009ea80: 6800         	ldr	r0, [r0]
7009ea82: 2805         	cmp	r0, #0x5
7009ea84: d011         	beq	0x7009eaaa <Udma_eventAllocResource+0xca> @ imm = #0x22
7009ea86: e7ff         	b	0x7009ea88 <Udma_eventAllocResource+0xa8> @ imm = #-0x2
;             eventHandle->vintrBitNum = Udma_rmAllocVintrBit(eventHandle);
7009ea88: 9808         	ldr	r0, [sp, #0x20]
7009ea8a: f007 ff79    	bl	0x700a6980 <Udma_rmAllocVintrBit> @ imm = #0x7ef2
7009ea8e: 9908         	ldr	r1, [sp, #0x20]
7009ea90: 6508         	str	r0, [r1, #0x50]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrBitNum)
7009ea92: 9808         	ldr	r0, [sp, #0x20]
7009ea94: 6d00         	ldr	r0, [r0, #0x50]
7009ea96: f64f 71ff    	movw	r1, #0xffff
7009ea9a: 4288         	cmp	r0, r1
7009ea9c: d104         	bne	0x7009eaa8 <Udma_eventAllocResource+0xc8> @ imm = #0x8
7009ea9e: e7ff         	b	0x7009eaa0 <Udma_eventAllocResource+0xc0> @ imm = #-0x2
7009eaa0: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009eaa4: 9007         	str	r0, [sp, #0x1c]
;             }
7009eaa6: e7ff         	b	0x7009eaa8 <Udma_eventAllocResource+0xc8> @ imm = #-0x2
;         }
7009eaa8: e7ff         	b	0x7009eaaa <Udma_eventAllocResource+0xca> @ imm = #-0x2
;     }
7009eaaa: e7ff         	b	0x7009eaac <Udma_eventAllocResource+0xcc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009eaac: 9807         	ldr	r0, [sp, #0x1c]
7009eaae: 2800         	cmp	r0, #0x0
7009eab0: d146         	bne	0x7009eb40 <Udma_eventAllocResource+0x160> @ imm = #0x8c
7009eab2: e7ff         	b	0x7009eab4 <Udma_eventAllocResource+0xd4> @ imm = #-0x2
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009eab4: 9804         	ldr	r0, [sp, #0x10]
7009eab6: 6940         	ldr	r0, [r0, #0x14]
7009eab8: b120         	cbz	r0, 0x7009eac4 <Udma_eventAllocResource+0xe4> @ imm = #0x8
7009eaba: e7ff         	b	0x7009eabc <Udma_eventAllocResource+0xdc> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)) ||
7009eabc: 9804         	ldr	r0, [sp, #0x10]
7009eabe: 6900         	ldr	r0, [r0, #0x10]
7009eac0: b128         	cbz	r0, 0x7009eace <Udma_eventAllocResource+0xee> @ imm = #0xa
7009eac2: e7ff         	b	0x7009eac4 <Udma_eventAllocResource+0xe4> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009eac4: 9804         	ldr	r0, [sp, #0x10]
7009eac6: 6800         	ldr	r0, [r0]
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009eac8: 2805         	cmp	r0, #0x5
7009eaca: d138         	bne	0x7009eb3e <Udma_eventAllocResource+0x15e> @ imm = #0x70
7009eacc: e7ff         	b	0x7009eace <Udma_eventAllocResource+0xee> @ imm = #-0x2
;             if(UDMA_CORE_INTR_ANY != eventPrms->preferredCoreIntrNum)
7009eace: 9804         	ldr	r0, [sp, #0x10]
7009ead0: 6a00         	ldr	r0, [r0, #0x20]
7009ead2: 2101         	movs	r1, #0x1
7009ead4: f6cf 71ff    	movt	r1, #0xffff
7009ead8: 4288         	cmp	r0, r1
7009eada: d007         	beq	0x7009eaec <Udma_eventAllocResource+0x10c> @ imm = #0xe
7009eadc: e7ff         	b	0x7009eade <Udma_eventAllocResource+0xfe> @ imm = #-0x2
;                 preferredIrIntrNum = Udma_rmTranslateCoreIntrInput(drvHandle, eventPrms->preferredCoreIntrNum);
7009eade: 9809         	ldr	r0, [sp, #0x24]
7009eae0: 9904         	ldr	r1, [sp, #0x10]
7009eae2: 6a09         	ldr	r1, [r1, #0x20]
7009eae4: f010 fb94    	bl	0x700af210 <Udma_rmTranslateCoreIntrInput> @ imm = #0x10728
7009eae8: 9005         	str	r0, [sp, #0x14]
;             }
7009eaea: e003         	b	0x7009eaf4 <Udma_eventAllocResource+0x114> @ imm = #0x6
;                 preferredIrIntrNum = eventPrms->preferredCoreIntrNum;
7009eaec: 9804         	ldr	r0, [sp, #0x10]
7009eaee: 6a00         	ldr	r0, [r0, #0x20]
7009eaf0: 9005         	str	r0, [sp, #0x14]
7009eaf2: e7ff         	b	0x7009eaf4 <Udma_eventAllocResource+0x114> @ imm = #-0x2
;             if(UDMA_INTR_INVALID != preferredIrIntrNum)
7009eaf4: 9805         	ldr	r0, [sp, #0x14]
7009eaf6: f510 3f80    	cmn.w	r0, #0x10000
7009eafa: d015         	beq	0x7009eb28 <Udma_eventAllocResource+0x148> @ imm = #0x2a
7009eafc: e7ff         	b	0x7009eafe <Udma_eventAllocResource+0x11e> @ imm = #-0x2
;                     Udma_rmAllocIrIntr(preferredIrIntrNum, drvHandle);
7009eafe: 9805         	ldr	r0, [sp, #0x14]
7009eb00: 9909         	ldr	r1, [sp, #0x24]
7009eb02: f004 fa85    	bl	0x700a3010 <Udma_rmAllocIrIntr> @ imm = #0x450a
;                 eventHandle->irIntrNum =
7009eb06: 9908         	ldr	r1, [sp, #0x20]
7009eb08: 6548         	str	r0, [r1, #0x54]
;                 if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
7009eb0a: 9808         	ldr	r0, [sp, #0x20]
7009eb0c: 6d40         	ldr	r0, [r0, #0x54]
7009eb0e: f510 3f80    	cmn.w	r0, #0x10000
7009eb12: d008         	beq	0x7009eb26 <Udma_eventAllocResource+0x146> @ imm = #0x10
7009eb14: e7ff         	b	0x7009eb16 <Udma_eventAllocResource+0x136> @ imm = #-0x2
;                     eventHandle->coreIntrNum = Udma_rmTranslateIrOutput(drvHandle, eventHandle->irIntrNum);
7009eb16: 9809         	ldr	r0, [sp, #0x24]
7009eb18: 9908         	ldr	r1, [sp, #0x20]
7009eb1a: 6d49         	ldr	r1, [r1, #0x54]
7009eb1c: f010 fb90    	bl	0x700af240 <Udma_rmTranslateIrOutput> @ imm = #0x10720
7009eb20: 9908         	ldr	r1, [sp, #0x20]
7009eb22: 6588         	str	r0, [r1, #0x58]
;                 }
7009eb24: e7ff         	b	0x7009eb26 <Udma_eventAllocResource+0x146> @ imm = #-0x2
;             }
7009eb26: e7ff         	b	0x7009eb28 <Udma_eventAllocResource+0x148> @ imm = #-0x2
;             if(UDMA_INTR_INVALID == eventHandle->coreIntrNum)
7009eb28: 9808         	ldr	r0, [sp, #0x20]
7009eb2a: 6d80         	ldr	r0, [r0, #0x58]
7009eb2c: f510 3f80    	cmn.w	r0, #0x10000
7009eb30: d104         	bne	0x7009eb3c <Udma_eventAllocResource+0x15c> @ imm = #0x8
7009eb32: e7ff         	b	0x7009eb34 <Udma_eventAllocResource+0x154> @ imm = #-0x2
7009eb34: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009eb38: 9007         	str	r0, [sp, #0x1c]
;             }
7009eb3a: e7ff         	b	0x7009eb3c <Udma_eventAllocResource+0x15c> @ imm = #-0x2
;         }
7009eb3c: e7ff         	b	0x7009eb3e <Udma_eventAllocResource+0x15e> @ imm = #-0x2
;     }
7009eb3e: e7ff         	b	0x7009eb40 <Udma_eventAllocResource+0x160> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009eb40: 9807         	ldr	r0, [sp, #0x1c]
7009eb42: bb18         	cbnz	r0, 0x7009eb8c <Udma_eventAllocResource+0x1ac> @ imm = #0x46
7009eb44: e7ff         	b	0x7009eb46 <Udma_eventAllocResource+0x166> @ imm = #-0x2
;         cookie = HwiP_disable();
7009eb46: f011 eeec    	blx	0x700b0920 <HwiP_disable> @ imm = #0x11dd8
7009eb4a: 9002         	str	r0, [sp, #0x8]
;         eventHandle->prevEvent = (Udma_EventHandleInt) NULL_PTR;
7009eb4c: 9908         	ldr	r1, [sp, #0x20]
7009eb4e: 2000         	movs	r0, #0x0
7009eb50: 6608         	str	r0, [r1, #0x60]
;         eventHandle->nextEvent = (Udma_EventHandleInt) NULL_PTR;
7009eb52: 9908         	ldr	r1, [sp, #0x20]
7009eb54: 65c8         	str	r0, [r1, #0x5c]
;         if(NULL_PTR != eventPrms->controllerEventHandle)
7009eb56: 9804         	ldr	r0, [sp, #0x10]
7009eb58: 6900         	ldr	r0, [r0, #0x10]
7009eb5a: b198         	cbz	r0, 0x7009eb84 <Udma_eventAllocResource+0x1a4> @ imm = #0x26
7009eb5c: e7ff         	b	0x7009eb5e <Udma_eventAllocResource+0x17e> @ imm = #-0x2
;             lastEvent = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
7009eb5e: 9804         	ldr	r0, [sp, #0x10]
7009eb60: 6900         	ldr	r0, [r0, #0x10]
7009eb62: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009eb64: e7ff         	b	0x7009eb66 <Udma_eventAllocResource+0x186> @ imm = #-0x2
7009eb66: 9803         	ldr	r0, [sp, #0xc]
7009eb68: 6dc0         	ldr	r0, [r0, #0x5c]
7009eb6a: b120         	cbz	r0, 0x7009eb76 <Udma_eventAllocResource+0x196> @ imm = #0x8
7009eb6c: e7ff         	b	0x7009eb6e <Udma_eventAllocResource+0x18e> @ imm = #-0x2
;                 lastEvent = lastEvent->nextEvent;
7009eb6e: 9803         	ldr	r0, [sp, #0xc]
7009eb70: 6dc0         	ldr	r0, [r0, #0x5c]
7009eb72: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009eb74: e7f7         	b	0x7009eb66 <Udma_eventAllocResource+0x186> @ imm = #-0x12
;             eventHandle->prevEvent = lastEvent;
7009eb76: 9803         	ldr	r0, [sp, #0xc]
7009eb78: 9908         	ldr	r1, [sp, #0x20]
7009eb7a: 6608         	str	r0, [r1, #0x60]
;             lastEvent->nextEvent   = eventHandle;
7009eb7c: 9808         	ldr	r0, [sp, #0x20]
7009eb7e: 9903         	ldr	r1, [sp, #0xc]
7009eb80: 65c8         	str	r0, [r1, #0x5c]
;         }
7009eb82: e7ff         	b	0x7009eb84 <Udma_eventAllocResource+0x1a4> @ imm = #-0x2
;         HwiP_restore(cookie);
7009eb84: 9802         	ldr	r0, [sp, #0x8]
7009eb86: f011 eeec    	blx	0x700b0960 <HwiP_restore> @ imm = #0x11dd8
;     }
7009eb8a: e7ff         	b	0x7009eb8c <Udma_eventAllocResource+0x1ac> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009eb8c: 9807         	ldr	r0, [sp, #0x1c]
7009eb8e: b9a0         	cbnz	r0, 0x7009ebba <Udma_eventAllocResource+0x1da> @ imm = #0x28
7009eb90: e7ff         	b	0x7009eb92 <Udma_eventAllocResource+0x1b2> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009eb92: 9804         	ldr	r0, [sp, #0x10]
7009eb94: 6800         	ldr	r0, [r0]
7009eb96: 2803         	cmp	r0, #0x3
7009eb98: d10e         	bne	0x7009ebb8 <Udma_eventAllocResource+0x1d8> @ imm = #0x1c
7009eb9a: e7ff         	b	0x7009eb9c <Udma_eventAllocResource+0x1bc> @ imm = #-0x2
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009eb9c: 9804         	ldr	r0, [sp, #0x10]
7009eb9e: 6880         	ldr	r0, [r0, #0x8]
7009eba0: 9001         	str	r0, [sp, #0x4]
;             if(TRUE == chHandle->chOesAllocDone)
7009eba2: 9801         	ldr	r0, [sp, #0x4]
7009eba4: f8d0 0248    	ldr.w	r0, [r0, #0x248]
7009eba8: 2801         	cmp	r0, #0x1
7009ebaa: d104         	bne	0x7009ebb6 <Udma_eventAllocResource+0x1d6> @ imm = #0x8
7009ebac: e7ff         	b	0x7009ebae <Udma_eventAllocResource+0x1ce> @ imm = #-0x2
7009ebae: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009ebb2: 9007         	str	r0, [sp, #0x1c]
;             }
7009ebb4: e7ff         	b	0x7009ebb6 <Udma_eventAllocResource+0x1d6> @ imm = #-0x2
;         }
7009ebb6: e7ff         	b	0x7009ebb8 <Udma_eventAllocResource+0x1d8> @ imm = #-0x2
;     }
7009ebb8: e7ff         	b	0x7009ebba <Udma_eventAllocResource+0x1da> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009ebba: 9807         	ldr	r0, [sp, #0x1c]
7009ebbc: b128         	cbz	r0, 0x7009ebca <Udma_eventAllocResource+0x1ea> @ imm = #0xa
7009ebbe: e7ff         	b	0x7009ebc0 <Udma_eventAllocResource+0x1e0> @ imm = #-0x2
;         Udma_eventFreeResource(drvHandle, eventHandle);
7009ebc0: 9809         	ldr	r0, [sp, #0x24]
7009ebc2: 9908         	ldr	r1, [sp, #0x20]
7009ebc4: f006 ffc4    	bl	0x700a5b50 <Udma_eventFreeResource> @ imm = #0x6f88
;     }
7009ebc8: e016         	b	0x7009ebf8 <Udma_eventAllocResource+0x218> @ imm = #0x2c
;         if(NULL_PTR == eventPrms->controllerEventHandle)
7009ebca: 9804         	ldr	r0, [sp, #0x10]
7009ebcc: 6900         	ldr	r0, [r0, #0x10]
7009ebce: b920         	cbnz	r0, 0x7009ebda <Udma_eventAllocResource+0x1fa> @ imm = #0x8
7009ebd0: e7ff         	b	0x7009ebd2 <Udma_eventAllocResource+0x1f2> @ imm = #-0x2
;             vintrNum = eventHandle->vintrNum;
7009ebd2: 9808         	ldr	r0, [sp, #0x20]
7009ebd4: 6cc0         	ldr	r0, [r0, #0x4c]
7009ebd6: 9006         	str	r0, [sp, #0x18]
;         }
7009ebd8: e004         	b	0x7009ebe4 <Udma_eventAllocResource+0x204> @ imm = #0x8
;             vintrNum = ((Udma_EventHandleInt) (eventPrms->controllerEventHandle))->vintrNum;
7009ebda: 9804         	ldr	r0, [sp, #0x10]
7009ebdc: 6900         	ldr	r0, [r0, #0x10]
7009ebde: 6cc0         	ldr	r0, [r0, #0x4c]
7009ebe0: 9006         	str	r0, [sp, #0x18]
7009ebe2: e7ff         	b	0x7009ebe4 <Udma_eventAllocResource+0x204> @ imm = #-0x2
;         eventHandle->pIaVintrRegs = &drvHandle->iaRegs.pIntrRegs->VINT[vintrNum];
7009ebe4: 9809         	ldr	r0, [sp, #0x24]
7009ebe6: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
7009ebea: 9906         	ldr	r1, [sp, #0x18]
7009ebec: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009ebf0: 9908         	ldr	r1, [sp, #0x20]
7009ebf2: f8c1 0094    	str.w	r0, [r1, #0x94]
7009ebf6: e7ff         	b	0x7009ebf8 <Udma_eventAllocResource+0x218> @ imm = #-0x2
;     return (retVal);
7009ebf8: 9807         	ldr	r0, [sp, #0x1c]
7009ebfa: b00a         	add	sp, #0x28
7009ebfc: bd80         	pop	{r7, pc}
7009ebfe: 0000         	movs	r0, r0

7009ec00 <Udma_chFreeResource>:
; {
7009ec00: b580         	push	{r7, lr}
7009ec02: b084         	sub	sp, #0x10
7009ec04: 9003         	str	r0, [sp, #0xc]
7009ec06: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009ec08: 9002         	str	r0, [sp, #0x8]
;     drvHandle = chHandle->drvHandle;
7009ec0a: 9803         	ldr	r0, [sp, #0xc]
7009ec0c: 6e80         	ldr	r0, [r0, #0x68]
7009ec0e: 9001         	str	r0, [sp, #0x4]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009ec10: 9803         	ldr	r0, [sp, #0xc]
7009ec12: 7800         	ldrb	r0, [r0]
7009ec14: 0740         	lsls	r0, r0, #0x1d
7009ec16: 2800         	cmp	r0, #0x0
7009ec18: d52e         	bpl	0x7009ec78 <Udma_chFreeResource+0x78> @ imm = #0x5c
7009ec1a: e7ff         	b	0x7009ec1c <Udma_chFreeResource+0x1c> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009ec1c: 9803         	ldr	r0, [sp, #0xc]
7009ec1e: 6ec0         	ldr	r0, [r0, #0x6c]
7009ec20: f510 3f80    	cmn.w	r0, #0x10000
7009ec24: d027         	beq	0x7009ec76 <Udma_chFreeResource+0x76> @ imm = #0x4e
7009ec26: e7ff         	b	0x7009ec28 <Udma_chFreeResource+0x28> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009ec28: 9803         	ldr	r0, [sp, #0xc]
7009ec2a: 7800         	ldrb	r0, [r0]
7009ec2c: 0640         	lsls	r0, r0, #0x19
7009ec2e: 2800         	cmp	r0, #0x0
7009ec30: d506         	bpl	0x7009ec40 <Udma_chFreeResource+0x40> @ imm = #0xc
7009ec32: e7ff         	b	0x7009ec34 <Udma_chFreeResource+0x34> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyHcCh(chHandle->txChNum, drvHandle);
7009ec34: 9803         	ldr	r0, [sp, #0xc]
7009ec36: 6ec0         	ldr	r0, [r0, #0x6c]
7009ec38: 9901         	ldr	r1, [sp, #0x4]
7009ec3a: f00d f961    	bl	0x700abf00 <Udma_rmFreeBlkCopyHcCh> @ imm = #0xd2c2
;             }
7009ec3e: e012         	b	0x7009ec66 <Udma_chFreeResource+0x66> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009ec40: 9803         	ldr	r0, [sp, #0xc]
7009ec42: 7800         	ldrb	r0, [r0]
7009ec44: 0600         	lsls	r0, r0, #0x18
7009ec46: 2800         	cmp	r0, #0x0
7009ec48: d506         	bpl	0x7009ec58 <Udma_chFreeResource+0x58> @ imm = #0xc
7009ec4a: e7ff         	b	0x7009ec4c <Udma_chFreeResource+0x4c> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyUhcCh(chHandle->txChNum, drvHandle);
7009ec4c: 9803         	ldr	r0, [sp, #0xc]
7009ec4e: 6ec0         	ldr	r0, [r0, #0x6c]
7009ec50: 9901         	ldr	r1, [sp, #0x4]
7009ec52: f00d f98d    	bl	0x700abf70 <Udma_rmFreeBlkCopyUhcCh> @ imm = #0xd31a
;             }
7009ec56: e005         	b	0x7009ec64 <Udma_chFreeResource+0x64> @ imm = #0xa
;                 Udma_rmFreeBlkCopyCh(chHandle->txChNum, drvHandle);
7009ec58: 9803         	ldr	r0, [sp, #0xc]
7009ec5a: 6ec0         	ldr	r0, [r0, #0x6c]
7009ec5c: 9901         	ldr	r1, [sp, #0x4]
7009ec5e: f00d f917    	bl	0x700abe90 <Udma_rmFreeBlkCopyCh> @ imm = #0xd22e
7009ec62: e7ff         	b	0x7009ec64 <Udma_chFreeResource+0x64> @ imm = #-0x2
7009ec64: e7ff         	b	0x7009ec66 <Udma_chFreeResource+0x66> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009ec66: 9903         	ldr	r1, [sp, #0xc]
7009ec68: 2000         	movs	r0, #0x0
7009ec6a: f6cf 70ff    	movt	r0, #0xffff
7009ec6e: 66c8         	str	r0, [r1, #0x6c]
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009ec70: 9903         	ldr	r1, [sp, #0xc]
7009ec72: 6708         	str	r0, [r1, #0x70]
;         }
7009ec74: e7ff         	b	0x7009ec76 <Udma_chFreeResource+0x76> @ imm = #-0x2
;     }
7009ec76: e084         	b	0x7009ed82 <Udma_chFreeResource+0x182> @ imm = #0x108
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009ec78: 9803         	ldr	r0, [sp, #0xc]
7009ec7a: 6ec0         	ldr	r0, [r0, #0x6c]
7009ec7c: f510 3f80    	cmn.w	r0, #0x10000
7009ec80: d032         	beq	0x7009ece8 <Udma_chFreeResource+0xe8> @ imm = #0x64
7009ec82: e7ff         	b	0x7009ec84 <Udma_chFreeResource+0x84> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009ec84: 9803         	ldr	r0, [sp, #0xc]
7009ec86: 7800         	ldrb	r0, [r0]
7009ec88: 0640         	lsls	r0, r0, #0x19
7009ec8a: 2800         	cmp	r0, #0x0
7009ec8c: d506         	bpl	0x7009ec9c <Udma_chFreeResource+0x9c> @ imm = #0xc
7009ec8e: e7ff         	b	0x7009ec90 <Udma_chFreeResource+0x90> @ imm = #-0x2
;                 Udma_rmFreeTxHcCh(chHandle->txChNum, drvHandle);
7009ec90: 9803         	ldr	r0, [sp, #0xc]
7009ec92: 6ec0         	ldr	r0, [r0, #0x6c]
7009ec94: 9901         	ldr	r1, [sp, #0x4]
7009ec96: f00d fa83    	bl	0x700ac1a0 <Udma_rmFreeTxHcCh> @ imm = #0xd506
;             }
7009ec9a: e01f         	b	0x7009ecdc <Udma_chFreeResource+0xdc> @ imm = #0x3e
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009ec9c: 9803         	ldr	r0, [sp, #0xc]
7009ec9e: 7840         	ldrb	r0, [r0, #0x1]
7009eca0: 07c0         	lsls	r0, r0, #0x1f
7009eca2: b138         	cbz	r0, 0x7009ecb4 <Udma_chFreeResource+0xb4> @ imm = #0xe
7009eca4: e7ff         	b	0x7009eca6 <Udma_chFreeResource+0xa6> @ imm = #-0x2
;                 Udma_rmFreeMappedTxCh(chHandle->txChNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009eca6: 9803         	ldr	r0, [sp, #0xc]
7009eca8: 68c2         	ldr	r2, [r0, #0xc]
7009ecaa: 6ec0         	ldr	r0, [r0, #0x6c]
7009ecac: 9901         	ldr	r1, [sp, #0x4]
7009ecae: f00c fbaf    	bl	0x700ab410 <Udma_rmFreeMappedTxCh> @ imm = #0xc75e
;             }
7009ecb2: e012         	b	0x7009ecda <Udma_chFreeResource+0xda> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009ecb4: 9803         	ldr	r0, [sp, #0xc]
7009ecb6: 7800         	ldrb	r0, [r0]
7009ecb8: 0600         	lsls	r0, r0, #0x18
7009ecba: 2800         	cmp	r0, #0x0
7009ecbc: d506         	bpl	0x7009eccc <Udma_chFreeResource+0xcc> @ imm = #0xc
7009ecbe: e7ff         	b	0x7009ecc0 <Udma_chFreeResource+0xc0> @ imm = #-0x2
;                 Udma_rmFreeTxUhcCh(chHandle->txChNum, drvHandle);
7009ecc0: 9803         	ldr	r0, [sp, #0xc]
7009ecc2: 6ec0         	ldr	r0, [r0, #0x6c]
7009ecc4: 9901         	ldr	r1, [sp, #0x4]
7009ecc6: f00d faa3    	bl	0x700ac210 <Udma_rmFreeTxUhcCh> @ imm = #0xd546
;             }
7009ecca: e005         	b	0x7009ecd8 <Udma_chFreeResource+0xd8> @ imm = #0xa
;                 Udma_rmFreeTxCh(chHandle->txChNum, drvHandle);
7009eccc: 9803         	ldr	r0, [sp, #0xc]
7009ecce: 6ec0         	ldr	r0, [r0, #0x6c]
7009ecd0: 9901         	ldr	r1, [sp, #0x4]
7009ecd2: f00d fa2d    	bl	0x700ac130 <Udma_rmFreeTxCh> @ imm = #0xd45a
7009ecd6: e7ff         	b	0x7009ecd8 <Udma_chFreeResource+0xd8> @ imm = #-0x2
7009ecd8: e7ff         	b	0x7009ecda <Udma_chFreeResource+0xda> @ imm = #-0x2
7009ecda: e7ff         	b	0x7009ecdc <Udma_chFreeResource+0xdc> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009ecdc: 9903         	ldr	r1, [sp, #0xc]
7009ecde: 2000         	movs	r0, #0x0
7009ece0: f6cf 70ff    	movt	r0, #0xffff
7009ece4: 66c8         	str	r0, [r1, #0x6c]
;         }
7009ece6: e7ff         	b	0x7009ece8 <Udma_chFreeResource+0xe8> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->rxChNum)
7009ece8: 9803         	ldr	r0, [sp, #0xc]
7009ecea: 6f00         	ldr	r0, [r0, #0x70]
7009ecec: f510 3f80    	cmn.w	r0, #0x10000
7009ecf0: d033         	beq	0x7009ed5a <Udma_chFreeResource+0x15a> @ imm = #0x66
7009ecf2: e7ff         	b	0x7009ecf4 <Udma_chFreeResource+0xf4> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009ecf4: 9803         	ldr	r0, [sp, #0xc]
7009ecf6: 7800         	ldrb	r0, [r0]
7009ecf8: 0640         	lsls	r0, r0, #0x19
7009ecfa: 2800         	cmp	r0, #0x0
7009ecfc: d506         	bpl	0x7009ed0c <Udma_chFreeResource+0x10c> @ imm = #0xc
7009ecfe: e7ff         	b	0x7009ed00 <Udma_chFreeResource+0x100> @ imm = #-0x2
;                 Udma_rmFreeRxHcCh(chHandle->rxChNum, drvHandle);
7009ed00: 9803         	ldr	r0, [sp, #0xc]
7009ed02: 6f00         	ldr	r0, [r0, #0x70]
7009ed04: 9901         	ldr	r1, [sp, #0x4]
7009ed06: f00d f9a3    	bl	0x700ac050 <Udma_rmFreeRxHcCh> @ imm = #0xd346
;             }
7009ed0a: e020         	b	0x7009ed4e <Udma_chFreeResource+0x14e> @ imm = #0x40
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009ed0c: 9803         	ldr	r0, [sp, #0xc]
7009ed0e: 7840         	ldrb	r0, [r0, #0x1]
7009ed10: 07c0         	lsls	r0, r0, #0x1f
7009ed12: b140         	cbz	r0, 0x7009ed26 <Udma_chFreeResource+0x126> @ imm = #0x10
7009ed14: e7ff         	b	0x7009ed16 <Udma_chFreeResource+0x116> @ imm = #-0x2
;                 Udma_rmFreeMappedRxCh(chHandle->rxChNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009ed16: 9803         	ldr	r0, [sp, #0xc]
7009ed18: 68c2         	ldr	r2, [r0, #0xc]
7009ed1a: 6f00         	ldr	r0, [r0, #0x70]
7009ed1c: 9901         	ldr	r1, [sp, #0x4]
7009ed1e: 3a04         	subs	r2, #0x4
7009ed20: f00c fb3e    	bl	0x700ab3a0 <Udma_rmFreeMappedRxCh> @ imm = #0xc67c
;             }
7009ed24: e012         	b	0x7009ed4c <Udma_chFreeResource+0x14c> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009ed26: 9803         	ldr	r0, [sp, #0xc]
7009ed28: 7800         	ldrb	r0, [r0]
7009ed2a: 0600         	lsls	r0, r0, #0x18
7009ed2c: 2800         	cmp	r0, #0x0
7009ed2e: d506         	bpl	0x7009ed3e <Udma_chFreeResource+0x13e> @ imm = #0xc
7009ed30: e7ff         	b	0x7009ed32 <Udma_chFreeResource+0x132> @ imm = #-0x2
;                 Udma_rmFreeRxUhcCh(chHandle->rxChNum, drvHandle);
7009ed32: 9803         	ldr	r0, [sp, #0xc]
7009ed34: 6f00         	ldr	r0, [r0, #0x70]
7009ed36: 9901         	ldr	r1, [sp, #0x4]
7009ed38: f00d f9c2    	bl	0x700ac0c0 <Udma_rmFreeRxUhcCh> @ imm = #0xd384
;             }
7009ed3c: e005         	b	0x7009ed4a <Udma_chFreeResource+0x14a> @ imm = #0xa
;                 Udma_rmFreeRxCh(chHandle->rxChNum, drvHandle);
7009ed3e: 9803         	ldr	r0, [sp, #0xc]
7009ed40: 6f00         	ldr	r0, [r0, #0x70]
7009ed42: 9901         	ldr	r1, [sp, #0x4]
7009ed44: f00d f94c    	bl	0x700abfe0 <Udma_rmFreeRxCh> @ imm = #0xd298
7009ed48: e7ff         	b	0x7009ed4a <Udma_chFreeResource+0x14a> @ imm = #-0x2
7009ed4a: e7ff         	b	0x7009ed4c <Udma_chFreeResource+0x14c> @ imm = #-0x2
7009ed4c: e7ff         	b	0x7009ed4e <Udma_chFreeResource+0x14e> @ imm = #-0x2
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009ed4e: 9903         	ldr	r1, [sp, #0xc]
7009ed50: 2000         	movs	r0, #0x0
7009ed52: f6cf 70ff    	movt	r0, #0xffff
7009ed56: 6708         	str	r0, [r1, #0x70]
;         }
7009ed58: e7ff         	b	0x7009ed5a <Udma_chFreeResource+0x15a> @ imm = #-0x2
;         chHandle->defaultFlowObj.drvHandle    = (Udma_DrvHandleInt) NULL_PTR;
7009ed5a: 9903         	ldr	r1, [sp, #0xc]
7009ed5c: 2000         	movs	r0, #0x0
7009ed5e: f8c1 01cc    	str.w	r0, [r1, #0x1cc]
;         chHandle->defaultFlowObj.flowStart    = UDMA_FLOW_INVALID;
7009ed62: 9a03         	ldr	r2, [sp, #0xc]
7009ed64: 2100         	movs	r1, #0x0
7009ed66: f6cf 71ff    	movt	r1, #0xffff
7009ed6a: f8c2 11d0    	str.w	r1, [r2, #0x1d0]
;         chHandle->defaultFlowObj.flowCnt      = 0U;
7009ed6e: 9903         	ldr	r1, [sp, #0xc]
7009ed70: f8c1 01d4    	str.w	r0, [r1, #0x1d4]
;         chHandle->defaultFlowObj.flowInitDone = UDMA_DEINIT_DONE;
7009ed74: 9903         	ldr	r1, [sp, #0xc]
7009ed76: f8c1 01d8    	str.w	r0, [r1, #0x1d8]
;         chHandle->defaultFlow                 = (Udma_FlowHandleInt) NULL_PTR;
7009ed7a: 9903         	ldr	r1, [sp, #0xc]
7009ed7c: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
7009ed80: e7ff         	b	0x7009ed82 <Udma_chFreeResource+0x182> @ imm = #-0x2
;     chHandle->pdmaChNum = UDMA_DMA_CH_INVALID;
7009ed82: 9903         	ldr	r1, [sp, #0xc]
7009ed84: 2000         	movs	r0, #0x0
7009ed86: f6cf 70ff    	movt	r0, #0xffff
7009ed8a: 6788         	str	r0, [r1, #0x78]
;     chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009ed8c: 9903         	ldr	r1, [sp, #0xc]
7009ed8e: 2004         	movs	r0, #0x4
7009ed90: f6cf 70ff    	movt	r0, #0xffff
7009ed94: 67c8         	str	r0, [r1, #0x7c]
;     if(NULL_PTR != chHandle->fqRing)
7009ed96: 9803         	ldr	r0, [sp, #0xc]
7009ed98: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009ed9c: b190         	cbz	r0, 0x7009edc4 <Udma_chFreeResource+0x1c4> @ imm = #0x24
7009ed9e: e7ff         	b	0x7009eda0 <Udma_chFreeResource+0x1a0> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->fqRing);
7009eda0: 9803         	ldr	r0, [sp, #0xc]
7009eda2: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009eda6: f008 f8c3    	bl	0x700a6f30 <Udma_ringFree> @ imm = #0x8186
7009edaa: 4601         	mov	r1, r0
7009edac: 9802         	ldr	r0, [sp, #0x8]
7009edae: 4408         	add	r0, r1
7009edb0: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009edb2: 9802         	ldr	r0, [sp, #0x8]
7009edb4: b108         	cbz	r0, 0x7009edba <Udma_chFreeResource+0x1ba> @ imm = #0x2
7009edb6: e7ff         	b	0x7009edb8 <Udma_chFreeResource+0x1b8> @ imm = #-0x2
;         }
7009edb8: e7ff         	b	0x7009edba <Udma_chFreeResource+0x1ba> @ imm = #-0x2
;         chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009edba: 9903         	ldr	r1, [sp, #0xc]
7009edbc: 2000         	movs	r0, #0x0
7009edbe: f8c1 0080    	str.w	r0, [r1, #0x80]
;     }
7009edc2: e7ff         	b	0x7009edc4 <Udma_chFreeResource+0x1c4> @ imm = #-0x2
;     if(NULL_PTR != chHandle->cqRing)
7009edc4: 9803         	ldr	r0, [sp, #0xc]
7009edc6: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009edca: b128         	cbz	r0, 0x7009edd8 <Udma_chFreeResource+0x1d8> @ imm = #0xa
7009edcc: e7ff         	b	0x7009edce <Udma_chFreeResource+0x1ce> @ imm = #-0x2
;         chHandle->cqRing = (Udma_RingHandleInt) NULL_PTR;
7009edce: 9903         	ldr	r1, [sp, #0xc]
7009edd0: 2000         	movs	r0, #0x0
7009edd2: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009edd6: e7ff         	b	0x7009edd8 <Udma_chFreeResource+0x1d8> @ imm = #-0x2
;     if(NULL_PTR != chHandle->tdCqRing)
7009edd8: 9803         	ldr	r0, [sp, #0xc]
7009edda: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009edde: b190         	cbz	r0, 0x7009ee06 <Udma_chFreeResource+0x206> @ imm = #0x24
7009ede0: e7ff         	b	0x7009ede2 <Udma_chFreeResource+0x1e2> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->tdCqRing);
7009ede2: 9803         	ldr	r0, [sp, #0xc]
7009ede4: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ede8: f008 f8a2    	bl	0x700a6f30 <Udma_ringFree> @ imm = #0x8144
7009edec: 4601         	mov	r1, r0
7009edee: 9802         	ldr	r0, [sp, #0x8]
7009edf0: 4408         	add	r0, r1
7009edf2: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009edf4: 9802         	ldr	r0, [sp, #0x8]
7009edf6: b108         	cbz	r0, 0x7009edfc <Udma_chFreeResource+0x1fc> @ imm = #0x2
7009edf8: e7ff         	b	0x7009edfa <Udma_chFreeResource+0x1fa> @ imm = #-0x2
;         }
7009edfa: e7ff         	b	0x7009edfc <Udma_chFreeResource+0x1fc> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009edfc: 9903         	ldr	r1, [sp, #0xc]
7009edfe: 2000         	movs	r0, #0x0
7009ee00: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009ee04: e7ff         	b	0x7009ee06 <Udma_chFreeResource+0x206> @ imm = #-0x2
;     return (retVal);
7009ee06: 9802         	ldr	r0, [sp, #0x8]
7009ee08: b004         	add	sp, #0x10
7009ee0a: bd80         	pop	{r7, pc}
7009ee0c: 0000         	movs	r0, r0
7009ee0e: 0000         	movs	r0, r0

7009ee10 <Udma_ringAlloc>:
; {
7009ee10: b580         	push	{r7, lr}
7009ee12: b096         	sub	sp, #0x58
7009ee14: 9015         	str	r0, [sp, #0x54]
7009ee16: 9114         	str	r1, [sp, #0x50]
7009ee18: f8ad 204e    	strh.w	r2, [sp, #0x4e]
7009ee1c: 9312         	str	r3, [sp, #0x48]
7009ee1e: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009ee20: 9011         	str	r0, [sp, #0x44]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009ee22: 900d         	str	r0, [sp, #0x34]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009ee24: 9815         	ldr	r0, [sp, #0x54]
7009ee26: 900c         	str	r0, [sp, #0x30]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
7009ee28: 9814         	ldr	r0, [sp, #0x50]
7009ee2a: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == drvHandleInt) ||
7009ee2c: 980c         	ldr	r0, [sp, #0x30]
7009ee2e: b130         	cbz	r0, 0x7009ee3e <Udma_ringAlloc+0x2e> @ imm = #0xc
7009ee30: e7ff         	b	0x7009ee32 <Udma_ringAlloc+0x22> @ imm = #-0x2
;        (NULL_PTR == ringHandleInt) ||
7009ee32: 980b         	ldr	r0, [sp, #0x2c]
7009ee34: b118         	cbz	r0, 0x7009ee3e <Udma_ringAlloc+0x2e> @ imm = #0x6
7009ee36: e7ff         	b	0x7009ee38 <Udma_ringAlloc+0x28> @ imm = #-0x2
;        (NULL_PTR == ringPrms))
7009ee38: 9812         	ldr	r0, [sp, #0x48]
;     if((NULL_PTR == drvHandleInt) ||
7009ee3a: b920         	cbnz	r0, 0x7009ee46 <Udma_ringAlloc+0x36> @ imm = #0x8
7009ee3c: e7ff         	b	0x7009ee3e <Udma_ringAlloc+0x2e> @ imm = #-0x2
7009ee3e: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009ee42: 9011         	str	r0, [sp, #0x44]
;     }
7009ee44: e7ff         	b	0x7009ee46 <Udma_ringAlloc+0x36> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ee46: 9811         	ldr	r0, [sp, #0x44]
7009ee48: b978         	cbnz	r0, 0x7009ee6a <Udma_ringAlloc+0x5a> @ imm = #0x1e
7009ee4a: e7ff         	b	0x7009ee4c <Udma_ringAlloc+0x3c> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009ee4c: 980c         	ldr	r0, [sp, #0x30]
7009ee4e: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009ee52: f64a 31cd    	movw	r1, #0xabcd
7009ee56: f6ca 31dc    	movt	r1, #0xabdc
7009ee5a: 4288         	cmp	r0, r1
7009ee5c: d004         	beq	0x7009ee68 <Udma_ringAlloc+0x58> @ imm = #0x8
7009ee5e: e7ff         	b	0x7009ee60 <Udma_ringAlloc+0x50> @ imm = #-0x2
7009ee60: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009ee64: 9011         	str	r0, [sp, #0x44]
;         }
7009ee66: e7ff         	b	0x7009ee68 <Udma_ringAlloc+0x58> @ imm = #-0x2
;     }
7009ee68: e7ff         	b	0x7009ee6a <Udma_ringAlloc+0x5a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ee6a: 9811         	ldr	r0, [sp, #0x44]
7009ee6c: b930         	cbnz	r0, 0x7009ee7c <Udma_ringAlloc+0x6c> @ imm = #0xc
7009ee6e: e7ff         	b	0x7009ee70 <Udma_ringAlloc+0x60> @ imm = #-0x2
;         retVal = Udma_ringCheckParams(drvHandleInt, ringPrms);
7009ee70: 980c         	ldr	r0, [sp, #0x30]
7009ee72: 9912         	ldr	r1, [sp, #0x48]
7009ee74: f007 febc    	bl	0x700a6bf0 <Udma_ringCheckParams> @ imm = #0x7d78
7009ee78: 9011         	str	r0, [sp, #0x44]
;     }
7009ee7a: e7ff         	b	0x7009ee7c <Udma_ringAlloc+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ee7c: 9811         	ldr	r0, [sp, #0x44]
7009ee7e: 2800         	cmp	r0, #0x0
7009ee80: d140         	bne	0x7009ef04 <Udma_ringAlloc+0xf4> @ imm = #0x80
7009ee82: e7ff         	b	0x7009ee84 <Udma_ringAlloc+0x74> @ imm = #-0x2
;         if(UDMA_RING_ANY == ringNum)
7009ee84: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009ee88: f64f 71fe    	movw	r1, #0xfffe
7009ee8c: 4288         	cmp	r0, r1
7009ee8e: d126         	bne	0x7009eede <Udma_ringAlloc+0xce> @ imm = #0x4c
7009ee90: e7ff         	b	0x7009ee92 <Udma_ringAlloc+0x82> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009ee92: 9812         	ldr	r0, [sp, #0x48]
7009ee94: 6940         	ldr	r0, [r0, #0x14]
7009ee96: 2104         	movs	r1, #0x4
7009ee98: f6cf 71ff    	movt	r1, #0xffff
7009ee9c: 4288         	cmp	r0, r1
7009ee9e: d106         	bne	0x7009eeae <Udma_ringAlloc+0x9e> @ imm = #0xc
7009eea0: e7ff         	b	0x7009eea2 <Udma_ringAlloc+0x92> @ imm = #-0x2
;                 ringHandleInt->ringNum = Udma_rmAllocFreeRing(drvHandleInt);
7009eea2: 980c         	ldr	r0, [sp, #0x30]
7009eea4: f010 fd54    	bl	0x700af950 <Udma_rmAllocFreeRing> @ imm = #0x10aa8
7009eea8: 990b         	ldr	r1, [sp, #0x2c]
7009eeaa: 8088         	strh	r0, [r1, #0x4]
;             }
7009eeac: e008         	b	0x7009eec0 <Udma_ringAlloc+0xb0> @ imm = #0x10
;                 ringHandleInt->ringNum = Udma_rmAllocMappedRing(drvHandleInt, ringPrms->mappedRingGrp, ringPrms->mappedChNum);
7009eeae: 980c         	ldr	r0, [sp, #0x30]
7009eeb0: 9a12         	ldr	r2, [sp, #0x48]
7009eeb2: 6951         	ldr	r1, [r2, #0x14]
7009eeb4: 6992         	ldr	r2, [r2, #0x18]
7009eeb6: f003 fc53    	bl	0x700a2760 <Udma_rmAllocMappedRing> @ imm = #0x38a6
7009eeba: 990b         	ldr	r1, [sp, #0x2c]
7009eebc: 8088         	strh	r0, [r1, #0x4]
7009eebe: e7ff         	b	0x7009eec0 <Udma_ringAlloc+0xb0> @ imm = #-0x2
;             if(UDMA_RING_INVALID == ringHandleInt->ringNum)
7009eec0: 980b         	ldr	r0, [sp, #0x2c]
7009eec2: 8880         	ldrh	r0, [r0, #0x4]
7009eec4: f64f 71ff    	movw	r1, #0xffff
7009eec8: 4288         	cmp	r0, r1
7009eeca: d104         	bne	0x7009eed6 <Udma_ringAlloc+0xc6> @ imm = #0x8
7009eecc: e7ff         	b	0x7009eece <Udma_ringAlloc+0xbe> @ imm = #-0x2
7009eece: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009eed2: 9011         	str	r0, [sp, #0x44]
;             }
7009eed4: e002         	b	0x7009eedc <Udma_ringAlloc+0xcc> @ imm = #0x4
7009eed6: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009eed8: 900d         	str	r0, [sp, #0x34]
7009eeda: e7ff         	b	0x7009eedc <Udma_ringAlloc+0xcc> @ imm = #-0x2
;         }
7009eedc: e011         	b	0x7009ef02 <Udma_ringAlloc+0xf2> @ imm = #0x22
;             if(ringNum >= drvHandleInt->maxRings)
7009eede: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009eee2: 990c         	ldr	r1, [sp, #0x30]
7009eee4: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
7009eee8: 4288         	cmp	r0, r1
7009eeea: d304         	blo	0x7009eef6 <Udma_ringAlloc+0xe6> @ imm = #0x8
7009eeec: e7ff         	b	0x7009eeee <Udma_ringAlloc+0xde> @ imm = #-0x2
7009eeee: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
7009eef2: 9011         	str	r0, [sp, #0x44]
;             }
7009eef4: e004         	b	0x7009ef00 <Udma_ringAlloc+0xf0> @ imm = #0x8
;                 ringHandleInt->ringNum = ringNum;
7009eef6: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009eefa: 990b         	ldr	r1, [sp, #0x2c]
7009eefc: 8088         	strh	r0, [r1, #0x4]
7009eefe: e7ff         	b	0x7009ef00 <Udma_ringAlloc+0xf0> @ imm = #-0x2
7009ef00: e7ff         	b	0x7009ef02 <Udma_ringAlloc+0xf2> @ imm = #-0x2
;     }
7009ef02: e7ff         	b	0x7009ef04 <Udma_ringAlloc+0xf4> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ef04: 9811         	ldr	r0, [sp, #0x44]
7009ef06: b9a8         	cbnz	r0, 0x7009ef34 <Udma_ringAlloc+0x124> @ imm = #0x2a
7009ef08: e7ff         	b	0x7009ef0a <Udma_ringAlloc+0xfa> @ imm = #-0x2
;         Udma_ringAssertFnPointers(drvHandleInt);
7009ef0a: 980c         	ldr	r0, [sp, #0x30]
7009ef0c: f010 fed8    	bl	0x700afcc0 <Udma_ringAssertFnPointers> @ imm = #0x10db0
;         ringHandleInt->drvHandle = drvHandleInt;
7009ef10: 980c         	ldr	r0, [sp, #0x30]
7009ef12: 990b         	ldr	r1, [sp, #0x2c]
7009ef14: 6008         	str	r0, [r1]
;         ringHandleInt->mappedRingGrp   = ringPrms->mappedRingGrp;
7009ef16: 9812         	ldr	r0, [sp, #0x48]
7009ef18: 6940         	ldr	r0, [r0, #0x14]
7009ef1a: 990b         	ldr	r1, [sp, #0x2c]
7009ef1c: 65c8         	str	r0, [r1, #0x5c]
;         ringHandleInt->mappedChNum     = ringPrms->mappedChNum;
7009ef1e: 9812         	ldr	r0, [sp, #0x48]
7009ef20: 6980         	ldr	r0, [r0, #0x18]
7009ef22: 990b         	ldr	r1, [sp, #0x2c]
7009ef24: 6608         	str	r0, [r1, #0x60]
;         drvHandleInt->ringSetCfg(drvHandleInt, ringHandleInt, ringPrms);
7009ef26: 980c         	ldr	r0, [sp, #0x30]
7009ef28: f8d0 35c4    	ldr.w	r3, [r0, #0x5c4]
7009ef2c: 990b         	ldr	r1, [sp, #0x2c]
7009ef2e: 9a12         	ldr	r2, [sp, #0x48]
7009ef30: 4798         	blx	r3
;     }
7009ef32: e7ff         	b	0x7009ef34 <Udma_ringAlloc+0x124> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ef34: 9811         	ldr	r0, [sp, #0x44]
7009ef36: 2800         	cmp	r0, #0x0
7009ef38: d146         	bne	0x7009efc8 <Udma_ringAlloc+0x1b8> @ imm = #0x8c
7009ef3a: e7ff         	b	0x7009ef3c <Udma_ringAlloc+0x12c> @ imm = #-0x2
7009ef3c: 20bf         	movs	r0, #0xbf
;         rmRingReq.valid_params  = TISCI_MSG_VALUE_RM_RING_ADDR_LO_VALID |
7009ef3e: 9004         	str	r0, [sp, #0x10]
;         rmRingReq.nav_id        = drvHandleInt->devIdRing;
7009ef40: 980c         	ldr	r0, [sp, #0x30]
7009ef42: f8b0 00e0    	ldrh.w	r0, [r0, #0xe0]
7009ef46: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmRingReq.index         = ringHandleInt->ringNum;
7009ef4a: 980b         	ldr	r0, [sp, #0x2c]
7009ef4c: 8880         	ldrh	r0, [r0, #0x4]
7009ef4e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         physBase = Udma_virtToPhyFxn(ringPrms->ringMem, drvHandleInt, (Udma_ChHandleInt) NULL_PTR);
7009ef52: 9812         	ldr	r0, [sp, #0x48]
7009ef54: 6800         	ldr	r0, [r0]
7009ef56: 990c         	ldr	r1, [sp, #0x30]
7009ef58: 2200         	movs	r2, #0x0
7009ef5a: f00d f9f1    	bl	0x700ac340 <Udma_virtToPhyFxn> @ imm = #0xd3e2
7009ef5e: 910f         	str	r1, [sp, #0x3c]
7009ef60: 900e         	str	r0, [sp, #0x38]
;         rmRingReq.addr_lo       = (uint32_t)physBase;
7009ef62: 980e         	ldr	r0, [sp, #0x38]
7009ef64: 9006         	str	r0, [sp, #0x18]
;         rmRingReq.addr_hi       = (uint32_t)(physBase >> 32UL);
7009ef66: 980f         	ldr	r0, [sp, #0x3c]
7009ef68: 9007         	str	r0, [sp, #0x1c]
;         rmRingReq.count         = ringPrms->elemCnt;
7009ef6a: 9812         	ldr	r0, [sp, #0x48]
7009ef6c: 68c0         	ldr	r0, [r0, #0xc]
7009ef6e: 9008         	str	r0, [sp, #0x20]
;         rmRingReq.mode          = ringPrms->mode;
7009ef70: 9812         	ldr	r0, [sp, #0x48]
7009ef72: 7a00         	ldrb	r0, [r0, #0x8]
7009ef74: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmRingReq.size          = ringPrms->elemSize;
7009ef78: 9812         	ldr	r0, [sp, #0x48]
7009ef7a: 7c00         	ldrb	r0, [r0, #0x10]
7009ef7c: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmRingReq.order_id      = ringPrms->orderId;
7009ef80: 9812         	ldr	r0, [sp, #0x48]
7009ef82: 7c40         	ldrb	r0, [r0, #0x11]
7009ef84: f88d 0026    	strb.w	r0, [sp, #0x26]
;         rmRingReq.asel          = ringPrms->asel;
7009ef88: 9812         	ldr	r0, [sp, #0x48]
7009ef8a: 7c80         	ldrb	r0, [r0, #0x12]
7009ef8c: f88d 0029    	strb.w	r0, [sp, #0x29]
;         if(UDMA_RING_VIRTID_INVALID != ringPrms->virtId)
7009ef90: 9812         	ldr	r0, [sp, #0x48]
7009ef92: 8940         	ldrh	r0, [r0, #0xa]
7009ef94: f64f 71ff    	movw	r1, #0xffff
7009ef98: 4288         	cmp	r0, r1
7009ef9a: d009         	beq	0x7009efb0 <Udma_ringAlloc+0x1a0> @ imm = #0x12
7009ef9c: e7ff         	b	0x7009ef9e <Udma_ringAlloc+0x18e> @ imm = #-0x2
;             rmRingReq.valid_params |= TISCI_MSG_VALUE_RM_RING_VIRTID_VALID;
7009ef9e: 9804         	ldr	r0, [sp, #0x10]
7009efa0: f040 0040    	orr	r0, r0, #0x40
7009efa4: 9004         	str	r0, [sp, #0x10]
;             rmRingReq.virtid        = ringPrms->virtId;
7009efa6: 9812         	ldr	r0, [sp, #0x48]
7009efa8: 8940         	ldrh	r0, [r0, #0xa]
7009efaa: f8ad 0027    	strh.w	r0, [sp, #0x27]
;         }
7009efae: e7ff         	b	0x7009efb0 <Udma_ringAlloc+0x1a0> @ imm = #-0x2
7009efb0: a802         	add	r0, sp, #0x8
7009efb2: 4669         	mov	r1, sp
7009efb4: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmRingCfg(
7009efb8: f00d fc02    	bl	0x700ac7c0 <Sciclient_rmRingCfg> @ imm = #0xd804
7009efbc: 9011         	str	r0, [sp, #0x44]
;         if(CSL_PASS != retVal)
7009efbe: 9811         	ldr	r0, [sp, #0x44]
7009efc0: b108         	cbz	r0, 0x7009efc6 <Udma_ringAlloc+0x1b6> @ imm = #0x2
7009efc2: e7ff         	b	0x7009efc4 <Udma_ringAlloc+0x1b4> @ imm = #-0x2
;         }
7009efc4: e7ff         	b	0x7009efc6 <Udma_ringAlloc+0x1b6> @ imm = #-0x2
;     }
7009efc6: e7ff         	b	0x7009efc8 <Udma_ringAlloc+0x1b8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009efc8: 9811         	ldr	r0, [sp, #0x44]
7009efca: b938         	cbnz	r0, 0x7009efdc <Udma_ringAlloc+0x1cc> @ imm = #0xe
7009efcc: e7ff         	b	0x7009efce <Udma_ringAlloc+0x1be> @ imm = #-0x2
;         ringHandleInt->ringInitDone = UDMA_INIT_DONE;
7009efce: 990b         	ldr	r1, [sp, #0x2c]
7009efd0: f64a 30cd    	movw	r0, #0xabcd
7009efd4: f6ca 30dc    	movt	r0, #0xabdc
7009efd8: 6588         	str	r0, [r1, #0x58]
;     }
7009efda: e01b         	b	0x7009f014 <Udma_ringAlloc+0x204> @ imm = #0x36
;         if(((uint32_t) TRUE) == allocDone)
7009efdc: 980d         	ldr	r0, [sp, #0x34]
7009efde: 2801         	cmp	r0, #0x1
7009efe0: d117         	bne	0x7009f012 <Udma_ringAlloc+0x202> @ imm = #0x2e
7009efe2: e7ff         	b	0x7009efe4 <Udma_ringAlloc+0x1d4> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009efe4: 9812         	ldr	r0, [sp, #0x48]
7009efe6: 6940         	ldr	r0, [r0, #0x14]
7009efe8: 2104         	movs	r1, #0x4
7009efea: f6cf 71ff    	movt	r1, #0xffff
7009efee: 4288         	cmp	r0, r1
7009eff0: d106         	bne	0x7009f000 <Udma_ringAlloc+0x1f0> @ imm = #0xc
7009eff2: e7ff         	b	0x7009eff4 <Udma_ringAlloc+0x1e4> @ imm = #-0x2
;                 Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandleInt);
7009eff4: 980b         	ldr	r0, [sp, #0x2c]
7009eff6: 8880         	ldrh	r0, [r0, #0x4]
7009eff8: 990c         	ldr	r1, [sp, #0x30]
7009effa: f010 fe29    	bl	0x700afc50 <Udma_rmFreeFreeRing> @ imm = #0x10c52
;             }
7009effe: e007         	b	0x7009f010 <Udma_ringAlloc+0x200> @ imm = #0xe
;                 Udma_rmFreeMappedRing(ringHandleInt->ringNum, drvHandleInt, ringHandleInt->mappedRingGrp, ringHandleInt->mappedChNum);
7009f000: 9b0b         	ldr	r3, [sp, #0x2c]
7009f002: 8898         	ldrh	r0, [r3, #0x4]
7009f004: 990c         	ldr	r1, [sp, #0x30]
7009f006: 6dda         	ldr	r2, [r3, #0x5c]
7009f008: 6e1b         	ldr	r3, [r3, #0x60]
7009f00a: f00a fdf9    	bl	0x700a9c00 <Udma_rmFreeMappedRing> @ imm = #0xabf2
7009f00e: e7ff         	b	0x7009f010 <Udma_ringAlloc+0x200> @ imm = #-0x2
;         }
7009f010: e7ff         	b	0x7009f012 <Udma_ringAlloc+0x202> @ imm = #-0x2
7009f012: e7ff         	b	0x7009f014 <Udma_ringAlloc+0x204> @ imm = #-0x2
;     return (retVal);
7009f014: 9811         	ldr	r0, [sp, #0x44]
7009f016: b016         	add	sp, #0x58
7009f018: bd80         	pop	{r7, pc}
7009f01a: 0000         	movs	r0, r0
7009f01c: 0000         	movs	r0, r0
7009f01e: 0000         	movs	r0, r0

7009f020 <Udma_chDisableBlkCpyChan>:
; {
7009f020: b580         	push	{r7, lr}
7009f022: b090         	sub	sp, #0x40
7009f024: 900f         	str	r0, [sp, #0x3c]
7009f026: 910e         	str	r1, [sp, #0x38]
7009f028: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f02a: 900d         	str	r0, [sp, #0x34]
;     uint32_t            currTimeout = 0U;
7009f02c: 900c         	str	r0, [sp, #0x30]
;     drvHandle = chHandle->drvHandle;
7009f02e: 980f         	ldr	r0, [sp, #0x3c]
7009f030: 6e80         	ldr	r0, [r0, #0x68]
7009f032: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f034: 980b         	ldr	r0, [sp, #0x2c]
7009f036: 6800         	ldr	r0, [r0]
7009f038: 2801         	cmp	r0, #0x1
7009f03a: d10a         	bne	0x7009f052 <Udma_chDisableBlkCpyChan+0x32> @ imm = #0x14
7009f03c: e7ff         	b	0x7009f03e <Udma_chDisableBlkCpyChan+0x1e> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009f03e: 980b         	ldr	r0, [sp, #0x2c]
7009f040: 3008         	adds	r0, #0x8
7009f042: 990f         	ldr	r1, [sp, #0x3c]
7009f044: 6ec9         	ldr	r1, [r1, #0x6c]
7009f046: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009f048: 461a         	mov	r2, r3
7009f04a: f00e fb39    	bl	0x700ad6c0 <CSL_bcdmaTeardownTxChan> @ imm = #0xe672
7009f04e: 900d         	str	r0, [sp, #0x34]
;     }
7009f050: e00f         	b	0x7009f072 <Udma_chDisableBlkCpyChan+0x52> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f052: 980b         	ldr	r0, [sp, #0x2c]
7009f054: 6800         	ldr	r0, [r0]
7009f056: 2802         	cmp	r0, #0x2
7009f058: d10a         	bne	0x7009f070 <Udma_chDisableBlkCpyChan+0x50> @ imm = #0x14
7009f05a: e7ff         	b	0x7009f05c <Udma_chDisableBlkCpyChan+0x3c> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009f05c: 980b         	ldr	r0, [sp, #0x2c]
7009f05e: 3054         	adds	r0, #0x54
7009f060: 990f         	ldr	r1, [sp, #0x3c]
7009f062: 6ec9         	ldr	r1, [r1, #0x6c]
7009f064: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009f066: 461a         	mov	r2, r3
7009f068: f00f f9f2    	bl	0x700ae450 <CSL_pktdmaTeardownTxChan> @ imm = #0xf3e4
7009f06c: 900d         	str	r0, [sp, #0x34]
;     }
7009f06e: e7ff         	b	0x7009f070 <Udma_chDisableBlkCpyChan+0x50> @ imm = #-0x2
7009f070: e7ff         	b	0x7009f072 <Udma_chDisableBlkCpyChan+0x52> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009f072: 980d         	ldr	r0, [sp, #0x34]
7009f074: b108         	cbz	r0, 0x7009f07a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #0x2
7009f076: e7ff         	b	0x7009f078 <Udma_chDisableBlkCpyChan+0x58> @ imm = #-0x2
;     }
7009f078: e7ff         	b	0x7009f07a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009f07a: e7ff         	b	0x7009f07c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x2
7009f07c: 980d         	ldr	r0, [sp, #0x34]
7009f07e: bba8         	cbnz	r0, 0x7009f0ec <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x6a
7009f080: e7ff         	b	0x7009f082 <Udma_chDisableBlkCpyChan+0x62> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f082: 980b         	ldr	r0, [sp, #0x2c]
7009f084: 6800         	ldr	r0, [r0]
7009f086: 2801         	cmp	r0, #0x1
7009f088: d10c         	bne	0x7009f0a4 <Udma_chDisableBlkCpyChan+0x84> @ imm = #0x18
7009f08a: e7ff         	b	0x7009f08c <Udma_chDisableBlkCpyChan+0x6c> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f08c: 980b         	ldr	r0, [sp, #0x2c]
7009f08e: 3008         	adds	r0, #0x8
7009f090: 990f         	ldr	r1, [sp, #0x3c]
7009f092: 6ec9         	ldr	r1, [r1, #0x6c]
7009f094: aa05         	add	r2, sp, #0x14
7009f096: f00f fcd3    	bl	0x700aea40 <CSL_bcdmaGetTxRT> @ imm = #0xf9a6
;             if(FALSE == bcdmaRtStatus.enable)
7009f09a: 9805         	ldr	r0, [sp, #0x14]
7009f09c: b908         	cbnz	r0, 0x7009f0a2 <Udma_chDisableBlkCpyChan+0x82> @ imm = #0x2
7009f09e: e7ff         	b	0x7009f0a0 <Udma_chDisableBlkCpyChan+0x80> @ imm = #-0x2
;                 break;
7009f0a0: e024         	b	0x7009f0ec <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x48
;         }
7009f0a2: e011         	b	0x7009f0c8 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f0a4: 980b         	ldr	r0, [sp, #0x2c]
7009f0a6: 6800         	ldr	r0, [r0]
7009f0a8: 2802         	cmp	r0, #0x2
7009f0aa: d10c         	bne	0x7009f0c6 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #0x18
7009f0ac: e7ff         	b	0x7009f0ae <Udma_chDisableBlkCpyChan+0x8e> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f0ae: 980b         	ldr	r0, [sp, #0x2c]
7009f0b0: 3054         	adds	r0, #0x54
7009f0b2: 990f         	ldr	r1, [sp, #0x3c]
7009f0b4: 6ec9         	ldr	r1, [r1, #0x6c]
7009f0b6: 466a         	mov	r2, sp
7009f0b8: f00e f952    	bl	0x700ad360 <CSL_pktdmaGetTxRT> @ imm = #0xe2a4
;             if(FALSE == pktdmaRtStatus.enable)
7009f0bc: 9800         	ldr	r0, [sp]
7009f0be: b908         	cbnz	r0, 0x7009f0c4 <Udma_chDisableBlkCpyChan+0xa4> @ imm = #0x2
7009f0c0: e7ff         	b	0x7009f0c2 <Udma_chDisableBlkCpyChan+0xa2> @ imm = #-0x2
;                 break;
7009f0c2: e013         	b	0x7009f0ec <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x26
;         }
7009f0c4: e7ff         	b	0x7009f0c6 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #-0x2
7009f0c6: e7ff         	b	0x7009f0c8 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #-0x2
;         if(currTimeout > timeout)
7009f0c8: 980c         	ldr	r0, [sp, #0x30]
7009f0ca: 990e         	ldr	r1, [sp, #0x38]
7009f0cc: 4288         	cmp	r0, r1
7009f0ce: d904         	bls	0x7009f0da <Udma_chDisableBlkCpyChan+0xba> @ imm = #0x8
7009f0d0: e7ff         	b	0x7009f0d2 <Udma_chDisableBlkCpyChan+0xb2> @ imm = #-0x2
7009f0d2: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009f0d6: 900d         	str	r0, [sp, #0x34]
;         }
7009f0d8: e007         	b	0x7009f0ea <Udma_chDisableBlkCpyChan+0xca> @ imm = #0xe
7009f0da: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009f0de: f00b ff77    	bl	0x700aafd0 <ClockP_usleep> @ imm = #0xbeee
;             currTimeout++;
7009f0e2: 980c         	ldr	r0, [sp, #0x30]
7009f0e4: 3001         	adds	r0, #0x1
7009f0e6: 900c         	str	r0, [sp, #0x30]
7009f0e8: e7ff         	b	0x7009f0ea <Udma_chDisableBlkCpyChan+0xca> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009f0ea: e7c7         	b	0x7009f07c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x72
;     if(UDMA_SOK != retVal)
7009f0ec: 980d         	ldr	r0, [sp, #0x34]
7009f0ee: 2800         	cmp	r0, #0x0
7009f0f0: d05f         	beq	0x7009f1b2 <Udma_chDisableBlkCpyChan+0x192> @ imm = #0xbe
7009f0f2: e7ff         	b	0x7009f0f4 <Udma_chDisableBlkCpyChan+0xd4> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f0f4: 980b         	ldr	r0, [sp, #0x2c]
7009f0f6: 6800         	ldr	r0, [r0]
7009f0f8: 2801         	cmp	r0, #0x1
7009f0fa: d10a         	bne	0x7009f112 <Udma_chDisableBlkCpyChan+0xf2> @ imm = #0x14
7009f0fc: e7ff         	b	0x7009f0fe <Udma_chDisableBlkCpyChan+0xde> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009f0fe: 980b         	ldr	r0, [sp, #0x2c]
7009f100: 3008         	adds	r0, #0x8
7009f102: 990f         	ldr	r1, [sp, #0x3c]
7009f104: 6ec9         	ldr	r1, [r1, #0x6c]
7009f106: 2201         	movs	r2, #0x1
7009f108: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009f10a: f00e fad9    	bl	0x700ad6c0 <CSL_bcdmaTeardownTxChan> @ imm = #0xe5b2
7009f10e: 900d         	str	r0, [sp, #0x34]
;         }
7009f110: e00f         	b	0x7009f132 <Udma_chDisableBlkCpyChan+0x112> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f112: 980b         	ldr	r0, [sp, #0x2c]
7009f114: 6800         	ldr	r0, [r0]
7009f116: 2802         	cmp	r0, #0x2
7009f118: d10a         	bne	0x7009f130 <Udma_chDisableBlkCpyChan+0x110> @ imm = #0x14
7009f11a: e7ff         	b	0x7009f11c <Udma_chDisableBlkCpyChan+0xfc> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009f11c: 980b         	ldr	r0, [sp, #0x2c]
7009f11e: 3054         	adds	r0, #0x54
7009f120: 990f         	ldr	r1, [sp, #0x3c]
7009f122: 6ec9         	ldr	r1, [r1, #0x6c]
7009f124: 2201         	movs	r2, #0x1
7009f126: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009f128: f00f f992    	bl	0x700ae450 <CSL_pktdmaTeardownTxChan> @ imm = #0xf324
7009f12c: 900d         	str	r0, [sp, #0x34]
;         }
7009f12e: e7ff         	b	0x7009f130 <Udma_chDisableBlkCpyChan+0x110> @ imm = #-0x2
7009f130: e7ff         	b	0x7009f132 <Udma_chDisableBlkCpyChan+0x112> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009f132: 980d         	ldr	r0, [sp, #0x34]
7009f134: b108         	cbz	r0, 0x7009f13a <Udma_chDisableBlkCpyChan+0x11a> @ imm = #0x2
7009f136: e7ff         	b	0x7009f138 <Udma_chDisableBlkCpyChan+0x118> @ imm = #-0x2
;         }
7009f138: e7ff         	b	0x7009f13a <Udma_chDisableBlkCpyChan+0x11a> @ imm = #-0x2
7009f13a: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009f13c: 900c         	str	r0, [sp, #0x30]
;         while(UDMA_SOK == retVal)
7009f13e: e7ff         	b	0x7009f140 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x2
7009f140: 980d         	ldr	r0, [sp, #0x34]
7009f142: bba8         	cbnz	r0, 0x7009f1b0 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x6a
7009f144: e7ff         	b	0x7009f146 <Udma_chDisableBlkCpyChan+0x126> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f146: 980b         	ldr	r0, [sp, #0x2c]
7009f148: 6800         	ldr	r0, [r0]
7009f14a: 2801         	cmp	r0, #0x1
7009f14c: d10c         	bne	0x7009f168 <Udma_chDisableBlkCpyChan+0x148> @ imm = #0x18
7009f14e: e7ff         	b	0x7009f150 <Udma_chDisableBlkCpyChan+0x130> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f150: 980b         	ldr	r0, [sp, #0x2c]
7009f152: 3008         	adds	r0, #0x8
7009f154: 990f         	ldr	r1, [sp, #0x3c]
7009f156: 6ec9         	ldr	r1, [r1, #0x6c]
7009f158: aa05         	add	r2, sp, #0x14
7009f15a: f00f fc71    	bl	0x700aea40 <CSL_bcdmaGetTxRT> @ imm = #0xf8e2
;                 if(FALSE == bcdmaRtStatus.enable)
7009f15e: 9805         	ldr	r0, [sp, #0x14]
7009f160: b908         	cbnz	r0, 0x7009f166 <Udma_chDisableBlkCpyChan+0x146> @ imm = #0x2
7009f162: e7ff         	b	0x7009f164 <Udma_chDisableBlkCpyChan+0x144> @ imm = #-0x2
;                     break;
7009f164: e024         	b	0x7009f1b0 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x48
;             }
7009f166: e011         	b	0x7009f18c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #0x22
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f168: 980b         	ldr	r0, [sp, #0x2c]
7009f16a: 6800         	ldr	r0, [r0]
7009f16c: 2802         	cmp	r0, #0x2
7009f16e: d10c         	bne	0x7009f18a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #0x18
7009f170: e7ff         	b	0x7009f172 <Udma_chDisableBlkCpyChan+0x152> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f172: 980b         	ldr	r0, [sp, #0x2c]
7009f174: 3054         	adds	r0, #0x54
7009f176: 990f         	ldr	r1, [sp, #0x3c]
7009f178: 6ec9         	ldr	r1, [r1, #0x6c]
7009f17a: 466a         	mov	r2, sp
7009f17c: f00e f8f0    	bl	0x700ad360 <CSL_pktdmaGetTxRT> @ imm = #0xe1e0
;                 if(FALSE == pktdmaRtStatus.enable)
7009f180: 9800         	ldr	r0, [sp]
7009f182: b908         	cbnz	r0, 0x7009f188 <Udma_chDisableBlkCpyChan+0x168> @ imm = #0x2
7009f184: e7ff         	b	0x7009f186 <Udma_chDisableBlkCpyChan+0x166> @ imm = #-0x2
;                     break;
7009f186: e013         	b	0x7009f1b0 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x26
;             }
7009f188: e7ff         	b	0x7009f18a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #-0x2
7009f18a: e7ff         	b	0x7009f18c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009f18c: 980c         	ldr	r0, [sp, #0x30]
7009f18e: 990e         	ldr	r1, [sp, #0x38]
7009f190: 4288         	cmp	r0, r1
7009f192: d904         	bls	0x7009f19e <Udma_chDisableBlkCpyChan+0x17e> @ imm = #0x8
7009f194: e7ff         	b	0x7009f196 <Udma_chDisableBlkCpyChan+0x176> @ imm = #-0x2
7009f196: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009f19a: 900d         	str	r0, [sp, #0x34]
;             }
7009f19c: e007         	b	0x7009f1ae <Udma_chDisableBlkCpyChan+0x18e> @ imm = #0xe
7009f19e: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009f1a2: f00b ff15    	bl	0x700aafd0 <ClockP_usleep> @ imm = #0xbe2a
;                 currTimeout++;
7009f1a6: 980c         	ldr	r0, [sp, #0x30]
7009f1a8: 3001         	adds	r0, #0x1
7009f1aa: 900c         	str	r0, [sp, #0x30]
7009f1ac: e7ff         	b	0x7009f1ae <Udma_chDisableBlkCpyChan+0x18e> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009f1ae: e7c7         	b	0x7009f140 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x72
;     }
7009f1b0: e7ff         	b	0x7009f1b2 <Udma_chDisableBlkCpyChan+0x192> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f1b2: 980d         	ldr	r0, [sp, #0x34]
7009f1b4: bb20         	cbnz	r0, 0x7009f200 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #0x48
7009f1b6: e7ff         	b	0x7009f1b8 <Udma_chDisableBlkCpyChan+0x198> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f1b8: 980b         	ldr	r0, [sp, #0x2c]
7009f1ba: 6800         	ldr	r0, [r0]
7009f1bc: 2801         	cmp	r0, #0x1
7009f1be: d10c         	bne	0x7009f1da <Udma_chDisableBlkCpyChan+0x1ba> @ imm = #0x18
7009f1c0: e7ff         	b	0x7009f1c2 <Udma_chDisableBlkCpyChan+0x1a2> @ imm = #-0x2
7009f1c2: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009f1c4: 9005         	str	r0, [sp, #0x14]
;             bcdmaRtStatus.teardown = FALSE;
7009f1c6: 9006         	str	r0, [sp, #0x18]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009f1c8: 9009         	str	r0, [sp, #0x24]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f1ca: 980b         	ldr	r0, [sp, #0x2c]
7009f1cc: 3008         	adds	r0, #0x8
7009f1ce: 990f         	ldr	r1, [sp, #0x3c]
7009f1d0: 6ec9         	ldr	r1, [r1, #0x6c]
7009f1d2: aa05         	add	r2, sp, #0x14
7009f1d4: f00f fc64    	bl	0x700aeaa0 <CSL_bcdmaSetTxRT> @ imm = #0xf8c8
;         }
7009f1d8: e011         	b	0x7009f1fe <Udma_chDisableBlkCpyChan+0x1de> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f1da: 980b         	ldr	r0, [sp, #0x2c]
7009f1dc: 6800         	ldr	r0, [r0]
7009f1de: 2802         	cmp	r0, #0x2
7009f1e0: d10c         	bne	0x7009f1fc <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #0x18
7009f1e2: e7ff         	b	0x7009f1e4 <Udma_chDisableBlkCpyChan+0x1c4> @ imm = #-0x2
7009f1e4: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009f1e6: 9000         	str	r0, [sp]
;             pktdmaRtStatus.teardown = FALSE;
7009f1e8: 9001         	str	r0, [sp, #0x4]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009f1ea: 9004         	str	r0, [sp, #0x10]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f1ec: 980b         	ldr	r0, [sp, #0x2c]
7009f1ee: 3054         	adds	r0, #0x54
7009f1f0: 990f         	ldr	r1, [sp, #0x3c]
7009f1f2: 6ec9         	ldr	r1, [r1, #0x6c]
7009f1f4: 466a         	mov	r2, sp
7009f1f6: f00e fe6b    	bl	0x700aded0 <CSL_pktdmaSetTxRT> @ imm = #0xecd6
;         }
7009f1fa: e7ff         	b	0x7009f1fc <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #-0x2
7009f1fc: e7ff         	b	0x7009f1fe <Udma_chDisableBlkCpyChan+0x1de> @ imm = #-0x2
;     }
7009f1fe: e7ff         	b	0x7009f200 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #-0x2
;     return (retVal);
7009f200: 980d         	ldr	r0, [sp, #0x34]
7009f202: b010         	add	sp, #0x40
7009f204: bd80         	pop	{r7, pc}
		...
7009f20e: 0000         	movs	r0, r0

7009f210 <Udma_flowConfig>:
; {
7009f210: b580         	push	{r7, lr}
7009f212: b09e         	sub	sp, #0x78
7009f214: 901d         	str	r0, [sp, #0x74]
7009f216: 911c         	str	r1, [sp, #0x70]
7009f218: 921b         	str	r2, [sp, #0x6c]
7009f21a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f21c: 901a         	str	r0, [sp, #0x68]
;     Udma_FlowHandleInt  flowHandleInt = (Udma_FlowHandleInt) flowHandle;
7009f21e: 981d         	ldr	r0, [sp, #0x74]
7009f220: 9018         	str	r0, [sp, #0x60]
;     if((NULL_PTR == flowHandleInt) ||
7009f222: 9818         	ldr	r0, [sp, #0x60]
7009f224: b160         	cbz	r0, 0x7009f240 <Udma_flowConfig+0x30> @ imm = #0x18
7009f226: e7ff         	b	0x7009f228 <Udma_flowConfig+0x18> @ imm = #-0x2
;        (flowHandleInt->flowInitDone != UDMA_INIT_DONE) ||
7009f228: 9818         	ldr	r0, [sp, #0x60]
7009f22a: 68c0         	ldr	r0, [r0, #0xc]
7009f22c: f64a 31cd    	movw	r1, #0xabcd
7009f230: f6ca 31dc    	movt	r1, #0xabdc
7009f234: 4288         	cmp	r0, r1
7009f236: d103         	bne	0x7009f240 <Udma_flowConfig+0x30> @ imm = #0x6
7009f238: e7ff         	b	0x7009f23a <Udma_flowConfig+0x2a> @ imm = #-0x2
;        (NULL_PTR == flowPrms))
7009f23a: 981b         	ldr	r0, [sp, #0x6c]
;     if((NULL_PTR == flowHandleInt) ||
7009f23c: b920         	cbnz	r0, 0x7009f248 <Udma_flowConfig+0x38> @ imm = #0x8
7009f23e: e7ff         	b	0x7009f240 <Udma_flowConfig+0x30> @ imm = #-0x2
7009f240: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009f244: 901a         	str	r0, [sp, #0x68]
;     }
7009f246: e7ff         	b	0x7009f248 <Udma_flowConfig+0x38> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f248: 981a         	ldr	r0, [sp, #0x68]
7009f24a: b9a8         	cbnz	r0, 0x7009f278 <Udma_flowConfig+0x68> @ imm = #0x2a
7009f24c: e7ff         	b	0x7009f24e <Udma_flowConfig+0x3e> @ imm = #-0x2
;         drvHandle = flowHandleInt->drvHandle;
7009f24e: 9818         	ldr	r0, [sp, #0x60]
7009f250: 6800         	ldr	r0, [r0]
7009f252: 9019         	str	r0, [sp, #0x64]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009f254: 9819         	ldr	r0, [sp, #0x64]
7009f256: b150         	cbz	r0, 0x7009f26e <Udma_flowConfig+0x5e> @ imm = #0x14
7009f258: e7ff         	b	0x7009f25a <Udma_flowConfig+0x4a> @ imm = #-0x2
7009f25a: 9819         	ldr	r0, [sp, #0x64]
7009f25c: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009f260: f64a 31cd    	movw	r1, #0xabcd
7009f264: f6ca 31dc    	movt	r1, #0xabdc
7009f268: 4288         	cmp	r0, r1
7009f26a: d004         	beq	0x7009f276 <Udma_flowConfig+0x66> @ imm = #0x8
7009f26c: e7ff         	b	0x7009f26e <Udma_flowConfig+0x5e> @ imm = #-0x2
7009f26e: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009f272: 901a         	str	r0, [sp, #0x68]
;         }
7009f274: e7ff         	b	0x7009f276 <Udma_flowConfig+0x66> @ imm = #-0x2
;     }
7009f276: e7ff         	b	0x7009f278 <Udma_flowConfig+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f278: 981a         	ldr	r0, [sp, #0x68]
7009f27a: b958         	cbnz	r0, 0x7009f294 <Udma_flowConfig+0x84> @ imm = #0x16
7009f27c: e7ff         	b	0x7009f27e <Udma_flowConfig+0x6e> @ imm = #-0x2
;         if(flowIdx >= flowHandleInt->flowCnt)
7009f27e: 981c         	ldr	r0, [sp, #0x70]
7009f280: 9918         	ldr	r1, [sp, #0x60]
7009f282: 6889         	ldr	r1, [r1, #0x8]
7009f284: 4288         	cmp	r0, r1
7009f286: d304         	blo	0x7009f292 <Udma_flowConfig+0x82> @ imm = #0x8
7009f288: e7ff         	b	0x7009f28a <Udma_flowConfig+0x7a> @ imm = #-0x2
7009f28a: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
7009f28e: 901a         	str	r0, [sp, #0x68]
;         }
7009f290: e7ff         	b	0x7009f292 <Udma_flowConfig+0x82> @ imm = #-0x2
;     }
7009f292: e7ff         	b	0x7009f294 <Udma_flowConfig+0x84> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f294: 981a         	ldr	r0, [sp, #0x68]
7009f296: 2800         	cmp	r0, #0x0
7009f298: f040 80a3    	bne.w	0x7009f3e2 <Udma_flowConfig+0x1d2> @ imm = #0x146
7009f29c: e7ff         	b	0x7009f29e <Udma_flowConfig+0x8e> @ imm = #-0x2
7009f29e: f64f 70ff    	movw	r0, #0xffff
7009f2a2: f2c0 0007    	movt	r0, #0x7
;         rmFlowReq.valid_params          = TISCI_MSG_VALUE_RM_UDMAP_FLOW_EINFO_PRESENT_VALID |
7009f2a6: 900f         	str	r0, [sp, #0x3c]
;         rmFlowReq.nav_id                = drvHandle->devIdUdma;
7009f2a8: 9819         	ldr	r0, [sp, #0x64]
7009f2aa: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009f2ae: f8ad 0040    	strh.w	r0, [sp, #0x40]
;         rmFlowReq.flow_index            = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009f2b2: 9818         	ldr	r0, [sp, #0x60]
7009f2b4: 6840         	ldr	r0, [r0, #0x4]
7009f2b6: 991c         	ldr	r1, [sp, #0x70]
7009f2b8: 4408         	add	r0, r1
7009f2ba: f8ad 0042    	strh.w	r0, [sp, #0x42]
;         rmFlowReq.rx_einfo_present      = flowPrms->einfoPresent;
7009f2be: 981b         	ldr	r0, [sp, #0x6c]
7009f2c0: 7900         	ldrb	r0, [r0, #0x4]
7009f2c2: f88d 0044    	strb.w	r0, [sp, #0x44]
;         rmFlowReq.rx_psinfo_present     = flowPrms->psInfoPresent;
7009f2c6: 981b         	ldr	r0, [sp, #0x6c]
7009f2c8: 7940         	ldrb	r0, [r0, #0x5]
7009f2ca: f88d 0045    	strb.w	r0, [sp, #0x45]
;         rmFlowReq.rx_error_handling     = flowPrms->errorHandling;
7009f2ce: 981b         	ldr	r0, [sp, #0x6c]
7009f2d0: 7980         	ldrb	r0, [r0, #0x6]
7009f2d2: f88d 0046    	strb.w	r0, [sp, #0x46]
;         rmFlowReq.rx_desc_type          = flowPrms->descType;
7009f2d6: 981b         	ldr	r0, [sp, #0x6c]
7009f2d8: 79c0         	ldrb	r0, [r0, #0x7]
7009f2da: f88d 0047    	strb.w	r0, [sp, #0x47]
;         rmFlowReq.rx_ps_location        = flowPrms->psLocation;
7009f2de: 981b         	ldr	r0, [sp, #0x6c]
7009f2e0: 7a00         	ldrb	r0, [r0, #0x8]
7009f2e2: f88d 005c    	strb.w	r0, [sp, #0x5c]
;         rmFlowReq.rx_sop_offset         = flowPrms->sopOffset;
7009f2e6: 981b         	ldr	r0, [sp, #0x6c]
7009f2e8: 8940         	ldrh	r0, [r0, #0xa]
7009f2ea: f8ad 0048    	strh.w	r0, [sp, #0x48]
;         rmFlowReq.rx_dest_qnum          = flowPrms->defaultRxCQ;
7009f2ee: 981b         	ldr	r0, [sp, #0x6c]
7009f2f0: 8980         	ldrh	r0, [r0, #0xc]
7009f2f2: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;         rmFlowReq.rx_src_tag_hi         = flowPrms->srcTagHi;
7009f2f6: 981b         	ldr	r0, [sp, #0x6c]
7009f2f8: 7b80         	ldrb	r0, [r0, #0xe]
7009f2fa: f88d 004c    	strb.w	r0, [sp, #0x4c]
;         rmFlowReq.rx_src_tag_lo         = flowPrms->srcTagLo;
7009f2fe: 981b         	ldr	r0, [sp, #0x6c]
7009f300: 7bc0         	ldrb	r0, [r0, #0xf]
7009f302: f88d 004d    	strb.w	r0, [sp, #0x4d]
;         rmFlowReq.rx_src_tag_hi_sel     = flowPrms->srcTagHiSel;
7009f306: 981b         	ldr	r0, [sp, #0x6c]
7009f308: 7c00         	ldrb	r0, [r0, #0x10]
7009f30a: f88d 0050    	strb.w	r0, [sp, #0x50]
;         rmFlowReq.rx_src_tag_lo_sel     = flowPrms->srcTagLoSel;
7009f30e: 981b         	ldr	r0, [sp, #0x6c]
7009f310: 7c40         	ldrb	r0, [r0, #0x11]
7009f312: f88d 0051    	strb.w	r0, [sp, #0x51]
;         rmFlowReq.rx_dest_tag_hi        = flowPrms->destTagHi;
7009f316: 981b         	ldr	r0, [sp, #0x6c]
7009f318: 7c80         	ldrb	r0, [r0, #0x12]
7009f31a: f88d 004e    	strb.w	r0, [sp, #0x4e]
;         rmFlowReq.rx_dest_tag_lo        = flowPrms->destTagLo;
7009f31e: 981b         	ldr	r0, [sp, #0x6c]
7009f320: 7cc0         	ldrb	r0, [r0, #0x13]
7009f322: f88d 004f    	strb.w	r0, [sp, #0x4f]
;         rmFlowReq.rx_dest_tag_hi_sel    = flowPrms->destTagHiSel;
7009f326: 981b         	ldr	r0, [sp, #0x6c]
7009f328: 7d00         	ldrb	r0, [r0, #0x14]
7009f32a: f88d 0052    	strb.w	r0, [sp, #0x52]
;         rmFlowReq.rx_dest_tag_lo_sel    = flowPrms->destTagLoSel;
7009f32e: 981b         	ldr	r0, [sp, #0x6c]
7009f330: 7d40         	ldrb	r0, [r0, #0x15]
7009f332: f88d 0053    	strb.w	r0, [sp, #0x53]
;         rmFlowReq.rx_fdq0_sz0_qnum      = flowPrms->fdq0Sz0Qnum;
7009f336: 981b         	ldr	r0, [sp, #0x6c]
7009f338: 8b00         	ldrh	r0, [r0, #0x18]
7009f33a: f8ad 0054    	strh.w	r0, [sp, #0x54]
;         rmFlowReq.rx_fdq1_qnum          = flowPrms->fdq1Qnum;
7009f33e: 981b         	ldr	r0, [sp, #0x6c]
7009f340: 8b40         	ldrh	r0, [r0, #0x1a]
7009f342: f8ad 0056    	strh.w	r0, [sp, #0x56]
;         rmFlowReq.rx_fdq2_qnum          = flowPrms->fdq2Qnum;
7009f346: 981b         	ldr	r0, [sp, #0x6c]
7009f348: 8b80         	ldrh	r0, [r0, #0x1c]
7009f34a: f8ad 0058    	strh.w	r0, [sp, #0x58]
;         rmFlowReq.rx_fdq3_qnum          = flowPrms->fdq3Qnum;
7009f34e: 981b         	ldr	r0, [sp, #0x6c]
7009f350: 8bc0         	ldrh	r0, [r0, #0x1e]
7009f352: f8ad 005a    	strh.w	r0, [sp, #0x5a]
7009f356: a80d         	add	r0, sp, #0x34
7009f358: a90b         	add	r1, sp, #0x2c
7009f35a: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapFlowCfg(
7009f35e: f00d fa5f    	bl	0x700ac820 <Sciclient_rmUdmapFlowCfg> @ imm = #0xd4be
7009f362: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009f364: 981a         	ldr	r0, [sp, #0x68]
7009f366: b108         	cbz	r0, 0x7009f36c <Udma_flowConfig+0x15c> @ imm = #0x2
7009f368: e7ff         	b	0x7009f36a <Udma_flowConfig+0x15a> @ imm = #-0x2
;         }
7009f36a: e7ff         	b	0x7009f36c <Udma_flowConfig+0x15c> @ imm = #-0x2
7009f36c: 207f         	movs	r0, #0x7f
;         rmOptFlowReq.valid_params       = TISCI_MSG_VALUE_RM_UDMAP_FLOW_SIZE_THRESH0_VALID |
7009f36e: 9005         	str	r0, [sp, #0x14]
;         rmOptFlowReq.nav_id             = drvHandle->devIdUdma;
7009f370: 9819         	ldr	r0, [sp, #0x64]
7009f372: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009f376: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmOptFlowReq.flow_index         = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009f37a: 9818         	ldr	r0, [sp, #0x60]
7009f37c: 6840         	ldr	r0, [r0, #0x4]
7009f37e: 991c         	ldr	r1, [sp, #0x70]
7009f380: 4408         	add	r0, r1
7009f382: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         rmOptFlowReq.rx_size_thresh0    = (flowPrms->sizeThresh0 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f386: 981b         	ldr	r0, [sp, #0x6c]
7009f388: 8c00         	ldrh	r0, [r0, #0x20]
7009f38a: 0940         	lsrs	r0, r0, #0x5
7009f38c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmOptFlowReq.rx_size_thresh1    = (flowPrms->sizeThresh1 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f390: 981b         	ldr	r0, [sp, #0x6c]
7009f392: 8c40         	ldrh	r0, [r0, #0x22]
7009f394: 0940         	lsrs	r0, r0, #0x5
7009f396: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmOptFlowReq.rx_size_thresh2    = (flowPrms->sizeThresh2 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f39a: 981b         	ldr	r0, [sp, #0x6c]
7009f39c: 8c80         	ldrh	r0, [r0, #0x24]
7009f39e: 0940         	lsrs	r0, r0, #0x5
7009f3a0: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmOptFlowReq.rx_fdq0_sz1_qnum   = flowPrms->fdq0Sz1Qnum;
7009f3a4: 981b         	ldr	r0, [sp, #0x6c]
7009f3a6: 8cc0         	ldrh	r0, [r0, #0x26]
7009f3a8: f8ad 0022    	strh.w	r0, [sp, #0x22]
;         rmOptFlowReq.rx_fdq0_sz2_qnum   = flowPrms->fdq0Sz2Qnum;
7009f3ac: 981b         	ldr	r0, [sp, #0x6c]
7009f3ae: 8d00         	ldrh	r0, [r0, #0x28]
7009f3b0: f8ad 0024    	strh.w	r0, [sp, #0x24]
;         rmOptFlowReq.rx_fdq0_sz3_qnum   = flowPrms->fdq0Sz3Qnum;
7009f3b4: 981b         	ldr	r0, [sp, #0x6c]
7009f3b6: 8d40         	ldrh	r0, [r0, #0x2a]
7009f3b8: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmOptFlowReq.rx_size_thresh_en  = flowPrms->sizeThreshEn;
7009f3bc: 981b         	ldr	r0, [sp, #0x6c]
7009f3be: 7d80         	ldrb	r0, [r0, #0x16]
7009f3c0: f88d 0028    	strb.w	r0, [sp, #0x28]
7009f3c4: a803         	add	r0, sp, #0xc
7009f3c6: a901         	add	r1, sp, #0x4
7009f3c8: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal += Sciclient_rmUdmapFlowSizeThreshCfg(
7009f3cc: f00d fa58    	bl	0x700ac880 <Sciclient_rmUdmapFlowSizeThreshCfg> @ imm = #0xd4b0
7009f3d0: 4601         	mov	r1, r0
7009f3d2: 981a         	ldr	r0, [sp, #0x68]
7009f3d4: 4408         	add	r0, r1
7009f3d6: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009f3d8: 981a         	ldr	r0, [sp, #0x68]
7009f3da: b108         	cbz	r0, 0x7009f3e0 <Udma_flowConfig+0x1d0> @ imm = #0x2
7009f3dc: e7ff         	b	0x7009f3de <Udma_flowConfig+0x1ce> @ imm = #-0x2
;         }
7009f3de: e7ff         	b	0x7009f3e0 <Udma_flowConfig+0x1d0> @ imm = #-0x2
;     }
7009f3e0: e7ff         	b	0x7009f3e2 <Udma_flowConfig+0x1d2> @ imm = #-0x2
;     return (retVal);
7009f3e2: 981a         	ldr	r0, [sp, #0x68]
7009f3e4: b01e         	add	sp, #0x78
7009f3e6: bd80         	pop	{r7, pc}

7009f3e8 <__udivsi3>:
7009f3e8: e3510001     	cmp	r1, #1
7009f3ec: 3a00000b     	blo	0x7009f420 <__udivsi3+0x38> @ imm = #0x2c
7009f3f0: 012fff1e     	bxeq	lr
7009f3f4: e1500001     	cmp	r0, r1
7009f3f8: 33a00000     	movlo	r0, #0
7009f3fc: 312fff1e     	bxlo	lr
7009f400: e16fcf10     	clz	r12, r0
7009f404: e16f3f11     	clz	r3, r1
7009f408: e043300c     	sub	r3, r3, r12
7009f40c: e28fce19     	add	r12, pc, #400
7009f410: e04cc103     	sub	r12, r12, r3, lsl #2
7009f414: e04cc183     	sub	r12, r12, r3, lsl #3
7009f418: e3a03000     	mov	r3, #0
7009f41c: e12fff1c     	bx	r12
7009f420: e3b00000     	movs	r0, #0
7009f424: e92d4080     	push	{r7, lr}
7009f428: eb004238     	bl	0x700afd10 <__aeabi_idiv0> @ imm = #0x108e0
7009f42c: e8bd8080     	pop	{r7, pc}
7009f430: e1500f81     	cmp	r0, r1, lsl #31
7009f434: 22833102     	addhs	r3, r3, #-2147483648
7009f438: 20400f81     	subhs	r0, r0, r1, lsl #31
7009f43c: e1500f01     	cmp	r0, r1, lsl #30
7009f440: 22833101     	addhs	r3, r3, #1073741824
7009f444: 20400f01     	subhs	r0, r0, r1, lsl #30
7009f448: e1500e81     	cmp	r0, r1, lsl #29
7009f44c: 22833202     	addhs	r3, r3, #536870912
7009f450: 20400e81     	subhs	r0, r0, r1, lsl #29
7009f454: e1500e01     	cmp	r0, r1, lsl #28
7009f458: 22833201     	addhs	r3, r3, #268435456
7009f45c: 20400e01     	subhs	r0, r0, r1, lsl #28
7009f460: e1500d81     	cmp	r0, r1, lsl #27
7009f464: 22833302     	addhs	r3, r3, #134217728
7009f468: 20400d81     	subhs	r0, r0, r1, lsl #27
7009f46c: e1500d01     	cmp	r0, r1, lsl #26
7009f470: 22833301     	addhs	r3, r3, #67108864
7009f474: 20400d01     	subhs	r0, r0, r1, lsl #26
7009f478: e1500c81     	cmp	r0, r1, lsl #25
7009f47c: 22833402     	addhs	r3, r3, #33554432
7009f480: 20400c81     	subhs	r0, r0, r1, lsl #25
7009f484: e1500c01     	cmp	r0, r1, lsl #24
7009f488: 22833401     	addhs	r3, r3, #16777216
7009f48c: 20400c01     	subhs	r0, r0, r1, lsl #24
7009f490: e1500b81     	cmp	r0, r1, lsl #23
7009f494: 22833502     	addhs	r3, r3, #8388608
7009f498: 20400b81     	subhs	r0, r0, r1, lsl #23
7009f49c: e1500b01     	cmp	r0, r1, lsl #22
7009f4a0: 22833501     	addhs	r3, r3, #4194304
7009f4a4: 20400b01     	subhs	r0, r0, r1, lsl #22
7009f4a8: e1500a81     	cmp	r0, r1, lsl #21
7009f4ac: 22833602     	addhs	r3, r3, #2097152
7009f4b0: 20400a81     	subhs	r0, r0, r1, lsl #21
7009f4b4: e1500a01     	cmp	r0, r1, lsl #20
7009f4b8: 22833601     	addhs	r3, r3, #1048576
7009f4bc: 20400a01     	subhs	r0, r0, r1, lsl #20
7009f4c0: e1500981     	cmp	r0, r1, lsl #19
7009f4c4: 22833702     	addhs	r3, r3, #524288
7009f4c8: 20400981     	subhs	r0, r0, r1, lsl #19
7009f4cc: e1500901     	cmp	r0, r1, lsl #18
7009f4d0: 22833701     	addhs	r3, r3, #262144
7009f4d4: 20400901     	subhs	r0, r0, r1, lsl #18
7009f4d8: e1500881     	cmp	r0, r1, lsl #17
7009f4dc: 22833802     	addhs	r3, r3, #131072
7009f4e0: 20400881     	subhs	r0, r0, r1, lsl #17
7009f4e4: e1500801     	cmp	r0, r1, lsl #16
7009f4e8: 22833801     	addhs	r3, r3, #65536
7009f4ec: 20400801     	subhs	r0, r0, r1, lsl #16
7009f4f0: e1500781     	cmp	r0, r1, lsl #15
7009f4f4: 22833902     	addhs	r3, r3, #32768
7009f4f8: 20400781     	subhs	r0, r0, r1, lsl #15
7009f4fc: e1500701     	cmp	r0, r1, lsl #14
7009f500: 22833901     	addhs	r3, r3, #16384
7009f504: 20400701     	subhs	r0, r0, r1, lsl #14
7009f508: e1500681     	cmp	r0, r1, lsl #13
7009f50c: 22833a02     	addhs	r3, r3, #8192
7009f510: 20400681     	subhs	r0, r0, r1, lsl #13
7009f514: e1500601     	cmp	r0, r1, lsl #12
7009f518: 22833a01     	addhs	r3, r3, #4096
7009f51c: 20400601     	subhs	r0, r0, r1, lsl #12
7009f520: e1500581     	cmp	r0, r1, lsl #11
7009f524: 22833b02     	addhs	r3, r3, #2048
7009f528: 20400581     	subhs	r0, r0, r1, lsl #11
7009f52c: e1500501     	cmp	r0, r1, lsl #10
7009f530: 22833b01     	addhs	r3, r3, #1024
7009f534: 20400501     	subhs	r0, r0, r1, lsl #10
7009f538: e1500481     	cmp	r0, r1, lsl #9
7009f53c: 22833c02     	addhs	r3, r3, #512
7009f540: 20400481     	subhs	r0, r0, r1, lsl #9
7009f544: e1500401     	cmp	r0, r1, lsl #8
7009f548: 22833c01     	addhs	r3, r3, #256
7009f54c: 20400401     	subhs	r0, r0, r1, lsl #8
7009f550: e1500381     	cmp	r0, r1, lsl #7
7009f554: 22833080     	addhs	r3, r3, #128
7009f558: 20400381     	subhs	r0, r0, r1, lsl #7
7009f55c: e1500301     	cmp	r0, r1, lsl #6
7009f560: 22833040     	addhs	r3, r3, #64
7009f564: 20400301     	subhs	r0, r0, r1, lsl #6
7009f568: e1500281     	cmp	r0, r1, lsl #5
7009f56c: 22833020     	addhs	r3, r3, #32
7009f570: 20400281     	subhs	r0, r0, r1, lsl #5
7009f574: e1500201     	cmp	r0, r1, lsl #4
7009f578: 22833010     	addhs	r3, r3, #16
7009f57c: 20400201     	subhs	r0, r0, r1, lsl #4
7009f580: e1500181     	cmp	r0, r1, lsl #3
7009f584: 22833008     	addhs	r3, r3, #8
7009f588: 20400181     	subhs	r0, r0, r1, lsl #3
7009f58c: e1500101     	cmp	r0, r1, lsl #2
7009f590: 22833004     	addhs	r3, r3, #4
7009f594: 20400101     	subhs	r0, r0, r1, lsl #2
7009f598: e1500081     	cmp	r0, r1, lsl #1
7009f59c: 22833002     	addhs	r3, r3, #2
7009f5a0: 20400081     	subhs	r0, r0, r1, lsl #1
7009f5a4: e1500001     	cmp	r0, r1
7009f5a8: 22833001     	addhs	r3, r3, #1
7009f5ac: 20400001     	subhs	r0, r0, r1
7009f5b0: e1a00003     	mov	r0, r3
7009f5b4: e12fff1e     	bx	lr
		...

7009f5c0 <SOC_moduleSetClockFrequency>:
; {
7009f5c0: b580         	push	{r7, lr}
7009f5c2: b090         	sub	sp, #0x40
7009f5c4: 900f         	str	r0, [sp, #0x3c]
7009f5c6: 910e         	str	r1, [sp, #0x38]
7009f5c8: 930d         	str	r3, [sp, #0x34]
7009f5ca: 920c         	str	r2, [sp, #0x30]
7009f5cc: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009f5ce: 9002         	str	r0, [sp, #0x8]
7009f5d0: 900b         	str	r0, [sp, #0x2c]
;     uint32_t i = 0U;
7009f5d2: 900a         	str	r0, [sp, #0x28]
;     uint64_t respClkRate = 0;
7009f5d4: 9009         	str	r0, [sp, #0x24]
7009f5d6: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009f5d8: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009f5da: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009f5dc: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009f5de: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009f5e0: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009f5e2: 980f         	ldr	r0, [sp, #0x3c]
;                                             clkId,
7009f5e4: 990e         	ldr	r1, [sp, #0x38]
7009f5e6: aa05         	add	r2, sp, #0x14
7009f5e8: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009f5ec: f009 fe08    	bl	0x700a9200 <Sciclient_pmModuleGetClkStatus> @ imm = #0x9c10
7009f5f0: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009f5f2: 980b         	ldr	r0, [sp, #0x2c]
7009f5f4: b948         	cbnz	r0, 0x7009f60a <SOC_moduleSetClockFrequency+0x4a> @ imm = #0x12
7009f5f6: e7ff         	b	0x7009f5f8 <SOC_moduleSetClockFrequency+0x38> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009f5f8: 980f         	ldr	r0, [sp, #0x3c]
;                                                    clkId,
7009f5fa: 990e         	ldr	r1, [sp, #0x38]
7009f5fc: aa07         	add	r2, sp, #0x1c
7009f5fe: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009f602: f008 fedd    	bl	0x700a83c0 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x8dba
7009f606: 900b         	str	r0, [sp, #0x2c]
;     }
7009f608: e7ff         	b	0x7009f60a <SOC_moduleSetClockFrequency+0x4a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f60a: 980b         	ldr	r0, [sp, #0x2c]
7009f60c: b970         	cbnz	r0, 0x7009f62c <SOC_moduleSetClockFrequency+0x6c> @ imm = #0x1c
7009f60e: e7ff         	b	0x7009f610 <SOC_moduleSetClockFrequency+0x50> @ imm = #-0x2
;         if(numParents > 1U)
7009f610: 9807         	ldr	r0, [sp, #0x1c]
7009f612: 2802         	cmp	r0, #0x2
7009f614: d309         	blo	0x7009f62a <SOC_moduleSetClockFrequency+0x6a> @ imm = #0x12
7009f616: e7ff         	b	0x7009f618 <SOC_moduleSetClockFrequency+0x58> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009f618: 980f         	ldr	r0, [sp, #0x3c]
;                                                     clkId,
7009f61a: 990e         	ldr	r1, [sp, #0x38]
7009f61c: aa04         	add	r2, sp, #0x10
7009f61e: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009f622: f009 fc0d    	bl	0x700a8e40 <Sciclient_pmGetModuleClkParent> @ imm = #0x981a
7009f626: 900b         	str	r0, [sp, #0x2c]
;         }
7009f628: e7ff         	b	0x7009f62a <SOC_moduleSetClockFrequency+0x6a> @ imm = #-0x2
;     }
7009f62a: e7ff         	b	0x7009f62c <SOC_moduleSetClockFrequency+0x6c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f62c: 980b         	ldr	r0, [sp, #0x2c]
7009f62e: b960         	cbnz	r0, 0x7009f64a <SOC_moduleSetClockFrequency+0x8a> @ imm = #0x18
7009f630: e7ff         	b	0x7009f632 <SOC_moduleSetClockFrequency+0x72> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009f632: 980f         	ldr	r0, [sp, #0x3c]
;                                               clkId,
7009f634: 990e         	ldr	r1, [sp, #0x38]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009f636: 466b         	mov	r3, sp
7009f638: f04f 32ff    	mov.w	r2, #0xffffffff
7009f63c: 601a         	str	r2, [r3]
7009f63e: 2300         	movs	r3, #0x0
7009f640: 461a         	mov	r2, r3
7009f642: f00a fbb5    	bl	0x700a9db0 <Sciclient_pmModuleClkRequest> @ imm = #0xa76a
7009f646: 900b         	str	r0, [sp, #0x2c]
;     }
7009f648: e7ff         	b	0x7009f64a <SOC_moduleSetClockFrequency+0x8a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f64a: 980b         	ldr	r0, [sp, #0x2c]
7009f64c: 2800         	cmp	r0, #0x0
7009f64e: d14d         	bne	0x7009f6ec <SOC_moduleSetClockFrequency+0x12c> @ imm = #0x9a
7009f650: e7ff         	b	0x7009f652 <SOC_moduleSetClockFrequency+0x92> @ imm = #-0x2
7009f652: 2000         	movs	r0, #0x0
;         foundParent = 0U;
7009f654: 9003         	str	r0, [sp, #0xc]
;         for(i=0U;i<numParents;i++)
7009f656: 900a         	str	r0, [sp, #0x28]
7009f658: e7ff         	b	0x7009f65a <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x2
7009f65a: 980a         	ldr	r0, [sp, #0x28]
7009f65c: 9907         	ldr	r1, [sp, #0x1c]
7009f65e: 4288         	cmp	r0, r1
7009f660: d243         	bhs	0x7009f6ea <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x86
7009f662: e7ff         	b	0x7009f664 <SOC_moduleSetClockFrequency+0xa4> @ imm = #-0x2
;             if (numParents > 1U)
7009f664: 9807         	ldr	r0, [sp, #0x1c]
7009f666: 2802         	cmp	r0, #0x2
7009f668: d311         	blo	0x7009f68e <SOC_moduleSetClockFrequency+0xce> @ imm = #0x22
7009f66a: e7ff         	b	0x7009f66c <SOC_moduleSetClockFrequency+0xac> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009f66c: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009f66e: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkId+i+1,
7009f670: 9a0a         	ldr	r2, [sp, #0x28]
7009f672: 440a         	add	r2, r1
7009f674: 3201         	adds	r2, #0x1
7009f676: f04f 33ff    	mov.w	r3, #0xffffffff
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009f67a: f009 fc31    	bl	0x700a8ee0 <Sciclient_pmSetModuleClkParent> @ imm = #0x9862
7009f67e: 900b         	str	r0, [sp, #0x2c]
;                 if (status == SystemP_SUCCESS)
7009f680: 980b         	ldr	r0, [sp, #0x2c]
7009f682: b918         	cbnz	r0, 0x7009f68c <SOC_moduleSetClockFrequency+0xcc> @ imm = #0x6
7009f684: e7ff         	b	0x7009f686 <SOC_moduleSetClockFrequency+0xc6> @ imm = #-0x2
7009f686: 2001         	movs	r0, #0x1
;                     moduleClockParentChanged = 1U;
7009f688: 9006         	str	r0, [sp, #0x18]
;                 }
7009f68a: e7ff         	b	0x7009f68c <SOC_moduleSetClockFrequency+0xcc> @ imm = #-0x2
;             }
7009f68c: e7ff         	b	0x7009f68e <SOC_moduleSetClockFrequency+0xce> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009f68e: 980b         	ldr	r0, [sp, #0x2c]
7009f690: b988         	cbnz	r0, 0x7009f6b6 <SOC_moduleSetClockFrequency+0xf6> @ imm = #0x22
7009f692: e7ff         	b	0x7009f694 <SOC_moduleSetClockFrequency+0xd4> @ imm = #-0x2
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009f694: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009f696: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkRate,
7009f698: 9a0c         	ldr	r2, [sp, #0x30]
7009f69a: 9b0d         	ldr	r3, [sp, #0x34]
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009f69c: 46ee         	mov	lr, sp
7009f69e: f04f 3cff    	mov.w	r12, #0xffffffff
7009f6a2: f8ce c004    	str.w	r12, [lr, #0x4]
7009f6a6: f10d 0c20    	add.w	r12, sp, #0x20
7009f6aa: f8ce c000    	str.w	r12, [lr]
7009f6ae: f003 fe77    	bl	0x700a33a0 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x3cee
7009f6b2: 900b         	str	r0, [sp, #0x2c]
;             }
7009f6b4: e7ff         	b	0x7009f6b6 <SOC_moduleSetClockFrequency+0xf6> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009f6b6: 980b         	ldr	r0, [sp, #0x2c]
7009f6b8: b970         	cbnz	r0, 0x7009f6d8 <SOC_moduleSetClockFrequency+0x118> @ imm = #0x1c
7009f6ba: e7ff         	b	0x7009f6bc <SOC_moduleSetClockFrequency+0xfc> @ imm = #-0x2
;                 if(respClkRate == clkRate)
7009f6bc: 9808         	ldr	r0, [sp, #0x20]
7009f6be: 9909         	ldr	r1, [sp, #0x24]
7009f6c0: 9a0c         	ldr	r2, [sp, #0x30]
7009f6c2: 9b0d         	ldr	r3, [sp, #0x34]
7009f6c4: 4059         	eors	r1, r3
7009f6c6: ea80 0002    	eor.w	r0, r0, r2
7009f6ca: 4308         	orrs	r0, r1
7009f6cc: b918         	cbnz	r0, 0x7009f6d6 <SOC_moduleSetClockFrequency+0x116> @ imm = #0x6
7009f6ce: e7ff         	b	0x7009f6d0 <SOC_moduleSetClockFrequency+0x110> @ imm = #-0x2
7009f6d0: 2001         	movs	r0, #0x1
;                     foundParent = 1U;
7009f6d2: 9003         	str	r0, [sp, #0xc]
;                 }
7009f6d4: e7ff         	b	0x7009f6d6 <SOC_moduleSetClockFrequency+0x116> @ imm = #-0x2
;             }
7009f6d6: e7ff         	b	0x7009f6d8 <SOC_moduleSetClockFrequency+0x118> @ imm = #-0x2
;             if(foundParent)
7009f6d8: 9803         	ldr	r0, [sp, #0xc]
7009f6da: b108         	cbz	r0, 0x7009f6e0 <SOC_moduleSetClockFrequency+0x120> @ imm = #0x2
7009f6dc: e7ff         	b	0x7009f6de <SOC_moduleSetClockFrequency+0x11e> @ imm = #-0x2
;                 break; /* found a parent to set clock frequency, rebak form the loop */
7009f6de: e004         	b	0x7009f6ea <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x8
;         }
7009f6e0: e7ff         	b	0x7009f6e2 <SOC_moduleSetClockFrequency+0x122> @ imm = #-0x2
;         for(i=0U;i<numParents;i++)
7009f6e2: 980a         	ldr	r0, [sp, #0x28]
7009f6e4: 3001         	adds	r0, #0x1
7009f6e6: 900a         	str	r0, [sp, #0x28]
7009f6e8: e7b7         	b	0x7009f65a <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x92
;     }
7009f6ea: e7ff         	b	0x7009f6ec <SOC_moduleSetClockFrequency+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f6ec: 980b         	ldr	r0, [sp, #0x2c]
7009f6ee: b9d0         	cbnz	r0, 0x7009f726 <SOC_moduleSetClockFrequency+0x166> @ imm = #0x34
7009f6f0: e7ff         	b	0x7009f6f2 <SOC_moduleSetClockFrequency+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009f6f2: 9803         	ldr	r0, [sp, #0xc]
7009f6f4: 2801         	cmp	r0, #0x1
7009f6f6: d111         	bne	0x7009f71c <SOC_moduleSetClockFrequency+0x15c> @ imm = #0x22
7009f6f8: e7ff         	b	0x7009f6fa <SOC_moduleSetClockFrequency+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009f6fa: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009f6fc: 990e         	ldr	r1, [sp, #0x38]
;                                                   clkRate,
7009f6fe: 9a0c         	ldr	r2, [sp, #0x30]
7009f700: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009f702: 46ee         	mov	lr, sp
7009f704: f04f 3cff    	mov.w	r12, #0xffffffff
7009f708: f8ce c004    	str.w	r12, [lr, #0x4]
7009f70c: f44f 7c00    	mov.w	r12, #0x200
7009f710: f8ce c000    	str.w	r12, [lr]
7009f714: f005 fafc    	bl	0x700a4d10 <Sciclient_pmSetModuleClkFreq> @ imm = #0x55f8
7009f718: 900b         	str	r0, [sp, #0x2c]
;         }
7009f71a: e003         	b	0x7009f724 <SOC_moduleSetClockFrequency+0x164> @ imm = #0x6
7009f71c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009f720: 900b         	str	r0, [sp, #0x2c]
7009f722: e7ff         	b	0x7009f724 <SOC_moduleSetClockFrequency+0x164> @ imm = #-0x2
;     }
7009f724: e7ff         	b	0x7009f726 <SOC_moduleSetClockFrequency+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f726: 980b         	ldr	r0, [sp, #0x2c]
7009f728: b988         	cbnz	r0, 0x7009f74e <SOC_moduleSetClockFrequency+0x18e> @ imm = #0x22
7009f72a: e7ff         	b	0x7009f72c <SOC_moduleSetClockFrequency+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009f72c: 9805         	ldr	r0, [sp, #0x14]
7009f72e: b968         	cbnz	r0, 0x7009f74c <SOC_moduleSetClockFrequency+0x18c> @ imm = #0x1a
7009f730: e7ff         	b	0x7009f732 <SOC_moduleSetClockFrequency+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009f732: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009f734: 990e         	ldr	r1, [sp, #0x38]
;                                                   clockStatus,
7009f736: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009f738: 46ec         	mov	r12, sp
7009f73a: f04f 33ff    	mov.w	r3, #0xffffffff
7009f73e: f8cc 3000    	str.w	r3, [r12]
7009f742: 2300         	movs	r3, #0x0
7009f744: f00a fb34    	bl	0x700a9db0 <Sciclient_pmModuleClkRequest> @ imm = #0xa668
7009f748: 900b         	str	r0, [sp, #0x2c]
;         }
7009f74a: e7ff         	b	0x7009f74c <SOC_moduleSetClockFrequency+0x18c> @ imm = #-0x2
;     }
7009f74c: e7ff         	b	0x7009f74e <SOC_moduleSetClockFrequency+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009f74e: 980b         	ldr	r0, [sp, #0x2c]
7009f750: b168         	cbz	r0, 0x7009f76e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #0x1a
7009f752: e7ff         	b	0x7009f754 <SOC_moduleSetClockFrequency+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009f754: 9806         	ldr	r0, [sp, #0x18]
7009f756: 2801         	cmp	r0, #0x1
7009f758: d108         	bne	0x7009f76c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #0x10
7009f75a: e7ff         	b	0x7009f75c <SOC_moduleSetClockFrequency+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009f75c: 980f         	ldr	r0, [sp, #0x3c]
;                                            clkId,
7009f75e: 990e         	ldr	r1, [sp, #0x38]
;                                            origParent,
7009f760: 9a04         	ldr	r2, [sp, #0x10]
7009f762: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009f766: f009 fbbb    	bl	0x700a8ee0 <Sciclient_pmSetModuleClkParent> @ imm = #0x9776
;         }
7009f76a: e7ff         	b	0x7009f76c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #-0x2
;     }
7009f76c: e7ff         	b	0x7009f76e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #-0x2
;     return status;
7009f76e: 980b         	ldr	r0, [sp, #0x2c]
7009f770: b010         	add	sp, #0x40
7009f772: bd80         	pop	{r7, pc}
		...

7009f780 <SOC_moduleSetClockFrequencyWithParent>:
; {
7009f780: b580         	push	{r7, lr}
7009f782: b092         	sub	sp, #0x48
7009f784: 460b         	mov	r3, r1
7009f786: 4684         	mov	r12, r0
7009f788: 9915         	ldr	r1, [sp, #0x54]
7009f78a: 9814         	ldr	r0, [sp, #0x50]
7009f78c: f8cd c044    	str.w	r12, [sp, #0x44]
7009f790: 9310         	str	r3, [sp, #0x40]
7009f792: 920f         	str	r2, [sp, #0x3c]
7009f794: 910d         	str	r1, [sp, #0x34]
7009f796: 900c         	str	r0, [sp, #0x30]
7009f798: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009f79a: 9002         	str	r0, [sp, #0x8]
7009f79c: 900b         	str	r0, [sp, #0x2c]
;     uint64_t respClkRate = 0;
7009f79e: 9009         	str	r0, [sp, #0x24]
7009f7a0: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009f7a2: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009f7a4: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009f7a6: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009f7a8: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009f7aa: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009f7ac: 9811         	ldr	r0, [sp, #0x44]
;                                             clkId,
7009f7ae: 9910         	ldr	r1, [sp, #0x40]
7009f7b0: aa05         	add	r2, sp, #0x14
7009f7b2: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009f7b6: f009 fd23    	bl	0x700a9200 <Sciclient_pmModuleGetClkStatus> @ imm = #0x9a46
7009f7ba: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009f7bc: 980b         	ldr	r0, [sp, #0x2c]
7009f7be: b948         	cbnz	r0, 0x7009f7d4 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #0x12
7009f7c0: e7ff         	b	0x7009f7c2 <SOC_moduleSetClockFrequencyWithParent+0x42> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009f7c2: 9811         	ldr	r0, [sp, #0x44]
;                                                    clkId,
7009f7c4: 9910         	ldr	r1, [sp, #0x40]
7009f7c6: aa07         	add	r2, sp, #0x1c
7009f7c8: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009f7cc: f008 fdf8    	bl	0x700a83c0 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x8bf0
7009f7d0: 900b         	str	r0, [sp, #0x2c]
;     }
7009f7d2: e7ff         	b	0x7009f7d4 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f7d4: 980b         	ldr	r0, [sp, #0x2c]
7009f7d6: b970         	cbnz	r0, 0x7009f7f6 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #0x1c
7009f7d8: e7ff         	b	0x7009f7da <SOC_moduleSetClockFrequencyWithParent+0x5a> @ imm = #-0x2
;         if(numParents > 1U)
7009f7da: 9807         	ldr	r0, [sp, #0x1c]
7009f7dc: 2802         	cmp	r0, #0x2
7009f7de: d309         	blo	0x7009f7f4 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #0x12
7009f7e0: e7ff         	b	0x7009f7e2 <SOC_moduleSetClockFrequencyWithParent+0x62> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009f7e2: 9811         	ldr	r0, [sp, #0x44]
;                                                     clkId,
7009f7e4: 9910         	ldr	r1, [sp, #0x40]
7009f7e6: aa04         	add	r2, sp, #0x10
7009f7e8: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009f7ec: f009 fb28    	bl	0x700a8e40 <Sciclient_pmGetModuleClkParent> @ imm = #0x9650
7009f7f0: 900b         	str	r0, [sp, #0x2c]
;         }
7009f7f2: e7ff         	b	0x7009f7f4 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #-0x2
;     }
7009f7f4: e7ff         	b	0x7009f7f6 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f7f6: 980b         	ldr	r0, [sp, #0x2c]
7009f7f8: b960         	cbnz	r0, 0x7009f814 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #0x18
7009f7fa: e7ff         	b	0x7009f7fc <SOC_moduleSetClockFrequencyWithParent+0x7c> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009f7fc: 9811         	ldr	r0, [sp, #0x44]
;                                               clkId,
7009f7fe: 9910         	ldr	r1, [sp, #0x40]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009f800: 466b         	mov	r3, sp
7009f802: f04f 32ff    	mov.w	r2, #0xffffffff
7009f806: 601a         	str	r2, [r3]
7009f808: 2300         	movs	r3, #0x0
7009f80a: 461a         	mov	r2, r3
7009f80c: f00a fad0    	bl	0x700a9db0 <Sciclient_pmModuleClkRequest> @ imm = #0xa5a0
7009f810: 900b         	str	r0, [sp, #0x2c]
;     }
7009f812: e7ff         	b	0x7009f814 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f814: 980b         	ldr	r0, [sp, #0x2c]
7009f816: b960         	cbnz	r0, 0x7009f832 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #0x18
7009f818: e7ff         	b	0x7009f81a <SOC_moduleSetClockFrequencyWithParent+0x9a> @ imm = #-0x2
;         if (clkParent > (clkId + numParents))
7009f81a: 980f         	ldr	r0, [sp, #0x3c]
7009f81c: 9910         	ldr	r1, [sp, #0x40]
7009f81e: 9a07         	ldr	r2, [sp, #0x1c]
7009f820: 4411         	add	r1, r2
7009f822: 4288         	cmp	r0, r1
7009f824: d904         	bls	0x7009f830 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #0x8
7009f826: e7ff         	b	0x7009f828 <SOC_moduleSetClockFrequencyWithParent+0xa8> @ imm = #-0x2
7009f828: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009f82c: 900b         	str	r0, [sp, #0x2c]
;         }
7009f82e: e7ff         	b	0x7009f830 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #-0x2
;     }
7009f830: e7ff         	b	0x7009f832 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f832: 980b         	ldr	r0, [sp, #0x2c]
7009f834: b9a8         	cbnz	r0, 0x7009f862 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #0x2a
7009f836: e7ff         	b	0x7009f838 <SOC_moduleSetClockFrequencyWithParent+0xb8> @ imm = #-0x2
;         if (clkParent != origParent)
7009f838: 980f         	ldr	r0, [sp, #0x3c]
7009f83a: 9904         	ldr	r1, [sp, #0x10]
7009f83c: 4288         	cmp	r0, r1
7009f83e: d00f         	beq	0x7009f860 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #0x1e
7009f840: e7ff         	b	0x7009f842 <SOC_moduleSetClockFrequencyWithParent+0xc2> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009f842: 9811         	ldr	r0, [sp, #0x44]
;                                                         clkId,
7009f844: 9910         	ldr	r1, [sp, #0x40]
;                                                         clkParent,
7009f846: 9a0f         	ldr	r2, [sp, #0x3c]
7009f848: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009f84c: f009 fb48    	bl	0x700a8ee0 <Sciclient_pmSetModuleClkParent> @ imm = #0x9690
7009f850: 900b         	str	r0, [sp, #0x2c]
;             if (status == SystemP_SUCCESS)
7009f852: 980b         	ldr	r0, [sp, #0x2c]
7009f854: b918         	cbnz	r0, 0x7009f85e <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #0x6
7009f856: e7ff         	b	0x7009f858 <SOC_moduleSetClockFrequencyWithParent+0xd8> @ imm = #-0x2
7009f858: 2001         	movs	r0, #0x1
;                 moduleClockParentChanged = 1U;
7009f85a: 9006         	str	r0, [sp, #0x18]
;             }
7009f85c: e7ff         	b	0x7009f85e <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #-0x2
;         }
7009f85e: e7ff         	b	0x7009f860 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #-0x2
;     }
7009f860: e7ff         	b	0x7009f862 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f862: 980b         	ldr	r0, [sp, #0x2c]
7009f864: b988         	cbnz	r0, 0x7009f88a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #0x22
7009f866: e7ff         	b	0x7009f868 <SOC_moduleSetClockFrequencyWithParent+0xe8> @ imm = #-0x2
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009f868: 9811         	ldr	r0, [sp, #0x44]
;                                                 clkId,
7009f86a: 9910         	ldr	r1, [sp, #0x40]
;                                                 clkRate,
7009f86c: 9a0c         	ldr	r2, [sp, #0x30]
7009f86e: 9b0d         	ldr	r3, [sp, #0x34]
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009f870: 46ee         	mov	lr, sp
7009f872: f04f 3cff    	mov.w	r12, #0xffffffff
7009f876: f8ce c004    	str.w	r12, [lr, #0x4]
7009f87a: f10d 0c20    	add.w	r12, sp, #0x20
7009f87e: f8ce c000    	str.w	r12, [lr]
7009f882: f003 fd8d    	bl	0x700a33a0 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x3b1a
7009f886: 900b         	str	r0, [sp, #0x2c]
;     }
7009f888: e7ff         	b	0x7009f88a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f88a: 980b         	ldr	r0, [sp, #0x2c]
7009f88c: b970         	cbnz	r0, 0x7009f8ac <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #0x1c
7009f88e: e7ff         	b	0x7009f890 <SOC_moduleSetClockFrequencyWithParent+0x110> @ imm = #-0x2
;         if(respClkRate == clkRate)
7009f890: 9808         	ldr	r0, [sp, #0x20]
7009f892: 9909         	ldr	r1, [sp, #0x24]
7009f894: 9a0c         	ldr	r2, [sp, #0x30]
7009f896: 9b0d         	ldr	r3, [sp, #0x34]
7009f898: 4059         	eors	r1, r3
7009f89a: ea80 0002    	eor.w	r0, r0, r2
7009f89e: 4308         	orrs	r0, r1
7009f8a0: b918         	cbnz	r0, 0x7009f8aa <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #0x6
7009f8a2: e7ff         	b	0x7009f8a4 <SOC_moduleSetClockFrequencyWithParent+0x124> @ imm = #-0x2
7009f8a4: 2001         	movs	r0, #0x1
;             foundParent = 1U;
7009f8a6: 9003         	str	r0, [sp, #0xc]
;         }
7009f8a8: e7ff         	b	0x7009f8aa <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #-0x2
;     }
7009f8aa: e7ff         	b	0x7009f8ac <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f8ac: 980b         	ldr	r0, [sp, #0x2c]
7009f8ae: b9d0         	cbnz	r0, 0x7009f8e6 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #0x34
7009f8b0: e7ff         	b	0x7009f8b2 <SOC_moduleSetClockFrequencyWithParent+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009f8b2: 9803         	ldr	r0, [sp, #0xc]
7009f8b4: 2801         	cmp	r0, #0x1
7009f8b6: d111         	bne	0x7009f8dc <SOC_moduleSetClockFrequencyWithParent+0x15c> @ imm = #0x22
7009f8b8: e7ff         	b	0x7009f8ba <SOC_moduleSetClockFrequencyWithParent+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009f8ba: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009f8bc: 9910         	ldr	r1, [sp, #0x40]
;                                                   clkRate,
7009f8be: 9a0c         	ldr	r2, [sp, #0x30]
7009f8c0: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009f8c2: 46ee         	mov	lr, sp
7009f8c4: f04f 3cff    	mov.w	r12, #0xffffffff
7009f8c8: f8ce c004    	str.w	r12, [lr, #0x4]
7009f8cc: f44f 7c00    	mov.w	r12, #0x200
7009f8d0: f8ce c000    	str.w	r12, [lr]
7009f8d4: f005 fa1c    	bl	0x700a4d10 <Sciclient_pmSetModuleClkFreq> @ imm = #0x5438
7009f8d8: 900b         	str	r0, [sp, #0x2c]
;         }
7009f8da: e003         	b	0x7009f8e4 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #0x6
7009f8dc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009f8e0: 900b         	str	r0, [sp, #0x2c]
7009f8e2: e7ff         	b	0x7009f8e4 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #-0x2
;     }
7009f8e4: e7ff         	b	0x7009f8e6 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009f8e6: 980b         	ldr	r0, [sp, #0x2c]
7009f8e8: b988         	cbnz	r0, 0x7009f90e <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #0x22
7009f8ea: e7ff         	b	0x7009f8ec <SOC_moduleSetClockFrequencyWithParent+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009f8ec: 9805         	ldr	r0, [sp, #0x14]
7009f8ee: b968         	cbnz	r0, 0x7009f90c <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #0x1a
7009f8f0: e7ff         	b	0x7009f8f2 <SOC_moduleSetClockFrequencyWithParent+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009f8f2: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009f8f4: 9910         	ldr	r1, [sp, #0x40]
;                                                   clockStatus,
7009f8f6: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009f8f8: 46ec         	mov	r12, sp
7009f8fa: f04f 33ff    	mov.w	r3, #0xffffffff
7009f8fe: f8cc 3000    	str.w	r3, [r12]
7009f902: 2300         	movs	r3, #0x0
7009f904: f00a fa54    	bl	0x700a9db0 <Sciclient_pmModuleClkRequest> @ imm = #0xa4a8
7009f908: 900b         	str	r0, [sp, #0x2c]
;         }
7009f90a: e7ff         	b	0x7009f90c <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #-0x2
;     }
7009f90c: e7ff         	b	0x7009f90e <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009f90e: 980b         	ldr	r0, [sp, #0x2c]
7009f910: b168         	cbz	r0, 0x7009f92e <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #0x1a
7009f912: e7ff         	b	0x7009f914 <SOC_moduleSetClockFrequencyWithParent+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009f914: 9806         	ldr	r0, [sp, #0x18]
7009f916: 2801         	cmp	r0, #0x1
7009f918: d108         	bne	0x7009f92c <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #0x10
7009f91a: e7ff         	b	0x7009f91c <SOC_moduleSetClockFrequencyWithParent+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009f91c: 9811         	ldr	r0, [sp, #0x44]
;                                            clkId,
7009f91e: 9910         	ldr	r1, [sp, #0x40]
;                                            origParent,
7009f920: 9a04         	ldr	r2, [sp, #0x10]
7009f922: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009f926: f009 fadb    	bl	0x700a8ee0 <Sciclient_pmSetModuleClkParent> @ imm = #0x95b6
;         }
7009f92a: e7ff         	b	0x7009f92c <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #-0x2
;     }
7009f92c: e7ff         	b	0x7009f92e <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #-0x2
;     return status;
7009f92e: 980b         	ldr	r0, [sp, #0x2c]
7009f930: b012         	add	sp, #0x48
7009f932: bd80         	pop	{r7, pc}

7009f934 <memalign>:
7009f934: e92d4bf0     	push	{r4, r5, r6, r7, r8, r9, r11, lr}
7009f938: e59f5190     	ldr	r5, [pc, #0x190]        @ 0x7009fad0 <memalign+0x19c>
7009f93c: e3a02000     	mov	r2, #0
7009f940: e3a08000     	mov	r8, #0
7009f944: e2413001     	sub	r3, r1, #1
7009f948: e2454008     	sub	r4, r5, #8
7009f94c: e3550007     	cmp	r5, #7
7009f950: 81a02004     	movhi	r2, r4
7009f954: e1530002     	cmp	r3, r2
7009f958: 2a00005a     	bhs	0x7009fac8 <memalign+0x194> @ imm = #0x168
7009f95c: e2402001     	sub	r2, r0, #1
7009f960: e59f316c     	ldr	r3, [pc, #0x16c]        @ 0x7009fad4 <memalign+0x1a0>
7009f964: e3a07008     	mov	r7, #8
7009f968: e2816007     	add	r6, r1, #7
7009f96c: e1100002     	tst	r0, r2
7009f970: 01a07000     	moveq	r7, r0
7009f974: e3500007     	cmp	r0, #7
7009f978: e5930000     	ldr	r0, [r3]
7009f97c: e3a02008     	mov	r2, #8
7009f980: 91a07002     	movls	r7, r2
7009f984: e12fff30     	blx	r0
7009f988: e59f0148     	ldr	r0, [pc, #0x148]        @ 0x7009fad8 <memalign+0x1a4>
7009f98c: e5d01000     	ldrb	r1, [r0]
7009f990: e3510000     	cmp	r1, #0
7009f994: 1a000011     	bne	0x7009f9e0 <memalign+0xac> @ imm = #0x44
7009f998: e3a02000     	mov	r2, #0
7009f99c: e3a01000     	mov	r1, #0
7009f9a0: e3550007     	cmp	r5, #7
7009f9a4: 81a02004     	movhi	r2, r4
7009f9a8: e3520000     	cmp	r2, #0
7009f9ac: 1a000002     	bne	0x7009f9bc <memalign+0x88> @ imm = #0x8
7009f9b0: e59f2124     	ldr	r2, [pc, #0x124]        @ 0x7009fadc <memalign+0x1a8>
7009f9b4: e5821000     	str	r1, [r2]
7009f9b8: ea000006     	b	0x7009f9d8 <memalign+0xa4> @ imm = #0x18
7009f9bc: e59f211c     	ldr	r2, [pc, #0x11c]        @ 0x7009fae0 <memalign+0x1ac>
7009f9c0: e3550007     	cmp	r5, #7
7009f9c4: 91a04001     	movls	r4, r1
7009f9c8: e59f310c     	ldr	r3, [pc, #0x10c]        @ 0x7009fadc <memalign+0x1a8>
7009f9cc: e5821008     	str	r1, [r2, #0x8]
7009f9d0: e5832000     	str	r2, [r3]
7009f9d4: e5824000     	str	r4, [r2]
7009f9d8: e3a01001     	mov	r1, #1
7009f9dc: e5c01000     	strb	r1, [r0]
7009f9e0: e59f50f4     	ldr	r5, [pc, #0xf4]         @ 0x7009fadc <memalign+0x1a8>
7009f9e4: e3c69007     	bic	r9, r6, #7
7009f9e8: e2470001     	sub	r0, r7, #1
7009f9ec: e2671000     	rsb	r1, r7, #0
7009f9f0: e5956000     	ldr	r6, [r5]
7009f9f4: e3560000     	cmp	r6, #0
7009f9f8: 0a00002f     	beq	0x7009fabc <memalign+0x188> @ imm = #0xbc
7009f9fc: e2865008     	add	r5, r6, #8
7009fa00: e0802005     	add	r2, r0, r5
7009fa04: e0024001     	and	r4, r2, r1
7009fa08: e1550004     	cmp	r5, r4
7009fa0c: 0a00000c     	beq	0x7009fa44 <memalign+0x110> @ imm = #0x30
7009fa10: e2862010     	add	r2, r6, #16
7009fa14: e2443008     	sub	r3, r4, #8
7009fa18: e1520003     	cmp	r2, r3
7009fa1c: 9a000001     	bls	0x7009fa28 <memalign+0xf4> @ imm = #0x4
7009fa20: e0844007     	add	r4, r4, r7
7009fa24: eafffffa     	b	0x7009fa14 <memalign+0xe0> @ imm = #-0x18
7009fa28: e5962000     	ldr	r2, [r6]
7009fa2c: e0843009     	add	r3, r4, r9
7009fa30: e3c22001     	bic	r2, r2, #1
7009fa34: e0852002     	add	r2, r5, r2
7009fa38: e1520003     	cmp	r2, r3
7009fa3c: 3affffeb     	blo	0x7009f9f0 <memalign+0xbc> @ imm = #-0x54
7009fa40: ea000004     	b	0x7009fa58 <memalign+0x124> @ imm = #0x10
7009fa44: e5962000     	ldr	r2, [r6]
7009fa48: e3c22001     	bic	r2, r2, #1
7009fa4c: e1520009     	cmp	r2, r9
7009fa50: baffffe6     	blt	0x7009f9f0 <memalign+0xbc> @ imm = #-0x68
7009fa54: e1a04005     	mov	r4, r5
7009fa58: e1a00006     	mov	r0, r6
7009fa5c: eb003ab8     	bl	0x700ae544 <free_list_remove> @ imm = #0xeae0
7009fa60: e1540005     	cmp	r4, r5
7009fa64: 0a00000c     	beq	0x7009fa9c <memalign+0x168> @ imm = #0x30
7009fa68: e5960000     	ldr	r0, [r6]
7009fa6c: e0441005     	sub	r1, r4, r5
7009fa70: e2412008     	sub	r2, r1, #8
7009fa74: e1a04006     	mov	r4, r6
7009fa78: e3c00001     	bic	r0, r0, #1
7009fa7c: e0400001     	sub	r0, r0, r1
7009fa80: e3c21001     	bic	r1, r2, #1
7009fa84: e3800001     	orr	r0, r0, #1
7009fa88: e6842001     	str	r2, [r4], r1
7009fa8c: e5a40008     	str	r0, [r4, #0x8]!
7009fa90: e1a00006     	mov	r0, r6
7009fa94: eb00385d     	bl	0x700adc10 <free_list_insert> @ imm = #0xe174
7009fa98: e1a06004     	mov	r6, r4
7009fa9c: e1a00006     	mov	r0, r6
7009faa0: e1a01009     	mov	r1, r9
7009faa4: eb00231e     	bl	0x700a8724 <split>      @ imm = #0x8c78
7009faa8: e59f0034     	ldr	r0, [pc, #0x34]         @ 0x7009fae4 <memalign+0x1b0>
7009faac: e5900000     	ldr	r0, [r0]
7009fab0: e12fff30     	blx	r0
7009fab4: e2868008     	add	r8, r6, #8
7009fab8: ea000002     	b	0x7009fac8 <memalign+0x194> @ imm = #0x8
7009fabc: e59f0020     	ldr	r0, [pc, #0x20]         @ 0x7009fae4 <memalign+0x1b0>
7009fac0: e5900000     	ldr	r0, [r0]
7009fac4: e12fff30     	blx	r0
7009fac8: e1a00008     	mov	r0, r8
7009facc: e8bd8bf0     	pop	{r4, r5, r6, r7, r8, r9, r11, pc}
7009fad0: 00 00 01 00  	.word	0x00010000
7009fad4: c4 29 0b 70  	.word	0x700b29c4
7009fad8: 58 2a 0b 70  	.word	0x700b2a58
7009fadc: 34 51 08 70  	.word	0x70085134
7009fae0: 80 51 08 70  	.word	0x70085180
7009fae4: c8 29 0b 70  	.word	0x700b29c8
7009fae8: 00 00 00 00  	.word	0x00000000
7009faec: 00 00 00 00  	.word	0x00000000

7009faf0 <UART_close>:
; {
7009faf0: b580         	push	{r7, lr}
7009faf2: b08a         	sub	sp, #0x28
7009faf4: 9009         	str	r0, [sp, #0x24]
;     config = (UART_Config *) handle;
7009faf6: 9809         	ldr	r0, [sp, #0x24]
7009faf8: 9008         	str	r0, [sp, #0x20]
;     if ((NULL != config) && (config->object != NULL) && (config->object->isOpen != FALSE))
7009fafa: 9808         	ldr	r0, [sp, #0x20]
7009fafc: 2800         	cmp	r0, #0x0
7009fafe: f000 80ce    	beq.w	0x7009fc9e <UART_close+0x1ae> @ imm = #0x19c
7009fb02: e7ff         	b	0x7009fb04 <UART_close+0x14> @ imm = #-0x2
7009fb04: 9808         	ldr	r0, [sp, #0x20]
7009fb06: 6840         	ldr	r0, [r0, #0x4]
7009fb08: 2800         	cmp	r0, #0x0
7009fb0a: f000 80c8    	beq.w	0x7009fc9e <UART_close+0x1ae> @ imm = #0x190
7009fb0e: e7ff         	b	0x7009fb10 <UART_close+0x20> @ imm = #-0x2
7009fb10: 9808         	ldr	r0, [sp, #0x20]
7009fb12: 6840         	ldr	r0, [r0, #0x4]
7009fb14: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009fb18: 2800         	cmp	r0, #0x0
7009fb1a: f000 80c0    	beq.w	0x7009fc9e <UART_close+0x1ae> @ imm = #0x180
7009fb1e: e7ff         	b	0x7009fb20 <UART_close+0x30> @ imm = #-0x2
;         object = config->object;
7009fb20: 9808         	ldr	r0, [sp, #0x20]
7009fb22: 6840         	ldr	r0, [r0, #0x4]
7009fb24: 9007         	str	r0, [sp, #0x1c]
;         attrs = config->attrs;
7009fb26: 9808         	ldr	r0, [sp, #0x20]
7009fb28: 6800         	ldr	r0, [r0]
7009fb2a: 9006         	str	r0, [sp, #0x18]
;         object->uartLld_handle = &object->uartLld_object;
7009fb2c: 9907         	ldr	r1, [sp, #0x1c]
7009fb2e: f501 7022    	add.w	r0, r1, #0x288
7009fb32: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle = object->uartLld_handle;
7009fb36: 9807         	ldr	r0, [sp, #0x1c]
7009fb38: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009fb3c: 9005         	str	r0, [sp, #0x14]
;         DebugP_assert(NULL_PTR != object);
7009fb3e: 9807         	ldr	r0, [sp, #0x1c]
7009fb40: 2800         	cmp	r0, #0x0
7009fb42: bf18         	it	ne
7009fb44: 2001         	movne	r0, #0x1
7009fb46: f641 71ee    	movw	r1, #0x1fee
7009fb4a: f2c7 010b    	movt	r1, #0x700b
7009fb4e: 466a         	mov	r2, sp
7009fb50: 6011         	str	r1, [r2]
7009fb52: f242 0101    	movw	r1, #0x2001
7009fb56: f2c7 010b    	movt	r1, #0x700b
7009fb5a: 9101         	str	r1, [sp, #0x4]
7009fb5c: f242 1247    	movw	r2, #0x2147
7009fb60: f2c7 020b    	movt	r2, #0x700b
7009fb64: 9202         	str	r2, [sp, #0x8]
7009fb66: f240 13c5    	movw	r3, #0x1c5
7009fb6a: f00a ffb1    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xaf62
7009fb6e: 9901         	ldr	r1, [sp, #0x4]
7009fb70: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
7009fb72: 9806         	ldr	r0, [sp, #0x18]
7009fb74: 2800         	cmp	r0, #0x0
7009fb76: bf18         	it	ne
7009fb78: 2001         	movne	r0, #0x1
7009fb7a: f242 0337    	movw	r3, #0x2037
7009fb7e: f2c7 030b    	movt	r3, #0x700b
7009fb82: 46ec         	mov	r12, sp
7009fb84: f8cc 3000    	str.w	r3, [r12]
7009fb88: f44f 73e3    	mov.w	r3, #0x1c6
7009fb8c: f00a ffa0    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xaf40
7009fb90: 9901         	ldr	r1, [sp, #0x4]
7009fb92: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009fb94: f242 7328    	movw	r3, #0x2728
7009fb98: f2c7 030b    	movt	r3, #0x700b
7009fb9c: f853 0b04    	ldr	r0, [r3], #4
7009fba0: 9303         	str	r3, [sp, #0xc]
7009fba2: 2800         	cmp	r0, #0x0
7009fba4: bf18         	it	ne
7009fba6: 2001         	movne	r0, #0x1
7009fba8: f641 53c4    	movw	r3, #0x1dc4
7009fbac: f2c7 030b    	movt	r3, #0x700b
7009fbb0: 46ec         	mov	r12, sp
7009fbb2: f8cc 3000    	str.w	r3, [r12]
7009fbb6: f44f 73e4    	mov.w	r3, #0x1c8
7009fbba: f00a ff89    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xaf12
7009fbbe: 9803         	ldr	r0, [sp, #0xc]
7009fbc0: f04f 31ff    	mov.w	r1, #0xffffffff
;         (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009fbc4: f00a fd2c    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0xaa58
;         UART_flushTxFifo(handle);
7009fbc8: 9809         	ldr	r0, [sp, #0x24]
7009fbca: f007 fb51    	bl	0x700a7270 <UART_flushTxFifo> @ imm = #0x76a2
;         UART_intrDisable(attrs->baseAddr,
7009fbce: 9806         	ldr	r0, [sp, #0x18]
7009fbd0: 6800         	ldr	r0, [r0]
7009fbd2: 2107         	movs	r1, #0x7
7009fbd4: 9104         	str	r1, [sp, #0x10]
7009fbd6: f006 fae3    	bl	0x700a61a0 <UART_intrDisable> @ imm = #0x65c6
;         UART_intr2Disable(attrs->baseAddr, UART_INT2_TX_EMPTY);
7009fbda: 9806         	ldr	r0, [sp, #0x18]
7009fbdc: 6800         	ldr	r0, [r0]
7009fbde: 2102         	movs	r1, #0x2
7009fbe0: f00f f87e    	bl	0x700aece0 <UART_intr2Disable> @ imm = #0xf0fc
7009fbe4: 9904         	ldr	r1, [sp, #0x10]
;         (void)UART_operatingModeSelect(attrs->baseAddr, UART_OPER_MODE_DISABLED);
7009fbe6: 9806         	ldr	r0, [sp, #0x18]
7009fbe8: 6800         	ldr	r0, [r0]
7009fbea: f00f f8c1    	bl	0x700aed70 <UART_operatingModeSelect> @ imm = #0xf182
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009fbee: 9807         	ldr	r0, [sp, #0x1c]
7009fbf0: 6b00         	ldr	r0, [r0, #0x30]
7009fbf2: 2803         	cmp	r0, #0x3
7009fbf4: d104         	bne	0x7009fc00 <UART_close+0x110> @ imm = #0x8
7009fbf6: e7ff         	b	0x7009fbf8 <UART_close+0x108> @ imm = #-0x2
;             (void)UART_lld_deInitDma(uartLld_handle);
7009fbf8: 9805         	ldr	r0, [sp, #0x14]
7009fbfa: f00b ff89    	bl	0x700abb10 <UART_lld_deInitDma> @ imm = #0xbf12
;         }
7009fbfe: e003         	b	0x7009fc08 <UART_close+0x118> @ imm = #0x6
;             (void)UART_lld_deInit(uartLld_handle);
7009fc00: 9805         	ldr	r0, [sp, #0x14]
7009fc02: f00c fc5d    	bl	0x700ac4c0 <UART_lld_deInit> @ imm = #0xc8ba
7009fc06: e7ff         	b	0x7009fc08 <UART_close+0x118> @ imm = #-0x2
;         if(NULL != object->lock)
7009fc08: 9807         	ldr	r0, [sp, #0x1c]
7009fc0a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009fc0e: b148         	cbz	r0, 0x7009fc24 <UART_close+0x134> @ imm = #0x12
7009fc10: e7ff         	b	0x7009fc12 <UART_close+0x122> @ imm = #-0x2
;             SemaphoreP_destruct(&object->lockObj);
7009fc12: 9807         	ldr	r0, [sp, #0x1c]
7009fc14: 308c         	adds	r0, #0x8c
7009fc16: f00f fe2b    	bl	0x700af870 <SemaphoreP_destruct> @ imm = #0xfc56
;             object->lock = NULL;
7009fc1a: 9907         	ldr	r1, [sp, #0x1c]
7009fc1c: 2000         	movs	r0, #0x0
7009fc1e: f8c1 0088    	str.w	r0, [r1, #0x88]
;         }
7009fc22: e7ff         	b	0x7009fc24 <UART_close+0x134> @ imm = #-0x2
;         if(NULL != object->readTransferSem)
7009fc24: 9807         	ldr	r0, [sp, #0x1c]
7009fc26: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009fc2a: b160         	cbz	r0, 0x7009fc46 <UART_close+0x156> @ imm = #0x18
7009fc2c: e7ff         	b	0x7009fc2e <UART_close+0x13e> @ imm = #-0x2
;             SemaphoreP_destruct(&object->readTransferSemObj);
7009fc2e: 9807         	ldr	r0, [sp, #0x1c]
7009fc30: f500 7094    	add.w	r0, r0, #0x128
7009fc34: f00f fe1c    	bl	0x700af870 <SemaphoreP_destruct> @ imm = #0xfc38
;             object->readTransferSem = NULL;
7009fc38: 9907         	ldr	r1, [sp, #0x1c]
7009fc3a: 2000         	movs	r0, #0x0
7009fc3c: f8c1 0124    	str.w	r0, [r1, #0x124]
;             uartLld_handle->readTransferMutex = NULL;
7009fc40: 9905         	ldr	r1, [sp, #0x14]
7009fc42: 6588         	str	r0, [r1, #0x58]
;         }
7009fc44: e7ff         	b	0x7009fc46 <UART_close+0x156> @ imm = #-0x2
;         if(NULL != object->writeTransferSem)
7009fc46: 9807         	ldr	r0, [sp, #0x1c]
7009fc48: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009fc4c: b160         	cbz	r0, 0x7009fc68 <UART_close+0x178> @ imm = #0x18
7009fc4e: e7ff         	b	0x7009fc50 <UART_close+0x160> @ imm = #-0x2
;             SemaphoreP_destruct(&object->writeTransferSemObj);
7009fc50: 9807         	ldr	r0, [sp, #0x1c]
7009fc52: f500 70e2    	add.w	r0, r0, #0x1c4
7009fc56: f00f fe0b    	bl	0x700af870 <SemaphoreP_destruct> @ imm = #0xfc16
;             object->writeTransferSem = NULL;
7009fc5a: 9907         	ldr	r1, [sp, #0x1c]
7009fc5c: 2000         	movs	r0, #0x0
7009fc5e: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;             uartLld_handle->writeTransferMutex = NULL;
7009fc62: 9905         	ldr	r1, [sp, #0x14]
7009fc64: 65c8         	str	r0, [r1, #0x5c]
;         }
7009fc66: e7ff         	b	0x7009fc68 <UART_close+0x178> @ imm = #-0x2
;         if(NULL != object->hwiHandle)
7009fc68: 9807         	ldr	r0, [sp, #0x1c]
7009fc6a: f8d0 025c    	ldr.w	r0, [r0, #0x25c]
7009fc6e: b150         	cbz	r0, 0x7009fc86 <UART_close+0x196> @ imm = #0x14
7009fc70: e7ff         	b	0x7009fc72 <UART_close+0x182> @ imm = #-0x2
;             HwiP_destruct(&object->hwiObj);
7009fc72: 9807         	ldr	r0, [sp, #0x1c]
7009fc74: f500 7018    	add.w	r0, r0, #0x260
7009fc78: f010 fa62    	bl	0x700b0140 <HwiP_destruct> @ imm = #0x104c4
;             object->hwiHandle = NULL;
7009fc7c: 9907         	ldr	r1, [sp, #0x1c]
7009fc7e: 2000         	movs	r0, #0x0
7009fc80: f8c1 025c    	str.w	r0, [r1, #0x25c]
;         }
7009fc84: e7ff         	b	0x7009fc86 <UART_close+0x196> @ imm = #-0x2
;         object->isOpen = FALSE;
7009fc86: 9907         	ldr	r1, [sp, #0x1c]
7009fc88: 2000         	movs	r0, #0x0
7009fc8a: f8c1 0084    	str.w	r0, [r1, #0x84]
;         SemaphoreP_post(&gUartDrvObj.lockObj);
7009fc8e: f242 7028    	movw	r0, #0x2728
7009fc92: f2c7 000b    	movt	r0, #0x700b
7009fc96: 3004         	adds	r0, #0x4
7009fc98: f00c f88a    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0xc114
;     }
7009fc9c: e7ff         	b	0x7009fc9e <UART_close+0x1ae> @ imm = #-0x2
;     return;
7009fc9e: b00a         	add	sp, #0x28
7009fca0: bd80         	pop	{r7, pc}
7009fca2: 0000         	movs	r0, r0

7009fca4 <free>:
7009fca4: e3500000     	cmp	r0, #0
7009fca8: 012fff1e     	bxeq	lr
7009fcac: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
7009fcb0: e1a04000     	mov	r4, r0
7009fcb4: e59f0188     	ldr	r0, [pc, #0x188]        @ 0x7009fe44 <free+0x1a0>
7009fcb8: e5900000     	ldr	r0, [r0]
7009fcbc: e12fff30     	blx	r0
7009fcc0: e59f0180     	ldr	r0, [pc, #0x180]        @ 0x7009fe48 <free+0x1a4>
7009fcc4: e2444008     	sub	r4, r4, #8
7009fcc8: e3a05000     	mov	r5, #0
7009fccc: e5901000     	ldr	r1, [r0]
7009fcd0: e1500004     	cmp	r0, r4
7009fcd4: e3c12001     	bic	r2, r1, #1
7009fcd8: 2a000004     	bhs	0x7009fcf0 <free+0x4c>  @ imm = #0x10
7009fcdc: e0801002     	add	r1, r0, r2
7009fce0: e1a05000     	mov	r5, r0
7009fce4: e2811008     	add	r1, r1, #8
7009fce8: e1a00001     	mov	r0, r1
7009fcec: eafffff6     	b	0x7009fccc <free+0x28>  @ imm = #-0x28
7009fcf0: e59f3150     	ldr	r3, [pc, #0x150]        @ 0x7009fe48 <free+0x1a4>
7009fcf4: e0802002     	add	r2, r0, r2
7009fcf8: e59f714c     	ldr	r7, [pc, #0x14c]        @ 0x7009fe4c <free+0x1a8>
7009fcfc: e2826008     	add	r6, r2, #8
7009fd00: e0872003     	add	r2, r7, r3
7009fd04: e3570007     	cmp	r7, #7
7009fd08: 82423008     	subhi	r3, r2, #8
7009fd0c: e1560003     	cmp	r6, r3
7009fd10: 83006000     	movwhi	r6, #0x0
7009fd14: e1500004     	cmp	r0, r4
7009fd18: 1a000045     	bne	0x7009fe34 <free+0x190> @ imm = #0x114
7009fd1c: e2110001     	ands	r0, r1, #1
7009fd20: 0a000043     	beq	0x7009fe34 <free+0x190> @ imm = #0x10c
7009fd24: e3550000     	cmp	r5, #0
7009fd28: 0a000009     	beq	0x7009fd54 <free+0xb0>  @ imm = #0x24
7009fd2c: e5951000     	ldr	r1, [r5]
7009fd30: e3a00000     	mov	r0, #0
7009fd34: e3a07000     	mov	r7, #0
7009fd38: e2111001     	ands	r1, r1, #1
7009fd3c: 01a00005     	moveq	r0, r5
7009fd40: e3560000     	cmp	r6, #0
7009fd44: 1a000005     	bne	0x7009fd60 <free+0xbc>  @ imm = #0x14
7009fd48: e3510000     	cmp	r1, #0
7009fd4c: 0a00000b     	beq	0x7009fd80 <free+0xdc>  @ imm = #0x2c
7009fd50: ea000022     	b	0x7009fde0 <free+0x13c> @ imm = #0x88
7009fd54: e3a00000     	mov	r0, #0
7009fd58: e3560000     	cmp	r6, #0
7009fd5c: 0a00001f     	beq	0x7009fde0 <free+0x13c> @ imm = #0x7c
7009fd60: e5d61000     	ldrb	r1, [r6]
7009fd64: e3a07000     	mov	r7, #0
7009fd68: e3a08000     	mov	r8, #0
7009fd6c: e3110001     	tst	r1, #1
7009fd70: 01a07006     	moveq	r7, r6
7009fd74: e3500000     	cmp	r0, #0
7009fd78: 0a000007     	beq	0x7009fd9c <free+0xf8>  @ imm = #0x1c
7009fd7c: e1a05000     	mov	r5, r0
7009fd80: e1a00005     	mov	r0, r5
7009fd84: eb0039ee     	bl	0x700ae544 <free_list_remove> @ imm = #0xe7b8
7009fd88: e3a08001     	mov	r8, #1
7009fd8c: e3570000     	cmp	r7, #0
7009fd90: 0a00001d     	beq	0x7009fe0c <free+0x168> @ imm = #0x74
7009fd94: e1a06007     	mov	r6, r7
7009fd98: ea000002     	b	0x7009fda8 <free+0x104> @ imm = #0x8
7009fd9c: e3a05000     	mov	r5, #0
7009fda0: e3570000     	cmp	r7, #0
7009fda4: 0a00000d     	beq	0x7009fde0 <free+0x13c> @ imm = #0x34
7009fda8: e1a00006     	mov	r0, r6
7009fdac: eb0039e4     	bl	0x700ae544 <free_list_remove> @ imm = #0xe790
7009fdb0: e3580000     	cmp	r8, #0
7009fdb4: 0a00000c     	beq	0x7009fdec <free+0x148> @ imm = #0x30
7009fdb8: e5950000     	ldr	r0, [r5]
7009fdbc: e5941000     	ldr	r1, [r4]
7009fdc0: e5962000     	ldr	r2, [r6]
7009fdc4: e2800010     	add	r0, r0, #16
7009fdc8: e3c11001     	bic	r1, r1, #1
7009fdcc: e3c00001     	bic	r0, r0, #1
7009fdd0: e3c22001     	bic	r2, r2, #1
7009fdd4: e0800001     	add	r0, r0, r1
7009fdd8: e0800002     	add	r0, r0, r2
7009fddc: ea000010     	b	0x7009fe24 <free+0x180> @ imm = #0x40
7009fde0: e5940000     	ldr	r0, [r4]
7009fde4: e3c00001     	bic	r0, r0, #1
7009fde8: ea000005     	b	0x7009fe04 <free+0x160> @ imm = #0x14
7009fdec: e5940000     	ldr	r0, [r4]
7009fdf0: e5961000     	ldr	r1, [r6]
7009fdf4: e2800008     	add	r0, r0, #8
7009fdf8: e3c11001     	bic	r1, r1, #1
7009fdfc: e3c00001     	bic	r0, r0, #1
7009fe00: e0800001     	add	r0, r0, r1
7009fe04: e5840000     	str	r0, [r4]
7009fe08: ea000007     	b	0x7009fe2c <free+0x188> @ imm = #0x1c
7009fe0c: e5950000     	ldr	r0, [r5]
7009fe10: e5941000     	ldr	r1, [r4]
7009fe14: e2800008     	add	r0, r0, #8
7009fe18: e3c11001     	bic	r1, r1, #1
7009fe1c: e3c00001     	bic	r0, r0, #1
7009fe20: e0800001     	add	r0, r0, r1
7009fe24: e1a04005     	mov	r4, r5
7009fe28: e5850000     	str	r0, [r5]
7009fe2c: e1a00004     	mov	r0, r4
7009fe30: eb003776     	bl	0x700adc10 <free_list_insert> @ imm = #0xddd8
7009fe34: e59f0014     	ldr	r0, [pc, #0x14]         @ 0x7009fe50 <free+0x1ac>
7009fe38: e5900000     	ldr	r0, [r0]
7009fe3c: e8bd41f0     	pop	{r4, r5, r6, r7, r8, lr}
7009fe40: e12fff10     	bx	r0
7009fe44: c4 29 0b 70  	.word	0x700b29c4
7009fe48: 80 51 08 70  	.word	0x70085180
7009fe4c: 00 00 01 00  	.word	0x00010000
7009fe50: c8 29 0b 70  	.word	0x700b29c8
7009fe54: 00 00 00 00  	.word	0x00000000
7009fe58: 00 00 00 00  	.word	0x00000000
7009fe5c: 00 00 00 00  	.word	0x00000000

7009fe60 <UART_lld_controllerIsr>:
; {
7009fe60: b580         	push	{r7, lr}
7009fe62: b086         	sub	sp, #0x18
7009fe64: 9005         	str	r0, [sp, #0x14]
7009fe66: 2001         	movs	r0, #0x1
;     uint32_t            retVal = TRUE;
7009fe68: 9001         	str	r0, [sp, #0x4]
;     if(NULL != args)
7009fe6a: 9805         	ldr	r0, [sp, #0x14]
7009fe6c: 2800         	cmp	r0, #0x0
7009fe6e: f000 80c8    	beq.w	0x700a0002 <UART_lld_controllerIsr+0x1a2> @ imm = #0x190
7009fe72: e7ff         	b	0x7009fe74 <UART_lld_controllerIsr+0x14> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
7009fe74: 9805         	ldr	r0, [sp, #0x14]
7009fe76: 9002         	str	r0, [sp, #0x8]
;         while (retVal == TRUE)
7009fe78: e7ff         	b	0x7009fe7a <UART_lld_controllerIsr+0x1a> @ imm = #-0x2
7009fe7a: 9801         	ldr	r0, [sp, #0x4]
7009fe7c: 2801         	cmp	r0, #0x1
7009fe7e: f040 80bf    	bne.w	0x700a0000 <UART_lld_controllerIsr+0x1a0> @ imm = #0x17e
7009fe82: e7ff         	b	0x7009fe84 <UART_lld_controllerIsr+0x24> @ imm = #-0x2
;             intType = UART_getIntrIdentityStatus(hUart->baseAddr);
7009fe84: 9802         	ldr	r0, [sp, #0x8]
7009fe86: 6800         	ldr	r0, [r0]
7009fe88: f00d faba    	bl	0x700ad400 <UART_getIntrIdentityStatus> @ imm = #0xd574
7009fe8c: 9004         	str	r0, [sp, #0x10]
;             if ((intType & UART_INTID_RX_THRES_REACH) == UART_INTID_RX_THRES_REACH)
7009fe8e: f89d 0010    	ldrb.w	r0, [sp, #0x10]
7009fe92: 0740         	lsls	r0, r0, #0x1d
7009fe94: 2800         	cmp	r0, #0x0
7009fe96: d561         	bpl	0x7009ff5c <UART_lld_controllerIsr+0xfc> @ imm = #0xc2
7009fe98: e7ff         	b	0x7009fe9a <UART_lld_controllerIsr+0x3a> @ imm = #-0x2
;                 if ((intType & UART_INTID_RX_LINE_STAT_ERROR) ==
7009fe9a: 9804         	ldr	r0, [sp, #0x10]
7009fe9c: f000 0006    	and	r0, r0, #0x6
7009fea0: 2806         	cmp	r0, #0x6
7009fea2: d104         	bne	0x7009feae <UART_lld_controllerIsr+0x4e> @ imm = #0x8
7009fea4: e7ff         	b	0x7009fea6 <UART_lld_controllerIsr+0x46> @ imm = #-0x2
;                     (void)UART_procLineStatusErr(hUart);
7009fea6: 9802         	ldr	r0, [sp, #0x8]
7009fea8: f002 fcfa    	bl	0x700a28a0 <UART_procLineStatusErr> @ imm = #0x29f4
;                 }
7009feac: e055         	b	0x7009ff5a <UART_lld_controllerIsr+0xfa> @ imm = #0xaa
;                     if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
7009feae: 9804         	ldr	r0, [sp, #0x10]
7009feb0: f000 000c    	and	r0, r0, #0xc
7009feb4: 280c         	cmp	r0, #0xc
7009feb6: d10a         	bne	0x7009fece <UART_lld_controllerIsr+0x6e> @ imm = #0x14
7009feb8: e7ff         	b	0x7009feba <UART_lld_controllerIsr+0x5a> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009feba: 9802         	ldr	r0, [sp, #0x8]
7009febc: 6800         	ldr	r0, [r0]
7009febe: 2105         	movs	r1, #0x5
7009fec0: f006 f96e    	bl	0x700a61a0 <UART_intrDisable> @ imm = #0x62dc
;                         hUart->rxTimeoutCnt++;
7009fec4: 9902         	ldr	r1, [sp, #0x8]
7009fec6: 6a08         	ldr	r0, [r1, #0x20]
7009fec8: 3001         	adds	r0, #0x1
7009feca: 6208         	str	r0, [r1, #0x20]
;                     }
7009fecc: e7ff         	b	0x7009fece <UART_lld_controllerIsr+0x6e> @ imm = #-0x2
;                     if (hUart->readSizeRemaining > 0U)
7009fece: 9802         	ldr	r0, [sp, #0x8]
7009fed0: 69c0         	ldr	r0, [r0, #0x1c]
7009fed2: b3a8         	cbz	r0, 0x7009ff40 <UART_lld_controllerIsr+0xe0> @ imm = #0x6a
7009fed4: e7ff         	b	0x7009fed6 <UART_lld_controllerIsr+0x76> @ imm = #-0x2
;                         hUart->readSizeRemaining = UART_readData(hUart, hUart->readSizeRemaining);
7009fed6: 9802         	ldr	r0, [sp, #0x8]
7009fed8: 69c1         	ldr	r1, [r0, #0x1c]
7009feda: f00a fdb9    	bl	0x700aaa50 <UART_readData> @ imm = #0xab72
7009fede: 9902         	ldr	r1, [sp, #0x8]
7009fee0: 61c8         	str	r0, [r1, #0x1c]
;                         if ((hUart->readSizeRemaining == 0U) ||
7009fee2: 9802         	ldr	r0, [sp, #0x8]
7009fee4: 69c0         	ldr	r0, [r0, #0x1c]
7009fee6: b130         	cbz	r0, 0x7009fef6 <UART_lld_controllerIsr+0x96> @ imm = #0xc
7009fee8: e7ff         	b	0x7009feea <UART_lld_controllerIsr+0x8a> @ imm = #-0x2
;                             (hUart->hUartInit->readReturnMode == UART_READ_RETURN_MODE_PARTIAL))
7009feea: 9802         	ldr	r0, [sp, #0x8]
7009feec: 6840         	ldr	r0, [r0, #0x4]
7009feee: 6940         	ldr	r0, [r0, #0x14]
;                         if ((hUart->readSizeRemaining == 0U) ||
7009fef0: 2801         	cmp	r0, #0x1
7009fef2: d11e         	bne	0x7009ff32 <UART_lld_controllerIsr+0xd2> @ imm = #0x3c
7009fef4: e7ff         	b	0x7009fef6 <UART_lld_controllerIsr+0x96> @ imm = #-0x2
;                             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009fef6: 9802         	ldr	r0, [sp, #0x8]
7009fef8: 6800         	ldr	r0, [r0]
7009fefa: 2105         	movs	r1, #0x5
7009fefc: f006 f950    	bl	0x700a61a0 <UART_intrDisable> @ imm = #0x62a0
;                             hUart->readBuf = (uint8_t *)hUart->readBuf - hUart->readCount;
7009ff00: 9902         	ldr	r1, [sp, #0x8]
7009ff02: 6948         	ldr	r0, [r1, #0x14]
7009ff04: 698a         	ldr	r2, [r1, #0x18]
7009ff06: 1a80         	subs	r0, r0, r2
7009ff08: 6148         	str	r0, [r1, #0x14]
;                             if (hUart->readTrans.buf != NULL)
7009ff0a: 9802         	ldr	r0, [sp, #0x8]
7009ff0c: 6a80         	ldr	r0, [r0, #0x28]
7009ff0e: b138         	cbz	r0, 0x7009ff20 <UART_lld_controllerIsr+0xc0> @ imm = #0xe
7009ff10: e7ff         	b	0x7009ff12 <UART_lld_controllerIsr+0xb2> @ imm = #-0x2
;                                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
7009ff12: 9902         	ldr	r1, [sp, #0x8]
7009ff14: 6988         	ldr	r0, [r1, #0x18]
7009ff16: 62c8         	str	r0, [r1, #0x2c]
;                                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
7009ff18: 9902         	ldr	r1, [sp, #0x8]
7009ff1a: 2000         	movs	r0, #0x0
7009ff1c: 6348         	str	r0, [r1, #0x34]
;                             }
7009ff1e: e7ff         	b	0x7009ff20 <UART_lld_controllerIsr+0xc0> @ imm = #-0x2
;                             hUart->hUartInit->readCompleteCallbackFxn(hUart);
7009ff20: 9802         	ldr	r0, [sp, #0x8]
7009ff22: 6841         	ldr	r1, [r0, #0x4]
7009ff24: 6dc9         	ldr	r1, [r1, #0x5c]
7009ff26: 4788         	blx	r1
;                             UART_lld_Transaction_deInit(&hUart->readTrans);
7009ff28: 9802         	ldr	r0, [sp, #0x8]
7009ff2a: 3028         	adds	r0, #0x28
7009ff2c: f00f fa78    	bl	0x700af420 <UART_lld_Transaction_deInit> @ imm = #0xf4f0
;                         }
7009ff30: e005         	b	0x7009ff3e <UART_lld_controllerIsr+0xde> @ imm = #0xa
;                             UART_intrEnable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009ff32: 9802         	ldr	r0, [sp, #0x8]
7009ff34: 6800         	ldr	r0, [r0]
7009ff36: 2105         	movs	r1, #0x5
7009ff38: f006 f852    	bl	0x700a5fe0 <UART_intrEnable> @ imm = #0x60a4
7009ff3c: e7ff         	b	0x7009ff3e <UART_lld_controllerIsr+0xde> @ imm = #-0x2
;                     }
7009ff3e: e00b         	b	0x7009ff58 <UART_lld_controllerIsr+0xf8> @ imm = #0x16
;                         (void)UART_getChar(hUart->baseAddr, &rdData);
7009ff40: 9802         	ldr	r0, [sp, #0x8]
7009ff42: 6800         	ldr	r0, [r0]
7009ff44: f10d 010f    	add.w	r1, sp, #0xf
7009ff48: f00c f99a    	bl	0x700ac280 <UART_getChar> @ imm = #0xc334
;                         UART_intrDisable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009ff4c: 9802         	ldr	r0, [sp, #0x8]
7009ff4e: 6800         	ldr	r0, [r0]
7009ff50: 2105         	movs	r1, #0x5
7009ff52: f006 f925    	bl	0x700a61a0 <UART_intrDisable> @ imm = #0x624a
7009ff56: e7ff         	b	0x7009ff58 <UART_lld_controllerIsr+0xf8> @ imm = #-0x2
7009ff58: e7ff         	b	0x7009ff5a <UART_lld_controllerIsr+0xfa> @ imm = #-0x2
;             }
7009ff5a: e050         	b	0x7009fffe <UART_lld_controllerIsr+0x19e> @ imm = #0xa0
;             else if ((intType & UART_INTID_TX_THRES_REACH) == UART_INTID_TX_THRES_REACH)
7009ff5c: f89d 0010    	ldrb.w	r0, [sp, #0x10]
7009ff60: 0780         	lsls	r0, r0, #0x1e
7009ff62: 2800         	cmp	r0, #0x0
7009ff64: d534         	bpl	0x7009ffd0 <UART_lld_controllerIsr+0x170> @ imm = #0x68
7009ff66: e7ff         	b	0x7009ff68 <UART_lld_controllerIsr+0x108> @ imm = #-0x2
;                 if (hUart->writeSizeRemaining > 0U)
7009ff68: 9802         	ldr	r0, [sp, #0x8]
7009ff6a: 6900         	ldr	r0, [r0, #0x10]
7009ff6c: b348         	cbz	r0, 0x7009ffc2 <UART_lld_controllerIsr+0x162> @ imm = #0x52
7009ff6e: e7ff         	b	0x7009ff70 <UART_lld_controllerIsr+0x110> @ imm = #-0x2
;                     hUart->writeSizeRemaining = (uint32_t)UART_writeData(hUart, (hUart->writeSizeRemaining));
7009ff70: 9802         	ldr	r0, [sp, #0x8]
7009ff72: 6901         	ldr	r1, [r0, #0x10]
7009ff74: f00c f9b4    	bl	0x700ac2e0 <UART_writeData> @ imm = #0xc368
7009ff78: 9902         	ldr	r1, [sp, #0x8]
7009ff7a: 6108         	str	r0, [r1, #0x10]
;                     if ((hUart->writeSizeRemaining) == 0U)
7009ff7c: 9802         	ldr	r0, [sp, #0x8]
7009ff7e: 6900         	ldr	r0, [r0, #0x10]
7009ff80: b9f0         	cbnz	r0, 0x7009ffc0 <UART_lld_controllerIsr+0x160> @ imm = #0x3c
7009ff82: e7ff         	b	0x7009ff84 <UART_lld_controllerIsr+0x124> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
7009ff84: 9802         	ldr	r0, [sp, #0x8]
7009ff86: 6800         	ldr	r0, [r0]
7009ff88: 2102         	movs	r1, #0x2
7009ff8a: f006 f909    	bl	0x700a61a0 <UART_intrDisable> @ imm = #0x6212
;                         hUart->writeBuf = (const void *)((uint8_t *)hUart->writeBuf - hUart->writeCount);
7009ff8e: 9902         	ldr	r1, [sp, #0x8]
7009ff90: 6888         	ldr	r0, [r1, #0x8]
7009ff92: 68ca         	ldr	r2, [r1, #0xc]
7009ff94: 1a80         	subs	r0, r0, r2
7009ff96: 6088         	str	r0, [r1, #0x8]
;                         if (hUart->writeTrans.buf != NULL)
7009ff98: 9802         	ldr	r0, [sp, #0x8]
7009ff9a: 6bc0         	ldr	r0, [r0, #0x3c]
7009ff9c: b138         	cbz	r0, 0x7009ffae <UART_lld_controllerIsr+0x14e> @ imm = #0xe
7009ff9e: e7ff         	b	0x7009ffa0 <UART_lld_controllerIsr+0x140> @ imm = #-0x2
;                             hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
7009ffa0: 9902         	ldr	r1, [sp, #0x8]
7009ffa2: 68c8         	ldr	r0, [r1, #0xc]
7009ffa4: 6408         	str	r0, [r1, #0x40]
;                             hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
7009ffa6: 9902         	ldr	r1, [sp, #0x8]
7009ffa8: 2000         	movs	r0, #0x0
7009ffaa: 6488         	str	r0, [r1, #0x48]
;                         }
7009ffac: e7ff         	b	0x7009ffae <UART_lld_controllerIsr+0x14e> @ imm = #-0x2
;                         hUart->hUartInit->writeCompleteCallbackFxn(hUart);
7009ffae: 9802         	ldr	r0, [sp, #0x8]
7009ffb0: 6841         	ldr	r1, [r0, #0x4]
7009ffb2: 6e09         	ldr	r1, [r1, #0x60]
7009ffb4: 4788         	blx	r1
;                         UART_lld_Transaction_deInit(&hUart->writeTrans);
7009ffb6: 9802         	ldr	r0, [sp, #0x8]
7009ffb8: 303c         	adds	r0, #0x3c
7009ffba: f00f fa31    	bl	0x700af420 <UART_lld_Transaction_deInit> @ imm = #0xf462
;                     }
7009ffbe: e7ff         	b	0x7009ffc0 <UART_lld_controllerIsr+0x160> @ imm = #-0x2
;                 }
7009ffc0: e005         	b	0x7009ffce <UART_lld_controllerIsr+0x16e> @ imm = #0xa
;                     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
7009ffc2: 9802         	ldr	r0, [sp, #0x8]
7009ffc4: 6800         	ldr	r0, [r0]
7009ffc6: 2102         	movs	r1, #0x2
7009ffc8: f006 f8ea    	bl	0x700a61a0 <UART_intrDisable> @ imm = #0x61d4
7009ffcc: e7ff         	b	0x7009ffce <UART_lld_controllerIsr+0x16e> @ imm = #-0x2
;             }
7009ffce: e015         	b	0x7009fffc <UART_lld_controllerIsr+0x19c> @ imm = #0x2a
;             else if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
7009ffd0: 9804         	ldr	r0, [sp, #0x10]
7009ffd2: f000 000c    	and	r0, r0, #0xc
7009ffd6: 280c         	cmp	r0, #0xc
7009ffd8: d10c         	bne	0x7009fff4 <UART_lld_controllerIsr+0x194> @ imm = #0x18
7009ffda: e7ff         	b	0x7009ffdc <UART_lld_controllerIsr+0x17c> @ imm = #-0x2
;                 if (FALSE == UART_checkCharsAvailInFifo(hUart->baseAddr))
7009ffdc: 9802         	ldr	r0, [sp, #0x8]
7009ffde: 6800         	ldr	r0, [r0]
7009ffe0: f00d f82e    	bl	0x700ad040 <UART_checkCharsAvailInFifo> @ imm = #0xd05c
7009ffe4: b928         	cbnz	r0, 0x7009fff2 <UART_lld_controllerIsr+0x192> @ imm = #0xa
7009ffe6: e7ff         	b	0x7009ffe8 <UART_lld_controllerIsr+0x188> @ imm = #-0x2
;                     UART_i2310WA(hUart->baseAddr);
7009ffe8: 9802         	ldr	r0, [sp, #0x8]
7009ffea: 6800         	ldr	r0, [r0]
7009ffec: f00d fed0    	bl	0x700add90 <UART_i2310WA> @ imm = #0xdda0
;                 }
7009fff0: e7ff         	b	0x7009fff2 <UART_lld_controllerIsr+0x192> @ imm = #-0x2
;             }
7009fff2: e002         	b	0x7009fffa <UART_lld_controllerIsr+0x19a> @ imm = #0x4
7009fff4: 2000         	movs	r0, #0x0
;                 retVal = FALSE;
7009fff6: 9001         	str	r0, [sp, #0x4]
7009fff8: e7ff         	b	0x7009fffa <UART_lld_controllerIsr+0x19a> @ imm = #-0x2
7009fffa: e7ff         	b	0x7009fffc <UART_lld_controllerIsr+0x19c> @ imm = #-0x2
7009fffc: e7ff         	b	0x7009fffe <UART_lld_controllerIsr+0x19e> @ imm = #-0x2
;         while (retVal == TRUE)
7009fffe: e73c         	b	0x7009fe7a <UART_lld_controllerIsr+0x1a> @ imm = #-0x188
;     }
700a0000: e000         	b	0x700a0004 <UART_lld_controllerIsr+0x1a4> @ imm = #0x0
700a0002: e7ff         	b	0x700a0004 <UART_lld_controllerIsr+0x1a4> @ imm = #-0x2
; }
700a0004: b006         	add	sp, #0x18
700a0006: bd80         	pop	{r7, pc}
		...

700a0010 <UART_write>:
; {
700a0010: b580         	push	{r7, lr}
700a0012: b08e         	sub	sp, #0x38
700a0014: 900d         	str	r0, [sp, #0x34]
700a0016: 910c         	str	r1, [sp, #0x30]
700a0018: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS, semStatus = SystemP_SUCCESS;
700a001a: 900b         	str	r0, [sp, #0x2c]
700a001c: 900a         	str	r0, [sp, #0x28]
;     if ((NULL_PTR == handle) || (NULL_PTR == trans))
700a001e: 980d         	ldr	r0, [sp, #0x34]
700a0020: b118         	cbz	r0, 0x700a002a <UART_write+0x1a> @ imm = #0x6
700a0022: e7ff         	b	0x700a0024 <UART_write+0x14> @ imm = #-0x2
700a0024: 980c         	ldr	r0, [sp, #0x30]
700a0026: b920         	cbnz	r0, 0x700a0032 <UART_write+0x22> @ imm = #0x8
700a0028: e7ff         	b	0x700a002a <UART_write+0x1a> @ imm = #-0x2
700a002a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a002e: 900b         	str	r0, [sp, #0x2c]
;     }
700a0030: e7ff         	b	0x700a0032 <UART_write+0x22> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a0032: 980b         	ldr	r0, [sp, #0x2c]
700a0034: 2800         	cmp	r0, #0x0
700a0036: d141         	bne	0x700a00bc <UART_write+0xac> @ imm = #0x82
700a0038: e7ff         	b	0x700a003a <UART_write+0x2a> @ imm = #-0x2
;         config  = (UART_Config *) handle;
700a003a: 980d         	ldr	r0, [sp, #0x34]
700a003c: 9009         	str	r0, [sp, #0x24]
;         object  = config->object;
700a003e: 9809         	ldr	r0, [sp, #0x24]
700a0040: 6840         	ldr	r0, [r0, #0x4]
700a0042: 9008         	str	r0, [sp, #0x20]
;         attrs   = config->attrs;
700a0044: 9809         	ldr	r0, [sp, #0x24]
700a0046: 6800         	ldr	r0, [r0]
700a0048: 9007         	str	r0, [sp, #0x1c]
;         prms    = &config->object->prms;
700a004a: 9809         	ldr	r0, [sp, #0x24]
700a004c: 6840         	ldr	r0, [r0, #0x4]
700a004e: 3004         	adds	r0, #0x4
700a0050: 9006         	str	r0, [sp, #0x18]
;         uartLld_handle = object->uartLld_handle;
700a0052: 9808         	ldr	r0, [sp, #0x20]
700a0054: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a0058: 9004         	str	r0, [sp, #0x10]
;         object->writeTrans = trans;
700a005a: 980c         	ldr	r0, [sp, #0x30]
700a005c: 9908         	ldr	r1, [sp, #0x20]
700a005e: f8c1 0080    	str.w	r0, [r1, #0x80]
;         DebugP_assert(NULL_PTR != object);
700a0062: 9808         	ldr	r0, [sp, #0x20]
700a0064: 2800         	cmp	r0, #0x0
700a0066: bf18         	it	ne
700a0068: 2001         	movne	r0, #0x1
700a006a: f641 71ee    	movw	r1, #0x1fee
700a006e: f2c7 010b    	movt	r1, #0x700b
700a0072: 466a         	mov	r2, sp
700a0074: 6011         	str	r1, [r2]
700a0076: f242 0101    	movw	r1, #0x2001
700a007a: f2c7 010b    	movt	r1, #0x700b
700a007e: 9101         	str	r1, [sp, #0x4]
700a0080: f242 123c    	movw	r2, #0x213c
700a0084: f2c7 020b    	movt	r2, #0x700b
700a0088: 9202         	str	r2, [sp, #0x8]
700a008a: f44f 7305    	mov.w	r3, #0x214
700a008e: f00a fd1f    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xaa3e
700a0092: 9901         	ldr	r1, [sp, #0x4]
700a0094: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
700a0096: 9807         	ldr	r0, [sp, #0x1c]
700a0098: 2800         	cmp	r0, #0x0
700a009a: bf18         	it	ne
700a009c: 2001         	movne	r0, #0x1
700a009e: f242 0337    	movw	r3, #0x2037
700a00a2: f2c7 030b    	movt	r3, #0x700b
700a00a6: 46ec         	mov	r12, sp
700a00a8: f8cc 3000    	str.w	r3, [r12]
700a00ac: f240 2315    	movw	r3, #0x215
700a00b0: f00a fd0e    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xaa1c
;         extendedParams.args = trans->args;
700a00b4: 980c         	ldr	r0, [sp, #0x30]
700a00b6: 6900         	ldr	r0, [r0, #0x10]
700a00b8: 9003         	str	r0, [sp, #0xc]
;     }
700a00ba: e7ff         	b	0x700a00bc <UART_write+0xac> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a00bc: 980b         	ldr	r0, [sp, #0x2c]
700a00be: b950         	cbnz	r0, 0x700a00d6 <UART_write+0xc6> @ imm = #0x14
700a00c0: e7ff         	b	0x700a00c2 <UART_write+0xb2> @ imm = #-0x2
;         if (TRUE == prms->skipIntrReg)
700a00c2: 9806         	ldr	r0, [sp, #0x18]
700a00c4: 6b80         	ldr	r0, [r0, #0x38]
700a00c6: 2801         	cmp	r0, #0x1
700a00c8: d104         	bne	0x700a00d4 <UART_write+0xc4> @ imm = #0x8
700a00ca: e7ff         	b	0x700a00cc <UART_write+0xbc> @ imm = #-0x2
700a00cc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
700a00d0: 900b         	str	r0, [sp, #0x2c]
;         }
700a00d2: e7ff         	b	0x700a00d4 <UART_write+0xc4> @ imm = #-0x2
;     }
700a00d4: e7ff         	b	0x700a00d6 <UART_write+0xc6> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a00d6: 980b         	ldr	r0, [sp, #0x2c]
700a00d8: 2800         	cmp	r0, #0x0
700a00da: d168         	bne	0x700a01ae <UART_write+0x19e> @ imm = #0xd0
700a00dc: e7ff         	b	0x700a00de <UART_write+0xce> @ imm = #-0x2
;         key = HwiP_disable();
700a00de: f010 ec20    	blx	0x700b0920 <HwiP_disable> @ imm = #0x10840
700a00e2: 9005         	str	r0, [sp, #0x14]
;         HwiP_restore(key);
700a00e4: 9805         	ldr	r0, [sp, #0x14]
700a00e6: f010 ec3c    	blx	0x700b0960 <HwiP_restore> @ imm = #0x10878
;         uartLld_handle->state = UART_STATE_READY;
700a00ea: 9904         	ldr	r1, [sp, #0x10]
700a00ec: 2001         	movs	r0, #0x1
700a00ee: 6548         	str	r0, [r1, #0x54]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
700a00f0: 9806         	ldr	r0, [sp, #0x18]
700a00f2: 6ac0         	ldr	r0, [r0, #0x2c]
700a00f4: 2801         	cmp	r0, #0x1
700a00f6: d005         	beq	0x700a0104 <UART_write+0xf4> @ imm = #0xa
700a00f8: e7ff         	b	0x700a00fa <UART_write+0xea> @ imm = #-0x2
;             (UART_CONFIG_MODE_DMA == prms->transferMode))
700a00fa: 9806         	ldr	r0, [sp, #0x18]
700a00fc: 6ac0         	ldr	r0, [r0, #0x2c]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
700a00fe: 2803         	cmp	r0, #0x3
700a0100: d146         	bne	0x700a0190 <UART_write+0x180> @ imm = #0x8c
700a0102: e7ff         	b	0x700a0104 <UART_write+0xf4> @ imm = #-0x2
;             if (UART_CONFIG_MODE_INTERRUPT == prms->transferMode)
700a0104: 9806         	ldr	r0, [sp, #0x18]
700a0106: 6ac0         	ldr	r0, [r0, #0x2c]
700a0108: 2801         	cmp	r0, #0x1
700a010a: d109         	bne	0x700a0120 <UART_write+0x110> @ imm = #0x12
700a010c: e7ff         	b	0x700a010e <UART_write+0xfe> @ imm = #-0x2
;                 status = UART_lld_writeIntr(uartLld_handle, trans->buf, trans->count, &extendedParams);
700a010e: 9804         	ldr	r0, [sp, #0x10]
700a0110: 9a0c         	ldr	r2, [sp, #0x30]
700a0112: 6811         	ldr	r1, [r2]
700a0114: 6852         	ldr	r2, [r2, #0x4]
700a0116: ab03         	add	r3, sp, #0xc
700a0118: f006 ff72    	bl	0x700a7000 <UART_lld_writeIntr> @ imm = #0x6ee4
700a011c: 900b         	str	r0, [sp, #0x2c]
;             }
700a011e: e008         	b	0x700a0132 <UART_write+0x122> @ imm = #0x10
;                 status = UART_lld_writeDma(uartLld_handle, trans->buf, trans->count, &extendedParams);
700a0120: 9804         	ldr	r0, [sp, #0x10]
700a0122: 9a0c         	ldr	r2, [sp, #0x30]
700a0124: 6811         	ldr	r1, [r2]
700a0126: 6852         	ldr	r2, [r2, #0x4]
700a0128: ab03         	add	r3, sp, #0xc
700a012a: f006 fdc9    	bl	0x700a6cc0 <UART_lld_writeDma> @ imm = #0x6b92
700a012e: 900b         	str	r0, [sp, #0x2c]
700a0130: e7ff         	b	0x700a0132 <UART_write+0x122> @ imm = #-0x2
;             if (SystemP_SUCCESS == status)
700a0132: 980b         	ldr	r0, [sp, #0x2c]
700a0134: bb58         	cbnz	r0, 0x700a018e <UART_write+0x17e> @ imm = #0x56
700a0136: e7ff         	b	0x700a0138 <UART_write+0x128> @ imm = #-0x2
;                 if(object->prms.writeMode == UART_TRANSFER_MODE_BLOCKING)
700a0138: 9808         	ldr	r0, [sp, #0x20]
700a013a: 69c0         	ldr	r0, [r0, #0x1c]
700a013c: bb18         	cbnz	r0, 0x700a0186 <UART_write+0x176> @ imm = #0x46
700a013e: e7ff         	b	0x700a0140 <UART_write+0x130> @ imm = #-0x2
;                     semStatus = SemaphoreP_pend(&object->writeTransferSemObj, trans->timeout);
700a0140: 9808         	ldr	r0, [sp, #0x20]
700a0142: f500 70e2    	add.w	r0, r0, #0x1c4
700a0146: 990c         	ldr	r1, [sp, #0x30]
700a0148: 6889         	ldr	r1, [r1, #0x8]
700a014a: f00a fa69    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0xa4d2
700a014e: 900a         	str	r0, [sp, #0x28]
;                     if (semStatus == SystemP_SUCCESS)
700a0150: 980a         	ldr	r0, [sp, #0x28]
700a0152: b960         	cbnz	r0, 0x700a016e <UART_write+0x15e> @ imm = #0x18
700a0154: e7ff         	b	0x700a0156 <UART_write+0x146> @ imm = #-0x2
;                         if (trans->status == (uint32_t)UART_STATUS_SUCCESS)
700a0156: 980c         	ldr	r0, [sp, #0x30]
700a0158: 68c0         	ldr	r0, [r0, #0xc]
700a015a: b918         	cbnz	r0, 0x700a0164 <UART_write+0x154> @ imm = #0x6
700a015c: e7ff         	b	0x700a015e <UART_write+0x14e> @ imm = #-0x2
700a015e: 2000         	movs	r0, #0x0
;                             status = SystemP_SUCCESS;
700a0160: 900b         	str	r0, [sp, #0x2c]
;                         }
700a0162: e003         	b	0x700a016c <UART_write+0x15c> @ imm = #0x6
700a0164: f04f 30ff    	mov.w	r0, #0xffffffff
;                             status = SystemP_FAILURE;
700a0168: 900b         	str	r0, [sp, #0x2c]
700a016a: e7ff         	b	0x700a016c <UART_write+0x15c> @ imm = #-0x2
;                     }
700a016c: e00a         	b	0x700a0184 <UART_write+0x174> @ imm = #0x14
;                         trans->status = UART_TRANSFER_TIMEOUT;
700a016e: 990c         	ldr	r1, [sp, #0x30]
700a0170: f06f 0001    	mvn	r0, #0x1
700a0174: 60c8         	str	r0, [r1, #0xc]
;                         (void)UART_writeCancelNoCB(uartLld_handle);
700a0176: 9804         	ldr	r0, [sp, #0x10]
700a0178: f009 fef2    	bl	0x700a9f60 <UART_writeCancelNoCB> @ imm = #0x9de4
700a017c: f04f 30ff    	mov.w	r0, #0xffffffff
;                         status = SystemP_FAILURE;
700a0180: 900b         	str	r0, [sp, #0x2c]
700a0182: e7ff         	b	0x700a0184 <UART_write+0x174> @ imm = #-0x2
;                 }
700a0184: e002         	b	0x700a018c <UART_write+0x17c> @ imm = #0x4
700a0186: 2000         	movs	r0, #0x0
;                     status = SystemP_SUCCESS;
700a0188: 900b         	str	r0, [sp, #0x2c]
700a018a: e7ff         	b	0x700a018c <UART_write+0x17c> @ imm = #-0x2
;             }
700a018c: e7ff         	b	0x700a018e <UART_write+0x17e> @ imm = #-0x2
;         }
700a018e: e00d         	b	0x700a01ac <UART_write+0x19c> @ imm = #0x1a
;             status = UART_lld_write(uartLld_handle, trans->buf, trans->count, trans->timeout, &extendedParams);
700a0190: 9804         	ldr	r0, [sp, #0x10]
700a0192: 9b0c         	ldr	r3, [sp, #0x30]
700a0194: 6819         	ldr	r1, [r3]
700a0196: 685a         	ldr	r2, [r3, #0x4]
700a0198: 689b         	ldr	r3, [r3, #0x8]
700a019a: 46ee         	mov	lr, sp
700a019c: f10d 0c0c    	add.w	r12, sp, #0xc
700a01a0: f8ce c000    	str.w	r12, [lr]
700a01a4: f006 fa9c    	bl	0x700a66e0 <UART_lld_write> @ imm = #0x6538
700a01a8: 900b         	str	r0, [sp, #0x2c]
700a01aa: e7ff         	b	0x700a01ac <UART_write+0x19c> @ imm = #-0x2
;     }
700a01ac: e7ff         	b	0x700a01ae <UART_write+0x19e> @ imm = #-0x2
;     return (status);
700a01ae: 980b         	ldr	r0, [sp, #0x2c]
700a01b0: b00e         	add	sp, #0x38
700a01b2: bd80         	pop	{r7, pc}
		...

700a01c0 <Sciclient_rmClearInterruptRoute>:
; {
700a01c0: b580         	push	{r7, lr}
700a01c2: b08e         	sub	sp, #0x38
700a01c4: 900d         	str	r0, [sp, #0x34]
700a01c6: 910c         	str	r1, [sp, #0x30]
700a01c8: 920b         	str	r2, [sp, #0x2c]
700a01ca: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a01cc: 9001         	str	r0, [sp, #0x4]
700a01ce: 900a         	str	r0, [sp, #0x28]
700a01d0: f241 0101    	movw	r1, #0x1001
;     uint16_t messageType = TISCI_MSG_RM_IRQ_RELEASE;
700a01d4: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
700a01d8: 9008         	str	r0, [sp, #0x20]
700a01da: 9007         	str	r0, [sp, #0x1c]
700a01dc: 9006         	str	r0, [sp, #0x18]
700a01de: 9005         	str	r0, [sp, #0x14]
700a01e0: 9004         	str	r0, [sp, #0x10]
700a01e2: 9003         	str	r0, [sp, #0xc]
700a01e4: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
700a01e6: 980d         	ldr	r0, [sp, #0x34]
700a01e8: b118         	cbz	r0, 0x700a01f2 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #0x6
700a01ea: e7ff         	b	0x700a01ec <Sciclient_rmClearInterruptRoute+0x2c> @ imm = #-0x2
700a01ec: 980c         	ldr	r0, [sp, #0x30]
700a01ee: b920         	cbnz	r0, 0x700a01fa <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #0x8
700a01f0: e7ff         	b	0x700a01f2 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #-0x2
700a01f2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a01f6: 900a         	str	r0, [sp, #0x28]
;     }
700a01f8: e7ff         	b	0x700a01fa <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a01fa: 980a         	ldr	r0, [sp, #0x28]
700a01fc: b968         	cbnz	r0, 0x700a021a <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0x1a
700a01fe: e7ff         	b	0x700a0200 <Sciclient_rmClearInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a0200: 980d         	ldr	r0, [sp, #0x34]
700a0202: 6880         	ldr	r0, [r0, #0x8]
700a0204: f04f 4100    	mov.w	r1, #0x80000000
700a0208: f00e fd22    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0xea44
;     if (r == SystemP_SUCCESS &&
700a020c: b128         	cbz	r0, 0x700a021a <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0xa
700a020e: e7ff         	b	0x700a0210 <Sciclient_rmClearInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
700a0210: 980d         	ldr	r0, [sp, #0x34]
700a0212: 7ec0         	ldrb	r0, [r0, #0x1b]
700a0214: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
700a0218: e00f         	b	0x700a023a <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
700a021a: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
700a021e: f007 fbf7    	bl	0x700a7a10 <Sciclient_getCurrentContext> @ imm = #0x77ee
700a0222: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a0226: f241 3020    	movw	r0, #0x1320
700a022a: f2c7 000b    	movt	r0, #0x700b
700a022e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a0232: 6840         	ldr	r0, [r0, #0x4]
700a0234: f88d 0025    	strb.w	r0, [sp, #0x25]
700a0238: e7ff         	b	0x700a023a <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a023a: 980a         	ldr	r0, [sp, #0x28]
700a023c: b960         	cbnz	r0, 0x700a0258 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0x18
700a023e: e7ff         	b	0x700a0240 <Sciclient_rmClearInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a0240: 980d         	ldr	r0, [sp, #0x34]
700a0242: 6880         	ldr	r0, [r0, #0x8]
700a0244: 2104         	movs	r1, #0x4
700a0246: f00e fd03    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0xea06
;     if (r == SystemP_SUCCESS &&
700a024a: b128         	cbz	r0, 0x700a0258 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0xa
700a024c: e7ff         	b	0x700a024e <Sciclient_rmClearInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
700a024e: 980d         	ldr	r0, [sp, #0x34]
700a0250: 8a80         	ldrh	r0, [r0, #0x14]
700a0252: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
700a0256: e003         	b	0x700a0260 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #0x6
700a0258: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
700a025a: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a025e: e7ff         	b	0x700a0260 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a0260: 980a         	ldr	r0, [sp, #0x28]
700a0262: 2800         	cmp	r0, #0x0
700a0264: d175         	bne	0x700a0352 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #0xea
700a0266: e7ff         	b	0x700a0268 <Sciclient_rmClearInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
700a0268: 980d         	ldr	r0, [sp, #0x34]
700a026a: 6880         	ldr	r0, [r0, #0x8]
700a026c: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
700a026e: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a0272: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
700a0276: 980d         	ldr	r0, [sp, #0x34]
700a0278: 8980         	ldrh	r0, [r0, #0xc]
700a027a: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
700a027e: 980d         	ldr	r0, [sp, #0x34]
700a0280: 89c0         	ldrh	r0, [r0, #0xe]
700a0282: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
700a0286: 980d         	ldr	r0, [sp, #0x34]
700a0288: 8a00         	ldrh	r0, [r0, #0x10]
700a028a: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
700a028e: 980d         	ldr	r0, [sp, #0x34]
700a0290: 8a40         	ldrh	r0, [r0, #0x12]
700a0292: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
700a0296: 980d         	ldr	r0, [sp, #0x34]
700a0298: 8b00         	ldrh	r0, [r0, #0x18]
700a029a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
700a029e: 980d         	ldr	r0, [sp, #0x34]
700a02a0: 8ac0         	ldrh	r0, [r0, #0x16]
700a02a2: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
700a02a6: 980d         	ldr	r0, [sp, #0x34]
700a02a8: 7e80         	ldrb	r0, [r0, #0x1a]
700a02aa: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
700a02ae: 9802         	ldr	r0, [sp, #0x8]
700a02b0: f00b fa6e    	bl	0x700ab790 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xb4dc
700a02b4: b310         	cbz	r0, 0x700a02fc <Sciclient_rmClearInterruptRoute+0x13c> @ imm = #0x44
700a02b6: e7ff         	b	0x700a02b8 <Sciclient_rmClearInterruptRoute+0xf8> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
700a02b8: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a02bc: f00e fad0    	bl	0x700ae860 <Sciclient_rmIaIsIa> @ imm = #0xe5a0
700a02c0: b168         	cbz	r0, 0x700a02de <Sciclient_rmClearInterruptRoute+0x11e> @ imm = #0x1a
700a02c2: e7ff         	b	0x700a02c4 <Sciclient_rmClearInterruptRoute+0x104> @ imm = #-0x2
;                 cfg.s_ia = cfg.s_id;
700a02c4: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a02c8: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                 cfg.vint = cfg.s_idx;
700a02cc: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a02d0: f8ad 001a    	strh.w	r0, [sp, #0x1a]
700a02d4: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
700a02d6: f00c fa43    	bl	0x700ac760 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xc486
700a02da: 900a         	str	r0, [sp, #0x28]
;             } else {
700a02dc: e00d         	b	0x700a02fa <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #0x1a
700a02de: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqGetRoute(&cfg);
700a02e0: f7fc fc46    	bl	0x7009cb70 <Sciclient_rmIrqGetRoute> @ imm = #-0x3774
700a02e4: 900a         	str	r0, [sp, #0x28]
;                 if (r == SystemP_SUCCESS) {
700a02e6: 980a         	ldr	r0, [sp, #0x28]
700a02e8: b930         	cbnz	r0, 0x700a02f8 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #0xc
700a02ea: e7ff         	b	0x700a02ec <Sciclient_rmClearInterruptRoute+0x12c> @ imm = #-0x2
700a02ec: a802         	add	r0, sp, #0x8
700a02ee: 2100         	movs	r1, #0x0
;                     r = Sciclient_rmIrqDeleteRoute(&cfg, false);
700a02f0: f000 f9ce    	bl	0x700a0690 <Sciclient_rmIrqDeleteRoute> @ imm = #0x39c
700a02f4: 900a         	str	r0, [sp, #0x28]
;                 }
700a02f6: e7ff         	b	0x700a02f8 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #-0x2
700a02f8: e7ff         	b	0x700a02fa <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a02fa: e029         	b	0x700a0350 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #0x52
700a02fc: 9802         	ldr	r0, [sp, #0x8]
700a02fe: f00b fa0f    	bl	0x700ab720 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xb41e
;                 true) ||
700a0302: b928         	cbnz	r0, 0x700a0310 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #0xa
700a0304: e7ff         	b	0x700a0306 <Sciclient_rmClearInterruptRoute+0x146> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
700a0306: 9802         	ldr	r0, [sp, #0x8]
700a0308: f00b fa7a    	bl	0x700ab800 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xb4f4
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a030c: b128         	cbz	r0, 0x700a031a <Sciclient_rmClearInterruptRoute+0x15a> @ imm = #0xa
700a030e: e7ff         	b	0x700a0310 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #-0x2
700a0310: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintDelete(&cfg);
700a0312: f002 fca5    	bl	0x700a2c60 <Sciclient_rmIrqVintDelete> @ imm = #0x294a
700a0316: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
700a0318: e019         	b	0x700a034e <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #0x32
700a031a: 9802         	ldr	r0, [sp, #0x8]
700a031c: f00b fae0    	bl	0x700ab8e0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xb5c0
700a0320: b128         	cbz	r0, 0x700a032e <Sciclient_rmClearInterruptRoute+0x16e> @ imm = #0xa
700a0322: e7ff         	b	0x700a0324 <Sciclient_rmClearInterruptRoute+0x164> @ imm = #-0x2
700a0324: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
700a0326: f00c fa1b    	bl	0x700ac760 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xc436
700a032a: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
700a032c: e00e         	b	0x700a034c <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #0x1c
700a032e: 9802         	ldr	r0, [sp, #0x8]
700a0330: f00b fa9e    	bl	0x700ab870 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xb53c
700a0334: b128         	cbz	r0, 0x700a0342 <Sciclient_rmClearInterruptRoute+0x182> @ imm = #0xa
700a0336: e7ff         	b	0x700a0338 <Sciclient_rmClearInterruptRoute+0x178> @ imm = #-0x2
700a0338: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqClearOesRegister(&cfg);
700a033a: f00d fde9    	bl	0x700adf10 <Sciclient_rmIrqClearOesRegister> @ imm = #0xdbd2
700a033e: 900a         	str	r0, [sp, #0x28]
;         } else {
700a0340: e003         	b	0x700a034a <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #0x6
700a0342: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a0346: 900a         	str	r0, [sp, #0x28]
700a0348: e7ff         	b	0x700a034a <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #-0x2
700a034a: e7ff         	b	0x700a034c <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #-0x2
700a034c: e7ff         	b	0x700a034e <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #-0x2
700a034e: e7ff         	b	0x700a0350 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #-0x2
;     }
700a0350: e7ff         	b	0x700a0352 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #-0x2
;     return r;
700a0352: 980a         	ldr	r0, [sp, #0x28]
700a0354: b00e         	add	sp, #0x38
700a0356: bd80         	pop	{r7, pc}
		...

700a0360 <Udma_chConfigTx>:
; {
700a0360: b580         	push	{r7, lr}
700a0362: b090         	sub	sp, #0x40
700a0364: 900f         	str	r0, [sp, #0x3c]
700a0366: 910e         	str	r1, [sp, #0x38]
700a0368: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
700a036a: 900d         	str	r0, [sp, #0x34]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
700a036c: 980f         	ldr	r0, [sp, #0x3c]
700a036e: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
700a0370: 980b         	ldr	r0, [sp, #0x2c]
700a0372: b178         	cbz	r0, 0x700a0394 <Udma_chConfigTx+0x34> @ imm = #0x1e
700a0374: e7ff         	b	0x700a0376 <Udma_chConfigTx+0x16> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
700a0376: 980b         	ldr	r0, [sp, #0x2c]
700a0378: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a037c: f64a 31cd    	movw	r1, #0xabcd
700a0380: f6ca 31dc    	movt	r1, #0xabdc
700a0384: 4288         	cmp	r0, r1
700a0386: d105         	bne	0x700a0394 <Udma_chConfigTx+0x34> @ imm = #0xa
700a0388: e7ff         	b	0x700a038a <Udma_chConfigTx+0x2a> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_TX) != UDMA_CH_FLAG_TX))
700a038a: 980b         	ldr	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
700a038c: 7800         	ldrb	r0, [r0]
700a038e: 07c0         	lsls	r0, r0, #0x1f
700a0390: b920         	cbnz	r0, 0x700a039c <Udma_chConfigTx+0x3c> @ imm = #0x8
700a0392: e7ff         	b	0x700a0394 <Udma_chConfigTx+0x34> @ imm = #-0x2
700a0394: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a0398: 900d         	str	r0, [sp, #0x34]
;     }
700a039a: e7ff         	b	0x700a039c <Udma_chConfigTx+0x3c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a039c: 980d         	ldr	r0, [sp, #0x34]
700a039e: b9a8         	cbnz	r0, 0x700a03cc <Udma_chConfigTx+0x6c> @ imm = #0x2a
700a03a0: e7ff         	b	0x700a03a2 <Udma_chConfigTx+0x42> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a03a2: 980b         	ldr	r0, [sp, #0x2c]
700a03a4: 6e80         	ldr	r0, [r0, #0x68]
700a03a6: 900c         	str	r0, [sp, #0x30]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a03a8: 980c         	ldr	r0, [sp, #0x30]
700a03aa: b150         	cbz	r0, 0x700a03c2 <Udma_chConfigTx+0x62> @ imm = #0x14
700a03ac: e7ff         	b	0x700a03ae <Udma_chConfigTx+0x4e> @ imm = #-0x2
700a03ae: 980c         	ldr	r0, [sp, #0x30]
700a03b0: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a03b4: f64a 31cd    	movw	r1, #0xabcd
700a03b8: f6ca 31dc    	movt	r1, #0xabdc
700a03bc: 4288         	cmp	r0, r1
700a03be: d004         	beq	0x700a03ca <Udma_chConfigTx+0x6a> @ imm = #0x8
700a03c0: e7ff         	b	0x700a03c2 <Udma_chConfigTx+0x62> @ imm = #-0x2
700a03c2: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a03c6: 900d         	str	r0, [sp, #0x34]
;         }
700a03c8: e7ff         	b	0x700a03ca <Udma_chConfigTx+0x6a> @ imm = #-0x2
;     }
700a03ca: e7ff         	b	0x700a03cc <Udma_chConfigTx+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a03cc: 980d         	ldr	r0, [sp, #0x34]
700a03ce: 2800         	cmp	r0, #0x0
700a03d0: f040 808e    	bne.w	0x700a04f0 <Udma_chConfigTx+0x190> @ imm = #0x11c
700a03d4: e7ff         	b	0x700a03d6 <Udma_chConfigTx+0x76> @ imm = #-0x2
700a03d6: f647 70ff    	movw	r0, #0x7fff
;         rmUdmaTxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
700a03da: 9004         	str	r0, [sp, #0x10]
;         rmUdmaTxReq.nav_id              = drvHandle->devIdUdma;
700a03dc: 980c         	ldr	r0, [sp, #0x30]
700a03de: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
700a03e2: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmUdmaTxReq.index               = (uint16_t)chHandleInt->txChNum;
700a03e6: 980b         	ldr	r0, [sp, #0x2c]
700a03e8: 6ec0         	ldr	r0, [r0, #0x6c]
700a03ea: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmUdmaTxReq.tx_pause_on_err     = txPrms->pauseOnError;
700a03ee: 980e         	ldr	r0, [sp, #0x38]
700a03f0: 7800         	ldrb	r0, [r0]
700a03f2: f88d 0018    	strb.w	r0, [sp, #0x18]
;         rmUdmaTxReq.tx_filt_einfo       = txPrms->filterEinfo;
700a03f6: 980e         	ldr	r0, [sp, #0x38]
700a03f8: 7840         	ldrb	r0, [r0, #0x1]
700a03fa: f88d 0019    	strb.w	r0, [sp, #0x19]
;         rmUdmaTxReq.tx_filt_pswords     = txPrms->filterPsWords;
700a03fe: 980e         	ldr	r0, [sp, #0x38]
700a0400: 7880         	ldrb	r0, [r0, #0x2]
700a0402: f88d 001a    	strb.w	r0, [sp, #0x1a]
;         rmUdmaTxReq.tx_atype            = txPrms->addrType;
700a0406: 980e         	ldr	r0, [sp, #0x38]
700a0408: 78c0         	ldrb	r0, [r0, #0x3]
700a040a: f88d 001b    	strb.w	r0, [sp, #0x1b]
;         rmUdmaTxReq.tx_chan_type        = txPrms->chanType;
700a040e: 980e         	ldr	r0, [sp, #0x38]
700a0410: 7900         	ldrb	r0, [r0, #0x4]
700a0412: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         rmUdmaTxReq.tx_fetch_size       = txPrms->fetchWordSize;
700a0416: 980e         	ldr	r0, [sp, #0x38]
700a0418: 88c0         	ldrh	r0, [r0, #0x6]
700a041a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmUdmaTxReq.tx_priority         = txPrms->busPriority;
700a041e: 980e         	ldr	r0, [sp, #0x38]
700a0420: 7a00         	ldrb	r0, [r0, #0x8]
700a0422: f88d 0023    	strb.w	r0, [sp, #0x23]
;         rmUdmaTxReq.tx_qos              = txPrms->busQos;
700a0426: 980e         	ldr	r0, [sp, #0x38]
700a0428: 7a40         	ldrb	r0, [r0, #0x9]
700a042a: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmUdmaTxReq.tx_orderid          = txPrms->busOrderId;
700a042e: 980e         	ldr	r0, [sp, #0x38]
700a0430: 7a80         	ldrb	r0, [r0, #0xa]
700a0432: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmUdmaTxReq.fdepth              = txPrms->fifoDepth;
700a0436: 980e         	ldr	r0, [sp, #0x38]
700a0438: 89c0         	ldrh	r0, [r0, #0xe]
700a043a: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmUdmaTxReq.tx_burst_size       = txPrms->burstSize;
700a043e: 980e         	ldr	r0, [sp, #0x38]
700a0440: 7c00         	ldrb	r0, [r0, #0x10]
700a0442: f88d 0029    	strb.w	r0, [sp, #0x29]
;         rmUdmaTxReq.tx_sched_priority   = txPrms->dmaPriority;
700a0446: 980e         	ldr	r0, [sp, #0x38]
700a0448: 7ac0         	ldrb	r0, [r0, #0xb]
700a044a: f88d 0028    	strb.w	r0, [sp, #0x28]
;         rmUdmaTxReq.tx_credit_count     = txPrms->txCredit;
700a044e: 980e         	ldr	r0, [sp, #0x38]
700a0450: 7b00         	ldrb	r0, [r0, #0xc]
700a0452: f88d 0020    	strb.w	r0, [sp, #0x20]
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a0456: 980c         	ldr	r0, [sp, #0x30]
700a0458: 6800         	ldr	r0, [r0]
700a045a: 2801         	cmp	r0, #0x1
700a045c: d11d         	bne	0x700a049a <Udma_chConfigTx+0x13a> @ imm = #0x3a
700a045e: e7ff         	b	0x700a0460 <Udma_chConfigTx+0x100> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a0460: 980b         	ldr	r0, [sp, #0x2c]
700a0462: 7800         	ldrb	r0, [r0]
700a0464: 0740         	lsls	r0, r0, #0x1d
700a0466: 2800         	cmp	r0, #0x0
700a0468: d508         	bpl	0x700a047c <Udma_chConfigTx+0x11c> @ imm = #0x10
700a046a: e7ff         	b	0x700a046c <Udma_chConfigTx+0x10c> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
700a046c: 9804         	ldr	r0, [sp, #0x10]
700a046e: f440 3080    	orr	r0, r0, #0x10000
700a0472: 9004         	str	r0, [sp, #0x10]
700a0474: 2001         	movs	r0, #0x1
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_BLK_CPY;
700a0476: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
700a047a: e00d         	b	0x700a0498 <Udma_chConfigTx+0x138> @ imm = #0x1a
;             else if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a047c: 980b         	ldr	r0, [sp, #0x2c]
700a047e: 7800         	ldrb	r0, [r0]
700a0480: 07c0         	lsls	r0, r0, #0x1f
700a0482: b140         	cbz	r0, 0x700a0496 <Udma_chConfigTx+0x136> @ imm = #0x10
700a0484: e7ff         	b	0x700a0486 <Udma_chConfigTx+0x126> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
700a0486: 9804         	ldr	r0, [sp, #0x10]
700a0488: f440 3080    	orr	r0, r0, #0x10000
700a048c: 9004         	str	r0, [sp, #0x10]
700a048e: 2000         	movs	r0, #0x0
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_SPLIT_TR_TX;
700a0490: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
700a0494: e7ff         	b	0x700a0496 <Udma_chConfigTx+0x136> @ imm = #-0x2
700a0496: e7ff         	b	0x700a0498 <Udma_chConfigTx+0x138> @ imm = #-0x2
;         }
700a0498: e7ff         	b	0x700a049a <Udma_chConfigTx+0x13a> @ imm = #-0x2
;         if(NULL_PTR != chHandleInt->tdCqRing)
700a049a: 980b         	ldr	r0, [sp, #0x2c]
700a049c: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a04a0: b158         	cbz	r0, 0x700a04ba <Udma_chConfigTx+0x15a> @ imm = #0x16
700a04a2: e7ff         	b	0x700a04a4 <Udma_chConfigTx+0x144> @ imm = #-0x2
;             rmUdmaTxReq.txcq_qnum       = chHandleInt->tdCqRing->ringNum;
700a04a4: 980b         	ldr	r0, [sp, #0x2c]
700a04a6: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a04aa: 8880         	ldrh	r0, [r0, #0x4]
700a04ac: f8ad 0021    	strh.w	r0, [sp, #0x21]
;             rmUdmaTxReq.tx_supr_tdpkt   = txPrms->supressTdCqPkt;
700a04b0: 980e         	ldr	r0, [sp, #0x38]
700a04b2: 7c40         	ldrb	r0, [r0, #0x11]
700a04b4: f88d 001d    	strb.w	r0, [sp, #0x1d]
;         }
700a04b8: e007         	b	0x700a04ca <Udma_chConfigTx+0x16a> @ imm = #0xe
700a04ba: f64f 70ff    	movw	r0, #0xffff
;             rmUdmaTxReq.txcq_qnum       = UDMA_RING_INVALID;
700a04be: f8ad 0021    	strh.w	r0, [sp, #0x21]
700a04c2: 2001         	movs	r0, #0x1
;             rmUdmaTxReq.tx_supr_tdpkt   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_ENABLED;
700a04c4: f88d 001d    	strb.w	r0, [sp, #0x1d]
700a04c8: e7ff         	b	0x700a04ca <Udma_chConfigTx+0x16a> @ imm = #-0x2
700a04ca: a802         	add	r0, sp, #0x8
700a04cc: 4669         	mov	r1, sp
700a04ce: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapTxChCfg(
700a04d2: f00c fa35    	bl	0x700ac940 <Sciclient_rmUdmapTxChCfg> @ imm = #0xc46a
700a04d6: 900d         	str	r0, [sp, #0x34]
;         if(CSL_PASS != retVal)
700a04d8: 980d         	ldr	r0, [sp, #0x34]
700a04da: b108         	cbz	r0, 0x700a04e0 <Udma_chConfigTx+0x180> @ imm = #0x2
700a04dc: e7ff         	b	0x700a04de <Udma_chConfigTx+0x17e> @ imm = #-0x2
;         }
700a04de: e7ff         	b	0x700a04e0 <Udma_chConfigTx+0x180> @ imm = #-0x2
;         (void) memcpy(&chHandleInt->txPrms, txPrms, sizeof(chHandleInt->txPrms));
700a04e0: 980b         	ldr	r0, [sp, #0x2c]
700a04e2: f500 70f2    	add.w	r0, r0, #0x1e4
700a04e6: 990e         	ldr	r1, [sp, #0x38]
700a04e8: 2212         	movs	r2, #0x12
700a04ea: f7f9 ed38    	blx	0x70099f5c <__aeabi_memcpy8> @ imm = #-0x6590
;     }
700a04ee: e7ff         	b	0x700a04f0 <Udma_chConfigTx+0x190> @ imm = #-0x2
;     return (retVal);
700a04f0: 980d         	ldr	r0, [sp, #0x34]
700a04f2: b010         	add	sp, #0x40
700a04f4: bd80         	pop	{r7, pc}
		...
700a04fe: 0000         	movs	r0, r0

700a0500 <ClockP_init>:
; {
700a0500: b580         	push	{r7, lr}
700a0502: b096         	sub	sp, #0x58
;     DebugP_assert( gClockConfig.timerInputPreScaler != 0U);
700a0504: f642 1000    	movw	r0, #0x2900
700a0508: f2c7 000b    	movt	r0, #0x700b
700a050c: 9009         	str	r0, [sp, #0x24]
700a050e: 68c0         	ldr	r0, [r0, #0xc]
700a0510: 2800         	cmp	r0, #0x0
700a0512: bf18         	it	ne
700a0514: 2001         	movne	r0, #0x1
700a0516: f641 316a    	movw	r1, #0x1b6a
700a051a: f2c7 010b    	movt	r1, #0x700b
700a051e: 466a         	mov	r2, sp
700a0520: 6011         	str	r1, [r2]
700a0522: f641 51fd    	movw	r1, #0x1dfd
700a0526: f2c7 010b    	movt	r1, #0x700b
700a052a: 9107         	str	r1, [sp, #0x1c]
700a052c: f242 120c    	movw	r2, #0x210c
700a0530: f2c7 020b    	movt	r2, #0x700b
700a0534: 9208         	str	r2, [sp, #0x20]
700a0536: 2334         	movs	r3, #0x34
700a0538: f00a faca    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xa594
700a053c: 9907         	ldr	r1, [sp, #0x1c]
700a053e: 9a08         	ldr	r2, [sp, #0x20]
700a0540: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerInputClkHz != 0U);
700a0542: 6880         	ldr	r0, [r0, #0x8]
700a0544: 2800         	cmp	r0, #0x0
700a0546: bf18         	it	ne
700a0548: 2001         	movne	r0, #0x1
700a054a: f641 33dc    	movw	r3, #0x1bdc
700a054e: f2c7 030b    	movt	r3, #0x700b
700a0552: 46ec         	mov	r12, sp
700a0554: f8cc 3000    	str.w	r3, [r12]
700a0558: 2335         	movs	r3, #0x35
700a055a: f00a fab9    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xa572
700a055e: 9907         	ldr	r1, [sp, #0x1c]
700a0560: 9a08         	ldr	r2, [sp, #0x20]
700a0562: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.usecPerTick != 0U);
700a0564: 6900         	ldr	r0, [r0, #0x10]
700a0566: 2800         	cmp	r0, #0x0
700a0568: bf18         	it	ne
700a056a: 2001         	movne	r0, #0x1
700a056c: f641 532c    	movw	r3, #0x1d2c
700a0570: f2c7 030b    	movt	r3, #0x700b
700a0574: 46ec         	mov	r12, sp
700a0576: f8cc 3000    	str.w	r3, [r12]
700a057a: 2336         	movs	r3, #0x36
700a057c: f00a faa8    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xa550
700a0580: 9907         	ldr	r1, [sp, #0x1c]
700a0582: 9a08         	ldr	r2, [sp, #0x20]
700a0584: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerBaseAddr != 0U);
700a0586: 6800         	ldr	r0, [r0]
700a0588: 2800         	cmp	r0, #0x0
700a058a: bf18         	it	ne
700a058c: 2001         	movne	r0, #0x1
700a058e: f641 43aa    	movw	r3, #0x1caa
700a0592: f2c7 030b    	movt	r3, #0x700b
700a0596: 46ec         	mov	r12, sp
700a0598: f8cc 3000    	str.w	r3, [r12]
700a059c: 2337         	movs	r3, #0x37
700a059e: f00a fa97    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xa52e
700a05a2: 9809         	ldr	r0, [sp, #0x24]
;     gClockCtrl.ticks = 0;
700a05a4: f245 0210    	movw	r2, #0x5010
700a05a8: f2c7 0208    	movt	r2, #0x7008
700a05ac: 2100         	movs	r1, #0x0
700a05ae: 6051         	str	r1, [r2, #0x4]
700a05b0: 6011         	str	r1, [r2]
;     gClockCtrl.usecPerTick = gClockConfig.usecPerTick;
700a05b2: 6903         	ldr	r3, [r0, #0x10]
700a05b4: 6093         	str	r3, [r2, #0x8]
;     gClockCtrl.timerBaseAddr = gClockConfig.timerBaseAddr;
700a05b6: 6800         	ldr	r0, [r0]
700a05b8: 62d0         	str	r0, [r2, #0x2c]
700a05ba: f244 2040    	movw	r0, #0x4240
700a05be: f2c0 000f    	movt	r0, #0xf
;     if( pdMS_TO_TICKS( TIME_IN_MILLI_SECONDS ) != ClockP_usecToTicks( TIME_IN_MICRO_SECONDS ) )
700a05c2: f00e fe6d    	bl	0x700af2a0 <ClockP_usecToTicks> @ imm = #0xecda
700a05c6: f5b0 7f7a    	cmp.w	r0, #0x3e8
700a05ca: d01d         	beq	0x700a0608 <ClockP_init+0x108> @ imm = #0x3a
700a05cc: e7ff         	b	0x700a05ce <ClockP_init+0xce> @ imm = #-0x2
;         DebugP_logWarn("FreeRTOS configTICK_RATE_HZ (%d), does not match ClockP tick rate Hz (%d)\r\n",
700a05ce: f642 1000    	movw	r0, #0x2900
700a05d2: f2c7 000b    	movt	r0, #0x700b
700a05d6: 6901         	ldr	r1, [r0, #0x10]
700a05d8: f244 2040    	movw	r0, #0x4240
700a05dc: f2c0 000f    	movt	r0, #0xf
700a05e0: fbb0 f0f1    	udiv	r0, r0, r1
700a05e4: 4669         	mov	r1, sp
700a05e6: 6048         	str	r0, [r1, #0x4]
700a05e8: f44f 707a    	mov.w	r0, #0x3e8
700a05ec: 6008         	str	r0, [r1]
700a05ee: f641 012c    	movw	r1, #0x182c
700a05f2: f2c7 010b    	movt	r1, #0x700b
700a05f6: f242 120c    	movw	r2, #0x210c
700a05fa: f2c7 020b    	movt	r2, #0x700b
700a05fe: 2004         	movs	r0, #0x4
700a0600: 2346         	movs	r3, #0x46
700a0602: f009 faad    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #0x955a
;     }
700a0606: e7ff         	b	0x700a0608 <ClockP_init+0x108> @ imm = #-0x2
700a0608: a80f         	add	r0, sp, #0x3c
;     TimerP_Params_init(&timerParams);
700a060a: 9002         	str	r0, [sp, #0x8]
700a060c: f00d ff40    	bl	0x700ae490 <TimerP_Params_init> @ imm = #0xde80
700a0610: 9902         	ldr	r1, [sp, #0x8]
;     timerParams.inputPreScaler    = gClockConfig.timerInputPreScaler;
700a0612: f642 1000    	movw	r0, #0x2900
700a0616: f2c7 000b    	movt	r0, #0x700b
700a061a: 9004         	str	r0, [sp, #0x10]
700a061c: 68c2         	ldr	r2, [r0, #0xc]
700a061e: 920f         	str	r2, [sp, #0x3c]
;     timerParams.inputClkHz        = gClockConfig.timerInputClkHz;
700a0620: 6882         	ldr	r2, [r0, #0x8]
700a0622: 9210         	str	r2, [sp, #0x40]
;     timerParams.periodInUsec      = gClockConfig.usecPerTick;
700a0624: 6900         	ldr	r0, [r0, #0x10]
700a0626: 9011         	str	r0, [sp, #0x44]
700a0628: 2000         	movs	r0, #0x0
;     timerParams.oneshotMode       = 0;
700a062a: 9003         	str	r0, [sp, #0xc]
700a062c: 9013         	str	r0, [sp, #0x4c]
700a062e: 2001         	movs	r0, #0x1
;     timerParams.enableOverflowInt = 1;
700a0630: 9014         	str	r0, [sp, #0x50]
;     TimerP_setup(gClockCtrl.timerBaseAddr, &timerParams);
700a0632: f245 0010    	movw	r0, #0x5010
700a0636: f2c7 0008    	movt	r0, #0x7008
700a063a: 9006         	str	r0, [sp, #0x18]
700a063c: 6ac0         	ldr	r0, [r0, #0x2c]
700a063e: f7fd f9bf    	bl	0x7009d9c0 <TimerP_setup> @ imm = #-0x2c82
700a0642: 9806         	ldr	r0, [sp, #0x18]
;     gClockCtrl.timerReloadCount = TimerP_getReloadCount(gClockCtrl.timerBaseAddr);
700a0644: 6ac0         	ldr	r0, [r0, #0x2c]
700a0646: f00f f9c3    	bl	0x700af9d0 <TimerP_getReloadCount> @ imm = #0xf386
700a064a: 9906         	ldr	r1, [sp, #0x18]
700a064c: 6308         	str	r0, [r1, #0x30]
700a064e: a80a         	add	r0, sp, #0x28
;     HwiP_Params_init(&timerHwiParams);
700a0650: 9005         	str	r0, [sp, #0x14]
700a0652: f00f fc5d    	bl	0x700aff10 <HwiP_Params_init> @ imm = #0xf8ba
700a0656: 9b03         	ldr	r3, [sp, #0xc]
700a0658: 9a04         	ldr	r2, [sp, #0x10]
700a065a: 9905         	ldr	r1, [sp, #0x14]
700a065c: 9806         	ldr	r0, [sp, #0x18]
;     timerHwiParams.intNum = gClockConfig.timerHwiIntNum;
700a065e: f8d2 c004    	ldr.w	r12, [r2, #0x4]
700a0662: f8cd c028    	str.w	r12, [sp, #0x28]
;     timerHwiParams.callback = ClockP_timerTickIsr;
700a0666: f24e 5cc1    	movw	r12, #0xe5c1
700a066a: f2c7 0c0a    	movt	r12, #0x700a
700a066e: f8cd c02c    	str.w	r12, [sp, #0x2c]
;     timerHwiParams.isPulse = 0;
700a0672: f88d 3038    	strb.w	r3, [sp, #0x38]
;     timerHwiParams.priority = gClockConfig.intrPriority;
700a0676: 7d12         	ldrb	r2, [r2, #0x14]
700a0678: f88d 2036    	strb.w	r2, [sp, #0x36]
;     (void)HwiP_construct(&gClockCtrl.timerHwiObj, &timerHwiParams);
700a067c: 300c         	adds	r0, #0xc
700a067e: f00f fc5f    	bl	0x700aff40 <HwiP_construct> @ imm = #0xf8be
;     TimerP_start(gClockCtrl.timerBaseAddr);
700a0682: 9806         	ldr	r0, [sp, #0x18]
700a0684: 6ac0         	ldr	r0, [r0, #0x2c]
700a0686: f00e fffb    	bl	0x700af680 <TimerP_start> @ imm = #0xeff6
; }
700a068a: b016         	add	sp, #0x58
700a068c: bd80         	pop	{r7, pc}
700a068e: 0000         	movs	r0, r0

700a0690 <Sciclient_rmIrqDeleteRoute>:
; {
700a0690: b580         	push	{r7, lr}
700a0692: b090         	sub	sp, #0x40
700a0694: 900f         	str	r0, [sp, #0x3c]
700a0696: f88d 103b    	strb.w	r1, [sp, #0x3b]
700a069a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a069c: 900d         	str	r0, [sp, #0x34]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a069e: 9002         	str	r0, [sp, #0x8]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
700a06a0: 9001         	str	r0, [sp, #0x4]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a06a2: f8ad 0032    	strh.w	r0, [sp, #0x32]
700a06a6: e7ff         	b	0x700a06a8 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x2
700a06a8: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a06ac: 9000         	str	r0, [sp]
700a06ae: f00f fac7    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0xf58e
700a06b2: 4601         	mov	r1, r0
700a06b4: 9800         	ldr	r0, [sp]
700a06b6: 4288         	cmp	r0, r1
700a06b8: f280 80ac    	bge.w	0x700a0814 <Sciclient_rmIrqDeleteRoute+0x184> @ imm = #0x158
700a06bc: e7ff         	b	0x700a06be <Sciclient_rmIrqDeleteRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a06be: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a06c2: f00e fe7d    	bl	0x700af3c0 <Sciclient_rmPsGetIrqNode> @ imm = #0xecfa
700a06c6: 900b         	str	r0, [sp, #0x2c]
;         cur_inp = Sciclient_rmPsGetInp(i);
700a06c8: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a06cc: f00d fa60    	bl	0x700adb90 <Sciclient_rmPsGetInp> @ imm = #0xd4c0
700a06d0: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;         cur_outp = Sciclient_rmPsGetOutp(i);
700a06d4: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a06d8: f00d fa7a    	bl	0x700adbd0 <Sciclient_rmPsGetOutp> @ imm = #0xd4f4
700a06dc: f8ad 0028    	strh.w	r0, [sp, #0x28]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a06e0: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a06e4: 2800         	cmp	r0, #0x0
700a06e6: d156         	bne	0x700a0796 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0xac
700a06e8: e7ff         	b	0x700a06ea <Sciclient_rmIrqDeleteRoute+0x5a> @ imm = #-0x2
700a06ea: 980b         	ldr	r0, [sp, #0x2c]
700a06ec: 8800         	ldrh	r0, [r0]
700a06ee: f00e f8b7    	bl	0x700ae860 <Sciclient_rmIaIsIa> @ imm = #0xe16e
700a06f2: 2800         	cmp	r0, #0x0
700a06f4: d04f         	beq	0x700a0796 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x9e
700a06f6: e7ff         	b	0x700a06f8 <Sciclient_rmIrqDeleteRoute+0x68> @ imm = #-0x2
;             (unmap_vint == true)) {
700a06f8: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a06fc: 07c0         	lsls	r0, r0, #0x1f
700a06fe: 2800         	cmp	r0, #0x0
700a0700: d049         	beq	0x700a0796 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x92
700a0702: e7ff         	b	0x700a0704 <Sciclient_rmIrqDeleteRoute+0x74> @ imm = #-0x2
700a0704: 203c         	movs	r0, #0x3c
700a0706: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a070a: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
700a070c: 980f         	ldr	r0, [sp, #0x3c]
700a070e: 7900         	ldrb	r0, [r0, #0x4]
700a0710: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cfg->s_id;
700a0714: 980f         	ldr	r0, [sp, #0x3c]
700a0716: 88c0         	ldrh	r0, [r0, #0x6]
700a0718: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cfg->s_idx;
700a071c: 980f         	ldr	r0, [sp, #0x3c]
700a071e: 8900         	ldrh	r0, [r0, #0x8]
700a0720: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.ia_id = cfg->s_ia;
700a0724: 980f         	ldr	r0, [sp, #0x3c]
700a0726: 8a00         	ldrh	r0, [r0, #0x10]
700a0728: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.vint = cur_outp;
700a072c: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a0730: f8ad 0022    	strh.w	r0, [sp, #0x22]
;             req.global_event = cur_inp;
700a0734: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
700a0738: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint_status_bit_index = cfg->vint_sb;
700a073c: 980f         	ldr	r0, [sp, #0x3c]
700a073e: 7d00         	ldrb	r0, [r0, #0x14]
700a0740: f88d 0026    	strb.w	r0, [sp, #0x26]
700a0744: a803         	add	r0, sp, #0xc
700a0746: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
700a074a: f00c f9a9    	bl	0x700acaa0 <Sciclient_rmIrqReleaseRaw> @ imm = #0xc352
700a074e: 900d         	str	r0, [sp, #0x34]
;             if (r == SystemP_SUCCESS) {
700a0750: 980d         	ldr	r0, [sp, #0x34]
700a0752: b9f8         	cbnz	r0, 0x700a0794 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #0x3e
700a0754: e7ff         	b	0x700a0756 <Sciclient_rmIrqDeleteRoute+0xc6> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
700a0756: 980b         	ldr	r0, [sp, #0x2c]
700a0758: 8800         	ldrh	r0, [r0]
700a075a: f00b fe51    	bl	0x700ac400 <Sciclient_rmIaGetInst> @ imm = #0xbca2
700a075e: 9002         	str	r0, [sp, #0x8]
;                 if (ia_inst != NULL) {
700a0760: 9802         	ldr	r0, [sp, #0x8]
700a0762: b1b0         	cbz	r0, 0x700a0792 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #0x2c
700a0764: e7ff         	b	0x700a0766 <Sciclient_rmIrqDeleteRoute+0xd6> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]--;
700a0766: 9802         	ldr	r0, [sp, #0x8]
700a0768: 6901         	ldr	r1, [r0, #0x10]
700a076a: f8bd 2028    	ldrh.w	r2, [sp, #0x28]
700a076e: 5c88         	ldrb	r0, [r1, r2]
700a0770: 3801         	subs	r0, #0x1
700a0772: 5488         	strb	r0, [r1, r2]
;                     if (ia_inst->v0_b0_evt == cur_inp - ia_inst->sevt_offset) {
700a0774: 9a02         	ldr	r2, [sp, #0x8]
700a0776: 8a90         	ldrh	r0, [r2, #0x14]
700a0778: f8bd 102a    	ldrh.w	r1, [sp, #0x2a]
700a077c: 8912         	ldrh	r2, [r2, #0x8]
700a077e: 1a89         	subs	r1, r1, r2
700a0780: 4288         	cmp	r0, r1
700a0782: d105         	bne	0x700a0790 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #0xa
700a0784: e7ff         	b	0x700a0786 <Sciclient_rmIrqDeleteRoute+0xf6> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
700a0786: 9902         	ldr	r1, [sp, #0x8]
700a0788: f64f 70ff    	movw	r0, #0xffff
700a078c: 8288         	strh	r0, [r1, #0x14]
;                     }
700a078e: e7ff         	b	0x700a0790 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #-0x2
;                 }
700a0790: e7ff         	b	0x700a0792 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #-0x2
;             }
700a0792: e7ff         	b	0x700a0794 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #-0x2
;         }
700a0794: e7ff         	b	0x700a0796 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #-0x2
;         if (i > 0u) {
700a0796: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a079a: b3a0         	cbz	r0, 0x700a0806 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #0x68
700a079c: e7ff         	b	0x700a079e <Sciclient_rmIrqDeleteRoute+0x10e> @ imm = #-0x2
700a079e: 2003         	movs	r0, #0x3
700a07a0: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
700a07a4: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
700a07a6: 980f         	ldr	r0, [sp, #0x3c]
700a07a8: 7900         	ldrb	r0, [r0, #0x4]
700a07aa: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cur_n->id;
700a07ae: 980b         	ldr	r0, [sp, #0x2c]
700a07b0: 8800         	ldrh	r0, [r0]
700a07b2: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cur_inp;
700a07b6: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
700a07ba: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.dst_id = cur_n->id;
700a07be: 980b         	ldr	r0, [sp, #0x2c]
700a07c0: 8800         	ldrh	r0, [r0]
700a07c2: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.dst_host_irq = cur_outp;
700a07c6: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a07ca: f8ad 001e    	strh.w	r0, [sp, #0x1e]
700a07ce: a803         	add	r0, sp, #0xc
700a07d0: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
700a07d4: f00c f964    	bl	0x700acaa0 <Sciclient_rmIrqReleaseRaw> @ imm = #0xc2c8
700a07d8: 900d         	str	r0, [sp, #0x34]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
700a07da: 980d         	ldr	r0, [sp, #0x34]
700a07dc: b990         	cbnz	r0, 0x700a0804 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x24
700a07de: e7ff         	b	0x700a07e0 <Sciclient_rmIrqDeleteRoute+0x150> @ imm = #-0x2
700a07e0: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a07e4: b970         	cbnz	r0, 0x700a0804 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x1c
700a07e6: e7ff         	b	0x700a07e8 <Sciclient_rmIrqDeleteRoute+0x158> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
700a07e8: 980b         	ldr	r0, [sp, #0x2c]
700a07ea: 8800         	ldrh	r0, [r0]
700a07ec: f00b f920    	bl	0x700aba30 <Sciclient_rmIrGetInst> @ imm = #0xb240
700a07f0: 9001         	str	r0, [sp, #0x4]
;                 if (ir_inst != NULL) {
700a07f2: 9801         	ldr	r0, [sp, #0x4]
700a07f4: b128         	cbz	r0, 0x700a0802 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #0xa
700a07f6: e7ff         	b	0x700a07f8 <Sciclient_rmIrqDeleteRoute+0x168> @ imm = #-0x2
;                     ir_inst->inp0_mapping = SCICLIENT_RM_IR_MAPPING_FREE;
700a07f8: 9901         	ldr	r1, [sp, #0x4]
700a07fa: f64f 70ff    	movw	r0, #0xffff
700a07fe: 8188         	strh	r0, [r1, #0xc]
;                 }
700a0800: e7ff         	b	0x700a0802 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #-0x2
;             }
700a0802: e7ff         	b	0x700a0804 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #-0x2
;         }
700a0804: e7ff         	b	0x700a0806 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #-0x2
;     }
700a0806: e7ff         	b	0x700a0808 <Sciclient_rmIrqDeleteRoute+0x178> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0808: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a080c: 3001         	adds	r0, #0x1
700a080e: f8ad 0032    	strh.w	r0, [sp, #0x32]
700a0812: e749         	b	0x700a06a8 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x16e
;     return r;
700a0814: 980d         	ldr	r0, [sp, #0x34]
700a0816: b010         	add	sp, #0x40
700a0818: bd80         	pop	{r7, pc}
700a081a: 0000         	movs	r0, r0
700a081c: 0000         	movs	r0, r0
700a081e: 0000         	movs	r0, r0

700a0820 <Sciclient_rmProgramInterruptRoute>:
; {
700a0820: b580         	push	{r7, lr}
700a0822: b08e         	sub	sp, #0x38
700a0824: 900d         	str	r0, [sp, #0x34]
700a0826: 910c         	str	r1, [sp, #0x30]
700a0828: 920b         	str	r2, [sp, #0x2c]
700a082a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a082c: 9001         	str	r0, [sp, #0x4]
700a082e: 900a         	str	r0, [sp, #0x28]
700a0830: f44f 5180    	mov.w	r1, #0x1000
;     uint16_t messageType = TISCI_MSG_RM_IRQ_SET;
700a0834: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
700a0838: 9008         	str	r0, [sp, #0x20]
700a083a: 9007         	str	r0, [sp, #0x1c]
700a083c: 9006         	str	r0, [sp, #0x18]
700a083e: 9005         	str	r0, [sp, #0x14]
700a0840: 9004         	str	r0, [sp, #0x10]
700a0842: 9003         	str	r0, [sp, #0xc]
700a0844: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
700a0846: 980d         	ldr	r0, [sp, #0x34]
700a0848: b118         	cbz	r0, 0x700a0852 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #0x6
700a084a: e7ff         	b	0x700a084c <Sciclient_rmProgramInterruptRoute+0x2c> @ imm = #-0x2
700a084c: 980c         	ldr	r0, [sp, #0x30]
700a084e: b920         	cbnz	r0, 0x700a085a <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #0x8
700a0850: e7ff         	b	0x700a0852 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #-0x2
700a0852: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0856: 900a         	str	r0, [sp, #0x28]
;     }
700a0858: e7ff         	b	0x700a085a <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a085a: 980a         	ldr	r0, [sp, #0x28]
700a085c: b968         	cbnz	r0, 0x700a087a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0x1a
700a085e: e7ff         	b	0x700a0860 <Sciclient_rmProgramInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a0860: 980d         	ldr	r0, [sp, #0x34]
700a0862: 6880         	ldr	r0, [r0, #0x8]
700a0864: f04f 4100    	mov.w	r1, #0x80000000
700a0868: f00e f9f2    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0xe3e4
;     if (r == SystemP_SUCCESS &&
700a086c: b128         	cbz	r0, 0x700a087a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0xa
700a086e: e7ff         	b	0x700a0870 <Sciclient_rmProgramInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
700a0870: 980d         	ldr	r0, [sp, #0x34]
700a0872: 7ec0         	ldrb	r0, [r0, #0x1b]
700a0874: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
700a0878: e00f         	b	0x700a089a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
700a087a: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
700a087e: f007 f8c7    	bl	0x700a7a10 <Sciclient_getCurrentContext> @ imm = #0x718e
700a0882: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a0886: f241 3020    	movw	r0, #0x1320
700a088a: f2c7 000b    	movt	r0, #0x700b
700a088e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a0892: 6840         	ldr	r0, [r0, #0x4]
700a0894: f88d 0025    	strb.w	r0, [sp, #0x25]
700a0898: e7ff         	b	0x700a089a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a089a: 980a         	ldr	r0, [sp, #0x28]
700a089c: b960         	cbnz	r0, 0x700a08b8 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0x18
700a089e: e7ff         	b	0x700a08a0 <Sciclient_rmProgramInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a08a0: 980d         	ldr	r0, [sp, #0x34]
700a08a2: 6880         	ldr	r0, [r0, #0x8]
700a08a4: 2104         	movs	r1, #0x4
700a08a6: f00e f9d3    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0xe3a6
;     if (r == SystemP_SUCCESS &&
700a08aa: b128         	cbz	r0, 0x700a08b8 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0xa
700a08ac: e7ff         	b	0x700a08ae <Sciclient_rmProgramInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
700a08ae: 980d         	ldr	r0, [sp, #0x34]
700a08b0: 8a80         	ldrh	r0, [r0, #0x14]
700a08b2: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
700a08b6: e003         	b	0x700a08c0 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #0x6
700a08b8: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
700a08ba: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a08be: e7ff         	b	0x700a08c0 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a08c0: 980a         	ldr	r0, [sp, #0x28]
700a08c2: 2800         	cmp	r0, #0x0
700a08c4: d16e         	bne	0x700a09a4 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #0xdc
700a08c6: e7ff         	b	0x700a08c8 <Sciclient_rmProgramInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
700a08c8: 980d         	ldr	r0, [sp, #0x34]
700a08ca: 6880         	ldr	r0, [r0, #0x8]
700a08cc: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
700a08ce: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a08d2: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
700a08d6: 980d         	ldr	r0, [sp, #0x34]
700a08d8: 8980         	ldrh	r0, [r0, #0xc]
700a08da: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
700a08de: 980d         	ldr	r0, [sp, #0x34]
700a08e0: 89c0         	ldrh	r0, [r0, #0xe]
700a08e2: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
700a08e6: 980d         	ldr	r0, [sp, #0x34]
700a08e8: 8a00         	ldrh	r0, [r0, #0x10]
700a08ea: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
700a08ee: 980d         	ldr	r0, [sp, #0x34]
700a08f0: 8a40         	ldrh	r0, [r0, #0x12]
700a08f2: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
700a08f6: 980d         	ldr	r0, [sp, #0x34]
700a08f8: 8b00         	ldrh	r0, [r0, #0x18]
700a08fa: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
700a08fe: 980d         	ldr	r0, [sp, #0x34]
700a0900: 8ac0         	ldrh	r0, [r0, #0x16]
700a0902: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
700a0906: 980d         	ldr	r0, [sp, #0x34]
700a0908: 7e80         	ldrb	r0, [r0, #0x1a]
700a090a: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         cfg.set_resp = resp;
700a090e: 980c         	ldr	r0, [sp, #0x30]
700a0910: 9008         	str	r0, [sp, #0x20]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
700a0912: 9802         	ldr	r0, [sp, #0x8]
700a0914: f00a ff3c    	bl	0x700ab790 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xae78
700a0918: b1c8         	cbz	r0, 0x700a094e <Sciclient_rmProgramInterruptRoute+0x12e> @ imm = #0x32
700a091a: e7ff         	b	0x700a091c <Sciclient_rmProgramInterruptRoute+0xfc> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
700a091c: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a0920: f00d ff9e    	bl	0x700ae860 <Sciclient_rmIaIsIa> @ imm = #0xdf3c
700a0924: b128         	cbz	r0, 0x700a0932 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #0xa
700a0926: e7ff         	b	0x700a0928 <Sciclient_rmProgramInterruptRoute+0x108> @ imm = #-0x2
;                 cfg.vint = cfg.s_idx;
700a0928: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a092c: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             }
700a0930: e7ff         	b	0x700a0932 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #-0x2
700a0932: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqFindRoute(&cfg);
700a0934: f7fd fab4    	bl	0x7009dea0 <Sciclient_rmIrqFindRoute> @ imm = #-0x2a98
700a0938: 900a         	str	r0, [sp, #0x28]
;             if (r == SystemP_SUCCESS) {
700a093a: 980a         	ldr	r0, [sp, #0x28]
700a093c: b930         	cbnz	r0, 0x700a094c <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #0xc
700a093e: e7ff         	b	0x700a0940 <Sciclient_rmProgramInterruptRoute+0x120> @ imm = #-0x2
700a0940: a802         	add	r0, sp, #0x8
700a0942: 2100         	movs	r1, #0x0
;                 r = Sciclient_rmIrqProgramRoute(&cfg, false);
700a0944: f000 f8fc    	bl	0x700a0b40 <Sciclient_rmIrqProgramRoute> @ imm = #0x1f8
700a0948: 900a         	str	r0, [sp, #0x28]
;             }
700a094a: e7ff         	b	0x700a094c <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a094c: e029         	b	0x700a09a2 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #0x52
700a094e: 9802         	ldr	r0, [sp, #0x8]
700a0950: f00a fee6    	bl	0x700ab720 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xadcc
;                 true) ||
700a0954: b928         	cbnz	r0, 0x700a0962 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #0xa
700a0956: e7ff         	b	0x700a0958 <Sciclient_rmProgramInterruptRoute+0x138> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
700a0958: 9802         	ldr	r0, [sp, #0x8]
700a095a: f00a ff51    	bl	0x700ab800 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xaea2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a095e: b128         	cbz	r0, 0x700a096c <Sciclient_rmProgramInterruptRoute+0x14c> @ imm = #0xa
700a0960: e7ff         	b	0x700a0962 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #-0x2
700a0962: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintAdd(&cfg);
700a0964: f003 fdec    	bl	0x700a4540 <Sciclient_rmIrqVintAdd> @ imm = #0x3bd8
700a0968: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
700a096a: e019         	b	0x700a09a0 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #0x32
700a096c: 9802         	ldr	r0, [sp, #0x8]
700a096e: f00a ffb7    	bl	0x700ab8e0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xaf6e
700a0972: b128         	cbz	r0, 0x700a0980 <Sciclient_rmProgramInterruptRoute+0x160> @ imm = #0xa
700a0974: e7ff         	b	0x700a0976 <Sciclient_rmProgramInterruptRoute+0x156> @ imm = #-0x2
700a0976: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmUnmappedVintRouteCreate(&cfg);
700a0978: f00c f9b2    	bl	0x700acce0 <Sciclient_rmUnmappedVintRouteCreate> @ imm = #0xc364
700a097c: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
700a097e: e00e         	b	0x700a099e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #0x1c
700a0980: 9802         	ldr	r0, [sp, #0x8]
700a0982: f00a ff75    	bl	0x700ab870 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xaeea
700a0986: b128         	cbz	r0, 0x700a0994 <Sciclient_rmProgramInterruptRoute+0x174> @ imm = #0xa
700a0988: e7ff         	b	0x700a098a <Sciclient_rmProgramInterruptRoute+0x16a> @ imm = #-0x2
700a098a: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqProgramOesRegister(&cfg);
700a098c: f00d f8c0    	bl	0x700adb10 <Sciclient_rmIrqProgramOesRegister> @ imm = #0xd180
700a0990: 900a         	str	r0, [sp, #0x28]
;         } else {
700a0992: e003         	b	0x700a099c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #0x6
700a0994: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a0998: 900a         	str	r0, [sp, #0x28]
700a099a: e7ff         	b	0x700a099c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #-0x2
700a099c: e7ff         	b	0x700a099e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #-0x2
700a099e: e7ff         	b	0x700a09a0 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #-0x2
700a09a0: e7ff         	b	0x700a09a2 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #-0x2
;     }
700a09a2: e7ff         	b	0x700a09a4 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #-0x2
;     return r;
700a09a4: 980a         	ldr	r0, [sp, #0x28]
700a09a6: b00e         	add	sp, #0x38
700a09a8: bd80         	pop	{r7, pc}
700a09aa: 0000         	movs	r0, r0
700a09ac: 0000         	movs	r0, r0
700a09ae: 0000         	movs	r0, r0

700a09b0 <PMU_init>:
; int32_t PMU_init(PMU_Config *cfg) {
700a09b0: b580         	push	{r7, lr}
700a09b2: b08a         	sub	sp, #0x28
700a09b4: 9009         	str	r0, [sp, #0x24]
;   memset((void *)&gProfileObject, 0U, sizeof(gProfileObject));
700a09b6: f243 0080    	movw	r0, #0x3080
700a09ba: f2c7 0008    	movt	r0, #0x7008
700a09be: 9003         	str	r0, [sp, #0xc]
700a09c0: f640 510c    	movw	r1, #0xd0c
700a09c4: f7fa eae6    	blx	0x7009af94 <__aeabi_memclr8> @ imm = #-0x5a34
700a09c8: 9a03         	ldr	r2, [sp, #0xc]
700a09ca: 2000         	movs	r0, #0x0
;   gProfileObject.logIndex = 0U;
700a09cc: 9004         	str	r0, [sp, #0x10]
700a09ce: 6010         	str	r0, [r2]
;   gProfileObject.bCycleCounter = cfg->bCycleCounter;
700a09d0: 9909         	ldr	r1, [sp, #0x24]
700a09d2: 6809         	ldr	r1, [r1]
700a09d4: 6051         	str	r1, [r2, #0x4]
;   DebugP_assert(cfg->numEventCounters <= 3U);
700a09d6: 9909         	ldr	r1, [sp, #0x24]
700a09d8: 6849         	ldr	r1, [r1, #0x4]
700a09da: 2904         	cmp	r1, #0x4
700a09dc: bf38         	it	lo
700a09de: 2001         	movlo	r0, #0x1
700a09e0: f641 51e1    	movw	r1, #0x1de1
700a09e4: f2c7 010b    	movt	r1, #0x700b
700a09e8: 466a         	mov	r2, sp
700a09ea: 6011         	str	r1, [r2]
700a09ec: f242 1166    	movw	r1, #0x2166
700a09f0: f2c7 010b    	movt	r1, #0x700b
700a09f4: f242 1270    	movw	r2, #0x2170
700a09f8: f2c7 020b    	movt	r2, #0x700b
700a09fc: 236e         	movs	r3, #0x6e
700a09fe: f00a f867    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xa0ce
700a0a02: 9a03         	ldr	r2, [sp, #0xc]
700a0a04: 9804         	ldr	r0, [sp, #0x10]
;   gProfileObject.numEvents = cfg->numEventCounters;
700a0a06: 9909         	ldr	r1, [sp, #0x24]
700a0a08: 6849         	ldr	r1, [r1, #0x4]
700a0a0a: 6091         	str	r1, [r2, #0x8]
;   for (i = 0; i < PMU_MAX_LOG_ENTRIES; i++) {
700a0a0c: 9008         	str	r0, [sp, #0x20]
700a0a0e: e7ff         	b	0x700a0a10 <PMU_init+0x60> @ imm = #-0x2
700a0a10: 9808         	ldr	r0, [sp, #0x20]
700a0a12: 283f         	cmp	r0, #0x3f
700a0a14: d833         	bhi	0x700a0a7e <PMU_init+0xce> @ imm = #0x66
700a0a16: e7ff         	b	0x700a0a18 <PMU_init+0x68> @ imm = #-0x2
;     PMU_ProfilePoint *p = &gProfileObject.point[i];
700a0a18: 9808         	ldr	r0, [sp, #0x20]
700a0a1a: f243 0280    	movw	r2, #0x3080
700a0a1e: f2c7 0208    	movt	r2, #0x7008
700a0a22: 2134         	movs	r1, #0x34
700a0a24: fb00 2001    	mla	r0, r0, r1, r2
700a0a28: 300c         	adds	r0, #0xc
700a0a2a: 9006         	str	r0, [sp, #0x18]
700a0a2c: 2000         	movs	r0, #0x0
;     for (j = 0; j < cfg->numEventCounters; j++) {
700a0a2e: 9007         	str	r0, [sp, #0x1c]
700a0a30: e7ff         	b	0x700a0a32 <PMU_init+0x82> @ imm = #-0x2
700a0a32: 9807         	ldr	r0, [sp, #0x1c]
700a0a34: 9909         	ldr	r1, [sp, #0x24]
700a0a36: 6849         	ldr	r1, [r1, #0x4]
700a0a38: 4288         	cmp	r0, r1
700a0a3a: d21b         	bhs	0x700a0a74 <PMU_init+0xc4> @ imm = #0x36
700a0a3c: e7ff         	b	0x700a0a3e <PMU_init+0x8e> @ imm = #-0x2
;       p->events[j].name = cfg->eventCounters[j].name;
700a0a3e: 9809         	ldr	r0, [sp, #0x24]
700a0a40: 6880         	ldr	r0, [r0, #0x8]
700a0a42: 9a07         	ldr	r2, [sp, #0x1c]
700a0a44: eb00 00c2    	add.w	r0, r0, r2, lsl #3
700a0a48: 6840         	ldr	r0, [r0, #0x4]
700a0a4a: 9906         	ldr	r1, [sp, #0x18]
700a0a4c: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a0a50: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;       p->events[j].type = cfg->eventCounters[j].type;
700a0a54: 9809         	ldr	r0, [sp, #0x24]
700a0a56: 6880         	ldr	r0, [r0, #0x8]
700a0a58: 9a07         	ldr	r2, [sp, #0x1c]
700a0a5a: f850 0032    	ldr.w	r0, [r0, r2, lsl #3]
700a0a5e: 9906         	ldr	r1, [sp, #0x18]
700a0a60: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a0a64: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0a68: 6048         	str	r0, [r1, #0x4]
;     }
700a0a6a: e7ff         	b	0x700a0a6c <PMU_init+0xbc> @ imm = #-0x2
;     for (j = 0; j < cfg->numEventCounters; j++) {
700a0a6c: 9807         	ldr	r0, [sp, #0x1c]
700a0a6e: 3001         	adds	r0, #0x1
700a0a70: 9007         	str	r0, [sp, #0x1c]
700a0a72: e7de         	b	0x700a0a32 <PMU_init+0x82> @ imm = #-0x44
;   }
700a0a74: e7ff         	b	0x700a0a76 <PMU_init+0xc6> @ imm = #-0x2
;   for (i = 0; i < PMU_MAX_LOG_ENTRIES; i++) {
700a0a76: 9808         	ldr	r0, [sp, #0x20]
700a0a78: 3001         	adds	r0, #0x1
700a0a7a: 9008         	str	r0, [sp, #0x20]
700a0a7c: e7c8         	b	0x700a0a10 <PMU_init+0x60> @ imm = #-0x70
;   int32_t numCount = CSL_armR5PmuGetNumCntrs();
700a0a7e: f001 eab6    	blx	0x700a1fec <CSL_armR5PmuGetNumCntrs> @ imm = #0x156c
700a0a82: 9005         	str	r0, [sp, #0x14]
;   DebugP_assert(numCount == cfg->numEventCounters);
700a0a84: 9805         	ldr	r0, [sp, #0x14]
700a0a86: 9909         	ldr	r1, [sp, #0x24]
700a0a88: 6849         	ldr	r1, [r1, #0x4]
700a0a8a: 1a40         	subs	r0, r0, r1
700a0a8c: fab0 f080    	clz	r0, r0
700a0a90: 0940         	lsrs	r0, r0, #0x5
700a0a92: f641 4122    	movw	r1, #0x1c22
700a0a96: f2c7 010b    	movt	r1, #0x700b
700a0a9a: 466a         	mov	r2, sp
700a0a9c: 6011         	str	r1, [r2]
700a0a9e: f242 1166    	movw	r1, #0x2166
700a0aa2: f2c7 010b    	movt	r1, #0x700b
700a0aa6: f242 1270    	movw	r2, #0x2170
700a0aaa: f2c7 020b    	movt	r2, #0x700b
700a0aae: 237d         	movs	r3, #0x7d
700a0ab0: f00a f80e    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0xa01c
700a0ab4: 2100         	movs	r1, #0x0
700a0ab6: 9102         	str	r1, [sp, #0x8]
700a0ab8: 2201         	movs	r2, #0x1
;   CSL_armR5PmuCfg(0, 0, 1);
700a0aba: 4608         	mov	r0, r1
700a0abc: f001 ea68    	blx	0x700a1f90 <CSL_armR5PmuCfg> @ imm = #0x14d0
700a0ac0: 9802         	ldr	r0, [sp, #0x8]
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0ac2: 9008         	str	r0, [sp, #0x20]
700a0ac4: e7ff         	b	0x700a0ac6 <PMU_init+0x116> @ imm = #-0x2
700a0ac6: 9808         	ldr	r0, [sp, #0x20]
700a0ac8: 9909         	ldr	r1, [sp, #0x24]
700a0aca: 6849         	ldr	r1, [r1, #0x4]
700a0acc: 4288         	cmp	r0, r1
700a0ace: d20c         	bhs	0x700a0aea <PMU_init+0x13a> @ imm = #0x18
700a0ad0: e7ff         	b	0x700a0ad2 <PMU_init+0x122> @ imm = #-0x2
;     CSL_armR5PmuCfgCntr(i, (cfg->eventCounters[i].type & 0xFF));
700a0ad2: 9808         	ldr	r0, [sp, #0x20]
700a0ad4: 9909         	ldr	r1, [sp, #0x24]
700a0ad6: 6889         	ldr	r1, [r1, #0x8]
700a0ad8: f811 1030    	ldrb.w	r1, [r1, r0, lsl #3]
700a0adc: f001 ea8e    	blx	0x700a1ffc <CSL_armR5PmuCfgCntr> @ imm = #0x151c
;   }
700a0ae0: e7ff         	b	0x700a0ae2 <PMU_init+0x132> @ imm = #-0x2
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0ae2: 9808         	ldr	r0, [sp, #0x20]
700a0ae4: 3001         	adds	r0, #0x1
700a0ae6: 9008         	str	r0, [sp, #0x20]
700a0ae8: e7ed         	b	0x700a0ac6 <PMU_init+0x116> @ imm = #-0x26
700a0aea: 2000         	movs	r0, #0x0
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0aec: 9008         	str	r0, [sp, #0x20]
700a0aee: e7ff         	b	0x700a0af0 <PMU_init+0x140> @ imm = #-0x2
700a0af0: 9808         	ldr	r0, [sp, #0x20]
700a0af2: 9909         	ldr	r1, [sp, #0x24]
700a0af4: 6849         	ldr	r1, [r1, #0x4]
700a0af6: 4288         	cmp	r0, r1
700a0af8: d209         	bhs	0x700a0b0e <PMU_init+0x15e> @ imm = #0x12
700a0afa: e7ff         	b	0x700a0afc <PMU_init+0x14c> @ imm = #-0x2
;     CSL_armR5PmuEnableCntrOverflowIntr(i, 0);
700a0afc: 9808         	ldr	r0, [sp, #0x20]
700a0afe: 2100         	movs	r1, #0x0
700a0b00: f001 ea88    	blx	0x700a2014 <CSL_armR5PmuEnableCntrOverflowIntr> @ imm = #0x1510
;   }
700a0b04: e7ff         	b	0x700a0b06 <PMU_init+0x156> @ imm = #-0x2
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0b06: 9808         	ldr	r0, [sp, #0x20]
700a0b08: 3001         	adds	r0, #0x1
700a0b0a: 9008         	str	r0, [sp, #0x20]
700a0b0c: e7f0         	b	0x700a0af0 <PMU_init+0x140> @ imm = #-0x20
;   if (cfg->bCycleCounter == TRUE) {
700a0b0e: 9809         	ldr	r0, [sp, #0x24]
700a0b10: 6800         	ldr	r0, [r0]
700a0b12: 2801         	cmp	r0, #0x1
700a0b14: d105         	bne	0x700a0b22 <PMU_init+0x172> @ imm = #0xa
700a0b16: e7ff         	b	0x700a0b18 <PMU_init+0x168> @ imm = #-0x2
700a0b18: 201f         	movs	r0, #0x1f
700a0b1a: 2100         	movs	r1, #0x0
;     CSL_armR5PmuEnableCntrOverflowIntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM, 0);
700a0b1c: f001 ea7a    	blx	0x700a2014 <CSL_armR5PmuEnableCntrOverflowIntr> @ imm = #0x14f4
;   }
700a0b20: e7ff         	b	0x700a0b22 <PMU_init+0x172> @ imm = #-0x2
;   CSL_armR5PmuResetCntrs();
700a0b22: f001 ead0    	blx	0x700a20c4 <CSL_armR5PmuResetCntrs> @ imm = #0x15a0
;   CSL_armR5PmuResetCycleCnt();
700a0b26: f001 eac6    	blx	0x700a20b4 <CSL_armR5PmuResetCycleCnt> @ imm = #0x158c
;   PMU_enableAllCounters(cfg->numEventCounters);
700a0b2a: 9809         	ldr	r0, [sp, #0x24]
700a0b2c: 6840         	ldr	r0, [r0, #0x4]
700a0b2e: f00d facf    	bl	0x700ae0d0 <PMU_enableAllCounters> @ imm = #0xd59e
700a0b32: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
700a0b34: b00a         	add	sp, #0x28
700a0b36: bd80         	pop	{r7, pc}
		...

700a0b40 <Sciclient_rmIrqProgramRoute>:
; {
700a0b40: b580         	push	{r7, lr}
700a0b42: b092         	sub	sp, #0x48
700a0b44: 9011         	str	r0, [sp, #0x44]
700a0b46: f88d 1043    	strb.w	r1, [sp, #0x43]
700a0b4a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a0b4c: 900f         	str	r0, [sp, #0x3c]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a0b4e: 9003         	str	r0, [sp, #0xc]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
700a0b50: 9002         	str	r0, [sp, #0x8]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0b52: f8ad 003a    	strh.w	r0, [sp, #0x3a]
700a0b56: e7ff         	b	0x700a0b58 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x2
700a0b58: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0b5c: 9001         	str	r0, [sp, #0x4]
700a0b5e: f00f f86f    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0xf0de
700a0b62: 4601         	mov	r1, r0
700a0b64: 9801         	ldr	r0, [sp, #0x4]
700a0b66: 4288         	cmp	r0, r1
700a0b68: f280 80aa    	bge.w	0x700a0cc0 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0x154
700a0b6c: e7ff         	b	0x700a0b6e <Sciclient_rmIrqProgramRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a0b6e: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0b72: f00e fc25    	bl	0x700af3c0 <Sciclient_rmPsGetIrqNode> @ imm = #0xe84a
700a0b76: 900d         	str	r0, [sp, #0x34]
;         cur_inp = Sciclient_rmPsGetInp(i);
700a0b78: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0b7c: f00d f808    	bl	0x700adb90 <Sciclient_rmPsGetInp> @ imm = #0xd010
700a0b80: 900c         	str	r0, [sp, #0x30]
;         cur_outp = Sciclient_rmPsGetOutp(i);
700a0b82: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0b86: f00d f823    	bl	0x700adbd0 <Sciclient_rmPsGetOutp> @ imm = #0xd046
700a0b8a: 900b         	str	r0, [sp, #0x2c]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a0b8c: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0b90: 2800         	cmp	r0, #0x0
700a0b92: d154         	bne	0x700a0c3e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0xa8
700a0b94: e7ff         	b	0x700a0b96 <Sciclient_rmIrqProgramRoute+0x56> @ imm = #-0x2
700a0b96: 980d         	ldr	r0, [sp, #0x34]
700a0b98: 8800         	ldrh	r0, [r0]
700a0b9a: f00d fe61    	bl	0x700ae860 <Sciclient_rmIaIsIa> @ imm = #0xdcc2
700a0b9e: 2800         	cmp	r0, #0x0
700a0ba0: d04d         	beq	0x700a0c3e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x9a
700a0ba2: e7ff         	b	0x700a0ba4 <Sciclient_rmIrqProgramRoute+0x64> @ imm = #-0x2
;             (map_vint == true)) {
700a0ba4: f89d 0043    	ldrb.w	r0, [sp, #0x43]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a0ba8: 07c0         	lsls	r0, r0, #0x1f
700a0baa: 2800         	cmp	r0, #0x0
700a0bac: d047         	beq	0x700a0c3e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x8e
700a0bae: e7ff         	b	0x700a0bb0 <Sciclient_rmIrqProgramRoute+0x70> @ imm = #-0x2
700a0bb0: 203c         	movs	r0, #0x3c
700a0bb2: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a0bb6: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
700a0bb8: 9811         	ldr	r0, [sp, #0x44]
700a0bba: 7900         	ldrb	r0, [r0, #0x4]
700a0bbc: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cfg->s_id;
700a0bc0: 9811         	ldr	r0, [sp, #0x44]
700a0bc2: 88c0         	ldrh	r0, [r0, #0x6]
700a0bc4: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cfg->s_idx;
700a0bc8: 9811         	ldr	r0, [sp, #0x44]
700a0bca: 8900         	ldrh	r0, [r0, #0x8]
700a0bcc: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.ia_id = cfg->s_ia;
700a0bd0: 9811         	ldr	r0, [sp, #0x44]
700a0bd2: 8a00         	ldrh	r0, [r0, #0x10]
700a0bd4: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint = cur_outp;
700a0bd8: 980b         	ldr	r0, [sp, #0x2c]
700a0bda: f8ad 0026    	strh.w	r0, [sp, #0x26]
;             req.global_event = cur_inp;
700a0bde: 980c         	ldr	r0, [sp, #0x30]
700a0be0: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             req.vint_status_bit_index = cfg->vint_sb;
700a0be4: 9811         	ldr	r0, [sp, #0x44]
700a0be6: 7d00         	ldrb	r0, [r0, #0x14]
700a0be8: f88d 002a    	strb.w	r0, [sp, #0x2a]
;                                       cfg->set_resp,
700a0bec: 9811         	ldr	r0, [sp, #0x44]
700a0bee: 6981         	ldr	r1, [r0, #0x18]
700a0bf0: a804         	add	r0, sp, #0x10
700a0bf2: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
700a0bf6: f00b fd83    	bl	0x700ac700 <Sciclient_rmIrqSetRaw> @ imm = #0xbb06
700a0bfa: 900f         	str	r0, [sp, #0x3c]
;             if (r == SystemP_SUCCESS) {
700a0bfc: 980f         	ldr	r0, [sp, #0x3c]
700a0bfe: b9e8         	cbnz	r0, 0x700a0c3c <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #0x3a
700a0c00: e7ff         	b	0x700a0c02 <Sciclient_rmIrqProgramRoute+0xc2> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
700a0c02: 980d         	ldr	r0, [sp, #0x34]
700a0c04: 8800         	ldrh	r0, [r0]
700a0c06: f00b fbfb    	bl	0x700ac400 <Sciclient_rmIaGetInst> @ imm = #0xb7f6
700a0c0a: 9003         	str	r0, [sp, #0xc]
;                 if (ia_inst != NULL) {
700a0c0c: 9803         	ldr	r0, [sp, #0xc]
700a0c0e: b1a0         	cbz	r0, 0x700a0c3a <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #0x28
700a0c10: e7ff         	b	0x700a0c12 <Sciclient_rmIrqProgramRoute+0xd2> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]++;
700a0c12: 9803         	ldr	r0, [sp, #0xc]
700a0c14: 6901         	ldr	r1, [r0, #0x10]
700a0c16: 9a0b         	ldr	r2, [sp, #0x2c]
700a0c18: 5c88         	ldrb	r0, [r1, r2]
700a0c1a: 3001         	adds	r0, #0x1
700a0c1c: 5488         	strb	r0, [r1, r2]
;                     if ((cur_outp == 0) && (cfg->vint_sb == 0)) {
700a0c1e: 980b         	ldr	r0, [sp, #0x2c]
700a0c20: b950         	cbnz	r0, 0x700a0c38 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0x14
700a0c22: e7ff         	b	0x700a0c24 <Sciclient_rmIrqProgramRoute+0xe4> @ imm = #-0x2
700a0c24: 9811         	ldr	r0, [sp, #0x44]
700a0c26: 7d00         	ldrb	r0, [r0, #0x14]
700a0c28: b930         	cbnz	r0, 0x700a0c38 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0xc
700a0c2a: e7ff         	b	0x700a0c2c <Sciclient_rmIrqProgramRoute+0xec> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = cur_inp - ia_inst->sevt_offset;
700a0c2c: 980c         	ldr	r0, [sp, #0x30]
700a0c2e: 9903         	ldr	r1, [sp, #0xc]
700a0c30: 890a         	ldrh	r2, [r1, #0x8]
700a0c32: 1a80         	subs	r0, r0, r2
700a0c34: 8288         	strh	r0, [r1, #0x14]
;                     }
700a0c36: e7ff         	b	0x700a0c38 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #-0x2
;                 }
700a0c38: e7ff         	b	0x700a0c3a <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #-0x2
;             }
700a0c3a: e7ff         	b	0x700a0c3c <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #-0x2
;         }
700a0c3c: e7ff         	b	0x700a0c3e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #-0x2
;         if (i > 0u) {
700a0c3e: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0c42: b390         	cbz	r0, 0x700a0caa <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #0x64
700a0c44: e7ff         	b	0x700a0c46 <Sciclient_rmIrqProgramRoute+0x106> @ imm = #-0x2
700a0c46: 2003         	movs	r0, #0x3
700a0c48: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
700a0c4c: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
700a0c4e: 9811         	ldr	r0, [sp, #0x44]
700a0c50: 7900         	ldrb	r0, [r0, #0x4]
700a0c52: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cur_n->id;
700a0c56: 980d         	ldr	r0, [sp, #0x34]
700a0c58: 8800         	ldrh	r0, [r0]
700a0c5a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cur_inp;
700a0c5e: 980c         	ldr	r0, [sp, #0x30]
700a0c60: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.dst_id = cur_n->id;
700a0c64: 980d         	ldr	r0, [sp, #0x34]
700a0c66: 8800         	ldrh	r0, [r0]
700a0c68: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.dst_host_irq = cur_outp;
700a0c6c: 980b         	ldr	r0, [sp, #0x2c]
700a0c6e: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                                       cfg->set_resp,
700a0c72: 9811         	ldr	r0, [sp, #0x44]
700a0c74: 6981         	ldr	r1, [r0, #0x18]
700a0c76: a804         	add	r0, sp, #0x10
700a0c78: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
700a0c7c: f00b fd40    	bl	0x700ac700 <Sciclient_rmIrqSetRaw> @ imm = #0xba80
700a0c80: 900f         	str	r0, [sp, #0x3c]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
700a0c82: 980f         	ldr	r0, [sp, #0x3c]
700a0c84: b980         	cbnz	r0, 0x700a0ca8 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x20
700a0c86: e7ff         	b	0x700a0c88 <Sciclient_rmIrqProgramRoute+0x148> @ imm = #-0x2
700a0c88: 980b         	ldr	r0, [sp, #0x2c]
700a0c8a: b968         	cbnz	r0, 0x700a0ca8 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x1a
700a0c8c: e7ff         	b	0x700a0c8e <Sciclient_rmIrqProgramRoute+0x14e> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
700a0c8e: 980d         	ldr	r0, [sp, #0x34]
700a0c90: 8800         	ldrh	r0, [r0]
700a0c92: f00a fecd    	bl	0x700aba30 <Sciclient_rmIrGetInst> @ imm = #0xad9a
700a0c96: 9002         	str	r0, [sp, #0x8]
;                 if (ir_inst != NULL) {
700a0c98: 9802         	ldr	r0, [sp, #0x8]
700a0c9a: b120         	cbz	r0, 0x700a0ca6 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #0x8
700a0c9c: e7ff         	b	0x700a0c9e <Sciclient_rmIrqProgramRoute+0x15e> @ imm = #-0x2
;                     ir_inst->inp0_mapping = cur_outp;
700a0c9e: 980b         	ldr	r0, [sp, #0x2c]
700a0ca0: 9902         	ldr	r1, [sp, #0x8]
700a0ca2: 8188         	strh	r0, [r1, #0xc]
;                 }
700a0ca4: e7ff         	b	0x700a0ca6 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #-0x2
;             }
700a0ca6: e7ff         	b	0x700a0ca8 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #-0x2
;         }
700a0ca8: e7ff         	b	0x700a0caa <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #-0x2
;         if (r != SystemP_SUCCESS) {
700a0caa: 980f         	ldr	r0, [sp, #0x3c]
700a0cac: b108         	cbz	r0, 0x700a0cb2 <Sciclient_rmIrqProgramRoute+0x172> @ imm = #0x2
700a0cae: e7ff         	b	0x700a0cb0 <Sciclient_rmIrqProgramRoute+0x170> @ imm = #-0x2
;             break;
700a0cb0: e006         	b	0x700a0cc0 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0xc
;     }
700a0cb2: e7ff         	b	0x700a0cb4 <Sciclient_rmIrqProgramRoute+0x174> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0cb4: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0cb8: 3001         	adds	r0, #0x1
700a0cba: f8ad 003a    	strh.w	r0, [sp, #0x3a]
700a0cbe: e74b         	b	0x700a0b58 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x16a
;     return r;
700a0cc0: 980f         	ldr	r0, [sp, #0x3c]
700a0cc2: b012         	add	sp, #0x48
700a0cc4: bd80         	pop	{r7, pc}
		...
700a0cce: 0000         	movs	r0, r0

700a0cd0 <Udma_chEnableLocal>:
; {
700a0cd0: b580         	push	{r7, lr}
700a0cd2: b08e         	sub	sp, #0x38
700a0cd4: 900d         	str	r0, [sp, #0x34]
;     drvHandle = chHandle->drvHandle;
700a0cd6: 980d         	ldr	r0, [sp, #0x34]
700a0cd8: 6e80         	ldr	r0, [r0, #0x68]
700a0cda: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a0cdc: 980b         	ldr	r0, [sp, #0x2c]
700a0cde: 6800         	ldr	r0, [r0]
700a0ce0: 2801         	cmp	r0, #0x1
700a0ce2: d163         	bne	0x700a0dac <Udma_chEnableLocal+0xdc> @ imm = #0xc6
700a0ce4: e7ff         	b	0x700a0ce6 <Udma_chEnableLocal+0x16> @ imm = #-0x2
700a0ce6: 2001         	movs	r0, #0x1
;         bcdmaRtEnable.enable         = TRUE;
700a0ce8: 9005         	str	r0, [sp, #0x14]
700a0cea: 2000         	movs	r0, #0x0
;         bcdmaRtEnable.teardown       = FALSE;
700a0cec: 9006         	str	r0, [sp, #0x18]
;         bcdmaRtEnable.forcedTeardown = FALSE;
700a0cee: 9009         	str	r0, [sp, #0x24]
;         bcdmaRtEnable.pause          = FALSE;
700a0cf0: 9007         	str	r0, [sp, #0x1c]
;         bcdmaRtEnable.error          = FALSE;
700a0cf2: 9008         	str	r0, [sp, #0x20]
;         if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a0cf4: 980d         	ldr	r0, [sp, #0x34]
700a0cf6: 7800         	ldrb	r0, [r0]
700a0cf8: 0740         	lsls	r0, r0, #0x1d
700a0cfa: 2800         	cmp	r0, #0x0
700a0cfc: d508         	bpl	0x700a0d10 <Udma_chEnableLocal+0x40> @ imm = #0x10
700a0cfe: e7ff         	b	0x700a0d00 <Udma_chEnableLocal+0x30> @ imm = #-0x2
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum , &bcdmaRtEnable);
700a0d00: 980b         	ldr	r0, [sp, #0x2c]
700a0d02: 3008         	adds	r0, #0x8
700a0d04: 990d         	ldr	r1, [sp, #0x34]
700a0d06: 6ec9         	ldr	r1, [r1, #0x6c]
700a0d08: aa05         	add	r2, sp, #0x14
700a0d0a: f00d fec9    	bl	0x700aeaa0 <CSL_bcdmaSetTxRT> @ imm = #0xdd92
;         }
700a0d0e: e04c         	b	0x700a0daa <Udma_chEnableLocal+0xda> @ imm = #0x98
;         else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a0d10: 980d         	ldr	r0, [sp, #0x34]
700a0d12: 7800         	ldrb	r0, [r0]
700a0d14: 07c0         	lsls	r0, r0, #0x1f
700a0d16: b300         	cbz	r0, 0x700a0d5a <Udma_chEnableLocal+0x8a> @ imm = #0x40
700a0d18: e7ff         	b	0x700a0d1a <Udma_chEnableLocal+0x4a> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaTxRtRegs->PEER8);
700a0d1a: 980d         	ldr	r0, [sp, #0x34]
700a0d1c: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a0d20: f500 7008    	add.w	r0, r0, #0x220
700a0d24: f00e ff74    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xeee8
700a0d28: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a0d2a: 980c         	ldr	r0, [sp, #0x30]
700a0d2c: f040 4000    	orr	r0, r0, #0x80000000
700a0d30: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaTxRtRegs->PEER8, regVal);
700a0d32: 980d         	ldr	r0, [sp, #0x34]
700a0d34: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a0d38: f500 7008    	add.w	r0, r0, #0x220
700a0d3c: 990c         	ldr	r1, [sp, #0x30]
700a0d3e: f00e fec7    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0xed8e
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtEnable);
700a0d42: 9a0b         	ldr	r2, [sp, #0x2c]
700a0d44: f102 0008    	add.w	r0, r2, #0x8
700a0d48: 990d         	ldr	r1, [sp, #0x34]
700a0d4a: 6ec9         	ldr	r1, [r1, #0x6c]
700a0d4c: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
700a0d50: 4411         	add	r1, r2
700a0d52: aa05         	add	r2, sp, #0x14
700a0d54: f00d fea4    	bl	0x700aeaa0 <CSL_bcdmaSetTxRT> @ imm = #0xdd48
;         }
700a0d58: e026         	b	0x700a0da8 <Udma_chEnableLocal+0xd8> @ imm = #0x4c
;         else if ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a0d5a: 980d         	ldr	r0, [sp, #0x34]
700a0d5c: 7800         	ldrb	r0, [r0]
700a0d5e: 0780         	lsls	r0, r0, #0x1e
700a0d60: 2800         	cmp	r0, #0x0
700a0d62: d520         	bpl	0x700a0da6 <Udma_chEnableLocal+0xd6> @ imm = #0x40
700a0d64: e7ff         	b	0x700a0d66 <Udma_chEnableLocal+0x96> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtEnable);
700a0d66: 9a0b         	ldr	r2, [sp, #0x2c]
700a0d68: f102 0008    	add.w	r0, r2, #0x8
700a0d6c: 990d         	ldr	r1, [sp, #0x34]
700a0d6e: 6f09         	ldr	r1, [r1, #0x70]
700a0d70: f8d2 2114    	ldr.w	r2, [r2, #0x114]
700a0d74: 4411         	add	r1, r2
700a0d76: aa05         	add	r2, sp, #0x14
;             (void) CSL_bcdmaSetRxRT(
700a0d78: f00d fe7a    	bl	0x700aea70 <CSL_bcdmaSetRxRT> @ imm = #0xdcf4
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
700a0d7c: 980d         	ldr	r0, [sp, #0x34]
700a0d7e: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a0d82: f500 7008    	add.w	r0, r0, #0x220
700a0d86: f00e ff43    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xee86
700a0d8a: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a0d8c: 980c         	ldr	r0, [sp, #0x30]
700a0d8e: f040 4000    	orr	r0, r0, #0x80000000
700a0d92: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
700a0d94: 980d         	ldr	r0, [sp, #0x34]
700a0d96: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a0d9a: f500 7008    	add.w	r0, r0, #0x220
700a0d9e: 990c         	ldr	r1, [sp, #0x30]
700a0da0: f00e fe96    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0xed2c
;         }
700a0da4: e7ff         	b	0x700a0da6 <Udma_chEnableLocal+0xd6> @ imm = #-0x2
700a0da6: e7ff         	b	0x700a0da8 <Udma_chEnableLocal+0xd8> @ imm = #-0x2
700a0da8: e7ff         	b	0x700a0daa <Udma_chEnableLocal+0xda> @ imm = #-0x2
;     }
700a0daa: e050         	b	0x700a0e4e <Udma_chEnableLocal+0x17e> @ imm = #0xa0
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a0dac: 980b         	ldr	r0, [sp, #0x2c]
700a0dae: 6800         	ldr	r0, [r0]
700a0db0: 2802         	cmp	r0, #0x2
700a0db2: d14b         	bne	0x700a0e4c <Udma_chEnableLocal+0x17c> @ imm = #0x96
700a0db4: e7ff         	b	0x700a0db6 <Udma_chEnableLocal+0xe6> @ imm = #-0x2
700a0db6: 2001         	movs	r0, #0x1
;         pktdmaRtEnable.enable         = TRUE;
700a0db8: 9000         	str	r0, [sp]
700a0dba: 2000         	movs	r0, #0x0
;         pktdmaRtEnable.teardown       = FALSE;
700a0dbc: 9001         	str	r0, [sp, #0x4]
;         pktdmaRtEnable.forcedTeardown = FALSE;
700a0dbe: 9004         	str	r0, [sp, #0x10]
;         pktdmaRtEnable.pause          = FALSE;
700a0dc0: 9002         	str	r0, [sp, #0x8]
;         pktdmaRtEnable.error          = FALSE;
700a0dc2: 9003         	str	r0, [sp, #0xc]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a0dc4: 980d         	ldr	r0, [sp, #0x34]
700a0dc6: 7800         	ldrb	r0, [r0]
700a0dc8: 07c0         	lsls	r0, r0, #0x1f
700a0dca: b1e0         	cbz	r0, 0x700a0e06 <Udma_chEnableLocal+0x136> @ imm = #0x38
700a0dcc: e7ff         	b	0x700a0dce <Udma_chEnableLocal+0xfe> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaTxRtRegs->PEER8);
700a0dce: 980d         	ldr	r0, [sp, #0x34]
700a0dd0: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a0dd4: f500 7008    	add.w	r0, r0, #0x220
700a0dd8: f00e ff1a    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xee34
700a0ddc: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a0dde: 980c         	ldr	r0, [sp, #0x30]
700a0de0: f040 4000    	orr	r0, r0, #0x80000000
700a0de4: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaTxRtRegs->PEER8, regVal);
700a0de6: 980d         	ldr	r0, [sp, #0x34]
700a0de8: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a0dec: f500 7008    	add.w	r0, r0, #0x220
700a0df0: 990c         	ldr	r1, [sp, #0x30]
700a0df2: f00e fe6d    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0xecda
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtEnable);
700a0df6: 980b         	ldr	r0, [sp, #0x2c]
700a0df8: 3054         	adds	r0, #0x54
700a0dfa: 990d         	ldr	r1, [sp, #0x34]
700a0dfc: 6ec9         	ldr	r1, [r1, #0x6c]
700a0dfe: 466a         	mov	r2, sp
700a0e00: f00d f866    	bl	0x700aded0 <CSL_pktdmaSetTxRT> @ imm = #0xd0cc
;         }
700a0e04: e7ff         	b	0x700a0e06 <Udma_chEnableLocal+0x136> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a0e06: 980d         	ldr	r0, [sp, #0x34]
700a0e08: 7800         	ldrb	r0, [r0]
700a0e0a: 0780         	lsls	r0, r0, #0x1e
700a0e0c: 2800         	cmp	r0, #0x0
700a0e0e: d51c         	bpl	0x700a0e4a <Udma_chEnableLocal+0x17a> @ imm = #0x38
700a0e10: e7ff         	b	0x700a0e12 <Udma_chEnableLocal+0x142> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtEnable);
700a0e12: 980b         	ldr	r0, [sp, #0x2c]
700a0e14: 3054         	adds	r0, #0x54
700a0e16: 990d         	ldr	r1, [sp, #0x34]
700a0e18: 6f09         	ldr	r1, [r1, #0x70]
700a0e1a: 466a         	mov	r2, sp
;             (void) CSL_pktdmaSetRxRT(
700a0e1c: f00d f838    	bl	0x700ade90 <CSL_pktdmaSetRxRT> @ imm = #0xd070
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
700a0e20: 980d         	ldr	r0, [sp, #0x34]
700a0e22: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a0e26: f500 7008    	add.w	r0, r0, #0x220
700a0e2a: f00e fef1    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xede2
700a0e2e: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a0e30: 980c         	ldr	r0, [sp, #0x30]
700a0e32: f040 4000    	orr	r0, r0, #0x80000000
700a0e36: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
700a0e38: 980d         	ldr	r0, [sp, #0x34]
700a0e3a: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a0e3e: f500 7008    	add.w	r0, r0, #0x220
700a0e42: 990c         	ldr	r1, [sp, #0x30]
700a0e44: f00e fe44    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0xec88
;         }
700a0e48: e7ff         	b	0x700a0e4a <Udma_chEnableLocal+0x17a> @ imm = #-0x2
;     }
700a0e4a: e7ff         	b	0x700a0e4c <Udma_chEnableLocal+0x17c> @ imm = #-0x2
700a0e4c: e7ff         	b	0x700a0e4e <Udma_chEnableLocal+0x17e> @ imm = #-0x2
;     return;
700a0e4e: b00e         	add	sp, #0x38
700a0e50: bd80         	pop	{r7, pc}
		...
700a0e5e: 0000         	movs	r0, r0

700a0e60 <Udma_chConfigPdma>:
; {
700a0e60: b580         	push	{r7, lr}
700a0e62: b08a         	sub	sp, #0x28
700a0e64: 9009         	str	r0, [sp, #0x24]
700a0e66: 9108         	str	r1, [sp, #0x20]
700a0e68: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a0e6a: 9007         	str	r0, [sp, #0x1c]
;     volatile uint32_t  *PEER8=NULL, *PEER0=NULL, *PEER1=NULL;
700a0e6c: 9006         	str	r0, [sp, #0x18]
700a0e6e: 9005         	str	r0, [sp, #0x14]
700a0e70: 9004         	str	r0, [sp, #0x10]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a0e72: 9809         	ldr	r0, [sp, #0x24]
700a0e74: 9002         	str	r0, [sp, #0x8]
;     if((NULL_PTR == chHandleInt) ||
700a0e76: 9802         	ldr	r0, [sp, #0x8]
700a0e78: b1a0         	cbz	r0, 0x700a0ea4 <Udma_chConfigPdma+0x44> @ imm = #0x28
700a0e7a: e7ff         	b	0x700a0e7c <Udma_chConfigPdma+0x1c> @ imm = #-0x2
;        (NULL_PTR == pdmaPrms) ||
700a0e7c: 9808         	ldr	r0, [sp, #0x20]
700a0e7e: b188         	cbz	r0, 0x700a0ea4 <Udma_chConfigPdma+0x44> @ imm = #0x22
700a0e80: e7ff         	b	0x700a0e82 <Udma_chConfigPdma+0x22> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
700a0e82: 9802         	ldr	r0, [sp, #0x8]
700a0e84: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a0e88: f64a 31cd    	movw	r1, #0xabcd
700a0e8c: f6ca 31dc    	movt	r1, #0xabdc
700a0e90: 4288         	cmp	r0, r1
700a0e92: d107         	bne	0x700a0ea4 <Udma_chConfigPdma+0x44> @ imm = #0xe
700a0e94: e7ff         	b	0x700a0e96 <Udma_chConfigPdma+0x36> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_PDMA) != UDMA_CH_FLAG_PDMA))
700a0e96: 9802         	ldr	r0, [sp, #0x8]
700a0e98: 6800         	ldr	r0, [r0]
700a0e9a: f000 0008    	and	r0, r0, #0x8
;     if((NULL_PTR == chHandleInt) ||
700a0e9e: 2808         	cmp	r0, #0x8
700a0ea0: d004         	beq	0x700a0eac <Udma_chConfigPdma+0x4c> @ imm = #0x8
700a0ea2: e7ff         	b	0x700a0ea4 <Udma_chConfigPdma+0x44> @ imm = #-0x2
700a0ea4: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a0ea8: 9007         	str	r0, [sp, #0x1c]
;     }
700a0eaa: e7ff         	b	0x700a0eac <Udma_chConfigPdma+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a0eac: 9807         	ldr	r0, [sp, #0x1c]
700a0eae: b9a8         	cbnz	r0, 0x700a0edc <Udma_chConfigPdma+0x7c> @ imm = #0x2a
700a0eb0: e7ff         	b	0x700a0eb2 <Udma_chConfigPdma+0x52> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a0eb2: 9802         	ldr	r0, [sp, #0x8]
700a0eb4: 6e80         	ldr	r0, [r0, #0x68]
700a0eb6: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a0eb8: 9803         	ldr	r0, [sp, #0xc]
700a0eba: b150         	cbz	r0, 0x700a0ed2 <Udma_chConfigPdma+0x72> @ imm = #0x14
700a0ebc: e7ff         	b	0x700a0ebe <Udma_chConfigPdma+0x5e> @ imm = #-0x2
700a0ebe: 9803         	ldr	r0, [sp, #0xc]
700a0ec0: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a0ec4: f64a 31cd    	movw	r1, #0xabcd
700a0ec8: f6ca 31dc    	movt	r1, #0xabdc
700a0ecc: 4288         	cmp	r0, r1
700a0ece: d004         	beq	0x700a0eda <Udma_chConfigPdma+0x7a> @ imm = #0x8
700a0ed0: e7ff         	b	0x700a0ed2 <Udma_chConfigPdma+0x72> @ imm = #-0x2
700a0ed2: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a0ed6: 9007         	str	r0, [sp, #0x1c]
;         }
700a0ed8: e7ff         	b	0x700a0eda <Udma_chConfigPdma+0x7a> @ imm = #-0x2
;     }
700a0eda: e7ff         	b	0x700a0edc <Udma_chConfigPdma+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a0edc: 9807         	ldr	r0, [sp, #0x1c]
700a0ede: 2800         	cmp	r0, #0x0
700a0ee0: d17a         	bne	0x700a0fd8 <Udma_chConfigPdma+0x178> @ imm = #0xf4
700a0ee2: e7ff         	b	0x700a0ee4 <Udma_chConfigPdma+0x84> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a0ee4: 9803         	ldr	r0, [sp, #0xc]
700a0ee6: 6800         	ldr	r0, [r0]
700a0ee8: 2801         	cmp	r0, #0x1
700a0eea: d137         	bne	0x700a0f5c <Udma_chConfigPdma+0xfc> @ imm = #0x6e
700a0eec: e7ff         	b	0x700a0eee <Udma_chConfigPdma+0x8e> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a0eee: 9802         	ldr	r0, [sp, #0x8]
700a0ef0: 7800         	ldrb	r0, [r0]
700a0ef2: 07c0         	lsls	r0, r0, #0x1f
700a0ef4: b198         	cbz	r0, 0x700a0f1e <Udma_chConfigPdma+0xbe> @ imm = #0x26
700a0ef6: e7ff         	b	0x700a0ef8 <Udma_chConfigPdma+0x98> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pBcdmaTxRtRegs->PEER8;
700a0ef8: 9802         	ldr	r0, [sp, #0x8]
700a0efa: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a0efe: f500 7008    	add.w	r0, r0, #0x220
700a0f02: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaTxRtRegs->PEER1;
700a0f04: 9802         	ldr	r0, [sp, #0x8]
700a0f06: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a0f0a: f500 7001    	add.w	r0, r0, #0x204
700a0f0e: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaTxRtRegs->PEER0;
700a0f10: 9802         	ldr	r0, [sp, #0x8]
700a0f12: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a0f16: f500 7000    	add.w	r0, r0, #0x200
700a0f1a: 9005         	str	r0, [sp, #0x14]
;             }
700a0f1c: e012         	b	0x700a0f44 <Udma_chConfigPdma+0xe4> @ imm = #0x24
;                 PEER8 = &chHandleInt->pBcdmaRxRtRegs->PEER8;
700a0f1e: 9802         	ldr	r0, [sp, #0x8]
700a0f20: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a0f24: f500 7008    	add.w	r0, r0, #0x220
700a0f28: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaRxRtRegs->PEER1;
700a0f2a: 9802         	ldr	r0, [sp, #0x8]
700a0f2c: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a0f30: f500 7001    	add.w	r0, r0, #0x204
700a0f34: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaRxRtRegs->PEER0;
700a0f36: 9802         	ldr	r0, [sp, #0x8]
700a0f38: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a0f3c: f500 7000    	add.w	r0, r0, #0x200
700a0f40: 9005         	str	r0, [sp, #0x14]
700a0f42: e7ff         	b	0x700a0f44 <Udma_chConfigPdma+0xe4> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
700a0f44: 9803         	ldr	r0, [sp, #0xc]
700a0f46: 9908         	ldr	r1, [sp, #0x20]
700a0f48: 9a06         	ldr	r2, [sp, #0x18]
700a0f4a: 9b04         	ldr	r3, [sp, #0x10]
700a0f4c: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a0f50: 46ee         	mov	lr, sp
700a0f52: f8ce c000    	str.w	r12, [lr]
700a0f56: f00b fe33    	bl	0x700acbc0 <Udma_chSetPeerReg> @ imm = #0xbc66
;         }
700a0f5a: e03c         	b	0x700a0fd6 <Udma_chConfigPdma+0x176> @ imm = #0x78
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a0f5c: 9803         	ldr	r0, [sp, #0xc]
700a0f5e: 6800         	ldr	r0, [r0]
700a0f60: 2802         	cmp	r0, #0x2
700a0f62: d137         	bne	0x700a0fd4 <Udma_chConfigPdma+0x174> @ imm = #0x6e
700a0f64: e7ff         	b	0x700a0f66 <Udma_chConfigPdma+0x106> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a0f66: 9802         	ldr	r0, [sp, #0x8]
700a0f68: 7800         	ldrb	r0, [r0]
700a0f6a: 07c0         	lsls	r0, r0, #0x1f
700a0f6c: b198         	cbz	r0, 0x700a0f96 <Udma_chConfigPdma+0x136> @ imm = #0x26
700a0f6e: e7ff         	b	0x700a0f70 <Udma_chConfigPdma+0x110> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pPktdmaTxRtRegs->PEER8;
700a0f70: 9802         	ldr	r0, [sp, #0x8]
700a0f72: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a0f76: f500 7008    	add.w	r0, r0, #0x220
700a0f7a: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaTxRtRegs->PEER1;
700a0f7c: 9802         	ldr	r0, [sp, #0x8]
700a0f7e: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a0f82: f500 7001    	add.w	r0, r0, #0x204
700a0f86: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaTxRtRegs->PEER0;
700a0f88: 9802         	ldr	r0, [sp, #0x8]
700a0f8a: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a0f8e: f500 7000    	add.w	r0, r0, #0x200
700a0f92: 9005         	str	r0, [sp, #0x14]
;             }
700a0f94: e012         	b	0x700a0fbc <Udma_chConfigPdma+0x15c> @ imm = #0x24
;                 PEER8 = &chHandleInt->pPktdmaRxRtRegs->PEER8;
700a0f96: 9802         	ldr	r0, [sp, #0x8]
700a0f98: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a0f9c: f500 7008    	add.w	r0, r0, #0x220
700a0fa0: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaRxRtRegs->PEER1;
700a0fa2: 9802         	ldr	r0, [sp, #0x8]
700a0fa4: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a0fa8: f500 7001    	add.w	r0, r0, #0x204
700a0fac: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaRxRtRegs->PEER0;
700a0fae: 9802         	ldr	r0, [sp, #0x8]
700a0fb0: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a0fb4: f500 7000    	add.w	r0, r0, #0x200
700a0fb8: 9005         	str	r0, [sp, #0x14]
700a0fba: e7ff         	b	0x700a0fbc <Udma_chConfigPdma+0x15c> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
700a0fbc: 9803         	ldr	r0, [sp, #0xc]
700a0fbe: 9908         	ldr	r1, [sp, #0x20]
700a0fc0: 9a06         	ldr	r2, [sp, #0x18]
700a0fc2: 9b04         	ldr	r3, [sp, #0x10]
700a0fc4: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a0fc8: 46ee         	mov	lr, sp
700a0fca: f8ce c000    	str.w	r12, [lr]
700a0fce: f00b fdf7    	bl	0x700acbc0 <Udma_chSetPeerReg> @ imm = #0xbbee
;         }
700a0fd2: e7ff         	b	0x700a0fd4 <Udma_chConfigPdma+0x174> @ imm = #-0x2
700a0fd4: e7ff         	b	0x700a0fd6 <Udma_chConfigPdma+0x176> @ imm = #-0x2
;     }
700a0fd6: e7ff         	b	0x700a0fd8 <Udma_chConfigPdma+0x178> @ imm = #-0x2
;     return (retVal);
700a0fd8: 9807         	ldr	r0, [sp, #0x1c]
700a0fda: b00a         	add	sp, #0x28
700a0fdc: bd80         	pop	{r7, pc}
700a0fde: 0000         	movs	r0, r0

700a0fe0 <HighPrioTask>:
; {
700a0fe0: b5f0         	push	{r4, r5, r6, r7, lr}
700a0fe2: b081         	sub	sp, #0x4
700a0fe4: f644 2778    	movw	r7, #0x4a78
700a0fe8: 2600         	movs	r6, #0x0
700a0fea: f2c7 0708    	movt	r7, #0x7008
700a0fee: e007         	b	0x700a1000 <HighPrioTask+0x20> @ imm = #0xe
;       tm_thread_sleep_ticks(5);
700a0ff0: 2005         	movs	r0, #0x5
700a0ff2: f00e febd    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xed7a
;    for (int i = 0; i < ITERATION_COUNT; i++)
700a0ff6: 3640         	adds	r6, #0x40
700a0ff8: f5b6 7f80    	cmp.w	r6, #0x100
700a0ffc: f000 80a6    	beq.w	0x700a114c <HighPrioTask+0x16c> @ imm = #0x14c
;       tm_thread_sleep_ticks(15);
700a1000: 200f         	movs	r0, #0xf
700a1002: f00e feb5    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xed6a
;       tm_pmu_profile_start(pmu_names[i]);
700a1006: 19bc         	adds	r4, r7, r6
700a1008: 4620         	mov	r0, r4
700a100a: f00e fea9    	bl	0x700afd60 <tm_pmu_profile_start> @ imm = #0xed52
;       if (tm_mutex_get(SHARED_MUTEX_ID) == TM_SUCCESS)
700a100e: 2001         	movs	r0, #0x1
700a1010: f00e fa46    	bl	0x700af4a0 <tm_mutex_get> @ imm = #0xe48c
700a1014: b928         	cbnz	r0, 0x700a1022 <HighPrioTask+0x42> @ imm = #0xa
;          tm_pmu_profile_end(pmu_names[i]);
700a1016: 4620         	mov	r0, r4
700a1018: f00e fe92    	bl	0x700afd40 <tm_pmu_profile_end> @ imm = #0xed24
;          tm_mutex_put(SHARED_MUTEX_ID);
700a101c: 2001         	movs	r0, #0x1
700a101e: f00e f97f    	bl	0x700af320 <tm_mutex_put> @ imm = #0xe2fe
;       tm_thread_sleep_ticks(5);
700a1022: 2005         	movs	r0, #0x5
700a1024: f00e fea4    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xed48
;       tm_thread_sleep_ticks(15);
700a1028: 200f         	movs	r0, #0xf
700a102a: f00e fea1    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xed42
;       tm_pmu_profile_start(pmu_names[i]);
700a102e: f104 0508    	add.w	r5, r4, #0x8
700a1032: 4628         	mov	r0, r5
700a1034: f00e fe94    	bl	0x700afd60 <tm_pmu_profile_start> @ imm = #0xed28
;       if (tm_mutex_get(SHARED_MUTEX_ID) == TM_SUCCESS)
700a1038: 2001         	movs	r0, #0x1
700a103a: f00e fa31    	bl	0x700af4a0 <tm_mutex_get> @ imm = #0xe462
700a103e: b928         	cbnz	r0, 0x700a104c <HighPrioTask+0x6c> @ imm = #0xa
;          tm_pmu_profile_end(pmu_names[i]);
700a1040: 4628         	mov	r0, r5
700a1042: f00e fe7d    	bl	0x700afd40 <tm_pmu_profile_end> @ imm = #0xecfa
;          tm_mutex_put(SHARED_MUTEX_ID);
700a1046: 2001         	movs	r0, #0x1
700a1048: f00e f96a    	bl	0x700af320 <tm_mutex_put> @ imm = #0xe2d4
;       tm_thread_sleep_ticks(5);
700a104c: 2005         	movs	r0, #0x5
700a104e: f00e fe8f    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xed1e
;       tm_thread_sleep_ticks(15);
700a1052: 200f         	movs	r0, #0xf
700a1054: f00e fe8c    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xed18
;       tm_pmu_profile_start(pmu_names[i]);
700a1058: f104 0510    	add.w	r5, r4, #0x10
700a105c: 4628         	mov	r0, r5
700a105e: f00e fe7f    	bl	0x700afd60 <tm_pmu_profile_start> @ imm = #0xecfe
;       if (tm_mutex_get(SHARED_MUTEX_ID) == TM_SUCCESS)
700a1062: 2001         	movs	r0, #0x1
700a1064: f00e fa1c    	bl	0x700af4a0 <tm_mutex_get> @ imm = #0xe438
700a1068: b928         	cbnz	r0, 0x700a1076 <HighPrioTask+0x96> @ imm = #0xa
;          tm_pmu_profile_end(pmu_names[i]);
700a106a: 4628         	mov	r0, r5
700a106c: f00e fe68    	bl	0x700afd40 <tm_pmu_profile_end> @ imm = #0xecd0
;          tm_mutex_put(SHARED_MUTEX_ID);
700a1070: 2001         	movs	r0, #0x1
700a1072: f00e f955    	bl	0x700af320 <tm_mutex_put> @ imm = #0xe2aa
;       tm_thread_sleep_ticks(5);
700a1076: 2005         	movs	r0, #0x5
700a1078: f00e fe7a    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xecf4
;       tm_thread_sleep_ticks(15);
700a107c: 200f         	movs	r0, #0xf
700a107e: f00e fe77    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xecee
;       tm_pmu_profile_start(pmu_names[i]);
700a1082: f104 0518    	add.w	r5, r4, #0x18
700a1086: 4628         	mov	r0, r5
700a1088: f00e fe6a    	bl	0x700afd60 <tm_pmu_profile_start> @ imm = #0xecd4
;       if (tm_mutex_get(SHARED_MUTEX_ID) == TM_SUCCESS)
700a108c: 2001         	movs	r0, #0x1
700a108e: f00e fa07    	bl	0x700af4a0 <tm_mutex_get> @ imm = #0xe40e
700a1092: b928         	cbnz	r0, 0x700a10a0 <HighPrioTask+0xc0> @ imm = #0xa
;          tm_pmu_profile_end(pmu_names[i]);
700a1094: 4628         	mov	r0, r5
700a1096: f00e fe53    	bl	0x700afd40 <tm_pmu_profile_end> @ imm = #0xeca6
;          tm_mutex_put(SHARED_MUTEX_ID);
700a109a: 2001         	movs	r0, #0x1
700a109c: f00e f940    	bl	0x700af320 <tm_mutex_put> @ imm = #0xe280
;       tm_thread_sleep_ticks(5);
700a10a0: 2005         	movs	r0, #0x5
700a10a2: f00e fe65    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xecca
;       tm_thread_sleep_ticks(15);
700a10a6: 200f         	movs	r0, #0xf
700a10a8: f00e fe62    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xecc4
;       tm_pmu_profile_start(pmu_names[i]);
700a10ac: f104 0520    	add.w	r5, r4, #0x20
700a10b0: 4628         	mov	r0, r5
700a10b2: f00e fe55    	bl	0x700afd60 <tm_pmu_profile_start> @ imm = #0xecaa
;       if (tm_mutex_get(SHARED_MUTEX_ID) == TM_SUCCESS)
700a10b6: 2001         	movs	r0, #0x1
700a10b8: f00e f9f2    	bl	0x700af4a0 <tm_mutex_get> @ imm = #0xe3e4
700a10bc: b928         	cbnz	r0, 0x700a10ca <HighPrioTask+0xea> @ imm = #0xa
;          tm_pmu_profile_end(pmu_names[i]);
700a10be: 4628         	mov	r0, r5
700a10c0: f00e fe3e    	bl	0x700afd40 <tm_pmu_profile_end> @ imm = #0xec7c
;          tm_mutex_put(SHARED_MUTEX_ID);
700a10c4: 2001         	movs	r0, #0x1
700a10c6: f00e f92b    	bl	0x700af320 <tm_mutex_put> @ imm = #0xe256
;       tm_thread_sleep_ticks(5);
700a10ca: 2005         	movs	r0, #0x5
700a10cc: f00e fe50    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xeca0
;       tm_thread_sleep_ticks(15);
700a10d0: 200f         	movs	r0, #0xf
700a10d2: f00e fe4d    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xec9a
;       tm_pmu_profile_start(pmu_names[i]);
700a10d6: f104 0528    	add.w	r5, r4, #0x28
700a10da: 4628         	mov	r0, r5
700a10dc: f00e fe40    	bl	0x700afd60 <tm_pmu_profile_start> @ imm = #0xec80
;       if (tm_mutex_get(SHARED_MUTEX_ID) == TM_SUCCESS)
700a10e0: 2001         	movs	r0, #0x1
700a10e2: f00e f9dd    	bl	0x700af4a0 <tm_mutex_get> @ imm = #0xe3ba
700a10e6: b928         	cbnz	r0, 0x700a10f4 <HighPrioTask+0x114> @ imm = #0xa
;          tm_pmu_profile_end(pmu_names[i]);
700a10e8: 4628         	mov	r0, r5
700a10ea: f00e fe29    	bl	0x700afd40 <tm_pmu_profile_end> @ imm = #0xec52
;          tm_mutex_put(SHARED_MUTEX_ID);
700a10ee: 2001         	movs	r0, #0x1
700a10f0: f00e f916    	bl	0x700af320 <tm_mutex_put> @ imm = #0xe22c
;       tm_thread_sleep_ticks(5);
700a10f4: 2005         	movs	r0, #0x5
700a10f6: f00e fe3b    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xec76
;       tm_thread_sleep_ticks(15);
700a10fa: 200f         	movs	r0, #0xf
700a10fc: f00e fe38    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xec70
;       tm_pmu_profile_start(pmu_names[i]);
700a1100: f104 0530    	add.w	r5, r4, #0x30
700a1104: 4628         	mov	r0, r5
700a1106: f00e fe2b    	bl	0x700afd60 <tm_pmu_profile_start> @ imm = #0xec56
;       if (tm_mutex_get(SHARED_MUTEX_ID) == TM_SUCCESS)
700a110a: 2001         	movs	r0, #0x1
700a110c: f00e f9c8    	bl	0x700af4a0 <tm_mutex_get> @ imm = #0xe390
700a1110: b928         	cbnz	r0, 0x700a111e <HighPrioTask+0x13e> @ imm = #0xa
;          tm_pmu_profile_end(pmu_names[i]);
700a1112: 4628         	mov	r0, r5
700a1114: f00e fe14    	bl	0x700afd40 <tm_pmu_profile_end> @ imm = #0xec28
;          tm_mutex_put(SHARED_MUTEX_ID);
700a1118: 2001         	movs	r0, #0x1
700a111a: f00e f901    	bl	0x700af320 <tm_mutex_put> @ imm = #0xe202
;       tm_thread_sleep_ticks(5);
700a111e: 2005         	movs	r0, #0x5
700a1120: f00e fe26    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xec4c
;       tm_thread_sleep_ticks(15);
700a1124: 200f         	movs	r0, #0xf
700a1126: f00e fe23    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xec46
;       tm_pmu_profile_start(pmu_names[i]);
700a112a: 3438         	adds	r4, #0x38
700a112c: 4620         	mov	r0, r4
700a112e: f00e fe17    	bl	0x700afd60 <tm_pmu_profile_start> @ imm = #0xec2e
;       if (tm_mutex_get(SHARED_MUTEX_ID) == TM_SUCCESS)
700a1132: 2001         	movs	r0, #0x1
700a1134: f00e f9b4    	bl	0x700af4a0 <tm_mutex_get> @ imm = #0xe368
700a1138: 2800         	cmp	r0, #0x0
700a113a: f47f af59    	bne.w	0x700a0ff0 <HighPrioTask+0x10> @ imm = #-0x14e
;          tm_pmu_profile_end(pmu_names[i]);
700a113e: 4620         	mov	r0, r4
700a1140: f00e fdfe    	bl	0x700afd40 <tm_pmu_profile_end> @ imm = #0xebfc
;          tm_mutex_put(SHARED_MUTEX_ID);
700a1144: 2001         	movs	r0, #0x1
700a1146: f00e f8eb    	bl	0x700af320 <tm_mutex_put> @ imm = #0xe1d6
700a114a: e751         	b	0x700a0ff0 <HighPrioTask+0x10> @ imm = #-0x15e
;    tm_thread_suspend(HIGH_TASK_ID);
700a114c: 2000         	movs	r0, #0x0
700a114e: b001         	add	sp, #0x4
700a1150: e8bd 40f0    	pop.w	{r4, r5, r6, r7, lr}
700a1154: f00e bbcc    	b.w	0x700af8f0 <tm_thread_suspend> @ imm = #0xe798
		...

700a1160 <xQueueSemaphoreTake>:
; {
700a1160: b580         	push	{r7, lr}
700a1162: b08a         	sub	sp, #0x28
700a1164: 9008         	str	r0, [sp, #0x20]
700a1166: 9107         	str	r1, [sp, #0x1c]
700a1168: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
700a116a: 9006         	str	r0, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a116c: 9908         	ldr	r1, [sp, #0x20]
700a116e: 9103         	str	r1, [sp, #0xc]
;         BaseType_t xInheritanceOccurred = pdFALSE;
700a1170: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
700a1172: e7ff         	b	0x700a1174 <xQueueSemaphoreTake+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a1174: f00d faa4    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0xd548
;             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
700a1178: 9803         	ldr	r0, [sp, #0xc]
700a117a: 6b80         	ldr	r0, [r0, #0x38]
700a117c: 9001         	str	r0, [sp, #0x4]
;             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
700a117e: 9801         	ldr	r0, [sp, #0x4]
700a1180: b310         	cbz	r0, 0x700a11c8 <xQueueSemaphoreTake+0x68> @ imm = #0x44
700a1182: e7ff         	b	0x700a1184 <xQueueSemaphoreTake+0x24> @ imm = #-0x2
;                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
700a1184: 9801         	ldr	r0, [sp, #0x4]
700a1186: 3801         	subs	r0, #0x1
700a1188: 9903         	ldr	r1, [sp, #0xc]
700a118a: 6388         	str	r0, [r1, #0x38]
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a118c: 9803         	ldr	r0, [sp, #0xc]
700a118e: 6800         	ldr	r0, [r0]
700a1190: b928         	cbnz	r0, 0x700a119e <xQueueSemaphoreTake+0x3e> @ imm = #0xa
700a1192: e7ff         	b	0x700a1194 <xQueueSemaphoreTake+0x34> @ imm = #-0x2
;                             pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
700a1194: f00d fd14    	bl	0x700aebc0 <pvTaskIncrementMutexHeldCount> @ imm = #0xda28
700a1198: 9903         	ldr	r1, [sp, #0xc]
700a119a: 6088         	str	r0, [r1, #0x8]
;                         }
700a119c: e000         	b	0x700a11a0 <xQueueSemaphoreTake+0x40> @ imm = #0x0
700a119e: e7ff         	b	0x700a11a0 <xQueueSemaphoreTake+0x40> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a11a0: 9803         	ldr	r0, [sp, #0xc]
700a11a2: 6900         	ldr	r0, [r0, #0x10]
700a11a4: b150         	cbz	r0, 0x700a11bc <xQueueSemaphoreTake+0x5c> @ imm = #0x14
700a11a6: e7ff         	b	0x700a11a8 <xQueueSemaphoreTake+0x48> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a11a8: 9803         	ldr	r0, [sp, #0xc]
700a11aa: 3010         	adds	r0, #0x10
700a11ac: f006 fbd0    	bl	0x700a7950 <xTaskRemoveFromEventList> @ imm = #0x67a0
700a11b0: b110         	cbz	r0, 0x700a11b8 <xQueueSemaphoreTake+0x58> @ imm = #0x4
700a11b2: e7ff         	b	0x700a11b4 <xQueueSemaphoreTake+0x54> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
700a11b4: df00         	svc	#0x0
;                     }
700a11b6: e000         	b	0x700a11ba <xQueueSemaphoreTake+0x5a> @ imm = #0x0
700a11b8: e7ff         	b	0x700a11ba <xQueueSemaphoreTake+0x5a> @ imm = #-0x2
;                 }
700a11ba: e000         	b	0x700a11be <xQueueSemaphoreTake+0x5e> @ imm = #0x0
700a11bc: e7ff         	b	0x700a11be <xQueueSemaphoreTake+0x5e> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a11be: f00c fb1f    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xc63e
700a11c2: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a11c4: 9009         	str	r0, [sp, #0x24]
700a11c6: e083         	b	0x700a12d0 <xQueueSemaphoreTake+0x170> @ imm = #0x106
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a11c8: 9807         	ldr	r0, [sp, #0x1c]
700a11ca: b928         	cbnz	r0, 0x700a11d8 <xQueueSemaphoreTake+0x78> @ imm = #0xa
700a11cc: e7ff         	b	0x700a11ce <xQueueSemaphoreTake+0x6e> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a11ce: f00c fb17    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xc62e
700a11d2: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
700a11d4: 9009         	str	r0, [sp, #0x24]
700a11d6: e07b         	b	0x700a12d0 <xQueueSemaphoreTake+0x170> @ imm = #0xf6
;                 else if( xEntryTimeSet == pdFALSE )
700a11d8: 9806         	ldr	r0, [sp, #0x18]
700a11da: b930         	cbnz	r0, 0x700a11ea <xQueueSemaphoreTake+0x8a> @ imm = #0xc
700a11dc: e7ff         	b	0x700a11de <xQueueSemaphoreTake+0x7e> @ imm = #-0x2
700a11de: a804         	add	r0, sp, #0x10
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a11e0: f00d ffe6    	bl	0x700af1b0 <vTaskInternalSetTimeOutState> @ imm = #0xdfcc
700a11e4: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a11e6: 9006         	str	r0, [sp, #0x18]
;                 }
700a11e8: e000         	b	0x700a11ec <xQueueSemaphoreTake+0x8c> @ imm = #0x0
700a11ea: e7ff         	b	0x700a11ec <xQueueSemaphoreTake+0x8c> @ imm = #-0x2
700a11ec: e7ff         	b	0x700a11ee <xQueueSemaphoreTake+0x8e> @ imm = #-0x2
700a11ee: e7ff         	b	0x700a11f0 <xQueueSemaphoreTake+0x90> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a11f0: f00c fb06    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xc60c
;         vTaskSuspendAll();
700a11f4: f00e fcc4    	bl	0x700afb80 <vTaskSuspendAll> @ imm = #0xe988
;         prvLockQueue( pxQueue );
700a11f8: f00d fa62    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0xd4c4
700a11fc: 9803         	ldr	r0, [sp, #0xc]
700a11fe: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a1202: 3001         	adds	r0, #0x1
700a1204: b928         	cbnz	r0, 0x700a1212 <xQueueSemaphoreTake+0xb2> @ imm = #0xa
700a1206: e7ff         	b	0x700a1208 <xQueueSemaphoreTake+0xa8> @ imm = #-0x2
700a1208: 9903         	ldr	r1, [sp, #0xc]
700a120a: 2000         	movs	r0, #0x0
700a120c: f881 0044    	strb.w	r0, [r1, #0x44]
700a1210: e7ff         	b	0x700a1212 <xQueueSemaphoreTake+0xb2> @ imm = #-0x2
700a1212: 9803         	ldr	r0, [sp, #0xc]
700a1214: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a1218: 3001         	adds	r0, #0x1
700a121a: b928         	cbnz	r0, 0x700a1228 <xQueueSemaphoreTake+0xc8> @ imm = #0xa
700a121c: e7ff         	b	0x700a121e <xQueueSemaphoreTake+0xbe> @ imm = #-0x2
700a121e: 9903         	ldr	r1, [sp, #0xc]
700a1220: 2000         	movs	r0, #0x0
700a1222: f881 0045    	strb.w	r0, [r1, #0x45]
700a1226: e7ff         	b	0x700a1228 <xQueueSemaphoreTake+0xc8> @ imm = #-0x2
700a1228: f00c faea    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xc5d4
700a122c: a804         	add	r0, sp, #0x10
700a122e: a907         	add	r1, sp, #0x1c
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a1230: f007 ff46    	bl	0x700a90c0 <xTaskCheckForTimeOut> @ imm = #0x7e8c
700a1234: bb58         	cbnz	r0, 0x700a128e <xQueueSemaphoreTake+0x12e> @ imm = #0x56
700a1236: e7ff         	b	0x700a1238 <xQueueSemaphoreTake+0xd8> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a1238: 9803         	ldr	r0, [sp, #0xc]
700a123a: f00d fdf9    	bl	0x700aee30 <prvIsQueueEmpty> @ imm = #0xdbf2
700a123e: b1f8         	cbz	r0, 0x700a1280 <xQueueSemaphoreTake+0x120> @ imm = #0x3e
700a1240: e7ff         	b	0x700a1242 <xQueueSemaphoreTake+0xe2> @ imm = #-0x2
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a1242: 9803         	ldr	r0, [sp, #0xc]
700a1244: 6800         	ldr	r0, [r0]
700a1246: b950         	cbnz	r0, 0x700a125e <xQueueSemaphoreTake+0xfe> @ imm = #0x14
700a1248: e7ff         	b	0x700a124a <xQueueSemaphoreTake+0xea> @ imm = #-0x2
;                             taskENTER_CRITICAL();
700a124a: f00d fa39    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0xd472
;                                 xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
700a124e: 9803         	ldr	r0, [sp, #0xc]
700a1250: 6880         	ldr	r0, [r0, #0x8]
700a1252: f003 fef5    	bl	0x700a5040 <xTaskPriorityInherit> @ imm = #0x3dea
700a1256: 9002         	str	r0, [sp, #0x8]
;                             taskEXIT_CRITICAL();
700a1258: f00c fad2    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xc5a4
;                         }
700a125c: e000         	b	0x700a1260 <xQueueSemaphoreTake+0x100> @ imm = #0x0
700a125e: e7ff         	b	0x700a1260 <xQueueSemaphoreTake+0x100> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
700a1260: 9803         	ldr	r0, [sp, #0xc]
700a1262: 3024         	adds	r0, #0x24
700a1264: 9907         	ldr	r1, [sp, #0x1c]
700a1266: f00d fea3    	bl	0x700aefb0 <vTaskPlaceOnEventList> @ imm = #0xdd46
;                 prvUnlockQueue( pxQueue );
700a126a: 9803         	ldr	r0, [sp, #0xc]
700a126c: f006 fd38    	bl	0x700a7ce0 <prvUnlockQueue> @ imm = #0x6a70
;                 if( xTaskResumeAll() == pdFALSE )
700a1270: f000 ff36    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #0xe6c
700a1274: b910         	cbnz	r0, 0x700a127c <xQueueSemaphoreTake+0x11c> @ imm = #0x4
700a1276: e7ff         	b	0x700a1278 <xQueueSemaphoreTake+0x118> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a1278: df00         	svc	#0x0
;                 }
700a127a: e000         	b	0x700a127e <xQueueSemaphoreTake+0x11e> @ imm = #0x0
700a127c: e7ff         	b	0x700a127e <xQueueSemaphoreTake+0x11e> @ imm = #-0x2
;             }
700a127e: e005         	b	0x700a128c <xQueueSemaphoreTake+0x12c> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a1280: 9803         	ldr	r0, [sp, #0xc]
700a1282: f006 fd2d    	bl	0x700a7ce0 <prvUnlockQueue> @ imm = #0x6a5a
;                 ( void ) xTaskResumeAll();
700a1286: f000 ff2b    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #0xe56
700a128a: e7ff         	b	0x700a128c <xQueueSemaphoreTake+0x12c> @ imm = #-0x2
;         }
700a128c: e01f         	b	0x700a12ce <xQueueSemaphoreTake+0x16e> @ imm = #0x3e
;             prvUnlockQueue( pxQueue );
700a128e: 9803         	ldr	r0, [sp, #0xc]
700a1290: f006 fd26    	bl	0x700a7ce0 <prvUnlockQueue> @ imm = #0x6a4c
;             ( void ) xTaskResumeAll();
700a1294: f000 ff24    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #0xe48
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a1298: 9803         	ldr	r0, [sp, #0xc]
700a129a: f00d fdc9    	bl	0x700aee30 <prvIsQueueEmpty> @ imm = #0xdb92
700a129e: b1a0         	cbz	r0, 0x700a12ca <xQueueSemaphoreTake+0x16a> @ imm = #0x28
700a12a0: e7ff         	b	0x700a12a2 <xQueueSemaphoreTake+0x142> @ imm = #-0x2
;                         if( xInheritanceOccurred != pdFALSE )
700a12a2: 9802         	ldr	r0, [sp, #0x8]
700a12a4: b170         	cbz	r0, 0x700a12c4 <xQueueSemaphoreTake+0x164> @ imm = #0x1c
700a12a6: e7ff         	b	0x700a12a8 <xQueueSemaphoreTake+0x148> @ imm = #-0x2
;                             taskENTER_CRITICAL();
700a12a8: f00d fa0a    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0xd414
;                                 uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
700a12ac: 9803         	ldr	r0, [sp, #0xc]
700a12ae: f00d fe67    	bl	0x700aef80 <prvGetDisinheritPriorityAfterTimeout> @ imm = #0xdcce
700a12b2: 9000         	str	r0, [sp]
;                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
700a12b4: 9803         	ldr	r0, [sp, #0xc]
700a12b6: 6880         	ldr	r0, [r0, #0x8]
700a12b8: 9900         	ldr	r1, [sp]
700a12ba: f004 fb59    	bl	0x700a5970 <vTaskPriorityDisinheritAfterTimeout> @ imm = #0x46b2
;                             taskEXIT_CRITICAL();
700a12be: f00c fa9f    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xc53e
;                         }
700a12c2: e7ff         	b	0x700a12c4 <xQueueSemaphoreTake+0x164> @ imm = #-0x2
700a12c4: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
700a12c6: 9009         	str	r0, [sp, #0x24]
700a12c8: e002         	b	0x700a12d0 <xQueueSemaphoreTake+0x170> @ imm = #0x4
700a12ca: e7ff         	b	0x700a12cc <xQueueSemaphoreTake+0x16c> @ imm = #-0x2
700a12cc: e7ff         	b	0x700a12ce <xQueueSemaphoreTake+0x16e> @ imm = #-0x2
;     for( ; ; )
700a12ce: e751         	b	0x700a1174 <xQueueSemaphoreTake+0x14> @ imm = #-0x15e
; }
700a12d0: 9809         	ldr	r0, [sp, #0x24]
700a12d2: b00a         	add	sp, #0x28
700a12d4: bd80         	pop	{r7, pc}
		...
700a12de: 0000         	movs	r0, r0

700a12e0 <xTaskIncrementTick>:
; BaseType_t xTaskIncrementTick(void) {
700a12e0: b580         	push	{r7, lr}
700a12e2: b086         	sub	sp, #0x18
700a12e4: 2000         	movs	r0, #0x0
;   BaseType_t xSwitchRequired = pdFALSE;
700a12e6: 9003         	str	r0, [sp, #0xc]
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a12e8: f642 2024    	movw	r0, #0x2a24
700a12ec: f2c7 000b    	movt	r0, #0x700b
700a12f0: 6800         	ldr	r0, [r0]
700a12f2: 2800         	cmp	r0, #0x0
700a12f4: f040 80a3    	bne.w	0x700a143e <xTaskIncrementTick+0x15e> @ imm = #0x146
700a12f8: e7ff         	b	0x700a12fa <xTaskIncrementTick+0x1a> @ imm = #-0x2
;     const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
700a12fa: f642 2144    	movw	r1, #0x2a44
700a12fe: f2c7 010b    	movt	r1, #0x700b
700a1302: 6808         	ldr	r0, [r1]
700a1304: 3001         	adds	r0, #0x1
700a1306: 9002         	str	r0, [sp, #0x8]
;     xTickCount = xConstTickCount;
700a1308: 9802         	ldr	r0, [sp, #0x8]
700a130a: 6008         	str	r0, [r1]
;     if (xConstTickCount ==
700a130c: 9802         	ldr	r0, [sp, #0x8]
700a130e: b9c0         	cbnz	r0, 0x700a1342 <xTaskIncrementTick+0x62> @ imm = #0x30
700a1310: e7ff         	b	0x700a1312 <xTaskIncrementTick+0x32> @ imm = #-0x2
;       taskSWITCH_DELAYED_LISTS();
700a1312: f245 1228    	movw	r2, #0x5128
700a1316: f2c7 0208    	movt	r2, #0x7008
700a131a: 6810         	ldr	r0, [r2]
700a131c: 9001         	str	r0, [sp, #0x4]
700a131e: f245 112c    	movw	r1, #0x512c
700a1322: f2c7 0108    	movt	r1, #0x7008
700a1326: 6808         	ldr	r0, [r1]
700a1328: 6010         	str	r0, [r2]
700a132a: 9801         	ldr	r0, [sp, #0x4]
700a132c: 6008         	str	r0, [r1]
700a132e: f642 2138    	movw	r1, #0x2a38
700a1332: f2c7 010b    	movt	r1, #0x700b
700a1336: 6808         	ldr	r0, [r1]
700a1338: 3001         	adds	r0, #0x1
700a133a: 6008         	str	r0, [r1]
700a133c: f00c fea8    	bl	0x700ae090 <prvResetNextTaskUnblockTime> @ imm = #0xcd50
;     } else {
700a1340: e000         	b	0x700a1344 <xTaskIncrementTick+0x64> @ imm = #0x0
700a1342: e7ff         	b	0x700a1344 <xTaskIncrementTick+0x64> @ imm = #-0x2
;     if (xConstTickCount >= xNextTaskUnblockTime) {
700a1344: 9802         	ldr	r0, [sp, #0x8]
700a1346: f642 2134    	movw	r1, #0x2a34
700a134a: f2c7 010b    	movt	r1, #0x700b
700a134e: 6809         	ldr	r1, [r1]
700a1350: 4288         	cmp	r0, r1
700a1352: d368         	blo	0x700a1426 <xTaskIncrementTick+0x146> @ imm = #0xd0
700a1354: e7ff         	b	0x700a1356 <xTaskIncrementTick+0x76> @ imm = #-0x2
;       for (;;) {
700a1356: e7ff         	b	0x700a1358 <xTaskIncrementTick+0x78> @ imm = #-0x2
;         if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
700a1358: f245 1028    	movw	r0, #0x5128
700a135c: f2c7 0008    	movt	r0, #0x7008
700a1360: 6800         	ldr	r0, [r0]
700a1362: 6800         	ldr	r0, [r0]
700a1364: b940         	cbnz	r0, 0x700a1378 <xTaskIncrementTick+0x98> @ imm = #0x10
700a1366: e7ff         	b	0x700a1368 <xTaskIncrementTick+0x88> @ imm = #-0x2
;           xNextTaskUnblockTime =
700a1368: f642 2134    	movw	r1, #0x2a34
700a136c: f2c7 010b    	movt	r1, #0x700b
700a1370: f04f 30ff    	mov.w	r0, #0xffffffff
700a1374: 6008         	str	r0, [r1]
;           break;
700a1376: e055         	b	0x700a1424 <xTaskIncrementTick+0x144> @ imm = #0xaa
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a1378: f245 1028    	movw	r0, #0x5128
700a137c: f2c7 0008    	movt	r0, #0x7008
700a1380: 6800         	ldr	r0, [r0]
700a1382: 68c0         	ldr	r0, [r0, #0xc]
700a1384: 68c0         	ldr	r0, [r0, #0xc]
700a1386: 9005         	str	r0, [sp, #0x14]
;           xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
700a1388: 9805         	ldr	r0, [sp, #0x14]
700a138a: 6840         	ldr	r0, [r0, #0x4]
700a138c: 9004         	str	r0, [sp, #0x10]
;           if (xConstTickCount < xItemValue) {
700a138e: 9802         	ldr	r0, [sp, #0x8]
700a1390: 9904         	ldr	r1, [sp, #0x10]
700a1392: 4288         	cmp	r0, r1
700a1394: d207         	bhs	0x700a13a6 <xTaskIncrementTick+0xc6> @ imm = #0xe
700a1396: e7ff         	b	0x700a1398 <xTaskIncrementTick+0xb8> @ imm = #-0x2
;             xNextTaskUnblockTime = xItemValue;
700a1398: 9804         	ldr	r0, [sp, #0x10]
700a139a: f642 2134    	movw	r1, #0x2a34
700a139e: f2c7 010b    	movt	r1, #0x700b
700a13a2: 6008         	str	r0, [r1]
;             break; /*lint !e9011 Code structure here is deedmed easier to
700a13a4: e03e         	b	0x700a1424 <xTaskIncrementTick+0x144> @ imm = #0x7c
700a13a6: e7ff         	b	0x700a13a8 <xTaskIncrementTick+0xc8> @ imm = #-0x2
;           (void)uxListRemove(&(pxTCB->xStateListItem));
700a13a8: 9805         	ldr	r0, [sp, #0x14]
700a13aa: 3004         	adds	r0, #0x4
700a13ac: f00c f938    	bl	0x700ad620 <uxListRemove> @ imm = #0xc270
;           if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a13b0: 9805         	ldr	r0, [sp, #0x14]
700a13b2: 6a80         	ldr	r0, [r0, #0x28]
700a13b4: b128         	cbz	r0, 0x700a13c2 <xTaskIncrementTick+0xe2> @ imm = #0xa
700a13b6: e7ff         	b	0x700a13b8 <xTaskIncrementTick+0xd8> @ imm = #-0x2
;             (void)uxListRemove(&(pxTCB->xEventListItem));
700a13b8: 9805         	ldr	r0, [sp, #0x14]
700a13ba: 3018         	adds	r0, #0x18
700a13bc: f00c f930    	bl	0x700ad620 <uxListRemove> @ imm = #0xc260
;           } else {
700a13c0: e000         	b	0x700a13c4 <xTaskIncrementTick+0xe4> @ imm = #0x0
700a13c2: e7ff         	b	0x700a13c4 <xTaskIncrementTick+0xe4> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
700a13c4: 9805         	ldr	r0, [sp, #0x14]
700a13c6: 6ac0         	ldr	r0, [r0, #0x2c]
700a13c8: f642 212c    	movw	r1, #0x2a2c
700a13cc: f2c7 010b    	movt	r1, #0x700b
700a13d0: 6809         	ldr	r1, [r1]
700a13d2: 4288         	cmp	r0, r1
700a13d4: d908         	bls	0x700a13e8 <xTaskIncrementTick+0x108> @ imm = #0x10
700a13d6: e7ff         	b	0x700a13d8 <xTaskIncrementTick+0xf8> @ imm = #-0x2
700a13d8: 9805         	ldr	r0, [sp, #0x14]
700a13da: 6ac0         	ldr	r0, [r0, #0x2c]
700a13dc: f642 212c    	movw	r1, #0x2a2c
700a13e0: f2c7 010b    	movt	r1, #0x700b
700a13e4: 6008         	str	r0, [r1]
700a13e6: e7ff         	b	0x700a13e8 <xTaskIncrementTick+0x108> @ imm = #-0x2
700a13e8: 9905         	ldr	r1, [sp, #0x14]
700a13ea: 6ac8         	ldr	r0, [r1, #0x2c]
700a13ec: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a13f0: f244 40f8    	movw	r0, #0x44f8
700a13f4: f2c7 0008    	movt	r0, #0x7008
700a13f8: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a13fc: 3104         	adds	r1, #0x4
700a13fe: f00c fec7    	bl	0x700ae190 <vListInsertEnd> @ imm = #0xcd8e
;             if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a1402: 9805         	ldr	r0, [sp, #0x14]
700a1404: 6ac0         	ldr	r0, [r0, #0x2c]
700a1406: f642 2100    	movw	r1, #0x2a00
700a140a: f2c7 010b    	movt	r1, #0x700b
700a140e: 6809         	ldr	r1, [r1]
700a1410: 6ac9         	ldr	r1, [r1, #0x2c]
700a1412: 4288         	cmp	r0, r1
700a1414: d303         	blo	0x700a141e <xTaskIncrementTick+0x13e> @ imm = #0x6
700a1416: e7ff         	b	0x700a1418 <xTaskIncrementTick+0x138> @ imm = #-0x2
700a1418: 2001         	movs	r0, #0x1
;               xSwitchRequired = pdTRUE;
700a141a: 9003         	str	r0, [sp, #0xc]
;             } else {
700a141c: e000         	b	0x700a1420 <xTaskIncrementTick+0x140> @ imm = #0x0
700a141e: e7ff         	b	0x700a1420 <xTaskIncrementTick+0x140> @ imm = #-0x2
700a1420: e7ff         	b	0x700a1422 <xTaskIncrementTick+0x142> @ imm = #-0x2
;       for (;;) {
700a1422: e799         	b	0x700a1358 <xTaskIncrementTick+0x78> @ imm = #-0xce
;     }
700a1424: e7ff         	b	0x700a1426 <xTaskIncrementTick+0x146> @ imm = #-0x2
;       if (xYieldPending != pdFALSE) {
700a1426: f642 2050    	movw	r0, #0x2a50
700a142a: f2c7 000b    	movt	r0, #0x700b
700a142e: 6800         	ldr	r0, [r0]
700a1430: b118         	cbz	r0, 0x700a143a <xTaskIncrementTick+0x15a> @ imm = #0x6
700a1432: e7ff         	b	0x700a1434 <xTaskIncrementTick+0x154> @ imm = #-0x2
700a1434: 2001         	movs	r0, #0x1
;         xSwitchRequired = pdTRUE;
700a1436: 9003         	str	r0, [sp, #0xc]
;       } else {
700a1438: e000         	b	0x700a143c <xTaskIncrementTick+0x15c> @ imm = #0x0
700a143a: e7ff         	b	0x700a143c <xTaskIncrementTick+0x15c> @ imm = #-0x2
;   } else {
700a143c: e007         	b	0x700a144e <xTaskIncrementTick+0x16e> @ imm = #0xe
;     ++xPendedTicks;
700a143e: f642 213c    	movw	r1, #0x2a3c
700a1442: f2c7 010b    	movt	r1, #0x700b
700a1446: 6808         	ldr	r0, [r1]
700a1448: 3001         	adds	r0, #0x1
700a144a: 6008         	str	r0, [r1]
700a144c: e7ff         	b	0x700a144e <xTaskIncrementTick+0x16e> @ imm = #-0x2
;   return xSwitchRequired;
700a144e: 9803         	ldr	r0, [sp, #0xc]
700a1450: b006         	add	sp, #0x18
700a1452: bd80         	pop	{r7, pc}
		...

700a1460 <CSL_bcdmaChanOpTeardownChan>:
; {
700a1460: b580         	push	{r7, lr}
700a1462: b08c         	sub	sp, #0x30
700a1464: 900b         	str	r0, [sp, #0x2c]
700a1466: 910a         	str	r1, [sp, #0x28]
700a1468: 9209         	str	r2, [sp, #0x24]
700a146a: 9308         	str	r3, [sp, #0x20]
700a146c: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
700a146e: 9007         	str	r0, [sp, #0x1c]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
700a1470: 980b         	ldr	r0, [sp, #0x2c]
700a1472: 990a         	ldr	r1, [sp, #0x28]
700a1474: 9a09         	ldr	r2, [sp, #0x24]
700a1476: f009 f9eb    	bl	0x700aa850 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x93d6
700a147a: b920         	cbnz	r0, 0x700a1486 <CSL_bcdmaChanOpTeardownChan+0x26> @ imm = #0x8
700a147c: e7ff         	b	0x700a147e <CSL_bcdmaChanOpTeardownChan+0x1e> @ imm = #-0x2
700a147e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a1482: 9007         	str	r0, [sp, #0x1c]
;     }
700a1484: e09f         	b	0x700a15c6 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #0x13e
700a1486: 2000         	movs	r0, #0x0
;         uint32_t force = (uint32_t)0U, wait = (uint32_t)0U;
700a1488: 9005         	str	r0, [sp, #0x14]
700a148a: 9004         	str	r0, [sp, #0x10]
;         if( pOpData != NULL )
700a148c: 9808         	ldr	r0, [sp, #0x20]
700a148e: b148         	cbz	r0, 0x700a14a4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #0x12
700a1490: e7ff         	b	0x700a1492 <CSL_bcdmaChanOpTeardownChan+0x32> @ imm = #-0x2
;             CSL_BcdmaTeardownOpts *pTdOpts = (CSL_BcdmaTeardownOpts *)pOpData;
700a1492: 9808         	ldr	r0, [sp, #0x20]
700a1494: 9003         	str	r0, [sp, #0xc]
;             force = pTdOpts->force;
700a1496: 9803         	ldr	r0, [sp, #0xc]
700a1498: 6800         	ldr	r0, [r0]
700a149a: 9005         	str	r0, [sp, #0x14]
;             wait  = pTdOpts->wait;
700a149c: 9803         	ldr	r0, [sp, #0xc]
700a149e: 6840         	ldr	r0, [r0, #0x4]
700a14a0: 9004         	str	r0, [sp, #0x10]
;         }
700a14a2: e7ff         	b	0x700a14a4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #-0x2
;         switch( chanType )
700a14a4: 980a         	ldr	r0, [sp, #0x28]
700a14a6: 9001         	str	r0, [sp, #0x4]
700a14a8: b148         	cbz	r0, 0x700a14be <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #0x12
700a14aa: e7ff         	b	0x700a14ac <CSL_bcdmaChanOpTeardownChan+0x4c> @ imm = #-0x2
700a14ac: 9801         	ldr	r0, [sp, #0x4]
700a14ae: 2801         	cmp	r0, #0x1
700a14b0: d024         	beq	0x700a14fc <CSL_bcdmaChanOpTeardownChan+0x9c> @ imm = #0x48
700a14b2: e7ff         	b	0x700a14b4 <CSL_bcdmaChanOpTeardownChan+0x54> @ imm = #-0x2
700a14b4: 9801         	ldr	r0, [sp, #0x4]
700a14b6: 2802         	cmp	r0, #0x2
700a14b8: d03f         	beq	0x700a153a <CSL_bcdmaChanOpTeardownChan+0xda> @ imm = #0x7e
700a14ba: e7ff         	b	0x700a14bc <CSL_bcdmaChanOpTeardownChan+0x5c> @ imm = #-0x2
;         {
700a14bc: e7ff         	b	0x700a14be <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
700a14be: 980b         	ldr	r0, [sp, #0x2c]
700a14c0: 6880         	ldr	r0, [r0, #0x8]
700a14c2: 9909         	ldr	r1, [sp, #0x24]
700a14c4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a14c8: f00e fb7a    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xe6f4
700a14cc: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a14ce: 9806         	ldr	r0, [sp, #0x18]
700a14d0: f040 4080    	orr	r0, r0, #0x40000000
700a14d4: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a14d6: 9806         	ldr	r0, [sp, #0x18]
700a14d8: f020 5180    	bic	r1, r0, #0x10000000
700a14dc: 9a05         	ldr	r2, [sp, #0x14]
700a14de: f101 5080    	add.w	r0, r1, #0x10000000
700a14e2: 2a00         	cmp	r2, #0x0
700a14e4: bf08         	it	eq
700a14e6: 4608         	moveq	r0, r1
700a14e8: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a14ea: 980b         	ldr	r0, [sp, #0x2c]
700a14ec: 6880         	ldr	r0, [r0, #0x8]
700a14ee: 9909         	ldr	r1, [sp, #0x24]
700a14f0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a14f4: 9906         	ldr	r1, [sp, #0x18]
700a14f6: f7fa fe0b    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x53ea
;                 break;
700a14fa: e03d         	b	0x700a1578 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x7a
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a14fc: 980b         	ldr	r0, [sp, #0x2c]
700a14fe: 6900         	ldr	r0, [r0, #0x10]
700a1500: 9909         	ldr	r1, [sp, #0x24]
700a1502: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1506: f00e fb5b    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xe6b6
700a150a: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a150c: 9806         	ldr	r0, [sp, #0x18]
700a150e: f040 4080    	orr	r0, r0, #0x40000000
700a1512: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a1514: 9806         	ldr	r0, [sp, #0x18]
700a1516: f020 5180    	bic	r1, r0, #0x10000000
700a151a: 9a05         	ldr	r2, [sp, #0x14]
700a151c: f101 5080    	add.w	r0, r1, #0x10000000
700a1520: 2a00         	cmp	r2, #0x0
700a1522: bf08         	it	eq
700a1524: 4608         	moveq	r0, r1
700a1526: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a1528: 980b         	ldr	r0, [sp, #0x2c]
700a152a: 6900         	ldr	r0, [r0, #0x10]
700a152c: 9909         	ldr	r1, [sp, #0x24]
700a152e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1532: 9906         	ldr	r1, [sp, #0x18]
700a1534: f7fa fdec    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x5428
;                 break;
700a1538: e01e         	b	0x700a1578 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x3c
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a153a: 980b         	ldr	r0, [sp, #0x2c]
700a153c: 6980         	ldr	r0, [r0, #0x18]
700a153e: 9909         	ldr	r1, [sp, #0x24]
700a1540: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1544: f00e fb3c    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xe678
700a1548: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a154a: 9806         	ldr	r0, [sp, #0x18]
700a154c: f040 4080    	orr	r0, r0, #0x40000000
700a1550: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a1552: 9806         	ldr	r0, [sp, #0x18]
700a1554: f020 5180    	bic	r1, r0, #0x10000000
700a1558: 9a05         	ldr	r2, [sp, #0x14]
700a155a: f101 5080    	add.w	r0, r1, #0x10000000
700a155e: 2a00         	cmp	r2, #0x0
700a1560: bf08         	it	eq
700a1562: 4608         	moveq	r0, r1
700a1564: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a1566: 980b         	ldr	r0, [sp, #0x2c]
700a1568: 6980         	ldr	r0, [r0, #0x18]
700a156a: 9909         	ldr	r1, [sp, #0x24]
700a156c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1570: 9906         	ldr	r1, [sp, #0x18]
700a1572: f7fa fdcd    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x5466
;                 break;
700a1576: e7ff         	b	0x700a1578 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #-0x2
;         if(wait != 0U)
700a1578: 9804         	ldr	r0, [sp, #0x10]
700a157a: b318         	cbz	r0, 0x700a15c4 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #0x46
700a157c: e7ff         	b	0x700a157e <CSL_bcdmaChanOpTeardownChan+0x11e> @ imm = #-0x2
700a157e: 2080         	movs	r0, #0x80
;             uint32_t retryCnt = CSL_BCDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
700a1580: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a1582: e7ff         	b	0x700a1584 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x2
700a1584: 980b         	ldr	r0, [sp, #0x2c]
700a1586: 990a         	ldr	r1, [sp, #0x28]
700a1588: 9a09         	ldr	r2, [sp, #0x24]
700a158a: f009 f961    	bl	0x700aa850 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x92c2
700a158e: 4601         	mov	r1, r0
700a1590: 2000         	movs	r0, #0x0
700a1592: 9000         	str	r0, [sp]
700a1594: b131         	cbz	r1, 0x700a15a4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #0xc
700a1596: e7ff         	b	0x700a1598 <CSL_bcdmaChanOpTeardownChan+0x138> @ imm = #-0x2
700a1598: 9802         	ldr	r0, [sp, #0x8]
700a159a: 2800         	cmp	r0, #0x0
700a159c: bf18         	it	ne
700a159e: 2001         	movne	r0, #0x1
700a15a0: 9000         	str	r0, [sp]
700a15a2: e7ff         	b	0x700a15a4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #-0x2
700a15a4: 9800         	ldr	r0, [sp]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a15a6: 07c0         	lsls	r0, r0, #0x1f
700a15a8: b120         	cbz	r0, 0x700a15b4 <CSL_bcdmaChanOpTeardownChan+0x154> @ imm = #0x8
700a15aa: e7ff         	b	0x700a15ac <CSL_bcdmaChanOpTeardownChan+0x14c> @ imm = #-0x2
;                 retryCnt--;
700a15ac: 9802         	ldr	r0, [sp, #0x8]
700a15ae: 3801         	subs	r0, #0x1
700a15b0: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a15b2: e7e7         	b	0x700a1584 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x32
;             if( retryCnt == (uint32_t)0U ) {
700a15b4: 9802         	ldr	r0, [sp, #0x8]
700a15b6: b920         	cbnz	r0, 0x700a15c2 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #0x8
700a15b8: e7ff         	b	0x700a15ba <CSL_bcdmaChanOpTeardownChan+0x15a> @ imm = #-0x2
700a15ba: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = CSL_EFAIL;
700a15be: 9007         	str	r0, [sp, #0x1c]
;             }
700a15c0: e7ff         	b	0x700a15c2 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #-0x2
;         }
700a15c2: e7ff         	b	0x700a15c4 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #-0x2
700a15c4: e7ff         	b	0x700a15c6 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #-0x2
;     return retVal;
700a15c6: 9807         	ldr	r0, [sp, #0x1c]
700a15c8: b00c         	add	sp, #0x30
700a15ca: bd80         	pop	{r7, pc}
700a15cc: 0000         	movs	r0, r0
700a15ce: 0000         	movs	r0, r0

700a15d0 <CSL_bcdmaChanOp>:
; {
700a15d0: b580         	push	{r7, lr}
700a15d2: b088         	sub	sp, #0x20
700a15d4: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a15d8: 9007         	str	r0, [sp, #0x1c]
700a15da: 9106         	str	r1, [sp, #0x18]
700a15dc: 9205         	str	r2, [sp, #0x14]
700a15de: 9304         	str	r3, [sp, #0x10]
700a15e0: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a15e2: 9003         	str	r0, [sp, #0xc]
;     if( ( pCfg == NULL )                                    ||
700a15e4: 9807         	ldr	r0, [sp, #0x1c]
700a15e6: b158         	cbz	r0, 0x700a1600 <CSL_bcdmaChanOp+0x30> @ imm = #0x16
700a15e8: e7ff         	b	0x700a15ea <CSL_bcdmaChanOp+0x1a> @ imm = #-0x2
;         ( chanType > CSL_BCDMA_CHAN_TYPE_SPLIT_RX )         ||
700a15ea: 9805         	ldr	r0, [sp, #0x14]
700a15ec: 2802         	cmp	r0, #0x2
700a15ee: d807         	bhi	0x700a1600 <CSL_bcdmaChanOp+0x30> @ imm = #0xe
700a15f0: e7ff         	b	0x700a15f2 <CSL_bcdmaChanOp+0x22> @ imm = #-0x2
;         ( !CSL_bcdmaChanOpIsValidChanIdx( pCfg, chanType, chanIdx ) )
700a15f2: 9807         	ldr	r0, [sp, #0x1c]
700a15f4: 9905         	ldr	r1, [sp, #0x14]
700a15f6: 9a04         	ldr	r2, [sp, #0x10]
700a15f8: f009 f96a    	bl	0x700aa8d0 <CSL_bcdmaChanOpIsValidChanIdx> @ imm = #0x92d4
;     if( ( pCfg == NULL )                                    ||
700a15fc: b920         	cbnz	r0, 0x700a1608 <CSL_bcdmaChanOp+0x38> @ imm = #0x8
700a15fe: e7ff         	b	0x700a1600 <CSL_bcdmaChanOp+0x30> @ imm = #-0x2
700a1600: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a1604: 9003         	str	r0, [sp, #0xc]
;     }
700a1606: e094         	b	0x700a1732 <CSL_bcdmaChanOp+0x162> @ imm = #0x128
;         switch(chanOp )
700a1608: 9806         	ldr	r0, [sp, #0x18]
700a160a: 9002         	str	r0, [sp, #0x8]
700a160c: 280e         	cmp	r0, #0xe
700a160e: f200 808b    	bhi.w	0x700a1728 <CSL_bcdmaChanOp+0x158> @ imm = #0x116
700a1612: 9902         	ldr	r1, [sp, #0x8]
700a1614: e8df f001    	tbb	[pc, r1]
700a1618: 08 10 18 20  	.word	0x20181008
700a161c: 28 30 38 3f  	.word	0x3f383028
700a1620: 47 4f 57 5f  	.word	0x5f574f47
700a1624: 6c 79 81 00  	.word	0x0081796c
;                 retVal = CSL_bcdmaChanOpCfgChan( pCfg, chanType, chanIdx, pOpData );
700a1628: 9807         	ldr	r0, [sp, #0x1c]
700a162a: 9905         	ldr	r1, [sp, #0x14]
700a162c: 9a04         	ldr	r2, [sp, #0x10]
700a162e: 9b0a         	ldr	r3, [sp, #0x28]
700a1630: f7fc f876    	bl	0x7009d720 <CSL_bcdmaChanOpCfgChan> @ imm = #-0x3f14
700a1634: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1636: e07b         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0xf6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)true );
700a1638: 9807         	ldr	r0, [sp, #0x1c]
700a163a: 9905         	ldr	r1, [sp, #0x14]
700a163c: 9a04         	ldr	r2, [sp, #0x10]
700a163e: 2301         	movs	r3, #0x1
700a1640: f007 fd8e    	bl	0x700a9160 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x7b1c
700a1644: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1646: e073         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0xe6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)false );
700a1648: 9807         	ldr	r0, [sp, #0x1c]
700a164a: 9905         	ldr	r1, [sp, #0x14]
700a164c: 9a04         	ldr	r2, [sp, #0x10]
700a164e: 2300         	movs	r3, #0x0
700a1650: f007 fd86    	bl	0x700a9160 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x7b0c
700a1654: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1656: e06b         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0xd6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)true );
700a1658: 9807         	ldr	r0, [sp, #0x1c]
700a165a: 9905         	ldr	r1, [sp, #0x14]
700a165c: 9a04         	ldr	r2, [sp, #0x10]
700a165e: 2301         	movs	r3, #0x1
700a1660: f006 fcf6    	bl	0x700a8050 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x69ec
700a1664: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1666: e063         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0xc6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)false );
700a1668: 9807         	ldr	r0, [sp, #0x1c]
700a166a: 9905         	ldr	r1, [sp, #0x14]
700a166c: 9a04         	ldr	r2, [sp, #0x10]
700a166e: 2300         	movs	r3, #0x0
700a1670: f006 fcee    	bl	0x700a8050 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x69dc
700a1674: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1676: e05b         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0xb6
;                 retVal = CSL_bcdmaChanOpTeardownChan( pCfg, chanType, chanIdx, pOpData );
700a1678: 9807         	ldr	r0, [sp, #0x1c]
700a167a: 9905         	ldr	r1, [sp, #0x14]
700a167c: 9a04         	ldr	r2, [sp, #0x10]
700a167e: 9b0a         	ldr	r3, [sp, #0x28]
700a1680: f7ff feee    	bl	0x700a1460 <CSL_bcdmaChanOpTeardownChan> @ imm = #-0x224
700a1684: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1686: e053         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0xa6
;                 retVal = CSL_bcdmaChanOpTriggerChan( pCfg, chanType, chanIdx );
700a1688: 9807         	ldr	r0, [sp, #0x1c]
700a168a: 9905         	ldr	r1, [sp, #0x14]
700a168c: 9a04         	ldr	r2, [sp, #0x10]
700a168e: f009 fd1f    	bl	0x700ab0d0 <CSL_bcdmaChanOpTriggerChan> @ imm = #0x9a3e
700a1692: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1694: e04c         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0x98
;                 retVal = CSL_bcdmaChanOpGetChanRT( pCfg, chanType, chanIdx, pOpData );
700a1696: 9807         	ldr	r0, [sp, #0x1c]
700a1698: 9905         	ldr	r1, [sp, #0x14]
700a169a: 9a04         	ldr	r2, [sp, #0x10]
700a169c: 9b0a         	ldr	r3, [sp, #0x28]
700a169e: f004 fecf    	bl	0x700a6440 <CSL_bcdmaChanOpGetChanRT> @ imm = #0x4d9e
700a16a2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a16a4: e044         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0x88
;                 retVal = CSL_bcdmaChanOpSetChanRT( pCfg, chanType, chanIdx, pOpData );
700a16a6: 9807         	ldr	r0, [sp, #0x1c]
700a16a8: 9905         	ldr	r1, [sp, #0x14]
700a16aa: 9a04         	ldr	r2, [sp, #0x10]
700a16ac: 9b0a         	ldr	r3, [sp, #0x28]
700a16ae: f006 fd27    	bl	0x700a8100 <CSL_bcdmaChanOpSetChanRT> @ imm = #0x6a4e
700a16b2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a16b4: e03c         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0x78
;                 retVal = CSL_bcdmaChanOpGetChanStats( pCfg, chanType, chanIdx, pOpData );
700a16b6: 9807         	ldr	r0, [sp, #0x1c]
700a16b8: 9905         	ldr	r1, [sp, #0x14]
700a16ba: 9a04         	ldr	r2, [sp, #0x10]
700a16bc: 9b0a         	ldr	r3, [sp, #0x28]
700a16be: f000 fb07    	bl	0x700a1cd0 <CSL_bcdmaChanOpGetChanStats> @ imm = #0x60e
700a16c2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a16c4: e034         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0x68
;                 retVal = CSL_bcdmaChanOpDecChanStats( pCfg, chanType, chanIdx, pOpData );
700a16c6: 9807         	ldr	r0, [sp, #0x1c]
700a16c8: 9905         	ldr	r1, [sp, #0x14]
700a16ca: 9a04         	ldr	r2, [sp, #0x10]
700a16cc: 9b0a         	ldr	r3, [sp, #0x28]
700a16ce: f003 f8df    	bl	0x700a4890 <CSL_bcdmaChanOpDecChanStats> @ imm = #0x31be
700a16d2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a16d4: e02c         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0x58
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)true );
700a16d6: 9807         	ldr	r0, [sp, #0x1c]
700a16d8: 9905         	ldr	r1, [sp, #0x14]
700a16da: 9a04         	ldr	r2, [sp, #0x10]
700a16dc: 9b0a         	ldr	r3, [sp, #0x28]
700a16de: 46ee         	mov	lr, sp
700a16e0: f04f 0c01    	mov.w	r12, #0x1
700a16e4: f8ce c000    	str.w	r12, [lr]
700a16e8: f005 fe92    	bl	0x700a7410 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5d24
700a16ec: 9003         	str	r0, [sp, #0xc]
;                 break;
700a16ee: e01f         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0x3e
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)false );
700a16f0: 9807         	ldr	r0, [sp, #0x1c]
700a16f2: 9905         	ldr	r1, [sp, #0x14]
700a16f4: 9a04         	ldr	r2, [sp, #0x10]
700a16f6: 9b0a         	ldr	r3, [sp, #0x28]
700a16f8: 46ee         	mov	lr, sp
700a16fa: f04f 0c00    	mov.w	r12, #0x0
700a16fe: f8ce c000    	str.w	r12, [lr]
700a1702: f005 fe85    	bl	0x700a7410 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5d0a
700a1706: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1708: e012         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0x24
;                 retVal = CSL_bcdmaChanOpSetBurstSize( pCfg, chanType, chanIdx, pOpData );
700a170a: 9807         	ldr	r0, [sp, #0x1c]
700a170c: 9905         	ldr	r1, [sp, #0x14]
700a170e: 9a04         	ldr	r2, [sp, #0x10]
700a1710: 9b0a         	ldr	r3, [sp, #0x28]
700a1712: f005 fa05    	bl	0x700a6b20 <CSL_bcdmaChanOpSetBurstSize> @ imm = #0x540a
700a1716: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1718: e00a         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0x14
;                 retVal = CSL_bcdmaChanOpClearError( pCfg, chanType, chanIdx );
700a171a: 9807         	ldr	r0, [sp, #0x1c]
700a171c: 9905         	ldr	r1, [sp, #0x14]
700a171e: 9a04         	ldr	r2, [sp, #0x10]
700a1720: f009 fb16    	bl	0x700aad50 <CSL_bcdmaChanOpClearError> @ imm = #0x962c
700a1724: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1726: e003         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #0x6
700a1728: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a172c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a172e: e7ff         	b	0x700a1730 <CSL_bcdmaChanOp+0x160> @ imm = #-0x2
700a1730: e7ff         	b	0x700a1732 <CSL_bcdmaChanOp+0x162> @ imm = #-0x2
;     return retVal;
700a1732: 9803         	ldr	r0, [sp, #0xc]
700a1734: b008         	add	sp, #0x20
700a1736: bd80         	pop	{r7, pc}
		...

700a1740 <Udma_chOpen>:
; {
700a1740: b580         	push	{r7, lr}
700a1742: b08a         	sub	sp, #0x28
700a1744: 9009         	str	r0, [sp, #0x24]
700a1746: 9108         	str	r1, [sp, #0x20]
700a1748: 9207         	str	r2, [sp, #0x1c]
700a174a: 9306         	str	r3, [sp, #0x18]
700a174c: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK, tempRetVal;
700a174e: 9005         	str	r0, [sp, #0x14]
;     uint32_t            allocDone = (uint32_t) FALSE;
700a1750: 9003         	str	r0, [sp, #0xc]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700a1752: 9809         	ldr	r0, [sp, #0x24]
700a1754: 9001         	str	r0, [sp, #0x4]
;     if((drvHandleInt == NULL_PTR) || (NULL_PTR == chHandle) || (NULL_PTR == chPrms))
700a1756: 9801         	ldr	r0, [sp, #0x4]
700a1758: b130         	cbz	r0, 0x700a1768 <Udma_chOpen+0x28> @ imm = #0xc
700a175a: e7ff         	b	0x700a175c <Udma_chOpen+0x1c> @ imm = #-0x2
700a175c: 9808         	ldr	r0, [sp, #0x20]
700a175e: b118         	cbz	r0, 0x700a1768 <Udma_chOpen+0x28> @ imm = #0x6
700a1760: e7ff         	b	0x700a1762 <Udma_chOpen+0x22> @ imm = #-0x2
700a1762: 9806         	ldr	r0, [sp, #0x18]
700a1764: b920         	cbnz	r0, 0x700a1770 <Udma_chOpen+0x30> @ imm = #0x8
700a1766: e7ff         	b	0x700a1768 <Udma_chOpen+0x28> @ imm = #-0x2
700a1768: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a176c: 9005         	str	r0, [sp, #0x14]
;     }
700a176e: e7ff         	b	0x700a1770 <Udma_chOpen+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1770: 9805         	ldr	r0, [sp, #0x14]
700a1772: b978         	cbnz	r0, 0x700a1794 <Udma_chOpen+0x54> @ imm = #0x1e
700a1774: e7ff         	b	0x700a1776 <Udma_chOpen+0x36> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700a1776: 9801         	ldr	r0, [sp, #0x4]
700a1778: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a177c: f64a 31cd    	movw	r1, #0xabcd
700a1780: f6ca 31dc    	movt	r1, #0xabdc
700a1784: 4288         	cmp	r0, r1
700a1786: d004         	beq	0x700a1792 <Udma_chOpen+0x52> @ imm = #0x8
700a1788: e7ff         	b	0x700a178a <Udma_chOpen+0x4a> @ imm = #-0x2
700a178a: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a178e: 9005         	str	r0, [sp, #0x14]
;         }
700a1790: e7ff         	b	0x700a1792 <Udma_chOpen+0x52> @ imm = #-0x2
;     }
700a1792: e7ff         	b	0x700a1794 <Udma_chOpen+0x54> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1794: 9805         	ldr	r0, [sp, #0x14]
700a1796: b938         	cbnz	r0, 0x700a17a8 <Udma_chOpen+0x68> @ imm = #0xe
700a1798: e7ff         	b	0x700a179a <Udma_chOpen+0x5a> @ imm = #-0x2
;         retVal = Udma_chCheckParams(drvHandleInt, chType, chPrms);
700a179a: 9801         	ldr	r0, [sp, #0x4]
700a179c: 9907         	ldr	r1, [sp, #0x1c]
700a179e: 9a06         	ldr	r2, [sp, #0x18]
700a17a0: f006 f9ee    	bl	0x700a7b80 <Udma_chCheckParams> @ imm = #0x63dc
700a17a4: 9005         	str	r0, [sp, #0x14]
;     }
700a17a6: e7ff         	b	0x700a17a8 <Udma_chOpen+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a17a8: 9805         	ldr	r0, [sp, #0x14]
700a17aa: 2800         	cmp	r0, #0x0
700a17ac: d145         	bne	0x700a183a <Udma_chOpen+0xfa> @ imm = #0x8a
700a17ae: e7ff         	b	0x700a17b0 <Udma_chOpen+0x70> @ imm = #-0x2
;         chHandleInt = (Udma_ChHandleInt) chHandle;
700a17b0: 9808         	ldr	r0, [sp, #0x20]
700a17b2: 9002         	str	r0, [sp, #0x8]
;         (void) memset(chHandleInt, 0, sizeof(Udma_ChObject));
700a17b4: 9802         	ldr	r0, [sp, #0x8]
700a17b6: f44f 7116    	mov.w	r1, #0x258
700a17ba: f7f9 ebec    	blx	0x7009af94 <__aeabi_memclr8> @ imm = #-0x6828
;         (void) memcpy(&chHandleInt->chPrms, chPrms, sizeof(Udma_ChPrms));
700a17be: 9802         	ldr	r0, [sp, #0x8]
700a17c0: 3004         	adds	r0, #0x4
700a17c2: 9906         	ldr	r1, [sp, #0x18]
700a17c4: 2264         	movs	r2, #0x64
700a17c6: f7f8 ebca    	blx	0x70099f5c <__aeabi_memcpy8> @ imm = #-0x786c
;         chHandleInt->chType            = chType;
700a17ca: 9807         	ldr	r0, [sp, #0x1c]
700a17cc: 9902         	ldr	r1, [sp, #0x8]
700a17ce: 6008         	str	r0, [r1]
;         chHandleInt->drvHandle         = drvHandleInt;
700a17d0: 9801         	ldr	r0, [sp, #0x4]
700a17d2: 9902         	ldr	r1, [sp, #0x8]
700a17d4: 6688         	str	r0, [r1, #0x68]
;         chHandleInt->txChNum           = UDMA_DMA_CH_INVALID;
700a17d6: 9902         	ldr	r1, [sp, #0x8]
700a17d8: 2000         	movs	r0, #0x0
700a17da: f6cf 70ff    	movt	r0, #0xffff
700a17de: 66c8         	str	r0, [r1, #0x6c]
;         chHandleInt->rxChNum           = UDMA_DMA_CH_INVALID;
700a17e0: 9902         	ldr	r1, [sp, #0x8]
700a17e2: 6708         	str	r0, [r1, #0x70]
;         chHandleInt->extChNum          = UDMA_DMA_CH_INVALID;
700a17e4: 9902         	ldr	r1, [sp, #0x8]
700a17e6: 6748         	str	r0, [r1, #0x74]
;         chHandleInt->pdmaChNum         = UDMA_DMA_CH_INVALID;
700a17e8: 9902         	ldr	r1, [sp, #0x8]
700a17ea: 6788         	str	r0, [r1, #0x78]
;         chHandleInt->peerThreadId      = UDMA_THREAD_ID_INVALID;
700a17ec: 9902         	ldr	r1, [sp, #0x8]
700a17ee: 2004         	movs	r0, #0x4
700a17f0: f6cf 70ff    	movt	r0, #0xffff
700a17f4: 67c8         	str	r0, [r1, #0x7c]
;         chHandleInt->fqRing            = (Udma_RingHandleInt) NULL_PTR;
700a17f6: 9902         	ldr	r1, [sp, #0x8]
700a17f8: 2000         	movs	r0, #0x0
700a17fa: 9000         	str	r0, [sp]
700a17fc: f8c1 0080    	str.w	r0, [r1, #0x80]
;         chHandleInt->cqRing            = (Udma_RingHandleInt) NULL_PTR;
700a1800: 9902         	ldr	r1, [sp, #0x8]
700a1802: f8c1 0084    	str.w	r0, [r1, #0x84]
;         chHandleInt->tdCqRing          = (Udma_RingHandleInt) NULL_PTR;
700a1806: 9902         	ldr	r1, [sp, #0x8]
700a1808: f8c1 0088    	str.w	r0, [r1, #0x88]
;         UdmaChTxPrms_init(&chHandleInt->txPrms, chType);
700a180c: 9802         	ldr	r0, [sp, #0x8]
700a180e: f500 70f2    	add.w	r0, r0, #0x1e4
700a1812: 9907         	ldr	r1, [sp, #0x1c]
700a1814: f006 fb6c    	bl	0x700a7ef0 <UdmaChTxPrms_init> @ imm = #0x66d8
;         UdmaChRxPrms_init(&chHandleInt->rxPrms, chType);
700a1818: 9802         	ldr	r0, [sp, #0x8]
700a181a: f500 70fc    	add.w	r0, r0, #0x1f8
700a181e: 9907         	ldr	r1, [sp, #0x1c]
700a1820: f006 fb0e    	bl	0x700a7e40 <UdmaChRxPrms_init> @ imm = #0x661c
;         Udma_chInitRegs(chHandleInt);
700a1824: 9802         	ldr	r0, [sp, #0x8]
700a1826: f00b fb7b    	bl	0x700acf20 <Udma_chInitRegs> @ imm = #0xb6f6
700a182a: 9800         	ldr	r0, [sp]
;         chHandleInt->chOesAllocDone    = FALSE;
700a182c: 9902         	ldr	r1, [sp, #0x8]
700a182e: f8c1 0248    	str.w	r0, [r1, #0x248]
;         chHandleInt->trigger           = CSL_UDMAP_TR_FLAGS_TRIGGER_NONE;
700a1832: 9902         	ldr	r1, [sp, #0x8]
700a1834: f8c1 024c    	str.w	r0, [r1, #0x24c]
;     }
700a1838: e7ff         	b	0x700a183a <Udma_chOpen+0xfa> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a183a: 9805         	ldr	r0, [sp, #0x14]
700a183c: b960         	cbnz	r0, 0x700a1858 <Udma_chOpen+0x118> @ imm = #0x18
700a183e: e7ff         	b	0x700a1840 <Udma_chOpen+0x100> @ imm = #-0x2
;         retVal = Udma_chAllocResource(chHandleInt);
700a1840: 9802         	ldr	r0, [sp, #0x8]
700a1842: f7fa fa95    	bl	0x7009bd70 <Udma_chAllocResource> @ imm = #-0x5ad6
700a1846: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK == retVal)
700a1848: 9805         	ldr	r0, [sp, #0x14]
700a184a: b918         	cbnz	r0, 0x700a1854 <Udma_chOpen+0x114> @ imm = #0x6
700a184c: e7ff         	b	0x700a184e <Udma_chOpen+0x10e> @ imm = #-0x2
700a184e: 2001         	movs	r0, #0x1
;             allocDone = (uint32_t) TRUE;
700a1850: 9003         	str	r0, [sp, #0xc]
;         }
700a1852: e000         	b	0x700a1856 <Udma_chOpen+0x116> @ imm = #0x0
700a1854: e7ff         	b	0x700a1856 <Udma_chOpen+0x116> @ imm = #-0x2
;     }
700a1856: e7ff         	b	0x700a1858 <Udma_chOpen+0x118> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1858: 9805         	ldr	r0, [sp, #0x14]
700a185a: b948         	cbnz	r0, 0x700a1870 <Udma_chOpen+0x130> @ imm = #0x12
700a185c: e7ff         	b	0x700a185e <Udma_chOpen+0x11e> @ imm = #-0x2
;         retVal = Udma_chPair(chHandleInt);
700a185e: 9802         	ldr	r0, [sp, #0x8]
700a1860: f008 ff26    	bl	0x700aa6b0 <Udma_chPair> @ imm = #0x8e4c
700a1864: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != retVal)
700a1866: 9805         	ldr	r0, [sp, #0x14]
700a1868: b108         	cbz	r0, 0x700a186e <Udma_chOpen+0x12e> @ imm = #0x2
700a186a: e7ff         	b	0x700a186c <Udma_chOpen+0x12c> @ imm = #-0x2
;         }
700a186c: e7ff         	b	0x700a186e <Udma_chOpen+0x12e> @ imm = #-0x2
;     }
700a186e: e7ff         	b	0x700a1870 <Udma_chOpen+0x130> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1870: 9805         	ldr	r0, [sp, #0x14]
700a1872: b940         	cbnz	r0, 0x700a1886 <Udma_chOpen+0x146> @ imm = #0x10
700a1874: e7ff         	b	0x700a1876 <Udma_chOpen+0x136> @ imm = #-0x2
;         chHandleInt->chInitDone = UDMA_INIT_DONE;
700a1876: 9902         	ldr	r1, [sp, #0x8]
700a1878: f64a 30cd    	movw	r0, #0xabcd
700a187c: f6ca 30dc    	movt	r0, #0xabdc
700a1880: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a1884: e00d         	b	0x700a18a2 <Udma_chOpen+0x162> @ imm = #0x1a
;         if(((uint32_t) TRUE) == allocDone)
700a1886: 9803         	ldr	r0, [sp, #0xc]
700a1888: 2801         	cmp	r0, #0x1
700a188a: d109         	bne	0x700a18a0 <Udma_chOpen+0x160> @ imm = #0x12
700a188c: e7ff         	b	0x700a188e <Udma_chOpen+0x14e> @ imm = #-0x2
;             tempRetVal = Udma_chFreeResource(chHandleInt);
700a188e: 9802         	ldr	r0, [sp, #0x8]
700a1890: f7fd f9b6    	bl	0x7009ec00 <Udma_chFreeResource> @ imm = #-0x2c94
700a1894: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK != tempRetVal)
700a1896: 9804         	ldr	r0, [sp, #0x10]
700a1898: b108         	cbz	r0, 0x700a189e <Udma_chOpen+0x15e> @ imm = #0x2
700a189a: e7ff         	b	0x700a189c <Udma_chOpen+0x15c> @ imm = #-0x2
;             }
700a189c: e7ff         	b	0x700a189e <Udma_chOpen+0x15e> @ imm = #-0x2
;         }
700a189e: e7ff         	b	0x700a18a0 <Udma_chOpen+0x160> @ imm = #-0x2
700a18a0: e7ff         	b	0x700a18a2 <Udma_chOpen+0x162> @ imm = #-0x2
;     return (retVal);
700a18a2: 9805         	ldr	r0, [sp, #0x14]
700a18a4: b00a         	add	sp, #0x28
700a18a6: bd80         	pop	{r7, pc}
		...

700a18b0 <MedPrioTask>:
; {
700a18b0: b510         	push	{r4, lr}
700a18b2: f642 14f4    	movw	r4, #0x29f4
700a18b6: 2000         	movs	r0, #0x0
700a18b8: f2c7 040b    	movt	r4, #0x700b
700a18bc: bf00         	nop
700a18be: bf00         	nop
;       for (int i = 0; i < 1000; i++)
700a18c0: 3001         	adds	r0, #0x1
;          __asm__ volatile("nop");
700a18c2: bf00         	nop
;       for (int i = 0; i < 1000; i++)
700a18c4: f5b0 7f7a    	cmp.w	r0, #0x3e8
700a18c8: d1fa         	bne	0x700a18c0 <MedPrioTask+0x10> @ imm = #-0xc
;       tm_thread_sleep_ticks(2);
700a18ca: 2002         	movs	r0, #0x2
700a18cc: f00e fa50    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xe4a0
;       if (inversion_count >= ITERATION_COUNT)
700a18d0: 6821         	ldr	r1, [r4]
700a18d2: 2000         	movs	r0, #0x0
700a18d4: 291f         	cmp	r1, #0x1f
700a18d6: d9f3         	bls	0x700a18c0 <MedPrioTask+0x10> @ imm = #-0x1a
;          tm_thread_sleep_ticks(10);
700a18d8: 200a         	movs	r0, #0xa
700a18da: f00e fa49    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0xe492
;          printf("\r\n*** Test Complete ***\r\n");
700a18de: f641 61a4    	movw	r1, #0x1ea4
700a18e2: 2001         	movs	r0, #0x1
700a18e4: f2c7 010b    	movt	r1, #0x700b
700a18e8: f008 f93a    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #0x8274
;          printf("Total inversion cycles completed: %lu\r\n", inversion_count);
700a18ec: f641 311a    	movw	r1, #0x1b1a
700a18f0: 6822         	ldr	r2, [r4]
700a18f2: f2c7 010b    	movt	r1, #0x700b
700a18f6: 2001         	movs	r0, #0x1
700a18f8: f008 f932    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #0x8264
;             tm_pmu_profile_print(pmu_names[i]);
700a18fc: f644 2478    	movw	r4, #0x4a78
700a1900: f2c7 0408    	movt	r4, #0x7008
700a1904: 4620         	mov	r0, r4
700a1906: f00e fa23    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe446
700a190a: f104 0008    	add.w	r0, r4, #0x8
700a190e: f00e fa1f    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe43e
700a1912: f104 0010    	add.w	r0, r4, #0x10
700a1916: f00e fa1b    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe436
700a191a: f104 0018    	add.w	r0, r4, #0x18
700a191e: f00e fa17    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe42e
700a1922: f104 0020    	add.w	r0, r4, #0x20
700a1926: f00e fa13    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe426
700a192a: f104 0028    	add.w	r0, r4, #0x28
700a192e: f00e fa0f    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe41e
700a1932: f104 0030    	add.w	r0, r4, #0x30
700a1936: f00e fa0b    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe416
700a193a: f104 0038    	add.w	r0, r4, #0x38
700a193e: f00e fa07    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe40e
700a1942: f104 0040    	add.w	r0, r4, #0x40
700a1946: f00e fa03    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe406
700a194a: f104 0048    	add.w	r0, r4, #0x48
700a194e: f00e f9ff    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3fe
700a1952: f104 0050    	add.w	r0, r4, #0x50
700a1956: f00e f9fb    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3f6
700a195a: f104 0058    	add.w	r0, r4, #0x58
700a195e: f00e f9f7    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3ee
700a1962: f104 0060    	add.w	r0, r4, #0x60
700a1966: f00e f9f3    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3e6
700a196a: f104 0068    	add.w	r0, r4, #0x68
700a196e: f00e f9ef    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3de
700a1972: f104 0070    	add.w	r0, r4, #0x70
700a1976: f00e f9eb    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3d6
700a197a: f104 0078    	add.w	r0, r4, #0x78
700a197e: f00e f9e7    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3ce
700a1982: f104 0080    	add.w	r0, r4, #0x80
700a1986: f00e f9e3    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3c6
700a198a: f104 0088    	add.w	r0, r4, #0x88
700a198e: f00e f9df    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3be
700a1992: f104 0090    	add.w	r0, r4, #0x90
700a1996: f00e f9db    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3b6
700a199a: f104 0098    	add.w	r0, r4, #0x98
700a199e: f00e f9d7    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3ae
700a19a2: f104 00a0    	add.w	r0, r4, #0xa0
700a19a6: f00e f9d3    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe3a6
700a19aa: f104 00a8    	add.w	r0, r4, #0xa8
700a19ae: f00e f9cf    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe39e
700a19b2: f104 00b0    	add.w	r0, r4, #0xb0
700a19b6: f00e f9cb    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe396
700a19ba: f104 00b8    	add.w	r0, r4, #0xb8
700a19be: f00e f9c7    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe38e
700a19c2: f104 00c0    	add.w	r0, r4, #0xc0
700a19c6: f00e f9c3    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe386
700a19ca: f104 00c8    	add.w	r0, r4, #0xc8
700a19ce: f00e f9bf    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe37e
700a19d2: f104 00d0    	add.w	r0, r4, #0xd0
700a19d6: f00e f9bb    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe376
700a19da: f104 00d8    	add.w	r0, r4, #0xd8
700a19de: f00e f9b7    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe36e
700a19e2: f104 00e0    	add.w	r0, r4, #0xe0
700a19e6: f00e f9b3    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe366
700a19ea: f104 00e8    	add.w	r0, r4, #0xe8
700a19ee: f00e f9af    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe35e
700a19f2: f104 00f0    	add.w	r0, r4, #0xf0
700a19f6: f00e f9ab    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe356
700a19fa: f104 00f8    	add.w	r0, r4, #0xf8
700a19fe: f00e f9a7    	bl	0x700afd50 <tm_pmu_profile_print> @ imm = #0xe34e
;          tm_thread_exit(MED_TASK_ID);
700a1a02: 2001         	movs	r0, #0x1
700a1a04: e8bd 4010    	pop.w	{r4, lr}
700a1a08: f00d bc32    	b.w	0x700af270 <tm_thread_exit> @ imm = #0xd864
700a1a0c: 0000         	movs	r0, r0
700a1a0e: 0000         	movs	r0, r0

700a1a10 <Udma_rmAllocMappedRxCh>:
; {
700a1a10: b580         	push	{r7, lr}
700a1a12: b08a         	sub	sp, #0x28
700a1a14: 9009         	str	r0, [sp, #0x24]
700a1a16: 9108         	str	r1, [sp, #0x20]
700a1a18: 9207         	str	r2, [sp, #0x1c]
700a1a1a: 2000         	movs	r0, #0x0
700a1a1c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1a20: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1a22: 9808         	ldr	r0, [sp, #0x20]
700a1a24: f500 70ea    	add.w	r0, r0, #0x1d4
700a1a28: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1a2a: 9808         	ldr	r0, [sp, #0x20]
700a1a2c: f500 609f    	add.w	r0, r0, #0x4f8
700a1a30: f04f 31ff    	mov.w	r1, #0xffffffff
700a1a34: f008 fdf4    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x8be8
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1a38: 9809         	ldr	r0, [sp, #0x24]
700a1a3a: 2101         	movs	r1, #0x1
700a1a3c: f6cf 71ff    	movt	r1, #0xffff
700a1a40: 4288         	cmp	r0, r1
700a1a42: d142         	bne	0x700a1aca <Udma_rmAllocMappedRxCh+0xba> @ imm = #0x84
700a1a44: e7ff         	b	0x700a1a46 <Udma_rmAllocMappedRxCh+0x36> @ imm = #-0x2
700a1a46: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
700a1a48: 9005         	str	r0, [sp, #0x14]
700a1a4a: e7ff         	b	0x700a1a4c <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x2
700a1a4c: 9805         	ldr	r0, [sp, #0x14]
700a1a4e: 9901         	ldr	r1, [sp, #0x4]
700a1a50: 9a07         	ldr	r2, [sp, #0x1c]
700a1a52: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1a56: 6f89         	ldr	r1, [r1, #0x78]
700a1a58: 4288         	cmp	r0, r1
700a1a5a: d235         	bhs	0x700a1ac8 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x6a
700a1a5c: e7ff         	b	0x700a1a5e <Udma_rmAllocMappedRxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
700a1a5e: 9805         	ldr	r0, [sp, #0x14]
700a1a60: 0940         	lsrs	r0, r0, #0x5
700a1a62: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1a64: 9805         	ldr	r0, [sp, #0x14]
700a1a66: 9904         	ldr	r1, [sp, #0x10]
700a1a68: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1a6c: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1a6e: 9903         	ldr	r1, [sp, #0xc]
700a1a70: 2001         	movs	r0, #0x1
700a1a72: 4088         	lsls	r0, r1
700a1a74: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1a76: 9808         	ldr	r0, [sp, #0x20]
700a1a78: 9907         	ldr	r1, [sp, #0x1c]
700a1a7a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1a7e: 9904         	ldr	r1, [sp, #0x10]
700a1a80: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1a84: f8d0 0334    	ldr.w	r0, [r0, #0x334]
700a1a88: 9902         	ldr	r1, [sp, #0x8]
700a1a8a: 4008         	ands	r0, r1
700a1a8c: 4288         	cmp	r0, r1
700a1a8e: d116         	bne	0x700a1abe <Udma_rmAllocMappedRxCh+0xae> @ imm = #0x2c
700a1a90: e7ff         	b	0x700a1a92 <Udma_rmAllocMappedRxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1a92: 9a02         	ldr	r2, [sp, #0x8]
700a1a94: 9808         	ldr	r0, [sp, #0x20]
700a1a96: 9907         	ldr	r1, [sp, #0x1c]
700a1a98: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1a9c: 9904         	ldr	r1, [sp, #0x10]
700a1a9e: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1aa2: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a1aa6: 4390         	bics	r0, r2
700a1aa8: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = i + rmInitPrms->startMappedRxCh[mappedChGrp];  /* Add start offset */
700a1aac: 9805         	ldr	r0, [sp, #0x14]
700a1aae: 9901         	ldr	r1, [sp, #0x4]
700a1ab0: 9a07         	ldr	r2, [sp, #0x1c]
700a1ab2: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1ab6: 6e89         	ldr	r1, [r1, #0x68]
700a1ab8: 4408         	add	r0, r1
700a1aba: 9006         	str	r0, [sp, #0x18]
;                 break;
700a1abc: e004         	b	0x700a1ac8 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x8
;         }
700a1abe: e7ff         	b	0x700a1ac0 <Udma_rmAllocMappedRxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
700a1ac0: 9805         	ldr	r0, [sp, #0x14]
700a1ac2: 3001         	adds	r0, #0x1
700a1ac4: 9005         	str	r0, [sp, #0x14]
700a1ac6: e7c1         	b	0x700a1a4c <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x7e
;     }
700a1ac8: e047         	b	0x700a1b5a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
700a1aca: 9809         	ldr	r0, [sp, #0x24]
700a1acc: 9901         	ldr	r1, [sp, #0x4]
700a1ace: 9a07         	ldr	r2, [sp, #0x1c]
700a1ad0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1ad4: 6e89         	ldr	r1, [r1, #0x68]
700a1ad6: 4288         	cmp	r0, r1
700a1ad8: d33e         	blo	0x700a1b58 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x7c
700a1ada: e7ff         	b	0x700a1adc <Udma_rmAllocMappedRxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedRxCh[mappedChGrp] + rmInitPrms->numMappedRxCh[mappedChGrp])))
700a1adc: 9809         	ldr	r0, [sp, #0x24]
700a1ade: 9901         	ldr	r1, [sp, #0x4]
700a1ae0: 9a07         	ldr	r2, [sp, #0x1c]
700a1ae2: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a1ae6: 6e91         	ldr	r1, [r2, #0x68]
700a1ae8: 6f92         	ldr	r2, [r2, #0x78]
700a1aea: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
700a1aec: 4288         	cmp	r0, r1
700a1aee: d233         	bhs	0x700a1b58 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x66
700a1af0: e7ff         	b	0x700a1af2 <Udma_rmAllocMappedRxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700a1af2: 9809         	ldr	r0, [sp, #0x24]
700a1af4: 9901         	ldr	r1, [sp, #0x4]
700a1af6: 9a07         	ldr	r2, [sp, #0x1c]
700a1af8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1afc: 6e89         	ldr	r1, [r1, #0x68]
700a1afe: 1a40         	subs	r0, r0, r1
700a1b00: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1b02: 9805         	ldr	r0, [sp, #0x14]
700a1b04: 0940         	lsrs	r0, r0, #0x5
700a1b06: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1b08: 9805         	ldr	r0, [sp, #0x14]
700a1b0a: 9904         	ldr	r1, [sp, #0x10]
700a1b0c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1b10: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1b12: 9903         	ldr	r1, [sp, #0xc]
700a1b14: 2001         	movs	r0, #0x1
700a1b16: 4088         	lsls	r0, r1
700a1b18: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1b1a: 9808         	ldr	r0, [sp, #0x20]
700a1b1c: 9907         	ldr	r1, [sp, #0x1c]
700a1b1e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1b22: 9904         	ldr	r1, [sp, #0x10]
700a1b24: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1b28: f8d0 0334    	ldr.w	r0, [r0, #0x334]
700a1b2c: 9902         	ldr	r1, [sp, #0x8]
700a1b2e: 4008         	ands	r0, r1
700a1b30: 4288         	cmp	r0, r1
700a1b32: d110         	bne	0x700a1b56 <Udma_rmAllocMappedRxCh+0x146> @ imm = #0x20
700a1b34: e7ff         	b	0x700a1b36 <Udma_rmAllocMappedRxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1b36: 9a02         	ldr	r2, [sp, #0x8]
700a1b38: 9808         	ldr	r0, [sp, #0x20]
700a1b3a: 9907         	ldr	r1, [sp, #0x1c]
700a1b3c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1b40: 9904         	ldr	r1, [sp, #0x10]
700a1b42: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1b46: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a1b4a: 4390         	bics	r0, r2
700a1b4c: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = preferredChNum;
700a1b50: 9809         	ldr	r0, [sp, #0x24]
700a1b52: 9006         	str	r0, [sp, #0x18]
;             }
700a1b54: e7ff         	b	0x700a1b56 <Udma_rmAllocMappedRxCh+0x146> @ imm = #-0x2
;         }
700a1b56: e7ff         	b	0x700a1b58 <Udma_rmAllocMappedRxCh+0x148> @ imm = #-0x2
700a1b58: e7ff         	b	0x700a1b5a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1b5a: 9808         	ldr	r0, [sp, #0x20]
700a1b5c: f500 609f    	add.w	r0, r0, #0x4f8
700a1b60: f00a f926    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0xa24c
;     return (chNum);
700a1b64: 9806         	ldr	r0, [sp, #0x18]
700a1b66: b00a         	add	sp, #0x28
700a1b68: bd80         	pop	{r7, pc}
700a1b6a: 0000         	movs	r0, r0
700a1b6c: 0000         	movs	r0, r0
700a1b6e: 0000         	movs	r0, r0

700a1b70 <Udma_rmAllocMappedTxCh>:
; {
700a1b70: b580         	push	{r7, lr}
700a1b72: b08a         	sub	sp, #0x28
700a1b74: 9009         	str	r0, [sp, #0x24]
700a1b76: 9108         	str	r1, [sp, #0x20]
700a1b78: 9207         	str	r2, [sp, #0x1c]
700a1b7a: 2000         	movs	r0, #0x0
700a1b7c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1b80: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1b82: 9808         	ldr	r0, [sp, #0x20]
700a1b84: f500 70ea    	add.w	r0, r0, #0x1d4
700a1b88: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1b8a: 9808         	ldr	r0, [sp, #0x20]
700a1b8c: f500 609f    	add.w	r0, r0, #0x4f8
700a1b90: f04f 31ff    	mov.w	r1, #0xffffffff
700a1b94: f008 fd44    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x8a88
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1b98: 9809         	ldr	r0, [sp, #0x24]
700a1b9a: 2101         	movs	r1, #0x1
700a1b9c: f6cf 71ff    	movt	r1, #0xffff
700a1ba0: 4288         	cmp	r0, r1
700a1ba2: d142         	bne	0x700a1c2a <Udma_rmAllocMappedTxCh+0xba> @ imm = #0x84
700a1ba4: e7ff         	b	0x700a1ba6 <Udma_rmAllocMappedTxCh+0x36> @ imm = #-0x2
700a1ba6: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a1ba8: 9005         	str	r0, [sp, #0x14]
700a1baa: e7ff         	b	0x700a1bac <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x2
700a1bac: 9805         	ldr	r0, [sp, #0x14]
700a1bae: 9901         	ldr	r1, [sp, #0x4]
700a1bb0: 9a07         	ldr	r2, [sp, #0x1c]
700a1bb2: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1bb6: 6d89         	ldr	r1, [r1, #0x58]
700a1bb8: 4288         	cmp	r0, r1
700a1bba: d235         	bhs	0x700a1c28 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x6a
700a1bbc: e7ff         	b	0x700a1bbe <Udma_rmAllocMappedTxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
700a1bbe: 9805         	ldr	r0, [sp, #0x14]
700a1bc0: 0940         	lsrs	r0, r0, #0x5
700a1bc2: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1bc4: 9805         	ldr	r0, [sp, #0x14]
700a1bc6: 9904         	ldr	r1, [sp, #0x10]
700a1bc8: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1bcc: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1bce: 9903         	ldr	r1, [sp, #0xc]
700a1bd0: 2001         	movs	r0, #0x1
700a1bd2: 4088         	lsls	r0, r1
700a1bd4: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1bd6: 9808         	ldr	r0, [sp, #0x20]
700a1bd8: 9907         	ldr	r1, [sp, #0x1c]
700a1bda: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1bde: 9904         	ldr	r1, [sp, #0x10]
700a1be0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1be4: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a1be8: 9902         	ldr	r1, [sp, #0x8]
700a1bea: 4008         	ands	r0, r1
700a1bec: 4288         	cmp	r0, r1
700a1bee: d116         	bne	0x700a1c1e <Udma_rmAllocMappedTxCh+0xae> @ imm = #0x2c
700a1bf0: e7ff         	b	0x700a1bf2 <Udma_rmAllocMappedTxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1bf2: 9a02         	ldr	r2, [sp, #0x8]
700a1bf4: 9808         	ldr	r0, [sp, #0x20]
700a1bf6: 9907         	ldr	r1, [sp, #0x1c]
700a1bf8: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1bfc: 9904         	ldr	r1, [sp, #0x10]
700a1bfe: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1c02: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a1c06: 4390         	bics	r0, r2
700a1c08: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = i + rmInitPrms->startMappedTxCh[mappedChGrp];  /* Add start offset */
700a1c0c: 9805         	ldr	r0, [sp, #0x14]
700a1c0e: 9901         	ldr	r1, [sp, #0x4]
700a1c10: 9a07         	ldr	r2, [sp, #0x1c]
700a1c12: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1c16: 6c89         	ldr	r1, [r1, #0x48]
700a1c18: 4408         	add	r0, r1
700a1c1a: 9006         	str	r0, [sp, #0x18]
;                 break;
700a1c1c: e004         	b	0x700a1c28 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x8
;         }
700a1c1e: e7ff         	b	0x700a1c20 <Udma_rmAllocMappedTxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a1c20: 9805         	ldr	r0, [sp, #0x14]
700a1c22: 3001         	adds	r0, #0x1
700a1c24: 9005         	str	r0, [sp, #0x14]
700a1c26: e7c1         	b	0x700a1bac <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x7e
;     }
700a1c28: e047         	b	0x700a1cba <Udma_rmAllocMappedTxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a1c2a: 9809         	ldr	r0, [sp, #0x24]
700a1c2c: 9901         	ldr	r1, [sp, #0x4]
700a1c2e: 9a07         	ldr	r2, [sp, #0x1c]
700a1c30: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1c34: 6c89         	ldr	r1, [r1, #0x48]
700a1c36: 4288         	cmp	r0, r1
700a1c38: d33e         	blo	0x700a1cb8 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x7c
700a1c3a: e7ff         	b	0x700a1c3c <Udma_rmAllocMappedTxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedTxCh[mappedChGrp] + rmInitPrms->numMappedTxCh[mappedChGrp])))
700a1c3c: 9809         	ldr	r0, [sp, #0x24]
700a1c3e: 9901         	ldr	r1, [sp, #0x4]
700a1c40: 9a07         	ldr	r2, [sp, #0x1c]
700a1c42: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a1c46: 6c91         	ldr	r1, [r2, #0x48]
700a1c48: 6d92         	ldr	r2, [r2, #0x58]
700a1c4a: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a1c4c: 4288         	cmp	r0, r1
700a1c4e: d233         	bhs	0x700a1cb8 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x66
700a1c50: e7ff         	b	0x700a1c52 <Udma_rmAllocMappedTxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700a1c52: 9809         	ldr	r0, [sp, #0x24]
700a1c54: 9901         	ldr	r1, [sp, #0x4]
700a1c56: 9a07         	ldr	r2, [sp, #0x1c]
700a1c58: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1c5c: 6c89         	ldr	r1, [r1, #0x48]
700a1c5e: 1a40         	subs	r0, r0, r1
700a1c60: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1c62: 9805         	ldr	r0, [sp, #0x14]
700a1c64: 0940         	lsrs	r0, r0, #0x5
700a1c66: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1c68: 9805         	ldr	r0, [sp, #0x14]
700a1c6a: 9904         	ldr	r1, [sp, #0x10]
700a1c6c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1c70: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1c72: 9903         	ldr	r1, [sp, #0xc]
700a1c74: 2001         	movs	r0, #0x1
700a1c76: 4088         	lsls	r0, r1
700a1c78: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1c7a: 9808         	ldr	r0, [sp, #0x20]
700a1c7c: 9907         	ldr	r1, [sp, #0x1c]
700a1c7e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c82: 9904         	ldr	r1, [sp, #0x10]
700a1c84: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c88: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a1c8c: 9902         	ldr	r1, [sp, #0x8]
700a1c8e: 4008         	ands	r0, r1
700a1c90: 4288         	cmp	r0, r1
700a1c92: d110         	bne	0x700a1cb6 <Udma_rmAllocMappedTxCh+0x146> @ imm = #0x20
700a1c94: e7ff         	b	0x700a1c96 <Udma_rmAllocMappedTxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1c96: 9a02         	ldr	r2, [sp, #0x8]
700a1c98: 9808         	ldr	r0, [sp, #0x20]
700a1c9a: 9907         	ldr	r1, [sp, #0x1c]
700a1c9c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1ca0: 9904         	ldr	r1, [sp, #0x10]
700a1ca2: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1ca6: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a1caa: 4390         	bics	r0, r2
700a1cac: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = preferredChNum;
700a1cb0: 9809         	ldr	r0, [sp, #0x24]
700a1cb2: 9006         	str	r0, [sp, #0x18]
;             }
700a1cb4: e7ff         	b	0x700a1cb6 <Udma_rmAllocMappedTxCh+0x146> @ imm = #-0x2
;         }
700a1cb6: e7ff         	b	0x700a1cb8 <Udma_rmAllocMappedTxCh+0x148> @ imm = #-0x2
700a1cb8: e7ff         	b	0x700a1cba <Udma_rmAllocMappedTxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1cba: 9808         	ldr	r0, [sp, #0x20]
700a1cbc: f500 609f    	add.w	r0, r0, #0x4f8
700a1cc0: f00a f876    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0xa0ec
;     return (chNum);
700a1cc4: 9806         	ldr	r0, [sp, #0x18]
700a1cc6: b00a         	add	sp, #0x28
700a1cc8: bd80         	pop	{r7, pc}
700a1cca: 0000         	movs	r0, r0
700a1ccc: 0000         	movs	r0, r0
700a1cce: 0000         	movs	r0, r0

700a1cd0 <CSL_bcdmaChanOpGetChanStats>:
; {
700a1cd0: b580         	push	{r7, lr}
700a1cd2: b088         	sub	sp, #0x20
700a1cd4: 9007         	str	r0, [sp, #0x1c]
700a1cd6: 9106         	str	r1, [sp, #0x18]
700a1cd8: 9205         	str	r2, [sp, #0x14]
700a1cda: 9304         	str	r3, [sp, #0x10]
700a1cdc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a1cde: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a1ce0: 9804         	ldr	r0, [sp, #0x10]
700a1ce2: b920         	cbnz	r0, 0x700a1cee <CSL_bcdmaChanOpGetChanStats+0x1e> @ imm = #0x8
700a1ce4: e7ff         	b	0x700a1ce6 <CSL_bcdmaChanOpGetChanStats+0x16> @ imm = #-0x2
700a1ce6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a1cea: 9003         	str	r0, [sp, #0xc]
;     }
700a1cec: e099         	b	0x700a1e22 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #0x132
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a1cee: 9804         	ldr	r0, [sp, #0x10]
700a1cf0: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a1cf2: 9806         	ldr	r0, [sp, #0x18]
700a1cf4: 9001         	str	r0, [sp, #0x4]
700a1cf6: b140         	cbz	r0, 0x700a1d0a <CSL_bcdmaChanOpGetChanStats+0x3a> @ imm = #0x10
700a1cf8: e7ff         	b	0x700a1cfa <CSL_bcdmaChanOpGetChanStats+0x2a> @ imm = #-0x2
700a1cfa: 9801         	ldr	r0, [sp, #0x4]
700a1cfc: 2801         	cmp	r0, #0x1
700a1cfe: d031         	beq	0x700a1d64 <CSL_bcdmaChanOpGetChanStats+0x94> @ imm = #0x62
700a1d00: e7ff         	b	0x700a1d02 <CSL_bcdmaChanOpGetChanStats+0x32> @ imm = #-0x2
700a1d02: 9801         	ldr	r0, [sp, #0x4]
700a1d04: 2802         	cmp	r0, #0x2
700a1d06: d05a         	beq	0x700a1dbe <CSL_bcdmaChanOpGetChanStats+0xee> @ imm = #0xb4
700a1d08: e086         	b	0x700a1e18 <CSL_bcdmaChanOpGetChanStats+0x148> @ imm = #0x10c
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT );
700a1d0a: 9807         	ldr	r0, [sp, #0x1c]
700a1d0c: 6880         	ldr	r0, [r0, #0x8]
700a1d0e: 9905         	ldr	r1, [sp, #0x14]
700a1d10: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1d14: f500 6080    	add.w	r0, r0, #0x400
700a1d18: f00d ff52    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xdea4
700a1d1c: 9902         	ldr	r1, [sp, #0x8]
700a1d1e: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT );
700a1d20: 9807         	ldr	r0, [sp, #0x1c]
700a1d22: 6880         	ldr	r0, [r0, #0x8]
700a1d24: 9905         	ldr	r1, [sp, #0x14]
700a1d26: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1d2a: f500 6081    	add.w	r0, r0, #0x408
700a1d2e: f00d ff47    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xde8e
700a1d32: 9902         	ldr	r1, [sp, #0x8]
700a1d34: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT );
700a1d36: 9807         	ldr	r0, [sp, #0x1c]
700a1d38: 6880         	ldr	r0, [r0, #0x8]
700a1d3a: 9905         	ldr	r1, [sp, #0x14]
700a1d3c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1d40: f500 6082    	add.w	r0, r0, #0x410
700a1d44: f00d ff3c    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xde78
700a1d48: 9902         	ldr	r1, [sp, #0x8]
700a1d4a: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a1d4c: 9902         	ldr	r1, [sp, #0x8]
700a1d4e: 2000         	movs	r0, #0x0
700a1d50: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a1d52: 9902         	ldr	r1, [sp, #0x8]
700a1d54: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a1d56: 9902         	ldr	r1, [sp, #0x8]
700a1d58: 6848         	ldr	r0, [r1, #0x4]
700a1d5a: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a1d5c: 9902         	ldr	r1, [sp, #0x8]
700a1d5e: 6888         	ldr	r0, [r1, #0x8]
700a1d60: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1d62: e05d         	b	0x700a1e20 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0xba
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT );
700a1d64: 9807         	ldr	r0, [sp, #0x1c]
700a1d66: 6900         	ldr	r0, [r0, #0x10]
700a1d68: 9905         	ldr	r1, [sp, #0x14]
700a1d6a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1d6e: f500 6080    	add.w	r0, r0, #0x400
700a1d72: f00d ff25    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xde4a
700a1d76: 9902         	ldr	r1, [sp, #0x8]
700a1d78: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT );
700a1d7a: 9807         	ldr	r0, [sp, #0x1c]
700a1d7c: 6900         	ldr	r0, [r0, #0x10]
700a1d7e: 9905         	ldr	r1, [sp, #0x14]
700a1d80: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1d84: f500 6081    	add.w	r0, r0, #0x408
700a1d88: f00d ff1a    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xde34
700a1d8c: 9902         	ldr	r1, [sp, #0x8]
700a1d8e: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT );
700a1d90: 9807         	ldr	r0, [sp, #0x1c]
700a1d92: 6900         	ldr	r0, [r0, #0x10]
700a1d94: 9905         	ldr	r1, [sp, #0x14]
700a1d96: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1d9a: f500 6082    	add.w	r0, r0, #0x410
700a1d9e: f00d ff0f    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xde1e
700a1da2: 9902         	ldr	r1, [sp, #0x8]
700a1da4: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a1da6: 9902         	ldr	r1, [sp, #0x8]
700a1da8: 2000         	movs	r0, #0x0
700a1daa: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a1dac: 9902         	ldr	r1, [sp, #0x8]
700a1dae: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a1db0: 9902         	ldr	r1, [sp, #0x8]
700a1db2: 6848         	ldr	r0, [r1, #0x4]
700a1db4: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a1db6: 9902         	ldr	r1, [sp, #0x8]
700a1db8: 6888         	ldr	r0, [r1, #0x8]
700a1dba: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1dbc: e030         	b	0x700a1e20 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x60
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT );
700a1dbe: 9807         	ldr	r0, [sp, #0x1c]
700a1dc0: 6980         	ldr	r0, [r0, #0x18]
700a1dc2: 9905         	ldr	r1, [sp, #0x14]
700a1dc4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1dc8: f500 6080    	add.w	r0, r0, #0x400
700a1dcc: f00d fef8    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xddf0
700a1dd0: 9902         	ldr	r1, [sp, #0x8]
700a1dd2: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = (uint32_t)0U;
700a1dd4: 9902         	ldr	r1, [sp, #0x8]
700a1dd6: 2000         	movs	r0, #0x0
700a1dd8: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = (uint32_t)0U;
700a1dda: 9902         	ldr	r1, [sp, #0x8]
700a1ddc: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT );
700a1dde: 9807         	ldr	r0, [sp, #0x1c]
700a1de0: 6980         	ldr	r0, [r0, #0x18]
700a1de2: 9905         	ldr	r1, [sp, #0x14]
700a1de4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1de8: f500 6081    	add.w	r0, r0, #0x408
700a1dec: f00d fee8    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xddd0
700a1df0: 9902         	ldr	r1, [sp, #0x8]
700a1df2: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT );
700a1df4: 9807         	ldr	r0, [sp, #0x1c]
700a1df6: 6980         	ldr	r0, [r0, #0x18]
700a1df8: 9905         	ldr	r1, [sp, #0x14]
700a1dfa: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1dfe: f500 6082    	add.w	r0, r0, #0x410
700a1e02: f00d fedd    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xddba
700a1e06: 9902         	ldr	r1, [sp, #0x8]
700a1e08: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->rxPayloadByteCnt;
700a1e0a: 9902         	ldr	r1, [sp, #0x8]
700a1e0c: 68c8         	ldr	r0, [r1, #0xc]
700a1e0e: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->rxStartedByteCnt;
700a1e10: 9902         	ldr	r1, [sp, #0x8]
700a1e12: 6908         	ldr	r0, [r1, #0x10]
700a1e14: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1e16: e003         	b	0x700a1e20 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x6
700a1e18: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a1e1c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1e1e: e7ff         	b	0x700a1e20 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #-0x2
700a1e20: e7ff         	b	0x700a1e22 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #-0x2
;     return retVal;
700a1e22: 9803         	ldr	r0, [sp, #0xc]
700a1e24: b008         	add	sp, #0x20
700a1e26: bd80         	pop	{r7, pc}
		...

700a1e30 <UART_lld_initDma>:
; {
700a1e30: b580         	push	{r7, lr}
700a1e32: b084         	sub	sp, #0x10
700a1e34: 9003         	str	r0, [sp, #0xc]
700a1e36: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a1e38: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a1e3a: 9803         	ldr	r0, [sp, #0xc]
700a1e3c: b168         	cbz	r0, 0x700a1e5a <UART_lld_initDma+0x2a> @ imm = #0x1a
700a1e3e: e7ff         	b	0x700a1e40 <UART_lld_initDma+0x10> @ imm = #-0x2
700a1e40: 9803         	ldr	r0, [sp, #0xc]
700a1e42: 6840         	ldr	r0, [r0, #0x4]
700a1e44: b148         	cbz	r0, 0x700a1e5a <UART_lld_initDma+0x2a> @ imm = #0x12
700a1e46: e7ff         	b	0x700a1e48 <UART_lld_initDma+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a1e48: 9803         	ldr	r0, [sp, #0xc]
700a1e4a: 6d40         	ldr	r0, [r0, #0x54]
700a1e4c: b120         	cbz	r0, 0x700a1e58 <UART_lld_initDma+0x28> @ imm = #0x8
700a1e4e: e7ff         	b	0x700a1e50 <UART_lld_initDma+0x20> @ imm = #-0x2
700a1e50: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a1e54: 9002         	str	r0, [sp, #0x8]
;         }
700a1e56: e7ff         	b	0x700a1e58 <UART_lld_initDma+0x28> @ imm = #-0x2
;     }
700a1e58: e003         	b	0x700a1e62 <UART_lld_initDma+0x32> @ imm = #0x6
700a1e5a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a1e5e: 9002         	str	r0, [sp, #0x8]
700a1e60: e7ff         	b	0x700a1e62 <UART_lld_initDma+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a1e62: 9802         	ldr	r0, [sp, #0x8]
700a1e64: 2800         	cmp	r0, #0x0
700a1e66: d170         	bne	0x700a1f4a <UART_lld_initDma+0x11a> @ imm = #0xe0
700a1e68: e7ff         	b	0x700a1e6a <UART_lld_initDma+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a1e6a: 9903         	ldr	r1, [sp, #0xc]
700a1e6c: 2002         	movs	r0, #0x2
700a1e6e: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a1e70: 9803         	ldr	r0, [sp, #0xc]
700a1e72: 6840         	ldr	r0, [r0, #0x4]
700a1e74: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a1e76: 9801         	ldr	r0, [sp, #0x4]
700a1e78: 6d82         	ldr	r2, [r0, #0x58]
700a1e7a: f244 2040    	movw	r0, #0x4240
700a1e7e: f2c0 000f    	movt	r0, #0xf
700a1e82: 2100         	movs	r1, #0x0
700a1e84: 9100         	str	r1, [sp]
700a1e86: 4790         	blx	r2
700a1e88: 9a00         	ldr	r2, [sp]
700a1e8a: 9903         	ldr	r1, [sp, #0xc]
700a1e8c: 66ca         	str	r2, [r1, #0x6c]
700a1e8e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a1e90: 9803         	ldr	r0, [sp, #0xc]
700a1e92: 6800         	ldr	r0, [r0]
700a1e94: f006 fbf4    	bl	0x700a8680 <UART_IsBaseAddrValid> @ imm = #0x67e8
700a1e98: 4601         	mov	r1, r0
700a1e9a: 9802         	ldr	r0, [sp, #0x8]
700a1e9c: 4408         	add	r0, r1
700a1e9e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a1ea0: 9801         	ldr	r0, [sp, #0x4]
700a1ea2: 6800         	ldr	r0, [r0]
700a1ea4: f00d fb3c    	bl	0x700af520 <UART_IsParameter> @ imm = #0xd678
700a1ea8: 4601         	mov	r1, r0
700a1eaa: 9802         	ldr	r0, [sp, #0x8]
700a1eac: 4408         	add	r0, r1
700a1eae: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a1eb0: 9801         	ldr	r0, [sp, #0x4]
700a1eb2: 6840         	ldr	r0, [r0, #0x4]
700a1eb4: f00d fb34    	bl	0x700af520 <UART_IsParameter> @ imm = #0xd668
700a1eb8: 4601         	mov	r1, r0
700a1eba: 9802         	ldr	r0, [sp, #0x8]
700a1ebc: 4408         	add	r0, r1
700a1ebe: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a1ec0: 9801         	ldr	r0, [sp, #0x4]
700a1ec2: 6880         	ldr	r0, [r0, #0x8]
700a1ec4: f00c fb04    	bl	0x700ae4d0 <UART_IsDataLengthValid> @ imm = #0xc608
700a1ec8: 4601         	mov	r1, r0
700a1eca: 9802         	ldr	r0, [sp, #0x8]
700a1ecc: 4408         	add	r0, r1
700a1ece: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a1ed0: 9801         	ldr	r0, [sp, #0x4]
700a1ed2: 68c0         	ldr	r0, [r0, #0xc]
700a1ed4: f00d f92c    	bl	0x700af130 <UART_IsStopBitsValid> @ imm = #0xd258
700a1ed8: 4601         	mov	r1, r0
700a1eda: 9802         	ldr	r0, [sp, #0x8]
700a1edc: 4408         	add	r0, r1
700a1ede: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a1ee0: 9801         	ldr	r0, [sp, #0x4]
700a1ee2: 6900         	ldr	r0, [r0, #0x10]
700a1ee4: f00c f834    	bl	0x700adf50 <UART_IsParityTypeValid> @ imm = #0xc068
700a1ee8: 4601         	mov	r1, r0
700a1eea: 9802         	ldr	r0, [sp, #0x8]
700a1eec: 4408         	add	r0, r1
700a1eee: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a1ef0: 9801         	ldr	r0, [sp, #0x4]
700a1ef2: 69c0         	ldr	r0, [r0, #0x1c]
700a1ef4: f00b feec    	bl	0x700adcd0 <UART_IsHWFlowCtrlValid> @ imm = #0xbdd8
700a1ef8: 4601         	mov	r1, r0
700a1efa: 9802         	ldr	r0, [sp, #0x8]
700a1efc: 4408         	add	r0, r1
700a1efe: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a1f00: 9801         	ldr	r0, [sp, #0x4]
700a1f02: 6ac0         	ldr	r0, [r0, #0x2c]
700a1f04: f00a ff1c    	bl	0x700acd40 <UART_OperModeValid> @ imm = #0xae38
700a1f08: 4601         	mov	r1, r0
700a1f0a: 9802         	ldr	r0, [sp, #0x8]
700a1f0c: 4408         	add	r0, r1
700a1f0e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a1f10: 9801         	ldr	r0, [sp, #0x4]
700a1f12: 6b80         	ldr	r0, [r0, #0x38]
700a1f14: f00b fefc    	bl	0x700add10 <UART_IsRxTrigLvlValid> @ imm = #0xbdf8
700a1f18: 4601         	mov	r1, r0
700a1f1a: 9802         	ldr	r0, [sp, #0x8]
700a1f1c: 4408         	add	r0, r1
700a1f1e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a1f20: 9801         	ldr	r0, [sp, #0x4]
700a1f22: 6bc0         	ldr	r0, [r0, #0x3c]
700a1f24: f00b ff14    	bl	0x700add50 <UART_IsTxTrigLvlValid> @ imm = #0xbe28
700a1f28: 4601         	mov	r1, r0
700a1f2a: 9802         	ldr	r0, [sp, #0x8]
700a1f2c: 4408         	add	r0, r1
700a1f2e: 9002         	str	r0, [sp, #0x8]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a1f30: 9801         	ldr	r0, [sp, #0x4]
700a1f32: 6c80         	ldr	r0, [r0, #0x48]
;             || (hUartInit->dmaChCfg == NULL_PTR))
700a1f34: b120         	cbz	r0, 0x700a1f40 <UART_lld_initDma+0x110> @ imm = #0x8
700a1f36: e7ff         	b	0x700a1f38 <UART_lld_initDma+0x108> @ imm = #-0x2
700a1f38: 9801         	ldr	r0, [sp, #0x4]
700a1f3a: 6cc0         	ldr	r0, [r0, #0x4c]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a1f3c: b920         	cbnz	r0, 0x700a1f48 <UART_lld_initDma+0x118> @ imm = #0x8
700a1f3e: e7ff         	b	0x700a1f40 <UART_lld_initDma+0x110> @ imm = #-0x2
;             status += UART_INVALID_PARAM;
700a1f40: 9802         	ldr	r0, [sp, #0x8]
700a1f42: 3803         	subs	r0, #0x3
700a1f44: 9002         	str	r0, [sp, #0x8]
;         }
700a1f46: e7ff         	b	0x700a1f48 <UART_lld_initDma+0x118> @ imm = #-0x2
;     }
700a1f48: e7ff         	b	0x700a1f4a <UART_lld_initDma+0x11a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a1f4a: 9802         	ldr	r0, [sp, #0x8]
700a1f4c: b950         	cbnz	r0, 0x700a1f64 <UART_lld_initDma+0x134> @ imm = #0x14
700a1f4e: e7ff         	b	0x700a1f50 <UART_lld_initDma+0x120> @ imm = #-0x2
;         UART_configInstance(hUart);
700a1f50: 9803         	ldr	r0, [sp, #0xc]
700a1f52: f003 fa95    	bl	0x700a5480 <UART_configInstance> @ imm = #0x352a
;         status = UART_lld_dmaInit(hUart, hUart->hUartInit->dmaChCfg);
700a1f56: 9803         	ldr	r0, [sp, #0xc]
700a1f58: 6841         	ldr	r1, [r0, #0x4]
700a1f5a: 6cc9         	ldr	r1, [r1, #0x4c]
700a1f5c: f00b faa0    	bl	0x700ad4a0 <UART_lld_dmaInit> @ imm = #0xb540
700a1f60: 9002         	str	r0, [sp, #0x8]
;     }
700a1f62: e7ff         	b	0x700a1f64 <UART_lld_initDma+0x134> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a1f64: 9802         	ldr	r0, [sp, #0x8]
700a1f66: b920         	cbnz	r0, 0x700a1f72 <UART_lld_initDma+0x142> @ imm = #0x8
700a1f68: e7ff         	b	0x700a1f6a <UART_lld_initDma+0x13a> @ imm = #-0x2
;         hUart->state = UART_STATE_READY;
700a1f6a: 9903         	ldr	r1, [sp, #0xc]
700a1f6c: 2001         	movs	r0, #0x1
700a1f6e: 6548         	str	r0, [r1, #0x54]
;     }
700a1f70: e004         	b	0x700a1f7c <UART_lld_initDma+0x14c> @ imm = #0x8
;        status = UART_lld_deInitDma(hUart);
700a1f72: 9803         	ldr	r0, [sp, #0xc]
700a1f74: f009 fdcc    	bl	0x700abb10 <UART_lld_deInitDma> @ imm = #0x9b98
700a1f78: 9002         	str	r0, [sp, #0x8]
700a1f7a: e7ff         	b	0x700a1f7c <UART_lld_initDma+0x14c> @ imm = #-0x2
;     return status;
700a1f7c: 9802         	ldr	r0, [sp, #0x8]
700a1f7e: b004         	add	sp, #0x10
700a1f80: bd80         	pop	{r7, pc}
700a1f82: 0000         	movs	r0, r0

700a1f84 <CSL_armR5PmuSelectCntr>:
;     AND     r0, r0, #0x1F
700a1f84: e200001f     	and	r0, r0, #31
;     MCR     p15, #0, r0, c9, c12, #5        /* Write PMSELR Register */
700a1f88: ee090fbc     	mcr	p15, #0x0, r0, c9, c12, #0x5
;     BX      lr
700a1f8c: e12fff1e     	bx	lr

700a1f90 <CSL_armR5PmuCfg>:
;     MRC     p15, #0, r3, c9, c12, #0        /* Read PMCR Register */
700a1f90: ee193f1c     	mrc	p15, #0x0, r3, c9, c12, #0x0
;     BIC     r3, r3, #((1<<3) | (1<<4))      /* Clear D and X bits */
700a1f94: e3c33018     	bic	r3, r3, #24
;     CMP     r0, #0
700a1f98: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuCfg_00
700a1f9c: 0a000000     	beq	0x700a1fa4 <armR5PmuCfg_00> @ imm = #0x0
;     ORR     r3, r3, #(1<<3)                 /* Set D bit */
700a1fa0: e3833008     	orr	r3, r3, #8

700a1fa4 <armR5PmuCfg_00>:
;     CMP     r1, #0
700a1fa4: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuCfg_01
700a1fa8: 0a000000     	beq	0x700a1fb0 <armR5PmuCfg_01> @ imm = #0x0
;     ORR     r3, r3, #(1<<4)                 /* Set X bit */
700a1fac: e3833010     	orr	r3, r3, #16

700a1fb0 <armR5PmuCfg_01>:
;     MCR     p15, #0, r3, c9, c12, #0        /* Write PMCR Register */
700a1fb0: ee093f1c     	mcr	p15, #0x0, r3, c9, c12, #0x0
;     EOR     r3, r3, r3                      /* Clear r3 */
700a1fb4: e0233003     	eor	r3, r3, r3
;     CMP     r2, #0
700a1fb8: e3520000     	cmp	r2, #0
;     BEQ     armR5PmuCfg_02
700a1fbc: 0a000000     	beq	0x700a1fc4 <armR5PmuCfg_02> @ imm = #0x0
;     ORR     r3, r3, #1
700a1fc0: e3833001     	orr	r3, r3, #1

700a1fc4 <armR5PmuCfg_02>:
;     MCR     p15, #0, r3, c9, c14, #0        /* Write PMUSERENR Register */
700a1fc4: ee093f1e     	mcr	p15, #0x0, r3, c9, c14, #0x0
;     BX      lr
700a1fc8: e12fff1e     	bx	lr

700a1fcc <CSL_armR5PmuEnableAllCntrs>:
;     MRC     p15, #0, r1, c9, c12, #0        /* Read PMCR */
700a1fcc: ee191f1c     	mrc	p15, #0x0, r1, c9, c12, #0x0
;     CMP     r0, #0
700a1fd0: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuEnableAllCntrs_disable
700a1fd4: 0a000001     	beq	0x700a1fe0 <armR5PmuEnableAllCntrs_disable> @ imm = #0x4
;     ORR     r1, r1, #0x1                    /* Set E bit to enable all counters */
700a1fd8: e3811001     	orr	r1, r1, #1
;     B       armR5PmuEnableAllCntrs_00
700a1fdc: ea000000     	b	0x700a1fe4 <armR5PmuEnableAllCntrs_00> @ imm = #0x0

700a1fe0 <armR5PmuEnableAllCntrs_disable>:
;     BIC     r1, r1, #0x1                    /* Clr E bit to disable all counters */
700a1fe0: e3c11001     	bic	r1, r1, #1

700a1fe4 <armR5PmuEnableAllCntrs_00>:
;     MCR     p15, #0, r1, c9, c12, #0        /* Write modified PMCR */
700a1fe4: ee091f1c     	mcr	p15, #0x0, r1, c9, c12, #0x0
;     BX      lr
700a1fe8: e12fff1e     	bx	lr

700a1fec <CSL_armR5PmuGetNumCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR (Performance Monitor Control Register) */
700a1fec: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     LSR     r0, r0, #11                     /* Shift and */
700a1ff0: e1a005a0     	lsr	r0, r0, #11
;     AND     r0, r0, #0x1F                   /*   mask to get N */
700a1ff4: e200001f     	and	r0, r0, #31
;     BX      lr
700a1ff8: e12fff1e     	bx	lr

700a1ffc <CSL_armR5PmuCfgCntr>:
;     PUSH    {lr}
700a1ffc: e52de004     	str	lr, [sp, #-0x4]!
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a2000: ebffffdf     	bl	0x700a1f84 <CSL_armR5PmuSelectCntr> @ imm = #-0x84
;     AND     r1, r1, #0xFF
700a2004: e20110ff     	and	r1, r1, #255
;     MCR     p15, #0, r1, c9, c13, #1        /* Write PMXEVTYPERx Register */
700a2008: ee091f3d     	mcr	p15, #0x0, r1, c9, c13, #0x1
;     POP     {lr}
700a200c: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a2010: e12fff1e     	bx	lr

700a2014 <CSL_armR5PmuEnableCntrOverflowIntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a2014: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a2018: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a201c: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a2020: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrOverflowIntr_clear
700a2024: 0a000001     	beq	0x700a2030 <armR5PmuEnableCntrOverflowIntr_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c14, #1        /* Write PMINTENSET Register (writes of 0 have no effect) */
700a2028: ee090f3e     	mcr	p15, #0x0, r0, c9, c14, #0x1
;     B       armR5PmuEnableCntrOverflowIntr_00
700a202c: ea000000     	b	0x700a2034 <armR5PmuEnableCntrOverflowIntr_00> @ imm = #0x0

700a2030 <armR5PmuEnableCntrOverflowIntr_clear>:
;     MCR     p15, #0, r0, c9, c14, #2        /* Write PMINTENCLR Register (writes of 0 have no effect) */
700a2030: ee090f5e     	mcr	p15, #0x0, r0, c9, c14, #0x2

700a2034 <armR5PmuEnableCntrOverflowIntr_00>:
;     BX      lr
700a2034: e12fff1e     	bx	lr

700a2038 <CSL_armR5PmuEnableCntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a2038: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a203c: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a2040: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a2044: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrs_clear
700a2048: 0a000001     	beq	0x700a2054 <armR5PmuEnableCntrs_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c12, #1        /* Write PMCNTENSET Register (writes of 0 have no effect) */
700a204c: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;     B       armR5PmuEnableCntrs_00
700a2050: ea000000     	b	0x700a2058 <armR5PmuEnableCntrs_00> @ imm = #0x0

700a2054 <armR5PmuEnableCntrs_clear>:
;     MCR     p15, #0, r0, c9, c12, #2        /* Write PMCNTENCLR Register (writes of 0 have no effect) */
700a2054: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2

700a2058 <armR5PmuEnableCntrs_00>:
;     BX      lr
700a2058: e12fff1e     	bx	lr

700a205c <CSL_armR5PmuReadCntr>:
;     PUSH    {lr}
700a205c: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a2060: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuReadCntr_cycles
700a2064: 0a000002     	beq	0x700a2074 <armR5PmuReadCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a2068: ebffffc5     	bl	0x700a1f84 <CSL_armR5PmuSelectCntr> @ imm = #-0xec
;     MRC     p15, #0, r0, c9, c13, #2        /* Read current PMNx Register */
700a206c: ee190f5d     	mrc	p15, #0x0, r0, c9, c13, #0x2
;     B       armR5PmuReadCntr_00
700a2070: ea000000     	b	0x700a2078 <armR5PmuReadCntr_00> @ imm = #0x0

700a2074 <armR5PmuReadCntr_cycles>:
;     MRC     p15, #0, r0, c9, c13, #0        /* Read PMCCNTR Register */
700a2074: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0

700a2078 <armR5PmuReadCntr_00>:
;     POP     {lr}
700a2078: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a207c: e12fff1e     	bx	lr

700a2080 <CSL_armR5PmuSetCntr>:
;     PUSH    {lr}
700a2080: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a2084: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuSetCntr_cycles
700a2088: 0a000002     	beq	0x700a2098 <armR5PmuSetCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a208c: ebffffbc     	bl	0x700a1f84 <CSL_armR5PmuSelectCntr> @ imm = #-0x110
;     MCR     p15, #0, r1, c9, c13, #2        /* Write current PMNx Register */
700a2090: ee091f5d     	mcr	p15, #0x0, r1, c9, c13, #0x2
;     B       armR5PmuSetCntr_00
700a2094: ea000000     	b	0x700a209c <armR5PmuSetCntr_00> @ imm = #0x0

700a2098 <armR5PmuSetCntr_cycles>:
;     MCR     p15, #0, r1, c9, c13, #0        /* Write PMCCNTR Register */
700a2098: ee091f1d     	mcr	p15, #0x0, r1, c9, c13, #0x0

700a209c <armR5PmuSetCntr_00>:
;     POP     {lr}
700a209c: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a20a0: e12fff1e     	bx	lr

700a20a4 <CSL_armR5PmuReadCntrOverflowStatus>:
;     MRC     p15, #0, r0, c9, c12, #3        /* Read PMOVSR Register */
700a20a4: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a20a8: e12fff1e     	bx	lr

700a20ac <CSL_armR5PmuClearCntrOverflowStatus>:
;     MCR     p15, #0, r0, c9, c12, #3        /* Write PMOVSR Register */
700a20ac: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a20b0: e12fff1e     	bx	lr

700a20b4 <CSL_armR5PmuResetCycleCnt>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a20b4: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<2)                 /* Set C bit to reset the cycle counter, PMCCNTR, to zero */
700a20b8: e3800004     	orr	r0, r0, #4
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR*/
700a20bc: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a20c0: e12fff1e     	bx	lr

700a20c4 <CSL_armR5PmuResetCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a20c4: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<1)                 /* Set P bit to reset all event counters to zero */
700a20c8: e3800002     	orr	r0, r0, #2
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR */
700a20cc: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a20d0: e12fff1e     	bx	lr
		...

700a20e0 <xTaskResumeAll>:
; BaseType_t xTaskResumeAll(void) {
700a20e0: b580         	push	{r7, lr}
700a20e2: b084         	sub	sp, #0x10
700a20e4: 2000         	movs	r0, #0x0
;   TCB_t *pxTCB = NULL;
700a20e6: 9003         	str	r0, [sp, #0xc]
;   BaseType_t xAlreadyYielded = pdFALSE;
700a20e8: 9002         	str	r0, [sp, #0x8]
;   taskENTER_CRITICAL();
700a20ea: f00c fae9    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0xc5d2
;     --uxSchedulerSuspended;
700a20ee: f642 2024    	movw	r0, #0x2a24
700a20f2: f2c7 000b    	movt	r0, #0x700b
700a20f6: 6801         	ldr	r1, [r0]
700a20f8: 3901         	subs	r1, #0x1
700a20fa: 6001         	str	r1, [r0]
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a20fc: 6800         	ldr	r0, [r0]
700a20fe: 2800         	cmp	r0, #0x0
700a2100: f040 808f    	bne.w	0x700a2222 <xTaskResumeAll+0x142> @ imm = #0x11e
700a2104: e7ff         	b	0x700a2106 <xTaskResumeAll+0x26> @ imm = #-0x2
;       if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
700a2106: f642 201c    	movw	r0, #0x2a1c
700a210a: f2c7 000b    	movt	r0, #0x700b
700a210e: 6800         	ldr	r0, [r0]
700a2110: 2800         	cmp	r0, #0x0
700a2112: f000 8085    	beq.w	0x700a2220 <xTaskResumeAll+0x140> @ imm = #0x10a
700a2116: e7ff         	b	0x700a2118 <xTaskResumeAll+0x38> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a2118: e7ff         	b	0x700a211a <xTaskResumeAll+0x3a> @ imm = #-0x2
700a211a: f245 00e0    	movw	r0, #0x50e0
700a211e: f2c7 0008    	movt	r0, #0x7008
700a2122: 6800         	ldr	r0, [r0]
700a2124: 2800         	cmp	r0, #0x0
700a2126: d042         	beq	0x700a21ae <xTaskResumeAll+0xce> @ imm = #0x84
700a2128: e7ff         	b	0x700a212a <xTaskResumeAll+0x4a> @ imm = #-0x2
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a212a: f245 00e0    	movw	r0, #0x50e0
700a212e: f2c7 0008    	movt	r0, #0x7008
700a2132: 68c0         	ldr	r0, [r0, #0xc]
700a2134: 68c0         	ldr	r0, [r0, #0xc]
700a2136: 9003         	str	r0, [sp, #0xc]
;           (void)uxListRemove(&(pxTCB->xEventListItem));
700a2138: 9803         	ldr	r0, [sp, #0xc]
700a213a: 3018         	adds	r0, #0x18
700a213c: f00b fa70    	bl	0x700ad620 <uxListRemove> @ imm = #0xb4e0
;           (void)uxListRemove(&(pxTCB->xStateListItem));
700a2140: 9803         	ldr	r0, [sp, #0xc]
700a2142: 3004         	adds	r0, #0x4
700a2144: f00b fa6c    	bl	0x700ad620 <uxListRemove> @ imm = #0xb4d8
;           prvAddTaskToReadyList(pxTCB);
700a2148: 9803         	ldr	r0, [sp, #0xc]
700a214a: 6ac0         	ldr	r0, [r0, #0x2c]
700a214c: f642 212c    	movw	r1, #0x2a2c
700a2150: f2c7 010b    	movt	r1, #0x700b
700a2154: 6809         	ldr	r1, [r1]
700a2156: 4288         	cmp	r0, r1
700a2158: d908         	bls	0x700a216c <xTaskResumeAll+0x8c> @ imm = #0x10
700a215a: e7ff         	b	0x700a215c <xTaskResumeAll+0x7c> @ imm = #-0x2
700a215c: 9803         	ldr	r0, [sp, #0xc]
700a215e: 6ac0         	ldr	r0, [r0, #0x2c]
700a2160: f642 212c    	movw	r1, #0x2a2c
700a2164: f2c7 010b    	movt	r1, #0x700b
700a2168: 6008         	str	r0, [r1]
700a216a: e7ff         	b	0x700a216c <xTaskResumeAll+0x8c> @ imm = #-0x2
700a216c: 9903         	ldr	r1, [sp, #0xc]
700a216e: 6ac8         	ldr	r0, [r1, #0x2c]
700a2170: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a2174: f244 40f8    	movw	r0, #0x44f8
700a2178: f2c7 0008    	movt	r0, #0x7008
700a217c: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a2180: 3104         	adds	r1, #0x4
700a2182: f00c f805    	bl	0x700ae190 <vListInsertEnd> @ imm = #0xc00a
;           if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a2186: 9803         	ldr	r0, [sp, #0xc]
700a2188: 6ac0         	ldr	r0, [r0, #0x2c]
700a218a: f642 2100    	movw	r1, #0x2a00
700a218e: f2c7 010b    	movt	r1, #0x700b
700a2192: 6809         	ldr	r1, [r1]
700a2194: 6ac9         	ldr	r1, [r1, #0x2c]
700a2196: 4288         	cmp	r0, r1
700a2198: d307         	blo	0x700a21aa <xTaskResumeAll+0xca> @ imm = #0xe
700a219a: e7ff         	b	0x700a219c <xTaskResumeAll+0xbc> @ imm = #-0x2
;             xYieldPending = pdTRUE;
700a219c: f642 2150    	movw	r1, #0x2a50
700a21a0: f2c7 010b    	movt	r1, #0x700b
700a21a4: 2001         	movs	r0, #0x1
700a21a6: 6008         	str	r0, [r1]
;           } else {
700a21a8: e000         	b	0x700a21ac <xTaskResumeAll+0xcc> @ imm = #0x0
700a21aa: e7ff         	b	0x700a21ac <xTaskResumeAll+0xcc> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a21ac: e7b5         	b	0x700a211a <xTaskResumeAll+0x3a> @ imm = #-0x96
;         if (pxTCB != NULL) {
700a21ae: 9803         	ldr	r0, [sp, #0xc]
700a21b0: b118         	cbz	r0, 0x700a21ba <xTaskResumeAll+0xda> @ imm = #0x6
700a21b2: e7ff         	b	0x700a21b4 <xTaskResumeAll+0xd4> @ imm = #-0x2
;           prvResetNextTaskUnblockTime();
700a21b4: f00b ff6c    	bl	0x700ae090 <prvResetNextTaskUnblockTime> @ imm = #0xbed8
;         }
700a21b8: e7ff         	b	0x700a21ba <xTaskResumeAll+0xda> @ imm = #-0x2
;           TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
700a21ba: f642 203c    	movw	r0, #0x2a3c
700a21be: f2c7 000b    	movt	r0, #0x700b
700a21c2: 6800         	ldr	r0, [r0]
700a21c4: 9001         	str	r0, [sp, #0x4]
;           if (xPendedCounts > (TickType_t)0U) {
700a21c6: 9801         	ldr	r0, [sp, #0x4]
700a21c8: b1e0         	cbz	r0, 0x700a2204 <xTaskResumeAll+0x124> @ imm = #0x38
700a21ca: e7ff         	b	0x700a21cc <xTaskResumeAll+0xec> @ imm = #-0x2
;             do {
700a21cc: e7ff         	b	0x700a21ce <xTaskResumeAll+0xee> @ imm = #-0x2
;               if (xTaskIncrementTick() != pdFALSE) {
700a21ce: f7ff f887    	bl	0x700a12e0 <xTaskIncrementTick> @ imm = #-0xef2
700a21d2: b138         	cbz	r0, 0x700a21e4 <xTaskResumeAll+0x104> @ imm = #0xe
700a21d4: e7ff         	b	0x700a21d6 <xTaskResumeAll+0xf6> @ imm = #-0x2
;                 xYieldPending = pdTRUE;
700a21d6: f642 2150    	movw	r1, #0x2a50
700a21da: f2c7 010b    	movt	r1, #0x700b
700a21de: 2001         	movs	r0, #0x1
700a21e0: 6008         	str	r0, [r1]
;               } else {
700a21e2: e000         	b	0x700a21e6 <xTaskResumeAll+0x106> @ imm = #0x0
700a21e4: e7ff         	b	0x700a21e6 <xTaskResumeAll+0x106> @ imm = #-0x2
;               --xPendedCounts;
700a21e6: 9801         	ldr	r0, [sp, #0x4]
700a21e8: 3801         	subs	r0, #0x1
700a21ea: 9001         	str	r0, [sp, #0x4]
;             } while (xPendedCounts > (TickType_t)0U);
700a21ec: e7ff         	b	0x700a21ee <xTaskResumeAll+0x10e> @ imm = #-0x2
700a21ee: 9801         	ldr	r0, [sp, #0x4]
700a21f0: 2800         	cmp	r0, #0x0
700a21f2: d1ec         	bne	0x700a21ce <xTaskResumeAll+0xee> @ imm = #-0x28
700a21f4: e7ff         	b	0x700a21f6 <xTaskResumeAll+0x116> @ imm = #-0x2
;             xPendedTicks = 0;
700a21f6: f642 213c    	movw	r1, #0x2a3c
700a21fa: f2c7 010b    	movt	r1, #0x700b
700a21fe: 2000         	movs	r0, #0x0
700a2200: 6008         	str	r0, [r1]
;           } else {
700a2202: e000         	b	0x700a2206 <xTaskResumeAll+0x126> @ imm = #0x0
700a2204: e7ff         	b	0x700a2206 <xTaskResumeAll+0x126> @ imm = #-0x2
;         if (xYieldPending != pdFALSE) {
700a2206: f642 2050    	movw	r0, #0x2a50
700a220a: f2c7 000b    	movt	r0, #0x700b
700a220e: 6800         	ldr	r0, [r0]
700a2210: b120         	cbz	r0, 0x700a221c <xTaskResumeAll+0x13c> @ imm = #0x8
700a2212: e7ff         	b	0x700a2214 <xTaskResumeAll+0x134> @ imm = #-0x2
700a2214: 2001         	movs	r0, #0x1
;             xAlreadyYielded = pdTRUE;
700a2216: 9002         	str	r0, [sp, #0x8]
;           taskYIELD_IF_USING_PREEMPTION();
700a2218: df00         	svc	#0x0
;         } else {
700a221a: e000         	b	0x700a221e <xTaskResumeAll+0x13e> @ imm = #0x0
700a221c: e7ff         	b	0x700a221e <xTaskResumeAll+0x13e> @ imm = #-0x2
;       }
700a221e: e7ff         	b	0x700a2220 <xTaskResumeAll+0x140> @ imm = #-0x2
;     } else {
700a2220: e000         	b	0x700a2224 <xTaskResumeAll+0x144> @ imm = #0x0
700a2222: e7ff         	b	0x700a2224 <xTaskResumeAll+0x144> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a2224: f00b faec    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xb5d8
;   return xAlreadyYielded;
700a2228: 9802         	ldr	r0, [sp, #0x8]
700a222a: b004         	add	sp, #0x10
700a222c: bd80         	pop	{r7, pc}
700a222e: 0000         	movs	r0, r0

700a2230 <Udma_chAssignRegOverlay>:
; {
700a2230: b082         	sub	sp, #0x8
700a2232: 9001         	str	r0, [sp, #0x4]
700a2234: 9100         	str	r1, [sp]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a2236: 9801         	ldr	r0, [sp, #0x4]
700a2238: 6800         	ldr	r0, [r0]
700a223a: 2801         	cmp	r0, #0x1
700a223c: d147         	bne	0x700a22ce <Udma_chAssignRegOverlay+0x9e> @ imm = #0x8e
700a223e: e7ff         	b	0x700a2240 <Udma_chAssignRegOverlay+0x10> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a2240: 9800         	ldr	r0, [sp]
700a2242: 6ec0         	ldr	r0, [r0, #0x6c]
700a2244: f510 3f80    	cmn.w	r0, #0x10000
700a2248: d029         	beq	0x700a229e <Udma_chAssignRegOverlay+0x6e> @ imm = #0x52
700a224a: e7ff         	b	0x700a224c <Udma_chAssignRegOverlay+0x1c> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a224c: 9800         	ldr	r0, [sp]
700a224e: 7800         	ldrb	r0, [r0]
700a2250: 0740         	lsls	r0, r0, #0x1d
700a2252: 2800         	cmp	r0, #0x0
700a2254: d511         	bpl	0x700a227a <Udma_chAssignRegOverlay+0x4a> @ imm = #0x22
700a2256: e7ff         	b	0x700a2258 <Udma_chAssignRegOverlay+0x28> @ imm = #-0x2
;                     &drvHandle->bcdmaRegs.pBcChanCfgRegs->CHAN[chHandle->txChNum];
700a2258: 9801         	ldr	r0, [sp, #0x4]
700a225a: 68c0         	ldr	r0, [r0, #0xc]
700a225c: 9900         	ldr	r1, [sp]
700a225e: 6eca         	ldr	r2, [r1, #0x6c]
700a2260: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaBcCfgRegs =
700a2264: f8c1 0214    	str.w	r0, [r1, #0x214]
;                     &drvHandle->bcdmaRegs.pBcChanRtRegs->CHAN[chHandle->txChNum];
700a2268: 9801         	ldr	r0, [sp, #0x4]
700a226a: 6900         	ldr	r0, [r0, #0x10]
700a226c: 9900         	ldr	r1, [sp]
700a226e: 6eca         	ldr	r2, [r1, #0x6c]
700a2270: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaBcRtRegs  =
700a2274: f8c1 0218    	str.w	r0, [r1, #0x218]
;             }
700a2278: e010         	b	0x700a229c <Udma_chAssignRegOverlay+0x6c> @ imm = #0x20
;                     &drvHandle->bcdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a227a: 9801         	ldr	r0, [sp, #0x4]
700a227c: 6940         	ldr	r0, [r0, #0x14]
700a227e: 9900         	ldr	r1, [sp]
700a2280: 6eca         	ldr	r2, [r1, #0x6c]
700a2282: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaTxCfgRegs =
700a2286: f8c1 021c    	str.w	r0, [r1, #0x21c]
;                     &drvHandle->bcdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a228a: 9801         	ldr	r0, [sp, #0x4]
700a228c: 6980         	ldr	r0, [r0, #0x18]
700a228e: 9900         	ldr	r1, [sp]
700a2290: 6eca         	ldr	r2, [r1, #0x6c]
700a2292: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaTxRtRegs  =
700a2296: f8c1 0220    	str.w	r0, [r1, #0x220]
700a229a: e7ff         	b	0x700a229c <Udma_chAssignRegOverlay+0x6c> @ imm = #-0x2
;         }
700a229c: e7ff         	b	0x700a229e <Udma_chAssignRegOverlay+0x6e> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a229e: 9800         	ldr	r0, [sp]
700a22a0: 6f00         	ldr	r0, [r0, #0x70]
700a22a2: f510 3f80    	cmn.w	r0, #0x10000
700a22a6: d011         	beq	0x700a22cc <Udma_chAssignRegOverlay+0x9c> @ imm = #0x22
700a22a8: e7ff         	b	0x700a22aa <Udma_chAssignRegOverlay+0x7a> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a22aa: 9801         	ldr	r0, [sp, #0x4]
700a22ac: 69c0         	ldr	r0, [r0, #0x1c]
700a22ae: 9900         	ldr	r1, [sp]
700a22b0: 6f0a         	ldr	r2, [r1, #0x70]
700a22b2: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pBcdmaRxCfgRegs =
700a22b6: f8c1 0224    	str.w	r0, [r1, #0x224]
;                 &drvHandle->bcdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a22ba: 9801         	ldr	r0, [sp, #0x4]
700a22bc: 6a00         	ldr	r0, [r0, #0x20]
700a22be: 9900         	ldr	r1, [sp]
700a22c0: 6f0a         	ldr	r2, [r1, #0x70]
700a22c2: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pBcdmaRxRtRegs  =
700a22c6: f8c1 0228    	str.w	r0, [r1, #0x228]
;         }
700a22ca: e7ff         	b	0x700a22cc <Udma_chAssignRegOverlay+0x9c> @ imm = #-0x2
;     }
700a22cc: e051         	b	0x700a2372 <Udma_chAssignRegOverlay+0x142> @ imm = #0xa2
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a22ce: 9801         	ldr	r0, [sp, #0x4]
700a22d0: 6800         	ldr	r0, [r0]
700a22d2: 2802         	cmp	r0, #0x2
700a22d4: d14c         	bne	0x700a2370 <Udma_chAssignRegOverlay+0x140> @ imm = #0x98
700a22d6: e7ff         	b	0x700a22d8 <Udma_chAssignRegOverlay+0xa8> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a22d8: 9800         	ldr	r0, [sp]
700a22da: 6ec0         	ldr	r0, [r0, #0x6c]
700a22dc: f510 3f80    	cmn.w	r0, #0x10000
700a22e0: d011         	beq	0x700a2306 <Udma_chAssignRegOverlay+0xd6> @ imm = #0x22
700a22e2: e7ff         	b	0x700a22e4 <Udma_chAssignRegOverlay+0xb4> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a22e4: 9801         	ldr	r0, [sp, #0x4]
700a22e6: 6dc0         	ldr	r0, [r0, #0x5c]
700a22e8: 9900         	ldr	r1, [sp]
700a22ea: 6eca         	ldr	r2, [r1, #0x6c]
700a22ec: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaTxCfgRegs =
700a22f0: f8c1 022c    	str.w	r0, [r1, #0x22c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a22f4: 9801         	ldr	r0, [sp, #0x4]
700a22f6: 6e40         	ldr	r0, [r0, #0x64]
700a22f8: 9900         	ldr	r1, [sp]
700a22fa: 6eca         	ldr	r2, [r1, #0x6c]
700a22fc: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaTxRtRegs  =
700a2300: f8c1 0230    	str.w	r0, [r1, #0x230]
;         }
700a2304: e7ff         	b	0x700a2306 <Udma_chAssignRegOverlay+0xd6> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a2306: 9800         	ldr	r0, [sp]
700a2308: 6f00         	ldr	r0, [r0, #0x70]
700a230a: f510 3f80    	cmn.w	r0, #0x10000
700a230e: d011         	beq	0x700a2334 <Udma_chAssignRegOverlay+0x104> @ imm = #0x22
700a2310: e7ff         	b	0x700a2312 <Udma_chAssignRegOverlay+0xe2> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a2312: 9801         	ldr	r0, [sp, #0x4]
700a2314: 6e00         	ldr	r0, [r0, #0x60]
700a2316: 9900         	ldr	r1, [sp]
700a2318: 6f0a         	ldr	r2, [r1, #0x70]
700a231a: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaRxCfgRegs =
700a231e: f8c1 0234    	str.w	r0, [r1, #0x234]
;                 &drvHandle->pktdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a2322: 9801         	ldr	r0, [sp, #0x4]
700a2324: 6e80         	ldr	r0, [r0, #0x68]
700a2326: 9900         	ldr	r1, [sp]
700a2328: 6f0a         	ldr	r2, [r1, #0x70]
700a232a: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaRxRtRegs  =
700a232e: f8c1 0238    	str.w	r0, [r1, #0x238]
;         }
700a2332: e7ff         	b	0x700a2334 <Udma_chAssignRegOverlay+0x104> @ imm = #-0x2
;         if(chHandle->extChNum != UDMA_DMA_CH_INVALID)
700a2334: 9800         	ldr	r0, [sp]
700a2336: 6f40         	ldr	r0, [r0, #0x74]
700a2338: f510 3f80    	cmn.w	r0, #0x10000
700a233c: d017         	beq	0x700a236e <Udma_chAssignRegOverlay+0x13e> @ imm = #0x2e
700a233e: e7ff         	b	0x700a2340 <Udma_chAssignRegOverlay+0x110> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a2340: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a2342: 9900         	ldr	r1, [sp]
700a2344: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a2346: 6dd8         	ldr	r0, [r3, #0x5c]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a2348: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a234c: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a234e: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaExtCfgRegs =
700a2352: f8c1 023c    	str.w	r0, [r1, #0x23c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a2356: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a2358: 9900         	ldr	r1, [sp]
700a235a: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a235c: 6e58         	ldr	r0, [r3, #0x64]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a235e: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a2362: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a2364: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaExtRtRegs  =
700a2368: f8c1 0240    	str.w	r0, [r1, #0x240]
;         }
700a236c: e7ff         	b	0x700a236e <Udma_chAssignRegOverlay+0x13e> @ imm = #-0x2
;     }
700a236e: e7ff         	b	0x700a2370 <Udma_chAssignRegOverlay+0x140> @ imm = #-0x2
700a2370: e7ff         	b	0x700a2372 <Udma_chAssignRegOverlay+0x142> @ imm = #-0x2
; }
700a2372: b002         	add	sp, #0x8
700a2374: 4770         	bx	lr
		...
700a237e: 0000         	movs	r0, r0

700a2380 <DebugP_memLogWriterPutChar>:
; {
700a2380: b580         	push	{r7, lr}
700a2382: b088         	sub	sp, #0x20
700a2384: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     if(lineBufIndex==0U)
700a2388: f642 00bc    	movw	r0, #0x28bc
700a238c: f2c7 000b    	movt	r0, #0x700b
700a2390: 6800         	ldr	r0, [r0]
700a2392: bb40         	cbnz	r0, 0x700a23e6 <DebugP_memLogWriterPutChar+0x66> @ imm = #0x50
700a2394: e7ff         	b	0x700a2396 <DebugP_memLogWriterPutChar+0x16> @ imm = #-0x2
;         uint64_t curTime = ClockP_getTimeUsec();
700a2396: f008 fb1b    	bl	0x700aa9d0 <ClockP_getTimeUsec> @ imm = #0x8636
700a239a: 9105         	str	r1, [sp, #0x14]
700a239c: 9004         	str	r0, [sp, #0x10]
;                             gDebugP_memTraceLogWriterSelfCoreName,
700a239e: f642 10e0    	movw	r0, #0x29e0
700a23a2: f2c7 000b    	movt	r0, #0x700b
700a23a6: 6800         	ldr	r0, [r0]
;                             (uint32_t)(curTime/TIME_IN_MICRO_SECONDS),
700a23a8: 9003         	str	r0, [sp, #0xc]
700a23aa: 9804         	ldr	r0, [sp, #0x10]
700a23ac: 9905         	ldr	r1, [sp, #0x14]
700a23ae: f244 2240    	movw	r2, #0x4240
700a23b2: f2c0 020f    	movt	r2, #0xf
700a23b6: 2300         	movs	r3, #0x0
;                             (uint32_t)(curTime%TIME_IN_MICRO_SECONDS)
700a23b8: f00c eecc    	blx	0x700af154 <__aeabi_uldivmod> @ imm = #0xcd98
700a23bc: 9b03         	ldr	r3, [sp, #0xc]
;         lineBufIndex = (uint32_t)snprintf_((char*)lineBuf, DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE, "[%6s] %5d.%06ds : ",
700a23be: 4669         	mov	r1, sp
700a23c0: 604a         	str	r2, [r1, #0x4]
700a23c2: 6008         	str	r0, [r1]
700a23c4: f644 7040    	movw	r0, #0x4f40
700a23c8: f2c7 0008    	movt	r0, #0x7008
700a23cc: f641 72c8    	movw	r2, #0x1fc8
700a23d0: f2c7 020b    	movt	r2, #0x700b
700a23d4: 2178         	movs	r1, #0x78
700a23d6: f00b febb    	bl	0x700ae150 <snprintf_>  @ imm = #0xbd76
700a23da: f642 01bc    	movw	r1, #0x28bc
700a23de: f2c7 010b    	movt	r1, #0x700b
700a23e2: 6008         	str	r0, [r1]
;     }
700a23e4: e7ff         	b	0x700a23e6 <DebugP_memLogWriterPutChar+0x66> @ imm = #-0x2
;     lineBuf[lineBufIndex]=(uint8_t)character;
700a23e6: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a23ea: f642 01bc    	movw	r1, #0x28bc
700a23ee: f2c7 010b    	movt	r1, #0x700b
700a23f2: 680b         	ldr	r3, [r1]
700a23f4: f644 7240    	movw	r2, #0x4f40
700a23f8: f2c7 0208    	movt	r2, #0x7008
700a23fc: 54d0         	strb	r0, [r2, r3]
; 	lineBufIndex = lineBufIndex + 1U;
700a23fe: 6808         	ldr	r0, [r1]
700a2400: 3001         	adds	r0, #0x1
700a2402: 6008         	str	r0, [r1]
;     if( (character == '\n') ||
700a2404: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a2408: 280a         	cmp	r0, #0xa
700a240a: d008         	beq	0x700a241e <DebugP_memLogWriterPutChar+0x9e> @ imm = #0x10
700a240c: e7ff         	b	0x700a240e <DebugP_memLogWriterPutChar+0x8e> @ imm = #-0x2
;         (lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE)))
700a240e: f642 00bc    	movw	r0, #0x28bc
700a2412: f2c7 000b    	movt	r0, #0x700b
700a2416: 6800         	ldr	r0, [r0]
;     if( (character == '\n') ||
700a2418: 2878         	cmp	r0, #0x78
700a241a: d350         	blo	0x700a24be <DebugP_memLogWriterPutChar+0x13e> @ imm = #0xa0
700a241c: e7ff         	b	0x700a241e <DebugP_memLogWriterPutChar+0x9e> @ imm = #-0x2
;         if(lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE))
700a241e: f642 00bc    	movw	r0, #0x28bc
700a2422: f2c7 000b    	movt	r0, #0x700b
700a2426: 6800         	ldr	r0, [r0]
700a2428: 2878         	cmp	r0, #0x78
700a242a: d315         	blo	0x700a2458 <DebugP_memLogWriterPutChar+0xd8> @ imm = #0x2a
700a242c: e7ff         	b	0x700a242e <DebugP_memLogWriterPutChar+0xae> @ imm = #-0x2
;             lineBuf[lineBufIndex]=(uint8_t)'\r';
700a242e: f642 01bc    	movw	r1, #0x28bc
700a2432: f2c7 010b    	movt	r1, #0x700b
700a2436: 680b         	ldr	r3, [r1]
700a2438: f644 7240    	movw	r2, #0x4f40
700a243c: f2c7 0208    	movt	r2, #0x7008
700a2440: 200d         	movs	r0, #0xd
700a2442: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a2444: 6808         	ldr	r0, [r1]
700a2446: 3001         	adds	r0, #0x1
700a2448: 6008         	str	r0, [r1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a244a: 680b         	ldr	r3, [r1]
700a244c: 200a         	movs	r0, #0xa
700a244e: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a2450: 6808         	ldr	r0, [r1]
700a2452: 3001         	adds	r0, #0x1
700a2454: 6008         	str	r0, [r1]
;         }
700a2456: e7ff         	b	0x700a2458 <DebugP_memLogWriterPutChar+0xd8> @ imm = #-0x2
;         if(lineBuf[lineBufIndex-UNSIGNED_INTEGERVAL_TWO]!=(uint8_t)'\r')
700a2458: f642 00bc    	movw	r0, #0x28bc
700a245c: f2c7 000b    	movt	r0, #0x700b
700a2460: 6800         	ldr	r0, [r0]
700a2462: f644 7140    	movw	r1, #0x4f40
700a2466: f2c7 0108    	movt	r1, #0x7008
700a246a: 4408         	add	r0, r1
700a246c: f810 0c02    	ldrb	r0, [r0, #-2]
700a2470: 280d         	cmp	r0, #0xd
700a2472: d014         	beq	0x700a249e <DebugP_memLogWriterPutChar+0x11e> @ imm = #0x28
700a2474: e7ff         	b	0x700a2476 <DebugP_memLogWriterPutChar+0xf6> @ imm = #-0x2
;             lineBuf[lineBufIndex-1U]=(uint8_t)'\r';
700a2476: f642 01bc    	movw	r1, #0x28bc
700a247a: f2c7 010b    	movt	r1, #0x700b
700a247e: 6808         	ldr	r0, [r1]
700a2480: f644 7240    	movw	r2, #0x4f40
700a2484: f2c7 0208    	movt	r2, #0x7008
700a2488: 1883         	adds	r3, r0, r2
700a248a: 200d         	movs	r0, #0xd
700a248c: f803 0c01    	strb	r0, [r3, #-1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a2490: 680b         	ldr	r3, [r1]
700a2492: 200a         	movs	r0, #0xa
700a2494: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a2496: 6808         	ldr	r0, [r1]
700a2498: 3001         	adds	r0, #0x1
700a249a: 6008         	str	r0, [r1]
;         }
700a249c: e7ff         	b	0x700a249e <DebugP_memLogWriterPutChar+0x11e> @ imm = #-0x2
;         DebugP_memTraceLogWriterPutLine(lineBuf, (uint16_t)lineBufIndex);
700a249e: f642 00bc    	movw	r0, #0x28bc
700a24a2: f2c7 000b    	movt	r0, #0x700b
700a24a6: 9002         	str	r0, [sp, #0x8]
700a24a8: 8801         	ldrh	r1, [r0]
700a24aa: f644 7040    	movw	r0, #0x4f40
700a24ae: f2c7 0008    	movt	r0, #0x7008
700a24b2: f003 fbc5    	bl	0x700a5c40 <DebugP_memTraceLogWriterPutLine> @ imm = #0x378a
700a24b6: 9902         	ldr	r1, [sp, #0x8]
700a24b8: 2000         	movs	r0, #0x0
;         lineBufIndex = 0;
700a24ba: 6008         	str	r0, [r1]
;     }
700a24bc: e7ff         	b	0x700a24be <DebugP_memLogWriterPutChar+0x13e> @ imm = #-0x2
; }
700a24be: b008         	add	sp, #0x20
700a24c0: bd80         	pop	{r7, pc}
		...
700a24ce: 0000         	movs	r0, r0

700a24d0 <Sciclient_sendMessage>:
; {
700a24d0: b580         	push	{r7, lr}
700a24d2: b08a         	sub	sp, #0x28
700a24d4: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a24d8: 9009         	str	r0, [sp, #0x24]
700a24da: 9108         	str	r1, [sp, #0x20]
700a24dc: 9207         	str	r2, [sp, #0x1c]
700a24de: 9306         	str	r3, [sp, #0x18]
700a24e0: 2200         	movs	r2, #0x0
;     uint32_t        i   = 0U;
700a24e2: 9205         	str	r2, [sp, #0x14]
;     const uint8_t *msg = pSecHeader;
700a24e4: 9808         	ldr	r0, [sp, #0x20]
700a24e6: 9004         	str	r0, [sp, #0x10]
;     uint32_t numWords   = 0U;
700a24e8: 9203         	str	r2, [sp, #0xc]
;     uint32_t test = 0U;
700a24ea: 9202         	str	r2, [sp, #0x8]
;     uintptr_t threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U);
700a24ec: 9909         	ldr	r1, [sp, #0x24]
700a24ee: f642 00c0    	movw	r0, #0x28c0
700a24f2: f2c7 000b    	movt	r0, #0x700b
700a24f6: f00d f803    	bl	0x700af500 <CSL_secProxyGetDataAddr> @ imm = #0xd006
700a24fa: 9001         	str	r0, [sp, #0x4]
;     if(pSecHeader != NULL)
700a24fc: 9808         	ldr	r0, [sp, #0x20]
700a24fe: b1f8         	cbz	r0, 0x700a2540 <Sciclient_sendMessage+0x70> @ imm = #0x3e
700a2500: e7ff         	b	0x700a2502 <Sciclient_sendMessage+0x32> @ imm = #-0x2
700a2502: 2000         	movs	r0, #0x0
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a2504: 9005         	str	r0, [sp, #0x14]
700a2506: e7ff         	b	0x700a2508 <Sciclient_sendMessage+0x38> @ imm = #-0x2
700a2508: 9805         	ldr	r0, [sp, #0x14]
700a250a: f642 2154    	movw	r1, #0x2a54
700a250e: f2c7 010b    	movt	r1, #0x700b
700a2512: 7809         	ldrb	r1, [r1]
700a2514: 4288         	cmp	r0, r1
700a2516: d212         	bhs	0x700a253e <Sciclient_sendMessage+0x6e> @ imm = #0x24
700a2518: e7ff         	b	0x700a251a <Sciclient_sendMessage+0x4a> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a251a: 9804         	ldr	r0, [sp, #0x10]
700a251c: 6800         	ldr	r0, [r0]
700a251e: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a2520: 9801         	ldr	r0, [sp, #0x4]
700a2522: 9902         	ldr	r1, [sp, #0x8]
700a2524: f00d fac4    	bl	0x700afab0 <CSL_REG32_WR_RAW> @ imm = #0xd588
;             msg += 4;
700a2528: 9804         	ldr	r0, [sp, #0x10]
700a252a: 3004         	adds	r0, #0x4
700a252c: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a252e: 9801         	ldr	r0, [sp, #0x4]
700a2530: 3004         	adds	r0, #0x4
700a2532: 9001         	str	r0, [sp, #0x4]
;         }
700a2534: e7ff         	b	0x700a2536 <Sciclient_sendMessage+0x66> @ imm = #-0x2
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a2536: 9805         	ldr	r0, [sp, #0x14]
700a2538: 3001         	adds	r0, #0x1
700a253a: 9005         	str	r0, [sp, #0x14]
700a253c: e7e4         	b	0x700a2508 <Sciclient_sendMessage+0x38> @ imm = #-0x38
;     }
700a253e: e7ff         	b	0x700a2540 <Sciclient_sendMessage+0x70> @ imm = #-0x2
;     msg = pHeader;
700a2540: 9807         	ldr	r0, [sp, #0x1c]
700a2542: 9004         	str	r0, [sp, #0x10]
700a2544: 2000         	movs	r0, #0x0
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a2546: 9005         	str	r0, [sp, #0x14]
700a2548: e7ff         	b	0x700a254a <Sciclient_sendMessage+0x7a> @ imm = #-0x2
700a254a: 9805         	ldr	r0, [sp, #0x14]
700a254c: 2801         	cmp	r0, #0x1
700a254e: d812         	bhi	0x700a2576 <Sciclient_sendMessage+0xa6> @ imm = #0x24
700a2550: e7ff         	b	0x700a2552 <Sciclient_sendMessage+0x82> @ imm = #-0x2
;         (void) memcpy((void *)&test, (const void *)msg, 4);
700a2552: 9804         	ldr	r0, [sp, #0x10]
700a2554: 6800         	ldr	r0, [r0]
700a2556: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(threadAddr, test);
700a2558: 9801         	ldr	r0, [sp, #0x4]
700a255a: 9902         	ldr	r1, [sp, #0x8]
700a255c: f00d faa8    	bl	0x700afab0 <CSL_REG32_WR_RAW> @ imm = #0xd550
;         msg += 4;
700a2560: 9804         	ldr	r0, [sp, #0x10]
700a2562: 3004         	adds	r0, #0x4
700a2564: 9004         	str	r0, [sp, #0x10]
;         threadAddr+=sizeof(uint32_t);
700a2566: 9801         	ldr	r0, [sp, #0x4]
700a2568: 3004         	adds	r0, #0x4
700a256a: 9001         	str	r0, [sp, #0x4]
;     }
700a256c: e7ff         	b	0x700a256e <Sciclient_sendMessage+0x9e> @ imm = #-0x2
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a256e: 9805         	ldr	r0, [sp, #0x14]
700a2570: 3001         	adds	r0, #0x1
700a2572: 9005         	str	r0, [sp, #0x14]
700a2574: e7e9         	b	0x700a254a <Sciclient_sendMessage+0x7a> @ imm = #-0x2e
;     if (payloadSize > 0U)
700a2576: 980c         	ldr	r0, [sp, #0x30]
700a2578: b300         	cbz	r0, 0x700a25bc <Sciclient_sendMessage+0xec> @ imm = #0x40
700a257a: e7ff         	b	0x700a257c <Sciclient_sendMessage+0xac> @ imm = #-0x2
;         numWords   = (payloadSize+3U)/4U;
700a257c: 980c         	ldr	r0, [sp, #0x30]
700a257e: 3003         	adds	r0, #0x3
700a2580: 0880         	lsrs	r0, r0, #0x2
700a2582: 9003         	str	r0, [sp, #0xc]
;         msg = pPayload;
700a2584: 9806         	ldr	r0, [sp, #0x18]
700a2586: 9004         	str	r0, [sp, #0x10]
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a2588: e7ff         	b	0x700a258a <Sciclient_sendMessage+0xba> @ imm = #-0x2
700a258a: 9805         	ldr	r0, [sp, #0x14]
700a258c: 9903         	ldr	r1, [sp, #0xc]
700a258e: 3102         	adds	r1, #0x2
700a2590: 4288         	cmp	r0, r1
700a2592: d212         	bhs	0x700a25ba <Sciclient_sendMessage+0xea> @ imm = #0x24
700a2594: e7ff         	b	0x700a2596 <Sciclient_sendMessage+0xc6> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a2596: 9804         	ldr	r0, [sp, #0x10]
700a2598: 6800         	ldr	r0, [r0]
700a259a: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a259c: 9801         	ldr	r0, [sp, #0x4]
700a259e: 9902         	ldr	r1, [sp, #0x8]
700a25a0: f00d fa86    	bl	0x700afab0 <CSL_REG32_WR_RAW> @ imm = #0xd50c
;             msg += 4;
700a25a4: 9804         	ldr	r0, [sp, #0x10]
700a25a6: 3004         	adds	r0, #0x4
700a25a8: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a25aa: 9801         	ldr	r0, [sp, #0x4]
700a25ac: 3004         	adds	r0, #0x4
700a25ae: 9001         	str	r0, [sp, #0x4]
;         }
700a25b0: e7ff         	b	0x700a25b2 <Sciclient_sendMessage+0xe2> @ imm = #-0x2
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a25b2: 9805         	ldr	r0, [sp, #0x14]
700a25b4: 3001         	adds	r0, #0x1
700a25b6: 9005         	str	r0, [sp, #0x14]
700a25b8: e7e7         	b	0x700a258a <Sciclient_sendMessage+0xba> @ imm = #-0x32
;     }
700a25ba: e7ff         	b	0x700a25bc <Sciclient_sendMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a25bc: f642 2054    	movw	r0, #0x2a54
700a25c0: f2c7 000b    	movt	r0, #0x700b
700a25c4: 7801         	ldrb	r1, [r0]
700a25c6: 980c         	ldr	r0, [sp, #0x30]
700a25c8: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a25cc: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a25ce: f642 1148    	movw	r1, #0x2948
700a25d2: f2c7 010b    	movt	r1, #0x700b
700a25d6: 6949         	ldr	r1, [r1, #0x14]
700a25d8: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a25da: 4288         	cmp	r0, r1
700a25dc: d817         	bhi	0x700a260e <Sciclient_sendMessage+0x13e> @ imm = #0x2e
700a25de: e7ff         	b	0x700a25e0 <Sciclient_sendMessage+0x110> @ imm = #-0x2
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a25e0: 9909         	ldr	r1, [sp, #0x24]
700a25e2: f642 00c0    	movw	r0, #0x28c0
700a25e6: f2c7 000b    	movt	r0, #0x700b
700a25ea: 2200         	movs	r2, #0x0
700a25ec: 9200         	str	r2, [sp]
700a25ee: f00c ff87    	bl	0x700af500 <CSL_secProxyGetDataAddr> @ imm = #0xcf0e
700a25f2: 9900         	ldr	r1, [sp]
700a25f4: 4602         	mov	r2, r0
;         ((uintptr_t) gSciclientHandle.maxMsgSizeBytes  - (uintptr_t) 4U) ;
700a25f6: f642 1048    	movw	r0, #0x2948
700a25fa: f2c7 000b    	movt	r0, #0x700b
700a25fe: 6940         	ldr	r0, [r0, #0x14]
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a2600: 4410         	add	r0, r2
700a2602: 3804         	subs	r0, #0x4
700a2604: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(threadAddr,0U);
700a2606: 9801         	ldr	r0, [sp, #0x4]
700a2608: f00d fa52    	bl	0x700afab0 <CSL_REG32_WR_RAW> @ imm = #0xd4a4
;     }
700a260c: e7ff         	b	0x700a260e <Sciclient_sendMessage+0x13e> @ imm = #-0x2
; }
700a260e: b00a         	add	sp, #0x28
700a2610: bd80         	pop	{r7, pc}
		...
700a261e: 0000         	movs	r0, r0

700a2620 <Sciclient_rmIaValidateMapping>:
; {
700a2620: b580         	push	{r7, lr}
700a2622: b088         	sub	sp, #0x20
700a2624: 4684         	mov	r12, r0
700a2626: 980a         	ldr	r0, [sp, #0x28]
700a2628: f88d c01f    	strb.w	r12, [sp, #0x1f]
700a262c: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a2630: f8ad 201a    	strh.w	r2, [sp, #0x1a]
700a2634: f8ad 3018    	strh.w	r3, [sp, #0x18]
700a2638: f88d 0017    	strb.w	r0, [sp, #0x17]
700a263c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a263e: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700a2640: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700a2642: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a2646: f009 fedb    	bl	0x700ac400 <Sciclient_rmIaGetInst> @ imm = #0x9db6
700a264a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a264c: 9803         	ldr	r0, [sp, #0xc]
700a264e: b920         	cbnz	r0, 0x700a265a <Sciclient_rmIaValidateMapping+0x3a> @ imm = #0x8
700a2650: e7ff         	b	0x700a2652 <Sciclient_rmIaValidateMapping+0x32> @ imm = #-0x2
700a2652: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a2656: 9004         	str	r0, [sp, #0x10]
;     } else {
700a2658: e00b         	b	0x700a2672 <Sciclient_rmIaValidateMapping+0x52> @ imm = #0x16
;         if (vint >= inst->n_vint) {
700a265a: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a265e: 9903         	ldr	r1, [sp, #0xc]
700a2660: 8989         	ldrh	r1, [r1, #0xc]
700a2662: 4288         	cmp	r0, r1
700a2664: db04         	blt	0x700a2670 <Sciclient_rmIaValidateMapping+0x50> @ imm = #0x8
700a2666: e7ff         	b	0x700a2668 <Sciclient_rmIaValidateMapping+0x48> @ imm = #-0x2
700a2668: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a266c: 9004         	str	r0, [sp, #0x10]
;         }
700a266e: e7ff         	b	0x700a2670 <Sciclient_rmIaValidateMapping+0x50> @ imm = #-0x2
700a2670: e7ff         	b	0x700a2672 <Sciclient_rmIaValidateMapping+0x52> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (vint_sb_index >= SCICLIENT_IA_VINT_MAX_BITS)) {
700a2672: 9804         	ldr	r0, [sp, #0x10]
700a2674: b948         	cbnz	r0, 0x700a268a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x12
700a2676: e7ff         	b	0x700a2678 <Sciclient_rmIaValidateMapping+0x58> @ imm = #-0x2
700a2678: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a267c: 2840         	cmp	r0, #0x40
700a267e: d304         	blo	0x700a268a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x8
700a2680: e7ff         	b	0x700a2682 <Sciclient_rmIaValidateMapping+0x62> @ imm = #-0x2
700a2682: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a2686: 9004         	str	r0, [sp, #0x10]
;     }
700a2688: e7ff         	b	0x700a268a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a268a: 9804         	ldr	r0, [sp, #0x10]
700a268c: b998         	cbnz	r0, 0x700a26b6 <Sciclient_rmIaValidateMapping+0x96> @ imm = #0x26
700a268e: e7ff         	b	0x700a2690 <Sciclient_rmIaValidateMapping+0x70> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700a2690: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a2694: 9903         	ldr	r1, [sp, #0xc]
700a2696: 8909         	ldrh	r1, [r1, #0x8]
700a2698: 1a40         	subs	r0, r0, r1
700a269a: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         if (evt >= inst->n_sevt) {
700a269e: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a26a2: 9903         	ldr	r1, [sp, #0xc]
700a26a4: 8949         	ldrh	r1, [r1, #0xa]
700a26a6: 4288         	cmp	r0, r1
700a26a8: db04         	blt	0x700a26b4 <Sciclient_rmIaValidateMapping+0x94> @ imm = #0x8
700a26aa: e7ff         	b	0x700a26ac <Sciclient_rmIaValidateMapping+0x8c> @ imm = #-0x2
700a26ac: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a26b0: 9004         	str	r0, [sp, #0x10]
;         }
700a26b2: e7ff         	b	0x700a26b4 <Sciclient_rmIaValidateMapping+0x94> @ imm = #-0x2
;     }
700a26b4: e7ff         	b	0x700a26b6 <Sciclient_rmIaValidateMapping+0x96> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a26b6: 9804         	ldr	r0, [sp, #0x10]
700a26b8: 2800         	cmp	r0, #0x0
700a26ba: d14e         	bne	0x700a275a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #0x9c
700a26bc: e7ff         	b	0x700a26be <Sciclient_rmIaValidateMapping+0x9e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a26be: 9803         	ldr	r0, [sp, #0xc]
700a26c0: 6840         	ldr	r0, [r0, #0x4]
700a26c2: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a26c6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a26ca: 9001         	str	r0, [sp, #0x4]
;         reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a26cc: 9801         	ldr	r0, [sp, #0x4]
700a26ce: f64f 7100    	movw	r1, #0xff00
700a26d2: f2c0 0101    	movt	r1, #0x1
700a26d6: 2208         	movs	r2, #0x8
700a26d8: f00c fcfa    	bl	0x700af0d0 <CSL_REG32_FEXT_RAW> @ imm = #0xc9f4
700a26dc: f8ad 0002    	strh.w	r0, [sp, #0x2]
;         reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a26e0: 9801         	ldr	r0, [sp, #0x4]
700a26e2: 213f         	movs	r1, #0x3f
700a26e4: 2200         	movs	r2, #0x0
700a26e6: f00c fcf3    	bl	0x700af0d0 <CSL_REG32_FEXT_RAW> @ imm = #0xc9e6
700a26ea: f8ad 0000    	strh.w	r0, [sp]
;         if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a26ee: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a26f2: b9f0         	cbnz	r0, 0x700a2732 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x3c
700a26f4: e7ff         	b	0x700a26f6 <Sciclient_rmIaValidateMapping+0xd6> @ imm = #-0x2
700a26f6: f8bd 0000    	ldrh.w	r0, [sp]
700a26fa: b9d0         	cbnz	r0, 0x700a2732 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x34
700a26fc: e7ff         	b	0x700a26fe <Sciclient_rmIaValidateMapping+0xde> @ imm = #-0x2
;             if ((vint != reg_vint) &&
700a26fe: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a2702: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a2706: 4288         	cmp	r0, r1
700a2708: d012         	beq	0x700a2730 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x24
700a270a: e7ff         	b	0x700a270c <Sciclient_rmIaValidateMapping+0xec> @ imm = #-0x2
;                 (vint_sb_index != reg_sb) &&
700a270c: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a2710: f8bd 1000    	ldrh.w	r1, [sp]
700a2714: 4288         	cmp	r0, r1
700a2716: d00b         	beq	0x700a2730 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x16
700a2718: e7ff         	b	0x700a271a <Sciclient_rmIaValidateMapping+0xfa> @ imm = #-0x2
;                 (evt != inst->v0_b0_evt)) {
700a271a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a271e: 9903         	ldr	r1, [sp, #0xc]
700a2720: 8a89         	ldrh	r1, [r1, #0x14]
;             if ((vint != reg_vint) &&
700a2722: 4288         	cmp	r0, r1
700a2724: d004         	beq	0x700a2730 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x8
700a2726: e7ff         	b	0x700a2728 <Sciclient_rmIaValidateMapping+0x108> @ imm = #-0x2
700a2728: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a272c: 9004         	str	r0, [sp, #0x10]
;             }
700a272e: e7ff         	b	0x700a2730 <Sciclient_rmIaValidateMapping+0x110> @ imm = #-0x2
;         } else {
700a2730: e012         	b	0x700a2758 <Sciclient_rmIaValidateMapping+0x138> @ imm = #0x24
;             if ((vint != reg_vint) &&
700a2732: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a2736: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a273a: 4288         	cmp	r0, r1
700a273c: d00b         	beq	0x700a2756 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x16
700a273e: e7ff         	b	0x700a2740 <Sciclient_rmIaValidateMapping+0x120> @ imm = #-0x2
;                 (vint_sb_index != reg_sb)) {
700a2740: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a2744: f8bd 1000    	ldrh.w	r1, [sp]
;             if ((vint != reg_vint) &&
700a2748: 4288         	cmp	r0, r1
700a274a: d004         	beq	0x700a2756 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x8
700a274c: e7ff         	b	0x700a274e <Sciclient_rmIaValidateMapping+0x12e> @ imm = #-0x2
700a274e: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a2752: 9004         	str	r0, [sp, #0x10]
;             }
700a2754: e7ff         	b	0x700a2756 <Sciclient_rmIaValidateMapping+0x136> @ imm = #-0x2
700a2756: e7ff         	b	0x700a2758 <Sciclient_rmIaValidateMapping+0x138> @ imm = #-0x2
;     }
700a2758: e7ff         	b	0x700a275a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #-0x2
;     return r;
700a275a: 9804         	ldr	r0, [sp, #0x10]
700a275c: b008         	add	sp, #0x20
700a275e: bd80         	pop	{r7, pc}

700a2760 <Udma_rmAllocMappedRing>:
; {
700a2760: b580         	push	{r7, lr}
700a2762: b090         	sub	sp, #0x40
700a2764: 900f         	str	r0, [sp, #0x3c]
700a2766: 910e         	str	r1, [sp, #0x38]
700a2768: 920d         	str	r2, [sp, #0x34]
700a276a: f64f 70ff    	movw	r0, #0xffff
;     uint32_t    ringNum = UDMA_RING_INVALID;
700a276e: 900c         	str	r0, [sp, #0x30]
700a2770: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a2772: 9005         	str	r0, [sp, #0x14]
;     Udma_RmInitPrms             *rmInitPrms = &drvHandle->rmInitPrms;
700a2774: 980f         	ldr	r0, [sp, #0x3c]
700a2776: f500 70ea    	add.w	r0, r0, #0x1d4
700a277a: 9004         	str	r0, [sp, #0x10]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a277c: 980f         	ldr	r0, [sp, #0x3c]
700a277e: 990e         	ldr	r1, [sp, #0x38]
700a2780: 9a0d         	ldr	r2, [sp, #0x34]
700a2782: ab01         	add	r3, sp, #0x4
700a2784: f005 fa54    	bl	0x700a7c30 <Udma_getMappedChRingAttributes> @ imm = #0x54a8
700a2788: 9005         	str	r0, [sp, #0x14]
;     if(UDMA_SOK == retVal)
700a278a: 9805         	ldr	r0, [sp, #0x14]
700a278c: 2800         	cmp	r0, #0x0
700a278e: f040 8084    	bne.w	0x700a289a <Udma_rmAllocMappedRing+0x13a> @ imm = #0x108
700a2792: e7ff         	b	0x700a2794 <Udma_rmAllocMappedRing+0x34> @ imm = #-0x2
700a2794: 2000         	movs	r0, #0x0
;         loopStart = 0;
700a2796: 9007         	str	r0, [sp, #0x1c]
;         loopMax   = rmInitPrms->numMappedRing[mappedRingGrp];
700a2798: 9804         	ldr	r0, [sp, #0x10]
700a279a: 990e         	ldr	r1, [sp, #0x38]
700a279c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a27a0: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
700a27a4: 9006         	str	r0, [sp, #0x18]
;         if(chAttr.startFreeRing > rmInitPrms->startMappedRing[mappedRingGrp])
700a27a6: 9802         	ldr	r0, [sp, #0x8]
700a27a8: 9904         	ldr	r1, [sp, #0x10]
700a27aa: 9a0e         	ldr	r2, [sp, #0x38]
700a27ac: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a27b0: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a27b4: 4288         	cmp	r0, r1
700a27b6: d90a         	bls	0x700a27ce <Udma_rmAllocMappedRing+0x6e> @ imm = #0x14
700a27b8: e7ff         	b	0x700a27ba <Udma_rmAllocMappedRing+0x5a> @ imm = #-0x2
;             loopStart = chAttr.startFreeRing - rmInitPrms->startMappedRing[mappedRingGrp];
700a27ba: 9802         	ldr	r0, [sp, #0x8]
700a27bc: 9904         	ldr	r1, [sp, #0x10]
700a27be: 9a0e         	ldr	r2, [sp, #0x38]
700a27c0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a27c4: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a27c8: 1a40         	subs	r0, r0, r1
700a27ca: 9007         	str	r0, [sp, #0x1c]
;         }
700a27cc: e7ff         	b	0x700a27ce <Udma_rmAllocMappedRing+0x6e> @ imm = #-0x2
;         if((chAttr.startFreeRing + chAttr.numFreeRing) < (rmInitPrms->startMappedRing[mappedRingGrp] + rmInitPrms->numMappedRing[mappedRingGrp]))
700a27ce: 9802         	ldr	r0, [sp, #0x8]
700a27d0: 9903         	ldr	r1, [sp, #0xc]
700a27d2: 4408         	add	r0, r1
700a27d4: 9904         	ldr	r1, [sp, #0x10]
700a27d6: 9a0e         	ldr	r2, [sp, #0x38]
700a27d8: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a27dc: f8d2 1088    	ldr.w	r1, [r2, #0x88]
700a27e0: f8d2 20a8    	ldr.w	r2, [r2, #0xa8]
700a27e4: 4411         	add	r1, r2
700a27e6: 4288         	cmp	r0, r1
700a27e8: d20c         	bhs	0x700a2804 <Udma_rmAllocMappedRing+0xa4> @ imm = #0x18
700a27ea: e7ff         	b	0x700a27ec <Udma_rmAllocMappedRing+0x8c> @ imm = #-0x2
;             loopMax = (chAttr.startFreeRing + chAttr.numFreeRing) - rmInitPrms->startMappedRing[mappedRingGrp];
700a27ec: 9802         	ldr	r0, [sp, #0x8]
700a27ee: 9903         	ldr	r1, [sp, #0xc]
700a27f0: 4408         	add	r0, r1
700a27f2: 9904         	ldr	r1, [sp, #0x10]
700a27f4: 9a0e         	ldr	r2, [sp, #0x38]
700a27f6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a27fa: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a27fe: 1a40         	subs	r0, r0, r1
700a2800: 9006         	str	r0, [sp, #0x18]
;         }
700a2802: e7ff         	b	0x700a2804 <Udma_rmAllocMappedRing+0xa4> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2804: 980f         	ldr	r0, [sp, #0x3c]
700a2806: f500 609f    	add.w	r0, r0, #0x4f8
700a280a: f04f 31ff    	mov.w	r1, #0xffffffff
700a280e: f007 ff07    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x7e0e
;         for(i = loopStart; i < loopMax; i++)
700a2812: 9807         	ldr	r0, [sp, #0x1c]
700a2814: 900b         	str	r0, [sp, #0x2c]
700a2816: e7ff         	b	0x700a2818 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x2
700a2818: 980b         	ldr	r0, [sp, #0x2c]
700a281a: 9906         	ldr	r1, [sp, #0x18]
700a281c: 4288         	cmp	r0, r1
700a281e: d236         	bhs	0x700a288e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x6c
700a2820: e7ff         	b	0x700a2822 <Udma_rmAllocMappedRing+0xc2> @ imm = #-0x2
;             offset = i >> 5U;
700a2822: 980b         	ldr	r0, [sp, #0x2c]
700a2824: 0940         	lsrs	r0, r0, #0x5
700a2826: 900a         	str	r0, [sp, #0x28]
;             bitPos = i - (offset << 5U);
700a2828: 980b         	ldr	r0, [sp, #0x2c]
700a282a: 990a         	ldr	r1, [sp, #0x28]
700a282c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2830: 9009         	str	r0, [sp, #0x24]
;             bitMask = (uint32_t) 1U << bitPos;
700a2832: 9909         	ldr	r1, [sp, #0x24]
700a2834: 2001         	movs	r0, #0x1
700a2836: 4088         	lsls	r0, r1
700a2838: 9008         	str	r0, [sp, #0x20]
;             if((drvHandle->mappedRingFlag[mappedRingGrp][offset] & bitMask) == bitMask)
700a283a: 980f         	ldr	r0, [sp, #0x3c]
700a283c: 990e         	ldr	r1, [sp, #0x38]
700a283e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a2842: 990a         	ldr	r1, [sp, #0x28]
700a2844: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2848: f8d0 0344    	ldr.w	r0, [r0, #0x344]
700a284c: 9908         	ldr	r1, [sp, #0x20]
700a284e: 4008         	ands	r0, r1
700a2850: 4288         	cmp	r0, r1
700a2852: d117         	bne	0x700a2884 <Udma_rmAllocMappedRing+0x124> @ imm = #0x2e
700a2854: e7ff         	b	0x700a2856 <Udma_rmAllocMappedRing+0xf6> @ imm = #-0x2
;                 drvHandle->mappedRingFlag[mappedRingGrp][offset] &= ~bitMask;
700a2856: 9a08         	ldr	r2, [sp, #0x20]
700a2858: 980f         	ldr	r0, [sp, #0x3c]
700a285a: 990e         	ldr	r1, [sp, #0x38]
700a285c: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a2860: 990a         	ldr	r1, [sp, #0x28]
700a2862: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a2866: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a286a: 4390         	bics	r0, r2
700a286c: f8c1 0344    	str.w	r0, [r1, #0x344]
;                 ringNum = i + rmInitPrms->startMappedRing[mappedRingGrp];  /* Add start offset */
700a2870: 980b         	ldr	r0, [sp, #0x2c]
700a2872: 9904         	ldr	r1, [sp, #0x10]
700a2874: 9a0e         	ldr	r2, [sp, #0x38]
700a2876: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a287a: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a287e: 4408         	add	r0, r1
700a2880: 900c         	str	r0, [sp, #0x30]
;                 break;
700a2882: e004         	b	0x700a288e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x8
;         }
700a2884: e7ff         	b	0x700a2886 <Udma_rmAllocMappedRing+0x126> @ imm = #-0x2
;         for(i = loopStart; i < loopMax; i++)
700a2886: 980b         	ldr	r0, [sp, #0x2c]
700a2888: 3001         	adds	r0, #0x1
700a288a: 900b         	str	r0, [sp, #0x2c]
700a288c: e7c4         	b	0x700a2818 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x78
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a288e: 980f         	ldr	r0, [sp, #0x3c]
700a2890: f500 609f    	add.w	r0, r0, #0x4f8
700a2894: f009 fa8c    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x9518
;     }
700a2898: e7ff         	b	0x700a289a <Udma_rmAllocMappedRing+0x13a> @ imm = #-0x2
;     return (ringNum);
700a289a: 980c         	ldr	r0, [sp, #0x30]
700a289c: b010         	add	sp, #0x40
700a289e: bd80         	pop	{r7, pc}

700a28a0 <UART_procLineStatusErr>:
; {
700a28a0: b580         	push	{r7, lr}
700a28a2: b086         	sub	sp, #0x18
700a28a4: 9005         	str	r0, [sp, #0x14]
700a28a6: 2000         	movs	r0, #0x0
;     int32_t            status = UART_STATUS_SUCCESS;
700a28a8: 9004         	str	r0, [sp, #0x10]
;     uint32_t           lineStatus, iteration = 0U;
700a28aa: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == hUart)
700a28ac: 9805         	ldr	r0, [sp, #0x14]
700a28ae: b920         	cbnz	r0, 0x700a28ba <UART_procLineStatusErr+0x1a> @ imm = #0x8
700a28b0: e7ff         	b	0x700a28b2 <UART_procLineStatusErr+0x12> @ imm = #-0x2
700a28b2: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a28b6: 9004         	str	r0, [sp, #0x10]
;     }
700a28b8: e7ff         	b	0x700a28ba <UART_procLineStatusErr+0x1a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a28ba: 9804         	ldr	r0, [sp, #0x10]
700a28bc: 2800         	cmp	r0, #0x0
700a28be: f040 808b    	bne.w	0x700a29d8 <UART_procLineStatusErr+0x138> @ imm = #0x116
700a28c2: e7ff         	b	0x700a28c4 <UART_procLineStatusErr+0x24> @ imm = #-0x2
;         lineStatus = UART_readLineStatus(hUart->baseAddr);
700a28c4: 9805         	ldr	r0, [sp, #0x14]
700a28c6: 6800         	ldr	r0, [r0]
700a28c8: f00a ff72    	bl	0x700ad7b0 <UART_readLineStatus> @ imm = #0xaee4
700a28cc: 9003         	str	r0, [sp, #0xc]
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a28ce: 9803         	ldr	r0, [sp, #0xc]
700a28d0: f000 0080    	and	r0, r0, #0x80
;                 || ((lineStatus & UART_OVERRUN_ERROR) == UART_OVERRUN_ERROR))
700a28d4: 2880         	cmp	r0, #0x80
700a28d6: d006         	beq	0x700a28e6 <UART_procLineStatusErr+0x46> @ imm = #0xc
700a28d8: e7ff         	b	0x700a28da <UART_procLineStatusErr+0x3a> @ imm = #-0x2
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a28da: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a28de: 0780         	lsls	r0, r0, #0x1e
700a28e0: 2800         	cmp	r0, #0x0
700a28e2: d578         	bpl	0x700a29d6 <UART_procLineStatusErr+0x136> @ imm = #0xf0
700a28e4: e7ff         	b	0x700a28e6 <UART_procLineStatusErr+0x46> @ imm = #-0x2
;             if (hUart->readTrans.buf != NULL)
700a28e6: 9805         	ldr	r0, [sp, #0x14]
700a28e8: 6a80         	ldr	r0, [r0, #0x28]
700a28ea: b120         	cbz	r0, 0x700a28f6 <UART_procLineStatusErr+0x56> @ imm = #0x8
700a28ec: e7ff         	b	0x700a28ee <UART_procLineStatusErr+0x4e> @ imm = #-0x2
;                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
700a28ee: 9905         	ldr	r1, [sp, #0x14]
700a28f0: 6988         	ldr	r0, [r1, #0x18]
700a28f2: 62c8         	str	r0, [r1, #0x2c]
;             }
700a28f4: e7ff         	b	0x700a28f6 <UART_procLineStatusErr+0x56> @ imm = #-0x2
700a28f6: 2040         	movs	r0, #0x40
;             iteration = UART_FIFO_SIZE;
700a28f8: 9002         	str	r0, [sp, #0x8]
;             do
700a28fa: e7ff         	b	0x700a28fc <UART_procLineStatusErr+0x5c> @ imm = #-0x2
;                 (void)UART_fifoCharGet(hUart->baseAddr);
700a28fc: 9805         	ldr	r0, [sp, #0x14]
700a28fe: 6800         	ldr	r0, [r0]
700a2900: f00c fe6e    	bl	0x700af5e0 <UART_fifoCharGet> @ imm = #0xccdc
;                 iteration--;
700a2904: 9802         	ldr	r0, [sp, #0x8]
700a2906: 3801         	subs	r0, #0x1
700a2908: 9002         	str	r0, [sp, #0x8]
;                 lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a290a: 9805         	ldr	r0, [sp, #0x14]
700a290c: 6800         	ldr	r0, [r0]
700a290e: f00a ff4f    	bl	0x700ad7b0 <UART_readLineStatus> @ imm = #0xae9e
700a2912: 9003         	str	r0, [sp, #0xc]
;                 lineStatus &= (UART_LSR_RX_FIFO_STS_MASK |
700a2914: 9803         	ldr	r0, [sp, #0xc]
700a2916: f000 009f    	and	r0, r0, #0x9f
700a291a: 9003         	str	r0, [sp, #0xc]
;             }
700a291c: e7ff         	b	0x700a291e <UART_procLineStatusErr+0x7e> @ imm = #-0x2
;             while ((lineStatus != 0U) && (iteration != 0U));
700a291e: 9903         	ldr	r1, [sp, #0xc]
700a2920: 2000         	movs	r0, #0x0
700a2922: 9001         	str	r0, [sp, #0x4]
700a2924: b131         	cbz	r1, 0x700a2934 <UART_procLineStatusErr+0x94> @ imm = #0xc
700a2926: e7ff         	b	0x700a2928 <UART_procLineStatusErr+0x88> @ imm = #-0x2
700a2928: 9802         	ldr	r0, [sp, #0x8]
700a292a: 2800         	cmp	r0, #0x0
700a292c: bf18         	it	ne
700a292e: 2001         	movne	r0, #0x1
700a2930: 9001         	str	r0, [sp, #0x4]
700a2932: e7ff         	b	0x700a2934 <UART_procLineStatusErr+0x94> @ imm = #-0x2
700a2934: 9801         	ldr	r0, [sp, #0x4]
;             }
700a2936: 07c0         	lsls	r0, r0, #0x1f
700a2938: 2800         	cmp	r0, #0x0
700a293a: d1df         	bne	0x700a28fc <UART_procLineStatusErr+0x5c> @ imm = #-0x42
700a293c: e7ff         	b	0x700a293e <UART_procLineStatusErr+0x9e> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a293e: 9805         	ldr	r0, [sp, #0x14]
700a2940: 6800         	ldr	r0, [r0]
700a2942: 2105         	movs	r1, #0x5
700a2944: f003 fc2c    	bl	0x700a61a0 <UART_intrDisable> @ imm = #0x3858
;             hUart->readBuf = (void *)((uint8_t *)hUart->readBuf - hUart->readCount);
700a2948: 9905         	ldr	r1, [sp, #0x14]
700a294a: 6948         	ldr	r0, [r1, #0x14]
700a294c: 698a         	ldr	r2, [r1, #0x18]
700a294e: 1a80         	subs	r0, r0, r2
700a2950: 6148         	str	r0, [r1, #0x14]
;             if (hUart->readTrans.buf != NULL)
700a2952: 9805         	ldr	r0, [sp, #0x14]
700a2954: 6a80         	ldr	r0, [r0, #0x28]
700a2956: b3a8         	cbz	r0, 0x700a29c4 <UART_procLineStatusErr+0x124> @ imm = #0x6a
700a2958: e7ff         	b	0x700a295a <UART_procLineStatusErr+0xba> @ imm = #-0x2
;                 if ((lineStatus & UART_BREAK_DETECTED_ERROR) != 0U)
700a295a: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a295e: 06c0         	lsls	r0, r0, #0x1b
700a2960: 2800         	cmp	r0, #0x0
700a2962: d508         	bpl	0x700a2976 <UART_procLineStatusErr+0xd6> @ imm = #0x10
700a2964: e7ff         	b	0x700a2966 <UART_procLineStatusErr+0xc6> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_BI;
700a2966: 9905         	ldr	r1, [sp, #0x14]
700a2968: 2002         	movs	r0, #0x2
700a296a: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a296c: 9905         	ldr	r1, [sp, #0x14]
700a296e: 6a48         	ldr	r0, [r1, #0x24]
700a2970: 3001         	adds	r0, #0x1
700a2972: 6248         	str	r0, [r1, #0x24]
;                 }
700a2974: e025         	b	0x700a29c2 <UART_procLineStatusErr+0x122> @ imm = #0x4a
;                 else if ((lineStatus & UART_FRAMING_ERROR) != 0U)
700a2976: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a297a: 0700         	lsls	r0, r0, #0x1c
700a297c: 2800         	cmp	r0, #0x0
700a297e: d508         	bpl	0x700a2992 <UART_procLineStatusErr+0xf2> @ imm = #0x10
700a2980: e7ff         	b	0x700a2982 <UART_procLineStatusErr+0xe2> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_FE;
700a2982: 9905         	ldr	r1, [sp, #0x14]
700a2984: 2003         	movs	r0, #0x3
700a2986: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2988: 9905         	ldr	r1, [sp, #0x14]
700a298a: 6a48         	ldr	r0, [r1, #0x24]
700a298c: 3001         	adds	r0, #0x1
700a298e: 6248         	str	r0, [r1, #0x24]
;                 }
700a2990: e016         	b	0x700a29c0 <UART_procLineStatusErr+0x120> @ imm = #0x2c
;                 else if ((lineStatus & UART_PARITY_ERROR) != 0U)
700a2992: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a2996: 0740         	lsls	r0, r0, #0x1d
700a2998: 2800         	cmp	r0, #0x0
700a299a: d508         	bpl	0x700a29ae <UART_procLineStatusErr+0x10e> @ imm = #0x10
700a299c: e7ff         	b	0x700a299e <UART_procLineStatusErr+0xfe> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_PE;
700a299e: 9905         	ldr	r1, [sp, #0x14]
700a29a0: 2004         	movs	r0, #0x4
700a29a2: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a29a4: 9905         	ldr	r1, [sp, #0x14]
700a29a6: 6a48         	ldr	r0, [r1, #0x24]
700a29a8: 3001         	adds	r0, #0x1
700a29aa: 6248         	str	r0, [r1, #0x24]
;                 }
700a29ac: e007         	b	0x700a29be <UART_procLineStatusErr+0x11e> @ imm = #0xe
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OE;
700a29ae: 9905         	ldr	r1, [sp, #0x14]
700a29b0: 2005         	movs	r0, #0x5
700a29b2: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a29b4: 9905         	ldr	r1, [sp, #0x14]
700a29b6: 6a48         	ldr	r0, [r1, #0x24]
700a29b8: 3001         	adds	r0, #0x1
700a29ba: 6248         	str	r0, [r1, #0x24]
700a29bc: e7ff         	b	0x700a29be <UART_procLineStatusErr+0x11e> @ imm = #-0x2
700a29be: e7ff         	b	0x700a29c0 <UART_procLineStatusErr+0x120> @ imm = #-0x2
700a29c0: e7ff         	b	0x700a29c2 <UART_procLineStatusErr+0x122> @ imm = #-0x2
;             }
700a29c2: e7ff         	b	0x700a29c4 <UART_procLineStatusErr+0x124> @ imm = #-0x2
;             hUart->hUartInit->errorCallbackFxn(hUart);
700a29c4: 9805         	ldr	r0, [sp, #0x14]
700a29c6: 6841         	ldr	r1, [r0, #0x4]
700a29c8: 6e49         	ldr	r1, [r1, #0x64]
700a29ca: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a29cc: 9805         	ldr	r0, [sp, #0x14]
700a29ce: 3028         	adds	r0, #0x28
700a29d0: f00c fd26    	bl	0x700af420 <UART_lld_Transaction_deInit> @ imm = #0xca4c
;         }
700a29d4: e7ff         	b	0x700a29d6 <UART_procLineStatusErr+0x136> @ imm = #-0x2
;     }
700a29d6: e7ff         	b	0x700a29d8 <UART_procLineStatusErr+0x138> @ imm = #-0x2
;     return status;
700a29d8: 9804         	ldr	r0, [sp, #0x10]
700a29da: b006         	add	sp, #0x18
700a29dc: bd80         	pop	{r7, pc}
700a29de: 0000         	movs	r0, r0

700a29e0 <prvProcessReceivedCommands>:
;     {
700a29e0: b580         	push	{r7, lr}
700a29e2: b08c         	sub	sp, #0x30
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a29e4: e7ff         	b	0x700a29e6 <prvProcessReceivedCommands+0x6> @ imm = #-0x2
700a29e6: f642 2048    	movw	r0, #0x2a48
700a29ea: f2c7 000b    	movt	r0, #0x700b
700a29ee: 6800         	ldr	r0, [r0]
700a29f0: a908         	add	r1, sp, #0x20
700a29f2: 2200         	movs	r2, #0x0
700a29f4: f000 fd6c    	bl	0x700a34d0 <xQueueReceive> @ imm = #0xad8
700a29f8: 2800         	cmp	r0, #0x0
700a29fa: f000 808c    	beq.w	0x700a2b16 <prvProcessReceivedCommands+0x136> @ imm = #0x118
700a29fe: e7ff         	b	0x700a2a00 <prvProcessReceivedCommands+0x20> @ imm = #-0x2
;                     if( xMessage.xMessageID < ( BaseType_t ) 0 )
700a2a00: 9808         	ldr	r0, [sp, #0x20]
700a2a02: f1b0 3fff    	cmp.w	r0, #0xffffffff
700a2a06: dc09         	bgt	0x700a2a1c <prvProcessReceivedCommands+0x3c> @ imm = #0x12
700a2a08: e7ff         	b	0x700a2a0a <prvProcessReceivedCommands+0x2a> @ imm = #-0x2
700a2a0a: a808         	add	r0, sp, #0x20
;                         const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
700a2a0c: 3004         	adds	r0, #0x4
700a2a0e: 9003         	str	r0, [sp, #0xc]
;                         pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
700a2a10: 9903         	ldr	r1, [sp, #0xc]
700a2a12: 680a         	ldr	r2, [r1]
700a2a14: 6848         	ldr	r0, [r1, #0x4]
700a2a16: 6889         	ldr	r1, [r1, #0x8]
700a2a18: 4790         	blx	r2
;                     }
700a2a1a: e000         	b	0x700a2a1e <prvProcessReceivedCommands+0x3e> @ imm = #0x0
700a2a1c: e7ff         	b	0x700a2a1e <prvProcessReceivedCommands+0x3e> @ imm = #-0x2
;             if( xMessage.xMessageID >= ( BaseType_t ) 0 )
700a2a1e: 9808         	ldr	r0, [sp, #0x20]
700a2a20: 2800         	cmp	r0, #0x0
700a2a22: f100 8077    	bmi.w	0x700a2b14 <prvProcessReceivedCommands+0x134> @ imm = #0xee
700a2a26: e7ff         	b	0x700a2a28 <prvProcessReceivedCommands+0x48> @ imm = #-0x2
;                 pxTimer = xMessage.u.xTimerParameters.pxTimer;
700a2a28: 980a         	ldr	r0, [sp, #0x28]
700a2a2a: 9007         	str	r0, [sp, #0x1c]
;                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
700a2a2c: 9807         	ldr	r0, [sp, #0x1c]
700a2a2e: 6940         	ldr	r0, [r0, #0x14]
700a2a30: b128         	cbz	r0, 0x700a2a3e <prvProcessReceivedCommands+0x5e> @ imm = #0xa
700a2a32: e7ff         	b	0x700a2a34 <prvProcessReceivedCommands+0x54> @ imm = #-0x2
;                     ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a2a34: 9807         	ldr	r0, [sp, #0x1c]
700a2a36: 3004         	adds	r0, #0x4
700a2a38: f00a fdf2    	bl	0x700ad620 <uxListRemove> @ imm = #0xabe4
;                 }
700a2a3c: e000         	b	0x700a2a40 <prvProcessReceivedCommands+0x60> @ imm = #0x0
700a2a3e: e7ff         	b	0x700a2a40 <prvProcessReceivedCommands+0x60> @ imm = #-0x2
700a2a40: a806         	add	r0, sp, #0x18
;                 xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700a2a42: f00a ff55    	bl	0x700ad8f0 <prvSampleTimeNow> @ imm = #0xaeaa
700a2a46: 9004         	str	r0, [sp, #0x10]
;                 switch( xMessage.xMessageID )
700a2a48: 9808         	ldr	r0, [sp, #0x20]
700a2a4a: 9002         	str	r0, [sp, #0x8]
700a2a4c: 2809         	cmp	r0, #0x9
700a2a4e: d85f         	bhi	0x700a2b10 <prvProcessReceivedCommands+0x130> @ imm = #0xbe
700a2a50: 9902         	ldr	r1, [sp, #0x8]
700a2a52: e8df f001    	tbb	[pc, r1]
700a2a56: 05 05 05 2f  	.word	0x2f050505
700a2a5a: 37 49 05 05  	.word	0x05054937
700a2a5e: 2f 37        	.short	0x372f
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a2a60: 9907         	ldr	r1, [sp, #0x1c]
700a2a62: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2a66: f040 0001    	orr	r0, r0, #0x1
700a2a6a: f881 0028    	strb.w	r0, [r1, #0x28]
;                         if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
700a2a6e: 9807         	ldr	r0, [sp, #0x1c]
700a2a70: 9b09         	ldr	r3, [sp, #0x24]
700a2a72: 6981         	ldr	r1, [r0, #0x18]
700a2a74: 4419         	add	r1, r3
700a2a76: 9a04         	ldr	r2, [sp, #0x10]
700a2a78: f007 fcb2    	bl	0x700aa3e0 <prvInsertTimerInActiveList> @ imm = #0x7964
700a2a7c: b1c0         	cbz	r0, 0x700a2ab0 <prvProcessReceivedCommands+0xd0> @ imm = #0x30
700a2a7e: e7ff         	b	0x700a2a80 <prvProcessReceivedCommands+0xa0> @ imm = #-0x2
;                             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a2a80: 9807         	ldr	r0, [sp, #0x1c]
700a2a82: 6a01         	ldr	r1, [r0, #0x20]
700a2a84: 4788         	blx	r1
;                             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a2a86: 9807         	ldr	r0, [sp, #0x1c]
700a2a88: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a2a8c: 0740         	lsls	r0, r0, #0x1d
700a2a8e: 2800         	cmp	r0, #0x0
700a2a90: d50c         	bpl	0x700a2aac <prvProcessReceivedCommands+0xcc> @ imm = #0x18
700a2a92: e7ff         	b	0x700a2a94 <prvProcessReceivedCommands+0xb4> @ imm = #-0x2
;                                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
700a2a94: 9807         	ldr	r0, [sp, #0x1c]
700a2a96: 9909         	ldr	r1, [sp, #0x24]
700a2a98: 6982         	ldr	r2, [r0, #0x18]
700a2a9a: 440a         	add	r2, r1
700a2a9c: 4669         	mov	r1, sp
700a2a9e: 2300         	movs	r3, #0x0
700a2aa0: 600b         	str	r3, [r1]
700a2aa2: 4619         	mov	r1, r3
700a2aa4: f006 ff6c    	bl	0x700a9980 <xTimerGenericCommand> @ imm = #0x6ed8
700a2aa8: 9005         	str	r0, [sp, #0x14]
;                             }
700a2aaa: e000         	b	0x700a2aae <prvProcessReceivedCommands+0xce> @ imm = #0x0
700a2aac: e7ff         	b	0x700a2aae <prvProcessReceivedCommands+0xce> @ imm = #-0x2
;                         }
700a2aae: e000         	b	0x700a2ab2 <prvProcessReceivedCommands+0xd2> @ imm = #0x0
700a2ab0: e7ff         	b	0x700a2ab2 <prvProcessReceivedCommands+0xd2> @ imm = #-0x2
;                         break;
700a2ab2: e02e         	b	0x700a2b12 <prvProcessReceivedCommands+0x132> @ imm = #0x5c
;                         pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a2ab4: 9907         	ldr	r1, [sp, #0x1c]
700a2ab6: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2aba: f000 00fe    	and	r0, r0, #0xfe
700a2abe: f881 0028    	strb.w	r0, [r1, #0x28]
;                         break;
700a2ac2: e026         	b	0x700a2b12 <prvProcessReceivedCommands+0x132> @ imm = #0x4c
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a2ac4: 9907         	ldr	r1, [sp, #0x1c]
700a2ac6: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2aca: f040 0001    	orr	r0, r0, #0x1
700a2ace: f881 0028    	strb.w	r0, [r1, #0x28]
;                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
700a2ad2: 9809         	ldr	r0, [sp, #0x24]
700a2ad4: 9907         	ldr	r1, [sp, #0x1c]
700a2ad6: 6188         	str	r0, [r1, #0x18]
;                         ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
700a2ad8: 9807         	ldr	r0, [sp, #0x1c]
700a2ada: 9b04         	ldr	r3, [sp, #0x10]
700a2adc: 6981         	ldr	r1, [r0, #0x18]
700a2ade: 4419         	add	r1, r3
700a2ae0: 461a         	mov	r2, r3
700a2ae2: f007 fc7d    	bl	0x700aa3e0 <prvInsertTimerInActiveList> @ imm = #0x78fa
;                         break;
700a2ae6: e014         	b	0x700a2b12 <prvProcessReceivedCommands+0x132> @ imm = #0x28
;                                 if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
700a2ae8: 9807         	ldr	r0, [sp, #0x1c]
700a2aea: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a2aee: 0780         	lsls	r0, r0, #0x1e
700a2af0: 2800         	cmp	r0, #0x0
700a2af2: d404         	bmi	0x700a2afe <prvProcessReceivedCommands+0x11e> @ imm = #0x8
700a2af4: e7ff         	b	0x700a2af6 <prvProcessReceivedCommands+0x116> @ imm = #-0x2
;                                     vPortFree( pxTimer );
700a2af6: 9807         	ldr	r0, [sp, #0x1c]
700a2af8: f00c fc22    	bl	0x700af340 <vPortFree>  @ imm = #0xc844
;                                 }
700a2afc: e007         	b	0x700a2b0e <prvProcessReceivedCommands+0x12e> @ imm = #0xe
;                                     pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a2afe: 9907         	ldr	r1, [sp, #0x1c]
700a2b00: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2b04: f000 00fe    	and	r0, r0, #0xfe
700a2b08: f881 0028    	strb.w	r0, [r1, #0x28]
700a2b0c: e7ff         	b	0x700a2b0e <prvProcessReceivedCommands+0x12e> @ imm = #-0x2
;                         break;
700a2b0e: e000         	b	0x700a2b12 <prvProcessReceivedCommands+0x132> @ imm = #0x0
;                         break;
700a2b10: e7ff         	b	0x700a2b12 <prvProcessReceivedCommands+0x132> @ imm = #-0x2
;             }
700a2b12: e7ff         	b	0x700a2b14 <prvProcessReceivedCommands+0x134> @ imm = #-0x2
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a2b14: e767         	b	0x700a29e6 <prvProcessReceivedCommands+0x6> @ imm = #-0x132
;     }
700a2b16: b00c         	add	sp, #0x30
700a2b18: bd80         	pop	{r7, pc}
700a2b1a: 0000         	movs	r0, r0
700a2b1c: 0000         	movs	r0, r0
700a2b1e: 0000         	movs	r0, r0

700a2b20 <_ntoa_long_long>:
; {
700a2b20: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a2b24: b09e         	sub	sp, #0x78
700a2b26: 469e         	mov	lr, r3
700a2b28: 4614         	mov	r4, r2
700a2b2a: 460d         	mov	r5, r1
700a2b2c: 4606         	mov	r6, r0
700a2b2e: 9929         	ldr	r1, [sp, #0xa4]
700a2b30: 9828         	ldr	r0, [sp, #0xa0]
700a2b32: f8dd c094    	ldr.w	r12, [sp, #0x94]
700a2b36: 9b24         	ldr	r3, [sp, #0x90]
700a2b38: 9a2c         	ldr	r2, [sp, #0xb0]
700a2b3a: 9a2b         	ldr	r2, [sp, #0xac]
700a2b3c: 9a2a         	ldr	r2, [sp, #0xa8]
700a2b3e: 9a26         	ldr	r2, [sp, #0x98]
700a2b40: 961d         	str	r6, [sp, #0x74]
700a2b42: 951c         	str	r5, [sp, #0x70]
700a2b44: 941b         	str	r4, [sp, #0x6c]
700a2b46: f8cd e068    	str.w	lr, [sp, #0x68]
700a2b4a: f8cd c064    	str.w	r12, [sp, #0x64]
700a2b4e: 9318         	str	r3, [sp, #0x60]
700a2b50: f88d 205f    	strb.w	r2, [sp, #0x5f]
700a2b54: 9115         	str	r1, [sp, #0x54]
700a2b56: 9014         	str	r0, [sp, #0x50]
700a2b58: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a2b5a: 900b         	str	r0, [sp, #0x2c]
;   if (!value) {
700a2b5c: 9818         	ldr	r0, [sp, #0x60]
700a2b5e: 9919         	ldr	r1, [sp, #0x64]
700a2b60: 4308         	orrs	r0, r1
700a2b62: b928         	cbnz	r0, 0x700a2b70 <_ntoa_long_long+0x50> @ imm = #0xa
700a2b64: e7ff         	b	0x700a2b66 <_ntoa_long_long+0x46> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a2b66: 982c         	ldr	r0, [sp, #0xb0]
700a2b68: f020 0010    	bic	r0, r0, #0x10
700a2b6c: 902c         	str	r0, [sp, #0xb0]
;   }
700a2b6e: e7ff         	b	0x700a2b70 <_ntoa_long_long+0x50> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a2b70: f89d 00b1    	ldrb.w	r0, [sp, #0xb1]
700a2b74: 0740         	lsls	r0, r0, #0x1d
700a2b76: 2800         	cmp	r0, #0x0
700a2b78: d506         	bpl	0x700a2b88 <_ntoa_long_long+0x68> @ imm = #0xc
700a2b7a: e7ff         	b	0x700a2b7c <_ntoa_long_long+0x5c> @ imm = #-0x2
700a2b7c: 9818         	ldr	r0, [sp, #0x60]
700a2b7e: 9919         	ldr	r1, [sp, #0x64]
700a2b80: 4308         	orrs	r0, r1
700a2b82: 2800         	cmp	r0, #0x0
700a2b84: d043         	beq	0x700a2c0e <_ntoa_long_long+0xee> @ imm = #0x86
700a2b86: e7ff         	b	0x700a2b88 <_ntoa_long_long+0x68> @ imm = #-0x2
;     do {
700a2b88: e7ff         	b	0x700a2b8a <_ntoa_long_long+0x6a> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a2b8a: 9818         	ldr	r0, [sp, #0x60]
700a2b8c: 9919         	ldr	r1, [sp, #0x64]
700a2b8e: 9a14         	ldr	r2, [sp, #0x50]
700a2b90: 9b15         	ldr	r3, [sp, #0x54]
700a2b92: f00c eae0    	blx	0x700af154 <__aeabi_uldivmod> @ imm = #0xc5c0
700a2b96: f88d 202b    	strb.w	r2, [sp, #0x2b]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a2b9a: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a2b9e: 2809         	cmp	r0, #0x9
700a2ba0: dc05         	bgt	0x700a2bae <_ntoa_long_long+0x8e> @ imm = #0xa
700a2ba2: e7ff         	b	0x700a2ba4 <_ntoa_long_long+0x84> @ imm = #-0x2
700a2ba4: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a2ba8: 3030         	adds	r0, #0x30
700a2baa: 9009         	str	r0, [sp, #0x24]
700a2bac: e00c         	b	0x700a2bc8 <_ntoa_long_long+0xa8> @ imm = #0x18
700a2bae: f89d 00b0    	ldrb.w	r0, [sp, #0xb0]
700a2bb2: 0681         	lsls	r1, r0, #0x1a
700a2bb4: 2061         	movs	r0, #0x61
700a2bb6: 2900         	cmp	r1, #0x0
700a2bb8: bf48         	it	mi
700a2bba: 2041         	movmi	r0, #0x41
700a2bbc: f89d 102b    	ldrb.w	r1, [sp, #0x2b]
700a2bc0: 4408         	add	r0, r1
700a2bc2: 380a         	subs	r0, #0xa
700a2bc4: 9009         	str	r0, [sp, #0x24]
700a2bc6: e7ff         	b	0x700a2bc8 <_ntoa_long_long+0xa8> @ imm = #-0x2
700a2bc8: 9809         	ldr	r0, [sp, #0x24]
700a2bca: 9a0b         	ldr	r2, [sp, #0x2c]
700a2bcc: 1c51         	adds	r1, r2, #0x1
700a2bce: 910b         	str	r1, [sp, #0x2c]
700a2bd0: a90c         	add	r1, sp, #0x30
700a2bd2: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a2bd4: 9a14         	ldr	r2, [sp, #0x50]
700a2bd6: 9b15         	ldr	r3, [sp, #0x54]
700a2bd8: 9818         	ldr	r0, [sp, #0x60]
700a2bda: 9919         	ldr	r1, [sp, #0x64]
700a2bdc: f00c eaba    	blx	0x700af154 <__aeabi_uldivmod> @ imm = #0xc574
700a2be0: 9119         	str	r1, [sp, #0x64]
700a2be2: 9018         	str	r0, [sp, #0x60]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a2be4: e7ff         	b	0x700a2be6 <_ntoa_long_long+0xc6> @ imm = #-0x2
700a2be6: 9818         	ldr	r0, [sp, #0x60]
700a2be8: 9919         	ldr	r1, [sp, #0x64]
700a2bea: 4301         	orrs	r1, r0
700a2bec: 2000         	movs	r0, #0x0
700a2bee: 9008         	str	r0, [sp, #0x20]
700a2bf0: b139         	cbz	r1, 0x700a2c02 <_ntoa_long_long+0xe2> @ imm = #0xe
700a2bf2: e7ff         	b	0x700a2bf4 <_ntoa_long_long+0xd4> @ imm = #-0x2
700a2bf4: 990b         	ldr	r1, [sp, #0x2c]
700a2bf6: 2000         	movs	r0, #0x0
700a2bf8: 2920         	cmp	r1, #0x20
700a2bfa: bf38         	it	lo
700a2bfc: 2001         	movlo	r0, #0x1
700a2bfe: 9008         	str	r0, [sp, #0x20]
700a2c00: e7ff         	b	0x700a2c02 <_ntoa_long_long+0xe2> @ imm = #-0x2
700a2c02: 9808         	ldr	r0, [sp, #0x20]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a2c04: 07c0         	lsls	r0, r0, #0x1f
700a2c06: 2800         	cmp	r0, #0x0
700a2c08: d1bf         	bne	0x700a2b8a <_ntoa_long_long+0x6a> @ imm = #-0x82
700a2c0a: e7ff         	b	0x700a2c0c <_ntoa_long_long+0xec> @ imm = #-0x2
;   }
700a2c0c: e7ff         	b	0x700a2c0e <_ntoa_long_long+0xee> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a2c0e: 981d         	ldr	r0, [sp, #0x74]
700a2c10: 991c         	ldr	r1, [sp, #0x70]
700a2c12: 9a1b         	ldr	r2, [sp, #0x6c]
700a2c14: 9b1a         	ldr	r3, [sp, #0x68]
700a2c16: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a2c1a: 9d14         	ldr	r5, [sp, #0x50]
700a2c1c: 9e2a         	ldr	r6, [sp, #0xa8]
700a2c1e: 9f2b         	ldr	r7, [sp, #0xac]
700a2c20: f8dd 80b0    	ldr.w	r8, [sp, #0xb0]
700a2c24: f89d 405f    	ldrb.w	r4, [sp, #0x5f]
700a2c28: 46ee         	mov	lr, sp
700a2c2a: f8ce 8018    	str.w	r8, [lr, #0x18]
700a2c2e: f8ce 7014    	str.w	r7, [lr, #0x14]
700a2c32: f8ce 6010    	str.w	r6, [lr, #0x10]
700a2c36: f8ce 500c    	str.w	r5, [lr, #0xc]
700a2c3a: f004 0401    	and	r4, r4, #0x1
700a2c3e: f8ce 4008    	str.w	r4, [lr, #0x8]
700a2c42: f8ce c004    	str.w	r12, [lr, #0x4]
700a2c46: f10d 0c30    	add.w	r12, sp, #0x30
700a2c4a: f8ce c000    	str.w	r12, [lr]
700a2c4e: f7fb fb77    	bl	0x7009e340 <_ntoa_format> @ imm = #-0x4912
700a2c52: b01e         	add	sp, #0x78
700a2c54: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a2c60 <Sciclient_rmIrqVintDelete>:
; {
700a2c60: b580         	push	{r7, lr}
700a2c62: b08c         	sub	sp, #0x30
700a2c64: 900b         	str	r0, [sp, #0x2c]
700a2c66: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a2c68: 900a         	str	r0, [sp, #0x28]
;     bool del_mapping = false;
700a2c6a: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool del_whole_route = false;
700a2c6e: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a2c72: 9008         	str	r0, [sp, #0x20]
;     if (r == SystemP_SUCCESS) {
700a2c74: 980a         	ldr	r0, [sp, #0x28]
700a2c76: b948         	cbnz	r0, 0x700a2c8c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #0x12
700a2c78: e7ff         	b	0x700a2c7a <Sciclient_rmIrqVintDelete+0x1a> @ imm = #-0x2
;         r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700a2c7a: 990b         	ldr	r1, [sp, #0x2c]
700a2c7c: 8a08         	ldrh	r0, [r1, #0x10]
700a2c7e: 8a49         	ldrh	r1, [r1, #0x12]
700a2c80: f10d 0227    	add.w	r2, sp, #0x27
700a2c84: f008 fbfc    	bl	0x700ab480 <Sciclient_rmIaVintGetInfo> @ imm = #0x87f8
700a2c88: 900a         	str	r0, [sp, #0x28]
;     }
700a2c8a: e7ff         	b	0x700a2c8c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a2c8c: 980a         	ldr	r0, [sp, #0x28]
700a2c8e: b9e8         	cbnz	r0, 0x700a2ccc <Sciclient_rmIrqVintDelete+0x6c> @ imm = #0x3a
700a2c90: e7ff         	b	0x700a2c92 <Sciclient_rmIrqVintDelete+0x32> @ imm = #-0x2
;         if (num_evts == 0u) {
700a2c92: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a2c96: b920         	cbnz	r0, 0x700a2ca2 <Sciclient_rmIrqVintDelete+0x42> @ imm = #0x8
700a2c98: e7ff         	b	0x700a2c9a <Sciclient_rmIrqVintDelete+0x3a> @ imm = #-0x2
700a2c9a: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a2c9e: 900a         	str	r0, [sp, #0x28]
;         } else if ((num_evts > 1u) ||
700a2ca0: e013         	b	0x700a2cca <Sciclient_rmIrqVintDelete+0x6a> @ imm = #0x26
700a2ca2: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a2ca6: 2801         	cmp	r0, #0x1
700a2ca8: d806         	bhi	0x700a2cb8 <Sciclient_rmIrqVintDelete+0x58> @ imm = #0xc
700a2caa: e7ff         	b	0x700a2cac <Sciclient_rmIrqVintDelete+0x4c> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a2cac: 980b         	ldr	r0, [sp, #0x2c]
700a2cae: 6800         	ldr	r0, [r0]
700a2cb0: f008 fda6    	bl	0x700ab800 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x8b4c
;         } else if ((num_evts > 1u) ||
700a2cb4: b120         	cbz	r0, 0x700a2cc0 <Sciclient_rmIrqVintDelete+0x60> @ imm = #0x8
700a2cb6: e7ff         	b	0x700a2cb8 <Sciclient_rmIrqVintDelete+0x58> @ imm = #-0x2
700a2cb8: 2001         	movs	r0, #0x1
;             del_mapping = true;
700a2cba: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a2cbe: e003         	b	0x700a2cc8 <Sciclient_rmIrqVintDelete+0x68> @ imm = #0x6
700a2cc0: 2001         	movs	r0, #0x1
;             del_whole_route = true;
700a2cc2: f88d 0025    	strb.w	r0, [sp, #0x25]
700a2cc6: e7ff         	b	0x700a2cc8 <Sciclient_rmIrqVintDelete+0x68> @ imm = #-0x2
700a2cc8: e7ff         	b	0x700a2cca <Sciclient_rmIrqVintDelete+0x6a> @ imm = #-0x2
;     }
700a2cca: e7ff         	b	0x700a2ccc <Sciclient_rmIrqVintDelete+0x6c> @ imm = #-0x2
;     if (del_mapping == true) {
700a2ccc: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a2cd0: 07c0         	lsls	r0, r0, #0x1f
700a2cd2: 2800         	cmp	r0, #0x0
700a2cd4: d049         	beq	0x700a2d6a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #0x92
700a2cd6: e7ff         	b	0x700a2cd8 <Sciclient_rmIrqVintDelete+0x78> @ imm = #-0x2
700a2cd8: 203c         	movs	r0, #0x3c
700a2cda: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a2cde: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a2ce0: 980b         	ldr	r0, [sp, #0x2c]
700a2ce2: 7900         	ldrb	r0, [r0, #0x4]
700a2ce4: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a2ce8: 980b         	ldr	r0, [sp, #0x2c]
700a2cea: 88c0         	ldrh	r0, [r0, #0x6]
700a2cec: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a2cf0: 980b         	ldr	r0, [sp, #0x2c]
700a2cf2: 8900         	ldrh	r0, [r0, #0x8]
700a2cf4: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a2cf8: 980b         	ldr	r0, [sp, #0x2c]
700a2cfa: 8a00         	ldrh	r0, [r0, #0x10]
700a2cfc: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a2d00: 980b         	ldr	r0, [sp, #0x2c]
700a2d02: 8a40         	ldrh	r0, [r0, #0x12]
700a2d04: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a2d08: 980b         	ldr	r0, [sp, #0x2c]
700a2d0a: 89c0         	ldrh	r0, [r0, #0xe]
700a2d0c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a2d10: 980b         	ldr	r0, [sp, #0x2c]
700a2d12: 7d00         	ldrb	r0, [r0, #0x14]
700a2d14: f88d 001e    	strb.w	r0, [sp, #0x1e]
700a2d18: a801         	add	r0, sp, #0x4
700a2d1a: f04f 31ff    	mov.w	r1, #0xffffffff
;         r = Sciclient_rmIrqReleaseRaw(&req,
700a2d1e: f009 febf    	bl	0x700acaa0 <Sciclient_rmIrqReleaseRaw> @ imm = #0x9d7e
700a2d22: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2d24: 980a         	ldr	r0, [sp, #0x28]
700a2d26: b9f8         	cbnz	r0, 0x700a2d68 <Sciclient_rmIrqVintDelete+0x108> @ imm = #0x3e
700a2d28: e7ff         	b	0x700a2d2a <Sciclient_rmIrqVintDelete+0xca> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a2d2a: 980b         	ldr	r0, [sp, #0x2c]
700a2d2c: 8a00         	ldrh	r0, [r0, #0x10]
700a2d2e: f009 fb67    	bl	0x700ac400 <Sciclient_rmIaGetInst> @ imm = #0x96ce
700a2d32: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a2d34: 9808         	ldr	r0, [sp, #0x20]
700a2d36: b1b0         	cbz	r0, 0x700a2d66 <Sciclient_rmIrqVintDelete+0x106> @ imm = #0x2c
700a2d38: e7ff         	b	0x700a2d3a <Sciclient_rmIrqVintDelete+0xda> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]--;
700a2d3a: 9808         	ldr	r0, [sp, #0x20]
700a2d3c: 6901         	ldr	r1, [r0, #0x10]
700a2d3e: 980b         	ldr	r0, [sp, #0x2c]
700a2d40: 8a42         	ldrh	r2, [r0, #0x12]
700a2d42: 5c88         	ldrb	r0, [r1, r2]
700a2d44: 3801         	subs	r0, #0x1
700a2d46: 5488         	strb	r0, [r1, r2]
;                 if (ia_inst->v0_b0_evt == cfg->global_evt - ia_inst->sevt_offset) {
700a2d48: 9a08         	ldr	r2, [sp, #0x20]
700a2d4a: 8a90         	ldrh	r0, [r2, #0x14]
700a2d4c: 990b         	ldr	r1, [sp, #0x2c]
700a2d4e: 89c9         	ldrh	r1, [r1, #0xe]
700a2d50: 8912         	ldrh	r2, [r2, #0x8]
700a2d52: 1a89         	subs	r1, r1, r2
700a2d54: 4288         	cmp	r0, r1
700a2d56: d105         	bne	0x700a2d64 <Sciclient_rmIrqVintDelete+0x104> @ imm = #0xa
700a2d58: e7ff         	b	0x700a2d5a <Sciclient_rmIrqVintDelete+0xfa> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
700a2d5a: 9908         	ldr	r1, [sp, #0x20]
700a2d5c: f64f 70ff    	movw	r0, #0xffff
700a2d60: 8288         	strh	r0, [r1, #0x14]
;                 }
700a2d62: e7ff         	b	0x700a2d64 <Sciclient_rmIrqVintDelete+0x104> @ imm = #-0x2
;             }
700a2d64: e7ff         	b	0x700a2d66 <Sciclient_rmIrqVintDelete+0x106> @ imm = #-0x2
;         }
700a2d66: e7ff         	b	0x700a2d68 <Sciclient_rmIrqVintDelete+0x108> @ imm = #-0x2
;     }
700a2d68: e7ff         	b	0x700a2d6a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #-0x2
;     if (del_whole_route == true) {
700a2d6a: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a2d6e: 07c0         	lsls	r0, r0, #0x1f
700a2d70: b170         	cbz	r0, 0x700a2d90 <Sciclient_rmIrqVintDelete+0x130> @ imm = #0x1c
700a2d72: e7ff         	b	0x700a2d74 <Sciclient_rmIrqVintDelete+0x114> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700a2d74: 980b         	ldr	r0, [sp, #0x2c]
700a2d76: f7f9 fefb    	bl	0x7009cb70 <Sciclient_rmIrqGetRoute> @ imm = #-0x620a
700a2d7a: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2d7c: 980a         	ldr	r0, [sp, #0x28]
700a2d7e: b930         	cbnz	r0, 0x700a2d8e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #0xc
700a2d80: e7ff         	b	0x700a2d82 <Sciclient_rmIrqVintDelete+0x122> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, true);
700a2d82: 980b         	ldr	r0, [sp, #0x2c]
700a2d84: 2101         	movs	r1, #0x1
700a2d86: f7fd fc83    	bl	0x700a0690 <Sciclient_rmIrqDeleteRoute> @ imm = #-0x26fa
700a2d8a: 900a         	str	r0, [sp, #0x28]
;         }
700a2d8c: e7ff         	b	0x700a2d8e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #-0x2
;     }
700a2d8e: e7ff         	b	0x700a2d90 <Sciclient_rmIrqVintDelete+0x130> @ imm = #-0x2
;     return r;
700a2d90: 980a         	ldr	r0, [sp, #0x28]
700a2d92: b00c         	add	sp, #0x30
700a2d94: bd80         	pop	{r7, pc}
		...
700a2d9e: 0000         	movs	r0, r0

700a2da0 <UART_writePolling>:
; {
700a2da0: b580         	push	{r7, lr}
700a2da2: b08c         	sub	sp, #0x30
700a2da4: 900b         	str	r0, [sp, #0x2c]
700a2da6: 910a         	str	r1, [sp, #0x28]
700a2da8: 2000         	movs	r0, #0x0
;     int32_t             retVal          = UART_TRANSFER_STATUS_SUCCESS;
700a2daa: 9007         	str	r0, [sp, #0x1c]
;     uint32_t            timeoutElapsed  = FALSE;
700a2dac: 9006         	str	r0, [sp, #0x18]
;     uint32_t            baseAddr        = hUart->baseAddr;
700a2dae: 990b         	ldr	r1, [sp, #0x2c]
700a2db0: 6809         	ldr	r1, [r1]
700a2db2: 9105         	str	r1, [sp, #0x14]
;     uint32_t            lineStatus      = 0U;
700a2db4: 9004         	str	r0, [sp, #0x10]
;     hUartInit = hUart->hUartInit;
700a2db6: 980b         	ldr	r0, [sp, #0x2c]
700a2db8: 6840         	ldr	r0, [r0, #0x4]
700a2dba: 9003         	str	r0, [sp, #0xc]
;     hUart->writeSizeRemaining = trans->count;
700a2dbc: 980a         	ldr	r0, [sp, #0x28]
700a2dbe: 6840         	ldr	r0, [r0, #0x4]
700a2dc0: 990b         	ldr	r1, [sp, #0x2c]
700a2dc2: 6108         	str	r0, [r1, #0x10]
;     startTicks = hUartInit->clockP_get();
700a2dc4: 9803         	ldr	r0, [sp, #0xc]
700a2dc6: 6d40         	ldr	r0, [r0, #0x54]
700a2dc8: 4780         	blx	r0
700a2dca: 9009         	str	r0, [sp, #0x24]
;     while ((FALSE == timeoutElapsed)
700a2dcc: e7ff         	b	0x700a2dce <UART_writePolling+0x2e> @ imm = #-0x2
700a2dce: 9906         	ldr	r1, [sp, #0x18]
700a2dd0: 2000         	movs	r0, #0x0
;            && (0U != hUart->writeSizeRemaining))
700a2dd2: 9002         	str	r0, [sp, #0x8]
700a2dd4: b939         	cbnz	r1, 0x700a2de6 <UART_writePolling+0x46> @ imm = #0xe
700a2dd6: e7ff         	b	0x700a2dd8 <UART_writePolling+0x38> @ imm = #-0x2
700a2dd8: 980b         	ldr	r0, [sp, #0x2c]
700a2dda: 6900         	ldr	r0, [r0, #0x10]
700a2ddc: 2800         	cmp	r0, #0x0
700a2dde: bf18         	it	ne
700a2de0: 2001         	movne	r0, #0x1
700a2de2: 9002         	str	r0, [sp, #0x8]
700a2de4: e7ff         	b	0x700a2de6 <UART_writePolling+0x46> @ imm = #-0x2
700a2de6: 9802         	ldr	r0, [sp, #0x8]
;     while ((FALSE == timeoutElapsed)
700a2de8: 07c0         	lsls	r0, r0, #0x1f
700a2dea: b198         	cbz	r0, 0x700a2e14 <UART_writePolling+0x74> @ imm = #0x26
700a2dec: e7ff         	b	0x700a2dee <UART_writePolling+0x4e> @ imm = #-0x2
;         UART_writeDataPolling(hUart);
700a2dee: 980b         	ldr	r0, [sp, #0x2c]
700a2df0: f00b fa4e    	bl	0x700ae290 <UART_writeDataPolling> @ imm = #0xb49c
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700a2df4: 9803         	ldr	r0, [sp, #0xc]
700a2df6: 6d40         	ldr	r0, [r0, #0x54]
700a2df8: 4780         	blx	r0
700a2dfa: 9909         	ldr	r1, [sp, #0x24]
700a2dfc: 1a40         	subs	r0, r0, r1
700a2dfe: 9008         	str	r0, [sp, #0x20]
;         if (elapsedTicks >= trans->timeout)
700a2e00: 9808         	ldr	r0, [sp, #0x20]
700a2e02: 990a         	ldr	r1, [sp, #0x28]
700a2e04: 6889         	ldr	r1, [r1, #0x8]
700a2e06: 4288         	cmp	r0, r1
700a2e08: d303         	blo	0x700a2e12 <UART_writePolling+0x72> @ imm = #0x6
700a2e0a: e7ff         	b	0x700a2e0c <UART_writePolling+0x6c> @ imm = #-0x2
700a2e0c: 2001         	movs	r0, #0x1
;             timeoutElapsed = TRUE;
700a2e0e: 9006         	str	r0, [sp, #0x18]
;         }
700a2e10: e7ff         	b	0x700a2e12 <UART_writePolling+0x72> @ imm = #-0x2
;     while ((FALSE == timeoutElapsed)
700a2e12: e7dc         	b	0x700a2dce <UART_writePolling+0x2e> @ imm = #-0x48
;     if (0U == hUart->writeSizeRemaining)
700a2e14: 980b         	ldr	r0, [sp, #0x2c]
700a2e16: 6900         	ldr	r0, [r0, #0x10]
700a2e18: 2800         	cmp	r0, #0x0
700a2e1a: d149         	bne	0x700a2eb0 <UART_writePolling+0x110> @ imm = #0x92
700a2e1c: e7ff         	b	0x700a2e1e <UART_writePolling+0x7e> @ imm = #-0x2
;         do
700a2e1e: e7ff         	b	0x700a2e20 <UART_writePolling+0x80> @ imm = #-0x2
;             lineStatus = UART_readLineStatus(baseAddr);
700a2e20: 9805         	ldr	r0, [sp, #0x14]
700a2e22: f00a fcc5    	bl	0x700ad7b0 <UART_readLineStatus> @ imm = #0xa98a
700a2e26: 9004         	str	r0, [sp, #0x10]
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700a2e28: 9803         	ldr	r0, [sp, #0xc]
700a2e2a: 6d40         	ldr	r0, [r0, #0x54]
700a2e2c: 4780         	blx	r0
700a2e2e: 9909         	ldr	r1, [sp, #0x24]
700a2e30: 1a40         	subs	r0, r0, r1
700a2e32: 9008         	str	r0, [sp, #0x20]
;         }
700a2e34: e7ff         	b	0x700a2e36 <UART_writePolling+0x96> @ imm = #-0x2
;                (lineStatus & (uint32_t) (UART_LSR_TX_FIFO_E_MASK |
700a2e36: 9804         	ldr	r0, [sp, #0x10]
700a2e38: f000 0160    	and	r1, r0, #0x60
700a2e3c: 2000         	movs	r0, #0x0
;                 && (elapsedTicks < hUart->lineStatusTimeout));
700a2e3e: 2960         	cmp	r1, #0x60
700a2e40: 9001         	str	r0, [sp, #0x4]
700a2e42: d00d         	beq	0x700a2e60 <UART_writePolling+0xc0> @ imm = #0x1a
700a2e44: e7ff         	b	0x700a2e46 <UART_writePolling+0xa6> @ imm = #-0x2
700a2e46: 9808         	ldr	r0, [sp, #0x20]
700a2e48: 990b         	ldr	r1, [sp, #0x2c]
700a2e4a: 6e8a         	ldr	r2, [r1, #0x68]
700a2e4c: 6ec9         	ldr	r1, [r1, #0x6c]
700a2e4e: 1a80         	subs	r0, r0, r2
700a2e50: f04f 0000    	mov.w	r0, #0x0
700a2e54: eb70 0101    	sbcs.w	r1, r0, r1
700a2e58: bf38         	it	lo
700a2e5a: 2001         	movlo	r0, #0x1
700a2e5c: 9001         	str	r0, [sp, #0x4]
700a2e5e: e7ff         	b	0x700a2e60 <UART_writePolling+0xc0> @ imm = #-0x2
700a2e60: 9801         	ldr	r0, [sp, #0x4]
;         }
700a2e62: 07c0         	lsls	r0, r0, #0x1f
700a2e64: 2800         	cmp	r0, #0x0
700a2e66: d1db         	bne	0x700a2e20 <UART_writePolling+0x80> @ imm = #-0x4a
700a2e68: e7ff         	b	0x700a2e6a <UART_writePolling+0xca> @ imm = #-0x2
;         if(elapsedTicks >= hUart->lineStatusTimeout)
700a2e6a: 9808         	ldr	r0, [sp, #0x20]
700a2e6c: 990b         	ldr	r1, [sp, #0x2c]
700a2e6e: 6e8a         	ldr	r2, [r1, #0x68]
700a2e70: 6ec9         	ldr	r1, [r1, #0x6c]
700a2e72: 1a80         	subs	r0, r0, r2
700a2e74: f04f 0000    	mov.w	r0, #0x0
700a2e78: 4188         	sbcs	r0, r1
700a2e7a: d30f         	blo	0x700a2e9c <UART_writePolling+0xfc> @ imm = #0x1e
700a2e7c: e7ff         	b	0x700a2e7e <UART_writePolling+0xde> @ imm = #-0x2
700a2e7e: f06f 0001    	mvn	r0, #0x1
;             retVal             = UART_TRANSFER_TIMEOUT;
700a2e82: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a2e84: 990a         	ldr	r1, [sp, #0x28]
700a2e86: 2001         	movs	r0, #0x1
700a2e88: 60c8         	str	r0, [r1, #0xc]
;             trans->count       = hUart->writeCount;
700a2e8a: 980b         	ldr	r0, [sp, #0x2c]
700a2e8c: 68c0         	ldr	r0, [r0, #0xc]
700a2e8e: 990a         	ldr	r1, [sp, #0x28]
700a2e90: 6048         	str	r0, [r1, #0x4]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a2e92: 980b         	ldr	r0, [sp, #0x2c]
700a2e94: 303c         	adds	r0, #0x3c
700a2e96: f00c fac3    	bl	0x700af420 <UART_lld_Transaction_deInit> @ imm = #0xc586
;         }
700a2e9a: e008         	b	0x700a2eae <UART_writePolling+0x10e> @ imm = #0x10
700a2e9c: 2000         	movs	r0, #0x0
;             retVal             = UART_TRANSFER_STATUS_SUCCESS;
700a2e9e: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_SUCCESS;
700a2ea0: 990a         	ldr	r1, [sp, #0x28]
700a2ea2: 60c8         	str	r0, [r1, #0xc]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a2ea4: 980b         	ldr	r0, [sp, #0x2c]
700a2ea6: 303c         	adds	r0, #0x3c
700a2ea8: f00c faba    	bl	0x700af420 <UART_lld_Transaction_deInit> @ imm = #0xc574
700a2eac: e7ff         	b	0x700a2eae <UART_writePolling+0x10e> @ imm = #-0x2
;     }
700a2eae: e00e         	b	0x700a2ece <UART_writePolling+0x12e> @ imm = #0x1c
700a2eb0: f06f 0001    	mvn	r0, #0x1
;         retVal             = UART_TRANSFER_TIMEOUT;
700a2eb4: 9007         	str	r0, [sp, #0x1c]
;         trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a2eb6: 990a         	ldr	r1, [sp, #0x28]
700a2eb8: 2001         	movs	r0, #0x1
700a2eba: 60c8         	str	r0, [r1, #0xc]
;         trans->count       = hUart->writeCount;
700a2ebc: 980b         	ldr	r0, [sp, #0x2c]
700a2ebe: 68c0         	ldr	r0, [r0, #0xc]
700a2ec0: 990a         	ldr	r1, [sp, #0x28]
700a2ec2: 6048         	str	r0, [r1, #0x4]
;         UART_lld_Transaction_deInit(&hUart->writeTrans);
700a2ec4: 980b         	ldr	r0, [sp, #0x2c]
700a2ec6: 303c         	adds	r0, #0x3c
700a2ec8: f00c faaa    	bl	0x700af420 <UART_lld_Transaction_deInit> @ imm = #0xc554
700a2ecc: e7ff         	b	0x700a2ece <UART_writePolling+0x12e> @ imm = #-0x2
;     return (retVal);
700a2ece: 9807         	ldr	r0, [sp, #0x1c]
700a2ed0: b00c         	add	sp, #0x30
700a2ed2: bd80         	pop	{r7, pc}
		...

700a2ee0 <Sciclient_recvMessage>:
; {
700a2ee0: b580         	push	{r7, lr}
700a2ee2: b08e         	sub	sp, #0x38
700a2ee4: 900d         	str	r0, [sp, #0x34]
700a2ee6: 910c         	str	r1, [sp, #0x30]
700a2ee8: 920b         	str	r2, [sp, #0x2c]
700a2eea: 2000         	movs	r0, #0x0
;     uint8_t  trailBytes = 0U;
700a2eec: f88d 0023    	strb.w	r0, [sp, #0x23]
;     numWords   = (uint32_t) (rxPayloadSize / 4U);
700a2ef0: 990b         	ldr	r1, [sp, #0x2c]
700a2ef2: ea4f 0191    	lsr.w	r1, r1, #0x2
700a2ef6: 910a         	str	r1, [sp, #0x28]
;     trailBytes = (uint8_t) (rxPayloadSize - (numWords * 4U));
700a2ef8: 990b         	ldr	r1, [sp, #0x2c]
700a2efa: 9a0a         	ldr	r2, [sp, #0x28]
700a2efc: eba1 0182    	sub.w	r1, r1, r2, lsl #2
700a2f00: f88d 1023    	strb.w	r1, [sp, #0x23]
;     for (i = 0; i < numWords; i++)
700a2f04: 9009         	str	r0, [sp, #0x24]
700a2f06: e7ff         	b	0x700a2f08 <Sciclient_recvMessage+0x28> @ imm = #-0x2
700a2f08: 9809         	ldr	r0, [sp, #0x24]
700a2f0a: 990a         	ldr	r1, [sp, #0x28]
700a2f0c: 4288         	cmp	r0, r1
700a2f0e: d22c         	bhs	0x700a2f6a <Sciclient_recvMessage+0x8a> @ imm = #0x58
700a2f10: e7ff         	b	0x700a2f12 <Sciclient_recvMessage+0x32> @ imm = #-0x2
;             rxThread,
700a2f12: 980d         	ldr	r0, [sp, #0x34]
;             ((uint8_t) i +
700a2f14: 9909         	ldr	r1, [sp, #0x24]
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a2f16: f642 2254    	movw	r2, #0x2a54
700a2f1a: f2c7 020b    	movt	r2, #0x700b
700a2f1e: 7812         	ldrb	r2, [r2]
;             ((uint8_t) i +
700a2f20: 4411         	add	r1, r2
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a2f22: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a2f24: b2c9         	uxtb	r1, r1
700a2f26: f00b fccb    	bl	0x700ae8c0 <Sciclient_secProxyReadThread32> @ imm = #0xb996
700a2f2a: 9007         	str	r0, [sp, #0x1c]
700a2f2c: a807         	add	r0, sp, #0x1c
;         uint8_t * tempWordPtr = (uint8_t*) & tempWord;
700a2f2e: 9006         	str	r0, [sp, #0x18]
700a2f30: 2000         	movs	r0, #0x0
;         uint32_t j = 0U;
700a2f32: 9005         	str	r0, [sp, #0x14]
;         for (j = 0U; j < 4U; j++)
700a2f34: 9005         	str	r0, [sp, #0x14]
700a2f36: e7ff         	b	0x700a2f38 <Sciclient_recvMessage+0x58> @ imm = #-0x2
700a2f38: 9805         	ldr	r0, [sp, #0x14]
700a2f3a: 2803         	cmp	r0, #0x3
700a2f3c: d810         	bhi	0x700a2f60 <Sciclient_recvMessage+0x80> @ imm = #0x20
700a2f3e: e7ff         	b	0x700a2f40 <Sciclient_recvMessage+0x60> @ imm = #-0x2
;             *(pLocalRespPayload + i * 4 + j) = *tempWordPtr;
700a2f40: 9806         	ldr	r0, [sp, #0x18]
700a2f42: 7800         	ldrb	r0, [r0]
700a2f44: 990c         	ldr	r1, [sp, #0x30]
700a2f46: 9a09         	ldr	r2, [sp, #0x24]
700a2f48: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2f4c: 9a05         	ldr	r2, [sp, #0x14]
700a2f4e: 5488         	strb	r0, [r1, r2]
;             tempWordPtr++;
700a2f50: 9806         	ldr	r0, [sp, #0x18]
700a2f52: 3001         	adds	r0, #0x1
700a2f54: 9006         	str	r0, [sp, #0x18]
;         }
700a2f56: e7ff         	b	0x700a2f58 <Sciclient_recvMessage+0x78> @ imm = #-0x2
;         for (j = 0U; j < 4U; j++)
700a2f58: 9805         	ldr	r0, [sp, #0x14]
700a2f5a: 3001         	adds	r0, #0x1
700a2f5c: 9005         	str	r0, [sp, #0x14]
700a2f5e: e7eb         	b	0x700a2f38 <Sciclient_recvMessage+0x58> @ imm = #-0x2a
;     }
700a2f60: e7ff         	b	0x700a2f62 <Sciclient_recvMessage+0x82> @ imm = #-0x2
;     for (i = 0; i < numWords; i++)
700a2f62: 9809         	ldr	r0, [sp, #0x24]
700a2f64: 3001         	adds	r0, #0x1
700a2f66: 9009         	str	r0, [sp, #0x24]
700a2f68: e7ce         	b	0x700a2f08 <Sciclient_recvMessage+0x28> @ imm = #-0x64
;     if (trailBytes > 0U)
700a2f6a: f89d 0023    	ldrb.w	r0, [sp, #0x23]
700a2f6e: b368         	cbz	r0, 0x700a2fcc <Sciclient_recvMessage+0xec> @ imm = #0x5a
700a2f70: e7ff         	b	0x700a2f72 <Sciclient_recvMessage+0x92> @ imm = #-0x2
;                 rxThread,
700a2f72: 980d         	ldr	r0, [sp, #0x34]
;                 ((uint8_t)i +
700a2f74: 9909         	ldr	r1, [sp, #0x24]
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a2f76: f642 2254    	movw	r2, #0x2a54
700a2f7a: f2c7 020b    	movt	r2, #0x700b
700a2f7e: 7812         	ldrb	r2, [r2]
;                 ((uint8_t)i +
700a2f80: 4411         	add	r1, r2
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a2f82: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a2f84: b2c9         	uxtb	r1, r1
700a2f86: f00b fc9b    	bl	0x700ae8c0 <Sciclient_secProxyReadThread32> @ imm = #0xb936
700a2f8a: 9004         	str	r0, [sp, #0x10]
700a2f8c: a804         	add	r0, sp, #0x10
;         uint8_t * pTempWord = (uint8_t*) &tempWord;
700a2f8e: 9003         	str	r0, [sp, #0xc]
700a2f90: 2000         	movs	r0, #0x0
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a2f92: 9002         	str	r0, [sp, #0x8]
700a2f94: e7ff         	b	0x700a2f96 <Sciclient_recvMessage+0xb6> @ imm = #-0x2
700a2f96: 9802         	ldr	r0, [sp, #0x8]
700a2f98: f89d 1023    	ldrb.w	r1, [sp, #0x23]
700a2f9c: 4288         	cmp	r0, r1
700a2f9e: d214         	bhs	0x700a2fca <Sciclient_recvMessage+0xea> @ imm = #0x28
700a2fa0: e7ff         	b	0x700a2fa2 <Sciclient_recvMessage+0xc2> @ imm = #-0x2
;             uint8_t * address = (uint8_t*)pLocalRespPayload;
700a2fa2: 980c         	ldr	r0, [sp, #0x30]
700a2fa4: 9001         	str	r0, [sp, #0x4]
;             uint8_t value = *(uint8_t*)(pTempWord + bytes);
700a2fa6: 9803         	ldr	r0, [sp, #0xc]
700a2fa8: 9902         	ldr	r1, [sp, #0x8]
700a2faa: 5c40         	ldrb	r0, [r0, r1]
700a2fac: f88d 0003    	strb.w	r0, [sp, #0x3]
;             *(uint8_t*)(address + i*4 + bytes) = value;
700a2fb0: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a2fb4: 9901         	ldr	r1, [sp, #0x4]
700a2fb6: 9a09         	ldr	r2, [sp, #0x24]
700a2fb8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2fbc: 9a02         	ldr	r2, [sp, #0x8]
700a2fbe: 5488         	strb	r0, [r1, r2]
;         }
700a2fc0: e7ff         	b	0x700a2fc2 <Sciclient_recvMessage+0xe2> @ imm = #-0x2
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a2fc2: 9802         	ldr	r0, [sp, #0x8]
700a2fc4: 3001         	adds	r0, #0x1
700a2fc6: 9002         	str	r0, [sp, #0x8]
700a2fc8: e7e5         	b	0x700a2f96 <Sciclient_recvMessage+0xb6> @ imm = #-0x36
;     }
700a2fca: e7ff         	b	0x700a2fcc <Sciclient_recvMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a2fcc: f642 2054    	movw	r0, #0x2a54
700a2fd0: f2c7 000b    	movt	r0, #0x700b
700a2fd4: 7801         	ldrb	r1, [r0]
;         rxPayloadSize) <=
700a2fd6: 980b         	ldr	r0, [sp, #0x2c]
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a2fd8: eb00 0081    	add.w	r0, r0, r1, lsl #2
;         (SCICLIENT_HEADER_SIZE_IN_WORDS*4U) +
700a2fdc: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a2fde: f642 1148    	movw	r1, #0x2948
700a2fe2: f2c7 010b    	movt	r1, #0x700b
700a2fe6: 6949         	ldr	r1, [r1, #0x14]
700a2fe8: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a2fea: 4288         	cmp	r0, r1
700a2fec: d80e         	bhi	0x700a300c <Sciclient_recvMessage+0x12c> @ imm = #0x1c
700a2fee: e7ff         	b	0x700a2ff0 <Sciclient_recvMessage+0x110> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a2ff0: 980d         	ldr	r0, [sp, #0x34]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a2ff2: f642 1148    	movw	r1, #0x2948
700a2ff6: f2c7 010b    	movt	r1, #0x700b
700a2ffa: 694a         	ldr	r2, [r1, #0x14]
700a2ffc: f04f 31ff    	mov.w	r1, #0xffffffff
700a3000: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a3004: b2c9         	uxtb	r1, r1
700a3006: f00b fc5b    	bl	0x700ae8c0 <Sciclient_secProxyReadThread32> @ imm = #0xb8b6
;     }
700a300a: e7ff         	b	0x700a300c <Sciclient_recvMessage+0x12c> @ imm = #-0x2
; }
700a300c: b00e         	add	sp, #0x38
700a300e: bd80         	pop	{r7, pc}

700a3010 <Udma_rmAllocIrIntr>:
; {
700a3010: b580         	push	{r7, lr}
700a3012: b088         	sub	sp, #0x20
700a3014: 9007         	str	r0, [sp, #0x1c]
700a3016: 9106         	str	r1, [sp, #0x18]
700a3018: 2000         	movs	r0, #0x0
700a301a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            irIntrNum = UDMA_INTR_INVALID;
700a301e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3020: 9806         	ldr	r0, [sp, #0x18]
700a3022: f500 70ea    	add.w	r0, r0, #0x1d4
700a3026: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3028: 9806         	ldr	r0, [sp, #0x18]
700a302a: f500 609f    	add.w	r0, r0, #0x4f8
700a302e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3032: f007 faf5    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x75ea
;     if(UDMA_CORE_INTR_ANY == preferredIrIntrNum)
700a3036: 9807         	ldr	r0, [sp, #0x1c]
700a3038: 2101         	movs	r1, #0x1
700a303a: f6cf 71ff    	movt	r1, #0xffff
700a303e: 4288         	cmp	r0, r1
700a3040: d138         	bne	0x700a30b4 <Udma_rmAllocIrIntr+0xa4> @ imm = #0x70
700a3042: e7ff         	b	0x700a3044 <Udma_rmAllocIrIntr+0x34> @ imm = #-0x2
700a3044: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a3046: 9005         	str	r0, [sp, #0x14]
700a3048: e7ff         	b	0x700a304a <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x2
700a304a: 9805         	ldr	r0, [sp, #0x14]
700a304c: 9900         	ldr	r1, [sp]
700a304e: f8d1 10ec    	ldr.w	r1, [r1, #0xec]
700a3052: 4288         	cmp	r0, r1
700a3054: d22d         	bhs	0x700a30b2 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x5a
700a3056: e7ff         	b	0x700a3058 <Udma_rmAllocIrIntr+0x48> @ imm = #-0x2
;             offset = i >> 5U;
700a3058: 9805         	ldr	r0, [sp, #0x14]
700a305a: 0940         	lsrs	r0, r0, #0x5
700a305c: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a305e: 9805         	ldr	r0, [sp, #0x14]
700a3060: 9904         	ldr	r1, [sp, #0x10]
700a3062: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3066: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3068: 9903         	ldr	r1, [sp, #0xc]
700a306a: 2001         	movs	r0, #0x1
700a306c: 4088         	lsls	r0, r1
700a306e: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a3070: 9806         	ldr	r0, [sp, #0x18]
700a3072: 9904         	ldr	r1, [sp, #0x10]
700a3074: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3078: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a307c: 9902         	ldr	r1, [sp, #0x8]
700a307e: 4008         	ands	r0, r1
700a3080: 4288         	cmp	r0, r1
700a3082: d111         	bne	0x700a30a8 <Udma_rmAllocIrIntr+0x98> @ imm = #0x22
700a3084: e7ff         	b	0x700a3086 <Udma_rmAllocIrIntr+0x76> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a3086: 9a02         	ldr	r2, [sp, #0x8]
700a3088: 9806         	ldr	r0, [sp, #0x18]
700a308a: 9904         	ldr	r1, [sp, #0x10]
700a308c: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3090: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a3094: 4390         	bics	r0, r2
700a3096: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = i + rmInitPrms->startIrIntr;    /* Add start offset */
700a309a: 9805         	ldr	r0, [sp, #0x14]
700a309c: 9900         	ldr	r1, [sp]
700a309e: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a30a2: 4408         	add	r0, r1
700a30a4: 9001         	str	r0, [sp, #0x4]
;                 break;
700a30a6: e004         	b	0x700a30b2 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x8
;         }
700a30a8: e7ff         	b	0x700a30aa <Udma_rmAllocIrIntr+0x9a> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a30aa: 9805         	ldr	r0, [sp, #0x14]
700a30ac: 3001         	adds	r0, #0x1
700a30ae: 9005         	str	r0, [sp, #0x14]
700a30b0: e7cb         	b	0x700a304a <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x6a
;     }
700a30b2: e03c         	b	0x700a312e <Udma_rmAllocIrIntr+0x11e> @ imm = #0x78
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a30b4: 9807         	ldr	r0, [sp, #0x1c]
700a30b6: 9900         	ldr	r1, [sp]
700a30b8: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a30bc: 4288         	cmp	r0, r1
700a30be: d335         	blo	0x700a312c <Udma_rmAllocIrIntr+0x11c> @ imm = #0x6a
700a30c0: e7ff         	b	0x700a30c2 <Udma_rmAllocIrIntr+0xb2> @ imm = #-0x2
;            (preferredIrIntrNum < (rmInitPrms->startIrIntr + rmInitPrms->numIrIntr)))
700a30c2: 9807         	ldr	r0, [sp, #0x1c]
700a30c4: 9a00         	ldr	r2, [sp]
700a30c6: f8d2 10e8    	ldr.w	r1, [r2, #0xe8]
700a30ca: f8d2 20ec    	ldr.w	r2, [r2, #0xec]
700a30ce: 4411         	add	r1, r2
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a30d0: 4288         	cmp	r0, r1
700a30d2: d22b         	bhs	0x700a312c <Udma_rmAllocIrIntr+0x11c> @ imm = #0x56
700a30d4: e7ff         	b	0x700a30d6 <Udma_rmAllocIrIntr+0xc6> @ imm = #-0x2
;             i = preferredIrIntrNum - rmInitPrms->startIrIntr;
700a30d6: 9807         	ldr	r0, [sp, #0x1c]
700a30d8: 9900         	ldr	r1, [sp]
700a30da: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a30de: 1a40         	subs	r0, r0, r1
700a30e0: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a30e2: 9805         	ldr	r0, [sp, #0x14]
700a30e4: 0940         	lsrs	r0, r0, #0x5
700a30e6: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a30e8: 9805         	ldr	r0, [sp, #0x14]
700a30ea: 9904         	ldr	r1, [sp, #0x10]
700a30ec: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a30f0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a30f2: 9903         	ldr	r1, [sp, #0xc]
700a30f4: 2001         	movs	r0, #0x1
700a30f6: 4088         	lsls	r0, r1
700a30f8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a30fa: 9806         	ldr	r0, [sp, #0x18]
700a30fc: 9904         	ldr	r1, [sp, #0x10]
700a30fe: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3102: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a3106: 9902         	ldr	r1, [sp, #0x8]
700a3108: 4008         	ands	r0, r1
700a310a: 4288         	cmp	r0, r1
700a310c: d10d         	bne	0x700a312a <Udma_rmAllocIrIntr+0x11a> @ imm = #0x1a
700a310e: e7ff         	b	0x700a3110 <Udma_rmAllocIrIntr+0x100> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a3110: 9a02         	ldr	r2, [sp, #0x8]
700a3112: 9806         	ldr	r0, [sp, #0x18]
700a3114: 9904         	ldr	r1, [sp, #0x10]
700a3116: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a311a: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a311e: 4390         	bics	r0, r2
700a3120: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = preferredIrIntrNum;
700a3124: 9807         	ldr	r0, [sp, #0x1c]
700a3126: 9001         	str	r0, [sp, #0x4]
;             }
700a3128: e7ff         	b	0x700a312a <Udma_rmAllocIrIntr+0x11a> @ imm = #-0x2
;         }
700a312a: e7ff         	b	0x700a312c <Udma_rmAllocIrIntr+0x11c> @ imm = #-0x2
700a312c: e7ff         	b	0x700a312e <Udma_rmAllocIrIntr+0x11e> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a312e: 9806         	ldr	r0, [sp, #0x18]
700a3130: f500 609f    	add.w	r0, r0, #0x4f8
700a3134: f008 fe3c    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x8c78
;     return (irIntrNum);
700a3138: 9801         	ldr	r0, [sp, #0x4]
700a313a: b008         	add	sp, #0x20
700a313c: bd80         	pop	{r7, pc}
700a313e: 0000         	movs	r0, r0

700a3140 <xQueueGenericSend>:
; {
700a3140: b580         	push	{r7, lr}
700a3142: b08a         	sub	sp, #0x28
700a3144: 9008         	str	r0, [sp, #0x20]
700a3146: 9107         	str	r1, [sp, #0x1c]
700a3148: 9206         	str	r2, [sp, #0x18]
700a314a: 9305         	str	r3, [sp, #0x14]
700a314c: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
700a314e: 9004         	str	r0, [sp, #0x10]
;     Queue_t * const pxQueue = xQueue;
700a3150: 9808         	ldr	r0, [sp, #0x20]
700a3152: 9000         	str	r0, [sp]
;     for( ; ; )
700a3154: e7ff         	b	0x700a3156 <xQueueGenericSend+0x16> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a3156: f00b fab3    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0xb566
;             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a315a: 9800         	ldr	r0, [sp]
700a315c: 6b80         	ldr	r0, [r0, #0x38]
700a315e: 9900         	ldr	r1, [sp]
700a3160: 6bc9         	ldr	r1, [r1, #0x3c]
700a3162: 4288         	cmp	r0, r1
700a3164: d304         	blo	0x700a3170 <xQueueGenericSend+0x30> @ imm = #0x8
700a3166: e7ff         	b	0x700a3168 <xQueueGenericSend+0x28> @ imm = #-0x2
700a3168: 9805         	ldr	r0, [sp, #0x14]
700a316a: 2802         	cmp	r0, #0x2
700a316c: d120         	bne	0x700a31b0 <xQueueGenericSend+0x70> @ imm = #0x40
700a316e: e7ff         	b	0x700a3170 <xQueueGenericSend+0x30> @ imm = #-0x2
;                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a3170: 9800         	ldr	r0, [sp]
700a3172: 9907         	ldr	r1, [sp, #0x1c]
700a3174: 9a05         	ldr	r2, [sp, #0x14]
700a3176: f003 fc6b    	bl	0x700a6a50 <prvCopyDataToQueue> @ imm = #0x38d6
700a317a: 9003         	str	r0, [sp, #0xc]
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a317c: 9800         	ldr	r0, [sp]
700a317e: 6a40         	ldr	r0, [r0, #0x24]
700a3180: b150         	cbz	r0, 0x700a3198 <xQueueGenericSend+0x58> @ imm = #0x14
700a3182: e7ff         	b	0x700a3184 <xQueueGenericSend+0x44> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a3184: 9800         	ldr	r0, [sp]
700a3186: 3024         	adds	r0, #0x24
700a3188: f004 fbe2    	bl	0x700a7950 <xTaskRemoveFromEventList> @ imm = #0x47c4
700a318c: b110         	cbz	r0, 0x700a3194 <xQueueGenericSend+0x54> @ imm = #0x4
700a318e: e7ff         	b	0x700a3190 <xQueueGenericSend+0x50> @ imm = #-0x2
;                                 queueYIELD_IF_USING_PREEMPTION();
700a3190: df00         	svc	#0x0
;                             }
700a3192: e000         	b	0x700a3196 <xQueueGenericSend+0x56> @ imm = #0x0
700a3194: e7ff         	b	0x700a3196 <xQueueGenericSend+0x56> @ imm = #-0x2
;                         }
700a3196: e006         	b	0x700a31a6 <xQueueGenericSend+0x66> @ imm = #0xc
;                         else if( xYieldRequired != pdFALSE )
700a3198: 9803         	ldr	r0, [sp, #0xc]
700a319a: b110         	cbz	r0, 0x700a31a2 <xQueueGenericSend+0x62> @ imm = #0x4
700a319c: e7ff         	b	0x700a319e <xQueueGenericSend+0x5e> @ imm = #-0x2
;                             queueYIELD_IF_USING_PREEMPTION();
700a319e: df00         	svc	#0x0
;                         }
700a31a0: e000         	b	0x700a31a4 <xQueueGenericSend+0x64> @ imm = #0x0
700a31a2: e7ff         	b	0x700a31a4 <xQueueGenericSend+0x64> @ imm = #-0x2
700a31a4: e7ff         	b	0x700a31a6 <xQueueGenericSend+0x66> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a31a6: f00a fb2b    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xa656
700a31aa: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a31ac: 9009         	str	r0, [sp, #0x24]
700a31ae: e05b         	b	0x700a3268 <xQueueGenericSend+0x128> @ imm = #0xb6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a31b0: 9806         	ldr	r0, [sp, #0x18]
700a31b2: b928         	cbnz	r0, 0x700a31c0 <xQueueGenericSend+0x80> @ imm = #0xa
700a31b4: e7ff         	b	0x700a31b6 <xQueueGenericSend+0x76> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a31b6: f00a fb23    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xa646
700a31ba: 2000         	movs	r0, #0x0
;                     return errQUEUE_FULL;
700a31bc: 9009         	str	r0, [sp, #0x24]
700a31be: e053         	b	0x700a3268 <xQueueGenericSend+0x128> @ imm = #0xa6
;                 else if( xEntryTimeSet == pdFALSE )
700a31c0: 9804         	ldr	r0, [sp, #0x10]
700a31c2: b930         	cbnz	r0, 0x700a31d2 <xQueueGenericSend+0x92> @ imm = #0xc
700a31c4: e7ff         	b	0x700a31c6 <xQueueGenericSend+0x86> @ imm = #-0x2
700a31c6: a801         	add	r0, sp, #0x4
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a31c8: f00b fff2    	bl	0x700af1b0 <vTaskInternalSetTimeOutState> @ imm = #0xbfe4
700a31cc: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a31ce: 9004         	str	r0, [sp, #0x10]
;                 }
700a31d0: e000         	b	0x700a31d4 <xQueueGenericSend+0x94> @ imm = #0x0
700a31d2: e7ff         	b	0x700a31d4 <xQueueGenericSend+0x94> @ imm = #-0x2
700a31d4: e7ff         	b	0x700a31d6 <xQueueGenericSend+0x96> @ imm = #-0x2
700a31d6: e7ff         	b	0x700a31d8 <xQueueGenericSend+0x98> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a31d8: f00a fb12    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xa624
;         vTaskSuspendAll();
700a31dc: f00c fcd0    	bl	0x700afb80 <vTaskSuspendAll> @ imm = #0xc9a0
;         prvLockQueue( pxQueue );
700a31e0: f00b fa6e    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0xb4dc
700a31e4: 9800         	ldr	r0, [sp]
700a31e6: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a31ea: 3001         	adds	r0, #0x1
700a31ec: b928         	cbnz	r0, 0x700a31fa <xQueueGenericSend+0xba> @ imm = #0xa
700a31ee: e7ff         	b	0x700a31f0 <xQueueGenericSend+0xb0> @ imm = #-0x2
700a31f0: 9900         	ldr	r1, [sp]
700a31f2: 2000         	movs	r0, #0x0
700a31f4: f881 0044    	strb.w	r0, [r1, #0x44]
700a31f8: e7ff         	b	0x700a31fa <xQueueGenericSend+0xba> @ imm = #-0x2
700a31fa: 9800         	ldr	r0, [sp]
700a31fc: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a3200: 3001         	adds	r0, #0x1
700a3202: b928         	cbnz	r0, 0x700a3210 <xQueueGenericSend+0xd0> @ imm = #0xa
700a3204: e7ff         	b	0x700a3206 <xQueueGenericSend+0xc6> @ imm = #-0x2
700a3206: 9900         	ldr	r1, [sp]
700a3208: 2000         	movs	r0, #0x0
700a320a: f881 0045    	strb.w	r0, [r1, #0x45]
700a320e: e7ff         	b	0x700a3210 <xQueueGenericSend+0xd0> @ imm = #-0x2
700a3210: f00a faf6    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xa5ec
700a3214: a801         	add	r0, sp, #0x4
700a3216: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a3218: f005 ff52    	bl	0x700a90c0 <xTaskCheckForTimeOut> @ imm = #0x5ea4
700a321c: b9d8         	cbnz	r0, 0x700a3256 <xQueueGenericSend+0x116> @ imm = #0x36
700a321e: e7ff         	b	0x700a3220 <xQueueGenericSend+0xe0> @ imm = #-0x2
;             if( prvIsQueueFull( pxQueue ) != pdFALSE )
700a3220: 9800         	ldr	r0, [sp]
700a3222: f00b fb95    	bl	0x700ae950 <prvIsQueueFull> @ imm = #0xb72a
700a3226: b178         	cbz	r0, 0x700a3248 <xQueueGenericSend+0x108> @ imm = #0x1e
700a3228: e7ff         	b	0x700a322a <xQueueGenericSend+0xea> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
700a322a: 9800         	ldr	r0, [sp]
700a322c: 3010         	adds	r0, #0x10
700a322e: 9906         	ldr	r1, [sp, #0x18]
700a3230: f00b febe    	bl	0x700aefb0 <vTaskPlaceOnEventList> @ imm = #0xbd7c
;                 prvUnlockQueue( pxQueue );
700a3234: 9800         	ldr	r0, [sp]
700a3236: f004 fd53    	bl	0x700a7ce0 <prvUnlockQueue> @ imm = #0x4aa6
;                 if( xTaskResumeAll() == pdFALSE )
700a323a: f7fe ff51    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0x115e
700a323e: b910         	cbnz	r0, 0x700a3246 <xQueueGenericSend+0x106> @ imm = #0x4
700a3240: e7ff         	b	0x700a3242 <xQueueGenericSend+0x102> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a3242: df00         	svc	#0x0
;                 }
700a3244: e7ff         	b	0x700a3246 <xQueueGenericSend+0x106> @ imm = #-0x2
;             }
700a3246: e005         	b	0x700a3254 <xQueueGenericSend+0x114> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a3248: 9800         	ldr	r0, [sp]
700a324a: f004 fd49    	bl	0x700a7ce0 <prvUnlockQueue> @ imm = #0x4a92
;                 ( void ) xTaskResumeAll();
700a324e: f7fe ff47    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0x1172
700a3252: e7ff         	b	0x700a3254 <xQueueGenericSend+0x114> @ imm = #-0x2
;         }
700a3254: e007         	b	0x700a3266 <xQueueGenericSend+0x126> @ imm = #0xe
;             prvUnlockQueue( pxQueue );
700a3256: 9800         	ldr	r0, [sp]
700a3258: f004 fd42    	bl	0x700a7ce0 <prvUnlockQueue> @ imm = #0x4a84
;             ( void ) xTaskResumeAll();
700a325c: f7fe ff40    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0x1180
700a3260: 2000         	movs	r0, #0x0
;             return errQUEUE_FULL;
700a3262: 9009         	str	r0, [sp, #0x24]
700a3264: e000         	b	0x700a3268 <xQueueGenericSend+0x128> @ imm = #0x0
;     for( ; ; )
700a3266: e776         	b	0x700a3156 <xQueueGenericSend+0x16> @ imm = #-0x114
; }
700a3268: 9809         	ldr	r0, [sp, #0x24]
700a326a: b00a         	add	sp, #0x28
700a326c: bd80         	pop	{r7, pc}
700a326e: 0000         	movs	r0, r0

700a3270 <UART_lld_init>:
; {
700a3270: b580         	push	{r7, lr}
700a3272: b084         	sub	sp, #0x10
700a3274: 9003         	str	r0, [sp, #0xc]
700a3276: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a3278: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a327a: 9803         	ldr	r0, [sp, #0xc]
700a327c: b168         	cbz	r0, 0x700a329a <UART_lld_init+0x2a> @ imm = #0x1a
700a327e: e7ff         	b	0x700a3280 <UART_lld_init+0x10> @ imm = #-0x2
700a3280: 9803         	ldr	r0, [sp, #0xc]
700a3282: 6840         	ldr	r0, [r0, #0x4]
700a3284: b148         	cbz	r0, 0x700a329a <UART_lld_init+0x2a> @ imm = #0x12
700a3286: e7ff         	b	0x700a3288 <UART_lld_init+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a3288: 9803         	ldr	r0, [sp, #0xc]
700a328a: 6d40         	ldr	r0, [r0, #0x54]
700a328c: b120         	cbz	r0, 0x700a3298 <UART_lld_init+0x28> @ imm = #0x8
700a328e: e7ff         	b	0x700a3290 <UART_lld_init+0x20> @ imm = #-0x2
700a3290: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a3294: 9002         	str	r0, [sp, #0x8]
;         }
700a3296: e7ff         	b	0x700a3298 <UART_lld_init+0x28> @ imm = #-0x2
;     }
700a3298: e003         	b	0x700a32a2 <UART_lld_init+0x32> @ imm = #0x6
700a329a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a329e: 9002         	str	r0, [sp, #0x8]
700a32a0: e7ff         	b	0x700a32a2 <UART_lld_init+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a32a2: 9802         	ldr	r0, [sp, #0x8]
700a32a4: 2800         	cmp	r0, #0x0
700a32a6: d176         	bne	0x700a3396 <UART_lld_init+0x126> @ imm = #0xec
700a32a8: e7ff         	b	0x700a32aa <UART_lld_init+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a32aa: 9903         	ldr	r1, [sp, #0xc]
700a32ac: 2002         	movs	r0, #0x2
700a32ae: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a32b0: 9803         	ldr	r0, [sp, #0xc]
700a32b2: 6840         	ldr	r0, [r0, #0x4]
700a32b4: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a32b6: 9801         	ldr	r0, [sp, #0x4]
700a32b8: 6d82         	ldr	r2, [r0, #0x58]
700a32ba: f244 2040    	movw	r0, #0x4240
700a32be: f2c0 000f    	movt	r0, #0xf
700a32c2: 2100         	movs	r1, #0x0
700a32c4: 9100         	str	r1, [sp]
700a32c6: 4790         	blx	r2
700a32c8: 9a00         	ldr	r2, [sp]
700a32ca: 9903         	ldr	r1, [sp, #0xc]
700a32cc: 66ca         	str	r2, [r1, #0x6c]
700a32ce: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a32d0: 9803         	ldr	r0, [sp, #0xc]
700a32d2: 6800         	ldr	r0, [r0]
700a32d4: f005 f9d4    	bl	0x700a8680 <UART_IsBaseAddrValid> @ imm = #0x53a8
700a32d8: 4601         	mov	r1, r0
700a32da: 9802         	ldr	r0, [sp, #0x8]
700a32dc: 4408         	add	r0, r1
700a32de: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a32e0: 9801         	ldr	r0, [sp, #0x4]
700a32e2: 6800         	ldr	r0, [r0]
700a32e4: f00c f91c    	bl	0x700af520 <UART_IsParameter> @ imm = #0xc238
700a32e8: 4601         	mov	r1, r0
700a32ea: 9802         	ldr	r0, [sp, #0x8]
700a32ec: 4408         	add	r0, r1
700a32ee: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a32f0: 9801         	ldr	r0, [sp, #0x4]
700a32f2: 6840         	ldr	r0, [r0, #0x4]
700a32f4: f00c f914    	bl	0x700af520 <UART_IsParameter> @ imm = #0xc228
700a32f8: 4601         	mov	r1, r0
700a32fa: 9802         	ldr	r0, [sp, #0x8]
700a32fc: 4408         	add	r0, r1
700a32fe: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a3300: 9801         	ldr	r0, [sp, #0x4]
700a3302: 6880         	ldr	r0, [r0, #0x8]
700a3304: f00b f8e4    	bl	0x700ae4d0 <UART_IsDataLengthValid> @ imm = #0xb1c8
700a3308: 4601         	mov	r1, r0
700a330a: 9802         	ldr	r0, [sp, #0x8]
700a330c: 4408         	add	r0, r1
700a330e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a3310: 9801         	ldr	r0, [sp, #0x4]
700a3312: 68c0         	ldr	r0, [r0, #0xc]
700a3314: f00b ff0c    	bl	0x700af130 <UART_IsStopBitsValid> @ imm = #0xbe18
700a3318: 4601         	mov	r1, r0
700a331a: 9802         	ldr	r0, [sp, #0x8]
700a331c: 4408         	add	r0, r1
700a331e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a3320: 9801         	ldr	r0, [sp, #0x4]
700a3322: 6900         	ldr	r0, [r0, #0x10]
700a3324: f00a fe14    	bl	0x700adf50 <UART_IsParityTypeValid> @ imm = #0xac28
700a3328: 4601         	mov	r1, r0
700a332a: 9802         	ldr	r0, [sp, #0x8]
700a332c: 4408         	add	r0, r1
700a332e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a3330: 9801         	ldr	r0, [sp, #0x4]
700a3332: 69c0         	ldr	r0, [r0, #0x1c]
700a3334: f00a fccc    	bl	0x700adcd0 <UART_IsHWFlowCtrlValid> @ imm = #0xa998
700a3338: 4601         	mov	r1, r0
700a333a: 9802         	ldr	r0, [sp, #0x8]
700a333c: 4408         	add	r0, r1
700a333e: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a3340: 9801         	ldr	r0, [sp, #0x4]
700a3342: 6ac0         	ldr	r0, [r0, #0x2c]
700a3344: f009 fcfc    	bl	0x700acd40 <UART_OperModeValid> @ imm = #0x99f8
700a3348: 4601         	mov	r1, r0
700a334a: 9802         	ldr	r0, [sp, #0x8]
700a334c: 4408         	add	r0, r1
700a334e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a3350: 9801         	ldr	r0, [sp, #0x4]
700a3352: 6b80         	ldr	r0, [r0, #0x38]
700a3354: f00a fcdc    	bl	0x700add10 <UART_IsRxTrigLvlValid> @ imm = #0xa9b8
700a3358: 4601         	mov	r1, r0
700a335a: 9802         	ldr	r0, [sp, #0x8]
700a335c: 4408         	add	r0, r1
700a335e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a3360: 9801         	ldr	r0, [sp, #0x4]
700a3362: 6bc0         	ldr	r0, [r0, #0x3c]
700a3364: f00a fcf4    	bl	0x700add50 <UART_IsTxTrigLvlValid> @ imm = #0xa9e8
700a3368: 4601         	mov	r1, r0
700a336a: 9802         	ldr	r0, [sp, #0x8]
700a336c: 4408         	add	r0, r1
700a336e: 9002         	str	r0, [sp, #0x8]
;         if(UART_STATUS_SUCCESS == status)
700a3370: 9802         	ldr	r0, [sp, #0x8]
700a3372: b938         	cbnz	r0, 0x700a3384 <UART_lld_init+0x114> @ imm = #0xe
700a3374: e7ff         	b	0x700a3376 <UART_lld_init+0x106> @ imm = #-0x2
;             UART_configInstance(hUart);
700a3376: 9803         	ldr	r0, [sp, #0xc]
700a3378: f002 f882    	bl	0x700a5480 <UART_configInstance> @ imm = #0x2104
;             hUart->state = UART_STATE_READY;
700a337c: 9903         	ldr	r1, [sp, #0xc]
700a337e: 2001         	movs	r0, #0x1
700a3380: 6548         	str	r0, [r1, #0x54]
;         }
700a3382: e007         	b	0x700a3394 <UART_lld_init+0x124> @ imm = #0xe
;             status += UART_lld_deInit(hUart);
700a3384: 9803         	ldr	r0, [sp, #0xc]
700a3386: f009 f89b    	bl	0x700ac4c0 <UART_lld_deInit> @ imm = #0x9136
700a338a: 4601         	mov	r1, r0
700a338c: 9802         	ldr	r0, [sp, #0x8]
700a338e: 4408         	add	r0, r1
700a3390: 9002         	str	r0, [sp, #0x8]
700a3392: e7ff         	b	0x700a3394 <UART_lld_init+0x124> @ imm = #-0x2
;     }
700a3394: e7ff         	b	0x700a3396 <UART_lld_init+0x126> @ imm = #-0x2
;     return status;
700a3396: 9802         	ldr	r0, [sp, #0x8]
700a3398: b004         	add	sp, #0x10
700a339a: bd80         	pop	{r7, pc}
700a339c: 0000         	movs	r0, r0
700a339e: 0000         	movs	r0, r0

700a33a0 <Sciclient_pmQueryModuleClkFreq>:
; {
700a33a0: b580         	push	{r7, lr}
700a33a2: b09e         	sub	sp, #0x78
700a33a4: f8dd c084    	ldr.w	r12, [sp, #0x84]
700a33a8: f8dd c080    	ldr.w	r12, [sp, #0x80]
700a33ac: 901d         	str	r0, [sp, #0x74]
700a33ae: 911c         	str	r1, [sp, #0x70]
700a33b0: 931b         	str	r3, [sp, #0x6c]
700a33b2: 921a         	str	r2, [sp, #0x68]
700a33b4: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a33b6: 9019         	str	r0, [sp, #0x64]
;     request.device         = (uint32_t) moduleId;
700a33b8: 981d         	ldr	r0, [sp, #0x74]
700a33ba: 9010         	str	r0, [sp, #0x40]
;     request.min_freq_hz    = (uint64_t) reqFreqHz;
700a33bc: 981a         	ldr	r0, [sp, #0x68]
700a33be: 991b         	ldr	r1, [sp, #0x6c]
700a33c0: 9112         	str	r1, [sp, #0x48]
700a33c2: 9011         	str	r0, [sp, #0x44]
;     request.target_freq_hz = (uint64_t) reqFreqHz;
700a33c4: 981a         	ldr	r0, [sp, #0x68]
700a33c6: 991b         	ldr	r1, [sp, #0x6c]
700a33c8: 9114         	str	r1, [sp, #0x50]
700a33ca: 9013         	str	r0, [sp, #0x4c]
;     request.max_freq_hz    = (uint64_t) reqFreqHz;
700a33cc: 981a         	ldr	r0, [sp, #0x68]
700a33ce: 991b         	ldr	r1, [sp, #0x6c]
700a33d0: 9116         	str	r1, [sp, #0x58]
700a33d2: 9015         	str	r0, [sp, #0x54]
;     if((reqFreqHz%10U) != 0U)
700a33d4: 9b1a         	ldr	r3, [sp, #0x68]
700a33d6: 981b         	ldr	r0, [sp, #0x6c]
700a33d8: f64c 41cd    	movw	r1, #0xcccd
700a33dc: f6cc 41cc    	movt	r1, #0xcccc
700a33e0: fba3 2e01    	umull	r2, lr, r3, r1
700a33e4: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a33e8: fb03 e30c    	mla	r3, r3, r12, lr
700a33ec: fb00 3101    	mla	r1, r0, r1, r3
700a33f0: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a33f4: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a33f8: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a33fc: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a3400: f649 129a    	movw	r2, #0x999a
700a3404: f6c9 1299    	movt	r2, #0x9999
700a3408: 1a89         	subs	r1, r1, r2
700a340a: f649 1199    	movw	r1, #0x9999
700a340e: f6c1 1199    	movt	r1, #0x1999
700a3412: 4188         	sbcs	r0, r1
700a3414: d316         	blo	0x700a3444 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #0x2c
700a3416: e7ff         	b	0x700a3418 <Sciclient_pmQueryModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(reqFreqHz-(reqFreqHz%10U));
700a3418: 981a         	ldr	r0, [sp, #0x68]
700a341a: 9001         	str	r0, [sp, #0x4]
700a341c: 991b         	ldr	r1, [sp, #0x6c]
700a341e: 9100         	str	r1, [sp]
700a3420: 220a         	movs	r2, #0xa
700a3422: 2300         	movs	r3, #0x0
700a3424: f00b ee96    	blx	0x700af154 <__aeabi_uldivmod> @ imm = #0xbd2c
700a3428: 9800         	ldr	r0, [sp]
700a342a: 9901         	ldr	r1, [sp, #0x4]
700a342c: 1a89         	subs	r1, r1, r2
700a342e: 4198         	sbcs	r0, r3
700a3430: 9111         	str	r1, [sp, #0x44]
700a3432: 9012         	str	r0, [sp, #0x48]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a3434: 9911         	ldr	r1, [sp, #0x44]
700a3436: 9812         	ldr	r0, [sp, #0x48]
700a3438: 310a         	adds	r1, #0xa
700a343a: f140 0000    	adc	r0, r0, #0x0
700a343e: 9115         	str	r1, [sp, #0x54]
700a3440: 9016         	str	r0, [sp, #0x58]
;     }
700a3442: e7ff         	b	0x700a3444 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a3444: 981c         	ldr	r0, [sp, #0x70]
700a3446: 28ff         	cmp	r0, #0xff
700a3448: d307         	blo	0x700a345a <Sciclient_pmQueryModuleClkFreq+0xba> @ imm = #0xe
700a344a: e7ff         	b	0x700a344c <Sciclient_pmQueryModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a344c: 981c         	ldr	r0, [sp, #0x70]
700a344e: f8cd 005d    	str.w	r0, [sp, #0x5d]
700a3452: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a3454: f88d 005c    	strb.w	r0, [sp, #0x5c]
;     }
700a3458: e003         	b	0x700a3462 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a345a: 981c         	ldr	r0, [sp, #0x70]
700a345c: f88d 005c    	strb.w	r0, [sp, #0x5c]
700a3460: e7ff         	b	0x700a3462 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #-0x2
700a3462: 2000         	movs	r0, #0x0
;     struct tisci_msg_query_freq_resp response = {{0}};
700a3464: 900d         	str	r0, [sp, #0x34]
700a3466: 900c         	str	r0, [sp, #0x30]
700a3468: 900b         	str	r0, [sp, #0x2c]
700a346a: 900a         	str	r0, [sp, #0x28]
700a346c: f240 110d    	movw	r1, #0x10d
;     reqParam.messageType    = (uint16_t) TISCI_MSG_QUERY_FREQ;
700a3470: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a3474: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a3476: 9106         	str	r1, [sp, #0x18]
700a3478: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a347a: 9107         	str	r1, [sp, #0x1c]
700a347c: 2129         	movs	r1, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a347e: 9108         	str	r1, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a3480: 9921         	ldr	r1, [sp, #0x84]
700a3482: 9109         	str	r1, [sp, #0x24]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a3484: 9002         	str	r0, [sp, #0x8]
700a3486: a80a         	add	r0, sp, #0x28
;     respParam.pRespPayload    = (uint8_t *) &response;
700a3488: 9003         	str	r0, [sp, #0xc]
700a348a: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a348c: 9004         	str	r0, [sp, #0x10]
700a348e: a805         	add	r0, sp, #0x14
700a3490: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a3492: f7f9 fe75    	bl	0x7009d180 <Sciclient_service> @ imm = #-0x6316
700a3496: 9019         	str	r0, [sp, #0x64]
;     if((retVal != SystemP_SUCCESS) ||
700a3498: 9819         	ldr	r0, [sp, #0x64]
700a349a: b930         	cbnz	r0, 0x700a34aa <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #0xc
700a349c: e7ff         	b	0x700a349e <Sciclient_pmQueryModuleClkFreq+0xfe> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a349e: 9802         	ldr	r0, [sp, #0x8]
700a34a0: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a34a4: 2802         	cmp	r0, #0x2
700a34a6: d004         	beq	0x700a34b2 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #0x8
700a34a8: e7ff         	b	0x700a34aa <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #-0x2
700a34aa: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a34ae: 9019         	str	r0, [sp, #0x64]
;     }
700a34b0: e7ff         	b	0x700a34b2 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a34b2: 9819         	ldr	r0, [sp, #0x64]
700a34b4: b930         	cbnz	r0, 0x700a34c4 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #0xc
700a34b6: e7ff         	b	0x700a34b8 <Sciclient_pmQueryModuleClkFreq+0x118> @ imm = #-0x2
;         *respFreqHz = (uint64_t) response.freq_hz;
700a34b8: 980c         	ldr	r0, [sp, #0x30]
700a34ba: 9a0d         	ldr	r2, [sp, #0x34]
700a34bc: 9920         	ldr	r1, [sp, #0x80]
700a34be: 604a         	str	r2, [r1, #0x4]
700a34c0: 6008         	str	r0, [r1]
;     }
700a34c2: e7ff         	b	0x700a34c4 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #-0x2
;     return retVal;
700a34c4: 9819         	ldr	r0, [sp, #0x64]
700a34c6: b01e         	add	sp, #0x78
700a34c8: bd80         	pop	{r7, pc}
700a34ca: 0000         	movs	r0, r0
700a34cc: 0000         	movs	r0, r0
700a34ce: 0000         	movs	r0, r0

700a34d0 <xQueueReceive>:
; {
700a34d0: b580         	push	{r7, lr}
700a34d2: b08a         	sub	sp, #0x28
700a34d4: 9008         	str	r0, [sp, #0x20]
700a34d6: 9107         	str	r1, [sp, #0x1c]
700a34d8: 9206         	str	r2, [sp, #0x18]
700a34da: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
700a34dc: 9005         	str	r0, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a34de: 9808         	ldr	r0, [sp, #0x20]
700a34e0: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
700a34e2: e7ff         	b	0x700a34e4 <xQueueReceive+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a34e4: f00b f8ec    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0xb1d8
;             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a34e8: 9802         	ldr	r0, [sp, #0x8]
700a34ea: 6b80         	ldr	r0, [r0, #0x38]
700a34ec: 9001         	str	r0, [sp, #0x4]
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a34ee: 9801         	ldr	r0, [sp, #0x4]
700a34f0: b1e0         	cbz	r0, 0x700a352c <xQueueReceive+0x5c> @ imm = #0x38
700a34f2: e7ff         	b	0x700a34f4 <xQueueReceive+0x24> @ imm = #-0x2
;                 prvCopyDataFromQueue( pxQueue, pvBuffer );
700a34f4: 9802         	ldr	r0, [sp, #0x8]
700a34f6: 9907         	ldr	r1, [sp, #0x1c]
700a34f8: f00a fac2    	bl	0x700ada80 <prvCopyDataFromQueue> @ imm = #0xa584
;                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a34fc: 9801         	ldr	r0, [sp, #0x4]
700a34fe: 3801         	subs	r0, #0x1
700a3500: 9902         	ldr	r1, [sp, #0x8]
700a3502: 6388         	str	r0, [r1, #0x38]
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a3504: 9802         	ldr	r0, [sp, #0x8]
700a3506: 6900         	ldr	r0, [r0, #0x10]
700a3508: b150         	cbz	r0, 0x700a3520 <xQueueReceive+0x50> @ imm = #0x14
700a350a: e7ff         	b	0x700a350c <xQueueReceive+0x3c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a350c: 9802         	ldr	r0, [sp, #0x8]
700a350e: 3010         	adds	r0, #0x10
700a3510: f004 fa1e    	bl	0x700a7950 <xTaskRemoveFromEventList> @ imm = #0x443c
700a3514: b110         	cbz	r0, 0x700a351c <xQueueReceive+0x4c> @ imm = #0x4
700a3516: e7ff         	b	0x700a3518 <xQueueReceive+0x48> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
700a3518: df00         	svc	#0x0
;                     }
700a351a: e000         	b	0x700a351e <xQueueReceive+0x4e> @ imm = #0x0
700a351c: e7ff         	b	0x700a351e <xQueueReceive+0x4e> @ imm = #-0x2
;                 }
700a351e: e000         	b	0x700a3522 <xQueueReceive+0x52> @ imm = #0x0
700a3520: e7ff         	b	0x700a3522 <xQueueReceive+0x52> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a3522: f00a f96d    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xa2da
700a3526: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a3528: 9009         	str	r0, [sp, #0x24]
700a352a: e063         	b	0x700a35f4 <xQueueReceive+0x124> @ imm = #0xc6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a352c: 9806         	ldr	r0, [sp, #0x18]
700a352e: b928         	cbnz	r0, 0x700a353c <xQueueReceive+0x6c> @ imm = #0xa
700a3530: e7ff         	b	0x700a3532 <xQueueReceive+0x62> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a3532: f00a f965    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xa2ca
700a3536: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
700a3538: 9009         	str	r0, [sp, #0x24]
700a353a: e05b         	b	0x700a35f4 <xQueueReceive+0x124> @ imm = #0xb6
;                 else if( xEntryTimeSet == pdFALSE )
700a353c: 9805         	ldr	r0, [sp, #0x14]
700a353e: b930         	cbnz	r0, 0x700a354e <xQueueReceive+0x7e> @ imm = #0xc
700a3540: e7ff         	b	0x700a3542 <xQueueReceive+0x72> @ imm = #-0x2
700a3542: a803         	add	r0, sp, #0xc
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a3544: f00b fe34    	bl	0x700af1b0 <vTaskInternalSetTimeOutState> @ imm = #0xbc68
700a3548: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a354a: 9005         	str	r0, [sp, #0x14]
;                 }
700a354c: e000         	b	0x700a3550 <xQueueReceive+0x80> @ imm = #0x0
700a354e: e7ff         	b	0x700a3550 <xQueueReceive+0x80> @ imm = #-0x2
700a3550: e7ff         	b	0x700a3552 <xQueueReceive+0x82> @ imm = #-0x2
700a3552: e7ff         	b	0x700a3554 <xQueueReceive+0x84> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a3554: f00a f954    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xa2a8
;         vTaskSuspendAll();
700a3558: f00c fb12    	bl	0x700afb80 <vTaskSuspendAll> @ imm = #0xc624
;         prvLockQueue( pxQueue );
700a355c: f00b f8b0    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0xb160
700a3560: 9802         	ldr	r0, [sp, #0x8]
700a3562: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a3566: 3001         	adds	r0, #0x1
700a3568: b928         	cbnz	r0, 0x700a3576 <xQueueReceive+0xa6> @ imm = #0xa
700a356a: e7ff         	b	0x700a356c <xQueueReceive+0x9c> @ imm = #-0x2
700a356c: 9902         	ldr	r1, [sp, #0x8]
700a356e: 2000         	movs	r0, #0x0
700a3570: f881 0044    	strb.w	r0, [r1, #0x44]
700a3574: e7ff         	b	0x700a3576 <xQueueReceive+0xa6> @ imm = #-0x2
700a3576: 9802         	ldr	r0, [sp, #0x8]
700a3578: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a357c: 3001         	adds	r0, #0x1
700a357e: b928         	cbnz	r0, 0x700a358c <xQueueReceive+0xbc> @ imm = #0xa
700a3580: e7ff         	b	0x700a3582 <xQueueReceive+0xb2> @ imm = #-0x2
700a3582: 9902         	ldr	r1, [sp, #0x8]
700a3584: 2000         	movs	r0, #0x0
700a3586: f881 0045    	strb.w	r0, [r1, #0x45]
700a358a: e7ff         	b	0x700a358c <xQueueReceive+0xbc> @ imm = #-0x2
700a358c: f00a f938    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0xa270
700a3590: a803         	add	r0, sp, #0xc
700a3592: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a3594: f005 fd94    	bl	0x700a90c0 <xTaskCheckForTimeOut> @ imm = #0x5b28
700a3598: b9e0         	cbnz	r0, 0x700a35d4 <xQueueReceive+0x104> @ imm = #0x38
700a359a: e7ff         	b	0x700a359c <xQueueReceive+0xcc> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a359c: 9802         	ldr	r0, [sp, #0x8]
700a359e: f00b fc47    	bl	0x700aee30 <prvIsQueueEmpty> @ imm = #0xb88e
700a35a2: b180         	cbz	r0, 0x700a35c6 <xQueueReceive+0xf6> @ imm = #0x20
700a35a4: e7ff         	b	0x700a35a6 <xQueueReceive+0xd6> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
700a35a6: 9802         	ldr	r0, [sp, #0x8]
700a35a8: 3024         	adds	r0, #0x24
700a35aa: 9906         	ldr	r1, [sp, #0x18]
700a35ac: f00b fd00    	bl	0x700aefb0 <vTaskPlaceOnEventList> @ imm = #0xba00
;                 prvUnlockQueue( pxQueue );
700a35b0: 9802         	ldr	r0, [sp, #0x8]
700a35b2: f004 fb95    	bl	0x700a7ce0 <prvUnlockQueue> @ imm = #0x472a
;                 if( xTaskResumeAll() == pdFALSE )
700a35b6: f7fe fd93    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0x14da
700a35ba: b910         	cbnz	r0, 0x700a35c2 <xQueueReceive+0xf2> @ imm = #0x4
700a35bc: e7ff         	b	0x700a35be <xQueueReceive+0xee> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a35be: df00         	svc	#0x0
;                 }
700a35c0: e000         	b	0x700a35c4 <xQueueReceive+0xf4> @ imm = #0x0
700a35c2: e7ff         	b	0x700a35c4 <xQueueReceive+0xf4> @ imm = #-0x2
;             }
700a35c4: e005         	b	0x700a35d2 <xQueueReceive+0x102> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a35c6: 9802         	ldr	r0, [sp, #0x8]
700a35c8: f004 fb8a    	bl	0x700a7ce0 <prvUnlockQueue> @ imm = #0x4714
;                 ( void ) xTaskResumeAll();
700a35cc: f7fe fd88    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0x14f0
700a35d0: e7ff         	b	0x700a35d2 <xQueueReceive+0x102> @ imm = #-0x2
;         }
700a35d2: e00e         	b	0x700a35f2 <xQueueReceive+0x122> @ imm = #0x1c
;             prvUnlockQueue( pxQueue );
700a35d4: 9802         	ldr	r0, [sp, #0x8]
700a35d6: f004 fb83    	bl	0x700a7ce0 <prvUnlockQueue> @ imm = #0x4706
;             ( void ) xTaskResumeAll();
700a35da: f7fe fd81    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0x14fe
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a35de: 9802         	ldr	r0, [sp, #0x8]
700a35e0: f00b fc26    	bl	0x700aee30 <prvIsQueueEmpty> @ imm = #0xb84c
700a35e4: b118         	cbz	r0, 0x700a35ee <xQueueReceive+0x11e> @ imm = #0x6
700a35e6: e7ff         	b	0x700a35e8 <xQueueReceive+0x118> @ imm = #-0x2
700a35e8: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
700a35ea: 9009         	str	r0, [sp, #0x24]
700a35ec: e002         	b	0x700a35f4 <xQueueReceive+0x124> @ imm = #0x4
700a35ee: e7ff         	b	0x700a35f0 <xQueueReceive+0x120> @ imm = #-0x2
700a35f0: e7ff         	b	0x700a35f2 <xQueueReceive+0x122> @ imm = #-0x2
;     for( ; ; )
700a35f2: e777         	b	0x700a34e4 <xQueueReceive+0x14> @ imm = #-0x112
; }
700a35f4: 9809         	ldr	r0, [sp, #0x24]
700a35f6: b00a         	add	sp, #0x28
700a35f8: bd80         	pop	{r7, pc}
700a35fa: 0000         	movs	r0, r0
700a35fc: 0000         	movs	r0, r0
700a35fe: 0000         	movs	r0, r0

700a3600 <pxPortInitialiseStack>:
;                                    TaskFunction_t pxCode, void *pvParameters) {
700a3600: b083         	sub	sp, #0xc
700a3602: 9002         	str	r0, [sp, #0x8]
700a3604: 9101         	str	r1, [sp, #0x4]
700a3606: 9200         	str	r2, [sp]
;   *pxTopOfStack = (StackType_t)NULL;
700a3608: 9902         	ldr	r1, [sp, #0x8]
700a360a: 2000         	movs	r0, #0x0
700a360c: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a360e: 9902         	ldr	r1, [sp, #0x8]
700a3610: 3904         	subs	r1, #0x4
700a3612: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a3614: 9902         	ldr	r1, [sp, #0x8]
700a3616: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3618: 9902         	ldr	r1, [sp, #0x8]
700a361a: 3904         	subs	r1, #0x4
700a361c: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a361e: 9902         	ldr	r1, [sp, #0x8]
700a3620: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3622: 9802         	ldr	r0, [sp, #0x8]
700a3624: 3804         	subs	r0, #0x4
700a3626: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portINITIAL_SPSR;
700a3628: 9902         	ldr	r1, [sp, #0x8]
700a362a: 201f         	movs	r0, #0x1f
700a362c: 6008         	str	r0, [r1]
;   if (((uint32_t)pxCode & portTHUMB_MODE_ADDRESS) != 0x00UL) {
700a362e: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a3632: 07c0         	lsls	r0, r0, #0x1f
700a3634: b130         	cbz	r0, 0x700a3644 <pxPortInitialiseStack+0x44> @ imm = #0xc
700a3636: e7ff         	b	0x700a3638 <pxPortInitialiseStack+0x38> @ imm = #-0x2
;     *pxTopOfStack |= portTHUMB_MODE_BIT;
700a3638: 9902         	ldr	r1, [sp, #0x8]
700a363a: 6808         	ldr	r0, [r1]
700a363c: f040 0020    	orr	r0, r0, #0x20
700a3640: 6008         	str	r0, [r1]
;   }
700a3642: e7ff         	b	0x700a3644 <pxPortInitialiseStack+0x44> @ imm = #-0x2
;   pxTopOfStack--;
700a3644: 9802         	ldr	r0, [sp, #0x8]
700a3646: 3804         	subs	r0, #0x4
700a3648: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pxCode;
700a364a: 9801         	ldr	r0, [sp, #0x4]
700a364c: 9902         	ldr	r1, [sp, #0x8]
700a364e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3650: 9802         	ldr	r0, [sp, #0x8]
700a3652: 3804         	subs	r0, #0x4
700a3654: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* R14 */
700a3656: 9902         	ldr	r1, [sp, #0x8]
700a3658: f64f 4091    	movw	r0, #0xfc91
700a365c: f2c7 000a    	movt	r0, #0x700a
700a3660: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3662: 9802         	ldr	r0, [sp, #0x8]
700a3664: 3804         	subs	r0, #0x4
700a3666: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x12121212; /* R12 */
700a3668: 9902         	ldr	r1, [sp, #0x8]
700a366a: f04f 3012    	mov.w	r0, #0x12121212
700a366e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3670: 9802         	ldr	r0, [sp, #0x8]
700a3672: 3804         	subs	r0, #0x4
700a3674: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x11111111; /* R11 */
700a3676: 9902         	ldr	r1, [sp, #0x8]
700a3678: f04f 3011    	mov.w	r0, #0x11111111
700a367c: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a367e: 9802         	ldr	r0, [sp, #0x8]
700a3680: 3804         	subs	r0, #0x4
700a3682: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x10101010; /* R10 */
700a3684: 9902         	ldr	r1, [sp, #0x8]
700a3686: f04f 3010    	mov.w	r0, #0x10101010
700a368a: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a368c: 9802         	ldr	r0, [sp, #0x8]
700a368e: 3804         	subs	r0, #0x4
700a3690: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x09090909; /* R9 */
700a3692: 9902         	ldr	r1, [sp, #0x8]
700a3694: f04f 3009    	mov.w	r0, #0x9090909
700a3698: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a369a: 9802         	ldr	r0, [sp, #0x8]
700a369c: 3804         	subs	r0, #0x4
700a369e: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x08080808; /* R8 */
700a36a0: 9902         	ldr	r1, [sp, #0x8]
700a36a2: f04f 3008    	mov.w	r0, #0x8080808
700a36a6: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a36a8: 9802         	ldr	r0, [sp, #0x8]
700a36aa: 3804         	subs	r0, #0x4
700a36ac: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x07070707; /* R7 */
700a36ae: 9902         	ldr	r1, [sp, #0x8]
700a36b0: f04f 3007    	mov.w	r0, #0x7070707
700a36b4: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a36b6: 9802         	ldr	r0, [sp, #0x8]
700a36b8: 3804         	subs	r0, #0x4
700a36ba: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x06060606; /* R6 */
700a36bc: 9902         	ldr	r1, [sp, #0x8]
700a36be: f04f 3006    	mov.w	r0, #0x6060606
700a36c2: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a36c4: 9802         	ldr	r0, [sp, #0x8]
700a36c6: 3804         	subs	r0, #0x4
700a36c8: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x05050505; /* R5 */
700a36ca: 9902         	ldr	r1, [sp, #0x8]
700a36cc: f04f 3005    	mov.w	r0, #0x5050505
700a36d0: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a36d2: 9802         	ldr	r0, [sp, #0x8]
700a36d4: 3804         	subs	r0, #0x4
700a36d6: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x04040404; /* R4 */
700a36d8: 9902         	ldr	r1, [sp, #0x8]
700a36da: f04f 3004    	mov.w	r0, #0x4040404
700a36de: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a36e0: 9802         	ldr	r0, [sp, #0x8]
700a36e2: 3804         	subs	r0, #0x4
700a36e4: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x03030303; /* R3 */
700a36e6: 9902         	ldr	r1, [sp, #0x8]
700a36e8: f04f 3003    	mov.w	r0, #0x3030303
700a36ec: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a36ee: 9802         	ldr	r0, [sp, #0x8]
700a36f0: 3804         	subs	r0, #0x4
700a36f2: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x02020202; /* R2 */
700a36f4: 9902         	ldr	r1, [sp, #0x8]
700a36f6: f04f 3002    	mov.w	r0, #0x2020202
700a36fa: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a36fc: 9802         	ldr	r0, [sp, #0x8]
700a36fe: 3804         	subs	r0, #0x4
700a3700: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x01010101; /* R1 */
700a3702: 9902         	ldr	r1, [sp, #0x8]
700a3704: f04f 3001    	mov.w	r0, #0x1010101
700a3708: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a370a: 9802         	ldr	r0, [sp, #0x8]
700a370c: 3804         	subs	r0, #0x4
700a370e: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pvParameters; /* R0 */
700a3710: 9800         	ldr	r0, [sp]
700a3712: 9902         	ldr	r1, [sp, #0x8]
700a3714: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3716: 9802         	ldr	r0, [sp, #0x8]
700a3718: 3804         	subs	r0, #0x4
700a371a: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
700a371c: 9902         	ldr	r1, [sp, #0x8]
700a371e: 2000         	movs	r0, #0x0
700a3720: 6008         	str	r0, [r1]
;   return pxTopOfStack;
700a3722: 9802         	ldr	r0, [sp, #0x8]
700a3724: b003         	add	sp, #0xc
700a3726: 4770         	bx	lr
		...

700a3730 <Udma_rmAllocBlkCopyCh>:
; {
700a3730: b580         	push	{r7, lr}
700a3732: b088         	sub	sp, #0x20
700a3734: 9007         	str	r0, [sp, #0x1c]
700a3736: 9106         	str	r1, [sp, #0x18]
700a3738: 2000         	movs	r0, #0x0
700a373a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a373e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3740: 9806         	ldr	r0, [sp, #0x18]
700a3742: f500 70ea    	add.w	r0, r0, #0x1d4
700a3746: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3748: 9806         	ldr	r0, [sp, #0x18]
700a374a: f500 609f    	add.w	r0, r0, #0x4f8
700a374e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3752: f006 ff65    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x6eca
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3756: 9807         	ldr	r0, [sp, #0x1c]
700a3758: 2101         	movs	r1, #0x1
700a375a: f6cf 71ff    	movt	r1, #0xffff
700a375e: 4288         	cmp	r0, r1
700a3760: d136         	bne	0x700a37d0 <Udma_rmAllocBlkCopyCh+0xa0> @ imm = #0x6c
700a3762: e7ff         	b	0x700a3764 <Udma_rmAllocBlkCopyCh+0x34> @ imm = #-0x2
700a3764: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a3766: 9005         	str	r0, [sp, #0x14]
700a3768: e7ff         	b	0x700a376a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x2
700a376a: 9805         	ldr	r0, [sp, #0x14]
700a376c: 9900         	ldr	r1, [sp]
700a376e: 6949         	ldr	r1, [r1, #0x14]
700a3770: 4288         	cmp	r0, r1
700a3772: d22c         	bhs	0x700a37ce <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x58
700a3774: e7ff         	b	0x700a3776 <Udma_rmAllocBlkCopyCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3776: 9805         	ldr	r0, [sp, #0x14]
700a3778: 0940         	lsrs	r0, r0, #0x5
700a377a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a377c: 9805         	ldr	r0, [sp, #0x14]
700a377e: 9904         	ldr	r1, [sp, #0x10]
700a3780: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3784: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3786: 9903         	ldr	r1, [sp, #0xc]
700a3788: 2001         	movs	r0, #0x1
700a378a: 4088         	lsls	r0, r1
700a378c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a378e: 9806         	ldr	r0, [sp, #0x18]
700a3790: 9904         	ldr	r1, [sp, #0x10]
700a3792: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3796: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a379a: 9902         	ldr	r1, [sp, #0x8]
700a379c: 4008         	ands	r0, r1
700a379e: 4288         	cmp	r0, r1
700a37a0: d110         	bne	0x700a37c4 <Udma_rmAllocBlkCopyCh+0x94> @ imm = #0x20
700a37a2: e7ff         	b	0x700a37a4 <Udma_rmAllocBlkCopyCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a37a4: 9a02         	ldr	r2, [sp, #0x8]
700a37a6: 9806         	ldr	r0, [sp, #0x18]
700a37a8: 9904         	ldr	r1, [sp, #0x10]
700a37aa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a37ae: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a37b2: 4390         	bics	r0, r2
700a37b4: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = i + rmInitPrms->startBlkCopyCh;  /* Add start offset */
700a37b8: 9805         	ldr	r0, [sp, #0x14]
700a37ba: 9900         	ldr	r1, [sp]
700a37bc: 6909         	ldr	r1, [r1, #0x10]
700a37be: 4408         	add	r0, r1
700a37c0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a37c2: e004         	b	0x700a37ce <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x8
;         }
700a37c4: e7ff         	b	0x700a37c6 <Udma_rmAllocBlkCopyCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a37c6: 9805         	ldr	r0, [sp, #0x14]
700a37c8: 3001         	adds	r0, #0x1
700a37ca: 9005         	str	r0, [sp, #0x14]
700a37cc: e7cd         	b	0x700a376a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x66
;     }
700a37ce: e038         	b	0x700a3842 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a37d0: 9807         	ldr	r0, [sp, #0x1c]
700a37d2: 9900         	ldr	r1, [sp]
700a37d4: 6909         	ldr	r1, [r1, #0x10]
700a37d6: 4288         	cmp	r0, r1
700a37d8: d332         	blo	0x700a3840 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x64
700a37da: e7ff         	b	0x700a37dc <Udma_rmAllocBlkCopyCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyCh + rmInitPrms->numBlkCopyCh)))
700a37dc: 9807         	ldr	r0, [sp, #0x1c]
700a37de: 9a00         	ldr	r2, [sp]
700a37e0: 6911         	ldr	r1, [r2, #0x10]
700a37e2: 6952         	ldr	r2, [r2, #0x14]
700a37e4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a37e6: 4288         	cmp	r0, r1
700a37e8: d22a         	bhs	0x700a3840 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x54
700a37ea: e7ff         	b	0x700a37ec <Udma_rmAllocBlkCopyCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyCh;
700a37ec: 9807         	ldr	r0, [sp, #0x1c]
700a37ee: 9900         	ldr	r1, [sp]
700a37f0: 6909         	ldr	r1, [r1, #0x10]
700a37f2: 1a40         	subs	r0, r0, r1
700a37f4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a37f6: 9805         	ldr	r0, [sp, #0x14]
700a37f8: 0940         	lsrs	r0, r0, #0x5
700a37fa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a37fc: 9805         	ldr	r0, [sp, #0x14]
700a37fe: 9904         	ldr	r1, [sp, #0x10]
700a3800: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3804: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3806: 9903         	ldr	r1, [sp, #0xc]
700a3808: 2001         	movs	r0, #0x1
700a380a: 4088         	lsls	r0, r1
700a380c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a380e: 9806         	ldr	r0, [sp, #0x18]
700a3810: 9904         	ldr	r1, [sp, #0x10]
700a3812: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3816: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a381a: 9902         	ldr	r1, [sp, #0x8]
700a381c: 4008         	ands	r0, r1
700a381e: 4288         	cmp	r0, r1
700a3820: d10d         	bne	0x700a383e <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #0x1a
700a3822: e7ff         	b	0x700a3824 <Udma_rmAllocBlkCopyCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a3824: 9a02         	ldr	r2, [sp, #0x8]
700a3826: 9806         	ldr	r0, [sp, #0x18]
700a3828: 9904         	ldr	r1, [sp, #0x10]
700a382a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a382e: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a3832: 4390         	bics	r0, r2
700a3834: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = preferredChNum;
700a3838: 9807         	ldr	r0, [sp, #0x1c]
700a383a: 9001         	str	r0, [sp, #0x4]
;             }
700a383c: e7ff         	b	0x700a383e <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #-0x2
;         }
700a383e: e7ff         	b	0x700a3840 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #-0x2
700a3840: e7ff         	b	0x700a3842 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3842: 9806         	ldr	r0, [sp, #0x18]
700a3844: f500 609f    	add.w	r0, r0, #0x4f8
700a3848: f008 fab2    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x8564
;     return (chNum);
700a384c: 9801         	ldr	r0, [sp, #0x4]
700a384e: b008         	add	sp, #0x20
700a3850: bd80         	pop	{r7, pc}
		...
700a385e: 0000         	movs	r0, r0

700a3860 <Udma_rmAllocBlkCopyHcCh>:
; {
700a3860: b580         	push	{r7, lr}
700a3862: b088         	sub	sp, #0x20
700a3864: 9007         	str	r0, [sp, #0x1c]
700a3866: 9106         	str	r1, [sp, #0x18]
700a3868: 2000         	movs	r0, #0x0
700a386a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a386e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3870: 9806         	ldr	r0, [sp, #0x18]
700a3872: f500 70ea    	add.w	r0, r0, #0x1d4
700a3876: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3878: 9806         	ldr	r0, [sp, #0x18]
700a387a: f500 609f    	add.w	r0, r0, #0x4f8
700a387e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3882: f006 fecd    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x6d9a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3886: 9807         	ldr	r0, [sp, #0x1c]
700a3888: 2101         	movs	r1, #0x1
700a388a: f6cf 71ff    	movt	r1, #0xffff
700a388e: 4288         	cmp	r0, r1
700a3890: d136         	bne	0x700a3900 <Udma_rmAllocBlkCopyHcCh+0xa0> @ imm = #0x6c
700a3892: e7ff         	b	0x700a3894 <Udma_rmAllocBlkCopyHcCh+0x34> @ imm = #-0x2
700a3894: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a3896: 9005         	str	r0, [sp, #0x14]
700a3898: e7ff         	b	0x700a389a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x2
700a389a: 9805         	ldr	r0, [sp, #0x14]
700a389c: 9900         	ldr	r1, [sp]
700a389e: 68c9         	ldr	r1, [r1, #0xc]
700a38a0: 4288         	cmp	r0, r1
700a38a2: d22c         	bhs	0x700a38fe <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x58
700a38a4: e7ff         	b	0x700a38a6 <Udma_rmAllocBlkCopyHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a38a6: 9805         	ldr	r0, [sp, #0x14]
700a38a8: 0940         	lsrs	r0, r0, #0x5
700a38aa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a38ac: 9805         	ldr	r0, [sp, #0x14]
700a38ae: 9904         	ldr	r1, [sp, #0x10]
700a38b0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a38b4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a38b6: 9903         	ldr	r1, [sp, #0xc]
700a38b8: 2001         	movs	r0, #0x1
700a38ba: 4088         	lsls	r0, r1
700a38bc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a38be: 9806         	ldr	r0, [sp, #0x18]
700a38c0: 9904         	ldr	r1, [sp, #0x10]
700a38c2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a38c6: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a38ca: 9902         	ldr	r1, [sp, #0x8]
700a38cc: 4008         	ands	r0, r1
700a38ce: 4288         	cmp	r0, r1
700a38d0: d110         	bne	0x700a38f4 <Udma_rmAllocBlkCopyHcCh+0x94> @ imm = #0x20
700a38d2: e7ff         	b	0x700a38d4 <Udma_rmAllocBlkCopyHcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a38d4: 9a02         	ldr	r2, [sp, #0x8]
700a38d6: 9806         	ldr	r0, [sp, #0x18]
700a38d8: 9904         	ldr	r1, [sp, #0x10]
700a38da: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a38de: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a38e2: 4390         	bics	r0, r2
700a38e4: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = i + rmInitPrms->startBlkCopyHcCh;  /* Add start offset */
700a38e8: 9805         	ldr	r0, [sp, #0x14]
700a38ea: 9900         	ldr	r1, [sp]
700a38ec: 6889         	ldr	r1, [r1, #0x8]
700a38ee: 4408         	add	r0, r1
700a38f0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a38f2: e004         	b	0x700a38fe <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x8
;         }
700a38f4: e7ff         	b	0x700a38f6 <Udma_rmAllocBlkCopyHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a38f6: 9805         	ldr	r0, [sp, #0x14]
700a38f8: 3001         	adds	r0, #0x1
700a38fa: 9005         	str	r0, [sp, #0x14]
700a38fc: e7cd         	b	0x700a389a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x66
;     }
700a38fe: e038         	b	0x700a3972 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a3900: 9807         	ldr	r0, [sp, #0x1c]
700a3902: 9900         	ldr	r1, [sp]
700a3904: 6889         	ldr	r1, [r1, #0x8]
700a3906: 4288         	cmp	r0, r1
700a3908: d332         	blo	0x700a3970 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x64
700a390a: e7ff         	b	0x700a390c <Udma_rmAllocBlkCopyHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyHcCh + rmInitPrms->numBlkCopyHcCh)))
700a390c: 9807         	ldr	r0, [sp, #0x1c]
700a390e: 9a00         	ldr	r2, [sp]
700a3910: 6891         	ldr	r1, [r2, #0x8]
700a3912: 68d2         	ldr	r2, [r2, #0xc]
700a3914: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a3916: 4288         	cmp	r0, r1
700a3918: d22a         	bhs	0x700a3970 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x54
700a391a: e7ff         	b	0x700a391c <Udma_rmAllocBlkCopyHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyHcCh;
700a391c: 9807         	ldr	r0, [sp, #0x1c]
700a391e: 9900         	ldr	r1, [sp]
700a3920: 6889         	ldr	r1, [r1, #0x8]
700a3922: 1a40         	subs	r0, r0, r1
700a3924: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3926: 9805         	ldr	r0, [sp, #0x14]
700a3928: 0940         	lsrs	r0, r0, #0x5
700a392a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a392c: 9805         	ldr	r0, [sp, #0x14]
700a392e: 9904         	ldr	r1, [sp, #0x10]
700a3930: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3934: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3936: 9903         	ldr	r1, [sp, #0xc]
700a3938: 2001         	movs	r0, #0x1
700a393a: 4088         	lsls	r0, r1
700a393c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a393e: 9806         	ldr	r0, [sp, #0x18]
700a3940: 9904         	ldr	r1, [sp, #0x10]
700a3942: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3946: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a394a: 9902         	ldr	r1, [sp, #0x8]
700a394c: 4008         	ands	r0, r1
700a394e: 4288         	cmp	r0, r1
700a3950: d10d         	bne	0x700a396e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #0x1a
700a3952: e7ff         	b	0x700a3954 <Udma_rmAllocBlkCopyHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a3954: 9a02         	ldr	r2, [sp, #0x8]
700a3956: 9806         	ldr	r0, [sp, #0x18]
700a3958: 9904         	ldr	r1, [sp, #0x10]
700a395a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a395e: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a3962: 4390         	bics	r0, r2
700a3964: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = preferredChNum;
700a3968: 9807         	ldr	r0, [sp, #0x1c]
700a396a: 9001         	str	r0, [sp, #0x4]
;             }
700a396c: e7ff         	b	0x700a396e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #-0x2
;         }
700a396e: e7ff         	b	0x700a3970 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #-0x2
700a3970: e7ff         	b	0x700a3972 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3972: 9806         	ldr	r0, [sp, #0x18]
700a3974: f500 609f    	add.w	r0, r0, #0x4f8
700a3978: f008 fa1a    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x8434
;     return (chNum);
700a397c: 9801         	ldr	r0, [sp, #0x4]
700a397e: b008         	add	sp, #0x20
700a3980: bd80         	pop	{r7, pc}
		...
700a398e: 0000         	movs	r0, r0

700a3990 <Udma_rmAllocBlkCopyUhcCh>:
; {
700a3990: b580         	push	{r7, lr}
700a3992: b088         	sub	sp, #0x20
700a3994: 9007         	str	r0, [sp, #0x1c]
700a3996: 9106         	str	r1, [sp, #0x18]
700a3998: 2000         	movs	r0, #0x0
700a399a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a399e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a39a0: 9806         	ldr	r0, [sp, #0x18]
700a39a2: f500 70ea    	add.w	r0, r0, #0x1d4
700a39a6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a39a8: 9806         	ldr	r0, [sp, #0x18]
700a39aa: f500 609f    	add.w	r0, r0, #0x4f8
700a39ae: f04f 31ff    	mov.w	r1, #0xffffffff
700a39b2: f006 fe35    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x6c6a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a39b6: 9807         	ldr	r0, [sp, #0x1c]
700a39b8: 2101         	movs	r1, #0x1
700a39ba: f6cf 71ff    	movt	r1, #0xffff
700a39be: 4288         	cmp	r0, r1
700a39c0: d136         	bne	0x700a3a30 <Udma_rmAllocBlkCopyUhcCh+0xa0> @ imm = #0x6c
700a39c2: e7ff         	b	0x700a39c4 <Udma_rmAllocBlkCopyUhcCh+0x34> @ imm = #-0x2
700a39c4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a39c6: 9005         	str	r0, [sp, #0x14]
700a39c8: e7ff         	b	0x700a39ca <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x2
700a39ca: 9805         	ldr	r0, [sp, #0x14]
700a39cc: 9900         	ldr	r1, [sp]
700a39ce: 6849         	ldr	r1, [r1, #0x4]
700a39d0: 4288         	cmp	r0, r1
700a39d2: d22c         	bhs	0x700a3a2e <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x58
700a39d4: e7ff         	b	0x700a39d6 <Udma_rmAllocBlkCopyUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a39d6: 9805         	ldr	r0, [sp, #0x14]
700a39d8: 0940         	lsrs	r0, r0, #0x5
700a39da: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a39dc: 9805         	ldr	r0, [sp, #0x14]
700a39de: 9904         	ldr	r1, [sp, #0x10]
700a39e0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a39e4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a39e6: 9903         	ldr	r1, [sp, #0xc]
700a39e8: 2001         	movs	r0, #0x1
700a39ea: 4088         	lsls	r0, r1
700a39ec: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a39ee: 9806         	ldr	r0, [sp, #0x18]
700a39f0: 9904         	ldr	r1, [sp, #0x10]
700a39f2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a39f6: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a39fa: 9902         	ldr	r1, [sp, #0x8]
700a39fc: 4008         	ands	r0, r1
700a39fe: 4288         	cmp	r0, r1
700a3a00: d110         	bne	0x700a3a24 <Udma_rmAllocBlkCopyUhcCh+0x94> @ imm = #0x20
700a3a02: e7ff         	b	0x700a3a04 <Udma_rmAllocBlkCopyUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a3a04: 9a02         	ldr	r2, [sp, #0x8]
700a3a06: 9806         	ldr	r0, [sp, #0x18]
700a3a08: 9904         	ldr	r1, [sp, #0x10]
700a3a0a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3a0e: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a3a12: 4390         	bics	r0, r2
700a3a14: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = i + rmInitPrms->startBlkCopyUhcCh;  /* Add start offset */
700a3a18: 9805         	ldr	r0, [sp, #0x14]
700a3a1a: 9900         	ldr	r1, [sp]
700a3a1c: 6809         	ldr	r1, [r1]
700a3a1e: 4408         	add	r0, r1
700a3a20: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3a22: e004         	b	0x700a3a2e <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x8
;         }
700a3a24: e7ff         	b	0x700a3a26 <Udma_rmAllocBlkCopyUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a3a26: 9805         	ldr	r0, [sp, #0x14]
700a3a28: 3001         	adds	r0, #0x1
700a3a2a: 9005         	str	r0, [sp, #0x14]
700a3a2c: e7cd         	b	0x700a39ca <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x66
;     }
700a3a2e: e038         	b	0x700a3aa2 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a3a30: 9807         	ldr	r0, [sp, #0x1c]
700a3a32: 9900         	ldr	r1, [sp]
700a3a34: 6809         	ldr	r1, [r1]
700a3a36: 4288         	cmp	r0, r1
700a3a38: d332         	blo	0x700a3aa0 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x64
700a3a3a: e7ff         	b	0x700a3a3c <Udma_rmAllocBlkCopyUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyUhcCh + rmInitPrms->numBlkCopyUhcCh)))
700a3a3c: 9807         	ldr	r0, [sp, #0x1c]
700a3a3e: 9a00         	ldr	r2, [sp]
700a3a40: 6811         	ldr	r1, [r2]
700a3a42: 6852         	ldr	r2, [r2, #0x4]
700a3a44: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a3a46: 4288         	cmp	r0, r1
700a3a48: d22a         	bhs	0x700a3aa0 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x54
700a3a4a: e7ff         	b	0x700a3a4c <Udma_rmAllocBlkCopyUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyUhcCh;
700a3a4c: 9807         	ldr	r0, [sp, #0x1c]
700a3a4e: 9900         	ldr	r1, [sp]
700a3a50: 6809         	ldr	r1, [r1]
700a3a52: 1a40         	subs	r0, r0, r1
700a3a54: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3a56: 9805         	ldr	r0, [sp, #0x14]
700a3a58: 0940         	lsrs	r0, r0, #0x5
700a3a5a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3a5c: 9805         	ldr	r0, [sp, #0x14]
700a3a5e: 9904         	ldr	r1, [sp, #0x10]
700a3a60: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3a64: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3a66: 9903         	ldr	r1, [sp, #0xc]
700a3a68: 2001         	movs	r0, #0x1
700a3a6a: 4088         	lsls	r0, r1
700a3a6c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a3a6e: 9806         	ldr	r0, [sp, #0x18]
700a3a70: 9904         	ldr	r1, [sp, #0x10]
700a3a72: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3a76: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a3a7a: 9902         	ldr	r1, [sp, #0x8]
700a3a7c: 4008         	ands	r0, r1
700a3a7e: 4288         	cmp	r0, r1
700a3a80: d10d         	bne	0x700a3a9e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #0x1a
700a3a82: e7ff         	b	0x700a3a84 <Udma_rmAllocBlkCopyUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a3a84: 9a02         	ldr	r2, [sp, #0x8]
700a3a86: 9806         	ldr	r0, [sp, #0x18]
700a3a88: 9904         	ldr	r1, [sp, #0x10]
700a3a8a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3a8e: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a3a92: 4390         	bics	r0, r2
700a3a94: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = preferredChNum;
700a3a98: 9807         	ldr	r0, [sp, #0x1c]
700a3a9a: 9001         	str	r0, [sp, #0x4]
;             }
700a3a9c: e7ff         	b	0x700a3a9e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #-0x2
;         }
700a3a9e: e7ff         	b	0x700a3aa0 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #-0x2
700a3aa0: e7ff         	b	0x700a3aa2 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3aa2: 9806         	ldr	r0, [sp, #0x18]
700a3aa4: f500 609f    	add.w	r0, r0, #0x4f8
700a3aa8: f008 f982    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x8304
;     return (chNum);
700a3aac: 9801         	ldr	r0, [sp, #0x4]
700a3aae: b008         	add	sp, #0x20
700a3ab0: bd80         	pop	{r7, pc}
		...
700a3abe: 0000         	movs	r0, r0

700a3ac0 <Udma_rmAllocRxCh>:
; {
700a3ac0: b580         	push	{r7, lr}
700a3ac2: b088         	sub	sp, #0x20
700a3ac4: 9007         	str	r0, [sp, #0x1c]
700a3ac6: 9106         	str	r1, [sp, #0x18]
700a3ac8: 2000         	movs	r0, #0x0
700a3aca: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3ace: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3ad0: 9806         	ldr	r0, [sp, #0x18]
700a3ad2: f500 70ea    	add.w	r0, r0, #0x1d4
700a3ad6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3ad8: 9806         	ldr	r0, [sp, #0x18]
700a3ada: f500 609f    	add.w	r0, r0, #0x4f8
700a3ade: f04f 31ff    	mov.w	r1, #0xffffffff
700a3ae2: f006 fd9d    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x6b3a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3ae6: 9807         	ldr	r0, [sp, #0x1c]
700a3ae8: 2101         	movs	r1, #0x1
700a3aea: f6cf 71ff    	movt	r1, #0xffff
700a3aee: 4288         	cmp	r0, r1
700a3af0: d136         	bne	0x700a3b60 <Udma_rmAllocRxCh+0xa0> @ imm = #0x6c
700a3af2: e7ff         	b	0x700a3af4 <Udma_rmAllocRxCh+0x34> @ imm = #-0x2
700a3af4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a3af6: 9005         	str	r0, [sp, #0x14]
700a3af8: e7ff         	b	0x700a3afa <Udma_rmAllocRxCh+0x3a> @ imm = #-0x2
700a3afa: 9805         	ldr	r0, [sp, #0x14]
700a3afc: 9900         	ldr	r1, [sp]
700a3afe: 6c49         	ldr	r1, [r1, #0x44]
700a3b00: 4288         	cmp	r0, r1
700a3b02: d22c         	bhs	0x700a3b5e <Udma_rmAllocRxCh+0x9e> @ imm = #0x58
700a3b04: e7ff         	b	0x700a3b06 <Udma_rmAllocRxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3b06: 9805         	ldr	r0, [sp, #0x14]
700a3b08: 0940         	lsrs	r0, r0, #0x5
700a3b0a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3b0c: 9805         	ldr	r0, [sp, #0x14]
700a3b0e: 9904         	ldr	r1, [sp, #0x10]
700a3b10: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3b14: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3b16: 9903         	ldr	r1, [sp, #0xc]
700a3b18: 2001         	movs	r0, #0x1
700a3b1a: 4088         	lsls	r0, r1
700a3b1c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a3b1e: 9806         	ldr	r0, [sp, #0x18]
700a3b20: 9904         	ldr	r1, [sp, #0x10]
700a3b22: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3b26: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a3b2a: 9902         	ldr	r1, [sp, #0x8]
700a3b2c: 4008         	ands	r0, r1
700a3b2e: 4288         	cmp	r0, r1
700a3b30: d110         	bne	0x700a3b54 <Udma_rmAllocRxCh+0x94> @ imm = #0x20
700a3b32: e7ff         	b	0x700a3b34 <Udma_rmAllocRxCh+0x74> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a3b34: 9a02         	ldr	r2, [sp, #0x8]
700a3b36: 9806         	ldr	r0, [sp, #0x18]
700a3b38: 9904         	ldr	r1, [sp, #0x10]
700a3b3a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3b3e: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a3b42: 4390         	bics	r0, r2
700a3b44: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = i + rmInitPrms->startRxCh;  /* Add start offset */
700a3b48: 9805         	ldr	r0, [sp, #0x14]
700a3b4a: 9900         	ldr	r1, [sp]
700a3b4c: 6c09         	ldr	r1, [r1, #0x40]
700a3b4e: 4408         	add	r0, r1
700a3b50: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3b52: e004         	b	0x700a3b5e <Udma_rmAllocRxCh+0x9e> @ imm = #0x8
;         }
700a3b54: e7ff         	b	0x700a3b56 <Udma_rmAllocRxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a3b56: 9805         	ldr	r0, [sp, #0x14]
700a3b58: 3001         	adds	r0, #0x1
700a3b5a: 9005         	str	r0, [sp, #0x14]
700a3b5c: e7cd         	b	0x700a3afa <Udma_rmAllocRxCh+0x3a> @ imm = #-0x66
;     }
700a3b5e: e038         	b	0x700a3bd2 <Udma_rmAllocRxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a3b60: 9807         	ldr	r0, [sp, #0x1c]
700a3b62: 9900         	ldr	r1, [sp]
700a3b64: 6c09         	ldr	r1, [r1, #0x40]
700a3b66: 4288         	cmp	r0, r1
700a3b68: d332         	blo	0x700a3bd0 <Udma_rmAllocRxCh+0x110> @ imm = #0x64
700a3b6a: e7ff         	b	0x700a3b6c <Udma_rmAllocRxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxCh + rmInitPrms->numRxCh)))
700a3b6c: 9807         	ldr	r0, [sp, #0x1c]
700a3b6e: 9a00         	ldr	r2, [sp]
700a3b70: 6c11         	ldr	r1, [r2, #0x40]
700a3b72: 6c52         	ldr	r2, [r2, #0x44]
700a3b74: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a3b76: 4288         	cmp	r0, r1
700a3b78: d22a         	bhs	0x700a3bd0 <Udma_rmAllocRxCh+0x110> @ imm = #0x54
700a3b7a: e7ff         	b	0x700a3b7c <Udma_rmAllocRxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxCh;
700a3b7c: 9807         	ldr	r0, [sp, #0x1c]
700a3b7e: 9900         	ldr	r1, [sp]
700a3b80: 6c09         	ldr	r1, [r1, #0x40]
700a3b82: 1a40         	subs	r0, r0, r1
700a3b84: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3b86: 9805         	ldr	r0, [sp, #0x14]
700a3b88: 0940         	lsrs	r0, r0, #0x5
700a3b8a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3b8c: 9805         	ldr	r0, [sp, #0x14]
700a3b8e: 9904         	ldr	r1, [sp, #0x10]
700a3b90: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3b94: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3b96: 9903         	ldr	r1, [sp, #0xc]
700a3b98: 2001         	movs	r0, #0x1
700a3b9a: 4088         	lsls	r0, r1
700a3b9c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a3b9e: 9806         	ldr	r0, [sp, #0x18]
700a3ba0: 9904         	ldr	r1, [sp, #0x10]
700a3ba2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3ba6: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a3baa: 9902         	ldr	r1, [sp, #0x8]
700a3bac: 4008         	ands	r0, r1
700a3bae: 4288         	cmp	r0, r1
700a3bb0: d10d         	bne	0x700a3bce <Udma_rmAllocRxCh+0x10e> @ imm = #0x1a
700a3bb2: e7ff         	b	0x700a3bb4 <Udma_rmAllocRxCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a3bb4: 9a02         	ldr	r2, [sp, #0x8]
700a3bb6: 9806         	ldr	r0, [sp, #0x18]
700a3bb8: 9904         	ldr	r1, [sp, #0x10]
700a3bba: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3bbe: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a3bc2: 4390         	bics	r0, r2
700a3bc4: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = preferredChNum;
700a3bc8: 9807         	ldr	r0, [sp, #0x1c]
700a3bca: 9001         	str	r0, [sp, #0x4]
;             }
700a3bcc: e7ff         	b	0x700a3bce <Udma_rmAllocRxCh+0x10e> @ imm = #-0x2
;         }
700a3bce: e7ff         	b	0x700a3bd0 <Udma_rmAllocRxCh+0x110> @ imm = #-0x2
700a3bd0: e7ff         	b	0x700a3bd2 <Udma_rmAllocRxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3bd2: 9806         	ldr	r0, [sp, #0x18]
700a3bd4: f500 609f    	add.w	r0, r0, #0x4f8
700a3bd8: f008 f8ea    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x81d4
;     return (chNum);
700a3bdc: 9801         	ldr	r0, [sp, #0x4]
700a3bde: b008         	add	sp, #0x20
700a3be0: bd80         	pop	{r7, pc}
		...
700a3bee: 0000         	movs	r0, r0

700a3bf0 <Udma_rmAllocRxHcCh>:
; {
700a3bf0: b580         	push	{r7, lr}
700a3bf2: b088         	sub	sp, #0x20
700a3bf4: 9007         	str	r0, [sp, #0x1c]
700a3bf6: 9106         	str	r1, [sp, #0x18]
700a3bf8: 2000         	movs	r0, #0x0
700a3bfa: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3bfe: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3c00: 9806         	ldr	r0, [sp, #0x18]
700a3c02: f500 70ea    	add.w	r0, r0, #0x1d4
700a3c06: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3c08: 9806         	ldr	r0, [sp, #0x18]
700a3c0a: f500 609f    	add.w	r0, r0, #0x4f8
700a3c0e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3c12: f006 fd05    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x6a0a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3c16: 9807         	ldr	r0, [sp, #0x1c]
700a3c18: 2101         	movs	r1, #0x1
700a3c1a: f6cf 71ff    	movt	r1, #0xffff
700a3c1e: 4288         	cmp	r0, r1
700a3c20: d136         	bne	0x700a3c90 <Udma_rmAllocRxHcCh+0xa0> @ imm = #0x6c
700a3c22: e7ff         	b	0x700a3c24 <Udma_rmAllocRxHcCh+0x34> @ imm = #-0x2
700a3c24: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a3c26: 9005         	str	r0, [sp, #0x14]
700a3c28: e7ff         	b	0x700a3c2a <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x2
700a3c2a: 9805         	ldr	r0, [sp, #0x14]
700a3c2c: 9900         	ldr	r1, [sp]
700a3c2e: 6bc9         	ldr	r1, [r1, #0x3c]
700a3c30: 4288         	cmp	r0, r1
700a3c32: d22c         	bhs	0x700a3c8e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x58
700a3c34: e7ff         	b	0x700a3c36 <Udma_rmAllocRxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3c36: 9805         	ldr	r0, [sp, #0x14]
700a3c38: 0940         	lsrs	r0, r0, #0x5
700a3c3a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3c3c: 9805         	ldr	r0, [sp, #0x14]
700a3c3e: 9904         	ldr	r1, [sp, #0x10]
700a3c40: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3c44: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3c46: 9903         	ldr	r1, [sp, #0xc]
700a3c48: 2001         	movs	r0, #0x1
700a3c4a: 4088         	lsls	r0, r1
700a3c4c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a3c4e: 9806         	ldr	r0, [sp, #0x18]
700a3c50: 9904         	ldr	r1, [sp, #0x10]
700a3c52: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3c56: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a3c5a: 9902         	ldr	r1, [sp, #0x8]
700a3c5c: 4008         	ands	r0, r1
700a3c5e: 4288         	cmp	r0, r1
700a3c60: d110         	bne	0x700a3c84 <Udma_rmAllocRxHcCh+0x94> @ imm = #0x20
700a3c62: e7ff         	b	0x700a3c64 <Udma_rmAllocRxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a3c64: 9a02         	ldr	r2, [sp, #0x8]
700a3c66: 9806         	ldr	r0, [sp, #0x18]
700a3c68: 9904         	ldr	r1, [sp, #0x10]
700a3c6a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3c6e: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a3c72: 4390         	bics	r0, r2
700a3c74: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = i + rmInitPrms->startRxHcCh;  /* Add start offset */
700a3c78: 9805         	ldr	r0, [sp, #0x14]
700a3c7a: 9900         	ldr	r1, [sp]
700a3c7c: 6b89         	ldr	r1, [r1, #0x38]
700a3c7e: 4408         	add	r0, r1
700a3c80: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3c82: e004         	b	0x700a3c8e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x8
;         }
700a3c84: e7ff         	b	0x700a3c86 <Udma_rmAllocRxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a3c86: 9805         	ldr	r0, [sp, #0x14]
700a3c88: 3001         	adds	r0, #0x1
700a3c8a: 9005         	str	r0, [sp, #0x14]
700a3c8c: e7cd         	b	0x700a3c2a <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x66
;     }
700a3c8e: e038         	b	0x700a3d02 <Udma_rmAllocRxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a3c90: 9807         	ldr	r0, [sp, #0x1c]
700a3c92: 9900         	ldr	r1, [sp]
700a3c94: 6b89         	ldr	r1, [r1, #0x38]
700a3c96: 4288         	cmp	r0, r1
700a3c98: d332         	blo	0x700a3d00 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x64
700a3c9a: e7ff         	b	0x700a3c9c <Udma_rmAllocRxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxHcCh + rmInitPrms->numRxHcCh)))
700a3c9c: 9807         	ldr	r0, [sp, #0x1c]
700a3c9e: 9a00         	ldr	r2, [sp]
700a3ca0: 6b91         	ldr	r1, [r2, #0x38]
700a3ca2: 6bd2         	ldr	r2, [r2, #0x3c]
700a3ca4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a3ca6: 4288         	cmp	r0, r1
700a3ca8: d22a         	bhs	0x700a3d00 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x54
700a3caa: e7ff         	b	0x700a3cac <Udma_rmAllocRxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxHcCh;
700a3cac: 9807         	ldr	r0, [sp, #0x1c]
700a3cae: 9900         	ldr	r1, [sp]
700a3cb0: 6b89         	ldr	r1, [r1, #0x38]
700a3cb2: 1a40         	subs	r0, r0, r1
700a3cb4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3cb6: 9805         	ldr	r0, [sp, #0x14]
700a3cb8: 0940         	lsrs	r0, r0, #0x5
700a3cba: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3cbc: 9805         	ldr	r0, [sp, #0x14]
700a3cbe: 9904         	ldr	r1, [sp, #0x10]
700a3cc0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3cc4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3cc6: 9903         	ldr	r1, [sp, #0xc]
700a3cc8: 2001         	movs	r0, #0x1
700a3cca: 4088         	lsls	r0, r1
700a3ccc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a3cce: 9806         	ldr	r0, [sp, #0x18]
700a3cd0: 9904         	ldr	r1, [sp, #0x10]
700a3cd2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3cd6: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a3cda: 9902         	ldr	r1, [sp, #0x8]
700a3cdc: 4008         	ands	r0, r1
700a3cde: 4288         	cmp	r0, r1
700a3ce0: d10d         	bne	0x700a3cfe <Udma_rmAllocRxHcCh+0x10e> @ imm = #0x1a
700a3ce2: e7ff         	b	0x700a3ce4 <Udma_rmAllocRxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a3ce4: 9a02         	ldr	r2, [sp, #0x8]
700a3ce6: 9806         	ldr	r0, [sp, #0x18]
700a3ce8: 9904         	ldr	r1, [sp, #0x10]
700a3cea: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3cee: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a3cf2: 4390         	bics	r0, r2
700a3cf4: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = preferredChNum;
700a3cf8: 9807         	ldr	r0, [sp, #0x1c]
700a3cfa: 9001         	str	r0, [sp, #0x4]
;             }
700a3cfc: e7ff         	b	0x700a3cfe <Udma_rmAllocRxHcCh+0x10e> @ imm = #-0x2
;         }
700a3cfe: e7ff         	b	0x700a3d00 <Udma_rmAllocRxHcCh+0x110> @ imm = #-0x2
700a3d00: e7ff         	b	0x700a3d02 <Udma_rmAllocRxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3d02: 9806         	ldr	r0, [sp, #0x18]
700a3d04: f500 609f    	add.w	r0, r0, #0x4f8
700a3d08: f008 f852    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x80a4
;     return (chNum);
700a3d0c: 9801         	ldr	r0, [sp, #0x4]
700a3d0e: b008         	add	sp, #0x20
700a3d10: bd80         	pop	{r7, pc}
		...
700a3d1e: 0000         	movs	r0, r0

700a3d20 <Udma_rmAllocRxUhcCh>:
; {
700a3d20: b580         	push	{r7, lr}
700a3d22: b088         	sub	sp, #0x20
700a3d24: 9007         	str	r0, [sp, #0x1c]
700a3d26: 9106         	str	r1, [sp, #0x18]
700a3d28: 2000         	movs	r0, #0x0
700a3d2a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3d2e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3d30: 9806         	ldr	r0, [sp, #0x18]
700a3d32: f500 70ea    	add.w	r0, r0, #0x1d4
700a3d36: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3d38: 9806         	ldr	r0, [sp, #0x18]
700a3d3a: f500 609f    	add.w	r0, r0, #0x4f8
700a3d3e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3d42: f006 fc6d    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x68da
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3d46: 9807         	ldr	r0, [sp, #0x1c]
700a3d48: 2101         	movs	r1, #0x1
700a3d4a: f6cf 71ff    	movt	r1, #0xffff
700a3d4e: 4288         	cmp	r0, r1
700a3d50: d136         	bne	0x700a3dc0 <Udma_rmAllocRxUhcCh+0xa0> @ imm = #0x6c
700a3d52: e7ff         	b	0x700a3d54 <Udma_rmAllocRxUhcCh+0x34> @ imm = #-0x2
700a3d54: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a3d56: 9005         	str	r0, [sp, #0x14]
700a3d58: e7ff         	b	0x700a3d5a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x2
700a3d5a: 9805         	ldr	r0, [sp, #0x14]
700a3d5c: 9900         	ldr	r1, [sp]
700a3d5e: 6b49         	ldr	r1, [r1, #0x34]
700a3d60: 4288         	cmp	r0, r1
700a3d62: d22c         	bhs	0x700a3dbe <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x58
700a3d64: e7ff         	b	0x700a3d66 <Udma_rmAllocRxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3d66: 9805         	ldr	r0, [sp, #0x14]
700a3d68: 0940         	lsrs	r0, r0, #0x5
700a3d6a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3d6c: 9805         	ldr	r0, [sp, #0x14]
700a3d6e: 9904         	ldr	r1, [sp, #0x10]
700a3d70: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3d74: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3d76: 9903         	ldr	r1, [sp, #0xc]
700a3d78: 2001         	movs	r0, #0x1
700a3d7a: 4088         	lsls	r0, r1
700a3d7c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a3d7e: 9806         	ldr	r0, [sp, #0x18]
700a3d80: 9904         	ldr	r1, [sp, #0x10]
700a3d82: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3d86: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a3d8a: 9902         	ldr	r1, [sp, #0x8]
700a3d8c: 4008         	ands	r0, r1
700a3d8e: 4288         	cmp	r0, r1
700a3d90: d110         	bne	0x700a3db4 <Udma_rmAllocRxUhcCh+0x94> @ imm = #0x20
700a3d92: e7ff         	b	0x700a3d94 <Udma_rmAllocRxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a3d94: 9a02         	ldr	r2, [sp, #0x8]
700a3d96: 9806         	ldr	r0, [sp, #0x18]
700a3d98: 9904         	ldr	r1, [sp, #0x10]
700a3d9a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3d9e: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a3da2: 4390         	bics	r0, r2
700a3da4: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = i + rmInitPrms->startRxUhcCh;  /* Add start offset */
700a3da8: 9805         	ldr	r0, [sp, #0x14]
700a3daa: 9900         	ldr	r1, [sp]
700a3dac: 6b09         	ldr	r1, [r1, #0x30]
700a3dae: 4408         	add	r0, r1
700a3db0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3db2: e004         	b	0x700a3dbe <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x8
;         }
700a3db4: e7ff         	b	0x700a3db6 <Udma_rmAllocRxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a3db6: 9805         	ldr	r0, [sp, #0x14]
700a3db8: 3001         	adds	r0, #0x1
700a3dba: 9005         	str	r0, [sp, #0x14]
700a3dbc: e7cd         	b	0x700a3d5a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x66
;     }
700a3dbe: e038         	b	0x700a3e32 <Udma_rmAllocRxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a3dc0: 9807         	ldr	r0, [sp, #0x1c]
700a3dc2: 9900         	ldr	r1, [sp]
700a3dc4: 6b09         	ldr	r1, [r1, #0x30]
700a3dc6: 4288         	cmp	r0, r1
700a3dc8: d332         	blo	0x700a3e30 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x64
700a3dca: e7ff         	b	0x700a3dcc <Udma_rmAllocRxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxUhcCh + rmInitPrms->numRxUhcCh)))
700a3dcc: 9807         	ldr	r0, [sp, #0x1c]
700a3dce: 9a00         	ldr	r2, [sp]
700a3dd0: 6b11         	ldr	r1, [r2, #0x30]
700a3dd2: 6b52         	ldr	r2, [r2, #0x34]
700a3dd4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a3dd6: 4288         	cmp	r0, r1
700a3dd8: d22a         	bhs	0x700a3e30 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x54
700a3dda: e7ff         	b	0x700a3ddc <Udma_rmAllocRxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxUhcCh;
700a3ddc: 9807         	ldr	r0, [sp, #0x1c]
700a3dde: 9900         	ldr	r1, [sp]
700a3de0: 6b09         	ldr	r1, [r1, #0x30]
700a3de2: 1a40         	subs	r0, r0, r1
700a3de4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3de6: 9805         	ldr	r0, [sp, #0x14]
700a3de8: 0940         	lsrs	r0, r0, #0x5
700a3dea: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3dec: 9805         	ldr	r0, [sp, #0x14]
700a3dee: 9904         	ldr	r1, [sp, #0x10]
700a3df0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3df4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3df6: 9903         	ldr	r1, [sp, #0xc]
700a3df8: 2001         	movs	r0, #0x1
700a3dfa: 4088         	lsls	r0, r1
700a3dfc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a3dfe: 9806         	ldr	r0, [sp, #0x18]
700a3e00: 9904         	ldr	r1, [sp, #0x10]
700a3e02: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3e06: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a3e0a: 9902         	ldr	r1, [sp, #0x8]
700a3e0c: 4008         	ands	r0, r1
700a3e0e: 4288         	cmp	r0, r1
700a3e10: d10d         	bne	0x700a3e2e <Udma_rmAllocRxUhcCh+0x10e> @ imm = #0x1a
700a3e12: e7ff         	b	0x700a3e14 <Udma_rmAllocRxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a3e14: 9a02         	ldr	r2, [sp, #0x8]
700a3e16: 9806         	ldr	r0, [sp, #0x18]
700a3e18: 9904         	ldr	r1, [sp, #0x10]
700a3e1a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3e1e: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a3e22: 4390         	bics	r0, r2
700a3e24: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = preferredChNum;
700a3e28: 9807         	ldr	r0, [sp, #0x1c]
700a3e2a: 9001         	str	r0, [sp, #0x4]
;             }
700a3e2c: e7ff         	b	0x700a3e2e <Udma_rmAllocRxUhcCh+0x10e> @ imm = #-0x2
;         }
700a3e2e: e7ff         	b	0x700a3e30 <Udma_rmAllocRxUhcCh+0x110> @ imm = #-0x2
700a3e30: e7ff         	b	0x700a3e32 <Udma_rmAllocRxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3e32: 9806         	ldr	r0, [sp, #0x18]
700a3e34: f500 609f    	add.w	r0, r0, #0x4f8
700a3e38: f007 ffba    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x7f74
;     return (chNum);
700a3e3c: 9801         	ldr	r0, [sp, #0x4]
700a3e3e: b008         	add	sp, #0x20
700a3e40: bd80         	pop	{r7, pc}
		...
700a3e4e: 0000         	movs	r0, r0

700a3e50 <Udma_rmAllocTxCh>:
; {
700a3e50: b580         	push	{r7, lr}
700a3e52: b088         	sub	sp, #0x20
700a3e54: 9007         	str	r0, [sp, #0x1c]
700a3e56: 9106         	str	r1, [sp, #0x18]
700a3e58: 2000         	movs	r0, #0x0
700a3e5a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3e5e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3e60: 9806         	ldr	r0, [sp, #0x18]
700a3e62: f500 70ea    	add.w	r0, r0, #0x1d4
700a3e66: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3e68: 9806         	ldr	r0, [sp, #0x18]
700a3e6a: f500 609f    	add.w	r0, r0, #0x4f8
700a3e6e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3e72: f006 fbd5    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x67aa
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3e76: 9807         	ldr	r0, [sp, #0x1c]
700a3e78: 2101         	movs	r1, #0x1
700a3e7a: f6cf 71ff    	movt	r1, #0xffff
700a3e7e: 4288         	cmp	r0, r1
700a3e80: d136         	bne	0x700a3ef0 <Udma_rmAllocTxCh+0xa0> @ imm = #0x6c
700a3e82: e7ff         	b	0x700a3e84 <Udma_rmAllocTxCh+0x34> @ imm = #-0x2
700a3e84: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a3e86: 9005         	str	r0, [sp, #0x14]
700a3e88: e7ff         	b	0x700a3e8a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x2
700a3e8a: 9805         	ldr	r0, [sp, #0x14]
700a3e8c: 9900         	ldr	r1, [sp]
700a3e8e: 6ac9         	ldr	r1, [r1, #0x2c]
700a3e90: 4288         	cmp	r0, r1
700a3e92: d22c         	bhs	0x700a3eee <Udma_rmAllocTxCh+0x9e> @ imm = #0x58
700a3e94: e7ff         	b	0x700a3e96 <Udma_rmAllocTxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3e96: 9805         	ldr	r0, [sp, #0x14]
700a3e98: 0940         	lsrs	r0, r0, #0x5
700a3e9a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3e9c: 9805         	ldr	r0, [sp, #0x14]
700a3e9e: 9904         	ldr	r1, [sp, #0x10]
700a3ea0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3ea4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3ea6: 9903         	ldr	r1, [sp, #0xc]
700a3ea8: 2001         	movs	r0, #0x1
700a3eaa: 4088         	lsls	r0, r1
700a3eac: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a3eae: 9806         	ldr	r0, [sp, #0x18]
700a3eb0: 9904         	ldr	r1, [sp, #0x10]
700a3eb2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3eb6: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a3eba: 9902         	ldr	r1, [sp, #0x8]
700a3ebc: 4008         	ands	r0, r1
700a3ebe: 4288         	cmp	r0, r1
700a3ec0: d110         	bne	0x700a3ee4 <Udma_rmAllocTxCh+0x94> @ imm = #0x20
700a3ec2: e7ff         	b	0x700a3ec4 <Udma_rmAllocTxCh+0x74> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a3ec4: 9a02         	ldr	r2, [sp, #0x8]
700a3ec6: 9806         	ldr	r0, [sp, #0x18]
700a3ec8: 9904         	ldr	r1, [sp, #0x10]
700a3eca: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3ece: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a3ed2: 4390         	bics	r0, r2
700a3ed4: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = i + rmInitPrms->startTxCh;  /* Add start offset */
700a3ed8: 9805         	ldr	r0, [sp, #0x14]
700a3eda: 9900         	ldr	r1, [sp]
700a3edc: 6a89         	ldr	r1, [r1, #0x28]
700a3ede: 4408         	add	r0, r1
700a3ee0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3ee2: e004         	b	0x700a3eee <Udma_rmAllocTxCh+0x9e> @ imm = #0x8
;         }
700a3ee4: e7ff         	b	0x700a3ee6 <Udma_rmAllocTxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a3ee6: 9805         	ldr	r0, [sp, #0x14]
700a3ee8: 3001         	adds	r0, #0x1
700a3eea: 9005         	str	r0, [sp, #0x14]
700a3eec: e7cd         	b	0x700a3e8a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x66
;     }
700a3eee: e038         	b	0x700a3f62 <Udma_rmAllocTxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a3ef0: 9807         	ldr	r0, [sp, #0x1c]
700a3ef2: 9900         	ldr	r1, [sp]
700a3ef4: 6a89         	ldr	r1, [r1, #0x28]
700a3ef6: 4288         	cmp	r0, r1
700a3ef8: d332         	blo	0x700a3f60 <Udma_rmAllocTxCh+0x110> @ imm = #0x64
700a3efa: e7ff         	b	0x700a3efc <Udma_rmAllocTxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxCh + rmInitPrms->numTxCh)))
700a3efc: 9807         	ldr	r0, [sp, #0x1c]
700a3efe: 9a00         	ldr	r2, [sp]
700a3f00: 6a91         	ldr	r1, [r2, #0x28]
700a3f02: 6ad2         	ldr	r2, [r2, #0x2c]
700a3f04: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a3f06: 4288         	cmp	r0, r1
700a3f08: d22a         	bhs	0x700a3f60 <Udma_rmAllocTxCh+0x110> @ imm = #0x54
700a3f0a: e7ff         	b	0x700a3f0c <Udma_rmAllocTxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxCh;
700a3f0c: 9807         	ldr	r0, [sp, #0x1c]
700a3f0e: 9900         	ldr	r1, [sp]
700a3f10: 6a89         	ldr	r1, [r1, #0x28]
700a3f12: 1a40         	subs	r0, r0, r1
700a3f14: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3f16: 9805         	ldr	r0, [sp, #0x14]
700a3f18: 0940         	lsrs	r0, r0, #0x5
700a3f1a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3f1c: 9805         	ldr	r0, [sp, #0x14]
700a3f1e: 9904         	ldr	r1, [sp, #0x10]
700a3f20: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3f24: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3f26: 9903         	ldr	r1, [sp, #0xc]
700a3f28: 2001         	movs	r0, #0x1
700a3f2a: 4088         	lsls	r0, r1
700a3f2c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a3f2e: 9806         	ldr	r0, [sp, #0x18]
700a3f30: 9904         	ldr	r1, [sp, #0x10]
700a3f32: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3f36: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a3f3a: 9902         	ldr	r1, [sp, #0x8]
700a3f3c: 4008         	ands	r0, r1
700a3f3e: 4288         	cmp	r0, r1
700a3f40: d10d         	bne	0x700a3f5e <Udma_rmAllocTxCh+0x10e> @ imm = #0x1a
700a3f42: e7ff         	b	0x700a3f44 <Udma_rmAllocTxCh+0xf4> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a3f44: 9a02         	ldr	r2, [sp, #0x8]
700a3f46: 9806         	ldr	r0, [sp, #0x18]
700a3f48: 9904         	ldr	r1, [sp, #0x10]
700a3f4a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3f4e: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a3f52: 4390         	bics	r0, r2
700a3f54: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = preferredChNum;
700a3f58: 9807         	ldr	r0, [sp, #0x1c]
700a3f5a: 9001         	str	r0, [sp, #0x4]
;             }
700a3f5c: e7ff         	b	0x700a3f5e <Udma_rmAllocTxCh+0x10e> @ imm = #-0x2
;         }
700a3f5e: e7ff         	b	0x700a3f60 <Udma_rmAllocTxCh+0x110> @ imm = #-0x2
700a3f60: e7ff         	b	0x700a3f62 <Udma_rmAllocTxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3f62: 9806         	ldr	r0, [sp, #0x18]
700a3f64: f500 609f    	add.w	r0, r0, #0x4f8
700a3f68: f007 ff22    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x7e44
;     return (chNum);
700a3f6c: 9801         	ldr	r0, [sp, #0x4]
700a3f6e: b008         	add	sp, #0x20
700a3f70: bd80         	pop	{r7, pc}
		...
700a3f7e: 0000         	movs	r0, r0

700a3f80 <Udma_rmAllocTxHcCh>:
; {
700a3f80: b580         	push	{r7, lr}
700a3f82: b088         	sub	sp, #0x20
700a3f84: 9007         	str	r0, [sp, #0x1c]
700a3f86: 9106         	str	r1, [sp, #0x18]
700a3f88: 2000         	movs	r0, #0x0
700a3f8a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3f8e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3f90: 9806         	ldr	r0, [sp, #0x18]
700a3f92: f500 70ea    	add.w	r0, r0, #0x1d4
700a3f96: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3f98: 9806         	ldr	r0, [sp, #0x18]
700a3f9a: f500 609f    	add.w	r0, r0, #0x4f8
700a3f9e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3fa2: f006 fb3d    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x667a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3fa6: 9807         	ldr	r0, [sp, #0x1c]
700a3fa8: 2101         	movs	r1, #0x1
700a3faa: f6cf 71ff    	movt	r1, #0xffff
700a3fae: 4288         	cmp	r0, r1
700a3fb0: d136         	bne	0x700a4020 <Udma_rmAllocTxHcCh+0xa0> @ imm = #0x6c
700a3fb2: e7ff         	b	0x700a3fb4 <Udma_rmAllocTxHcCh+0x34> @ imm = #-0x2
700a3fb4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a3fb6: 9005         	str	r0, [sp, #0x14]
700a3fb8: e7ff         	b	0x700a3fba <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x2
700a3fba: 9805         	ldr	r0, [sp, #0x14]
700a3fbc: 9900         	ldr	r1, [sp]
700a3fbe: 6a49         	ldr	r1, [r1, #0x24]
700a3fc0: 4288         	cmp	r0, r1
700a3fc2: d22c         	bhs	0x700a401e <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x58
700a3fc4: e7ff         	b	0x700a3fc6 <Udma_rmAllocTxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3fc6: 9805         	ldr	r0, [sp, #0x14]
700a3fc8: 0940         	lsrs	r0, r0, #0x5
700a3fca: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3fcc: 9805         	ldr	r0, [sp, #0x14]
700a3fce: 9904         	ldr	r1, [sp, #0x10]
700a3fd0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3fd4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3fd6: 9903         	ldr	r1, [sp, #0xc]
700a3fd8: 2001         	movs	r0, #0x1
700a3fda: 4088         	lsls	r0, r1
700a3fdc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a3fde: 9806         	ldr	r0, [sp, #0x18]
700a3fe0: 9904         	ldr	r1, [sp, #0x10]
700a3fe2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3fe6: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a3fea: 9902         	ldr	r1, [sp, #0x8]
700a3fec: 4008         	ands	r0, r1
700a3fee: 4288         	cmp	r0, r1
700a3ff0: d110         	bne	0x700a4014 <Udma_rmAllocTxHcCh+0x94> @ imm = #0x20
700a3ff2: e7ff         	b	0x700a3ff4 <Udma_rmAllocTxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a3ff4: 9a02         	ldr	r2, [sp, #0x8]
700a3ff6: 9806         	ldr	r0, [sp, #0x18]
700a3ff8: 9904         	ldr	r1, [sp, #0x10]
700a3ffa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3ffe: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a4002: 4390         	bics	r0, r2
700a4004: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = i + rmInitPrms->startTxHcCh;  /* Add start offset */
700a4008: 9805         	ldr	r0, [sp, #0x14]
700a400a: 9900         	ldr	r1, [sp]
700a400c: 6a09         	ldr	r1, [r1, #0x20]
700a400e: 4408         	add	r0, r1
700a4010: 9001         	str	r0, [sp, #0x4]
;                 break;
700a4012: e004         	b	0x700a401e <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x8
;         }
700a4014: e7ff         	b	0x700a4016 <Udma_rmAllocTxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a4016: 9805         	ldr	r0, [sp, #0x14]
700a4018: 3001         	adds	r0, #0x1
700a401a: 9005         	str	r0, [sp, #0x14]
700a401c: e7cd         	b	0x700a3fba <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x66
;     }
700a401e: e038         	b	0x700a4092 <Udma_rmAllocTxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a4020: 9807         	ldr	r0, [sp, #0x1c]
700a4022: 9900         	ldr	r1, [sp]
700a4024: 6a09         	ldr	r1, [r1, #0x20]
700a4026: 4288         	cmp	r0, r1
700a4028: d332         	blo	0x700a4090 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x64
700a402a: e7ff         	b	0x700a402c <Udma_rmAllocTxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxHcCh + rmInitPrms->numTxHcCh)))
700a402c: 9807         	ldr	r0, [sp, #0x1c]
700a402e: 9a00         	ldr	r2, [sp]
700a4030: 6a11         	ldr	r1, [r2, #0x20]
700a4032: 6a52         	ldr	r2, [r2, #0x24]
700a4034: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a4036: 4288         	cmp	r0, r1
700a4038: d22a         	bhs	0x700a4090 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x54
700a403a: e7ff         	b	0x700a403c <Udma_rmAllocTxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxHcCh;
700a403c: 9807         	ldr	r0, [sp, #0x1c]
700a403e: 9900         	ldr	r1, [sp]
700a4040: 6a09         	ldr	r1, [r1, #0x20]
700a4042: 1a40         	subs	r0, r0, r1
700a4044: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a4046: 9805         	ldr	r0, [sp, #0x14]
700a4048: 0940         	lsrs	r0, r0, #0x5
700a404a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a404c: 9805         	ldr	r0, [sp, #0x14]
700a404e: 9904         	ldr	r1, [sp, #0x10]
700a4050: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4054: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4056: 9903         	ldr	r1, [sp, #0xc]
700a4058: 2001         	movs	r0, #0x1
700a405a: 4088         	lsls	r0, r1
700a405c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a405e: 9806         	ldr	r0, [sp, #0x18]
700a4060: 9904         	ldr	r1, [sp, #0x10]
700a4062: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4066: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a406a: 9902         	ldr	r1, [sp, #0x8]
700a406c: 4008         	ands	r0, r1
700a406e: 4288         	cmp	r0, r1
700a4070: d10d         	bne	0x700a408e <Udma_rmAllocTxHcCh+0x10e> @ imm = #0x1a
700a4072: e7ff         	b	0x700a4074 <Udma_rmAllocTxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a4074: 9a02         	ldr	r2, [sp, #0x8]
700a4076: 9806         	ldr	r0, [sp, #0x18]
700a4078: 9904         	ldr	r1, [sp, #0x10]
700a407a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a407e: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a4082: 4390         	bics	r0, r2
700a4084: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = preferredChNum;
700a4088: 9807         	ldr	r0, [sp, #0x1c]
700a408a: 9001         	str	r0, [sp, #0x4]
;             }
700a408c: e7ff         	b	0x700a408e <Udma_rmAllocTxHcCh+0x10e> @ imm = #-0x2
;         }
700a408e: e7ff         	b	0x700a4090 <Udma_rmAllocTxHcCh+0x110> @ imm = #-0x2
700a4090: e7ff         	b	0x700a4092 <Udma_rmAllocTxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a4092: 9806         	ldr	r0, [sp, #0x18]
700a4094: f500 609f    	add.w	r0, r0, #0x4f8
700a4098: f007 fe8a    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x7d14
;     return (chNum);
700a409c: 9801         	ldr	r0, [sp, #0x4]
700a409e: b008         	add	sp, #0x20
700a40a0: bd80         	pop	{r7, pc}
		...
700a40ae: 0000         	movs	r0, r0

700a40b0 <Udma_rmAllocTxUhcCh>:
; {
700a40b0: b580         	push	{r7, lr}
700a40b2: b088         	sub	sp, #0x20
700a40b4: 9007         	str	r0, [sp, #0x1c]
700a40b6: 9106         	str	r1, [sp, #0x18]
700a40b8: 2000         	movs	r0, #0x0
700a40ba: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a40be: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a40c0: 9806         	ldr	r0, [sp, #0x18]
700a40c2: f500 70ea    	add.w	r0, r0, #0x1d4
700a40c6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a40c8: 9806         	ldr	r0, [sp, #0x18]
700a40ca: f500 609f    	add.w	r0, r0, #0x4f8
700a40ce: f04f 31ff    	mov.w	r1, #0xffffffff
700a40d2: f006 faa5    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x654a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a40d6: 9807         	ldr	r0, [sp, #0x1c]
700a40d8: 2101         	movs	r1, #0x1
700a40da: f6cf 71ff    	movt	r1, #0xffff
700a40de: 4288         	cmp	r0, r1
700a40e0: d136         	bne	0x700a4150 <Udma_rmAllocTxUhcCh+0xa0> @ imm = #0x6c
700a40e2: e7ff         	b	0x700a40e4 <Udma_rmAllocTxUhcCh+0x34> @ imm = #-0x2
700a40e4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a40e6: 9005         	str	r0, [sp, #0x14]
700a40e8: e7ff         	b	0x700a40ea <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x2
700a40ea: 9805         	ldr	r0, [sp, #0x14]
700a40ec: 9900         	ldr	r1, [sp]
700a40ee: 69c9         	ldr	r1, [r1, #0x1c]
700a40f0: 4288         	cmp	r0, r1
700a40f2: d22c         	bhs	0x700a414e <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x58
700a40f4: e7ff         	b	0x700a40f6 <Udma_rmAllocTxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a40f6: 9805         	ldr	r0, [sp, #0x14]
700a40f8: 0940         	lsrs	r0, r0, #0x5
700a40fa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a40fc: 9805         	ldr	r0, [sp, #0x14]
700a40fe: 9904         	ldr	r1, [sp, #0x10]
700a4100: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4104: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4106: 9903         	ldr	r1, [sp, #0xc]
700a4108: 2001         	movs	r0, #0x1
700a410a: 4088         	lsls	r0, r1
700a410c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a410e: 9806         	ldr	r0, [sp, #0x18]
700a4110: 9904         	ldr	r1, [sp, #0x10]
700a4112: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4116: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a411a: 9902         	ldr	r1, [sp, #0x8]
700a411c: 4008         	ands	r0, r1
700a411e: 4288         	cmp	r0, r1
700a4120: d110         	bne	0x700a4144 <Udma_rmAllocTxUhcCh+0x94> @ imm = #0x20
700a4122: e7ff         	b	0x700a4124 <Udma_rmAllocTxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a4124: 9a02         	ldr	r2, [sp, #0x8]
700a4126: 9806         	ldr	r0, [sp, #0x18]
700a4128: 9904         	ldr	r1, [sp, #0x10]
700a412a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a412e: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a4132: 4390         	bics	r0, r2
700a4134: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = i + rmInitPrms->startTxUhcCh;  /* Add start offset */
700a4138: 9805         	ldr	r0, [sp, #0x14]
700a413a: 9900         	ldr	r1, [sp]
700a413c: 6989         	ldr	r1, [r1, #0x18]
700a413e: 4408         	add	r0, r1
700a4140: 9001         	str	r0, [sp, #0x4]
;                 break;
700a4142: e004         	b	0x700a414e <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x8
;         }
700a4144: e7ff         	b	0x700a4146 <Udma_rmAllocTxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a4146: 9805         	ldr	r0, [sp, #0x14]
700a4148: 3001         	adds	r0, #0x1
700a414a: 9005         	str	r0, [sp, #0x14]
700a414c: e7cd         	b	0x700a40ea <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x66
;     }
700a414e: e038         	b	0x700a41c2 <Udma_rmAllocTxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a4150: 9807         	ldr	r0, [sp, #0x1c]
700a4152: 9900         	ldr	r1, [sp]
700a4154: 6989         	ldr	r1, [r1, #0x18]
700a4156: 4288         	cmp	r0, r1
700a4158: d332         	blo	0x700a41c0 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x64
700a415a: e7ff         	b	0x700a415c <Udma_rmAllocTxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxUhcCh + rmInitPrms->numTxUhcCh)))
700a415c: 9807         	ldr	r0, [sp, #0x1c]
700a415e: 9a00         	ldr	r2, [sp]
700a4160: 6991         	ldr	r1, [r2, #0x18]
700a4162: 69d2         	ldr	r2, [r2, #0x1c]
700a4164: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a4166: 4288         	cmp	r0, r1
700a4168: d22a         	bhs	0x700a41c0 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x54
700a416a: e7ff         	b	0x700a416c <Udma_rmAllocTxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxUhcCh;
700a416c: 9807         	ldr	r0, [sp, #0x1c]
700a416e: 9900         	ldr	r1, [sp]
700a4170: 6989         	ldr	r1, [r1, #0x18]
700a4172: 1a40         	subs	r0, r0, r1
700a4174: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a4176: 9805         	ldr	r0, [sp, #0x14]
700a4178: 0940         	lsrs	r0, r0, #0x5
700a417a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a417c: 9805         	ldr	r0, [sp, #0x14]
700a417e: 9904         	ldr	r1, [sp, #0x10]
700a4180: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4184: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4186: 9903         	ldr	r1, [sp, #0xc]
700a4188: 2001         	movs	r0, #0x1
700a418a: 4088         	lsls	r0, r1
700a418c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a418e: 9806         	ldr	r0, [sp, #0x18]
700a4190: 9904         	ldr	r1, [sp, #0x10]
700a4192: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4196: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a419a: 9902         	ldr	r1, [sp, #0x8]
700a419c: 4008         	ands	r0, r1
700a419e: 4288         	cmp	r0, r1
700a41a0: d10d         	bne	0x700a41be <Udma_rmAllocTxUhcCh+0x10e> @ imm = #0x1a
700a41a2: e7ff         	b	0x700a41a4 <Udma_rmAllocTxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a41a4: 9a02         	ldr	r2, [sp, #0x8]
700a41a6: 9806         	ldr	r0, [sp, #0x18]
700a41a8: 9904         	ldr	r1, [sp, #0x10]
700a41aa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a41ae: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a41b2: 4390         	bics	r0, r2
700a41b4: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = preferredChNum;
700a41b8: 9807         	ldr	r0, [sp, #0x1c]
700a41ba: 9001         	str	r0, [sp, #0x4]
;             }
700a41bc: e7ff         	b	0x700a41be <Udma_rmAllocTxUhcCh+0x10e> @ imm = #-0x2
;         }
700a41be: e7ff         	b	0x700a41c0 <Udma_rmAllocTxUhcCh+0x110> @ imm = #-0x2
700a41c0: e7ff         	b	0x700a41c2 <Udma_rmAllocTxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a41c2: 9806         	ldr	r0, [sp, #0x18]
700a41c4: f500 609f    	add.w	r0, r0, #0x4f8
700a41c8: f007 fdf2    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x7be4
;     return (chNum);
700a41cc: 9801         	ldr	r0, [sp, #0x4]
700a41ce: b008         	add	sp, #0x20
700a41d0: bd80         	pop	{r7, pc}
		...
700a41de: 0000         	movs	r0, r0

700a41e0 <UART_udmaInitRxCh>:
; {
700a41e0: b580         	push	{r7, lr}
700a41e2: b0be         	sub	sp, #0xf8
700a41e4: 903d         	str	r0, [sp, #0xf4]
700a41e6: 913c         	str	r1, [sp, #0xf0]
700a41e8: 200a         	movs	r0, #0xa
;     chType = UDMA_CH_TYPE_PDMA_RX;
700a41ea: 903a         	str	r0, [sp, #0xe8]
;     UdmaChPrms_init(&chPrms, chType);
700a41ec: 993a         	ldr	r1, [sp, #0xe8]
700a41ee: a821         	add	r0, sp, #0x84
700a41f0: f007 f9b6    	bl	0x700ab560 <UdmaChPrms_init> @ imm = #0x736c
;     chPrms.peerChNum                = hUart->hUartInit->rxEvtNum;
700a41f4: 983d         	ldr	r0, [sp, #0xf4]
700a41f6: 6840         	ldr	r0, [r0, #0x4]
700a41f8: 6c00         	ldr	r0, [r0, #0x40]
700a41fa: 9022         	str	r0, [sp, #0x88]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->rxRingMem;
700a41fc: 983c         	ldr	r0, [sp, #0xf0]
700a41fe: 6a80         	ldr	r0, [r0, #0x28]
700a4200: 9025         	str	r0, [sp, #0x94]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a4202: 983c         	ldr	r0, [sp, #0xf0]
700a4204: 6b00         	ldr	r0, [r0, #0x30]
700a4206: 9026         	str	r0, [sp, #0x98]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a4208: 983c         	ldr	r0, [sp, #0xf0]
700a420a: 6b40         	ldr	r0, [r0, #0x34]
700a420c: 9028         	str	r0, [sp, #0xa0]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a420e: 983c         	ldr	r0, [sp, #0xf0]
700a4210: 6bc0         	ldr	r0, [r0, #0x3c]
700a4212: 2801         	cmp	r0, #0x1
700a4214: d10a         	bne	0x700a422c <UART_udmaInitRxCh+0x4c> @ imm = #0x14
700a4216: e7ff         	b	0x700a4218 <UART_udmaInitRxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqRxRingMem;
700a4218: 983c         	ldr	r0, [sp, #0xf0]
700a421a: 6ac0         	ldr	r0, [r0, #0x2c]
700a421c: 902c         	str	r0, [sp, #0xb0]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a421e: 983c         	ldr	r0, [sp, #0xf0]
700a4220: 6b00         	ldr	r0, [r0, #0x30]
700a4222: 902d         	str	r0, [sp, #0xb4]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a4224: 983c         	ldr	r0, [sp, #0xf0]
700a4226: 6b40         	ldr	r0, [r0, #0x34]
700a4228: 902f         	str	r0, [sp, #0xbc]
;     }
700a422a: e7ff         	b	0x700a422c <UART_udmaInitRxCh+0x4c> @ imm = #-0x2
;     rxChHandle                      = udmaChCfg->rxChHandle;
700a422c: 983c         	ldr	r0, [sp, #0xf0]
700a422e: 6880         	ldr	r0, [r0, #0x8]
700a4230: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a4232: 983c         	ldr	r0, [sp, #0xf0]
700a4234: 6800         	ldr	r0, [r0]
700a4236: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, rxChHandle, chType, &chPrms);
700a4238: 9807         	ldr	r0, [sp, #0x1c]
700a423a: 9906         	ldr	r1, [sp, #0x18]
700a423c: 9a3a         	ldr	r2, [sp, #0xe8]
700a423e: ab21         	add	r3, sp, #0x84
700a4240: f7fd fa7e    	bl	0x700a1740 <Udma_chOpen> @ imm = #-0x2b04
700a4244: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a4246: 983b         	ldr	r0, [sp, #0xec]
700a4248: fab0 f080    	clz	r0, r0
700a424c: 0940         	lsrs	r0, r0, #0x5
700a424e: f641 718f    	movw	r1, #0x1f8f
700a4252: f2c7 010b    	movt	r1, #0x700b
700a4256: 9103         	str	r1, [sp, #0xc]
700a4258: 466a         	mov	r2, sp
700a425a: 6011         	str	r1, [r2]
700a425c: f641 3191    	movw	r1, #0x1b91
700a4260: f2c7 010b    	movt	r1, #0x700b
700a4264: 9104         	str	r1, [sp, #0x10]
700a4266: f242 0213    	movw	r2, #0x2013
700a426a: f2c7 020b    	movt	r2, #0x700b
700a426e: 9205         	str	r2, [sp, #0x14]
700a4270: 2366         	movs	r3, #0x66
700a4272: f006 fc2d    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x685a
;     UdmaChRxPrms_init(&rxPrms, chType);
700a4276: 993a         	ldr	r1, [sp, #0xe8]
700a4278: a81a         	add	r0, sp, #0x68
700a427a: 9001         	str	r0, [sp, #0x4]
700a427c: f003 fde0    	bl	0x700a7e40 <UdmaChRxPrms_init> @ imm = #0x3bc0
700a4280: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigRx(rxChHandle, &rxPrms);
700a4282: 9806         	ldr	r0, [sp, #0x18]
700a4284: f7f9 fcdc    	bl	0x7009dc40 <Udma_chConfigRx> @ imm = #-0x6648
700a4288: 9b03         	ldr	r3, [sp, #0xc]
700a428a: 9904         	ldr	r1, [sp, #0x10]
700a428c: 9a05         	ldr	r2, [sp, #0x14]
700a428e: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a4290: 983b         	ldr	r0, [sp, #0xec]
700a4292: fab0 f080    	clz	r0, r0
700a4296: 0940         	lsrs	r0, r0, #0x5
700a4298: 46ec         	mov	r12, sp
700a429a: f8cc 3000    	str.w	r3, [r12]
700a429e: 236b         	movs	r3, #0x6b
700a42a0: f006 fc16    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x682c
;     eventHandle = udmaChCfg->cqRxEvtHandle;
700a42a4: 983c         	ldr	r0, [sp, #0xf0]
700a42a6: 6900         	ldr	r0, [r0, #0x10]
700a42a8: 9019         	str	r0, [sp, #0x64]
700a42aa: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a42ac: 9002         	str	r0, [sp, #0x8]
700a42ae: f007 fdb7    	bl	0x700abe20 <UdmaEventPrms_init> @ imm = #0x7b6e
700a42b2: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a42b4: 9008         	str	r0, [sp, #0x20]
700a42b6: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a42b8: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = rxChHandle;
700a42ba: 9806         	ldr	r0, [sp, #0x18]
700a42bc: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a42be: 9807         	ldr	r0, [sp, #0x1c]
700a42c0: f008 fcae    	bl	0x700acc20 <Udma_eventGetGlobalHandle> @ imm = #0x895c
700a42c4: 9a02         	ldr	r2, [sp, #0x8]
700a42c6: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrRx;
700a42c8: f249 50c1    	movw	r0, #0x95c1
700a42cc: f2c7 000a    	movt	r0, #0x700a
700a42d0: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a42d2: 983d         	ldr	r0, [sp, #0xf4]
700a42d4: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a42d6: 9807         	ldr	r0, [sp, #0x1c]
700a42d8: 9919         	ldr	r1, [sp, #0x64]
700a42da: f7fa fa69    	bl	0x7009e7b0 <Udma_eventRegister> @ imm = #-0x5b2e
700a42de: 9b03         	ldr	r3, [sp, #0xc]
700a42e0: 9904         	ldr	r1, [sp, #0x10]
700a42e2: 9a05         	ldr	r2, [sp, #0x14]
700a42e4: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a42e6: 983b         	ldr	r0, [sp, #0xec]
700a42e8: fab0 f080    	clz	r0, r0
700a42ec: 0940         	lsrs	r0, r0, #0x5
700a42ee: 46ec         	mov	r12, sp
700a42f0: f8cc 3000    	str.w	r3, [r12]
700a42f4: 2377         	movs	r3, #0x77
700a42f6: f006 fbeb    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x67d6
;     return retVal;
700a42fa: 983b         	ldr	r0, [sp, #0xec]
700a42fc: b03e         	add	sp, #0xf8
700a42fe: bd80         	pop	{r7, pc}

700a4300 <UART_udmaInitTxCh>:
; {
700a4300: b580         	push	{r7, lr}
700a4302: b0bc         	sub	sp, #0xf0
700a4304: 903b         	str	r0, [sp, #0xec]
700a4306: 913a         	str	r1, [sp, #0xe8]
700a4308: 2009         	movs	r0, #0x9
;     chType = UDMA_CH_TYPE_PDMA_TX;
700a430a: 9038         	str	r0, [sp, #0xe0]
;     UdmaChPrms_init(&chPrms, chType);
700a430c: 9938         	ldr	r1, [sp, #0xe0]
700a430e: a81f         	add	r0, sp, #0x7c
700a4310: f007 f926    	bl	0x700ab560 <UdmaChPrms_init> @ imm = #0x724c
;     chPrms.peerChNum                = hUart->hUartInit->txEvtNum;
700a4314: 983b         	ldr	r0, [sp, #0xec]
700a4316: 6840         	ldr	r0, [r0, #0x4]
700a4318: 6c40         	ldr	r0, [r0, #0x44]
700a431a: 9020         	str	r0, [sp, #0x80]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->txRingMem;
700a431c: 983a         	ldr	r0, [sp, #0xe8]
700a431e: 6a00         	ldr	r0, [r0, #0x20]
700a4320: 9023         	str	r0, [sp, #0x8c]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a4322: 983a         	ldr	r0, [sp, #0xe8]
700a4324: 6b00         	ldr	r0, [r0, #0x30]
700a4326: 9024         	str	r0, [sp, #0x90]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a4328: 983a         	ldr	r0, [sp, #0xe8]
700a432a: 6b40         	ldr	r0, [r0, #0x34]
700a432c: 9026         	str	r0, [sp, #0x98]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a432e: 983a         	ldr	r0, [sp, #0xe8]
700a4330: 6bc0         	ldr	r0, [r0, #0x3c]
700a4332: 2801         	cmp	r0, #0x1
700a4334: d10a         	bne	0x700a434c <UART_udmaInitTxCh+0x4c> @ imm = #0x14
700a4336: e7ff         	b	0x700a4338 <UART_udmaInitTxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqTxRingMem;
700a4338: 983a         	ldr	r0, [sp, #0xe8]
700a433a: 6a40         	ldr	r0, [r0, #0x24]
700a433c: 902a         	str	r0, [sp, #0xa8]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a433e: 983a         	ldr	r0, [sp, #0xe8]
700a4340: 6b00         	ldr	r0, [r0, #0x30]
700a4342: 902b         	str	r0, [sp, #0xac]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a4344: 983a         	ldr	r0, [sp, #0xe8]
700a4346: 6b40         	ldr	r0, [r0, #0x34]
700a4348: 902d         	str	r0, [sp, #0xb4]
;     }
700a434a: e7ff         	b	0x700a434c <UART_udmaInitTxCh+0x4c> @ imm = #-0x2
;     txChHandle                      = udmaChCfg->txChHandle;
700a434c: 983a         	ldr	r0, [sp, #0xe8]
700a434e: 6840         	ldr	r0, [r0, #0x4]
700a4350: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a4352: 983a         	ldr	r0, [sp, #0xe8]
700a4354: 6800         	ldr	r0, [r0]
700a4356: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, txChHandle, chType, &chPrms);
700a4358: 9807         	ldr	r0, [sp, #0x1c]
700a435a: 9906         	ldr	r1, [sp, #0x18]
700a435c: 9a38         	ldr	r2, [sp, #0xe0]
700a435e: ab1f         	add	r3, sp, #0x7c
700a4360: f7fd f9ee    	bl	0x700a1740 <Udma_chOpen> @ imm = #-0x2c24
700a4364: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a4366: 9839         	ldr	r0, [sp, #0xe4]
700a4368: fab0 f080    	clz	r0, r0
700a436c: 0940         	lsrs	r0, r0, #0x5
700a436e: f641 718f    	movw	r1, #0x1f8f
700a4372: f2c7 010b    	movt	r1, #0x700b
700a4376: 9103         	str	r1, [sp, #0xc]
700a4378: 466a         	mov	r2, sp
700a437a: 6011         	str	r1, [r2]
700a437c: f641 3191    	movw	r1, #0x1b91
700a4380: f2c7 010b    	movt	r1, #0x700b
700a4384: 9104         	str	r1, [sp, #0x10]
700a4386: f242 0249    	movw	r2, #0x2049
700a438a: f2c7 020b    	movt	r2, #0x700b
700a438e: 9205         	str	r2, [sp, #0x14]
700a4390: 2398         	movs	r3, #0x98
700a4392: f006 fb9d    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x673a
;     UdmaChTxPrms_init(&txPrms, chType);
700a4396: 9938         	ldr	r1, [sp, #0xe0]
700a4398: a81a         	add	r0, sp, #0x68
700a439a: 9001         	str	r0, [sp, #0x4]
700a439c: f003 fda8    	bl	0x700a7ef0 <UdmaChTxPrms_init> @ imm = #0x3b50
700a43a0: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigTx(txChHandle, &txPrms);
700a43a2: 9806         	ldr	r0, [sp, #0x18]
700a43a4: f7fb ffdc    	bl	0x700a0360 <Udma_chConfigTx> @ imm = #-0x4048
700a43a8: 9b03         	ldr	r3, [sp, #0xc]
700a43aa: 9904         	ldr	r1, [sp, #0x10]
700a43ac: 9a05         	ldr	r2, [sp, #0x14]
700a43ae: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a43b0: 9839         	ldr	r0, [sp, #0xe4]
700a43b2: fab0 f080    	clz	r0, r0
700a43b6: 0940         	lsrs	r0, r0, #0x5
700a43b8: 46ec         	mov	r12, sp
700a43ba: f8cc 3000    	str.w	r3, [r12]
700a43be: 239d         	movs	r3, #0x9d
700a43c0: f006 fb86    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x670c
;     eventHandle = udmaChCfg->cqTxEvtHandle;
700a43c4: 983a         	ldr	r0, [sp, #0xe8]
700a43c6: 68c0         	ldr	r0, [r0, #0xc]
700a43c8: 9019         	str	r0, [sp, #0x64]
700a43ca: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a43cc: 9002         	str	r0, [sp, #0x8]
700a43ce: f007 fd27    	bl	0x700abe20 <UdmaEventPrms_init> @ imm = #0x7a4e
700a43d2: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a43d4: 9008         	str	r0, [sp, #0x20]
700a43d6: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a43d8: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = txChHandle;
700a43da: 9806         	ldr	r0, [sp, #0x18]
700a43dc: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a43de: 9807         	ldr	r0, [sp, #0x1c]
700a43e0: f008 fc1e    	bl	0x700acc20 <Udma_eventGetGlobalHandle> @ imm = #0x883c
700a43e4: 9a02         	ldr	r2, [sp, #0x8]
700a43e6: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrTx;
700a43e8: f249 6061    	movw	r0, #0x9661
700a43ec: f2c7 000a    	movt	r0, #0x700a
700a43f0: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a43f2: 983b         	ldr	r0, [sp, #0xec]
700a43f4: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a43f6: 9807         	ldr	r0, [sp, #0x1c]
700a43f8: 9919         	ldr	r1, [sp, #0x64]
700a43fa: f7fa f9d9    	bl	0x7009e7b0 <Udma_eventRegister> @ imm = #-0x5c4e
700a43fe: 9b03         	ldr	r3, [sp, #0xc]
700a4400: 9904         	ldr	r1, [sp, #0x10]
700a4402: 9a05         	ldr	r2, [sp, #0x14]
700a4404: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a4406: 9839         	ldr	r0, [sp, #0xe4]
700a4408: fab0 f080    	clz	r0, r0
700a440c: 0940         	lsrs	r0, r0, #0x5
700a440e: 46ec         	mov	r12, sp
700a4410: f8cc 3000    	str.w	r3, [r12]
700a4414: 23a9         	movs	r3, #0xa9
700a4416: f006 fb5b    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x66b6
;     return retVal;
700a441a: 9839         	ldr	r0, [sp, #0xe4]
700a441c: b03c         	add	sp, #0xf0
700a441e: bd80         	pop	{r7, pc}

700a4420 <Sciclient_rmIaValidateEvt>:
; {
700a4420: b580         	push	{r7, lr}
700a4422: b086         	sub	sp, #0x18
700a4424: 4684         	mov	r12, r0
700a4426: 9808         	ldr	r0, [sp, #0x20]
700a4428: f8cd c014    	str.w	r12, [sp, #0x14]
700a442c: f8ad 1012    	strh.w	r1, [sp, #0x12]
700a4430: f8ad 2010    	strh.w	r2, [sp, #0x10]
700a4434: f88d 300f    	strb.w	r3, [sp, #0xf]
700a4438: f88d 000e    	strb.w	r0, [sp, #0xe]
700a443c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a443e: 9002         	str	r0, [sp, #0x8]
;     if (evt >= inst->n_sevt) {
700a4440: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a4444: 9905         	ldr	r1, [sp, #0x14]
700a4446: 8949         	ldrh	r1, [r1, #0xa]
700a4448: 4288         	cmp	r0, r1
700a444a: db04         	blt	0x700a4456 <Sciclient_rmIaValidateEvt+0x36> @ imm = #0x8
700a444c: e7ff         	b	0x700a444e <Sciclient_rmIaValidateEvt+0x2e> @ imm = #-0x2
700a444e: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a4452: 9002         	str	r0, [sp, #0x8]
;     }
700a4454: e7ff         	b	0x700a4456 <Sciclient_rmIaValidateEvt+0x36> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a4456: 9802         	ldr	r0, [sp, #0x8]
700a4458: 2800         	cmp	r0, #0x0
700a445a: d16d         	bne	0x700a4538 <Sciclient_rmIaValidateEvt+0x118> @ imm = #0xda
700a445c: e7ff         	b	0x700a445e <Sciclient_rmIaValidateEvt+0x3e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a445e: 9805         	ldr	r0, [sp, #0x14]
700a4460: 6840         	ldr	r0, [r0, #0x4]
700a4462: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a4466: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a446a: 9001         	str	r0, [sp, #0x4]
;         if (in_use == true) {
700a446c: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700a4470: 07c0         	lsls	r0, r0, #0x1f
700a4472: 2800         	cmp	r0, #0x0
700a4474: d047         	beq	0x700a4506 <Sciclient_rmIaValidateEvt+0xe6> @ imm = #0x8e
700a4476: e7ff         	b	0x700a4478 <Sciclient_rmIaValidateEvt+0x58> @ imm = #-0x2
;             reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a4478: 9801         	ldr	r0, [sp, #0x4]
700a447a: f64f 7100    	movw	r1, #0xff00
700a447e: f2c0 0101    	movt	r1, #0x1
700a4482: 2208         	movs	r2, #0x8
700a4484: f00a fe24    	bl	0x700af0d0 <CSL_REG32_FEXT_RAW> @ imm = #0xac48
700a4488: f8ad 0002    	strh.w	r0, [sp, #0x2]
;             reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a448c: 9801         	ldr	r0, [sp, #0x4]
700a448e: 213f         	movs	r1, #0x3f
700a4490: 2200         	movs	r2, #0x0
700a4492: f00a fe1d    	bl	0x700af0d0 <CSL_REG32_FEXT_RAW> @ imm = #0xac3a
700a4496: f8ad 0000    	strh.w	r0, [sp]
;             if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a449a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a449e: b9f0         	cbnz	r0, 0x700a44de <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x3c
700a44a0: e7ff         	b	0x700a44a2 <Sciclient_rmIaValidateEvt+0x82> @ imm = #-0x2
700a44a2: f8bd 0000    	ldrh.w	r0, [sp]
700a44a6: b9d0         	cbnz	r0, 0x700a44de <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x34
700a44a8: e7ff         	b	0x700a44aa <Sciclient_rmIaValidateEvt+0x8a> @ imm = #-0x2
;                 if ((vint != reg_vint) &&
700a44aa: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a44ae: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a44b2: 4288         	cmp	r0, r1
700a44b4: d012         	beq	0x700a44dc <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x24
700a44b6: e7ff         	b	0x700a44b8 <Sciclient_rmIaValidateEvt+0x98> @ imm = #-0x2
;                     (vint_sb_index != reg_sb) &&
700a44b8: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a44bc: f8bd 1000    	ldrh.w	r1, [sp]
700a44c0: 4288         	cmp	r0, r1
700a44c2: d00b         	beq	0x700a44dc <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x16
700a44c4: e7ff         	b	0x700a44c6 <Sciclient_rmIaValidateEvt+0xa6> @ imm = #-0x2
;                     (evt != inst->v0_b0_evt)) {
700a44c6: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a44ca: 9905         	ldr	r1, [sp, #0x14]
700a44cc: 8a89         	ldrh	r1, [r1, #0x14]
;                 if ((vint != reg_vint) &&
700a44ce: 4288         	cmp	r0, r1
700a44d0: d004         	beq	0x700a44dc <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x8
700a44d2: e7ff         	b	0x700a44d4 <Sciclient_rmIaValidateEvt+0xb4> @ imm = #-0x2
700a44d4: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a44d8: 9002         	str	r0, [sp, #0x8]
;                 }
700a44da: e7ff         	b	0x700a44dc <Sciclient_rmIaValidateEvt+0xbc> @ imm = #-0x2
;             } else {
700a44dc: e012         	b	0x700a4504 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #0x24
;                 if ((vint != reg_vint) &&
700a44de: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a44e2: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a44e6: 4288         	cmp	r0, r1
700a44e8: d00b         	beq	0x700a4502 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x16
700a44ea: e7ff         	b	0x700a44ec <Sciclient_rmIaValidateEvt+0xcc> @ imm = #-0x2
;                     (vint_sb_index != reg_sb)) {
700a44ec: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a44f0: f8bd 1000    	ldrh.w	r1, [sp]
;                 if ((vint != reg_vint) &&
700a44f4: 4288         	cmp	r0, r1
700a44f6: d004         	beq	0x700a4502 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x8
700a44f8: e7ff         	b	0x700a44fa <Sciclient_rmIaValidateEvt+0xda> @ imm = #-0x2
700a44fa: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a44fe: 9002         	str	r0, [sp, #0x8]
;                 }
700a4500: e7ff         	b	0x700a4502 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #-0x2
700a4502: e7ff         	b	0x700a4504 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #-0x2
;         } else {
700a4504: e017         	b	0x700a4536 <Sciclient_rmIaValidateEvt+0x116> @ imm = #0x2e
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a4506: 9801         	ldr	r0, [sp, #0x4]
700a4508: f00b fb7a    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xb6f4
700a450c: b138         	cbz	r0, 0x700a451e <Sciclient_rmIaValidateEvt+0xfe> @ imm = #0xe
700a450e: e7ff         	b	0x700a4510 <Sciclient_rmIaValidateEvt+0xf0> @ imm = #-0x2
;                  (Sciclient_rmIaEvtRomMapped(inst, evt) == false)) ||
700a4510: 9805         	ldr	r0, [sp, #0x14]
700a4512: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a4516: f005 fcdb    	bl	0x700a9ed0 <Sciclient_rmIaEvtRomMapped> @ imm = #0x59b6
700a451a: b138         	cbz	r0, 0x700a452c <Sciclient_rmIaValidateEvt+0x10c> @ imm = #0xe
700a451c: e7ff         	b	0x700a451e <Sciclient_rmIaValidateEvt+0xfe> @ imm = #-0x2
;                 (evt == inst->v0_b0_evt)) {
700a451e: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a4522: 9905         	ldr	r1, [sp, #0x14]
700a4524: 8a89         	ldrh	r1, [r1, #0x14]
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a4526: 4288         	cmp	r0, r1
700a4528: d104         	bne	0x700a4534 <Sciclient_rmIaValidateEvt+0x114> @ imm = #0x8
700a452a: e7ff         	b	0x700a452c <Sciclient_rmIaValidateEvt+0x10c> @ imm = #-0x2
700a452c: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a4530: 9002         	str	r0, [sp, #0x8]
;             }
700a4532: e7ff         	b	0x700a4534 <Sciclient_rmIaValidateEvt+0x114> @ imm = #-0x2
700a4534: e7ff         	b	0x700a4536 <Sciclient_rmIaValidateEvt+0x116> @ imm = #-0x2
;     }
700a4536: e7ff         	b	0x700a4538 <Sciclient_rmIaValidateEvt+0x118> @ imm = #-0x2
;     return r;
700a4538: 9802         	ldr	r0, [sp, #0x8]
700a453a: b006         	add	sp, #0x18
700a453c: bd80         	pop	{r7, pc}
700a453e: 0000         	movs	r0, r0

700a4540 <Sciclient_rmIrqVintAdd>:
; {
700a4540: b580         	push	{r7, lr}
700a4542: b08c         	sub	sp, #0x30
700a4544: 900b         	str	r0, [sp, #0x2c]
700a4546: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a4548: 900a         	str	r0, [sp, #0x28]
;     bool cfg_new_mapping = false;
700a454a: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool cfg_whole_route = false;
700a454e: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a4552: 9008         	str	r0, [sp, #0x20]
;     r = Sciclient_rmIrqIsVintRouteSet(cfg, &vint_used);
700a4554: 980b         	ldr	r0, [sp, #0x2c]
700a4556: f10d 0127    	add.w	r1, sp, #0x27
700a455a: f002 fe21    	bl	0x700a71a0 <Sciclient_rmIrqIsVintRouteSet> @ imm = #0x2c42
700a455e: 900a         	str	r0, [sp, #0x28]
;     if (r == SystemP_SUCCESS) {
700a4560: 980a         	ldr	r0, [sp, #0x28]
700a4562: b9a0         	cbnz	r0, 0x700a458e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #0x28
700a4564: e7ff         	b	0x700a4566 <Sciclient_rmIrqVintAdd+0x26> @ imm = #-0x2
;         if ((vint_used == true) ||
700a4566: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a456a: 07c0         	lsls	r0, r0, #0x1f
700a456c: b930         	cbnz	r0, 0x700a457c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #0xc
700a456e: e7ff         	b	0x700a4570 <Sciclient_rmIrqVintAdd+0x30> @ imm = #-0x2
;             (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a4570: 980b         	ldr	r0, [sp, #0x2c]
700a4572: 6800         	ldr	r0, [r0]
700a4574: f007 f944    	bl	0x700ab800 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x7288
;         if ((vint_used == true) ||
700a4578: b120         	cbz	r0, 0x700a4584 <Sciclient_rmIrqVintAdd+0x44> @ imm = #0x8
700a457a: e7ff         	b	0x700a457c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #-0x2
700a457c: 2001         	movs	r0, #0x1
;             cfg_new_mapping = true;
700a457e: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a4582: e003         	b	0x700a458c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #0x6
700a4584: 2001         	movs	r0, #0x1
;             cfg_whole_route = true;
700a4586: f88d 0025    	strb.w	r0, [sp, #0x25]
700a458a: e7ff         	b	0x700a458c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #-0x2
;     }
700a458c: e7ff         	b	0x700a458e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #-0x2
;     if (cfg_new_mapping == true) {
700a458e: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a4592: 07c0         	lsls	r0, r0, #0x1f
700a4594: 2800         	cmp	r0, #0x0
700a4596: d04c         	beq	0x700a4632 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #0x98
700a4598: e7ff         	b	0x700a459a <Sciclient_rmIrqVintAdd+0x5a> @ imm = #-0x2
700a459a: 203c         	movs	r0, #0x3c
700a459c: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a45a0: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a45a2: 980b         	ldr	r0, [sp, #0x2c]
700a45a4: 7900         	ldrb	r0, [r0, #0x4]
700a45a6: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a45aa: 980b         	ldr	r0, [sp, #0x2c]
700a45ac: 88c0         	ldrh	r0, [r0, #0x6]
700a45ae: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a45b2: 980b         	ldr	r0, [sp, #0x2c]
700a45b4: 8900         	ldrh	r0, [r0, #0x8]
700a45b6: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a45ba: 980b         	ldr	r0, [sp, #0x2c]
700a45bc: 8a00         	ldrh	r0, [r0, #0x10]
700a45be: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a45c2: 980b         	ldr	r0, [sp, #0x2c]
700a45c4: 8a40         	ldrh	r0, [r0, #0x12]
700a45c6: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a45ca: 980b         	ldr	r0, [sp, #0x2c]
700a45cc: 89c0         	ldrh	r0, [r0, #0xe]
700a45ce: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a45d2: 980b         	ldr	r0, [sp, #0x2c]
700a45d4: 7d00         	ldrb	r0, [r0, #0x14]
700a45d6: f88d 001e    	strb.w	r0, [sp, #0x1e]
;                                   cfg->set_resp,
700a45da: 980b         	ldr	r0, [sp, #0x2c]
700a45dc: 6981         	ldr	r1, [r0, #0x18]
700a45de: a801         	add	r0, sp, #0x4
700a45e0: f04f 32ff    	mov.w	r2, #0xffffffff
;         r = Sciclient_rmIrqSetRaw(&req,
700a45e4: f008 f88c    	bl	0x700ac700 <Sciclient_rmIrqSetRaw> @ imm = #0x8118
700a45e8: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a45ea: 980a         	ldr	r0, [sp, #0x28]
700a45ec: bb00         	cbnz	r0, 0x700a4630 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #0x40
700a45ee: e7ff         	b	0x700a45f0 <Sciclient_rmIrqVintAdd+0xb0> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a45f0: 980b         	ldr	r0, [sp, #0x2c]
700a45f2: 8a00         	ldrh	r0, [r0, #0x10]
700a45f4: f007 ff04    	bl	0x700ac400 <Sciclient_rmIaGetInst> @ imm = #0x7e08
700a45f8: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a45fa: 9808         	ldr	r0, [sp, #0x20]
700a45fc: b1b8         	cbz	r0, 0x700a462e <Sciclient_rmIrqVintAdd+0xee> @ imm = #0x2e
700a45fe: e7ff         	b	0x700a4600 <Sciclient_rmIrqVintAdd+0xc0> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]++;
700a4600: 9808         	ldr	r0, [sp, #0x20]
700a4602: 6901         	ldr	r1, [r0, #0x10]
700a4604: 980b         	ldr	r0, [sp, #0x2c]
700a4606: 8a42         	ldrh	r2, [r0, #0x12]
700a4608: 5c88         	ldrb	r0, [r1, r2]
700a460a: 3001         	adds	r0, #0x1
700a460c: 5488         	strb	r0, [r1, r2]
;                 if ((cfg->vint == 0) && (cfg->vint_sb == 0)) {
700a460e: 980b         	ldr	r0, [sp, #0x2c]
700a4610: 8a40         	ldrh	r0, [r0, #0x12]
700a4612: b958         	cbnz	r0, 0x700a462c <Sciclient_rmIrqVintAdd+0xec> @ imm = #0x16
700a4614: e7ff         	b	0x700a4616 <Sciclient_rmIrqVintAdd+0xd6> @ imm = #-0x2
700a4616: 980b         	ldr	r0, [sp, #0x2c]
700a4618: 7d00         	ldrb	r0, [r0, #0x14]
700a461a: b938         	cbnz	r0, 0x700a462c <Sciclient_rmIrqVintAdd+0xec> @ imm = #0xe
700a461c: e7ff         	b	0x700a461e <Sciclient_rmIrqVintAdd+0xde> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = cfg->global_evt - ia_inst->sevt_offset;
700a461e: 980b         	ldr	r0, [sp, #0x2c]
700a4620: 89c0         	ldrh	r0, [r0, #0xe]
700a4622: 9908         	ldr	r1, [sp, #0x20]
700a4624: 890a         	ldrh	r2, [r1, #0x8]
700a4626: 1a80         	subs	r0, r0, r2
700a4628: 8288         	strh	r0, [r1, #0x14]
;                 }
700a462a: e7ff         	b	0x700a462c <Sciclient_rmIrqVintAdd+0xec> @ imm = #-0x2
;             }
700a462c: e7ff         	b	0x700a462e <Sciclient_rmIrqVintAdd+0xee> @ imm = #-0x2
;         }
700a462e: e7ff         	b	0x700a4630 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #-0x2
;     }
700a4630: e7ff         	b	0x700a4632 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #-0x2
;     if (cfg_whole_route == true) {
700a4632: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a4636: 07c0         	lsls	r0, r0, #0x1f
700a4638: b170         	cbz	r0, 0x700a4658 <Sciclient_rmIrqVintAdd+0x118> @ imm = #0x1c
700a463a: e7ff         	b	0x700a463c <Sciclient_rmIrqVintAdd+0xfc> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700a463c: 980b         	ldr	r0, [sp, #0x2c]
700a463e: f7f9 fc2f    	bl	0x7009dea0 <Sciclient_rmIrqFindRoute> @ imm = #-0x67a2
700a4642: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a4644: 980a         	ldr	r0, [sp, #0x28]
700a4646: b930         	cbnz	r0, 0x700a4656 <Sciclient_rmIrqVintAdd+0x116> @ imm = #0xc
700a4648: e7ff         	b	0x700a464a <Sciclient_rmIrqVintAdd+0x10a> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, true);
700a464a: 980b         	ldr	r0, [sp, #0x2c]
700a464c: 2101         	movs	r1, #0x1
700a464e: f7fc fa77    	bl	0x700a0b40 <Sciclient_rmIrqProgramRoute> @ imm = #-0x3b12
700a4652: 900a         	str	r0, [sp, #0x28]
;         }
700a4654: e7ff         	b	0x700a4656 <Sciclient_rmIrqVintAdd+0x116> @ imm = #-0x2
;     }
700a4656: e7ff         	b	0x700a4658 <Sciclient_rmIrqVintAdd+0x118> @ imm = #-0x2
;     return r;
700a4658: 980a         	ldr	r0, [sp, #0x28]
700a465a: b00c         	add	sp, #0x30
700a465c: bd80         	pop	{r7, pc}
700a465e: 0000         	movs	r0, r0

700a4660 <TaskP_loadUpdateAll>:
; {
700a4660: b580         	push	{r7, lr}
700a4662: b090         	sub	sp, #0x40
;     vTaskSuspendAll();
700a4664: f00b fa8c    	bl	0x700afb80 <vTaskSuspendAll> @ imm = #0xb518
700a4668: 2000         	movs	r0, #0x0
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a466a: 9005         	str	r0, [sp, #0x14]
700a466c: e7ff         	b	0x700a466e <TaskP_loadUpdateAll+0xe> @ imm = #-0x2
700a466e: 9805         	ldr	r0, [sp, #0x14]
700a4670: 281f         	cmp	r0, #0x1f
700a4672: d837         	bhi	0x700a46e4 <TaskP_loadUpdateAll+0x84> @ imm = #0x6e
700a4674: e7ff         	b	0x700a4676 <TaskP_loadUpdateAll+0x16> @ imm = #-0x2
;         if(gTaskP_ctrl.taskRegistry[i]!=NULL)
700a4676: 9905         	ldr	r1, [sp, #0x14]
700a4678: f644 4078    	movw	r0, #0x4c78
700a467c: f2c7 0008    	movt	r0, #0x7008
700a4680: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a4684: b348         	cbz	r0, 0x700a46da <TaskP_loadUpdateAll+0x7a> @ imm = #0x52
700a4686: e7ff         	b	0x700a4688 <TaskP_loadUpdateAll+0x28> @ imm = #-0x2
;             taskObj = gTaskP_ctrl.taskRegistry[i];
700a4688: 9905         	ldr	r1, [sp, #0x14]
700a468a: f644 4078    	movw	r0, #0x4c78
700a468e: f2c7 0008    	movt	r0, #0x7008
700a4692: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a4696: 900f         	str	r0, [sp, #0x3c]
;             vTaskGetInfo(taskObj->taskHndl, &taskStatus, pdFALSE, eReady);
700a4698: 980f         	ldr	r0, [sp, #0x3c]
700a469a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a469e: a906         	add	r1, sp, #0x18
700a46a0: 2200         	movs	r2, #0x0
700a46a2: 2301         	movs	r3, #0x1
700a46a4: f001 fbbc    	bl	0x700a5e20 <vTaskGetInfo> @ imm = #0x1778
;             delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, taskObj->lastRunTime);
700a46a8: 980c         	ldr	r0, [sp, #0x30]
700a46aa: 990f         	ldr	r1, [sp, #0x3c]
700a46ac: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a46b0: f00a fa3e    	bl	0x700aeb30 <TaskP_calcCounterDiff> @ imm = #0xa47c
700a46b4: 9004         	str	r0, [sp, #0x10]
;             taskObj->accRunTime += delta;
700a46b6: 9b04         	ldr	r3, [sp, #0x10]
700a46b8: 990f         	ldr	r1, [sp, #0x3c]
700a46ba: f8d1 2090    	ldr.w	r2, [r1, #0x90]
700a46be: f8d1 0094    	ldr.w	r0, [r1, #0x94]
700a46c2: 18d2         	adds	r2, r2, r3
700a46c4: f140 0000    	adc	r0, r0, #0x0
700a46c8: f8c1 2090    	str.w	r2, [r1, #0x90]
700a46cc: f8c1 0094    	str.w	r0, [r1, #0x94]
;             taskObj->lastRunTime = taskStatus.ulRunTimeCounter;
700a46d0: 980c         	ldr	r0, [sp, #0x30]
700a46d2: 990f         	ldr	r1, [sp, #0x3c]
700a46d4: f8c1 008c    	str.w	r0, [r1, #0x8c]
;         }
700a46d8: e7ff         	b	0x700a46da <TaskP_loadUpdateAll+0x7a> @ imm = #-0x2
;     }
700a46da: e7ff         	b	0x700a46dc <TaskP_loadUpdateAll+0x7c> @ imm = #-0x2
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a46dc: 9805         	ldr	r0, [sp, #0x14]
700a46de: 3001         	adds	r0, #0x1
700a46e0: 9005         	str	r0, [sp, #0x14]
700a46e2: e7c4         	b	0x700a466e <TaskP_loadUpdateAll+0xe> @ imm = #-0x78
;     idleTskHndl = xTaskGetIdleTaskHandle();
700a46e4: f00b fabc    	bl	0x700afc60 <xTaskGetIdleTaskHandle> @ imm = #0xb578
700a46e8: 9002         	str	r0, [sp, #0x8]
;     if(idleTskHndl != NULL)
700a46ea: 9802         	ldr	r0, [sp, #0x8]
700a46ec: b310         	cbz	r0, 0x700a4734 <TaskP_loadUpdateAll+0xd4> @ imm = #0x44
700a46ee: e7ff         	b	0x700a46f0 <TaskP_loadUpdateAll+0x90> @ imm = #-0x2
;         vTaskGetInfo(idleTskHndl, &taskStatus, pdFALSE, eReady);
700a46f0: 9802         	ldr	r0, [sp, #0x8]
700a46f2: a906         	add	r1, sp, #0x18
700a46f4: 2200         	movs	r2, #0x0
700a46f6: 2301         	movs	r3, #0x1
700a46f8: f001 fb92    	bl	0x700a5e20 <vTaskGetInfo> @ imm = #0x1724
;         delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, gTaskP_ctrl.idleTskLastRunTime);
700a46fc: 980c         	ldr	r0, [sp, #0x30]
700a46fe: f644 4178    	movw	r1, #0x4c78
700a4702: f2c7 0108    	movt	r1, #0x7008
700a4706: 9101         	str	r1, [sp, #0x4]
700a4708: f8d1 1090    	ldr.w	r1, [r1, #0x90]
700a470c: f00a fa10    	bl	0x700aeb30 <TaskP_calcCounterDiff> @ imm = #0xa420
700a4710: 9901         	ldr	r1, [sp, #0x4]
700a4712: 9004         	str	r0, [sp, #0x10]
;         gTaskP_ctrl.idleTskAccRunTime += delta;
700a4714: 9b04         	ldr	r3, [sp, #0x10]
700a4716: f8d1 2098    	ldr.w	r2, [r1, #0x98]
700a471a: f8d1 009c    	ldr.w	r0, [r1, #0x9c]
700a471e: 18d2         	adds	r2, r2, r3
700a4720: f140 0000    	adc	r0, r0, #0x0
700a4724: f8c1 2098    	str.w	r2, [r1, #0x98]
700a4728: f8c1 009c    	str.w	r0, [r1, #0x9c]
;         gTaskP_ctrl.idleTskLastRunTime = taskStatus.ulRunTimeCounter;
700a472c: 980c         	ldr	r0, [sp, #0x30]
700a472e: f8c1 0090    	str.w	r0, [r1, #0x90]
;     }
700a4732: e7ff         	b	0x700a4734 <TaskP_loadUpdateAll+0xd4> @ imm = #-0x2
;     curTotalTime = portGET_RUN_TIME_COUNTER_VALUE();
700a4734: f00b f99c    	bl	0x700afa70 <uiPortGetRunTimeCounterValue> @ imm = #0xb338
700a4738: 9003         	str	r0, [sp, #0xc]
;     delta = TaskP_calcCounterDiff(curTotalTime, gTaskP_ctrl.lastTotalTime);
700a473a: 9803         	ldr	r0, [sp, #0xc]
700a473c: f644 4178    	movw	r1, #0x4c78
700a4740: f2c7 0108    	movt	r1, #0x7008
700a4744: 9100         	str	r1, [sp]
700a4746: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700a474a: f00a f9f1    	bl	0x700aeb30 <TaskP_calcCounterDiff> @ imm = #0xa3e2
700a474e: 9900         	ldr	r1, [sp]
700a4750: 9004         	str	r0, [sp, #0x10]
;     gTaskP_ctrl.accTotalTime += delta;
700a4752: 9b04         	ldr	r3, [sp, #0x10]
700a4754: f8d1 2088    	ldr.w	r2, [r1, #0x88]
700a4758: f8d1 008c    	ldr.w	r0, [r1, #0x8c]
700a475c: 18d2         	adds	r2, r2, r3
700a475e: f140 0000    	adc	r0, r0, #0x0
700a4762: f8c1 2088    	str.w	r2, [r1, #0x88]
700a4766: f8c1 008c    	str.w	r0, [r1, #0x8c]
;     gTaskP_ctrl.lastTotalTime = curTotalTime;
700a476a: 9803         	ldr	r0, [sp, #0xc]
700a476c: f8c1 0080    	str.w	r0, [r1, #0x80]
;     (void)xTaskResumeAll();
700a4770: f7fd fcb6    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0x2694
; }
700a4774: b010         	add	sp, #0x40
700a4776: bd80         	pop	{r7, pc}

700a4778 <__udivmoddi4>:
700a4778: e1530001     	cmp	r3, r1
700a477c: 01520000     	cmpeq	r2, r0
700a4780: 9a000007     	bls	0x700a47a4 <__udivmoddi4+0x2c> @ imm = #0x1c
700a4784: e59d2000     	ldr	r2, [sp]
700a4788: e3520000     	cmp	r2, #0
700a478c: 0a000001     	beq	0x700a4798 <__udivmoddi4+0x20> @ imm = #0x4
700a4790: e5820000     	str	r0, [r2]
700a4794: e5821004     	str	r1, [r2, #0x4]
700a4798: e3b01000     	movs	r1, #0
700a479c: e3b00000     	movs	r0, #0
700a47a0: e12fff1e     	bx	lr
700a47a4: e3530000     	cmp	r3, #0
700a47a8: 03520000     	cmpeq	r2, #0
700a47ac: 1a00000d     	bne	0x700a47e8 <__udivmoddi4+0x70> @ imm = #0x34
700a47b0: e59d2000     	ldr	r2, [sp]
700a47b4: e3520000     	cmp	r2, #0
700a47b8: 0a000001     	beq	0x700a47c4 <__udivmoddi4+0x4c> @ imm = #0x4
700a47bc: e5820000     	str	r0, [r2]
700a47c0: e5821004     	str	r1, [r2, #0x4]
700a47c4: e1b02000     	movs	r2, r0
700a47c8: e1b03001     	movs	r3, r1
700a47cc: e3b01000     	movs	r1, #0
700a47d0: e3b00000     	movs	r0, #0
700a47d4: e3530000     	cmp	r3, #0
700a47d8: 03520000     	cmpeq	r2, #0
700a47dc: 11e01001     	mvnne	r1, r1
700a47e0: 11e00000     	mvnne	r0, r0
700a47e4: ea002d4d     	b	0x700afd20 <__aeabi_ldiv0> @ imm = #0xb534
700a47e8: e92d40f0     	push	{r4, r5, r6, r7, lr}
700a47ec: e1a04003     	mov	r4, r3
700a47f0: e1a05002     	mov	r5, r2
700a47f4: e1a03001     	mov	r3, r1
700a47f8: e1a02000     	mov	r2, r0
700a47fc: e3b00000     	movs	r0, #0
700a4800: e3b01000     	movs	r1, #0
700a4804: e16f6f14     	clz	r6, r4
700a4808: e3560020     	cmp	r6, #32
700a480c: 016f6f15     	clzeq	r6, r5
700a4810: 02866020     	addeq	r6, r6, #32
700a4814: e16f7f13     	clz	r7, r3
700a4818: e3570020     	cmp	r7, #32
700a481c: 016f7f12     	clzeq	r7, r2
700a4820: 02877020     	addeq	r7, r7, #32
700a4824: e0566007     	subs	r6, r6, r7
700a4828: e2567020     	subs	r7, r6, #32
700a482c: 21a04715     	lslhs	r4, r5, r7
700a4830: 23a05000     	movhs	r5, #0
700a4834: 32677000     	rsblo	r7, r7, #0
700a4838: 31a04614     	lsllo	r4, r4, r6
700a483c: 31a07735     	lsrlo	r7, r5, r7
700a4840: 31844007     	orrlo	r4, r4, r7
700a4844: 31a05615     	lsllo	r5, r5, r6
700a4848: e1530004     	cmp	r3, r4
700a484c: 01520005     	cmpeq	r2, r5
700a4850: 3a000001     	blo	0x700a485c <__udivmoddi4+0xe4> @ imm = #0x4
700a4854: e0522005     	subs	r2, r2, r5
700a4858: e0d33004     	sbcs	r3, r3, r4
700a485c: e0b00000     	adcs	r0, r0, r0
700a4860: e0b11001     	adcs	r1, r1, r1
700a4864: e1b050a5     	lsrs	r5, r5, #1
700a4868: e1855f84     	orr	r5, r5, r4, lsl #31
700a486c: e1b040a4     	lsrs	r4, r4, #1
700a4870: e2566001     	subs	r6, r6, #1
700a4874: 5afffff3     	bpl	0x700a4848 <__udivmoddi4+0xd0> @ imm = #-0x34
700a4878: e59d7014     	ldr	r7, [sp, #0x14]
700a487c: e3570000     	cmp	r7, #0
700a4880: 0a000001     	beq	0x700a488c <__udivmoddi4+0x114> @ imm = #0x4
700a4884: e5872000     	str	r2, [r7]
700a4888: e5873004     	str	r3, [r7, #0x4]
700a488c: e8bd80f0     	pop	{r4, r5, r6, r7, pc}

700a4890 <CSL_bcdmaChanOpDecChanStats>:
; {
700a4890: b580         	push	{r7, lr}
700a4892: b088         	sub	sp, #0x20
700a4894: 9007         	str	r0, [sp, #0x1c]
700a4896: 9106         	str	r1, [sp, #0x18]
700a4898: 9205         	str	r2, [sp, #0x14]
700a489a: 9304         	str	r3, [sp, #0x10]
700a489c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a489e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a48a0: 9804         	ldr	r0, [sp, #0x10]
700a48a2: b920         	cbnz	r0, 0x700a48ae <CSL_bcdmaChanOpDecChanStats+0x1e> @ imm = #0x8
700a48a4: e7ff         	b	0x700a48a6 <CSL_bcdmaChanOpDecChanStats+0x16> @ imm = #-0x2
700a48a6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a48aa: 9003         	str	r0, [sp, #0xc]
;     }
700a48ac: e078         	b	0x700a49a0 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #0xf0
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a48ae: 9804         	ldr	r0, [sp, #0x10]
700a48b0: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a48b2: 9806         	ldr	r0, [sp, #0x18]
700a48b4: 9001         	str	r0, [sp, #0x4]
700a48b6: b140         	cbz	r0, 0x700a48ca <CSL_bcdmaChanOpDecChanStats+0x3a> @ imm = #0x10
700a48b8: e7ff         	b	0x700a48ba <CSL_bcdmaChanOpDecChanStats+0x2a> @ imm = #-0x2
700a48ba: 9801         	ldr	r0, [sp, #0x4]
700a48bc: 2801         	cmp	r0, #0x1
700a48be: d026         	beq	0x700a490e <CSL_bcdmaChanOpDecChanStats+0x7e> @ imm = #0x4c
700a48c0: e7ff         	b	0x700a48c2 <CSL_bcdmaChanOpDecChanStats+0x32> @ imm = #-0x2
700a48c2: 9801         	ldr	r0, [sp, #0x4]
700a48c4: 2802         	cmp	r0, #0x2
700a48c6: d044         	beq	0x700a4952 <CSL_bcdmaChanOpDecChanStats+0xc2> @ imm = #0x88
700a48c8: e065         	b	0x700a4996 <CSL_bcdmaChanOpDecChanStats+0x106> @ imm = #0xca
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a48ca: 9807         	ldr	r0, [sp, #0x1c]
700a48cc: 6880         	ldr	r0, [r0, #0x8]
700a48ce: 9905         	ldr	r1, [sp, #0x14]
700a48d0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a48d4: f500 6080    	add.w	r0, r0, #0x400
700a48d8: 9902         	ldr	r1, [sp, #0x8]
700a48da: 6809         	ldr	r1, [r1]
700a48dc: f7f7 fc18    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x87d0
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a48e0: 9807         	ldr	r0, [sp, #0x1c]
700a48e2: 6880         	ldr	r0, [r0, #0x8]
700a48e4: 9905         	ldr	r1, [sp, #0x14]
700a48e6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a48ea: f500 6081    	add.w	r0, r0, #0x408
700a48ee: 9902         	ldr	r1, [sp, #0x8]
700a48f0: 6849         	ldr	r1, [r1, #0x4]
700a48f2: f7f7 fc0d    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x87e6
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a48f6: 9807         	ldr	r0, [sp, #0x1c]
700a48f8: 6880         	ldr	r0, [r0, #0x8]
700a48fa: 9905         	ldr	r1, [sp, #0x14]
700a48fc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4900: f500 6082    	add.w	r0, r0, #0x410
700a4904: 9902         	ldr	r1, [sp, #0x8]
700a4906: 6889         	ldr	r1, [r1, #0x8]
700a4908: f7f7 fc02    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x87fc
;                 break;
700a490c: e047         	b	0x700a499e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x8e
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a490e: 9807         	ldr	r0, [sp, #0x1c]
700a4910: 6900         	ldr	r0, [r0, #0x10]
700a4912: 9905         	ldr	r1, [sp, #0x14]
700a4914: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4918: f500 6080    	add.w	r0, r0, #0x400
700a491c: 9902         	ldr	r1, [sp, #0x8]
700a491e: 6809         	ldr	r1, [r1]
700a4920: f7f7 fbf6    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x8814
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a4924: 9807         	ldr	r0, [sp, #0x1c]
700a4926: 6900         	ldr	r0, [r0, #0x10]
700a4928: 9905         	ldr	r1, [sp, #0x14]
700a492a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a492e: f500 6081    	add.w	r0, r0, #0x408
700a4932: 9902         	ldr	r1, [sp, #0x8]
700a4934: 6849         	ldr	r1, [r1, #0x4]
700a4936: f7f7 fbeb    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x882a
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a493a: 9807         	ldr	r0, [sp, #0x1c]
700a493c: 6900         	ldr	r0, [r0, #0x10]
700a493e: 9905         	ldr	r1, [sp, #0x14]
700a4940: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4944: f500 6082    	add.w	r0, r0, #0x410
700a4948: 9902         	ldr	r1, [sp, #0x8]
700a494a: 6889         	ldr	r1, [r1, #0x8]
700a494c: f7f7 fbe0    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x8840
;                 break;
700a4950: e025         	b	0x700a499e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x4a
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a4952: 9807         	ldr	r0, [sp, #0x1c]
700a4954: 6980         	ldr	r0, [r0, #0x18]
700a4956: 9905         	ldr	r1, [sp, #0x14]
700a4958: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a495c: f500 6080    	add.w	r0, r0, #0x400
700a4960: 9902         	ldr	r1, [sp, #0x8]
700a4962: 6809         	ldr	r1, [r1]
700a4964: f7f7 fbd4    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x8858
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->rxPayloadByteCnt );
700a4968: 9807         	ldr	r0, [sp, #0x1c]
700a496a: 6980         	ldr	r0, [r0, #0x18]
700a496c: 9905         	ldr	r1, [sp, #0x14]
700a496e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4972: f500 6081    	add.w	r0, r0, #0x408
700a4976: 9902         	ldr	r1, [sp, #0x8]
700a4978: 68c9         	ldr	r1, [r1, #0xc]
700a497a: f7f7 fbc9    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x886e
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->rxStartedByteCnt );
700a497e: 9807         	ldr	r0, [sp, #0x1c]
700a4980: 6980         	ldr	r0, [r0, #0x18]
700a4982: 9905         	ldr	r1, [sp, #0x14]
700a4984: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4988: f500 6082    	add.w	r0, r0, #0x410
700a498c: 9902         	ldr	r1, [sp, #0x8]
700a498e: 6909         	ldr	r1, [r1, #0x10]
700a4990: f7f7 fbbe    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x8884
;                 break;
700a4994: e003         	b	0x700a499e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x6
700a4996: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a499a: 9003         	str	r0, [sp, #0xc]
;                 break;
700a499c: e7ff         	b	0x700a499e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #-0x2
700a499e: e7ff         	b	0x700a49a0 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #-0x2
;     return retVal;
700a49a0: 9803         	ldr	r0, [sp, #0xc]
700a49a2: b008         	add	sp, #0x20
700a49a4: bd80         	pop	{r7, pc}
		...
700a49ae: 0000         	movs	r0, r0

700a49b0 <UART_divisorLatchWrite>:
; {
700a49b0: b580         	push	{r7, lr}
700a49b2: b08c         	sub	sp, #0x30
700a49b4: 900b         	str	r0, [sp, #0x2c]
700a49b6: 910a         	str	r1, [sp, #0x28]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a49b8: 980b         	ldr	r0, [sp, #0x2c]
700a49ba: 21bf         	movs	r1, #0xbf
700a49bc: 9102         	str	r1, [sp, #0x8]
700a49be: f007 fe3f    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x7c7e
700a49c2: 9007         	str	r0, [sp, #0x1c]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a49c4: 980b         	ldr	r0, [sp, #0x2c]
700a49c6: 3008         	adds	r0, #0x8
700a49c8: 2110         	movs	r1, #0x10
700a49ca: 9103         	str	r1, [sp, #0xc]
700a49cc: 2204         	movs	r2, #0x4
700a49ce: 9204         	str	r2, [sp, #0x10]
700a49d0: f00a fc76    	bl	0x700af2c0 <HW_RD_FIELD32_RAW> @ imm = #0xa8ec
700a49d4: 9903         	ldr	r1, [sp, #0xc]
700a49d6: 9a04         	ldr	r2, [sp, #0x10]
700a49d8: 9009         	str	r0, [sp, #0x24]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a49da: 980b         	ldr	r0, [sp, #0x2c]
700a49dc: 3008         	adds	r0, #0x8
700a49de: 2301         	movs	r3, #0x1
700a49e0: f009 fe0e    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x9c1c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a49e4: 980b         	ldr	r0, [sp, #0x2c]
700a49e6: 300c         	adds	r0, #0xc
700a49e8: 9907         	ldr	r1, [sp, #0x1c]
700a49ea: f00b f8a9    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0xb152
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a49ee: 980b         	ldr	r0, [sp, #0x2c]
700a49f0: 217f         	movs	r1, #0x7f
700a49f2: 9101         	str	r1, [sp, #0x4]
700a49f4: f007 fe24    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x7c48
700a49f8: 9903         	ldr	r1, [sp, #0xc]
700a49fa: 9a04         	ldr	r2, [sp, #0x10]
700a49fc: 9007         	str	r0, [sp, #0x1c]
;     sleepMdBitVal = HW_RD_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE);
700a49fe: 980b         	ldr	r0, [sp, #0x2c]
700a4a00: 3004         	adds	r0, #0x4
700a4a02: f00a fc5d    	bl	0x700af2c0 <HW_RD_FIELD32_RAW> @ imm = #0xa8ba
700a4a06: 9903         	ldr	r1, [sp, #0xc]
700a4a08: 9a04         	ldr	r2, [sp, #0x10]
700a4a0a: 9008         	str	r0, [sp, #0x20]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, 0U);
700a4a0c: 980b         	ldr	r0, [sp, #0x2c]
700a4a0e: 3004         	adds	r0, #0x4
700a4a10: 2300         	movs	r3, #0x0
700a4a12: f009 fdf5    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x9bea
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4a16: 980b         	ldr	r0, [sp, #0x2c]
700a4a18: 300c         	adds	r0, #0xc
700a4a1a: 9907         	ldr	r1, [sp, #0x1c]
700a4a1c: f00b f890    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0xb120
700a4a20: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a4a22: 980b         	ldr	r0, [sp, #0x2c]
700a4a24: f007 fe0c    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x7c18
700a4a28: 9007         	str	r0, [sp, #0x1c]
;     divRegVal  = HW_RD_REG32(baseAddr + UART_DLL) & 0xFFU;
700a4a2a: 980b         	ldr	r0, [sp, #0x2c]
700a4a2c: f00b f880    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0xb100
700a4a30: b2c0         	uxtb	r0, r0
700a4a32: 9005         	str	r0, [sp, #0x14]
;     divRegVal |= (HW_RD_REG32(baseAddr + UART_DLH) & 0x3FU) << 8;
700a4a34: 980b         	ldr	r0, [sp, #0x2c]
700a4a36: 3004         	adds	r0, #0x4
700a4a38: f00b f87a    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0xb0f4
700a4a3c: f000 013f    	and	r1, r0, #0x3f
700a4a40: 9805         	ldr	r0, [sp, #0x14]
700a4a42: ea40 2001    	orr.w	r0, r0, r1, lsl #8
700a4a46: 9005         	str	r0, [sp, #0x14]
;     operMode = UART_operatingModeSelect(baseAddr,
700a4a48: 980b         	ldr	r0, [sp, #0x2c]
700a4a4a: 2107         	movs	r1, #0x7
700a4a4c: f00a f990    	bl	0x700aed70 <UART_operatingModeSelect> @ imm = #0xa320
700a4a50: 9006         	str	r0, [sp, #0x18]
;     HW_WR_REG32(baseAddr + UART_DLL, divisorValue & 0x00FFU);
700a4a52: 980b         	ldr	r0, [sp, #0x2c]
700a4a54: f89d 1028    	ldrb.w	r1, [sp, #0x28]
700a4a58: f00b f872    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0xb0e4
;     HW_WR_REG32(baseAddr + UART_DLH, (divisorValue & 0x3F00U) >> 8);
700a4a5c: 980b         	ldr	r0, [sp, #0x2c]
700a4a5e: 3004         	adds	r0, #0x4
700a4a60: 990a         	ldr	r1, [sp, #0x28]
700a4a62: f3c1 2105    	ubfx	r1, r1, #0x8, #0x6
700a4a66: f00b f86b    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0xb0d6
;     (void) UART_operatingModeSelect(baseAddr, operMode);
700a4a6a: 980b         	ldr	r0, [sp, #0x2c]
700a4a6c: 9906         	ldr	r1, [sp, #0x18]
700a4a6e: f00a f97f    	bl	0x700aed70 <UART_operatingModeSelect> @ imm = #0xa2fe
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4a72: 980b         	ldr	r0, [sp, #0x2c]
700a4a74: 300c         	adds	r0, #0xc
700a4a76: 9907         	ldr	r1, [sp, #0x1c]
700a4a78: f00b f862    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0xb0c4
700a4a7c: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a4a7e: 980b         	ldr	r0, [sp, #0x2c]
700a4a80: f007 fdde    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x7bbc
700a4a84: 9903         	ldr	r1, [sp, #0xc]
700a4a86: 9a04         	ldr	r2, [sp, #0x10]
700a4a88: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, sleepMdBitVal);
700a4a8a: 980b         	ldr	r0, [sp, #0x2c]
700a4a8c: 3004         	adds	r0, #0x4
700a4a8e: 9b08         	ldr	r3, [sp, #0x20]
700a4a90: f009 fdb6    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x9b6c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4a94: 980b         	ldr	r0, [sp, #0x2c]
700a4a96: 300c         	adds	r0, #0xc
700a4a98: 9907         	ldr	r1, [sp, #0x1c]
700a4a9a: f00b f851    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0xb0a2
700a4a9e: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a4aa0: 980b         	ldr	r0, [sp, #0x2c]
700a4aa2: f007 fdcd    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x7b9a
700a4aa6: 9903         	ldr	r1, [sp, #0xc]
700a4aa8: 9a04         	ldr	r2, [sp, #0x10]
700a4aaa: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a4aac: 980b         	ldr	r0, [sp, #0x2c]
700a4aae: 3008         	adds	r0, #0x8
700a4ab0: 9b09         	ldr	r3, [sp, #0x24]
700a4ab2: f009 fda5    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x9b4a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4ab6: 980b         	ldr	r0, [sp, #0x2c]
700a4ab8: 300c         	adds	r0, #0xc
700a4aba: 9907         	ldr	r1, [sp, #0x1c]
700a4abc: f00b f840    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0xb080
;     return divRegVal;
700a4ac0: 9805         	ldr	r0, [sp, #0x14]
700a4ac2: b00c         	add	sp, #0x30
700a4ac4: bd80         	pop	{r7, pc}
		...
700a4ace: 0000         	movs	r0, r0

700a4ad0 <_ntoa_long>:
; {
700a4ad0: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a4ad4: b098         	sub	sp, #0x60
700a4ad6: 4684         	mov	r12, r0
700a4ad8: 9823         	ldr	r0, [sp, #0x8c]
700a4ada: 9822         	ldr	r0, [sp, #0x88]
700a4adc: 9821         	ldr	r0, [sp, #0x84]
700a4ade: 9820         	ldr	r0, [sp, #0x80]
700a4ae0: 981f         	ldr	r0, [sp, #0x7c]
700a4ae2: f8dd e078    	ldr.w	lr, [sp, #0x78]
700a4ae6: f8cd c05c    	str.w	r12, [sp, #0x5c]
700a4aea: 9116         	str	r1, [sp, #0x58]
700a4aec: 9215         	str	r2, [sp, #0x54]
700a4aee: 9314         	str	r3, [sp, #0x50]
700a4af0: f88d 004f    	strb.w	r0, [sp, #0x4f]
700a4af4: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a4af6: 900a         	str	r0, [sp, #0x28]
;   if (!value) {
700a4af8: 981e         	ldr	r0, [sp, #0x78]
700a4afa: b928         	cbnz	r0, 0x700a4b08 <_ntoa_long+0x38> @ imm = #0xa
700a4afc: e7ff         	b	0x700a4afe <_ntoa_long+0x2e> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a4afe: 9823         	ldr	r0, [sp, #0x8c]
700a4b00: f020 0010    	bic	r0, r0, #0x10
700a4b04: 9023         	str	r0, [sp, #0x8c]
;   }
700a4b06: e7ff         	b	0x700a4b08 <_ntoa_long+0x38> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a4b08: f89d 008d    	ldrb.w	r0, [sp, #0x8d]
700a4b0c: 0740         	lsls	r0, r0, #0x1d
700a4b0e: 2800         	cmp	r0, #0x0
700a4b10: d504         	bpl	0x700a4b1c <_ntoa_long+0x4c> @ imm = #0x8
700a4b12: e7ff         	b	0x700a4b14 <_ntoa_long+0x44> @ imm = #-0x2
700a4b14: 981e         	ldr	r0, [sp, #0x78]
700a4b16: 2800         	cmp	r0, #0x0
700a4b18: d03f         	beq	0x700a4b9a <_ntoa_long+0xca> @ imm = #0x7e
700a4b1a: e7ff         	b	0x700a4b1c <_ntoa_long+0x4c> @ imm = #-0x2
;     do {
700a4b1c: e7ff         	b	0x700a4b1e <_ntoa_long+0x4e> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a4b1e: 9a1e         	ldr	r2, [sp, #0x78]
700a4b20: 9920         	ldr	r1, [sp, #0x80]
700a4b22: fbb2 f0f1    	udiv	r0, r2, r1
700a4b26: fb00 2011    	mls	r0, r0, r1, r2
700a4b2a: f88d 0027    	strb.w	r0, [sp, #0x27]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a4b2e: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a4b32: 2809         	cmp	r0, #0x9
700a4b34: dc05         	bgt	0x700a4b42 <_ntoa_long+0x72> @ imm = #0xa
700a4b36: e7ff         	b	0x700a4b38 <_ntoa_long+0x68> @ imm = #-0x2
700a4b38: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a4b3c: 3030         	adds	r0, #0x30
700a4b3e: 9008         	str	r0, [sp, #0x20]
700a4b40: e00c         	b	0x700a4b5c <_ntoa_long+0x8c> @ imm = #0x18
700a4b42: f89d 008c    	ldrb.w	r0, [sp, #0x8c]
700a4b46: 0681         	lsls	r1, r0, #0x1a
700a4b48: 2061         	movs	r0, #0x61
700a4b4a: 2900         	cmp	r1, #0x0
700a4b4c: bf48         	it	mi
700a4b4e: 2041         	movmi	r0, #0x41
700a4b50: f89d 1027    	ldrb.w	r1, [sp, #0x27]
700a4b54: 4408         	add	r0, r1
700a4b56: 380a         	subs	r0, #0xa
700a4b58: 9008         	str	r0, [sp, #0x20]
700a4b5a: e7ff         	b	0x700a4b5c <_ntoa_long+0x8c> @ imm = #-0x2
700a4b5c: 9808         	ldr	r0, [sp, #0x20]
700a4b5e: 9a0a         	ldr	r2, [sp, #0x28]
700a4b60: 1c51         	adds	r1, r2, #0x1
700a4b62: 910a         	str	r1, [sp, #0x28]
700a4b64: f10d 012f    	add.w	r1, sp, #0x2f
700a4b68: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a4b6a: 9920         	ldr	r1, [sp, #0x80]
700a4b6c: 981e         	ldr	r0, [sp, #0x78]
700a4b6e: fbb0 f0f1    	udiv	r0, r0, r1
700a4b72: 901e         	str	r0, [sp, #0x78]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a4b74: e7ff         	b	0x700a4b76 <_ntoa_long+0xa6> @ imm = #-0x2
700a4b76: 991e         	ldr	r1, [sp, #0x78]
700a4b78: 2000         	movs	r0, #0x0
700a4b7a: 9007         	str	r0, [sp, #0x1c]
700a4b7c: b139         	cbz	r1, 0x700a4b8e <_ntoa_long+0xbe> @ imm = #0xe
700a4b7e: e7ff         	b	0x700a4b80 <_ntoa_long+0xb0> @ imm = #-0x2
700a4b80: 990a         	ldr	r1, [sp, #0x28]
700a4b82: 2000         	movs	r0, #0x0
700a4b84: 2920         	cmp	r1, #0x20
700a4b86: bf38         	it	lo
700a4b88: 2001         	movlo	r0, #0x1
700a4b8a: 9007         	str	r0, [sp, #0x1c]
700a4b8c: e7ff         	b	0x700a4b8e <_ntoa_long+0xbe> @ imm = #-0x2
700a4b8e: 9807         	ldr	r0, [sp, #0x1c]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a4b90: 07c0         	lsls	r0, r0, #0x1f
700a4b92: 2800         	cmp	r0, #0x0
700a4b94: d1c3         	bne	0x700a4b1e <_ntoa_long+0x4e> @ imm = #-0x7a
700a4b96: e7ff         	b	0x700a4b98 <_ntoa_long+0xc8> @ imm = #-0x2
;   }
700a4b98: e7ff         	b	0x700a4b9a <_ntoa_long+0xca> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a4b9a: 9817         	ldr	r0, [sp, #0x5c]
700a4b9c: 9916         	ldr	r1, [sp, #0x58]
700a4b9e: 9a15         	ldr	r2, [sp, #0x54]
700a4ba0: 9b14         	ldr	r3, [sp, #0x50]
700a4ba2: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a4ba6: 9d20         	ldr	r5, [sp, #0x80]
700a4ba8: 9e21         	ldr	r6, [sp, #0x84]
700a4baa: 9f22         	ldr	r7, [sp, #0x88]
700a4bac: f8dd 808c    	ldr.w	r8, [sp, #0x8c]
700a4bb0: f89d 404f    	ldrb.w	r4, [sp, #0x4f]
700a4bb4: 46ee         	mov	lr, sp
700a4bb6: f8ce 8018    	str.w	r8, [lr, #0x18]
700a4bba: f8ce 7014    	str.w	r7, [lr, #0x14]
700a4bbe: f8ce 6010    	str.w	r6, [lr, #0x10]
700a4bc2: f8ce 500c    	str.w	r5, [lr, #0xc]
700a4bc6: f004 0401    	and	r4, r4, #0x1
700a4bca: f8ce 4008    	str.w	r4, [lr, #0x8]
700a4bce: f8ce c004    	str.w	r12, [lr, #0x4]
700a4bd2: f10d 0c2f    	add.w	r12, sp, #0x2f
700a4bd6: f8ce c000    	str.w	r12, [lr]
700a4bda: f7f9 fbb1    	bl	0x7009e340 <_ntoa_format> @ imm = #-0x689e
700a4bde: b018         	add	sp, #0x60
700a4be0: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a4bf0 <prvInitialiseNewTask>:
;     const MemoryRegion_t *const xRegions) {
700a4bf0: b580         	push	{r7, lr}
700a4bf2: b088         	sub	sp, #0x20
700a4bf4: f8dd c034    	ldr.w	r12, [sp, #0x34]
700a4bf8: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a4bfc: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a4c00: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a4c04: 9007         	str	r0, [sp, #0x1c]
700a4c06: 9106         	str	r1, [sp, #0x18]
700a4c08: 9205         	str	r2, [sp, #0x14]
700a4c0a: 9304         	str	r3, [sp, #0x10]
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a4c0c: 980c         	ldr	r0, [sp, #0x30]
700a4c0e: 6b00         	ldr	r0, [r0, #0x30]
;                  (size_t)ulStackDepth * sizeof(StackType_t));
700a4c10: 9905         	ldr	r1, [sp, #0x14]
700a4c12: 0089         	lsls	r1, r1, #0x2
700a4c14: 22a5         	movs	r2, #0xa5
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a4c16: f00a efa4    	blx	0x700afb60 <__aeabi_memset8> @ imm = #0xaf48
;     pxTopOfStack = &(pxNewTCB->pxStack[ulStackDepth - (uint32_t)1]);
700a4c1a: 980c         	ldr	r0, [sp, #0x30]
700a4c1c: 6b00         	ldr	r0, [r0, #0x30]
700a4c1e: 9905         	ldr	r1, [sp, #0x14]
700a4c20: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4c24: 3804         	subs	r0, #0x4
700a4c26: 9003         	str	r0, [sp, #0xc]
;              *)(((portPOINTER_SIZE_TYPE)pxTopOfStack) &
700a4c28: 9803         	ldr	r0, [sp, #0xc]
700a4c2a: f020 0007    	bic	r0, r0, #0x7
;     pxTopOfStack =
700a4c2e: 9003         	str	r0, [sp, #0xc]
;   if (pcName != NULL) {
700a4c30: 9806         	ldr	r0, [sp, #0x18]
700a4c32: b1f8         	cbz	r0, 0x700a4c74 <prvInitialiseNewTask+0x84> @ imm = #0x3e
700a4c34: e7ff         	b	0x700a4c36 <prvInitialiseNewTask+0x46> @ imm = #-0x2
700a4c36: 2000         	movs	r0, #0x0
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a4c38: 9002         	str	r0, [sp, #0x8]
700a4c3a: e7ff         	b	0x700a4c3c <prvInitialiseNewTask+0x4c> @ imm = #-0x2
700a4c3c: 9802         	ldr	r0, [sp, #0x8]
700a4c3e: 281f         	cmp	r0, #0x1f
700a4c40: d813         	bhi	0x700a4c6a <prvInitialiseNewTask+0x7a> @ imm = #0x26
700a4c42: e7ff         	b	0x700a4c44 <prvInitialiseNewTask+0x54> @ imm = #-0x2
;       pxNewTCB->pcTaskName[x] = pcName[x];
700a4c44: 9806         	ldr	r0, [sp, #0x18]
700a4c46: 9a02         	ldr	r2, [sp, #0x8]
700a4c48: 5c80         	ldrb	r0, [r0, r2]
700a4c4a: 990c         	ldr	r1, [sp, #0x30]
700a4c4c: 4411         	add	r1, r2
700a4c4e: f881 0034    	strb.w	r0, [r1, #0x34]
;       if (pcName[x] == (char)0x00) {
700a4c52: 9806         	ldr	r0, [sp, #0x18]
700a4c54: 9902         	ldr	r1, [sp, #0x8]
700a4c56: 5c40         	ldrb	r0, [r0, r1]
700a4c58: b908         	cbnz	r0, 0x700a4c5e <prvInitialiseNewTask+0x6e> @ imm = #0x2
700a4c5a: e7ff         	b	0x700a4c5c <prvInitialiseNewTask+0x6c> @ imm = #-0x2
;         break;
700a4c5c: e005         	b	0x700a4c6a <prvInitialiseNewTask+0x7a> @ imm = #0xa
700a4c5e: e7ff         	b	0x700a4c60 <prvInitialiseNewTask+0x70> @ imm = #-0x2
;     }
700a4c60: e7ff         	b	0x700a4c62 <prvInitialiseNewTask+0x72> @ imm = #-0x2
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a4c62: 9802         	ldr	r0, [sp, #0x8]
700a4c64: 3001         	adds	r0, #0x1
700a4c66: 9002         	str	r0, [sp, #0x8]
700a4c68: e7e8         	b	0x700a4c3c <prvInitialiseNewTask+0x4c> @ imm = #-0x30
;     pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
700a4c6a: 990c         	ldr	r1, [sp, #0x30]
700a4c6c: 2000         	movs	r0, #0x0
700a4c6e: f881 0053    	strb.w	r0, [r1, #0x53]
;   } else {
700a4c72: e004         	b	0x700a4c7e <prvInitialiseNewTask+0x8e> @ imm = #0x8
;     pxNewTCB->pcTaskName[0] = 0x00;
700a4c74: 990c         	ldr	r1, [sp, #0x30]
700a4c76: 2000         	movs	r0, #0x0
700a4c78: f881 0034    	strb.w	r0, [r1, #0x34]
700a4c7c: e7ff         	b	0x700a4c7e <prvInitialiseNewTask+0x8e> @ imm = #-0x2
;   if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES) {
700a4c7e: 980a         	ldr	r0, [sp, #0x28]
700a4c80: 2820         	cmp	r0, #0x20
700a4c82: d303         	blo	0x700a4c8c <prvInitialiseNewTask+0x9c> @ imm = #0x6
700a4c84: e7ff         	b	0x700a4c86 <prvInitialiseNewTask+0x96> @ imm = #-0x2
700a4c86: 201f         	movs	r0, #0x1f
;     uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
700a4c88: 900a         	str	r0, [sp, #0x28]
;   } else {
700a4c8a: e000         	b	0x700a4c8e <prvInitialiseNewTask+0x9e> @ imm = #0x0
700a4c8c: e7ff         	b	0x700a4c8e <prvInitialiseNewTask+0x9e> @ imm = #-0x2
;   pxNewTCB->uxPriority = uxPriority;
700a4c8e: 980a         	ldr	r0, [sp, #0x28]
700a4c90: 990c         	ldr	r1, [sp, #0x30]
700a4c92: 62c8         	str	r0, [r1, #0x2c]
;     pxNewTCB->uxBasePriority = uxPriority;
700a4c94: 980a         	ldr	r0, [sp, #0x28]
700a4c96: 990c         	ldr	r1, [sp, #0x30]
700a4c98: 6608         	str	r0, [r1, #0x60]
;     pxNewTCB->uxMutexesHeld = 0;
700a4c9a: 990c         	ldr	r1, [sp, #0x30]
700a4c9c: 2000         	movs	r0, #0x0
700a4c9e: 9001         	str	r0, [sp, #0x4]
700a4ca0: 6648         	str	r0, [r1, #0x64]
;   vListInitialiseItem(&(pxNewTCB->xStateListItem));
700a4ca2: 980c         	ldr	r0, [sp, #0x30]
700a4ca4: 3004         	adds	r0, #0x4
700a4ca6: f00a ff7b    	bl	0x700afba0 <vListInitialiseItem> @ imm = #0xaef6
;   vListInitialiseItem(&(pxNewTCB->xEventListItem));
700a4caa: 980c         	ldr	r0, [sp, #0x30]
700a4cac: 3018         	adds	r0, #0x18
700a4cae: f00a ff77    	bl	0x700afba0 <vListInitialiseItem> @ imm = #0xaeee
700a4cb2: 9801         	ldr	r0, [sp, #0x4]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
700a4cb4: 990c         	ldr	r1, [sp, #0x30]
700a4cb6: 6109         	str	r1, [r1, #0x10]
;   listSET_LIST_ITEM_VALUE(
700a4cb8: 990a         	ldr	r1, [sp, #0x28]
700a4cba: f1c1 0120    	rsb.w	r1, r1, #0x20
700a4cbe: 9a0c         	ldr	r2, [sp, #0x30]
700a4cc0: 6191         	str	r1, [r2, #0x18]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
700a4cc2: 990c         	ldr	r1, [sp, #0x30]
700a4cc4: 6249         	str	r1, [r1, #0x24]
;     pxNewTCB->uxCriticalNesting = (UBaseType_t)0U;
700a4cc6: 990c         	ldr	r1, [sp, #0x30]
700a4cc8: 6548         	str	r0, [r1, #0x54]
;     pxNewTCB->pxTaskTag = NULL;
700a4cca: 990c         	ldr	r1, [sp, #0x30]
700a4ccc: 6688         	str	r0, [r1, #0x68]
;     memset((void *)&(pxNewTCB->pvThreadLocalStoragePointers[0]), 0x00,
700a4cce: 990c         	ldr	r1, [sp, #0x30]
700a4cd0: 6788         	str	r0, [r1, #0x78]
700a4cd2: 6748         	str	r0, [r1, #0x74]
700a4cd4: 6708         	str	r0, [r1, #0x70]
700a4cd6: 66c8         	str	r0, [r1, #0x6c]
;     memset((void *)&(pxNewTCB->ulNotifiedValue[0]), 0x00,
700a4cd8: 990c         	ldr	r1, [sp, #0x30]
700a4cda: 67c8         	str	r0, [r1, #0x7c]
;     memset((void *)&(pxNewTCB->ucNotifyState[0]), 0x00,
700a4cdc: 990c         	ldr	r1, [sp, #0x30]
700a4cde: f881 0080    	strb.w	r0, [r1, #0x80]
;           pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
700a4ce2: 9803         	ldr	r0, [sp, #0xc]
700a4ce4: 9907         	ldr	r1, [sp, #0x1c]
700a4ce6: 9a04         	ldr	r2, [sp, #0x10]
700a4ce8: f7fe fc8a    	bl	0x700a3600 <pxPortInitialiseStack> @ imm = #-0x16ec
;       pxNewTCB->pxTopOfStack =
700a4cec: 990c         	ldr	r1, [sp, #0x30]
700a4cee: 6008         	str	r0, [r1]
;   if (pxCreatedTask != NULL) {
700a4cf0: 980b         	ldr	r0, [sp, #0x2c]
700a4cf2: b120         	cbz	r0, 0x700a4cfe <prvInitialiseNewTask+0x10e> @ imm = #0x8
700a4cf4: e7ff         	b	0x700a4cf6 <prvInitialiseNewTask+0x106> @ imm = #-0x2
;     *pxCreatedTask = (TaskHandle_t)pxNewTCB;
700a4cf6: 980c         	ldr	r0, [sp, #0x30]
700a4cf8: 990b         	ldr	r1, [sp, #0x2c]
700a4cfa: 6008         	str	r0, [r1]
;   } else {
700a4cfc: e000         	b	0x700a4d00 <prvInitialiseNewTask+0x110> @ imm = #0x0
700a4cfe: e7ff         	b	0x700a4d00 <prvInitialiseNewTask+0x110> @ imm = #-0x2
; }
700a4d00: b008         	add	sp, #0x20
700a4d02: bd80         	pop	{r7, pc}
		...

700a4d10 <Sciclient_pmSetModuleClkFreq>:
; {
700a4d10: b580         	push	{r7, lr}
700a4d12: b09a         	sub	sp, #0x68
700a4d14: f8dd c074    	ldr.w	r12, [sp, #0x74]
700a4d18: f8dd c070    	ldr.w	r12, [sp, #0x70]
700a4d1c: 9019         	str	r0, [sp, #0x64]
700a4d1e: 9118         	str	r1, [sp, #0x60]
700a4d20: 9317         	str	r3, [sp, #0x5c]
700a4d22: 9216         	str	r2, [sp, #0x58]
700a4d24: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a4d26: 9015         	str	r0, [sp, #0x54]
;     request.device         = (uint32_t) moduleId;
700a4d28: 9819         	ldr	r0, [sp, #0x64]
700a4d2a: 900c         	str	r0, [sp, #0x30]
;     request.min_freq_hz    = (uint64_t) freqHz;
700a4d2c: 9816         	ldr	r0, [sp, #0x58]
700a4d2e: 9917         	ldr	r1, [sp, #0x5c]
700a4d30: 910e         	str	r1, [sp, #0x38]
700a4d32: 900d         	str	r0, [sp, #0x34]
;     request.target_freq_hz = (uint64_t) freqHz;
700a4d34: 9816         	ldr	r0, [sp, #0x58]
700a4d36: 9917         	ldr	r1, [sp, #0x5c]
700a4d38: 9110         	str	r1, [sp, #0x40]
700a4d3a: 900f         	str	r0, [sp, #0x3c]
;     request.max_freq_hz    = (uint64_t) freqHz;
700a4d3c: 9816         	ldr	r0, [sp, #0x58]
700a4d3e: 9917         	ldr	r1, [sp, #0x5c]
700a4d40: 9112         	str	r1, [sp, #0x48]
700a4d42: 9011         	str	r0, [sp, #0x44]
;     if((freqHz%10U) != 0U)
700a4d44: 9b16         	ldr	r3, [sp, #0x58]
700a4d46: 9817         	ldr	r0, [sp, #0x5c]
700a4d48: f64c 41cd    	movw	r1, #0xcccd
700a4d4c: f6cc 41cc    	movt	r1, #0xcccc
700a4d50: fba3 2e01    	umull	r2, lr, r3, r1
700a4d54: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a4d58: fb03 e30c    	mla	r3, r3, r12, lr
700a4d5c: fb00 3101    	mla	r1, r0, r1, r3
700a4d60: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a4d64: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a4d68: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a4d6c: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a4d70: f649 129a    	movw	r2, #0x999a
700a4d74: f6c9 1299    	movt	r2, #0x9999
700a4d78: 1a89         	subs	r1, r1, r2
700a4d7a: f649 1199    	movw	r1, #0x9999
700a4d7e: f6c1 1199    	movt	r1, #0x1999
700a4d82: 4188         	sbcs	r0, r1
700a4d84: d316         	blo	0x700a4db4 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #0x2c
700a4d86: e7ff         	b	0x700a4d88 <Sciclient_pmSetModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(freqHz-(freqHz%10U));
700a4d88: 9816         	ldr	r0, [sp, #0x58]
700a4d8a: 9001         	str	r0, [sp, #0x4]
700a4d8c: 9917         	ldr	r1, [sp, #0x5c]
700a4d8e: 9100         	str	r1, [sp]
700a4d90: 220a         	movs	r2, #0xa
700a4d92: 2300         	movs	r3, #0x0
700a4d94: f00a e9de    	blx	0x700af154 <__aeabi_uldivmod> @ imm = #0xa3bc
700a4d98: 9800         	ldr	r0, [sp]
700a4d9a: 9901         	ldr	r1, [sp, #0x4]
700a4d9c: 1a89         	subs	r1, r1, r2
700a4d9e: 4198         	sbcs	r0, r3
700a4da0: 910d         	str	r1, [sp, #0x34]
700a4da2: 900e         	str	r0, [sp, #0x38]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a4da4: 990d         	ldr	r1, [sp, #0x34]
700a4da6: 980e         	ldr	r0, [sp, #0x38]
700a4da8: 310a         	adds	r1, #0xa
700a4daa: f140 0000    	adc	r0, r0, #0x0
700a4dae: 9111         	str	r1, [sp, #0x44]
700a4db0: 9012         	str	r0, [sp, #0x48]
;     }
700a4db2: e7ff         	b	0x700a4db4 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a4db4: 9818         	ldr	r0, [sp, #0x60]
700a4db6: 28ff         	cmp	r0, #0xff
700a4db8: d307         	blo	0x700a4dca <Sciclient_pmSetModuleClkFreq+0xba> @ imm = #0xe
700a4dba: e7ff         	b	0x700a4dbc <Sciclient_pmSetModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a4dbc: 9818         	ldr	r0, [sp, #0x60]
700a4dbe: f8cd 004d    	str.w	r0, [sp, #0x4d]
700a4dc2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a4dc4: f88d 004c    	strb.w	r0, [sp, #0x4c]
;     }
700a4dc8: e003         	b	0x700a4dd2 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a4dca: 9818         	ldr	r0, [sp, #0x60]
700a4dcc: f88d 004c    	strb.w	r0, [sp, #0x4c]
700a4dd0: e7ff         	b	0x700a4dd2 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #-0x2
700a4dd2: f44f 7086    	mov.w	r0, #0x10c
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_FREQ;
700a4dd6: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     reqParam.flags          = (uint32_t)(TISCI_MSG_FLAG_AOP | additionalFlag);
700a4dda: 981c         	ldr	r0, [sp, #0x70]
700a4ddc: f040 0002    	orr	r0, r0, #0x2
700a4de0: 9006         	str	r0, [sp, #0x18]
700a4de2: a80a         	add	r0, sp, #0x28
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a4de4: 9007         	str	r0, [sp, #0x1c]
700a4de6: 2029         	movs	r0, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a4de8: 9008         	str	r0, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a4dea: 981d         	ldr	r0, [sp, #0x74]
700a4dec: 9009         	str	r0, [sp, #0x24]
700a4dee: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a4df0: 9002         	str	r0, [sp, #0x8]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a4df2: 9003         	str	r0, [sp, #0xc]
;     respParam.respPayloadSize = (uint32_t) 0;
700a4df4: 9004         	str	r0, [sp, #0x10]
700a4df6: a805         	add	r0, sp, #0x14
700a4df8: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a4dfa: f7f8 f9c1    	bl	0x7009d180 <Sciclient_service> @ imm = #-0x7c7e
700a4dfe: 9015         	str	r0, [sp, #0x54]
;     if((retVal != SystemP_SUCCESS) ||
700a4e00: 9815         	ldr	r0, [sp, #0x54]
700a4e02: b930         	cbnz	r0, 0x700a4e12 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #0xc
700a4e04: e7ff         	b	0x700a4e06 <Sciclient_pmSetModuleClkFreq+0xf6> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a4e06: 9802         	ldr	r0, [sp, #0x8]
700a4e08: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a4e0c: 2802         	cmp	r0, #0x2
700a4e0e: d004         	beq	0x700a4e1a <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #0x8
700a4e10: e7ff         	b	0x700a4e12 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #-0x2
700a4e12: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a4e16: 9015         	str	r0, [sp, #0x54]
;     }
700a4e18: e7ff         	b	0x700a4e1a <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #-0x2
;     return retVal;
700a4e1a: 9815         	ldr	r0, [sp, #0x54]
700a4e1c: b01a         	add	sp, #0x68
700a4e1e: bd80         	pop	{r7, pc}

700a4e20 <vTaskSuspend>:
; void vTaskSuspend(TaskHandle_t xTaskToSuspend) {
700a4e20: b580         	push	{r7, lr}
700a4e22: b084         	sub	sp, #0x10
700a4e24: 9003         	str	r0, [sp, #0xc]
;   taskENTER_CRITICAL();
700a4e26: f009 fc4b    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x9896
;     pxTCB = prvGetTCBFromHandle(xTaskToSuspend);
700a4e2a: 9803         	ldr	r0, [sp, #0xc]
700a4e2c: b938         	cbnz	r0, 0x700a4e3e <vTaskSuspend+0x1e> @ imm = #0xe
700a4e2e: e7ff         	b	0x700a4e30 <vTaskSuspend+0x10> @ imm = #-0x2
700a4e30: f642 2000    	movw	r0, #0x2a00
700a4e34: f2c7 000b    	movt	r0, #0x700b
700a4e38: 6800         	ldr	r0, [r0]
700a4e3a: 9000         	str	r0, [sp]
700a4e3c: e002         	b	0x700a4e44 <vTaskSuspend+0x24> @ imm = #0x4
700a4e3e: 9803         	ldr	r0, [sp, #0xc]
700a4e40: 9000         	str	r0, [sp]
700a4e42: e7ff         	b	0x700a4e44 <vTaskSuspend+0x24> @ imm = #-0x2
700a4e44: 9800         	ldr	r0, [sp]
700a4e46: 9002         	str	r0, [sp, #0x8]
;     if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a4e48: 9802         	ldr	r0, [sp, #0x8]
700a4e4a: 3004         	adds	r0, #0x4
700a4e4c: f008 fbe8    	bl	0x700ad620 <uxListRemove> @ imm = #0x87d0
700a4e50: b908         	cbnz	r0, 0x700a4e56 <vTaskSuspend+0x36> @ imm = #0x2
700a4e52: e7ff         	b	0x700a4e54 <vTaskSuspend+0x34> @ imm = #-0x2
;     } else {
700a4e54: e000         	b	0x700a4e58 <vTaskSuspend+0x38> @ imm = #0x0
700a4e56: e7ff         	b	0x700a4e58 <vTaskSuspend+0x38> @ imm = #-0x2
;     if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a4e58: 9802         	ldr	r0, [sp, #0x8]
700a4e5a: 6a80         	ldr	r0, [r0, #0x28]
700a4e5c: b128         	cbz	r0, 0x700a4e6a <vTaskSuspend+0x4a> @ imm = #0xa
700a4e5e: e7ff         	b	0x700a4e60 <vTaskSuspend+0x40> @ imm = #-0x2
;       (void)uxListRemove(&(pxTCB->xEventListItem));
700a4e60: 9802         	ldr	r0, [sp, #0x8]
700a4e62: 3018         	adds	r0, #0x18
700a4e64: f008 fbdc    	bl	0x700ad620 <uxListRemove> @ imm = #0x87b8
;     } else {
700a4e68: e000         	b	0x700a4e6c <vTaskSuspend+0x4c> @ imm = #0x0
700a4e6a: e7ff         	b	0x700a4e6c <vTaskSuspend+0x4c> @ imm = #-0x2
;     vListInsertEnd(&xSuspendedTaskList, &(pxTCB->xStateListItem));
700a4e6c: 9802         	ldr	r0, [sp, #0x8]
700a4e6e: 1d01         	adds	r1, r0, #0x4
700a4e70: f245 00f4    	movw	r0, #0x50f4
700a4e74: f2c7 0008    	movt	r0, #0x7008
700a4e78: f009 f98a    	bl	0x700ae190 <vListInsertEnd> @ imm = #0x9314
700a4e7c: 2000         	movs	r0, #0x0
;       for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a4e7e: 9001         	str	r0, [sp, #0x4]
700a4e80: e7ff         	b	0x700a4e82 <vTaskSuspend+0x62> @ imm = #-0x2
700a4e82: 9801         	ldr	r0, [sp, #0x4]
700a4e84: 2800         	cmp	r0, #0x0
700a4e86: dc14         	bgt	0x700a4eb2 <vTaskSuspend+0x92> @ imm = #0x28
700a4e88: e7ff         	b	0x700a4e8a <vTaskSuspend+0x6a> @ imm = #-0x2
;         if (pxTCB->ucNotifyState[x] == taskWAITING_NOTIFICATION) {
700a4e8a: 9802         	ldr	r0, [sp, #0x8]
700a4e8c: 9901         	ldr	r1, [sp, #0x4]
700a4e8e: 4408         	add	r0, r1
700a4e90: f890 0080    	ldrb.w	r0, [r0, #0x80]
700a4e94: 2801         	cmp	r0, #0x1
700a4e96: d107         	bne	0x700a4ea8 <vTaskSuspend+0x88> @ imm = #0xe
700a4e98: e7ff         	b	0x700a4e9a <vTaskSuspend+0x7a> @ imm = #-0x2
;           pxTCB->ucNotifyState[x] = taskNOT_WAITING_NOTIFICATION;
700a4e9a: 9802         	ldr	r0, [sp, #0x8]
700a4e9c: 9901         	ldr	r1, [sp, #0x4]
700a4e9e: 4401         	add	r1, r0
700a4ea0: 2000         	movs	r0, #0x0
700a4ea2: f881 0080    	strb.w	r0, [r1, #0x80]
;         }
700a4ea6: e7ff         	b	0x700a4ea8 <vTaskSuspend+0x88> @ imm = #-0x2
;       }
700a4ea8: e7ff         	b	0x700a4eaa <vTaskSuspend+0x8a> @ imm = #-0x2
;       for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a4eaa: 9801         	ldr	r0, [sp, #0x4]
700a4eac: 3001         	adds	r0, #0x1
700a4eae: 9001         	str	r0, [sp, #0x4]
700a4eb0: e7e7         	b	0x700a4e82 <vTaskSuspend+0x62> @ imm = #-0x32
;   taskEXIT_CRITICAL();
700a4eb2: f008 fca5    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x894a
;   if (xSchedulerRunning != pdFALSE) {
700a4eb6: f642 2040    	movw	r0, #0x2a40
700a4eba: f2c7 000b    	movt	r0, #0x700b
700a4ebe: 6800         	ldr	r0, [r0]
700a4ec0: b138         	cbz	r0, 0x700a4ed2 <vTaskSuspend+0xb2> @ imm = #0xe
700a4ec2: e7ff         	b	0x700a4ec4 <vTaskSuspend+0xa4> @ imm = #-0x2
;     taskENTER_CRITICAL();
700a4ec4: f009 fbfc    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x97f8
;       prvResetNextTaskUnblockTime();
700a4ec8: f009 f8e2    	bl	0x700ae090 <prvResetNextTaskUnblockTime> @ imm = #0x91c4
;     taskEXIT_CRITICAL();
700a4ecc: f008 fc98    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x8930
;   } else {
700a4ed0: e000         	b	0x700a4ed4 <vTaskSuspend+0xb4> @ imm = #0x0
700a4ed2: e7ff         	b	0x700a4ed4 <vTaskSuspend+0xb4> @ imm = #-0x2
;   if (pxTCB == pxCurrentTCB) {
700a4ed4: 9802         	ldr	r0, [sp, #0x8]
700a4ed6: f642 2100    	movw	r1, #0x2a00
700a4eda: f2c7 010b    	movt	r1, #0x700b
700a4ede: 6809         	ldr	r1, [r1]
700a4ee0: 4288         	cmp	r0, r1
700a4ee2: d122         	bne	0x700a4f2a <vTaskSuspend+0x10a> @ imm = #0x44
700a4ee4: e7ff         	b	0x700a4ee6 <vTaskSuspend+0xc6> @ imm = #-0x2
;     if (xSchedulerRunning != pdFALSE) {
700a4ee6: f642 2040    	movw	r0, #0x2a40
700a4eea: f2c7 000b    	movt	r0, #0x700b
700a4eee: 6800         	ldr	r0, [r0]
700a4ef0: b110         	cbz	r0, 0x700a4ef8 <vTaskSuspend+0xd8> @ imm = #0x4
700a4ef2: e7ff         	b	0x700a4ef4 <vTaskSuspend+0xd4> @ imm = #-0x2
;       portYIELD_WITHIN_API();
700a4ef4: df00         	svc	#0x0
;     } else {
700a4ef6: e017         	b	0x700a4f28 <vTaskSuspend+0x108> @ imm = #0x2e
;       if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) ==
700a4ef8: f245 00f4    	movw	r0, #0x50f4
700a4efc: f2c7 0008    	movt	r0, #0x7008
700a4f00: 6800         	ldr	r0, [r0]
;           uxCurrentNumberOfTasks) /*lint !e931 Right has no side effect, just
700a4f02: f642 211c    	movw	r1, #0x2a1c
700a4f06: f2c7 010b    	movt	r1, #0x700b
700a4f0a: 6809         	ldr	r1, [r1]
;       if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) ==
700a4f0c: 4288         	cmp	r0, r1
700a4f0e: d107         	bne	0x700a4f20 <vTaskSuspend+0x100> @ imm = #0xe
700a4f10: e7ff         	b	0x700a4f12 <vTaskSuspend+0xf2> @ imm = #-0x2
;         pxCurrentTCB = NULL;
700a4f12: f642 2100    	movw	r1, #0x2a00
700a4f16: f2c7 010b    	movt	r1, #0x700b
700a4f1a: 2000         	movs	r0, #0x0
700a4f1c: 6008         	str	r0, [r1]
;       } else {
700a4f1e: e002         	b	0x700a4f26 <vTaskSuspend+0x106> @ imm = #0x4
;         vTaskSwitchContext();
700a4f20: f001 fcbe    	bl	0x700a68a0 <vTaskSwitchContext> @ imm = #0x197c
700a4f24: e7ff         	b	0x700a4f26 <vTaskSuspend+0x106> @ imm = #-0x2
700a4f26: e7ff         	b	0x700a4f28 <vTaskSuspend+0x108> @ imm = #-0x2
;   } else {
700a4f28: e000         	b	0x700a4f2c <vTaskSuspend+0x10c> @ imm = #0x0
700a4f2a: e7ff         	b	0x700a4f2c <vTaskSuspend+0x10c> @ imm = #-0x2
; }
700a4f2c: b004         	add	sp, #0x10
700a4f2e: bd80         	pop	{r7, pc}

700a4f30 <prvAddNewTaskToReadyList>:
; static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB) {
700a4f30: b580         	push	{r7, lr}
700a4f32: b082         	sub	sp, #0x8
700a4f34: 9001         	str	r0, [sp, #0x4]
;   taskENTER_CRITICAL();
700a4f36: f009 fbc3    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x9786
;     uxCurrentNumberOfTasks++;
700a4f3a: f642 211c    	movw	r1, #0x2a1c
700a4f3e: f2c7 010b    	movt	r1, #0x700b
700a4f42: 6808         	ldr	r0, [r1]
700a4f44: 3001         	adds	r0, #0x1
700a4f46: 6008         	str	r0, [r1]
;     if (pxCurrentTCB == NULL) {
700a4f48: f642 2000    	movw	r0, #0x2a00
700a4f4c: f2c7 000b    	movt	r0, #0x700b
700a4f50: 6800         	ldr	r0, [r0]
700a4f52: b998         	cbnz	r0, 0x700a4f7c <prvAddNewTaskToReadyList+0x4c> @ imm = #0x26
700a4f54: e7ff         	b	0x700a4f56 <prvAddNewTaskToReadyList+0x26> @ imm = #-0x2
;       pxCurrentTCB = pxNewTCB;
700a4f56: 9801         	ldr	r0, [sp, #0x4]
700a4f58: f642 2100    	movw	r1, #0x2a00
700a4f5c: f2c7 010b    	movt	r1, #0x700b
700a4f60: 6008         	str	r0, [r1]
;       if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
700a4f62: f642 201c    	movw	r0, #0x2a1c
700a4f66: f2c7 000b    	movt	r0, #0x700b
700a4f6a: 6800         	ldr	r0, [r0]
700a4f6c: 2801         	cmp	r0, #0x1
700a4f6e: d103         	bne	0x700a4f78 <prvAddNewTaskToReadyList+0x48> @ imm = #0x6
700a4f70: e7ff         	b	0x700a4f72 <prvAddNewTaskToReadyList+0x42> @ imm = #-0x2
;         prvInitialiseTaskLists();
700a4f72: f004 fe8d    	bl	0x700a9c90 <prvInitialiseTaskLists> @ imm = #0x4d1a
;       } else {
700a4f76: e000         	b	0x700a4f7a <prvAddNewTaskToReadyList+0x4a> @ imm = #0x0
700a4f78: e7ff         	b	0x700a4f7a <prvAddNewTaskToReadyList+0x4a> @ imm = #-0x2
;     } else {
700a4f7a: e01c         	b	0x700a4fb6 <prvAddNewTaskToReadyList+0x86> @ imm = #0x38
;       if (xSchedulerRunning == pdFALSE) {
700a4f7c: f642 2040    	movw	r0, #0x2a40
700a4f80: f2c7 000b    	movt	r0, #0x700b
700a4f84: 6800         	ldr	r0, [r0]
700a4f86: b9a0         	cbnz	r0, 0x700a4fb2 <prvAddNewTaskToReadyList+0x82> @ imm = #0x28
700a4f88: e7ff         	b	0x700a4f8a <prvAddNewTaskToReadyList+0x5a> @ imm = #-0x2
;         if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
700a4f8a: f642 2000    	movw	r0, #0x2a00
700a4f8e: f2c7 000b    	movt	r0, #0x700b
700a4f92: 6800         	ldr	r0, [r0]
700a4f94: 6ac0         	ldr	r0, [r0, #0x2c]
700a4f96: 9901         	ldr	r1, [sp, #0x4]
700a4f98: 6ac9         	ldr	r1, [r1, #0x2c]
700a4f9a: 4288         	cmp	r0, r1
700a4f9c: d807         	bhi	0x700a4fae <prvAddNewTaskToReadyList+0x7e> @ imm = #0xe
700a4f9e: e7ff         	b	0x700a4fa0 <prvAddNewTaskToReadyList+0x70> @ imm = #-0x2
;           pxCurrentTCB = pxNewTCB;
700a4fa0: 9801         	ldr	r0, [sp, #0x4]
700a4fa2: f642 2100    	movw	r1, #0x2a00
700a4fa6: f2c7 010b    	movt	r1, #0x700b
700a4faa: 6008         	str	r0, [r1]
;         } else {
700a4fac: e000         	b	0x700a4fb0 <prvAddNewTaskToReadyList+0x80> @ imm = #0x0
700a4fae: e7ff         	b	0x700a4fb0 <prvAddNewTaskToReadyList+0x80> @ imm = #-0x2
;       } else {
700a4fb0: e000         	b	0x700a4fb4 <prvAddNewTaskToReadyList+0x84> @ imm = #0x0
700a4fb2: e7ff         	b	0x700a4fb4 <prvAddNewTaskToReadyList+0x84> @ imm = #-0x2
700a4fb4: e7ff         	b	0x700a4fb6 <prvAddNewTaskToReadyList+0x86> @ imm = #-0x2
;     uxTaskNumber++;
700a4fb6: f642 2028    	movw	r0, #0x2a28
700a4fba: f2c7 000b    	movt	r0, #0x700b
700a4fbe: 6801         	ldr	r1, [r0]
700a4fc0: 3101         	adds	r1, #0x1
700a4fc2: 6001         	str	r1, [r0]
;       pxNewTCB->uxTCBNumber = uxTaskNumber;
700a4fc4: 6800         	ldr	r0, [r0]
700a4fc6: 9901         	ldr	r1, [sp, #0x4]
700a4fc8: 6588         	str	r0, [r1, #0x58]
;     prvAddTaskToReadyList(pxNewTCB);
700a4fca: 9801         	ldr	r0, [sp, #0x4]
700a4fcc: 6ac0         	ldr	r0, [r0, #0x2c]
700a4fce: f642 212c    	movw	r1, #0x2a2c
700a4fd2: f2c7 010b    	movt	r1, #0x700b
700a4fd6: 6809         	ldr	r1, [r1]
700a4fd8: 4288         	cmp	r0, r1
700a4fda: d908         	bls	0x700a4fee <prvAddNewTaskToReadyList+0xbe> @ imm = #0x10
700a4fdc: e7ff         	b	0x700a4fde <prvAddNewTaskToReadyList+0xae> @ imm = #-0x2
700a4fde: 9801         	ldr	r0, [sp, #0x4]
700a4fe0: 6ac0         	ldr	r0, [r0, #0x2c]
700a4fe2: f642 212c    	movw	r1, #0x2a2c
700a4fe6: f2c7 010b    	movt	r1, #0x700b
700a4fea: 6008         	str	r0, [r1]
700a4fec: e7ff         	b	0x700a4fee <prvAddNewTaskToReadyList+0xbe> @ imm = #-0x2
700a4fee: 9901         	ldr	r1, [sp, #0x4]
700a4ff0: 6ac8         	ldr	r0, [r1, #0x2c]
700a4ff2: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a4ff6: f244 40f8    	movw	r0, #0x44f8
700a4ffa: f2c7 0008    	movt	r0, #0x7008
700a4ffe: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a5002: 3104         	adds	r1, #0x4
700a5004: f009 f8c4    	bl	0x700ae190 <vListInsertEnd> @ imm = #0x9188
;   taskEXIT_CRITICAL();
700a5008: f008 fbfa    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x87f4
;   if (xSchedulerRunning != pdFALSE) {
700a500c: f642 2040    	movw	r0, #0x2a40
700a5010: f2c7 000b    	movt	r0, #0x700b
700a5014: 6800         	ldr	r0, [r0]
700a5016: b178         	cbz	r0, 0x700a5038 <prvAddNewTaskToReadyList+0x108> @ imm = #0x1e
700a5018: e7ff         	b	0x700a501a <prvAddNewTaskToReadyList+0xea> @ imm = #-0x2
;     if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
700a501a: f642 2000    	movw	r0, #0x2a00
700a501e: f2c7 000b    	movt	r0, #0x700b
700a5022: 6800         	ldr	r0, [r0]
700a5024: 6ac0         	ldr	r0, [r0, #0x2c]
700a5026: 9901         	ldr	r1, [sp, #0x4]
700a5028: 6ac9         	ldr	r1, [r1, #0x2c]
700a502a: 4288         	cmp	r0, r1
700a502c: d202         	bhs	0x700a5034 <prvAddNewTaskToReadyList+0x104> @ imm = #0x4
700a502e: e7ff         	b	0x700a5030 <prvAddNewTaskToReadyList+0x100> @ imm = #-0x2
;       taskYIELD_IF_USING_PREEMPTION();
700a5030: df00         	svc	#0x0
;     } else {
700a5032: e000         	b	0x700a5036 <prvAddNewTaskToReadyList+0x106> @ imm = #0x0
700a5034: e7ff         	b	0x700a5036 <prvAddNewTaskToReadyList+0x106> @ imm = #-0x2
;   } else {
700a5036: e000         	b	0x700a503a <prvAddNewTaskToReadyList+0x10a> @ imm = #0x0
700a5038: e7ff         	b	0x700a503a <prvAddNewTaskToReadyList+0x10a> @ imm = #-0x2
; }
700a503a: b002         	add	sp, #0x8
700a503c: bd80         	pop	{r7, pc}
700a503e: 0000         	movs	r0, r0

700a5040 <xTaskPriorityInherit>:
; BaseType_t xTaskPriorityInherit(TaskHandle_t const pxMutexHolder) {
700a5040: b580         	push	{r7, lr}
700a5042: b084         	sub	sp, #0x10
700a5044: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxMutexHolderTCB = pxMutexHolder;
700a5046: 9803         	ldr	r0, [sp, #0xc]
700a5048: 9002         	str	r0, [sp, #0x8]
700a504a: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a504c: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a504e: 9803         	ldr	r0, [sp, #0xc]
700a5050: 2800         	cmp	r0, #0x0
700a5052: d078         	beq	0x700a5146 <xTaskPriorityInherit+0x106> @ imm = #0xf0
700a5054: e7ff         	b	0x700a5056 <xTaskPriorityInherit+0x16> @ imm = #-0x2
;     if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority) {
700a5056: 9802         	ldr	r0, [sp, #0x8]
700a5058: 6ac0         	ldr	r0, [r0, #0x2c]
700a505a: f642 2100    	movw	r1, #0x2a00
700a505e: f2c7 010b    	movt	r1, #0x700b
700a5062: 6809         	ldr	r1, [r1]
700a5064: 6ac9         	ldr	r1, [r1, #0x2c]
700a5066: 4288         	cmp	r0, r1
700a5068: d25c         	bhs	0x700a5124 <xTaskPriorityInherit+0xe4> @ imm = #0xb8
700a506a: e7ff         	b	0x700a506c <xTaskPriorityInherit+0x2c> @ imm = #-0x2
;       if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) &
700a506c: 9802         	ldr	r0, [sp, #0x8]
700a506e: 7ec0         	ldrb	r0, [r0, #0x1b]
700a5070: 0600         	lsls	r0, r0, #0x18
700a5072: 2800         	cmp	r0, #0x0
700a5074: d40b         	bmi	0x700a508e <xTaskPriorityInherit+0x4e> @ imm = #0x16
700a5076: e7ff         	b	0x700a5078 <xTaskPriorityInherit+0x38> @ imm = #-0x2
;         listSET_LIST_ITEM_VALUE(
700a5078: f642 2000    	movw	r0, #0x2a00
700a507c: f2c7 000b    	movt	r0, #0x700b
700a5080: 6800         	ldr	r0, [r0]
700a5082: 6ac0         	ldr	r0, [r0, #0x2c]
700a5084: f1c0 0020    	rsb.w	r0, r0, #0x20
700a5088: 9902         	ldr	r1, [sp, #0x8]
700a508a: 6188         	str	r0, [r1, #0x18]
;       } else {
700a508c: e000         	b	0x700a5090 <xTaskPriorityInherit+0x50> @ imm = #0x0
700a508e: e7ff         	b	0x700a5090 <xTaskPriorityInherit+0x50> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(
700a5090: 9902         	ldr	r1, [sp, #0x8]
700a5092: 6948         	ldr	r0, [r1, #0x14]
700a5094: 6ac9         	ldr	r1, [r1, #0x2c]
700a5096: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a509a: f244 41f8    	movw	r1, #0x44f8
700a509e: f2c7 0108    	movt	r1, #0x7008
700a50a2: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a50a6: 4288         	cmp	r0, r1
700a50a8: d130         	bne	0x700a510c <xTaskPriorityInherit+0xcc> @ imm = #0x60
700a50aa: e7ff         	b	0x700a50ac <xTaskPriorityInherit+0x6c> @ imm = #-0x2
;         if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) ==
700a50ac: 9802         	ldr	r0, [sp, #0x8]
700a50ae: 3004         	adds	r0, #0x4
700a50b0: f008 fab6    	bl	0x700ad620 <uxListRemove> @ imm = #0x856c
700a50b4: b908         	cbnz	r0, 0x700a50ba <xTaskPriorityInherit+0x7a> @ imm = #0x2
700a50b6: e7ff         	b	0x700a50b8 <xTaskPriorityInherit+0x78> @ imm = #-0x2
;         } else {
700a50b8: e000         	b	0x700a50bc <xTaskPriorityInherit+0x7c> @ imm = #0x0
700a50ba: e7ff         	b	0x700a50bc <xTaskPriorityInherit+0x7c> @ imm = #-0x2
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a50bc: f642 2000    	movw	r0, #0x2a00
700a50c0: f2c7 000b    	movt	r0, #0x700b
700a50c4: 6800         	ldr	r0, [r0]
700a50c6: 6ac0         	ldr	r0, [r0, #0x2c]
700a50c8: 9902         	ldr	r1, [sp, #0x8]
700a50ca: 62c8         	str	r0, [r1, #0x2c]
;         prvAddTaskToReadyList(pxMutexHolderTCB);
700a50cc: 9802         	ldr	r0, [sp, #0x8]
700a50ce: 6ac0         	ldr	r0, [r0, #0x2c]
700a50d0: f642 212c    	movw	r1, #0x2a2c
700a50d4: f2c7 010b    	movt	r1, #0x700b
700a50d8: 6809         	ldr	r1, [r1]
700a50da: 4288         	cmp	r0, r1
700a50dc: d908         	bls	0x700a50f0 <xTaskPriorityInherit+0xb0> @ imm = #0x10
700a50de: e7ff         	b	0x700a50e0 <xTaskPriorityInherit+0xa0> @ imm = #-0x2
700a50e0: 9802         	ldr	r0, [sp, #0x8]
700a50e2: 6ac0         	ldr	r0, [r0, #0x2c]
700a50e4: f642 212c    	movw	r1, #0x2a2c
700a50e8: f2c7 010b    	movt	r1, #0x700b
700a50ec: 6008         	str	r0, [r1]
700a50ee: e7ff         	b	0x700a50f0 <xTaskPriorityInherit+0xb0> @ imm = #-0x2
700a50f0: 9902         	ldr	r1, [sp, #0x8]
700a50f2: 6ac8         	ldr	r0, [r1, #0x2c]
700a50f4: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a50f8: f244 40f8    	movw	r0, #0x44f8
700a50fc: f2c7 0008    	movt	r0, #0x7008
700a5100: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a5104: 3104         	adds	r1, #0x4
700a5106: f009 f843    	bl	0x700ae190 <vListInsertEnd> @ imm = #0x9086
;       } else {
700a510a: e008         	b	0x700a511e <xTaskPriorityInherit+0xde> @ imm = #0x10
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a510c: f642 2000    	movw	r0, #0x2a00
700a5110: f2c7 000b    	movt	r0, #0x700b
700a5114: 6800         	ldr	r0, [r0]
700a5116: 6ac0         	ldr	r0, [r0, #0x2c]
700a5118: 9902         	ldr	r1, [sp, #0x8]
700a511a: 62c8         	str	r0, [r1, #0x2c]
700a511c: e7ff         	b	0x700a511e <xTaskPriorityInherit+0xde> @ imm = #-0x2
700a511e: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a5120: 9001         	str	r0, [sp, #0x4]
;     } else {
700a5122: e00f         	b	0x700a5144 <xTaskPriorityInherit+0x104> @ imm = #0x1e
;       if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority) {
700a5124: 9802         	ldr	r0, [sp, #0x8]
700a5126: 6e00         	ldr	r0, [r0, #0x60]
700a5128: f642 2100    	movw	r1, #0x2a00
700a512c: f2c7 010b    	movt	r1, #0x700b
700a5130: 6809         	ldr	r1, [r1]
700a5132: 6ac9         	ldr	r1, [r1, #0x2c]
700a5134: 4288         	cmp	r0, r1
700a5136: d203         	bhs	0x700a5140 <xTaskPriorityInherit+0x100> @ imm = #0x6
700a5138: e7ff         	b	0x700a513a <xTaskPriorityInherit+0xfa> @ imm = #-0x2
700a513a: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a513c: 9001         	str	r0, [sp, #0x4]
;       } else {
700a513e: e000         	b	0x700a5142 <xTaskPriorityInherit+0x102> @ imm = #0x0
700a5140: e7ff         	b	0x700a5142 <xTaskPriorityInherit+0x102> @ imm = #-0x2
700a5142: e7ff         	b	0x700a5144 <xTaskPriorityInherit+0x104> @ imm = #-0x2
;   } else {
700a5144: e000         	b	0x700a5148 <xTaskPriorityInherit+0x108> @ imm = #0x0
700a5146: e7ff         	b	0x700a5148 <xTaskPriorityInherit+0x108> @ imm = #-0x2
;   return xReturn;
700a5148: 9801         	ldr	r0, [sp, #0x4]
700a514a: b004         	add	sp, #0x10
700a514c: bd80         	pop	{r7, pc}
700a514e: 0000         	movs	r0, r0

700a5150 <tm_isr_message_handler>:
; {
700a5150: b570         	push	{r4, r5, r6, lr}
;    tm_isr_counter++;
700a5152: f642 2008    	movw	r0, #0x2a08
;    message[1] = isr_message_counter;
700a5156: f642 15f8    	movw	r5, #0x29f8
;    tm_isr_counter++;
700a515a: f2c7 000b    	movt	r0, #0x700b
;    message[1] = isr_message_counter;
700a515e: f2c7 050b    	movt	r5, #0x700b
;    message[0] = 1;
700a5162: f644 66c0    	movw	r6, #0x4ec0
700a5166: f2c7 0608    	movt	r6, #0x7008
;    tm_isr_counter++;
700a516a: 6801         	ldr	r1, [r0]
700a516c: 3101         	adds	r1, #0x1
700a516e: 6001         	str	r1, [r0]
700a5170: 2001         	movs	r0, #0x1
;    message[1] = isr_message_counter;
700a5172: 6829         	ldr	r1, [r5]
;    message[0] = 1;
700a5174: 6030         	str	r0, [r6]
700a5176: 2000         	movs	r0, #0x0
;    message[1] = isr_message_counter;
700a5178: 6071         	str	r1, [r6, #0x4]
700a517a: bf00         	nop
700a517c: bf00         	nop
700a517e: bf00         	nop
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a5180: 6829         	ldr	r1, [r5]
700a5182: f200 33eb    	addw	r3, r0, #0x3eb
700a5186: 682a         	ldr	r2, [r5]
;    for (i = 2; i < MESSAGE_SIZE - 1; i++)
700a5188: 281b         	cmp	r0, #0x1b
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a518a: eb01 0181    	add.w	r1, r1, r1, lsl #2
700a518e: eb02 0282    	add.w	r2, r2, r2, lsl #2
700a5192: eb03 0141    	add.w	r1, r3, r1, lsl #1
700a5196: f1a1 0401    	sub.w	r4, r1, #0x1
700a519a: eb06 0180    	add.w	r1, r6, r0, lsl #2
700a519e: eb03 0242    	add.w	r2, r3, r2, lsl #1
700a51a2: e9c1 4202    	strd	r4, r2, [r1, #8]
;    for (i = 2; i < MESSAGE_SIZE - 1; i++)
700a51a6: d009         	beq	0x700a51bc <tm_isr_message_handler+0x6c> @ imm = #0x12
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a51a8: 682a         	ldr	r2, [r5]
700a51aa: eb02 0282    	add.w	r2, r2, r2, lsl #2
700a51ae: eb00 0242    	add.w	r2, r0, r2, lsl #1
700a51b2: 3003         	adds	r0, #0x3
700a51b4: f502 727b    	add.w	r2, r2, #0x3ec
700a51b8: 610a         	str	r2, [r1, #0x10]
700a51ba: e7e1         	b	0x700a5180 <tm_isr_message_handler+0x30> @ imm = #-0x3e
;       checksum += msg[i];
700a51bc: e896 0007    	ldm.w	r6, {r0, r1, r2}
700a51c0: 4408         	add	r0, r1
700a51c2: 68f1         	ldr	r1, [r6, #0xc]
700a51c4: 4410         	add	r0, r2
700a51c6: 6932         	ldr	r2, [r6, #0x10]
700a51c8: 4408         	add	r0, r1
700a51ca: 6971         	ldr	r1, [r6, #0x14]
700a51cc: 4410         	add	r0, r2
700a51ce: 69b2         	ldr	r2, [r6, #0x18]
700a51d0: 4408         	add	r0, r1
700a51d2: 69f1         	ldr	r1, [r6, #0x1c]
700a51d4: 4410         	add	r0, r2
700a51d6: 6a32         	ldr	r2, [r6, #0x20]
700a51d8: 4408         	add	r0, r1
700a51da: 6a71         	ldr	r1, [r6, #0x24]
700a51dc: 4410         	add	r0, r2
700a51de: 6ab2         	ldr	r2, [r6, #0x28]
700a51e0: 4408         	add	r0, r1
700a51e2: 6af1         	ldr	r1, [r6, #0x2c]
700a51e4: 4410         	add	r0, r2
700a51e6: 6b32         	ldr	r2, [r6, #0x30]
700a51e8: 4408         	add	r0, r1
700a51ea: 6b71         	ldr	r1, [r6, #0x34]
700a51ec: 4410         	add	r0, r2
700a51ee: 6bb2         	ldr	r2, [r6, #0x38]
700a51f0: 4408         	add	r0, r1
700a51f2: 6bf1         	ldr	r1, [r6, #0x3c]
700a51f4: 4410         	add	r0, r2
700a51f6: 6c32         	ldr	r2, [r6, #0x40]
700a51f8: 4408         	add	r0, r1
700a51fa: 6c71         	ldr	r1, [r6, #0x44]
700a51fc: 4410         	add	r0, r2
700a51fe: 6cb2         	ldr	r2, [r6, #0x48]
700a5200: 4408         	add	r0, r1
700a5202: 6cf1         	ldr	r1, [r6, #0x4c]
700a5204: 4410         	add	r0, r2
700a5206: 6d32         	ldr	r2, [r6, #0x50]
700a5208: 4408         	add	r0, r1
700a520a: 6d71         	ldr	r1, [r6, #0x54]
700a520c: 4410         	add	r0, r2
700a520e: 6db2         	ldr	r2, [r6, #0x58]
700a5210: 4408         	add	r0, r1
700a5212: 6df1         	ldr	r1, [r6, #0x5c]
700a5214: 4410         	add	r0, r2
700a5216: 6e32         	ldr	r2, [r6, #0x60]
700a5218: 4408         	add	r0, r1
700a521a: 6e71         	ldr	r1, [r6, #0x64]
700a521c: 4410         	add	r0, r2
700a521e: 6eb2         	ldr	r2, [r6, #0x68]
700a5220: 4408         	add	r0, r1
700a5222: 6ef1         	ldr	r1, [r6, #0x6c]
700a5224: 4410         	add	r0, r2
700a5226: 6f32         	ldr	r2, [r6, #0x70]
700a5228: 4408         	add	r0, r1
700a522a: 6f71         	ldr	r1, [r6, #0x74]
700a522c: 4410         	add	r0, r2
700a522e: 6fb2         	ldr	r2, [r6, #0x78]
700a5230: 4408         	add	r0, r1
;    tm_pmu_profile_start(pmu_send_names[isr_message_counter]);
700a5232: f244 7178    	movw	r1, #0x4778
700a5236: f2c7 0108    	movt	r1, #0x7008
;       checksum += msg[i];
700a523a: 4410         	add	r0, r2
;    message[MESSAGE_SIZE - 1] = compute_checksum(message, MESSAGE_SIZE - 1);
700a523c: 67f0         	str	r0, [r6, #0x7c]
;    tm_pmu_profile_start(pmu_send_names[isr_message_counter]);
700a523e: 6828         	ldr	r0, [r5]
700a5240: eb01 1000    	add.w	r0, r1, r0, lsl #4
700a5244: f00a fd8c    	bl	0x700afd60 <tm_pmu_profile_start> @ imm = #0xab18
;    tm_queue_send_from_isr(0, message);
700a5248: 4631         	mov	r1, r6
700a524a: 2000         	movs	r0, #0x0
700a524c: f009 fbb0    	bl	0x700ae9b0 <tm_queue_send_from_isr> @ imm = #0x9760
;    isr_message_counter++; /* Prepare for next iteration */
700a5250: 6828         	ldr	r0, [r5]
700a5252: 3001         	adds	r0, #0x1
700a5254: 6028         	str	r0, [r5]
; }
700a5256: bd70         	pop	{r4, r5, r6, pc}
		...

700a5260 <Udma_eventCheckParams>:
; {
700a5260: b084         	sub	sp, #0x10
700a5262: 9003         	str	r0, [sp, #0xc]
700a5264: 9102         	str	r1, [sp, #0x8]
700a5266: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a5268: 9001         	str	r0, [sp, #0x4]
;     if(UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode)
700a526a: 9802         	ldr	r0, [sp, #0x8]
700a526c: 6840         	ldr	r0, [r0, #0x4]
700a526e: 2801         	cmp	r0, #0x1
700a5270: d109         	bne	0x700a5286 <Udma_eventCheckParams+0x26> @ imm = #0x12
700a5272: e7ff         	b	0x700a5274 <Udma_eventCheckParams+0x14> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a5274: 9802         	ldr	r0, [sp, #0x8]
700a5276: 6900         	ldr	r0, [r0, #0x10]
700a5278: b120         	cbz	r0, 0x700a5284 <Udma_eventCheckParams+0x24> @ imm = #0x8
700a527a: e7ff         	b	0x700a527c <Udma_eventCheckParams+0x1c> @ imm = #-0x2
700a527c: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5280: 9001         	str	r0, [sp, #0x4]
;         }
700a5282: e7ff         	b	0x700a5284 <Udma_eventCheckParams+0x24> @ imm = #-0x2
;     }
700a5284: e7ff         	b	0x700a5286 <Udma_eventCheckParams+0x26> @ imm = #-0x2
;     if(UDMA_EVENT_MODE_SHARED == eventPrms->eventMode)
700a5286: 9802         	ldr	r0, [sp, #0x8]
700a5288: 6840         	ldr	r0, [r0, #0x4]
700a528a: 2802         	cmp	r0, #0x2
700a528c: d126         	bne	0x700a52dc <Udma_eventCheckParams+0x7c> @ imm = #0x4c
700a528e: e7ff         	b	0x700a5290 <Udma_eventCheckParams+0x30> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a5290: 9802         	ldr	r0, [sp, #0x8]
700a5292: 6900         	ldr	r0, [r0, #0x10]
700a5294: b308         	cbz	r0, 0x700a52da <Udma_eventCheckParams+0x7a> @ imm = #0x42
700a5296: e7ff         	b	0x700a5298 <Udma_eventCheckParams+0x38> @ imm = #-0x2
;             controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a5298: 9802         	ldr	r0, [sp, #0x8]
700a529a: 6900         	ldr	r0, [r0, #0x10]
700a529c: 9000         	str	r0, [sp]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a529e: 9800         	ldr	r0, [sp]
700a52a0: 69c0         	ldr	r0, [r0, #0x1c]
700a52a2: b140         	cbz	r0, 0x700a52b6 <Udma_eventCheckParams+0x56> @ imm = #0x10
700a52a4: e7ff         	b	0x700a52a6 <Udma_eventCheckParams+0x46> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR == eventPrms->eventCb))
700a52a6: 9802         	ldr	r0, [sp, #0x8]
700a52a8: 6940         	ldr	r0, [r0, #0x14]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a52aa: b920         	cbnz	r0, 0x700a52b6 <Udma_eventCheckParams+0x56> @ imm = #0x8
700a52ac: e7ff         	b	0x700a52ae <Udma_eventCheckParams+0x4e> @ imm = #-0x2
700a52ae: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a52b2: 9001         	str	r0, [sp, #0x4]
;             }
700a52b4: e7ff         	b	0x700a52b6 <Udma_eventCheckParams+0x56> @ imm = #-0x2
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a52b6: 9800         	ldr	r0, [sp]
700a52b8: 69c0         	ldr	r0, [r0, #0x1c]
700a52ba: b968         	cbnz	r0, 0x700a52d8 <Udma_eventCheckParams+0x78> @ imm = #0x1a
700a52bc: e7ff         	b	0x700a52be <Udma_eventCheckParams+0x5e> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
700a52be: 9802         	ldr	r0, [sp, #0x8]
700a52c0: 6940         	ldr	r0, [r0, #0x14]
700a52c2: b148         	cbz	r0, 0x700a52d8 <Udma_eventCheckParams+0x78> @ imm = #0x12
700a52c4: e7ff         	b	0x700a52c6 <Udma_eventCheckParams+0x66> @ imm = #-0x2
;                (UDMA_EVENT_TYPE_MASTER != controllerEventHandle->eventPrms.eventType))
700a52c6: 9800         	ldr	r0, [sp]
700a52c8: 6880         	ldr	r0, [r0, #0x8]
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a52ca: 2805         	cmp	r0, #0x5
700a52cc: d004         	beq	0x700a52d8 <Udma_eventCheckParams+0x78> @ imm = #0x8
700a52ce: e7ff         	b	0x700a52d0 <Udma_eventCheckParams+0x70> @ imm = #-0x2
700a52d0: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a52d4: 9001         	str	r0, [sp, #0x4]
;             }
700a52d6: e7ff         	b	0x700a52d8 <Udma_eventCheckParams+0x78> @ imm = #-0x2
;         }
700a52d8: e7ff         	b	0x700a52da <Udma_eventCheckParams+0x7a> @ imm = #-0x2
;     }
700a52da: e7ff         	b	0x700a52dc <Udma_eventCheckParams+0x7c> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a52dc: 9802         	ldr	r0, [sp, #0x8]
700a52de: 6800         	ldr	r0, [r0]
700a52e0: 2801         	cmp	r0, #0x1
700a52e2: d00f         	beq	0x700a5304 <Udma_eventCheckParams+0xa4> @ imm = #0x1e
700a52e4: e7ff         	b	0x700a52e6 <Udma_eventCheckParams+0x86> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a52e6: 9802         	ldr	r0, [sp, #0x8]
700a52e8: 6800         	ldr	r0, [r0]
700a52ea: 2806         	cmp	r0, #0x6
700a52ec: d00a         	beq	0x700a5304 <Udma_eventCheckParams+0xa4> @ imm = #0x14
700a52ee: e7ff         	b	0x700a52f0 <Udma_eventCheckParams+0x90> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
700a52f0: 9802         	ldr	r0, [sp, #0x8]
700a52f2: 6800         	ldr	r0, [r0]
700a52f4: 2802         	cmp	r0, #0x2
700a52f6: d005         	beq	0x700a5304 <Udma_eventCheckParams+0xa4> @ imm = #0xa
700a52f8: e7ff         	b	0x700a52fa <Udma_eventCheckParams+0x9a> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TR == eventPrms->eventType))
700a52fa: 9802         	ldr	r0, [sp, #0x8]
700a52fc: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a52fe: 2803         	cmp	r0, #0x3
700a5300: d109         	bne	0x700a5316 <Udma_eventCheckParams+0xb6> @ imm = #0x12
700a5302: e7ff         	b	0x700a5304 <Udma_eventCheckParams+0xa4> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->chHandle)
700a5304: 9802         	ldr	r0, [sp, #0x8]
700a5306: 6880         	ldr	r0, [r0, #0x8]
700a5308: b920         	cbnz	r0, 0x700a5314 <Udma_eventCheckParams+0xb4> @ imm = #0x8
700a530a: e7ff         	b	0x700a530c <Udma_eventCheckParams+0xac> @ imm = #-0x2
700a530c: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5310: 9001         	str	r0, [sp, #0x4]
;         }
700a5312: e7ff         	b	0x700a5314 <Udma_eventCheckParams+0xb4> @ imm = #-0x2
;     }
700a5314: e7ff         	b	0x700a5316 <Udma_eventCheckParams+0xb6> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
700a5316: 9802         	ldr	r0, [sp, #0x8]
700a5318: 6800         	ldr	r0, [r0]
700a531a: 2804         	cmp	r0, #0x4
700a531c: d109         	bne	0x700a5332 <Udma_eventCheckParams+0xd2> @ imm = #0x12
700a531e: e7ff         	b	0x700a5320 <Udma_eventCheckParams+0xc0> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->ringHandle)
700a5320: 9802         	ldr	r0, [sp, #0x8]
700a5322: 68c0         	ldr	r0, [r0, #0xc]
700a5324: b920         	cbnz	r0, 0x700a5330 <Udma_eventCheckParams+0xd0> @ imm = #0x8
700a5326: e7ff         	b	0x700a5328 <Udma_eventCheckParams+0xc8> @ imm = #-0x2
700a5328: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a532c: 9001         	str	r0, [sp, #0x4]
;         }
700a532e: e7ff         	b	0x700a5330 <Udma_eventCheckParams+0xd0> @ imm = #-0x2
;     }
700a5330: e7ff         	b	0x700a5332 <Udma_eventCheckParams+0xd2> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_MASTER == eventPrms->eventType)
700a5332: 9802         	ldr	r0, [sp, #0x8]
700a5334: 6800         	ldr	r0, [r0]
700a5336: 2805         	cmp	r0, #0x5
700a5338: d112         	bne	0x700a5360 <Udma_eventCheckParams+0x100> @ imm = #0x24
700a533a: e7ff         	b	0x700a533c <Udma_eventCheckParams+0xdc> @ imm = #-0x2
;         if(UDMA_EVENT_MODE_SHARED != eventPrms->eventMode)
700a533c: 9802         	ldr	r0, [sp, #0x8]
700a533e: 6840         	ldr	r0, [r0, #0x4]
700a5340: 2802         	cmp	r0, #0x2
700a5342: d004         	beq	0x700a534e <Udma_eventCheckParams+0xee> @ imm = #0x8
700a5344: e7ff         	b	0x700a5346 <Udma_eventCheckParams+0xe6> @ imm = #-0x2
700a5346: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a534a: 9001         	str	r0, [sp, #0x4]
;         }
700a534c: e7ff         	b	0x700a534e <Udma_eventCheckParams+0xee> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a534e: 9802         	ldr	r0, [sp, #0x8]
700a5350: 6900         	ldr	r0, [r0, #0x10]
700a5352: b120         	cbz	r0, 0x700a535e <Udma_eventCheckParams+0xfe> @ imm = #0x8
700a5354: e7ff         	b	0x700a5356 <Udma_eventCheckParams+0xf6> @ imm = #-0x2
700a5356: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a535a: 9001         	str	r0, [sp, #0x4]
;         }
700a535c: e7ff         	b	0x700a535e <Udma_eventCheckParams+0xfe> @ imm = #-0x2
;     }
700a535e: e7ff         	b	0x700a5360 <Udma_eventCheckParams+0x100> @ imm = #-0x2
;     return (retVal);
700a5360: 9801         	ldr	r0, [sp, #0x4]
700a5362: b004         	add	sp, #0x10
700a5364: 4770         	bx	lr
		...
700a536e: 0000         	movs	r0, r0

700a5370 <CSL_pktdmaTeardownChan>:
; {
700a5370: b580         	push	{r7, lr}
700a5372: b088         	sub	sp, #0x20
700a5374: 4684         	mov	r12, r0
700a5376: 980a         	ldr	r0, [sp, #0x28]
700a5378: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a537c: 9106         	str	r1, [sp, #0x18]
700a537e: 9205         	str	r2, [sp, #0x14]
700a5380: f88d 3013    	strb.w	r3, [sp, #0x13]
700a5384: f88d 0012    	strb.w	r0, [sp, #0x12]
700a5388: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
700a538a: 9003         	str	r0, [sp, #0xc]
;     if( (pCfg == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a538c: 9807         	ldr	r0, [sp, #0x1c]
700a538e: b138         	cbz	r0, 0x700a53a0 <CSL_pktdmaTeardownChan+0x30> @ imm = #0xe
700a5390: e7ff         	b	0x700a5392 <CSL_pktdmaTeardownChan+0x22> @ imm = #-0x2
700a5392: 9807         	ldr	r0, [sp, #0x1c]
700a5394: 9906         	ldr	r1, [sp, #0x18]
700a5396: 9a05         	ldr	r2, [sp, #0x14]
700a5398: f007 fc72    	bl	0x700acc80 <CSL_pktdmaIsValidChanIdx> @ imm = #0x78e4
700a539c: b920         	cbnz	r0, 0x700a53a8 <CSL_pktdmaTeardownChan+0x38> @ imm = #0x8
700a539e: e7ff         	b	0x700a53a0 <CSL_pktdmaTeardownChan+0x30> @ imm = #-0x2
700a53a0: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a53a4: 9003         	str	r0, [sp, #0xc]
;     }
700a53a6: e062         	b	0x700a546e <CSL_pktdmaTeardownChan+0xfe> @ imm = #0xc4
;         if( CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true )
700a53a8: 9807         	ldr	r0, [sp, #0x1c]
700a53aa: 9906         	ldr	r1, [sp, #0x18]
700a53ac: 9a05         	ldr	r2, [sp, #0x14]
700a53ae: f007 fe97    	bl	0x700ad0e0 <CSL_pktdmaIsChanEnabled> @ imm = #0x7d2e
700a53b2: 2800         	cmp	r0, #0x0
700a53b4: d056         	beq	0x700a5464 <CSL_pktdmaTeardownChan+0xf4> @ imm = #0xac
700a53b6: e7ff         	b	0x700a53b8 <CSL_pktdmaTeardownChan+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a53b8: 9805         	ldr	r0, [sp, #0x14]
700a53ba: b9a8         	cbnz	r0, 0x700a53e8 <CSL_pktdmaTeardownChan+0x78> @ imm = #0x2a
700a53bc: e7ff         	b	0x700a53be <CSL_pktdmaTeardownChan+0x4e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a53be: 9807         	ldr	r0, [sp, #0x1c]
700a53c0: 6900         	ldr	r0, [r0, #0x10]
700a53c2: 9906         	ldr	r1, [sp, #0x18]
700a53c4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a53c8: f00a fc0a    	bl	0x700afbe0 <CSL_REG32_RD_RAW> @ imm = #0xa814
700a53cc: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a53ce: 9802         	ldr	r0, [sp, #0x8]
700a53d0: f040 4080    	orr	r0, r0, #0x40000000
700a53d4: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a53d6: 9807         	ldr	r0, [sp, #0x1c]
700a53d8: 6900         	ldr	r0, [r0, #0x10]
700a53da: 9906         	ldr	r1, [sp, #0x18]
700a53dc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a53e0: 9902         	ldr	r1, [sp, #0x8]
700a53e2: f00a fb55    	bl	0x700afa90 <CSL_REG32_WR_RAW> @ imm = #0xa6aa
;             }
700a53e6: e014         	b	0x700a5412 <CSL_pktdmaTeardownChan+0xa2> @ imm = #0x28
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a53e8: 9807         	ldr	r0, [sp, #0x1c]
700a53ea: 6940         	ldr	r0, [r0, #0x14]
700a53ec: 9906         	ldr	r1, [sp, #0x18]
700a53ee: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a53f2: f00a fbf5    	bl	0x700afbe0 <CSL_REG32_RD_RAW> @ imm = #0xa7ea
700a53f6: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a53f8: 9802         	ldr	r0, [sp, #0x8]
700a53fa: f040 4080    	orr	r0, r0, #0x40000000
700a53fe: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a5400: 9807         	ldr	r0, [sp, #0x1c]
700a5402: 6940         	ldr	r0, [r0, #0x14]
700a5404: 9906         	ldr	r1, [sp, #0x18]
700a5406: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a540a: 9902         	ldr	r1, [sp, #0x8]
700a540c: f00a fb40    	bl	0x700afa90 <CSL_REG32_WR_RAW> @ imm = #0xa680
700a5410: e7ff         	b	0x700a5412 <CSL_pktdmaTeardownChan+0xa2> @ imm = #-0x2
;             if( bWait == (bool)true )
700a5412: f89d 0012    	ldrb.w	r0, [sp, #0x12]
700a5416: 07c0         	lsls	r0, r0, #0x1f
700a5418: b318         	cbz	r0, 0x700a5462 <CSL_pktdmaTeardownChan+0xf2> @ imm = #0x46
700a541a: e7ff         	b	0x700a541c <CSL_pktdmaTeardownChan+0xac> @ imm = #-0x2
700a541c: 2080         	movs	r0, #0x80
;                 uint32_t retryCnt = CSL_PKTDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
700a541e: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a5420: e7ff         	b	0x700a5422 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x2
700a5422: 9807         	ldr	r0, [sp, #0x1c]
700a5424: 9906         	ldr	r1, [sp, #0x18]
700a5426: 9a05         	ldr	r2, [sp, #0x14]
700a5428: f007 fe5a    	bl	0x700ad0e0 <CSL_pktdmaIsChanEnabled> @ imm = #0x7cb4
700a542c: 4601         	mov	r1, r0
700a542e: 2000         	movs	r0, #0x0
700a5430: 9000         	str	r0, [sp]
700a5432: b131         	cbz	r1, 0x700a5442 <CSL_pktdmaTeardownChan+0xd2> @ imm = #0xc
700a5434: e7ff         	b	0x700a5436 <CSL_pktdmaTeardownChan+0xc6> @ imm = #-0x2
700a5436: 9801         	ldr	r0, [sp, #0x4]
700a5438: 2800         	cmp	r0, #0x0
700a543a: bf18         	it	ne
700a543c: 2001         	movne	r0, #0x1
700a543e: 9000         	str	r0, [sp]
700a5440: e7ff         	b	0x700a5442 <CSL_pktdmaTeardownChan+0xd2> @ imm = #-0x2
700a5442: 9800         	ldr	r0, [sp]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a5444: 07c0         	lsls	r0, r0, #0x1f
700a5446: b120         	cbz	r0, 0x700a5452 <CSL_pktdmaTeardownChan+0xe2> @ imm = #0x8
700a5448: e7ff         	b	0x700a544a <CSL_pktdmaTeardownChan+0xda> @ imm = #-0x2
;                     retryCnt--;
700a544a: 9801         	ldr	r0, [sp, #0x4]
700a544c: 3801         	subs	r0, #0x1
700a544e: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a5450: e7e7         	b	0x700a5422 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x32
;                 if( retryCnt == (uint32_t)0U ) {
700a5452: 9801         	ldr	r0, [sp, #0x4]
700a5454: b920         	cbnz	r0, 0x700a5460 <CSL_pktdmaTeardownChan+0xf0> @ imm = #0x8
700a5456: e7ff         	b	0x700a5458 <CSL_pktdmaTeardownChan+0xe8> @ imm = #-0x2
700a5458: f04f 30ff    	mov.w	r0, #0xffffffff
;                     retVal = CSL_EFAIL;
700a545c: 9003         	str	r0, [sp, #0xc]
;                 }
700a545e: e7ff         	b	0x700a5460 <CSL_pktdmaTeardownChan+0xf0> @ imm = #-0x2
;             }
700a5460: e7ff         	b	0x700a5462 <CSL_pktdmaTeardownChan+0xf2> @ imm = #-0x2
;         }
700a5462: e003         	b	0x700a546c <CSL_pktdmaTeardownChan+0xfc> @ imm = #0x6
700a5464: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a5468: 9003         	str	r0, [sp, #0xc]
700a546a: e7ff         	b	0x700a546c <CSL_pktdmaTeardownChan+0xfc> @ imm = #-0x2
700a546c: e7ff         	b	0x700a546e <CSL_pktdmaTeardownChan+0xfe> @ imm = #-0x2
;     return retVal;
700a546e: 9803         	ldr	r0, [sp, #0xc]
700a5470: b008         	add	sp, #0x20
700a5472: bd80         	pop	{r7, pc}
		...

700a5480 <UART_configInstance>:
; {
700a5480: b580         	push	{r7, lr}
700a5482: b088         	sub	sp, #0x20
700a5484: 9007         	str	r0, [sp, #0x1c]
;     baseAddr = hUart->baseAddr;
700a5486: 9807         	ldr	r0, [sp, #0x1c]
700a5488: 6800         	ldr	r0, [r0]
700a548a: 9006         	str	r0, [sp, #0x18]
;     hUartInit = hUart->hUartInit;
700a548c: 9807         	ldr	r0, [sp, #0x1c]
700a548e: 6840         	ldr	r0, [r0, #0x4]
700a5490: 9001         	str	r0, [sp, #0x4]
;     UART_resetModule(hUart);
700a5492: 9807         	ldr	r0, [sp, #0x1c]
700a5494: f008 f854    	bl	0x700ad540 <UART_resetModule> @ imm = #0x80a8
;     if(UART_CONFIG_MODE_DMA == hUartInit->transferMode)
700a5498: 9801         	ldr	r0, [sp, #0x4]
700a549a: 6a00         	ldr	r0, [r0, #0x20]
700a549c: 2803         	cmp	r0, #0x3
700a549e: d10e         	bne	0x700a54be <UART_configInstance+0x3e> @ imm = #0x1c
700a54a0: e7ff         	b	0x700a54a2 <UART_configInstance+0x22> @ imm = #-0x2
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a54a2: 9801         	ldr	r0, [sp, #0x4]
700a54a4: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a54a8: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a54ac: 0380         	lsls	r0, r0, #0xe
700a54ae: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a54b2: 2131         	movs	r1, #0x31
700a54b4: f2c0 4140    	movt	r1, #0x440
700a54b8: 4308         	orrs	r0, r1
700a54ba: 9005         	str	r0, [sp, #0x14]
;     }
700a54bc: e00d         	b	0x700a54da <UART_configInstance+0x5a> @ imm = #0x1a
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a54be: 9801         	ldr	r0, [sp, #0x4]
700a54c0: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a54c4: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a54c8: 0380         	lsls	r0, r0, #0xe
700a54ca: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a54ce: 2130         	movs	r1, #0x30
700a54d0: f2c0 4140    	movt	r1, #0x440
700a54d4: 4308         	orrs	r0, r1
700a54d6: 9005         	str	r0, [sp, #0x14]
700a54d8: e7ff         	b	0x700a54da <UART_configInstance+0x5a> @ imm = #-0x2
;     (void)UART_fifoConfig(baseAddr, regVal);
700a54da: 9806         	ldr	r0, [sp, #0x18]
700a54dc: 9905         	ldr	r1, [sp, #0x14]
700a54de: f7f8 fe07    	bl	0x7009e0f0 <UART_fifoConfig> @ imm = #-0x73f2
;     UART_timeGuardConfig(baseAddr, hUartInit->timeGuardVal);
700a54e2: 9806         	ldr	r0, [sp, #0x18]
700a54e4: 9901         	ldr	r1, [sp, #0x4]
700a54e6: 6d09         	ldr	r1, [r1, #0x50]
700a54e8: f00a f88a    	bl	0x700af600 <UART_timeGuardConfig> @ imm = #0xa114
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a54ec: 9a01         	ldr	r2, [sp, #0x4]
700a54ee: 6810         	ldr	r0, [r2]
;                                     hUartInit->baudRate,
700a54f0: 6851         	ldr	r1, [r2, #0x4]
;                                     hUartInit->operMode,
700a54f2: 6ad2         	ldr	r2, [r2, #0x2c]
700a54f4: 232a         	movs	r3, #0x2a
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a54f6: f006 fa2b    	bl	0x700ab950 <UART_divisorValCompute> @ imm = #0x6456
700a54fa: 9004         	str	r0, [sp, #0x10]
;     (void)UART_divisorLatchWrite(baseAddr, divisorVal);
700a54fc: 9806         	ldr	r0, [sp, #0x18]
700a54fe: 9904         	ldr	r1, [sp, #0x10]
700a5500: f7ff fa56    	bl	0x700a49b0 <UART_divisorLatchWrite> @ imm = #-0xb54
;     (void)UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a5504: 9806         	ldr	r0, [sp, #0x18]
700a5506: 21bf         	movs	r1, #0xbf
700a5508: f007 f89a    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x7134
;     wLenStbFlag = (hUartInit->dataLength << UART_LCR_CHAR_LENGTH_SHIFT);
700a550c: 9801         	ldr	r0, [sp, #0x4]
700a550e: 6880         	ldr	r0, [r0, #0x8]
700a5510: 9003         	str	r0, [sp, #0xc]
;     wLenStbFlag |= (hUartInit->stopBits << UART_LCR_NB_STOP_SHIFT);
700a5512: 9801         	ldr	r0, [sp, #0x4]
700a5514: 68c1         	ldr	r1, [r0, #0xc]
700a5516: 9803         	ldr	r0, [sp, #0xc]
700a5518: ea40 0081    	orr.w	r0, r0, r1, lsl #2
700a551c: 9003         	str	r0, [sp, #0xc]
;     parityFlag = (hUartInit->parityType << UART_LCR_PARITY_EN_SHIFT);
700a551e: 9801         	ldr	r0, [sp, #0x4]
700a5520: 6900         	ldr	r0, [r0, #0x10]
700a5522: 00c0         	lsls	r0, r0, #0x3
700a5524: 9002         	str	r0, [sp, #0x8]
;     UART_lineCharConfig(baseAddr, wLenStbFlag, parityFlag);
700a5526: 9806         	ldr	r0, [sp, #0x18]
700a5528: 9903         	ldr	r1, [sp, #0xc]
700a552a: 9a02         	ldr	r2, [sp, #0x8]
700a552c: f007 ff90    	bl	0x700ad450 <UART_lineCharConfig> @ imm = #0x7f20
;     UART_divisorLatchDisable(baseAddr);
700a5530: 9806         	ldr	r0, [sp, #0x18]
700a5532: f00a f8c5    	bl	0x700af6c0 <UART_divisorLatchDisable> @ imm = #0xa18a
;     UART_breakCtl(baseAddr, UART_BREAK_COND_DISABLE);
700a5536: 9806         	ldr	r0, [sp, #0x18]
700a5538: 2100         	movs	r1, #0x0
700a553a: f009 ff61    	bl	0x700af400 <UART_breakCtl> @ imm = #0x9ec2
;     (void)UART_operatingModeSelect(baseAddr, hUartInit->operMode);
700a553e: 9806         	ldr	r0, [sp, #0x18]
700a5540: 9901         	ldr	r1, [sp, #0x4]
700a5542: 6ac9         	ldr	r1, [r1, #0x2c]
700a5544: f009 fc14    	bl	0x700aed70 <UART_operatingModeSelect> @ imm = #0x9828
;     if (hUartInit->hwFlowControl == (uint32_t)TRUE)
700a5548: 9801         	ldr	r0, [sp, #0x4]
700a554a: 6980         	ldr	r0, [r0, #0x18]
700a554c: 2801         	cmp	r0, #0x1
700a554e: d112         	bne	0x700a5576 <UART_configInstance+0xf6> @ imm = #0x24
700a5550: e7ff         	b	0x700a5552 <UART_configInstance+0xd2> @ imm = #-0x2
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_RTS_CTS_ENABLE);
700a5552: 9806         	ldr	r0, [sp, #0x18]
700a5554: 2103         	movs	r1, #0x3
700a5556: f009 f893    	bl	0x700ae680 <UART_hardwareFlowCtrlOptSet> @ imm = #0x9126
;         if (hUartInit->hwFlowControlThr >= hUartInit->rxTrigLvl)
700a555a: 9901         	ldr	r1, [sp, #0x4]
700a555c: 69c8         	ldr	r0, [r1, #0x1c]
700a555e: 6b89         	ldr	r1, [r1, #0x38]
700a5560: 4288         	cmp	r0, r1
700a5562: d307         	blo	0x700a5574 <UART_configInstance+0xf4> @ imm = #0xe
700a5564: e7ff         	b	0x700a5566 <UART_configInstance+0xe6> @ imm = #-0x2
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a5566: 9806         	ldr	r0, [sp, #0x18]
;                                     hUartInit->hwFlowControlThr,
700a5568: 9a01         	ldr	r2, [sp, #0x4]
700a556a: 69d1         	ldr	r1, [r2, #0x1c]
;                                     hUartInit->rxTrigLvl);
700a556c: 6b92         	ldr	r2, [r2, #0x38]
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a556e: f009 f917    	bl	0x700ae7a0 <UART_flowCtrlTrigLvlConfig> @ imm = #0x922e
;         }
700a5572: e7ff         	b	0x700a5574 <UART_configInstance+0xf4> @ imm = #-0x2
;     }
700a5574: e004         	b	0x700a5580 <UART_configInstance+0x100> @ imm = #0x8
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_NO_HARDWARE_FLOW_CONTROL);
700a5576: 9806         	ldr	r0, [sp, #0x18]
700a5578: 2100         	movs	r1, #0x0
700a557a: f009 f881    	bl	0x700ae680 <UART_hardwareFlowCtrlOptSet> @ imm = #0x9102
700a557e: e7ff         	b	0x700a5580 <UART_configInstance+0x100> @ imm = #-0x2
;     return;
700a5580: b008         	add	sp, #0x20
700a5582: bd80         	pop	{r7, pc}
		...

700a5590 <Sciclient_rmIrGetOutp>:
; {
700a5590: b580         	push	{r7, lr}
700a5592: b088         	sub	sp, #0x20
700a5594: f8ad 001e    	strh.w	r0, [sp, #0x1e]
700a5598: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a559c: 9206         	str	r2, [sp, #0x18]
700a559e: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a55a0: 9005         	str	r0, [sp, #0x14]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a55a2: 9004         	str	r0, [sp, #0x10]
;     if (outp == NULL) {
700a55a4: 9806         	ldr	r0, [sp, #0x18]
700a55a6: b920         	cbnz	r0, 0x700a55b2 <Sciclient_rmIrGetOutp+0x22> @ imm = #0x8
700a55a8: e7ff         	b	0x700a55aa <Sciclient_rmIrGetOutp+0x1a> @ imm = #-0x2
700a55aa: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a55ae: 9005         	str	r0, [sp, #0x14]
;     } else {
700a55b0: e018         	b	0x700a55e4 <Sciclient_rmIrGetOutp+0x54> @ imm = #0x30
;         inst = Sciclient_rmIrGetInst(id);
700a55b2: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
700a55b6: f006 fa3b    	bl	0x700aba30 <Sciclient_rmIrGetInst> @ imm = #0x6476
700a55ba: 9004         	str	r0, [sp, #0x10]
;         if (inst == NULL) {
700a55bc: 9804         	ldr	r0, [sp, #0x10]
700a55be: b920         	cbnz	r0, 0x700a55ca <Sciclient_rmIrGetOutp+0x3a> @ imm = #0x8
700a55c0: e7ff         	b	0x700a55c2 <Sciclient_rmIrGetOutp+0x32> @ imm = #-0x2
700a55c2: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a55c6: 9005         	str	r0, [sp, #0x14]
;         } else {
700a55c8: e00b         	b	0x700a55e2 <Sciclient_rmIrGetOutp+0x52> @ imm = #0x16
;             if (inp >= inst->n_inp) {
700a55ca: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a55ce: 9904         	ldr	r1, [sp, #0x10]
700a55d0: 8909         	ldrh	r1, [r1, #0x8]
700a55d2: 4288         	cmp	r0, r1
700a55d4: db04         	blt	0x700a55e0 <Sciclient_rmIrGetOutp+0x50> @ imm = #0x8
700a55d6: e7ff         	b	0x700a55d8 <Sciclient_rmIrGetOutp+0x48> @ imm = #-0x2
700a55d8: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a55dc: 9005         	str	r0, [sp, #0x14]
;             }
700a55de: e7ff         	b	0x700a55e0 <Sciclient_rmIrGetOutp+0x50> @ imm = #-0x2
700a55e0: e7ff         	b	0x700a55e2 <Sciclient_rmIrGetOutp+0x52> @ imm = #-0x2
700a55e2: e7ff         	b	0x700a55e4 <Sciclient_rmIrGetOutp+0x54> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp == 0u)) {
700a55e4: 9805         	ldr	r0, [sp, #0x14]
700a55e6: b9a8         	cbnz	r0, 0x700a5614 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x2a
700a55e8: e7ff         	b	0x700a55ea <Sciclient_rmIrGetOutp+0x5a> @ imm = #-0x2
700a55ea: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a55ee: b988         	cbnz	r0, 0x700a5614 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x22
700a55f0: e7ff         	b	0x700a55f2 <Sciclient_rmIrGetOutp+0x62> @ imm = #-0x2
;         if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a55f2: 9804         	ldr	r0, [sp, #0x10]
700a55f4: 8980         	ldrh	r0, [r0, #0xc]
700a55f6: f64f 71ff    	movw	r1, #0xffff
700a55fa: 4288         	cmp	r0, r1
700a55fc: d005         	beq	0x700a560a <Sciclient_rmIrGetOutp+0x7a> @ imm = #0xa
700a55fe: e7ff         	b	0x700a5600 <Sciclient_rmIrGetOutp+0x70> @ imm = #-0x2
;             *outp = inst->inp0_mapping;
700a5600: 9804         	ldr	r0, [sp, #0x10]
700a5602: 8980         	ldrh	r0, [r0, #0xc]
700a5604: 9906         	ldr	r1, [sp, #0x18]
700a5606: 8008         	strh	r0, [r1]
;         } else {
700a5608: e003         	b	0x700a5612 <Sciclient_rmIrGetOutp+0x82> @ imm = #0x6
700a560a: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a560e: 9005         	str	r0, [sp, #0x14]
700a5610: e7ff         	b	0x700a5612 <Sciclient_rmIrGetOutp+0x82> @ imm = #-0x2
;     }
700a5612: e7ff         	b	0x700a5614 <Sciclient_rmIrGetOutp+0x84> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp != 0u)) {
700a5614: 9805         	ldr	r0, [sp, #0x14]
700a5616: bbb8         	cbnz	r0, 0x700a5688 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x6e
700a5618: e7ff         	b	0x700a561a <Sciclient_rmIrGetOutp+0x8a> @ imm = #-0x2
700a561a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a561e: b398         	cbz	r0, 0x700a5688 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x66
700a5620: e7ff         	b	0x700a5622 <Sciclient_rmIrGetOutp+0x92> @ imm = #-0x2
700a5622: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a5626: 9005         	str	r0, [sp, #0x14]
700a5628: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_outp; i++) {
700a562a: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a562e: e7ff         	b	0x700a5630 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x2
700a5630: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a5634: 9904         	ldr	r1, [sp, #0x10]
700a5636: 8949         	ldrh	r1, [r1, #0xa]
700a5638: 4288         	cmp	r0, r1
700a563a: da24         	bge	0x700a5686 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0x48
700a563c: e7ff         	b	0x700a563e <Sciclient_rmIrGetOutp+0xae> @ imm = #-0x2
;             int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, i);
700a563e: 9804         	ldr	r0, [sp, #0x10]
700a5640: 6840         	ldr	r0, [r0, #0x4]
700a5642: f8bd 100e    	ldrh.w	r1, [sp, #0xe]
700a5646: f009 fa5b    	bl	0x700aeb00 <Sciclient_getIrAddr> @ imm = #0x94b6
700a564a: 9002         	str	r0, [sp, #0x8]
;             extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a564c: 9802         	ldr	r0, [sp, #0x8]
700a564e: f240 31ff    	movw	r1, #0x3ff
700a5652: 2200         	movs	r2, #0x0
700a5654: f009 fd3c    	bl	0x700af0d0 <CSL_REG32_FEXT_RAW> @ imm = #0x9a78
700a5658: f8ad 0006    	strh.w	r0, [sp, #0x6]
;             if (inp == extracted_inp) {
700a565c: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a5660: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700a5664: 4288         	cmp	r0, r1
700a5666: d107         	bne	0x700a5678 <Sciclient_rmIrGetOutp+0xe8> @ imm = #0xe
700a5668: e7ff         	b	0x700a566a <Sciclient_rmIrGetOutp+0xda> @ imm = #-0x2
;                 *outp = i;
700a566a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a566e: 9906         	ldr	r1, [sp, #0x18]
700a5670: 8008         	strh	r0, [r1]
700a5672: 2000         	movs	r0, #0x0
;                 r = SystemP_SUCCESS;
700a5674: 9005         	str	r0, [sp, #0x14]
;                 break;
700a5676: e006         	b	0x700a5686 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0xc
;         }
700a5678: e7ff         	b	0x700a567a <Sciclient_rmIrGetOutp+0xea> @ imm = #-0x2
;         for (i = 0u; i < inst->n_outp; i++) {
700a567a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a567e: 3001         	adds	r0, #0x1
700a5680: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a5684: e7d4         	b	0x700a5630 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x58
;     }
700a5686: e7ff         	b	0x700a5688 <Sciclient_rmIrGetOutp+0xf8> @ imm = #-0x2
;     return r;
700a5688: 9805         	ldr	r0, [sp, #0x14]
700a568a: b008         	add	sp, #0x20
700a568c: bd80         	pop	{r7, pc}
700a568e: 0000         	movs	r0, r0

700a5690 <eTaskGetState>:
; eTaskState eTaskGetState(TaskHandle_t xTask) {
700a5690: b580         	push	{r7, lr}
700a5692: b088         	sub	sp, #0x20
700a5694: 9007         	str	r0, [sp, #0x1c]
;   const TCB_t *const pxTCB = xTask;
700a5696: 9807         	ldr	r0, [sp, #0x1c]
700a5698: 9002         	str	r0, [sp, #0x8]
;   if (pxTCB == pxCurrentTCB) {
700a569a: 9802         	ldr	r0, [sp, #0x8]
700a569c: f642 2100    	movw	r1, #0x2a00
700a56a0: f2c7 010b    	movt	r1, #0x700b
700a56a4: 6809         	ldr	r1, [r1]
700a56a6: 4288         	cmp	r0, r1
700a56a8: d104         	bne	0x700a56b4 <eTaskGetState+0x24> @ imm = #0x8
700a56aa: e7ff         	b	0x700a56ac <eTaskGetState+0x1c> @ imm = #-0x2
700a56ac: 2000         	movs	r0, #0x0
;     eReturn = eRunning;
700a56ae: f88d 001b    	strb.w	r0, [sp, #0x1b]
;   } else {
700a56b2: e063         	b	0x700a577c <eTaskGetState+0xec> @ imm = #0xc6
;     taskENTER_CRITICAL();
700a56b4: f009 f804    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x9008
;       pxStateList = listLIST_ITEM_CONTAINER(&(pxTCB->xStateListItem));
700a56b8: 9802         	ldr	r0, [sp, #0x8]
700a56ba: 6940         	ldr	r0, [r0, #0x14]
700a56bc: 9005         	str	r0, [sp, #0x14]
;       pxDelayedList = pxDelayedTaskList;
700a56be: f245 1028    	movw	r0, #0x5128
700a56c2: f2c7 0008    	movt	r0, #0x7008
700a56c6: 6800         	ldr	r0, [r0]
700a56c8: 9004         	str	r0, [sp, #0x10]
;       pxOverflowedDelayedList = pxOverflowDelayedTaskList;
700a56ca: f245 102c    	movw	r0, #0x512c
700a56ce: f2c7 0008    	movt	r0, #0x7008
700a56d2: 6800         	ldr	r0, [r0]
700a56d4: 9003         	str	r0, [sp, #0xc]
;     taskEXIT_CRITICAL();
700a56d6: f008 f893    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x8126
;     if ((pxStateList == pxDelayedList) ||
700a56da: 9805         	ldr	r0, [sp, #0x14]
700a56dc: 9904         	ldr	r1, [sp, #0x10]
700a56de: 4288         	cmp	r0, r1
700a56e0: d005         	beq	0x700a56ee <eTaskGetState+0x5e> @ imm = #0xa
700a56e2: e7ff         	b	0x700a56e4 <eTaskGetState+0x54> @ imm = #-0x2
;         (pxStateList == pxOverflowedDelayedList)) {
700a56e4: 9805         	ldr	r0, [sp, #0x14]
700a56e6: 9903         	ldr	r1, [sp, #0xc]
;     if ((pxStateList == pxDelayedList) ||
700a56e8: 4288         	cmp	r0, r1
700a56ea: d104         	bne	0x700a56f6 <eTaskGetState+0x66> @ imm = #0x8
700a56ec: e7ff         	b	0x700a56ee <eTaskGetState+0x5e> @ imm = #-0x2
700a56ee: 2002         	movs	r0, #0x2
;       eReturn = eBlocked;
700a56f0: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a56f4: e041         	b	0x700a577a <eTaskGetState+0xea> @ imm = #0x82
;     else if (pxStateList == &xSuspendedTaskList) {
700a56f6: 9805         	ldr	r0, [sp, #0x14]
700a56f8: f245 01f4    	movw	r1, #0x50f4
700a56fc: f2c7 0108    	movt	r1, #0x7008
700a5700: 4288         	cmp	r0, r1
700a5702: d125         	bne	0x700a5750 <eTaskGetState+0xc0> @ imm = #0x4a
700a5704: e7ff         	b	0x700a5706 <eTaskGetState+0x76> @ imm = #-0x2
;       if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL) {
700a5706: 9802         	ldr	r0, [sp, #0x8]
700a5708: 6a80         	ldr	r0, [r0, #0x28]
700a570a: b9e0         	cbnz	r0, 0x700a5746 <eTaskGetState+0xb6> @ imm = #0x38
700a570c: e7ff         	b	0x700a570e <eTaskGetState+0x7e> @ imm = #-0x2
700a570e: 2003         	movs	r0, #0x3
;           eReturn = eSuspended;
700a5710: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a5714: 2000         	movs	r0, #0x0
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a5716: 9001         	str	r0, [sp, #0x4]
700a5718: e7ff         	b	0x700a571a <eTaskGetState+0x8a> @ imm = #-0x2
700a571a: 9801         	ldr	r0, [sp, #0x4]
700a571c: 2800         	cmp	r0, #0x0
700a571e: dc11         	bgt	0x700a5744 <eTaskGetState+0xb4> @ imm = #0x22
700a5720: e7ff         	b	0x700a5722 <eTaskGetState+0x92> @ imm = #-0x2
;             if (pxTCB->ucNotifyState[x] == taskWAITING_NOTIFICATION) {
700a5722: 9802         	ldr	r0, [sp, #0x8]
700a5724: 9901         	ldr	r1, [sp, #0x4]
700a5726: 4408         	add	r0, r1
700a5728: f890 0080    	ldrb.w	r0, [r0, #0x80]
700a572c: 2801         	cmp	r0, #0x1
700a572e: d104         	bne	0x700a573a <eTaskGetState+0xaa> @ imm = #0x8
700a5730: e7ff         	b	0x700a5732 <eTaskGetState+0xa2> @ imm = #-0x2
700a5732: 2002         	movs	r0, #0x2
;               eReturn = eBlocked;
700a5734: f88d 001b    	strb.w	r0, [sp, #0x1b]
;               break;
700a5738: e004         	b	0x700a5744 <eTaskGetState+0xb4> @ imm = #0x8
;           }
700a573a: e7ff         	b	0x700a573c <eTaskGetState+0xac> @ imm = #-0x2
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a573c: 9801         	ldr	r0, [sp, #0x4]
700a573e: 3001         	adds	r0, #0x1
700a5740: 9001         	str	r0, [sp, #0x4]
700a5742: e7ea         	b	0x700a571a <eTaskGetState+0x8a> @ imm = #-0x2c
;       } else {
700a5744: e003         	b	0x700a574e <eTaskGetState+0xbe> @ imm = #0x6
700a5746: 2002         	movs	r0, #0x2
;         eReturn = eBlocked;
700a5748: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a574c: e7ff         	b	0x700a574e <eTaskGetState+0xbe> @ imm = #-0x2
;     }
700a574e: e013         	b	0x700a5778 <eTaskGetState+0xe8> @ imm = #0x26
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a5750: 9805         	ldr	r0, [sp, #0x14]
700a5752: f245 1108    	movw	r1, #0x5108
700a5756: f2c7 0108    	movt	r1, #0x7008
700a575a: 4288         	cmp	r0, r1
700a575c: d003         	beq	0x700a5766 <eTaskGetState+0xd6> @ imm = #0x6
700a575e: e7ff         	b	0x700a5760 <eTaskGetState+0xd0> @ imm = #-0x2
;              (pxStateList == NULL)) {
700a5760: 9805         	ldr	r0, [sp, #0x14]
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a5762: b920         	cbnz	r0, 0x700a576e <eTaskGetState+0xde> @ imm = #0x8
700a5764: e7ff         	b	0x700a5766 <eTaskGetState+0xd6> @ imm = #-0x2
700a5766: 2004         	movs	r0, #0x4
;       eReturn = eDeleted;
700a5768: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a576c: e003         	b	0x700a5776 <eTaskGetState+0xe6> @ imm = #0x6
700a576e: 2001         	movs	r0, #0x1
;       eReturn = eReady;
700a5770: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a5774: e7ff         	b	0x700a5776 <eTaskGetState+0xe6> @ imm = #-0x2
700a5776: e7ff         	b	0x700a5778 <eTaskGetState+0xe8> @ imm = #-0x2
700a5778: e7ff         	b	0x700a577a <eTaskGetState+0xea> @ imm = #-0x2
700a577a: e7ff         	b	0x700a577c <eTaskGetState+0xec> @ imm = #-0x2
;   return eReturn;
700a577c: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a5780: b008         	add	sp, #0x20
700a5782: bd80         	pop	{r7, pc}
		...

700a5790 <PMU_profileEnd>:
; int32_t PMU_profileEnd(const char *name) {
700a5790: b580         	push	{r7, lr}
700a5792: b090         	sub	sp, #0x40
700a5794: 900e         	str	r0, [sp, #0x38]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a5796: f243 0080    	movw	r0, #0x3080
700a579a: f2c7 0008    	movt	r0, #0x7008
700a579e: 6800         	ldr	r0, [r0]
700a57a0: 2840         	cmp	r0, #0x40
700a57a2: d304         	blo	0x700a57ae <PMU_profileEnd+0x1e> @ imm = #0x8
700a57a4: e7ff         	b	0x700a57a6 <PMU_profileEnd+0x16> @ imm = #-0x2
700a57a6: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a57aa: 900f         	str	r0, [sp, #0x3c]
700a57ac: e065         	b	0x700a587a <PMU_profileEnd+0xea> @ imm = #0xca
700a57ae: 2000         	movs	r0, #0x0
;   int32_t status = SystemP_SUCCESS;
700a57b0: 9000         	str	r0, [sp]
700a57b2: 900d         	str	r0, [sp, #0x34]
700a57b4: 201f         	movs	r0, #0x1f
;   uint32_t ccount = CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a57b6: f7fc ec52    	blx	0x700a205c <CSL_armR5PmuReadCntr> @ imm = #-0x375c
700a57ba: 4601         	mov	r1, r0
700a57bc: 9800         	ldr	r0, [sp]
700a57be: 910c         	str	r1, [sp, #0x30]
;   uint32_t count0 = CSL_armR5PmuReadCntr(0);
700a57c0: f7fc ec4c    	blx	0x700a205c <CSL_armR5PmuReadCntr> @ imm = #-0x3768
700a57c4: 900b         	str	r0, [sp, #0x2c]
700a57c6: 2001         	movs	r0, #0x1
;   uint32_t count1 = CSL_armR5PmuReadCntr(1);
700a57c8: f7fc ec48    	blx	0x700a205c <CSL_armR5PmuReadCntr> @ imm = #-0x3770
700a57cc: 900a         	str	r0, [sp, #0x28]
700a57ce: 2002         	movs	r0, #0x2
;   uint32_t count2 = CSL_armR5PmuReadCntr(2);
700a57d0: f7fc ec44    	blx	0x700a205c <CSL_armR5PmuReadCntr> @ imm = #-0x3778
700a57d4: 9009         	str	r0, [sp, #0x24]
;   uint32_t counts[3] = {count0, count1, count2};
700a57d6: 980b         	ldr	r0, [sp, #0x2c]
700a57d8: 9006         	str	r0, [sp, #0x18]
700a57da: 980a         	ldr	r0, [sp, #0x28]
700a57dc: 9007         	str	r0, [sp, #0x1c]
700a57de: 9809         	ldr	r0, [sp, #0x24]
700a57e0: 9008         	str	r0, [sp, #0x20]
;   uint32_t i = gProfileObject.logIndex;
700a57e2: f243 0280    	movw	r2, #0x3080
700a57e6: f2c7 0208    	movt	r2, #0x7008
700a57ea: 6810         	ldr	r0, [r2]
700a57ec: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a57ee: 6890         	ldr	r0, [r2, #0x8]
700a57f0: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a57f2: 6850         	ldr	r0, [r2, #0x4]
700a57f4: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a57f6: 9805         	ldr	r0, [sp, #0x14]
700a57f8: 2134         	movs	r1, #0x34
700a57fa: fb00 2001    	mla	r0, r0, r1, r2
700a57fe: 300c         	adds	r0, #0xc
700a5800: 9001         	str	r0, [sp, #0x4]
;   if (strcmp(name, p->name) != 0) {
700a5802: 980e         	ldr	r0, [sp, #0x38]
700a5804: 9901         	ldr	r1, [sp, #0x4]
700a5806: 6b09         	ldr	r1, [r1, #0x30]
700a5808: f7f6 ec8a    	blx	0x7009c120 <strcmp>     @ imm = #-0x96ec
700a580c: b120         	cbz	r0, 0x700a5818 <PMU_profileEnd+0x88> @ imm = #0x8
700a580e: e7ff         	b	0x700a5810 <PMU_profileEnd+0x80> @ imm = #-0x2
700a5810: f04f 30ff    	mov.w	r0, #0xffffffff
;     status = SystemP_FAILURE;
700a5814: 900d         	str	r0, [sp, #0x34]
;   }
700a5816: e7ff         	b	0x700a5818 <PMU_profileEnd+0x88> @ imm = #-0x2
;   if (status == SystemP_SUCCESS) {
700a5818: 980d         	ldr	r0, [sp, #0x34]
700a581a: bb58         	cbnz	r0, 0x700a5874 <PMU_profileEnd+0xe4> @ imm = #0x56
700a581c: e7ff         	b	0x700a581e <PMU_profileEnd+0x8e> @ imm = #-0x2
;     if (bCCnt == TRUE) {
700a581e: 9802         	ldr	r0, [sp, #0x8]
700a5820: 2801         	cmp	r0, #0x1
700a5822: d106         	bne	0x700a5832 <PMU_profileEnd+0xa2> @ imm = #0xc
700a5824: e7ff         	b	0x700a5826 <PMU_profileEnd+0x96> @ imm = #-0x2
;       p->cycleCount.value = ccount - p->cycleCount.value;
700a5826: 980c         	ldr	r0, [sp, #0x30]
700a5828: 9901         	ldr	r1, [sp, #0x4]
700a582a: 6aca         	ldr	r2, [r1, #0x2c]
700a582c: 1a80         	subs	r0, r0, r2
700a582e: 62c8         	str	r0, [r1, #0x2c]
;     }
700a5830: e7ff         	b	0x700a5832 <PMU_profileEnd+0xa2> @ imm = #-0x2
700a5832: 2000         	movs	r0, #0x0
;     for (j = 0; j < numEvents; j++) {
700a5834: 9004         	str	r0, [sp, #0x10]
700a5836: e7ff         	b	0x700a5838 <PMU_profileEnd+0xa8> @ imm = #-0x2
700a5838: 9804         	ldr	r0, [sp, #0x10]
700a583a: 9903         	ldr	r1, [sp, #0xc]
700a583c: 4288         	cmp	r0, r1
700a583e: d211         	bhs	0x700a5864 <PMU_profileEnd+0xd4> @ imm = #0x22
700a5840: e7ff         	b	0x700a5842 <PMU_profileEnd+0xb2> @ imm = #-0x2
;       p->events[j].value = counts[j] - p->events[j].value;
700a5842: 9a04         	ldr	r2, [sp, #0x10]
700a5844: a806         	add	r0, sp, #0x18
700a5846: f850 0022    	ldr.w	r0, [r0, r2, lsl #2]
700a584a: 9901         	ldr	r1, [sp, #0x4]
700a584c: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a5850: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a5854: 688a         	ldr	r2, [r1, #0x8]
700a5856: 1a80         	subs	r0, r0, r2
700a5858: 6088         	str	r0, [r1, #0x8]
;     }
700a585a: e7ff         	b	0x700a585c <PMU_profileEnd+0xcc> @ imm = #-0x2
;     for (j = 0; j < numEvents; j++) {
700a585c: 9804         	ldr	r0, [sp, #0x10]
700a585e: 3001         	adds	r0, #0x1
700a5860: 9004         	str	r0, [sp, #0x10]
700a5862: e7e9         	b	0x700a5838 <PMU_profileEnd+0xa8> @ imm = #-0x2e
;     gProfileObject.logIndex++;
700a5864: f243 0180    	movw	r1, #0x3080
700a5868: f2c7 0108    	movt	r1, #0x7008
700a586c: 6808         	ldr	r0, [r1]
700a586e: 3001         	adds	r0, #0x1
700a5870: 6008         	str	r0, [r1]
;   }
700a5872: e7ff         	b	0x700a5874 <PMU_profileEnd+0xe4> @ imm = #-0x2
;   return status;
700a5874: 980d         	ldr	r0, [sp, #0x34]
700a5876: 900f         	str	r0, [sp, #0x3c]
700a5878: e7ff         	b	0x700a587a <PMU_profileEnd+0xea> @ imm = #-0x2
; }
700a587a: 980f         	ldr	r0, [sp, #0x3c]
700a587c: b010         	add	sp, #0x40
700a587e: bd80         	pop	{r7, pc}

700a5880 <Udma_eventIsrFxn>:
; {
700a5880: b580         	push	{r7, lr}
700a5882: b088         	sub	sp, #0x20
700a5884: 9007         	str	r0, [sp, #0x1c]
;     Udma_EventHandleInt eventHandle = (Udma_EventHandleInt) args;
700a5886: 9807         	ldr	r0, [sp, #0x1c]
700a5888: 9003         	str	r0, [sp, #0xc]
700a588a: 2001         	movs	r0, #0x1
;     teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_NA;
700a588c: 9004         	str	r0, [sp, #0x10]
700a588e: 2000         	movs	r0, #0x0
;     ringHandle = NULL;
700a5890: 9000         	str	r0, [sp]
;     drvHandle = eventHandle->drvHandle;
700a5892: 9803         	ldr	r0, [sp, #0xc]
700a5894: 6800         	ldr	r0, [r0]
700a5896: 9002         	str	r0, [sp, #0x8]
;     vintrNum = eventHandle->vintrNum;
700a5898: 9803         	ldr	r0, [sp, #0xc]
700a589a: 6cc0         	ldr	r0, [r0, #0x4c]
700a589c: 9005         	str	r0, [sp, #0x14]
;     while(eventHandle != NULL_PTR)
700a589e: e7ff         	b	0x700a58a0 <Udma_eventIsrFxn+0x20> @ imm = #-0x2
700a58a0: 9803         	ldr	r0, [sp, #0xc]
700a58a2: 2800         	cmp	r0, #0x0
700a58a4: d060         	beq	0x700a5968 <Udma_eventIsrFxn+0xe8> @ imm = #0xc0
700a58a6: e7ff         	b	0x700a58a8 <Udma_eventIsrFxn+0x28> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventHandle->eventPrms.eventType)
700a58a8: 9803         	ldr	r0, [sp, #0xc]
700a58aa: 6880         	ldr	r0, [r0, #0x8]
700a58ac: 2805         	cmp	r0, #0x5
700a58ae: d057         	beq	0x700a5960 <Udma_eventIsrFxn+0xe0> @ imm = #0xae
700a58b0: e7ff         	b	0x700a58b2 <Udma_eventIsrFxn+0x32> @ imm = #-0x2
;             vintrBitNum = vintrNum * UDMA_MAX_EVENTS_PER_VINTR;
700a58b2: 9805         	ldr	r0, [sp, #0x14]
700a58b4: 0180         	lsls	r0, r0, #0x6
700a58b6: 9006         	str	r0, [sp, #0x18]
;             vintrBitNum += eventHandle->vintrBitNum;
700a58b8: 9803         	ldr	r0, [sp, #0xc]
700a58ba: 6d01         	ldr	r1, [r0, #0x50]
700a58bc: 9806         	ldr	r0, [sp, #0x18]
700a58be: 4408         	add	r0, r1
700a58c0: 9006         	str	r0, [sp, #0x18]
;             if((bool)true == CSL_intaggrIsIntrPending(&drvHandle->iaRegs, vintrBitNum, (bool)true))
700a58c2: 9802         	ldr	r0, [sp, #0x8]
700a58c4: 309c         	adds	r0, #0x9c
700a58c6: 9906         	ldr	r1, [sp, #0x18]
700a58c8: 2201         	movs	r2, #0x1
700a58ca: f002 fe29    	bl	0x700a8520 <CSL_intaggrIsIntrPending> @ imm = #0x2c52
700a58ce: 2800         	cmp	r0, #0x0
700a58d0: d045         	beq	0x700a595e <Udma_eventIsrFxn+0xde> @ imm = #0x8a
700a58d2: e7ff         	b	0x700a58d4 <Udma_eventIsrFxn+0x54> @ imm = #-0x2
;                 (void) CSL_intaggrClrIntr(&drvHandle->iaRegs, vintrBitNum);
700a58d4: 9802         	ldr	r0, [sp, #0x8]
700a58d6: 309c         	adds	r0, #0x9c
700a58d8: 9906         	ldr	r1, [sp, #0x18]
700a58da: f005 fcb9    	bl	0x700ab250 <CSL_intaggrClrIntr> @ imm = #0x5972
;                 eventPrms = &eventHandle->eventPrms;
700a58de: 9803         	ldr	r0, [sp, #0xc]
700a58e0: 3008         	adds	r0, #0x8
700a58e2: 9001         	str	r0, [sp, #0x4]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a58e4: 9801         	ldr	r0, [sp, #0x4]
700a58e6: 6800         	ldr	r0, [r0]
700a58e8: 2801         	cmp	r0, #0x1
700a58ea: d005         	beq	0x700a58f8 <Udma_eventIsrFxn+0x78> @ imm = #0xa
700a58ec: e7ff         	b	0x700a58ee <Udma_eventIsrFxn+0x6e> @ imm = #-0x2
;                    (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a58ee: 9801         	ldr	r0, [sp, #0x4]
700a58f0: 6800         	ldr	r0, [r0]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a58f2: 2806         	cmp	r0, #0x6
700a58f4: d114         	bne	0x700a5920 <Udma_eventIsrFxn+0xa0> @ imm = #0x28
700a58f6: e7ff         	b	0x700a58f8 <Udma_eventIsrFxn+0x78> @ imm = #-0x2
;                     ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a58f8: 9801         	ldr	r0, [sp, #0x4]
700a58fa: 6880         	ldr	r0, [r0, #0x8]
700a58fc: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a5900: 9000         	str	r0, [sp]
;                     if( CSL_lcdma_ringaccIsTeardownComplete(&ringHandle->drvHandle->lcdmaRaRegs, ringHandle->ringNum) == TRUE )
700a5902: 9900         	ldr	r1, [sp]
700a5904: 6808         	ldr	r0, [r1]
700a5906: 308c         	adds	r0, #0x8c
700a5908: 8889         	ldrh	r1, [r1, #0x4]
700a590a: f008 f8e1    	bl	0x700adad0 <CSL_lcdma_ringaccIsTeardownComplete> @ imm = #0x81c2
700a590e: b118         	cbz	r0, 0x700a5918 <Udma_eventIsrFxn+0x98> @ imm = #0x6
700a5910: e7ff         	b	0x700a5912 <Udma_eventIsrFxn+0x92> @ imm = #-0x2
700a5912: 2002         	movs	r0, #0x2
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE;
700a5914: 9004         	str	r0, [sp, #0x10]
;                     }
700a5916: e002         	b	0x700a591e <Udma_eventIsrFxn+0x9e> @ imm = #0x4
700a5918: 2003         	movs	r0, #0x3
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE;
700a591a: 9004         	str	r0, [sp, #0x10]
700a591c: e7ff         	b	0x700a591e <Udma_eventIsrFxn+0x9e> @ imm = #-0x2
;                 }
700a591e: e7ff         	b	0x700a5920 <Udma_eventIsrFxn+0xa0> @ imm = #-0x2
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a5920: 9803         	ldr	r0, [sp, #0xc]
700a5922: 6880         	ldr	r0, [r0, #0x8]
700a5924: 2801         	cmp	r0, #0x1
700a5926: d104         	bne	0x700a5932 <Udma_eventIsrFxn+0xb2> @ imm = #0x8
700a5928: e7ff         	b	0x700a592a <Udma_eventIsrFxn+0xaa> @ imm = #-0x2
700a592a: 9804         	ldr	r0, [sp, #0x10]
700a592c: 2802         	cmp	r0, #0x2
700a592e: d015         	beq	0x700a595c <Udma_eventIsrFxn+0xdc> @ imm = #0x2a
700a5930: e7ff         	b	0x700a5932 <Udma_eventIsrFxn+0xb2> @ imm = #-0x2
;                  ((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_TEARDOWN_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE))))
700a5932: 9803         	ldr	r0, [sp, #0xc]
700a5934: 6880         	ldr	r0, [r0, #0x8]
700a5936: 2806         	cmp	r0, #0x6
700a5938: d104         	bne	0x700a5944 <Udma_eventIsrFxn+0xc4> @ imm = #0x8
700a593a: e7ff         	b	0x700a593c <Udma_eventIsrFxn+0xbc> @ imm = #-0x2
700a593c: 9804         	ldr	r0, [sp, #0x10]
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a593e: 2803         	cmp	r0, #0x3
700a5940: d00c         	beq	0x700a595c <Udma_eventIsrFxn+0xdc> @ imm = #0x18
700a5942: e7ff         	b	0x700a5944 <Udma_eventIsrFxn+0xc4> @ imm = #-0x2
;                     if((Udma_EventCallback) NULL_PTR != eventPrms->eventCb)
700a5944: 9801         	ldr	r0, [sp, #0x4]
700a5946: 6940         	ldr	r0, [r0, #0x14]
700a5948: b138         	cbz	r0, 0x700a595a <Udma_eventIsrFxn+0xda> @ imm = #0xe
700a594a: e7ff         	b	0x700a594c <Udma_eventIsrFxn+0xcc> @ imm = #-0x2
;                         eventPrms->eventCb(
700a594c: 9a01         	ldr	r2, [sp, #0x4]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a594e: 9803         	ldr	r0, [sp, #0xc]
700a5950: 6811         	ldr	r1, [r2]
;                         eventPrms->eventCb(
700a5952: 6953         	ldr	r3, [r2, #0x14]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a5954: 69d2         	ldr	r2, [r2, #0x1c]
;                         eventPrms->eventCb(
700a5956: 4798         	blx	r3
;                     }
700a5958: e7ff         	b	0x700a595a <Udma_eventIsrFxn+0xda> @ imm = #-0x2
;                 }
700a595a: e7ff         	b	0x700a595c <Udma_eventIsrFxn+0xdc> @ imm = #-0x2
;             }
700a595c: e7ff         	b	0x700a595e <Udma_eventIsrFxn+0xde> @ imm = #-0x2
;         }
700a595e: e7ff         	b	0x700a5960 <Udma_eventIsrFxn+0xe0> @ imm = #-0x2
;         eventHandle = eventHandle->nextEvent;
700a5960: 9803         	ldr	r0, [sp, #0xc]
700a5962: 6dc0         	ldr	r0, [r0, #0x5c]
700a5964: 9003         	str	r0, [sp, #0xc]
;     while(eventHandle != NULL_PTR)
700a5966: e79b         	b	0x700a58a0 <Udma_eventIsrFxn+0x20> @ imm = #-0xca
;     return;
700a5968: b008         	add	sp, #0x20
700a596a: bd80         	pop	{r7, pc}
700a596c: 0000         	movs	r0, r0
700a596e: 0000         	movs	r0, r0

700a5970 <vTaskPriorityDisinheritAfterTimeout>:
;     UBaseType_t uxHighestPriorityWaitingTask) {
700a5970: b580         	push	{r7, lr}
700a5972: b086         	sub	sp, #0x18
700a5974: 9005         	str	r0, [sp, #0x14]
700a5976: 9104         	str	r1, [sp, #0x10]
;   TCB_t *const pxTCB = pxMutexHolder;
700a5978: 9805         	ldr	r0, [sp, #0x14]
700a597a: 9003         	str	r0, [sp, #0xc]
700a597c: 2001         	movs	r0, #0x1
;   const UBaseType_t uxOnlyOneMutexHeld = (UBaseType_t)1;
700a597e: 9000         	str	r0, [sp]
;   if (pxMutexHolder != NULL) {
700a5980: 9805         	ldr	r0, [sp, #0x14]
700a5982: 2800         	cmp	r0, #0x0
700a5984: d067         	beq	0x700a5a56 <vTaskPriorityDisinheritAfterTimeout+0xe6> @ imm = #0xce
700a5986: e7ff         	b	0x700a5988 <vTaskPriorityDisinheritAfterTimeout+0x18> @ imm = #-0x2
;     if (pxTCB->uxBasePriority < uxHighestPriorityWaitingTask) {
700a5988: 9803         	ldr	r0, [sp, #0xc]
700a598a: 6e00         	ldr	r0, [r0, #0x60]
700a598c: 9904         	ldr	r1, [sp, #0x10]
700a598e: 4288         	cmp	r0, r1
700a5990: d203         	bhs	0x700a599a <vTaskPriorityDisinheritAfterTimeout+0x2a> @ imm = #0x6
700a5992: e7ff         	b	0x700a5994 <vTaskPriorityDisinheritAfterTimeout+0x24> @ imm = #-0x2
;       uxPriorityToUse = uxHighestPriorityWaitingTask;
700a5994: 9804         	ldr	r0, [sp, #0x10]
700a5996: 9001         	str	r0, [sp, #0x4]
;     } else {
700a5998: e003         	b	0x700a59a2 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #0x6
;       uxPriorityToUse = pxTCB->uxBasePriority;
700a599a: 9803         	ldr	r0, [sp, #0xc]
700a599c: 6e00         	ldr	r0, [r0, #0x60]
700a599e: 9001         	str	r0, [sp, #0x4]
700a59a0: e7ff         	b	0x700a59a2 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #-0x2
;     if (pxTCB->uxPriority != uxPriorityToUse) {
700a59a2: 9803         	ldr	r0, [sp, #0xc]
700a59a4: 6ac0         	ldr	r0, [r0, #0x2c]
700a59a6: 9901         	ldr	r1, [sp, #0x4]
700a59a8: 4288         	cmp	r0, r1
700a59aa: d052         	beq	0x700a5a52 <vTaskPriorityDisinheritAfterTimeout+0xe2> @ imm = #0xa4
700a59ac: e7ff         	b	0x700a59ae <vTaskPriorityDisinheritAfterTimeout+0x3e> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld) {
700a59ae: 9803         	ldr	r0, [sp, #0xc]
700a59b0: 6e40         	ldr	r0, [r0, #0x64]
700a59b2: 2801         	cmp	r0, #0x1
700a59b4: d14b         	bne	0x700a5a4e <vTaskPriorityDisinheritAfterTimeout+0xde> @ imm = #0x96
700a59b6: e7ff         	b	0x700a59b8 <vTaskPriorityDisinheritAfterTimeout+0x48> @ imm = #-0x2
;         uxPriorityUsedOnEntry = pxTCB->uxPriority;
700a59b8: 9803         	ldr	r0, [sp, #0xc]
700a59ba: 6ac0         	ldr	r0, [r0, #0x2c]
700a59bc: 9002         	str	r0, [sp, #0x8]
;         pxTCB->uxPriority = uxPriorityToUse;
700a59be: 9801         	ldr	r0, [sp, #0x4]
700a59c0: 9903         	ldr	r1, [sp, #0xc]
700a59c2: 62c8         	str	r0, [r1, #0x2c]
;         if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) &
700a59c4: 9803         	ldr	r0, [sp, #0xc]
700a59c6: 7ec0         	ldrb	r0, [r0, #0x1b]
700a59c8: 0600         	lsls	r0, r0, #0x18
700a59ca: 2800         	cmp	r0, #0x0
700a59cc: d406         	bmi	0x700a59dc <vTaskPriorityDisinheritAfterTimeout+0x6c> @ imm = #0xc
700a59ce: e7ff         	b	0x700a59d0 <vTaskPriorityDisinheritAfterTimeout+0x60> @ imm = #-0x2
;           listSET_LIST_ITEM_VALUE(
700a59d0: 9801         	ldr	r0, [sp, #0x4]
700a59d2: f1c0 0020    	rsb.w	r0, r0, #0x20
700a59d6: 9903         	ldr	r1, [sp, #0xc]
700a59d8: 6188         	str	r0, [r1, #0x18]
;         } else {
700a59da: e000         	b	0x700a59de <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #0x0
700a59dc: e7ff         	b	0x700a59de <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #-0x2
;         if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]),
700a59de: 9803         	ldr	r0, [sp, #0xc]
700a59e0: 6940         	ldr	r0, [r0, #0x14]
700a59e2: 9902         	ldr	r1, [sp, #0x8]
700a59e4: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a59e8: f244 41f8    	movw	r1, #0x44f8
700a59ec: f2c7 0108    	movt	r1, #0x7008
700a59f0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a59f4: 4288         	cmp	r0, r1
700a59f6: d128         	bne	0x700a5a4a <vTaskPriorityDisinheritAfterTimeout+0xda> @ imm = #0x50
700a59f8: e7ff         	b	0x700a59fa <vTaskPriorityDisinheritAfterTimeout+0x8a> @ imm = #-0x2
;           if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a59fa: 9803         	ldr	r0, [sp, #0xc]
700a59fc: 3004         	adds	r0, #0x4
700a59fe: f007 fe0f    	bl	0x700ad620 <uxListRemove> @ imm = #0x7c1e
700a5a02: b908         	cbnz	r0, 0x700a5a08 <vTaskPriorityDisinheritAfterTimeout+0x98> @ imm = #0x2
700a5a04: e7ff         	b	0x700a5a06 <vTaskPriorityDisinheritAfterTimeout+0x96> @ imm = #-0x2
;           } else {
700a5a06: e000         	b	0x700a5a0a <vTaskPriorityDisinheritAfterTimeout+0x9a> @ imm = #0x0
700a5a08: e7ff         	b	0x700a5a0a <vTaskPriorityDisinheritAfterTimeout+0x9a> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
700a5a0a: 9803         	ldr	r0, [sp, #0xc]
700a5a0c: 6ac0         	ldr	r0, [r0, #0x2c]
700a5a0e: f642 212c    	movw	r1, #0x2a2c
700a5a12: f2c7 010b    	movt	r1, #0x700b
700a5a16: 6809         	ldr	r1, [r1]
700a5a18: 4288         	cmp	r0, r1
700a5a1a: d908         	bls	0x700a5a2e <vTaskPriorityDisinheritAfterTimeout+0xbe> @ imm = #0x10
700a5a1c: e7ff         	b	0x700a5a1e <vTaskPriorityDisinheritAfterTimeout+0xae> @ imm = #-0x2
700a5a1e: 9803         	ldr	r0, [sp, #0xc]
700a5a20: 6ac0         	ldr	r0, [r0, #0x2c]
700a5a22: f642 212c    	movw	r1, #0x2a2c
700a5a26: f2c7 010b    	movt	r1, #0x700b
700a5a2a: 6008         	str	r0, [r1]
700a5a2c: e7ff         	b	0x700a5a2e <vTaskPriorityDisinheritAfterTimeout+0xbe> @ imm = #-0x2
700a5a2e: 9903         	ldr	r1, [sp, #0xc]
700a5a30: 6ac8         	ldr	r0, [r1, #0x2c]
700a5a32: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a5a36: f244 40f8    	movw	r0, #0x44f8
700a5a3a: f2c7 0008    	movt	r0, #0x7008
700a5a3e: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a5a42: 3104         	adds	r1, #0x4
700a5a44: f008 fba4    	bl	0x700ae190 <vListInsertEnd> @ imm = #0x8748
;         } else {
700a5a48: e000         	b	0x700a5a4c <vTaskPriorityDisinheritAfterTimeout+0xdc> @ imm = #0x0
700a5a4a: e7ff         	b	0x700a5a4c <vTaskPriorityDisinheritAfterTimeout+0xdc> @ imm = #-0x2
;       } else {
700a5a4c: e000         	b	0x700a5a50 <vTaskPriorityDisinheritAfterTimeout+0xe0> @ imm = #0x0
700a5a4e: e7ff         	b	0x700a5a50 <vTaskPriorityDisinheritAfterTimeout+0xe0> @ imm = #-0x2
;     } else {
700a5a50: e000         	b	0x700a5a54 <vTaskPriorityDisinheritAfterTimeout+0xe4> @ imm = #0x0
700a5a52: e7ff         	b	0x700a5a54 <vTaskPriorityDisinheritAfterTimeout+0xe4> @ imm = #-0x2
;   } else {
700a5a54: e000         	b	0x700a5a58 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #0x0
700a5a56: e7ff         	b	0x700a5a58 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #-0x2
; }
700a5a58: b006         	add	sp, #0x18
700a5a5a: bd80         	pop	{r7, pc}
700a5a5c: 0000         	movs	r0, r0
700a5a5e: 0000         	movs	r0, r0

700a5a60 <AddrTranslateP_getLocalAddr>:
; {
700a5a60: b580         	push	{r7, lr}
700a5a62: b08e         	sub	sp, #0x38
700a5a64: 910d         	str	r1, [sp, #0x34]
700a5a66: 900c         	str	r0, [sp, #0x30]
;     DebugP_assertNoLog(gAddrTranslateConfig.numRegions<AddrTranslateP_MAX_REGIONS);
700a5a68: f642 1074    	movw	r0, #0x2974
700a5a6c: f2c7 000b    	movt	r0, #0x700b
700a5a70: 6801         	ldr	r1, [r0]
700a5a72: 2000         	movs	r0, #0x0
700a5a74: 9001         	str	r0, [sp, #0x4]
700a5a76: 2910         	cmp	r1, #0x10
700a5a78: bf38         	it	lo
700a5a7a: 2001         	movlo	r0, #0x1
700a5a7c: f00b fc10    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0xb820
700a5a80: 9801         	ldr	r0, [sp, #0x4]
;     found = 0;
700a5a82: 900b         	str	r0, [sp, #0x2c]
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a5a84: 900a         	str	r0, [sp, #0x28]
700a5a86: e7ff         	b	0x700a5a88 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x2
700a5a88: 980a         	ldr	r0, [sp, #0x28]
700a5a8a: f642 1174    	movw	r1, #0x2974
700a5a8e: f2c7 010b    	movt	r1, #0x700b
700a5a92: 6809         	ldr	r1, [r1]
700a5a94: 4288         	cmp	r0, r1
700a5a96: d23b         	bhs	0x700a5b10 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x76
700a5a98: e7ff         	b	0x700a5a9a <AddrTranslateP_getLocalAddr+0x3a> @ imm = #-0x2
;         sizeMask = ( (uint32_t)( ((uint64_t)1U << gAddrTranslateConfig.regionConfig[regionId].size) - 1U) );
700a5a9a: f642 1074    	movw	r0, #0x2974
700a5a9e: f2c7 000b    	movt	r0, #0x700b
700a5aa2: 6881         	ldr	r1, [r0, #0x8]
700a5aa4: 9a0a         	ldr	r2, [sp, #0x28]
700a5aa6: eb01 1102    	add.w	r1, r1, r2, lsl #4
700a5aaa: 68ca         	ldr	r2, [r1, #0xc]
700a5aac: 2101         	movs	r1, #0x1
700a5aae: 4091         	lsls	r1, r2
700a5ab0: 3a20         	subs	r2, #0x20
700a5ab2: 2a00         	cmp	r2, #0x0
700a5ab4: bf58         	it	pl
700a5ab6: 2100         	movpl	r1, #0x0
700a5ab8: 3901         	subs	r1, #0x1
700a5aba: 9103         	str	r1, [sp, #0xc]
;         startAddr = gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a5abc: 6880         	ldr	r0, [r0, #0x8]
700a5abe: 9a0a         	ldr	r2, [sp, #0x28]
700a5ac0: eb00 1102    	add.w	r1, r0, r2, lsl #4
700a5ac4: ea4f 1202    	lsl.w	r2, r2, #0x4
700a5ac8: 5880         	ldr	r0, [r0, r2]
700a5aca: 6849         	ldr	r1, [r1, #0x4]
700a5acc: 9107         	str	r1, [sp, #0x1c]
700a5ace: 9006         	str	r0, [sp, #0x18]
;         endAddr = startAddr + sizeMask;
700a5ad0: 9906         	ldr	r1, [sp, #0x18]
700a5ad2: 9807         	ldr	r0, [sp, #0x1c]
700a5ad4: 9a03         	ldr	r2, [sp, #0xc]
700a5ad6: 1889         	adds	r1, r1, r2
700a5ad8: f140 0000    	adc	r0, r0, #0x0
700a5adc: 9104         	str	r1, [sp, #0x10]
700a5ade: 9005         	str	r0, [sp, #0x14]
;         if((systemAddr >= startAddr) && (systemAddr <= endAddr))
700a5ae0: 9a0c         	ldr	r2, [sp, #0x30]
700a5ae2: 980d         	ldr	r0, [sp, #0x34]
700a5ae4: 9b06         	ldr	r3, [sp, #0x18]
700a5ae6: 9907         	ldr	r1, [sp, #0x1c]
700a5ae8: 1ad2         	subs	r2, r2, r3
700a5aea: 4188         	sbcs	r0, r1
700a5aec: d30b         	blo	0x700a5b06 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x16
700a5aee: e7ff         	b	0x700a5af0 <AddrTranslateP_getLocalAddr+0x90> @ imm = #-0x2
700a5af0: 9b0c         	ldr	r3, [sp, #0x30]
700a5af2: 990d         	ldr	r1, [sp, #0x34]
700a5af4: 9a04         	ldr	r2, [sp, #0x10]
700a5af6: 9805         	ldr	r0, [sp, #0x14]
700a5af8: 1ad2         	subs	r2, r2, r3
700a5afa: 4188         	sbcs	r0, r1
700a5afc: d303         	blo	0x700a5b06 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x6
700a5afe: e7ff         	b	0x700a5b00 <AddrTranslateP_getLocalAddr+0xa0> @ imm = #-0x2
700a5b00: 2001         	movs	r0, #0x1
;             found = 1;
700a5b02: 900b         	str	r0, [sp, #0x2c]
;             break;
700a5b04: e004         	b	0x700a5b10 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x8
;     }
700a5b06: e7ff         	b	0x700a5b08 <AddrTranslateP_getLocalAddr+0xa8> @ imm = #-0x2
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a5b08: 980a         	ldr	r0, [sp, #0x28]
700a5b0a: 3001         	adds	r0, #0x1
700a5b0c: 900a         	str	r0, [sp, #0x28]
700a5b0e: e7bb         	b	0x700a5a88 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x8a
;     if(found != 0U)
700a5b10: 980b         	ldr	r0, [sp, #0x2c]
700a5b12: b1a0         	cbz	r0, 0x700a5b3e <AddrTranslateP_getLocalAddr+0xde> @ imm = #0x28
700a5b14: e7ff         	b	0x700a5b16 <AddrTranslateP_getLocalAddr+0xb6> @ imm = #-0x2
;         uint32_t offset = systemAddr - gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a5b16: 990c         	ldr	r1, [sp, #0x30]
700a5b18: f642 1074    	movw	r0, #0x2974
700a5b1c: f2c7 000b    	movt	r0, #0x700b
700a5b20: 6882         	ldr	r2, [r0, #0x8]
700a5b22: 9b0a         	ldr	r3, [sp, #0x28]
700a5b24: 011b         	lsls	r3, r3, #0x4
700a5b26: 58d2         	ldr	r2, [r2, r3]
700a5b28: 1a89         	subs	r1, r1, r2
700a5b2a: 9102         	str	r1, [sp, #0x8]
;         localAddr = (void *) (gAddrTranslateConfig.regionConfig[regionId].localAddr + offset);
700a5b2c: 6880         	ldr	r0, [r0, #0x8]
700a5b2e: 990a         	ldr	r1, [sp, #0x28]
700a5b30: eb00 1001    	add.w	r0, r0, r1, lsl #4
700a5b34: 6880         	ldr	r0, [r0, #0x8]
700a5b36: 9902         	ldr	r1, [sp, #0x8]
700a5b38: 4408         	add	r0, r1
700a5b3a: 9009         	str	r0, [sp, #0x24]
;     }
700a5b3c: e002         	b	0x700a5b44 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #0x4
;         localAddr = (void *) systemAddr;
700a5b3e: 980c         	ldr	r0, [sp, #0x30]
700a5b40: 9009         	str	r0, [sp, #0x24]
700a5b42: e7ff         	b	0x700a5b44 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #-0x2
;     return localAddr;
700a5b44: 9809         	ldr	r0, [sp, #0x24]
700a5b46: b00e         	add	sp, #0x38
700a5b48: bd80         	pop	{r7, pc}
700a5b4a: 0000         	movs	r0, r0
700a5b4c: 0000         	movs	r0, r0
700a5b4e: 0000         	movs	r0, r0

700a5b50 <Udma_eventFreeResource>:
; {
700a5b50: b580         	push	{r7, lr}
700a5b52: b084         	sub	sp, #0x10
700a5b54: 9003         	str	r0, [sp, #0xc]
700a5b56: 9102         	str	r1, [sp, #0x8]
;     cookie = HwiP_disable();
700a5b58: f00a eee2    	blx	0x700b0920 <HwiP_disable> @ imm = #0xadc4
700a5b5c: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventHandle->prevEvent)
700a5b5e: 9802         	ldr	r0, [sp, #0x8]
700a5b60: 6e00         	ldr	r0, [r0, #0x60]
700a5b62: b128         	cbz	r0, 0x700a5b70 <Udma_eventFreeResource+0x20> @ imm = #0xa
700a5b64: e7ff         	b	0x700a5b66 <Udma_eventFreeResource+0x16> @ imm = #-0x2
;         eventHandle->prevEvent->nextEvent = eventHandle->nextEvent;
700a5b66: 9902         	ldr	r1, [sp, #0x8]
700a5b68: 6dc8         	ldr	r0, [r1, #0x5c]
700a5b6a: 6e09         	ldr	r1, [r1, #0x60]
700a5b6c: 65c8         	str	r0, [r1, #0x5c]
;     }
700a5b6e: e7ff         	b	0x700a5b70 <Udma_eventFreeResource+0x20> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->nextEvent)
700a5b70: 9802         	ldr	r0, [sp, #0x8]
700a5b72: 6dc0         	ldr	r0, [r0, #0x5c]
700a5b74: b128         	cbz	r0, 0x700a5b82 <Udma_eventFreeResource+0x32> @ imm = #0xa
700a5b76: e7ff         	b	0x700a5b78 <Udma_eventFreeResource+0x28> @ imm = #-0x2
;         eventHandle->nextEvent->prevEvent = eventHandle->prevEvent;
700a5b78: 9802         	ldr	r0, [sp, #0x8]
700a5b7a: 6dc1         	ldr	r1, [r0, #0x5c]
700a5b7c: 6e00         	ldr	r0, [r0, #0x60]
700a5b7e: 6608         	str	r0, [r1, #0x60]
;     }
700a5b80: e7ff         	b	0x700a5b82 <Udma_eventFreeResource+0x32> @ imm = #-0x2
;     HwiP_restore(cookie);
700a5b82: 9801         	ldr	r0, [sp, #0x4]
700a5b84: f00a eeec    	blx	0x700b0960 <HwiP_restore> @ imm = #0xadd8
;     if(NULL_PTR != eventHandle->hwiHandle)
700a5b88: 9802         	ldr	r0, [sp, #0x8]
700a5b8a: 6e40         	ldr	r0, [r0, #0x64]
700a5b8c: b140         	cbz	r0, 0x700a5ba0 <Udma_eventFreeResource+0x50> @ imm = #0x10
700a5b8e: e7ff         	b	0x700a5b90 <Udma_eventFreeResource+0x40> @ imm = #-0x2
;         HwiP_destruct(&eventHandle->hwiObject);
700a5b90: 9802         	ldr	r0, [sp, #0x8]
700a5b92: 3068         	adds	r0, #0x68
700a5b94: f00a fad4    	bl	0x700b0140 <HwiP_destruct> @ imm = #0xa5a8
;         eventHandle->hwiHandle = NULL_PTR;
700a5b98: 9902         	ldr	r1, [sp, #0x8]
700a5b9a: 2000         	movs	r0, #0x0
700a5b9c: 6648         	str	r0, [r1, #0x64]
;     }
700a5b9e: e7ff         	b	0x700a5ba0 <Udma_eventFreeResource+0x50> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
700a5ba0: 9802         	ldr	r0, [sp, #0x8]
700a5ba2: 6d40         	ldr	r0, [r0, #0x54]
700a5ba4: f510 3f80    	cmn.w	r0, #0x10000
700a5ba8: d00d         	beq	0x700a5bc6 <Udma_eventFreeResource+0x76> @ imm = #0x1a
700a5baa: e7ff         	b	0x700a5bac <Udma_eventFreeResource+0x5c> @ imm = #-0x2
;         Udma_rmFreeIrIntr(eventHandle->irIntrNum, drvHandle);
700a5bac: 9802         	ldr	r0, [sp, #0x8]
700a5bae: 6d40         	ldr	r0, [r0, #0x54]
700a5bb0: 9903         	ldr	r1, [sp, #0xc]
700a5bb2: f006 f81d    	bl	0x700abbf0 <Udma_rmFreeIrIntr> @ imm = #0x603a
;         eventHandle->irIntrNum = UDMA_INTR_INVALID;
700a5bb6: 9902         	ldr	r1, [sp, #0x8]
700a5bb8: 2000         	movs	r0, #0x0
700a5bba: f6cf 70ff    	movt	r0, #0xffff
700a5bbe: 6548         	str	r0, [r1, #0x54]
;         eventHandle->coreIntrNum = UDMA_INTR_INVALID;
700a5bc0: 9902         	ldr	r1, [sp, #0x8]
700a5bc2: 6588         	str	r0, [r1, #0x58]
;     }
700a5bc4: e7ff         	b	0x700a5bc6 <Udma_eventFreeResource+0x76> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->globalEvent)
700a5bc6: 9802         	ldr	r0, [sp, #0x8]
700a5bc8: 6c80         	ldr	r0, [r0, #0x48]
700a5bca: f64f 71ff    	movw	r1, #0xffff
700a5bce: 4288         	cmp	r0, r1
700a5bd0: d00e         	beq	0x700a5bf0 <Udma_eventFreeResource+0xa0> @ imm = #0x1c
700a5bd2: e7ff         	b	0x700a5bd4 <Udma_eventFreeResource+0x84> @ imm = #-0x2
;         Udma_eventResetSteering(drvHandle, eventHandle);
700a5bd4: 9803         	ldr	r0, [sp, #0xc]
700a5bd6: 9902         	ldr	r1, [sp, #0x8]
700a5bd8: f009 f8fa    	bl	0x700aedd0 <Udma_eventResetSteering> @ imm = #0x91f4
;         Udma_rmFreeEvent(eventHandle->globalEvent, drvHandle);
700a5bdc: 9802         	ldr	r0, [sp, #0x8]
700a5bde: 6c80         	ldr	r0, [r0, #0x48]
700a5be0: 9903         	ldr	r1, [sp, #0xc]
700a5be2: f005 ffcd    	bl	0x700abb80 <Udma_rmFreeEvent> @ imm = #0x5f9a
;         eventHandle->globalEvent = UDMA_EVENT_INVALID;
700a5be6: 9902         	ldr	r1, [sp, #0x8]
700a5be8: f64f 70ff    	movw	r0, #0xffff
700a5bec: 6488         	str	r0, [r1, #0x48]
;     }
700a5bee: e7ff         	b	0x700a5bf0 <Udma_eventFreeResource+0xa0> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
700a5bf0: 9802         	ldr	r0, [sp, #0x8]
700a5bf2: 6d00         	ldr	r0, [r0, #0x50]
700a5bf4: f64f 71ff    	movw	r1, #0xffff
700a5bf8: 4288         	cmp	r0, r1
700a5bfa: d00a         	beq	0x700a5c12 <Udma_eventFreeResource+0xc2> @ imm = #0x14
700a5bfc: e7ff         	b	0x700a5bfe <Udma_eventFreeResource+0xae> @ imm = #-0x2
;         Udma_rmFreeVintrBit(eventHandle->vintrBitNum, drvHandle, eventHandle);
700a5bfe: 9a02         	ldr	r2, [sp, #0x8]
700a5c00: 6d10         	ldr	r0, [r2, #0x50]
700a5c02: 9903         	ldr	r1, [sp, #0xc]
700a5c04: f004 facc    	bl	0x700aa1a0 <Udma_rmFreeVintrBit> @ imm = #0x4598
;         eventHandle->vintrBitNum = UDMA_EVENT_INVALID;
700a5c08: 9902         	ldr	r1, [sp, #0x8]
700a5c0a: f64f 70ff    	movw	r0, #0xffff
700a5c0e: 6508         	str	r0, [r1, #0x50]
;     }
700a5c10: e7ff         	b	0x700a5c12 <Udma_eventFreeResource+0xc2> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrNum)
700a5c12: 9802         	ldr	r0, [sp, #0x8]
700a5c14: 6cc0         	ldr	r0, [r0, #0x4c]
700a5c16: f64f 71ff    	movw	r1, #0xffff
700a5c1a: 4288         	cmp	r0, r1
700a5c1c: d00a         	beq	0x700a5c34 <Udma_eventFreeResource+0xe4> @ imm = #0x14
700a5c1e: e7ff         	b	0x700a5c20 <Udma_eventFreeResource+0xd0> @ imm = #-0x2
;         Udma_rmFreeVintr(eventHandle->vintrNum, drvHandle);
700a5c20: 9802         	ldr	r0, [sp, #0x8]
700a5c22: 6cc0         	ldr	r0, [r0, #0x4c]
700a5c24: 9903         	ldr	r1, [sp, #0xc]
700a5c26: f006 f81b    	bl	0x700abc60 <Udma_rmFreeVintr> @ imm = #0x6036
;         eventHandle->vintrNum = UDMA_EVENT_INVALID;
700a5c2a: 9902         	ldr	r1, [sp, #0x8]
700a5c2c: f64f 70ff    	movw	r0, #0xffff
700a5c30: 64c8         	str	r0, [r1, #0x4c]
;     }
700a5c32: e7ff         	b	0x700a5c34 <Udma_eventFreeResource+0xe4> @ imm = #-0x2
;     return;
700a5c34: b004         	add	sp, #0x10
700a5c36: bd80         	pop	{r7, pc}
		...

700a5c40 <DebugP_memTraceLogWriterPutLine>:
; {
700a5c40: b580         	push	{r7, lr}
700a5c42: b08a         	sub	sp, #0x28
700a5c44: 9009         	str	r0, [sp, #0x24]
700a5c46: f8ad 1022    	strh.w	r1, [sp, #0x22]
700a5c4a: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a5c4c: 9007         	str	r0, [sp, #0x1c]
;     if (gDebugMemLogSize == 0U)
700a5c4e: f642 10d8    	movw	r0, #0x29d8
700a5c52: f2c7 000b    	movt	r0, #0x700b
700a5c56: 6800         	ldr	r0, [r0]
700a5c58: b920         	cbnz	r0, 0x700a5c64 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #0x8
700a5c5a: e7ff         	b	0x700a5c5c <DebugP_memTraceLogWriterPutLine+0x1c> @ imm = #-0x2
700a5c5c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a5c60: 9007         	str	r0, [sp, #0x1c]
;     }
700a5c62: e7ff         	b	0x700a5c64 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a5c64: 9807         	ldr	r0, [sp, #0x1c]
700a5c66: 2800         	cmp	r0, #0x0
700a5c68: d15a         	bne	0x700a5d20 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #0xb4
700a5c6a: e7ff         	b	0x700a5c6c <DebugP_memTraceLogWriterPutLine+0x2c> @ imm = #-0x2
;         wr_idx = gDebugMemLogWriteIndex;
700a5c6c: f642 10dc    	movw	r0, #0x29dc
700a5c70: f2c7 000b    	movt	r0, #0x700b
700a5c74: 6800         	ldr	r0, [r0]
700a5c76: 9006         	str	r0, [sp, #0x18]
;         dst = (uint8_t*)&gDebugMemLog[0];
700a5c78: f241 0080    	movw	r0, #0x1080
700a5c7c: f2c7 0008    	movt	r0, #0x7008
700a5c80: 9003         	str	r0, [sp, #0xc]
700a5c82: 2000         	movs	r0, #0x0
;         idx = 0;
700a5c84: 9004         	str	r0, [sp, #0x10]
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a5c86: 9005         	str	r0, [sp, #0x14]
700a5c88: e7ff         	b	0x700a5c8a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x2
700a5c8a: 9805         	ldr	r0, [sp, #0x14]
700a5c8c: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5c90: 4288         	cmp	r0, r1
700a5c92: d233         	bhs	0x700a5cfc <DebugP_memTraceLogWriterPutLine+0xbc> @ imm = #0x66
700a5c94: e7ff         	b	0x700a5c96 <DebugP_memTraceLogWriterPutLine+0x56> @ imm = #-0x2
;             dst[wr_idx] = buf[idx];
700a5c96: 9809         	ldr	r0, [sp, #0x24]
700a5c98: 9904         	ldr	r1, [sp, #0x10]
700a5c9a: 5c40         	ldrb	r0, [r0, r1]
700a5c9c: 9903         	ldr	r1, [sp, #0xc]
700a5c9e: 9a06         	ldr	r2, [sp, #0x18]
700a5ca0: 5488         	strb	r0, [r1, r2]
;             wr_idx = wr_idx + 1U;
700a5ca2: 9806         	ldr	r0, [sp, #0x18]
700a5ca4: 3001         	adds	r0, #0x1
700a5ca6: 9006         	str	r0, [sp, #0x18]
;             if (wr_idx >= gDebugMemLogSize)
700a5ca8: 9806         	ldr	r0, [sp, #0x18]
700a5caa: f642 11d8    	movw	r1, #0x29d8
700a5cae: f2c7 010b    	movt	r1, #0x700b
700a5cb2: 6809         	ldr	r1, [r1]
700a5cb4: 4288         	cmp	r0, r1
700a5cb6: d319         	blo	0x700a5cec <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #0x32
700a5cb8: e7ff         	b	0x700a5cba <DebugP_memTraceLogWriterPutLine+0x7a> @ imm = #-0x2
;                         &dst[gDebugMemLogWriteIndex],
700a5cba: 9803         	ldr	r0, [sp, #0xc]
700a5cbc: f642 12dc    	movw	r2, #0x29dc
700a5cc0: f2c7 020b    	movt	r2, #0x700b
700a5cc4: 9202         	str	r2, [sp, #0x8]
700a5cc6: 6811         	ldr	r1, [r2]
700a5cc8: 4408         	add	r0, r1
;                         (wr_idx - gDebugMemLogWriteIndex),
700a5cca: 9906         	ldr	r1, [sp, #0x18]
700a5ccc: 6812         	ldr	r2, [r2]
700a5cce: 1a89         	subs	r1, r1, r2
700a5cd0: 220f         	movs	r2, #0xf
;                 CacheP_wbInv(
700a5cd2: f00a ef1e    	blx	0x700b0b10 <CacheP_wbInv> @ imm = #0xae3c
700a5cd6: 9902         	ldr	r1, [sp, #0x8]
700a5cd8: 2000         	movs	r0, #0x0
;                 wr_idx = 0;
700a5cda: 9006         	str	r0, [sp, #0x18]
;                 gDebugMemLogWriteIndex = 0;
700a5cdc: 6008         	str	r0, [r1]
;                 gDebugMemLogIsWrapAround = 1;
700a5cde: f642 11d4    	movw	r1, #0x29d4
700a5ce2: f2c7 010b    	movt	r1, #0x700b
700a5ce6: 2001         	movs	r0, #0x1
700a5ce8: 6008         	str	r0, [r1]
;             }
700a5cea: e7ff         	b	0x700a5cec <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #-0x2
;             idx ++;
700a5cec: 9804         	ldr	r0, [sp, #0x10]
700a5cee: 3001         	adds	r0, #0x1
700a5cf0: 9004         	str	r0, [sp, #0x10]
;         }
700a5cf2: e7ff         	b	0x700a5cf4 <DebugP_memTraceLogWriterPutLine+0xb4> @ imm = #-0x2
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a5cf4: 9805         	ldr	r0, [sp, #0x14]
700a5cf6: 3001         	adds	r0, #0x1
700a5cf8: 9005         	str	r0, [sp, #0x14]
700a5cfa: e7c6         	b	0x700a5c8a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x74
;                 &dst[gDebugMemLogWriteIndex],
700a5cfc: 9803         	ldr	r0, [sp, #0xc]
700a5cfe: f642 12dc    	movw	r2, #0x29dc
700a5d02: f2c7 020b    	movt	r2, #0x700b
700a5d06: 9201         	str	r2, [sp, #0x4]
700a5d08: 6811         	ldr	r1, [r2]
700a5d0a: 4408         	add	r0, r1
;                 (wr_idx - gDebugMemLogWriteIndex),
700a5d0c: 9906         	ldr	r1, [sp, #0x18]
700a5d0e: 6812         	ldr	r2, [r2]
700a5d10: 1a89         	subs	r1, r1, r2
700a5d12: 220f         	movs	r2, #0xf
;         CacheP_wbInv(
700a5d14: f00a eefc    	blx	0x700b0b10 <CacheP_wbInv> @ imm = #0xadf8
700a5d18: 9901         	ldr	r1, [sp, #0x4]
;         gDebugMemLogWriteIndex = wr_idx;
700a5d1a: 9806         	ldr	r0, [sp, #0x18]
700a5d1c: 6008         	str	r0, [r1]
;     }
700a5d1e: e7ff         	b	0x700a5d20 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #-0x2
; }
700a5d20: b00a         	add	sp, #0x28
700a5d22: bd80         	pop	{r7, pc}
		...

700a5d30 <Sciclient_rmIrqGetNode>:
; {
700a5d30: b089         	sub	sp, #0x24
700a5d32: f8ad 0022    	strh.w	r0, [sp, #0x22]
700a5d36: 9107         	str	r1, [sp, #0x1c]
700a5d38: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700a5d3c: 9006         	str	r0, [sp, #0x18]
700a5d3e: 2000         	movs	r0, #0x0
;     lower = 0u;
700a5d40: 9004         	str	r0, [sp, #0x10]
;     upper = gRmIrqTreeCount - 1u;
700a5d42: f242 613c    	movw	r1, #0x263c
700a5d46: f2c7 010b    	movt	r1, #0x700b
700a5d4a: 680a         	ldr	r2, [r1]
700a5d4c: 3a01         	subs	r2, #0x1
700a5d4e: 9203         	str	r2, [sp, #0xc]
;     count = gRmIrqTreeCount;
700a5d50: 6809         	ldr	r1, [r1]
700a5d52: f8ad 1006    	strh.w	r1, [sp, #0x6]
;     *found_n = NULL;
700a5d56: 9907         	ldr	r1, [sp, #0x1c]
700a5d58: 6008         	str	r0, [r1]
;     while ((lower <= upper) &&
700a5d5a: e7ff         	b	0x700a5d5c <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0x2
700a5d5c: 9904         	ldr	r1, [sp, #0x10]
700a5d5e: 9a03         	ldr	r2, [sp, #0xc]
700a5d60: 2000         	movs	r0, #0x0
700a5d62: 4291         	cmp	r1, r2
700a5d64: 9000         	str	r0, [sp]
700a5d66: d81d         	bhi	0x700a5da4 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x3a
700a5d68: e7ff         	b	0x700a5d6a <Sciclient_rmIrqGetNode+0x3a> @ imm = #-0x2
;            (lower < gRmIrqTreeCount) &&
700a5d6a: 9904         	ldr	r1, [sp, #0x10]
700a5d6c: f242 603c    	movw	r0, #0x263c
700a5d70: f2c7 000b    	movt	r0, #0x700b
700a5d74: 6802         	ldr	r2, [r0]
700a5d76: 2000         	movs	r0, #0x0
700a5d78: 4291         	cmp	r1, r2
700a5d7a: 9000         	str	r0, [sp]
700a5d7c: d212         	bhs	0x700a5da4 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x24
700a5d7e: e7ff         	b	0x700a5d80 <Sciclient_rmIrqGetNode+0x50> @ imm = #-0x2
;            (upper < gRmIrqTreeCount) &&
700a5d80: 9903         	ldr	r1, [sp, #0xc]
700a5d82: f242 603c    	movw	r0, #0x263c
700a5d86: f2c7 000b    	movt	r0, #0x700b
700a5d8a: 6802         	ldr	r2, [r0]
700a5d8c: 2000         	movs	r0, #0x0
700a5d8e: 4291         	cmp	r1, r2
700a5d90: 9000         	str	r0, [sp]
700a5d92: d207         	bhs	0x700a5da4 <Sciclient_rmIrqGetNode+0x74> @ imm = #0xe
700a5d94: e7ff         	b	0x700a5d96 <Sciclient_rmIrqGetNode+0x66> @ imm = #-0x2
;            (count > 0u)) {
700a5d96: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5d9a: 2800         	cmp	r0, #0x0
700a5d9c: bf18         	it	ne
700a5d9e: 2001         	movne	r0, #0x1
700a5da0: 9000         	str	r0, [sp]
700a5da2: e7ff         	b	0x700a5da4 <Sciclient_rmIrqGetNode+0x74> @ imm = #-0x2
700a5da4: 9800         	ldr	r0, [sp]
;     while ((lower <= upper) &&
700a5da6: 07c0         	lsls	r0, r0, #0x1f
700a5da8: b380         	cbz	r0, 0x700a5e0c <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x60
700a5daa: e7ff         	b	0x700a5dac <Sciclient_rmIrqGetNode+0x7c> @ imm = #-0x2
;         current = (lower + upper) / (2u);
700a5dac: 9804         	ldr	r0, [sp, #0x10]
700a5dae: 9903         	ldr	r1, [sp, #0xc]
700a5db0: 4408         	add	r0, r1
700a5db2: 0840         	lsrs	r0, r0, #0x1
700a5db4: 9002         	str	r0, [sp, #0x8]
;         cur_n = (const struct Sciclient_rmIrqNode *) gRmIrqTree[current];
700a5db6: 9902         	ldr	r1, [sp, #0x8]
700a5db8: f641 0088    	movw	r0, #0x1888
700a5dbc: f2c7 000b    	movt	r0, #0x700b
700a5dc0: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a5dc4: 9005         	str	r0, [sp, #0x14]
;         if (cur_n->id == id) {
700a5dc6: 9805         	ldr	r0, [sp, #0x14]
700a5dc8: 8800         	ldrh	r0, [r0]
700a5dca: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5dce: 4288         	cmp	r0, r1
700a5dd0: d106         	bne	0x700a5de0 <Sciclient_rmIrqGetNode+0xb0> @ imm = #0xc
700a5dd2: e7ff         	b	0x700a5dd4 <Sciclient_rmIrqGetNode+0xa4> @ imm = #-0x2
;             *found_n = cur_n;
700a5dd4: 9805         	ldr	r0, [sp, #0x14]
700a5dd6: 9907         	ldr	r1, [sp, #0x1c]
700a5dd8: 6008         	str	r0, [r1]
700a5dda: 2000         	movs	r0, #0x0
;             r = SystemP_SUCCESS;
700a5ddc: 9006         	str	r0, [sp, #0x18]
;             break;
700a5dde: e015         	b	0x700a5e0c <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x2a
;             if (cur_n->id < id) {
700a5de0: 9805         	ldr	r0, [sp, #0x14]
700a5de2: 8800         	ldrh	r0, [r0]
700a5de4: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5de8: 4288         	cmp	r0, r1
700a5dea: da04         	bge	0x700a5df6 <Sciclient_rmIrqGetNode+0xc6> @ imm = #0x8
700a5dec: e7ff         	b	0x700a5dee <Sciclient_rmIrqGetNode+0xbe> @ imm = #-0x2
;                 lower = current + (1u);
700a5dee: 9802         	ldr	r0, [sp, #0x8]
700a5df0: 3001         	adds	r0, #0x1
700a5df2: 9004         	str	r0, [sp, #0x10]
;             } else {
700a5df4: e003         	b	0x700a5dfe <Sciclient_rmIrqGetNode+0xce> @ imm = #0x6
;                 upper = current - (1u);
700a5df6: 9802         	ldr	r0, [sp, #0x8]
700a5df8: 3801         	subs	r0, #0x1
700a5dfa: 9003         	str	r0, [sp, #0xc]
700a5dfc: e7ff         	b	0x700a5dfe <Sciclient_rmIrqGetNode+0xce> @ imm = #-0x2
700a5dfe: e7ff         	b	0x700a5e00 <Sciclient_rmIrqGetNode+0xd0> @ imm = #-0x2
;         count--;
700a5e00: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5e04: 3801         	subs	r0, #0x1
700a5e06: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     while ((lower <= upper) &&
700a5e0a: e7a7         	b	0x700a5d5c <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0xb2
;     return r;
700a5e0c: 9806         	ldr	r0, [sp, #0x18]
700a5e0e: b009         	add	sp, #0x24
700a5e10: 4770         	bx	lr
		...
700a5e1e: 0000         	movs	r0, r0

700a5e20 <vTaskGetInfo>:
;                   BaseType_t xGetFreeStackSpace, eTaskState eState) {
700a5e20: b580         	push	{r7, lr}
700a5e22: b086         	sub	sp, #0x18
700a5e24: 9005         	str	r0, [sp, #0x14]
700a5e26: 9104         	str	r1, [sp, #0x10]
700a5e28: 9203         	str	r2, [sp, #0xc]
700a5e2a: f88d 300b    	strb.w	r3, [sp, #0xb]
;   pxTCB = prvGetTCBFromHandle(xTask);
700a5e2e: 9805         	ldr	r0, [sp, #0x14]
700a5e30: b938         	cbnz	r0, 0x700a5e42 <vTaskGetInfo+0x22> @ imm = #0xe
700a5e32: e7ff         	b	0x700a5e34 <vTaskGetInfo+0x14> @ imm = #-0x2
700a5e34: f642 2000    	movw	r0, #0x2a00
700a5e38: f2c7 000b    	movt	r0, #0x700b
700a5e3c: 6800         	ldr	r0, [r0]
700a5e3e: 9000         	str	r0, [sp]
700a5e40: e002         	b	0x700a5e48 <vTaskGetInfo+0x28> @ imm = #0x4
700a5e42: 9805         	ldr	r0, [sp, #0x14]
700a5e44: 9000         	str	r0, [sp]
700a5e46: e7ff         	b	0x700a5e48 <vTaskGetInfo+0x28> @ imm = #-0x2
700a5e48: 9800         	ldr	r0, [sp]
700a5e4a: 9001         	str	r0, [sp, #0x4]
;   pxTaskStatus->xHandle = (TaskHandle_t)pxTCB;
700a5e4c: 9801         	ldr	r0, [sp, #0x4]
700a5e4e: 9904         	ldr	r1, [sp, #0x10]
700a5e50: 6008         	str	r0, [r1]
;   pxTaskStatus->pcTaskName = (const char *)&(pxTCB->pcTaskName[0]);
700a5e52: 9801         	ldr	r0, [sp, #0x4]
700a5e54: 3034         	adds	r0, #0x34
700a5e56: 9904         	ldr	r1, [sp, #0x10]
700a5e58: 6048         	str	r0, [r1, #0x4]
;   pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
700a5e5a: 9801         	ldr	r0, [sp, #0x4]
700a5e5c: 6ac0         	ldr	r0, [r0, #0x2c]
700a5e5e: 9904         	ldr	r1, [sp, #0x10]
700a5e60: 6108         	str	r0, [r1, #0x10]
;   pxTaskStatus->pxStackBase = pxTCB->pxStack;
700a5e62: 9801         	ldr	r0, [sp, #0x4]
700a5e64: 6b00         	ldr	r0, [r0, #0x30]
700a5e66: 9904         	ldr	r1, [sp, #0x10]
700a5e68: 61c8         	str	r0, [r1, #0x1c]
;   pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
700a5e6a: 9801         	ldr	r0, [sp, #0x4]
700a5e6c: 6d80         	ldr	r0, [r0, #0x58]
700a5e6e: 9904         	ldr	r1, [sp, #0x10]
700a5e70: 6088         	str	r0, [r1, #0x8]
;     pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
700a5e72: 9801         	ldr	r0, [sp, #0x4]
700a5e74: 6e00         	ldr	r0, [r0, #0x60]
700a5e76: 9904         	ldr	r1, [sp, #0x10]
700a5e78: 6148         	str	r0, [r1, #0x14]
;     pxTaskStatus->ulRunTimeCounter = 0;
700a5e7a: 9904         	ldr	r1, [sp, #0x10]
700a5e7c: 2000         	movs	r0, #0x0
700a5e7e: 6188         	str	r0, [r1, #0x18]
;   if (eState != eInvalid) {
700a5e80: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a5e84: 2805         	cmp	r0, #0x5
700a5e86: d025         	beq	0x700a5ed4 <vTaskGetInfo+0xb4> @ imm = #0x4a
700a5e88: e7ff         	b	0x700a5e8a <vTaskGetInfo+0x6a> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a5e8a: 9801         	ldr	r0, [sp, #0x4]
700a5e8c: f642 2100    	movw	r1, #0x2a00
700a5e90: f2c7 010b    	movt	r1, #0x700b
700a5e94: 6809         	ldr	r1, [r1]
700a5e96: 4288         	cmp	r0, r1
700a5e98: d104         	bne	0x700a5ea4 <vTaskGetInfo+0x84> @ imm = #0x8
700a5e9a: e7ff         	b	0x700a5e9c <vTaskGetInfo+0x7c> @ imm = #-0x2
;       pxTaskStatus->eCurrentState = eRunning;
700a5e9c: 9904         	ldr	r1, [sp, #0x10]
700a5e9e: 2000         	movs	r0, #0x0
700a5ea0: 7308         	strb	r0, [r1, #0xc]
;     } else {
700a5ea2: e016         	b	0x700a5ed2 <vTaskGetInfo+0xb2> @ imm = #0x2c
;       pxTaskStatus->eCurrentState = eState;
700a5ea4: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a5ea8: 9904         	ldr	r1, [sp, #0x10]
700a5eaa: 7308         	strb	r0, [r1, #0xc]
;         if (eState == eSuspended) {
700a5eac: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a5eb0: 2803         	cmp	r0, #0x3
700a5eb2: d10d         	bne	0x700a5ed0 <vTaskGetInfo+0xb0> @ imm = #0x1a
700a5eb4: e7ff         	b	0x700a5eb6 <vTaskGetInfo+0x96> @ imm = #-0x2
;           vTaskSuspendAll();
700a5eb6: f009 fe63    	bl	0x700afb80 <vTaskSuspendAll> @ imm = #0x9cc6
;             if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a5eba: 9801         	ldr	r0, [sp, #0x4]
700a5ebc: 6a80         	ldr	r0, [r0, #0x28]
700a5ebe: b120         	cbz	r0, 0x700a5eca <vTaskGetInfo+0xaa> @ imm = #0x8
700a5ec0: e7ff         	b	0x700a5ec2 <vTaskGetInfo+0xa2> @ imm = #-0x2
;               pxTaskStatus->eCurrentState = eBlocked;
700a5ec2: 9904         	ldr	r1, [sp, #0x10]
700a5ec4: 2002         	movs	r0, #0x2
700a5ec6: 7308         	strb	r0, [r1, #0xc]
;             }
700a5ec8: e7ff         	b	0x700a5eca <vTaskGetInfo+0xaa> @ imm = #-0x2
;           (void)xTaskResumeAll();
700a5eca: f7fc f909    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0x3dee
;         }
700a5ece: e7ff         	b	0x700a5ed0 <vTaskGetInfo+0xb0> @ imm = #-0x2
700a5ed0: e7ff         	b	0x700a5ed2 <vTaskGetInfo+0xb2> @ imm = #-0x2
;   } else {
700a5ed2: e005         	b	0x700a5ee0 <vTaskGetInfo+0xc0> @ imm = #0xa
;     pxTaskStatus->eCurrentState = eTaskGetState(pxTCB);
700a5ed4: 9801         	ldr	r0, [sp, #0x4]
700a5ed6: f7ff fbdb    	bl	0x700a5690 <eTaskGetState> @ imm = #-0x84a
700a5eda: 9904         	ldr	r1, [sp, #0x10]
700a5edc: 7308         	strb	r0, [r1, #0xc]
700a5ede: e7ff         	b	0x700a5ee0 <vTaskGetInfo+0xc0> @ imm = #-0x2
;   if (xGetFreeStackSpace != pdFALSE) {
700a5ee0: 9803         	ldr	r0, [sp, #0xc]
700a5ee2: b138         	cbz	r0, 0x700a5ef4 <vTaskGetInfo+0xd4> @ imm = #0xe
700a5ee4: e7ff         	b	0x700a5ee6 <vTaskGetInfo+0xc6> @ imm = #-0x2
;           prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
700a5ee6: 9801         	ldr	r0, [sp, #0x4]
700a5ee8: 6b00         	ldr	r0, [r0, #0x30]
700a5eea: f008 fd49    	bl	0x700ae980 <prvTaskCheckFreeStackSpace> @ imm = #0x8a92
;       pxTaskStatus->usStackHighWaterMark =
700a5eee: 9904         	ldr	r1, [sp, #0x10]
700a5ef0: 6208         	str	r0, [r1, #0x20]
;   } else {
700a5ef2: e003         	b	0x700a5efc <vTaskGetInfo+0xdc> @ imm = #0x6
;     pxTaskStatus->usStackHighWaterMark = 0;
700a5ef4: 9904         	ldr	r1, [sp, #0x10]
700a5ef6: 2000         	movs	r0, #0x0
700a5ef8: 6208         	str	r0, [r1, #0x20]
700a5efa: e7ff         	b	0x700a5efc <vTaskGetInfo+0xdc> @ imm = #-0x2
; }
700a5efc: b006         	add	sp, #0x18
700a5efe: bd80         	pop	{r7, pc}

700a5f00 <Sciclient_waitForMessage>:
; {
700a5f00: b580         	push	{r7, lr}
700a5f02: b088         	sub	sp, #0x20
700a5f04: 9007         	str	r0, [sp, #0x1c]
700a5f06: 9106         	str	r1, [sp, #0x18]
700a5f08: 9205         	str	r2, [sp, #0x14]
700a5f0a: f88d 3013    	strb.w	r3, [sp, #0x13]
;     uint32_t timeToWait = timeout;
700a5f0e: 9806         	ldr	r0, [sp, #0x18]
700a5f10: 9002         	str	r0, [sp, #0x8]
700a5f12: 2200         	movs	r2, #0x0
;     int32_t status = SystemP_SUCCESS;
700a5f14: 9201         	str	r2, [sp, #0x4]
;                                         &gSciclientSecProxyCfg, rxThread, 0U)
700a5f16: 9907         	ldr	r1, [sp, #0x1c]
;         (struct tisci_header *)(CSL_secProxyGetDataAddr(
700a5f18: f642 00c0    	movw	r0, #0x28c0
700a5f1c: f2c7 000b    	movt	r0, #0x700b
700a5f20: f009 faee    	bl	0x700af500 <CSL_secProxyGetDataAddr> @ imm = #0x95dc
;                                 + ((uintptr_t) gSecHeaderSizeWords * (uintptr_t) 4U));
700a5f24: f642 2154    	movw	r1, #0x2a54
700a5f28: f2c7 010b    	movt	r1, #0x700b
700a5f2c: 7809         	ldrb	r1, [r1]
700a5f2e: eb00 0081    	add.w	r0, r0, r1, lsl #2
;     pLocalRespHdr =
700a5f32: 9003         	str	r0, [sp, #0xc]
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a5f34: e7ff         	b	0x700a5f36 <Sciclient_waitForMessage+0x36> @ imm = #-0x2
700a5f36: 9807         	ldr	r0, [sp, #0x1c]
700a5f38: f009 fb92    	bl	0x700af660 <Sciclient_secProxyThreadStatusReg> @ imm = #0x9724
700a5f3c: f009 fe58    	bl	0x700afbf0 <CSL_REG32_RD_RAW> @ imm = #0x9cb0
700a5f40: b2c0         	uxtb	r0, r0
;             CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount) <= 0U)
700a5f42: 9905         	ldr	r1, [sp, #0x14]
700a5f44: 1a40         	subs	r0, r0, r1
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a5f46: b960         	cbnz	r0, 0x700a5f62 <Sciclient_waitForMessage+0x62> @ imm = #0x18
700a5f48: e7ff         	b	0x700a5f4a <Sciclient_waitForMessage+0x4a> @ imm = #-0x2
;         if (timeToWait != 0U)
700a5f4a: 9802         	ldr	r0, [sp, #0x8]
700a5f4c: b120         	cbz	r0, 0x700a5f58 <Sciclient_waitForMessage+0x58> @ imm = #0x8
700a5f4e: e7ff         	b	0x700a5f50 <Sciclient_waitForMessage+0x50> @ imm = #-0x2
;             timeToWait--;
700a5f50: 9802         	ldr	r0, [sp, #0x8]
700a5f52: 3801         	subs	r0, #0x1
700a5f54: 9002         	str	r0, [sp, #0x8]
;         }
700a5f56: e003         	b	0x700a5f60 <Sciclient_waitForMessage+0x60> @ imm = #0x6
700a5f58: f06f 0001    	mvn	r0, #0x1
;             status = SystemP_TIMEOUT;
700a5f5c: 9001         	str	r0, [sp, #0x4]
;             break;
700a5f5e: e000         	b	0x700a5f62 <Sciclient_waitForMessage+0x62> @ imm = #0x0
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a5f60: e7e9         	b	0x700a5f36 <Sciclient_waitForMessage+0x36> @ imm = #-0x2e
;     if (status == SystemP_SUCCESS)
700a5f62: 9801         	ldr	r0, [sp, #0x4]
700a5f64: bbc0         	cbnz	r0, 0x700a5fd8 <Sciclient_waitForMessage+0xd8> @ imm = #0x70
700a5f66: e7ff         	b	0x700a5f68 <Sciclient_waitForMessage+0x68> @ imm = #-0x2
700a5f68: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700a5f6c: 9001         	str	r0, [sp, #0x4]
;         timeToWait =  timeout;
700a5f6e: 9806         	ldr	r0, [sp, #0x18]
700a5f70: 9002         	str	r0, [sp, #0x8]
;         while(1)
700a5f72: e7ff         	b	0x700a5f74 <Sciclient_waitForMessage+0x74> @ imm = #-0x2
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a5f74: 9807         	ldr	r0, [sp, #0x1c]
700a5f76: f009 fb73    	bl	0x700af660 <Sciclient_secProxyThreadStatusReg> @ imm = #0x96e6
700a5f7a: f009 fe39    	bl	0x700afbf0 <CSL_REG32_RD_RAW> @ imm = #0x9c72
700a5f7e: b2c0         	uxtb	r0, r0
;                     CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount;
700a5f80: 9905         	ldr	r1, [sp, #0x14]
700a5f82: 1a40         	subs	r0, r0, r1
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a5f84: 9000         	str	r0, [sp]
;             if (pLocalRespHdr->seq == (uint32_t)localSeqId)
700a5f86: 9803         	ldr	r0, [sp, #0xc]
700a5f88: 78c0         	ldrb	r0, [r0, #0x3]
700a5f8a: f89d 1013    	ldrb.w	r1, [sp, #0x13]
700a5f8e: 4288         	cmp	r0, r1
700a5f90: d103         	bne	0x700a5f9a <Sciclient_waitForMessage+0x9a> @ imm = #0x6
700a5f92: e7ff         	b	0x700a5f94 <Sciclient_waitForMessage+0x94> @ imm = #-0x2
700a5f94: 2000         	movs	r0, #0x0
;                 status = SystemP_SUCCESS;
700a5f96: 9001         	str	r0, [sp, #0x4]
;                 break;
700a5f98: e01d         	b	0x700a5fd6 <Sciclient_waitForMessage+0xd6> @ imm = #0x3a
;             if (numCurrentMsgs > 1U)
700a5f9a: 9800         	ldr	r0, [sp]
700a5f9c: 2802         	cmp	r0, #0x2
700a5f9e: d30e         	blo	0x700a5fbe <Sciclient_waitForMessage+0xbe> @ imm = #0x1c
700a5fa0: e7ff         	b	0x700a5fa2 <Sciclient_waitForMessage+0xa2> @ imm = #-0x2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a5fa2: 9807         	ldr	r0, [sp, #0x1c]
;                                             (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a5fa4: f642 1148    	movw	r1, #0x2948
700a5fa8: f2c7 010b    	movt	r1, #0x700b
700a5fac: 694a         	ldr	r2, [r1, #0x14]
700a5fae: f04f 31ff    	mov.w	r1, #0xffffffff
700a5fb2: eb01 0192    	add.w	r1, r1, r2, lsr #2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a5fb6: b2c9         	uxtb	r1, r1
700a5fb8: f008 fc82    	bl	0x700ae8c0 <Sciclient_secProxyReadThread32> @ imm = #0x8904
;             }
700a5fbc: e7ff         	b	0x700a5fbe <Sciclient_waitForMessage+0xbe> @ imm = #-0x2
;             if (timeToWait != 0U)
700a5fbe: 9802         	ldr	r0, [sp, #0x8]
700a5fc0: b120         	cbz	r0, 0x700a5fcc <Sciclient_waitForMessage+0xcc> @ imm = #0x8
700a5fc2: e7ff         	b	0x700a5fc4 <Sciclient_waitForMessage+0xc4> @ imm = #-0x2
;                 timeToWait--;
700a5fc4: 9802         	ldr	r0, [sp, #0x8]
700a5fc6: 3801         	subs	r0, #0x1
700a5fc8: 9002         	str	r0, [sp, #0x8]
;             }
700a5fca: e003         	b	0x700a5fd4 <Sciclient_waitForMessage+0xd4> @ imm = #0x6
700a5fcc: f06f 0001    	mvn	r0, #0x1
;                 status = SystemP_TIMEOUT;
700a5fd0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a5fd2: e000         	b	0x700a5fd6 <Sciclient_waitForMessage+0xd6> @ imm = #0x0
;         while(1)
700a5fd4: e7ce         	b	0x700a5f74 <Sciclient_waitForMessage+0x74> @ imm = #-0x64
;     }
700a5fd6: e7ff         	b	0x700a5fd8 <Sciclient_waitForMessage+0xd8> @ imm = #-0x2
;     return status;
700a5fd8: 9801         	ldr	r0, [sp, #0x4]
700a5fda: b008         	add	sp, #0x20
700a5fdc: bd80         	pop	{r7, pc}
700a5fde: 0000         	movs	r0, r0

700a5fe0 <UART_intrEnable>:
; {
700a5fe0: b580         	push	{r7, lr}
700a5fe2: b08a         	sub	sp, #0x28
700a5fe4: 9009         	str	r0, [sp, #0x24]
700a5fe6: 9108         	str	r1, [sp, #0x20]
700a5fe8: 2000         	movs	r0, #0x0
;     uint32_t enhanFnBitVal = 0U;
700a5fea: 9007         	str	r0, [sp, #0x1c]
;     uint32_t lcrRegValue   = 0U;
700a5fec: 9006         	str	r0, [sp, #0x18]
;     if ((intrFlag & 0xF0U) > 0U)
700a5fee: f89d 0020    	ldrb.w	r0, [sp, #0x20]
700a5ff2: f010 0ff0    	tst.w	r0, #0xf0
700a5ff6: d053         	beq	0x700a60a0 <UART_intrEnable+0xc0> @ imm = #0xa6
700a5ff8: e7ff         	b	0x700a5ffa <UART_intrEnable+0x1a> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a5ffa: 9809         	ldr	r0, [sp, #0x24]
700a5ffc: 300c         	adds	r0, #0xc
700a5ffe: f009 fd97    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x9b2e
700a6002: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a6004: 9809         	ldr	r0, [sp, #0x24]
700a6006: 300c         	adds	r0, #0xc
700a6008: 21bf         	movs	r1, #0xbf
700a600a: 9103         	str	r1, [sp, #0xc]
700a600c: f009 fd98    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x9b30
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a6010: 9809         	ldr	r0, [sp, #0x24]
700a6012: 3008         	adds	r0, #0x8
700a6014: 2110         	movs	r1, #0x10
700a6016: 9104         	str	r1, [sp, #0x10]
700a6018: 2204         	movs	r2, #0x4
700a601a: 9205         	str	r2, [sp, #0x14]
700a601c: f009 f950    	bl	0x700af2c0 <HW_RD_FIELD32_RAW> @ imm = #0x92a0
700a6020: 9904         	ldr	r1, [sp, #0x10]
700a6022: 9a05         	ldr	r2, [sp, #0x14]
700a6024: 9007         	str	r0, [sp, #0x1c]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a6026: 9809         	ldr	r0, [sp, #0x24]
700a6028: 3008         	adds	r0, #0x8
700a602a: 2301         	movs	r3, #0x1
700a602c: f008 fae8    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x85d0
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a6030: 9809         	ldr	r0, [sp, #0x24]
700a6032: 300c         	adds	r0, #0xc
700a6034: 9906         	ldr	r1, [sp, #0x18]
700a6036: f009 fd83    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x9b06
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a603a: 9809         	ldr	r0, [sp, #0x24]
700a603c: 300c         	adds	r0, #0xc
700a603e: f009 fd77    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x9aee
700a6042: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a6044: 9809         	ldr	r0, [sp, #0x24]
700a6046: 300c         	adds	r0, #0xc
700a6048: 9002         	str	r0, [sp, #0x8]
700a604a: f009 fd71    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x9ae2
700a604e: 4601         	mov	r1, r0
700a6050: 9802         	ldr	r0, [sp, #0x8]
700a6052: f001 017f    	and	r1, r1, #0x7f
700a6056: f009 fd73    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x9ae6
;         HW_WR_REG32(baseAddr + UART_IER, intrFlag & 0xF0U);
700a605a: 9809         	ldr	r0, [sp, #0x24]
700a605c: 3004         	adds	r0, #0x4
700a605e: 9908         	ldr	r1, [sp, #0x20]
700a6060: f001 01f0    	and	r1, r1, #0xf0
700a6064: f009 fd6c    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x9ad8
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a6068: 9809         	ldr	r0, [sp, #0x24]
700a606a: 300c         	adds	r0, #0xc
700a606c: 9906         	ldr	r1, [sp, #0x18]
700a606e: f009 fd67    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x9ace
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a6072: 9809         	ldr	r0, [sp, #0x24]
700a6074: 300c         	adds	r0, #0xc
700a6076: f009 fd5b    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x9ab6
700a607a: 9903         	ldr	r1, [sp, #0xc]
700a607c: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a607e: 9809         	ldr	r0, [sp, #0x24]
700a6080: 300c         	adds	r0, #0xc
700a6082: f009 fd5d    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x9aba
700a6086: 9904         	ldr	r1, [sp, #0x10]
700a6088: 9a05         	ldr	r2, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a608a: 9809         	ldr	r0, [sp, #0x24]
700a608c: 3008         	adds	r0, #0x8
700a608e: 9b07         	ldr	r3, [sp, #0x1c]
700a6090: f008 fab6    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x856c
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a6094: 9809         	ldr	r0, [sp, #0x24]
700a6096: 300c         	adds	r0, #0xc
700a6098: 9906         	ldr	r1, [sp, #0x18]
700a609a: f009 fd51    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x9aa2
;     }
700a609e: e7ff         	b	0x700a60a0 <UART_intrEnable+0xc0> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) |
700a60a0: 9809         	ldr	r0, [sp, #0x24]
700a60a2: 3004         	adds	r0, #0x4
700a60a4: 9001         	str	r0, [sp, #0x4]
700a60a6: f009 fd43    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x9a86
700a60aa: 4601         	mov	r1, r0
700a60ac: 9801         	ldr	r0, [sp, #0x4]
700a60ae: 9a08         	ldr	r2, [sp, #0x20]
700a60b0: f002 020f    	and	r2, r2, #0xf
700a60b4: 4311         	orrs	r1, r2
700a60b6: f009 fd43    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x9a86
; }
700a60ba: b00a         	add	sp, #0x28
700a60bc: bd80         	pop	{r7, pc}
700a60be: 0000         	movs	r0, r0

700a60c0 <Sciclient_rmIrInpIsFree>:
; {
700a60c0: b580         	push	{r7, lr}
700a60c2: b086         	sub	sp, #0x18
700a60c4: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a60c8: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a60cc: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a60ce: 9004         	str	r0, [sp, #0x10]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a60d0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a60d2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a60d6: f005 fcab    	bl	0x700aba30 <Sciclient_rmIrGetInst> @ imm = #0x5956
700a60da: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a60dc: 9803         	ldr	r0, [sp, #0xc]
700a60de: b920         	cbnz	r0, 0x700a60ea <Sciclient_rmIrInpIsFree+0x2a> @ imm = #0x8
700a60e0: e7ff         	b	0x700a60e2 <Sciclient_rmIrInpIsFree+0x22> @ imm = #-0x2
700a60e2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a60e6: 9004         	str	r0, [sp, #0x10]
;     } else {
700a60e8: e00b         	b	0x700a6102 <Sciclient_rmIrInpIsFree+0x42> @ imm = #0x16
;         if (inp >= inst->n_inp) {
700a60ea: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a60ee: 9903         	ldr	r1, [sp, #0xc]
700a60f0: 8909         	ldrh	r1, [r1, #0x8]
700a60f2: 4288         	cmp	r0, r1
700a60f4: db04         	blt	0x700a6100 <Sciclient_rmIrInpIsFree+0x40> @ imm = #0x8
700a60f6: e7ff         	b	0x700a60f8 <Sciclient_rmIrInpIsFree+0x38> @ imm = #-0x2
700a60f8: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a60fc: 9004         	str	r0, [sp, #0x10]
;         }
700a60fe: e7ff         	b	0x700a6100 <Sciclient_rmIrInpIsFree+0x40> @ imm = #-0x2
700a6100: e7ff         	b	0x700a6102 <Sciclient_rmIrInpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a6102: 9804         	ldr	r0, [sp, #0x10]
700a6104: 2800         	cmp	r0, #0x0
700a6106: d145         	bne	0x700a6194 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #0x8a
700a6108: e7ff         	b	0x700a610a <Sciclient_rmIrInpIsFree+0x4a> @ imm = #-0x2
;         if (inp == 0u) {
700a610a: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a610e: b960         	cbnz	r0, 0x700a612a <Sciclient_rmIrInpIsFree+0x6a> @ imm = #0x18
700a6110: e7ff         	b	0x700a6112 <Sciclient_rmIrInpIsFree+0x52> @ imm = #-0x2
;             if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a6112: 9803         	ldr	r0, [sp, #0xc]
700a6114: 8980         	ldrh	r0, [r0, #0xc]
700a6116: f64f 71ff    	movw	r1, #0xffff
700a611a: 4288         	cmp	r0, r1
700a611c: d004         	beq	0x700a6128 <Sciclient_rmIrInpIsFree+0x68> @ imm = #0x8
700a611e: e7ff         	b	0x700a6120 <Sciclient_rmIrInpIsFree+0x60> @ imm = #-0x2
700a6120: f04f 30ff    	mov.w	r0, #0xffffffff
;                 r = SystemP_FAILURE;
700a6124: 9004         	str	r0, [sp, #0x10]
;             }
700a6126: e7ff         	b	0x700a6128 <Sciclient_rmIrInpIsFree+0x68> @ imm = #-0x2
;         } else {
700a6128: e033         	b	0x700a6192 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #0x66
700a612a: 2000         	movs	r0, #0x0
;             for (i = 0u; i < inst->n_outp; i++) {
700a612c: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a6130: e7ff         	b	0x700a6132 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x2
700a6132: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a6136: 9903         	ldr	r1, [sp, #0xc]
700a6138: 8949         	ldrh	r1, [r1, #0xa]
700a613a: 4288         	cmp	r0, r1
700a613c: da28         	bge	0x700a6190 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0x50
700a613e: e7ff         	b	0x700a6140 <Sciclient_rmIrInpIsFree+0x80> @ imm = #-0x2
;                 int_ctrl_reg = (volatile uint32_t *)Sciclient_getIrAddr(inst->cfg, i);
700a6140: 9803         	ldr	r0, [sp, #0xc]
700a6142: 6840         	ldr	r0, [r0, #0x4]
700a6144: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a6148: f008 fcda    	bl	0x700aeb00 <Sciclient_getIrAddr> @ imm = #0x89b4
700a614c: 9001         	str	r0, [sp, #0x4]
;                 extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a614e: 9801         	ldr	r0, [sp, #0x4]
700a6150: f240 31ff    	movw	r1, #0x3ff
700a6154: 2200         	movs	r2, #0x0
700a6156: f008 ffbb    	bl	0x700af0d0 <CSL_REG32_FEXT_RAW> @ imm = #0x8f76
700a615a: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 if ((extracted_inp == inp) &&
700a615e: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a6162: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a6166: 4288         	cmp	r0, r1
700a6168: d10b         	bne	0x700a6182 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x16
700a616a: e7ff         	b	0x700a616c <Sciclient_rmIrInpIsFree+0xac> @ imm = #-0x2
;                     (Sciclient_rmIrInpRomMapped(inst, inp) == false)) {
700a616c: 9803         	ldr	r0, [sp, #0xc]
700a616e: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a6172: f002 f81d    	bl	0x700a81b0 <Sciclient_rmIrInpRomMapped> @ imm = #0x203a
;                 if ((extracted_inp == inp) &&
700a6176: b920         	cbnz	r0, 0x700a6182 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x8
700a6178: e7ff         	b	0x700a617a <Sciclient_rmIrInpIsFree+0xba> @ imm = #-0x2
700a617a: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
700a617e: 9004         	str	r0, [sp, #0x10]
;                     break;
700a6180: e006         	b	0x700a6190 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0xc
;             }
700a6182: e7ff         	b	0x700a6184 <Sciclient_rmIrInpIsFree+0xc4> @ imm = #-0x2
;             for (i = 0u; i < inst->n_outp; i++) {
700a6184: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a6188: 3001         	adds	r0, #0x1
700a618a: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a618e: e7d0         	b	0x700a6132 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x60
700a6190: e7ff         	b	0x700a6192 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #-0x2
;     }
700a6192: e7ff         	b	0x700a6194 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #-0x2
;     return r;
700a6194: 9804         	ldr	r0, [sp, #0x10]
700a6196: b006         	add	sp, #0x18
700a6198: bd80         	pop	{r7, pc}
700a619a: 0000         	movs	r0, r0
700a619c: 0000         	movs	r0, r0
700a619e: 0000         	movs	r0, r0

700a61a0 <UART_intrDisable>:
; {
700a61a0: b580         	push	{r7, lr}
700a61a2: b088         	sub	sp, #0x20
700a61a4: 9007         	str	r0, [sp, #0x1c]
700a61a6: 9106         	str	r1, [sp, #0x18]
;     if((intrFlag & 0xF0U) > 0U)
700a61a8: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a61ac: f010 0ff0    	tst.w	r0, #0xf0
700a61b0: d020         	beq	0x700a61f4 <UART_intrDisable+0x54> @ imm = #0x40
700a61b2: e7ff         	b	0x700a61b4 <UART_intrDisable+0x14> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a61b4: 9807         	ldr	r0, [sp, #0x1c]
700a61b6: 300c         	adds	r0, #0xc
700a61b8: f009 fcba    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x9974
700a61bc: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a61be: 9807         	ldr	r0, [sp, #0x1c]
700a61c0: 300c         	adds	r0, #0xc
700a61c2: 21bf         	movs	r1, #0xbf
700a61c4: f009 fcbc    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x9978
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a61c8: 9807         	ldr	r0, [sp, #0x1c]
700a61ca: 3008         	adds	r0, #0x8
700a61cc: 2110         	movs	r1, #0x10
700a61ce: 9102         	str	r1, [sp, #0x8]
700a61d0: 2204         	movs	r2, #0x4
700a61d2: 9203         	str	r2, [sp, #0xc]
700a61d4: f009 f874    	bl	0x700af2c0 <HW_RD_FIELD32_RAW> @ imm = #0x90e8
700a61d8: 9902         	ldr	r1, [sp, #0x8]
700a61da: 9a03         	ldr	r2, [sp, #0xc]
700a61dc: 9005         	str	r0, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a61de: 9807         	ldr	r0, [sp, #0x1c]
700a61e0: 3008         	adds	r0, #0x8
700a61e2: 2301         	movs	r3, #0x1
700a61e4: f008 fa0c    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x8418
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a61e8: 9807         	ldr	r0, [sp, #0x1c]
700a61ea: 300c         	adds	r0, #0xc
700a61ec: 9904         	ldr	r1, [sp, #0x10]
700a61ee: f009 fca7    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x994e
;     }
700a61f2: e7ff         	b	0x700a61f4 <UART_intrDisable+0x54> @ imm = #-0x2
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a61f4: 9807         	ldr	r0, [sp, #0x1c]
700a61f6: 300c         	adds	r0, #0xc
700a61f8: f009 fc9a    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x9934
700a61fc: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a61fe: 9807         	ldr	r0, [sp, #0x1c]
700a6200: 300c         	adds	r0, #0xc
700a6202: 9000         	str	r0, [sp]
700a6204: f009 fc94    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x9928
700a6208: 4601         	mov	r1, r0
700a620a: 9800         	ldr	r0, [sp]
700a620c: f001 017f    	and	r1, r1, #0x7f
700a6210: f009 fc96    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x992c
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) &
700a6214: 9807         	ldr	r0, [sp, #0x1c]
700a6216: 3004         	adds	r0, #0x4
700a6218: 9001         	str	r0, [sp, #0x4]
700a621a: f009 fc89    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x9912
700a621e: 4601         	mov	r1, r0
700a6220: 9801         	ldr	r0, [sp, #0x4]
700a6222: 9b06         	ldr	r3, [sp, #0x18]
700a6224: f06f 02ff    	mvn	r2, #0xff
700a6228: ea62 0203    	orn	r2, r2, r3
700a622c: 4011         	ands	r1, r2
700a622e: f009 fc87    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x990e
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a6232: 9807         	ldr	r0, [sp, #0x1c]
700a6234: 300c         	adds	r0, #0xc
700a6236: 9904         	ldr	r1, [sp, #0x10]
700a6238: f009 fc82    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x9904
;     if((intrFlag & 0xF0U) > 0U)
700a623c: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a6240: f010 0ff0    	tst.w	r0, #0xf0
700a6244: d017         	beq	0x700a6276 <UART_intrDisable+0xd6> @ imm = #0x2e
700a6246: e7ff         	b	0x700a6248 <UART_intrDisable+0xa8> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a6248: 9807         	ldr	r0, [sp, #0x1c]
700a624a: 300c         	adds	r0, #0xc
700a624c: f009 fc70    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x98e0
700a6250: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a6252: 9807         	ldr	r0, [sp, #0x1c]
700a6254: 300c         	adds	r0, #0xc
700a6256: 21bf         	movs	r1, #0xbf
700a6258: f009 fc72    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x98e4
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a625c: 9807         	ldr	r0, [sp, #0x1c]
700a625e: 3008         	adds	r0, #0x8
700a6260: 9b05         	ldr	r3, [sp, #0x14]
700a6262: 2110         	movs	r1, #0x10
700a6264: 2204         	movs	r2, #0x4
700a6266: f008 f9cb    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x8396
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a626a: 9807         	ldr	r0, [sp, #0x1c]
700a626c: 300c         	adds	r0, #0xc
700a626e: 9904         	ldr	r1, [sp, #0x10]
700a6270: f009 fc66    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x98cc
;     }
700a6274: e7ff         	b	0x700a6276 <UART_intrDisable+0xd6> @ imm = #-0x2
; }
700a6276: b008         	add	sp, #0x20
700a6278: bd80         	pop	{r7, pc}
700a627a: 0000         	movs	r0, r0
700a627c: 0000         	movs	r0, r0
700a627e: 0000         	movs	r0, r0

700a6280 <UART_udmaConfigPdmaTx>:
; {
700a6280: b580         	push	{r7, lr}
700a6282: b090         	sub	sp, #0x40
700a6284: 900f         	str	r0, [sp, #0x3c]
700a6286: 910e         	str	r1, [sp, #0x38]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a6288: 980f         	ldr	r0, [sp, #0x3c]
700a628a: 6840         	ldr	r0, [r0, #0x4]
700a628c: 6cc0         	ldr	r0, [r0, #0x4c]
700a628e: 9008         	str	r0, [sp, #0x20]
;     txChHandle  = udmaChCfg->txChHandle;
700a6290: 9808         	ldr	r0, [sp, #0x20]
700a6292: 6840         	ldr	r0, [r0, #0x4]
700a6294: 9009         	str	r0, [sp, #0x24]
700a6296: a80a         	add	r0, sp, #0x28
;     UdmaChPdmaPrms_init(&pdmaPrms);
700a6298: 9002         	str	r0, [sp, #0x8]
700a629a: f009 f8e1    	bl	0x700af460 <UdmaChPdmaPrms_init> @ imm = #0x91c2
700a629e: 9902         	ldr	r1, [sp, #0x8]
700a62a0: 2000         	movs	r0, #0x0
;     pdmaPrms.elemSize = UDMA_PDMA_ES_8BITS;
700a62a2: 9003         	str	r0, [sp, #0xc]
700a62a4: 900a         	str	r0, [sp, #0x28]
700a62a6: 2201         	movs	r2, #0x1
;     pdmaPrms.elemCnt  = 1U;
700a62a8: 920b         	str	r2, [sp, #0x2c]
;     pdmaPrms.fifoCnt  = 0U;
700a62aa: 900c         	str	r0, [sp, #0x30]
;     retVal = Udma_chConfigPdma(txChHandle, &pdmaPrms);
700a62ac: 9809         	ldr	r0, [sp, #0x24]
700a62ae: f7fa fdd7    	bl	0x700a0e60 <Udma_chConfigPdma> @ imm = #-0x5452
700a62b2: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a62b4: 980d         	ldr	r0, [sp, #0x34]
700a62b6: fab0 f080    	clz	r0, r0
700a62ba: 0940         	lsrs	r0, r0, #0x5
700a62bc: f641 718f    	movw	r1, #0x1f8f
700a62c0: f2c7 010b    	movt	r1, #0x700b
700a62c4: 9105         	str	r1, [sp, #0x14]
700a62c6: 466a         	mov	r2, sp
700a62c8: 6011         	str	r1, [r2]
700a62ca: f641 3191    	movw	r1, #0x1b91
700a62ce: f2c7 010b    	movt	r1, #0x700b
700a62d2: 9106         	str	r1, [sp, #0x18]
700a62d4: f641 7252    	movw	r2, #0x1f52
700a62d8: f2c7 020b    	movt	r2, #0x700b
700a62dc: 9207         	str	r2, [sp, #0x1c]
700a62de: 23ee         	movs	r3, #0xee
700a62e0: f004 fbf6    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x47ec
;     retVal = Udma_chEnable(txChHandle);
700a62e4: 9809         	ldr	r0, [sp, #0x24]
700a62e6: f004 feb3    	bl	0x700ab050 <Udma_chEnable> @ imm = #0x4d66
700a62ea: 9b05         	ldr	r3, [sp, #0x14]
700a62ec: 9906         	ldr	r1, [sp, #0x18]
700a62ee: 9a07         	ldr	r2, [sp, #0x1c]
700a62f0: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a62f2: 980d         	ldr	r0, [sp, #0x34]
700a62f4: fab0 f080    	clz	r0, r0
700a62f8: 0940         	lsrs	r0, r0, #0x5
700a62fa: 46ec         	mov	r12, sp
700a62fc: f8cc 3000    	str.w	r3, [r12]
700a6300: 23f1         	movs	r3, #0xf1
700a6302: f004 fbe5    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x47ca
;     UART_udmaHpdInit(txChHandle, (uint8_t *) udmaChCfg->txHpdMem, hUart->writeBuf, transaction->count);
700a6306: 9809         	ldr	r0, [sp, #0x24]
700a6308: 9908         	ldr	r1, [sp, #0x20]
700a630a: 6949         	ldr	r1, [r1, #0x14]
700a630c: 9a0f         	ldr	r2, [sp, #0x3c]
700a630e: 6892         	ldr	r2, [r2, #0x8]
700a6310: 9b0e         	ldr	r3, [sp, #0x38]
700a6312: 685b         	ldr	r3, [r3, #0x4]
700a6314: f000 fd3c    	bl	0x700a6d90 <UART_udmaHpdInit> @ imm = #0xa78
;                  Udma_chGetFqRingHandle(txChHandle),
700a6318: 9809         	ldr	r0, [sp, #0x24]
700a631a: f004 fdd9    	bl	0x700aaed0 <Udma_chGetFqRingHandle> @ imm = #0x4bb2
700a631e: 9a03         	ldr	r2, [sp, #0xc]
;                  (uint64_t) Udma_defaultVirtToPhyFxn(udmaChCfg->txHpdMem, 0U, NULL));
700a6320: 9004         	str	r0, [sp, #0x10]
700a6322: 9808         	ldr	r0, [sp, #0x20]
700a6324: 6940         	ldr	r0, [r0, #0x14]
700a6326: 4611         	mov	r1, r2
700a6328: f009 fc12    	bl	0x700afb50 <Udma_defaultVirtToPhyFxn> @ imm = #0x9824
700a632c: 4602         	mov	r2, r0
700a632e: 9804         	ldr	r0, [sp, #0x10]
700a6330: 460b         	mov	r3, r1
;     retVal = Udma_ringQueueRaw(
700a6332: f002 fe75    	bl	0x700a9020 <Udma_ringQueueRaw> @ imm = #0x2cea
700a6336: 9b05         	ldr	r3, [sp, #0x14]
700a6338: 9906         	ldr	r1, [sp, #0x18]
700a633a: 9a07         	ldr	r2, [sp, #0x1c]
700a633c: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a633e: 980d         	ldr	r0, [sp, #0x34]
700a6340: fab0 f080    	clz	r0, r0
700a6344: 0940         	lsrs	r0, r0, #0x5
700a6346: 46ec         	mov	r12, sp
700a6348: f8cc 3000    	str.w	r3, [r12]
700a634c: 23f9         	movs	r3, #0xf9
700a634e: f004 fbbf    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x477e
;     return (retVal);
700a6352: 980d         	ldr	r0, [sp, #0x34]
700a6354: b010         	add	sp, #0x40
700a6356: bd80         	pop	{r7, pc}
		...

700a6360 <vTaskDelete>:
; void vTaskDelete(TaskHandle_t xTaskToDelete) {
700a6360: b580         	push	{r7, lr}
700a6362: b084         	sub	sp, #0x10
700a6364: 9003         	str	r0, [sp, #0xc]
;   taskENTER_CRITICAL();
700a6366: f008 f9ab    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x8356
;     pxTCB = prvGetTCBFromHandle(xTaskToDelete);
700a636a: 9803         	ldr	r0, [sp, #0xc]
700a636c: b938         	cbnz	r0, 0x700a637e <vTaskDelete+0x1e> @ imm = #0xe
700a636e: e7ff         	b	0x700a6370 <vTaskDelete+0x10> @ imm = #-0x2
700a6370: f642 2000    	movw	r0, #0x2a00
700a6374: f2c7 000b    	movt	r0, #0x700b
700a6378: 6800         	ldr	r0, [r0]
700a637a: 9001         	str	r0, [sp, #0x4]
700a637c: e002         	b	0x700a6384 <vTaskDelete+0x24> @ imm = #0x4
700a637e: 9803         	ldr	r0, [sp, #0xc]
700a6380: 9001         	str	r0, [sp, #0x4]
700a6382: e7ff         	b	0x700a6384 <vTaskDelete+0x24> @ imm = #-0x2
700a6384: 9801         	ldr	r0, [sp, #0x4]
700a6386: 9002         	str	r0, [sp, #0x8]
;     if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a6388: 9802         	ldr	r0, [sp, #0x8]
700a638a: 3004         	adds	r0, #0x4
700a638c: f007 f948    	bl	0x700ad620 <uxListRemove> @ imm = #0x7290
700a6390: b908         	cbnz	r0, 0x700a6396 <vTaskDelete+0x36> @ imm = #0x2
700a6392: e7ff         	b	0x700a6394 <vTaskDelete+0x34> @ imm = #-0x2
;     } else {
700a6394: e000         	b	0x700a6398 <vTaskDelete+0x38> @ imm = #0x0
700a6396: e7ff         	b	0x700a6398 <vTaskDelete+0x38> @ imm = #-0x2
;     if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a6398: 9802         	ldr	r0, [sp, #0x8]
700a639a: 6a80         	ldr	r0, [r0, #0x28]
700a639c: b128         	cbz	r0, 0x700a63aa <vTaskDelete+0x4a> @ imm = #0xa
700a639e: e7ff         	b	0x700a63a0 <vTaskDelete+0x40> @ imm = #-0x2
;       (void)uxListRemove(&(pxTCB->xEventListItem));
700a63a0: 9802         	ldr	r0, [sp, #0x8]
700a63a2: 3018         	adds	r0, #0x18
700a63a4: f007 f93c    	bl	0x700ad620 <uxListRemove> @ imm = #0x7278
;     } else {
700a63a8: e000         	b	0x700a63ac <vTaskDelete+0x4c> @ imm = #0x0
700a63aa: e7ff         	b	0x700a63ac <vTaskDelete+0x4c> @ imm = #-0x2
;     uxTaskNumber++;
700a63ac: f642 2128    	movw	r1, #0x2a28
700a63b0: f2c7 010b    	movt	r1, #0x700b
700a63b4: 6808         	ldr	r0, [r1]
700a63b6: 3001         	adds	r0, #0x1
700a63b8: 6008         	str	r0, [r1]
;     if (pxTCB == pxCurrentTCB) {
700a63ba: 9802         	ldr	r0, [sp, #0x8]
700a63bc: f642 2100    	movw	r1, #0x2a00
700a63c0: f2c7 010b    	movt	r1, #0x700b
700a63c4: 6809         	ldr	r1, [r1]
700a63c6: 4288         	cmp	r0, r1
700a63c8: d110         	bne	0x700a63ec <vTaskDelete+0x8c> @ imm = #0x20
700a63ca: e7ff         	b	0x700a63cc <vTaskDelete+0x6c> @ imm = #-0x2
;       vListInsertEnd(&xTasksWaitingTermination, &(pxTCB->xStateListItem));
700a63cc: 9802         	ldr	r0, [sp, #0x8]
700a63ce: 1d01         	adds	r1, r0, #0x4
700a63d0: f245 1008    	movw	r0, #0x5108
700a63d4: f2c7 0008    	movt	r0, #0x7008
700a63d8: f007 feda    	bl	0x700ae190 <vListInsertEnd> @ imm = #0x7db4
;       ++uxDeletedTasksWaitingCleanUp;
700a63dc: f642 2120    	movw	r1, #0x2a20
700a63e0: f2c7 010b    	movt	r1, #0x700b
700a63e4: 6808         	ldr	r0, [r1]
700a63e6: 3001         	adds	r0, #0x1
700a63e8: 6008         	str	r0, [r1]
;     } else {
700a63ea: e00c         	b	0x700a6406 <vTaskDelete+0xa6> @ imm = #0x18
;       --uxCurrentNumberOfTasks;
700a63ec: f642 211c    	movw	r1, #0x2a1c
700a63f0: f2c7 010b    	movt	r1, #0x700b
700a63f4: 6808         	ldr	r0, [r1]
700a63f6: 3801         	subs	r0, #0x1
700a63f8: 6008         	str	r0, [r1]
;       prvDeleteTCB(pxTCB);
700a63fa: 9802         	ldr	r0, [sp, #0x8]
700a63fc: f007 fe28    	bl	0x700ae050 <prvDeleteTCB> @ imm = #0x7c50
;       prvResetNextTaskUnblockTime();
700a6400: f007 fe46    	bl	0x700ae090 <prvResetNextTaskUnblockTime> @ imm = #0x7c8c
700a6404: e7ff         	b	0x700a6406 <vTaskDelete+0xa6> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a6406: f007 f9fb    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x73f6
;   if (xSchedulerRunning != pdFALSE) {
700a640a: f642 2040    	movw	r0, #0x2a40
700a640e: f2c7 000b    	movt	r0, #0x700b
700a6412: 6800         	ldr	r0, [r0]
700a6414: b168         	cbz	r0, 0x700a6432 <vTaskDelete+0xd2> @ imm = #0x1a
700a6416: e7ff         	b	0x700a6418 <vTaskDelete+0xb8> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a6418: 9802         	ldr	r0, [sp, #0x8]
700a641a: f642 2100    	movw	r1, #0x2a00
700a641e: f2c7 010b    	movt	r1, #0x700b
700a6422: 6809         	ldr	r1, [r1]
700a6424: 4288         	cmp	r0, r1
700a6426: d102         	bne	0x700a642e <vTaskDelete+0xce> @ imm = #0x4
700a6428: e7ff         	b	0x700a642a <vTaskDelete+0xca> @ imm = #-0x2
;       portYIELD_WITHIN_API();
700a642a: df00         	svc	#0x0
;     } else {
700a642c: e000         	b	0x700a6430 <vTaskDelete+0xd0> @ imm = #0x0
700a642e: e7ff         	b	0x700a6430 <vTaskDelete+0xd0> @ imm = #-0x2
;   }
700a6430: e7ff         	b	0x700a6432 <vTaskDelete+0xd2> @ imm = #-0x2
; }
700a6432: b004         	add	sp, #0x10
700a6434: bd80         	pop	{r7, pc}
		...
700a643e: 0000         	movs	r0, r0

700a6440 <CSL_bcdmaChanOpGetChanRT>:
; {
700a6440: b580         	push	{r7, lr}
700a6442: b088         	sub	sp, #0x20
700a6444: 9007         	str	r0, [sp, #0x1c]
700a6446: 9106         	str	r1, [sp, #0x18]
700a6448: 9205         	str	r2, [sp, #0x14]
700a644a: 9304         	str	r3, [sp, #0x10]
700a644c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a644e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a6450: 9804         	ldr	r0, [sp, #0x10]
700a6452: b920         	cbnz	r0, 0x700a645e <CSL_bcdmaChanOpGetChanRT+0x1e> @ imm = #0x8
700a6454: e7ff         	b	0x700a6456 <CSL_bcdmaChanOpGetChanRT+0x16> @ imm = #-0x2
700a6456: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a645a: 9003         	str	r0, [sp, #0xc]
;     }
700a645c: e057         	b	0x700a650e <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #0xae
;         switch( chanType )
700a645e: 9806         	ldr	r0, [sp, #0x18]
700a6460: 9000         	str	r0, [sp]
700a6462: b140         	cbz	r0, 0x700a6476 <CSL_bcdmaChanOpGetChanRT+0x36> @ imm = #0x10
700a6464: e7ff         	b	0x700a6466 <CSL_bcdmaChanOpGetChanRT+0x26> @ imm = #-0x2
700a6466: 9800         	ldr	r0, [sp]
700a6468: 2801         	cmp	r0, #0x1
700a646a: d00d         	beq	0x700a6488 <CSL_bcdmaChanOpGetChanRT+0x48> @ imm = #0x1a
700a646c: e7ff         	b	0x700a646e <CSL_bcdmaChanOpGetChanRT+0x2e> @ imm = #-0x2
700a646e: 9800         	ldr	r0, [sp]
700a6470: 2802         	cmp	r0, #0x2
700a6472: d012         	beq	0x700a649a <CSL_bcdmaChanOpGetChanRT+0x5a> @ imm = #0x24
700a6474: e01a         	b	0x700a64ac <CSL_bcdmaChanOpGetChanRT+0x6c> @ imm = #0x34
;                 val = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
700a6476: 9807         	ldr	r0, [sp, #0x1c]
700a6478: 6880         	ldr	r0, [r0, #0x8]
700a647a: 9905         	ldr	r1, [sp, #0x14]
700a647c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6480: f009 fb9e    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0x973c
700a6484: 9002         	str	r0, [sp, #0x8]
;                 break;
700a6486: e015         	b	0x700a64b4 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x2a
;                 val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a6488: 9807         	ldr	r0, [sp, #0x1c]
700a648a: 6900         	ldr	r0, [r0, #0x10]
700a648c: 9905         	ldr	r1, [sp, #0x14]
700a648e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6492: f009 fb95    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0x972a
700a6496: 9002         	str	r0, [sp, #0x8]
;                 break;
700a6498: e00c         	b	0x700a64b4 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x18
;                 val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a649a: 9807         	ldr	r0, [sp, #0x1c]
700a649c: 6980         	ldr	r0, [r0, #0x18]
700a649e: 9905         	ldr	r1, [sp, #0x14]
700a64a0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a64a4: f009 fb8c    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0x9718
700a64a8: 9002         	str	r0, [sp, #0x8]
;                 break;
700a64aa: e003         	b	0x700a64b4 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x6
700a64ac: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a64b0: 9003         	str	r0, [sp, #0xc]
;                 break;
700a64b2: e7ff         	b	0x700a64b4 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #-0x2
;         if( retVal == CSL_PASS )
700a64b4: 9803         	ldr	r0, [sp, #0xc]
700a64b6: bb48         	cbnz	r0, 0x700a650c <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #0x52
700a64b8: e7ff         	b	0x700a64ba <CSL_bcdmaChanOpGetChanRT+0x7a> @ imm = #-0x2
;             CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a64ba: 9804         	ldr	r0, [sp, #0x10]
700a64bc: 9001         	str	r0, [sp, #0x4]
;             pRT->enable         = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_EN );
700a64be: 9802         	ldr	r0, [sp, #0x8]
700a64c0: 0fc0         	lsrs	r0, r0, #0x1f
700a64c2: 9901         	ldr	r1, [sp, #0x4]
700a64c4: 6008         	str	r0, [r1]
;             pRT->teardown       = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_TDOWN );
700a64c6: 9802         	ldr	r0, [sp, #0x8]
700a64c8: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700a64cc: 9901         	ldr	r1, [sp, #0x4]
700a64ce: 6048         	str	r0, [r1, #0x4]
;             pRT->forcedTeardown = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_FTDOWN );
700a64d0: 9802         	ldr	r0, [sp, #0x8]
700a64d2: f3c0 7000    	ubfx	r0, r0, #0x1c, #0x1
700a64d6: 9901         	ldr	r1, [sp, #0x4]
700a64d8: 6108         	str	r0, [r1, #0x10]
;             pRT->pause          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_PAUSE );
700a64da: 9802         	ldr	r0, [sp, #0x8]
700a64dc: f3c0 7040    	ubfx	r0, r0, #0x1d, #0x1
700a64e0: 9901         	ldr	r1, [sp, #0x4]
700a64e2: 6088         	str	r0, [r1, #0x8]
;             pRT->error          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_ERROR );
700a64e4: 9802         	ldr	r0, [sp, #0x8]
700a64e6: f000 0001    	and	r0, r0, #0x1
700a64ea: 9901         	ldr	r1, [sp, #0x4]
700a64ec: 60c8         	str	r0, [r1, #0xc]
;             if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a64ee: 9806         	ldr	r0, [sp, #0x18]
700a64f0: 2802         	cmp	r0, #0x2
700a64f2: d106         	bne	0x700a6502 <CSL_bcdmaChanOpGetChanRT+0xc2> @ imm = #0xc
700a64f4: e7ff         	b	0x700a64f6 <CSL_bcdmaChanOpGetChanRT+0xb6> @ imm = #-0x2
;                 pRT->starvation = CSL_FEXT( val, BCDMA_RXCRT_CHAN_CTL_STARVATION );
700a64f6: 9802         	ldr	r0, [sp, #0x8]
700a64f8: f3c0 0040    	ubfx	r0, r0, #0x1, #0x1
700a64fc: 9901         	ldr	r1, [sp, #0x4]
700a64fe: 6148         	str	r0, [r1, #0x14]
;             }
700a6500: e003         	b	0x700a650a <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #0x6
;                 pRT->starvation = (uint32_t)0U;
700a6502: 9901         	ldr	r1, [sp, #0x4]
700a6504: 2000         	movs	r0, #0x0
700a6506: 6148         	str	r0, [r1, #0x14]
700a6508: e7ff         	b	0x700a650a <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #-0x2
;         }
700a650a: e7ff         	b	0x700a650c <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #-0x2
700a650c: e7ff         	b	0x700a650e <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #-0x2
;     return retVal;
700a650e: 9803         	ldr	r0, [sp, #0xc]
700a6510: b008         	add	sp, #0x20
700a6512: bd80         	pop	{r7, pc}
		...

700a6520 <Pinmux_unlockMMR>:
; {
700a6520: b580         	push	{r7, lr}
700a6522: b088         	sub	sp, #0x20
700a6524: 9007         	str	r0, [sp, #0x1c]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a6526: 9807         	ldr	r0, [sp, #0x1c]
700a6528: bb78         	cbnz	r0, 0x700a658a <Pinmux_unlockMMR+0x6a> @ imm = #0x5e
700a652a: e7ff         	b	0x700a652c <Pinmux_unlockMMR+0xc> @ imm = #-0x2
700a652c: f44f 2070    	mov.w	r0, #0xf0000
700a6530: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_PADCFG_CTRL0_CFG0_BASE);
700a6532: f7ff fa95    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0xad6
700a6536: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK0_KICK0_OFFSET);
700a6538: 9806         	ldr	r0, [sp, #0x18]
700a653a: f241 0108    	movw	r1, #0x1008
700a653e: 4408         	add	r0, r1
700a6540: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6542: 9805         	ldr	r0, [sp, #0x14]
700a6544: f243 4190    	movw	r1, #0x3490
700a6548: f6c6 01ef    	movt	r1, #0x68ef
700a654c: 9103         	str	r1, [sp, #0xc]
700a654e: f009 faa7    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x954e
;         kickAddr++;
700a6552: 9805         	ldr	r0, [sp, #0x14]
700a6554: 3004         	adds	r0, #0x4
700a6556: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6558: 9805         	ldr	r0, [sp, #0x14]
700a655a: f64b 415a    	movw	r1, #0xbc5a
700a655e: f2cd 1172    	movt	r1, #0xd172
700a6562: 9104         	str	r1, [sp, #0x10]
700a6564: f009 fa9c    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x9538
700a6568: 9903         	ldr	r1, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK1_KICK0_OFFSET);
700a656a: 9806         	ldr	r0, [sp, #0x18]
700a656c: f245 0208    	movw	r2, #0x5008
700a6570: 4410         	add	r0, r2
700a6572: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6574: 9805         	ldr	r0, [sp, #0x14]
700a6576: f009 fa93    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x9526
700a657a: 9904         	ldr	r1, [sp, #0x10]
;         kickAddr++;
700a657c: 9805         	ldr	r0, [sp, #0x14]
700a657e: 3004         	adds	r0, #0x4
700a6580: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6582: 9805         	ldr	r0, [sp, #0x14]
700a6584: f009 fa8c    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x9518
;     }
700a6588: e7ff         	b	0x700a658a <Pinmux_unlockMMR+0x6a> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700a658a: 9807         	ldr	r0, [sp, #0x1c]
700a658c: 2801         	cmp	r0, #0x1
700a658e: d12f         	bne	0x700a65f0 <Pinmux_unlockMMR+0xd0> @ imm = #0x5e
700a6590: e7ff         	b	0x700a6592 <Pinmux_unlockMMR+0x72> @ imm = #-0x2
700a6592: f04f 6081    	mov.w	r0, #0x4080000
700a6596: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700a6598: f7ff fa62    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0xb3c
700a659c: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700a659e: 9806         	ldr	r0, [sp, #0x18]
700a65a0: f241 0108    	movw	r1, #0x1008
700a65a4: 4408         	add	r0, r1
700a65a6: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a65a8: 9805         	ldr	r0, [sp, #0x14]
700a65aa: f243 4190    	movw	r1, #0x3490
700a65ae: f6c6 01ef    	movt	r1, #0x68ef
700a65b2: 9101         	str	r1, [sp, #0x4]
700a65b4: f009 fa74    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x94e8
;         kickAddr++;
700a65b8: 9805         	ldr	r0, [sp, #0x14]
700a65ba: 3004         	adds	r0, #0x4
700a65bc: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a65be: 9805         	ldr	r0, [sp, #0x14]
700a65c0: f64b 415a    	movw	r1, #0xbc5a
700a65c4: f2cd 1172    	movt	r1, #0xd172
700a65c8: 9102         	str	r1, [sp, #0x8]
700a65ca: f009 fa69    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x94d2
700a65ce: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700a65d0: 9806         	ldr	r0, [sp, #0x18]
700a65d2: f245 0208    	movw	r2, #0x5008
700a65d6: 4410         	add	r0, r2
700a65d8: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a65da: 9805         	ldr	r0, [sp, #0x14]
700a65dc: f009 fa60    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x94c0
700a65e0: 9902         	ldr	r1, [sp, #0x8]
;         kickAddr++;
700a65e2: 9805         	ldr	r0, [sp, #0x14]
700a65e4: 3004         	adds	r0, #0x4
700a65e6: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a65e8: 9805         	ldr	r0, [sp, #0x14]
700a65ea: f009 fa59    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x94b2
;     }
700a65ee: e7ff         	b	0x700a65f0 <Pinmux_unlockMMR+0xd0> @ imm = #-0x2
;     return;
700a65f0: b008         	add	sp, #0x20
700a65f2: bd80         	pop	{r7, pc}
		...

700a6600 <prvAddCurrentTaskToDelayedList>:
;                                const BaseType_t xCanBlockIndefinitely) {
700a6600: b580         	push	{r7, lr}
700a6602: b084         	sub	sp, #0x10
700a6604: 9003         	str	r0, [sp, #0xc]
700a6606: 9102         	str	r1, [sp, #0x8]
;   const TickType_t xConstTickCount = xTickCount;
700a6608: f642 2044    	movw	r0, #0x2a44
700a660c: f2c7 000b    	movt	r0, #0x700b
700a6610: 6800         	ldr	r0, [r0]
700a6612: 9000         	str	r0, [sp]
;   if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
700a6614: f642 2000    	movw	r0, #0x2a00
700a6618: f2c7 000b    	movt	r0, #0x700b
700a661c: 6800         	ldr	r0, [r0]
700a661e: 3004         	adds	r0, #0x4
700a6620: f006 fffe    	bl	0x700ad620 <uxListRemove> @ imm = #0x6ffc
700a6624: b908         	cbnz	r0, 0x700a662a <prvAddCurrentTaskToDelayedList+0x2a> @ imm = #0x2
700a6626: e7ff         	b	0x700a6628 <prvAddCurrentTaskToDelayedList+0x28> @ imm = #-0x2
;   } else {
700a6628: e000         	b	0x700a662c <prvAddCurrentTaskToDelayedList+0x2c> @ imm = #0x0
700a662a: e7ff         	b	0x700a662c <prvAddCurrentTaskToDelayedList+0x2c> @ imm = #-0x2
;     if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
700a662c: 9803         	ldr	r0, [sp, #0xc]
700a662e: 3001         	adds	r0, #0x1
700a6630: b980         	cbnz	r0, 0x700a6654 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #0x20
700a6632: e7ff         	b	0x700a6634 <prvAddCurrentTaskToDelayedList+0x34> @ imm = #-0x2
700a6634: 9802         	ldr	r0, [sp, #0x8]
700a6636: b168         	cbz	r0, 0x700a6654 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #0x1a
700a6638: e7ff         	b	0x700a663a <prvAddCurrentTaskToDelayedList+0x3a> @ imm = #-0x2
;       vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
700a663a: f642 2000    	movw	r0, #0x2a00
700a663e: f2c7 000b    	movt	r0, #0x700b
700a6642: 6800         	ldr	r0, [r0]
700a6644: 1d01         	adds	r1, r0, #0x4
700a6646: f245 00f4    	movw	r0, #0x50f4
700a664a: f2c7 0008    	movt	r0, #0x7008
700a664e: f007 fd9f    	bl	0x700ae190 <vListInsertEnd> @ imm = #0x7b3e
;     } else {
700a6652: e03d         	b	0x700a66d0 <prvAddCurrentTaskToDelayedList+0xd0> @ imm = #0x7a
;       xTimeToWake = xConstTickCount + xTicksToWait;
700a6654: 9800         	ldr	r0, [sp]
700a6656: 9903         	ldr	r1, [sp, #0xc]
700a6658: 4408         	add	r0, r1
700a665a: 9001         	str	r0, [sp, #0x4]
;       listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
700a665c: 9801         	ldr	r0, [sp, #0x4]
700a665e: f642 2100    	movw	r1, #0x2a00
700a6662: f2c7 010b    	movt	r1, #0x700b
700a6666: 6809         	ldr	r1, [r1]
700a6668: 6048         	str	r0, [r1, #0x4]
;       if (xTimeToWake < xConstTickCount) {
700a666a: 9801         	ldr	r0, [sp, #0x4]
700a666c: 9900         	ldr	r1, [sp]
700a666e: 4288         	cmp	r0, r1
700a6670: d20e         	bhs	0x700a6690 <prvAddCurrentTaskToDelayedList+0x90> @ imm = #0x1c
700a6672: e7ff         	b	0x700a6674 <prvAddCurrentTaskToDelayedList+0x74> @ imm = #-0x2
;         vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a6674: f245 102c    	movw	r0, #0x512c
700a6678: f2c7 0008    	movt	r0, #0x7008
700a667c: 6800         	ldr	r0, [r0]
700a667e: f642 2100    	movw	r1, #0x2a00
700a6682: f2c7 010b    	movt	r1, #0x700b
700a6686: 6809         	ldr	r1, [r1]
700a6688: 3104         	adds	r1, #0x4
700a668a: f005 f811    	bl	0x700ab6b0 <vListInsert> @ imm = #0x5022
;       } else {
700a668e: e01e         	b	0x700a66ce <prvAddCurrentTaskToDelayedList+0xce> @ imm = #0x3c
;         vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a6690: f245 1028    	movw	r0, #0x5128
700a6694: f2c7 0008    	movt	r0, #0x7008
700a6698: 6800         	ldr	r0, [r0]
700a669a: f642 2100    	movw	r1, #0x2a00
700a669e: f2c7 010b    	movt	r1, #0x700b
700a66a2: 6809         	ldr	r1, [r1]
700a66a4: 3104         	adds	r1, #0x4
700a66a6: f005 f803    	bl	0x700ab6b0 <vListInsert> @ imm = #0x5006
;         if (xTimeToWake < xNextTaskUnblockTime) {
700a66aa: 9801         	ldr	r0, [sp, #0x4]
700a66ac: f642 2134    	movw	r1, #0x2a34
700a66b0: f2c7 010b    	movt	r1, #0x700b
700a66b4: 6809         	ldr	r1, [r1]
700a66b6: 4288         	cmp	r0, r1
700a66b8: d207         	bhs	0x700a66ca <prvAddCurrentTaskToDelayedList+0xca> @ imm = #0xe
700a66ba: e7ff         	b	0x700a66bc <prvAddCurrentTaskToDelayedList+0xbc> @ imm = #-0x2
;           xNextTaskUnblockTime = xTimeToWake;
700a66bc: 9801         	ldr	r0, [sp, #0x4]
700a66be: f642 2134    	movw	r1, #0x2a34
700a66c2: f2c7 010b    	movt	r1, #0x700b
700a66c6: 6008         	str	r0, [r1]
;         } else {
700a66c8: e000         	b	0x700a66cc <prvAddCurrentTaskToDelayedList+0xcc> @ imm = #0x0
700a66ca: e7ff         	b	0x700a66cc <prvAddCurrentTaskToDelayedList+0xcc> @ imm = #-0x2
700a66cc: e7ff         	b	0x700a66ce <prvAddCurrentTaskToDelayedList+0xce> @ imm = #-0x2
700a66ce: e7ff         	b	0x700a66d0 <prvAddCurrentTaskToDelayedList+0xd0> @ imm = #-0x2
; }
700a66d0: b004         	add	sp, #0x10
700a66d2: bd80         	pop	{r7, pc}
		...

700a66e0 <UART_lld_write>:
; {
700a66e0: b580         	push	{r7, lr}
700a66e2: b086         	sub	sp, #0x18
700a66e4: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a66e8: 9005         	str	r0, [sp, #0x14]
700a66ea: 9104         	str	r1, [sp, #0x10]
700a66ec: 9203         	str	r2, [sp, #0xc]
700a66ee: 9302         	str	r3, [sp, #0x8]
700a66f0: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a66f2: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a66f4: 9805         	ldr	r0, [sp, #0x14]
700a66f6: 2800         	cmp	r0, #0x0
700a66f8: d054         	beq	0x700a67a4 <UART_lld_write+0xc4> @ imm = #0xa8
700a66fa: e7ff         	b	0x700a66fc <UART_lld_write+0x1c> @ imm = #-0x2
;          trans = &hUart->writeTrans;
700a66fc: 9805         	ldr	r0, [sp, #0x14]
700a66fe: 303c         	adds	r0, #0x3c
700a6700: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a6702: 9800         	ldr	r0, [sp]
700a6704: 6800         	ldr	r0, [r0]
700a6706: b138         	cbz	r0, 0x700a6718 <UART_lld_write+0x38> @ imm = #0xe
700a6708: e7ff         	b	0x700a670a <UART_lld_write+0x2a> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a670a: 9900         	ldr	r1, [sp]
700a670c: 2009         	movs	r0, #0x9
700a670e: 60c8         	str	r0, [r1, #0xc]
700a6710: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a6714: 9001         	str	r0, [sp, #0x4]
;         }
700a6716: e044         	b	0x700a67a2 <UART_lld_write+0xc2> @ imm = #0x88
;             UART_lld_Transaction_init(trans);
700a6718: 9800         	ldr	r0, [sp]
700a671a: f008 faf9    	bl	0x700aed10 <UART_lld_Transaction_init> @ imm = #0x85f2
;             if(extendedParams != NULL)
700a671e: 9808         	ldr	r0, [sp, #0x20]
700a6720: b128         	cbz	r0, 0x700a672e <UART_lld_write+0x4e> @ imm = #0xa
700a6722: e7ff         	b	0x700a6724 <UART_lld_write+0x44> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a6724: 9808         	ldr	r0, [sp, #0x20]
700a6726: 6800         	ldr	r0, [r0]
700a6728: 9900         	ldr	r1, [sp]
700a672a: 6108         	str	r0, [r1, #0x10]
;             }
700a672c: e003         	b	0x700a6736 <UART_lld_write+0x56> @ imm = #0x6
;                 trans->args = NULL;
700a672e: 9900         	ldr	r1, [sp]
700a6730: 2000         	movs	r0, #0x0
700a6732: 6108         	str	r0, [r1, #0x10]
700a6734: e7ff         	b	0x700a6736 <UART_lld_write+0x56> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a6736: 9804         	ldr	r0, [sp, #0x10]
700a6738: 9900         	ldr	r1, [sp]
700a673a: 6008         	str	r0, [r1]
;             trans->count = size;
700a673c: 9803         	ldr	r0, [sp, #0xc]
700a673e: 9900         	ldr	r1, [sp]
700a6740: 6048         	str	r0, [r1, #0x4]
;             trans->timeout = timeout;
700a6742: 9802         	ldr	r0, [sp, #0x8]
700a6744: 9900         	ldr	r1, [sp]
700a6746: 6088         	str	r0, [r1, #0x8]
;             if(hUart->state == UART_STATE_READY)
700a6748: 9805         	ldr	r0, [sp, #0x14]
700a674a: 6d40         	ldr	r0, [r0, #0x54]
700a674c: 2801         	cmp	r0, #0x1
700a674e: d105         	bne	0x700a675c <UART_lld_write+0x7c> @ imm = #0xa
700a6750: e7ff         	b	0x700a6752 <UART_lld_write+0x72> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a6752: 9800         	ldr	r0, [sp]
700a6754: f007 fedc    	bl	0x700ae510 <UART_checkTransaction> @ imm = #0x7db8
700a6758: 9001         	str	r0, [sp, #0x4]
;             }
700a675a: e003         	b	0x700a6764 <UART_lld_write+0x84> @ imm = #0x6
700a675c: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a6760: 9001         	str	r0, [sp, #0x4]
700a6762: e7ff         	b	0x700a6764 <UART_lld_write+0x84> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a6764: 9801         	ldr	r0, [sp, #0x4]
700a6766: b980         	cbnz	r0, 0x700a678a <UART_lld_write+0xaa> @ imm = #0x20
700a6768: e7ff         	b	0x700a676a <UART_lld_write+0x8a> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a676a: 9800         	ldr	r0, [sp]
700a676c: 6800         	ldr	r0, [r0]
700a676e: 9905         	ldr	r1, [sp, #0x14]
700a6770: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a6772: 9800         	ldr	r0, [sp]
700a6774: 6880         	ldr	r0, [r0, #0x8]
700a6776: 9905         	ldr	r1, [sp, #0x14]
700a6778: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a677a: 9905         	ldr	r1, [sp, #0x14]
700a677c: 2000         	movs	r0, #0x0
700a677e: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a6780: 9800         	ldr	r0, [sp]
700a6782: 6840         	ldr	r0, [r0, #0x4]
700a6784: 9905         	ldr	r1, [sp, #0x14]
700a6786: 6108         	str	r0, [r1, #0x10]
;             }
700a6788: e7ff         	b	0x700a678a <UART_lld_write+0xaa> @ imm = #-0x2
;             hUart->state = UART_STATE_BUSY;
700a678a: 9905         	ldr	r1, [sp, #0x14]
700a678c: 2002         	movs	r0, #0x2
700a678e: 6548         	str	r0, [r1, #0x54]
;             status = UART_writePolling(hUart, trans);
700a6790: 9805         	ldr	r0, [sp, #0x14]
700a6792: 9900         	ldr	r1, [sp]
700a6794: f7fc fb04    	bl	0x700a2da0 <UART_writePolling> @ imm = #-0x39f8
700a6798: 9001         	str	r0, [sp, #0x4]
;             hUart->state = UART_STATE_READY;
700a679a: 9905         	ldr	r1, [sp, #0x14]
700a679c: 2001         	movs	r0, #0x1
700a679e: 6548         	str	r0, [r1, #0x54]
700a67a0: e7ff         	b	0x700a67a2 <UART_lld_write+0xc2> @ imm = #-0x2
;     }
700a67a2: e003         	b	0x700a67ac <UART_lld_write+0xcc> @ imm = #0x6
700a67a4: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a67a8: 9001         	str	r0, [sp, #0x4]
700a67aa: e7ff         	b	0x700a67ac <UART_lld_write+0xcc> @ imm = #-0x2
;     return status;
700a67ac: 9801         	ldr	r0, [sp, #0x4]
700a67ae: b006         	add	sp, #0x18
700a67b0: bd80         	pop	{r7, pc}
		...
700a67be: 0000         	movs	r0, r0

700a67c0 <UART_udmaDeInitCh>:
; {
700a67c0: b580         	push	{r7, lr}
700a67c2: b08c         	sub	sp, #0x30
700a67c4: 900b         	str	r0, [sp, #0x2c]
700a67c6: 910a         	str	r1, [sp, #0x28]
700a67c8: 2000         	movs	r0, #0x0
;     int32_t status = UDMA_SOK;
700a67ca: 9009         	str	r0, [sp, #0x24]
700a67cc: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a67ce: 9008         	str	r0, [sp, #0x20]
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a67d0: 980b         	ldr	r0, [sp, #0x2c]
700a67d2: 2164         	movs	r1, #0x64
700a67d4: f001 fbe4    	bl	0x700a7fa0 <Udma_chDisable> @ imm = #0x17c8
700a67d8: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a67da: 9809         	ldr	r0, [sp, #0x24]
700a67dc: fab0 f080    	clz	r0, r0
700a67e0: 0940         	lsrs	r0, r0, #0x5
700a67e2: f641 71db    	movw	r1, #0x1fdb
700a67e6: f2c7 010b    	movt	r1, #0x700b
700a67ea: 9102         	str	r1, [sp, #0x8]
700a67ec: 466a         	mov	r2, sp
700a67ee: 6011         	str	r1, [r2]
700a67f0: f641 3191    	movw	r1, #0x1b91
700a67f4: f2c7 010b    	movt	r1, #0x700b
700a67f8: 9103         	str	r1, [sp, #0xc]
700a67fa: f242 0225    	movw	r2, #0x2025
700a67fe: f2c7 020b    	movt	r2, #0x700b
700a6802: 9204         	str	r2, [sp, #0x10]
700a6804: f240 134b    	movw	r3, #0x14b
700a6808: f004 f962    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x42c4
;     status = Udma_eventUnRegister(eventHandle);
700a680c: 980a         	ldr	r0, [sp, #0x28]
700a680e: f000 fc5f    	bl	0x700a70d0 <Udma_eventUnRegister> @ imm = #0x8be
700a6812: 9b02         	ldr	r3, [sp, #0x8]
700a6814: 9903         	ldr	r1, [sp, #0xc]
700a6816: 9a04         	ldr	r2, [sp, #0x10]
700a6818: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a681a: 9809         	ldr	r0, [sp, #0x24]
700a681c: fab0 f080    	clz	r0, r0
700a6820: 0940         	lsrs	r0, r0, #0x5
700a6822: 46ec         	mov	r12, sp
700a6824: f8cc 3000    	str.w	r3, [r12]
700a6828: f240 134f    	movw	r3, #0x14f
700a682c: f004 f950    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x42a0
;     while(temp == TRUE)
700a6830: e7ff         	b	0x700a6832 <UART_udmaDeInitCh+0x72> @ imm = #-0x2
700a6832: 9808         	ldr	r0, [sp, #0x20]
700a6834: 2801         	cmp	r0, #0x1
700a6836: d10f         	bne	0x700a6858 <UART_udmaDeInitCh+0x98> @ imm = #0x1e
700a6838: e7ff         	b	0x700a683a <UART_udmaDeInitCh+0x7a> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a683a: 980b         	ldr	r0, [sp, #0x2c]
700a683c: f004 fb48    	bl	0x700aaed0 <Udma_chGetFqRingHandle> @ imm = #0x4690
700a6840: a906         	add	r1, sp, #0x18
;         tempRetVal = Udma_ringFlushRaw(
700a6842: f003 fbd5    	bl	0x700a9ff0 <Udma_ringFlushRaw> @ imm = #0x37aa
700a6846: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a6848: 9805         	ldr	r0, [sp, #0x14]
700a684a: 3004         	adds	r0, #0x4
700a684c: b918         	cbnz	r0, 0x700a6856 <UART_udmaDeInitCh+0x96> @ imm = #0x6
700a684e: e7ff         	b	0x700a6850 <UART_udmaDeInitCh+0x90> @ imm = #-0x2
700a6850: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a6852: 9008         	str	r0, [sp, #0x20]
;         }
700a6854: e7ff         	b	0x700a6856 <UART_udmaDeInitCh+0x96> @ imm = #-0x2
;     while(temp == TRUE)
700a6856: e7ec         	b	0x700a6832 <UART_udmaDeInitCh+0x72> @ imm = #-0x28
;     status = Udma_chClose(chHandle);
700a6858: 980b         	ldr	r0, [sp, #0x2c]
700a685a: f000 fd71    	bl	0x700a7340 <Udma_chClose> @ imm = #0xae2
700a685e: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a6860: 9809         	ldr	r0, [sp, #0x24]
700a6862: fab0 f080    	clz	r0, r0
700a6866: 0940         	lsrs	r0, r0, #0x5
700a6868: f641 71db    	movw	r1, #0x1fdb
700a686c: f2c7 010b    	movt	r1, #0x700b
700a6870: 466a         	mov	r2, sp
700a6872: 6011         	str	r1, [r2]
700a6874: f641 3191    	movw	r1, #0x1b91
700a6878: f2c7 010b    	movt	r1, #0x700b
700a687c: f242 0225    	movw	r2, #0x2025
700a6880: f2c7 020b    	movt	r2, #0x700b
700a6884: f240 1361    	movw	r3, #0x161
700a6888: f004 f922    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x4244
;     return status;
700a688c: 9809         	ldr	r0, [sp, #0x24]
700a688e: b00c         	add	sp, #0x30
700a6890: bd80         	pop	{r7, pc}
		...
700a689e: 0000         	movs	r0, r0

700a68a0 <vTaskSwitchContext>:
; void vTaskSwitchContext(void) {
700a68a0: b082         	sub	sp, #0x8
;   if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
700a68a2: f642 2024    	movw	r0, #0x2a24
700a68a6: f2c7 000b    	movt	r0, #0x700b
700a68aa: 6800         	ldr	r0, [r0]
700a68ac: b138         	cbz	r0, 0x700a68be <vTaskSwitchContext+0x1e> @ imm = #0xe
700a68ae: e7ff         	b	0x700a68b0 <vTaskSwitchContext+0x10> @ imm = #-0x2
;     xYieldPending = pdTRUE;
700a68b0: f642 2150    	movw	r1, #0x2a50
700a68b4: f2c7 010b    	movt	r1, #0x700b
700a68b8: 2001         	movs	r0, #0x1
700a68ba: 6008         	str	r0, [r1]
;   } else {
700a68bc: e057         	b	0x700a696e <vTaskSwitchContext+0xce> @ imm = #0xae
;     xYieldPending = pdFALSE;
700a68be: f642 2150    	movw	r1, #0x2a50
700a68c2: f2c7 010b    	movt	r1, #0x700b
700a68c6: 2000         	movs	r0, #0x0
700a68c8: 6008         	str	r0, [r1]
;       pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
700a68ca: f642 10ac    	movw	r0, #0x29ac
700a68ce: f2c7 000b    	movt	r0, #0x700b
700a68d2: 6800         	ldr	r0, [r0]
700a68d4: f642 2100    	movw	r1, #0x2a00
700a68d8: f2c7 010b    	movt	r1, #0x700b
700a68dc: 6809         	ldr	r1, [r1]
700a68de: f8c1 0084    	str.w	r0, [r1, #0x84]
;     taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this
700a68e2: f642 202c    	movw	r0, #0x2a2c
700a68e6: f2c7 000b    	movt	r0, #0x700b
700a68ea: 6800         	ldr	r0, [r0]
700a68ec: 9001         	str	r0, [sp, #0x4]
700a68ee: e7ff         	b	0x700a68f0 <vTaskSwitchContext+0x50> @ imm = #-0x2
700a68f0: 9801         	ldr	r0, [sp, #0x4]
700a68f2: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a68f6: f244 40f8    	movw	r0, #0x44f8
700a68fa: f2c7 0008    	movt	r0, #0x7008
700a68fe: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a6902: b920         	cbnz	r0, 0x700a690e <vTaskSwitchContext+0x6e> @ imm = #0x8
700a6904: e7ff         	b	0x700a6906 <vTaskSwitchContext+0x66> @ imm = #-0x2
700a6906: 9801         	ldr	r0, [sp, #0x4]
700a6908: 3801         	subs	r0, #0x1
700a690a: 9001         	str	r0, [sp, #0x4]
700a690c: e7f0         	b	0x700a68f0 <vTaskSwitchContext+0x50> @ imm = #-0x20
700a690e: 9801         	ldr	r0, [sp, #0x4]
700a6910: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a6914: f244 40f8    	movw	r0, #0x44f8
700a6918: f2c7 0008    	movt	r0, #0x7008
700a691c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a6920: 9000         	str	r0, [sp]
700a6922: 9900         	ldr	r1, [sp]
700a6924: 6848         	ldr	r0, [r1, #0x4]
700a6926: 6840         	ldr	r0, [r0, #0x4]
700a6928: 6048         	str	r0, [r1, #0x4]
700a692a: 9900         	ldr	r1, [sp]
700a692c: 6848         	ldr	r0, [r1, #0x4]
700a692e: 3108         	adds	r1, #0x8
700a6930: 4288         	cmp	r0, r1
700a6932: d105         	bne	0x700a6940 <vTaskSwitchContext+0xa0> @ imm = #0xa
700a6934: e7ff         	b	0x700a6936 <vTaskSwitchContext+0x96> @ imm = #-0x2
700a6936: 9900         	ldr	r1, [sp]
700a6938: 6848         	ldr	r0, [r1, #0x4]
700a693a: 6840         	ldr	r0, [r0, #0x4]
700a693c: 6048         	str	r0, [r1, #0x4]
700a693e: e7ff         	b	0x700a6940 <vTaskSwitchContext+0xa0> @ imm = #-0x2
700a6940: 9800         	ldr	r0, [sp]
700a6942: 6840         	ldr	r0, [r0, #0x4]
700a6944: 68c1         	ldr	r1, [r0, #0xc]
700a6946: f642 2000    	movw	r0, #0x2a00
700a694a: f2c7 000b    	movt	r0, #0x700b
700a694e: 6001         	str	r1, [r0]
700a6950: 9901         	ldr	r1, [sp, #0x4]
700a6952: f642 222c    	movw	r2, #0x2a2c
700a6956: f2c7 020b    	movt	r2, #0x700b
700a695a: 6011         	str	r1, [r2]
;       FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
700a695c: 6800         	ldr	r0, [r0]
700a695e: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a6962: f642 11ac    	movw	r1, #0x29ac
700a6966: f2c7 010b    	movt	r1, #0x700b
700a696a: 6008         	str	r0, [r1]
700a696c: e7ff         	b	0x700a696e <vTaskSwitchContext+0xce> @ imm = #-0x2
; }
700a696e: b002         	add	sp, #0x8
700a6970: 4770         	bx	lr
		...
700a697e: 0000         	movs	r0, r0

700a6980 <Udma_rmAllocVintrBit>:
; {
700a6980: b580         	push	{r7, lr}
700a6982: b08a         	sub	sp, #0x28
700a6984: 9009         	str	r0, [sp, #0x24]
700a6986: f64f 70ff    	movw	r0, #0xffff
;     uint32_t                vintrBitNum = UDMA_EVENT_INVALID;
700a698a: 9007         	str	r0, [sp, #0x1c]
;     Udma_DrvHandleInt       drvHandle = eventHandle->drvHandle;
700a698c: 9809         	ldr	r0, [sp, #0x24]
700a698e: 6800         	ldr	r0, [r0]
700a6990: 9001         	str	r0, [sp, #0x4]
;     controllerEventHandle = eventHandle;
700a6992: 9809         	ldr	r0, [sp, #0x24]
700a6994: 9003         	str	r0, [sp, #0xc]
;     eventPrms = &eventHandle->eventPrms;
700a6996: 9809         	ldr	r0, [sp, #0x24]
700a6998: 3008         	adds	r0, #0x8
700a699a: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700a699c: 9802         	ldr	r0, [sp, #0x8]
700a699e: 6900         	ldr	r0, [r0, #0x10]
700a69a0: b120         	cbz	r0, 0x700a69ac <Udma_rmAllocVintrBit+0x2c> @ imm = #0x8
700a69a2: e7ff         	b	0x700a69a4 <Udma_rmAllocVintrBit+0x24> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a69a4: 9802         	ldr	r0, [sp, #0x8]
700a69a6: 6900         	ldr	r0, [r0, #0x10]
700a69a8: 9003         	str	r0, [sp, #0xc]
;     }
700a69aa: e7ff         	b	0x700a69ac <Udma_rmAllocVintrBit+0x2c> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a69ac: 9801         	ldr	r0, [sp, #0x4]
700a69ae: f500 609f    	add.w	r0, r0, #0x4f8
700a69b2: f04f 31ff    	mov.w	r1, #0xffffffff
700a69b6: f003 fe33    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x3c66
700a69ba: 2000         	movs	r0, #0x0
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a69bc: 9008         	str	r0, [sp, #0x20]
700a69be: e7ff         	b	0x700a69c0 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x2
700a69c0: 9808         	ldr	r0, [sp, #0x20]
700a69c2: 283f         	cmp	r0, #0x3f
700a69c4: d83a         	bhi	0x700a6a3c <Udma_rmAllocVintrBit+0xbc> @ imm = #0x74
700a69c6: e7ff         	b	0x700a69c8 <Udma_rmAllocVintrBit+0x48> @ imm = #-0x2
;         bitMask = ((uint64_t) 1U << i);
700a69c8: 9b08         	ldr	r3, [sp, #0x20]
700a69ca: f1a3 0220    	sub.w	r2, r3, #0x20
700a69ce: 2101         	movs	r1, #0x1
700a69d0: fa01 fc02    	lsl.w	r12, r1, r2
700a69d4: f1c3 0020    	rsb.w	r0, r3, #0x20
700a69d8: fa21 f000    	lsr.w	r0, r1, r0
700a69dc: 2a00         	cmp	r2, #0x0
700a69de: bf58         	it	pl
700a69e0: 4660         	movpl	r0, r12
700a69e2: fa01 f103    	lsl.w	r1, r1, r3
700a69e6: 2a00         	cmp	r2, #0x0
700a69e8: bf58         	it	pl
700a69ea: 2100         	movpl	r1, #0x0
700a69ec: 9104         	str	r1, [sp, #0x10]
700a69ee: 9005         	str	r0, [sp, #0x14]
;         if((controllerEventHandle->vintrBitAllocFlag & bitMask) == 0U)
700a69f0: 9903         	ldr	r1, [sp, #0xc]
700a69f2: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a69f6: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a69fa: 9a04         	ldr	r2, [sp, #0x10]
700a69fc: 9b05         	ldr	r3, [sp, #0x14]
700a69fe: ea01 0103    	and.w	r1, r1, r3
700a6a02: ea00 0002    	and.w	r0, r0, r2
700a6a06: ea40 0001    	orr.w	r0, r0, r1
700a6a0a: b990         	cbnz	r0, 0x700a6a32 <Udma_rmAllocVintrBit+0xb2> @ imm = #0x24
700a6a0c: e7ff         	b	0x700a6a0e <Udma_rmAllocVintrBit+0x8e> @ imm = #-0x2
;             controllerEventHandle->vintrBitAllocFlag |= bitMask;
700a6a0e: f8dd c010    	ldr.w	r12, [sp, #0x10]
700a6a12: 9b05         	ldr	r3, [sp, #0x14]
700a6a14: 9903         	ldr	r1, [sp, #0xc]
700a6a16: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a6a1a: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700a6a1e: ea40 000c    	orr.w	r0, r0, r12
700a6a22: 431a         	orrs	r2, r3
700a6a24: f8c1 208c    	str.w	r2, [r1, #0x8c]
700a6a28: f8c1 0088    	str.w	r0, [r1, #0x88]
;             vintrBitNum = i;
700a6a2c: 9808         	ldr	r0, [sp, #0x20]
700a6a2e: 9007         	str	r0, [sp, #0x1c]
;             break;
700a6a30: e004         	b	0x700a6a3c <Udma_rmAllocVintrBit+0xbc> @ imm = #0x8
;     }
700a6a32: e7ff         	b	0x700a6a34 <Udma_rmAllocVintrBit+0xb4> @ imm = #-0x2
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a6a34: 9808         	ldr	r0, [sp, #0x20]
700a6a36: 3001         	adds	r0, #0x1
700a6a38: 9008         	str	r0, [sp, #0x20]
700a6a3a: e7c1         	b	0x700a69c0 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x7e
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a6a3c: 9801         	ldr	r0, [sp, #0x4]
700a6a3e: f500 609f    	add.w	r0, r0, #0x4f8
700a6a42: f005 f9b5    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x536a
;     return (vintrBitNum);
700a6a46: 9807         	ldr	r0, [sp, #0x1c]
700a6a48: b00a         	add	sp, #0x28
700a6a4a: bd80         	pop	{r7, pc}
700a6a4c: 0000         	movs	r0, r0
700a6a4e: 0000         	movs	r0, r0

700a6a50 <prvCopyDataToQueue>:
; {
700a6a50: b580         	push	{r7, lr}
700a6a52: b086         	sub	sp, #0x18
700a6a54: 9005         	str	r0, [sp, #0x14]
700a6a56: 9104         	str	r1, [sp, #0x10]
700a6a58: 9203         	str	r2, [sp, #0xc]
700a6a5a: 2000         	movs	r0, #0x0
;     BaseType_t xReturn = pdFALSE;
700a6a5c: 9002         	str	r0, [sp, #0x8]
;     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a6a5e: 9805         	ldr	r0, [sp, #0x14]
700a6a60: 6b80         	ldr	r0, [r0, #0x38]
700a6a62: 9001         	str	r0, [sp, #0x4]
;     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
700a6a64: 9805         	ldr	r0, [sp, #0x14]
700a6a66: 6c00         	ldr	r0, [r0, #0x40]
700a6a68: b978         	cbnz	r0, 0x700a6a8a <prvCopyDataToQueue+0x3a> @ imm = #0x1e
700a6a6a: e7ff         	b	0x700a6a6c <prvCopyDataToQueue+0x1c> @ imm = #-0x2
;                 if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a6a6c: 9805         	ldr	r0, [sp, #0x14]
700a6a6e: 6800         	ldr	r0, [r0]
700a6a70: b948         	cbnz	r0, 0x700a6a86 <prvCopyDataToQueue+0x36> @ imm = #0x12
700a6a72: e7ff         	b	0x700a6a74 <prvCopyDataToQueue+0x24> @ imm = #-0x2
;                     xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
700a6a74: 9805         	ldr	r0, [sp, #0x14]
700a6a76: 6880         	ldr	r0, [r0, #0x8]
700a6a78: f001 fcfa    	bl	0x700a8470 <xTaskPriorityDisinherit> @ imm = #0x19f4
700a6a7c: 9002         	str	r0, [sp, #0x8]
;                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
700a6a7e: 9905         	ldr	r1, [sp, #0x14]
700a6a80: 2000         	movs	r0, #0x0
700a6a82: 6088         	str	r0, [r1, #0x8]
;                 }
700a6a84: e000         	b	0x700a6a88 <prvCopyDataToQueue+0x38> @ imm = #0x0
700a6a86: e7ff         	b	0x700a6a88 <prvCopyDataToQueue+0x38> @ imm = #-0x2
;     }
700a6a88: e041         	b	0x700a6b0e <prvCopyDataToQueue+0xbe> @ imm = #0x82
;     else if( xPosition == queueSEND_TO_BACK )
700a6a8a: 9803         	ldr	r0, [sp, #0xc]
700a6a8c: b9b8         	cbnz	r0, 0x700a6abe <prvCopyDataToQueue+0x6e> @ imm = #0x2e
700a6a8e: e7ff         	b	0x700a6a90 <prvCopyDataToQueue+0x40> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700a6a90: 9a05         	ldr	r2, [sp, #0x14]
700a6a92: 9904         	ldr	r1, [sp, #0x10]
700a6a94: 6850         	ldr	r0, [r2, #0x4]
700a6a96: 6c12         	ldr	r2, [r2, #0x40]
700a6a98: f7f3 ea60    	blx	0x70099f5c <__aeabi_memcpy8> @ imm = #-0xcb40
;         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700a6a9c: 9905         	ldr	r1, [sp, #0x14]
700a6a9e: 6848         	ldr	r0, [r1, #0x4]
700a6aa0: 6c0a         	ldr	r2, [r1, #0x40]
700a6aa2: 4410         	add	r0, r2
700a6aa4: 6048         	str	r0, [r1, #0x4]
;         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a6aa6: 9905         	ldr	r1, [sp, #0x14]
700a6aa8: 6848         	ldr	r0, [r1, #0x4]
700a6aaa: 6889         	ldr	r1, [r1, #0x8]
700a6aac: 4288         	cmp	r0, r1
700a6aae: d304         	blo	0x700a6aba <prvCopyDataToQueue+0x6a> @ imm = #0x8
700a6ab0: e7ff         	b	0x700a6ab2 <prvCopyDataToQueue+0x62> @ imm = #-0x2
;             pxQueue->pcWriteTo = pxQueue->pcHead;
700a6ab2: 9905         	ldr	r1, [sp, #0x14]
700a6ab4: 6808         	ldr	r0, [r1]
700a6ab6: 6048         	str	r0, [r1, #0x4]
;         }
700a6ab8: e000         	b	0x700a6abc <prvCopyDataToQueue+0x6c> @ imm = #0x0
700a6aba: e7ff         	b	0x700a6abc <prvCopyDataToQueue+0x6c> @ imm = #-0x2
;     }
700a6abc: e026         	b	0x700a6b0c <prvCopyDataToQueue+0xbc> @ imm = #0x4c
;         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
700a6abe: 9a05         	ldr	r2, [sp, #0x14]
700a6ac0: 9904         	ldr	r1, [sp, #0x10]
700a6ac2: 68d0         	ldr	r0, [r2, #0xc]
700a6ac4: 6c12         	ldr	r2, [r2, #0x40]
700a6ac6: f7f3 ea4a    	blx	0x70099f5c <__aeabi_memcpy8> @ imm = #-0xcb6c
;         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
700a6aca: 9905         	ldr	r1, [sp, #0x14]
700a6acc: 68c8         	ldr	r0, [r1, #0xc]
700a6ace: 6c0a         	ldr	r2, [r1, #0x40]
700a6ad0: 1a80         	subs	r0, r0, r2
700a6ad2: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a6ad4: 9805         	ldr	r0, [sp, #0x14]
700a6ad6: 6801         	ldr	r1, [r0]
700a6ad8: 68c0         	ldr	r0, [r0, #0xc]
700a6ada: 4288         	cmp	r0, r1
700a6adc: d206         	bhs	0x700a6aec <prvCopyDataToQueue+0x9c> @ imm = #0xc
700a6ade: e7ff         	b	0x700a6ae0 <prvCopyDataToQueue+0x90> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
700a6ae0: 9905         	ldr	r1, [sp, #0x14]
700a6ae2: 6888         	ldr	r0, [r1, #0x8]
700a6ae4: 6c0a         	ldr	r2, [r1, #0x40]
700a6ae6: 1a80         	subs	r0, r0, r2
700a6ae8: 60c8         	str	r0, [r1, #0xc]
;         }
700a6aea: e000         	b	0x700a6aee <prvCopyDataToQueue+0x9e> @ imm = #0x0
700a6aec: e7ff         	b	0x700a6aee <prvCopyDataToQueue+0x9e> @ imm = #-0x2
;         if( xPosition == queueOVERWRITE )
700a6aee: 9803         	ldr	r0, [sp, #0xc]
700a6af0: 2802         	cmp	r0, #0x2
700a6af2: d109         	bne	0x700a6b08 <prvCopyDataToQueue+0xb8> @ imm = #0x12
700a6af4: e7ff         	b	0x700a6af6 <prvCopyDataToQueue+0xa6> @ imm = #-0x2
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a6af6: 9801         	ldr	r0, [sp, #0x4]
700a6af8: b120         	cbz	r0, 0x700a6b04 <prvCopyDataToQueue+0xb4> @ imm = #0x8
700a6afa: e7ff         	b	0x700a6afc <prvCopyDataToQueue+0xac> @ imm = #-0x2
;                 --uxMessagesWaiting;
700a6afc: 9801         	ldr	r0, [sp, #0x4]
700a6afe: 3801         	subs	r0, #0x1
700a6b00: 9001         	str	r0, [sp, #0x4]
;             }
700a6b02: e000         	b	0x700a6b06 <prvCopyDataToQueue+0xb6> @ imm = #0x0
700a6b04: e7ff         	b	0x700a6b06 <prvCopyDataToQueue+0xb6> @ imm = #-0x2
;         }
700a6b06: e000         	b	0x700a6b0a <prvCopyDataToQueue+0xba> @ imm = #0x0
700a6b08: e7ff         	b	0x700a6b0a <prvCopyDataToQueue+0xba> @ imm = #-0x2
700a6b0a: e7ff         	b	0x700a6b0c <prvCopyDataToQueue+0xbc> @ imm = #-0x2
700a6b0c: e7ff         	b	0x700a6b0e <prvCopyDataToQueue+0xbe> @ imm = #-0x2
;     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a6b0e: 9801         	ldr	r0, [sp, #0x4]
700a6b10: 3001         	adds	r0, #0x1
700a6b12: 9905         	ldr	r1, [sp, #0x14]
700a6b14: 6388         	str	r0, [r1, #0x38]
;     return xReturn;
700a6b16: 9802         	ldr	r0, [sp, #0x8]
700a6b18: b006         	add	sp, #0x18
700a6b1a: bd80         	pop	{r7, pc}
700a6b1c: 0000         	movs	r0, r0
700a6b1e: 0000         	movs	r0, r0

700a6b20 <CSL_bcdmaChanOpSetBurstSize>:
; {
700a6b20: b580         	push	{r7, lr}
700a6b22: b088         	sub	sp, #0x20
700a6b24: 9007         	str	r0, [sp, #0x1c]
700a6b26: 9106         	str	r1, [sp, #0x18]
700a6b28: 9205         	str	r2, [sp, #0x14]
700a6b2a: 9304         	str	r3, [sp, #0x10]
700a6b2c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a6b2e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a6b30: 9804         	ldr	r0, [sp, #0x10]
700a6b32: b920         	cbnz	r0, 0x700a6b3e <CSL_bcdmaChanOpSetBurstSize+0x1e> @ imm = #0x8
700a6b34: e7ff         	b	0x700a6b36 <CSL_bcdmaChanOpSetBurstSize+0x16> @ imm = #-0x2
700a6b36: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a6b3a: 9003         	str	r0, [sp, #0xc]
;     }
700a6b3c: e052         	b	0x700a6be4 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #0xa4
;         CSL_BcdmaChanBurstSize burstSize = *(CSL_BcdmaChanBurstSize *)pOpData;
700a6b3e: 9804         	ldr	r0, [sp, #0x10]
700a6b40: 6800         	ldr	r0, [r0]
700a6b42: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a6b44: 9806         	ldr	r0, [sp, #0x18]
700a6b46: 9001         	str	r0, [sp, #0x4]
700a6b48: b140         	cbz	r0, 0x700a6b5c <CSL_bcdmaChanOpSetBurstSize+0x3c> @ imm = #0x10
700a6b4a: e7ff         	b	0x700a6b4c <CSL_bcdmaChanOpSetBurstSize+0x2c> @ imm = #-0x2
700a6b4c: 9801         	ldr	r0, [sp, #0x4]
700a6b4e: 2801         	cmp	r0, #0x1
700a6b50: d019         	beq	0x700a6b86 <CSL_bcdmaChanOpSetBurstSize+0x66> @ imm = #0x32
700a6b52: e7ff         	b	0x700a6b54 <CSL_bcdmaChanOpSetBurstSize+0x34> @ imm = #-0x2
700a6b54: 9801         	ldr	r0, [sp, #0x4]
700a6b56: 2802         	cmp	r0, #0x2
700a6b58: d02a         	beq	0x700a6bb0 <CSL_bcdmaChanOpSetBurstSize+0x90> @ imm = #0x54
700a6b5a: e03e         	b	0x700a6bda <CSL_bcdmaChanOpSetBurstSize+0xba> @ imm = #0x7c
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES )   /* Block-copy supports 32, 64, and 128-byte bursts */
700a6b5c: 9802         	ldr	r0, [sp, #0x8]
700a6b5e: 2803         	cmp	r0, #0x3
700a6b60: d304         	blo	0x700a6b6c <CSL_bcdmaChanOpSetBurstSize+0x4c> @ imm = #0x8
700a6b62: e7ff         	b	0x700a6b64 <CSL_bcdmaChanOpSetBurstSize+0x44> @ imm = #-0x2
700a6b64: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6b68: 9003         	str	r0, [sp, #0xc]
;                 }
700a6b6a: e00b         	b	0x700a6b84 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, burstSize );
700a6b6c: 9807         	ldr	r0, [sp, #0x1c]
700a6b6e: 6840         	ldr	r0, [r0, #0x4]
700a6b70: 9905         	ldr	r1, [sp, #0x14]
700a6b72: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6b76: 9b02         	ldr	r3, [sp, #0x8]
700a6b78: f44f 6140    	mov.w	r1, #0xc00
700a6b7c: 220a         	movs	r2, #0xa
700a6b7e: f007 fb27    	bl	0x700ae1d0 <CSL_REG32_FINS_RAW> @ imm = #0x764e
700a6b82: e7ff         	b	0x700a6b84 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #-0x2
;                 break;
700a6b84: e02d         	b	0x700a6be2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x5a
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-tx supports 32, and 64-byte bursts */
700a6b86: 9802         	ldr	r0, [sp, #0x8]
700a6b88: 2802         	cmp	r0, #0x2
700a6b8a: d304         	blo	0x700a6b96 <CSL_bcdmaChanOpSetBurstSize+0x76> @ imm = #0x8
700a6b8c: e7ff         	b	0x700a6b8e <CSL_bcdmaChanOpSetBurstSize+0x6e> @ imm = #-0x2
700a6b8e: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6b92: 9003         	str	r0, [sp, #0xc]
;                 }
700a6b94: e00b         	b	0x700a6bae <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, burstSize );
700a6b96: 9807         	ldr	r0, [sp, #0x1c]
700a6b98: 68c0         	ldr	r0, [r0, #0xc]
700a6b9a: 9905         	ldr	r1, [sp, #0x14]
700a6b9c: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6ba0: 9b02         	ldr	r3, [sp, #0x8]
700a6ba2: f44f 6140    	mov.w	r1, #0xc00
700a6ba6: 220a         	movs	r2, #0xa
700a6ba8: f007 fb12    	bl	0x700ae1d0 <CSL_REG32_FINS_RAW> @ imm = #0x7624
700a6bac: e7ff         	b	0x700a6bae <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #-0x2
;                 break;
700a6bae: e018         	b	0x700a6be2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x30
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-rx supports 32, and 64-byte bursts */
700a6bb0: 9802         	ldr	r0, [sp, #0x8]
700a6bb2: 2802         	cmp	r0, #0x2
700a6bb4: d304         	blo	0x700a6bc0 <CSL_bcdmaChanOpSetBurstSize+0xa0> @ imm = #0x8
700a6bb6: e7ff         	b	0x700a6bb8 <CSL_bcdmaChanOpSetBurstSize+0x98> @ imm = #-0x2
700a6bb8: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6bbc: 9003         	str	r0, [sp, #0xc]
;                 }
700a6bbe: e00b         	b	0x700a6bd8 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, burstSize );
700a6bc0: 9807         	ldr	r0, [sp, #0x1c]
700a6bc2: 6940         	ldr	r0, [r0, #0x14]
700a6bc4: 9905         	ldr	r1, [sp, #0x14]
700a6bc6: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6bca: 9b02         	ldr	r3, [sp, #0x8]
700a6bcc: f44f 6140    	mov.w	r1, #0xc00
700a6bd0: 220a         	movs	r2, #0xa
700a6bd2: f007 fafd    	bl	0x700ae1d0 <CSL_REG32_FINS_RAW> @ imm = #0x75fa
700a6bd6: e7ff         	b	0x700a6bd8 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #-0x2
;                 break;
700a6bd8: e003         	b	0x700a6be2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x6
700a6bda: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a6bde: 9003         	str	r0, [sp, #0xc]
;                 break;
700a6be0: e7ff         	b	0x700a6be2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #-0x2
700a6be2: e7ff         	b	0x700a6be4 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #-0x2
;     return retVal;
700a6be4: 9803         	ldr	r0, [sp, #0xc]
700a6be6: b008         	add	sp, #0x20
700a6be8: bd80         	pop	{r7, pc}
700a6bea: 0000         	movs	r0, r0
700a6bec: 0000         	movs	r0, r0
700a6bee: 0000         	movs	r0, r0

700a6bf0 <Udma_ringCheckParams>:
; {
700a6bf0: b580         	push	{r7, lr}
700a6bf2: b084         	sub	sp, #0x10
700a6bf4: 9003         	str	r0, [sp, #0xc]
700a6bf6: 9102         	str	r1, [sp, #0x8]
700a6bf8: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a6bfa: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR == ringPrms->ringMem)
700a6bfc: 9802         	ldr	r0, [sp, #0x8]
700a6bfe: 6800         	ldr	r0, [r0]
700a6c00: b920         	cbnz	r0, 0x700a6c0c <Udma_ringCheckParams+0x1c> @ imm = #0x8
700a6c02: e7ff         	b	0x700a6c04 <Udma_ringCheckParams+0x14> @ imm = #-0x2
700a6c04: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6c08: 9001         	str	r0, [sp, #0x4]
;     }
700a6c0a: e009         	b	0x700a6c20 <Udma_ringCheckParams+0x30> @ imm = #0x12
;         if(((uintptr_t)ringPrms->ringMem & (UDMA_CACHELINE_ALIGNMENT - 1U)) != 0U)
700a6c0c: 9802         	ldr	r0, [sp, #0x8]
700a6c0e: 7800         	ldrb	r0, [r0]
700a6c10: 0640         	lsls	r0, r0, #0x19
700a6c12: b120         	cbz	r0, 0x700a6c1e <Udma_ringCheckParams+0x2e> @ imm = #0x8
700a6c14: e7ff         	b	0x700a6c16 <Udma_ringCheckParams+0x26> @ imm = #-0x2
700a6c16: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a6c1a: 9001         	str	r0, [sp, #0x4]
;         }
700a6c1c: e7ff         	b	0x700a6c1e <Udma_ringCheckParams+0x2e> @ imm = #-0x2
700a6c1e: e7ff         	b	0x700a6c20 <Udma_ringCheckParams+0x30> @ imm = #-0x2
;     if(0U == ringPrms->elemCnt)
700a6c20: 9802         	ldr	r0, [sp, #0x8]
700a6c22: 68c0         	ldr	r0, [r0, #0xc]
700a6c24: b920         	cbnz	r0, 0x700a6c30 <Udma_ringCheckParams+0x40> @ imm = #0x8
700a6c26: e7ff         	b	0x700a6c28 <Udma_ringCheckParams+0x38> @ imm = #-0x2
700a6c28: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6c2c: 9001         	str	r0, [sp, #0x4]
;     }
700a6c2e: e7ff         	b	0x700a6c30 <Udma_ringCheckParams+0x40> @ imm = #-0x2
;     if(UDMA_INST_TYPE_NORMAL != drvHandle->instType)
700a6c30: 9803         	ldr	r0, [sp, #0xc]
700a6c32: 6800         	ldr	r0, [r0]
700a6c34: b148         	cbz	r0, 0x700a6c4a <Udma_ringCheckParams+0x5a> @ imm = #0x12
700a6c36: e7ff         	b	0x700a6c38 <Udma_ringCheckParams+0x48> @ imm = #-0x2
;         if(TISCI_MSG_VALUE_RM_RING_MODE_RING != ringPrms->mode)
700a6c38: 9802         	ldr	r0, [sp, #0x8]
700a6c3a: 7a00         	ldrb	r0, [r0, #0x8]
700a6c3c: b120         	cbz	r0, 0x700a6c48 <Udma_ringCheckParams+0x58> @ imm = #0x8
700a6c3e: e7ff         	b	0x700a6c40 <Udma_ringCheckParams+0x50> @ imm = #-0x2
700a6c40: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a6c44: 9001         	str	r0, [sp, #0x4]
;         }
700a6c46: e7ff         	b	0x700a6c48 <Udma_ringCheckParams+0x58> @ imm = #-0x2
;     }
700a6c48: e7ff         	b	0x700a6c4a <Udma_ringCheckParams+0x5a> @ imm = #-0x2
;     if(UDMA_RING_SIZE_CHECK_SKIP != ringPrms->ringMemSize)
700a6c4a: 9802         	ldr	r0, [sp, #0x8]
700a6c4c: 6840         	ldr	r0, [r0, #0x4]
700a6c4e: f64a 31cd    	movw	r1, #0xabcd
700a6c52: f6ca 31dc    	movt	r1, #0xabdc
700a6c56: 4288         	cmp	r0, r1
700a6c58: d012         	beq	0x700a6c80 <Udma_ringCheckParams+0x90> @ imm = #0x24
700a6c5a: e7ff         	b	0x700a6c5c <Udma_ringCheckParams+0x6c> @ imm = #-0x2
;                           ringPrms->mode,
700a6c5c: 9a02         	ldr	r2, [sp, #0x8]
700a6c5e: 7a10         	ldrb	r0, [r2, #0x8]
;                           ringPrms->elemCnt,
700a6c60: 68d1         	ldr	r1, [r2, #0xc]
;                           ringPrms->elemSize);
700a6c62: 7c12         	ldrb	r2, [r2, #0x10]
;         ringMemSize = UdmaUtils_getRingMemSize(
700a6c64: f006 fee4    	bl	0x700ada30 <UdmaUtils_getRingMemSize> @ imm = #0x6dc8
700a6c68: 9000         	str	r0, [sp]
;         if(ringPrms->ringMemSize < ringMemSize)
700a6c6a: 9802         	ldr	r0, [sp, #0x8]
700a6c6c: 6840         	ldr	r0, [r0, #0x4]
700a6c6e: 9900         	ldr	r1, [sp]
700a6c70: 4288         	cmp	r0, r1
700a6c72: d204         	bhs	0x700a6c7e <Udma_ringCheckParams+0x8e> @ imm = #0x8
700a6c74: e7ff         	b	0x700a6c76 <Udma_ringCheckParams+0x86> @ imm = #-0x2
700a6c76: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
700a6c7a: 9001         	str	r0, [sp, #0x4]
;         }
700a6c7c: e7ff         	b	0x700a6c7e <Udma_ringCheckParams+0x8e> @ imm = #-0x2
;     }
700a6c7e: e7ff         	b	0x700a6c80 <Udma_ringCheckParams+0x90> @ imm = #-0x2
;     if (UDMA_RING_ORDERID_MAX < ringPrms->orderId)
700a6c80: 9802         	ldr	r0, [sp, #0x8]
700a6c82: 7c40         	ldrb	r0, [r0, #0x11]
700a6c84: 2810         	cmp	r0, #0x10
700a6c86: d304         	blo	0x700a6c92 <Udma_ringCheckParams+0xa2> @ imm = #0x8
700a6c88: e7ff         	b	0x700a6c8a <Udma_ringCheckParams+0x9a> @ imm = #-0x2
700a6c8a: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6c8e: 9001         	str	r0, [sp, #0x4]
;     }
700a6c90: e7ff         	b	0x700a6c92 <Udma_ringCheckParams+0xa2> @ imm = #-0x2
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a6c92: 9802         	ldr	r0, [sp, #0x8]
700a6c94: 6940         	ldr	r0, [r0, #0x14]
700a6c96: 2104         	movs	r1, #0x4
700a6c98: f6cf 71ff    	movt	r1, #0xffff
700a6c9c: 4288         	cmp	r0, r1
700a6c9e: d009         	beq	0x700a6cb4 <Udma_ringCheckParams+0xc4> @ imm = #0x12
700a6ca0: e7ff         	b	0x700a6ca2 <Udma_ringCheckParams+0xb2> @ imm = #-0x2
;        (ringPrms->mappedRingGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a6ca2: 9802         	ldr	r0, [sp, #0x8]
700a6ca4: 6940         	ldr	r0, [r0, #0x14]
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a6ca6: 2808         	cmp	r0, #0x8
700a6ca8: d304         	blo	0x700a6cb4 <Udma_ringCheckParams+0xc4> @ imm = #0x8
700a6caa: e7ff         	b	0x700a6cac <Udma_ringCheckParams+0xbc> @ imm = #-0x2
700a6cac: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6cb0: 9001         	str	r0, [sp, #0x4]
;     }
700a6cb2: e7ff         	b	0x700a6cb4 <Udma_ringCheckParams+0xc4> @ imm = #-0x2
;     return (retVal);
700a6cb4: 9801         	ldr	r0, [sp, #0x4]
700a6cb6: b004         	add	sp, #0x10
700a6cb8: bd80         	pop	{r7, pc}
700a6cba: 0000         	movs	r0, r0
700a6cbc: 0000         	movs	r0, r0
700a6cbe: 0000         	movs	r0, r0

700a6cc0 <UART_lld_writeDma>:
; {
700a6cc0: b580         	push	{r7, lr}
700a6cc2: b086         	sub	sp, #0x18
700a6cc4: 9005         	str	r0, [sp, #0x14]
700a6cc6: 9104         	str	r1, [sp, #0x10]
700a6cc8: 9203         	str	r2, [sp, #0xc]
700a6cca: 9302         	str	r3, [sp, #0x8]
700a6ccc: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a6cce: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a6cd0: 9805         	ldr	r0, [sp, #0x14]
700a6cd2: 2800         	cmp	r0, #0x0
700a6cd4: d051         	beq	0x700a6d7a <UART_lld_writeDma+0xba> @ imm = #0xa2
700a6cd6: e7ff         	b	0x700a6cd8 <UART_lld_writeDma+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a6cd8: 9805         	ldr	r0, [sp, #0x14]
700a6cda: 303c         	adds	r0, #0x3c
700a6cdc: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a6cde: 9800         	ldr	r0, [sp]
700a6ce0: 6800         	ldr	r0, [r0]
700a6ce2: b138         	cbz	r0, 0x700a6cf4 <UART_lld_writeDma+0x34> @ imm = #0xe
700a6ce4: e7ff         	b	0x700a6ce6 <UART_lld_writeDma+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a6ce6: 9900         	ldr	r1, [sp]
700a6ce8: 2009         	movs	r0, #0x9
700a6cea: 60c8         	str	r0, [r1, #0xc]
700a6cec: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a6cf0: 9001         	str	r0, [sp, #0x4]
;         }
700a6cf2: e041         	b	0x700a6d78 <UART_lld_writeDma+0xb8> @ imm = #0x82
;             UART_lld_Transaction_init(trans);
700a6cf4: 9800         	ldr	r0, [sp]
700a6cf6: f008 f80b    	bl	0x700aed10 <UART_lld_Transaction_init> @ imm = #0x8016
;             if(extendedParams != NULL)
700a6cfa: 9802         	ldr	r0, [sp, #0x8]
700a6cfc: b128         	cbz	r0, 0x700a6d0a <UART_lld_writeDma+0x4a> @ imm = #0xa
700a6cfe: e7ff         	b	0x700a6d00 <UART_lld_writeDma+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a6d00: 9802         	ldr	r0, [sp, #0x8]
700a6d02: 6800         	ldr	r0, [r0]
700a6d04: 9900         	ldr	r1, [sp]
700a6d06: 6108         	str	r0, [r1, #0x10]
;             }
700a6d08: e003         	b	0x700a6d12 <UART_lld_writeDma+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a6d0a: 9900         	ldr	r1, [sp]
700a6d0c: 2000         	movs	r0, #0x0
700a6d0e: 6108         	str	r0, [r1, #0x10]
700a6d10: e7ff         	b	0x700a6d12 <UART_lld_writeDma+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a6d12: 9804         	ldr	r0, [sp, #0x10]
700a6d14: 9900         	ldr	r1, [sp]
700a6d16: 6008         	str	r0, [r1]
;             trans->count = size;
700a6d18: 9803         	ldr	r0, [sp, #0xc]
700a6d1a: 9900         	ldr	r1, [sp]
700a6d1c: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a6d1e: 9805         	ldr	r0, [sp, #0x14]
700a6d20: 6d40         	ldr	r0, [r0, #0x54]
700a6d22: 2801         	cmp	r0, #0x1
700a6d24: d105         	bne	0x700a6d32 <UART_lld_writeDma+0x72> @ imm = #0xa
700a6d26: e7ff         	b	0x700a6d28 <UART_lld_writeDma+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a6d28: 9800         	ldr	r0, [sp]
700a6d2a: f007 fbf1    	bl	0x700ae510 <UART_checkTransaction> @ imm = #0x77e2
700a6d2e: 9001         	str	r0, [sp, #0x4]
;             }
700a6d30: e003         	b	0x700a6d3a <UART_lld_writeDma+0x7a> @ imm = #0x6
700a6d32: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a6d36: 9001         	str	r0, [sp, #0x4]
700a6d38: e7ff         	b	0x700a6d3a <UART_lld_writeDma+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a6d3a: 9801         	ldr	r0, [sp, #0x4]
700a6d3c: b9d8         	cbnz	r0, 0x700a6d76 <UART_lld_writeDma+0xb6> @ imm = #0x36
700a6d3e: e7ff         	b	0x700a6d40 <UART_lld_writeDma+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a6d40: 9800         	ldr	r0, [sp]
700a6d42: 6800         	ldr	r0, [r0]
700a6d44: 9905         	ldr	r1, [sp, #0x14]
700a6d46: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a6d48: 9800         	ldr	r0, [sp]
700a6d4a: 6880         	ldr	r0, [r0, #0x8]
700a6d4c: 9905         	ldr	r1, [sp, #0x14]
700a6d4e: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a6d50: 9905         	ldr	r1, [sp, #0x14]
700a6d52: 2000         	movs	r0, #0x0
700a6d54: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a6d56: 9800         	ldr	r0, [sp]
700a6d58: 6840         	ldr	r0, [r0, #0x4]
700a6d5a: 9905         	ldr	r1, [sp, #0x14]
700a6d5c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a6d5e: 9905         	ldr	r1, [sp, #0x14]
700a6d60: 2002         	movs	r0, #0x2
700a6d62: 6548         	str	r0, [r1, #0x54]
;                 status = UART_lld_dmaWrite(hUart, trans);
700a6d64: 9805         	ldr	r0, [sp, #0x14]
700a6d66: 9900         	ldr	r1, [sp]
700a6d68: f007 ffea    	bl	0x700aed40 <UART_lld_dmaWrite> @ imm = #0x7fd4
700a6d6c: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a6d6e: 9905         	ldr	r1, [sp, #0x14]
700a6d70: 2001         	movs	r0, #0x1
700a6d72: 6548         	str	r0, [r1, #0x54]
;             }
700a6d74: e7ff         	b	0x700a6d76 <UART_lld_writeDma+0xb6> @ imm = #-0x2
700a6d76: e7ff         	b	0x700a6d78 <UART_lld_writeDma+0xb8> @ imm = #-0x2
;     }
700a6d78: e003         	b	0x700a6d82 <UART_lld_writeDma+0xc2> @ imm = #0x6
700a6d7a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a6d7e: 9001         	str	r0, [sp, #0x4]
700a6d80: e7ff         	b	0x700a6d82 <UART_lld_writeDma+0xc2> @ imm = #-0x2
;     return status;
700a6d82: 9801         	ldr	r0, [sp, #0x4]
700a6d84: b006         	add	sp, #0x18
700a6d86: bd80         	pop	{r7, pc}
		...

700a6d90 <UART_udmaHpdInit>:
; {
700a6d90: b580         	push	{r7, lr}
700a6d92: b08a         	sub	sp, #0x28
700a6d94: 9009         	str	r0, [sp, #0x24]
700a6d96: 9108         	str	r1, [sp, #0x20]
700a6d98: 9207         	str	r2, [sp, #0x1c]
700a6d9a: 9306         	str	r3, [sp, #0x18]
;     CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700a6d9c: 9808         	ldr	r0, [sp, #0x20]
700a6d9e: 9005         	str	r0, [sp, #0x14]
700a6da0: 2001         	movs	r0, #0x1
;     uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700a6da2: 9004         	str	r0, [sp, #0x10]
;     CSL_udmapCppi5SetDescType(pHpd, descType);
700a6da4: 9805         	ldr	r0, [sp, #0x14]
700a6da6: 9904         	ldr	r1, [sp, #0x10]
700a6da8: f008 fc0a    	bl	0x700af5c0 <CSL_udmapCppi5SetDescType> @ imm = #0x8814
;     CSL_udmapCppi5SetEpiDataPresent(pHpd, FALSE);
700a6dac: 9805         	ldr	r0, [sp, #0x14]
700a6dae: 2100         	movs	r1, #0x0
700a6db0: 9102         	str	r1, [sp, #0x8]
700a6db2: f008 fae5    	bl	0x700af380 <CSL_udmapCppi5SetEpiDataPresent> @ imm = #0x85ca
700a6db6: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLoc(pHpd, 0U);
700a6db8: 9805         	ldr	r0, [sp, #0x14]
700a6dba: f008 fd19    	bl	0x700af7f0 <CSL_udmapCppi5SetPsDataLoc> @ imm = #0x8a32
700a6dbe: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLen(pHpd, 0U);
700a6dc0: 9805         	ldr	r0, [sp, #0x14]
700a6dc2: f008 fc2d    	bl	0x700af620 <CSL_udmapCppi5SetPsDataLen> @ imm = #0x885a
;     CSL_udmapCppi5SetPktLen(pHpd, descType, length);
700a6dc6: 9805         	ldr	r0, [sp, #0x14]
700a6dc8: 9904         	ldr	r1, [sp, #0x10]
700a6dca: 9a06         	ldr	r2, [sp, #0x18]
700a6dcc: f006 fdb8    	bl	0x700ad940 <CSL_udmapCppi5SetPktLen> @ imm = #0x6b70
700a6dd0: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsFlags(pHpd, 0U);
700a6dd2: 9805         	ldr	r0, [sp, #0x14]
700a6dd4: f008 fd1c    	bl	0x700af810 <CSL_udmapCppi5SetPsFlags> @ imm = #0x8a38
;     CSL_udmapCppi5SetIds(pHpd, descType, 0x321, UDMA_DEFAULT_FLOW_ID);
700a6dd8: 9805         	ldr	r0, [sp, #0x14]
700a6dda: 9904         	ldr	r1, [sp, #0x10]
700a6ddc: f240 3221    	movw	r2, #0x321
700a6de0: f643 73ff    	movw	r3, #0x3fff
700a6de4: f004 fdec    	bl	0x700ab9c0 <CSL_udmapCppi5SetIds> @ imm = #0x4bd8
700a6de8: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetSrcTag(pHpd, 0x0000);     /* Not used */
700a6dea: 9805         	ldr	r0, [sp, #0x14]
700a6dec: f008 fdd0    	bl	0x700af990 <CSL_udmapCppi5SetSrcTag> @ imm = #0x8ba0
700a6df0: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetDstTag(pHpd, 0x0000);     /* Not used */
700a6df2: 9805         	ldr	r0, [sp, #0x14]
700a6df4: f008 fe74    	bl	0x700afae0 <CSL_udmapCppi5SetDstTag> @ imm = #0x8ce8
;     UART_udmapSetReturnPolicy(chHandle, pHpdMem);
700a6df8: 9809         	ldr	r0, [sp, #0x24]
700a6dfa: 9908         	ldr	r1, [sp, #0x20]
700a6dfc: f008 f860    	bl	0x700aeec0 <UART_udmapSetReturnPolicy> @ imm = #0x80c0
700a6e00: 9b02         	ldr	r3, [sp, #0x8]
;     CSL_udmapCppi5LinkDesc(pHpd, 0U);
700a6e02: 9805         	ldr	r0, [sp, #0x14]
700a6e04: 461a         	mov	r2, r3
700a6e06: f008 fcb3    	bl	0x700af770 <CSL_udmapCppi5LinkDesc> @ imm = #0x8966
700a6e0a: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a6e0c: 9805         	ldr	r0, [sp, #0x14]
700a6e0e: 9001         	str	r0, [sp, #0x4]
700a6e10: 9807         	ldr	r0, [sp, #0x1c]
700a6e12: 4611         	mov	r1, r2
700a6e14: f008 fe9c    	bl	0x700afb50 <Udma_defaultVirtToPhyFxn> @ imm = #0x8d38
700a6e18: 4602         	mov	r2, r0
700a6e1a: 9801         	ldr	r0, [sp, #0x4]
700a6e1c: 460b         	mov	r3, r1
700a6e1e: f008 fcb7    	bl	0x700af790 <CSL_udmapCppi5SetBufferAddr> @ imm = #0x896e
;     CSL_udmapCppi5SetBufferLen(pHpd, length);
700a6e22: 9805         	ldr	r0, [sp, #0x14]
700a6e24: 9906         	ldr	r1, [sp, #0x18]
700a6e26: f008 fcc3    	bl	0x700af7b0 <CSL_udmapCppi5SetBufferLen> @ imm = #0x8986
700a6e2a: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetOrgBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a6e2c: 9805         	ldr	r0, [sp, #0x14]
700a6e2e: 9003         	str	r0, [sp, #0xc]
700a6e30: 9807         	ldr	r0, [sp, #0x1c]
700a6e32: 4611         	mov	r1, r2
700a6e34: f008 fe8c    	bl	0x700afb50 <Udma_defaultVirtToPhyFxn> @ imm = #0x8d18
700a6e38: 4602         	mov	r2, r0
700a6e3a: 9803         	ldr	r0, [sp, #0xc]
700a6e3c: 460b         	mov	r3, r1
700a6e3e: f008 fcc7    	bl	0x700af7d0 <CSL_udmapCppi5SetOrgBufferAddr> @ imm = #0x898e
;     CSL_udmapCppi5SetOrgBufferLen(pHpd, length);
700a6e42: 9805         	ldr	r0, [sp, #0x14]
700a6e44: 9906         	ldr	r1, [sp, #0x18]
700a6e46: f008 fe53    	bl	0x700afaf0 <CSL_udmapCppi5SetOrgBufferLen> @ imm = #0x8ca6
;     CacheP_wb(pHpdMem, sizeof(CSL_UdmapCppi5HMPD), CacheP_TYPE_ALLD);
700a6e4a: 9808         	ldr	r0, [sp, #0x20]
700a6e4c: 2130         	movs	r1, #0x30
700a6e4e: 220a         	movs	r2, #0xa
700a6e50: f009 ee40    	blx	0x700b0ad4 <CacheP_wb>  @ imm = #0x9c80
;     return;
700a6e54: b00a         	add	sp, #0x28
700a6e56: bd80         	pop	{r7, pc}
		...

700a6e60 <Udma_eventCheckUnRegister>:
; {
700a6e60: b580         	push	{r7, lr}
700a6e62: b088         	sub	sp, #0x20
700a6e64: 9007         	str	r0, [sp, #0x1c]
700a6e66: 9106         	str	r1, [sp, #0x18]
700a6e68: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a6e6a: 9005         	str	r0, [sp, #0x14]
;     eventPrms = &eventHandle->eventPrms;
700a6e6c: 9806         	ldr	r0, [sp, #0x18]
700a6e6e: 3008         	adds	r0, #0x8
700a6e70: 9004         	str	r0, [sp, #0x10]
;     if(eventHandle->eventInitDone != UDMA_INIT_DONE)
700a6e72: 9806         	ldr	r0, [sp, #0x18]
700a6e74: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700a6e78: f64a 31cd    	movw	r1, #0xabcd
700a6e7c: f6ca 31dc    	movt	r1, #0xabdc
700a6e80: 4288         	cmp	r0, r1
700a6e82: d004         	beq	0x700a6e8e <Udma_eventCheckUnRegister+0x2e> @ imm = #0x8
700a6e84: e7ff         	b	0x700a6e86 <Udma_eventCheckUnRegister+0x26> @ imm = #-0x2
700a6e86: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = UDMA_EFAIL;
700a6e8a: 9005         	str	r0, [sp, #0x14]
;     }
700a6e8c: e7ff         	b	0x700a6e8e <Udma_eventCheckUnRegister+0x2e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6e8e: 9805         	ldr	r0, [sp, #0x14]
700a6e90: b968         	cbnz	r0, 0x700a6eae <Udma_eventCheckUnRegister+0x4e> @ imm = #0x1a
700a6e92: e7ff         	b	0x700a6e94 <Udma_eventCheckUnRegister+0x34> @ imm = #-0x2
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a6e94: 9804         	ldr	r0, [sp, #0x10]
700a6e96: 6900         	ldr	r0, [r0, #0x10]
700a6e98: b940         	cbnz	r0, 0x700a6eac <Udma_eventCheckUnRegister+0x4c> @ imm = #0x10
700a6e9a: e7ff         	b	0x700a6e9c <Udma_eventCheckUnRegister+0x3c> @ imm = #-0x2
;            (NULL_PTR != eventHandle->nextEvent))
700a6e9c: 9806         	ldr	r0, [sp, #0x18]
700a6e9e: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a6ea0: b120         	cbz	r0, 0x700a6eac <Udma_eventCheckUnRegister+0x4c> @ imm = #0x8
700a6ea2: e7ff         	b	0x700a6ea4 <Udma_eventCheckUnRegister+0x44> @ imm = #-0x2
700a6ea4: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a6ea8: 9005         	str	r0, [sp, #0x14]
;         }
700a6eaa: e7ff         	b	0x700a6eac <Udma_eventCheckUnRegister+0x4c> @ imm = #-0x2
;     }
700a6eac: e7ff         	b	0x700a6eae <Udma_eventCheckUnRegister+0x4e> @ imm = #-0x2
;      if(UDMA_SOK == retVal)
700a6eae: 9805         	ldr	r0, [sp, #0x14]
700a6eb0: bbb8         	cbnz	r0, 0x700a6f22 <Udma_eventCheckUnRegister+0xc2> @ imm = #0x6e
700a6eb2: e7ff         	b	0x700a6eb4 <Udma_eventCheckUnRegister+0x54> @ imm = #-0x2
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a6eb4: 9804         	ldr	r0, [sp, #0x10]
700a6eb6: 6800         	ldr	r0, [r0]
700a6eb8: 2801         	cmp	r0, #0x1
700a6eba: d00a         	beq	0x700a6ed2 <Udma_eventCheckUnRegister+0x72> @ imm = #0x14
700a6ebc: e7ff         	b	0x700a6ebe <Udma_eventCheckUnRegister+0x5e> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a6ebe: 9804         	ldr	r0, [sp, #0x10]
700a6ec0: 6800         	ldr	r0, [r0]
700a6ec2: 2806         	cmp	r0, #0x6
700a6ec4: d005         	beq	0x700a6ed2 <Udma_eventCheckUnRegister+0x72> @ imm = #0xa
700a6ec6: e7ff         	b	0x700a6ec8 <Udma_eventCheckUnRegister+0x68> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_RING == eventPrms->eventType))
700a6ec8: 9804         	ldr	r0, [sp, #0x10]
700a6eca: 6800         	ldr	r0, [r0]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a6ecc: 2804         	cmp	r0, #0x4
700a6ece: d127         	bne	0x700a6f20 <Udma_eventCheckUnRegister+0xc0> @ imm = #0x4e
700a6ed0: e7ff         	b	0x700a6ed2 <Udma_eventCheckUnRegister+0x72> @ imm = #-0x2
;             if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a6ed2: 9804         	ldr	r0, [sp, #0x10]
700a6ed4: 6800         	ldr	r0, [r0]
700a6ed6: 2801         	cmp	r0, #0x1
700a6ed8: d005         	beq	0x700a6ee6 <Udma_eventCheckUnRegister+0x86> @ imm = #0xa
700a6eda: e7ff         	b	0x700a6edc <Udma_eventCheckUnRegister+0x7c> @ imm = #-0x2
700a6edc: 9804         	ldr	r0, [sp, #0x10]
700a6ede: 6800         	ldr	r0, [r0]
700a6ee0: 2806         	cmp	r0, #0x6
700a6ee2: d106         	bne	0x700a6ef2 <Udma_eventCheckUnRegister+0x92> @ imm = #0xc
700a6ee4: e7ff         	b	0x700a6ee6 <Udma_eventCheckUnRegister+0x86> @ imm = #-0x2
;                 ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a6ee6: 9804         	ldr	r0, [sp, #0x10]
700a6ee8: 6880         	ldr	r0, [r0, #0x8]
700a6eea: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a6eee: 9003         	str	r0, [sp, #0xc]
;             }
700a6ef0: e003         	b	0x700a6efa <Udma_eventCheckUnRegister+0x9a> @ imm = #0x6
;                 ringHandle = eventPrms->ringHandle;
700a6ef2: 9804         	ldr	r0, [sp, #0x10]
700a6ef4: 68c0         	ldr	r0, [r0, #0xc]
700a6ef6: 9003         	str	r0, [sp, #0xc]
700a6ef8: e7ff         	b	0x700a6efa <Udma_eventCheckUnRegister+0x9a> @ imm = #-0x2
;             fOcc = Udma_ringGetForwardRingOcc(ringHandle);
700a6efa: 9803         	ldr	r0, [sp, #0xc]
700a6efc: f007 fff8    	bl	0x700aeef0 <Udma_ringGetForwardRingOcc> @ imm = #0x7ff0
700a6f00: 9002         	str	r0, [sp, #0x8]
;             rOcc = Udma_ringGetReverseRingOcc(ringHandle);
700a6f02: 9803         	ldr	r0, [sp, #0xc]
700a6f04: f008 f80c    	bl	0x700aef20 <Udma_ringGetReverseRingOcc> @ imm = #0x8018
700a6f08: 9001         	str	r0, [sp, #0x4]
;             if((0U != fOcc) || (0U != rOcc))
700a6f0a: 9802         	ldr	r0, [sp, #0x8]
700a6f0c: b918         	cbnz	r0, 0x700a6f16 <Udma_eventCheckUnRegister+0xb6> @ imm = #0x6
700a6f0e: e7ff         	b	0x700a6f10 <Udma_eventCheckUnRegister+0xb0> @ imm = #-0x2
700a6f10: 9801         	ldr	r0, [sp, #0x4]
700a6f12: b120         	cbz	r0, 0x700a6f1e <Udma_eventCheckUnRegister+0xbe> @ imm = #0x8
700a6f14: e7ff         	b	0x700a6f16 <Udma_eventCheckUnRegister+0xb6> @ imm = #-0x2
700a6f16: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = UDMA_EFAIL;
700a6f1a: 9005         	str	r0, [sp, #0x14]
;             }
700a6f1c: e7ff         	b	0x700a6f1e <Udma_eventCheckUnRegister+0xbe> @ imm = #-0x2
;         }
700a6f1e: e7ff         	b	0x700a6f20 <Udma_eventCheckUnRegister+0xc0> @ imm = #-0x2
;     }
700a6f20: e7ff         	b	0x700a6f22 <Udma_eventCheckUnRegister+0xc2> @ imm = #-0x2
;     return (retVal);
700a6f22: 9805         	ldr	r0, [sp, #0x14]
700a6f24: b008         	add	sp, #0x20
700a6f26: bd80         	pop	{r7, pc}
		...

700a6f30 <Udma_ringFree>:
; {
700a6f30: b580         	push	{r7, lr}
700a6f32: b086         	sub	sp, #0x18
700a6f34: 9005         	str	r0, [sp, #0x14]
700a6f36: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a6f38: 9004         	str	r0, [sp, #0x10]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a6f3a: 9805         	ldr	r0, [sp, #0x14]
700a6f3c: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == ringHandleInt)
700a6f3e: 9802         	ldr	r0, [sp, #0x8]
700a6f40: b920         	cbnz	r0, 0x700a6f4c <Udma_ringFree+0x1c> @ imm = #0x8
700a6f42: e7ff         	b	0x700a6f44 <Udma_ringFree+0x14> @ imm = #-0x2
700a6f44: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a6f48: 9004         	str	r0, [sp, #0x10]
;     }
700a6f4a: e7ff         	b	0x700a6f4c <Udma_ringFree+0x1c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6f4c: 9804         	ldr	r0, [sp, #0x10]
700a6f4e: b970         	cbnz	r0, 0x700a6f6e <Udma_ringFree+0x3e> @ imm = #0x1c
700a6f50: e7ff         	b	0x700a6f52 <Udma_ringFree+0x22> @ imm = #-0x2
;         if(ringHandleInt->ringInitDone != UDMA_INIT_DONE)
700a6f52: 9802         	ldr	r0, [sp, #0x8]
700a6f54: 6d80         	ldr	r0, [r0, #0x58]
700a6f56: f64a 31cd    	movw	r1, #0xabcd
700a6f5a: f6ca 31dc    	movt	r1, #0xabdc
700a6f5e: 4288         	cmp	r0, r1
700a6f60: d004         	beq	0x700a6f6c <Udma_ringFree+0x3c> @ imm = #0x8
700a6f62: e7ff         	b	0x700a6f64 <Udma_ringFree+0x34> @ imm = #-0x2
700a6f64: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a6f68: 9004         	str	r0, [sp, #0x10]
;         }
700a6f6a: e7ff         	b	0x700a6f6c <Udma_ringFree+0x3c> @ imm = #-0x2
;     }
700a6f6c: e7ff         	b	0x700a6f6e <Udma_ringFree+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6f6e: 9804         	ldr	r0, [sp, #0x10]
700a6f70: b9a8         	cbnz	r0, 0x700a6f9e <Udma_ringFree+0x6e> @ imm = #0x2a
700a6f72: e7ff         	b	0x700a6f74 <Udma_ringFree+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a6f74: 9802         	ldr	r0, [sp, #0x8]
700a6f76: 6800         	ldr	r0, [r0]
700a6f78: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a6f7a: 9803         	ldr	r0, [sp, #0xc]
700a6f7c: b150         	cbz	r0, 0x700a6f94 <Udma_ringFree+0x64> @ imm = #0x14
700a6f7e: e7ff         	b	0x700a6f80 <Udma_ringFree+0x50> @ imm = #-0x2
700a6f80: 9803         	ldr	r0, [sp, #0xc]
700a6f82: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a6f86: f64a 31cd    	movw	r1, #0xabcd
700a6f8a: f6ca 31dc    	movt	r1, #0xabdc
700a6f8e: 4288         	cmp	r0, r1
700a6f90: d004         	beq	0x700a6f9c <Udma_ringFree+0x6c> @ imm = #0x8
700a6f92: e7ff         	b	0x700a6f94 <Udma_ringFree+0x64> @ imm = #-0x2
700a6f94: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a6f98: 9004         	str	r0, [sp, #0x10]
;         }
700a6f9a: e7ff         	b	0x700a6f9c <Udma_ringFree+0x6c> @ imm = #-0x2
;     }
700a6f9c: e7ff         	b	0x700a6f9e <Udma_ringFree+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a6f9e: 9804         	ldr	r0, [sp, #0x10]
700a6fa0: bb38         	cbnz	r0, 0x700a6ff2 <Udma_ringFree+0xc2> @ imm = #0x4e
700a6fa2: e7ff         	b	0x700a6fa4 <Udma_ringFree+0x74> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == ringHandleInt->mappedRingGrp)
700a6fa4: 9802         	ldr	r0, [sp, #0x8]
700a6fa6: 6dc0         	ldr	r0, [r0, #0x5c]
700a6fa8: 2104         	movs	r1, #0x4
700a6faa: f6cf 71ff    	movt	r1, #0xffff
700a6fae: 4288         	cmp	r0, r1
700a6fb0: d106         	bne	0x700a6fc0 <Udma_ringFree+0x90> @ imm = #0xc
700a6fb2: e7ff         	b	0x700a6fb4 <Udma_ringFree+0x84> @ imm = #-0x2
;             Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandle);
700a6fb4: 9802         	ldr	r0, [sp, #0x8]
700a6fb6: 8880         	ldrh	r0, [r0, #0x4]
700a6fb8: 9903         	ldr	r1, [sp, #0xc]
700a6fba: f008 fe49    	bl	0x700afc50 <Udma_rmFreeFreeRing> @ imm = #0x8c92
;         }
700a6fbe: e007         	b	0x700a6fd0 <Udma_ringFree+0xa0> @ imm = #0xe
;                 ringHandleInt->ringNum,
700a6fc0: 9b02         	ldr	r3, [sp, #0x8]
700a6fc2: 8898         	ldrh	r0, [r3, #0x4]
;                 drvHandle,
700a6fc4: 9903         	ldr	r1, [sp, #0xc]
;                 ringHandleInt->mappedRingGrp,
700a6fc6: 6dda         	ldr	r2, [r3, #0x5c]
;                 ringHandleInt->mappedChNum);
700a6fc8: 6e1b         	ldr	r3, [r3, #0x60]
;             Udma_rmFreeMappedRing(
700a6fca: f002 fe19    	bl	0x700a9c00 <Udma_rmFreeMappedRing> @ imm = #0x2c32
700a6fce: e7ff         	b	0x700a6fd0 <Udma_ringFree+0xa0> @ imm = #-0x2
;         ringHandleInt->ringNum         = UDMA_RING_INVALID;
700a6fd0: 9902         	ldr	r1, [sp, #0x8]
700a6fd2: f64f 70ff    	movw	r0, #0xffff
700a6fd6: 8088         	strh	r0, [r1, #0x4]
;         ringHandleInt->ringInitDone    = UDMA_DEINIT_DONE;
700a6fd8: 9902         	ldr	r1, [sp, #0x8]
700a6fda: 2000         	movs	r0, #0x0
700a6fdc: 9001         	str	r0, [sp, #0x4]
700a6fde: 6588         	str	r0, [r1, #0x58]
;         drvHandle->ringHandleClearRegs(ringHandleInt);
700a6fe0: 9803         	ldr	r0, [sp, #0xc]
700a6fe2: f8d0 15c8    	ldr.w	r1, [r0, #0x5c8]
700a6fe6: 9802         	ldr	r0, [sp, #0x8]
700a6fe8: 4788         	blx	r1
700a6fea: 9801         	ldr	r0, [sp, #0x4]
;         ringHandleInt->drvHandle       = (Udma_DrvHandleInt) NULL_PTR;
700a6fec: 9902         	ldr	r1, [sp, #0x8]
700a6fee: 6008         	str	r0, [r1]
;     }
700a6ff0: e7ff         	b	0x700a6ff2 <Udma_ringFree+0xc2> @ imm = #-0x2
;     return (retVal);
700a6ff2: 9804         	ldr	r0, [sp, #0x10]
700a6ff4: b006         	add	sp, #0x18
700a6ff6: bd80         	pop	{r7, pc}
		...

700a7000 <UART_lld_writeIntr>:
; {
700a7000: b580         	push	{r7, lr}
700a7002: b086         	sub	sp, #0x18
700a7004: 9005         	str	r0, [sp, #0x14]
700a7006: 9104         	str	r1, [sp, #0x10]
700a7008: 9203         	str	r2, [sp, #0xc]
700a700a: 9302         	str	r3, [sp, #0x8]
700a700c: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a700e: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a7010: 9805         	ldr	r0, [sp, #0x14]
700a7012: 2800         	cmp	r0, #0x0
700a7014: d050         	beq	0x700a70b8 <UART_lld_writeIntr+0xb8> @ imm = #0xa0
700a7016: e7ff         	b	0x700a7018 <UART_lld_writeIntr+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a7018: 9805         	ldr	r0, [sp, #0x14]
700a701a: 303c         	adds	r0, #0x3c
700a701c: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a701e: 9800         	ldr	r0, [sp]
700a7020: 6800         	ldr	r0, [r0]
700a7022: b138         	cbz	r0, 0x700a7034 <UART_lld_writeIntr+0x34> @ imm = #0xe
700a7024: e7ff         	b	0x700a7026 <UART_lld_writeIntr+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a7026: 9900         	ldr	r1, [sp]
700a7028: 2009         	movs	r0, #0x9
700a702a: 60c8         	str	r0, [r1, #0xc]
700a702c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a7030: 9001         	str	r0, [sp, #0x4]
;         }
700a7032: e040         	b	0x700a70b6 <UART_lld_writeIntr+0xb6> @ imm = #0x80
;             UART_lld_Transaction_init(trans);
700a7034: 9800         	ldr	r0, [sp]
700a7036: f007 fe6b    	bl	0x700aed10 <UART_lld_Transaction_init> @ imm = #0x7cd6
;             if(extendedParams != NULL)
700a703a: 9802         	ldr	r0, [sp, #0x8]
700a703c: b128         	cbz	r0, 0x700a704a <UART_lld_writeIntr+0x4a> @ imm = #0xa
700a703e: e7ff         	b	0x700a7040 <UART_lld_writeIntr+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a7040: 9802         	ldr	r0, [sp, #0x8]
700a7042: 6800         	ldr	r0, [r0]
700a7044: 9900         	ldr	r1, [sp]
700a7046: 6108         	str	r0, [r1, #0x10]
;             }
700a7048: e003         	b	0x700a7052 <UART_lld_writeIntr+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a704a: 9900         	ldr	r1, [sp]
700a704c: 2000         	movs	r0, #0x0
700a704e: 6108         	str	r0, [r1, #0x10]
700a7050: e7ff         	b	0x700a7052 <UART_lld_writeIntr+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a7052: 9804         	ldr	r0, [sp, #0x10]
700a7054: 9900         	ldr	r1, [sp]
700a7056: 6008         	str	r0, [r1]
;             trans->count = size;
700a7058: 9803         	ldr	r0, [sp, #0xc]
700a705a: 9900         	ldr	r1, [sp]
700a705c: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a705e: 9805         	ldr	r0, [sp, #0x14]
700a7060: 6d40         	ldr	r0, [r0, #0x54]
700a7062: 2801         	cmp	r0, #0x1
700a7064: d105         	bne	0x700a7072 <UART_lld_writeIntr+0x72> @ imm = #0xa
700a7066: e7ff         	b	0x700a7068 <UART_lld_writeIntr+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a7068: 9800         	ldr	r0, [sp]
700a706a: f007 fa51    	bl	0x700ae510 <UART_checkTransaction> @ imm = #0x74a2
700a706e: 9001         	str	r0, [sp, #0x4]
;             }
700a7070: e003         	b	0x700a707a <UART_lld_writeIntr+0x7a> @ imm = #0x6
700a7072: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a7076: 9001         	str	r0, [sp, #0x4]
700a7078: e7ff         	b	0x700a707a <UART_lld_writeIntr+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a707a: 9801         	ldr	r0, [sp, #0x4]
700a707c: b9d0         	cbnz	r0, 0x700a70b4 <UART_lld_writeIntr+0xb4> @ imm = #0x34
700a707e: e7ff         	b	0x700a7080 <UART_lld_writeIntr+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a7080: 9800         	ldr	r0, [sp]
700a7082: 6800         	ldr	r0, [r0]
700a7084: 9905         	ldr	r1, [sp, #0x14]
700a7086: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a7088: 9800         	ldr	r0, [sp]
700a708a: 6880         	ldr	r0, [r0, #0x8]
700a708c: 9905         	ldr	r1, [sp, #0x14]
700a708e: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a7090: 9905         	ldr	r1, [sp, #0x14]
700a7092: 2000         	movs	r0, #0x0
700a7094: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a7096: 9800         	ldr	r0, [sp]
700a7098: 6840         	ldr	r0, [r0, #0x4]
700a709a: 9905         	ldr	r1, [sp, #0x14]
700a709c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a709e: 9905         	ldr	r1, [sp, #0x14]
700a70a0: 2002         	movs	r0, #0x2
700a70a2: 6548         	str	r0, [r1, #0x54]
;                 status = UART_writeInterrupt(hUart);
700a70a4: 9805         	ldr	r0, [sp, #0x14]
700a70a6: f008 f9cb    	bl	0x700af440 <UART_writeInterrupt> @ imm = #0x8396
700a70aa: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a70ac: 9905         	ldr	r1, [sp, #0x14]
700a70ae: 2001         	movs	r0, #0x1
700a70b0: 6548         	str	r0, [r1, #0x54]
;             }
700a70b2: e7ff         	b	0x700a70b4 <UART_lld_writeIntr+0xb4> @ imm = #-0x2
700a70b4: e7ff         	b	0x700a70b6 <UART_lld_writeIntr+0xb6> @ imm = #-0x2
;     }
700a70b6: e003         	b	0x700a70c0 <UART_lld_writeIntr+0xc0> @ imm = #0x6
700a70b8: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a70bc: 9001         	str	r0, [sp, #0x4]
700a70be: e7ff         	b	0x700a70c0 <UART_lld_writeIntr+0xc0> @ imm = #-0x2
;     return status;
700a70c0: 9801         	ldr	r0, [sp, #0x4]
700a70c2: b006         	add	sp, #0x18
700a70c4: bd80         	pop	{r7, pc}
		...
700a70ce: 0000         	movs	r0, r0

700a70d0 <Udma_eventUnRegister>:
; {
700a70d0: b580         	push	{r7, lr}
700a70d2: b084         	sub	sp, #0x10
700a70d4: 9003         	str	r0, [sp, #0xc]
700a70d6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a70d8: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == eventHandle)
700a70da: 9803         	ldr	r0, [sp, #0xc]
700a70dc: b920         	cbnz	r0, 0x700a70e8 <Udma_eventUnRegister+0x18> @ imm = #0x8
700a70de: e7ff         	b	0x700a70e0 <Udma_eventUnRegister+0x10> @ imm = #-0x2
700a70e0: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a70e4: 9002         	str	r0, [sp, #0x8]
;     }
700a70e6: e7ff         	b	0x700a70e8 <Udma_eventUnRegister+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a70e8: 9802         	ldr	r0, [sp, #0x8]
700a70ea: b9b8         	cbnz	r0, 0x700a711c <Udma_eventUnRegister+0x4c> @ imm = #0x2e
700a70ec: e7ff         	b	0x700a70ee <Udma_eventUnRegister+0x1e> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
700a70ee: 9803         	ldr	r0, [sp, #0xc]
700a70f0: 9000         	str	r0, [sp]
;         drvHandle = eventHandleInt->drvHandle;
700a70f2: 9800         	ldr	r0, [sp]
700a70f4: 6800         	ldr	r0, [r0]
700a70f6: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a70f8: 9801         	ldr	r0, [sp, #0x4]
700a70fa: b150         	cbz	r0, 0x700a7112 <Udma_eventUnRegister+0x42> @ imm = #0x14
700a70fc: e7ff         	b	0x700a70fe <Udma_eventUnRegister+0x2e> @ imm = #-0x2
700a70fe: 9801         	ldr	r0, [sp, #0x4]
700a7100: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7104: f64a 31cd    	movw	r1, #0xabcd
700a7108: f6ca 31dc    	movt	r1, #0xabdc
700a710c: 4288         	cmp	r0, r1
700a710e: d004         	beq	0x700a711a <Udma_eventUnRegister+0x4a> @ imm = #0x8
700a7110: e7ff         	b	0x700a7112 <Udma_eventUnRegister+0x42> @ imm = #-0x2
700a7112: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7116: 9002         	str	r0, [sp, #0x8]
;         }
700a7118: e7ff         	b	0x700a711a <Udma_eventUnRegister+0x4a> @ imm = #-0x2
;     }
700a711a: e7ff         	b	0x700a711c <Udma_eventUnRegister+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a711c: 9802         	ldr	r0, [sp, #0x8]
700a711e: bbb8         	cbnz	r0, 0x700a7190 <Udma_eventUnRegister+0xc0> @ imm = #0x6e
700a7120: e7ff         	b	0x700a7122 <Udma_eventUnRegister+0x52> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a7122: 9801         	ldr	r0, [sp, #0x4]
700a7124: 6800         	ldr	r0, [r0]
700a7126: b130         	cbz	r0, 0x700a7136 <Udma_eventUnRegister+0x66> @ imm = #0xc
700a7128: e7ff         	b	0x700a712a <Udma_eventUnRegister+0x5a> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventHandleInt->eventPrms.eventType))
700a712a: 9800         	ldr	r0, [sp]
700a712c: 6880         	ldr	r0, [r0, #0x8]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a712e: 2802         	cmp	r0, #0x2
700a7130: d101         	bne	0x700a7136 <Udma_eventUnRegister+0x66> @ imm = #0x2
700a7132: e7ff         	b	0x700a7134 <Udma_eventUnRegister+0x64> @ imm = #-0x2
;         }
700a7134: e02b         	b	0x700a718e <Udma_eventUnRegister+0xbe> @ imm = #0x56
;             retVal = Udma_eventCheckUnRegister(drvHandle, eventHandleInt);
700a7136: 9801         	ldr	r0, [sp, #0x4]
700a7138: 9900         	ldr	r1, [sp]
700a713a: f7ff fe91    	bl	0x700a6e60 <Udma_eventCheckUnRegister> @ imm = #-0x2de
700a713e: 9002         	str	r0, [sp, #0x8]
;             if(UDMA_SOK == retVal)
700a7140: 9802         	ldr	r0, [sp, #0x8]
700a7142: bb18         	cbnz	r0, 0x700a718c <Udma_eventUnRegister+0xbc> @ imm = #0x46
700a7144: e7ff         	b	0x700a7146 <Udma_eventUnRegister+0x76> @ imm = #-0x2
;                 if(NULL_PTR != eventHandleInt->hwiHandle)
700a7146: 9800         	ldr	r0, [sp]
700a7148: 6e40         	ldr	r0, [r0, #0x64]
700a714a: b128         	cbz	r0, 0x700a7158 <Udma_eventUnRegister+0x88> @ imm = #0xa
700a714c: e7ff         	b	0x700a714e <Udma_eventUnRegister+0x7e> @ imm = #-0x2
;                     HwiP_disableInt(eventHandleInt->coreIntrNum);
700a714e: 9800         	ldr	r0, [sp]
700a7150: 6d80         	ldr	r0, [r0, #0x58]
700a7152: f008 fe55    	bl	0x700afe00 <HwiP_disableInt> @ imm = #0x8caa
;                 }
700a7156: e7ff         	b	0x700a7158 <Udma_eventUnRegister+0x88> @ imm = #-0x2
;                 retVal = Udma_eventReset(drvHandle, eventHandleInt);
700a7158: 9801         	ldr	r0, [sp, #0x4]
700a715a: 9900         	ldr	r1, [sp]
700a715c: f7f5 fe90    	bl	0x7009ce80 <Udma_eventReset> @ imm = #-0xa2e0
700a7160: 9002         	str	r0, [sp, #0x8]
;                 if(UDMA_SOK != retVal)
700a7162: 9802         	ldr	r0, [sp, #0x8]
700a7164: b108         	cbz	r0, 0x700a716a <Udma_eventUnRegister+0x9a> @ imm = #0x2
700a7166: e7ff         	b	0x700a7168 <Udma_eventUnRegister+0x98> @ imm = #-0x2
;                 }
700a7168: e7ff         	b	0x700a716a <Udma_eventUnRegister+0x9a> @ imm = #-0x2
;                 Udma_eventFreeResource(drvHandle, eventHandleInt);
700a716a: 9801         	ldr	r0, [sp, #0x4]
700a716c: 9900         	ldr	r1, [sp]
700a716e: f7fe fcef    	bl	0x700a5b50 <Udma_eventFreeResource> @ imm = #-0x1622
;                 eventHandleInt->eventInitDone  = UDMA_DEINIT_DONE;
700a7172: 9900         	ldr	r1, [sp]
700a7174: 2000         	movs	r0, #0x0
700a7176: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 eventHandleInt->pIaGeviRegs    = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
700a717a: 9900         	ldr	r1, [sp]
700a717c: f8c1 0090    	str.w	r0, [r1, #0x90]
;                 eventHandleInt->pIaVintrRegs   = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
700a7180: 9900         	ldr	r1, [sp]
700a7182: f8c1 0094    	str.w	r0, [r1, #0x94]
;                 eventHandleInt->drvHandle      = (Udma_DrvHandleInt) NULL_PTR;
700a7186: 9900         	ldr	r1, [sp]
700a7188: 6008         	str	r0, [r1]
;             }
700a718a: e7ff         	b	0x700a718c <Udma_eventUnRegister+0xbc> @ imm = #-0x2
700a718c: e7ff         	b	0x700a718e <Udma_eventUnRegister+0xbe> @ imm = #-0x2
;     }
700a718e: e7ff         	b	0x700a7190 <Udma_eventUnRegister+0xc0> @ imm = #-0x2
;     return (retVal);
700a7190: 9802         	ldr	r0, [sp, #0x8]
700a7192: b004         	add	sp, #0x10
700a7194: bd80         	pop	{r7, pc}
		...
700a719e: 0000         	movs	r0, r0

700a71a0 <Sciclient_rmIrqIsVintRouteSet>:
; {
700a71a0: b580         	push	{r7, lr}
700a71a2: b088         	sub	sp, #0x20
700a71a4: 9007         	str	r0, [sp, #0x1c]
700a71a6: 9106         	str	r1, [sp, #0x18]
700a71a8: 2000         	movs	r0, #0x0
;     bool found_iface = false;
700a71aa: f88d 0007    	strb.w	r0, [sp, #0x7]
;     *vint_used = false;
700a71ae: 9906         	ldr	r1, [sp, #0x18]
700a71b0: 7008         	strb	r0, [r1]
;     r = Sciclient_rmIrqGetNode(cfg->s_ia, &ia_node);
700a71b2: 9807         	ldr	r0, [sp, #0x1c]
700a71b4: 8a00         	ldrh	r0, [r0, #0x10]
700a71b6: a903         	add	r1, sp, #0xc
700a71b8: f7fe fdba    	bl	0x700a5d30 <Sciclient_rmIrqGetNode> @ imm = #-0x148c
700a71bc: 9005         	str	r0, [sp, #0x14]
;     if (r == SystemP_SUCCESS) {
700a71be: 9805         	ldr	r0, [sp, #0x14]
700a71c0: bb90         	cbnz	r0, 0x700a7228 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #0x64
700a71c2: e7ff         	b	0x700a71c4 <Sciclient_rmIrqIsVintRouteSet+0x24> @ imm = #-0x2
700a71c4: 2000         	movs	r0, #0x0
;         for (i = 0U; i < ia_node->n_if; i++) {
700a71c6: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a71ca: e7ff         	b	0x700a71cc <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x2
700a71cc: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a71d0: 9903         	ldr	r1, [sp, #0xc]
700a71d2: 8849         	ldrh	r1, [r1, #0x2]
700a71d4: 4288         	cmp	r0, r1
700a71d6: da26         	bge	0x700a7226 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x4c
700a71d8: e7ff         	b	0x700a71da <Sciclient_rmIrqIsVintRouteSet+0x3a> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(ia_node, i, &iface);
700a71da: 9803         	ldr	r0, [sp, #0xc]
700a71dc: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a71e0: aa02         	add	r2, sp, #0x8
700a71e2: f006 fbd5    	bl	0x700ad990 <Sciclient_rmIrqGetNodeItf> @ imm = #0x67aa
700a71e6: 9005         	str	r0, [sp, #0x14]
;             if (r != SystemP_SUCCESS) {
700a71e8: 9805         	ldr	r0, [sp, #0x14]
700a71ea: b108         	cbz	r0, 0x700a71f0 <Sciclient_rmIrqIsVintRouteSet+0x50> @ imm = #0x2
700a71ec: e7ff         	b	0x700a71ee <Sciclient_rmIrqIsVintRouteSet+0x4e> @ imm = #-0x2
;                 break;
700a71ee: e01a         	b	0x700a7226 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x34
;             if ((cfg->vint >= iface->lbase) &&
700a71f0: 9807         	ldr	r0, [sp, #0x1c]
700a71f2: 8a40         	ldrh	r0, [r0, #0x12]
700a71f4: 9902         	ldr	r1, [sp, #0x8]
700a71f6: 8809         	ldrh	r1, [r1]
700a71f8: 4288         	cmp	r0, r1
700a71fa: db0d         	blt	0x700a7218 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x1a
700a71fc: e7ff         	b	0x700a71fe <Sciclient_rmIrqIsVintRouteSet+0x5e> @ imm = #-0x2
;                 (cfg->vint < (iface->lbase + iface->len))) {
700a71fe: 9807         	ldr	r0, [sp, #0x1c]
700a7200: 8a40         	ldrh	r0, [r0, #0x12]
700a7202: 9a02         	ldr	r2, [sp, #0x8]
700a7204: 8811         	ldrh	r1, [r2]
700a7206: 8892         	ldrh	r2, [r2, #0x4]
700a7208: 4411         	add	r1, r2
;             if ((cfg->vint >= iface->lbase) &&
700a720a: 4288         	cmp	r0, r1
700a720c: da04         	bge	0x700a7218 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x8
700a720e: e7ff         	b	0x700a7210 <Sciclient_rmIrqIsVintRouteSet+0x70> @ imm = #-0x2
700a7210: 2001         	movs	r0, #0x1
;                 found_iface = true;
700a7212: f88d 0007    	strb.w	r0, [sp, #0x7]
;                 break;
700a7216: e006         	b	0x700a7226 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0xc
;         }
700a7218: e7ff         	b	0x700a721a <Sciclient_rmIrqIsVintRouteSet+0x7a> @ imm = #-0x2
;         for (i = 0U; i < ia_node->n_if; i++) {
700a721a: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a721e: 3001         	adds	r0, #0x1
700a7220: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a7224: e7d2         	b	0x700a71cc <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x5c
;     }
700a7226: e7ff         	b	0x700a7228 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #-0x2
;     if (found_iface) {
700a7228: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a722c: 07c0         	lsls	r0, r0, #0x1f
700a722e: b1b0         	cbz	r0, 0x700a725e <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #0x2c
700a7230: e7ff         	b	0x700a7232 <Sciclient_rmIrqIsVintRouteSet+0x92> @ imm = #-0x2
;         ir_inp = SCICLIENT_OUTP_TO_INP(cfg->vint, iface->lbase, iface->rbase);
700a7232: 9a02         	ldr	r2, [sp, #0x8]
700a7234: 8850         	ldrh	r0, [r2, #0x2]
700a7236: 9907         	ldr	r1, [sp, #0x1c]
700a7238: 8a49         	ldrh	r1, [r1, #0x12]
700a723a: 8812         	ldrh	r2, [r2]
700a723c: 1a89         	subs	r1, r1, r2
700a723e: 4408         	add	r0, r1
700a7240: f8ad 0004    	strh.w	r0, [sp, #0x4]
;         if (Sciclient_rmIrInpIsFree(iface->rid, ir_inp) != SystemP_SUCCESS) {
700a7244: 9802         	ldr	r0, [sp, #0x8]
700a7246: 88c0         	ldrh	r0, [r0, #0x6]
700a7248: f8bd 1004    	ldrh.w	r1, [sp, #0x4]
700a724c: f7fe ff38    	bl	0x700a60c0 <Sciclient_rmIrInpIsFree> @ imm = #-0x1190
700a7250: b120         	cbz	r0, 0x700a725c <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #0x8
700a7252: e7ff         	b	0x700a7254 <Sciclient_rmIrqIsVintRouteSet+0xb4> @ imm = #-0x2
;             *vint_used = true;
700a7254: 9906         	ldr	r1, [sp, #0x18]
700a7256: 2001         	movs	r0, #0x1
700a7258: 7008         	strb	r0, [r1]
;         }
700a725a: e7ff         	b	0x700a725c <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #-0x2
;     }
700a725c: e7ff         	b	0x700a725e <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #-0x2
;     return r;
700a725e: 9805         	ldr	r0, [sp, #0x14]
700a7260: b008         	add	sp, #0x20
700a7262: bd80         	pop	{r7, pc}
		...

700a7270 <UART_flushTxFifo>:
; {
700a7270: b580         	push	{r7, lr}
700a7272: b08a         	sub	sp, #0x28
700a7274: 9009         	str	r0, [sp, #0x24]
700a7276: f640 30b8    	movw	r0, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700a727a: 9003         	str	r0, [sp, #0xc]
700a727c: 2000         	movs	r0, #0x0
;     uint32_t            timeoutElapsed  = FALSE;
700a727e: 9002         	str	r0, [sp, #0x8]
;     config = (UART_Config *) handle;
700a7280: 9809         	ldr	r0, [sp, #0x24]
700a7282: 9008         	str	r0, [sp, #0x20]
;     if (NULL != config)
700a7284: 9808         	ldr	r0, [sp, #0x20]
700a7286: 2800         	cmp	r0, #0x0
700a7288: d052         	beq	0x700a7330 <UART_flushTxFifo+0xc0> @ imm = #0xa4
700a728a: e7ff         	b	0x700a728c <UART_flushTxFifo+0x1c> @ imm = #-0x2
;         attrs = config->attrs;
700a728c: 9808         	ldr	r0, [sp, #0x20]
700a728e: 6800         	ldr	r0, [r0]
700a7290: 9007         	str	r0, [sp, #0x1c]
;         DebugP_assert(NULL_PTR != attrs);
700a7292: 9807         	ldr	r0, [sp, #0x1c]
700a7294: 2800         	cmp	r0, #0x0
700a7296: bf18         	it	ne
700a7298: 2001         	movne	r0, #0x1
700a729a: f242 0137    	movw	r1, #0x2037
700a729e: f2c7 010b    	movt	r1, #0x700b
700a72a2: 466a         	mov	r2, sp
700a72a4: 6011         	str	r1, [r2]
700a72a6: f242 0101    	movw	r1, #0x2001
700a72aa: f2c7 010b    	movt	r1, #0x700b
700a72ae: f242 028e    	movw	r2, #0x208e
700a72b2: f2c7 020b    	movt	r2, #0x700b
700a72b6: f240 3355    	movw	r3, #0x355
700a72ba: f003 fc09    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x3812
;         startTicks = ClockP_getTicks();
700a72be: f008 fcef    	bl	0x700afca0 <ClockP_getTicks> @ imm = #0x89de
700a72c2: 9005         	str	r0, [sp, #0x14]
;         while (FALSE == timeoutElapsed)
700a72c4: e7ff         	b	0x700a72c6 <UART_flushTxFifo+0x56> @ imm = #-0x2
700a72c6: 9802         	ldr	r0, [sp, #0x8]
700a72c8: b9d8         	cbnz	r0, 0x700a7302 <UART_flushTxFifo+0x92> @ imm = #0x36
700a72ca: e7ff         	b	0x700a72cc <UART_flushTxFifo+0x5c> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(attrs->baseAddr);
700a72cc: 9807         	ldr	r0, [sp, #0x1c]
700a72ce: 6800         	ldr	r0, [r0]
700a72d0: f006 fd7e    	bl	0x700addd0 <UART_spaceAvail> @ imm = #0x6afc
700a72d4: 9006         	str	r0, [sp, #0x18]
;             if (TRUE == isTxFifoEmpty)
700a72d6: 9806         	ldr	r0, [sp, #0x18]
700a72d8: 2801         	cmp	r0, #0x1
700a72da: d101         	bne	0x700a72e0 <UART_flushTxFifo+0x70> @ imm = #0x2
700a72dc: e7ff         	b	0x700a72de <UART_flushTxFifo+0x6e> @ imm = #-0x2
;                 break;
700a72de: e010         	b	0x700a7302 <UART_flushTxFifo+0x92> @ imm = #0x20
;             elapsedTicks = ClockP_getTicks() - startTicks;
700a72e0: f008 fcde    	bl	0x700afca0 <ClockP_getTicks> @ imm = #0x89bc
700a72e4: 9905         	ldr	r1, [sp, #0x14]
700a72e6: 1a40         	subs	r0, r0, r1
700a72e8: 9004         	str	r0, [sp, #0x10]
;             if (elapsedTicks >= timeout)
700a72ea: 9804         	ldr	r0, [sp, #0x10]
700a72ec: 9903         	ldr	r1, [sp, #0xc]
700a72ee: 4288         	cmp	r0, r1
700a72f0: d303         	blo	0x700a72fa <UART_flushTxFifo+0x8a> @ imm = #0x6
700a72f2: e7ff         	b	0x700a72f4 <UART_flushTxFifo+0x84> @ imm = #-0x2
700a72f4: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700a72f6: 9002         	str	r0, [sp, #0x8]
;             }
700a72f8: e002         	b	0x700a7300 <UART_flushTxFifo+0x90> @ imm = #0x4
;                 TaskP_yield();
700a72fa: f008 fd01    	bl	0x700afd00 <TaskP_yield> @ imm = #0x8a02
700a72fe: e7ff         	b	0x700a7300 <UART_flushTxFifo+0x90> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700a7300: e7e1         	b	0x700a72c6 <UART_flushTxFifo+0x56> @ imm = #-0x3e
;         DebugP_assert(FALSE == timeoutElapsed);
700a7302: 9802         	ldr	r0, [sp, #0x8]
700a7304: fab0 f080    	clz	r0, r0
700a7308: 0940         	lsrs	r0, r0, #0x5
700a730a: f641 61f1    	movw	r1, #0x1ef1
700a730e: f2c7 010b    	movt	r1, #0x700b
700a7312: 466a         	mov	r2, sp
700a7314: 6011         	str	r1, [r2]
700a7316: f242 0101    	movw	r1, #0x2001
700a731a: f2c7 010b    	movt	r1, #0x700b
700a731e: f242 028e    	movw	r2, #0x208e
700a7322: f2c7 020b    	movt	r2, #0x700b
700a7326: f240 336f    	movw	r3, #0x36f
700a732a: f003 fbd1    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x37a2
;     }
700a732e: e7ff         	b	0x700a7330 <UART_flushTxFifo+0xc0> @ imm = #-0x2
;     return;
700a7330: b00a         	add	sp, #0x28
700a7332: bd80         	pop	{r7, pc}
		...

700a7340 <Udma_chClose>:
; {
700a7340: b580         	push	{r7, lr}
700a7342: b084         	sub	sp, #0x10
700a7344: 9003         	str	r0, [sp, #0xc]
700a7346: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a7348: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a734a: 9803         	ldr	r0, [sp, #0xc]
700a734c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a734e: 9800         	ldr	r0, [sp]
700a7350: b150         	cbz	r0, 0x700a7368 <Udma_chClose+0x28> @ imm = #0x14
700a7352: e7ff         	b	0x700a7354 <Udma_chClose+0x14> @ imm = #-0x2
700a7354: 9800         	ldr	r0, [sp]
700a7356: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a735a: f64a 31cd    	movw	r1, #0xabcd
700a735e: f6ca 31dc    	movt	r1, #0xabdc
700a7362: 4288         	cmp	r0, r1
700a7364: d004         	beq	0x700a7370 <Udma_chClose+0x30> @ imm = #0x8
700a7366: e7ff         	b	0x700a7368 <Udma_chClose+0x28> @ imm = #-0x2
700a7368: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a736c: 9002         	str	r0, [sp, #0x8]
;     }
700a736e: e7ff         	b	0x700a7370 <Udma_chClose+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7370: 9802         	ldr	r0, [sp, #0x8]
700a7372: b9a8         	cbnz	r0, 0x700a73a0 <Udma_chClose+0x60> @ imm = #0x2a
700a7374: e7ff         	b	0x700a7376 <Udma_chClose+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a7376: 9800         	ldr	r0, [sp]
700a7378: 6e80         	ldr	r0, [r0, #0x68]
700a737a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a737c: 9801         	ldr	r0, [sp, #0x4]
700a737e: b150         	cbz	r0, 0x700a7396 <Udma_chClose+0x56> @ imm = #0x14
700a7380: e7ff         	b	0x700a7382 <Udma_chClose+0x42> @ imm = #-0x2
700a7382: 9801         	ldr	r0, [sp, #0x4]
700a7384: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7388: f64a 31cd    	movw	r1, #0xabcd
700a738c: f6ca 31dc    	movt	r1, #0xabdc
700a7390: 4288         	cmp	r0, r1
700a7392: d004         	beq	0x700a739e <Udma_chClose+0x5e> @ imm = #0x8
700a7394: e7ff         	b	0x700a7396 <Udma_chClose+0x56> @ imm = #-0x2
700a7396: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a739a: 9002         	str	r0, [sp, #0x8]
;         }
700a739c: e7ff         	b	0x700a739e <Udma_chClose+0x5e> @ imm = #-0x2
;     }
700a739e: e7ff         	b	0x700a73a0 <Udma_chClose+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a73a0: 9802         	ldr	r0, [sp, #0x8]
700a73a2: b958         	cbnz	r0, 0x700a73bc <Udma_chClose+0x7c> @ imm = #0x16
700a73a4: e7ff         	b	0x700a73a6 <Udma_chClose+0x66> @ imm = #-0x2
;         if(TRUE == chHandleInt->chOesAllocDone)
700a73a6: 9800         	ldr	r0, [sp]
700a73a8: f8d0 0248    	ldr.w	r0, [r0, #0x248]
700a73ac: 2801         	cmp	r0, #0x1
700a73ae: d104         	bne	0x700a73ba <Udma_chClose+0x7a> @ imm = #0x8
700a73b0: e7ff         	b	0x700a73b2 <Udma_chClose+0x72> @ imm = #-0x2
700a73b2: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a73b6: 9002         	str	r0, [sp, #0x8]
;         }
700a73b8: e7ff         	b	0x700a73ba <Udma_chClose+0x7a> @ imm = #-0x2
;     }
700a73ba: e7ff         	b	0x700a73bc <Udma_chClose+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a73bc: 9802         	ldr	r0, [sp, #0x8]
700a73be: b9e8         	cbnz	r0, 0x700a73fc <Udma_chClose+0xbc> @ imm = #0x3a
700a73c0: e7ff         	b	0x700a73c2 <Udma_chClose+0x82> @ imm = #-0x2
;         retVal = Udma_chUnpair(chHandleInt);
700a73c2: 9800         	ldr	r0, [sp]
700a73c4: f003 f9bc    	bl	0x700aa740 <Udma_chUnpair> @ imm = #0x3378
700a73c8: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a73ca: 9802         	ldr	r0, [sp, #0x8]
700a73cc: b108         	cbz	r0, 0x700a73d2 <Udma_chClose+0x92> @ imm = #0x2
700a73ce: e7ff         	b	0x700a73d0 <Udma_chClose+0x90> @ imm = #-0x2
;         }
700a73d0: e7ff         	b	0x700a73d2 <Udma_chClose+0x92> @ imm = #-0x2
;         retVal += Udma_chFreeResource(chHandleInt);
700a73d2: 9800         	ldr	r0, [sp]
700a73d4: f7f7 fc14    	bl	0x7009ec00 <Udma_chFreeResource> @ imm = #-0x87d8
700a73d8: 4601         	mov	r1, r0
700a73da: 9802         	ldr	r0, [sp, #0x8]
700a73dc: 4408         	add	r0, r1
700a73de: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a73e0: 9802         	ldr	r0, [sp, #0x8]
700a73e2: b108         	cbz	r0, 0x700a73e8 <Udma_chClose+0xa8> @ imm = #0x2
700a73e4: e7ff         	b	0x700a73e6 <Udma_chClose+0xa6> @ imm = #-0x2
;         }
700a73e6: e7ff         	b	0x700a73e8 <Udma_chClose+0xa8> @ imm = #-0x2
;         (void) memset(chHandleInt, 0, sizeof(*chHandleInt));
700a73e8: 9800         	ldr	r0, [sp]
700a73ea: f44f 7114    	mov.w	r1, #0x250
700a73ee: f7f3 edd2    	blx	0x7009af94 <__aeabi_memclr8> @ imm = #-0xc45c
;         chHandleInt->chInitDone = UDMA_DEINIT_DONE;
700a73f2: 9900         	ldr	r1, [sp]
700a73f4: 2000         	movs	r0, #0x0
700a73f6: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a73fa: e7ff         	b	0x700a73fc <Udma_chClose+0xbc> @ imm = #-0x2
;     return (retVal);
700a73fc: 9802         	ldr	r0, [sp, #0x8]
700a73fe: b004         	add	sp, #0x10
700a7400: bd80         	pop	{r7, pc}
		...
700a740e: 0000         	movs	r0, r0

700a7410 <CSL_bcdmaChanOpAccessRemotePeerReg>:
; {
700a7410: b580         	push	{r7, lr}
700a7412: b08a         	sub	sp, #0x28
700a7414: 4684         	mov	r12, r0
700a7416: 980c         	ldr	r0, [sp, #0x30]
700a7418: f8cd c024    	str.w	r12, [sp, #0x24]
700a741c: 9108         	str	r1, [sp, #0x20]
700a741e: 9207         	str	r2, [sp, #0x1c]
700a7420: 9306         	str	r3, [sp, #0x18]
700a7422: f88d 0017    	strb.w	r0, [sp, #0x17]
700a7426: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a7428: 9004         	str	r0, [sp, #0x10]
;     if( pOpData == NULL )
700a742a: 9806         	ldr	r0, [sp, #0x18]
700a742c: b920         	cbnz	r0, 0x700a7438 <CSL_bcdmaChanOpAccessRemotePeerReg+0x28> @ imm = #0x8
700a742e: e7ff         	b	0x700a7430 <CSL_bcdmaChanOpAccessRemotePeerReg+0x20> @ imm = #-0x2
700a7430: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a7434: 9004         	str	r0, [sp, #0x10]
;     }
700a7436: e048         	b	0x700a74ca <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #0x90
700a7438: 2000         	movs	r0, #0x0
;         uint32_t *pRemotePeerReg = NULL;
700a743a: 9003         	str	r0, [sp, #0xc]
;         switch( chanType )
700a743c: 9808         	ldr	r0, [sp, #0x20]
700a743e: 9001         	str	r0, [sp, #0x4]
700a7440: 2801         	cmp	r0, #0x1
700a7442: d004         	beq	0x700a744e <CSL_bcdmaChanOpAccessRemotePeerReg+0x3e> @ imm = #0x8
700a7444: e7ff         	b	0x700a7446 <CSL_bcdmaChanOpAccessRemotePeerReg+0x36> @ imm = #-0x2
700a7446: 9801         	ldr	r0, [sp, #0x4]
700a7448: 2802         	cmp	r0, #0x2
700a744a: d009         	beq	0x700a7460 <CSL_bcdmaChanOpAccessRemotePeerReg+0x50> @ imm = #0x12
700a744c: e011         	b	0x700a7472 <CSL_bcdmaChanOpAccessRemotePeerReg+0x62> @ imm = #0x22
;                 pRemotePeerReg = (uint32_t *)&pCfg->pTxChanRtRegs->CHAN[chanIdx].PEER0;
700a744e: 9809         	ldr	r0, [sp, #0x24]
700a7450: 6900         	ldr	r0, [r0, #0x10]
700a7452: 9907         	ldr	r1, [sp, #0x1c]
700a7454: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a7458: f500 7000    	add.w	r0, r0, #0x200
700a745c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a745e: e00c         	b	0x700a747a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x18
;                 pRemotePeerReg = (uint32_t *)&pCfg->pRxChanRtRegs->CHAN[chanIdx].PEER0;
700a7460: 9809         	ldr	r0, [sp, #0x24]
700a7462: 6980         	ldr	r0, [r0, #0x18]
700a7464: 9907         	ldr	r1, [sp, #0x1c]
700a7466: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a746a: f500 7000    	add.w	r0, r0, #0x200
700a746e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a7470: e003         	b	0x700a747a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x6
700a7472: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a7476: 9004         	str	r0, [sp, #0x10]
;                 break;
700a7478: e7ff         	b	0x700a747a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #-0x2
;         if( pRemotePeerReg != NULL )
700a747a: 9803         	ldr	r0, [sp, #0xc]
700a747c: b320         	cbz	r0, 0x700a74c8 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #0x48
700a747e: e7ff         	b	0x700a7480 <CSL_bcdmaChanOpAccessRemotePeerReg+0x70> @ imm = #-0x2
;             CSL_BcdmaRemotePeerOpts *pPeerOpts = (CSL_BcdmaRemotePeerOpts *)pOpData;
700a7480: 9806         	ldr	r0, [sp, #0x18]
700a7482: 9002         	str	r0, [sp, #0x8]
;             if( pPeerOpts->regIdx >= (uint32_t)16u )
700a7484: 9802         	ldr	r0, [sp, #0x8]
700a7486: 6800         	ldr	r0, [r0]
700a7488: 2810         	cmp	r0, #0x10
700a748a: d304         	blo	0x700a7496 <CSL_bcdmaChanOpAccessRemotePeerReg+0x86> @ imm = #0x8
700a748c: e7ff         	b	0x700a748e <CSL_bcdmaChanOpAccessRemotePeerReg+0x7e> @ imm = #-0x2
700a748e: f06f 0002    	mvn	r0, #0x2
;                 retVal = CSL_EINVALID_PARAMS;
700a7492: 9004         	str	r0, [sp, #0x10]
;             }
700a7494: e017         	b	0x700a74c6 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #0x2e
;                 pRemotePeerReg += pPeerOpts->regIdx;    /* Increment to specified peer register */
700a7496: 9802         	ldr	r0, [sp, #0x8]
700a7498: 6801         	ldr	r1, [r0]
700a749a: 9803         	ldr	r0, [sp, #0xc]
700a749c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a74a0: 9003         	str	r0, [sp, #0xc]
;                 if( bRead == (bool)true )
700a74a2: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a74a6: 07c0         	lsls	r0, r0, #0x1f
700a74a8: b130         	cbz	r0, 0x700a74b8 <CSL_bcdmaChanOpAccessRemotePeerReg+0xa8> @ imm = #0xc
700a74aa: e7ff         	b	0x700a74ac <CSL_bcdmaChanOpAccessRemotePeerReg+0x9c> @ imm = #-0x2
;                     pPeerOpts->regVal = CSL_REG32_RD( pRemotePeerReg );
700a74ac: 9803         	ldr	r0, [sp, #0xc]
700a74ae: f008 fb87    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0x870e
700a74b2: 9902         	ldr	r1, [sp, #0x8]
700a74b4: 6048         	str	r0, [r1, #0x4]
;                 }
700a74b6: e005         	b	0x700a74c4 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #0xa
;                     CSL_REG32_WR( pRemotePeerReg, pPeerOpts->regVal );
700a74b8: 9803         	ldr	r0, [sp, #0xc]
700a74ba: 9902         	ldr	r1, [sp, #0x8]
700a74bc: 6849         	ldr	r1, [r1, #0x4]
700a74be: f7f4 fe27    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0xb3b2
700a74c2: e7ff         	b	0x700a74c4 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #-0x2
700a74c4: e7ff         	b	0x700a74c6 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #-0x2
;         }
700a74c6: e7ff         	b	0x700a74c8 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #-0x2
700a74c8: e7ff         	b	0x700a74ca <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #-0x2
;     return retVal;
700a74ca: 9804         	ldr	r0, [sp, #0x10]
700a74cc: b00a         	add	sp, #0x28
700a74ce: bd80         	pop	{r7, pc}

700a74d0 <_out_rev>:
; {
700a74d0: b580         	push	{r7, lr}
700a74d2: b086         	sub	sp, #0x18
700a74d4: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a74d8: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a74dc: f8dd c024    	ldr.w	r12, [sp, #0x24]
700a74e0: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a74e4: 9005         	str	r0, [sp, #0x14]
700a74e6: 9104         	str	r1, [sp, #0x10]
700a74e8: 9203         	str	r2, [sp, #0xc]
700a74ea: 9302         	str	r3, [sp, #0x8]
;   const size_t start_idx = idx;
700a74ec: 9803         	ldr	r0, [sp, #0xc]
700a74ee: 9001         	str	r0, [sp, #0x4]
;   if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
700a74f0: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a74f4: 0780         	lsls	r0, r0, #0x1e
700a74f6: 2800         	cmp	r0, #0x0
700a74f8: d41c         	bmi	0x700a7534 <_out_rev+0x64> @ imm = #0x38
700a74fa: e7ff         	b	0x700a74fc <_out_rev+0x2c> @ imm = #-0x2
700a74fc: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a7500: 07c0         	lsls	r0, r0, #0x1f
700a7502: b9b8         	cbnz	r0, 0x700a7534 <_out_rev+0x64> @ imm = #0x2e
700a7504: e7ff         	b	0x700a7506 <_out_rev+0x36> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a7506: 9809         	ldr	r0, [sp, #0x24]
700a7508: 9000         	str	r0, [sp]
700a750a: e7ff         	b	0x700a750c <_out_rev+0x3c> @ imm = #-0x2
700a750c: 9800         	ldr	r0, [sp]
700a750e: 990a         	ldr	r1, [sp, #0x28]
700a7510: 4288         	cmp	r0, r1
700a7512: d20e         	bhs	0x700a7532 <_out_rev+0x62> @ imm = #0x1c
700a7514: e7ff         	b	0x700a7516 <_out_rev+0x46> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a7516: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a751a: 9904         	ldr	r1, [sp, #0x10]
700a751c: 9a03         	ldr	r2, [sp, #0xc]
700a751e: 1c50         	adds	r0, r2, #0x1
700a7520: 9003         	str	r0, [sp, #0xc]
700a7522: 9b02         	ldr	r3, [sp, #0x8]
700a7524: 2020         	movs	r0, #0x20
700a7526: 47e0         	blx	r12
;     }
700a7528: e7ff         	b	0x700a752a <_out_rev+0x5a> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a752a: 9800         	ldr	r0, [sp]
700a752c: 3001         	adds	r0, #0x1
700a752e: 9000         	str	r0, [sp]
700a7530: e7ec         	b	0x700a750c <_out_rev+0x3c> @ imm = #-0x28
;   }
700a7532: e7ff         	b	0x700a7534 <_out_rev+0x64> @ imm = #-0x2
;   while (len) {
700a7534: e7ff         	b	0x700a7536 <_out_rev+0x66> @ imm = #-0x2
700a7536: 9809         	ldr	r0, [sp, #0x24]
700a7538: b170         	cbz	r0, 0x700a7558 <_out_rev+0x88> @ imm = #0x1c
700a753a: e7ff         	b	0x700a753c <_out_rev+0x6c> @ imm = #-0x2
;     out(buf[--len], buffer, idx++, maxlen);
700a753c: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a7540: 9808         	ldr	r0, [sp, #0x20]
700a7542: 9909         	ldr	r1, [sp, #0x24]
700a7544: 3901         	subs	r1, #0x1
700a7546: 9109         	str	r1, [sp, #0x24]
700a7548: 5c40         	ldrb	r0, [r0, r1]
700a754a: 9904         	ldr	r1, [sp, #0x10]
700a754c: 9a03         	ldr	r2, [sp, #0xc]
700a754e: 1c53         	adds	r3, r2, #0x1
700a7550: 9303         	str	r3, [sp, #0xc]
700a7552: 9b02         	ldr	r3, [sp, #0x8]
700a7554: 47e0         	blx	r12
;   while (len) {
700a7556: e7ee         	b	0x700a7536 <_out_rev+0x66> @ imm = #-0x24
;   if (flags & FLAGS_LEFT) {
700a7558: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a755c: 0780         	lsls	r0, r0, #0x1e
700a755e: 2800         	cmp	r0, #0x0
700a7560: d513         	bpl	0x700a758a <_out_rev+0xba> @ imm = #0x26
700a7562: e7ff         	b	0x700a7564 <_out_rev+0x94> @ imm = #-0x2
;     while (idx - start_idx < width) {
700a7564: e7ff         	b	0x700a7566 <_out_rev+0x96> @ imm = #-0x2
700a7566: 9803         	ldr	r0, [sp, #0xc]
700a7568: 9901         	ldr	r1, [sp, #0x4]
700a756a: 1a40         	subs	r0, r0, r1
700a756c: 990a         	ldr	r1, [sp, #0x28]
700a756e: 4288         	cmp	r0, r1
700a7570: d20a         	bhs	0x700a7588 <_out_rev+0xb8> @ imm = #0x14
700a7572: e7ff         	b	0x700a7574 <_out_rev+0xa4> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a7574: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a7578: 9904         	ldr	r1, [sp, #0x10]
700a757a: 9a03         	ldr	r2, [sp, #0xc]
700a757c: 1c50         	adds	r0, r2, #0x1
700a757e: 9003         	str	r0, [sp, #0xc]
700a7580: 9b02         	ldr	r3, [sp, #0x8]
700a7582: 2020         	movs	r0, #0x20
700a7584: 47e0         	blx	r12
;     while (idx - start_idx < width) {
700a7586: e7ee         	b	0x700a7566 <_out_rev+0x96> @ imm = #-0x24
;   }
700a7588: e7ff         	b	0x700a758a <_out_rev+0xba> @ imm = #-0x2
;   return idx;
700a758a: 9803         	ldr	r0, [sp, #0xc]
700a758c: b006         	add	sp, #0x18
700a758e: bd80         	pop	{r7, pc}

700a7590 <vTaskStartScheduler>:
; void vTaskStartScheduler(void) {
700a7590: b580         	push	{r7, lr}
700a7592: b088         	sub	sp, #0x20
700a7594: 2000         	movs	r0, #0x0
;     StaticTask_t *pxIdleTaskTCBBuffer = NULL;
700a7596: 9003         	str	r0, [sp, #0xc]
700a7598: 9006         	str	r0, [sp, #0x18]
;     StackType_t *pxIdleTaskStackBuffer = NULL;
700a759a: 9005         	str	r0, [sp, #0x14]
700a759c: a806         	add	r0, sp, #0x18
700a759e: a905         	add	r1, sp, #0x14
700a75a0: aa04         	add	r2, sp, #0x10
;     vApplicationGetIdleTaskMemory(&pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer,
700a75a2: f007 fb25    	bl	0x700aebf0 <vApplicationGetIdleTaskMemory> @ imm = #0x764a
700a75a6: 9b03         	ldr	r3, [sp, #0xc]
;         prvIdleTask, configIDLE_TASK_NAME, ulIdleTaskStackSize,
700a75a8: 9a04         	ldr	r2, [sp, #0x10]
;         pxIdleTaskStackBuffer,
700a75aa: 9905         	ldr	r1, [sp, #0x14]
;         pxIdleTaskTCBBuffer); /*lint !e961 MISRA exception, justified as it is
700a75ac: f8dd c018    	ldr.w	r12, [sp, #0x18]
;     xIdleTaskHandle = xTaskCreateStatic(
700a75b0: 4668         	mov	r0, sp
700a75b2: f8c0 c008    	str.w	r12, [r0, #0x8]
700a75b6: 6041         	str	r1, [r0, #0x4]
700a75b8: 6003         	str	r3, [r0]
700a75ba: f64c 6001    	movw	r0, #0xce01
700a75be: f2c7 000a    	movt	r0, #0x700a
700a75c2: f242 612c    	movw	r1, #0x262c
700a75c6: f2c7 010b    	movt	r1, #0x700b
700a75ca: f003 fe01    	bl	0x700ab1d0 <xTaskCreateStatic> @ imm = #0x3c02
700a75ce: 4601         	mov	r1, r0
700a75d0: f642 2030    	movw	r0, #0x2a30
700a75d4: f2c7 000b    	movt	r0, #0x700b
700a75d8: 6001         	str	r1, [r0]
;     if (xIdleTaskHandle != NULL) {
700a75da: 6800         	ldr	r0, [r0]
700a75dc: b118         	cbz	r0, 0x700a75e6 <vTaskStartScheduler+0x56> @ imm = #0x6
700a75de: e7ff         	b	0x700a75e0 <vTaskStartScheduler+0x50> @ imm = #-0x2
700a75e0: 2001         	movs	r0, #0x1
;       xReturn = pdPASS;
700a75e2: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a75e4: e002         	b	0x700a75ec <vTaskStartScheduler+0x5c> @ imm = #0x4
700a75e6: 2000         	movs	r0, #0x0
;       xReturn = pdFAIL;
700a75e8: 9007         	str	r0, [sp, #0x1c]
700a75ea: e7ff         	b	0x700a75ec <vTaskStartScheduler+0x5c> @ imm = #-0x2
;     if (xReturn == pdPASS) {
700a75ec: 9807         	ldr	r0, [sp, #0x1c]
700a75ee: 2801         	cmp	r0, #0x1
700a75f0: d104         	bne	0x700a75fc <vTaskStartScheduler+0x6c> @ imm = #0x8
700a75f2: e7ff         	b	0x700a75f4 <vTaskStartScheduler+0x64> @ imm = #-0x2
;       xReturn = xTimerCreateTimerTask();
700a75f4: f003 fb6c    	bl	0x700aacd0 <xTimerCreateTimerTask> @ imm = #0x36d8
700a75f8: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a75fa: e000         	b	0x700a75fe <vTaskStartScheduler+0x6e> @ imm = #0x0
700a75fc: e7ff         	b	0x700a75fe <vTaskStartScheduler+0x6e> @ imm = #-0x2
;   if (xReturn == pdPASS) {
700a75fe: 9807         	ldr	r0, [sp, #0x1c]
700a7600: 2801         	cmp	r0, #0x1
700a7602: d11d         	bne	0x700a7640 <vTaskStartScheduler+0xb0> @ imm = #0x3a
700a7604: e7ff         	b	0x700a7606 <vTaskStartScheduler+0x76> @ imm = #-0x2
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700a7606: b672         	cpsid i
;     xNextTaskUnblockTime = portMAX_DELAY;
700a7608: f642 2134    	movw	r1, #0x2a34
700a760c: f2c7 010b    	movt	r1, #0x700b
700a7610: f04f 30ff    	mov.w	r0, #0xffffffff
700a7614: 6008         	str	r0, [r1]
;     xSchedulerRunning = pdTRUE;
700a7616: f642 2140    	movw	r1, #0x2a40
700a761a: f2c7 010b    	movt	r1, #0x700b
700a761e: 2001         	movs	r0, #0x1
700a7620: 6008         	str	r0, [r1]
;     xTickCount = (TickType_t)configINITIAL_TICK_COUNT;
700a7622: f642 2144    	movw	r1, #0x2a44
700a7626: f2c7 010b    	movt	r1, #0x700b
700a762a: 2000         	movs	r0, #0x0
700a762c: 6008         	str	r0, [r1]
;     portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
700a762e: f008 fbb7    	bl	0x700afda0 <vPortConfigTimerForRunTimeStats> @ imm = #0x876e
;     if (xPortStartScheduler() != pdFALSE) {
700a7632: f007 ff45    	bl	0x700af4c0 <xPortStartScheduler> @ imm = #0x7e8a
700a7636: b108         	cbz	r0, 0x700a763c <vTaskStartScheduler+0xac> @ imm = #0x2
700a7638: e7ff         	b	0x700a763a <vTaskStartScheduler+0xaa> @ imm = #-0x2
;     } else {
700a763a: e000         	b	0x700a763e <vTaskStartScheduler+0xae> @ imm = #0x0
700a763c: e7ff         	b	0x700a763e <vTaskStartScheduler+0xae> @ imm = #-0x2
;   } else {
700a763e: e000         	b	0x700a7642 <vTaskStartScheduler+0xb2> @ imm = #0x0
700a7640: e7ff         	b	0x700a7642 <vTaskStartScheduler+0xb2> @ imm = #-0x2
;   (void)uxTopUsedPriority;
700a7642: f242 606c    	movw	r0, #0x266c
700a7646: f2c7 000b    	movt	r0, #0x700b
700a764a: 6800         	ldr	r0, [r0]
; }
700a764c: b008         	add	sp, #0x20
700a764e: bd80         	pop	{r7, pc}

700a7650 <PMU_profilePrintEntry>:
; void PMU_profilePrintEntry(const char *name) {
700a7650: b580         	push	{r7, lr}
700a7652: b086         	sub	sp, #0x18
700a7654: 9005         	str	r0, [sp, #0x14]
700a7656: 2000         	movs	r0, #0x0
;   for (i = 0; i < gProfileObject.logIndex; i++) {
700a7658: 9004         	str	r0, [sp, #0x10]
700a765a: e7ff         	b	0x700a765c <PMU_profilePrintEntry+0xc> @ imm = #-0x2
700a765c: 9804         	ldr	r0, [sp, #0x10]
700a765e: f243 0180    	movw	r1, #0x3080
700a7662: f2c7 0108    	movt	r1, #0x7008
700a7666: 6809         	ldr	r1, [r1]
700a7668: 4288         	cmp	r0, r1
700a766a: d24d         	bhs	0x700a7708 <PMU_profilePrintEntry+0xb8> @ imm = #0x9a
700a766c: e7ff         	b	0x700a766e <PMU_profilePrintEntry+0x1e> @ imm = #-0x2
;     PMU_ProfilePoint *p = &gProfileObject.point[i];
700a766e: 9804         	ldr	r0, [sp, #0x10]
700a7670: f243 0280    	movw	r2, #0x3080
700a7674: f2c7 0208    	movt	r2, #0x7008
700a7678: 2134         	movs	r1, #0x34
700a767a: fb00 2001    	mla	r0, r0, r1, r2
700a767e: 300c         	adds	r0, #0xc
700a7680: 9002         	str	r0, [sp, #0x8]
;     if (strcmp(name, p->name) == 0) {
700a7682: 9805         	ldr	r0, [sp, #0x14]
700a7684: 9902         	ldr	r1, [sp, #0x8]
700a7686: 6b09         	ldr	r1, [r1, #0x30]
700a7688: f7f4 ed4a    	blx	0x7009c120 <strcmp>     @ imm = #-0xb56c
700a768c: bbb8         	cbnz	r0, 0x700a76fe <PMU_profilePrintEntry+0xae> @ imm = #0x6e
700a768e: e7ff         	b	0x700a7690 <PMU_profilePrintEntry+0x40> @ imm = #-0x2
;       DebugP_log("Profile Point: %-32s\r\n", p->name);
700a7690: 9802         	ldr	r0, [sp, #0x8]
700a7692: 6b02         	ldr	r2, [r0, #0x30]
700a7694: f641 713b    	movw	r1, #0x1f3b
700a7698: f2c7 010b    	movt	r1, #0x700b
700a769c: 2001         	movs	r0, #0x1
700a769e: 9001         	str	r0, [sp, #0x4]
700a76a0: f002 fa5e    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #0x24bc
700a76a4: 9801         	ldr	r0, [sp, #0x4]
;       DebugP_log("Cycle Count: %lu\r\n", p->cycleCount.value);
700a76a6: 9902         	ldr	r1, [sp, #0x8]
700a76a8: 6aca         	ldr	r2, [r1, #0x2c]
700a76aa: f641 71b5    	movw	r1, #0x1fb5
700a76ae: f2c7 010b    	movt	r1, #0x700b
700a76b2: f002 fa55    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #0x24aa
700a76b6: 2000         	movs	r0, #0x0
;       for (j = 0; j < PMU_MAX_EVENT_COUNTERS; j++) {
700a76b8: 9003         	str	r0, [sp, #0xc]
700a76ba: e7ff         	b	0x700a76bc <PMU_profilePrintEntry+0x6c> @ imm = #-0x2
700a76bc: 9803         	ldr	r0, [sp, #0xc]
700a76be: 2802         	cmp	r0, #0x2
700a76c0: d815         	bhi	0x700a76ee <PMU_profilePrintEntry+0x9e> @ imm = #0x2a
700a76c2: e7ff         	b	0x700a76c4 <PMU_profilePrintEntry+0x74> @ imm = #-0x2
;         DebugP_log("%s Count: %lu\r\n", p->events[j].name, p->events[j].value);
700a76c4: 9902         	ldr	r1, [sp, #0x8]
700a76c6: 9803         	ldr	r0, [sp, #0xc]
700a76c8: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a76cc: eb01 0082    	add.w	r0, r1, r2, lsl #2
700a76d0: f851 2022    	ldr.w	r2, [r1, r2, lsl #2]
700a76d4: 6883         	ldr	r3, [r0, #0x8]
700a76d6: f242 01c1    	movw	r1, #0x20c1
700a76da: f2c7 010b    	movt	r1, #0x700b
700a76de: 2001         	movs	r0, #0x1
700a76e0: f002 fa3e    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #0x247c
;       }
700a76e4: e7ff         	b	0x700a76e6 <PMU_profilePrintEntry+0x96> @ imm = #-0x2
;       for (j = 0; j < PMU_MAX_EVENT_COUNTERS; j++) {
700a76e6: 9803         	ldr	r0, [sp, #0xc]
700a76e8: 3001         	adds	r0, #0x1
700a76ea: 9003         	str	r0, [sp, #0xc]
700a76ec: e7e6         	b	0x700a76bc <PMU_profilePrintEntry+0x6c> @ imm = #-0x34
;       DebugP_log("\r\n");
700a76ee: f241 61c1    	movw	r1, #0x16c1
700a76f2: f2c7 010b    	movt	r1, #0x700b
700a76f6: 2001         	movs	r0, #0x1
700a76f8: f002 fa32    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #0x2464
;       break;
700a76fc: e004         	b	0x700a7708 <PMU_profilePrintEntry+0xb8> @ imm = #0x8
;   }
700a76fe: e7ff         	b	0x700a7700 <PMU_profilePrintEntry+0xb0> @ imm = #-0x2
;   for (i = 0; i < gProfileObject.logIndex; i++) {
700a7700: 9804         	ldr	r0, [sp, #0x10]
700a7702: 3001         	adds	r0, #0x1
700a7704: 9004         	str	r0, [sp, #0x10]
700a7706: e7a9         	b	0x700a765c <PMU_profilePrintEntry+0xc> @ imm = #-0xae
; }
700a7708: b006         	add	sp, #0x18
700a770a: bd80         	pop	{r7, pc}
700a770c: 0000         	movs	r0, r0
700a770e: 0000         	movs	r0, r0

700a7710 <prvSwitchTimerLists>:
;     {
700a7710: b580         	push	{r7, lr}
700a7712: b086         	sub	sp, #0x18
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a7714: e7ff         	b	0x700a7716 <prvSwitchTimerLists+0x6> @ imm = #-0x2
700a7716: f245 1024    	movw	r0, #0x5124
700a771a: f2c7 0008    	movt	r0, #0x7008
700a771e: 6800         	ldr	r0, [r0]
700a7720: 6800         	ldr	r0, [r0]
700a7722: 2800         	cmp	r0, #0x0
700a7724: d040         	beq	0x700a77a8 <prvSwitchTimerLists+0x98> @ imm = #0x80
700a7726: e7ff         	b	0x700a7728 <prvSwitchTimerLists+0x18> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700a7728: f245 1024    	movw	r0, #0x5124
700a772c: f2c7 0008    	movt	r0, #0x7008
700a7730: 6801         	ldr	r1, [r0]
700a7732: 68c9         	ldr	r1, [r1, #0xc]
700a7734: 6809         	ldr	r1, [r1]
700a7736: 9105         	str	r1, [sp, #0x14]
;             pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700a7738: 6800         	ldr	r0, [r0]
700a773a: 68c0         	ldr	r0, [r0, #0xc]
700a773c: 68c0         	ldr	r0, [r0, #0xc]
700a773e: 9002         	str	r0, [sp, #0x8]
;             ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a7740: 9802         	ldr	r0, [sp, #0x8]
700a7742: 3004         	adds	r0, #0x4
700a7744: f005 ff6c    	bl	0x700ad620 <uxListRemove> @ imm = #0x5ed8
;             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a7748: 9802         	ldr	r0, [sp, #0x8]
700a774a: 6a01         	ldr	r1, [r0, #0x20]
700a774c: 4788         	blx	r1
;             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a774e: 9802         	ldr	r0, [sp, #0x8]
700a7750: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a7754: 0740         	lsls	r0, r0, #0x1d
700a7756: 2800         	cmp	r0, #0x0
700a7758: d524         	bpl	0x700a77a4 <prvSwitchTimerLists+0x94> @ imm = #0x48
700a775a: e7ff         	b	0x700a775c <prvSwitchTimerLists+0x4c> @ imm = #-0x2
;                 xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
700a775c: 9805         	ldr	r0, [sp, #0x14]
700a775e: 9902         	ldr	r1, [sp, #0x8]
700a7760: 6989         	ldr	r1, [r1, #0x18]
700a7762: 4408         	add	r0, r1
700a7764: 9004         	str	r0, [sp, #0x10]
;                 if( xReloadTime > xNextExpireTime )
700a7766: 9804         	ldr	r0, [sp, #0x10]
700a7768: 9905         	ldr	r1, [sp, #0x14]
700a776a: 4288         	cmp	r0, r1
700a776c: d90f         	bls	0x700a778e <prvSwitchTimerLists+0x7e> @ imm = #0x1e
700a776e: e7ff         	b	0x700a7770 <prvSwitchTimerLists+0x60> @ imm = #-0x2
;                     listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
700a7770: 9804         	ldr	r0, [sp, #0x10]
700a7772: 9902         	ldr	r1, [sp, #0x8]
700a7774: 6048         	str	r0, [r1, #0x4]
;                     listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700a7776: 9802         	ldr	r0, [sp, #0x8]
700a7778: 6100         	str	r0, [r0, #0x10]
;                     vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700a777a: f245 1024    	movw	r0, #0x5124
700a777e: f2c7 0008    	movt	r0, #0x7008
700a7782: 6800         	ldr	r0, [r0]
700a7784: 9902         	ldr	r1, [sp, #0x8]
700a7786: 3104         	adds	r1, #0x4
700a7788: f003 ff92    	bl	0x700ab6b0 <vListInsert> @ imm = #0x3f24
;                 }
700a778c: e009         	b	0x700a77a2 <prvSwitchTimerLists+0x92> @ imm = #0x12
;                     xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700a778e: 9802         	ldr	r0, [sp, #0x8]
700a7790: 9a05         	ldr	r2, [sp, #0x14]
700a7792: 4669         	mov	r1, sp
700a7794: 2300         	movs	r3, #0x0
700a7796: 600b         	str	r3, [r1]
700a7798: 4619         	mov	r1, r3
700a779a: f002 f8f1    	bl	0x700a9980 <xTimerGenericCommand> @ imm = #0x21e2
700a779e: 9001         	str	r0, [sp, #0x4]
700a77a0: e7ff         	b	0x700a77a2 <prvSwitchTimerLists+0x92> @ imm = #-0x2
;             }
700a77a2: e000         	b	0x700a77a6 <prvSwitchTimerLists+0x96> @ imm = #0x0
700a77a4: e7ff         	b	0x700a77a6 <prvSwitchTimerLists+0x96> @ imm = #-0x2
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a77a6: e7b6         	b	0x700a7716 <prvSwitchTimerLists+0x6> @ imm = #-0x94
;         pxTemp = pxCurrentTimerList;
700a77a8: f245 1224    	movw	r2, #0x5124
700a77ac: f2c7 0208    	movt	r2, #0x7008
700a77b0: 6810         	ldr	r0, [r2]
700a77b2: 9003         	str	r0, [sp, #0xc]
;         pxCurrentTimerList = pxOverflowTimerList;
700a77b4: f245 1130    	movw	r1, #0x5130
700a77b8: f2c7 0108    	movt	r1, #0x7008
700a77bc: 6808         	ldr	r0, [r1]
700a77be: 6010         	str	r0, [r2]
;         pxOverflowTimerList = pxTemp;
700a77c0: 9803         	ldr	r0, [sp, #0xc]
700a77c2: 6008         	str	r0, [r1]
;     }
700a77c4: b006         	add	sp, #0x18
700a77c6: bd80         	pop	{r7, pc}
		...

700a77d0 <CSL_pktdmaAccessChanPeerReg>:
; {
700a77d0: b580         	push	{r7, lr}
700a77d2: b088         	sub	sp, #0x20
700a77d4: 4684         	mov	r12, r0
700a77d6: 980b         	ldr	r0, [sp, #0x2c]
700a77d8: f8dd e028    	ldr.w	lr, [sp, #0x28]
700a77dc: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a77e0: 9106         	str	r1, [sp, #0x18]
700a77e2: 9205         	str	r2, [sp, #0x14]
700a77e4: 9304         	str	r3, [sp, #0x10]
700a77e6: f88d 000f    	strb.w	r0, [sp, #0xf]
700a77ea: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a77ec: 9002         	str	r0, [sp, #0x8]
;     if( (pCfg == NULL) || (pVal == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a77ee: 9807         	ldr	r0, [sp, #0x1c]
700a77f0: b150         	cbz	r0, 0x700a7808 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0x14
700a77f2: e7ff         	b	0x700a77f4 <CSL_pktdmaAccessChanPeerReg+0x24> @ imm = #-0x2
700a77f4: 9804         	ldr	r0, [sp, #0x10]
700a77f6: b138         	cbz	r0, 0x700a7808 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0xe
700a77f8: e7ff         	b	0x700a77fa <CSL_pktdmaAccessChanPeerReg+0x2a> @ imm = #-0x2
700a77fa: 9807         	ldr	r0, [sp, #0x1c]
700a77fc: 9906         	ldr	r1, [sp, #0x18]
700a77fe: 9a0a         	ldr	r2, [sp, #0x28]
700a7800: f005 fa3e    	bl	0x700acc80 <CSL_pktdmaIsValidChanIdx> @ imm = #0x547c
700a7804: b920         	cbnz	r0, 0x700a7810 <CSL_pktdmaAccessChanPeerReg+0x40> @ imm = #0x8
700a7806: e7ff         	b	0x700a7808 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #-0x2
700a7808: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a780c: 9002         	str	r0, [sp, #0x8]
;     }
700a780e: e037         	b	0x700a7880 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #0x6e
;         if( regIdx < CSL_PKTDMA_NUM_PEER_REGS )
700a7810: 9805         	ldr	r0, [sp, #0x14]
700a7812: 280f         	cmp	r0, #0xf
700a7814: d82f         	bhi	0x700a7876 <CSL_pktdmaAccessChanPeerReg+0xa6> @ imm = #0x5e
700a7816: e7ff         	b	0x700a7818 <CSL_pktdmaAccessChanPeerReg+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a7818: 980a         	ldr	r0, [sp, #0x28]
700a781a: b960         	cbnz	r0, 0x700a7836 <CSL_pktdmaAccessChanPeerReg+0x66> @ imm = #0x18
700a781c: e7ff         	b	0x700a781e <CSL_pktdmaAccessChanPeerReg+0x4e> @ imm = #-0x2
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pTxChanRtRegs) + (uintptr_t)CSL_PKTDMA_TXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a781e: 9807         	ldr	r0, [sp, #0x1c]
700a7820: 6900         	ldr	r0, [r0, #0x10]
700a7822: 9906         	ldr	r1, [sp, #0x18]
700a7824: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a7828: 9905         	ldr	r1, [sp, #0x14]
700a782a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a782e: f500 7000    	add.w	r0, r0, #0x200
700a7832: 9001         	str	r0, [sp, #0x4]
;             }
700a7834: e00b         	b	0x700a784e <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #0x16
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pRxChanRtRegs) + (uintptr_t)CSL_PKTDMA_RXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a7836: 9807         	ldr	r0, [sp, #0x1c]
700a7838: 6940         	ldr	r0, [r0, #0x14]
700a783a: 9906         	ldr	r1, [sp, #0x18]
700a783c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a7840: 9905         	ldr	r1, [sp, #0x14]
700a7842: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7846: f500 7000    	add.w	r0, r0, #0x200
700a784a: 9001         	str	r0, [sp, #0x4]
700a784c: e7ff         	b	0x700a784e <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #-0x2
;             if( bRdAccess == (bool)true )
700a784e: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a7852: 07c0         	lsls	r0, r0, #0x1f
700a7854: b130         	cbz	r0, 0x700a7864 <CSL_pktdmaAccessChanPeerReg+0x94> @ imm = #0xc
700a7856: e7ff         	b	0x700a7858 <CSL_pktdmaAccessChanPeerReg+0x88> @ imm = #-0x2
;                 *pVal = CSL_REG32_RD( pPeerReg );
700a7858: 9801         	ldr	r0, [sp, #0x4]
700a785a: f008 f9c1    	bl	0x700afbe0 <CSL_REG32_RD_RAW> @ imm = #0x8382
700a785e: 9904         	ldr	r1, [sp, #0x10]
700a7860: 6008         	str	r0, [r1]
;             }
700a7862: e005         	b	0x700a7870 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #0xa
;                 CSL_REG32_WR( pPeerReg, *pVal );
700a7864: 9801         	ldr	r0, [sp, #0x4]
700a7866: 9904         	ldr	r1, [sp, #0x10]
700a7868: 6809         	ldr	r1, [r1]
700a786a: f008 f911    	bl	0x700afa90 <CSL_REG32_WR_RAW> @ imm = #0x8222
700a786e: e7ff         	b	0x700a7870 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #-0x2
700a7870: 2000         	movs	r0, #0x0
;             retVal = CSL_PASS;
700a7872: 9002         	str	r0, [sp, #0x8]
;         }
700a7874: e003         	b	0x700a787e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #0x6
700a7876: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a787a: 9002         	str	r0, [sp, #0x8]
700a787c: e7ff         	b	0x700a787e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #-0x2
700a787e: e7ff         	b	0x700a7880 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #-0x2
;     return retVal;
700a7880: 9802         	ldr	r0, [sp, #0x8]
700a7882: b008         	add	sp, #0x20
700a7884: bd80         	pop	{r7, pc}
		...
700a788e: 0000         	movs	r0, r0

700a7890 <UART_fifoWrite>:
; {
700a7890: b580         	push	{r7, lr}
700a7892: b08c         	sub	sp, #0x30
700a7894: 900b         	str	r0, [sp, #0x2c]
700a7896: 910a         	str	r1, [sp, #0x28]
700a7898: 9209         	str	r2, [sp, #0x24]
;     uint32_t tempWriteSizeRemaining = writeSizeRemaining;
700a789a: 9809         	ldr	r0, [sp, #0x24]
700a789c: 9008         	str	r0, [sp, #0x20]
;     uint32_t size                  = tempWriteSizeRemaining;
700a789e: 9808         	ldr	r0, [sp, #0x20]
700a78a0: 9007         	str	r0, [sp, #0x1c]
;     const uint8_t *tempBuffer = buffer;
700a78a2: 980a         	ldr	r0, [sp, #0x28]
700a78a4: 9006         	str	r0, [sp, #0x18]
700a78a6: 2000         	movs	r0, #0x0
;     uint32_t lineStatus            = 0U;
700a78a8: 9005         	str	r0, [sp, #0x14]
;     uint32_t tempChunksize         = 0U;
700a78aa: 9004         	str	r0, [sp, #0x10]
700a78ac: f640 30b8    	movw	r0, #0xbb8
;     int32_t  maxTrialCount         = (int32_t) UART_TRANSMITEMPTY_TRIALCOUNT;
700a78b0: 9003         	str	r0, [sp, #0xc]
700a78b2: 2040         	movs	r0, #0x40
;     tempChunksize = UART_FIFO_SIZE;
700a78b4: 9004         	str	r0, [sp, #0x10]
;     do
700a78b6: e7ff         	b	0x700a78b8 <UART_fifoWrite+0x28> @ imm = #-0x2
;         lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a78b8: 980b         	ldr	r0, [sp, #0x2c]
700a78ba: 6800         	ldr	r0, [r0]
700a78bc: f005 ff78    	bl	0x700ad7b0 <UART_readLineStatus> @ imm = #0x5ef0
700a78c0: 9005         	str	r0, [sp, #0x14]
;         maxTrialCount--;
700a78c2: 9803         	ldr	r0, [sp, #0xc]
700a78c4: 3801         	subs	r0, #0x1
700a78c6: 9003         	str	r0, [sp, #0xc]
;     }
700a78c8: e7ff         	b	0x700a78ca <UART_fifoWrite+0x3a> @ imm = #-0x2
;                        UART_LSR_TX_FIFO_E_MASK) & lineStatus))
700a78ca: 9805         	ldr	r0, [sp, #0x14]
700a78cc: f000 0160    	and	r1, r0, #0x60
700a78d0: 2000         	movs	r0, #0x0
;            && (0 < maxTrialCount));
700a78d2: 2960         	cmp	r1, #0x60
700a78d4: 9002         	str	r0, [sp, #0x8]
700a78d6: d007         	beq	0x700a78e8 <UART_fifoWrite+0x58> @ imm = #0xe
700a78d8: e7ff         	b	0x700a78da <UART_fifoWrite+0x4a> @ imm = #-0x2
700a78da: 9903         	ldr	r1, [sp, #0xc]
700a78dc: 2000         	movs	r0, #0x0
700a78de: 2900         	cmp	r1, #0x0
700a78e0: bfc8         	it	gt
700a78e2: 2001         	movgt	r0, #0x1
700a78e4: 9002         	str	r0, [sp, #0x8]
700a78e6: e7ff         	b	0x700a78e8 <UART_fifoWrite+0x58> @ imm = #-0x2
700a78e8: 9802         	ldr	r0, [sp, #0x8]
;     }
700a78ea: 07c0         	lsls	r0, r0, #0x1f
700a78ec: 2800         	cmp	r0, #0x0
700a78ee: d1e3         	bne	0x700a78b8 <UART_fifoWrite+0x28> @ imm = #-0x3a
700a78f0: e7ff         	b	0x700a78f2 <UART_fifoWrite+0x62> @ imm = #-0x2
;     if (maxTrialCount > 0)
700a78f2: 9803         	ldr	r0, [sp, #0xc]
700a78f4: 2801         	cmp	r0, #0x1
700a78f6: db21         	blt	0x700a793c <UART_fifoWrite+0xac> @ imm = #0x42
700a78f8: e7ff         	b	0x700a78fa <UART_fifoWrite+0x6a> @ imm = #-0x2
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a78fa: e7ff         	b	0x700a78fc <UART_fifoWrite+0x6c> @ imm = #-0x2
700a78fc: 9904         	ldr	r1, [sp, #0x10]
700a78fe: 2000         	movs	r0, #0x0
700a7900: 9001         	str	r0, [sp, #0x4]
700a7902: b131         	cbz	r1, 0x700a7912 <UART_fifoWrite+0x82> @ imm = #0xc
700a7904: e7ff         	b	0x700a7906 <UART_fifoWrite+0x76> @ imm = #-0x2
700a7906: 9808         	ldr	r0, [sp, #0x20]
700a7908: 2800         	cmp	r0, #0x0
700a790a: bf18         	it	ne
700a790c: 2001         	movne	r0, #0x1
700a790e: 9001         	str	r0, [sp, #0x4]
700a7910: e7ff         	b	0x700a7912 <UART_fifoWrite+0x82> @ imm = #-0x2
700a7912: 9801         	ldr	r0, [sp, #0x4]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a7914: 07c0         	lsls	r0, r0, #0x1f
700a7916: b180         	cbz	r0, 0x700a793a <UART_fifoWrite+0xaa> @ imm = #0x20
700a7918: e7ff         	b	0x700a791a <UART_fifoWrite+0x8a> @ imm = #-0x2
;             UART_putChar(hUart->baseAddr, (*tempBuffer));
700a791a: 980b         	ldr	r0, [sp, #0x2c]
700a791c: 6800         	ldr	r0, [r0]
700a791e: 9906         	ldr	r1, [sp, #0x18]
700a7920: 7809         	ldrb	r1, [r1]
700a7922: f007 feed    	bl	0x700af700 <UART_putChar> @ imm = #0x7dda
;             tempBuffer++;
700a7926: 9806         	ldr	r0, [sp, #0x18]
700a7928: 3001         	adds	r0, #0x1
700a792a: 9006         	str	r0, [sp, #0x18]
;             tempWriteSizeRemaining--;
700a792c: 9808         	ldr	r0, [sp, #0x20]
700a792e: 3801         	subs	r0, #0x1
700a7930: 9008         	str	r0, [sp, #0x20]
;             tempChunksize--;
700a7932: 9804         	ldr	r0, [sp, #0x10]
700a7934: 3801         	subs	r0, #0x1
700a7936: 9004         	str	r0, [sp, #0x10]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a7938: e7e0         	b	0x700a78fc <UART_fifoWrite+0x6c> @ imm = #-0x40
;     }
700a793a: e7ff         	b	0x700a793c <UART_fifoWrite+0xac> @ imm = #-0x2
;     return (size - tempWriteSizeRemaining);
700a793c: 9807         	ldr	r0, [sp, #0x1c]
700a793e: 9908         	ldr	r1, [sp, #0x20]
700a7940: 1a40         	subs	r0, r0, r1
700a7942: b00c         	add	sp, #0x30
700a7944: bd80         	pop	{r7, pc}
		...
700a794e: 0000         	movs	r0, r0

700a7950 <xTaskRemoveFromEventList>:
; BaseType_t xTaskRemoveFromEventList(const List_t *const pxEventList) {
700a7950: b580         	push	{r7, lr}
700a7952: b084         	sub	sp, #0x10
700a7954: 9003         	str	r0, [sp, #0xc]
;   pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a7956: 9803         	ldr	r0, [sp, #0xc]
700a7958: 68c0         	ldr	r0, [r0, #0xc]
700a795a: 68c0         	ldr	r0, [r0, #0xc]
700a795c: 9002         	str	r0, [sp, #0x8]
;   (void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
700a795e: 9802         	ldr	r0, [sp, #0x8]
700a7960: 3018         	adds	r0, #0x18
700a7962: f005 fe5d    	bl	0x700ad620 <uxListRemove> @ imm = #0x5cba
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a7966: f642 2024    	movw	r0, #0x2a24
700a796a: f2c7 000b    	movt	r0, #0x700b
700a796e: 6800         	ldr	r0, [r0]
700a7970: bb30         	cbnz	r0, 0x700a79c0 <xTaskRemoveFromEventList+0x70> @ imm = #0x4c
700a7972: e7ff         	b	0x700a7974 <xTaskRemoveFromEventList+0x24> @ imm = #-0x2
;     (void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
700a7974: 9802         	ldr	r0, [sp, #0x8]
700a7976: 3004         	adds	r0, #0x4
700a7978: f005 fe52    	bl	0x700ad620 <uxListRemove> @ imm = #0x5ca4
;     prvAddTaskToReadyList(pxUnblockedTCB);
700a797c: 9802         	ldr	r0, [sp, #0x8]
700a797e: 6ac0         	ldr	r0, [r0, #0x2c]
700a7980: f642 212c    	movw	r1, #0x2a2c
700a7984: f2c7 010b    	movt	r1, #0x700b
700a7988: 6809         	ldr	r1, [r1]
700a798a: 4288         	cmp	r0, r1
700a798c: d908         	bls	0x700a79a0 <xTaskRemoveFromEventList+0x50> @ imm = #0x10
700a798e: e7ff         	b	0x700a7990 <xTaskRemoveFromEventList+0x40> @ imm = #-0x2
700a7990: 9802         	ldr	r0, [sp, #0x8]
700a7992: 6ac0         	ldr	r0, [r0, #0x2c]
700a7994: f642 212c    	movw	r1, #0x2a2c
700a7998: f2c7 010b    	movt	r1, #0x700b
700a799c: 6008         	str	r0, [r1]
700a799e: e7ff         	b	0x700a79a0 <xTaskRemoveFromEventList+0x50> @ imm = #-0x2
700a79a0: 9902         	ldr	r1, [sp, #0x8]
700a79a2: 6ac8         	ldr	r0, [r1, #0x2c]
700a79a4: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a79a8: f244 40f8    	movw	r0, #0x44f8
700a79ac: f2c7 0008    	movt	r0, #0x7008
700a79b0: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a79b4: 3104         	adds	r1, #0x4
700a79b6: f006 fbeb    	bl	0x700ae190 <vListInsertEnd> @ imm = #0x67d6
;       prvResetNextTaskUnblockTime();
700a79ba: f006 fb69    	bl	0x700ae090 <prvResetNextTaskUnblockTime> @ imm = #0x66d2
;   } else {
700a79be: e009         	b	0x700a79d4 <xTaskRemoveFromEventList+0x84> @ imm = #0x12
;     vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
700a79c0: 9802         	ldr	r0, [sp, #0x8]
700a79c2: f100 0118    	add.w	r1, r0, #0x18
700a79c6: f245 00e0    	movw	r0, #0x50e0
700a79ca: f2c7 0008    	movt	r0, #0x7008
700a79ce: f006 fbdf    	bl	0x700ae190 <vListInsertEnd> @ imm = #0x67be
700a79d2: e7ff         	b	0x700a79d4 <xTaskRemoveFromEventList+0x84> @ imm = #-0x2
;   if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
700a79d4: 9802         	ldr	r0, [sp, #0x8]
700a79d6: 6ac0         	ldr	r0, [r0, #0x2c]
700a79d8: f642 2100    	movw	r1, #0x2a00
700a79dc: f2c7 010b    	movt	r1, #0x700b
700a79e0: 6809         	ldr	r1, [r1]
700a79e2: 6ac9         	ldr	r1, [r1, #0x2c]
700a79e4: 4288         	cmp	r0, r1
700a79e6: d908         	bls	0x700a79fa <xTaskRemoveFromEventList+0xaa> @ imm = #0x10
700a79e8: e7ff         	b	0x700a79ea <xTaskRemoveFromEventList+0x9a> @ imm = #-0x2
700a79ea: 2001         	movs	r0, #0x1
;     xReturn = pdTRUE;
700a79ec: 9001         	str	r0, [sp, #0x4]
;     xYieldPending = pdTRUE;
700a79ee: f642 2150    	movw	r1, #0x2a50
700a79f2: f2c7 010b    	movt	r1, #0x700b
700a79f6: 6008         	str	r0, [r1]
;   } else {
700a79f8: e002         	b	0x700a7a00 <xTaskRemoveFromEventList+0xb0> @ imm = #0x4
700a79fa: 2000         	movs	r0, #0x0
;     xReturn = pdFALSE;
700a79fc: 9001         	str	r0, [sp, #0x4]
700a79fe: e7ff         	b	0x700a7a00 <xTaskRemoveFromEventList+0xb0> @ imm = #-0x2
;   return xReturn;
700a7a00: 9801         	ldr	r0, [sp, #0x4]
700a7a02: b004         	add	sp, #0x10
700a7a04: bd80         	pop	{r7, pc}
		...
700a7a0e: 0000         	movs	r0, r0

700a7a10 <Sciclient_getCurrentContext>:
; {
700a7a10: b082         	sub	sp, #0x8
700a7a12: f8ad 0006    	strh.w	r0, [sp, #0x6]
700a7a16: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a7a18: 9000         	str	r0, [sp]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a7a1a: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7a1e: 280a         	cmp	r0, #0xa
700a7a20: d03e         	beq	0x700a7aa0 <Sciclient_getCurrentContext+0x90> @ imm = #0x7c
700a7a22: e7ff         	b	0x700a7a24 <Sciclient_getCurrentContext+0x14> @ imm = #-0x2
;        (TISCI_MSG_SEC_HANDOVER == messageType) ||
700a7a24: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7a28: f249 0130    	movw	r1, #0x9030
700a7a2c: 4288         	cmp	r0, r1
700a7a2e: d037         	beq	0x700a7aa0 <Sciclient_getCurrentContext+0x90> @ imm = #0x6e
700a7a30: e7ff         	b	0x700a7a32 <Sciclient_getCurrentContext+0x22> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG == messageType) ||
700a7a32: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7a36: 280b         	cmp	r0, #0xb
700a7a38: d032         	beq	0x700a7aa0 <Sciclient_getCurrentContext+0x90> @ imm = #0x64
700a7a3a: e7ff         	b	0x700a7a3c <Sciclient_getCurrentContext+0x2c> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_RM == messageType) ||
700a7a3c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7a40: 280c         	cmp	r0, #0xc
700a7a42: d02d         	beq	0x700a7aa0 <Sciclient_getCurrentContext+0x90> @ imm = #0x5a
700a7a44: e7ff         	b	0x700a7a46 <Sciclient_getCurrentContext+0x36> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_SECURITY == messageType) ||
700a7a46: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7a4a: 280d         	cmp	r0, #0xd
700a7a4c: d028         	beq	0x700a7aa0 <Sciclient_getCurrentContext+0x90> @ imm = #0x50
700a7a4e: e7ff         	b	0x700a7a50 <Sciclient_getCurrentContext+0x40> @ imm = #-0x2
;        (TISCI_MSG_KEY_WRITER == messageType) ||
700a7a50: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7a54: f249 0131    	movw	r1, #0x9031
700a7a58: 4288         	cmp	r0, r1
700a7a5a: d021         	beq	0x700a7aa0 <Sciclient_getCurrentContext+0x90> @ imm = #0x42
700a7a5c: e7ff         	b	0x700a7a5e <Sciclient_getCurrentContext+0x4e> @ imm = #-0x2
;        (TISCI_MSG_READ_OTP_MMR == messageType) ||
700a7a5e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7a62: f249 0122    	movw	r1, #0x9022
700a7a66: 4288         	cmp	r0, r1
700a7a68: d01a         	beq	0x700a7aa0 <Sciclient_getCurrentContext+0x90> @ imm = #0x34
700a7a6a: e7ff         	b	0x700a7a6c <Sciclient_getCurrentContext+0x5c> @ imm = #-0x2
;        (TISCI_MSG_WRITE_OTP_ROW == messageType) ||
700a7a6c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7a70: f249 0123    	movw	r1, #0x9023
700a7a74: 4288         	cmp	r0, r1
700a7a76: d013         	beq	0x700a7aa0 <Sciclient_getCurrentContext+0x90> @ imm = #0x26
700a7a78: e7ff         	b	0x700a7a7a <Sciclient_getCurrentContext+0x6a> @ imm = #-0x2
;        (TISCI_MSG_READ_SWREV == messageType) ||
700a7a7a: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7a7e: f249 0133    	movw	r1, #0x9033
700a7a82: 4288         	cmp	r0, r1
700a7a84: d00c         	beq	0x700a7aa0 <Sciclient_getCurrentContext+0x90> @ imm = #0x18
700a7a86: e7ff         	b	0x700a7a88 <Sciclient_getCurrentContext+0x78> @ imm = #-0x2
;        (TISCI_MSG_WRITE_SWREV == messageType) ||
700a7a88: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7a8c: f249 0132    	movw	r1, #0x9032
700a7a90: 4288         	cmp	r0, r1
700a7a92: d005         	beq	0x700a7aa0 <Sciclient_getCurrentContext+0x90> @ imm = #0xa
700a7a94: e7ff         	b	0x700a7a96 <Sciclient_getCurrentContext+0x86> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_PM == messageType))
700a7a96: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a7a9a: 280e         	cmp	r0, #0xe
700a7a9c: d107         	bne	0x700a7aae <Sciclient_getCurrentContext+0x9e> @ imm = #0xe
700a7a9e: e7ff         	b	0x700a7aa0 <Sciclient_getCurrentContext+0x90> @ imm = #-0x2
;         retVal = gSciclientHandle.secureContextId;
700a7aa0: f642 1048    	movw	r0, #0x2948
700a7aa4: f2c7 000b    	movt	r0, #0x700b
700a7aa8: 68c0         	ldr	r0, [r0, #0xc]
700a7aaa: 9000         	str	r0, [sp]
;     }
700a7aac: e006         	b	0x700a7abc <Sciclient_getCurrentContext+0xac> @ imm = #0xc
;         retVal = gSciclientHandle.nonSecureContextId;
700a7aae: f642 1048    	movw	r0, #0x2948
700a7ab2: f2c7 000b    	movt	r0, #0x700b
700a7ab6: 6900         	ldr	r0, [r0, #0x10]
700a7ab8: 9000         	str	r0, [sp]
700a7aba: e7ff         	b	0x700a7abc <Sciclient_getCurrentContext+0xac> @ imm = #-0x2
;     return retVal;
700a7abc: 9800         	ldr	r0, [sp]
700a7abe: b002         	add	sp, #0x8
700a7ac0: 4770         	bx	lr
		...
700a7ace: 0000         	movs	r0, r0

700a7ad0 <UART_init>:
; {
700a7ad0: b580         	push	{r7, lr}
700a7ad2: b086         	sub	sp, #0x18
700a7ad4: 2000         	movs	r0, #0x0
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a7ad6: 9004         	str	r0, [sp, #0x10]
700a7ad8: e7ff         	b	0x700a7ada <UART_init+0xa> @ imm = #-0x2
700a7ada: 9804         	ldr	r0, [sp, #0x10]
700a7adc: f642 11ec    	movw	r1, #0x29ec
700a7ae0: f2c7 010b    	movt	r1, #0x700b
700a7ae4: 6809         	ldr	r1, [r1]
700a7ae6: 4288         	cmp	r0, r1
700a7ae8: d236         	bhs	0x700a7b58 <UART_init+0x88> @ imm = #0x6c
700a7aea: e7ff         	b	0x700a7aec <UART_init+0x1c> @ imm = #-0x2
;         object = gUartConfig[cnt].object;
700a7aec: 9904         	ldr	r1, [sp, #0x10]
700a7aee: f642 10a4    	movw	r0, #0x29a4
700a7af2: f2c7 000b    	movt	r0, #0x700b
700a7af6: 9002         	str	r0, [sp, #0x8]
700a7af8: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a7afc: 6840         	ldr	r0, [r0, #0x4]
700a7afe: 9003         	str	r0, [sp, #0xc]
;         DebugP_assert(NULL_PTR != object);
700a7b00: 9803         	ldr	r0, [sp, #0xc]
700a7b02: 2800         	cmp	r0, #0x0
700a7b04: bf18         	it	ne
700a7b06: 2001         	movne	r0, #0x1
700a7b08: f641 71ee    	movw	r1, #0x1fee
700a7b0c: f2c7 010b    	movt	r1, #0x700b
700a7b10: 466a         	mov	r2, sp
700a7b12: 6011         	str	r1, [r2]
700a7b14: f242 0101    	movw	r1, #0x2001
700a7b18: f2c7 010b    	movt	r1, #0x700b
700a7b1c: f242 1252    	movw	r2, #0x2152
700a7b20: f2c7 020b    	movt	r2, #0x700b
700a7b24: 23bf         	movs	r3, #0xbf
700a7b26: f002 ffd3    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x2fa6
;         (void)memset(object, 0, sizeof(UART_Object));
700a7b2a: 9803         	ldr	r0, [sp, #0xc]
700a7b2c: f44f 715a    	mov.w	r1, #0x368
700a7b30: f7f3 ea30    	blx	0x7009af94 <__aeabi_memclr8> @ imm = #-0xcba0
700a7b34: 9802         	ldr	r0, [sp, #0x8]
;         gUartConfig[cnt].attrs->baseAddr = (uint32_t) AddrTranslateP_getLocalAddr((uint64_t)gUartConfig[cnt].attrs->baseAddr);
700a7b36: 9904         	ldr	r1, [sp, #0x10]
700a7b38: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700a7b3c: 6800         	ldr	r0, [r0]
700a7b3e: 2100         	movs	r1, #0x0
700a7b40: f7fd ff8e    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x20e4
700a7b44: 9902         	ldr	r1, [sp, #0x8]
700a7b46: 9a04         	ldr	r2, [sp, #0x10]
700a7b48: f851 1032    	ldr.w	r1, [r1, r2, lsl #3]
700a7b4c: 6008         	str	r0, [r1]
;     }
700a7b4e: e7ff         	b	0x700a7b50 <UART_init+0x80> @ imm = #-0x2
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a7b50: 9804         	ldr	r0, [sp, #0x10]
700a7b52: 3001         	adds	r0, #0x1
700a7b54: 9004         	str	r0, [sp, #0x10]
700a7b56: e7c0         	b	0x700a7ada <UART_init+0xa> @ imm = #-0x80
;     status = SemaphoreP_constructMutex(&gUartDrvObj.lockObj);
700a7b58: f242 7028    	movw	r0, #0x2728
700a7b5c: f2c7 000b    	movt	r0, #0x700b
700a7b60: 3004         	adds	r0, #0x4
700a7b62: f003 fcc5    	bl	0x700ab4f0 <SemaphoreP_constructMutex> @ imm = #0x398a
700a7b66: 9005         	str	r0, [sp, #0x14]
;     if(SystemP_SUCCESS == status)
700a7b68: 9805         	ldr	r0, [sp, #0x14]
700a7b6a: b938         	cbnz	r0, 0x700a7b7c <UART_init+0xac> @ imm = #0xe
700a7b6c: e7ff         	b	0x700a7b6e <UART_init+0x9e> @ imm = #-0x2
;         gUartDrvObj.lock = &gUartDrvObj.lockObj;
700a7b6e: f242 7128    	movw	r1, #0x2728
700a7b72: f2c7 010b    	movt	r1, #0x700b
700a7b76: 1d08         	adds	r0, r1, #0x4
700a7b78: 6008         	str	r0, [r1]
;     }
700a7b7a: e7ff         	b	0x700a7b7c <UART_init+0xac> @ imm = #-0x2
;     return;
700a7b7c: b006         	add	sp, #0x18
700a7b7e: bd80         	pop	{r7, pc}

700a7b80 <Udma_chCheckParams>:
; {
700a7b80: b084         	sub	sp, #0x10
700a7b82: 9003         	str	r0, [sp, #0xc]
700a7b84: 9102         	str	r1, [sp, #0x8]
700a7b86: 9201         	str	r2, [sp, #0x4]
700a7b88: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a7b8a: 9000         	str	r0, [sp]
;     if((chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
700a7b8c: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7b90: 0700         	lsls	r0, r0, #0x1c
700a7b92: 2800         	cmp	r0, #0x0
700a7b94: d513         	bpl	0x700a7bbe <Udma_chCheckParams+0x3e> @ imm = #0x26
700a7b96: e7ff         	b	0x700a7b98 <Udma_chCheckParams+0x18> @ imm = #-0x2
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a7b98: 9801         	ldr	r0, [sp, #0x4]
700a7b9a: 6840         	ldr	r0, [r0, #0x4]
700a7b9c: f510 3f80    	cmn.w	r0, #0x10000
700a7ba0: d008         	beq	0x700a7bb4 <Udma_chCheckParams+0x34> @ imm = #0x10
700a7ba2: e7ff         	b	0x700a7ba4 <Udma_chCheckParams+0x24> @ imm = #-0x2
;            (UDMA_DMA_CH_NA == chPrms->peerChNum))
700a7ba4: 9801         	ldr	r0, [sp, #0x4]
700a7ba6: 6840         	ldr	r0, [r0, #0x4]
700a7ba8: 2102         	movs	r1, #0x2
700a7baa: f6cf 71ff    	movt	r1, #0xffff
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a7bae: 4288         	cmp	r0, r1
700a7bb0: d104         	bne	0x700a7bbc <Udma_chCheckParams+0x3c> @ imm = #0x8
700a7bb2: e7ff         	b	0x700a7bb4 <Udma_chCheckParams+0x34> @ imm = #-0x2
700a7bb4: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7bb8: 9000         	str	r0, [sp]
;         }
700a7bba: e7ff         	b	0x700a7bbc <Udma_chCheckParams+0x3c> @ imm = #-0x2
;     }
700a7bbc: e7ff         	b	0x700a7bbe <Udma_chCheckParams+0x3e> @ imm = #-0x2
;     if((chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
700a7bbe: f89d 0009    	ldrb.w	r0, [sp, #0x9]
700a7bc2: 07c0         	lsls	r0, r0, #0x1f
700a7bc4: b388         	cbz	r0, 0x700a7c2a <Udma_chCheckParams+0xaa> @ imm = #0x62
700a7bc6: e7ff         	b	0x700a7bc8 <Udma_chCheckParams+0x48> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == chPrms->mappedChGrp)
700a7bc8: 9801         	ldr	r0, [sp, #0x4]
700a7bca: 6880         	ldr	r0, [r0, #0x8]
700a7bcc: 2104         	movs	r1, #0x4
700a7bce: f6cf 71ff    	movt	r1, #0xffff
700a7bd2: 4288         	cmp	r0, r1
700a7bd4: d104         	bne	0x700a7be0 <Udma_chCheckParams+0x60> @ imm = #0x8
700a7bd6: e7ff         	b	0x700a7bd8 <Udma_chCheckParams+0x58> @ imm = #-0x2
700a7bd8: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7bdc: 9000         	str	r0, [sp]
;         }
700a7bde: e7ff         	b	0x700a7be0 <Udma_chCheckParams+0x60> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a7be0: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7be4: 07c0         	lsls	r0, r0, #0x1f
700a7be6: b150         	cbz	r0, 0x700a7bfe <Udma_chCheckParams+0x7e> @ imm = #0x14
700a7be8: e7ff         	b	0x700a7bea <Udma_chCheckParams+0x6a> @ imm = #-0x2
;             if(chPrms->mappedChGrp >= UDMA_NUM_MAPPED_TX_GROUP)
700a7bea: 9801         	ldr	r0, [sp, #0x4]
700a7bec: 6880         	ldr	r0, [r0, #0x8]
700a7bee: 2804         	cmp	r0, #0x4
700a7bf0: d304         	blo	0x700a7bfc <Udma_chCheckParams+0x7c> @ imm = #0x8
700a7bf2: e7ff         	b	0x700a7bf4 <Udma_chCheckParams+0x74> @ imm = #-0x2
700a7bf4: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a7bf8: 9000         	str	r0, [sp]
;             }
700a7bfa: e7ff         	b	0x700a7bfc <Udma_chCheckParams+0x7c> @ imm = #-0x2
;         }
700a7bfc: e7ff         	b	0x700a7bfe <Udma_chCheckParams+0x7e> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a7bfe: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7c02: 0780         	lsls	r0, r0, #0x1e
700a7c04: 2800         	cmp	r0, #0x0
700a7c06: d50f         	bpl	0x700a7c28 <Udma_chCheckParams+0xa8> @ imm = #0x1e
700a7c08: e7ff         	b	0x700a7c0a <Udma_chCheckParams+0x8a> @ imm = #-0x2
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a7c0a: 9801         	ldr	r0, [sp, #0x4]
700a7c0c: 6880         	ldr	r0, [r0, #0x8]
700a7c0e: 2804         	cmp	r0, #0x4
700a7c10: d305         	blo	0x700a7c1e <Udma_chCheckParams+0x9e> @ imm = #0xa
700a7c12: e7ff         	b	0x700a7c14 <Udma_chCheckParams+0x94> @ imm = #-0x2
;                (chPrms->mappedChGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a7c14: 9801         	ldr	r0, [sp, #0x4]
700a7c16: 6880         	ldr	r0, [r0, #0x8]
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a7c18: 2808         	cmp	r0, #0x8
700a7c1a: d304         	blo	0x700a7c26 <Udma_chCheckParams+0xa6> @ imm = #0x8
700a7c1c: e7ff         	b	0x700a7c1e <Udma_chCheckParams+0x9e> @ imm = #-0x2
700a7c1e: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a7c22: 9000         	str	r0, [sp]
;             }
700a7c24: e7ff         	b	0x700a7c26 <Udma_chCheckParams+0xa6> @ imm = #-0x2
;         }
700a7c26: e7ff         	b	0x700a7c28 <Udma_chCheckParams+0xa8> @ imm = #-0x2
;     }
700a7c28: e7ff         	b	0x700a7c2a <Udma_chCheckParams+0xaa> @ imm = #-0x2
;     return (retVal);
700a7c2a: 9800         	ldr	r0, [sp]
700a7c2c: b004         	add	sp, #0x10
700a7c2e: 4770         	bx	lr

700a7c30 <Udma_getMappedChRingAttributes>:
; {
700a7c30: b087         	sub	sp, #0x1c
700a7c32: 9006         	str	r0, [sp, #0x18]
700a7c34: 9105         	str	r1, [sp, #0x14]
700a7c36: 9204         	str	r2, [sp, #0x10]
700a7c38: 9303         	str	r3, [sp, #0xc]
700a7c3a: 2000         	movs	r0, #0x0
;     uint32_t index = 0U;
700a7c3c: 9001         	str	r0, [sp, #0x4]
;     int32_t retVal = UDMA_SOK;
700a7c3e: 9000         	str	r0, [sp]
;     if(mappedGrp < UDMA_NUM_MAPPED_TX_GROUP) /* Mapped TX Channel */
700a7c40: 9805         	ldr	r0, [sp, #0x14]
700a7c42: 2803         	cmp	r0, #0x3
700a7c44: d81e         	bhi	0x700a7c84 <Udma_getMappedChRingAttributes+0x54> @ imm = #0x3c
700a7c46: e7ff         	b	0x700a7c48 <Udma_getMappedChRingAttributes+0x18> @ imm = #-0x2
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a7c48: 9804         	ldr	r0, [sp, #0x10]
700a7c4a: 2810         	cmp	r0, #0x10
700a7c4c: d304         	blo	0x700a7c58 <Udma_getMappedChRingAttributes+0x28> @ imm = #0x8
700a7c4e: e7ff         	b	0x700a7c50 <Udma_getMappedChRingAttributes+0x20> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_TX_CHANS))
700a7c50: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a7c52: 282a         	cmp	r0, #0x2a
700a7c54: d304         	blo	0x700a7c60 <Udma_getMappedChRingAttributes+0x30> @ imm = #0x8
700a7c56: e7ff         	b	0x700a7c58 <Udma_getMappedChRingAttributes+0x28> @ imm = #-0x2
700a7c58: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7c5c: 9000         	str	r0, [sp]
;         }
700a7c5e: e7ff         	b	0x700a7c60 <Udma_getMappedChRingAttributes+0x30> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a7c60: 9800         	ldr	r0, [sp]
700a7c62: b970         	cbnz	r0, 0x700a7c82 <Udma_getMappedChRingAttributes+0x52> @ imm = #0x1c
700a7c64: e7ff         	b	0x700a7c66 <Udma_getMappedChRingAttributes+0x36> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START;
700a7c66: 9804         	ldr	r0, [sp, #0x10]
700a7c68: 3810         	subs	r0, #0x10
700a7c6a: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaTxMappedChRingAttributes[index];
700a7c6c: 9801         	ldr	r0, [sp, #0x4]
700a7c6e: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a7c72: f241 4088    	movw	r0, #0x1488
700a7c76: f2c7 000b    	movt	r0, #0x700b
700a7c7a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7c7e: 9002         	str	r0, [sp, #0x8]
;         }
700a7c80: e7ff         	b	0x700a7c82 <Udma_getMappedChRingAttributes+0x52> @ imm = #-0x2
;     }
700a7c82: e01d         	b	0x700a7cc0 <Udma_getMappedChRingAttributes+0x90> @ imm = #0x3a
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a7c84: 9804         	ldr	r0, [sp, #0x10]
700a7c86: 2810         	cmp	r0, #0x10
700a7c88: d304         	blo	0x700a7c94 <Udma_getMappedChRingAttributes+0x64> @ imm = #0x8
700a7c8a: e7ff         	b	0x700a7c8c <Udma_getMappedChRingAttributes+0x5c> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_RX_CHANS))
700a7c8c: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a7c8e: 281d         	cmp	r0, #0x1d
700a7c90: d304         	blo	0x700a7c9c <Udma_getMappedChRingAttributes+0x6c> @ imm = #0x8
700a7c92: e7ff         	b	0x700a7c94 <Udma_getMappedChRingAttributes+0x64> @ imm = #-0x2
700a7c94: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7c98: 9000         	str	r0, [sp]
;         }
700a7c9a: e7ff         	b	0x700a7c9c <Udma_getMappedChRingAttributes+0x6c> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a7c9c: 9800         	ldr	r0, [sp]
700a7c9e: b970         	cbnz	r0, 0x700a7cbe <Udma_getMappedChRingAttributes+0x8e> @ imm = #0x1c
700a7ca0: e7ff         	b	0x700a7ca2 <Udma_getMappedChRingAttributes+0x72> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START;
700a7ca2: 9804         	ldr	r0, [sp, #0x10]
700a7ca4: 3810         	subs	r0, #0x10
700a7ca6: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaRxMappedChRingAttributes[index];
700a7ca8: 9801         	ldr	r0, [sp, #0x4]
700a7caa: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a7cae: f241 60c4    	movw	r0, #0x16c4
700a7cb2: f2c7 000b    	movt	r0, #0x700b
700a7cb6: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7cba: 9002         	str	r0, [sp, #0x8]
;         }
700a7cbc: e7ff         	b	0x700a7cbe <Udma_getMappedChRingAttributes+0x8e> @ imm = #-0x2
700a7cbe: e7ff         	b	0x700a7cc0 <Udma_getMappedChRingAttributes+0x90> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7cc0: 9800         	ldr	r0, [sp]
700a7cc2: b948         	cbnz	r0, 0x700a7cd8 <Udma_getMappedChRingAttributes+0xa8> @ imm = #0x12
700a7cc4: e7ff         	b	0x700a7cc6 <Udma_getMappedChRingAttributes+0x96> @ imm = #-0x2
;         (void) memcpy(chAttr, mappedChRingAttributes, sizeof (Udma_MappedChRingAttributes));
700a7cc6: 9903         	ldr	r1, [sp, #0xc]
700a7cc8: 9b02         	ldr	r3, [sp, #0x8]
700a7cca: 6818         	ldr	r0, [r3]
700a7ccc: 685a         	ldr	r2, [r3, #0x4]
700a7cce: 689b         	ldr	r3, [r3, #0x8]
700a7cd0: 608b         	str	r3, [r1, #0x8]
700a7cd2: 604a         	str	r2, [r1, #0x4]
700a7cd4: 6008         	str	r0, [r1]
;     }
700a7cd6: e7ff         	b	0x700a7cd8 <Udma_getMappedChRingAttributes+0xa8> @ imm = #-0x2
;     return(retVal);
700a7cd8: 9800         	ldr	r0, [sp]
700a7cda: b007         	add	sp, #0x1c
700a7cdc: 4770         	bx	lr
700a7cde: 0000         	movs	r0, r0

700a7ce0 <prvUnlockQueue>:
; {
700a7ce0: b580         	push	{r7, lr}
700a7ce2: b082         	sub	sp, #0x8
700a7ce4: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700a7ce6: f006 fceb    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x69d6
;         int8_t cTxLock = pxQueue->cTxLock;
700a7cea: 9801         	ldr	r0, [sp, #0x4]
700a7cec: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a7cf0: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a7cf4: e7ff         	b	0x700a7cf6 <prvUnlockQueue+0x16> @ imm = #-0x2
700a7cf6: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a7cfa: 2801         	cmp	r0, #0x1
700a7cfc: db16         	blt	0x700a7d2c <prvUnlockQueue+0x4c> @ imm = #0x2c
700a7cfe: e7ff         	b	0x700a7d00 <prvUnlockQueue+0x20> @ imm = #-0x2
;                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a7d00: 9801         	ldr	r0, [sp, #0x4]
700a7d02: 6a40         	ldr	r0, [r0, #0x24]
700a7d04: b158         	cbz	r0, 0x700a7d1e <prvUnlockQueue+0x3e> @ imm = #0x16
700a7d06: e7ff         	b	0x700a7d08 <prvUnlockQueue+0x28> @ imm = #-0x2
;                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a7d08: 9801         	ldr	r0, [sp, #0x4]
700a7d0a: 3024         	adds	r0, #0x24
700a7d0c: f7ff fe20    	bl	0x700a7950 <xTaskRemoveFromEventList> @ imm = #-0x3c0
700a7d10: b118         	cbz	r0, 0x700a7d1a <prvUnlockQueue+0x3a> @ imm = #0x6
700a7d12: e7ff         	b	0x700a7d14 <prvUnlockQueue+0x34> @ imm = #-0x2
;                             vTaskMissedYield();
700a7d14: f007 ff4c    	bl	0x700afbb0 <vTaskMissedYield> @ imm = #0x7e98
;                         }
700a7d18: e000         	b	0x700a7d1c <prvUnlockQueue+0x3c> @ imm = #0x0
700a7d1a: e7ff         	b	0x700a7d1c <prvUnlockQueue+0x3c> @ imm = #-0x2
;                     }
700a7d1c: e000         	b	0x700a7d20 <prvUnlockQueue+0x40> @ imm = #0x0
;                         break;
700a7d1e: e005         	b	0x700a7d2c <prvUnlockQueue+0x4c> @ imm = #0xa
;             --cTxLock;
700a7d20: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a7d24: 3801         	subs	r0, #0x1
700a7d26: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a7d2a: e7e4         	b	0x700a7cf6 <prvUnlockQueue+0x16> @ imm = #-0x38
;         pxQueue->cTxLock = queueUNLOCKED;
700a7d2c: 9901         	ldr	r1, [sp, #0x4]
700a7d2e: 20ff         	movs	r0, #0xff
700a7d30: f881 0045    	strb.w	r0, [r1, #0x45]
;     taskEXIT_CRITICAL();
700a7d34: f005 fd64    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x5ac8
;     taskENTER_CRITICAL();
700a7d38: f006 fcc2    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x6984
;         int8_t cRxLock = pxQueue->cRxLock;
700a7d3c: 9801         	ldr	r0, [sp, #0x4]
700a7d3e: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a7d42: f88d 0002    	strb.w	r0, [sp, #0x2]
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a7d46: e7ff         	b	0x700a7d48 <prvUnlockQueue+0x68> @ imm = #-0x2
700a7d48: f99d 0002    	ldrsb.w	r0, [sp, #0x2]
700a7d4c: 2801         	cmp	r0, #0x1
700a7d4e: db16         	blt	0x700a7d7e <prvUnlockQueue+0x9e> @ imm = #0x2c
700a7d50: e7ff         	b	0x700a7d52 <prvUnlockQueue+0x72> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a7d52: 9801         	ldr	r0, [sp, #0x4]
700a7d54: 6900         	ldr	r0, [r0, #0x10]
700a7d56: b180         	cbz	r0, 0x700a7d7a <prvUnlockQueue+0x9a> @ imm = #0x20
700a7d58: e7ff         	b	0x700a7d5a <prvUnlockQueue+0x7a> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a7d5a: 9801         	ldr	r0, [sp, #0x4]
700a7d5c: 3010         	adds	r0, #0x10
700a7d5e: f7ff fdf7    	bl	0x700a7950 <xTaskRemoveFromEventList> @ imm = #-0x412
700a7d62: b118         	cbz	r0, 0x700a7d6c <prvUnlockQueue+0x8c> @ imm = #0x6
700a7d64: e7ff         	b	0x700a7d66 <prvUnlockQueue+0x86> @ imm = #-0x2
;                     vTaskMissedYield();
700a7d66: f007 ff23    	bl	0x700afbb0 <vTaskMissedYield> @ imm = #0x7e46
;                 }
700a7d6a: e000         	b	0x700a7d6e <prvUnlockQueue+0x8e> @ imm = #0x0
700a7d6c: e7ff         	b	0x700a7d6e <prvUnlockQueue+0x8e> @ imm = #-0x2
;                 --cRxLock;
700a7d6e: f89d 0002    	ldrb.w	r0, [sp, #0x2]
700a7d72: 3801         	subs	r0, #0x1
700a7d74: f88d 0002    	strb.w	r0, [sp, #0x2]
;             }
700a7d78: e000         	b	0x700a7d7c <prvUnlockQueue+0x9c> @ imm = #0x0
;                 break;
700a7d7a: e000         	b	0x700a7d7e <prvUnlockQueue+0x9e> @ imm = #0x0
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a7d7c: e7e4         	b	0x700a7d48 <prvUnlockQueue+0x68> @ imm = #-0x38
;         pxQueue->cRxLock = queueUNLOCKED;
700a7d7e: 9901         	ldr	r1, [sp, #0x4]
700a7d80: 20ff         	movs	r0, #0xff
700a7d82: f881 0044    	strb.w	r0, [r1, #0x44]
;     taskEXIT_CRITICAL();
700a7d86: f005 fd3b    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x5a76
; }
700a7d8a: b002         	add	sp, #0x8
700a7d8c: bd80         	pop	{r7, pc}
700a7d8e: 0000         	movs	r0, r0

700a7d90 <SemaphoreP_constructBinary>:
; {
700a7d90: b580         	push	{r7, lr}
700a7d92: b086         	sub	sp, #0x18
700a7d94: 9005         	str	r0, [sp, #0x14]
700a7d96: 9104         	str	r1, [sp, #0x10]
700a7d98: 2000         	movs	r0, #0x0
;     SemaphoreP_Struct *pSemaphore = NULL;
700a7d9a: 9003         	str	r0, [sp, #0xc]
700a7d9c: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700a7da0: 9002         	str	r0, [sp, #0x8]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700a7da2: f641 10eb    	movw	r0, #0x19eb
700a7da6: f2c7 000b    	movt	r0, #0x700b
700a7daa: 4669         	mov	r1, sp
700a7dac: 6008         	str	r0, [r1]
700a7dae: f641 41cb    	movw	r1, #0x1ccb
700a7db2: f2c7 010b    	movt	r1, #0x700b
700a7db6: f641 6254    	movw	r2, #0x1e54
700a7dba: f2c7 020b    	movt	r2, #0x700b
700a7dbe: 2001         	movs	r0, #0x1
700a7dc0: 2332         	movs	r3, #0x32
700a7dc2: f002 fe85    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x2d0a
;     if(obj != NULL)
700a7dc6: 9805         	ldr	r0, [sp, #0x14]
700a7dc8: b128         	cbz	r0, 0x700a7dd6 <SemaphoreP_constructBinary+0x46> @ imm = #0xa
700a7dca: e7ff         	b	0x700a7dcc <SemaphoreP_constructBinary+0x3c> @ imm = #-0x2
;         pSemaphore = (SemaphoreP_Struct *)obj;
700a7dcc: 9805         	ldr	r0, [sp, #0x14]
700a7dce: 9003         	str	r0, [sp, #0xc]
700a7dd0: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a7dd2: 9002         	str	r0, [sp, #0x8]
;     }
700a7dd4: e7ff         	b	0x700a7dd6 <SemaphoreP_constructBinary+0x46> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a7dd6: 9802         	ldr	r0, [sp, #0x8]
700a7dd8: bb68         	cbnz	r0, 0x700a7e36 <SemaphoreP_constructBinary+0xa6> @ imm = #0x5a
700a7dda: e7ff         	b	0x700a7ddc <SemaphoreP_constructBinary+0x4c> @ imm = #-0x2
;         pSemaphore->isRecursiveMutex = 0;
700a7ddc: 9803         	ldr	r0, [sp, #0xc]
700a7dde: 2200         	movs	r2, #0x0
700a7de0: 6542         	str	r2, [r0, #0x54]
;         pSemaphore->semHndl = xSemaphoreCreateBinaryStatic(&pSemaphore->semObj);
700a7de2: 9b03         	ldr	r3, [sp, #0xc]
700a7de4: 4669         	mov	r1, sp
700a7de6: 2003         	movs	r0, #0x3
700a7de8: 6008         	str	r0, [r1]
700a7dea: 2001         	movs	r0, #0x1
700a7dec: 4611         	mov	r1, r2
700a7dee: f005 fb7f    	bl	0x700ad4f0 <xQueueGenericCreateStatic> @ imm = #0x56fe
700a7df2: 9903         	ldr	r1, [sp, #0xc]
700a7df4: 6508         	str	r0, [r1, #0x50]
;         if( pSemaphore->semHndl == NULL )
700a7df6: 9803         	ldr	r0, [sp, #0xc]
700a7df8: 6d00         	ldr	r0, [r0, #0x50]
700a7dfa: b920         	cbnz	r0, 0x700a7e06 <SemaphoreP_constructBinary+0x76> @ imm = #0x8
700a7dfc: e7ff         	b	0x700a7dfe <SemaphoreP_constructBinary+0x6e> @ imm = #-0x2
700a7dfe: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
700a7e02: 9002         	str	r0, [sp, #0x8]
;         }
700a7e04: e016         	b	0x700a7e34 <SemaphoreP_constructBinary+0xa4> @ imm = #0x2c
;             vQueueAddToRegistry(pSemaphore->semHndl, "Binary Sem (DPL)");
700a7e06: 9803         	ldr	r0, [sp, #0xc]
700a7e08: 6d00         	ldr	r0, [r0, #0x50]
700a7e0a: f242 01b0    	movw	r1, #0x20b0
700a7e0e: f2c7 010b    	movt	r1, #0x700b
700a7e12: f005 f8b5    	bl	0x700acf80 <vQueueAddToRegistry> @ imm = #0x516a
;             if(initCount == 1U)
700a7e16: 9804         	ldr	r0, [sp, #0x10]
700a7e18: 2801         	cmp	r0, #0x1
700a7e1a: d108         	bne	0x700a7e2e <SemaphoreP_constructBinary+0x9e> @ imm = #0x10
700a7e1c: e7ff         	b	0x700a7e1e <SemaphoreP_constructBinary+0x8e> @ imm = #-0x2
;                 (void)xSemaphoreGive(pSemaphore->semHndl);
700a7e1e: 9803         	ldr	r0, [sp, #0xc]
700a7e20: 6d00         	ldr	r0, [r0, #0x50]
700a7e22: 2300         	movs	r3, #0x0
700a7e24: 4619         	mov	r1, r3
700a7e26: 461a         	mov	r2, r3
700a7e28: f7fb f98a    	bl	0x700a3140 <xQueueGenericSend> @ imm = #-0x4cec
;             }
700a7e2c: e7ff         	b	0x700a7e2e <SemaphoreP_constructBinary+0x9e> @ imm = #-0x2
700a7e2e: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700a7e30: 9002         	str	r0, [sp, #0x8]
700a7e32: e7ff         	b	0x700a7e34 <SemaphoreP_constructBinary+0xa4> @ imm = #-0x2
;     }
700a7e34: e7ff         	b	0x700a7e36 <SemaphoreP_constructBinary+0xa6> @ imm = #-0x2
;     return status;
700a7e36: 9802         	ldr	r0, [sp, #0x8]
700a7e38: b006         	add	sp, #0x18
700a7e3a: bd80         	pop	{r7, pc}
700a7e3c: 0000         	movs	r0, r0
700a7e3e: 0000         	movs	r0, r0

700a7e40 <UdmaChRxPrms_init>:
; {
700a7e40: b083         	sub	sp, #0xc
700a7e42: 9002         	str	r0, [sp, #0x8]
700a7e44: 9101         	str	r1, [sp, #0x4]
;     if(NULL_PTR != rxPrms)
700a7e46: 9802         	ldr	r0, [sp, #0x8]
700a7e48: 2800         	cmp	r0, #0x0
700a7e4a: d04d         	beq	0x700a7ee8 <UdmaChRxPrms_init+0xa8> @ imm = #0x9a
700a7e4c: e7ff         	b	0x700a7e4e <UdmaChRxPrms_init+0xe> @ imm = #-0x2
;         rxPrms->pauseOnError        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a7e4e: 9902         	ldr	r1, [sp, #0x8]
700a7e50: 2000         	movs	r0, #0x0
700a7e52: 7008         	strb	r0, [r1]
;         rxPrms->addrType            = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a7e54: 9902         	ldr	r1, [sp, #0x8]
700a7e56: 7048         	strb	r0, [r1, #0x1]
;         rxPrms->chanType            = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a7e58: 9902         	ldr	r1, [sp, #0x8]
700a7e5a: 2002         	movs	r0, #0x2
700a7e5c: 7088         	strb	r0, [r1, #0x2]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a7e5e: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a7e62: 0740         	lsls	r0, r0, #0x1d
700a7e64: 2800         	cmp	r0, #0x0
700a7e66: d504         	bpl	0x700a7e72 <UdmaChRxPrms_init+0x32> @ imm = #0x8
700a7e68: e7ff         	b	0x700a7e6a <UdmaChRxPrms_init+0x2a> @ imm = #-0x2
;             rxPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a7e6a: 9902         	ldr	r1, [sp, #0x8]
700a7e6c: 200c         	movs	r0, #0xc
700a7e6e: 7088         	strb	r0, [r1, #0x2]
;         }
700a7e70: e7ff         	b	0x700a7e72 <UdmaChRxPrms_init+0x32> @ imm = #-0x2
;         rxPrms->fetchWordSize       = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a7e72: 9902         	ldr	r1, [sp, #0x8]
700a7e74: 2010         	movs	r0, #0x10
700a7e76: 8088         	strh	r0, [r1, #0x4]
;         rxPrms->busPriority         = UDMA_DEFAULT_RX_CH_BUS_PRIORITY;
700a7e78: 9902         	ldr	r1, [sp, #0x8]
700a7e7a: 2004         	movs	r0, #0x4
700a7e7c: 7188         	strb	r0, [r1, #0x6]
;         rxPrms->busQos              = UDMA_DEFAULT_RX_CH_BUS_QOS;
700a7e7e: 9902         	ldr	r1, [sp, #0x8]
700a7e80: 71c8         	strb	r0, [r1, #0x7]
;         rxPrms->busOrderId          = UDMA_DEFAULT_RX_CH_BUS_ORDERID;
700a7e82: 9802         	ldr	r0, [sp, #0x8]
700a7e84: 2100         	movs	r1, #0x0
700a7e86: 9100         	str	r1, [sp]
700a7e88: 7201         	strb	r1, [r0, #0x8]
;         rxPrms->dmaPriority         = UDMA_DEFAULT_RX_CH_DMA_PRIORITY;
700a7e8a: 9a02         	ldr	r2, [sp, #0x8]
700a7e8c: 2001         	movs	r0, #0x1
700a7e8e: 7250         	strb	r0, [r2, #0x9]
;         rxPrms->flowIdFwRangeStart  = 0U;       /* Reset value - to use default flow */
700a7e90: 9a02         	ldr	r2, [sp, #0x8]
700a7e92: 8151         	strh	r1, [r2, #0xa]
;         rxPrms->flowIdFwRangeCnt    = 0U;       /* Reset value - to use default flow */
700a7e94: 9a02         	ldr	r2, [sp, #0x8]
700a7e96: 8191         	strh	r1, [r2, #0xc]
;         rxPrms->flowEInfoPresent    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;       /* Default no EINFO */
700a7e98: 9a02         	ldr	r2, [sp, #0x8]
700a7e9a: 7391         	strb	r1, [r2, #0xe]
;         rxPrms->flowPsInfoPresent   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;      /* Default no PSINFO */
700a7e9c: 9a02         	ldr	r2, [sp, #0x8]
700a7e9e: 73d1         	strb	r1, [r2, #0xf]
;         rxPrms->flowErrorHandling   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;       /* Default Re-try descriptor allocation operation on starvation error */
700a7ea0: 9a02         	ldr	r2, [sp, #0x8]
700a7ea2: 7410         	strb	r0, [r2, #0x10]
;         rxPrms->flowSopOffset       = 0U;      /* Default SOP offset is 0 */
700a7ea4: 9a02         	ldr	r2, [sp, #0x8]
700a7ea6: 7451         	strb	r1, [r2, #0x11]
;         rxPrms->ignoreShortPkts     = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a7ea8: 9a02         	ldr	r2, [sp, #0x8]
700a7eaa: 7491         	strb	r1, [r2, #0x12]
;         rxPrms->ignoreLongPkts      = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a7eac: 9a02         	ldr	r2, [sp, #0x8]
700a7eae: 74d1         	strb	r1, [r2, #0x13]
;         rxPrms->configDefaultFlow   = TRUE;
700a7eb0: 9902         	ldr	r1, [sp, #0x8]
700a7eb2: 6148         	str	r0, [r1, #0x14]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a7eb4: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a7eb8: 0600         	lsls	r0, r0, #0x18
700a7eba: 2800         	cmp	r0, #0x0
700a7ebc: d504         	bpl	0x700a7ec8 <UdmaChRxPrms_init+0x88> @ imm = #0x8
700a7ebe: e7ff         	b	0x700a7ec0 <UdmaChRxPrms_init+0x80> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a7ec0: 9902         	ldr	r1, [sp, #0x8]
700a7ec2: 2003         	movs	r0, #0x3
700a7ec4: 7608         	strb	r0, [r1, #0x18]
;         }
700a7ec6: e00e         	b	0x700a7ee6 <UdmaChRxPrms_init+0xa6> @ imm = #0x1c
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a7ec8: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a7ecc: 0640         	lsls	r0, r0, #0x19
700a7ece: 2800         	cmp	r0, #0x0
700a7ed0: d504         	bpl	0x700a7edc <UdmaChRxPrms_init+0x9c> @ imm = #0x8
700a7ed2: e7ff         	b	0x700a7ed4 <UdmaChRxPrms_init+0x94> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a7ed4: 9902         	ldr	r1, [sp, #0x8]
700a7ed6: 2003         	movs	r0, #0x3
700a7ed8: 7608         	strb	r0, [r1, #0x18]
;         }
700a7eda: e003         	b	0x700a7ee4 <UdmaChRxPrms_init+0xa4> @ imm = #0x6
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a7edc: 9902         	ldr	r1, [sp, #0x8]
700a7ede: 2001         	movs	r0, #0x1
700a7ee0: 7608         	strb	r0, [r1, #0x18]
700a7ee2: e7ff         	b	0x700a7ee4 <UdmaChRxPrms_init+0xa4> @ imm = #-0x2
700a7ee4: e7ff         	b	0x700a7ee6 <UdmaChRxPrms_init+0xa6> @ imm = #-0x2
;     }
700a7ee6: e7ff         	b	0x700a7ee8 <UdmaChRxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a7ee8: b003         	add	sp, #0xc
700a7eea: 4770         	bx	lr
700a7eec: 0000         	movs	r0, r0
700a7eee: 0000         	movs	r0, r0

700a7ef0 <UdmaChTxPrms_init>:
; {
700a7ef0: b082         	sub	sp, #0x8
700a7ef2: 9001         	str	r0, [sp, #0x4]
700a7ef4: 9100         	str	r1, [sp]
;     if(NULL_PTR != txPrms)
700a7ef6: 9801         	ldr	r0, [sp, #0x4]
700a7ef8: 2800         	cmp	r0, #0x0
700a7efa: d04d         	beq	0x700a7f98 <UdmaChTxPrms_init+0xa8> @ imm = #0x9a
700a7efc: e7ff         	b	0x700a7efe <UdmaChTxPrms_init+0xe> @ imm = #-0x2
;         txPrms->pauseOnError    = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a7efe: 9901         	ldr	r1, [sp, #0x4]
700a7f00: 2000         	movs	r0, #0x0
700a7f02: 7008         	strb	r0, [r1]
;         txPrms->filterEinfo     = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_EINFO_DISABLED;
700a7f04: 9901         	ldr	r1, [sp, #0x4]
700a7f06: 7048         	strb	r0, [r1, #0x1]
;         txPrms->filterPsWords   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_PSWORDS_DISABLED;
700a7f08: 9901         	ldr	r1, [sp, #0x4]
700a7f0a: 7088         	strb	r0, [r1, #0x2]
;         txPrms->addrType        = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a7f0c: 9901         	ldr	r1, [sp, #0x4]
700a7f0e: 70c8         	strb	r0, [r1, #0x3]
;         txPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a7f10: 9901         	ldr	r1, [sp, #0x4]
700a7f12: 2002         	movs	r0, #0x2
700a7f14: 7108         	strb	r0, [r1, #0x4]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a7f16: f89d 0000    	ldrb.w	r0, [sp]
700a7f1a: 0740         	lsls	r0, r0, #0x1d
700a7f1c: 2800         	cmp	r0, #0x0
700a7f1e: d504         	bpl	0x700a7f2a <UdmaChTxPrms_init+0x3a> @ imm = #0x8
700a7f20: e7ff         	b	0x700a7f22 <UdmaChTxPrms_init+0x32> @ imm = #-0x2
;             txPrms->chanType    = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a7f22: 9901         	ldr	r1, [sp, #0x4]
700a7f24: 200c         	movs	r0, #0xc
700a7f26: 7108         	strb	r0, [r1, #0x4]
;         }
700a7f28: e7ff         	b	0x700a7f2a <UdmaChTxPrms_init+0x3a> @ imm = #-0x2
;         txPrms->fetchWordSize   = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a7f2a: 9901         	ldr	r1, [sp, #0x4]
700a7f2c: 2010         	movs	r0, #0x10
700a7f2e: 80c8         	strh	r0, [r1, #0x6]
;         txPrms->busPriority     = UDMA_DEFAULT_TX_CH_BUS_PRIORITY;
700a7f30: 9901         	ldr	r1, [sp, #0x4]
700a7f32: 2004         	movs	r0, #0x4
700a7f34: 7208         	strb	r0, [r1, #0x8]
;         txPrms->busQos          = UDMA_DEFAULT_TX_CH_BUS_QOS;
700a7f36: 9901         	ldr	r1, [sp, #0x4]
700a7f38: 7248         	strb	r0, [r1, #0x9]
;         txPrms->busOrderId      = UDMA_DEFAULT_TX_CH_BUS_ORDERID;
700a7f3a: 9901         	ldr	r1, [sp, #0x4]
700a7f3c: 2000         	movs	r0, #0x0
700a7f3e: 7288         	strb	r0, [r1, #0xa]
;         txPrms->dmaPriority     = UDMA_DEFAULT_TX_CH_DMA_PRIORITY;
700a7f40: 9a01         	ldr	r2, [sp, #0x4]
700a7f42: 2101         	movs	r1, #0x1
700a7f44: 72d1         	strb	r1, [r2, #0xb]
;         txPrms->txCredit        = 0U;
700a7f46: 9901         	ldr	r1, [sp, #0x4]
700a7f48: 7308         	strb	r0, [r1, #0xc]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a7f4a: f89d 0000    	ldrb.w	r0, [sp]
700a7f4e: ea4f 6000    	lsl.w	r0, r0, #0x18
700a7f52: 2800         	cmp	r0, #0x0
700a7f54: d507         	bpl	0x700a7f66 <UdmaChTxPrms_init+0x76> @ imm = #0xe
700a7f56: e7ff         	b	0x700a7f58 <UdmaChTxPrms_init+0x68> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_UHC_CHANS_FDEPTH;
700a7f58: 9901         	ldr	r1, [sp, #0x4]
700a7f5a: 2000         	movs	r0, #0x0
700a7f5c: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a7f5e: 9901         	ldr	r1, [sp, #0x4]
700a7f60: 2003         	movs	r0, #0x3
700a7f62: 7408         	strb	r0, [r1, #0x10]
;         }
700a7f64: e014         	b	0x700a7f90 <UdmaChTxPrms_init+0xa0> @ imm = #0x28
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a7f66: f89d 0000    	ldrb.w	r0, [sp]
700a7f6a: 0640         	lsls	r0, r0, #0x19
700a7f6c: 2800         	cmp	r0, #0x0
700a7f6e: d507         	bpl	0x700a7f80 <UdmaChTxPrms_init+0x90> @ imm = #0xe
700a7f70: e7ff         	b	0x700a7f72 <UdmaChTxPrms_init+0x82> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_HC_CHANS_FDEPTH;
700a7f72: 9901         	ldr	r1, [sp, #0x4]
700a7f74: 2000         	movs	r0, #0x0
700a7f76: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a7f78: 9901         	ldr	r1, [sp, #0x4]
700a7f7a: 2003         	movs	r0, #0x3
700a7f7c: 7408         	strb	r0, [r1, #0x10]
;         }
700a7f7e: e006         	b	0x700a7f8e <UdmaChTxPrms_init+0x9e> @ imm = #0xc
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_CHANS_FDEPTH;
700a7f80: 9901         	ldr	r1, [sp, #0x4]
700a7f82: 20c0         	movs	r0, #0xc0
700a7f84: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a7f86: 9901         	ldr	r1, [sp, #0x4]
700a7f88: 2001         	movs	r0, #0x1
700a7f8a: 7408         	strb	r0, [r1, #0x10]
700a7f8c: e7ff         	b	0x700a7f8e <UdmaChTxPrms_init+0x9e> @ imm = #-0x2
700a7f8e: e7ff         	b	0x700a7f90 <UdmaChTxPrms_init+0xa0> @ imm = #-0x2
;         txPrms->supressTdCqPkt  = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_DISABLED;
700a7f90: 9901         	ldr	r1, [sp, #0x4]
700a7f92: 2000         	movs	r0, #0x0
700a7f94: 7448         	strb	r0, [r1, #0x11]
;     }
700a7f96: e7ff         	b	0x700a7f98 <UdmaChTxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a7f98: b002         	add	sp, #0x8
700a7f9a: 4770         	bx	lr
700a7f9c: 0000         	movs	r0, r0
700a7f9e: 0000         	movs	r0, r0

700a7fa0 <Udma_chDisable>:
; {
700a7fa0: b580         	push	{r7, lr}
700a7fa2: b086         	sub	sp, #0x18
700a7fa4: 9005         	str	r0, [sp, #0x14]
700a7fa6: 9104         	str	r1, [sp, #0x10]
700a7fa8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a7faa: 9003         	str	r0, [sp, #0xc]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a7fac: 9805         	ldr	r0, [sp, #0x14]
700a7fae: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a7fb0: 9801         	ldr	r0, [sp, #0x4]
700a7fb2: b150         	cbz	r0, 0x700a7fca <Udma_chDisable+0x2a> @ imm = #0x14
700a7fb4: e7ff         	b	0x700a7fb6 <Udma_chDisable+0x16> @ imm = #-0x2
700a7fb6: 9801         	ldr	r0, [sp, #0x4]
700a7fb8: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a7fbc: f64a 31cd    	movw	r1, #0xabcd
700a7fc0: f6ca 31dc    	movt	r1, #0xabdc
700a7fc4: 4288         	cmp	r0, r1
700a7fc6: d004         	beq	0x700a7fd2 <Udma_chDisable+0x32> @ imm = #0x8
700a7fc8: e7ff         	b	0x700a7fca <Udma_chDisable+0x2a> @ imm = #-0x2
700a7fca: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a7fce: 9003         	str	r0, [sp, #0xc]
;     }
700a7fd0: e7ff         	b	0x700a7fd2 <Udma_chDisable+0x32> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7fd2: 9803         	ldr	r0, [sp, #0xc]
700a7fd4: b9a8         	cbnz	r0, 0x700a8002 <Udma_chDisable+0x62> @ imm = #0x2a
700a7fd6: e7ff         	b	0x700a7fd8 <Udma_chDisable+0x38> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a7fd8: 9801         	ldr	r0, [sp, #0x4]
700a7fda: 6e80         	ldr	r0, [r0, #0x68]
700a7fdc: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a7fde: 9802         	ldr	r0, [sp, #0x8]
700a7fe0: b150         	cbz	r0, 0x700a7ff8 <Udma_chDisable+0x58> @ imm = #0x14
700a7fe2: e7ff         	b	0x700a7fe4 <Udma_chDisable+0x44> @ imm = #-0x2
700a7fe4: 9802         	ldr	r0, [sp, #0x8]
700a7fe6: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7fea: f64a 31cd    	movw	r1, #0xabcd
700a7fee: f6ca 31dc    	movt	r1, #0xabdc
700a7ff2: 4288         	cmp	r0, r1
700a7ff4: d004         	beq	0x700a8000 <Udma_chDisable+0x60> @ imm = #0x8
700a7ff6: e7ff         	b	0x700a7ff8 <Udma_chDisable+0x58> @ imm = #-0x2
700a7ff8: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7ffc: 9003         	str	r0, [sp, #0xc]
;         }
700a7ffe: e7ff         	b	0x700a8000 <Udma_chDisable+0x60> @ imm = #-0x2
;     }
700a8000: e7ff         	b	0x700a8002 <Udma_chDisable+0x62> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a8002: 9803         	ldr	r0, [sp, #0xc]
700a8004: b9f8         	cbnz	r0, 0x700a8046 <Udma_chDisable+0xa6> @ imm = #0x3e
700a8006: e7ff         	b	0x700a8008 <Udma_chDisable+0x68> @ imm = #-0x2
;         if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a8008: 9801         	ldr	r0, [sp, #0x4]
700a800a: 7800         	ldrb	r0, [r0]
700a800c: 0740         	lsls	r0, r0, #0x1d
700a800e: 2800         	cmp	r0, #0x0
700a8010: d506         	bpl	0x700a8020 <Udma_chDisable+0x80> @ imm = #0xc
700a8012: e7ff         	b	0x700a8014 <Udma_chDisable+0x74> @ imm = #-0x2
;             retVal = Udma_chDisableBlkCpyChan(chHandleInt, timeout);
700a8014: 9801         	ldr	r0, [sp, #0x4]
700a8016: 9904         	ldr	r1, [sp, #0x10]
700a8018: f7f7 f802    	bl	0x7009f020 <Udma_chDisableBlkCpyChan> @ imm = #-0x8ffc
700a801c: 9003         	str	r0, [sp, #0xc]
;         }
700a801e: e011         	b	0x700a8044 <Udma_chDisable+0xa4> @ imm = #0x22
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a8020: 9801         	ldr	r0, [sp, #0x4]
700a8022: 7800         	ldrb	r0, [r0]
700a8024: 07c0         	lsls	r0, r0, #0x1f
700a8026: b130         	cbz	r0, 0x700a8036 <Udma_chDisable+0x96> @ imm = #0xc
700a8028: e7ff         	b	0x700a802a <Udma_chDisable+0x8a> @ imm = #-0x2
;                 retVal = Udma_chDisableTxChan(chHandleInt, timeout);
700a802a: 9801         	ldr	r0, [sp, #0x4]
700a802c: 9904         	ldr	r1, [sp, #0x10]
700a802e: f7f4 fa3f    	bl	0x7009c4b0 <Udma_chDisableTxChan> @ imm = #-0xbb82
700a8032: 9003         	str	r0, [sp, #0xc]
;             }
700a8034: e005         	b	0x700a8042 <Udma_chDisable+0xa2> @ imm = #0xa
;                 retVal = Udma_chDisableRxChan(chHandleInt, timeout);
700a8036: 9801         	ldr	r0, [sp, #0x4]
700a8038: 9904         	ldr	r1, [sp, #0x10]
700a803a: f7f5 fa09    	bl	0x7009d450 <Udma_chDisableRxChan> @ imm = #-0xabee
700a803e: 9003         	str	r0, [sp, #0xc]
700a8040: e7ff         	b	0x700a8042 <Udma_chDisable+0xa2> @ imm = #-0x2
700a8042: e7ff         	b	0x700a8044 <Udma_chDisable+0xa4> @ imm = #-0x2
;     }
700a8044: e7ff         	b	0x700a8046 <Udma_chDisable+0xa6> @ imm = #-0x2
;     return (retVal);
700a8046: 9803         	ldr	r0, [sp, #0xc]
700a8048: b006         	add	sp, #0x18
700a804a: bd80         	pop	{r7, pc}
700a804c: 0000         	movs	r0, r0
700a804e: 0000         	movs	r0, r0

700a8050 <CSL_bcdmaChanOpSetChanPause>:
; {
700a8050: b580         	push	{r7, lr}
700a8052: b086         	sub	sp, #0x18
700a8054: 9005         	str	r0, [sp, #0x14]
700a8056: 9104         	str	r1, [sp, #0x10]
700a8058: 9203         	str	r2, [sp, #0xc]
700a805a: f88d 300b    	strb.w	r3, [sp, #0xb]
700a805e: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a8060: 9001         	str	r0, [sp, #0x4]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
700a8062: 9805         	ldr	r0, [sp, #0x14]
700a8064: 9904         	ldr	r1, [sp, #0x10]
700a8066: 9a03         	ldr	r2, [sp, #0xc]
700a8068: f002 fbf2    	bl	0x700aa850 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x27e4
700a806c: b920         	cbnz	r0, 0x700a8078 <CSL_bcdmaChanOpSetChanPause+0x28> @ imm = #0x8
700a806e: e7ff         	b	0x700a8070 <CSL_bcdmaChanOpSetChanPause+0x20> @ imm = #-0x2
700a8070: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a8074: 9001         	str	r0, [sp, #0x4]
;     }
700a8076: e03d         	b	0x700a80f4 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #0x7a
;         switch( chanType )
700a8078: 9804         	ldr	r0, [sp, #0x10]
700a807a: 9000         	str	r0, [sp]
700a807c: b140         	cbz	r0, 0x700a8090 <CSL_bcdmaChanOpSetChanPause+0x40> @ imm = #0x10
700a807e: e7ff         	b	0x700a8080 <CSL_bcdmaChanOpSetChanPause+0x30> @ imm = #-0x2
700a8080: 9800         	ldr	r0, [sp]
700a8082: 2801         	cmp	r0, #0x1
700a8084: d013         	beq	0x700a80ae <CSL_bcdmaChanOpSetChanPause+0x5e> @ imm = #0x26
700a8086: e7ff         	b	0x700a8088 <CSL_bcdmaChanOpSetChanPause+0x38> @ imm = #-0x2
700a8088: 9800         	ldr	r0, [sp]
700a808a: 2802         	cmp	r0, #0x2
700a808c: d01e         	beq	0x700a80cc <CSL_bcdmaChanOpSetChanPause+0x7c> @ imm = #0x3c
700a808e: e02c         	b	0x700a80ea <CSL_bcdmaChanOpSetChanPause+0x9a> @ imm = #0x58
;                 CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a8090: 9805         	ldr	r0, [sp, #0x14]
700a8092: 6880         	ldr	r0, [r0, #0x8]
700a8094: 9903         	ldr	r1, [sp, #0xc]
700a8096: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a809a: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a809e: f001 0301    	and	r3, r1, #0x1
700a80a2: f04f 5100    	mov.w	r1, #0x20000000
700a80a6: 221d         	movs	r2, #0x1d
700a80a8: f006 f892    	bl	0x700ae1d0 <CSL_REG32_FINS_RAW> @ imm = #0x6124
;                 break;
700a80ac: e021         	b	0x700a80f2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x42
;                 CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a80ae: 9805         	ldr	r0, [sp, #0x14]
700a80b0: 6900         	ldr	r0, [r0, #0x10]
700a80b2: 9903         	ldr	r1, [sp, #0xc]
700a80b4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a80b8: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a80bc: f001 0301    	and	r3, r1, #0x1
700a80c0: f04f 5100    	mov.w	r1, #0x20000000
700a80c4: 221d         	movs	r2, #0x1d
700a80c6: f006 f883    	bl	0x700ae1d0 <CSL_REG32_FINS_RAW> @ imm = #0x6106
;                 break;
700a80ca: e012         	b	0x700a80f2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x24
;                 CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a80cc: 9805         	ldr	r0, [sp, #0x14]
700a80ce: 6980         	ldr	r0, [r0, #0x18]
700a80d0: 9903         	ldr	r1, [sp, #0xc]
700a80d2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a80d6: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a80da: f001 0301    	and	r3, r1, #0x1
700a80de: f04f 5100    	mov.w	r1, #0x20000000
700a80e2: 221d         	movs	r2, #0x1d
700a80e4: f006 f874    	bl	0x700ae1d0 <CSL_REG32_FINS_RAW> @ imm = #0x60e8
;                 break;
700a80e8: e003         	b	0x700a80f2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x6
700a80ea: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a80ee: 9001         	str	r0, [sp, #0x4]
;                 break;
700a80f0: e7ff         	b	0x700a80f2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #-0x2
700a80f2: e7ff         	b	0x700a80f4 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #-0x2
;     return retVal;
700a80f4: 9801         	ldr	r0, [sp, #0x4]
700a80f6: b006         	add	sp, #0x18
700a80f8: bd80         	pop	{r7, pc}
700a80fa: 0000         	movs	r0, r0
700a80fc: 0000         	movs	r0, r0
700a80fe: 0000         	movs	r0, r0

700a8100 <CSL_bcdmaChanOpSetChanRT>:
; {
700a8100: b580         	push	{r7, lr}
700a8102: b088         	sub	sp, #0x20
700a8104: 9007         	str	r0, [sp, #0x1c]
700a8106: 9106         	str	r1, [sp, #0x18]
700a8108: 9205         	str	r2, [sp, #0x14]
700a810a: 9304         	str	r3, [sp, #0x10]
700a810c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a810e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a8110: 9804         	ldr	r0, [sp, #0x10]
700a8112: b920         	cbnz	r0, 0x700a811e <CSL_bcdmaChanOpSetChanRT+0x1e> @ imm = #0x8
700a8114: e7ff         	b	0x700a8116 <CSL_bcdmaChanOpSetChanRT+0x16> @ imm = #-0x2
700a8116: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a811a: 9003         	str	r0, [sp, #0xc]
;     }
700a811c: e042         	b	0x700a81a4 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #0x84
;         CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a811e: 9804         	ldr	r0, [sp, #0x10]
700a8120: 9001         	str	r0, [sp, #0x4]
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a8122: 9801         	ldr	r0, [sp, #0x4]
700a8124: 6803         	ldr	r3, [r0]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a8126: f8d0 c004    	ldr.w	r12, [r0, #0x4]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a812a: 6881         	ldr	r1, [r0, #0x8]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a812c: 6902         	ldr	r2, [r0, #0x10]
700a812e: f04f 4080    	mov.w	r0, #0x40000000
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a8132: ea00 708c    	and.w	r0, r0, r12, lsl #30
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a8136: ea40 70c3    	orr.w	r0, r0, r3, lsl #31
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a813a: f002 0201    	and	r2, r2, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a813e: ea40 7002    	orr.w	r0, r0, r2, lsl #28
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a8142: f001 0101    	and	r1, r1, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a8146: ea40 7041    	orr.w	r0, r0, r1, lsl #29
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a814a: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a814c: 9806         	ldr	r0, [sp, #0x18]
700a814e: 9000         	str	r0, [sp]
700a8150: b140         	cbz	r0, 0x700a8164 <CSL_bcdmaChanOpSetChanRT+0x64> @ imm = #0x10
700a8152: e7ff         	b	0x700a8154 <CSL_bcdmaChanOpSetChanRT+0x54> @ imm = #-0x2
700a8154: 9800         	ldr	r0, [sp]
700a8156: 2801         	cmp	r0, #0x1
700a8158: d00d         	beq	0x700a8176 <CSL_bcdmaChanOpSetChanRT+0x76> @ imm = #0x1a
700a815a: e7ff         	b	0x700a815c <CSL_bcdmaChanOpSetChanRT+0x5c> @ imm = #-0x2
700a815c: 9800         	ldr	r0, [sp]
700a815e: 2802         	cmp	r0, #0x2
700a8160: d012         	beq	0x700a8188 <CSL_bcdmaChanOpSetChanRT+0x88> @ imm = #0x24
700a8162: e01a         	b	0x700a819a <CSL_bcdmaChanOpSetChanRT+0x9a> @ imm = #0x34
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, val );
700a8164: 9807         	ldr	r0, [sp, #0x1c]
700a8166: 6880         	ldr	r0, [r0, #0x8]
700a8168: 9905         	ldr	r1, [sp, #0x14]
700a816a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a816e: 9902         	ldr	r1, [sp, #0x8]
700a8170: f7f3 ffce    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0xc064
;                 break;
700a8174: e015         	b	0x700a81a2 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x2a
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, val );
700a8176: 9807         	ldr	r0, [sp, #0x1c]
700a8178: 6900         	ldr	r0, [r0, #0x10]
700a817a: 9905         	ldr	r1, [sp, #0x14]
700a817c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8180: 9902         	ldr	r1, [sp, #0x8]
700a8182: f7f3 ffc5    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0xc076
;                 break;
700a8186: e00c         	b	0x700a81a2 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x18
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, val );
700a8188: 9807         	ldr	r0, [sp, #0x1c]
700a818a: 6980         	ldr	r0, [r0, #0x18]
700a818c: 9905         	ldr	r1, [sp, #0x14]
700a818e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8192: 9902         	ldr	r1, [sp, #0x8]
700a8194: f7f3 ffbc    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0xc088
;                 break;
700a8198: e003         	b	0x700a81a2 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x6
700a819a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a819e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a81a0: e7ff         	b	0x700a81a2 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #-0x2
700a81a2: e7ff         	b	0x700a81a4 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #-0x2
;     return retVal;
700a81a4: 9803         	ldr	r0, [sp, #0xc]
700a81a6: b008         	add	sp, #0x20
700a81a8: bd80         	pop	{r7, pc}
700a81aa: 0000         	movs	r0, r0
700a81ac: 0000         	movs	r0, r0
700a81ae: 0000         	movs	r0, r0

700a81b0 <Sciclient_rmIrInpRomMapped>:
; {
700a81b0: b082         	sub	sp, #0x8
700a81b2: 9001         	str	r0, [sp, #0x4]
700a81b4: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a81b8: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a81ba: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a81be: 9801         	ldr	r0, [sp, #0x4]
700a81c0: 6900         	ldr	r0, [r0, #0x10]
700a81c2: 2800         	cmp	r0, #0x0
700a81c4: d042         	beq	0x700a824c <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #0x84
700a81c6: e7ff         	b	0x700a81c8 <Sciclient_rmIrInpRomMapped+0x18> @ imm = #-0x2
700a81c8: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a81ca: f88d 0000    	strb.w	r0, [sp]
700a81ce: e7ff         	b	0x700a81d0 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x2
700a81d0: f89d 0000    	ldrb.w	r0, [sp]
700a81d4: 9901         	ldr	r1, [sp, #0x4]
700a81d6: 7d09         	ldrb	r1, [r1, #0x14]
700a81d8: 4288         	cmp	r0, r1
700a81da: da36         	bge	0x700a824a <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0x6c
700a81dc: e7ff         	b	0x700a81de <Sciclient_rmIrInpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a81de: 9801         	ldr	r0, [sp, #0x4]
700a81e0: 6900         	ldr	r0, [r0, #0x10]
700a81e2: f89d 1000    	ldrb.w	r1, [sp]
700a81e6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a81ea: 7980         	ldrb	r0, [r0, #0x6]
700a81ec: 07c0         	lsls	r0, r0, #0x1f
700a81ee: bb28         	cbnz	r0, 0x700a823c <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x4a
700a81f0: e7ff         	b	0x700a81f2 <Sciclient_rmIrInpRomMapped+0x42> @ imm = #-0x2
;                 (inp >= inst->rom_usage[i].inp_start) &&
700a81f2: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a81f6: 9901         	ldr	r1, [sp, #0x4]
700a81f8: 6909         	ldr	r1, [r1, #0x10]
700a81fa: f89d 2000    	ldrb.w	r2, [sp]
700a81fe: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700a8202: 4288         	cmp	r0, r1
700a8204: db1a         	blt	0x700a823c <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x34
700a8206: e7ff         	b	0x700a8208 <Sciclient_rmIrInpRomMapped+0x58> @ imm = #-0x2
;                 (inp < (inst->rom_usage[i].inp_start +
700a8208: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a820c: 9901         	ldr	r1, [sp, #0x4]
700a820e: 6909         	ldr	r1, [r1, #0x10]
700a8210: f89d 3000    	ldrb.w	r3, [sp]
700a8214: eb01 02c3    	add.w	r2, r1, r3, lsl #3
700a8218: f831 1033    	ldrh.w	r1, [r1, r3, lsl #3]
;                         inst->rom_usage[i].length))) {
700a821c: 8892         	ldrh	r2, [r2, #0x4]
;                 (inp < (inst->rom_usage[i].inp_start +
700a821e: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a8220: 4288         	cmp	r0, r1
700a8222: da0b         	bge	0x700a823c <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x16
700a8224: e7ff         	b	0x700a8226 <Sciclient_rmIrInpRomMapped+0x76> @ imm = #-0x2
700a8226: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a8228: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a822c: 9901         	ldr	r1, [sp, #0x4]
700a822e: 6909         	ldr	r1, [r1, #0x10]
700a8230: f89d 2000    	ldrb.w	r2, [sp]
700a8234: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a8238: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a823a: e006         	b	0x700a824a <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0xc
;         }
700a823c: e7ff         	b	0x700a823e <Sciclient_rmIrInpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a823e: f89d 0000    	ldrb.w	r0, [sp]
700a8242: 3001         	adds	r0, #0x1
700a8244: f88d 0000    	strb.w	r0, [sp]
700a8248: e7c2         	b	0x700a81d0 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x7c
;     }
700a824a: e7ff         	b	0x700a824c <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a824c: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a8250: f000 0001    	and	r0, r0, #0x1
700a8254: b002         	add	sp, #0x8
700a8256: 4770         	bx	lr
		...

700a8260 <Sciclient_rmIrOutpRomMapped>:
; {
700a8260: b082         	sub	sp, #0x8
700a8262: 9001         	str	r0, [sp, #0x4]
700a8264: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a8268: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a826a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a826e: 9801         	ldr	r0, [sp, #0x4]
700a8270: 6900         	ldr	r0, [r0, #0x10]
700a8272: 2800         	cmp	r0, #0x0
700a8274: d042         	beq	0x700a82fc <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #0x84
700a8276: e7ff         	b	0x700a8278 <Sciclient_rmIrOutpRomMapped+0x18> @ imm = #-0x2
700a8278: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a827a: f88d 0000    	strb.w	r0, [sp]
700a827e: e7ff         	b	0x700a8280 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x2
700a8280: f89d 0000    	ldrb.w	r0, [sp]
700a8284: 9901         	ldr	r1, [sp, #0x4]
700a8286: 7d09         	ldrb	r1, [r1, #0x14]
700a8288: 4288         	cmp	r0, r1
700a828a: da36         	bge	0x700a82fa <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0x6c
700a828c: e7ff         	b	0x700a828e <Sciclient_rmIrOutpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a828e: 9801         	ldr	r0, [sp, #0x4]
700a8290: 6900         	ldr	r0, [r0, #0x10]
700a8292: f89d 1000    	ldrb.w	r1, [sp]
700a8296: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a829a: 7980         	ldrb	r0, [r0, #0x6]
700a829c: 07c0         	lsls	r0, r0, #0x1f
700a829e: bb28         	cbnz	r0, 0x700a82ec <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x4a
700a82a0: e7ff         	b	0x700a82a2 <Sciclient_rmIrOutpRomMapped+0x42> @ imm = #-0x2
;                 (outp >= inst->rom_usage[i].outp_start) &&
700a82a2: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a82a6: 9901         	ldr	r1, [sp, #0x4]
700a82a8: 6909         	ldr	r1, [r1, #0x10]
700a82aa: f89d 2000    	ldrb.w	r2, [sp]
700a82ae: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a82b2: 8849         	ldrh	r1, [r1, #0x2]
700a82b4: 4288         	cmp	r0, r1
700a82b6: db19         	blt	0x700a82ec <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x32
700a82b8: e7ff         	b	0x700a82ba <Sciclient_rmIrOutpRomMapped+0x5a> @ imm = #-0x2
;                 (outp < (inst->rom_usage[i].outp_start +
700a82ba: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a82be: 9901         	ldr	r1, [sp, #0x4]
700a82c0: 6909         	ldr	r1, [r1, #0x10]
700a82c2: f89d 2000    	ldrb.w	r2, [sp]
700a82c6: eb01 02c2    	add.w	r2, r1, r2, lsl #3
700a82ca: 8851         	ldrh	r1, [r2, #0x2]
;                         inst->rom_usage[i].length))) {
700a82cc: 8892         	ldrh	r2, [r2, #0x4]
;                 (outp < (inst->rom_usage[i].outp_start +
700a82ce: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a82d0: 4288         	cmp	r0, r1
700a82d2: da0b         	bge	0x700a82ec <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x16
700a82d4: e7ff         	b	0x700a82d6 <Sciclient_rmIrOutpRomMapped+0x76> @ imm = #-0x2
700a82d6: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a82d8: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a82dc: 9901         	ldr	r1, [sp, #0x4]
700a82de: 6909         	ldr	r1, [r1, #0x10]
700a82e0: f89d 2000    	ldrb.w	r2, [sp]
700a82e4: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a82e8: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a82ea: e006         	b	0x700a82fa <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0xc
;         }
700a82ec: e7ff         	b	0x700a82ee <Sciclient_rmIrOutpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a82ee: f89d 0000    	ldrb.w	r0, [sp]
700a82f2: 3001         	adds	r0, #0x1
700a82f4: f88d 0000    	strb.w	r0, [sp]
700a82f8: e7c2         	b	0x700a8280 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x7c
;     }
700a82fa: e7ff         	b	0x700a82fc <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a82fc: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a8300: f000 0001    	and	r0, r0, #0x1
700a8304: b002         	add	sp, #0x8
700a8306: 4770         	bx	lr
		...

700a8310 <CycleCounterP_init>:
; {
700a8310: b580         	push	{r7, lr}
700a8312: b082         	sub	sp, #0x8
700a8314: 9101         	str	r1, [sp, #0x4]
700a8316: 9000         	str	r0, [sp]
;     gCounterFreqHz = cpuFreqHz/PmuP_SETUP_COUNTER_DIVIDER_VAL;
700a8318: 9800         	ldr	r0, [sp]
700a831a: 9a01         	ldr	r2, [sp, #0x4]
700a831c: f642 11b0    	movw	r1, #0x29b0
700a8320: f2c7 010b    	movt	r1, #0x700b
700a8324: 604a         	str	r2, [r1, #0x4]
700a8326: 6008         	str	r0, [r1]
;     CycleCounterP_reset();
700a8328: f000 f802    	bl	0x700a8330 <CycleCounterP_reset> @ imm = #0x4
; }
700a832c: b002         	add	sp, #0x8
700a832e: bd80         	pop	{r7, pc}

700a8330 <CycleCounterP_reset>:
; {
700a8330: b580         	push	{r7, lr}
700a8332: b082         	sub	sp, #0x8
700a8334: 2000         	movs	r0, #0x0
;     uint32_t setupFlags = 0;
700a8336: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_CYCLE_COUNTER_RESET;
700a8338: 9801         	ldr	r0, [sp, #0x4]
700a833a: f040 0004    	orr	r0, r0, #0x4
700a833e: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_EVENT_COUNTER_RESET;
700a8340: 9801         	ldr	r0, [sp, #0x4]
700a8342: f040 0002    	orr	r0, r0, #0x2
700a8346: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_ENABLE_ALL_COUNTERS;
700a8348: 9801         	ldr	r0, [sp, #0x4]
700a834a: f040 0001    	orr	r0, r0, #0x1
700a834e: 9001         	str	r0, [sp, #0x4]
700a8350: f04f 30ff    	mov.w	r0, #0xffffffff
;     PmuP_disableCounters(PmuP_COUNTER_MASK_ALL_COUNTERS); /* disable all counters */
700a8354: 9000         	str	r0, [sp]
700a8356: f006 ea60    	blx	0x700ae818 <PmuP_disableCounters> @ imm = #0x64c0
700a835a: 9800         	ldr	r0, [sp]
;     PmuP_clearOverflowStatus(PmuP_COUNTER_MASK_ALL_COUNTERS); /* clear all overflow flags */
700a835c: f006 ea64    	blx	0x700ae828 <PmuP_clearOverflowStatus> @ imm = #0x64c8
;     PmuP_setup(setupFlags); /* setup counters */
700a8360: 9801         	ldr	r0, [sp, #0x4]
700a8362: f006 ea52    	blx	0x700ae808 <PmuP_setup> @ imm = #0x64a4
700a8366: f04f 4000    	mov.w	r0, #0x80000000
;     PmuP_enableCounters(PmuP_COUNTER_MASK_CYCLE_COUNTER); /* enable cycle counter only */
700a836a: f006 ea52    	blx	0x700ae810 <PmuP_enableCounters> @ imm = #0x64a4
; }
700a836e: b002         	add	sp, #0x8
700a8370: bd80         	pop	{r7, pc}
700a8372: bf00         	nop
700a8374: bf00         	nop
700a8376: bf00         	nop
700a8378: bf00         	nop
700a837a: bf00         	nop
700a837c: bf00         	nop
700a837e: bf00         	nop

700a8380 <CycleCounterP_nsToTicks>:
; {
700a8380: b580         	push	{r7, lr}
700a8382: b082         	sub	sp, #0x8
700a8384: 9101         	str	r1, [sp, #0x4]
700a8386: 9000         	str	r0, [sp]
;     return (((uint64_t)nanosecs*gCounterFreqHz)/PmuP_SEC_TO_NANOSEC);
700a8388: 9b00         	ldr	r3, [sp]
700a838a: 9901         	ldr	r1, [sp, #0x4]
700a838c: f642 10b0    	movw	r0, #0x29b0
700a8390: f2c7 000b    	movt	r0, #0x700b
700a8394: 6802         	ldr	r2, [r0]
700a8396: f8d0 c004    	ldr.w	r12, [r0, #0x4]
700a839a: fba3 0e02    	umull	r0, lr, r3, r2
700a839e: fb03 e30c    	mla	r3, r3, r12, lr
700a83a2: fb01 3102    	mla	r1, r1, r2, r3
700a83a6: f64c 2200    	movw	r2, #0xca00
700a83aa: f6c3 329a    	movt	r2, #0x3b9a
700a83ae: 2300         	movs	r3, #0x0
700a83b0: f006 eed0    	blx	0x700af154 <__aeabi_uldivmod> @ imm = #0x6da0
700a83b4: b002         	add	sp, #0x8
700a83b6: bd80         	pop	{r7, pc}
		...

700a83c0 <Sciclient_pmGetModuleClkNumParent>:
; {
700a83c0: b580         	push	{r7, lr}
700a83c2: b096         	sub	sp, #0x58
700a83c4: 9015         	str	r0, [sp, #0x54]
700a83c6: 9114         	str	r1, [sp, #0x50]
700a83c8: 9213         	str	r2, [sp, #0x4c]
700a83ca: 9312         	str	r3, [sp, #0x48]
700a83cc: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a83ce: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_num_clock_parents_req request = {{0}};
700a83d0: f88d 0040    	strb.w	r0, [sp, #0x40]
700a83d4: 900f         	str	r0, [sp, #0x3c]
700a83d6: 900e         	str	r0, [sp, #0x38]
700a83d8: 900d         	str	r0, [sp, #0x34]
700a83da: 900c         	str	r0, [sp, #0x30]
;     request.device = (uint32_t) moduleId;
700a83dc: 9815         	ldr	r0, [sp, #0x54]
700a83de: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a83e0: 9814         	ldr	r0, [sp, #0x50]
700a83e2: 28ff         	cmp	r0, #0xff
700a83e4: d307         	blo	0x700a83f6 <Sciclient_pmGetModuleClkNumParent+0x36> @ imm = #0xe
700a83e6: e7ff         	b	0x700a83e8 <Sciclient_pmGetModuleClkNumParent+0x28> @ imm = #-0x2
;         request.clk32 = clockId;
700a83e8: 9814         	ldr	r0, [sp, #0x50]
700a83ea: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a83ee: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a83f0: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a83f4: e003         	b	0x700a83fe <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a83f6: 9814         	ldr	r0, [sp, #0x50]
700a83f8: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a83fc: e7ff         	b	0x700a83fe <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #-0x2
700a83fe: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_num_clock_parents_resp response = {{0}};
700a8400: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a8404: 900a         	str	r0, [sp, #0x28]
700a8406: 9009         	str	r0, [sp, #0x24]
700a8408: 9008         	str	r0, [sp, #0x20]
700a840a: f44f 7182    	mov.w	r1, #0x104
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_NUM_CLOCK_PARENTS;
700a840e: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a8412: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a8414: 9104         	str	r1, [sp, #0x10]
700a8416: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a8418: 9105         	str	r1, [sp, #0x14]
700a841a: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a841c: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a841e: 9912         	ldr	r1, [sp, #0x48]
700a8420: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a8422: 9000         	str	r0, [sp]
700a8424: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a8426: 9001         	str	r0, [sp, #0x4]
700a8428: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a842a: 9002         	str	r0, [sp, #0x8]
700a842c: a803         	add	r0, sp, #0xc
700a842e: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a8430: f7f4 fea6    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xb2b4
700a8434: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a8436: 9811         	ldr	r0, [sp, #0x44]
700a8438: b930         	cbnz	r0, 0x700a8448 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #0xc
700a843a: e7ff         	b	0x700a843c <Sciclient_pmGetModuleClkNumParent+0x7c> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a843c: 9800         	ldr	r0, [sp]
700a843e: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8442: 2802         	cmp	r0, #0x2
700a8444: d004         	beq	0x700a8450 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #0x8
700a8446: e7ff         	b	0x700a8448 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #-0x2
700a8448: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a844c: 9011         	str	r0, [sp, #0x44]
;     }
700a844e: e7ff         	b	0x700a8450 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a8450: 9811         	ldr	r0, [sp, #0x44]
700a8452: b928         	cbnz	r0, 0x700a8460 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #0xa
700a8454: e7ff         	b	0x700a8456 <Sciclient_pmGetModuleClkNumParent+0x96> @ imm = #-0x2
;         *numParent = (uint32_t) response.num_parents;
700a8456: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a845a: 9913         	ldr	r1, [sp, #0x4c]
700a845c: 6008         	str	r0, [r1]
;     }
700a845e: e7ff         	b	0x700a8460 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #-0x2
;     return retVal;
700a8460: 9811         	ldr	r0, [sp, #0x44]
700a8462: b016         	add	sp, #0x58
700a8464: bd80         	pop	{r7, pc}
		...
700a846e: 0000         	movs	r0, r0

700a8470 <xTaskPriorityDisinherit>:
; BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder) {
700a8470: b580         	push	{r7, lr}
700a8472: b084         	sub	sp, #0x10
700a8474: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxTCB = pxMutexHolder;
700a8476: 9803         	ldr	r0, [sp, #0xc]
700a8478: 9002         	str	r0, [sp, #0x8]
700a847a: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a847c: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a847e: 9803         	ldr	r0, [sp, #0xc]
700a8480: 2800         	cmp	r0, #0x0
700a8482: d044         	beq	0x700a850e <xTaskPriorityDisinherit+0x9e> @ imm = #0x88
700a8484: e7ff         	b	0x700a8486 <xTaskPriorityDisinherit+0x16> @ imm = #-0x2
;     (pxTCB->uxMutexesHeld)--;
700a8486: 9902         	ldr	r1, [sp, #0x8]
700a8488: 6e48         	ldr	r0, [r1, #0x64]
700a848a: 3801         	subs	r0, #0x1
700a848c: 6648         	str	r0, [r1, #0x64]
;     if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
700a848e: 9902         	ldr	r1, [sp, #0x8]
700a8490: 6ac8         	ldr	r0, [r1, #0x2c]
700a8492: 6e09         	ldr	r1, [r1, #0x60]
700a8494: 4288         	cmp	r0, r1
700a8496: d038         	beq	0x700a850a <xTaskPriorityDisinherit+0x9a> @ imm = #0x70
700a8498: e7ff         	b	0x700a849a <xTaskPriorityDisinherit+0x2a> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
700a849a: 9802         	ldr	r0, [sp, #0x8]
700a849c: 6e40         	ldr	r0, [r0, #0x64]
700a849e: bb90         	cbnz	r0, 0x700a8506 <xTaskPriorityDisinherit+0x96> @ imm = #0x64
700a84a0: e7ff         	b	0x700a84a2 <xTaskPriorityDisinherit+0x32> @ imm = #-0x2
;         if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a84a2: 9802         	ldr	r0, [sp, #0x8]
700a84a4: 3004         	adds	r0, #0x4
700a84a6: f005 f8bb    	bl	0x700ad620 <uxListRemove> @ imm = #0x5176
700a84aa: b908         	cbnz	r0, 0x700a84b0 <xTaskPriorityDisinherit+0x40> @ imm = #0x2
700a84ac: e7ff         	b	0x700a84ae <xTaskPriorityDisinherit+0x3e> @ imm = #-0x2
;         } else {
700a84ae: e000         	b	0x700a84b2 <xTaskPriorityDisinherit+0x42> @ imm = #0x0
700a84b0: e7ff         	b	0x700a84b2 <xTaskPriorityDisinherit+0x42> @ imm = #-0x2
;         pxTCB->uxPriority = pxTCB->uxBasePriority;
700a84b2: 9902         	ldr	r1, [sp, #0x8]
700a84b4: 6e08         	ldr	r0, [r1, #0x60]
700a84b6: 62c8         	str	r0, [r1, #0x2c]
;         listSET_LIST_ITEM_VALUE(
700a84b8: 9902         	ldr	r1, [sp, #0x8]
700a84ba: 6ac8         	ldr	r0, [r1, #0x2c]
700a84bc: f1c0 0020    	rsb.w	r0, r0, #0x20
700a84c0: 6188         	str	r0, [r1, #0x18]
;         prvAddTaskToReadyList(pxTCB);
700a84c2: 9802         	ldr	r0, [sp, #0x8]
700a84c4: 6ac0         	ldr	r0, [r0, #0x2c]
700a84c6: f642 212c    	movw	r1, #0x2a2c
700a84ca: f2c7 010b    	movt	r1, #0x700b
700a84ce: 6809         	ldr	r1, [r1]
700a84d0: 4288         	cmp	r0, r1
700a84d2: d908         	bls	0x700a84e6 <xTaskPriorityDisinherit+0x76> @ imm = #0x10
700a84d4: e7ff         	b	0x700a84d6 <xTaskPriorityDisinherit+0x66> @ imm = #-0x2
700a84d6: 9802         	ldr	r0, [sp, #0x8]
700a84d8: 6ac0         	ldr	r0, [r0, #0x2c]
700a84da: f642 212c    	movw	r1, #0x2a2c
700a84de: f2c7 010b    	movt	r1, #0x700b
700a84e2: 6008         	str	r0, [r1]
700a84e4: e7ff         	b	0x700a84e6 <xTaskPriorityDisinherit+0x76> @ imm = #-0x2
700a84e6: 9902         	ldr	r1, [sp, #0x8]
700a84e8: 6ac8         	ldr	r0, [r1, #0x2c]
700a84ea: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a84ee: f244 40f8    	movw	r0, #0x44f8
700a84f2: f2c7 0008    	movt	r0, #0x7008
700a84f6: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a84fa: 3104         	adds	r1, #0x4
700a84fc: f005 fe48    	bl	0x700ae190 <vListInsertEnd> @ imm = #0x5c90
700a8500: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a8502: 9001         	str	r0, [sp, #0x4]
;       } else {
700a8504: e000         	b	0x700a8508 <xTaskPriorityDisinherit+0x98> @ imm = #0x0
700a8506: e7ff         	b	0x700a8508 <xTaskPriorityDisinherit+0x98> @ imm = #-0x2
;     } else {
700a8508: e000         	b	0x700a850c <xTaskPriorityDisinherit+0x9c> @ imm = #0x0
700a850a: e7ff         	b	0x700a850c <xTaskPriorityDisinherit+0x9c> @ imm = #-0x2
;   } else {
700a850c: e000         	b	0x700a8510 <xTaskPriorityDisinherit+0xa0> @ imm = #0x0
700a850e: e7ff         	b	0x700a8510 <xTaskPriorityDisinherit+0xa0> @ imm = #-0x2
;   return xReturn;
700a8510: 9801         	ldr	r0, [sp, #0x4]
700a8512: b004         	add	sp, #0x10
700a8514: bd80         	pop	{r7, pc}
		...
700a851e: 0000         	movs	r0, r0

700a8520 <CSL_intaggrIsIntrPending>:
; {
700a8520: b580         	push	{r7, lr}
700a8522: b088         	sub	sp, #0x20
700a8524: 9007         	str	r0, [sp, #0x1c]
700a8526: 9106         	str	r1, [sp, #0x18]
700a8528: f88d 2017    	strb.w	r2, [sp, #0x17]
700a852c: 2000         	movs	r0, #0x0
;     bool     retVal = (bool)false;
700a852e: f88d 0016    	strb.w	r0, [sp, #0x16]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700a8532: 9807         	ldr	r0, [sp, #0x1c]
700a8534: 9906         	ldr	r1, [sp, #0x18]
700a8536: f005 fc8b    	bl	0x700ade50 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x5916
700a853a: b3e8         	cbz	r0, 0x700a85b8 <CSL_intaggrIsIntrPending+0x98> @ imm = #0x7a
700a853c: e7ff         	b	0x700a853e <CSL_intaggrIsIntrPending+0x1e> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700a853e: 9806         	ldr	r0, [sp, #0x18]
700a8540: 0980         	lsrs	r0, r0, #0x6
700a8542: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700a8544: 9806         	ldr	r0, [sp, #0x18]
700a8546: f000 003f    	and	r0, r0, #0x3f
700a854a: 9000         	str	r0, [sp]
;         if( bMaskedStatus == (bool)true )
700a854c: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a8550: 07c0         	lsls	r0, r0, #0x1f
700a8552: b158         	cbz	r0, 0x700a856c <CSL_intaggrIsIntrPending+0x4c> @ imm = #0x16
700a8554: e7ff         	b	0x700a8556 <CSL_intaggrIsIntrPending+0x36> @ imm = #-0x2
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUSM );
700a8556: 9807         	ldr	r0, [sp, #0x1c]
700a8558: 6880         	ldr	r0, [r0, #0x8]
700a855a: 9901         	ldr	r1, [sp, #0x4]
700a855c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8560: 3020         	adds	r0, #0x20
700a8562: f007 fb15    	bl	0x700afb90 <CSL_REG64_RD_RAW> @ imm = #0x762a
700a8566: 9103         	str	r1, [sp, #0xc]
700a8568: 9002         	str	r0, [sp, #0x8]
;         }
700a856a: e00a         	b	0x700a8582 <CSL_intaggrIsIntrPending+0x62> @ imm = #0x14
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUS_SET );
700a856c: 9807         	ldr	r0, [sp, #0x1c]
700a856e: 6880         	ldr	r0, [r0, #0x8]
700a8570: 9901         	ldr	r1, [sp, #0x4]
700a8572: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8576: 3010         	adds	r0, #0x10
700a8578: f007 fb0a    	bl	0x700afb90 <CSL_REG64_RD_RAW> @ imm = #0x7614
700a857c: 9103         	str	r1, [sp, #0xc]
700a857e: 9002         	str	r0, [sp, #0x8]
700a8580: e7ff         	b	0x700a8582 <CSL_intaggrIsIntrPending+0x62> @ imm = #-0x2
;         if( (regVal & (((uint64_t)1U) << bitNum)) == 0U )
700a8582: 9802         	ldr	r0, [sp, #0x8]
700a8584: 9903         	ldr	r1, [sp, #0xc]
700a8586: 9a00         	ldr	r2, [sp]
700a8588: 40d0         	lsrs	r0, r2
700a858a: f1c2 0320    	rsb.w	r3, r2, #0x20
700a858e: fa01 f303    	lsl.w	r3, r1, r3
700a8592: 4318         	orrs	r0, r3
700a8594: 3a20         	subs	r2, #0x20
700a8596: 40d1         	lsrs	r1, r2
700a8598: 2a00         	cmp	r2, #0x0
700a859a: bf58         	it	pl
700a859c: 4608         	movpl	r0, r1
700a859e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
700a85a2: b920         	cbnz	r0, 0x700a85ae <CSL_intaggrIsIntrPending+0x8e> @ imm = #0x8
700a85a4: e7ff         	b	0x700a85a6 <CSL_intaggrIsIntrPending+0x86> @ imm = #-0x2
700a85a6: 2000         	movs	r0, #0x0
;             retVal = (bool)false; /* Interrupt is not pending */
700a85a8: f88d 0016    	strb.w	r0, [sp, #0x16]
;         }
700a85ac: e003         	b	0x700a85b6 <CSL_intaggrIsIntrPending+0x96> @ imm = #0x6
700a85ae: 2001         	movs	r0, #0x1
;             retVal = (bool)true;  /* Interrupt is pending */
700a85b0: f88d 0016    	strb.w	r0, [sp, #0x16]
700a85b4: e7ff         	b	0x700a85b6 <CSL_intaggrIsIntrPending+0x96> @ imm = #-0x2
;     }
700a85b6: e7ff         	b	0x700a85b8 <CSL_intaggrIsIntrPending+0x98> @ imm = #-0x2
;     return retVal;
700a85b8: f89d 0016    	ldrb.w	r0, [sp, #0x16]
700a85bc: f000 0001    	and	r0, r0, #0x1
700a85c0: b008         	add	sp, #0x20
700a85c2: bd80         	pop	{r7, pc}
		...

700a85d0 <Sciclient_rmIrqCheckLoop>:
; {
700a85d0: b580         	push	{r7, lr}
700a85d2: b088         	sub	sp, #0x20
700a85d4: 9007         	str	r0, [sp, #0x1c]
700a85d6: 2000         	movs	r0, #0x0
;     bool loop = false;
700a85d8: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a85dc: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a85e0: e7ff         	b	0x700a85e2 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x2
700a85e2: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a85e6: 9002         	str	r0, [sp, #0x8]
700a85e8: f007 fb2a    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0x7654
700a85ec: 4601         	mov	r1, r0
700a85ee: 9802         	ldr	r0, [sp, #0x8]
700a85f0: 4288         	cmp	r0, r1
700a85f2: da39         	bge	0x700a8668 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0x72
700a85f4: e7ff         	b	0x700a85f6 <Sciclient_rmIrqCheckLoop+0x26> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a85f6: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a85fa: f006 fee1    	bl	0x700af3c0 <Sciclient_rmPsGetIrqNode> @ imm = #0x6dc2
700a85fe: 9004         	str	r0, [sp, #0x10]
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a8600: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a8604: 3001         	adds	r0, #0x1
700a8606: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a860a: e7ff         	b	0x700a860c <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x2
700a860c: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a8610: 9001         	str	r0, [sp, #0x4]
700a8612: f007 fb15    	bl	0x700afc40 <Sciclient_rmPsGetPsp> @ imm = #0x762a
700a8616: 4601         	mov	r1, r0
700a8618: 9801         	ldr	r0, [sp, #0x4]
700a861a: 4288         	cmp	r0, r1
700a861c: da17         	bge	0x700a864e <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0x2e
700a861e: e7ff         	b	0x700a8620 <Sciclient_rmIrqCheckLoop+0x50> @ imm = #-0x2
;             future_n = Sciclient_rmPsGetIrqNode(j);
700a8620: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a8624: f006 fecc    	bl	0x700af3c0 <Sciclient_rmPsGetIrqNode> @ imm = #0x6d98
700a8628: 9003         	str	r0, [sp, #0xc]
;             if (cur_n->id == future_n->id) {
700a862a: 9804         	ldr	r0, [sp, #0x10]
700a862c: 8800         	ldrh	r0, [r0]
700a862e: 9903         	ldr	r1, [sp, #0xc]
700a8630: 8809         	ldrh	r1, [r1]
700a8632: 4288         	cmp	r0, r1
700a8634: d104         	bne	0x700a8640 <Sciclient_rmIrqCheckLoop+0x70> @ imm = #0x8
700a8636: e7ff         	b	0x700a8638 <Sciclient_rmIrqCheckLoop+0x68> @ imm = #-0x2
700a8638: 2001         	movs	r0, #0x1
;                 loop = true;
700a863a: f88d 001b    	strb.w	r0, [sp, #0x1b]
;                 break;
700a863e: e006         	b	0x700a864e <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0xc
;         }
700a8640: e7ff         	b	0x700a8642 <Sciclient_rmIrqCheckLoop+0x72> @ imm = #-0x2
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a8642: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a8646: 3001         	adds	r0, #0x1
700a8648: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a864c: e7de         	b	0x700a860c <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x44
;         if (loop == true) {
700a864e: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a8652: 07c0         	lsls	r0, r0, #0x1f
700a8654: b108         	cbz	r0, 0x700a865a <Sciclient_rmIrqCheckLoop+0x8a> @ imm = #0x2
700a8656: e7ff         	b	0x700a8658 <Sciclient_rmIrqCheckLoop+0x88> @ imm = #-0x2
;             break;
700a8658: e006         	b	0x700a8668 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0xc
;     }
700a865a: e7ff         	b	0x700a865c <Sciclient_rmIrqCheckLoop+0x8c> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a865c: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a8660: 3001         	adds	r0, #0x1
700a8662: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a8666: e7bc         	b	0x700a85e2 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x88
;     return loop;
700a8668: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a866c: f000 0001    	and	r0, r0, #0x1
700a8670: b008         	add	sp, #0x20
700a8672: bd80         	pop	{r7, pc}
		...

700a8680 <UART_IsBaseAddrValid>:
; {
700a8680: b082         	sub	sp, #0x8
700a8682: 9001         	str	r0, [sp, #0x4]
700a8684: f06f 0002    	mvn	r0, #0x2
;     int32_t status = (int32_t)-3;
700a8688: 9000         	str	r0, [sp]
;     if ((baseAddr == CSL_UART0_BASE) ||
700a868a: 9801         	ldr	r0, [sp, #0x4]
700a868c: f1b0 7f20    	cmp.w	r0, #0x2800000
700a8690: d042         	beq	0x700a8718 <UART_IsBaseAddrValid+0x98> @ imm = #0x84
700a8692: e7ff         	b	0x700a8694 <UART_IsBaseAddrValid+0x14> @ imm = #-0x2
;         (baseAddr == CSL_UART1_BASE) ||
700a8694: 9801         	ldr	r0, [sp, #0x4]
700a8696: 2100         	movs	r1, #0x0
700a8698: f2c0 2181    	movt	r1, #0x281
700a869c: 4288         	cmp	r0, r1
700a869e: d03b         	beq	0x700a8718 <UART_IsBaseAddrValid+0x98> @ imm = #0x76
700a86a0: e7ff         	b	0x700a86a2 <UART_IsBaseAddrValid+0x22> @ imm = #-0x2
;         (baseAddr == CSL_UART2_BASE) ||
700a86a2: 9801         	ldr	r0, [sp, #0x4]
700a86a4: 2100         	movs	r1, #0x0
700a86a6: f2c0 2182    	movt	r1, #0x282
700a86aa: 4288         	cmp	r0, r1
700a86ac: d034         	beq	0x700a8718 <UART_IsBaseAddrValid+0x98> @ imm = #0x68
700a86ae: e7ff         	b	0x700a86b0 <UART_IsBaseAddrValid+0x30> @ imm = #-0x2
;         (baseAddr == CSL_UART3_BASE) ||
700a86b0: 9801         	ldr	r0, [sp, #0x4]
700a86b2: 2100         	movs	r1, #0x0
700a86b4: f2c0 2183    	movt	r1, #0x283
700a86b8: 4288         	cmp	r0, r1
700a86ba: d02d         	beq	0x700a8718 <UART_IsBaseAddrValid+0x98> @ imm = #0x5a
700a86bc: e7ff         	b	0x700a86be <UART_IsBaseAddrValid+0x3e> @ imm = #-0x2
;         (baseAddr == CSL_UART4_BASE) ||
700a86be: 9801         	ldr	r0, [sp, #0x4]
700a86c0: f1b0 7f21    	cmp.w	r0, #0x2840000
700a86c4: d028         	beq	0x700a8718 <UART_IsBaseAddrValid+0x98> @ imm = #0x50
700a86c6: e7ff         	b	0x700a86c8 <UART_IsBaseAddrValid+0x48> @ imm = #-0x2
;         (baseAddr == CSL_UART5_BASE) ||
700a86c8: 9801         	ldr	r0, [sp, #0x4]
700a86ca: 2100         	movs	r1, #0x0
700a86cc: f2c0 2185    	movt	r1, #0x285
700a86d0: 4288         	cmp	r0, r1
700a86d2: d021         	beq	0x700a8718 <UART_IsBaseAddrValid+0x98> @ imm = #0x42
700a86d4: e7ff         	b	0x700a86d6 <UART_IsBaseAddrValid+0x56> @ imm = #-0x2
;         (baseAddr == CSL_UART6_BASE) ||
700a86d6: 9801         	ldr	r0, [sp, #0x4]
700a86d8: 2100         	movs	r1, #0x0
700a86da: f2c0 2186    	movt	r1, #0x286
700a86de: 4288         	cmp	r0, r1
700a86e0: d01a         	beq	0x700a8718 <UART_IsBaseAddrValid+0x98> @ imm = #0x34
700a86e2: e7ff         	b	0x700a86e4 <UART_IsBaseAddrValid+0x64> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART0_BASE) ||
700a86e4: 9801         	ldr	r0, [sp, #0x4]
700a86e6: f1b0 6f94    	cmp.w	r0, #0x4a00000
700a86ea: d015         	beq	0x700a8718 <UART_IsBaseAddrValid+0x98> @ imm = #0x2a
700a86ec: e7ff         	b	0x700a86ee <UART_IsBaseAddrValid+0x6e> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART1_BASE) ||
700a86ee: 9801         	ldr	r0, [sp, #0x4]
700a86f0: 2100         	movs	r1, #0x0
700a86f2: f2c0 41a1    	movt	r1, #0x4a1
700a86f6: 4288         	cmp	r0, r1
700a86f8: d00e         	beq	0x700a8718 <UART_IsBaseAddrValid+0x98> @ imm = #0x1c
700a86fa: e7ff         	b	0x700a86fc <UART_IsBaseAddrValid+0x7c> @ imm = #-0x2
;         (baseAddr == MCU_UART0_BASE_AFTER_ADDR_TRANSLATE) ||
700a86fc: 9801         	ldr	r0, [sp, #0x4]
700a86fe: 2100         	movs	r1, #0x0
700a8700: f2c8 41a0    	movt	r1, #0x84a0
700a8704: 4288         	cmp	r0, r1
700a8706: d007         	beq	0x700a8718 <UART_IsBaseAddrValid+0x98> @ imm = #0xe
700a8708: e7ff         	b	0x700a870a <UART_IsBaseAddrValid+0x8a> @ imm = #-0x2
;         (baseAddr == MCU_UART1_BASE_AFTER_ADDR_TRANSLATE))
700a870a: 9801         	ldr	r0, [sp, #0x4]
700a870c: 2100         	movs	r1, #0x0
700a870e: f2c8 41a1    	movt	r1, #0x84a1
;     if ((baseAddr == CSL_UART0_BASE) ||
700a8712: 4288         	cmp	r0, r1
700a8714: d103         	bne	0x700a871e <UART_IsBaseAddrValid+0x9e> @ imm = #0x6
700a8716: e7ff         	b	0x700a8718 <UART_IsBaseAddrValid+0x98> @ imm = #-0x2
700a8718: 2000         	movs	r0, #0x0
;         status = 0;
700a871a: 9000         	str	r0, [sp]
;     }
700a871c: e7ff         	b	0x700a871e <UART_IsBaseAddrValid+0x9e> @ imm = #-0x2
;     return status;
700a871e: 9800         	ldr	r0, [sp]
700a8720: b002         	add	sp, #0x8
700a8722: 4770         	bx	lr

700a8724 <split>:
700a8724: e92d48f0     	push	{r4, r5, r6, r7, r11, lr}
700a8728: e1a04000     	mov	r4, r0
700a872c: e5900000     	ldr	r0, [r0]
700a8730: e1a05001     	mov	r5, r1
700a8734: e3c01001     	bic	r1, r0, #1
700a8738: e0411005     	sub	r1, r1, r5
700a873c: e3510010     	cmp	r1, #16
700a8740: 3a00001b     	blo	0x700a87b4 <split+0x90> @ imm = #0x6c
700a8744: e2410008     	sub	r0, r1, #8
700a8748: e0846005     	add	r6, r4, r5
700a874c: e59f106c     	ldr	r1, [pc, #0x6c]         @ 0x700a87c0 <split+0x9c>
700a8750: e59f206c     	ldr	r2, [pc, #0x6c]         @ 0x700a87c4 <split+0xa0>
700a8754: e5a60008     	str	r0, [r6, #0x8]!
700a8758: e3c00001     	bic	r0, r0, #1
700a875c: e3520007     	cmp	r2, #7
700a8760: e0860000     	add	r0, r6, r0
700a8764: e2807008     	add	r7, r0, #8
700a8768: e0820001     	add	r0, r2, r1
700a876c: 82401008     	subhi	r1, r0, #8
700a8770: e1570001     	cmp	r7, r1
700a8774: 2a00000b     	bhs	0x700a87a8 <split+0x84> @ imm = #0x2c
700a8778: e5d70000     	ldrb	r0, [r7]
700a877c: e3100001     	tst	r0, #1
700a8780: 1a000008     	bne	0x700a87a8 <split+0x84> @ imm = #0x20
700a8784: e1a00007     	mov	r0, r7
700a8788: eb00176d     	bl	0x700ae544 <free_list_remove> @ imm = #0x5db4
700a878c: e5960000     	ldr	r0, [r6]
700a8790: e5971000     	ldr	r1, [r7]
700a8794: e2800008     	add	r0, r0, #8
700a8798: e3c11001     	bic	r1, r1, #1
700a879c: e3c00001     	bic	r0, r0, #1
700a87a0: e0800001     	add	r0, r0, r1
700a87a4: e5860000     	str	r0, [r6]
700a87a8: e1a00006     	mov	r0, r6
700a87ac: eb001517     	bl	0x700adc10 <free_list_insert> @ imm = #0x545c
700a87b0: e1a00005     	mov	r0, r5
700a87b4: e3800001     	orr	r0, r0, #1
700a87b8: e5840000     	str	r0, [r4]
700a87bc: e8bd88f0     	pop	{r4, r5, r6, r7, r11, pc}
700a87c0: 80 51 08 70  	.word	0x70085180
700a87c4: 00 00 01 00  	.word	0x00010000
700a87c8: 00 00 00 00  	.word	0x00000000
700a87cc: 00 00 00 00  	.word	0x00000000

700a87d0 <vTaskResume>:
; void vTaskResume(TaskHandle_t xTaskToResume) {
700a87d0: b580         	push	{r7, lr}
700a87d2: b082         	sub	sp, #0x8
700a87d4: 9001         	str	r0, [sp, #0x4]
;   TCB_t *const pxTCB = xTaskToResume;
700a87d6: 9801         	ldr	r0, [sp, #0x4]
700a87d8: 9000         	str	r0, [sp]
;   if ((pxTCB != pxCurrentTCB) && (pxTCB != NULL)) {
700a87da: 9800         	ldr	r0, [sp]
700a87dc: f642 2100    	movw	r1, #0x2a00
700a87e0: f2c7 010b    	movt	r1, #0x700b
700a87e4: 6809         	ldr	r1, [r1]
700a87e6: 4288         	cmp	r0, r1
700a87e8: d041         	beq	0x700a886e <vTaskResume+0x9e> @ imm = #0x82
700a87ea: e7ff         	b	0x700a87ec <vTaskResume+0x1c> @ imm = #-0x2
700a87ec: 9800         	ldr	r0, [sp]
700a87ee: 2800         	cmp	r0, #0x0
700a87f0: d03d         	beq	0x700a886e <vTaskResume+0x9e> @ imm = #0x7a
700a87f2: e7ff         	b	0x700a87f4 <vTaskResume+0x24> @ imm = #-0x2
;     taskENTER_CRITICAL();
700a87f4: f005 ff64    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x5ec8
;       if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE) {
700a87f8: 9800         	ldr	r0, [sp]
700a87fa: f004 fcc1    	bl	0x700ad180 <prvTaskIsTaskSuspended> @ imm = #0x4982
700a87fe: b390         	cbz	r0, 0x700a8866 <vTaskResume+0x96> @ imm = #0x64
700a8800: e7ff         	b	0x700a8802 <vTaskResume+0x32> @ imm = #-0x2
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700a8802: 9800         	ldr	r0, [sp]
700a8804: 3004         	adds	r0, #0x4
700a8806: f004 ff0b    	bl	0x700ad620 <uxListRemove> @ imm = #0x4e16
;         prvAddTaskToReadyList(pxTCB);
700a880a: 9800         	ldr	r0, [sp]
700a880c: 6ac0         	ldr	r0, [r0, #0x2c]
700a880e: f642 212c    	movw	r1, #0x2a2c
700a8812: f2c7 010b    	movt	r1, #0x700b
700a8816: 6809         	ldr	r1, [r1]
700a8818: 4288         	cmp	r0, r1
700a881a: d908         	bls	0x700a882e <vTaskResume+0x5e> @ imm = #0x10
700a881c: e7ff         	b	0x700a881e <vTaskResume+0x4e> @ imm = #-0x2
700a881e: 9800         	ldr	r0, [sp]
700a8820: 6ac0         	ldr	r0, [r0, #0x2c]
700a8822: f642 212c    	movw	r1, #0x2a2c
700a8826: f2c7 010b    	movt	r1, #0x700b
700a882a: 6008         	str	r0, [r1]
700a882c: e7ff         	b	0x700a882e <vTaskResume+0x5e> @ imm = #-0x2
700a882e: 9900         	ldr	r1, [sp]
700a8830: 6ac8         	ldr	r0, [r1, #0x2c]
700a8832: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a8836: f244 40f8    	movw	r0, #0x44f8
700a883a: f2c7 0008    	movt	r0, #0x7008
700a883e: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a8842: 3104         	adds	r1, #0x4
700a8844: f005 fca4    	bl	0x700ae190 <vListInsertEnd> @ imm = #0x5948
;         if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a8848: 9800         	ldr	r0, [sp]
700a884a: 6ac0         	ldr	r0, [r0, #0x2c]
700a884c: f642 2100    	movw	r1, #0x2a00
700a8850: f2c7 010b    	movt	r1, #0x700b
700a8854: 6809         	ldr	r1, [r1]
700a8856: 6ac9         	ldr	r1, [r1, #0x2c]
700a8858: 4288         	cmp	r0, r1
700a885a: d302         	blo	0x700a8862 <vTaskResume+0x92> @ imm = #0x4
700a885c: e7ff         	b	0x700a885e <vTaskResume+0x8e> @ imm = #-0x2
;           taskYIELD_IF_USING_PREEMPTION();
700a885e: df00         	svc	#0x0
;         } else {
700a8860: e000         	b	0x700a8864 <vTaskResume+0x94> @ imm = #0x0
700a8862: e7ff         	b	0x700a8864 <vTaskResume+0x94> @ imm = #-0x2
;       } else {
700a8864: e000         	b	0x700a8868 <vTaskResume+0x98> @ imm = #0x0
700a8866: e7ff         	b	0x700a8868 <vTaskResume+0x98> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700a8868: f004 ffca    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x4f94
;   } else {
700a886c: e000         	b	0x700a8870 <vTaskResume+0xa0> @ imm = #0x0
700a886e: e7ff         	b	0x700a8870 <vTaskResume+0xa0> @ imm = #-0x2
; }
700a8870: b002         	add	sp, #0x8
700a8872: bd80         	pop	{r7, pc}
		...

700a8880 <xQueueGenericSendFromISR>:
; {
700a8880: b580         	push	{r7, lr}
700a8882: b08a         	sub	sp, #0x28
700a8884: 9009         	str	r0, [sp, #0x24]
700a8886: 9108         	str	r1, [sp, #0x20]
700a8888: 9207         	str	r2, [sp, #0x1c]
700a888a: 9306         	str	r3, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a888c: 9809         	ldr	r0, [sp, #0x24]
700a888e: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a8890: f008 e846    	blx	0x700b0920 <HwiP_disable> @ imm = #0x808c
700a8894: 9004         	str	r0, [sp, #0x10]
;         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a8896: 9803         	ldr	r0, [sp, #0xc]
700a8898: 6b80         	ldr	r0, [r0, #0x38]
700a889a: 9903         	ldr	r1, [sp, #0xc]
700a889c: 6bc9         	ldr	r1, [r1, #0x3c]
700a889e: 4288         	cmp	r0, r1
700a88a0: d304         	blo	0x700a88ac <xQueueGenericSendFromISR+0x2c> @ imm = #0x8
700a88a2: e7ff         	b	0x700a88a4 <xQueueGenericSendFromISR+0x24> @ imm = #-0x2
700a88a4: 9806         	ldr	r0, [sp, #0x18]
700a88a6: 2802         	cmp	r0, #0x2
700a88a8: d133         	bne	0x700a8912 <xQueueGenericSendFromISR+0x92> @ imm = #0x66
700a88aa: e7ff         	b	0x700a88ac <xQueueGenericSendFromISR+0x2c> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a88ac: 9803         	ldr	r0, [sp, #0xc]
700a88ae: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a88b2: f88d 000b    	strb.w	r0, [sp, #0xb]
;             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
700a88b6: 9803         	ldr	r0, [sp, #0xc]
700a88b8: 6b80         	ldr	r0, [r0, #0x38]
700a88ba: 9001         	str	r0, [sp, #0x4]
;             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a88bc: 9803         	ldr	r0, [sp, #0xc]
700a88be: 9908         	ldr	r1, [sp, #0x20]
700a88c0: 9a06         	ldr	r2, [sp, #0x18]
700a88c2: f7fe f8c5    	bl	0x700a6a50 <prvCopyDataToQueue> @ imm = #-0x1e76
;             if( cTxLock == queueUNLOCKED )
700a88c6: f99d 000b    	ldrsb.w	r0, [sp, #0xb]
700a88ca: 3001         	adds	r0, #0x1
700a88cc: b9b8         	cbnz	r0, 0x700a88fe <xQueueGenericSendFromISR+0x7e> @ imm = #0x2e
700a88ce: e7ff         	b	0x700a88d0 <xQueueGenericSendFromISR+0x50> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a88d0: 9803         	ldr	r0, [sp, #0xc]
700a88d2: 6a40         	ldr	r0, [r0, #0x24]
700a88d4: b188         	cbz	r0, 0x700a88fa <xQueueGenericSendFromISR+0x7a> @ imm = #0x22
700a88d6: e7ff         	b	0x700a88d8 <xQueueGenericSendFromISR+0x58> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a88d8: 9803         	ldr	r0, [sp, #0xc]
700a88da: 3024         	adds	r0, #0x24
700a88dc: f7ff f838    	bl	0x700a7950 <xTaskRemoveFromEventList> @ imm = #-0xf90
700a88e0: b148         	cbz	r0, 0x700a88f6 <xQueueGenericSendFromISR+0x76> @ imm = #0x12
700a88e2: e7ff         	b	0x700a88e4 <xQueueGenericSendFromISR+0x64> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a88e4: 9807         	ldr	r0, [sp, #0x1c]
700a88e6: b120         	cbz	r0, 0x700a88f2 <xQueueGenericSendFromISR+0x72> @ imm = #0x8
700a88e8: e7ff         	b	0x700a88ea <xQueueGenericSendFromISR+0x6a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a88ea: 9907         	ldr	r1, [sp, #0x1c]
700a88ec: 2001         	movs	r0, #0x1
700a88ee: 6008         	str	r0, [r1]
;                                 }
700a88f0: e000         	b	0x700a88f4 <xQueueGenericSendFromISR+0x74> @ imm = #0x0
700a88f2: e7ff         	b	0x700a88f4 <xQueueGenericSendFromISR+0x74> @ imm = #-0x2
;                             }
700a88f4: e000         	b	0x700a88f8 <xQueueGenericSendFromISR+0x78> @ imm = #0x0
700a88f6: e7ff         	b	0x700a88f8 <xQueueGenericSendFromISR+0x78> @ imm = #-0x2
;                         }
700a88f8: e000         	b	0x700a88fc <xQueueGenericSendFromISR+0x7c> @ imm = #0x0
700a88fa: e7ff         	b	0x700a88fc <xQueueGenericSendFromISR+0x7c> @ imm = #-0x2
;             }
700a88fc: e006         	b	0x700a890c <xQueueGenericSendFromISR+0x8c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a88fe: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a8902: 3001         	adds	r0, #0x1
700a8904: 9903         	ldr	r1, [sp, #0xc]
700a8906: f881 0045    	strb.w	r0, [r1, #0x45]
700a890a: e7ff         	b	0x700a890c <xQueueGenericSendFromISR+0x8c> @ imm = #-0x2
700a890c: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a890e: 9005         	str	r0, [sp, #0x14]
;         }
700a8910: e002         	b	0x700a8918 <xQueueGenericSendFromISR+0x98> @ imm = #0x4
700a8912: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a8914: 9005         	str	r0, [sp, #0x14]
700a8916: e7ff         	b	0x700a8918 <xQueueGenericSendFromISR+0x98> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a8918: 9804         	ldr	r0, [sp, #0x10]
700a891a: f008 e822    	blx	0x700b0960 <HwiP_restore> @ imm = #0x8044
;     return xReturn;
700a891e: 9805         	ldr	r0, [sp, #0x14]
700a8920: b00a         	add	sp, #0x28
700a8922: bd80         	pop	{r7, pc}
		...

700a8930 <prvCheckForValidListAndQueue>:
;     {
700a8930: b580         	push	{r7, lr}
700a8932: b084         	sub	sp, #0x10
;         taskENTER_CRITICAL();
700a8934: f005 fec4    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x5d88
;             if( xTimerQueue == NULL )
700a8938: f642 2048    	movw	r0, #0x2a48
700a893c: f2c7 000b    	movt	r0, #0x700b
700a8940: 6800         	ldr	r0, [r0]
700a8942: 2800         	cmp	r0, #0x0
700a8944: d140         	bne	0x700a89c8 <prvCheckForValidListAndQueue+0x98> @ imm = #0x80
700a8946: e7ff         	b	0x700a8948 <prvCheckForValidListAndQueue+0x18> @ imm = #-0x2
;                 vListInitialise( &xActiveTimerList1 );
700a8948: f245 0090    	movw	r0, #0x5090
700a894c: f2c7 0008    	movt	r0, #0x7008
700a8950: 9002         	str	r0, [sp, #0x8]
700a8952: f006 f845    	bl	0x700ae9e0 <vListInitialise> @ imm = #0x608a
;                 vListInitialise( &xActiveTimerList2 );
700a8956: f245 00a4    	movw	r0, #0x50a4
700a895a: f2c7 0008    	movt	r0, #0x7008
700a895e: 9003         	str	r0, [sp, #0xc]
700a8960: f006 f83e    	bl	0x700ae9e0 <vListInitialise> @ imm = #0x607c
700a8964: 9902         	ldr	r1, [sp, #0x8]
700a8966: 9803         	ldr	r0, [sp, #0xc]
;                 pxCurrentTimerList = &xActiveTimerList1;
700a8968: f245 1224    	movw	r2, #0x5124
700a896c: f2c7 0208    	movt	r2, #0x7008
700a8970: 6011         	str	r1, [r2]
;                 pxOverflowTimerList = &xActiveTimerList2;
700a8972: f245 1130    	movw	r1, #0x5130
700a8976: f2c7 0108    	movt	r1, #0x7008
700a897a: 6008         	str	r0, [r1]
;                         xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
700a897c: 4669         	mov	r1, sp
700a897e: 2000         	movs	r0, #0x0
700a8980: 6008         	str	r0, [r1]
700a8982: f644 1278    	movw	r2, #0x4978
700a8986: f2c7 0208    	movt	r2, #0x7008
700a898a: f241 0308    	movw	r3, #0x1008
700a898e: f2c7 0308    	movt	r3, #0x7008
700a8992: 2110         	movs	r1, #0x10
700a8994: 4608         	mov	r0, r1
700a8996: f004 fdab    	bl	0x700ad4f0 <xQueueGenericCreateStatic> @ imm = #0x4b56
700a899a: 4601         	mov	r1, r0
700a899c: f642 2048    	movw	r0, #0x2a48
700a89a0: f2c7 000b    	movt	r0, #0x700b
700a89a4: 6001         	str	r1, [r0]
;                         if( xTimerQueue != NULL )
700a89a6: 6800         	ldr	r0, [r0]
700a89a8: b160         	cbz	r0, 0x700a89c4 <prvCheckForValidListAndQueue+0x94> @ imm = #0x18
700a89aa: e7ff         	b	0x700a89ac <prvCheckForValidListAndQueue+0x7c> @ imm = #-0x2
;                             vQueueAddToRegistry( xTimerQueue, "TmrQ" );
700a89ac: f642 2048    	movw	r0, #0x2a48
700a89b0: f2c7 000b    	movt	r0, #0x700b
700a89b4: 6800         	ldr	r0, [r0]
700a89b6: f242 6122    	movw	r1, #0x2622
700a89ba: f2c7 010b    	movt	r1, #0x700b
700a89be: f004 fadf    	bl	0x700acf80 <vQueueAddToRegistry> @ imm = #0x45be
;                         }
700a89c2: e000         	b	0x700a89c6 <prvCheckForValidListAndQueue+0x96> @ imm = #0x0
700a89c4: e7ff         	b	0x700a89c6 <prvCheckForValidListAndQueue+0x96> @ imm = #-0x2
;             }
700a89c6: e000         	b	0x700a89ca <prvCheckForValidListAndQueue+0x9a> @ imm = #0x0
700a89c8: e7ff         	b	0x700a89ca <prvCheckForValidListAndQueue+0x9a> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a89ca: f004 ff19    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x4e32
;     }
700a89ce: b004         	add	sp, #0x10
700a89d0: bd80         	pop	{r7, pc}
		...
700a89de: 0000         	movs	r0, r0

700a89e0 <Udma_rmAllocEvent>:
; {
700a89e0: b580         	push	{r7, lr}
700a89e2: b088         	sub	sp, #0x20
700a89e4: 9007         	str	r0, [sp, #0x1c]
700a89e6: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            globalEvent = UDMA_EVENT_INVALID;
700a89ea: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a89ec: 9807         	ldr	r0, [sp, #0x1c]
700a89ee: f500 70ea    	add.w	r0, r0, #0x1d4
700a89f2: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a89f4: 9807         	ldr	r0, [sp, #0x1c]
700a89f6: f500 609f    	add.w	r0, r0, #0x4f8
700a89fa: f04f 31ff    	mov.w	r1, #0xffffffff
700a89fe: f001 fe0f    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x1c1e
700a8a02: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a8a04: 9005         	str	r0, [sp, #0x14]
700a8a06: e7ff         	b	0x700a8a08 <Udma_rmAllocEvent+0x28> @ imm = #-0x2
700a8a08: 9805         	ldr	r0, [sp, #0x14]
700a8a0a: 9901         	ldr	r1, [sp, #0x4]
700a8a0c: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
700a8a10: 4288         	cmp	r0, r1
700a8a12: d22d         	bhs	0x700a8a70 <Udma_rmAllocEvent+0x90> @ imm = #0x5a
700a8a14: e7ff         	b	0x700a8a16 <Udma_rmAllocEvent+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a8a16: 9805         	ldr	r0, [sp, #0x14]
700a8a18: 0940         	lsrs	r0, r0, #0x5
700a8a1a: 9004         	str	r0, [sp, #0x10]
;         bitPos = i - (offset << 5U);
700a8a1c: 9805         	ldr	r0, [sp, #0x14]
700a8a1e: 9904         	ldr	r1, [sp, #0x10]
700a8a20: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a8a24: 9003         	str	r0, [sp, #0xc]
;         bitMask = (uint32_t) 1U << bitPos;
700a8a26: 9903         	ldr	r1, [sp, #0xc]
700a8a28: 2001         	movs	r0, #0x1
700a8a2a: 4088         	lsls	r0, r1
700a8a2c: 9002         	str	r0, [sp, #0x8]
;         if((drvHandle->globalEventFlag[offset] & bitMask) == bitMask)
700a8a2e: 9807         	ldr	r0, [sp, #0x1c]
700a8a30: 9904         	ldr	r1, [sp, #0x10]
700a8a32: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a8a36: f8d0 0424    	ldr.w	r0, [r0, #0x424]
700a8a3a: 9902         	ldr	r1, [sp, #0x8]
700a8a3c: 4008         	ands	r0, r1
700a8a3e: 4288         	cmp	r0, r1
700a8a40: d111         	bne	0x700a8a66 <Udma_rmAllocEvent+0x86> @ imm = #0x22
700a8a42: e7ff         	b	0x700a8a44 <Udma_rmAllocEvent+0x64> @ imm = #-0x2
;             drvHandle->globalEventFlag[offset] &= ~bitMask;
700a8a44: 9a02         	ldr	r2, [sp, #0x8]
700a8a46: 9807         	ldr	r0, [sp, #0x1c]
700a8a48: 9904         	ldr	r1, [sp, #0x10]
700a8a4a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a8a4e: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700a8a52: 4390         	bics	r0, r2
700a8a54: f8c1 0424    	str.w	r0, [r1, #0x424]
;             globalEvent = i + rmInitPrms->startGlobalEvent;  /* Add start offset */
700a8a58: 9805         	ldr	r0, [sp, #0x14]
700a8a5a: 9901         	ldr	r1, [sp, #0x4]
700a8a5c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a8a60: 4408         	add	r0, r1
700a8a62: 9006         	str	r0, [sp, #0x18]
;             break;
700a8a64: e004         	b	0x700a8a70 <Udma_rmAllocEvent+0x90> @ imm = #0x8
;     }
700a8a66: e7ff         	b	0x700a8a68 <Udma_rmAllocEvent+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a8a68: 9805         	ldr	r0, [sp, #0x14]
700a8a6a: 3001         	adds	r0, #0x1
700a8a6c: 9005         	str	r0, [sp, #0x14]
700a8a6e: e7cb         	b	0x700a8a08 <Udma_rmAllocEvent+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a8a70: 9807         	ldr	r0, [sp, #0x1c]
700a8a72: f500 609f    	add.w	r0, r0, #0x4f8
700a8a76: f003 f99b    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x3336
;     return (globalEvent);
700a8a7a: 9806         	ldr	r0, [sp, #0x18]
700a8a7c: b008         	add	sp, #0x20
700a8a7e: bd80         	pop	{r7, pc}

700a8a80 <Udma_rmAllocVintr>:
; {
700a8a80: b580         	push	{r7, lr}
700a8a82: b088         	sub	sp, #0x20
700a8a84: 9007         	str	r0, [sp, #0x1c]
700a8a86: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            vintrNum = UDMA_EVENT_INVALID;
700a8a8a: 9002         	str	r0, [sp, #0x8]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a8a8c: 9807         	ldr	r0, [sp, #0x1c]
700a8a8e: f500 70ea    	add.w	r0, r0, #0x1d4
700a8a92: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a8a94: 9807         	ldr	r0, [sp, #0x1c]
700a8a96: f500 609f    	add.w	r0, r0, #0x4f8
700a8a9a: f04f 31ff    	mov.w	r1, #0xffffffff
700a8a9e: f001 fdbf    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x1b7e
700a8aa2: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a8aa4: 9006         	str	r0, [sp, #0x18]
700a8aa6: e7ff         	b	0x700a8aa8 <Udma_rmAllocVintr+0x28> @ imm = #-0x2
700a8aa8: 9806         	ldr	r0, [sp, #0x18]
700a8aaa: 9901         	ldr	r1, [sp, #0x4]
700a8aac: f8d1 10e4    	ldr.w	r1, [r1, #0xe4]
700a8ab0: 4288         	cmp	r0, r1
700a8ab2: d22d         	bhs	0x700a8b10 <Udma_rmAllocVintr+0x90> @ imm = #0x5a
700a8ab4: e7ff         	b	0x700a8ab6 <Udma_rmAllocVintr+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a8ab6: 9806         	ldr	r0, [sp, #0x18]
700a8ab8: 0940         	lsrs	r0, r0, #0x5
700a8aba: 9005         	str	r0, [sp, #0x14]
;         bitPos = i - (offset << 5U);
700a8abc: 9806         	ldr	r0, [sp, #0x18]
700a8abe: 9905         	ldr	r1, [sp, #0x14]
700a8ac0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a8ac4: 9004         	str	r0, [sp, #0x10]
;         bitMask = (uint32_t) 1U << bitPos;
700a8ac6: 9904         	ldr	r1, [sp, #0x10]
700a8ac8: 2001         	movs	r0, #0x1
700a8aca: 4088         	lsls	r0, r1
700a8acc: 9003         	str	r0, [sp, #0xc]
;         if((drvHandle->vintrFlag[offset] & bitMask) == bitMask)
700a8ace: 9807         	ldr	r0, [sp, #0x1c]
700a8ad0: 9905         	ldr	r1, [sp, #0x14]
700a8ad2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a8ad6: f8d0 04a4    	ldr.w	r0, [r0, #0x4a4]
700a8ada: 9903         	ldr	r1, [sp, #0xc]
700a8adc: 4008         	ands	r0, r1
700a8ade: 4288         	cmp	r0, r1
700a8ae0: d111         	bne	0x700a8b06 <Udma_rmAllocVintr+0x86> @ imm = #0x22
700a8ae2: e7ff         	b	0x700a8ae4 <Udma_rmAllocVintr+0x64> @ imm = #-0x2
;             drvHandle->vintrFlag[offset] &= ~bitMask;
700a8ae4: 9a03         	ldr	r2, [sp, #0xc]
700a8ae6: 9807         	ldr	r0, [sp, #0x1c]
700a8ae8: 9905         	ldr	r1, [sp, #0x14]
700a8aea: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a8aee: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700a8af2: 4390         	bics	r0, r2
700a8af4: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;             vintrNum = i + rmInitPrms->startVintr;  /* Add start offset */
700a8af8: 9806         	ldr	r0, [sp, #0x18]
700a8afa: 9901         	ldr	r1, [sp, #0x4]
700a8afc: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700a8b00: 4408         	add	r0, r1
700a8b02: 9002         	str	r0, [sp, #0x8]
;             break;
700a8b04: e004         	b	0x700a8b10 <Udma_rmAllocVintr+0x90> @ imm = #0x8
;     }
700a8b06: e7ff         	b	0x700a8b08 <Udma_rmAllocVintr+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a8b08: 9806         	ldr	r0, [sp, #0x18]
700a8b0a: 3001         	adds	r0, #0x1
700a8b0c: 9006         	str	r0, [sp, #0x18]
700a8b0e: e7cb         	b	0x700a8aa8 <Udma_rmAllocVintr+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a8b10: 9807         	ldr	r0, [sp, #0x1c]
700a8b12: f500 609f    	add.w	r0, r0, #0x4f8
700a8b16: f003 f94b    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x3296
;     return (vintrNum);
700a8b1a: 9802         	ldr	r0, [sp, #0x8]
700a8b1c: b008         	add	sp, #0x20
700a8b1e: bd80         	pop	{r7, pc}

700a8b20 <Sciclient_getContext>:
; {
700a8b20: b084         	sub	sp, #0x10
700a8b22: 9003         	str	r0, [sp, #0xc]
700a8b24: 9102         	str	r1, [sp, #0x8]
700a8b26: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a8b28: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700a8b2a: 9802         	ldr	r0, [sp, #0x8]
700a8b2c: 9000         	str	r0, [sp]
700a8b2e: 2805         	cmp	r0, #0x5
700a8b30: d841         	bhi	0x700a8bb6 <Sciclient_getContext+0x96> @ imm = #0x82
700a8b32: 9900         	ldr	r1, [sp]
700a8b34: e8df f001    	tbb	[pc, r1]
700a8b38: 03 0d 17 21  	.word	0x21170d03
700a8b3c: 2b 35        	.short	0x352b
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8b3e: 9803         	ldr	r0, [sp, #0xc]
700a8b40: b918         	cbnz	r0, 0x700a8b4a <Sciclient_getContext+0x2a> @ imm = #0x6
700a8b42: e7ff         	b	0x700a8b44 <Sciclient_getContext+0x24> @ imm = #-0x2
700a8b44: 200e         	movs	r0, #0xe
;             retVal = SCICLIENT_CONTEXT_M4_SEC_0;
700a8b46: 9001         	str	r0, [sp, #0x4]
;         }
700a8b48: e002         	b	0x700a8b50 <Sciclient_getContext+0x30> @ imm = #0x4
700a8b4a: 2008         	movs	r0, #0x8
;             retVal = SCICLIENT_CONTEXT_M4_NONSEC_0;
700a8b4c: 9001         	str	r0, [sp, #0x4]
700a8b4e: e7ff         	b	0x700a8b50 <Sciclient_getContext+0x30> @ imm = #-0x2
;         break;
700a8b50: e032         	b	0x700a8bb8 <Sciclient_getContext+0x98> @ imm = #0x64
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8b52: 9803         	ldr	r0, [sp, #0xc]
700a8b54: b918         	cbnz	r0, 0x700a8b5e <Sciclient_getContext+0x3e> @ imm = #0x6
700a8b56: e7ff         	b	0x700a8b58 <Sciclient_getContext+0x38> @ imm = #-0x2
700a8b58: 2000         	movs	r0, #0x0
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_0;
700a8b5a: 9001         	str	r0, [sp, #0x4]
;         }
700a8b5c: e002         	b	0x700a8b64 <Sciclient_getContext+0x44> @ imm = #0x4
700a8b5e: 2001         	movs	r0, #0x1
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_0;
700a8b60: 9001         	str	r0, [sp, #0x4]
700a8b62: e7ff         	b	0x700a8b64 <Sciclient_getContext+0x44> @ imm = #-0x2
;         break;
700a8b64: e028         	b	0x700a8bb8 <Sciclient_getContext+0x98> @ imm = #0x50
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8b66: 9803         	ldr	r0, [sp, #0xc]
700a8b68: b918         	cbnz	r0, 0x700a8b72 <Sciclient_getContext+0x52> @ imm = #0x6
700a8b6a: e7ff         	b	0x700a8b6c <Sciclient_getContext+0x4c> @ imm = #-0x2
700a8b6c: 2002         	movs	r0, #0x2
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_1;
700a8b6e: 9001         	str	r0, [sp, #0x4]
;         }
700a8b70: e002         	b	0x700a8b78 <Sciclient_getContext+0x58> @ imm = #0x4
700a8b72: 2003         	movs	r0, #0x3
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_1;
700a8b74: 9001         	str	r0, [sp, #0x4]
700a8b76: e7ff         	b	0x700a8b78 <Sciclient_getContext+0x58> @ imm = #-0x2
;         break;
700a8b78: e01e         	b	0x700a8bb8 <Sciclient_getContext+0x98> @ imm = #0x3c
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8b7a: 9803         	ldr	r0, [sp, #0xc]
700a8b7c: b918         	cbnz	r0, 0x700a8b86 <Sciclient_getContext+0x66> @ imm = #0x6
700a8b7e: e7ff         	b	0x700a8b80 <Sciclient_getContext+0x60> @ imm = #-0x2
700a8b80: 2009         	movs	r0, #0x9
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_0;
700a8b82: 9001         	str	r0, [sp, #0x4]
;         }
700a8b84: e002         	b	0x700a8b8c <Sciclient_getContext+0x6c> @ imm = #0x4
700a8b86: 200a         	movs	r0, #0xa
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_0;
700a8b88: 9001         	str	r0, [sp, #0x4]
700a8b8a: e7ff         	b	0x700a8b8c <Sciclient_getContext+0x6c> @ imm = #-0x2
;         break;
700a8b8c: e014         	b	0x700a8bb8 <Sciclient_getContext+0x98> @ imm = #0x28
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8b8e: 9803         	ldr	r0, [sp, #0xc]
700a8b90: b918         	cbnz	r0, 0x700a8b9a <Sciclient_getContext+0x7a> @ imm = #0x6
700a8b92: e7ff         	b	0x700a8b94 <Sciclient_getContext+0x74> @ imm = #-0x2
700a8b94: 200b         	movs	r0, #0xb
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_1;
700a8b96: 9001         	str	r0, [sp, #0x4]
;         }
700a8b98: e002         	b	0x700a8ba0 <Sciclient_getContext+0x80> @ imm = #0x4
700a8b9a: 200c         	movs	r0, #0xc
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_1;
700a8b9c: 9001         	str	r0, [sp, #0x4]
700a8b9e: e7ff         	b	0x700a8ba0 <Sciclient_getContext+0x80> @ imm = #-0x2
;         break;
700a8ba0: e00a         	b	0x700a8bb8 <Sciclient_getContext+0x98> @ imm = #0x14
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8ba2: 9803         	ldr	r0, [sp, #0xc]
700a8ba4: b918         	cbnz	r0, 0x700a8bae <Sciclient_getContext+0x8e> @ imm = #0x6
700a8ba6: e7ff         	b	0x700a8ba8 <Sciclient_getContext+0x88> @ imm = #-0x2
700a8ba8: 2004         	movs	r0, #0x4
;             retVal = SCICLIENT_CONTEXT_A53_SEC_0;
700a8baa: 9001         	str	r0, [sp, #0x4]
;         }
700a8bac: e002         	b	0x700a8bb4 <Sciclient_getContext+0x94> @ imm = #0x4
700a8bae: 2006         	movs	r0, #0x6
;             retVal = SCICLIENT_CONTEXT_A53_NONSEC_1;
700a8bb0: 9001         	str	r0, [sp, #0x4]
700a8bb2: e7ff         	b	0x700a8bb4 <Sciclient_getContext+0x94> @ imm = #-0x2
;         break;
700a8bb4: e000         	b	0x700a8bb8 <Sciclient_getContext+0x98> @ imm = #0x0
;         break;
700a8bb6: e7ff         	b	0x700a8bb8 <Sciclient_getContext+0x98> @ imm = #-0x2
;     return retVal;
700a8bb8: 9801         	ldr	r0, [sp, #0x4]
700a8bba: b004         	add	sp, #0x10
700a8bbc: 4770         	bx	lr
700a8bbe: 0000         	movs	r0, r0

700a8bc0 <Pinmux_config>:
; {
700a8bc0: b580         	push	{r7, lr}
700a8bc2: b086         	sub	sp, #0x18
700a8bc4: 9005         	str	r0, [sp, #0x14]
700a8bc6: 9104         	str	r1, [sp, #0x10]
700a8bc8: 2000         	movs	r0, #0x0
;     uint32_t            isUnlocked = 0;
700a8bca: 9001         	str	r0, [sp, #0x4]
;     if((NULL != pinmuxCfg) && (pinmuxCfg->offset != PINMUX_END))
700a8bcc: 9805         	ldr	r0, [sp, #0x14]
700a8bce: 2800         	cmp	r0, #0x0
700a8bd0: d042         	beq	0x700a8c58 <Pinmux_config+0x98> @ imm = #0x84
700a8bd2: e7ff         	b	0x700a8bd4 <Pinmux_config+0x14> @ imm = #-0x2
700a8bd4: 9805         	ldr	r0, [sp, #0x14]
700a8bd6: f9b0 0000    	ldrsh.w	r0, [r0]
700a8bda: 3001         	adds	r0, #0x1
700a8bdc: b3e0         	cbz	r0, 0x700a8c58 <Pinmux_config+0x98> @ imm = #0x78
700a8bde: e7ff         	b	0x700a8be0 <Pinmux_config+0x20> @ imm = #-0x2
;         if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a8be0: 9804         	ldr	r0, [sp, #0x10]
700a8be2: b920         	cbnz	r0, 0x700a8bee <Pinmux_config+0x2e> @ imm = #0x8
700a8be4: e7ff         	b	0x700a8be6 <Pinmux_config+0x26> @ imm = #-0x2
700a8be6: f44f 2074    	mov.w	r0, #0xf4000
;             baseAddr = CSL_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a8bea: 9003         	str	r0, [sp, #0xc]
;         }
700a8bec: e005         	b	0x700a8bfa <Pinmux_config+0x3a> @ imm = #0xa
700a8bee: f244 0000    	movw	r0, #0x4000
700a8bf2: f2c0 4008    	movt	r0, #0x408
;             baseAddr = CSL_MCU_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a8bf6: 9003         	str	r0, [sp, #0xc]
700a8bf8: e7ff         	b	0x700a8bfa <Pinmux_config+0x3a> @ imm = #-0x2
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(baseAddr);
700a8bfa: 9803         	ldr	r0, [sp, #0xc]
700a8bfc: 2100         	movs	r1, #0x0
700a8bfe: f7fc ff2f    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x31a2
700a8c02: 9003         	str	r0, [sp, #0xc]
;         if (pinmuxCfg->offset != PINMUX_END)
700a8c04: 9805         	ldr	r0, [sp, #0x14]
700a8c06: f9b0 0000    	ldrsh.w	r0, [r0]
700a8c0a: 3001         	adds	r0, #0x1
700a8c0c: b130         	cbz	r0, 0x700a8c1c <Pinmux_config+0x5c> @ imm = #0xc
700a8c0e: e7ff         	b	0x700a8c10 <Pinmux_config+0x50> @ imm = #-0x2
700a8c10: 2001         	movs	r0, #0x1
;             isUnlocked = 1;
700a8c12: 9001         	str	r0, [sp, #0x4]
;             Pinmux_unlockMMR(domainId);
700a8c14: 9804         	ldr	r0, [sp, #0x10]
700a8c16: f7fd fc83    	bl	0x700a6520 <Pinmux_unlockMMR> @ imm = #-0x26fa
;         }
700a8c1a: e7ff         	b	0x700a8c1c <Pinmux_config+0x5c> @ imm = #-0x2
;         while( pinmuxCfg->offset != PINMUX_END )
700a8c1c: e7ff         	b	0x700a8c1e <Pinmux_config+0x5e> @ imm = #-0x2
700a8c1e: 9805         	ldr	r0, [sp, #0x14]
700a8c20: f9b0 0000    	ldrsh.w	r0, [r0]
700a8c24: 3001         	adds	r0, #0x1
700a8c26: b178         	cbz	r0, 0x700a8c48 <Pinmux_config+0x88> @ imm = #0x1e
700a8c28: e7ff         	b	0x700a8c2a <Pinmux_config+0x6a> @ imm = #-0x2
;             regAddr = (volatile uint32_t *)(baseAddr + pinmuxCfg->offset);
700a8c2a: 9803         	ldr	r0, [sp, #0xc]
700a8c2c: 9905         	ldr	r1, [sp, #0x14]
700a8c2e: f9b1 1000    	ldrsh.w	r1, [r1]
700a8c32: 4408         	add	r0, r1
700a8c34: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(regAddr, pinmuxCfg->settings);
700a8c36: 9802         	ldr	r0, [sp, #0x8]
700a8c38: 9905         	ldr	r1, [sp, #0x14]
700a8c3a: 6849         	ldr	r1, [r1, #0x4]
700a8c3c: f006 ff30    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x6e60
;             pinmuxCfg++;
700a8c40: 9805         	ldr	r0, [sp, #0x14]
700a8c42: 3008         	adds	r0, #0x8
700a8c44: 9005         	str	r0, [sp, #0x14]
;         while( pinmuxCfg->offset != PINMUX_END )
700a8c46: e7ea         	b	0x700a8c1e <Pinmux_config+0x5e> @ imm = #-0x2c
;         if (isUnlocked)
700a8c48: 9801         	ldr	r0, [sp, #0x4]
700a8c4a: b120         	cbz	r0, 0x700a8c56 <Pinmux_config+0x96> @ imm = #0x8
700a8c4c: e7ff         	b	0x700a8c4e <Pinmux_config+0x8e> @ imm = #-0x2
;             Pinmux_lockMMR(domainId);
700a8c4e: 9804         	ldr	r0, [sp, #0x10]
700a8c50: f002 fcf6    	bl	0x700ab640 <Pinmux_lockMMR> @ imm = #0x29ec
;         }
700a8c54: e7ff         	b	0x700a8c56 <Pinmux_config+0x96> @ imm = #-0x2
;     }
700a8c56: e7ff         	b	0x700a8c58 <Pinmux_config+0x98> @ imm = #-0x2
;     return;
700a8c58: b006         	add	sp, #0x18
700a8c5a: bd80         	pop	{r7, pc}
700a8c5c: 0000         	movs	r0, r0
700a8c5e: 0000         	movs	r0, r0

700a8c60 <rtos_main_freertos>:
; {
700a8c60: b082         	sub	sp, #0x8
;    System_init();
700a8c62: f005 fe45    	bl	0x700ae8f0 <System_init> @ imm = #0x5c8a
;    Board_init();
700a8c66: f007 f88b    	bl	0x700afd80 <Board_init> @ imm = #0x7116
;    Drivers_open();
700a8c6a: f004 f929    	bl	0x700acec0 <Drivers_open> @ imm = #0x4252
;    Board_driversOpen();
700a8c6e: f007 f837    	bl	0x700afce0 <Board_driversOpen> @ imm = #0x706e
;    printf("Initializing FreeRTOS system...\r\n");
700a8c72: f641 4188    	movw	r1, #0x1c88
700a8c76: 2001         	movs	r0, #0x1
700a8c78: f2c7 010b    	movt	r1, #0x700b
700a8c7c: f000 ff70    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #0xee0
;    BaseType_t status = xTaskCreate(main_task, "MainTask", MAIN_TASK_STACK_SIZE, NULL, MAIN_TASK_PRI, NULL);
700a8c80: f64a 30d1    	movw	r0, #0xabd1
700a8c84: f242 1179    	movw	r1, #0x2179
700a8c88: f2c7 000a    	movt	r0, #0x700a
700a8c8c: f2c7 010b    	movt	r1, #0x700b
700a8c90: 241e         	movs	r4, #0x1e
700a8c92: f44f 5200    	mov.w	r2, #0x2000
700a8c96: 2300         	movs	r3, #0x0
700a8c98: f04f 0c00    	mov.w	r12, #0x0
700a8c9c: e9cd 4c00    	strd	r4, r12, [sp]
700a8ca0: f000 fb4e    	bl	0x700a9340 <xTaskCreate> @ imm = #0x69c
;    if (status != pdPASS)
700a8ca4: 2801         	cmp	r0, #0x1
700a8ca6: d010         	beq	0x700a8cca <rtos_main_freertos+0x6a> @ imm = #0x20
;       DebugP_assert(status == pdPASS);
700a8ca8: f641 7124    	movw	r1, #0x1f24
700a8cac: f641 727c    	movw	r2, #0x1f7c
700a8cb0: f242 047d    	movw	r4, #0x207d
700a8cb4: f2c7 010b    	movt	r1, #0x700b
700a8cb8: f2c7 020b    	movt	r2, #0x700b
700a8cbc: f2c7 040b    	movt	r4, #0x700b
700a8cc0: 2000         	movs	r0, #0x0
700a8cc2: 2381         	movs	r3, #0x81
700a8cc4: 9400         	str	r4, [sp]
700a8cc6: f001 ff03    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x1e06
;    vTaskStartScheduler();
700a8cca: f7fe fc61    	bl	0x700a7590 <vTaskStartScheduler> @ imm = #-0x173e
700a8cce: f641 4444    	movw	r4, #0x1c44
700a8cd2: f2c7 040b    	movt	r4, #0x700b
700a8cd6: bf00         	nop
700a8cd8: bf00         	nop
700a8cda: bf00         	nop
700a8cdc: bf00         	nop
700a8cde: bf00         	nop
;       printf("Scheduler returned unexpectedly\r\n");
700a8ce0: 4621         	mov	r1, r4
700a8ce2: f04f 0001    	mov.w	r0, #0x1
700a8ce6: f000 ff3b    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #0xe76
700a8cea: 4621         	mov	r1, r4
700a8cec: 2001         	movs	r0, #0x1
700a8cee: f000 ff37    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #0xe6e
700a8cf2: 4621         	mov	r1, r4
700a8cf4: 2001         	movs	r0, #0x1
700a8cf6: f000 ff33    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #0xe66
;    for (;;)
700a8cfa: e7f1         	b	0x700a8ce0 <rtos_main_freertos+0x80> @ imm = #-0x1e
700a8cfc: 0000         	movs	r0, r0
700a8cfe: 0000         	movs	r0, r0

700a8d00 <SOC_controlModuleUnlockMMR>:
; {
700a8d00: b580         	push	{r7, lr}
700a8d02: b084         	sub	sp, #0x10
700a8d04: 9003         	str	r0, [sp, #0xc]
700a8d06: 9102         	str	r1, [sp, #0x8]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700a8d08: 9803         	ldr	r0, [sp, #0xc]
700a8d0a: bb00         	cbnz	r0, 0x700a8d4e <SOC_controlModuleUnlockMMR+0x4e> @ imm = #0x40
700a8d0c: e7ff         	b	0x700a8d0e <SOC_controlModuleUnlockMMR+0xe> @ imm = #-0x2
700a8d0e: f04f 4086    	mov.w	r0, #0x43000000
700a8d12: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700a8d14: f7fc fea4    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x32b8
700a8d18: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a8d1a: 9801         	ldr	r0, [sp, #0x4]
700a8d1c: 9902         	ldr	r1, [sp, #0x8]
700a8d1e: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a8d22: f241 0108    	movw	r1, #0x1008
700a8d26: 4408         	add	r0, r1
700a8d28: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a8d2a: 9800         	ldr	r0, [sp]
700a8d2c: f243 4190    	movw	r1, #0x3490
700a8d30: f6c6 01ef    	movt	r1, #0x68ef
700a8d34: f006 fec4    	bl	0x700afac0 <CSL_REG32_WR_RAW> @ imm = #0x6d88
;         kickAddr++;
700a8d38: 9800         	ldr	r0, [sp]
700a8d3a: 3004         	adds	r0, #0x4
700a8d3c: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a8d3e: 9800         	ldr	r0, [sp]
700a8d40: f64b 415a    	movw	r1, #0xbc5a
700a8d44: f2cd 1172    	movt	r1, #0xd172
700a8d48: f006 feba    	bl	0x700afac0 <CSL_REG32_WR_RAW> @ imm = #0x6d74
;     }
700a8d4c: e7ff         	b	0x700a8d4e <SOC_controlModuleUnlockMMR+0x4e> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700a8d4e: 9803         	ldr	r0, [sp, #0xc]
700a8d50: 2801         	cmp	r0, #0x1
700a8d52: d120         	bne	0x700a8d96 <SOC_controlModuleUnlockMMR+0x96> @ imm = #0x40
700a8d54: e7ff         	b	0x700a8d56 <SOC_controlModuleUnlockMMR+0x56> @ imm = #-0x2
700a8d56: f04f 608a    	mov.w	r0, #0x4500000
700a8d5a: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700a8d5c: f7fc fe80    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x3300
700a8d60: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a8d62: 9801         	ldr	r0, [sp, #0x4]
700a8d64: 9902         	ldr	r1, [sp, #0x8]
700a8d66: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a8d6a: f241 0108    	movw	r1, #0x1008
700a8d6e: 4408         	add	r0, r1
700a8d70: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a8d72: 9800         	ldr	r0, [sp]
700a8d74: f243 4190    	movw	r1, #0x3490
700a8d78: f6c6 01ef    	movt	r1, #0x68ef
700a8d7c: f006 fea0    	bl	0x700afac0 <CSL_REG32_WR_RAW> @ imm = #0x6d40
;         kickAddr++;
700a8d80: 9800         	ldr	r0, [sp]
700a8d82: 3004         	adds	r0, #0x4
700a8d84: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a8d86: 9800         	ldr	r0, [sp]
700a8d88: f64b 415a    	movw	r1, #0xbc5a
700a8d8c: f2cd 1172    	movt	r1, #0xd172
700a8d90: f006 fe96    	bl	0x700afac0 <CSL_REG32_WR_RAW> @ imm = #0x6d2c
;     }
700a8d94: e7ff         	b	0x700a8d96 <SOC_controlModuleUnlockMMR+0x96> @ imm = #-0x2
;     return;
700a8d96: b004         	add	sp, #0x10
700a8d98: bd80         	pop	{r7, pc}
700a8d9a: 0000         	movs	r0, r0
700a8d9c: 0000         	movs	r0, r0
700a8d9e: 0000         	movs	r0, r0

700a8da0 <Sciclient_pmGetModuleClkFreq>:
; {
700a8da0: b580         	push	{r7, lr}
700a8da2: b096         	sub	sp, #0x58
700a8da4: 9015         	str	r0, [sp, #0x54]
700a8da6: 9114         	str	r1, [sp, #0x50]
700a8da8: 9213         	str	r2, [sp, #0x4c]
700a8daa: 9312         	str	r3, [sp, #0x48]
700a8dac: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a8dae: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a8db0: 9815         	ldr	r0, [sp, #0x54]
700a8db2: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a8db4: 9814         	ldr	r0, [sp, #0x50]
700a8db6: 28ff         	cmp	r0, #0xff
700a8db8: d307         	blo	0x700a8dca <Sciclient_pmGetModuleClkFreq+0x2a> @ imm = #0xe
700a8dba: e7ff         	b	0x700a8dbc <Sciclient_pmGetModuleClkFreq+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a8dbc: 9814         	ldr	r0, [sp, #0x50]
700a8dbe: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a8dc2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a8dc4: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a8dc8: e003         	b	0x700a8dd2 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a8dca: 9814         	ldr	r0, [sp, #0x50]
700a8dcc: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a8dd0: e7ff         	b	0x700a8dd2 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #-0x2
700a8dd2: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_freq_resp response = {{0}};
700a8dd4: 900b         	str	r0, [sp, #0x2c]
700a8dd6: 900a         	str	r0, [sp, #0x28]
700a8dd8: 9009         	str	r0, [sp, #0x24]
700a8dda: 9008         	str	r0, [sp, #0x20]
700a8ddc: f44f 7187    	mov.w	r1, #0x10e
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_FREQ;
700a8de0: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a8de4: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a8de6: 9104         	str	r1, [sp, #0x10]
700a8de8: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a8dea: 9105         	str	r1, [sp, #0x14]
700a8dec: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a8dee: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a8df0: 9912         	ldr	r1, [sp, #0x48]
700a8df2: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a8df4: 9000         	str	r0, [sp]
700a8df6: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a8df8: 9001         	str	r0, [sp, #0x4]
700a8dfa: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a8dfc: 9002         	str	r0, [sp, #0x8]
700a8dfe: a803         	add	r0, sp, #0xc
700a8e00: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a8e02: f7f4 f9bd    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xbc86
700a8e06: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a8e08: 9811         	ldr	r0, [sp, #0x44]
700a8e0a: b930         	cbnz	r0, 0x700a8e1a <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #0xc
700a8e0c: e7ff         	b	0x700a8e0e <Sciclient_pmGetModuleClkFreq+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a8e0e: 9800         	ldr	r0, [sp]
700a8e10: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8e14: 2802         	cmp	r0, #0x2
700a8e16: d004         	beq	0x700a8e22 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #0x8
700a8e18: e7ff         	b	0x700a8e1a <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #-0x2
700a8e1a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a8e1e: 9011         	str	r0, [sp, #0x44]
;     }
700a8e20: e7ff         	b	0x700a8e22 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a8e22: 9811         	ldr	r0, [sp, #0x44]
700a8e24: b930         	cbnz	r0, 0x700a8e34 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #0xc
700a8e26: e7ff         	b	0x700a8e28 <Sciclient_pmGetModuleClkFreq+0x88> @ imm = #-0x2
;         *freqHz = (uint64_t) response.freq_hz;
700a8e28: 980a         	ldr	r0, [sp, #0x28]
700a8e2a: 9a0b         	ldr	r2, [sp, #0x2c]
700a8e2c: 9913         	ldr	r1, [sp, #0x4c]
700a8e2e: 604a         	str	r2, [r1, #0x4]
700a8e30: 6008         	str	r0, [r1]
;     }
700a8e32: e7ff         	b	0x700a8e34 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #-0x2
;     return retVal;
700a8e34: 9811         	ldr	r0, [sp, #0x44]
700a8e36: b016         	add	sp, #0x58
700a8e38: bd80         	pop	{r7, pc}
700a8e3a: 0000         	movs	r0, r0
700a8e3c: 0000         	movs	r0, r0
700a8e3e: 0000         	movs	r0, r0

700a8e40 <Sciclient_pmGetModuleClkParent>:
; {
700a8e40: b580         	push	{r7, lr}
700a8e42: b096         	sub	sp, #0x58
700a8e44: 9015         	str	r0, [sp, #0x54]
700a8e46: 9114         	str	r1, [sp, #0x50]
700a8e48: 9213         	str	r2, [sp, #0x4c]
700a8e4a: 9312         	str	r3, [sp, #0x48]
700a8e4c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a8e4e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a8e50: 9815         	ldr	r0, [sp, #0x54]
700a8e52: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a8e54: 9814         	ldr	r0, [sp, #0x50]
700a8e56: 28ff         	cmp	r0, #0xff
700a8e58: d307         	blo	0x700a8e6a <Sciclient_pmGetModuleClkParent+0x2a> @ imm = #0xe
700a8e5a: e7ff         	b	0x700a8e5c <Sciclient_pmGetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a8e5c: 9814         	ldr	r0, [sp, #0x50]
700a8e5e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a8e62: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a8e64: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a8e68: e003         	b	0x700a8e72 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a8e6a: 9814         	ldr	r0, [sp, #0x50]
700a8e6c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a8e70: e7ff         	b	0x700a8e72 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #-0x2
700a8e72: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_parent_resp response = {{0}};
700a8e74: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a8e78: 900a         	str	r0, [sp, #0x28]
700a8e7a: 9009         	str	r0, [sp, #0x24]
700a8e7c: 9008         	str	r0, [sp, #0x20]
700a8e7e: f240 1103    	movw	r1, #0x103
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK_PARENT;
700a8e82: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a8e86: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a8e88: 9104         	str	r1, [sp, #0x10]
700a8e8a: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a8e8c: 9105         	str	r1, [sp, #0x14]
700a8e8e: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a8e90: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a8e92: 9912         	ldr	r1, [sp, #0x48]
700a8e94: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a8e96: 9000         	str	r0, [sp]
700a8e98: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a8e9a: 9001         	str	r0, [sp, #0x4]
700a8e9c: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a8e9e: 9002         	str	r0, [sp, #0x8]
700a8ea0: a803         	add	r0, sp, #0xc
700a8ea2: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a8ea4: f7f4 f96c    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xbd28
700a8ea8: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a8eaa: 9811         	ldr	r0, [sp, #0x44]
700a8eac: b930         	cbnz	r0, 0x700a8ebc <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #0xc
700a8eae: e7ff         	b	0x700a8eb0 <Sciclient_pmGetModuleClkParent+0x70> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a8eb0: 9800         	ldr	r0, [sp]
700a8eb2: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8eb6: 2802         	cmp	r0, #0x2
700a8eb8: d004         	beq	0x700a8ec4 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #0x8
700a8eba: e7ff         	b	0x700a8ebc <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #-0x2
700a8ebc: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a8ec0: 9011         	str	r0, [sp, #0x44]
;     }
700a8ec2: e7ff         	b	0x700a8ec4 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a8ec4: 9811         	ldr	r0, [sp, #0x44]
700a8ec6: b928         	cbnz	r0, 0x700a8ed4 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #0xa
700a8ec8: e7ff         	b	0x700a8eca <Sciclient_pmGetModuleClkParent+0x8a> @ imm = #-0x2
;         *parent = (uint32_t) response.parent;
700a8eca: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a8ece: 9913         	ldr	r1, [sp, #0x4c]
700a8ed0: 6008         	str	r0, [r1]
;     }
700a8ed2: e7ff         	b	0x700a8ed4 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a8ed4: 9811         	ldr	r0, [sp, #0x44]
700a8ed6: b016         	add	sp, #0x58
700a8ed8: bd80         	pop	{r7, pc}
700a8eda: 0000         	movs	r0, r0
700a8edc: 0000         	movs	r0, r0
700a8ede: 0000         	movs	r0, r0

700a8ee0 <Sciclient_pmSetModuleClkParent>:
; {
700a8ee0: b580         	push	{r7, lr}
700a8ee2: b094         	sub	sp, #0x50
700a8ee4: 9013         	str	r0, [sp, #0x4c]
700a8ee6: 9112         	str	r1, [sp, #0x48]
700a8ee8: 9211         	str	r2, [sp, #0x44]
700a8eea: 9310         	str	r3, [sp, #0x40]
700a8eec: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a8eee: 900f         	str	r0, [sp, #0x3c]
;     request.device = (uint32_t) moduleId;
700a8ef0: 9813         	ldr	r0, [sp, #0x4c]
700a8ef2: 900b         	str	r0, [sp, #0x2c]
;     if (clockId >= 255U)
700a8ef4: 9812         	ldr	r0, [sp, #0x48]
700a8ef6: 28ff         	cmp	r0, #0xff
700a8ef8: d307         	blo	0x700a8f0a <Sciclient_pmSetModuleClkParent+0x2a> @ imm = #0xe
700a8efa: e7ff         	b	0x700a8efc <Sciclient_pmSetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a8efc: 9812         	ldr	r0, [sp, #0x48]
700a8efe: f8cd 0032    	str.w	r0, [sp, #0x32]
700a8f02: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a8f04: f88d 0030    	strb.w	r0, [sp, #0x30]
;     }
700a8f08: e003         	b	0x700a8f12 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a8f0a: 9812         	ldr	r0, [sp, #0x48]
700a8f0c: f88d 0030    	strb.w	r0, [sp, #0x30]
700a8f10: e7ff         	b	0x700a8f12 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #-0x2
;     if (parent >= 255U)
700a8f12: 9811         	ldr	r0, [sp, #0x44]
700a8f14: 28ff         	cmp	r0, #0xff
700a8f16: d307         	blo	0x700a8f28 <Sciclient_pmSetModuleClkParent+0x48> @ imm = #0xe
700a8f18: e7ff         	b	0x700a8f1a <Sciclient_pmSetModuleClkParent+0x3a> @ imm = #-0x2
;         request.parent32 = parent;
700a8f1a: 9811         	ldr	r0, [sp, #0x44]
700a8f1c: f8cd 0036    	str.w	r0, [sp, #0x36]
700a8f20: 20ff         	movs	r0, #0xff
;         request.parent   = (uint8_t) 255U;
700a8f22: f88d 0031    	strb.w	r0, [sp, #0x31]
;     }
700a8f26: e003         	b	0x700a8f30 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #0x6
;         request.parent = (uint8_t) parent;
700a8f28: 9811         	ldr	r0, [sp, #0x44]
700a8f2a: f88d 0031    	strb.w	r0, [sp, #0x31]
700a8f2e: e7ff         	b	0x700a8f30 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #-0x2
700a8f30: f44f 7081    	mov.w	r0, #0x102
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK_PARENT;
700a8f34: f8ad 0010    	strh.w	r0, [sp, #0x10]
700a8f38: 2002         	movs	r0, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a8f3a: 9005         	str	r0, [sp, #0x14]
700a8f3c: a809         	add	r0, sp, #0x24
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a8f3e: 9006         	str	r0, [sp, #0x18]
700a8f40: 2016         	movs	r0, #0x16
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a8f42: 9007         	str	r0, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a8f44: 9810         	ldr	r0, [sp, #0x40]
700a8f46: 9008         	str	r0, [sp, #0x20]
700a8f48: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a8f4a: 9001         	str	r0, [sp, #0x4]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a8f4c: 9002         	str	r0, [sp, #0x8]
;     respParam.respPayloadSize = (uint32_t) 0;
700a8f4e: 9003         	str	r0, [sp, #0xc]
700a8f50: a804         	add	r0, sp, #0x10
700a8f52: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a8f54: f7f4 f914    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xbdd8
700a8f58: 900f         	str	r0, [sp, #0x3c]
;     if((retVal != SystemP_SUCCESS) ||
700a8f5a: 980f         	ldr	r0, [sp, #0x3c]
700a8f5c: b930         	cbnz	r0, 0x700a8f6c <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #0xc
700a8f5e: e7ff         	b	0x700a8f60 <Sciclient_pmSetModuleClkParent+0x80> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a8f60: 9801         	ldr	r0, [sp, #0x4]
700a8f62: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8f66: 2802         	cmp	r0, #0x2
700a8f68: d004         	beq	0x700a8f74 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #0x8
700a8f6a: e7ff         	b	0x700a8f6c <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #-0x2
700a8f6c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a8f70: 900f         	str	r0, [sp, #0x3c]
;     }
700a8f72: e7ff         	b	0x700a8f74 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a8f74: 980f         	ldr	r0, [sp, #0x3c]
700a8f76: b014         	add	sp, #0x50
700a8f78: bd80         	pop	{r7, pc}
700a8f7a: 0000         	movs	r0, r0
700a8f7c: 0000         	movs	r0, r0
700a8f7e: 0000         	movs	r0, r0

700a8f80 <Sciclient_rmIrOutpIsFree>:
; {
700a8f80: b580         	push	{r7, lr}
700a8f82: b086         	sub	sp, #0x18
700a8f84: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a8f88: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a8f8c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a8f8e: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIrInst *inst = NULL;
700a8f90: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a8f92: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a8f96: f002 fd4b    	bl	0x700aba30 <Sciclient_rmIrGetInst> @ imm = #0x2a96
700a8f9a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a8f9c: 9803         	ldr	r0, [sp, #0xc]
700a8f9e: b920         	cbnz	r0, 0x700a8faa <Sciclient_rmIrOutpIsFree+0x2a> @ imm = #0x8
700a8fa0: e7ff         	b	0x700a8fa2 <Sciclient_rmIrOutpIsFree+0x22> @ imm = #-0x2
700a8fa2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a8fa6: 9004         	str	r0, [sp, #0x10]
;     } else {
700a8fa8: e00b         	b	0x700a8fc2 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #0x16
;         if (outp >= inst->n_outp) {
700a8faa: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a8fae: 9903         	ldr	r1, [sp, #0xc]
700a8fb0: 8949         	ldrh	r1, [r1, #0xa]
700a8fb2: 4288         	cmp	r0, r1
700a8fb4: db04         	blt	0x700a8fc0 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #0x8
700a8fb6: e7ff         	b	0x700a8fb8 <Sciclient_rmIrOutpIsFree+0x38> @ imm = #-0x2
700a8fb8: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a8fbc: 9004         	str	r0, [sp, #0x10]
;         }
700a8fbe: e7ff         	b	0x700a8fc0 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #-0x2
700a8fc0: e7ff         	b	0x700a8fc2 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a8fc2: 9804         	ldr	r0, [sp, #0x10]
700a8fc4: bb30         	cbnz	r0, 0x700a9014 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #0x4c
700a8fc6: e7ff         	b	0x700a8fc8 <Sciclient_rmIrOutpIsFree+0x48> @ imm = #-0x2
;         int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, outp);
700a8fc8: 9803         	ldr	r0, [sp, #0xc]
700a8fca: 6840         	ldr	r0, [r0, #0x4]
700a8fcc: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a8fd0: f005 fd96    	bl	0x700aeb00 <Sciclient_getIrAddr> @ imm = #0x5b2c
700a8fd4: 9002         	str	r0, [sp, #0x8]
;         extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a8fd6: 9802         	ldr	r0, [sp, #0x8]
700a8fd8: f240 31ff    	movw	r1, #0x3ff
700a8fdc: 2200         	movs	r2, #0x0
700a8fde: f006 f877    	bl	0x700af0d0 <CSL_REG32_FEXT_RAW> @ imm = #0x60ee
700a8fe2: f8ad 0006    	strh.w	r0, [sp, #0x6]
;         if (((extracted_inp != 0u) &&
700a8fe6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a8fea: b138         	cbz	r0, 0x700a8ffc <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #0xe
700a8fec: e7ff         	b	0x700a8fee <Sciclient_rmIrOutpIsFree+0x6e> @ imm = #-0x2
;              (Sciclient_rmIrOutpRomMapped(inst, outp) == false)) ||
700a8fee: 9803         	ldr	r0, [sp, #0xc]
700a8ff0: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a8ff4: f7ff f934    	bl	0x700a8260 <Sciclient_rmIrOutpRomMapped> @ imm = #-0xd98
700a8ff8: b138         	cbz	r0, 0x700a900a <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #0xe
700a8ffa: e7ff         	b	0x700a8ffc <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #-0x2
;             (outp == inst->inp0_mapping)) {
700a8ffc: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a9000: 9903         	ldr	r1, [sp, #0xc]
700a9002: 8989         	ldrh	r1, [r1, #0xc]
;         if (((extracted_inp != 0u) &&
700a9004: 4288         	cmp	r0, r1
700a9006: d104         	bne	0x700a9012 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #0x8
700a9008: e7ff         	b	0x700a900a <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #-0x2
700a900a: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a900e: 9004         	str	r0, [sp, #0x10]
;         }
700a9010: e7ff         	b	0x700a9012 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #-0x2
;     }
700a9012: e7ff         	b	0x700a9014 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #-0x2
;     return r;
700a9014: 9804         	ldr	r0, [sp, #0x10]
700a9016: b006         	add	sp, #0x18
700a9018: bd80         	pop	{r7, pc}
700a901a: 0000         	movs	r0, r0
700a901c: 0000         	movs	r0, r0
700a901e: 0000         	movs	r0, r0

700a9020 <Udma_ringQueueRaw>:
; {
700a9020: b580         	push	{r7, lr}
700a9022: b088         	sub	sp, #0x20
700a9024: 9007         	str	r0, [sp, #0x1c]
700a9026: 9305         	str	r3, [sp, #0x14]
700a9028: 9204         	str	r2, [sp, #0x10]
700a902a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a902c: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a902e: 9807         	ldr	r0, [sp, #0x1c]
700a9030: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a9032: 9800         	ldr	r0, [sp]
700a9034: b180         	cbz	r0, 0x700a9058 <Udma_ringQueueRaw+0x38> @ imm = #0x20
700a9036: e7ff         	b	0x700a9038 <Udma_ringQueueRaw+0x18> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a9038: 9800         	ldr	r0, [sp]
700a903a: 6d80         	ldr	r0, [r0, #0x58]
700a903c: f64a 31cd    	movw	r1, #0xabcd
700a9040: f6ca 31dc    	movt	r1, #0xabdc
700a9044: 4288         	cmp	r0, r1
700a9046: d107         	bne	0x700a9058 <Udma_ringQueueRaw+0x38> @ imm = #0xe
700a9048: e7ff         	b	0x700a904a <Udma_ringQueueRaw+0x2a> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a904a: 9800         	ldr	r0, [sp]
700a904c: 8880         	ldrh	r0, [r0, #0x4]
700a904e: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a9052: 4288         	cmp	r0, r1
700a9054: d104         	bne	0x700a9060 <Udma_ringQueueRaw+0x40> @ imm = #0x8
700a9056: e7ff         	b	0x700a9058 <Udma_ringQueueRaw+0x38> @ imm = #-0x2
700a9058: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a905c: 9003         	str	r0, [sp, #0xc]
;     }
700a905e: e7ff         	b	0x700a9060 <Udma_ringQueueRaw+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9060: 9803         	ldr	r0, [sp, #0xc]
700a9062: b9a8         	cbnz	r0, 0x700a9090 <Udma_ringQueueRaw+0x70> @ imm = #0x2a
700a9064: e7ff         	b	0x700a9066 <Udma_ringQueueRaw+0x46> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a9066: 9800         	ldr	r0, [sp]
700a9068: 6800         	ldr	r0, [r0]
700a906a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a906c: 9801         	ldr	r0, [sp, #0x4]
700a906e: b150         	cbz	r0, 0x700a9086 <Udma_ringQueueRaw+0x66> @ imm = #0x14
700a9070: e7ff         	b	0x700a9072 <Udma_ringQueueRaw+0x52> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a9072: 9801         	ldr	r0, [sp, #0x4]
700a9074: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a9078: f64a 31cd    	movw	r1, #0xabcd
700a907c: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a9080: 4288         	cmp	r0, r1
700a9082: d004         	beq	0x700a908e <Udma_ringQueueRaw+0x6e> @ imm = #0x8
700a9084: e7ff         	b	0x700a9086 <Udma_ringQueueRaw+0x66> @ imm = #-0x2
700a9086: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a908a: 9003         	str	r0, [sp, #0xc]
;         }
700a908c: e7ff         	b	0x700a908e <Udma_ringQueueRaw+0x6e> @ imm = #-0x2
;     }
700a908e: e7ff         	b	0x700a9090 <Udma_ringQueueRaw+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9090: 9803         	ldr	r0, [sp, #0xc]
700a9092: b978         	cbnz	r0, 0x700a90b4 <Udma_ringQueueRaw+0x94> @ imm = #0x1e
700a9094: e7ff         	b	0x700a9096 <Udma_ringQueueRaw+0x76> @ imm = #-0x2
;         cookie = HwiP_disable();
700a9096: f007 ec44    	blx	0x700b0920 <HwiP_disable> @ imm = #0x7888
700a909a: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringQueueRaw(drvHandle, ringHandleInt, phyDescMem);
700a909c: 9801         	ldr	r0, [sp, #0x4]
700a909e: f8d0 c594    	ldr.w	r12, [r0, #0x594]
700a90a2: 9900         	ldr	r1, [sp]
700a90a4: 9a04         	ldr	r2, [sp, #0x10]
700a90a6: 9b05         	ldr	r3, [sp, #0x14]
700a90a8: 47e0         	blx	r12
700a90aa: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a90ac: 9802         	ldr	r0, [sp, #0x8]
700a90ae: f007 ec58    	blx	0x700b0960 <HwiP_restore> @ imm = #0x78b0
;     }
700a90b2: e7ff         	b	0x700a90b4 <Udma_ringQueueRaw+0x94> @ imm = #-0x2
;     return (retVal);
700a90b4: 9803         	ldr	r0, [sp, #0xc]
700a90b6: b008         	add	sp, #0x20
700a90b8: bd80         	pop	{r7, pc}
700a90ba: 0000         	movs	r0, r0
700a90bc: 0000         	movs	r0, r0
700a90be: 0000         	movs	r0, r0

700a90c0 <xTaskCheckForTimeOut>:
;                                 TickType_t *const pxTicksToWait) {
700a90c0: b580         	push	{r7, lr}
700a90c2: b086         	sub	sp, #0x18
700a90c4: 9005         	str	r0, [sp, #0x14]
700a90c6: 9104         	str	r1, [sp, #0x10]
;   taskENTER_CRITICAL();
700a90c8: f005 fafa    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x55f4
;     const TickType_t xConstTickCount = xTickCount;
700a90cc: f642 2044    	movw	r0, #0x2a44
700a90d0: f2c7 000b    	movt	r0, #0x700b
700a90d4: 6800         	ldr	r0, [r0]
700a90d6: 9002         	str	r0, [sp, #0x8]
;         xConstTickCount - pxTimeOut->xTimeOnEntering;
700a90d8: 9802         	ldr	r0, [sp, #0x8]
700a90da: 9905         	ldr	r1, [sp, #0x14]
700a90dc: 6849         	ldr	r1, [r1, #0x4]
700a90de: 1a40         	subs	r0, r0, r1
;     const TickType_t xElapsedTime =
700a90e0: 9001         	str	r0, [sp, #0x4]
;         if (*pxTicksToWait == portMAX_DELAY) {
700a90e2: 9804         	ldr	r0, [sp, #0x10]
700a90e4: 6800         	ldr	r0, [r0]
700a90e6: 3001         	adds	r0, #0x1
700a90e8: b918         	cbnz	r0, 0x700a90f2 <xTaskCheckForTimeOut+0x32> @ imm = #0x6
700a90ea: e7ff         	b	0x700a90ec <xTaskCheckForTimeOut+0x2c> @ imm = #-0x2
700a90ec: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a90ee: 9003         	str	r0, [sp, #0xc]
;     } else
700a90f0: e02e         	b	0x700a9150 <xTaskCheckForTimeOut+0x90> @ imm = #0x5c
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a90f2: f642 2038    	movw	r0, #0x2a38
700a90f6: f2c7 000b    	movt	r0, #0x700b
700a90fa: 6800         	ldr	r0, [r0]
700a90fc: 9905         	ldr	r1, [sp, #0x14]
700a90fe: 6809         	ldr	r1, [r1]
700a9100: 4288         	cmp	r0, r1
700a9102: d00c         	beq	0x700a911e <xTaskCheckForTimeOut+0x5e> @ imm = #0x18
700a9104: e7ff         	b	0x700a9106 <xTaskCheckForTimeOut+0x46> @ imm = #-0x2
;             (xConstTickCount >=
700a9106: 9802         	ldr	r0, [sp, #0x8]
;              pxTimeOut
700a9108: 9905         	ldr	r1, [sp, #0x14]
;                  ->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to
700a910a: 6849         	ldr	r1, [r1, #0x4]
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a910c: 4288         	cmp	r0, r1
700a910e: d306         	blo	0x700a911e <xTaskCheckForTimeOut+0x5e> @ imm = #0xc
700a9110: e7ff         	b	0x700a9112 <xTaskCheckForTimeOut+0x52> @ imm = #-0x2
700a9112: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a9114: 9003         	str	r0, [sp, #0xc]
;       *pxTicksToWait = (TickType_t)0;
700a9116: 9904         	ldr	r1, [sp, #0x10]
700a9118: 2000         	movs	r0, #0x0
700a911a: 6008         	str	r0, [r1]
;     } else if (xElapsedTime <
700a911c: e017         	b	0x700a914e <xTaskCheckForTimeOut+0x8e> @ imm = #0x2e
700a911e: 9801         	ldr	r0, [sp, #0x4]
;                *pxTicksToWait) /*lint !e961 Explicit casting is only redundant
700a9120: 9904         	ldr	r1, [sp, #0x10]
700a9122: 6809         	ldr	r1, [r1]
;     } else if (xElapsedTime <
700a9124: 4288         	cmp	r0, r1
700a9126: d20b         	bhs	0x700a9140 <xTaskCheckForTimeOut+0x80> @ imm = #0x16
700a9128: e7ff         	b	0x700a912a <xTaskCheckForTimeOut+0x6a> @ imm = #-0x2
;       *pxTicksToWait -= xElapsedTime;
700a912a: 9a01         	ldr	r2, [sp, #0x4]
700a912c: 9904         	ldr	r1, [sp, #0x10]
700a912e: 6808         	ldr	r0, [r1]
700a9130: 1a80         	subs	r0, r0, r2
700a9132: 6008         	str	r0, [r1]
;       vTaskInternalSetTimeOutState(pxTimeOut);
700a9134: 9805         	ldr	r0, [sp, #0x14]
700a9136: f006 f83b    	bl	0x700af1b0 <vTaskInternalSetTimeOutState> @ imm = #0x6076
700a913a: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a913c: 9003         	str	r0, [sp, #0xc]
;     } else {
700a913e: e005         	b	0x700a914c <xTaskCheckForTimeOut+0x8c> @ imm = #0xa
;       *pxTicksToWait = (TickType_t)0;
700a9140: 9904         	ldr	r1, [sp, #0x10]
700a9142: 2000         	movs	r0, #0x0
700a9144: 6008         	str	r0, [r1]
700a9146: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a9148: 9003         	str	r0, [sp, #0xc]
700a914a: e7ff         	b	0x700a914c <xTaskCheckForTimeOut+0x8c> @ imm = #-0x2
700a914c: e7ff         	b	0x700a914e <xTaskCheckForTimeOut+0x8e> @ imm = #-0x2
700a914e: e7ff         	b	0x700a9150 <xTaskCheckForTimeOut+0x90> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a9150: f004 fb56    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x46ac
;   return xReturn;
700a9154: 9803         	ldr	r0, [sp, #0xc]
700a9156: b006         	add	sp, #0x18
700a9158: bd80         	pop	{r7, pc}
700a915a: 0000         	movs	r0, r0
700a915c: 0000         	movs	r0, r0
700a915e: 0000         	movs	r0, r0

700a9160 <CSL_bcdmaChanOpSetChanEnable>:
; {
700a9160: b580         	push	{r7, lr}
700a9162: b086         	sub	sp, #0x18
700a9164: 9005         	str	r0, [sp, #0x14]
700a9166: 9104         	str	r1, [sp, #0x10]
700a9168: 9203         	str	r2, [sp, #0xc]
700a916a: f88d 300b    	strb.w	r3, [sp, #0xb]
700a916e: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a9170: 9001         	str	r0, [sp, #0x4]
;     switch( chanType )
700a9172: 9804         	ldr	r0, [sp, #0x10]
700a9174: 9000         	str	r0, [sp]
700a9176: b140         	cbz	r0, 0x700a918a <CSL_bcdmaChanOpSetChanEnable+0x2a> @ imm = #0x10
700a9178: e7ff         	b	0x700a917a <CSL_bcdmaChanOpSetChanEnable+0x1a> @ imm = #-0x2
700a917a: 9800         	ldr	r0, [sp]
700a917c: 2801         	cmp	r0, #0x1
700a917e: d014         	beq	0x700a91aa <CSL_bcdmaChanOpSetChanEnable+0x4a> @ imm = #0x28
700a9180: e7ff         	b	0x700a9182 <CSL_bcdmaChanOpSetChanEnable+0x22> @ imm = #-0x2
700a9182: 9800         	ldr	r0, [sp]
700a9184: 2802         	cmp	r0, #0x2
700a9186: d020         	beq	0x700a91ca <CSL_bcdmaChanOpSetChanEnable+0x6a> @ imm = #0x40
700a9188: e02f         	b	0x700a91ea <CSL_bcdmaChanOpSetChanEnable+0x8a> @ imm = #0x5e
;             CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_BCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a918a: 9805         	ldr	r0, [sp, #0x14]
700a918c: 6880         	ldr	r0, [r0, #0x8]
700a918e: 9903         	ldr	r1, [sp, #0xc]
700a9190: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a9194: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a9198: f001 0101    	and	r1, r1, #0x1
700a919c: 2900         	cmp	r1, #0x0
700a919e: bf18         	it	ne
700a91a0: f04f 4100    	movne.w	r1, #0x80000000
700a91a4: f7f2 ffb4    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0xd098
;             break;
700a91a8: e023         	b	0x700a91f2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x46
;             CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a91aa: 9805         	ldr	r0, [sp, #0x14]
700a91ac: 6900         	ldr	r0, [r0, #0x10]
700a91ae: 9903         	ldr	r1, [sp, #0xc]
700a91b0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a91b4: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a91b8: f001 0101    	and	r1, r1, #0x1
700a91bc: 2900         	cmp	r1, #0x0
700a91be: bf18         	it	ne
700a91c0: f04f 4100    	movne.w	r1, #0x80000000
700a91c4: f7f2 ffa4    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0xd0b8
;             break;
700a91c8: e013         	b	0x700a91f2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x26
;             CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_RXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a91ca: 9805         	ldr	r0, [sp, #0x14]
700a91cc: 6980         	ldr	r0, [r0, #0x18]
700a91ce: 9903         	ldr	r1, [sp, #0xc]
700a91d0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a91d4: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a91d8: f001 0101    	and	r1, r1, #0x1
700a91dc: 2900         	cmp	r1, #0x0
700a91de: bf18         	it	ne
700a91e0: f04f 4100    	movne.w	r1, #0x80000000
700a91e4: f7f2 ff94    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0xd0d8
;             break;
700a91e8: e003         	b	0x700a91f2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x6
700a91ea: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700a91ee: 9001         	str	r0, [sp, #0x4]
;             break;
700a91f0: e7ff         	b	0x700a91f2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #-0x2
;     return retVal;
700a91f2: 9801         	ldr	r0, [sp, #0x4]
700a91f4: b006         	add	sp, #0x18
700a91f6: bd80         	pop	{r7, pc}
		...

700a9200 <Sciclient_pmModuleGetClkStatus>:
; {
700a9200: b580         	push	{r7, lr}
700a9202: b096         	sub	sp, #0x58
700a9204: 9015         	str	r0, [sp, #0x54]
700a9206: 9114         	str	r1, [sp, #0x50]
700a9208: 9213         	str	r2, [sp, #0x4c]
700a920a: 9312         	str	r3, [sp, #0x48]
700a920c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a920e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a9210: 9815         	ldr	r0, [sp, #0x54]
700a9212: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a9214: 9814         	ldr	r0, [sp, #0x50]
700a9216: 28ff         	cmp	r0, #0xff
700a9218: d307         	blo	0x700a922a <Sciclient_pmModuleGetClkStatus+0x2a> @ imm = #0xe
700a921a: e7ff         	b	0x700a921c <Sciclient_pmModuleGetClkStatus+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a921c: 9814         	ldr	r0, [sp, #0x50]
700a921e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a9222: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a9224: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a9228: e003         	b	0x700a9232 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a922a: 9814         	ldr	r0, [sp, #0x50]
700a922c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a9230: e7ff         	b	0x700a9232 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #-0x2
700a9232: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_resp response = {{0}};
700a9234: f8ad 002c    	strh.w	r0, [sp, #0x2c]
700a9238: 900a         	str	r0, [sp, #0x28]
700a923a: 9009         	str	r0, [sp, #0x24]
700a923c: f240 1101    	movw	r1, #0x101
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK;
700a9240: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a9244: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a9246: 9105         	str	r1, [sp, #0x14]
700a9248: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a924a: 9106         	str	r1, [sp, #0x18]
700a924c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a924e: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a9250: 9912         	ldr	r1, [sp, #0x48]
700a9252: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9254: 9001         	str	r0, [sp, #0x4]
700a9256: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a9258: 9002         	str	r0, [sp, #0x8]
700a925a: 200a         	movs	r0, #0xa
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a925c: 9003         	str	r0, [sp, #0xc]
700a925e: a804         	add	r0, sp, #0x10
700a9260: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9262: f7f3 ff8d    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xc0e6
700a9266: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a9268: 9811         	ldr	r0, [sp, #0x44]
700a926a: b930         	cbnz	r0, 0x700a927a <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #0xc
700a926c: e7ff         	b	0x700a926e <Sciclient_pmModuleGetClkStatus+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a926e: 9801         	ldr	r0, [sp, #0x4]
700a9270: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9274: 2802         	cmp	r0, #0x2
700a9276: d004         	beq	0x700a9282 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #0x8
700a9278: e7ff         	b	0x700a927a <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #-0x2
700a927a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a927e: 9011         	str	r0, [sp, #0x44]
;     }
700a9280: e7ff         	b	0x700a9282 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a9282: 9811         	ldr	r0, [sp, #0x44]
700a9284: b928         	cbnz	r0, 0x700a9292 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #0xa
700a9286: e7ff         	b	0x700a9288 <Sciclient_pmModuleGetClkStatus+0x88> @ imm = #-0x2
;         *state = (uint32_t) response.current_state;
700a9288: f89d 002d    	ldrb.w	r0, [sp, #0x2d]
700a928c: 9913         	ldr	r1, [sp, #0x4c]
700a928e: 6008         	str	r0, [r1]
;     }
700a9290: e7ff         	b	0x700a9292 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #-0x2
;     return retVal;
700a9292: 9811         	ldr	r0, [sp, #0x44]
700a9294: b016         	add	sp, #0x58
700a9296: bd80         	pop	{r7, pc}
		...

700a92a0 <xQueueReceiveFromISR>:
; {
700a92a0: b580         	push	{r7, lr}
700a92a2: b088         	sub	sp, #0x20
700a92a4: 9007         	str	r0, [sp, #0x1c]
700a92a6: 9106         	str	r1, [sp, #0x18]
700a92a8: 9205         	str	r2, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a92aa: 9807         	ldr	r0, [sp, #0x1c]
700a92ac: 9002         	str	r0, [sp, #0x8]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a92ae: f007 eb38    	blx	0x700b0920 <HwiP_disable> @ imm = #0x7670
700a92b2: 9003         	str	r0, [sp, #0xc]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a92b4: 9802         	ldr	r0, [sp, #0x8]
700a92b6: 6b80         	ldr	r0, [r0, #0x38]
700a92b8: 9001         	str	r0, [sp, #0x4]
;         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a92ba: 9801         	ldr	r0, [sp, #0x4]
700a92bc: b398         	cbz	r0, 0x700a9326 <xQueueReceiveFromISR+0x86> @ imm = #0x66
700a92be: e7ff         	b	0x700a92c0 <xQueueReceiveFromISR+0x20> @ imm = #-0x2
;             const int8_t cRxLock = pxQueue->cRxLock;
700a92c0: 9802         	ldr	r0, [sp, #0x8]
700a92c2: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a92c6: f88d 0003    	strb.w	r0, [sp, #0x3]
;             prvCopyDataFromQueue( pxQueue, pvBuffer );
700a92ca: 9802         	ldr	r0, [sp, #0x8]
700a92cc: 9906         	ldr	r1, [sp, #0x18]
700a92ce: f004 fbd7    	bl	0x700ada80 <prvCopyDataFromQueue> @ imm = #0x47ae
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a92d2: 9801         	ldr	r0, [sp, #0x4]
700a92d4: 3801         	subs	r0, #0x1
700a92d6: 9902         	ldr	r1, [sp, #0x8]
700a92d8: 6388         	str	r0, [r1, #0x38]
;             if( cRxLock == queueUNLOCKED )
700a92da: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a92de: 3001         	adds	r0, #0x1
700a92e0: b9b8         	cbnz	r0, 0x700a9312 <xQueueReceiveFromISR+0x72> @ imm = #0x2e
700a92e2: e7ff         	b	0x700a92e4 <xQueueReceiveFromISR+0x44> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a92e4: 9802         	ldr	r0, [sp, #0x8]
700a92e6: 6900         	ldr	r0, [r0, #0x10]
700a92e8: b188         	cbz	r0, 0x700a930e <xQueueReceiveFromISR+0x6e> @ imm = #0x22
700a92ea: e7ff         	b	0x700a92ec <xQueueReceiveFromISR+0x4c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a92ec: 9802         	ldr	r0, [sp, #0x8]
700a92ee: 3010         	adds	r0, #0x10
700a92f0: f7fe fb2e    	bl	0x700a7950 <xTaskRemoveFromEventList> @ imm = #-0x19a4
700a92f4: b148         	cbz	r0, 0x700a930a <xQueueReceiveFromISR+0x6a> @ imm = #0x12
700a92f6: e7ff         	b	0x700a92f8 <xQueueReceiveFromISR+0x58> @ imm = #-0x2
;                         if( pxHigherPriorityTaskWoken != NULL )
700a92f8: 9805         	ldr	r0, [sp, #0x14]
700a92fa: b120         	cbz	r0, 0x700a9306 <xQueueReceiveFromISR+0x66> @ imm = #0x8
700a92fc: e7ff         	b	0x700a92fe <xQueueReceiveFromISR+0x5e> @ imm = #-0x2
;                             *pxHigherPriorityTaskWoken = pdTRUE;
700a92fe: 9905         	ldr	r1, [sp, #0x14]
700a9300: 2001         	movs	r0, #0x1
700a9302: 6008         	str	r0, [r1]
;                         }
700a9304: e000         	b	0x700a9308 <xQueueReceiveFromISR+0x68> @ imm = #0x0
700a9306: e7ff         	b	0x700a9308 <xQueueReceiveFromISR+0x68> @ imm = #-0x2
;                     }
700a9308: e000         	b	0x700a930c <xQueueReceiveFromISR+0x6c> @ imm = #0x0
700a930a: e7ff         	b	0x700a930c <xQueueReceiveFromISR+0x6c> @ imm = #-0x2
;                 }
700a930c: e000         	b	0x700a9310 <xQueueReceiveFromISR+0x70> @ imm = #0x0
700a930e: e7ff         	b	0x700a9310 <xQueueReceiveFromISR+0x70> @ imm = #-0x2
;             }
700a9310: e006         	b	0x700a9320 <xQueueReceiveFromISR+0x80> @ imm = #0xc
;                 pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
700a9312: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9316: 3001         	adds	r0, #0x1
700a9318: 9902         	ldr	r1, [sp, #0x8]
700a931a: f881 0044    	strb.w	r0, [r1, #0x44]
700a931e: e7ff         	b	0x700a9320 <xQueueReceiveFromISR+0x80> @ imm = #-0x2
700a9320: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a9322: 9004         	str	r0, [sp, #0x10]
;         }
700a9324: e002         	b	0x700a932c <xQueueReceiveFromISR+0x8c> @ imm = #0x4
700a9326: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700a9328: 9004         	str	r0, [sp, #0x10]
700a932a: e7ff         	b	0x700a932c <xQueueReceiveFromISR+0x8c> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a932c: 9803         	ldr	r0, [sp, #0xc]
700a932e: f007 eb18    	blx	0x700b0960 <HwiP_restore> @ imm = #0x7630
;     return xReturn;
700a9332: 9804         	ldr	r0, [sp, #0x10]
700a9334: b008         	add	sp, #0x20
700a9336: bd80         	pop	{r7, pc}
		...

700a9340 <xTaskCreate>:
;     UBaseType_t uxPriority, TaskHandle_t *const pxCreatedTask) {
700a9340: b570         	push	{r4, r5, r6, lr}
700a9342: b08c         	sub	sp, #0x30
700a9344: f8dd c044    	ldr.w	r12, [sp, #0x44]
700a9348: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a934c: 900b         	str	r0, [sp, #0x2c]
700a934e: 910a         	str	r1, [sp, #0x28]
700a9350: 9209         	str	r2, [sp, #0x24]
700a9352: 9308         	str	r3, [sp, #0x20]
;         (((size_t)usStackDepth) *
700a9354: 9809         	ldr	r0, [sp, #0x24]
700a9356: 0080         	lsls	r0, r0, #0x2
;     pxStack = (StackType_t *)pvPortMalloc(
700a9358: f006 f8f2    	bl	0x700af540 <pvPortMalloc> @ imm = #0x61e4
700a935c: 9005         	str	r0, [sp, #0x14]
;     if (pxStack != NULL) {
700a935e: 9805         	ldr	r0, [sp, #0x14]
700a9360: b180         	cbz	r0, 0x700a9384 <xTaskCreate+0x44> @ imm = #0x20
700a9362: e7ff         	b	0x700a9364 <xTaskCreate+0x24> @ imm = #-0x2
700a9364: 2088         	movs	r0, #0x88
;       pxNewTCB = (TCB_t *)pvPortMalloc(
700a9366: f006 f8eb    	bl	0x700af540 <pvPortMalloc> @ imm = #0x61d6
700a936a: 9007         	str	r0, [sp, #0x1c]
;       if (pxNewTCB != NULL) {
700a936c: 9807         	ldr	r0, [sp, #0x1c]
700a936e: b120         	cbz	r0, 0x700a937a <xTaskCreate+0x3a> @ imm = #0x8
700a9370: e7ff         	b	0x700a9372 <xTaskCreate+0x32> @ imm = #-0x2
;         pxNewTCB->pxStack = pxStack;
700a9372: 9805         	ldr	r0, [sp, #0x14]
700a9374: 9907         	ldr	r1, [sp, #0x1c]
700a9376: 6308         	str	r0, [r1, #0x30]
;       } else {
700a9378: e003         	b	0x700a9382 <xTaskCreate+0x42> @ imm = #0x6
;         vPortFree(pxStack);
700a937a: 9805         	ldr	r0, [sp, #0x14]
700a937c: f005 ffe0    	bl	0x700af340 <vPortFree>  @ imm = #0x5fc0
700a9380: e7ff         	b	0x700a9382 <xTaskCreate+0x42> @ imm = #-0x2
;     } else {
700a9382: e002         	b	0x700a938a <xTaskCreate+0x4a> @ imm = #0x4
700a9384: 2000         	movs	r0, #0x0
;       pxNewTCB = NULL;
700a9386: 9007         	str	r0, [sp, #0x1c]
700a9388: e7ff         	b	0x700a938a <xTaskCreate+0x4a> @ imm = #-0x2
;   if (pxNewTCB != NULL) {
700a938a: 9807         	ldr	r0, [sp, #0x1c]
700a938c: b1e8         	cbz	r0, 0x700a93ca <xTaskCreate+0x8a> @ imm = #0x3a
700a938e: e7ff         	b	0x700a9390 <xTaskCreate+0x50> @ imm = #-0x2
;       pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
700a9390: 9807         	ldr	r0, [sp, #0x1c]
700a9392: 2600         	movs	r6, #0x0
700a9394: f880 6081    	strb.w	r6, [r0, #0x81]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a9398: 980b         	ldr	r0, [sp, #0x2c]
700a939a: 990a         	ldr	r1, [sp, #0x28]
700a939c: 9a09         	ldr	r2, [sp, #0x24]
;                          pvParameters, uxPriority, pxCreatedTask, pxNewTCB,
700a939e: 9b08         	ldr	r3, [sp, #0x20]
700a93a0: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a93a4: 9c11         	ldr	r4, [sp, #0x44]
700a93a6: 9d07         	ldr	r5, [sp, #0x1c]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a93a8: 46ee         	mov	lr, sp
700a93aa: f8ce 600c    	str.w	r6, [lr, #0xc]
700a93ae: f8ce 5008    	str.w	r5, [lr, #0x8]
700a93b2: f8ce 4004    	str.w	r4, [lr, #0x4]
700a93b6: f8ce c000    	str.w	r12, [lr]
700a93ba: f7fb fc19    	bl	0x700a4bf0 <prvInitialiseNewTask> @ imm = #-0x47ce
;     prvAddNewTaskToReadyList(pxNewTCB);
700a93be: 9807         	ldr	r0, [sp, #0x1c]
700a93c0: f7fb fdb6    	bl	0x700a4f30 <prvAddNewTaskToReadyList> @ imm = #-0x4494
700a93c4: 2001         	movs	r0, #0x1
;     xReturn = pdPASS;
700a93c6: 9006         	str	r0, [sp, #0x18]
;   } else {
700a93c8: e003         	b	0x700a93d2 <xTaskCreate+0x92> @ imm = #0x6
700a93ca: f04f 30ff    	mov.w	r0, #0xffffffff
;     xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
700a93ce: 9006         	str	r0, [sp, #0x18]
700a93d0: e7ff         	b	0x700a93d2 <xTaskCreate+0x92> @ imm = #-0x2
;   return xReturn;
700a93d2: 9806         	ldr	r0, [sp, #0x18]
700a93d4: b00c         	add	sp, #0x30
700a93d6: bd70         	pop	{r4, r5, r6, pc}
		...

700a93e0 <PMU_profileStart>:
; int32_t PMU_profileStart(const char *name) {
700a93e0: b580         	push	{r7, lr}
700a93e2: b088         	sub	sp, #0x20
700a93e4: 9006         	str	r0, [sp, #0x18]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a93e6: f243 0080    	movw	r0, #0x3080
700a93ea: f2c7 0008    	movt	r0, #0x7008
700a93ee: 6800         	ldr	r0, [r0]
700a93f0: 2840         	cmp	r0, #0x40
700a93f2: d304         	blo	0x700a93fe <PMU_profileStart+0x1e> @ imm = #0x8
700a93f4: e7ff         	b	0x700a93f6 <PMU_profileStart+0x16> @ imm = #-0x2
700a93f6: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a93fa: 9007         	str	r0, [sp, #0x1c]
700a93fc: e038         	b	0x700a9470 <PMU_profileStart+0x90> @ imm = #0x70
;   uint32_t i = gProfileObject.logIndex;
700a93fe: f243 0280    	movw	r2, #0x3080
700a9402: f2c7 0208    	movt	r2, #0x7008
700a9406: 6810         	ldr	r0, [r2]
700a9408: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a940a: 6890         	ldr	r0, [r2, #0x8]
700a940c: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a940e: 6850         	ldr	r0, [r2, #0x4]
700a9410: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a9412: 9805         	ldr	r0, [sp, #0x14]
700a9414: 2134         	movs	r1, #0x34
700a9416: fb00 2001    	mla	r0, r0, r1, r2
700a941a: 300c         	adds	r0, #0xc
700a941c: 9001         	str	r0, [sp, #0x4]
;   p->name = name;
700a941e: 9806         	ldr	r0, [sp, #0x18]
700a9420: 9901         	ldr	r1, [sp, #0x4]
700a9422: 6308         	str	r0, [r1, #0x30]
;   PMU_resetCounters();
700a9424: f006 fbfc    	bl	0x700afc20 <PMU_resetCounters> @ imm = #0x67f8
;   if (bCCnt == TRUE) {
700a9428: 9802         	ldr	r0, [sp, #0x8]
700a942a: 2801         	cmp	r0, #0x1
700a942c: d106         	bne	0x700a943c <PMU_profileStart+0x5c> @ imm = #0xc
700a942e: e7ff         	b	0x700a9430 <PMU_profileStart+0x50> @ imm = #-0x2
700a9430: 201f         	movs	r0, #0x1f
;         CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a9432: f7f8 ee14    	blx	0x700a205c <CSL_armR5PmuReadCntr> @ imm = #-0x73d8
;     p->cycleCount.value =
700a9436: 9901         	ldr	r1, [sp, #0x4]
700a9438: 62c8         	str	r0, [r1, #0x2c]
;   }
700a943a: e7ff         	b	0x700a943c <PMU_profileStart+0x5c> @ imm = #-0x2
700a943c: 2000         	movs	r0, #0x0
;   for (j = 0; j < numEvents; j++) {
700a943e: 9004         	str	r0, [sp, #0x10]
700a9440: e7ff         	b	0x700a9442 <PMU_profileStart+0x62> @ imm = #-0x2
700a9442: 9804         	ldr	r0, [sp, #0x10]
700a9444: 9903         	ldr	r1, [sp, #0xc]
700a9446: 4288         	cmp	r0, r1
700a9448: d20f         	bhs	0x700a946a <PMU_profileStart+0x8a> @ imm = #0x1e
700a944a: e7ff         	b	0x700a944c <PMU_profileStart+0x6c> @ imm = #-0x2
;     p->events[j].value = CSL_armR5PmuReadCntr(j);
700a944c: 9804         	ldr	r0, [sp, #0x10]
700a944e: f7f8 ee06    	blx	0x700a205c <CSL_armR5PmuReadCntr> @ imm = #-0x73f4
700a9452: 9901         	ldr	r1, [sp, #0x4]
700a9454: 9a04         	ldr	r2, [sp, #0x10]
700a9456: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a945a: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a945e: 6088         	str	r0, [r1, #0x8]
;   }
700a9460: e7ff         	b	0x700a9462 <PMU_profileStart+0x82> @ imm = #-0x2
;   for (j = 0; j < numEvents; j++) {
700a9462: 9804         	ldr	r0, [sp, #0x10]
700a9464: 3001         	adds	r0, #0x1
700a9466: 9004         	str	r0, [sp, #0x10]
700a9468: e7eb         	b	0x700a9442 <PMU_profileStart+0x62> @ imm = #-0x2a
700a946a: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
700a946c: 9007         	str	r0, [sp, #0x1c]
700a946e: e7ff         	b	0x700a9470 <PMU_profileStart+0x90> @ imm = #-0x2
; }
700a9470: 9807         	ldr	r0, [sp, #0x1c]
700a9472: b008         	add	sp, #0x20
700a9474: bd80         	pop	{r7, pc}
		...
700a947e: 0000         	movs	r0, r0

700a9480 <Sciclient_init>:
; {
700a9480: b580         	push	{r7, lr}
700a9482: b086         	sub	sp, #0x18
700a9484: 9005         	str	r0, [sp, #0x14]
700a9486: 2100         	movs	r1, #0x0
;     int32_t   status = SystemP_SUCCESS;
700a9488: 9101         	str	r1, [sp, #0x4]
700a948a: 9104         	str	r1, [sp, #0x10]
;         = (CSL_sec_proxyRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRegs);
700a948c: f642 00c0    	movw	r0, #0x28c0
700a9490: f2c7 000b    	movt	r0, #0x700b
700a9494: 9002         	str	r0, [sp, #0x8]
700a9496: 6800         	ldr	r0, [r0]
700a9498: f7fc fae2    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a3c
700a949c: 9901         	ldr	r1, [sp, #0x4]
700a949e: 4602         	mov	r2, r0
700a94a0: 9802         	ldr	r0, [sp, #0x8]
700a94a2: 6002         	str	r2, [r0]
;         = (CSL_sec_proxy_scfgRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyScfgRegs);
700a94a4: 6840         	ldr	r0, [r0, #0x4]
700a94a6: f7fc fadb    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a4a
700a94aa: 9901         	ldr	r1, [sp, #0x4]
700a94ac: 4602         	mov	r2, r0
700a94ae: 9802         	ldr	r0, [sp, #0x8]
700a94b0: 6042         	str	r2, [r0, #0x4]
;         = (CSL_sec_proxy_rtRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRtRegs);
700a94b2: 6880         	ldr	r0, [r0, #0x8]
700a94b4: f7fc fad4    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a58
700a94b8: 9902         	ldr	r1, [sp, #0x8]
700a94ba: 6088         	str	r0, [r1, #0x8]
;         = (uint64_t)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.proxyTargetAddr);
700a94bc: 6908         	ldr	r0, [r1, #0x10]
700a94be: 6949         	ldr	r1, [r1, #0x14]
700a94c0: f7fc face    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a64
700a94c4: 9a02         	ldr	r2, [sp, #0x8]
700a94c6: 4601         	mov	r1, r0
700a94c8: 9801         	ldr	r0, [sp, #0x4]
700a94ca: 6150         	str	r0, [r2, #0x14]
700a94cc: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.currSeqId = 0;
700a94ce: f642 1148    	movw	r1, #0x2948
700a94d2: f2c7 010b    	movt	r1, #0x700b
700a94d6: 9103         	str	r1, [sp, #0xc]
700a94d8: 6008         	str	r0, [r1]
;     gSciclientHandle.coreId = coreId;
700a94da: 9805         	ldr	r0, [sp, #0x14]
700a94dc: 6048         	str	r0, [r1, #0x4]
;     gSciclientHandle.devIdCore = Sciclient_getDevId(coreId);
700a94de: 9805         	ldr	r0, [sp, #0x14]
700a94e0: f003 ff66    	bl	0x700ad3b0 <Sciclient_getDevId> @ imm = #0x3ecc
700a94e4: 9a03         	ldr	r2, [sp, #0xc]
700a94e6: 4601         	mov	r1, r0
700a94e8: 9801         	ldr	r0, [sp, #0x4]
700a94ea: 6091         	str	r1, [r2, #0x8]
;     gSciclientHandle.secureContextId = Sciclient_getContext(SCICLIENT_SECURE_CONTEXT, coreId);
700a94ec: 9905         	ldr	r1, [sp, #0x14]
700a94ee: f7ff fb17    	bl	0x700a8b20 <Sciclient_getContext> @ imm = #-0x9d2
700a94f2: 9903         	ldr	r1, [sp, #0xc]
700a94f4: 60c8         	str	r0, [r1, #0xc]
;     gSciclientHandle.nonSecureContextId = Sciclient_getContext(SCICLIENT_NON_SECURE_CONTEXT, coreId);
700a94f6: 9905         	ldr	r1, [sp, #0x14]
700a94f8: 2001         	movs	r0, #0x1
700a94fa: f7ff fb11    	bl	0x700a8b20 <Sciclient_getContext> @ imm = #-0x9de
700a94fe: 9a03         	ldr	r2, [sp, #0xc]
700a9500: 4601         	mov	r1, r0
700a9502: 9802         	ldr	r0, [sp, #0x8]
700a9504: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
700a9506: f005 f993    	bl	0x700ae830 <CSL_secProxyGetMaxMsgSize> @ imm = #0x5326
700a950a: 9903         	ldr	r1, [sp, #0xc]
700a950c: 3804         	subs	r0, #0x4
700a950e: 6148         	str	r0, [r1, #0x14]
;     return status;
700a9510: 9804         	ldr	r0, [sp, #0x10]
700a9512: b006         	add	sp, #0x18
700a9514: bd80         	pop	{r7, pc}
		...
700a951e: 0000         	movs	r0, r0

700a9520 <UART_subConfigTCRTLRModeEn>:
; {
700a9520: b580         	push	{r7, lr}
700a9522: b088         	sub	sp, #0x20
700a9524: 9007         	str	r0, [sp, #0x1c]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a9526: 9807         	ldr	r0, [sp, #0x1c]
700a9528: 21bf         	movs	r1, #0xbf
700a952a: 9101         	str	r1, [sp, #0x4]
700a952c: f003 f888    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x3110
700a9530: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a9532: 9807         	ldr	r0, [sp, #0x1c]
700a9534: 3008         	adds	r0, #0x8
700a9536: 2110         	movs	r1, #0x10
700a9538: 9102         	str	r1, [sp, #0x8]
700a953a: 2204         	movs	r2, #0x4
700a953c: 9203         	str	r2, [sp, #0xc]
700a953e: f005 febf    	bl	0x700af2c0 <HW_RD_FIELD32_RAW> @ imm = #0x5d7e
700a9542: 9902         	ldr	r1, [sp, #0x8]
700a9544: 9a03         	ldr	r2, [sp, #0xc]
700a9546: 9006         	str	r0, [sp, #0x18]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a9548: 9807         	ldr	r0, [sp, #0x1c]
700a954a: 3008         	adds	r0, #0x8
700a954c: 2301         	movs	r3, #0x1
700a954e: 9300         	str	r3, [sp]
700a9550: f005 f856    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x50ac
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9554: 9807         	ldr	r0, [sp, #0x1c]
700a9556: 300c         	adds	r0, #0xc
700a9558: 9904         	ldr	r1, [sp, #0x10]
700a955a: f006 faf1    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x65e2
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a955e: 9807         	ldr	r0, [sp, #0x1c]
700a9560: 2180         	movs	r1, #0x80
700a9562: f003 f86d    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x30da
700a9566: 9004         	str	r0, [sp, #0x10]
;     tcrTlrValue = HW_RD_REG32(baseAddr + UART_MCR) & UART_MCR_TCR_TLR_MASK;
700a9568: 9807         	ldr	r0, [sp, #0x1c]
700a956a: 3010         	adds	r0, #0x10
700a956c: f006 fae0    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x65c0
700a9570: 9b00         	ldr	r3, [sp]
700a9572: f000 0040    	and	r0, r0, #0x40
700a9576: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR,
700a9578: 9807         	ldr	r0, [sp, #0x1c]
700a957a: 3010         	adds	r0, #0x10
700a957c: 2140         	movs	r1, #0x40
700a957e: 2206         	movs	r2, #0x6
700a9580: f005 f83e    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x507c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9584: 9807         	ldr	r0, [sp, #0x1c]
700a9586: 300c         	adds	r0, #0xc
700a9588: 9904         	ldr	r1, [sp, #0x10]
700a958a: f006 fad9    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x65b2
700a958e: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a9590: 9807         	ldr	r0, [sp, #0x1c]
700a9592: f003 f855    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x30aa
700a9596: 9902         	ldr	r1, [sp, #0x8]
700a9598: 9a03         	ldr	r2, [sp, #0xc]
700a959a: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a959c: 9807         	ldr	r0, [sp, #0x1c]
700a959e: 3008         	adds	r0, #0x8
700a95a0: 9b06         	ldr	r3, [sp, #0x18]
700a95a2: f005 f82d    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x505a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a95a6: 9807         	ldr	r0, [sp, #0x1c]
700a95a8: 300c         	adds	r0, #0xc
700a95aa: 9904         	ldr	r1, [sp, #0x10]
700a95ac: f006 fac8    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x6590
;     return tcrTlrValue;
700a95b0: 9805         	ldr	r0, [sp, #0x14]
700a95b2: b008         	add	sp, #0x20
700a95b4: bd80         	pop	{r7, pc}
		...
700a95be: 0000         	movs	r0, r0

700a95c0 <UART_udmaIsrRx>:
; {
700a95c0: b580         	push	{r7, lr}
700a95c2: b08a         	sub	sp, #0x28
700a95c4: 9009         	str	r0, [sp, #0x24]
700a95c6: 9108         	str	r1, [sp, #0x20]
700a95c8: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a95ca: 9807         	ldr	r0, [sp, #0x1c]
700a95cc: 2800         	cmp	r0, #0x0
700a95ce: d040         	beq	0x700a9652 <UART_udmaIsrRx+0x92> @ imm = #0x80
700a95d0: e7ff         	b	0x700a95d2 <UART_udmaIsrRx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a95d2: 9807         	ldr	r0, [sp, #0x1c]
700a95d4: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a95d6: 9800         	ldr	r0, [sp]
700a95d8: 6840         	ldr	r0, [r0, #0x4]
700a95da: 6cc0         	ldr	r0, [r0, #0x4c]
700a95dc: 9001         	str	r0, [sp, #0x4]
;         rxChHandle  = udmaChCfg->rxChHandle;
700a95de: 9801         	ldr	r0, [sp, #0x4]
700a95e0: 6880         	ldr	r0, [r0, #0x8]
700a95e2: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a95e4: 9808         	ldr	r0, [sp, #0x20]
700a95e6: 2801         	cmp	r0, #0x1
700a95e8: d12e         	bne	0x700a9648 <UART_udmaIsrRx+0x88> @ imm = #0x5c
700a95ea: e7ff         	b	0x700a95ec <UART_udmaIsrRx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->rxHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a95ec: 9901         	ldr	r1, [sp, #0x4]
700a95ee: 6988         	ldr	r0, [r1, #0x18]
700a95f0: 69c9         	ldr	r1, [r1, #0x1c]
700a95f2: 220a         	movs	r2, #0xa
700a95f4: f007 fc24    	bl	0x700b0e40 <CacheP_inv> @ imm = #0x7848
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a95f8: 9802         	ldr	r0, [sp, #0x8]
700a95fa: f001 fc29    	bl	0x700aae50 <Udma_chGetCqRingHandle> @ imm = #0x1852
700a95fe: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a9600: f000 f8ce    	bl	0x700a97a0 <Udma_ringDequeueRaw> @ imm = #0x19c
700a9604: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a9606: 9806         	ldr	r0, [sp, #0x18]
700a9608: b988         	cbnz	r0, 0x700a962e <UART_udmaIsrRx+0x6e> @ imm = #0x22
700a960a: e7ff         	b	0x700a960c <UART_udmaIsrRx+0x4c> @ imm = #-0x2
700a960c: 9804         	ldr	r0, [sp, #0x10]
700a960e: 9905         	ldr	r1, [sp, #0x14]
700a9610: 4308         	orrs	r0, r1
700a9612: b160         	cbz	r0, 0x700a962e <UART_udmaIsrRx+0x6e> @ imm = #0x18
700a9614: e7ff         	b	0x700a9616 <UART_udmaIsrRx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a9616: 9804         	ldr	r0, [sp, #0x10]
700a9618: 9003         	str	r0, [sp, #0xc]
;                 hUart->readTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a961a: 9803         	ldr	r0, [sp, #0xc]
700a961c: 6800         	ldr	r0, [r0]
700a961e: f36f 509f    	bfc	r0, #22, #10
700a9622: 9900         	ldr	r1, [sp]
700a9624: 62c8         	str	r0, [r1, #0x2c]
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a9626: 9900         	ldr	r1, [sp]
700a9628: 2000         	movs	r0, #0x0
700a962a: 6348         	str	r0, [r1, #0x34]
;             }
700a962c: e003         	b	0x700a9636 <UART_udmaIsrRx+0x76> @ imm = #0x6
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a962e: 9900         	ldr	r1, [sp]
700a9630: 200a         	movs	r0, #0xa
700a9632: 6348         	str	r0, [r1, #0x34]
700a9634: e7ff         	b	0x700a9636 <UART_udmaIsrRx+0x76> @ imm = #-0x2
;             hUart->hUartInit->readCompleteCallbackFxn(hUart);
700a9636: 9800         	ldr	r0, [sp]
700a9638: 6841         	ldr	r1, [r0, #0x4]
700a963a: 6dc9         	ldr	r1, [r1, #0x5c]
700a963c: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a963e: 9800         	ldr	r0, [sp]
700a9640: 3028         	adds	r0, #0x28
700a9642: f005 feed    	bl	0x700af420 <UART_lld_Transaction_deInit> @ imm = #0x5dda
;         }
700a9646: e003         	b	0x700a9650 <UART_udmaIsrRx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a9648: 9900         	ldr	r1, [sp]
700a964a: 200a         	movs	r0, #0xa
700a964c: 6488         	str	r0, [r1, #0x48]
700a964e: e7ff         	b	0x700a9650 <UART_udmaIsrRx+0x90> @ imm = #-0x2
;     }
700a9650: e7ff         	b	0x700a9652 <UART_udmaIsrRx+0x92> @ imm = #-0x2
;     return;
700a9652: b00a         	add	sp, #0x28
700a9654: bd80         	pop	{r7, pc}
		...
700a965e: 0000         	movs	r0, r0

700a9660 <UART_udmaIsrTx>:
; {
700a9660: b580         	push	{r7, lr}
700a9662: b08a         	sub	sp, #0x28
700a9664: 9009         	str	r0, [sp, #0x24]
700a9666: 9108         	str	r1, [sp, #0x20]
700a9668: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a966a: 9807         	ldr	r0, [sp, #0x1c]
700a966c: 2800         	cmp	r0, #0x0
700a966e: d040         	beq	0x700a96f2 <UART_udmaIsrTx+0x92> @ imm = #0x80
700a9670: e7ff         	b	0x700a9672 <UART_udmaIsrTx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a9672: 9807         	ldr	r0, [sp, #0x1c]
700a9674: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a9676: 9800         	ldr	r0, [sp]
700a9678: 6840         	ldr	r0, [r0, #0x4]
700a967a: 6cc0         	ldr	r0, [r0, #0x4c]
700a967c: 9001         	str	r0, [sp, #0x4]
;         txChHandle  = udmaChCfg->txChHandle;
700a967e: 9801         	ldr	r0, [sp, #0x4]
700a9680: 6840         	ldr	r0, [r0, #0x4]
700a9682: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a9684: 9808         	ldr	r0, [sp, #0x20]
700a9686: 2801         	cmp	r0, #0x1
700a9688: d12e         	bne	0x700a96e8 <UART_udmaIsrTx+0x88> @ imm = #0x5c
700a968a: e7ff         	b	0x700a968c <UART_udmaIsrTx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->txHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a968c: 9901         	ldr	r1, [sp, #0x4]
700a968e: 6948         	ldr	r0, [r1, #0x14]
700a9690: 69c9         	ldr	r1, [r1, #0x1c]
700a9692: 220a         	movs	r2, #0xa
700a9694: f007 fbd4    	bl	0x700b0e40 <CacheP_inv> @ imm = #0x77a8
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a9698: 9802         	ldr	r0, [sp, #0x8]
700a969a: f001 fbd9    	bl	0x700aae50 <Udma_chGetCqRingHandle> @ imm = #0x17b2
700a969e: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a96a0: f000 f87e    	bl	0x700a97a0 <Udma_ringDequeueRaw> @ imm = #0xfc
700a96a4: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a96a6: 9806         	ldr	r0, [sp, #0x18]
700a96a8: b988         	cbnz	r0, 0x700a96ce <UART_udmaIsrTx+0x6e> @ imm = #0x22
700a96aa: e7ff         	b	0x700a96ac <UART_udmaIsrTx+0x4c> @ imm = #-0x2
700a96ac: 9804         	ldr	r0, [sp, #0x10]
700a96ae: 9905         	ldr	r1, [sp, #0x14]
700a96b0: 4308         	orrs	r0, r1
700a96b2: b160         	cbz	r0, 0x700a96ce <UART_udmaIsrTx+0x6e> @ imm = #0x18
700a96b4: e7ff         	b	0x700a96b6 <UART_udmaIsrTx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a96b6: 9804         	ldr	r0, [sp, #0x10]
700a96b8: 9003         	str	r0, [sp, #0xc]
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a96ba: 9900         	ldr	r1, [sp]
700a96bc: 2000         	movs	r0, #0x0
700a96be: 6488         	str	r0, [r1, #0x48]
;                 hUart->writeTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a96c0: 9803         	ldr	r0, [sp, #0xc]
700a96c2: 6800         	ldr	r0, [r0]
700a96c4: f36f 509f    	bfc	r0, #22, #10
700a96c8: 9900         	ldr	r1, [sp]
700a96ca: 6408         	str	r0, [r1, #0x40]
;             }
700a96cc: e003         	b	0x700a96d6 <UART_udmaIsrTx+0x76> @ imm = #0x6
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a96ce: 9900         	ldr	r1, [sp]
700a96d0: 200a         	movs	r0, #0xa
700a96d2: 6488         	str	r0, [r1, #0x48]
700a96d4: e7ff         	b	0x700a96d6 <UART_udmaIsrTx+0x76> @ imm = #-0x2
;             hUart->hUartInit->writeCompleteCallbackFxn(hUart);
700a96d6: 9800         	ldr	r0, [sp]
700a96d8: 6841         	ldr	r1, [r0, #0x4]
700a96da: 6e09         	ldr	r1, [r1, #0x60]
700a96dc: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a96de: 9800         	ldr	r0, [sp]
700a96e0: 303c         	adds	r0, #0x3c
700a96e2: f005 fe9d    	bl	0x700af420 <UART_lld_Transaction_deInit> @ imm = #0x5d3a
;         }
700a96e6: e003         	b	0x700a96f0 <UART_udmaIsrTx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a96e8: 9900         	ldr	r1, [sp]
700a96ea: 200a         	movs	r0, #0xa
700a96ec: 6488         	str	r0, [r1, #0x48]
700a96ee: e7ff         	b	0x700a96f0 <UART_udmaIsrTx+0x90> @ imm = #-0x2
;     }
700a96f0: e7ff         	b	0x700a96f2 <UART_udmaIsrTx+0x92> @ imm = #-0x2
;     return;
700a96f2: b00a         	add	sp, #0x28
700a96f4: bd80         	pop	{r7, pc}
		...
700a96fe: 0000         	movs	r0, r0

700a9700 <UdmaFlowPrms_init>:
; {
700a9700: b084         	sub	sp, #0x10
700a9702: 9003         	str	r0, [sp, #0xc]
700a9704: 9102         	str	r1, [sp, #0x8]
;     if(NULL_PTR != flowPrms)
700a9706: 9803         	ldr	r0, [sp, #0xc]
700a9708: 2800         	cmp	r0, #0x0
700a970a: d042         	beq	0x700a9792 <UdmaFlowPrms_init+0x92> @ imm = #0x84
700a970c: e7ff         	b	0x700a970e <UdmaFlowPrms_init+0xe> @ imm = #-0x2
;         flowPrms->rxChHandle    = (Udma_ChHandle) NULL_PTR;
700a970e: 9803         	ldr	r0, [sp, #0xc]
700a9710: 2100         	movs	r1, #0x0
700a9712: 9100         	str	r1, [sp]
700a9714: 6001         	str	r1, [r0]
;         flowPrms->einfoPresent  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;
700a9716: 9803         	ldr	r0, [sp, #0xc]
700a9718: 7101         	strb	r1, [r0, #0x4]
;         flowPrms->psInfoPresent = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;
700a971a: 9803         	ldr	r0, [sp, #0xc]
700a971c: 7141         	strb	r1, [r0, #0x5]
;         flowPrms->errorHandling = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;
700a971e: 9a03         	ldr	r2, [sp, #0xc]
700a9720: 2001         	movs	r0, #0x1
700a9722: 7190         	strb	r0, [r2, #0x6]
;         flowPrms->descType      = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DESC_HOST;
700a9724: 9803         	ldr	r0, [sp, #0xc]
700a9726: 71c1         	strb	r1, [r0, #0x7]
;         flowPrms->psLocation    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PS_END_PD;
700a9728: 9803         	ldr	r0, [sp, #0xc]
700a972a: 7201         	strb	r1, [r0, #0x8]
;         flowPrms->sopOffset     = 0U;
700a972c: 9803         	ldr	r0, [sp, #0xc]
700a972e: 8141         	strh	r1, [r0, #0xa]
;         flowPrms->defaultRxCQ   = UDMA_RING_INVALID;
700a9730: 9a03         	ldr	r2, [sp, #0xc]
700a9732: f64f 70ff    	movw	r0, #0xffff
700a9736: 9001         	str	r0, [sp, #0x4]
700a9738: 8190         	strh	r0, [r2, #0xc]
;         flowPrms->srcTagLo      = 0U;
700a973a: 9a03         	ldr	r2, [sp, #0xc]
700a973c: 73d1         	strb	r1, [r2, #0xf]
;         flowPrms->srcTagLoSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_SRC_TAG;
700a973e: 9b03         	ldr	r3, [sp, #0xc]
700a9740: 2204         	movs	r2, #0x4
700a9742: 745a         	strb	r2, [r3, #0x11]
;         flowPrms->srcTagHi      = 0U;
700a9744: 9b03         	ldr	r3, [sp, #0xc]
700a9746: 7399         	strb	r1, [r3, #0xe]
;         flowPrms->srcTagHiSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_FLOW_ID;
700a9748: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700a974c: 2302         	movs	r3, #0x2
700a974e: f88c 3010    	strb.w	r3, [r12, #0x10]
;         flowPrms->destTagLo     = 0U;
700a9752: 9b03         	ldr	r3, [sp, #0xc]
700a9754: 74d9         	strb	r1, [r3, #0x13]
;         flowPrms->destTagLoSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_LO;
700a9756: 9b03         	ldr	r3, [sp, #0xc]
700a9758: 755a         	strb	r2, [r3, #0x15]
;         flowPrms->destTagHi     = 0U;
700a975a: 9a03         	ldr	r2, [sp, #0xc]
700a975c: 7491         	strb	r1, [r2, #0x12]
;         flowPrms->destTagHiSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_HI;
700a975e: 9b03         	ldr	r3, [sp, #0xc]
700a9760: 2205         	movs	r2, #0x5
700a9762: 751a         	strb	r2, [r3, #0x14]
;         flowPrms->sizeThreshEn  = 0U;
700a9764: 9a03         	ldr	r2, [sp, #0xc]
700a9766: 7591         	strb	r1, [r2, #0x16]
;         flowPrms->fdq0Sz0Qnum   = UDMA_RING_INVALID;
700a9768: 9a03         	ldr	r2, [sp, #0xc]
700a976a: 8310         	strh	r0, [r2, #0x18]
;         flowPrms->fdq1Qnum      = UDMA_RING_INVALID;
700a976c: 9a03         	ldr	r2, [sp, #0xc]
700a976e: 8350         	strh	r0, [r2, #0x1a]
;         flowPrms->fdq2Qnum      = UDMA_RING_INVALID;
700a9770: 9a03         	ldr	r2, [sp, #0xc]
700a9772: 8390         	strh	r0, [r2, #0x1c]
;         flowPrms->fdq3Qnum      = UDMA_RING_INVALID;
700a9774: 9a03         	ldr	r2, [sp, #0xc]
700a9776: 83d0         	strh	r0, [r2, #0x1e]
;         flowPrms->sizeThresh0   = 0U;
700a9778: 9a03         	ldr	r2, [sp, #0xc]
700a977a: 8411         	strh	r1, [r2, #0x20]
;         flowPrms->sizeThresh1   = 0U;
700a977c: 9a03         	ldr	r2, [sp, #0xc]
700a977e: 8451         	strh	r1, [r2, #0x22]
;         flowPrms->sizeThresh2   = 0U;
700a9780: 9a03         	ldr	r2, [sp, #0xc]
700a9782: 8491         	strh	r1, [r2, #0x24]
;         flowPrms->fdq0Sz1Qnum   = UDMA_RING_INVALID;
700a9784: 9903         	ldr	r1, [sp, #0xc]
700a9786: 84c8         	strh	r0, [r1, #0x26]
;         flowPrms->fdq0Sz2Qnum   = UDMA_RING_INVALID;
700a9788: 9903         	ldr	r1, [sp, #0xc]
700a978a: 8508         	strh	r0, [r1, #0x28]
;         flowPrms->fdq0Sz3Qnum   = UDMA_RING_INVALID;
700a978c: 9903         	ldr	r1, [sp, #0xc]
700a978e: 8548         	strh	r0, [r1, #0x2a]
;     }
700a9790: e7ff         	b	0x700a9792 <UdmaFlowPrms_init+0x92> @ imm = #-0x2
;     return;
700a9792: b004         	add	sp, #0x10
700a9794: 4770         	bx	lr
		...
700a979e: 0000         	movs	r0, r0

700a97a0 <Udma_ringDequeueRaw>:
; {
700a97a0: b580         	push	{r7, lr}
700a97a2: b086         	sub	sp, #0x18
700a97a4: 9005         	str	r0, [sp, #0x14]
700a97a6: 9104         	str	r1, [sp, #0x10]
700a97a8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a97aa: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a97ac: 9805         	ldr	r0, [sp, #0x14]
700a97ae: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a97b0: 9800         	ldr	r0, [sp]
700a97b2: b180         	cbz	r0, 0x700a97d6 <Udma_ringDequeueRaw+0x36> @ imm = #0x20
700a97b4: e7ff         	b	0x700a97b6 <Udma_ringDequeueRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a97b6: 9800         	ldr	r0, [sp]
700a97b8: 6d80         	ldr	r0, [r0, #0x58]
700a97ba: f64a 31cd    	movw	r1, #0xabcd
700a97be: f6ca 31dc    	movt	r1, #0xabdc
700a97c2: 4288         	cmp	r0, r1
700a97c4: d107         	bne	0x700a97d6 <Udma_ringDequeueRaw+0x36> @ imm = #0xe
700a97c6: e7ff         	b	0x700a97c8 <Udma_ringDequeueRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a97c8: 9800         	ldr	r0, [sp]
700a97ca: 8880         	ldrh	r0, [r0, #0x4]
700a97cc: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a97d0: 4288         	cmp	r0, r1
700a97d2: d104         	bne	0x700a97de <Udma_ringDequeueRaw+0x3e> @ imm = #0x8
700a97d4: e7ff         	b	0x700a97d6 <Udma_ringDequeueRaw+0x36> @ imm = #-0x2
700a97d6: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a97da: 9003         	str	r0, [sp, #0xc]
;     }
700a97dc: e7ff         	b	0x700a97de <Udma_ringDequeueRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a97de: 9803         	ldr	r0, [sp, #0xc]
700a97e0: b9a8         	cbnz	r0, 0x700a980e <Udma_ringDequeueRaw+0x6e> @ imm = #0x2a
700a97e2: e7ff         	b	0x700a97e4 <Udma_ringDequeueRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a97e4: 9800         	ldr	r0, [sp]
700a97e6: 6800         	ldr	r0, [r0]
700a97e8: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a97ea: 9801         	ldr	r0, [sp, #0x4]
700a97ec: b150         	cbz	r0, 0x700a9804 <Udma_ringDequeueRaw+0x64> @ imm = #0x14
700a97ee: e7ff         	b	0x700a97f0 <Udma_ringDequeueRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a97f0: 9801         	ldr	r0, [sp, #0x4]
700a97f2: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a97f6: f64a 31cd    	movw	r1, #0xabcd
700a97fa: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a97fe: 4288         	cmp	r0, r1
700a9800: d004         	beq	0x700a980c <Udma_ringDequeueRaw+0x6c> @ imm = #0x8
700a9802: e7ff         	b	0x700a9804 <Udma_ringDequeueRaw+0x64> @ imm = #-0x2
700a9804: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a9808: 9003         	str	r0, [sp, #0xc]
;         }
700a980a: e7ff         	b	0x700a980c <Udma_ringDequeueRaw+0x6c> @ imm = #-0x2
;     }
700a980c: e7ff         	b	0x700a980e <Udma_ringDequeueRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a980e: 9803         	ldr	r0, [sp, #0xc]
700a9810: b970         	cbnz	r0, 0x700a9830 <Udma_ringDequeueRaw+0x90> @ imm = #0x1c
700a9812: e7ff         	b	0x700a9814 <Udma_ringDequeueRaw+0x74> @ imm = #-0x2
;         cookie = HwiP_disable();
700a9814: f007 e884    	blx	0x700b0920 <HwiP_disable> @ imm = #0x7108
700a9818: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringDequeueRaw(drvHandle, ringHandleInt, phyDescMem);
700a981a: 9801         	ldr	r0, [sp, #0x4]
700a981c: f8d0 3590    	ldr.w	r3, [r0, #0x590]
700a9820: 9900         	ldr	r1, [sp]
700a9822: 9a04         	ldr	r2, [sp, #0x10]
700a9824: 4798         	blx	r3
700a9826: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a9828: 9802         	ldr	r0, [sp, #0x8]
700a982a: f007 e89a    	blx	0x700b0960 <HwiP_restore> @ imm = #0x7134
;     }
700a982e: e7ff         	b	0x700a9830 <Udma_ringDequeueRaw+0x90> @ imm = #-0x2
;     return (retVal);
700a9830: 9803         	ldr	r0, [sp, #0xc]
700a9832: b006         	add	sp, #0x18
700a9834: bd80         	pop	{r7, pc}
		...
700a983e: 0000         	movs	r0, r0

700a9840 <UART_lld_dmaDisableChannel>:
; {
700a9840: b580         	push	{r7, lr}
700a9842: b08a         	sub	sp, #0x28
700a9844: 9009         	str	r0, [sp, #0x24]
700a9846: 9108         	str	r1, [sp, #0x20]
700a9848: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a984a: 9007         	str	r0, [sp, #0x1c]
700a984c: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a984e: 9006         	str	r0, [sp, #0x18]
;     udmaChCfg   = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a9850: 9809         	ldr	r0, [sp, #0x24]
700a9852: 6840         	ldr	r0, [r0, #0x4]
700a9854: 6cc0         	ldr	r0, [r0, #0x4c]
700a9856: 9005         	str	r0, [sp, #0x14]
;     if (isChannelTx == TRUE)
700a9858: 9808         	ldr	r0, [sp, #0x20]
700a985a: 2801         	cmp	r0, #0x1
700a985c: d104         	bne	0x700a9868 <UART_lld_dmaDisableChannel+0x28> @ imm = #0x8
700a985e: e7ff         	b	0x700a9860 <UART_lld_dmaDisableChannel+0x20> @ imm = #-0x2
;         chHandle = udmaChCfg->txChHandle;
700a9860: 9805         	ldr	r0, [sp, #0x14]
700a9862: 6840         	ldr	r0, [r0, #0x4]
700a9864: 9004         	str	r0, [sp, #0x10]
;     }
700a9866: e003         	b	0x700a9870 <UART_lld_dmaDisableChannel+0x30> @ imm = #0x6
;         chHandle = udmaChCfg->rxChHandle;
700a9868: 9805         	ldr	r0, [sp, #0x14]
700a986a: 6880         	ldr	r0, [r0, #0x8]
700a986c: 9004         	str	r0, [sp, #0x10]
700a986e: e7ff         	b	0x700a9870 <UART_lld_dmaDisableChannel+0x30> @ imm = #-0x2
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a9870: 9804         	ldr	r0, [sp, #0x10]
700a9872: 2164         	movs	r1, #0x64
700a9874: f7fe fb94    	bl	0x700a7fa0 <Udma_chDisable> @ imm = #-0x18d8
700a9878: 9007         	str	r0, [sp, #0x1c]
;     DebugP_assert(UDMA_SOK == status);
700a987a: 9807         	ldr	r0, [sp, #0x1c]
700a987c: fab0 f080    	clz	r0, r0
700a9880: 0940         	lsrs	r0, r0, #0x5
700a9882: f641 71db    	movw	r1, #0x1fdb
700a9886: f2c7 010b    	movt	r1, #0x700b
700a988a: 466a         	mov	r2, sp
700a988c: 6011         	str	r1, [r2]
700a988e: f641 3191    	movw	r1, #0x1b91
700a9892: f2c7 010b    	movt	r1, #0x700b
700a9896: f641 626f    	movw	r2, #0x1e6f
700a989a: f2c7 020b    	movt	r2, #0x700b
700a989e: f240 137b    	movw	r3, #0x17b
700a98a2: f001 f915    	bl	0x700aaad0 <_DebugP_assert> @ imm = #0x122a
;     while(temp == TRUE)
700a98a6: e7ff         	b	0x700a98a8 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x2
700a98a8: 9806         	ldr	r0, [sp, #0x18]
700a98aa: 2801         	cmp	r0, #0x1
700a98ac: d10f         	bne	0x700a98ce <UART_lld_dmaDisableChannel+0x8e> @ imm = #0x1e
700a98ae: e7ff         	b	0x700a98b0 <UART_lld_dmaDisableChannel+0x70> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a98b0: 9804         	ldr	r0, [sp, #0x10]
700a98b2: f001 fb0d    	bl	0x700aaed0 <Udma_chGetFqRingHandle> @ imm = #0x161a
700a98b6: a902         	add	r1, sp, #0x8
;         tempRetVal = Udma_ringFlushRaw(
700a98b8: f000 fb9a    	bl	0x700a9ff0 <Udma_ringFlushRaw> @ imm = #0x734
700a98bc: 9001         	str	r0, [sp, #0x4]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a98be: 9801         	ldr	r0, [sp, #0x4]
700a98c0: 3004         	adds	r0, #0x4
700a98c2: b918         	cbnz	r0, 0x700a98cc <UART_lld_dmaDisableChannel+0x8c> @ imm = #0x6
700a98c4: e7ff         	b	0x700a98c6 <UART_lld_dmaDisableChannel+0x86> @ imm = #-0x2
700a98c6: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a98c8: 9006         	str	r0, [sp, #0x18]
;         }
700a98ca: e7ff         	b	0x700a98cc <UART_lld_dmaDisableChannel+0x8c> @ imm = #-0x2
;     while(temp == TRUE)
700a98cc: e7ec         	b	0x700a98a8 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x28
;     return status;
700a98ce: 9807         	ldr	r0, [sp, #0x1c]
700a98d0: b00a         	add	sp, #0x28
700a98d2: bd80         	pop	{r7, pc}
		...

700a98e0 <xQueueGiveFromISR>:
; {
700a98e0: b580         	push	{r7, lr}
700a98e2: b088         	sub	sp, #0x20
700a98e4: 9007         	str	r0, [sp, #0x1c]
700a98e6: 9106         	str	r1, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a98e8: 9807         	ldr	r0, [sp, #0x1c]
700a98ea: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a98ec: f007 e818    	blx	0x700b0920 <HwiP_disable> @ imm = #0x7030
700a98f0: 9004         	str	r0, [sp, #0x10]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a98f2: 9803         	ldr	r0, [sp, #0xc]
700a98f4: 6b80         	ldr	r0, [r0, #0x38]
700a98f6: 9002         	str	r0, [sp, #0x8]
;         if( uxMessagesWaiting < pxQueue->uxLength )
700a98f8: 9802         	ldr	r0, [sp, #0x8]
700a98fa: 9903         	ldr	r1, [sp, #0xc]
700a98fc: 6bc9         	ldr	r1, [r1, #0x3c]
700a98fe: 4288         	cmp	r0, r1
700a9900: d22f         	bhs	0x700a9962 <xQueueGiveFromISR+0x82> @ imm = #0x5e
700a9902: e7ff         	b	0x700a9904 <xQueueGiveFromISR+0x24> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a9904: 9803         	ldr	r0, [sp, #0xc]
700a9906: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a990a: f88d 0007    	strb.w	r0, [sp, #0x7]
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a990e: 9802         	ldr	r0, [sp, #0x8]
700a9910: 3001         	adds	r0, #0x1
700a9912: 9903         	ldr	r1, [sp, #0xc]
700a9914: 6388         	str	r0, [r1, #0x38]
;             if( cTxLock == queueUNLOCKED )
700a9916: f99d 0007    	ldrsb.w	r0, [sp, #0x7]
700a991a: 3001         	adds	r0, #0x1
700a991c: b9b8         	cbnz	r0, 0x700a994e <xQueueGiveFromISR+0x6e> @ imm = #0x2e
700a991e: e7ff         	b	0x700a9920 <xQueueGiveFromISR+0x40> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a9920: 9803         	ldr	r0, [sp, #0xc]
700a9922: 6a40         	ldr	r0, [r0, #0x24]
700a9924: b188         	cbz	r0, 0x700a994a <xQueueGiveFromISR+0x6a> @ imm = #0x22
700a9926: e7ff         	b	0x700a9928 <xQueueGiveFromISR+0x48> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a9928: 9803         	ldr	r0, [sp, #0xc]
700a992a: 3024         	adds	r0, #0x24
700a992c: f7fe f810    	bl	0x700a7950 <xTaskRemoveFromEventList> @ imm = #-0x1fe0
700a9930: b148         	cbz	r0, 0x700a9946 <xQueueGiveFromISR+0x66> @ imm = #0x12
700a9932: e7ff         	b	0x700a9934 <xQueueGiveFromISR+0x54> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a9934: 9806         	ldr	r0, [sp, #0x18]
700a9936: b120         	cbz	r0, 0x700a9942 <xQueueGiveFromISR+0x62> @ imm = #0x8
700a9938: e7ff         	b	0x700a993a <xQueueGiveFromISR+0x5a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a993a: 9906         	ldr	r1, [sp, #0x18]
700a993c: 2001         	movs	r0, #0x1
700a993e: 6008         	str	r0, [r1]
;                                 }
700a9940: e000         	b	0x700a9944 <xQueueGiveFromISR+0x64> @ imm = #0x0
700a9942: e7ff         	b	0x700a9944 <xQueueGiveFromISR+0x64> @ imm = #-0x2
;                             }
700a9944: e000         	b	0x700a9948 <xQueueGiveFromISR+0x68> @ imm = #0x0
700a9946: e7ff         	b	0x700a9948 <xQueueGiveFromISR+0x68> @ imm = #-0x2
;                         }
700a9948: e000         	b	0x700a994c <xQueueGiveFromISR+0x6c> @ imm = #0x0
700a994a: e7ff         	b	0x700a994c <xQueueGiveFromISR+0x6c> @ imm = #-0x2
;             }
700a994c: e006         	b	0x700a995c <xQueueGiveFromISR+0x7c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a994e: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a9952: 3001         	adds	r0, #0x1
700a9954: 9903         	ldr	r1, [sp, #0xc]
700a9956: f881 0045    	strb.w	r0, [r1, #0x45]
700a995a: e7ff         	b	0x700a995c <xQueueGiveFromISR+0x7c> @ imm = #-0x2
700a995c: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a995e: 9005         	str	r0, [sp, #0x14]
;         }
700a9960: e002         	b	0x700a9968 <xQueueGiveFromISR+0x88> @ imm = #0x4
700a9962: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a9964: 9005         	str	r0, [sp, #0x14]
700a9966: e7ff         	b	0x700a9968 <xQueueGiveFromISR+0x88> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a9968: 9804         	ldr	r0, [sp, #0x10]
700a996a: f006 effa    	blx	0x700b0960 <HwiP_restore> @ imm = #0x6ff4
;     return xReturn;
700a996e: 9805         	ldr	r0, [sp, #0x14]
700a9970: b008         	add	sp, #0x20
700a9972: bd80         	pop	{r7, pc}
		...

700a9980 <xTimerGenericCommand>:
;     {
700a9980: b580         	push	{r7, lr}
700a9982: b08a         	sub	sp, #0x28
700a9984: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a9988: 9009         	str	r0, [sp, #0x24]
700a998a: 9108         	str	r1, [sp, #0x20]
700a998c: 9207         	str	r2, [sp, #0x1c]
700a998e: 9306         	str	r3, [sp, #0x18]
700a9990: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700a9992: 9005         	str	r0, [sp, #0x14]
;         if( xTimerQueue != NULL )
700a9994: f642 2048    	movw	r0, #0x2a48
700a9998: f2c7 000b    	movt	r0, #0x700b
700a999c: 6800         	ldr	r0, [r0]
700a999e: b3a8         	cbz	r0, 0x700a9a0c <xTimerGenericCommand+0x8c> @ imm = #0x6a
700a99a0: e7ff         	b	0x700a99a2 <xTimerGenericCommand+0x22> @ imm = #-0x2
;             xMessage.xMessageID = xCommandID;
700a99a2: 9808         	ldr	r0, [sp, #0x20]
700a99a4: 9001         	str	r0, [sp, #0x4]
;             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
700a99a6: 9807         	ldr	r0, [sp, #0x1c]
700a99a8: 9002         	str	r0, [sp, #0x8]
;             xMessage.u.xTimerParameters.pxTimer = xTimer;
700a99aa: 9809         	ldr	r0, [sp, #0x24]
700a99ac: 9003         	str	r0, [sp, #0xc]
;             if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
700a99ae: 9808         	ldr	r0, [sp, #0x20]
700a99b0: 2805         	cmp	r0, #0x5
700a99b2: dc1e         	bgt	0x700a99f2 <xTimerGenericCommand+0x72> @ imm = #0x3c
700a99b4: e7ff         	b	0x700a99b6 <xTimerGenericCommand+0x36> @ imm = #-0x2
;                 if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
700a99b6: f004 fcab    	bl	0x700ae310 <xTaskGetSchedulerState> @ imm = #0x4956
700a99ba: 2802         	cmp	r0, #0x2
700a99bc: d10c         	bne	0x700a99d8 <xTimerGenericCommand+0x58> @ imm = #0x18
700a99be: e7ff         	b	0x700a99c0 <xTimerGenericCommand+0x40> @ imm = #-0x2
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
700a99c0: f642 2048    	movw	r0, #0x2a48
700a99c4: f2c7 000b    	movt	r0, #0x700b
700a99c8: 6800         	ldr	r0, [r0]
700a99ca: 9a0c         	ldr	r2, [sp, #0x30]
700a99cc: a901         	add	r1, sp, #0x4
700a99ce: 2300         	movs	r3, #0x0
700a99d0: f7f9 fbb6    	bl	0x700a3140 <xQueueGenericSend> @ imm = #-0x6894
700a99d4: 9005         	str	r0, [sp, #0x14]
;                 }
700a99d6: e00b         	b	0x700a99f0 <xTimerGenericCommand+0x70> @ imm = #0x16
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
700a99d8: f642 2048    	movw	r0, #0x2a48
700a99dc: f2c7 000b    	movt	r0, #0x700b
700a99e0: 6800         	ldr	r0, [r0]
700a99e2: a901         	add	r1, sp, #0x4
700a99e4: 2300         	movs	r3, #0x0
700a99e6: 461a         	mov	r2, r3
700a99e8: f7f9 fbaa    	bl	0x700a3140 <xQueueGenericSend> @ imm = #-0x68ac
700a99ec: 9005         	str	r0, [sp, #0x14]
700a99ee: e7ff         	b	0x700a99f0 <xTimerGenericCommand+0x70> @ imm = #-0x2
;             }
700a99f0: e00b         	b	0x700a9a0a <xTimerGenericCommand+0x8a> @ imm = #0x16
;                 xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
700a99f2: f642 2048    	movw	r0, #0x2a48
700a99f6: f2c7 000b    	movt	r0, #0x700b
700a99fa: 6800         	ldr	r0, [r0]
700a99fc: 9a06         	ldr	r2, [sp, #0x18]
700a99fe: a901         	add	r1, sp, #0x4
700a9a00: 2300         	movs	r3, #0x0
700a9a02: f7fe ff3d    	bl	0x700a8880 <xQueueGenericSendFromISR> @ imm = #-0x1186
700a9a06: 9005         	str	r0, [sp, #0x14]
700a9a08: e7ff         	b	0x700a9a0a <xTimerGenericCommand+0x8a> @ imm = #-0x2
;         }
700a9a0a: e000         	b	0x700a9a0e <xTimerGenericCommand+0x8e> @ imm = #0x0
700a9a0c: e7ff         	b	0x700a9a0e <xTimerGenericCommand+0x8e> @ imm = #-0x2
;         return xReturn;
700a9a0e: 9805         	ldr	r0, [sp, #0x14]
700a9a10: b00a         	add	sp, #0x28
700a9a12: bd80         	pop	{r7, pc}
		...

700a9a20 <SOC_moduleClockEnable>:
; {
700a9a20: b580         	push	{r7, lr}
700a9a22: b088         	sub	sp, #0x20
700a9a24: 9007         	str	r0, [sp, #0x1c]
700a9a26: 9106         	str	r1, [sp, #0x18]
700a9a28: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a9a2a: 9005         	str	r0, [sp, #0x14]
700a9a2c: 2102         	movs	r1, #0x2
;     uint32_t moduleState = TISCI_MSG_VALUE_DEVICE_HW_STATE_TRANS;
700a9a2e: 9104         	str	r1, [sp, #0x10]
;     uint32_t resetState = 0U;
700a9a30: 9003         	str	r0, [sp, #0xc]
;     uint32_t contextLossState = 0U;
700a9a32: 9002         	str	r0, [sp, #0x8]
;     status = Sciclient_pmGetModuleState(moduleId,
700a9a34: 9807         	ldr	r0, [sp, #0x1c]
700a9a36: 466a         	mov	r2, sp
700a9a38: f04f 31ff    	mov.w	r1, #0xffffffff
700a9a3c: 6011         	str	r1, [r2]
700a9a3e: a904         	add	r1, sp, #0x10
700a9a40: aa03         	add	r2, sp, #0xc
700a9a42: ab02         	add	r3, sp, #0x8
700a9a44: f000 f96c    	bl	0x700a9d20 <Sciclient_pmGetModuleState> @ imm = #0x2d8
700a9a48: 9005         	str	r0, [sp, #0x14]
;     if(status == SystemP_SUCCESS)
700a9a4a: 9805         	ldr	r0, [sp, #0x14]
700a9a4c: bb70         	cbnz	r0, 0x700a9aac <SOC_moduleClockEnable+0x8c> @ imm = #0x5c
700a9a4e: e7ff         	b	0x700a9a50 <SOC_moduleClockEnable+0x30> @ imm = #-0x2
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_OFF && (enable == 1))
700a9a50: 9804         	ldr	r0, [sp, #0x10]
700a9a52: b9c8         	cbnz	r0, 0x700a9a88 <SOC_moduleClockEnable+0x68> @ imm = #0x32
700a9a54: e7ff         	b	0x700a9a56 <SOC_moduleClockEnable+0x36> @ imm = #-0x2
700a9a56: 9806         	ldr	r0, [sp, #0x18]
700a9a58: 2801         	cmp	r0, #0x1
700a9a5a: d115         	bne	0x700a9a88 <SOC_moduleClockEnable+0x68> @ imm = #0x2a
700a9a5c: e7ff         	b	0x700a9a5e <SOC_moduleClockEnable+0x3e> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a9a5e: 9807         	ldr	r0, [sp, #0x1c]
700a9a60: 2102         	movs	r1, #0x2
700a9a62: f240 2202    	movw	r2, #0x202
700a9a66: f04f 33ff    	mov.w	r3, #0xffffffff
700a9a6a: f000 f9e9    	bl	0x700a9e40 <Sciclient_pmSetModuleState> @ imm = #0x3d2
700a9a6e: 9005         	str	r0, [sp, #0x14]
;             if (status == SystemP_SUCCESS)
700a9a70: 9805         	ldr	r0, [sp, #0x14]
700a9a72: b940         	cbnz	r0, 0x700a9a86 <SOC_moduleClockEnable+0x66> @ imm = #0x10
700a9a74: e7ff         	b	0x700a9a76 <SOC_moduleClockEnable+0x56> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleRst(moduleId,
700a9a76: 9807         	ldr	r0, [sp, #0x1c]
700a9a78: 2100         	movs	r1, #0x0
700a9a7a: f04f 32ff    	mov.w	r2, #0xffffffff
700a9a7e: f002 fc8f    	bl	0x700ac3a0 <Sciclient_pmSetModuleRst> @ imm = #0x291e
700a9a82: 9005         	str	r0, [sp, #0x14]
;             }
700a9a84: e7ff         	b	0x700a9a86 <SOC_moduleClockEnable+0x66> @ imm = #-0x2
;         }
700a9a86: e010         	b	0x700a9aaa <SOC_moduleClockEnable+0x8a> @ imm = #0x20
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_ON && (enable == 0))
700a9a88: 9804         	ldr	r0, [sp, #0x10]
700a9a8a: 2801         	cmp	r0, #0x1
700a9a8c: d10c         	bne	0x700a9aa8 <SOC_moduleClockEnable+0x88> @ imm = #0x18
700a9a8e: e7ff         	b	0x700a9a90 <SOC_moduleClockEnable+0x70> @ imm = #-0x2
700a9a90: 9806         	ldr	r0, [sp, #0x18]
700a9a92: b948         	cbnz	r0, 0x700a9aa8 <SOC_moduleClockEnable+0x88> @ imm = #0x12
700a9a94: e7ff         	b	0x700a9a96 <SOC_moduleClockEnable+0x76> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a9a96: 9807         	ldr	r0, [sp, #0x1c]
700a9a98: 2100         	movs	r1, #0x0
700a9a9a: 2202         	movs	r2, #0x2
700a9a9c: f04f 33ff    	mov.w	r3, #0xffffffff
700a9aa0: f000 f9ce    	bl	0x700a9e40 <Sciclient_pmSetModuleState> @ imm = #0x39c
700a9aa4: 9005         	str	r0, [sp, #0x14]
;         }
700a9aa6: e7ff         	b	0x700a9aa8 <SOC_moduleClockEnable+0x88> @ imm = #-0x2
700a9aa8: e7ff         	b	0x700a9aaa <SOC_moduleClockEnable+0x8a> @ imm = #-0x2
;     }
700a9aaa: e7ff         	b	0x700a9aac <SOC_moduleClockEnable+0x8c> @ imm = #-0x2
;     return status;
700a9aac: 9805         	ldr	r0, [sp, #0x14]
700a9aae: b008         	add	sp, #0x20
700a9ab0: bd80         	pop	{r7, pc}
		...
700a9abe: 0000         	movs	r0, r0

700a9ac0 <Sciclient_rmPsPop>:
; {
700a9ac0: b084         	sub	sp, #0x10
700a9ac2: 9003         	str	r0, [sp, #0xc]
700a9ac4: 9102         	str	r1, [sp, #0x8]
700a9ac6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a9ac8: 9001         	str	r0, [sp, #0x4]
;     if ((gPstack.psp > (0u)) && (n != NULL) && (if_idx != NULL)) {
700a9aca: f241 0058    	movw	r0, #0x1058
700a9ace: f2c7 0008    	movt	r0, #0x7008
700a9ad2: 8c80         	ldrh	r0, [r0, #0x24]
700a9ad4: b3b0         	cbz	r0, 0x700a9b44 <Sciclient_rmPsPop+0x84> @ imm = #0x6c
700a9ad6: e7ff         	b	0x700a9ad8 <Sciclient_rmPsPop+0x18> @ imm = #-0x2
700a9ad8: 9803         	ldr	r0, [sp, #0xc]
700a9ada: b398         	cbz	r0, 0x700a9b44 <Sciclient_rmPsPop+0x84> @ imm = #0x66
700a9adc: e7ff         	b	0x700a9ade <Sciclient_rmPsPop+0x1e> @ imm = #-0x2
700a9ade: 9802         	ldr	r0, [sp, #0x8]
700a9ae0: b380         	cbz	r0, 0x700a9b44 <Sciclient_rmPsPop+0x84> @ imm = #0x60
700a9ae2: e7ff         	b	0x700a9ae4 <Sciclient_rmPsPop+0x24> @ imm = #-0x2
;         gPstack.psp--;
700a9ae4: f241 0158    	movw	r1, #0x1058
700a9ae8: f2c7 0108    	movt	r1, #0x7008
700a9aec: 9100         	str	r1, [sp]
700a9aee: 8c88         	ldrh	r0, [r1, #0x24]
700a9af0: 3801         	subs	r0, #0x1
700a9af2: 8488         	strh	r0, [r1, #0x24]
;         *n = gPstack.ps[gPstack.psp].p_n;
700a9af4: 8c88         	ldrh	r0, [r1, #0x24]
700a9af6: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a9afa: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700a9afe: 9a03         	ldr	r2, [sp, #0xc]
700a9b00: 6010         	str	r0, [r2]
;         *if_idx = gPstack.ps[gPstack.psp].if_idx;
700a9b02: 8c88         	ldrh	r0, [r1, #0x24]
700a9b04: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a9b08: eb01 0080    	add.w	r0, r1, r0, lsl #2
700a9b0c: 8880         	ldrh	r0, [r0, #0x4]
700a9b0e: 9a02         	ldr	r2, [sp, #0x8]
700a9b10: 8010         	strh	r0, [r2]
;         gPstack.ps[gPstack.psp].p_n = NULL;
700a9b12: 8c88         	ldrh	r0, [r1, #0x24]
700a9b14: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a9b18: 2000         	movs	r0, #0x0
700a9b1a: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = 0;
700a9b1e: 8c8a         	ldrh	r2, [r1, #0x24]
700a9b20: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9b24: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a9b28: 8090         	strh	r0, [r2, #0x4]
;         gPstack.ps[gPstack.psp].inp = 0;
700a9b2a: 8c8a         	ldrh	r2, [r1, #0x24]
700a9b2c: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9b30: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a9b34: 80d0         	strh	r0, [r2, #0x6]
;         gPstack.ps[gPstack.psp].outp = 0;
700a9b36: 8c8a         	ldrh	r2, [r1, #0x24]
700a9b38: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9b3c: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a9b40: 8108         	strh	r0, [r1, #0x8]
;     } else {
700a9b42: e003         	b	0x700a9b4c <Sciclient_rmPsPop+0x8c> @ imm = #0x6
700a9b44: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a9b48: 9001         	str	r0, [sp, #0x4]
700a9b4a: e7ff         	b	0x700a9b4c <Sciclient_rmPsPop+0x8c> @ imm = #-0x2
;     return r;
700a9b4c: 9801         	ldr	r0, [sp, #0x4]
700a9b4e: b004         	add	sp, #0x10
700a9b50: 4770         	bx	lr
		...
700a9b5e: 0000         	movs	r0, r0

700a9b60 <_DebugP_logZone>:
; {
700a9b60: b082         	sub	sp, #0x8
700a9b62: b580         	push	{r7, lr}
700a9b64: b086         	sub	sp, #0x18
700a9b66: 9309         	str	r3, [sp, #0x24]
700a9b68: 9208         	str	r2, [sp, #0x20]
700a9b6a: 9005         	str	r0, [sp, #0x14]
700a9b6c: 9104         	str	r1, [sp, #0x10]
;     if((HwiP_inISR()) == 0U )
700a9b6e: f006 fbf7    	bl	0x700b0360 <HwiP_inISR> @ imm = #0x67ee
700a9b72: bbc8         	cbnz	r0, 0x700a9be8 <_DebugP_logZone+0x88> @ imm = #0x72
700a9b74: e7ff         	b	0x700a9b76 <_DebugP_logZone+0x16> @ imm = #-0x2
;         if(gDebugLogIsInitDone == 0U)
700a9b76: f642 10cc    	movw	r0, #0x29cc
700a9b7a: f2c7 000b    	movt	r0, #0x700b
700a9b7e: 6800         	ldr	r0, [r0]
700a9b80: b9a0         	cbnz	r0, 0x700a9bac <_DebugP_logZone+0x4c> @ imm = #0x28
700a9b82: e7ff         	b	0x700a9b84 <_DebugP_logZone+0x24> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&gDebugLogLockObj);
700a9b84: f644 5018    	movw	r0, #0x4d18
700a9b88: f2c7 0008    	movt	r0, #0x7008
700a9b8c: f001 fcb0    	bl	0x700ab4f0 <SemaphoreP_constructMutex> @ imm = #0x1960
700a9b90: 9003         	str	r0, [sp, #0xc]
;             DebugP_assertNoLog(status == SystemP_SUCCESS);
700a9b92: 9803         	ldr	r0, [sp, #0xc]
700a9b94: fab0 f080    	clz	r0, r0
700a9b98: 0940         	lsrs	r0, r0, #0x5
700a9b9a: f007 fb81    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x7702
;             gDebugLogIsInitDone = 1;
700a9b9e: f642 11cc    	movw	r1, #0x29cc
700a9ba2: f2c7 010b    	movt	r1, #0x700b
700a9ba6: 2001         	movs	r0, #0x1
700a9ba8: 6008         	str	r0, [r1]
;         }
700a9baa: e7ff         	b	0x700a9bac <_DebugP_logZone+0x4c> @ imm = #-0x2
;         if( ( gDebugLogZone & logZone ) == logZone )
700a9bac: f642 10d0    	movw	r0, #0x29d0
700a9bb0: f2c7 000b    	movt	r0, #0x700b
700a9bb4: 6800         	ldr	r0, [r0]
700a9bb6: 9905         	ldr	r1, [sp, #0x14]
700a9bb8: 4008         	ands	r0, r1
700a9bba: 4288         	cmp	r0, r1
700a9bbc: d113         	bne	0x700a9be6 <_DebugP_logZone+0x86> @ imm = #0x26
700a9bbe: e7ff         	b	0x700a9bc0 <_DebugP_logZone+0x60> @ imm = #-0x2
;             SemaphoreP_pend(&gDebugLogLockObj, SystemP_WAIT_FOREVER);
700a9bc0: f644 5018    	movw	r0, #0x4d18
700a9bc4: f2c7 0008    	movt	r0, #0x7008
700a9bc8: 9001         	str	r0, [sp, #0x4]
700a9bca: f04f 31ff    	mov.w	r1, #0xffffffff
700a9bce: f000 fd27    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0xa4e
700a9bd2: a808         	add	r0, sp, #0x20
;             va_start(va, format);
700a9bd4: 9002         	str	r0, [sp, #0x8]
;             vprintf_(format, va);
700a9bd6: 9804         	ldr	r0, [sp, #0x10]
700a9bd8: 9902         	ldr	r1, [sp, #0x8]
700a9bda: f005 f959    	bl	0x700aee90 <vprintf_>   @ imm = #0x52b2
;             SemaphoreP_post(&gDebugLogLockObj);
700a9bde: 9801         	ldr	r0, [sp, #0x4]
700a9be0: f002 f8e6    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x21cc
;         }
700a9be4: e7ff         	b	0x700a9be6 <_DebugP_logZone+0x86> @ imm = #-0x2
;     }
700a9be6: e7ff         	b	0x700a9be8 <_DebugP_logZone+0x88> @ imm = #-0x2
; }
700a9be8: b006         	add	sp, #0x18
700a9bea: e8bd 4080    	pop.w	{r7, lr}
700a9bee: b002         	add	sp, #0x8
700a9bf0: 4770         	bx	lr
		...
700a9bfe: 0000         	movs	r0, r0

700a9c00 <Udma_rmFreeMappedRing>:
; {
700a9c00: b580         	push	{r7, lr}
700a9c02: b08e         	sub	sp, #0x38
700a9c04: 900d         	str	r0, [sp, #0x34]
700a9c06: 910c         	str	r1, [sp, #0x30]
700a9c08: 920b         	str	r2, [sp, #0x2c]
700a9c0a: 930a         	str	r3, [sp, #0x28]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9c0c: 980c         	ldr	r0, [sp, #0x30]
700a9c0e: f500 70ea    	add.w	r0, r0, #0x1d4
700a9c12: 9005         	str	r0, [sp, #0x14]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a9c14: 980c         	ldr	r0, [sp, #0x30]
700a9c16: 990b         	ldr	r1, [sp, #0x2c]
700a9c18: 9a0a         	ldr	r2, [sp, #0x28]
700a9c1a: ab02         	add	r3, sp, #0x8
700a9c1c: f7fe f808    	bl	0x700a7c30 <Udma_getMappedChRingAttributes> @ imm = #-0x1ff0
700a9c20: 9001         	str	r0, [sp, #0x4]
;     if(ringNum != chAttr.defaultRing)
700a9c22: 980d         	ldr	r0, [sp, #0x34]
700a9c24: 9902         	ldr	r1, [sp, #0x8]
700a9c26: 4288         	cmp	r0, r1
700a9c28: d02f         	beq	0x700a9c8a <Udma_rmFreeMappedRing+0x8a> @ imm = #0x5e
700a9c2a: e7ff         	b	0x700a9c2c <Udma_rmFreeMappedRing+0x2c> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9c2c: 980c         	ldr	r0, [sp, #0x30]
700a9c2e: f500 609f    	add.w	r0, r0, #0x4f8
700a9c32: f04f 31ff    	mov.w	r1, #0xffffffff
700a9c36: f000 fcf3    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x9e6
;         i = ringNum - rmInitPrms->startMappedRing[mappedRingGrp];
700a9c3a: 980d         	ldr	r0, [sp, #0x34]
700a9c3c: 9905         	ldr	r1, [sp, #0x14]
700a9c3e: 9a0b         	ldr	r2, [sp, #0x2c]
700a9c40: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a9c44: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a9c48: 1a40         	subs	r0, r0, r1
700a9c4a: 9009         	str	r0, [sp, #0x24]
;         offset = i >> 5U;
700a9c4c: 9809         	ldr	r0, [sp, #0x24]
700a9c4e: 0940         	lsrs	r0, r0, #0x5
700a9c50: 9008         	str	r0, [sp, #0x20]
;         bitPos = i - (offset << 5U);
700a9c52: 9809         	ldr	r0, [sp, #0x24]
700a9c54: 9908         	ldr	r1, [sp, #0x20]
700a9c56: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9c5a: 9007         	str	r0, [sp, #0x1c]
;         bitMask = (uint32_t) 1U << bitPos;
700a9c5c: 9907         	ldr	r1, [sp, #0x1c]
700a9c5e: 2001         	movs	r0, #0x1
700a9c60: 4088         	lsls	r0, r1
700a9c62: 9006         	str	r0, [sp, #0x18]
;         drvHandle->mappedRingFlag[mappedRingGrp][offset] |= bitMask;
700a9c64: 9a06         	ldr	r2, [sp, #0x18]
700a9c66: 980c         	ldr	r0, [sp, #0x30]
700a9c68: 990b         	ldr	r1, [sp, #0x2c]
700a9c6a: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a9c6e: 9908         	ldr	r1, [sp, #0x20]
700a9c70: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9c74: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a9c78: 4310         	orrs	r0, r2
700a9c7a: f8c1 0344    	str.w	r0, [r1, #0x344]
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a9c7e: 980c         	ldr	r0, [sp, #0x30]
700a9c80: f500 609f    	add.w	r0, r0, #0x4f8
700a9c84: f002 f894    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x2128
;     }
700a9c88: e7ff         	b	0x700a9c8a <Udma_rmFreeMappedRing+0x8a> @ imm = #-0x2
;     return;
700a9c8a: b00e         	add	sp, #0x38
700a9c8c: bd80         	pop	{r7, pc}
700a9c8e: 0000         	movs	r0, r0

700a9c90 <prvInitialiseTaskLists>:
; static void prvInitialiseTaskLists(void) {
700a9c90: b580         	push	{r7, lr}
700a9c92: b084         	sub	sp, #0x10
700a9c94: 2000         	movs	r0, #0x0
;   for (uxPriority = (UBaseType_t)0U;
700a9c96: 9003         	str	r0, [sp, #0xc]
700a9c98: e7ff         	b	0x700a9c9a <prvInitialiseTaskLists+0xa> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a9c9a: 9803         	ldr	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a9c9c: 281f         	cmp	r0, #0x1f
700a9c9e: d810         	bhi	0x700a9cc2 <prvInitialiseTaskLists+0x32> @ imm = #0x20
700a9ca0: e7ff         	b	0x700a9ca2 <prvInitialiseTaskLists+0x12> @ imm = #-0x2
;     vListInitialise(&(pxReadyTasksLists[uxPriority]));
700a9ca2: 9803         	ldr	r0, [sp, #0xc]
700a9ca4: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a9ca8: f244 40f8    	movw	r0, #0x44f8
700a9cac: f2c7 0008    	movt	r0, #0x7008
700a9cb0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a9cb4: f004 fe94    	bl	0x700ae9e0 <vListInitialise> @ imm = #0x4d28
;   }
700a9cb8: e7ff         	b	0x700a9cba <prvInitialiseTaskLists+0x2a> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a9cba: 9803         	ldr	r0, [sp, #0xc]
700a9cbc: 3001         	adds	r0, #0x1
700a9cbe: 9003         	str	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a9cc0: e7eb         	b	0x700a9c9a <prvInitialiseTaskLists+0xa> @ imm = #-0x2a
;   vListInitialise(&xDelayedTaskList1);
700a9cc2: f245 00b8    	movw	r0, #0x50b8
700a9cc6: f2c7 0008    	movt	r0, #0x7008
700a9cca: 9001         	str	r0, [sp, #0x4]
700a9ccc: f004 fe88    	bl	0x700ae9e0 <vListInitialise> @ imm = #0x4d10
;   vListInitialise(&xDelayedTaskList2);
700a9cd0: f245 00cc    	movw	r0, #0x50cc
700a9cd4: f2c7 0008    	movt	r0, #0x7008
700a9cd8: 9002         	str	r0, [sp, #0x8]
700a9cda: f004 fe81    	bl	0x700ae9e0 <vListInitialise> @ imm = #0x4d02
;   vListInitialise(&xPendingReadyList);
700a9cde: f245 00e0    	movw	r0, #0x50e0
700a9ce2: f2c7 0008    	movt	r0, #0x7008
700a9ce6: f004 fe7b    	bl	0x700ae9e0 <vListInitialise> @ imm = #0x4cf6
;     vListInitialise(&xTasksWaitingTermination);
700a9cea: f245 1008    	movw	r0, #0x5108
700a9cee: f2c7 0008    	movt	r0, #0x7008
700a9cf2: f004 fe75    	bl	0x700ae9e0 <vListInitialise> @ imm = #0x4cea
;     vListInitialise(&xSuspendedTaskList);
700a9cf6: f245 00f4    	movw	r0, #0x50f4
700a9cfa: f2c7 0008    	movt	r0, #0x7008
700a9cfe: f004 fe6f    	bl	0x700ae9e0 <vListInitialise> @ imm = #0x4cde
700a9d02: 9901         	ldr	r1, [sp, #0x4]
700a9d04: 9802         	ldr	r0, [sp, #0x8]
;   pxDelayedTaskList = &xDelayedTaskList1;
700a9d06: f245 1228    	movw	r2, #0x5128
700a9d0a: f2c7 0208    	movt	r2, #0x7008
700a9d0e: 6011         	str	r1, [r2]
;   pxOverflowDelayedTaskList = &xDelayedTaskList2;
700a9d10: f245 112c    	movw	r1, #0x512c
700a9d14: f2c7 0108    	movt	r1, #0x7008
700a9d18: 6008         	str	r0, [r1]
; }
700a9d1a: b004         	add	sp, #0x10
700a9d1c: bd80         	pop	{r7, pc}
700a9d1e: 0000         	movs	r0, r0

700a9d20 <Sciclient_pmGetModuleState>:
; {
700a9d20: b580         	push	{r7, lr}
700a9d22: b096         	sub	sp, #0x58
700a9d24: f8dd c060    	ldr.w	r12, [sp, #0x60]
700a9d28: 9015         	str	r0, [sp, #0x54]
700a9d2a: 9114         	str	r1, [sp, #0x50]
700a9d2c: 9213         	str	r2, [sp, #0x4c]
700a9d2e: 9312         	str	r3, [sp, #0x48]
700a9d30: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a9d32: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_device_resp response = {{0}};
700a9d34: f8ad 0034    	strh.w	r0, [sp, #0x34]
700a9d38: 900c         	str	r0, [sp, #0x30]
700a9d3a: 900b         	str	r0, [sp, #0x2c]
700a9d3c: 900a         	str	r0, [sp, #0x28]
700a9d3e: 9009         	str	r0, [sp, #0x24]
;     request.id = (uint32_t) moduleId;
700a9d40: 9915         	ldr	r1, [sp, #0x54]
700a9d42: 9110         	str	r1, [sp, #0x40]
700a9d44: f240 2101    	movw	r1, #0x201
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_DEVICE;
700a9d48: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a9d4c: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a9d4e: 9105         	str	r1, [sp, #0x14]
700a9d50: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a9d52: 9106         	str	r1, [sp, #0x18]
700a9d54: 210c         	movs	r1, #0xc
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9d56: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a9d58: 9918         	ldr	r1, [sp, #0x60]
700a9d5a: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9d5c: 9001         	str	r0, [sp, #0x4]
700a9d5e: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a9d60: 9002         	str	r0, [sp, #0x8]
700a9d62: 2012         	movs	r0, #0x12
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a9d64: 9003         	str	r0, [sp, #0xc]
700a9d66: a804         	add	r0, sp, #0x10
700a9d68: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9d6a: f7f3 fa09    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xcbee
700a9d6e: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a9d70: 9811         	ldr	r0, [sp, #0x44]
700a9d72: b930         	cbnz	r0, 0x700a9d82 <Sciclient_pmGetModuleState+0x62> @ imm = #0xc
700a9d74: e7ff         	b	0x700a9d76 <Sciclient_pmGetModuleState+0x56> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9d76: 9801         	ldr	r0, [sp, #0x4]
700a9d78: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9d7c: 2802         	cmp	r0, #0x2
700a9d7e: d004         	beq	0x700a9d8a <Sciclient_pmGetModuleState+0x6a> @ imm = #0x8
700a9d80: e7ff         	b	0x700a9d82 <Sciclient_pmGetModuleState+0x62> @ imm = #-0x2
700a9d82: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9d86: 9011         	str	r0, [sp, #0x44]
;     }
700a9d88: e7ff         	b	0x700a9d8a <Sciclient_pmGetModuleState+0x6a> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a9d8a: 9811         	ldr	r0, [sp, #0x44]
700a9d8c: b958         	cbnz	r0, 0x700a9da6 <Sciclient_pmGetModuleState+0x86> @ imm = #0x16
700a9d8e: e7ff         	b	0x700a9d90 <Sciclient_pmGetModuleState+0x70> @ imm = #-0x2
;         *moduleState = (uint32_t) response.current_state;
700a9d90: f89d 0035    	ldrb.w	r0, [sp, #0x35]
700a9d94: 9914         	ldr	r1, [sp, #0x50]
700a9d96: 6008         	str	r0, [r1]
;         *resetState = (uint32_t) response.resets;
700a9d98: 980c         	ldr	r0, [sp, #0x30]
700a9d9a: 9913         	ldr	r1, [sp, #0x4c]
700a9d9c: 6008         	str	r0, [r1]
;         *contextLossState = (uint32_t) response.context_loss_count;
700a9d9e: 980b         	ldr	r0, [sp, #0x2c]
700a9da0: 9912         	ldr	r1, [sp, #0x48]
700a9da2: 6008         	str	r0, [r1]
;     }
700a9da4: e7ff         	b	0x700a9da6 <Sciclient_pmGetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a9da6: 9811         	ldr	r0, [sp, #0x44]
700a9da8: b016         	add	sp, #0x58
700a9daa: bd80         	pop	{r7, pc}
700a9dac: 0000         	movs	r0, r0
700a9dae: 0000         	movs	r0, r0

700a9db0 <Sciclient_pmModuleClkRequest>:
; {
700a9db0: b580         	push	{r7, lr}
700a9db2: b092         	sub	sp, #0x48
700a9db4: f8dd c050    	ldr.w	r12, [sp, #0x50]
700a9db8: 9011         	str	r0, [sp, #0x44]
700a9dba: 9110         	str	r1, [sp, #0x40]
700a9dbc: 920f         	str	r2, [sp, #0x3c]
700a9dbe: 930e         	str	r3, [sp, #0x38]
700a9dc0: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a9dc2: 900d         	str	r0, [sp, #0x34]
;     request.device = (uint32_t) moduleId;
700a9dc4: 9811         	ldr	r0, [sp, #0x44]
700a9dc6: 900a         	str	r0, [sp, #0x28]
;     if(clockId > (uint32_t)(255U))
700a9dc8: 9810         	ldr	r0, [sp, #0x40]
700a9dca: f5b0 7f80    	cmp.w	r0, #0x100
700a9dce: d307         	blo	0x700a9de0 <Sciclient_pmModuleClkRequest+0x30> @ imm = #0xe
700a9dd0: e7ff         	b	0x700a9dd2 <Sciclient_pmModuleClkRequest+0x22> @ imm = #-0x2
700a9dd2: 20ff         	movs	r0, #0xff
;         request.clk = (uint8_t)(255U);
700a9dd4: f88d 002c    	strb.w	r0, [sp, #0x2c]
;         request.clk32 = clockId;
700a9dd8: 9810         	ldr	r0, [sp, #0x40]
700a9dda: f8cd 002e    	str.w	r0, [sp, #0x2e]
;     }
700a9dde: e003         	b	0x700a9de8 <Sciclient_pmModuleClkRequest+0x38> @ imm = #0x6
;         request.clk    = (uint8_t)clockId;
700a9de0: 9810         	ldr	r0, [sp, #0x40]
700a9de2: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a9de6: e7ff         	b	0x700a9de8 <Sciclient_pmModuleClkRequest+0x38> @ imm = #-0x2
;     request.state  = (uint8_t) state;
700a9de8: 980f         	ldr	r0, [sp, #0x3c]
700a9dea: f88d 002d    	strb.w	r0, [sp, #0x2d]
700a9dee: f44f 7080    	mov.w	r0, #0x100
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK;
700a9df2: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP | additionalFlag;
700a9df6: 980e         	ldr	r0, [sp, #0x38]
700a9df8: f040 0002    	orr	r0, r0, #0x2
700a9dfc: 9004         	str	r0, [sp, #0x10]
700a9dfe: a808         	add	r0, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a9e00: 9005         	str	r0, [sp, #0x14]
700a9e02: 2012         	movs	r0, #0x12
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9e04: 9006         	str	r0, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a9e06: 9814         	ldr	r0, [sp, #0x50]
700a9e08: 9007         	str	r0, [sp, #0x1c]
700a9e0a: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9e0c: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a9e0e: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a9e10: 9002         	str	r0, [sp, #0x8]
700a9e12: a803         	add	r0, sp, #0xc
700a9e14: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9e16: f7f3 f9b3    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xcc9a
700a9e1a: 900d         	str	r0, [sp, #0x34]
;     if((retVal != SystemP_SUCCESS) ||
700a9e1c: 980d         	ldr	r0, [sp, #0x34]
700a9e1e: b930         	cbnz	r0, 0x700a9e2e <Sciclient_pmModuleClkRequest+0x7e> @ imm = #0xc
700a9e20: e7ff         	b	0x700a9e22 <Sciclient_pmModuleClkRequest+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9e22: 9800         	ldr	r0, [sp]
700a9e24: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9e28: 2802         	cmp	r0, #0x2
700a9e2a: d004         	beq	0x700a9e36 <Sciclient_pmModuleClkRequest+0x86> @ imm = #0x8
700a9e2c: e7ff         	b	0x700a9e2e <Sciclient_pmModuleClkRequest+0x7e> @ imm = #-0x2
700a9e2e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9e32: 900d         	str	r0, [sp, #0x34]
;     }
700a9e34: e7ff         	b	0x700a9e36 <Sciclient_pmModuleClkRequest+0x86> @ imm = #-0x2
;     return retVal;
700a9e36: 980d         	ldr	r0, [sp, #0x34]
700a9e38: b012         	add	sp, #0x48
700a9e3a: bd80         	pop	{r7, pc}
700a9e3c: 0000         	movs	r0, r0
700a9e3e: 0000         	movs	r0, r0

700a9e40 <Sciclient_pmSetModuleState>:
; {
700a9e40: b580         	push	{r7, lr}
700a9e42: b092         	sub	sp, #0x48
700a9e44: 9011         	str	r0, [sp, #0x44]
700a9e46: 9110         	str	r1, [sp, #0x40]
700a9e48: 920f         	str	r2, [sp, #0x3c]
700a9e4a: 930e         	str	r3, [sp, #0x38]
700a9e4c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a9e4e: 900d         	str	r0, [sp, #0x34]
;     request.id       = (uint32_t) moduleId;
700a9e50: 9911         	ldr	r1, [sp, #0x44]
700a9e52: 910a         	str	r1, [sp, #0x28]
;     request.reserved = (uint32_t) 0;
700a9e54: 900b         	str	r0, [sp, #0x2c]
;     request.state    = (uint8_t) state;
700a9e56: 9910         	ldr	r1, [sp, #0x40]
700a9e58: f88d 1030    	strb.w	r1, [sp, #0x30]
700a9e5c: f44f 7100    	mov.w	r1, #0x200
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE;
700a9e60: f8ad 100c    	strh.w	r1, [sp, #0xc]
;     reqParam.flags          = (uint32_t) reqFlag;
700a9e64: 990f         	ldr	r1, [sp, #0x3c]
700a9e66: 9104         	str	r1, [sp, #0x10]
700a9e68: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a9e6a: 9105         	str	r1, [sp, #0x14]
700a9e6c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9e6e: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a9e70: 990e         	ldr	r1, [sp, #0x38]
700a9e72: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9e74: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a9e76: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a9e78: 9002         	str	r0, [sp, #0x8]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700a9e7a: 980f         	ldr	r0, [sp, #0x3c]
700a9e7c: f000 0002    	and	r0, r0, #0x2
700a9e80: 2802         	cmp	r0, #0x2
700a9e82: d007         	beq	0x700a9e94 <Sciclient_pmSetModuleState+0x54> @ imm = #0xe
700a9e84: e7ff         	b	0x700a9e86 <Sciclient_pmSetModuleState+0x46> @ imm = #-0x2
;         (reqFlag != 0U))
700a9e86: 980f         	ldr	r0, [sp, #0x3c]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700a9e88: b120         	cbz	r0, 0x700a9e94 <Sciclient_pmSetModuleState+0x54> @ imm = #0x8
700a9e8a: e7ff         	b	0x700a9e8c <Sciclient_pmSetModuleState+0x4c> @ imm = #-0x2
700a9e8c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9e90: 900d         	str	r0, [sp, #0x34]
;     }
700a9e92: e7ff         	b	0x700a9e94 <Sciclient_pmSetModuleState+0x54> @ imm = #-0x2
;     if(retVal == SystemP_SUCCESS)
700a9e94: 980d         	ldr	r0, [sp, #0x34]
700a9e96: b930         	cbnz	r0, 0x700a9ea6 <Sciclient_pmSetModuleState+0x66> @ imm = #0xc
700a9e98: e7ff         	b	0x700a9e9a <Sciclient_pmSetModuleState+0x5a> @ imm = #-0x2
700a9e9a: a803         	add	r0, sp, #0xc
700a9e9c: 4669         	mov	r1, sp
;         retVal = Sciclient_service(&reqParam, &respParam);
700a9e9e: f7f3 f96f    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xcd22
700a9ea2: 900d         	str	r0, [sp, #0x34]
;     }
700a9ea4: e7ff         	b	0x700a9ea6 <Sciclient_pmSetModuleState+0x66> @ imm = #-0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9ea6: 980d         	ldr	r0, [sp, #0x34]
700a9ea8: b948         	cbnz	r0, 0x700a9ebe <Sciclient_pmSetModuleState+0x7e> @ imm = #0x12
700a9eaa: e7ff         	b	0x700a9eac <Sciclient_pmSetModuleState+0x6c> @ imm = #-0x2
;         ((reqFlag != 0U) &&
700a9eac: 980f         	ldr	r0, [sp, #0x3c]
700a9eae: b150         	cbz	r0, 0x700a9ec6 <Sciclient_pmSetModuleState+0x86> @ imm = #0x14
700a9eb0: e7ff         	b	0x700a9eb2 <Sciclient_pmSetModuleState+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)))
700a9eb2: 9800         	ldr	r0, [sp]
700a9eb4: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9eb8: 2802         	cmp	r0, #0x2
700a9eba: d004         	beq	0x700a9ec6 <Sciclient_pmSetModuleState+0x86> @ imm = #0x8
700a9ebc: e7ff         	b	0x700a9ebe <Sciclient_pmSetModuleState+0x7e> @ imm = #-0x2
700a9ebe: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9ec2: 900d         	str	r0, [sp, #0x34]
;     }
700a9ec4: e7ff         	b	0x700a9ec6 <Sciclient_pmSetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a9ec6: 980d         	ldr	r0, [sp, #0x34]
700a9ec8: b012         	add	sp, #0x48
700a9eca: bd80         	pop	{r7, pc}
700a9ecc: 0000         	movs	r0, r0
700a9ece: 0000         	movs	r0, r0

700a9ed0 <Sciclient_rmIaEvtRomMapped>:
; {
700a9ed0: b082         	sub	sp, #0x8
700a9ed2: 9001         	str	r0, [sp, #0x4]
700a9ed4: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a9ed8: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a9eda: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a9ede: 9801         	ldr	r0, [sp, #0x4]
700a9ee0: 6980         	ldr	r0, [r0, #0x18]
700a9ee2: b3a8         	cbz	r0, 0x700a9f50 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #0x6a
700a9ee4: e7ff         	b	0x700a9ee6 <Sciclient_rmIaEvtRomMapped+0x16> @ imm = #-0x2
700a9ee6: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a9ee8: f88d 0000    	strb.w	r0, [sp]
700a9eec: e7ff         	b	0x700a9eee <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x2
700a9eee: f89d 0000    	ldrb.w	r0, [sp]
700a9ef2: 9901         	ldr	r1, [sp, #0x4]
700a9ef4: 7f09         	ldrb	r1, [r1, #0x1c]
700a9ef6: 4288         	cmp	r0, r1
700a9ef8: da29         	bge	0x700a9f4e <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0x52
700a9efa: e7ff         	b	0x700a9efc <Sciclient_rmIaEvtRomMapped+0x2c> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a9efc: 9801         	ldr	r0, [sp, #0x4]
700a9efe: 6980         	ldr	r0, [r0, #0x18]
700a9f00: f89d 1000    	ldrb.w	r1, [sp]
700a9f04: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a9f08: 7880         	ldrb	r0, [r0, #0x2]
700a9f0a: 07c0         	lsls	r0, r0, #0x1f
700a9f0c: b9c0         	cbnz	r0, 0x700a9f40 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x30
700a9f0e: e7ff         	b	0x700a9f10 <Sciclient_rmIaEvtRomMapped+0x40> @ imm = #-0x2
;                 (evt == (inst->rom_usage[i].event - inst->sevt_offset))) {
700a9f10: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a9f14: 9a01         	ldr	r2, [sp, #0x4]
700a9f16: 6991         	ldr	r1, [r2, #0x18]
700a9f18: f89d 3000    	ldrb.w	r3, [sp]
700a9f1c: f831 1023    	ldrh.w	r1, [r1, r3, lsl #2]
700a9f20: 8912         	ldrh	r2, [r2, #0x8]
700a9f22: 1a89         	subs	r1, r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a9f24: 4288         	cmp	r0, r1
700a9f26: d10b         	bne	0x700a9f40 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x16
700a9f28: e7ff         	b	0x700a9f2a <Sciclient_rmIaEvtRomMapped+0x5a> @ imm = #-0x2
700a9f2a: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a9f2c: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a9f30: 9901         	ldr	r1, [sp, #0x4]
700a9f32: 6989         	ldr	r1, [r1, #0x18]
700a9f34: f89d 2000    	ldrb.w	r2, [sp]
700a9f38: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a9f3c: 7088         	strb	r0, [r1, #0x2]
;                 break;
700a9f3e: e006         	b	0x700a9f4e <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0xc
;         }
700a9f40: e7ff         	b	0x700a9f42 <Sciclient_rmIaEvtRomMapped+0x72> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a9f42: f89d 0000    	ldrb.w	r0, [sp]
700a9f46: 3001         	adds	r0, #0x1
700a9f48: f88d 0000    	strb.w	r0, [sp]
700a9f4c: e7cf         	b	0x700a9eee <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x62
;     }
700a9f4e: e7ff         	b	0x700a9f50 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #-0x2
;     return rom_mapped;
700a9f50: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a9f54: f000 0001    	and	r0, r0, #0x1
700a9f58: b002         	add	sp, #0x8
700a9f5a: 4770         	bx	lr
700a9f5c: 0000         	movs	r0, r0
700a9f5e: 0000         	movs	r0, r0

700a9f60 <UART_writeCancelNoCB>:
; {
700a9f60: b580         	push	{r7, lr}
700a9f62: b084         	sub	sp, #0x10
700a9f64: 9003         	str	r0, [sp, #0xc]
700a9f66: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a9f68: 9001         	str	r0, [sp, #0x4]
;     hUartInit = hUart->hUartInit;
700a9f6a: 9803         	ldr	r0, [sp, #0xc]
700a9f6c: 6840         	ldr	r0, [r0, #0x4]
700a9f6e: 9000         	str	r0, [sp]
;     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700a9f70: 9803         	ldr	r0, [sp, #0xc]
700a9f72: 6800         	ldr	r0, [r0]
700a9f74: 2102         	movs	r1, #0x2
700a9f76: f7fc f913    	bl	0x700a61a0 <UART_intrDisable> @ imm = #-0x3dda
;     key = HwiP_disable();
700a9f7a: f006 ecd2    	blx	0x700b0920 <HwiP_disable> @ imm = #0x69a4
700a9f7e: 9002         	str	r0, [sp, #0x8]
;     if ((hUart->writeSizeRemaining) == 0U)
700a9f80: 9803         	ldr	r0, [sp, #0xc]
700a9f82: 6900         	ldr	r0, [r0, #0x10]
700a9f84: b920         	cbnz	r0, 0x700a9f90 <UART_writeCancelNoCB+0x30> @ imm = #0x8
700a9f86: e7ff         	b	0x700a9f88 <UART_writeCancelNoCB+0x28> @ imm = #-0x2
700a9f88: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700a9f8c: 9001         	str	r0, [sp, #0x4]
;     }
700a9f8e: e027         	b	0x700a9fe0 <UART_writeCancelNoCB+0x80> @ imm = #0x4e
;         if (hUartInit->transferMode == UART_CONFIG_MODE_DMA)
700a9f90: 9800         	ldr	r0, [sp]
700a9f92: 6a00         	ldr	r0, [r0, #0x20]
700a9f94: 2803         	cmp	r0, #0x3
700a9f96: d111         	bne	0x700a9fbc <UART_writeCancelNoCB+0x5c> @ imm = #0x22
700a9f98: e7ff         	b	0x700a9f9a <UART_writeCancelNoCB+0x3a> @ imm = #-0x2
;             UART_lld_dmaDisableChannel(hUart, (Bool)TRUE);
700a9f9a: 9803         	ldr	r0, [sp, #0xc]
700a9f9c: 2101         	movs	r1, #0x1
700a9f9e: f7ff fc4f    	bl	0x700a9840 <UART_lld_dmaDisableChannel> @ imm = #-0x762
;             if (hUart->writeTrans.buf != NULL)
700a9fa2: 9803         	ldr	r0, [sp, #0xc]
700a9fa4: 6bc0         	ldr	r0, [r0, #0x3c]
700a9fa6: b120         	cbz	r0, 0x700a9fb2 <UART_writeCancelNoCB+0x52> @ imm = #0x8
700a9fa8: e7ff         	b	0x700a9faa <UART_writeCancelNoCB+0x4a> @ imm = #-0x2
;                 hUart->writeTrans.count = 0;
700a9faa: 9903         	ldr	r1, [sp, #0xc]
700a9fac: 2000         	movs	r0, #0x0
700a9fae: 6408         	str	r0, [r1, #0x40]
;             }
700a9fb0: e003         	b	0x700a9fba <UART_writeCancelNoCB+0x5a> @ imm = #0x6
;                 hUart->writeCount = 0;
700a9fb2: 9903         	ldr	r1, [sp, #0xc]
700a9fb4: 2000         	movs	r0, #0x0
700a9fb6: 60c8         	str	r0, [r1, #0xc]
700a9fb8: e7ff         	b	0x700a9fba <UART_writeCancelNoCB+0x5a> @ imm = #-0x2
;         }
700a9fba: e010         	b	0x700a9fde <UART_writeCancelNoCB+0x7e> @ imm = #0x20
;             hUart->writeBuf = (const uint8_t *)hUart->writeBuf - hUart->writeCount;
700a9fbc: 9903         	ldr	r1, [sp, #0xc]
700a9fbe: 6888         	ldr	r0, [r1, #0x8]
700a9fc0: 68ca         	ldr	r2, [r1, #0xc]
700a9fc2: 1a80         	subs	r0, r0, r2
700a9fc4: 6088         	str	r0, [r1, #0x8]
;             if (hUart->writeTrans.buf != NULL)
700a9fc6: 9803         	ldr	r0, [sp, #0xc]
700a9fc8: 6bc0         	ldr	r0, [r0, #0x3c]
700a9fca: b120         	cbz	r0, 0x700a9fd6 <UART_writeCancelNoCB+0x76> @ imm = #0x8
700a9fcc: e7ff         	b	0x700a9fce <UART_writeCancelNoCB+0x6e> @ imm = #-0x2
;                 hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
700a9fce: 9903         	ldr	r1, [sp, #0xc]
700a9fd0: 68c8         	ldr	r0, [r1, #0xc]
700a9fd2: 6408         	str	r0, [r1, #0x40]
;             }
700a9fd4: e7ff         	b	0x700a9fd6 <UART_writeCancelNoCB+0x76> @ imm = #-0x2
;             hUart->writeSizeRemaining = 0;
700a9fd6: 9903         	ldr	r1, [sp, #0xc]
700a9fd8: 2000         	movs	r0, #0x0
700a9fda: 6108         	str	r0, [r1, #0x10]
700a9fdc: e7ff         	b	0x700a9fde <UART_writeCancelNoCB+0x7e> @ imm = #-0x2
700a9fde: e7ff         	b	0x700a9fe0 <UART_writeCancelNoCB+0x80> @ imm = #-0x2
;     HwiP_restore(key);
700a9fe0: 9802         	ldr	r0, [sp, #0x8]
700a9fe2: f006 ecbe    	blx	0x700b0960 <HwiP_restore> @ imm = #0x697c
;     return (status);
700a9fe6: 9801         	ldr	r0, [sp, #0x4]
700a9fe8: b004         	add	sp, #0x10
700a9fea: bd80         	pop	{r7, pc}
700a9fec: 0000         	movs	r0, r0
700a9fee: 0000         	movs	r0, r0

700a9ff0 <Udma_ringFlushRaw>:
; {
700a9ff0: b580         	push	{r7, lr}
700a9ff2: b086         	sub	sp, #0x18
700a9ff4: 9005         	str	r0, [sp, #0x14]
700a9ff6: 9104         	str	r1, [sp, #0x10]
700a9ff8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a9ffa: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a9ffc: 9805         	ldr	r0, [sp, #0x14]
700a9ffe: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == ringHandleInt) ||
700aa000: 9801         	ldr	r0, [sp, #0x4]
700aa002: b180         	cbz	r0, 0x700aa026 <Udma_ringFlushRaw+0x36> @ imm = #0x20
700aa004: e7ff         	b	0x700aa006 <Udma_ringFlushRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700aa006: 9801         	ldr	r0, [sp, #0x4]
700aa008: 6d80         	ldr	r0, [r0, #0x58]
700aa00a: f64a 31cd    	movw	r1, #0xabcd
700aa00e: f6ca 31dc    	movt	r1, #0xabdc
700aa012: 4288         	cmp	r0, r1
700aa014: d107         	bne	0x700aa026 <Udma_ringFlushRaw+0x36> @ imm = #0xe
700aa016: e7ff         	b	0x700aa018 <Udma_ringFlushRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700aa018: 9801         	ldr	r0, [sp, #0x4]
700aa01a: 8880         	ldrh	r0, [r0, #0x4]
700aa01c: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700aa020: 4288         	cmp	r0, r1
700aa022: d104         	bne	0x700aa02e <Udma_ringFlushRaw+0x3e> @ imm = #0x8
700aa024: e7ff         	b	0x700aa026 <Udma_ringFlushRaw+0x36> @ imm = #-0x2
700aa026: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700aa02a: 9003         	str	r0, [sp, #0xc]
;     }
700aa02c: e7ff         	b	0x700aa02e <Udma_ringFlushRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aa02e: 9803         	ldr	r0, [sp, #0xc]
700aa030: b9a8         	cbnz	r0, 0x700aa05e <Udma_ringFlushRaw+0x6e> @ imm = #0x2a
700aa032: e7ff         	b	0x700aa034 <Udma_ringFlushRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700aa034: 9801         	ldr	r0, [sp, #0x4]
700aa036: 6800         	ldr	r0, [r0]
700aa038: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) ||
700aa03a: 9802         	ldr	r0, [sp, #0x8]
700aa03c: b150         	cbz	r0, 0x700aa054 <Udma_ringFlushRaw+0x64> @ imm = #0x14
700aa03e: e7ff         	b	0x700aa040 <Udma_ringFlushRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700aa040: 9802         	ldr	r0, [sp, #0x8]
700aa042: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700aa046: f64a 31cd    	movw	r1, #0xabcd
700aa04a: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700aa04e: 4288         	cmp	r0, r1
700aa050: d004         	beq	0x700aa05c <Udma_ringFlushRaw+0x6c> @ imm = #0x8
700aa052: e7ff         	b	0x700aa054 <Udma_ringFlushRaw+0x64> @ imm = #-0x2
700aa054: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700aa058: 9003         	str	r0, [sp, #0xc]
;         }
700aa05a: e7ff         	b	0x700aa05c <Udma_ringFlushRaw+0x6c> @ imm = #-0x2
;     }
700aa05c: e7ff         	b	0x700aa05e <Udma_ringFlushRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aa05e: 9803         	ldr	r0, [sp, #0xc]
700aa060: b940         	cbnz	r0, 0x700aa074 <Udma_ringFlushRaw+0x84> @ imm = #0x10
700aa062: e7ff         	b	0x700aa064 <Udma_ringFlushRaw+0x74> @ imm = #-0x2
;         retVal = drvHandle->ringFlushRaw(drvHandle, ringHandleInt, phyDescMem);
700aa064: 9802         	ldr	r0, [sp, #0x8]
700aa066: f8d0 3598    	ldr.w	r3, [r0, #0x598]
700aa06a: 9901         	ldr	r1, [sp, #0x4]
700aa06c: 9a04         	ldr	r2, [sp, #0x10]
700aa06e: 4798         	blx	r3
700aa070: 9003         	str	r0, [sp, #0xc]
;     }
700aa072: e7ff         	b	0x700aa074 <Udma_ringFlushRaw+0x84> @ imm = #-0x2
;     return (retVal);
700aa074: 9803         	ldr	r0, [sp, #0xc]
700aa076: b006         	add	sp, #0x18
700aa078: bd80         	pop	{r7, pc}
700aa07a: 0000         	movs	r0, r0
700aa07c: 0000         	movs	r0, r0
700aa07e: 0000         	movs	r0, r0

700aa080 <xQueueGenericReset>:
; {
700aa080: b580         	push	{r7, lr}
700aa082: b084         	sub	sp, #0x10
700aa084: 9003         	str	r0, [sp, #0xc]
700aa086: 9102         	str	r1, [sp, #0x8]
;     Queue_t * const pxQueue = xQueue;
700aa088: 9803         	ldr	r0, [sp, #0xc]
700aa08a: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700aa08c: f004 fb18    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x4630
;         pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700aa090: 9901         	ldr	r1, [sp, #0x4]
700aa092: 680b         	ldr	r3, [r1]
700aa094: 6bc8         	ldr	r0, [r1, #0x3c]
700aa096: 6c0a         	ldr	r2, [r1, #0x40]
700aa098: fb00 3002    	mla	r0, r0, r2, r3
700aa09c: 6088         	str	r0, [r1, #0x8]
;         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
700aa09e: 9901         	ldr	r1, [sp, #0x4]
700aa0a0: 2000         	movs	r0, #0x0
700aa0a2: 6388         	str	r0, [r1, #0x38]
;         pxQueue->pcWriteTo = pxQueue->pcHead;
700aa0a4: 9901         	ldr	r1, [sp, #0x4]
700aa0a6: 6808         	ldr	r0, [r1]
700aa0a8: 6048         	str	r0, [r1, #0x4]
;         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700aa0aa: 9901         	ldr	r1, [sp, #0x4]
700aa0ac: 680b         	ldr	r3, [r1]
700aa0ae: 6bc8         	ldr	r0, [r1, #0x3c]
700aa0b0: 6c0a         	ldr	r2, [r1, #0x40]
700aa0b2: 3801         	subs	r0, #0x1
700aa0b4: fb00 3002    	mla	r0, r0, r2, r3
700aa0b8: 60c8         	str	r0, [r1, #0xc]
;         pxQueue->cRxLock = queueUNLOCKED;
700aa0ba: 9901         	ldr	r1, [sp, #0x4]
700aa0bc: 20ff         	movs	r0, #0xff
700aa0be: f881 0044    	strb.w	r0, [r1, #0x44]
;         pxQueue->cTxLock = queueUNLOCKED;
700aa0c2: 9901         	ldr	r1, [sp, #0x4]
700aa0c4: f881 0045    	strb.w	r0, [r1, #0x45]
;         if( xNewQueue == pdFALSE )
700aa0c8: 9802         	ldr	r0, [sp, #0x8]
700aa0ca: b980         	cbnz	r0, 0x700aa0ee <xQueueGenericReset+0x6e> @ imm = #0x20
700aa0cc: e7ff         	b	0x700aa0ce <xQueueGenericReset+0x4e> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700aa0ce: 9801         	ldr	r0, [sp, #0x4]
700aa0d0: 6900         	ldr	r0, [r0, #0x10]
700aa0d2: b150         	cbz	r0, 0x700aa0ea <xQueueGenericReset+0x6a> @ imm = #0x14
700aa0d4: e7ff         	b	0x700aa0d6 <xQueueGenericReset+0x56> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700aa0d6: 9801         	ldr	r0, [sp, #0x4]
700aa0d8: 3010         	adds	r0, #0x10
700aa0da: f7fd fc39    	bl	0x700a7950 <xTaskRemoveFromEventList> @ imm = #-0x278e
700aa0de: b110         	cbz	r0, 0x700aa0e6 <xQueueGenericReset+0x66> @ imm = #0x4
700aa0e0: e7ff         	b	0x700aa0e2 <xQueueGenericReset+0x62> @ imm = #-0x2
;                     queueYIELD_IF_USING_PREEMPTION();
700aa0e2: df00         	svc	#0x0
;                 }
700aa0e4: e000         	b	0x700aa0e8 <xQueueGenericReset+0x68> @ imm = #0x0
700aa0e6: e7ff         	b	0x700aa0e8 <xQueueGenericReset+0x68> @ imm = #-0x2
;             }
700aa0e8: e000         	b	0x700aa0ec <xQueueGenericReset+0x6c> @ imm = #0x0
700aa0ea: e7ff         	b	0x700aa0ec <xQueueGenericReset+0x6c> @ imm = #-0x2
;         }
700aa0ec: e008         	b	0x700aa100 <xQueueGenericReset+0x80> @ imm = #0x10
;             vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
700aa0ee: 9801         	ldr	r0, [sp, #0x4]
700aa0f0: 3010         	adds	r0, #0x10
700aa0f2: f004 fc75    	bl	0x700ae9e0 <vListInitialise> @ imm = #0x48ea
;             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
700aa0f6: 9801         	ldr	r0, [sp, #0x4]
700aa0f8: 3024         	adds	r0, #0x24
700aa0fa: f004 fc71    	bl	0x700ae9e0 <vListInitialise> @ imm = #0x48e2
700aa0fe: e7ff         	b	0x700aa100 <xQueueGenericReset+0x80> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700aa100: f003 fb7e    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x36fc
700aa104: 2001         	movs	r0, #0x1
;     return pdPASS;
700aa106: b004         	add	sp, #0x10
700aa108: bd80         	pop	{r7, pc}
700aa10a: 0000         	movs	r0, r0
700aa10c: 0000         	movs	r0, r0
700aa10e: 0000         	movs	r0, r0

700aa110 <CSL_bcdmaGetCfg>:
; {
700aa110: b580         	push	{r7, lr}
700aa112: b082         	sub	sp, #0x8
700aa114: 9001         	str	r0, [sp, #0x4]
;     if( ! ((pCfg == NULL) || (pCfg->pGenCfgRegs == NULL)) )
700aa116: 9801         	ldr	r0, [sp, #0x4]
700aa118: b3e0         	cbz	r0, 0x700aa194 <CSL_bcdmaGetCfg+0x84> @ imm = #0x78
700aa11a: e7ff         	b	0x700aa11c <CSL_bcdmaGetCfg+0xc> @ imm = #-0x2
700aa11c: 9801         	ldr	r0, [sp, #0x4]
700aa11e: 6800         	ldr	r0, [r0]
700aa120: b3c0         	cbz	r0, 0x700aa194 <CSL_bcdmaGetCfg+0x84> @ imm = #0x70
700aa122: e7ff         	b	0x700aa124 <CSL_bcdmaGetCfg+0x14> @ imm = #-0x2
;         pCfg->cap0 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP0 );
700aa124: 9801         	ldr	r0, [sp, #0x4]
700aa126: 6800         	ldr	r0, [r0]
700aa128: 3020         	adds	r0, #0x20
700aa12a: f005 fd49    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0x5a92
700aa12e: 9901         	ldr	r1, [sp, #0x4]
700aa130: 61c8         	str	r0, [r1, #0x1c]
;         pCfg->cap1 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP1 );
700aa132: 9801         	ldr	r0, [sp, #0x4]
700aa134: 6800         	ldr	r0, [r0]
700aa136: 3024         	adds	r0, #0x24
700aa138: f005 fd42    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0x5a84
700aa13c: 9901         	ldr	r1, [sp, #0x4]
700aa13e: 6208         	str	r0, [r1, #0x20]
;         regVal = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP2 );
700aa140: 9801         	ldr	r0, [sp, #0x4]
700aa142: 6800         	ldr	r0, [r0]
700aa144: 3028         	adds	r0, #0x28
700aa146: f005 fd3b    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0x5a76
700aa14a: 9000         	str	r0, [sp]
;         pCfg->bcChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_CHAN_CNT );
700aa14c: 9800         	ldr	r0, [sp]
700aa14e: f36f 205f    	bfc	r0, #9, #23
700aa152: 9901         	ldr	r1, [sp, #0x4]
700aa154: 6248         	str	r0, [r1, #0x24]
;         pCfg->splitTxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_TCHAN_CNT );
700aa156: 9800         	ldr	r0, [sp]
700aa158: f3c0 2048    	ubfx	r0, r0, #0x9, #0x9
700aa15c: 9901         	ldr	r1, [sp, #0x4]
700aa15e: 62c8         	str	r0, [r1, #0x2c]
;         pCfg->splitRxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_RCHAN_CNT );
700aa160: 9800         	ldr	r0, [sp]
700aa162: f3c0 4088    	ubfx	r0, r0, #0x12, #0x9
700aa166: 9901         	ldr	r1, [sp, #0x4]
700aa168: 6288         	str	r0, [r1, #0x28]
;         pCfg->flowCnt = (uint32_t)0U;
700aa16a: 9901         	ldr	r1, [sp, #0x4]
700aa16c: 2000         	movs	r0, #0x0
700aa16e: 6308         	str	r0, [r1, #0x30]
;         pCfg->txChanCnt                     = pCfg->bcChanCnt + pCfg->splitTxChanCnt;
700aa170: 9a01         	ldr	r2, [sp, #0x4]
700aa172: 6a51         	ldr	r1, [r2, #0x24]
700aa174: 6ad3         	ldr	r3, [r2, #0x2c]
700aa176: 4419         	add	r1, r3
700aa178: 6351         	str	r1, [r2, #0x34]
;         pCfg->rxChanCnt                     = pCfg->splitRxChanCnt;
700aa17a: 9a01         	ldr	r2, [sp, #0x4]
700aa17c: 6a91         	ldr	r1, [r2, #0x28]
700aa17e: 6391         	str	r1, [r2, #0x38]
;         pCfg->rxFlowCnt                     = pCfg->flowCnt;
700aa180: 9a01         	ldr	r2, [sp, #0x4]
700aa182: 6b11         	ldr	r1, [r2, #0x30]
700aa184: 63d1         	str	r1, [r2, #0x3c]
;         pCfg->txExtUtcChanCnt               = (uint32_t)0U;
700aa186: 9901         	ldr	r1, [sp, #0x4]
700aa188: 6408         	str	r0, [r1, #0x40]
;         pCfg->txHighCapacityChanCnt         = (uint32_t)0U;
700aa18a: 9901         	ldr	r1, [sp, #0x4]
700aa18c: 6448         	str	r0, [r1, #0x44]
;         pCfg->txUltraHighCapacityChanCnt    = (uint32_t)0U;
700aa18e: 9901         	ldr	r1, [sp, #0x4]
700aa190: 6488         	str	r0, [r1, #0x48]
;     }
700aa192: e7ff         	b	0x700aa194 <CSL_bcdmaGetCfg+0x84> @ imm = #-0x2
; }
700aa194: b002         	add	sp, #0x8
700aa196: bd80         	pop	{r7, pc}
		...

700aa1a0 <Udma_rmFreeVintrBit>:
; {
700aa1a0: b580         	push	{r7, lr}
700aa1a2: b088         	sub	sp, #0x20
700aa1a4: 9007         	str	r0, [sp, #0x1c]
700aa1a6: 9106         	str	r1, [sp, #0x18]
700aa1a8: 9205         	str	r2, [sp, #0x14]
;     controllerEventHandle = eventHandle;
700aa1aa: 9805         	ldr	r0, [sp, #0x14]
700aa1ac: 9001         	str	r0, [sp, #0x4]
;     eventPrms = &eventHandle->eventPrms;
700aa1ae: 9805         	ldr	r0, [sp, #0x14]
700aa1b0: 3008         	adds	r0, #0x8
700aa1b2: 9000         	str	r0, [sp]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700aa1b4: 9800         	ldr	r0, [sp]
700aa1b6: 6900         	ldr	r0, [r0, #0x10]
700aa1b8: b120         	cbz	r0, 0x700aa1c4 <Udma_rmFreeVintrBit+0x24> @ imm = #0x8
700aa1ba: e7ff         	b	0x700aa1bc <Udma_rmFreeVintrBit+0x1c> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700aa1bc: 9800         	ldr	r0, [sp]
700aa1be: 6900         	ldr	r0, [r0, #0x10]
700aa1c0: 9001         	str	r0, [sp, #0x4]
;     }
700aa1c2: e7ff         	b	0x700aa1c4 <Udma_rmFreeVintrBit+0x24> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa1c4: 9806         	ldr	r0, [sp, #0x18]
700aa1c6: f500 609f    	add.w	r0, r0, #0x4f8
700aa1ca: f04f 31ff    	mov.w	r1, #0xffffffff
700aa1ce: f000 fa27    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #0x44e
;     bitMask = ((uint64_t) 1U << vintrBitNum);
700aa1d2: 9b07         	ldr	r3, [sp, #0x1c]
700aa1d4: f1a3 0220    	sub.w	r2, r3, #0x20
700aa1d8: 2101         	movs	r1, #0x1
700aa1da: fa01 fc02    	lsl.w	r12, r1, r2
700aa1de: f1c3 0020    	rsb.w	r0, r3, #0x20
700aa1e2: fa21 f000    	lsr.w	r0, r1, r0
700aa1e6: 2a00         	cmp	r2, #0x0
700aa1e8: bf58         	it	pl
700aa1ea: 4660         	movpl	r0, r12
700aa1ec: fa01 f103    	lsl.w	r1, r1, r3
700aa1f0: 2a00         	cmp	r2, #0x0
700aa1f2: bf58         	it	pl
700aa1f4: 2100         	movpl	r1, #0x0
700aa1f6: 9102         	str	r1, [sp, #0x8]
700aa1f8: 9003         	str	r0, [sp, #0xc]
;     controllerEventHandle->vintrBitAllocFlag &= ~bitMask;
700aa1fa: f8dd c008    	ldr.w	r12, [sp, #0x8]
700aa1fe: 9b03         	ldr	r3, [sp, #0xc]
700aa200: 9901         	ldr	r1, [sp, #0x4]
700aa202: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700aa206: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700aa20a: ea20 000c    	bic.w	r0, r0, r12
700aa20e: ea22 0203    	bic.w	r2, r2, r3
700aa212: f8c1 208c    	str.w	r2, [r1, #0x8c]
700aa216: f8c1 0088    	str.w	r0, [r1, #0x88]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa21a: 9806         	ldr	r0, [sp, #0x18]
700aa21c: f500 609f    	add.w	r0, r0, #0x4f8
700aa220: f001 fdc6    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x1b8c
;     return;
700aa224: b008         	add	sp, #0x20
700aa226: bd80         	pop	{r7, pc}
		...

700aa230 <SOC_controlModuleLockMMR>:
; {
700aa230: b580         	push	{r7, lr}
700aa232: b086         	sub	sp, #0x18
700aa234: 9005         	str	r0, [sp, #0x14]
700aa236: 9104         	str	r1, [sp, #0x10]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700aa238: 9805         	ldr	r0, [sp, #0x14]
700aa23a: b9d8         	cbnz	r0, 0x700aa274 <SOC_controlModuleLockMMR+0x44> @ imm = #0x36
700aa23c: e7ff         	b	0x700aa23e <SOC_controlModuleLockMMR+0xe> @ imm = #-0x2
700aa23e: f04f 4086    	mov.w	r0, #0x43000000
700aa242: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700aa244: 9101         	str	r1, [sp, #0x4]
700aa246: f7fb fc0b    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x47ea
700aa24a: 9901         	ldr	r1, [sp, #0x4]
700aa24c: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700aa24e: 9803         	ldr	r0, [sp, #0xc]
700aa250: 9a04         	ldr	r2, [sp, #0x10]
700aa252: eb00 3082    	add.w	r0, r0, r2, lsl #14
700aa256: f241 0208    	movw	r2, #0x1008
700aa25a: 4410         	add	r0, r2
700aa25c: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700aa25e: 9802         	ldr	r0, [sp, #0x8]
700aa260: f005 fc2e    	bl	0x700afac0 <CSL_REG32_WR_RAW> @ imm = #0x585c
700aa264: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr++;
700aa266: 9802         	ldr	r0, [sp, #0x8]
700aa268: 3004         	adds	r0, #0x4
700aa26a: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700aa26c: 9802         	ldr	r0, [sp, #0x8]
700aa26e: f005 fc27    	bl	0x700afac0 <CSL_REG32_WR_RAW> @ imm = #0x584e
;     }
700aa272: e7ff         	b	0x700aa274 <SOC_controlModuleLockMMR+0x44> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700aa274: 9805         	ldr	r0, [sp, #0x14]
700aa276: 2801         	cmp	r0, #0x1
700aa278: d11b         	bne	0x700aa2b2 <SOC_controlModuleLockMMR+0x82> @ imm = #0x36
700aa27a: e7ff         	b	0x700aa27c <SOC_controlModuleLockMMR+0x4c> @ imm = #-0x2
700aa27c: f04f 608a    	mov.w	r0, #0x4500000
700aa280: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700aa282: 9100         	str	r1, [sp]
700aa284: f7fb fbec    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x4828
700aa288: 9900         	ldr	r1, [sp]
700aa28a: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700aa28c: 9803         	ldr	r0, [sp, #0xc]
700aa28e: 9a04         	ldr	r2, [sp, #0x10]
700aa290: eb00 3082    	add.w	r0, r0, r2, lsl #14
700aa294: f241 0208    	movw	r2, #0x1008
700aa298: 4410         	add	r0, r2
700aa29a: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700aa29c: 9802         	ldr	r0, [sp, #0x8]
700aa29e: f005 fc0f    	bl	0x700afac0 <CSL_REG32_WR_RAW> @ imm = #0x581e
700aa2a2: 9900         	ldr	r1, [sp]
;         kickAddr++;
700aa2a4: 9802         	ldr	r0, [sp, #0x8]
700aa2a6: 3004         	adds	r0, #0x4
700aa2a8: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700aa2aa: 9802         	ldr	r0, [sp, #0x8]
700aa2ac: f005 fc08    	bl	0x700afac0 <CSL_REG32_WR_RAW> @ imm = #0x5810
;     }
700aa2b0: e7ff         	b	0x700aa2b2 <SOC_controlModuleLockMMR+0x82> @ imm = #-0x2
;     return;
700aa2b2: b006         	add	sp, #0x18
700aa2b4: bd80         	pop	{r7, pc}
		...
700aa2be: 0000         	movs	r0, r0

700aa2c0 <UART_lld_flushTxFifo>:
; {
700aa2c0: b580         	push	{r7, lr}
700aa2c2: b088         	sub	sp, #0x20
700aa2c4: 9007         	str	r0, [sp, #0x1c]
700aa2c6: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700aa2c8: 9006         	str	r0, [sp, #0x18]
700aa2ca: f640 31b8    	movw	r1, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700aa2ce: 9102         	str	r1, [sp, #0x8]
;     uint32_t            timeoutElapsed  = FALSE;
700aa2d0: 9001         	str	r0, [sp, #0x4]
;     if (NULL_PTR != hUart)
700aa2d2: 9807         	ldr	r0, [sp, #0x1c]
700aa2d4: b380         	cbz	r0, 0x700aa338 <UART_lld_flushTxFifo+0x78> @ imm = #0x60
700aa2d6: e7ff         	b	0x700aa2d8 <UART_lld_flushTxFifo+0x18> @ imm = #-0x2
;         hUartInit = hUart->hUartInit;
700aa2d8: 9807         	ldr	r0, [sp, #0x1c]
700aa2da: 6840         	ldr	r0, [r0, #0x4]
700aa2dc: 9000         	str	r0, [sp]
;         startTicks = hUartInit->clockP_get();
700aa2de: 9800         	ldr	r0, [sp]
700aa2e0: 6d40         	ldr	r0, [r0, #0x54]
700aa2e2: 4780         	blx	r0
700aa2e4: 9004         	str	r0, [sp, #0x10]
;         while (FALSE == timeoutElapsed)
700aa2e6: e7ff         	b	0x700aa2e8 <UART_lld_flushTxFifo+0x28> @ imm = #-0x2
700aa2e8: 9801         	ldr	r0, [sp, #0x4]
700aa2ea: b9e0         	cbnz	r0, 0x700aa326 <UART_lld_flushTxFifo+0x66> @ imm = #0x38
700aa2ec: e7ff         	b	0x700aa2ee <UART_lld_flushTxFifo+0x2e> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(hUart->baseAddr);
700aa2ee: 9807         	ldr	r0, [sp, #0x1c]
700aa2f0: 6800         	ldr	r0, [r0]
700aa2f2: f003 fd6d    	bl	0x700addd0 <UART_spaceAvail> @ imm = #0x3ada
700aa2f6: 9005         	str	r0, [sp, #0x14]
;             if ((uint32_t) TRUE == isTxFifoEmpty)
700aa2f8: 9805         	ldr	r0, [sp, #0x14]
700aa2fa: 2801         	cmp	r0, #0x1
700aa2fc: d101         	bne	0x700aa302 <UART_lld_flushTxFifo+0x42> @ imm = #0x2
700aa2fe: e7ff         	b	0x700aa300 <UART_lld_flushTxFifo+0x40> @ imm = #-0x2
;                 break;
700aa300: e011         	b	0x700aa326 <UART_lld_flushTxFifo+0x66> @ imm = #0x22
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700aa302: 9800         	ldr	r0, [sp]
700aa304: 6d40         	ldr	r0, [r0, #0x54]
700aa306: 4780         	blx	r0
700aa308: 9904         	ldr	r1, [sp, #0x10]
700aa30a: 1a40         	subs	r0, r0, r1
700aa30c: 9003         	str	r0, [sp, #0xc]
;             if (elapsedTicks >= timeout)
700aa30e: 9803         	ldr	r0, [sp, #0xc]
700aa310: 9902         	ldr	r1, [sp, #0x8]
700aa312: 4288         	cmp	r0, r1
700aa314: d303         	blo	0x700aa31e <UART_lld_flushTxFifo+0x5e> @ imm = #0x6
700aa316: e7ff         	b	0x700aa318 <UART_lld_flushTxFifo+0x58> @ imm = #-0x2
700aa318: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700aa31a: 9001         	str	r0, [sp, #0x4]
;             }
700aa31c: e002         	b	0x700aa324 <UART_lld_flushTxFifo+0x64> @ imm = #0x4
;                 TaskP_yield();
700aa31e: f005 fcef    	bl	0x700afd00 <TaskP_yield> @ imm = #0x59de
700aa322: e7ff         	b	0x700aa324 <UART_lld_flushTxFifo+0x64> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700aa324: e7e0         	b	0x700aa2e8 <UART_lld_flushTxFifo+0x28> @ imm = #-0x40
;         if(TRUE == timeoutElapsed)
700aa326: 9801         	ldr	r0, [sp, #0x4]
700aa328: 2801         	cmp	r0, #0x1
700aa32a: d104         	bne	0x700aa336 <UART_lld_flushTxFifo+0x76> @ imm = #0x8
700aa32c: e7ff         	b	0x700aa32e <UART_lld_flushTxFifo+0x6e> @ imm = #-0x2
700aa32e: f06f 0001    	mvn	r0, #0x1
;             status = UART_TRANSFER_TIMEOUT;
700aa332: 9006         	str	r0, [sp, #0x18]
;         }
700aa334: e7ff         	b	0x700aa336 <UART_lld_flushTxFifo+0x76> @ imm = #-0x2
;     }
700aa336: e003         	b	0x700aa340 <UART_lld_flushTxFifo+0x80> @ imm = #0x6
700aa338: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700aa33c: 9006         	str	r0, [sp, #0x18]
700aa33e: e7ff         	b	0x700aa340 <UART_lld_flushTxFifo+0x80> @ imm = #-0x2
;     return status;
700aa340: 9806         	ldr	r0, [sp, #0x18]
700aa342: b008         	add	sp, #0x20
700aa344: bd80         	pop	{r7, pc}
		...
700aa34e: 0000         	movs	r0, r0

700aa350 <UART_tcrTlrBitValRestore>:
; {
700aa350: b580         	push	{r7, lr}
700aa352: b088         	sub	sp, #0x20
700aa354: 9007         	str	r0, [sp, #0x1c]
700aa356: 9106         	str	r1, [sp, #0x18]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700aa358: 9807         	ldr	r0, [sp, #0x1c]
700aa35a: 21bf         	movs	r1, #0xbf
700aa35c: 9101         	str	r1, [sp, #0x4]
700aa35e: f002 f96f    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x22de
700aa362: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700aa364: 9807         	ldr	r0, [sp, #0x1c]
700aa366: 3008         	adds	r0, #0x8
700aa368: 2110         	movs	r1, #0x10
700aa36a: 9102         	str	r1, [sp, #0x8]
700aa36c: 2204         	movs	r2, #0x4
700aa36e: 9203         	str	r2, [sp, #0xc]
700aa370: f004 ffa6    	bl	0x700af2c0 <HW_RD_FIELD32_RAW> @ imm = #0x4f4c
700aa374: 9902         	ldr	r1, [sp, #0x8]
700aa376: 9a03         	ldr	r2, [sp, #0xc]
700aa378: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700aa37a: 9807         	ldr	r0, [sp, #0x1c]
700aa37c: 3008         	adds	r0, #0x8
700aa37e: 2301         	movs	r3, #0x1
700aa380: f004 f93e    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x427c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa384: 9807         	ldr	r0, [sp, #0x1c]
700aa386: 300c         	adds	r0, #0xc
700aa388: 9904         	ldr	r1, [sp, #0x10]
700aa38a: f005 fbd9    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x57b2
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700aa38e: 9807         	ldr	r0, [sp, #0x1c]
700aa390: 2180         	movs	r1, #0x80
700aa392: f002 f955    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x22aa
700aa396: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR, tcrTlrBitVal);
700aa398: 9807         	ldr	r0, [sp, #0x1c]
700aa39a: 3010         	adds	r0, #0x10
700aa39c: 9b06         	ldr	r3, [sp, #0x18]
700aa39e: 2140         	movs	r1, #0x40
700aa3a0: 2206         	movs	r2, #0x6
700aa3a2: f004 f92d    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x425a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa3a6: 9807         	ldr	r0, [sp, #0x1c]
700aa3a8: 300c         	adds	r0, #0xc
700aa3aa: 9904         	ldr	r1, [sp, #0x10]
700aa3ac: f005 fbc8    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x5790
700aa3b0: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700aa3b2: 9807         	ldr	r0, [sp, #0x1c]
700aa3b4: f002 f944    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0x2288
700aa3b8: 9902         	ldr	r1, [sp, #0x8]
700aa3ba: 9a03         	ldr	r2, [sp, #0xc]
700aa3bc: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700aa3be: 9807         	ldr	r0, [sp, #0x1c]
700aa3c0: 3008         	adds	r0, #0x8
700aa3c2: 9b05         	ldr	r3, [sp, #0x14]
700aa3c4: f004 f91c    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x4238
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa3c8: 9807         	ldr	r0, [sp, #0x1c]
700aa3ca: 300c         	adds	r0, #0xc
700aa3cc: 9904         	ldr	r1, [sp, #0x10]
700aa3ce: f005 fbb7    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x576e
; }
700aa3d2: b008         	add	sp, #0x20
700aa3d4: bd80         	pop	{r7, pc}
		...
700aa3de: 0000         	movs	r0, r0

700aa3e0 <prvInsertTimerInActiveList>:
;     {
700aa3e0: b580         	push	{r7, lr}
700aa3e2: b086         	sub	sp, #0x18
700aa3e4: 9005         	str	r0, [sp, #0x14]
700aa3e6: 9104         	str	r1, [sp, #0x10]
700aa3e8: 9203         	str	r2, [sp, #0xc]
700aa3ea: 9302         	str	r3, [sp, #0x8]
700aa3ec: 2000         	movs	r0, #0x0
;         BaseType_t xProcessTimerNow = pdFALSE;
700aa3ee: 9001         	str	r0, [sp, #0x4]
;         listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
700aa3f0: 9804         	ldr	r0, [sp, #0x10]
700aa3f2: 9905         	ldr	r1, [sp, #0x14]
700aa3f4: 6048         	str	r0, [r1, #0x4]
;         listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700aa3f6: 9805         	ldr	r0, [sp, #0x14]
700aa3f8: 6100         	str	r0, [r0, #0x10]
;         if( xNextExpiryTime <= xTimeNow )
700aa3fa: 9804         	ldr	r0, [sp, #0x10]
700aa3fc: 9903         	ldr	r1, [sp, #0xc]
700aa3fe: 4288         	cmp	r0, r1
700aa400: d816         	bhi	0x700aa430 <prvInsertTimerInActiveList+0x50> @ imm = #0x2c
700aa402: e7ff         	b	0x700aa404 <prvInsertTimerInActiveList+0x24> @ imm = #-0x2
;             if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
700aa404: 9803         	ldr	r0, [sp, #0xc]
700aa406: 9902         	ldr	r1, [sp, #0x8]
700aa408: 1a40         	subs	r0, r0, r1
700aa40a: 9905         	ldr	r1, [sp, #0x14]
700aa40c: 6989         	ldr	r1, [r1, #0x18]
700aa40e: 4288         	cmp	r0, r1
700aa410: d303         	blo	0x700aa41a <prvInsertTimerInActiveList+0x3a> @ imm = #0x6
700aa412: e7ff         	b	0x700aa414 <prvInsertTimerInActiveList+0x34> @ imm = #-0x2
700aa414: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700aa416: 9001         	str	r0, [sp, #0x4]
;             }
700aa418: e009         	b	0x700aa42e <prvInsertTimerInActiveList+0x4e> @ imm = #0x12
;                 vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
700aa41a: f245 1030    	movw	r0, #0x5130
700aa41e: f2c7 0008    	movt	r0, #0x7008
700aa422: 6800         	ldr	r0, [r0]
700aa424: 9905         	ldr	r1, [sp, #0x14]
700aa426: 3104         	adds	r1, #0x4
700aa428: f001 f942    	bl	0x700ab6b0 <vListInsert> @ imm = #0x1284
700aa42c: e7ff         	b	0x700aa42e <prvInsertTimerInActiveList+0x4e> @ imm = #-0x2
;         }
700aa42e: e017         	b	0x700aa460 <prvInsertTimerInActiveList+0x80> @ imm = #0x2e
;             if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
700aa430: 9803         	ldr	r0, [sp, #0xc]
700aa432: 9902         	ldr	r1, [sp, #0x8]
700aa434: 4288         	cmp	r0, r1
700aa436: d208         	bhs	0x700aa44a <prvInsertTimerInActiveList+0x6a> @ imm = #0x10
700aa438: e7ff         	b	0x700aa43a <prvInsertTimerInActiveList+0x5a> @ imm = #-0x2
700aa43a: 9804         	ldr	r0, [sp, #0x10]
700aa43c: 9902         	ldr	r1, [sp, #0x8]
700aa43e: 4288         	cmp	r0, r1
700aa440: d303         	blo	0x700aa44a <prvInsertTimerInActiveList+0x6a> @ imm = #0x6
700aa442: e7ff         	b	0x700aa444 <prvInsertTimerInActiveList+0x64> @ imm = #-0x2
700aa444: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700aa446: 9001         	str	r0, [sp, #0x4]
;             }
700aa448: e009         	b	0x700aa45e <prvInsertTimerInActiveList+0x7e> @ imm = #0x12
;                 vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700aa44a: f245 1024    	movw	r0, #0x5124
700aa44e: f2c7 0008    	movt	r0, #0x7008
700aa452: 6800         	ldr	r0, [r0]
700aa454: 9905         	ldr	r1, [sp, #0x14]
700aa456: 3104         	adds	r1, #0x4
700aa458: f001 f92a    	bl	0x700ab6b0 <vListInsert> @ imm = #0x1254
700aa45c: e7ff         	b	0x700aa45e <prvInsertTimerInActiveList+0x7e> @ imm = #-0x2
700aa45e: e7ff         	b	0x700aa460 <prvInsertTimerInActiveList+0x80> @ imm = #-0x2
;         return xProcessTimerNow;
700aa460: 9801         	ldr	r0, [sp, #0x4]
700aa462: b006         	add	sp, #0x18
700aa464: bd80         	pop	{r7, pc}
		...
700aa46e: 0000         	movs	r0, r0

700aa470 <prvProcessTimerOrBlockTask>:
;     {
700aa470: b580         	push	{r7, lr}
700aa472: b084         	sub	sp, #0x10
700aa474: 9003         	str	r0, [sp, #0xc]
700aa476: 9102         	str	r1, [sp, #0x8]
;         vTaskSuspendAll();
700aa478: f005 fb82    	bl	0x700afb80 <vTaskSuspendAll> @ imm = #0x5704
700aa47c: 4668         	mov	r0, sp
;             xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700aa47e: f003 fa37    	bl	0x700ad8f0 <prvSampleTimeNow> @ imm = #0x346e
700aa482: 9001         	str	r0, [sp, #0x4]
;             if( xTimerListsWereSwitched == pdFALSE )
700aa484: 9800         	ldr	r0, [sp]
700aa486: bb88         	cbnz	r0, 0x700aa4ec <prvProcessTimerOrBlockTask+0x7c> @ imm = #0x62
700aa488: e7ff         	b	0x700aa48a <prvProcessTimerOrBlockTask+0x1a> @ imm = #-0x2
;                 if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
700aa48a: 9802         	ldr	r0, [sp, #0x8]
700aa48c: b960         	cbnz	r0, 0x700aa4a8 <prvProcessTimerOrBlockTask+0x38> @ imm = #0x18
700aa48e: e7ff         	b	0x700aa490 <prvProcessTimerOrBlockTask+0x20> @ imm = #-0x2
700aa490: 9803         	ldr	r0, [sp, #0xc]
700aa492: 9901         	ldr	r1, [sp, #0x4]
700aa494: 4288         	cmp	r0, r1
700aa496: d807         	bhi	0x700aa4a8 <prvProcessTimerOrBlockTask+0x38> @ imm = #0xe
700aa498: e7ff         	b	0x700aa49a <prvProcessTimerOrBlockTask+0x2a> @ imm = #-0x2
;                     ( void ) xTaskResumeAll();
700aa49a: f7f7 fe21    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0x83be
;                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
700aa49e: 9803         	ldr	r0, [sp, #0xc]
700aa4a0: 9901         	ldr	r1, [sp, #0x4]
700aa4a2: f000 fe55    	bl	0x700ab150 <prvProcessExpiredTimer> @ imm = #0xcaa
;                 }
700aa4a6: e020         	b	0x700aa4ea <prvProcessTimerOrBlockTask+0x7a> @ imm = #0x40
;                     if( xListWasEmpty != pdFALSE )
700aa4a8: 9802         	ldr	r0, [sp, #0x8]
700aa4aa: b158         	cbz	r0, 0x700aa4c4 <prvProcessTimerOrBlockTask+0x54> @ imm = #0x16
700aa4ac: e7ff         	b	0x700aa4ae <prvProcessTimerOrBlockTask+0x3e> @ imm = #-0x2
;                         xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
700aa4ae: f245 1030    	movw	r0, #0x5130
700aa4b2: f2c7 0008    	movt	r0, #0x7008
700aa4b6: 6800         	ldr	r0, [r0]
700aa4b8: 6800         	ldr	r0, [r0]
700aa4ba: fab0 f080    	clz	r0, r0
700aa4be: 0940         	lsrs	r0, r0, #0x5
700aa4c0: 9002         	str	r0, [sp, #0x8]
;                     }
700aa4c2: e7ff         	b	0x700aa4c4 <prvProcessTimerOrBlockTask+0x54> @ imm = #-0x2
;                     vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
700aa4c4: f642 2048    	movw	r0, #0x2a48
700aa4c8: f2c7 000b    	movt	r0, #0x700b
700aa4cc: 6800         	ldr	r0, [r0]
700aa4ce: 9903         	ldr	r1, [sp, #0xc]
700aa4d0: 9a01         	ldr	r2, [sp, #0x4]
700aa4d2: 1a89         	subs	r1, r1, r2
700aa4d4: 9a02         	ldr	r2, [sp, #0x8]
700aa4d6: f001 fc33    	bl	0x700abd40 <vQueueWaitForMessageRestricted> @ imm = #0x1866
;                     if( xTaskResumeAll() == pdFALSE )
700aa4da: f7f7 fe01    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0x83fe
700aa4de: b910         	cbnz	r0, 0x700aa4e6 <prvProcessTimerOrBlockTask+0x76> @ imm = #0x4
700aa4e0: e7ff         	b	0x700aa4e2 <prvProcessTimerOrBlockTask+0x72> @ imm = #-0x2
;                         portYIELD_WITHIN_API();
700aa4e2: df00         	svc	#0x0
;                     }
700aa4e4: e000         	b	0x700aa4e8 <prvProcessTimerOrBlockTask+0x78> @ imm = #0x0
700aa4e6: e7ff         	b	0x700aa4e8 <prvProcessTimerOrBlockTask+0x78> @ imm = #-0x2
700aa4e8: e7ff         	b	0x700aa4ea <prvProcessTimerOrBlockTask+0x7a> @ imm = #-0x2
;             }
700aa4ea: e002         	b	0x700aa4f2 <prvProcessTimerOrBlockTask+0x82> @ imm = #0x4
;                 ( void ) xTaskResumeAll();
700aa4ec: f7f7 fdf8    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0x8410
700aa4f0: e7ff         	b	0x700aa4f2 <prvProcessTimerOrBlockTask+0x82> @ imm = #-0x2
;     }
700aa4f2: b004         	add	sp, #0x10
700aa4f4: bd80         	pop	{r7, pc}
		...
700aa4fe: 0000         	movs	r0, r0

700aa500 <PowerClock_init>:
; {
700aa500: b570         	push	{r4, r5, r6, lr}
700aa502: b082         	sub	sp, #0x8
;     while(gSocModules[i]!=SOC_MODULES_END)
700aa504: f642 1194    	movw	r1, #0x2994
700aa508: f2c7 010b    	movt	r1, #0x700b
700aa50c: 6808         	ldr	r0, [r1]
700aa50e: 1c42         	adds	r2, r0, #0x1
700aa510: d013         	beq	0x700aa53a <PowerClock_init+0x3a> @ imm = #0x26
700aa512: 1d0c         	adds	r4, r1, #0x4
700aa514: bf00         	nop
700aa516: bf00         	nop
700aa518: bf00         	nop
700aa51a: bf00         	nop
700aa51c: bf00         	nop
700aa51e: bf00         	nop
;         status = SOC_moduleClockEnable(gSocModules[i], 1);
700aa520: f04f 0101    	mov.w	r1, #0x1
700aa524: f7ff fa7c    	bl	0x700a9a20 <SOC_moduleClockEnable> @ imm = #-0xb08
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700aa528: fab0 f080    	clz	r0, r0
700aa52c: 0940         	lsrs	r0, r0, #0x5
700aa52e: f006 feb7    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x6d6e
;     while(gSocModules[i]!=SOC_MODULES_END)
700aa532: f854 0b04    	ldr	r0, [r4], #4
700aa536: 1c41         	adds	r1, r0, #0x1
700aa538: d1f2         	bne	0x700aa520 <PowerClock_init+0x20> @ imm = #-0x1c
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700aa53a: f642 01e0    	movw	r1, #0x28e0
700aa53e: f2c7 010b    	movt	r1, #0x700b
700aa542: 6808         	ldr	r0, [r1]
700aa544: 1c42         	adds	r2, r0, #0x1
700aa546: d01b         	beq	0x700aa580 <PowerClock_init+0x80> @ imm = #0x36
700aa548: f101 0408    	add.w	r4, r1, #0x8
700aa54c: 2600         	movs	r6, #0x0
700aa54e: e00c         	b	0x700aa56a <PowerClock_init+0x6a> @ imm = #0x18
;             status = SOC_moduleSetClockFrequency(
700aa550: 461a         	mov	r2, r3
700aa552: 2300         	movs	r3, #0x0
700aa554: f7f5 f834    	bl	0x7009f5c0 <SOC_moduleSetClockFrequency> @ imm = #-0xaf98
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700aa558: fab0 f080    	clz	r0, r0
700aa55c: 0940         	lsrs	r0, r0, #0x5
700aa55e: f006 fe9f    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x6d3e
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700aa562: 68a0         	ldr	r0, [r4, #0x8]
700aa564: 3410         	adds	r4, #0x10
700aa566: 1c41         	adds	r1, r0, #0x1
700aa568: d00a         	beq	0x700aa580 <PowerClock_init+0x80> @ imm = #0x14
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700aa56a: 6862         	ldr	r2, [r4, #0x4]
700aa56c: f854 1c04    	ldr	r1, [r4, #-4]
700aa570: 6823         	ldr	r3, [r4]
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700aa572: 1c55         	adds	r5, r2, #0x1
700aa574: d0ec         	beq	0x700aa550 <PowerClock_init+0x50> @ imm = #-0x28
;             status = SOC_moduleSetClockFrequencyWithParent(
700aa576: e9cd 3600    	strd	r3, r6, [sp]
700aa57a: f7f5 f901    	bl	0x7009f780 <SOC_moduleSetClockFrequencyWithParent> @ imm = #-0xadfe
700aa57e: e7eb         	b	0x700aa558 <PowerClock_init+0x58> @ imm = #-0x2a
; }
700aa580: b002         	add	sp, #0x8
700aa582: bd70         	pop	{r4, r5, r6, pc}
		...

700aa590 <CSL_udmapCppi5SetReturnPolicy>:
; {
700aa590: b085         	sub	sp, #0x14
700aa592: f8dd c018    	ldr.w	r12, [sp, #0x18]
700aa596: f8dd c014    	ldr.w	r12, [sp, #0x14]
700aa59a: 9004         	str	r0, [sp, #0x10]
700aa59c: 9103         	str	r1, [sp, #0xc]
700aa59e: 9202         	str	r2, [sp, #0x8]
700aa5a0: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700aa5a2: 9803         	ldr	r0, [sp, #0xc]
700aa5a4: 2803         	cmp	r0, #0x3
700aa5a6: d108         	bne	0x700aa5ba <CSL_udmapCppi5SetReturnPolicy+0x2a> @ imm = #0x10
700aa5a8: e7ff         	b	0x700aa5aa <CSL_udmapCppi5SetReturnPolicy+0x1a> @ imm = #-0x2
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700aa5aa: 9905         	ldr	r1, [sp, #0x14]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETQ, retQnum ) ;
700aa5ac: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700aa5b0: f361 4010    	bfi	r0, r1, #16, #1
;         ((CSL_UdmapCppi5TRPD *)pDesc)->retInfo =
700aa5b4: 9904         	ldr	r1, [sp, #0x10]
700aa5b6: 6088         	str	r0, [r1, #0x8]
;     }
700aa5b8: e029         	b	0x700aa60e <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #0x52
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2;
700aa5ba: 9804         	ldr	r0, [sp, #0x10]
700aa5bc: 6880         	ldr	r0, [r0, #0x8]
700aa5be: 9000         	str	r0, [sp]
;         if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO )
700aa5c0: 9803         	ldr	r0, [sp, #0xc]
700aa5c2: 2802         	cmp	r0, #0x2
700aa5c4: d105         	bne	0x700aa5d2 <CSL_udmapCppi5SetReturnPolicy+0x42> @ imm = #0xa
700aa5c6: e7ff         	b	0x700aa5c8 <CSL_udmapCppi5SetReturnPolicy+0x38> @ imm = #-0x2
;             v &= (CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO2_DATA_OFFSET_MASK);
700aa5c8: 9800         	ldr	r0, [sp]
700aa5ca: f36f 0011    	bfc	r0, #0, #18
700aa5ce: 9000         	str	r0, [sp]
;         }
700aa5d0: e00b         	b	0x700aa5ea <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #0x16
;             v &= CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK;
700aa5d2: 9800         	ldr	r0, [sp]
700aa5d4: f000 4078    	and	r0, r0, #0xf8000000
700aa5d8: 9000         	str	r0, [sp]
;             v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPOLICY, retPolicy );
700aa5da: 9802         	ldr	r0, [sp, #0x8]
700aa5dc: f000 0101    	and	r1, r0, #0x1
700aa5e0: 9800         	ldr	r0, [sp]
700aa5e2: ea40 4081    	orr.w	r0, r0, r1, lsl #18
700aa5e6: 9000         	str	r0, [sp]
700aa5e8: e7ff         	b	0x700aa5ea <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #-0x2
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa5ea: 9901         	ldr	r1, [sp, #0x4]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700aa5ec: 9a05         	ldr	r2, [sp, #0x14]
700aa5ee: f44f 3080    	mov.w	r0, #0x10000
700aa5f2: ea00 4002    	and.w	r0, r0, r2, lsl #16
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa5f6: f361 4051    	bfi	r0, r1, #17, #1
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETQ, retQnum );
700aa5fa: f8bd 1018    	ldrh.w	r1, [sp, #0x18]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700aa5fe: 4401         	add	r1, r0
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa600: 9800         	ldr	r0, [sp]
700aa602: 4308         	orrs	r0, r1
700aa604: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2 = v;
700aa606: 9800         	ldr	r0, [sp]
700aa608: 9904         	ldr	r1, [sp, #0x10]
700aa60a: 6088         	str	r0, [r1, #0x8]
700aa60c: e7ff         	b	0x700aa60e <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #-0x2
; }
700aa60e: b005         	add	sp, #0x14
700aa610: 4770         	bx	lr
		...
700aa61e: 0000         	movs	r0, r0

700aa620 <SemaphoreP_pend>:
; {
700aa620: b580         	push	{r7, lr}
700aa622: b086         	sub	sp, #0x18
700aa624: 9005         	str	r0, [sp, #0x14]
700aa626: 9104         	str	r1, [sp, #0x10]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700aa628: 9805         	ldr	r0, [sp, #0x14]
700aa62a: 9003         	str	r0, [sp, #0xc]
700aa62c: 2000         	movs	r0, #0x0
;     uint32_t isSemTaken = 0U;
700aa62e: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700aa630: 9803         	ldr	r0, [sp, #0xc]
700aa632: 6d40         	ldr	r0, [r0, #0x54]
700aa634: b180         	cbz	r0, 0x700aa658 <SemaphoreP_pend+0x38> @ imm = #0x20
700aa636: e7ff         	b	0x700aa638 <SemaphoreP_pend+0x18> @ imm = #-0x2
;         if(HwiP_inISR() == 0U )
700aa638: f005 fe92    	bl	0x700b0360 <HwiP_inISR> @ imm = #0x5d24
700aa63c: b938         	cbnz	r0, 0x700aa64e <SemaphoreP_pend+0x2e> @ imm = #0xe
700aa63e: e7ff         	b	0x700aa640 <SemaphoreP_pend+0x20> @ imm = #-0x2
;             isSemTaken =(uint32_t) xSemaphoreTakeRecursive(pSemaphore->semHndl, timeout);
700aa640: 9803         	ldr	r0, [sp, #0xc]
700aa642: 6d00         	ldr	r0, [r0, #0x50]
700aa644: 9904         	ldr	r1, [sp, #0x10]
700aa646: f002 fccb    	bl	0x700acfe0 <xQueueTakeMutexRecursive> @ imm = #0x2996
700aa64a: 9002         	str	r0, [sp, #0x8]
;         }
700aa64c: e003         	b	0x700aa656 <SemaphoreP_pend+0x36> @ imm = #0x6
700aa64e: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700aa650: f006 fe26    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x6c4c
700aa654: e7ff         	b	0x700aa656 <SemaphoreP_pend+0x36> @ imm = #-0x2
;     }
700aa656: e017         	b	0x700aa688 <SemaphoreP_pend+0x68> @ imm = #0x2e
;         if( HwiP_inISR() != 0U )
700aa658: f005 fe82    	bl	0x700b0360 <HwiP_inISR> @ imm = #0x5d04
700aa65c: b160         	cbz	r0, 0x700aa678 <SemaphoreP_pend+0x58> @ imm = #0x18
700aa65e: e7ff         	b	0x700aa660 <SemaphoreP_pend+0x40> @ imm = #-0x2
700aa660: 2100         	movs	r1, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700aa662: 9100         	str	r1, [sp]
;             isSemTaken = (uint32_t) xSemaphoreTakeFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700aa664: 9803         	ldr	r0, [sp, #0xc]
700aa666: 6d00         	ldr	r0, [r0, #0x50]
700aa668: 466a         	mov	r2, sp
700aa66a: f7fe fe19    	bl	0x700a92a0 <xQueueReceiveFromISR> @ imm = #-0x13ce
700aa66e: 9002         	str	r0, [sp, #0x8]
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700aa670: 9800         	ldr	r0, [sp]
700aa672: f004 ff85    	bl	0x700af580 <vPortYeildFromISR> @ imm = #0x4f0a
;         }
700aa676: e006         	b	0x700aa686 <SemaphoreP_pend+0x66> @ imm = #0xc
;             isSemTaken = (uint32_t) xSemaphoreTake(pSemaphore->semHndl, timeout);
700aa678: 9803         	ldr	r0, [sp, #0xc]
700aa67a: 6d00         	ldr	r0, [r0, #0x50]
700aa67c: 9904         	ldr	r1, [sp, #0x10]
700aa67e: f7f6 fd6f    	bl	0x700a1160 <xQueueSemaphoreTake> @ imm = #-0x9522
700aa682: 9002         	str	r0, [sp, #0x8]
700aa684: e7ff         	b	0x700aa686 <SemaphoreP_pend+0x66> @ imm = #-0x2
700aa686: e7ff         	b	0x700aa688 <SemaphoreP_pend+0x68> @ imm = #-0x2
;     if(isSemTaken != 0U)
700aa688: 9802         	ldr	r0, [sp, #0x8]
700aa68a: b118         	cbz	r0, 0x700aa694 <SemaphoreP_pend+0x74> @ imm = #0x6
700aa68c: e7ff         	b	0x700aa68e <SemaphoreP_pend+0x6e> @ imm = #-0x2
700aa68e: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700aa690: 9001         	str	r0, [sp, #0x4]
;     }
700aa692: e003         	b	0x700aa69c <SemaphoreP_pend+0x7c> @ imm = #0x6
700aa694: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700aa698: 9001         	str	r0, [sp, #0x4]
700aa69a: e7ff         	b	0x700aa69c <SemaphoreP_pend+0x7c> @ imm = #-0x2
;     return status;
700aa69c: 9801         	ldr	r0, [sp, #0x4]
700aa69e: b006         	add	sp, #0x18
700aa6a0: bd80         	pop	{r7, pc}
		...
700aa6ae: 0000         	movs	r0, r0

700aa6b0 <Udma_chPair>:
; {
700aa6b0: b580         	push	{r7, lr}
700aa6b2: b088         	sub	sp, #0x20
700aa6b4: 9007         	str	r0, [sp, #0x1c]
700aa6b6: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
700aa6b8: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700aa6ba: 9807         	ldr	r0, [sp, #0x1c]
700aa6bc: 6e80         	ldr	r0, [r0, #0x68]
700aa6be: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa6c0: 9805         	ldr	r0, [sp, #0x14]
700aa6c2: 6800         	ldr	r0, [r0]
700aa6c4: 2801         	cmp	r0, #0x1
700aa6c6: d107         	bne	0x700aa6d8 <Udma_chPair+0x28> @ imm = #0xe
700aa6c8: e7ff         	b	0x700aa6ca <Udma_chPair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700aa6ca: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa6cc: 7800         	ldrb	r0, [r0]
700aa6ce: 0740         	lsls	r0, r0, #0x1d
700aa6d0: 2800         	cmp	r0, #0x0
700aa6d2: d501         	bpl	0x700aa6d8 <Udma_chPair+0x28> @ imm = #0x2
700aa6d4: e7ff         	b	0x700aa6d6 <Udma_chPair+0x26> @ imm = #-0x2
;     }
700aa6d6: e029         	b	0x700aa72c <Udma_chPair+0x7c> @ imm = #0x52
;         rmPairReq.nav_id = drvHandle->devIdPsil;
700aa6d8: 9805         	ldr	r0, [sp, #0x14]
700aa6da: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700aa6de: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700aa6e0: 9807         	ldr	r0, [sp, #0x1c]
700aa6e2: 7800         	ldrb	r0, [r0]
700aa6e4: 07c0         	lsls	r0, r0, #0x1f
700aa6e6: b158         	cbz	r0, 0x700aa700 <Udma_chPair+0x50> @ imm = #0x16
700aa6e8: e7ff         	b	0x700aa6ea <Udma_chPair+0x3a> @ imm = #-0x2
;             rmPairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700aa6ea: 9807         	ldr	r0, [sp, #0x1c]
700aa6ec: 6ec0         	ldr	r0, [r0, #0x6c]
700aa6ee: 9905         	ldr	r1, [sp, #0x14]
700aa6f0: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700aa6f4: 4408         	add	r0, r1
700aa6f6: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->peerThreadId;
700aa6f8: 9807         	ldr	r0, [sp, #0x1c]
700aa6fa: 6fc0         	ldr	r0, [r0, #0x7c]
700aa6fc: 9004         	str	r0, [sp, #0x10]
;         }
700aa6fe: e00a         	b	0x700aa716 <Udma_chPair+0x66> @ imm = #0x14
;             rmPairReq.src_thread = chHandle->peerThreadId;
700aa700: 9807         	ldr	r0, [sp, #0x1c]
700aa702: 6fc0         	ldr	r0, [r0, #0x7c]
700aa704: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700aa706: 9807         	ldr	r0, [sp, #0x1c]
700aa708: 6f00         	ldr	r0, [r0, #0x70]
700aa70a: 9905         	ldr	r1, [sp, #0x14]
700aa70c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700aa710: 4408         	add	r0, r1
700aa712: 9004         	str	r0, [sp, #0x10]
700aa714: e7ff         	b	0x700aa716 <Udma_chPair+0x66> @ imm = #-0x2
700aa716: 4668         	mov	r0, sp
700aa718: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilPair(&rmPairReq, UDMA_SCICLIENT_TIMEOUT);
700aa71c: f002 f9f0    	bl	0x700acb00 <Sciclient_rmPsilPair> @ imm = #0x23e0
700aa720: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700aa722: 9806         	ldr	r0, [sp, #0x18]
700aa724: b108         	cbz	r0, 0x700aa72a <Udma_chPair+0x7a> @ imm = #0x2
700aa726: e7ff         	b	0x700aa728 <Udma_chPair+0x78> @ imm = #-0x2
;         }
700aa728: e7ff         	b	0x700aa72a <Udma_chPair+0x7a> @ imm = #-0x2
700aa72a: e7ff         	b	0x700aa72c <Udma_chPair+0x7c> @ imm = #-0x2
;     return (retVal);
700aa72c: 9806         	ldr	r0, [sp, #0x18]
700aa72e: b008         	add	sp, #0x20
700aa730: bd80         	pop	{r7, pc}
		...
700aa73e: 0000         	movs	r0, r0

700aa740 <Udma_chUnpair>:
; {
700aa740: b580         	push	{r7, lr}
700aa742: b088         	sub	sp, #0x20
700aa744: 9007         	str	r0, [sp, #0x1c]
700aa746: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aa748: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700aa74a: 9807         	ldr	r0, [sp, #0x1c]
700aa74c: 6e80         	ldr	r0, [r0, #0x68]
700aa74e: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa750: 9805         	ldr	r0, [sp, #0x14]
700aa752: 6800         	ldr	r0, [r0]
700aa754: 2801         	cmp	r0, #0x1
700aa756: d107         	bne	0x700aa768 <Udma_chUnpair+0x28> @ imm = #0xe
700aa758: e7ff         	b	0x700aa75a <Udma_chUnpair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700aa75a: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa75c: 7800         	ldrb	r0, [r0]
700aa75e: 0740         	lsls	r0, r0, #0x1d
700aa760: 2800         	cmp	r0, #0x0
700aa762: d501         	bpl	0x700aa768 <Udma_chUnpair+0x28> @ imm = #0x2
700aa764: e7ff         	b	0x700aa766 <Udma_chUnpair+0x26> @ imm = #-0x2
;     }
700aa766: e029         	b	0x700aa7bc <Udma_chUnpair+0x7c> @ imm = #0x52
;         rmUnpairReq.nav_id = drvHandle->devIdPsil;
700aa768: 9805         	ldr	r0, [sp, #0x14]
700aa76a: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700aa76e: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700aa770: 9807         	ldr	r0, [sp, #0x1c]
700aa772: 7800         	ldrb	r0, [r0]
700aa774: 07c0         	lsls	r0, r0, #0x1f
700aa776: b158         	cbz	r0, 0x700aa790 <Udma_chUnpair+0x50> @ imm = #0x16
700aa778: e7ff         	b	0x700aa77a <Udma_chUnpair+0x3a> @ imm = #-0x2
;             rmUnpairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700aa77a: 9807         	ldr	r0, [sp, #0x1c]
700aa77c: 6ec0         	ldr	r0, [r0, #0x6c]
700aa77e: 9905         	ldr	r1, [sp, #0x14]
700aa780: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700aa784: 4408         	add	r0, r1
700aa786: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->peerThreadId;
700aa788: 9807         	ldr	r0, [sp, #0x1c]
700aa78a: 6fc0         	ldr	r0, [r0, #0x7c]
700aa78c: 9004         	str	r0, [sp, #0x10]
;         }
700aa78e: e00a         	b	0x700aa7a6 <Udma_chUnpair+0x66> @ imm = #0x14
;             rmUnpairReq.src_thread = chHandle->peerThreadId;
700aa790: 9807         	ldr	r0, [sp, #0x1c]
700aa792: 6fc0         	ldr	r0, [r0, #0x7c]
700aa794: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700aa796: 9807         	ldr	r0, [sp, #0x1c]
700aa798: 6f00         	ldr	r0, [r0, #0x70]
700aa79a: 9905         	ldr	r1, [sp, #0x14]
700aa79c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700aa7a0: 4408         	add	r0, r1
700aa7a2: 9004         	str	r0, [sp, #0x10]
700aa7a4: e7ff         	b	0x700aa7a6 <Udma_chUnpair+0x66> @ imm = #-0x2
700aa7a6: 4668         	mov	r0, sp
700aa7a8: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilUnpair(&rmUnpairReq, UDMA_SCICLIENT_TIMEOUT);
700aa7ac: f002 f9d8    	bl	0x700acb60 <Sciclient_rmPsilUnpair> @ imm = #0x23b0
700aa7b0: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700aa7b2: 9806         	ldr	r0, [sp, #0x18]
700aa7b4: b108         	cbz	r0, 0x700aa7ba <Udma_chUnpair+0x7a> @ imm = #0x2
700aa7b6: e7ff         	b	0x700aa7b8 <Udma_chUnpair+0x78> @ imm = #-0x2
;         }
700aa7b8: e7ff         	b	0x700aa7ba <Udma_chUnpair+0x7a> @ imm = #-0x2
700aa7ba: e7ff         	b	0x700aa7bc <Udma_chUnpair+0x7c> @ imm = #-0x2
;     return (retVal);
700aa7bc: 9806         	ldr	r0, [sp, #0x18]
700aa7be: b008         	add	sp, #0x20
700aa7c0: bd80         	pop	{r7, pc}
		...
700aa7ce: 0000         	movs	r0, r0

700aa7d0 <UART_moduleReset>:
; {
700aa7d0: b580         	push	{r7, lr}
700aa7d2: b088         	sub	sp, #0x20
700aa7d4: 9007         	str	r0, [sp, #0x1c]
700aa7d6: 2000         	movs	r0, #0x0
;     uint32_t startTicks, elapsedTicks = 0;
700aa7d8: 9005         	str	r0, [sp, #0x14]
;     hUartInit = hUart->hUartInit;
700aa7da: 9807         	ldr	r0, [sp, #0x1c]
700aa7dc: 6840         	ldr	r0, [r0, #0x4]
700aa7de: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(hUart->baseAddr + UART_SYSC, UART_SYSC_SOFTRESET,
700aa7e0: 9807         	ldr	r0, [sp, #0x1c]
700aa7e2: 6800         	ldr	r0, [r0]
700aa7e4: 3054         	adds	r0, #0x54
700aa7e6: 2102         	movs	r1, #0x2
700aa7e8: 2301         	movs	r3, #0x1
700aa7ea: 461a         	mov	r2, r3
700aa7ec: f003 ff08    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x3e10
;     startTicks = hUartInit->clockP_get();
700aa7f0: 9804         	ldr	r0, [sp, #0x10]
700aa7f2: 6d40         	ldr	r0, [r0, #0x54]
700aa7f4: 4780         	blx	r0
700aa7f6: 9006         	str	r0, [sp, #0x18]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aa7f8: e7ff         	b	0x700aa7fa <UART_moduleReset+0x2a> @ imm = #-0x2
700aa7fa: 9807         	ldr	r0, [sp, #0x1c]
700aa7fc: 6800         	ldr	r0, [r0]
700aa7fe: 3058         	adds	r0, #0x58
700aa800: 2101         	movs	r1, #0x1
700aa802: 2200         	movs	r2, #0x0
700aa804: 9202         	str	r2, [sp, #0x8]
700aa806: f004 fd5b    	bl	0x700af2c0 <HW_RD_FIELD32_RAW> @ imm = #0x4ab6
700aa80a: 4601         	mov	r1, r0
700aa80c: 9802         	ldr	r0, [sp, #0x8]
700aa80e: 9003         	str	r0, [sp, #0xc]
700aa810: b989         	cbnz	r1, 0x700aa836 <UART_moduleReset+0x66> @ imm = #0x22
700aa812: e7ff         	b	0x700aa814 <UART_moduleReset+0x44> @ imm = #-0x2
700aa814: 9805         	ldr	r0, [sp, #0x14]
700aa816: 9000         	str	r0, [sp]
700aa818: 9804         	ldr	r0, [sp, #0x10]
700aa81a: 6d82         	ldr	r2, [r0, #0x58]
700aa81c: f44f 70fa    	mov.w	r0, #0x1f4
700aa820: 2100         	movs	r1, #0x0
700aa822: 9101         	str	r1, [sp, #0x4]
700aa824: 4790         	blx	r2
700aa826: 9900         	ldr	r1, [sp]
700aa828: 4602         	mov	r2, r0
700aa82a: 9801         	ldr	r0, [sp, #0x4]
700aa82c: 4291         	cmp	r1, r2
700aa82e: bf38         	it	lo
700aa830: 2001         	movlo	r0, #0x1
700aa832: 9003         	str	r0, [sp, #0xc]
700aa834: e7ff         	b	0x700aa836 <UART_moduleReset+0x66> @ imm = #-0x2
700aa836: 9803         	ldr	r0, [sp, #0xc]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aa838: 07c0         	lsls	r0, r0, #0x1f
700aa83a: b138         	cbz	r0, 0x700aa84c <UART_moduleReset+0x7c> @ imm = #0xe
700aa83c: e7ff         	b	0x700aa83e <UART_moduleReset+0x6e> @ imm = #-0x2
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700aa83e: 9804         	ldr	r0, [sp, #0x10]
700aa840: 6d40         	ldr	r0, [r0, #0x54]
700aa842: 4780         	blx	r0
700aa844: 9906         	ldr	r1, [sp, #0x18]
700aa846: 1a40         	subs	r0, r0, r1
700aa848: 9005         	str	r0, [sp, #0x14]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aa84a: e7d6         	b	0x700aa7fa <UART_moduleReset+0x2a> @ imm = #-0x54
; }
700aa84c: b008         	add	sp, #0x20
700aa84e: bd80         	pop	{r7, pc}

700aa850 <CSL_bcdmaChanOpIsChanEnabled>:
; {
700aa850: b580         	push	{r7, lr}
700aa852: b086         	sub	sp, #0x18
700aa854: 9005         	str	r0, [sp, #0x14]
700aa856: 9104         	str	r1, [sp, #0x10]
700aa858: 9203         	str	r2, [sp, #0xc]
;     switch( chanType )
700aa85a: 9804         	ldr	r0, [sp, #0x10]
700aa85c: 9001         	str	r0, [sp, #0x4]
700aa85e: b140         	cbz	r0, 0x700aa872 <CSL_bcdmaChanOpIsChanEnabled+0x22> @ imm = #0x10
700aa860: e7ff         	b	0x700aa862 <CSL_bcdmaChanOpIsChanEnabled+0x12> @ imm = #-0x2
700aa862: 9801         	ldr	r0, [sp, #0x4]
700aa864: 2801         	cmp	r0, #0x1
700aa866: d010         	beq	0x700aa88a <CSL_bcdmaChanOpIsChanEnabled+0x3a> @ imm = #0x20
700aa868: e7ff         	b	0x700aa86a <CSL_bcdmaChanOpIsChanEnabled+0x1a> @ imm = #-0x2
700aa86a: 9801         	ldr	r0, [sp, #0x4]
700aa86c: 2802         	cmp	r0, #0x2
700aa86e: d018         	beq	0x700aa8a2 <CSL_bcdmaChanOpIsChanEnabled+0x52> @ imm = #0x30
700aa870: e023         	b	0x700aa8ba <CSL_bcdmaChanOpIsChanEnabled+0x6a> @ imm = #0x46
;             regVal = CSL_REG32_FEXT( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_EN );
700aa872: 9805         	ldr	r0, [sp, #0x14]
700aa874: 6880         	ldr	r0, [r0, #0x8]
700aa876: 9903         	ldr	r1, [sp, #0xc]
700aa878: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aa87c: f04f 4100    	mov.w	r1, #0x80000000
700aa880: 221f         	movs	r2, #0x1f
700aa882: f004 fbc5    	bl	0x700af010 <CSL_REG32_FEXT_RAW> @ imm = #0x478a
700aa886: 9002         	str	r0, [sp, #0x8]
;             break;
700aa888: e01a         	b	0x700aa8c0 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x34
;             regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_EN );
700aa88a: 9805         	ldr	r0, [sp, #0x14]
700aa88c: 6900         	ldr	r0, [r0, #0x10]
700aa88e: 9903         	ldr	r1, [sp, #0xc]
700aa890: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aa894: f04f 4100    	mov.w	r1, #0x80000000
700aa898: 221f         	movs	r2, #0x1f
700aa89a: f004 fbb9    	bl	0x700af010 <CSL_REG32_FEXT_RAW> @ imm = #0x4772
700aa89e: 9002         	str	r0, [sp, #0x8]
;             break;
700aa8a0: e00e         	b	0x700aa8c0 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x1c
;             regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_EN );
700aa8a2: 9805         	ldr	r0, [sp, #0x14]
700aa8a4: 6980         	ldr	r0, [r0, #0x18]
700aa8a6: 9903         	ldr	r1, [sp, #0xc]
700aa8a8: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aa8ac: f04f 4100    	mov.w	r1, #0x80000000
700aa8b0: 221f         	movs	r2, #0x1f
700aa8b2: f004 fbad    	bl	0x700af010 <CSL_REG32_FEXT_RAW> @ imm = #0x475a
700aa8b6: 9002         	str	r0, [sp, #0x8]
;             break;
700aa8b8: e002         	b	0x700aa8c0 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x4
700aa8ba: 2000         	movs	r0, #0x0
;             regVal = 0U;
700aa8bc: 9002         	str	r0, [sp, #0x8]
;             break;
700aa8be: e7ff         	b	0x700aa8c0 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700aa8c0: 9802         	ldr	r0, [sp, #0x8]
700aa8c2: 3801         	subs	r0, #0x1
700aa8c4: fab0 f080    	clz	r0, r0
700aa8c8: 0940         	lsrs	r0, r0, #0x5
700aa8ca: b006         	add	sp, #0x18
700aa8cc: bd80         	pop	{r7, pc}
700aa8ce: 0000         	movs	r0, r0

700aa8d0 <CSL_bcdmaChanOpIsValidChanIdx>:
; {
700aa8d0: b084         	sub	sp, #0x10
700aa8d2: 9003         	str	r0, [sp, #0xc]
700aa8d4: 9102         	str	r1, [sp, #0x8]
700aa8d6: 9201         	str	r2, [sp, #0x4]
700aa8d8: 2001         	movs	r0, #0x1
;     bool retVal = (bool)true;
700aa8da: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700aa8de: 9802         	ldr	r0, [sp, #0x8]
700aa8e0: b958         	cbnz	r0, 0x700aa8fa <CSL_bcdmaChanOpIsValidChanIdx+0x2a> @ imm = #0x16
700aa8e2: e7ff         	b	0x700aa8e4 <CSL_bcdmaChanOpIsValidChanIdx+0x14> @ imm = #-0x2
;         if( chanIdx > pCfg->bcChanCnt )
700aa8e4: 9801         	ldr	r0, [sp, #0x4]
700aa8e6: 9903         	ldr	r1, [sp, #0xc]
700aa8e8: 6a49         	ldr	r1, [r1, #0x24]
700aa8ea: 4288         	cmp	r0, r1
700aa8ec: d904         	bls	0x700aa8f8 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #0x8
700aa8ee: e7ff         	b	0x700aa8f0 <CSL_bcdmaChanOpIsValidChanIdx+0x20> @ imm = #-0x2
700aa8f0: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aa8f2: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aa8f6: e7ff         	b	0x700aa8f8 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #-0x2
;     }
700aa8f8: e023         	b	0x700aa942 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #0x46
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700aa8fa: 9802         	ldr	r0, [sp, #0x8]
700aa8fc: 2802         	cmp	r0, #0x2
700aa8fe: d10b         	bne	0x700aa918 <CSL_bcdmaChanOpIsValidChanIdx+0x48> @ imm = #0x16
700aa900: e7ff         	b	0x700aa902 <CSL_bcdmaChanOpIsValidChanIdx+0x32> @ imm = #-0x2
;         if( chanIdx > pCfg->splitRxChanCnt )
700aa902: 9801         	ldr	r0, [sp, #0x4]
700aa904: 9903         	ldr	r1, [sp, #0xc]
700aa906: 6a89         	ldr	r1, [r1, #0x28]
700aa908: 4288         	cmp	r0, r1
700aa90a: d904         	bls	0x700aa916 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #0x8
700aa90c: e7ff         	b	0x700aa90e <CSL_bcdmaChanOpIsValidChanIdx+0x3e> @ imm = #-0x2
700aa90e: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aa910: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aa914: e7ff         	b	0x700aa916 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #-0x2
;     }
700aa916: e013         	b	0x700aa940 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #0x26
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700aa918: 9802         	ldr	r0, [sp, #0x8]
700aa91a: 2801         	cmp	r0, #0x1
700aa91c: d10b         	bne	0x700aa936 <CSL_bcdmaChanOpIsValidChanIdx+0x66> @ imm = #0x16
700aa91e: e7ff         	b	0x700aa920 <CSL_bcdmaChanOpIsValidChanIdx+0x50> @ imm = #-0x2
;         if( chanIdx > pCfg->splitTxChanCnt )
700aa920: 9801         	ldr	r0, [sp, #0x4]
700aa922: 9903         	ldr	r1, [sp, #0xc]
700aa924: 6ac9         	ldr	r1, [r1, #0x2c]
700aa926: 4288         	cmp	r0, r1
700aa928: d904         	bls	0x700aa934 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #0x8
700aa92a: e7ff         	b	0x700aa92c <CSL_bcdmaChanOpIsValidChanIdx+0x5c> @ imm = #-0x2
700aa92c: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aa92e: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aa932: e7ff         	b	0x700aa934 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #-0x2
;     }
700aa934: e003         	b	0x700aa93e <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #0x6
700aa936: 2000         	movs	r0, #0x0
;         retVal = (bool)false;
700aa938: f88d 0003    	strb.w	r0, [sp, #0x3]
700aa93c: e7ff         	b	0x700aa93e <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #-0x2
700aa93e: e7ff         	b	0x700aa940 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #-0x2
700aa940: e7ff         	b	0x700aa942 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #-0x2
;     return retVal;
700aa942: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aa946: f000 0001    	and	r0, r0, #0x1
700aa94a: b004         	add	sp, #0x10
700aa94c: 4770         	bx	lr
700aa94e: 0000         	movs	r0, r0

700aa950 <CSL_bcdmaMapChanIdx>:
; {
700aa950: b084         	sub	sp, #0x10
700aa952: 9003         	str	r0, [sp, #0xc]
700aa954: 9102         	str	r1, [sp, #0x8]
700aa956: 9201         	str	r2, [sp, #0x4]
;     if( chanIdx < pCfg->bcChanCnt )
700aa958: 9802         	ldr	r0, [sp, #0x8]
700aa95a: 9903         	ldr	r1, [sp, #0xc]
700aa95c: 6a49         	ldr	r1, [r1, #0x24]
700aa95e: 4288         	cmp	r0, r1
700aa960: d206         	bhs	0x700aa970 <CSL_bcdmaMapChanIdx+0x20> @ imm = #0xc
700aa962: e7ff         	b	0x700aa964 <CSL_bcdmaMapChanIdx+0x14> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_BLOCK_COPY;
700aa964: 9901         	ldr	r1, [sp, #0x4]
700aa966: 2000         	movs	r0, #0x0
700aa968: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx;
700aa96a: 9802         	ldr	r0, [sp, #0x8]
700aa96c: 9000         	str	r0, [sp]
;     }
700aa96e: e02b         	b	0x700aa9c8 <CSL_bcdmaMapChanIdx+0x78> @ imm = #0x56
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt) )
700aa970: 9802         	ldr	r0, [sp, #0x8]
700aa972: 9a03         	ldr	r2, [sp, #0xc]
700aa974: 6a51         	ldr	r1, [r2, #0x24]
700aa976: 6ad2         	ldr	r2, [r2, #0x2c]
700aa978: 4411         	add	r1, r2
700aa97a: 4288         	cmp	r0, r1
700aa97c: d209         	bhs	0x700aa992 <CSL_bcdmaMapChanIdx+0x42> @ imm = #0x12
700aa97e: e7ff         	b	0x700aa980 <CSL_bcdmaMapChanIdx+0x30> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_TX;
700aa980: 9901         	ldr	r1, [sp, #0x4]
700aa982: 2001         	movs	r0, #0x1
700aa984: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt;
700aa986: 9802         	ldr	r0, [sp, #0x8]
700aa988: 9903         	ldr	r1, [sp, #0xc]
700aa98a: 6a49         	ldr	r1, [r1, #0x24]
700aa98c: 1a40         	subs	r0, r0, r1
700aa98e: 9000         	str	r0, [sp]
;     }
700aa990: e019         	b	0x700aa9c6 <CSL_bcdmaMapChanIdx+0x76> @ imm = #0x32
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt + pCfg->splitRxChanCnt) )
700aa992: 9802         	ldr	r0, [sp, #0x8]
700aa994: 9b03         	ldr	r3, [sp, #0xc]
700aa996: 6a59         	ldr	r1, [r3, #0x24]
700aa998: 6a9a         	ldr	r2, [r3, #0x28]
700aa99a: 6adb         	ldr	r3, [r3, #0x2c]
700aa99c: 4419         	add	r1, r3
700aa99e: 4411         	add	r1, r2
700aa9a0: 4288         	cmp	r0, r1
700aa9a2: d20b         	bhs	0x700aa9bc <CSL_bcdmaMapChanIdx+0x6c> @ imm = #0x16
700aa9a4: e7ff         	b	0x700aa9a6 <CSL_bcdmaMapChanIdx+0x56> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_RX;
700aa9a6: 9901         	ldr	r1, [sp, #0x4]
700aa9a8: 2002         	movs	r0, #0x2
700aa9aa: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt - pCfg->splitTxChanCnt;
700aa9ac: 9802         	ldr	r0, [sp, #0x8]
700aa9ae: 9903         	ldr	r1, [sp, #0xc]
700aa9b0: 6a4a         	ldr	r2, [r1, #0x24]
700aa9b2: 6ac9         	ldr	r1, [r1, #0x2c]
700aa9b4: 1a80         	subs	r0, r0, r2
700aa9b6: 1a40         	subs	r0, r0, r1
700aa9b8: 9000         	str	r0, [sp]
;     }
700aa9ba: e003         	b	0x700aa9c4 <CSL_bcdmaMapChanIdx+0x74> @ imm = #0x6
700aa9bc: f04f 30ff    	mov.w	r0, #0xffffffff
;         base0chanIdx = CSL_BCDMA_INVALID_CHANNEL_INDEX;
700aa9c0: 9000         	str	r0, [sp]
700aa9c2: e7ff         	b	0x700aa9c4 <CSL_bcdmaMapChanIdx+0x74> @ imm = #-0x2
700aa9c4: e7ff         	b	0x700aa9c6 <CSL_bcdmaMapChanIdx+0x76> @ imm = #-0x2
700aa9c6: e7ff         	b	0x700aa9c8 <CSL_bcdmaMapChanIdx+0x78> @ imm = #-0x2
;     return base0chanIdx;
700aa9c8: 9800         	ldr	r0, [sp]
700aa9ca: b004         	add	sp, #0x10
700aa9cc: 4770         	bx	lr
700aa9ce: 0000         	movs	r0, r0

700aa9d0 <ClockP_getTimeUsec>:
; {
700aa9d0: b580         	push	{r7, lr}
700aa9d2: b08a         	sub	sp, #0x28
700aa9d4: 2000         	movs	r0, #0x0
;     uint64_t ts = 0U;
700aa9d6: 9009         	str	r0, [sp, #0x24]
700aa9d8: 9008         	str	r0, [sp, #0x20]
;     do {
700aa9da: e7ff         	b	0x700aa9dc <ClockP_getTimeUsec+0xc> @ imm = #-0x2
;         ticks1 = gClockCtrl.ticks;
700aa9dc: f245 0010    	movw	r0, #0x5010
700aa9e0: f2c7 0008    	movt	r0, #0x7008
700aa9e4: 9001         	str	r0, [sp, #0x4]
700aa9e6: 6801         	ldr	r1, [r0]
700aa9e8: 6842         	ldr	r2, [r0, #0x4]
700aa9ea: 9205         	str	r2, [sp, #0x14]
700aa9ec: 9104         	str	r1, [sp, #0x10]
;         timerCount = ClockP_getTimerCount(gClockCtrl.timerBaseAddr);
700aa9ee: 6ac0         	ldr	r0, [r0, #0x2c]
700aa9f0: f005 f886    	bl	0x700afb00 <ClockP_getTimerCount> @ imm = #0x510c
700aa9f4: 9901         	ldr	r1, [sp, #0x4]
700aa9f6: 9007         	str	r0, [sp, #0x1c]
;         ticks2 = gClockCtrl.ticks;
700aa9f8: 6808         	ldr	r0, [r1]
700aa9fa: 6849         	ldr	r1, [r1, #0x4]
700aa9fc: 9103         	str	r1, [sp, #0xc]
700aa9fe: 9002         	str	r0, [sp, #0x8]
;     } while (ticks1 != ticks2);
700aaa00: e7ff         	b	0x700aaa02 <ClockP_getTimeUsec+0x32> @ imm = #-0x2
700aaa02: 9804         	ldr	r0, [sp, #0x10]
700aaa04: 9905         	ldr	r1, [sp, #0x14]
700aaa06: 9a02         	ldr	r2, [sp, #0x8]
700aaa08: 9b03         	ldr	r3, [sp, #0xc]
700aaa0a: 4059         	eors	r1, r3
700aaa0c: ea80 0002    	eor.w	r0, r0, r2
700aaa10: 4308         	orrs	r0, r1
700aaa12: 2800         	cmp	r0, #0x0
700aaa14: d1e2         	bne	0x700aa9dc <ClockP_getTimeUsec+0xc> @ imm = #-0x3c
700aaa16: e7ff         	b	0x700aaa18 <ClockP_getTimeUsec+0x48> @ imm = #-0x2
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aaa18: 9a02         	ldr	r2, [sp, #0x8]
700aaa1a: 9803         	ldr	r0, [sp, #0xc]
700aaa1c: f245 0110    	movw	r1, #0x5010
700aaa20: f2c7 0108    	movt	r1, #0x7008
700aaa24: 688b         	ldr	r3, [r1, #0x8]
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700aaa26: f8d1 c030    	ldr.w	r12, [r1, #0x30]
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aaa2a: fb00 f103    	mul	r1, r0, r3
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700aaa2e: 9807         	ldr	r0, [sp, #0x1c]
700aaa30: eba0 000c    	sub.w	r0, r0, r12
700aaa34: 4358         	muls	r0, r3, r0
700aaa36: ea6f 0c0c    	mvn.w	r12, r12
700aaa3a: fbb0 f0fc    	udiv	r0, r0, r12
;              + (uint64_t) ( /* convert timer count to usecs */
700aaa3e: fbe2 0103    	umlal	r0, r1, r2, r3
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aaa42: 9109         	str	r1, [sp, #0x24]
700aaa44: 9008         	str	r0, [sp, #0x20]
;     return (ts);
700aaa46: 9808         	ldr	r0, [sp, #0x20]
700aaa48: 9909         	ldr	r1, [sp, #0x24]
700aaa4a: b00a         	add	sp, #0x28
700aaa4c: bd80         	pop	{r7, pc}
700aaa4e: 0000         	movs	r0, r0

700aaa50 <UART_readData>:
; {
700aaa50: b580         	push	{r7, lr}
700aaa52: b086         	sub	sp, #0x18
700aaa54: 9005         	str	r0, [sp, #0x14]
700aaa56: 9104         	str	r1, [sp, #0x10]
700aaa58: 2000         	movs	r0, #0x0
;     uint8_t             readIn = 0;
700aaa5a: f88d 000f    	strb.w	r0, [sp, #0xf]
;     uint32_t             rdSize = size;
700aaa5e: 9804         	ldr	r0, [sp, #0x10]
700aaa60: 9001         	str	r0, [sp, #0x4]
;     readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700aaa62: 9805         	ldr	r0, [sp, #0x14]
700aaa64: 6800         	ldr	r0, [r0]
700aaa66: f10d 010f    	add.w	r1, sp, #0xf
700aaa6a: f001 fc09    	bl	0x700ac280 <UART_getChar> @ imm = #0x1812
700aaa6e: 9002         	str	r0, [sp, #0x8]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aaa70: e7ff         	b	0x700aaa72 <UART_readData+0x22> @ imm = #-0x2
700aaa72: 9901         	ldr	r1, [sp, #0x4]
700aaa74: 2000         	movs	r0, #0x0
700aaa76: 9000         	str	r0, [sp]
700aaa78: b131         	cbz	r1, 0x700aaa88 <UART_readData+0x38> @ imm = #0xc
700aaa7a: e7ff         	b	0x700aaa7c <UART_readData+0x2c> @ imm = #-0x2
700aaa7c: 9802         	ldr	r0, [sp, #0x8]
700aaa7e: 2800         	cmp	r0, #0x0
700aaa80: bf18         	it	ne
700aaa82: 2001         	movne	r0, #0x1
700aaa84: 9000         	str	r0, [sp]
700aaa86: e7ff         	b	0x700aaa88 <UART_readData+0x38> @ imm = #-0x2
700aaa88: 9800         	ldr	r0, [sp]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aaa8a: 07c0         	lsls	r0, r0, #0x1f
700aaa8c: b1e0         	cbz	r0, 0x700aaac8 <UART_readData+0x78> @ imm = #0x38
700aaa8e: e7ff         	b	0x700aaa90 <UART_readData+0x40> @ imm = #-0x2
;         *(uint8_t *)hUart->readBuf = readIn;
700aaa90: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700aaa94: 9905         	ldr	r1, [sp, #0x14]
700aaa96: 6949         	ldr	r1, [r1, #0x14]
700aaa98: 7008         	strb	r0, [r1]
;         hUart->readBuf = (uint8_t *)hUart->readBuf + 1U;
700aaa9a: 9905         	ldr	r1, [sp, #0x14]
700aaa9c: 6948         	ldr	r0, [r1, #0x14]
700aaa9e: 3001         	adds	r0, #0x1
700aaaa0: 6148         	str	r0, [r1, #0x14]
;         hUart->readCount++;
700aaaa2: 9905         	ldr	r1, [sp, #0x14]
700aaaa4: 6988         	ldr	r0, [r1, #0x18]
700aaaa6: 3001         	adds	r0, #0x1
700aaaa8: 6188         	str	r0, [r1, #0x18]
;         rdSize--;
700aaaaa: 9801         	ldr	r0, [sp, #0x4]
700aaaac: 3801         	subs	r0, #0x1
700aaaae: 9001         	str	r0, [sp, #0x4]
;         if (rdSize != 0U)
700aaab0: 9801         	ldr	r0, [sp, #0x4]
700aaab2: b140         	cbz	r0, 0x700aaac6 <UART_readData+0x76> @ imm = #0x10
700aaab4: e7ff         	b	0x700aaab6 <UART_readData+0x66> @ imm = #-0x2
;             readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700aaab6: 9805         	ldr	r0, [sp, #0x14]
700aaab8: 6800         	ldr	r0, [r0]
700aaaba: f10d 010f    	add.w	r1, sp, #0xf
700aaabe: f001 fbdf    	bl	0x700ac280 <UART_getChar> @ imm = #0x17be
700aaac2: 9002         	str	r0, [sp, #0x8]
;         }
700aaac4: e7ff         	b	0x700aaac6 <UART_readData+0x76> @ imm = #-0x2
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aaac6: e7d4         	b	0x700aaa72 <UART_readData+0x22> @ imm = #-0x58
;     return (rdSize);
700aaac8: 9801         	ldr	r0, [sp, #0x4]
700aaaca: b006         	add	sp, #0x18
700aaacc: bd80         	pop	{r7, pc}
700aaace: 0000         	movs	r0, r0

700aaad0 <_DebugP_assert>:
; {
700aaad0: b5b0         	push	{r4, r5, r7, lr}
700aaad2: b08e         	sub	sp, #0x38
700aaad4: f8dd c048    	ldr.w	r12, [sp, #0x48]
700aaad8: 900d         	str	r0, [sp, #0x34]
700aaada: 910c         	str	r1, [sp, #0x30]
700aaadc: 920b         	str	r2, [sp, #0x2c]
700aaade: 930a         	str	r3, [sp, #0x28]
;     if(expression==0)
700aaae0: 980d         	ldr	r0, [sp, #0x34]
700aaae2: bb88         	cbnz	r0, 0x700aab48 <_DebugP_assert+0x78> @ imm = #0x62
700aaae4: e7ff         	b	0x700aaae6 <_DebugP_assert+0x16> @ imm = #-0x2
700aaae6: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700aaae8: 9004         	str	r0, [sp, #0x10]
700aaaea: 9009         	str	r0, [sp, #0x24]
;         uint64_t curTime = ClockP_getTimeUsec();
700aaaec: f7ff ff70    	bl	0x700aa9d0 <ClockP_getTimeUsec> @ imm = #-0x120
700aaaf0: 9107         	str	r1, [sp, #0x1c]
700aaaf2: 9006         	str	r0, [sp, #0x18]
;         DebugP_log("ASSERT: %d.%ds: %s:%s:%d: %s failed !!!\r\n",
700aaaf4: 9806         	ldr	r0, [sp, #0x18]
700aaaf6: 9907         	ldr	r1, [sp, #0x1c]
700aaaf8: f244 2240    	movw	r2, #0x4240
700aaafc: f2c0 020f    	movt	r2, #0xf
700aab00: 2300         	movs	r3, #0x0
700aab02: f004 eb28    	blx	0x700af154 <__aeabi_uldivmod> @ imm = #0x4650
700aab06: 4603         	mov	r3, r0
700aab08: 9804         	ldr	r0, [sp, #0x10]
700aab0a: 9305         	str	r3, [sp, #0x14]
700aab0c: 4613         	mov	r3, r2
700aab0e: 9a05         	ldr	r2, [sp, #0x14]
700aab10: 990c         	ldr	r1, [sp, #0x30]
700aab12: f8dd e02c    	ldr.w	lr, [sp, #0x2c]
700aab16: 9c0a         	ldr	r4, [sp, #0x28]
700aab18: 9d12         	ldr	r5, [sp, #0x48]
700aab1a: 46ec         	mov	r12, sp
700aab1c: f8cc 500c    	str.w	r5, [r12, #0xc]
700aab20: f8cc 4008    	str.w	r4, [r12, #0x8]
700aab24: f8cc e004    	str.w	lr, [r12, #0x4]
700aab28: f8cc 1000    	str.w	r1, [r12]
700aab2c: f641 21f0    	movw	r1, #0x1af0
700aab30: f2c7 010b    	movt	r1, #0x700b
700aab34: f7ff f814    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #-0xfd8
;         (void) HwiP_disable();
700aab38: f005 eef2    	blx	0x700b0920 <HwiP_disable> @ imm = #0x5de4
;         while(assert_loop!= 0U)
700aab3c: e7ff         	b	0x700aab3e <_DebugP_assert+0x6e> @ imm = #-0x2
700aab3e: 9809         	ldr	r0, [sp, #0x24]
700aab40: b108         	cbz	r0, 0x700aab46 <_DebugP_assert+0x76> @ imm = #0x2
700aab42: e7ff         	b	0x700aab44 <_DebugP_assert+0x74> @ imm = #-0x2
700aab44: e7fb         	b	0x700aab3e <_DebugP_assert+0x6e> @ imm = #-0xa
;     }
700aab46: e7ff         	b	0x700aab48 <_DebugP_assert+0x78> @ imm = #-0x2
; }
700aab48: b00e         	add	sp, #0x38
700aab4a: bdb0         	pop	{r4, r5, r7, pc}
700aab4c: 0000         	movs	r0, r0
700aab4e: 0000         	movs	r0, r0

700aab50 <UART_Params_init>:
; {
700aab50: b082         	sub	sp, #0x8
700aab52: 9001         	str	r0, [sp, #0x4]
;     if(prms != NULL)
700aab54: 9801         	ldr	r0, [sp, #0x4]
700aab56: b3b0         	cbz	r0, 0x700aabc6 <UART_Params_init+0x76> @ imm = #0x6c
700aab58: e7ff         	b	0x700aab5a <UART_Params_init+0xa> @ imm = #-0x2
;         prms->baudRate           = 115200U;
700aab5a: 9901         	ldr	r1, [sp, #0x4]
700aab5c: f44f 30e1    	mov.w	r0, #0x1c200
700aab60: 6008         	str	r0, [r1]
;         prms->dataLength         = UART_LEN_8;
700aab62: 9901         	ldr	r1, [sp, #0x4]
700aab64: 2003         	movs	r0, #0x3
700aab66: 6048         	str	r0, [r1, #0x4]
;         prms->stopBits           = UART_STOPBITS_1;
700aab68: 9901         	ldr	r1, [sp, #0x4]
700aab6a: 2000         	movs	r0, #0x0
700aab6c: 9000         	str	r0, [sp]
700aab6e: 6088         	str	r0, [r1, #0x8]
;         prms->parityType         = UART_PARITY_NONE;
700aab70: 9901         	ldr	r1, [sp, #0x4]
700aab72: 60c8         	str	r0, [r1, #0xc]
;         prms->readMode           = UART_TRANSFER_MODE_BLOCKING;
700aab74: 9901         	ldr	r1, [sp, #0x4]
700aab76: 6108         	str	r0, [r1, #0x10]
;         prms->readReturnMode     = UART_READ_RETURN_MODE_FULL;
700aab78: 9901         	ldr	r1, [sp, #0x4]
700aab7a: 6148         	str	r0, [r1, #0x14]
;         prms->writeMode          = UART_TRANSFER_MODE_BLOCKING;
700aab7c: 9901         	ldr	r1, [sp, #0x4]
700aab7e: 6188         	str	r0, [r1, #0x18]
;         prms->readCallbackFxn    = NULL;
700aab80: 9901         	ldr	r1, [sp, #0x4]
700aab82: 61c8         	str	r0, [r1, #0x1c]
;         prms->writeCallbackFxn   = NULL;
700aab84: 9901         	ldr	r1, [sp, #0x4]
700aab86: 6208         	str	r0, [r1, #0x20]
;         prms->hwFlowControl      = FALSE;
700aab88: 9901         	ldr	r1, [sp, #0x4]
700aab8a: 6248         	str	r0, [r1, #0x24]
;         prms->hwFlowControlThr   = UART_RXTRIGLVL_16;
700aab8c: 9a01         	ldr	r2, [sp, #0x4]
700aab8e: 2110         	movs	r1, #0x10
700aab90: 6291         	str	r1, [r2, #0x28]
;         prms->intrNum            = 0xFFFF;
700aab92: 9a01         	ldr	r2, [sp, #0x4]
700aab94: f64f 71ff    	movw	r1, #0xffff
700aab98: 6311         	str	r1, [r2, #0x30]
;         prms->transferMode       = UART_CONFIG_MODE_INTERRUPT;
700aab9a: 9a01         	ldr	r2, [sp, #0x4]
700aab9c: 2101         	movs	r1, #0x1
700aab9e: 62d1         	str	r1, [r2, #0x2c]
;         prms->intrPriority       = 4U;
700aaba0: 9a01         	ldr	r2, [sp, #0x4]
700aaba2: 2104         	movs	r1, #0x4
700aaba4: f882 1034    	strb.w	r1, [r2, #0x34]
;         prms->skipIntrReg        = FALSE;
700aaba8: 9901         	ldr	r1, [sp, #0x4]
700aabaa: 6388         	str	r0, [r1, #0x38]
;         prms->uartDmaIndex       = -1;
700aabac: 9a01         	ldr	r2, [sp, #0x4]
700aabae: f04f 31ff    	mov.w	r1, #0xffffffff
700aabb2: 63d1         	str	r1, [r2, #0x3c]
;         prms->operMode           = UART_OPER_MODE_16X;
700aabb4: 9901         	ldr	r1, [sp, #0x4]
700aabb6: 6408         	str	r0, [r1, #0x40]
;         prms->rxTrigLvl          = UART_RXTRIGLVL_8;
700aabb8: 9901         	ldr	r1, [sp, #0x4]
700aabba: 2008         	movs	r0, #0x8
700aabbc: 6448         	str	r0, [r1, #0x44]
;         prms->txTrigLvl          = UART_TXTRIGLVL_32;
700aabbe: 9901         	ldr	r1, [sp, #0x4]
700aabc0: 2020         	movs	r0, #0x20
700aabc2: 6488         	str	r0, [r1, #0x48]
;     }
700aabc4: e7ff         	b	0x700aabc6 <UART_Params_init+0x76> @ imm = #-0x2
; }
700aabc6: b002         	add	sp, #0x8
700aabc8: 4770         	bx	lr
700aabca: 0000         	movs	r0, r0
700aabcc: 0000         	movs	r0, r0
700aabce: 0000         	movs	r0, r0

700aabd0 <main_task>:
; {
700aabd0: b5b0         	push	{r4, r5, r7, lr}
700aabd2: b086         	sub	sp, #0x18
;    printf("Starting Thread-Metric tests...\r\n");
700aabd4: f641 4166    	movw	r1, #0x1c66
700aabd8: 2001         	movs	r0, #0x1
700aabda: f2c7 010b    	movt	r1, #0x700b
700aabde: 2501         	movs	r5, #0x1
700aabe0: f7fe ffbe    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #-0x1084
;    test_interrupt_handler = tm_isr_message_handler;
700aabe4: f245 1051    	movw	r0, #0x5151
700aabe8: f642 2104    	movw	r1, #0x2a04
700aabec: f2c7 000a    	movt	r0, #0x700a
700aabf0: ac01         	add	r4, sp, #0x4
700aabf2: f2c7 010b    	movt	r1, #0x700b
700aabf6: 6008         	str	r0, [r1]
;    HwiP_Params_init(&hwiParams);
700aabf8: 4620         	mov	r0, r4
700aabfa: f005 f989    	bl	0x700aff10 <HwiP_Params_init> @ imm = #0x5312
;    hwiParams.callback = tm_interrupt_handler; /* Interrupt handler */
700aabfe: f64f 2131    	movw	r1, #0xfa31
700aac02: 200a         	movs	r0, #0xa
700aac04: f2c7 010a    	movt	r1, #0x700a
;    hwiParams.priority = 1;                    /* Set a valid priority (lower is higher priority) */
700aac08: f8ad 5012    	strh.w	r5, [sp, #0x12]
;    hwiParams.intNum = SOFTWARE_INTERRUPT_ID;  /* Chosen interrupt ID */
700aac0c: e9cd 0101    	strd	r0, r1, [sp, #4]
;    if (HwiP_construct(&hwiObj, &hwiParams) != SystemP_SUCCESS)
700aac10: f245 0070    	movw	r0, #0x5070
700aac14: f2c7 0008    	movt	r0, #0x7008
700aac18: 4621         	mov	r1, r4
700aac1a: f005 f991    	bl	0x700aff40 <HwiP_construct> @ imm = #0x5322
700aac1e: b140         	cbz	r0, 0x700aac32 <main_task+0x62> @ imm = #0x10
;       printf("Failed to register interrupt\r\n");
700aac20: f641 516a    	movw	r1, #0x1d6a
700aac24: 2001         	movs	r0, #0x1
700aac26: f2c7 010b    	movt	r1, #0x700b
700aac2a: f7fe ff99    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #-0x10ce
700aac2e: bf00         	nop
;       while (1)
700aac30: e7fe         	b	0x700aac30 <main_task+0x60> @ imm = #-0x4
;    HwiP_enableInt(SOFTWARE_INTERRUPT_ID);
700aac32: 200a         	movs	r0, #0xa
700aac34: f005 f8c4    	bl	0x700afdc0 <HwiP_enableInt> @ imm = #0x5188
;    HwiP_enable();
700aac38: f005 ee82    	blx	0x700b0940 <HwiP_enable> @ imm = #0x5d04
;    main_inheritance();
700aac3c: f004 fed8    	bl	0x700af9f0 <main_inheritance> @ imm = #0x4db0
;    vTaskDelete(NULL);
700aac40: 2000         	movs	r0, #0x0
700aac42: f7fb fb8d    	bl	0x700a6360 <vTaskDelete> @ imm = #-0x48e6
; }
700aac46: b006         	add	sp, #0x18
700aac48: bdb0         	pop	{r4, r5, r7, pc}
700aac4a: 0000         	movs	r0, r0

700aac4c <snprintf>:
700aac4c: e24dd004     	sub	sp, sp, #4
700aac50: e92d4070     	push	{r4, r5, r6, lr}
700aac54: e24dd01c     	sub	sp, sp, #28
700aac58: e1a04001     	mov	r4, r1
700aac5c: e3510000     	cmp	r1, #0
700aac60: 12411001     	subne	r1, r1, #1
700aac64: e58d302c     	str	r3, [sp, #0x2c]
700aac68: e59f3050     	ldr	r3, [pc, #0x50]         @ 0x700aacc0 <snprintf+0x74>
700aac6c: e3a06000     	mov	r6, #0
700aac70: e59f5044     	ldr	r5, [pc, #0x44]         @ 0x700aacbc <snprintf+0x70>
700aac74: e58d2014     	str	r2, [sp, #0x14]
700aac78: e28d2008     	add	r2, sp, #8
700aac7c: e58d100c     	str	r1, [sp, #0xc]
700aac80: e28d102c     	add	r1, sp, #44
700aac84: e58d0008     	str	r0, [sp, #0x8]
700aac88: e28d0014     	add	r0, sp, #20
700aac8c: e58d6010     	str	r6, [sp, #0x10]
700aac90: e58d1018     	str	r1, [sp, #0x18]
700aac94: e58d5000     	str	r5, [sp]
700aac98: ebffb938     	bl	0x70099180 <__TI_printfi_nofloat> @ imm = #-0x11b20
700aac9c: e3540000     	cmp	r4, #0
700aaca0: 0a000001     	beq	0x700aacac <snprintf+0x60> @ imm = #0x4
700aaca4: e59d1008     	ldr	r1, [sp, #0x8]
700aaca8: e5c16000     	strb	r6, [r1]
700aacac: e28dd01c     	add	sp, sp, #28
700aacb0: e8bd4070     	pop	{r4, r5, r6, lr}
700aacb4: e28dd004     	add	sp, sp, #4
700aacb8: e12fff1e     	bx	lr
700aacbc: 98 c9 0a 70  	.word	0x700ac998
700aacc0: d0 e7 0a 70  	.word	0x700ae7d0
700aacc4: 00 00 00 00  	.word	0x00000000
700aacc8: 00 00 00 00  	.word	0x00000000
700aaccc: 00 00 00 00  	.word	0x00000000

700aacd0 <xTimerCreateTimerTask>:
;     {
700aacd0: b580         	push	{r7, lr}
700aacd2: b088         	sub	sp, #0x20
700aacd4: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700aacd6: 9007         	str	r0, [sp, #0x1c]
;         prvCheckForValidListAndQueue();
700aacd8: f7fd fe2a    	bl	0x700a8930 <prvCheckForValidListAndQueue> @ imm = #-0x23ac
;         if( xTimerQueue != NULL )
700aacdc: f642 2048    	movw	r0, #0x2a48
700aace0: f2c7 000b    	movt	r0, #0x700b
700aace4: 6800         	ldr	r0, [r0]
700aace6: b358         	cbz	r0, 0x700aad40 <xTimerCreateTimerTask+0x70> @ imm = #0x56
700aace8: e7ff         	b	0x700aacea <xTimerCreateTimerTask+0x1a> @ imm = #-0x2
700aacea: 2000         	movs	r0, #0x0
;                     StaticTask_t * pxTimerTaskTCBBuffer = NULL;
700aacec: 9003         	str	r0, [sp, #0xc]
700aacee: 9006         	str	r0, [sp, #0x18]
;                     StackType_t * pxTimerTaskStackBuffer = NULL;
700aacf0: 9005         	str	r0, [sp, #0x14]
700aacf2: a806         	add	r0, sp, #0x18
700aacf4: a905         	add	r1, sp, #0x14
700aacf6: aa04         	add	r2, sp, #0x10
;                     vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
700aacf8: f003 ff92    	bl	0x700aec20 <vApplicationGetTimerTaskMemory> @ imm = #0x3f24
700aacfc: 9b03         	ldr	r3, [sp, #0xc]
;                                                           ulTimerTaskStackSize,
700aacfe: 9a04         	ldr	r2, [sp, #0x10]
;                                                           pxTimerTaskStackBuffer,
700aad00: 9805         	ldr	r0, [sp, #0x14]
;                                                           pxTimerTaskTCBBuffer );
700aad02: f8dd c018    	ldr.w	r12, [sp, #0x18]
;                     xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
700aad06: 4669         	mov	r1, sp
700aad08: f8c1 c008    	str.w	r12, [r1, #0x8]
700aad0c: 6048         	str	r0, [r1, #0x4]
700aad0e: 201f         	movs	r0, #0x1f
700aad10: 6008         	str	r0, [r1]
700aad12: f24f 4081    	movw	r0, #0xf481
700aad16: f2c7 000a    	movt	r0, #0x700a
700aad1a: f242 5112    	movw	r1, #0x2512
700aad1e: f2c7 010b    	movt	r1, #0x700b
700aad22: f000 fa55    	bl	0x700ab1d0 <xTaskCreateStatic> @ imm = #0x4aa
700aad26: 4601         	mov	r1, r0
700aad28: f642 204c    	movw	r0, #0x2a4c
700aad2c: f2c7 000b    	movt	r0, #0x700b
700aad30: 6001         	str	r1, [r0]
;                     if( xTimerTaskHandle != NULL )
700aad32: 6800         	ldr	r0, [r0]
700aad34: b118         	cbz	r0, 0x700aad3e <xTimerCreateTimerTask+0x6e> @ imm = #0x6
700aad36: e7ff         	b	0x700aad38 <xTimerCreateTimerTask+0x68> @ imm = #-0x2
700aad38: 2001         	movs	r0, #0x1
;                         xReturn = pdPASS;
700aad3a: 9007         	str	r0, [sp, #0x1c]
;                     }
700aad3c: e7ff         	b	0x700aad3e <xTimerCreateTimerTask+0x6e> @ imm = #-0x2
;         }
700aad3e: e000         	b	0x700aad42 <xTimerCreateTimerTask+0x72> @ imm = #0x0
700aad40: e7ff         	b	0x700aad42 <xTimerCreateTimerTask+0x72> @ imm = #-0x2
;         return xReturn;
700aad42: 9807         	ldr	r0, [sp, #0x1c]
700aad44: b008         	add	sp, #0x20
700aad46: bd80         	pop	{r7, pc}
		...

700aad50 <CSL_bcdmaChanOpClearError>:
; {
700aad50: b580         	push	{r7, lr}
700aad52: b086         	sub	sp, #0x18
700aad54: 9005         	str	r0, [sp, #0x14]
700aad56: 9104         	str	r1, [sp, #0x10]
700aad58: 9203         	str	r2, [sp, #0xc]
700aad5a: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700aad5c: 9002         	str	r0, [sp, #0x8]
;     switch( chanType )
700aad5e: 9804         	ldr	r0, [sp, #0x10]
700aad60: 9001         	str	r0, [sp, #0x4]
700aad62: b140         	cbz	r0, 0x700aad76 <CSL_bcdmaChanOpClearError+0x26> @ imm = #0x10
700aad64: e7ff         	b	0x700aad66 <CSL_bcdmaChanOpClearError+0x16> @ imm = #-0x2
700aad66: 9801         	ldr	r0, [sp, #0x4]
700aad68: 2801         	cmp	r0, #0x1
700aad6a: d00f         	beq	0x700aad8c <CSL_bcdmaChanOpClearError+0x3c> @ imm = #0x1e
700aad6c: e7ff         	b	0x700aad6e <CSL_bcdmaChanOpClearError+0x1e> @ imm = #-0x2
700aad6e: 9801         	ldr	r0, [sp, #0x4]
700aad70: 2802         	cmp	r0, #0x2
700aad72: d016         	beq	0x700aada2 <CSL_bcdmaChanOpClearError+0x52> @ imm = #0x2c
700aad74: e020         	b	0x700aadb8 <CSL_bcdmaChanOpClearError+0x68> @ imm = #0x40
;             CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aad76: 9805         	ldr	r0, [sp, #0x14]
700aad78: 6880         	ldr	r0, [r0, #0x8]
700aad7a: 9903         	ldr	r1, [sp, #0xc]
700aad7c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aad80: 2101         	movs	r1, #0x1
700aad82: 2300         	movs	r3, #0x0
700aad84: 461a         	mov	r2, r3
700aad86: f003 fa23    	bl	0x700ae1d0 <CSL_REG32_FINS_RAW> @ imm = #0x3446
;             break;
700aad8a: e019         	b	0x700aadc0 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x32
;             CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aad8c: 9805         	ldr	r0, [sp, #0x14]
700aad8e: 6900         	ldr	r0, [r0, #0x10]
700aad90: 9903         	ldr	r1, [sp, #0xc]
700aad92: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aad96: 2101         	movs	r1, #0x1
700aad98: 2300         	movs	r3, #0x0
700aad9a: 461a         	mov	r2, r3
700aad9c: f003 fa18    	bl	0x700ae1d0 <CSL_REG32_FINS_RAW> @ imm = #0x3430
;             break;
700aada0: e00e         	b	0x700aadc0 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x1c
;             CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aada2: 9805         	ldr	r0, [sp, #0x14]
700aada4: 6980         	ldr	r0, [r0, #0x18]
700aada6: 9903         	ldr	r1, [sp, #0xc]
700aada8: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aadac: 2101         	movs	r1, #0x1
700aadae: 2300         	movs	r3, #0x0
700aadb0: 461a         	mov	r2, r3
700aadb2: f003 fa0d    	bl	0x700ae1d0 <CSL_REG32_FINS_RAW> @ imm = #0x341a
;             break;
700aadb6: e003         	b	0x700aadc0 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x6
700aadb8: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700aadbc: 9002         	str	r0, [sp, #0x8]
;             break;
700aadbe: e7ff         	b	0x700aadc0 <CSL_bcdmaChanOpClearError+0x70> @ imm = #-0x2
;     return retVal;
700aadc0: 9802         	ldr	r0, [sp, #0x8]
700aadc2: b006         	add	sp, #0x18
700aadc4: bd80         	pop	{r7, pc}
		...
700aadce: 0000         	movs	r0, r0

700aadd0 <CSL_bcdmaDoChanOp>:
; {
700aadd0: b580         	push	{r7, lr}
700aadd2: b088         	sub	sp, #0x20
700aadd4: 9007         	str	r0, [sp, #0x1c]
700aadd6: 9106         	str	r1, [sp, #0x18]
700aadd8: 9205         	str	r2, [sp, #0x14]
700aadda: 9304         	str	r3, [sp, #0x10]
700aaddc: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t retVal = CSL_EFAIL;
700aade0: 9003         	str	r0, [sp, #0xc]
;     if( pCfg == NULL )
700aade2: 9807         	ldr	r0, [sp, #0x1c]
700aade4: b920         	cbnz	r0, 0x700aadf0 <CSL_bcdmaDoChanOp+0x20> @ imm = #0x8
700aade6: e7ff         	b	0x700aade8 <CSL_bcdmaDoChanOp+0x18> @ imm = #-0x2
700aade8: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700aadec: 9003         	str	r0, [sp, #0xc]
;     }
700aadee: e027         	b	0x700aae40 <CSL_bcdmaDoChanOp+0x70> @ imm = #0x4e
;         if( (pCfg->bcChanCnt == (uint32_t)0U) || (pCfg->splitTxChanCnt == (uint32_t)0U) || (pCfg->splitRxChanCnt == (uint32_t)0U) ) {
700aadf0: 9807         	ldr	r0, [sp, #0x1c]
700aadf2: 6a40         	ldr	r0, [r0, #0x24]
700aadf4: b140         	cbz	r0, 0x700aae08 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x10
700aadf6: e7ff         	b	0x700aadf8 <CSL_bcdmaDoChanOp+0x28> @ imm = #-0x2
700aadf8: 9807         	ldr	r0, [sp, #0x1c]
700aadfa: 6ac0         	ldr	r0, [r0, #0x2c]
700aadfc: b120         	cbz	r0, 0x700aae08 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x8
700aadfe: e7ff         	b	0x700aae00 <CSL_bcdmaDoChanOp+0x30> @ imm = #-0x2
700aae00: 9807         	ldr	r0, [sp, #0x1c]
700aae02: 6a80         	ldr	r0, [r0, #0x28]
700aae04: b920         	cbnz	r0, 0x700aae10 <CSL_bcdmaDoChanOp+0x40> @ imm = #0x8
700aae06: e7ff         	b	0x700aae08 <CSL_bcdmaDoChanOp+0x38> @ imm = #-0x2
;             CSL_bcdmaGetCfg( pCfg );
700aae08: 9807         	ldr	r0, [sp, #0x1c]
700aae0a: f7ff f981    	bl	0x700aa110 <CSL_bcdmaGetCfg> @ imm = #-0xcfe
;         }
700aae0e: e7ff         	b	0x700aae10 <CSL_bcdmaDoChanOp+0x40> @ imm = #-0x2
;         base0chanIdx = CSL_bcdmaMapChanIdx( pCfg, chanIdx, &chanType );
700aae10: 9807         	ldr	r0, [sp, #0x1c]
700aae12: 9905         	ldr	r1, [sp, #0x14]
700aae14: aa01         	add	r2, sp, #0x4
700aae16: f7ff fd9b    	bl	0x700aa950 <CSL_bcdmaMapChanIdx> @ imm = #-0x4ca
700aae1a: 9002         	str	r0, [sp, #0x8]
;         if( base0chanIdx != CSL_BCDMA_INVALID_CHANNEL_INDEX )
700aae1c: 9802         	ldr	r0, [sp, #0x8]
700aae1e: 3001         	adds	r0, #0x1
700aae20: b168         	cbz	r0, 0x700aae3e <CSL_bcdmaDoChanOp+0x6e> @ imm = #0x1a
700aae22: e7ff         	b	0x700aae24 <CSL_bcdmaDoChanOp+0x54> @ imm = #-0x2
;             retVal = CSL_bcdmaChanOp( pCfg, chanOp, chanType, base0chanIdx, pOpData );
700aae24: 9807         	ldr	r0, [sp, #0x1c]
700aae26: 9906         	ldr	r1, [sp, #0x18]
700aae28: 9a01         	ldr	r2, [sp, #0x4]
700aae2a: 9b02         	ldr	r3, [sp, #0x8]
700aae2c: f8dd c010    	ldr.w	r12, [sp, #0x10]
700aae30: 46ee         	mov	lr, sp
700aae32: f8ce c000    	str.w	r12, [lr]
700aae36: f7f6 fbcb    	bl	0x700a15d0 <CSL_bcdmaChanOp> @ imm = #-0x986a
700aae3a: 9003         	str	r0, [sp, #0xc]
;         }
700aae3c: e7ff         	b	0x700aae3e <CSL_bcdmaDoChanOp+0x6e> @ imm = #-0x2
700aae3e: e7ff         	b	0x700aae40 <CSL_bcdmaDoChanOp+0x70> @ imm = #-0x2
;     return retVal;
700aae40: 9803         	ldr	r0, [sp, #0xc]
700aae42: b008         	add	sp, #0x20
700aae44: bd80         	pop	{r7, pc}
		...
700aae4e: 0000         	movs	r0, r0

700aae50 <Udma_chGetCqRingHandle>:
; {
700aae50: b085         	sub	sp, #0x14
700aae52: 9004         	str	r0, [sp, #0x10]
700aae54: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aae56: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     cqRing = (Udma_RingHandle) NULL_PTR;
700aae58: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700aae5a: 9804         	ldr	r0, [sp, #0x10]
700aae5c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700aae5e: 9800         	ldr	r0, [sp]
700aae60: b150         	cbz	r0, 0x700aae78 <Udma_chGetCqRingHandle+0x28> @ imm = #0x14
700aae62: e7ff         	b	0x700aae64 <Udma_chGetCqRingHandle+0x14> @ imm = #-0x2
700aae64: 9800         	ldr	r0, [sp]
700aae66: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700aae6a: f64a 31cd    	movw	r1, #0xabcd
700aae6e: f6ca 31dc    	movt	r1, #0xabdc
700aae72: 4288         	cmp	r0, r1
700aae74: d004         	beq	0x700aae80 <Udma_chGetCqRingHandle+0x30> @ imm = #0x8
700aae76: e7ff         	b	0x700aae78 <Udma_chGetCqRingHandle+0x28> @ imm = #-0x2
700aae78: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700aae7c: 9003         	str	r0, [sp, #0xc]
;     }
700aae7e: e7ff         	b	0x700aae80 <Udma_chGetCqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aae80: 9803         	ldr	r0, [sp, #0xc]
700aae82: b9a8         	cbnz	r0, 0x700aaeb0 <Udma_chGetCqRingHandle+0x60> @ imm = #0x2a
700aae84: e7ff         	b	0x700aae86 <Udma_chGetCqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700aae86: 9800         	ldr	r0, [sp]
700aae88: 6e80         	ldr	r0, [r0, #0x68]
700aae8a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700aae8c: 9801         	ldr	r0, [sp, #0x4]
700aae8e: b150         	cbz	r0, 0x700aaea6 <Udma_chGetCqRingHandle+0x56> @ imm = #0x14
700aae90: e7ff         	b	0x700aae92 <Udma_chGetCqRingHandle+0x42> @ imm = #-0x2
700aae92: 9801         	ldr	r0, [sp, #0x4]
700aae94: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700aae98: f64a 31cd    	movw	r1, #0xabcd
700aae9c: f6ca 31dc    	movt	r1, #0xabdc
700aaea0: 4288         	cmp	r0, r1
700aaea2: d004         	beq	0x700aaeae <Udma_chGetCqRingHandle+0x5e> @ imm = #0x8
700aaea4: e7ff         	b	0x700aaea6 <Udma_chGetCqRingHandle+0x56> @ imm = #-0x2
700aaea6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700aaeaa: 9003         	str	r0, [sp, #0xc]
;         }
700aaeac: e7ff         	b	0x700aaeae <Udma_chGetCqRingHandle+0x5e> @ imm = #-0x2
;     }
700aaeae: e7ff         	b	0x700aaeb0 <Udma_chGetCqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aaeb0: 9803         	ldr	r0, [sp, #0xc]
700aaeb2: b928         	cbnz	r0, 0x700aaec0 <Udma_chGetCqRingHandle+0x70> @ imm = #0xa
700aaeb4: e7ff         	b	0x700aaeb6 <Udma_chGetCqRingHandle+0x66> @ imm = #-0x2
;         cqRing = (Udma_RingHandle) chHandleInt->cqRing;
700aaeb6: 9800         	ldr	r0, [sp]
700aaeb8: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700aaebc: 9002         	str	r0, [sp, #0x8]
;     }
700aaebe: e7ff         	b	0x700aaec0 <Udma_chGetCqRingHandle+0x70> @ imm = #-0x2
;     return (cqRing);
700aaec0: 9802         	ldr	r0, [sp, #0x8]
700aaec2: b005         	add	sp, #0x14
700aaec4: 4770         	bx	lr
		...
700aaece: 0000         	movs	r0, r0

700aaed0 <Udma_chGetFqRingHandle>:
; {
700aaed0: b085         	sub	sp, #0x14
700aaed2: 9004         	str	r0, [sp, #0x10]
700aaed4: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aaed6: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     fqRing = (Udma_RingHandle) NULL_PTR;
700aaed8: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700aaeda: 9804         	ldr	r0, [sp, #0x10]
700aaedc: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700aaede: 9800         	ldr	r0, [sp]
700aaee0: b150         	cbz	r0, 0x700aaef8 <Udma_chGetFqRingHandle+0x28> @ imm = #0x14
700aaee2: e7ff         	b	0x700aaee4 <Udma_chGetFqRingHandle+0x14> @ imm = #-0x2
700aaee4: 9800         	ldr	r0, [sp]
700aaee6: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700aaeea: f64a 31cd    	movw	r1, #0xabcd
700aaeee: f6ca 31dc    	movt	r1, #0xabdc
700aaef2: 4288         	cmp	r0, r1
700aaef4: d004         	beq	0x700aaf00 <Udma_chGetFqRingHandle+0x30> @ imm = #0x8
700aaef6: e7ff         	b	0x700aaef8 <Udma_chGetFqRingHandle+0x28> @ imm = #-0x2
700aaef8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700aaefc: 9003         	str	r0, [sp, #0xc]
;     }
700aaefe: e7ff         	b	0x700aaf00 <Udma_chGetFqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aaf00: 9803         	ldr	r0, [sp, #0xc]
700aaf02: b9a8         	cbnz	r0, 0x700aaf30 <Udma_chGetFqRingHandle+0x60> @ imm = #0x2a
700aaf04: e7ff         	b	0x700aaf06 <Udma_chGetFqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700aaf06: 9800         	ldr	r0, [sp]
700aaf08: 6e80         	ldr	r0, [r0, #0x68]
700aaf0a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700aaf0c: 9801         	ldr	r0, [sp, #0x4]
700aaf0e: b150         	cbz	r0, 0x700aaf26 <Udma_chGetFqRingHandle+0x56> @ imm = #0x14
700aaf10: e7ff         	b	0x700aaf12 <Udma_chGetFqRingHandle+0x42> @ imm = #-0x2
700aaf12: 9801         	ldr	r0, [sp, #0x4]
700aaf14: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700aaf18: f64a 31cd    	movw	r1, #0xabcd
700aaf1c: f6ca 31dc    	movt	r1, #0xabdc
700aaf20: 4288         	cmp	r0, r1
700aaf22: d004         	beq	0x700aaf2e <Udma_chGetFqRingHandle+0x5e> @ imm = #0x8
700aaf24: e7ff         	b	0x700aaf26 <Udma_chGetFqRingHandle+0x56> @ imm = #-0x2
700aaf26: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700aaf2a: 9003         	str	r0, [sp, #0xc]
;         }
700aaf2c: e7ff         	b	0x700aaf2e <Udma_chGetFqRingHandle+0x5e> @ imm = #-0x2
;     }
700aaf2e: e7ff         	b	0x700aaf30 <Udma_chGetFqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aaf30: 9803         	ldr	r0, [sp, #0xc]
700aaf32: b928         	cbnz	r0, 0x700aaf40 <Udma_chGetFqRingHandle+0x70> @ imm = #0xa
700aaf34: e7ff         	b	0x700aaf36 <Udma_chGetFqRingHandle+0x66> @ imm = #-0x2
;         fqRing = (Udma_RingHandle) chHandleInt->fqRing;
700aaf36: 9800         	ldr	r0, [sp]
700aaf38: f8d0 0080    	ldr.w	r0, [r0, #0x80]
700aaf3c: 9002         	str	r0, [sp, #0x8]
;     }
700aaf3e: e7ff         	b	0x700aaf40 <Udma_chGetFqRingHandle+0x70> @ imm = #-0x2
;     return (fqRing);
700aaf40: 9802         	ldr	r0, [sp, #0x8]
700aaf42: b005         	add	sp, #0x14
700aaf44: 4770         	bx	lr
		...
700aaf4e: 0000         	movs	r0, r0

700aaf50 <prvGetExpectedIdleTime>:
; static TickType_t prvGetExpectedIdleTime(void) {
700aaf50: b082         	sub	sp, #0x8
700aaf52: 2000         	movs	r0, #0x0
;   UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
700aaf54: 9000         	str	r0, [sp]
;     if (uxTopReadyPriority > tskIDLE_PRIORITY) {
700aaf56: f642 202c    	movw	r0, #0x2a2c
700aaf5a: f2c7 000b    	movt	r0, #0x700b
700aaf5e: 6800         	ldr	r0, [r0]
700aaf60: b118         	cbz	r0, 0x700aaf6a <prvGetExpectedIdleTime+0x1a> @ imm = #0x6
700aaf62: e7ff         	b	0x700aaf64 <prvGetExpectedIdleTime+0x14> @ imm = #-0x2
700aaf64: 2001         	movs	r0, #0x1
;       uxHigherPriorityReadyTasks = pdTRUE;
700aaf66: 9000         	str	r0, [sp]
;     }
700aaf68: e7ff         	b	0x700aaf6a <prvGetExpectedIdleTime+0x1a> @ imm = #-0x2
;   if (pxCurrentTCB->uxPriority > tskIDLE_PRIORITY) {
700aaf6a: f642 2000    	movw	r0, #0x2a00
700aaf6e: f2c7 000b    	movt	r0, #0x700b
700aaf72: 6800         	ldr	r0, [r0]
700aaf74: 6ac0         	ldr	r0, [r0, #0x2c]
700aaf76: b118         	cbz	r0, 0x700aaf80 <prvGetExpectedIdleTime+0x30> @ imm = #0x6
700aaf78: e7ff         	b	0x700aaf7a <prvGetExpectedIdleTime+0x2a> @ imm = #-0x2
700aaf7a: 2000         	movs	r0, #0x0
;     xReturn = 0;
700aaf7c: 9001         	str	r0, [sp, #0x4]
;   } else if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700aaf7e: e01f         	b	0x700aafc0 <prvGetExpectedIdleTime+0x70> @ imm = #0x3e
700aaf80: f244 40f8    	movw	r0, #0x44f8
700aaf84: f2c7 0008    	movt	r0, #0x7008
700aaf88: 6800         	ldr	r0, [r0]
700aaf8a: 2802         	cmp	r0, #0x2
700aaf8c: d303         	blo	0x700aaf96 <prvGetExpectedIdleTime+0x46> @ imm = #0x6
700aaf8e: e7ff         	b	0x700aaf90 <prvGetExpectedIdleTime+0x40> @ imm = #-0x2
700aaf90: 2000         	movs	r0, #0x0
;     xReturn = 0;
700aaf92: 9001         	str	r0, [sp, #0x4]
;   } else if (uxHigherPriorityReadyTasks != pdFALSE) {
700aaf94: e013         	b	0x700aafbe <prvGetExpectedIdleTime+0x6e> @ imm = #0x26
700aaf96: 9800         	ldr	r0, [sp]
700aaf98: b118         	cbz	r0, 0x700aafa2 <prvGetExpectedIdleTime+0x52> @ imm = #0x6
700aaf9a: e7ff         	b	0x700aaf9c <prvGetExpectedIdleTime+0x4c> @ imm = #-0x2
700aaf9c: 2000         	movs	r0, #0x0
;     xReturn = 0;
700aaf9e: 9001         	str	r0, [sp, #0x4]
;   } else {
700aafa0: e00c         	b	0x700aafbc <prvGetExpectedIdleTime+0x6c> @ imm = #0x18
;     xReturn = xNextTaskUnblockTime - xTickCount;
700aafa2: f642 2034    	movw	r0, #0x2a34
700aafa6: f2c7 000b    	movt	r0, #0x700b
700aafaa: 6800         	ldr	r0, [r0]
700aafac: f642 2144    	movw	r1, #0x2a44
700aafb0: f2c7 010b    	movt	r1, #0x700b
700aafb4: 6809         	ldr	r1, [r1]
700aafb6: 1a40         	subs	r0, r0, r1
700aafb8: 9001         	str	r0, [sp, #0x4]
700aafba: e7ff         	b	0x700aafbc <prvGetExpectedIdleTime+0x6c> @ imm = #-0x2
700aafbc: e7ff         	b	0x700aafbe <prvGetExpectedIdleTime+0x6e> @ imm = #-0x2
700aafbe: e7ff         	b	0x700aafc0 <prvGetExpectedIdleTime+0x70> @ imm = #-0x2
;   return xReturn;
700aafc0: 9801         	ldr	r0, [sp, #0x4]
700aafc2: b002         	add	sp, #0x8
700aafc4: 4770         	bx	lr
		...
700aafce: 0000         	movs	r0, r0

700aafd0 <ClockP_usleep>:
; {
700aafd0: b580         	push	{r7, lr}
700aafd2: b088         	sub	sp, #0x20
700aafd4: 9007         	str	r0, [sp, #0x1c]
;     curTime = ClockP_getTimeUsec();
700aafd6: f7ff fcfb    	bl	0x700aa9d0 <ClockP_getTimeUsec> @ imm = #-0x60a
700aafda: 9105         	str	r1, [sp, #0x14]
700aafdc: 9004         	str	r0, [sp, #0x10]
;     endTime = curTime + usec;
700aafde: 9904         	ldr	r1, [sp, #0x10]
700aafe0: 9805         	ldr	r0, [sp, #0x14]
700aafe2: 9a07         	ldr	r2, [sp, #0x1c]
700aafe4: 1889         	adds	r1, r1, r2
700aafe6: f140 0000    	adc	r0, r0, #0x0
700aafea: 9102         	str	r1, [sp, #0x8]
700aafec: 9003         	str	r0, [sp, #0xc]
;     if (usec >= gClockCtrl.usecPerTick) {
700aafee: 9807         	ldr	r0, [sp, #0x1c]
700aaff0: f245 0110    	movw	r1, #0x5010
700aaff4: f2c7 0108    	movt	r1, #0x7008
700aaff8: 6889         	ldr	r1, [r1, #0x8]
700aaffa: 4288         	cmp	r0, r1
700aaffc: d30d         	blo	0x700ab01a <ClockP_usleep+0x4a> @ imm = #0x1a
700aaffe: e7ff         	b	0x700ab000 <ClockP_usleep+0x30> @ imm = #-0x2
;         ticksToSleep = usec / gClockCtrl.usecPerTick;
700ab000: 9807         	ldr	r0, [sp, #0x1c]
700ab002: f245 0110    	movw	r1, #0x5010
700ab006: f2c7 0108    	movt	r1, #0x7008
700ab00a: 6889         	ldr	r1, [r1, #0x8]
700ab00c: fbb0 f0f1    	udiv	r0, r0, r1
700ab010: 9001         	str	r0, [sp, #0x4]
;         ClockP_sleepTicks(ticksToSleep);
700ab012: 9801         	ldr	r0, [sp, #0x4]
700ab014: f004 fd7c    	bl	0x700afb10 <ClockP_sleepTicks> @ imm = #0x4af8
;     }
700ab018: e012         	b	0x700ab040 <ClockP_usleep+0x70> @ imm = #0x24
;         curTime = ClockP_getTimeUsec();
700ab01a: f7ff fcd9    	bl	0x700aa9d0 <ClockP_getTimeUsec> @ imm = #-0x64e
700ab01e: 9105         	str	r1, [sp, #0x14]
700ab020: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700ab022: e7ff         	b	0x700ab024 <ClockP_usleep+0x54> @ imm = #-0x2
700ab024: 9a04         	ldr	r2, [sp, #0x10]
700ab026: 9805         	ldr	r0, [sp, #0x14]
700ab028: 9b02         	ldr	r3, [sp, #0x8]
700ab02a: 9903         	ldr	r1, [sp, #0xc]
700ab02c: 1ad2         	subs	r2, r2, r3
700ab02e: 4188         	sbcs	r0, r1
700ab030: d205         	bhs	0x700ab03e <ClockP_usleep+0x6e> @ imm = #0xa
700ab032: e7ff         	b	0x700ab034 <ClockP_usleep+0x64> @ imm = #-0x2
;             curTime = ClockP_getTimeUsec();
700ab034: f7ff fccc    	bl	0x700aa9d0 <ClockP_getTimeUsec> @ imm = #-0x668
700ab038: 9105         	str	r1, [sp, #0x14]
700ab03a: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700ab03c: e7f2         	b	0x700ab024 <ClockP_usleep+0x54> @ imm = #-0x1c
700ab03e: e7ff         	b	0x700ab040 <ClockP_usleep+0x70> @ imm = #-0x2
; }
700ab040: b008         	add	sp, #0x20
700ab042: bd80         	pop	{r7, pc}
		...

700ab050 <Udma_chEnable>:
; {
700ab050: b580         	push	{r7, lr}
700ab052: b084         	sub	sp, #0x10
700ab054: 9003         	str	r0, [sp, #0xc]
700ab056: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700ab058: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700ab05a: 9803         	ldr	r0, [sp, #0xc]
700ab05c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700ab05e: 9800         	ldr	r0, [sp]
700ab060: b150         	cbz	r0, 0x700ab078 <Udma_chEnable+0x28> @ imm = #0x14
700ab062: e7ff         	b	0x700ab064 <Udma_chEnable+0x14> @ imm = #-0x2
700ab064: 9800         	ldr	r0, [sp]
700ab066: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700ab06a: f64a 31cd    	movw	r1, #0xabcd
700ab06e: f6ca 31dc    	movt	r1, #0xabdc
700ab072: 4288         	cmp	r0, r1
700ab074: d004         	beq	0x700ab080 <Udma_chEnable+0x30> @ imm = #0x8
700ab076: e7ff         	b	0x700ab078 <Udma_chEnable+0x28> @ imm = #-0x2
700ab078: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700ab07c: 9002         	str	r0, [sp, #0x8]
;     }
700ab07e: e7ff         	b	0x700ab080 <Udma_chEnable+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab080: 9802         	ldr	r0, [sp, #0x8]
700ab082: b9a8         	cbnz	r0, 0x700ab0b0 <Udma_chEnable+0x60> @ imm = #0x2a
700ab084: e7ff         	b	0x700ab086 <Udma_chEnable+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700ab086: 9800         	ldr	r0, [sp]
700ab088: 6e80         	ldr	r0, [r0, #0x68]
700ab08a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700ab08c: 9801         	ldr	r0, [sp, #0x4]
700ab08e: b150         	cbz	r0, 0x700ab0a6 <Udma_chEnable+0x56> @ imm = #0x14
700ab090: e7ff         	b	0x700ab092 <Udma_chEnable+0x42> @ imm = #-0x2
700ab092: 9801         	ldr	r0, [sp, #0x4]
700ab094: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700ab098: f64a 31cd    	movw	r1, #0xabcd
700ab09c: f6ca 31dc    	movt	r1, #0xabdc
700ab0a0: 4288         	cmp	r0, r1
700ab0a2: d004         	beq	0x700ab0ae <Udma_chEnable+0x5e> @ imm = #0x8
700ab0a4: e7ff         	b	0x700ab0a6 <Udma_chEnable+0x56> @ imm = #-0x2
700ab0a6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700ab0aa: 9002         	str	r0, [sp, #0x8]
;         }
700ab0ac: e7ff         	b	0x700ab0ae <Udma_chEnable+0x5e> @ imm = #-0x2
;     }
700ab0ae: e7ff         	b	0x700ab0b0 <Udma_chEnable+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab0b0: 9802         	ldr	r0, [sp, #0x8]
700ab0b2: b920         	cbnz	r0, 0x700ab0be <Udma_chEnable+0x6e> @ imm = #0x8
700ab0b4: e7ff         	b	0x700ab0b6 <Udma_chEnable+0x66> @ imm = #-0x2
;         Udma_chEnableLocal(chHandleInt);
700ab0b6: 9800         	ldr	r0, [sp]
700ab0b8: f7f5 fe0a    	bl	0x700a0cd0 <Udma_chEnableLocal> @ imm = #-0xa3ec
;     }
700ab0bc: e7ff         	b	0x700ab0be <Udma_chEnable+0x6e> @ imm = #-0x2
;     return (retVal);
700ab0be: 9802         	ldr	r0, [sp, #0x8]
700ab0c0: b004         	add	sp, #0x10
700ab0c2: bd80         	pop	{r7, pc}
		...

700ab0d0 <CSL_bcdmaChanOpTriggerChan>:
; {
700ab0d0: b580         	push	{r7, lr}
700ab0d2: b084         	sub	sp, #0x10
700ab0d4: 9003         	str	r0, [sp, #0xc]
700ab0d6: 9102         	str	r1, [sp, #0x8]
700ab0d8: 9201         	str	r2, [sp, #0x4]
700ab0da: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700ab0dc: 9000         	str	r0, [sp]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700ab0de: 9802         	ldr	r0, [sp, #0x8]
700ab0e0: b950         	cbnz	r0, 0x700ab0f8 <CSL_bcdmaChanOpTriggerChan+0x28> @ imm = #0x14
700ab0e2: e7ff         	b	0x700ab0e4 <CSL_bcdmaChanOpTriggerChan+0x14> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_BCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab0e4: 9803         	ldr	r0, [sp, #0xc]
700ab0e6: 6880         	ldr	r0, [r0, #0x8]
700ab0e8: 9901         	ldr	r1, [sp, #0x4]
700ab0ea: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab0ee: 3008         	adds	r0, #0x8
700ab0f0: 2101         	movs	r1, #0x1
700ab0f2: f7f1 f80d    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0xefe6
;     }
700ab0f6: e021         	b	0x700ab13c <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #0x42
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700ab0f8: 9802         	ldr	r0, [sp, #0x8]
700ab0fa: 2801         	cmp	r0, #0x1
700ab0fc: d10a         	bne	0x700ab114 <CSL_bcdmaChanOpTriggerChan+0x44> @ imm = #0x14
700ab0fe: e7ff         	b	0x700ab100 <CSL_bcdmaChanOpTriggerChan+0x30> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_TXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab100: 9803         	ldr	r0, [sp, #0xc]
700ab102: 6900         	ldr	r0, [r0, #0x10]
700ab104: 9901         	ldr	r1, [sp, #0x4]
700ab106: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab10a: 3008         	adds	r0, #0x8
700ab10c: 2101         	movs	r1, #0x1
700ab10e: f7f0 ffff    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0xf002
;     }
700ab112: e012         	b	0x700ab13a <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #0x24
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700ab114: 9802         	ldr	r0, [sp, #0x8]
700ab116: 2802         	cmp	r0, #0x2
700ab118: d10a         	bne	0x700ab130 <CSL_bcdmaChanOpTriggerChan+0x60> @ imm = #0x14
700ab11a: e7ff         	b	0x700ab11c <CSL_bcdmaChanOpTriggerChan+0x4c> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_RXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab11c: 9803         	ldr	r0, [sp, #0xc]
700ab11e: 6980         	ldr	r0, [r0, #0x18]
700ab120: 9901         	ldr	r1, [sp, #0x4]
700ab122: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab126: 3008         	adds	r0, #0x8
700ab128: 2101         	movs	r1, #0x1
700ab12a: f7f0 fff1    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0xf01e
;     }
700ab12e: e003         	b	0x700ab138 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #0x6
700ab130: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700ab134: 9000         	str	r0, [sp]
700ab136: e7ff         	b	0x700ab138 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #-0x2
700ab138: e7ff         	b	0x700ab13a <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #-0x2
700ab13a: e7ff         	b	0x700ab13c <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #-0x2
;     return retVal;
700ab13c: 9800         	ldr	r0, [sp]
700ab13e: b004         	add	sp, #0x10
700ab140: bd80         	pop	{r7, pc}
		...
700ab14e: 0000         	movs	r0, r0

700ab150 <prvProcessExpiredTimer>:
;     {
700ab150: b580         	push	{r7, lr}
700ab152: b086         	sub	sp, #0x18
700ab154: 9005         	str	r0, [sp, #0x14]
700ab156: 9104         	str	r1, [sp, #0x10]
;         Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700ab158: f245 1024    	movw	r0, #0x5124
700ab15c: f2c7 0008    	movt	r0, #0x7008
700ab160: 6800         	ldr	r0, [r0]
700ab162: 68c0         	ldr	r0, [r0, #0xc]
700ab164: 68c0         	ldr	r0, [r0, #0xc]
700ab166: 9002         	str	r0, [sp, #0x8]
;         ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700ab168: 9802         	ldr	r0, [sp, #0x8]
700ab16a: 3004         	adds	r0, #0x4
700ab16c: f002 fa58    	bl	0x700ad620 <uxListRemove> @ imm = #0x24b0
;         if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700ab170: 9802         	ldr	r0, [sp, #0x8]
700ab172: f890 0028    	ldrb.w	r0, [r0, #0x28]
700ab176: 0740         	lsls	r0, r0, #0x1d
700ab178: 2800         	cmp	r0, #0x0
700ab17a: d515         	bpl	0x700ab1a8 <prvProcessExpiredTimer+0x58> @ imm = #0x2a
700ab17c: e7ff         	b	0x700ab17e <prvProcessExpiredTimer+0x2e> @ imm = #-0x2
;             if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
700ab17e: 9802         	ldr	r0, [sp, #0x8]
700ab180: 9b05         	ldr	r3, [sp, #0x14]
700ab182: 6981         	ldr	r1, [r0, #0x18]
700ab184: 4419         	add	r1, r3
700ab186: 9a04         	ldr	r2, [sp, #0x10]
700ab188: f7ff f92a    	bl	0x700aa3e0 <prvInsertTimerInActiveList> @ imm = #-0xdac
700ab18c: b150         	cbz	r0, 0x700ab1a4 <prvProcessExpiredTimer+0x54> @ imm = #0x14
700ab18e: e7ff         	b	0x700ab190 <prvProcessExpiredTimer+0x40> @ imm = #-0x2
;                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700ab190: 9802         	ldr	r0, [sp, #0x8]
700ab192: 9a05         	ldr	r2, [sp, #0x14]
700ab194: 4669         	mov	r1, sp
700ab196: 2300         	movs	r3, #0x0
700ab198: 600b         	str	r3, [r1]
700ab19a: 4619         	mov	r1, r3
700ab19c: f7fe fbf0    	bl	0x700a9980 <xTimerGenericCommand> @ imm = #-0x1820
700ab1a0: 9003         	str	r0, [sp, #0xc]
;             }
700ab1a2: e000         	b	0x700ab1a6 <prvProcessExpiredTimer+0x56> @ imm = #0x0
700ab1a4: e7ff         	b	0x700ab1a6 <prvProcessExpiredTimer+0x56> @ imm = #-0x2
;         }
700ab1a6: e007         	b	0x700ab1b8 <prvProcessExpiredTimer+0x68> @ imm = #0xe
;             pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700ab1a8: 9902         	ldr	r1, [sp, #0x8]
700ab1aa: f891 0028    	ldrb.w	r0, [r1, #0x28]
700ab1ae: f000 00fe    	and	r0, r0, #0xfe
700ab1b2: f881 0028    	strb.w	r0, [r1, #0x28]
700ab1b6: e7ff         	b	0x700ab1b8 <prvProcessExpiredTimer+0x68> @ imm = #-0x2
;         pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700ab1b8: 9802         	ldr	r0, [sp, #0x8]
700ab1ba: 6a01         	ldr	r1, [r0, #0x20]
700ab1bc: 4788         	blx	r1
;     }
700ab1be: b006         	add	sp, #0x18
700ab1c0: bd80         	pop	{r7, pc}
		...
700ab1ce: 0000         	movs	r0, r0

700ab1d0 <xTaskCreateStatic>:
;     StaticTask_t *const pxTaskBuffer) {
700ab1d0: b5b0         	push	{r4, r5, r7, lr}
700ab1d2: b08a         	sub	sp, #0x28
700ab1d4: f8dd c040    	ldr.w	r12, [sp, #0x40]
700ab1d8: f8dd c03c    	ldr.w	r12, [sp, #0x3c]
700ab1dc: f8dd c038    	ldr.w	r12, [sp, #0x38]
700ab1e0: 9009         	str	r0, [sp, #0x24]
700ab1e2: 9108         	str	r1, [sp, #0x20]
700ab1e4: 9207         	str	r2, [sp, #0x1c]
700ab1e6: 9306         	str	r3, [sp, #0x18]
;   if ((pxTaskBuffer != NULL) && (puxStackBuffer != NULL)) {
700ab1e8: 9810         	ldr	r0, [sp, #0x40]
700ab1ea: b320         	cbz	r0, 0x700ab236 <xTaskCreateStatic+0x66> @ imm = #0x48
700ab1ec: e7ff         	b	0x700ab1ee <xTaskCreateStatic+0x1e> @ imm = #-0x2
700ab1ee: 980f         	ldr	r0, [sp, #0x3c]
700ab1f0: b308         	cbz	r0, 0x700ab236 <xTaskCreateStatic+0x66> @ imm = #0x42
700ab1f2: e7ff         	b	0x700ab1f4 <xTaskCreateStatic+0x24> @ imm = #-0x2
;         pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures
700ab1f4: 9810         	ldr	r0, [sp, #0x40]
;     pxNewTCB = (TCB_t *)
700ab1f6: 9005         	str	r0, [sp, #0x14]
;     pxNewTCB->pxStack = (StackType_t *)puxStackBuffer;
700ab1f8: 980f         	ldr	r0, [sp, #0x3c]
700ab1fa: 9905         	ldr	r1, [sp, #0x14]
700ab1fc: 6308         	str	r0, [r1, #0x30]
;       pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
700ab1fe: 9905         	ldr	r1, [sp, #0x14]
700ab200: 2002         	movs	r0, #0x2
700ab202: f881 0081    	strb.w	r0, [r1, #0x81]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700ab206: 9809         	ldr	r0, [sp, #0x24]
700ab208: 9908         	ldr	r1, [sp, #0x20]
700ab20a: 9a07         	ldr	r2, [sp, #0x1c]
700ab20c: 9b06         	ldr	r3, [sp, #0x18]
;                          uxPriority, &xReturn, pxNewTCB, NULL);
700ab20e: f8dd c038    	ldr.w	r12, [sp, #0x38]
700ab212: 9c05         	ldr	r4, [sp, #0x14]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700ab214: 46ee         	mov	lr, sp
700ab216: 2500         	movs	r5, #0x0
700ab218: f8ce 500c    	str.w	r5, [lr, #0xc]
700ab21c: f8ce 4008    	str.w	r4, [lr, #0x8]
700ab220: ac04         	add	r4, sp, #0x10
700ab222: f8ce 4004    	str.w	r4, [lr, #0x4]
700ab226: f8ce c000    	str.w	r12, [lr]
700ab22a: f7f9 fce1    	bl	0x700a4bf0 <prvInitialiseNewTask> @ imm = #-0x663e
;     prvAddNewTaskToReadyList(pxNewTCB);
700ab22e: 9805         	ldr	r0, [sp, #0x14]
700ab230: f7f9 fe7e    	bl	0x700a4f30 <prvAddNewTaskToReadyList> @ imm = #-0x6304
;   } else {
700ab234: e002         	b	0x700ab23c <xTaskCreateStatic+0x6c> @ imm = #0x4
700ab236: 2000         	movs	r0, #0x0
;     xReturn = NULL;
700ab238: 9004         	str	r0, [sp, #0x10]
700ab23a: e7ff         	b	0x700ab23c <xTaskCreateStatic+0x6c> @ imm = #-0x2
;   return xReturn;
700ab23c: 9804         	ldr	r0, [sp, #0x10]
700ab23e: b00a         	add	sp, #0x28
700ab240: bdb0         	pop	{r4, r5, r7, pc}
		...
700ab24e: 0000         	movs	r0, r0

700ab250 <CSL_intaggrClrIntr>:
; {
700ab250: b580         	push	{r7, lr}
700ab252: b088         	sub	sp, #0x20
700ab254: 9007         	str	r0, [sp, #0x1c]
700ab256: 9106         	str	r1, [sp, #0x18]
700ab258: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t  retVal = CSL_EFAIL;
700ab25c: 9005         	str	r0, [sp, #0x14]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700ab25e: 9807         	ldr	r0, [sp, #0x1c]
700ab260: 9906         	ldr	r1, [sp, #0x18]
700ab262: f002 fdf5    	bl	0x700ade50 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x2bea
700ab266: b340         	cbz	r0, 0x700ab2ba <CSL_intaggrClrIntr+0x6a> @ imm = #0x50
700ab268: e7ff         	b	0x700ab26a <CSL_intaggrClrIntr+0x1a> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700ab26a: 9806         	ldr	r0, [sp, #0x18]
700ab26c: 0980         	lsrs	r0, r0, #0x6
700ab26e: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700ab270: 9806         	ldr	r0, [sp, #0x18]
700ab272: f000 003f    	and	r0, r0, #0x3f
700ab276: 9000         	str	r0, [sp]
;         regVal = (((uint64_t)1U) << bitNum);
700ab278: 9b00         	ldr	r3, [sp]
700ab27a: f1a3 0220    	sub.w	r2, r3, #0x20
700ab27e: 2101         	movs	r1, #0x1
700ab280: fa01 fc02    	lsl.w	r12, r1, r2
700ab284: f1c3 0020    	rsb.w	r0, r3, #0x20
700ab288: fa21 f000    	lsr.w	r0, r1, r0
700ab28c: 2a00         	cmp	r2, #0x0
700ab28e: bf58         	it	pl
700ab290: 4660         	movpl	r0, r12
700ab292: fa01 f103    	lsl.w	r1, r1, r3
700ab296: 2a00         	cmp	r2, #0x0
700ab298: bf58         	it	pl
700ab29a: 2100         	movpl	r1, #0x0
700ab29c: 9102         	str	r1, [sp, #0x8]
700ab29e: 9003         	str	r0, [sp, #0xc]
;         CSL_REG64_WR( &pCfg->pIntrRegs->VINT[regNum].STATUS_CLEAR, regVal );
700ab2a0: 9807         	ldr	r0, [sp, #0x1c]
700ab2a2: 6880         	ldr	r0, [r0, #0x8]
700ab2a4: 9901         	ldr	r1, [sp, #0x4]
700ab2a6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab2aa: 3018         	adds	r0, #0x18
700ab2ac: 9a02         	ldr	r2, [sp, #0x8]
700ab2ae: 9b03         	ldr	r3, [sp, #0xc]
700ab2b0: f004 fa4e    	bl	0x700af750 <CSL_REG64_WR_RAW> @ imm = #0x449c
700ab2b4: 2000         	movs	r0, #0x0
;         retVal = CSL_PASS;
700ab2b6: 9005         	str	r0, [sp, #0x14]
;     }
700ab2b8: e7ff         	b	0x700ab2ba <CSL_intaggrClrIntr+0x6a> @ imm = #-0x2
;     return retVal;
700ab2ba: 9805         	ldr	r0, [sp, #0x14]
700ab2bc: b008         	add	sp, #0x20
700ab2be: bd80         	pop	{r7, pc}

700ab2c0 <LowPrioTask>:
; {
700ab2c0: b5b0         	push	{r4, r5, r7, lr}
700ab2c2: f642 15f4    	movw	r5, #0x29f4
700ab2c6: 2400         	movs	r4, #0x0
700ab2c8: f2c7 050b    	movt	r5, #0x700b
700ab2cc: e00c         	b	0x700ab2e8 <LowPrioTask+0x28> @ imm = #0x18
700ab2ce: bf00         	nop
;          tm_mutex_put(SHARED_MUTEX_ID);
700ab2d0: 2001         	movs	r0, #0x1
700ab2d2: f004 f825    	bl	0x700af320 <tm_mutex_put> @ imm = #0x404a
;          inversion_count++; /* Completed inversion cycle */
700ab2d6: 6828         	ldr	r0, [r5]
700ab2d8: 3001         	adds	r0, #0x1
700ab2da: 6028         	str	r0, [r5]
;       tm_thread_sleep_ticks(1);
700ab2dc: 2001         	movs	r0, #0x1
700ab2de: f004 fd47    	bl	0x700afd70 <tm_thread_sleep_ticks> @ imm = #0x4a8e
;    for (int i = 0; i < ITERATION_COUNT; i++)
700ab2e2: 3401         	adds	r4, #0x1
700ab2e4: 2c20         	cmp	r4, #0x20
700ab2e6: d01e         	beq	0x700ab326 <LowPrioTask+0x66> @ imm = #0x3c
;       if (tm_mutex_get(SHARED_MUTEX_ID) == TM_SUCCESS)
700ab2e8: 2001         	movs	r0, #0x1
700ab2ea: f004 f8d9    	bl	0x700af4a0 <tm_mutex_get> @ imm = #0x41b2
700ab2ee: 2800         	cmp	r0, #0x0
700ab2f0: d1f4         	bne	0x700ab2dc <LowPrioTask+0x1c> @ imm = #-0x18
700ab2f2: e006         	b	0x700ab302 <LowPrioTask+0x42> @ imm = #0xc
700ab2f4: bf00         	nop
700ab2f6: bf00         	nop
700ab2f8: bf00         	nop
700ab2fa: bf00         	nop
700ab2fc: bf00         	nop
700ab2fe: bf00         	nop
;             __asm__ volatile("nop");
700ab300: bf00         	nop
;          while (tm_task_priority_get(LOW_TASK_ID) == LOW_TASK_PRIO)
700ab302: 2002         	movs	r0, #0x2
700ab304: f004 fa0c    	bl	0x700af720 <tm_task_priority_get> @ imm = #0x4418
700ab308: 2814         	cmp	r0, #0x14
700ab30a: d1e1         	bne	0x700ab2d0 <LowPrioTask+0x10> @ imm = #-0x3e
700ab30c: 2002         	movs	r0, #0x2
;             __asm__ volatile("nop");
700ab30e: bf00         	nop
;          while (tm_task_priority_get(LOW_TASK_ID) == LOW_TASK_PRIO)
700ab310: f004 fa06    	bl	0x700af720 <tm_task_priority_get> @ imm = #0x440c
700ab314: 2814         	cmp	r0, #0x14
700ab316: d1db         	bne	0x700ab2d0 <LowPrioTask+0x10> @ imm = #-0x4a
700ab318: 2002         	movs	r0, #0x2
;             __asm__ volatile("nop");
700ab31a: bf00         	nop
;          while (tm_task_priority_get(LOW_TASK_ID) == LOW_TASK_PRIO)
700ab31c: f004 fa00    	bl	0x700af720 <tm_task_priority_get> @ imm = #0x4400
700ab320: 2814         	cmp	r0, #0x14
700ab322: d0ed         	beq	0x700ab300 <LowPrioTask+0x40> @ imm = #-0x26
700ab324: e7d4         	b	0x700ab2d0 <LowPrioTask+0x10> @ imm = #-0x58
;    tm_thread_suspend(LOW_TASK_ID);
700ab326: 2002         	movs	r0, #0x2
700ab328: e8bd 40b0    	pop.w	{r4, r5, r7, lr}
700ab32c: f004 bae0    	b.w	0x700af8f0 <tm_thread_suspend> @ imm = #0x45c0

700ab330 <Sciclient_rmGetResourceRange>:
; {
700ab330: b580         	push	{r7, lr}
700ab332: b090         	sub	sp, #0x40
700ab334: 900f         	str	r0, [sp, #0x3c]
700ab336: 910e         	str	r1, [sp, #0x38]
700ab338: 920d         	str	r2, [sp, #0x34]
700ab33a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab33c: 900c         	str	r0, [sp, #0x30]
700ab33e: f44f 51a8    	mov.w	r1, #0x1500
;     sciReq.messageType    = TISCI_MSG_RM_GET_RESOURCE_RANGE;
700ab342: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700ab346: 2102         	movs	r1, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ab348: 9108         	str	r1, [sp, #0x20]
700ab34a: a904         	add	r1, sp, #0x10
;     sciReq.pReqPayload    = (const uint8_t *) &req_copy;
700ab34c: 9109         	str	r1, [sp, #0x24]
700ab34e: 210c         	movs	r1, #0xc
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ab350: 910a         	str	r1, [sp, #0x28]
;     sciReq.timeout        = timeout;
700ab352: 990d         	ldr	r1, [sp, #0x34]
700ab354: 910b         	str	r1, [sp, #0x2c]
;     sciResp.flags           = 0;
700ab356: 9001         	str	r0, [sp, #0x4]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ab358: 980e         	ldr	r0, [sp, #0x38]
700ab35a: 9002         	str	r0, [sp, #0x8]
700ab35c: 2010         	movs	r0, #0x10
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ab35e: 9003         	str	r0, [sp, #0xc]
;     memcpy(&req_copy, req, sizeof(struct tisci_msg_rm_get_resource_range_req));
700ab360: 9a0f         	ldr	r2, [sp, #0x3c]
700ab362: 6810         	ldr	r0, [r2]
700ab364: 6851         	ldr	r1, [r2, #0x4]
700ab366: 6892         	ldr	r2, [r2, #0x8]
700ab368: 9206         	str	r2, [sp, #0x18]
700ab36a: 9105         	str	r1, [sp, #0x14]
700ab36c: 9004         	str	r0, [sp, #0x10]
;     if (SystemP_SUCCESS == r)
700ab36e: 980c         	ldr	r0, [sp, #0x30]
700ab370: b930         	cbnz	r0, 0x700ab380 <Sciclient_rmGetResourceRange+0x50> @ imm = #0xc
700ab372: e7ff         	b	0x700ab374 <Sciclient_rmGetResourceRange+0x44> @ imm = #-0x2
700ab374: a807         	add	r0, sp, #0x1c
700ab376: a901         	add	r1, sp, #0x4
;         r = Sciclient_service(&sciReq, &sciResp);
700ab378: f7f1 ff02    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xe1fc
700ab37c: 900c         	str	r0, [sp, #0x30]
;     }
700ab37e: e7ff         	b	0x700ab380 <Sciclient_rmGetResourceRange+0x50> @ imm = #-0x2
;     if ((r != SystemP_SUCCESS) ||
700ab380: 980c         	ldr	r0, [sp, #0x30]
700ab382: b930         	cbnz	r0, 0x700ab392 <Sciclient_rmGetResourceRange+0x62> @ imm = #0xc
700ab384: e7ff         	b	0x700ab386 <Sciclient_rmGetResourceRange+0x56> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ab386: 9801         	ldr	r0, [sp, #0x4]
700ab388: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ab38c: 2802         	cmp	r0, #0x2
700ab38e: d004         	beq	0x700ab39a <Sciclient_rmGetResourceRange+0x6a> @ imm = #0x8
700ab390: e7ff         	b	0x700ab392 <Sciclient_rmGetResourceRange+0x62> @ imm = #-0x2
700ab392: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ab396: 900c         	str	r0, [sp, #0x30]
;     }
700ab398: e7ff         	b	0x700ab39a <Sciclient_rmGetResourceRange+0x6a> @ imm = #-0x2
;     return r;
700ab39a: 980c         	ldr	r0, [sp, #0x30]
700ab39c: b010         	add	sp, #0x40
700ab39e: bd80         	pop	{r7, pc}

700ab3a0 <Udma_rmFreeMappedRxCh>:
; {
700ab3a0: b580         	push	{r7, lr}
700ab3a2: b088         	sub	sp, #0x20
700ab3a4: 9007         	str	r0, [sp, #0x1c]
700ab3a6: 9106         	str	r1, [sp, #0x18]
700ab3a8: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ab3aa: 9806         	ldr	r0, [sp, #0x18]
700ab3ac: f500 70ea    	add.w	r0, r0, #0x1d4
700ab3b0: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ab3b2: 9806         	ldr	r0, [sp, #0x18]
700ab3b4: f500 609f    	add.w	r0, r0, #0x4f8
700ab3b8: f04f 31ff    	mov.w	r1, #0xffffffff
700ab3bc: f7ff f930    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0xda0
;     i = chNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700ab3c0: 9807         	ldr	r0, [sp, #0x1c]
700ab3c2: 9900         	ldr	r1, [sp]
700ab3c4: 9a05         	ldr	r2, [sp, #0x14]
700ab3c6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab3ca: 6e89         	ldr	r1, [r1, #0x68]
700ab3cc: 1a40         	subs	r0, r0, r1
700ab3ce: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700ab3d0: 9804         	ldr	r0, [sp, #0x10]
700ab3d2: 0940         	lsrs	r0, r0, #0x5
700ab3d4: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700ab3d6: 9804         	ldr	r0, [sp, #0x10]
700ab3d8: 9903         	ldr	r1, [sp, #0xc]
700ab3da: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ab3de: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700ab3e0: 9902         	ldr	r1, [sp, #0x8]
700ab3e2: 2001         	movs	r0, #0x1
700ab3e4: 4088         	lsls	r0, r1
700ab3e6: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedRxChFlag[mappedChGrp][offset] |= bitMask;
700ab3e8: 9a01         	ldr	r2, [sp, #0x4]
700ab3ea: 9806         	ldr	r0, [sp, #0x18]
700ab3ec: 9905         	ldr	r1, [sp, #0x14]
700ab3ee: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ab3f2: 9903         	ldr	r1, [sp, #0xc]
700ab3f4: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ab3f8: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700ab3fc: 4310         	orrs	r0, r2
700ab3fe: f8c1 0334    	str.w	r0, [r1, #0x334]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ab402: 9806         	ldr	r0, [sp, #0x18]
700ab404: f500 609f    	add.w	r0, r0, #0x4f8
700ab408: f000 fcd2    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x9a4
;     return;
700ab40c: b008         	add	sp, #0x20
700ab40e: bd80         	pop	{r7, pc}

700ab410 <Udma_rmFreeMappedTxCh>:
; {
700ab410: b580         	push	{r7, lr}
700ab412: b088         	sub	sp, #0x20
700ab414: 9007         	str	r0, [sp, #0x1c]
700ab416: 9106         	str	r1, [sp, #0x18]
700ab418: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ab41a: 9806         	ldr	r0, [sp, #0x18]
700ab41c: f500 70ea    	add.w	r0, r0, #0x1d4
700ab420: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ab422: 9806         	ldr	r0, [sp, #0x18]
700ab424: f500 609f    	add.w	r0, r0, #0x4f8
700ab428: f04f 31ff    	mov.w	r1, #0xffffffff
700ab42c: f7ff f8f8    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0xe10
;     i = chNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700ab430: 9807         	ldr	r0, [sp, #0x1c]
700ab432: 9900         	ldr	r1, [sp]
700ab434: 9a05         	ldr	r2, [sp, #0x14]
700ab436: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab43a: 6c89         	ldr	r1, [r1, #0x48]
700ab43c: 1a40         	subs	r0, r0, r1
700ab43e: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700ab440: 9804         	ldr	r0, [sp, #0x10]
700ab442: 0940         	lsrs	r0, r0, #0x5
700ab444: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700ab446: 9804         	ldr	r0, [sp, #0x10]
700ab448: 9903         	ldr	r1, [sp, #0xc]
700ab44a: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ab44e: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700ab450: 9902         	ldr	r1, [sp, #0x8]
700ab452: 2001         	movs	r0, #0x1
700ab454: 4088         	lsls	r0, r1
700ab456: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedTxChFlag[mappedChGrp][offset] |= bitMask;
700ab458: 9a01         	ldr	r2, [sp, #0x4]
700ab45a: 9806         	ldr	r0, [sp, #0x18]
700ab45c: 9905         	ldr	r1, [sp, #0x14]
700ab45e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ab462: 9903         	ldr	r1, [sp, #0xc]
700ab464: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ab468: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700ab46c: 4310         	orrs	r0, r2
700ab46e: f8c1 0324    	str.w	r0, [r1, #0x324]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ab472: 9806         	ldr	r0, [sp, #0x18]
700ab474: f500 609f    	add.w	r0, r0, #0x4f8
700ab478: f000 fc9a    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x934
;     return;
700ab47c: b008         	add	sp, #0x20
700ab47e: bd80         	pop	{r7, pc}

700ab480 <Sciclient_rmIaVintGetInfo>:
; {
700ab480: b580         	push	{r7, lr}
700ab482: b084         	sub	sp, #0x10
700ab484: f8ad 000e    	strh.w	r0, [sp, #0xe]
700ab488: f8ad 100c    	strh.w	r1, [sp, #0xc]
700ab48c: 9202         	str	r2, [sp, #0x8]
700ab48e: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab490: 9001         	str	r0, [sp, #0x4]
;     if (n_evts == NULL) {
700ab492: 9802         	ldr	r0, [sp, #0x8]
700ab494: b920         	cbnz	r0, 0x700ab4a0 <Sciclient_rmIaVintGetInfo+0x20> @ imm = #0x8
700ab496: e7ff         	b	0x700ab498 <Sciclient_rmIaVintGetInfo+0x18> @ imm = #-0x2
700ab498: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab49c: 9001         	str	r0, [sp, #0x4]
;     } else {
700ab49e: e018         	b	0x700ab4d2 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #0x30
;         inst = Sciclient_rmIaGetInst(id);
700ab4a0: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700ab4a4: f000 ffac    	bl	0x700ac400 <Sciclient_rmIaGetInst> @ imm = #0xf58
700ab4a8: 9000         	str	r0, [sp]
;         if (inst == NULL) {
700ab4aa: 9800         	ldr	r0, [sp]
700ab4ac: b920         	cbnz	r0, 0x700ab4b8 <Sciclient_rmIaVintGetInfo+0x38> @ imm = #0x8
700ab4ae: e7ff         	b	0x700ab4b0 <Sciclient_rmIaVintGetInfo+0x30> @ imm = #-0x2
700ab4b0: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700ab4b4: 9001         	str	r0, [sp, #0x4]
;         } else {
700ab4b6: e00b         	b	0x700ab4d0 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #0x16
;             if (vint >= inst->n_vint) {
700ab4b8: f8bd 000c    	ldrh.w	r0, [sp, #0xc]
700ab4bc: 9900         	ldr	r1, [sp]
700ab4be: 8989         	ldrh	r1, [r1, #0xc]
700ab4c0: 4288         	cmp	r0, r1
700ab4c2: db04         	blt	0x700ab4ce <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #0x8
700ab4c4: e7ff         	b	0x700ab4c6 <Sciclient_rmIaVintGetInfo+0x46> @ imm = #-0x2
700ab4c6: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700ab4ca: 9001         	str	r0, [sp, #0x4]
;             }
700ab4cc: e7ff         	b	0x700ab4ce <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #-0x2
700ab4ce: e7ff         	b	0x700ab4d0 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #-0x2
700ab4d0: e7ff         	b	0x700ab4d2 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ab4d2: 9801         	ldr	r0, [sp, #0x4]
700ab4d4: b940         	cbnz	r0, 0x700ab4e8 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #0x10
700ab4d6: e7ff         	b	0x700ab4d8 <Sciclient_rmIaVintGetInfo+0x58> @ imm = #-0x2
;         *n_evts = inst->vint_usage_count[vint];
700ab4d8: 9800         	ldr	r0, [sp]
700ab4da: 6900         	ldr	r0, [r0, #0x10]
700ab4dc: f8bd 100c    	ldrh.w	r1, [sp, #0xc]
700ab4e0: 5c40         	ldrb	r0, [r0, r1]
700ab4e2: 9902         	ldr	r1, [sp, #0x8]
700ab4e4: 7008         	strb	r0, [r1]
;     }
700ab4e6: e7ff         	b	0x700ab4e8 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #-0x2
;     return r;
700ab4e8: 9801         	ldr	r0, [sp, #0x4]
700ab4ea: b004         	add	sp, #0x10
700ab4ec: bd80         	pop	{r7, pc}
700ab4ee: 0000         	movs	r0, r0

700ab4f0 <SemaphoreP_constructMutex>:
; {
700ab4f0: b580         	push	{r7, lr}
700ab4f2: b086         	sub	sp, #0x18
700ab4f4: 9005         	str	r0, [sp, #0x14]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700ab4f6: 9805         	ldr	r0, [sp, #0x14]
700ab4f8: 9004         	str	r0, [sp, #0x10]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700ab4fa: f641 10eb    	movw	r0, #0x19eb
700ab4fe: f2c7 000b    	movt	r0, #0x700b
700ab502: 4669         	mov	r1, sp
700ab504: 6008         	str	r0, [r1]
700ab506: f641 41cb    	movw	r1, #0x1ccb
700ab50a: f2c7 010b    	movt	r1, #0x700b
700ab50e: f641 628a    	movw	r2, #0x1e8a
700ab512: f2c7 020b    	movt	r2, #0x700b
700ab516: 2001         	movs	r0, #0x1
700ab518: 9002         	str	r0, [sp, #0x8]
700ab51a: 2370         	movs	r3, #0x70
700ab51c: f7ff fad8    	bl	0x700aaad0 <_DebugP_assert> @ imm = #-0xa50
700ab520: 9802         	ldr	r0, [sp, #0x8]
;     pSemaphore->isRecursiveMutex = 1;
700ab522: 9904         	ldr	r1, [sp, #0x10]
700ab524: 6548         	str	r0, [r1, #0x54]
;     pSemaphore->semHndl = xSemaphoreCreateRecursiveMutexStatic(&pSemaphore->semObj);
700ab526: 9904         	ldr	r1, [sp, #0x10]
700ab528: 2004         	movs	r0, #0x4
700ab52a: f003 f8e9    	bl	0x700ae700 <xQueueCreateMutexStatic> @ imm = #0x31d2
700ab52e: 9904         	ldr	r1, [sp, #0x10]
700ab530: 6508         	str	r0, [r1, #0x50]
;     if( pSemaphore->semHndl == NULL )
700ab532: 9804         	ldr	r0, [sp, #0x10]
700ab534: 6d00         	ldr	r0, [r0, #0x50]
700ab536: b920         	cbnz	r0, 0x700ab542 <SemaphoreP_constructMutex+0x52> @ imm = #0x8
700ab538: e7ff         	b	0x700ab53a <SemaphoreP_constructMutex+0x4a> @ imm = #-0x2
700ab53a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ab53e: 9003         	str	r0, [sp, #0xc]
;     }
700ab540: e00a         	b	0x700ab558 <SemaphoreP_constructMutex+0x68> @ imm = #0x14
;         vQueueAddToRegistry(pSemaphore->semHndl, "Mutex (DPL)");
700ab542: 9804         	ldr	r0, [sp, #0x10]
700ab544: 6d00         	ldr	r0, [r0, #0x50]
700ab546: f242 1130    	movw	r1, #0x2130
700ab54a: f2c7 010b    	movt	r1, #0x700b
700ab54e: f001 fd17    	bl	0x700acf80 <vQueueAddToRegistry> @ imm = #0x1a2e
700ab552: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700ab554: 9003         	str	r0, [sp, #0xc]
700ab556: e7ff         	b	0x700ab558 <SemaphoreP_constructMutex+0x68> @ imm = #-0x2
;     return status;
700ab558: 9803         	ldr	r0, [sp, #0xc]
700ab55a: b006         	add	sp, #0x18
700ab55c: bd80         	pop	{r7, pc}
700ab55e: 0000         	movs	r0, r0

700ab560 <UdmaChPrms_init>:
; {
700ab560: b580         	push	{r7, lr}
700ab562: b082         	sub	sp, #0x8
700ab564: 9001         	str	r0, [sp, #0x4]
700ab566: 9100         	str	r1, [sp]
;     if(NULL_PTR != chPrms)
700ab568: 9801         	ldr	r0, [sp, #0x4]
700ab56a: b368         	cbz	r0, 0x700ab5c8 <UdmaChPrms_init+0x68> @ imm = #0x5a
700ab56c: e7ff         	b	0x700ab56e <UdmaChPrms_init+0xe> @ imm = #-0x2
;         chPrms->chNum       = UDMA_DMA_CH_ANY;
700ab56e: 9901         	ldr	r1, [sp, #0x4]
700ab570: 2001         	movs	r0, #0x1
700ab572: f6cf 70ff    	movt	r0, #0xffff
700ab576: 6008         	str	r0, [r1]
;         chPrms->peerChNum   = UDMA_DMA_CH_INVALID;
700ab578: 9901         	ldr	r1, [sp, #0x4]
700ab57a: 2000         	movs	r0, #0x0
700ab57c: f6cf 70ff    	movt	r0, #0xffff
700ab580: 6048         	str	r0, [r1, #0x4]
;         if(UDMA_CH_TYPE_TR_BLK_COPY == chType)
700ab582: 9800         	ldr	r0, [sp]
700ab584: 2807         	cmp	r0, #0x7
700ab586: d106         	bne	0x700ab596 <UdmaChPrms_init+0x36> @ imm = #0xc
700ab588: e7ff         	b	0x700ab58a <UdmaChPrms_init+0x2a> @ imm = #-0x2
;             chPrms->peerChNum   = UDMA_DMA_CH_NA;
700ab58a: 9901         	ldr	r1, [sp, #0x4]
700ab58c: 2002         	movs	r0, #0x2
700ab58e: f6cf 70ff    	movt	r0, #0xffff
700ab592: 6048         	str	r0, [r1, #0x4]
;         }
700ab594: e7ff         	b	0x700ab596 <UdmaChPrms_init+0x36> @ imm = #-0x2
;         chPrms->mappedChGrp = UDMA_MAPPED_GROUP_INVALID;
700ab596: 9901         	ldr	r1, [sp, #0x4]
700ab598: 2004         	movs	r0, #0x4
700ab59a: f6cf 70ff    	movt	r0, #0xffff
700ab59e: 6088         	str	r0, [r1, #0x8]
;         chPrms->appData     = NULL_PTR;
700ab5a0: 9901         	ldr	r1, [sp, #0x4]
700ab5a2: 2000         	movs	r0, #0x0
700ab5a4: 60c8         	str	r0, [r1, #0xc]
;         UdmaRingPrms_init(&chPrms->fqRingPrms);
700ab5a6: 9801         	ldr	r0, [sp, #0x4]
700ab5a8: 3010         	adds	r0, #0x10
700ab5aa: f001 fbf9    	bl	0x700acda0 <UdmaRingPrms_init> @ imm = #0x17f2
;         UdmaRingPrms_init(&chPrms->cqRingPrms);
700ab5ae: 9801         	ldr	r0, [sp, #0x4]
700ab5b0: 302c         	adds	r0, #0x2c
700ab5b2: f001 fbf5    	bl	0x700acda0 <UdmaRingPrms_init> @ imm = #0x17ea
;         UdmaRingPrms_init(&chPrms->tdCqRingPrms);
700ab5b6: 9801         	ldr	r0, [sp, #0x4]
700ab5b8: 3048         	adds	r0, #0x48
700ab5ba: f001 fbf1    	bl	0x700acda0 <UdmaRingPrms_init> @ imm = #0x17e2
;         chPrms->tdCqRingPrms.elemSize = UDMA_RING_ES_8BYTES;
700ab5be: 9901         	ldr	r1, [sp, #0x4]
700ab5c0: 2001         	movs	r0, #0x1
700ab5c2: f881 0058    	strb.w	r0, [r1, #0x58]
;     }
700ab5c6: e7ff         	b	0x700ab5c8 <UdmaChPrms_init+0x68> @ imm = #-0x2
;     return;
700ab5c8: b002         	add	sp, #0x8
700ab5ca: bd80         	pop	{r7, pc}

700ab5cc <atoi>:
700ab5cc: e59f1060     	ldr	r1, [pc, #0x60]         @ 0x700ab634 <atoi+0x68>
700ab5d0: e4d02001     	ldrb	r2, [r0], #1
700ab5d4: e0813002     	add	r3, r1, r2
700ab5d8: e5d33001     	ldrb	r3, [r3, #0x1]
700ab5dc: e3130010     	tst	r3, #16
700ab5e0: 1afffffa     	bne	0x700ab5d0 <atoi+0x4>   @ imm = #-0x18
700ab5e4: e3a01000     	mov	r1, #0
700ab5e8: e352002b     	cmp	r2, #43
700ab5ec: 1352002d     	cmpne	r2, #45
700ab5f0: 0a000003     	beq	0x700ab604 <atoi+0x38>  @ imm = #0xc
700ab5f4: e2400001     	sub	r0, r0, #1
700ab5f8: e3a01000     	mov	r1, #0
700ab5fc: e1a03002     	mov	r3, r2
700ab600: ea000000     	b	0x700ab608 <atoi+0x3c>  @ imm = #0x0
700ab604: e5d03000     	ldrb	r3, [r0]
700ab608: e2433030     	sub	r3, r3, #48
700ab60c: e3530009     	cmp	r3, #9
700ab610: 8a000003     	bhi	0x700ab624 <atoi+0x58>  @ imm = #0xc
700ab614: e0811101     	add	r1, r1, r1, lsl #2
700ab618: e2800001     	add	r0, r0, #1
700ab61c: e0831081     	add	r1, r3, r1, lsl #1
700ab620: eafffff7     	b	0x700ab604 <atoi+0x38>  @ imm = #-0x24
700ab624: e352002d     	cmp	r2, #45
700ab628: 02611000     	rsbeq	r1, r1, #0
700ab62c: e1a00001     	mov	r0, r1
700ab630: e12fff1e     	bx	lr
700ab634: c0 15 0b 70  	.word	0x700b15c0
700ab638: 00 00 00 00  	.word	0x00000000
700ab63c: 00 00 00 00  	.word	0x00000000

700ab640 <Pinmux_lockMMR>:
; {
700ab640: b580         	push	{r7, lr}
700ab642: b084         	sub	sp, #0x10
700ab644: 9003         	str	r0, [sp, #0xc]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700ab646: 9803         	ldr	r0, [sp, #0xc]
700ab648: b908         	cbnz	r0, 0x700ab64e <Pinmux_lockMMR+0xe> @ imm = #0x2
700ab64a: e7ff         	b	0x700ab64c <Pinmux_lockMMR+0xc> @ imm = #-0x2
;     }
700ab64c: e7ff         	b	0x700ab64e <Pinmux_lockMMR+0xe> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700ab64e: 9803         	ldr	r0, [sp, #0xc]
700ab650: 2801         	cmp	r0, #0x1
700ab652: d128         	bne	0x700ab6a6 <Pinmux_lockMMR+0x66> @ imm = #0x50
700ab654: e7ff         	b	0x700ab656 <Pinmux_lockMMR+0x16> @ imm = #-0x2
700ab656: f04f 6081    	mov.w	r0, #0x4080000
700ab65a: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700ab65c: 9100         	str	r1, [sp]
700ab65e: f7fa f9ff    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x5c02
700ab662: 9900         	ldr	r1, [sp]
700ab664: 9002         	str	r0, [sp, #0x8]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700ab666: 9802         	ldr	r0, [sp, #0x8]
700ab668: f241 0208    	movw	r2, #0x1008
700ab66c: 4410         	add	r0, r2
700ab66e: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700ab670: 9801         	ldr	r0, [sp, #0x4]
700ab672: f004 fa15    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x442a
700ab676: 9900         	ldr	r1, [sp]
;         kickAddr++;
700ab678: 9801         	ldr	r0, [sp, #0x4]
700ab67a: 3004         	adds	r0, #0x4
700ab67c: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700ab67e: 9801         	ldr	r0, [sp, #0x4]
700ab680: f004 fa0e    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x441c
700ab684: 9900         	ldr	r1, [sp]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700ab686: 9802         	ldr	r0, [sp, #0x8]
700ab688: f245 0208    	movw	r2, #0x5008
700ab68c: 4410         	add	r0, r2
700ab68e: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700ab690: 9801         	ldr	r0, [sp, #0x4]
700ab692: f004 fa05    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x440a
700ab696: 9900         	ldr	r1, [sp]
;         kickAddr++;
700ab698: 9801         	ldr	r0, [sp, #0x4]
700ab69a: 3004         	adds	r0, #0x4
700ab69c: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700ab69e: 9801         	ldr	r0, [sp, #0x4]
700ab6a0: f004 f9fe    	bl	0x700afaa0 <CSL_REG32_WR_RAW> @ imm = #0x43fc
;     }
700ab6a4: e7ff         	b	0x700ab6a6 <Pinmux_lockMMR+0x66> @ imm = #-0x2
;     return;
700ab6a6: b004         	add	sp, #0x10
700ab6a8: bd80         	pop	{r7, pc}
700ab6aa: 0000         	movs	r0, r0
700ab6ac: 0000         	movs	r0, r0
700ab6ae: 0000         	movs	r0, r0

700ab6b0 <vListInsert>:
; {
700ab6b0: b084         	sub	sp, #0x10
700ab6b2: 9003         	str	r0, [sp, #0xc]
700ab6b4: 9102         	str	r1, [sp, #0x8]
;     const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
700ab6b6: 9802         	ldr	r0, [sp, #0x8]
700ab6b8: 6800         	ldr	r0, [r0]
700ab6ba: 9000         	str	r0, [sp]
;     if( xValueOfInsertion == portMAX_DELAY )
700ab6bc: 9800         	ldr	r0, [sp]
700ab6be: 3001         	adds	r0, #0x1
700ab6c0: b920         	cbnz	r0, 0x700ab6cc <vListInsert+0x1c> @ imm = #0x8
700ab6c2: e7ff         	b	0x700ab6c4 <vListInsert+0x14> @ imm = #-0x2
;         pxIterator = pxList->xListEnd.pxPrevious;
700ab6c4: 9803         	ldr	r0, [sp, #0xc]
700ab6c6: 6900         	ldr	r0, [r0, #0x10]
700ab6c8: 9001         	str	r0, [sp, #0x4]
;     }
700ab6ca: e010         	b	0x700ab6ee <vListInsert+0x3e> @ imm = #0x20
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700ab6cc: 9803         	ldr	r0, [sp, #0xc]
700ab6ce: 3008         	adds	r0, #0x8
700ab6d0: 9001         	str	r0, [sp, #0x4]
700ab6d2: e7ff         	b	0x700ab6d4 <vListInsert+0x24> @ imm = #-0x2
700ab6d4: 9801         	ldr	r0, [sp, #0x4]
700ab6d6: 6840         	ldr	r0, [r0, #0x4]
700ab6d8: 6800         	ldr	r0, [r0]
700ab6da: 9900         	ldr	r1, [sp]
700ab6dc: 4288         	cmp	r0, r1
700ab6de: d805         	bhi	0x700ab6ec <vListInsert+0x3c> @ imm = #0xa
700ab6e0: e7ff         	b	0x700ab6e2 <vListInsert+0x32> @ imm = #-0x2
;         }
700ab6e2: e7ff         	b	0x700ab6e4 <vListInsert+0x34> @ imm = #-0x2
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700ab6e4: 9801         	ldr	r0, [sp, #0x4]
700ab6e6: 6840         	ldr	r0, [r0, #0x4]
700ab6e8: 9001         	str	r0, [sp, #0x4]
700ab6ea: e7f3         	b	0x700ab6d4 <vListInsert+0x24> @ imm = #-0x1a
700ab6ec: e7ff         	b	0x700ab6ee <vListInsert+0x3e> @ imm = #-0x2
;     pxNewListItem->pxNext = pxIterator->pxNext;
700ab6ee: 9801         	ldr	r0, [sp, #0x4]
700ab6f0: 6840         	ldr	r0, [r0, #0x4]
700ab6f2: 9902         	ldr	r1, [sp, #0x8]
700ab6f4: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxNext->pxPrevious = pxNewListItem;
700ab6f6: 9802         	ldr	r0, [sp, #0x8]
700ab6f8: 6841         	ldr	r1, [r0, #0x4]
700ab6fa: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxPrevious = pxIterator;
700ab6fc: 9801         	ldr	r0, [sp, #0x4]
700ab6fe: 9902         	ldr	r1, [sp, #0x8]
700ab700: 6088         	str	r0, [r1, #0x8]
;     pxIterator->pxNext = pxNewListItem;
700ab702: 9802         	ldr	r0, [sp, #0x8]
700ab704: 9901         	ldr	r1, [sp, #0x4]
700ab706: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxContainer = pxList;
700ab708: 9803         	ldr	r0, [sp, #0xc]
700ab70a: 9902         	ldr	r1, [sp, #0x8]
700ab70c: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700ab70e: 9903         	ldr	r1, [sp, #0xc]
700ab710: 6808         	ldr	r0, [r1]
700ab712: 3001         	adds	r0, #0x1
700ab714: 6008         	str	r0, [r1]
; }
700ab716: b004         	add	sp, #0x10
700ab718: 4770         	bx	lr
700ab71a: 0000         	movs	r0, r0
700ab71c: 0000         	movs	r0, r0
700ab71e: 0000         	movs	r0, r0

700ab720 <Sciclient_rmIrqCfgIsDirectEvent>:
; {
700ab720: b580         	push	{r7, lr}
700ab722: b082         	sub	sp, #0x8
700ab724: 9001         	str	r0, [sp, #0x4]
700ab726: 2000         	movs	r0, #0x0
;     bool r = false;
700ab728: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab72c: 9801         	ldr	r0, [sp, #0x4]
700ab72e: 2101         	movs	r1, #0x1
700ab730: f003 fa8e    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x351c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700ab734: b310         	cbz	r0, 0x700ab77c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x44
700ab736: e7ff         	b	0x700ab738 <Sciclient_rmIrqCfgIsDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab738: 9801         	ldr	r0, [sp, #0x4]
700ab73a: 2102         	movs	r1, #0x2
700ab73c: f003 fa88    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3510
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700ab740: b1e0         	cbz	r0, 0x700ab77c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x38
700ab742: e7ff         	b	0x700ab744 <Sciclient_rmIrqCfgIsDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab744: 9801         	ldr	r0, [sp, #0x4]
700ab746: 2104         	movs	r1, #0x4
700ab748: f003 fa82    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3504
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700ab74c: b1b0         	cbz	r0, 0x700ab77c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x2c
700ab74e: e7ff         	b	0x700ab750 <Sciclient_rmIrqCfgIsDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab750: 9801         	ldr	r0, [sp, #0x4]
700ab752: 2108         	movs	r1, #0x8
700ab754: f003 fa7c    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x34f8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700ab758: b180         	cbz	r0, 0x700ab77c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x20
700ab75a: e7ff         	b	0x700ab75c <Sciclient_rmIrqCfgIsDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab75c: 9801         	ldr	r0, [sp, #0x4]
700ab75e: 2110         	movs	r1, #0x10
700ab760: f003 fa76    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x34ec
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700ab764: b150         	cbz	r0, 0x700ab77c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x14
700ab766: e7ff         	b	0x700ab768 <Sciclient_rmIrqCfgIsDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab768: 9801         	ldr	r0, [sp, #0x4]
700ab76a: 2120         	movs	r1, #0x20
700ab76c: f003 fa70    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x34e0
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab770: b120         	cbz	r0, 0x700ab77c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x8
700ab772: e7ff         	b	0x700ab774 <Sciclient_rmIrqCfgIsDirectEvent+0x54> @ imm = #-0x2
700ab774: 2001         	movs	r0, #0x1
;         r = true;
700ab776: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab77a: e7ff         	b	0x700ab77c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700ab77c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab780: f000 0001    	and	r0, r0, #0x1
700ab784: b002         	add	sp, #0x8
700ab786: bd80         	pop	{r7, pc}
		...

700ab790 <Sciclient_rmIrqCfgIsDirectNonEvent>:
; {
700ab790: b580         	push	{r7, lr}
700ab792: b082         	sub	sp, #0x8
700ab794: 9001         	str	r0, [sp, #0x4]
700ab796: 2000         	movs	r0, #0x0
;     bool r = false;
700ab798: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab79c: 9801         	ldr	r0, [sp, #0x4]
700ab79e: 2101         	movs	r1, #0x1
700ab7a0: f003 fa56    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x34ac
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700ab7a4: b310         	cbz	r0, 0x700ab7ec <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x44
700ab7a6: e7ff         	b	0x700ab7a8 <Sciclient_rmIrqCfgIsDirectNonEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab7a8: 9801         	ldr	r0, [sp, #0x4]
700ab7aa: 2102         	movs	r1, #0x2
700ab7ac: f003 fa50    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x34a0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700ab7b0: b1e0         	cbz	r0, 0x700ab7ec <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x38
700ab7b2: e7ff         	b	0x700ab7b4 <Sciclient_rmIrqCfgIsDirectNonEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab7b4: 9801         	ldr	r0, [sp, #0x4]
700ab7b6: 2104         	movs	r1, #0x4
700ab7b8: f003 fa4a    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3494
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700ab7bc: b9b0         	cbnz	r0, 0x700ab7ec <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x2c
700ab7be: e7ff         	b	0x700ab7c0 <Sciclient_rmIrqCfgIsDirectNonEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab7c0: 9801         	ldr	r0, [sp, #0x4]
700ab7c2: 2108         	movs	r1, #0x8
700ab7c4: f003 fa44    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3488
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700ab7c8: b980         	cbnz	r0, 0x700ab7ec <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x20
700ab7ca: e7ff         	b	0x700ab7cc <Sciclient_rmIrqCfgIsDirectNonEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab7cc: 9801         	ldr	r0, [sp, #0x4]
700ab7ce: 2110         	movs	r1, #0x10
700ab7d0: f003 fa3e    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x347c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700ab7d4: b950         	cbnz	r0, 0x700ab7ec <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x14
700ab7d6: e7ff         	b	0x700ab7d8 <Sciclient_rmIrqCfgIsDirectNonEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab7d8: 9801         	ldr	r0, [sp, #0x4]
700ab7da: 2120         	movs	r1, #0x20
700ab7dc: f003 fa38    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3470
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab7e0: b920         	cbnz	r0, 0x700ab7ec <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x8
700ab7e2: e7ff         	b	0x700ab7e4 <Sciclient_rmIrqCfgIsDirectNonEvent+0x54> @ imm = #-0x2
700ab7e4: 2001         	movs	r0, #0x1
;         r = true;
700ab7e6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab7ea: e7ff         	b	0x700ab7ec <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #-0x2
;     return r;
700ab7ec: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab7f0: f000 0001    	and	r0, r0, #0x1
700ab7f4: b002         	add	sp, #0x8
700ab7f6: bd80         	pop	{r7, pc}
		...

700ab800 <Sciclient_rmIrqCfgIsEventToVintMappingOnly>:
; {
700ab800: b580         	push	{r7, lr}
700ab802: b082         	sub	sp, #0x8
700ab804: 9001         	str	r0, [sp, #0x4]
700ab806: 2000         	movs	r0, #0x0
;     bool r = false;
700ab808: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab80c: 9801         	ldr	r0, [sp, #0x4]
700ab80e: 2101         	movs	r1, #0x1
700ab810: f003 fa1e    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x343c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700ab814: bb10         	cbnz	r0, 0x700ab85c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x44
700ab816: e7ff         	b	0x700ab818 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab818: 9801         	ldr	r0, [sp, #0x4]
700ab81a: 2102         	movs	r1, #0x2
700ab81c: f003 fa18    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3430
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700ab820: b9e0         	cbnz	r0, 0x700ab85c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x38
700ab822: e7ff         	b	0x700ab824 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab824: 9801         	ldr	r0, [sp, #0x4]
700ab826: 2104         	movs	r1, #0x4
700ab828: f003 fa12    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3424
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700ab82c: b1b0         	cbz	r0, 0x700ab85c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x2c
700ab82e: e7ff         	b	0x700ab830 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab830: 9801         	ldr	r0, [sp, #0x4]
700ab832: 2108         	movs	r1, #0x8
700ab834: f003 fa0c    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3418
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700ab838: b180         	cbz	r0, 0x700ab85c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x20
700ab83a: e7ff         	b	0x700ab83c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab83c: 9801         	ldr	r0, [sp, #0x4]
700ab83e: 2110         	movs	r1, #0x10
700ab840: f003 fa06    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x340c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700ab844: b150         	cbz	r0, 0x700ab85c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x14
700ab846: e7ff         	b	0x700ab848 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab848: 9801         	ldr	r0, [sp, #0x4]
700ab84a: 2120         	movs	r1, #0x20
700ab84c: f003 fa00    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3400
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab850: b120         	cbz	r0, 0x700ab85c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x8
700ab852: e7ff         	b	0x700ab854 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x54> @ imm = #-0x2
700ab854: 2001         	movs	r0, #0x1
;         r = true;
700ab856: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab85a: e7ff         	b	0x700ab85c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #-0x2
;     return r;
700ab85c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab860: f000 0001    	and	r0, r0, #0x1
700ab864: b002         	add	sp, #0x8
700ab866: bd80         	pop	{r7, pc}
		...

700ab870 <Sciclient_rmIrqCfgIsOesOnly>:
; {
700ab870: b580         	push	{r7, lr}
700ab872: b082         	sub	sp, #0x8
700ab874: 9001         	str	r0, [sp, #0x4]
700ab876: 2000         	movs	r0, #0x0
;     bool r = false;
700ab878: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab87c: 9801         	ldr	r0, [sp, #0x4]
700ab87e: 2101         	movs	r1, #0x1
700ab880: f003 f9e6    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x33cc
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700ab884: bb10         	cbnz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x44
700ab886: e7ff         	b	0x700ab888 <Sciclient_rmIrqCfgIsOesOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab888: 9801         	ldr	r0, [sp, #0x4]
700ab88a: 2102         	movs	r1, #0x2
700ab88c: f003 f9e0    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x33c0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700ab890: b9e0         	cbnz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x38
700ab892: e7ff         	b	0x700ab894 <Sciclient_rmIrqCfgIsOesOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab894: 9801         	ldr	r0, [sp, #0x4]
700ab896: 2104         	movs	r1, #0x4
700ab898: f003 f9da    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x33b4
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700ab89c: b9b0         	cbnz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x2c
700ab89e: e7ff         	b	0x700ab8a0 <Sciclient_rmIrqCfgIsOesOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab8a0: 9801         	ldr	r0, [sp, #0x4]
700ab8a2: 2108         	movs	r1, #0x8
700ab8a4: f003 f9d4    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x33a8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700ab8a8: b980         	cbnz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x20
700ab8aa: e7ff         	b	0x700ab8ac <Sciclient_rmIrqCfgIsOesOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab8ac: 9801         	ldr	r0, [sp, #0x4]
700ab8ae: 2110         	movs	r1, #0x10
700ab8b0: f003 f9ce    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x339c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700ab8b4: b150         	cbz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x14
700ab8b6: e7ff         	b	0x700ab8b8 <Sciclient_rmIrqCfgIsOesOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab8b8: 9801         	ldr	r0, [sp, #0x4]
700ab8ba: 2120         	movs	r1, #0x20
700ab8bc: f003 f9c8    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3390
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab8c0: b920         	cbnz	r0, 0x700ab8cc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x8
700ab8c2: e7ff         	b	0x700ab8c4 <Sciclient_rmIrqCfgIsOesOnly+0x54> @ imm = #-0x2
700ab8c4: 2001         	movs	r0, #0x1
;         r = true;
700ab8c6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab8ca: e7ff         	b	0x700ab8cc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #-0x2
;     return r;
700ab8cc: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab8d0: f000 0001    	and	r0, r0, #0x1
700ab8d4: b002         	add	sp, #0x8
700ab8d6: bd80         	pop	{r7, pc}
		...

700ab8e0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent>:
; {
700ab8e0: b580         	push	{r7, lr}
700ab8e2: b082         	sub	sp, #0x8
700ab8e4: 9001         	str	r0, [sp, #0x4]
700ab8e6: 2000         	movs	r0, #0x0
;     bool r = false;
700ab8e8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab8ec: 9801         	ldr	r0, [sp, #0x4]
700ab8ee: 2101         	movs	r1, #0x1
700ab8f0: f003 f9ae    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x335c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700ab8f4: b310         	cbz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x44
700ab8f6: e7ff         	b	0x700ab8f8 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab8f8: 9801         	ldr	r0, [sp, #0x4]
700ab8fa: 2102         	movs	r1, #0x2
700ab8fc: f003 f9a8    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3350
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700ab900: b1e0         	cbz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x38
700ab902: e7ff         	b	0x700ab904 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab904: 9801         	ldr	r0, [sp, #0x4]
700ab906: 2104         	movs	r1, #0x4
700ab908: f003 f9a2    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3344
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700ab90c: b1b0         	cbz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x2c
700ab90e: e7ff         	b	0x700ab910 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab910: 9801         	ldr	r0, [sp, #0x4]
700ab912: 2108         	movs	r1, #0x8
700ab914: f003 f99c    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3338
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700ab918: b180         	cbz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x20
700ab91a: e7ff         	b	0x700ab91c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab91c: 9801         	ldr	r0, [sp, #0x4]
700ab91e: 2110         	movs	r1, #0x10
700ab920: f003 f996    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x332c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700ab924: b950         	cbnz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x14
700ab926: e7ff         	b	0x700ab928 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab928: 9801         	ldr	r0, [sp, #0x4]
700ab92a: 2120         	movs	r1, #0x20
700ab92c: f003 f990    	bl	0x700aec50 <Sciclient_rmParamIsValid> @ imm = #0x3320
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab930: b920         	cbnz	r0, 0x700ab93c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x8
700ab932: e7ff         	b	0x700ab934 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x54> @ imm = #-0x2
700ab934: 2001         	movs	r0, #0x1
;         r = true;
700ab936: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab93a: e7ff         	b	0x700ab93c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700ab93c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab940: f000 0001    	and	r0, r0, #0x1
700ab944: b002         	add	sp, #0x8
700ab946: bd80         	pop	{r7, pc}
		...

700ab950 <UART_divisorValCompute>:
; {
700ab950: b580         	push	{r7, lr}
700ab952: b088         	sub	sp, #0x20
700ab954: 9007         	str	r0, [sp, #0x1c]
700ab956: 9106         	str	r1, [sp, #0x18]
700ab958: 9205         	str	r2, [sp, #0x14]
700ab95a: 9304         	str	r3, [sp, #0x10]
700ab95c: 2000         	movs	r0, #0x0
;     uint32_t divisorValue = 0U;
700ab95e: 9003         	str	r0, [sp, #0xc]
;     uint32_t tempModeFlag = modeFlag & UART_MDR1_MODE_SELECT_MASK;
700ab960: 9805         	ldr	r0, [sp, #0x14]
700ab962: f000 0007    	and	r0, r0, #0x7
700ab966: 9002         	str	r0, [sp, #0x8]
;     switch (tempModeFlag)
700ab968: 9802         	ldr	r0, [sp, #0x8]
700ab96a: 9001         	str	r0, [sp, #0x4]
700ab96c: 2805         	cmp	r0, #0x5
700ab96e: d81f         	bhi	0x700ab9b0 <UART_divisorValCompute+0x60> @ imm = #0x3e
700ab970: 9901         	ldr	r1, [sp, #0x4]
700ab972: e8df f001    	tbb	[pc, r1]
700ab976: 03 03 1d 0a  	.word	0x0a1d0303
700ab97a: 12 1a        	.short	0x1a12
;             divisorValue = UART_divideRoundCloset(moduleClk, 16U * baudRate);
700ab97c: 9807         	ldr	r0, [sp, #0x1c]
700ab97e: 9906         	ldr	r1, [sp, #0x18]
700ab980: 0109         	lsls	r1, r1, #0x4
700ab982: f003 ff85    	bl	0x700af890 <UART_divideRoundCloset> @ imm = #0x3f0a
700ab986: 9003         	str	r0, [sp, #0xc]
;             break;
700ab988: e013         	b	0x700ab9b2 <UART_divisorValCompute+0x62> @ imm = #0x26
;             divisorValue = UART_divideRoundCloset(moduleClk, 13U * baudRate);
700ab98a: 9807         	ldr	r0, [sp, #0x1c]
700ab98c: 9906         	ldr	r1, [sp, #0x18]
700ab98e: 220d         	movs	r2, #0xd
700ab990: 4351         	muls	r1, r2, r1
700ab992: f003 ff7d    	bl	0x700af890 <UART_divideRoundCloset> @ imm = #0x3efa
700ab996: 9003         	str	r0, [sp, #0xc]
;             break;
700ab998: e00b         	b	0x700ab9b2 <UART_divisorValCompute+0x62> @ imm = #0x16
;             divisorValue = UART_divideRoundCloset(moduleClk, mirOverSampRate * baudRate);
700ab99a: 9807         	ldr	r0, [sp, #0x1c]
700ab99c: 9904         	ldr	r1, [sp, #0x10]
700ab99e: 9a06         	ldr	r2, [sp, #0x18]
700ab9a0: 4351         	muls	r1, r2, r1
700ab9a2: f003 ff75    	bl	0x700af890 <UART_divideRoundCloset> @ imm = #0x3eea
700ab9a6: 9003         	str	r0, [sp, #0xc]
;             break;
700ab9a8: e003         	b	0x700ab9b2 <UART_divisorValCompute+0x62> @ imm = #0x6
700ab9aa: 2000         	movs	r0, #0x0
;             divisorValue = 0U;
700ab9ac: 9003         	str	r0, [sp, #0xc]
;             break;
700ab9ae: e000         	b	0x700ab9b2 <UART_divisorValCompute+0x62> @ imm = #0x0
;             break;
700ab9b0: e7ff         	b	0x700ab9b2 <UART_divisorValCompute+0x62> @ imm = #-0x2
;     return divisorValue;
700ab9b2: 9803         	ldr	r0, [sp, #0xc]
700ab9b4: b008         	add	sp, #0x20
700ab9b6: bd80         	pop	{r7, pc}
		...

700ab9c0 <CSL_udmapCppi5SetIds>:
; {
700ab9c0: b085         	sub	sp, #0x14
700ab9c2: 9004         	str	r0, [sp, #0x10]
700ab9c4: 9103         	str	r1, [sp, #0xc]
700ab9c6: 9202         	str	r2, [sp, #0x8]
700ab9c8: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700ab9ca: 9803         	ldr	r0, [sp, #0xc]
700ab9cc: 2803         	cmp	r0, #0x3
700ab9ce: d114         	bne	0x700ab9fa <CSL_udmapCppi5SetIds+0x3a> @ imm = #0x28
700ab9d0: e7ff         	b	0x700ab9d2 <CSL_udmapCppi5SetIds+0x12> @ imm = #-0x2
;         v = ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo;
700ab9d2: 9804         	ldr	r0, [sp, #0x10]
700ab9d4: 6840         	ldr	r0, [r0, #0x4]
700ab9d6: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_TRPD_PKTINFO_PKTID_MASK | CSL_UDMAP_CPPI5_TRPD_PKTINFO_FLOWID_MASK);
700ab9d8: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab9dc: 0600         	lsls	r0, r0, #0x18
700ab9de: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700ab9e0: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_FLOWID, flowId );
700ab9e2: 9901         	ldr	r1, [sp, #0x4]
700ab9e4: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700ab9e8: f360 3197    	bfi	r1, r0, #14, #10
700ab9ec: 9800         	ldr	r0, [sp]
700ab9ee: 4308         	orrs	r0, r1
700ab9f0: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo = v;
700ab9f2: 9800         	ldr	r0, [sp]
700ab9f4: 9904         	ldr	r1, [sp, #0x10]
700ab9f6: 6048         	str	r0, [r1, #0x4]
;     }
700ab9f8: e013         	b	0x700aba22 <CSL_udmapCppi5SetIds+0x62> @ imm = #0x26
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1;
700ab9fa: 9804         	ldr	r0, [sp, #0x10]
700ab9fc: 6840         	ldr	r0, [r0, #0x4]
700ab9fe: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_PD_PKTINFO1_PKTID_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO1_FLOWID_MASK);
700aba00: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aba04: 0600         	lsls	r0, r0, #0x18
700aba06: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700aba08: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_FLOWID, flowId );
700aba0a: 9901         	ldr	r1, [sp, #0x4]
700aba0c: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700aba10: f360 3197    	bfi	r1, r0, #14, #10
700aba14: 9800         	ldr	r0, [sp]
700aba16: 4308         	orrs	r0, r1
700aba18: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1 = v;
700aba1a: 9800         	ldr	r0, [sp]
700aba1c: 9904         	ldr	r1, [sp, #0x10]
700aba1e: 6048         	str	r0, [r1, #0x4]
700aba20: e7ff         	b	0x700aba22 <CSL_udmapCppi5SetIds+0x62> @ imm = #-0x2
; }
700aba22: b005         	add	sp, #0x14
700aba24: 4770         	bx	lr
		...
700aba2e: 0000         	movs	r0, r0

700aba30 <Sciclient_rmIrGetInst>:
; {
700aba30: b083         	sub	sp, #0xc
700aba32: f8ad 000a    	strh.w	r0, [sp, #0xa]
700aba36: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIrInst *inst = NULL;
700aba38: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700aba3a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700aba3e: e7ff         	b	0x700aba40 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x2
700aba40: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700aba44: 2803         	cmp	r0, #0x3
700aba46: dc22         	bgt	0x700aba8e <Sciclient_rmIrGetInst+0x5e> @ imm = #0x44
700aba48: e7ff         	b	0x700aba4a <Sciclient_rmIrGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIrInstances[i].dev_id) {
700aba4a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700aba4e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700aba52: eb01 0241    	add.w	r2, r1, r1, lsl #1
700aba56: f242 71c4    	movw	r1, #0x27c4
700aba5a: f2c7 010b    	movt	r1, #0x700b
700aba5e: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700aba62: 4288         	cmp	r0, r1
700aba64: d10c         	bne	0x700aba80 <Sciclient_rmIrGetInst+0x50> @ imm = #0x18
700aba66: e7ff         	b	0x700aba68 <Sciclient_rmIrGetInst+0x38> @ imm = #-0x2
;             inst = &gRmIrInstances[i];
700aba68: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700aba6c: eb00 0140    	add.w	r1, r0, r0, lsl #1
700aba70: f242 70c4    	movw	r0, #0x27c4
700aba74: f2c7 000b    	movt	r0, #0x700b
700aba78: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700aba7c: 9001         	str	r0, [sp, #0x4]
;             break;
700aba7e: e006         	b	0x700aba8e <Sciclient_rmIrGetInst+0x5e> @ imm = #0xc
;     }
700aba80: e7ff         	b	0x700aba82 <Sciclient_rmIrGetInst+0x52> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700aba82: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700aba86: 3001         	adds	r0, #0x1
700aba88: f8ad 0002    	strh.w	r0, [sp, #0x2]
700aba8c: e7d8         	b	0x700aba40 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x50
;     return inst;
700aba8e: 9801         	ldr	r0, [sp, #0x4]
700aba90: b003         	add	sp, #0xc
700aba92: 4770         	bx	lr
		...

700abaa0 <UART_fifoRegisterWrite>:
; {
700abaa0: b580         	push	{r7, lr}
700abaa2: b088         	sub	sp, #0x20
700abaa4: 9007         	str	r0, [sp, #0x1c]
700abaa6: 9106         	str	r1, [sp, #0x18]
700abaa8: 2000         	movs	r0, #0x0
;     uint32_t isTxRxFifoEmpty = FALSE;
700abaaa: 9001         	str	r0, [sp, #0x4]
700abaac: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700abaae: 9807         	ldr	r0, [sp, #0x1c]
700abab0: 2180         	movs	r1, #0x80
700abab2: f000 fdc5    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #0xb8a
700abab6: 9901         	ldr	r1, [sp, #0x4]
700abab8: 9003         	str	r0, [sp, #0xc]
;     divLatchRegVal = UART_divisorLatchWrite(baseAddr, 0x0000U);
700ababa: 9807         	ldr	r0, [sp, #0x1c]
700ababc: f7f8 ff78    	bl	0x700a49b0 <UART_divisorLatchWrite> @ imm = #-0x7110
700abac0: 9005         	str	r0, [sp, #0x14]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
700abac2: 9807         	ldr	r0, [sp, #0x1c]
700abac4: f002 fa84    	bl	0x700adfd0 <UART_enhanFuncEnable> @ imm = #0x2508
700abac8: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_FCR, fcrValue);
700abaca: 9807         	ldr	r0, [sp, #0x1c]
700abacc: 3008         	adds	r0, #0x8
700abace: 9906         	ldr	r1, [sp, #0x18]
700abad0: f004 f836    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x406c
;     while(isTxRxFifoEmpty == FALSE)
700abad4: e7ff         	b	0x700abad6 <UART_fifoRegisterWrite+0x36> @ imm = #-0x2
700abad6: 9802         	ldr	r0, [sp, #0x8]
700abad8: b928         	cbnz	r0, 0x700abae6 <UART_fifoRegisterWrite+0x46> @ imm = #0xa
700abada: e7ff         	b	0x700abadc <UART_fifoRegisterWrite+0x3c> @ imm = #-0x2
;         isTxRxFifoEmpty = UART_IsTxRxFifoEmpty(baseAddr);
700abadc: 9807         	ldr	r0, [sp, #0x1c]
700abade: f002 fa57    	bl	0x700adf90 <UART_IsTxRxFifoEmpty> @ imm = #0x24ae
700abae2: 9002         	str	r0, [sp, #0x8]
;     while(isTxRxFifoEmpty == FALSE)
700abae4: e7f7         	b	0x700abad6 <UART_fifoRegisterWrite+0x36> @ imm = #-0x12
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
700abae6: 9807         	ldr	r0, [sp, #0x1c]
700abae8: 9904         	ldr	r1, [sp, #0x10]
700abaea: f002 fda9    	bl	0x700ae640 <UART_enhanFuncBitValRestore> @ imm = #0x2b52
;     (void) UART_divisorLatchWrite(baseAddr, divLatchRegVal);
700abaee: 9807         	ldr	r0, [sp, #0x1c]
700abaf0: 9905         	ldr	r1, [sp, #0x14]
700abaf2: f7f8 ff5d    	bl	0x700a49b0 <UART_divisorLatchWrite> @ imm = #-0x7146
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700abaf6: 9807         	ldr	r0, [sp, #0x1c]
700abaf8: 300c         	adds	r0, #0xc
700abafa: 9903         	ldr	r1, [sp, #0xc]
700abafc: f004 f820    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x4040
; }
700abb00: b008         	add	sp, #0x20
700abb02: bd80         	pop	{r7, pc}
		...

700abb10 <UART_lld_deInitDma>:
; {
700abb10: b580         	push	{r7, lr}
700abb12: b084         	sub	sp, #0x10
700abb14: 9003         	str	r0, [sp, #0xc]
700abb16: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700abb18: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700abb1a: 9803         	ldr	r0, [sp, #0xc]
700abb1c: b318         	cbz	r0, 0x700abb66 <UART_lld_deInitDma+0x56> @ imm = #0x46
700abb1e: e7ff         	b	0x700abb20 <UART_lld_deInitDma+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700abb20: 9903         	ldr	r1, [sp, #0xc]
700abb22: 2002         	movs	r0, #0x2
700abb24: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700abb26: 9803         	ldr	r0, [sp, #0xc]
700abb28: f7fe fbca    	bl	0x700aa2c0 <UART_lld_flushTxFifo> @ imm = #-0x186c
700abb2c: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700abb2e: 9802         	ldr	r0, [sp, #0x8]
700abb30: b9a0         	cbnz	r0, 0x700abb5c <UART_lld_deInitDma+0x4c> @ imm = #0x28
700abb32: e7ff         	b	0x700abb34 <UART_lld_deInitDma+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700abb34: 9803         	ldr	r0, [sp, #0xc]
700abb36: 6800         	ldr	r0, [r0]
700abb38: 2107         	movs	r1, #0x7
700abb3a: 9101         	str	r1, [sp, #0x4]
700abb3c: f7fa fb30    	bl	0x700a61a0 <UART_intrDisable> @ imm = #-0x59a0
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700abb40: 9803         	ldr	r0, [sp, #0xc]
700abb42: 6800         	ldr	r0, [r0]
700abb44: 2102         	movs	r1, #0x2
700abb46: f003 f8cb    	bl	0x700aece0 <UART_intr2Disable> @ imm = #0x3196
700abb4a: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700abb4c: 9803         	ldr	r0, [sp, #0xc]
700abb4e: 6800         	ldr	r0, [r0]
700abb50: f003 f90e    	bl	0x700aed70 <UART_operatingModeSelect> @ imm = #0x321c
;             hUart->state = UART_STATE_RESET;
700abb54: 9903         	ldr	r1, [sp, #0xc]
700abb56: 2000         	movs	r0, #0x0
700abb58: 6548         	str	r0, [r1, #0x54]
;         }
700abb5a: e7ff         	b	0x700abb5c <UART_lld_deInitDma+0x4c> @ imm = #-0x2
;         status = UART_lld_dmaDeInit(hUart);
700abb5c: 9803         	ldr	r0, [sp, #0xc]
700abb5e: f002 fa57    	bl	0x700ae010 <UART_lld_dmaDeInit> @ imm = #0x24ae
700abb62: 9002         	str	r0, [sp, #0x8]
;     }
700abb64: e003         	b	0x700abb6e <UART_lld_deInitDma+0x5e> @ imm = #0x6
700abb66: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700abb6a: 9002         	str	r0, [sp, #0x8]
700abb6c: e7ff         	b	0x700abb6e <UART_lld_deInitDma+0x5e> @ imm = #-0x2
;     return status;
700abb6e: 9802         	ldr	r0, [sp, #0x8]
700abb70: b004         	add	sp, #0x10
700abb72: bd80         	pop	{r7, pc}
		...

700abb80 <Udma_rmFreeEvent>:
; {
700abb80: b580         	push	{r7, lr}
700abb82: b088         	sub	sp, #0x20
700abb84: 9007         	str	r0, [sp, #0x1c]
700abb86: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abb88: 9806         	ldr	r0, [sp, #0x18]
700abb8a: f500 70ea    	add.w	r0, r0, #0x1d4
700abb8e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abb90: 9806         	ldr	r0, [sp, #0x18]
700abb92: f500 609f    	add.w	r0, r0, #0x4f8
700abb96: f04f 31ff    	mov.w	r1, #0xffffffff
700abb9a: f7fe fd41    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x157e
;     i = globalEvent - rmInitPrms->startGlobalEvent;
700abb9e: 9807         	ldr	r0, [sp, #0x1c]
700abba0: 9901         	ldr	r1, [sp, #0x4]
700abba2: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700abba6: 1a40         	subs	r0, r0, r1
700abba8: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abbaa: 9805         	ldr	r0, [sp, #0x14]
700abbac: 0940         	lsrs	r0, r0, #0x5
700abbae: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abbb0: 9805         	ldr	r0, [sp, #0x14]
700abbb2: 9904         	ldr	r1, [sp, #0x10]
700abbb4: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abbb8: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abbba: 9903         	ldr	r1, [sp, #0xc]
700abbbc: 2001         	movs	r0, #0x1
700abbbe: 4088         	lsls	r0, r1
700abbc0: 9002         	str	r0, [sp, #0x8]
;     drvHandle->globalEventFlag[offset] |= bitMask;
700abbc2: 9a02         	ldr	r2, [sp, #0x8]
700abbc4: 9806         	ldr	r0, [sp, #0x18]
700abbc6: 9904         	ldr	r1, [sp, #0x10]
700abbc8: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abbcc: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700abbd0: 4310         	orrs	r0, r2
700abbd2: f8c1 0424    	str.w	r0, [r1, #0x424]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abbd6: 9806         	ldr	r0, [sp, #0x18]
700abbd8: f500 609f    	add.w	r0, r0, #0x4f8
700abbdc: f000 f8e8    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x1d0
;     return;
700abbe0: b008         	add	sp, #0x20
700abbe2: bd80         	pop	{r7, pc}
		...

700abbf0 <Udma_rmFreeIrIntr>:
; {
700abbf0: b580         	push	{r7, lr}
700abbf2: b088         	sub	sp, #0x20
700abbf4: 9007         	str	r0, [sp, #0x1c]
700abbf6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abbf8: 9806         	ldr	r0, [sp, #0x18]
700abbfa: f500 70ea    	add.w	r0, r0, #0x1d4
700abbfe: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abc00: 9806         	ldr	r0, [sp, #0x18]
700abc02: f500 609f    	add.w	r0, r0, #0x4f8
700abc06: f04f 31ff    	mov.w	r1, #0xffffffff
700abc0a: f7fe fd09    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x15ee
;     i = irIntrNum - rmInitPrms->startIrIntr;
700abc0e: 9807         	ldr	r0, [sp, #0x1c]
700abc10: 9901         	ldr	r1, [sp, #0x4]
700abc12: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700abc16: 1a40         	subs	r0, r0, r1
700abc18: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abc1a: 9805         	ldr	r0, [sp, #0x14]
700abc1c: 0940         	lsrs	r0, r0, #0x5
700abc1e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abc20: 9805         	ldr	r0, [sp, #0x14]
700abc22: 9904         	ldr	r1, [sp, #0x10]
700abc24: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abc28: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abc2a: 9903         	ldr	r1, [sp, #0xc]
700abc2c: 2001         	movs	r0, #0x1
700abc2e: 4088         	lsls	r0, r1
700abc30: 9002         	str	r0, [sp, #0x8]
;     drvHandle->irIntrFlag[offset] |= bitMask;
700abc32: 9a02         	ldr	r2, [sp, #0x8]
700abc34: 9806         	ldr	r0, [sp, #0x18]
700abc36: 9904         	ldr	r1, [sp, #0x10]
700abc38: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abc3c: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700abc40: 4310         	orrs	r0, r2
700abc42: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abc46: 9806         	ldr	r0, [sp, #0x18]
700abc48: f500 609f    	add.w	r0, r0, #0x4f8
700abc4c: f000 f8b0    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0x160
;     return;
700abc50: b008         	add	sp, #0x20
700abc52: bd80         	pop	{r7, pc}
		...

700abc60 <Udma_rmFreeVintr>:
; {
700abc60: b580         	push	{r7, lr}
700abc62: b088         	sub	sp, #0x20
700abc64: 9007         	str	r0, [sp, #0x1c]
700abc66: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abc68: 9806         	ldr	r0, [sp, #0x18]
700abc6a: f500 70ea    	add.w	r0, r0, #0x1d4
700abc6e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abc70: 9806         	ldr	r0, [sp, #0x18]
700abc72: f500 609f    	add.w	r0, r0, #0x4f8
700abc76: f04f 31ff    	mov.w	r1, #0xffffffff
700abc7a: f7fe fcd1    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x165e
;     i = vintrNum - rmInitPrms->startVintr;
700abc7e: 9807         	ldr	r0, [sp, #0x1c]
700abc80: 9901         	ldr	r1, [sp, #0x4]
700abc82: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700abc86: 1a40         	subs	r0, r0, r1
700abc88: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abc8a: 9805         	ldr	r0, [sp, #0x14]
700abc8c: 0940         	lsrs	r0, r0, #0x5
700abc8e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abc90: 9805         	ldr	r0, [sp, #0x14]
700abc92: 9904         	ldr	r1, [sp, #0x10]
700abc94: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abc98: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abc9a: 9903         	ldr	r1, [sp, #0xc]
700abc9c: 2001         	movs	r0, #0x1
700abc9e: 4088         	lsls	r0, r1
700abca0: 9002         	str	r0, [sp, #0x8]
;     drvHandle->vintrFlag[offset] |= bitMask;
700abca2: 9a02         	ldr	r2, [sp, #0x8]
700abca4: 9806         	ldr	r0, [sp, #0x18]
700abca6: 9904         	ldr	r1, [sp, #0x10]
700abca8: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abcac: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700abcb0: 4310         	orrs	r0, r2
700abcb2: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abcb6: 9806         	ldr	r0, [sp, #0x18]
700abcb8: f500 609f    	add.w	r0, r0, #0x4f8
700abcbc: f000 f878    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #0xf0
;     return;
700abcc0: b008         	add	sp, #0x20
700abcc2: bd80         	pop	{r7, pc}
		...

700abcd0 <vApplicationLoadHook>:
; {
700abcd0: b580         	push	{r7, lr}
700abcd2: b082         	sub	sp, #0x8
;     uint64_t curUpdateTime = ClockP_getTimeUsec();
700abcd4: f7fe fe7c    	bl	0x700aa9d0 <ClockP_getTimeUsec> @ imm = #-0x1308
700abcd8: 9101         	str	r1, [sp, #0x4]
700abcda: 9000         	str	r0, [sp]
;     if( (curUpdateTime > lastUpdateTime) && ((curUpdateTime - lastUpdateTime) > (TaskP_LOAD_UPDATE_WINDOW_MSEC*1000u )) )
700abcdc: 9b00         	ldr	r3, [sp]
700abcde: 9901         	ldr	r1, [sp, #0x4]
700abce0: f642 10b8    	movw	r0, #0x29b8
700abce4: f2c7 000b    	movt	r0, #0x700b
700abce8: 6802         	ldr	r2, [r0]
700abcea: 6840         	ldr	r0, [r0, #0x4]
700abcec: 1ad2         	subs	r2, r2, r3
700abcee: 4188         	sbcs	r0, r1
700abcf0: d21e         	bhs	0x700abd30 <vApplicationLoadHook+0x60> @ imm = #0x3c
700abcf2: e7ff         	b	0x700abcf4 <vApplicationLoadHook+0x24> @ imm = #-0x2
700abcf4: 9900         	ldr	r1, [sp]
700abcf6: 9801         	ldr	r0, [sp, #0x4]
700abcf8: f642 12b8    	movw	r2, #0x29b8
700abcfc: f2c7 020b    	movt	r2, #0x700b
700abd00: 6813         	ldr	r3, [r2]
700abd02: 6852         	ldr	r2, [r2, #0x4]
700abd04: 1ac9         	subs	r1, r1, r3
700abd06: 4190         	sbcs	r0, r2
700abd08: f24a 1221    	movw	r2, #0xa121
700abd0c: f2c0 0207    	movt	r2, #0x7
700abd10: 1a89         	subs	r1, r1, r2
700abd12: f170 0000    	sbcs	r0, r0, #0x0
700abd16: d30b         	blo	0x700abd30 <vApplicationLoadHook+0x60> @ imm = #0x16
700abd18: e7ff         	b	0x700abd1a <vApplicationLoadHook+0x4a> @ imm = #-0x2
;         TaskP_loadUpdateAll();
700abd1a: f7f8 fca1    	bl	0x700a4660 <TaskP_loadUpdateAll> @ imm = #-0x76be
;         lastUpdateTime = curUpdateTime;
700abd1e: 9800         	ldr	r0, [sp]
700abd20: 9a01         	ldr	r2, [sp, #0x4]
700abd22: f642 11b8    	movw	r1, #0x29b8
700abd26: f2c7 010b    	movt	r1, #0x700b
700abd2a: 604a         	str	r2, [r1, #0x4]
700abd2c: 6008         	str	r0, [r1]
;     }
700abd2e: e7ff         	b	0x700abd30 <vApplicationLoadHook+0x60> @ imm = #-0x2
; }
700abd30: b002         	add	sp, #0x8
700abd32: bd80         	pop	{r7, pc}
		...

700abd40 <vQueueWaitForMessageRestricted>:
;     {
700abd40: b580         	push	{r7, lr}
700abd42: b084         	sub	sp, #0x10
700abd44: 9003         	str	r0, [sp, #0xc]
700abd46: 9102         	str	r1, [sp, #0x8]
700abd48: 9201         	str	r2, [sp, #0x4]
;         Queue_t * const pxQueue = xQueue;
700abd4a: 9803         	ldr	r0, [sp, #0xc]
700abd4c: 9000         	str	r0, [sp]
;         prvLockQueue( pxQueue );
700abd4e: f002 fcb7    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x296e
700abd52: 9800         	ldr	r0, [sp]
700abd54: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700abd58: 3001         	adds	r0, #0x1
700abd5a: b928         	cbnz	r0, 0x700abd68 <vQueueWaitForMessageRestricted+0x28> @ imm = #0xa
700abd5c: e7ff         	b	0x700abd5e <vQueueWaitForMessageRestricted+0x1e> @ imm = #-0x2
700abd5e: 9900         	ldr	r1, [sp]
700abd60: 2000         	movs	r0, #0x0
700abd62: f881 0044    	strb.w	r0, [r1, #0x44]
700abd66: e7ff         	b	0x700abd68 <vQueueWaitForMessageRestricted+0x28> @ imm = #-0x2
700abd68: 9800         	ldr	r0, [sp]
700abd6a: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700abd6e: 3001         	adds	r0, #0x1
700abd70: b928         	cbnz	r0, 0x700abd7e <vQueueWaitForMessageRestricted+0x3e> @ imm = #0xa
700abd72: e7ff         	b	0x700abd74 <vQueueWaitForMessageRestricted+0x34> @ imm = #-0x2
700abd74: 9900         	ldr	r1, [sp]
700abd76: 2000         	movs	r0, #0x0
700abd78: f881 0045    	strb.w	r0, [r1, #0x45]
700abd7c: e7ff         	b	0x700abd7e <vQueueWaitForMessageRestricted+0x3e> @ imm = #-0x2
700abd7e: f001 fd3f    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x1a7e
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
700abd82: 9800         	ldr	r0, [sp]
700abd84: 6b80         	ldr	r0, [r0, #0x38]
700abd86: b938         	cbnz	r0, 0x700abd98 <vQueueWaitForMessageRestricted+0x58> @ imm = #0xe
700abd88: e7ff         	b	0x700abd8a <vQueueWaitForMessageRestricted+0x4a> @ imm = #-0x2
;             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
700abd8a: 9800         	ldr	r0, [sp]
700abd8c: 3024         	adds	r0, #0x24
700abd8e: 9902         	ldr	r1, [sp, #0x8]
700abd90: 9a01         	ldr	r2, [sp, #0x4]
700abd92: f002 fb1d    	bl	0x700ae3d0 <vTaskPlaceOnEventListRestricted> @ imm = #0x263a
;         }
700abd96: e000         	b	0x700abd9a <vQueueWaitForMessageRestricted+0x5a> @ imm = #0x0
700abd98: e7ff         	b	0x700abd9a <vQueueWaitForMessageRestricted+0x5a> @ imm = #-0x2
;         prvUnlockQueue( pxQueue );
700abd9a: 9800         	ldr	r0, [sp]
700abd9c: f7fb ffa0    	bl	0x700a7ce0 <prvUnlockQueue> @ imm = #-0x40c0
;     }
700abda0: b004         	add	sp, #0x10
700abda2: bd80         	pop	{r7, pc}
		...

700abdb0 <SemaphoreP_post>:
; {
700abdb0: b580         	push	{r7, lr}
700abdb2: b084         	sub	sp, #0x10
700abdb4: 9003         	str	r0, [sp, #0xc]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700abdb6: 9803         	ldr	r0, [sp, #0xc]
700abdb8: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700abdba: 9802         	ldr	r0, [sp, #0x8]
700abdbc: 6d40         	ldr	r0, [r0, #0x54]
700abdbe: b170         	cbz	r0, 0x700abdde <SemaphoreP_post+0x2e> @ imm = #0x1c
700abdc0: e7ff         	b	0x700abdc2 <SemaphoreP_post+0x12> @ imm = #-0x2
;         if( HwiP_inISR() == 0U)
700abdc2: f004 facd    	bl	0x700b0360 <HwiP_inISR> @ imm = #0x459a
700abdc6: b928         	cbnz	r0, 0x700abdd4 <SemaphoreP_post+0x24> @ imm = #0xa
700abdc8: e7ff         	b	0x700abdca <SemaphoreP_post+0x1a> @ imm = #-0x2
;             (void)xSemaphoreGiveRecursive(pSemaphore->semHndl);
700abdca: 9802         	ldr	r0, [sp, #0x8]
700abdcc: 6d00         	ldr	r0, [r0, #0x50]
700abdce: f001 f95f    	bl	0x700ad090 <xQueueGiveMutexRecursive> @ imm = #0x12be
;         }
700abdd2: e003         	b	0x700abddc <SemaphoreP_post+0x2c> @ imm = #0x6
700abdd4: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700abdd6: f005 fa63    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x54c6
700abdda: e7ff         	b	0x700abddc <SemaphoreP_post+0x2c> @ imm = #-0x2
;     }
700abddc: e017         	b	0x700abe0e <SemaphoreP_post+0x5e> @ imm = #0x2e
;         if( HwiP_inISR() != 0U)
700abdde: f004 fabf    	bl	0x700b0360 <HwiP_inISR> @ imm = #0x457e
700abde2: b158         	cbz	r0, 0x700abdfc <SemaphoreP_post+0x4c> @ imm = #0x16
700abde4: e7ff         	b	0x700abde6 <SemaphoreP_post+0x36> @ imm = #-0x2
700abde6: 2000         	movs	r0, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700abde8: 9001         	str	r0, [sp, #0x4]
;             (void)xSemaphoreGiveFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700abdea: 9802         	ldr	r0, [sp, #0x8]
700abdec: 6d00         	ldr	r0, [r0, #0x50]
700abdee: a901         	add	r1, sp, #0x4
700abdf0: f7fd fd76    	bl	0x700a98e0 <xQueueGiveFromISR> @ imm = #-0x2514
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700abdf4: 9801         	ldr	r0, [sp, #0x4]
700abdf6: f003 fbc3    	bl	0x700af580 <vPortYeildFromISR> @ imm = #0x3786
;         }
700abdfa: e007         	b	0x700abe0c <SemaphoreP_post+0x5c> @ imm = #0xe
;             (void)xSemaphoreGive(pSemaphore->semHndl);
700abdfc: 9802         	ldr	r0, [sp, #0x8]
700abdfe: 6d00         	ldr	r0, [r0, #0x50]
700abe00: 2300         	movs	r3, #0x0
700abe02: 4619         	mov	r1, r3
700abe04: 461a         	mov	r2, r3
700abe06: f7f7 f99b    	bl	0x700a3140 <xQueueGenericSend> @ imm = #-0x8cca
700abe0a: e7ff         	b	0x700abe0c <SemaphoreP_post+0x5c> @ imm = #-0x2
700abe0c: e7ff         	b	0x700abe0e <SemaphoreP_post+0x5e> @ imm = #-0x2
; }
700abe0e: b004         	add	sp, #0x10
700abe10: bd80         	pop	{r7, pc}
		...
700abe1e: 0000         	movs	r0, r0

700abe20 <UdmaEventPrms_init>:
; {
700abe20: b082         	sub	sp, #0x8
700abe22: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventPrms)
700abe24: 9801         	ldr	r0, [sp, #0x4]
700abe26: b350         	cbz	r0, 0x700abe7e <UdmaEventPrms_init+0x5e> @ imm = #0x54
700abe28: e7ff         	b	0x700abe2a <UdmaEventPrms_init+0xa> @ imm = #-0x2
;         eventPrms->eventType            = UDMA_EVENT_TYPE_DMA_COMPLETION;
700abe2a: 9801         	ldr	r0, [sp, #0x4]
700abe2c: 2101         	movs	r1, #0x1
700abe2e: 6001         	str	r1, [r0]
;         eventPrms->eventMode            = UDMA_EVENT_MODE_SHARED;
700abe30: 9a01         	ldr	r2, [sp, #0x4]
700abe32: 2002         	movs	r0, #0x2
700abe34: 6050         	str	r0, [r2, #0x4]
;         eventPrms->chHandle             = (Udma_ChHandle) NULL_PTR;
700abe36: 9a01         	ldr	r2, [sp, #0x4]
700abe38: 2000         	movs	r0, #0x0
700abe3a: 9000         	str	r0, [sp]
700abe3c: 6090         	str	r0, [r2, #0x8]
;         eventPrms->ringHandle           = (Udma_RingHandle) NULL_PTR;
700abe3e: 9a01         	ldr	r2, [sp, #0x4]
700abe40: 60d0         	str	r0, [r2, #0xc]
;         eventPrms->controllerEventHandle    = (Udma_EventHandle) NULL_PTR;
700abe42: 9a01         	ldr	r2, [sp, #0x4]
700abe44: 6110         	str	r0, [r2, #0x10]
;         eventPrms->eventCb              = (Udma_EventCallback) NULL_PTR;
700abe46: 9a01         	ldr	r2, [sp, #0x4]
700abe48: 6150         	str	r0, [r2, #0x14]
;         eventPrms->intrPriority         = 1U;
700abe4a: 9a01         	ldr	r2, [sp, #0x4]
700abe4c: 6191         	str	r1, [r2, #0x18]
;         eventPrms->appData              = NULL_PTR;
700abe4e: 9901         	ldr	r1, [sp, #0x4]
700abe50: 61c8         	str	r0, [r1, #0x1c]
;         eventPrms->preferredCoreIntrNum = UDMA_CORE_INTR_ANY;
700abe52: 9a01         	ldr	r2, [sp, #0x4]
700abe54: 2101         	movs	r1, #0x1
700abe56: f6cf 71ff    	movt	r1, #0xffff
700abe5a: 6211         	str	r1, [r2, #0x20]
;         eventPrms->intrStatusReg        = (volatile uint64_t *) NULL_PTR;
700abe5c: 9901         	ldr	r1, [sp, #0x4]
700abe5e: 6248         	str	r0, [r1, #0x24]
;         eventPrms->intrClearReg         = (volatile uint64_t *) NULL_PTR;
700abe60: 9901         	ldr	r1, [sp, #0x4]
700abe62: 6288         	str	r0, [r1, #0x28]
;         eventPrms->intrMask             = 0U;
700abe64: 9901         	ldr	r1, [sp, #0x4]
700abe66: 6348         	str	r0, [r1, #0x34]
700abe68: 6308         	str	r0, [r1, #0x30]
;         eventPrms->vintrNum             = UDMA_EVENT_INVALID;
700abe6a: 9901         	ldr	r1, [sp, #0x4]
700abe6c: f64f 70ff    	movw	r0, #0xffff
700abe70: 6388         	str	r0, [r1, #0x38]
;         eventPrms->coreIntrNum          = UDMA_INTR_INVALID;
700abe72: 9901         	ldr	r1, [sp, #0x4]
700abe74: 2000         	movs	r0, #0x0
700abe76: f6cf 70ff    	movt	r0, #0xffff
700abe7a: 63c8         	str	r0, [r1, #0x3c]
;     }
700abe7c: e7ff         	b	0x700abe7e <UdmaEventPrms_init+0x5e> @ imm = #-0x2
;     return;
700abe7e: b002         	add	sp, #0x8
700abe80: 4770         	bx	lr
		...
700abe8e: 0000         	movs	r0, r0

700abe90 <Udma_rmFreeBlkCopyCh>:
; {
700abe90: b580         	push	{r7, lr}
700abe92: b088         	sub	sp, #0x20
700abe94: 9007         	str	r0, [sp, #0x1c]
700abe96: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abe98: 9806         	ldr	r0, [sp, #0x18]
700abe9a: f500 70ea    	add.w	r0, r0, #0x1d4
700abe9e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abea0: 9806         	ldr	r0, [sp, #0x18]
700abea2: f500 609f    	add.w	r0, r0, #0x4f8
700abea6: f04f 31ff    	mov.w	r1, #0xffffffff
700abeaa: f7fe fbb9    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x188e
;     i = chNum - rmInitPrms->startBlkCopyCh;
700abeae: 9807         	ldr	r0, [sp, #0x1c]
700abeb0: 9901         	ldr	r1, [sp, #0x4]
700abeb2: 6909         	ldr	r1, [r1, #0x10]
700abeb4: 1a40         	subs	r0, r0, r1
700abeb6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abeb8: 9805         	ldr	r0, [sp, #0x14]
700abeba: 0940         	lsrs	r0, r0, #0x5
700abebc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abebe: 9805         	ldr	r0, [sp, #0x14]
700abec0: 9904         	ldr	r1, [sp, #0x10]
700abec2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abec6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abec8: 9903         	ldr	r1, [sp, #0xc]
700abeca: 2001         	movs	r0, #0x1
700abecc: 4088         	lsls	r0, r1
700abece: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyChFlag[offset] |= bitMask;
700abed0: 9a02         	ldr	r2, [sp, #0x8]
700abed2: 9806         	ldr	r0, [sp, #0x18]
700abed4: 9904         	ldr	r1, [sp, #0x10]
700abed6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abeda: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700abede: 4310         	orrs	r0, r2
700abee0: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abee4: 9806         	ldr	r0, [sp, #0x18]
700abee6: f500 609f    	add.w	r0, r0, #0x4f8
700abeea: f7ff ff61    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #-0x13e
;     return;
700abeee: b008         	add	sp, #0x20
700abef0: bd80         	pop	{r7, pc}
		...
700abefe: 0000         	movs	r0, r0

700abf00 <Udma_rmFreeBlkCopyHcCh>:
; {
700abf00: b580         	push	{r7, lr}
700abf02: b088         	sub	sp, #0x20
700abf04: 9007         	str	r0, [sp, #0x1c]
700abf06: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abf08: 9806         	ldr	r0, [sp, #0x18]
700abf0a: f500 70ea    	add.w	r0, r0, #0x1d4
700abf0e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abf10: 9806         	ldr	r0, [sp, #0x18]
700abf12: f500 609f    	add.w	r0, r0, #0x4f8
700abf16: f04f 31ff    	mov.w	r1, #0xffffffff
700abf1a: f7fe fb81    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x18fe
;     i = chNum - rmInitPrms->startBlkCopyHcCh;
700abf1e: 9807         	ldr	r0, [sp, #0x1c]
700abf20: 9901         	ldr	r1, [sp, #0x4]
700abf22: 6889         	ldr	r1, [r1, #0x8]
700abf24: 1a40         	subs	r0, r0, r1
700abf26: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abf28: 9805         	ldr	r0, [sp, #0x14]
700abf2a: 0940         	lsrs	r0, r0, #0x5
700abf2c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abf2e: 9805         	ldr	r0, [sp, #0x14]
700abf30: 9904         	ldr	r1, [sp, #0x10]
700abf32: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abf36: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abf38: 9903         	ldr	r1, [sp, #0xc]
700abf3a: 2001         	movs	r0, #0x1
700abf3c: 4088         	lsls	r0, r1
700abf3e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyHcChFlag[offset] |= bitMask;
700abf40: 9a02         	ldr	r2, [sp, #0x8]
700abf42: 9806         	ldr	r0, [sp, #0x18]
700abf44: 9904         	ldr	r1, [sp, #0x10]
700abf46: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abf4a: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700abf4e: 4310         	orrs	r0, r2
700abf50: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abf54: 9806         	ldr	r0, [sp, #0x18]
700abf56: f500 609f    	add.w	r0, r0, #0x4f8
700abf5a: f7ff ff29    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #-0x1ae
;     return;
700abf5e: b008         	add	sp, #0x20
700abf60: bd80         	pop	{r7, pc}
		...
700abf6e: 0000         	movs	r0, r0

700abf70 <Udma_rmFreeBlkCopyUhcCh>:
; {
700abf70: b580         	push	{r7, lr}
700abf72: b088         	sub	sp, #0x20
700abf74: 9007         	str	r0, [sp, #0x1c]
700abf76: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abf78: 9806         	ldr	r0, [sp, #0x18]
700abf7a: f500 70ea    	add.w	r0, r0, #0x1d4
700abf7e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abf80: 9806         	ldr	r0, [sp, #0x18]
700abf82: f500 609f    	add.w	r0, r0, #0x4f8
700abf86: f04f 31ff    	mov.w	r1, #0xffffffff
700abf8a: f7fe fb49    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x196e
;     i = chNum - rmInitPrms->startBlkCopyUhcCh;
700abf8e: 9807         	ldr	r0, [sp, #0x1c]
700abf90: 9901         	ldr	r1, [sp, #0x4]
700abf92: 6809         	ldr	r1, [r1]
700abf94: 1a40         	subs	r0, r0, r1
700abf96: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abf98: 9805         	ldr	r0, [sp, #0x14]
700abf9a: 0940         	lsrs	r0, r0, #0x5
700abf9c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abf9e: 9805         	ldr	r0, [sp, #0x14]
700abfa0: 9904         	ldr	r1, [sp, #0x10]
700abfa2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abfa6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abfa8: 9903         	ldr	r1, [sp, #0xc]
700abfaa: 2001         	movs	r0, #0x1
700abfac: 4088         	lsls	r0, r1
700abfae: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyUhcChFlag[offset] |= bitMask;
700abfb0: 9a02         	ldr	r2, [sp, #0x8]
700abfb2: 9806         	ldr	r0, [sp, #0x18]
700abfb4: 9904         	ldr	r1, [sp, #0x10]
700abfb6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abfba: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700abfbe: 4310         	orrs	r0, r2
700abfc0: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abfc4: 9806         	ldr	r0, [sp, #0x18]
700abfc6: f500 609f    	add.w	r0, r0, #0x4f8
700abfca: f7ff fef1    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #-0x21e
;     return;
700abfce: b008         	add	sp, #0x20
700abfd0: bd80         	pop	{r7, pc}
		...
700abfde: 0000         	movs	r0, r0

700abfe0 <Udma_rmFreeRxCh>:
; {
700abfe0: b580         	push	{r7, lr}
700abfe2: b088         	sub	sp, #0x20
700abfe4: 9007         	str	r0, [sp, #0x1c]
700abfe6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abfe8: 9806         	ldr	r0, [sp, #0x18]
700abfea: f500 70ea    	add.w	r0, r0, #0x1d4
700abfee: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abff0: 9806         	ldr	r0, [sp, #0x18]
700abff2: f500 609f    	add.w	r0, r0, #0x4f8
700abff6: f04f 31ff    	mov.w	r1, #0xffffffff
700abffa: f7fe fb11    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x19de
;     i = chNum - rmInitPrms->startRxCh;
700abffe: 9807         	ldr	r0, [sp, #0x1c]
700ac000: 9901         	ldr	r1, [sp, #0x4]
700ac002: 6c09         	ldr	r1, [r1, #0x40]
700ac004: 1a40         	subs	r0, r0, r1
700ac006: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac008: 9805         	ldr	r0, [sp, #0x14]
700ac00a: 0940         	lsrs	r0, r0, #0x5
700ac00c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac00e: 9805         	ldr	r0, [sp, #0x14]
700ac010: 9904         	ldr	r1, [sp, #0x10]
700ac012: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac016: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac018: 9903         	ldr	r1, [sp, #0xc]
700ac01a: 2001         	movs	r0, #0x1
700ac01c: 4088         	lsls	r0, r1
700ac01e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxChFlag[offset] |= bitMask;
700ac020: 9a02         	ldr	r2, [sp, #0x8]
700ac022: 9806         	ldr	r0, [sp, #0x18]
700ac024: 9904         	ldr	r1, [sp, #0x10]
700ac026: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac02a: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700ac02e: 4310         	orrs	r0, r2
700ac030: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac034: 9806         	ldr	r0, [sp, #0x18]
700ac036: f500 609f    	add.w	r0, r0, #0x4f8
700ac03a: f7ff feb9    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #-0x28e
;     return;
700ac03e: b008         	add	sp, #0x20
700ac040: bd80         	pop	{r7, pc}
		...
700ac04e: 0000         	movs	r0, r0

700ac050 <Udma_rmFreeRxHcCh>:
; {
700ac050: b580         	push	{r7, lr}
700ac052: b088         	sub	sp, #0x20
700ac054: 9007         	str	r0, [sp, #0x1c]
700ac056: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac058: 9806         	ldr	r0, [sp, #0x18]
700ac05a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac05e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac060: 9806         	ldr	r0, [sp, #0x18]
700ac062: f500 609f    	add.w	r0, r0, #0x4f8
700ac066: f04f 31ff    	mov.w	r1, #0xffffffff
700ac06a: f7fe fad9    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x1a4e
;     i = chNum - rmInitPrms->startRxHcCh;
700ac06e: 9807         	ldr	r0, [sp, #0x1c]
700ac070: 9901         	ldr	r1, [sp, #0x4]
700ac072: 6b89         	ldr	r1, [r1, #0x38]
700ac074: 1a40         	subs	r0, r0, r1
700ac076: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac078: 9805         	ldr	r0, [sp, #0x14]
700ac07a: 0940         	lsrs	r0, r0, #0x5
700ac07c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac07e: 9805         	ldr	r0, [sp, #0x14]
700ac080: 9904         	ldr	r1, [sp, #0x10]
700ac082: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac086: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac088: 9903         	ldr	r1, [sp, #0xc]
700ac08a: 2001         	movs	r0, #0x1
700ac08c: 4088         	lsls	r0, r1
700ac08e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxHcChFlag[offset] |= bitMask;
700ac090: 9a02         	ldr	r2, [sp, #0x8]
700ac092: 9806         	ldr	r0, [sp, #0x18]
700ac094: 9904         	ldr	r1, [sp, #0x10]
700ac096: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac09a: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700ac09e: 4310         	orrs	r0, r2
700ac0a0: f8c1 031c    	str.w	r0, [r1, #0x31c]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac0a4: 9806         	ldr	r0, [sp, #0x18]
700ac0a6: f500 609f    	add.w	r0, r0, #0x4f8
700ac0aa: f7ff fe81    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #-0x2fe
;     return;
700ac0ae: b008         	add	sp, #0x20
700ac0b0: bd80         	pop	{r7, pc}
		...
700ac0be: 0000         	movs	r0, r0

700ac0c0 <Udma_rmFreeRxUhcCh>:
; {
700ac0c0: b580         	push	{r7, lr}
700ac0c2: b088         	sub	sp, #0x20
700ac0c4: 9007         	str	r0, [sp, #0x1c]
700ac0c6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac0c8: 9806         	ldr	r0, [sp, #0x18]
700ac0ca: f500 70ea    	add.w	r0, r0, #0x1d4
700ac0ce: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac0d0: 9806         	ldr	r0, [sp, #0x18]
700ac0d2: f500 609f    	add.w	r0, r0, #0x4f8
700ac0d6: f04f 31ff    	mov.w	r1, #0xffffffff
700ac0da: f7fe faa1    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x1abe
;     i = chNum - rmInitPrms->startRxUhcCh;
700ac0de: 9807         	ldr	r0, [sp, #0x1c]
700ac0e0: 9901         	ldr	r1, [sp, #0x4]
700ac0e2: 6b09         	ldr	r1, [r1, #0x30]
700ac0e4: 1a40         	subs	r0, r0, r1
700ac0e6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac0e8: 9805         	ldr	r0, [sp, #0x14]
700ac0ea: 0940         	lsrs	r0, r0, #0x5
700ac0ec: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac0ee: 9805         	ldr	r0, [sp, #0x14]
700ac0f0: 9904         	ldr	r1, [sp, #0x10]
700ac0f2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac0f6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac0f8: 9903         	ldr	r1, [sp, #0xc]
700ac0fa: 2001         	movs	r0, #0x1
700ac0fc: 4088         	lsls	r0, r1
700ac0fe: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxUhcChFlag[offset] |= bitMask;
700ac100: 9a02         	ldr	r2, [sp, #0x8]
700ac102: 9806         	ldr	r0, [sp, #0x18]
700ac104: 9904         	ldr	r1, [sp, #0x10]
700ac106: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac10a: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700ac10e: 4310         	orrs	r0, r2
700ac110: f8c1 0320    	str.w	r0, [r1, #0x320]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac114: 9806         	ldr	r0, [sp, #0x18]
700ac116: f500 609f    	add.w	r0, r0, #0x4f8
700ac11a: f7ff fe49    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #-0x36e
;     return;
700ac11e: b008         	add	sp, #0x20
700ac120: bd80         	pop	{r7, pc}
		...
700ac12e: 0000         	movs	r0, r0

700ac130 <Udma_rmFreeTxCh>:
; {
700ac130: b580         	push	{r7, lr}
700ac132: b088         	sub	sp, #0x20
700ac134: 9007         	str	r0, [sp, #0x1c]
700ac136: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac138: 9806         	ldr	r0, [sp, #0x18]
700ac13a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac13e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac140: 9806         	ldr	r0, [sp, #0x18]
700ac142: f500 609f    	add.w	r0, r0, #0x4f8
700ac146: f04f 31ff    	mov.w	r1, #0xffffffff
700ac14a: f7fe fa69    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x1b2e
;     i = chNum - rmInitPrms->startTxCh;
700ac14e: 9807         	ldr	r0, [sp, #0x1c]
700ac150: 9901         	ldr	r1, [sp, #0x4]
700ac152: 6a89         	ldr	r1, [r1, #0x28]
700ac154: 1a40         	subs	r0, r0, r1
700ac156: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac158: 9805         	ldr	r0, [sp, #0x14]
700ac15a: 0940         	lsrs	r0, r0, #0x5
700ac15c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac15e: 9805         	ldr	r0, [sp, #0x14]
700ac160: 9904         	ldr	r1, [sp, #0x10]
700ac162: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac166: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac168: 9903         	ldr	r1, [sp, #0xc]
700ac16a: 2001         	movs	r0, #0x1
700ac16c: 4088         	lsls	r0, r1
700ac16e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txChFlag[offset] |= bitMask;
700ac170: 9a02         	ldr	r2, [sp, #0x8]
700ac172: 9806         	ldr	r0, [sp, #0x18]
700ac174: 9904         	ldr	r1, [sp, #0x10]
700ac176: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac17a: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700ac17e: 4310         	orrs	r0, r2
700ac180: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac184: 9806         	ldr	r0, [sp, #0x18]
700ac186: f500 609f    	add.w	r0, r0, #0x4f8
700ac18a: f7ff fe11    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #-0x3de
;     return;
700ac18e: b008         	add	sp, #0x20
700ac190: bd80         	pop	{r7, pc}
		...
700ac19e: 0000         	movs	r0, r0

700ac1a0 <Udma_rmFreeTxHcCh>:
; {
700ac1a0: b580         	push	{r7, lr}
700ac1a2: b088         	sub	sp, #0x20
700ac1a4: 9007         	str	r0, [sp, #0x1c]
700ac1a6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac1a8: 9806         	ldr	r0, [sp, #0x18]
700ac1aa: f500 70ea    	add.w	r0, r0, #0x1d4
700ac1ae: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac1b0: 9806         	ldr	r0, [sp, #0x18]
700ac1b2: f500 609f    	add.w	r0, r0, #0x4f8
700ac1b6: f04f 31ff    	mov.w	r1, #0xffffffff
700ac1ba: f7fe fa31    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x1b9e
;     i = chNum - rmInitPrms->startTxHcCh;
700ac1be: 9807         	ldr	r0, [sp, #0x1c]
700ac1c0: 9901         	ldr	r1, [sp, #0x4]
700ac1c2: 6a09         	ldr	r1, [r1, #0x20]
700ac1c4: 1a40         	subs	r0, r0, r1
700ac1c6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac1c8: 9805         	ldr	r0, [sp, #0x14]
700ac1ca: 0940         	lsrs	r0, r0, #0x5
700ac1cc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac1ce: 9805         	ldr	r0, [sp, #0x14]
700ac1d0: 9904         	ldr	r1, [sp, #0x10]
700ac1d2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac1d6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac1d8: 9903         	ldr	r1, [sp, #0xc]
700ac1da: 2001         	movs	r0, #0x1
700ac1dc: 4088         	lsls	r0, r1
700ac1de: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txHcChFlag[offset] |= bitMask;
700ac1e0: 9a02         	ldr	r2, [sp, #0x8]
700ac1e2: 9806         	ldr	r0, [sp, #0x18]
700ac1e4: 9904         	ldr	r1, [sp, #0x10]
700ac1e6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac1ea: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700ac1ee: 4310         	orrs	r0, r2
700ac1f0: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac1f4: 9806         	ldr	r0, [sp, #0x18]
700ac1f6: f500 609f    	add.w	r0, r0, #0x4f8
700ac1fa: f7ff fdd9    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #-0x44e
;     return;
700ac1fe: b008         	add	sp, #0x20
700ac200: bd80         	pop	{r7, pc}
		...
700ac20e: 0000         	movs	r0, r0

700ac210 <Udma_rmFreeTxUhcCh>:
; {
700ac210: b580         	push	{r7, lr}
700ac212: b088         	sub	sp, #0x20
700ac214: 9007         	str	r0, [sp, #0x1c]
700ac216: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac218: 9806         	ldr	r0, [sp, #0x18]
700ac21a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac21e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac220: 9806         	ldr	r0, [sp, #0x18]
700ac222: f500 609f    	add.w	r0, r0, #0x4f8
700ac226: f04f 31ff    	mov.w	r1, #0xffffffff
700ac22a: f7fe f9f9    	bl	0x700aa620 <SemaphoreP_pend> @ imm = #-0x1c0e
;     i = chNum - rmInitPrms->startTxUhcCh;
700ac22e: 9807         	ldr	r0, [sp, #0x1c]
700ac230: 9901         	ldr	r1, [sp, #0x4]
700ac232: 6989         	ldr	r1, [r1, #0x18]
700ac234: 1a40         	subs	r0, r0, r1
700ac236: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac238: 9805         	ldr	r0, [sp, #0x14]
700ac23a: 0940         	lsrs	r0, r0, #0x5
700ac23c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac23e: 9805         	ldr	r0, [sp, #0x14]
700ac240: 9904         	ldr	r1, [sp, #0x10]
700ac242: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac246: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac248: 9903         	ldr	r1, [sp, #0xc]
700ac24a: 2001         	movs	r0, #0x1
700ac24c: 4088         	lsls	r0, r1
700ac24e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txUhcChFlag[offset] |= bitMask;
700ac250: 9a02         	ldr	r2, [sp, #0x8]
700ac252: 9806         	ldr	r0, [sp, #0x18]
700ac254: 9904         	ldr	r1, [sp, #0x10]
700ac256: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac25a: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700ac25e: 4310         	orrs	r0, r2
700ac260: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac264: 9806         	ldr	r0, [sp, #0x18]
700ac266: f500 609f    	add.w	r0, r0, #0x4f8
700ac26a: f7ff fda1    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #-0x4be
;     return;
700ac26e: b008         	add	sp, #0x20
700ac270: bd80         	pop	{r7, pc}
		...
700ac27e: 0000         	movs	r0, r0

700ac280 <UART_getChar>:
; {
700ac280: b580         	push	{r7, lr}
700ac282: b086         	sub	sp, #0x18
700ac284: 9005         	str	r0, [sp, #0x14]
700ac286: 9104         	str	r1, [sp, #0x10]
700ac288: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ac28a: 9003         	str	r0, [sp, #0xc]
;     uint32_t retVal      = FALSE;
700ac28c: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ac28e: 9805         	ldr	r0, [sp, #0x14]
700ac290: 300c         	adds	r0, #0xc
700ac292: f003 fc4d    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x389a
700ac296: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ac298: 9805         	ldr	r0, [sp, #0x14]
700ac29a: 300c         	adds	r0, #0xc
700ac29c: 9000         	str	r0, [sp]
700ac29e: f003 fc47    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x388e
700ac2a2: 4601         	mov	r1, r0
700ac2a4: 9800         	ldr	r0, [sp]
700ac2a6: f001 017f    	and	r1, r1, #0x7f
700ac2aa: f003 fc49    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x3892
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ac2ae: 9805         	ldr	r0, [sp, #0x14]
700ac2b0: 3014         	adds	r0, #0x14
700ac2b2: f003 fc3d    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x387a
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700ac2b6: 07c0         	lsls	r0, r0, #0x1f
700ac2b8: b150         	cbz	r0, 0x700ac2d0 <UART_getChar+0x50> @ imm = #0x14
700ac2ba: e7ff         	b	0x700ac2bc <UART_getChar+0x3c> @ imm = #-0x2
;         uint32_t tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700ac2bc: 9805         	ldr	r0, [sp, #0x14]
700ac2be: f003 fc37    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x386e
700ac2c2: 9001         	str	r0, [sp, #0x4]
;         *pChar = (uint8_t)tempRetVal;
700ac2c4: 9801         	ldr	r0, [sp, #0x4]
700ac2c6: 9904         	ldr	r1, [sp, #0x10]
700ac2c8: 7008         	strb	r0, [r1]
700ac2ca: 2001         	movs	r0, #0x1
;         retVal = TRUE;
700ac2cc: 9002         	str	r0, [sp, #0x8]
;     }
700ac2ce: e7ff         	b	0x700ac2d0 <UART_getChar+0x50> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ac2d0: 9805         	ldr	r0, [sp, #0x14]
700ac2d2: 300c         	adds	r0, #0xc
700ac2d4: 9903         	ldr	r1, [sp, #0xc]
700ac2d6: f003 fc33    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x3866
;     return retVal;
700ac2da: 9802         	ldr	r0, [sp, #0x8]
700ac2dc: b006         	add	sp, #0x18
700ac2de: bd80         	pop	{r7, pc}

700ac2e0 <UART_writeData>:
; {
700ac2e0: b580         	push	{r7, lr}
700ac2e2: b086         	sub	sp, #0x18
700ac2e4: 9005         	str	r0, [sp, #0x14]
700ac2e6: 9104         	str	r1, [sp, #0x10]
;     UARTLLD_InitHandle hUartInit = hUart->hUartInit;
700ac2e8: 9805         	ldr	r0, [sp, #0x14]
700ac2ea: 6840         	ldr	r0, [r0, #0x4]
700ac2ec: 9001         	str	r0, [sp, #0x4]
;     numBytesToTransfer = writeSizeRemaining;
700ac2ee: 9804         	ldr	r0, [sp, #0x10]
700ac2f0: 9003         	str	r0, [sp, #0xc]
;     if (numBytesToTransfer >= hUartInit->txTrigLvl)
700ac2f2: 9803         	ldr	r0, [sp, #0xc]
700ac2f4: 9901         	ldr	r1, [sp, #0x4]
700ac2f6: 6bc9         	ldr	r1, [r1, #0x3c]
700ac2f8: 4288         	cmp	r0, r1
700ac2fa: d304         	blo	0x700ac306 <UART_writeData+0x26> @ imm = #0x8
700ac2fc: e7ff         	b	0x700ac2fe <UART_writeData+0x1e> @ imm = #-0x2
;         numBytesToTransfer = hUartInit->txTrigLvl;
700ac2fe: 9801         	ldr	r0, [sp, #0x4]
700ac300: 6bc0         	ldr	r0, [r0, #0x3c]
700ac302: 9003         	str	r0, [sp, #0xc]
;     }
700ac304: e7ff         	b	0x700ac306 <UART_writeData+0x26> @ imm = #-0x2
;     numBytesToTransferred = numBytesToTransfer;
700ac306: 9803         	ldr	r0, [sp, #0xc]
700ac308: 9002         	str	r0, [sp, #0x8]
;     while (numBytesToTransfer != 0U)
700ac30a: e7ff         	b	0x700ac30c <UART_writeData+0x2c> @ imm = #-0x2
700ac30c: 9803         	ldr	r0, [sp, #0xc]
700ac30e: b190         	cbz	r0, 0x700ac336 <UART_writeData+0x56> @ imm = #0x24
700ac310: e7ff         	b	0x700ac312 <UART_writeData+0x32> @ imm = #-0x2
;         UART_putChar(hUart->baseAddr, *(const uint8_t *)hUart->writeBuf);
700ac312: 9905         	ldr	r1, [sp, #0x14]
700ac314: 6808         	ldr	r0, [r1]
700ac316: 6889         	ldr	r1, [r1, #0x8]
700ac318: 7809         	ldrb	r1, [r1]
700ac31a: f003 f9f1    	bl	0x700af700 <UART_putChar> @ imm = #0x33e2
;         hUart->writeBuf = (const uint8_t *)hUart->writeBuf + 1U;
700ac31e: 9905         	ldr	r1, [sp, #0x14]
700ac320: 6888         	ldr	r0, [r1, #0x8]
700ac322: 3001         	adds	r0, #0x1
700ac324: 6088         	str	r0, [r1, #0x8]
;         numBytesToTransfer--;
700ac326: 9803         	ldr	r0, [sp, #0xc]
700ac328: 3801         	subs	r0, #0x1
700ac32a: 9003         	str	r0, [sp, #0xc]
;         hUart->writeCount++;
700ac32c: 9905         	ldr	r1, [sp, #0x14]
700ac32e: 68c8         	ldr	r0, [r1, #0xc]
700ac330: 3001         	adds	r0, #0x1
700ac332: 60c8         	str	r0, [r1, #0xc]
;     while (numBytesToTransfer != 0U)
700ac334: e7ea         	b	0x700ac30c <UART_writeData+0x2c> @ imm = #-0x2c
;     return (writeSizeRemaining - numBytesToTransferred);
700ac336: 9804         	ldr	r0, [sp, #0x10]
700ac338: 9902         	ldr	r1, [sp, #0x8]
700ac33a: 1a40         	subs	r0, r0, r1
700ac33c: b006         	add	sp, #0x18
700ac33e: bd80         	pop	{r7, pc}

700ac340 <Udma_virtToPhyFxn>:
; {
700ac340: b580         	push	{r7, lr}
700ac342: b088         	sub	sp, #0x20
700ac344: 9007         	str	r0, [sp, #0x1c]
700ac346: 9106         	str	r1, [sp, #0x18]
700ac348: 9205         	str	r2, [sp, #0x14]
700ac34a: 2000         	movs	r0, #0x0
700ac34c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700ac350: 9004         	str	r0, [sp, #0x10]
700ac352: 2000         	movs	r0, #0x0
;     void               *appData = NULL_PTR;
700ac354: 9003         	str	r0, [sp, #0xc]
;     if(NULL_PTR != chHandle)
700ac356: 9805         	ldr	r0, [sp, #0x14]
700ac358: b138         	cbz	r0, 0x700ac36a <Udma_virtToPhyFxn+0x2a> @ imm = #0xe
700ac35a: e7ff         	b	0x700ac35c <Udma_virtToPhyFxn+0x1c> @ imm = #-0x2
;         chNum   = chHandle->chPrms.chNum;
700ac35c: 9805         	ldr	r0, [sp, #0x14]
700ac35e: 6840         	ldr	r0, [r0, #0x4]
700ac360: 9004         	str	r0, [sp, #0x10]
;         appData = chHandle->chPrms.appData;
700ac362: 9805         	ldr	r0, [sp, #0x14]
700ac364: 6900         	ldr	r0, [r0, #0x10]
700ac366: 9003         	str	r0, [sp, #0xc]
;     }
700ac368: e7ff         	b	0x700ac36a <Udma_virtToPhyFxn+0x2a> @ imm = #-0x2
;     if((Udma_VirtToPhyFxn) NULL_PTR != drvHandle->initPrms.virtToPhyFxn)
700ac36a: 9806         	ldr	r0, [sp, #0x18]
700ac36c: f8d0 01cc    	ldr.w	r0, [r0, #0x1cc]
700ac370: b150         	cbz	r0, 0x700ac388 <Udma_virtToPhyFxn+0x48> @ imm = #0x14
700ac372: e7ff         	b	0x700ac374 <Udma_virtToPhyFxn+0x34> @ imm = #-0x2
;         phyAddr = drvHandle->initPrms.virtToPhyFxn(virtAddr, chNum, appData);
700ac374: 9806         	ldr	r0, [sp, #0x18]
700ac376: f8d0 31cc    	ldr.w	r3, [r0, #0x1cc]
700ac37a: 9807         	ldr	r0, [sp, #0x1c]
700ac37c: 9904         	ldr	r1, [sp, #0x10]
700ac37e: 9a03         	ldr	r2, [sp, #0xc]
700ac380: 4798         	blx	r3
700ac382: 9101         	str	r1, [sp, #0x4]
700ac384: 9000         	str	r0, [sp]
;     }
700ac386: e007         	b	0x700ac398 <Udma_virtToPhyFxn+0x58> @ imm = #0xe
;         phyAddr = Udma_defaultVirtToPhyFxn(virtAddr, chNum, appData);
700ac388: 9807         	ldr	r0, [sp, #0x1c]
700ac38a: 9904         	ldr	r1, [sp, #0x10]
700ac38c: 9a03         	ldr	r2, [sp, #0xc]
700ac38e: f003 fbdf    	bl	0x700afb50 <Udma_defaultVirtToPhyFxn> @ imm = #0x37be
700ac392: 9101         	str	r1, [sp, #0x4]
700ac394: 9000         	str	r0, [sp]
700ac396: e7ff         	b	0x700ac398 <Udma_virtToPhyFxn+0x58> @ imm = #-0x2
;     return (phyAddr);
700ac398: 9800         	ldr	r0, [sp]
700ac39a: 9901         	ldr	r1, [sp, #0x4]
700ac39c: b008         	add	sp, #0x20
700ac39e: bd80         	pop	{r7, pc}

700ac3a0 <Sciclient_pmSetModuleRst>:
; {
700ac3a0: b580         	push	{r7, lr}
700ac3a2: b090         	sub	sp, #0x40
700ac3a4: 900f         	str	r0, [sp, #0x3c]
700ac3a6: 910e         	str	r1, [sp, #0x38]
700ac3a8: 920d         	str	r2, [sp, #0x34]
700ac3aa: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700ac3ac: 900c         	str	r0, [sp, #0x30]
;     request.id     = (uint32_t) moduleId;
700ac3ae: 990f         	ldr	r1, [sp, #0x3c]
700ac3b0: 910a         	str	r1, [sp, #0x28]
;     request.resets = (uint32_t) resetBit;
700ac3b2: 990e         	ldr	r1, [sp, #0x38]
700ac3b4: 910b         	str	r1, [sp, #0x2c]
700ac3b6: f240 2102    	movw	r1, #0x202
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE_RESETS;
700ac3ba: f8ad 100c    	strh.w	r1, [sp, #0xc]
700ac3be: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700ac3c0: 9104         	str	r1, [sp, #0x10]
700ac3c2: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700ac3c4: 9105         	str	r1, [sp, #0x14]
700ac3c6: 2110         	movs	r1, #0x10
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700ac3c8: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700ac3ca: 990d         	ldr	r1, [sp, #0x34]
700ac3cc: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700ac3ce: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700ac3d0: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700ac3d2: 9002         	str	r0, [sp, #0x8]
700ac3d4: a803         	add	r0, sp, #0xc
700ac3d6: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700ac3d8: f7f0 fed2    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xf25c
700ac3dc: 900c         	str	r0, [sp, #0x30]
;     if((retVal != SystemP_SUCCESS) ||
700ac3de: 980c         	ldr	r0, [sp, #0x30]
700ac3e0: b930         	cbnz	r0, 0x700ac3f0 <Sciclient_pmSetModuleRst+0x50> @ imm = #0xc
700ac3e2: e7ff         	b	0x700ac3e4 <Sciclient_pmSetModuleRst+0x44> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700ac3e4: 9800         	ldr	r0, [sp]
700ac3e6: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700ac3ea: 2802         	cmp	r0, #0x2
700ac3ec: d004         	beq	0x700ac3f8 <Sciclient_pmSetModuleRst+0x58> @ imm = #0x8
700ac3ee: e7ff         	b	0x700ac3f0 <Sciclient_pmSetModuleRst+0x50> @ imm = #-0x2
700ac3f0: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700ac3f4: 900c         	str	r0, [sp, #0x30]
;     }
700ac3f6: e7ff         	b	0x700ac3f8 <Sciclient_pmSetModuleRst+0x58> @ imm = #-0x2
;     return retVal;
700ac3f8: 980c         	ldr	r0, [sp, #0x30]
700ac3fa: b010         	add	sp, #0x40
700ac3fc: bd80         	pop	{r7, pc}
700ac3fe: 0000         	movs	r0, r0

700ac400 <Sciclient_rmIaGetInst>:
; {
700ac400: b083         	sub	sp, #0xc
700ac402: f8ad 000a    	strh.w	r0, [sp, #0xa]
700ac406: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIaInst *inst = NULL;
700ac408: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700ac40a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700ac40e: e7ff         	b	0x700ac410 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x2
700ac410: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ac414: 2800         	cmp	r0, #0x0
700ac416: dc1e         	bgt	0x700ac456 <Sciclient_rmIaGetInst+0x56> @ imm = #0x3c
700ac418: e7ff         	b	0x700ac41a <Sciclient_rmIaGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIaInstances[i].dev_id) {
700ac41a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700ac41e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700ac422: 014a         	lsls	r2, r1, #0x5
700ac424: f642 019c    	movw	r1, #0x289c
700ac428: f2c7 010b    	movt	r1, #0x700b
700ac42c: 5a89         	ldrh	r1, [r1, r2]
700ac42e: 4288         	cmp	r0, r1
700ac430: d10a         	bne	0x700ac448 <Sciclient_rmIaGetInst+0x48> @ imm = #0x14
700ac432: e7ff         	b	0x700ac434 <Sciclient_rmIaGetInst+0x34> @ imm = #-0x2
;             inst = &gRmIaInstances[i];
700ac434: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700ac438: f642 009c    	movw	r0, #0x289c
700ac43c: f2c7 000b    	movt	r0, #0x700b
700ac440: eb00 1041    	add.w	r0, r0, r1, lsl #5
700ac444: 9001         	str	r0, [sp, #0x4]
;             break;
700ac446: e006         	b	0x700ac456 <Sciclient_rmIaGetInst+0x56> @ imm = #0xc
;     }
700ac448: e7ff         	b	0x700ac44a <Sciclient_rmIaGetInst+0x4a> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700ac44a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ac44e: 3001         	adds	r0, #0x1
700ac450: f8ad 0002    	strh.w	r0, [sp, #0x2]
700ac454: e7dc         	b	0x700ac410 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x48
;     return inst;
700ac456: 9801         	ldr	r0, [sp, #0x4]
700ac458: b003         	add	sp, #0xc
700ac45a: 4770         	bx	lr
700ac45c: 0000         	movs	r0, r0
700ac45e: 0000         	movs	r0, r0

700ac460 <Sciclient_rmPsPush>:
; {
700ac460: b083         	sub	sp, #0xc
700ac462: 9002         	str	r0, [sp, #0x8]
700ac464: f8ad 1006    	strh.w	r1, [sp, #0x6]
700ac468: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac46a: 9000         	str	r0, [sp]
;     if ((gPstack.psp < SCICLIENT_PS_MAX_DEPTH) && (n != NULL)) {
700ac46c: f241 0058    	movw	r0, #0x1058
700ac470: f2c7 0008    	movt	r0, #0x7008
700ac474: 8c80         	ldrh	r0, [r0, #0x24]
700ac476: 2802         	cmp	r0, #0x2
700ac478: dc19         	bgt	0x700ac4ae <Sciclient_rmPsPush+0x4e> @ imm = #0x32
700ac47a: e7ff         	b	0x700ac47c <Sciclient_rmPsPush+0x1c> @ imm = #-0x2
700ac47c: 9802         	ldr	r0, [sp, #0x8]
700ac47e: b1b0         	cbz	r0, 0x700ac4ae <Sciclient_rmPsPush+0x4e> @ imm = #0x2c
700ac480: e7ff         	b	0x700ac482 <Sciclient_rmPsPush+0x22> @ imm = #-0x2
;         gPstack.ps[gPstack.psp].p_n = n;
700ac482: 9802         	ldr	r0, [sp, #0x8]
700ac484: f241 0158    	movw	r1, #0x1058
700ac488: f2c7 0108    	movt	r1, #0x7008
700ac48c: 8c8a         	ldrh	r2, [r1, #0x24]
700ac48e: eb02 0242    	add.w	r2, r2, r2, lsl #1
700ac492: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = if_idx;
700ac496: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac49a: 8c8a         	ldrh	r2, [r1, #0x24]
700ac49c: eb02 0242    	add.w	r2, r2, r2, lsl #1
700ac4a0: eb01 0282    	add.w	r2, r1, r2, lsl #2
700ac4a4: 8090         	strh	r0, [r2, #0x4]
;         gPstack.psp++;
700ac4a6: 8c88         	ldrh	r0, [r1, #0x24]
700ac4a8: 3001         	adds	r0, #0x1
700ac4aa: 8488         	strh	r0, [r1, #0x24]
;     } else {
700ac4ac: e003         	b	0x700ac4b6 <Sciclient_rmPsPush+0x56> @ imm = #0x6
700ac4ae: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac4b2: 9000         	str	r0, [sp]
700ac4b4: e7ff         	b	0x700ac4b6 <Sciclient_rmPsPush+0x56> @ imm = #-0x2
;     return r;
700ac4b6: 9800         	ldr	r0, [sp]
700ac4b8: b003         	add	sp, #0xc
700ac4ba: 4770         	bx	lr
700ac4bc: 0000         	movs	r0, r0
700ac4be: 0000         	movs	r0, r0

700ac4c0 <UART_lld_deInit>:
; {
700ac4c0: b580         	push	{r7, lr}
700ac4c2: b084         	sub	sp, #0x10
700ac4c4: 9003         	str	r0, [sp, #0xc]
700ac4c6: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700ac4c8: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700ac4ca: 9803         	ldr	r0, [sp, #0xc]
700ac4cc: b1f8         	cbz	r0, 0x700ac50e <UART_lld_deInit+0x4e> @ imm = #0x3e
700ac4ce: e7ff         	b	0x700ac4d0 <UART_lld_deInit+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700ac4d0: 9903         	ldr	r1, [sp, #0xc]
700ac4d2: 2002         	movs	r0, #0x2
700ac4d4: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700ac4d6: 9803         	ldr	r0, [sp, #0xc]
700ac4d8: f7fd fef2    	bl	0x700aa2c0 <UART_lld_flushTxFifo> @ imm = #-0x221c
700ac4dc: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700ac4de: 9802         	ldr	r0, [sp, #0x8]
700ac4e0: b988         	cbnz	r0, 0x700ac506 <UART_lld_deInit+0x46> @ imm = #0x22
700ac4e2: e7ff         	b	0x700ac4e4 <UART_lld_deInit+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700ac4e4: 9803         	ldr	r0, [sp, #0xc]
700ac4e6: 6800         	ldr	r0, [r0]
700ac4e8: 2107         	movs	r1, #0x7
700ac4ea: 9101         	str	r1, [sp, #0x4]
700ac4ec: f7f9 fe58    	bl	0x700a61a0 <UART_intrDisable> @ imm = #-0x6350
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700ac4f0: 9803         	ldr	r0, [sp, #0xc]
700ac4f2: 6800         	ldr	r0, [r0]
700ac4f4: 2102         	movs	r1, #0x2
700ac4f6: f002 fbf3    	bl	0x700aece0 <UART_intr2Disable> @ imm = #0x27e6
700ac4fa: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700ac4fc: 9803         	ldr	r0, [sp, #0xc]
700ac4fe: 6800         	ldr	r0, [r0]
700ac500: f002 fc36    	bl	0x700aed70 <UART_operatingModeSelect> @ imm = #0x286c
;         }
700ac504: e7ff         	b	0x700ac506 <UART_lld_deInit+0x46> @ imm = #-0x2
;         hUart->state = UART_STATE_RESET;
700ac506: 9903         	ldr	r1, [sp, #0xc]
700ac508: 2000         	movs	r0, #0x0
700ac50a: 6548         	str	r0, [r1, #0x54]
;     }
700ac50c: e003         	b	0x700ac516 <UART_lld_deInit+0x56> @ imm = #0x6
700ac50e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700ac512: 9002         	str	r0, [sp, #0x8]
700ac514: e7ff         	b	0x700ac516 <UART_lld_deInit+0x56> @ imm = #-0x2
;     return status;
700ac516: 9802         	ldr	r0, [sp, #0x8]
700ac518: b004         	add	sp, #0x10
700ac51a: bd80         	pop	{r7, pc}
700ac51c: 0000         	movs	r0, r0
700ac51e: 0000         	movs	r0, r0

700ac520 <UART_lld_writeCompleteCallback>:
; {
700ac520: b580         	push	{r7, lr}
700ac522: b086         	sub	sp, #0x18
700ac524: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700ac526: 9805         	ldr	r0, [sp, #0x14]
700ac528: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700ac52a: 9802         	ldr	r0, [sp, #0x8]
700ac52c: b320         	cbz	r0, 0x700ac578 <UART_lld_writeCompleteCallback+0x58> @ imm = #0x48
700ac52e: e7ff         	b	0x700ac530 <UART_lld_writeCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700ac530: 9802         	ldr	r0, [sp, #0x8]
700ac532: 6e00         	ldr	r0, [r0, #0x60]
700ac534: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700ac536: 9801         	ldr	r0, [sp, #0x4]
700ac538: b1e8         	cbz	r0, 0x700ac576 <UART_lld_writeCompleteCallback+0x56> @ imm = #0x3a
700ac53a: e7ff         	b	0x700ac53c <UART_lld_writeCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700ac53c: 9801         	ldr	r0, [sp, #0x4]
700ac53e: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700ac540: 9804         	ldr	r0, [sp, #0x10]
700ac542: 6840         	ldr	r0, [r0, #0x4]
700ac544: 9003         	str	r0, [sp, #0xc]
;             obj->writeTrans->count = hUart->writeTrans.count;
700ac546: 9802         	ldr	r0, [sp, #0x8]
700ac548: 6c00         	ldr	r0, [r0, #0x40]
700ac54a: 9903         	ldr	r1, [sp, #0xc]
700ac54c: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700ac550: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.writeMode == UART_TRANSFER_MODE_CALLBACK)
700ac552: 9803         	ldr	r0, [sp, #0xc]
700ac554: 69c0         	ldr	r0, [r0, #0x1c]
700ac556: 2801         	cmp	r0, #0x1
700ac558: d107         	bne	0x700ac56a <UART_lld_writeCompleteCallback+0x4a> @ imm = #0xe
700ac55a: e7ff         	b	0x700ac55c <UART_lld_writeCompleteCallback+0x3c> @ imm = #-0x2
;                 obj->prms.writeCallbackFxn(hUart, &hUart->writeTrans);
700ac55c: 9803         	ldr	r0, [sp, #0xc]
700ac55e: 6a42         	ldr	r2, [r0, #0x24]
700ac560: 9802         	ldr	r0, [sp, #0x8]
700ac562: f100 013c    	add.w	r1, r0, #0x3c
700ac566: 4790         	blx	r2
;             }
700ac568: e004         	b	0x700ac574 <UART_lld_writeCompleteCallback+0x54> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->writeTransferMutex);
700ac56a: 9802         	ldr	r0, [sp, #0x8]
700ac56c: 6dc0         	ldr	r0, [r0, #0x5c]
700ac56e: f7ff fc1f    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #-0x7c2
700ac572: e7ff         	b	0x700ac574 <UART_lld_writeCompleteCallback+0x54> @ imm = #-0x2
;         }
700ac574: e7ff         	b	0x700ac576 <UART_lld_writeCompleteCallback+0x56> @ imm = #-0x2
;     }
700ac576: e7ff         	b	0x700ac578 <UART_lld_writeCompleteCallback+0x58> @ imm = #-0x2
; }
700ac578: b006         	add	sp, #0x18
700ac57a: bd80         	pop	{r7, pc}
700ac57c: 0000         	movs	r0, r0
700ac57e: 0000         	movs	r0, r0

700ac580 <Sciclient_rmIaValidateGlobalEvt>:
; {
700ac580: b580         	push	{r7, lr}
700ac582: b086         	sub	sp, #0x18
700ac584: f8ad 0016    	strh.w	r0, [sp, #0x16]
700ac588: f8ad 1014    	strh.w	r1, [sp, #0x14]
700ac58c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac58e: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700ac590: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700ac592: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700ac596: f7ff ff33    	bl	0x700ac400 <Sciclient_rmIaGetInst> @ imm = #-0x19a
700ac59a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700ac59c: 9803         	ldr	r0, [sp, #0xc]
700ac59e: b920         	cbnz	r0, 0x700ac5aa <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #0x8
700ac5a0: e7ff         	b	0x700ac5a2 <Sciclient_rmIaValidateGlobalEvt+0x22> @ imm = #-0x2
700ac5a2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ac5a6: 9004         	str	r0, [sp, #0x10]
;     }
700ac5a8: e7ff         	b	0x700ac5aa <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ac5aa: 9804         	ldr	r0, [sp, #0x10]
700ac5ac: b990         	cbnz	r0, 0x700ac5d4 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #0x24
700ac5ae: e7ff         	b	0x700ac5b0 <Sciclient_rmIaValidateGlobalEvt+0x30> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700ac5b0: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700ac5b4: 9903         	ldr	r1, [sp, #0xc]
700ac5b6: 8909         	ldrh	r1, [r1, #0x8]
700ac5b8: 1a40         	subs	r0, r0, r1
700ac5ba: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         r = Sciclient_rmIaValidateEvt(inst, evt, 0u, 0u, false);
700ac5be: 9803         	ldr	r0, [sp, #0xc]
700ac5c0: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700ac5c4: 466a         	mov	r2, sp
700ac5c6: 2300         	movs	r3, #0x0
700ac5c8: 6013         	str	r3, [r2]
700ac5ca: 461a         	mov	r2, r3
700ac5cc: f7f7 ff28    	bl	0x700a4420 <Sciclient_rmIaValidateEvt> @ imm = #-0x81b0
700ac5d0: 9004         	str	r0, [sp, #0x10]
;     }
700ac5d2: e7ff         	b	0x700ac5d4 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #-0x2
;     return r;
700ac5d4: 9804         	ldr	r0, [sp, #0x10]
700ac5d6: b006         	add	sp, #0x18
700ac5d8: bd80         	pop	{r7, pc}
700ac5da: 0000         	movs	r0, r0
700ac5dc: 0000         	movs	r0, r0
700ac5de: 0000         	movs	r0, r0

700ac5e0 <UART_lld_readCompleteCallback>:
; {
700ac5e0: b580         	push	{r7, lr}
700ac5e2: b086         	sub	sp, #0x18
700ac5e4: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700ac5e6: 9805         	ldr	r0, [sp, #0x14]
700ac5e8: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700ac5ea: 9802         	ldr	r0, [sp, #0x8]
700ac5ec: b318         	cbz	r0, 0x700ac636 <UART_lld_readCompleteCallback+0x56> @ imm = #0x46
700ac5ee: e7ff         	b	0x700ac5f0 <UART_lld_readCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700ac5f0: 9802         	ldr	r0, [sp, #0x8]
700ac5f2: 6e00         	ldr	r0, [r0, #0x60]
700ac5f4: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700ac5f6: 9801         	ldr	r0, [sp, #0x4]
700ac5f8: b1e0         	cbz	r0, 0x700ac634 <UART_lld_readCompleteCallback+0x54> @ imm = #0x38
700ac5fa: e7ff         	b	0x700ac5fc <UART_lld_readCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700ac5fc: 9801         	ldr	r0, [sp, #0x4]
700ac5fe: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700ac600: 9804         	ldr	r0, [sp, #0x10]
700ac602: 6840         	ldr	r0, [r0, #0x4]
700ac604: 9003         	str	r0, [sp, #0xc]
;             obj->readTrans->count = hUart->readTrans.count;
700ac606: 9802         	ldr	r0, [sp, #0x8]
700ac608: 6ac0         	ldr	r0, [r0, #0x2c]
700ac60a: 9903         	ldr	r1, [sp, #0xc]
700ac60c: 6fc9         	ldr	r1, [r1, #0x7c]
700ac60e: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.readMode == UART_TRANSFER_MODE_CALLBACK)
700ac610: 9803         	ldr	r0, [sp, #0xc]
700ac612: 6940         	ldr	r0, [r0, #0x14]
700ac614: 2801         	cmp	r0, #0x1
700ac616: d107         	bne	0x700ac628 <UART_lld_readCompleteCallback+0x48> @ imm = #0xe
700ac618: e7ff         	b	0x700ac61a <UART_lld_readCompleteCallback+0x3a> @ imm = #-0x2
;                 obj->prms.readCallbackFxn(hUart, &hUart->readTrans);
700ac61a: 9803         	ldr	r0, [sp, #0xc]
700ac61c: 6a02         	ldr	r2, [r0, #0x20]
700ac61e: 9802         	ldr	r0, [sp, #0x8]
700ac620: f100 0128    	add.w	r1, r0, #0x28
700ac624: 4790         	blx	r2
;             }
700ac626: e004         	b	0x700ac632 <UART_lld_readCompleteCallback+0x52> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->readTransferMutex);
700ac628: 9802         	ldr	r0, [sp, #0x8]
700ac62a: 6d80         	ldr	r0, [r0, #0x58]
700ac62c: f7ff fbc0    	bl	0x700abdb0 <SemaphoreP_post> @ imm = #-0x880
700ac630: e7ff         	b	0x700ac632 <UART_lld_readCompleteCallback+0x52> @ imm = #-0x2
;         }
700ac632: e7ff         	b	0x700ac634 <UART_lld_readCompleteCallback+0x54> @ imm = #-0x2
;     }
700ac634: e7ff         	b	0x700ac636 <UART_lld_readCompleteCallback+0x56> @ imm = #-0x2
; }
700ac636: b006         	add	sp, #0x18
700ac638: bd80         	pop	{r7, pc}
700ac63a: 0000         	movs	r0, r0
700ac63c: 0000         	movs	r0, r0
700ac63e: 0000         	movs	r0, r0

700ac640 <UART_regConfigModeEnable>:
; {
700ac640: b580         	push	{r7, lr}
700ac642: b086         	sub	sp, #0x18
700ac644: 9005         	str	r0, [sp, #0x14]
700ac646: 9104         	str	r1, [sp, #0x10]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ac648: 9805         	ldr	r0, [sp, #0x14]
700ac64a: 300c         	adds	r0, #0xc
700ac64c: f003 fa70    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x34e0
700ac650: 9003         	str	r0, [sp, #0xc]
;     switch (modeFlag)
700ac652: 9804         	ldr	r0, [sp, #0x10]
700ac654: 9002         	str	r0, [sp, #0x8]
700ac656: 287f         	cmp	r0, #0x7f
700ac658: d00f         	beq	0x700ac67a <UART_regConfigModeEnable+0x3a> @ imm = #0x1e
700ac65a: e7ff         	b	0x700ac65c <UART_regConfigModeEnable+0x1c> @ imm = #-0x2
700ac65c: 9802         	ldr	r0, [sp, #0x8]
700ac65e: 2880         	cmp	r0, #0x80
700ac660: d004         	beq	0x700ac66c <UART_regConfigModeEnable+0x2c> @ imm = #0x8
700ac662: e7ff         	b	0x700ac664 <UART_regConfigModeEnable+0x24> @ imm = #-0x2
700ac664: 9802         	ldr	r0, [sp, #0x8]
700ac666: 28bf         	cmp	r0, #0xbf
700ac668: d113         	bne	0x700ac692 <UART_regConfigModeEnable+0x52> @ imm = #0x26
700ac66a: e7ff         	b	0x700ac66c <UART_regConfigModeEnable+0x2c> @ imm = #-0x2
;             HW_WR_REG32(baseAddr + UART_LCR, modeFlag & 0xFFU);
700ac66c: 9805         	ldr	r0, [sp, #0x14]
700ac66e: 300c         	adds	r0, #0xc
700ac670: f89d 1010    	ldrb.w	r1, [sp, #0x10]
700ac674: f003 fa64    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x34c8
;             break;
700ac678: e00c         	b	0x700ac694 <UART_regConfigModeEnable+0x54> @ imm = #0x18
;             HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ac67a: 9805         	ldr	r0, [sp, #0x14]
700ac67c: 300c         	adds	r0, #0xc
700ac67e: 9001         	str	r0, [sp, #0x4]
700ac680: f003 fa56    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x34ac
700ac684: 4601         	mov	r1, r0
700ac686: 9801         	ldr	r0, [sp, #0x4]
700ac688: f001 017f    	and	r1, r1, #0x7f
700ac68c: f003 fa58    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x34b0
;             break;
700ac690: e000         	b	0x700ac694 <UART_regConfigModeEnable+0x54> @ imm = #0x0
;             break;
700ac692: e7ff         	b	0x700ac694 <UART_regConfigModeEnable+0x54> @ imm = #-0x2
;     return lcrRegValue;
700ac694: 9803         	ldr	r0, [sp, #0xc]
700ac696: b006         	add	sp, #0x18
700ac698: bd80         	pop	{r7, pc}
700ac69a: 0000         	movs	r0, r0
700ac69c: 0000         	movs	r0, r0
700ac69e: 0000         	movs	r0, r0

700ac6a0 <prvCheckTasksWaitingTermination>:
; static void prvCheckTasksWaitingTermination(void) {
700ac6a0: b580         	push	{r7, lr}
700ac6a2: b082         	sub	sp, #0x8
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700ac6a4: e7ff         	b	0x700ac6a6 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x2
700ac6a6: f642 2020    	movw	r0, #0x2a20
700ac6aa: f2c7 000b    	movt	r0, #0x700b
700ac6ae: 6800         	ldr	r0, [r0]
700ac6b0: b308         	cbz	r0, 0x700ac6f6 <prvCheckTasksWaitingTermination+0x56> @ imm = #0x42
700ac6b2: e7ff         	b	0x700ac6b4 <prvCheckTasksWaitingTermination+0x14> @ imm = #-0x2
;       taskENTER_CRITICAL();
700ac6b4: f002 f804    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x2008
;         pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700ac6b8: f245 1008    	movw	r0, #0x5108
700ac6bc: f2c7 0008    	movt	r0, #0x7008
700ac6c0: 68c0         	ldr	r0, [r0, #0xc]
700ac6c2: 68c0         	ldr	r0, [r0, #0xc]
700ac6c4: 9001         	str	r0, [sp, #0x4]
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700ac6c6: 9801         	ldr	r0, [sp, #0x4]
700ac6c8: 3004         	adds	r0, #0x4
700ac6ca: f000 ffa9    	bl	0x700ad620 <uxListRemove> @ imm = #0xf52
;         --uxCurrentNumberOfTasks;
700ac6ce: f642 211c    	movw	r1, #0x2a1c
700ac6d2: f2c7 010b    	movt	r1, #0x700b
700ac6d6: 6808         	ldr	r0, [r1]
700ac6d8: 3801         	subs	r0, #0x1
700ac6da: 6008         	str	r0, [r1]
;         --uxDeletedTasksWaitingCleanUp;
700ac6dc: f642 2120    	movw	r1, #0x2a20
700ac6e0: f2c7 010b    	movt	r1, #0x700b
700ac6e4: 6808         	ldr	r0, [r1]
700ac6e6: 3801         	subs	r0, #0x1
700ac6e8: 6008         	str	r0, [r1]
;       taskEXIT_CRITICAL();
700ac6ea: f001 f889    	bl	0x700ad800 <vTaskExitCritical> @ imm = #0x1112
;       prvDeleteTCB(pxTCB);
700ac6ee: 9801         	ldr	r0, [sp, #0x4]
700ac6f0: f001 fcae    	bl	0x700ae050 <prvDeleteTCB> @ imm = #0x195c
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700ac6f4: e7d7         	b	0x700ac6a6 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x52
; }
700ac6f6: b002         	add	sp, #0x8
700ac6f8: bd80         	pop	{r7, pc}
700ac6fa: 0000         	movs	r0, r0
700ac6fc: 0000         	movs	r0, r0
700ac6fe: 0000         	movs	r0, r0

700ac700 <Sciclient_rmIrqSetRaw>:
; {
700ac700: b580         	push	{r7, lr}
700ac702: b08c         	sub	sp, #0x30
700ac704: 900b         	str	r0, [sp, #0x2c]
700ac706: 910a         	str	r1, [sp, #0x28]
700ac708: 9209         	str	r2, [sp, #0x24]
700ac70a: f44f 5080    	mov.w	r0, #0x1000
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_SET;
700ac70e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac712: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac714: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac716: 980b         	ldr	r0, [sp, #0x2c]
700ac718: 9005         	str	r0, [sp, #0x14]
700ac71a: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac71c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac71e: 9809         	ldr	r0, [sp, #0x24]
700ac720: 9007         	str	r0, [sp, #0x1c]
700ac722: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac724: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac726: 980a         	ldr	r0, [sp, #0x28]
700ac728: 9001         	str	r0, [sp, #0x4]
700ac72a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac72c: 9002         	str	r0, [sp, #0x8]
700ac72e: a803         	add	r0, sp, #0xc
700ac730: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac732: f7f0 fd25    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xf5b6
700ac736: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac738: 9808         	ldr	r0, [sp, #0x20]
700ac73a: b930         	cbnz	r0, 0x700ac74a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #0xc
700ac73c: e7ff         	b	0x700ac73e <Sciclient_rmIrqSetRaw+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac73e: 9800         	ldr	r0, [sp]
700ac740: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac744: 2802         	cmp	r0, #0x2
700ac746: d004         	beq	0x700ac752 <Sciclient_rmIrqSetRaw+0x52> @ imm = #0x8
700ac748: e7ff         	b	0x700ac74a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #-0x2
700ac74a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac74e: 9008         	str	r0, [sp, #0x20]
;     }
700ac750: e7ff         	b	0x700ac752 <Sciclient_rmIrqSetRaw+0x52> @ imm = #-0x2
;     return r;
700ac752: 9808         	ldr	r0, [sp, #0x20]
700ac754: b00c         	add	sp, #0x30
700ac756: bd80         	pop	{r7, pc}
		...

700ac760 <Sciclient_rmIrqUnmappedVintRouteDelete>:
; {
700ac760: b580         	push	{r7, lr}
700ac762: b084         	sub	sp, #0x10
700ac764: 9003         	str	r0, [sp, #0xc]
700ac766: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac768: 9002         	str	r0, [sp, #0x8]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700ac76a: 9903         	ldr	r1, [sp, #0xc]
700ac76c: 8a08         	ldrh	r0, [r1, #0x10]
700ac76e: 8a49         	ldrh	r1, [r1, #0x12]
700ac770: f10d 0207    	add.w	r2, sp, #0x7
700ac774: f7fe fe84    	bl	0x700ab480 <Sciclient_rmIaVintGetInfo> @ imm = #-0x12f8
700ac778: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700ac77a: 9802         	ldr	r0, [sp, #0x8]
700ac77c: b940         	cbnz	r0, 0x700ac790 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x10
700ac77e: e7ff         	b	0x700ac780 <Sciclient_rmIrqUnmappedVintRouteDelete+0x20> @ imm = #-0x2
700ac780: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ac784: b120         	cbz	r0, 0x700ac790 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x8
700ac786: e7ff         	b	0x700ac788 <Sciclient_rmIrqUnmappedVintRouteDelete+0x28> @ imm = #-0x2
700ac788: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ac78c: 9002         	str	r0, [sp, #0x8]
;     }
700ac78e: e7ff         	b	0x700ac790 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ac790: 9802         	ldr	r0, [sp, #0x8]
700ac792: b970         	cbnz	r0, 0x700ac7b2 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #0x1c
700ac794: e7ff         	b	0x700ac796 <Sciclient_rmIrqUnmappedVintRouteDelete+0x36> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700ac796: 9803         	ldr	r0, [sp, #0xc]
700ac798: f7f0 f9ea    	bl	0x7009cb70 <Sciclient_rmIrqGetRoute> @ imm = #-0xfc2c
700ac79c: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700ac79e: 9802         	ldr	r0, [sp, #0x8]
700ac7a0: b930         	cbnz	r0, 0x700ac7b0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #0xc
700ac7a2: e7ff         	b	0x700ac7a4 <Sciclient_rmIrqUnmappedVintRouteDelete+0x44> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, false);
700ac7a4: 9803         	ldr	r0, [sp, #0xc]
700ac7a6: 2100         	movs	r1, #0x0
700ac7a8: f7f3 ff72    	bl	0x700a0690 <Sciclient_rmIrqDeleteRoute> @ imm = #-0xc11c
700ac7ac: 9002         	str	r0, [sp, #0x8]
;         }
700ac7ae: e7ff         	b	0x700ac7b0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #-0x2
;     }
700ac7b0: e7ff         	b	0x700ac7b2 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #-0x2
;     return r;
700ac7b2: 9802         	ldr	r0, [sp, #0x8]
700ac7b4: b004         	add	sp, #0x10
700ac7b6: bd80         	pop	{r7, pc}
		...

700ac7c0 <Sciclient_rmRingCfg>:
; {
700ac7c0: b580         	push	{r7, lr}
700ac7c2: b08c         	sub	sp, #0x30
700ac7c4: 900b         	str	r0, [sp, #0x2c]
700ac7c6: 910a         	str	r1, [sp, #0x28]
700ac7c8: 9209         	str	r2, [sp, #0x24]
700ac7ca: f241 1010    	movw	r0, #0x1110
;     sciReq.messageType    = TISCI_MSG_RM_RING_CFG;
700ac7ce: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac7d2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac7d4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac7d6: 980b         	ldr	r0, [sp, #0x2c]
700ac7d8: 9005         	str	r0, [sp, #0x14]
700ac7da: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac7dc: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac7de: 9809         	ldr	r0, [sp, #0x24]
700ac7e0: 9007         	str	r0, [sp, #0x1c]
700ac7e2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac7e4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac7e6: 980a         	ldr	r0, [sp, #0x28]
700ac7e8: 9001         	str	r0, [sp, #0x4]
700ac7ea: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac7ec: 9002         	str	r0, [sp, #0x8]
700ac7ee: a803         	add	r0, sp, #0xc
700ac7f0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac7f2: f7f0 fcc5    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xf676
700ac7f6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac7f8: 9808         	ldr	r0, [sp, #0x20]
700ac7fa: b930         	cbnz	r0, 0x700ac80a <Sciclient_rmRingCfg+0x4a> @ imm = #0xc
700ac7fc: e7ff         	b	0x700ac7fe <Sciclient_rmRingCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac7fe: 9800         	ldr	r0, [sp]
700ac800: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac804: 2802         	cmp	r0, #0x2
700ac806: d004         	beq	0x700ac812 <Sciclient_rmRingCfg+0x52> @ imm = #0x8
700ac808: e7ff         	b	0x700ac80a <Sciclient_rmRingCfg+0x4a> @ imm = #-0x2
700ac80a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac80e: 9008         	str	r0, [sp, #0x20]
;     }
700ac810: e7ff         	b	0x700ac812 <Sciclient_rmRingCfg+0x52> @ imm = #-0x2
;     return r;
700ac812: 9808         	ldr	r0, [sp, #0x20]
700ac814: b00c         	add	sp, #0x30
700ac816: bd80         	pop	{r7, pc}
		...

700ac820 <Sciclient_rmUdmapFlowCfg>:
; {
700ac820: b580         	push	{r7, lr}
700ac822: b08c         	sub	sp, #0x30
700ac824: 900b         	str	r0, [sp, #0x2c]
700ac826: 910a         	str	r1, [sp, #0x28]
700ac828: 9209         	str	r2, [sp, #0x24]
700ac82a: f241 2030    	movw	r0, #0x1230
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_CFG;
700ac82e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac832: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac834: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac836: 980b         	ldr	r0, [sp, #0x2c]
700ac838: 9005         	str	r0, [sp, #0x14]
700ac83a: 2029         	movs	r0, #0x29
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac83c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac83e: 9809         	ldr	r0, [sp, #0x24]
700ac840: 9007         	str	r0, [sp, #0x1c]
700ac842: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac844: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac846: 980a         	ldr	r0, [sp, #0x28]
700ac848: 9001         	str	r0, [sp, #0x4]
700ac84a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac84c: 9002         	str	r0, [sp, #0x8]
700ac84e: a803         	add	r0, sp, #0xc
700ac850: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac852: f7f0 fc95    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xf6d6
700ac856: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac858: 9808         	ldr	r0, [sp, #0x20]
700ac85a: b930         	cbnz	r0, 0x700ac86a <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #0xc
700ac85c: e7ff         	b	0x700ac85e <Sciclient_rmUdmapFlowCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac85e: 9800         	ldr	r0, [sp]
700ac860: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac864: 2802         	cmp	r0, #0x2
700ac866: d004         	beq	0x700ac872 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #0x8
700ac868: e7ff         	b	0x700ac86a <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #-0x2
700ac86a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac86e: 9008         	str	r0, [sp, #0x20]
;     }
700ac870: e7ff         	b	0x700ac872 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #-0x2
;     return r;
700ac872: 9808         	ldr	r0, [sp, #0x20]
700ac874: b00c         	add	sp, #0x30
700ac876: bd80         	pop	{r7, pc}
		...

700ac880 <Sciclient_rmUdmapFlowSizeThreshCfg>:
; {
700ac880: b580         	push	{r7, lr}
700ac882: b08c         	sub	sp, #0x30
700ac884: 900b         	str	r0, [sp, #0x2c]
700ac886: 910a         	str	r1, [sp, #0x28]
700ac888: 9209         	str	r2, [sp, #0x24]
700ac88a: f241 2031    	movw	r0, #0x1231
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_SIZE_THRESH_CFG;
700ac88e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac892: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac894: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac896: 980b         	ldr	r0, [sp, #0x2c]
700ac898: 9005         	str	r0, [sp, #0x14]
700ac89a: 201d         	movs	r0, #0x1d
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac89c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac89e: 9809         	ldr	r0, [sp, #0x24]
700ac8a0: 9007         	str	r0, [sp, #0x1c]
700ac8a2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac8a4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac8a6: 980a         	ldr	r0, [sp, #0x28]
700ac8a8: 9001         	str	r0, [sp, #0x4]
700ac8aa: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac8ac: 9002         	str	r0, [sp, #0x8]
700ac8ae: a803         	add	r0, sp, #0xc
700ac8b0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac8b2: f7f0 fc65    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xf736
700ac8b6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac8b8: 9808         	ldr	r0, [sp, #0x20]
700ac8ba: b930         	cbnz	r0, 0x700ac8ca <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #0xc
700ac8bc: e7ff         	b	0x700ac8be <Sciclient_rmUdmapFlowSizeThreshCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac8be: 9800         	ldr	r0, [sp]
700ac8c0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac8c4: 2802         	cmp	r0, #0x2
700ac8c6: d004         	beq	0x700ac8d2 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #0x8
700ac8c8: e7ff         	b	0x700ac8ca <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #-0x2
700ac8ca: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac8ce: 9008         	str	r0, [sp, #0x20]
;     }
700ac8d0: e7ff         	b	0x700ac8d2 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #-0x2
;     return r;
700ac8d2: 9808         	ldr	r0, [sp, #0x20]
700ac8d4: b00c         	add	sp, #0x30
700ac8d6: bd80         	pop	{r7, pc}
		...

700ac8e0 <Sciclient_rmUdmapRxChCfg>:
; {
700ac8e0: b580         	push	{r7, lr}
700ac8e2: b08c         	sub	sp, #0x30
700ac8e4: 900b         	str	r0, [sp, #0x2c]
700ac8e6: 910a         	str	r1, [sp, #0x28]
700ac8e8: 9209         	str	r2, [sp, #0x24]
700ac8ea: f241 2015    	movw	r0, #0x1215
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_RX_CH_CFG;
700ac8ee: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac8f2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac8f4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac8f6: 980b         	ldr	r0, [sp, #0x2c]
700ac8f8: 9005         	str	r0, [sp, #0x14]
700ac8fa: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac8fc: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac8fe: 9809         	ldr	r0, [sp, #0x24]
700ac900: 9007         	str	r0, [sp, #0x1c]
700ac902: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac904: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac906: 980a         	ldr	r0, [sp, #0x28]
700ac908: 9001         	str	r0, [sp, #0x4]
700ac90a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac90c: 9002         	str	r0, [sp, #0x8]
700ac90e: a803         	add	r0, sp, #0xc
700ac910: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac912: f7f0 fc35    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xf796
700ac916: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac918: 9808         	ldr	r0, [sp, #0x20]
700ac91a: b930         	cbnz	r0, 0x700ac92a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #0xc
700ac91c: e7ff         	b	0x700ac91e <Sciclient_rmUdmapRxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac91e: 9800         	ldr	r0, [sp]
700ac920: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac924: 2802         	cmp	r0, #0x2
700ac926: d004         	beq	0x700ac932 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #0x8
700ac928: e7ff         	b	0x700ac92a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #-0x2
700ac92a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac92e: 9008         	str	r0, [sp, #0x20]
;     }
700ac930: e7ff         	b	0x700ac932 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #-0x2
;     return r;
700ac932: 9808         	ldr	r0, [sp, #0x20]
700ac934: b00c         	add	sp, #0x30
700ac936: bd80         	pop	{r7, pc}
		...

700ac940 <Sciclient_rmUdmapTxChCfg>:
; {
700ac940: b580         	push	{r7, lr}
700ac942: b08c         	sub	sp, #0x30
700ac944: 900b         	str	r0, [sp, #0x2c]
700ac946: 910a         	str	r1, [sp, #0x28]
700ac948: 9209         	str	r2, [sp, #0x24]
700ac94a: f241 2005    	movw	r0, #0x1205
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_TX_CH_CFG;
700ac94e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac952: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac954: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac956: 980b         	ldr	r0, [sp, #0x2c]
700ac958: 9005         	str	r0, [sp, #0x14]
700ac95a: 2024         	movs	r0, #0x24
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac95c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac95e: 9809         	ldr	r0, [sp, #0x24]
700ac960: 9007         	str	r0, [sp, #0x1c]
700ac962: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac964: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac966: 980a         	ldr	r0, [sp, #0x28]
700ac968: 9001         	str	r0, [sp, #0x4]
700ac96a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac96c: 9002         	str	r0, [sp, #0x8]
700ac96e: a803         	add	r0, sp, #0xc
700ac970: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac972: f7f0 fc05    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xf7f6
700ac976: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac978: 9808         	ldr	r0, [sp, #0x20]
700ac97a: b930         	cbnz	r0, 0x700ac98a <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #0xc
700ac97c: e7ff         	b	0x700ac97e <Sciclient_rmUdmapTxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac97e: 9800         	ldr	r0, [sp]
700ac980: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac984: 2802         	cmp	r0, #0x2
700ac986: d004         	beq	0x700ac992 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #0x8
700ac988: e7ff         	b	0x700ac98a <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #-0x2
700ac98a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac98e: 9008         	str	r0, [sp, #0x20]
;     }
700ac990: e7ff         	b	0x700ac992 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #-0x2
;     return r;
700ac992: 9808         	ldr	r0, [sp, #0x20]
700ac994: b00c         	add	sp, #0x30
700ac996: bd80         	pop	{r7, pc}

700ac998 <_outs>:
700ac998: e92d4070     	push	{r4, r5, r6, lr}
700ac99c: e5916004     	ldr	r6, [r1, #0x4]
700ac9a0: e1a04001     	mov	r4, r1
700ac9a4: e5913008     	ldr	r3, [r1, #0x8]
700ac9a8: e1a05002     	mov	r5, r2
700ac9ac: e1560003     	cmp	r6, r3
700ac9b0: 9a00000a     	bls	0x700ac9e0 <_outs+0x48> @ imm = #0x28
700ac9b4: e0466003     	sub	r6, r6, r3
700ac9b8: e1a01000     	mov	r1, r0
700ac9bc: e5940000     	ldr	r0, [r4]
700ac9c0: e1560005     	cmp	r6, r5
700ac9c4: 21a06005     	movhs	r6, r5
700ac9c8: e1a02006     	mov	r2, r6
700ac9cc: ebffb562     	bl	0x70099f5c <__aeabi_memcpy8> @ imm = #-0x12a78
700ac9d0: e5940000     	ldr	r0, [r4]
700ac9d4: e5943008     	ldr	r3, [r4, #0x8]
700ac9d8: e0800006     	add	r0, r0, r6
700ac9dc: e5840000     	str	r0, [r4]
700ac9e0: e0831005     	add	r1, r3, r5
700ac9e4: e1a00005     	mov	r0, r5
700ac9e8: e5841008     	str	r1, [r4, #0x8]
700ac9ec: e8bd8070     	pop	{r4, r5, r6, pc}

700ac9f0 <xQueueGenericCreate>:
;     {
700ac9f0: b580         	push	{r7, lr}
700ac9f2: b088         	sub	sp, #0x20
700ac9f4: 9007         	str	r0, [sp, #0x1c]
700ac9f6: 9106         	str	r1, [sp, #0x18]
700ac9f8: f88d 2017    	strb.w	r2, [sp, #0x17]
;         xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
700ac9fc: 9807         	ldr	r0, [sp, #0x1c]
700ac9fe: 9906         	ldr	r1, [sp, #0x18]
700aca00: 4348         	muls	r0, r1, r0
700aca02: 9003         	str	r0, [sp, #0xc]
;         pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
700aca04: 9803         	ldr	r0, [sp, #0xc]
700aca06: 3050         	adds	r0, #0x50
700aca08: f002 fd9a    	bl	0x700af540 <pvPortMalloc> @ imm = #0x2b34
700aca0c: 9004         	str	r0, [sp, #0x10]
;         if( pxNewQueue != NULL )
700aca0e: 9804         	ldr	r0, [sp, #0x10]
700aca10: b1b0         	cbz	r0, 0x700aca40 <xQueueGenericCreate+0x50> @ imm = #0x2c
700aca12: e7ff         	b	0x700aca14 <xQueueGenericCreate+0x24> @ imm = #-0x2
;             pucQueueStorage = ( uint8_t * ) pxNewQueue;
700aca14: 9804         	ldr	r0, [sp, #0x10]
700aca16: 9002         	str	r0, [sp, #0x8]
;             pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700aca18: 9802         	ldr	r0, [sp, #0x8]
700aca1a: 3050         	adds	r0, #0x50
700aca1c: 9002         	str	r0, [sp, #0x8]
;                     pxNewQueue->ucStaticallyAllocated = pdFALSE;
700aca1e: 9904         	ldr	r1, [sp, #0x10]
700aca20: 2000         	movs	r0, #0x0
700aca22: f881 0046    	strb.w	r0, [r1, #0x46]
;             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
700aca26: 9807         	ldr	r0, [sp, #0x1c]
700aca28: 9906         	ldr	r1, [sp, #0x18]
700aca2a: 9a02         	ldr	r2, [sp, #0x8]
700aca2c: f89d 3017    	ldrb.w	r3, [sp, #0x17]
700aca30: f8dd c010    	ldr.w	r12, [sp, #0x10]
700aca34: 46ee         	mov	lr, sp
700aca36: f8ce c000    	str.w	r12, [lr]
700aca3a: f000 fdc9    	bl	0x700ad5d0 <prvInitialiseNewQueue> @ imm = #0xb92
;         }
700aca3e: e000         	b	0x700aca42 <xQueueGenericCreate+0x52> @ imm = #0x0
700aca40: e7ff         	b	0x700aca42 <xQueueGenericCreate+0x52> @ imm = #-0x2
;         return pxNewQueue;
700aca42: 9804         	ldr	r0, [sp, #0x10]
700aca44: b008         	add	sp, #0x20
700aca46: bd80         	pop	{r7, pc}

700aca48 <__TI_auto_init_nobinit_nopinit>:
700aca48: e92d4070     	push	{r4, r5, r6, lr}
700aca4c: e59f4040     	ldr	r4, [pc, #0x40]         @ 0x700aca94 <__TI_auto_init_nobinit_nopinit+0x4c>
700aca50: e59f0038     	ldr	r0, [pc, #0x38]         @ 0x700aca90 <__TI_auto_init_nobinit_nopinit+0x48>
700aca54: e1540000     	cmp	r4, r0
700aca58: 0a00000a     	beq	0x700aca88 <__TI_auto_init_nobinit_nopinit+0x40> @ imm = #0x28
700aca5c: e59f5034     	ldr	r5, [pc, #0x34]         @ 0x700aca98 <__TI_auto_init_nobinit_nopinit+0x50>
700aca60: e59f6034     	ldr	r6, [pc, #0x34]         @ 0x700aca9c <__TI_auto_init_nobinit_nopinit+0x54>
700aca64: e1550006     	cmp	r5, r6
700aca68: 0a000006     	beq	0x700aca88 <__TI_auto_init_nobinit_nopinit+0x40> @ imm = #0x18
700aca6c: e5950000     	ldr	r0, [r5]
700aca70: e5951004     	ldr	r1, [r5, #0x4]
700aca74: e4d02001     	ldrb	r2, [r0], #1
700aca78: e7942102     	ldr	r2, [r4, r2, lsl #2]
700aca7c: e12fff32     	blx	r2
700aca80: e2855008     	add	r5, r5, #8
700aca84: eafffff6     	b	0x700aca64 <__TI_auto_init_nobinit_nopinit+0x1c> @ imm = #-0x28
700aca88: e1a00000     	mov	r0, r0
700aca8c: e8bd8070     	pop	{r4, r5, r6, pc}
700aca90: 00 00 00 00  	.word	0x00000000
700aca94: 00 00 00 00  	.word	0x00000000
700aca98: 00 00 00 00  	.word	0x00000000
700aca9c: 00 00 00 00  	.word	0x00000000

700acaa0 <Sciclient_rmIrqReleaseRaw>:
; {
700acaa0: b580         	push	{r7, lr}
700acaa2: b08e         	sub	sp, #0x38
700acaa4: 900d         	str	r0, [sp, #0x34]
700acaa6: 910c         	str	r1, [sp, #0x30]
700acaa8: f241 0001    	movw	r0, #0x1001
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_RELEASE;
700acaac: f8ad 0018    	strh.w	r0, [sp, #0x18]
700acab0: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700acab2: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700acab4: 980d         	ldr	r0, [sp, #0x34]
700acab6: 9008         	str	r0, [sp, #0x20]
700acab8: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700acaba: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700acabc: 980c         	ldr	r0, [sp, #0x30]
700acabe: 900a         	str	r0, [sp, #0x28]
700acac0: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700acac2: 9003         	str	r0, [sp, #0xc]
700acac4: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700acac6: 9004         	str	r0, [sp, #0x10]
700acac8: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700acaca: 9005         	str	r0, [sp, #0x14]
700acacc: a806         	add	r0, sp, #0x18
700acace: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700acad0: f7f0 fb56    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xf954
700acad4: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700acad6: 980b         	ldr	r0, [sp, #0x2c]
700acad8: b930         	cbnz	r0, 0x700acae8 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #0xc
700acada: e7ff         	b	0x700acadc <Sciclient_rmIrqReleaseRaw+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700acadc: 9803         	ldr	r0, [sp, #0xc]
700acade: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700acae2: 2802         	cmp	r0, #0x2
700acae4: d004         	beq	0x700acaf0 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #0x8
700acae6: e7ff         	b	0x700acae8 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #-0x2
700acae8: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700acaec: 900b         	str	r0, [sp, #0x2c]
;     }
700acaee: e7ff         	b	0x700acaf0 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #-0x2
;     return r;
700acaf0: 980b         	ldr	r0, [sp, #0x2c]
700acaf2: b00e         	add	sp, #0x38
700acaf4: bd80         	pop	{r7, pc}
		...
700acafe: 0000         	movs	r0, r0

700acb00 <Sciclient_rmPsilPair>:
; {
700acb00: b580         	push	{r7, lr}
700acb02: b08e         	sub	sp, #0x38
700acb04: 900d         	str	r0, [sp, #0x34]
700acb06: 910c         	str	r1, [sp, #0x30]
700acb08: f44f 5094    	mov.w	r0, #0x1280
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_PAIR;
700acb0c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700acb10: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700acb12: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700acb14: 980d         	ldr	r0, [sp, #0x34]
700acb16: 9008         	str	r0, [sp, #0x20]
700acb18: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700acb1a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700acb1c: 980c         	ldr	r0, [sp, #0x30]
700acb1e: 900a         	str	r0, [sp, #0x28]
700acb20: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700acb22: 9003         	str	r0, [sp, #0xc]
700acb24: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t*)&resp;
700acb26: 9004         	str	r0, [sp, #0x10]
700acb28: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700acb2a: 9005         	str	r0, [sp, #0x14]
700acb2c: a806         	add	r0, sp, #0x18
700acb2e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700acb30: f7f0 fb26    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xf9b4
700acb34: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700acb36: 980b         	ldr	r0, [sp, #0x2c]
700acb38: b930         	cbnz	r0, 0x700acb48 <Sciclient_rmPsilPair+0x48> @ imm = #0xc
700acb3a: e7ff         	b	0x700acb3c <Sciclient_rmPsilPair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700acb3c: 9803         	ldr	r0, [sp, #0xc]
700acb3e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700acb42: 2802         	cmp	r0, #0x2
700acb44: d004         	beq	0x700acb50 <Sciclient_rmPsilPair+0x50> @ imm = #0x8
700acb46: e7ff         	b	0x700acb48 <Sciclient_rmPsilPair+0x48> @ imm = #-0x2
700acb48: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700acb4c: 900b         	str	r0, [sp, #0x2c]
;     }
700acb4e: e7ff         	b	0x700acb50 <Sciclient_rmPsilPair+0x50> @ imm = #-0x2
;     return r;
700acb50: 980b         	ldr	r0, [sp, #0x2c]
700acb52: b00e         	add	sp, #0x38
700acb54: bd80         	pop	{r7, pc}
		...
700acb5e: 0000         	movs	r0, r0

700acb60 <Sciclient_rmPsilUnpair>:
; {
700acb60: b580         	push	{r7, lr}
700acb62: b08e         	sub	sp, #0x38
700acb64: 900d         	str	r0, [sp, #0x34]
700acb66: 910c         	str	r1, [sp, #0x30]
700acb68: f241 2081    	movw	r0, #0x1281
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_UNPAIR;
700acb6c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700acb70: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700acb72: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700acb74: 980d         	ldr	r0, [sp, #0x34]
700acb76: 9008         	str	r0, [sp, #0x20]
700acb78: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700acb7a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700acb7c: 980c         	ldr	r0, [sp, #0x30]
700acb7e: 900a         	str	r0, [sp, #0x28]
700acb80: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700acb82: 9003         	str	r0, [sp, #0xc]
700acb84: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700acb86: 9004         	str	r0, [sp, #0x10]
700acb88: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700acb8a: 9005         	str	r0, [sp, #0x14]
700acb8c: a806         	add	r0, sp, #0x18
700acb8e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700acb90: f7f0 faf6    	bl	0x7009d180 <Sciclient_service> @ imm = #-0xfa14
700acb94: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700acb96: 980b         	ldr	r0, [sp, #0x2c]
700acb98: b930         	cbnz	r0, 0x700acba8 <Sciclient_rmPsilUnpair+0x48> @ imm = #0xc
700acb9a: e7ff         	b	0x700acb9c <Sciclient_rmPsilUnpair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700acb9c: 9803         	ldr	r0, [sp, #0xc]
700acb9e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700acba2: 2802         	cmp	r0, #0x2
700acba4: d004         	beq	0x700acbb0 <Sciclient_rmPsilUnpair+0x50> @ imm = #0x8
700acba6: e7ff         	b	0x700acba8 <Sciclient_rmPsilUnpair+0x48> @ imm = #-0x2
700acba8: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700acbac: 900b         	str	r0, [sp, #0x2c]
;     }
700acbae: e7ff         	b	0x700acbb0 <Sciclient_rmPsilUnpair+0x50> @ imm = #-0x2
;     return r;
700acbb0: 980b         	ldr	r0, [sp, #0x2c]
700acbb2: b00e         	add	sp, #0x38
700acbb4: bd80         	pop	{r7, pc}
		...
700acbbe: 0000         	movs	r0, r0

700acbc0 <Udma_chSetPeerReg>:
; {
700acbc0: b580         	push	{r7, lr}
700acbc2: b086         	sub	sp, #0x18
700acbc4: f8dd c020    	ldr.w	r12, [sp, #0x20]
700acbc8: 9005         	str	r0, [sp, #0x14]
700acbca: 9104         	str	r1, [sp, #0x10]
700acbcc: 9203         	str	r2, [sp, #0xc]
700acbce: 9302         	str	r3, [sp, #0x8]
;     regVal = CSL_REG32_RD(PEER8);
700acbd0: 9803         	ldr	r0, [sp, #0xc]
700acbd2: f003 f81d    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0x303a
700acbd6: 9001         	str	r0, [sp, #0x4]
;     CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 0U);
700acbd8: 9801         	ldr	r0, [sp, #0x4]
700acbda: f020 4000    	bic	r0, r0, #0x80000000
700acbde: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER8, regVal);
700acbe0: 9803         	ldr	r0, [sp, #0xc]
700acbe2: 9901         	ldr	r1, [sp, #0x4]
700acbe4: f002 ff74    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0x2ee8
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700acbe8: 9804         	ldr	r0, [sp, #0x10]
700acbea: 6801         	ldr	r1, [r0]
;                 CSL_FMK(PSILCFG_REG_STATIC_TR_Y, pdmaPrms->elemCnt);
700acbec: 6840         	ldr	r0, [r0, #0x4]
700acbee: f36f 301f    	bfc	r0, #12, #20
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700acbf2: f361 601a    	bfi	r0, r1, #24, #3
700acbf6: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER0, regVal);
700acbf8: 9808         	ldr	r0, [sp, #0x20]
700acbfa: 9901         	ldr	r1, [sp, #0x4]
700acbfc: f002 ff68    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0x2ed0
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_Z, pdmaPrms->fifoCnt);
700acc00: 9804         	ldr	r0, [sp, #0x10]
700acc02: 6880         	ldr	r0, [r0, #0x8]
700acc04: f36f 301f    	bfc	r0, #12, #20
700acc08: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER1, regVal);
700acc0a: 9802         	ldr	r0, [sp, #0x8]
700acc0c: 9901         	ldr	r1, [sp, #0x4]
700acc0e: f002 ff5f    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0x2ebe
; }
700acc12: b006         	add	sp, #0x18
700acc14: bd80         	pop	{r7, pc}
		...
700acc1e: 0000         	movs	r0, r0

700acc20 <Udma_eventGetGlobalHandle>:
; {
700acc20: b084         	sub	sp, #0x10
700acc22: 9003         	str	r0, [sp, #0xc]
700acc24: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700acc26: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandle    eventHandle = (Udma_EventHandle) NULL_PTR;
700acc28: 9000         	str	r0, [sp]
;     if(NULL_PTR == drvHandle)
700acc2a: 9803         	ldr	r0, [sp, #0xc]
700acc2c: b920         	cbnz	r0, 0x700acc38 <Udma_eventGetGlobalHandle+0x18> @ imm = #0x8
700acc2e: e7ff         	b	0x700acc30 <Udma_eventGetGlobalHandle+0x10> @ imm = #-0x2
700acc30: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700acc34: 9002         	str	r0, [sp, #0x8]
;     }
700acc36: e7ff         	b	0x700acc38 <Udma_eventGetGlobalHandle+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700acc38: 9802         	ldr	r0, [sp, #0x8]
700acc3a: b988         	cbnz	r0, 0x700acc60 <Udma_eventGetGlobalHandle+0x40> @ imm = #0x22
700acc3c: e7ff         	b	0x700acc3e <Udma_eventGetGlobalHandle+0x1e> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700acc3e: 9803         	ldr	r0, [sp, #0xc]
700acc40: 9001         	str	r0, [sp, #0x4]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700acc42: 9801         	ldr	r0, [sp, #0x4]
700acc44: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700acc48: f64a 31cd    	movw	r1, #0xabcd
700acc4c: f6ca 31dc    	movt	r1, #0xabdc
700acc50: 4288         	cmp	r0, r1
700acc52: d004         	beq	0x700acc5e <Udma_eventGetGlobalHandle+0x3e> @ imm = #0x8
700acc54: e7ff         	b	0x700acc56 <Udma_eventGetGlobalHandle+0x36> @ imm = #-0x2
700acc56: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700acc5a: 9002         	str	r0, [sp, #0x8]
;         }
700acc5c: e7ff         	b	0x700acc5e <Udma_eventGetGlobalHandle+0x3e> @ imm = #-0x2
;     }
700acc5e: e7ff         	b	0x700acc60 <Udma_eventGetGlobalHandle+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700acc60: 9802         	ldr	r0, [sp, #0x8]
700acc62: b928         	cbnz	r0, 0x700acc70 <Udma_eventGetGlobalHandle+0x50> @ imm = #0xa
700acc64: e7ff         	b	0x700acc66 <Udma_eventGetGlobalHandle+0x46> @ imm = #-0x2
;         eventHandle = (Udma_EventHandle) drvHandleInt->globalEventHandle;
700acc66: 9801         	ldr	r0, [sp, #0x4]
700acc68: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
700acc6c: 9000         	str	r0, [sp]
;     }
700acc6e: e7ff         	b	0x700acc70 <Udma_eventGetGlobalHandle+0x50> @ imm = #-0x2
;     return (eventHandle);
700acc70: 9800         	ldr	r0, [sp]
700acc72: b004         	add	sp, #0x10
700acc74: 4770         	bx	lr
		...
700acc7e: 0000         	movs	r0, r0

700acc80 <CSL_pktdmaIsValidChanIdx>:
; {
700acc80: b084         	sub	sp, #0x10
700acc82: 9003         	str	r0, [sp, #0xc]
700acc84: 9102         	str	r1, [sp, #0x8]
700acc86: 9201         	str	r2, [sp, #0x4]
;     if( (chanDir == CSL_PKTDMA_CHAN_DIR_TX) && (chanIdx < pCfg->txChanCnt) )
700acc88: 9801         	ldr	r0, [sp, #0x4]
700acc8a: b950         	cbnz	r0, 0x700acca2 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x14
700acc8c: e7ff         	b	0x700acc8e <CSL_pktdmaIsValidChanIdx+0xe> @ imm = #-0x2
700acc8e: 9802         	ldr	r0, [sp, #0x8]
700acc90: 9903         	ldr	r1, [sp, #0xc]
700acc92: 6a09         	ldr	r1, [r1, #0x20]
700acc94: 4288         	cmp	r0, r1
700acc96: d204         	bhs	0x700acca2 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x8
700acc98: e7ff         	b	0x700acc9a <CSL_pktdmaIsValidChanIdx+0x1a> @ imm = #-0x2
700acc9a: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700acc9c: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700acca0: e012         	b	0x700accc8 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #0x24
;     else if( (chanDir == CSL_PKTDMA_CHAN_DIR_RX) && (chanIdx < pCfg->rxChanCnt) )
700acca2: 9801         	ldr	r0, [sp, #0x4]
700acca4: 2801         	cmp	r0, #0x1
700acca6: d10a         	bne	0x700accbe <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x14
700acca8: e7ff         	b	0x700accaa <CSL_pktdmaIsValidChanIdx+0x2a> @ imm = #-0x2
700accaa: 9802         	ldr	r0, [sp, #0x8]
700accac: 9903         	ldr	r1, [sp, #0xc]
700accae: 6a49         	ldr	r1, [r1, #0x24]
700accb0: 4288         	cmp	r0, r1
700accb2: d204         	bhs	0x700accbe <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x8
700accb4: e7ff         	b	0x700accb6 <CSL_pktdmaIsValidChanIdx+0x36> @ imm = #-0x2
700accb6: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700accb8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700accbc: e003         	b	0x700accc6 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #0x6
700accbe: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700accc0: f88d 0003    	strb.w	r0, [sp, #0x3]
700accc4: e7ff         	b	0x700accc6 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #-0x2
700accc6: e7ff         	b	0x700accc8 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #-0x2
;     return bRetVal;
700accc8: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700acccc: f000 0001    	and	r0, r0, #0x1
700accd0: b004         	add	sp, #0x10
700accd2: 4770         	bx	lr
		...

700acce0 <Sciclient_rmUnmappedVintRouteCreate>:
; {
700acce0: b580         	push	{r7, lr}
700acce2: b084         	sub	sp, #0x10
700acce4: 9003         	str	r0, [sp, #0xc]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700acce6: 9903         	ldr	r1, [sp, #0xc]
700acce8: 8a08         	ldrh	r0, [r1, #0x10]
700accea: 8a49         	ldrh	r1, [r1, #0x12]
700accec: f10d 0207    	add.w	r2, sp, #0x7
700accf0: f7fe fbc6    	bl	0x700ab480 <Sciclient_rmIaVintGetInfo> @ imm = #-0x1874
700accf4: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700accf6: 9802         	ldr	r0, [sp, #0x8]
700accf8: b940         	cbnz	r0, 0x700acd0c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x10
700accfa: e7ff         	b	0x700accfc <Sciclient_rmUnmappedVintRouteCreate+0x1c> @ imm = #-0x2
700accfc: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700acd00: b120         	cbz	r0, 0x700acd0c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x8
700acd02: e7ff         	b	0x700acd04 <Sciclient_rmUnmappedVintRouteCreate+0x24> @ imm = #-0x2
700acd04: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700acd08: 9002         	str	r0, [sp, #0x8]
;     }
700acd0a: e7ff         	b	0x700acd0c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700acd0c: 9802         	ldr	r0, [sp, #0x8]
700acd0e: b970         	cbnz	r0, 0x700acd2e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #0x1c
700acd10: e7ff         	b	0x700acd12 <Sciclient_rmUnmappedVintRouteCreate+0x32> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700acd12: 9803         	ldr	r0, [sp, #0xc]
700acd14: f7f1 f8c4    	bl	0x7009dea0 <Sciclient_rmIrqFindRoute> @ imm = #-0xee78
700acd18: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700acd1a: 9802         	ldr	r0, [sp, #0x8]
700acd1c: b930         	cbnz	r0, 0x700acd2c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #0xc
700acd1e: e7ff         	b	0x700acd20 <Sciclient_rmUnmappedVintRouteCreate+0x40> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, false);
700acd20: 9803         	ldr	r0, [sp, #0xc]
700acd22: 2100         	movs	r1, #0x0
700acd24: f7f3 ff0c    	bl	0x700a0b40 <Sciclient_rmIrqProgramRoute> @ imm = #-0xc1e8
700acd28: 9002         	str	r0, [sp, #0x8]
;         }
700acd2a: e7ff         	b	0x700acd2c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #-0x2
;     }
700acd2c: e7ff         	b	0x700acd2e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #-0x2
;     return r;
700acd2e: 9802         	ldr	r0, [sp, #0x8]
700acd30: b004         	add	sp, #0x10
700acd32: bd80         	pop	{r7, pc}
		...

700acd40 <UART_OperModeValid>:
; {
700acd40: b082         	sub	sp, #0x8
700acd42: 9001         	str	r0, [sp, #0x4]
700acd44: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700acd48: 9000         	str	r0, [sp]
;     if(((operMode == UART_OPER_MODE_16X) ||
700acd4a: 9801         	ldr	r0, [sp, #0x4]
700acd4c: b1e0         	cbz	r0, 0x700acd88 <UART_OperModeValid+0x48> @ imm = #0x38
700acd4e: e7ff         	b	0x700acd50 <UART_OperModeValid+0x10> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_SIR) ||
700acd50: 9801         	ldr	r0, [sp, #0x4]
700acd52: 2801         	cmp	r0, #0x1
700acd54: d018         	beq	0x700acd88 <UART_OperModeValid+0x48> @ imm = #0x30
700acd56: e7ff         	b	0x700acd58 <UART_OperModeValid+0x18> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_16X_AUTO_BAUD) ||
700acd58: 9801         	ldr	r0, [sp, #0x4]
700acd5a: 2802         	cmp	r0, #0x2
700acd5c: d014         	beq	0x700acd88 <UART_OperModeValid+0x48> @ imm = #0x28
700acd5e: e7ff         	b	0x700acd60 <UART_OperModeValid+0x20> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_13X) ||
700acd60: 9801         	ldr	r0, [sp, #0x4]
700acd62: 2803         	cmp	r0, #0x3
700acd64: d010         	beq	0x700acd88 <UART_OperModeValid+0x48> @ imm = #0x20
700acd66: e7ff         	b	0x700acd68 <UART_OperModeValid+0x28> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_MIR) ||
700acd68: 9801         	ldr	r0, [sp, #0x4]
700acd6a: 2804         	cmp	r0, #0x4
700acd6c: d00c         	beq	0x700acd88 <UART_OperModeValid+0x48> @ imm = #0x18
700acd6e: e7ff         	b	0x700acd70 <UART_OperModeValid+0x30> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_FIR) ||
700acd70: 9801         	ldr	r0, [sp, #0x4]
700acd72: 2805         	cmp	r0, #0x5
700acd74: d008         	beq	0x700acd88 <UART_OperModeValid+0x48> @ imm = #0x10
700acd76: e7ff         	b	0x700acd78 <UART_OperModeValid+0x38> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_CIR) ||
700acd78: 9801         	ldr	r0, [sp, #0x4]
700acd7a: 2806         	cmp	r0, #0x6
700acd7c: d004         	beq	0x700acd88 <UART_OperModeValid+0x48> @ imm = #0x8
700acd7e: e7ff         	b	0x700acd80 <UART_OperModeValid+0x40> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_DISABLED)))
700acd80: 9801         	ldr	r0, [sp, #0x4]
;     if(((operMode == UART_OPER_MODE_16X) ||
700acd82: 2807         	cmp	r0, #0x7
700acd84: d103         	bne	0x700acd8e <UART_OperModeValid+0x4e> @ imm = #0x6
700acd86: e7ff         	b	0x700acd88 <UART_OperModeValid+0x48> @ imm = #-0x2
700acd88: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700acd8a: 9000         	str	r0, [sp]
;     }
700acd8c: e7ff         	b	0x700acd8e <UART_OperModeValid+0x4e> @ imm = #-0x2
;     return status;
700acd8e: 9800         	ldr	r0, [sp]
700acd90: b002         	add	sp, #0x8
700acd92: 4770         	bx	lr
		...

700acda0 <UdmaRingPrms_init>:
; {
700acda0: b081         	sub	sp, #0x4
700acda2: 9000         	str	r0, [sp]
;     if(NULL_PTR != ringPrms)
700acda4: 9800         	ldr	r0, [sp]
700acda6: b318         	cbz	r0, 0x700acdf0 <UdmaRingPrms_init+0x50> @ imm = #0x46
700acda8: e7ff         	b	0x700acdaa <UdmaRingPrms_init+0xa> @ imm = #-0x2
;         ringPrms->ringMem       = NULL_PTR;
700acdaa: 9900         	ldr	r1, [sp]
700acdac: 2000         	movs	r0, #0x0
700acdae: 6008         	str	r0, [r1]
;         ringPrms->ringMemSize   = UDMA_RING_SIZE_CHECK_SKIP;
700acdb0: 9a00         	ldr	r2, [sp]
700acdb2: f64a 31cd    	movw	r1, #0xabcd
700acdb6: f6ca 31dc    	movt	r1, #0xabdc
700acdba: 6051         	str	r1, [r2, #0x4]
;         ringPrms->mode          = TISCI_MSG_VALUE_RM_RING_MODE_RING;
700acdbc: 9900         	ldr	r1, [sp]
700acdbe: 7208         	strb	r0, [r1, #0x8]
;         ringPrms->virtId        = UDMA_RING_VIRTID_INVALID;
700acdc0: 9a00         	ldr	r2, [sp]
700acdc2: f64f 71ff    	movw	r1, #0xffff
700acdc6: 8151         	strh	r1, [r2, #0xa]
;         ringPrms->elemCnt       = 0U;
700acdc8: 9900         	ldr	r1, [sp]
700acdca: 60c8         	str	r0, [r1, #0xc]
;         ringPrms->elemSize      = UDMA_RING_ES_8BYTES;
700acdcc: 9a00         	ldr	r2, [sp]
700acdce: 2101         	movs	r1, #0x1
700acdd0: 7411         	strb	r1, [r2, #0x10]
;         ringPrms->orderId       = UDMA_DEFAULT_RING_ORDER_ID;
700acdd2: 9900         	ldr	r1, [sp]
700acdd4: 7448         	strb	r0, [r1, #0x11]
;         ringPrms->asel          = UDMA_RINGACC_ASEL_ENDPOINT_PHYSADDR;
700acdd6: 9900         	ldr	r1, [sp]
700acdd8: 7488         	strb	r0, [r1, #0x12]
;         ringPrms->mappedRingGrp = UDMA_MAPPED_GROUP_INVALID;
700acdda: 9900         	ldr	r1, [sp]
700acddc: 2004         	movs	r0, #0x4
700acdde: f6cf 70ff    	movt	r0, #0xffff
700acde2: 6148         	str	r0, [r1, #0x14]
;         ringPrms->mappedChNum   = UDMA_DMA_CH_INVALID;
700acde4: 9900         	ldr	r1, [sp]
700acde6: 2000         	movs	r0, #0x0
700acde8: f6cf 70ff    	movt	r0, #0xffff
700acdec: 6188         	str	r0, [r1, #0x18]
;     }
700acdee: e7ff         	b	0x700acdf0 <UdmaRingPrms_init+0x50> @ imm = #-0x2
;     return;
700acdf0: b001         	add	sp, #0x4
700acdf2: 4770         	bx	lr
		...

700ace00 <prvIdleTask>:
; static portTASK_FUNCTION(prvIdleTask, pvParameters) {
700ace00: b580         	push	{r7, lr}
700ace02: b082         	sub	sp, #0x8
700ace04: 9001         	str	r0, [sp, #0x4]
;   for (;;) {
700ace06: e7ff         	b	0x700ace08 <prvIdleTask+0x8> @ imm = #-0x2
;     prvCheckTasksWaitingTermination();
700ace08: f7ff fc4a    	bl	0x700ac6a0 <prvCheckTasksWaitingTermination> @ imm = #-0x76c
;       if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700ace0c: f244 40f8    	movw	r0, #0x44f8
700ace10: f2c7 0008    	movt	r0, #0x7008
700ace14: 6800         	ldr	r0, [r0]
700ace16: 2802         	cmp	r0, #0x2
700ace18: d302         	blo	0x700ace20 <prvIdleTask+0x20> @ imm = #0x4
700ace1a: e7ff         	b	0x700ace1c <prvIdleTask+0x1c> @ imm = #-0x2
;         taskYIELD();
700ace1c: df00         	svc	#0x0
;       } else {
700ace1e: e000         	b	0x700ace22 <prvIdleTask+0x22> @ imm = #0x0
700ace20: e7ff         	b	0x700ace22 <prvIdleTask+0x22> @ imm = #-0x2
;       vApplicationIdleHook();
700ace22: f002 ff55    	bl	0x700afcd0 <vApplicationIdleHook> @ imm = #0x2eaa
;       xExpectedIdleTime = prvGetExpectedIdleTime();
700ace26: f7fe f893    	bl	0x700aaf50 <prvGetExpectedIdleTime> @ imm = #-0x1eda
700ace2a: 9000         	str	r0, [sp]
;       if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700ace2c: 9800         	ldr	r0, [sp]
700ace2e: 2802         	cmp	r0, #0x2
700ace30: d30e         	blo	0x700ace50 <prvIdleTask+0x50> @ imm = #0x1c
700ace32: e7ff         	b	0x700ace34 <prvIdleTask+0x34> @ imm = #-0x2
;         vTaskSuspendAll();
700ace34: f002 fea4    	bl	0x700afb80 <vTaskSuspendAll> @ imm = #0x2d48
;           xExpectedIdleTime = prvGetExpectedIdleTime();
700ace38: f7fe f88a    	bl	0x700aaf50 <prvGetExpectedIdleTime> @ imm = #-0x1eec
700ace3c: 9000         	str	r0, [sp]
;           if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700ace3e: 9800         	ldr	r0, [sp]
700ace40: 2802         	cmp	r0, #0x2
700ace42: d301         	blo	0x700ace48 <prvIdleTask+0x48> @ imm = #0x2
700ace44: e7ff         	b	0x700ace46 <prvIdleTask+0x46> @ imm = #-0x2
;           } else {
700ace46: e000         	b	0x700ace4a <prvIdleTask+0x4a> @ imm = #0x0
700ace48: e7ff         	b	0x700ace4a <prvIdleTask+0x4a> @ imm = #-0x2
;         (void)xTaskResumeAll();
700ace4a: f7f5 f949    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0xad6e
;       } else {
700ace4e: e000         	b	0x700ace52 <prvIdleTask+0x52> @ imm = #0x0
700ace50: e7ff         	b	0x700ace52 <prvIdleTask+0x52> @ imm = #-0x2
;   for (;;) {
700ace52: e7d9         	b	0x700ace08 <prvIdleTask+0x8> @ imm = #-0x4e
		...

700ace60 <vQueueUnregisterQueue>:
;     {
700ace60: b082         	sub	sp, #0x8
700ace62: 9001         	str	r0, [sp, #0x4]
700ace64: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700ace66: 9000         	str	r0, [sp]
700ace68: e7ff         	b	0x700ace6a <vQueueUnregisterQueue+0xa> @ imm = #-0x2
700ace6a: 9800         	ldr	r0, [sp]
700ace6c: 281f         	cmp	r0, #0x1f
700ace6e: d81f         	bhi	0x700aceb0 <vQueueUnregisterQueue+0x50> @ imm = #0x3e
700ace70: e7ff         	b	0x700ace72 <vQueueUnregisterQueue+0x12> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].xHandle == xQueue )
700ace72: 9900         	ldr	r1, [sp]
700ace74: f644 3078    	movw	r0, #0x4b78
700ace78: f2c7 0008    	movt	r0, #0x7008
700ace7c: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ace80: 6840         	ldr	r0, [r0, #0x4]
700ace82: 9901         	ldr	r1, [sp, #0x4]
700ace84: 4288         	cmp	r0, r1
700ace86: d10d         	bne	0x700acea4 <vQueueUnregisterQueue+0x44> @ imm = #0x1a
700ace88: e7ff         	b	0x700ace8a <vQueueUnregisterQueue+0x2a> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = NULL;
700ace8a: 9a00         	ldr	r2, [sp]
700ace8c: f644 3178    	movw	r1, #0x4b78
700ace90: f2c7 0108    	movt	r1, #0x7008
700ace94: 2000         	movs	r0, #0x0
700ace96: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
700ace9a: 9a00         	ldr	r2, [sp]
700ace9c: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700acea0: 6048         	str	r0, [r1, #0x4]
;                 break;
700acea2: e005         	b	0x700aceb0 <vQueueUnregisterQueue+0x50> @ imm = #0xa
700acea4: e7ff         	b	0x700acea6 <vQueueUnregisterQueue+0x46> @ imm = #-0x2
;         }
700acea6: e7ff         	b	0x700acea8 <vQueueUnregisterQueue+0x48> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700acea8: 9800         	ldr	r0, [sp]
700aceaa: 3001         	adds	r0, #0x1
700aceac: 9000         	str	r0, [sp]
700aceae: e7dc         	b	0x700ace6a <vQueueUnregisterQueue+0xa> @ imm = #-0x48
;     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
700aceb0: b002         	add	sp, #0x8
700aceb2: 4770         	bx	lr
		...

700acec0 <Drivers_open>:
; {
700acec0: b5b0         	push	{r4, r5, r7, lr}
700acec2: b082         	sub	sp, #0x8
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700acec4: f642 0124    	movw	r1, #0x2824
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700acec8: f245 1438    	movw	r4, #0x5138
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700acecc: f2c7 010b    	movt	r1, #0x700b
700aced0: 2500         	movs	r5, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700aced2: f2c7 0408    	movt	r4, #0x7008
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700aced6: 2000         	movs	r0, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700aced8: 6025         	str	r5, [r4]
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700aceda: f7ee fd31    	bl	0x7009b940 <UART_open>  @ imm = #-0x1159e
700acede: 6020         	str	r0, [r4]
;         if(NULL == gUartHandle[instCnt])
700acee0: b108         	cbz	r0, 0x700acee6 <Drivers_open+0x26> @ imm = #0x2
; }
700acee2: b002         	add	sp, #0x8
700acee4: bdb0         	pop	{r4, r5, r7, pc}
;             DebugP_logError("UART open failed for instance %d !!!\r\n", instCnt);
700acee6: f641 2122    	movw	r1, #0x1a22
700aceea: f242 029f    	movw	r2, #0x209f
700aceee: f2c7 010b    	movt	r1, #0x700b
700acef2: f2c7 020b    	movt	r2, #0x700b
700acef6: 2002         	movs	r0, #0x2
700acef8: 236e         	movs	r3, #0x6e
700acefa: 9500         	str	r5, [sp]
700acefc: f7fc fe30    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #-0x33a0
;         if(gUartHandle[instCnt] != NULL)
700acf00: 6820         	ldr	r0, [r4]
700acf02: 2800         	cmp	r0, #0x0
700acf04: d0ed         	beq	0x700acee2 <Drivers_open+0x22> @ imm = #-0x26
;             UART_close(gUartHandle[instCnt]);
700acf06: f7f2 fdf3    	bl	0x7009faf0 <UART_close> @ imm = #-0xd41a
700acf0a: 2000         	movs	r0, #0x0
;             gUartHandle[instCnt] = NULL;
700acf0c: 6020         	str	r0, [r4]
; }
700acf0e: b002         	add	sp, #0x8
700acf10: bdb0         	pop	{r4, r5, r7, pc}
		...
700acf1e: 0000         	movs	r0, r0

700acf20 <Udma_chInitRegs>:
; {
700acf20: b081         	sub	sp, #0x4
700acf22: 9000         	str	r0, [sp]
;     chHandle->pBcdmaBcCfgRegs    = (volatile CSL_bcdma_bccfgRegs_chan *) NULL_PTR;
700acf24: 9900         	ldr	r1, [sp]
700acf26: 2000         	movs	r0, #0x0
700acf28: f8c1 0214    	str.w	r0, [r1, #0x214]
;     chHandle->pBcdmaBcRtRegs     = (volatile CSL_bcdma_bcrtRegs_chan *) NULL_PTR;
700acf2c: 9900         	ldr	r1, [sp]
700acf2e: f8c1 0218    	str.w	r0, [r1, #0x218]
;     chHandle->pBcdmaTxCfgRegs   = (volatile CSL_bcdma_txccfgRegs_chan *) NULL_PTR;
700acf32: 9900         	ldr	r1, [sp]
700acf34: f8c1 021c    	str.w	r0, [r1, #0x21c]
;     chHandle->pBcdmaTxRtRegs    = (volatile CSL_bcdma_txcrtRegs_chan *) NULL_PTR;
700acf38: 9900         	ldr	r1, [sp]
700acf3a: f8c1 0220    	str.w	r0, [r1, #0x220]
;     chHandle->pBcdmaRxCfgRegs   = (volatile CSL_bcdma_rxccfgRegs_chan *) NULL_PTR;
700acf3e: 9900         	ldr	r1, [sp]
700acf40: f8c1 0224    	str.w	r0, [r1, #0x224]
;     chHandle->pBcdmaRxRtRegs    = (volatile CSL_bcdma_rxcrtRegs_chan *) NULL_PTR;
700acf44: 9900         	ldr	r1, [sp]
700acf46: f8c1 0228    	str.w	r0, [r1, #0x228]
;     chHandle->pPktdmaTxCfgRegs  = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700acf4a: 9900         	ldr	r1, [sp]
700acf4c: f8c1 022c    	str.w	r0, [r1, #0x22c]
;     chHandle->pPktdmaTxRtRegs   = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700acf50: 9900         	ldr	r1, [sp]
700acf52: f8c1 0230    	str.w	r0, [r1, #0x230]
;     chHandle->pPktdmaRxCfgRegs  = (volatile CSL_pktdma_rxccfgRegs_chan *) NULL_PTR;
700acf56: 9900         	ldr	r1, [sp]
700acf58: f8c1 0234    	str.w	r0, [r1, #0x234]
;     chHandle->pPktdmaRxRtRegs   = (volatile CSL_pktdma_rxcrtRegs_chan *) NULL_PTR;
700acf5c: 9900         	ldr	r1, [sp]
700acf5e: f8c1 0238    	str.w	r0, [r1, #0x238]
;     chHandle->pPktdmaExtCfgRegs = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700acf62: 9900         	ldr	r1, [sp]
700acf64: f8c1 023c    	str.w	r0, [r1, #0x23c]
;     chHandle->pPktdmaExtRtRegs  = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700acf68: 9900         	ldr	r1, [sp]
700acf6a: f8c1 0240    	str.w	r0, [r1, #0x240]
; }
700acf6e: b001         	add	sp, #0x4
700acf70: 4770         	bx	lr
		...
700acf7e: 0000         	movs	r0, r0

700acf80 <vQueueAddToRegistry>:
;     {
700acf80: b083         	sub	sp, #0xc
700acf82: 9002         	str	r0, [sp, #0x8]
700acf84: 9101         	str	r1, [sp, #0x4]
700acf86: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700acf88: 9000         	str	r0, [sp]
700acf8a: e7ff         	b	0x700acf8c <vQueueAddToRegistry+0xc> @ imm = #-0x2
700acf8c: 9800         	ldr	r0, [sp]
700acf8e: 281f         	cmp	r0, #0x1f
700acf90: d81d         	bhi	0x700acfce <vQueueAddToRegistry+0x4e> @ imm = #0x3a
700acf92: e7ff         	b	0x700acf94 <vQueueAddToRegistry+0x14> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].pcQueueName == NULL )
700acf94: 9900         	ldr	r1, [sp]
700acf96: f644 3078    	movw	r0, #0x4b78
700acf9a: f2c7 0008    	movt	r0, #0x7008
700acf9e: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700acfa2: b970         	cbnz	r0, 0x700acfc2 <vQueueAddToRegistry+0x42> @ imm = #0x1c
700acfa4: e7ff         	b	0x700acfa6 <vQueueAddToRegistry+0x26> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = pcQueueName;
700acfa6: 9801         	ldr	r0, [sp, #0x4]
700acfa8: 9a00         	ldr	r2, [sp]
700acfaa: f644 3178    	movw	r1, #0x4b78
700acfae: f2c7 0108    	movt	r1, #0x7008
700acfb2: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = xQueue;
700acfb6: 9802         	ldr	r0, [sp, #0x8]
700acfb8: 9a00         	ldr	r2, [sp]
700acfba: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700acfbe: 6048         	str	r0, [r1, #0x4]
;                 break;
700acfc0: e005         	b	0x700acfce <vQueueAddToRegistry+0x4e> @ imm = #0xa
700acfc2: e7ff         	b	0x700acfc4 <vQueueAddToRegistry+0x44> @ imm = #-0x2
;         }
700acfc4: e7ff         	b	0x700acfc6 <vQueueAddToRegistry+0x46> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700acfc6: 9800         	ldr	r0, [sp]
700acfc8: 3001         	adds	r0, #0x1
700acfca: 9000         	str	r0, [sp]
700acfcc: e7de         	b	0x700acf8c <vQueueAddToRegistry+0xc> @ imm = #-0x44
;     }
700acfce: b003         	add	sp, #0xc
700acfd0: 4770         	bx	lr
		...
700acfde: 0000         	movs	r0, r0

700acfe0 <xQueueTakeMutexRecursive>:
;     {
700acfe0: b580         	push	{r7, lr}
700acfe2: b086         	sub	sp, #0x18
700acfe4: 9005         	str	r0, [sp, #0x14]
700acfe6: 9104         	str	r1, [sp, #0x10]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700acfe8: 9805         	ldr	r0, [sp, #0x14]
700acfea: 9002         	str	r0, [sp, #0x8]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700acfec: 9802         	ldr	r0, [sp, #0x8]
700acfee: 6880         	ldr	r0, [r0, #0x8]
700acff0: 9001         	str	r0, [sp, #0x4]
700acff2: f002 fcbd    	bl	0x700af970 <xTaskGetCurrentTaskHandle> @ imm = #0x297a
700acff6: 4601         	mov	r1, r0
700acff8: 9801         	ldr	r0, [sp, #0x4]
700acffa: 4288         	cmp	r0, r1
700acffc: d107         	bne	0x700ad00e <xQueueTakeMutexRecursive+0x2e> @ imm = #0xe
700acffe: e7ff         	b	0x700ad000 <xQueueTakeMutexRecursive+0x20> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700ad000: 9902         	ldr	r1, [sp, #0x8]
700ad002: 68c8         	ldr	r0, [r1, #0xc]
700ad004: 3001         	adds	r0, #0x1
700ad006: 60c8         	str	r0, [r1, #0xc]
700ad008: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700ad00a: 9003         	str	r0, [sp, #0xc]
;         }
700ad00c: e00e         	b	0x700ad02c <xQueueTakeMutexRecursive+0x4c> @ imm = #0x1c
;             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
700ad00e: 9802         	ldr	r0, [sp, #0x8]
700ad010: 9904         	ldr	r1, [sp, #0x10]
700ad012: f7f4 f8a5    	bl	0x700a1160 <xQueueSemaphoreTake> @ imm = #-0xbeb6
700ad016: 9003         	str	r0, [sp, #0xc]
;             if( xReturn != pdFAIL )
700ad018: 9803         	ldr	r0, [sp, #0xc]
700ad01a: b128         	cbz	r0, 0x700ad028 <xQueueTakeMutexRecursive+0x48> @ imm = #0xa
700ad01c: e7ff         	b	0x700ad01e <xQueueTakeMutexRecursive+0x3e> @ imm = #-0x2
;                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700ad01e: 9902         	ldr	r1, [sp, #0x8]
700ad020: 68c8         	ldr	r0, [r1, #0xc]
700ad022: 3001         	adds	r0, #0x1
700ad024: 60c8         	str	r0, [r1, #0xc]
;             }
700ad026: e000         	b	0x700ad02a <xQueueTakeMutexRecursive+0x4a> @ imm = #0x0
700ad028: e7ff         	b	0x700ad02a <xQueueTakeMutexRecursive+0x4a> @ imm = #-0x2
700ad02a: e7ff         	b	0x700ad02c <xQueueTakeMutexRecursive+0x4c> @ imm = #-0x2
;         return xReturn;
700ad02c: 9803         	ldr	r0, [sp, #0xc]
700ad02e: b006         	add	sp, #0x18
700ad030: bd80         	pop	{r7, pc}
		...
700ad03e: 0000         	movs	r0, r0

700ad040 <UART_checkCharsAvailInFifo>:
; {
700ad040: b580         	push	{r7, lr}
700ad042: b084         	sub	sp, #0x10
700ad044: 9003         	str	r0, [sp, #0xc]
700ad046: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ad048: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700ad04a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad04c: 9803         	ldr	r0, [sp, #0xc]
700ad04e: 300c         	adds	r0, #0xc
700ad050: f002 fd6e    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x2adc
700ad054: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ad056: 9803         	ldr	r0, [sp, #0xc]
700ad058: 300c         	adds	r0, #0xc
700ad05a: 9000         	str	r0, [sp]
700ad05c: f002 fd68    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x2ad0
700ad060: 4601         	mov	r1, r0
700ad062: 9800         	ldr	r0, [sp]
700ad064: f001 017f    	and	r1, r1, #0x7f
700ad068: f002 fd6a    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x2ad4
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ad06c: 9803         	ldr	r0, [sp, #0xc]
700ad06e: 3014         	adds	r0, #0x14
700ad070: f002 fd5e    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x2abc
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700ad074: 07c0         	lsls	r0, r0, #0x1f
700ad076: b118         	cbz	r0, 0x700ad080 <UART_checkCharsAvailInFifo+0x40> @ imm = #0x6
700ad078: e7ff         	b	0x700ad07a <UART_checkCharsAvailInFifo+0x3a> @ imm = #-0x2
700ad07a: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700ad07c: 9001         	str	r0, [sp, #0x4]
;     }
700ad07e: e7ff         	b	0x700ad080 <UART_checkCharsAvailInFifo+0x40> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad080: 9803         	ldr	r0, [sp, #0xc]
700ad082: 300c         	adds	r0, #0xc
700ad084: 9902         	ldr	r1, [sp, #0x8]
700ad086: f002 fd5b    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x2ab6
;     return retVal;
700ad08a: 9801         	ldr	r0, [sp, #0x4]
700ad08c: b004         	add	sp, #0x10
700ad08e: bd80         	pop	{r7, pc}

700ad090 <xQueueGiveMutexRecursive>:
;     {
700ad090: b580         	push	{r7, lr}
700ad092: b084         	sub	sp, #0x10
700ad094: 9003         	str	r0, [sp, #0xc]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700ad096: 9803         	ldr	r0, [sp, #0xc]
700ad098: 9001         	str	r0, [sp, #0x4]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700ad09a: 9801         	ldr	r0, [sp, #0x4]
700ad09c: 6880         	ldr	r0, [r0, #0x8]
700ad09e: 9000         	str	r0, [sp]
700ad0a0: f002 fc66    	bl	0x700af970 <xTaskGetCurrentTaskHandle> @ imm = #0x28cc
700ad0a4: 4601         	mov	r1, r0
700ad0a6: 9800         	ldr	r0, [sp]
700ad0a8: 4288         	cmp	r0, r1
700ad0aa: d113         	bne	0x700ad0d4 <xQueueGiveMutexRecursive+0x44> @ imm = #0x26
700ad0ac: e7ff         	b	0x700ad0ae <xQueueGiveMutexRecursive+0x1e> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
700ad0ae: 9901         	ldr	r1, [sp, #0x4]
700ad0b0: 68c8         	ldr	r0, [r1, #0xc]
700ad0b2: 3801         	subs	r0, #0x1
700ad0b4: 60c8         	str	r0, [r1, #0xc]
;             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
700ad0b6: 9801         	ldr	r0, [sp, #0x4]
700ad0b8: 68c0         	ldr	r0, [r0, #0xc]
700ad0ba: b938         	cbnz	r0, 0x700ad0cc <xQueueGiveMutexRecursive+0x3c> @ imm = #0xe
700ad0bc: e7ff         	b	0x700ad0be <xQueueGiveMutexRecursive+0x2e> @ imm = #-0x2
;                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
700ad0be: 9801         	ldr	r0, [sp, #0x4]
700ad0c0: 2300         	movs	r3, #0x0
700ad0c2: 4619         	mov	r1, r3
700ad0c4: 461a         	mov	r2, r3
700ad0c6: f7f6 f83b    	bl	0x700a3140 <xQueueGenericSend> @ imm = #-0x9f8a
;             }
700ad0ca: e000         	b	0x700ad0ce <xQueueGiveMutexRecursive+0x3e> @ imm = #0x0
700ad0cc: e7ff         	b	0x700ad0ce <xQueueGiveMutexRecursive+0x3e> @ imm = #-0x2
700ad0ce: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700ad0d0: 9002         	str	r0, [sp, #0x8]
;         }
700ad0d2: e002         	b	0x700ad0da <xQueueGiveMutexRecursive+0x4a> @ imm = #0x4
700ad0d4: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700ad0d6: 9002         	str	r0, [sp, #0x8]
700ad0d8: e7ff         	b	0x700ad0da <xQueueGiveMutexRecursive+0x4a> @ imm = #-0x2
;         return xReturn;
700ad0da: 9802         	ldr	r0, [sp, #0x8]
700ad0dc: b004         	add	sp, #0x10
700ad0de: bd80         	pop	{r7, pc}

700ad0e0 <CSL_pktdmaIsChanEnabled>:
; {
700ad0e0: b580         	push	{r7, lr}
700ad0e2: b084         	sub	sp, #0x10
700ad0e4: 9003         	str	r0, [sp, #0xc]
700ad0e6: 9102         	str	r1, [sp, #0x8]
700ad0e8: 9201         	str	r2, [sp, #0x4]
;     if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700ad0ea: 9801         	ldr	r0, [sp, #0x4]
700ad0ec: b960         	cbnz	r0, 0x700ad108 <CSL_pktdmaIsChanEnabled+0x28> @ imm = #0x18
700ad0ee: e7ff         	b	0x700ad0f0 <CSL_pktdmaIsChanEnabled+0x10> @ imm = #-0x2
;         regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_TXCRT_CHAN_CTL_EN );
700ad0f0: 9803         	ldr	r0, [sp, #0xc]
700ad0f2: 6900         	ldr	r0, [r0, #0x10]
700ad0f4: 9902         	ldr	r1, [sp, #0x8]
700ad0f6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad0fa: f04f 4100    	mov.w	r1, #0x80000000
700ad0fe: 221f         	movs	r2, #0x1f
700ad100: f001 ffb6    	bl	0x700af070 <CSL_REG32_FEXT_RAW> @ imm = #0x1f6c
700ad104: 9000         	str	r0, [sp]
;     }
700ad106: e00b         	b	0x700ad120 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #0x16
;         regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_RXCRT_CHAN_CTL_EN );
700ad108: 9803         	ldr	r0, [sp, #0xc]
700ad10a: 6940         	ldr	r0, [r0, #0x14]
700ad10c: 9902         	ldr	r1, [sp, #0x8]
700ad10e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad112: f04f 4100    	mov.w	r1, #0x80000000
700ad116: 221f         	movs	r2, #0x1f
700ad118: f001 ffaa    	bl	0x700af070 <CSL_REG32_FEXT_RAW> @ imm = #0x1f54
700ad11c: 9000         	str	r0, [sp]
700ad11e: e7ff         	b	0x700ad120 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700ad120: 9800         	ldr	r0, [sp]
700ad122: 3801         	subs	r0, #0x1
700ad124: fab0 f080    	clz	r0, r0
700ad128: 0940         	lsrs	r0, r0, #0x5
700ad12a: b004         	add	sp, #0x10
700ad12c: bd80         	pop	{r7, pc}
700ad12e: 0000         	movs	r0, r0

700ad130 <UART_getHandle>:
; {
700ad130: b083         	sub	sp, #0xc
700ad132: 9002         	str	r0, [sp, #0x8]
700ad134: 2000         	movs	r0, #0x0
;     UART_Handle         handle = NULL;
700ad136: 9001         	str	r0, [sp, #0x4]
;     if(index < gUartConfigNum)
700ad138: 9802         	ldr	r0, [sp, #0x8]
700ad13a: f642 11ec    	movw	r1, #0x29ec
700ad13e: f2c7 010b    	movt	r1, #0x700b
700ad142: 6809         	ldr	r1, [r1]
700ad144: 4288         	cmp	r0, r1
700ad146: d217         	bhs	0x700ad178 <UART_getHandle+0x48> @ imm = #0x2e
700ad148: e7ff         	b	0x700ad14a <UART_getHandle+0x1a> @ imm = #-0x2
;         object = gUartConfig[index].object;
700ad14a: 9902         	ldr	r1, [sp, #0x8]
700ad14c: f642 10a4    	movw	r0, #0x29a4
700ad150: f2c7 000b    	movt	r0, #0x700b
700ad154: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ad158: 6840         	ldr	r0, [r0, #0x4]
700ad15a: 9000         	str	r0, [sp]
;         if(object && (TRUE == object->isOpen))
700ad15c: 9800         	ldr	r0, [sp]
700ad15e: b150         	cbz	r0, 0x700ad176 <UART_getHandle+0x46> @ imm = #0x14
700ad160: e7ff         	b	0x700ad162 <UART_getHandle+0x32> @ imm = #-0x2
700ad162: 9800         	ldr	r0, [sp]
700ad164: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700ad168: 2801         	cmp	r0, #0x1
700ad16a: d104         	bne	0x700ad176 <UART_getHandle+0x46> @ imm = #0x8
700ad16c: e7ff         	b	0x700ad16e <UART_getHandle+0x3e> @ imm = #-0x2
;             handle = object->handle;
700ad16e: 9800         	ldr	r0, [sp]
700ad170: 6800         	ldr	r0, [r0]
700ad172: 9001         	str	r0, [sp, #0x4]
;         }
700ad174: e7ff         	b	0x700ad176 <UART_getHandle+0x46> @ imm = #-0x2
;     }
700ad176: e7ff         	b	0x700ad178 <UART_getHandle+0x48> @ imm = #-0x2
;     return handle;
700ad178: 9801         	ldr	r0, [sp, #0x4]
700ad17a: b003         	add	sp, #0xc
700ad17c: 4770         	bx	lr
700ad17e: 0000         	movs	r0, r0

700ad180 <prvTaskIsTaskSuspended>:
; static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask) {
700ad180: b083         	sub	sp, #0xc
700ad182: 9002         	str	r0, [sp, #0x8]
700ad184: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700ad186: 9001         	str	r0, [sp, #0x4]
;   const TCB_t *const pxTCB = xTask;
700ad188: 9802         	ldr	r0, [sp, #0x8]
700ad18a: 9000         	str	r0, [sp]
;   if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) !=
700ad18c: 9800         	ldr	r0, [sp]
700ad18e: 6940         	ldr	r0, [r0, #0x14]
700ad190: f245 01f4    	movw	r1, #0x50f4
700ad194: f2c7 0108    	movt	r1, #0x7008
700ad198: 4288         	cmp	r0, r1
700ad19a: d114         	bne	0x700ad1c6 <prvTaskIsTaskSuspended+0x46> @ imm = #0x28
700ad19c: e7ff         	b	0x700ad19e <prvTaskIsTaskSuspended+0x1e> @ imm = #-0x2
;     if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) ==
700ad19e: 9800         	ldr	r0, [sp]
700ad1a0: 6a80         	ldr	r0, [r0, #0x28]
700ad1a2: f245 01e0    	movw	r1, #0x50e0
700ad1a6: f2c7 0108    	movt	r1, #0x7008
700ad1aa: 4288         	cmp	r0, r1
700ad1ac: d009         	beq	0x700ad1c2 <prvTaskIsTaskSuspended+0x42> @ imm = #0x12
700ad1ae: e7ff         	b	0x700ad1b0 <prvTaskIsTaskSuspended+0x30> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(NULL, &(pxTCB->xEventListItem)) !=
700ad1b0: 9800         	ldr	r0, [sp]
700ad1b2: 6a80         	ldr	r0, [r0, #0x28]
700ad1b4: b918         	cbnz	r0, 0x700ad1be <prvTaskIsTaskSuspended+0x3e> @ imm = #0x6
700ad1b6: e7ff         	b	0x700ad1b8 <prvTaskIsTaskSuspended+0x38> @ imm = #-0x2
700ad1b8: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700ad1ba: 9001         	str	r0, [sp, #0x4]
;       } else {
700ad1bc: e000         	b	0x700ad1c0 <prvTaskIsTaskSuspended+0x40> @ imm = #0x0
700ad1be: e7ff         	b	0x700ad1c0 <prvTaskIsTaskSuspended+0x40> @ imm = #-0x2
;     } else {
700ad1c0: e000         	b	0x700ad1c4 <prvTaskIsTaskSuspended+0x44> @ imm = #0x0
700ad1c2: e7ff         	b	0x700ad1c4 <prvTaskIsTaskSuspended+0x44> @ imm = #-0x2
;   } else {
700ad1c4: e000         	b	0x700ad1c8 <prvTaskIsTaskSuspended+0x48> @ imm = #0x0
700ad1c6: e7ff         	b	0x700ad1c8 <prvTaskIsTaskSuspended+0x48> @ imm = #-0x2
;   return xReturn;
700ad1c8: 9801         	ldr	r0, [sp, #0x4]
700ad1ca: b003         	add	sp, #0xc
700ad1cc: 4770         	bx	lr
700ad1ce: 0000         	movs	r0, r0

700ad1d0 <tm_mutex_create>:
; {
700ad1d0: b510         	push	{r4, lr}
700ad1d2: 4604         	mov	r4, r0
;    if (mutex_id < 0 || mutex_id >= TM_FREERTOS_MAX_SEMAPHORES)
700ad1d4: 2802         	cmp	r0, #0x2
700ad1d6: d30b         	blo	0x700ad1f0 <tm_mutex_create+0x20> @ imm = #0x16
;       printf("Invalid mutex ID: %d. Max allowed: %d\r\n", mutex_id, TM_FREERTOS_MAX_SEMAPHORES - 1);
700ad1d8: f641 3142    	movw	r1, #0x1b42
700ad1dc: 4622         	mov	r2, r4
700ad1de: f2c7 010b    	movt	r1, #0x700b
700ad1e2: 2001         	movs	r0, #0x1
700ad1e4: 2301         	movs	r3, #0x1
700ad1e6: 2401         	movs	r4, #0x1
700ad1e8: f7fc fcba    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #-0x368c
; }
700ad1ec: 4620         	mov	r0, r4
700ad1ee: bd10         	pop	{r4, pc}
;    tm_mutex_array[mutex_id] = xSemaphoreCreateMutex();
700ad1f0: 2001         	movs	r0, #0x1
700ad1f2: f001 fef5    	bl	0x700aefe0 <xQueueCreateMutex> @ imm = #0x1dea
700ad1f6: f245 111c    	movw	r1, #0x511c
700ad1fa: f2c7 0108    	movt	r1, #0x7008
700ad1fe: f841 0024    	str.w	r0, [r1, r4, lsl #2]
;    if (tm_mutex_array[mutex_id] == NULL)
700ad202: b108         	cbz	r0, 0x700ad208 <tm_mutex_create+0x38> @ imm = #0x2
700ad204: 2000         	movs	r0, #0x0
; }
700ad206: bd10         	pop	{r4, pc}
;       printf("Failed to create mutex for ID %d\r\n", mutex_id);
700ad208: f641 31ff    	movw	r1, #0x1bff
700ad20c: 4622         	mov	r2, r4
700ad20e: f2c7 010b    	movt	r1, #0x700b
700ad212: 2001         	movs	r0, #0x1
700ad214: 2401         	movs	r4, #0x1
700ad216: f7fc fca3    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #-0x36ba
; }
700ad21a: 4620         	mov	r0, r4
700ad21c: bd10         	pop	{r4, pc}
700ad21e: 0000         	movs	r0, r0

700ad220 <Sciclient_rmPsSetInp>:
; {
700ad220: b082         	sub	sp, #0x8
700ad222: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad226: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ad22a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ad22c: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ad22e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad232: f241 0158    	movw	r1, #0x1058
700ad236: f2c7 0108    	movt	r1, #0x7008
700ad23a: 8c89         	ldrh	r1, [r1, #0x24]
700ad23c: 4288         	cmp	r0, r1
700ad23e: da0e         	bge	0x700ad25e <Sciclient_rmPsSetInp+0x3e> @ imm = #0x1c
700ad240: e7ff         	b	0x700ad242 <Sciclient_rmPsSetInp+0x22> @ imm = #-0x2
;         gPstack.ps[index].inp = inp;
700ad242: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ad246: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ad24a: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ad24e: f241 0158    	movw	r1, #0x1058
700ad252: f2c7 0108    	movt	r1, #0x7008
700ad256: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ad25a: 80c8         	strh	r0, [r1, #0x6]
;     } else {
700ad25c: e003         	b	0x700ad266 <Sciclient_rmPsSetInp+0x46> @ imm = #0x6
700ad25e: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ad262: 9000         	str	r0, [sp]
700ad264: e7ff         	b	0x700ad266 <Sciclient_rmPsSetInp+0x46> @ imm = #-0x2
;     return r;
700ad266: 9800         	ldr	r0, [sp]
700ad268: b002         	add	sp, #0x8
700ad26a: 4770         	bx	lr
700ad26c: 0000         	movs	r0, r0
700ad26e: 0000         	movs	r0, r0

700ad270 <Sciclient_rmPsSetOutp>:
; {
700ad270: b082         	sub	sp, #0x8
700ad272: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad276: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ad27a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ad27c: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ad27e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad282: f241 0158    	movw	r1, #0x1058
700ad286: f2c7 0108    	movt	r1, #0x7008
700ad28a: 8c89         	ldrh	r1, [r1, #0x24]
700ad28c: 4288         	cmp	r0, r1
700ad28e: da0e         	bge	0x700ad2ae <Sciclient_rmPsSetOutp+0x3e> @ imm = #0x1c
700ad290: e7ff         	b	0x700ad292 <Sciclient_rmPsSetOutp+0x22> @ imm = #-0x2
;         gPstack.ps[index].outp = outp;
700ad292: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ad296: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ad29a: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ad29e: f241 0158    	movw	r1, #0x1058
700ad2a2: f2c7 0108    	movt	r1, #0x7008
700ad2a6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ad2aa: 8108         	strh	r0, [r1, #0x8]
;     } else {
700ad2ac: e003         	b	0x700ad2b6 <Sciclient_rmPsSetOutp+0x46> @ imm = #0x6
700ad2ae: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ad2b2: 9000         	str	r0, [sp]
700ad2b4: e7ff         	b	0x700ad2b6 <Sciclient_rmPsSetOutp+0x46> @ imm = #-0x2
;     return r;
700ad2b6: 9800         	ldr	r0, [sp]
700ad2b8: b002         	add	sp, #0x8
700ad2ba: 4770         	bx	lr
700ad2bc: 0000         	movs	r0, r0
700ad2be: 0000         	movs	r0, r0

700ad2c0 <Udma_eventGetId>:
; {
700ad2c0: b084         	sub	sp, #0x10
700ad2c2: 9003         	str	r0, [sp, #0xc]
700ad2c4: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            evtNum = UDMA_EVENT_INVALID;
700ad2c8: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandleInt eventHandleInt = (Udma_EventHandleInt) eventHandle;
700ad2ca: 9803         	ldr	r0, [sp, #0xc]
700ad2cc: 9000         	str	r0, [sp]
;     if((NULL_PTR != eventHandleInt) &&
700ad2ce: 9800         	ldr	r0, [sp]
700ad2d0: b1c8         	cbz	r0, 0x700ad306 <Udma_eventGetId+0x46> @ imm = #0x32
700ad2d2: e7ff         	b	0x700ad2d4 <Udma_eventGetId+0x14> @ imm = #-0x2
;        (UDMA_INIT_DONE == eventHandleInt->eventInitDone))
700ad2d4: 9800         	ldr	r0, [sp]
700ad2d6: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700ad2da: f64a 31cd    	movw	r1, #0xabcd
700ad2de: f6ca 31dc    	movt	r1, #0xabdc
;     if((NULL_PTR != eventHandleInt) &&
700ad2e2: 4288         	cmp	r0, r1
700ad2e4: d10f         	bne	0x700ad306 <Udma_eventGetId+0x46> @ imm = #0x1e
700ad2e6: e7ff         	b	0x700ad2e8 <Udma_eventGetId+0x28> @ imm = #-0x2
;         drvHandle = eventHandleInt->drvHandle;
700ad2e8: 9800         	ldr	r0, [sp]
700ad2ea: 6800         	ldr	r0, [r0]
700ad2ec: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != drvHandle)
700ad2ee: 9801         	ldr	r0, [sp, #0x4]
700ad2f0: b140         	cbz	r0, 0x700ad304 <Udma_eventGetId+0x44> @ imm = #0x10
700ad2f2: e7ff         	b	0x700ad2f4 <Udma_eventGetId+0x34> @ imm = #-0x2
;             evtNum = drvHandle->iaGemOffset + eventHandleInt->globalEvent;
700ad2f4: 9801         	ldr	r0, [sp, #0x4]
700ad2f6: f8d0 0118    	ldr.w	r0, [r0, #0x118]
700ad2fa: 9900         	ldr	r1, [sp]
700ad2fc: 6c89         	ldr	r1, [r1, #0x48]
700ad2fe: 4408         	add	r0, r1
700ad300: 9002         	str	r0, [sp, #0x8]
;         }
700ad302: e7ff         	b	0x700ad304 <Udma_eventGetId+0x44> @ imm = #-0x2
;     }
700ad304: e7ff         	b	0x700ad306 <Udma_eventGetId+0x46> @ imm = #-0x2
;     return (evtNum);
700ad306: 9802         	ldr	r0, [sp, #0x8]
700ad308: b004         	add	sp, #0x10
700ad30a: 4770         	bx	lr
700ad30c: 0000         	movs	r0, r0
700ad30e: 0000         	movs	r0, r0

700ad310 <CSL_pktdmaGetRxRT>:
; {
700ad310: b580         	push	{r7, lr}
700ad312: b084         	sub	sp, #0x10
700ad314: 9003         	str	r0, [sp, #0xc]
700ad316: 9102         	str	r1, [sp, #0x8]
700ad318: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700ad31a: 9803         	ldr	r0, [sp, #0xc]
700ad31c: 6940         	ldr	r0, [r0, #0x14]
700ad31e: 9902         	ldr	r1, [sp, #0x8]
700ad320: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad324: f002 fc5c    	bl	0x700afbe0 <CSL_REG32_RD_RAW> @ imm = #0x28b8
700ad328: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_EN );
700ad32a: 9800         	ldr	r0, [sp]
700ad32c: 0fc0         	lsrs	r0, r0, #0x1f
700ad32e: 9901         	ldr	r1, [sp, #0x4]
700ad330: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_TDOWN );
700ad332: 9800         	ldr	r0, [sp]
700ad334: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ad338: 9901         	ldr	r1, [sp, #0x4]
700ad33a: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ad33c: 9901         	ldr	r1, [sp, #0x4]
700ad33e: 2000         	movs	r0, #0x0
700ad340: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_PAUSE );
700ad342: 9900         	ldr	r1, [sp]
700ad344: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ad348: 9a01         	ldr	r2, [sp, #0x4]
700ad34a: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_ERROR );
700ad34c: 9900         	ldr	r1, [sp]
700ad34e: f001 0101    	and	r1, r1, #0x1
700ad352: 9a01         	ldr	r2, [sp, #0x4]
700ad354: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ad356: b004         	add	sp, #0x10
700ad358: bd80         	pop	{r7, pc}
700ad35a: 0000         	movs	r0, r0
700ad35c: 0000         	movs	r0, r0
700ad35e: 0000         	movs	r0, r0

700ad360 <CSL_pktdmaGetTxRT>:
; {
700ad360: b580         	push	{r7, lr}
700ad362: b084         	sub	sp, #0x10
700ad364: 9003         	str	r0, [sp, #0xc]
700ad366: 9102         	str	r1, [sp, #0x8]
700ad368: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700ad36a: 9803         	ldr	r0, [sp, #0xc]
700ad36c: 6900         	ldr	r0, [r0, #0x10]
700ad36e: 9902         	ldr	r1, [sp, #0x8]
700ad370: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad374: f002 fc34    	bl	0x700afbe0 <CSL_REG32_RD_RAW> @ imm = #0x2868
700ad378: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_EN );
700ad37a: 9800         	ldr	r0, [sp]
700ad37c: 0fc0         	lsrs	r0, r0, #0x1f
700ad37e: 9901         	ldr	r1, [sp, #0x4]
700ad380: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_TDOWN );
700ad382: 9800         	ldr	r0, [sp]
700ad384: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ad388: 9901         	ldr	r1, [sp, #0x4]
700ad38a: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ad38c: 9901         	ldr	r1, [sp, #0x4]
700ad38e: 2000         	movs	r0, #0x0
700ad390: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_PAUSE );
700ad392: 9900         	ldr	r1, [sp]
700ad394: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ad398: 9a01         	ldr	r2, [sp, #0x4]
700ad39a: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_ERROR );
700ad39c: 9900         	ldr	r1, [sp]
700ad39e: f001 0101    	and	r1, r1, #0x1
700ad3a2: 9a01         	ldr	r2, [sp, #0x4]
700ad3a4: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ad3a6: b004         	add	sp, #0x10
700ad3a8: bd80         	pop	{r7, pc}
700ad3aa: 0000         	movs	r0, r0
700ad3ac: 0000         	movs	r0, r0
700ad3ae: 0000         	movs	r0, r0

700ad3b0 <Sciclient_getDevId>:
; {
700ad3b0: b083         	sub	sp, #0xc
700ad3b2: 9002         	str	r0, [sp, #0x8]
700ad3b4: f04f 30ff    	mov.w	r0, #0xffffffff
;     uint32_t retVal = UINT32_MAX;
700ad3b8: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700ad3ba: 9802         	ldr	r0, [sp, #0x8]
700ad3bc: 9000         	str	r0, [sp]
700ad3be: 2805         	cmp	r0, #0x5
700ad3c0: d817         	bhi	0x700ad3f2 <Sciclient_getDevId+0x42> @ imm = #0x2e
700ad3c2: 9900         	ldr	r1, [sp]
700ad3c4: e8df f001    	tbb	[pc, r1]
700ad3c8: 03 06 09 0c  	.word	0x0c090603
700ad3cc: 0f 12        	.short	0x120f
700ad3ce: 2009         	movs	r0, #0x9
;         retVal = TISCI_DEV_MCU_M4FSS0_CORE0;
700ad3d0: 9001         	str	r0, [sp, #0x4]
;         break;
700ad3d2: e00f         	b	0x700ad3f4 <Sciclient_getDevId+0x44> @ imm = #0x1e
700ad3d4: 2079         	movs	r0, #0x79
;         retVal = TISCI_DEV_R5FSS0_CORE0;
700ad3d6: 9001         	str	r0, [sp, #0x4]
;         break;
700ad3d8: e00c         	b	0x700ad3f4 <Sciclient_getDevId+0x44> @ imm = #0x18
700ad3da: 207a         	movs	r0, #0x7a
;         retVal = TISCI_DEV_R5FSS0_CORE1;
700ad3dc: 9001         	str	r0, [sp, #0x4]
;         break;
700ad3de: e009         	b	0x700ad3f4 <Sciclient_getDevId+0x44> @ imm = #0x12
700ad3e0: 207b         	movs	r0, #0x7b
;         retVal = TISCI_DEV_R5FSS1_CORE0;
700ad3e2: 9001         	str	r0, [sp, #0x4]
;         break;
700ad3e4: e006         	b	0x700ad3f4 <Sciclient_getDevId+0x44> @ imm = #0xc
700ad3e6: 207c         	movs	r0, #0x7c
;         retVal = TISCI_DEV_R5FSS1_CORE1;
700ad3e8: 9001         	str	r0, [sp, #0x4]
;         break;
700ad3ea: e003         	b	0x700ad3f4 <Sciclient_getDevId+0x44> @ imm = #0x6
700ad3ec: 2087         	movs	r0, #0x87
;         retVal = TISCI_DEV_A53SS0_CORE_0;
700ad3ee: 9001         	str	r0, [sp, #0x4]
;         break;
700ad3f0: e000         	b	0x700ad3f4 <Sciclient_getDevId+0x44> @ imm = #0x0
;         break;
700ad3f2: e7ff         	b	0x700ad3f4 <Sciclient_getDevId+0x44> @ imm = #-0x2
;     return retVal;
700ad3f4: 9801         	ldr	r0, [sp, #0x4]
700ad3f6: b003         	add	sp, #0xc
700ad3f8: 4770         	bx	lr
700ad3fa: 0000         	movs	r0, r0
700ad3fc: 0000         	movs	r0, r0
700ad3fe: 0000         	movs	r0, r0

700ad400 <UART_getIntrIdentityStatus>:
; {
700ad400: b580         	push	{r7, lr}
700ad402: b084         	sub	sp, #0x10
700ad404: 9003         	str	r0, [sp, #0xc]
700ad406: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ad408: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ad40a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad40c: 9803         	ldr	r0, [sp, #0xc]
700ad40e: 300c         	adds	r0, #0xc
700ad410: f002 fb8e    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x271c
700ad414: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ad416: 9803         	ldr	r0, [sp, #0xc]
700ad418: 300c         	adds	r0, #0xc
700ad41a: 9000         	str	r0, [sp]
700ad41c: f002 fb88    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x2710
700ad420: 4601         	mov	r1, r0
700ad422: 9800         	ldr	r0, [sp]
700ad424: f001 017f    	and	r1, r1, #0x7f
700ad428: f002 fb8a    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x2714
;     retVal = HW_RD_REG32(baseAddr + UART_IIR) & UART_IIR_IT_TYPE_MASK;
700ad42c: 9803         	ldr	r0, [sp, #0xc]
700ad42e: 3008         	adds	r0, #0x8
700ad430: f002 fb7e    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x26fc
700ad434: f000 003e    	and	r0, r0, #0x3e
700ad438: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad43a: 9803         	ldr	r0, [sp, #0xc]
700ad43c: 300c         	adds	r0, #0xc
700ad43e: 9902         	ldr	r1, [sp, #0x8]
700ad440: f002 fb7e    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x26fc
;     return retVal;
700ad444: 9801         	ldr	r0, [sp, #0x4]
700ad446: b004         	add	sp, #0x10
700ad448: bd80         	pop	{r7, pc}
700ad44a: 0000         	movs	r0, r0
700ad44c: 0000         	movs	r0, r0
700ad44e: 0000         	movs	r0, r0

700ad450 <UART_lineCharConfig>:
; {
700ad450: b580         	push	{r7, lr}
700ad452: b084         	sub	sp, #0x10
700ad454: 9003         	str	r0, [sp, #0xc]
700ad456: 9102         	str	r1, [sp, #0x8]
700ad458: 9201         	str	r2, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad45a: 9803         	ldr	r0, [sp, #0xc]
700ad45c: 300c         	adds	r0, #0xc
700ad45e: f002 fb67    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x26ce
700ad462: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_NB_STOP_MASK | (uint32_t) UART_LCR_CHAR_LENGTH_MASK);
700ad464: 9800         	ldr	r0, [sp]
700ad466: f020 0007    	bic	r0, r0, #0x7
700ad46a: 9000         	str	r0, [sp]
;     lcrRegValue |= wLenStbFlag & (UART_LCR_NB_STOP_MASK |
700ad46c: 9802         	ldr	r0, [sp, #0x8]
700ad46e: f000 0107    	and	r1, r0, #0x7
700ad472: 9800         	ldr	r0, [sp]
700ad474: 4308         	orrs	r0, r1
700ad476: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_PARITY_TYPE2_MASK |
700ad478: 9800         	ldr	r0, [sp]
700ad47a: f020 0038    	bic	r0, r0, #0x38
700ad47e: 9000         	str	r0, [sp]
;     lcrRegValue |= parityFlag & (UART_LCR_PARITY_TYPE2_MASK |
700ad480: 9801         	ldr	r0, [sp, #0x4]
700ad482: f000 0138    	and	r1, r0, #0x38
700ad486: 9800         	ldr	r0, [sp]
700ad488: 4308         	orrs	r0, r1
700ad48a: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad48c: 9803         	ldr	r0, [sp, #0xc]
700ad48e: 300c         	adds	r0, #0xc
700ad490: 9900         	ldr	r1, [sp]
700ad492: f002 fb55    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x26aa
; }
700ad496: b004         	add	sp, #0x10
700ad498: bd80         	pop	{r7, pc}
700ad49a: 0000         	movs	r0, r0
700ad49c: 0000         	movs	r0, r0
700ad49e: 0000         	movs	r0, r0

700ad4a0 <UART_lld_dmaInit>:
; {
700ad4a0: b580         	push	{r7, lr}
700ad4a2: b084         	sub	sp, #0x10
700ad4a4: 9003         	str	r0, [sp, #0xc]
700ad4a6: 9102         	str	r1, [sp, #0x8]
700ad4a8: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ad4aa: 9001         	str	r0, [sp, #0x4]
;     UART_UdmaChConfig *udmaChCfg = (UART_UdmaChConfig *)dmaChCfg;
700ad4ac: 9802         	ldr	r0, [sp, #0x8]
700ad4ae: 9000         	str	r0, [sp]
;     status  = UART_udmaInitRxCh(hUart, udmaChCfg);
700ad4b0: 9803         	ldr	r0, [sp, #0xc]
700ad4b2: 9900         	ldr	r1, [sp]
700ad4b4: f7f6 fe94    	bl	0x700a41e0 <UART_udmaInitRxCh> @ imm = #-0x92d8
700ad4b8: 9001         	str	r0, [sp, #0x4]
;     status += UART_udmaInitTxCh(hUart, udmaChCfg);
700ad4ba: 9803         	ldr	r0, [sp, #0xc]
700ad4bc: 9900         	ldr	r1, [sp]
700ad4be: f7f6 ff1f    	bl	0x700a4300 <UART_udmaInitTxCh> @ imm = #-0x91c2
700ad4c2: 4601         	mov	r1, r0
700ad4c4: 9801         	ldr	r0, [sp, #0x4]
700ad4c6: 4408         	add	r0, r1
700ad4c8: 9001         	str	r0, [sp, #0x4]
;     if (status == UDMA_SOK)
700ad4ca: 9801         	ldr	r0, [sp, #0x4]
700ad4cc: b930         	cbnz	r0, 0x700ad4dc <UART_lld_dmaInit+0x3c> @ imm = #0xc
700ad4ce: e7ff         	b	0x700ad4d0 <UART_lld_dmaInit+0x30> @ imm = #-0x2
;         udmaChCfg->isOpen = TRUE;
700ad4d0: 9900         	ldr	r1, [sp]
700ad4d2: 2001         	movs	r0, #0x1
700ad4d4: 6388         	str	r0, [r1, #0x38]
700ad4d6: 2000         	movs	r0, #0x0
;         status = UART_TRANSFER_STATUS_SUCCESS;
700ad4d8: 9001         	str	r0, [sp, #0x4]
;     }
700ad4da: e003         	b	0x700ad4e4 <UART_lld_dmaInit+0x44> @ imm = #0x6
700ad4dc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ad4e0: 9001         	str	r0, [sp, #0x4]
700ad4e2: e7ff         	b	0x700ad4e4 <UART_lld_dmaInit+0x44> @ imm = #-0x2
;     return status;
700ad4e4: 9801         	ldr	r0, [sp, #0x4]
700ad4e6: b004         	add	sp, #0x10
700ad4e8: bd80         	pop	{r7, pc}
700ad4ea: 0000         	movs	r0, r0
700ad4ec: 0000         	movs	r0, r0
700ad4ee: 0000         	movs	r0, r0

700ad4f0 <xQueueGenericCreateStatic>:
;     {
700ad4f0: b580         	push	{r7, lr}
700ad4f2: b088         	sub	sp, #0x20
700ad4f4: 4684         	mov	r12, r0
700ad4f6: 980a         	ldr	r0, [sp, #0x28]
700ad4f8: f8cd c01c    	str.w	r12, [sp, #0x1c]
700ad4fc: 9106         	str	r1, [sp, #0x18]
700ad4fe: 9205         	str	r2, [sp, #0x14]
700ad500: 9304         	str	r3, [sp, #0x10]
700ad502: f88d 000f    	strb.w	r0, [sp, #0xf]
;         pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
700ad506: 9804         	ldr	r0, [sp, #0x10]
700ad508: 9002         	str	r0, [sp, #0x8]
;         if( pxNewQueue != NULL )
700ad50a: 9802         	ldr	r0, [sp, #0x8]
700ad50c: b188         	cbz	r0, 0x700ad532 <xQueueGenericCreateStatic+0x42> @ imm = #0x22
700ad50e: e7ff         	b	0x700ad510 <xQueueGenericCreateStatic+0x20> @ imm = #-0x2
;                     pxNewQueue->ucStaticallyAllocated = pdTRUE;
700ad510: 9902         	ldr	r1, [sp, #0x8]
700ad512: 2001         	movs	r0, #0x1
700ad514: f881 0046    	strb.w	r0, [r1, #0x46]
;             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
700ad518: 9807         	ldr	r0, [sp, #0x1c]
700ad51a: 9906         	ldr	r1, [sp, #0x18]
700ad51c: 9a05         	ldr	r2, [sp, #0x14]
700ad51e: f89d 300f    	ldrb.w	r3, [sp, #0xf]
700ad522: f8dd c008    	ldr.w	r12, [sp, #0x8]
700ad526: 46ee         	mov	lr, sp
700ad528: f8ce c000    	str.w	r12, [lr]
700ad52c: f000 f850    	bl	0x700ad5d0 <prvInitialiseNewQueue> @ imm = #0xa0
;         }
700ad530: e000         	b	0x700ad534 <xQueueGenericCreateStatic+0x44> @ imm = #0x0
700ad532: e7ff         	b	0x700ad534 <xQueueGenericCreateStatic+0x44> @ imm = #-0x2
;         return pxNewQueue;
700ad534: 9802         	ldr	r0, [sp, #0x8]
700ad536: b008         	add	sp, #0x20
700ad538: bd80         	pop	{r7, pc}
700ad53a: 0000         	movs	r0, r0
700ad53c: 0000         	movs	r0, r0
700ad53e: 0000         	movs	r0, r0

700ad540 <UART_resetModule>:
; {
700ad540: b580         	push	{r7, lr}
700ad542: b082         	sub	sp, #0x8
700ad544: 9001         	str	r0, [sp, #0x4]
;     (void)UART_enhanFuncEnable(hUart->baseAddr);
700ad546: 9801         	ldr	r0, [sp, #0x4]
700ad548: 6800         	ldr	r0, [r0]
700ad54a: f000 fd41    	bl	0x700adfd0 <UART_enhanFuncEnable> @ imm = #0xa82
;     UART_regConfModeRestore(hUart->baseAddr, 0x00U);
700ad54e: 9801         	ldr	r0, [sp, #0x4]
700ad550: 6800         	ldr	r0, [r0]
700ad552: 2100         	movs	r1, #0x0
700ad554: f002 f9ac    	bl	0x700af8b0 <UART_regConfModeRestore> @ imm = #0x2358
;     UART_modemControlReset(hUart->baseAddr);
700ad558: 9801         	ldr	r0, [sp, #0x4]
700ad55a: 6800         	ldr	r0, [r0]
700ad55c: f002 f8c0    	bl	0x700af6e0 <UART_modemControlReset> @ imm = #0x2180
;     UART_intrDisable(hUart->baseAddr, 0xFFU);
700ad560: 9801         	ldr	r0, [sp, #0x4]
700ad562: 6800         	ldr	r0, [r0]
700ad564: 21ff         	movs	r1, #0xff
700ad566: f7f8 fe1b    	bl	0x700a61a0 <UART_intrDisable> @ imm = #-0x73ca
;     UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700ad56a: 9801         	ldr	r0, [sp, #0x4]
700ad56c: 6800         	ldr	r0, [r0]
700ad56e: 2102         	movs	r1, #0x2
700ad570: f001 fbb6    	bl	0x700aece0 <UART_intr2Disable> @ imm = #0x176c
;     (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700ad574: 9801         	ldr	r0, [sp, #0x4]
700ad576: 6800         	ldr	r0, [r0]
700ad578: 2107         	movs	r1, #0x7
700ad57a: f001 fbf9    	bl	0x700aed70 <UART_operatingModeSelect> @ imm = #0x17f2
;     UART_moduleReset(hUart);
700ad57e: 9801         	ldr	r0, [sp, #0x4]
700ad580: f7fd f926    	bl	0x700aa7d0 <UART_moduleReset> @ imm = #-0x2db4
;     return;
700ad584: b002         	add	sp, #0x8
700ad586: bd80         	pop	{r7, pc}

700ad588 <memccpy>:
700ad588: e92d4800     	push	{r11, lr}
700ad58c: e1a0c000     	mov	r12, r0
700ad590: e3a00000     	mov	r0, #0
700ad594: e3530000     	cmp	r3, #0
700ad598: 0a000009     	beq	0x700ad5c4 <memccpy+0x3c> @ imm = #0x24
700ad59c: e28cc001     	add	r12, r12, #1
700ad5a0: e6efe072     	uxtb	lr, r2
700ad5a4: e5d12000     	ldrb	r2, [r1]
700ad5a8: e152000e     	cmp	r2, lr
700ad5ac: e54c2001     	strb	r2, [r12, #-0x1]
700ad5b0: 0a000004     	beq	0x700ad5c8 <memccpy+0x40> @ imm = #0x10
700ad5b4: e2811001     	add	r1, r1, #1
700ad5b8: e2533001     	subs	r3, r3, #1
700ad5bc: e28cc001     	add	r12, r12, #1
700ad5c0: 1afffff7     	bne	0x700ad5a4 <memccpy+0x1c> @ imm = #-0x24
700ad5c4: e8bd8800     	pop	{r11, pc}
700ad5c8: e1a0000c     	mov	r0, r12
700ad5cc: e8bd8800     	pop	{r11, pc}

700ad5d0 <prvInitialiseNewQueue>:
; {
700ad5d0: b580         	push	{r7, lr}
700ad5d2: b084         	sub	sp, #0x10
700ad5d4: f8dd c018    	ldr.w	r12, [sp, #0x18]
700ad5d8: 9003         	str	r0, [sp, #0xc]
700ad5da: 9102         	str	r1, [sp, #0x8]
700ad5dc: 9201         	str	r2, [sp, #0x4]
700ad5de: f88d 3003    	strb.w	r3, [sp, #0x3]
;     if( uxItemSize == ( UBaseType_t ) 0 )
700ad5e2: 9802         	ldr	r0, [sp, #0x8]
700ad5e4: b918         	cbnz	r0, 0x700ad5ee <prvInitialiseNewQueue+0x1e> @ imm = #0x6
700ad5e6: e7ff         	b	0x700ad5e8 <prvInitialiseNewQueue+0x18> @ imm = #-0x2
;         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
700ad5e8: 9806         	ldr	r0, [sp, #0x18]
700ad5ea: 6000         	str	r0, [r0]
;     }
700ad5ec: e003         	b	0x700ad5f6 <prvInitialiseNewQueue+0x26> @ imm = #0x6
;         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
700ad5ee: 9801         	ldr	r0, [sp, #0x4]
700ad5f0: 9906         	ldr	r1, [sp, #0x18]
700ad5f2: 6008         	str	r0, [r1]
700ad5f4: e7ff         	b	0x700ad5f6 <prvInitialiseNewQueue+0x26> @ imm = #-0x2
;     pxNewQueue->uxLength = uxQueueLength;
700ad5f6: 9803         	ldr	r0, [sp, #0xc]
700ad5f8: 9906         	ldr	r1, [sp, #0x18]
700ad5fa: 63c8         	str	r0, [r1, #0x3c]
;     pxNewQueue->uxItemSize = uxItemSize;
700ad5fc: 9802         	ldr	r0, [sp, #0x8]
700ad5fe: 9906         	ldr	r1, [sp, #0x18]
700ad600: 6408         	str	r0, [r1, #0x40]
;     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
700ad602: 9806         	ldr	r0, [sp, #0x18]
700ad604: 2101         	movs	r1, #0x1
700ad606: f7fc fd3b    	bl	0x700aa080 <xQueueGenericReset> @ imm = #-0x358a
;             pxNewQueue->ucQueueType = ucQueueType;
700ad60a: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ad60e: 9906         	ldr	r1, [sp, #0x18]
700ad610: f881 004c    	strb.w	r0, [r1, #0x4c]
; }
700ad614: b004         	add	sp, #0x10
700ad616: bd80         	pop	{r7, pc}
		...

700ad620 <uxListRemove>:
; {
700ad620: b082         	sub	sp, #0x8
700ad622: 9001         	str	r0, [sp, #0x4]
;     List_t * const pxList = pxItemToRemove->pxContainer;
700ad624: 9801         	ldr	r0, [sp, #0x4]
700ad626: 6900         	ldr	r0, [r0, #0x10]
700ad628: 9000         	str	r0, [sp]
;     pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
700ad62a: 9801         	ldr	r0, [sp, #0x4]
700ad62c: 6841         	ldr	r1, [r0, #0x4]
700ad62e: 6880         	ldr	r0, [r0, #0x8]
700ad630: 6088         	str	r0, [r1, #0x8]
;     pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
700ad632: 9901         	ldr	r1, [sp, #0x4]
700ad634: 6848         	ldr	r0, [r1, #0x4]
700ad636: 6889         	ldr	r1, [r1, #0x8]
700ad638: 6048         	str	r0, [r1, #0x4]
;     if( pxList->pxIndex == pxItemToRemove )
700ad63a: 9800         	ldr	r0, [sp]
700ad63c: 6840         	ldr	r0, [r0, #0x4]
700ad63e: 9901         	ldr	r1, [sp, #0x4]
700ad640: 4288         	cmp	r0, r1
700ad642: d105         	bne	0x700ad650 <uxListRemove+0x30> @ imm = #0xa
700ad644: e7ff         	b	0x700ad646 <uxListRemove+0x26> @ imm = #-0x2
;         pxList->pxIndex = pxItemToRemove->pxPrevious;
700ad646: 9801         	ldr	r0, [sp, #0x4]
700ad648: 6880         	ldr	r0, [r0, #0x8]
700ad64a: 9900         	ldr	r1, [sp]
700ad64c: 6048         	str	r0, [r1, #0x4]
;     }
700ad64e: e000         	b	0x700ad652 <uxListRemove+0x32> @ imm = #0x0
700ad650: e7ff         	b	0x700ad652 <uxListRemove+0x32> @ imm = #-0x2
;     pxItemToRemove->pxContainer = NULL;
700ad652: 9901         	ldr	r1, [sp, #0x4]
700ad654: 2000         	movs	r0, #0x0
700ad656: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )--;
700ad658: 9900         	ldr	r1, [sp]
700ad65a: 6808         	ldr	r0, [r1]
700ad65c: 3801         	subs	r0, #0x1
700ad65e: 6008         	str	r0, [r1]
;     return pxList->uxNumberOfItems;
700ad660: 9800         	ldr	r0, [sp]
700ad662: 6800         	ldr	r0, [r0]
700ad664: b002         	add	sp, #0x8
700ad666: 4770         	bx	lr
		...

700ad670 <CSL_bcdmaTeardownRxChan>:
; {
700ad670: b580         	push	{r7, lr}
700ad672: b086         	sub	sp, #0x18
700ad674: 9005         	str	r0, [sp, #0x14]
700ad676: 9104         	str	r1, [sp, #0x10]
700ad678: f88d 200f    	strb.w	r2, [sp, #0xf]
700ad67c: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad680: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad684: f000 0001    	and	r0, r0, #0x1
700ad688: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad68a: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ad68e: f000 0001    	and	r0, r0, #0x1
700ad692: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ad694: 9805         	ldr	r0, [sp, #0x14]
700ad696: 9a04         	ldr	r2, [sp, #0x10]
700ad698: 2105         	movs	r1, #0x5
700ad69a: 466b         	mov	r3, sp
700ad69c: f7fd fb98    	bl	0x700aadd0 <CSL_bcdmaDoChanOp> @ imm = #-0x28d0
700ad6a0: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ad6a2: 9802         	ldr	r0, [sp, #0x8]
700ad6a4: b120         	cbz	r0, 0x700ad6b0 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #0x8
700ad6a6: e7ff         	b	0x700ad6a8 <CSL_bcdmaTeardownRxChan+0x38> @ imm = #-0x2
700ad6a8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad6ac: 9002         	str	r0, [sp, #0x8]
;     }
700ad6ae: e7ff         	b	0x700ad6b0 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #-0x2
;     return retVal;
700ad6b0: 9802         	ldr	r0, [sp, #0x8]
700ad6b2: b006         	add	sp, #0x18
700ad6b4: bd80         	pop	{r7, pc}
		...
700ad6be: 0000         	movs	r0, r0

700ad6c0 <CSL_bcdmaTeardownTxChan>:
; {
700ad6c0: b580         	push	{r7, lr}
700ad6c2: b086         	sub	sp, #0x18
700ad6c4: 9005         	str	r0, [sp, #0x14]
700ad6c6: 9104         	str	r1, [sp, #0x10]
700ad6c8: f88d 200f    	strb.w	r2, [sp, #0xf]
700ad6cc: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad6d0: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad6d4: f000 0001    	and	r0, r0, #0x1
700ad6d8: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad6da: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ad6de: f000 0001    	and	r0, r0, #0x1
700ad6e2: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ad6e4: 9805         	ldr	r0, [sp, #0x14]
700ad6e6: 9a04         	ldr	r2, [sp, #0x10]
700ad6e8: 2105         	movs	r1, #0x5
700ad6ea: 466b         	mov	r3, sp
700ad6ec: f7fd fb70    	bl	0x700aadd0 <CSL_bcdmaDoChanOp> @ imm = #-0x2920
700ad6f0: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ad6f2: 9802         	ldr	r0, [sp, #0x8]
700ad6f4: b120         	cbz	r0, 0x700ad700 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #0x8
700ad6f6: e7ff         	b	0x700ad6f8 <CSL_bcdmaTeardownTxChan+0x38> @ imm = #-0x2
700ad6f8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad6fc: 9002         	str	r0, [sp, #0x8]
;     }
700ad6fe: e7ff         	b	0x700ad700 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #-0x2
;     return retVal;
700ad700: 9802         	ldr	r0, [sp, #0x8]
700ad702: b006         	add	sp, #0x18
700ad704: bd80         	pop	{r7, pc}
		...
700ad70e: 0000         	movs	r0, r0

700ad710 <DebugP_uartLogWriterPutChar>:
; {
700ad710: b580         	push	{r7, lr}
700ad712: b088         	sub	sp, #0x20
700ad714: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     char value = character;
700ad718: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700ad71c: f88d 001e    	strb.w	r0, [sp, #0x1e]
;     UART_Handle uartHandle = UART_getHandle(gDebugP_uartDrvIndex);
700ad720: f642 10e4    	movw	r0, #0x29e4
700ad724: f2c7 000b    	movt	r0, #0x700b
700ad728: 6800         	ldr	r0, [r0]
700ad72a: f7ff fd01    	bl	0x700ad130 <UART_getHandle> @ imm = #-0x5fe
700ad72e: 9006         	str	r0, [sp, #0x18]
;     if(uartHandle!=NULL)
700ad730: 9806         	ldr	r0, [sp, #0x18]
700ad732: b170         	cbz	r0, 0x700ad752 <DebugP_uartLogWriterPutChar+0x42> @ imm = #0x1c
700ad734: e7ff         	b	0x700ad736 <DebugP_uartLogWriterPutChar+0x26> @ imm = #-0x2
700ad736: a801         	add	r0, sp, #0x4
;         UART_Transaction_init(&trans);
700ad738: 9000         	str	r0, [sp]
700ad73a: f001 fab9    	bl	0x700aecb0 <UART_Transaction_init> @ imm = #0x1572
700ad73e: 9900         	ldr	r1, [sp]
700ad740: f10d 001e    	add.w	r0, sp, #0x1e
;         trans.buf   = &value;
700ad744: 9001         	str	r0, [sp, #0x4]
700ad746: 2001         	movs	r0, #0x1
;         trans.count = 1;
700ad748: 9002         	str	r0, [sp, #0x8]
;         (void) UART_write(uartHandle, &trans);
700ad74a: 9806         	ldr	r0, [sp, #0x18]
700ad74c: f7f2 fc60    	bl	0x700a0010 <UART_write> @ imm = #-0xd740
;     }
700ad750: e7ff         	b	0x700ad752 <DebugP_uartLogWriterPutChar+0x42> @ imm = #-0x2
; }
700ad752: b008         	add	sp, #0x20
700ad754: bd80         	pop	{r7, pc}
		...
700ad75e: 0000         	movs	r0, r0

700ad760 <Dpl_init>:
; {
700ad760: b510         	push	{r4, lr}
;     HwiP_init();
700ad762: f002 fd25    	bl	0x700b01b0 <HwiP_init>  @ imm = #0x2a4a
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_ERROR);
700ad766: 2002         	movs	r0, #0x2
700ad768: f001 f9b2    	bl	0x700aead0 <DebugP_logZoneEnable> @ imm = #0x1364
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_WARN);
700ad76c: 2004         	movs	r0, #0x4
700ad76e: f001 f9af    	bl	0x700aead0 <DebugP_logZoneEnable> @ imm = #0x135e
;     DebugP_memLogWriterInit(CSL_CORE_ID_R5FSS0_0);
700ad772: 2001         	movs	r0, #0x1
700ad774: f001 fe14    	bl	0x700af3a0 <DebugP_memLogWriterInit> @ imm = #0x1c28
;     DebugP_uartSetDrvIndex(CONFIG_UART_CONSOLE);
700ad778: 2000         	movs	r0, #0x0
700ad77a: 2400         	movs	r4, #0x0
700ad77c: f002 f8c8    	bl	0x700af910 <DebugP_uartSetDrvIndex> @ imm = #0x2190
;     SOC_controlModuleUnlockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad780: 2000         	movs	r0, #0x0
700ad782: 2102         	movs	r1, #0x2
700ad784: f7fb fabc    	bl	0x700a8d00 <SOC_controlModuleUnlockMMR> @ imm = #-0x4a88
700ad788: f248 10d0    	movw	r0, #0x81d0
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad78c: 2102         	movs	r1, #0x2
700ad78e: f2c4 3000    	movt	r0, #0x4300
;     *(volatile uint32_t*)(TIMER8_CLOCK_SRC_MUX_ADDR) = TIMER8_CLOCK_SRC_MCU_HFOSC0;
700ad792: 6004         	str	r4, [r0]
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad794: 2000         	movs	r0, #0x0
700ad796: f7fc fd4b    	bl	0x700aa230 <SOC_controlModuleLockMMR> @ imm = #-0x356a
;     ClockP_init();
700ad79a: f7f2 feb1    	bl	0x700a0500 <ClockP_init> @ imm = #-0xd29e
;     HwiP_enable();
700ad79e: e8bd 4010    	pop.w	{r4, lr}
700ad7a2: f7ef bb69    	b.w	0x7009ce78 <$Ven$TA$L$PI$$HwiP_enable> @ imm = #-0x1092e
		...
700ad7ae: 0000         	movs	r0, r0

700ad7b0 <UART_readLineStatus>:
; {
700ad7b0: b580         	push	{r7, lr}
700ad7b2: b084         	sub	sp, #0x10
700ad7b4: 9003         	str	r0, [sp, #0xc]
700ad7b6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ad7b8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ad7ba: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad7bc: 9803         	ldr	r0, [sp, #0xc]
700ad7be: 300c         	adds	r0, #0xc
700ad7c0: f002 f9b6    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x236c
700ad7c4: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ad7c6: 9803         	ldr	r0, [sp, #0xc]
700ad7c8: 300c         	adds	r0, #0xc
700ad7ca: 9000         	str	r0, [sp]
700ad7cc: f002 f9b0    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x2360
700ad7d0: 4601         	mov	r1, r0
700ad7d2: 9800         	ldr	r0, [sp]
700ad7d4: f001 017f    	and	r1, r1, #0x7f
700ad7d8: f002 f9b2    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x2364
;     retVal = HW_RD_REG32(baseAddr + UART_LSR);
700ad7dc: 9803         	ldr	r0, [sp, #0xc]
700ad7de: 3014         	adds	r0, #0x14
700ad7e0: f002 f9a6    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x234c
700ad7e4: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad7e6: 9803         	ldr	r0, [sp, #0xc]
700ad7e8: 300c         	adds	r0, #0xc
700ad7ea: 9902         	ldr	r1, [sp, #0x8]
700ad7ec: f002 f9a8    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x2350
;     return retVal;
700ad7f0: 9801         	ldr	r0, [sp, #0x4]
700ad7f2: b004         	add	sp, #0x10
700ad7f4: bd80         	pop	{r7, pc}
		...
700ad7fe: 0000         	movs	r0, r0

700ad800 <vTaskExitCritical>:
;   if (xSchedulerRunning != pdFALSE) {
700ad800: f642 2040    	movw	r0, #0x2a40
700ad804: f2c7 000b    	movt	r0, #0x700b
700ad808: 6800         	ldr	r0, [r0]
700ad80a: b1d0         	cbz	r0, 0x700ad842 <vTaskExitCritical+0x42> @ imm = #0x34
700ad80c: e7ff         	b	0x700ad80e <vTaskExitCritical+0xe> @ imm = #-0x2
;     if (pxCurrentTCB->uxCriticalNesting > 0U) {
700ad80e: f642 2000    	movw	r0, #0x2a00
700ad812: f2c7 000b    	movt	r0, #0x700b
700ad816: 6800         	ldr	r0, [r0]
700ad818: 6d40         	ldr	r0, [r0, #0x54]
700ad81a: b180         	cbz	r0, 0x700ad83e <vTaskExitCritical+0x3e> @ imm = #0x20
700ad81c: e7ff         	b	0x700ad81e <vTaskExitCritical+0x1e> @ imm = #-0x2
;       (pxCurrentTCB->uxCriticalNesting)--;
700ad81e: f642 2000    	movw	r0, #0x2a00
700ad822: f2c7 000b    	movt	r0, #0x700b
700ad826: 6802         	ldr	r2, [r0]
700ad828: 6d51         	ldr	r1, [r2, #0x54]
700ad82a: 3901         	subs	r1, #0x1
700ad82c: 6551         	str	r1, [r2, #0x54]
;       if (pxCurrentTCB->uxCriticalNesting == 0U) {
700ad82e: 6800         	ldr	r0, [r0]
700ad830: 6d40         	ldr	r0, [r0, #0x54]
700ad832: b910         	cbnz	r0, 0x700ad83a <vTaskExitCritical+0x3a> @ imm = #0x4
700ad834: e7ff         	b	0x700ad836 <vTaskExitCritical+0x36> @ imm = #-0x2
;     __asm__ volatile ( "CPSIE	i" ::: "cc" );
700ad836: b662         	cpsie i
;       } else {
700ad838: e000         	b	0x700ad83c <vTaskExitCritical+0x3c> @ imm = #0x0
700ad83a: e7ff         	b	0x700ad83c <vTaskExitCritical+0x3c> @ imm = #-0x2
;     } else {
700ad83c: e000         	b	0x700ad840 <vTaskExitCritical+0x40> @ imm = #0x0
700ad83e: e7ff         	b	0x700ad840 <vTaskExitCritical+0x40> @ imm = #-0x2
;   } else {
700ad840: e000         	b	0x700ad844 <vTaskExitCritical+0x44> @ imm = #0x0
700ad842: e7ff         	b	0x700ad844 <vTaskExitCritical+0x44> @ imm = #-0x2
; }
700ad844: 4770         	bx	lr
		...
700ad84e: 0000         	movs	r0, r0

700ad850 <CSL_bcdmaGetChanPeerReg>:
; {
700ad850: b580         	push	{r7, lr}
700ad852: b088         	sub	sp, #0x20
700ad854: f8dd c028    	ldr.w	r12, [sp, #0x28]
700ad858: 9007         	str	r0, [sp, #0x1c]
700ad85a: 9106         	str	r1, [sp, #0x18]
700ad85c: 9205         	str	r2, [sp, #0x14]
700ad85e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700ad860: 9804         	ldr	r0, [sp, #0x10]
700ad862: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700ad864: 9807         	ldr	r0, [sp, #0x1c]
700ad866: 9a06         	ldr	r2, [sp, #0x18]
700ad868: 210b         	movs	r1, #0xb
700ad86a: ab01         	add	r3, sp, #0x4
700ad86c: f7fd fab0    	bl	0x700aadd0 <CSL_bcdmaDoChanOp> @ imm = #-0x2aa0
700ad870: 9003         	str	r0, [sp, #0xc]
;     if( retVal == CSL_PASS )
700ad872: 9803         	ldr	r0, [sp, #0xc]
700ad874: b920         	cbnz	r0, 0x700ad880 <CSL_bcdmaGetChanPeerReg+0x30> @ imm = #0x8
700ad876: e7ff         	b	0x700ad878 <CSL_bcdmaGetChanPeerReg+0x28> @ imm = #-0x2
;         *pVal = remotePeerOpts.regVal;
700ad878: 9802         	ldr	r0, [sp, #0x8]
700ad87a: 990a         	ldr	r1, [sp, #0x28]
700ad87c: 6008         	str	r0, [r1]
;     }
700ad87e: e006         	b	0x700ad88e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #0xc
;         *pVal = (uint32_t)0U;
700ad880: 990a         	ldr	r1, [sp, #0x28]
700ad882: 2000         	movs	r0, #0x0
700ad884: 6008         	str	r0, [r1]
700ad886: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad88a: 9003         	str	r0, [sp, #0xc]
700ad88c: e7ff         	b	0x700ad88e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #-0x2
;     return retVal;
700ad88e: 9803         	ldr	r0, [sp, #0xc]
700ad890: b008         	add	sp, #0x20
700ad892: bd80         	pop	{r7, pc}
		...

700ad8a0 <_strnlen_s>:
; {
700ad8a0: b084         	sub	sp, #0x10
700ad8a2: 9003         	str	r0, [sp, #0xc]
700ad8a4: 9102         	str	r1, [sp, #0x8]
;   for (s = str; *s && maxsize--; ++s);
700ad8a6: 9803         	ldr	r0, [sp, #0xc]
700ad8a8: 9001         	str	r0, [sp, #0x4]
700ad8aa: e7ff         	b	0x700ad8ac <_strnlen_s+0xc> @ imm = #-0x2
700ad8ac: 9801         	ldr	r0, [sp, #0x4]
700ad8ae: 7801         	ldrb	r1, [r0]
700ad8b0: 2000         	movs	r0, #0x0
700ad8b2: 9000         	str	r0, [sp]
700ad8b4: b141         	cbz	r1, 0x700ad8c8 <_strnlen_s+0x28> @ imm = #0x10
700ad8b6: e7ff         	b	0x700ad8b8 <_strnlen_s+0x18> @ imm = #-0x2
700ad8b8: 9802         	ldr	r0, [sp, #0x8]
700ad8ba: 1e41         	subs	r1, r0, #0x1
700ad8bc: 9102         	str	r1, [sp, #0x8]
700ad8be: 2800         	cmp	r0, #0x0
700ad8c0: bf18         	it	ne
700ad8c2: 2001         	movne	r0, #0x1
700ad8c4: 9000         	str	r0, [sp]
700ad8c6: e7ff         	b	0x700ad8c8 <_strnlen_s+0x28> @ imm = #-0x2
700ad8c8: 9800         	ldr	r0, [sp]
;   for (s = str; *s && maxsize--; ++s);
700ad8ca: 07c0         	lsls	r0, r0, #0x1f
700ad8cc: b128         	cbz	r0, 0x700ad8da <_strnlen_s+0x3a> @ imm = #0xa
700ad8ce: e7ff         	b	0x700ad8d0 <_strnlen_s+0x30> @ imm = #-0x2
700ad8d0: e7ff         	b	0x700ad8d2 <_strnlen_s+0x32> @ imm = #-0x2
700ad8d2: 9801         	ldr	r0, [sp, #0x4]
700ad8d4: 3001         	adds	r0, #0x1
700ad8d6: 9001         	str	r0, [sp, #0x4]
700ad8d8: e7e8         	b	0x700ad8ac <_strnlen_s+0xc> @ imm = #-0x30
;   return (unsigned int)(s - str);
700ad8da: 9801         	ldr	r0, [sp, #0x4]
700ad8dc: 9903         	ldr	r1, [sp, #0xc]
700ad8de: 1a40         	subs	r0, r0, r1
700ad8e0: b004         	add	sp, #0x10
700ad8e2: 4770         	bx	lr
		...

700ad8f0 <prvSampleTimeNow>:
;     {
700ad8f0: b580         	push	{r7, lr}
700ad8f2: b082         	sub	sp, #0x8
700ad8f4: 9001         	str	r0, [sp, #0x4]
;         xTimeNow = xTaskGetTickCount();
700ad8f6: f001 fdf3    	bl	0x700af4e0 <xTaskGetTickCount> @ imm = #0x1be6
700ad8fa: 9000         	str	r0, [sp]
;         if( xTimeNow < xLastTime )
700ad8fc: 9800         	ldr	r0, [sp]
700ad8fe: f642 11fc    	movw	r1, #0x29fc
700ad902: f2c7 010b    	movt	r1, #0x700b
700ad906: 6809         	ldr	r1, [r1]
700ad908: 4288         	cmp	r0, r1
700ad90a: d206         	bhs	0x700ad91a <prvSampleTimeNow+0x2a> @ imm = #0xc
700ad90c: e7ff         	b	0x700ad90e <prvSampleTimeNow+0x1e> @ imm = #-0x2
;             prvSwitchTimerLists();
700ad90e: f7f9 feff    	bl	0x700a7710 <prvSwitchTimerLists> @ imm = #-0x6202
;             *pxTimerListsWereSwitched = pdTRUE;
700ad912: 9901         	ldr	r1, [sp, #0x4]
700ad914: 2001         	movs	r0, #0x1
700ad916: 6008         	str	r0, [r1]
;         }
700ad918: e003         	b	0x700ad922 <prvSampleTimeNow+0x32> @ imm = #0x6
;             *pxTimerListsWereSwitched = pdFALSE;
700ad91a: 9901         	ldr	r1, [sp, #0x4]
700ad91c: 2000         	movs	r0, #0x0
700ad91e: 6008         	str	r0, [r1]
700ad920: e7ff         	b	0x700ad922 <prvSampleTimeNow+0x32> @ imm = #-0x2
;         xLastTime = xTimeNow;
700ad922: 9800         	ldr	r0, [sp]
700ad924: f642 11fc    	movw	r1, #0x29fc
700ad928: f2c7 010b    	movt	r1, #0x700b
700ad92c: 6008         	str	r0, [r1]
;         return xTimeNow;
700ad92e: 9800         	ldr	r0, [sp]
700ad930: b002         	add	sp, #0x8
700ad932: bd80         	pop	{r7, pc}
		...

700ad940 <CSL_udmapCppi5SetPktLen>:
; {
700ad940: b083         	sub	sp, #0xc
700ad942: 9002         	str	r0, [sp, #0x8]
700ad944: 9101         	str	r1, [sp, #0x4]
700ad946: 9200         	str	r2, [sp]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ad948: 9801         	ldr	r0, [sp, #0x4]
700ad94a: 2801         	cmp	r0, #0x1
700ad94c: d004         	beq	0x700ad958 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #0x8
700ad94e: e7ff         	b	0x700ad950 <CSL_udmapCppi5SetPktLen+0x10> @ imm = #-0x2
;         (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO) )
700ad950: 9801         	ldr	r0, [sp, #0x4]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ad952: 2802         	cmp	r0, #0x2
700ad954: d107         	bne	0x700ad966 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #0xe
700ad956: e7ff         	b	0x700ad958 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PKTLEN, pktLen );
700ad958: 9902         	ldr	r1, [sp, #0x8]
700ad95a: 6808         	ldr	r0, [r1]
700ad95c: 9a00         	ldr	r2, [sp]
700ad95e: f362 0015    	bfi	r0, r2, #0, #22
700ad962: 6008         	str	r0, [r1]
;     }
700ad964: e7ff         	b	0x700ad966 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #-0x2
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700ad966: 9801         	ldr	r0, [sp, #0x4]
700ad968: 2803         	cmp	r0, #0x3
700ad96a: d108         	bne	0x700ad97e <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #0x10
700ad96c: e7ff         	b	0x700ad96e <CSL_udmapCppi5SetPktLen+0x2e> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5TRPD *)pDesc)->descInfo, UDMAP_CPPI5_TRPD_DESCINFO_LASTIDX, pktLen-1U );
700ad96e: 9902         	ldr	r1, [sp, #0x8]
700ad970: 6808         	ldr	r0, [r1]
700ad972: 9a00         	ldr	r2, [sp]
700ad974: 3a01         	subs	r2, #0x1
700ad976: f362 000d    	bfi	r0, r2, #0, #14
700ad97a: 6008         	str	r0, [r1]
;     }
700ad97c: e7ff         	b	0x700ad97e <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #-0x2
; }
700ad97e: b003         	add	sp, #0xc
700ad980: 4770         	bx	lr
		...
700ad98e: 0000         	movs	r0, r0

700ad990 <Sciclient_rmIrqGetNodeItf>:
; {
700ad990: b084         	sub	sp, #0x10
700ad992: 9003         	str	r0, [sp, #0xc]
700ad994: f8ad 100a    	strh.w	r1, [sp, #0xa]
700ad998: 9201         	str	r2, [sp, #0x4]
700ad99a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ad99c: 9000         	str	r0, [sp]
;     if (n_itf < n->n_if) {
700ad99e: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700ad9a2: 9903         	ldr	r1, [sp, #0xc]
700ad9a4: 8849         	ldrh	r1, [r1, #0x2]
700ad9a6: 4288         	cmp	r0, r1
700ad9a8: da09         	bge	0x700ad9be <Sciclient_rmIrqGetNodeItf+0x2e> @ imm = #0x12
700ad9aa: e7ff         	b	0x700ad9ac <Sciclient_rmIrqGetNodeItf+0x1c> @ imm = #-0x2
;         *itf = n->p_if[n_itf];
700ad9ac: 9803         	ldr	r0, [sp, #0xc]
700ad9ae: 6840         	ldr	r0, [r0, #0x4]
700ad9b0: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700ad9b4: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ad9b8: 9901         	ldr	r1, [sp, #0x4]
700ad9ba: 6008         	str	r0, [r1]
;     } else {
700ad9bc: e006         	b	0x700ad9cc <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #0xc
;         *itf = NULL;
700ad9be: 9901         	ldr	r1, [sp, #0x4]
700ad9c0: 2000         	movs	r0, #0x0
700ad9c2: 6008         	str	r0, [r1]
700ad9c4: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ad9c8: 9000         	str	r0, [sp]
700ad9ca: e7ff         	b	0x700ad9cc <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #-0x2
;     return r;
700ad9cc: 9800         	ldr	r0, [sp]
700ad9ce: b004         	add	sp, #0x10
700ad9d0: 4770         	bx	lr
		...
700ad9de: 0000         	movs	r0, r0

700ad9e0 <UART_checkOpenParams>:
; {
700ad9e0: b082         	sub	sp, #0x8
700ad9e2: 9001         	str	r0, [sp, #0x4]
700ad9e4: 2000         	movs	r0, #0x0
;     int32_t     status = SystemP_SUCCESS;
700ad9e6: 9000         	str	r0, [sp]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700ad9e8: 9801         	ldr	r0, [sp, #0x4]
700ad9ea: 6900         	ldr	r0, [r0, #0x10]
700ad9ec: 2801         	cmp	r0, #0x1
700ad9ee: d108         	bne	0x700ada02 <UART_checkOpenParams+0x22> @ imm = #0x10
700ad9f0: e7ff         	b	0x700ad9f2 <UART_checkOpenParams+0x12> @ imm = #-0x2
;        (NULL_PTR == prms->readCallbackFxn))
700ad9f2: 9801         	ldr	r0, [sp, #0x4]
700ad9f4: 69c0         	ldr	r0, [r0, #0x1c]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700ad9f6: b920         	cbnz	r0, 0x700ada02 <UART_checkOpenParams+0x22> @ imm = #0x8
700ad9f8: e7ff         	b	0x700ad9fa <UART_checkOpenParams+0x1a> @ imm = #-0x2
700ad9fa: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ad9fe: 9000         	str	r0, [sp]
;     }
700ada00: e7ff         	b	0x700ada02 <UART_checkOpenParams+0x22> @ imm = #-0x2
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700ada02: 9801         	ldr	r0, [sp, #0x4]
700ada04: 6980         	ldr	r0, [r0, #0x18]
700ada06: 2801         	cmp	r0, #0x1
700ada08: d108         	bne	0x700ada1c <UART_checkOpenParams+0x3c> @ imm = #0x10
700ada0a: e7ff         	b	0x700ada0c <UART_checkOpenParams+0x2c> @ imm = #-0x2
;        (NULL_PTR == prms->writeCallbackFxn))
700ada0c: 9801         	ldr	r0, [sp, #0x4]
700ada0e: 6a00         	ldr	r0, [r0, #0x20]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700ada10: b920         	cbnz	r0, 0x700ada1c <UART_checkOpenParams+0x3c> @ imm = #0x8
700ada12: e7ff         	b	0x700ada14 <UART_checkOpenParams+0x34> @ imm = #-0x2
700ada14: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ada18: 9000         	str	r0, [sp]
;     }
700ada1a: e7ff         	b	0x700ada1c <UART_checkOpenParams+0x3c> @ imm = #-0x2
;     return (status);
700ada1c: 9800         	ldr	r0, [sp]
700ada1e: b002         	add	sp, #0x8
700ada20: 4770         	bx	lr
		...
700ada2e: 0000         	movs	r0, r0

700ada30 <UdmaUtils_getRingMemSize>:
; {
700ada30: b084         	sub	sp, #0x10
700ada32: f88d 000f    	strb.w	r0, [sp, #0xf]
700ada36: 9102         	str	r1, [sp, #0x8]
700ada38: f88d 2007    	strb.w	r2, [sp, #0x7]
;     ringMemSize = ((uint32_t) 1U << (elemSize + 2U));   /* Element size in bytes */
700ada3c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ada40: 1c81         	adds	r1, r0, #0x2
700ada42: 2001         	movs	r0, #0x1
700ada44: 4088         	lsls	r0, r1
700ada46: 9000         	str	r0, [sp]
;     ringMemSize *= elemCnt;
700ada48: 9902         	ldr	r1, [sp, #0x8]
700ada4a: 9800         	ldr	r0, [sp]
700ada4c: 4348         	muls	r0, r1, r0
700ada4e: 9000         	str	r0, [sp]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700ada50: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ada54: 2802         	cmp	r0, #0x2
700ada56: d005         	beq	0x700ada64 <UdmaUtils_getRingMemSize+0x34> @ imm = #0xa
700ada58: e7ff         	b	0x700ada5a <UdmaUtils_getRingMemSize+0x2a> @ imm = #-0x2
;        (TISCI_MSG_VALUE_RM_RING_MODE_QM == mode))
700ada5a: f89d 000f    	ldrb.w	r0, [sp, #0xf]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700ada5e: 2803         	cmp	r0, #0x3
700ada60: d104         	bne	0x700ada6c <UdmaUtils_getRingMemSize+0x3c> @ imm = #0x8
700ada62: e7ff         	b	0x700ada64 <UdmaUtils_getRingMemSize+0x34> @ imm = #-0x2
;         ringMemSize <<= 1U;
700ada64: 9800         	ldr	r0, [sp]
700ada66: 0040         	lsls	r0, r0, #0x1
700ada68: 9000         	str	r0, [sp]
;     }
700ada6a: e7ff         	b	0x700ada6c <UdmaUtils_getRingMemSize+0x3c> @ imm = #-0x2
;     return (ringMemSize);
700ada6c: 9800         	ldr	r0, [sp]
700ada6e: b004         	add	sp, #0x10
700ada70: 4770         	bx	lr
		...
700ada7e: 0000         	movs	r0, r0

700ada80 <prvCopyDataFromQueue>:
; {
700ada80: b580         	push	{r7, lr}
700ada82: b082         	sub	sp, #0x8
700ada84: 9001         	str	r0, [sp, #0x4]
700ada86: 9100         	str	r1, [sp]
;     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
700ada88: 9801         	ldr	r0, [sp, #0x4]
700ada8a: 6c00         	ldr	r0, [r0, #0x40]
700ada8c: b1b8         	cbz	r0, 0x700adabe <prvCopyDataFromQueue+0x3e> @ imm = #0x2e
700ada8e: e7ff         	b	0x700ada90 <prvCopyDataFromQueue+0x10> @ imm = #-0x2
;         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700ada90: 9901         	ldr	r1, [sp, #0x4]
700ada92: 68c8         	ldr	r0, [r1, #0xc]
700ada94: 6c0a         	ldr	r2, [r1, #0x40]
700ada96: 4410         	add	r0, r2
700ada98: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
700ada9a: 9801         	ldr	r0, [sp, #0x4]
700ada9c: 6881         	ldr	r1, [r0, #0x8]
700ada9e: 68c0         	ldr	r0, [r0, #0xc]
700adaa0: 4288         	cmp	r0, r1
700adaa2: d304         	blo	0x700adaae <prvCopyDataFromQueue+0x2e> @ imm = #0x8
700adaa4: e7ff         	b	0x700adaa6 <prvCopyDataFromQueue+0x26> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
700adaa6: 9901         	ldr	r1, [sp, #0x4]
700adaa8: 6808         	ldr	r0, [r1]
700adaaa: 60c8         	str	r0, [r1, #0xc]
;         }
700adaac: e000         	b	0x700adab0 <prvCopyDataFromQueue+0x30> @ imm = #0x0
700adaae: e7ff         	b	0x700adab0 <prvCopyDataFromQueue+0x30> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700adab0: 9800         	ldr	r0, [sp]
700adab2: 9a01         	ldr	r2, [sp, #0x4]
700adab4: 68d1         	ldr	r1, [r2, #0xc]
700adab6: 6c12         	ldr	r2, [r2, #0x40]
700adab8: f7ec ea50    	blx	0x70099f5c <__aeabi_memcpy8> @ imm = #-0x13b60
;     }
700adabc: e7ff         	b	0x700adabe <prvCopyDataFromQueue+0x3e> @ imm = #-0x2
; }
700adabe: b002         	add	sp, #0x8
700adac0: bd80         	pop	{r7, pc}
		...
700adace: 0000         	movs	r0, r0

700adad0 <CSL_lcdma_ringaccIsTeardownComplete>:
; {
700adad0: b580         	push	{r7, lr}
700adad2: b084         	sub	sp, #0x10
700adad4: 9003         	str	r0, [sp, #0xc]
700adad6: 9102         	str	r1, [sp, #0x8]
700adad8: 2000         	movs	r0, #0x0
;     bool bRetVal = (bool)false;
700adada: f88d 0007    	strb.w	r0, [sp, #0x7]
;     if( CSL_REG32_FEXT( &pCfg->pRingRtRegs->RING[ringNum].ROCC, LCDMA_RINGACC_RINGRT_RING_ROCC_COMP ) != (uint32_t)0U )
700adade: 9803         	ldr	r0, [sp, #0xc]
700adae0: 6840         	ldr	r0, [r0, #0x4]
700adae2: 9902         	ldr	r1, [sp, #0x8]
700adae4: eb00 3041    	add.w	r0, r0, r1, lsl #13
700adae8: f241 0118    	movw	r1, #0x1018
700adaec: 4408         	add	r0, r1
700adaee: f04f 4100    	mov.w	r1, #0x80000000
700adaf2: 221f         	movs	r2, #0x1f
700adaf4: f001 faa4    	bl	0x700af040 <CSL_REG32_FEXT_RAW> @ imm = #0x1548
700adaf8: b120         	cbz	r0, 0x700adb04 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #0x8
700adafa: e7ff         	b	0x700adafc <CSL_lcdma_ringaccIsTeardownComplete+0x2c> @ imm = #-0x2
700adafc: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700adafe: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700adb02: e7ff         	b	0x700adb04 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #-0x2
;     return bRetVal;
700adb04: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700adb08: f000 0001    	and	r0, r0, #0x1
700adb0c: b004         	add	sp, #0x10
700adb0e: bd80         	pop	{r7, pc}

700adb10 <Sciclient_rmIrqProgramOesRegister>:
; {
700adb10: b580         	push	{r7, lr}
700adb12: b088         	sub	sp, #0x20
700adb14: 9007         	str	r0, [sp, #0x1c]
700adb16: 2010         	movs	r0, #0x10
700adb18: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700adb1c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700adb1e: 9807         	ldr	r0, [sp, #0x1c]
700adb20: 7900         	ldrb	r0, [r0, #0x4]
700adb22: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700adb26: 9807         	ldr	r0, [sp, #0x1c]
700adb28: 88c0         	ldrh	r0, [r0, #0x6]
700adb2a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700adb2e: 9807         	ldr	r0, [sp, #0x1c]
700adb30: 8900         	ldrh	r0, [r0, #0x8]
700adb32: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700adb36: 9807         	ldr	r0, [sp, #0x1c]
700adb38: 89c0         	ldrh	r0, [r0, #0xe]
700adb3a: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                                  cfg->set_resp,
700adb3e: 9807         	ldr	r0, [sp, #0x1c]
700adb40: 6981         	ldr	r1, [r0, #0x18]
700adb42: 4668         	mov	r0, sp
700adb44: f04f 32ff    	mov.w	r2, #0xffffffff
;     return Sciclient_rmIrqSetRaw(&req,
700adb48: f7fe fdda    	bl	0x700ac700 <Sciclient_rmIrqSetRaw> @ imm = #-0x144c
700adb4c: b008         	add	sp, #0x20
700adb4e: bd80         	pop	{r7, pc}

700adb50 <Sciclient_rmPsGetIfIdx>:
; {
700adb50: b082         	sub	sp, #0x8
700adb52: f8ad 0006    	strh.w	r0, [sp, #0x6]
700adb56: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700adb5a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700adb5c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adb60: f241 0158    	movw	r1, #0x1058
700adb64: f2c7 0108    	movt	r1, #0x7008
700adb68: 8c89         	ldrh	r1, [r1, #0x24]
700adb6a: 4288         	cmp	r0, r1
700adb6c: da0d         	bge	0x700adb8a <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #0x1a
700adb6e: e7ff         	b	0x700adb70 <Sciclient_rmPsGetIfIdx+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].if_idx;
700adb70: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adb74: eb00 0140    	add.w	r1, r0, r0, lsl #1
700adb78: f241 0058    	movw	r0, #0x1058
700adb7c: f2c7 0008    	movt	r0, #0x7008
700adb80: eb00 0081    	add.w	r0, r0, r1, lsl #2
700adb84: 8880         	ldrh	r0, [r0, #0x4]
700adb86: 9000         	str	r0, [sp]
;     }
700adb88: e7ff         	b	0x700adb8a <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #-0x2
;     return r;
700adb8a: 9800         	ldr	r0, [sp]
700adb8c: b002         	add	sp, #0x8
700adb8e: 4770         	bx	lr

700adb90 <Sciclient_rmPsGetInp>:
; {
700adb90: b082         	sub	sp, #0x8
700adb92: f8ad 0006    	strh.w	r0, [sp, #0x6]
700adb96: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700adb9a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700adb9c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adba0: f241 0158    	movw	r1, #0x1058
700adba4: f2c7 0108    	movt	r1, #0x7008
700adba8: 8c89         	ldrh	r1, [r1, #0x24]
700adbaa: 4288         	cmp	r0, r1
700adbac: da0d         	bge	0x700adbca <Sciclient_rmPsGetInp+0x3a> @ imm = #0x1a
700adbae: e7ff         	b	0x700adbb0 <Sciclient_rmPsGetInp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].inp;
700adbb0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adbb4: eb00 0140    	add.w	r1, r0, r0, lsl #1
700adbb8: f241 0058    	movw	r0, #0x1058
700adbbc: f2c7 0008    	movt	r0, #0x7008
700adbc0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700adbc4: 88c0         	ldrh	r0, [r0, #0x6]
700adbc6: 9000         	str	r0, [sp]
;     }
700adbc8: e7ff         	b	0x700adbca <Sciclient_rmPsGetInp+0x3a> @ imm = #-0x2
;     return r;
700adbca: 9800         	ldr	r0, [sp]
700adbcc: b002         	add	sp, #0x8
700adbce: 4770         	bx	lr

700adbd0 <Sciclient_rmPsGetOutp>:
; {
700adbd0: b082         	sub	sp, #0x8
700adbd2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700adbd6: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700adbda: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700adbdc: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adbe0: f241 0158    	movw	r1, #0x1058
700adbe4: f2c7 0108    	movt	r1, #0x7008
700adbe8: 8c89         	ldrh	r1, [r1, #0x24]
700adbea: 4288         	cmp	r0, r1
700adbec: da0d         	bge	0x700adc0a <Sciclient_rmPsGetOutp+0x3a> @ imm = #0x1a
700adbee: e7ff         	b	0x700adbf0 <Sciclient_rmPsGetOutp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].outp;
700adbf0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adbf4: eb00 0140    	add.w	r1, r0, r0, lsl #1
700adbf8: f241 0058    	movw	r0, #0x1058
700adbfc: f2c7 0008    	movt	r0, #0x7008
700adc00: eb00 0081    	add.w	r0, r0, r1, lsl #2
700adc04: 8900         	ldrh	r0, [r0, #0x8]
700adc06: 9000         	str	r0, [sp]
;     }
700adc08: e7ff         	b	0x700adc0a <Sciclient_rmPsGetOutp+0x3a> @ imm = #-0x2
;     return r;
700adc0a: 9800         	ldr	r0, [sp]
700adc0c: b002         	add	sp, #0x8
700adc0e: 4770         	bx	lr

700adc10 <free_list_insert>:
700adc10: e5902000     	ldr	r2, [r0]
700adc14: e59f1030     	ldr	r1, [pc, #0x30]         @ 0x700adc4c <free_list_insert+0x3c>
700adc18: e3c2c001     	bic	r12, r2, #1
700adc1c: e5913000     	ldr	r3, [r1]
700adc20: e3530000     	cmp	r3, #0
700adc24: 0a000005     	beq	0x700adc40 <free_list_insert+0x30> @ imm = #0x14
700adc28: e5932000     	ldr	r2, [r3]
700adc2c: e3c22001     	bic	r2, r2, #1
700adc30: e152000c     	cmp	r2, r12
700adc34: 2a000001     	bhs	0x700adc40 <free_list_insert+0x30> @ imm = #0x4
700adc38: e2831008     	add	r1, r3, #8
700adc3c: eafffff6     	b	0x700adc1c <free_list_insert+0xc> @ imm = #-0x28
700adc40: e5803008     	str	r3, [r0, #0x8]
700adc44: e5810000     	str	r0, [r1]
700adc48: e12fff1e     	bx	lr
700adc4c: 34 51 08 70  	.word	0x70085134

700adc50 <prvGetNextExpireTime>:
;     {
700adc50: b082         	sub	sp, #0x8
700adc52: 9001         	str	r0, [sp, #0x4]
;         *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
700adc54: f245 1024    	movw	r0, #0x5124
700adc58: f2c7 0008    	movt	r0, #0x7008
700adc5c: 6800         	ldr	r0, [r0]
700adc5e: 6800         	ldr	r0, [r0]
700adc60: fab0 f080    	clz	r0, r0
700adc64: 0940         	lsrs	r0, r0, #0x5
700adc66: 9901         	ldr	r1, [sp, #0x4]
700adc68: 6008         	str	r0, [r1]
;         if( *pxListWasEmpty == pdFALSE )
700adc6a: 9801         	ldr	r0, [sp, #0x4]
700adc6c: 6800         	ldr	r0, [r0]
700adc6e: b948         	cbnz	r0, 0x700adc84 <prvGetNextExpireTime+0x34> @ imm = #0x12
700adc70: e7ff         	b	0x700adc72 <prvGetNextExpireTime+0x22> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700adc72: f245 1024    	movw	r0, #0x5124
700adc76: f2c7 0008    	movt	r0, #0x7008
700adc7a: 6800         	ldr	r0, [r0]
700adc7c: 68c0         	ldr	r0, [r0, #0xc]
700adc7e: 6800         	ldr	r0, [r0]
700adc80: 9000         	str	r0, [sp]
;         }
700adc82: e002         	b	0x700adc8a <prvGetNextExpireTime+0x3a> @ imm = #0x4
700adc84: 2000         	movs	r0, #0x0
;             xNextExpireTime = ( TickType_t ) 0U;
700adc86: 9000         	str	r0, [sp]
700adc88: e7ff         	b	0x700adc8a <prvGetNextExpireTime+0x3a> @ imm = #-0x2
;         return xNextExpireTime;
700adc8a: 9800         	ldr	r0, [sp]
700adc8c: b002         	add	sp, #0x8
700adc8e: 4770         	bx	lr

700adc90 <Sciclient_secProxyWaitThread>:
; {
700adc90: b580         	push	{r7, lr}
700adc92: b084         	sub	sp, #0x10
700adc94: 9003         	str	r0, [sp, #0xc]
700adc96: 9102         	str	r1, [sp, #0x8]
700adc98: f06f 0003    	mvn	r0, #0x3
;     int32_t  status     = CSL_ETIMEOUT;
700adc9c: 9001         	str	r0, [sp, #0x4]
;     uint32_t timeToWait = timeout;
700adc9e: 9802         	ldr	r0, [sp, #0x8]
700adca0: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700adca2: e7ff         	b	0x700adca4 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x2
700adca4: 9800         	ldr	r0, [sp]
700adca6: b178         	cbz	r0, 0x700adcc8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x1e
700adca8: e7ff         	b	0x700adcaa <Sciclient_secProxyWaitThread+0x1a> @ imm = #-0x2
;         if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700adcaa: 9803         	ldr	r0, [sp, #0xc]
700adcac: f001 fcd8    	bl	0x700af660 <Sciclient_secProxyThreadStatusReg> @ imm = #0x19b0
700adcb0: f001 ff9e    	bl	0x700afbf0 <CSL_REG32_RD_RAW> @ imm = #0x1f3c
700adcb4: 0600         	lsls	r0, r0, #0x18
700adcb6: b118         	cbz	r0, 0x700adcc0 <Sciclient_secProxyWaitThread+0x30> @ imm = #0x6
700adcb8: e7ff         	b	0x700adcba <Sciclient_secProxyWaitThread+0x2a> @ imm = #-0x2
700adcba: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700adcbc: 9001         	str	r0, [sp, #0x4]
;             break;
700adcbe: e003         	b	0x700adcc8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x6
;         timeToWait--;
700adcc0: 9800         	ldr	r0, [sp]
700adcc2: 3801         	subs	r0, #0x1
700adcc4: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700adcc6: e7ed         	b	0x700adca4 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x26
;     return status;
700adcc8: 9801         	ldr	r0, [sp, #0x4]
700adcca: b004         	add	sp, #0x10
700adccc: bd80         	pop	{r7, pc}
700adcce: 0000         	movs	r0, r0

700adcd0 <UART_IsHWFlowCtrlValid>:
; {
700adcd0: b082         	sub	sp, #0x8
700adcd2: 9001         	str	r0, [sp, #0x4]
700adcd4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700adcd8: 9000         	str	r0, [sp]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700adcda: 9801         	ldr	r0, [sp, #0x4]
700adcdc: 2801         	cmp	r0, #0x1
700adcde: d010         	beq	0x700add02 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x20
700adce0: e7ff         	b	0x700adce2 <UART_IsHWFlowCtrlValid+0x12> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_8)  ||
700adce2: 9801         	ldr	r0, [sp, #0x4]
700adce4: 2808         	cmp	r0, #0x8
700adce6: d00c         	beq	0x700add02 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x18
700adce8: e7ff         	b	0x700adcea <UART_IsHWFlowCtrlValid+0x1a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_16) ||
700adcea: 9801         	ldr	r0, [sp, #0x4]
700adcec: 2810         	cmp	r0, #0x10
700adcee: d008         	beq	0x700add02 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x10
700adcf0: e7ff         	b	0x700adcf2 <UART_IsHWFlowCtrlValid+0x22> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_56) ||
700adcf2: 9801         	ldr	r0, [sp, #0x4]
700adcf4: 2838         	cmp	r0, #0x38
700adcf6: d004         	beq	0x700add02 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x8
700adcf8: e7ff         	b	0x700adcfa <UART_IsHWFlowCtrlValid+0x2a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_60)))
700adcfa: 9801         	ldr	r0, [sp, #0x4]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700adcfc: 283c         	cmp	r0, #0x3c
700adcfe: d103         	bne	0x700add08 <UART_IsHWFlowCtrlValid+0x38> @ imm = #0x6
700add00: e7ff         	b	0x700add02 <UART_IsHWFlowCtrlValid+0x32> @ imm = #-0x2
700add02: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700add04: 9000         	str	r0, [sp]
;     }
700add06: e7ff         	b	0x700add08 <UART_IsHWFlowCtrlValid+0x38> @ imm = #-0x2
;     return status;
700add08: 9800         	ldr	r0, [sp]
700add0a: b002         	add	sp, #0x8
700add0c: 4770         	bx	lr
700add0e: 0000         	movs	r0, r0

700add10 <UART_IsRxTrigLvlValid>:
; {
700add10: b082         	sub	sp, #0x8
700add12: 9001         	str	r0, [sp, #0x4]
700add14: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700add18: 9000         	str	r0, [sp]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700add1a: 9801         	ldr	r0, [sp, #0x4]
700add1c: 2801         	cmp	r0, #0x1
700add1e: d010         	beq	0x700add42 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x20
700add20: e7ff         	b	0x700add22 <UART_IsRxTrigLvlValid+0x12> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_8)  ||
700add22: 9801         	ldr	r0, [sp, #0x4]
700add24: 2808         	cmp	r0, #0x8
700add26: d00c         	beq	0x700add42 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x18
700add28: e7ff         	b	0x700add2a <UART_IsRxTrigLvlValid+0x1a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_16) ||
700add2a: 9801         	ldr	r0, [sp, #0x4]
700add2c: 2810         	cmp	r0, #0x10
700add2e: d008         	beq	0x700add42 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x10
700add30: e7ff         	b	0x700add32 <UART_IsRxTrigLvlValid+0x22> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_56) ||
700add32: 9801         	ldr	r0, [sp, #0x4]
700add34: 2838         	cmp	r0, #0x38
700add36: d004         	beq	0x700add42 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x8
700add38: e7ff         	b	0x700add3a <UART_IsRxTrigLvlValid+0x2a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_60)))
700add3a: 9801         	ldr	r0, [sp, #0x4]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700add3c: 283c         	cmp	r0, #0x3c
700add3e: d103         	bne	0x700add48 <UART_IsRxTrigLvlValid+0x38> @ imm = #0x6
700add40: e7ff         	b	0x700add42 <UART_IsRxTrigLvlValid+0x32> @ imm = #-0x2
700add42: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700add44: 9000         	str	r0, [sp]
;     }
700add46: e7ff         	b	0x700add48 <UART_IsRxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700add48: 9800         	ldr	r0, [sp]
700add4a: b002         	add	sp, #0x8
700add4c: 4770         	bx	lr
700add4e: 0000         	movs	r0, r0

700add50 <UART_IsTxTrigLvlValid>:
; {
700add50: b082         	sub	sp, #0x8
700add52: 9001         	str	r0, [sp, #0x4]
700add54: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700add58: 9000         	str	r0, [sp]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700add5a: 9801         	ldr	r0, [sp, #0x4]
700add5c: 2801         	cmp	r0, #0x1
700add5e: d010         	beq	0x700add82 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x20
700add60: e7ff         	b	0x700add62 <UART_IsTxTrigLvlValid+0x12> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_8)  ||
700add62: 9801         	ldr	r0, [sp, #0x4]
700add64: 2808         	cmp	r0, #0x8
700add66: d00c         	beq	0x700add82 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x18
700add68: e7ff         	b	0x700add6a <UART_IsTxTrigLvlValid+0x1a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_16) ||
700add6a: 9801         	ldr	r0, [sp, #0x4]
700add6c: 2810         	cmp	r0, #0x10
700add6e: d008         	beq	0x700add82 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x10
700add70: e7ff         	b	0x700add72 <UART_IsTxTrigLvlValid+0x22> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_32) ||
700add72: 9801         	ldr	r0, [sp, #0x4]
700add74: 2820         	cmp	r0, #0x20
700add76: d004         	beq	0x700add82 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x8
700add78: e7ff         	b	0x700add7a <UART_IsTxTrigLvlValid+0x2a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_56)))
700add7a: 9801         	ldr	r0, [sp, #0x4]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700add7c: 2838         	cmp	r0, #0x38
700add7e: d103         	bne	0x700add88 <UART_IsTxTrigLvlValid+0x38> @ imm = #0x6
700add80: e7ff         	b	0x700add82 <UART_IsTxTrigLvlValid+0x32> @ imm = #-0x2
700add82: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700add84: 9000         	str	r0, [sp]
;     }
700add86: e7ff         	b	0x700add88 <UART_IsTxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700add88: 9800         	ldr	r0, [sp]
700add8a: b002         	add	sp, #0x8
700add8c: 4770         	bx	lr
700add8e: 0000         	movs	r0, r0

700add90 <UART_i2310WA>:
; {
700add90: b580         	push	{r7, lr}
700add92: b084         	sub	sp, #0x10
700add94: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTL, 0xFF);
700add96: 9803         	ldr	r0, [sp, #0xc]
700add98: 3098         	adds	r0, #0x98
700add9a: 21ff         	movs	r1, #0xff
700add9c: 9101         	str	r1, [sp, #0x4]
700add9e: f001 fecf    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x1d9e
700adda2: 9901         	ldr	r1, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTH, 0xFF);
700adda4: 9803         	ldr	r0, [sp, #0xc]
700adda6: 309c         	adds	r0, #0x9c
700adda8: f001 feca    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x1d94
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 1);
700addac: 9803         	ldr	r0, [sp, #0xc]
700addae: 308c         	adds	r0, #0x8c
700addb0: 2206         	movs	r2, #0x6
700addb2: 9202         	str	r2, [sp, #0x8]
700addb4: 2301         	movs	r3, #0x1
700addb6: 4611         	mov	r1, r2
700addb8: f000 fc22    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x844
700addbc: 9a02         	ldr	r2, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 0);
700addbe: 9803         	ldr	r0, [sp, #0xc]
700addc0: 308c         	adds	r0, #0x8c
700addc2: 2300         	movs	r3, #0x0
700addc4: 4611         	mov	r1, r2
700addc6: f000 fc1b    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x836
; }
700addca: b004         	add	sp, #0x10
700addcc: bd80         	pop	{r7, pc}
700addce: 0000         	movs	r0, r0

700addd0 <UART_spaceAvail>:
; {
700addd0: b580         	push	{r7, lr}
700addd2: b084         	sub	sp, #0x10
700addd4: 9003         	str	r0, [sp, #0xc]
700addd6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700addd8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700addda: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700adddc: 9803         	ldr	r0, [sp, #0xc]
700addde: 217f         	movs	r1, #0x7f
700adde0: f7fe fc2e    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #-0x17a4
700adde4: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700adde6: 9803         	ldr	r0, [sp, #0xc]
700adde8: 3014         	adds	r0, #0x14
700addea: f001 fea1    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x1d42
700addee: f000 0060    	and	r0, r0, #0x60
;     if ((UART_LSR_TX_SR_E_MASK | UART_LSR_TX_FIFO_E_MASK) ==
700addf2: 2860         	cmp	r0, #0x60
700addf4: d103         	bne	0x700addfe <UART_spaceAvail+0x2e> @ imm = #0x6
700addf6: e7ff         	b	0x700addf8 <UART_spaceAvail+0x28> @ imm = #-0x2
700addf8: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700addfa: 9001         	str	r0, [sp, #0x4]
;     }
700addfc: e7ff         	b	0x700addfe <UART_spaceAvail+0x2e> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700addfe: 9803         	ldr	r0, [sp, #0xc]
700ade00: 300c         	adds	r0, #0xc
700ade02: 9902         	ldr	r1, [sp, #0x8]
700ade04: f001 fe9c    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x1d38
;     return retVal;
700ade08: 9801         	ldr	r0, [sp, #0x4]
700ade0a: b004         	add	sp, #0x10
700ade0c: bd80         	pop	{r7, pc}
700ade0e: 0000         	movs	r0, r0

700ade10 <CSL_bcdmaSetChanPeerReg>:
; {
700ade10: b580         	push	{r7, lr}
700ade12: b088         	sub	sp, #0x20
700ade14: f8dd c028    	ldr.w	r12, [sp, #0x28]
700ade18: 9007         	str	r0, [sp, #0x1c]
700ade1a: 9106         	str	r1, [sp, #0x18]
700ade1c: 9205         	str	r2, [sp, #0x14]
700ade1e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700ade20: 9804         	ldr	r0, [sp, #0x10]
700ade22: 9001         	str	r0, [sp, #0x4]
;     remotePeerOpts.regVal = *pVal;
700ade24: 980a         	ldr	r0, [sp, #0x28]
700ade26: 6800         	ldr	r0, [r0]
700ade28: 9002         	str	r0, [sp, #0x8]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700ade2a: 9807         	ldr	r0, [sp, #0x1c]
700ade2c: 9a06         	ldr	r2, [sp, #0x18]
700ade2e: 210c         	movs	r1, #0xc
700ade30: ab01         	add	r3, sp, #0x4
700ade32: f7fc ffcd    	bl	0x700aadd0 <CSL_bcdmaDoChanOp> @ imm = #-0x3066
700ade36: 9003         	str	r0, [sp, #0xc]
;     if( retVal != CSL_PASS )
700ade38: 9803         	ldr	r0, [sp, #0xc]
700ade3a: b120         	cbz	r0, 0x700ade46 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #0x8
700ade3c: e7ff         	b	0x700ade3e <CSL_bcdmaSetChanPeerReg+0x2e> @ imm = #-0x2
700ade3e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ade42: 9003         	str	r0, [sp, #0xc]
;     }
700ade44: e7ff         	b	0x700ade46 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #-0x2
;     return retVal;
700ade46: 9803         	ldr	r0, [sp, #0xc]
700ade48: b008         	add	sp, #0x20
700ade4a: bd80         	pop	{r7, pc}
700ade4c: 0000         	movs	r0, r0
700ade4e: 0000         	movs	r0, r0

700ade50 <CSL_intaggrIsValidStatusBitNum>:
; {
700ade50: b084         	sub	sp, #0x10
700ade52: 9003         	str	r0, [sp, #0xc]
700ade54: 9102         	str	r1, [sp, #0x8]
;     uint32_t localStatusBitNum = statusBitNum;
700ade56: 9802         	ldr	r0, [sp, #0x8]
700ade58: 9000         	str	r0, [sp]
;     localStatusBitNum &= ~CSL_INTAGGR_INTR_MODE_FLAG;   /* Remove intr mode flag */
700ade5a: 9800         	ldr	r0, [sp]
700ade5c: f020 4000    	bic	r0, r0, #0x80000000
700ade60: 9000         	str	r0, [sp]
;     if( localStatusBitNum < (pCfg->virtIntrCnt << 6U) )
700ade62: 9800         	ldr	r0, [sp]
700ade64: 9903         	ldr	r1, [sp, #0xc]
700ade66: 6a49         	ldr	r1, [r1, #0x24]
700ade68: ebb0 1f81    	cmp.w	r0, r1, lsl #6
700ade6c: d204         	bhs	0x700ade78 <CSL_intaggrIsValidStatusBitNum+0x28> @ imm = #0x8
700ade6e: e7ff         	b	0x700ade70 <CSL_intaggrIsValidStatusBitNum+0x20> @ imm = #-0x2
700ade70: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700ade72: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700ade76: e003         	b	0x700ade80 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #0x6
700ade78: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700ade7a: f88d 0007    	strb.w	r0, [sp, #0x7]
700ade7e: e7ff         	b	0x700ade80 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #-0x2
;     return bRetVal;
700ade80: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ade84: f000 0001    	and	r0, r0, #0x1
700ade88: b004         	add	sp, #0x10
700ade8a: 4770         	bx	lr
700ade8c: 0000         	movs	r0, r0
700ade8e: 0000         	movs	r0, r0

700ade90 <CSL_pktdmaSetRxRT>:
; {
700ade90: b580         	push	{r7, lr}
700ade92: b084         	sub	sp, #0x10
700ade94: 9003         	str	r0, [sp, #0xc]
700ade96: 9102         	str	r1, [sp, #0x8]
700ade98: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL,
700ade9a: 9803         	ldr	r0, [sp, #0xc]
700ade9c: 6940         	ldr	r0, [r0, #0x14]
700ade9e: 9902         	ldr	r1, [sp, #0x8]
700adea0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700adea4: 9901         	ldr	r1, [sp, #0x4]
700adea6: 680b         	ldr	r3, [r1]
700adea8: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700adeac: 688a         	ldr	r2, [r1, #0x8]
700adeae: f04f 4180    	mov.w	r1, #0x40000000
700adeb2: ea01 718c    	and.w	r1, r1, r12, lsl #30
700adeb6: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700adeba: f002 0201    	and	r2, r2, #0x1
700adebe: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700adec2: f001 fde5    	bl	0x700afa90 <CSL_REG32_WR_RAW> @ imm = #0x1bca
700adec6: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700adec8: b004         	add	sp, #0x10
700adeca: bd80         	pop	{r7, pc}
700adecc: 0000         	movs	r0, r0
700adece: 0000         	movs	r0, r0

700aded0 <CSL_pktdmaSetTxRT>:
; {
700aded0: b580         	push	{r7, lr}
700aded2: b084         	sub	sp, #0x10
700aded4: 9003         	str	r0, [sp, #0xc]
700aded6: 9102         	str	r1, [sp, #0x8]
700aded8: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL,
700adeda: 9803         	ldr	r0, [sp, #0xc]
700adedc: 6900         	ldr	r0, [r0, #0x10]
700adede: 9902         	ldr	r1, [sp, #0x8]
700adee0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700adee4: 9901         	ldr	r1, [sp, #0x4]
700adee6: 680b         	ldr	r3, [r1]
700adee8: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700adeec: 688a         	ldr	r2, [r1, #0x8]
700adeee: f04f 4180    	mov.w	r1, #0x40000000
700adef2: ea01 718c    	and.w	r1, r1, r12, lsl #30
700adef6: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700adefa: f002 0201    	and	r2, r2, #0x1
700adefe: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700adf02: f001 fdc5    	bl	0x700afa90 <CSL_REG32_WR_RAW> @ imm = #0x1b8a
700adf06: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700adf08: b004         	add	sp, #0x10
700adf0a: bd80         	pop	{r7, pc}
700adf0c: 0000         	movs	r0, r0
700adf0e: 0000         	movs	r0, r0

700adf10 <Sciclient_rmIrqClearOesRegister>:
; {
700adf10: b580         	push	{r7, lr}
700adf12: b088         	sub	sp, #0x20
700adf14: 9007         	str	r0, [sp, #0x1c]
700adf16: 2010         	movs	r0, #0x10
700adf18: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700adf1c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700adf1e: 9807         	ldr	r0, [sp, #0x1c]
700adf20: 7900         	ldrb	r0, [r0, #0x4]
700adf22: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700adf26: 9807         	ldr	r0, [sp, #0x1c]
700adf28: 88c0         	ldrh	r0, [r0, #0x6]
700adf2a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700adf2e: 9807         	ldr	r0, [sp, #0x1c]
700adf30: 8900         	ldrh	r0, [r0, #0x8]
700adf32: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700adf36: 9807         	ldr	r0, [sp, #0x1c]
700adf38: 89c0         	ldrh	r0, [r0, #0xe]
700adf3a: f8ad 0018    	strh.w	r0, [sp, #0x18]
700adf3e: 4668         	mov	r0, sp
700adf40: f04f 31ff    	mov.w	r1, #0xffffffff
;     return Sciclient_rmIrqReleaseRaw(&req,
700adf44: f7fe fdac    	bl	0x700acaa0 <Sciclient_rmIrqReleaseRaw> @ imm = #-0x14a8
700adf48: b008         	add	sp, #0x20
700adf4a: bd80         	pop	{r7, pc}
700adf4c: 0000         	movs	r0, r0
700adf4e: 0000         	movs	r0, r0

700adf50 <UART_IsParityTypeValid>:
; {
700adf50: b082         	sub	sp, #0x8
700adf52: 9001         	str	r0, [sp, #0x4]
700adf54: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700adf58: 9000         	str	r0, [sp]
;     if(((parityType == UART_PARITY_NONE)    ||
700adf5a: 9801         	ldr	r0, [sp, #0x4]
700adf5c: b180         	cbz	r0, 0x700adf80 <UART_IsParityTypeValid+0x30> @ imm = #0x20
700adf5e: e7ff         	b	0x700adf60 <UART_IsParityTypeValid+0x10> @ imm = #-0x2
;         (parityType == UART_PARITY_ODD)     ||
700adf60: 9801         	ldr	r0, [sp, #0x4]
700adf62: 2801         	cmp	r0, #0x1
700adf64: d00c         	beq	0x700adf80 <UART_IsParityTypeValid+0x30> @ imm = #0x18
700adf66: e7ff         	b	0x700adf68 <UART_IsParityTypeValid+0x18> @ imm = #-0x2
;         (parityType == UART_PARITY_EVEN)    ||
700adf68: 9801         	ldr	r0, [sp, #0x4]
700adf6a: 2803         	cmp	r0, #0x3
700adf6c: d008         	beq	0x700adf80 <UART_IsParityTypeValid+0x30> @ imm = #0x10
700adf6e: e7ff         	b	0x700adf70 <UART_IsParityTypeValid+0x20> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED0) ||
700adf70: 9801         	ldr	r0, [sp, #0x4]
700adf72: 2807         	cmp	r0, #0x7
700adf74: d004         	beq	0x700adf80 <UART_IsParityTypeValid+0x30> @ imm = #0x8
700adf76: e7ff         	b	0x700adf78 <UART_IsParityTypeValid+0x28> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED1)))
700adf78: 9801         	ldr	r0, [sp, #0x4]
;     if(((parityType == UART_PARITY_NONE)    ||
700adf7a: 2805         	cmp	r0, #0x5
700adf7c: d103         	bne	0x700adf86 <UART_IsParityTypeValid+0x36> @ imm = #0x6
700adf7e: e7ff         	b	0x700adf80 <UART_IsParityTypeValid+0x30> @ imm = #-0x2
700adf80: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700adf82: 9000         	str	r0, [sp]
;     }
700adf84: e7ff         	b	0x700adf86 <UART_IsParityTypeValid+0x36> @ imm = #-0x2
;     return status;
700adf86: 9800         	ldr	r0, [sp]
700adf88: b002         	add	sp, #0x8
700adf8a: 4770         	bx	lr
700adf8c: 0000         	movs	r0, r0
700adf8e: 0000         	movs	r0, r0

700adf90 <UART_IsTxRxFifoEmpty>:
; {
700adf90: b580         	push	{r7, lr}
700adf92: b084         	sub	sp, #0x10
700adf94: 9003         	str	r0, [sp, #0xc]
700adf96: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700adf98: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700adf9a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700adf9c: 9803         	ldr	r0, [sp, #0xc]
700adf9e: 217f         	movs	r1, #0x7f
700adfa0: f7fe fb4e    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #-0x1964
700adfa4: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700adfa6: 9803         	ldr	r0, [sp, #0xc]
700adfa8: 3014         	adds	r0, #0x14
700adfaa: f001 fdc1    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x1b82
;     if (((UART_LSR_TX_FIFO_E_TX_FIFO_E_VALUE_1 << UART_LSR_TX_FIFO_E_SHIFT) |
700adfae: 0680         	lsls	r0, r0, #0x1a
700adfb0: 2800         	cmp	r0, #0x0
700adfb2: d503         	bpl	0x700adfbc <UART_IsTxRxFifoEmpty+0x2c> @ imm = #0x6
700adfb4: e7ff         	b	0x700adfb6 <UART_IsTxRxFifoEmpty+0x26> @ imm = #-0x2
700adfb6: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700adfb8: 9001         	str	r0, [sp, #0x4]
;     }
700adfba: e7ff         	b	0x700adfbc <UART_IsTxRxFifoEmpty+0x2c> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700adfbc: 9803         	ldr	r0, [sp, #0xc]
700adfbe: 300c         	adds	r0, #0xc
700adfc0: 9902         	ldr	r1, [sp, #0x8]
700adfc2: f001 fdbd    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x1b7a
;     return retVal;
700adfc6: 9801         	ldr	r0, [sp, #0x4]
700adfc8: b004         	add	sp, #0x10
700adfca: bd80         	pop	{r7, pc}
700adfcc: 0000         	movs	r0, r0
700adfce: 0000         	movs	r0, r0

700adfd0 <UART_enhanFuncEnable>:
; {
700adfd0: b580         	push	{r7, lr}
700adfd2: b084         	sub	sp, #0x10
700adfd4: 9003         	str	r0, [sp, #0xc]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700adfd6: 9803         	ldr	r0, [sp, #0xc]
700adfd8: 21bf         	movs	r1, #0xbf
700adfda: f7fe fb31    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #-0x199e
700adfde: 9001         	str	r0, [sp, #0x4]
;     enhanFnBitVal = HW_RD_REG32(baseAddr + UART_EFR) & UART_EFR_ENHANCED_EN_MASK;
700adfe0: 9803         	ldr	r0, [sp, #0xc]
700adfe2: 3008         	adds	r0, #0x8
700adfe4: f001 fda4    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x1b48
700adfe8: f000 0010    	and	r0, r0, #0x10
700adfec: 9002         	str	r0, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700adfee: 9803         	ldr	r0, [sp, #0xc]
700adff0: 3008         	adds	r0, #0x8
700adff2: 2110         	movs	r1, #0x10
700adff4: 2204         	movs	r2, #0x4
700adff6: 2301         	movs	r3, #0x1
700adff8: f000 fb02    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #0x604
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700adffc: 9803         	ldr	r0, [sp, #0xc]
700adffe: 300c         	adds	r0, #0xc
700ae000: 9901         	ldr	r1, [sp, #0x4]
700ae002: f001 fd9d    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x1b3a
;     return enhanFnBitVal;
700ae006: 9802         	ldr	r0, [sp, #0x8]
700ae008: b004         	add	sp, #0x10
700ae00a: bd80         	pop	{r7, pc}
700ae00c: 0000         	movs	r0, r0
700ae00e: 0000         	movs	r0, r0

700ae010 <UART_lld_dmaDeInit>:
; {
700ae010: b580         	push	{r7, lr}
700ae012: b084         	sub	sp, #0x10
700ae014: 9003         	str	r0, [sp, #0xc]
700ae016: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ae018: 9002         	str	r0, [sp, #0x8]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700ae01a: 9803         	ldr	r0, [sp, #0xc]
700ae01c: 6840         	ldr	r0, [r0, #0x4]
700ae01e: 6cc0         	ldr	r0, [r0, #0x4c]
700ae020: 9001         	str	r0, [sp, #0x4]
;     if (udmaChCfg->isOpen != FALSE)
700ae022: 9801         	ldr	r0, [sp, #0x4]
700ae024: 6b80         	ldr	r0, [r0, #0x38]
700ae026: b170         	cbz	r0, 0x700ae046 <UART_lld_dmaDeInit+0x36> @ imm = #0x1c
700ae028: e7ff         	b	0x700ae02a <UART_lld_dmaDeInit+0x1a> @ imm = #-0x2
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700ae02a: 9901         	ldr	r1, [sp, #0x4]
700ae02c: 6888         	ldr	r0, [r1, #0x8]
;                           udmaChCfg->cqRxEvtHandle);
700ae02e: 6909         	ldr	r1, [r1, #0x10]
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700ae030: f7f8 fbc6    	bl	0x700a67c0 <UART_udmaDeInitCh> @ imm = #-0x7874
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700ae034: 9901         	ldr	r1, [sp, #0x4]
700ae036: 6848         	ldr	r0, [r1, #0x4]
;                           udmaChCfg->cqTxEvtHandle);
700ae038: 68c9         	ldr	r1, [r1, #0xc]
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700ae03a: f7f8 fbc1    	bl	0x700a67c0 <UART_udmaDeInitCh> @ imm = #-0x787e
;         udmaChCfg->isOpen = FALSE;
700ae03e: 9901         	ldr	r1, [sp, #0x4]
700ae040: 2000         	movs	r0, #0x0
700ae042: 6388         	str	r0, [r1, #0x38]
;     }
700ae044: e7ff         	b	0x700ae046 <UART_lld_dmaDeInit+0x36> @ imm = #-0x2
;     return status;
700ae046: 9802         	ldr	r0, [sp, #0x8]
700ae048: b004         	add	sp, #0x10
700ae04a: bd80         	pop	{r7, pc}
700ae04c: 0000         	movs	r0, r0
700ae04e: 0000         	movs	r0, r0

700ae050 <prvDeleteTCB>:
; static void prvDeleteTCB(TCB_t *pxTCB) {
700ae050: b580         	push	{r7, lr}
700ae052: b082         	sub	sp, #0x8
700ae054: 9001         	str	r0, [sp, #0x4]
;   portCLEAN_UP_TCB(pxTCB);
700ae056: 9801         	ldr	r0, [sp, #0x4]
;     if (pxTCB->ucStaticallyAllocated ==
700ae058: f890 0081    	ldrb.w	r0, [r0, #0x81]
700ae05c: b940         	cbnz	r0, 0x700ae070 <prvDeleteTCB+0x20> @ imm = #0x10
700ae05e: e7ff         	b	0x700ae060 <prvDeleteTCB+0x10> @ imm = #-0x2
;       vPortFree(pxTCB->pxStack);
700ae060: 9801         	ldr	r0, [sp, #0x4]
700ae062: 6b00         	ldr	r0, [r0, #0x30]
700ae064: f001 f96c    	bl	0x700af340 <vPortFree>  @ imm = #0x12d8
;       vPortFree(pxTCB);
700ae068: 9801         	ldr	r0, [sp, #0x4]
700ae06a: f001 f969    	bl	0x700af340 <vPortFree>  @ imm = #0x12d2
;     } else if (pxTCB->ucStaticallyAllocated ==
700ae06e: e00b         	b	0x700ae088 <prvDeleteTCB+0x38> @ imm = #0x16
700ae070: 9801         	ldr	r0, [sp, #0x4]
700ae072: f890 0081    	ldrb.w	r0, [r0, #0x81]
700ae076: 2801         	cmp	r0, #0x1
700ae078: d104         	bne	0x700ae084 <prvDeleteTCB+0x34> @ imm = #0x8
700ae07a: e7ff         	b	0x700ae07c <prvDeleteTCB+0x2c> @ imm = #-0x2
;       vPortFree(pxTCB);
700ae07c: 9801         	ldr	r0, [sp, #0x4]
700ae07e: f001 f95f    	bl	0x700af340 <vPortFree>  @ imm = #0x12be
;     } else {
700ae082: e000         	b	0x700ae086 <prvDeleteTCB+0x36> @ imm = #0x0
700ae084: e7ff         	b	0x700ae086 <prvDeleteTCB+0x36> @ imm = #-0x2
700ae086: e7ff         	b	0x700ae088 <prvDeleteTCB+0x38> @ imm = #-0x2
; }
700ae088: b002         	add	sp, #0x8
700ae08a: bd80         	pop	{r7, pc}
700ae08c: 0000         	movs	r0, r0
700ae08e: 0000         	movs	r0, r0

700ae090 <prvResetNextTaskUnblockTime>:
;   if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
700ae090: f245 1028    	movw	r0, #0x5128
700ae094: f2c7 0008    	movt	r0, #0x7008
700ae098: 6800         	ldr	r0, [r0]
700ae09a: 6800         	ldr	r0, [r0]
700ae09c: b940         	cbnz	r0, 0x700ae0b0 <prvResetNextTaskUnblockTime+0x20> @ imm = #0x10
700ae09e: e7ff         	b	0x700ae0a0 <prvResetNextTaskUnblockTime+0x10> @ imm = #-0x2
;     xNextTaskUnblockTime = portMAX_DELAY;
700ae0a0: f642 2134    	movw	r1, #0x2a34
700ae0a4: f2c7 010b    	movt	r1, #0x700b
700ae0a8: f04f 30ff    	mov.w	r0, #0xffffffff
700ae0ac: 6008         	str	r0, [r1]
;   } else {
700ae0ae: e00c         	b	0x700ae0ca <prvResetNextTaskUnblockTime+0x3a> @ imm = #0x18
;     xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxDelayedTaskList);
700ae0b0: f245 1028    	movw	r0, #0x5128
700ae0b4: f2c7 0008    	movt	r0, #0x7008
700ae0b8: 6800         	ldr	r0, [r0]
700ae0ba: 68c0         	ldr	r0, [r0, #0xc]
700ae0bc: 6800         	ldr	r0, [r0]
700ae0be: f642 2134    	movw	r1, #0x2a34
700ae0c2: f2c7 010b    	movt	r1, #0x700b
700ae0c6: 6008         	str	r0, [r1]
700ae0c8: e7ff         	b	0x700ae0ca <prvResetNextTaskUnblockTime+0x3a> @ imm = #-0x2
; }
700ae0ca: 4770         	bx	lr
700ae0cc: 0000         	movs	r0, r0
700ae0ce: 0000         	movs	r0, r0

700ae0d0 <PMU_enableAllCounters>:
; static void PMU_enableAllCounters(uint32_t numCounters) {
700ae0d0: b580         	push	{r7, lr}
700ae0d2: b082         	sub	sp, #0x8
700ae0d4: 9001         	str	r0, [sp, #0x4]
700ae0d6: 2001         	movs	r0, #0x1
;   CSL_armR5PmuEnableAllCntrs(1);
700ae0d8: f7f3 ef78    	blx	0x700a1fcc <CSL_armR5PmuEnableAllCntrs> @ imm = #-0xc110
700ae0dc: 2000         	movs	r0, #0x0
;   for (i = 0; i < numCounters; i++) {
700ae0de: 9000         	str	r0, [sp]
700ae0e0: e7ff         	b	0x700ae0e2 <PMU_enableAllCounters+0x12> @ imm = #-0x2
700ae0e2: 9800         	ldr	r0, [sp]
700ae0e4: 9901         	ldr	r1, [sp, #0x4]
700ae0e6: 4288         	cmp	r0, r1
700ae0e8: d209         	bhs	0x700ae0fe <PMU_enableAllCounters+0x2e> @ imm = #0x12
700ae0ea: e7ff         	b	0x700ae0ec <PMU_enableAllCounters+0x1c> @ imm = #-0x2
;     CSL_armR5PmuEnableCntr(i, 1);
700ae0ec: 9800         	ldr	r0, [sp]
700ae0ee: 2101         	movs	r1, #0x1
700ae0f0: f7f3 efa2    	blx	0x700a2038 <CSL_armR5PmuEnableCntr> @ imm = #-0xc0bc
;   }
700ae0f4: e7ff         	b	0x700ae0f6 <PMU_enableAllCounters+0x26> @ imm = #-0x2
;   for (i = 0; i < numCounters; i++) {
700ae0f6: 9800         	ldr	r0, [sp]
700ae0f8: 3001         	adds	r0, #0x1
700ae0fa: 9000         	str	r0, [sp]
700ae0fc: e7f1         	b	0x700ae0e2 <PMU_enableAllCounters+0x12> @ imm = #-0x1e
700ae0fe: 201f         	movs	r0, #0x1f
700ae100: 2101         	movs	r1, #0x1
;   CSL_armR5PmuEnableCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM, 1);
700ae102: f7f3 ef9a    	blx	0x700a2038 <CSL_armR5PmuEnableCntr> @ imm = #-0xc0cc
; }
700ae106: b002         	add	sp, #0x8
700ae108: bd80         	pop	{r7, pc}
700ae10a: 0000         	movs	r0, r0
700ae10c: 0000         	movs	r0, r0
700ae10e: 0000         	movs	r0, r0

700ae110 <_atoi>:
; {
700ae110: b580         	push	{r7, lr}
700ae112: b082         	sub	sp, #0x8
700ae114: 9001         	str	r0, [sp, #0x4]
700ae116: 2000         	movs	r0, #0x0
;   unsigned int i = 0U;
700ae118: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700ae11a: e7ff         	b	0x700ae11c <_atoi+0xc>  @ imm = #-0x2
700ae11c: 9801         	ldr	r0, [sp, #0x4]
700ae11e: 6800         	ldr	r0, [r0]
700ae120: 7800         	ldrb	r0, [r0]
700ae122: f000 fbfd    	bl	0x700ae920 <_is_digit>  @ imm = #0x7fa
700ae126: b168         	cbz	r0, 0x700ae144 <_atoi+0x34> @ imm = #0x1a
700ae128: e7ff         	b	0x700ae12a <_atoi+0x1a> @ imm = #-0x2
;     i = i * 10U + (unsigned int)(*((*str)++) - '0');
700ae12a: 9800         	ldr	r0, [sp]
700ae12c: eb00 0180    	add.w	r1, r0, r0, lsl #2
700ae130: 9b01         	ldr	r3, [sp, #0x4]
700ae132: 6818         	ldr	r0, [r3]
700ae134: 1c42         	adds	r2, r0, #0x1
700ae136: 601a         	str	r2, [r3]
700ae138: 7800         	ldrb	r0, [r0]
700ae13a: eb00 0041    	add.w	r0, r0, r1, lsl #1
700ae13e: 3830         	subs	r0, #0x30
700ae140: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700ae142: e7eb         	b	0x700ae11c <_atoi+0xc>  @ imm = #-0x2a
;   return i;
700ae144: 9800         	ldr	r0, [sp]
700ae146: b002         	add	sp, #0x8
700ae148: bd80         	pop	{r7, pc}
700ae14a: 0000         	movs	r0, r0
700ae14c: 0000         	movs	r0, r0
700ae14e: 0000         	movs	r0, r0

700ae150 <snprintf_>:
; {
700ae150: b081         	sub	sp, #0x4
700ae152: b580         	push	{r7, lr}
700ae154: b087         	sub	sp, #0x1c
700ae156: 9309         	str	r3, [sp, #0x24]
700ae158: 9006         	str	r0, [sp, #0x18]
700ae15a: 9105         	str	r1, [sp, #0x14]
700ae15c: 9204         	str	r2, [sp, #0x10]
700ae15e: a809         	add	r0, sp, #0x24
;   va_start(va, format);
700ae160: 9003         	str	r0, [sp, #0xc]
;   const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
700ae162: 9906         	ldr	r1, [sp, #0x18]
700ae164: 9a05         	ldr	r2, [sp, #0x14]
700ae166: 9b04         	ldr	r3, [sp, #0x10]
700ae168: 9803         	ldr	r0, [sp, #0xc]
700ae16a: 46ec         	mov	r12, sp
700ae16c: f8cc 0000    	str.w	r0, [r12]
700ae170: f64e 7051    	movw	r0, #0xef51
700ae174: f2c7 000a    	movt	r0, #0x700a
700ae178: f7eb fef2    	bl	0x70099f60 <_vsnprintf> @ imm = #-0x1421c
700ae17c: 9002         	str	r0, [sp, #0x8]
;   return ret;
700ae17e: 9802         	ldr	r0, [sp, #0x8]
700ae180: b007         	add	sp, #0x1c
700ae182: e8bd 4080    	pop.w	{r7, lr}
700ae186: b001         	add	sp, #0x4
700ae188: 4770         	bx	lr
700ae18a: 0000         	movs	r0, r0
700ae18c: 0000         	movs	r0, r0
700ae18e: 0000         	movs	r0, r0

700ae190 <vListInsertEnd>:
; {
700ae190: b083         	sub	sp, #0xc
700ae192: 9002         	str	r0, [sp, #0x8]
700ae194: 9101         	str	r1, [sp, #0x4]
;     ListItem_t * const pxIndex = pxList->pxIndex;
700ae196: 9802         	ldr	r0, [sp, #0x8]
700ae198: 6840         	ldr	r0, [r0, #0x4]
700ae19a: 9000         	str	r0, [sp]
;     pxNewListItem->pxNext = pxIndex;
700ae19c: 9800         	ldr	r0, [sp]
700ae19e: 9901         	ldr	r1, [sp, #0x4]
700ae1a0: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxPrevious = pxIndex->pxPrevious;
700ae1a2: 9800         	ldr	r0, [sp]
700ae1a4: 6880         	ldr	r0, [r0, #0x8]
700ae1a6: 9901         	ldr	r1, [sp, #0x4]
700ae1a8: 6088         	str	r0, [r1, #0x8]
;     pxIndex->pxPrevious->pxNext = pxNewListItem;
700ae1aa: 9801         	ldr	r0, [sp, #0x4]
700ae1ac: 9900         	ldr	r1, [sp]
700ae1ae: 6889         	ldr	r1, [r1, #0x8]
700ae1b0: 6048         	str	r0, [r1, #0x4]
;     pxIndex->pxPrevious = pxNewListItem;
700ae1b2: 9801         	ldr	r0, [sp, #0x4]
700ae1b4: 9900         	ldr	r1, [sp]
700ae1b6: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxContainer = pxList;
700ae1b8: 9802         	ldr	r0, [sp, #0x8]
700ae1ba: 9901         	ldr	r1, [sp, #0x4]
700ae1bc: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700ae1be: 9902         	ldr	r1, [sp, #0x8]
700ae1c0: 6808         	ldr	r0, [r1]
700ae1c2: 3001         	adds	r0, #0x1
700ae1c4: 6008         	str	r0, [r1]
; }
700ae1c6: b003         	add	sp, #0xc
700ae1c8: 4770         	bx	lr
700ae1ca: 0000         	movs	r0, r0
700ae1cc: 0000         	movs	r0, r0
700ae1ce: 0000         	movs	r0, r0

700ae1d0 <CSL_REG32_FINS_RAW>:
; {
700ae1d0: b580         	push	{r7, lr}
700ae1d2: b086         	sub	sp, #0x18
700ae1d4: 9005         	str	r0, [sp, #0x14]
700ae1d6: 9104         	str	r1, [sp, #0x10]
700ae1d8: 9203         	str	r2, [sp, #0xc]
700ae1da: 9302         	str	r3, [sp, #0x8]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ae1dc: 9805         	ldr	r0, [sp, #0x14]
700ae1de: f001 fcef    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0x19de
700ae1e2: 9001         	str	r0, [sp, #0x4]
;     regVal = (regVal & ~(mask));
700ae1e4: 9801         	ldr	r0, [sp, #0x4]
700ae1e6: 9904         	ldr	r1, [sp, #0x10]
700ae1e8: 4388         	bics	r0, r1
700ae1ea: 9001         	str	r0, [sp, #0x4]
;     regVal |= (v << shift) & mask;
700ae1ec: 9802         	ldr	r0, [sp, #0x8]
700ae1ee: 9903         	ldr	r1, [sp, #0xc]
700ae1f0: 4088         	lsls	r0, r1
700ae1f2: 9904         	ldr	r1, [sp, #0x10]
700ae1f4: 4001         	ands	r1, r0
700ae1f6: 9801         	ldr	r0, [sp, #0x4]
700ae1f8: 4308         	orrs	r0, r1
700ae1fa: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR_RAW(p, regVal);
700ae1fc: 9805         	ldr	r0, [sp, #0x14]
700ae1fe: 9901         	ldr	r1, [sp, #0x4]
700ae200: f7ed ff86    	bl	0x7009c110 <CSL_REG32_WR_RAW> @ imm = #-0x120f4
;     return;
700ae204: b006         	add	sp, #0x18
700ae206: bd80         	pop	{r7, pc}
		...

700ae210 <SOC_getCoreName>:
; {
700ae210: b082         	sub	sp, #0x8
700ae212: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     if(coreId < CSL_CORE_ID_MAX)
700ae216: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae21a: 2806         	cmp	r0, #0x6
700ae21c: d80a         	bhi	0x700ae234 <SOC_getCoreName+0x24> @ imm = #0x14
700ae21e: e7ff         	b	0x700ae220 <SOC_getCoreName+0x10> @ imm = #-0x2
;         name = coreIdNames[coreId];
700ae220: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ae224: f642 007c    	movw	r0, #0x287c
700ae228: f2c7 000b    	movt	r0, #0x700b
700ae22c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ae230: 9000         	str	r0, [sp]
;     }
700ae232: e006         	b	0x700ae242 <SOC_getCoreName+0x32> @ imm = #0xc
;         name = coreIdNames[CSL_CORE_ID_MAX];
700ae234: f642 007c    	movw	r0, #0x287c
700ae238: f2c7 000b    	movt	r0, #0x700b
700ae23c: 69c0         	ldr	r0, [r0, #0x1c]
700ae23e: 9000         	str	r0, [sp]
700ae240: e7ff         	b	0x700ae242 <SOC_getCoreName+0x32> @ imm = #-0x2
;     return name;
700ae242: 9800         	ldr	r0, [sp]
700ae244: b002         	add	sp, #0x8
700ae246: 4770         	bx	lr
		...

700ae250 <Sciclient_secProxyFlush>:
; {
700ae250: b580         	push	{r7, lr}
700ae252: b082         	sub	sp, #0x8
700ae254: 9001         	str	r0, [sp, #0x4]
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ae256: e7ff         	b	0x700ae258 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2
700ae258: 9801         	ldr	r0, [sp, #0x4]
700ae25a: f001 fa01    	bl	0x700af660 <Sciclient_secProxyThreadStatusReg> @ imm = #0x1402
700ae25e: f001 fcc7    	bl	0x700afbf0 <CSL_REG32_RD_RAW> @ imm = #0x198e
700ae262: 0600         	lsls	r0, r0, #0x18
700ae264: b170         	cbz	r0, 0x700ae284 <Sciclient_secProxyFlush+0x34> @ imm = #0x1c
700ae266: e7ff         	b	0x700ae268 <Sciclient_secProxyFlush+0x18> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(thread,
700ae268: 9801         	ldr	r0, [sp, #0x4]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U)-1U));
700ae26a: f642 1148    	movw	r1, #0x2948
700ae26e: f2c7 010b    	movt	r1, #0x700b
700ae272: 694a         	ldr	r2, [r1, #0x14]
700ae274: f04f 31ff    	mov.w	r1, #0xffffffff
700ae278: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(thread,
700ae27c: b2c9         	uxtb	r1, r1
700ae27e: f000 fb1f    	bl	0x700ae8c0 <Sciclient_secProxyReadThread32> @ imm = #0x63e
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ae282: e7e9         	b	0x700ae258 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2e
;     return ;
700ae284: b002         	add	sp, #0x8
700ae286: bd80         	pop	{r7, pc}
		...

700ae290 <UART_writeDataPolling>:
; {
700ae290: b580         	push	{r7, lr}
700ae292: b082         	sub	sp, #0x8
700ae294: 9001         	str	r0, [sp, #0x4]
700ae296: 2000         	movs	r0, #0x0
;     uint32_t numBytesWritten = 0U;
700ae298: 9000         	str	r0, [sp]
;     numBytesWritten = UART_fifoWrite(hUart,
700ae29a: 9801         	ldr	r0, [sp, #0x4]
;                                      (const uint8_t *) hUart->writeBuf,
700ae29c: 6881         	ldr	r1, [r0, #0x8]
;                                      hUart->writeSizeRemaining);
700ae29e: 6902         	ldr	r2, [r0, #0x10]
;     numBytesWritten = UART_fifoWrite(hUart,
700ae2a0: f7f9 faf6    	bl	0x700a7890 <UART_fifoWrite> @ imm = #-0x6a14
700ae2a4: 9000         	str	r0, [sp]
;     hUart->writeSizeRemaining -= numBytesWritten;
700ae2a6: 9a00         	ldr	r2, [sp]
700ae2a8: 9901         	ldr	r1, [sp, #0x4]
700ae2aa: 6908         	ldr	r0, [r1, #0x10]
700ae2ac: 1a80         	subs	r0, r0, r2
700ae2ae: 6108         	str	r0, [r1, #0x10]
;     hUart->writeBuf           = (const void *)((uint8_t *)hUart->writeBuf + numBytesWritten);
700ae2b0: 9901         	ldr	r1, [sp, #0x4]
700ae2b2: 6888         	ldr	r0, [r1, #0x8]
700ae2b4: 9a00         	ldr	r2, [sp]
700ae2b6: 4410         	add	r0, r2
700ae2b8: 6088         	str	r0, [r1, #0x8]
;     hUart->writeCount         += numBytesWritten;
700ae2ba: 9a00         	ldr	r2, [sp]
700ae2bc: 9901         	ldr	r1, [sp, #0x4]
700ae2be: 68c8         	ldr	r0, [r1, #0xc]
700ae2c0: 4410         	add	r0, r2
700ae2c2: 60c8         	str	r0, [r1, #0xc]
;     return;
700ae2c4: b002         	add	sp, #0x8
700ae2c6: bd80         	pop	{r7, pc}
		...

700ae2d0 <uxTaskPriorityGet>:
; UBaseType_t uxTaskPriorityGet(const TaskHandle_t xTask) {
700ae2d0: b580         	push	{r7, lr}
700ae2d2: b084         	sub	sp, #0x10
700ae2d4: 9003         	str	r0, [sp, #0xc]
;   taskENTER_CRITICAL();
700ae2d6: f000 f9f3    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x3e6
;     pxTCB = prvGetTCBFromHandle(xTask);
700ae2da: 9803         	ldr	r0, [sp, #0xc]
700ae2dc: b938         	cbnz	r0, 0x700ae2ee <uxTaskPriorityGet+0x1e> @ imm = #0xe
700ae2de: e7ff         	b	0x700ae2e0 <uxTaskPriorityGet+0x10> @ imm = #-0x2
700ae2e0: f642 2000    	movw	r0, #0x2a00
700ae2e4: f2c7 000b    	movt	r0, #0x700b
700ae2e8: 6800         	ldr	r0, [r0]
700ae2ea: 9000         	str	r0, [sp]
700ae2ec: e002         	b	0x700ae2f4 <uxTaskPriorityGet+0x24> @ imm = #0x4
700ae2ee: 9803         	ldr	r0, [sp, #0xc]
700ae2f0: 9000         	str	r0, [sp]
700ae2f2: e7ff         	b	0x700ae2f4 <uxTaskPriorityGet+0x24> @ imm = #-0x2
700ae2f4: 9800         	ldr	r0, [sp]
700ae2f6: 9002         	str	r0, [sp, #0x8]
;     uxReturn = pxTCB->uxPriority;
700ae2f8: 9802         	ldr	r0, [sp, #0x8]
700ae2fa: 6ac0         	ldr	r0, [r0, #0x2c]
700ae2fc: 9001         	str	r0, [sp, #0x4]
;   taskEXIT_CRITICAL();
700ae2fe: f7ff fa7f    	bl	0x700ad800 <vTaskExitCritical> @ imm = #-0xb02
;   return uxReturn;
700ae302: 9801         	ldr	r0, [sp, #0x4]
700ae304: b004         	add	sp, #0x10
700ae306: bd80         	pop	{r7, pc}
		...

700ae310 <xTaskGetSchedulerState>:
; BaseType_t xTaskGetSchedulerState(void) {
700ae310: b081         	sub	sp, #0x4
;   if (xSchedulerRunning == pdFALSE) {
700ae312: f642 2040    	movw	r0, #0x2a40
700ae316: f2c7 000b    	movt	r0, #0x700b
700ae31a: 6800         	ldr	r0, [r0]
700ae31c: b918         	cbnz	r0, 0x700ae326 <xTaskGetSchedulerState+0x16> @ imm = #0x6
700ae31e: e7ff         	b	0x700ae320 <xTaskGetSchedulerState+0x10> @ imm = #-0x2
700ae320: 2001         	movs	r0, #0x1
;     xReturn = taskSCHEDULER_NOT_STARTED;
700ae322: 9000         	str	r0, [sp]
;   } else {
700ae324: e00d         	b	0x700ae342 <xTaskGetSchedulerState+0x32> @ imm = #0x1a
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700ae326: f642 2024    	movw	r0, #0x2a24
700ae32a: f2c7 000b    	movt	r0, #0x700b
700ae32e: 6800         	ldr	r0, [r0]
700ae330: b918         	cbnz	r0, 0x700ae33a <xTaskGetSchedulerState+0x2a> @ imm = #0x6
700ae332: e7ff         	b	0x700ae334 <xTaskGetSchedulerState+0x24> @ imm = #-0x2
700ae334: 2002         	movs	r0, #0x2
;       xReturn = taskSCHEDULER_RUNNING;
700ae336: 9000         	str	r0, [sp]
;     } else {
700ae338: e002         	b	0x700ae340 <xTaskGetSchedulerState+0x30> @ imm = #0x4
700ae33a: 2000         	movs	r0, #0x0
;       xReturn = taskSCHEDULER_SUSPENDED;
700ae33c: 9000         	str	r0, [sp]
700ae33e: e7ff         	b	0x700ae340 <xTaskGetSchedulerState+0x30> @ imm = #-0x2
700ae340: e7ff         	b	0x700ae342 <xTaskGetSchedulerState+0x32> @ imm = #-0x2
;   return xReturn;
700ae342: 9800         	ldr	r0, [sp]
700ae344: b001         	add	sp, #0x4
700ae346: 4770         	bx	lr
		...

700ae350 <tm_thread_create>:
; {
700ae350: b580         	push	{r7, lr}
700ae352: b082         	sub	sp, #0x8
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae354: f245 0348    	movw	r3, #0x5048
;    int new_priority = configMAX_PRIORITIES - priority + 1;
700ae358: f1c1 0c21    	rsb.w	r12, r1, #0x21
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae35c: f2c7 0308    	movt	r3, #0x7008
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ae360: f641 71a2    	movw	r1, #0x1fa2
700ae364: f2c7 010b    	movt	r1, #0x700b
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae368: eb03 0e80    	add.w	lr, r3, r0, lsl #2
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ae36c: 4610         	mov	r0, r2
700ae36e: f44f 6280    	mov.w	r2, #0x400
700ae372: 2300         	movs	r3, #0x0
700ae374: e9cd ce00    	strd	r12, lr, [sp]
700ae378: f7fa ffe2    	bl	0x700a9340 <xTaskCreate> @ imm = #-0x503c
;    if (status != pdPASS)
700ae37c: 3801         	subs	r0, #0x1
700ae37e: bf18         	it	ne
700ae380: 2001         	movne	r0, #0x1
; }
700ae382: b002         	add	sp, #0x8
700ae384: bd80         	pop	{r7, pc}
		...
700ae38e: 0000         	movs	r0, r0

700ae390 <vTaskDelay>:
; void vTaskDelay(const TickType_t xTicksToDelay) {
700ae390: b580         	push	{r7, lr}
700ae392: b082         	sub	sp, #0x8
700ae394: 9001         	str	r0, [sp, #0x4]
700ae396: 2000         	movs	r0, #0x0
;   BaseType_t xAlreadyYielded = pdFALSE;
700ae398: 9000         	str	r0, [sp]
;   if (xTicksToDelay > (TickType_t)0U) {
700ae39a: 9801         	ldr	r0, [sp, #0x4]
700ae39c: b150         	cbz	r0, 0x700ae3b4 <vTaskDelay+0x24> @ imm = #0x14
700ae39e: e7ff         	b	0x700ae3a0 <vTaskDelay+0x10> @ imm = #-0x2
;     vTaskSuspendAll();
700ae3a0: f001 fbee    	bl	0x700afb80 <vTaskSuspendAll> @ imm = #0x17dc
;       prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
700ae3a4: 9801         	ldr	r0, [sp, #0x4]
700ae3a6: 2100         	movs	r1, #0x0
700ae3a8: f7f8 f92a    	bl	0x700a6600 <prvAddCurrentTaskToDelayedList> @ imm = #-0x7dac
;     xAlreadyYielded = xTaskResumeAll();
700ae3ac: f7f3 fe98    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0xc2d0
700ae3b0: 9000         	str	r0, [sp]
;   } else {
700ae3b2: e000         	b	0x700ae3b6 <vTaskDelay+0x26> @ imm = #0x0
700ae3b4: e7ff         	b	0x700ae3b6 <vTaskDelay+0x26> @ imm = #-0x2
;   if (xAlreadyYielded == pdFALSE) {
700ae3b6: 9800         	ldr	r0, [sp]
700ae3b8: b910         	cbnz	r0, 0x700ae3c0 <vTaskDelay+0x30> @ imm = #0x4
700ae3ba: e7ff         	b	0x700ae3bc <vTaskDelay+0x2c> @ imm = #-0x2
;     portYIELD_WITHIN_API();
700ae3bc: df00         	svc	#0x0
;   } else {
700ae3be: e000         	b	0x700ae3c2 <vTaskDelay+0x32> @ imm = #0x0
700ae3c0: e7ff         	b	0x700ae3c2 <vTaskDelay+0x32> @ imm = #-0x2
; }
700ae3c2: b002         	add	sp, #0x8
700ae3c4: bd80         	pop	{r7, pc}
		...
700ae3ce: 0000         	movs	r0, r0

700ae3d0 <vTaskPlaceOnEventListRestricted>:
;                                      const BaseType_t xWaitIndefinitely) {
700ae3d0: b580         	push	{r7, lr}
700ae3d2: b084         	sub	sp, #0x10
700ae3d4: 9003         	str	r0, [sp, #0xc]
700ae3d6: 9102         	str	r1, [sp, #0x8]
700ae3d8: 9201         	str	r2, [sp, #0x4]
;   vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
700ae3da: 9803         	ldr	r0, [sp, #0xc]
700ae3dc: f642 2100    	movw	r1, #0x2a00
700ae3e0: f2c7 010b    	movt	r1, #0x700b
700ae3e4: 6809         	ldr	r1, [r1]
700ae3e6: 3118         	adds	r1, #0x18
700ae3e8: f7ff fed2    	bl	0x700ae190 <vListInsertEnd> @ imm = #-0x25c
;   if (xWaitIndefinitely != pdFALSE) {
700ae3ec: 9801         	ldr	r0, [sp, #0x4]
700ae3ee: b120         	cbz	r0, 0x700ae3fa <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #0x8
700ae3f0: e7ff         	b	0x700ae3f2 <vTaskPlaceOnEventListRestricted+0x22> @ imm = #-0x2
700ae3f2: f04f 30ff    	mov.w	r0, #0xffffffff
;     xTicksToWait = portMAX_DELAY;
700ae3f6: 9002         	str	r0, [sp, #0x8]
;   }
700ae3f8: e7ff         	b	0x700ae3fa <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #-0x2
;   prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
700ae3fa: 9802         	ldr	r0, [sp, #0x8]
700ae3fc: 9901         	ldr	r1, [sp, #0x4]
700ae3fe: f7f8 f8ff    	bl	0x700a6600 <prvAddCurrentTaskToDelayedList> @ imm = #-0x7e02
; }
700ae402: b004         	add	sp, #0x10
700ae404: bd80         	pop	{r7, pc}
		...
700ae40e: 0000         	movs	r0, r0

700ae410 <CSL_pktdmaTeardownRxChan>:
; {
700ae410: b580         	push	{r7, lr}
700ae412: b084         	sub	sp, #0x10
700ae414: 9003         	str	r0, [sp, #0xc]
700ae416: 9102         	str	r1, [sp, #0x8]
700ae418: f88d 2007    	strb.w	r2, [sp, #0x7]
700ae41c: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_RX, bForce, bWait );
700ae420: 9803         	ldr	r0, [sp, #0xc]
700ae422: 9902         	ldr	r1, [sp, #0x8]
700ae424: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ae428: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ae42c: f003 0301    	and	r3, r3, #0x1
700ae430: 46ec         	mov	r12, sp
700ae432: f8cc 3000    	str.w	r3, [r12]
700ae436: f002 0301    	and	r3, r2, #0x1
700ae43a: 2201         	movs	r2, #0x1
700ae43c: f7f6 ff98    	bl	0x700a5370 <CSL_pktdmaTeardownChan> @ imm = #-0x90d0
700ae440: b004         	add	sp, #0x10
700ae442: bd80         	pop	{r7, pc}
		...

700ae450 <CSL_pktdmaTeardownTxChan>:
; {
700ae450: b580         	push	{r7, lr}
700ae452: b084         	sub	sp, #0x10
700ae454: 9003         	str	r0, [sp, #0xc]
700ae456: 9102         	str	r1, [sp, #0x8]
700ae458: f88d 2007    	strb.w	r2, [sp, #0x7]
700ae45c: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_TX, bForce, bWait );
700ae460: 9803         	ldr	r0, [sp, #0xc]
700ae462: 9902         	ldr	r1, [sp, #0x8]
700ae464: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ae468: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ae46c: f003 0301    	and	r3, r3, #0x1
700ae470: 46ec         	mov	r12, sp
700ae472: f8cc 3000    	str.w	r3, [r12]
700ae476: f002 0301    	and	r3, r2, #0x1
700ae47a: 2200         	movs	r2, #0x0
700ae47c: f7f6 ff78    	bl	0x700a5370 <CSL_pktdmaTeardownChan> @ imm = #-0x9110
700ae480: b004         	add	sp, #0x10
700ae482: bd80         	pop	{r7, pc}
		...

700ae490 <TimerP_Params_init>:
; {
700ae490: b081         	sub	sp, #0x4
700ae492: 9000         	str	r0, [sp]
;     params->inputPreScaler = 1;
700ae494: 9800         	ldr	r0, [sp]
700ae496: 2101         	movs	r1, #0x1
700ae498: 6001         	str	r1, [r0]
;     params->inputClkHz = 25*1000000;
700ae49a: 9a00         	ldr	r2, [sp]
700ae49c: f647 0040    	movw	r0, #0x7840
700ae4a0: f2c0 107d    	movt	r0, #0x17d
700ae4a4: 6050         	str	r0, [r2, #0x4]
;     params->periodInUsec = 1000;
700ae4a6: 9a00         	ldr	r2, [sp]
700ae4a8: f44f 707a    	mov.w	r0, #0x3e8
700ae4ac: 6090         	str	r0, [r2, #0x8]
;     params->periodInNsec = 0; /* periodInUsec is used when periodInNsec is 0 */
700ae4ae: 9a00         	ldr	r2, [sp]
700ae4b0: 2000         	movs	r0, #0x0
700ae4b2: 60d0         	str	r0, [r2, #0xc]
;     params->oneshotMode = 0;
700ae4b4: 9a00         	ldr	r2, [sp]
700ae4b6: 6110         	str	r0, [r2, #0x10]
;     params->enableOverflowInt = 1;
700ae4b8: 9a00         	ldr	r2, [sp]
700ae4ba: 6151         	str	r1, [r2, #0x14]
;     params->enableDmaTrigger = 0; /* NOT USED */
700ae4bc: 9900         	ldr	r1, [sp]
700ae4be: 6188         	str	r0, [r1, #0x18]
; }
700ae4c0: b001         	add	sp, #0x4
700ae4c2: 4770         	bx	lr
		...

700ae4d0 <UART_IsDataLengthValid>:
; {
700ae4d0: b082         	sub	sp, #0x8
700ae4d2: 9001         	str	r0, [sp, #0x4]
700ae4d4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ae4d8: 9000         	str	r0, [sp]
;     if(((dataLength == UART_LEN_5) ||
700ae4da: 9801         	ldr	r0, [sp, #0x4]
700ae4dc: b160         	cbz	r0, 0x700ae4f8 <UART_IsDataLengthValid+0x28> @ imm = #0x18
700ae4de: e7ff         	b	0x700ae4e0 <UART_IsDataLengthValid+0x10> @ imm = #-0x2
;         (dataLength == UART_LEN_6) ||
700ae4e0: 9801         	ldr	r0, [sp, #0x4]
700ae4e2: 2801         	cmp	r0, #0x1
700ae4e4: d008         	beq	0x700ae4f8 <UART_IsDataLengthValid+0x28> @ imm = #0x10
700ae4e6: e7ff         	b	0x700ae4e8 <UART_IsDataLengthValid+0x18> @ imm = #-0x2
;         (dataLength == UART_LEN_7) ||
700ae4e8: 9801         	ldr	r0, [sp, #0x4]
700ae4ea: 2802         	cmp	r0, #0x2
700ae4ec: d004         	beq	0x700ae4f8 <UART_IsDataLengthValid+0x28> @ imm = #0x8
700ae4ee: e7ff         	b	0x700ae4f0 <UART_IsDataLengthValid+0x20> @ imm = #-0x2
;         (dataLength == UART_LEN_8)))
700ae4f0: 9801         	ldr	r0, [sp, #0x4]
;     if(((dataLength == UART_LEN_5) ||
700ae4f2: 2803         	cmp	r0, #0x3
700ae4f4: d103         	bne	0x700ae4fe <UART_IsDataLengthValid+0x2e> @ imm = #0x6
700ae4f6: e7ff         	b	0x700ae4f8 <UART_IsDataLengthValid+0x28> @ imm = #-0x2
700ae4f8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ae4fa: 9000         	str	r0, [sp]
;     }
700ae4fc: e7ff         	b	0x700ae4fe <UART_IsDataLengthValid+0x2e> @ imm = #-0x2
;     return status;
700ae4fe: 9800         	ldr	r0, [sp]
700ae500: b002         	add	sp, #0x8
700ae502: 4770         	bx	lr
		...

700ae510 <UART_checkTransaction>:
; {
700ae510: b082         	sub	sp, #0x8
700ae512: 9001         	str	r0, [sp, #0x4]
700ae514: 2000         	movs	r0, #0x0
;     int32_t     status = UART_TRANSFER_STATUS_SUCCESS;
700ae516: 9000         	str	r0, [sp]
;     if(0U == trans->count)
700ae518: 9801         	ldr	r0, [sp, #0x4]
700ae51a: 6840         	ldr	r0, [r0, #0x4]
700ae51c: b938         	cbnz	r0, 0x700ae52e <UART_checkTransaction+0x1e> @ imm = #0xe
700ae51e: e7ff         	b	0x700ae520 <UART_checkTransaction+0x10> @ imm = #-0x2
;         trans->status = UART_TRANSFER_STATUS_ERROR_OTH;
700ae520: 9901         	ldr	r1, [sp, #0x4]
700ae522: 200a         	movs	r0, #0xa
700ae524: 60c8         	str	r0, [r1, #0xc]
700ae526: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ae52a: 9000         	str	r0, [sp]
;     }
700ae52c: e7ff         	b	0x700ae52e <UART_checkTransaction+0x1e> @ imm = #-0x2
;     if(NULL == trans->buf)
700ae52e: 9801         	ldr	r0, [sp, #0x4]
700ae530: 6800         	ldr	r0, [r0]
700ae532: b920         	cbnz	r0, 0x700ae53e <UART_checkTransaction+0x2e> @ imm = #0x8
700ae534: e7ff         	b	0x700ae536 <UART_checkTransaction+0x26> @ imm = #-0x2
700ae536: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ae53a: 9000         	str	r0, [sp]
;     }
700ae53c: e7ff         	b	0x700ae53e <UART_checkTransaction+0x2e> @ imm = #-0x2
;     return (status);
700ae53e: 9800         	ldr	r0, [sp]
700ae540: b002         	add	sp, #0x8
700ae542: 4770         	bx	lr

700ae544 <free_list_remove>:
700ae544: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700ae574 <free_list_remove+0x30>
700ae548: e5932000     	ldr	r2, [r3]
700ae54c: e1a01003     	mov	r1, r3
700ae550: e3520000     	cmp	r2, #0
700ae554: 12823008     	addne	r3, r2, #8
700ae558: 11520000     	cmpne	r2, r0
700ae55c: 1afffff9     	bne	0x700ae548 <free_list_remove+0x4> @ imm = #-0x1c
700ae560: e3520000     	cmp	r2, #0
700ae564: 012fff1e     	bxeq	lr
700ae568: e5900008     	ldr	r0, [r0, #0x8]
700ae56c: e5810000     	str	r0, [r1]
700ae570: e12fff1e     	bx	lr
700ae574: 34 51 08 70  	.word	0x70085134
700ae578: 00 00 00 00  	.word	0x00000000
700ae57c: 00 00 00 00  	.word	0x00000000

700ae580 <vPortTimerTickHandler>:
; void vPortTimerTickHandler() {
700ae580: b580         	push	{r7, lr}
;   portENTER_CRITICAL();
700ae582: f000 f89d    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #0x13a
;   if (ulPortSchedularRunning == pdTRUE) {
700ae586: f642 2010    	movw	r0, #0x2a10
700ae58a: f2c7 000b    	movt	r0, #0x700b
700ae58e: 6800         	ldr	r0, [r0]
700ae590: 2801         	cmp	r0, #0x1
700ae592: d10c         	bne	0x700ae5ae <vPortTimerTickHandler+0x2e> @ imm = #0x18
700ae594: e7ff         	b	0x700ae596 <vPortTimerTickHandler+0x16> @ imm = #-0x2
;     if (xTaskIncrementTick() != pdFALSE) {
700ae596: f7f2 fea3    	bl	0x700a12e0 <xTaskIncrementTick> @ imm = #-0xd2ba
700ae59a: b138         	cbz	r0, 0x700ae5ac <vPortTimerTickHandler+0x2c> @ imm = #0xe
700ae59c: e7ff         	b	0x700ae59e <vPortTimerTickHandler+0x1e> @ imm = #-0x2
;       ulPortYieldRequired = pdTRUE;
700ae59e: f642 2118    	movw	r1, #0x2a18
700ae5a2: f2c7 010b    	movt	r1, #0x700b
700ae5a6: 2001         	movs	r0, #0x1
700ae5a8: 6008         	str	r0, [r1]
;     }
700ae5aa: e7ff         	b	0x700ae5ac <vPortTimerTickHandler+0x2c> @ imm = #-0x2
;   }
700ae5ac: e7ff         	b	0x700ae5ae <vPortTimerTickHandler+0x2e> @ imm = #-0x2
;   portEXIT_CRITICAL();
700ae5ae: f7ff f927    	bl	0x700ad800 <vTaskExitCritical> @ imm = #-0xdb2
; }
700ae5b2: bd80         	pop	{r7, pc}
		...

700ae5c0 <ClockP_timerTickIsr>:
; {
700ae5c0: b580         	push	{r7, lr}
700ae5c2: b082         	sub	sp, #0x8
700ae5c4: 9001         	str	r0, [sp, #0x4]
;     gClockCtrl.ticks++;
700ae5c6: f245 0110    	movw	r1, #0x5010
700ae5ca: f2c7 0108    	movt	r1, #0x7008
700ae5ce: 680a         	ldr	r2, [r1]
700ae5d0: 6848         	ldr	r0, [r1, #0x4]
700ae5d2: 3201         	adds	r2, #0x1
700ae5d4: f140 0000    	adc	r0, r0, #0x0
700ae5d8: 600a         	str	r2, [r1]
700ae5da: 6048         	str	r0, [r1, #0x4]
;     vPortTimerTickHandler();
700ae5dc: f7ff ffd0    	bl	0x700ae580 <vPortTimerTickHandler> @ imm = #-0x60
;     ClockP_timerClearOverflowInt(gClockConfig.timerBaseAddr);
700ae5e0: f642 1000    	movw	r0, #0x2900
700ae5e4: f2c7 000b    	movt	r0, #0x700b
700ae5e8: 6800         	ldr	r0, [r0]
700ae5ea: f001 fa99    	bl	0x700afb20 <ClockP_timerClearOverflowInt> @ imm = #0x1532
; }
700ae5ee: b002         	add	sp, #0x8
700ae5f0: bd80         	pop	{r7, pc}
		...
700ae5fe: 0000         	movs	r0, r0

700ae600 <HW_WR_FIELD32_RAW>:
; {
700ae600: b085         	sub	sp, #0x14
700ae602: 9004         	str	r0, [sp, #0x10]
700ae604: 9103         	str	r1, [sp, #0xc]
700ae606: 9202         	str	r2, [sp, #0x8]
700ae608: 9301         	str	r3, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700ae60a: 9804         	ldr	r0, [sp, #0x10]
700ae60c: 6800         	ldr	r0, [r0]
700ae60e: 9000         	str	r0, [sp]
;     regVal &= (~mask);
700ae610: 9903         	ldr	r1, [sp, #0xc]
700ae612: 9800         	ldr	r0, [sp]
700ae614: 4388         	bics	r0, r1
700ae616: 9000         	str	r0, [sp]
;     regVal |= (value << shift) & mask;
700ae618: 9801         	ldr	r0, [sp, #0x4]
700ae61a: 9902         	ldr	r1, [sp, #0x8]
700ae61c: 4088         	lsls	r0, r1
700ae61e: 9903         	ldr	r1, [sp, #0xc]
700ae620: 4001         	ands	r1, r0
700ae622: 9800         	ldr	r0, [sp]
700ae624: 4308         	orrs	r0, r1
700ae626: 9000         	str	r0, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = regVal;
700ae628: 9800         	ldr	r0, [sp]
700ae62a: 9904         	ldr	r1, [sp, #0x10]
700ae62c: 6008         	str	r0, [r1]
;     return;
700ae62e: b005         	add	sp, #0x14
700ae630: 4770         	bx	lr
		...
700ae63e: 0000         	movs	r0, r0

700ae640 <UART_enhanFuncBitValRestore>:
; {
700ae640: b580         	push	{r7, lr}
700ae642: b084         	sub	sp, #0x10
700ae644: 9003         	str	r0, [sp, #0xc]
700ae646: 9102         	str	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ae648: 9803         	ldr	r0, [sp, #0xc]
700ae64a: 21bf         	movs	r1, #0xbf
700ae64c: f7fd fff8    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #-0x2010
700ae650: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700ae652: 9803         	ldr	r0, [sp, #0xc]
700ae654: 3008         	adds	r0, #0x8
700ae656: 9902         	ldr	r1, [sp, #0x8]
700ae658: ea4f 1311    	lsr.w	r3, r1, #0x4
700ae65c: 2110         	movs	r1, #0x10
700ae65e: 2204         	movs	r2, #0x4
700ae660: f7ff ffce    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #-0x64
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae664: 9803         	ldr	r0, [sp, #0xc]
700ae666: 300c         	adds	r0, #0xc
700ae668: 9901         	ldr	r1, [sp, #0x4]
700ae66a: f001 fa69    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x14d2
; }
700ae66e: b004         	add	sp, #0x10
700ae670: bd80         	pop	{r7, pc}
		...
700ae67e: 0000         	movs	r0, r0

700ae680 <UART_hardwareFlowCtrlOptSet>:
; {
700ae680: b580         	push	{r7, lr}
700ae682: b084         	sub	sp, #0x10
700ae684: 9003         	str	r0, [sp, #0xc]
700ae686: 9102         	str	r1, [sp, #0x8]
700ae688: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ae68a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ae68c: 9803         	ldr	r0, [sp, #0xc]
700ae68e: 21bf         	movs	r1, #0xbf
700ae690: f7fd ffd6    	bl	0x700ac640 <UART_regConfigModeEnable> @ imm = #-0x2054
700ae694: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_HW_FLOW_CONTROL, hwFlowCtrl);
700ae696: 9803         	ldr	r0, [sp, #0xc]
700ae698: 3008         	adds	r0, #0x8
700ae69a: 9b02         	ldr	r3, [sp, #0x8]
700ae69c: 21c0         	movs	r1, #0xc0
700ae69e: 2206         	movs	r2, #0x6
700ae6a0: f7ff ffae    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #-0xa4
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae6a4: 9803         	ldr	r0, [sp, #0xc]
700ae6a6: 300c         	adds	r0, #0xc
700ae6a8: 9901         	ldr	r1, [sp, #0x4]
700ae6aa: f001 fa49    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x1492
; }
700ae6ae: b004         	add	sp, #0x10
700ae6b0: bd80         	pop	{r7, pc}
		...
700ae6be: 0000         	movs	r0, r0

700ae6c0 <vTaskEnterCritical>:
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700ae6c0: b672         	cpsid i
;   if (xSchedulerRunning != pdFALSE) {
700ae6c2: f642 2040    	movw	r0, #0x2a40
700ae6c6: f2c7 000b    	movt	r0, #0x700b
700ae6ca: 6800         	ldr	r0, [r0]
700ae6cc: b178         	cbz	r0, 0x700ae6ee <vTaskEnterCritical+0x2e> @ imm = #0x1e
700ae6ce: e7ff         	b	0x700ae6d0 <vTaskEnterCritical+0x10> @ imm = #-0x2
;     (pxCurrentTCB->uxCriticalNesting)++;
700ae6d0: f642 2000    	movw	r0, #0x2a00
700ae6d4: f2c7 000b    	movt	r0, #0x700b
700ae6d8: 6802         	ldr	r2, [r0]
700ae6da: 6d51         	ldr	r1, [r2, #0x54]
700ae6dc: 3101         	adds	r1, #0x1
700ae6de: 6551         	str	r1, [r2, #0x54]
;     if (pxCurrentTCB->uxCriticalNesting == 1) {
700ae6e0: 6800         	ldr	r0, [r0]
700ae6e2: 6d40         	ldr	r0, [r0, #0x54]
700ae6e4: 2801         	cmp	r0, #0x1
700ae6e6: d101         	bne	0x700ae6ec <vTaskEnterCritical+0x2c> @ imm = #0x2
700ae6e8: e7ff         	b	0x700ae6ea <vTaskEnterCritical+0x2a> @ imm = #-0x2
;     }
700ae6ea: e7ff         	b	0x700ae6ec <vTaskEnterCritical+0x2c> @ imm = #-0x2
;   } else {
700ae6ec: e000         	b	0x700ae6f0 <vTaskEnterCritical+0x30> @ imm = #0x0
700ae6ee: e7ff         	b	0x700ae6f0 <vTaskEnterCritical+0x30> @ imm = #-0x2
; }
700ae6f0: 4770         	bx	lr
		...
700ae6fe: 0000         	movs	r0, r0

700ae700 <xQueueCreateMutexStatic>:
;     {
700ae700: b580         	push	{r7, lr}
700ae702: b086         	sub	sp, #0x18
700ae704: f88d 0017    	strb.w	r0, [sp, #0x17]
700ae708: 9104         	str	r1, [sp, #0x10]
700ae70a: 2001         	movs	r0, #0x1
;         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
700ae70c: 9002         	str	r0, [sp, #0x8]
700ae70e: 2200         	movs	r2, #0x0
700ae710: 9201         	str	r2, [sp, #0x4]
;         ( void ) ucQueueType;
700ae712: f89d 1017    	ldrb.w	r1, [sp, #0x17]
;         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
700ae716: 9b04         	ldr	r3, [sp, #0x10]
700ae718: 46ec         	mov	r12, sp
700ae71a: f8cc 1000    	str.w	r1, [r12]
700ae71e: 4611         	mov	r1, r2
700ae720: f7fe fee6    	bl	0x700ad4f0 <xQueueGenericCreateStatic> @ imm = #-0x1234
700ae724: 9003         	str	r0, [sp, #0xc]
;         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
700ae726: 9803         	ldr	r0, [sp, #0xc]
700ae728: f000 fa32    	bl	0x700aeb90 <prvInitialiseMutex> @ imm = #0x464
;         return xNewQueue;
700ae72c: 9803         	ldr	r0, [sp, #0xc]
700ae72e: b006         	add	sp, #0x18
700ae730: bd80         	pop	{r7, pc}
		...
700ae73e: 0000         	movs	r0, r0

700ae740 <CSL_pktdmaGetChanPeerReg>:
; {
700ae740: b510         	push	{r4, lr}
700ae742: b086         	sub	sp, #0x18
700ae744: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ae748: 9005         	str	r0, [sp, #0x14]
700ae74a: 9104         	str	r1, [sp, #0x10]
700ae74c: 9203         	str	r2, [sp, #0xc]
700ae74e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)true );
700ae750: 9805         	ldr	r0, [sp, #0x14]
700ae752: 9904         	ldr	r1, [sp, #0x10]
700ae754: 9a02         	ldr	r2, [sp, #0x8]
700ae756: 9b08         	ldr	r3, [sp, #0x20]
700ae758: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ae75c: 46ee         	mov	lr, sp
700ae75e: 2401         	movs	r4, #0x1
700ae760: f8ce 4004    	str.w	r4, [lr, #0x4]
700ae764: f8ce c000    	str.w	r12, [lr]
700ae768: f7f9 f832    	bl	0x700a77d0 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6f9c
700ae76c: b006         	add	sp, #0x18
700ae76e: bd10         	pop	{r4, pc}

700ae770 <CSL_pktdmaSetChanPeerReg>:
; {
700ae770: b510         	push	{r4, lr}
700ae772: b086         	sub	sp, #0x18
700ae774: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ae778: 9005         	str	r0, [sp, #0x14]
700ae77a: 9104         	str	r1, [sp, #0x10]
700ae77c: 9203         	str	r2, [sp, #0xc]
700ae77e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)false );
700ae780: 9805         	ldr	r0, [sp, #0x14]
700ae782: 9904         	ldr	r1, [sp, #0x10]
700ae784: 9a02         	ldr	r2, [sp, #0x8]
700ae786: 9b08         	ldr	r3, [sp, #0x20]
700ae788: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ae78c: 46ee         	mov	lr, sp
700ae78e: 2400         	movs	r4, #0x0
700ae790: f8ce 4004    	str.w	r4, [lr, #0x4]
700ae794: f8ce c000    	str.w	r12, [lr]
700ae798: f7f9 f81a    	bl	0x700a77d0 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6fcc
700ae79c: b006         	add	sp, #0x18
700ae79e: bd10         	pop	{r4, pc}

700ae7a0 <UART_flowCtrlTrigLvlConfig>:
; {
700ae7a0: b580         	push	{r7, lr}
700ae7a2: b084         	sub	sp, #0x10
700ae7a4: 9003         	str	r0, [sp, #0xc]
700ae7a6: 9102         	str	r1, [sp, #0x8]
700ae7a8: 9201         	str	r2, [sp, #0x4]
700ae7aa: 2000         	movs	r0, #0x0
;     uint32_t tcrValue = 0;
700ae7ac: 9000         	str	r0, [sp]
;     tcrValue = rtsHaltFlag & UART_TCR_RX_FIFO_TRIG_HALT_MASK;
700ae7ae: 9802         	ldr	r0, [sp, #0x8]
700ae7b0: f000 000f    	and	r0, r0, #0xf
700ae7b4: 9000         	str	r0, [sp]
;     tcrValue |= (rtsStartFlag <<
700ae7b6: 9801         	ldr	r0, [sp, #0x4]
700ae7b8: 0100         	lsls	r0, r0, #0x4
;                  UART_TCR_RX_FIFO_TRIG_START_SHIFT) &
700ae7ba: b2c1         	uxtb	r1, r0
;     tcrValue |= (rtsStartFlag <<
700ae7bc: 9800         	ldr	r0, [sp]
700ae7be: 4308         	orrs	r0, r1
700ae7c0: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_TCR, tcrValue);
700ae7c2: 9803         	ldr	r0, [sp, #0xc]
700ae7c4: 3018         	adds	r0, #0x18
700ae7c6: 9900         	ldr	r1, [sp]
700ae7c8: f001 f9ba    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x1374
; }
700ae7cc: b004         	add	sp, #0x10
700ae7ce: bd80         	pop	{r7, pc}

700ae7d0 <_outc>:
700ae7d0: e5912008     	ldr	r2, [r1, #0x8]
700ae7d4: e5913004     	ldr	r3, [r1, #0x4]
700ae7d8: e1520003     	cmp	r2, r3
700ae7dc: 2a000004     	bhs	0x700ae7f4 <_outc+0x24> @ imm = #0x10
700ae7e0: e5912000     	ldr	r2, [r1]
700ae7e4: e2823001     	add	r3, r2, #1
700ae7e8: e5813000     	str	r3, [r1]
700ae7ec: e5c20000     	strb	r0, [r2]
700ae7f0: e5912008     	ldr	r2, [r1, #0x8]
700ae7f4: e2822001     	add	r2, r2, #1
700ae7f8: e5812008     	str	r2, [r1, #0x8]
700ae7fc: e12fff1e     	bx	lr

700ae800 <CycleCounterP_getCount32>:
;         MRC     p15, #0, r0, c9, c13, 0  // read PMCCNTR
700ae800: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0
;         bx      LR
700ae804: e12fff1e     	bx	lr

700ae808 <PmuP_setup>:
;         MCR     p15, #0, r0, c9, c12, 0 // write PMCR
700ae808: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;         bx      LR
700ae80c: e12fff1e     	bx	lr

700ae810 <PmuP_enableCounters>:
;         MCR     p15, #0, r0, c9, c12, 1  // write PMCNTENSET
700ae810: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;         bx      LR
700ae814: e12fff1e     	bx	lr

700ae818 <PmuP_disableCounters>:
;         MCR     p15, #0, r0, c9, c12, 2  // write PMCNTENCLR
700ae818: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2
;         bx      LR
700ae81c: e12fff1e     	bx	lr

700ae820 <PmuP_getOverflowStatus>:
;         MRC     p15, 0, r0, c9, c12, 3  // read PMOVSR
700ae820: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ae824: e12fff1e     	bx	lr

700ae828 <PmuP_clearOverflowStatus>:
;         MCR     p15, 0, r0, c9, c12, 3  // write PMOVSR
700ae828: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ae82c: e12fff1e     	bx	lr

700ae830 <CSL_secProxyGetMaxMsgSize>:
; {
700ae830: b580         	push	{r7, lr}
700ae832: b082         	sub	sp, #0x8
700ae834: 9001         	str	r0, [sp, #0x4]
;     if( pSecProxyCfg->maxMsgSize == (uint32_t)0U )
700ae836: 9801         	ldr	r0, [sp, #0x4]
700ae838: 6980         	ldr	r0, [r0, #0x18]
700ae83a: b960         	cbnz	r0, 0x700ae856 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #0x18
700ae83c: e7ff         	b	0x700ae83e <CSL_secProxyGetMaxMsgSize+0xe> @ imm = #-0x2
;         pSecProxyCfg->maxMsgSize = (uint32_t)CSL_REG32_FEXT( &pSecProxyCfg->pSecProxyRegs->CONFIG, SEC_PROXY_CONFIG_MSG_SIZE );
700ae83e: 9801         	ldr	r0, [sp, #0x4]
700ae840: 6800         	ldr	r0, [r0]
700ae842: 3004         	adds	r0, #0x4
700ae844: 2100         	movs	r1, #0x0
700ae846: f6cf 71ff    	movt	r1, #0xffff
700ae84a: 2210         	movs	r2, #0x10
700ae84c: f000 fc28    	bl	0x700af0a0 <CSL_REG32_FEXT_RAW> @ imm = #0x850
700ae850: 9901         	ldr	r1, [sp, #0x4]
700ae852: 6188         	str	r0, [r1, #0x18]
;     }
700ae854: e7ff         	b	0x700ae856 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #-0x2
;     return pSecProxyCfg->maxMsgSize;
700ae856: 9801         	ldr	r0, [sp, #0x4]
700ae858: 6980         	ldr	r0, [r0, #0x18]
700ae85a: b002         	add	sp, #0x8
700ae85c: bd80         	pop	{r7, pc}
700ae85e: 0000         	movs	r0, r0

700ae860 <Sciclient_rmIaIsIa>:
; {
700ae860: b580         	push	{r7, lr}
700ae862: b082         	sub	sp, #0x8
700ae864: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ae868: 2000         	movs	r0, #0x0
;     bool r = false;
700ae86a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIaGetInst(id) != NULL) {
700ae86e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae872: f7fd fdc5    	bl	0x700ac400 <Sciclient_rmIaGetInst> @ imm = #-0x2476
700ae876: b120         	cbz	r0, 0x700ae882 <Sciclient_rmIaIsIa+0x22> @ imm = #0x8
700ae878: e7ff         	b	0x700ae87a <Sciclient_rmIaIsIa+0x1a> @ imm = #-0x2
700ae87a: 2001         	movs	r0, #0x1
;         r = true;
700ae87c: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ae880: e7ff         	b	0x700ae882 <Sciclient_rmIaIsIa+0x22> @ imm = #-0x2
;     return r;
700ae882: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ae886: f000 0001    	and	r0, r0, #0x1
700ae88a: b002         	add	sp, #0x8
700ae88c: bd80         	pop	{r7, pc}
700ae88e: 0000         	movs	r0, r0

700ae890 <Sciclient_rmIrIsIr>:
; {
700ae890: b580         	push	{r7, lr}
700ae892: b082         	sub	sp, #0x8
700ae894: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ae898: 2000         	movs	r0, #0x0
;     bool r = false;
700ae89a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIrGetInst(id) != NULL) {
700ae89e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae8a2: f7fd f8c5    	bl	0x700aba30 <Sciclient_rmIrGetInst> @ imm = #-0x2e76
700ae8a6: b120         	cbz	r0, 0x700ae8b2 <Sciclient_rmIrIsIr+0x22> @ imm = #0x8
700ae8a8: e7ff         	b	0x700ae8aa <Sciclient_rmIrIsIr+0x1a> @ imm = #-0x2
700ae8aa: 2001         	movs	r0, #0x1
;         r = true;
700ae8ac: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ae8b0: e7ff         	b	0x700ae8b2 <Sciclient_rmIrIsIr+0x22> @ imm = #-0x2
;     return r;
700ae8b2: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ae8b6: f000 0001    	and	r0, r0, #0x1
700ae8ba: b002         	add	sp, #0x8
700ae8bc: bd80         	pop	{r7, pc}
700ae8be: 0000         	movs	r0, r0

700ae8c0 <Sciclient_secProxyReadThread32>:
; {
700ae8c0: b580         	push	{r7, lr}
700ae8c2: b084         	sub	sp, #0x10
700ae8c4: 9003         	str	r0, [sp, #0xc]
700ae8c6: f88d 100b    	strb.w	r1, [sp, #0xb]
;     ret = CSL_REG32_RD(CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg,thread,0U) +
700ae8ca: 9903         	ldr	r1, [sp, #0xc]
700ae8cc: f642 00c0    	movw	r0, #0x28c0
700ae8d0: f2c7 000b    	movt	r0, #0x700b
700ae8d4: 2200         	movs	r2, #0x0
700ae8d6: f000 fe13    	bl	0x700af500 <CSL_secProxyGetDataAddr> @ imm = #0xc26
700ae8da: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700ae8de: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ae8e2: f001 f985    	bl	0x700afbf0 <CSL_REG32_RD_RAW> @ imm = #0x130a
700ae8e6: 9001         	str	r0, [sp, #0x4]
;     return ret;
700ae8e8: 9801         	ldr	r0, [sp, #0x4]
700ae8ea: b004         	add	sp, #0x10
700ae8ec: bd80         	pop	{r7, pc}
700ae8ee: 0000         	movs	r0, r0

700ae8f0 <System_init>:
; {
700ae8f0: b580         	push	{r7, lr}
;     Dpl_init();
700ae8f2: f7fe ff35    	bl	0x700ad760 <Dpl_init>   @ imm = #-0x1196
;         retVal = Sciclient_init(CSL_CORE_ID_R5FSS0_0);
700ae8f6: 2001         	movs	r0, #0x1
700ae8f8: f7fa fdc2    	bl	0x700a9480 <Sciclient_init> @ imm = #-0x547c
;         DebugP_assertNoLog(SystemP_SUCCESS == retVal);
700ae8fc: fab0 f080    	clz	r0, r0
700ae900: 0940         	lsrs	r0, r0, #0x5
700ae902: f002 fccd    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x299a
;     CycleCounterP_init(SOC_getSelfCpuClk());
700ae906: f000 fbfb    	bl	0x700af100 <SOC_getSelfCpuClk> @ imm = #0x7f6
700ae90a: f7f9 fd01    	bl	0x700a8310 <CycleCounterP_init> @ imm = #-0x65fe
;     PowerClock_init();
700ae90e: f7fb fdf7    	bl	0x700aa500 <PowerClock_init> @ imm = #-0x4412
;     Pinmux_init();
700ae912: f000 fc65    	bl	0x700af1e0 <Pinmux_init> @ imm = #0x8ca
;     UART_init();
700ae916: e8bd 4080    	pop.w	{r7, lr}
700ae91a: f7f9 b8d9    	b.w	0x700a7ad0 <UART_init>  @ imm = #-0x6e4e
700ae91e: 0000         	movs	r0, r0

700ae920 <_is_digit>:
; {
700ae920: b082         	sub	sp, #0x8
700ae922: f88d 0007    	strb.w	r0, [sp, #0x7]
;   return (ch >= '0') && (ch <= '9');
700ae926: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ae92a: 2000         	movs	r0, #0x0
700ae92c: 2930         	cmp	r1, #0x30
700ae92e: 9000         	str	r0, [sp]
700ae930: db08         	blt	0x700ae944 <_is_digit+0x24> @ imm = #0x10
700ae932: e7ff         	b	0x700ae934 <_is_digit+0x14> @ imm = #-0x2
700ae934: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ae938: 2000         	movs	r0, #0x0
700ae93a: 293a         	cmp	r1, #0x3a
700ae93c: bfb8         	it	lt
700ae93e: 2001         	movlt	r0, #0x1
700ae940: 9000         	str	r0, [sp]
700ae942: e7ff         	b	0x700ae944 <_is_digit+0x24> @ imm = #-0x2
700ae944: 9800         	ldr	r0, [sp]
;   return (ch >= '0') && (ch <= '9');
700ae946: f000 0001    	and	r0, r0, #0x1
700ae94a: b002         	add	sp, #0x8
700ae94c: 4770         	bx	lr
700ae94e: 0000         	movs	r0, r0

700ae950 <prvIsQueueFull>:
; {
700ae950: b580         	push	{r7, lr}
700ae952: b082         	sub	sp, #0x8
700ae954: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700ae956: f7ff feb3    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #-0x29a
;         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
700ae95a: 9801         	ldr	r0, [sp, #0x4]
700ae95c: 6b80         	ldr	r0, [r0, #0x38]
700ae95e: 9901         	ldr	r1, [sp, #0x4]
700ae960: 6bc9         	ldr	r1, [r1, #0x3c]
700ae962: 4288         	cmp	r0, r1
700ae964: d103         	bne	0x700ae96e <prvIsQueueFull+0x1e> @ imm = #0x6
700ae966: e7ff         	b	0x700ae968 <prvIsQueueFull+0x18> @ imm = #-0x2
700ae968: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700ae96a: 9000         	str	r0, [sp]
;         }
700ae96c: e002         	b	0x700ae974 <prvIsQueueFull+0x24> @ imm = #0x4
700ae96e: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700ae970: 9000         	str	r0, [sp]
700ae972: e7ff         	b	0x700ae974 <prvIsQueueFull+0x24> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700ae974: f7fe ff44    	bl	0x700ad800 <vTaskExitCritical> @ imm = #-0x1178
;     return xReturn;
700ae978: 9800         	ldr	r0, [sp]
700ae97a: b002         	add	sp, #0x8
700ae97c: bd80         	pop	{r7, pc}
700ae97e: 0000         	movs	r0, r0

700ae980 <prvTaskCheckFreeStackSpace>:
; prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte) {
700ae980: b082         	sub	sp, #0x8
700ae982: 9001         	str	r0, [sp, #0x4]
700ae984: 2000         	movs	r0, #0x0
;   uint32_t ulCount = 0U;
700ae986: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700ae988: e7ff         	b	0x700ae98a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x2
700ae98a: 9801         	ldr	r0, [sp, #0x4]
700ae98c: 7800         	ldrb	r0, [r0]
700ae98e: 28a5         	cmp	r0, #0xa5
700ae990: d107         	bne	0x700ae9a2 <prvTaskCheckFreeStackSpace+0x22> @ imm = #0xe
700ae992: e7ff         	b	0x700ae994 <prvTaskCheckFreeStackSpace+0x14> @ imm = #-0x2
;     pucStackByte -= portSTACK_GROWTH;
700ae994: 9801         	ldr	r0, [sp, #0x4]
700ae996: 3001         	adds	r0, #0x1
700ae998: 9001         	str	r0, [sp, #0x4]
;     ulCount++;
700ae99a: 9800         	ldr	r0, [sp]
700ae99c: 3001         	adds	r0, #0x1
700ae99e: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700ae9a0: e7f3         	b	0x700ae98a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x1a
;   ulCount /=
700ae9a2: 9800         	ldr	r0, [sp]
700ae9a4: 0880         	lsrs	r0, r0, #0x2
700ae9a6: 9000         	str	r0, [sp]
;   return (configSTACK_DEPTH_TYPE)ulCount;
700ae9a8: 9800         	ldr	r0, [sp]
700ae9aa: b002         	add	sp, #0x8
700ae9ac: 4770         	bx	lr
700ae9ae: 0000         	movs	r0, r0

700ae9b0 <tm_queue_send_from_isr>:
; {
700ae9b0: b580         	push	{r7, lr}
700ae9b2: b082         	sub	sp, #0x8
;    status = xQueueSendToBackFromISR(tm_queue_array[queue_id], (const void*) message_ptr, &xHigherPriorityTaskWoken);
700ae9b4: f245 123c    	movw	r2, #0x513c
700ae9b8: 2300         	movs	r3, #0x0
700ae9ba: f2c7 0208    	movt	r2, #0x7008
700ae9be: f852 0020    	ldr.w	r0, [r2, r0, lsl #2]
700ae9c2: aa01         	add	r2, sp, #0x4
;    status = xQueueSendToBackFromISR(tm_queue_array[queue_id], (const void*) message_ptr, &xHigherPriorityTaskWoken);
700ae9c4: f7f9 ff5c    	bl	0x700a8880 <xQueueGenericSendFromISR> @ imm = #-0x6148
;    if (status != pdTRUE)
700ae9c8: 2801         	cmp	r0, #0x1
700ae9ca: d105         	bne	0x700ae9d8 <tm_queue_send_from_isr+0x28> @ imm = #0xa
;    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
700ae9cc: 9801         	ldr	r0, [sp, #0x4]
700ae9ce: f000 fdd7    	bl	0x700af580 <vPortYeildFromISR> @ imm = #0xbae
700ae9d2: 2000         	movs	r0, #0x0
; }
700ae9d4: b002         	add	sp, #0x8
700ae9d6: bd80         	pop	{r7, pc}
700ae9d8: 2001         	movs	r0, #0x1
; }
700ae9da: b002         	add	sp, #0x8
700ae9dc: bd80         	pop	{r7, pc}
700ae9de: 0000         	movs	r0, r0

700ae9e0 <vListInitialise>:
; {
700ae9e0: b081         	sub	sp, #0x4
700ae9e2: 9000         	str	r0, [sp]
;     pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ae9e4: 9900         	ldr	r1, [sp]
700ae9e6: f101 0008    	add.w	r0, r1, #0x8
700ae9ea: 6048         	str	r0, [r1, #0x4]
;     pxList->xListEnd.xItemValue = portMAX_DELAY;
700ae9ec: 9900         	ldr	r1, [sp]
700ae9ee: f04f 30ff    	mov.w	r0, #0xffffffff
700ae9f2: 6088         	str	r0, [r1, #0x8]
;     pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ae9f4: 9900         	ldr	r1, [sp]
700ae9f6: f101 0008    	add.w	r0, r1, #0x8
700ae9fa: 60c8         	str	r0, [r1, #0xc]
;     pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ae9fc: 9900         	ldr	r1, [sp]
700ae9fe: f101 0008    	add.w	r0, r1, #0x8
700aea02: 6108         	str	r0, [r1, #0x10]
;     pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
700aea04: 9900         	ldr	r1, [sp]
700aea06: 2000         	movs	r0, #0x0
700aea08: 6008         	str	r0, [r1]
; }
700aea0a: b001         	add	sp, #0x4
700aea0c: 4770         	bx	lr
700aea0e: 0000         	movs	r0, r0

700aea10 <CSL_bcdmaGetRxRT>:
; {
700aea10: b580         	push	{r7, lr}
700aea12: b084         	sub	sp, #0x10
700aea14: 9003         	str	r0, [sp, #0xc]
700aea16: 9102         	str	r1, [sp, #0x8]
700aea18: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700aea1a: 9803         	ldr	r0, [sp, #0xc]
700aea1c: 9a02         	ldr	r2, [sp, #0x8]
700aea1e: 9b01         	ldr	r3, [sp, #0x4]
700aea20: 2107         	movs	r1, #0x7
700aea22: f7fc f9d5    	bl	0x700aadd0 <CSL_bcdmaDoChanOp> @ imm = #-0x3c56
700aea26: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aea28: 9800         	ldr	r0, [sp]
700aea2a: b120         	cbz	r0, 0x700aea36 <CSL_bcdmaGetRxRT+0x26> @ imm = #0x8
700aea2c: e7ff         	b	0x700aea2e <CSL_bcdmaGetRxRT+0x1e> @ imm = #-0x2
700aea2e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aea32: 9000         	str	r0, [sp]
;     }
700aea34: e7ff         	b	0x700aea36 <CSL_bcdmaGetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700aea36: 9800         	ldr	r0, [sp]
700aea38: b004         	add	sp, #0x10
700aea3a: bd80         	pop	{r7, pc}
700aea3c: 0000         	movs	r0, r0
700aea3e: 0000         	movs	r0, r0

700aea40 <CSL_bcdmaGetTxRT>:
; {
700aea40: b580         	push	{r7, lr}
700aea42: b084         	sub	sp, #0x10
700aea44: 9003         	str	r0, [sp, #0xc]
700aea46: 9102         	str	r1, [sp, #0x8]
700aea48: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700aea4a: 9803         	ldr	r0, [sp, #0xc]
700aea4c: 9a02         	ldr	r2, [sp, #0x8]
700aea4e: 9b01         	ldr	r3, [sp, #0x4]
700aea50: 2107         	movs	r1, #0x7
700aea52: f7fc f9bd    	bl	0x700aadd0 <CSL_bcdmaDoChanOp> @ imm = #-0x3c86
700aea56: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aea58: 9800         	ldr	r0, [sp]
700aea5a: b120         	cbz	r0, 0x700aea66 <CSL_bcdmaGetTxRT+0x26> @ imm = #0x8
700aea5c: e7ff         	b	0x700aea5e <CSL_bcdmaGetTxRT+0x1e> @ imm = #-0x2
700aea5e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aea62: 9000         	str	r0, [sp]
;     }
700aea64: e7ff         	b	0x700aea66 <CSL_bcdmaGetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700aea66: 9800         	ldr	r0, [sp]
700aea68: b004         	add	sp, #0x10
700aea6a: bd80         	pop	{r7, pc}
700aea6c: 0000         	movs	r0, r0
700aea6e: 0000         	movs	r0, r0

700aea70 <CSL_bcdmaSetRxRT>:
; {
700aea70: b580         	push	{r7, lr}
700aea72: b084         	sub	sp, #0x10
700aea74: 9003         	str	r0, [sp, #0xc]
700aea76: 9102         	str	r1, [sp, #0x8]
700aea78: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700aea7a: 9803         	ldr	r0, [sp, #0xc]
700aea7c: 9a02         	ldr	r2, [sp, #0x8]
700aea7e: 9b01         	ldr	r3, [sp, #0x4]
700aea80: 2108         	movs	r1, #0x8
700aea82: f7fc f9a5    	bl	0x700aadd0 <CSL_bcdmaDoChanOp> @ imm = #-0x3cb6
700aea86: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aea88: 9800         	ldr	r0, [sp]
700aea8a: b120         	cbz	r0, 0x700aea96 <CSL_bcdmaSetRxRT+0x26> @ imm = #0x8
700aea8c: e7ff         	b	0x700aea8e <CSL_bcdmaSetRxRT+0x1e> @ imm = #-0x2
700aea8e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aea92: 9000         	str	r0, [sp]
;     }
700aea94: e7ff         	b	0x700aea96 <CSL_bcdmaSetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700aea96: 9800         	ldr	r0, [sp]
700aea98: b004         	add	sp, #0x10
700aea9a: bd80         	pop	{r7, pc}
700aea9c: 0000         	movs	r0, r0
700aea9e: 0000         	movs	r0, r0

700aeaa0 <CSL_bcdmaSetTxRT>:
; {
700aeaa0: b580         	push	{r7, lr}
700aeaa2: b084         	sub	sp, #0x10
700aeaa4: 9003         	str	r0, [sp, #0xc]
700aeaa6: 9102         	str	r1, [sp, #0x8]
700aeaa8: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700aeaaa: 9803         	ldr	r0, [sp, #0xc]
700aeaac: 9a02         	ldr	r2, [sp, #0x8]
700aeaae: 9b01         	ldr	r3, [sp, #0x4]
700aeab0: 2108         	movs	r1, #0x8
700aeab2: f7fc f98d    	bl	0x700aadd0 <CSL_bcdmaDoChanOp> @ imm = #-0x3ce6
700aeab6: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aeab8: 9800         	ldr	r0, [sp]
700aeaba: b120         	cbz	r0, 0x700aeac6 <CSL_bcdmaSetTxRT+0x26> @ imm = #0x8
700aeabc: e7ff         	b	0x700aeabe <CSL_bcdmaSetTxRT+0x1e> @ imm = #-0x2
700aeabe: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aeac2: 9000         	str	r0, [sp]
;     }
700aeac4: e7ff         	b	0x700aeac6 <CSL_bcdmaSetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700aeac6: 9800         	ldr	r0, [sp]
700aeac8: b004         	add	sp, #0x10
700aeaca: bd80         	pop	{r7, pc}
700aeacc: 0000         	movs	r0, r0
700aeace: 0000         	movs	r0, r0

700aead0 <DebugP_logZoneEnable>:
; {
700aead0: b580         	push	{r7, lr}
700aead2: b084         	sub	sp, #0x10
700aead4: 9003         	str	r0, [sp, #0xc]
;     oldIntState = HwiP_disable();
700aead6: f001 ef24    	blx	0x700b0920 <HwiP_disable> @ imm = #0x1e48
700aeada: 9001         	str	r0, [sp, #0x4]
;     oldZoneMask = gDebugLogZone;
700aeadc: f642 11d0    	movw	r1, #0x29d0
700aeae0: f2c7 010b    	movt	r1, #0x700b
700aeae4: 6808         	ldr	r0, [r1]
700aeae6: 9002         	str	r0, [sp, #0x8]
;     gDebugLogZone = gDebugLogZone | (logZoneMask);
700aeae8: 6808         	ldr	r0, [r1]
700aeaea: 9a03         	ldr	r2, [sp, #0xc]
700aeaec: 4310         	orrs	r0, r2
700aeaee: 6008         	str	r0, [r1]
;     HwiP_restore(oldIntState);
700aeaf0: 9801         	ldr	r0, [sp, #0x4]
700aeaf2: f001 ef36    	blx	0x700b0960 <HwiP_restore> @ imm = #0x1e6c
;     return oldZoneMask;
700aeaf6: 9802         	ldr	r0, [sp, #0x8]
700aeaf8: b004         	add	sp, #0x10
700aeafa: bd80         	pop	{r7, pc}
700aeafc: 0000         	movs	r0, r0
700aeafe: 0000         	movs	r0, r0

700aeb00 <Sciclient_getIrAddr>:
; {
700aeb00: b580         	push	{r7, lr}
700aeb02: b084         	sub	sp, #0x10
700aeb04: 9003         	str	r0, [sp, #0xc]
700aeb06: 9102         	str	r1, [sp, #0x8]
;     int_ctrl_reg = (uint32_t *)(addr + Sciclient_rmIrIntControlReg(i));
700aeb08: 9803         	ldr	r0, [sp, #0xc]
700aeb0a: 9000         	str	r0, [sp]
700aeb0c: f8bd 0008    	ldrh.w	r0, [sp, #0x8]
700aeb10: f000 ff0e    	bl	0x700af930 <Sciclient_rmIrIntControlReg> @ imm = #0xe1c
700aeb14: 4601         	mov	r1, r0
700aeb16: 9800         	ldr	r0, [sp]
700aeb18: 4408         	add	r0, r1
700aeb1a: 9001         	str	r0, [sp, #0x4]
;     int_ctrl_reg = (uint32_t *)AddrTranslateP_getLocalAddr( (uint64_t)int_ctrl_reg);
700aeb1c: 9801         	ldr	r0, [sp, #0x4]
700aeb1e: 2100         	movs	r1, #0x0
700aeb20: f7f6 ff9e    	bl	0x700a5a60 <AddrTranslateP_getLocalAddr> @ imm = #-0x90c4
700aeb24: 9001         	str	r0, [sp, #0x4]
;     return int_ctrl_reg;
700aeb26: 9801         	ldr	r0, [sp, #0x4]
700aeb28: b004         	add	sp, #0x10
700aeb2a: bd80         	pop	{r7, pc}
700aeb2c: 0000         	movs	r0, r0
700aeb2e: 0000         	movs	r0, r0

700aeb30 <TaskP_calcCounterDiff>:
; {
700aeb30: b083         	sub	sp, #0xc
700aeb32: 9002         	str	r0, [sp, #0x8]
700aeb34: 9101         	str	r1, [sp, #0x4]
;     if(cur >= last)
700aeb36: 9802         	ldr	r0, [sp, #0x8]
700aeb38: 9901         	ldr	r1, [sp, #0x4]
700aeb3a: 4288         	cmp	r0, r1
700aeb3c: d305         	blo	0x700aeb4a <TaskP_calcCounterDiff+0x1a> @ imm = #0xa
700aeb3e: e7ff         	b	0x700aeb40 <TaskP_calcCounterDiff+0x10> @ imm = #-0x2
;         delta = cur - last;
700aeb40: 9802         	ldr	r0, [sp, #0x8]
700aeb42: 9901         	ldr	r1, [sp, #0x4]
700aeb44: 1a40         	subs	r0, r0, r1
700aeb46: 9000         	str	r0, [sp]
;     }
700aeb48: e005         	b	0x700aeb56 <TaskP_calcCounterDiff+0x26> @ imm = #0xa
;         delta = (  0xFFFFFFFFU - last ) + cur;
700aeb4a: 9801         	ldr	r0, [sp, #0x4]
700aeb4c: 9902         	ldr	r1, [sp, #0x8]
700aeb4e: 43c0         	mvns	r0, r0
700aeb50: 4408         	add	r0, r1
700aeb52: 9000         	str	r0, [sp]
700aeb54: e7ff         	b	0x700aeb56 <TaskP_calcCounterDiff+0x26> @ imm = #-0x2
;     return delta;
700aeb56: 9800         	ldr	r0, [sp]
700aeb58: b003         	add	sp, #0xc
700aeb5a: 4770         	bx	lr
700aeb5c: 0000         	movs	r0, r0
700aeb5e: 0000         	movs	r0, r0

700aeb60 <TimerP_clearOverflowInt>:
; {
700aeb60: b083         	sub	sp, #0xc
700aeb62: 9002         	str	r0, [sp, #0x8]
700aeb64: 2002         	movs	r0, #0x2
;     uint32_t value = (0x1U << TIMER_OVF_INT_SHIFT);
700aeb66: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_STATUS);
700aeb68: 9802         	ldr	r0, [sp, #0x8]
700aeb6a: 3028         	adds	r0, #0x28
700aeb6c: 9001         	str	r0, [sp, #0x4]
;     *addr = value;
700aeb6e: 9800         	ldr	r0, [sp]
700aeb70: 9901         	ldr	r1, [sp, #0x4]
700aeb72: 6008         	str	r0, [r1]
;     if((*addr & value) != 0U)
700aeb74: 9801         	ldr	r0, [sp, #0x4]
700aeb76: 6800         	ldr	r0, [r0]
700aeb78: 9900         	ldr	r1, [sp]
700aeb7a: 4208         	tst	r0, r1
700aeb7c: d004         	beq	0x700aeb88 <TimerP_clearOverflowInt+0x28> @ imm = #0x8
700aeb7e: e7ff         	b	0x700aeb80 <TimerP_clearOverflowInt+0x20> @ imm = #-0x2
;         *addr = value;
700aeb80: 9800         	ldr	r0, [sp]
700aeb82: 9901         	ldr	r1, [sp, #0x4]
700aeb84: 6008         	str	r0, [r1]
;     }
700aeb86: e7ff         	b	0x700aeb88 <TimerP_clearOverflowInt+0x28> @ imm = #-0x2
; }
700aeb88: b003         	add	sp, #0xc
700aeb8a: 4770         	bx	lr
700aeb8c: 0000         	movs	r0, r0
700aeb8e: 0000         	movs	r0, r0

700aeb90 <prvInitialiseMutex>:
;     {
700aeb90: b580         	push	{r7, lr}
700aeb92: b082         	sub	sp, #0x8
700aeb94: 9001         	str	r0, [sp, #0x4]
;         if( pxNewQueue != NULL )
700aeb96: 9801         	ldr	r0, [sp, #0x4]
700aeb98: b168         	cbz	r0, 0x700aebb6 <prvInitialiseMutex+0x26> @ imm = #0x1a
700aeb9a: e7ff         	b	0x700aeb9c <prvInitialiseMutex+0xc> @ imm = #-0x2
;             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
700aeb9c: 9801         	ldr	r0, [sp, #0x4]
700aeb9e: 2300         	movs	r3, #0x0
700aeba0: 6083         	str	r3, [r0, #0x8]
;             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
700aeba2: 9801         	ldr	r0, [sp, #0x4]
700aeba4: 6003         	str	r3, [r0]
;             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
700aeba6: 9801         	ldr	r0, [sp, #0x4]
700aeba8: 60c3         	str	r3, [r0, #0xc]
;             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
700aebaa: 9801         	ldr	r0, [sp, #0x4]
700aebac: 4619         	mov	r1, r3
700aebae: 461a         	mov	r2, r3
700aebb0: f7f4 fac6    	bl	0x700a3140 <xQueueGenericSend> @ imm = #-0xba74
;         }
700aebb4: e000         	b	0x700aebb8 <prvInitialiseMutex+0x28> @ imm = #0x0
700aebb6: e7ff         	b	0x700aebb8 <prvInitialiseMutex+0x28> @ imm = #-0x2
;     }
700aebb8: b002         	add	sp, #0x8
700aebba: bd80         	pop	{r7, pc}
700aebbc: 0000         	movs	r0, r0
700aebbe: 0000         	movs	r0, r0

700aebc0 <pvTaskIncrementMutexHeldCount>:
;   if (pxCurrentTCB != NULL) {
700aebc0: f642 2000    	movw	r0, #0x2a00
700aebc4: f2c7 000b    	movt	r0, #0x700b
700aebc8: 6800         	ldr	r0, [r0]
700aebca: b148         	cbz	r0, 0x700aebe0 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #0x12
700aebcc: e7ff         	b	0x700aebce <pvTaskIncrementMutexHeldCount+0xe> @ imm = #-0x2
;     (pxCurrentTCB->uxMutexesHeld)++;
700aebce: f642 2000    	movw	r0, #0x2a00
700aebd2: f2c7 000b    	movt	r0, #0x700b
700aebd6: 6801         	ldr	r1, [r0]
700aebd8: 6e48         	ldr	r0, [r1, #0x64]
700aebda: 3001         	adds	r0, #0x1
700aebdc: 6648         	str	r0, [r1, #0x64]
;   }
700aebde: e7ff         	b	0x700aebe0 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #-0x2
;   return pxCurrentTCB;
700aebe0: f642 2000    	movw	r0, #0x2a00
700aebe4: f2c7 000b    	movt	r0, #0x700b
700aebe8: 6800         	ldr	r0, [r0]
700aebea: 4770         	bx	lr
700aebec: 0000         	movs	r0, r0
700aebee: 0000         	movs	r0, r0

700aebf0 <vApplicationGetIdleTaskMemory>:
;                                    uint32_t *pulIdleTaskStackSize) {
700aebf0: b083         	sub	sp, #0xc
700aebf2: 9002         	str	r0, [sp, #0x8]
700aebf4: 9101         	str	r1, [sp, #0x4]
700aebf6: 9200         	str	r2, [sp]
;   *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
700aebf8: 9902         	ldr	r1, [sp, #0x8]
700aebfa: f644 50b0    	movw	r0, #0x4db0
700aebfe: f2c7 0008    	movt	r0, #0x7008
700aec02: 6008         	str	r0, [r1]
;   *ppxIdleTaskStackBuffer = uxIdleTaskStack;
700aec04: 9901         	ldr	r1, [sp, #0x4]
700aec06: f242 0080    	movw	r0, #0x2080
700aec0a: f2c7 0008    	movt	r0, #0x7008
700aec0e: 6008         	str	r0, [r1]
;   *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
700aec10: 9900         	ldr	r1, [sp]
700aec12: f44f 6080    	mov.w	r0, #0x400
700aec16: 6008         	str	r0, [r1]
; }
700aec18: b003         	add	sp, #0xc
700aec1a: 4770         	bx	lr
700aec1c: 0000         	movs	r0, r0
700aec1e: 0000         	movs	r0, r0

700aec20 <vApplicationGetTimerTaskMemory>:
;                                     uint32_t *pulTimerTaskStackSize) {
700aec20: b083         	sub	sp, #0xc
700aec22: 9002         	str	r0, [sp, #0x8]
700aec24: 9101         	str	r1, [sp, #0x4]
700aec26: 9200         	str	r2, [sp]
;   *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
700aec28: 9902         	ldr	r1, [sp, #0x8]
700aec2a: f644 6038    	movw	r0, #0x4e38
700aec2e: f2c7 0008    	movt	r0, #0x7008
700aec32: 6008         	str	r0, [r1]
;   *ppxTimerTaskStackBuffer = uxTimerTaskStack;
700aec34: 9901         	ldr	r1, [sp, #0x4]
700aec36: f643 508c    	movw	r0, #0x3d8c
700aec3a: f2c7 0008    	movt	r0, #0x7008
700aec3e: 6008         	str	r0, [r1]
;   *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
700aec40: 9900         	ldr	r1, [sp]
700aec42: f44f 7080    	mov.w	r0, #0x100
700aec46: 6008         	str	r0, [r1]
; }
700aec48: b003         	add	sp, #0xc
700aec4a: 4770         	bx	lr
700aec4c: 0000         	movs	r0, r0
700aec4e: 0000         	movs	r0, r0

700aec50 <Sciclient_rmParamIsValid>:
; {
700aec50: b083         	sub	sp, #0xc
700aec52: 9002         	str	r0, [sp, #0x8]
700aec54: 9101         	str	r1, [sp, #0x4]
700aec56: 2000         	movs	r0, #0x0
;     bool r = false;
700aec58: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((valid_params & param_mask) != 0) {
700aec5c: 9802         	ldr	r0, [sp, #0x8]
700aec5e: 9901         	ldr	r1, [sp, #0x4]
700aec60: 4208         	tst	r0, r1
700aec62: d004         	beq	0x700aec6e <Sciclient_rmParamIsValid+0x1e> @ imm = #0x8
700aec64: e7ff         	b	0x700aec66 <Sciclient_rmParamIsValid+0x16> @ imm = #-0x2
700aec66: 2001         	movs	r0, #0x1
;         r = true;
700aec68: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aec6c: e7ff         	b	0x700aec6e <Sciclient_rmParamIsValid+0x1e> @ imm = #-0x2
;     return r;
700aec6e: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aec72: f000 0001    	and	r0, r0, #0x1
700aec76: b003         	add	sp, #0xc
700aec78: 4770         	bx	lr
700aec7a: 0000         	movs	r0, r0
700aec7c: 0000         	movs	r0, r0
700aec7e: 0000         	movs	r0, r0

700aec80 <Sciclient_rmPsIsEmpty>:
; {
700aec80: b081         	sub	sp, #0x4
700aec82: 2001         	movs	r0, #0x1
;     bool e = true;
700aec84: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if (gPstack.psp != 0) {
700aec88: f241 0058    	movw	r0, #0x1058
700aec8c: f2c7 0008    	movt	r0, #0x7008
700aec90: 8c80         	ldrh	r0, [r0, #0x24]
700aec92: b120         	cbz	r0, 0x700aec9e <Sciclient_rmPsIsEmpty+0x1e> @ imm = #0x8
700aec94: e7ff         	b	0x700aec96 <Sciclient_rmPsIsEmpty+0x16> @ imm = #-0x2
700aec96: 2000         	movs	r0, #0x0
;         e = false;
700aec98: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aec9c: e7ff         	b	0x700aec9e <Sciclient_rmPsIsEmpty+0x1e> @ imm = #-0x2
;     return e;
700aec9e: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aeca2: f000 0001    	and	r0, r0, #0x1
700aeca6: b001         	add	sp, #0x4
700aeca8: 4770         	bx	lr
700aecaa: 0000         	movs	r0, r0
700aecac: 0000         	movs	r0, r0
700aecae: 0000         	movs	r0, r0

700aecb0 <UART_Transaction_init>:
; {
700aecb0: b081         	sub	sp, #0x4
700aecb2: 9000         	str	r0, [sp]
;     if(trans != NULL)
700aecb4: 9800         	ldr	r0, [sp]
700aecb6: b170         	cbz	r0, 0x700aecd6 <UART_Transaction_init+0x26> @ imm = #0x1c
700aecb8: e7ff         	b	0x700aecba <UART_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700aecba: 9900         	ldr	r1, [sp]
700aecbc: 2000         	movs	r0, #0x0
700aecbe: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700aecc0: 9900         	ldr	r1, [sp]
700aecc2: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = SystemP_WAIT_FOREVER;
700aecc4: 9a00         	ldr	r2, [sp]
700aecc6: f04f 31ff    	mov.w	r1, #0xffffffff
700aecca: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700aeccc: 9900         	ldr	r1, [sp]
700aecce: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700aecd0: 9900         	ldr	r1, [sp]
700aecd2: 6108         	str	r0, [r1, #0x10]
;     }
700aecd4: e7ff         	b	0x700aecd6 <UART_Transaction_init+0x26> @ imm = #-0x2
; }
700aecd6: b001         	add	sp, #0x4
700aecd8: 4770         	bx	lr
700aecda: 0000         	movs	r0, r0
700aecdc: 0000         	movs	r0, r0
700aecde: 0000         	movs	r0, r0

700aece0 <UART_intr2Disable>:
; {
700aece0: b580         	push	{r7, lr}
700aece2: b084         	sub	sp, #0x10
700aece4: 9003         	str	r0, [sp, #0xc]
700aece6: 9102         	str	r1, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_IER2, HW_RD_REG32(baseAddr + UART_IER2) &
700aece8: 9803         	ldr	r0, [sp, #0xc]
700aecea: 306c         	adds	r0, #0x6c
700aecec: 9001         	str	r0, [sp, #0x4]
700aecee: f000 ff1f    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0xe3e
700aecf2: 4601         	mov	r1, r0
700aecf4: 9801         	ldr	r0, [sp, #0x4]
700aecf6: 9b02         	ldr	r3, [sp, #0x8]
700aecf8: f06f 0203    	mvn	r2, #0x3
700aecfc: ea62 0203    	orn	r2, r2, r3
700aed00: 4011         	ands	r1, r2
700aed02: f000 ff1d    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0xe3a
; }
700aed06: b004         	add	sp, #0x10
700aed08: bd80         	pop	{r7, pc}
700aed0a: 0000         	movs	r0, r0
700aed0c: 0000         	movs	r0, r0
700aed0e: 0000         	movs	r0, r0

700aed10 <UART_lld_Transaction_init>:
; {
700aed10: b081         	sub	sp, #0x4
700aed12: 9000         	str	r0, [sp]
;     if(trans != NULL)
700aed14: 9800         	ldr	r0, [sp]
700aed16: b170         	cbz	r0, 0x700aed36 <UART_lld_Transaction_init+0x26> @ imm = #0x1c
700aed18: e7ff         	b	0x700aed1a <UART_lld_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700aed1a: 9900         	ldr	r1, [sp]
700aed1c: 2000         	movs	r0, #0x0
700aed1e: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700aed20: 9900         	ldr	r1, [sp]
700aed22: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = UART_WAIT_FOREVER;
700aed24: 9a00         	ldr	r2, [sp]
700aed26: f04f 31ff    	mov.w	r1, #0xffffffff
700aed2a: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700aed2c: 9900         	ldr	r1, [sp]
700aed2e: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700aed30: 9900         	ldr	r1, [sp]
700aed32: 6108         	str	r0, [r1, #0x10]
;     }
700aed34: e7ff         	b	0x700aed36 <UART_lld_Transaction_init+0x26> @ imm = #-0x2
; }
700aed36: b001         	add	sp, #0x4
700aed38: 4770         	bx	lr
700aed3a: 0000         	movs	r0, r0
700aed3c: 0000         	movs	r0, r0
700aed3e: 0000         	movs	r0, r0

700aed40 <UART_lld_dmaWrite>:
; {
700aed40: b580         	push	{r7, lr}
700aed42: b084         	sub	sp, #0x10
700aed44: 9003         	str	r0, [sp, #0xc]
700aed46: 9102         	str	r1, [sp, #0x8]
700aed48: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700aed4a: 9001         	str	r0, [sp, #0x4]
;     status = UART_udmaConfigPdmaTx(hUart, transaction);
700aed4c: 9803         	ldr	r0, [sp, #0xc]
700aed4e: 9902         	ldr	r1, [sp, #0x8]
700aed50: f7f7 fa96    	bl	0x700a6280 <UART_udmaConfigPdmaTx> @ imm = #-0x8ad4
700aed54: 9001         	str	r0, [sp, #0x4]
;     if (status != UDMA_SOK)
700aed56: 9801         	ldr	r0, [sp, #0x4]
700aed58: b120         	cbz	r0, 0x700aed64 <UART_lld_dmaWrite+0x24> @ imm = #0x8
700aed5a: e7ff         	b	0x700aed5c <UART_lld_dmaWrite+0x1c> @ imm = #-0x2
700aed5c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700aed60: 9001         	str	r0, [sp, #0x4]
;     }
700aed62: e7ff         	b	0x700aed64 <UART_lld_dmaWrite+0x24> @ imm = #-0x2
;     return status;
700aed64: 9801         	ldr	r0, [sp, #0x4]
700aed66: b004         	add	sp, #0x10
700aed68: bd80         	pop	{r7, pc}
700aed6a: 0000         	movs	r0, r0
700aed6c: 0000         	movs	r0, r0
700aed6e: 0000         	movs	r0, r0

700aed70 <UART_operatingModeSelect>:
; {
700aed70: b580         	push	{r7, lr}
700aed72: b084         	sub	sp, #0x10
700aed74: 9003         	str	r0, [sp, #0xc]
700aed76: 9102         	str	r1, [sp, #0x8]
;     operMode = HW_RD_REG32(baseAddr + UART_MDR1) & UART_MDR1_MODE_SELECT_MASK;
700aed78: 9803         	ldr	r0, [sp, #0xc]
700aed7a: 3020         	adds	r0, #0x20
700aed7c: f000 fed8    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0xdb0
700aed80: f000 0007    	and	r0, r0, #0x7
700aed84: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_MDR1, UART_MDR1_MODE_SELECT,
700aed86: 9803         	ldr	r0, [sp, #0xc]
700aed88: 3020         	adds	r0, #0x20
700aed8a: 9b02         	ldr	r3, [sp, #0x8]
700aed8c: 2107         	movs	r1, #0x7
700aed8e: 2200         	movs	r2, #0x0
700aed90: f7ff fc36    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #-0x794
;     return operMode;
700aed94: 9801         	ldr	r0, [sp, #0x4]
700aed96: b004         	add	sp, #0x10
700aed98: bd80         	pop	{r7, pc}
700aed9a: 0000         	movs	r0, r0
700aed9c: 0000         	movs	r0, r0
700aed9e: 0000         	movs	r0, r0

700aeda0 <Udma_eventProgramSteering>:
; {
700aeda0: b084         	sub	sp, #0x10
700aeda2: 9003         	str	r0, [sp, #0xc]
700aeda4: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700aeda6: 9802         	ldr	r0, [sp, #0x8]
700aeda8: 3008         	adds	r0, #0x8
700aedaa: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700aedac: 9800         	ldr	r0, [sp]
700aedae: 6800         	ldr	r0, [r0]
700aedb0: 2803         	cmp	r0, #0x3
700aedb2: d108         	bne	0x700aedc6 <Udma_eventProgramSteering+0x26> @ imm = #0x10
700aedb4: e7ff         	b	0x700aedb6 <Udma_eventProgramSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700aedb6: 9800         	ldr	r0, [sp]
700aedb8: 6880         	ldr	r0, [r0, #0x8]
700aedba: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = TRUE;
700aedbc: 9901         	ldr	r1, [sp, #0x4]
700aedbe: 2001         	movs	r0, #0x1
700aedc0: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700aedc4: e7ff         	b	0x700aedc6 <Udma_eventProgramSteering+0x26> @ imm = #-0x2
;     return;
700aedc6: b004         	add	sp, #0x10
700aedc8: 4770         	bx	lr
700aedca: 0000         	movs	r0, r0
700aedcc: 0000         	movs	r0, r0
700aedce: 0000         	movs	r0, r0

700aedd0 <Udma_eventResetSteering>:
; {
700aedd0: b084         	sub	sp, #0x10
700aedd2: 9003         	str	r0, [sp, #0xc]
700aedd4: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700aedd6: 9802         	ldr	r0, [sp, #0x8]
700aedd8: 3008         	adds	r0, #0x8
700aedda: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700aeddc: 9800         	ldr	r0, [sp]
700aedde: 6800         	ldr	r0, [r0]
700aede0: 2803         	cmp	r0, #0x3
700aede2: d108         	bne	0x700aedf6 <Udma_eventResetSteering+0x26> @ imm = #0x10
700aede4: e7ff         	b	0x700aede6 <Udma_eventResetSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700aede6: 9800         	ldr	r0, [sp]
700aede8: 6880         	ldr	r0, [r0, #0x8]
700aedea: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = FALSE;
700aedec: 9901         	ldr	r1, [sp, #0x4]
700aedee: 2000         	movs	r0, #0x0
700aedf0: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700aedf4: e7ff         	b	0x700aedf6 <Udma_eventResetSteering+0x26> @ imm = #-0x2
;     return;
700aedf6: b004         	add	sp, #0x10
700aedf8: 4770         	bx	lr
700aedfa: 0000         	movs	r0, r0
700aedfc: 0000         	movs	r0, r0
700aedfe: 0000         	movs	r0, r0

700aee00 <Sciclient_secProxyVerifyThread>:
; {
700aee00: b580         	push	{r7, lr}
700aee02: b082         	sub	sp, #0x8
700aee04: 9001         	str	r0, [sp, #0x4]
700aee06: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700aee08: 9000         	str	r0, [sp]
;     if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700aee0a: 9801         	ldr	r0, [sp, #0x4]
700aee0c: f000 fc28    	bl	0x700af660 <Sciclient_secProxyThreadStatusReg> @ imm = #0x850
700aee10: f000 feee    	bl	0x700afbf0 <CSL_REG32_RD_RAW> @ imm = #0xddc
700aee14: 0fc0         	lsrs	r0, r0, #0x1f
700aee16: b120         	cbz	r0, 0x700aee22 <Sciclient_secProxyVerifyThread+0x22> @ imm = #0x8
700aee18: e7ff         	b	0x700aee1a <Sciclient_secProxyVerifyThread+0x1a> @ imm = #-0x2
700aee1a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700aee1e: 9000         	str	r0, [sp]
;     }
700aee20: e7ff         	b	0x700aee22 <Sciclient_secProxyVerifyThread+0x22> @ imm = #-0x2
;     return status;
700aee22: 9800         	ldr	r0, [sp]
700aee24: b002         	add	sp, #0x8
700aee26: bd80         	pop	{r7, pc}
		...

700aee30 <prvIsQueueEmpty>:
; {
700aee30: b580         	push	{r7, lr}
700aee32: b082         	sub	sp, #0x8
700aee34: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700aee36: f7ff fc43    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #-0x77a
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
700aee3a: 9801         	ldr	r0, [sp, #0x4]
700aee3c: 6b80         	ldr	r0, [r0, #0x38]
700aee3e: b918         	cbnz	r0, 0x700aee48 <prvIsQueueEmpty+0x18> @ imm = #0x6
700aee40: e7ff         	b	0x700aee42 <prvIsQueueEmpty+0x12> @ imm = #-0x2
700aee42: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700aee44: 9000         	str	r0, [sp]
;         }
700aee46: e002         	b	0x700aee4e <prvIsQueueEmpty+0x1e> @ imm = #0x4
700aee48: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700aee4a: 9000         	str	r0, [sp]
700aee4c: e7ff         	b	0x700aee4e <prvIsQueueEmpty+0x1e> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700aee4e: f7fe fcd7    	bl	0x700ad800 <vTaskExitCritical> @ imm = #-0x1652
;     return xReturn;
700aee52: 9800         	ldr	r0, [sp]
700aee54: b002         	add	sp, #0x8
700aee56: bd80         	pop	{r7, pc}
		...

700aee60 <vQueueDelete>:
; {
700aee60: b580         	push	{r7, lr}
700aee62: b082         	sub	sp, #0x8
700aee64: 9001         	str	r0, [sp, #0x4]
;     Queue_t * const pxQueue = xQueue;
700aee66: 9801         	ldr	r0, [sp, #0x4]
700aee68: 9000         	str	r0, [sp]
;             vQueueUnregisterQueue( pxQueue );
700aee6a: 9800         	ldr	r0, [sp]
700aee6c: f7fd fff8    	bl	0x700ace60 <vQueueUnregisterQueue> @ imm = #-0x2010
;             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
700aee70: 9800         	ldr	r0, [sp]
700aee72: f890 0046    	ldrb.w	r0, [r0, #0x46]
700aee76: b920         	cbnz	r0, 0x700aee82 <vQueueDelete+0x22> @ imm = #0x8
700aee78: e7ff         	b	0x700aee7a <vQueueDelete+0x1a> @ imm = #-0x2
;                 vPortFree( pxQueue );
700aee7a: 9800         	ldr	r0, [sp]
700aee7c: f000 fa60    	bl	0x700af340 <vPortFree>  @ imm = #0x4c0
;             }
700aee80: e000         	b	0x700aee84 <vQueueDelete+0x24> @ imm = #0x0
700aee82: e7ff         	b	0x700aee84 <vQueueDelete+0x24> @ imm = #-0x2
; }
700aee84: b002         	add	sp, #0x8
700aee86: bd80         	pop	{r7, pc}
		...

700aee90 <vprintf_>:
; {
700aee90: b580         	push	{r7, lr}
700aee92: b084         	sub	sp, #0x10
700aee94: 9103         	str	r1, [sp, #0xc]
700aee96: 9002         	str	r0, [sp, #0x8]
;   return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
700aee98: 9b02         	ldr	r3, [sp, #0x8]
700aee9a: 9803         	ldr	r0, [sp, #0xc]
700aee9c: 4669         	mov	r1, sp
700aee9e: 6008         	str	r0, [r1]
700aeea0: f24f 1081    	movw	r0, #0xf181
700aeea4: f2c7 000a    	movt	r0, #0x700a
700aeea8: f10d 0107    	add.w	r1, sp, #0x7
700aeeac: f04f 32ff    	mov.w	r2, #0xffffffff
700aeeb0: f7eb f856    	bl	0x70099f60 <_vsnprintf> @ imm = #-0x14f54
700aeeb4: b004         	add	sp, #0x10
700aeeb6: bd80         	pop	{r7, pc}
		...

700aeec0 <UART_udmapSetReturnPolicy>:
; {
700aeec0: b580         	push	{r7, lr}
700aeec2: b086         	sub	sp, #0x18
700aeec4: 9005         	str	r0, [sp, #0x14]
700aeec6: 9104         	str	r1, [sp, #0x10]
700aeec8: 2001         	movs	r0, #0x1
;         uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700aeeca: 9003         	str	r0, [sp, #0xc]
;         CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700aeecc: 9804         	ldr	r0, [sp, #0x10]
700aeece: 9002         	str	r0, [sp, #0x8]
;         pHpd,
700aeed0: 9802         	ldr	r0, [sp, #0x8]
;         descType,
700aeed2: 9903         	ldr	r1, [sp, #0xc]
;         CSL_udmapCppi5SetReturnPolicy(
700aeed4: 466a         	mov	r2, sp
700aeed6: 2300         	movs	r3, #0x0
700aeed8: 6053         	str	r3, [r2, #0x4]
700aeeda: 6013         	str	r3, [r2]
700aeedc: 461a         	mov	r2, r3
700aeede: f7fb fb57    	bl	0x700aa590 <CSL_udmapCppi5SetReturnPolicy> @ imm = #-0x4952
;         return;
700aeee2: b006         	add	sp, #0x18
700aeee4: bd80         	pop	{r7, pc}
		...
700aeeee: 0000         	movs	r0, r0

700aeef0 <Udma_ringGetForwardRingOcc>:
; {
700aeef0: b580         	push	{r7, lr}
700aeef2: b084         	sub	sp, #0x10
700aeef4: 9003         	str	r0, [sp, #0xc]
700aeef6: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700aeef8: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700aeefa: 9803         	ldr	r0, [sp, #0xc]
700aeefc: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700aeefe: 9801         	ldr	r0, [sp, #0x4]
700aef00: 6800         	ldr	r0, [r0]
700aef02: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetForwardRingOcc(ringHandleInt);
700aef04: 9800         	ldr	r0, [sp]
700aef06: f8d0 15a8    	ldr.w	r1, [r0, #0x5a8]
700aef0a: 9801         	ldr	r0, [sp, #0x4]
700aef0c: 4788         	blx	r1
700aef0e: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700aef10: 9802         	ldr	r0, [sp, #0x8]
700aef12: b004         	add	sp, #0x10
700aef14: bd80         	pop	{r7, pc}
		...
700aef1e: 0000         	movs	r0, r0

700aef20 <Udma_ringGetReverseRingOcc>:
; {
700aef20: b580         	push	{r7, lr}
700aef22: b084         	sub	sp, #0x10
700aef24: 9003         	str	r0, [sp, #0xc]
700aef26: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700aef28: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700aef2a: 9803         	ldr	r0, [sp, #0xc]
700aef2c: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700aef2e: 9801         	ldr	r0, [sp, #0x4]
700aef30: 6800         	ldr	r0, [r0]
700aef32: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetReverseRingOcc(ringHandleInt);
700aef34: 9800         	ldr	r0, [sp]
700aef36: f8d0 15ac    	ldr.w	r1, [r0, #0x5ac]
700aef3a: 9801         	ldr	r0, [sp, #0x4]
700aef3c: 4788         	blx	r1
700aef3e: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700aef40: 9802         	ldr	r0, [sp, #0x8]
700aef42: b004         	add	sp, #0x10
700aef44: bd80         	pop	{r7, pc}
		...
700aef4e: 0000         	movs	r0, r0

700aef50 <_out_buffer>:
; {
700aef50: b084         	sub	sp, #0x10
700aef52: f88d 000f    	strb.w	r0, [sp, #0xf]
700aef56: 9102         	str	r1, [sp, #0x8]
700aef58: 9201         	str	r2, [sp, #0x4]
700aef5a: 9300         	str	r3, [sp]
;   if (idx < maxlen) {
700aef5c: 9801         	ldr	r0, [sp, #0x4]
700aef5e: 9900         	ldr	r1, [sp]
700aef60: 4288         	cmp	r0, r1
700aef62: d206         	bhs	0x700aef72 <_out_buffer+0x22> @ imm = #0xc
700aef64: e7ff         	b	0x700aef66 <_out_buffer+0x16> @ imm = #-0x2
;     ((char*)buffer)[idx] = character;
700aef66: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700aef6a: 9902         	ldr	r1, [sp, #0x8]
700aef6c: 9a01         	ldr	r2, [sp, #0x4]
700aef6e: 5488         	strb	r0, [r1, r2]
;   }
700aef70: e7ff         	b	0x700aef72 <_out_buffer+0x22> @ imm = #-0x2
; }
700aef72: b004         	add	sp, #0x10
700aef74: 4770         	bx	lr
		...
700aef7e: 0000         	movs	r0, r0

700aef80 <prvGetDisinheritPriorityAfterTimeout>:
;     {
700aef80: b082         	sub	sp, #0x8
700aef82: 9001         	str	r0, [sp, #0x4]
;         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
700aef84: 9801         	ldr	r0, [sp, #0x4]
700aef86: 6a40         	ldr	r0, [r0, #0x24]
700aef88: b138         	cbz	r0, 0x700aef9a <prvGetDisinheritPriorityAfterTimeout+0x1a> @ imm = #0xe
700aef8a: e7ff         	b	0x700aef8c <prvGetDisinheritPriorityAfterTimeout+0xc> @ imm = #-0x2
;             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
700aef8c: 9801         	ldr	r0, [sp, #0x4]
700aef8e: 6b00         	ldr	r0, [r0, #0x30]
700aef90: 6800         	ldr	r0, [r0]
700aef92: f1c0 0020    	rsb.w	r0, r0, #0x20
700aef96: 9000         	str	r0, [sp]
;         }
700aef98: e002         	b	0x700aefa0 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #0x4
700aef9a: 2000         	movs	r0, #0x0
;             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
700aef9c: 9000         	str	r0, [sp]
700aef9e: e7ff         	b	0x700aefa0 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #-0x2
;         return uxHighestPriorityOfWaitingTasks;
700aefa0: 9800         	ldr	r0, [sp]
700aefa2: b002         	add	sp, #0x8
700aefa4: 4770         	bx	lr
		...
700aefae: 0000         	movs	r0, r0

700aefb0 <vTaskPlaceOnEventList>:
;                            const TickType_t xTicksToWait) {
700aefb0: b580         	push	{r7, lr}
700aefb2: b082         	sub	sp, #0x8
700aefb4: 9001         	str	r0, [sp, #0x4]
700aefb6: 9100         	str	r1, [sp]
;   vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
700aefb8: 9801         	ldr	r0, [sp, #0x4]
700aefba: f642 2100    	movw	r1, #0x2a00
700aefbe: f2c7 010b    	movt	r1, #0x700b
700aefc2: 6809         	ldr	r1, [r1]
700aefc4: 3118         	adds	r1, #0x18
700aefc6: f7fc fb73    	bl	0x700ab6b0 <vListInsert> @ imm = #-0x391a
;   prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
700aefca: 9800         	ldr	r0, [sp]
700aefcc: 2101         	movs	r1, #0x1
700aefce: f7f7 fb17    	bl	0x700a6600 <prvAddCurrentTaskToDelayedList> @ imm = #-0x89d2
; }
700aefd2: b002         	add	sp, #0x8
700aefd4: bd80         	pop	{r7, pc}
		...
700aefde: 0000         	movs	r0, r0

700aefe0 <xQueueCreateMutex>:
;     {
700aefe0: b580         	push	{r7, lr}
700aefe2: b084         	sub	sp, #0x10
700aefe4: f88d 000f    	strb.w	r0, [sp, #0xf]
700aefe8: 2001         	movs	r0, #0x1
;         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
700aefea: 9001         	str	r0, [sp, #0x4]
700aefec: 2100         	movs	r1, #0x0
700aefee: 9100         	str	r1, [sp]
;         xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
700aeff0: f89d 200f    	ldrb.w	r2, [sp, #0xf]
700aeff4: f7fd fcfc    	bl	0x700ac9f0 <xQueueGenericCreate> @ imm = #-0x2608
700aeff8: 9002         	str	r0, [sp, #0x8]
;         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
700aeffa: 9802         	ldr	r0, [sp, #0x8]
700aeffc: f7ff fdc8    	bl	0x700aeb90 <prvInitialiseMutex> @ imm = #-0x470
;         return xNewQueue;
700af000: 9802         	ldr	r0, [sp, #0x8]
700af002: b004         	add	sp, #0x10
700af004: bd80         	pop	{r7, pc}
		...
700af00e: 0000         	movs	r0, r0

700af010 <CSL_REG32_FEXT_RAW>:
; {
700af010: b580         	push	{r7, lr}
700af012: b084         	sub	sp, #0x10
700af014: 9003         	str	r0, [sp, #0xc]
700af016: 9102         	str	r1, [sp, #0x8]
700af018: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af01a: 9803         	ldr	r0, [sp, #0xc]
700af01c: f000 fdd0    	bl	0x700afbc0 <CSL_REG32_RD_RAW> @ imm = #0xba0
700af020: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af022: 9800         	ldr	r0, [sp]
700af024: 9902         	ldr	r1, [sp, #0x8]
700af026: 4008         	ands	r0, r1
700af028: 9901         	ldr	r1, [sp, #0x4]
700af02a: 40c8         	lsrs	r0, r1
700af02c: 9000         	str	r0, [sp]
;     return (regVal);
700af02e: 9800         	ldr	r0, [sp]
700af030: b004         	add	sp, #0x10
700af032: bd80         	pop	{r7, pc}
		...

700af040 <CSL_REG32_FEXT_RAW>:
; {
700af040: b580         	push	{r7, lr}
700af042: b084         	sub	sp, #0x10
700af044: 9003         	str	r0, [sp, #0xc]
700af046: 9102         	str	r1, [sp, #0x8]
700af048: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af04a: 9803         	ldr	r0, [sp, #0xc]
700af04c: f000 fdc0    	bl	0x700afbd0 <CSL_REG32_RD_RAW> @ imm = #0xb80
700af050: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af052: 9800         	ldr	r0, [sp]
700af054: 9902         	ldr	r1, [sp, #0x8]
700af056: 4008         	ands	r0, r1
700af058: 9901         	ldr	r1, [sp, #0x4]
700af05a: 40c8         	lsrs	r0, r1
700af05c: 9000         	str	r0, [sp]
;     return (regVal);
700af05e: 9800         	ldr	r0, [sp]
700af060: b004         	add	sp, #0x10
700af062: bd80         	pop	{r7, pc}
		...

700af070 <CSL_REG32_FEXT_RAW>:
; {
700af070: b580         	push	{r7, lr}
700af072: b084         	sub	sp, #0x10
700af074: 9003         	str	r0, [sp, #0xc]
700af076: 9102         	str	r1, [sp, #0x8]
700af078: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af07a: 9803         	ldr	r0, [sp, #0xc]
700af07c: f000 fdb0    	bl	0x700afbe0 <CSL_REG32_RD_RAW> @ imm = #0xb60
700af080: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af082: 9800         	ldr	r0, [sp]
700af084: 9902         	ldr	r1, [sp, #0x8]
700af086: 4008         	ands	r0, r1
700af088: 9901         	ldr	r1, [sp, #0x4]
700af08a: 40c8         	lsrs	r0, r1
700af08c: 9000         	str	r0, [sp]
;     return (regVal);
700af08e: 9800         	ldr	r0, [sp]
700af090: b004         	add	sp, #0x10
700af092: bd80         	pop	{r7, pc}
		...

700af0a0 <CSL_REG32_FEXT_RAW>:
; {
700af0a0: b580         	push	{r7, lr}
700af0a2: b084         	sub	sp, #0x10
700af0a4: 9003         	str	r0, [sp, #0xc]
700af0a6: 9102         	str	r1, [sp, #0x8]
700af0a8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af0aa: 9803         	ldr	r0, [sp, #0xc]
700af0ac: f000 fda0    	bl	0x700afbf0 <CSL_REG32_RD_RAW> @ imm = #0xb40
700af0b0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af0b2: 9800         	ldr	r0, [sp]
700af0b4: 9902         	ldr	r1, [sp, #0x8]
700af0b6: 4008         	ands	r0, r1
700af0b8: 9901         	ldr	r1, [sp, #0x4]
700af0ba: 40c8         	lsrs	r0, r1
700af0bc: 9000         	str	r0, [sp]
;     return (regVal);
700af0be: 9800         	ldr	r0, [sp]
700af0c0: b004         	add	sp, #0x10
700af0c2: bd80         	pop	{r7, pc}
		...

700af0d0 <CSL_REG32_FEXT_RAW>:
; {
700af0d0: b580         	push	{r7, lr}
700af0d2: b084         	sub	sp, #0x10
700af0d4: 9003         	str	r0, [sp, #0xc]
700af0d6: 9102         	str	r1, [sp, #0x8]
700af0d8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af0da: 9803         	ldr	r0, [sp, #0xc]
700af0dc: f000 fd90    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xb20
700af0e0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af0e2: 9800         	ldr	r0, [sp]
700af0e4: 9902         	ldr	r1, [sp, #0x8]
700af0e6: 4008         	ands	r0, r1
700af0e8: 9901         	ldr	r1, [sp, #0x4]
700af0ea: 40c8         	lsrs	r0, r1
700af0ec: 9000         	str	r0, [sp]
;     return (regVal);
700af0ee: 9800         	ldr	r0, [sp]
700af0f0: b004         	add	sp, #0x10
700af0f2: bd80         	pop	{r7, pc}
		...

700af100 <SOC_getSelfCpuClk>:
; {
700af100: b580         	push	{r7, lr}
700af102: b084         	sub	sp, #0x10
700af104: 2000         	movs	r0, #0x0
;     uint64_t cpuClockRate = 0U;
700af106: 9001         	str	r0, [sp, #0x4]
700af108: 9003         	str	r0, [sp, #0xc]
700af10a: 9002         	str	r0, [sp, #0x8]
;                     Sciclient_getSelfDevIdCore(),
700af10c: f000 fd90    	bl	0x700afc30 <Sciclient_getSelfDevIdCore> @ imm = #0xb20
700af110: 9901         	ldr	r1, [sp, #0x4]
700af112: aa02         	add	r2, sp, #0x8
700af114: f04f 33ff    	mov.w	r3, #0xffffffff
;     Sciclient_pmGetModuleClkFreq(
700af118: f7f9 fe42    	bl	0x700a8da0 <Sciclient_pmGetModuleClkFreq> @ imm = #-0x637c
;     return cpuClockRate;
700af11c: 9802         	ldr	r0, [sp, #0x8]
700af11e: 9903         	ldr	r1, [sp, #0xc]
700af120: b004         	add	sp, #0x10
700af122: bd80         	pop	{r7, pc}
		...

700af130 <UART_IsStopBitsValid>:
; {
700af130: b082         	sub	sp, #0x8
700af132: 9001         	str	r0, [sp, #0x4]
700af134: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700af138: 9000         	str	r0, [sp]
;     if((stopBits == UART_STOPBITS_1) ||
700af13a: 9801         	ldr	r0, [sp, #0x4]
700af13c: b120         	cbz	r0, 0x700af148 <UART_IsStopBitsValid+0x18> @ imm = #0x8
700af13e: e7ff         	b	0x700af140 <UART_IsStopBitsValid+0x10> @ imm = #-0x2
;         (stopBits == UART_STOPBITS_2))
700af140: 9801         	ldr	r0, [sp, #0x4]
;     if((stopBits == UART_STOPBITS_1) ||
700af142: 2801         	cmp	r0, #0x1
700af144: d103         	bne	0x700af14e <UART_IsStopBitsValid+0x1e> @ imm = #0x6
700af146: e7ff         	b	0x700af148 <UART_IsStopBitsValid+0x18> @ imm = #-0x2
700af148: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700af14a: 9000         	str	r0, [sp]
;     }
700af14c: e7ff         	b	0x700af14e <UART_IsStopBitsValid+0x1e> @ imm = #-0x2
;     return status;
700af14e: 9800         	ldr	r0, [sp]
700af150: b002         	add	sp, #0x8
700af152: 4770         	bx	lr

700af154 <__aeabi_uldivmod>:
700af154: e92d4040     	push	{r6, lr}
700af158: e24dd010     	sub	sp, sp, #16
700af15c: e28d6008     	add	r6, sp, #8
700af160: e58d6000     	str	r6, [sp]
700af164: ebffd583     	bl	0x700a4778 <__udivmoddi4> @ imm = #-0xa9f4
700af168: e59d2008     	ldr	r2, [sp, #0x8]
700af16c: e59d300c     	ldr	r3, [sp, #0xc]
700af170: e28dd010     	add	sp, sp, #16
700af174: e8bd8040     	pop	{r6, pc}
		...

700af180 <_out_char>:
; {
700af180: b580         	push	{r7, lr}
700af182: b084         	sub	sp, #0x10
700af184: f88d 000f    	strb.w	r0, [sp, #0xf]
700af188: 9102         	str	r1, [sp, #0x8]
700af18a: 9201         	str	r2, [sp, #0x4]
700af18c: 9300         	str	r3, [sp]
;   if (character) {
700af18e: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700af192: b128         	cbz	r0, 0x700af1a0 <_out_char+0x20> @ imm = #0xa
700af194: e7ff         	b	0x700af196 <_out_char+0x16> @ imm = #-0x2
;     putchar_(character);
700af196: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700af19a: f000 fc39    	bl	0x700afa10 <putchar_>   @ imm = #0x872
;   }
700af19e: e7ff         	b	0x700af1a0 <_out_char+0x20> @ imm = #-0x2
; }
700af1a0: b004         	add	sp, #0x10
700af1a2: bd80         	pop	{r7, pc}
		...

700af1b0 <vTaskInternalSetTimeOutState>:
; void vTaskInternalSetTimeOutState(TimeOut_t *const pxTimeOut) {
700af1b0: b081         	sub	sp, #0x4
700af1b2: 9000         	str	r0, [sp]
;   pxTimeOut->xOverflowCount = xNumOfOverflows;
700af1b4: f642 2038    	movw	r0, #0x2a38
700af1b8: f2c7 000b    	movt	r0, #0x700b
700af1bc: 6800         	ldr	r0, [r0]
700af1be: 9900         	ldr	r1, [sp]
700af1c0: 6008         	str	r0, [r1]
;   pxTimeOut->xTimeOnEntering = xTickCount;
700af1c2: f642 2044    	movw	r0, #0x2a44
700af1c6: f2c7 000b    	movt	r0, #0x700b
700af1ca: 6800         	ldr	r0, [r0]
700af1cc: 9900         	ldr	r1, [sp]
700af1ce: 6048         	str	r0, [r1, #0x4]
; }
700af1d0: b001         	add	sp, #0x4
700af1d2: 4770         	bx	lr
		...

700af1e0 <Pinmux_init>:
; {
700af1e0: b580         	push	{r7, lr}
;     Pinmux_config(gPinMuxMainDomainCfg, PINMUX_DOMAIN_ID_MAIN);
700af1e2: f642 1018    	movw	r0, #0x2918
700af1e6: 2100         	movs	r1, #0x0
700af1e8: f2c7 000b    	movt	r0, #0x700b
700af1ec: f7f9 fce8    	bl	0x700a8bc0 <Pinmux_config> @ imm = #-0x6630
;     Pinmux_config(gPinMuxMcuDomainCfg, PINMUX_DOMAIN_ID_MCU);
700af1f0: f642 108c    	movw	r0, #0x298c
700af1f4: 2101         	movs	r1, #0x1
700af1f6: f2c7 000b    	movt	r0, #0x700b
700af1fa: e8bd 4080    	pop.w	{r7, lr}
700af1fe: f7f9 bcdf    	b.w	0x700a8bc0 <Pinmux_config> @ imm = #-0x6642
		...
700af20e: 0000         	movs	r0, r0

700af210 <Udma_rmTranslateCoreIntrInput>:
; {
700af210: b083         	sub	sp, #0xc
700af212: 9002         	str	r0, [sp, #0x8]
700af214: 9101         	str	r1, [sp, #0x4]
700af216: 2000         	movs	r0, #0x0
700af218: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    irIntrNum = UDMA_INTR_INVALID;
700af21c: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700af21e: 9802         	ldr	r0, [sp, #0x8]
700af220: 6800         	ldr	r0, [r0]
700af222: b118         	cbz	r0, 0x700af22c <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #0x6
700af224: e7ff         	b	0x700af226 <Udma_rmTranslateCoreIntrInput+0x16> @ imm = #-0x2
;         irIntrNum = coreIntrNum;
700af226: 9801         	ldr	r0, [sp, #0x4]
700af228: 9000         	str	r0, [sp]
;     }
700af22a: e7ff         	b	0x700af22c <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #-0x2
;     return (irIntrNum);
700af22c: 9800         	ldr	r0, [sp]
700af22e: b003         	add	sp, #0xc
700af230: 4770         	bx	lr
		...
700af23e: 0000         	movs	r0, r0

700af240 <Udma_rmTranslateIrOutput>:
; {
700af240: b083         	sub	sp, #0xc
700af242: 9002         	str	r0, [sp, #0x8]
700af244: 9101         	str	r1, [sp, #0x4]
700af246: 2000         	movs	r0, #0x0
700af248: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    coreIntrNum = UDMA_INTR_INVALID;
700af24c: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700af24e: 9802         	ldr	r0, [sp, #0x8]
700af250: 6800         	ldr	r0, [r0]
700af252: b118         	cbz	r0, 0x700af25c <Udma_rmTranslateIrOutput+0x1c> @ imm = #0x6
700af254: e7ff         	b	0x700af256 <Udma_rmTranslateIrOutput+0x16> @ imm = #-0x2
;         coreIntrNum = irIntrNum;
700af256: 9801         	ldr	r0, [sp, #0x4]
700af258: 9000         	str	r0, [sp]
;     }
700af25a: e7ff         	b	0x700af25c <Udma_rmTranslateIrOutput+0x1c> @ imm = #-0x2
;     return (coreIntrNum);
700af25c: 9800         	ldr	r0, [sp]
700af25e: b003         	add	sp, #0xc
700af260: 4770         	bx	lr
		...
700af26e: 0000         	movs	r0, r0

700af270 <tm_thread_exit>:
; {
700af270: b580         	push	{r7, lr}
;    if (xTaskGetCurrentTaskHandle() != NULL)
700af272: f000 fb7d    	bl	0x700af970 <xTaskGetCurrentTaskHandle> @ imm = #0x6fa
700af276: b120         	cbz	r0, 0x700af282 <tm_thread_exit+0x12> @ imm = #0x8
;       vTaskDelete(NULL);
700af278: 2000         	movs	r0, #0x0
700af27a: e8bd 4080    	pop.w	{r7, lr}
700af27e: f7f7 b86f    	b.w	0x700a6360 <vTaskDelete> @ imm = #-0x8f22
;       printf("Error: tm_thread_exit called outside of a task context\r\n");
700af282: f641 11b2    	movw	r1, #0x19b2
700af286: 2001         	movs	r0, #0x1
700af288: f2c7 010b    	movt	r1, #0x700b
700af28c: f7fa fc68    	bl	0x700a9b60 <_DebugP_logZone> @ imm = #-0x5730
;       for (;;)
700af290: e7fe         	b	0x700af290 <tm_thread_exit+0x20> @ imm = #-0x4
		...
700af29e: 0000         	movs	r0, r0

700af2a0 <ClockP_usecToTicks>:
; {
700af2a0: b580         	push	{r7, lr}
700af2a2: b082         	sub	sp, #0x8
700af2a4: 9101         	str	r1, [sp, #0x4]
700af2a6: 9000         	str	r0, [sp]
;     return (uint32_t)(usecs / gClockCtrl.usecPerTick);
700af2a8: 9800         	ldr	r0, [sp]
700af2aa: 9901         	ldr	r1, [sp, #0x4]
700af2ac: f245 0210    	movw	r2, #0x5010
700af2b0: f2c7 0208    	movt	r2, #0x7008
700af2b4: 6892         	ldr	r2, [r2, #0x8]
700af2b6: 2300         	movs	r3, #0x0
700af2b8: f7ff ef4c    	blx	0x700af154 <__aeabi_uldivmod> @ imm = #-0x168
700af2bc: b002         	add	sp, #0x8
700af2be: bd80         	pop	{r7, pc}

700af2c0 <HW_RD_FIELD32_RAW>:
; {
700af2c0: b084         	sub	sp, #0x10
700af2c2: 9003         	str	r0, [sp, #0xc]
700af2c4: 9102         	str	r1, [sp, #0x8]
700af2c6: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700af2c8: 9803         	ldr	r0, [sp, #0xc]
700af2ca: 6800         	ldr	r0, [r0]
700af2cc: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af2ce: 9800         	ldr	r0, [sp]
700af2d0: 9902         	ldr	r1, [sp, #0x8]
700af2d2: 4008         	ands	r0, r1
700af2d4: 9901         	ldr	r1, [sp, #0x4]
700af2d6: 40c8         	lsrs	r0, r1
700af2d8: 9000         	str	r0, [sp]
;     return (regVal);
700af2da: 9800         	ldr	r0, [sp]
700af2dc: b004         	add	sp, #0x10
700af2de: 4770         	bx	lr

700af2e0 <Sciclient_getRxThreadId>:
; {
700af2e0: b082         	sub	sp, #0x8
700af2e2: 9001         	str	r0, [sp, #0x4]
;     rxThread = gSciclientMap[contextId].respThreadId;
700af2e4: 9801         	ldr	r0, [sp, #0x4]
700af2e6: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af2ea: f241 3020    	movw	r0, #0x1320
700af2ee: f2c7 000b    	movt	r0, #0x700b
700af2f2: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700af2f6: 68c0         	ldr	r0, [r0, #0xc]
700af2f8: 9000         	str	r0, [sp]
;     return rxThread;
700af2fa: 9800         	ldr	r0, [sp]
700af2fc: b002         	add	sp, #0x8
700af2fe: 4770         	bx	lr

700af300 <Sciclient_getTxThreadId>:
; {
700af300: b082         	sub	sp, #0x8
700af302: 9001         	str	r0, [sp, #0x4]
;     txThread = gSciclientMap[contextId].reqLowPrioThreadId;
700af304: 9801         	ldr	r0, [sp, #0x4]
700af306: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af30a: f241 3020    	movw	r0, #0x1320
700af30e: f2c7 000b    	movt	r0, #0x700b
700af312: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700af316: 6880         	ldr	r0, [r0, #0x8]
700af318: 9000         	str	r0, [sp]
;     return txThread;
700af31a: 9800         	ldr	r0, [sp]
700af31c: b002         	add	sp, #0x8
700af31e: 4770         	bx	lr

700af320 <tm_mutex_put>:
; {
700af320: b580         	push	{r7, lr}
;    status = xSemaphoreGive(tm_mutex_array[mutex_id]);
700af322: f245 111c    	movw	r1, #0x511c
700af326: 2200         	movs	r2, #0x0
700af328: f2c7 0108    	movt	r1, #0x7008
700af32c: 2300         	movs	r3, #0x0
700af32e: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700af332: 2100         	movs	r1, #0x0
700af334: f7f3 ff04    	bl	0x700a3140 <xQueueGenericSend> @ imm = #-0xc1f8
;    return (status == pdTRUE) ? TM_SUCCESS : TM_ERROR;
700af338: 3801         	subs	r0, #0x1
700af33a: bf18         	it	ne
700af33c: 2001         	movne	r0, #0x1
700af33e: bd80         	pop	{r7, pc}

700af340 <vPortFree>:
; {
700af340: b580         	push	{r7, lr}
700af342: b082         	sub	sp, #0x8
700af344: 9001         	str	r0, [sp, #0x4]
;     if( pv )
700af346: 9801         	ldr	r0, [sp, #0x4]
700af348: b140         	cbz	r0, 0x700af35c <vPortFree+0x1c> @ imm = #0x10
700af34a: e7ff         	b	0x700af34c <vPortFree+0xc> @ imm = #-0x2
;         vTaskSuspendAll();
700af34c: f000 fc18    	bl	0x700afb80 <vTaskSuspendAll> @ imm = #0x830
;             free( pv );
700af350: 9801         	ldr	r0, [sp, #0x4]
700af352: f7f0 eca8    	blx	0x7009fca4 <free>       @ imm = #-0xf6b0
;         ( void ) xTaskResumeAll();
700af356: f7f2 fec3    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0xd27a
;     }
700af35a: e7ff         	b	0x700af35c <vPortFree+0x1c> @ imm = #-0x2
; }
700af35c: b002         	add	sp, #0x8
700af35e: bd80         	pop	{r7, pc}

700af360 <wcslen>:
700af360: e3a01000     	mov	r1, #0
700af364: e7902001     	ldr	r2, [r0, r1]
700af368: e2811004     	add	r1, r1, #4
700af36c: e3520000     	cmp	r2, #0
700af370: 1afffffb     	bne	0x700af364 <wcslen+0x4> @ imm = #-0x14
700af374: e2410004     	sub	r0, r1, #4
700af378: e1a00140     	asr	r0, r0, #2
700af37c: e12fff1e     	bx	lr

700af380 <CSL_udmapCppi5SetEpiDataPresent>:
; {
700af380: b082         	sub	sp, #0x8
700af382: 9001         	str	r0, [sp, #0x4]
700af384: f88d 1003    	strb.w	r1, [sp, #0x3]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_EINFO, (bEpiDataPresent==(bool)true) ? (uint32_t)1U : (uint32_t)0U );
700af388: 9901         	ldr	r1, [sp, #0x4]
700af38a: 6808         	ldr	r0, [r1]
700af38c: f020 5000    	bic	r0, r0, #0x20000000
700af390: f89d 2003    	ldrb.w	r2, [sp, #0x3]
700af394: f362 705d    	bfi	r0, r2, #29, #1
700af398: 6008         	str	r0, [r1]
; }
700af39a: b002         	add	sp, #0x8
700af39c: 4770         	bx	lr
700af39e: 0000         	movs	r0, r0

700af3a0 <DebugP_memLogWriterInit>:
; {
700af3a0: b580         	push	{r7, lr}
700af3a2: b082         	sub	sp, #0x8
700af3a4: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     gDebugP_memTraceLogWriterSelfCoreName = SOC_getCoreName(selfCoreId);
700af3a8: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700af3ac: f7fe ff30    	bl	0x700ae210 <SOC_getCoreName> @ imm = #-0x11a0
700af3b0: f642 11e0    	movw	r1, #0x29e0
700af3b4: f2c7 010b    	movt	r1, #0x700b
700af3b8: 6008         	str	r0, [r1]
; }
700af3ba: b002         	add	sp, #0x8
700af3bc: bd80         	pop	{r7, pc}
700af3be: 0000         	movs	r0, r0

700af3c0 <Sciclient_rmPsGetIrqNode>:
; {
700af3c0: b081         	sub	sp, #0x4
700af3c2: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return gPstack.ps[index].p_n;
700af3c6: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700af3ca: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af3ce: f241 0058    	movw	r0, #0x1058
700af3d2: f2c7 0008    	movt	r0, #0x7008
700af3d6: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700af3da: b001         	add	sp, #0x4
700af3dc: 4770         	bx	lr
700af3de: 0000         	movs	r0, r0

700af3e0 <Sciclient_rmPsInit>:
; {
700af3e0: b580         	push	{r7, lr}
700af3e2: b082         	sub	sp, #0x8
;     memset(&gPstack.ps[0], 0, sizeof(gPstack.ps));
700af3e4: f241 0058    	movw	r0, #0x1058
700af3e8: f2c7 0008    	movt	r0, #0x7008
700af3ec: 9001         	str	r0, [sp, #0x4]
700af3ee: 2124         	movs	r1, #0x24
700af3f0: f7eb edd0    	blx	0x7009af94 <__aeabi_memclr8> @ imm = #-0x14460
700af3f4: 9901         	ldr	r1, [sp, #0x4]
700af3f6: 2000         	movs	r0, #0x0
;     gPstack.psp = 0;
700af3f8: 8488         	strh	r0, [r1, #0x24]
; }
700af3fa: b002         	add	sp, #0x8
700af3fc: bd80         	pop	{r7, pc}
700af3fe: 0000         	movs	r0, r0

700af400 <UART_breakCtl>:
; {
700af400: b580         	push	{r7, lr}
700af402: b082         	sub	sp, #0x8
700af404: 9001         	str	r0, [sp, #0x4]
700af406: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_BREAK_EN,
700af408: 9801         	ldr	r0, [sp, #0x4]
700af40a: 300c         	adds	r0, #0xc
700af40c: 9900         	ldr	r1, [sp]
700af40e: ea4f 1391    	lsr.w	r3, r1, #0x6
700af412: 2140         	movs	r1, #0x40
700af414: 2206         	movs	r2, #0x6
700af416: f7ff f8f3    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #-0xe1a
; }
700af41a: b002         	add	sp, #0x8
700af41c: bd80         	pop	{r7, pc}
700af41e: 0000         	movs	r0, r0

700af420 <UART_lld_Transaction_deInit>:
; {
700af420: b081         	sub	sp, #0x4
700af422: 9000         	str	r0, [sp]
;     trans->buf              = NULL;
700af424: 9900         	ldr	r1, [sp]
700af426: 2000         	movs	r0, #0x0
700af428: 6008         	str	r0, [r1]
;     trans->count            = 0U;
700af42a: 9900         	ldr	r1, [sp]
700af42c: 6048         	str	r0, [r1, #0x4]
;     trans->timeout          = 0U;
700af42e: 9900         	ldr	r1, [sp]
700af430: 6088         	str	r0, [r1, #0x8]
;     trans->status           = UART_STATUS_SUCCESS;
700af432: 9900         	ldr	r1, [sp]
700af434: 60c8         	str	r0, [r1, #0xc]
;     trans->args             = NULL;
700af436: 9900         	ldr	r1, [sp]
700af438: 6108         	str	r0, [r1, #0x10]
; }
700af43a: b001         	add	sp, #0x4
700af43c: 4770         	bx	lr
700af43e: 0000         	movs	r0, r0

700af440 <UART_writeInterrupt>:
; {
700af440: b580         	push	{r7, lr}
700af442: b084         	sub	sp, #0x10
700af444: 9003         	str	r0, [sp, #0xc]
700af446: 2000         	movs	r0, #0x0
;     int32_t     status = UART_STATUS_SUCCESS;
700af448: 9002         	str	r0, [sp, #0x8]
;     baseAddr = hUart->baseAddr;
700af44a: 9803         	ldr	r0, [sp, #0xc]
700af44c: 6800         	ldr	r0, [r0]
700af44e: 9001         	str	r0, [sp, #0x4]
;     UART_intrEnable(baseAddr, UART_INTR_THR);
700af450: 9801         	ldr	r0, [sp, #0x4]
700af452: 2102         	movs	r1, #0x2
700af454: f7f6 fdc4    	bl	0x700a5fe0 <UART_intrEnable> @ imm = #-0x9478
;     return status;
700af458: 9802         	ldr	r0, [sp, #0x8]
700af45a: b004         	add	sp, #0x10
700af45c: bd80         	pop	{r7, pc}
700af45e: 0000         	movs	r0, r0

700af460 <UdmaChPdmaPrms_init>:
; {
700af460: b081         	sub	sp, #0x4
700af462: 9000         	str	r0, [sp]
;     if(NULL_PTR != pdmaPrms)
700af464: 9800         	ldr	r0, [sp]
700af466: b140         	cbz	r0, 0x700af47a <UdmaChPdmaPrms_init+0x1a> @ imm = #0x10
700af468: e7ff         	b	0x700af46a <UdmaChPdmaPrms_init+0xa> @ imm = #-0x2
;         pdmaPrms->elemSize  = UDMA_PDMA_ES_8BITS;
700af46a: 9900         	ldr	r1, [sp]
700af46c: 2000         	movs	r0, #0x0
700af46e: 6008         	str	r0, [r1]
;         pdmaPrms->elemCnt   = 0U;
700af470: 9900         	ldr	r1, [sp]
700af472: 6048         	str	r0, [r1, #0x4]
;         pdmaPrms->fifoCnt   = 0U;
700af474: 9900         	ldr	r1, [sp]
700af476: 6088         	str	r0, [r1, #0x8]
;     }
700af478: e7ff         	b	0x700af47a <UdmaChPdmaPrms_init+0x1a> @ imm = #-0x2
;     return;
700af47a: b001         	add	sp, #0x4
700af47c: 4770         	bx	lr
700af47e: 0000         	movs	r0, r0

700af480 <prvTimerTask>:
;     {
700af480: b580         	push	{r7, lr}
700af482: b084         	sub	sp, #0x10
700af484: 9003         	str	r0, [sp, #0xc]
;         for( ; ; )
700af486: e7ff         	b	0x700af488 <prvTimerTask+0x8> @ imm = #-0x2
700af488: a801         	add	r0, sp, #0x4
;             xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
700af48a: f7fe fbe1    	bl	0x700adc50 <prvGetNextExpireTime> @ imm = #-0x183e
700af48e: 9002         	str	r0, [sp, #0x8]
;             prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
700af490: 9802         	ldr	r0, [sp, #0x8]
700af492: 9901         	ldr	r1, [sp, #0x4]
700af494: f7fa ffec    	bl	0x700aa470 <prvProcessTimerOrBlockTask> @ imm = #-0x5028
;             prvProcessReceivedCommands();
700af498: f7f3 faa2    	bl	0x700a29e0 <prvProcessReceivedCommands> @ imm = #-0xcabc
;         for( ; ; )
700af49c: e7f4         	b	0x700af488 <prvTimerTask+0x8> @ imm = #-0x18
700af49e: 0000         	movs	r0, r0

700af4a0 <tm_mutex_get>:
; {
700af4a0: b580         	push	{r7, lr}
;    status = xSemaphoreTake(tm_mutex_array[mutex_id], portMAX_DELAY);
700af4a2: f245 111c    	movw	r1, #0x511c
700af4a6: f2c7 0108    	movt	r1, #0x7008
700af4aa: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700af4ae: f04f 31ff    	mov.w	r1, #0xffffffff
700af4b2: f7f1 fe55    	bl	0x700a1160 <xQueueSemaphoreTake> @ imm = #-0xe356
;    return (status == pdTRUE) ? TM_SUCCESS : TM_ERROR;
700af4b6: 3801         	subs	r0, #0x1
700af4b8: bf18         	it	ne
700af4ba: 2001         	movne	r0, #0x1
700af4bc: bd80         	pop	{r7, pc}
700af4be: 0000         	movs	r0, r0

700af4c0 <xPortStartScheduler>:
; BaseType_t xPortStartScheduler(void) {
700af4c0: b580         	push	{r7, lr}
700af4c2: b082         	sub	sp, #0x8
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700af4c4: b672         	cpsid i
;   ulPortSchedularRunning = pdTRUE;
700af4c6: f642 2110    	movw	r1, #0x2a10
700af4ca: f2c7 010b    	movt	r1, #0x700b
700af4ce: 2001         	movs	r0, #0x1
700af4d0: 9001         	str	r0, [sp, #0x4]
700af4d2: 6008         	str	r0, [r1]
;   vPortRestoreTaskContext();
700af4d4: f001 e92e    	blx	0x700b0734 <vPortRestoreTaskContext> @ imm = #0x125c
700af4d8: 9801         	ldr	r0, [sp, #0x4]
;   return pdTRUE;
700af4da: b002         	add	sp, #0x8
700af4dc: bd80         	pop	{r7, pc}
700af4de: 0000         	movs	r0, r0

700af4e0 <xTaskGetTickCount>:
; TickType_t xTaskGetTickCount(void) {
700af4e0: b580         	push	{r7, lr}
700af4e2: b082         	sub	sp, #0x8
;   portTICK_TYPE_ENTER_CRITICAL();
700af4e4: f7ff f8ec    	bl	0x700ae6c0 <vTaskEnterCritical> @ imm = #-0xe28
;     xTicks = xTickCount;
700af4e8: f642 2044    	movw	r0, #0x2a44
700af4ec: f2c7 000b    	movt	r0, #0x700b
700af4f0: 6800         	ldr	r0, [r0]
700af4f2: 9001         	str	r0, [sp, #0x4]
;   portTICK_TYPE_EXIT_CRITICAL();
700af4f4: f7fe f984    	bl	0x700ad800 <vTaskExitCritical> @ imm = #-0x1cf8
;   return xTicks;
700af4f8: 9801         	ldr	r0, [sp, #0x4]
700af4fa: b002         	add	sp, #0x8
700af4fc: bd80         	pop	{r7, pc}
700af4fe: 0000         	movs	r0, r0

700af500 <CSL_secProxyGetDataAddr>:
; {
700af500: b084         	sub	sp, #0x10
700af502: 9003         	str	r0, [sp, #0xc]
700af504: 9102         	str	r1, [sp, #0x8]
700af506: 9201         	str	r2, [sp, #0x4]
;     dataAddr = (uintptr_t)pSecProxyCfg->proxyTargetAddr + ((uintptr_t)threadNum * CSL_SEC_PROXY_TARGET_CHAN_SIZE) + (uintptr_t)CSL_SEC_PROXY_RSVD_MSG_BYTES;
700af508: 9803         	ldr	r0, [sp, #0xc]
700af50a: 6900         	ldr	r0, [r0, #0x10]
700af50c: 9902         	ldr	r1, [sp, #0x8]
700af50e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700af512: 3004         	adds	r0, #0x4
700af514: 9000         	str	r0, [sp]
;     return dataAddr;
700af516: 9800         	ldr	r0, [sp]
700af518: b004         	add	sp, #0x10
700af51a: 4770         	bx	lr
700af51c: 0000         	movs	r0, r0
700af51e: 0000         	movs	r0, r0

700af520 <UART_IsParameter>:
; {
700af520: b082         	sub	sp, #0x8
700af522: 9001         	str	r0, [sp, #0x4]
700af524: 2000         	movs	r0, #0x0
;     int32_t status = UART_STATUS_SUCCESS;
700af526: 9000         	str	r0, [sp]
;     if(InuptParameter == 0U)
700af528: 9801         	ldr	r0, [sp, #0x4]
700af52a: b920         	cbnz	r0, 0x700af536 <UART_IsParameter+0x16> @ imm = #0x8
700af52c: e7ff         	b	0x700af52e <UART_IsParameter+0xe> @ imm = #-0x2
700af52e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700af532: 9000         	str	r0, [sp]
;     }
700af534: e7ff         	b	0x700af536 <UART_IsParameter+0x16> @ imm = #-0x2
;     return status;
700af536: 9800         	ldr	r0, [sp]
700af538: b002         	add	sp, #0x8
700af53a: 4770         	bx	lr
700af53c: 0000         	movs	r0, r0
700af53e: 0000         	movs	r0, r0

700af540 <pvPortMalloc>:
; {
700af540: b580         	push	{r7, lr}
700af542: b082         	sub	sp, #0x8
700af544: 9001         	str	r0, [sp, #0x4]
;     vTaskSuspendAll();
700af546: f000 fb1b    	bl	0x700afb80 <vTaskSuspendAll> @ imm = #0x636
;         pvReturn = malloc( xWantedSize );
700af54a: 9801         	ldr	r0, [sp, #0x4]
700af54c: f7ed ee12    	blx	0x7009d174 <malloc>     @ imm = #-0x123dc
700af550: 9000         	str	r0, [sp]
;     ( void ) xTaskResumeAll();
700af552: f7f2 fdc5    	bl	0x700a20e0 <xTaskResumeAll> @ imm = #-0xd476
;     return pvReturn;
700af556: 9800         	ldr	r0, [sp]
700af558: b002         	add	sp, #0x8
700af55a: bd80         	pop	{r7, pc}

700af55c <strlen>:
700af55c: e3a01000     	mov	r1, #0
700af560: e7d02001     	ldrb	r2, [r0, r1]
700af564: e2811001     	add	r1, r1, #1
700af568: e3520000     	cmp	r2, #0
700af56c: 1afffffb     	bne	0x700af560 <strlen+0x4> @ imm = #-0x14
700af570: e2410001     	sub	r0, r1, #1
700af574: e12fff1e     	bx	lr
		...

700af580 <vPortYeildFromISR>:
; void vPortYeildFromISR(uint32_t xSwitchRequired) {
700af580: b081         	sub	sp, #0x4
700af582: 9000         	str	r0, [sp]
;   if (xSwitchRequired != pdFALSE) {
700af584: 9800         	ldr	r0, [sp]
700af586: b138         	cbz	r0, 0x700af598 <vPortYeildFromISR+0x18> @ imm = #0xe
700af588: e7ff         	b	0x700af58a <vPortYeildFromISR+0xa> @ imm = #-0x2
;     ulPortYieldRequired = pdTRUE;
700af58a: f642 2118    	movw	r1, #0x2a18
700af58e: f2c7 010b    	movt	r1, #0x700b
700af592: 2001         	movs	r0, #0x1
700af594: 6008         	str	r0, [r1]
;   }
700af596: e7ff         	b	0x700af598 <vPortYeildFromISR+0x18> @ imm = #-0x2
; }
700af598: b001         	add	sp, #0x4
700af59a: 4770         	bx	lr

700af59c <TI_memcpy_small>:
700af59c: e3a0c000     	mov	r12, #0

700af5a0 <_loop>:
700af5a0: e152000c     	cmp	r2, r12
700af5a4: 012fff1e     	bxeq	lr
700af5a8: e7d1300c     	ldrb	r3, [r1, r12]
700af5ac: e7c0300c     	strb	r3, [r0, r12]
700af5b0: e28cc001     	add	r12, r12, #1
700af5b4: eafffff9     	b	0x700af5a0 <_loop>      @ imm = #-0x1c
		...

700af5c0 <CSL_udmapCppi5SetDescType>:
; {
700af5c0: b082         	sub	sp, #0x8
700af5c2: 9001         	str	r0, [sp, #0x4]
700af5c4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_DTYPE, descType );
700af5c6: 9901         	ldr	r1, [sp, #0x4]
700af5c8: 6808         	ldr	r0, [r1]
700af5ca: f020 4040    	bic	r0, r0, #0xc0000000
700af5ce: 9a00         	ldr	r2, [sp]
700af5d0: ea40 7082    	orr.w	r0, r0, r2, lsl #30
700af5d4: 6008         	str	r0, [r1]
; }
700af5d6: b002         	add	sp, #0x8
700af5d8: 4770         	bx	lr
700af5da: 0000         	movs	r0, r0
700af5dc: 0000         	movs	r0, r0
700af5de: 0000         	movs	r0, r0

700af5e0 <UART_fifoCharGet>:
; {
700af5e0: b580         	push	{r7, lr}
700af5e2: b082         	sub	sp, #0x8
700af5e4: 9001         	str	r0, [sp, #0x4]
700af5e6: 2000         	movs	r0, #0x0
;     uint32_t tempRetVal = 0U;
700af5e8: 9000         	str	r0, [sp]
;     tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700af5ea: 9801         	ldr	r0, [sp, #0x4]
700af5ec: f000 faa0    	bl	0x700afb30 <HW_RD_REG32_RAW> @ imm = #0x540
700af5f0: 9000         	str	r0, [sp]
;     return ((uint8_t) tempRetVal);
700af5f2: f89d 0000    	ldrb.w	r0, [sp]
700af5f6: b002         	add	sp, #0x8
700af5f8: bd80         	pop	{r7, pc}
700af5fa: 0000         	movs	r0, r0
700af5fc: 0000         	movs	r0, r0
700af5fe: 0000         	movs	r0, r0

700af600 <UART_timeGuardConfig>:
; {
700af600: b580         	push	{r7, lr}
700af602: b082         	sub	sp, #0x8
700af604: 9001         	str	r0, [sp, #0x4]
700af606: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_TIMEGUARD, UART_TIMEGUARD_TIMEGUARD,
700af608: 9801         	ldr	r0, [sp, #0x4]
700af60a: 3094         	adds	r0, #0x94
700af60c: 9b00         	ldr	r3, [sp]
700af60e: 21ff         	movs	r1, #0xff
700af610: 2200         	movs	r2, #0x0
700af612: f7fe fff5    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #-0x1016
; }
700af616: b002         	add	sp, #0x8
700af618: bd80         	pop	{r7, pc}
700af61a: 0000         	movs	r0, r0
700af61c: 0000         	movs	r0, r0
700af61e: 0000         	movs	r0, r0

700af620 <CSL_udmapCppi5SetPsDataLen>:
; {
700af620: b082         	sub	sp, #0x8
700af622: 9001         	str	r0, [sp, #0x4]
700af624: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSWCNT, (psDataLen/4U) );
700af626: 9901         	ldr	r1, [sp, #0x4]
700af628: 6808         	ldr	r0, [r1]
700af62a: 9a00         	ldr	r2, [sp]
700af62c: 0892         	lsrs	r2, r2, #0x2
700af62e: f362 509b    	bfi	r0, r2, #22, #6
700af632: 6008         	str	r0, [r1]
; }
700af634: b002         	add	sp, #0x8
700af636: 4770         	bx	lr
		...

700af640 <Sciclient_rmIrqSet>:
; {
700af640: b580         	push	{r7, lr}
700af642: b084         	sub	sp, #0x10
700af644: 9003         	str	r0, [sp, #0xc]
700af646: 9102         	str	r1, [sp, #0x8]
700af648: 9201         	str	r2, [sp, #0x4]
;     return Sciclient_rmProgramInterruptRoute(req, resp, timeout);
700af64a: 9803         	ldr	r0, [sp, #0xc]
700af64c: 9902         	ldr	r1, [sp, #0x8]
700af64e: 9a01         	ldr	r2, [sp, #0x4]
700af650: f7f1 f8e6    	bl	0x700a0820 <Sciclient_rmProgramInterruptRoute> @ imm = #-0xee34
700af654: b004         	add	sp, #0x10
700af656: bd80         	pop	{r7, pc}
		...

700af660 <Sciclient_secProxyThreadStatusReg>:
; {
700af660: b081         	sub	sp, #0x4
700af662: 9000         	str	r0, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700af664: f642 00c0    	movw	r0, #0x28c0
700af668: f2c7 000b    	movt	r0, #0x700b
700af66c: 6880         	ldr	r0, [r0, #0x8]
;         CSL_SEC_PROXY_RT_THREAD_STATUS(thread));
700af66e: 9900         	ldr	r1, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700af670: eb00 3001    	add.w	r0, r0, r1, lsl #12
700af674: b001         	add	sp, #0x4
700af676: 4770         	bx	lr
		...

700af680 <TimerP_start>:
; {
700af680: b082         	sub	sp, #0x8
700af682: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (uint32_t *)(baseAddr + TIMER_TCLR);
700af684: 9801         	ldr	r0, [sp, #0x4]
700af686: 3038         	adds	r0, #0x38
700af688: 9000         	str	r0, [sp]
;     *addr |= (0x1U << 0);
700af68a: 9900         	ldr	r1, [sp]
700af68c: 6808         	ldr	r0, [r1]
700af68e: f040 0001    	orr	r0, r0, #0x1
700af692: 6008         	str	r0, [r1]
; }
700af694: b002         	add	sp, #0x8
700af696: 4770         	bx	lr
		...

700af6a0 <TimerP_stop>:
; {
700af6a0: b082         	sub	sp, #0x8
700af6a2: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
700af6a4: 9801         	ldr	r0, [sp, #0x4]
700af6a6: 3038         	adds	r0, #0x38
700af6a8: 9000         	str	r0, [sp]
;     *addr &= ~(0x1U << 0);
700af6aa: 9900         	ldr	r1, [sp]
700af6ac: 6808         	ldr	r0, [r1]
700af6ae: f020 0001    	bic	r0, r0, #0x1
700af6b2: 6008         	str	r0, [r1]
; }
700af6b4: b002         	add	sp, #0x8
700af6b6: 4770         	bx	lr
		...

700af6c0 <UART_divisorLatchDisable>:
; {
700af6c0: b580         	push	{r7, lr}
700af6c2: b082         	sub	sp, #0x8
700af6c4: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_DIV_EN,
700af6c6: 9801         	ldr	r0, [sp, #0x4]
700af6c8: 300c         	adds	r0, #0xc
700af6ca: 2180         	movs	r1, #0x80
700af6cc: 2207         	movs	r2, #0x7
700af6ce: 2300         	movs	r3, #0x0
700af6d0: f7fe ff96    	bl	0x700ae600 <HW_WR_FIELD32_RAW> @ imm = #-0x10d4
; }
700af6d4: b002         	add	sp, #0x8
700af6d6: bd80         	pop	{r7, pc}
		...

700af6e0 <UART_modemControlReset>:
; {
700af6e0: b580         	push	{r7, lr}
700af6e2: b082         	sub	sp, #0x8
700af6e4: 9001         	str	r0, [sp, #0x4]
700af6e6: 2000         	movs	r0, #0x0
;     uint32_t mcrResetVal = 0U;
700af6e8: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_MCR, mcrResetVal);
700af6ea: 9801         	ldr	r0, [sp, #0x4]
700af6ec: 3010         	adds	r0, #0x10
700af6ee: 9900         	ldr	r1, [sp]
700af6f0: f000 fa26    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x44c
; }
700af6f4: b002         	add	sp, #0x8
700af6f6: bd80         	pop	{r7, pc}
		...

700af700 <UART_putChar>:
; {
700af700: b580         	push	{r7, lr}
700af702: b082         	sub	sp, #0x8
700af704: 9001         	str	r0, [sp, #0x4]
700af706: f88d 1003    	strb.w	r1, [sp, #0x3]
;     HW_WR_REG32(baseAddr + UART_THR, (uint32_t) byteTx);
700af70a: 9801         	ldr	r0, [sp, #0x4]
700af70c: f89d 1003    	ldrb.w	r1, [sp, #0x3]
700af710: f000 fa16    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x42c
; }
700af714: b002         	add	sp, #0x8
700af716: bd80         	pop	{r7, pc}
		...

700af720 <tm_task_priority_get>:
; {
700af720: b580         	push	{r7, lr}
;    UBaseType_t freertos_priority = uxTaskPriorityGet(tm_thread_array[thread_id]);
700af722: f245 0148    	movw	r1, #0x5048
700af726: f2c7 0108    	movt	r1, #0x7008
700af72a: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700af72e: f7fe fdcf    	bl	0x700ae2d0 <uxTaskPriorityGet> @ imm = #-0x1462
;    return (int) (configMAX_PRIORITIES - freertos_priority + 1);
700af732: f1c0 0021    	rsb.w	r0, r0, #0x21
700af736: bd80         	pop	{r7, pc}

700af738 <TI_memset_small>:
700af738: e3a03000     	mov	r3, #0

700af73c <_loop>:
700af73c: e1520003     	cmp	r2, r3
700af740: 012fff1e     	bxeq	lr
700af744: e7c01003     	strb	r1, [r0, r3]
700af748: e2833001     	add	r3, r3, #1
700af74c: eafffffa     	b	0x700af73c <_loop>      @ imm = #-0x18

700af750 <CSL_REG64_WR_RAW>:
; {
700af750: b084         	sub	sp, #0x10
700af752: 9003         	str	r0, [sp, #0xc]
700af754: 9301         	str	r3, [sp, #0x4]
700af756: 9200         	str	r2, [sp]
;     *p = v;
700af758: 9800         	ldr	r0, [sp]
700af75a: 9901         	ldr	r1, [sp, #0x4]
700af75c: 9a03         	ldr	r2, [sp, #0xc]
700af75e: e9c2 0100    	strd	r0, r1, [r2]
;     return;
700af762: b004         	add	sp, #0x10
700af764: 4770         	bx	lr
		...
700af76e: 0000         	movs	r0, r0

700af770 <CSL_udmapCppi5LinkDesc>:
; {
700af770: b084         	sub	sp, #0x10
700af772: 9003         	str	r0, [sp, #0xc]
700af774: 9301         	str	r3, [sp, #0x4]
700af776: 9200         	str	r2, [sp]
;     pDesc->nextDescPtr = physBufferDescAddr;
700af778: 9800         	ldr	r0, [sp]
700af77a: 9a01         	ldr	r2, [sp, #0x4]
700af77c: 9903         	ldr	r1, [sp, #0xc]
700af77e: 614a         	str	r2, [r1, #0x14]
700af780: 6108         	str	r0, [r1, #0x10]
; }
700af782: b004         	add	sp, #0x10
700af784: 4770         	bx	lr
		...
700af78e: 0000         	movs	r0, r0

700af790 <CSL_udmapCppi5SetBufferAddr>:
; {
700af790: b084         	sub	sp, #0x10
700af792: 9003         	str	r0, [sp, #0xc]
700af794: 9301         	str	r3, [sp, #0x4]
700af796: 9200         	str	r2, [sp]
;     pDesc->bufPtr    = physBufferAddr;
700af798: 9800         	ldr	r0, [sp]
700af79a: 9a01         	ldr	r2, [sp, #0x4]
700af79c: 9903         	ldr	r1, [sp, #0xc]
700af79e: 61ca         	str	r2, [r1, #0x1c]
700af7a0: 6188         	str	r0, [r1, #0x18]
; }
700af7a2: b004         	add	sp, #0x10
700af7a4: 4770         	bx	lr
		...
700af7ae: 0000         	movs	r0, r0

700af7b0 <CSL_udmapCppi5SetBufferLen>:
; {
700af7b0: b082         	sub	sp, #0x8
700af7b2: 9001         	str	r0, [sp, #0x4]
700af7b4: 9100         	str	r1, [sp]
;     CSL_FINS( pDesc->bufInfo1, UDMAP_CPPI5_PD_BUFINFO1_LEN, bufferLenBytes );
700af7b6: 9901         	ldr	r1, [sp, #0x4]
700af7b8: 6a08         	ldr	r0, [r1, #0x20]
700af7ba: 9a00         	ldr	r2, [sp]
700af7bc: f362 0015    	bfi	r0, r2, #0, #22
700af7c0: 6208         	str	r0, [r1, #0x20]
; }
700af7c2: b002         	add	sp, #0x8
700af7c4: 4770         	bx	lr
		...
700af7ce: 0000         	movs	r0, r0

700af7d0 <CSL_udmapCppi5SetOrgBufferAddr>:
; {
700af7d0: b084         	sub	sp, #0x10
700af7d2: 9003         	str	r0, [sp, #0xc]
700af7d4: 9301         	str	r3, [sp, #0x4]
700af7d6: 9200         	str	r2, [sp]
;     pDesc->orgBufPtr = physBufferAddr;
700af7d8: 9800         	ldr	r0, [sp]
700af7da: 9a01         	ldr	r2, [sp, #0x4]
700af7dc: 9903         	ldr	r1, [sp, #0xc]
700af7de: 62ca         	str	r2, [r1, #0x2c]
700af7e0: 6288         	str	r0, [r1, #0x28]
; }
700af7e2: b004         	add	sp, #0x10
700af7e4: 4770         	bx	lr
		...
700af7ee: 0000         	movs	r0, r0

700af7f0 <CSL_udmapCppi5SetPsDataLoc>:
; {
700af7f0: b082         	sub	sp, #0x8
700af7f2: 9001         	str	r0, [sp, #0x4]
700af7f4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSINFO, psLoc );
700af7f6: 9901         	ldr	r1, [sp, #0x4]
700af7f8: 6808         	ldr	r0, [r1]
700af7fa: 9a00         	ldr	r2, [sp]
700af7fc: f362 701c    	bfi	r0, r2, #28, #1
700af800: 6008         	str	r0, [r1]
; }
700af802: b002         	add	sp, #0x8
700af804: 4770         	bx	lr
		...
700af80e: 0000         	movs	r0, r0

700af810 <CSL_udmapCppi5SetPsFlags>:
; {
700af810: b082         	sub	sp, #0x8
700af812: 9001         	str	r0, [sp, #0x4]
700af814: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1, UDMAP_CPPI5_PD_PKTINFO1_PSFLGS, psFlags );
700af816: 9901         	ldr	r1, [sp, #0x4]
700af818: 6848         	ldr	r0, [r1, #0x4]
700af81a: 9a00         	ldr	r2, [sp]
700af81c: f362 601b    	bfi	r0, r2, #24, #4
700af820: 6048         	str	r0, [r1, #0x4]
; }
700af822: b002         	add	sp, #0x8
700af824: 4770         	bx	lr
		...
700af82e: 0000         	movs	r0, r0

700af830 <Sciclient_rmIrqRelease>:
; {
700af830: b580         	push	{r7, lr}
700af832: b084         	sub	sp, #0x10
700af834: 9003         	str	r0, [sp, #0xc]
700af836: 9102         	str	r1, [sp, #0x8]
;     return Sciclient_rmClearInterruptRoute(req, &resp, timeout);
700af838: 9803         	ldr	r0, [sp, #0xc]
700af83a: 9a02         	ldr	r2, [sp, #0x8]
700af83c: 4669         	mov	r1, sp
700af83e: f7f0 fcbf    	bl	0x700a01c0 <Sciclient_rmClearInterruptRoute> @ imm = #-0xf682
700af842: b004         	add	sp, #0x10
700af844: bd80         	pop	{r7, pc}
		...
700af84e: 0000         	movs	r0, r0

700af850 <Sciclient_secProxyReadThreadCount>:
; {
700af850: b580         	push	{r7, lr}
700af852: b082         	sub	sp, #0x8
700af854: 9001         	str	r0, [sp, #0x4]
;     return (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700af856: 9801         	ldr	r0, [sp, #0x4]
700af858: f7ff ff02    	bl	0x700af660 <Sciclient_secProxyThreadStatusReg> @ imm = #-0x1fc
700af85c: f000 f9c8    	bl	0x700afbf0 <CSL_REG32_RD_RAW> @ imm = #0x390
700af860: b2c0         	uxtb	r0, r0
700af862: b002         	add	sp, #0x8
700af864: bd80         	pop	{r7, pc}
		...
700af86e: 0000         	movs	r0, r0

700af870 <SemaphoreP_destruct>:
; {
700af870: b580         	push	{r7, lr}
700af872: b082         	sub	sp, #0x8
700af874: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700af876: 9801         	ldr	r0, [sp, #0x4]
700af878: 9000         	str	r0, [sp]
;     vSemaphoreDelete(pSemaphore->semHndl);
700af87a: 9800         	ldr	r0, [sp]
700af87c: 6d00         	ldr	r0, [r0, #0x50]
700af87e: f7ff faef    	bl	0x700aee60 <vQueueDelete> @ imm = #-0xa22
; }
700af882: b002         	add	sp, #0x8
700af884: bd80         	pop	{r7, pc}
		...
700af88e: 0000         	movs	r0, r0

700af890 <UART_divideRoundCloset>:
; {
700af890: b082         	sub	sp, #0x8
700af892: 9001         	str	r0, [sp, #0x4]
700af894: 9100         	str	r1, [sp]
;     return ((divident + (divisor/2U))/divisor);
700af896: 9801         	ldr	r0, [sp, #0x4]
700af898: 9900         	ldr	r1, [sp]
700af89a: eb00 0051    	add.w	r0, r0, r1, lsr #1
700af89e: fbb0 f0f1    	udiv	r0, r0, r1
700af8a2: b002         	add	sp, #0x8
700af8a4: 4770         	bx	lr
		...
700af8ae: 0000         	movs	r0, r0

700af8b0 <UART_regConfModeRestore>:
; {
700af8b0: b580         	push	{r7, lr}
700af8b2: b082         	sub	sp, #0x8
700af8b4: 9001         	str	r0, [sp, #0x4]
700af8b6: 9100         	str	r1, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700af8b8: 9801         	ldr	r0, [sp, #0x4]
700af8ba: 300c         	adds	r0, #0xc
700af8bc: 9900         	ldr	r1, [sp]
700af8be: f000 f93f    	bl	0x700afb40 <HW_WR_REG32_RAW> @ imm = #0x27e
; }
700af8c2: b002         	add	sp, #0x8
700af8c4: bd80         	pop	{r7, pc}
		...
700af8ce: 0000         	movs	r0, r0

700af8d0 <tm_thread_resume>:
; {
700af8d0: b580         	push	{r7, lr}
;    vTaskResume(tm_thread_array[thread_id]);
700af8d2: f245 0148    	movw	r1, #0x5048
700af8d6: f2c7 0108    	movt	r1, #0x7008
700af8da: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700af8de: f7f8 ff77    	bl	0x700a87d0 <vTaskResume> @ imm = #-0x7112
;    return TM_SUCCESS;
700af8e2: 2000         	movs	r0, #0x0
700af8e4: bd80         	pop	{r7, pc}
		...
700af8ee: 0000         	movs	r0, r0

700af8f0 <tm_thread_suspend>:
; {
700af8f0: b580         	push	{r7, lr}
;    vTaskSuspend(tm_thread_array[thread_id]);
700af8f2: f245 0148    	movw	r1, #0x5048
700af8f6: f2c7 0108    	movt	r1, #0x7008
700af8fa: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700af8fe: f7f5 fa8f    	bl	0x700a4e20 <vTaskSuspend> @ imm = #-0xaae2
;    return TM_SUCCESS;
700af902: 2000         	movs	r0, #0x0
700af904: bd80         	pop	{r7, pc}
		...
700af90e: 0000         	movs	r0, r0

700af910 <DebugP_uartSetDrvIndex>:
; {
700af910: b081         	sub	sp, #0x4
700af912: 9000         	str	r0, [sp]
;     gDebugP_uartDrvIndex = uartDrvIndex;
700af914: 9800         	ldr	r0, [sp]
700af916: f642 11e4    	movw	r1, #0x29e4
700af91a: f2c7 010b    	movt	r1, #0x700b
700af91e: 6008         	str	r0, [r1]
; }
700af920: b001         	add	sp, #0x4
700af922: 4770         	bx	lr
		...

700af930 <Sciclient_rmIrIntControlReg>:
; {
700af930: b081         	sub	sp, #0x4
700af932: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (outp * SCICLIENT_IR_INT_CONTROL_REG_STEP) +
700af936: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700af93a: 2004         	movs	r0, #0x4
700af93c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700af940: b001         	add	sp, #0x4
700af942: 4770         	bx	lr
		...

700af950 <Udma_rmAllocFreeRing>:
; {
700af950: b082         	sub	sp, #0x8
700af952: 9001         	str	r0, [sp, #0x4]
700af954: f64f 70ff    	movw	r0, #0xffff
;     uint16_t            ringNum = UDMA_RING_INVALID;
700af958: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (ringNum);
700af95c: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700af960: b002         	add	sp, #0x8
700af962: 4770         	bx	lr
		...

700af970 <xTaskGetCurrentTaskHandle>:
; TaskHandle_t xTaskGetCurrentTaskHandle(void) {
700af970: b081         	sub	sp, #0x4
;   xReturn = pxCurrentTCB;
700af972: f642 2000    	movw	r0, #0x2a00
700af976: f2c7 000b    	movt	r0, #0x700b
700af97a: 6800         	ldr	r0, [r0]
700af97c: 9000         	str	r0, [sp]
;   return xReturn;
700af97e: 9800         	ldr	r0, [sp]
700af980: b001         	add	sp, #0x4
700af982: 4770         	bx	lr
		...

700af990 <CSL_udmapCppi5SetSrcTag>:
; {
700af990: b082         	sub	sp, #0x8
700af992: 9001         	str	r0, [sp, #0x4]
700af994: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_SRCTAG, srcTag );
700af996: 9901         	ldr	r1, [sp, #0x4]
700af998: f8bd 0000    	ldrh.w	r0, [sp]
700af99c: 81c8         	strh	r0, [r1, #0xe]
; }
700af99e: b002         	add	sp, #0x8
700af9a0: 4770         	bx	lr
		...
700af9ae: 0000         	movs	r0, r0

700af9b0 <TimerP_getCount>:
; {
700af9b0: b082         	sub	sp, #0x8
700af9b2: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
700af9b4: 9801         	ldr	r0, [sp, #0x4]
700af9b6: 303c         	adds	r0, #0x3c
700af9b8: 9000         	str	r0, [sp]
;     return *addr;
700af9ba: 9800         	ldr	r0, [sp]
700af9bc: 6800         	ldr	r0, [r0]
700af9be: b002         	add	sp, #0x8
700af9c0: 4770         	bx	lr
		...
700af9ce: 0000         	movs	r0, r0

700af9d0 <TimerP_getReloadCount>:
; {
700af9d0: b082         	sub	sp, #0x8
700af9d2: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
700af9d4: 9801         	ldr	r0, [sp, #0x4]
700af9d6: 3040         	adds	r0, #0x40
700af9d8: 9000         	str	r0, [sp]
;     return *addr;
700af9da: 9800         	ldr	r0, [sp]
700af9dc: 6800         	ldr	r0, [r0]
700af9de: b002         	add	sp, #0x8
700af9e0: 4770         	bx	lr
		...
700af9ee: 0000         	movs	r0, r0

700af9f0 <main_inheritance>:
; {
700af9f0: b580         	push	{r7, lr}
;    tm_initialize(tm_priority_inheritance_initialize);
700af9f2: f24e 5081    	movw	r0, #0xe581
700af9f6: f2c7 0009    	movt	r0, #0x7009
700af9fa: f000 f9c9    	bl	0x700afd90 <tm_initialize> @ imm = #0x392
;    return 0;
700af9fe: 2000         	movs	r0, #0x0
700afa00: bd80         	pop	{r7, pc}
		...
700afa0e: 0000         	movs	r0, r0

700afa10 <putchar_>:
; {
700afa10: b510         	push	{r4, lr}
700afa12: 4604         	mov	r4, r0
;     DebugP_memLogWriterPutChar(character);
700afa14: f7f2 fcb4    	bl	0x700a2380 <DebugP_memLogWriterPutChar> @ imm = #-0xd698
;     DebugP_uartLogWriterPutChar(character);
700afa18: 4620         	mov	r0, r4
700afa1a: e8bd 4010    	pop.w	{r4, lr}
700afa1e: f7fd be77    	b.w	0x700ad710 <DebugP_uartLogWriterPutChar> @ imm = #-0x2312
		...
700afa2e: 0000         	movs	r0, r0

700afa30 <tm_interrupt_handler>:
;    if (test_interrupt_handler != NULL)
700afa30: f642 2004    	movw	r0, #0x2a04
700afa34: f2c7 000b    	movt	r0, #0x700b
700afa38: 6800         	ldr	r0, [r0]
700afa3a: 2800         	cmp	r0, #0x0
; }
700afa3c: bf08         	it	eq
700afa3e: 4770         	bxeq	lr
;       ((void (*)(void)) test_interrupt_handler)();
700afa40: 4700         	bx	r0
		...
700afa4e: 0000         	movs	r0, r0

700afa50 <tm_setup_pmu>:
; {
700afa50: b580         	push	{r7, lr}
;    PMU_init(&gPmuConfig);
700afa52: f642 1080    	movw	r0, #0x2980
700afa56: f2c7 000b    	movt	r0, #0x700b
700afa5a: f7f0 ffa9    	bl	0x700a09b0 <PMU_init>   @ imm = #-0xf0ae
;    return 1;
700afa5e: 2001         	movs	r0, #0x1
700afa60: bd80         	pop	{r7, pc}
		...
700afa6e: 0000         	movs	r0, r0

700afa70 <uiPortGetRunTimeCounterValue>:
; uint32_t uiPortGetRunTimeCounterValue() {
700afa70: b580         	push	{r7, lr}
700afa72: b082         	sub	sp, #0x8
;   uint64_t timeInUsecs = ClockP_getTimeUsec();
700afa74: f7fa ffac    	bl	0x700aa9d0 <ClockP_getTimeUsec> @ imm = #-0x50a8
700afa78: 9101         	str	r1, [sp, #0x4]
700afa7a: 9000         	str	r0, [sp]
;   return (uint32_t)(timeInUsecs);
700afa7c: 9800         	ldr	r0, [sp]
700afa7e: b002         	add	sp, #0x8
700afa80: bd80         	pop	{r7, pc}
		...
700afa8e: 0000         	movs	r0, r0

700afa90 <CSL_REG32_WR_RAW>:
; {
700afa90: b082         	sub	sp, #0x8
700afa92: 9001         	str	r0, [sp, #0x4]
700afa94: 9100         	str	r1, [sp]
;     *p = v;
700afa96: 9800         	ldr	r0, [sp]
700afa98: 9901         	ldr	r1, [sp, #0x4]
700afa9a: 6008         	str	r0, [r1]
;     return;
700afa9c: b002         	add	sp, #0x8
700afa9e: 4770         	bx	lr

700afaa0 <CSL_REG32_WR_RAW>:
; {
700afaa0: b082         	sub	sp, #0x8
700afaa2: 9001         	str	r0, [sp, #0x4]
700afaa4: 9100         	str	r1, [sp]
;     *p = v;
700afaa6: 9800         	ldr	r0, [sp]
700afaa8: 9901         	ldr	r1, [sp, #0x4]
700afaaa: 6008         	str	r0, [r1]
;     return;
700afaac: b002         	add	sp, #0x8
700afaae: 4770         	bx	lr

700afab0 <CSL_REG32_WR_RAW>:
; {
700afab0: b082         	sub	sp, #0x8
700afab2: 9001         	str	r0, [sp, #0x4]
700afab4: 9100         	str	r1, [sp]
;     *p = v;
700afab6: 9800         	ldr	r0, [sp]
700afab8: 9901         	ldr	r1, [sp, #0x4]
700afaba: 6008         	str	r0, [r1]
;     return;
700afabc: b002         	add	sp, #0x8
700afabe: 4770         	bx	lr

700afac0 <CSL_REG32_WR_RAW>:
; {
700afac0: b082         	sub	sp, #0x8
700afac2: 9001         	str	r0, [sp, #0x4]
700afac4: 9100         	str	r1, [sp]
;     *p = v;
700afac6: 9800         	ldr	r0, [sp]
700afac8: 9901         	ldr	r1, [sp, #0x4]
700afaca: 6008         	str	r0, [r1]
;     return;
700afacc: b002         	add	sp, #0x8
700aface: 4770         	bx	lr

700afad0 <CSL_REG32_WR_RAW>:
; {
700afad0: b082         	sub	sp, #0x8
700afad2: 9001         	str	r0, [sp, #0x4]
700afad4: 9100         	str	r1, [sp]
;     *p = v;
700afad6: 9800         	ldr	r0, [sp]
700afad8: 9901         	ldr	r1, [sp, #0x4]
700afada: 6008         	str	r0, [r1]
;     return;
700afadc: b002         	add	sp, #0x8
700afade: 4770         	bx	lr

700afae0 <CSL_udmapCppi5SetDstTag>:
; {
700afae0: b082         	sub	sp, #0x8
700afae2: 9001         	str	r0, [sp, #0x4]
700afae4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_DSTTAG, dstTag );
700afae6: 9901         	ldr	r1, [sp, #0x4]
700afae8: 9800         	ldr	r0, [sp]
700afaea: 8188         	strh	r0, [r1, #0xc]
; }
700afaec: b002         	add	sp, #0x8
700afaee: 4770         	bx	lr

700afaf0 <CSL_udmapCppi5SetOrgBufferLen>:
; {
700afaf0: b082         	sub	sp, #0x8
700afaf2: 9001         	str	r0, [sp, #0x4]
700afaf4: 9100         	str	r1, [sp]
;     pDesc->orgBufLen = bufferLenBytes;
700afaf6: 9800         	ldr	r0, [sp]
700afaf8: 9901         	ldr	r1, [sp, #0x4]
700afafa: 6248         	str	r0, [r1, #0x24]
; }
700afafc: b002         	add	sp, #0x8
700afafe: 4770         	bx	lr

700afb00 <ClockP_getTimerCount>:
; {
700afb00: b580         	push	{r7, lr}
700afb02: b082         	sub	sp, #0x8
700afb04: 9001         	str	r0, [sp, #0x4]
;     return TimerP_getCount(timerBaseAddr);
700afb06: 9801         	ldr	r0, [sp, #0x4]
700afb08: f7ff ff52    	bl	0x700af9b0 <TimerP_getCount> @ imm = #-0x15c
700afb0c: b002         	add	sp, #0x8
700afb0e: bd80         	pop	{r7, pc}

700afb10 <ClockP_sleepTicks>:
; {
700afb10: b580         	push	{r7, lr}
700afb12: b082         	sub	sp, #0x8
700afb14: 9001         	str	r0, [sp, #0x4]
;     vTaskDelay(ticks);
700afb16: 9801         	ldr	r0, [sp, #0x4]
700afb18: f7fe fc3a    	bl	0x700ae390 <vTaskDelay> @ imm = #-0x178c
; }
700afb1c: b002         	add	sp, #0x8
700afb1e: bd80         	pop	{r7, pc}

700afb20 <ClockP_timerClearOverflowInt>:
; {
700afb20: b580         	push	{r7, lr}
700afb22: b082         	sub	sp, #0x8
700afb24: 9001         	str	r0, [sp, #0x4]
;     TimerP_clearOverflowInt(timerBaseAddr);
700afb26: 9801         	ldr	r0, [sp, #0x4]
700afb28: f7ff f81a    	bl	0x700aeb60 <TimerP_clearOverflowInt> @ imm = #-0xfcc
; }
700afb2c: b002         	add	sp, #0x8
700afb2e: bd80         	pop	{r7, pc}

700afb30 <HW_RD_REG32_RAW>:
; {
700afb30: b082         	sub	sp, #0x8
700afb32: 9001         	str	r0, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700afb34: 9801         	ldr	r0, [sp, #0x4]
700afb36: 6800         	ldr	r0, [r0]
700afb38: 9000         	str	r0, [sp]
;     return (regVal);
700afb3a: 9800         	ldr	r0, [sp]
700afb3c: b002         	add	sp, #0x8
700afb3e: 4770         	bx	lr

700afb40 <HW_WR_REG32_RAW>:
; {
700afb40: b082         	sub	sp, #0x8
700afb42: 9001         	str	r0, [sp, #0x4]
700afb44: 9100         	str	r1, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = value;
700afb46: 9800         	ldr	r0, [sp]
700afb48: 9901         	ldr	r1, [sp, #0x4]
700afb4a: 6008         	str	r0, [r1]
;     return;
700afb4c: b002         	add	sp, #0x8
700afb4e: 4770         	bx	lr

700afb50 <Udma_defaultVirtToPhyFxn>:
; {
700afb50: b083         	sub	sp, #0xc
700afb52: 9002         	str	r0, [sp, #0x8]
700afb54: 9101         	str	r1, [sp, #0x4]
700afb56: 9200         	str	r2, [sp]
;     return ((uint64_t) virtAddr);
700afb58: 9802         	ldr	r0, [sp, #0x8]
700afb5a: 2100         	movs	r1, #0x0
700afb5c: b003         	add	sp, #0xc
700afb5e: 4770         	bx	lr

700afb60 <__aeabi_memset8>:
700afb60: e1a03001     	mov	r3, r1
700afb64: e1a01002     	mov	r1, r2
700afb68: e1a02003     	mov	r2, r3
700afb6c: eafffef1     	b	0x700af738 <TI_memset_small> @ imm = #-0x43c

700afb70 <_out_null>:
; {
700afb70: b084         	sub	sp, #0x10
700afb72: f88d 000f    	strb.w	r0, [sp, #0xf]
700afb76: 9102         	str	r1, [sp, #0x8]
700afb78: 9201         	str	r2, [sp, #0x4]
700afb7a: 9300         	str	r3, [sp]
; }
700afb7c: b004         	add	sp, #0x10
700afb7e: 4770         	bx	lr

700afb80 <vTaskSuspendAll>:
;   ++uxSchedulerSuspended;
700afb80: f642 2124    	movw	r1, #0x2a24
700afb84: f2c7 010b    	movt	r1, #0x700b
700afb88: 6808         	ldr	r0, [r1]
700afb8a: 3001         	adds	r0, #0x1
700afb8c: 6008         	str	r0, [r1]
; }
700afb8e: 4770         	bx	lr

700afb90 <CSL_REG64_RD_RAW>:
; {
700afb90: b081         	sub	sp, #0x4
700afb92: 9000         	str	r0, [sp]
;     return (*p);
700afb94: 9800         	ldr	r0, [sp]
700afb96: e9d0 0100    	ldrd	r0, r1, [r0]
700afb9a: b001         	add	sp, #0x4
700afb9c: 4770         	bx	lr
700afb9e: 0000         	movs	r0, r0

700afba0 <vListInitialiseItem>:
; {
700afba0: b081         	sub	sp, #0x4
700afba2: 9000         	str	r0, [sp]
;     pxItem->pxContainer = NULL;
700afba4: 9900         	ldr	r1, [sp]
700afba6: 2000         	movs	r0, #0x0
700afba8: 6108         	str	r0, [r1, #0x10]
; }
700afbaa: b001         	add	sp, #0x4
700afbac: 4770         	bx	lr
700afbae: 0000         	movs	r0, r0

700afbb0 <vTaskMissedYield>:
; void vTaskMissedYield(void) { xYieldPending = pdTRUE; }
700afbb0: f642 2150    	movw	r1, #0x2a50
700afbb4: f2c7 010b    	movt	r1, #0x700b
700afbb8: 2001         	movs	r0, #0x1
700afbba: 6008         	str	r0, [r1]
700afbbc: 4770         	bx	lr
700afbbe: 0000         	movs	r0, r0

700afbc0 <CSL_REG32_RD_RAW>:
; {
700afbc0: b081         	sub	sp, #0x4
700afbc2: 9000         	str	r0, [sp]
;     return (*p);
700afbc4: 9800         	ldr	r0, [sp]
700afbc6: 6800         	ldr	r0, [r0]
700afbc8: b001         	add	sp, #0x4
700afbca: 4770         	bx	lr
700afbcc: 0000         	movs	r0, r0
700afbce: 0000         	movs	r0, r0

700afbd0 <CSL_REG32_RD_RAW>:
; {
700afbd0: b081         	sub	sp, #0x4
700afbd2: 9000         	str	r0, [sp]
;     return (*p);
700afbd4: 9800         	ldr	r0, [sp]
700afbd6: 6800         	ldr	r0, [r0]
700afbd8: b001         	add	sp, #0x4
700afbda: 4770         	bx	lr
700afbdc: 0000         	movs	r0, r0
700afbde: 0000         	movs	r0, r0

700afbe0 <CSL_REG32_RD_RAW>:
; {
700afbe0: b081         	sub	sp, #0x4
700afbe2: 9000         	str	r0, [sp]
;     return (*p);
700afbe4: 9800         	ldr	r0, [sp]
700afbe6: 6800         	ldr	r0, [r0]
700afbe8: b001         	add	sp, #0x4
700afbea: 4770         	bx	lr
700afbec: 0000         	movs	r0, r0
700afbee: 0000         	movs	r0, r0

700afbf0 <CSL_REG32_RD_RAW>:
; {
700afbf0: b081         	sub	sp, #0x4
700afbf2: 9000         	str	r0, [sp]
;     return (*p);
700afbf4: 9800         	ldr	r0, [sp]
700afbf6: 6800         	ldr	r0, [r0]
700afbf8: b001         	add	sp, #0x4
700afbfa: 4770         	bx	lr
700afbfc: 0000         	movs	r0, r0
700afbfe: 0000         	movs	r0, r0

700afc00 <CSL_REG32_RD_RAW>:
; {
700afc00: b081         	sub	sp, #0x4
700afc02: 9000         	str	r0, [sp]
;     return (*p);
700afc04: 9800         	ldr	r0, [sp]
700afc06: 6800         	ldr	r0, [r0]
700afc08: b001         	add	sp, #0x4
700afc0a: 4770         	bx	lr
700afc0c: 0000         	movs	r0, r0
700afc0e: 0000         	movs	r0, r0

700afc10 <CSL_REG32_RD_RAW>:
; {
700afc10: b081         	sub	sp, #0x4
700afc12: 9000         	str	r0, [sp]
;     return (*p);
700afc14: 9800         	ldr	r0, [sp]
700afc16: 6800         	ldr	r0, [r0]
700afc18: b001         	add	sp, #0x4
700afc1a: 4770         	bx	lr
700afc1c: 0000         	movs	r0, r0
700afc1e: 0000         	movs	r0, r0

700afc20 <PMU_resetCounters>:
; static void PMU_resetCounters(void) {
700afc20: b580         	push	{r7, lr}
;   CSL_armR5PmuResetCycleCnt();
700afc22: f7f2 ea48    	blx	0x700a20b4 <CSL_armR5PmuResetCycleCnt> @ imm = #-0xdb70
;   CSL_armR5PmuResetCntrs();
700afc26: f7f2 ea4e    	blx	0x700a20c4 <CSL_armR5PmuResetCntrs> @ imm = #-0xdb64
; }
700afc2a: bd80         	pop	{r7, pc}
700afc2c: 0000         	movs	r0, r0
700afc2e: 0000         	movs	r0, r0

700afc30 <Sciclient_getSelfDevIdCore>:
;     return gSciclientHandle.devIdCore;
700afc30: f642 1048    	movw	r0, #0x2948
700afc34: f2c7 000b    	movt	r0, #0x700b
700afc38: 6880         	ldr	r0, [r0, #0x8]
700afc3a: 4770         	bx	lr
700afc3c: 0000         	movs	r0, r0
700afc3e: 0000         	movs	r0, r0

700afc40 <Sciclient_rmPsGetPsp>:
;     return gPstack.psp;
700afc40: f241 0058    	movw	r0, #0x1058
700afc44: f2c7 0008    	movt	r0, #0x7008
700afc48: 8c80         	ldrh	r0, [r0, #0x24]
700afc4a: 4770         	bx	lr
700afc4c: 0000         	movs	r0, r0
700afc4e: 0000         	movs	r0, r0

700afc50 <Udma_rmFreeFreeRing>:
; {
700afc50: b082         	sub	sp, #0x8
700afc52: f8ad 0006    	strh.w	r0, [sp, #0x6]
700afc56: 9100         	str	r1, [sp]
;     return;
700afc58: b002         	add	sp, #0x8
700afc5a: 4770         	bx	lr
700afc5c: 0000         	movs	r0, r0
700afc5e: 0000         	movs	r0, r0

700afc60 <xTaskGetIdleTaskHandle>:
;   return xIdleTaskHandle;
700afc60: f642 2030    	movw	r0, #0x2a30
700afc64: f2c7 000b    	movt	r0, #0x700b
700afc68: 6800         	ldr	r0, [r0]
700afc6a: 4770         	bx	lr
700afc6c: 0000         	movs	r0, r0
700afc6e: 0000         	movs	r0, r0

700afc70 <Hwip_dataAndInstructionBarrier>:
;     __asm__ __volatile__ (" isb"   "\n\t": : : "memory");
700afc70: f3bf 8f6f    	isb	sy
;     __asm__ __volatile__ (" dsb"   "\n\t": : : "memory");
700afc74: f3bf 8f4f    	dsb	sy
; }
700afc78: 4770         	bx	lr
700afc7a: 0000         	movs	r0, r0
700afc7c: 0000         	movs	r0, r0
700afc7e: 0000         	movs	r0, r0

700afc80 <.Lfastpath_exit>:
700afc80: e0420003     	sub	r0, r2, r3
700afc84: e12fff1e     	bx	lr
700afc88: e320f000     	nop
700afc8c: 00000000     	andeq	r0, r0, r0

700afc90 <prvTaskExitError>:
; static void prvTaskExitError(void) {
700afc90: b580         	push	{r7, lr}
700afc92: 2000         	movs	r0, #0x0
;   DebugP_assertNoLog(0);
700afc94: f001 fb04    	bl	0x700b12a0 <_DebugP_assertNoLog> @ imm = #0x1608
; }
700afc98: bd80         	pop	{r7, pc}
700afc9a: 0000         	movs	r0, r0
700afc9c: 0000         	movs	r0, r0
700afc9e: 0000         	movs	r0, r0

700afca0 <ClockP_getTicks>:
; {
700afca0: b580         	push	{r7, lr}
;     return ((uint32_t)xTaskGetTickCount());
700afca2: f7ff fc1d    	bl	0x700af4e0 <xTaskGetTickCount> @ imm = #-0x7c6
700afca6: bd80         	pop	{r7, pc}
		...

700afcb0 <UART_lld_errorCallback>:
; {
700afcb0: b081         	sub	sp, #0x4
700afcb2: 9000         	str	r0, [sp]
; }
700afcb4: b001         	add	sp, #0x4
700afcb6: 4770         	bx	lr
		...

700afcc0 <Udma_ringAssertFnPointers>:
; {
700afcc0: b081         	sub	sp, #0x4
700afcc2: 9000         	str	r0, [sp]
;     return;
700afcc4: b001         	add	sp, #0x4
700afcc6: 4770         	bx	lr
		...

700afcd0 <vApplicationIdleHook>:
; void vApplicationIdleHook(void) {
700afcd0: b580         	push	{r7, lr}
;   vApplicationLoadHook();
700afcd2: f7fb fffd    	bl	0x700abcd0 <vApplicationLoadHook> @ imm = #-0x4006
; }
700afcd6: bd80         	pop	{r7, pc}
		...

700afce0 <Board_driversOpen>:
;     return status;
700afce0: 2000         	movs	r0, #0x0
700afce2: 4770         	bx	lr
		...

700afcf0 <Sciclient_rmPsGetMaxPsp>:
; {
700afcf0: 2003         	movs	r0, #0x3
;     return SCICLIENT_PS_MAX_DEPTH;
700afcf2: 4770         	bx	lr
		...

700afd00 <TaskP_yield>:
;     taskYIELD();
700afd00: df00         	svc	#0x0
; }
700afd02: 4770         	bx	lr
		...

700afd10 <__aeabi_idiv0>:
700afd10: e12fff1e     	bx	lr
		...

700afd20 <__aeabi_ldiv0>:
700afd20: e12fff1e     	bx	lr
		...

700afd30 <main>:
;    return rtos_main_freertos();
700afd30: f7f8 bf96    	b.w	0x700a8c60 <rtos_main_freertos> @ imm = #-0x70d4
		...

700afd40 <tm_pmu_profile_end>:
;    PMU_profileEnd(name);
700afd40: f7f5 bd26    	b.w	0x700a5790 <PMU_profileEnd> @ imm = #-0xa5b4
		...

700afd50 <tm_pmu_profile_print>:
;    PMU_profilePrintEntry(name);
700afd50: f7f7 bc7e    	b.w	0x700a7650 <PMU_profilePrintEntry> @ imm = #-0x8704
		...

700afd60 <tm_pmu_profile_start>:
;    PMU_profileStart(name);
700afd60: f7f9 bb3e    	b.w	0x700a93e0 <PMU_profileStart> @ imm = #-0x6984
		...

700afd70 <tm_thread_sleep_ticks>:
;    vTaskDelay(ticks);
700afd70: f7fe bb0e    	b.w	0x700ae390 <vTaskDelay> @ imm = #-0x19e4
		...

700afd80 <Board_init>:
; }
700afd80: 4770         	bx	lr
		...
700afd8e: 0000         	movs	r0, r0

700afd90 <tm_initialize>:
;    test_initialization_function();
700afd90: 4700         	bx	r0
		...
700afd9e: 0000         	movs	r0, r0

700afda0 <vPortConfigTimerForRunTimeStats>:
; }
700afda0: 4770         	bx	lr
		...
700afdbe: 0000         	movs	r0, r0
