
.\files\freertos.out:	file format elf32-littlearm

Disassembly of section .vectors:

00000000 <_vectors>:
;         LDR pc, reset_addr          // Reset
       0: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x20 <reset_addr>
;         LDR pc, undefined_addr      // Undefined Instruction
       4: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x24 <undefined_addr>
;         LDR pc, svc_addr            // Software interrupt
       8: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x28 <svc_addr>
;         LDR pc, prefetch_abort_addr // Abort (prefetch)
       c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x2c <prefetch_abort_addr>
;         LDR pc, data_abort_addr     // Abort (data)
      10: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x30 <data_abort_addr>
;         LDR pc, reserved_addr       // rsvd
      14: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x34 <reserved_addr>
;         LDR pc, irq_addr            // IRQ
      18: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x38 <irq_addr>
;         LDR pc, fiq_addr            // FIQ
      1c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x3c <fiq_addr>

00000020 <reset_addr>:
      20: c4 ee 0a 70  	.word	0x700aeec4

00000024 <undefined_addr>:
      24: d1 e3 0a 70  	.word	0x700ae3d1

00000028 <svc_addr>:
      28: bc e4 0a 70  	.word	0x700ae4bc

0000002c <prefetch_abort_addr>:
      2c: 11 e4 0a 70  	.word	0x700ae411

00000030 <data_abort_addr>:
      30: e0 e6 0a 70  	.word	0x700ae6e0

00000034 <reserved_addr>:
      34: 91 e3 0a 70  	.word	0x700ae391

00000038 <irq_addr>:
      38: 2c e5 0a 70  	.word	0x700ae52c

0000003c <fiq_addr>:
      3c: 21 e2 0a 70  	.word	0x700ae221

Disassembly of section .text.hwi:

700adb10 <HwiP_enableInt>:
; {
700adb10: b580         	push	{r7, lr}
700adb12: b084         	sub	sp, #0x10
700adb14: 9003         	str	r0, [sp, #0xc]
;     Hwip_dataAndInstructionBarrier();
700adb16: f7ff ff7b    	bl	0x700ada10 <Hwip_dataAndInstructionBarrier> @ imm = #-0x10a
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_EN(intNum));
700adb1a: f240 40c8    	movw	r0, #0x4c8
700adb1e: f2c7 000b    	movt	r0, #0x700b
700adb22: 6801         	ldr	r1, [r0]
700adb24: 9803         	ldr	r0, [sp, #0xc]
700adb26: f400 70f0    	and	r0, r0, #0x1e0
700adb2a: 4408         	add	r0, r1
700adb2c: f500 6081    	add.w	r0, r0, #0x408
700adb30: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700adb32: 9803         	ldr	r0, [sp, #0xc]
700adb34: f000 001f    	and	r0, r0, #0x1f
700adb38: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700adb3a: 9901         	ldr	r1, [sp, #0x4]
700adb3c: 2001         	movs	r0, #0x1
700adb3e: 4088         	lsls	r0, r1
700adb40: 9902         	ldr	r1, [sp, #0x8]
700adb42: 6008         	str	r0, [r1]
; }
700adb44: b004         	add	sp, #0x10
700adb46: bd80         	pop	{r7, pc}
700adb48: bf00         	nop
700adb4a: bf00         	nop
700adb4c: bf00         	nop
700adb4e: bf00         	nop

700adb50 <HwiP_disableInt>:
; {
700adb50: b580         	push	{r7, lr}
700adb52: b084         	sub	sp, #0x10
700adb54: 9003         	str	r0, [sp, #0xc]
700adb56: 2000         	movs	r0, #0x0
;     uint32_t isEnable = 0;
700adb58: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(intNum));
700adb5a: f240 40c8    	movw	r0, #0x4c8
700adb5e: f2c7 000b    	movt	r0, #0x700b
700adb62: 6801         	ldr	r1, [r0]
700adb64: 9803         	ldr	r0, [sp, #0xc]
700adb66: f400 70f0    	and	r0, r0, #0x1e0
700adb6a: 4408         	add	r0, r1
700adb6c: f200 400c    	addw	r0, r0, #0x40c
700adb70: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700adb72: 9803         	ldr	r0, [sp, #0xc]
700adb74: f000 001f    	and	r0, r0, #0x1f
700adb78: 9001         	str	r0, [sp, #0x4]
;     if( (*addr & ((uint32_t)0x1 << bitPos))!=0U)
700adb7a: 9802         	ldr	r0, [sp, #0x8]
700adb7c: 6800         	ldr	r0, [r0]
700adb7e: 9901         	ldr	r1, [sp, #0x4]
700adb80: 40c8         	lsrs	r0, r1
700adb82: 07c0         	lsls	r0, r0, #0x1f
700adb84: b118         	cbz	r0, 0x700adb8e <HwiP_disableInt+0x3e> @ imm = #0x6
700adb86: e7ff         	b	0x700adb88 <HwiP_disableInt+0x38> @ imm = #-0x2
700adb88: 2001         	movs	r0, #0x1
;         isEnable = 1;
700adb8a: 9000         	str	r0, [sp]
;     }
700adb8c: e7ff         	b	0x700adb8e <HwiP_disableInt+0x3e> @ imm = #-0x2
;     *addr = ((uint32_t)0x1 << bitPos);
700adb8e: 9901         	ldr	r1, [sp, #0x4]
700adb90: 2001         	movs	r0, #0x1
700adb92: 4088         	lsls	r0, r1
700adb94: 9902         	ldr	r1, [sp, #0x8]
700adb96: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700adb98: f7ff ff3a    	bl	0x700ada10 <Hwip_dataAndInstructionBarrier> @ imm = #-0x18c
;     return isEnable;
700adb9c: 9800         	ldr	r0, [sp]
700adb9e: b004         	add	sp, #0x10
700adba0: bd80         	pop	{r7, pc}
700adba2: bf00         	nop
700adba4: bf00         	nop
700adba6: bf00         	nop
700adba8: bf00         	nop
700adbaa: bf00         	nop
700adbac: bf00         	nop
700adbae: bf00         	nop

700adbb0 <HwiP_restoreInt>:
; {
700adbb0: b580         	push	{r7, lr}
700adbb2: b082         	sub	sp, #0x8
700adbb4: 9001         	str	r0, [sp, #0x4]
700adbb6: 9100         	str	r1, [sp]
;     if(oldIntState!=0U)
700adbb8: 9800         	ldr	r0, [sp]
700adbba: b120         	cbz	r0, 0x700adbc6 <HwiP_restoreInt+0x16> @ imm = #0x8
700adbbc: e7ff         	b	0x700adbbe <HwiP_restoreInt+0xe> @ imm = #-0x2
;         HwiP_enableInt(intNum);
700adbbe: 9801         	ldr	r0, [sp, #0x4]
700adbc0: f7ff ffa6    	bl	0x700adb10 <HwiP_enableInt> @ imm = #-0xb4
;     }
700adbc4: e003         	b	0x700adbce <HwiP_restoreInt+0x1e> @ imm = #0x6
;        (void) HwiP_disableInt(intNum);
700adbc6: 9801         	ldr	r0, [sp, #0x4]
700adbc8: f7ff ffc2    	bl	0x700adb50 <HwiP_disableInt> @ imm = #-0x7c
700adbcc: e7ff         	b	0x700adbce <HwiP_restoreInt+0x1e> @ imm = #-0x2
; }
700adbce: b002         	add	sp, #0x8
700adbd0: bd80         	pop	{r7, pc}
700adbd2: bf00         	nop
700adbd4: bf00         	nop
700adbd6: bf00         	nop
700adbd8: bf00         	nop
700adbda: bf00         	nop
700adbdc: bf00         	nop
700adbde: bf00         	nop

700adbe0 <HwiP_clearInt>:
; {
700adbe0: b083         	sub	sp, #0xc
700adbe2: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_STS(intNum));
700adbe4: f240 40c8    	movw	r0, #0x4c8
700adbe8: f2c7 000b    	movt	r0, #0x700b
700adbec: 6801         	ldr	r1, [r0]
700adbee: 9802         	ldr	r0, [sp, #0x8]
700adbf0: f400 70f0    	and	r0, r0, #0x1e0
700adbf4: 4408         	add	r0, r1
700adbf6: f200 4004    	addw	r0, r0, #0x404
700adbfa: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700adbfc: 9802         	ldr	r0, [sp, #0x8]
700adbfe: f000 001f    	and	r0, r0, #0x1f
700adc02: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)0x1 << bitPos);
700adc04: 9900         	ldr	r1, [sp]
700adc06: 2001         	movs	r0, #0x1
700adc08: 4088         	lsls	r0, r1
700adc0a: 9901         	ldr	r1, [sp, #0x4]
700adc0c: 6008         	str	r0, [r1]
; }
700adc0e: b003         	add	sp, #0xc
700adc10: 4770         	bx	lr
700adc12: bf00         	nop
700adc14: bf00         	nop
700adc16: bf00         	nop
700adc18: bf00         	nop
700adc1a: bf00         	nop
700adc1c: bf00         	nop
700adc1e: bf00         	nop

700adc20 <HwiP_post>:
; {
700adc20: b580         	push	{r7, lr}
700adc22: b084         	sub	sp, #0x10
700adc24: 9003         	str	r0, [sp, #0xc]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_RAW(intNum));
700adc26: f240 40c8    	movw	r0, #0x4c8
700adc2a: f2c7 000b    	movt	r0, #0x700b
700adc2e: 6801         	ldr	r1, [r0]
700adc30: 9803         	ldr	r0, [sp, #0xc]
700adc32: f400 70f0    	and	r0, r0, #0x1e0
700adc36: 4408         	add	r0, r1
700adc38: f500 6080    	add.w	r0, r0, #0x400
700adc3c: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700adc3e: 9803         	ldr	r0, [sp, #0xc]
700adc40: f000 001f    	and	r0, r0, #0x1f
700adc44: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700adc46: 9901         	ldr	r1, [sp, #0x4]
700adc48: 2001         	movs	r0, #0x1
700adc4a: 4088         	lsls	r0, r1
700adc4c: 9902         	ldr	r1, [sp, #0x8]
700adc4e: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700adc50: f7ff fede    	bl	0x700ada10 <Hwip_dataAndInstructionBarrier> @ imm = #-0x244
; }
700adc54: b004         	add	sp, #0x10
700adc56: bd80         	pop	{r7, pc}
700adc58: bf00         	nop
700adc5a: bf00         	nop
700adc5c: bf00         	nop
700adc5e: bf00         	nop

700adc60 <HwiP_Params_init>:
; {
700adc60: b081         	sub	sp, #0x4
700adc62: 9000         	str	r0, [sp]
;     params->intNum = 0;
700adc64: 9900         	ldr	r1, [sp]
700adc66: 2000         	movs	r0, #0x0
700adc68: 6008         	str	r0, [r1]
;     params->callback = NULL;
700adc6a: 9900         	ldr	r1, [sp]
700adc6c: 6048         	str	r0, [r1, #0x4]
;     params->args = NULL;
700adc6e: 9900         	ldr	r1, [sp]
700adc70: 6088         	str	r0, [r1, #0x8]
;     params->eventId = 0; /* NOT USED */
700adc72: 9900         	ldr	r1, [sp]
700adc74: 8188         	strh	r0, [r1, #0xc]
;     params->priority = (HwiP_MAX_PRIORITY-1U);
700adc76: 9a00         	ldr	r2, [sp]
700adc78: 210f         	movs	r1, #0xf
700adc7a: 7391         	strb	r1, [r2, #0xe]
;     params->isFIQ = 0;
700adc7c: 9900         	ldr	r1, [sp]
700adc7e: 73c8         	strb	r0, [r1, #0xf]
;     params->isPulse = 0;
700adc80: 9900         	ldr	r1, [sp]
700adc82: 7408         	strb	r0, [r1, #0x10]
; }
700adc84: b001         	add	sp, #0x4
700adc86: 4770         	bx	lr
700adc88: bf00         	nop
700adc8a: bf00         	nop
700adc8c: bf00         	nop
700adc8e: bf00         	nop

700adc90 <HwiP_construct>:
; {
700adc90: b580         	push	{r7, lr}
700adc92: b084         	sub	sp, #0x10
700adc94: 9003         	str	r0, [sp, #0xc]
700adc96: 9102         	str	r1, [sp, #0x8]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700adc98: 9803         	ldr	r0, [sp, #0xc]
700adc9a: 9001         	str	r0, [sp, #0x4]
700adc9c: 2001         	movs	r0, #0x1
;     DebugP_assertNoLog( sizeof(HwiP_Struct) <= sizeof(HwiP_Object) );
700adc9e: f001 f9a7    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x134e
;     DebugP_assertNoLog( params->callback != NULL );
700adca2: 9802         	ldr	r0, [sp, #0x8]
700adca4: 6840         	ldr	r0, [r0, #0x4]
700adca6: 2800         	cmp	r0, #0x0
700adca8: bf18         	it	ne
700adcaa: 2001         	movne	r0, #0x1
700adcac: f001 f9a0    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x1340
;     DebugP_assertNoLog( params->intNum < HwiP_MAX_INTERRUPTS );
700adcb0: 9802         	ldr	r0, [sp, #0x8]
700adcb2: 6801         	ldr	r1, [r0]
700adcb4: 2000         	movs	r0, #0x0
700adcb6: 9000         	str	r0, [sp]
700adcb8: f5b1 7f00    	cmp.w	r1, #0x200
700adcbc: bf38         	it	lo
700adcbe: 2001         	movlo	r0, #0x1
700adcc0: f001 f996    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x132c
700adcc4: 9800         	ldr	r0, [sp]
;     DebugP_assertNoLog( params->priority < HwiP_MAX_PRIORITY );
700adcc6: 9902         	ldr	r1, [sp, #0x8]
700adcc8: 7b89         	ldrb	r1, [r1, #0xe]
700adcca: 2910         	cmp	r1, #0x10
700adccc: bf38         	it	lo
700adcce: 2001         	movlo	r0, #0x1
700adcd0: f001 f98e    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x131c
;     (void) HwiP_disableInt(params->intNum);
700adcd4: 9802         	ldr	r0, [sp, #0x8]
700adcd6: 6800         	ldr	r0, [r0]
700adcd8: f7ff ff3a    	bl	0x700adb50 <HwiP_disableInt> @ imm = #-0x18c
;     HwiP_clearInt(params->intNum);
700adcdc: 9802         	ldr	r0, [sp, #0x8]
700adcde: 6800         	ldr	r0, [r0]
700adce0: f7ff ff7e    	bl	0x700adbe0 <HwiP_clearInt> @ imm = #-0x104
;     HwiP_setAsFIQ(params->intNum, params->isFIQ);
700adce4: 9902         	ldr	r1, [sp, #0x8]
700adce6: 6808         	ldr	r0, [r1]
700adce8: 7bc9         	ldrb	r1, [r1, #0xf]
700adcea: f000 f841    	bl	0x700add70 <HwiP_setAsFIQ> @ imm = #0x82
;     HwiP_setPri(params->intNum, params->priority);
700adcee: 9902         	ldr	r1, [sp, #0x8]
700adcf0: 6808         	ldr	r0, [r1]
700adcf2: 7b89         	ldrb	r1, [r1, #0xe]
700adcf4: f000 f86c    	bl	0x700addd0 <HwiP_setPri> @ imm = #0xd8
;     HwiP_setAsPulse(params->intNum, params->isPulse);
700adcf8: 9902         	ldr	r1, [sp, #0x8]
700adcfa: 6808         	ldr	r0, [r1]
700adcfc: 7c09         	ldrb	r1, [r1, #0x10]
700adcfe: f000 f87f    	bl	0x700ade00 <HwiP_setAsPulse> @ imm = #0xfe
;     if(params->isFIQ != 0U)
700add02: 9802         	ldr	r0, [sp, #0x8]
700add04: 7bc0         	ldrb	r0, [r0, #0xf]
700add06: b148         	cbz	r0, 0x700add1c <HwiP_construct+0x8c> @ imm = #0x12
700add08: e7ff         	b	0x700add0a <HwiP_construct+0x7a> @ imm = #-0x2
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_fiq_handler);
700add0a: 9802         	ldr	r0, [sp, #0x8]
700add0c: 6800         	ldr	r0, [r0]
700add0e: f24e 2121    	movw	r1, #0xe221
700add12: f2c7 010a    	movt	r1, #0x700a
700add16: f000 f8a3    	bl	0x700ade60 <HwiP_setVecAddr> @ imm = #0x146
;     }
700add1a: e008         	b	0x700add2e <HwiP_construct+0x9e> @ imm = #0x10
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_irq_handler);
700add1c: 9802         	ldr	r0, [sp, #0x8]
700add1e: 6800         	ldr	r0, [r0]
700add20: f24e 512c    	movw	r1, #0xe52c
700add24: f2c7 010a    	movt	r1, #0x700a
700add28: f000 f89a    	bl	0x700ade60 <HwiP_setVecAddr> @ imm = #0x134
700add2c: e7ff         	b	0x700add2e <HwiP_construct+0x9e> @ imm = #-0x2
;     gHwiCtrl.isr[params->intNum] = params->callback;
700add2e: 9802         	ldr	r0, [sp, #0x8]
700add30: 6802         	ldr	r2, [r0]
700add32: 6840         	ldr	r0, [r0, #0x4]
700add34: f240 0100    	movw	r1, #0x0
700add38: f2c7 0108    	movt	r1, #0x7008
700add3c: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[params->intNum] = params->args;
700add40: 9802         	ldr	r0, [sp, #0x8]
700add42: 6802         	ldr	r2, [r0]
700add44: 6880         	ldr	r0, [r0, #0x8]
700add46: eb01 0182    	add.w	r1, r1, r2, lsl #2
700add4a: f8c1 0800    	str.w	r0, [r1, #0x800]
;     obj->intNum = params->intNum;
700add4e: 9802         	ldr	r0, [sp, #0x8]
700add50: 6800         	ldr	r0, [r0]
700add52: 9901         	ldr	r1, [sp, #0x4]
700add54: 6008         	str	r0, [r1]
;     HwiP_enableInt(params->intNum);
700add56: 9802         	ldr	r0, [sp, #0x8]
700add58: 6800         	ldr	r0, [r0]
700add5a: f7ff fed9    	bl	0x700adb10 <HwiP_enableInt> @ imm = #-0x24e
700add5e: 2000         	movs	r0, #0x0
;     return SystemP_SUCCESS;
700add60: b004         	add	sp, #0x10
700add62: bd80         	pop	{r7, pc}
700add64: bf00         	nop
700add66: bf00         	nop
700add68: bf00         	nop
700add6a: bf00         	nop
700add6c: bf00         	nop
700add6e: bf00         	nop

700add70 <HwiP_setAsFIQ>:
; {
700add70: b084         	sub	sp, #0x10
700add72: 9003         	str	r0, [sp, #0xc]
700add74: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(intNum));
700add76: f240 40c8    	movw	r0, #0x4c8
700add7a: f2c7 000b    	movt	r0, #0x700b
700add7e: 6801         	ldr	r1, [r0]
700add80: 9803         	ldr	r0, [sp, #0xc]
700add82: f400 70f0    	and	r0, r0, #0x1e0
700add86: 4408         	add	r0, r1
700add88: f500 6083    	add.w	r0, r0, #0x418
700add8c: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700add8e: 9803         	ldr	r0, [sp, #0xc]
700add90: f000 001f    	and	r0, r0, #0x1f
700add94: 9000         	str	r0, [sp]
;     if(isFIQ != 0U)
700add96: 9802         	ldr	r0, [sp, #0x8]
700add98: b148         	cbz	r0, 0x700addae <HwiP_setAsFIQ+0x3e> @ imm = #0x12
700add9a: e7ff         	b	0x700add9c <HwiP_setAsFIQ+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700add9c: 9900         	ldr	r1, [sp]
700add9e: 2001         	movs	r0, #0x1
700adda0: fa00 f201    	lsl.w	r2, r0, r1
700adda4: 9901         	ldr	r1, [sp, #0x4]
700adda6: 6808         	ldr	r0, [r1]
700adda8: 4310         	orrs	r0, r2
700addaa: 6008         	str	r0, [r1]
;     }
700addac: e008         	b	0x700addc0 <HwiP_setAsFIQ+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700addae: 9900         	ldr	r1, [sp]
700addb0: 2001         	movs	r0, #0x1
700addb2: fa00 f201    	lsl.w	r2, r0, r1
700addb6: 9901         	ldr	r1, [sp, #0x4]
700addb8: 6808         	ldr	r0, [r1]
700addba: 4390         	bics	r0, r2
700addbc: 6008         	str	r0, [r1]
700addbe: e7ff         	b	0x700addc0 <HwiP_setAsFIQ+0x50> @ imm = #-0x2
; }
700addc0: b004         	add	sp, #0x10
700addc2: 4770         	bx	lr
700addc4: bf00         	nop
700addc6: bf00         	nop
700addc8: bf00         	nop
700addca: bf00         	nop
700addcc: bf00         	nop
700addce: bf00         	nop

700addd0 <HwiP_setPri>:
; {
700addd0: b083         	sub	sp, #0xc
700addd2: 9002         	str	r0, [sp, #0x8]
700addd4: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_PRI(intNum));
700addd6: f240 40c8    	movw	r0, #0x4c8
700addda: f2c7 000b    	movt	r0, #0x700b
700addde: 6800         	ldr	r0, [r0]
700adde0: 9902         	ldr	r1, [sp, #0x8]
700adde2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700adde6: f500 5080    	add.w	r0, r0, #0x1000
700addea: 9000         	str	r0, [sp]
;     *addr = (priority & 0xFu);
700addec: 9801         	ldr	r0, [sp, #0x4]
700addee: f000 000f    	and	r0, r0, #0xf
700addf2: 9900         	ldr	r1, [sp]
700addf4: 6008         	str	r0, [r1]
; }
700addf6: b003         	add	sp, #0xc
700addf8: 4770         	bx	lr
700addfa: bf00         	nop
700addfc: bf00         	nop
700addfe: bf00         	nop

700ade00 <HwiP_setAsPulse>:
; {
700ade00: b084         	sub	sp, #0x10
700ade02: 9003         	str	r0, [sp, #0xc]
700ade04: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700ade06: f240 40c8    	movw	r0, #0x4c8
700ade0a: f2c7 000b    	movt	r0, #0x700b
700ade0e: 6801         	ldr	r1, [r0]
700ade10: 9803         	ldr	r0, [sp, #0xc]
700ade12: f400 70f0    	and	r0, r0, #0x1e0
700ade16: 4408         	add	r0, r1
700ade18: f200 401c    	addw	r0, r0, #0x41c
700ade1c: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700ade1e: 9803         	ldr	r0, [sp, #0xc]
700ade20: f000 001f    	and	r0, r0, #0x1f
700ade24: 9000         	str	r0, [sp]
;     if(isPulse != 0U)
700ade26: 9802         	ldr	r0, [sp, #0x8]
700ade28: b148         	cbz	r0, 0x700ade3e <HwiP_setAsPulse+0x3e> @ imm = #0x12
700ade2a: e7ff         	b	0x700ade2c <HwiP_setAsPulse+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700ade2c: 9900         	ldr	r1, [sp]
700ade2e: 2001         	movs	r0, #0x1
700ade30: fa00 f201    	lsl.w	r2, r0, r1
700ade34: 9901         	ldr	r1, [sp, #0x4]
700ade36: 6808         	ldr	r0, [r1]
700ade38: 4310         	orrs	r0, r2
700ade3a: 6008         	str	r0, [r1]
;     }
700ade3c: e008         	b	0x700ade50 <HwiP_setAsPulse+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700ade3e: 9900         	ldr	r1, [sp]
700ade40: 2001         	movs	r0, #0x1
700ade42: fa00 f201    	lsl.w	r2, r0, r1
700ade46: 9901         	ldr	r1, [sp, #0x4]
700ade48: 6808         	ldr	r0, [r1]
700ade4a: 4390         	bics	r0, r2
700ade4c: 6008         	str	r0, [r1]
700ade4e: e7ff         	b	0x700ade50 <HwiP_setAsPulse+0x50> @ imm = #-0x2
; }
700ade50: b004         	add	sp, #0x10
700ade52: 4770         	bx	lr
700ade54: bf00         	nop
700ade56: bf00         	nop
700ade58: bf00         	nop
700ade5a: bf00         	nop
700ade5c: bf00         	nop
700ade5e: bf00         	nop

700ade60 <HwiP_setVecAddr>:
; {
700ade60: b083         	sub	sp, #0xc
700ade62: 9002         	str	r0, [sp, #0x8]
700ade64: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_VEC(intNum));
700ade66: f240 40c8    	movw	r0, #0x4c8
700ade6a: f2c7 000b    	movt	r0, #0x700b
700ade6e: 6800         	ldr	r0, [r0]
700ade70: 9902         	ldr	r1, [sp, #0x8]
700ade72: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ade76: f500 5000    	add.w	r0, r0, #0x2000
700ade7a: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)vecAddr & 0xFFFFFFFCU);
700ade7c: 9801         	ldr	r0, [sp, #0x4]
700ade7e: f020 0003    	bic	r0, r0, #0x3
700ade82: 9900         	ldr	r1, [sp]
700ade84: 6008         	str	r0, [r1]
; }
700ade86: b003         	add	sp, #0xc
700ade88: 4770         	bx	lr
700ade8a: bf00         	nop
700ade8c: bf00         	nop
700ade8e: bf00         	nop

700ade90 <HwiP_destruct>:
; {
700ade90: b580         	push	{r7, lr}
700ade92: b084         	sub	sp, #0x10
700ade94: 9003         	str	r0, [sp, #0xc]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700ade96: 9803         	ldr	r0, [sp, #0xc]
700ade98: 9002         	str	r0, [sp, #0x8]
;    (void) HwiP_disableInt(obj->intNum);
700ade9a: 9802         	ldr	r0, [sp, #0x8]
700ade9c: 6800         	ldr	r0, [r0]
700ade9e: f7ff fe57    	bl	0x700adb50 <HwiP_disableInt> @ imm = #-0x352
;     HwiP_clearInt(obj->intNum);
700adea2: 9802         	ldr	r0, [sp, #0x8]
700adea4: 6800         	ldr	r0, [r0]
700adea6: f7ff fe9b    	bl	0x700adbe0 <HwiP_clearInt> @ imm = #-0x2ca
;     HwiP_setAsFIQ(obj->intNum, 0);
700adeaa: 9802         	ldr	r0, [sp, #0x8]
700adeac: 6800         	ldr	r0, [r0]
700adeae: 2100         	movs	r1, #0x0
700adeb0: 9101         	str	r1, [sp, #0x4]
700adeb2: f7ff ff5d    	bl	0x700add70 <HwiP_setAsFIQ> @ imm = #-0x146
;     HwiP_setPri(obj->intNum, HwiP_MAX_PRIORITY-1U);
700adeb6: 9802         	ldr	r0, [sp, #0x8]
700adeb8: 6800         	ldr	r0, [r0]
700adeba: 210f         	movs	r1, #0xf
700adebc: f7ff ff88    	bl	0x700addd0 <HwiP_setPri> @ imm = #-0xf0
700adec0: 9901         	ldr	r1, [sp, #0x4]
;     HwiP_setAsPulse(obj->intNum, 0);
700adec2: 9802         	ldr	r0, [sp, #0x8]
700adec4: 6800         	ldr	r0, [r0]
700adec6: f7ff ff9b    	bl	0x700ade00 <HwiP_setAsPulse> @ imm = #-0xca
;     HwiP_setVecAddr(obj->intNum, (uintptr_t)HwiP_irq_handler);
700adeca: 9802         	ldr	r0, [sp, #0x8]
700adecc: 6800         	ldr	r0, [r0]
700adece: f24e 512c    	movw	r1, #0xe52c
700aded2: f2c7 010a    	movt	r1, #0x700a
700aded6: f7ff ffc3    	bl	0x700ade60 <HwiP_setVecAddr> @ imm = #-0x7a
700adeda: 9801         	ldr	r0, [sp, #0x4]
;     gHwiCtrl.isr[obj->intNum] = NULL;
700adedc: 9902         	ldr	r1, [sp, #0x8]
700adede: 680a         	ldr	r2, [r1]
700adee0: f240 0100    	movw	r1, #0x0
700adee4: f2c7 0108    	movt	r1, #0x7008
700adee8: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[obj->intNum] = NULL;
700adeec: 9a02         	ldr	r2, [sp, #0x8]
700adeee: 6812         	ldr	r2, [r2]
700adef0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700adef4: f8c1 0800    	str.w	r0, [r1, #0x800]
; }
700adef8: b004         	add	sp, #0x10
700adefa: bd80         	pop	{r7, pc}
700adefc: bf00         	nop
700adefe: bf00         	nop

700adf00 <HwiP_init>:
; {
700adf00: b580         	push	{r7, lr}
700adf02: b084         	sub	sp, #0x10
;     (void) HwiP_disable();
700adf04: f000 ebb4    	blx	0x700ae670 <HwiP_disable> @ imm = #0x768
;     (void) HwiP_disableFIQ();
700adf08: f000 ebba    	blx	0x700ae680 <HwiP_disableFIQ> @ imm = #0x774
;     DebugP_assertNoLog(gHwiConfig.intcBaseAddr != 0U);
700adf0c: f240 40c8    	movw	r0, #0x4c8
700adf10: f2c7 000b    	movt	r0, #0x700b
700adf14: 6800         	ldr	r0, [r0]
700adf16: 2800         	cmp	r0, #0x0
700adf18: bf18         	it	ne
700adf1a: 2001         	movne	r0, #0x1
700adf1c: f001 f868    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x10d0
;     gHwiCtrl.spuriousIRQCount = 0;
700adf20: f240 0100    	movw	r1, #0x0
700adf24: f2c7 0108    	movt	r1, #0x7008
700adf28: f44f 5280    	mov.w	r2, #0x1000
700adf2c: 2000         	movs	r0, #0x0
700adf2e: 5088         	str	r0, [r1, r2]
700adf30: f241 0204    	movw	r2, #0x1004
;     gHwiCtrl.spuriousFIQCount = 0;
700adf34: 5088         	str	r0, [r1, r2]
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700adf36: 9003         	str	r0, [sp, #0xc]
700adf38: e7ff         	b	0x700adf3a <HwiP_init+0x3a> @ imm = #-0x2
700adf3a: 9903         	ldr	r1, [sp, #0xc]
700adf3c: 2000         	movs	r0, #0x0
700adf3e: ebb0 2f51    	cmp.w	r0, r1, lsr #9
700adf42: d11d         	bne	0x700adf80 <HwiP_init+0x80> @ imm = #0x3a
700adf44: e7ff         	b	0x700adf46 <HwiP_init+0x46> @ imm = #-0x2
;         gHwiCtrl.isr[i] = NULL;
700adf46: 9a03         	ldr	r2, [sp, #0xc]
700adf48: f240 0100    	movw	r1, #0x0
700adf4c: f2c7 0108    	movt	r1, #0x7008
700adf50: 2000         	movs	r0, #0x0
700adf52: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gHwiCtrl.isrArgs[i] = NULL;
700adf56: 9a03         	ldr	r2, [sp, #0xc]
700adf58: eb01 0182    	add.w	r1, r1, r2, lsl #2
700adf5c: f8c1 0800    	str.w	r0, [r1, #0x800]
;         HwiP_setPri(i, 0xF);
700adf60: 9803         	ldr	r0, [sp, #0xc]
700adf62: 210f         	movs	r1, #0xf
700adf64: f7ff ff34    	bl	0x700addd0 <HwiP_setPri> @ imm = #-0x198
;         HwiP_setVecAddr(i, (uintptr_t)HwiP_irq_handler);
700adf68: 9803         	ldr	r0, [sp, #0xc]
700adf6a: f24e 512c    	movw	r1, #0xe52c
700adf6e: f2c7 010a    	movt	r1, #0x700a
700adf72: f7ff ff75    	bl	0x700ade60 <HwiP_setVecAddr> @ imm = #-0x116
;     }
700adf76: e7ff         	b	0x700adf78 <HwiP_init+0x78> @ imm = #-0x2
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700adf78: 9803         	ldr	r0, [sp, #0xc]
700adf7a: 3001         	adds	r0, #0x1
700adf7c: 9003         	str	r0, [sp, #0xc]
700adf7e: e7dc         	b	0x700adf3a <HwiP_init+0x3a> @ imm = #-0x48
700adf80: 2000         	movs	r0, #0x0
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700adf82: 9003         	str	r0, [sp, #0xc]
700adf84: e7ff         	b	0x700adf86 <HwiP_init+0x86> @ imm = #-0x2
700adf86: 9803         	ldr	r0, [sp, #0xc]
700adf88: 280f         	cmp	r0, #0xf
700adf8a: d838         	bhi	0x700adffe <HwiP_init+0xfe> @ imm = #0x70
700adf8c: e7ff         	b	0x700adf8e <HwiP_init+0x8e> @ imm = #-0x2
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(i*INTERRUPT_VALUE));
700adf8e: f240 41c8    	movw	r1, #0x4c8
700adf92: f2c7 010b    	movt	r1, #0x700b
700adf96: 6808         	ldr	r0, [r1]
700adf98: 9a03         	ldr	r2, [sp, #0xc]
700adf9a: f002 020f    	and	r2, r2, #0xf
700adf9e: eb00 1042    	add.w	r0, r0, r2, lsl #5
700adfa2: f200 400c    	addw	r0, r0, #0x40c
700adfa6: 9002         	str	r0, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700adfa8: 9a02         	ldr	r2, [sp, #0x8]
700adfaa: f04f 30ff    	mov.w	r0, #0xffffffff
700adfae: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_STS(i*INTERRUPT_VALUE));
700adfb0: 680a         	ldr	r2, [r1]
700adfb2: 9b03         	ldr	r3, [sp, #0xc]
700adfb4: f003 030f    	and	r3, r3, #0xf
700adfb8: eb02 1243    	add.w	r2, r2, r3, lsl #5
700adfbc: f202 4204    	addw	r2, r2, #0x404
700adfc0: 9202         	str	r2, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700adfc2: 9a02         	ldr	r2, [sp, #0x8]
700adfc4: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(i*INTERRUPT_VALUE));
700adfc6: 6808         	ldr	r0, [r1]
700adfc8: 9a03         	ldr	r2, [sp, #0xc]
700adfca: f002 020f    	and	r2, r2, #0xf
700adfce: eb00 1042    	add.w	r0, r0, r2, lsl #5
700adfd2: f200 401c    	addw	r0, r0, #0x41c
700adfd6: 9002         	str	r0, [sp, #0x8]
;         *addr = 0x0u;
700adfd8: 9a02         	ldr	r2, [sp, #0x8]
700adfda: 2000         	movs	r0, #0x0
700adfdc: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(i*INTERRUPT_VALUE));
700adfde: 6809         	ldr	r1, [r1]
700adfe0: 9a03         	ldr	r2, [sp, #0xc]
700adfe2: f002 020f    	and	r2, r2, #0xf
700adfe6: eb01 1142    	add.w	r1, r1, r2, lsl #5
700adfea: f501 6183    	add.w	r1, r1, #0x418
700adfee: 9102         	str	r1, [sp, #0x8]
;         *addr = 0x0u;
700adff0: 9902         	ldr	r1, [sp, #0x8]
700adff2: 6008         	str	r0, [r1]
;     }
700adff4: e7ff         	b	0x700adff6 <HwiP_init+0xf6> @ imm = #-0x2
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700adff6: 9803         	ldr	r0, [sp, #0xc]
700adff8: 3001         	adds	r0, #0x1
700adffa: 9003         	str	r0, [sp, #0xc]
700adffc: e7c3         	b	0x700adf86 <HwiP_init+0x86> @ imm = #-0x7a
;         gdummy = HwiP_getIRQVecAddr();
700adffe: f000 f817    	bl	0x700ae030 <HwiP_getIRQVecAddr> @ imm = #0x2e
700ae002: f644 6194    	movw	r1, #0x4e94
700ae006: f2c7 0108    	movt	r1, #0x7008
700ae00a: 9100         	str	r1, [sp]
700ae00c: 6008         	str	r0, [r1]
;         gdummy = HwiP_getFIQVecAddr();
700ae00e: f000 f81f    	bl	0x700ae050 <HwiP_getFIQVecAddr> @ imm = #0x3e
700ae012: 9900         	ldr	r1, [sp]
700ae014: 6008         	str	r0, [r1]
700ae016: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700ae018: 9001         	str	r0, [sp, #0x4]
700ae01a: f000 f829    	bl	0x700ae070 <HwiP_ackIRQ> @ imm = #0x52
700ae01e: 9801         	ldr	r0, [sp, #0x4]
;         HwiP_ackFIQ(0);
700ae020: f000 f836    	bl	0x700ae090 <HwiP_ackFIQ> @ imm = #0x6c
;     HwiP_enableVIC();
700ae024: f000 eb48    	blx	0x700ae6b8 <HwiP_enableVIC> @ imm = #0x690
;     HwiP_enableFIQ();
700ae028: f000 eb3a    	blx	0x700ae6a0 <HwiP_enableFIQ> @ imm = #0x674
; }
700ae02c: b004         	add	sp, #0x10
700ae02e: bd80         	pop	{r7, pc}

700ae030 <HwiP_getIRQVecAddr>:
; {
700ae030: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700ae032: f240 40c8    	movw	r0, #0x4c8
700ae036: f2c7 000b    	movt	r0, #0x700b
700ae03a: 6800         	ldr	r0, [r0]
700ae03c: 3018         	adds	r0, #0x18
700ae03e: 9000         	str	r0, [sp]
;     return *addr;
700ae040: 9800         	ldr	r0, [sp]
700ae042: 6800         	ldr	r0, [r0]
700ae044: b001         	add	sp, #0x4
700ae046: 4770         	bx	lr
700ae048: bf00         	nop
700ae04a: bf00         	nop
700ae04c: bf00         	nop
700ae04e: bf00         	nop

700ae050 <HwiP_getFIQVecAddr>:
; {
700ae050: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700ae052: f240 40c8    	movw	r0, #0x4c8
700ae056: f2c7 000b    	movt	r0, #0x700b
700ae05a: 6800         	ldr	r0, [r0]
700ae05c: 301c         	adds	r0, #0x1c
700ae05e: 9000         	str	r0, [sp]
;     return *addr;
700ae060: 9800         	ldr	r0, [sp]
700ae062: 6800         	ldr	r0, [r0]
700ae064: b001         	add	sp, #0x4
700ae066: 4770         	bx	lr
700ae068: bf00         	nop
700ae06a: bf00         	nop
700ae06c: bf00         	nop
700ae06e: bf00         	nop

700ae070 <HwiP_ackIRQ>:
; {
700ae070: b082         	sub	sp, #0x8
700ae072: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700ae074: f240 40c8    	movw	r0, #0x4c8
700ae078: f2c7 000b    	movt	r0, #0x700b
700ae07c: 6800         	ldr	r0, [r0]
700ae07e: 3018         	adds	r0, #0x18
700ae080: 9000         	str	r0, [sp]
;     *addr= intNum;
700ae082: 9801         	ldr	r0, [sp, #0x4]
700ae084: 9900         	ldr	r1, [sp]
700ae086: 6008         	str	r0, [r1]
; }
700ae088: b002         	add	sp, #0x8
700ae08a: 4770         	bx	lr
700ae08c: bf00         	nop
700ae08e: bf00         	nop

700ae090 <HwiP_ackFIQ>:
; {
700ae090: b082         	sub	sp, #0x8
700ae092: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700ae094: f240 40c8    	movw	r0, #0x4c8
700ae098: f2c7 000b    	movt	r0, #0x700b
700ae09c: 6800         	ldr	r0, [r0]
700ae09e: 301c         	adds	r0, #0x1c
700ae0a0: 9000         	str	r0, [sp]
;     *addr= intNum;
700ae0a2: 9801         	ldr	r0, [sp, #0x4]
700ae0a4: 9900         	ldr	r1, [sp]
700ae0a6: 6008         	str	r0, [r1]
; }
700ae0a8: b002         	add	sp, #0x8
700ae0aa: 4770         	bx	lr
700ae0ac: bf00         	nop
700ae0ae: bf00         	nop

700ae0b0 <HwiP_inISR>:
; {
700ae0b0: b580         	push	{r7, lr}
700ae0b2: b082         	sub	sp, #0x8
;     uint32_t mode = (HwiP_getCPSR() & 0x1FU);
700ae0b4: f000 eb10    	blx	0x700ae6d8 <HwiP_getCPSR> @ imm = #0x620
700ae0b8: f000 001f    	and	r0, r0, #0x1f
700ae0bc: 9001         	str	r0, [sp, #0x4]
700ae0be: 2000         	movs	r0, #0x0
;     uint32_t result =0;
700ae0c0: 9000         	str	r0, [sp]
;     if(mode != ARMV7R_SYSTEM_MODE)
700ae0c2: 9801         	ldr	r0, [sp, #0x4]
700ae0c4: 281f         	cmp	r0, #0x1f
700ae0c6: d003         	beq	0x700ae0d0 <HwiP_inISR+0x20> @ imm = #0x6
700ae0c8: e7ff         	b	0x700ae0ca <HwiP_inISR+0x1a> @ imm = #-0x2
700ae0ca: 2001         	movs	r0, #0x1
;          result= 1;
700ae0cc: 9000         	str	r0, [sp]
;     }
700ae0ce: e7ff         	b	0x700ae0d0 <HwiP_inISR+0x20> @ imm = #-0x2
;     return result;
700ae0d0: 9800         	ldr	r0, [sp]
700ae0d2: b002         	add	sp, #0x8
700ae0d4: bd80         	pop	{r7, pc}
		...
700ae0de: 0000         	movs	r0, r0

700ae0e0 <HwiP_irq_handler_c>:
; {
700ae0e0: b580         	push	{r7, lr}
700ae0e2: b086         	sub	sp, #0x18
700ae0e4: a804         	add	r0, sp, #0x10
;     status = HwiP_getIRQ(&intNum);
700ae0e6: f000 f843    	bl	0x700ae170 <HwiP_getIRQ> @ imm = #0x86
700ae0ea: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700ae0ec: 9805         	ldr	r0, [sp, #0x14]
700ae0ee: bb78         	cbnz	r0, 0x700ae150 <HwiP_irq_handler_c+0x70> @ imm = #0x5e
700ae0f0: e7ff         	b	0x700ae0f2 <HwiP_irq_handler_c+0x12> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700ae0f2: 9804         	ldr	r0, [sp, #0x10]
700ae0f4: f000 f864    	bl	0x700ae1c0 <HwiP_isPulse> @ imm = #0xc8
700ae0f8: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700ae0fa: 9803         	ldr	r0, [sp, #0xc]
700ae0fc: b120         	cbz	r0, 0x700ae108 <HwiP_irq_handler_c+0x28> @ imm = #0x8
700ae0fe: e7ff         	b	0x700ae100 <HwiP_irq_handler_c+0x20> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700ae100: 9804         	ldr	r0, [sp, #0x10]
700ae102: f7ff fd6d    	bl	0x700adbe0 <HwiP_clearInt> @ imm = #-0x526
;         }
700ae106: e7ff         	b	0x700ae108 <HwiP_irq_handler_c+0x28> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700ae108: 9904         	ldr	r1, [sp, #0x10]
700ae10a: f240 0000    	movw	r0, #0x0
700ae10e: f2c7 0008    	movt	r0, #0x7008
700ae112: f850 1021    	ldr.w	r1, [r0, r1, lsl #2]
700ae116: 9102         	str	r1, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700ae118: 9904         	ldr	r1, [sp, #0x10]
700ae11a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ae11e: f8d0 0800    	ldr.w	r0, [r0, #0x800]
700ae122: 9001         	str	r0, [sp, #0x4]
;         HwiP_enable();
700ae124: f000 eab4    	blx	0x700ae690 <HwiP_enable> @ imm = #0x568
;         if(isr!=NULL)
700ae128: 9802         	ldr	r0, [sp, #0x8]
700ae12a: b120         	cbz	r0, 0x700ae136 <HwiP_irq_handler_c+0x56> @ imm = #0x8
700ae12c: e7ff         	b	0x700ae12e <HwiP_irq_handler_c+0x4e> @ imm = #-0x2
;             isr(args);
700ae12e: 9902         	ldr	r1, [sp, #0x8]
700ae130: 9801         	ldr	r0, [sp, #0x4]
700ae132: 4788         	blx	r1
;         }
700ae134: e7ff         	b	0x700ae136 <HwiP_irq_handler_c+0x56> @ imm = #-0x2
;         (void)HwiP_disable();
700ae136: f000 ea9c    	blx	0x700ae670 <HwiP_disable> @ imm = #0x538
;         if(isPulse == 0U)
700ae13a: 9803         	ldr	r0, [sp, #0xc]
700ae13c: b920         	cbnz	r0, 0x700ae148 <HwiP_irq_handler_c+0x68> @ imm = #0x8
700ae13e: e7ff         	b	0x700ae140 <HwiP_irq_handler_c+0x60> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700ae140: 9804         	ldr	r0, [sp, #0x10]
700ae142: f7ff fd4d    	bl	0x700adbe0 <HwiP_clearInt> @ imm = #-0x566
;         }
700ae146: e7ff         	b	0x700ae148 <HwiP_irq_handler_c+0x68> @ imm = #-0x2
;         HwiP_ackIRQ(intNum);
700ae148: 9804         	ldr	r0, [sp, #0x10]
700ae14a: f000 f859    	bl	0x700ae200 <HwiP_ackIRQ> @ imm = #0xb2
;     }
700ae14e: e00c         	b	0x700ae16a <HwiP_irq_handler_c+0x8a> @ imm = #0x18
;         gHwiCtrl.spuriousIRQCount++;
700ae150: f240 0100    	movw	r1, #0x0
700ae154: f2c7 0108    	movt	r1, #0x7008
700ae158: f44f 5280    	mov.w	r2, #0x1000
700ae15c: 5888         	ldr	r0, [r1, r2]
700ae15e: 3001         	adds	r0, #0x1
700ae160: 5088         	str	r0, [r1, r2]
700ae162: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700ae164: f000 f84c    	bl	0x700ae200 <HwiP_ackIRQ> @ imm = #0x98
700ae168: e7ff         	b	0x700ae16a <HwiP_irq_handler_c+0x8a> @ imm = #-0x2
; }
700ae16a: b006         	add	sp, #0x18
700ae16c: bd80         	pop	{r7, pc}
700ae16e: bf00         	nop

700ae170 <HwiP_getIRQ>:
; {
700ae170: b084         	sub	sp, #0x10
700ae172: 9003         	str	r0, [sp, #0xc]
700ae174: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700ae178: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700ae17a: 9903         	ldr	r1, [sp, #0xc]
700ae17c: 2000         	movs	r0, #0x0
700ae17e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTIRQ);
700ae180: f240 40c8    	movw	r0, #0x4c8
700ae184: f2c7 000b    	movt	r0, #0x700b
700ae188: 6800         	ldr	r0, [r0]
700ae18a: 3020         	adds	r0, #0x20
700ae18c: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700ae18e: 9802         	ldr	r0, [sp, #0x8]
700ae190: 6800         	ldr	r0, [r0]
700ae192: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700ae194: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ae198: 0600         	lsls	r0, r0, #0x18
700ae19a: 2800         	cmp	r0, #0x0
700ae19c: d508         	bpl	0x700ae1b0 <HwiP_getIRQ+0x40> @ imm = #0x10
700ae19e: e7ff         	b	0x700ae1a0 <HwiP_getIRQ+0x30> @ imm = #-0x2
;         *intNum = (value & (HwiP_MAX_INTERRUPTS-1U));
700ae1a0: 9800         	ldr	r0, [sp]
700ae1a2: f36f 205f    	bfc	r0, #9, #23
700ae1a6: 9903         	ldr	r1, [sp, #0xc]
700ae1a8: 6008         	str	r0, [r1]
700ae1aa: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700ae1ac: 9001         	str	r0, [sp, #0x4]
;     }
700ae1ae: e7ff         	b	0x700ae1b0 <HwiP_getIRQ+0x40> @ imm = #-0x2
;     return status;
700ae1b0: 9801         	ldr	r0, [sp, #0x4]
700ae1b2: b004         	add	sp, #0x10
700ae1b4: 4770         	bx	lr
700ae1b6: bf00         	nop
700ae1b8: bf00         	nop
700ae1ba: bf00         	nop
700ae1bc: bf00         	nop
700ae1be: bf00         	nop

700ae1c0 <HwiP_isPulse>:
; {
700ae1c0: b083         	sub	sp, #0xc
700ae1c2: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700ae1c4: f240 40c8    	movw	r0, #0x4c8
700ae1c8: f2c7 000b    	movt	r0, #0x700b
700ae1cc: 6801         	ldr	r1, [r0]
700ae1ce: 9802         	ldr	r0, [sp, #0x8]
700ae1d0: f400 70f0    	and	r0, r0, #0x1e0
700ae1d4: 4408         	add	r0, r1
700ae1d6: f200 401c    	addw	r0, r0, #0x41c
700ae1da: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700ae1dc: 9802         	ldr	r0, [sp, #0x8]
700ae1de: f000 001f    	and	r0, r0, #0x1f
700ae1e2: 9000         	str	r0, [sp]
;     return ((*addr >> bitPos) & 0x1u );
700ae1e4: 9801         	ldr	r0, [sp, #0x4]
700ae1e6: 6800         	ldr	r0, [r0]
700ae1e8: 9900         	ldr	r1, [sp]
700ae1ea: 40c8         	lsrs	r0, r1
700ae1ec: f000 0001    	and	r0, r0, #0x1
700ae1f0: b003         	add	sp, #0xc
700ae1f2: 4770         	bx	lr
700ae1f4: bf00         	nop
700ae1f6: bf00         	nop
700ae1f8: bf00         	nop
700ae1fa: bf00         	nop
700ae1fc: bf00         	nop
700ae1fe: bf00         	nop

700ae200 <HwiP_ackIRQ>:
; {
700ae200: b082         	sub	sp, #0x8
700ae202: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700ae204: f240 40c8    	movw	r0, #0x4c8
700ae208: f2c7 000b    	movt	r0, #0x700b
700ae20c: 6800         	ldr	r0, [r0]
700ae20e: 3018         	adds	r0, #0x18
700ae210: 9000         	str	r0, [sp]
;     *addr= intNum;
700ae212: 9801         	ldr	r0, [sp, #0x4]
700ae214: 9900         	ldr	r1, [sp]
700ae216: 6008         	str	r0, [r1]
; }
700ae218: b002         	add	sp, #0x8
700ae21a: 4770         	bx	lr
700ae21c: bf00         	nop
700ae21e: bf00         	nop

700ae220 <HwiP_fiq_handler>:
; {
700ae220: b5df         	push	{r0, r1, r2, r3, r4, r6, r7, lr}
700ae222: af06         	add	r7, sp, #0x18
700ae224: b086         	sub	sp, #0x18
700ae226: 466c         	mov	r4, sp
700ae228: f36f 0402    	bfc	r4, #0, #3
700ae22c: 46a5         	mov	sp, r4
;     gdummy = HwiP_getFIQVecAddr();
700ae22e: f000 f867    	bl	0x700ae300 <HwiP_getFIQVecAddr> @ imm = #0xce
700ae232: f244 188c    	movw	r8, #0x418c
700ae236: f2c7 0808    	movt	r8, #0x7008
700ae23a: f8c8 0000    	str.w	r0, [r8]
700ae23e: a804         	add	r0, sp, #0x10
;     status = HwiP_getFIQ(&intNum);
700ae240: f000 f86e    	bl	0x700ae320 <HwiP_getFIQ> @ imm = #0xdc
700ae244: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700ae246: f8dd 8014    	ldr.w	r8, [sp, #0x14]
700ae24a: f1b8 0f00    	cmp.w	r8, #0x0
700ae24e: d13b         	bne	0x700ae2c8 <HwiP_fiq_handler+0xa8> @ imm = #0x76
700ae250: e7ff         	b	0x700ae252 <HwiP_fiq_handler+0x32> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700ae252: 9804         	ldr	r0, [sp, #0x10]
700ae254: f7ff ffb4    	bl	0x700ae1c0 <HwiP_isPulse> @ imm = #-0x98
700ae258: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700ae25a: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700ae25e: f1b8 0f00    	cmp.w	r8, #0x0
700ae262: d004         	beq	0x700ae26e <HwiP_fiq_handler+0x4e> @ imm = #0x8
700ae264: e7ff         	b	0x700ae266 <HwiP_fiq_handler+0x46> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700ae266: 9804         	ldr	r0, [sp, #0x10]
700ae268: f7ff fcba    	bl	0x700adbe0 <HwiP_clearInt> @ imm = #-0x68c
;         }
700ae26c: e7ff         	b	0x700ae26e <HwiP_fiq_handler+0x4e> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700ae26e: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700ae272: f240 0800    	movw	r8, #0x0
700ae276: f2c7 0808    	movt	r8, #0x7008
700ae27a: f858 9029    	ldr.w	r9, [r8, r9, lsl #2]
700ae27e: f8cd 9008    	str.w	r9, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700ae282: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700ae286: eb08 0889    	add.w	r8, r8, r9, lsl #2
700ae28a: f8d8 8800    	ldr.w	r8, [r8, #0x800]
700ae28e: f8cd 8004    	str.w	r8, [sp, #0x4]
;         if(isr!=NULL)
700ae292: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700ae296: f1b8 0f00    	cmp.w	r8, #0x0
700ae29a: d005         	beq	0x700ae2a8 <HwiP_fiq_handler+0x88> @ imm = #0xa
700ae29c: e7ff         	b	0x700ae29e <HwiP_fiq_handler+0x7e> @ imm = #-0x2
;             isr(args);
700ae29e: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700ae2a2: 9801         	ldr	r0, [sp, #0x4]
700ae2a4: 47c0         	blx	r8
;         }
700ae2a6: e7ff         	b	0x700ae2a8 <HwiP_fiq_handler+0x88> @ imm = #-0x2
;         (void)HwiP_disableFIQ();
700ae2a8: f000 e9ea    	blx	0x700ae680 <HwiP_disableFIQ> @ imm = #0x3d4
;         if(isPulse == 0U)
700ae2ac: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700ae2b0: f1b8 0f00    	cmp.w	r8, #0x0
700ae2b4: d104         	bne	0x700ae2c0 <HwiP_fiq_handler+0xa0> @ imm = #0x8
700ae2b6: e7ff         	b	0x700ae2b8 <HwiP_fiq_handler+0x98> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700ae2b8: 9804         	ldr	r0, [sp, #0x10]
700ae2ba: f7ff fc91    	bl	0x700adbe0 <HwiP_clearInt> @ imm = #-0x6de
;         }
700ae2be: e7ff         	b	0x700ae2c0 <HwiP_fiq_handler+0xa0> @ imm = #-0x2
;         HwiP_ackFIQ(intNum);
700ae2c0: 9804         	ldr	r0, [sp, #0x10]
700ae2c2: f000 f855    	bl	0x700ae370 <HwiP_ackFIQ> @ imm = #0xaa
;     }
700ae2c6: e00f         	b	0x700ae2e8 <HwiP_fiq_handler+0xc8> @ imm = #0x1e
;         gHwiCtrl.spuriousFIQCount++;
700ae2c8: f240 0900    	movw	r9, #0x0
700ae2cc: f2c7 0908    	movt	r9, #0x7008
700ae2d0: f241 0a04    	movw	r10, #0x1004
700ae2d4: f859 800a    	ldr.w	r8, [r9, r10]
700ae2d8: f108 0801    	add.w	r8, r8, #0x1
700ae2dc: f849 800a    	str.w	r8, [r9, r10]
700ae2e0: 2000         	movs	r0, #0x0
;         HwiP_ackFIQ(0);
700ae2e2: f000 f845    	bl	0x700ae370 <HwiP_ackFIQ> @ imm = #0x8a
700ae2e6: e7ff         	b	0x700ae2e8 <HwiP_fiq_handler+0xc8> @ imm = #-0x2
; }
700ae2e8: f1a7 0418    	sub.w	r4, r7, #0x18
700ae2ec: 46a5         	mov	sp, r4
700ae2ee: e8bd 40df    	pop.w	{r0, r1, r2, r3, r4, r6, r7, lr}
700ae2f2: f3de 8f04    	subs	pc, lr, #0x4
700ae2f6: bf00         	nop
700ae2f8: bf00         	nop
700ae2fa: bf00         	nop
700ae2fc: bf00         	nop
700ae2fe: bf00         	nop

700ae300 <HwiP_getFIQVecAddr>:
; {
700ae300: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700ae302: f240 40c8    	movw	r0, #0x4c8
700ae306: f2c7 000b    	movt	r0, #0x700b
700ae30a: 6800         	ldr	r0, [r0]
700ae30c: 301c         	adds	r0, #0x1c
700ae30e: 9000         	str	r0, [sp]
;     return *addr;
700ae310: 9800         	ldr	r0, [sp]
700ae312: 6800         	ldr	r0, [r0]
700ae314: b001         	add	sp, #0x4
700ae316: 4770         	bx	lr
700ae318: bf00         	nop
700ae31a: bf00         	nop
700ae31c: bf00         	nop
700ae31e: bf00         	nop

700ae320 <HwiP_getFIQ>:
; {
700ae320: b084         	sub	sp, #0x10
700ae322: 9003         	str	r0, [sp, #0xc]
700ae324: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700ae328: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700ae32a: 9903         	ldr	r1, [sp, #0xc]
700ae32c: 2000         	movs	r0, #0x0
700ae32e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTFIQ);
700ae330: f240 40c8    	movw	r0, #0x4c8
700ae334: f2c7 000b    	movt	r0, #0x700b
700ae338: 6800         	ldr	r0, [r0]
700ae33a: 3024         	adds	r0, #0x24
700ae33c: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700ae33e: 9802         	ldr	r0, [sp, #0x8]
700ae340: 6800         	ldr	r0, [r0]
700ae342: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700ae344: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ae348: 0600         	lsls	r0, r0, #0x18
700ae34a: 2800         	cmp	r0, #0x0
700ae34c: d508         	bpl	0x700ae360 <HwiP_getFIQ+0x40> @ imm = #0x10
700ae34e: e7ff         	b	0x700ae350 <HwiP_getFIQ+0x30> @ imm = #-0x2
;         *intNum = (value & 0x3FFU);
700ae350: 9800         	ldr	r0, [sp]
700ae352: f36f 209f    	bfc	r0, #10, #22
700ae356: 9903         	ldr	r1, [sp, #0xc]
700ae358: 6008         	str	r0, [r1]
700ae35a: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700ae35c: 9001         	str	r0, [sp, #0x4]
;     }
700ae35e: e7ff         	b	0x700ae360 <HwiP_getFIQ+0x40> @ imm = #-0x2
;     return status;
700ae360: 9801         	ldr	r0, [sp, #0x4]
700ae362: b004         	add	sp, #0x10
700ae364: 4770         	bx	lr
700ae366: bf00         	nop
700ae368: bf00         	nop
700ae36a: bf00         	nop
700ae36c: bf00         	nop
700ae36e: bf00         	nop

700ae370 <HwiP_ackFIQ>:
; {
700ae370: b082         	sub	sp, #0x8
700ae372: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700ae374: f240 40c8    	movw	r0, #0x4c8
700ae378: f2c7 000b    	movt	r0, #0x700b
700ae37c: 6800         	ldr	r0, [r0]
700ae37e: 301c         	adds	r0, #0x1c
700ae380: 9000         	str	r0, [sp]
;     *addr= intNum;
700ae382: 9801         	ldr	r0, [sp, #0x4]
700ae384: 9900         	ldr	r1, [sp]
700ae386: 6008         	str	r0, [r1]
; }
700ae388: b002         	add	sp, #0x8
700ae38a: 4770         	bx	lr
700ae38c: bf00         	nop
700ae38e: bf00         	nop

700ae390 <HwiP_reserved_handler>:
; {
700ae390: b5d0         	push	{r4, r6, r7, lr}
700ae392: af02         	add	r7, sp, #0x8
700ae394: b082         	sub	sp, #0x8
700ae396: 466c         	mov	r4, sp
700ae398: f36f 0402    	bfc	r4, #0, #3
700ae39c: 46a5         	mov	sp, r4
700ae39e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700ae3a2: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U) { ; }
700ae3a6: e7ff         	b	0x700ae3a8 <HwiP_reserved_handler+0x18> @ imm = #-0x2
700ae3a8: f8dd e004    	ldr.w	lr, [sp, #0x4]
700ae3ac: f1be 0f00    	cmp.w	lr, #0x0
700ae3b0: d001         	beq	0x700ae3b6 <HwiP_reserved_handler+0x26> @ imm = #0x2
700ae3b2: e7ff         	b	0x700ae3b4 <HwiP_reserved_handler+0x24> @ imm = #-0x2
700ae3b4: e7f8         	b	0x700ae3a8 <HwiP_reserved_handler+0x18> @ imm = #-0x10
; }
700ae3b6: f1a7 0408    	sub.w	r4, r7, #0x8
700ae3ba: 46a5         	mov	sp, r4
700ae3bc: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700ae3c0: f3de 8f00    	subs	pc, lr, #0x0
700ae3c4: bf00         	nop
700ae3c6: bf00         	nop
700ae3c8: bf00         	nop
700ae3ca: bf00         	nop
700ae3cc: bf00         	nop
700ae3ce: bf00         	nop

700ae3d0 <HwiP_undefined_handler>:
; {
700ae3d0: b5d0         	push	{r4, r6, r7, lr}
700ae3d2: af02         	add	r7, sp, #0x8
700ae3d4: b082         	sub	sp, #0x8
700ae3d6: 466c         	mov	r4, sp
700ae3d8: f36f 0402    	bfc	r4, #0, #3
700ae3dc: 46a5         	mov	sp, r4
700ae3de: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700ae3e2: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){  ; }
700ae3e6: e7ff         	b	0x700ae3e8 <HwiP_undefined_handler+0x18> @ imm = #-0x2
700ae3e8: f8dd e004    	ldr.w	lr, [sp, #0x4]
700ae3ec: f1be 0f00    	cmp.w	lr, #0x0
700ae3f0: d001         	beq	0x700ae3f6 <HwiP_undefined_handler+0x26> @ imm = #0x2
700ae3f2: e7ff         	b	0x700ae3f4 <HwiP_undefined_handler+0x24> @ imm = #-0x2
700ae3f4: e7f8         	b	0x700ae3e8 <HwiP_undefined_handler+0x18> @ imm = #-0x10
; }
700ae3f6: f1a7 0408    	sub.w	r4, r7, #0x8
700ae3fa: 46a5         	mov	sp, r4
700ae3fc: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700ae400: f3de 8f00    	subs	pc, lr, #0x0
700ae404: bf00         	nop
700ae406: bf00         	nop
700ae408: bf00         	nop
700ae40a: bf00         	nop
700ae40c: bf00         	nop
700ae40e: bf00         	nop

700ae410 <HwiP_prefetch_abort_handler>:
; {
700ae410: b5d0         	push	{r4, r6, r7, lr}
700ae412: af02         	add	r7, sp, #0x8
700ae414: b082         	sub	sp, #0x8
700ae416: 466c         	mov	r4, sp
700ae418: f36f 0402    	bfc	r4, #0, #3
700ae41c: 46a5         	mov	sp, r4
700ae41e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700ae422: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U)  { ;}
700ae426: e7ff         	b	0x700ae428 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x2
700ae428: f8dd e004    	ldr.w	lr, [sp, #0x4]
700ae42c: f1be 0f00    	cmp.w	lr, #0x0
700ae430: d001         	beq	0x700ae436 <HwiP_prefetch_abort_handler+0x26> @ imm = #0x2
700ae432: e7ff         	b	0x700ae434 <HwiP_prefetch_abort_handler+0x24> @ imm = #-0x2
700ae434: e7f8         	b	0x700ae428 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x10
; }
700ae436: f1a7 0408    	sub.w	r4, r7, #0x8
700ae43a: 46a5         	mov	sp, r4
700ae43c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700ae440: f3de 8f04    	subs	pc, lr, #0x4
700ae444: bf00         	nop
700ae446: bf00         	nop
700ae448: bf00         	nop
700ae44a: bf00         	nop
700ae44c: bf00         	nop
700ae44e: bf00         	nop

700ae450 <HwiP_data_abort_handler_c>:
; {
700ae450: b5d0         	push	{r4, r6, r7, lr}
700ae452: af02         	add	r7, sp, #0x8
700ae454: b082         	sub	sp, #0x8
700ae456: 466c         	mov	r4, sp
700ae458: f36f 0402    	bfc	r4, #0, #3
700ae45c: 46a5         	mov	sp, r4
700ae45e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700ae462: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){ ; }
700ae466: e7ff         	b	0x700ae468 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x2
700ae468: f8dd e004    	ldr.w	lr, [sp, #0x4]
700ae46c: f1be 0f00    	cmp.w	lr, #0x0
700ae470: d001         	beq	0x700ae476 <HwiP_data_abort_handler_c+0x26> @ imm = #0x2
700ae472: e7ff         	b	0x700ae474 <HwiP_data_abort_handler_c+0x24> @ imm = #-0x2
700ae474: e7f8         	b	0x700ae468 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x10
; }
700ae476: f1a7 0408    	sub.w	r4, r7, #0x8
700ae47a: 46a5         	mov	sp, r4
700ae47c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700ae480: f3de 8f04    	subs	pc, lr, #0x4

700ae484 <vPortRestoreTaskContext>:
;         CPS     #SYS_MODE
700ae484: f102001f     	cps	#0x1f
;         portRESTORE_CONTEXT
700ae488: e59f01c8     	ldr	r0, [pc, #0x1c8]        @ 0x700ae658 <pxCurrentTCBConst>
700ae48c: e5901000     	ldr	r1, [r0]
700ae490: e591d000     	ldr	sp, [r1]
700ae494: e59f01c0     	ldr	r0, [pc, #0x1c0]        @ 0x700ae65c <ulPortTaskHasFPUContextConst>
700ae498: e49d1004     	ldr	r1, [sp], #4
700ae49c: e5801000     	str	r1, [r0]
700ae4a0: e3510000     	cmp	r1, #0
700ae4a4: 149d0004     	ldrne	r0, [sp], #4
700ae4a8: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700ae4ac: 1ee10a10     	vmsrne	fpscr, r0
700ae4b0: f57ff01f     	clrex
700ae4b4: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700ae4b8: f8bd0a00     	rfeia	sp!

700ae4bc <HwiP_svc_handler>:
;         portSAVE_CONTEXT
700ae4bc: f96d051f     	srsdb	sp!, #0x1f
700ae4c0: f102001f     	cps	#0x1f
700ae4c4: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700ae4c8: e59f218c     	ldr	r2, [pc, #0x18c]        @ 0x700ae65c <ulPortTaskHasFPUContextConst>
700ae4cc: e5923000     	ldr	r3, [r2]
700ae4d0: e3530000     	cmp	r3, #0
700ae4d4: 1ef11a10     	vmrsne	r1, fpscr
700ae4d8: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700ae4dc: 152d1004     	strne	r1, [sp, #-0x4]!
700ae4e0: e52d3004     	str	r3, [sp, #-0x4]!
700ae4e4: e59f016c     	ldr	r0, [pc, #0x16c]        @ 0x700ae658 <pxCurrentTCBConst>
700ae4e8: e5901000     	ldr	r1, [r0]
700ae4ec: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700ae4f0: e59f0168     	ldr	r0, [pc, #0x168]        @ 0x700ae660 <vTaskSwitchContextConst>
;         BLX     R0
700ae4f4: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700ae4f8: e59f0158     	ldr	r0, [pc, #0x158]        @ 0x700ae658 <pxCurrentTCBConst>
700ae4fc: e5901000     	ldr	r1, [r0]
700ae500: e591d000     	ldr	sp, [r1]
700ae504: e59f0150     	ldr	r0, [pc, #0x150]        @ 0x700ae65c <ulPortTaskHasFPUContextConst>
700ae508: e49d1004     	ldr	r1, [sp], #4
700ae50c: e5801000     	str	r1, [r0]
700ae510: e3510000     	cmp	r1, #0
700ae514: 149d0004     	ldrne	r0, [sp], #4
700ae518: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700ae51c: 1ee10a10     	vmsrne	fpscr, r0
700ae520: f57ff01f     	clrex
700ae524: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700ae528: f8bd0a00     	rfeia	sp!

700ae52c <HwiP_irq_handler>:
;         SUB             lr, lr, #4
700ae52c: e24ee004     	sub	lr, lr, #4
;         PUSH    {lr}
700ae530: e52de004     	str	lr, [sp, #-0x4]!
;         MRS     lr, SPSR
700ae534: e14fe000     	mrs	lr, spsr
;         PUSH    {lr}
700ae538: e52de004     	str	lr, [sp, #-0x4]!
;         CPS  #SVC_MODE
700ae53c: f1020013     	cps	#0x13
;         PUSH    {r0-r4, r12}
700ae540: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         LDR     r3, ulPortInterruptNestingConst
700ae544: e59f3118     	ldr	r3, [pc, #0x118]        @ 0x700ae664 <ulPortInterruptNestingConst>
;         LDR     r1, [r3]
700ae548: e5931000     	ldr	r1, [r3]
;         ADD     r4, r1, #1
700ae54c: e2814001     	add	r4, r1, #1
;         STR     r4, [r3]
700ae550: e5834000     	str	r4, [r3]
;         FMRX  R0, FPSCR
700ae554: eef10a10     	vmrs	r0, fpscr
;         VPUSH {D0-D15}
700ae558: ed2d0b20     	vpush	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         PUSH  {R0}
700ae55c: e52d0004     	str	r0, [sp, #-0x4]!
;         MOV     r2, sp
700ae560: e1a0200d     	mov	r2, sp
;         AND     r2, r2, #4
700ae564: e2022004     	and	r2, r2, #4
;         SUB     sp, sp, r2
700ae568: e04dd002     	sub	sp, sp, r2
;         PUSH    {r0-r4, lr}
700ae56c: e92d401f     	push	{r0, r1, r2, r3, r4, lr}
;         LDR     r1, vApplicationIRQHandlerConst
700ae570: e59f10f0     	ldr	r1, [pc, #0xf0]         @ 0x700ae668 <vApplicationIRQHandlerConst>
;         BLX     r1
700ae574: e12fff31     	blx	r1
;         POP     {r0-r4, lr}
700ae578: e8bd401f     	pop	{r0, r1, r2, r3, r4, lr}
;         ADD     sp, sp, r2
700ae57c: e08dd002     	add	sp, sp, r2
;         CPSID   i
700ae580: f10c0080     	cpsid	i
;         DSB
700ae584: f57ff04f     	dsb	sy
;         ISB
700ae588: f57ff06f     	isb	sy
;         POP   {R0}
700ae58c: e49d0004     	ldr	r0, [sp], #4
;         VPOP  {D0-D15}
700ae590: ecbd0b20     	vpop	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         VMSR  FPSCR, R0
700ae594: eee10a10     	vmsr	fpscr, r0
;         STR     r1, [r3]
700ae598: e5831000     	str	r1, [r3]
;         CMP     r1, #0
700ae59c: e3510000     	cmp	r1, #0
;         BNE     exit_without_switch
700ae5a0: 1a000003     	bne	0x700ae5b4 <exit_without_switch> @ imm = #0xc
;         LDR     r1, =ulPortYieldRequired
700ae5a4: e59f10c0     	ldr	r1, [pc, #0xc0]         @ 0x700ae66c <vApplicationIRQHandlerConst+0x4>
;         LDR     r0, [r1]
700ae5a8: e5910000     	ldr	r0, [r1]
;         CMP     r0, #0
700ae5ac: e3500000     	cmp	r0, #0
;         BNE     switch_before_exit
700ae5b0: 1a000005     	bne	0x700ae5cc <switch_before_exit> @ imm = #0x14

700ae5b4 <exit_without_switch>:
;         POP     {r0-r4, r12}
700ae5b4: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700ae5b8: f1020012     	cps	#0x12
;         POP     {LR}
700ae5bc: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700ae5c0: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700ae5c4: e49de004     	ldr	lr, [sp], #4
;         MOVS    PC, LR
700ae5c8: e1b0f00e     	movs	pc, lr

700ae5cc <switch_before_exit>:
;         MOV     r0, #0
700ae5cc: e3a00000     	mov	r0, #0
;         STR     r0, [r1]
700ae5d0: e5810000     	str	r0, [r1]
;         POP     {r0-r4, r12}
700ae5d4: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700ae5d8: f1020012     	cps	#0x12
;         POP     {LR}
700ae5dc: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700ae5e0: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700ae5e4: e49de004     	ldr	lr, [sp], #4
;         portSAVE_CONTEXT
700ae5e8: f96d051f     	srsdb	sp!, #0x1f
700ae5ec: f102001f     	cps	#0x1f
700ae5f0: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700ae5f4: e59f2060     	ldr	r2, [pc, #0x60]         @ 0x700ae65c <ulPortTaskHasFPUContextConst>
700ae5f8: e5923000     	ldr	r3, [r2]
700ae5fc: e3530000     	cmp	r3, #0
700ae600: 1ef11a10     	vmrsne	r1, fpscr
700ae604: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700ae608: 152d1004     	strne	r1, [sp, #-0x4]!
700ae60c: e52d3004     	str	r3, [sp, #-0x4]!
700ae610: e59f0040     	ldr	r0, [pc, #0x40]         @ 0x700ae658 <pxCurrentTCBConst>
700ae614: e5901000     	ldr	r1, [r0]
700ae618: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700ae61c: e59f003c     	ldr	r0, [pc, #0x3c]         @ 0x700ae660 <vTaskSwitchContextConst>
;         BLX     R0
700ae620: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700ae624: e59f002c     	ldr	r0, [pc, #0x2c]         @ 0x700ae658 <pxCurrentTCBConst>
700ae628: e5901000     	ldr	r1, [r0]
700ae62c: e591d000     	ldr	sp, [r1]
700ae630: e59f0024     	ldr	r0, [pc, #0x24]         @ 0x700ae65c <ulPortTaskHasFPUContextConst>
700ae634: e49d1004     	ldr	r1, [sp], #4
700ae638: e5801000     	str	r1, [r0]
700ae63c: e3510000     	cmp	r1, #0
700ae640: 149d0004     	ldrne	r0, [sp], #4
700ae644: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700ae648: 1ee10a10     	vmsrne	fpscr, r0
700ae64c: f57ff01f     	clrex
700ae650: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700ae654: f8bd0a00     	rfeia	sp!

700ae658 <pxCurrentTCBConst>:
700ae658: dc 04 0b 70  	.word	0x700b04dc

700ae65c <ulPortTaskHasFPUContextConst>:
700ae65c: f0 04 0b 70  	.word	0x700b04f0

700ae660 <vTaskSwitchContextConst>:
700ae660: d1 50 0a 70  	.word	0x700a50d1

700ae664 <ulPortInterruptNestingConst>:
700ae664: e8 04 0b 70  	.word	0x700b04e8

700ae668 <vApplicationIRQHandlerConst>:
700ae668: e1 e0 0a 70  	.word	0x700ae0e1
700ae66c: f4 04 0b 70  	.word	0x700b04f4

700ae670 <HwiP_disable>:
;         mrs     r0, cpsr
700ae670: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x80
700ae674: e380c080     	orr	r12, r0, #128
;         msr     cpsr_cf, r12
700ae678: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700ae67c: e12fff1e     	bx	lr

700ae680 <HwiP_disableFIQ>:
;         mrs     r0, cpsr
700ae680: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x40
700ae684: e380c040     	orr	r12, r0, #64
;         msr     cpsr_cf, r12
700ae688: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700ae68c: e12fff1e     	bx	lr

700ae690 <HwiP_enable>:
;         mrs     r0, cpsr
700ae690: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x80
700ae694: e3c0c080     	bic	r12, r0, #128
;         msr     cpsr_cf, r12
700ae698: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700ae69c: e12fff1e     	bx	lr

700ae6a0 <HwiP_enableFIQ>:
;         mrs     r0, cpsr
700ae6a0: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x40
700ae6a4: e3c0c040     	bic	r12, r0, #64
;         msr     cpsr_cf, r12
700ae6a8: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700ae6ac: e12fff1e     	bx	lr

700ae6b0 <HwiP_restore>:
;         msr     cpsr_cf, r0
700ae6b0: e129f000     	msr	CPSR_fc, r0
;         bx      LR
700ae6b4: e12fff1e     	bx	lr

700ae6b8 <HwiP_enableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700ae6b8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR     r0, r0, #(1<<24)         /* Set VE mask (VIC controller provides handler address for IRQ) */
700ae6bc: e3800401     	orr	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700ae6c0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700ae6c4: e12fff1e     	bx	lr

700ae6c8 <HwiP_disableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700ae6c8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC     r0, r0, #(1<<24)         /* Clear VE mask (VIC controller provides handler address for IRQ) */
700ae6cc: e3c00401     	bic	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700ae6d0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700ae6d4: e12fff1e     	bx	lr

700ae6d8 <HwiP_getCPSR>:
;         mrs     r0, cpsr
700ae6d8: e10f0000     	mrs	r0, apsr
;         bx      LR
700ae6dc: e12fff1e     	bx	lr

700ae6e0 <HwiP_data_abort_handler>:
;         PUSH	{r0-r4, r12}
700ae6e0: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         MRS r0, SPSR
700ae6e4: e14f0000     	mrs	r0, spsr
;         AND r1, r0, #0x20
700ae6e8: e2001020     	and	r1, r0, #32
;         CMP R1, #0
700ae6ec: e3510000     	cmp	r1, #0
;         BEQ ARM_STATE
700ae6f0: 0a000000     	beq	0x700ae6f8 <ARM_STATE>  @ imm = #0x0
;         SUB lr, lr, #2
700ae6f4: e24ee002     	sub	lr, lr, #2

700ae6f8 <ARM_STATE>:
;         SUB lr, lr, #4
700ae6f8: e24ee004     	sub	lr, lr, #4

700ae6fc <END>:
;         PUSH	{lr}
700ae6fc: e52de004     	str	lr, [sp, #-0x4]!
;         MRS	lr, SPSR
700ae700: e14fe000     	mrs	lr, spsr
;         PUSH	{lr}
700ae704: e52de004     	str	lr, [sp, #-0x4]!
;         LDR	r1, HwiP_data_abort_handler_const
700ae708: e59f1014     	ldr	r1, [pc, #0x14]         @ 0x700ae724 <HwiP_data_abort_handler_const>
;         BLX	r1
700ae70c: e12fff31     	blx	r1
;         POP	{LR}
700ae710: e49de004     	ldr	lr, [sp], #4
;         MSR	SPSR_cxsf, LR
700ae714: e16ff00e     	msr	SPSR_fsxc, lr
;         POP	{LR}
700ae718: e49de004     	ldr	lr, [sp], #4
;         POP	{r0-r4, r12}
700ae71c: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         MOVS	PC, LR
700ae720: e1b0f00e     	movs	pc, lr

700ae724 <HwiP_data_abort_handler_const>:
700ae724: 51 e4 0a 70  	.word	0x700ae451
700ae728: 00 00 00 00  	.word	0x00000000
700ae72c: 00 00 00 00  	.word	0x00000000

Disassembly of section .text.cache:

700ae730 <CacheP_disableL1d>:
;         push    {r0-r7, r9-r11, lr}
700ae730: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700ae734: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x0004         // clear C bit
700ae738: e3c00004     	bic	r0, r0, #4
;         dsb
700ae73c: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0 // L1D cache disabled
700ae740: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700ae744: e30e095c     	movw	r0, #0xe95c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700ae748: e347000a     	movt	r0, #0x700a
;         blx     r0
700ae74c: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700ae750: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700ae754: e12fff1e     	bx	lr

700ae758 <CacheP_disableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700ae758: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1000         // clear I bit
700ae75c: e3c00a01     	bic	r0, r0, #4096
;         mcr     p15, #0, r0, c1, c0, #0 // L1P cache disabled
700ae760: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700ae764: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         isb
700ae768: f57ff06f     	isb	sy
;         bx      lr
700ae76c: e12fff1e     	bx	lr

700ae770 <CacheP_enableL1d>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCR register
700ae770: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x0004          // set C bit (bit 2) to 1
700ae774: e3800004     	orr	r0, r0, #4
;         dsb
700ae778: f57ff04f     	dsb	sy
;         mcr     p15, #0, r1, c15, c5, #0 // Invalidate entire data cache
700ae77c: ee0f1f15     	mcr	p15, #0x0, r1, c15, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0  // L1D cache enabled
700ae780: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      lr
700ae784: e12fff1e     	bx	lr

700ae788 <CacheP_enableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700ae788: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1000         // set I bit (bit 12) to 1
700ae78c: e3800a01     	orr	r0, r0, #4096
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700ae790: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0 // ICache enabled
700ae794: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb
700ae798: f57ff06f     	isb	sy
;         bx      lr
700ae79c: e12fff1e     	bx	lr

700ae7a0 <CacheP_invL1d>:
;         push    {r4}
700ae7a0: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700ae7a4: e0801001     	add	r1, r0, r1
;         ldr     r3, l1dCacheLineSizeInvL1dAddr
700ae7a8: e59f3024     	ldr	r3, [pc, #0x24]         @ 0x700ae7d4 <l1dCacheLineSizeInvL1dAddr>
;         ldr     r3, [r3]
700ae7ac: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700ae7b0: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700ae7b4: e1c00004     	bic	r0, r0, r4

700ae7b8 <invL1dCache_loop>:
;         mcr     p15, #0, r0, c7, c6, #1 // invalidate single entry in L1D cache
700ae7b8: ee070f36     	mcr	p15, #0x0, r0, c7, c6, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700ae7bc: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700ae7c0: e1500001     	cmp	r0, r1
;         blo     invL1dCache_loop        // loop if > 0
700ae7c4: 3afffffb     	blo	0x700ae7b8 <invL1dCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700ae7c8: f57ff04f     	dsb	sy
;         pop     {r4}
700ae7cc: e49d4004     	ldr	r4, [sp], #4
;         bx      lr                      // return
700ae7d0: e12fff1e     	bx	lr

700ae7d4 <l1dCacheLineSizeInvL1dAddr>:
700ae7d4: 24 f5 0a 70  	.word	0x700af524

700ae7d8 <CacheP_invL1p>:
;         push    {r4}
700ae7d8: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700ae7dc: e0801001     	add	r1, r0, r1
;         ldr     r3, l1pCacheLineSizeAddr
700ae7e0: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700ae810 <l1pCacheLineSizeAddr>
;         ldr     r3, [r3]
700ae7e4: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700ae7e8: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700ae7ec: e1c00004     	bic	r0, r0, r4

700ae7f0 <invL1pCache_loop>:
;         mcr     p15, #0, r0, c7, c5, #1 // invalidate single entry in ICache
700ae7f0: ee070f35     	mcr	p15, #0x0, r0, c7, c5, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700ae7f4: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700ae7f8: e1500001     	cmp	r0, r1
;         blo     invL1pCache_loop        // loop if > 0
700ae7fc: 3afffffb     	blo	0x700ae7f0 <invL1pCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700ae800: f57ff04f     	dsb	sy
;         isb                             // flush instruction pipeline
700ae804: f57ff06f     	isb	sy
;         pop     {r4}
700ae808: e49d4004     	ldr	r4, [sp], #4
;         bx      lr
700ae80c: e12fff1e     	bx	lr

700ae810 <l1pCacheLineSizeAddr>:
700ae810: 40 01 0b 70  	.word	0x700b0140

700ae814 <CacheP_invL1dAll>:
;         mcr     p15, #0, r0, c15, c5, #0 // Invalidate entire data cache
700ae814: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         bx      lr                       // return
700ae818: e12fff1e     	bx	lr

700ae81c <CacheP_invL1pAll>:
;         mcr     p15, #0, r0, c7, c5, #0 // invalidate all entries in ICache
700ae81c: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         bx      lr                      // return
700ae820: e12fff1e     	bx	lr

700ae824 <CacheP_wb>:
;         push    {r4, r5}
700ae824: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700ae828: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700ae82c: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbAddr
700ae830: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700ae85c <l1dCacheLineSizeWbAddr>
;         ldr     r4, [r4]
700ae834: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700ae838: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align address to cache line
700ae83c: e1c00005     	bic	r0, r0, r5

700ae840 <writeback>:
;         mcr     p15, #0, r0, c7, c10, #1 // write back a cache line
700ae840: ee070f3a     	mcr	p15, #0x0, r0, c7, c10, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700ae844: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700ae848: e1500001     	cmp	r0, r1
;         blo     writeback                // loop if count > 0
700ae84c: 3afffffb     	blo	0x700ae840 <writeback>  @ imm = #-0x14
;         dsb                              // drain write buffer
700ae850: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700ae854: e8bd0030     	pop	{r4, r5}
;         bx      lr
700ae858: e12fff1e     	bx	lr

700ae85c <l1dCacheLineSizeWbAddr>:
700ae85c: 24 f5 0a 70  	.word	0x700af524

700ae860 <CacheP_wbInv>:
;         push    {r4, r5}
700ae860: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700ae864: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700ae868: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbInvAddr
700ae86c: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700ae898 <l1dCacheLineSizeWbInvAddr>
;         ldr     r4, [r4]
700ae870: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700ae874: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align blockPtr to cache line
700ae878: e1c00005     	bic	r0, r0, r5

700ae87c <writebackInv>:
;         mcr     p15, #0, r0, c7, c14, #1 // writeback inv a cache line
700ae87c: ee070f3e     	mcr	p15, #0x0, r0, c7, c14, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700ae880: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700ae884: e1500001     	cmp	r0, r1
;         blo     writebackInv             // loop if count > 0
700ae888: 3afffffb     	blo	0x700ae87c <writebackInv> @ imm = #-0x14
;         dsb                              // drain write buffer
700ae88c: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700ae890: e8bd0030     	pop	{r4, r5}
;         bx      lr
700ae894: e12fff1e     	bx	lr

700ae898 <l1dCacheLineSizeWbInvAddr>:
700ae898: 24 f5 0a 70  	.word	0x700af524

700ae89c <CacheP_wbAll>:
;         stmfd   sp!, {r0-r7, r9-r11, lr}
700ae89c: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         dmb                             // Ensure all previous memory accesses
700ae8a0: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700ae8a4: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700ae8a8: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700ae8ac: e1a03ba3     	lsr	r3, r3, #23
;         beq     wbafinished             // if loc is 0, then no need to clean
700ae8b0: 0a00001d     	beq	0x700ae92c <wbafinished> @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700ae8b4: e3a0a000     	mov	r10, #0

700ae8b8 <wbaloop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700ae8b8: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700ae8bc: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700ae8c0: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700ae8c4: e3510002     	cmp	r1, #2
;         blt     wbaskip                 // skip if no cache, or just i-cache
700ae8c8: ba000014     	blt	0x700ae920 <wbaskip>    @ imm = #0x50
;         mrs     r6, cpsr
700ae8cc: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700ae8d0: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700ae8d4: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700ae8d8: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700ae8dc: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700ae8e0: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700ae8e4: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700ae8e8: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700ae8ec: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700ae8f0: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700ae8f4: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700ae8f8: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700ae8fc: e01776a1     	ands	r7, r7, r1, lsr #13

700ae900 <wbaloop2>:
;         mov     r9, r4                  // create working copy of max way size
700ae900: e1a09004     	mov	r9, r4

700ae904 <wbaloop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700ae904: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700ae908: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c10, #2 // clean line by set/way
700ae90c: ee07bf5a     	mcr	p15, #0x0, r11, c7, c10, #0x2
;         subs    r9, r9, #1              // decrement the way
700ae910: e2599001     	subs	r9, r9, #1
;         bge     wbaloop3
700ae914: aafffffa     	bge	0x700ae904 <wbaloop3>   @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700ae918: e2577001     	subs	r7, r7, #1
;         bge     wbaloop2
700ae91c: aafffff7     	bge	0x700ae900 <wbaloop2>   @ imm = #-0x24

700ae920 <wbaskip>:
;         add     r10, r10, #2            // increment cache number
700ae920: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700ae924: e153000a     	cmp	r3, r10
;         bgt     wbaloop1
700ae928: caffffe2     	bgt	0x700ae8b8 <wbaloop1>   @ imm = #-0x78

700ae92c <wbafinished>:
;         mov     r10, #0                 // switch back to cache level 0
700ae92c: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700ae930: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700ae934: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700ae938: f57ff06f     	isb	sy
;         ldmfd   sp!, {r0-r7, r9-r11, lr}
700ae93c: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700ae940: e12fff1e     	bx	lr

700ae944 <CacheP_wbInvAll>:
;         push    {r0-r7, r9-r11, lr}
700ae944: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700ae948: e30e095c     	movw	r0, #0xe95c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700ae94c: e347000a     	movt	r0, #0x700a
;         blx     r0
700ae950: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700ae954: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700ae958: e12fff1e     	bx	lr

700ae95c <CacheP_wbInvAllAsm>:
;         dmb                             // Ensure all previous memory accesses
700ae95c: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700ae960: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700ae964: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700ae968: e1a03ba3     	lsr	r3, r3, #23
;         beq     finished                // if loc is 0, then no need to clean
700ae96c: 0a00001d     	beq	0x700ae9e8 <finished>   @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700ae970: e3a0a000     	mov	r10, #0

700ae974 <loop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700ae974: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700ae978: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700ae97c: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700ae980: e3510002     	cmp	r1, #2
;         blt     skip                    // skip if no cache, or just i-cache
700ae984: ba000014     	blt	0x700ae9dc <skip>       @ imm = #0x50
;         mrs     r6, cpsr
700ae988: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700ae98c: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700ae990: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700ae994: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700ae998: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700ae99c: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700ae9a0: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700ae9a4: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700ae9a8: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700ae9ac: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700ae9b0: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700ae9b4: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700ae9b8: e01776a1     	ands	r7, r7, r1, lsr #13

700ae9bc <loop2>:
;         mov     r9, r4                  // create working copy of max way size
700ae9bc: e1a09004     	mov	r9, r4

700ae9c0 <loop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700ae9c0: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700ae9c4: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c14, #2 // clean & invalidate by set/way
700ae9c8: ee07bf5e     	mcr	p15, #0x0, r11, c7, c14, #0x2
;         subs    r9, r9, #1              // decrement the way
700ae9cc: e2599001     	subs	r9, r9, #1
;         bge     loop3
700ae9d0: aafffffa     	bge	0x700ae9c0 <loop3>      @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700ae9d4: e2577001     	subs	r7, r7, #1
;         bge     loop2
700ae9d8: aafffff7     	bge	0x700ae9bc <loop2>      @ imm = #-0x24

700ae9dc <skip>:
;         add     r10, r10, #2            // increment cache number
700ae9dc: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700ae9e0: e153000a     	cmp	r3, r10
;         bgt     loop1
700ae9e4: caffffe2     	bgt	0x700ae974 <loop1>      @ imm = #-0x78

700ae9e8 <finished>:
;         mov     r10, #0                 // swith back to cache level 0
700ae9e8: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700ae9ec: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700ae9f0: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700ae9f4: f57ff06f     	isb	sy
;         bx      lr
700ae9f8: e12fff1e     	bx	lr

700ae9fc <CacheP_getEnabled>:
;         mov     r0, #0
700ae9fc: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0 // fetch Control Register into r1
700aea00: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1000             // test I bit (bit 12) for L1P
700aea04: e3110a01     	tst	r1, #4096
;         addne   r0, r0, #1              // if I is true, L1P is enabled
700aea08: 12800001     	addne	r0, r0, #1
;         tst     r1, #0x0004             // test C bit (bit 2) for L1D
700aea0c: e3110004     	tst	r1, #4
;         addne   r0, r0, #2              // if C bit is true, L1D is enabled
700aea10: 12800002     	addne	r0, r0, #2
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700aea14: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         tst     r1, #0x0002             // test L2EN bit (bit 1) for L2EN
700aea18: e3110002     	tst	r1, #2
;         beq     getEnabledDone
700aea1c: 0a000003     	beq	0x700aea30 <getEnabledDone> @ imm = #0xc
;         tst     r0, #0x0001
700aea20: e3100001     	tst	r0, #1
;         addne   r0, r0, #4              // If L2EN and L1P then L2P
700aea24: 12800004     	addne	r0, r0, #4
;         tst     r0, #0x0002
700aea28: e3100002     	tst	r0, #2
;         addne   r0, r0, #8              // If L2EN and L1D then L2D
700aea2c: 12800008     	addne	r0, r0, #8

700aea30 <getEnabledDone>:
;         bx      lr
700aea30: e12fff1e     	bx	lr

700aea34 <CacheP_getCacheLevelInfo>:
;         mcr     p15, #2, r0, c0, c0, #0 // write to Cache Size Selection Reg
700aea34: ee400f10     	mcr	p15, #0x2, r0, c0, c0, #0x0
;         mrc     p15, #1, r0, c0, c0, #0 // read Cache Size Id Reg
700aea38: ee300f10     	mrc	p15, #0x1, r0, c0, c0, #0x0
;         bx      lr
700aea3c: e12fff1e     	bx	lr

700aea40 <CacheP_configForceWrThru>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700aea40: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         cmp     r0, #0
700aea44: e3500000     	cmp	r0, #0
;         beq     FWT_disable
700aea48: 0a000001     	beq	0x700aea54 <FWT_disable> @ imm = #0x4
;         orr     r1, r1, #(1 << 9)       // set (enable) force write-thru bit
700aea4c: e3811c02     	orr	r1, r1, #512
;         b       FWT_exit
700aea50: ea000000     	b	0x700aea58 <FWT_exit>   @ imm = #0x0

700aea54 <FWT_disable>:
;         bic     r1, r1, #(1 << 9)       // clear (disable) force write-thru bit
700aea54: e3c11c02     	bic	r1, r1, #512

700aea58 <FWT_exit>:
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700aea58: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700aea5c: e12fff1e     	bx	lr

700aea60 <CacheP_setDLFO>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700aea60: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         orr     r1, r1, #(1 << 13)      // set DLFO to disable LF optimization
700aea64: e3811a02     	orr	r1, r1, #8192
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700aea68: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700aea6c: e12fff1e     	bx	lr

700aea70 <CacheP_init>:
; {
700aea70: b580         	push	{r7, lr}
700aea72: b084         	sub	sp, #0x10
700aea74: 2000         	movs	r0, #0x0
;     info = CacheP_getCacheLevelInfo(0);
700aea76: f7ff efde    	blx	0x700aea34 <CacheP_getCacheLevelInfo> @ imm = #-0x44
700aea7a: 9003         	str	r0, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1dCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700aea7c: 9803         	ldr	r0, [sp, #0xc]
700aea7e: f000 0007    	and	r0, r0, #0x7
700aea82: 1c81         	adds	r1, r0, #0x2
700aea84: 2004         	movs	r0, #0x4
700aea86: 9001         	str	r0, [sp, #0x4]
700aea88: 4088         	lsls	r0, r1
700aea8a: 3820         	subs	r0, #0x20
700aea8c: fab0 f080    	clz	r0, r0
700aea90: 0940         	lsrs	r0, r0, #0x5
700aea92: f000 faad    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x55a
700aea96: 2001         	movs	r0, #0x1
;     info = CacheP_getCacheLevelInfo(1);
700aea98: f7ff efcc    	blx	0x700aea34 <CacheP_getCacheLevelInfo> @ imm = #-0x68
700aea9c: 4601         	mov	r1, r0
700aea9e: 9801         	ldr	r0, [sp, #0x4]
700aeaa0: 9103         	str	r1, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1pCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700aeaa2: 9903         	ldr	r1, [sp, #0xc]
700aeaa4: f001 0107    	and	r1, r1, #0x7
700aeaa8: 3102         	adds	r1, #0x2
700aeaaa: 4088         	lsls	r0, r1
700aeaac: 3820         	subs	r0, #0x20
700aeaae: fab0 f080    	clz	r0, r0
700aeab2: 0940         	lsrs	r0, r0, #0x5
700aeab4: f000 fa9c    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x538
;     enabled = CacheP_getEnabled();
700aeab8: f7ff efa0    	blx	0x700ae9fc <CacheP_getEnabled> @ imm = #-0xc0
700aeabc: 9002         	str	r0, [sp, #0x8]
;     if (enabled!=0U) {
700aeabe: 9802         	ldr	r0, [sp, #0x8]
700aeac0: b120         	cbz	r0, 0x700aeacc <CacheP_init+0x5c> @ imm = #0x8
700aeac2: e7ff         	b	0x700aeac4 <CacheP_init+0x54> @ imm = #-0x2
700aeac4: 200f         	movs	r0, #0xf
;         CacheP_disable((uint32_t)CacheP_TYPE_ALL);
700aeac6: f000 f81b    	bl	0x700aeb00 <CacheP_disable> @ imm = #0x36
;     }
700aeaca: e7ff         	b	0x700aeacc <CacheP_init+0x5c> @ imm = #-0x2
;     if (gCacheConfig.enable!=0U) {
700aeacc: f24f 400c    	movw	r0, #0xf40c
700aead0: f2c7 000a    	movt	r0, #0x700a
700aead4: 6800         	ldr	r0, [r0]
700aead6: b158         	cbz	r0, 0x700aeaf0 <CacheP_init+0x80> @ imm = #0x16
700aead8: e7ff         	b	0x700aeada <CacheP_init+0x6a> @ imm = #-0x2
;          CacheP_configForceWrThru(gCacheConfig.enableForceWrThru);
700aeada: f24f 400c    	movw	r0, #0xf40c
700aeade: f2c7 000a    	movt	r0, #0x700a
700aeae2: 6840         	ldr	r0, [r0, #0x4]
700aeae4: f7ff efac    	blx	0x700aea40 <CacheP_configForceWrThru> @ imm = #-0xa8
700aeae8: 200f         	movs	r0, #0xf
;         CacheP_enable((uint32_t)CacheP_TYPE_ALL);
700aeaea: f000 f831    	bl	0x700aeb50 <CacheP_enable> @ imm = #0x62
;     }
700aeaee: e7ff         	b	0x700aeaf0 <CacheP_init+0x80> @ imm = #-0x2
; }
700aeaf0: b004         	add	sp, #0x10
700aeaf2: bd80         	pop	{r7, pc}
700aeaf4: bf00         	nop
700aeaf6: bf00         	nop
700aeaf8: bf00         	nop
700aeafa: bf00         	nop
700aeafc: bf00         	nop
700aeafe: bf00         	nop

700aeb00 <CacheP_disable>:
; {
700aeb00: b580         	push	{r7, lr}
700aeb02: b084         	sub	sp, #0x10
700aeb04: 9003         	str	r0, [sp, #0xc]
;     enabled = CacheP_getEnabled();
700aeb06: f7ff ef7a    	blx	0x700ae9fc <CacheP_getEnabled> @ imm = #-0x10c
700aeb0a: 9002         	str	r0, [sp, #0x8]
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700aeb0c: 9902         	ldr	r1, [sp, #0x8]
700aeb0e: 9803         	ldr	r0, [sp, #0xc]
700aeb10: 4008         	ands	r0, r1
700aeb12: 0780         	lsls	r0, r0, #0x1e
700aeb14: 2800         	cmp	r0, #0x0
700aeb16: d509         	bpl	0x700aeb2c <CacheP_disable+0x2c> @ imm = #0x12
700aeb18: e7ff         	b	0x700aeb1a <CacheP_disable+0x1a> @ imm = #-0x2
;         key = HwiP_disable();
700aeb1a: f7ff edaa    	blx	0x700ae670 <HwiP_disable> @ imm = #-0x4ac
700aeb1e: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1d();             /* Disable L1D Cache */
700aeb20: f7ff ee06    	blx	0x700ae730 <CacheP_disableL1d> @ imm = #-0x3f4
;         HwiP_restore(key);
700aeb24: 9801         	ldr	r0, [sp, #0x4]
700aeb26: f7ff edc4    	blx	0x700ae6b0 <HwiP_restore> @ imm = #-0x478
;     }
700aeb2a: e7ff         	b	0x700aeb2c <CacheP_disable+0x2c> @ imm = #-0x2
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700aeb2c: 9902         	ldr	r1, [sp, #0x8]
700aeb2e: 9803         	ldr	r0, [sp, #0xc]
700aeb30: 4008         	ands	r0, r1
700aeb32: 07c0         	lsls	r0, r0, #0x1f
700aeb34: b148         	cbz	r0, 0x700aeb4a <CacheP_disable+0x4a> @ imm = #0x12
700aeb36: e7ff         	b	0x700aeb38 <CacheP_disable+0x38> @ imm = #-0x2
;         key = HwiP_disable();
700aeb38: f7ff ed9a    	blx	0x700ae670 <HwiP_disable> @ imm = #-0x4cc
700aeb3c: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1p();             /* Disable L1P Cache */
700aeb3e: f7ff ee0c    	blx	0x700ae758 <CacheP_disableL1p> @ imm = #-0x3e8
;         HwiP_restore(key);
700aeb42: 9801         	ldr	r0, [sp, #0x4]
700aeb44: f7ff edb4    	blx	0x700ae6b0 <HwiP_restore> @ imm = #-0x498
;     }
700aeb48: e7ff         	b	0x700aeb4a <CacheP_disable+0x4a> @ imm = #-0x2
; }
700aeb4a: b004         	add	sp, #0x10
700aeb4c: bd80         	pop	{r7, pc}
700aeb4e: bf00         	nop

700aeb50 <CacheP_enable>:
; {
700aeb50: b580         	push	{r7, lr}
700aeb52: b082         	sub	sp, #0x8
700aeb54: 9001         	str	r0, [sp, #0x4]
;     disabled = ~(CacheP_getEnabled());
700aeb56: f7ff ef52    	blx	0x700ae9fc <CacheP_getEnabled> @ imm = #-0x15c
700aeb5a: 43c0         	mvns	r0, r0
700aeb5c: 9000         	str	r0, [sp]
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700aeb5e: 9900         	ldr	r1, [sp]
700aeb60: 9801         	ldr	r0, [sp, #0x4]
700aeb62: 4008         	ands	r0, r1
700aeb64: 0780         	lsls	r0, r0, #0x1e
700aeb66: 2800         	cmp	r0, #0x0
700aeb68: d503         	bpl	0x700aeb72 <CacheP_enable+0x22> @ imm = #0x6
700aeb6a: e7ff         	b	0x700aeb6c <CacheP_enable+0x1c> @ imm = #-0x2
;         CacheP_enableL1d();              /* Enable L1D Cache */
700aeb6c: f7ff ee00    	blx	0x700ae770 <CacheP_enableL1d> @ imm = #-0x400
;     }
700aeb70: e7ff         	b	0x700aeb72 <CacheP_enable+0x22> @ imm = #-0x2
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700aeb72: 9900         	ldr	r1, [sp]
700aeb74: 9801         	ldr	r0, [sp, #0x4]
700aeb76: 4008         	ands	r0, r1
700aeb78: 07c0         	lsls	r0, r0, #0x1f
700aeb7a: b118         	cbz	r0, 0x700aeb84 <CacheP_enable+0x34> @ imm = #0x6
700aeb7c: e7ff         	b	0x700aeb7e <CacheP_enable+0x2e> @ imm = #-0x2
;         CacheP_enableL1p();              /* Enable L1P Cache */
700aeb7e: f7ff ee04    	blx	0x700ae788 <CacheP_enableL1p> @ imm = #-0x3f8
;     }
700aeb82: e7ff         	b	0x700aeb84 <CacheP_enable+0x34> @ imm = #-0x2
; }
700aeb84: b002         	add	sp, #0x8
700aeb86: bd80         	pop	{r7, pc}
700aeb88: bf00         	nop
700aeb8a: bf00         	nop
700aeb8c: bf00         	nop
700aeb8e: bf00         	nop

700aeb90 <CacheP_inv>:
; {
700aeb90: b580         	push	{r7, lr}
700aeb92: b084         	sub	sp, #0x10
700aeb94: 9003         	str	r0, [sp, #0xc]
700aeb96: 9102         	str	r1, [sp, #0x8]
700aeb98: 9201         	str	r2, [sp, #0x4]
;     if (((type) & ((uint32_t)CacheP_TYPE_L1P))!=0U) {
700aeb9a: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700aeb9e: 07c0         	lsls	r0, r0, #0x1f
700aeba0: b128         	cbz	r0, 0x700aebae <CacheP_inv+0x1e> @ imm = #0xa
700aeba2: e7ff         	b	0x700aeba4 <CacheP_inv+0x14> @ imm = #-0x2
;         CacheP_invL1p((uint32_t)blockPtr, byteCnt);
700aeba4: 9803         	ldr	r0, [sp, #0xc]
700aeba6: 9902         	ldr	r1, [sp, #0x8]
700aeba8: f7ff ee16    	blx	0x700ae7d8 <CacheP_invL1p> @ imm = #-0x3d4
;     }
700aebac: e7ff         	b	0x700aebae <CacheP_inv+0x1e> @ imm = #-0x2
;     if (((type) & ((uint32_t)CacheP_TYPE_L1D))!=0U) {
700aebae: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700aebb2: 0780         	lsls	r0, r0, #0x1e
700aebb4: 2800         	cmp	r0, #0x0
700aebb6: d505         	bpl	0x700aebc4 <CacheP_inv+0x34> @ imm = #0xa
700aebb8: e7ff         	b	0x700aebba <CacheP_inv+0x2a> @ imm = #-0x2
;         CacheP_invL1d((uint32_t)blockPtr, byteCnt);
700aebba: 9803         	ldr	r0, [sp, #0xc]
700aebbc: 9902         	ldr	r1, [sp, #0x8]
700aebbe: f7ff edf0    	blx	0x700ae7a0 <CacheP_invL1d> @ imm = #-0x420
;     }
700aebc2: e7ff         	b	0x700aebc4 <CacheP_inv+0x34> @ imm = #-0x2
; }
700aebc4: b004         	add	sp, #0x10
700aebc6: bd80         	pop	{r7, pc}
		...

Disassembly of section .text.mpu:

700aebd0 <MpuP_RegionAttrs_init>:
; {
700aebd0: b081         	sub	sp, #0x4
700aebd2: 9000         	str	r0, [sp]
;     region->isExecuteNever = 0;
700aebd4: 9900         	ldr	r1, [sp]
700aebd6: 2000         	movs	r0, #0x0
700aebd8: 7108         	strb	r0, [r1, #0x4]
;     region->accessPerm     = (uint8_t)MpuP_AP_S_RW_U_R;
700aebda: 9a00         	ldr	r2, [sp]
700aebdc: 2102         	movs	r1, #0x2
700aebde: 7191         	strb	r1, [r2, #0x6]
;     region->tex            = 0;
700aebe0: 9900         	ldr	r1, [sp]
700aebe2: 7148         	strb	r0, [r1, #0x5]
;     region->isSharable     = 1;
700aebe4: 9a00         	ldr	r2, [sp]
700aebe6: 2101         	movs	r1, #0x1
700aebe8: 70d1         	strb	r1, [r2, #0x3]
;     region->isCacheable    = 0;
700aebea: 9900         	ldr	r1, [sp]
700aebec: 7048         	strb	r0, [r1, #0x1]
;     region->isBufferable   = 0;
700aebee: 9900         	ldr	r1, [sp]
700aebf0: 7088         	strb	r0, [r1, #0x2]
;     region->isEnable       = 0;
700aebf2: 9900         	ldr	r1, [sp]
700aebf4: 7008         	strb	r0, [r1]
;     region->subregionDisableMask = 0;
700aebf6: 9900         	ldr	r1, [sp]
700aebf8: 71c8         	strb	r0, [r1, #0x7]
; }
700aebfa: b001         	add	sp, #0x4
700aebfc: 4770         	bx	lr
700aebfe: bf00         	nop

700aec00 <MpuP_setRegion>:
; {
700aec00: b580         	push	{r7, lr}
700aec02: b08a         	sub	sp, #0x28
700aec04: 9009         	str	r0, [sp, #0x24]
700aec06: 9108         	str	r1, [sp, #0x20]
700aec08: 9207         	str	r2, [sp, #0x1c]
700aec0a: 9306         	str	r3, [sp, #0x18]
;     uint32_t value = size;
700aec0c: 9807         	ldr	r0, [sp, #0x1c]
700aec0e: 9000         	str	r0, [sp]
;     DebugP_assertNoLog( regionNum < MpuP_MAX_REGIONS);
700aec10: 9909         	ldr	r1, [sp, #0x24]
700aec12: 2000         	movs	r0, #0x0
700aec14: 2910         	cmp	r1, #0x10
700aec16: bf38         	it	lo
700aec18: 2001         	movlo	r0, #0x1
700aec1a: f000 f9e9    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x3d2
;     value = (value & (uint32_t)0x1F);
700aec1e: 9800         	ldr	r0, [sp]
700aec20: f000 001f    	and	r0, r0, #0x1f
700aec24: 9000         	str	r0, [sp]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700aec26: 9806         	ldr	r0, [sp, #0x18]
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700aec28: 7801         	ldrb	r1, [r0]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700aec2a: 79c0         	ldrb	r0, [r0, #0x7]
700aec2c: 0200         	lsls	r0, r0, #0x8
;                   | ((uint32_t)(value            & (uint32_t)0x1F) << (uint32_t)1)
700aec2e: 9a00         	ldr	r2, [sp]
700aec30: f002 021f    	and	r2, r2, #0x1f
700aec34: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700aec38: f001 0101    	and	r1, r1, #0x1
700aec3c: 4408         	add	r0, r1
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700aec3e: 9004         	str	r0, [sp, #0x10]
;     baseAddress = ((uint32_t)addr & ~( (1U <<((uint64_t)value+1U))-1U ));
700aec40: 9808         	ldr	r0, [sp, #0x20]
700aec42: 9900         	ldr	r1, [sp]
700aec44: 1c4a         	adds	r2, r1, #0x1
700aec46: 2101         	movs	r1, #0x1
700aec48: 4091         	lsls	r1, r2
700aec4a: 4249         	rsbs	r1, r1, #0
700aec4c: 4008         	ands	r0, r1
700aec4e: 9005         	str	r0, [sp, #0x14]
;     regionAttrs = MpuP_getAttrs(attrs);
700aec50: 9806         	ldr	r0, [sp, #0x18]
700aec52: f000 f81d    	bl	0x700aec90 <MpuP_getAttrs> @ imm = #0x3a
700aec56: 9003         	str	r0, [sp, #0xc]
;     enabled = MpuP_isEnable();
700aec58: f000 f84a    	bl	0x700aecf0 <MpuP_isEnable> @ imm = #0x94
700aec5c: 9002         	str	r0, [sp, #0x8]
;     MpuP_disable();
700aec5e: f000 f84f    	bl	0x700aed00 <MpuP_disable> @ imm = #0x9e
;     key = HwiP_disable();
700aec62: f7ff ed06    	blx	0x700ae670 <HwiP_disable> @ imm = #-0x5f4
700aec66: 9001         	str	r0, [sp, #0x4]
;     MpuP_setRegionAsm(regionNum, baseAddress, sizeAndEnable, regionAttrs);
700aec68: 9809         	ldr	r0, [sp, #0x24]
700aec6a: 9905         	ldr	r1, [sp, #0x14]
700aec6c: 9a04         	ldr	r2, [sp, #0x10]
700aec6e: 9b03         	ldr	r3, [sp, #0xc]
700aec70: f000 e90c    	blx	0x700aee8c <MpuP_setRegionAsm> @ imm = #0x218
;     HwiP_restore(key);
700aec74: 9801         	ldr	r0, [sp, #0x4]
700aec76: f7ff ed1c    	blx	0x700ae6b0 <HwiP_restore> @ imm = #-0x5c8
;     if (enabled != 0U) {
700aec7a: 9802         	ldr	r0, [sp, #0x8]
700aec7c: b118         	cbz	r0, 0x700aec86 <MpuP_setRegion+0x86> @ imm = #0x6
700aec7e: e7ff         	b	0x700aec80 <MpuP_setRegion+0x80> @ imm = #-0x2
;         MpuP_enable();
700aec80: f000 f85e    	bl	0x700aed40 <MpuP_enable> @ imm = #0xbc
;     }
700aec84: e7ff         	b	0x700aec86 <MpuP_setRegion+0x86> @ imm = #-0x2
; }
700aec86: b00a         	add	sp, #0x28
700aec88: bd80         	pop	{r7, pc}
700aec8a: bf00         	nop
700aec8c: bf00         	nop
700aec8e: bf00         	nop

700aec90 <MpuP_getAttrs>:
; {
700aec90: b580         	push	{r7, lr}
700aec92: b082         	sub	sp, #0x8
700aec94: 9001         	str	r0, [sp, #0x4]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700aec96: f8dd c004    	ldr.w	r12, [sp, #0x4]
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700aec9a: f89c 2001    	ldrb.w	r2, [r12, #0x1]
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700aec9e: f89c 1002    	ldrb.w	r1, [r12, #0x2]
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700aeca2: f89c 3003    	ldrb.w	r3, [r12, #0x3]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700aeca6: f89c 0004    	ldrb.w	r0, [r12, #0x4]
700aecaa: f000 0001    	and	r0, r0, #0x1
700aecae: 0300         	lsls	r0, r0, #0xc
;         | ((uint32_t)(region->accessPerm     & (uint32_t)0x7) << (uint32_t)8)
700aecb0: f89c e006    	ldrb.w	lr, [r12, #0x6]
700aecb4: f00e 0e07    	and	lr, lr, #0x7
700aecb8: ea40 200e    	orr.w	r0, r0, lr, lsl #8
;         | ((uint32_t)(region->tex            & (uint32_t)0x7) << (uint32_t)3)
700aecbc: f89c c005    	ldrb.w	r12, [r12, #0x5]
700aecc0: f00c 0c07    	and	r12, r12, #0x7
700aecc4: ea40 00cc    	orr.w	r0, r0, r12, lsl #3
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700aecc8: f003 0301    	and	r3, r3, #0x1
700aeccc: ea40 0083    	orr.w	r0, r0, r3, lsl #2
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700aecd0: f002 0201    	and	r2, r2, #0x1
700aecd4: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700aecd8: f001 0101    	and	r1, r1, #0x1
700aecdc: 4408         	add	r0, r1
;     uint32_t regionAttrs =
700aecde: 9000         	str	r0, [sp]
;     return regionAttrs;
700aece0: 9800         	ldr	r0, [sp]
700aece2: b002         	add	sp, #0x8
700aece4: bd80         	pop	{r7, pc}
700aece6: bf00         	nop
700aece8: bf00         	nop
700aecea: bf00         	nop
700aecec: bf00         	nop
700aecee: bf00         	nop

700aecf0 <MpuP_isEnable>:
; {
700aecf0: b580         	push	{r7, lr}
;     return MpuP_isEnableAsm();
700aecf2: f000 e8c2    	blx	0x700aee78 <MpuP_isEnableAsm> @ imm = #0x184
700aecf6: bd80         	pop	{r7, pc}
700aecf8: bf00         	nop
700aecfa: bf00         	nop
700aecfc: bf00         	nop
700aecfe: bf00         	nop

700aed00 <MpuP_disable>:
; {
700aed00: b580         	push	{r7, lr}
700aed02: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()!=0U)
700aed04: f7ff fff4    	bl	0x700aecf0 <MpuP_isEnable> @ imm = #-0x18
700aed08: b1a0         	cbz	r0, 0x700aed34 <MpuP_disable+0x34> @ imm = #0x28
700aed0a: e7ff         	b	0x700aed0c <MpuP_disable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700aed0c: f7ff ecb0    	blx	0x700ae670 <HwiP_disable> @ imm = #-0x6a0
700aed10: 9000         	str	r0, [sp]
;         type = CacheP_getEnabled();
700aed12: f7ff ee74    	blx	0x700ae9fc <CacheP_getEnabled> @ imm = #-0x318
700aed16: 9001         	str	r0, [sp, #0x4]
;         CacheP_disable(type);
700aed18: 9801         	ldr	r0, [sp, #0x4]
700aed1a: f7ff fef1    	bl	0x700aeb00 <CacheP_disable> @ imm = #-0x21e
;         __asm__ __volatile__ (" dsb" "\n\t": : : "memory");
700aed1e: f3bf 8f4f    	dsb	sy
;         MpuP_disableAsm();
700aed22: f000 e882    	blx	0x700aee28 <MpuP_disableAsm> @ imm = #0x104
;         CacheP_enable(type);
700aed26: 9801         	ldr	r0, [sp, #0x4]
700aed28: f7ff ff12    	bl	0x700aeb50 <CacheP_enable> @ imm = #-0x1dc
;         HwiP_restore(key);
700aed2c: 9800         	ldr	r0, [sp]
700aed2e: f7ff ecc0    	blx	0x700ae6b0 <HwiP_restore> @ imm = #-0x680
;     }
700aed32: e7ff         	b	0x700aed34 <MpuP_disable+0x34> @ imm = #-0x2
; }
700aed34: b002         	add	sp, #0x8
700aed36: bd80         	pop	{r7, pc}
700aed38: bf00         	nop
700aed3a: bf00         	nop
700aed3c: bf00         	nop
700aed3e: bf00         	nop

700aed40 <MpuP_enable>:
; {
700aed40: b580         	push	{r7, lr}
700aed42: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()==(uint32_t) 0U)
700aed44: f7ff ffd4    	bl	0x700aecf0 <MpuP_isEnable> @ imm = #-0x58
700aed48: b9e0         	cbnz	r0, 0x700aed84 <MpuP_enable+0x44> @ imm = #0x38
700aed4a: e7ff         	b	0x700aed4c <MpuP_enable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700aed4c: f7ff ec90    	blx	0x700ae670 <HwiP_disable> @ imm = #-0x6e0
700aed50: 9000         	str	r0, [sp]
;         type = (uint32_t)CacheP_getEnabled();
700aed52: f7ff ee54    	blx	0x700ae9fc <CacheP_getEnabled> @ imm = #-0x358
700aed56: 9001         	str	r0, [sp, #0x4]
;         if (type & CacheP_TYPE_L1) {
700aed58: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700aed5c: 0780         	lsls	r0, r0, #0x1e
700aed5e: b120         	cbz	r0, 0x700aed6a <MpuP_enable+0x2a> @ imm = #0x8
700aed60: e7ff         	b	0x700aed62 <MpuP_enable+0x22> @ imm = #-0x2
700aed62: 2003         	movs	r0, #0x3
;             CacheP_disable(CacheP_TYPE_L1);
700aed64: f7ff fecc    	bl	0x700aeb00 <CacheP_disable> @ imm = #-0x268
;         }
700aed68: e7ff         	b	0x700aed6a <MpuP_enable+0x2a> @ imm = #-0x2
;         MpuP_enableAsm();
700aed6a: f000 e872    	blx	0x700aee50 <MpuP_enableAsm> @ imm = #0xe4
;         CacheP_enable(type);
700aed6e: 9801         	ldr	r0, [sp, #0x4]
700aed70: f7ff feee    	bl	0x700aeb50 <CacheP_enable> @ imm = #-0x224
;         __asm__  __volatile__ (" dsb" "\n\t": : : "memory");
700aed74: f3bf 8f4f    	dsb	sy
;         __asm__  __volatile__ (" isb" "\n\t": : : "memory");
700aed78: f3bf 8f6f    	isb	sy
;         HwiP_restore(key);
700aed7c: 9800         	ldr	r0, [sp]
700aed7e: f7ff ec98    	blx	0x700ae6b0 <HwiP_restore> @ imm = #-0x6d0
;     }
700aed82: e7ff         	b	0x700aed84 <MpuP_enable+0x44> @ imm = #-0x2
; }
700aed84: b002         	add	sp, #0x8
700aed86: bd80         	pop	{r7, pc}
700aed88: bf00         	nop
700aed8a: bf00         	nop
700aed8c: bf00         	nop
700aed8e: bf00         	nop

700aed90 <MpuP_init>:
; {
700aed90: b580         	push	{r7, lr}
700aed92: b082         	sub	sp, #0x8
;     if (MpuP_isEnable()!=0U) {
700aed94: f7ff ffac    	bl	0x700aecf0 <MpuP_isEnable> @ imm = #-0xa8
700aed98: b118         	cbz	r0, 0x700aeda2 <MpuP_init+0x12> @ imm = #0x6
700aed9a: e7ff         	b	0x700aed9c <MpuP_init+0xc> @ imm = #-0x2
;         MpuP_disable();
700aed9c: f7ff ffb0    	bl	0x700aed00 <MpuP_disable> @ imm = #-0xa0
;     }
700aeda0: e7ff         	b	0x700aeda2 <MpuP_init+0x12> @ imm = #-0x2
;     MpuP_disableBRAsm();
700aeda2: f000 e84e    	blx	0x700aee40 <MpuP_disableBRAsm> @ imm = #0x9c
;     DebugP_assertNoLog( gMpuConfig.numRegions < MpuP_MAX_REGIONS);
700aeda6: f24f 4014    	movw	r0, #0xf414
700aedaa: f2c7 000a    	movt	r0, #0x700a
700aedae: 6801         	ldr	r1, [r0]
700aedb0: 2000         	movs	r0, #0x0
700aedb2: 9000         	str	r0, [sp]
700aedb4: 2910         	cmp	r1, #0x10
700aedb6: bf38         	it	lo
700aedb8: 2001         	movlo	r0, #0x1
700aedba: f000 f919    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x232
700aedbe: 9800         	ldr	r0, [sp]
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700aedc0: 9001         	str	r0, [sp, #0x4]
700aedc2: e7ff         	b	0x700aedc4 <MpuP_init+0x34> @ imm = #-0x2
700aedc4: 9801         	ldr	r0, [sp, #0x4]
700aedc6: f24f 4114    	movw	r1, #0xf414
700aedca: f2c7 010a    	movt	r1, #0x700a
700aedce: 6809         	ldr	r1, [r1]
700aedd0: 4288         	cmp	r0, r1
700aedd2: d212         	bhs	0x700aedfa <MpuP_init+0x6a> @ imm = #0x24
700aedd4: e7ff         	b	0x700aedd6 <MpuP_init+0x46> @ imm = #-0x2
;         MpuP_setRegion(i,
700aedd6: 9801         	ldr	r0, [sp, #0x4]
;                 (void*)gMpuRegionConfig[i].baseAddr,
700aedd8: f24f 4120    	movw	r1, #0xf420
700aeddc: f2c7 010a    	movt	r1, #0x700a
700aede0: eb01 1300    	add.w	r3, r1, r0, lsl #4
700aede4: 0102         	lsls	r2, r0, #0x4
700aede6: 5889         	ldr	r1, [r1, r2]
;                 gMpuRegionConfig[i].size,
700aede8: 685a         	ldr	r2, [r3, #0x4]
;                 &gMpuRegionConfig[i].attrs
700aedea: 3308         	adds	r3, #0x8
;         MpuP_setRegion(i,
700aedec: f7ff ff08    	bl	0x700aec00 <MpuP_setRegion> @ imm = #-0x1f0
;     }
700aedf0: e7ff         	b	0x700aedf2 <MpuP_init+0x62> @ imm = #-0x2
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700aedf2: 9801         	ldr	r0, [sp, #0x4]
700aedf4: 3001         	adds	r0, #0x1
700aedf6: 9001         	str	r0, [sp, #0x4]
700aedf8: e7e4         	b	0x700aedc4 <MpuP_init+0x34> @ imm = #-0x38
;     if (gMpuConfig.enableBackgroundRegion!=0U) {
700aedfa: f24f 4014    	movw	r0, #0xf414
700aedfe: f2c7 000a    	movt	r0, #0x700a
700aee02: 6840         	ldr	r0, [r0, #0x4]
700aee04: b118         	cbz	r0, 0x700aee0e <MpuP_init+0x7e> @ imm = #0x6
700aee06: e7ff         	b	0x700aee08 <MpuP_init+0x78> @ imm = #-0x2
;         MpuP_enableBRAsm();
700aee08: f000 e82e    	blx	0x700aee68 <MpuP_enableBRAsm> @ imm = #0x5c
;     }
700aee0c: e7ff         	b	0x700aee0e <MpuP_init+0x7e> @ imm = #-0x2
;     if (gMpuConfig.enableMpu!=0U) {
700aee0e: f24f 4014    	movw	r0, #0xf414
700aee12: f2c7 000a    	movt	r0, #0x700a
700aee16: 6880         	ldr	r0, [r0, #0x8]
700aee18: b118         	cbz	r0, 0x700aee22 <MpuP_init+0x92> @ imm = #0x6
700aee1a: e7ff         	b	0x700aee1c <MpuP_init+0x8c> @ imm = #-0x2
;         MpuP_enable();
700aee1c: f7ff ff90    	bl	0x700aed40 <MpuP_enable> @ imm = #-0xe0
;     }
700aee20: e7ff         	b	0x700aee22 <MpuP_init+0x92> @ imm = #-0x2
; }
700aee22: b002         	add	sp, #0x8
700aee24: bd80         	pop	{r7, pc}
700aee26: 0000         	movs	r0, r0

700aee28 <MpuP_disableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700aee28: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1             // clear bit 0 in r0
700aee2c: e3c00001     	bic	r0, r0, #1
;         dsb
700aee30: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU disabled (bit 0 = 0)
700aee34: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700aee38: f57ff06f     	isb	sy
;         bx      LR
700aee3c: e12fff1e     	bx	lr

700aee40 <MpuP_disableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700aee40: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x20000         // clear bit 17 in r0
700aee44: e3c00802     	bic	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // disable background region
700aee48: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700aee4c: e12fff1e     	bx	lr

700aee50 <MpuP_enableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700aee50: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1             // set bit 0 in r0
700aee54: e3800001     	orr	r0, r0, #1
;         dsb
700aee58: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU enabled (bit 0 = 1)
700aee5c: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700aee60: f57ff06f     	isb	sy
;         bx      LR
700aee64: e12fff1e     	bx	lr

700aee68 <MpuP_enableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700aee68: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x20000         // set bit 17 in r0
700aee6c: e3800802     	orr	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // background region enabled
700aee70: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700aee74: e12fff1e     	bx	lr

700aee78 <MpuP_isEnableAsm>:
;         mov     r0, #0
700aee78: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0  // read SCTLR register to r1
700aee7c: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1                 // test bit 0
700aee80: e3110001     	tst	r1, #1
;         movne   r0, #1                   // if not 0, MPU is enabled
700aee84: 13a00001     	movne	r0, #1
;         bx      LR
700aee88: e12fff1e     	bx	lr

700aee8c <MpuP_setRegionAsm>:
;         mcr     p15, #0, r0, c6, c2, #0  // select MPU region
700aee8c: ee060f12     	mcr	p15, #0x0, r0, c6, c2, #0x0
;         mcr     p15, #0, r1, c6, c1, #0  // set region base address
700aee90: ee061f11     	mcr	p15, #0x0, r1, c6, c1, #0x0
;         mcr     p15, #0, r2, c6, c1, #2  // set region size and enable it
700aee94: ee062f51     	mcr	p15, #0x0, r2, c6, c1, #0x2
;         mcr     p15, #0, r3, c6, c1, #4  // set protection attributes
700aee98: ee063f91     	mcr	p15, #0x0, r3, c6, c1, #0x4
;         bx      LR
700aee9c: e12fff1e     	bx	lr

Disassembly of section .text.boot:

700aeea0 <_c_int00_sbl>:
;         MRC     p15, #0, r1, c0, c0, #5
700aeea0: ee101fb0     	mrc	p15, #0x0, r1, c0, c0, #0x5
;         BFC     r1, #8, #24
700aeea4: e7df141f     	bfc	r1, #8, #24
;         CMP     r1, #0
700aeea8: e3510000     	cmp	r1, #0
;         BNE     _sblLoopForever
700aeeac: 1a000001     	bne	0x700aeeb8 <_sblLoopForever> @ imm = #0x4
;         LDR     r1, _c_int00_addr
700aeeb0: e59f1008     	ldr	r1, [pc, #0x8]          @ 0x700aeec0 <_c_int00_addr>
;         BLX     r1
700aeeb4: e12fff31     	blx	r1

700aeeb8 <_sblLoopForever>:
;         WFI
700aeeb8: e320f003     	wfi
;         B       _sblLoopForever
700aeebc: eafffffd     	b	0x700aeeb8 <_sblLoopForever> @ imm = #-0xc

700aeec0 <_c_int00_addr>:
700aeec0: c4 ee 0a 70  	.word	0x700aeec4

700aeec4 <_c_int00>:
;         mrs     r0, cpsr
700aeec4: e10f0000     	mrs	r0, apsr
;         orr     r0, r0, #0xC0
700aeec8: e38000c0     	orr	r0, r0, #192
;         msr     cpsr_cf, r0
700aeecc: e129f000     	msr	CPSR_fc, r0
;         MRC      p15,#0x0,r0,c1,c0,#2
700aeed0: ee110f50     	mrc	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r3,#0xf00000
700aeed4: e3a0360f     	mov	r3, #15728640
;         ORR      r0,r0,r3
700aeed8: e1800003     	orr	r0, r0, r3
;         MCR      p15,#0x0,r0,c1,c0,#2
700aeedc: ee010f50     	mcr	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r0,#0x40000000
700aeee0: e3a00101     	mov	r0, #1073741824
;         FMXR     FPEXC,r0
700aeee4: eee80a10     	vmsr	fpexc, r0
;         MRS     r0, cpsr
700aeee8: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aeeec: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x11  // SET FIQ MODE
700aeef0: e3800011     	orr	r0, r0, #17
;         MSR     cpsr_cf, r0
700aeef4: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_FIQ_STACK_END
700aeef8: e59fd0d4     	ldr	sp, [pc, #0xd4]         @ 0x700aefd4 <c_FIQ_STACK_END>
;         MRS     r0, cpsr
700aeefc: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aef00: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x12  // SET IRQ MODE
700aef04: e3800012     	orr	r0, r0, #18
;         MSR     cpsr_cf, r0
700aef08: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_IRQ_STACK_END
700aef0c: e59fd0bc     	ldr	sp, [pc, #0xbc]         @ 0x700aefd0 <c_IRQ_STACK_END>
;         MRS     r0, cpsr
700aef10: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aef14: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x13  // SET SVC MODE
700aef18: e3800013     	orr	r0, r0, #19
;         MSR     cpsr_cf, r0
700aef1c: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_SVC_STACK_END
700aef20: e59fd0b0     	ldr	sp, [pc, #0xb0]         @ 0x700aefd8 <c_SVC_STACK_END>
;         MRS     r0, cpsr
700aef24: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aef28: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x17  // SET ABORT MODE
700aef2c: e3800017     	orr	r0, r0, #23
;         MSR     cpsr_cf, r0
700aef30: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_ABORT_STACK_END
700aef34: e59fd0a0     	ldr	sp, [pc, #0xa0]         @ 0x700aefdc <c_ABORT_STACK_END>
;         MRS     r0, cpsr
700aef38: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aef3c: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1B  // SET ABORT MODE
700aef40: e380001b     	orr	r0, r0, #27
;         MSR     cpsr_cf, r0
700aef44: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_UNDEFINED_STACK_END
700aef48: e59fd090     	ldr	sp, [pc, #0x90]         @ 0x700aefe0 <c_UNDEFINED_STACK_END>
;         MRS     r0, cpsr
700aef4c: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aef50: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1F  // SET SYSTEM MODE
700aef54: e380001f     	orr	r0, r0, #31
;         MSR     cpsr_cf, r0
700aef58: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_STACK_END
700aef5c: e59fd068     	ldr	sp, [pc, #0x68]         @ 0x700aefcc <c_STACK_END>
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700aef60: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC r0, r0, #0x1 << 2      // Disable data cache bit
700aef64: e3c00004     	bic	r0, r0, #4
;         BIC r0, r0, #0x1 << 12     // Disable instruction cache bit
700aef68: e3c00a01     	bic	r0, r0, #4096
;         DSB
700aef6c: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700aef70: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB                        // Ensures following instructions are not executed from cache
700aef74: f57ff06f     	isb	sy
;         MRC p15, 0, r1, c1, c0, 1  // Read Auxiliary Control Register
700aef78: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         ORR r1, r1, #(0x1 << 3)    //Enable ECC for Cache
700aef7c: e3811008     	orr	r1, r1, #8
;         ORR r1,r1,#(0x1 << 5)
700aef80: e3811020     	orr	r1, r1, #32
;         MCR p15, 0, r1, c1, c0, 1  // Write Auxiliary Control Register
700aef84: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         MCR p15, 0, r0, c15, c5, 0 // Invalidate entire data cache
700aef88: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         MCR p15, 0, r0, c7, c5, 0  // Invalidate entire instruction cache
700aef8c: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700aef90: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR r0, r0, #0x1 << 2      // Enable data cache bit
700aef94: e3800004     	orr	r0, r0, #4
;         ORR r0, r0, #0x1 << 12     // Enable instruction cache bit
700aef98: e3800a01     	orr	r0, r0, #4096
;         DSB
700aef9c: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700aefa0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB
700aefa4: f57ff06f     	isb	sy
;         BL      __mpu_init
700aefa8: fa000028     	blx	0x700af050 <__mpu_init> @ imm = #0xa0
;         BL      _system_pre_init
700aefac: fa00001b     	blx	0x700af020 <_system_pre_init> @ imm = #0x6c
;         CMP     R0, #0
700aefb0: e3500000     	cmp	r0, #0
;         BEQ     bypass_auto_init
700aefb4: 0a000000     	beq	0x700aefbc <bypass_auto_init> @ imm = #0x0
;         BL      __TI_auto_init
700aefb8: ebffef91     	bl	0x700aae04 <__TI_auto_init_nobinit_nopinit> @ imm = #-0x41bc

700aefbc <bypass_auto_init>:
;         BL      main
700aefbc: fafffabb     	blx	0x700adab0 <main>       @ imm = #-0x1514
;         MOV     R0, #1
700aefc0: e3a00001     	mov	r0, #1
;         BL      exit
700aefc4: eb000025     	bl	0x700af060 <abort>      @ imm = #0x94

700aefc8 <L1>:
; L1:     B       L1
700aefc8: eafffffe     	b	0x700aefc8 <L1>         @ imm = #-0x8

700aefcc <c_STACK_END>:
700aefcc: 00 90 09 70  	.word	0x70099000

700aefd0 <c_IRQ_STACK_END>:
700aefd0: 38 06 0b 70  	.word	0x700b0638

700aefd4 <c_FIQ_STACK_END>:
700aefd4: 38 07 0b 70  	.word	0x700b0738

700aefd8 <c_SVC_STACK_END>:
700aefd8: 38 17 0b 70  	.word	0x700b1738

700aefdc <c_ABORT_STACK_END>:
700aefdc: 38 18 0b 70  	.word	0x700b1838

700aefe0 <c_UNDEFINED_STACK_END>:
700aefe0: 38 19 0b 70  	.word	0x700b1938
700aefe4: 00 00 00 00  	.word	0x00000000
700aefe8: 00 00 00 00  	.word	0x00000000
700aefec: 00 00 00 00  	.word	0x00000000

700aeff0 <_DebugP_assertNoLog>:
; {
700aeff0: b580         	push	{r7, lr}
700aeff2: b082         	sub	sp, #0x8
700aeff4: 9001         	str	r0, [sp, #0x4]
;     if(expression==0)
700aeff6: 9801         	ldr	r0, [sp, #0x4]
700aeff8: b950         	cbnz	r0, 0x700af010 <_DebugP_assertNoLog+0x20> @ imm = #0x14
700aeffa: e7ff         	b	0x700aeffc <_DebugP_assertNoLog+0xc> @ imm = #-0x2
700aeffc: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700aeffe: 9000         	str	r0, [sp]
;         (void) HwiP_disable();
700af000: f7ff eb36    	blx	0x700ae670 <HwiP_disable> @ imm = #-0x994
;         while(assert_loop!= 0U)
700af004: e7ff         	b	0x700af006 <_DebugP_assertNoLog+0x16> @ imm = #-0x2
700af006: 9800         	ldr	r0, [sp]
700af008: b108         	cbz	r0, 0x700af00e <_DebugP_assertNoLog+0x1e> @ imm = #0x2
700af00a: e7ff         	b	0x700af00c <_DebugP_assertNoLog+0x1c> @ imm = #-0x2
700af00c: e7fb         	b	0x700af006 <_DebugP_assertNoLog+0x16> @ imm = #-0xa
;     }
700af00e: e7ff         	b	0x700af010 <_DebugP_assertNoLog+0x20> @ imm = #-0x2
; }
700af010: b002         	add	sp, #0x8
700af012: bd80         	pop	{r7, pc}
		...

700af020 <_system_pre_init>:
; {
700af020: b580         	push	{r7, lr}
700af022: b082         	sub	sp, #0x8
;     uint32_t bss_size = ((uintptr_t)&__BSS_END - (uintptr_t)&__BSS_START);
700af024: f240 0000    	movw	r0, #0x0
700af028: f2c7 0008    	movt	r0, #0x7008
700af02c: f245 0100    	movw	r1, #0x5000
700af030: f2c7 0108    	movt	r1, #0x7008
700af034: 1a09         	subs	r1, r1, r0
700af036: 9101         	str	r1, [sp, #0x4]
;     (void) memset((void*)&__BSS_START, 0x00, bss_size);
700af038: 9901         	ldr	r1, [sp, #0x4]
700af03a: f7ea ecfc    	blx	0x70099a34 <__aeabi_memclr8> @ imm = #-0x15608
700af03e: 2001         	movs	r0, #0x1
;     return 1;
700af040: b002         	add	sp, #0x8
700af042: bd80         	pop	{r7, pc}
		...

700af050 <__mpu_init>:
; {
700af050: b580         	push	{r7, lr}
;     MpuP_init();
700af052: f7ff fe9d    	bl	0x700aed90 <MpuP_init>  @ imm = #-0x2c6
;     CacheP_init();
700af056: e8bd 4080    	pop.w	{r7, lr}
700af05a: f7ff bd09    	b.w	0x700aea70 <CacheP_init> @ imm = #-0x5ee
700af05e: 0000         	movs	r0, r0

Disassembly of section .text:abort:

700af060 <abort>:
700af060: e320f000     	nop
700af064: eafffffe     	b	0x700af064 <abort+0x4>  @ imm = #-0x8

Disassembly of section .text:

70099000 <_vsnprintf>:
; {
70099000: e92d 43f0    	push.w	{r4, r5, r6, r7, r8, r9, lr}
70099004: b0c1         	sub	sp, #0x104
70099006: f8dd c120    	ldr.w	r12, [sp, #0x120]
7009900a: f8cd c100    	str.w	r12, [sp, #0x100]
7009900e: 903f         	str	r0, [sp, #0xfc]
70099010: 913e         	str	r1, [sp, #0xf8]
70099012: 923d         	str	r2, [sp, #0xf4]
70099014: 933c         	str	r3, [sp, #0xf0]
70099016: 2000         	movs	r0, #0x0
;   size_t idx = 0U;
70099018: 9037         	str	r0, [sp, #0xdc]
;   if (!buffer) {
7009901a: 983e         	ldr	r0, [sp, #0xf8]
7009901c: b930         	cbnz	r0, 0x7009902c <_vsnprintf+0x2c> @ imm = #0xc
7009901e: e7ff         	b	0x70099020 <_vsnprintf+0x20> @ imm = #-0x2
;     out = _out_null;
70099020: f64d 1001    	movw	r0, #0xd901
70099024: f2c7 000a    	movt	r0, #0x700a
70099028: 903f         	str	r0, [sp, #0xfc]
;   }
7009902a: e7ff         	b	0x7009902c <_vsnprintf+0x2c> @ imm = #-0x2
;   while (*format)
7009902c: e7ff         	b	0x7009902e <_vsnprintf+0x2e> @ imm = #-0x2
7009902e: 983c         	ldr	r0, [sp, #0xf0]
70099030: 7800         	ldrb	r0, [r0]
70099032: 2800         	cmp	r0, #0x0
70099034: f000 84e3    	beq.w	0x700999fe <_vsnprintf+0x9fe> @ imm = #0x9c6
70099038: e7ff         	b	0x7009903a <_vsnprintf+0x3a> @ imm = #-0x2
;     if (*format != '%') {
7009903a: 983c         	ldr	r0, [sp, #0xf0]
7009903c: 7800         	ldrb	r0, [r0]
7009903e: 2825         	cmp	r0, #0x25
70099040: d00e         	beq	0x70099060 <_vsnprintf+0x60> @ imm = #0x1c
70099042: e7ff         	b	0x70099044 <_vsnprintf+0x44> @ imm = #-0x2
;       out(*format, buffer, idx++, maxlen);
70099044: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099048: 983c         	ldr	r0, [sp, #0xf0]
7009904a: 7800         	ldrb	r0, [r0]
7009904c: 993e         	ldr	r1, [sp, #0xf8]
7009904e: 9a37         	ldr	r2, [sp, #0xdc]
70099050: 1c53         	adds	r3, r2, #0x1
70099052: 9337         	str	r3, [sp, #0xdc]
70099054: 9b3d         	ldr	r3, [sp, #0xf4]
70099056: 47e0         	blx	r12
;       format++;
70099058: 983c         	ldr	r0, [sp, #0xf0]
7009905a: 3001         	adds	r0, #0x1
7009905c: 903c         	str	r0, [sp, #0xf0]
;       continue;
7009905e: e7e6         	b	0x7009902e <_vsnprintf+0x2e> @ imm = #-0x34
;       format++;
70099060: 983c         	ldr	r0, [sp, #0xf0]
70099062: 3001         	adds	r0, #0x1
70099064: 903c         	str	r0, [sp, #0xf0]
70099066: e7ff         	b	0x70099068 <_vsnprintf+0x68> @ imm = #-0x2
70099068: 2000         	movs	r0, #0x0
;     flags = 0U;
7009906a: 903b         	str	r0, [sp, #0xec]
;     do {
7009906c: e7ff         	b	0x7009906e <_vsnprintf+0x6e> @ imm = #-0x2
;       switch (*format) {
7009906e: 983c         	ldr	r0, [sp, #0xf0]
70099070: 7800         	ldrb	r0, [r0]
70099072: 3820         	subs	r0, #0x20
70099074: 4601         	mov	r1, r0
70099076: 912a         	str	r1, [sp, #0xa8]
70099078: 2810         	cmp	r0, #0x10
7009907a: d83d         	bhi	0x700990f8 <_vsnprintf+0xf8> @ imm = #0x7a
7009907c: 992a         	ldr	r1, [sp, #0xa8]
7009907e: e8df f001    	tbb	[pc, r1]
70099082: 27 3b 3b 31  	.word	0x313b3b27
70099086: 3b 3b 3b 3b  	.word	0x3b3b3b3b
7009908a: 3b 3b 3b 1d  	.word	0x1d3b3b3b
7009908e: 3b 13 3b 3b  	.word	0x3b3b133b
70099092: 09 00        	.short	0x0009
;         case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
70099094: 983b         	ldr	r0, [sp, #0xec]
70099096: f040 0001    	orr	r0, r0, #0x1
7009909a: 903b         	str	r0, [sp, #0xec]
7009909c: 983c         	ldr	r0, [sp, #0xf0]
7009909e: 3001         	adds	r0, #0x1
700990a0: 903c         	str	r0, [sp, #0xf0]
700990a2: 2001         	movs	r0, #0x1
700990a4: 9038         	str	r0, [sp, #0xe0]
700990a6: e02a         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #0x54
;         case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
700990a8: 983b         	ldr	r0, [sp, #0xec]
700990aa: f040 0002    	orr	r0, r0, #0x2
700990ae: 903b         	str	r0, [sp, #0xec]
700990b0: 983c         	ldr	r0, [sp, #0xf0]
700990b2: 3001         	adds	r0, #0x1
700990b4: 903c         	str	r0, [sp, #0xf0]
700990b6: 2001         	movs	r0, #0x1
700990b8: 9038         	str	r0, [sp, #0xe0]
700990ba: e020         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #0x40
;         case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
700990bc: 983b         	ldr	r0, [sp, #0xec]
700990be: f040 0004    	orr	r0, r0, #0x4
700990c2: 903b         	str	r0, [sp, #0xec]
700990c4: 983c         	ldr	r0, [sp, #0xf0]
700990c6: 3001         	adds	r0, #0x1
700990c8: 903c         	str	r0, [sp, #0xf0]
700990ca: 2001         	movs	r0, #0x1
700990cc: 9038         	str	r0, [sp, #0xe0]
700990ce: e016         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #0x2c
;         case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
700990d0: 983b         	ldr	r0, [sp, #0xec]
700990d2: f040 0008    	orr	r0, r0, #0x8
700990d6: 903b         	str	r0, [sp, #0xec]
700990d8: 983c         	ldr	r0, [sp, #0xf0]
700990da: 3001         	adds	r0, #0x1
700990dc: 903c         	str	r0, [sp, #0xf0]
700990de: 2001         	movs	r0, #0x1
700990e0: 9038         	str	r0, [sp, #0xe0]
700990e2: e00c         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #0x18
;         case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
700990e4: 983b         	ldr	r0, [sp, #0xec]
700990e6: f040 0010    	orr	r0, r0, #0x10
700990ea: 903b         	str	r0, [sp, #0xec]
700990ec: 983c         	ldr	r0, [sp, #0xf0]
700990ee: 3001         	adds	r0, #0x1
700990f0: 903c         	str	r0, [sp, #0xf0]
700990f2: 2001         	movs	r0, #0x1
700990f4: 9038         	str	r0, [sp, #0xe0]
700990f6: e002         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #0x4
700990f8: 2000         	movs	r0, #0x0
;         default :                                   n = 0U; break;
700990fa: 9038         	str	r0, [sp, #0xe0]
700990fc: e7ff         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #-0x2
;     } while (n);
700990fe: e7ff         	b	0x70099100 <_vsnprintf+0x100> @ imm = #-0x2
70099100: 9838         	ldr	r0, [sp, #0xe0]
70099102: 2800         	cmp	r0, #0x0
70099104: d1b3         	bne	0x7009906e <_vsnprintf+0x6e> @ imm = #-0x9a
70099106: e7ff         	b	0x70099108 <_vsnprintf+0x108> @ imm = #-0x2
70099108: 2000         	movs	r0, #0x0
;     width = 0U;
7009910a: 903a         	str	r0, [sp, #0xe8]
;     if (_is_digit(*format)) {
7009910c: 983c         	ldr	r0, [sp, #0xf0]
7009910e: 7800         	ldrb	r0, [r0]
70099110: f013 fb56    	bl	0x700ac7c0 <_is_digit>  @ imm = #0x136ac
70099114: b128         	cbz	r0, 0x70099122 <_vsnprintf+0x122> @ imm = #0xa
70099116: e7ff         	b	0x70099118 <_vsnprintf+0x118> @ imm = #-0x2
70099118: a83c         	add	r0, sp, #0xf0
;       width = _atoi(&format);
7009911a: f012 ff81    	bl	0x700ac020 <_atoi>      @ imm = #0x12f02
7009911e: 903a         	str	r0, [sp, #0xe8]
;     }
70099120: e01e         	b	0x70099160 <_vsnprintf+0x160> @ imm = #0x3c
;     else if (*format == '*') {
70099122: 983c         	ldr	r0, [sp, #0xf0]
70099124: 7800         	ldrb	r0, [r0]
70099126: 282a         	cmp	r0, #0x2a
70099128: d119         	bne	0x7009915e <_vsnprintf+0x15e> @ imm = #0x32
7009912a: e7ff         	b	0x7009912c <_vsnprintf+0x12c> @ imm = #-0x2
;       const int w = va_arg(va, int);
7009912c: 9840         	ldr	r0, [sp, #0x100]
7009912e: 1d01         	adds	r1, r0, #0x4
70099130: 9140         	str	r1, [sp, #0x100]
70099132: 6800         	ldr	r0, [r0]
70099134: 9036         	str	r0, [sp, #0xd8]
;       if (w < 0) {
70099136: 9836         	ldr	r0, [sp, #0xd8]
70099138: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009913c: dc08         	bgt	0x70099150 <_vsnprintf+0x150> @ imm = #0x10
7009913e: e7ff         	b	0x70099140 <_vsnprintf+0x140> @ imm = #-0x2
;         flags |= FLAGS_LEFT;    // reverse padding
70099140: 983b         	ldr	r0, [sp, #0xec]
70099142: f040 0002    	orr	r0, r0, #0x2
70099146: 903b         	str	r0, [sp, #0xec]
;         width = (unsigned int)-w;
70099148: 9836         	ldr	r0, [sp, #0xd8]
7009914a: 4240         	rsbs	r0, r0, #0
7009914c: 903a         	str	r0, [sp, #0xe8]
;       }
7009914e: e002         	b	0x70099156 <_vsnprintf+0x156> @ imm = #0x4
;         width = (unsigned int)w;
70099150: 9836         	ldr	r0, [sp, #0xd8]
70099152: 903a         	str	r0, [sp, #0xe8]
70099154: e7ff         	b	0x70099156 <_vsnprintf+0x156> @ imm = #-0x2
;       format++;
70099156: 983c         	ldr	r0, [sp, #0xf0]
70099158: 3001         	adds	r0, #0x1
7009915a: 903c         	str	r0, [sp, #0xf0]
;     }
7009915c: e7ff         	b	0x7009915e <_vsnprintf+0x15e> @ imm = #-0x2
7009915e: e7ff         	b	0x70099160 <_vsnprintf+0x160> @ imm = #-0x2
70099160: 2000         	movs	r0, #0x0
;     precision = 0U;
70099162: 9039         	str	r0, [sp, #0xe4]
;     if (*format == '.') {
70099164: 983c         	ldr	r0, [sp, #0xf0]
70099166: 7800         	ldrb	r0, [r0]
70099168: 282e         	cmp	r0, #0x2e
7009916a: d12e         	bne	0x700991ca <_vsnprintf+0x1ca> @ imm = #0x5c
7009916c: e7ff         	b	0x7009916e <_vsnprintf+0x16e> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;
7009916e: 983b         	ldr	r0, [sp, #0xec]
70099170: f440 6080    	orr	r0, r0, #0x400
70099174: 903b         	str	r0, [sp, #0xec]
;       format++;
70099176: 983c         	ldr	r0, [sp, #0xf0]
70099178: 3001         	adds	r0, #0x1
7009917a: 903c         	str	r0, [sp, #0xf0]
;       if (_is_digit(*format)) {
7009917c: 983c         	ldr	r0, [sp, #0xf0]
7009917e: 7800         	ldrb	r0, [r0]
70099180: f013 fb1e    	bl	0x700ac7c0 <_is_digit>  @ imm = #0x1363c
70099184: b128         	cbz	r0, 0x70099192 <_vsnprintf+0x192> @ imm = #0xa
70099186: e7ff         	b	0x70099188 <_vsnprintf+0x188> @ imm = #-0x2
70099188: a83c         	add	r0, sp, #0xf0
;         precision = _atoi(&format);
7009918a: f012 ff49    	bl	0x700ac020 <_atoi>      @ imm = #0x12e92
7009918e: 9039         	str	r0, [sp, #0xe4]
;       }
70099190: e01a         	b	0x700991c8 <_vsnprintf+0x1c8> @ imm = #0x34
;       else if (*format == '*') {
70099192: 983c         	ldr	r0, [sp, #0xf0]
70099194: 7800         	ldrb	r0, [r0]
70099196: 282a         	cmp	r0, #0x2a
70099198: d115         	bne	0x700991c6 <_vsnprintf+0x1c6> @ imm = #0x2a
7009919a: e7ff         	b	0x7009919c <_vsnprintf+0x19c> @ imm = #-0x2
;         const int prec = (int)va_arg(va, int);
7009919c: 9840         	ldr	r0, [sp, #0x100]
7009919e: 1d01         	adds	r1, r0, #0x4
700991a0: 9140         	str	r1, [sp, #0x100]
700991a2: 6800         	ldr	r0, [r0]
700991a4: 9035         	str	r0, [sp, #0xd4]
;         precision = prec > 0 ? (unsigned int)prec : 0U;
700991a6: 9835         	ldr	r0, [sp, #0xd4]
700991a8: 2801         	cmp	r0, #0x1
700991aa: db03         	blt	0x700991b4 <_vsnprintf+0x1b4> @ imm = #0x6
700991ac: e7ff         	b	0x700991ae <_vsnprintf+0x1ae> @ imm = #-0x2
700991ae: 9835         	ldr	r0, [sp, #0xd4]
700991b0: 9029         	str	r0, [sp, #0xa4]
700991b2: e002         	b	0x700991ba <_vsnprintf+0x1ba> @ imm = #0x4
700991b4: 2000         	movs	r0, #0x0
;         precision = prec > 0 ? (unsigned int)prec : 0U;
700991b6: 9029         	str	r0, [sp, #0xa4]
700991b8: e7ff         	b	0x700991ba <_vsnprintf+0x1ba> @ imm = #-0x2
700991ba: 9829         	ldr	r0, [sp, #0xa4]
700991bc: 9039         	str	r0, [sp, #0xe4]
;         format++;
700991be: 983c         	ldr	r0, [sp, #0xf0]
700991c0: 3001         	adds	r0, #0x1
700991c2: 903c         	str	r0, [sp, #0xf0]
;       }
700991c4: e7ff         	b	0x700991c6 <_vsnprintf+0x1c6> @ imm = #-0x2
700991c6: e7ff         	b	0x700991c8 <_vsnprintf+0x1c8> @ imm = #-0x2
;     }
700991c8: e7ff         	b	0x700991ca <_vsnprintf+0x1ca> @ imm = #-0x2
;     switch (*format) {
700991ca: 983c         	ldr	r0, [sp, #0xf0]
700991cc: 7800         	ldrb	r0, [r0]
700991ce: 3868         	subs	r0, #0x68
700991d0: 4601         	mov	r1, r0
700991d2: 9128         	str	r1, [sp, #0xa0]
700991d4: 2812         	cmp	r0, #0x12
700991d6: d84e         	bhi	0x70099276 <_vsnprintf+0x276> @ imm = #0x9c
700991d8: 9928         	ldr	r1, [sp, #0xa0]
700991da: e8df f001    	tbb	[pc, r1]
700991de: 1f 4c 3c 4c  	.word	0x4c3c4c1f
700991e2: 0a 4c 4c 4c  	.word	0x4c4c4c0a
700991e6: 4c 4c 4c 4c  	.word	0x4c4c4c4c
700991ea: 34 4c 4c 4c  	.word	0x4c4c4c34
700991ee: 4c 4c 44 00  	.word	0x00444c4c
;         flags |= FLAGS_LONG;
700991f2: 983b         	ldr	r0, [sp, #0xec]
700991f4: f440 7080    	orr	r0, r0, #0x100
700991f8: 903b         	str	r0, [sp, #0xec]
;         format++;
700991fa: 983c         	ldr	r0, [sp, #0xf0]
700991fc: 3001         	adds	r0, #0x1
700991fe: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'l') {
70099200: 983c         	ldr	r0, [sp, #0xf0]
70099202: 7800         	ldrb	r0, [r0]
70099204: 286c         	cmp	r0, #0x6c
70099206: d108         	bne	0x7009921a <_vsnprintf+0x21a> @ imm = #0x10
70099208: e7ff         	b	0x7009920a <_vsnprintf+0x20a> @ imm = #-0x2
;           flags |= FLAGS_LONG_LONG;
7009920a: 983b         	ldr	r0, [sp, #0xec]
7009920c: f440 7000    	orr	r0, r0, #0x200
70099210: 903b         	str	r0, [sp, #0xec]
;           format++;
70099212: 983c         	ldr	r0, [sp, #0xf0]
70099214: 3001         	adds	r0, #0x1
70099216: 903c         	str	r0, [sp, #0xf0]
;         }
70099218: e7ff         	b	0x7009921a <_vsnprintf+0x21a> @ imm = #-0x2
;         break;
7009921a: e02d         	b	0x70099278 <_vsnprintf+0x278> @ imm = #0x5a
;         flags |= FLAGS_SHORT;
7009921c: 983b         	ldr	r0, [sp, #0xec]
7009921e: f040 0080    	orr	r0, r0, #0x80
70099222: 903b         	str	r0, [sp, #0xec]
;         format++;
70099224: 983c         	ldr	r0, [sp, #0xf0]
70099226: 3001         	adds	r0, #0x1
70099228: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'h') {
7009922a: 983c         	ldr	r0, [sp, #0xf0]
7009922c: 7800         	ldrb	r0, [r0]
7009922e: 2868         	cmp	r0, #0x68
70099230: d108         	bne	0x70099244 <_vsnprintf+0x244> @ imm = #0x10
70099232: e7ff         	b	0x70099234 <_vsnprintf+0x234> @ imm = #-0x2
;           flags |= FLAGS_CHAR;
70099234: 983b         	ldr	r0, [sp, #0xec]
70099236: f040 0040    	orr	r0, r0, #0x40
7009923a: 903b         	str	r0, [sp, #0xec]
;           format++;
7009923c: 983c         	ldr	r0, [sp, #0xf0]
7009923e: 3001         	adds	r0, #0x1
70099240: 903c         	str	r0, [sp, #0xf0]
;         }
70099242: e7ff         	b	0x70099244 <_vsnprintf+0x244> @ imm = #-0x2
;         break;
70099244: e018         	b	0x70099278 <_vsnprintf+0x278> @ imm = #0x30
;         flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
70099246: 983b         	ldr	r0, [sp, #0xec]
70099248: f440 7080    	orr	r0, r0, #0x100
7009924c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009924e: 983c         	ldr	r0, [sp, #0xf0]
70099250: 3001         	adds	r0, #0x1
70099252: 903c         	str	r0, [sp, #0xf0]
;         break;
70099254: e010         	b	0x70099278 <_vsnprintf+0x278> @ imm = #0x20
;         flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
70099256: 983b         	ldr	r0, [sp, #0xec]
70099258: f440 7000    	orr	r0, r0, #0x200
7009925c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009925e: 983c         	ldr	r0, [sp, #0xf0]
70099260: 3001         	adds	r0, #0x1
70099262: 903c         	str	r0, [sp, #0xf0]
;         break;
70099264: e008         	b	0x70099278 <_vsnprintf+0x278> @ imm = #0x10
;         flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
70099266: 983b         	ldr	r0, [sp, #0xec]
70099268: f440 7080    	orr	r0, r0, #0x100
7009926c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009926e: 983c         	ldr	r0, [sp, #0xf0]
70099270: 3001         	adds	r0, #0x1
70099272: 903c         	str	r0, [sp, #0xf0]
;         break;
70099274: e000         	b	0x70099278 <_vsnprintf+0x278> @ imm = #0x0
;         break;
70099276: e7ff         	b	0x70099278 <_vsnprintf+0x278> @ imm = #-0x2
;     switch (*format) {
70099278: 983c         	ldr	r0, [sp, #0xf0]
7009927a: 7800         	ldrb	r0, [r0]
7009927c: 3825         	subs	r0, #0x25
7009927e: 4601         	mov	r1, r0
70099280: 9127         	str	r1, [sp, #0x9c]
70099282: 2853         	cmp	r0, #0x53
70099284: f200 83ab    	bhi.w	0x700999de <_vsnprintf+0x9de> @ imm = #0x756
70099288: 9927         	ldr	r1, [sp, #0x9c]
7009928a: e8df f011    	tbh	[pc, r1, lsl #1]
7009928e: 9b 03 a8 03  	.word	0x03a8039b
70099292: a8 03 a8 03  	.word	0x03a803a8
70099296: a8 03 a8 03  	.word	0x03a803a8
7009929a: a8 03 a8 03  	.word	0x03a803a8
7009929e: a8 03 a8 03  	.word	0x03a803a8
700992a2: a8 03 a8 03  	.word	0x03a803a8
700992a6: a8 03 a8 03  	.word	0x03a803a8
700992aa: a8 03 a8 03  	.word	0x03a803a8
700992ae: a8 03 a8 03  	.word	0x03a803a8
700992b2: a8 03 a8 03  	.word	0x03a803a8
700992b6: a8 03 a8 03  	.word	0x03a803a8
700992ba: a8 03 a8 03  	.word	0x03a803a8
700992be: a8 03 a8 03  	.word	0x03a803a8
700992c2: a8 03 a8 03  	.word	0x03a803a8
700992c6: a8 03 a8 03  	.word	0x03a803a8
700992ca: a8 03 a8 03  	.word	0x03a803a8
700992ce: 5e 02 32 02  	.word	0x0232025e
700992d2: 5e 02 a8 03  	.word	0x03a8025e
700992d6: a8 03 a8 03  	.word	0x03a803a8
700992da: a8 03 a8 03  	.word	0x03a803a8
700992de: a8 03 a8 03  	.word	0x03a803a8
700992e2: a8 03 a8 03  	.word	0x03a803a8
700992e6: a8 03 a8 03  	.word	0x03a803a8
700992ea: a8 03 a8 03  	.word	0x03a803a8
700992ee: a8 03 a8 03  	.word	0x03a803a8
700992f2: a8 03 54 00  	.word	0x005403a8
700992f6: a8 03 a8 03  	.word	0x03a803a8
700992fa: a8 03 a8 03  	.word	0x03a803a8
700992fe: a8 03 a8 03  	.word	0x03a803a8
70099302: a8 03 a8 03  	.word	0x03a803a8
70099306: a8 03 54 00  	.word	0x005403a8
7009930a: 9e 02 54 00  	.word	0x0054029e
7009930e: 5e 02 32 02  	.word	0x0232025e
70099312: 5e 02 a8 03  	.word	0x03a8025e
70099316: 54 00 a8 03  	.word	0x03a80054
7009931a: a8 03 a8 03  	.word	0x03a803a8
7009931e: a8 03 a8 03  	.word	0x03a803a8
70099322: 54 00 6e 03  	.word	0x036e0054
70099326: a8 03 a8 03  	.word	0x03a803a8
7009932a: e2 02 a8 03  	.word	0x03a802e2
7009932e: 54 00 a8 03  	.word	0x03a80054
70099332: a8 03 54 00  	.word	0x005403a8
;         if (*format == 'x' || *format == 'X') {
70099336: 983c         	ldr	r0, [sp, #0xf0]
70099338: 7800         	ldrb	r0, [r0]
7009933a: 2878         	cmp	r0, #0x78
7009933c: d005         	beq	0x7009934a <_vsnprintf+0x34a> @ imm = #0xa
7009933e: e7ff         	b	0x70099340 <_vsnprintf+0x340> @ imm = #-0x2
70099340: 983c         	ldr	r0, [sp, #0xf0]
70099342: 7800         	ldrb	r0, [r0]
70099344: 2858         	cmp	r0, #0x58
70099346: d103         	bne	0x70099350 <_vsnprintf+0x350> @ imm = #0x6
70099348: e7ff         	b	0x7009934a <_vsnprintf+0x34a> @ imm = #-0x2
7009934a: 2010         	movs	r0, #0x10
;           base = 16U;
7009934c: 9034         	str	r0, [sp, #0xd0]
;         }
7009934e: e018         	b	0x70099382 <_vsnprintf+0x382> @ imm = #0x30
;         else if (*format == 'o') {
70099350: 983c         	ldr	r0, [sp, #0xf0]
70099352: 7800         	ldrb	r0, [r0]
70099354: 286f         	cmp	r0, #0x6f
70099356: d103         	bne	0x70099360 <_vsnprintf+0x360> @ imm = #0x6
70099358: e7ff         	b	0x7009935a <_vsnprintf+0x35a> @ imm = #-0x2
7009935a: 2008         	movs	r0, #0x8
;           base =  8U;
7009935c: 9034         	str	r0, [sp, #0xd0]
;         }
7009935e: e00f         	b	0x70099380 <_vsnprintf+0x380> @ imm = #0x1e
;         else if (*format == 'b') {
70099360: 983c         	ldr	r0, [sp, #0xf0]
70099362: 7800         	ldrb	r0, [r0]
70099364: 2862         	cmp	r0, #0x62
70099366: d103         	bne	0x70099370 <_vsnprintf+0x370> @ imm = #0x6
70099368: e7ff         	b	0x7009936a <_vsnprintf+0x36a> @ imm = #-0x2
7009936a: 2002         	movs	r0, #0x2
;           base =  2U;
7009936c: 9034         	str	r0, [sp, #0xd0]
;         }
7009936e: e006         	b	0x7009937e <_vsnprintf+0x37e> @ imm = #0xc
70099370: 200a         	movs	r0, #0xa
;           base = 10U;
70099372: 9034         	str	r0, [sp, #0xd0]
;           flags &= ~FLAGS_HASH;   // no hash for dec format
70099374: 983b         	ldr	r0, [sp, #0xec]
70099376: f020 0010    	bic	r0, r0, #0x10
7009937a: 903b         	str	r0, [sp, #0xec]
7009937c: e7ff         	b	0x7009937e <_vsnprintf+0x37e> @ imm = #-0x2
7009937e: e7ff         	b	0x70099380 <_vsnprintf+0x380> @ imm = #-0x2
70099380: e7ff         	b	0x70099382 <_vsnprintf+0x382> @ imm = #-0x2
;         if (*format == 'X') {
70099382: 983c         	ldr	r0, [sp, #0xf0]
70099384: 7800         	ldrb	r0, [r0]
70099386: 2858         	cmp	r0, #0x58
70099388: d105         	bne	0x70099396 <_vsnprintf+0x396> @ imm = #0xa
7009938a: e7ff         	b	0x7009938c <_vsnprintf+0x38c> @ imm = #-0x2
;           flags |= FLAGS_UPPERCASE;
7009938c: 983b         	ldr	r0, [sp, #0xec]
7009938e: f040 0020    	orr	r0, r0, #0x20
70099392: 903b         	str	r0, [sp, #0xec]
;         }
70099394: e7ff         	b	0x70099396 <_vsnprintf+0x396> @ imm = #-0x2
;         if ((*format != 'i') && (*format != 'd')) {
70099396: 983c         	ldr	r0, [sp, #0xf0]
70099398: 7800         	ldrb	r0, [r0]
7009939a: 2869         	cmp	r0, #0x69
7009939c: d00a         	beq	0x700993b4 <_vsnprintf+0x3b4> @ imm = #0x14
7009939e: e7ff         	b	0x700993a0 <_vsnprintf+0x3a0> @ imm = #-0x2
700993a0: 983c         	ldr	r0, [sp, #0xf0]
700993a2: 7800         	ldrb	r0, [r0]
700993a4: 2864         	cmp	r0, #0x64
700993a6: d005         	beq	0x700993b4 <_vsnprintf+0x3b4> @ imm = #0xa
700993a8: e7ff         	b	0x700993aa <_vsnprintf+0x3aa> @ imm = #-0x2
;           flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
700993aa: 983b         	ldr	r0, [sp, #0xec]
700993ac: f020 000c    	bic	r0, r0, #0xc
700993b0: 903b         	str	r0, [sp, #0xec]
;         }
700993b2: e7ff         	b	0x700993b4 <_vsnprintf+0x3b4> @ imm = #-0x2
;         if (flags & FLAGS_PRECISION) {
700993b4: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
700993b8: 0740         	lsls	r0, r0, #0x1d
700993ba: 2800         	cmp	r0, #0x0
700993bc: d505         	bpl	0x700993ca <_vsnprintf+0x3ca> @ imm = #0xa
700993be: e7ff         	b	0x700993c0 <_vsnprintf+0x3c0> @ imm = #-0x2
;           flags &= ~FLAGS_ZEROPAD;
700993c0: 983b         	ldr	r0, [sp, #0xec]
700993c2: f020 0001    	bic	r0, r0, #0x1
700993c6: 903b         	str	r0, [sp, #0xec]
;         }
700993c8: e7ff         	b	0x700993ca <_vsnprintf+0x3ca> @ imm = #-0x2
;         if ((*format == 'i') || (*format == 'd')) {
700993ca: 983c         	ldr	r0, [sp, #0xf0]
700993cc: 7800         	ldrb	r0, [r0]
700993ce: 2869         	cmp	r0, #0x69
700993d0: d006         	beq	0x700993e0 <_vsnprintf+0x3e0> @ imm = #0xc
700993d2: e7ff         	b	0x700993d4 <_vsnprintf+0x3d4> @ imm = #-0x2
700993d4: 983c         	ldr	r0, [sp, #0xf0]
700993d6: 7800         	ldrb	r0, [r0]
700993d8: 2864         	cmp	r0, #0x64
700993da: f040 80e9    	bne.w	0x700995b0 <_vsnprintf+0x5b0> @ imm = #0x1d2
700993de: e7ff         	b	0x700993e0 <_vsnprintf+0x3e0> @ imm = #-0x2
;           if (flags & FLAGS_LONG_LONG) {
700993e0: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
700993e4: 0780         	lsls	r0, r0, #0x1e
700993e6: 2800         	cmp	r0, #0x0
700993e8: d550         	bpl	0x7009948c <_vsnprintf+0x48c> @ imm = #0xa0
700993ea: e7ff         	b	0x700993ec <_vsnprintf+0x3ec> @ imm = #-0x2
;             const long long value = va_arg(va, long long);
700993ec: 9840         	ldr	r0, [sp, #0x100]
700993ee: 3007         	adds	r0, #0x7
700993f0: f020 0107    	bic	r1, r0, #0x7
700993f4: f101 0008    	add.w	r0, r1, #0x8
700993f8: 9040         	str	r0, [sp, #0x100]
700993fa: 6808         	ldr	r0, [r1]
700993fc: 6849         	ldr	r1, [r1, #0x4]
700993fe: 9133         	str	r1, [sp, #0xcc]
70099400: 9032         	str	r0, [sp, #0xc8]
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
70099402: 983f         	ldr	r0, [sp, #0xfc]
70099404: 9023         	str	r0, [sp, #0x8c]
70099406: 983e         	ldr	r0, [sp, #0xf8]
70099408: 9024         	str	r0, [sp, #0x90]
7009940a: 9837         	ldr	r0, [sp, #0xdc]
7009940c: 9025         	str	r0, [sp, #0x94]
7009940e: 983d         	ldr	r0, [sp, #0xf4]
70099410: 9026         	str	r0, [sp, #0x98]
70099412: 9932         	ldr	r1, [sp, #0xc8]
70099414: 9833         	ldr	r0, [sp, #0xcc]
70099416: 3901         	subs	r1, #0x1
70099418: f170 0000    	sbcs	r0, r0, #0x0
7009941c: db05         	blt	0x7009942a <_vsnprintf+0x42a> @ imm = #0xa
7009941e: e7ff         	b	0x70099420 <_vsnprintf+0x420> @ imm = #-0x2
70099420: 9932         	ldr	r1, [sp, #0xc8]
70099422: 9833         	ldr	r0, [sp, #0xcc]
70099424: 9121         	str	r1, [sp, #0x84]
70099426: 9022         	str	r0, [sp, #0x88]
70099428: e008         	b	0x7009943c <_vsnprintf+0x43c> @ imm = #0x10
7009942a: 9832         	ldr	r0, [sp, #0xc8]
7009942c: 9a33         	ldr	r2, [sp, #0xcc]
7009942e: 4241         	rsbs	r1, r0, #0
70099430: f04f 0000    	mov.w	r0, #0x0
70099434: 4190         	sbcs	r0, r2
70099436: 9121         	str	r1, [sp, #0x84]
70099438: 9022         	str	r0, [sp, #0x88]
7009943a: e7ff         	b	0x7009943c <_vsnprintf+0x43c> @ imm = #-0x2
7009943c: 9b26         	ldr	r3, [sp, #0x98]
7009943e: 9a25         	ldr	r2, [sp, #0x94]
70099440: 9924         	ldr	r1, [sp, #0x90]
70099442: 9823         	ldr	r0, [sp, #0x8c]
70099444: f8dd c084    	ldr.w	r12, [sp, #0x84]
70099448: 9c22         	ldr	r4, [sp, #0x88]
7009944a: 9d33         	ldr	r5, [sp, #0xcc]
7009944c: 9e34         	ldr	r6, [sp, #0xd0]
7009944e: 9f39         	ldr	r7, [sp, #0xe4]
70099450: f8dd 80e8    	ldr.w	r8, [sp, #0xe8]
70099454: f8dd 90ec    	ldr.w	r9, [sp, #0xec]
70099458: 46ee         	mov	lr, sp
7009945a: f8cd e080    	str.w	lr, [sp, #0x80]
7009945e: f8ce 9020    	str.w	r9, [lr, #0x20]
70099462: f8ce 801c    	str.w	r8, [lr, #0x1c]
70099466: f8ce 7018    	str.w	r7, [lr, #0x18]
7009946a: 2700         	movs	r7, #0x0
7009946c: f8ce 7014    	str.w	r7, [lr, #0x14]
70099470: f8ce 6010    	str.w	r6, [lr, #0x10]
70099474: ea4f 75d5    	lsr.w	r5, r5, #0x1f
70099478: f8ce 5008    	str.w	r5, [lr, #0x8]
7009947c: f8ce 4004    	str.w	r4, [lr, #0x4]
70099480: f8ce c000    	str.w	r12, [lr]
70099484: f007 fd74    	bl	0x700a0f70 <_ntoa_long_long> @ imm = #0x7ae8
70099488: 9037         	str	r0, [sp, #0xdc]
;           }
7009948a: e090         	b	0x700995ae <_vsnprintf+0x5ae> @ imm = #0x120
;           else if (flags & FLAGS_LONG) {
7009948c: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
70099490: 07c0         	lsls	r0, r0, #0x1f
70099492: b3b0         	cbz	r0, 0x70099502 <_vsnprintf+0x502> @ imm = #0x6c
70099494: e7ff         	b	0x70099496 <_vsnprintf+0x496> @ imm = #-0x2
;             const long value = va_arg(va, long);
70099496: 9840         	ldr	r0, [sp, #0x100]
70099498: 1d01         	adds	r1, r0, #0x4
7009949a: 9140         	str	r1, [sp, #0x100]
7009949c: 6800         	ldr	r0, [r0]
7009949e: 9031         	str	r0, [sp, #0xc4]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
700994a0: 983f         	ldr	r0, [sp, #0xfc]
700994a2: 901c         	str	r0, [sp, #0x70]
700994a4: 983e         	ldr	r0, [sp, #0xf8]
700994a6: 901d         	str	r0, [sp, #0x74]
700994a8: 9837         	ldr	r0, [sp, #0xdc]
700994aa: 901e         	str	r0, [sp, #0x78]
700994ac: 983d         	ldr	r0, [sp, #0xf4]
700994ae: 901f         	str	r0, [sp, #0x7c]
700994b0: 9831         	ldr	r0, [sp, #0xc4]
700994b2: 2801         	cmp	r0, #0x1
700994b4: db03         	blt	0x700994be <_vsnprintf+0x4be> @ imm = #0x6
700994b6: e7ff         	b	0x700994b8 <_vsnprintf+0x4b8> @ imm = #-0x2
700994b8: 9831         	ldr	r0, [sp, #0xc4]
700994ba: 901b         	str	r0, [sp, #0x6c]
700994bc: e003         	b	0x700994c6 <_vsnprintf+0x4c6> @ imm = #0x6
700994be: 9831         	ldr	r0, [sp, #0xc4]
700994c0: 4240         	rsbs	r0, r0, #0
700994c2: 901b         	str	r0, [sp, #0x6c]
700994c4: e7ff         	b	0x700994c6 <_vsnprintf+0x4c6> @ imm = #-0x2
700994c6: 9b1f         	ldr	r3, [sp, #0x7c]
700994c8: 9a1e         	ldr	r2, [sp, #0x78]
700994ca: 991d         	ldr	r1, [sp, #0x74]
700994cc: 981c         	ldr	r0, [sp, #0x70]
700994ce: f8dd c06c    	ldr.w	r12, [sp, #0x6c]
700994d2: 9c31         	ldr	r4, [sp, #0xc4]
700994d4: 9d34         	ldr	r5, [sp, #0xd0]
700994d6: 9e39         	ldr	r6, [sp, #0xe4]
700994d8: 9f3a         	ldr	r7, [sp, #0xe8]
700994da: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
700994de: 46ee         	mov	lr, sp
700994e0: f8ce 8014    	str.w	r8, [lr, #0x14]
700994e4: f8ce 7010    	str.w	r7, [lr, #0x10]
700994e8: f8ce 600c    	str.w	r6, [lr, #0xc]
700994ec: f8ce 5008    	str.w	r5, [lr, #0x8]
700994f0: 0fe4         	lsrs	r4, r4, #0x1f
700994f2: f8ce 4004    	str.w	r4, [lr, #0x4]
700994f6: f8ce c000    	str.w	r12, [lr]
700994fa: f009 fe31    	bl	0x700a3160 <_ntoa_long> @ imm = #0x9c62
700994fe: 9037         	str	r0, [sp, #0xdc]
;           }
70099500: e054         	b	0x700995ac <_vsnprintf+0x5ac> @ imm = #0xa8
;             const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
70099502: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
70099506: 0640         	lsls	r0, r0, #0x19
70099508: 2800         	cmp	r0, #0x0
7009950a: d506         	bpl	0x7009951a <_vsnprintf+0x51a> @ imm = #0xc
7009950c: e7ff         	b	0x7009950e <_vsnprintf+0x50e> @ imm = #-0x2
7009950e: 9840         	ldr	r0, [sp, #0x100]
70099510: 1d01         	adds	r1, r0, #0x4
70099512: 9140         	str	r1, [sp, #0x100]
70099514: 7800         	ldrb	r0, [r0]
70099516: 901a         	str	r0, [sp, #0x68]
70099518: e015         	b	0x70099546 <_vsnprintf+0x546> @ imm = #0x2a
7009951a: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009951e: 0600         	lsls	r0, r0, #0x18
70099520: 2800         	cmp	r0, #0x0
70099522: d507         	bpl	0x70099534 <_vsnprintf+0x534> @ imm = #0xe
70099524: e7ff         	b	0x70099526 <_vsnprintf+0x526> @ imm = #-0x2
70099526: 9840         	ldr	r0, [sp, #0x100]
70099528: 1d01         	adds	r1, r0, #0x4
7009952a: 9140         	str	r1, [sp, #0x100]
7009952c: f9b0 0000    	ldrsh.w	r0, [r0]
70099530: 9019         	str	r0, [sp, #0x64]
70099532: e005         	b	0x70099540 <_vsnprintf+0x540> @ imm = #0xa
70099534: 9840         	ldr	r0, [sp, #0x100]
70099536: 1d01         	adds	r1, r0, #0x4
70099538: 9140         	str	r1, [sp, #0x100]
7009953a: 6800         	ldr	r0, [r0]
7009953c: 9019         	str	r0, [sp, #0x64]
7009953e: e7ff         	b	0x70099540 <_vsnprintf+0x540> @ imm = #-0x2
70099540: 9819         	ldr	r0, [sp, #0x64]
70099542: 901a         	str	r0, [sp, #0x68]
70099544: e7ff         	b	0x70099546 <_vsnprintf+0x546> @ imm = #-0x2
70099546: 981a         	ldr	r0, [sp, #0x68]
70099548: 9030         	str	r0, [sp, #0xc0]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009954a: 983f         	ldr	r0, [sp, #0xfc]
7009954c: 9015         	str	r0, [sp, #0x54]
7009954e: 983e         	ldr	r0, [sp, #0xf8]
70099550: 9016         	str	r0, [sp, #0x58]
70099552: 9837         	ldr	r0, [sp, #0xdc]
70099554: 9017         	str	r0, [sp, #0x5c]
70099556: 983d         	ldr	r0, [sp, #0xf4]
70099558: 9018         	str	r0, [sp, #0x60]
7009955a: 9830         	ldr	r0, [sp, #0xc0]
7009955c: 2801         	cmp	r0, #0x1
7009955e: db03         	blt	0x70099568 <_vsnprintf+0x568> @ imm = #0x6
70099560: e7ff         	b	0x70099562 <_vsnprintf+0x562> @ imm = #-0x2
70099562: 9830         	ldr	r0, [sp, #0xc0]
70099564: 9014         	str	r0, [sp, #0x50]
70099566: e003         	b	0x70099570 <_vsnprintf+0x570> @ imm = #0x6
70099568: 9830         	ldr	r0, [sp, #0xc0]
7009956a: 4240         	rsbs	r0, r0, #0
7009956c: 9014         	str	r0, [sp, #0x50]
7009956e: e7ff         	b	0x70099570 <_vsnprintf+0x570> @ imm = #-0x2
70099570: 9b18         	ldr	r3, [sp, #0x60]
70099572: 9a17         	ldr	r2, [sp, #0x5c]
70099574: 9916         	ldr	r1, [sp, #0x58]
70099576: 9815         	ldr	r0, [sp, #0x54]
70099578: f8dd c050    	ldr.w	r12, [sp, #0x50]
7009957c: 9c30         	ldr	r4, [sp, #0xc0]
7009957e: 9d34         	ldr	r5, [sp, #0xd0]
70099580: 9e39         	ldr	r6, [sp, #0xe4]
70099582: 9f3a         	ldr	r7, [sp, #0xe8]
70099584: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
70099588: 46ee         	mov	lr, sp
7009958a: f8ce 8014    	str.w	r8, [lr, #0x14]
7009958e: f8ce 7010    	str.w	r7, [lr, #0x10]
70099592: f8ce 600c    	str.w	r6, [lr, #0xc]
70099596: f8ce 5008    	str.w	r5, [lr, #0x8]
7009959a: 0fe4         	lsrs	r4, r4, #0x1f
7009959c: f8ce 4004    	str.w	r4, [lr, #0x4]
700995a0: f8ce c000    	str.w	r12, [lr]
700995a4: f009 fddc    	bl	0x700a3160 <_ntoa_long> @ imm = #0x9bb8
700995a8: 9037         	str	r0, [sp, #0xdc]
700995aa: e7ff         	b	0x700995ac <_vsnprintf+0x5ac> @ imm = #-0x2
700995ac: e7ff         	b	0x700995ae <_vsnprintf+0x5ae> @ imm = #-0x2
;         }
700995ae: e09c         	b	0x700996ea <_vsnprintf+0x6ea> @ imm = #0x138
;           if (flags & FLAGS_LONG_LONG) {
700995b0: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
700995b4: 0780         	lsls	r0, r0, #0x1e
700995b6: 2800         	cmp	r0, #0x0
700995b8: d52f         	bpl	0x7009961a <_vsnprintf+0x61a> @ imm = #0x5e
700995ba: e7ff         	b	0x700995bc <_vsnprintf+0x5bc> @ imm = #-0x2
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
700995bc: 983f         	ldr	r0, [sp, #0xfc]
700995be: 993e         	ldr	r1, [sp, #0xf8]
700995c0: 9a37         	ldr	r2, [sp, #0xdc]
700995c2: 9b3d         	ldr	r3, [sp, #0xf4]
700995c4: f8dd c100    	ldr.w	r12, [sp, #0x100]
700995c8: f10c 0c07    	add.w	r12, r12, #0x7
700995cc: f02c 0e07    	bic	lr, r12, #0x7
700995d0: f10e 0c08    	add.w	r12, lr, #0x8
700995d4: f8cd c100    	str.w	r12, [sp, #0x100]
700995d8: f8de c000    	ldr.w	r12, [lr]
700995dc: f8de 4004    	ldr.w	r4, [lr, #0x4]
700995e0: 9e34         	ldr	r6, [sp, #0xd0]
700995e2: 9d39         	ldr	r5, [sp, #0xe4]
700995e4: 9f3a         	ldr	r7, [sp, #0xe8]
700995e6: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
700995ea: 46ee         	mov	lr, sp
700995ec: f8cd e04c    	str.w	lr, [sp, #0x4c]
700995f0: f8ce 8020    	str.w	r8, [lr, #0x20]
700995f4: f8ce 701c    	str.w	r7, [lr, #0x1c]
700995f8: f8ce 5018    	str.w	r5, [lr, #0x18]
700995fc: 2500         	movs	r5, #0x0
700995fe: f8ce 5014    	str.w	r5, [lr, #0x14]
70099602: f8ce 6010    	str.w	r6, [lr, #0x10]
70099606: f8ce 5008    	str.w	r5, [lr, #0x8]
7009960a: f8ce 4004    	str.w	r4, [lr, #0x4]
7009960e: f8ce c000    	str.w	r12, [lr]
70099612: f007 fcad    	bl	0x700a0f70 <_ntoa_long_long> @ imm = #0x795a
70099616: 9037         	str	r0, [sp, #0xdc]
;           }
70099618: e066         	b	0x700996e8 <_vsnprintf+0x6e8> @ imm = #0xcc
;           else if (flags & FLAGS_LONG) {
7009961a: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009961e: 07c0         	lsls	r0, r0, #0x1f
70099620: b310         	cbz	r0, 0x70099668 <_vsnprintf+0x668> @ imm = #0x44
70099622: e7ff         	b	0x70099624 <_vsnprintf+0x624> @ imm = #-0x2
;             idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
70099624: 983f         	ldr	r0, [sp, #0xfc]
70099626: 993e         	ldr	r1, [sp, #0xf8]
70099628: 9a37         	ldr	r2, [sp, #0xdc]
7009962a: 9b3d         	ldr	r3, [sp, #0xf4]
7009962c: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099630: f10c 0e04    	add.w	lr, r12, #0x4
70099634: f8cd e100    	str.w	lr, [sp, #0x100]
70099638: f8dc c000    	ldr.w	r12, [r12]
7009963c: 9c34         	ldr	r4, [sp, #0xd0]
7009963e: 9d39         	ldr	r5, [sp, #0xe4]
70099640: 9e3a         	ldr	r6, [sp, #0xe8]
70099642: 9f3b         	ldr	r7, [sp, #0xec]
70099644: 46ee         	mov	lr, sp
70099646: f8ce 7014    	str.w	r7, [lr, #0x14]
7009964a: f8ce 6010    	str.w	r6, [lr, #0x10]
7009964e: f8ce 500c    	str.w	r5, [lr, #0xc]
70099652: f8ce 4008    	str.w	r4, [lr, #0x8]
70099656: 2400         	movs	r4, #0x0
70099658: f8ce 4004    	str.w	r4, [lr, #0x4]
7009965c: f8ce c000    	str.w	r12, [lr]
70099660: f009 fd7e    	bl	0x700a3160 <_ntoa_long> @ imm = #0x9afc
70099664: 9037         	str	r0, [sp, #0xdc]
;           }
70099666: e03e         	b	0x700996e6 <_vsnprintf+0x6e6> @ imm = #0x7c
;             const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
70099668: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009966c: 0640         	lsls	r0, r0, #0x19
7009966e: 2800         	cmp	r0, #0x0
70099670: d506         	bpl	0x70099680 <_vsnprintf+0x680> @ imm = #0xc
70099672: e7ff         	b	0x70099674 <_vsnprintf+0x674> @ imm = #-0x2
70099674: 9840         	ldr	r0, [sp, #0x100]
70099676: 1d01         	adds	r1, r0, #0x4
70099678: 9140         	str	r1, [sp, #0x100]
7009967a: 7800         	ldrb	r0, [r0]
7009967c: 9012         	str	r0, [sp, #0x48]
7009967e: e014         	b	0x700996aa <_vsnprintf+0x6aa> @ imm = #0x28
70099680: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
70099684: 0600         	lsls	r0, r0, #0x18
70099686: 2800         	cmp	r0, #0x0
70099688: d506         	bpl	0x70099698 <_vsnprintf+0x698> @ imm = #0xc
7009968a: e7ff         	b	0x7009968c <_vsnprintf+0x68c> @ imm = #-0x2
7009968c: 9840         	ldr	r0, [sp, #0x100]
7009968e: 1d01         	adds	r1, r0, #0x4
70099690: 9140         	str	r1, [sp, #0x100]
70099692: 8800         	ldrh	r0, [r0]
70099694: 9011         	str	r0, [sp, #0x44]
70099696: e005         	b	0x700996a4 <_vsnprintf+0x6a4> @ imm = #0xa
70099698: 9840         	ldr	r0, [sp, #0x100]
7009969a: 1d01         	adds	r1, r0, #0x4
7009969c: 9140         	str	r1, [sp, #0x100]
7009969e: 6800         	ldr	r0, [r0]
700996a0: 9011         	str	r0, [sp, #0x44]
700996a2: e7ff         	b	0x700996a4 <_vsnprintf+0x6a4> @ imm = #-0x2
700996a4: 9811         	ldr	r0, [sp, #0x44]
700996a6: 9012         	str	r0, [sp, #0x48]
700996a8: e7ff         	b	0x700996aa <_vsnprintf+0x6aa> @ imm = #-0x2
700996aa: 9812         	ldr	r0, [sp, #0x48]
700996ac: 902f         	str	r0, [sp, #0xbc]
;             idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
700996ae: 983f         	ldr	r0, [sp, #0xfc]
700996b0: 993e         	ldr	r1, [sp, #0xf8]
700996b2: 9a37         	ldr	r2, [sp, #0xdc]
700996b4: 9b3d         	ldr	r3, [sp, #0xf4]
700996b6: f8dd c0bc    	ldr.w	r12, [sp, #0xbc]
700996ba: 9c34         	ldr	r4, [sp, #0xd0]
700996bc: 9d39         	ldr	r5, [sp, #0xe4]
700996be: 9e3a         	ldr	r6, [sp, #0xe8]
700996c0: 9f3b         	ldr	r7, [sp, #0xec]
700996c2: 46ee         	mov	lr, sp
700996c4: f8ce 7014    	str.w	r7, [lr, #0x14]
700996c8: f8ce 6010    	str.w	r6, [lr, #0x10]
700996cc: f8ce 500c    	str.w	r5, [lr, #0xc]
700996d0: f8ce 4008    	str.w	r4, [lr, #0x8]
700996d4: 2400         	movs	r4, #0x0
700996d6: f8ce 4004    	str.w	r4, [lr, #0x4]
700996da: f8ce c000    	str.w	r12, [lr]
700996de: f009 fd3f    	bl	0x700a3160 <_ntoa_long> @ imm = #0x9a7e
700996e2: 9037         	str	r0, [sp, #0xdc]
700996e4: e7ff         	b	0x700996e6 <_vsnprintf+0x6e6> @ imm = #-0x2
700996e6: e7ff         	b	0x700996e8 <_vsnprintf+0x6e8> @ imm = #-0x2
700996e8: e7ff         	b	0x700996ea <_vsnprintf+0x6ea> @ imm = #-0x2
;         format++;
700996ea: 983c         	ldr	r0, [sp, #0xf0]
700996ec: 3001         	adds	r0, #0x1
700996ee: 903c         	str	r0, [sp, #0xf0]
;         break;
700996f0: e183         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x306
;         if (*format == 'F') flags |= FLAGS_UPPERCASE;
700996f2: 983c         	ldr	r0, [sp, #0xf0]
700996f4: 7800         	ldrb	r0, [r0]
700996f6: 2846         	cmp	r0, #0x46
700996f8: d105         	bne	0x70099706 <_vsnprintf+0x706> @ imm = #0xa
700996fa: e7ff         	b	0x700996fc <_vsnprintf+0x6fc> @ imm = #-0x2
700996fc: 983b         	ldr	r0, [sp, #0xec]
700996fe: f040 0020    	orr	r0, r0, #0x20
70099702: 903b         	str	r0, [sp, #0xec]
70099704: e7ff         	b	0x70099706 <_vsnprintf+0x706> @ imm = #-0x2
;         idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
70099706: 983f         	ldr	r0, [sp, #0xfc]
70099708: 993e         	ldr	r1, [sp, #0xf8]
7009970a: 9a37         	ldr	r2, [sp, #0xdc]
7009970c: 9b3d         	ldr	r3, [sp, #0xf4]
7009970e: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099712: f10c 0c07    	add.w	r12, r12, #0x7
70099716: f02c 0c07    	bic	r12, r12, #0x7
7009971a: f10c 0e08    	add.w	lr, r12, #0x8
7009971e: f8cd e100    	str.w	lr, [sp, #0x100]
70099722: ed9c 0b00    	vldr	d0, [r12]
70099726: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
7009972a: 9c3a         	ldr	r4, [sp, #0xe8]
7009972c: 9d3b         	ldr	r5, [sp, #0xec]
7009972e: 46ee         	mov	lr, sp
70099730: f8ce 5008    	str.w	r5, [lr, #0x8]
70099734: f8ce 4004    	str.w	r4, [lr, #0x4]
70099738: f8ce c000    	str.w	r12, [lr]
7009973c: f000 fc80    	bl	0x7009a040 <_ftoa>      @ imm = #0x900
70099740: 9037         	str	r0, [sp, #0xdc]
;         format++;
70099742: 983c         	ldr	r0, [sp, #0xf0]
70099744: 3001         	adds	r0, #0x1
70099746: 903c         	str	r0, [sp, #0xf0]
;         break;
70099748: e157         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x2ae
;         if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
7009974a: 983c         	ldr	r0, [sp, #0xf0]
7009974c: 7800         	ldrb	r0, [r0]
7009974e: 2867         	cmp	r0, #0x67
70099750: d005         	beq	0x7009975e <_vsnprintf+0x75e> @ imm = #0xa
70099752: e7ff         	b	0x70099754 <_vsnprintf+0x754> @ imm = #-0x2
70099754: 983c         	ldr	r0, [sp, #0xf0]
70099756: 7800         	ldrb	r0, [r0]
70099758: 2847         	cmp	r0, #0x47
7009975a: d105         	bne	0x70099768 <_vsnprintf+0x768> @ imm = #0xa
7009975c: e7ff         	b	0x7009975e <_vsnprintf+0x75e> @ imm = #-0x2
7009975e: 983b         	ldr	r0, [sp, #0xec]
70099760: f440 6000    	orr	r0, r0, #0x800
70099764: 903b         	str	r0, [sp, #0xec]
70099766: e7ff         	b	0x70099768 <_vsnprintf+0x768> @ imm = #-0x2
;         if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
70099768: 983c         	ldr	r0, [sp, #0xf0]
7009976a: 7800         	ldrb	r0, [r0]
7009976c: 2845         	cmp	r0, #0x45
7009976e: d005         	beq	0x7009977c <_vsnprintf+0x77c> @ imm = #0xa
70099770: e7ff         	b	0x70099772 <_vsnprintf+0x772> @ imm = #-0x2
70099772: 983c         	ldr	r0, [sp, #0xf0]
70099774: 7800         	ldrb	r0, [r0]
70099776: 2847         	cmp	r0, #0x47
70099778: d105         	bne	0x70099786 <_vsnprintf+0x786> @ imm = #0xa
7009977a: e7ff         	b	0x7009977c <_vsnprintf+0x77c> @ imm = #-0x2
7009977c: 983b         	ldr	r0, [sp, #0xec]
7009977e: f040 0020    	orr	r0, r0, #0x20
70099782: 903b         	str	r0, [sp, #0xec]
70099784: e7ff         	b	0x70099786 <_vsnprintf+0x786> @ imm = #-0x2
;         idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
70099786: 983f         	ldr	r0, [sp, #0xfc]
70099788: 993e         	ldr	r1, [sp, #0xf8]
7009978a: 9a37         	ldr	r2, [sp, #0xdc]
7009978c: 9b3d         	ldr	r3, [sp, #0xf4]
7009978e: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099792: f10c 0c07    	add.w	r12, r12, #0x7
70099796: f02c 0c07    	bic	r12, r12, #0x7
7009979a: f10c 0e08    	add.w	lr, r12, #0x8
7009979e: f8cd e100    	str.w	lr, [sp, #0x100]
700997a2: ed9c 0b00    	vldr	d0, [r12]
700997a6: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
700997aa: 9c3a         	ldr	r4, [sp, #0xe8]
700997ac: 9d3b         	ldr	r5, [sp, #0xec]
700997ae: 46ee         	mov	lr, sp
700997b0: f8ce 5008    	str.w	r5, [lr, #0x8]
700997b4: f8ce 4004    	str.w	r4, [lr, #0x4]
700997b8: f8ce c000    	str.w	r12, [lr]
700997bc: f000 fed0    	bl	0x7009a560 <_etoa>      @ imm = #0xda0
700997c0: 9037         	str	r0, [sp, #0xdc]
;         format++;
700997c2: 983c         	ldr	r0, [sp, #0xf0]
700997c4: 3001         	adds	r0, #0x1
700997c6: 903c         	str	r0, [sp, #0xf0]
;         break;
700997c8: e117         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x22e
700997ca: 2001         	movs	r0, #0x1
;         unsigned int l = 1U;
700997cc: 902e         	str	r0, [sp, #0xb8]
;         if (!(flags & FLAGS_LEFT)) {
700997ce: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
700997d2: 0780         	lsls	r0, r0, #0x1e
700997d4: 2800         	cmp	r0, #0x0
700997d6: d413         	bmi	0x70099800 <_vsnprintf+0x800> @ imm = #0x26
700997d8: e7ff         	b	0x700997da <_vsnprintf+0x7da> @ imm = #-0x2
;           while (l++ < width) {
700997da: e7ff         	b	0x700997dc <_vsnprintf+0x7dc> @ imm = #-0x2
700997dc: 982e         	ldr	r0, [sp, #0xb8]
700997de: 1c41         	adds	r1, r0, #0x1
700997e0: 912e         	str	r1, [sp, #0xb8]
700997e2: 993a         	ldr	r1, [sp, #0xe8]
700997e4: 4288         	cmp	r0, r1
700997e6: d20a         	bhs	0x700997fe <_vsnprintf+0x7fe> @ imm = #0x14
700997e8: e7ff         	b	0x700997ea <_vsnprintf+0x7ea> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
700997ea: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700997ee: 993e         	ldr	r1, [sp, #0xf8]
700997f0: 9a37         	ldr	r2, [sp, #0xdc]
700997f2: 1c50         	adds	r0, r2, #0x1
700997f4: 9037         	str	r0, [sp, #0xdc]
700997f6: 9b3d         	ldr	r3, [sp, #0xf4]
700997f8: 2020         	movs	r0, #0x20
700997fa: 47e0         	blx	r12
;           while (l++ < width) {
700997fc: e7ee         	b	0x700997dc <_vsnprintf+0x7dc> @ imm = #-0x24
;         }
700997fe: e7ff         	b	0x70099800 <_vsnprintf+0x800> @ imm = #-0x2
;         out((char)va_arg(va, int), buffer, idx++, maxlen);
70099800: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099804: 9840         	ldr	r0, [sp, #0x100]
70099806: 1d01         	adds	r1, r0, #0x4
70099808: 9140         	str	r1, [sp, #0x100]
7009980a: 7800         	ldrb	r0, [r0]
7009980c: 993e         	ldr	r1, [sp, #0xf8]
7009980e: 9a37         	ldr	r2, [sp, #0xdc]
70099810: 1c53         	adds	r3, r2, #0x1
70099812: 9337         	str	r3, [sp, #0xdc]
70099814: 9b3d         	ldr	r3, [sp, #0xf4]
70099816: 47e0         	blx	r12
;         if (flags & FLAGS_LEFT) {
70099818: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009981c: 0780         	lsls	r0, r0, #0x1e
7009981e: 2800         	cmp	r0, #0x0
70099820: d513         	bpl	0x7009984a <_vsnprintf+0x84a> @ imm = #0x26
70099822: e7ff         	b	0x70099824 <_vsnprintf+0x824> @ imm = #-0x2
;           while (l++ < width) {
70099824: e7ff         	b	0x70099826 <_vsnprintf+0x826> @ imm = #-0x2
70099826: 982e         	ldr	r0, [sp, #0xb8]
70099828: 1c41         	adds	r1, r0, #0x1
7009982a: 912e         	str	r1, [sp, #0xb8]
7009982c: 993a         	ldr	r1, [sp, #0xe8]
7009982e: 4288         	cmp	r0, r1
70099830: d20a         	bhs	0x70099848 <_vsnprintf+0x848> @ imm = #0x14
70099832: e7ff         	b	0x70099834 <_vsnprintf+0x834> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
70099834: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099838: 993e         	ldr	r1, [sp, #0xf8]
7009983a: 9a37         	ldr	r2, [sp, #0xdc]
7009983c: 1c50         	adds	r0, r2, #0x1
7009983e: 9037         	str	r0, [sp, #0xdc]
70099840: 9b3d         	ldr	r3, [sp, #0xf4]
70099842: 2020         	movs	r0, #0x20
70099844: 47e0         	blx	r12
;           while (l++ < width) {
70099846: e7ee         	b	0x70099826 <_vsnprintf+0x826> @ imm = #-0x24
;         }
70099848: e7ff         	b	0x7009984a <_vsnprintf+0x84a> @ imm = #-0x2
;         format++;
7009984a: 983c         	ldr	r0, [sp, #0xf0]
7009984c: 3001         	adds	r0, #0x1
7009984e: 903c         	str	r0, [sp, #0xf0]
;         break;
70099850: e0d3         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x1a6
;         const char* p = va_arg(va, char*);
70099852: 9840         	ldr	r0, [sp, #0x100]
70099854: 1d01         	adds	r1, r0, #0x4
70099856: 9140         	str	r1, [sp, #0x100]
70099858: 6800         	ldr	r0, [r0]
7009985a: 902d         	str	r0, [sp, #0xb4]
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
7009985c: 982d         	ldr	r0, [sp, #0xb4]
7009985e: 9010         	str	r0, [sp, #0x40]
70099860: 9839         	ldr	r0, [sp, #0xe4]
70099862: b118         	cbz	r0, 0x7009986c <_vsnprintf+0x86c> @ imm = #0x6
70099864: e7ff         	b	0x70099866 <_vsnprintf+0x866> @ imm = #-0x2
70099866: 9839         	ldr	r0, [sp, #0xe4]
70099868: 900f         	str	r0, [sp, #0x3c]
7009986a: e003         	b	0x70099874 <_vsnprintf+0x874> @ imm = #0x6
7009986c: f04f 30ff    	mov.w	r0, #0xffffffff
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
70099870: 900f         	str	r0, [sp, #0x3c]
70099872: e7ff         	b	0x70099874 <_vsnprintf+0x874> @ imm = #-0x2
70099874: 9810         	ldr	r0, [sp, #0x40]
70099876: 990f         	ldr	r1, [sp, #0x3c]
70099878: f011 ff9a    	bl	0x700ab7b0 <_strnlen_s> @ imm = #0x11f34
7009987c: 902c         	str	r0, [sp, #0xb0]
;         if (flags & FLAGS_PRECISION) {
7009987e: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
70099882: 0740         	lsls	r0, r0, #0x1d
70099884: 2800         	cmp	r0, #0x0
70099886: d50e         	bpl	0x700998a6 <_vsnprintf+0x8a6> @ imm = #0x1c
70099888: e7ff         	b	0x7009988a <_vsnprintf+0x88a> @ imm = #-0x2
;           l = (l < precision ? l : precision);
7009988a: 982c         	ldr	r0, [sp, #0xb0]
7009988c: 9939         	ldr	r1, [sp, #0xe4]
7009988e: 4288         	cmp	r0, r1
70099890: d203         	bhs	0x7009989a <_vsnprintf+0x89a> @ imm = #0x6
70099892: e7ff         	b	0x70099894 <_vsnprintf+0x894> @ imm = #-0x2
70099894: 982c         	ldr	r0, [sp, #0xb0]
70099896: 900e         	str	r0, [sp, #0x38]
70099898: e002         	b	0x700998a0 <_vsnprintf+0x8a0> @ imm = #0x4
7009989a: 9839         	ldr	r0, [sp, #0xe4]
7009989c: 900e         	str	r0, [sp, #0x38]
7009989e: e7ff         	b	0x700998a0 <_vsnprintf+0x8a0> @ imm = #-0x2
700998a0: 980e         	ldr	r0, [sp, #0x38]
700998a2: 902c         	str	r0, [sp, #0xb0]
;         }
700998a4: e7ff         	b	0x700998a6 <_vsnprintf+0x8a6> @ imm = #-0x2
;         if (!(flags & FLAGS_LEFT)) {
700998a6: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
700998aa: 0780         	lsls	r0, r0, #0x1e
700998ac: 2800         	cmp	r0, #0x0
700998ae: d413         	bmi	0x700998d8 <_vsnprintf+0x8d8> @ imm = #0x26
700998b0: e7ff         	b	0x700998b2 <_vsnprintf+0x8b2> @ imm = #-0x2
;           while (l++ < width) {
700998b2: e7ff         	b	0x700998b4 <_vsnprintf+0x8b4> @ imm = #-0x2
700998b4: 982c         	ldr	r0, [sp, #0xb0]
700998b6: 1c41         	adds	r1, r0, #0x1
700998b8: 912c         	str	r1, [sp, #0xb0]
700998ba: 993a         	ldr	r1, [sp, #0xe8]
700998bc: 4288         	cmp	r0, r1
700998be: d20a         	bhs	0x700998d6 <_vsnprintf+0x8d6> @ imm = #0x14
700998c0: e7ff         	b	0x700998c2 <_vsnprintf+0x8c2> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
700998c2: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700998c6: 993e         	ldr	r1, [sp, #0xf8]
700998c8: 9a37         	ldr	r2, [sp, #0xdc]
700998ca: 1c50         	adds	r0, r2, #0x1
700998cc: 9037         	str	r0, [sp, #0xdc]
700998ce: 9b3d         	ldr	r3, [sp, #0xf4]
700998d0: 2020         	movs	r0, #0x20
700998d2: 47e0         	blx	r12
;           while (l++ < width) {
700998d4: e7ee         	b	0x700998b4 <_vsnprintf+0x8b4> @ imm = #-0x24
;         }
700998d6: e7ff         	b	0x700998d8 <_vsnprintf+0x8d8> @ imm = #-0x2
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
700998d8: e7ff         	b	0x700998da <_vsnprintf+0x8da> @ imm = #-0x2
700998da: 982d         	ldr	r0, [sp, #0xb4]
700998dc: 7801         	ldrb	r1, [r0]
700998de: 2000         	movs	r0, #0x0
700998e0: 900d         	str	r0, [sp, #0x34]
700998e2: b1a1         	cbz	r1, 0x7009990e <_vsnprintf+0x90e> @ imm = #0x28
700998e4: e7ff         	b	0x700998e6 <_vsnprintf+0x8e6> @ imm = #-0x2
700998e6: 2001         	movs	r0, #0x1
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
700998e8: f89d 10ed    	ldrb.w	r1, [sp, #0xed]
700998ec: ea4f 7141    	lsl.w	r1, r1, #0x1d
700998f0: 2900         	cmp	r1, #0x0
700998f2: 900c         	str	r0, [sp, #0x30]
700998f4: d508         	bpl	0x70099908 <_vsnprintf+0x908> @ imm = #0x10
700998f6: e7ff         	b	0x700998f8 <_vsnprintf+0x8f8> @ imm = #-0x2
700998f8: 9839         	ldr	r0, [sp, #0xe4]
700998fa: 1e41         	subs	r1, r0, #0x1
700998fc: 9139         	str	r1, [sp, #0xe4]
700998fe: 2800         	cmp	r0, #0x0
70099900: bf18         	it	ne
70099902: 2001         	movne	r0, #0x1
70099904: 900c         	str	r0, [sp, #0x30]
70099906: e7ff         	b	0x70099908 <_vsnprintf+0x908> @ imm = #-0x2
70099908: 980c         	ldr	r0, [sp, #0x30]
7009990a: 900d         	str	r0, [sp, #0x34]
7009990c: e7ff         	b	0x7009990e <_vsnprintf+0x90e> @ imm = #-0x2
7009990e: 980d         	ldr	r0, [sp, #0x34]
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
70099910: 07c0         	lsls	r0, r0, #0x1f
70099912: b168         	cbz	r0, 0x70099930 <_vsnprintf+0x930> @ imm = #0x1a
70099914: e7ff         	b	0x70099916 <_vsnprintf+0x916> @ imm = #-0x2
;           out(*(p++), buffer, idx++, maxlen);
70099916: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009991a: 982d         	ldr	r0, [sp, #0xb4]
7009991c: 1c41         	adds	r1, r0, #0x1
7009991e: 912d         	str	r1, [sp, #0xb4]
70099920: 7800         	ldrb	r0, [r0]
70099922: 993e         	ldr	r1, [sp, #0xf8]
70099924: 9a37         	ldr	r2, [sp, #0xdc]
70099926: 1c53         	adds	r3, r2, #0x1
70099928: 9337         	str	r3, [sp, #0xdc]
7009992a: 9b3d         	ldr	r3, [sp, #0xf4]
7009992c: 47e0         	blx	r12
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009992e: e7d4         	b	0x700998da <_vsnprintf+0x8da> @ imm = #-0x58
;         if (flags & FLAGS_LEFT) {
70099930: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
70099934: 0780         	lsls	r0, r0, #0x1e
70099936: 2800         	cmp	r0, #0x0
70099938: d513         	bpl	0x70099962 <_vsnprintf+0x962> @ imm = #0x26
7009993a: e7ff         	b	0x7009993c <_vsnprintf+0x93c> @ imm = #-0x2
;           while (l++ < width) {
7009993c: e7ff         	b	0x7009993e <_vsnprintf+0x93e> @ imm = #-0x2
7009993e: 982c         	ldr	r0, [sp, #0xb0]
70099940: 1c41         	adds	r1, r0, #0x1
70099942: 912c         	str	r1, [sp, #0xb0]
70099944: 993a         	ldr	r1, [sp, #0xe8]
70099946: 4288         	cmp	r0, r1
70099948: d20a         	bhs	0x70099960 <_vsnprintf+0x960> @ imm = #0x14
7009994a: e7ff         	b	0x7009994c <_vsnprintf+0x94c> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009994c: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099950: 993e         	ldr	r1, [sp, #0xf8]
70099952: 9a37         	ldr	r2, [sp, #0xdc]
70099954: 1c50         	adds	r0, r2, #0x1
70099956: 9037         	str	r0, [sp, #0xdc]
70099958: 9b3d         	ldr	r3, [sp, #0xf4]
7009995a: 2020         	movs	r0, #0x20
7009995c: 47e0         	blx	r12
;           while (l++ < width) {
7009995e: e7ee         	b	0x7009993e <_vsnprintf+0x93e> @ imm = #-0x24
;         }
70099960: e7ff         	b	0x70099962 <_vsnprintf+0x962> @ imm = #-0x2
;         format++;
70099962: 983c         	ldr	r0, [sp, #0xf0]
70099964: 3001         	adds	r0, #0x1
70099966: 903c         	str	r0, [sp, #0xf0]
;         break;
70099968: e047         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x8e
7009996a: 2008         	movs	r0, #0x8
;         width = sizeof(void*) * 2U;
7009996c: 903a         	str	r0, [sp, #0xe8]
;         flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
7009996e: 983b         	ldr	r0, [sp, #0xec]
70099970: f040 0021    	orr	r0, r0, #0x21
70099974: 903b         	str	r0, [sp, #0xec]
70099976: 2400         	movs	r4, #0x0
;         const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
70099978: f88d 40af    	strb.w	r4, [sp, #0xaf]
;           idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
7009997c: 983f         	ldr	r0, [sp, #0xfc]
7009997e: 993e         	ldr	r1, [sp, #0xf8]
70099980: 9a37         	ldr	r2, [sp, #0xdc]
70099982: 9b3d         	ldr	r3, [sp, #0xf4]
70099984: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099988: f10c 0e04    	add.w	lr, r12, #0x4
7009998c: f8cd e100    	str.w	lr, [sp, #0x100]
70099990: f8dc c000    	ldr.w	r12, [r12]
70099994: 9d39         	ldr	r5, [sp, #0xe4]
70099996: 9e3a         	ldr	r6, [sp, #0xe8]
70099998: 9f3b         	ldr	r7, [sp, #0xec]
7009999a: 46ee         	mov	lr, sp
7009999c: f8ce 7014    	str.w	r7, [lr, #0x14]
700999a0: f8ce 6010    	str.w	r6, [lr, #0x10]
700999a4: f8ce 500c    	str.w	r5, [lr, #0xc]
700999a8: 2510         	movs	r5, #0x10
700999aa: f8ce 5008    	str.w	r5, [lr, #0x8]
700999ae: f8ce 4004    	str.w	r4, [lr, #0x4]
700999b2: f8ce c000    	str.w	r12, [lr]
700999b6: f009 fbd3    	bl	0x700a3160 <_ntoa_long> @ imm = #0x97a6
700999ba: 9037         	str	r0, [sp, #0xdc]
;         format++;
700999bc: 983c         	ldr	r0, [sp, #0xf0]
700999be: 3001         	adds	r0, #0x1
700999c0: 903c         	str	r0, [sp, #0xf0]
;         break;
700999c2: e01a         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x34
;         out('%', buffer, idx++, maxlen);
700999c4: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700999c8: 993e         	ldr	r1, [sp, #0xf8]
700999ca: 9a37         	ldr	r2, [sp, #0xdc]
700999cc: 1c50         	adds	r0, r2, #0x1
700999ce: 9037         	str	r0, [sp, #0xdc]
700999d0: 9b3d         	ldr	r3, [sp, #0xf4]
700999d2: 2025         	movs	r0, #0x25
700999d4: 47e0         	blx	r12
;         format++;
700999d6: 983c         	ldr	r0, [sp, #0xf0]
700999d8: 3001         	adds	r0, #0x1
700999da: 903c         	str	r0, [sp, #0xf0]
;         break;
700999dc: e00d         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x1a
;         out(*format, buffer, idx++, maxlen);
700999de: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700999e2: 983c         	ldr	r0, [sp, #0xf0]
700999e4: 7800         	ldrb	r0, [r0]
700999e6: 993e         	ldr	r1, [sp, #0xf8]
700999e8: 9a37         	ldr	r2, [sp, #0xdc]
700999ea: 1c53         	adds	r3, r2, #0x1
700999ec: 9337         	str	r3, [sp, #0xdc]
700999ee: 9b3d         	ldr	r3, [sp, #0xf4]
700999f0: 47e0         	blx	r12
;         format++;
700999f2: 983c         	ldr	r0, [sp, #0xf0]
700999f4: 3001         	adds	r0, #0x1
700999f6: 903c         	str	r0, [sp, #0xf0]
;         break;
700999f8: e7ff         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #-0x2
;   while (*format)
700999fa: f7ff bb18    	b.w	0x7009902e <_vsnprintf+0x2e> @ imm = #-0x9d0
;   out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
700999fe: 983f         	ldr	r0, [sp, #0xfc]
70099a00: 900a         	str	r0, [sp, #0x28]
70099a02: 983e         	ldr	r0, [sp, #0xf8]
70099a04: 900b         	str	r0, [sp, #0x2c]
70099a06: 9837         	ldr	r0, [sp, #0xdc]
70099a08: 993d         	ldr	r1, [sp, #0xf4]
70099a0a: 4288         	cmp	r0, r1
70099a0c: d203         	bhs	0x70099a16 <_vsnprintf+0xa16> @ imm = #0x6
70099a0e: e7ff         	b	0x70099a10 <_vsnprintf+0xa10> @ imm = #-0x2
70099a10: 9837         	ldr	r0, [sp, #0xdc]
70099a12: 9009         	str	r0, [sp, #0x24]
70099a14: e003         	b	0x70099a1e <_vsnprintf+0xa1e> @ imm = #0x6
70099a16: 983d         	ldr	r0, [sp, #0xf4]
70099a18: 3801         	subs	r0, #0x1
70099a1a: 9009         	str	r0, [sp, #0x24]
70099a1c: e7ff         	b	0x70099a1e <_vsnprintf+0xa1e> @ imm = #-0x2
70099a1e: f8dd c028    	ldr.w	r12, [sp, #0x28]
70099a22: 990b         	ldr	r1, [sp, #0x2c]
70099a24: 9a09         	ldr	r2, [sp, #0x24]
70099a26: 9b3d         	ldr	r3, [sp, #0xf4]
70099a28: 2000         	movs	r0, #0x0
70099a2a: 47e0         	blx	r12
;   return (int)idx;
70099a2c: 9837         	ldr	r0, [sp, #0xdc]
70099a2e: b041         	add	sp, #0x104
70099a30: e8bd 83f0    	pop.w	{r4, r5, r6, r7, r8, r9, pc}

70099a34 <__aeabi_memclr8>:
70099a34: e1a02001     	mov	r2, r1
70099a38: e3b01000     	movs	r1, #0
70099a3c: ea004ea5     	b	0x700ad4d8 <TI_memset_small> @ imm = #0x13a94

70099a40 <Sciclient_rmIrqRouteValidate>:
; {
70099a40: b580         	push	{r7, lr}
70099a42: b09e         	sub	sp, #0x78
70099a44: 901d         	str	r0, [sp, #0x74]
70099a46: 2001         	movs	r0, #0x1
;     bool valid = true;
70099a48: f88d 0073    	strb.w	r0, [sp, #0x73]
70099a4c: 2000         	movs	r0, #0x0
;     const struct Sciclient_rmIrqNode *cur_n, *next_n = NULL;
70099a4e: 9009         	str	r0, [sp, #0x24]
70099a50: 9019         	str	r0, [sp, #0x64]
;     bool cur_outp_valid = false, next_inp_valid = false;
70099a52: f88d 005f    	strb.w	r0, [sp, #0x5f]
70099a56: f88d 005e    	strb.w	r0, [sp, #0x5e]
;     uint16_t cur_outp = 0, next_inp = 0;
70099a5a: f8ad 0056    	strh.w	r0, [sp, #0x56]
70099a5e: f8ad 0054    	strh.w	r0, [sp, #0x54]
;     struct tisci_msg_rm_get_resource_range_req req = {{0}};
70099a62: 9014         	str	r0, [sp, #0x50]
70099a64: 9013         	str	r0, [sp, #0x4c]
70099a66: 9012         	str	r0, [sp, #0x48]
;     struct tisci_msg_rm_get_resource_range_resp host_resp = {{0}};
70099a68: 9011         	str	r0, [sp, #0x44]
70099a6a: 9010         	str	r0, [sp, #0x40]
70099a6c: 900f         	str	r0, [sp, #0x3c]
70099a6e: 900e         	str	r0, [sp, #0x38]
;     struct tisci_msg_rm_get_resource_range_resp all_resp = {{0}};
70099a70: 900d         	str	r0, [sp, #0x34]
70099a72: 900c         	str	r0, [sp, #0x30]
70099a74: 900b         	str	r0, [sp, #0x2c]
70099a76: 900a         	str	r0, [sp, #0x28]
;     if (cfg->s_ia == SCICLIENT_RM_DEV_NONE) {
70099a78: 981d         	ldr	r0, [sp, #0x74]
70099a7a: 8a00         	ldrh	r0, [r0, #0x10]
70099a7c: 28ff         	cmp	r0, #0xff
70099a7e: d12c         	bne	0x70099ada <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #0x58
70099a80: e7ff         	b	0x70099a82 <Sciclient_rmIrqRouteValidate+0x42> @ imm = #-0x2
70099a82: 2000         	movs	r0, #0x0
;         cur_n = Sciclient_rmPsGetIrqNode(0u);
70099a84: f013 fb9c    	bl	0x700ad1c0 <Sciclient_rmPsGetIrqNode> @ imm = #0x13738
70099a88: 901a         	str	r0, [sp, #0x68]
;         if (cur_n == NULL) {
70099a8a: 981a         	ldr	r0, [sp, #0x68]
70099a8c: b920         	cbnz	r0, 0x70099a98 <Sciclient_rmIrqRouteValidate+0x58> @ imm = #0x8
70099a8e: e7ff         	b	0x70099a90 <Sciclient_rmIrqRouteValidate+0x50> @ imm = #-0x2
70099a90: 2000         	movs	r0, #0x0
;             valid = false;
70099a92: f88d 0073    	strb.w	r0, [sp, #0x73]
;         } else {
70099a96: e01f         	b	0x70099ad8 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #0x3e
;             cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(0u)];
70099a98: 981a         	ldr	r0, [sp, #0x68]
70099a9a: 6840         	ldr	r0, [r0, #0x4]
70099a9c: 9008         	str	r0, [sp, #0x20]
70099a9e: 2000         	movs	r0, #0x0
70099aa0: f011 ffde    	bl	0x700aba60 <Sciclient_rmPsGetIfIdx> @ imm = #0x11fbc
70099aa4: 4601         	mov	r1, r0
70099aa6: 9808         	ldr	r0, [sp, #0x20]
70099aa8: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
70099aac: 9018         	str	r0, [sp, #0x60]
;             if ((cfg->s_idx < cur_if->lbase) ||
70099aae: 981d         	ldr	r0, [sp, #0x74]
70099ab0: 8900         	ldrh	r0, [r0, #0x8]
70099ab2: 9918         	ldr	r1, [sp, #0x60]
70099ab4: 8809         	ldrh	r1, [r1]
70099ab6: 4288         	cmp	r0, r1
70099ab8: db09         	blt	0x70099ace <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #0x12
70099aba: e7ff         	b	0x70099abc <Sciclient_rmIrqRouteValidate+0x7c> @ imm = #-0x2
;                 (cfg->s_idx >= (cur_if->lbase + cur_if->len))) {
70099abc: 981d         	ldr	r0, [sp, #0x74]
70099abe: 8900         	ldrh	r0, [r0, #0x8]
70099ac0: 9a18         	ldr	r2, [sp, #0x60]
70099ac2: 8811         	ldrh	r1, [r2]
70099ac4: 8892         	ldrh	r2, [r2, #0x4]
70099ac6: 4411         	add	r1, r2
;             if ((cfg->s_idx < cur_if->lbase) ||
70099ac8: 4288         	cmp	r0, r1
70099aca: db04         	blt	0x70099ad6 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #0x8
70099acc: e7ff         	b	0x70099ace <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #-0x2
70099ace: 2000         	movs	r0, #0x0
;                 valid = false;
70099ad0: f88d 0073    	strb.w	r0, [sp, #0x73]
;             }
70099ad4: e7ff         	b	0x70099ad6 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #-0x2
70099ad6: e7ff         	b	0x70099ad8 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #-0x2
;     }
70099ad8: e7ff         	b	0x70099ada <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #-0x2
;     if ((valid == true) &&
70099ada: f89d 0073    	ldrb.w	r0, [sp, #0x73]
70099ade: 07c0         	lsls	r0, r0, #0x1f
70099ae0: b148         	cbz	r0, 0x70099af6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x12
70099ae2: e7ff         	b	0x70099ae4 <Sciclient_rmIrqRouteValidate+0xa4> @ imm = #-0x2
;         (Sciclient_rmPsGetPsp() <= 1U)) {
70099ae4: f013 ff74    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0x13ee8
;     if ((valid == true) &&
70099ae8: 2801         	cmp	r0, #0x1
70099aea: d804         	bhi	0x70099af6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x8
70099aec: e7ff         	b	0x70099aee <Sciclient_rmIrqRouteValidate+0xae> @ imm = #-0x2
70099aee: 2000         	movs	r0, #0x0
;         valid = false;
70099af0: f88d 0073    	strb.w	r0, [sp, #0x73]
;     }
70099af4: e7ff         	b	0x70099af6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #-0x2
;     if (valid == true) {
70099af6: f89d 0073    	ldrb.w	r0, [sp, #0x73]
70099afa: 07c0         	lsls	r0, r0, #0x1f
70099afc: b150         	cbz	r0, 0x70099b14 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #0x14
70099afe: e7ff         	b	0x70099b00 <Sciclient_rmIrqRouteValidate+0xc0> @ imm = #-0x2
;         if (Sciclient_rmIrqCheckLoop(cfg) == true) {
70099b00: 981d         	ldr	r0, [sp, #0x74]
70099b02: f00c fdd5    	bl	0x700a66b0 <Sciclient_rmIrqCheckLoop> @ imm = #0xcbaa
70099b06: b120         	cbz	r0, 0x70099b12 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #0x8
70099b08: e7ff         	b	0x70099b0a <Sciclient_rmIrqRouteValidate+0xca> @ imm = #-0x2
70099b0a: 2000         	movs	r0, #0x0
;             valid = false;
70099b0c: f88d 0073    	strb.w	r0, [sp, #0x73]
;         }
70099b10: e7ff         	b	0x70099b12 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #-0x2
;     }
70099b12: e7ff         	b	0x70099b14 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #-0x2
70099b14: 2000         	movs	r0, #0x0
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
70099b16: f8ad 0070    	strh.w	r0, [sp, #0x70]
70099b1a: e7ff         	b	0x70099b1c <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x2
70099b1c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099b20: 9006         	str	r0, [sp, #0x18]
70099b22: f013 ff55    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0x13eaa
70099b26: 9906         	ldr	r1, [sp, #0x18]
70099b28: 4602         	mov	r2, r0
70099b2a: 2000         	movs	r0, #0x0
70099b2c: 4291         	cmp	r1, r2
70099b2e: 9007         	str	r0, [sp, #0x1c]
70099b30: da06         	bge	0x70099b40 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #0xc
70099b32: e7ff         	b	0x70099b34 <Sciclient_rmIrqRouteValidate+0xf4> @ imm = #-0x2
70099b34: f89d 0073    	ldrb.w	r0, [sp, #0x73]
70099b38: f000 0001    	and	r0, r0, #0x1
70099b3c: 9007         	str	r0, [sp, #0x1c]
70099b3e: e7ff         	b	0x70099b40 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #-0x2
70099b40: 9807         	ldr	r0, [sp, #0x1c]
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
70099b42: 07c0         	lsls	r0, r0, #0x1f
70099b44: 2800         	cmp	r0, #0x0
70099b46: f000 826f    	beq.w	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x4de
70099b4a: e7ff         	b	0x70099b4c <Sciclient_rmIrqRouteValidate+0x10c> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
70099b4c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099b50: f013 fb36    	bl	0x700ad1c0 <Sciclient_rmPsGetIrqNode> @ imm = #0x1366c
70099b54: 901a         	str	r0, [sp, #0x68]
;         cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(i)];
70099b56: 981a         	ldr	r0, [sp, #0x68]
70099b58: 6840         	ldr	r0, [r0, #0x4]
70099b5a: 9004         	str	r0, [sp, #0x10]
70099b5c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099b60: f011 ff7e    	bl	0x700aba60 <Sciclient_rmPsGetIfIdx> @ imm = #0x11efc
70099b64: 4601         	mov	r1, r0
70099b66: 9804         	ldr	r0, [sp, #0x10]
70099b68: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
70099b6c: 9018         	str	r0, [sp, #0x60]
;         if (i < (Sciclient_rmPsGetPsp() - 1u)) {
70099b6e: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099b72: 9005         	str	r0, [sp, #0x14]
70099b74: f013 ff2c    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0x13e58
70099b78: 4601         	mov	r1, r0
70099b7a: 9805         	ldr	r0, [sp, #0x14]
70099b7c: 3901         	subs	r1, #0x1
70099b7e: 4288         	cmp	r0, r1
70099b80: d20f         	bhs	0x70099ba2 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #0x1e
70099b82: e7ff         	b	0x70099b84 <Sciclient_rmIrqRouteValidate+0x144> @ imm = #-0x2
;             next_n = Sciclient_rmPsGetIrqNode(i + 1u);
70099b84: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099b88: 3001         	adds	r0, #0x1
70099b8a: b280         	uxth	r0, r0
70099b8c: f013 fb18    	bl	0x700ad1c0 <Sciclient_rmPsGetIrqNode> @ imm = #0x13630
70099b90: 9019         	str	r0, [sp, #0x64]
;             if (next_n == NULL) {
70099b92: 9819         	ldr	r0, [sp, #0x64]
70099b94: b920         	cbnz	r0, 0x70099ba0 <Sciclient_rmIrqRouteValidate+0x160> @ imm = #0x8
70099b96: e7ff         	b	0x70099b98 <Sciclient_rmIrqRouteValidate+0x158> @ imm = #-0x2
70099b98: 2000         	movs	r0, #0x0
;                 valid = false;
70099b9a: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099b9e: e243         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x486
;         }
70099ba0: e7ff         	b	0x70099ba2 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #-0x2
;         if (i > 0u) {
70099ba2: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099ba6: b158         	cbz	r0, 0x70099bc0 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #0x16
70099ba8: e7ff         	b	0x70099baa <Sciclient_rmIrqRouteValidate+0x16a> @ imm = #-0x2
;             if (Sciclient_rmIrIsIr(cur_n->id) != true) {
70099baa: 981a         	ldr	r0, [sp, #0x68]
70099bac: 8800         	ldrh	r0, [r0]
70099bae: f012 fdbf    	bl	0x700ac730 <Sciclient_rmIrIsIr> @ imm = #0x12b7e
70099bb2: b920         	cbnz	r0, 0x70099bbe <Sciclient_rmIrqRouteValidate+0x17e> @ imm = #0x8
70099bb4: e7ff         	b	0x70099bb6 <Sciclient_rmIrqRouteValidate+0x176> @ imm = #-0x2
70099bb6: 2000         	movs	r0, #0x0
;                 valid = false;
70099bb8: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099bbc: e234         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x468
;         }
70099bbe: e7ff         	b	0x70099bc0 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #-0x2
;         if ((i == 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
70099bc0: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099bc4: 2800         	cmp	r0, #0x0
70099bc6: f040 8080    	bne.w	0x70099cca <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0x100
70099bca: e7ff         	b	0x70099bcc <Sciclient_rmIrqRouteValidate+0x18c> @ imm = #-0x2
70099bcc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099bd0: 9003         	str	r0, [sp, #0xc]
70099bd2: f013 fefd    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0x13dfa
70099bd6: 4601         	mov	r1, r0
70099bd8: 9803         	ldr	r0, [sp, #0xc]
70099bda: 3901         	subs	r1, #0x1
70099bdc: 4288         	cmp	r0, r1
70099bde: d274         	bhs	0x70099cca <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0xe8
70099be0: e7ff         	b	0x70099be2 <Sciclient_rmIrqRouteValidate+0x1a2> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cur_n->id) == true) {
70099be2: 981a         	ldr	r0, [sp, #0x68]
70099be4: 8800         	ldrh	r0, [r0]
70099be6: f012 fd8b    	bl	0x700ac700 <Sciclient_rmIaIsIa> @ imm = #0x12b16
70099bea: 2800         	cmp	r0, #0x0
70099bec: d049         	beq	0x70099c82 <Sciclient_rmIrqRouteValidate+0x242> @ imm = #0x92
70099bee: e7ff         	b	0x70099bf0 <Sciclient_rmIrqRouteValidate+0x1b0> @ imm = #-0x2
70099bf0: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
70099bf2: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
70099bf6: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cfg->vint,
70099bfa: 9a18         	ldr	r2, [sp, #0x60]
70099bfc: 8850         	ldrh	r0, [r2, #0x2]
70099bfe: 991d         	ldr	r1, [sp, #0x74]
70099c00: 8a49         	ldrh	r1, [r1, #0x12]
70099c02: 8812         	ldrh	r2, [r2]
70099c04: 1a89         	subs	r1, r1, r2
70099c06: 4408         	add	r0, r1
70099c08: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 cur_outp = cfg->vint;
70099c0c: 981d         	ldr	r0, [sp, #0x74]
70099c0e: 8a40         	ldrh	r0, [r0, #0x12]
70099c10: f8ad 0056    	strh.w	r0, [sp, #0x56]
70099c14: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
70099c16: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
70099c1a: 9819         	ldr	r0, [sp, #0x64]
70099c1c: b160         	cbz	r0, 0x70099c38 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x18
70099c1e: e7ff         	b	0x70099c20 <Sciclient_rmIrqRouteValidate+0x1e0> @ imm = #-0x2
70099c20: 9819         	ldr	r0, [sp, #0x64]
70099c22: 8800         	ldrh	r0, [r0]
70099c24: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099c28: f00a fc02    	bl	0x700a4430 <Sciclient_rmIrInpIsFree> @ imm = #0xa804
70099c2c: b920         	cbnz	r0, 0x70099c38 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x8
70099c2e: e7ff         	b	0x70099c30 <Sciclient_rmIrqRouteValidate+0x1f0> @ imm = #-0x2
70099c30: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
70099c32: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
70099c36: e7ff         	b	0x70099c38 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #-0x2
;                 if (Sciclient_rmParamIsValid(cfg->valid_params,
70099c38: 981d         	ldr	r0, [sp, #0x74]
70099c3a: 6800         	ldr	r0, [r0]
70099c3c: 2110         	movs	r1, #0x10
70099c3e: f012 ff57    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x12eae
70099c42: b1e8         	cbz	r0, 0x70099c80 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #0x3a
70099c44: e7ff         	b	0x70099c46 <Sciclient_rmIrqRouteValidate+0x206> @ imm = #-0x2
;                     cur_inp = cfg->global_evt;
70099c46: 981d         	ldr	r0, [sp, #0x74]
70099c48: 89c0         	ldrh	r0, [r0, #0xe]
70099c4a: 9016         	str	r0, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
70099c4c: 981a         	ldr	r0, [sp, #0x68]
70099c4e: 8800         	ldrh	r0, [r0]
;                                       cur_inp) ==
70099c50: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
70099c54: f010 fcbc    	bl	0x700aa5d0 <Sciclient_rmIaValidateGlobalEvt> @ imm = #0x10978
70099c58: b968         	cbnz	r0, 0x70099c76 <Sciclient_rmIrqRouteValidate+0x236> @ imm = #0x1a
70099c5a: e7ff         	b	0x70099c5c <Sciclient_rmIrqRouteValidate+0x21c> @ imm = #-0x2
;                         if (Sciclient_rmPsSetInp(i, cur_inp) != SystemP_SUCCESS) {
70099c5c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099c60: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
70099c64: f011 fa84    	bl	0x700ab170 <Sciclient_rmPsSetInp> @ imm = #0x11508
70099c68: b120         	cbz	r0, 0x70099c74 <Sciclient_rmIrqRouteValidate+0x234> @ imm = #0x8
70099c6a: e7ff         	b	0x70099c6c <Sciclient_rmIrqRouteValidate+0x22c> @ imm = #-0x2
70099c6c: 2000         	movs	r0, #0x0
;                             valid = false;
70099c6e: f88d 0073    	strb.w	r0, [sp, #0x73]
;                             break;
70099c72: e1d9         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3b2
;                     } else {
70099c74: e003         	b	0x70099c7e <Sciclient_rmIrqRouteValidate+0x23e> @ imm = #0x6
70099c76: 2000         	movs	r0, #0x0
;                         valid = false;
70099c78: f88d 0073    	strb.w	r0, [sp, #0x73]
;                         break;
70099c7c: e1d4         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3a8
;                 }
70099c7e: e7ff         	b	0x70099c80 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #-0x2
;             } else {
70099c80: e022         	b	0x70099cc8 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #0x44
70099c82: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
70099c84: f88d 005f    	strb.w	r0, [sp, #0x5f]
70099c88: 2000         	movs	r0, #0x0
;                 next_inp_valid = false;
70099c8a: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = cfg->s_idx;
70099c8e: 981d         	ldr	r0, [sp, #0x74]
70099c90: 8900         	ldrh	r0, [r0, #0x8]
70099c92: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
70099c96: 9a18         	ldr	r2, [sp, #0x60]
70099c98: 8850         	ldrh	r0, [r2, #0x2]
70099c9a: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099c9e: 8812         	ldrh	r2, [r2]
70099ca0: 1a89         	subs	r1, r1, r2
70099ca2: 4408         	add	r0, r1
70099ca4: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
70099ca8: 9819         	ldr	r0, [sp, #0x64]
70099caa: b160         	cbz	r0, 0x70099cc6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x18
70099cac: e7ff         	b	0x70099cae <Sciclient_rmIrqRouteValidate+0x26e> @ imm = #-0x2
70099cae: 9819         	ldr	r0, [sp, #0x64]
70099cb0: 8800         	ldrh	r0, [r0]
70099cb2: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099cb6: f00a fbbb    	bl	0x700a4430 <Sciclient_rmIrInpIsFree> @ imm = #0xa776
70099cba: b920         	cbnz	r0, 0x70099cc6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x8
70099cbc: e7ff         	b	0x70099cbe <Sciclient_rmIrqRouteValidate+0x27e> @ imm = #-0x2
70099cbe: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
70099cc0: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
70099cc4: e7ff         	b	0x70099cc6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #-0x2
70099cc6: e7ff         	b	0x70099cc8 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #-0x2
;         }
70099cc8: e7ff         	b	0x70099cca <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #-0x2
;         if ((i > 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
70099cca: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099cce: 2800         	cmp	r0, #0x0
70099cd0: f000 80c4    	beq.w	0x70099e5c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x188
70099cd4: e7ff         	b	0x70099cd6 <Sciclient_rmIrqRouteValidate+0x296> @ imm = #-0x2
70099cd6: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099cda: 9002         	str	r0, [sp, #0x8]
70099cdc: f013 fe78    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0x13cf0
70099ce0: 4601         	mov	r1, r0
70099ce2: 9802         	ldr	r0, [sp, #0x8]
70099ce4: 3901         	subs	r1, #0x1
70099ce6: 4288         	cmp	r0, r1
70099ce8: f080 80b8    	bhs.w	0x70099e5c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x170
70099cec: e7ff         	b	0x70099cee <Sciclient_rmIrqRouteValidate+0x2ae> @ imm = #-0x2
;             req.secondary_host = cfg->host;
70099cee: 981d         	ldr	r0, [sp, #0x74]
70099cf0: 7900         	ldrb	r0, [r0, #0x4]
70099cf2: f88d 0053    	strb.w	r0, [sp, #0x53]
;             req.type = cur_n->id;
70099cf6: 981a         	ldr	r0, [sp, #0x68]
70099cf8: 8800         	ldrh	r0, [r0]
70099cfa: f8ad 0050    	strh.w	r0, [sp, #0x50]
70099cfe: 2000         	movs	r0, #0x0
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
70099d00: f88d 0052    	strb.w	r0, [sp, #0x52]
70099d04: a812         	add	r0, sp, #0x48
70099d06: a90e         	add	r1, sp, #0x38
70099d08: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
70099d0c: f00f fb40    	bl	0x700a9390 <Sciclient_rmGetResourceRange> @ imm = #0xf680
70099d10: b120         	cbz	r0, 0x70099d1c <Sciclient_rmIrqRouteValidate+0x2dc> @ imm = #0x8
70099d12: e7ff         	b	0x70099d14 <Sciclient_rmIrqRouteValidate+0x2d4> @ imm = #-0x2
70099d14: 2000         	movs	r0, #0x0
;                 valid = false;
70099d16: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099d1a: e185         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30a
70099d1c: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
70099d1e: f88d 0053    	strb.w	r0, [sp, #0x53]
70099d22: a812         	add	r0, sp, #0x48
70099d24: a90a         	add	r1, sp, #0x28
70099d26: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
70099d2a: f00f fb31    	bl	0x700a9390 <Sciclient_rmGetResourceRange> @ imm = #0xf662
70099d2e: b120         	cbz	r0, 0x70099d3a <Sciclient_rmIrqRouteValidate+0x2fa> @ imm = #0x8
70099d30: e7ff         	b	0x70099d32 <Sciclient_rmIrqRouteValidate+0x2f2> @ imm = #-0x2
70099d32: 2000         	movs	r0, #0x0
;                 valid = false;
70099d34: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099d38: e176         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x2ec
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
70099d3a: 9818         	ldr	r0, [sp, #0x60]
70099d3c: 8800         	ldrh	r0, [r0]
70099d3e: f8ad 006e    	strh.w	r0, [sp, #0x6e]
70099d42: e7ff         	b	0x70099d44 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x2
70099d44: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
70099d48: 9a18         	ldr	r2, [sp, #0x60]
70099d4a: 8811         	ldrh	r1, [r2]
70099d4c: 8892         	ldrh	r2, [r2, #0x4]
70099d4e: 4411         	add	r1, r2
70099d50: 4288         	cmp	r0, r1
70099d52: f280 8082    	bge.w	0x70099e5a <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0x104
70099d56: e7ff         	b	0x70099d58 <Sciclient_rmIrqRouteValidate+0x318> @ imm = #-0x2
70099d58: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
70099d5a: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
70099d5e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = j;
70099d62: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
70099d66: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
70099d6a: 9a18         	ldr	r2, [sp, #0x60]
70099d6c: 8850         	ldrh	r0, [r2, #0x2]
70099d6e: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099d72: 8812         	ldrh	r2, [r2]
70099d74: 1a89         	subs	r1, r1, r2
70099d76: 4408         	add	r0, r1
70099d78: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((((cur_outp >= host_resp.range_start) &&
70099d7c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099d80: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099d84: 4288         	cmp	r0, r1
70099d86: db0a         	blt	0x70099d9e <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #0x14
70099d88: e7ff         	b	0x70099d8a <Sciclient_rmIrqRouteValidate+0x34a> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start + host_resp.range_num)) ||
70099d8a: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099d8e: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099d92: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
70099d96: 4411         	add	r1, r2
70099d98: 4288         	cmp	r0, r1
70099d9a: db33         	blt	0x70099e04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x66
70099d9c: e7ff         	b	0x70099d9e <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #-0x2
;                      ((cur_outp >= host_resp.range_start_sec) &&
70099d9e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099da2: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
70099da6: 4288         	cmp	r0, r1
70099da8: db0a         	blt	0x70099dc0 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #0x14
70099daa: e7ff         	b	0x70099dac <Sciclient_rmIrqRouteValidate+0x36c> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start_sec +
70099dac: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099db0: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                                   host_resp.range_num_sec))) ||
70099db4: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                       (cur_outp < host_resp.range_start_sec +
70099db8: 4411         	add	r1, r2
;                                   host_resp.range_num_sec))) ||
70099dba: 4288         	cmp	r0, r1
70099dbc: db22         	blt	0x70099e04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x44
70099dbe: e7ff         	b	0x70099dc0 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #-0x2
;                     (((cur_outp >= all_resp.range_start) &&
70099dc0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099dc4: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099dc8: 4288         	cmp	r0, r1
70099dca: db0a         	blt	0x70099de2 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #0x14
70099dcc: e7ff         	b	0x70099dce <Sciclient_rmIrqRouteValidate+0x38e> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start + all_resp.range_num)) ||
70099dce: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099dd2: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099dd6: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
70099dda: 4411         	add	r1, r2
70099ddc: 4288         	cmp	r0, r1
70099dde: db11         	blt	0x70099e04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x22
70099de0: e7ff         	b	0x70099de2 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #-0x2
;                      ((cur_outp >= all_resp.range_start_sec) &&
70099de2: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099de6: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
70099dea: 4288         	cmp	r0, r1
70099dec: db2e         	blt	0x70099e4c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x5c
70099dee: e7ff         	b	0x70099df0 <Sciclient_rmIrqRouteValidate+0x3b0> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start_sec +
70099df0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099df4: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                                   all_resp.range_num_sec)))) {
70099df8: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                       (cur_outp < all_resp.range_start_sec +
70099dfc: 4411         	add	r1, r2
;                 if ((((cur_outp >= host_resp.range_start) &&
70099dfe: 4288         	cmp	r0, r1
70099e00: da24         	bge	0x70099e4c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x48
70099e02: e7ff         	b	0x70099e04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
70099e04: 981a         	ldr	r0, [sp, #0x68]
70099e06: 8800         	ldrh	r0, [r0]
70099e08: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099e0c: f00d f8d0    	bl	0x700a6fb0 <Sciclient_rmIrOutpIsFree> @ imm = #0xd1a0
70099e10: b920         	cbnz	r0, 0x70099e1c <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #0x8
70099e12: e7ff         	b	0x70099e14 <Sciclient_rmIrqRouteValidate+0x3d4> @ imm = #-0x2
70099e14: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
70099e16: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
70099e1a: e7ff         	b	0x70099e1c <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #-0x2
;                     if (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
70099e1c: 9819         	ldr	r0, [sp, #0x64]
70099e1e: 8800         	ldrh	r0, [r0]
70099e20: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099e24: f00a fb04    	bl	0x700a4430 <Sciclient_rmIrInpIsFree> @ imm = #0xa608
70099e28: b920         	cbnz	r0, 0x70099e34 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #0x8
70099e2a: e7ff         	b	0x70099e2c <Sciclient_rmIrqRouteValidate+0x3ec> @ imm = #-0x2
70099e2c: 2001         	movs	r0, #0x1
;                         next_inp_valid = true;
70099e2e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                     }
70099e32: e7ff         	b	0x70099e34 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #-0x2
;                     if ((cur_outp_valid == true) &&
70099e34: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
70099e38: 07c0         	lsls	r0, r0, #0x1f
70099e3a: b130         	cbz	r0, 0x70099e4a <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0xc
70099e3c: e7ff         	b	0x70099e3e <Sciclient_rmIrqRouteValidate+0x3fe> @ imm = #-0x2
;                         (next_inp_valid == true)) {
70099e3e: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
;                     if ((cur_outp_valid == true) &&
70099e42: 07c0         	lsls	r0, r0, #0x1f
70099e44: b108         	cbz	r0, 0x70099e4a <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0x2
70099e46: e7ff         	b	0x70099e48 <Sciclient_rmIrqRouteValidate+0x408> @ imm = #-0x2
;                         break;
70099e48: e007         	b	0x70099e5a <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0xe
;                 }
70099e4a: e7ff         	b	0x70099e4c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #-0x2
;             }
70099e4c: e7ff         	b	0x70099e4e <Sciclient_rmIrqRouteValidate+0x40e> @ imm = #-0x2
;                  j++) {
70099e4e: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
70099e52: 3001         	adds	r0, #0x1
70099e54: f8ad 006e    	strh.w	r0, [sp, #0x6e]
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
70099e58: e774         	b	0x70099d44 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x118
;         }
70099e5a: e7ff         	b	0x70099e5c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #-0x2
;         if (i == (Sciclient_rmPsGetPsp() - 1u)) {
70099e5c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099e60: 9001         	str	r0, [sp, #0x4]
70099e62: f013 fdb5    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0x13b6a
70099e66: 4601         	mov	r1, r0
70099e68: 9801         	ldr	r0, [sp, #0x4]
70099e6a: 3901         	subs	r1, #0x1
70099e6c: 4288         	cmp	r0, r1
70099e6e: f040 809f    	bne.w	0x70099fb0 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #0x13e
70099e72: e7ff         	b	0x70099e74 <Sciclient_rmIrqRouteValidate+0x434> @ imm = #-0x2
70099e74: 2000         	movs	r0, #0x0
;             cur_outp_valid = false;
70099e76: f88d 005f    	strb.w	r0, [sp, #0x5f]
70099e7a: 2101         	movs	r1, #0x1
;             next_inp_valid = true;
70099e7c: f88d 105e    	strb.w	r1, [sp, #0x5e]
;             req.secondary_host = cfg->host;
70099e80: 991d         	ldr	r1, [sp, #0x74]
70099e82: 7909         	ldrb	r1, [r1, #0x4]
70099e84: f88d 1053    	strb.w	r1, [sp, #0x53]
;             req.type = cur_n->id;
70099e88: 991a         	ldr	r1, [sp, #0x68]
70099e8a: 8809         	ldrh	r1, [r1]
70099e8c: f8ad 1050    	strh.w	r1, [sp, #0x50]
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
70099e90: f88d 0052    	strb.w	r0, [sp, #0x52]
70099e94: a812         	add	r0, sp, #0x48
70099e96: a90e         	add	r1, sp, #0x38
70099e98: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
70099e9c: f00f fa78    	bl	0x700a9390 <Sciclient_rmGetResourceRange> @ imm = #0xf4f0
70099ea0: b120         	cbz	r0, 0x70099eac <Sciclient_rmIrqRouteValidate+0x46c> @ imm = #0x8
70099ea2: e7ff         	b	0x70099ea4 <Sciclient_rmIrqRouteValidate+0x464> @ imm = #-0x2
70099ea4: 2000         	movs	r0, #0x0
;                 valid = false;
70099ea6: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099eaa: e0bd         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x17a
70099eac: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
70099eae: f88d 0053    	strb.w	r0, [sp, #0x53]
70099eb2: a812         	add	r0, sp, #0x48
70099eb4: a90a         	add	r1, sp, #0x28
70099eb6: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
70099eba: f00f fa69    	bl	0x700a9390 <Sciclient_rmGetResourceRange> @ imm = #0xf4d2
70099ebe: b120         	cbz	r0, 0x70099eca <Sciclient_rmIrqRouteValidate+0x48a> @ imm = #0x8
70099ec0: e7ff         	b	0x70099ec2 <Sciclient_rmIrqRouteValidate+0x482> @ imm = #-0x2
70099ec2: 2000         	movs	r0, #0x0
;                 valid = false;
70099ec4: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099ec8: e0ae         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x15c
;             cur_outp = SCICLIENT_INP_TO_OUTP(cfg->d_irq,
70099eca: 9a18         	ldr	r2, [sp, #0x60]
70099ecc: 8810         	ldrh	r0, [r2]
70099ece: 991d         	ldr	r1, [sp, #0x74]
70099ed0: 8989         	ldrh	r1, [r1, #0xc]
70099ed2: 8852         	ldrh	r2, [r2, #0x2]
70099ed4: 1a89         	subs	r1, r1, r2
70099ed6: 4408         	add	r0, r1
70099ed8: f8ad 0056    	strh.w	r0, [sp, #0x56]
;             if ((((cur_outp >= host_resp.range_start) &&
70099edc: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099ee0: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099ee4: 4288         	cmp	r0, r1
70099ee6: db0a         	blt	0x70099efe <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #0x14
70099ee8: e7ff         	b	0x70099eea <Sciclient_rmIrqRouteValidate+0x4aa> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start + host_resp.range_num)) ||
70099eea: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099eee: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099ef2: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
70099ef6: 4411         	add	r1, r2
70099ef8: 4288         	cmp	r0, r1
70099efa: db33         	blt	0x70099f64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x66
70099efc: e7ff         	b	0x70099efe <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #-0x2
;                  ((cur_outp >= host_resp.range_start_sec) &&
70099efe: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f02: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
70099f06: 4288         	cmp	r0, r1
70099f08: db0a         	blt	0x70099f20 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #0x14
70099f0a: e7ff         	b	0x70099f0c <Sciclient_rmIrqRouteValidate+0x4cc> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start_sec +
70099f0c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f10: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                               host_resp.range_num_sec))) ||
70099f14: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                   (cur_outp < host_resp.range_start_sec +
70099f18: 4411         	add	r1, r2
;                               host_resp.range_num_sec))) ||
70099f1a: 4288         	cmp	r0, r1
70099f1c: db22         	blt	0x70099f64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x44
70099f1e: e7ff         	b	0x70099f20 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #-0x2
;                 (((cur_outp >= all_resp.range_start) &&
70099f20: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f24: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099f28: 4288         	cmp	r0, r1
70099f2a: db0a         	blt	0x70099f42 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #0x14
70099f2c: e7ff         	b	0x70099f2e <Sciclient_rmIrqRouteValidate+0x4ee> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start + all_resp.range_num)) ||
70099f2e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f32: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099f36: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
70099f3a: 4411         	add	r1, r2
70099f3c: 4288         	cmp	r0, r1
70099f3e: db11         	blt	0x70099f64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x22
70099f40: e7ff         	b	0x70099f42 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #-0x2
;                  ((cur_outp >= all_resp.range_start_sec) &&
70099f42: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f46: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
70099f4a: 4288         	cmp	r0, r1
70099f4c: db2f         	blt	0x70099fae <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x5e
70099f4e: e7ff         	b	0x70099f50 <Sciclient_rmIrqRouteValidate+0x510> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start_sec +
70099f50: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f54: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                               all_resp.range_num_sec)))) {
70099f58: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                   (cur_outp < all_resp.range_start_sec +
70099f5c: 4411         	add	r1, r2
;             if ((((cur_outp >= host_resp.range_start) &&
70099f5e: 4288         	cmp	r0, r1
70099f60: da25         	bge	0x70099fae <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x4a
70099f62: e7ff         	b	0x70099f64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
70099f64: 9818         	ldr	r0, [sp, #0x60]
70099f66: 88c0         	ldrh	r0, [r0, #0x6]
70099f68: 991d         	ldr	r1, [sp, #0x74]
70099f6a: 8949         	ldrh	r1, [r1, #0xa]
70099f6c: 4288         	cmp	r0, r1
70099f6e: d11d         	bne	0x70099fac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x3a
70099f70: e7ff         	b	0x70099f72 <Sciclient_rmIrqRouteValidate+0x532> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
70099f72: 981d         	ldr	r0, [sp, #0x74]
70099f74: 8980         	ldrh	r0, [r0, #0xc]
70099f76: 9918         	ldr	r1, [sp, #0x60]
70099f78: 8849         	ldrh	r1, [r1, #0x2]
70099f7a: 4288         	cmp	r0, r1
70099f7c: db16         	blt	0x70099fac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x2c
70099f7e: e7ff         	b	0x70099f80 <Sciclient_rmIrqRouteValidate+0x540> @ imm = #-0x2
;                     (cfg->d_irq < (cur_if->rbase + cur_if->len))) {
70099f80: 981d         	ldr	r0, [sp, #0x74]
70099f82: 8980         	ldrh	r0, [r0, #0xc]
70099f84: 9a18         	ldr	r2, [sp, #0x60]
70099f86: 8851         	ldrh	r1, [r2, #0x2]
70099f88: 8892         	ldrh	r2, [r2, #0x4]
70099f8a: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
70099f8c: 4288         	cmp	r0, r1
70099f8e: da0d         	bge	0x70099fac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x1a
70099f90: e7ff         	b	0x70099f92 <Sciclient_rmIrqRouteValidate+0x552> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
70099f92: 981a         	ldr	r0, [sp, #0x68]
70099f94: 8800         	ldrh	r0, [r0]
70099f96: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099f9a: f00d f809    	bl	0x700a6fb0 <Sciclient_rmIrOutpIsFree> @ imm = #0xd012
70099f9e: b920         	cbnz	r0, 0x70099faa <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #0x8
70099fa0: e7ff         	b	0x70099fa2 <Sciclient_rmIrqRouteValidate+0x562> @ imm = #-0x2
70099fa2: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
70099fa4: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
70099fa8: e7ff         	b	0x70099faa <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #-0x2
;                 }
70099faa: e7ff         	b	0x70099fac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #-0x2
; 	    }
70099fac: e7ff         	b	0x70099fae <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #-0x2
;         }
70099fae: e7ff         	b	0x70099fb0 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #-0x2
;         if ((cur_outp_valid == true) && (next_inp_valid == true)) {
70099fb0: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
70099fb4: 07c0         	lsls	r0, r0, #0x1f
70099fb6: b360         	cbz	r0, 0x7009a012 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x58
70099fb8: e7ff         	b	0x70099fba <Sciclient_rmIrqRouteValidate+0x57a> @ imm = #-0x2
70099fba: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
70099fbe: 07c0         	lsls	r0, r0, #0x1f
70099fc0: b338         	cbz	r0, 0x7009a012 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x4e
70099fc2: e7ff         	b	0x70099fc4 <Sciclient_rmIrqRouteValidate+0x584> @ imm = #-0x2
;             if (i < (Sciclient_rmPsGetPsp() - (1u))) {
70099fc4: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099fc8: 9000         	str	r0, [sp]
70099fca: f013 fd01    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0x13a02
70099fce: 4601         	mov	r1, r0
70099fd0: 9800         	ldr	r0, [sp]
70099fd2: 3901         	subs	r1, #0x1
70099fd4: 4288         	cmp	r0, r1
70099fd6: d20f         	bhs	0x70099ff8 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #0x1e
70099fd8: e7ff         	b	0x70099fda <Sciclient_rmIrqRouteValidate+0x59a> @ imm = #-0x2
;                 if (Sciclient_rmPsSetInp(i + (1u), next_inp) != SystemP_SUCCESS) {
70099fda: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099fde: 3001         	adds	r0, #0x1
70099fe0: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099fe4: b280         	uxth	r0, r0
70099fe6: f011 f8c3    	bl	0x700ab170 <Sciclient_rmPsSetInp> @ imm = #0x11186
70099fea: b120         	cbz	r0, 0x70099ff6 <Sciclient_rmIrqRouteValidate+0x5b6> @ imm = #0x8
70099fec: e7ff         	b	0x70099fee <Sciclient_rmIrqRouteValidate+0x5ae> @ imm = #-0x2
70099fee: 2000         	movs	r0, #0x0
;                     valid = false;
70099ff0: f88d 0073    	strb.w	r0, [sp, #0x73]
;                     break;
70099ff4: e018         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30
;             }
70099ff6: e7ff         	b	0x70099ff8 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #-0x2
;             if (Sciclient_rmPsSetOutp(i, cur_outp) != SystemP_SUCCESS) {
70099ff8: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099ffc: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009a000: f011 f8de    	bl	0x700ab1c0 <Sciclient_rmPsSetOutp> @ imm = #0x111bc
7009a004: b120         	cbz	r0, 0x7009a010 <Sciclient_rmIrqRouteValidate+0x5d0> @ imm = #0x8
7009a006: e7ff         	b	0x7009a008 <Sciclient_rmIrqRouteValidate+0x5c8> @ imm = #-0x2
7009a008: 2000         	movs	r0, #0x0
;                 valid = false;
7009a00a: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009a00e: e00b         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x16
;         } else {
7009a010: e003         	b	0x7009a01a <Sciclient_rmIrqRouteValidate+0x5da> @ imm = #0x6
7009a012: 2000         	movs	r0, #0x0
;             valid = false;
7009a014: f88d 0073    	strb.w	r0, [sp, #0x73]
;             break;
7009a018: e006         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0xc
;     }
7009a01a: e7ff         	b	0x7009a01c <Sciclient_rmIrqRouteValidate+0x5dc> @ imm = #-0x2
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009a01c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009a020: 3001         	adds	r0, #0x1
7009a022: f8ad 0070    	strh.w	r0, [sp, #0x70]
7009a026: e579         	b	0x70099b1c <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x50e
;     return valid;
7009a028: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009a02c: f000 0001    	and	r0, r0, #0x1
7009a030: b01e         	add	sp, #0x78
7009a032: bd80         	pop	{r7, pc}

7009a034 <malloc>:
7009a034: e1a01000     	mov	r1, r0
7009a038: e3a00008     	mov	r0, #8
7009a03c: ea00122c     	b	0x7009e8f4 <memalign>   @ imm = #0x48b0

7009a040 <_ftoa>:
; {
7009a040: b570         	push	{r4, r5, r6, lr}
7009a042: b0a2         	sub	sp, #0x88
7009a044: f8dd c0a0    	ldr.w	r12, [sp, #0xa0]
7009a048: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009a04c: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009a050: 9020         	str	r0, [sp, #0x80]
7009a052: 911f         	str	r1, [sp, #0x7c]
7009a054: 921e         	str	r2, [sp, #0x78]
7009a056: 931d         	str	r3, [sp, #0x74]
7009a058: ed8d 0b1a    	vstr	d0, [sp, #104]
7009a05c: 2000         	movs	r0, #0x0
;   size_t len  = 0U;
7009a05e: 9011         	str	r0, [sp, #0x44]
;   double diff = 0.0;
7009a060: 900f         	str	r0, [sp, #0x3c]
7009a062: 900e         	str	r0, [sp, #0x38]
;   if (value != value)
7009a064: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a068: eeb4 0b40    	vcmp.f64	d0, d0
7009a06c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a070: d71a         	bvc	0x7009a0a8 <_ftoa+0x68> @ imm = #0x34
7009a072: e7ff         	b	0x7009a074 <_ftoa+0x34> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
7009a074: 9820         	ldr	r0, [sp, #0x80]
7009a076: 991f         	ldr	r1, [sp, #0x7c]
7009a078: 9a1e         	ldr	r2, [sp, #0x78]
7009a07a: 9b1d         	ldr	r3, [sp, #0x74]
7009a07c: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009a080: 9c28         	ldr	r4, [sp, #0xa0]
7009a082: 46ee         	mov	lr, sp
7009a084: f8ce 400c    	str.w	r4, [lr, #0xc]
7009a088: f8ce c008    	str.w	r12, [lr, #0x8]
7009a08c: f04f 0c03    	mov.w	r12, #0x3
7009a090: f8ce c004    	str.w	r12, [lr, #0x4]
7009a094: f240 1c4c    	movw	r12, #0x14c
7009a098: f2c7 0c0b    	movt	r12, #0x700b
7009a09c: f8ce c000    	str.w	r12, [lr]
7009a0a0: f00b fae6    	bl	0x700a5670 <_out_rev>   @ imm = #0xb5cc
7009a0a4: 9021         	str	r0, [sp, #0x84]
7009a0a6: e257         	b	0x7009a558 <_ftoa+0x518> @ imm = #0x4ae
;   if (value < -DBL_MAX)
7009a0a8: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a0ac: ed9f 1bd2    	vldr	d1, [pc, #840]          @ 0x7009a3f8 <_ftoa+0x3b8>
7009a0b0: eeb4 0b41    	vcmp.f64	d0, d1
7009a0b4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a0b8: d51a         	bpl	0x7009a0f0 <_ftoa+0xb0> @ imm = #0x34
7009a0ba: e7ff         	b	0x7009a0bc <_ftoa+0x7c> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
7009a0bc: 9820         	ldr	r0, [sp, #0x80]
7009a0be: 991f         	ldr	r1, [sp, #0x7c]
7009a0c0: 9a1e         	ldr	r2, [sp, #0x78]
7009a0c2: 9b1d         	ldr	r3, [sp, #0x74]
7009a0c4: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009a0c8: 9c28         	ldr	r4, [sp, #0xa0]
7009a0ca: 46ee         	mov	lr, sp
7009a0cc: f8ce 400c    	str.w	r4, [lr, #0xc]
7009a0d0: f8ce c008    	str.w	r12, [lr, #0x8]
7009a0d4: f04f 0c04    	mov.w	r12, #0x4
7009a0d8: f8ce c004    	str.w	r12, [lr, #0x4]
7009a0dc: f240 1c29    	movw	r12, #0x129
7009a0e0: f2c7 0c0b    	movt	r12, #0x700b
7009a0e4: f8ce c000    	str.w	r12, [lr]
7009a0e8: f00b fac2    	bl	0x700a5670 <_out_rev>   @ imm = #0xb584
7009a0ec: 9021         	str	r0, [sp, #0x84]
7009a0ee: e233         	b	0x7009a558 <_ftoa+0x518> @ imm = #0x466
;   if (value > DBL_MAX)
7009a0f0: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a0f4: ed9f 1bc2    	vldr	d1, [pc, #776]          @ 0x7009a400 <_ftoa+0x3c0>
7009a0f8: eeb4 0b41    	vcmp.f64	d0, d1
7009a0fc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a100: dd26         	ble	0x7009a150 <_ftoa+0x110> @ imm = #0x4c
7009a102: e7ff         	b	0x7009a104 <_ftoa+0xc4> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
7009a104: 9820         	ldr	r0, [sp, #0x80]
7009a106: 991f         	ldr	r1, [sp, #0x7c]
7009a108: 9a1e         	ldr	r2, [sp, #0x78]
7009a10a: 9b1d         	ldr	r3, [sp, #0x74]
7009a10c: 9e28         	ldr	r6, [sp, #0xa0]
7009a10e: f006 0e04    	and	lr, r6, #0x4
7009a112: f240 1433    	movw	r4, #0x133
7009a116: f2c7 040b    	movt	r4, #0x700b
7009a11a: f240 1c48    	movw	r12, #0x148
7009a11e: f2c7 0c0b    	movt	r12, #0x700b
7009a122: f1be 0f00    	cmp.w	lr, #0x0
7009a126: bf18         	it	ne
7009a128: 46a4         	movne	r12, r4
7009a12a: 2403         	movs	r4, #0x3
7009a12c: f1be 0f00    	cmp.w	lr, #0x0
7009a130: bf18         	it	ne
7009a132: 2404         	movne	r4, #0x4
7009a134: 9d27         	ldr	r5, [sp, #0x9c]
7009a136: 46ee         	mov	lr, sp
7009a138: f8ce 600c    	str.w	r6, [lr, #0xc]
7009a13c: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a140: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a144: f8ce c000    	str.w	r12, [lr]
7009a148: f00b fa92    	bl	0x700a5670 <_out_rev>   @ imm = #0xb524
7009a14c: 9021         	str	r0, [sp, #0x84]
7009a14e: e203         	b	0x7009a558 <_ftoa+0x518> @ imm = #0x406
;   if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
7009a150: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a154: ed9f 1bac    	vldr	d1, [pc, #688]          @ 0x7009a408 <_ftoa+0x3c8>
7009a158: eeb4 0b41    	vcmp.f64	d0, d1
7009a15c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a160: dc0a         	bgt	0x7009a178 <_ftoa+0x138> @ imm = #0x14
7009a162: e7ff         	b	0x7009a164 <_ftoa+0x124> @ imm = #-0x2
7009a164: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a168: ed9f 1ba9    	vldr	d1, [pc, #676]          @ 0x7009a410 <_ftoa+0x3d0>
7009a16c: eeb4 0b41    	vcmp.f64	d0, d1
7009a170: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a174: d515         	bpl	0x7009a1a2 <_ftoa+0x162> @ imm = #0x2a
7009a176: e7ff         	b	0x7009a178 <_ftoa+0x138> @ imm = #-0x2
;     return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009a178: 9820         	ldr	r0, [sp, #0x80]
7009a17a: 991f         	ldr	r1, [sp, #0x7c]
7009a17c: 9a1e         	ldr	r2, [sp, #0x78]
7009a17e: 9b1d         	ldr	r3, [sp, #0x74]
7009a180: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a184: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009a188: 9c27         	ldr	r4, [sp, #0x9c]
7009a18a: 9d28         	ldr	r5, [sp, #0xa0]
7009a18c: 46ee         	mov	lr, sp
7009a18e: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a192: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a196: f8ce c000    	str.w	r12, [lr]
7009a19a: f000 f9e1    	bl	0x7009a560 <_etoa>      @ imm = #0x3c2
7009a19e: 9021         	str	r0, [sp, #0x84]
7009a1a0: e1da         	b	0x7009a558 <_ftoa+0x518> @ imm = #0x3b4
7009a1a2: f04f 0000    	mov.w	r0, #0x0
;   bool negative = false;
7009a1a6: f88d 0037    	strb.w	r0, [sp, #0x37]
;   if (value < 0) {
7009a1aa: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a1ae: eeb5 0b40    	vcmp.f64	d0, #0
7009a1b2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a1b6: d50d         	bpl	0x7009a1d4 <_ftoa+0x194> @ imm = #0x1a
7009a1b8: e7ff         	b	0x7009a1ba <_ftoa+0x17a> @ imm = #-0x2
7009a1ba: f04f 0001    	mov.w	r0, #0x1
;     negative = true;
7009a1be: f88d 0037    	strb.w	r0, [sp, #0x37]
;     value = 0 - value;
7009a1c2: ed9d 1b1a    	vldr	d1, [sp, #104]
7009a1c6: ed9f 0b94    	vldr	d0, [pc, #592]          @ 0x7009a418 <_ftoa+0x3d8>
7009a1ca: ee30 0b41    	vsub.f64	d0, d0, d1
7009a1ce: ed8d 0b1a    	vstr	d0, [sp, #104]
;   }
7009a1d2: e7ff         	b	0x7009a1d4 <_ftoa+0x194> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009a1d4: f89d 00a1    	ldrb.w	r0, [sp, #0xa1]
7009a1d8: ea4f 7040    	lsl.w	r0, r0, #0x1d
7009a1dc: 2800         	cmp	r0, #0x0
7009a1de: d403         	bmi	0x7009a1e8 <_ftoa+0x1a8> @ imm = #0x6
7009a1e0: e7ff         	b	0x7009a1e2 <_ftoa+0x1a2> @ imm = #-0x2
7009a1e2: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009a1e4: 9026         	str	r0, [sp, #0x98]
;   }
7009a1e6: e7ff         	b	0x7009a1e8 <_ftoa+0x1a8> @ imm = #-0x2
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009a1e8: e7ff         	b	0x7009a1ea <_ftoa+0x1aa> @ imm = #-0x2
7009a1ea: 9911         	ldr	r1, [sp, #0x44]
7009a1ec: 2000         	movs	r0, #0x0
7009a1ee: 291f         	cmp	r1, #0x1f
7009a1f0: 9007         	str	r0, [sp, #0x1c]
7009a1f2: d807         	bhi	0x7009a204 <_ftoa+0x1c4> @ imm = #0xe
7009a1f4: e7ff         	b	0x7009a1f6 <_ftoa+0x1b6> @ imm = #-0x2
7009a1f6: 9926         	ldr	r1, [sp, #0x98]
7009a1f8: 2000         	movs	r0, #0x0
7009a1fa: 2909         	cmp	r1, #0x9
7009a1fc: bf88         	it	hi
7009a1fe: 2001         	movhi	r0, #0x1
7009a200: 9007         	str	r0, [sp, #0x1c]
7009a202: e7ff         	b	0x7009a204 <_ftoa+0x1c4> @ imm = #-0x2
7009a204: 9807         	ldr	r0, [sp, #0x1c]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009a206: 07c0         	lsls	r0, r0, #0x1f
7009a208: b150         	cbz	r0, 0x7009a220 <_ftoa+0x1e0> @ imm = #0x14
7009a20a: e7ff         	b	0x7009a20c <_ftoa+0x1cc> @ imm = #-0x2
;     buf[len++] = '0';
7009a20c: 9a11         	ldr	r2, [sp, #0x44]
7009a20e: 1c50         	adds	r0, r2, #0x1
7009a210: 9011         	str	r0, [sp, #0x44]
7009a212: a912         	add	r1, sp, #0x48
7009a214: 2030         	movs	r0, #0x30
7009a216: 5488         	strb	r0, [r1, r2]
;     prec--;
7009a218: 9826         	ldr	r0, [sp, #0x98]
7009a21a: 3801         	subs	r0, #0x1
7009a21c: 9026         	str	r0, [sp, #0x98]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009a21e: e7e4         	b	0x7009a1ea <_ftoa+0x1aa> @ imm = #-0x38
;   int whole = (int)value;
7009a220: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a224: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009a228: ed8d 0a0c    	vstr	s0, [sp, #48]
;   double tmp = (value - whole) * pow10[prec];
7009a22c: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a230: ed9d 1a0c    	vldr	s2, [sp, #48]
7009a234: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009a238: ee30 0b41    	vsub.f64	d0, d0, d1
7009a23c: 9926         	ldr	r1, [sp, #0x98]
7009a23e: f24f 5028    	movw	r0, #0xf528
7009a242: f2c7 000a    	movt	r0, #0x700a
7009a246: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009a24a: ed90 1b00    	vldr	d1, [r0]
7009a24e: ee20 0b01    	vmul.f64	d0, d0, d1
7009a252: ed8d 0b0a    	vstr	d0, [sp, #40]
;   unsigned long frac = (unsigned long)tmp;
7009a256: ed9d 0b0a    	vldr	d0, [sp, #40]
7009a25a: eebc 0bc0    	vcvt.u32.f64	s0, d0
7009a25e: ed8d 0a09    	vstr	s0, [sp, #36]
;   diff = tmp - frac;
7009a262: ed9d 0b0a    	vldr	d0, [sp, #40]
7009a266: ed9d 1a09    	vldr	s2, [sp, #36]
7009a26a: eeb8 1b41    	vcvt.f64.u32	d1, s2
7009a26e: ee30 0b41    	vsub.f64	d0, d0, d1
7009a272: ed8d 0b0e    	vstr	d0, [sp, #56]
;   if (diff > 0.5) {
7009a276: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a27a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a27e: eeb4 0b41    	vcmp.f64	d0, d1
7009a282: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a286: dd1e         	ble	0x7009a2c6 <_ftoa+0x286> @ imm = #0x3c
7009a288: e7ff         	b	0x7009a28a <_ftoa+0x24a> @ imm = #-0x2
;     ++frac;
7009a28a: 9809         	ldr	r0, [sp, #0x24]
7009a28c: 3001         	adds	r0, #0x1
7009a28e: 9009         	str	r0, [sp, #0x24]
;     if (frac >= pow10[prec]) {
7009a290: ed9d 0a09    	vldr	s0, [sp, #36]
7009a294: eeb8 0b40    	vcvt.f64.u32	d0, s0
7009a298: 9926         	ldr	r1, [sp, #0x98]
7009a29a: f24f 5028    	movw	r0, #0xf528
7009a29e: f2c7 000a    	movt	r0, #0x700a
7009a2a2: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009a2a6: ed90 1b00    	vldr	d1, [r0]
7009a2aa: eeb4 0b41    	vcmp.f64	d0, d1
7009a2ae: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a2b2: db07         	blt	0x7009a2c4 <_ftoa+0x284> @ imm = #0xe
7009a2b4: e7ff         	b	0x7009a2b6 <_ftoa+0x276> @ imm = #-0x2
7009a2b6: f04f 0000    	mov.w	r0, #0x0
;       frac = 0;
7009a2ba: 9009         	str	r0, [sp, #0x24]
;       ++whole;
7009a2bc: 980c         	ldr	r0, [sp, #0x30]
7009a2be: 3001         	adds	r0, #0x1
7009a2c0: 900c         	str	r0, [sp, #0x30]
;     }
7009a2c2: e7ff         	b	0x7009a2c4 <_ftoa+0x284> @ imm = #-0x2
;   }
7009a2c4: e018         	b	0x7009a2f8 <_ftoa+0x2b8> @ imm = #0x30
;   else if (diff < 0.5) {
7009a2c6: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a2ca: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a2ce: eeb4 0b41    	vcmp.f64	d0, d1
7009a2d2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a2d6: d501         	bpl	0x7009a2dc <_ftoa+0x29c> @ imm = #0x2
7009a2d8: e7ff         	b	0x7009a2da <_ftoa+0x29a> @ imm = #-0x2
;   }
7009a2da: e00c         	b	0x7009a2f6 <_ftoa+0x2b6> @ imm = #0x18
;   else if ((frac == 0U) || (frac & 1U)) {
7009a2dc: 9809         	ldr	r0, [sp, #0x24]
7009a2de: b128         	cbz	r0, 0x7009a2ec <_ftoa+0x2ac> @ imm = #0xa
7009a2e0: e7ff         	b	0x7009a2e2 <_ftoa+0x2a2> @ imm = #-0x2
7009a2e2: f89d 0024    	ldrb.w	r0, [sp, #0x24]
7009a2e6: 07c0         	lsls	r0, r0, #0x1f
7009a2e8: b120         	cbz	r0, 0x7009a2f4 <_ftoa+0x2b4> @ imm = #0x8
7009a2ea: e7ff         	b	0x7009a2ec <_ftoa+0x2ac> @ imm = #-0x2
;     ++frac;
7009a2ec: 9809         	ldr	r0, [sp, #0x24]
7009a2ee: 3001         	adds	r0, #0x1
7009a2f0: 9009         	str	r0, [sp, #0x24]
;   }
7009a2f2: e7ff         	b	0x7009a2f4 <_ftoa+0x2b4> @ imm = #-0x2
7009a2f4: e7ff         	b	0x7009a2f6 <_ftoa+0x2b6> @ imm = #-0x2
7009a2f6: e7ff         	b	0x7009a2f8 <_ftoa+0x2b8> @ imm = #-0x2
;   if (prec == 0U) {
7009a2f8: 9826         	ldr	r0, [sp, #0x98]
7009a2fa: bb48         	cbnz	r0, 0x7009a350 <_ftoa+0x310> @ imm = #0x52
7009a2fc: e7ff         	b	0x7009a2fe <_ftoa+0x2be> @ imm = #-0x2
;     diff = value - (double)whole;
7009a2fe: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a302: ed9d 1a0c    	vldr	s2, [sp, #48]
7009a306: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009a30a: ee30 0b41    	vsub.f64	d0, d0, d1
7009a30e: ed8d 0b0e    	vstr	d0, [sp, #56]
;     if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
7009a312: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a316: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a31a: eeb4 0b41    	vcmp.f64	d0, d1
7009a31e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a322: d50a         	bpl	0x7009a33a <_ftoa+0x2fa> @ imm = #0x14
7009a324: e7ff         	b	0x7009a326 <_ftoa+0x2e6> @ imm = #-0x2
7009a326: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a32a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a32e: eeb4 0b41    	vcmp.f64	d0, d1
7009a332: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a336: dd0a         	ble	0x7009a34e <_ftoa+0x30e> @ imm = #0x14
7009a338: e7ff         	b	0x7009a33a <_ftoa+0x2fa> @ imm = #-0x2
7009a33a: f89d 0030    	ldrb.w	r0, [sp, #0x30]
7009a33e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009a342: b120         	cbz	r0, 0x7009a34e <_ftoa+0x30e> @ imm = #0x8
7009a344: e7ff         	b	0x7009a346 <_ftoa+0x306> @ imm = #-0x2
;       ++whole;
7009a346: 980c         	ldr	r0, [sp, #0x30]
7009a348: 3001         	adds	r0, #0x1
7009a34a: 900c         	str	r0, [sp, #0x30]
;     }
7009a34c: e7ff         	b	0x7009a34e <_ftoa+0x30e> @ imm = #-0x2
;   }
7009a34e: e04d         	b	0x7009a3ec <_ftoa+0x3ac> @ imm = #0x9a
;     unsigned int count = prec;
7009a350: 9826         	ldr	r0, [sp, #0x98]
7009a352: 9008         	str	r0, [sp, #0x20]
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a354: e7ff         	b	0x7009a356 <_ftoa+0x316> @ imm = #-0x2
7009a356: 9811         	ldr	r0, [sp, #0x44]
7009a358: 281f         	cmp	r0, #0x1f
7009a35a: d821         	bhi	0x7009a3a0 <_ftoa+0x360> @ imm = #0x42
7009a35c: e7ff         	b	0x7009a35e <_ftoa+0x31e> @ imm = #-0x2
;       --count;
7009a35e: 9808         	ldr	r0, [sp, #0x20]
7009a360: 3801         	subs	r0, #0x1
7009a362: 9008         	str	r0, [sp, #0x20]
;       buf[len++] = (char)(48U + (frac % 10U));
7009a364: 9809         	ldr	r0, [sp, #0x24]
7009a366: f64c 41cd    	movw	r1, #0xcccd
7009a36a: f6cc 41cc    	movt	r1, #0xcccc
7009a36e: fba0 3201    	umull	r3, r2, r0, r1
7009a372: ea4f 02d2    	lsr.w	r2, r2, #0x3
7009a376: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009a37a: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009a37e: f040 0030    	orr	r0, r0, #0x30
7009a382: 9b11         	ldr	r3, [sp, #0x44]
7009a384: 1c5a         	adds	r2, r3, #0x1
7009a386: 9211         	str	r2, [sp, #0x44]
7009a388: aa12         	add	r2, sp, #0x48
7009a38a: 54d0         	strb	r0, [r2, r3]
;       if (!(frac /= 10U)) {
7009a38c: 9809         	ldr	r0, [sp, #0x24]
7009a38e: fba0 1001    	umull	r1, r0, r0, r1
7009a392: ea4f 00d0    	lsr.w	r0, r0, #0x3
7009a396: 9009         	str	r0, [sp, #0x24]
7009a398: b908         	cbnz	r0, 0x7009a39e <_ftoa+0x35e> @ imm = #0x2
7009a39a: e7ff         	b	0x7009a39c <_ftoa+0x35c> @ imm = #-0x2
;         break;
7009a39c: e000         	b	0x7009a3a0 <_ftoa+0x360> @ imm = #0x0
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a39e: e7da         	b	0x7009a356 <_ftoa+0x316> @ imm = #-0x4c
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009a3a0: e7ff         	b	0x7009a3a2 <_ftoa+0x362> @ imm = #-0x2
7009a3a2: 9911         	ldr	r1, [sp, #0x44]
7009a3a4: 2000         	movs	r0, #0x0
7009a3a6: 291f         	cmp	r1, #0x1f
7009a3a8: 9006         	str	r0, [sp, #0x18]
7009a3aa: d808         	bhi	0x7009a3be <_ftoa+0x37e> @ imm = #0x10
7009a3ac: e7ff         	b	0x7009a3ae <_ftoa+0x36e> @ imm = #-0x2
7009a3ae: 9808         	ldr	r0, [sp, #0x20]
7009a3b0: 1e41         	subs	r1, r0, #0x1
7009a3b2: 9108         	str	r1, [sp, #0x20]
7009a3b4: 2800         	cmp	r0, #0x0
7009a3b6: bf18         	it	ne
7009a3b8: 2001         	movne	r0, #0x1
7009a3ba: 9006         	str	r0, [sp, #0x18]
7009a3bc: e7ff         	b	0x7009a3be <_ftoa+0x37e> @ imm = #-0x2
7009a3be: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009a3c0: 07c0         	lsls	r0, r0, #0x1f
7009a3c2: b138         	cbz	r0, 0x7009a3d4 <_ftoa+0x394> @ imm = #0xe
7009a3c4: e7ff         	b	0x7009a3c6 <_ftoa+0x386> @ imm = #-0x2
;       buf[len++] = '0';
7009a3c6: 9a11         	ldr	r2, [sp, #0x44]
7009a3c8: 1c50         	adds	r0, r2, #0x1
7009a3ca: 9011         	str	r0, [sp, #0x44]
7009a3cc: a912         	add	r1, sp, #0x48
7009a3ce: 2030         	movs	r0, #0x30
7009a3d0: 5488         	strb	r0, [r1, r2]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009a3d2: e7e6         	b	0x7009a3a2 <_ftoa+0x362> @ imm = #-0x34
;     if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a3d4: 9811         	ldr	r0, [sp, #0x44]
7009a3d6: 281f         	cmp	r0, #0x1f
7009a3d8: d807         	bhi	0x7009a3ea <_ftoa+0x3aa> @ imm = #0xe
7009a3da: e7ff         	b	0x7009a3dc <_ftoa+0x39c> @ imm = #-0x2
;       buf[len++] = '.';
7009a3dc: 9a11         	ldr	r2, [sp, #0x44]
7009a3de: 1c50         	adds	r0, r2, #0x1
7009a3e0: 9011         	str	r0, [sp, #0x44]
7009a3e2: a912         	add	r1, sp, #0x48
7009a3e4: 202e         	movs	r0, #0x2e
7009a3e6: 5488         	strb	r0, [r1, r2]
;     }
7009a3e8: e7ff         	b	0x7009a3ea <_ftoa+0x3aa> @ imm = #-0x2
7009a3ea: e7ff         	b	0x7009a3ec <_ftoa+0x3ac> @ imm = #-0x2
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a3ec: e7ff         	b	0x7009a3ee <_ftoa+0x3ae> @ imm = #-0x2
7009a3ee: 9811         	ldr	r0, [sp, #0x44]
7009a3f0: 281f         	cmp	r0, #0x1f
7009a3f2: d835         	bhi	0x7009a460 <_ftoa+0x420> @ imm = #0x6a
7009a3f4: e014         	b	0x7009a420 <_ftoa+0x3e0> @ imm = #0x28
7009a3f6: bf00         	nop
7009a3f8: ff ff ff ff  	.word	0xffffffff
7009a3fc: ff ff ef ff  	.word	0xffefffff
7009a400: ff ff ff ff  	.word	0xffffffff
7009a404: ff ff ef 7f  	.word	0x7fefffff
7009a408: 00 00 00 00  	.word	0x00000000
7009a40c: 65 cd cd 41  	.word	0x41cdcd65
7009a410: 00 00 00 00  	.word	0x00000000
7009a414: 65 cd cd c1  	.word	0xc1cdcd65
7009a418: 00 00 00 00  	.word	0x00000000
7009a41c: 00 00 00 00  	.word	0x00000000
;     buf[len++] = (char)(48 + (whole % 10));
7009a420: 980c         	ldr	r0, [sp, #0x30]
7009a422: f246 6167    	movw	r1, #0x6667
7009a426: f2c6 6166    	movt	r1, #0x6666
7009a42a: fb50 f301    	smmul	r3, r0, r1
7009a42e: 089a         	lsrs	r2, r3, #0x2
7009a430: eb02 72d3    	add.w	r2, r2, r3, lsr #31
7009a434: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009a438: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009a43c: 3030         	adds	r0, #0x30
7009a43e: 9b11         	ldr	r3, [sp, #0x44]
7009a440: 1c5a         	adds	r2, r3, #0x1
7009a442: 9211         	str	r2, [sp, #0x44]
7009a444: aa12         	add	r2, sp, #0x48
7009a446: 54d0         	strb	r0, [r2, r3]
;     if (!(whole /= 10)) {
7009a448: 980c         	ldr	r0, [sp, #0x30]
7009a44a: fb50 f101    	smmul	r1, r0, r1
7009a44e: ea4f 00a1    	asr.w	r0, r1, #0x2
7009a452: eb00 70d1    	add.w	r0, r0, r1, lsr #31
7009a456: 900c         	str	r0, [sp, #0x30]
7009a458: b908         	cbnz	r0, 0x7009a45e <_ftoa+0x41e> @ imm = #0x2
7009a45a: e7ff         	b	0x7009a45c <_ftoa+0x41c> @ imm = #-0x2
;       break;
7009a45c: e000         	b	0x7009a460 <_ftoa+0x420> @ imm = #0x0
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a45e: e7c6         	b	0x7009a3ee <_ftoa+0x3ae> @ imm = #-0x74
;   if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
7009a460: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a464: 0780         	lsls	r0, r0, #0x1e
7009a466: 2800         	cmp	r0, #0x0
7009a468: d432         	bmi	0x7009a4d0 <_ftoa+0x490> @ imm = #0x64
7009a46a: e7ff         	b	0x7009a46c <_ftoa+0x42c> @ imm = #-0x2
7009a46c: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a470: 07c0         	lsls	r0, r0, #0x1f
7009a472: b368         	cbz	r0, 0x7009a4d0 <_ftoa+0x490> @ imm = #0x5a
7009a474: e7ff         	b	0x7009a476 <_ftoa+0x436> @ imm = #-0x2
;     if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009a476: 9827         	ldr	r0, [sp, #0x9c]
7009a478: b178         	cbz	r0, 0x7009a49a <_ftoa+0x45a> @ imm = #0x1e
7009a47a: e7ff         	b	0x7009a47c <_ftoa+0x43c> @ imm = #-0x2
7009a47c: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009a480: 07c0         	lsls	r0, r0, #0x1f
7009a482: b930         	cbnz	r0, 0x7009a492 <_ftoa+0x452> @ imm = #0xc
7009a484: e7ff         	b	0x7009a486 <_ftoa+0x446> @ imm = #-0x2
7009a486: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a48a: f010 0f0c    	tst.w	r0, #0xc
7009a48e: d004         	beq	0x7009a49a <_ftoa+0x45a> @ imm = #0x8
7009a490: e7ff         	b	0x7009a492 <_ftoa+0x452> @ imm = #-0x2
;       width--;
7009a492: 9827         	ldr	r0, [sp, #0x9c]
7009a494: 3801         	subs	r0, #0x1
7009a496: 9027         	str	r0, [sp, #0x9c]
;     }
7009a498: e7ff         	b	0x7009a49a <_ftoa+0x45a> @ imm = #-0x2
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009a49a: e7ff         	b	0x7009a49c <_ftoa+0x45c> @ imm = #-0x2
7009a49c: 9911         	ldr	r1, [sp, #0x44]
7009a49e: 9a27         	ldr	r2, [sp, #0x9c]
7009a4a0: 2000         	movs	r0, #0x0
7009a4a2: 4291         	cmp	r1, r2
7009a4a4: 9005         	str	r0, [sp, #0x14]
7009a4a6: d207         	bhs	0x7009a4b8 <_ftoa+0x478> @ imm = #0xe
7009a4a8: e7ff         	b	0x7009a4aa <_ftoa+0x46a> @ imm = #-0x2
7009a4aa: 9911         	ldr	r1, [sp, #0x44]
7009a4ac: 2000         	movs	r0, #0x0
7009a4ae: 2920         	cmp	r1, #0x20
7009a4b0: bf38         	it	lo
7009a4b2: 2001         	movlo	r0, #0x1
7009a4b4: 9005         	str	r0, [sp, #0x14]
7009a4b6: e7ff         	b	0x7009a4b8 <_ftoa+0x478> @ imm = #-0x2
7009a4b8: 9805         	ldr	r0, [sp, #0x14]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009a4ba: 07c0         	lsls	r0, r0, #0x1f
7009a4bc: b138         	cbz	r0, 0x7009a4ce <_ftoa+0x48e> @ imm = #0xe
7009a4be: e7ff         	b	0x7009a4c0 <_ftoa+0x480> @ imm = #-0x2
;       buf[len++] = '0';
7009a4c0: 9a11         	ldr	r2, [sp, #0x44]
7009a4c2: 1c50         	adds	r0, r2, #0x1
7009a4c4: 9011         	str	r0, [sp, #0x44]
7009a4c6: a912         	add	r1, sp, #0x48
7009a4c8: 2030         	movs	r0, #0x30
7009a4ca: 5488         	strb	r0, [r1, r2]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009a4cc: e7e6         	b	0x7009a49c <_ftoa+0x45c> @ imm = #-0x34
;   }
7009a4ce: e7ff         	b	0x7009a4d0 <_ftoa+0x490> @ imm = #-0x2
;   if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a4d0: 9811         	ldr	r0, [sp, #0x44]
7009a4d2: 281f         	cmp	r0, #0x1f
7009a4d4: d829         	bhi	0x7009a52a <_ftoa+0x4ea> @ imm = #0x52
7009a4d6: e7ff         	b	0x7009a4d8 <_ftoa+0x498> @ imm = #-0x2
;     if (negative) {
7009a4d8: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009a4dc: 07c0         	lsls	r0, r0, #0x1f
7009a4de: b138         	cbz	r0, 0x7009a4f0 <_ftoa+0x4b0> @ imm = #0xe
7009a4e0: e7ff         	b	0x7009a4e2 <_ftoa+0x4a2> @ imm = #-0x2
;       buf[len++] = '-';
7009a4e2: 9a11         	ldr	r2, [sp, #0x44]
7009a4e4: 1c50         	adds	r0, r2, #0x1
7009a4e6: 9011         	str	r0, [sp, #0x44]
7009a4e8: a912         	add	r1, sp, #0x48
7009a4ea: 202d         	movs	r0, #0x2d
7009a4ec: 5488         	strb	r0, [r1, r2]
;     }
7009a4ee: e01b         	b	0x7009a528 <_ftoa+0x4e8> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009a4f0: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a4f4: 0740         	lsls	r0, r0, #0x1d
7009a4f6: 2800         	cmp	r0, #0x0
7009a4f8: d507         	bpl	0x7009a50a <_ftoa+0x4ca> @ imm = #0xe
7009a4fa: e7ff         	b	0x7009a4fc <_ftoa+0x4bc> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009a4fc: 9a11         	ldr	r2, [sp, #0x44]
7009a4fe: 1c50         	adds	r0, r2, #0x1
7009a500: 9011         	str	r0, [sp, #0x44]
7009a502: a912         	add	r1, sp, #0x48
7009a504: 202b         	movs	r0, #0x2b
7009a506: 5488         	strb	r0, [r1, r2]
;     }
7009a508: e00d         	b	0x7009a526 <_ftoa+0x4e6> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009a50a: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a50e: 0700         	lsls	r0, r0, #0x1c
7009a510: 2800         	cmp	r0, #0x0
7009a512: d507         	bpl	0x7009a524 <_ftoa+0x4e4> @ imm = #0xe
7009a514: e7ff         	b	0x7009a516 <_ftoa+0x4d6> @ imm = #-0x2
;       buf[len++] = ' ';
7009a516: 9a11         	ldr	r2, [sp, #0x44]
7009a518: 1c50         	adds	r0, r2, #0x1
7009a51a: 9011         	str	r0, [sp, #0x44]
7009a51c: a912         	add	r1, sp, #0x48
7009a51e: 2020         	movs	r0, #0x20
7009a520: 5488         	strb	r0, [r1, r2]
;     }
7009a522: e7ff         	b	0x7009a524 <_ftoa+0x4e4> @ imm = #-0x2
7009a524: e7ff         	b	0x7009a526 <_ftoa+0x4e6> @ imm = #-0x2
7009a526: e7ff         	b	0x7009a528 <_ftoa+0x4e8> @ imm = #-0x2
;   }
7009a528: e7ff         	b	0x7009a52a <_ftoa+0x4ea> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009a52a: 9820         	ldr	r0, [sp, #0x80]
7009a52c: 991f         	ldr	r1, [sp, #0x7c]
7009a52e: 9a1e         	ldr	r2, [sp, #0x78]
7009a530: 9b1d         	ldr	r3, [sp, #0x74]
7009a532: f8dd c044    	ldr.w	r12, [sp, #0x44]
7009a536: 9c27         	ldr	r4, [sp, #0x9c]
7009a538: 9d28         	ldr	r5, [sp, #0xa0]
7009a53a: 46ee         	mov	lr, sp
7009a53c: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a540: f8ce 4008    	str.w	r4, [lr, #0x8]
7009a544: f8ce c004    	str.w	r12, [lr, #0x4]
7009a548: f10d 0c48    	add.w	r12, sp, #0x48
7009a54c: f8ce c000    	str.w	r12, [lr]
7009a550: f00b f88e    	bl	0x700a5670 <_out_rev>   @ imm = #0xb11c
7009a554: 9021         	str	r0, [sp, #0x84]
7009a556: e7ff         	b	0x7009a558 <_ftoa+0x518> @ imm = #-0x2
; }
7009a558: 9821         	ldr	r0, [sp, #0x84]
7009a55a: b022         	add	sp, #0x88
7009a55c: bd70         	pop	{r4, r5, r6, pc}
7009a55e: 0000         	movs	r0, r0

7009a560 <_etoa>:
; {
7009a560: b570         	push	{r4, r5, r6, lr}
7009a562: b0a8         	sub	sp, #0xa0
7009a564: f8dd c0b8    	ldr.w	r12, [sp, #0xb8]
7009a568: f8dd c0b4    	ldr.w	r12, [sp, #0xb4]
7009a56c: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009a570: 9026         	str	r0, [sp, #0x98]
7009a572: 9125         	str	r1, [sp, #0x94]
7009a574: 9224         	str	r2, [sp, #0x90]
7009a576: 9323         	str	r3, [sp, #0x8c]
7009a578: ed8d 0b20    	vstr	d0, [sp, #128]
;   if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
7009a57c: ed9d 0b20    	vldr	d0, [sp, #128]
7009a580: eeb4 0b40    	vcmp.f64	d0, d0
7009a584: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a588: d614         	bvs	0x7009a5b4 <_etoa+0x54> @ imm = #0x28
7009a58a: e7ff         	b	0x7009a58c <_etoa+0x2c> @ imm = #-0x2
7009a58c: ed9d 0b20    	vldr	d0, [sp, #128]
7009a590: ed9f 1bdb    	vldr	d1, [pc, #876]          @ 0x7009a900 <_etoa+0x3a0>
7009a594: eeb4 0b41    	vcmp.f64	d0, d1
7009a598: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a59c: dc0a         	bgt	0x7009a5b4 <_etoa+0x54> @ imm = #0x14
7009a59e: e7ff         	b	0x7009a5a0 <_etoa+0x40> @ imm = #-0x2
7009a5a0: ed9d 0b20    	vldr	d0, [sp, #128]
7009a5a4: ed9f 1bd8    	vldr	d1, [pc, #864]          @ 0x7009a908 <_etoa+0x3a8>
7009a5a8: eeb4 0b41    	vcmp.f64	d0, d1
7009a5ac: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a5b0: d515         	bpl	0x7009a5de <_etoa+0x7e> @ imm = #0x2a
7009a5b2: e7ff         	b	0x7009a5b4 <_etoa+0x54> @ imm = #-0x2
;     return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009a5b4: 9826         	ldr	r0, [sp, #0x98]
7009a5b6: 9925         	ldr	r1, [sp, #0x94]
7009a5b8: 9a24         	ldr	r2, [sp, #0x90]
7009a5ba: 9b23         	ldr	r3, [sp, #0x8c]
7009a5bc: ed9d 0b20    	vldr	d0, [sp, #128]
7009a5c0: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009a5c4: 9c2d         	ldr	r4, [sp, #0xb4]
7009a5c6: 9d2e         	ldr	r5, [sp, #0xb8]
7009a5c8: 46ee         	mov	lr, sp
7009a5ca: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a5ce: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a5d2: f8ce c000    	str.w	r12, [lr]
7009a5d6: f7ff fd33    	bl	0x7009a040 <_ftoa>      @ imm = #-0x59a
7009a5da: 9027         	str	r0, [sp, #0x9c]
7009a5dc: e1d8         	b	0x7009a990 <_etoa+0x430> @ imm = #0x3b0
;   const bool negative = value < 0;
7009a5de: ed9d 0b20    	vldr	d0, [sp, #128]
7009a5e2: f04f 0000    	mov.w	r0, #0x0
7009a5e6: eeb5 0b40    	vcmp.f64	d0, #0
7009a5ea: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a5ee: bf48         	it	mi
7009a5f0: 2001         	movmi	r0, #0x1
7009a5f2: f88d 007f    	strb.w	r0, [sp, #0x7f]
;   if (negative) {
7009a5f6: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009a5fa: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009a5fe: b138         	cbz	r0, 0x7009a610 <_etoa+0xb0> @ imm = #0xe
7009a600: e7ff         	b	0x7009a602 <_etoa+0xa2> @ imm = #-0x2
;     value = -value;
7009a602: ed9d 0b20    	vldr	d0, [sp, #128]
7009a606: eeb1 0b40    	vneg.f64	d0, d0
7009a60a: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009a60e: e7ff         	b	0x7009a610 <_etoa+0xb0> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009a610: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009a614: 0740         	lsls	r0, r0, #0x1d
7009a616: 2800         	cmp	r0, #0x0
7009a618: d403         	bmi	0x7009a622 <_etoa+0xc2> @ imm = #0x6
7009a61a: e7ff         	b	0x7009a61c <_etoa+0xbc> @ imm = #-0x2
7009a61c: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009a61e: 902c         	str	r0, [sp, #0xb0]
;   }
7009a620: e7ff         	b	0x7009a622 <_etoa+0xc2> @ imm = #-0x2
;   conv.F = value;
7009a622: ed9d 0b20    	vldr	d0, [sp, #128]
7009a626: ed8d 0b1c    	vstr	d0, [sp, #112]
;   int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
7009a62a: 981d         	ldr	r0, [sp, #0x74]
7009a62c: f3c0 500a    	ubfx	r0, r0, #0x14, #0xb
7009a630: f2a0 30ff    	subw	r0, r0, #0x3ff
7009a634: 901b         	str	r0, [sp, #0x6c]
;   conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
7009a636: 981d         	ldr	r0, [sp, #0x74]
7009a638: f240 31ff    	movw	r1, #0x3ff
7009a63c: f361 501f    	bfi	r0, r1, #20, #12
7009a640: 901d         	str	r0, [sp, #0x74]
;   int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
7009a642: ed9d 0a1b    	vldr	s0, [sp, #108]
7009a646: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009a64a: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009a998 <_etoa+0x438>
7009a64e: ee20 0b01    	vmul.f64	d0, d0, d1
7009a652: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009a9a0 <_etoa+0x440>
7009a656: ee30 1b01    	vadd.f64	d1, d0, d1
7009a65a: ed9d 0b1c    	vldr	d0, [sp, #112]
7009a65e: eebf 2b08    	vmov.f64	d2, #-1.500000e+00
7009a662: ee30 0b02    	vadd.f64	d0, d0, d2
7009a666: ed9f 2bd0    	vldr	d2, [pc, #832]          @ 0x7009a9a8 <_etoa+0x448>
7009a66a: ee20 0b02    	vmul.f64	d0, d0, d2
7009a66e: ee30 0b01    	vadd.f64	d0, d0, d1
7009a672: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009a676: ed8d 0a1a    	vstr	s0, [sp, #104]
;   exp2 = (int)(expval * 3.321928094887362 + 0.5);
7009a67a: ed9d 0a1a    	vldr	s0, [sp, #104]
7009a67e: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009a682: ed9f 1bcb    	vldr	d1, [pc, #812]          @ 0x7009a9b0 <_etoa+0x450>
7009a686: ee20 0b01    	vmul.f64	d0, d0, d1
7009a68a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a68e: ee30 0b01    	vadd.f64	d0, d0, d1
7009a692: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009a696: ed8d 0a1b    	vstr	s0, [sp, #108]
;   const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
7009a69a: ed9d 0a1a    	vldr	s0, [sp, #104]
7009a69e: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009a6a2: ed9d 1a1b    	vldr	s2, [sp, #108]
7009a6a6: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009a6aa: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009a9b8 <_etoa+0x458>
7009a6ae: ee21 1b02    	vmul.f64	d1, d1, d2
7009a6b2: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009a9c0 <_etoa+0x460>
7009a6b6: ee20 0b02    	vmul.f64	d0, d0, d2
7009a6ba: ee30 0b01    	vadd.f64	d0, d0, d1
7009a6be: ed8d 0b18    	vstr	d0, [sp, #96]
;   const double z2 = z * z;
7009a6c2: ed9d 0b18    	vldr	d0, [sp, #96]
7009a6c6: ee20 0b00    	vmul.f64	d0, d0, d0
7009a6ca: ed8d 0b16    	vstr	d0, [sp, #88]
;   conv.U = (uint64_t)(exp2 + 1023) << 52U;
7009a6ce: 981b         	ldr	r0, [sp, #0x6c]
7009a6d0: f200 30ff    	addw	r0, r0, #0x3ff
7009a6d4: 0500         	lsls	r0, r0, #0x14
7009a6d6: 2100         	movs	r1, #0x0
7009a6d8: 911c         	str	r1, [sp, #0x70]
7009a6da: 901d         	str	r0, [sp, #0x74]
;   conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
7009a6dc: ed9d 2b18    	vldr	d2, [sp, #96]
7009a6e0: ee32 0b02    	vadd.f64	d0, d2, d2
7009a6e4: eeb0 1b00    	vmov.f64	d1, #2.000000e+00
7009a6e8: ee31 1b42    	vsub.f64	d1, d1, d2
7009a6ec: ed9d 2b16    	vldr	d2, [sp, #88]
7009a6f0: eeb2 3b0c    	vmov.f64	d3, #1.400000e+01
7009a6f4: ee82 3b03    	vdiv.f64	d3, d2, d3
7009a6f8: eeb2 4b04    	vmov.f64	d4, #1.000000e+01
7009a6fc: ee33 3b04    	vadd.f64	d3, d3, d4
7009a700: ee82 3b03    	vdiv.f64	d3, d2, d3
7009a704: eeb1 4b08    	vmov.f64	d4, #6.000000e+00
7009a708: ee33 3b04    	vadd.f64	d3, d3, d4
7009a70c: ee82 2b03    	vdiv.f64	d2, d2, d3
7009a710: ee31 1b02    	vadd.f64	d1, d1, d2
7009a714: ee80 0b01    	vdiv.f64	d0, d0, d1
7009a718: eeb7 1b00    	vmov.f64	d1, #1.000000e+00
7009a71c: ee30 1b01    	vadd.f64	d1, d0, d1
7009a720: ed9d 0b1c    	vldr	d0, [sp, #112]
7009a724: ee20 0b01    	vmul.f64	d0, d0, d1
7009a728: ed8d 0b1c    	vstr	d0, [sp, #112]
;   if (value < conv.F) {
7009a72c: ed9d 0b20    	vldr	d0, [sp, #128]
7009a730: ed9d 1b1c    	vldr	d1, [sp, #112]
7009a734: eeb4 0b41    	vcmp.f64	d0, d1
7009a738: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a73c: d50c         	bpl	0x7009a758 <_etoa+0x1f8> @ imm = #0x18
7009a73e: e7ff         	b	0x7009a740 <_etoa+0x1e0> @ imm = #-0x2
;     expval--;
7009a740: 981a         	ldr	r0, [sp, #0x68]
7009a742: 3801         	subs	r0, #0x1
7009a744: 901a         	str	r0, [sp, #0x68]
;     conv.F /= 10;
7009a746: ed9d 0b1c    	vldr	d0, [sp, #112]
7009a74a: eeb2 1b04    	vmov.f64	d1, #1.000000e+01
7009a74e: ee80 0b01    	vdiv.f64	d0, d0, d1
7009a752: ed8d 0b1c    	vstr	d0, [sp, #112]
;   }
7009a756: e7ff         	b	0x7009a758 <_etoa+0x1f8> @ imm = #-0x2
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009a758: 991a         	ldr	r1, [sp, #0x68]
7009a75a: f04f 0000    	mov.w	r0, #0x0
7009a75e: 2963         	cmp	r1, #0x63
7009a760: 9012         	str	r0, [sp, #0x48]
7009a762: dc08         	bgt	0x7009a776 <_etoa+0x216> @ imm = #0x10
7009a764: e7ff         	b	0x7009a766 <_etoa+0x206> @ imm = #-0x2
7009a766: 991a         	ldr	r1, [sp, #0x68]
7009a768: 2000         	movs	r0, #0x0
7009a76a: f111 0f64    	cmn.w	r1, #0x64
7009a76e: bfc8         	it	gt
7009a770: 2001         	movgt	r0, #0x1
7009a772: 9012         	str	r0, [sp, #0x48]
7009a774: e7ff         	b	0x7009a776 <_etoa+0x216> @ imm = #-0x2
7009a776: 9812         	ldr	r0, [sp, #0x48]
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009a778: 07c1         	lsls	r1, r0, #0x1f
7009a77a: 2005         	movs	r0, #0x5
7009a77c: 2900         	cmp	r1, #0x0
7009a77e: bf18         	it	ne
7009a780: 2004         	movne	r0, #0x4
7009a782: 9015         	str	r0, [sp, #0x54]
;   if (flags & FLAGS_ADAPT_EXP) {
7009a784: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009a788: ea4f 7000    	lsl.w	r0, r0, #0x1c
7009a78c: 2800         	cmp	r0, #0x0
7009a78e: d539         	bpl	0x7009a804 <_etoa+0x2a4> @ imm = #0x72
7009a790: e7ff         	b	0x7009a792 <_etoa+0x232> @ imm = #-0x2
;     if ((value >= 1e-4) && (value < 1e6)) {
7009a792: ed9d 0b20    	vldr	d0, [sp, #128]
7009a796: ed9f 1b8c    	vldr	d1, [pc, #560]          @ 0x7009a9c8 <_etoa+0x468>
7009a79a: eeb4 0b41    	vcmp.f64	d0, d1
7009a79e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a7a2: db20         	blt	0x7009a7e6 <_etoa+0x286> @ imm = #0x40
7009a7a4: e7ff         	b	0x7009a7a6 <_etoa+0x246> @ imm = #-0x2
7009a7a6: ed9d 0b20    	vldr	d0, [sp, #128]
7009a7aa: ed9f 1b89    	vldr	d1, [pc, #548]          @ 0x7009a9d0 <_etoa+0x470>
7009a7ae: eeb4 0b41    	vcmp.f64	d0, d1
7009a7b2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a7b6: d516         	bpl	0x7009a7e6 <_etoa+0x286> @ imm = #0x2c
7009a7b8: e7ff         	b	0x7009a7ba <_etoa+0x25a> @ imm = #-0x2
;       if ((int)prec > expval) {
7009a7ba: 982c         	ldr	r0, [sp, #0xb0]
7009a7bc: 991a         	ldr	r1, [sp, #0x68]
7009a7be: 4288         	cmp	r0, r1
7009a7c0: dd06         	ble	0x7009a7d0 <_etoa+0x270> @ imm = #0xc
7009a7c2: e7ff         	b	0x7009a7c4 <_etoa+0x264> @ imm = #-0x2
;         prec = (unsigned)((int)prec - expval - 1);
7009a7c4: 992c         	ldr	r1, [sp, #0xb0]
7009a7c6: 981a         	ldr	r0, [sp, #0x68]
7009a7c8: 43c0         	mvns	r0, r0
7009a7ca: 4408         	add	r0, r1
7009a7cc: 902c         	str	r0, [sp, #0xb0]
;       }
7009a7ce: e002         	b	0x7009a7d6 <_etoa+0x276> @ imm = #0x4
7009a7d0: 2000         	movs	r0, #0x0
;         prec = 0;
7009a7d2: 902c         	str	r0, [sp, #0xb0]
7009a7d4: e7ff         	b	0x7009a7d6 <_etoa+0x276> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
7009a7d6: 982e         	ldr	r0, [sp, #0xb8]
7009a7d8: f440 6080    	orr	r0, r0, #0x400
7009a7dc: 902e         	str	r0, [sp, #0xb8]
7009a7de: 2000         	movs	r0, #0x0
;       minwidth = 0U;
7009a7e0: 9015         	str	r0, [sp, #0x54]
;       expval   = 0;
7009a7e2: 901a         	str	r0, [sp, #0x68]
;     }
7009a7e4: e00d         	b	0x7009a802 <_etoa+0x2a2> @ imm = #0x1a
;       if ((prec > 0) && (flags & FLAGS_PRECISION)) {
7009a7e6: 982c         	ldr	r0, [sp, #0xb0]
7009a7e8: b150         	cbz	r0, 0x7009a800 <_etoa+0x2a0> @ imm = #0x14
7009a7ea: e7ff         	b	0x7009a7ec <_etoa+0x28c> @ imm = #-0x2
7009a7ec: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009a7f0: 0740         	lsls	r0, r0, #0x1d
7009a7f2: 2800         	cmp	r0, #0x0
7009a7f4: d504         	bpl	0x7009a800 <_etoa+0x2a0> @ imm = #0x8
7009a7f6: e7ff         	b	0x7009a7f8 <_etoa+0x298> @ imm = #-0x2
;         --prec;
7009a7f8: 982c         	ldr	r0, [sp, #0xb0]
7009a7fa: 3801         	subs	r0, #0x1
7009a7fc: 902c         	str	r0, [sp, #0xb0]
;       }
7009a7fe: e7ff         	b	0x7009a800 <_etoa+0x2a0> @ imm = #-0x2
7009a800: e7ff         	b	0x7009a802 <_etoa+0x2a2> @ imm = #-0x2
;   }
7009a802: e7ff         	b	0x7009a804 <_etoa+0x2a4> @ imm = #-0x2
;   unsigned int fwidth = width;
7009a804: 982d         	ldr	r0, [sp, #0xb4]
7009a806: 9014         	str	r0, [sp, #0x50]
;   if (width > minwidth) {
7009a808: 982d         	ldr	r0, [sp, #0xb4]
7009a80a: 9915         	ldr	r1, [sp, #0x54]
7009a80c: 4288         	cmp	r0, r1
7009a80e: d905         	bls	0x7009a81c <_etoa+0x2bc> @ imm = #0xa
7009a810: e7ff         	b	0x7009a812 <_etoa+0x2b2> @ imm = #-0x2
;     fwidth -= minwidth;
7009a812: 9915         	ldr	r1, [sp, #0x54]
7009a814: 9814         	ldr	r0, [sp, #0x50]
7009a816: 1a40         	subs	r0, r0, r1
7009a818: 9014         	str	r0, [sp, #0x50]
;   } else {
7009a81a: e002         	b	0x7009a822 <_etoa+0x2c2> @ imm = #0x4
7009a81c: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009a81e: 9014         	str	r0, [sp, #0x50]
7009a820: e7ff         	b	0x7009a822 <_etoa+0x2c2> @ imm = #-0x2
;   if ((flags & FLAGS_LEFT) && minwidth) {
7009a822: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009a826: 0780         	lsls	r0, r0, #0x1e
7009a828: 2800         	cmp	r0, #0x0
7009a82a: d506         	bpl	0x7009a83a <_etoa+0x2da> @ imm = #0xc
7009a82c: e7ff         	b	0x7009a82e <_etoa+0x2ce> @ imm = #-0x2
7009a82e: 9815         	ldr	r0, [sp, #0x54]
7009a830: b118         	cbz	r0, 0x7009a83a <_etoa+0x2da> @ imm = #0x6
7009a832: e7ff         	b	0x7009a834 <_etoa+0x2d4> @ imm = #-0x2
7009a834: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009a836: 9014         	str	r0, [sp, #0x50]
;   }
7009a838: e7ff         	b	0x7009a83a <_etoa+0x2da> @ imm = #-0x2
;   if (expval) {
7009a83a: 981a         	ldr	r0, [sp, #0x68]
7009a83c: b148         	cbz	r0, 0x7009a852 <_etoa+0x2f2> @ imm = #0x12
7009a83e: e7ff         	b	0x7009a840 <_etoa+0x2e0> @ imm = #-0x2
;     value /= conv.F;
7009a840: ed9d 1b1c    	vldr	d1, [sp, #112]
7009a844: ed9d 0b20    	vldr	d0, [sp, #128]
7009a848: ee80 0b01    	vdiv.f64	d0, d0, d1
7009a84c: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009a850: e7ff         	b	0x7009a852 <_etoa+0x2f2> @ imm = #-0x2
;   const size_t start_idx = idx;
7009a852: 9824         	ldr	r0, [sp, #0x90]
7009a854: 9013         	str	r0, [sp, #0x4c]
;   idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
7009a856: 9826         	ldr	r0, [sp, #0x98]
7009a858: 900e         	str	r0, [sp, #0x38]
7009a85a: 9825         	ldr	r0, [sp, #0x94]
7009a85c: 900f         	str	r0, [sp, #0x3c]
7009a85e: 9824         	ldr	r0, [sp, #0x90]
7009a860: 9010         	str	r0, [sp, #0x40]
7009a862: 9823         	ldr	r0, [sp, #0x8c]
7009a864: 9011         	str	r0, [sp, #0x44]
7009a866: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009a86a: 07c0         	lsls	r0, r0, #0x1f
7009a86c: b138         	cbz	r0, 0x7009a87e <_etoa+0x31e> @ imm = #0xe
7009a86e: e7ff         	b	0x7009a870 <_etoa+0x310> @ imm = #-0x2
7009a870: ed9d 0b20    	vldr	d0, [sp, #128]
7009a874: eeb1 0b40    	vneg.f64	d0, d0
7009a878: ed8d 0b0c    	vstr	d0, [sp, #48]
7009a87c: e004         	b	0x7009a888 <_etoa+0x328> @ imm = #0x8
7009a87e: ed9d 0b20    	vldr	d0, [sp, #128]
7009a882: ed8d 0b0c    	vstr	d0, [sp, #48]
7009a886: e7ff         	b	0x7009a888 <_etoa+0x328> @ imm = #-0x2
7009a888: 9b11         	ldr	r3, [sp, #0x44]
7009a88a: 9a10         	ldr	r2, [sp, #0x40]
7009a88c: 990f         	ldr	r1, [sp, #0x3c]
7009a88e: 980e         	ldr	r0, [sp, #0x38]
7009a890: ed9d 0b0c    	vldr	d0, [sp, #48]
7009a894: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009a898: 9c14         	ldr	r4, [sp, #0x50]
7009a89a: f8dd e0b8    	ldr.w	lr, [sp, #0xb8]
7009a89e: f42e 6500    	bic	r5, lr, #0x800
7009a8a2: 46ee         	mov	lr, sp
7009a8a4: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a8a8: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a8ac: f8ce c000    	str.w	r12, [lr]
7009a8b0: f7ff fbc6    	bl	0x7009a040 <_ftoa>      @ imm = #-0x874
7009a8b4: 9024         	str	r0, [sp, #0x90]
;   if (minwidth) {
7009a8b6: 9815         	ldr	r0, [sp, #0x54]
7009a8b8: 2800         	cmp	r0, #0x0
7009a8ba: d066         	beq	0x7009a98a <_etoa+0x42a> @ imm = #0xcc
7009a8bc: e7ff         	b	0x7009a8be <_etoa+0x35e> @ imm = #-0x2
;     out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
7009a8be: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009a8c2: 982e         	ldr	r0, [sp, #0xb8]
7009a8c4: 0681         	lsls	r1, r0, #0x1a
7009a8c6: 2065         	movs	r0, #0x65
7009a8c8: 2900         	cmp	r1, #0x0
7009a8ca: bf48         	it	mi
7009a8cc: 2045         	movmi	r0, #0x45
7009a8ce: 9925         	ldr	r1, [sp, #0x94]
7009a8d0: 9a24         	ldr	r2, [sp, #0x90]
7009a8d2: 1c53         	adds	r3, r2, #0x1
7009a8d4: 9324         	str	r3, [sp, #0x90]
7009a8d6: 9b23         	ldr	r3, [sp, #0x8c]
7009a8d8: 47e0         	blx	r12
;     idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
7009a8da: 9826         	ldr	r0, [sp, #0x98]
7009a8dc: 9008         	str	r0, [sp, #0x20]
7009a8de: 9825         	ldr	r0, [sp, #0x94]
7009a8e0: 9009         	str	r0, [sp, #0x24]
7009a8e2: 9824         	ldr	r0, [sp, #0x90]
7009a8e4: 900a         	str	r0, [sp, #0x28]
7009a8e6: 9823         	ldr	r0, [sp, #0x8c]
7009a8e8: 900b         	str	r0, [sp, #0x2c]
7009a8ea: 981a         	ldr	r0, [sp, #0x68]
7009a8ec: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009a8f0: dc0e         	bgt	0x7009a910 <_etoa+0x3b0> @ imm = #0x1c
7009a8f2: e7ff         	b	0x7009a8f4 <_etoa+0x394> @ imm = #-0x2
7009a8f4: 981a         	ldr	r0, [sp, #0x68]
7009a8f6: 4240         	rsbs	r0, r0, #0
7009a8f8: 9007         	str	r0, [sp, #0x1c]
7009a8fa: e00c         	b	0x7009a916 <_etoa+0x3b6> @ imm = #0x18
7009a8fc: bf00         	nop
7009a8fe: bf00         	nop
7009a900: ff ff ff ff  	.word	0xffffffff
7009a904: ff ff ef 7f  	.word	0x7fefffff
7009a908: ff ff ff ff  	.word	0xffffffff
7009a90c: ff ff ef ff  	.word	0xffefffff
7009a910: 981a         	ldr	r0, [sp, #0x68]
7009a912: 9007         	str	r0, [sp, #0x1c]
7009a914: e7ff         	b	0x7009a916 <_etoa+0x3b6> @ imm = #-0x2
7009a916: 9b0b         	ldr	r3, [sp, #0x2c]
7009a918: 9a0a         	ldr	r2, [sp, #0x28]
7009a91a: 9909         	ldr	r1, [sp, #0x24]
7009a91c: 9808         	ldr	r0, [sp, #0x20]
7009a91e: f8dd c01c    	ldr.w	r12, [sp, #0x1c]
7009a922: 9c1a         	ldr	r4, [sp, #0x68]
7009a924: f8dd e054    	ldr.w	lr, [sp, #0x54]
7009a928: f1ae 0501    	sub.w	r5, lr, #0x1
7009a92c: 46ee         	mov	lr, sp
7009a92e: 2605         	movs	r6, #0x5
7009a930: f8ce 6014    	str.w	r6, [lr, #0x14]
7009a934: f8ce 5010    	str.w	r5, [lr, #0x10]
7009a938: 2500         	movs	r5, #0x0
7009a93a: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a93e: 250a         	movs	r5, #0xa
7009a940: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a944: ea4f 74d4    	lsr.w	r4, r4, #0x1f
7009a948: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a94c: f8ce c000    	str.w	r12, [lr]
7009a950: f008 fc06    	bl	0x700a3160 <_ntoa_long> @ imm = #0x880c
7009a954: 9024         	str	r0, [sp, #0x90]
;     if (flags & FLAGS_LEFT) {
7009a956: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009a95a: 0780         	lsls	r0, r0, #0x1e
7009a95c: 2800         	cmp	r0, #0x0
7009a95e: d513         	bpl	0x7009a988 <_etoa+0x428> @ imm = #0x26
7009a960: e7ff         	b	0x7009a962 <_etoa+0x402> @ imm = #-0x2
;       while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
7009a962: e7ff         	b	0x7009a964 <_etoa+0x404> @ imm = #-0x2
7009a964: 9824         	ldr	r0, [sp, #0x90]
7009a966: 9913         	ldr	r1, [sp, #0x4c]
7009a968: 1a40         	subs	r0, r0, r1
7009a96a: 992d         	ldr	r1, [sp, #0xb4]
7009a96c: 4288         	cmp	r0, r1
7009a96e: d20a         	bhs	0x7009a986 <_etoa+0x426> @ imm = #0x14
7009a970: e7ff         	b	0x7009a972 <_etoa+0x412> @ imm = #-0x2
7009a972: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009a976: 9925         	ldr	r1, [sp, #0x94]
7009a978: 9a24         	ldr	r2, [sp, #0x90]
7009a97a: 1c50         	adds	r0, r2, #0x1
7009a97c: 9024         	str	r0, [sp, #0x90]
7009a97e: 9b23         	ldr	r3, [sp, #0x8c]
7009a980: 2020         	movs	r0, #0x20
7009a982: 47e0         	blx	r12
7009a984: e7ee         	b	0x7009a964 <_etoa+0x404> @ imm = #-0x24
;     }
7009a986: e7ff         	b	0x7009a988 <_etoa+0x428> @ imm = #-0x2
;   }
7009a988: e7ff         	b	0x7009a98a <_etoa+0x42a> @ imm = #-0x2
;   return idx;
7009a98a: 9824         	ldr	r0, [sp, #0x90]
7009a98c: 9027         	str	r0, [sp, #0x9c]
7009a98e: e7ff         	b	0x7009a990 <_etoa+0x430> @ imm = #-0x2
; }
7009a990: 9827         	ldr	r0, [sp, #0x9c]
7009a992: b028         	add	sp, #0xa0
7009a994: bd70         	pop	{r4, r5, r6, pc}
7009a996: bf00         	nop
7009a998: fb 79 9f 50  	.word	0x509f79fb
7009a99c: 13 44 d3 3f  	.word	0x3fd34413
7009a9a0: b3 c8 60 8b  	.word	0x8b60c8b3
7009a9a4: 28 8a c6 3f  	.word	0x3fc68a28
7009a9a8: 61 43 6f 63  	.word	0x636f4361
7009a9ac: a7 87 d2 3f  	.word	0x3fd287a7
7009a9b0: 71 a3 79 09  	.word	0x0979a371
7009a9b4: 4f 93 0a 40  	.word	0x400a934f
7009a9b8: ef 39 fa fe  	.word	0xfefa39ef
7009a9bc: 42 2e e6 bf  	.word	0xbfe62e42
7009a9c0: 16 55 b5 bb  	.word	0xbbb55516
7009a9c4: b1 6b 02 40  	.word	0x40026bb1
7009a9c8: 2d 43 1c eb  	.word	0xeb1c432d
7009a9cc: e2 36 1a 3f  	.word	0x3f1a36e2
7009a9d0: 00 00 00 00  	.word	0x00000000
7009a9d4: 80 84 2e 41  	.word	0x412e8480

7009a9d8 <__aeabi_ldiv0>:
7009a9d8: e12fff1e     	bx	lr

7009a9dc <__aeabi_memcpy8>:
7009a9dc: ea004a5e     	b	0x700ad35c <TI_memcpy_small> @ imm = #0x12978

7009a9e0 <UART_open>:
; {
7009a9e0: b580         	push	{r7, lr}
7009a9e2: b092         	sub	sp, #0x48
7009a9e4: 9011         	str	r0, [sp, #0x44]
7009a9e6: 9110         	str	r1, [sp, #0x40]
7009a9e8: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS;
7009a9ea: 900f         	str	r0, [sp, #0x3c]
;     UART_Handle         handle = NULL;
7009a9ec: 900e         	str	r0, [sp, #0x38]
;     UART_Config        *config = NULL;
7009a9ee: 900d         	str	r0, [sp, #0x34]
;     UART_Object        *object    = NULL;
7009a9f0: 900c         	str	r0, [sp, #0x30]
;     if(index >= gUartConfigNum)
7009a9f2: 9811         	ldr	r0, [sp, #0x44]
7009a9f4: f240 41cc    	movw	r1, #0x4cc
7009a9f8: f2c7 010b    	movt	r1, #0x700b
7009a9fc: 6809         	ldr	r1, [r1]
7009a9fe: 4288         	cmp	r0, r1
7009aa00: d304         	blo	0x7009aa0c <UART_open+0x2c> @ imm = #0x8
7009aa02: e7ff         	b	0x7009aa04 <UART_open+0x24> @ imm = #-0x2
7009aa04: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009aa08: 900f         	str	r0, [sp, #0x3c]
;     }
7009aa0a: e008         	b	0x7009aa1e <UART_open+0x3e> @ imm = #0x10
;         config = &gUartConfig[index];
7009aa0c: 9911         	ldr	r1, [sp, #0x44]
7009aa0e: f240 4088    	movw	r0, #0x488
7009aa12: f2c7 000b    	movt	r0, #0x700b
7009aa16: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009aa1a: 900d         	str	r0, [sp, #0x34]
7009aa1c: e7ff         	b	0x7009aa1e <UART_open+0x3e> @ imm = #-0x2
;     DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009aa1e: f240 2130    	movw	r1, #0x230
7009aa22: f2c7 010b    	movt	r1, #0x700b
7009aa26: f851 0b04    	ldr	r0, [r1], #4
7009aa2a: 9103         	str	r1, [sp, #0xc]
7009aa2c: 2800         	cmp	r0, #0x0
7009aa2e: bf18         	it	ne
7009aa30: 2001         	movne	r0, #0x1
7009aa32: f64f 1188    	movw	r1, #0xf988
7009aa36: f2c7 010a    	movt	r1, #0x700a
7009aa3a: 466a         	mov	r2, sp
7009aa3c: 6011         	str	r1, [r2]
7009aa3e: f64f 3182    	movw	r1, #0xfb82
7009aa42: f2c7 010a    	movt	r1, #0x700a
7009aa46: f64f 4282    	movw	r2, #0xfc82
7009aa4a: f2c7 020a    	movt	r2, #0x700a
7009aa4e: f240 1301    	movw	r3, #0x101
7009aa52: f00e f8e5    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xe1ca
7009aa56: 9803         	ldr	r0, [sp, #0xc]
7009aa58: f04f 31ff    	mov.w	r1, #0xffffffff
;     (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009aa5c: f00d fe48    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0xdc90
;     if(SystemP_SUCCESS  == status)
7009aa60: 980f         	ldr	r0, [sp, #0x3c]
7009aa62: bb38         	cbnz	r0, 0x7009aab4 <UART_open+0xd4> @ imm = #0x4e
7009aa64: e7ff         	b	0x7009aa66 <UART_open+0x86> @ imm = #-0x2
;         object = config->object;
7009aa66: 980d         	ldr	r0, [sp, #0x34]
7009aa68: 6840         	ldr	r0, [r0, #0x4]
7009aa6a: 900c         	str	r0, [sp, #0x30]
;         attrs  = config->attrs;
7009aa6c: 980d         	ldr	r0, [sp, #0x34]
7009aa6e: 6800         	ldr	r0, [r0]
7009aa70: 900b         	str	r0, [sp, #0x2c]
;         DebugP_assert(NULL_PTR != object);
7009aa72: 980c         	ldr	r0, [sp, #0x30]
7009aa74: 2800         	cmp	r0, #0x0
7009aa76: bf18         	it	ne
7009aa78: 2001         	movne	r0, #0x1
7009aa7a: f64f 316f    	movw	r1, #0xfb6f
7009aa7e: f2c7 010a    	movt	r1, #0x700a
7009aa82: 466a         	mov	r2, sp
7009aa84: 6011         	str	r1, [r2]
7009aa86: f64f 3182    	movw	r1, #0xfb82
7009aa8a: f2c7 010a    	movt	r1, #0x700a
7009aa8e: f64f 4282    	movw	r2, #0xfc82
7009aa92: f2c7 020a    	movt	r2, #0x700a
7009aa96: f44f 7384    	mov.w	r3, #0x108
7009aa9a: f00e f8c1    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xe182
;         if(TRUE == object->isOpen)
7009aa9e: 980c         	ldr	r0, [sp, #0x30]
7009aaa0: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009aaa4: 2801         	cmp	r0, #0x1
7009aaa6: d104         	bne	0x7009aab2 <UART_open+0xd2> @ imm = #0x8
7009aaa8: e7ff         	b	0x7009aaaa <UART_open+0xca> @ imm = #-0x2
7009aaaa: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009aaae: 900f         	str	r0, [sp, #0x3c]
;         }
7009aab0: e7ff         	b	0x7009aab2 <UART_open+0xd2> @ imm = #-0x2
;     }
7009aab2: e7ff         	b	0x7009aab4 <UART_open+0xd4> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009aab4: 980f         	ldr	r0, [sp, #0x3c]
7009aab6: 2800         	cmp	r0, #0x0
7009aab8: f040 80cd    	bne.w	0x7009ac56 <UART_open+0x276> @ imm = #0x19a
7009aabc: e7ff         	b	0x7009aabe <UART_open+0xde> @ imm = #-0x2
;         object->handle = (UART_Handle) config;
7009aabe: 980d         	ldr	r0, [sp, #0x34]
7009aac0: 990c         	ldr	r1, [sp, #0x30]
7009aac2: 6008         	str	r0, [r1]
;         if(NULL != prms)
7009aac4: 9810         	ldr	r0, [sp, #0x40]
7009aac6: b138         	cbz	r0, 0x7009aad8 <UART_open+0xf8> @ imm = #0xe
7009aac8: e7ff         	b	0x7009aaca <UART_open+0xea> @ imm = #-0x2
;             ( void )memcpy(&object->prms, prms, sizeof(UART_Params));
7009aaca: 980c         	ldr	r0, [sp, #0x30]
7009aacc: 3004         	adds	r0, #0x4
7009aace: 9910         	ldr	r1, [sp, #0x40]
7009aad0: 2258         	movs	r2, #0x58
7009aad2: f7ff ef84    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0xf8
;         }
7009aad6: e004         	b	0x7009aae2 <UART_open+0x102> @ imm = #0x8
;             UART_Params_init(&object->prms);
7009aad8: 980c         	ldr	r0, [sp, #0x30]
7009aada: 3004         	adds	r0, #0x4
7009aadc: f00e f920    	bl	0x700a8d20 <UART_Params_init> @ imm = #0xe240
7009aae0: e7ff         	b	0x7009aae2 <UART_open+0x102> @ imm = #-0x2
;         object->uartLld_handle             = &object->uartLld_object;
7009aae2: 990c         	ldr	r1, [sp, #0x30]
7009aae4: f501 7022    	add.w	r0, r1, #0x288
7009aae8: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle                     = object->uartLld_handle;
7009aaec: 980c         	ldr	r0, [sp, #0x30]
7009aaee: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009aaf2: 9005         	str	r0, [sp, #0x14]
;         object->uartLld_initHandle         = &object->uartLld_initObject;
7009aaf4: 990c         	ldr	r1, [sp, #0x30]
7009aaf6: f501 7040    	add.w	r0, r1, #0x300
7009aafa: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;         uartLldInit_handle                 = object->uartLld_initHandle;
7009aafe: 980c         	ldr	r0, [sp, #0x30]
7009ab00: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
7009ab04: 9004         	str	r0, [sp, #0x10]
;         uartLld_handle->hUartInit          = uartLldInit_handle;
7009ab06: 9804         	ldr	r0, [sp, #0x10]
7009ab08: 9905         	ldr	r1, [sp, #0x14]
7009ab0a: 6048         	str	r0, [r1, #0x4]
;         uartLld_handle->baseAddr           = attrs->baseAddr;
7009ab0c: 980b         	ldr	r0, [sp, #0x2c]
7009ab0e: 6800         	ldr	r0, [r0]
7009ab10: 9905         	ldr	r1, [sp, #0x14]
7009ab12: 6008         	str	r0, [r1]
;         uartLld_handle->args               = (void *)object->handle;
7009ab14: 980c         	ldr	r0, [sp, #0x30]
7009ab16: 6800         	ldr	r0, [r0]
7009ab18: 9905         	ldr	r1, [sp, #0x14]
7009ab1a: 6608         	str	r0, [r1, #0x60]
;         uartLld_handle->writeBuf           = object->writeBuf;
7009ab1c: 980c         	ldr	r0, [sp, #0x30]
7009ab1e: 6dc0         	ldr	r0, [r0, #0x5c]
7009ab20: 9905         	ldr	r1, [sp, #0x14]
7009ab22: 6088         	str	r0, [r1, #0x8]
;         uartLld_handle->writeCount         = object->writeCount;
7009ab24: 980c         	ldr	r0, [sp, #0x30]
7009ab26: 6e00         	ldr	r0, [r0, #0x60]
7009ab28: 9905         	ldr	r1, [sp, #0x14]
7009ab2a: 60c8         	str	r0, [r1, #0xc]
;         uartLld_handle->writeSizeRemaining = object->writeSizeRemaining;
7009ab2c: 980c         	ldr	r0, [sp, #0x30]
7009ab2e: 6e40         	ldr	r0, [r0, #0x64]
7009ab30: 9905         	ldr	r1, [sp, #0x14]
7009ab32: 6108         	str	r0, [r1, #0x10]
;         uartLld_handle->readBuf            = object->readBuf;
7009ab34: 980c         	ldr	r0, [sp, #0x30]
7009ab36: 6e80         	ldr	r0, [r0, #0x68]
7009ab38: 9905         	ldr	r1, [sp, #0x14]
7009ab3a: 6148         	str	r0, [r1, #0x14]
;         uartLld_handle->readCount          = object->readCount;
7009ab3c: 980c         	ldr	r0, [sp, #0x30]
7009ab3e: 6ec0         	ldr	r0, [r0, #0x6c]
7009ab40: 9905         	ldr	r1, [sp, #0x14]
7009ab42: 6188         	str	r0, [r1, #0x18]
;         uartLld_handle->readSizeRemaining  = object->readSizeRemaining;
7009ab44: 980c         	ldr	r0, [sp, #0x30]
7009ab46: 6f00         	ldr	r0, [r0, #0x70]
7009ab48: 9905         	ldr	r1, [sp, #0x14]
7009ab4a: 61c8         	str	r0, [r1, #0x1c]
;         uartLld_handle->rxTimeoutCnt       = object->rxTimeoutCnt;
7009ab4c: 980c         	ldr	r0, [sp, #0x30]
7009ab4e: 6f40         	ldr	r0, [r0, #0x74]
7009ab50: 9905         	ldr	r1, [sp, #0x14]
7009ab52: 6208         	str	r0, [r1, #0x20]
;         uartLld_handle->readErrorCnt       = object->readErrorCnt;
7009ab54: 980c         	ldr	r0, [sp, #0x30]
7009ab56: 6f80         	ldr	r0, [r0, #0x78]
7009ab58: 9905         	ldr	r1, [sp, #0x14]
7009ab5a: 6248         	str	r0, [r1, #0x24]
;         uartLld_handle->state              = UART_STATE_RESET;
7009ab5c: 9905         	ldr	r1, [sp, #0x14]
7009ab5e: 2000         	movs	r0, #0x0
7009ab60: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->inputClkFreq      = attrs->inputClkFreq;
7009ab62: 990b         	ldr	r1, [sp, #0x2c]
7009ab64: 6849         	ldr	r1, [r1, #0x4]
7009ab66: 9a04         	ldr	r2, [sp, #0x10]
7009ab68: 6011         	str	r1, [r2]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009ab6a: 990c         	ldr	r1, [sp, #0x30]
7009ab6c: 6849         	ldr	r1, [r1, #0x4]
7009ab6e: 9a04         	ldr	r2, [sp, #0x10]
7009ab70: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009ab72: 990c         	ldr	r1, [sp, #0x30]
7009ab74: 6849         	ldr	r1, [r1, #0x4]
7009ab76: 9a04         	ldr	r2, [sp, #0x10]
7009ab78: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->dataLength        = object->prms.dataLength;
7009ab7a: 990c         	ldr	r1, [sp, #0x30]
7009ab7c: 6889         	ldr	r1, [r1, #0x8]
7009ab7e: 9a04         	ldr	r2, [sp, #0x10]
7009ab80: 6091         	str	r1, [r2, #0x8]
;         uartLldInit_handle->stopBits          = object->prms.stopBits;
7009ab82: 990c         	ldr	r1, [sp, #0x30]
7009ab84: 68c9         	ldr	r1, [r1, #0xc]
7009ab86: 9a04         	ldr	r2, [sp, #0x10]
7009ab88: 60d1         	str	r1, [r2, #0xc]
;         uartLldInit_handle->parityType        = object->prms.parityType;
7009ab8a: 990c         	ldr	r1, [sp, #0x30]
7009ab8c: 6909         	ldr	r1, [r1, #0x10]
7009ab8e: 9a04         	ldr	r2, [sp, #0x10]
7009ab90: 6111         	str	r1, [r2, #0x10]
;         uartLldInit_handle->readReturnMode    = object->prms.readReturnMode;
7009ab92: 990c         	ldr	r1, [sp, #0x30]
7009ab94: 6989         	ldr	r1, [r1, #0x18]
7009ab96: 9a04         	ldr	r2, [sp, #0x10]
7009ab98: 6151         	str	r1, [r2, #0x14]
;         uartLldInit_handle->hwFlowControl     = object->prms.hwFlowControl;
7009ab9a: 990c         	ldr	r1, [sp, #0x30]
7009ab9c: 6a89         	ldr	r1, [r1, #0x28]
7009ab9e: 9a04         	ldr	r2, [sp, #0x10]
7009aba0: 6191         	str	r1, [r2, #0x18]
;         uartLldInit_handle->hwFlowControlThr  = object->prms.hwFlowControlThr;
7009aba2: 990c         	ldr	r1, [sp, #0x30]
7009aba4: 6ac9         	ldr	r1, [r1, #0x2c]
7009aba6: 9a04         	ldr	r2, [sp, #0x10]
7009aba8: 61d1         	str	r1, [r2, #0x1c]
;         uartLldInit_handle->intrNum           = object->prms.intrNum;
7009abaa: 990c         	ldr	r1, [sp, #0x30]
7009abac: 6b49         	ldr	r1, [r1, #0x34]
7009abae: 9a04         	ldr	r2, [sp, #0x10]
7009abb0: 6251         	str	r1, [r2, #0x24]
;         uartLldInit_handle->transferMode      = object->prms.transferMode;
7009abb2: 990c         	ldr	r1, [sp, #0x30]
7009abb4: 6b09         	ldr	r1, [r1, #0x30]
7009abb6: 9a04         	ldr	r2, [sp, #0x10]
7009abb8: 6211         	str	r1, [r2, #0x20]
;         uartLldInit_handle->intrPriority      = object->prms.intrPriority;
7009abba: 990c         	ldr	r1, [sp, #0x30]
7009abbc: f891 1038    	ldrb.w	r1, [r1, #0x38]
7009abc0: 9a04         	ldr	r2, [sp, #0x10]
7009abc2: f882 1028    	strb.w	r1, [r2, #0x28]
;         uartLldInit_handle->operMode          = object->prms.operMode;
7009abc6: 990c         	ldr	r1, [sp, #0x30]
7009abc8: 6c49         	ldr	r1, [r1, #0x44]
7009abca: 9a04         	ldr	r2, [sp, #0x10]
7009abcc: 62d1         	str	r1, [r2, #0x2c]
;         uartLldInit_handle->rxTrigLvl         = object->prms.rxTrigLvl;
7009abce: 990c         	ldr	r1, [sp, #0x30]
7009abd0: 6c89         	ldr	r1, [r1, #0x48]
7009abd2: 9a04         	ldr	r2, [sp, #0x10]
7009abd4: 6391         	str	r1, [r2, #0x38]
;         uartLldInit_handle->txTrigLvl         = object->prms.txTrigLvl;
7009abd6: 990c         	ldr	r1, [sp, #0x30]
7009abd8: 6cc9         	ldr	r1, [r1, #0x4c]
7009abda: 9a04         	ldr	r2, [sp, #0x10]
7009abdc: 63d1         	str	r1, [r2, #0x3c]
;         uartLldInit_handle->uartDmaHandle     = NULL;
7009abde: 9904         	ldr	r1, [sp, #0x10]
7009abe0: 6488         	str	r0, [r1, #0x48]
;         uartLldInit_handle->dmaChCfg          = NULL;
7009abe2: 9904         	ldr	r1, [sp, #0x10]
7009abe4: 64c8         	str	r0, [r1, #0x4c]
;         uartLldInit_handle->rxEvtNum          = object->prms.rxEvtNum;
7009abe6: 980c         	ldr	r0, [sp, #0x30]
7009abe8: 6d00         	ldr	r0, [r0, #0x50]
7009abea: 9904         	ldr	r1, [sp, #0x10]
7009abec: 6408         	str	r0, [r1, #0x40]
;         uartLldInit_handle->txEvtNum          = object->prms.txEvtNum;
7009abee: 980c         	ldr	r0, [sp, #0x30]
7009abf0: 6d40         	ldr	r0, [r0, #0x54]
7009abf2: 9904         	ldr	r1, [sp, #0x10]
7009abf4: 6448         	str	r0, [r1, #0x44]
;         uartLldInit_handle->writeMode         = object->prms.writeMode;
7009abf6: 980c         	ldr	r0, [sp, #0x30]
7009abf8: 69c0         	ldr	r0, [r0, #0x1c]
7009abfa: 9904         	ldr	r1, [sp, #0x10]
7009abfc: 6348         	str	r0, [r1, #0x34]
;         uartLldInit_handle->readMode          = object->prms.readMode;
7009abfe: 980c         	ldr	r0, [sp, #0x30]
7009ac00: 6940         	ldr	r0, [r0, #0x14]
7009ac02: 9904         	ldr	r1, [sp, #0x10]
7009ac04: 6308         	str	r0, [r1, #0x30]
;         uartLldInit_handle->timeGuardVal      = object->prms.timeGuardVal;
7009ac06: 980c         	ldr	r0, [sp, #0x30]
7009ac08: 6d80         	ldr	r0, [r0, #0x58]
7009ac0a: 9904         	ldr	r1, [sp, #0x10]
7009ac0c: 6508         	str	r0, [r1, #0x50]
;         uartLldInit_handle->clockP_get        = ClockP_getTicks;
7009ac0e: 9904         	ldr	r1, [sp, #0x10]
7009ac10: f64d 2041    	movw	r0, #0xda41
7009ac14: f2c7 000a    	movt	r0, #0x700a
7009ac18: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->clockP_usecToTick = ClockP_usecToTicks;
7009ac1a: 9904         	ldr	r1, [sp, #0x10]
7009ac1c: f24d 00e1    	movw	r0, #0xd0e1
7009ac20: f2c7 000a    	movt	r0, #0x700a
7009ac24: 6588         	str	r0, [r1, #0x58]
;         uartLldInit_handle->readCompleteCallbackFxn =  UART_lld_readCompleteCallback;
7009ac26: 9904         	ldr	r1, [sp, #0x10]
7009ac28: f24a 6031    	movw	r0, #0xa631
7009ac2c: f2c7 000a    	movt	r0, #0x700a
7009ac30: 65c8         	str	r0, [r1, #0x5c]
;         uartLldInit_handle->writeCompleteCallbackFxn = UART_lld_writeCompleteCallback;
7009ac32: 9904         	ldr	r1, [sp, #0x10]
7009ac34: f24a 5071    	movw	r0, #0xa571
7009ac38: f2c7 000a    	movt	r0, #0x700a
7009ac3c: 6608         	str	r0, [r1, #0x60]
;         uartLldInit_handle->errorCallbackFxn =         UART_lld_errorCallback;
7009ac3e: 9904         	ldr	r1, [sp, #0x10]
7009ac40: f64d 2051    	movw	r0, #0xda51
7009ac44: f2c7 000a    	movt	r0, #0x700a
7009ac48: 6648         	str	r0, [r1, #0x64]
;         status = UART_checkOpenParams(&object->prms);
7009ac4a: 980c         	ldr	r0, [sp, #0x30]
7009ac4c: 3004         	adds	r0, #0x4
7009ac4e: f010 fe4f    	bl	0x700ab8f0 <UART_checkOpenParams> @ imm = #0x10c9e
7009ac52: 900f         	str	r0, [sp, #0x3c]
;     }
7009ac54: e7ff         	b	0x7009ac56 <UART_open+0x276> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009ac56: 980f         	ldr	r0, [sp, #0x3c]
7009ac58: 2800         	cmp	r0, #0x0
7009ac5a: f040 80b8    	bne.w	0x7009adce <UART_open+0x3ee> @ imm = #0x170
7009ac5e: e7ff         	b	0x7009ac60 <UART_open+0x280> @ imm = #-0x2
;         uartLld_handle->state = UART_STATE_RESET;
7009ac60: 9905         	ldr	r1, [sp, #0x14]
7009ac62: 2000         	movs	r0, #0x0
7009ac64: 6548         	str	r0, [r1, #0x54]
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009ac66: 980c         	ldr	r0, [sp, #0x30]
7009ac68: 6b00         	ldr	r0, [r0, #0x30]
7009ac6a: 2803         	cmp	r0, #0x3
7009ac6c: d117         	bne	0x7009ac9e <UART_open+0x2be> @ imm = #0x2e
7009ac6e: e7ff         	b	0x7009ac70 <UART_open+0x290> @ imm = #-0x2
;             uartLldInit_handle->uartDmaHandle = (UART_DmaHandle) gUartDmaHandle[index];
7009ac70: 9911         	ldr	r1, [sp, #0x44]
7009ac72: f240 1078    	movw	r0, #0x178
7009ac76: f2c7 000b    	movt	r0, #0x700b
7009ac7a: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009ac7e: 9904         	ldr	r1, [sp, #0x10]
7009ac80: 6488         	str	r0, [r1, #0x48]
;             uartLldInit_handle->dmaChCfg      = gUartDmaChConfig[index];
7009ac82: 9911         	ldr	r1, [sp, #0x44]
7009ac84: f240 40d0    	movw	r0, #0x4d0
7009ac88: f2c7 000b    	movt	r0, #0x700b
7009ac8c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009ac90: 9904         	ldr	r1, [sp, #0x10]
7009ac92: 64c8         	str	r0, [r1, #0x4c]
;             status = UART_lld_initDma(uartLld_handle);
7009ac94: 9805         	ldr	r0, [sp, #0x14]
7009ac96: f005 fafb    	bl	0x700a0290 <UART_lld_initDma> @ imm = #0x55f6
7009ac9a: 900f         	str	r0, [sp, #0x3c]
;         }
7009ac9c: e008         	b	0x7009acb0 <UART_open+0x2d0> @ imm = #0x10
;             status = UART_lld_init(uartLld_handle);
7009ac9e: 9805         	ldr	r0, [sp, #0x14]
7009aca0: f006 fd0e    	bl	0x700a16c0 <UART_lld_init> @ imm = #0x6a1c
7009aca4: 900f         	str	r0, [sp, #0x3c]
;             object->uartDmaHandle = NULL;
7009aca6: 990c         	ldr	r1, [sp, #0x30]
7009aca8: 2000         	movs	r0, #0x0
7009acaa: f8c1 0280    	str.w	r0, [r1, #0x280]
7009acae: e7ff         	b	0x7009acb0 <UART_open+0x2d0> @ imm = #-0x2
;         if(SystemP_SUCCESS == status)
7009acb0: 980f         	ldr	r0, [sp, #0x3c]
7009acb2: 2800         	cmp	r0, #0x0
7009acb4: f040 808a    	bne.w	0x7009adcc <UART_open+0x3ec> @ imm = #0x114
7009acb8: e7ff         	b	0x7009acba <UART_open+0x2da> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&object->lockObj);
7009acba: 980c         	ldr	r0, [sp, #0x30]
7009acbc: 308c         	adds	r0, #0x8c
7009acbe: f00e fc47    	bl	0x700a9550 <SemaphoreP_constructMutex> @ imm = #0xe88e
7009acc2: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009acc4: 980f         	ldr	r0, [sp, #0x3c]
7009acc6: b930         	cbnz	r0, 0x7009acd6 <UART_open+0x2f6> @ imm = #0xc
7009acc8: e7ff         	b	0x7009acca <UART_open+0x2ea> @ imm = #-0x2
;                 object->lock = &object->lockObj;
7009acca: 990c         	ldr	r1, [sp, #0x30]
7009accc: f101 008c    	add.w	r0, r1, #0x8c
7009acd0: f8c1 0088    	str.w	r0, [r1, #0x88]
;             }
7009acd4: e7ff         	b	0x7009acd6 <UART_open+0x2f6> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->readTransferSemObj, 0U);
7009acd6: 980c         	ldr	r0, [sp, #0x30]
7009acd8: f500 7094    	add.w	r0, r0, #0x128
7009acdc: 2100         	movs	r1, #0x0
7009acde: f00b f8c7    	bl	0x700a5e70 <SemaphoreP_constructBinary> @ imm = #0xb18e
7009ace2: 4601         	mov	r1, r0
7009ace4: 980f         	ldr	r0, [sp, #0x3c]
7009ace6: 4408         	add	r0, r1
7009ace8: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009acea: 980f         	ldr	r0, [sp, #0x3c]
7009acec: b958         	cbnz	r0, 0x7009ad06 <UART_open+0x326> @ imm = #0x16
7009acee: e7ff         	b	0x7009acf0 <UART_open+0x310> @ imm = #-0x2
;                 object->readTransferSem = &object->readTransferSemObj;
7009acf0: 990c         	ldr	r1, [sp, #0x30]
7009acf2: f501 7094    	add.w	r0, r1, #0x128
7009acf6: f8c1 0124    	str.w	r0, [r1, #0x124]
;                 uartLld_handle->readTransferMutex = object->readTransferSem;
7009acfa: 980c         	ldr	r0, [sp, #0x30]
7009acfc: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009ad00: 9905         	ldr	r1, [sp, #0x14]
7009ad02: 6588         	str	r0, [r1, #0x58]
;             }
7009ad04: e7ff         	b	0x7009ad06 <UART_open+0x326> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->writeTransferSemObj, 0U);
7009ad06: 980c         	ldr	r0, [sp, #0x30]
7009ad08: f500 70e2    	add.w	r0, r0, #0x1c4
7009ad0c: 2100         	movs	r1, #0x0
7009ad0e: f00b f8af    	bl	0x700a5e70 <SemaphoreP_constructBinary> @ imm = #0xb15e
7009ad12: 4601         	mov	r1, r0
7009ad14: 980f         	ldr	r0, [sp, #0x3c]
7009ad16: 4408         	add	r0, r1
7009ad18: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009ad1a: 980f         	ldr	r0, [sp, #0x3c]
7009ad1c: b958         	cbnz	r0, 0x7009ad36 <UART_open+0x356> @ imm = #0x16
7009ad1e: e7ff         	b	0x7009ad20 <UART_open+0x340> @ imm = #-0x2
;                 object->writeTransferSem = &object->writeTransferSemObj;
7009ad20: 990c         	ldr	r1, [sp, #0x30]
7009ad22: f501 70e2    	add.w	r0, r1, #0x1c4
7009ad26: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;                 uartLld_handle->writeTransferMutex = object->writeTransferSem;
7009ad2a: 980c         	ldr	r0, [sp, #0x30]
7009ad2c: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009ad30: 9905         	ldr	r1, [sp, #0x14]
7009ad32: 65c8         	str	r0, [r1, #0x5c]
;             }
7009ad34: e7ff         	b	0x7009ad36 <UART_open+0x356> @ imm = #-0x2
;             if((UART_CONFIG_MODE_INTERRUPT == object->prms.transferMode) && (TRUE != object->prms.skipIntrReg))
7009ad36: 980c         	ldr	r0, [sp, #0x30]
7009ad38: 6b00         	ldr	r0, [r0, #0x30]
7009ad3a: 2801         	cmp	r0, #0x1
7009ad3c: d145         	bne	0x7009adca <UART_open+0x3ea> @ imm = #0x8a
7009ad3e: e7ff         	b	0x7009ad40 <UART_open+0x360> @ imm = #-0x2
7009ad40: 980c         	ldr	r0, [sp, #0x30]
7009ad42: 6bc0         	ldr	r0, [r0, #0x3c]
7009ad44: 2801         	cmp	r0, #0x1
7009ad46: d040         	beq	0x7009adca <UART_open+0x3ea> @ imm = #0x80
7009ad48: e7ff         	b	0x7009ad4a <UART_open+0x36a> @ imm = #-0x2
;                 DebugP_assert(object->prms.intrNum != 0xFFFFU);
7009ad4a: 980c         	ldr	r0, [sp, #0x30]
7009ad4c: 6b40         	ldr	r0, [r0, #0x34]
7009ad4e: f64f 71ff    	movw	r1, #0xffff
7009ad52: 1a40         	subs	r0, r0, r1
7009ad54: bf18         	it	ne
7009ad56: 2001         	movne	r0, #0x1
7009ad58: f64f 01af    	movw	r1, #0xf8af
7009ad5c: f2c7 010a    	movt	r1, #0x700a
7009ad60: 466a         	mov	r2, sp
7009ad62: 6011         	str	r1, [r2]
7009ad64: f64f 3182    	movw	r1, #0xfb82
7009ad68: f2c7 010a    	movt	r1, #0x700a
7009ad6c: f64f 4282    	movw	r2, #0xfc82
7009ad70: f2c7 020a    	movt	r2, #0x700a
7009ad74: f44f 73bf    	mov.w	r3, #0x17e
7009ad78: f00d ff52    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xdea4
7009ad7c: a806         	add	r0, sp, #0x18
;                 HwiP_Params_init(&hwiPrms);
7009ad7e: 9002         	str	r0, [sp, #0x8]
7009ad80: f012 ff6e    	bl	0x700adc60 <HwiP_Params_init> @ imm = #0x12edc
7009ad84: 9902         	ldr	r1, [sp, #0x8]
;                 hwiPrms.intNum      = object->prms.intrNum;
7009ad86: 980c         	ldr	r0, [sp, #0x30]
7009ad88: 6b40         	ldr	r0, [r0, #0x34]
7009ad8a: 9006         	str	r0, [sp, #0x18]
;                 hwiPrms.callback    = &UART_lld_controllerIsr;
7009ad8c: f24e 4001    	movw	r0, #0xe401
7009ad90: f2c7 0009    	movt	r0, #0x7009
7009ad94: 9007         	str	r0, [sp, #0x1c]
;                 hwiPrms.priority    = object->prms.intrPriority;
7009ad96: 980c         	ldr	r0, [sp, #0x30]
7009ad98: f890 0038    	ldrb.w	r0, [r0, #0x38]
7009ad9c: f88d 0026    	strb.w	r0, [sp, #0x26]
;                 hwiPrms.args        = (void *) uartLld_handle;
7009ada0: 9805         	ldr	r0, [sp, #0x14]
7009ada2: 9008         	str	r0, [sp, #0x20]
;                 status += HwiP_construct(&object->hwiObj, &hwiPrms);
7009ada4: 980c         	ldr	r0, [sp, #0x30]
7009ada6: f500 7018    	add.w	r0, r0, #0x260
7009adaa: f012 ff71    	bl	0x700adc90 <HwiP_construct> @ imm = #0x12ee2
7009adae: 4601         	mov	r1, r0
7009adb0: 980f         	ldr	r0, [sp, #0x3c]
7009adb2: 4408         	add	r0, r1
7009adb4: 900f         	str	r0, [sp, #0x3c]
;                 if(SystemP_SUCCESS == status)
7009adb6: 980f         	ldr	r0, [sp, #0x3c]
7009adb8: b930         	cbnz	r0, 0x7009adc8 <UART_open+0x3e8> @ imm = #0xc
7009adba: e7ff         	b	0x7009adbc <UART_open+0x3dc> @ imm = #-0x2
;                     object->hwiHandle = &object->hwiObj;
7009adbc: 990c         	ldr	r1, [sp, #0x30]
7009adbe: f501 7018    	add.w	r0, r1, #0x260
7009adc2: f8c1 025c    	str.w	r0, [r1, #0x25c]
;                 }
7009adc6: e7ff         	b	0x7009adc8 <UART_open+0x3e8> @ imm = #-0x2
;             }
7009adc8: e7ff         	b	0x7009adca <UART_open+0x3ea> @ imm = #-0x2
;         }
7009adca: e7ff         	b	0x7009adcc <UART_open+0x3ec> @ imm = #-0x2
;     }
7009adcc: e7ff         	b	0x7009adce <UART_open+0x3ee> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009adce: 980f         	ldr	r0, [sp, #0x3c]
7009add0: b938         	cbnz	r0, 0x7009ade2 <UART_open+0x402> @ imm = #0xe
7009add2: e7ff         	b	0x7009add4 <UART_open+0x3f4> @ imm = #-0x2
;         object->isOpen = TRUE;
7009add4: 990c         	ldr	r1, [sp, #0x30]
7009add6: 2001         	movs	r0, #0x1
7009add8: f8c1 0084    	str.w	r0, [r1, #0x84]
;         handle = (UART_Handle) config;
7009addc: 980d         	ldr	r0, [sp, #0x34]
7009adde: 900e         	str	r0, [sp, #0x38]
;     }
7009ade0: e7ff         	b	0x7009ade2 <UART_open+0x402> @ imm = #-0x2
;     SemaphoreP_post(&gUartDrvObj.lockObj);
7009ade2: f240 2030    	movw	r0, #0x230
7009ade6: f2c7 000b    	movt	r0, #0x700b
7009adea: 3004         	adds	r0, #0x4
7009adec: f00e ffd8    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0xefb0
;     if(SystemP_SUCCESS != status)
7009adf0: 980f         	ldr	r0, [sp, #0x3c]
7009adf2: b140         	cbz	r0, 0x7009ae06 <UART_open+0x426> @ imm = #0x10
7009adf4: e7ff         	b	0x7009adf6 <UART_open+0x416> @ imm = #-0x2
;         if(NULL != config)
7009adf6: 980d         	ldr	r0, [sp, #0x34]
7009adf8: b120         	cbz	r0, 0x7009ae04 <UART_open+0x424> @ imm = #0x8
7009adfa: e7ff         	b	0x7009adfc <UART_open+0x41c> @ imm = #-0x2
;             UART_close((UART_Handle) config);
7009adfc: 980d         	ldr	r0, [sp, #0x34]
7009adfe: f003 fa1f    	bl	0x7009e240 <UART_close> @ imm = #0x343e
;         }
7009ae02: e7ff         	b	0x7009ae04 <UART_open+0x424> @ imm = #-0x2
;     }
7009ae04: e7ff         	b	0x7009ae06 <UART_open+0x426> @ imm = #-0x2
;     return (handle);
7009ae06: 980e         	ldr	r0, [sp, #0x38]
7009ae08: b012         	add	sp, #0x48
7009ae0a: bd80         	pop	{r7, pc}

7009ae0c <_nop>:
7009ae0c: e12fff1e     	bx	lr

7009ae10 <Udma_chAllocResource>:
; {
7009ae10: b580         	push	{r7, lr}
7009ae12: b088         	sub	sp, #0x20
7009ae14: 9007         	str	r0, [sp, #0x1c]
7009ae16: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK, tempRetVal;
7009ae18: 9006         	str	r0, [sp, #0x18]
7009ae1a: f64f 70ff    	movw	r0, #0xffff
;     uint16_t                ringNum = UDMA_RING_INVALID;
7009ae1e: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     drvHandle = chHandle->drvHandle;
7009ae22: 9807         	ldr	r0, [sp, #0x1c]
7009ae24: 6e80         	ldr	r0, [r0, #0x68]
7009ae26: 9004         	str	r0, [sp, #0x10]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009ae28: 9807         	ldr	r0, [sp, #0x1c]
7009ae2a: 7800         	ldrb	r0, [r0]
7009ae2c: 0740         	lsls	r0, r0, #0x1d
7009ae2e: 2800         	cmp	r0, #0x0
7009ae30: d54d         	bpl	0x7009aece <Udma_chAllocResource+0xbe> @ imm = #0x9a
7009ae32: e7ff         	b	0x7009ae34 <Udma_chAllocResource+0x24> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009ae34: 9807         	ldr	r0, [sp, #0x1c]
7009ae36: 7800         	ldrb	r0, [r0]
7009ae38: 0640         	lsls	r0, r0, #0x19
7009ae3a: 2800         	cmp	r0, #0x0
7009ae3c: d508         	bpl	0x7009ae50 <Udma_chAllocResource+0x40> @ imm = #0x10
7009ae3e: e7ff         	b	0x7009ae40 <Udma_chAllocResource+0x30> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyHcCh(chHandle->chPrms.chNum, drvHandle);
7009ae40: 9807         	ldr	r0, [sp, #0x1c]
7009ae42: 6840         	ldr	r0, [r0, #0x4]
7009ae44: 9904         	ldr	r1, [sp, #0x10]
7009ae46: f006 ff33    	bl	0x700a1cb0 <Udma_rmAllocBlkCopyHcCh> @ imm = #0x6e66
;             chHandle->txChNum =
7009ae4a: 9907         	ldr	r1, [sp, #0x1c]
7009ae4c: 66c8         	str	r0, [r1, #0x6c]
;         }
7009ae4e: e016         	b	0x7009ae7e <Udma_chAllocResource+0x6e> @ imm = #0x2c
;         else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009ae50: 9807         	ldr	r0, [sp, #0x1c]
7009ae52: 7800         	ldrb	r0, [r0]
7009ae54: 0600         	lsls	r0, r0, #0x18
7009ae56: 2800         	cmp	r0, #0x0
7009ae58: d508         	bpl	0x7009ae6c <Udma_chAllocResource+0x5c> @ imm = #0x10
7009ae5a: e7ff         	b	0x7009ae5c <Udma_chAllocResource+0x4c> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyUhcCh(chHandle->chPrms.chNum, drvHandle);
7009ae5c: 9807         	ldr	r0, [sp, #0x1c]
7009ae5e: 6840         	ldr	r0, [r0, #0x4]
7009ae60: 9904         	ldr	r1, [sp, #0x10]
7009ae62: f006 ffbd    	bl	0x700a1de0 <Udma_rmAllocBlkCopyUhcCh> @ imm = #0x6f7a
;             chHandle->txChNum =
7009ae66: 9907         	ldr	r1, [sp, #0x1c]
7009ae68: 66c8         	str	r0, [r1, #0x6c]
;         }
7009ae6a: e007         	b	0x7009ae7c <Udma_chAllocResource+0x6c> @ imm = #0xe
;                 Udma_rmAllocBlkCopyCh(chHandle->chPrms.chNum, drvHandle);
7009ae6c: 9807         	ldr	r0, [sp, #0x1c]
7009ae6e: 6840         	ldr	r0, [r0, #0x4]
7009ae70: 9904         	ldr	r1, [sp, #0x10]
7009ae72: f006 fe85    	bl	0x700a1b80 <Udma_rmAllocBlkCopyCh> @ imm = #0x6d0a
;             chHandle->txChNum =
7009ae76: 9907         	ldr	r1, [sp, #0x1c]
7009ae78: 66c8         	str	r0, [r1, #0x6c]
7009ae7a: e7ff         	b	0x7009ae7c <Udma_chAllocResource+0x6c> @ imm = #-0x2
7009ae7c: e7ff         	b	0x7009ae7e <Udma_chAllocResource+0x6e> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009ae7e: 9807         	ldr	r0, [sp, #0x1c]
7009ae80: 6ec0         	ldr	r0, [r0, #0x6c]
7009ae82: f510 3f80    	cmn.w	r0, #0x10000
7009ae86: d104         	bne	0x7009ae92 <Udma_chAllocResource+0x82> @ imm = #0x8
7009ae88: e7ff         	b	0x7009ae8a <Udma_chAllocResource+0x7a> @ imm = #-0x2
7009ae8a: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009ae8e: 9006         	str	r0, [sp, #0x18]
;         }
7009ae90: e01c         	b	0x7009aecc <Udma_chAllocResource+0xbc> @ imm = #0x38
;             if (UDMA_INST_TYPE_LCDMA_BCDMA == chHandle->drvHandle->instType)
7009ae92: 9807         	ldr	r0, [sp, #0x1c]
7009ae94: 6e80         	ldr	r0, [r0, #0x68]
7009ae96: 6800         	ldr	r0, [r0]
7009ae98: 2801         	cmp	r0, #0x1
7009ae9a: d10b         	bne	0x7009aeb4 <Udma_chAllocResource+0xa4> @ imm = #0x16
7009ae9c: e7ff         	b	0x7009ae9e <Udma_chAllocResource+0x8e> @ imm = #-0x2
;                 chHandle->rxChNum     = UDMA_DMA_CH_INVALID;
7009ae9e: 9907         	ldr	r1, [sp, #0x1c]
7009aea0: 2000         	movs	r0, #0x0
7009aea2: f6cf 70ff    	movt	r0, #0xffff
7009aea6: 6708         	str	r0, [r1, #0x70]
;                 chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009aea8: 9907         	ldr	r1, [sp, #0x1c]
7009aeaa: 2004         	movs	r0, #0x4
7009aeac: f6cf 70ff    	movt	r0, #0xffff
7009aeb0: 67c8         	str	r0, [r1, #0x7c]
;             }
7009aeb2: e00a         	b	0x7009aeca <Udma_chAllocResource+0xba> @ imm = #0x14
;                 chHandle->rxChNum = chHandle->txChNum;
7009aeb4: 9907         	ldr	r1, [sp, #0x1c]
7009aeb6: 6ec8         	ldr	r0, [r1, #0x6c]
7009aeb8: 6708         	str	r0, [r1, #0x70]
;                     chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
7009aeba: 9907         	ldr	r1, [sp, #0x1c]
7009aebc: 6f08         	ldr	r0, [r1, #0x70]
7009aebe: 9a04         	ldr	r2, [sp, #0x10]
7009aec0: f8d2 20d8    	ldr.w	r2, [r2, #0xd8]
7009aec4: 4410         	add	r0, r2
;                 chHandle->peerThreadId =
7009aec6: 67c8         	str	r0, [r1, #0x7c]
7009aec8: e7ff         	b	0x7009aeca <Udma_chAllocResource+0xba> @ imm = #-0x2
7009aeca: e7ff         	b	0x7009aecc <Udma_chAllocResource+0xbc> @ imm = #-0x2
;     }
7009aecc: e0bd         	b	0x7009b04a <Udma_chAllocResource+0x23a> @ imm = #0x17a
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009aece: 9807         	ldr	r0, [sp, #0x1c]
7009aed0: 7800         	ldrb	r0, [r0]
7009aed2: 07c0         	lsls	r0, r0, #0x1f
7009aed4: 2800         	cmp	r0, #0x0
7009aed6: d03f         	beq	0x7009af58 <Udma_chAllocResource+0x148> @ imm = #0x7e
7009aed8: e7ff         	b	0x7009aeda <Udma_chAllocResource+0xca> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009aeda: 9807         	ldr	r0, [sp, #0x1c]
7009aedc: 7800         	ldrb	r0, [r0]
7009aede: 0640         	lsls	r0, r0, #0x19
7009aee0: 2800         	cmp	r0, #0x0
7009aee2: d508         	bpl	0x7009aef6 <Udma_chAllocResource+0xe6> @ imm = #0x10
7009aee4: e7ff         	b	0x7009aee6 <Udma_chAllocResource+0xd6> @ imm = #-0x2
;                     Udma_rmAllocTxHcCh(chHandle->chPrms.chNum, drvHandle);
7009aee6: 9807         	ldr	r0, [sp, #0x1c]
7009aee8: 6840         	ldr	r0, [r0, #0x4]
7009aeea: 9904         	ldr	r1, [sp, #0x10]
7009aeec: f007 fa70    	bl	0x700a23d0 <Udma_rmAllocTxHcCh> @ imm = #0x74e0
;                 chHandle->txChNum =
7009aef0: 9907         	ldr	r1, [sp, #0x1c]
7009aef2: 66c8         	str	r0, [r1, #0x6c]
;             }
7009aef4: e025         	b	0x7009af42 <Udma_chAllocResource+0x132> @ imm = #0x4a
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009aef6: 9807         	ldr	r0, [sp, #0x1c]
7009aef8: 7840         	ldrb	r0, [r0, #0x1]
7009aefa: 07c0         	lsls	r0, r0, #0x1f
7009aefc: b148         	cbz	r0, 0x7009af12 <Udma_chAllocResource+0x102> @ imm = #0x12
7009aefe: e7ff         	b	0x7009af00 <Udma_chAllocResource+0xf0> @ imm = #-0x2
;                     Udma_rmAllocMappedTxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009af00: 9a07         	ldr	r2, [sp, #0x1c]
7009af02: 9904         	ldr	r1, [sp, #0x10]
7009af04: 6850         	ldr	r0, [r2, #0x4]
7009af06: 68d2         	ldr	r2, [r2, #0xc]
7009af08: f005 f862    	bl	0x7009ffd0 <Udma_rmAllocMappedTxCh> @ imm = #0x50c4
;                 chHandle->txChNum =
7009af0c: 9907         	ldr	r1, [sp, #0x1c]
7009af0e: 66c8         	str	r0, [r1, #0x6c]
;             }
7009af10: e016         	b	0x7009af40 <Udma_chAllocResource+0x130> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009af12: 9807         	ldr	r0, [sp, #0x1c]
7009af14: 7800         	ldrb	r0, [r0]
7009af16: 0600         	lsls	r0, r0, #0x18
7009af18: 2800         	cmp	r0, #0x0
7009af1a: d508         	bpl	0x7009af2e <Udma_chAllocResource+0x11e> @ imm = #0x10
7009af1c: e7ff         	b	0x7009af1e <Udma_chAllocResource+0x10e> @ imm = #-0x2
;                     Udma_rmAllocTxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009af1e: 9807         	ldr	r0, [sp, #0x1c]
7009af20: 6840         	ldr	r0, [r0, #0x4]
7009af22: 9904         	ldr	r1, [sp, #0x10]
7009af24: f007 faec    	bl	0x700a2500 <Udma_rmAllocTxUhcCh> @ imm = #0x75d8
;                 chHandle->txChNum =
7009af28: 9907         	ldr	r1, [sp, #0x1c]
7009af2a: 66c8         	str	r0, [r1, #0x6c]
;             }
7009af2c: e007         	b	0x7009af3e <Udma_chAllocResource+0x12e> @ imm = #0xe
;                     Udma_rmAllocTxCh(chHandle->chPrms.chNum, drvHandle);
7009af2e: 9807         	ldr	r0, [sp, #0x1c]
7009af30: 6840         	ldr	r0, [r0, #0x4]
7009af32: 9904         	ldr	r1, [sp, #0x10]
7009af34: f007 f9b4    	bl	0x700a22a0 <Udma_rmAllocTxCh> @ imm = #0x7368
;                 chHandle->txChNum =
7009af38: 9907         	ldr	r1, [sp, #0x1c]
7009af3a: 66c8         	str	r0, [r1, #0x6c]
7009af3c: e7ff         	b	0x7009af3e <Udma_chAllocResource+0x12e> @ imm = #-0x2
7009af3e: e7ff         	b	0x7009af40 <Udma_chAllocResource+0x130> @ imm = #-0x2
7009af40: e7ff         	b	0x7009af42 <Udma_chAllocResource+0x132> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009af42: 9807         	ldr	r0, [sp, #0x1c]
7009af44: 6ec0         	ldr	r0, [r0, #0x6c]
7009af46: f510 3f80    	cmn.w	r0, #0x10000
7009af4a: d104         	bne	0x7009af56 <Udma_chAllocResource+0x146> @ imm = #0x8
7009af4c: e7ff         	b	0x7009af4e <Udma_chAllocResource+0x13e> @ imm = #-0x2
7009af4e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009af52: 9006         	str	r0, [sp, #0x18]
;             }
7009af54: e7ff         	b	0x7009af56 <Udma_chAllocResource+0x146> @ imm = #-0x2
;         }
7009af56: e05c         	b	0x7009b012 <Udma_chAllocResource+0x202> @ imm = #0xb8
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009af58: 9807         	ldr	r0, [sp, #0x1c]
7009af5a: 7800         	ldrb	r0, [r0]
7009af5c: 0640         	lsls	r0, r0, #0x19
7009af5e: 2800         	cmp	r0, #0x0
7009af60: d508         	bpl	0x7009af74 <Udma_chAllocResource+0x164> @ imm = #0x10
7009af62: e7ff         	b	0x7009af64 <Udma_chAllocResource+0x154> @ imm = #-0x2
;                     Udma_rmAllocRxHcCh(chHandle->chPrms.chNum, drvHandle);
7009af64: 9807         	ldr	r0, [sp, #0x1c]
7009af66: 6840         	ldr	r0, [r0, #0x4]
7009af68: 9904         	ldr	r1, [sp, #0x10]
7009af6a: f007 f869    	bl	0x700a2040 <Udma_rmAllocRxHcCh> @ imm = #0x70d2
;                 chHandle->rxChNum =
7009af6e: 9907         	ldr	r1, [sp, #0x1c]
7009af70: 6708         	str	r0, [r1, #0x70]
;             }
7009af72: e026         	b	0x7009afc2 <Udma_chAllocResource+0x1b2> @ imm = #0x4c
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009af74: 9807         	ldr	r0, [sp, #0x1c]
7009af76: 7840         	ldrb	r0, [r0, #0x1]
7009af78: 07c0         	lsls	r0, r0, #0x1f
7009af7a: b150         	cbz	r0, 0x7009af92 <Udma_chAllocResource+0x182> @ imm = #0x14
7009af7c: e7ff         	b	0x7009af7e <Udma_chAllocResource+0x16e> @ imm = #-0x2
;                     Udma_rmAllocMappedRxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009af7e: 9a07         	ldr	r2, [sp, #0x1c]
7009af80: 9904         	ldr	r1, [sp, #0x10]
7009af82: 6850         	ldr	r0, [r2, #0x4]
7009af84: 68d2         	ldr	r2, [r2, #0xc]
7009af86: 3a04         	subs	r2, #0x4
7009af88: f004 ff72    	bl	0x7009fe70 <Udma_rmAllocMappedRxCh> @ imm = #0x4ee4
;                 chHandle->rxChNum =
7009af8c: 9907         	ldr	r1, [sp, #0x1c]
7009af8e: 6708         	str	r0, [r1, #0x70]
;             }
7009af90: e016         	b	0x7009afc0 <Udma_chAllocResource+0x1b0> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009af92: 9807         	ldr	r0, [sp, #0x1c]
7009af94: 7800         	ldrb	r0, [r0]
7009af96: 0600         	lsls	r0, r0, #0x18
7009af98: 2800         	cmp	r0, #0x0
7009af9a: d508         	bpl	0x7009afae <Udma_chAllocResource+0x19e> @ imm = #0x10
7009af9c: e7ff         	b	0x7009af9e <Udma_chAllocResource+0x18e> @ imm = #-0x2
;                     Udma_rmAllocRxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009af9e: 9807         	ldr	r0, [sp, #0x1c]
7009afa0: 6840         	ldr	r0, [r0, #0x4]
7009afa2: 9904         	ldr	r1, [sp, #0x10]
7009afa4: f007 f8e4    	bl	0x700a2170 <Udma_rmAllocRxUhcCh> @ imm = #0x71c8
;                 chHandle->rxChNum =
7009afa8: 9907         	ldr	r1, [sp, #0x1c]
7009afaa: 6708         	str	r0, [r1, #0x70]
;             }
7009afac: e007         	b	0x7009afbe <Udma_chAllocResource+0x1ae> @ imm = #0xe
;                     Udma_rmAllocRxCh(chHandle->chPrms.chNum, drvHandle);
7009afae: 9807         	ldr	r0, [sp, #0x1c]
7009afb0: 6840         	ldr	r0, [r0, #0x4]
7009afb2: 9904         	ldr	r1, [sp, #0x10]
7009afb4: f006 ffac    	bl	0x700a1f10 <Udma_rmAllocRxCh> @ imm = #0x6f58
;                 chHandle->rxChNum =
7009afb8: 9907         	ldr	r1, [sp, #0x1c]
7009afba: 6708         	str	r0, [r1, #0x70]
7009afbc: e7ff         	b	0x7009afbe <Udma_chAllocResource+0x1ae> @ imm = #-0x2
7009afbe: e7ff         	b	0x7009afc0 <Udma_chAllocResource+0x1b0> @ imm = #-0x2
7009afc0: e7ff         	b	0x7009afc2 <Udma_chAllocResource+0x1b2> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->rxChNum)
7009afc2: 9807         	ldr	r0, [sp, #0x1c]
7009afc4: 6f00         	ldr	r0, [r0, #0x70]
7009afc6: f510 3f80    	cmn.w	r0, #0x10000
7009afca: d104         	bne	0x7009afd6 <Udma_chAllocResource+0x1c6> @ imm = #0x8
7009afcc: e7ff         	b	0x7009afce <Udma_chAllocResource+0x1be> @ imm = #-0x2
7009afce: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009afd2: 9006         	str	r0, [sp, #0x18]
;             }
7009afd4: e01c         	b	0x7009b010 <Udma_chAllocResource+0x200> @ imm = #0x38
;                 chHandle->defaultFlow               = &chHandle->defaultFlowObj;
7009afd6: 9907         	ldr	r1, [sp, #0x1c]
7009afd8: f501 70e6    	add.w	r0, r1, #0x1cc
7009afdc: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
;                 chHandle->defaultFlow->drvHandle    = drvHandle;
7009afe0: 9804         	ldr	r0, [sp, #0x10]
7009afe2: 9907         	ldr	r1, [sp, #0x1c]
7009afe4: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009afe8: 6008         	str	r0, [r1]
;                 chHandle->defaultFlow->flowStart    = chHandle->rxChNum;
7009afea: 9907         	ldr	r1, [sp, #0x1c]
7009afec: 6f08         	ldr	r0, [r1, #0x70]
7009afee: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009aff2: 6048         	str	r0, [r1, #0x4]
;                 chHandle->defaultFlow->flowCnt      = 1U;
7009aff4: 9807         	ldr	r0, [sp, #0x1c]
7009aff6: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009affa: 2001         	movs	r0, #0x1
7009affc: 6088         	str	r0, [r1, #0x8]
;                 chHandle->defaultFlow->flowInitDone = UDMA_INIT_DONE;
7009affe: 9807         	ldr	r0, [sp, #0x1c]
7009b000: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009b004: f64a 30cd    	movw	r0, #0xabcd
7009b008: f6ca 30dc    	movt	r0, #0xabdc
7009b00c: 60c8         	str	r0, [r1, #0xc]
7009b00e: e7ff         	b	0x7009b010 <Udma_chAllocResource+0x200> @ imm = #-0x2
7009b010: e7ff         	b	0x7009b012 <Udma_chAllocResource+0x202> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
7009b012: 9806         	ldr	r0, [sp, #0x18]
7009b014: b9c0         	cbnz	r0, 0x7009b048 <Udma_chAllocResource+0x238> @ imm = #0x30
7009b016: e7ff         	b	0x7009b018 <Udma_chAllocResource+0x208> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
7009b018: 9807         	ldr	r0, [sp, #0x1c]
7009b01a: 7800         	ldrb	r0, [r0]
7009b01c: 0700         	lsls	r0, r0, #0x1c
7009b01e: 2800         	cmp	r0, #0x0
7009b020: d507         	bpl	0x7009b032 <Udma_chAllocResource+0x222> @ imm = #0xe
7009b022: e7ff         	b	0x7009b024 <Udma_chAllocResource+0x214> @ imm = #-0x2
;                 chHandle->pdmaChNum = chHandle->chPrms.peerChNum;
7009b024: 9907         	ldr	r1, [sp, #0x1c]
7009b026: 6888         	ldr	r0, [r1, #0x8]
7009b028: 6788         	str	r0, [r1, #0x78]
;                 chHandle->peerThreadId = chHandle->pdmaChNum;
7009b02a: 9907         	ldr	r1, [sp, #0x1c]
7009b02c: 6f88         	ldr	r0, [r1, #0x78]
7009b02e: 67c8         	str	r0, [r1, #0x7c]
;             }
7009b030: e7ff         	b	0x7009b032 <Udma_chAllocResource+0x222> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)
7009b032: 9807         	ldr	r0, [sp, #0x1c]
7009b034: 7800         	ldrb	r0, [r0]
7009b036: 06c0         	lsls	r0, r0, #0x1b
7009b038: 2800         	cmp	r0, #0x0
7009b03a: d504         	bpl	0x7009b046 <Udma_chAllocResource+0x236> @ imm = #0x8
7009b03c: e7ff         	b	0x7009b03e <Udma_chAllocResource+0x22e> @ imm = #-0x2
;                 chHandle->peerThreadId = chHandle->chPrms.peerChNum;
7009b03e: 9907         	ldr	r1, [sp, #0x1c]
7009b040: 6888         	ldr	r0, [r1, #0x8]
7009b042: 67c8         	str	r0, [r1, #0x7c]
;             }
7009b044: e7ff         	b	0x7009b046 <Udma_chAllocResource+0x236> @ imm = #-0x2
;         }
7009b046: e7ff         	b	0x7009b048 <Udma_chAllocResource+0x238> @ imm = #-0x2
7009b048: e7ff         	b	0x7009b04a <Udma_chAllocResource+0x23a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b04a: 9806         	ldr	r0, [sp, #0x18]
7009b04c: 2800         	cmp	r0, #0x0
7009b04e: f040 8088    	bne.w	0x7009b162 <Udma_chAllocResource+0x352> @ imm = #0x110
7009b052: e7ff         	b	0x7009b054 <Udma_chAllocResource+0x244> @ imm = #-0x2
;         if(NULL_PTR != chHandle->chPrms.fqRingPrms.ringMem)
7009b054: 9807         	ldr	r0, [sp, #0x1c]
7009b056: 6940         	ldr	r0, [r0, #0x14]
7009b058: 2800         	cmp	r0, #0x0
7009b05a: f000 8081    	beq.w	0x7009b160 <Udma_chAllocResource+0x350> @ imm = #0x102
7009b05e: e7ff         	b	0x7009b060 <Udma_chAllocResource+0x250> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) ==
7009b060: 9807         	ldr	r0, [sp, #0x1c]
7009b062: 7800         	ldrb	r0, [r0]
7009b064: 0740         	lsls	r0, r0, #0x1d
7009b066: 2800         	cmp	r0, #0x0
7009b068: d505         	bpl	0x7009b076 <Udma_chAllocResource+0x266> @ imm = #0xa
7009b06a: e7ff         	b	0x7009b06c <Udma_chAllocResource+0x25c> @ imm = #-0x2
;                 ringNum = (uint16_t)chHandle->txChNum;
7009b06c: 9807         	ldr	r0, [sp, #0x1c]
7009b06e: 6ec0         	ldr	r0, [r0, #0x6c]
7009b070: f8ad 000e    	strh.w	r0, [sp, #0xe]
;             }
7009b074: e044         	b	0x7009b100 <Udma_chAllocResource+0x2f0> @ imm = #0x88
;                 if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009b076: 9807         	ldr	r0, [sp, #0x1c]
7009b078: 7840         	ldrb	r0, [r0, #0x1]
7009b07a: 07c0         	lsls	r0, r0, #0x1f
7009b07c: b338         	cbz	r0, 0x7009b0ce <Udma_chAllocResource+0x2be> @ imm = #0x4e
7009b07e: e7ff         	b	0x7009b080 <Udma_chAllocResource+0x270> @ imm = #-0x2
;                     chHandle->chPrms.fqRingPrms.mappedRingGrp  = chHandle->chPrms.mappedChGrp;
7009b080: 9907         	ldr	r1, [sp, #0x1c]
7009b082: 68c8         	ldr	r0, [r1, #0xc]
7009b084: 6288         	str	r0, [r1, #0x28]
;                     if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009b086: 9807         	ldr	r0, [sp, #0x1c]
7009b088: 7800         	ldrb	r0, [r0]
7009b08a: 07c0         	lsls	r0, r0, #0x1f
7009b08c: b178         	cbz	r0, 0x7009b0ae <Udma_chAllocResource+0x29e> @ imm = #0x1e
7009b08e: e7ff         	b	0x7009b090 <Udma_chAllocResource+0x280> @ imm = #-0x2
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->txChNum;
7009b090: 9907         	ldr	r1, [sp, #0x1c]
7009b092: 6ec8         	ldr	r0, [r1, #0x6c]
7009b094: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->txChNum, &chAttr);
7009b096: 9804         	ldr	r0, [sp, #0x10]
7009b098: 9a07         	ldr	r2, [sp, #0x1c]
7009b09a: 68d1         	ldr	r1, [r2, #0xc]
7009b09c: 6ed2         	ldr	r2, [r2, #0x6c]
7009b09e: 466b         	mov	r3, sp
7009b0a0: f00a fe36    	bl	0x700a5d10 <Udma_getMappedChRingAttributes> @ imm = #0xac6c
7009b0a4: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009b0a6: 9800         	ldr	r0, [sp]
7009b0a8: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                     }
7009b0ac: e00e         	b	0x7009b0cc <Udma_chAllocResource+0x2bc> @ imm = #0x1c
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->rxChNum;
7009b0ae: 9907         	ldr	r1, [sp, #0x1c]
7009b0b0: 6f08         	ldr	r0, [r1, #0x70]
7009b0b2: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->rxChNum, &chAttr);
7009b0b4: 9804         	ldr	r0, [sp, #0x10]
7009b0b6: 9a07         	ldr	r2, [sp, #0x1c]
7009b0b8: 68d1         	ldr	r1, [r2, #0xc]
7009b0ba: 6f12         	ldr	r2, [r2, #0x70]
7009b0bc: 466b         	mov	r3, sp
7009b0be: f00a fe27    	bl	0x700a5d10 <Udma_getMappedChRingAttributes> @ imm = #0xac4e
7009b0c2: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009b0c4: 9800         	ldr	r0, [sp]
7009b0c6: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009b0ca: e7ff         	b	0x7009b0cc <Udma_chAllocResource+0x2bc> @ imm = #-0x2
;                 }
7009b0cc: e017         	b	0x7009b0fe <Udma_chAllocResource+0x2ee> @ imm = #0x2e
;                 else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009b0ce: 9807         	ldr	r0, [sp, #0x1c]
7009b0d0: 7800         	ldrb	r0, [r0]
7009b0d2: 07c0         	lsls	r0, r0, #0x1f
7009b0d4: b148         	cbz	r0, 0x7009b0ea <Udma_chAllocResource+0x2da> @ imm = #0x12
7009b0d6: e7ff         	b	0x7009b0d8 <Udma_chAllocResource+0x2c8> @ imm = #-0x2
;                     ringNum = (uint16_t)(chHandle->txChNum + drvHandle->txChOffset);
7009b0d8: 9807         	ldr	r0, [sp, #0x1c]
7009b0da: 6ec0         	ldr	r0, [r0, #0x6c]
7009b0dc: 9904         	ldr	r1, [sp, #0x10]
7009b0de: f8d1 110c    	ldr.w	r1, [r1, #0x10c]
7009b0e2: 4408         	add	r0, r1
7009b0e4: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 }
7009b0e8: e008         	b	0x7009b0fc <Udma_chAllocResource+0x2ec> @ imm = #0x10
;                     ringNum = (uint16_t)(chHandle->rxChNum + drvHandle->rxChOffset);
7009b0ea: 9807         	ldr	r0, [sp, #0x1c]
7009b0ec: 6f00         	ldr	r0, [r0, #0x70]
7009b0ee: 9904         	ldr	r1, [sp, #0x10]
7009b0f0: f8d1 1114    	ldr.w	r1, [r1, #0x114]
7009b0f4: 4408         	add	r0, r1
7009b0f6: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009b0fa: e7ff         	b	0x7009b0fc <Udma_chAllocResource+0x2ec> @ imm = #-0x2
7009b0fc: e7ff         	b	0x7009b0fe <Udma_chAllocResource+0x2ee> @ imm = #-0x2
7009b0fe: e7ff         	b	0x7009b100 <Udma_chAllocResource+0x2f0> @ imm = #-0x2
;             chHandle->fqRing = &chHandle->fqRingObj;
7009b100: 9907         	ldr	r1, [sp, #0x1c]
7009b102: f101 0090    	add.w	r0, r1, #0x90
7009b106: f8c1 0080    	str.w	r0, [r1, #0x80]
;                          drvHandle,
7009b10a: 9804         	ldr	r0, [sp, #0x10]
;                          chHandle->fqRing,
7009b10c: 9b07         	ldr	r3, [sp, #0x1c]
7009b10e: f8d3 1080    	ldr.w	r1, [r3, #0x80]
;                          ringNum,
7009b112: f8bd 200e    	ldrh.w	r2, [sp, #0xe]
;                          &chHandle->chPrms.fqRingPrms);
7009b116: 3314         	adds	r3, #0x14
;             retVal = Udma_ringAlloc(
7009b118: f002 fbe2    	bl	0x7009d8e0 <Udma_ringAlloc> @ imm = #0x27c4
7009b11c: 9006         	str	r0, [sp, #0x18]
;             if(UDMA_SOK != retVal)
7009b11e: 9806         	ldr	r0, [sp, #0x18]
7009b120: b128         	cbz	r0, 0x7009b12e <Udma_chAllocResource+0x31e> @ imm = #0xa
7009b122: e7ff         	b	0x7009b124 <Udma_chAllocResource+0x314> @ imm = #-0x2
;                 chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009b124: 9907         	ldr	r1, [sp, #0x1c]
7009b126: 2000         	movs	r0, #0x0
7009b128: f8c1 0080    	str.w	r0, [r1, #0x80]
;             }
7009b12c: e017         	b	0x7009b15e <Udma_chAllocResource+0x34e> @ imm = #0x2e
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009b12e: 9807         	ldr	r0, [sp, #0x1c]
7009b130: 7840         	ldrb	r0, [r0, #0x1]
7009b132: 07c0         	lsls	r0, r0, #0x1f
7009b134: b190         	cbz	r0, 0x7009b15c <Udma_chAllocResource+0x34c> @ imm = #0x24
7009b136: e7ff         	b	0x7009b138 <Udma_chAllocResource+0x328> @ imm = #-0x2
;                     ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX))
7009b138: 9807         	ldr	r0, [sp, #0x1c]
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009b13a: 7800         	ldrb	r0, [r0]
7009b13c: 0780         	lsls	r0, r0, #0x1e
7009b13e: 2800         	cmp	r0, #0x0
7009b140: d50c         	bpl	0x7009b15c <Udma_chAllocResource+0x34c> @ imm = #0x18
7009b142: e7ff         	b	0x7009b144 <Udma_chAllocResource+0x334> @ imm = #-0x2
;                 chHandle->defaultFlow->flowStart    = chHandle->fqRing->ringNum - drvHandle->rxChOffset;
7009b144: 9907         	ldr	r1, [sp, #0x1c]
7009b146: f8d1 0080    	ldr.w	r0, [r1, #0x80]
7009b14a: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009b14e: 8880         	ldrh	r0, [r0, #0x4]
7009b150: 9a04         	ldr	r2, [sp, #0x10]
7009b152: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009b156: 1a80         	subs	r0, r0, r2
7009b158: 6048         	str	r0, [r1, #0x4]
;             }
7009b15a: e7ff         	b	0x7009b15c <Udma_chAllocResource+0x34c> @ imm = #-0x2
7009b15c: e7ff         	b	0x7009b15e <Udma_chAllocResource+0x34e> @ imm = #-0x2
;         }
7009b15e: e7ff         	b	0x7009b160 <Udma_chAllocResource+0x350> @ imm = #-0x2
;     }
7009b160: e7ff         	b	0x7009b162 <Udma_chAllocResource+0x352> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b162: 9806         	ldr	r0, [sp, #0x18]
7009b164: b930         	cbnz	r0, 0x7009b174 <Udma_chAllocResource+0x364> @ imm = #0xc
7009b166: e7ff         	b	0x7009b168 <Udma_chAllocResource+0x358> @ imm = #-0x2
;         chHandle->cqRing = &chHandle->fqRingObj;
7009b168: 9907         	ldr	r1, [sp, #0x1c]
7009b16a: f101 0090    	add.w	r0, r1, #0x90
7009b16e: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009b172: e7ff         	b	0x7009b174 <Udma_chAllocResource+0x364> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b174: 9806         	ldr	r0, [sp, #0x18]
7009b176: b928         	cbnz	r0, 0x7009b184 <Udma_chAllocResource+0x374> @ imm = #0xa
7009b178: e7ff         	b	0x7009b17a <Udma_chAllocResource+0x36a> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009b17a: 9907         	ldr	r1, [sp, #0x1c]
7009b17c: 2000         	movs	r0, #0x0
7009b17e: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009b182: e7ff         	b	0x7009b184 <Udma_chAllocResource+0x374> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009b184: 9806         	ldr	r0, [sp, #0x18]
7009b186: b148         	cbz	r0, 0x7009b19c <Udma_chAllocResource+0x38c> @ imm = #0x12
7009b188: e7ff         	b	0x7009b18a <Udma_chAllocResource+0x37a> @ imm = #-0x2
;         tempRetVal = Udma_chFreeResource(chHandle);
7009b18a: 9807         	ldr	r0, [sp, #0x1c]
7009b18c: f002 faa0    	bl	0x7009d6d0 <Udma_chFreeResource> @ imm = #0x2540
7009b190: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != tempRetVal)
7009b192: 9805         	ldr	r0, [sp, #0x14]
7009b194: b108         	cbz	r0, 0x7009b19a <Udma_chAllocResource+0x38a> @ imm = #0x2
7009b196: e7ff         	b	0x7009b198 <Udma_chAllocResource+0x388> @ imm = #-0x2
;         }
7009b198: e7ff         	b	0x7009b19a <Udma_chAllocResource+0x38a> @ imm = #-0x2
;     }
7009b19a: e004         	b	0x7009b1a6 <Udma_chAllocResource+0x396> @ imm = #0x8
;         Udma_chAssignRegOverlay(drvHandle, chHandle);
7009b19c: 9804         	ldr	r0, [sp, #0x10]
7009b19e: 9907         	ldr	r1, [sp, #0x1c]
7009b1a0: f005 f9ce    	bl	0x700a0540 <Udma_chAssignRegOverlay> @ imm = #0x539c
7009b1a4: e7ff         	b	0x7009b1a6 <Udma_chAllocResource+0x396> @ imm = #-0x2
;     return (retVal);
7009b1a6: 9806         	ldr	r0, [sp, #0x18]
7009b1a8: b008         	add	sp, #0x20
7009b1aa: bd80         	pop	{r7, pc}
7009b1ac: 0000         	movs	r0, r0
7009b1ae: 0000         	movs	r0, r0

7009b1b0 <Udma_chDisableTxChan>:
; {
7009b1b0: b580         	push	{r7, lr}
7009b1b2: b09a         	sub	sp, #0x68
7009b1b4: 9019         	str	r0, [sp, #0x64]
7009b1b6: 9118         	str	r1, [sp, #0x60]
7009b1b8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009b1ba: 9017         	str	r0, [sp, #0x5c]
;     uint32_t            peerRtEnable = 0U, currTimeout = 0U;
7009b1bc: 9016         	str	r0, [sp, #0x58]
7009b1be: 9015         	str	r0, [sp, #0x54]
;     drvHandle = chHandle->drvHandle;
7009b1c0: 9819         	ldr	r0, [sp, #0x64]
7009b1c2: 6e80         	ldr	r0, [r0, #0x68]
7009b1c4: 9014         	str	r0, [sp, #0x50]
7009b1c6: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009b1c8: 9008         	str	r0, [sp, #0x20]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b1ca: 9814         	ldr	r0, [sp, #0x50]
7009b1cc: 6800         	ldr	r0, [r0]
7009b1ce: 2801         	cmp	r0, #0x1
7009b1d0: d10e         	bne	0x7009b1f0 <Udma_chDisableTxChan+0x40> @ imm = #0x1c
7009b1d2: e7ff         	b	0x7009b1d4 <Udma_chDisableTxChan+0x24> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)false, (bool)false);
7009b1d4: 9a14         	ldr	r2, [sp, #0x50]
7009b1d6: f102 0008    	add.w	r0, r2, #0x8
7009b1da: 9919         	ldr	r1, [sp, #0x64]
7009b1dc: 6ec9         	ldr	r1, [r1, #0x6c]
7009b1de: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b1e2: 4411         	add	r1, r2
7009b1e4: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009b1e6: 461a         	mov	r2, r3
7009b1e8: f010 f9f2    	bl	0x700ab5d0 <CSL_bcdmaTeardownTxChan> @ imm = #0x103e4
7009b1ec: 9017         	str	r0, [sp, #0x5c]
;     }
7009b1ee: e00f         	b	0x7009b210 <Udma_chDisableTxChan+0x60> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b1f0: 9814         	ldr	r0, [sp, #0x50]
7009b1f2: 6800         	ldr	r0, [r0]
7009b1f4: 2802         	cmp	r0, #0x2
7009b1f6: d10a         	bne	0x7009b20e <Udma_chDisableTxChan+0x5e> @ imm = #0x14
7009b1f8: e7ff         	b	0x7009b1fa <Udma_chDisableTxChan+0x4a> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009b1fa: 9814         	ldr	r0, [sp, #0x50]
7009b1fc: 3054         	adds	r0, #0x54
7009b1fe: 9919         	ldr	r1, [sp, #0x64]
7009b200: 6ec9         	ldr	r1, [r1, #0x6c]
7009b202: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009b204: 461a         	mov	r2, r3
7009b206: f011 f88b    	bl	0x700ac320 <CSL_pktdmaTeardownTxChan> @ imm = #0x11116
7009b20a: 9017         	str	r0, [sp, #0x5c]
;     }
7009b20c: e7ff         	b	0x7009b20e <Udma_chDisableTxChan+0x5e> @ imm = #-0x2
7009b20e: e7ff         	b	0x7009b210 <Udma_chDisableTxChan+0x60> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009b210: 9817         	ldr	r0, [sp, #0x5c]
7009b212: b108         	cbz	r0, 0x7009b218 <Udma_chDisableTxChan+0x68> @ imm = #0x2
7009b214: e7ff         	b	0x7009b216 <Udma_chDisableTxChan+0x66> @ imm = #-0x2
;     }
7009b216: e7ff         	b	0x7009b218 <Udma_chDisableTxChan+0x68> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009b218: e7ff         	b	0x7009b21a <Udma_chDisableTxChan+0x6a> @ imm = #-0x2
7009b21a: 9817         	ldr	r0, [sp, #0x5c]
7009b21c: bbc8         	cbnz	r0, 0x7009b292 <Udma_chDisableTxChan+0xe2> @ imm = #0x72
7009b21e: e7ff         	b	0x7009b220 <Udma_chDisableTxChan+0x70> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b220: 9814         	ldr	r0, [sp, #0x50]
7009b222: 6800         	ldr	r0, [r0]
7009b224: 2801         	cmp	r0, #0x1
7009b226: d110         	bne	0x7009b24a <Udma_chDisableTxChan+0x9a> @ imm = #0x20
7009b228: e7ff         	b	0x7009b22a <Udma_chDisableTxChan+0x7a> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009b22a: 9a14         	ldr	r2, [sp, #0x50]
7009b22c: f102 0008    	add.w	r0, r2, #0x8
7009b230: 9919         	ldr	r1, [sp, #0x64]
7009b232: 6ec9         	ldr	r1, [r1, #0x6c]
7009b234: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b238: 4411         	add	r1, r2
7009b23a: aa0e         	add	r2, sp, #0x38
7009b23c: f011 fb50    	bl	0x700ac8e0 <CSL_bcdmaGetTxRT> @ imm = #0x116a0
;             if(FALSE == bcdmaRtStatus.enable)
7009b240: 980e         	ldr	r0, [sp, #0x38]
7009b242: b908         	cbnz	r0, 0x7009b248 <Udma_chDisableTxChan+0x98> @ imm = #0x2
7009b244: e7ff         	b	0x7009b246 <Udma_chDisableTxChan+0x96> @ imm = #-0x2
;                 break;
7009b246: e024         	b	0x7009b292 <Udma_chDisableTxChan+0xe2> @ imm = #0x48
;         }
7009b248: e011         	b	0x7009b26e <Udma_chDisableTxChan+0xbe> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b24a: 9814         	ldr	r0, [sp, #0x50]
7009b24c: 6800         	ldr	r0, [r0]
7009b24e: 2802         	cmp	r0, #0x2
7009b250: d10c         	bne	0x7009b26c <Udma_chDisableTxChan+0xbc> @ imm = #0x18
7009b252: e7ff         	b	0x7009b254 <Udma_chDisableTxChan+0xa4> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009b254: 9814         	ldr	r0, [sp, #0x50]
7009b256: 3054         	adds	r0, #0x54
7009b258: 9919         	ldr	r1, [sp, #0x64]
7009b25a: 6ec9         	ldr	r1, [r1, #0x6c]
7009b25c: aa09         	add	r2, sp, #0x24
7009b25e: f010 f827    	bl	0x700ab2b0 <CSL_pktdmaGetTxRT> @ imm = #0x1004e
;             if(FALSE == pktdmaRtStatus.enable)
7009b262: 9809         	ldr	r0, [sp, #0x24]
7009b264: b908         	cbnz	r0, 0x7009b26a <Udma_chDisableTxChan+0xba> @ imm = #0x2
7009b266: e7ff         	b	0x7009b268 <Udma_chDisableTxChan+0xb8> @ imm = #-0x2
;                 break;
7009b268: e013         	b	0x7009b292 <Udma_chDisableTxChan+0xe2> @ imm = #0x26
;         }
7009b26a: e7ff         	b	0x7009b26c <Udma_chDisableTxChan+0xbc> @ imm = #-0x2
7009b26c: e7ff         	b	0x7009b26e <Udma_chDisableTxChan+0xbe> @ imm = #-0x2
;         if(currTimeout > timeout)
7009b26e: 9815         	ldr	r0, [sp, #0x54]
7009b270: 9918         	ldr	r1, [sp, #0x60]
7009b272: 4288         	cmp	r0, r1
7009b274: d904         	bls	0x7009b280 <Udma_chDisableTxChan+0xd0> @ imm = #0x8
7009b276: e7ff         	b	0x7009b278 <Udma_chDisableTxChan+0xc8> @ imm = #-0x2
7009b278: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009b27c: 9017         	str	r0, [sp, #0x5c]
;         }
7009b27e: e007         	b	0x7009b290 <Udma_chDisableTxChan+0xe0> @ imm = #0xe
7009b280: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009b284: f00d ff0c    	bl	0x700a90a0 <ClockP_usleep> @ imm = #0xde18
;             currTimeout++;
7009b288: 9815         	ldr	r0, [sp, #0x54]
7009b28a: 3001         	adds	r0, #0x1
7009b28c: 9015         	str	r0, [sp, #0x54]
7009b28e: e7ff         	b	0x7009b290 <Udma_chDisableTxChan+0xe0> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009b290: e7c3         	b	0x7009b21a <Udma_chDisableTxChan+0x6a> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009b292: 9817         	ldr	r0, [sp, #0x5c]
7009b294: 2800         	cmp	r0, #0x0
7009b296: f000 80e4    	beq.w	0x7009b462 <Udma_chDisableTxChan+0x2b2> @ imm = #0x1c8
7009b29a: e7ff         	b	0x7009b29c <Udma_chDisableTxChan+0xec> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b29c: 9814         	ldr	r0, [sp, #0x50]
7009b29e: 6800         	ldr	r0, [r0]
7009b2a0: 2801         	cmp	r0, #0x1
7009b2a2: d10e         	bne	0x7009b2c2 <Udma_chDisableTxChan+0x112> @ imm = #0x1c
7009b2a4: e7ff         	b	0x7009b2a6 <Udma_chDisableTxChan+0xf6> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)true, (bool)false);
7009b2a6: 9a14         	ldr	r2, [sp, #0x50]
7009b2a8: f102 0008    	add.w	r0, r2, #0x8
7009b2ac: 9919         	ldr	r1, [sp, #0x64]
7009b2ae: 6ec9         	ldr	r1, [r1, #0x6c]
7009b2b0: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b2b4: 4411         	add	r1, r2
7009b2b6: 2201         	movs	r2, #0x1
7009b2b8: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009b2ba: f010 f989    	bl	0x700ab5d0 <CSL_bcdmaTeardownTxChan> @ imm = #0x10312
7009b2be: 9017         	str	r0, [sp, #0x5c]
;         }
7009b2c0: e00f         	b	0x7009b2e2 <Udma_chDisableTxChan+0x132> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b2c2: 9814         	ldr	r0, [sp, #0x50]
7009b2c4: 6800         	ldr	r0, [r0]
7009b2c6: 2802         	cmp	r0, #0x2
7009b2c8: d10a         	bne	0x7009b2e0 <Udma_chDisableTxChan+0x130> @ imm = #0x14
7009b2ca: e7ff         	b	0x7009b2cc <Udma_chDisableTxChan+0x11c> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009b2cc: 9814         	ldr	r0, [sp, #0x50]
7009b2ce: 3054         	adds	r0, #0x54
7009b2d0: 9919         	ldr	r1, [sp, #0x64]
7009b2d2: 6ec9         	ldr	r1, [r1, #0x6c]
7009b2d4: 2201         	movs	r2, #0x1
7009b2d6: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009b2d8: f011 f822    	bl	0x700ac320 <CSL_pktdmaTeardownTxChan> @ imm = #0x11044
7009b2dc: 9017         	str	r0, [sp, #0x5c]
;         }
7009b2de: e7ff         	b	0x7009b2e0 <Udma_chDisableTxChan+0x130> @ imm = #-0x2
7009b2e0: e7ff         	b	0x7009b2e2 <Udma_chDisableTxChan+0x132> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009b2e2: 9817         	ldr	r0, [sp, #0x5c]
7009b2e4: b108         	cbz	r0, 0x7009b2ea <Udma_chDisableTxChan+0x13a> @ imm = #0x2
7009b2e6: e7ff         	b	0x7009b2e8 <Udma_chDisableTxChan+0x138> @ imm = #-0x2
;         }
7009b2e8: e7ff         	b	0x7009b2ea <Udma_chDisableTxChan+0x13a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b2ea: 9814         	ldr	r0, [sp, #0x50]
7009b2ec: 6800         	ldr	r0, [r0]
7009b2ee: 2801         	cmp	r0, #0x1
7009b2f0: d128         	bne	0x7009b344 <Udma_chDisableTxChan+0x194> @ imm = #0x50
7009b2f2: e7ff         	b	0x7009b2f4 <Udma_chDisableTxChan+0x144> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs,
7009b2f4: 9a14         	ldr	r2, [sp, #0x50]
7009b2f6: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009b2fa: 9919         	ldr	r1, [sp, #0x64]
7009b2fc: 6ec9         	ldr	r1, [r1, #0x6c]
7009b2fe: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b302: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009b304: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaGetChanPeerReg(
7009b306: 46ec         	mov	r12, sp
7009b308: aa16         	add	r2, sp, #0x58
7009b30a: 9206         	str	r2, [sp, #0x18]
7009b30c: f8cc 2000    	str.w	r2, [r12]
7009b310: 2200         	movs	r2, #0x0
7009b312: 9207         	str	r2, [sp, #0x1c]
7009b314: f010 fa24    	bl	0x700ab760 <CSL_bcdmaGetChanPeerReg> @ imm = #0x10448
7009b318: f8dd c018    	ldr.w	r12, [sp, #0x18]
7009b31c: 9a07         	ldr	r2, [sp, #0x1c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009b31e: 9816         	ldr	r0, [sp, #0x58]
7009b320: f040 5080    	orr	r0, r0, #0x10000000
7009b324: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->bcdmaRegs,
7009b326: 9b14         	ldr	r3, [sp, #0x50]
7009b328: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009b32c: 9919         	ldr	r1, [sp, #0x64]
7009b32e: 6ec9         	ldr	r1, [r1, #0x6c]
7009b330: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009b334: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009b336: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009b338: 46ee         	mov	lr, sp
7009b33a: f8ce c000    	str.w	r12, [lr]
7009b33e: f010 fd0f    	bl	0x700abd60 <CSL_bcdmaSetChanPeerReg> @ imm = #0x10a1e
;         }
7009b342: e025         	b	0x7009b390 <Udma_chDisableTxChan+0x1e0> @ imm = #0x4a
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b344: 9814         	ldr	r0, [sp, #0x50]
7009b346: 6800         	ldr	r0, [r0]
7009b348: 2802         	cmp	r0, #0x2
7009b34a: d120         	bne	0x7009b38e <Udma_chDisableTxChan+0x1de> @ imm = #0x40
7009b34c: e7ff         	b	0x7009b34e <Udma_chDisableTxChan+0x19e> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs,
7009b34e: 9814         	ldr	r0, [sp, #0x50]
7009b350: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009b352: 9919         	ldr	r1, [sp, #0x64]
7009b354: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009b356: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaGetChanPeerReg(
7009b358: 46ec         	mov	r12, sp
7009b35a: aa16         	add	r2, sp, #0x58
7009b35c: 9204         	str	r2, [sp, #0x10]
7009b35e: f8cc 2000    	str.w	r2, [r12]
7009b362: 2200         	movs	r2, #0x0
7009b364: 9205         	str	r2, [sp, #0x14]
7009b366: f011 f953    	bl	0x700ac610 <CSL_pktdmaGetChanPeerReg> @ imm = #0x112a6
7009b36a: f8dd c010    	ldr.w	r12, [sp, #0x10]
7009b36e: 9a05         	ldr	r2, [sp, #0x14]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009b370: 9816         	ldr	r0, [sp, #0x58]
7009b372: f040 5080    	orr	r0, r0, #0x10000000
7009b376: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->pktdmaRegs,
7009b378: 9814         	ldr	r0, [sp, #0x50]
7009b37a: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009b37c: 9919         	ldr	r1, [sp, #0x64]
7009b37e: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009b380: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009b382: 46ee         	mov	lr, sp
7009b384: f8ce c000    	str.w	r12, [lr]
7009b388: f011 f95a    	bl	0x700ac640 <CSL_pktdmaSetChanPeerReg> @ imm = #0x112b4
;         }
7009b38c: e7ff         	b	0x7009b38e <Udma_chDisableTxChan+0x1de> @ imm = #-0x2
7009b38e: e7ff         	b	0x7009b390 <Udma_chDisableTxChan+0x1e0> @ imm = #-0x2
7009b390: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009b392: 9015         	str	r0, [sp, #0x54]
;         while(UDMA_SOK == retVal)
7009b394: e7ff         	b	0x7009b396 <Udma_chDisableTxChan+0x1e6> @ imm = #-0x2
7009b396: 9817         	ldr	r0, [sp, #0x5c]
7009b398: 2800         	cmp	r0, #0x0
7009b39a: d161         	bne	0x7009b460 <Udma_chDisableTxChan+0x2b0> @ imm = #0xc2
7009b39c: e7ff         	b	0x7009b39e <Udma_chDisableTxChan+0x1ee> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b39e: 9814         	ldr	r0, [sp, #0x50]
7009b3a0: 6800         	ldr	r0, [r0]
7009b3a2: 2801         	cmp	r0, #0x1
7009b3a4: d126         	bne	0x7009b3f4 <Udma_chDisableTxChan+0x244> @ imm = #0x4c
7009b3a6: e7ff         	b	0x7009b3a8 <Udma_chDisableTxChan+0x1f8> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009b3a8: 9a14         	ldr	r2, [sp, #0x50]
7009b3aa: f102 0008    	add.w	r0, r2, #0x8
7009b3ae: 9919         	ldr	r1, [sp, #0x64]
7009b3b0: 6ec9         	ldr	r1, [r1, #0x6c]
7009b3b2: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b3b6: 4411         	add	r1, r2
7009b3b8: aa0e         	add	r2, sp, #0x38
7009b3ba: f011 fa91    	bl	0x700ac8e0 <CSL_bcdmaGetTxRT> @ imm = #0x11522
;                     &drvHandle->bcdmaRegs,
7009b3be: 9a14         	ldr	r2, [sp, #0x50]
7009b3c0: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->txChNum + drvHandle->txChOffset,
7009b3c4: 9919         	ldr	r1, [sp, #0x64]
7009b3c6: 6ec9         	ldr	r1, [r1, #0x6c]
7009b3c8: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b3cc: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009b3ce: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009b3d0: 46ec         	mov	r12, sp
7009b3d2: aa16         	add	r2, sp, #0x58
7009b3d4: f8cc 2000    	str.w	r2, [r12]
7009b3d8: 2200         	movs	r2, #0x0
7009b3da: f010 f9c1    	bl	0x700ab760 <CSL_bcdmaGetChanPeerReg> @ imm = #0x10382
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009b3de: 980e         	ldr	r0, [sp, #0x38]
7009b3e0: b938         	cbnz	r0, 0x7009b3f2 <Udma_chDisableTxChan+0x242> @ imm = #0xe
7009b3e2: e7ff         	b	0x7009b3e4 <Udma_chDisableTxChan+0x234> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009b3e4: 9916         	ldr	r1, [sp, #0x58]
7009b3e6: 2000         	movs	r0, #0x0
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009b3e8: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009b3ec: d101         	bne	0x7009b3f2 <Udma_chDisableTxChan+0x242> @ imm = #0x2
7009b3ee: e7ff         	b	0x7009b3f0 <Udma_chDisableTxChan+0x240> @ imm = #-0x2
;                     break;
7009b3f0: e036         	b	0x7009b460 <Udma_chDisableTxChan+0x2b0> @ imm = #0x6c
;             }
7009b3f2: e023         	b	0x7009b43c <Udma_chDisableTxChan+0x28c> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b3f4: 9814         	ldr	r0, [sp, #0x50]
7009b3f6: 6800         	ldr	r0, [r0]
7009b3f8: 2802         	cmp	r0, #0x2
7009b3fa: d11e         	bne	0x7009b43a <Udma_chDisableTxChan+0x28a> @ imm = #0x3c
7009b3fc: e7ff         	b	0x7009b3fe <Udma_chDisableTxChan+0x24e> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009b3fe: 9814         	ldr	r0, [sp, #0x50]
7009b400: 3054         	adds	r0, #0x54
7009b402: 9919         	ldr	r1, [sp, #0x64]
7009b404: 6ec9         	ldr	r1, [r1, #0x6c]
7009b406: aa09         	add	r2, sp, #0x24
7009b408: f00f ff52    	bl	0x700ab2b0 <CSL_pktdmaGetTxRT> @ imm = #0xfea4
;                     &drvHandle->pktdmaRegs,
7009b40c: 9814         	ldr	r0, [sp, #0x50]
7009b40e: 3054         	adds	r0, #0x54
;                     chHandle->txChNum,
7009b410: 9919         	ldr	r1, [sp, #0x64]
7009b412: 6ec9         	ldr	r1, [r1, #0x6c]
;                     rtEnableRegOffset, &peerRtEnable);
7009b414: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009b416: 46ec         	mov	r12, sp
7009b418: aa16         	add	r2, sp, #0x58
7009b41a: f8cc 2000    	str.w	r2, [r12]
7009b41e: 2200         	movs	r2, #0x0
7009b420: f011 f8f6    	bl	0x700ac610 <CSL_pktdmaGetChanPeerReg> @ imm = #0x111ec
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009b424: 9809         	ldr	r0, [sp, #0x24]
7009b426: b938         	cbnz	r0, 0x7009b438 <Udma_chDisableTxChan+0x288> @ imm = #0xe
7009b428: e7ff         	b	0x7009b42a <Udma_chDisableTxChan+0x27a> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009b42a: 9916         	ldr	r1, [sp, #0x58]
7009b42c: 2000         	movs	r0, #0x0
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009b42e: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009b432: d101         	bne	0x7009b438 <Udma_chDisableTxChan+0x288> @ imm = #0x2
7009b434: e7ff         	b	0x7009b436 <Udma_chDisableTxChan+0x286> @ imm = #-0x2
;                     break;
7009b436: e013         	b	0x7009b460 <Udma_chDisableTxChan+0x2b0> @ imm = #0x26
;             }
7009b438: e7ff         	b	0x7009b43a <Udma_chDisableTxChan+0x28a> @ imm = #-0x2
7009b43a: e7ff         	b	0x7009b43c <Udma_chDisableTxChan+0x28c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009b43c: 9815         	ldr	r0, [sp, #0x54]
7009b43e: 9918         	ldr	r1, [sp, #0x60]
7009b440: 4288         	cmp	r0, r1
7009b442: d904         	bls	0x7009b44e <Udma_chDisableTxChan+0x29e> @ imm = #0x8
7009b444: e7ff         	b	0x7009b446 <Udma_chDisableTxChan+0x296> @ imm = #-0x2
7009b446: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009b44a: 9017         	str	r0, [sp, #0x5c]
;             }
7009b44c: e007         	b	0x7009b45e <Udma_chDisableTxChan+0x2ae> @ imm = #0xe
7009b44e: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009b452: f00d fe25    	bl	0x700a90a0 <ClockP_usleep> @ imm = #0xdc4a
;                 currTimeout++;
7009b456: 9815         	ldr	r0, [sp, #0x54]
7009b458: 3001         	adds	r0, #0x1
7009b45a: 9015         	str	r0, [sp, #0x54]
7009b45c: e7ff         	b	0x7009b45e <Udma_chDisableTxChan+0x2ae> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009b45e: e79a         	b	0x7009b396 <Udma_chDisableTxChan+0x1e6> @ imm = #-0xcc
;     }
7009b460: e7ff         	b	0x7009b462 <Udma_chDisableTxChan+0x2b2> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b462: 9817         	ldr	r0, [sp, #0x5c]
7009b464: 2800         	cmp	r0, #0x0
7009b466: d150         	bne	0x7009b50a <Udma_chDisableTxChan+0x35a> @ imm = #0xa0
7009b468: e7ff         	b	0x7009b46a <Udma_chDisableTxChan+0x2ba> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b46a: 9814         	ldr	r0, [sp, #0x50]
7009b46c: 6800         	ldr	r0, [r0]
7009b46e: 2801         	cmp	r0, #0x1
7009b470: d126         	bne	0x7009b4c0 <Udma_chDisableTxChan+0x310> @ imm = #0x4c
7009b472: e7ff         	b	0x7009b474 <Udma_chDisableTxChan+0x2c4> @ imm = #-0x2
7009b474: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009b476: 9003         	str	r0, [sp, #0xc]
7009b478: 900e         	str	r0, [sp, #0x38]
;             bcdmaRtStatus.teardown = FALSE;
7009b47a: 900f         	str	r0, [sp, #0x3c]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009b47c: 9012         	str	r0, [sp, #0x48]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009b47e: 9816         	ldr	r0, [sp, #0x58]
7009b480: f020 4080    	bic	r0, r0, #0x40000000
7009b484: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009b486: 9a14         	ldr	r2, [sp, #0x50]
7009b488: f102 0008    	add.w	r0, r2, #0x8
7009b48c: 9919         	ldr	r1, [sp, #0x64]
7009b48e: 6ec9         	ldr	r1, [r1, #0x6c]
7009b490: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b494: 4411         	add	r1, r2
7009b496: aa0e         	add	r2, sp, #0x38
7009b498: f011 fa52    	bl	0x700ac940 <CSL_bcdmaSetTxRT> @ imm = #0x114a4
7009b49c: 9a03         	ldr	r2, [sp, #0xc]
;                 &drvHandle->bcdmaRegs,
7009b49e: 9b14         	ldr	r3, [sp, #0x50]
7009b4a0: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009b4a4: 9919         	ldr	r1, [sp, #0x64]
7009b4a6: 6ec9         	ldr	r1, [r1, #0x6c]
7009b4a8: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009b4ac: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009b4ae: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009b4b0: 46ee         	mov	lr, sp
7009b4b2: f10d 0c58    	add.w	r12, sp, #0x58
7009b4b6: f8ce c000    	str.w	r12, [lr]
7009b4ba: f010 fc51    	bl	0x700abd60 <CSL_bcdmaSetChanPeerReg> @ imm = #0x108a2
;         }
7009b4be: e023         	b	0x7009b508 <Udma_chDisableTxChan+0x358> @ imm = #0x46
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b4c0: 9814         	ldr	r0, [sp, #0x50]
7009b4c2: 6800         	ldr	r0, [r0]
7009b4c4: 2802         	cmp	r0, #0x2
7009b4c6: d11e         	bne	0x7009b506 <Udma_chDisableTxChan+0x356> @ imm = #0x3c
7009b4c8: e7ff         	b	0x7009b4ca <Udma_chDisableTxChan+0x31a> @ imm = #-0x2
7009b4ca: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009b4cc: 9002         	str	r0, [sp, #0x8]
7009b4ce: 9009         	str	r0, [sp, #0x24]
;             pktdmaRtStatus.teardown = FALSE;
7009b4d0: 900a         	str	r0, [sp, #0x28]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009b4d2: 900d         	str	r0, [sp, #0x34]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009b4d4: 9816         	ldr	r0, [sp, #0x58]
7009b4d6: f020 4080    	bic	r0, r0, #0x40000000
7009b4da: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009b4dc: 9814         	ldr	r0, [sp, #0x50]
7009b4de: 3054         	adds	r0, #0x54
7009b4e0: 9919         	ldr	r1, [sp, #0x64]
7009b4e2: 6ec9         	ldr	r1, [r1, #0x6c]
7009b4e4: aa09         	add	r2, sp, #0x24
7009b4e6: f010 fc9b    	bl	0x700abe20 <CSL_pktdmaSetTxRT> @ imm = #0x10936
7009b4ea: 9a02         	ldr	r2, [sp, #0x8]
;                 &drvHandle->pktdmaRegs,
7009b4ec: 9814         	ldr	r0, [sp, #0x50]
7009b4ee: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009b4f0: 9919         	ldr	r1, [sp, #0x64]
7009b4f2: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009b4f4: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009b4f6: 46ee         	mov	lr, sp
7009b4f8: f10d 0c58    	add.w	r12, sp, #0x58
7009b4fc: f8ce c000    	str.w	r12, [lr]
7009b500: f011 f89e    	bl	0x700ac640 <CSL_pktdmaSetChanPeerReg> @ imm = #0x1113c
;         }
7009b504: e7ff         	b	0x7009b506 <Udma_chDisableTxChan+0x356> @ imm = #-0x2
7009b506: e7ff         	b	0x7009b508 <Udma_chDisableTxChan+0x358> @ imm = #-0x2
;     }
7009b508: e7ff         	b	0x7009b50a <Udma_chDisableTxChan+0x35a> @ imm = #-0x2
;     return (retVal);
7009b50a: 9817         	ldr	r0, [sp, #0x5c]
7009b50c: b01a         	add	sp, #0x68
7009b50e: bd80         	pop	{r7, pc}

7009b510 <Udma_eventConfig>:
; {
7009b510: b580         	push	{r7, lr}
7009b512: b098         	sub	sp, #0x60
7009b514: 9017         	str	r0, [sp, #0x5c]
7009b516: 9116         	str	r1, [sp, #0x58]
7009b518: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009b51a: 9001         	str	r0, [sp, #0x4]
7009b51c: 9015         	str	r0, [sp, #0x54]
;     eventPrms = &eventHandle->eventPrms;
7009b51e: 9916         	ldr	r1, [sp, #0x58]
7009b520: 3108         	adds	r1, #0x8
7009b522: 9110         	str	r1, [sp, #0x40]
;     rmIrqReq.valid_params           = 0U;
7009b524: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.global_event           = 0U;
7009b526: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     rmIrqReq.src_id                 = 0U;
7009b52a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.src_index              = 0U;
7009b52e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.dst_id                 = 0U;
7009b532: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.dst_host_irq           = 0U;
7009b536: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     rmIrqReq.ia_id                  = 0U;
7009b53a: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint                   = 0U;
7009b53e: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009b542: f88d 002a    	strb.w	r0, [sp, #0x2a]
7009b546: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009b548: f88d 002b    	strb.w	r0, [sp, #0x2b]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009b54c: 9810         	ldr	r0, [sp, #0x40]
7009b54e: 6800         	ldr	r0, [r0]
7009b550: 2805         	cmp	r0, #0x5
7009b552: d00a         	beq	0x7009b56a <Udma_eventConfig+0x5a> @ imm = #0x14
7009b554: e7ff         	b	0x7009b556 <Udma_eventConfig+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009b556: 9806         	ldr	r0, [sp, #0x18]
7009b558: f040 0010    	orr	r0, r0, #0x10
7009b55c: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009b55e: 9816         	ldr	r0, [sp, #0x58]
7009b560: f00f fe56    	bl	0x700ab210 <Udma_eventGetId> @ imm = #0xfcac
7009b564: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     }
7009b568: e7ff         	b	0x7009b56a <Udma_eventConfig+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009b56a: 9816         	ldr	r0, [sp, #0x58]
7009b56c: 6d80         	ldr	r0, [r0, #0x58]
7009b56e: f510 3f80    	cmn.w	r0, #0x10000
7009b572: d012         	beq	0x7009b59a <Udma_eventConfig+0x8a> @ imm = #0x24
7009b574: e7ff         	b	0x7009b576 <Udma_eventConfig+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009b576: 9806         	ldr	r0, [sp, #0x18]
7009b578: f040 0001    	orr	r0, r0, #0x1
7009b57c: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009b57e: 9806         	ldr	r0, [sp, #0x18]
7009b580: f040 0002    	orr	r0, r0, #0x2
7009b584: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.dst_id        = drvHandle->devIdCore;
7009b586: 9817         	ldr	r0, [sp, #0x5c]
7009b588: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009b58c: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmIrqReq.dst_host_irq  = (uint16_t)eventHandle->coreIntrNum;
7009b590: 9816         	ldr	r0, [sp, #0x58]
7009b592: 6d80         	ldr	r0, [r0, #0x58]
7009b594: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     }
7009b598: e7ff         	b	0x7009b59a <Udma_eventConfig+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009b59a: 9816         	ldr	r0, [sp, #0x58]
7009b59c: 6980         	ldr	r0, [r0, #0x18]
7009b59e: b128         	cbz	r0, 0x7009b5ac <Udma_eventConfig+0x9c> @ imm = #0xa
7009b5a0: e7ff         	b	0x7009b5a2 <Udma_eventConfig+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009b5a2: 9816         	ldr	r0, [sp, #0x58]
7009b5a4: 6980         	ldr	r0, [r0, #0x18]
7009b5a6: 6cc0         	ldr	r0, [r0, #0x4c]
7009b5a8: 9014         	str	r0, [sp, #0x50]
;     }
7009b5aa: e003         	b	0x7009b5b4 <Udma_eventConfig+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009b5ac: 9816         	ldr	r0, [sp, #0x58]
7009b5ae: 6cc0         	ldr	r0, [r0, #0x4c]
7009b5b0: 9014         	str	r0, [sp, #0x50]
7009b5b2: e7ff         	b	0x7009b5b4 <Udma_eventConfig+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009b5b4: 9806         	ldr	r0, [sp, #0x18]
7009b5b6: f040 0004    	orr	r0, r0, #0x4
7009b5ba: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009b5bc: 9806         	ldr	r0, [sp, #0x18]
7009b5be: f040 0008    	orr	r0, r0, #0x8
7009b5c2: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009b5c4: 9817         	ldr	r0, [sp, #0x5c]
7009b5c6: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009b5ca: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009b5ce: 9814         	ldr	r0, [sp, #0x50]
7009b5d0: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009b5d4: 9816         	ldr	r0, [sp, #0x58]
7009b5d6: 6d00         	ldr	r0, [r0, #0x50]
7009b5d8: f64f 71ff    	movw	r1, #0xffff
7009b5dc: 4288         	cmp	r0, r1
7009b5de: d009         	beq	0x7009b5f4 <Udma_eventConfig+0xe4> @ imm = #0x12
7009b5e0: e7ff         	b	0x7009b5e2 <Udma_eventConfig+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009b5e2: 9806         	ldr	r0, [sp, #0x18]
7009b5e4: f040 0020    	orr	r0, r0, #0x20
7009b5e8: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009b5ea: 9816         	ldr	r0, [sp, #0x58]
7009b5ec: 6d00         	ldr	r0, [r0, #0x50]
7009b5ee: f88d 002a    	strb.w	r0, [sp, #0x2a]
;     }
7009b5f2: e7ff         	b	0x7009b5f4 <Udma_eventConfig+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009b5f4: 9810         	ldr	r0, [sp, #0x40]
7009b5f6: 6800         	ldr	r0, [r0]
7009b5f8: 2801         	cmp	r0, #0x1
7009b5fa: d00a         	beq	0x7009b612 <Udma_eventConfig+0x102> @ imm = #0x14
7009b5fc: e7ff         	b	0x7009b5fe <Udma_eventConfig+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
7009b5fe: 9810         	ldr	r0, [sp, #0x40]
7009b600: 6800         	ldr	r0, [r0]
7009b602: 2802         	cmp	r0, #0x2
7009b604: d005         	beq	0x7009b612 <Udma_eventConfig+0x102> @ imm = #0xa
7009b606: e7ff         	b	0x7009b608 <Udma_eventConfig+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009b608: 9810         	ldr	r0, [sp, #0x40]
7009b60a: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009b60c: 2806         	cmp	r0, #0x6
7009b60e: d14d         	bne	0x7009b6ac <Udma_eventConfig+0x19c> @ imm = #0x9a
7009b610: e7ff         	b	0x7009b612 <Udma_eventConfig+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009b612: 9810         	ldr	r0, [sp, #0x40]
7009b614: 6880         	ldr	r0, [r0, #0x8]
7009b616: 9012         	str	r0, [sp, #0x48]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009b618: 9817         	ldr	r0, [sp, #0x5c]
7009b61a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009b61e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009b622: 9810         	ldr	r0, [sp, #0x40]
7009b624: 6800         	ldr	r0, [r0]
7009b626: 2801         	cmp	r0, #0x1
7009b628: d005         	beq	0x7009b636 <Udma_eventConfig+0x126> @ imm = #0xa
7009b62a: e7ff         	b	0x7009b62c <Udma_eventConfig+0x11c> @ imm = #-0x2
7009b62c: 9810         	ldr	r0, [sp, #0x40]
7009b62e: 6800         	ldr	r0, [r0]
7009b630: 2806         	cmp	r0, #0x6
7009b632: d12e         	bne	0x7009b692 <Udma_eventConfig+0x182> @ imm = #0x5c
7009b634: e7ff         	b	0x7009b636 <Udma_eventConfig+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009b636: 9812         	ldr	r0, [sp, #0x48]
7009b638: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009b63c: 8880         	ldrh	r0, [r0, #0x4]
7009b63e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009b642: 9812         	ldr	r0, [sp, #0x48]
7009b644: 7800         	ldrb	r0, [r0]
7009b646: 0740         	lsls	r0, r0, #0x1d
7009b648: 2800         	cmp	r0, #0x0
7009b64a: d509         	bpl	0x7009b660 <Udma_eventConfig+0x150> @ imm = #0x12
7009b64c: e7ff         	b	0x7009b64e <Udma_eventConfig+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009b64e: 9817         	ldr	r0, [sp, #0x5c]
7009b650: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009b654: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b658: 4408         	add	r0, r1
7009b65a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b65e: e017         	b	0x7009b690 <Udma_eventConfig+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009b660: 9812         	ldr	r0, [sp, #0x48]
7009b662: 7800         	ldrb	r0, [r0]
7009b664: 07c0         	lsls	r0, r0, #0x1f
7009b666: b148         	cbz	r0, 0x7009b67c <Udma_eventConfig+0x16c> @ imm = #0x12
7009b668: e7ff         	b	0x7009b66a <Udma_eventConfig+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009b66a: 9817         	ldr	r0, [sp, #0x5c]
7009b66c: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009b670: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b674: 4408         	add	r0, r1
7009b676: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b67a: e008         	b	0x7009b68e <Udma_eventConfig+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009b67c: 9817         	ldr	r0, [sp, #0x5c]
7009b67e: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009b682: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b686: 4408         	add	r0, r1
7009b688: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009b68c: e7ff         	b	0x7009b68e <Udma_eventConfig+0x17e> @ imm = #-0x2
7009b68e: e7ff         	b	0x7009b690 <Udma_eventConfig+0x180> @ imm = #-0x2
;         }
7009b690: e00b         	b	0x7009b6aa <Udma_eventConfig+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009b692: 9812         	ldr	r0, [sp, #0x48]
7009b694: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009b698: 8880         	ldrh	r0, [r0, #0x4]
7009b69a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009b69e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b6a2: 3014         	adds	r0, #0x14
7009b6a4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009b6a8: e7ff         	b	0x7009b6aa <Udma_eventConfig+0x19a> @ imm = #-0x2
;     }
7009b6aa: e7ff         	b	0x7009b6ac <Udma_eventConfig+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009b6ac: 9810         	ldr	r0, [sp, #0x40]
7009b6ae: 6800         	ldr	r0, [r0]
7009b6b0: 2803         	cmp	r0, #0x3
7009b6b2: d156         	bne	0x7009b762 <Udma_eventConfig+0x252> @ imm = #0xac
7009b6b4: e7ff         	b	0x7009b6b6 <Udma_eventConfig+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b6b6: 9817         	ldr	r0, [sp, #0x5c]
7009b6b8: 6800         	ldr	r0, [r0]
7009b6ba: 2802         	cmp	r0, #0x2
7009b6bc: d104         	bne	0x7009b6c8 <Udma_eventConfig+0x1b8> @ imm = #0x8
7009b6be: e7ff         	b	0x7009b6c0 <Udma_eventConfig+0x1b0> @ imm = #-0x2
7009b6c0: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009b6c4: 9015         	str	r0, [sp, #0x54]
;         }
7009b6c6: e04b         	b	0x7009b760 <Udma_eventConfig+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009b6c8: 9810         	ldr	r0, [sp, #0x40]
7009b6ca: 6880         	ldr	r0, [r0, #0x8]
7009b6cc: 9012         	str	r0, [sp, #0x48]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009b6ce: 9817         	ldr	r0, [sp, #0x5c]
7009b6d0: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009b6d4: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009b6d8: 9812         	ldr	r0, [sp, #0x48]
7009b6da: 7800         	ldrb	r0, [r0]
7009b6dc: 0740         	lsls	r0, r0, #0x1d
7009b6de: 2800         	cmp	r0, #0x0
7009b6e0: d50d         	bpl	0x7009b6fe <Udma_eventConfig+0x1ee> @ imm = #0x1a
7009b6e2: e7ff         	b	0x7009b6e4 <Udma_eventConfig+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009b6e4: 9812         	ldr	r0, [sp, #0x48]
7009b6e6: 6ec0         	ldr	r0, [r0, #0x6c]
7009b6e8: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009b6ec: 9817         	ldr	r0, [sp, #0x5c]
7009b6ee: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009b6f2: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b6f6: 4408         	add	r0, r1
7009b6f8: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b6fc: e02f         	b	0x7009b75e <Udma_eventConfig+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009b6fe: 9812         	ldr	r0, [sp, #0x48]
7009b700: 7800         	ldrb	r0, [r0]
7009b702: 0780         	lsls	r0, r0, #0x1e
7009b704: 2800         	cmp	r0, #0x0
7009b706: d50d         	bpl	0x7009b724 <Udma_eventConfig+0x214> @ imm = #0x1a
7009b708: e7ff         	b	0x7009b70a <Udma_eventConfig+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009b70a: 9812         	ldr	r0, [sp, #0x48]
7009b70c: 6f00         	ldr	r0, [r0, #0x70]
7009b70e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009b712: 9817         	ldr	r0, [sp, #0x5c]
7009b714: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009b718: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b71c: 4408         	add	r0, r1
7009b71e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b722: e01b         	b	0x7009b75c <Udma_eventConfig+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009b724: 9812         	ldr	r0, [sp, #0x48]
7009b726: 7800         	ldrb	r0, [r0]
7009b728: 07c0         	lsls	r0, r0, #0x1f
7009b72a: b168         	cbz	r0, 0x7009b748 <Udma_eventConfig+0x238> @ imm = #0x1a
7009b72c: e7ff         	b	0x7009b72e <Udma_eventConfig+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009b72e: 9812         	ldr	r0, [sp, #0x48]
7009b730: 6ec0         	ldr	r0, [r0, #0x6c]
7009b732: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009b736: 9817         	ldr	r0, [sp, #0x5c]
7009b738: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009b73c: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b740: 4408         	add	r0, r1
7009b742: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b746: e008         	b	0x7009b75a <Udma_eventConfig+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009b748: 9817         	ldr	r0, [sp, #0x5c]
7009b74a: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009b74e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009b752: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009b754: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009b758: e7ff         	b	0x7009b75a <Udma_eventConfig+0x24a> @ imm = #-0x2
7009b75a: e7ff         	b	0x7009b75c <Udma_eventConfig+0x24c> @ imm = #-0x2
7009b75c: e7ff         	b	0x7009b75e <Udma_eventConfig+0x24e> @ imm = #-0x2
7009b75e: e7ff         	b	0x7009b760 <Udma_eventConfig+0x250> @ imm = #-0x2
;     }
7009b760: e7ff         	b	0x7009b762 <Udma_eventConfig+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009b762: 9810         	ldr	r0, [sp, #0x40]
7009b764: 6800         	ldr	r0, [r0]
7009b766: 2804         	cmp	r0, #0x4
7009b768: d130         	bne	0x7009b7cc <Udma_eventConfig+0x2bc> @ imm = #0x60
7009b76a: e7ff         	b	0x7009b76c <Udma_eventConfig+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009b76c: 9810         	ldr	r0, [sp, #0x40]
7009b76e: 68c0         	ldr	r0, [r0, #0xc]
7009b770: 9011         	str	r0, [sp, #0x44]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009b772: 9817         	ldr	r0, [sp, #0x5c]
7009b774: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009b778: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009b77c: 9811         	ldr	r0, [sp, #0x44]
7009b77e: 8880         	ldrh	r0, [r0, #0x4]
7009b780: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009b784: 9817         	ldr	r0, [sp, #0x5c]
7009b786: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009b78a: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b78e: 4408         	add	r0, r1
7009b790: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009b794: 9811         	ldr	r0, [sp, #0x44]
7009b796: 6dc0         	ldr	r0, [r0, #0x5c]
7009b798: 2804         	cmp	r0, #0x4
7009b79a: d316         	blo	0x7009b7ca <Udma_eventConfig+0x2ba> @ imm = #0x2c
7009b79c: e7ff         	b	0x7009b79e <Udma_eventConfig+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009b79e: 9811         	ldr	r0, [sp, #0x44]
7009b7a0: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009b7a2: 2807         	cmp	r0, #0x7
7009b7a4: d811         	bhi	0x7009b7ca <Udma_eventConfig+0x2ba> @ imm = #0x22
7009b7a6: e7ff         	b	0x7009b7a8 <Udma_eventConfig+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009b7a8: 9817         	ldr	r0, [sp, #0x5c]
7009b7aa: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009b7ae: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b7b2: 1a40         	subs	r0, r0, r1
7009b7b4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009b7b8: 9817         	ldr	r0, [sp, #0x5c]
7009b7ba: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009b7be: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b7c2: 4408         	add	r0, r1
7009b7c4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         }
7009b7c8: e7ff         	b	0x7009b7ca <Udma_eventConfig+0x2ba> @ imm = #-0x2
;     }
7009b7ca: e7ff         	b	0x7009b7cc <Udma_eventConfig+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b7cc: 9815         	ldr	r0, [sp, #0x54]
7009b7ce: b9d8         	cbnz	r0, 0x7009b808 <Udma_eventConfig+0x2f8> @ imm = #0x36
7009b7d0: e7ff         	b	0x7009b7d2 <Udma_eventConfig+0x2c2> @ imm = #-0x2
;         Udma_eventProgramSteering(drvHandle, eventHandle);
7009b7d2: 9817         	ldr	r0, [sp, #0x5c]
7009b7d4: 9916         	ldr	r1, [sp, #0x58]
7009b7d6: f011 fa33    	bl	0x700acc40 <Udma_eventProgramSteering> @ imm = #0x11466
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009b7da: 9817         	ldr	r0, [sp, #0x5c]
7009b7dc: 6800         	ldr	r0, [r0]
7009b7de: b130         	cbz	r0, 0x7009b7ee <Udma_eventConfig+0x2de> @ imm = #0xc
7009b7e0: e7ff         	b	0x7009b7e2 <Udma_eventConfig+0x2d2> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009b7e2: 9810         	ldr	r0, [sp, #0x40]
7009b7e4: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009b7e6: 2805         	cmp	r0, #0x5
7009b7e8: d101         	bne	0x7009b7ee <Udma_eventConfig+0x2de> @ imm = #0x2
7009b7ea: e7ff         	b	0x7009b7ec <Udma_eventConfig+0x2dc> @ imm = #-0x2
;         }
7009b7ec: e00b         	b	0x7009b806 <Udma_eventConfig+0x2f6> @ imm = #0x16
7009b7ee: a804         	add	r0, sp, #0x10
7009b7f0: a902         	add	r1, sp, #0x8
7009b7f2: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmIrqSet(
7009b7f6: f011 fe03    	bl	0x700ad400 <Sciclient_rmIrqSet> @ imm = #0x11c06
7009b7fa: 9015         	str	r0, [sp, #0x54]
;             if(CSL_PASS != retVal)
7009b7fc: 9815         	ldr	r0, [sp, #0x54]
7009b7fe: b108         	cbz	r0, 0x7009b804 <Udma_eventConfig+0x2f4> @ imm = #0x2
7009b800: e7ff         	b	0x7009b802 <Udma_eventConfig+0x2f2> @ imm = #-0x2
;             }
7009b802: e7ff         	b	0x7009b804 <Udma_eventConfig+0x2f4> @ imm = #-0x2
7009b804: e7ff         	b	0x7009b806 <Udma_eventConfig+0x2f6> @ imm = #-0x2
;     }
7009b806: e7ff         	b	0x7009b808 <Udma_eventConfig+0x2f8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b808: 9815         	ldr	r0, [sp, #0x54]
7009b80a: bb58         	cbnz	r0, 0x7009b864 <Udma_eventConfig+0x354> @ imm = #0x56
7009b80c: e7ff         	b	0x7009b80e <Udma_eventConfig+0x2fe> @ imm = #-0x2
;         if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009b80e: 9816         	ldr	r0, [sp, #0x58]
7009b810: 6d80         	ldr	r0, [r0, #0x58]
7009b812: f510 3f80    	cmn.w	r0, #0x10000
7009b816: d024         	beq	0x7009b862 <Udma_eventConfig+0x352> @ imm = #0x48
7009b818: e7ff         	b	0x7009b81a <Udma_eventConfig+0x30a> @ imm = #-0x2
;             coreIntrNum = eventHandle->coreIntrNum;
7009b81a: 9816         	ldr	r0, [sp, #0x58]
7009b81c: 6d80         	ldr	r0, [r0, #0x58]
7009b81e: 9013         	str	r0, [sp, #0x4c]
7009b820: a80b         	add	r0, sp, #0x2c
;             HwiP_Params_init(&hwiPrms);
7009b822: 9000         	str	r0, [sp]
7009b824: f012 fa1c    	bl	0x700adc60 <HwiP_Params_init> @ imm = #0x12438
7009b828: 9900         	ldr	r1, [sp]
;             hwiPrms.intNum = coreIntrNum;
7009b82a: 9813         	ldr	r0, [sp, #0x4c]
7009b82c: 900b         	str	r0, [sp, #0x2c]
;             hwiPrms.callback = &Udma_eventIsrFxn;
7009b82e: f643 40e1    	movw	r0, #0x3ce1
7009b832: f2c7 000a    	movt	r0, #0x700a
7009b836: 900c         	str	r0, [sp, #0x30]
;             hwiPrms.args = eventHandle;
7009b838: 9816         	ldr	r0, [sp, #0x58]
7009b83a: 900d         	str	r0, [sp, #0x34]
;             hwiPrms.priority = eventHandle->eventPrms.intrPriority;
7009b83c: 9816         	ldr	r0, [sp, #0x58]
7009b83e: 6a00         	ldr	r0, [r0, #0x20]
7009b840: f88d 003a    	strb.w	r0, [sp, #0x3a]
;             retVal = HwiP_construct(&eventHandle->hwiObject, &hwiPrms);
7009b844: 9816         	ldr	r0, [sp, #0x58]
7009b846: 3068         	adds	r0, #0x68
7009b848: f012 fa22    	bl	0x700adc90 <HwiP_construct> @ imm = #0x12444
7009b84c: 9015         	str	r0, [sp, #0x54]
;             if(SystemP_SUCCESS != retVal)
7009b84e: 9815         	ldr	r0, [sp, #0x54]
7009b850: b108         	cbz	r0, 0x7009b856 <Udma_eventConfig+0x346> @ imm = #0x2
7009b852: e7ff         	b	0x7009b854 <Udma_eventConfig+0x344> @ imm = #-0x2
;             }
7009b854: e004         	b	0x7009b860 <Udma_eventConfig+0x350> @ imm = #0x8
;                 eventHandle->hwiHandle = &eventHandle->hwiObject;
7009b856: 9916         	ldr	r1, [sp, #0x58]
7009b858: f101 0068    	add.w	r0, r1, #0x68
7009b85c: 6648         	str	r0, [r1, #0x64]
7009b85e: e7ff         	b	0x7009b860 <Udma_eventConfig+0x350> @ imm = #-0x2
;         }
7009b860: e7ff         	b	0x7009b862 <Udma_eventConfig+0x352> @ imm = #-0x2
;     }
7009b862: e7ff         	b	0x7009b864 <Udma_eventConfig+0x354> @ imm = #-0x2
;     return (retVal);
7009b864: 9815         	ldr	r0, [sp, #0x54]
7009b866: b018         	add	sp, #0x60
7009b868: bd80         	pop	{r7, pc}
7009b86a: 0000         	movs	r0, r0
7009b86c: 0000         	movs	r0, r0
7009b86e: 0000         	movs	r0, r0

7009b870 <Sciclient_rmIrqGetRoute>:
; {
7009b870: b580         	push	{r7, lr}
7009b872: b08e         	sub	sp, #0x38
7009b874: 900d         	str	r0, [sp, #0x34]
7009b876: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009b878: 900c         	str	r0, [sp, #0x30]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009b87a: 980d         	ldr	r0, [sp, #0x34]
7009b87c: 88c0         	ldrh	r0, [r0, #0x6]
7009b87e: f010 ff57    	bl	0x700ac730 <Sciclient_rmIrIsIr> @ imm = #0x10eae
7009b882: b930         	cbnz	r0, 0x7009b892 <Sciclient_rmIrqGetRoute+0x22> @ imm = #0xc
7009b884: e7ff         	b	0x7009b886 <Sciclient_rmIrqGetRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009b886: 980d         	ldr	r0, [sp, #0x34]
7009b888: 8940         	ldrh	r0, [r0, #0xa]
7009b88a: f010 ff51    	bl	0x700ac730 <Sciclient_rmIrIsIr> @ imm = #0x10ea2
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009b88e: b120         	cbz	r0, 0x7009b89a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #0x8
7009b890: e7ff         	b	0x7009b892 <Sciclient_rmIrqGetRoute+0x22> @ imm = #-0x2
7009b892: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009b896: 900c         	str	r0, [sp, #0x30]
;     }
7009b898: e7ff         	b	0x7009b89a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009b89a: 980c         	ldr	r0, [sp, #0x30]
7009b89c: 2800         	cmp	r0, #0x0
7009b89e: d156         	bne	0x7009b94e <Sciclient_rmIrqGetRoute+0xde> @ imm = #0xac
7009b8a0: e7ff         	b	0x7009b8a2 <Sciclient_rmIrqGetRoute+0x32> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009b8a2: 980d         	ldr	r0, [sp, #0x34]
7009b8a4: 8a00         	ldrh	r0, [r0, #0x10]
7009b8a6: 28ff         	cmp	r0, #0xff
7009b8a8: d042         	beq	0x7009b930 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x84
7009b8aa: e7ff         	b	0x7009b8ac <Sciclient_rmIrqGetRoute+0x3c> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009b8ac: 980d         	ldr	r0, [sp, #0x34]
7009b8ae: 6800         	ldr	r0, [r0]
7009b8b0: 2104         	movs	r1, #0x4
7009b8b2: f011 f91d    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x1123a
;              true) &&
7009b8b6: b3d8         	cbz	r0, 0x7009b930 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x76
7009b8b8: e7ff         	b	0x7009b8ba <Sciclient_rmIrqGetRoute+0x4a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009b8ba: 980d         	ldr	r0, [sp, #0x34]
7009b8bc: 6800         	ldr	r0, [r0]
7009b8be: 2108         	movs	r1, #0x8
7009b8c0: f011 f916    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x1122c
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009b8c4: b3a0         	cbz	r0, 0x7009b930 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x68
7009b8c6: e7ff         	b	0x7009b8c8 <Sciclient_rmIrqGetRoute+0x58> @ imm = #-0x2
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009b8c8: 980d         	ldr	r0, [sp, #0x34]
7009b8ca: 6800         	ldr	r0, [r0]
7009b8cc: 2110         	movs	r1, #0x10
7009b8ce: f011 f90f    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x1121e
;                  true) &&
7009b8d2: b1d0         	cbz	r0, 0x7009b90a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x34
7009b8d4: e7ff         	b	0x7009b8d6 <Sciclient_rmIrqGetRoute+0x66> @ imm = #-0x2
;                 (Sciclient_rmParamIsValid(cfg->valid_params,
7009b8d6: 980d         	ldr	r0, [sp, #0x34]
7009b8d8: 6800         	ldr	r0, [r0]
7009b8da: 2120         	movs	r1, #0x20
7009b8dc: f011 f908    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x11210
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009b8e0: b198         	cbz	r0, 0x7009b90a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x26
7009b8e2: e7ff         	b	0x7009b8e4 <Sciclient_rmIrqGetRoute+0x74> @ imm = #-0x2
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009b8e4: f8dd c034    	ldr.w	r12, [sp, #0x34]
7009b8e8: f8bc 1010    	ldrh.w	r1, [r12, #0x10]
;                                cfg->vint, cfg->global_evt,
7009b8ec: f8bc 2012    	ldrh.w	r2, [r12, #0x12]
7009b8f0: f8bc 300e    	ldrh.w	r3, [r12, #0xe]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009b8f4: f89c 0004    	ldrb.w	r0, [r12, #0x4]
;                                cfg->vint_sb);
7009b8f8: f89c c014    	ldrb.w	r12, [r12, #0x14]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009b8fc: 46ee         	mov	lr, sp
7009b8fe: f8ce c000    	str.w	r12, [lr]
7009b902: f005 f815    	bl	0x700a0930 <Sciclient_rmIaValidateMapping> @ imm = #0x502a
7009b906: 900c         	str	r0, [sp, #0x30]
;             }
7009b908: e7ff         	b	0x7009b90a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #-0x2
;             if (r == SystemP_SUCCESS) {
7009b90a: 980c         	ldr	r0, [sp, #0x30]
7009b90c: b978         	cbnz	r0, 0x7009b92e <Sciclient_rmIrqGetRoute+0xbe> @ imm = #0x1e
7009b90e: e7ff         	b	0x7009b910 <Sciclient_rmIrqGetRoute+0xa0> @ imm = #-0x2
;                 inp = cfg->global_evt;
7009b910: 980d         	ldr	r0, [sp, #0x34]
7009b912: 89c0         	ldrh	r0, [r0, #0xe]
7009b914: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = cfg->vint;
7009b918: 980d         	ldr	r0, [sp, #0x34]
7009b91a: 8a40         	ldrh	r0, [r0, #0x12]
7009b91c: f8ad 0024    	strh.w	r0, [sp, #0x24]
;                 r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009b920: 980d         	ldr	r0, [sp, #0x34]
7009b922: 8a00         	ldrh	r0, [r0, #0x10]
7009b924: a906         	add	r1, sp, #0x18
7009b926: f008 fbbb    	bl	0x700a40a0 <Sciclient_rmIrqGetNode> @ imm = #0x8776
7009b92a: 900c         	str	r0, [sp, #0x30]
;             }
7009b92c: e7ff         	b	0x7009b92e <Sciclient_rmIrqGetRoute+0xbe> @ imm = #-0x2
;         } else {
7009b92e: e00d         	b	0x7009b94c <Sciclient_rmIrqGetRoute+0xdc> @ imm = #0x1a
7009b930: 2000         	movs	r0, #0x0
;             inp = 0u;
7009b932: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             outp = cfg->s_idx;
7009b936: 980d         	ldr	r0, [sp, #0x34]
7009b938: 8900         	ldrh	r0, [r0, #0x8]
7009b93a: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009b93e: 980d         	ldr	r0, [sp, #0x34]
7009b940: 88c0         	ldrh	r0, [r0, #0x6]
7009b942: a906         	add	r1, sp, #0x18
7009b944: f008 fbac    	bl	0x700a40a0 <Sciclient_rmIrqGetNode> @ imm = #0x8758
7009b948: 900c         	str	r0, [sp, #0x30]
7009b94a: e7ff         	b	0x7009b94c <Sciclient_rmIrqGetRoute+0xdc> @ imm = #-0x2
;     }
7009b94c: e7ff         	b	0x7009b94e <Sciclient_rmIrqGetRoute+0xde> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009b94e: 980c         	ldr	r0, [sp, #0x30]
7009b950: b948         	cbnz	r0, 0x7009b966 <Sciclient_rmIrqGetRoute+0xf6> @ imm = #0x12
7009b952: e7ff         	b	0x7009b954 <Sciclient_rmIrqGetRoute+0xe4> @ imm = #-0x2
7009b954: 2001         	movs	r0, #0x1
;         search = true;
7009b956: f88d 0021    	strb.w	r0, [sp, #0x21]
7009b95a: 2000         	movs	r0, #0x0
;         rt_complete = false;
7009b95c: f88d 0020    	strb.w	r0, [sp, #0x20]
;         Sciclient_rmPsInit();
7009b960: f011 fc3e    	bl	0x700ad1e0 <Sciclient_rmPsInit> @ imm = #0x1187c
;     } else {
7009b964: e003         	b	0x7009b96e <Sciclient_rmIrqGetRoute+0xfe> @ imm = #0x6
7009b966: 2000         	movs	r0, #0x0
;         search = false;
7009b968: f88d 0021    	strb.w	r0, [sp, #0x21]
7009b96c: e7ff         	b	0x7009b96e <Sciclient_rmIrqGetRoute+0xfe> @ imm = #-0x2
7009b96e: 2000         	movs	r0, #0x0
;     for (search_depth = 0u;
7009b970: f8ad 002e    	strh.w	r0, [sp, #0x2e]
7009b974: e7ff         	b	0x7009b976 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x2
;          (search_depth < Sciclient_rmPsGetMaxPsp()) && (search == true);
7009b976: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009b97a: 9002         	str	r0, [sp, #0x8]
7009b97c: f012 f888    	bl	0x700ada90 <Sciclient_rmPsGetMaxPsp> @ imm = #0x12110
7009b980: 9902         	ldr	r1, [sp, #0x8]
7009b982: 4602         	mov	r2, r0
7009b984: 2000         	movs	r0, #0x0
7009b986: 4291         	cmp	r1, r2
7009b988: 9003         	str	r0, [sp, #0xc]
7009b98a: da06         	bge	0x7009b99a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #0xc
7009b98c: e7ff         	b	0x7009b98e <Sciclient_rmIrqGetRoute+0x11e> @ imm = #-0x2
7009b98e: f89d 0021    	ldrb.w	r0, [sp, #0x21]
7009b992: f000 0001    	and	r0, r0, #0x1
7009b996: 9003         	str	r0, [sp, #0xc]
7009b998: e7ff         	b	0x7009b99a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #-0x2
7009b99a: 9803         	ldr	r0, [sp, #0xc]
;     for (search_depth = 0u;
7009b99c: 07c0         	lsls	r0, r0, #0x1f
7009b99e: 2800         	cmp	r0, #0x0
7009b9a0: f000 80d8    	beq.w	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x1b0
7009b9a4: e7ff         	b	0x7009b9a6 <Sciclient_rmIrqGetRoute+0x136> @ imm = #-0x2
7009b9a6: 2000         	movs	r0, #0x0
;         push_node = false;
7009b9a8: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009b9ac: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009b9b0: e7ff         	b	0x7009b9b2 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0x2
7009b9b2: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009b9b6: 9906         	ldr	r1, [sp, #0x18]
7009b9b8: 8849         	ldrh	r1, [r1, #0x2]
7009b9ba: 4288         	cmp	r0, r1
7009b9bc: da6b         	bge	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xd6
7009b9be: e7ff         	b	0x7009b9c0 <Sciclient_rmIrqGetRoute+0x150> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009b9c0: 9806         	ldr	r0, [sp, #0x18]
7009b9c2: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009b9c6: aa04         	add	r2, sp, #0x10
7009b9c8: f00f ff6a    	bl	0x700ab8a0 <Sciclient_rmIrqGetNodeItf> @ imm = #0xfed4
7009b9cc: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009b9ce: 980c         	ldr	r0, [sp, #0x30]
7009b9d0: b108         	cbz	r0, 0x7009b9d6 <Sciclient_rmIrqGetRoute+0x166> @ imm = #0x2
7009b9d2: e7ff         	b	0x7009b9d4 <Sciclient_rmIrqGetRoute+0x164> @ imm = #-0x2
;                 break;
7009b9d4: e05f         	b	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xbe
;             if ((outp >= cur_if->lbase) &&
7009b9d6: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009b9da: 9904         	ldr	r1, [sp, #0x10]
7009b9dc: 8809         	ldrh	r1, [r1]
7009b9de: 4288         	cmp	r0, r1
7009b9e0: db52         	blt	0x7009ba88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0xa4
7009b9e2: e7ff         	b	0x7009b9e4 <Sciclient_rmIrqGetRoute+0x174> @ imm = #-0x2
;                 (outp < (cur_if->lbase + cur_if->len))) {
7009b9e4: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009b9e8: 9a04         	ldr	r2, [sp, #0x10]
7009b9ea: 8811         	ldrh	r1, [r2]
7009b9ec: 8892         	ldrh	r2, [r2, #0x4]
7009b9ee: 4411         	add	r1, r2
;             if ((outp >= cur_if->lbase) &&
7009b9f0: 4288         	cmp	r0, r1
7009b9f2: da49         	bge	0x7009ba88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0x92
7009b9f4: e7ff         	b	0x7009b9f6 <Sciclient_rmIrqGetRoute+0x186> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
7009b9f6: 9804         	ldr	r0, [sp, #0x10]
7009b9f8: 88c0         	ldrh	r0, [r0, #0x6]
7009b9fa: 990d         	ldr	r1, [sp, #0x34]
7009b9fc: 8949         	ldrh	r1, [r1, #0xa]
7009b9fe: 4288         	cmp	r0, r1
7009ba00: d110         	bne	0x7009ba24 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x20
7009ba02: e7ff         	b	0x7009ba04 <Sciclient_rmIrqGetRoute+0x194> @ imm = #-0x2
;                     (SCICLIENT_OUTP_TO_INP(outp, cur_if->lbase,
7009ba04: 9a04         	ldr	r2, [sp, #0x10]
7009ba06: 8850         	ldrh	r0, [r2, #0x2]
7009ba08: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009ba0c: 8812         	ldrh	r2, [r2]
7009ba0e: 1a89         	subs	r1, r1, r2
7009ba10: 4408         	add	r0, r1
;                      cfg->d_irq)) {
7009ba12: 990d         	ldr	r1, [sp, #0x34]
7009ba14: 8989         	ldrh	r1, [r1, #0xc]
;                 if ((cur_if->rid == cfg->d_id) &&
7009ba16: 4288         	cmp	r0, r1
7009ba18: d104         	bne	0x7009ba24 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x8
7009ba1a: e7ff         	b	0x7009ba1c <Sciclient_rmIrqGetRoute+0x1ac> @ imm = #-0x2
7009ba1c: 2001         	movs	r0, #0x1
;                     rt_complete = true;
7009ba1e: f88d 0020    	strb.w	r0, [sp, #0x20]
;                     break;
7009ba22: e038         	b	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x70
;                 if (Sciclient_rmIrIsIr(cur_if->rid) == true) {
7009ba24: 9804         	ldr	r0, [sp, #0x10]
7009ba26: 88c0         	ldrh	r0, [r0, #0x6]
7009ba28: f010 fe82    	bl	0x700ac730 <Sciclient_rmIrIsIr> @ imm = #0x10d04
7009ba2c: b358         	cbz	r0, 0x7009ba86 <Sciclient_rmIrqGetRoute+0x216> @ imm = #0x56
7009ba2e: e7ff         	b	0x7009ba30 <Sciclient_rmIrqGetRoute+0x1c0> @ imm = #-0x2
;                     r = Sciclient_rmIrqGetNode(cur_if->rid, &next_n);
7009ba30: 9804         	ldr	r0, [sp, #0x10]
7009ba32: 88c0         	ldrh	r0, [r0, #0x6]
7009ba34: a905         	add	r1, sp, #0x14
7009ba36: f008 fb33    	bl	0x700a40a0 <Sciclient_rmIrqGetNode> @ imm = #0x8666
7009ba3a: 900c         	str	r0, [sp, #0x30]
;                     if (r != SystemP_SUCCESS) {
7009ba3c: 980c         	ldr	r0, [sp, #0x30]
7009ba3e: b108         	cbz	r0, 0x7009ba44 <Sciclient_rmIrqGetRoute+0x1d4> @ imm = #0x2
7009ba40: e7ff         	b	0x7009ba42 <Sciclient_rmIrqGetRoute+0x1d2> @ imm = #-0x2
;                         break;
7009ba42: e028         	b	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x50
;                     next_inp = SCICLIENT_OUTP_TO_INP(outp,
7009ba44: 9a04         	ldr	r2, [sp, #0x10]
7009ba46: 8850         	ldrh	r0, [r2, #0x2]
7009ba48: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009ba4c: 8812         	ldrh	r2, [r2]
7009ba4e: 1a89         	subs	r1, r1, r2
7009ba50: 4408         	add	r0, r1
7009ba52: f8ad 0026    	strh.w	r0, [sp, #0x26]
;                     r = Sciclient_rmIrGetOutp(next_n->id, next_inp,
7009ba56: 9805         	ldr	r0, [sp, #0x14]
7009ba58: 8800         	ldrh	r0, [r0]
7009ba5a: f8bd 1026    	ldrh.w	r1, [sp, #0x26]
7009ba5e: f10d 0222    	add.w	r2, sp, #0x22
7009ba62: f007 ff3d    	bl	0x700a38e0 <Sciclient_rmIrGetOutp> @ imm = #0x7e7a
7009ba66: 900c         	str	r0, [sp, #0x30]
;                     if (r == SystemP_SUCCESS) {
7009ba68: 980c         	ldr	r0, [sp, #0x30]
7009ba6a: b930         	cbnz	r0, 0x7009ba7a <Sciclient_rmIrqGetRoute+0x20a> @ imm = #0xc
7009ba6c: e7ff         	b	0x7009ba6e <Sciclient_rmIrqGetRoute+0x1fe> @ imm = #-0x2
7009ba6e: 2001         	movs	r0, #0x1
;                         push_node = true;
7009ba70: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009ba74: 2000         	movs	r0, #0x0
;                         r = SystemP_SUCCESS;
7009ba76: 900c         	str	r0, [sp, #0x30]
;                         break;
7009ba78: e00d         	b	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x1a
;                     if (r != SystemP_FAILURE) {
7009ba7a: 980c         	ldr	r0, [sp, #0x30]
7009ba7c: 3001         	adds	r0, #0x1
7009ba7e: b108         	cbz	r0, 0x7009ba84 <Sciclient_rmIrqGetRoute+0x214> @ imm = #0x2
7009ba80: e7ff         	b	0x7009ba82 <Sciclient_rmIrqGetRoute+0x212> @ imm = #-0x2
;                         break;
7009ba82: e008         	b	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x10
;                 }
7009ba84: e7ff         	b	0x7009ba86 <Sciclient_rmIrqGetRoute+0x216> @ imm = #-0x2
;             }
7009ba86: e7ff         	b	0x7009ba88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #-0x2
;         }
7009ba88: e7ff         	b	0x7009ba8a <Sciclient_rmIrqGetRoute+0x21a> @ imm = #-0x2
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009ba8a: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009ba8e: 3001         	adds	r0, #0x1
7009ba90: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009ba94: e78d         	b	0x7009b9b2 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0xe6
;         if (r != SystemP_SUCCESS) {
7009ba96: 980c         	ldr	r0, [sp, #0x30]
7009ba98: b108         	cbz	r0, 0x7009ba9e <Sciclient_rmIrqGetRoute+0x22e> @ imm = #0x2
7009ba9a: e7ff         	b	0x7009ba9c <Sciclient_rmIrqGetRoute+0x22c> @ imm = #-0x2
;             break;
7009ba9c: e05a         	b	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0xb4
;         if ((rt_complete == true) || (push_node == true)) {
7009ba9e: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009baa2: 07c0         	lsls	r0, r0, #0x1f
7009baa4: b930         	cbnz	r0, 0x7009bab4 <Sciclient_rmIrqGetRoute+0x244> @ imm = #0xc
7009baa6: e7ff         	b	0x7009baa8 <Sciclient_rmIrqGetRoute+0x238> @ imm = #-0x2
7009baa8: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009baac: 07c0         	lsls	r0, r0, #0x1f
7009baae: 2800         	cmp	r0, #0x0
7009bab0: d049         	beq	0x7009bb46 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #0x92
7009bab2: e7ff         	b	0x7009bab4 <Sciclient_rmIrqGetRoute+0x244> @ imm = #-0x2
;             r = Sciclient_rmPsPush(cur_n, if_idx);
7009bab4: 9806         	ldr	r0, [sp, #0x18]
7009bab6: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009baba: f00e fcf9    	bl	0x700aa4b0 <Sciclient_rmPsPush> @ imm = #0xe9f2
7009babe: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009bac0: 980c         	ldr	r0, [sp, #0x30]
7009bac2: b108         	cbz	r0, 0x7009bac8 <Sciclient_rmIrqGetRoute+0x258> @ imm = #0x2
7009bac4: e7ff         	b	0x7009bac6 <Sciclient_rmIrqGetRoute+0x256> @ imm = #-0x2
;                 break;
7009bac6: e045         	b	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x8a
;             if ((search_depth > 0u) ||
7009bac8: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bacc: b950         	cbnz	r0, 0x7009bae4 <Sciclient_rmIrqGetRoute+0x274> @ imm = #0x14
7009bace: e7ff         	b	0x7009bad0 <Sciclient_rmIrqGetRoute+0x260> @ imm = #-0x2
;                 ((search_depth == 0u) &&
7009bad0: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bad4: bb28         	cbnz	r0, 0x7009bb22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x4a
7009bad6: e7ff         	b	0x7009bad8 <Sciclient_rmIrqGetRoute+0x268> @ imm = #-0x2
;                  (Sciclient_rmIaIsIa(cur_n->id) == true))) {
7009bad8: 9806         	ldr	r0, [sp, #0x18]
7009bada: 8800         	ldrh	r0, [r0]
7009badc: f010 fe10    	bl	0x700ac700 <Sciclient_rmIaIsIa> @ imm = #0x10c20
;             if ((search_depth > 0u) ||
7009bae0: b1f8         	cbz	r0, 0x7009bb22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x3e
7009bae2: e7ff         	b	0x7009bae4 <Sciclient_rmIrqGetRoute+0x274> @ imm = #-0x2
;                 cur_psp = Sciclient_rmPsGetPsp();
7009bae4: f011 ff74    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0x11ee8
7009bae8: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 r = Sciclient_rmPsSetInp(cur_psp - (1u), inp);
7009baec: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009baf0: 3801         	subs	r0, #0x1
7009baf2: f8bd 1028    	ldrh.w	r1, [sp, #0x28]
7009baf6: b280         	uxth	r0, r0
7009baf8: f00f fb3a    	bl	0x700ab170 <Sciclient_rmPsSetInp> @ imm = #0xf674
7009bafc: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009bafe: 980c         	ldr	r0, [sp, #0x30]
7009bb00: b108         	cbz	r0, 0x7009bb06 <Sciclient_rmIrqGetRoute+0x296> @ imm = #0x2
7009bb02: e7ff         	b	0x7009bb04 <Sciclient_rmIrqGetRoute+0x294> @ imm = #-0x2
;                     break;
7009bb04: e026         	b	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x4c
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009bb06: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009bb0a: 3801         	subs	r0, #0x1
;                         outp);
7009bb0c: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009bb10: b280         	uxth	r0, r0
7009bb12: f00f fb55    	bl	0x700ab1c0 <Sciclient_rmPsSetOutp> @ imm = #0xf6aa
7009bb16: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009bb18: 980c         	ldr	r0, [sp, #0x30]
7009bb1a: b108         	cbz	r0, 0x7009bb20 <Sciclient_rmIrqGetRoute+0x2b0> @ imm = #0x2
7009bb1c: e7ff         	b	0x7009bb1e <Sciclient_rmIrqGetRoute+0x2ae> @ imm = #-0x2
;                     break;
7009bb1e: e019         	b	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x32
;             }
7009bb20: e7ff         	b	0x7009bb22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #-0x2
;             if (rt_complete == true) {
7009bb22: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009bb26: 07c0         	lsls	r0, r0, #0x1f
7009bb28: b108         	cbz	r0, 0x7009bb2e <Sciclient_rmIrqGetRoute+0x2be> @ imm = #0x2
7009bb2a: e7ff         	b	0x7009bb2c <Sciclient_rmIrqGetRoute+0x2bc> @ imm = #-0x2
;                 break;
7009bb2c: e012         	b	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x24
;                 cur_n = next_n;
7009bb2e: 9805         	ldr	r0, [sp, #0x14]
7009bb30: 9006         	str	r0, [sp, #0x18]
;                 inp = next_inp;
7009bb32: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009bb36: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = next_outp;
7009bb3a: f8bd 0022    	ldrh.w	r0, [sp, #0x22]
7009bb3e: f8ad 0024    	strh.w	r0, [sp, #0x24]
7009bb42: e7ff         	b	0x7009bb44 <Sciclient_rmIrqGetRoute+0x2d4> @ imm = #-0x2
;         }
7009bb44: e7ff         	b	0x7009bb46 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #-0x2
;     }
7009bb46: e7ff         	b	0x7009bb48 <Sciclient_rmIrqGetRoute+0x2d8> @ imm = #-0x2
;          search_depth++) {
7009bb48: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bb4c: 3001         	adds	r0, #0x1
7009bb4e: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;     for (search_depth = 0u;
7009bb52: e710         	b	0x7009b976 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x1e0
;     if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009bb54: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bb58: 9001         	str	r0, [sp, #0x4]
7009bb5a: f011 ff99    	bl	0x700ada90 <Sciclient_rmPsGetMaxPsp> @ imm = #0x11f32
7009bb5e: 4601         	mov	r1, r0
7009bb60: 9801         	ldr	r0, [sp, #0x4]
7009bb62: 4288         	cmp	r0, r1
7009bb64: db04         	blt	0x7009bb70 <Sciclient_rmIrqGetRoute+0x300> @ imm = #0x8
7009bb66: e7ff         	b	0x7009bb68 <Sciclient_rmIrqGetRoute+0x2f8> @ imm = #-0x2
7009bb68: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
7009bb6c: 900c         	str	r0, [sp, #0x30]
;     }
7009bb6e: e7ff         	b	0x7009bb70 <Sciclient_rmIrqGetRoute+0x300> @ imm = #-0x2
;     return r;
7009bb70: 980c         	ldr	r0, [sp, #0x30]
7009bb72: b00e         	add	sp, #0x38
7009bb74: bd80         	pop	{r7, pc}
7009bb76: 0000         	movs	r0, r0

7009bb78 <$Ven$TA$L$PI$$HwiP_enable>:
7009bb78: f8df f000    	ldr.w	pc, [pc, #0x0]          @ 0x7009bb7c <$Ven$TA$L$PI$$HwiP_enable+0x4>
7009bb7c: 90 e6 0a 70  	.word	0x700ae690

7009bb80 <Udma_eventReset>:
; {
7009bb80: b580         	push	{r7, lr}
7009bb82: b090         	sub	sp, #0x40
7009bb84: 900f         	str	r0, [sp, #0x3c]
7009bb86: 910e         	str	r1, [sp, #0x38]
7009bb88: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009bb8a: 9001         	str	r0, [sp, #0x4]
7009bb8c: 900d         	str	r0, [sp, #0x34]
;     eventPrms = &eventHandle->eventPrms;
7009bb8e: 990e         	ldr	r1, [sp, #0x38]
7009bb90: 3108         	adds	r1, #0x8
7009bb92: 9109         	str	r1, [sp, #0x24]
;     rmIrqReq.valid_params           = 0U;
7009bb94: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.global_event           = 0U;
7009bb96: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.src_id                 = 0U;
7009bb9a: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     rmIrqReq.src_index              = 0U;
7009bb9e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;     rmIrqReq.dst_id                 = 0U;
7009bba2: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     rmIrqReq.dst_host_irq           = 0U;
7009bba6: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     rmIrqReq.ia_id                  = 0U;
7009bbaa: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint                   = 0U;
7009bbae: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009bbb2: f88d 0022    	strb.w	r0, [sp, #0x22]
7009bbb6: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009bbb8: f88d 0023    	strb.w	r0, [sp, #0x23]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009bbbc: 9809         	ldr	r0, [sp, #0x24]
7009bbbe: 6800         	ldr	r0, [r0]
7009bbc0: 2805         	cmp	r0, #0x5
7009bbc2: d00a         	beq	0x7009bbda <Udma_eventReset+0x5a> @ imm = #0x14
7009bbc4: e7ff         	b	0x7009bbc6 <Udma_eventReset+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009bbc6: 9804         	ldr	r0, [sp, #0x10]
7009bbc8: f040 0010    	orr	r0, r0, #0x10
7009bbcc: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009bbce: 980e         	ldr	r0, [sp, #0x38]
7009bbd0: f00f fb1e    	bl	0x700ab210 <Udma_eventGetId> @ imm = #0xf63c
7009bbd4: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     }
7009bbd8: e7ff         	b	0x7009bbda <Udma_eventReset+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009bbda: 980e         	ldr	r0, [sp, #0x38]
7009bbdc: 6d80         	ldr	r0, [r0, #0x58]
7009bbde: f510 3f80    	cmn.w	r0, #0x10000
7009bbe2: d012         	beq	0x7009bc0a <Udma_eventReset+0x8a> @ imm = #0x24
7009bbe4: e7ff         	b	0x7009bbe6 <Udma_eventReset+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009bbe6: 9804         	ldr	r0, [sp, #0x10]
7009bbe8: f040 0001    	orr	r0, r0, #0x1
7009bbec: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009bbee: 9804         	ldr	r0, [sp, #0x10]
7009bbf0: f040 0002    	orr	r0, r0, #0x2
7009bbf4: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.dst_id       = drvHandle->devIdCore;
7009bbf6: 980f         	ldr	r0, [sp, #0x3c]
7009bbf8: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009bbfc: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmIrqReq.dst_host_irq = (uint16_t)eventHandle->coreIntrNum;
7009bc00: 980e         	ldr	r0, [sp, #0x38]
7009bc02: 6d80         	ldr	r0, [r0, #0x58]
7009bc04: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     }
7009bc08: e7ff         	b	0x7009bc0a <Udma_eventReset+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009bc0a: 980e         	ldr	r0, [sp, #0x38]
7009bc0c: 6980         	ldr	r0, [r0, #0x18]
7009bc0e: b128         	cbz	r0, 0x7009bc1c <Udma_eventReset+0x9c> @ imm = #0xa
7009bc10: e7ff         	b	0x7009bc12 <Udma_eventReset+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009bc12: 980e         	ldr	r0, [sp, #0x38]
7009bc14: 6980         	ldr	r0, [r0, #0x18]
7009bc16: 6cc0         	ldr	r0, [r0, #0x4c]
7009bc18: 900c         	str	r0, [sp, #0x30]
;     }
7009bc1a: e003         	b	0x7009bc24 <Udma_eventReset+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009bc1c: 980e         	ldr	r0, [sp, #0x38]
7009bc1e: 6cc0         	ldr	r0, [r0, #0x4c]
7009bc20: 900c         	str	r0, [sp, #0x30]
7009bc22: e7ff         	b	0x7009bc24 <Udma_eventReset+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009bc24: 9804         	ldr	r0, [sp, #0x10]
7009bc26: f040 0004    	orr	r0, r0, #0x4
7009bc2a: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009bc2c: 9804         	ldr	r0, [sp, #0x10]
7009bc2e: f040 0008    	orr	r0, r0, #0x8
7009bc32: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009bc34: 980f         	ldr	r0, [sp, #0x3c]
7009bc36: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009bc3a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009bc3e: 980c         	ldr	r0, [sp, #0x30]
7009bc40: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009bc44: 980e         	ldr	r0, [sp, #0x38]
7009bc46: 6d00         	ldr	r0, [r0, #0x50]
7009bc48: f64f 71ff    	movw	r1, #0xffff
7009bc4c: 4288         	cmp	r0, r1
7009bc4e: d009         	beq	0x7009bc64 <Udma_eventReset+0xe4> @ imm = #0x12
7009bc50: e7ff         	b	0x7009bc52 <Udma_eventReset+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009bc52: 9804         	ldr	r0, [sp, #0x10]
7009bc54: f040 0020    	orr	r0, r0, #0x20
7009bc58: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009bc5a: 980e         	ldr	r0, [sp, #0x38]
7009bc5c: 6d00         	ldr	r0, [r0, #0x50]
7009bc5e: f88d 0022    	strb.w	r0, [sp, #0x22]
;     }
7009bc62: e7ff         	b	0x7009bc64 <Udma_eventReset+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009bc64: 9809         	ldr	r0, [sp, #0x24]
7009bc66: 6800         	ldr	r0, [r0]
7009bc68: 2801         	cmp	r0, #0x1
7009bc6a: d00a         	beq	0x7009bc82 <Udma_eventReset+0x102> @ imm = #0x14
7009bc6c: e7ff         	b	0x7009bc6e <Udma_eventReset+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType)||
7009bc6e: 9809         	ldr	r0, [sp, #0x24]
7009bc70: 6800         	ldr	r0, [r0]
7009bc72: 2806         	cmp	r0, #0x6
7009bc74: d005         	beq	0x7009bc82 <Udma_eventReset+0x102> @ imm = #0xa
7009bc76: e7ff         	b	0x7009bc78 <Udma_eventReset+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009bc78: 9809         	ldr	r0, [sp, #0x24]
7009bc7a: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009bc7c: 2802         	cmp	r0, #0x2
7009bc7e: d14d         	bne	0x7009bd1c <Udma_eventReset+0x19c> @ imm = #0x9a
7009bc80: e7ff         	b	0x7009bc82 <Udma_eventReset+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009bc82: 9809         	ldr	r0, [sp, #0x24]
7009bc84: 6880         	ldr	r0, [r0, #0x8]
7009bc86: 900b         	str	r0, [sp, #0x2c]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009bc88: 980f         	ldr	r0, [sp, #0x3c]
7009bc8a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009bc8e: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009bc92: 9809         	ldr	r0, [sp, #0x24]
7009bc94: 6800         	ldr	r0, [r0]
7009bc96: 2801         	cmp	r0, #0x1
7009bc98: d005         	beq	0x7009bca6 <Udma_eventReset+0x126> @ imm = #0xa
7009bc9a: e7ff         	b	0x7009bc9c <Udma_eventReset+0x11c> @ imm = #-0x2
7009bc9c: 9809         	ldr	r0, [sp, #0x24]
7009bc9e: 6800         	ldr	r0, [r0]
7009bca0: 2806         	cmp	r0, #0x6
7009bca2: d12e         	bne	0x7009bd02 <Udma_eventReset+0x182> @ imm = #0x5c
7009bca4: e7ff         	b	0x7009bca6 <Udma_eventReset+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009bca6: 980b         	ldr	r0, [sp, #0x2c]
7009bca8: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009bcac: 8880         	ldrh	r0, [r0, #0x4]
7009bcae: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009bcb2: 980b         	ldr	r0, [sp, #0x2c]
7009bcb4: 7800         	ldrb	r0, [r0]
7009bcb6: 0740         	lsls	r0, r0, #0x1d
7009bcb8: 2800         	cmp	r0, #0x0
7009bcba: d509         	bpl	0x7009bcd0 <Udma_eventReset+0x150> @ imm = #0x12
7009bcbc: e7ff         	b	0x7009bcbe <Udma_eventReset+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009bcbe: 980f         	ldr	r0, [sp, #0x3c]
7009bcc0: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009bcc4: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bcc8: 4408         	add	r0, r1
7009bcca: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bcce: e017         	b	0x7009bd00 <Udma_eventReset+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009bcd0: 980b         	ldr	r0, [sp, #0x2c]
7009bcd2: 7800         	ldrb	r0, [r0]
7009bcd4: 07c0         	lsls	r0, r0, #0x1f
7009bcd6: b148         	cbz	r0, 0x7009bcec <Udma_eventReset+0x16c> @ imm = #0x12
7009bcd8: e7ff         	b	0x7009bcda <Udma_eventReset+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009bcda: 980f         	ldr	r0, [sp, #0x3c]
7009bcdc: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009bce0: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bce4: 4408         	add	r0, r1
7009bce6: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bcea: e008         	b	0x7009bcfe <Udma_eventReset+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009bcec: 980f         	ldr	r0, [sp, #0x3c]
7009bcee: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009bcf2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bcf6: 4408         	add	r0, r1
7009bcf8: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009bcfc: e7ff         	b	0x7009bcfe <Udma_eventReset+0x17e> @ imm = #-0x2
7009bcfe: e7ff         	b	0x7009bd00 <Udma_eventReset+0x180> @ imm = #-0x2
;         }
7009bd00: e00b         	b	0x7009bd1a <Udma_eventReset+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009bd02: 980b         	ldr	r0, [sp, #0x2c]
7009bd04: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009bd08: 8880         	ldrh	r0, [r0, #0x4]
7009bd0a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009bd0e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bd12: 3014         	adds	r0, #0x14
7009bd14: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009bd18: e7ff         	b	0x7009bd1a <Udma_eventReset+0x19a> @ imm = #-0x2
;     }
7009bd1a: e7ff         	b	0x7009bd1c <Udma_eventReset+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009bd1c: 9809         	ldr	r0, [sp, #0x24]
7009bd1e: 6800         	ldr	r0, [r0]
7009bd20: 2803         	cmp	r0, #0x3
7009bd22: d156         	bne	0x7009bdd2 <Udma_eventReset+0x252> @ imm = #0xac
7009bd24: e7ff         	b	0x7009bd26 <Udma_eventReset+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009bd26: 980f         	ldr	r0, [sp, #0x3c]
7009bd28: 6800         	ldr	r0, [r0]
7009bd2a: 2802         	cmp	r0, #0x2
7009bd2c: d104         	bne	0x7009bd38 <Udma_eventReset+0x1b8> @ imm = #0x8
7009bd2e: e7ff         	b	0x7009bd30 <Udma_eventReset+0x1b0> @ imm = #-0x2
7009bd30: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009bd34: 900d         	str	r0, [sp, #0x34]
;         }
7009bd36: e04b         	b	0x7009bdd0 <Udma_eventReset+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009bd38: 9809         	ldr	r0, [sp, #0x24]
7009bd3a: 6880         	ldr	r0, [r0, #0x8]
7009bd3c: 900b         	str	r0, [sp, #0x2c]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009bd3e: 980f         	ldr	r0, [sp, #0x3c]
7009bd40: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009bd44: f8ad 0014    	strh.w	r0, [sp, #0x14]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009bd48: 980b         	ldr	r0, [sp, #0x2c]
7009bd4a: 7800         	ldrb	r0, [r0]
7009bd4c: 0740         	lsls	r0, r0, #0x1d
7009bd4e: 2800         	cmp	r0, #0x0
7009bd50: d50d         	bpl	0x7009bd6e <Udma_eventReset+0x1ee> @ imm = #0x1a
7009bd52: e7ff         	b	0x7009bd54 <Udma_eventReset+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009bd54: 980b         	ldr	r0, [sp, #0x2c]
7009bd56: 6ec0         	ldr	r0, [r0, #0x6c]
7009bd58: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009bd5c: 980f         	ldr	r0, [sp, #0x3c]
7009bd5e: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009bd62: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bd66: 4408         	add	r0, r1
7009bd68: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bd6c: e02f         	b	0x7009bdce <Udma_eventReset+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009bd6e: 980b         	ldr	r0, [sp, #0x2c]
7009bd70: 7800         	ldrb	r0, [r0]
7009bd72: 0780         	lsls	r0, r0, #0x1e
7009bd74: 2800         	cmp	r0, #0x0
7009bd76: d50d         	bpl	0x7009bd94 <Udma_eventReset+0x214> @ imm = #0x1a
7009bd78: e7ff         	b	0x7009bd7a <Udma_eventReset+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009bd7a: 980b         	ldr	r0, [sp, #0x2c]
7009bd7c: 6f00         	ldr	r0, [r0, #0x70]
7009bd7e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009bd82: 980f         	ldr	r0, [sp, #0x3c]
7009bd84: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009bd88: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bd8c: 4408         	add	r0, r1
7009bd8e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bd92: e01b         	b	0x7009bdcc <Udma_eventReset+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009bd94: 980b         	ldr	r0, [sp, #0x2c]
7009bd96: 7800         	ldrb	r0, [r0]
7009bd98: 07c0         	lsls	r0, r0, #0x1f
7009bd9a: b168         	cbz	r0, 0x7009bdb8 <Udma_eventReset+0x238> @ imm = #0x1a
7009bd9c: e7ff         	b	0x7009bd9e <Udma_eventReset+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009bd9e: 980b         	ldr	r0, [sp, #0x2c]
7009bda0: 6ec0         	ldr	r0, [r0, #0x6c]
7009bda2: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009bda6: 980f         	ldr	r0, [sp, #0x3c]
7009bda8: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009bdac: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bdb0: 4408         	add	r0, r1
7009bdb2: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bdb6: e008         	b	0x7009bdca <Udma_eventReset+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009bdb8: 980f         	ldr	r0, [sp, #0x3c]
7009bdba: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009bdbe: f8ad 0014    	strh.w	r0, [sp, #0x14]
7009bdc2: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009bdc4: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009bdc8: e7ff         	b	0x7009bdca <Udma_eventReset+0x24a> @ imm = #-0x2
7009bdca: e7ff         	b	0x7009bdcc <Udma_eventReset+0x24c> @ imm = #-0x2
7009bdcc: e7ff         	b	0x7009bdce <Udma_eventReset+0x24e> @ imm = #-0x2
7009bdce: e7ff         	b	0x7009bdd0 <Udma_eventReset+0x250> @ imm = #-0x2
;     }
7009bdd0: e7ff         	b	0x7009bdd2 <Udma_eventReset+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009bdd2: 9809         	ldr	r0, [sp, #0x24]
7009bdd4: 6800         	ldr	r0, [r0]
7009bdd6: 2804         	cmp	r0, #0x4
7009bdd8: d130         	bne	0x7009be3c <Udma_eventReset+0x2bc> @ imm = #0x60
7009bdda: e7ff         	b	0x7009bddc <Udma_eventReset+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009bddc: 9809         	ldr	r0, [sp, #0x24]
7009bdde: 68c0         	ldr	r0, [r0, #0xc]
7009bde0: 900a         	str	r0, [sp, #0x28]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009bde2: 980f         	ldr	r0, [sp, #0x3c]
7009bde4: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009bde8: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009bdec: 980a         	ldr	r0, [sp, #0x28]
7009bdee: 8880         	ldrh	r0, [r0, #0x4]
7009bdf0: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009bdf4: 980f         	ldr	r0, [sp, #0x3c]
7009bdf6: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009bdfa: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bdfe: 4408         	add	r0, r1
7009be00: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009be04: 980a         	ldr	r0, [sp, #0x28]
7009be06: 6dc0         	ldr	r0, [r0, #0x5c]
7009be08: 2804         	cmp	r0, #0x4
7009be0a: d316         	blo	0x7009be3a <Udma_eventReset+0x2ba> @ imm = #0x2c
7009be0c: e7ff         	b	0x7009be0e <Udma_eventReset+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009be0e: 980a         	ldr	r0, [sp, #0x28]
7009be10: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009be12: 2807         	cmp	r0, #0x7
7009be14: d811         	bhi	0x7009be3a <Udma_eventReset+0x2ba> @ imm = #0x22
7009be16: e7ff         	b	0x7009be18 <Udma_eventReset+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009be18: 980f         	ldr	r0, [sp, #0x3c]
7009be1a: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009be1e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009be22: 1a40         	subs	r0, r0, r1
7009be24: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009be28: 980f         	ldr	r0, [sp, #0x3c]
7009be2a: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009be2e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009be32: 4408         	add	r0, r1
7009be34: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         }
7009be38: e7ff         	b	0x7009be3a <Udma_eventReset+0x2ba> @ imm = #-0x2
;     }
7009be3a: e7ff         	b	0x7009be3c <Udma_eventReset+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009be3c: 980d         	ldr	r0, [sp, #0x34]
7009be3e: b9b0         	cbnz	r0, 0x7009be6e <Udma_eventReset+0x2ee> @ imm = #0x2c
7009be40: e7ff         	b	0x7009be42 <Udma_eventReset+0x2c2> @ imm = #-0x2
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009be42: 980f         	ldr	r0, [sp, #0x3c]
7009be44: 6800         	ldr	r0, [r0]
7009be46: b130         	cbz	r0, 0x7009be56 <Udma_eventReset+0x2d6> @ imm = #0xc
7009be48: e7ff         	b	0x7009be4a <Udma_eventReset+0x2ca> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009be4a: 9809         	ldr	r0, [sp, #0x24]
7009be4c: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009be4e: 2805         	cmp	r0, #0x5
7009be50: d101         	bne	0x7009be56 <Udma_eventReset+0x2d6> @ imm = #0x2
7009be52: e7ff         	b	0x7009be54 <Udma_eventReset+0x2d4> @ imm = #-0x2
;         }
7009be54: e00a         	b	0x7009be6c <Udma_eventReset+0x2ec> @ imm = #0x14
7009be56: a802         	add	r0, sp, #0x8
7009be58: f04f 31ff    	mov.w	r1, #0xffffffff
;             retVal = Sciclient_rmIrqRelease(&rmIrqReq, UDMA_SCICLIENT_TIMEOUT);
7009be5c: f011 fbb8    	bl	0x700ad5d0 <Sciclient_rmIrqRelease> @ imm = #0x11770
7009be60: 900d         	str	r0, [sp, #0x34]
;             if(CSL_PASS != retVal)
7009be62: 980d         	ldr	r0, [sp, #0x34]
7009be64: b108         	cbz	r0, 0x7009be6a <Udma_eventReset+0x2ea> @ imm = #0x2
7009be66: e7ff         	b	0x7009be68 <Udma_eventReset+0x2e8> @ imm = #-0x2
;             }
7009be68: e7ff         	b	0x7009be6a <Udma_eventReset+0x2ea> @ imm = #-0x2
7009be6a: e7ff         	b	0x7009be6c <Udma_eventReset+0x2ec> @ imm = #-0x2
;     }
7009be6c: e7ff         	b	0x7009be6e <Udma_eventReset+0x2ee> @ imm = #-0x2
;     return (retVal);
7009be6e: 980d         	ldr	r0, [sp, #0x34]
7009be70: b010         	add	sp, #0x40
7009be72: bd80         	pop	{r7, pc}
		...

7009be80 <Sciclient_service>:
; {
7009be80: b580         	push	{r7, lr}
7009be82: b094         	sub	sp, #0x50
7009be84: 9013         	str	r0, [sp, #0x4c]
7009be86: 9112         	str	r1, [sp, #0x48]
7009be88: 2000         	movs	r0, #0x0
;     int32_t   status        = SystemP_SUCCESS;
7009be8a: 9011         	str	r0, [sp, #0x44]
7009be8c: 210f         	movs	r1, #0xf
;     uint32_t  contextId     = SCICLIENT_CONTEXT_MAX_NUM;
7009be8e: 9110         	str	r1, [sp, #0x40]
;     uint32_t  initialCount  = 0U;
7009be90: 900f         	str	r0, [sp, #0x3c]
;     uint8_t   localSeqId    = gSciclientHandle.currSeqId;
7009be92: f240 4138    	movw	r1, #0x438
7009be96: f2c7 010b    	movt	r1, #0x700b
7009be9a: 6809         	ldr	r1, [r1]
7009be9c: f88d 103b    	strb.w	r1, [sp, #0x3b]
;     uint32_t  txPayloadSize = 0U;
7009bea0: 900d         	str	r0, [sp, #0x34]
;     uint32_t  rxPayloadSize = 0U;
7009bea2: 900c         	str	r0, [sp, #0x30]
;     uint8_t  *pLocalRespPayload = NULL;
7009bea4: 900b         	str	r0, [sp, #0x2c]
;     uint8_t  *pSecHeader = NULL;
7009bea6: 9007         	str	r0, [sp, #0x1c]
;     if((pReqPrm == NULL) || (pRespPrm == NULL) || (pReqPrm->pReqPayload == NULL))
7009bea8: 9813         	ldr	r0, [sp, #0x4c]
7009beaa: b138         	cbz	r0, 0x7009bebc <Sciclient_service+0x3c> @ imm = #0xe
7009beac: e7ff         	b	0x7009beae <Sciclient_service+0x2e> @ imm = #-0x2
7009beae: 9812         	ldr	r0, [sp, #0x48]
7009beb0: b120         	cbz	r0, 0x7009bebc <Sciclient_service+0x3c> @ imm = #0x8
7009beb2: e7ff         	b	0x7009beb4 <Sciclient_service+0x34> @ imm = #-0x2
7009beb4: 9813         	ldr	r0, [sp, #0x4c]
7009beb6: 6880         	ldr	r0, [r0, #0x8]
7009beb8: b920         	cbnz	r0, 0x7009bec4 <Sciclient_service+0x44> @ imm = #0x8
7009beba: e7ff         	b	0x7009bebc <Sciclient_service+0x3c> @ imm = #-0x2
7009bebc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009bec0: 9011         	str	r0, [sp, #0x44]
;     }
7009bec2: e09e         	b	0x7009c002 <Sciclient_service+0x182> @ imm = #0x13c
;         contextId = Sciclient_getCurrentContext(pReqPrm->messageType);
7009bec4: 9813         	ldr	r0, [sp, #0x4c]
7009bec6: 8800         	ldrh	r0, [r0]
7009bec8: f009 fe12    	bl	0x700a5af0 <Sciclient_getCurrentContext> @ imm = #0x9c24
7009becc: 9010         	str	r0, [sp, #0x40]
;         if(contextId < SCICLIENT_CONTEXT_MAX_NUM)
7009bece: 9810         	ldr	r0, [sp, #0x40]
7009bed0: 280e         	cmp	r0, #0xe
7009bed2: f200 8091    	bhi.w	0x7009bff8 <Sciclient_service+0x178> @ imm = #0x122
7009bed6: e7ff         	b	0x7009bed8 <Sciclient_service+0x58> @ imm = #-0x2
;             txThread = Sciclient_getTxThreadId(contextId);
7009bed8: 9810         	ldr	r0, [sp, #0x40]
7009beda: f011 f931    	bl	0x700ad140 <Sciclient_getTxThreadId> @ imm = #0x11262
7009bede: 900a         	str	r0, [sp, #0x28]
;             rxThread = Sciclient_getRxThreadId(contextId);
7009bee0: 9810         	ldr	r0, [sp, #0x40]
7009bee2: f011 f91d    	bl	0x700ad120 <Sciclient_getRxThreadId> @ imm = #0x1123a
7009bee6: 9009         	str	r0, [sp, #0x24]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009bee8: 9810         	ldr	r0, [sp, #0x40]
7009beea: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009beee: f24f 0068    	movw	r0, #0xf068
7009bef2: f2c7 000a    	movt	r0, #0x700a
7009bef6: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009befa: b938         	cbnz	r0, 0x7009bf0c <Sciclient_service+0x8c> @ imm = #0xe
7009befc: e7ff         	b	0x7009befe <Sciclient_service+0x7e> @ imm = #-0x2
;                 gSecHeaderSizeWords = sizeof(struct tisci_sec_header)/sizeof(uint32_t);
7009befe: f240 5130    	movw	r1, #0x530
7009bf02: f2c7 010b    	movt	r1, #0x700b
7009bf06: 2001         	movs	r0, #0x1
7009bf08: 7008         	strb	r0, [r1]
;             }
7009bf0a: e006         	b	0x7009bf1a <Sciclient_service+0x9a> @ imm = #0xc
;                 gSecHeaderSizeWords = 0;
7009bf0c: f240 5130    	movw	r1, #0x530
7009bf10: f2c7 010b    	movt	r1, #0x700b
7009bf14: 2000         	movs	r0, #0x0
7009bf16: 7008         	strb	r0, [r1]
7009bf18: e7ff         	b	0x7009bf1a <Sciclient_service+0x9a> @ imm = #-0x2
;             gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
7009bf1a: f240 30c8    	movw	r0, #0x3c8
7009bf1e: f2c7 000b    	movt	r0, #0x700b
7009bf22: f010 fbd5    	bl	0x700ac6d0 <CSL_secProxyGetMaxMsgSize> @ imm = #0x107aa
7009bf26: 3804         	subs	r0, #0x4
7009bf28: f240 4138    	movw	r1, #0x438
7009bf2c: f2c7 010b    	movt	r1, #0x700b
7009bf30: 6148         	str	r0, [r1, #0x14]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009bf32: 9810         	ldr	r0, [sp, #0x40]
7009bf34: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009bf38: f24f 0068    	movw	r0, #0xf068
7009bf3c: f2c7 000a    	movt	r0, #0x700a
7009bf40: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009bf44: b940         	cbnz	r0, 0x7009bf58 <Sciclient_service+0xd8> @ imm = #0x10
7009bf46: e7ff         	b	0x7009bf48 <Sciclient_service+0xc8> @ imm = #-0x2
7009bf48: 2000         	movs	r0, #0x0
;                 secHeader.integ_check = (uint16_t)0;
7009bf4a: f8ad 0014    	strh.w	r0, [sp, #0x14]
;                 secHeader.rsvd = (uint16_t)0;
7009bf4e: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009bf52: a805         	add	r0, sp, #0x14
;                 pSecHeader = (uint8_t * )(&secHeader);
7009bf54: 9007         	str	r0, [sp, #0x1c]
;             }
7009bf56: e7ff         	b	0x7009bf58 <Sciclient_service+0xd8> @ imm = #-0x2
;             if (pReqPrm->reqPayloadSize > 0U)
7009bf58: 9813         	ldr	r0, [sp, #0x4c]
7009bf5a: 68c0         	ldr	r0, [r0, #0xc]
7009bf5c: b128         	cbz	r0, 0x7009bf6a <Sciclient_service+0xea> @ imm = #0xa
7009bf5e: e7ff         	b	0x7009bf60 <Sciclient_service+0xe0> @ imm = #-0x2
;                 txPayloadSize = pReqPrm->reqPayloadSize - sizeof(struct tisci_header);
7009bf60: 9813         	ldr	r0, [sp, #0x4c]
7009bf62: 68c0         	ldr	r0, [r0, #0xc]
7009bf64: 3808         	subs	r0, #0x8
7009bf66: 900d         	str	r0, [sp, #0x34]
;             }
7009bf68: e002         	b	0x7009bf70 <Sciclient_service+0xf0> @ imm = #0x4
7009bf6a: 2000         	movs	r0, #0x0
;                 txPayloadSize = 0U;
7009bf6c: 900d         	str	r0, [sp, #0x34]
7009bf6e: e7ff         	b	0x7009bf70 <Sciclient_service+0xf0> @ imm = #-0x2
;             if (txPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009bf70: 980d         	ldr	r0, [sp, #0x34]
7009bf72: f240 4138    	movw	r1, #0x438
7009bf76: f2c7 010b    	movt	r1, #0x700b
7009bf7a: 6949         	ldr	r1, [r1, #0x14]
7009bf7c: 3908         	subs	r1, #0x8
7009bf7e: 4288         	cmp	r0, r1
7009bf80: d904         	bls	0x7009bf8c <Sciclient_service+0x10c> @ imm = #0x8
7009bf82: e7ff         	b	0x7009bf84 <Sciclient_service+0x104> @ imm = #-0x2
7009bf84: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009bf88: 9011         	str	r0, [sp, #0x44]
;             }
7009bf8a: e7ff         	b	0x7009bf8c <Sciclient_service+0x10c> @ imm = #-0x2
;             if ((txPayloadSize > 0U) && (pReqPrm->pReqPayload == NULL))
7009bf8c: 980d         	ldr	r0, [sp, #0x34]
7009bf8e: b140         	cbz	r0, 0x7009bfa2 <Sciclient_service+0x122> @ imm = #0x10
7009bf90: e7ff         	b	0x7009bf92 <Sciclient_service+0x112> @ imm = #-0x2
7009bf92: 9813         	ldr	r0, [sp, #0x4c]
7009bf94: 6880         	ldr	r0, [r0, #0x8]
7009bf96: b920         	cbnz	r0, 0x7009bfa2 <Sciclient_service+0x122> @ imm = #0x8
7009bf98: e7ff         	b	0x7009bf9a <Sciclient_service+0x11a> @ imm = #-0x2
7009bf9a: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009bf9e: 9011         	str	r0, [sp, #0x44]
;             }
7009bfa0: e7ff         	b	0x7009bfa2 <Sciclient_service+0x122> @ imm = #-0x2
;             if (pRespPrm->respPayloadSize > 0U)
7009bfa2: 9812         	ldr	r0, [sp, #0x48]
7009bfa4: 6880         	ldr	r0, [r0, #0x8]
7009bfa6: b128         	cbz	r0, 0x7009bfb4 <Sciclient_service+0x134> @ imm = #0xa
7009bfa8: e7ff         	b	0x7009bfaa <Sciclient_service+0x12a> @ imm = #-0x2
;                 rxPayloadSize = pRespPrm->respPayloadSize - sizeof(struct tisci_header);
7009bfaa: 9812         	ldr	r0, [sp, #0x48]
7009bfac: 6880         	ldr	r0, [r0, #0x8]
7009bfae: 3808         	subs	r0, #0x8
7009bfb0: 900c         	str	r0, [sp, #0x30]
;             }
7009bfb2: e002         	b	0x7009bfba <Sciclient_service+0x13a> @ imm = #0x4
7009bfb4: 2000         	movs	r0, #0x0
;                 rxPayloadSize = 0U;
7009bfb6: 900c         	str	r0, [sp, #0x30]
7009bfb8: e7ff         	b	0x7009bfba <Sciclient_service+0x13a> @ imm = #-0x2
;             if (rxPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009bfba: 980c         	ldr	r0, [sp, #0x30]
7009bfbc: f240 4138    	movw	r1, #0x438
7009bfc0: f2c7 010b    	movt	r1, #0x700b
7009bfc4: 6949         	ldr	r1, [r1, #0x14]
7009bfc6: 3908         	subs	r1, #0x8
7009bfc8: 4288         	cmp	r0, r1
7009bfca: d904         	bls	0x7009bfd6 <Sciclient_service+0x156> @ imm = #0x8
7009bfcc: e7ff         	b	0x7009bfce <Sciclient_service+0x14e> @ imm = #-0x2
7009bfce: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009bfd2: 9011         	str	r0, [sp, #0x44]
;             }
7009bfd4: e7ff         	b	0x7009bfd6 <Sciclient_service+0x156> @ imm = #-0x2
;             if ((rxPayloadSize > 0U) && (pRespPrm->pRespPayload == NULL))
7009bfd6: 980c         	ldr	r0, [sp, #0x30]
7009bfd8: b140         	cbz	r0, 0x7009bfec <Sciclient_service+0x16c> @ imm = #0x10
7009bfda: e7ff         	b	0x7009bfdc <Sciclient_service+0x15c> @ imm = #-0x2
7009bfdc: 9812         	ldr	r0, [sp, #0x48]
7009bfde: 6840         	ldr	r0, [r0, #0x4]
7009bfe0: b920         	cbnz	r0, 0x7009bfec <Sciclient_service+0x16c> @ imm = #0x8
7009bfe2: e7ff         	b	0x7009bfe4 <Sciclient_service+0x164> @ imm = #-0x2
7009bfe4: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009bfe8: 9011         	str	r0, [sp, #0x44]
;             }
7009bfea: e004         	b	0x7009bff6 <Sciclient_service+0x176> @ imm = #0x8
;                 pLocalRespPayload = (uint8_t *)(pRespPrm->pRespPayload + sizeof(struct tisci_header));
7009bfec: 9812         	ldr	r0, [sp, #0x48]
7009bfee: 6840         	ldr	r0, [r0, #0x4]
7009bff0: 3008         	adds	r0, #0x8
7009bff2: 900b         	str	r0, [sp, #0x2c]
7009bff4: e7ff         	b	0x7009bff6 <Sciclient_service+0x176> @ imm = #-0x2
;         }
7009bff6: e003         	b	0x7009c000 <Sciclient_service+0x180> @ imm = #0x6
7009bff8: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009bffc: 9011         	str	r0, [sp, #0x44]
7009bffe: e7ff         	b	0x7009c000 <Sciclient_service+0x180> @ imm = #-0x2
7009c000: e7ff         	b	0x7009c002 <Sciclient_service+0x182> @ imm = #-0x2
;     key = HwiP_disable();
7009c002: f012 eb36    	blx	0x700ae670 <HwiP_disable> @ imm = #0x1266c
7009c006: 9008         	str	r0, [sp, #0x20]
;     if (SystemP_SUCCESS == status)
7009c008: 9811         	ldr	r0, [sp, #0x44]
7009c00a: 2800         	cmp	r0, #0x0
7009c00c: d159         	bne	0x7009c0c2 <Sciclient_service+0x242> @ imm = #0xb2
7009c00e: e7ff         	b	0x7009c010 <Sciclient_service+0x190> @ imm = #-0x2
;         Sciclient_secProxyFlush(rxThread);
7009c010: 9809         	ldr	r0, [sp, #0x24]
7009c012: f010 f8a5    	bl	0x700ac160 <Sciclient_secProxyFlush> @ imm = #0x1014a
;         header = (struct tisci_header*)pReqPrm->pReqPayload;
7009c016: 9813         	ldr	r0, [sp, #0x4c]
7009c018: 6880         	ldr	r0, [r0, #0x8]
7009c01a: 9006         	str	r0, [sp, #0x18]
;         header->type = pReqPrm->messageType;
7009c01c: 9813         	ldr	r0, [sp, #0x4c]
7009c01e: 8800         	ldrh	r0, [r0]
7009c020: 9906         	ldr	r1, [sp, #0x18]
7009c022: 8008         	strh	r0, [r1]
;         header->host = (uint8_t) gSciclientMap[contextId].hostId;
7009c024: 9810         	ldr	r0, [sp, #0x40]
7009c026: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009c02a: f24f 0068    	movw	r0, #0xf068
7009c02e: f2c7 000a    	movt	r0, #0x700a
7009c032: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009c036: 6840         	ldr	r0, [r0, #0x4]
7009c038: 9906         	ldr	r1, [sp, #0x18]
7009c03a: 7088         	strb	r0, [r1, #0x2]
;         header->seq = localSeqId;
7009c03c: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
7009c040: 9906         	ldr	r1, [sp, #0x18]
7009c042: 70c8         	strb	r0, [r1, #0x3]
;         pFlags = (uint8_t*)&pReqPrm->flags;
7009c044: 9813         	ldr	r0, [sp, #0x4c]
7009c046: 3004         	adds	r0, #0x4
7009c048: 9004         	str	r0, [sp, #0x10]
7009c04a: 2000         	movs	r0, #0x0
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009c04c: 9003         	str	r0, [sp, #0xc]
7009c04e: e7ff         	b	0x7009c050 <Sciclient_service+0x1d0> @ imm = #-0x2
7009c050: 9803         	ldr	r0, [sp, #0xc]
7009c052: 2803         	cmp	r0, #0x3
7009c054: d811         	bhi	0x7009c07a <Sciclient_service+0x1fa> @ imm = #0x22
7009c056: e7ff         	b	0x7009c058 <Sciclient_service+0x1d8> @ imm = #-0x2
;             uint8_t *pDestFlags = ((uint8_t*)&header->flags) + numBytes;
7009c058: 9806         	ldr	r0, [sp, #0x18]
7009c05a: 9903         	ldr	r1, [sp, #0xc]
7009c05c: 4408         	add	r0, r1
7009c05e: 3004         	adds	r0, #0x4
7009c060: 9002         	str	r0, [sp, #0x8]
;             *pDestFlags = *pFlags;
7009c062: 9804         	ldr	r0, [sp, #0x10]
7009c064: 7800         	ldrb	r0, [r0]
7009c066: 9902         	ldr	r1, [sp, #0x8]
7009c068: 7008         	strb	r0, [r1]
;             pFlags++;
7009c06a: 9804         	ldr	r0, [sp, #0x10]
7009c06c: 3001         	adds	r0, #0x1
7009c06e: 9004         	str	r0, [sp, #0x10]
;         }
7009c070: e7ff         	b	0x7009c072 <Sciclient_service+0x1f2> @ imm = #-0x2
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009c072: 9803         	ldr	r0, [sp, #0xc]
7009c074: 3001         	adds	r0, #0x1
7009c076: 9003         	str	r0, [sp, #0xc]
7009c078: e7ea         	b	0x7009c050 <Sciclient_service+0x1d0> @ imm = #-0x2c
;         gSciclientHandle.currSeqId = (gSciclientHandle.currSeqId + 1U) %
7009c07a: f240 4138    	movw	r1, #0x438
7009c07e: f2c7 010b    	movt	r1, #0x700b
7009c082: 6808         	ldr	r0, [r1]
7009c084: 3001         	adds	r0, #0x1
7009c086: f644 1225    	movw	r2, #0x4925
7009c08a: f2c2 4292    	movt	r2, #0x2492
7009c08e: fba0 3202    	umull	r3, r2, r0, r2
7009c092: 1a83         	subs	r3, r0, r2
7009c094: eb02 0353    	add.w	r3, r2, r3, lsr #1
7009c098: 089a         	lsrs	r2, r3, #0x2
7009c09a: 00d2         	lsls	r2, r2, #0x3
7009c09c: eba2 0293    	sub.w	r2, r2, r3, lsr #2
7009c0a0: 1a80         	subs	r0, r0, r2
7009c0a2: 6008         	str	r0, [r1]
;         status = Sciclient_secProxyVerifyThread(txThread);
7009c0a4: 980a         	ldr	r0, [sp, #0x28]
7009c0a6: f010 fdfb    	bl	0x700acca0 <Sciclient_secProxyVerifyThread> @ imm = #0x10bf6
7009c0aa: 9011         	str	r0, [sp, #0x44]
;         if (SystemP_SUCCESS == status)
7009c0ac: 9811         	ldr	r0, [sp, #0x44]
7009c0ae: b938         	cbnz	r0, 0x7009c0c0 <Sciclient_service+0x240> @ imm = #0xe
7009c0b0: e7ff         	b	0x7009c0b2 <Sciclient_service+0x232> @ imm = #-0x2
;             status = Sciclient_secProxyWaitThread(txThread, pReqPrm->timeout);
7009c0b2: 980a         	ldr	r0, [sp, #0x28]
7009c0b4: 9913         	ldr	r1, [sp, #0x4c]
7009c0b6: 6909         	ldr	r1, [r1, #0x10]
7009c0b8: f00f fd72    	bl	0x700abba0 <Sciclient_secProxyWaitThread> @ imm = #0xfae4
7009c0bc: 9011         	str	r0, [sp, #0x44]
;         }
7009c0be: e7ff         	b	0x7009c0c0 <Sciclient_service+0x240> @ imm = #-0x2
;     }
7009c0c0: e7ff         	b	0x7009c0c2 <Sciclient_service+0x242> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
7009c0c2: 9811         	ldr	r0, [sp, #0x44]
7009c0c4: b9b0         	cbnz	r0, 0x7009c0f4 <Sciclient_service+0x274> @ imm = #0x2c
7009c0c6: e7ff         	b	0x7009c0c8 <Sciclient_service+0x248> @ imm = #-0x2
;         initialCount = Sciclient_secProxyReadThreadCount(rxThread);
7009c0c8: 9809         	ldr	r0, [sp, #0x24]
7009c0ca: f011 fa91    	bl	0x700ad5f0 <Sciclient_secProxyReadThreadCount> @ imm = #0x11522
7009c0ce: 900f         	str	r0, [sp, #0x3c]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009c0d0: 980a         	ldr	r0, [sp, #0x28]
7009c0d2: 9907         	ldr	r1, [sp, #0x1c]
7009c0d4: 9a06         	ldr	r2, [sp, #0x18]
;                               (pReqPrm->pReqPayload + sizeof(struct tisci_header)),
7009c0d6: 9b13         	ldr	r3, [sp, #0x4c]
7009c0d8: 689b         	ldr	r3, [r3, #0x8]
7009c0da: 3308         	adds	r3, #0x8
;                               txPayloadSize);
7009c0dc: f8dd c034    	ldr.w	r12, [sp, #0x34]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009c0e0: 46ee         	mov	lr, sp
7009c0e2: f8ce c000    	str.w	r12, [lr]
7009c0e6: f004 fb7b    	bl	0x700a07e0 <Sciclient_sendMessage> @ imm = #0x46f6
;         status = Sciclient_secProxyVerifyThread(rxThread);
7009c0ea: 9809         	ldr	r0, [sp, #0x24]
7009c0ec: f010 fdd8    	bl	0x700acca0 <Sciclient_secProxyVerifyThread> @ imm = #0x10bb0
7009c0f0: 9011         	str	r0, [sp, #0x44]
;     }
7009c0f2: e7ff         	b	0x7009c0f4 <Sciclient_service+0x274> @ imm = #-0x2
;     if ((status == SystemP_SUCCESS) &&
7009c0f4: 9811         	ldr	r0, [sp, #0x44]
7009c0f6: b978         	cbnz	r0, 0x7009c118 <Sciclient_service+0x298> @ imm = #0x1e
7009c0f8: e7ff         	b	0x7009c0fa <Sciclient_service+0x27a> @ imm = #-0x2
;         ((pReqPrm->flags & TISCI_MSG_FLAG_MASK) != 0U))
7009c0fa: 9813         	ldr	r0, [sp, #0x4c]
;     if ((status == SystemP_SUCCESS) &&
7009c0fc: 7900         	ldrb	r0, [r0, #0x4]
7009c0fe: 0780         	lsls	r0, r0, #0x1e
7009c100: b150         	cbz	r0, 0x7009c118 <Sciclient_service+0x298> @ imm = #0x14
7009c102: e7ff         	b	0x7009c104 <Sciclient_service+0x284> @ imm = #-0x2
;         status = Sciclient_waitForMessage(rxThread, pReqPrm->timeout, initialCount, localSeqId);
7009c104: 9809         	ldr	r0, [sp, #0x24]
7009c106: 9913         	ldr	r1, [sp, #0x4c]
7009c108: 6909         	ldr	r1, [r1, #0x10]
7009c10a: 9a0f         	ldr	r2, [sp, #0x3c]
7009c10c: f89d 303b    	ldrb.w	r3, [sp, #0x3b]
7009c110: f008 f8ae    	bl	0x700a4270 <Sciclient_waitForMessage> @ imm = #0x815c
7009c114: 9011         	str	r0, [sp, #0x44]
;     }
7009c116: e7ff         	b	0x7009c118 <Sciclient_service+0x298> @ imm = #-0x2
;     if(status == SystemP_SUCCESS)
7009c118: 9811         	ldr	r0, [sp, #0x44]
7009c11a: b990         	cbnz	r0, 0x7009c142 <Sciclient_service+0x2c2> @ imm = #0x24
7009c11c: e7ff         	b	0x7009c11e <Sciclient_service+0x29e> @ imm = #-0x2
;         pRespPrm->flags = Sciclient_secProxyReadThread32(rxThread, 1U+gSecHeaderSizeWords);
7009c11e: 9809         	ldr	r0, [sp, #0x24]
7009c120: f240 5130    	movw	r1, #0x530
7009c124: f2c7 010b    	movt	r1, #0x700b
7009c128: 7809         	ldrb	r1, [r1]
7009c12a: 3101         	adds	r1, #0x1
7009c12c: b2c9         	uxtb	r1, r1
7009c12e: f010 fb17    	bl	0x700ac760 <Sciclient_secProxyReadThread32> @ imm = #0x1062e
7009c132: 9912         	ldr	r1, [sp, #0x48]
7009c134: 6008         	str	r0, [r1]
;         Sciclient_recvMessage(rxThread, pLocalRespPayload, rxPayloadSize);
7009c136: 9809         	ldr	r0, [sp, #0x24]
7009c138: 990b         	ldr	r1, [sp, #0x2c]
7009c13a: 9a0c         	ldr	r2, [sp, #0x30]
7009c13c: f005 f8f8    	bl	0x700a1330 <Sciclient_recvMessage> @ imm = #0x51f0
;     }
7009c140: e7ff         	b	0x7009c142 <Sciclient_service+0x2c2> @ imm = #-0x2
;     HwiP_restore(key);
7009c142: 9808         	ldr	r0, [sp, #0x20]
7009c144: f012 eab4    	blx	0x700ae6b0 <HwiP_restore> @ imm = #0x12568
;     return status;
7009c148: 9811         	ldr	r0, [sp, #0x44]
7009c14a: b014         	add	sp, #0x50
7009c14c: bd80         	pop	{r7, pc}
7009c14e: 0000         	movs	r0, r0

7009c150 <Udma_chDisableRxChan>:
; {
7009c150: b580         	push	{r7, lr}
7009c152: b096         	sub	sp, #0x58
7009c154: 9015         	str	r0, [sp, #0x54]
7009c156: 9114         	str	r1, [sp, #0x50]
7009c158: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009c15a: 9013         	str	r0, [sp, #0x4c]
;     uint32_t            currTimeout = 0U, regVal;
7009c15c: 9012         	str	r0, [sp, #0x48]
;     uint32_t            peerRtEnable = 0U, peerRtEnableBit = 0U;
7009c15e: 9004         	str	r0, [sp, #0x10]
7009c160: 9003         	str	r0, [sp, #0xc]
;     drvHandle = chHandle->drvHandle;
7009c162: 9815         	ldr	r0, [sp, #0x54]
7009c164: 6e80         	ldr	r0, [r0, #0x68]
7009c166: 9010         	str	r0, [sp, #0x40]
7009c168: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009c16a: 9002         	str	r0, [sp, #0x8]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c16c: 9810         	ldr	r0, [sp, #0x40]
7009c16e: 6800         	ldr	r0, [r0]
7009c170: 2801         	cmp	r0, #0x1
7009c172: d115         	bne	0x7009c1a0 <Udma_chDisableRxChan+0x50> @ imm = #0x2a
7009c174: e7ff         	b	0x7009c176 <Udma_chDisableRxChan+0x26> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
7009c176: 9815         	ldr	r0, [sp, #0x54]
7009c178: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009c17c: f500 7008    	add.w	r0, r0, #0x220
7009c180: f011 fc0e    	bl	0x700ad9a0 <CSL_REG32_RD_RAW> @ imm = #0x1181c
7009c184: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009c186: 9811         	ldr	r0, [sp, #0x44]
7009c188: f040 4080    	orr	r0, r0, #0x40000000
7009c18c: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
7009c18e: 9815         	ldr	r0, [sp, #0x54]
7009c190: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009c194: f500 7008    	add.w	r0, r0, #0x220
7009c198: 9911         	ldr	r1, [sp, #0x44]
7009c19a: f011 fb61    	bl	0x700ad860 <CSL_REG32_WR_RAW> @ imm = #0x116c2
;     }
7009c19e: e01a         	b	0x7009c1d6 <Udma_chDisableRxChan+0x86> @ imm = #0x34
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c1a0: 9810         	ldr	r0, [sp, #0x40]
7009c1a2: 6800         	ldr	r0, [r0]
7009c1a4: 2802         	cmp	r0, #0x2
7009c1a6: d115         	bne	0x7009c1d4 <Udma_chDisableRxChan+0x84> @ imm = #0x2a
7009c1a8: e7ff         	b	0x7009c1aa <Udma_chDisableRxChan+0x5a> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
7009c1aa: 9815         	ldr	r0, [sp, #0x54]
7009c1ac: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009c1b0: f500 7008    	add.w	r0, r0, #0x220
7009c1b4: f011 fbf4    	bl	0x700ad9a0 <CSL_REG32_RD_RAW> @ imm = #0x117e8
7009c1b8: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009c1ba: 9811         	ldr	r0, [sp, #0x44]
7009c1bc: f040 4080    	orr	r0, r0, #0x40000000
7009c1c0: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
7009c1c2: 9815         	ldr	r0, [sp, #0x54]
7009c1c4: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009c1c8: f500 7008    	add.w	r0, r0, #0x220
7009c1cc: 9911         	ldr	r1, [sp, #0x44]
7009c1ce: f011 fb47    	bl	0x700ad860 <CSL_REG32_WR_RAW> @ imm = #0x1168e
;     }
7009c1d2: e7ff         	b	0x7009c1d4 <Udma_chDisableRxChan+0x84> @ imm = #-0x2
7009c1d4: e7ff         	b	0x7009c1d6 <Udma_chDisableRxChan+0x86> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c1d6: e7ff         	b	0x7009c1d8 <Udma_chDisableRxChan+0x88> @ imm = #-0x2
7009c1d8: 9813         	ldr	r0, [sp, #0x4c]
7009c1da: bbc8         	cbnz	r0, 0x7009c250 <Udma_chDisableRxChan+0x100> @ imm = #0x72
7009c1dc: e7ff         	b	0x7009c1de <Udma_chDisableRxChan+0x8e> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c1de: 9810         	ldr	r0, [sp, #0x40]
7009c1e0: 6800         	ldr	r0, [r0]
7009c1e2: 2801         	cmp	r0, #0x1
7009c1e4: d110         	bne	0x7009c208 <Udma_chDisableRxChan+0xb8> @ imm = #0x20
7009c1e6: e7ff         	b	0x7009c1e8 <Udma_chDisableRxChan+0x98> @ imm = #-0x2
;             (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009c1e8: 9a10         	ldr	r2, [sp, #0x40]
7009c1ea: f102 0008    	add.w	r0, r2, #0x8
7009c1ee: 9915         	ldr	r1, [sp, #0x54]
7009c1f0: 6f09         	ldr	r1, [r1, #0x70]
7009c1f2: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c1f6: 4411         	add	r1, r2
7009c1f8: aa0a         	add	r2, sp, #0x28
7009c1fa: f010 fb59    	bl	0x700ac8b0 <CSL_bcdmaGetRxRT> @ imm = #0x106b2
;             if(FALSE == bcdmaRtStatus.enable)
7009c1fe: 980a         	ldr	r0, [sp, #0x28]
7009c200: b908         	cbnz	r0, 0x7009c206 <Udma_chDisableRxChan+0xb6> @ imm = #0x2
7009c202: e7ff         	b	0x7009c204 <Udma_chDisableRxChan+0xb4> @ imm = #-0x2
;                 break;
7009c204: e024         	b	0x7009c250 <Udma_chDisableRxChan+0x100> @ imm = #0x48
;         }
7009c206: e011         	b	0x7009c22c <Udma_chDisableRxChan+0xdc> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c208: 9810         	ldr	r0, [sp, #0x40]
7009c20a: 6800         	ldr	r0, [r0]
7009c20c: 2802         	cmp	r0, #0x2
7009c20e: d10c         	bne	0x7009c22a <Udma_chDisableRxChan+0xda> @ imm = #0x18
7009c210: e7ff         	b	0x7009c212 <Udma_chDisableRxChan+0xc2> @ imm = #-0x2
;             (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009c212: 9810         	ldr	r0, [sp, #0x40]
7009c214: 3054         	adds	r0, #0x54
7009c216: 9915         	ldr	r1, [sp, #0x54]
7009c218: 6f09         	ldr	r1, [r1, #0x70]
7009c21a: aa05         	add	r2, sp, #0x14
7009c21c: f00f f820    	bl	0x700ab260 <CSL_pktdmaGetRxRT> @ imm = #0xf040
;             if(FALSE == pktdmaRtStatus.enable)
7009c220: 9805         	ldr	r0, [sp, #0x14]
7009c222: b908         	cbnz	r0, 0x7009c228 <Udma_chDisableRxChan+0xd8> @ imm = #0x2
7009c224: e7ff         	b	0x7009c226 <Udma_chDisableRxChan+0xd6> @ imm = #-0x2
;                 break;
7009c226: e013         	b	0x7009c250 <Udma_chDisableRxChan+0x100> @ imm = #0x26
;         }
7009c228: e7ff         	b	0x7009c22a <Udma_chDisableRxChan+0xda> @ imm = #-0x2
7009c22a: e7ff         	b	0x7009c22c <Udma_chDisableRxChan+0xdc> @ imm = #-0x2
;         if(currTimeout > timeout)
7009c22c: 9812         	ldr	r0, [sp, #0x48]
7009c22e: 9914         	ldr	r1, [sp, #0x50]
7009c230: 4288         	cmp	r0, r1
7009c232: d904         	bls	0x7009c23e <Udma_chDisableRxChan+0xee> @ imm = #0x8
7009c234: e7ff         	b	0x7009c236 <Udma_chDisableRxChan+0xe6> @ imm = #-0x2
7009c236: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009c23a: 9013         	str	r0, [sp, #0x4c]
;         }
7009c23c: e007         	b	0x7009c24e <Udma_chDisableRxChan+0xfe> @ imm = #0xe
7009c23e: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009c242: f00c ff2d    	bl	0x700a90a0 <ClockP_usleep> @ imm = #0xce5a
;             currTimeout++;
7009c246: 9812         	ldr	r0, [sp, #0x48]
7009c248: 3001         	adds	r0, #0x1
7009c24a: 9012         	str	r0, [sp, #0x48]
7009c24c: e7ff         	b	0x7009c24e <Udma_chDisableRxChan+0xfe> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c24e: e7c3         	b	0x7009c1d8 <Udma_chDisableRxChan+0x88> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009c250: 9813         	ldr	r0, [sp, #0x4c]
7009c252: 2800         	cmp	r0, #0x0
7009c254: f000 8091    	beq.w	0x7009c37a <Udma_chDisableRxChan+0x22a> @ imm = #0x122
7009c258: e7ff         	b	0x7009c25a <Udma_chDisableRxChan+0x10a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c25a: 9810         	ldr	r0, [sp, #0x40]
7009c25c: 6800         	ldr	r0, [r0]
7009c25e: 2801         	cmp	r0, #0x1
7009c260: d10e         	bne	0x7009c280 <Udma_chDisableRxChan+0x130> @ imm = #0x1c
7009c262: e7ff         	b	0x7009c264 <Udma_chDisableRxChan+0x114> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, (bool)true, (bool)false);
7009c264: 9a10         	ldr	r2, [sp, #0x40]
7009c266: f102 0008    	add.w	r0, r2, #0x8
7009c26a: 9915         	ldr	r1, [sp, #0x54]
7009c26c: 6f09         	ldr	r1, [r1, #0x70]
7009c26e: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c272: 4411         	add	r1, r2
7009c274: 2201         	movs	r2, #0x1
7009c276: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownRxChan(
7009c278: f00f f982    	bl	0x700ab580 <CSL_bcdmaTeardownRxChan> @ imm = #0xf304
7009c27c: 9013         	str	r0, [sp, #0x4c]
;         }
7009c27e: e00f         	b	0x7009c2a0 <Udma_chDisableRxChan+0x150> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c280: 9810         	ldr	r0, [sp, #0x40]
7009c282: 6800         	ldr	r0, [r0]
7009c284: 2802         	cmp	r0, #0x2
7009c286: d10a         	bne	0x7009c29e <Udma_chDisableRxChan+0x14e> @ imm = #0x14
7009c288: e7ff         	b	0x7009c28a <Udma_chDisableRxChan+0x13a> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->rxChNum, (bool)true, (bool)false);
7009c28a: 9810         	ldr	r0, [sp, #0x40]
7009c28c: 3054         	adds	r0, #0x54
7009c28e: 9915         	ldr	r1, [sp, #0x54]
7009c290: 6f09         	ldr	r1, [r1, #0x70]
7009c292: 2201         	movs	r2, #0x1
7009c294: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownRxChan(
7009c296: f010 f823    	bl	0x700ac2e0 <CSL_pktdmaTeardownRxChan> @ imm = #0x10046
7009c29a: 9013         	str	r0, [sp, #0x4c]
;         }
7009c29c: e7ff         	b	0x7009c29e <Udma_chDisableRxChan+0x14e> @ imm = #-0x2
7009c29e: e7ff         	b	0x7009c2a0 <Udma_chDisableRxChan+0x150> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009c2a0: 9813         	ldr	r0, [sp, #0x4c]
7009c2a2: b108         	cbz	r0, 0x7009c2a8 <Udma_chDisableRxChan+0x158> @ imm = #0x2
7009c2a4: e7ff         	b	0x7009c2a6 <Udma_chDisableRxChan+0x156> @ imm = #-0x2
;         }
7009c2a6: e7ff         	b	0x7009c2a8 <Udma_chDisableRxChan+0x158> @ imm = #-0x2
7009c2a8: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009c2aa: 9012         	str	r0, [sp, #0x48]
;         while(UDMA_SOK == retVal)
7009c2ac: e7ff         	b	0x7009c2ae <Udma_chDisableRxChan+0x15e> @ imm = #-0x2
7009c2ae: 9813         	ldr	r0, [sp, #0x4c]
7009c2b0: 2800         	cmp	r0, #0x0
7009c2b2: d161         	bne	0x7009c378 <Udma_chDisableRxChan+0x228> @ imm = #0xc2
7009c2b4: e7ff         	b	0x7009c2b6 <Udma_chDisableRxChan+0x166> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c2b6: 9810         	ldr	r0, [sp, #0x40]
7009c2b8: 6800         	ldr	r0, [r0]
7009c2ba: 2801         	cmp	r0, #0x1
7009c2bc: d126         	bne	0x7009c30c <Udma_chDisableRxChan+0x1bc> @ imm = #0x4c
7009c2be: e7ff         	b	0x7009c2c0 <Udma_chDisableRxChan+0x170> @ imm = #-0x2
;                 (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009c2c0: 9a10         	ldr	r2, [sp, #0x40]
7009c2c2: f102 0008    	add.w	r0, r2, #0x8
7009c2c6: 9915         	ldr	r1, [sp, #0x54]
7009c2c8: 6f09         	ldr	r1, [r1, #0x70]
7009c2ca: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c2ce: 4411         	add	r1, r2
7009c2d0: aa0a         	add	r2, sp, #0x28
7009c2d2: f010 faed    	bl	0x700ac8b0 <CSL_bcdmaGetRxRT> @ imm = #0x105da
;                     &drvHandle->bcdmaRegs,
7009c2d6: 9a10         	ldr	r2, [sp, #0x40]
7009c2d8: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->rxChNum + drvHandle->rxChOffset,
7009c2dc: 9915         	ldr	r1, [sp, #0x54]
7009c2de: 6f09         	ldr	r1, [r1, #0x70]
7009c2e0: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c2e4: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009c2e6: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009c2e8: 46ec         	mov	r12, sp
7009c2ea: aa04         	add	r2, sp, #0x10
7009c2ec: f8cc 2000    	str.w	r2, [r12]
7009c2f0: 2201         	movs	r2, #0x1
7009c2f2: f00f fa35    	bl	0x700ab760 <CSL_bcdmaGetChanPeerReg> @ imm = #0xf46a
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009c2f6: 9804         	ldr	r0, [sp, #0x10]
7009c2f8: 0fc0         	lsrs	r0, r0, #0x1f
7009c2fa: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == bcdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009c2fc: 980a         	ldr	r0, [sp, #0x28]
7009c2fe: b920         	cbnz	r0, 0x7009c30a <Udma_chDisableRxChan+0x1ba> @ imm = #0x8
7009c300: e7ff         	b	0x7009c302 <Udma_chDisableRxChan+0x1b2> @ imm = #-0x2
7009c302: 9803         	ldr	r0, [sp, #0xc]
7009c304: b908         	cbnz	r0, 0x7009c30a <Udma_chDisableRxChan+0x1ba> @ imm = #0x2
7009c306: e7ff         	b	0x7009c308 <Udma_chDisableRxChan+0x1b8> @ imm = #-0x2
;                     break;
7009c308: e036         	b	0x7009c378 <Udma_chDisableRxChan+0x228> @ imm = #0x6c
;             }
7009c30a: e023         	b	0x7009c354 <Udma_chDisableRxChan+0x204> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c30c: 9810         	ldr	r0, [sp, #0x40]
7009c30e: 6800         	ldr	r0, [r0]
7009c310: 2802         	cmp	r0, #0x2
7009c312: d11e         	bne	0x7009c352 <Udma_chDisableRxChan+0x202> @ imm = #0x3c
7009c314: e7ff         	b	0x7009c316 <Udma_chDisableRxChan+0x1c6> @ imm = #-0x2
;                 (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009c316: 9810         	ldr	r0, [sp, #0x40]
7009c318: 3054         	adds	r0, #0x54
7009c31a: 9915         	ldr	r1, [sp, #0x54]
7009c31c: 6f09         	ldr	r1, [r1, #0x70]
7009c31e: aa05         	add	r2, sp, #0x14
7009c320: f00e ff9e    	bl	0x700ab260 <CSL_pktdmaGetRxRT> @ imm = #0xef3c
;                     &drvHandle->pktdmaRegs,
7009c324: 9810         	ldr	r0, [sp, #0x40]
7009c326: 3054         	adds	r0, #0x54
;                     chHandle->rxChNum,
7009c328: 9915         	ldr	r1, [sp, #0x54]
7009c32a: 6f09         	ldr	r1, [r1, #0x70]
;                     rtEnableRegOffset, &peerRtEnable);
7009c32c: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009c32e: 46ec         	mov	r12, sp
7009c330: aa04         	add	r2, sp, #0x10
7009c332: f8cc 2000    	str.w	r2, [r12]
7009c336: 2201         	movs	r2, #0x1
7009c338: f010 f96a    	bl	0x700ac610 <CSL_pktdmaGetChanPeerReg> @ imm = #0x102d4
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009c33c: 9804         	ldr	r0, [sp, #0x10]
7009c33e: 0fc0         	lsrs	r0, r0, #0x1f
7009c340: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == pktdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009c342: 9805         	ldr	r0, [sp, #0x14]
7009c344: b920         	cbnz	r0, 0x7009c350 <Udma_chDisableRxChan+0x200> @ imm = #0x8
7009c346: e7ff         	b	0x7009c348 <Udma_chDisableRxChan+0x1f8> @ imm = #-0x2
7009c348: 9803         	ldr	r0, [sp, #0xc]
7009c34a: b908         	cbnz	r0, 0x7009c350 <Udma_chDisableRxChan+0x200> @ imm = #0x2
7009c34c: e7ff         	b	0x7009c34e <Udma_chDisableRxChan+0x1fe> @ imm = #-0x2
;                     break;
7009c34e: e013         	b	0x7009c378 <Udma_chDisableRxChan+0x228> @ imm = #0x26
;             }
7009c350: e7ff         	b	0x7009c352 <Udma_chDisableRxChan+0x202> @ imm = #-0x2
7009c352: e7ff         	b	0x7009c354 <Udma_chDisableRxChan+0x204> @ imm = #-0x2
;             if(currTimeout > timeout)
7009c354: 9812         	ldr	r0, [sp, #0x48]
7009c356: 9914         	ldr	r1, [sp, #0x50]
7009c358: 4288         	cmp	r0, r1
7009c35a: d904         	bls	0x7009c366 <Udma_chDisableRxChan+0x216> @ imm = #0x8
7009c35c: e7ff         	b	0x7009c35e <Udma_chDisableRxChan+0x20e> @ imm = #-0x2
7009c35e: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009c362: 9013         	str	r0, [sp, #0x4c]
;             }
7009c364: e007         	b	0x7009c376 <Udma_chDisableRxChan+0x226> @ imm = #0xe
7009c366: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009c36a: f00c fe99    	bl	0x700a90a0 <ClockP_usleep> @ imm = #0xcd32
;                 currTimeout++;
7009c36e: 9812         	ldr	r0, [sp, #0x48]
7009c370: 3001         	adds	r0, #0x1
7009c372: 9012         	str	r0, [sp, #0x48]
7009c374: e7ff         	b	0x7009c376 <Udma_chDisableRxChan+0x226> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009c376: e79a         	b	0x7009c2ae <Udma_chDisableRxChan+0x15e> @ imm = #-0xcc
;     }
7009c378: e7ff         	b	0x7009c37a <Udma_chDisableRxChan+0x22a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c37a: 9813         	ldr	r0, [sp, #0x4c]
7009c37c: 2800         	cmp	r0, #0x0
7009c37e: d148         	bne	0x7009c412 <Udma_chDisableRxChan+0x2c2> @ imm = #0x90
7009c380: e7ff         	b	0x7009c382 <Udma_chDisableRxChan+0x232> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c382: 9810         	ldr	r0, [sp, #0x40]
7009c384: 6800         	ldr	r0, [r0]
7009c386: 2801         	cmp	r0, #0x1
7009c388: d122         	bne	0x7009c3d0 <Udma_chDisableRxChan+0x280> @ imm = #0x44
7009c38a: e7ff         	b	0x7009c38c <Udma_chDisableRxChan+0x23c> @ imm = #-0x2
7009c38c: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009c38e: 900b         	str	r0, [sp, #0x2c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009c390: 9804         	ldr	r0, [sp, #0x10]
7009c392: f020 4080    	bic	r0, r0, #0x40000000
7009c396: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009c398: 9a10         	ldr	r2, [sp, #0x40]
7009c39a: f102 0008    	add.w	r0, r2, #0x8
7009c39e: 9915         	ldr	r1, [sp, #0x54]
7009c3a0: 6f09         	ldr	r1, [r1, #0x70]
7009c3a2: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c3a6: 4411         	add	r1, r2
7009c3a8: aa0a         	add	r2, sp, #0x28
;             (void) CSL_bcdmaSetRxRT(
7009c3aa: f010 fab1    	bl	0x700ac910 <CSL_bcdmaSetRxRT> @ imm = #0x10562
;                 &drvHandle->bcdmaRegs,
7009c3ae: 9a10         	ldr	r2, [sp, #0x40]
7009c3b0: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->rxChNum + drvHandle->rxChOffset,
7009c3b4: 9915         	ldr	r1, [sp, #0x54]
7009c3b6: 6f09         	ldr	r1, [r1, #0x70]
7009c3b8: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c3bc: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009c3be: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_bcdmaSetChanPeerReg(
7009c3c0: 46ec         	mov	r12, sp
7009c3c2: aa04         	add	r2, sp, #0x10
7009c3c4: f8cc 2000    	str.w	r2, [r12]
7009c3c8: 2201         	movs	r2, #0x1
7009c3ca: f00f fcc9    	bl	0x700abd60 <CSL_bcdmaSetChanPeerReg> @ imm = #0xf992
;         }
7009c3ce: e01f         	b	0x7009c410 <Udma_chDisableRxChan+0x2c0> @ imm = #0x3e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c3d0: 9810         	ldr	r0, [sp, #0x40]
7009c3d2: 6800         	ldr	r0, [r0]
7009c3d4: 2802         	cmp	r0, #0x2
7009c3d6: d11a         	bne	0x7009c40e <Udma_chDisableRxChan+0x2be> @ imm = #0x34
7009c3d8: e7ff         	b	0x7009c3da <Udma_chDisableRxChan+0x28a> @ imm = #-0x2
7009c3da: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009c3dc: 9006         	str	r0, [sp, #0x18]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009c3de: 9804         	ldr	r0, [sp, #0x10]
7009c3e0: f020 4080    	bic	r0, r0, #0x40000000
7009c3e4: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009c3e6: 9810         	ldr	r0, [sp, #0x40]
7009c3e8: 3054         	adds	r0, #0x54
7009c3ea: 9915         	ldr	r1, [sp, #0x54]
7009c3ec: 6f09         	ldr	r1, [r1, #0x70]
7009c3ee: aa05         	add	r2, sp, #0x14
;             (void) CSL_pktdmaSetRxRT(
7009c3f0: f00f fcf6    	bl	0x700abde0 <CSL_pktdmaSetRxRT> @ imm = #0xf9ec
;                 &drvHandle->pktdmaRegs,
7009c3f4: 9810         	ldr	r0, [sp, #0x40]
7009c3f6: 3054         	adds	r0, #0x54
;                 chHandle->rxChNum,
7009c3f8: 9915         	ldr	r1, [sp, #0x54]
7009c3fa: 6f09         	ldr	r1, [r1, #0x70]
;                 rtEnableRegOffset,
7009c3fc: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_pktdmaSetChanPeerReg(
7009c3fe: 46ec         	mov	r12, sp
7009c400: aa04         	add	r2, sp, #0x10
7009c402: f8cc 2000    	str.w	r2, [r12]
7009c406: 2201         	movs	r2, #0x1
7009c408: f010 f91a    	bl	0x700ac640 <CSL_pktdmaSetChanPeerReg> @ imm = #0x10234
;         }
7009c40c: e7ff         	b	0x7009c40e <Udma_chDisableRxChan+0x2be> @ imm = #-0x2
7009c40e: e7ff         	b	0x7009c410 <Udma_chDisableRxChan+0x2c0> @ imm = #-0x2
;     }
7009c410: e7ff         	b	0x7009c412 <Udma_chDisableRxChan+0x2c2> @ imm = #-0x2
;     return (retVal);
7009c412: 9813         	ldr	r0, [sp, #0x4c]
7009c414: b016         	add	sp, #0x58
7009c416: bd80         	pop	{r7, pc}
		...

7009c420 <CSL_bcdmaChanOpCfgChan>:
; {
7009c420: b580         	push	{r7, lr}
7009c422: b08a         	sub	sp, #0x28
7009c424: 9009         	str	r0, [sp, #0x24]
7009c426: 9108         	str	r1, [sp, #0x20]
7009c428: 9207         	str	r2, [sp, #0x1c]
7009c42a: 9306         	str	r3, [sp, #0x18]
7009c42c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
7009c42e: 9005         	str	r0, [sp, #0x14]
;     if( pOpData == NULL )
7009c430: 9806         	ldr	r0, [sp, #0x18]
7009c432: b920         	cbnz	r0, 0x7009c43e <CSL_bcdmaChanOpCfgChan+0x1e> @ imm = #0x8
7009c434: e7ff         	b	0x7009c436 <CSL_bcdmaChanOpCfgChan+0x16> @ imm = #-0x2
7009c436: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
7009c43a: 9005         	str	r0, [sp, #0x14]
;     }
7009c43c: e137         	b	0x7009c6ae <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #0x26e
;         switch( chanType )
7009c43e: 9808         	ldr	r0, [sp, #0x20]
7009c440: 9000         	str	r0, [sp]
7009c442: b148         	cbz	r0, 0x7009c458 <CSL_bcdmaChanOpCfgChan+0x38> @ imm = #0x12
7009c444: e7ff         	b	0x7009c446 <CSL_bcdmaChanOpCfgChan+0x26> @ imm = #-0x2
7009c446: 9800         	ldr	r0, [sp]
7009c448: 2801         	cmp	r0, #0x1
7009c44a: d057         	beq	0x7009c4fc <CSL_bcdmaChanOpCfgChan+0xdc> @ imm = #0xae
7009c44c: e7ff         	b	0x7009c44e <CSL_bcdmaChanOpCfgChan+0x2e> @ imm = #-0x2
7009c44e: 9800         	ldr	r0, [sp]
7009c450: 2802         	cmp	r0, #0x2
7009c452: f000 80c1    	beq.w	0x7009c5d8 <CSL_bcdmaChanOpCfgChan+0x1b8> @ imm = #0x182
7009c456: e125         	b	0x7009c6a4 <CSL_bcdmaChanOpCfgChan+0x284> @ imm = #0x24a
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009c458: 9806         	ldr	r0, [sp, #0x18]
7009c45a: 9003         	str	r0, [sp, #0xc]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009c45c: 9803         	ldr	r0, [sp, #0xc]
7009c45e: 6c40         	ldr	r0, [r0, #0x44]
7009c460: 2802         	cmp	r0, #0x2
7009c462: d80a         	bhi	0x7009c47a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0x14
7009c464: e7ff         	b	0x7009c466 <CSL_bcdmaChanOpCfgChan+0x46> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009c466: 9803         	ldr	r0, [sp, #0xc]
7009c468: 6a00         	ldr	r0, [r0, #0x20]
7009c46a: 2807         	cmp	r0, #0x7
7009c46c: d805         	bhi	0x7009c47a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0xa
7009c46e: e7ff         	b	0x7009c470 <CSL_bcdmaChanOpCfgChan+0x50> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009c470: 9803         	ldr	r0, [sp, #0xc]
7009c472: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009c474: 2804         	cmp	r0, #0x4
7009c476: d304         	blo	0x7009c482 <CSL_bcdmaChanOpCfgChan+0x62> @ imm = #0x8
7009c478: e7ff         	b	0x7009c47a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #-0x2
7009c47a: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009c47e: 9005         	str	r0, [sp, #0x14]
;                     }
7009c480: e03b         	b	0x7009c4fa <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #0x76
;                         regVal = CSL_REG32_RD( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG );
7009c482: 9809         	ldr	r0, [sp, #0x24]
7009c484: 6840         	ldr	r0, [r0, #0x4]
7009c486: 9907         	ldr	r1, [sp, #0x1c]
7009c488: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c48c: f011 fa60    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0x114c0
7009c490: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_PAUSE_ON_ERR, pChanCfg->pauseOnError );
7009c492: 9804         	ldr	r0, [sp, #0x10]
7009c494: f020 4000    	bic	r0, r0, #0x80000000
7009c498: 9903         	ldr	r1, [sp, #0xc]
7009c49a: 6809         	ldr	r1, [r1]
7009c49c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009c4a0: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, pChanCfg->burstSize );
7009c4a2: 9804         	ldr	r0, [sp, #0x10]
7009c4a4: 9903         	ldr	r1, [sp, #0xc]
7009c4a6: 6c49         	ldr	r1, [r1, #0x44]
7009c4a8: f361 208b    	bfi	r0, r1, #10, #2
7009c4ac: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, regVal );
7009c4ae: 9809         	ldr	r0, [sp, #0x24]
7009c4b0: 6840         	ldr	r0, [r0, #0x4]
7009c4b2: 9907         	ldr	r1, [sp, #0x1c]
7009c4b4: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c4b8: 9904         	ldr	r1, [sp, #0x10]
7009c4ba: f011 f9a9    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x11352
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c4be: 9803         	ldr	r0, [sp, #0xc]
7009c4c0: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009c4c2: 6a80         	ldr	r0, [r0, #0x28]
7009c4c4: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c4c8: f361 701e    	bfi	r0, r1, #28, #3
7009c4cc: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].PRI_CTRL, regVal );
7009c4ce: 9809         	ldr	r0, [sp, #0x24]
7009c4d0: 6840         	ldr	r0, [r0, #0x4]
7009c4d2: 9907         	ldr	r1, [sp, #0x1c]
7009c4d4: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c4d8: 3064         	adds	r0, #0x64
7009c4da: 9904         	ldr	r1, [sp, #0x10]
7009c4dc: f011 f998    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x11330
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_BCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009c4e0: 9809         	ldr	r0, [sp, #0x24]
7009c4e2: 6840         	ldr	r0, [r0, #0x4]
7009c4e4: 9907         	ldr	r1, [sp, #0x1c]
7009c4e6: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c4ea: 3080         	adds	r0, #0x80
7009c4ec: 9903         	ldr	r1, [sp, #0xc]
7009c4ee: 6ac9         	ldr	r1, [r1, #0x2c]
7009c4f0: f001 0103    	and	r1, r1, #0x3
7009c4f4: f011 f98c    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x11318
7009c4f8: e7ff         	b	0x7009c4fa <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #-0x2
;                 break;
7009c4fa: e0d7         	b	0x7009c6ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x1ae
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009c4fc: 9806         	ldr	r0, [sp, #0x18]
7009c4fe: 9002         	str	r0, [sp, #0x8]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009c500: 9802         	ldr	r0, [sp, #0x8]
7009c502: 6c40         	ldr	r0, [r0, #0x44]
7009c504: 2801         	cmp	r0, #0x1
7009c506: d80a         	bhi	0x7009c51e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0x14
7009c508: e7ff         	b	0x7009c50a <CSL_bcdmaChanOpCfgChan+0xea> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009c50a: 9802         	ldr	r0, [sp, #0x8]
7009c50c: 6a00         	ldr	r0, [r0, #0x20]
7009c50e: 2807         	cmp	r0, #0x7
7009c510: d805         	bhi	0x7009c51e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0xa
7009c512: e7ff         	b	0x7009c514 <CSL_bcdmaChanOpCfgChan+0xf4> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009c514: 9802         	ldr	r0, [sp, #0x8]
7009c516: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009c518: 2804         	cmp	r0, #0x4
7009c51a: d304         	blo	0x7009c526 <CSL_bcdmaChanOpCfgChan+0x106> @ imm = #0x8
7009c51c: e7ff         	b	0x7009c51e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #-0x2
7009c51e: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009c522: 9005         	str	r0, [sp, #0x14]
;                     }
7009c524: e057         	b	0x7009c5d6 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #0xae
;                         regVal = CSL_REG32_RD( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG );
7009c526: 9809         	ldr	r0, [sp, #0x24]
7009c528: 68c0         	ldr	r0, [r0, #0xc]
7009c52a: 9907         	ldr	r1, [sp, #0x1c]
7009c52c: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c530: f011 fa0e    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0x1141c
7009c534: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009c536: 9804         	ldr	r0, [sp, #0x10]
7009c538: f020 4000    	bic	r0, r0, #0x80000000
7009c53c: 9902         	ldr	r1, [sp, #0x8]
7009c53e: 6809         	ldr	r1, [r1]
7009c540: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009c544: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, pChanCfg->burstSize );
7009c546: 9804         	ldr	r0, [sp, #0x10]
7009c548: 9902         	ldr	r1, [sp, #0x8]
7009c54a: 6c49         	ldr	r1, [r1, #0x44]
7009c54c: f361 208b    	bfi	r0, r1, #10, #2
7009c550: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_TDTYPE, pChanCfg->tdType );
7009c552: 9804         	ldr	r0, [sp, #0x10]
7009c554: 9902         	ldr	r1, [sp, #0x8]
7009c556: 6c09         	ldr	r1, [r1, #0x40]
7009c558: f361 2049    	bfi	r0, r1, #9, #1
7009c55c: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_NOTDPKT, pChanCfg->bNoTeardownCompletePkt );
7009c55e: 9804         	ldr	r0, [sp, #0x10]
7009c560: f420 7080    	bic	r0, r0, #0x100
7009c564: 9902         	ldr	r1, [sp, #0x8]
7009c566: f891 103c    	ldrb.w	r1, [r1, #0x3c]
7009c56a: f001 0101    	and	r1, r1, #0x1
7009c56e: ea40 2001    	orr.w	r0, r0, r1, lsl #8
7009c572: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, regVal );
7009c574: 9809         	ldr	r0, [sp, #0x24]
7009c576: 68c0         	ldr	r0, [r0, #0xc]
7009c578: 9907         	ldr	r1, [sp, #0x1c]
7009c57a: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c57e: 9904         	ldr	r1, [sp, #0x10]
7009c580: f011 f946    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x1128c
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c584: 9802         	ldr	r0, [sp, #0x8]
7009c586: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009c588: 6a80         	ldr	r0, [r0, #0x28]
7009c58a: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c58e: f361 701e    	bfi	r0, r1, #28, #3
7009c592: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TPRI_CTRL, regVal );
7009c594: 9809         	ldr	r0, [sp, #0x24]
7009c596: 68c0         	ldr	r0, [r0, #0xc]
7009c598: 9907         	ldr	r1, [sp, #0x1c]
7009c59a: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c59e: 3064         	adds	r0, #0x64
7009c5a0: 9904         	ldr	r1, [sp, #0x10]
7009c5a2: f011 f935    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x1126a
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_TXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009c5a6: 9809         	ldr	r0, [sp, #0x24]
7009c5a8: 68c0         	ldr	r0, [r0, #0xc]
7009c5aa: 9907         	ldr	r1, [sp, #0x1c]
7009c5ac: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c5b0: 3068         	adds	r0, #0x68
7009c5b2: 9902         	ldr	r1, [sp, #0x8]
7009c5b4: f8b1 1048    	ldrh.w	r1, [r1, #0x48]
7009c5b8: f011 f92a    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x11254
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_TXCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009c5bc: 9809         	ldr	r0, [sp, #0x24]
7009c5be: 68c0         	ldr	r0, [r0, #0xc]
7009c5c0: 9907         	ldr	r1, [sp, #0x1c]
7009c5c2: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c5c6: 3080         	adds	r0, #0x80
7009c5c8: 9902         	ldr	r1, [sp, #0x8]
7009c5ca: 6ac9         	ldr	r1, [r1, #0x2c]
7009c5cc: f001 0103    	and	r1, r1, #0x3
7009c5d0: f011 f91e    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x1123c
7009c5d4: e7ff         	b	0x7009c5d6 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #-0x2
;                 break;
7009c5d6: e069         	b	0x7009c6ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0xd2
;                     CSL_BcdmaRxChanCfg *pChanCfg = (CSL_BcdmaRxChanCfg *)pOpData;
7009c5d8: 9806         	ldr	r0, [sp, #0x18]
7009c5da: 9001         	str	r0, [sp, #0x4]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009c5dc: 9801         	ldr	r0, [sp, #0x4]
7009c5de: 6bc0         	ldr	r0, [r0, #0x3c]
7009c5e0: 2801         	cmp	r0, #0x1
7009c5e2: d80a         	bhi	0x7009c5fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0x14
7009c5e4: e7ff         	b	0x7009c5e6 <CSL_bcdmaChanOpCfgChan+0x1c6> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009c5e6: 9801         	ldr	r0, [sp, #0x4]
7009c5e8: 6980         	ldr	r0, [r0, #0x18]
7009c5ea: 2807         	cmp	r0, #0x7
7009c5ec: d805         	bhi	0x7009c5fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0xa
7009c5ee: e7ff         	b	0x7009c5f0 <CSL_bcdmaChanOpCfgChan+0x1d0> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009c5f0: 9801         	ldr	r0, [sp, #0x4]
7009c5f2: 6b80         	ldr	r0, [r0, #0x38]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009c5f4: 2804         	cmp	r0, #0x4
7009c5f6: d304         	blo	0x7009c602 <CSL_bcdmaChanOpCfgChan+0x1e2> @ imm = #0x8
7009c5f8: e7ff         	b	0x7009c5fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #-0x2
7009c5fa: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009c5fe: 9005         	str	r0, [sp, #0x14]
;                     }
7009c600: e04f         	b	0x7009c6a2 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #0x9e
;                         regVal = CSL_REG32_RD( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG );
7009c602: 9809         	ldr	r0, [sp, #0x24]
7009c604: 6940         	ldr	r0, [r0, #0x14]
7009c606: 9907         	ldr	r1, [sp, #0x1c]
7009c608: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c60c: f011 f9a0    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0x11340
7009c610: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009c612: 9804         	ldr	r0, [sp, #0x10]
7009c614: f020 4000    	bic	r0, r0, #0x80000000
7009c618: 9901         	ldr	r1, [sp, #0x4]
7009c61a: 6809         	ldr	r1, [r1]
7009c61c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009c620: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, pChanCfg->burstSize );
7009c622: 9804         	ldr	r0, [sp, #0x10]
7009c624: 9901         	ldr	r1, [sp, #0x4]
7009c626: 6bc9         	ldr	r1, [r1, #0x3c]
7009c628: f361 208b    	bfi	r0, r1, #10, #2
7009c62c: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_IGNORE_LONG, pChanCfg->bIgnoreLongPkts ? (uint32_t)1U : (uint32_t)0U );
7009c62e: 9804         	ldr	r0, [sp, #0x10]
7009c630: f420 4080    	bic	r0, r0, #0x4000
7009c634: 9901         	ldr	r1, [sp, #0x4]
7009c636: f891 1035    	ldrb.w	r1, [r1, #0x35]
7009c63a: f361 308e    	bfi	r0, r1, #14, #1
7009c63e: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, regVal );
7009c640: 9809         	ldr	r0, [sp, #0x24]
7009c642: 6940         	ldr	r0, [r0, #0x14]
7009c644: 9907         	ldr	r1, [sp, #0x1c]
7009c646: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c64a: 9904         	ldr	r1, [sp, #0x10]
7009c64c: f011 f8e0    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x111c0
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c650: 9801         	ldr	r0, [sp, #0x4]
7009c652: 6981         	ldr	r1, [r0, #0x18]
;                                  CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009c654: 6a00         	ldr	r0, [r0, #0x20]
7009c656: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c65a: f361 701e    	bfi	r0, r1, #28, #3
7009c65e: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RPRI_CTRL, regVal );
7009c660: 9809         	ldr	r0, [sp, #0x24]
7009c662: 6940         	ldr	r0, [r0, #0x14]
7009c664: 9907         	ldr	r1, [sp, #0x1c]
7009c666: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c66a: 3064         	adds	r0, #0x64
7009c66c: 9904         	ldr	r1, [sp, #0x10]
7009c66e: f011 f8cf    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x1119e
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_RXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009c672: 9809         	ldr	r0, [sp, #0x24]
7009c674: 6940         	ldr	r0, [r0, #0x14]
7009c676: 9907         	ldr	r1, [sp, #0x1c]
7009c678: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c67c: 3068         	adds	r0, #0x68
7009c67e: 9901         	ldr	r1, [sp, #0x4]
7009c680: f8b1 1040    	ldrh.w	r1, [r1, #0x40]
7009c684: f011 f8c4    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x11188
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RST_SCHED, CSL_FMK(BCDMA_RXCCFG_CHAN_RST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009c688: 9809         	ldr	r0, [sp, #0x24]
7009c68a: 6940         	ldr	r0, [r0, #0x14]
7009c68c: 9907         	ldr	r1, [sp, #0x1c]
7009c68e: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c692: 3080         	adds	r0, #0x80
7009c694: 9901         	ldr	r1, [sp, #0x4]
7009c696: 6b89         	ldr	r1, [r1, #0x38]
7009c698: f001 0103    	and	r1, r1, #0x3
7009c69c: f011 f8b8    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x11170
7009c6a0: e7ff         	b	0x7009c6a2 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #-0x2
;                 break;
7009c6a2: e003         	b	0x7009c6ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x6
7009c6a4: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
7009c6a8: 9005         	str	r0, [sp, #0x14]
;                 break;
7009c6aa: e7ff         	b	0x7009c6ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #-0x2
7009c6ac: e7ff         	b	0x7009c6ae <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #-0x2
;     return retVal;
7009c6ae: 9805         	ldr	r0, [sp, #0x14]
7009c6b0: b00a         	add	sp, #0x28
7009c6b2: bd80         	pop	{r7, pc}
		...

7009c6c0 <TimerP_setup>:
; {
7009c6c0: b510         	push	{r4, lr}
7009c6c2: b096         	sub	sp, #0x58
7009c6c4: 9015         	str	r0, [sp, #0x54]
7009c6c6: 9114         	str	r1, [sp, #0x50]
;     DebugP_assert( baseAddr!=0U);
7009c6c8: 9815         	ldr	r0, [sp, #0x54]
7009c6ca: 2800         	cmp	r0, #0x0
7009c6cc: bf18         	it	ne
7009c6ce: 2001         	movne	r0, #0x1
7009c6d0: f64f 4130    	movw	r1, #0xfc30
7009c6d4: f2c7 010a    	movt	r1, #0x700a
7009c6d8: 466a         	mov	r2, sp
7009c6da: 6011         	str	r1, [r2]
7009c6dc: f64f 114d    	movw	r1, #0xf94d
7009c6e0: f2c7 010a    	movt	r1, #0x700a
7009c6e4: 9106         	str	r1, [sp, #0x18]
7009c6e6: f64f 423d    	movw	r2, #0xfc3d
7009c6ea: f2c7 020a    	movt	r2, #0x700a
7009c6ee: 9207         	str	r2, [sp, #0x1c]
7009c6f0: 2342         	movs	r3, #0x42
7009c6f2: f00c fa95    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xc52a
7009c6f6: 9906         	ldr	r1, [sp, #0x18]
7009c6f8: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputPreScaler != 0U);
7009c6fa: 9814         	ldr	r0, [sp, #0x50]
7009c6fc: 6800         	ldr	r0, [r0]
7009c6fe: 2800         	cmp	r0, #0x0
7009c700: bf18         	it	ne
7009c702: 2001         	movne	r0, #0x1
7009c704: f64f 136b    	movw	r3, #0xf96b
7009c708: f2c7 030a    	movt	r3, #0x700a
7009c70c: 46ec         	mov	r12, sp
7009c70e: f8cc 3000    	str.w	r3, [r12]
7009c712: 2343         	movs	r3, #0x43
7009c714: f00c fa84    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xc508
7009c718: 9906         	ldr	r1, [sp, #0x18]
7009c71a: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputClkHz != 0U);
7009c71c: 9814         	ldr	r0, [sp, #0x50]
7009c71e: 6840         	ldr	r0, [r0, #0x4]
7009c720: 2800         	cmp	r0, #0x0
7009c722: bf18         	it	ne
7009c724: 2001         	movne	r0, #0x1
7009c726: f64f 2380    	movw	r3, #0xfa80
7009c72a: f2c7 030a    	movt	r3, #0x700a
7009c72e: 46ec         	mov	r12, sp
7009c730: f8cc 3000    	str.w	r3, [r12]
7009c734: 2344         	movs	r3, #0x44
7009c736: f00c fa73    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xc4e6
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009c73a: 9814         	ldr	r0, [sp, #0x50]
7009c73c: 6881         	ldr	r1, [r0, #0x8]
7009c73e: 2001         	movs	r0, #0x1
7009c740: 9008         	str	r0, [sp, #0x20]
7009c742: b939         	cbnz	r1, 0x7009c754 <TimerP_setup+0x94> @ imm = #0xe
7009c744: e7ff         	b	0x7009c746 <TimerP_setup+0x86> @ imm = #-0x2
7009c746: 9814         	ldr	r0, [sp, #0x50]
7009c748: 68c0         	ldr	r0, [r0, #0xc]
7009c74a: 2800         	cmp	r0, #0x0
7009c74c: bf18         	it	ne
7009c74e: 2001         	movne	r0, #0x1
7009c750: 9008         	str	r0, [sp, #0x20]
7009c752: e7ff         	b	0x7009c754 <TimerP_setup+0x94> @ imm = #-0x2
7009c754: 9808         	ldr	r0, [sp, #0x20]
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009c756: f000 0001    	and	r0, r0, #0x1
7009c75a: f24f 6105    	movw	r1, #0xf605
7009c75e: f2c7 010a    	movt	r1, #0x700a
7009c762: 466a         	mov	r2, sp
7009c764: 6011         	str	r1, [r2]
7009c766: f64f 114d    	movw	r1, #0xf94d
7009c76a: f2c7 010a    	movt	r1, #0x700a
7009c76e: 9103         	str	r1, [sp, #0xc]
7009c770: f64f 423d    	movw	r2, #0xfc3d
7009c774: f2c7 020a    	movt	r2, #0x700a
7009c778: 9204         	str	r2, [sp, #0x10]
7009c77a: 2345         	movs	r3, #0x45
7009c77c: f00c fa50    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xc4a0
7009c780: 9903         	ldr	r1, [sp, #0xc]
7009c782: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( params->inputPreScaler <= 256U);
7009c784: 9814         	ldr	r0, [sp, #0x50]
7009c786: 6803         	ldr	r3, [r0]
7009c788: 2000         	movs	r0, #0x0
7009c78a: 9005         	str	r0, [sp, #0x14]
7009c78c: f5b3 7f80    	cmp.w	r3, #0x100
7009c790: bf98         	it	ls
7009c792: 2001         	movls	r0, #0x1
7009c794: f64f 130f    	movw	r3, #0xf90f
7009c798: f2c7 030a    	movt	r3, #0x700a
7009c79c: 46ec         	mov	r12, sp
7009c79e: f8cc 3000    	str.w	r3, [r12]
7009c7a2: 2347         	movs	r3, #0x47
7009c7a4: f00c fa3c    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xc478
7009c7a8: 9903         	ldr	r1, [sp, #0xc]
7009c7aa: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( (params->inputClkHz % params->inputPreScaler) == 0U);
7009c7ac: 9814         	ldr	r0, [sp, #0x50]
7009c7ae: 6803         	ldr	r3, [r0]
7009c7b0: f8d0 c004    	ldr.w	r12, [r0, #0x4]
7009c7b4: fbbc f0f3    	udiv	r0, r12, r3
7009c7b8: fb00 c013    	mls	r0, r0, r3, r12
7009c7bc: fab0 f080    	clz	r0, r0
7009c7c0: 0940         	lsrs	r0, r0, #0x5
7009c7c2: f24f 63af    	movw	r3, #0xf6af
7009c7c6: f2c7 030a    	movt	r3, #0x700a
7009c7ca: 46ec         	mov	r12, sp
7009c7cc: f8cc 3000    	str.w	r3, [r12]
7009c7d0: 2349         	movs	r3, #0x49
7009c7d2: f00c fa25    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xc44a
;     TimerP_stop(baseAddr);
7009c7d6: 9815         	ldr	r0, [sp, #0x54]
7009c7d8: f010 fe42    	bl	0x700ad460 <TimerP_stop> @ imm = #0x10c84
;     TimerP_clearOverflowInt(baseAddr);
7009c7dc: 9815         	ldr	r0, [sp, #0x54]
7009c7de: f010 f90f    	bl	0x700aca00 <TimerP_clearOverflowInt> @ imm = #0x1021e
7009c7e2: 9905         	ldr	r1, [sp, #0x14]
;     timeInNsec = (uint64_t)params->periodInNsec;
7009c7e4: 9814         	ldr	r0, [sp, #0x50]
7009c7e6: 68c0         	ldr	r0, [r0, #0xc]
7009c7e8: 910f         	str	r1, [sp, #0x3c]
7009c7ea: 900e         	str	r0, [sp, #0x38]
;     if(timeInNsec == 0U)
7009c7ec: 980e         	ldr	r0, [sp, #0x38]
7009c7ee: 990f         	ldr	r1, [sp, #0x3c]
7009c7f0: 4308         	orrs	r0, r1
7009c7f2: b948         	cbnz	r0, 0x7009c808 <TimerP_setup+0x148> @ imm = #0x12
7009c7f4: e7ff         	b	0x7009c7f6 <TimerP_setup+0x136> @ imm = #-0x2
;         timeInNsec = (uint64_t)params->periodInUsec*1000U;
7009c7f6: 9814         	ldr	r0, [sp, #0x50]
7009c7f8: 6880         	ldr	r0, [r0, #0x8]
7009c7fa: f44f 717a    	mov.w	r1, #0x3e8
7009c7fe: fba0 0101    	umull	r0, r1, r0, r1
7009c802: 910f         	str	r1, [sp, #0x3c]
7009c804: 900e         	str	r0, [sp, #0x38]
;     }
7009c806: e7ff         	b	0x7009c808 <TimerP_setup+0x148> @ imm = #-0x2
;     inputClkHz = (uint64_t)params->inputClkHz / (uint64_t)params->inputPreScaler;
7009c808: 9814         	ldr	r0, [sp, #0x50]
7009c80a: 6802         	ldr	r2, [r0]
7009c80c: 6840         	ldr	r0, [r0, #0x4]
7009c80e: 2300         	movs	r3, #0x0
7009c810: 9302         	str	r3, [sp, #0x8]
7009c812: 4619         	mov	r1, r3
7009c814: f010 ebd6    	blx	0x700acfc4 <__aeabi_uldivmod> @ imm = #0x107ac
7009c818: 9b02         	ldr	r3, [sp, #0x8]
7009c81a: 910d         	str	r1, [sp, #0x34]
7009c81c: 900c         	str	r0, [sp, #0x30]
;     timerCycles =  ( inputClkHz * timeInNsec ) / 1000000000U;
7009c81e: f8dd c030    	ldr.w	r12, [sp, #0x30]
7009c822: 990d         	ldr	r1, [sp, #0x34]
7009c824: 9a0e         	ldr	r2, [sp, #0x38]
7009c826: f8dd e03c    	ldr.w	lr, [sp, #0x3c]
7009c82a: fbac 0402    	umull	r0, r4, r12, r2
7009c82e: fb0c 4c0e    	mla	r12, r12, lr, r4
7009c832: fb01 c102    	mla	r1, r1, r2, r12
7009c836: f64c 2200    	movw	r2, #0xca00
7009c83a: f6c3 329a    	movt	r2, #0x3b9a
7009c83e: f010 ebc2    	blx	0x700acfc4 <__aeabi_uldivmod> @ imm = #0x10784
7009c842: 4602         	mov	r2, r0
7009c844: 9802         	ldr	r0, [sp, #0x8]
7009c846: 9201         	str	r2, [sp, #0x4]
7009c848: 460a         	mov	r2, r1
7009c84a: 9901         	ldr	r1, [sp, #0x4]
7009c84c: 920b         	str	r2, [sp, #0x2c]
7009c84e: 910a         	str	r1, [sp, #0x28]
;     DebugP_assert( timerCycles < 0xFFFFFFFFU );
7009c850: 9a0a         	ldr	r2, [sp, #0x28]
7009c852: 990b         	ldr	r1, [sp, #0x2c]
7009c854: f1b2 32ff    	subs.w	r2, r2, #0xffffffff
7009c858: f171 0100    	sbcs	r1, r1, #0x0
7009c85c: bf38         	it	lo
7009c85e: 2001         	movlo	r0, #0x1
7009c860: f64f 214c    	movw	r1, #0xfa4c
7009c864: f2c7 010a    	movt	r1, #0x700a
7009c868: 466a         	mov	r2, sp
7009c86a: 6011         	str	r1, [r2]
7009c86c: f64f 114d    	movw	r1, #0xf94d
7009c870: f2c7 010a    	movt	r1, #0x700a
7009c874: f64f 423d    	movw	r2, #0xfc3d
7009c878: f2c7 020a    	movt	r2, #0x700a
7009c87c: 2359         	movs	r3, #0x59
7009c87e: f00c f9cf    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xc39e
7009c882: 9802         	ldr	r0, [sp, #0x8]
;     countVal = 0xFFFFFFFFu - (timerCycles - 1U);
7009c884: 990a         	ldr	r1, [sp, #0x28]
7009c886: 4249         	rsbs	r1, r1, #0
7009c888: 9111         	str	r1, [sp, #0x44]
;     reloadVal = 0;
7009c88a: 9010         	str	r0, [sp, #0x40]
;     ctrlVal = 0;
7009c88c: 9012         	str	r0, [sp, #0x48]
;     if(params->inputPreScaler>1U)
7009c88e: 9814         	ldr	r0, [sp, #0x50]
7009c890: 6800         	ldr	r0, [r0]
7009c892: 2802         	cmp	r0, #0x2
7009c894: d320         	blo	0x7009c8d8 <TimerP_setup+0x218> @ imm = #0x40
7009c896: e7ff         	b	0x7009c898 <TimerP_setup+0x1d8> @ imm = #-0x2
7009c898: 2008         	movs	r0, #0x8
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009c89a: 9009         	str	r0, [sp, #0x24]
7009c89c: e7ff         	b	0x7009c89e <TimerP_setup+0x1de> @ imm = #-0x2
7009c89e: 9809         	ldr	r0, [sp, #0x24]
7009c8a0: b168         	cbz	r0, 0x7009c8be <TimerP_setup+0x1fe> @ imm = #0x1a
7009c8a2: e7ff         	b	0x7009c8a4 <TimerP_setup+0x1e4> @ imm = #-0x2
;             if( (params->inputPreScaler & (0x1U << preScaleVal)) != 0U )
7009c8a4: 9814         	ldr	r0, [sp, #0x50]
7009c8a6: 6800         	ldr	r0, [r0]
7009c8a8: 9909         	ldr	r1, [sp, #0x24]
7009c8aa: 40c8         	lsrs	r0, r1
7009c8ac: 07c0         	lsls	r0, r0, #0x1f
7009c8ae: b108         	cbz	r0, 0x7009c8b4 <TimerP_setup+0x1f4> @ imm = #0x2
7009c8b0: e7ff         	b	0x7009c8b2 <TimerP_setup+0x1f2> @ imm = #-0x2
;                 break;
7009c8b2: e004         	b	0x7009c8be <TimerP_setup+0x1fe> @ imm = #0x8
;         }
7009c8b4: e7ff         	b	0x7009c8b6 <TimerP_setup+0x1f6> @ imm = #-0x2
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009c8b6: 9809         	ldr	r0, [sp, #0x24]
7009c8b8: 3801         	subs	r0, #0x1
7009c8ba: 9009         	str	r0, [sp, #0x24]
7009c8bc: e7ef         	b	0x7009c89e <TimerP_setup+0x1de> @ imm = #-0x22
;         ctrlVal |= (0x1U << 5);
7009c8be: 9812         	ldr	r0, [sp, #0x48]
7009c8c0: f040 0020    	orr	r0, r0, #0x20
7009c8c4: 9012         	str	r0, [sp, #0x48]
;         ctrlVal |= ( ((preScaleVal - 1U) & 0x7U) << 2);
7009c8c6: 9809         	ldr	r0, [sp, #0x24]
7009c8c8: 3801         	subs	r0, #0x1
7009c8ca: f000 0107    	and	r1, r0, #0x7
7009c8ce: 9812         	ldr	r0, [sp, #0x48]
7009c8d0: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009c8d4: 9012         	str	r0, [sp, #0x48]
;     }
7009c8d6: e7ff         	b	0x7009c8d8 <TimerP_setup+0x218> @ imm = #-0x2
;     if(params->oneshotMode==0U)
7009c8d8: 9814         	ldr	r0, [sp, #0x50]
7009c8da: 6900         	ldr	r0, [r0, #0x10]
7009c8dc: b938         	cbnz	r0, 0x7009c8ee <TimerP_setup+0x22e> @ imm = #0xe
7009c8de: e7ff         	b	0x7009c8e0 <TimerP_setup+0x220> @ imm = #-0x2
;         ctrlVal |= (0x1U << 1);
7009c8e0: 9812         	ldr	r0, [sp, #0x48]
7009c8e2: f040 0002    	orr	r0, r0, #0x2
7009c8e6: 9012         	str	r0, [sp, #0x48]
;         reloadVal = countVal;
7009c8e8: 9811         	ldr	r0, [sp, #0x44]
7009c8ea: 9010         	str	r0, [sp, #0x40]
;     }
7009c8ec: e7ff         	b	0x7009c8ee <TimerP_setup+0x22e> @ imm = #-0x2
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
7009c8ee: 9815         	ldr	r0, [sp, #0x54]
7009c8f0: 3038         	adds	r0, #0x38
7009c8f2: 9013         	str	r0, [sp, #0x4c]
;     *addr = ctrlVal;
7009c8f4: 9812         	ldr	r0, [sp, #0x48]
7009c8f6: 9913         	ldr	r1, [sp, #0x4c]
7009c8f8: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
7009c8fa: 9815         	ldr	r0, [sp, #0x54]
7009c8fc: 303c         	adds	r0, #0x3c
7009c8fe: 9013         	str	r0, [sp, #0x4c]
;     *addr = countVal;
7009c900: 9811         	ldr	r0, [sp, #0x44]
7009c902: 9913         	ldr	r1, [sp, #0x4c]
7009c904: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
7009c906: 9815         	ldr	r0, [sp, #0x54]
7009c908: 3040         	adds	r0, #0x40
7009c90a: 9013         	str	r0, [sp, #0x4c]
;     *addr = reloadVal;
7009c90c: 9810         	ldr	r0, [sp, #0x40]
7009c90e: 9913         	ldr	r1, [sp, #0x4c]
7009c910: 6008         	str	r0, [r1]
;     if((params->enableOverflowInt) != 0U)
7009c912: 9814         	ldr	r0, [sp, #0x50]
7009c914: 6940         	ldr	r0, [r0, #0x14]
7009c916: b138         	cbz	r0, 0x7009c928 <TimerP_setup+0x268> @ imm = #0xe
7009c918: e7ff         	b	0x7009c91a <TimerP_setup+0x25a> @ imm = #-0x2
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_ENABLE);
7009c91a: 9815         	ldr	r0, [sp, #0x54]
7009c91c: 302c         	adds	r0, #0x2c
7009c91e: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009c920: 9913         	ldr	r1, [sp, #0x4c]
7009c922: 2002         	movs	r0, #0x2
7009c924: 6008         	str	r0, [r1]
;     }
7009c926: e006         	b	0x7009c936 <TimerP_setup+0x276> @ imm = #0xc
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_DISABLE);
7009c928: 9815         	ldr	r0, [sp, #0x54]
7009c92a: 3030         	adds	r0, #0x30
7009c92c: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009c92e: 9913         	ldr	r1, [sp, #0x4c]
7009c930: 2002         	movs	r0, #0x2
7009c932: 6008         	str	r0, [r1]
7009c934: e7ff         	b	0x7009c936 <TimerP_setup+0x276> @ imm = #-0x2
; }
7009c936: b016         	add	sp, #0x58
7009c938: bd10         	pop	{r4, pc}
7009c93a: 0000         	movs	r0, r0
7009c93c: 0000         	movs	r0, r0
7009c93e: 0000         	movs	r0, r0

7009c940 <Udma_chConfigRx>:
; {
7009c940: b580         	push	{r7, lr}
7009c942: b09c         	sub	sp, #0x70
7009c944: 901b         	str	r0, [sp, #0x6c]
7009c946: 911a         	str	r1, [sp, #0x68]
7009c948: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009c94a: 9019         	str	r0, [sp, #0x64]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
7009c94c: 981b         	ldr	r0, [sp, #0x6c]
7009c94e: 9017         	str	r0, [sp, #0x5c]
;     if((NULL_PTR == chHandleInt) ||
7009c950: 9817         	ldr	r0, [sp, #0x5c]
7009c952: b188         	cbz	r0, 0x7009c978 <Udma_chConfigRx+0x38> @ imm = #0x22
7009c954: e7ff         	b	0x7009c956 <Udma_chConfigRx+0x16> @ imm = #-0x2
;         (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009c956: 9817         	ldr	r0, [sp, #0x5c]
7009c958: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009c95c: f64a 31cd    	movw	r1, #0xabcd
7009c960: f6ca 31dc    	movt	r1, #0xabdc
7009c964: 4288         	cmp	r0, r1
7009c966: d107         	bne	0x7009c978 <Udma_chConfigRx+0x38> @ imm = #0xe
7009c968: e7ff         	b	0x7009c96a <Udma_chConfigRx+0x2a> @ imm = #-0x2
;         ((chHandleInt->chType & UDMA_CH_FLAG_RX) != UDMA_CH_FLAG_RX))
7009c96a: 9817         	ldr	r0, [sp, #0x5c]
7009c96c: 6800         	ldr	r0, [r0]
7009c96e: f000 0002    	and	r0, r0, #0x2
;     if((NULL_PTR == chHandleInt) ||
7009c972: 2802         	cmp	r0, #0x2
7009c974: d004         	beq	0x7009c980 <Udma_chConfigRx+0x40> @ imm = #0x8
7009c976: e7ff         	b	0x7009c978 <Udma_chConfigRx+0x38> @ imm = #-0x2
7009c978: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009c97c: 9019         	str	r0, [sp, #0x64]
;     }
7009c97e: e7ff         	b	0x7009c980 <Udma_chConfigRx+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c980: 9819         	ldr	r0, [sp, #0x64]
7009c982: b9a8         	cbnz	r0, 0x7009c9b0 <Udma_chConfigRx+0x70> @ imm = #0x2a
7009c984: e7ff         	b	0x7009c986 <Udma_chConfigRx+0x46> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009c986: 9817         	ldr	r0, [sp, #0x5c]
7009c988: 6e80         	ldr	r0, [r0, #0x68]
7009c98a: 9018         	str	r0, [sp, #0x60]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009c98c: 9818         	ldr	r0, [sp, #0x60]
7009c98e: b150         	cbz	r0, 0x7009c9a6 <Udma_chConfigRx+0x66> @ imm = #0x14
7009c990: e7ff         	b	0x7009c992 <Udma_chConfigRx+0x52> @ imm = #-0x2
7009c992: 9818         	ldr	r0, [sp, #0x60]
7009c994: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009c998: f64a 31cd    	movw	r1, #0xabcd
7009c99c: f6ca 31dc    	movt	r1, #0xabdc
7009c9a0: 4288         	cmp	r0, r1
7009c9a2: d004         	beq	0x7009c9ae <Udma_chConfigRx+0x6e> @ imm = #0x8
7009c9a4: e7ff         	b	0x7009c9a6 <Udma_chConfigRx+0x66> @ imm = #-0x2
7009c9a6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009c9aa: 9019         	str	r0, [sp, #0x64]
;         }
7009c9ac: e7ff         	b	0x7009c9ae <Udma_chConfigRx+0x6e> @ imm = #-0x2
;     }
7009c9ae: e7ff         	b	0x7009c9b0 <Udma_chConfigRx+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c9b0: 9819         	ldr	r0, [sp, #0x64]
7009c9b2: 2800         	cmp	r0, #0x0
7009c9b4: f040 80f1    	bne.w	0x7009cb9a <Udma_chConfigRx+0x25a> @ imm = #0x1e2
7009c9b8: e7ff         	b	0x7009c9ba <Udma_chConfigRx+0x7a> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009c9ba: 9818         	ldr	r0, [sp, #0x60]
7009c9bc: 6800         	ldr	r0, [r0]
7009c9be: 2801         	cmp	r0, #0x1
7009c9c0: d107         	bne	0x7009c9d2 <Udma_chConfigRx+0x92> @ imm = #0xe
7009c9c2: e7ff         	b	0x7009c9c4 <Udma_chConfigRx+0x84> @ imm = #-0x2
;             ((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
7009c9c4: 9817         	ldr	r0, [sp, #0x5c]
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009c9c6: 7800         	ldrb	r0, [r0]
7009c9c8: 0740         	lsls	r0, r0, #0x1d
7009c9ca: 2800         	cmp	r0, #0x0
7009c9cc: d501         	bpl	0x7009c9d2 <Udma_chConfigRx+0x92> @ imm = #0x2
7009c9ce: e7ff         	b	0x7009c9d0 <Udma_chConfigRx+0x90> @ imm = #-0x2
;         }
7009c9d0: e0e2         	b	0x7009cb98 <Udma_chConfigRx+0x258> @ imm = #0x1c4
7009c9d2: f645 70ff    	movw	r0, #0x5fff
;             rmUdmaRxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
7009c9d6: 9010         	str	r0, [sp, #0x40]
;             rmUdmaRxReq.nav_id              = drvHandle->devIdUdma;
7009c9d8: 9818         	ldr	r0, [sp, #0x60]
7009c9da: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009c9de: f8ad 0044    	strh.w	r0, [sp, #0x44]
;             rmUdmaRxReq.index               = (uint16_t)chHandleInt->rxChNum;
7009c9e2: 9817         	ldr	r0, [sp, #0x5c]
7009c9e4: 6f00         	ldr	r0, [r0, #0x70]
7009c9e6: f8ad 0046    	strh.w	r0, [sp, #0x46]
;             rmUdmaRxReq.rx_pause_on_err     = rxPrms->pauseOnError;
7009c9ea: 981a         	ldr	r0, [sp, #0x68]
7009c9ec: 7800         	ldrb	r0, [r0]
7009c9ee: f88d 0054    	strb.w	r0, [sp, #0x54]
;             rmUdmaRxReq.rx_atype            = rxPrms->addrType;
7009c9f2: 981a         	ldr	r0, [sp, #0x68]
7009c9f4: 7840         	ldrb	r0, [r0, #0x1]
7009c9f6: f88d 0055    	strb.w	r0, [sp, #0x55]
;             rmUdmaRxReq.rx_chan_type        = rxPrms->chanType;
7009c9fa: 981a         	ldr	r0, [sp, #0x68]
7009c9fc: 7880         	ldrb	r0, [r0, #0x2]
7009c9fe: f88d 0056    	strb.w	r0, [sp, #0x56]
;             rmUdmaRxReq.rx_fetch_size       = rxPrms->fetchWordSize;
7009ca02: 981a         	ldr	r0, [sp, #0x68]
7009ca04: 8880         	ldrh	r0, [r0, #0x4]
7009ca06: f8ad 0048    	strh.w	r0, [sp, #0x48]
;             rmUdmaRxReq.rx_priority         = rxPrms->busPriority;
7009ca0a: 981a         	ldr	r0, [sp, #0x68]
7009ca0c: 7980         	ldrb	r0, [r0, #0x6]
7009ca0e: f88d 004c    	strb.w	r0, [sp, #0x4c]
;             rmUdmaRxReq.rx_qos              = rxPrms->busQos;
7009ca12: 981a         	ldr	r0, [sp, #0x68]
7009ca14: 79c0         	ldrb	r0, [r0, #0x7]
7009ca16: f88d 004d    	strb.w	r0, [sp, #0x4d]
;             rmUdmaRxReq.rx_orderid          = rxPrms->busOrderId;
7009ca1a: 981a         	ldr	r0, [sp, #0x68]
7009ca1c: 7a00         	ldrb	r0, [r0, #0x8]
7009ca1e: f88d 004e    	strb.w	r0, [sp, #0x4e]
;             rmUdmaRxReq.rx_sched_priority   = rxPrms->dmaPriority;
7009ca22: 981a         	ldr	r0, [sp, #0x68]
7009ca24: 7a40         	ldrb	r0, [r0, #0x9]
7009ca26: f88d 004f    	strb.w	r0, [sp, #0x4f]
;             rmUdmaRxReq.flowid_start        = rxPrms->flowIdFwRangeStart;
7009ca2a: 981a         	ldr	r0, [sp, #0x68]
7009ca2c: 8940         	ldrh	r0, [r0, #0xa]
7009ca2e: f8ad 0050    	strh.w	r0, [sp, #0x50]
;             rmUdmaRxReq.flowid_cnt          = rxPrms->flowIdFwRangeCnt;
7009ca32: 981a         	ldr	r0, [sp, #0x68]
7009ca34: 8980         	ldrh	r0, [r0, #0xc]
7009ca36: f8ad 0052    	strh.w	r0, [sp, #0x52]
;             rmUdmaRxReq.rx_ignore_short     = rxPrms->ignoreShortPkts;
7009ca3a: 981a         	ldr	r0, [sp, #0x68]
7009ca3c: 7c80         	ldrb	r0, [r0, #0x12]
7009ca3e: f88d 0057    	strb.w	r0, [sp, #0x57]
;             rmUdmaRxReq.rx_ignore_long      = rxPrms->ignoreLongPkts;
7009ca42: 981a         	ldr	r0, [sp, #0x68]
7009ca44: 7cc0         	ldrb	r0, [r0, #0x13]
7009ca46: f88d 0058    	strb.w	r0, [sp, #0x58]
;             rmUdmaRxReq.rx_burst_size       = rxPrms->burstSize;
7009ca4a: 981a         	ldr	r0, [sp, #0x68]
7009ca4c: 7e00         	ldrb	r0, [r0, #0x18]
7009ca4e: f88d 0059    	strb.w	r0, [sp, #0x59]
;             if(NULL_PTR != chHandleInt->tdCqRing)
7009ca52: 9817         	ldr	r0, [sp, #0x5c]
7009ca54: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ca58: b138         	cbz	r0, 0x7009ca6a <Udma_chConfigRx+0x12a> @ imm = #0xe
7009ca5a: e7ff         	b	0x7009ca5c <Udma_chConfigRx+0x11c> @ imm = #-0x2
;                 rmUdmaRxReq.rxcq_qnum          = chHandleInt->tdCqRing->ringNum;
7009ca5c: 9817         	ldr	r0, [sp, #0x5c]
7009ca5e: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ca62: 8880         	ldrh	r0, [r0, #0x4]
7009ca64: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;             }
7009ca68: e004         	b	0x7009ca74 <Udma_chConfigRx+0x134> @ imm = #0x8
7009ca6a: f64f 70ff    	movw	r0, #0xffff
;                 rmUdmaRxReq.rxcq_qnum          = UDMA_RING_INVALID;
7009ca6e: f8ad 004a    	strh.w	r0, [sp, #0x4a]
7009ca72: e7ff         	b	0x7009ca74 <Udma_chConfigRx+0x134> @ imm = #-0x2
7009ca74: a80e         	add	r0, sp, #0x38
7009ca76: a90c         	add	r1, sp, #0x30
7009ca78: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmUdmapRxChCfg(
7009ca7c: f00d ff58    	bl	0x700aa930 <Sciclient_rmUdmapRxChCfg> @ imm = #0xdeb0
7009ca80: 9019         	str	r0, [sp, #0x64]
;             if(CSL_PASS != retVal)
7009ca82: 9819         	ldr	r0, [sp, #0x64]
7009ca84: b108         	cbz	r0, 0x7009ca8a <Udma_chConfigRx+0x14a> @ imm = #0x2
7009ca86: e7ff         	b	0x7009ca88 <Udma_chConfigRx+0x148> @ imm = #-0x2
;             }
7009ca88: e7ff         	b	0x7009ca8a <Udma_chConfigRx+0x14a> @ imm = #-0x2
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009ca8a: 9817         	ldr	r0, [sp, #0x5c]
7009ca8c: 6800         	ldr	r0, [r0]
7009ca8e: f000 0008    	and	r0, r0, #0x8
7009ca92: 2808         	cmp	r0, #0x8
7009ca94: d006         	beq	0x7009caa4 <Udma_chConfigRx+0x164> @ imm = #0xc
7009ca96: e7ff         	b	0x7009ca98 <Udma_chConfigRx+0x158> @ imm = #-0x2
;                     ((chHandleInt->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)) &&
7009ca98: 9817         	ldr	r0, [sp, #0x5c]
7009ca9a: 7800         	ldrb	r0, [r0]
7009ca9c: 06c0         	lsls	r0, r0, #0x1b
7009ca9e: 2800         	cmp	r0, #0x0
7009caa0: d569         	bpl	0x7009cb76 <Udma_chConfigRx+0x236> @ imm = #0xd2
7009caa2: e7ff         	b	0x7009caa4 <Udma_chConfigRx+0x164> @ imm = #-0x2
;                (TRUE == rxPrms->configDefaultFlow))
7009caa4: 981a         	ldr	r0, [sp, #0x68]
7009caa6: 6940         	ldr	r0, [r0, #0x14]
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009caa8: 2801         	cmp	r0, #0x1
7009caaa: d164         	bne	0x7009cb76 <Udma_chConfigRx+0x236> @ imm = #0xc8
7009caac: e7ff         	b	0x7009caae <Udma_chConfigRx+0x16e> @ imm = #-0x2
;                 UdmaFlowPrms_init(&flowPrms, chHandleInt->chType);
7009caae: 9817         	ldr	r0, [sp, #0x5c]
7009cab0: 6801         	ldr	r1, [r0]
7009cab2: a801         	add	r0, sp, #0x4
7009cab4: f00a fe3c    	bl	0x700a7730 <UdmaFlowPrms_init> @ imm = #0xac78
;                 flowPrms.psInfoPresent = rxPrms->flowPsInfoPresent;
7009cab8: 981a         	ldr	r0, [sp, #0x68]
7009caba: 7bc0         	ldrb	r0, [r0, #0xf]
7009cabc: f88d 0009    	strb.w	r0, [sp, #0x9]
;                 flowPrms.einfoPresent  = rxPrms->flowEInfoPresent;
7009cac0: 981a         	ldr	r0, [sp, #0x68]
7009cac2: 7b80         	ldrb	r0, [r0, #0xe]
7009cac4: f88d 0008    	strb.w	r0, [sp, #0x8]
;                 flowPrms.errorHandling = rxPrms->flowErrorHandling;
7009cac8: 981a         	ldr	r0, [sp, #0x68]
7009caca: 7c00         	ldrb	r0, [r0, #0x10]
7009cacc: f88d 000a    	strb.w	r0, [sp, #0xa]
;                 flowPrms.sopOffset     = rxPrms->flowSopOffset;
7009cad0: 981a         	ldr	r0, [sp, #0x68]
7009cad2: 7c40         	ldrb	r0, [r0, #0x11]
7009cad4: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 if(NULL_PTR == chHandleInt->cqRing)
7009cad8: 9817         	ldr	r0, [sp, #0x5c]
7009cada: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009cade: b928         	cbnz	r0, 0x7009caec <Udma_chConfigRx+0x1ac> @ imm = #0xa
7009cae0: e7ff         	b	0x7009cae2 <Udma_chConfigRx+0x1a2> @ imm = #-0x2
7009cae2: f64f 70ff    	movw	r0, #0xffff
;                     cqRing = UDMA_RING_INVALID;
7009cae6: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 }
7009caea: e006         	b	0x7009cafa <Udma_chConfigRx+0x1ba> @ imm = #0xc
;                     cqRing = chHandleInt->cqRing->ringNum;
7009caec: 9817         	ldr	r0, [sp, #0x5c]
7009caee: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009caf2: 8880         	ldrh	r0, [r0, #0x4]
7009caf4: f8ad 0002    	strh.w	r0, [sp, #0x2]
7009caf8: e7ff         	b	0x7009cafa <Udma_chConfigRx+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == chHandleInt->fqRing)
7009cafa: 9817         	ldr	r0, [sp, #0x5c]
7009cafc: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009cb00: b928         	cbnz	r0, 0x7009cb0e <Udma_chConfigRx+0x1ce> @ imm = #0xa
7009cb02: e7ff         	b	0x7009cb04 <Udma_chConfigRx+0x1c4> @ imm = #-0x2
7009cb04: f64f 70ff    	movw	r0, #0xffff
;                     fqRing = UDMA_RING_INVALID;
7009cb08: f8ad 0000    	strh.w	r0, [sp]
;                 }
7009cb0c: e006         	b	0x7009cb1c <Udma_chConfigRx+0x1dc> @ imm = #0xc
;                     fqRing = chHandleInt->fqRing->ringNum;
7009cb0e: 9817         	ldr	r0, [sp, #0x5c]
7009cb10: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009cb14: 8880         	ldrh	r0, [r0, #0x4]
7009cb16: f8ad 0000    	strh.w	r0, [sp]
7009cb1a: e7ff         	b	0x7009cb1c <Udma_chConfigRx+0x1dc> @ imm = #-0x2
;                 flowPrms.defaultRxCQ    = cqRing;
7009cb1c: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
7009cb20: f8ad 0010    	strh.w	r0, [sp, #0x10]
;                 flowPrms.fdq0Sz0Qnum    = fqRing;
7009cb24: f8bd 0000    	ldrh.w	r0, [sp]
7009cb28: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 flowPrms.fdq0Sz1Qnum    = fqRing;
7009cb2c: f8bd 0000    	ldrh.w	r0, [sp]
7009cb30: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 flowPrms.fdq0Sz2Qnum    = fqRing;
7009cb34: f8bd 0000    	ldrh.w	r0, [sp]
7009cb38: f8ad 002c    	strh.w	r0, [sp, #0x2c]
;                 flowPrms.fdq0Sz3Qnum    = fqRing;
7009cb3c: f8bd 0000    	ldrh.w	r0, [sp]
7009cb40: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;                 flowPrms.fdq1Qnum       = fqRing;
7009cb44: f8bd 0000    	ldrh.w	r0, [sp]
7009cb48: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 flowPrms.fdq2Qnum       = fqRing;
7009cb4c: f8bd 0000    	ldrh.w	r0, [sp]
7009cb50: f8ad 0020    	strh.w	r0, [sp, #0x20]
;                 flowPrms.fdq3Qnum       = fqRing;
7009cb54: f8bd 0000    	ldrh.w	r0, [sp]
7009cb58: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                 retVal = Udma_flowConfig(chHandleInt->defaultFlow, 0U, &flowPrms);
7009cb5c: 9817         	ldr	r0, [sp, #0x5c]
7009cb5e: f8d0 01c8    	ldr.w	r0, [r0, #0x1c8]
7009cb62: 2100         	movs	r1, #0x0
7009cb64: aa01         	add	r2, sp, #0x4
7009cb66: f001 f8bb    	bl	0x7009dce0 <Udma_flowConfig> @ imm = #0x1176
7009cb6a: 9019         	str	r0, [sp, #0x64]
;                 if(UDMA_SOK != retVal)
7009cb6c: 9819         	ldr	r0, [sp, #0x64]
7009cb6e: b108         	cbz	r0, 0x7009cb74 <Udma_chConfigRx+0x234> @ imm = #0x2
7009cb70: e7ff         	b	0x7009cb72 <Udma_chConfigRx+0x232> @ imm = #-0x2
;                 }
7009cb72: e7ff         	b	0x7009cb74 <Udma_chConfigRx+0x234> @ imm = #-0x2
;             }
7009cb74: e7ff         	b	0x7009cb76 <Udma_chConfigRx+0x236> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009cb76: 9819         	ldr	r0, [sp, #0x64]
7009cb78: b968         	cbnz	r0, 0x7009cb96 <Udma_chConfigRx+0x256> @ imm = #0x1a
7009cb7a: e7ff         	b	0x7009cb7c <Udma_chConfigRx+0x23c> @ imm = #-0x2
;                 (void) memcpy(&chHandleInt->rxPrms, rxPrms, sizeof(chHandleInt->rxPrms));
7009cb7c: 9817         	ldr	r0, [sp, #0x5c]
7009cb7e: f500 70fc    	add.w	r0, r0, #0x1f8
7009cb82: 991a         	ldr	r1, [sp, #0x68]
7009cb84: e8b1 100c    	ldm.w	r1!, {r2, r3, r12}
7009cb88: e8a0 100c    	stm.w	r0!, {r2, r3, r12}
7009cb8c: e891 500c    	ldm.w	r1, {r2, r3, r12, lr}
7009cb90: e880 500c    	stm.w	r0, {r2, r3, r12, lr}
;             }
7009cb94: e7ff         	b	0x7009cb96 <Udma_chConfigRx+0x256> @ imm = #-0x2
7009cb96: e7ff         	b	0x7009cb98 <Udma_chConfigRx+0x258> @ imm = #-0x2
;     }
7009cb98: e7ff         	b	0x7009cb9a <Udma_chConfigRx+0x25a> @ imm = #-0x2
;     return (retVal);
7009cb9a: 9819         	ldr	r0, [sp, #0x64]
7009cb9c: b01c         	add	sp, #0x70
7009cb9e: bd80         	pop	{r7, pc}

7009cba0 <Sciclient_rmIrqFindRoute>:
; {
7009cba0: b580         	push	{r7, lr}
7009cba2: b08a         	sub	sp, #0x28
7009cba4: 9009         	str	r0, [sp, #0x24]
7009cba6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009cba8: 9008         	str	r0, [sp, #0x20]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cbaa: 9809         	ldr	r0, [sp, #0x24]
7009cbac: 88c0         	ldrh	r0, [r0, #0x6]
7009cbae: f00f fdbf    	bl	0x700ac730 <Sciclient_rmIrIsIr> @ imm = #0xfb7e
7009cbb2: b930         	cbnz	r0, 0x7009cbc2 <Sciclient_rmIrqFindRoute+0x22> @ imm = #0xc
7009cbb4: e7ff         	b	0x7009cbb6 <Sciclient_rmIrqFindRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009cbb6: 9809         	ldr	r0, [sp, #0x24]
7009cbb8: 8940         	ldrh	r0, [r0, #0xa]
7009cbba: f00f fdb9    	bl	0x700ac730 <Sciclient_rmIrIsIr> @ imm = #0xfb72
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cbbe: b120         	cbz	r0, 0x7009cbca <Sciclient_rmIrqFindRoute+0x2a> @ imm = #0x8
7009cbc0: e7ff         	b	0x7009cbc2 <Sciclient_rmIrqFindRoute+0x22> @ imm = #-0x2
7009cbc2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009cbc6: 9008         	str	r0, [sp, #0x20]
;     }
7009cbc8: e7ff         	b	0x7009cbca <Sciclient_rmIrqFindRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cbca: 9808         	ldr	r0, [sp, #0x20]
7009cbcc: bb20         	cbnz	r0, 0x7009cc18 <Sciclient_rmIrqFindRoute+0x78> @ imm = #0x48
7009cbce: e7ff         	b	0x7009cbd0 <Sciclient_rmIrqFindRoute+0x30> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cbd0: 9809         	ldr	r0, [sp, #0x24]
7009cbd2: 8a00         	ldrh	r0, [r0, #0x10]
7009cbd4: 28ff         	cmp	r0, #0xff
7009cbd6: d015         	beq	0x7009cc04 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x2a
7009cbd8: e7ff         	b	0x7009cbda <Sciclient_rmIrqFindRoute+0x3a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cbda: 9809         	ldr	r0, [sp, #0x24]
7009cbdc: 6800         	ldr	r0, [r0]
7009cbde: 2104         	movs	r1, #0x4
7009cbe0: f00f ff86    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0xff0c
;              true) &&
7009cbe4: b170         	cbz	r0, 0x7009cc04 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x1c
7009cbe6: e7ff         	b	0x7009cbe8 <Sciclient_rmIrqFindRoute+0x48> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cbe8: 9809         	ldr	r0, [sp, #0x24]
7009cbea: 6800         	ldr	r0, [r0]
7009cbec: 2108         	movs	r1, #0x8
7009cbee: f00f ff7f    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0xfefe
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cbf2: b138         	cbz	r0, 0x7009cc04 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0xe
7009cbf4: e7ff         	b	0x7009cbf6 <Sciclient_rmIrqFindRoute+0x56> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009cbf6: 9809         	ldr	r0, [sp, #0x24]
7009cbf8: 8a00         	ldrh	r0, [r0, #0x10]
7009cbfa: a905         	add	r1, sp, #0x14
7009cbfc: f007 fa50    	bl	0x700a40a0 <Sciclient_rmIrqGetNode> @ imm = #0x74a0
7009cc00: 9008         	str	r0, [sp, #0x20]
;         } else {
7009cc02: e006         	b	0x7009cc12 <Sciclient_rmIrqFindRoute+0x72> @ imm = #0xc
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009cc04: 9809         	ldr	r0, [sp, #0x24]
7009cc06: 88c0         	ldrh	r0, [r0, #0x6]
7009cc08: a905         	add	r1, sp, #0x14
7009cc0a: f007 fa49    	bl	0x700a40a0 <Sciclient_rmIrqGetNode> @ imm = #0x7492
7009cc0e: 9008         	str	r0, [sp, #0x20]
7009cc10: e7ff         	b	0x7009cc12 <Sciclient_rmIrqFindRoute+0x72> @ imm = #-0x2
;         root_n = cur_n;
7009cc12: 9805         	ldr	r0, [sp, #0x14]
7009cc14: 9004         	str	r0, [sp, #0x10]
;     }
7009cc16: e7ff         	b	0x7009cc18 <Sciclient_rmIrqFindRoute+0x78> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cc18: 9808         	ldr	r0, [sp, #0x20]
7009cc1a: b968         	cbnz	r0, 0x7009cc38 <Sciclient_rmIrqFindRoute+0x98> @ imm = #0x1a
7009cc1c: e7ff         	b	0x7009cc1e <Sciclient_rmIrqFindRoute+0x7e> @ imm = #-0x2
7009cc1e: 2001         	movs	r0, #0x1
;         search = true;
7009cc20: 9002         	str	r0, [sp, #0x8]
7009cc22: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         Sciclient_rmPsInit();
7009cc26: f010 fadb    	bl	0x700ad1e0 <Sciclient_rmPsInit> @ imm = #0x105b6
7009cc2a: 9802         	ldr	r0, [sp, #0x8]
;         search_depth = 1u;
7009cc2c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009cc30: 2000         	movs	r0, #0x0
;         if_idx = 0u;
7009cc32: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     } else {
7009cc36: e003         	b	0x7009cc40 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #0x6
7009cc38: 2000         	movs	r0, #0x0
;         search = false;
7009cc3a: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009cc3e: e7ff         	b	0x7009cc40 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #-0x2
;     while (search == true) {
7009cc40: e7ff         	b	0x7009cc42 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x2
7009cc42: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009cc46: 07c0         	lsls	r0, r0, #0x1f
7009cc48: 2800         	cmp	r0, #0x0
7009cc4a: f000 80ca    	beq.w	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x194
7009cc4e: e7ff         	b	0x7009cc50 <Sciclient_rmIrqFindRoute+0xb0> @ imm = #-0x2
7009cc50: 2000         	movs	r0, #0x0
;         node_clear = false;
7009cc52: f88d 0019    	strb.w	r0, [sp, #0x19]
;         if (if_idx < cur_n->n_if) {
7009cc56: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009cc5a: 9905         	ldr	r1, [sp, #0x14]
7009cc5c: 8849         	ldrh	r1, [r1, #0x2]
7009cc5e: 4288         	cmp	r0, r1
7009cc60: f280 8087    	bge.w	0x7009cd72 <Sciclient_rmIrqFindRoute+0x1d2> @ imm = #0x10e
7009cc64: e7ff         	b	0x7009cc66 <Sciclient_rmIrqFindRoute+0xc6> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009cc66: 9805         	ldr	r0, [sp, #0x14]
7009cc68: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009cc6c: aa03         	add	r2, sp, #0xc
7009cc6e: f00e fe17    	bl	0x700ab8a0 <Sciclient_rmIrqGetNodeItf> @ imm = #0xec2e
7009cc72: 9008         	str	r0, [sp, #0x20]
;             if (r != SystemP_SUCCESS) {
7009cc74: 9808         	ldr	r0, [sp, #0x20]
7009cc76: b108         	cbz	r0, 0x7009cc7c <Sciclient_rmIrqFindRoute+0xdc> @ imm = #0x2
7009cc78: e7ff         	b	0x7009cc7a <Sciclient_rmIrqFindRoute+0xda> @ imm = #-0x2
;                 break;
7009cc7a: e0b2         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x164
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009cc7c: 9805         	ldr	r0, [sp, #0x14]
7009cc7e: 8800         	ldrh	r0, [r0]
7009cc80: f00f fd3e    	bl	0x700ac700 <Sciclient_rmIaIsIa> @ imm = #0xfa7c
7009cc84: b9d0         	cbnz	r0, 0x7009ccbc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x34
7009cc86: e7ff         	b	0x7009cc88 <Sciclient_rmIrqFindRoute+0xe8> @ imm = #-0x2
;                 (Sciclient_rmPsIsEmpty() == true) &&
7009cc88: f00f ff4a    	bl	0x700acb20 <Sciclient_rmPsIsEmpty> @ imm = #0xfe94
7009cc8c: b1b0         	cbz	r0, 0x7009ccbc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x2c
7009cc8e: e7ff         	b	0x7009cc90 <Sciclient_rmIrqFindRoute+0xf0> @ imm = #-0x2
;                 ((cfg->s_idx < cur_if->lbase) ||
7009cc90: 9809         	ldr	r0, [sp, #0x24]
7009cc92: 8900         	ldrh	r0, [r0, #0x8]
7009cc94: 9903         	ldr	r1, [sp, #0xc]
7009cc96: 8809         	ldrh	r1, [r1]
7009cc98: 4288         	cmp	r0, r1
7009cc9a: db09         	blt	0x7009ccb0 <Sciclient_rmIrqFindRoute+0x110> @ imm = #0x12
7009cc9c: e7ff         	b	0x7009cc9e <Sciclient_rmIrqFindRoute+0xfe> @ imm = #-0x2
;                  (cfg->s_idx >= (cur_if->lbase + cur_if->len)))) {
7009cc9e: 9809         	ldr	r0, [sp, #0x24]
7009cca0: 8900         	ldrh	r0, [r0, #0x8]
7009cca2: 9a03         	ldr	r2, [sp, #0xc]
7009cca4: 8811         	ldrh	r1, [r2]
7009cca6: 8892         	ldrh	r2, [r2, #0x4]
7009cca8: 4411         	add	r1, r2
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009ccaa: 4288         	cmp	r0, r1
7009ccac: db06         	blt	0x7009ccbc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0xc
7009ccae: e7ff         	b	0x7009ccb0 <Sciclient_rmIrqFindRoute+0x110> @ imm = #-0x2
;                 if_idx++;
7009ccb0: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009ccb4: 3001         	adds	r0, #0x1
7009ccb6: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             } else if (Sciclient_rmPsGetPsp() < search_depth) {
7009ccba: e059         	b	0x7009cd70 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #0xb2
7009ccbc: f010 fe88    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0x10d10
7009ccc0: f8bd 101c    	ldrh.w	r1, [sp, #0x1c]
7009ccc4: 4288         	cmp	r0, r1
7009ccc6: da1e         	bge	0x7009cd06 <Sciclient_rmIrqFindRoute+0x166> @ imm = #0x3c
7009ccc8: e7ff         	b	0x7009ccca <Sciclient_rmIrqFindRoute+0x12a> @ imm = #-0x2
;                 r = Sciclient_rmPsPush(cur_n, if_idx);
7009ccca: 9805         	ldr	r0, [sp, #0x14]
7009cccc: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009ccd0: f00d fbee    	bl	0x700aa4b0 <Sciclient_rmPsPush> @ imm = #0xd7dc
7009ccd4: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009ccd6: 9808         	ldr	r0, [sp, #0x20]
7009ccd8: b108         	cbz	r0, 0x7009ccde <Sciclient_rmIrqFindRoute+0x13e> @ imm = #0x2
7009ccda: e7ff         	b	0x7009ccdc <Sciclient_rmIrqFindRoute+0x13c> @ imm = #-0x2
;                     break;
7009ccdc: e081         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x102
;                 r = Sciclient_rmIrqGetNode(cur_if->rid, &cur_n);
7009ccde: 9803         	ldr	r0, [sp, #0xc]
7009cce0: 88c0         	ldrh	r0, [r0, #0x6]
7009cce2: a905         	add	r1, sp, #0x14
7009cce4: f007 f9dc    	bl	0x700a40a0 <Sciclient_rmIrqGetNode> @ imm = #0x73b8
7009cce8: 9008         	str	r0, [sp, #0x20]
;                 if (cur_n == NULL) {
7009ccea: 9805         	ldr	r0, [sp, #0x14]
7009ccec: b930         	cbnz	r0, 0x7009ccfc <Sciclient_rmIrqFindRoute+0x15c> @ imm = #0xc
7009ccee: e7ff         	b	0x7009ccf0 <Sciclient_rmIrqFindRoute+0x150> @ imm = #-0x2
7009ccf0: 2001         	movs	r0, #0x1
;                     node_clear = true;
7009ccf2: f88d 0019    	strb.w	r0, [sp, #0x19]
7009ccf6: 2000         	movs	r0, #0x0
;                     r = SystemP_SUCCESS;
7009ccf8: 9008         	str	r0, [sp, #0x20]
;                 } else {
7009ccfa: e003         	b	0x7009cd04 <Sciclient_rmIrqFindRoute+0x164> @ imm = #0x6
7009ccfc: 2000         	movs	r0, #0x0
;                     if_idx = 0u;
7009ccfe: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009cd02: e7ff         	b	0x7009cd04 <Sciclient_rmIrqFindRoute+0x164> @ imm = #-0x2
;             } else {
7009cd04: e033         	b	0x7009cd6e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #0x66
;                 if ((cur_if->rid == cfg->d_id) &&
7009cd06: 9803         	ldr	r0, [sp, #0xc]
7009cd08: 88c0         	ldrh	r0, [r0, #0x6]
7009cd0a: 9909         	ldr	r1, [sp, #0x24]
7009cd0c: 8949         	ldrh	r1, [r1, #0xa]
7009cd0e: 4288         	cmp	r0, r1
7009cd10: d127         	bne	0x7009cd62 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x4e
7009cd12: e7ff         	b	0x7009cd14 <Sciclient_rmIrqFindRoute+0x174> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
7009cd14: 9809         	ldr	r0, [sp, #0x24]
7009cd16: 8980         	ldrh	r0, [r0, #0xc]
7009cd18: 9903         	ldr	r1, [sp, #0xc]
7009cd1a: 8849         	ldrh	r1, [r1, #0x2]
7009cd1c: 4288         	cmp	r0, r1
7009cd1e: db20         	blt	0x7009cd62 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x40
7009cd20: e7ff         	b	0x7009cd22 <Sciclient_rmIrqFindRoute+0x182> @ imm = #-0x2
;                     (cfg->d_irq <
7009cd22: 9809         	ldr	r0, [sp, #0x24]
7009cd24: 8980         	ldrh	r0, [r0, #0xc]
;                      (cur_if->rbase + cur_if->len))) {
7009cd26: 9a03         	ldr	r2, [sp, #0xc]
7009cd28: 8851         	ldrh	r1, [r2, #0x2]
7009cd2a: 8892         	ldrh	r2, [r2, #0x4]
7009cd2c: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
7009cd2e: 4288         	cmp	r0, r1
7009cd30: da17         	bge	0x7009cd62 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x2e
7009cd32: e7ff         	b	0x7009cd34 <Sciclient_rmIrqFindRoute+0x194> @ imm = #-0x2
;                     r = Sciclient_rmPsPush(cur_n, if_idx);
7009cd34: 9805         	ldr	r0, [sp, #0x14]
7009cd36: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009cd3a: f00d fbb9    	bl	0x700aa4b0 <Sciclient_rmPsPush> @ imm = #0xd772
7009cd3e: 9008         	str	r0, [sp, #0x20]
;                     if (r != SystemP_SUCCESS) {
7009cd40: 9808         	ldr	r0, [sp, #0x20]
7009cd42: b108         	cbz	r0, 0x7009cd48 <Sciclient_rmIrqFindRoute+0x1a8> @ imm = #0x2
7009cd44: e7ff         	b	0x7009cd46 <Sciclient_rmIrqFindRoute+0x1a6> @ imm = #-0x2
;                         break;
7009cd46: e04c         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x98
;                     if (Sciclient_rmIrqRouteValidate(cfg) == true) {
7009cd48: 9809         	ldr	r0, [sp, #0x24]
7009cd4a: f7fc fe79    	bl	0x70099a40 <Sciclient_rmIrqRouteValidate> @ imm = #-0x330e
7009cd4e: b108         	cbz	r0, 0x7009cd54 <Sciclient_rmIrqFindRoute+0x1b4> @ imm = #0x2
7009cd50: e7ff         	b	0x7009cd52 <Sciclient_rmIrqFindRoute+0x1b2> @ imm = #-0x2
;                         break;
7009cd52: e046         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x8c
7009cd54: a805         	add	r0, sp, #0x14
7009cd56: f10d 011a    	add.w	r1, sp, #0x1a
;                         Sciclient_rmPsPop(&cur_n, &if_idx);
7009cd5a: f00a ff19    	bl	0x700a7b90 <Sciclient_rmPsPop> @ imm = #0xae32
7009cd5e: e7ff         	b	0x7009cd60 <Sciclient_rmIrqFindRoute+0x1c0> @ imm = #-0x2
;                 }
7009cd60: e7ff         	b	0x7009cd62 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #-0x2
;                 if_idx++;
7009cd62: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009cd66: 3001         	adds	r0, #0x1
7009cd68: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009cd6c: e7ff         	b	0x7009cd6e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #-0x2
7009cd6e: e7ff         	b	0x7009cd70 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #-0x2
;         } else {
7009cd70: e003         	b	0x7009cd7a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #0x6
7009cd72: 2001         	movs	r0, #0x1
;             node_clear = true;
7009cd74: f88d 0019    	strb.w	r0, [sp, #0x19]
7009cd78: e7ff         	b	0x7009cd7a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #-0x2
;         if (node_clear == true) {
7009cd7a: f89d 0019    	ldrb.w	r0, [sp, #0x19]
7009cd7e: 07c0         	lsls	r0, r0, #0x1f
7009cd80: b370         	cbz	r0, 0x7009cde0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #0x5c
7009cd82: e7ff         	b	0x7009cd84 <Sciclient_rmIrqFindRoute+0x1e4> @ imm = #-0x2
;             if (Sciclient_rmPsIsEmpty() == true) {
7009cd84: f00f fecc    	bl	0x700acb20 <Sciclient_rmPsIsEmpty> @ imm = #0xfd98
7009cd88: b1c8         	cbz	r0, 0x7009cdbe <Sciclient_rmIrqFindRoute+0x21e> @ imm = #0x32
7009cd8a: e7ff         	b	0x7009cd8c <Sciclient_rmIrqFindRoute+0x1ec> @ imm = #-0x2
;                 search_depth++;
7009cd8c: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009cd90: 3001         	adds	r0, #0x1
7009cd92: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 cur_n = root_n;
7009cd96: 9804         	ldr	r0, [sp, #0x10]
7009cd98: 9005         	str	r0, [sp, #0x14]
7009cd9a: 2000         	movs	r0, #0x0
;                 if_idx = 0u;
7009cd9c: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;                 if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009cda0: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009cda4: 9001         	str	r0, [sp, #0x4]
7009cda6: f010 fe73    	bl	0x700ada90 <Sciclient_rmPsGetMaxPsp> @ imm = #0x10ce6
7009cdaa: 4601         	mov	r1, r0
7009cdac: 9801         	ldr	r0, [sp, #0x4]
7009cdae: 4288         	cmp	r0, r1
7009cdb0: db04         	blt	0x7009cdbc <Sciclient_rmIrqFindRoute+0x21c> @ imm = #0x8
7009cdb2: e7ff         	b	0x7009cdb4 <Sciclient_rmIrqFindRoute+0x214> @ imm = #-0x2
7009cdb4: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
7009cdb8: 9008         	str	r0, [sp, #0x20]
;                     break;
7009cdba: e012         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x24
;             } else {
7009cdbc: e00f         	b	0x7009cdde <Sciclient_rmIrqFindRoute+0x23e> @ imm = #0x1e
7009cdbe: a805         	add	r0, sp, #0x14
7009cdc0: f10d 011a    	add.w	r1, sp, #0x1a
;                 r = Sciclient_rmPsPop(&cur_n, &if_idx);
7009cdc4: f00a fee4    	bl	0x700a7b90 <Sciclient_rmPsPop> @ imm = #0xadc8
7009cdc8: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009cdca: 9808         	ldr	r0, [sp, #0x20]
7009cdcc: b108         	cbz	r0, 0x7009cdd2 <Sciclient_rmIrqFindRoute+0x232> @ imm = #0x2
7009cdce: e7ff         	b	0x7009cdd0 <Sciclient_rmIrqFindRoute+0x230> @ imm = #-0x2
;                     break;
7009cdd0: e007         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0xe
;                 if_idx++;
7009cdd2: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009cdd6: 3001         	adds	r0, #0x1
7009cdd8: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009cddc: e7ff         	b	0x7009cdde <Sciclient_rmIrqFindRoute+0x23e> @ imm = #-0x2
;         }
7009cdde: e7ff         	b	0x7009cde0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #-0x2
;     while (search == true) {
7009cde0: e72f         	b	0x7009cc42 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x1a2
;     return r;
7009cde2: 9808         	ldr	r0, [sp, #0x20]
7009cde4: b00a         	add	sp, #0x28
7009cde6: bd80         	pop	{r7, pc}
		...

7009cdf0 <UART_fifoConfig>:
; {
7009cdf0: b580         	push	{r7, lr}
7009cdf2: b092         	sub	sp, #0x48
7009cdf4: 9011         	str	r0, [sp, #0x44]
7009cdf6: 9110         	str	r1, [sp, #0x40]
7009cdf8: 2000         	movs	r0, #0x0
;     uint32_t fcrValue = 0U;
7009cdfa: 900c         	str	r0, [sp, #0x30]
;     uint32_t txGra = (fifoConfig & UART_FIFO_CONFIG_TXGRA) >> 26;
7009cdfc: 9810         	ldr	r0, [sp, #0x40]
7009cdfe: f3c0 6083    	ubfx	r0, r0, #0x1a, #0x4
7009ce02: 900b         	str	r0, [sp, #0x2c]
;     uint32_t rxGra = (fifoConfig & UART_FIFO_CONFIG_RXGRA) >> 22;
7009ce04: 9810         	ldr	r0, [sp, #0x40]
7009ce06: f3c0 5083    	ubfx	r0, r0, #0x16, #0x4
7009ce0a: 900a         	str	r0, [sp, #0x28]
;     uint32_t txTrig = (fifoConfig & UART_FIFO_CONFIG_TXTRIG) >> 14;
7009ce0c: 9810         	ldr	r0, [sp, #0x40]
7009ce0e: f3c0 3087    	ubfx	r0, r0, #0xe, #0x8
7009ce12: 9009         	str	r0, [sp, #0x24]
;     uint32_t rxTrig = (fifoConfig & UART_FIFO_CONFIG_RXTRIG) >> 6;
7009ce14: 9810         	ldr	r0, [sp, #0x40]
7009ce16: f3c0 1087    	ubfx	r0, r0, #0x6, #0x8
7009ce1a: 9008         	str	r0, [sp, #0x20]
;     uint32_t txClr = (fifoConfig & UART_FIFO_CONFIG_TXCLR) >> 5;
7009ce1c: 9810         	ldr	r0, [sp, #0x40]
7009ce1e: f3c0 1040    	ubfx	r0, r0, #0x5, #0x1
7009ce22: 9007         	str	r0, [sp, #0x1c]
;     uint32_t rxClr = (fifoConfig & UART_FIFO_CONFIG_RXCLR) >> 4;
7009ce24: 9810         	ldr	r0, [sp, #0x40]
7009ce26: f3c0 1000    	ubfx	r0, r0, #0x4, #0x1
7009ce2a: 9006         	str	r0, [sp, #0x18]
;     uint32_t dmaEnPath = (fifoConfig & UART_FIFO_CONFIG_DMAENPATH) >> 3;
7009ce2c: 9810         	ldr	r0, [sp, #0x40]
7009ce2e: f3c0 00c0    	ubfx	r0, r0, #0x3, #0x1
7009ce32: 9005         	str	r0, [sp, #0x14]
;     uint32_t dmaMode   = (fifoConfig & UART_FIFO_CONFIG_DMAMODE);
7009ce34: 9810         	ldr	r0, [sp, #0x40]
7009ce36: f000 0007    	and	r0, r0, #0x7
7009ce3a: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
7009ce3c: 9811         	ldr	r0, [sp, #0x44]
7009ce3e: f00f f86f    	bl	0x700abf20 <UART_enhanFuncEnable> @ imm = #0xf0de
7009ce42: 900f         	str	r0, [sp, #0x3c]
;     tcrTlrBitVal = UART_subConfigTCRTLRModeEn(baseAddr);
7009ce44: 9811         	ldr	r0, [sp, #0x44]
7009ce46: f00a fb83    	bl	0x700a7550 <UART_subConfigTCRTLRModeEn> @ imm = #0xa706
7009ce4a: 900e         	str	r0, [sp, #0x38]
;     fcrValue |= UART_FCR_FIFO_EN_MASK;
7009ce4c: 980c         	ldr	r0, [sp, #0x30]
7009ce4e: f040 0001    	orr	r0, r0, #0x1
7009ce52: 900c         	str	r0, [sp, #0x30]
;     if(UART_TRIG_LVL_GRANULARITY_1 != rxGra)
7009ce54: 980a         	ldr	r0, [sp, #0x28]
7009ce56: 2801         	cmp	r0, #0x1
7009ce58: d033         	beq	0x7009cec2 <UART_fifoConfig+0xd2> @ imm = #0x66
7009ce5a: e7ff         	b	0x7009ce5c <UART_fifoConfig+0x6c> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009ce5c: 9811         	ldr	r0, [sp, #0x44]
7009ce5e: 3040         	adds	r0, #0x40
7009ce60: 2180         	movs	r1, #0x80
7009ce62: 2207         	movs	r2, #0x7
7009ce64: 2300         	movs	r3, #0x0
7009ce66: 9303         	str	r3, [sp, #0xc]
7009ce68: f00f fb32    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf664
7009ce6c: 9b03         	ldr	r3, [sp, #0xc]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009ce6e: 9811         	ldr	r0, [sp, #0x44]
7009ce70: 301c         	adds	r0, #0x1c
7009ce72: 21f0         	movs	r1, #0xf0
7009ce74: 2204         	movs	r2, #0x4
7009ce76: f00f fb2b    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf656
;         fcrValue &= ~((uint32_t) UART_FCR_RX_FIFO_TRIG_MASK);
7009ce7a: 980c         	ldr	r0, [sp, #0x30]
7009ce7c: f020 00c0    	bic	r0, r0, #0xc0
7009ce80: 900c         	str	r0, [sp, #0x30]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009ce82: 9808         	ldr	r0, [sp, #0x20]
7009ce84: 2808         	cmp	r0, #0x8
7009ce86: d00c         	beq	0x7009cea2 <UART_fifoConfig+0xb2> @ imm = #0x18
7009ce88: e7ff         	b	0x7009ce8a <UART_fifoConfig+0x9a> @ imm = #-0x2
;            (UART_RXTRIGLVL_16 == rxTrig) ||
7009ce8a: 9808         	ldr	r0, [sp, #0x20]
7009ce8c: 2810         	cmp	r0, #0x10
7009ce8e: d008         	beq	0x7009cea2 <UART_fifoConfig+0xb2> @ imm = #0x10
7009ce90: e7ff         	b	0x7009ce92 <UART_fifoConfig+0xa2> @ imm = #-0x2
;            (UART_RXTRIGLVL_56 == rxTrig) ||
7009ce92: 9808         	ldr	r0, [sp, #0x20]
7009ce94: 2838         	cmp	r0, #0x38
7009ce96: d004         	beq	0x7009cea2 <UART_fifoConfig+0xb2> @ imm = #0x8
7009ce98: e7ff         	b	0x7009ce9a <UART_fifoConfig+0xaa> @ imm = #-0x2
;            (UART_RXTRIGLVL_60 == rxTrig))
7009ce9a: 9808         	ldr	r0, [sp, #0x20]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009ce9c: 283c         	cmp	r0, #0x3c
7009ce9e: d107         	bne	0x7009ceb0 <UART_fifoConfig+0xc0> @ imm = #0xe
7009cea0: e7ff         	b	0x7009cea2 <UART_fifoConfig+0xb2> @ imm = #-0x2
;             fcrValue |= rxTrig & UART_FCR_RX_FIFO_TRIG_MASK;
7009cea2: 9808         	ldr	r0, [sp, #0x20]
7009cea4: f000 01c0    	and	r1, r0, #0xc0
7009cea8: 980c         	ldr	r0, [sp, #0x30]
7009ceaa: 4308         	orrs	r0, r1
7009ceac: 900c         	str	r0, [sp, #0x30]
;         }
7009ceae: e007         	b	0x7009cec0 <UART_fifoConfig+0xd0> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009ceb0: 9811         	ldr	r0, [sp, #0x44]
7009ceb2: 301c         	adds	r0, #0x1c
7009ceb4: 9b08         	ldr	r3, [sp, #0x20]
7009ceb6: 21f0         	movs	r1, #0xf0
7009ceb8: 2204         	movs	r2, #0x4
7009ceba: f00f fb09    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf612
7009cebe: e7ff         	b	0x7009cec0 <UART_fifoConfig+0xd0> @ imm = #-0x2
;     }
7009cec0: e01d         	b	0x7009cefe <UART_fifoConfig+0x10e> @ imm = #0x3a
;         rxTrig &= 0x003FU;
7009cec2: 9808         	ldr	r0, [sp, #0x20]
7009cec4: f000 003f    	and	r0, r0, #0x3f
7009cec8: 9008         	str	r0, [sp, #0x20]
;         tlrValue = (rxTrig & 0x003CU) >> 2;
7009ceca: 9808         	ldr	r0, [sp, #0x20]
7009cecc: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009ced0: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (rxTrig & 0x0003U) << UART_FCR_RX_FIFO_TRIG_SHIFT;
7009ced2: 9808         	ldr	r0, [sp, #0x20]
7009ced4: f000 0103    	and	r1, r0, #0x3
7009ced8: 980c         	ldr	r0, [sp, #0x30]
7009ceda: ea40 1081    	orr.w	r0, r0, r1, lsl #6
7009cede: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009cee0: 9811         	ldr	r0, [sp, #0x44]
7009cee2: 3040         	adds	r0, #0x40
7009cee4: 2180         	movs	r1, #0x80
7009cee6: 2207         	movs	r2, #0x7
7009cee8: 2301         	movs	r3, #0x1
7009ceea: f00f faf1    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf5e2
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA, tlrValue);
7009ceee: 9811         	ldr	r0, [sp, #0x44]
7009cef0: 301c         	adds	r0, #0x1c
7009cef2: 9b0d         	ldr	r3, [sp, #0x34]
7009cef4: 21f0         	movs	r1, #0xf0
7009cef6: 2204         	movs	r2, #0x4
7009cef8: f00f faea    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf5d4
7009cefc: e7ff         	b	0x7009cefe <UART_fifoConfig+0x10e> @ imm = #-0x2
;     if(UART_TRIG_LVL_GRANULARITY_1 != txGra)
7009cefe: 980b         	ldr	r0, [sp, #0x2c]
7009cf00: 2801         	cmp	r0, #0x1
7009cf02: d033         	beq	0x7009cf6c <UART_fifoConfig+0x17c> @ imm = #0x66
7009cf04: e7ff         	b	0x7009cf06 <UART_fifoConfig+0x116> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009cf06: 9811         	ldr	r0, [sp, #0x44]
7009cf08: 3040         	adds	r0, #0x40
7009cf0a: 2140         	movs	r1, #0x40
7009cf0c: 2206         	movs	r2, #0x6
7009cf0e: 2300         	movs	r3, #0x0
7009cf10: 9302         	str	r3, [sp, #0x8]
7009cf12: f00f fadd    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf5ba
7009cf16: 9b02         	ldr	r3, [sp, #0x8]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009cf18: 9811         	ldr	r0, [sp, #0x44]
7009cf1a: 301c         	adds	r0, #0x1c
7009cf1c: 210f         	movs	r1, #0xf
7009cf1e: 461a         	mov	r2, r3
7009cf20: f00f fad6    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf5ac
;         fcrValue &= ~((uint32_t) UART_FCR_TX_FIFO_TRIG_MASK);
7009cf24: 980c         	ldr	r0, [sp, #0x30]
7009cf26: f020 0030    	bic	r0, r0, #0x30
7009cf2a: 900c         	str	r0, [sp, #0x30]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009cf2c: 9809         	ldr	r0, [sp, #0x24]
7009cf2e: 2808         	cmp	r0, #0x8
7009cf30: d00c         	beq	0x7009cf4c <UART_fifoConfig+0x15c> @ imm = #0x18
7009cf32: e7ff         	b	0x7009cf34 <UART_fifoConfig+0x144> @ imm = #-0x2
;            (UART_TXTRIGLVL_16 == (txTrig)) ||
7009cf34: 9809         	ldr	r0, [sp, #0x24]
7009cf36: 2810         	cmp	r0, #0x10
7009cf38: d008         	beq	0x7009cf4c <UART_fifoConfig+0x15c> @ imm = #0x10
7009cf3a: e7ff         	b	0x7009cf3c <UART_fifoConfig+0x14c> @ imm = #-0x2
;            (UART_TXTRIGLVL_32 == (txTrig)) ||
7009cf3c: 9809         	ldr	r0, [sp, #0x24]
7009cf3e: 2820         	cmp	r0, #0x20
7009cf40: d004         	beq	0x7009cf4c <UART_fifoConfig+0x15c> @ imm = #0x8
7009cf42: e7ff         	b	0x7009cf44 <UART_fifoConfig+0x154> @ imm = #-0x2
;            (UART_TXTRIGLVL_56 == (txTrig)))
7009cf44: 9809         	ldr	r0, [sp, #0x24]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009cf46: 2838         	cmp	r0, #0x38
7009cf48: d107         	bne	0x7009cf5a <UART_fifoConfig+0x16a> @ imm = #0xe
7009cf4a: e7ff         	b	0x7009cf4c <UART_fifoConfig+0x15c> @ imm = #-0x2
;             fcrValue |= txTrig & UART_FCR_TX_FIFO_TRIG_MASK;
7009cf4c: 9809         	ldr	r0, [sp, #0x24]
7009cf4e: f000 0130    	and	r1, r0, #0x30
7009cf52: 980c         	ldr	r0, [sp, #0x30]
7009cf54: 4308         	orrs	r0, r1
7009cf56: 900c         	str	r0, [sp, #0x30]
;         }
7009cf58: e007         	b	0x7009cf6a <UART_fifoConfig+0x17a> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009cf5a: 9811         	ldr	r0, [sp, #0x44]
7009cf5c: 301c         	adds	r0, #0x1c
7009cf5e: 9b09         	ldr	r3, [sp, #0x24]
7009cf60: 210f         	movs	r1, #0xf
7009cf62: 2200         	movs	r2, #0x0
7009cf64: f00f fab4    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf568
7009cf68: e7ff         	b	0x7009cf6a <UART_fifoConfig+0x17a> @ imm = #-0x2
;     }
7009cf6a: e01d         	b	0x7009cfa8 <UART_fifoConfig+0x1b8> @ imm = #0x3a
;         txTrig &= 0x003FU;
7009cf6c: 9809         	ldr	r0, [sp, #0x24]
7009cf6e: f000 003f    	and	r0, r0, #0x3f
7009cf72: 9009         	str	r0, [sp, #0x24]
;         tlrValue = (txTrig & 0x003CU) >> 2;
7009cf74: 9809         	ldr	r0, [sp, #0x24]
7009cf76: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009cf7a: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (txTrig & 0x0003U) << UART_FCR_TX_FIFO_TRIG_SHIFT;
7009cf7c: 9809         	ldr	r0, [sp, #0x24]
7009cf7e: f000 0103    	and	r1, r0, #0x3
7009cf82: 980c         	ldr	r0, [sp, #0x30]
7009cf84: ea40 1001    	orr.w	r0, r0, r1, lsl #4
7009cf88: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009cf8a: 9811         	ldr	r0, [sp, #0x44]
7009cf8c: 3040         	adds	r0, #0x40
7009cf8e: 2140         	movs	r1, #0x40
7009cf90: 2206         	movs	r2, #0x6
7009cf92: 2301         	movs	r3, #0x1
7009cf94: f00f fa9c    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf538
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA, tlrValue);
7009cf98: 9811         	ldr	r0, [sp, #0x44]
7009cf9a: 301c         	adds	r0, #0x1c
7009cf9c: 9b0d         	ldr	r3, [sp, #0x34]
7009cf9e: 210f         	movs	r1, #0xf
7009cfa0: 2200         	movs	r2, #0x0
7009cfa2: f00f fa95    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf52a
7009cfa6: e7ff         	b	0x7009cfa8 <UART_fifoConfig+0x1b8> @ imm = #-0x2
;     if(UART_DMA_EN_PATH_FCR == dmaEnPath)
7009cfa8: 9805         	ldr	r0, [sp, #0x14]
7009cfaa: b9a8         	cbnz	r0, 0x7009cfd8 <UART_fifoConfig+0x1e8> @ imm = #0x2a
7009cfac: e7ff         	b	0x7009cfae <UART_fifoConfig+0x1be> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009cfae: 9811         	ldr	r0, [sp, #0x44]
7009cfb0: 3040         	adds	r0, #0x40
7009cfb2: 2101         	movs	r1, #0x1
7009cfb4: 2300         	movs	r3, #0x0
7009cfb6: 461a         	mov	r2, r3
7009cfb8: f00f fa8a    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf514
;         dmaMode &= 0x1U;
7009cfbc: 9804         	ldr	r0, [sp, #0x10]
7009cfbe: f000 0001    	and	r0, r0, #0x1
7009cfc2: 9004         	str	r0, [sp, #0x10]
;         fcrValue &= ~((uint32_t) UART_FCR_DMA_MODE_MASK);
7009cfc4: 980c         	ldr	r0, [sp, #0x30]
7009cfc6: f020 0008    	bic	r0, r0, #0x8
7009cfca: 900c         	str	r0, [sp, #0x30]
;         fcrValue |= dmaMode << UART_FCR_DMA_MODE_SHIFT;
7009cfcc: 9904         	ldr	r1, [sp, #0x10]
7009cfce: 980c         	ldr	r0, [sp, #0x30]
7009cfd0: ea40 00c1    	orr.w	r0, r0, r1, lsl #3
7009cfd4: 900c         	str	r0, [sp, #0x30]
;     }
7009cfd6: e013         	b	0x7009d000 <UART_fifoConfig+0x210> @ imm = #0x26
;         dmaMode &= 0x3U;
7009cfd8: 9804         	ldr	r0, [sp, #0x10]
7009cfda: f000 0003    	and	r0, r0, #0x3
7009cfde: 9004         	str	r0, [sp, #0x10]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009cfe0: 9811         	ldr	r0, [sp, #0x44]
7009cfe2: 3040         	adds	r0, #0x40
7009cfe4: 2200         	movs	r2, #0x0
7009cfe6: 2301         	movs	r3, #0x1
7009cfe8: 9301         	str	r3, [sp, #0x4]
7009cfea: 4619         	mov	r1, r3
7009cfec: f00f fa70    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf4e0
7009cff0: 9a01         	ldr	r2, [sp, #0x4]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_2, dmaMode);
7009cff2: 9811         	ldr	r0, [sp, #0x44]
7009cff4: 3040         	adds	r0, #0x40
7009cff6: 9b04         	ldr	r3, [sp, #0x10]
7009cff8: 2106         	movs	r1, #0x6
7009cffa: f00f fa69    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0xf4d2
7009cffe: e7ff         	b	0x7009d000 <UART_fifoConfig+0x210> @ imm = #-0x2
;     fcrValue |= rxClr << UART_FCR_RX_FIFO_CLEAR_SHIFT;
7009d000: 9906         	ldr	r1, [sp, #0x18]
7009d002: 980c         	ldr	r0, [sp, #0x30]
7009d004: ea40 0041    	orr.w	r0, r0, r1, lsl #1
7009d008: 900c         	str	r0, [sp, #0x30]
;     fcrValue |= txClr << UART_FCR_TX_FIFO_CLEAR_SHIFT;
7009d00a: 9907         	ldr	r1, [sp, #0x1c]
7009d00c: 980c         	ldr	r0, [sp, #0x30]
7009d00e: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009d012: 900c         	str	r0, [sp, #0x30]
;     UART_fifoRegisterWrite(baseAddr, fcrValue);
7009d014: 9811         	ldr	r0, [sp, #0x44]
7009d016: 990c         	ldr	r1, [sp, #0x30]
7009d018: f00c fd3a    	bl	0x700a9a90 <UART_fifoRegisterWrite> @ imm = #0xca74
;     UART_tcrTlrBitValRestore(baseAddr, tcrTlrBitVal);
7009d01c: 9811         	ldr	r0, [sp, #0x44]
7009d01e: 990e         	ldr	r1, [sp, #0x38]
7009d020: f00b f9fe    	bl	0x700a8420 <UART_tcrTlrBitValRestore> @ imm = #0xb3fc
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
7009d024: 9811         	ldr	r0, [sp, #0x44]
7009d026: 990f         	ldr	r1, [sp, #0x3c]
7009d028: f00f fa72    	bl	0x700ac510 <UART_enhanFuncBitValRestore> @ imm = #0xf4e4
;     return fcrValue;
7009d02c: 980c         	ldr	r0, [sp, #0x30]
7009d02e: b012         	add	sp, #0x48
7009d030: bd80         	pop	{r7, pc}
		...
7009d03e: 0000         	movs	r0, r0

7009d040 <_ntoa_format>:
; {
7009d040: b570         	push	{r4, r5, r6, lr}
7009d042: b08c         	sub	sp, #0x30
7009d044: 4684         	mov	r12, r0
7009d046: 9816         	ldr	r0, [sp, #0x58]
7009d048: 9815         	ldr	r0, [sp, #0x54]
7009d04a: 9814         	ldr	r0, [sp, #0x50]
7009d04c: 9813         	ldr	r0, [sp, #0x4c]
7009d04e: 9812         	ldr	r0, [sp, #0x48]
7009d050: f8dd e044    	ldr.w	lr, [sp, #0x44]
7009d054: f8dd e040    	ldr.w	lr, [sp, #0x40]
7009d058: f8cd c02c    	str.w	r12, [sp, #0x2c]
7009d05c: 910a         	str	r1, [sp, #0x28]
7009d05e: 9209         	str	r2, [sp, #0x24]
7009d060: 9308         	str	r3, [sp, #0x20]
7009d062: f88d 001f    	strb.w	r0, [sp, #0x1f]
;   if (!(flags & FLAGS_LEFT)) {
7009d066: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d06a: 0780         	lsls	r0, r0, #0x1e
7009d06c: 2800         	cmp	r0, #0x0
7009d06e: d454         	bmi	0x7009d11a <_ntoa_format+0xda> @ imm = #0xa8
7009d070: e7ff         	b	0x7009d072 <_ntoa_format+0x32> @ imm = #-0x2
;     if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009d072: 9815         	ldr	r0, [sp, #0x54]
7009d074: b1a0         	cbz	r0, 0x7009d0a0 <_ntoa_format+0x60> @ imm = #0x28
7009d076: e7ff         	b	0x7009d078 <_ntoa_format+0x38> @ imm = #-0x2
7009d078: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d07c: 07c0         	lsls	r0, r0, #0x1f
7009d07e: b178         	cbz	r0, 0x7009d0a0 <_ntoa_format+0x60> @ imm = #0x1e
7009d080: e7ff         	b	0x7009d082 <_ntoa_format+0x42> @ imm = #-0x2
7009d082: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009d086: 07c0         	lsls	r0, r0, #0x1f
7009d088: b930         	cbnz	r0, 0x7009d098 <_ntoa_format+0x58> @ imm = #0xc
7009d08a: e7ff         	b	0x7009d08c <_ntoa_format+0x4c> @ imm = #-0x2
7009d08c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d090: f010 0f0c    	tst.w	r0, #0xc
7009d094: d004         	beq	0x7009d0a0 <_ntoa_format+0x60> @ imm = #0x8
7009d096: e7ff         	b	0x7009d098 <_ntoa_format+0x58> @ imm = #-0x2
;       width--;
7009d098: 9815         	ldr	r0, [sp, #0x54]
7009d09a: 3801         	subs	r0, #0x1
7009d09c: 9015         	str	r0, [sp, #0x54]
;     }
7009d09e: e7ff         	b	0x7009d0a0 <_ntoa_format+0x60> @ imm = #-0x2
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d0a0: e7ff         	b	0x7009d0a2 <_ntoa_format+0x62> @ imm = #-0x2
7009d0a2: 9911         	ldr	r1, [sp, #0x44]
7009d0a4: 9a14         	ldr	r2, [sp, #0x50]
7009d0a6: 2000         	movs	r0, #0x0
7009d0a8: 4291         	cmp	r1, r2
7009d0aa: 9006         	str	r0, [sp, #0x18]
7009d0ac: d207         	bhs	0x7009d0be <_ntoa_format+0x7e> @ imm = #0xe
7009d0ae: e7ff         	b	0x7009d0b0 <_ntoa_format+0x70> @ imm = #-0x2
7009d0b0: 9911         	ldr	r1, [sp, #0x44]
7009d0b2: 2000         	movs	r0, #0x0
7009d0b4: 2920         	cmp	r1, #0x20
7009d0b6: bf38         	it	lo
7009d0b8: 2001         	movlo	r0, #0x1
7009d0ba: 9006         	str	r0, [sp, #0x18]
7009d0bc: e7ff         	b	0x7009d0be <_ntoa_format+0x7e> @ imm = #-0x2
7009d0be: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d0c0: 07c0         	lsls	r0, r0, #0x1f
7009d0c2: b138         	cbz	r0, 0x7009d0d4 <_ntoa_format+0x94> @ imm = #0xe
7009d0c4: e7ff         	b	0x7009d0c6 <_ntoa_format+0x86> @ imm = #-0x2
;       buf[len++] = '0';
7009d0c6: 9910         	ldr	r1, [sp, #0x40]
7009d0c8: 9a11         	ldr	r2, [sp, #0x44]
7009d0ca: 1c50         	adds	r0, r2, #0x1
7009d0cc: 9011         	str	r0, [sp, #0x44]
7009d0ce: 2030         	movs	r0, #0x30
7009d0d0: 5488         	strb	r0, [r1, r2]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d0d2: e7e6         	b	0x7009d0a2 <_ntoa_format+0x62> @ imm = #-0x34
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d0d4: e7ff         	b	0x7009d0d6 <_ntoa_format+0x96> @ imm = #-0x2
7009d0d6: 2000         	movs	r0, #0x0
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d0d8: f89d 1058    	ldrb.w	r1, [sp, #0x58]
7009d0dc: ea4f 71c1    	lsl.w	r1, r1, #0x1f
7009d0e0: 9005         	str	r0, [sp, #0x14]
7009d0e2: b171         	cbz	r1, 0x7009d102 <_ntoa_format+0xc2> @ imm = #0x1c
7009d0e4: e7ff         	b	0x7009d0e6 <_ntoa_format+0xa6> @ imm = #-0x2
7009d0e6: 9911         	ldr	r1, [sp, #0x44]
7009d0e8: 9a15         	ldr	r2, [sp, #0x54]
7009d0ea: 2000         	movs	r0, #0x0
7009d0ec: 4291         	cmp	r1, r2
7009d0ee: 9005         	str	r0, [sp, #0x14]
7009d0f0: d207         	bhs	0x7009d102 <_ntoa_format+0xc2> @ imm = #0xe
7009d0f2: e7ff         	b	0x7009d0f4 <_ntoa_format+0xb4> @ imm = #-0x2
7009d0f4: 9911         	ldr	r1, [sp, #0x44]
7009d0f6: 2000         	movs	r0, #0x0
7009d0f8: 2920         	cmp	r1, #0x20
7009d0fa: bf38         	it	lo
7009d0fc: 2001         	movlo	r0, #0x1
7009d0fe: 9005         	str	r0, [sp, #0x14]
7009d100: e7ff         	b	0x7009d102 <_ntoa_format+0xc2> @ imm = #-0x2
7009d102: 9805         	ldr	r0, [sp, #0x14]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d104: 07c0         	lsls	r0, r0, #0x1f
7009d106: b138         	cbz	r0, 0x7009d118 <_ntoa_format+0xd8> @ imm = #0xe
7009d108: e7ff         	b	0x7009d10a <_ntoa_format+0xca> @ imm = #-0x2
;       buf[len++] = '0';
7009d10a: 9910         	ldr	r1, [sp, #0x40]
7009d10c: 9a11         	ldr	r2, [sp, #0x44]
7009d10e: 1c50         	adds	r0, r2, #0x1
7009d110: 9011         	str	r0, [sp, #0x44]
7009d112: 2030         	movs	r0, #0x30
7009d114: 5488         	strb	r0, [r1, r2]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d116: e7de         	b	0x7009d0d6 <_ntoa_format+0x96> @ imm = #-0x44
;   }
7009d118: e7ff         	b	0x7009d11a <_ntoa_format+0xda> @ imm = #-0x2
;   if (flags & FLAGS_HASH) {
7009d11a: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d11e: 06c0         	lsls	r0, r0, #0x1b
7009d120: 2800         	cmp	r0, #0x0
7009d122: d569         	bpl	0x7009d1f8 <_ntoa_format+0x1b8> @ imm = #0xd2
7009d124: e7ff         	b	0x7009d126 <_ntoa_format+0xe6> @ imm = #-0x2
;     if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
7009d126: f89d 0059    	ldrb.w	r0, [sp, #0x59]
7009d12a: 0740         	lsls	r0, r0, #0x1d
7009d12c: 2800         	cmp	r0, #0x0
7009d12e: d41c         	bmi	0x7009d16a <_ntoa_format+0x12a> @ imm = #0x38
7009d130: e7ff         	b	0x7009d132 <_ntoa_format+0xf2> @ imm = #-0x2
7009d132: 9811         	ldr	r0, [sp, #0x44]
7009d134: b1c8         	cbz	r0, 0x7009d16a <_ntoa_format+0x12a> @ imm = #0x32
7009d136: e7ff         	b	0x7009d138 <_ntoa_format+0xf8> @ imm = #-0x2
7009d138: 9811         	ldr	r0, [sp, #0x44]
7009d13a: 9914         	ldr	r1, [sp, #0x50]
7009d13c: 4288         	cmp	r0, r1
7009d13e: d005         	beq	0x7009d14c <_ntoa_format+0x10c> @ imm = #0xa
7009d140: e7ff         	b	0x7009d142 <_ntoa_format+0x102> @ imm = #-0x2
7009d142: 9811         	ldr	r0, [sp, #0x44]
7009d144: 9915         	ldr	r1, [sp, #0x54]
7009d146: 4288         	cmp	r0, r1
7009d148: d10f         	bne	0x7009d16a <_ntoa_format+0x12a> @ imm = #0x1e
7009d14a: e7ff         	b	0x7009d14c <_ntoa_format+0x10c> @ imm = #-0x2
;       len--;
7009d14c: 9811         	ldr	r0, [sp, #0x44]
7009d14e: 3801         	subs	r0, #0x1
7009d150: 9011         	str	r0, [sp, #0x44]
;       if (len && (base == 16U)) {
7009d152: 9811         	ldr	r0, [sp, #0x44]
7009d154: b140         	cbz	r0, 0x7009d168 <_ntoa_format+0x128> @ imm = #0x10
7009d156: e7ff         	b	0x7009d158 <_ntoa_format+0x118> @ imm = #-0x2
7009d158: 9813         	ldr	r0, [sp, #0x4c]
7009d15a: 2810         	cmp	r0, #0x10
7009d15c: d104         	bne	0x7009d168 <_ntoa_format+0x128> @ imm = #0x8
7009d15e: e7ff         	b	0x7009d160 <_ntoa_format+0x120> @ imm = #-0x2
;         len--;
7009d160: 9811         	ldr	r0, [sp, #0x44]
7009d162: 3801         	subs	r0, #0x1
7009d164: 9011         	str	r0, [sp, #0x44]
;       }
7009d166: e7ff         	b	0x7009d168 <_ntoa_format+0x128> @ imm = #-0x2
;     }
7009d168: e7ff         	b	0x7009d16a <_ntoa_format+0x12a> @ imm = #-0x2
;     if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d16a: 9813         	ldr	r0, [sp, #0x4c]
7009d16c: 2810         	cmp	r0, #0x10
7009d16e: d111         	bne	0x7009d194 <_ntoa_format+0x154> @ imm = #0x22
7009d170: e7ff         	b	0x7009d172 <_ntoa_format+0x132> @ imm = #-0x2
7009d172: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d176: 0680         	lsls	r0, r0, #0x1a
7009d178: 2800         	cmp	r0, #0x0
7009d17a: d40b         	bmi	0x7009d194 <_ntoa_format+0x154> @ imm = #0x16
7009d17c: e7ff         	b	0x7009d17e <_ntoa_format+0x13e> @ imm = #-0x2
7009d17e: 9811         	ldr	r0, [sp, #0x44]
7009d180: 281f         	cmp	r0, #0x1f
7009d182: d807         	bhi	0x7009d194 <_ntoa_format+0x154> @ imm = #0xe
7009d184: e7ff         	b	0x7009d186 <_ntoa_format+0x146> @ imm = #-0x2
;       buf[len++] = 'x';
7009d186: 9910         	ldr	r1, [sp, #0x40]
7009d188: 9a11         	ldr	r2, [sp, #0x44]
7009d18a: 1c50         	adds	r0, r2, #0x1
7009d18c: 9011         	str	r0, [sp, #0x44]
7009d18e: 2078         	movs	r0, #0x78
7009d190: 5488         	strb	r0, [r1, r2]
;     }
7009d192: e025         	b	0x7009d1e0 <_ntoa_format+0x1a0> @ imm = #0x4a
;     else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d194: 9813         	ldr	r0, [sp, #0x4c]
7009d196: 2810         	cmp	r0, #0x10
7009d198: d111         	bne	0x7009d1be <_ntoa_format+0x17e> @ imm = #0x22
7009d19a: e7ff         	b	0x7009d19c <_ntoa_format+0x15c> @ imm = #-0x2
7009d19c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d1a0: 0680         	lsls	r0, r0, #0x1a
7009d1a2: 2800         	cmp	r0, #0x0
7009d1a4: d50b         	bpl	0x7009d1be <_ntoa_format+0x17e> @ imm = #0x16
7009d1a6: e7ff         	b	0x7009d1a8 <_ntoa_format+0x168> @ imm = #-0x2
7009d1a8: 9811         	ldr	r0, [sp, #0x44]
7009d1aa: 281f         	cmp	r0, #0x1f
7009d1ac: d807         	bhi	0x7009d1be <_ntoa_format+0x17e> @ imm = #0xe
7009d1ae: e7ff         	b	0x7009d1b0 <_ntoa_format+0x170> @ imm = #-0x2
;       buf[len++] = 'X';
7009d1b0: 9910         	ldr	r1, [sp, #0x40]
7009d1b2: 9a11         	ldr	r2, [sp, #0x44]
7009d1b4: 1c50         	adds	r0, r2, #0x1
7009d1b6: 9011         	str	r0, [sp, #0x44]
7009d1b8: 2058         	movs	r0, #0x58
7009d1ba: 5488         	strb	r0, [r1, r2]
;     }
7009d1bc: e00f         	b	0x7009d1de <_ntoa_format+0x19e> @ imm = #0x1e
;     else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d1be: 9813         	ldr	r0, [sp, #0x4c]
7009d1c0: 2802         	cmp	r0, #0x2
7009d1c2: d10b         	bne	0x7009d1dc <_ntoa_format+0x19c> @ imm = #0x16
7009d1c4: e7ff         	b	0x7009d1c6 <_ntoa_format+0x186> @ imm = #-0x2
7009d1c6: 9811         	ldr	r0, [sp, #0x44]
7009d1c8: 281f         	cmp	r0, #0x1f
7009d1ca: d807         	bhi	0x7009d1dc <_ntoa_format+0x19c> @ imm = #0xe
7009d1cc: e7ff         	b	0x7009d1ce <_ntoa_format+0x18e> @ imm = #-0x2
;       buf[len++] = 'b';
7009d1ce: 9910         	ldr	r1, [sp, #0x40]
7009d1d0: 9a11         	ldr	r2, [sp, #0x44]
7009d1d2: 1c50         	adds	r0, r2, #0x1
7009d1d4: 9011         	str	r0, [sp, #0x44]
7009d1d6: 2062         	movs	r0, #0x62
7009d1d8: 5488         	strb	r0, [r1, r2]
;     }
7009d1da: e7ff         	b	0x7009d1dc <_ntoa_format+0x19c> @ imm = #-0x2
7009d1dc: e7ff         	b	0x7009d1de <_ntoa_format+0x19e> @ imm = #-0x2
7009d1de: e7ff         	b	0x7009d1e0 <_ntoa_format+0x1a0> @ imm = #-0x2
;     if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009d1e0: 9811         	ldr	r0, [sp, #0x44]
7009d1e2: 281f         	cmp	r0, #0x1f
7009d1e4: d807         	bhi	0x7009d1f6 <_ntoa_format+0x1b6> @ imm = #0xe
7009d1e6: e7ff         	b	0x7009d1e8 <_ntoa_format+0x1a8> @ imm = #-0x2
;       buf[len++] = '0';
7009d1e8: 9910         	ldr	r1, [sp, #0x40]
7009d1ea: 9a11         	ldr	r2, [sp, #0x44]
7009d1ec: 1c50         	adds	r0, r2, #0x1
7009d1ee: 9011         	str	r0, [sp, #0x44]
7009d1f0: 2030         	movs	r0, #0x30
7009d1f2: 5488         	strb	r0, [r1, r2]
;     }
7009d1f4: e7ff         	b	0x7009d1f6 <_ntoa_format+0x1b6> @ imm = #-0x2
;   }
7009d1f6: e7ff         	b	0x7009d1f8 <_ntoa_format+0x1b8> @ imm = #-0x2
;   if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009d1f8: 9811         	ldr	r0, [sp, #0x44]
7009d1fa: 281f         	cmp	r0, #0x1f
7009d1fc: d829         	bhi	0x7009d252 <_ntoa_format+0x212> @ imm = #0x52
7009d1fe: e7ff         	b	0x7009d200 <_ntoa_format+0x1c0> @ imm = #-0x2
;     if (negative) {
7009d200: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009d204: 07c0         	lsls	r0, r0, #0x1f
7009d206: b138         	cbz	r0, 0x7009d218 <_ntoa_format+0x1d8> @ imm = #0xe
7009d208: e7ff         	b	0x7009d20a <_ntoa_format+0x1ca> @ imm = #-0x2
;       buf[len++] = '-';
7009d20a: 9910         	ldr	r1, [sp, #0x40]
7009d20c: 9a11         	ldr	r2, [sp, #0x44]
7009d20e: 1c50         	adds	r0, r2, #0x1
7009d210: 9011         	str	r0, [sp, #0x44]
7009d212: 202d         	movs	r0, #0x2d
7009d214: 5488         	strb	r0, [r1, r2]
;     }
7009d216: e01b         	b	0x7009d250 <_ntoa_format+0x210> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009d218: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d21c: 0740         	lsls	r0, r0, #0x1d
7009d21e: 2800         	cmp	r0, #0x0
7009d220: d507         	bpl	0x7009d232 <_ntoa_format+0x1f2> @ imm = #0xe
7009d222: e7ff         	b	0x7009d224 <_ntoa_format+0x1e4> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009d224: 9910         	ldr	r1, [sp, #0x40]
7009d226: 9a11         	ldr	r2, [sp, #0x44]
7009d228: 1c50         	adds	r0, r2, #0x1
7009d22a: 9011         	str	r0, [sp, #0x44]
7009d22c: 202b         	movs	r0, #0x2b
7009d22e: 5488         	strb	r0, [r1, r2]
;     }
7009d230: e00d         	b	0x7009d24e <_ntoa_format+0x20e> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009d232: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d236: 0700         	lsls	r0, r0, #0x1c
7009d238: 2800         	cmp	r0, #0x0
7009d23a: d507         	bpl	0x7009d24c <_ntoa_format+0x20c> @ imm = #0xe
7009d23c: e7ff         	b	0x7009d23e <_ntoa_format+0x1fe> @ imm = #-0x2
;       buf[len++] = ' ';
7009d23e: 9910         	ldr	r1, [sp, #0x40]
7009d240: 9a11         	ldr	r2, [sp, #0x44]
7009d242: 1c50         	adds	r0, r2, #0x1
7009d244: 9011         	str	r0, [sp, #0x44]
7009d246: 2020         	movs	r0, #0x20
7009d248: 5488         	strb	r0, [r1, r2]
;     }
7009d24a: e7ff         	b	0x7009d24c <_ntoa_format+0x20c> @ imm = #-0x2
7009d24c: e7ff         	b	0x7009d24e <_ntoa_format+0x20e> @ imm = #-0x2
7009d24e: e7ff         	b	0x7009d250 <_ntoa_format+0x210> @ imm = #-0x2
;   }
7009d250: e7ff         	b	0x7009d252 <_ntoa_format+0x212> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009d252: 980b         	ldr	r0, [sp, #0x2c]
7009d254: 990a         	ldr	r1, [sp, #0x28]
7009d256: 9a09         	ldr	r2, [sp, #0x24]
7009d258: 9b08         	ldr	r3, [sp, #0x20]
7009d25a: f8dd c040    	ldr.w	r12, [sp, #0x40]
7009d25e: 9c11         	ldr	r4, [sp, #0x44]
7009d260: 9d15         	ldr	r5, [sp, #0x54]
7009d262: 9e16         	ldr	r6, [sp, #0x58]
7009d264: 46ee         	mov	lr, sp
7009d266: f8ce 600c    	str.w	r6, [lr, #0xc]
7009d26a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009d26e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009d272: f8ce c000    	str.w	r12, [lr]
7009d276: f008 f9fb    	bl	0x700a5670 <_out_rev>   @ imm = #0x83f6
7009d27a: b00c         	add	sp, #0x30
7009d27c: bd70         	pop	{r4, r5, r6, pc}
7009d27e: 0000         	movs	r0, r0

7009d280 <Udma_eventRegister>:
; {
7009d280: b5b0         	push	{r4, r5, r7, lr}
7009d282: b088         	sub	sp, #0x20
7009d284: 9007         	str	r0, [sp, #0x1c]
7009d286: 9106         	str	r1, [sp, #0x18]
7009d288: 9205         	str	r2, [sp, #0x14]
7009d28a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d28c: 9004         	str	r0, [sp, #0x10]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009d28e: 9003         	str	r0, [sp, #0xc]
;     if((NULL_PTR == drvHandle) || (NULL_PTR == eventHandle) || (NULL_PTR == eventPrms))
7009d290: 9807         	ldr	r0, [sp, #0x1c]
7009d292: b130         	cbz	r0, 0x7009d2a2 <Udma_eventRegister+0x22> @ imm = #0xc
7009d294: e7ff         	b	0x7009d296 <Udma_eventRegister+0x16> @ imm = #-0x2
7009d296: 9806         	ldr	r0, [sp, #0x18]
7009d298: b118         	cbz	r0, 0x7009d2a2 <Udma_eventRegister+0x22> @ imm = #0x6
7009d29a: e7ff         	b	0x7009d29c <Udma_eventRegister+0x1c> @ imm = #-0x2
7009d29c: 9805         	ldr	r0, [sp, #0x14]
7009d29e: b920         	cbnz	r0, 0x7009d2aa <Udma_eventRegister+0x2a> @ imm = #0x8
7009d2a0: e7ff         	b	0x7009d2a2 <Udma_eventRegister+0x22> @ imm = #-0x2
7009d2a2: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009d2a6: 9004         	str	r0, [sp, #0x10]
;     }
7009d2a8: e7ff         	b	0x7009d2aa <Udma_eventRegister+0x2a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d2aa: 9804         	ldr	r0, [sp, #0x10]
7009d2ac: b988         	cbnz	r0, 0x7009d2d2 <Udma_eventRegister+0x52> @ imm = #0x22
7009d2ae: e7ff         	b	0x7009d2b0 <Udma_eventRegister+0x30> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009d2b0: 9807         	ldr	r0, [sp, #0x1c]
7009d2b2: 9002         	str	r0, [sp, #0x8]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009d2b4: 9802         	ldr	r0, [sp, #0x8]
7009d2b6: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009d2ba: f64a 31cd    	movw	r1, #0xabcd
7009d2be: f6ca 31dc    	movt	r1, #0xabdc
7009d2c2: 4288         	cmp	r0, r1
7009d2c4: d004         	beq	0x7009d2d0 <Udma_eventRegister+0x50> @ imm = #0x8
7009d2c6: e7ff         	b	0x7009d2c8 <Udma_eventRegister+0x48> @ imm = #-0x2
7009d2c8: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009d2cc: 9004         	str	r0, [sp, #0x10]
;         }
7009d2ce: e7ff         	b	0x7009d2d0 <Udma_eventRegister+0x50> @ imm = #-0x2
;     }
7009d2d0: e7ff         	b	0x7009d2d2 <Udma_eventRegister+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d2d2: 9804         	ldr	r0, [sp, #0x10]
7009d2d4: b930         	cbnz	r0, 0x7009d2e4 <Udma_eventRegister+0x64> @ imm = #0xc
7009d2d6: e7ff         	b	0x7009d2d8 <Udma_eventRegister+0x58> @ imm = #-0x2
;         retVal = Udma_eventCheckParams(drvHandleInt, eventPrms);
7009d2d8: 9802         	ldr	r0, [sp, #0x8]
7009d2da: 9905         	ldr	r1, [sp, #0x14]
7009d2dc: f006 f8e0    	bl	0x700a34a0 <Udma_eventCheckParams> @ imm = #0x61c0
7009d2e0: 9004         	str	r0, [sp, #0x10]
;     }
7009d2e2: e7ff         	b	0x7009d2e4 <Udma_eventRegister+0x64> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d2e4: 9804         	ldr	r0, [sp, #0x10]
7009d2e6: bbb0         	cbnz	r0, 0x7009d356 <Udma_eventRegister+0xd6> @ imm = #0x6c
7009d2e8: e7ff         	b	0x7009d2ea <Udma_eventRegister+0x6a> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
7009d2ea: 9806         	ldr	r0, [sp, #0x18]
7009d2ec: 9001         	str	r0, [sp, #0x4]
;             &eventHandleInt->eventPrms, eventPrms, sizeof(eventHandleInt->eventPrms));
7009d2ee: 9801         	ldr	r0, [sp, #0x4]
7009d2f0: 3008         	adds	r0, #0x8
7009d2f2: 9905         	ldr	r1, [sp, #0x14]
;         (void) memcpy(
7009d2f4: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009d2f8: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009d2fc: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009d300: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009d304: e891 503c    	ldm.w	r1, {r2, r3, r4, r5, r12, lr}
7009d308: e880 503c    	stm.w	r0, {r2, r3, r4, r5, r12, lr}
;         eventHandleInt->drvHandle       = drvHandleInt;
7009d30c: 9802         	ldr	r0, [sp, #0x8]
7009d30e: 9901         	ldr	r1, [sp, #0x4]
7009d310: 6008         	str	r0, [r1]
;         eventHandleInt->globalEvent     = UDMA_EVENT_INVALID;
7009d312: 9901         	ldr	r1, [sp, #0x4]
7009d314: f64f 70ff    	movw	r0, #0xffff
7009d318: 6488         	str	r0, [r1, #0x48]
;         eventHandleInt->vintrNum        = UDMA_EVENT_INVALID;
7009d31a: 9901         	ldr	r1, [sp, #0x4]
7009d31c: 64c8         	str	r0, [r1, #0x4c]
;         eventHandleInt->vintrBitNum     = UDMA_EVENT_INVALID;
7009d31e: 9901         	ldr	r1, [sp, #0x4]
7009d320: 6508         	str	r0, [r1, #0x50]
;         eventHandleInt->irIntrNum       = UDMA_INTR_INVALID;
7009d322: 9901         	ldr	r1, [sp, #0x4]
7009d324: 2000         	movs	r0, #0x0
7009d326: f6cf 70ff    	movt	r0, #0xffff
7009d32a: 6548         	str	r0, [r1, #0x54]
;         eventHandleInt->coreIntrNum     = UDMA_INTR_INVALID;
7009d32c: 9901         	ldr	r1, [sp, #0x4]
7009d32e: 6588         	str	r0, [r1, #0x58]
;         eventHandleInt->nextEvent       = (Udma_EventHandleInt) NULL_PTR;
7009d330: 9901         	ldr	r1, [sp, #0x4]
7009d332: 2000         	movs	r0, #0x0
7009d334: 65c8         	str	r0, [r1, #0x5c]
;         eventHandleInt->prevEvent       = (Udma_EventHandleInt) NULL_PTR;
7009d336: 9901         	ldr	r1, [sp, #0x4]
7009d338: 6608         	str	r0, [r1, #0x60]
;         eventHandleInt->hwiHandle       = NULL_PTR;
7009d33a: 9901         	ldr	r1, [sp, #0x4]
7009d33c: 6648         	str	r0, [r1, #0x64]
;         eventHandleInt->vintrBitAllocFlag = 0U;
7009d33e: 9901         	ldr	r1, [sp, #0x4]
7009d340: f8c1 008c    	str.w	r0, [r1, #0x8c]
7009d344: f8c1 0088    	str.w	r0, [r1, #0x88]
;         eventHandleInt->pIaGeviRegs     = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
7009d348: 9901         	ldr	r1, [sp, #0x4]
7009d34a: f8c1 0090    	str.w	r0, [r1, #0x90]
;         eventHandleInt->pIaVintrRegs    = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
7009d34e: 9901         	ldr	r1, [sp, #0x4]
7009d350: f8c1 0094    	str.w	r0, [r1, #0x94]
;     }
7009d354: e7ff         	b	0x7009d356 <Udma_eventRegister+0xd6> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d356: 9804         	ldr	r0, [sp, #0x10]
7009d358: 2800         	cmp	r0, #0x0
7009d35a: f040 809f    	bne.w	0x7009d49c <Udma_eventRegister+0x21c> @ imm = #0x13e
7009d35e: e7ff         	b	0x7009d360 <Udma_eventRegister+0xe0> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009d360: 9802         	ldr	r0, [sp, #0x8]
7009d362: 6800         	ldr	r0, [r0]
7009d364: b130         	cbz	r0, 0x7009d374 <Udma_eventRegister+0xf4> @ imm = #0xc
7009d366: e7ff         	b	0x7009d368 <Udma_eventRegister+0xe8> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009d368: 9805         	ldr	r0, [sp, #0x14]
7009d36a: 6800         	ldr	r0, [r0]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009d36c: 2802         	cmp	r0, #0x2
7009d36e: d101         	bne	0x7009d374 <Udma_eventRegister+0xf4> @ imm = #0x2
7009d370: e7ff         	b	0x7009d372 <Udma_eventRegister+0xf2> @ imm = #-0x2
;         }
7009d372: e092         	b	0x7009d49a <Udma_eventRegister+0x21a> @ imm = #0x124
;             retVal = Udma_eventAllocResource(drvHandleInt, eventHandleInt);
7009d374: 9802         	ldr	r0, [sp, #0x8]
7009d376: 9901         	ldr	r1, [sp, #0x4]
7009d378: f000 f89a    	bl	0x7009d4b0 <Udma_eventAllocResource> @ imm = #0x134
7009d37c: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK == retVal)
7009d37e: 9804         	ldr	r0, [sp, #0x10]
7009d380: b918         	cbnz	r0, 0x7009d38a <Udma_eventRegister+0x10a> @ imm = #0x6
7009d382: e7ff         	b	0x7009d384 <Udma_eventRegister+0x104> @ imm = #-0x2
7009d384: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009d386: 9003         	str	r0, [sp, #0xc]
;             }
7009d388: e000         	b	0x7009d38c <Udma_eventRegister+0x10c> @ imm = #0x0
7009d38a: e7ff         	b	0x7009d38c <Udma_eventRegister+0x10c> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009d38c: 9804         	ldr	r0, [sp, #0x10]
7009d38e: b9a0         	cbnz	r0, 0x7009d3ba <Udma_eventRegister+0x13a> @ imm = #0x28
7009d390: e7ff         	b	0x7009d392 <Udma_eventRegister+0x112> @ imm = #-0x2
;                 eventHandleInt->eventInitDone = UDMA_INIT_DONE;
7009d392: 9901         	ldr	r1, [sp, #0x4]
7009d394: f64a 30cd    	movw	r0, #0xabcd
7009d398: f6ca 30dc    	movt	r0, #0xabdc
7009d39c: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 retVal = Udma_eventConfig(drvHandleInt, eventHandleInt);
7009d3a0: 9802         	ldr	r0, [sp, #0x8]
7009d3a2: 9901         	ldr	r1, [sp, #0x4]
7009d3a4: f7fe f8b4    	bl	0x7009b510 <Udma_eventConfig> @ imm = #-0x1e98
7009d3a8: 9004         	str	r0, [sp, #0x10]
;                 if(UDMA_SOK == retVal)
7009d3aa: 9804         	ldr	r0, [sp, #0x10]
7009d3ac: b918         	cbnz	r0, 0x7009d3b6 <Udma_eventRegister+0x136> @ imm = #0x6
7009d3ae: e7ff         	b	0x7009d3b0 <Udma_eventRegister+0x130> @ imm = #-0x2
7009d3b0: 2001         	movs	r0, #0x1
;                     allocDone = (uint32_t) TRUE;
7009d3b2: 9003         	str	r0, [sp, #0xc]
;                 }
7009d3b4: e000         	b	0x7009d3b8 <Udma_eventRegister+0x138> @ imm = #0x0
7009d3b6: e7ff         	b	0x7009d3b8 <Udma_eventRegister+0x138> @ imm = #-0x2
;             }
7009d3b8: e7ff         	b	0x7009d3ba <Udma_eventRegister+0x13a> @ imm = #-0x2
;             if(UDMA_SOK != retVal)
7009d3ba: 9804         	ldr	r0, [sp, #0x10]
7009d3bc: b170         	cbz	r0, 0x7009d3dc <Udma_eventRegister+0x15c> @ imm = #0x1c
7009d3be: e7ff         	b	0x7009d3c0 <Udma_eventRegister+0x140> @ imm = #-0x2
;                 if(((uint32_t) TRUE) == allocDone)
7009d3c0: 9803         	ldr	r0, [sp, #0xc]
7009d3c2: 2801         	cmp	r0, #0x1
7009d3c4: d109         	bne	0x7009d3da <Udma_eventRegister+0x15a> @ imm = #0x12
7009d3c6: e7ff         	b	0x7009d3c8 <Udma_eventRegister+0x148> @ imm = #-0x2
;                     Udma_eventFreeResource(drvHandleInt, eventHandleInt);
7009d3c8: 9802         	ldr	r0, [sp, #0x8]
7009d3ca: 9901         	ldr	r1, [sp, #0x4]
7009d3cc: f006 fd78    	bl	0x700a3ec0 <Udma_eventFreeResource> @ imm = #0x6af0
;                     eventHandleInt->eventInitDone = UDMA_DEINIT_DONE;
7009d3d0: 9901         	ldr	r1, [sp, #0x4]
7009d3d2: 2000         	movs	r0, #0x0
7009d3d4: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 }
7009d3d8: e7ff         	b	0x7009d3da <Udma_eventRegister+0x15a> @ imm = #-0x2
;             }
7009d3da: e05d         	b	0x7009d498 <Udma_eventRegister+0x218> @ imm = #0xba
;                 eventPrms->intrStatusReg    = &eventHandleInt->pIaVintrRegs->STATUSM;
7009d3dc: 9801         	ldr	r0, [sp, #0x4]
7009d3de: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009d3e2: 3020         	adds	r0, #0x20
7009d3e4: 9905         	ldr	r1, [sp, #0x14]
7009d3e6: 6248         	str	r0, [r1, #0x24]
;                 eventPrms->intrClearReg     = &eventHandleInt->pIaVintrRegs->STATUS_CLEAR;
7009d3e8: 9801         	ldr	r0, [sp, #0x4]
7009d3ea: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009d3ee: 3018         	adds	r0, #0x18
7009d3f0: 9905         	ldr	r1, [sp, #0x14]
7009d3f2: 6288         	str	r0, [r1, #0x28]
;                 if(eventHandleInt->vintrBitNum != UDMA_EVENT_INVALID)
7009d3f4: 9801         	ldr	r0, [sp, #0x4]
7009d3f6: 6d00         	ldr	r0, [r0, #0x50]
7009d3f8: f64f 71ff    	movw	r1, #0xffff
7009d3fc: 4288         	cmp	r0, r1
7009d3fe: d017         	beq	0x7009d430 <Udma_eventRegister+0x1b0> @ imm = #0x2e
7009d400: e7ff         	b	0x7009d402 <Udma_eventRegister+0x182> @ imm = #-0x2
;                     eventPrms->intrMask     = ((uint64_t)1U << eventHandleInt->vintrBitNum);
7009d402: 9801         	ldr	r0, [sp, #0x4]
7009d404: 6d03         	ldr	r3, [r0, #0x50]
7009d406: f1a3 0120    	sub.w	r1, r3, #0x20
7009d40a: 2201         	movs	r2, #0x1
7009d40c: fa02 fc01    	lsl.w	r12, r2, r1
7009d410: f1c3 0020    	rsb.w	r0, r3, #0x20
7009d414: fa22 f000    	lsr.w	r0, r2, r0
7009d418: 2900         	cmp	r1, #0x0
7009d41a: bf58         	it	pl
7009d41c: 4660         	movpl	r0, r12
7009d41e: fa02 f203    	lsl.w	r2, r2, r3
7009d422: 2900         	cmp	r1, #0x0
7009d424: bf58         	it	pl
7009d426: 2200         	movpl	r2, #0x0
7009d428: 9905         	ldr	r1, [sp, #0x14]
7009d42a: 630a         	str	r2, [r1, #0x30]
7009d42c: 6348         	str	r0, [r1, #0x34]
;                 }
7009d42e: e004         	b	0x7009d43a <Udma_eventRegister+0x1ba> @ imm = #0x8
;                     eventPrms->intrMask     = 0U;
7009d430: 9905         	ldr	r1, [sp, #0x14]
7009d432: 2000         	movs	r0, #0x0
7009d434: 6348         	str	r0, [r1, #0x34]
7009d436: 6308         	str	r0, [r1, #0x30]
7009d438: e7ff         	b	0x7009d43a <Udma_eventRegister+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == eventHandleInt->eventPrms.controllerEventHandle)
7009d43a: 9801         	ldr	r0, [sp, #0x4]
7009d43c: 6980         	ldr	r0, [r0, #0x18]
7009d43e: b948         	cbnz	r0, 0x7009d454 <Udma_eventRegister+0x1d4> @ imm = #0x12
7009d440: e7ff         	b	0x7009d442 <Udma_eventRegister+0x1c2> @ imm = #-0x2
;                     eventPrms->vintrNum     = eventHandleInt->vintrNum;
7009d442: 9801         	ldr	r0, [sp, #0x4]
7009d444: 6cc0         	ldr	r0, [r0, #0x4c]
7009d446: 9905         	ldr	r1, [sp, #0x14]
7009d448: 6388         	str	r0, [r1, #0x38]
;                     eventPrms->coreIntrNum  = eventHandleInt->coreIntrNum;
7009d44a: 9801         	ldr	r0, [sp, #0x4]
7009d44c: 6d80         	ldr	r0, [r0, #0x58]
7009d44e: 9905         	ldr	r1, [sp, #0x14]
7009d450: 63c8         	str	r0, [r1, #0x3c]
;                 }
7009d452: e00a         	b	0x7009d46a <Udma_eventRegister+0x1ea> @ imm = #0x14
;                        ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->vintrNum;
7009d454: 9801         	ldr	r0, [sp, #0x4]
7009d456: 6980         	ldr	r0, [r0, #0x18]
7009d458: 6cc0         	ldr	r0, [r0, #0x4c]
;                     eventPrms->vintrNum       =
7009d45a: 9905         	ldr	r1, [sp, #0x14]
7009d45c: 6388         	str	r0, [r1, #0x38]
;                         ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->coreIntrNum;
7009d45e: 9801         	ldr	r0, [sp, #0x4]
7009d460: 6980         	ldr	r0, [r0, #0x18]
7009d462: 6d80         	ldr	r0, [r0, #0x58]
;                     eventPrms->coreIntrNum    =
7009d464: 9905         	ldr	r1, [sp, #0x14]
7009d466: 63c8         	str	r0, [r1, #0x3c]
7009d468: e7ff         	b	0x7009d46a <Udma_eventRegister+0x1ea> @ imm = #-0x2
;                 eventHandleInt->eventPrms.intrStatusReg   = eventPrms->intrStatusReg;
7009d46a: 9805         	ldr	r0, [sp, #0x14]
7009d46c: 6a40         	ldr	r0, [r0, #0x24]
7009d46e: 9901         	ldr	r1, [sp, #0x4]
7009d470: 62c8         	str	r0, [r1, #0x2c]
;                 eventHandleInt->eventPrms.intrClearReg    = eventPrms->intrClearReg;
7009d472: 9805         	ldr	r0, [sp, #0x14]
7009d474: 6a80         	ldr	r0, [r0, #0x28]
7009d476: 9901         	ldr	r1, [sp, #0x4]
7009d478: 6308         	str	r0, [r1, #0x30]
;                 eventHandleInt->eventPrms.intrMask        = eventPrms->intrMask;
7009d47a: 9905         	ldr	r1, [sp, #0x14]
7009d47c: 6b08         	ldr	r0, [r1, #0x30]
7009d47e: 6b4a         	ldr	r2, [r1, #0x34]
7009d480: 9901         	ldr	r1, [sp, #0x4]
7009d482: 63ca         	str	r2, [r1, #0x3c]
7009d484: 6388         	str	r0, [r1, #0x38]
;                 eventHandleInt->eventPrms.vintrNum        = eventPrms->vintrNum;
7009d486: 9805         	ldr	r0, [sp, #0x14]
7009d488: 6b80         	ldr	r0, [r0, #0x38]
7009d48a: 9901         	ldr	r1, [sp, #0x4]
7009d48c: 6408         	str	r0, [r1, #0x40]
;                 eventHandleInt->eventPrms.coreIntrNum     = eventPrms->coreIntrNum;
7009d48e: 9805         	ldr	r0, [sp, #0x14]
7009d490: 6bc0         	ldr	r0, [r0, #0x3c]
7009d492: 9901         	ldr	r1, [sp, #0x4]
7009d494: 6448         	str	r0, [r1, #0x44]
7009d496: e7ff         	b	0x7009d498 <Udma_eventRegister+0x218> @ imm = #-0x2
7009d498: e7ff         	b	0x7009d49a <Udma_eventRegister+0x21a> @ imm = #-0x2
;     }
7009d49a: e7ff         	b	0x7009d49c <Udma_eventRegister+0x21c> @ imm = #-0x2
;     return (retVal);
7009d49c: 9804         	ldr	r0, [sp, #0x10]
7009d49e: b008         	add	sp, #0x20
7009d4a0: bdb0         	pop	{r4, r5, r7, pc}
		...
7009d4ae: 0000         	movs	r0, r0

7009d4b0 <Udma_eventAllocResource>:
; {
7009d4b0: b580         	push	{r7, lr}
7009d4b2: b08a         	sub	sp, #0x28
7009d4b4: 9009         	str	r0, [sp, #0x24]
7009d4b6: 9108         	str	r1, [sp, #0x20]
7009d4b8: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009d4ba: 9007         	str	r0, [sp, #0x1c]
;     eventPrms = &eventHandle->eventPrms;
7009d4bc: 9808         	ldr	r0, [sp, #0x20]
7009d4be: 3008         	adds	r0, #0x8
7009d4c0: 9004         	str	r0, [sp, #0x10]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009d4c2: 9804         	ldr	r0, [sp, #0x10]
7009d4c4: 6800         	ldr	r0, [r0]
7009d4c6: 2805         	cmp	r0, #0x5
7009d4c8: d01b         	beq	0x7009d502 <Udma_eventAllocResource+0x52> @ imm = #0x36
7009d4ca: e7ff         	b	0x7009d4cc <Udma_eventAllocResource+0x1c> @ imm = #-0x2
;         eventHandle->globalEvent = Udma_rmAllocEvent(drvHandle);
7009d4cc: 9809         	ldr	r0, [sp, #0x24]
7009d4ce: f009 fa9f    	bl	0x700a6a10 <Udma_rmAllocEvent> @ imm = #0x953e
7009d4d2: 9908         	ldr	r1, [sp, #0x20]
7009d4d4: 6488         	str	r0, [r1, #0x48]
;         if(UDMA_EVENT_INVALID == eventHandle->globalEvent)
7009d4d6: 9808         	ldr	r0, [sp, #0x20]
7009d4d8: 6c80         	ldr	r0, [r0, #0x48]
7009d4da: f64f 71ff    	movw	r1, #0xffff
7009d4de: 4288         	cmp	r0, r1
7009d4e0: d104         	bne	0x7009d4ec <Udma_eventAllocResource+0x3c> @ imm = #0x8
7009d4e2: e7ff         	b	0x7009d4e4 <Udma_eventAllocResource+0x34> @ imm = #-0x2
7009d4e4: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009d4e8: 9007         	str	r0, [sp, #0x1c]
;         }
7009d4ea: e009         	b	0x7009d500 <Udma_eventAllocResource+0x50> @ imm = #0x12
;                 &drvHandle->iaRegs.pImapRegs->GEVI[eventHandle->globalEvent];
7009d4ec: 9809         	ldr	r0, [sp, #0x24]
7009d4ee: f8d0 00a0    	ldr.w	r0, [r0, #0xa0]
7009d4f2: 9908         	ldr	r1, [sp, #0x20]
7009d4f4: 6c8a         	ldr	r2, [r1, #0x48]
7009d4f6: eb00 00c2    	add.w	r0, r0, r2, lsl #3
;             eventHandle->pIaGeviRegs =
7009d4fa: f8c1 0090    	str.w	r0, [r1, #0x90]
7009d4fe: e7ff         	b	0x7009d500 <Udma_eventAllocResource+0x50> @ imm = #-0x2
;     }
7009d500: e7ff         	b	0x7009d502 <Udma_eventAllocResource+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d502: 9807         	ldr	r0, [sp, #0x1c]
7009d504: bb00         	cbnz	r0, 0x7009d548 <Udma_eventAllocResource+0x98> @ imm = #0x40
7009d506: e7ff         	b	0x7009d508 <Udma_eventAllocResource+0x58> @ imm = #-0x2
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009d508: 9804         	ldr	r0, [sp, #0x10]
7009d50a: 6840         	ldr	r0, [r0, #0x4]
7009d50c: 2801         	cmp	r0, #0x1
7009d50e: d009         	beq	0x7009d524 <Udma_eventAllocResource+0x74> @ imm = #0x12
7009d510: e7ff         	b	0x7009d512 <Udma_eventAllocResource+0x62> @ imm = #-0x2
;             ((UDMA_EVENT_MODE_SHARED == eventPrms->eventMode) &&
7009d512: 9804         	ldr	r0, [sp, #0x10]
7009d514: 6840         	ldr	r0, [r0, #0x4]
7009d516: 2802         	cmp	r0, #0x2
7009d518: d115         	bne	0x7009d546 <Udma_eventAllocResource+0x96> @ imm = #0x2a
7009d51a: e7ff         	b	0x7009d51c <Udma_eventAllocResource+0x6c> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)))
7009d51c: 9804         	ldr	r0, [sp, #0x10]
7009d51e: 6900         	ldr	r0, [r0, #0x10]
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009d520: b988         	cbnz	r0, 0x7009d546 <Udma_eventAllocResource+0x96> @ imm = #0x22
7009d522: e7ff         	b	0x7009d524 <Udma_eventAllocResource+0x74> @ imm = #-0x2
;             eventHandle->vintrNum = Udma_rmAllocVintr(drvHandle);
7009d524: 9809         	ldr	r0, [sp, #0x24]
7009d526: f009 fac3    	bl	0x700a6ab0 <Udma_rmAllocVintr> @ imm = #0x9586
7009d52a: 9908         	ldr	r1, [sp, #0x20]
7009d52c: 64c8         	str	r0, [r1, #0x4c]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrNum)
7009d52e: 9808         	ldr	r0, [sp, #0x20]
7009d530: 6cc0         	ldr	r0, [r0, #0x4c]
7009d532: f64f 71ff    	movw	r1, #0xffff
7009d536: 4288         	cmp	r0, r1
7009d538: d104         	bne	0x7009d544 <Udma_eventAllocResource+0x94> @ imm = #0x8
7009d53a: e7ff         	b	0x7009d53c <Udma_eventAllocResource+0x8c> @ imm = #-0x2
7009d53c: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d540: 9007         	str	r0, [sp, #0x1c]
;             }
7009d542: e7ff         	b	0x7009d544 <Udma_eventAllocResource+0x94> @ imm = #-0x2
;         }
7009d544: e7ff         	b	0x7009d546 <Udma_eventAllocResource+0x96> @ imm = #-0x2
;     }
7009d546: e7ff         	b	0x7009d548 <Udma_eventAllocResource+0x98> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d548: 9807         	ldr	r0, [sp, #0x1c]
7009d54a: b9b8         	cbnz	r0, 0x7009d57c <Udma_eventAllocResource+0xcc> @ imm = #0x2e
7009d54c: e7ff         	b	0x7009d54e <Udma_eventAllocResource+0x9e> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009d54e: 9804         	ldr	r0, [sp, #0x10]
7009d550: 6800         	ldr	r0, [r0]
7009d552: 2805         	cmp	r0, #0x5
7009d554: d011         	beq	0x7009d57a <Udma_eventAllocResource+0xca> @ imm = #0x22
7009d556: e7ff         	b	0x7009d558 <Udma_eventAllocResource+0xa8> @ imm = #-0x2
;             eventHandle->vintrBitNum = Udma_rmAllocVintrBit(eventHandle);
7009d558: 9808         	ldr	r0, [sp, #0x20]
7009d55a: f007 fa79    	bl	0x700a4a50 <Udma_rmAllocVintrBit> @ imm = #0x74f2
7009d55e: 9908         	ldr	r1, [sp, #0x20]
7009d560: 6508         	str	r0, [r1, #0x50]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrBitNum)
7009d562: 9808         	ldr	r0, [sp, #0x20]
7009d564: 6d00         	ldr	r0, [r0, #0x50]
7009d566: f64f 71ff    	movw	r1, #0xffff
7009d56a: 4288         	cmp	r0, r1
7009d56c: d104         	bne	0x7009d578 <Udma_eventAllocResource+0xc8> @ imm = #0x8
7009d56e: e7ff         	b	0x7009d570 <Udma_eventAllocResource+0xc0> @ imm = #-0x2
7009d570: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d574: 9007         	str	r0, [sp, #0x1c]
;             }
7009d576: e7ff         	b	0x7009d578 <Udma_eventAllocResource+0xc8> @ imm = #-0x2
;         }
7009d578: e7ff         	b	0x7009d57a <Udma_eventAllocResource+0xca> @ imm = #-0x2
;     }
7009d57a: e7ff         	b	0x7009d57c <Udma_eventAllocResource+0xcc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d57c: 9807         	ldr	r0, [sp, #0x1c]
7009d57e: 2800         	cmp	r0, #0x0
7009d580: d146         	bne	0x7009d610 <Udma_eventAllocResource+0x160> @ imm = #0x8c
7009d582: e7ff         	b	0x7009d584 <Udma_eventAllocResource+0xd4> @ imm = #-0x2
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009d584: 9804         	ldr	r0, [sp, #0x10]
7009d586: 6940         	ldr	r0, [r0, #0x14]
7009d588: b120         	cbz	r0, 0x7009d594 <Udma_eventAllocResource+0xe4> @ imm = #0x8
7009d58a: e7ff         	b	0x7009d58c <Udma_eventAllocResource+0xdc> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)) ||
7009d58c: 9804         	ldr	r0, [sp, #0x10]
7009d58e: 6900         	ldr	r0, [r0, #0x10]
7009d590: b128         	cbz	r0, 0x7009d59e <Udma_eventAllocResource+0xee> @ imm = #0xa
7009d592: e7ff         	b	0x7009d594 <Udma_eventAllocResource+0xe4> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009d594: 9804         	ldr	r0, [sp, #0x10]
7009d596: 6800         	ldr	r0, [r0]
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009d598: 2805         	cmp	r0, #0x5
7009d59a: d138         	bne	0x7009d60e <Udma_eventAllocResource+0x15e> @ imm = #0x70
7009d59c: e7ff         	b	0x7009d59e <Udma_eventAllocResource+0xee> @ imm = #-0x2
;             if(UDMA_CORE_INTR_ANY != eventPrms->preferredCoreIntrNum)
7009d59e: 9804         	ldr	r0, [sp, #0x10]
7009d5a0: 6a00         	ldr	r0, [r0, #0x20]
7009d5a2: 2101         	movs	r1, #0x1
7009d5a4: f6cf 71ff    	movt	r1, #0xffff
7009d5a8: 4288         	cmp	r0, r1
7009d5aa: d007         	beq	0x7009d5bc <Udma_eventAllocResource+0x10c> @ imm = #0xe
7009d5ac: e7ff         	b	0x7009d5ae <Udma_eventAllocResource+0xfe> @ imm = #-0x2
;                 preferredIrIntrNum = Udma_rmTranslateCoreIntrInput(drvHandle, eventPrms->preferredCoreIntrNum);
7009d5ae: 9809         	ldr	r0, [sp, #0x24]
7009d5b0: 9904         	ldr	r1, [sp, #0x10]
7009d5b2: 6a09         	ldr	r1, [r1, #0x20]
7009d5b4: f00f fd64    	bl	0x700ad080 <Udma_rmTranslateCoreIntrInput> @ imm = #0xfac8
7009d5b8: 9005         	str	r0, [sp, #0x14]
;             }
7009d5ba: e003         	b	0x7009d5c4 <Udma_eventAllocResource+0x114> @ imm = #0x6
;                 preferredIrIntrNum = eventPrms->preferredCoreIntrNum;
7009d5bc: 9804         	ldr	r0, [sp, #0x10]
7009d5be: 6a00         	ldr	r0, [r0, #0x20]
7009d5c0: 9005         	str	r0, [sp, #0x14]
7009d5c2: e7ff         	b	0x7009d5c4 <Udma_eventAllocResource+0x114> @ imm = #-0x2
;             if(UDMA_INTR_INVALID != preferredIrIntrNum)
7009d5c4: 9805         	ldr	r0, [sp, #0x14]
7009d5c6: f510 3f80    	cmn.w	r0, #0x10000
7009d5ca: d015         	beq	0x7009d5f8 <Udma_eventAllocResource+0x148> @ imm = #0x2a
7009d5cc: e7ff         	b	0x7009d5ce <Udma_eventAllocResource+0x11e> @ imm = #-0x2
;                     Udma_rmAllocIrIntr(preferredIrIntrNum, drvHandle);
7009d5ce: 9805         	ldr	r0, [sp, #0x14]
7009d5d0: 9909         	ldr	r1, [sp, #0x24]
7009d5d2: f003 ff45    	bl	0x700a1460 <Udma_rmAllocIrIntr> @ imm = #0x3e8a
;                 eventHandle->irIntrNum =
7009d5d6: 9908         	ldr	r1, [sp, #0x20]
7009d5d8: 6548         	str	r0, [r1, #0x54]
;                 if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
7009d5da: 9808         	ldr	r0, [sp, #0x20]
7009d5dc: 6d40         	ldr	r0, [r0, #0x54]
7009d5de: f510 3f80    	cmn.w	r0, #0x10000
7009d5e2: d008         	beq	0x7009d5f6 <Udma_eventAllocResource+0x146> @ imm = #0x10
7009d5e4: e7ff         	b	0x7009d5e6 <Udma_eventAllocResource+0x136> @ imm = #-0x2
;                     eventHandle->coreIntrNum = Udma_rmTranslateIrOutput(drvHandle, eventHandle->irIntrNum);
7009d5e6: 9809         	ldr	r0, [sp, #0x24]
7009d5e8: 9908         	ldr	r1, [sp, #0x20]
7009d5ea: 6d49         	ldr	r1, [r1, #0x54]
7009d5ec: f00f fd60    	bl	0x700ad0b0 <Udma_rmTranslateIrOutput> @ imm = #0xfac0
7009d5f0: 9908         	ldr	r1, [sp, #0x20]
7009d5f2: 6588         	str	r0, [r1, #0x58]
;                 }
7009d5f4: e7ff         	b	0x7009d5f6 <Udma_eventAllocResource+0x146> @ imm = #-0x2
;             }
7009d5f6: e7ff         	b	0x7009d5f8 <Udma_eventAllocResource+0x148> @ imm = #-0x2
;             if(UDMA_INTR_INVALID == eventHandle->coreIntrNum)
7009d5f8: 9808         	ldr	r0, [sp, #0x20]
7009d5fa: 6d80         	ldr	r0, [r0, #0x58]
7009d5fc: f510 3f80    	cmn.w	r0, #0x10000
7009d600: d104         	bne	0x7009d60c <Udma_eventAllocResource+0x15c> @ imm = #0x8
7009d602: e7ff         	b	0x7009d604 <Udma_eventAllocResource+0x154> @ imm = #-0x2
7009d604: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d608: 9007         	str	r0, [sp, #0x1c]
;             }
7009d60a: e7ff         	b	0x7009d60c <Udma_eventAllocResource+0x15c> @ imm = #-0x2
;         }
7009d60c: e7ff         	b	0x7009d60e <Udma_eventAllocResource+0x15e> @ imm = #-0x2
;     }
7009d60e: e7ff         	b	0x7009d610 <Udma_eventAllocResource+0x160> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d610: 9807         	ldr	r0, [sp, #0x1c]
7009d612: bb18         	cbnz	r0, 0x7009d65c <Udma_eventAllocResource+0x1ac> @ imm = #0x46
7009d614: e7ff         	b	0x7009d616 <Udma_eventAllocResource+0x166> @ imm = #-0x2
;         cookie = HwiP_disable();
7009d616: f011 e82c    	blx	0x700ae670 <HwiP_disable> @ imm = #0x11058
7009d61a: 9002         	str	r0, [sp, #0x8]
;         eventHandle->prevEvent = (Udma_EventHandleInt) NULL_PTR;
7009d61c: 9908         	ldr	r1, [sp, #0x20]
7009d61e: 2000         	movs	r0, #0x0
7009d620: 6608         	str	r0, [r1, #0x60]
;         eventHandle->nextEvent = (Udma_EventHandleInt) NULL_PTR;
7009d622: 9908         	ldr	r1, [sp, #0x20]
7009d624: 65c8         	str	r0, [r1, #0x5c]
;         if(NULL_PTR != eventPrms->controllerEventHandle)
7009d626: 9804         	ldr	r0, [sp, #0x10]
7009d628: 6900         	ldr	r0, [r0, #0x10]
7009d62a: b198         	cbz	r0, 0x7009d654 <Udma_eventAllocResource+0x1a4> @ imm = #0x26
7009d62c: e7ff         	b	0x7009d62e <Udma_eventAllocResource+0x17e> @ imm = #-0x2
;             lastEvent = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
7009d62e: 9804         	ldr	r0, [sp, #0x10]
7009d630: 6900         	ldr	r0, [r0, #0x10]
7009d632: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009d634: e7ff         	b	0x7009d636 <Udma_eventAllocResource+0x186> @ imm = #-0x2
7009d636: 9803         	ldr	r0, [sp, #0xc]
7009d638: 6dc0         	ldr	r0, [r0, #0x5c]
7009d63a: b120         	cbz	r0, 0x7009d646 <Udma_eventAllocResource+0x196> @ imm = #0x8
7009d63c: e7ff         	b	0x7009d63e <Udma_eventAllocResource+0x18e> @ imm = #-0x2
;                 lastEvent = lastEvent->nextEvent;
7009d63e: 9803         	ldr	r0, [sp, #0xc]
7009d640: 6dc0         	ldr	r0, [r0, #0x5c]
7009d642: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009d644: e7f7         	b	0x7009d636 <Udma_eventAllocResource+0x186> @ imm = #-0x12
;             eventHandle->prevEvent = lastEvent;
7009d646: 9803         	ldr	r0, [sp, #0xc]
7009d648: 9908         	ldr	r1, [sp, #0x20]
7009d64a: 6608         	str	r0, [r1, #0x60]
;             lastEvent->nextEvent   = eventHandle;
7009d64c: 9808         	ldr	r0, [sp, #0x20]
7009d64e: 9903         	ldr	r1, [sp, #0xc]
7009d650: 65c8         	str	r0, [r1, #0x5c]
;         }
7009d652: e7ff         	b	0x7009d654 <Udma_eventAllocResource+0x1a4> @ imm = #-0x2
;         HwiP_restore(cookie);
7009d654: 9802         	ldr	r0, [sp, #0x8]
7009d656: f011 e82c    	blx	0x700ae6b0 <HwiP_restore> @ imm = #0x11058
;     }
7009d65a: e7ff         	b	0x7009d65c <Udma_eventAllocResource+0x1ac> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d65c: 9807         	ldr	r0, [sp, #0x1c]
7009d65e: b9a0         	cbnz	r0, 0x7009d68a <Udma_eventAllocResource+0x1da> @ imm = #0x28
7009d660: e7ff         	b	0x7009d662 <Udma_eventAllocResource+0x1b2> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009d662: 9804         	ldr	r0, [sp, #0x10]
7009d664: 6800         	ldr	r0, [r0]
7009d666: 2803         	cmp	r0, #0x3
7009d668: d10e         	bne	0x7009d688 <Udma_eventAllocResource+0x1d8> @ imm = #0x1c
7009d66a: e7ff         	b	0x7009d66c <Udma_eventAllocResource+0x1bc> @ imm = #-0x2
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009d66c: 9804         	ldr	r0, [sp, #0x10]
7009d66e: 6880         	ldr	r0, [r0, #0x8]
7009d670: 9001         	str	r0, [sp, #0x4]
;             if(TRUE == chHandle->chOesAllocDone)
7009d672: 9801         	ldr	r0, [sp, #0x4]
7009d674: f8d0 0248    	ldr.w	r0, [r0, #0x248]
7009d678: 2801         	cmp	r0, #0x1
7009d67a: d104         	bne	0x7009d686 <Udma_eventAllocResource+0x1d6> @ imm = #0x8
7009d67c: e7ff         	b	0x7009d67e <Udma_eventAllocResource+0x1ce> @ imm = #-0x2
7009d67e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d682: 9007         	str	r0, [sp, #0x1c]
;             }
7009d684: e7ff         	b	0x7009d686 <Udma_eventAllocResource+0x1d6> @ imm = #-0x2
;         }
7009d686: e7ff         	b	0x7009d688 <Udma_eventAllocResource+0x1d8> @ imm = #-0x2
;     }
7009d688: e7ff         	b	0x7009d68a <Udma_eventAllocResource+0x1da> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009d68a: 9807         	ldr	r0, [sp, #0x1c]
7009d68c: b128         	cbz	r0, 0x7009d69a <Udma_eventAllocResource+0x1ea> @ imm = #0xa
7009d68e: e7ff         	b	0x7009d690 <Udma_eventAllocResource+0x1e0> @ imm = #-0x2
;         Udma_eventFreeResource(drvHandle, eventHandle);
7009d690: 9809         	ldr	r0, [sp, #0x24]
7009d692: 9908         	ldr	r1, [sp, #0x20]
7009d694: f006 fc14    	bl	0x700a3ec0 <Udma_eventFreeResource> @ imm = #0x6828
;     }
7009d698: e016         	b	0x7009d6c8 <Udma_eventAllocResource+0x218> @ imm = #0x2c
;         if(NULL_PTR == eventPrms->controllerEventHandle)
7009d69a: 9804         	ldr	r0, [sp, #0x10]
7009d69c: 6900         	ldr	r0, [r0, #0x10]
7009d69e: b920         	cbnz	r0, 0x7009d6aa <Udma_eventAllocResource+0x1fa> @ imm = #0x8
7009d6a0: e7ff         	b	0x7009d6a2 <Udma_eventAllocResource+0x1f2> @ imm = #-0x2
;             vintrNum = eventHandle->vintrNum;
7009d6a2: 9808         	ldr	r0, [sp, #0x20]
7009d6a4: 6cc0         	ldr	r0, [r0, #0x4c]
7009d6a6: 9006         	str	r0, [sp, #0x18]
;         }
7009d6a8: e004         	b	0x7009d6b4 <Udma_eventAllocResource+0x204> @ imm = #0x8
;             vintrNum = ((Udma_EventHandleInt) (eventPrms->controllerEventHandle))->vintrNum;
7009d6aa: 9804         	ldr	r0, [sp, #0x10]
7009d6ac: 6900         	ldr	r0, [r0, #0x10]
7009d6ae: 6cc0         	ldr	r0, [r0, #0x4c]
7009d6b0: 9006         	str	r0, [sp, #0x18]
7009d6b2: e7ff         	b	0x7009d6b4 <Udma_eventAllocResource+0x204> @ imm = #-0x2
;         eventHandle->pIaVintrRegs = &drvHandle->iaRegs.pIntrRegs->VINT[vintrNum];
7009d6b4: 9809         	ldr	r0, [sp, #0x24]
7009d6b6: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
7009d6ba: 9906         	ldr	r1, [sp, #0x18]
7009d6bc: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009d6c0: 9908         	ldr	r1, [sp, #0x20]
7009d6c2: f8c1 0094    	str.w	r0, [r1, #0x94]
7009d6c6: e7ff         	b	0x7009d6c8 <Udma_eventAllocResource+0x218> @ imm = #-0x2
;     return (retVal);
7009d6c8: 9807         	ldr	r0, [sp, #0x1c]
7009d6ca: b00a         	add	sp, #0x28
7009d6cc: bd80         	pop	{r7, pc}
7009d6ce: 0000         	movs	r0, r0

7009d6d0 <Udma_chFreeResource>:
; {
7009d6d0: b580         	push	{r7, lr}
7009d6d2: b084         	sub	sp, #0x10
7009d6d4: 9003         	str	r0, [sp, #0xc]
7009d6d6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d6d8: 9002         	str	r0, [sp, #0x8]
;     drvHandle = chHandle->drvHandle;
7009d6da: 9803         	ldr	r0, [sp, #0xc]
7009d6dc: 6e80         	ldr	r0, [r0, #0x68]
7009d6de: 9001         	str	r0, [sp, #0x4]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009d6e0: 9803         	ldr	r0, [sp, #0xc]
7009d6e2: 7800         	ldrb	r0, [r0]
7009d6e4: 0740         	lsls	r0, r0, #0x1d
7009d6e6: 2800         	cmp	r0, #0x0
7009d6e8: d52e         	bpl	0x7009d748 <Udma_chFreeResource+0x78> @ imm = #0x5c
7009d6ea: e7ff         	b	0x7009d6ec <Udma_chFreeResource+0x1c> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009d6ec: 9803         	ldr	r0, [sp, #0xc]
7009d6ee: 6ec0         	ldr	r0, [r0, #0x6c]
7009d6f0: f510 3f80    	cmn.w	r0, #0x10000
7009d6f4: d027         	beq	0x7009d746 <Udma_chFreeResource+0x76> @ imm = #0x4e
7009d6f6: e7ff         	b	0x7009d6f8 <Udma_chFreeResource+0x28> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009d6f8: 9803         	ldr	r0, [sp, #0xc]
7009d6fa: 7800         	ldrb	r0, [r0]
7009d6fc: 0640         	lsls	r0, r0, #0x19
7009d6fe: 2800         	cmp	r0, #0x0
7009d700: d506         	bpl	0x7009d710 <Udma_chFreeResource+0x40> @ imm = #0xc
7009d702: e7ff         	b	0x7009d704 <Udma_chFreeResource+0x34> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyHcCh(chHandle->txChNum, drvHandle);
7009d704: 9803         	ldr	r0, [sp, #0xc]
7009d706: 6ec0         	ldr	r0, [r0, #0x6c]
7009d708: 9901         	ldr	r1, [sp, #0x4]
7009d70a: f00c fbf1    	bl	0x700a9ef0 <Udma_rmFreeBlkCopyHcCh> @ imm = #0xc7e2
;             }
7009d70e: e012         	b	0x7009d736 <Udma_chFreeResource+0x66> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009d710: 9803         	ldr	r0, [sp, #0xc]
7009d712: 7800         	ldrb	r0, [r0]
7009d714: 0600         	lsls	r0, r0, #0x18
7009d716: 2800         	cmp	r0, #0x0
7009d718: d506         	bpl	0x7009d728 <Udma_chFreeResource+0x58> @ imm = #0xc
7009d71a: e7ff         	b	0x7009d71c <Udma_chFreeResource+0x4c> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyUhcCh(chHandle->txChNum, drvHandle);
7009d71c: 9803         	ldr	r0, [sp, #0xc]
7009d71e: 6ec0         	ldr	r0, [r0, #0x6c]
7009d720: 9901         	ldr	r1, [sp, #0x4]
7009d722: f00c fc1d    	bl	0x700a9f60 <Udma_rmFreeBlkCopyUhcCh> @ imm = #0xc83a
;             }
7009d726: e005         	b	0x7009d734 <Udma_chFreeResource+0x64> @ imm = #0xa
;                 Udma_rmFreeBlkCopyCh(chHandle->txChNum, drvHandle);
7009d728: 9803         	ldr	r0, [sp, #0xc]
7009d72a: 6ec0         	ldr	r0, [r0, #0x6c]
7009d72c: 9901         	ldr	r1, [sp, #0x4]
7009d72e: f00c fba7    	bl	0x700a9e80 <Udma_rmFreeBlkCopyCh> @ imm = #0xc74e
7009d732: e7ff         	b	0x7009d734 <Udma_chFreeResource+0x64> @ imm = #-0x2
7009d734: e7ff         	b	0x7009d736 <Udma_chFreeResource+0x66> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009d736: 9903         	ldr	r1, [sp, #0xc]
7009d738: 2000         	movs	r0, #0x0
7009d73a: f6cf 70ff    	movt	r0, #0xffff
7009d73e: 66c8         	str	r0, [r1, #0x6c]
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009d740: 9903         	ldr	r1, [sp, #0xc]
7009d742: 6708         	str	r0, [r1, #0x70]
;         }
7009d744: e7ff         	b	0x7009d746 <Udma_chFreeResource+0x76> @ imm = #-0x2
;     }
7009d746: e084         	b	0x7009d852 <Udma_chFreeResource+0x182> @ imm = #0x108
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009d748: 9803         	ldr	r0, [sp, #0xc]
7009d74a: 6ec0         	ldr	r0, [r0, #0x6c]
7009d74c: f510 3f80    	cmn.w	r0, #0x10000
7009d750: d032         	beq	0x7009d7b8 <Udma_chFreeResource+0xe8> @ imm = #0x64
7009d752: e7ff         	b	0x7009d754 <Udma_chFreeResource+0x84> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009d754: 9803         	ldr	r0, [sp, #0xc]
7009d756: 7800         	ldrb	r0, [r0]
7009d758: 0640         	lsls	r0, r0, #0x19
7009d75a: 2800         	cmp	r0, #0x0
7009d75c: d506         	bpl	0x7009d76c <Udma_chFreeResource+0x9c> @ imm = #0xc
7009d75e: e7ff         	b	0x7009d760 <Udma_chFreeResource+0x90> @ imm = #-0x2
;                 Udma_rmFreeTxHcCh(chHandle->txChNum, drvHandle);
7009d760: 9803         	ldr	r0, [sp, #0xc]
7009d762: 6ec0         	ldr	r0, [r0, #0x6c]
7009d764: 9901         	ldr	r1, [sp, #0x4]
7009d766: f00c fd13    	bl	0x700aa190 <Udma_rmFreeTxHcCh> @ imm = #0xca26
;             }
7009d76a: e01f         	b	0x7009d7ac <Udma_chFreeResource+0xdc> @ imm = #0x3e
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009d76c: 9803         	ldr	r0, [sp, #0xc]
7009d76e: 7840         	ldrb	r0, [r0, #0x1]
7009d770: 07c0         	lsls	r0, r0, #0x1f
7009d772: b138         	cbz	r0, 0x7009d784 <Udma_chFreeResource+0xb4> @ imm = #0xe
7009d774: e7ff         	b	0x7009d776 <Udma_chFreeResource+0xa6> @ imm = #-0x2
;                 Udma_rmFreeMappedTxCh(chHandle->txChNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009d776: 9803         	ldr	r0, [sp, #0xc]
7009d778: 68c2         	ldr	r2, [r0, #0xc]
7009d77a: 6ec0         	ldr	r0, [r0, #0x6c]
7009d77c: 9901         	ldr	r1, [sp, #0x4]
7009d77e: f00b fe77    	bl	0x700a9470 <Udma_rmFreeMappedTxCh> @ imm = #0xbcee
;             }
7009d782: e012         	b	0x7009d7aa <Udma_chFreeResource+0xda> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009d784: 9803         	ldr	r0, [sp, #0xc]
7009d786: 7800         	ldrb	r0, [r0]
7009d788: 0600         	lsls	r0, r0, #0x18
7009d78a: 2800         	cmp	r0, #0x0
7009d78c: d506         	bpl	0x7009d79c <Udma_chFreeResource+0xcc> @ imm = #0xc
7009d78e: e7ff         	b	0x7009d790 <Udma_chFreeResource+0xc0> @ imm = #-0x2
;                 Udma_rmFreeTxUhcCh(chHandle->txChNum, drvHandle);
7009d790: 9803         	ldr	r0, [sp, #0xc]
7009d792: 6ec0         	ldr	r0, [r0, #0x6c]
7009d794: 9901         	ldr	r1, [sp, #0x4]
7009d796: f00c fd33    	bl	0x700aa200 <Udma_rmFreeTxUhcCh> @ imm = #0xca66
;             }
7009d79a: e005         	b	0x7009d7a8 <Udma_chFreeResource+0xd8> @ imm = #0xa
;                 Udma_rmFreeTxCh(chHandle->txChNum, drvHandle);
7009d79c: 9803         	ldr	r0, [sp, #0xc]
7009d79e: 6ec0         	ldr	r0, [r0, #0x6c]
7009d7a0: 9901         	ldr	r1, [sp, #0x4]
7009d7a2: f00c fcbd    	bl	0x700aa120 <Udma_rmFreeTxCh> @ imm = #0xc97a
7009d7a6: e7ff         	b	0x7009d7a8 <Udma_chFreeResource+0xd8> @ imm = #-0x2
7009d7a8: e7ff         	b	0x7009d7aa <Udma_chFreeResource+0xda> @ imm = #-0x2
7009d7aa: e7ff         	b	0x7009d7ac <Udma_chFreeResource+0xdc> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009d7ac: 9903         	ldr	r1, [sp, #0xc]
7009d7ae: 2000         	movs	r0, #0x0
7009d7b0: f6cf 70ff    	movt	r0, #0xffff
7009d7b4: 66c8         	str	r0, [r1, #0x6c]
;         }
7009d7b6: e7ff         	b	0x7009d7b8 <Udma_chFreeResource+0xe8> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->rxChNum)
7009d7b8: 9803         	ldr	r0, [sp, #0xc]
7009d7ba: 6f00         	ldr	r0, [r0, #0x70]
7009d7bc: f510 3f80    	cmn.w	r0, #0x10000
7009d7c0: d033         	beq	0x7009d82a <Udma_chFreeResource+0x15a> @ imm = #0x66
7009d7c2: e7ff         	b	0x7009d7c4 <Udma_chFreeResource+0xf4> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009d7c4: 9803         	ldr	r0, [sp, #0xc]
7009d7c6: 7800         	ldrb	r0, [r0]
7009d7c8: 0640         	lsls	r0, r0, #0x19
7009d7ca: 2800         	cmp	r0, #0x0
7009d7cc: d506         	bpl	0x7009d7dc <Udma_chFreeResource+0x10c> @ imm = #0xc
7009d7ce: e7ff         	b	0x7009d7d0 <Udma_chFreeResource+0x100> @ imm = #-0x2
;                 Udma_rmFreeRxHcCh(chHandle->rxChNum, drvHandle);
7009d7d0: 9803         	ldr	r0, [sp, #0xc]
7009d7d2: 6f00         	ldr	r0, [r0, #0x70]
7009d7d4: 9901         	ldr	r1, [sp, #0x4]
7009d7d6: f00c fc33    	bl	0x700aa040 <Udma_rmFreeRxHcCh> @ imm = #0xc866
;             }
7009d7da: e020         	b	0x7009d81e <Udma_chFreeResource+0x14e> @ imm = #0x40
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009d7dc: 9803         	ldr	r0, [sp, #0xc]
7009d7de: 7840         	ldrb	r0, [r0, #0x1]
7009d7e0: 07c0         	lsls	r0, r0, #0x1f
7009d7e2: b140         	cbz	r0, 0x7009d7f6 <Udma_chFreeResource+0x126> @ imm = #0x10
7009d7e4: e7ff         	b	0x7009d7e6 <Udma_chFreeResource+0x116> @ imm = #-0x2
;                 Udma_rmFreeMappedRxCh(chHandle->rxChNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009d7e6: 9803         	ldr	r0, [sp, #0xc]
7009d7e8: 68c2         	ldr	r2, [r0, #0xc]
7009d7ea: 6f00         	ldr	r0, [r0, #0x70]
7009d7ec: 9901         	ldr	r1, [sp, #0x4]
7009d7ee: 3a04         	subs	r2, #0x4
7009d7f0: f00b fe06    	bl	0x700a9400 <Udma_rmFreeMappedRxCh> @ imm = #0xbc0c
;             }
7009d7f4: e012         	b	0x7009d81c <Udma_chFreeResource+0x14c> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009d7f6: 9803         	ldr	r0, [sp, #0xc]
7009d7f8: 7800         	ldrb	r0, [r0]
7009d7fa: 0600         	lsls	r0, r0, #0x18
7009d7fc: 2800         	cmp	r0, #0x0
7009d7fe: d506         	bpl	0x7009d80e <Udma_chFreeResource+0x13e> @ imm = #0xc
7009d800: e7ff         	b	0x7009d802 <Udma_chFreeResource+0x132> @ imm = #-0x2
;                 Udma_rmFreeRxUhcCh(chHandle->rxChNum, drvHandle);
7009d802: 9803         	ldr	r0, [sp, #0xc]
7009d804: 6f00         	ldr	r0, [r0, #0x70]
7009d806: 9901         	ldr	r1, [sp, #0x4]
7009d808: f00c fc52    	bl	0x700aa0b0 <Udma_rmFreeRxUhcCh> @ imm = #0xc8a4
;             }
7009d80c: e005         	b	0x7009d81a <Udma_chFreeResource+0x14a> @ imm = #0xa
;                 Udma_rmFreeRxCh(chHandle->rxChNum, drvHandle);
7009d80e: 9803         	ldr	r0, [sp, #0xc]
7009d810: 6f00         	ldr	r0, [r0, #0x70]
7009d812: 9901         	ldr	r1, [sp, #0x4]
7009d814: f00c fbdc    	bl	0x700a9fd0 <Udma_rmFreeRxCh> @ imm = #0xc7b8
7009d818: e7ff         	b	0x7009d81a <Udma_chFreeResource+0x14a> @ imm = #-0x2
7009d81a: e7ff         	b	0x7009d81c <Udma_chFreeResource+0x14c> @ imm = #-0x2
7009d81c: e7ff         	b	0x7009d81e <Udma_chFreeResource+0x14e> @ imm = #-0x2
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009d81e: 9903         	ldr	r1, [sp, #0xc]
7009d820: 2000         	movs	r0, #0x0
7009d822: f6cf 70ff    	movt	r0, #0xffff
7009d826: 6708         	str	r0, [r1, #0x70]
;         }
7009d828: e7ff         	b	0x7009d82a <Udma_chFreeResource+0x15a> @ imm = #-0x2
;         chHandle->defaultFlowObj.drvHandle    = (Udma_DrvHandleInt) NULL_PTR;
7009d82a: 9903         	ldr	r1, [sp, #0xc]
7009d82c: 2000         	movs	r0, #0x0
7009d82e: f8c1 01cc    	str.w	r0, [r1, #0x1cc]
;         chHandle->defaultFlowObj.flowStart    = UDMA_FLOW_INVALID;
7009d832: 9a03         	ldr	r2, [sp, #0xc]
7009d834: 2100         	movs	r1, #0x0
7009d836: f6cf 71ff    	movt	r1, #0xffff
7009d83a: f8c2 11d0    	str.w	r1, [r2, #0x1d0]
;         chHandle->defaultFlowObj.flowCnt      = 0U;
7009d83e: 9903         	ldr	r1, [sp, #0xc]
7009d840: f8c1 01d4    	str.w	r0, [r1, #0x1d4]
;         chHandle->defaultFlowObj.flowInitDone = UDMA_DEINIT_DONE;
7009d844: 9903         	ldr	r1, [sp, #0xc]
7009d846: f8c1 01d8    	str.w	r0, [r1, #0x1d8]
;         chHandle->defaultFlow                 = (Udma_FlowHandleInt) NULL_PTR;
7009d84a: 9903         	ldr	r1, [sp, #0xc]
7009d84c: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
7009d850: e7ff         	b	0x7009d852 <Udma_chFreeResource+0x182> @ imm = #-0x2
;     chHandle->pdmaChNum = UDMA_DMA_CH_INVALID;
7009d852: 9903         	ldr	r1, [sp, #0xc]
7009d854: 2000         	movs	r0, #0x0
7009d856: f6cf 70ff    	movt	r0, #0xffff
7009d85a: 6788         	str	r0, [r1, #0x78]
;     chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009d85c: 9903         	ldr	r1, [sp, #0xc]
7009d85e: 2004         	movs	r0, #0x4
7009d860: f6cf 70ff    	movt	r0, #0xffff
7009d864: 67c8         	str	r0, [r1, #0x7c]
;     if(NULL_PTR != chHandle->fqRing)
7009d866: 9803         	ldr	r0, [sp, #0xc]
7009d868: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009d86c: b190         	cbz	r0, 0x7009d894 <Udma_chFreeResource+0x1c4> @ imm = #0x24
7009d86e: e7ff         	b	0x7009d870 <Udma_chFreeResource+0x1a0> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->fqRing);
7009d870: 9803         	ldr	r0, [sp, #0xc]
7009d872: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009d876: f007 fbc3    	bl	0x700a5000 <Udma_ringFree> @ imm = #0x7786
7009d87a: 4601         	mov	r1, r0
7009d87c: 9802         	ldr	r0, [sp, #0x8]
7009d87e: 4408         	add	r0, r1
7009d880: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009d882: 9802         	ldr	r0, [sp, #0x8]
7009d884: b108         	cbz	r0, 0x7009d88a <Udma_chFreeResource+0x1ba> @ imm = #0x2
7009d886: e7ff         	b	0x7009d888 <Udma_chFreeResource+0x1b8> @ imm = #-0x2
;         }
7009d888: e7ff         	b	0x7009d88a <Udma_chFreeResource+0x1ba> @ imm = #-0x2
;         chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009d88a: 9903         	ldr	r1, [sp, #0xc]
7009d88c: 2000         	movs	r0, #0x0
7009d88e: f8c1 0080    	str.w	r0, [r1, #0x80]
;     }
7009d892: e7ff         	b	0x7009d894 <Udma_chFreeResource+0x1c4> @ imm = #-0x2
;     if(NULL_PTR != chHandle->cqRing)
7009d894: 9803         	ldr	r0, [sp, #0xc]
7009d896: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009d89a: b128         	cbz	r0, 0x7009d8a8 <Udma_chFreeResource+0x1d8> @ imm = #0xa
7009d89c: e7ff         	b	0x7009d89e <Udma_chFreeResource+0x1ce> @ imm = #-0x2
;         chHandle->cqRing = (Udma_RingHandleInt) NULL_PTR;
7009d89e: 9903         	ldr	r1, [sp, #0xc]
7009d8a0: 2000         	movs	r0, #0x0
7009d8a2: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009d8a6: e7ff         	b	0x7009d8a8 <Udma_chFreeResource+0x1d8> @ imm = #-0x2
;     if(NULL_PTR != chHandle->tdCqRing)
7009d8a8: 9803         	ldr	r0, [sp, #0xc]
7009d8aa: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009d8ae: b190         	cbz	r0, 0x7009d8d6 <Udma_chFreeResource+0x206> @ imm = #0x24
7009d8b0: e7ff         	b	0x7009d8b2 <Udma_chFreeResource+0x1e2> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->tdCqRing);
7009d8b2: 9803         	ldr	r0, [sp, #0xc]
7009d8b4: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009d8b8: f007 fba2    	bl	0x700a5000 <Udma_ringFree> @ imm = #0x7744
7009d8bc: 4601         	mov	r1, r0
7009d8be: 9802         	ldr	r0, [sp, #0x8]
7009d8c0: 4408         	add	r0, r1
7009d8c2: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009d8c4: 9802         	ldr	r0, [sp, #0x8]
7009d8c6: b108         	cbz	r0, 0x7009d8cc <Udma_chFreeResource+0x1fc> @ imm = #0x2
7009d8c8: e7ff         	b	0x7009d8ca <Udma_chFreeResource+0x1fa> @ imm = #-0x2
;         }
7009d8ca: e7ff         	b	0x7009d8cc <Udma_chFreeResource+0x1fc> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009d8cc: 9903         	ldr	r1, [sp, #0xc]
7009d8ce: 2000         	movs	r0, #0x0
7009d8d0: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009d8d4: e7ff         	b	0x7009d8d6 <Udma_chFreeResource+0x206> @ imm = #-0x2
;     return (retVal);
7009d8d6: 9802         	ldr	r0, [sp, #0x8]
7009d8d8: b004         	add	sp, #0x10
7009d8da: bd80         	pop	{r7, pc}
7009d8dc: 0000         	movs	r0, r0
7009d8de: 0000         	movs	r0, r0

7009d8e0 <Udma_ringAlloc>:
; {
7009d8e0: b580         	push	{r7, lr}
7009d8e2: b096         	sub	sp, #0x58
7009d8e4: 9015         	str	r0, [sp, #0x54]
7009d8e6: 9114         	str	r1, [sp, #0x50]
7009d8e8: f8ad 204e    	strh.w	r2, [sp, #0x4e]
7009d8ec: 9312         	str	r3, [sp, #0x48]
7009d8ee: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d8f0: 9011         	str	r0, [sp, #0x44]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009d8f2: 900d         	str	r0, [sp, #0x34]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009d8f4: 9815         	ldr	r0, [sp, #0x54]
7009d8f6: 900c         	str	r0, [sp, #0x30]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
7009d8f8: 9814         	ldr	r0, [sp, #0x50]
7009d8fa: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == drvHandleInt) ||
7009d8fc: 980c         	ldr	r0, [sp, #0x30]
7009d8fe: b130         	cbz	r0, 0x7009d90e <Udma_ringAlloc+0x2e> @ imm = #0xc
7009d900: e7ff         	b	0x7009d902 <Udma_ringAlloc+0x22> @ imm = #-0x2
;        (NULL_PTR == ringHandleInt) ||
7009d902: 980b         	ldr	r0, [sp, #0x2c]
7009d904: b118         	cbz	r0, 0x7009d90e <Udma_ringAlloc+0x2e> @ imm = #0x6
7009d906: e7ff         	b	0x7009d908 <Udma_ringAlloc+0x28> @ imm = #-0x2
;        (NULL_PTR == ringPrms))
7009d908: 9812         	ldr	r0, [sp, #0x48]
;     if((NULL_PTR == drvHandleInt) ||
7009d90a: b920         	cbnz	r0, 0x7009d916 <Udma_ringAlloc+0x36> @ imm = #0x8
7009d90c: e7ff         	b	0x7009d90e <Udma_ringAlloc+0x2e> @ imm = #-0x2
7009d90e: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009d912: 9011         	str	r0, [sp, #0x44]
;     }
7009d914: e7ff         	b	0x7009d916 <Udma_ringAlloc+0x36> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d916: 9811         	ldr	r0, [sp, #0x44]
7009d918: b978         	cbnz	r0, 0x7009d93a <Udma_ringAlloc+0x5a> @ imm = #0x1e
7009d91a: e7ff         	b	0x7009d91c <Udma_ringAlloc+0x3c> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009d91c: 980c         	ldr	r0, [sp, #0x30]
7009d91e: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009d922: f64a 31cd    	movw	r1, #0xabcd
7009d926: f6ca 31dc    	movt	r1, #0xabdc
7009d92a: 4288         	cmp	r0, r1
7009d92c: d004         	beq	0x7009d938 <Udma_ringAlloc+0x58> @ imm = #0x8
7009d92e: e7ff         	b	0x7009d930 <Udma_ringAlloc+0x50> @ imm = #-0x2
7009d930: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009d934: 9011         	str	r0, [sp, #0x44]
;         }
7009d936: e7ff         	b	0x7009d938 <Udma_ringAlloc+0x58> @ imm = #-0x2
;     }
7009d938: e7ff         	b	0x7009d93a <Udma_ringAlloc+0x5a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d93a: 9811         	ldr	r0, [sp, #0x44]
7009d93c: b930         	cbnz	r0, 0x7009d94c <Udma_ringAlloc+0x6c> @ imm = #0xc
7009d93e: e7ff         	b	0x7009d940 <Udma_ringAlloc+0x60> @ imm = #-0x2
;         retVal = Udma_ringCheckParams(drvHandleInt, ringPrms);
7009d940: 980c         	ldr	r0, [sp, #0x30]
7009d942: 9912         	ldr	r1, [sp, #0x48]
7009d944: f007 f9bc    	bl	0x700a4cc0 <Udma_ringCheckParams> @ imm = #0x7378
7009d948: 9011         	str	r0, [sp, #0x44]
;     }
7009d94a: e7ff         	b	0x7009d94c <Udma_ringAlloc+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d94c: 9811         	ldr	r0, [sp, #0x44]
7009d94e: 2800         	cmp	r0, #0x0
7009d950: d140         	bne	0x7009d9d4 <Udma_ringAlloc+0xf4> @ imm = #0x80
7009d952: e7ff         	b	0x7009d954 <Udma_ringAlloc+0x74> @ imm = #-0x2
;         if(UDMA_RING_ANY == ringNum)
7009d954: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009d958: f64f 71fe    	movw	r1, #0xfffe
7009d95c: 4288         	cmp	r0, r1
7009d95e: d126         	bne	0x7009d9ae <Udma_ringAlloc+0xce> @ imm = #0x4c
7009d960: e7ff         	b	0x7009d962 <Udma_ringAlloc+0x82> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009d962: 9812         	ldr	r0, [sp, #0x48]
7009d964: 6940         	ldr	r0, [r0, #0x14]
7009d966: 2104         	movs	r1, #0x4
7009d968: f6cf 71ff    	movt	r1, #0xffff
7009d96c: 4288         	cmp	r0, r1
7009d96e: d106         	bne	0x7009d97e <Udma_ringAlloc+0x9e> @ imm = #0xc
7009d970: e7ff         	b	0x7009d972 <Udma_ringAlloc+0x92> @ imm = #-0x2
;                 ringHandleInt->ringNum = Udma_rmAllocFreeRing(drvHandleInt);
7009d972: 980c         	ldr	r0, [sp, #0x30]
7009d974: f00f febc    	bl	0x700ad6f0 <Udma_rmAllocFreeRing> @ imm = #0xfd78
7009d978: 990b         	ldr	r1, [sp, #0x2c]
7009d97a: 8088         	strh	r0, [r1, #0x4]
;             }
7009d97c: e008         	b	0x7009d990 <Udma_ringAlloc+0xb0> @ imm = #0x10
;                 ringHandleInt->ringNum = Udma_rmAllocMappedRing(drvHandleInt, ringPrms->mappedRingGrp, ringPrms->mappedChNum);
7009d97e: 980c         	ldr	r0, [sp, #0x30]
7009d980: 9a12         	ldr	r2, [sp, #0x48]
7009d982: 6951         	ldr	r1, [r2, #0x14]
7009d984: 6992         	ldr	r2, [r2, #0x18]
7009d986: f003 f873    	bl	0x700a0a70 <Udma_rmAllocMappedRing> @ imm = #0x30e6
7009d98a: 990b         	ldr	r1, [sp, #0x2c]
7009d98c: 8088         	strh	r0, [r1, #0x4]
7009d98e: e7ff         	b	0x7009d990 <Udma_ringAlloc+0xb0> @ imm = #-0x2
;             if(UDMA_RING_INVALID == ringHandleInt->ringNum)
7009d990: 980b         	ldr	r0, [sp, #0x2c]
7009d992: 8880         	ldrh	r0, [r0, #0x4]
7009d994: f64f 71ff    	movw	r1, #0xffff
7009d998: 4288         	cmp	r0, r1
7009d99a: d104         	bne	0x7009d9a6 <Udma_ringAlloc+0xc6> @ imm = #0x8
7009d99c: e7ff         	b	0x7009d99e <Udma_ringAlloc+0xbe> @ imm = #-0x2
7009d99e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d9a2: 9011         	str	r0, [sp, #0x44]
;             }
7009d9a4: e002         	b	0x7009d9ac <Udma_ringAlloc+0xcc> @ imm = #0x4
7009d9a6: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009d9a8: 900d         	str	r0, [sp, #0x34]
7009d9aa: e7ff         	b	0x7009d9ac <Udma_ringAlloc+0xcc> @ imm = #-0x2
;         }
7009d9ac: e011         	b	0x7009d9d2 <Udma_ringAlloc+0xf2> @ imm = #0x22
;             if(ringNum >= drvHandleInt->maxRings)
7009d9ae: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009d9b2: 990c         	ldr	r1, [sp, #0x30]
7009d9b4: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
7009d9b8: 4288         	cmp	r0, r1
7009d9ba: d304         	blo	0x7009d9c6 <Udma_ringAlloc+0xe6> @ imm = #0x8
7009d9bc: e7ff         	b	0x7009d9be <Udma_ringAlloc+0xde> @ imm = #-0x2
7009d9be: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
7009d9c2: 9011         	str	r0, [sp, #0x44]
;             }
7009d9c4: e004         	b	0x7009d9d0 <Udma_ringAlloc+0xf0> @ imm = #0x8
;                 ringHandleInt->ringNum = ringNum;
7009d9c6: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009d9ca: 990b         	ldr	r1, [sp, #0x2c]
7009d9cc: 8088         	strh	r0, [r1, #0x4]
7009d9ce: e7ff         	b	0x7009d9d0 <Udma_ringAlloc+0xf0> @ imm = #-0x2
7009d9d0: e7ff         	b	0x7009d9d2 <Udma_ringAlloc+0xf2> @ imm = #-0x2
;     }
7009d9d2: e7ff         	b	0x7009d9d4 <Udma_ringAlloc+0xf4> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d9d4: 9811         	ldr	r0, [sp, #0x44]
7009d9d6: b9a8         	cbnz	r0, 0x7009da04 <Udma_ringAlloc+0x124> @ imm = #0x2a
7009d9d8: e7ff         	b	0x7009d9da <Udma_ringAlloc+0xfa> @ imm = #-0x2
;         Udma_ringAssertFnPointers(drvHandleInt);
7009d9da: 980c         	ldr	r0, [sp, #0x30]
7009d9dc: f010 f840    	bl	0x700ada60 <Udma_ringAssertFnPointers> @ imm = #0x10080
;         ringHandleInt->drvHandle = drvHandleInt;
7009d9e0: 980c         	ldr	r0, [sp, #0x30]
7009d9e2: 990b         	ldr	r1, [sp, #0x2c]
7009d9e4: 6008         	str	r0, [r1]
;         ringHandleInt->mappedRingGrp   = ringPrms->mappedRingGrp;
7009d9e6: 9812         	ldr	r0, [sp, #0x48]
7009d9e8: 6940         	ldr	r0, [r0, #0x14]
7009d9ea: 990b         	ldr	r1, [sp, #0x2c]
7009d9ec: 65c8         	str	r0, [r1, #0x5c]
;         ringHandleInt->mappedChNum     = ringPrms->mappedChNum;
7009d9ee: 9812         	ldr	r0, [sp, #0x48]
7009d9f0: 6980         	ldr	r0, [r0, #0x18]
7009d9f2: 990b         	ldr	r1, [sp, #0x2c]
7009d9f4: 6608         	str	r0, [r1, #0x60]
;         drvHandleInt->ringSetCfg(drvHandleInt, ringHandleInt, ringPrms);
7009d9f6: 980c         	ldr	r0, [sp, #0x30]
7009d9f8: f8d0 35c4    	ldr.w	r3, [r0, #0x5c4]
7009d9fc: 990b         	ldr	r1, [sp, #0x2c]
7009d9fe: 9a12         	ldr	r2, [sp, #0x48]
7009da00: 4798         	blx	r3
;     }
7009da02: e7ff         	b	0x7009da04 <Udma_ringAlloc+0x124> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009da04: 9811         	ldr	r0, [sp, #0x44]
7009da06: 2800         	cmp	r0, #0x0
7009da08: d146         	bne	0x7009da98 <Udma_ringAlloc+0x1b8> @ imm = #0x8c
7009da0a: e7ff         	b	0x7009da0c <Udma_ringAlloc+0x12c> @ imm = #-0x2
7009da0c: 20bf         	movs	r0, #0xbf
;         rmRingReq.valid_params  = TISCI_MSG_VALUE_RM_RING_ADDR_LO_VALID |
7009da0e: 9004         	str	r0, [sp, #0x10]
;         rmRingReq.nav_id        = drvHandleInt->devIdRing;
7009da10: 980c         	ldr	r0, [sp, #0x30]
7009da12: f8b0 00e0    	ldrh.w	r0, [r0, #0xe0]
7009da16: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmRingReq.index         = ringHandleInt->ringNum;
7009da1a: 980b         	ldr	r0, [sp, #0x2c]
7009da1c: 8880         	ldrh	r0, [r0, #0x4]
7009da1e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         physBase = Udma_virtToPhyFxn(ringPrms->ringMem, drvHandleInt, (Udma_ChHandleInt) NULL_PTR);
7009da22: 9812         	ldr	r0, [sp, #0x48]
7009da24: 6800         	ldr	r0, [r0]
7009da26: 990c         	ldr	r1, [sp, #0x30]
7009da28: 2200         	movs	r2, #0x0
7009da2a: f00c fc81    	bl	0x700aa330 <Udma_virtToPhyFxn> @ imm = #0xc902
7009da2e: 910f         	str	r1, [sp, #0x3c]
7009da30: 900e         	str	r0, [sp, #0x38]
;         rmRingReq.addr_lo       = (uint32_t)physBase;
7009da32: 980e         	ldr	r0, [sp, #0x38]
7009da34: 9006         	str	r0, [sp, #0x18]
;         rmRingReq.addr_hi       = (uint32_t)(physBase >> 32UL);
7009da36: 980f         	ldr	r0, [sp, #0x3c]
7009da38: 9007         	str	r0, [sp, #0x1c]
;         rmRingReq.count         = ringPrms->elemCnt;
7009da3a: 9812         	ldr	r0, [sp, #0x48]
7009da3c: 68c0         	ldr	r0, [r0, #0xc]
7009da3e: 9008         	str	r0, [sp, #0x20]
;         rmRingReq.mode          = ringPrms->mode;
7009da40: 9812         	ldr	r0, [sp, #0x48]
7009da42: 7a00         	ldrb	r0, [r0, #0x8]
7009da44: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmRingReq.size          = ringPrms->elemSize;
7009da48: 9812         	ldr	r0, [sp, #0x48]
7009da4a: 7c00         	ldrb	r0, [r0, #0x10]
7009da4c: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmRingReq.order_id      = ringPrms->orderId;
7009da50: 9812         	ldr	r0, [sp, #0x48]
7009da52: 7c40         	ldrb	r0, [r0, #0x11]
7009da54: f88d 0026    	strb.w	r0, [sp, #0x26]
;         rmRingReq.asel          = ringPrms->asel;
7009da58: 9812         	ldr	r0, [sp, #0x48]
7009da5a: 7c80         	ldrb	r0, [r0, #0x12]
7009da5c: f88d 0029    	strb.w	r0, [sp, #0x29]
;         if(UDMA_RING_VIRTID_INVALID != ringPrms->virtId)
7009da60: 9812         	ldr	r0, [sp, #0x48]
7009da62: 8940         	ldrh	r0, [r0, #0xa]
7009da64: f64f 71ff    	movw	r1, #0xffff
7009da68: 4288         	cmp	r0, r1
7009da6a: d009         	beq	0x7009da80 <Udma_ringAlloc+0x1a0> @ imm = #0x12
7009da6c: e7ff         	b	0x7009da6e <Udma_ringAlloc+0x18e> @ imm = #-0x2
;             rmRingReq.valid_params |= TISCI_MSG_VALUE_RM_RING_VIRTID_VALID;
7009da6e: 9804         	ldr	r0, [sp, #0x10]
7009da70: f040 0040    	orr	r0, r0, #0x40
7009da74: 9004         	str	r0, [sp, #0x10]
;             rmRingReq.virtid        = ringPrms->virtId;
7009da76: 9812         	ldr	r0, [sp, #0x48]
7009da78: 8940         	ldrh	r0, [r0, #0xa]
7009da7a: f8ad 0027    	strh.w	r0, [sp, #0x27]
;         }
7009da7e: e7ff         	b	0x7009da80 <Udma_ringAlloc+0x1a0> @ imm = #-0x2
7009da80: a802         	add	r0, sp, #0x8
7009da82: 4669         	mov	r1, sp
7009da84: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmRingCfg(
7009da88: f00c fec2    	bl	0x700aa810 <Sciclient_rmRingCfg> @ imm = #0xcd84
7009da8c: 9011         	str	r0, [sp, #0x44]
;         if(CSL_PASS != retVal)
7009da8e: 9811         	ldr	r0, [sp, #0x44]
7009da90: b108         	cbz	r0, 0x7009da96 <Udma_ringAlloc+0x1b6> @ imm = #0x2
7009da92: e7ff         	b	0x7009da94 <Udma_ringAlloc+0x1b4> @ imm = #-0x2
;         }
7009da94: e7ff         	b	0x7009da96 <Udma_ringAlloc+0x1b6> @ imm = #-0x2
;     }
7009da96: e7ff         	b	0x7009da98 <Udma_ringAlloc+0x1b8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009da98: 9811         	ldr	r0, [sp, #0x44]
7009da9a: b938         	cbnz	r0, 0x7009daac <Udma_ringAlloc+0x1cc> @ imm = #0xe
7009da9c: e7ff         	b	0x7009da9e <Udma_ringAlloc+0x1be> @ imm = #-0x2
;         ringHandleInt->ringInitDone = UDMA_INIT_DONE;
7009da9e: 990b         	ldr	r1, [sp, #0x2c]
7009daa0: f64a 30cd    	movw	r0, #0xabcd
7009daa4: f6ca 30dc    	movt	r0, #0xabdc
7009daa8: 6588         	str	r0, [r1, #0x58]
;     }
7009daaa: e01b         	b	0x7009dae4 <Udma_ringAlloc+0x204> @ imm = #0x36
;         if(((uint32_t) TRUE) == allocDone)
7009daac: 980d         	ldr	r0, [sp, #0x34]
7009daae: 2801         	cmp	r0, #0x1
7009dab0: d117         	bne	0x7009dae2 <Udma_ringAlloc+0x202> @ imm = #0x2e
7009dab2: e7ff         	b	0x7009dab4 <Udma_ringAlloc+0x1d4> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009dab4: 9812         	ldr	r0, [sp, #0x48]
7009dab6: 6940         	ldr	r0, [r0, #0x14]
7009dab8: 2104         	movs	r1, #0x4
7009daba: f6cf 71ff    	movt	r1, #0xffff
7009dabe: 4288         	cmp	r0, r1
7009dac0: d106         	bne	0x7009dad0 <Udma_ringAlloc+0x1f0> @ imm = #0xc
7009dac2: e7ff         	b	0x7009dac4 <Udma_ringAlloc+0x1e4> @ imm = #-0x2
;                 Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandleInt);
7009dac4: 980b         	ldr	r0, [sp, #0x2c]
7009dac6: 8880         	ldrh	r0, [r0, #0x4]
7009dac8: 990c         	ldr	r1, [sp, #0x30]
7009daca: f00f ff89    	bl	0x700ad9e0 <Udma_rmFreeFreeRing> @ imm = #0xff12
;             }
7009dace: e007         	b	0x7009dae0 <Udma_ringAlloc+0x200> @ imm = #0xe
;                 Udma_rmFreeMappedRing(ringHandleInt->ringNum, drvHandleInt, ringHandleInt->mappedRingGrp, ringHandleInt->mappedChNum);
7009dad0: 9b0b         	ldr	r3, [sp, #0x2c]
7009dad2: 8898         	ldrh	r0, [r3, #0x4]
7009dad4: 990c         	ldr	r1, [sp, #0x30]
7009dad6: 6dda         	ldr	r2, [r3, #0x5c]
7009dad8: 6e1b         	ldr	r3, [r3, #0x60]
7009dada: f00a f8f9    	bl	0x700a7cd0 <Udma_rmFreeMappedRing> @ imm = #0xa1f2
7009dade: e7ff         	b	0x7009dae0 <Udma_ringAlloc+0x200> @ imm = #-0x2
;         }
7009dae0: e7ff         	b	0x7009dae2 <Udma_ringAlloc+0x202> @ imm = #-0x2
7009dae2: e7ff         	b	0x7009dae4 <Udma_ringAlloc+0x204> @ imm = #-0x2
;     return (retVal);
7009dae4: 9811         	ldr	r0, [sp, #0x44]
7009dae6: b016         	add	sp, #0x58
7009dae8: bd80         	pop	{r7, pc}
7009daea: 0000         	movs	r0, r0
7009daec: 0000         	movs	r0, r0
7009daee: 0000         	movs	r0, r0

7009daf0 <Udma_chDisableBlkCpyChan>:
; {
7009daf0: b580         	push	{r7, lr}
7009daf2: b090         	sub	sp, #0x40
7009daf4: 900f         	str	r0, [sp, #0x3c]
7009daf6: 910e         	str	r1, [sp, #0x38]
7009daf8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009dafa: 900d         	str	r0, [sp, #0x34]
;     uint32_t            currTimeout = 0U;
7009dafc: 900c         	str	r0, [sp, #0x30]
;     drvHandle = chHandle->drvHandle;
7009dafe: 980f         	ldr	r0, [sp, #0x3c]
7009db00: 6e80         	ldr	r0, [r0, #0x68]
7009db02: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009db04: 980b         	ldr	r0, [sp, #0x2c]
7009db06: 6800         	ldr	r0, [r0]
7009db08: 2801         	cmp	r0, #0x1
7009db0a: d10a         	bne	0x7009db22 <Udma_chDisableBlkCpyChan+0x32> @ imm = #0x14
7009db0c: e7ff         	b	0x7009db0e <Udma_chDisableBlkCpyChan+0x1e> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009db0e: 980b         	ldr	r0, [sp, #0x2c]
7009db10: 3008         	adds	r0, #0x8
7009db12: 990f         	ldr	r1, [sp, #0x3c]
7009db14: 6ec9         	ldr	r1, [r1, #0x6c]
7009db16: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009db18: 461a         	mov	r2, r3
7009db1a: f00d fd59    	bl	0x700ab5d0 <CSL_bcdmaTeardownTxChan> @ imm = #0xdab2
7009db1e: 900d         	str	r0, [sp, #0x34]
;     }
7009db20: e00f         	b	0x7009db42 <Udma_chDisableBlkCpyChan+0x52> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009db22: 980b         	ldr	r0, [sp, #0x2c]
7009db24: 6800         	ldr	r0, [r0]
7009db26: 2802         	cmp	r0, #0x2
7009db28: d10a         	bne	0x7009db40 <Udma_chDisableBlkCpyChan+0x50> @ imm = #0x14
7009db2a: e7ff         	b	0x7009db2c <Udma_chDisableBlkCpyChan+0x3c> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009db2c: 980b         	ldr	r0, [sp, #0x2c]
7009db2e: 3054         	adds	r0, #0x54
7009db30: 990f         	ldr	r1, [sp, #0x3c]
7009db32: 6ec9         	ldr	r1, [r1, #0x6c]
7009db34: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009db36: 461a         	mov	r2, r3
7009db38: f00e fbf2    	bl	0x700ac320 <CSL_pktdmaTeardownTxChan> @ imm = #0xe7e4
7009db3c: 900d         	str	r0, [sp, #0x34]
;     }
7009db3e: e7ff         	b	0x7009db40 <Udma_chDisableBlkCpyChan+0x50> @ imm = #-0x2
7009db40: e7ff         	b	0x7009db42 <Udma_chDisableBlkCpyChan+0x52> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009db42: 980d         	ldr	r0, [sp, #0x34]
7009db44: b108         	cbz	r0, 0x7009db4a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #0x2
7009db46: e7ff         	b	0x7009db48 <Udma_chDisableBlkCpyChan+0x58> @ imm = #-0x2
;     }
7009db48: e7ff         	b	0x7009db4a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009db4a: e7ff         	b	0x7009db4c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x2
7009db4c: 980d         	ldr	r0, [sp, #0x34]
7009db4e: bba8         	cbnz	r0, 0x7009dbbc <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x6a
7009db50: e7ff         	b	0x7009db52 <Udma_chDisableBlkCpyChan+0x62> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009db52: 980b         	ldr	r0, [sp, #0x2c]
7009db54: 6800         	ldr	r0, [r0]
7009db56: 2801         	cmp	r0, #0x1
7009db58: d10c         	bne	0x7009db74 <Udma_chDisableBlkCpyChan+0x84> @ imm = #0x18
7009db5a: e7ff         	b	0x7009db5c <Udma_chDisableBlkCpyChan+0x6c> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009db5c: 980b         	ldr	r0, [sp, #0x2c]
7009db5e: 3008         	adds	r0, #0x8
7009db60: 990f         	ldr	r1, [sp, #0x3c]
7009db62: 6ec9         	ldr	r1, [r1, #0x6c]
7009db64: aa05         	add	r2, sp, #0x14
7009db66: f00e febb    	bl	0x700ac8e0 <CSL_bcdmaGetTxRT> @ imm = #0xed76
;             if(FALSE == bcdmaRtStatus.enable)
7009db6a: 9805         	ldr	r0, [sp, #0x14]
7009db6c: b908         	cbnz	r0, 0x7009db72 <Udma_chDisableBlkCpyChan+0x82> @ imm = #0x2
7009db6e: e7ff         	b	0x7009db70 <Udma_chDisableBlkCpyChan+0x80> @ imm = #-0x2
;                 break;
7009db70: e024         	b	0x7009dbbc <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x48
;         }
7009db72: e011         	b	0x7009db98 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009db74: 980b         	ldr	r0, [sp, #0x2c]
7009db76: 6800         	ldr	r0, [r0]
7009db78: 2802         	cmp	r0, #0x2
7009db7a: d10c         	bne	0x7009db96 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #0x18
7009db7c: e7ff         	b	0x7009db7e <Udma_chDisableBlkCpyChan+0x8e> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009db7e: 980b         	ldr	r0, [sp, #0x2c]
7009db80: 3054         	adds	r0, #0x54
7009db82: 990f         	ldr	r1, [sp, #0x3c]
7009db84: 6ec9         	ldr	r1, [r1, #0x6c]
7009db86: 466a         	mov	r2, sp
7009db88: f00d fb92    	bl	0x700ab2b0 <CSL_pktdmaGetTxRT> @ imm = #0xd724
;             if(FALSE == pktdmaRtStatus.enable)
7009db8c: 9800         	ldr	r0, [sp]
7009db8e: b908         	cbnz	r0, 0x7009db94 <Udma_chDisableBlkCpyChan+0xa4> @ imm = #0x2
7009db90: e7ff         	b	0x7009db92 <Udma_chDisableBlkCpyChan+0xa2> @ imm = #-0x2
;                 break;
7009db92: e013         	b	0x7009dbbc <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x26
;         }
7009db94: e7ff         	b	0x7009db96 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #-0x2
7009db96: e7ff         	b	0x7009db98 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #-0x2
;         if(currTimeout > timeout)
7009db98: 980c         	ldr	r0, [sp, #0x30]
7009db9a: 990e         	ldr	r1, [sp, #0x38]
7009db9c: 4288         	cmp	r0, r1
7009db9e: d904         	bls	0x7009dbaa <Udma_chDisableBlkCpyChan+0xba> @ imm = #0x8
7009dba0: e7ff         	b	0x7009dba2 <Udma_chDisableBlkCpyChan+0xb2> @ imm = #-0x2
7009dba2: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009dba6: 900d         	str	r0, [sp, #0x34]
;         }
7009dba8: e007         	b	0x7009dbba <Udma_chDisableBlkCpyChan+0xca> @ imm = #0xe
7009dbaa: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009dbae: f00b fa77    	bl	0x700a90a0 <ClockP_usleep> @ imm = #0xb4ee
;             currTimeout++;
7009dbb2: 980c         	ldr	r0, [sp, #0x30]
7009dbb4: 3001         	adds	r0, #0x1
7009dbb6: 900c         	str	r0, [sp, #0x30]
7009dbb8: e7ff         	b	0x7009dbba <Udma_chDisableBlkCpyChan+0xca> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009dbba: e7c7         	b	0x7009db4c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x72
;     if(UDMA_SOK != retVal)
7009dbbc: 980d         	ldr	r0, [sp, #0x34]
7009dbbe: 2800         	cmp	r0, #0x0
7009dbc0: d05f         	beq	0x7009dc82 <Udma_chDisableBlkCpyChan+0x192> @ imm = #0xbe
7009dbc2: e7ff         	b	0x7009dbc4 <Udma_chDisableBlkCpyChan+0xd4> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009dbc4: 980b         	ldr	r0, [sp, #0x2c]
7009dbc6: 6800         	ldr	r0, [r0]
7009dbc8: 2801         	cmp	r0, #0x1
7009dbca: d10a         	bne	0x7009dbe2 <Udma_chDisableBlkCpyChan+0xf2> @ imm = #0x14
7009dbcc: e7ff         	b	0x7009dbce <Udma_chDisableBlkCpyChan+0xde> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009dbce: 980b         	ldr	r0, [sp, #0x2c]
7009dbd0: 3008         	adds	r0, #0x8
7009dbd2: 990f         	ldr	r1, [sp, #0x3c]
7009dbd4: 6ec9         	ldr	r1, [r1, #0x6c]
7009dbd6: 2201         	movs	r2, #0x1
7009dbd8: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009dbda: f00d fcf9    	bl	0x700ab5d0 <CSL_bcdmaTeardownTxChan> @ imm = #0xd9f2
7009dbde: 900d         	str	r0, [sp, #0x34]
;         }
7009dbe0: e00f         	b	0x7009dc02 <Udma_chDisableBlkCpyChan+0x112> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009dbe2: 980b         	ldr	r0, [sp, #0x2c]
7009dbe4: 6800         	ldr	r0, [r0]
7009dbe6: 2802         	cmp	r0, #0x2
7009dbe8: d10a         	bne	0x7009dc00 <Udma_chDisableBlkCpyChan+0x110> @ imm = #0x14
7009dbea: e7ff         	b	0x7009dbec <Udma_chDisableBlkCpyChan+0xfc> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009dbec: 980b         	ldr	r0, [sp, #0x2c]
7009dbee: 3054         	adds	r0, #0x54
7009dbf0: 990f         	ldr	r1, [sp, #0x3c]
7009dbf2: 6ec9         	ldr	r1, [r1, #0x6c]
7009dbf4: 2201         	movs	r2, #0x1
7009dbf6: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009dbf8: f00e fb92    	bl	0x700ac320 <CSL_pktdmaTeardownTxChan> @ imm = #0xe724
7009dbfc: 900d         	str	r0, [sp, #0x34]
;         }
7009dbfe: e7ff         	b	0x7009dc00 <Udma_chDisableBlkCpyChan+0x110> @ imm = #-0x2
7009dc00: e7ff         	b	0x7009dc02 <Udma_chDisableBlkCpyChan+0x112> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009dc02: 980d         	ldr	r0, [sp, #0x34]
7009dc04: b108         	cbz	r0, 0x7009dc0a <Udma_chDisableBlkCpyChan+0x11a> @ imm = #0x2
7009dc06: e7ff         	b	0x7009dc08 <Udma_chDisableBlkCpyChan+0x118> @ imm = #-0x2
;         }
7009dc08: e7ff         	b	0x7009dc0a <Udma_chDisableBlkCpyChan+0x11a> @ imm = #-0x2
7009dc0a: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009dc0c: 900c         	str	r0, [sp, #0x30]
;         while(UDMA_SOK == retVal)
7009dc0e: e7ff         	b	0x7009dc10 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x2
7009dc10: 980d         	ldr	r0, [sp, #0x34]
7009dc12: bba8         	cbnz	r0, 0x7009dc80 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x6a
7009dc14: e7ff         	b	0x7009dc16 <Udma_chDisableBlkCpyChan+0x126> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009dc16: 980b         	ldr	r0, [sp, #0x2c]
7009dc18: 6800         	ldr	r0, [r0]
7009dc1a: 2801         	cmp	r0, #0x1
7009dc1c: d10c         	bne	0x7009dc38 <Udma_chDisableBlkCpyChan+0x148> @ imm = #0x18
7009dc1e: e7ff         	b	0x7009dc20 <Udma_chDisableBlkCpyChan+0x130> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009dc20: 980b         	ldr	r0, [sp, #0x2c]
7009dc22: 3008         	adds	r0, #0x8
7009dc24: 990f         	ldr	r1, [sp, #0x3c]
7009dc26: 6ec9         	ldr	r1, [r1, #0x6c]
7009dc28: aa05         	add	r2, sp, #0x14
7009dc2a: f00e fe59    	bl	0x700ac8e0 <CSL_bcdmaGetTxRT> @ imm = #0xecb2
;                 if(FALSE == bcdmaRtStatus.enable)
7009dc2e: 9805         	ldr	r0, [sp, #0x14]
7009dc30: b908         	cbnz	r0, 0x7009dc36 <Udma_chDisableBlkCpyChan+0x146> @ imm = #0x2
7009dc32: e7ff         	b	0x7009dc34 <Udma_chDisableBlkCpyChan+0x144> @ imm = #-0x2
;                     break;
7009dc34: e024         	b	0x7009dc80 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x48
;             }
7009dc36: e011         	b	0x7009dc5c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #0x22
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009dc38: 980b         	ldr	r0, [sp, #0x2c]
7009dc3a: 6800         	ldr	r0, [r0]
7009dc3c: 2802         	cmp	r0, #0x2
7009dc3e: d10c         	bne	0x7009dc5a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #0x18
7009dc40: e7ff         	b	0x7009dc42 <Udma_chDisableBlkCpyChan+0x152> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009dc42: 980b         	ldr	r0, [sp, #0x2c]
7009dc44: 3054         	adds	r0, #0x54
7009dc46: 990f         	ldr	r1, [sp, #0x3c]
7009dc48: 6ec9         	ldr	r1, [r1, #0x6c]
7009dc4a: 466a         	mov	r2, sp
7009dc4c: f00d fb30    	bl	0x700ab2b0 <CSL_pktdmaGetTxRT> @ imm = #0xd660
;                 if(FALSE == pktdmaRtStatus.enable)
7009dc50: 9800         	ldr	r0, [sp]
7009dc52: b908         	cbnz	r0, 0x7009dc58 <Udma_chDisableBlkCpyChan+0x168> @ imm = #0x2
7009dc54: e7ff         	b	0x7009dc56 <Udma_chDisableBlkCpyChan+0x166> @ imm = #-0x2
;                     break;
7009dc56: e013         	b	0x7009dc80 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x26
;             }
7009dc58: e7ff         	b	0x7009dc5a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #-0x2
7009dc5a: e7ff         	b	0x7009dc5c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009dc5c: 980c         	ldr	r0, [sp, #0x30]
7009dc5e: 990e         	ldr	r1, [sp, #0x38]
7009dc60: 4288         	cmp	r0, r1
7009dc62: d904         	bls	0x7009dc6e <Udma_chDisableBlkCpyChan+0x17e> @ imm = #0x8
7009dc64: e7ff         	b	0x7009dc66 <Udma_chDisableBlkCpyChan+0x176> @ imm = #-0x2
7009dc66: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009dc6a: 900d         	str	r0, [sp, #0x34]
;             }
7009dc6c: e007         	b	0x7009dc7e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #0xe
7009dc6e: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009dc72: f00b fa15    	bl	0x700a90a0 <ClockP_usleep> @ imm = #0xb42a
;                 currTimeout++;
7009dc76: 980c         	ldr	r0, [sp, #0x30]
7009dc78: 3001         	adds	r0, #0x1
7009dc7a: 900c         	str	r0, [sp, #0x30]
7009dc7c: e7ff         	b	0x7009dc7e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009dc7e: e7c7         	b	0x7009dc10 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x72
;     }
7009dc80: e7ff         	b	0x7009dc82 <Udma_chDisableBlkCpyChan+0x192> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dc82: 980d         	ldr	r0, [sp, #0x34]
7009dc84: bb20         	cbnz	r0, 0x7009dcd0 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #0x48
7009dc86: e7ff         	b	0x7009dc88 <Udma_chDisableBlkCpyChan+0x198> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009dc88: 980b         	ldr	r0, [sp, #0x2c]
7009dc8a: 6800         	ldr	r0, [r0]
7009dc8c: 2801         	cmp	r0, #0x1
7009dc8e: d10c         	bne	0x7009dcaa <Udma_chDisableBlkCpyChan+0x1ba> @ imm = #0x18
7009dc90: e7ff         	b	0x7009dc92 <Udma_chDisableBlkCpyChan+0x1a2> @ imm = #-0x2
7009dc92: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009dc94: 9005         	str	r0, [sp, #0x14]
;             bcdmaRtStatus.teardown = FALSE;
7009dc96: 9006         	str	r0, [sp, #0x18]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009dc98: 9009         	str	r0, [sp, #0x24]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009dc9a: 980b         	ldr	r0, [sp, #0x2c]
7009dc9c: 3008         	adds	r0, #0x8
7009dc9e: 990f         	ldr	r1, [sp, #0x3c]
7009dca0: 6ec9         	ldr	r1, [r1, #0x6c]
7009dca2: aa05         	add	r2, sp, #0x14
7009dca4: f00e fe4c    	bl	0x700ac940 <CSL_bcdmaSetTxRT> @ imm = #0xec98
;         }
7009dca8: e011         	b	0x7009dcce <Udma_chDisableBlkCpyChan+0x1de> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009dcaa: 980b         	ldr	r0, [sp, #0x2c]
7009dcac: 6800         	ldr	r0, [r0]
7009dcae: 2802         	cmp	r0, #0x2
7009dcb0: d10c         	bne	0x7009dccc <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #0x18
7009dcb2: e7ff         	b	0x7009dcb4 <Udma_chDisableBlkCpyChan+0x1c4> @ imm = #-0x2
7009dcb4: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009dcb6: 9000         	str	r0, [sp]
;             pktdmaRtStatus.teardown = FALSE;
7009dcb8: 9001         	str	r0, [sp, #0x4]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009dcba: 9004         	str	r0, [sp, #0x10]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009dcbc: 980b         	ldr	r0, [sp, #0x2c]
7009dcbe: 3054         	adds	r0, #0x54
7009dcc0: 990f         	ldr	r1, [sp, #0x3c]
7009dcc2: 6ec9         	ldr	r1, [r1, #0x6c]
7009dcc4: 466a         	mov	r2, sp
7009dcc6: f00e f8ab    	bl	0x700abe20 <CSL_pktdmaSetTxRT> @ imm = #0xe156
;         }
7009dcca: e7ff         	b	0x7009dccc <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #-0x2
7009dccc: e7ff         	b	0x7009dcce <Udma_chDisableBlkCpyChan+0x1de> @ imm = #-0x2
;     }
7009dcce: e7ff         	b	0x7009dcd0 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #-0x2
;     return (retVal);
7009dcd0: 980d         	ldr	r0, [sp, #0x34]
7009dcd2: b010         	add	sp, #0x40
7009dcd4: bd80         	pop	{r7, pc}
		...
7009dcde: 0000         	movs	r0, r0

7009dce0 <Udma_flowConfig>:
; {
7009dce0: b580         	push	{r7, lr}
7009dce2: b09e         	sub	sp, #0x78
7009dce4: 901d         	str	r0, [sp, #0x74]
7009dce6: 911c         	str	r1, [sp, #0x70]
7009dce8: 921b         	str	r2, [sp, #0x6c]
7009dcea: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009dcec: 901a         	str	r0, [sp, #0x68]
;     Udma_FlowHandleInt  flowHandleInt = (Udma_FlowHandleInt) flowHandle;
7009dcee: 981d         	ldr	r0, [sp, #0x74]
7009dcf0: 9018         	str	r0, [sp, #0x60]
;     if((NULL_PTR == flowHandleInt) ||
7009dcf2: 9818         	ldr	r0, [sp, #0x60]
7009dcf4: b160         	cbz	r0, 0x7009dd10 <Udma_flowConfig+0x30> @ imm = #0x18
7009dcf6: e7ff         	b	0x7009dcf8 <Udma_flowConfig+0x18> @ imm = #-0x2
;        (flowHandleInt->flowInitDone != UDMA_INIT_DONE) ||
7009dcf8: 9818         	ldr	r0, [sp, #0x60]
7009dcfa: 68c0         	ldr	r0, [r0, #0xc]
7009dcfc: f64a 31cd    	movw	r1, #0xabcd
7009dd00: f6ca 31dc    	movt	r1, #0xabdc
7009dd04: 4288         	cmp	r0, r1
7009dd06: d103         	bne	0x7009dd10 <Udma_flowConfig+0x30> @ imm = #0x6
7009dd08: e7ff         	b	0x7009dd0a <Udma_flowConfig+0x2a> @ imm = #-0x2
;        (NULL_PTR == flowPrms))
7009dd0a: 981b         	ldr	r0, [sp, #0x6c]
;     if((NULL_PTR == flowHandleInt) ||
7009dd0c: b920         	cbnz	r0, 0x7009dd18 <Udma_flowConfig+0x38> @ imm = #0x8
7009dd0e: e7ff         	b	0x7009dd10 <Udma_flowConfig+0x30> @ imm = #-0x2
7009dd10: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009dd14: 901a         	str	r0, [sp, #0x68]
;     }
7009dd16: e7ff         	b	0x7009dd18 <Udma_flowConfig+0x38> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dd18: 981a         	ldr	r0, [sp, #0x68]
7009dd1a: b9a8         	cbnz	r0, 0x7009dd48 <Udma_flowConfig+0x68> @ imm = #0x2a
7009dd1c: e7ff         	b	0x7009dd1e <Udma_flowConfig+0x3e> @ imm = #-0x2
;         drvHandle = flowHandleInt->drvHandle;
7009dd1e: 9818         	ldr	r0, [sp, #0x60]
7009dd20: 6800         	ldr	r0, [r0]
7009dd22: 9019         	str	r0, [sp, #0x64]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009dd24: 9819         	ldr	r0, [sp, #0x64]
7009dd26: b150         	cbz	r0, 0x7009dd3e <Udma_flowConfig+0x5e> @ imm = #0x14
7009dd28: e7ff         	b	0x7009dd2a <Udma_flowConfig+0x4a> @ imm = #-0x2
7009dd2a: 9819         	ldr	r0, [sp, #0x64]
7009dd2c: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009dd30: f64a 31cd    	movw	r1, #0xabcd
7009dd34: f6ca 31dc    	movt	r1, #0xabdc
7009dd38: 4288         	cmp	r0, r1
7009dd3a: d004         	beq	0x7009dd46 <Udma_flowConfig+0x66> @ imm = #0x8
7009dd3c: e7ff         	b	0x7009dd3e <Udma_flowConfig+0x5e> @ imm = #-0x2
7009dd3e: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009dd42: 901a         	str	r0, [sp, #0x68]
;         }
7009dd44: e7ff         	b	0x7009dd46 <Udma_flowConfig+0x66> @ imm = #-0x2
;     }
7009dd46: e7ff         	b	0x7009dd48 <Udma_flowConfig+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dd48: 981a         	ldr	r0, [sp, #0x68]
7009dd4a: b958         	cbnz	r0, 0x7009dd64 <Udma_flowConfig+0x84> @ imm = #0x16
7009dd4c: e7ff         	b	0x7009dd4e <Udma_flowConfig+0x6e> @ imm = #-0x2
;         if(flowIdx >= flowHandleInt->flowCnt)
7009dd4e: 981c         	ldr	r0, [sp, #0x70]
7009dd50: 9918         	ldr	r1, [sp, #0x60]
7009dd52: 6889         	ldr	r1, [r1, #0x8]
7009dd54: 4288         	cmp	r0, r1
7009dd56: d304         	blo	0x7009dd62 <Udma_flowConfig+0x82> @ imm = #0x8
7009dd58: e7ff         	b	0x7009dd5a <Udma_flowConfig+0x7a> @ imm = #-0x2
7009dd5a: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
7009dd5e: 901a         	str	r0, [sp, #0x68]
;         }
7009dd60: e7ff         	b	0x7009dd62 <Udma_flowConfig+0x82> @ imm = #-0x2
;     }
7009dd62: e7ff         	b	0x7009dd64 <Udma_flowConfig+0x84> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dd64: 981a         	ldr	r0, [sp, #0x68]
7009dd66: 2800         	cmp	r0, #0x0
7009dd68: f040 80a3    	bne.w	0x7009deb2 <Udma_flowConfig+0x1d2> @ imm = #0x146
7009dd6c: e7ff         	b	0x7009dd6e <Udma_flowConfig+0x8e> @ imm = #-0x2
7009dd6e: f64f 70ff    	movw	r0, #0xffff
7009dd72: f2c0 0007    	movt	r0, #0x7
;         rmFlowReq.valid_params          = TISCI_MSG_VALUE_RM_UDMAP_FLOW_EINFO_PRESENT_VALID |
7009dd76: 900f         	str	r0, [sp, #0x3c]
;         rmFlowReq.nav_id                = drvHandle->devIdUdma;
7009dd78: 9819         	ldr	r0, [sp, #0x64]
7009dd7a: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009dd7e: f8ad 0040    	strh.w	r0, [sp, #0x40]
;         rmFlowReq.flow_index            = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009dd82: 9818         	ldr	r0, [sp, #0x60]
7009dd84: 6840         	ldr	r0, [r0, #0x4]
7009dd86: 991c         	ldr	r1, [sp, #0x70]
7009dd88: 4408         	add	r0, r1
7009dd8a: f8ad 0042    	strh.w	r0, [sp, #0x42]
;         rmFlowReq.rx_einfo_present      = flowPrms->einfoPresent;
7009dd8e: 981b         	ldr	r0, [sp, #0x6c]
7009dd90: 7900         	ldrb	r0, [r0, #0x4]
7009dd92: f88d 0044    	strb.w	r0, [sp, #0x44]
;         rmFlowReq.rx_psinfo_present     = flowPrms->psInfoPresent;
7009dd96: 981b         	ldr	r0, [sp, #0x6c]
7009dd98: 7940         	ldrb	r0, [r0, #0x5]
7009dd9a: f88d 0045    	strb.w	r0, [sp, #0x45]
;         rmFlowReq.rx_error_handling     = flowPrms->errorHandling;
7009dd9e: 981b         	ldr	r0, [sp, #0x6c]
7009dda0: 7980         	ldrb	r0, [r0, #0x6]
7009dda2: f88d 0046    	strb.w	r0, [sp, #0x46]
;         rmFlowReq.rx_desc_type          = flowPrms->descType;
7009dda6: 981b         	ldr	r0, [sp, #0x6c]
7009dda8: 79c0         	ldrb	r0, [r0, #0x7]
7009ddaa: f88d 0047    	strb.w	r0, [sp, #0x47]
;         rmFlowReq.rx_ps_location        = flowPrms->psLocation;
7009ddae: 981b         	ldr	r0, [sp, #0x6c]
7009ddb0: 7a00         	ldrb	r0, [r0, #0x8]
7009ddb2: f88d 005c    	strb.w	r0, [sp, #0x5c]
;         rmFlowReq.rx_sop_offset         = flowPrms->sopOffset;
7009ddb6: 981b         	ldr	r0, [sp, #0x6c]
7009ddb8: 8940         	ldrh	r0, [r0, #0xa]
7009ddba: f8ad 0048    	strh.w	r0, [sp, #0x48]
;         rmFlowReq.rx_dest_qnum          = flowPrms->defaultRxCQ;
7009ddbe: 981b         	ldr	r0, [sp, #0x6c]
7009ddc0: 8980         	ldrh	r0, [r0, #0xc]
7009ddc2: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;         rmFlowReq.rx_src_tag_hi         = flowPrms->srcTagHi;
7009ddc6: 981b         	ldr	r0, [sp, #0x6c]
7009ddc8: 7b80         	ldrb	r0, [r0, #0xe]
7009ddca: f88d 004c    	strb.w	r0, [sp, #0x4c]
;         rmFlowReq.rx_src_tag_lo         = flowPrms->srcTagLo;
7009ddce: 981b         	ldr	r0, [sp, #0x6c]
7009ddd0: 7bc0         	ldrb	r0, [r0, #0xf]
7009ddd2: f88d 004d    	strb.w	r0, [sp, #0x4d]
;         rmFlowReq.rx_src_tag_hi_sel     = flowPrms->srcTagHiSel;
7009ddd6: 981b         	ldr	r0, [sp, #0x6c]
7009ddd8: 7c00         	ldrb	r0, [r0, #0x10]
7009ddda: f88d 0050    	strb.w	r0, [sp, #0x50]
;         rmFlowReq.rx_src_tag_lo_sel     = flowPrms->srcTagLoSel;
7009ddde: 981b         	ldr	r0, [sp, #0x6c]
7009dde0: 7c40         	ldrb	r0, [r0, #0x11]
7009dde2: f88d 0051    	strb.w	r0, [sp, #0x51]
;         rmFlowReq.rx_dest_tag_hi        = flowPrms->destTagHi;
7009dde6: 981b         	ldr	r0, [sp, #0x6c]
7009dde8: 7c80         	ldrb	r0, [r0, #0x12]
7009ddea: f88d 004e    	strb.w	r0, [sp, #0x4e]
;         rmFlowReq.rx_dest_tag_lo        = flowPrms->destTagLo;
7009ddee: 981b         	ldr	r0, [sp, #0x6c]
7009ddf0: 7cc0         	ldrb	r0, [r0, #0x13]
7009ddf2: f88d 004f    	strb.w	r0, [sp, #0x4f]
;         rmFlowReq.rx_dest_tag_hi_sel    = flowPrms->destTagHiSel;
7009ddf6: 981b         	ldr	r0, [sp, #0x6c]
7009ddf8: 7d00         	ldrb	r0, [r0, #0x14]
7009ddfa: f88d 0052    	strb.w	r0, [sp, #0x52]
;         rmFlowReq.rx_dest_tag_lo_sel    = flowPrms->destTagLoSel;
7009ddfe: 981b         	ldr	r0, [sp, #0x6c]
7009de00: 7d40         	ldrb	r0, [r0, #0x15]
7009de02: f88d 0053    	strb.w	r0, [sp, #0x53]
;         rmFlowReq.rx_fdq0_sz0_qnum      = flowPrms->fdq0Sz0Qnum;
7009de06: 981b         	ldr	r0, [sp, #0x6c]
7009de08: 8b00         	ldrh	r0, [r0, #0x18]
7009de0a: f8ad 0054    	strh.w	r0, [sp, #0x54]
;         rmFlowReq.rx_fdq1_qnum          = flowPrms->fdq1Qnum;
7009de0e: 981b         	ldr	r0, [sp, #0x6c]
7009de10: 8b40         	ldrh	r0, [r0, #0x1a]
7009de12: f8ad 0056    	strh.w	r0, [sp, #0x56]
;         rmFlowReq.rx_fdq2_qnum          = flowPrms->fdq2Qnum;
7009de16: 981b         	ldr	r0, [sp, #0x6c]
7009de18: 8b80         	ldrh	r0, [r0, #0x1c]
7009de1a: f8ad 0058    	strh.w	r0, [sp, #0x58]
;         rmFlowReq.rx_fdq3_qnum          = flowPrms->fdq3Qnum;
7009de1e: 981b         	ldr	r0, [sp, #0x6c]
7009de20: 8bc0         	ldrh	r0, [r0, #0x1e]
7009de22: f8ad 005a    	strh.w	r0, [sp, #0x5a]
7009de26: a80d         	add	r0, sp, #0x34
7009de28: a90b         	add	r1, sp, #0x2c
7009de2a: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapFlowCfg(
7009de2e: f00c fd1f    	bl	0x700aa870 <Sciclient_rmUdmapFlowCfg> @ imm = #0xca3e
7009de32: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009de34: 981a         	ldr	r0, [sp, #0x68]
7009de36: b108         	cbz	r0, 0x7009de3c <Udma_flowConfig+0x15c> @ imm = #0x2
7009de38: e7ff         	b	0x7009de3a <Udma_flowConfig+0x15a> @ imm = #-0x2
;         }
7009de3a: e7ff         	b	0x7009de3c <Udma_flowConfig+0x15c> @ imm = #-0x2
7009de3c: 207f         	movs	r0, #0x7f
;         rmOptFlowReq.valid_params       = TISCI_MSG_VALUE_RM_UDMAP_FLOW_SIZE_THRESH0_VALID |
7009de3e: 9005         	str	r0, [sp, #0x14]
;         rmOptFlowReq.nav_id             = drvHandle->devIdUdma;
7009de40: 9819         	ldr	r0, [sp, #0x64]
7009de42: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009de46: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmOptFlowReq.flow_index         = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009de4a: 9818         	ldr	r0, [sp, #0x60]
7009de4c: 6840         	ldr	r0, [r0, #0x4]
7009de4e: 991c         	ldr	r1, [sp, #0x70]
7009de50: 4408         	add	r0, r1
7009de52: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         rmOptFlowReq.rx_size_thresh0    = (flowPrms->sizeThresh0 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009de56: 981b         	ldr	r0, [sp, #0x6c]
7009de58: 8c00         	ldrh	r0, [r0, #0x20]
7009de5a: 0940         	lsrs	r0, r0, #0x5
7009de5c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmOptFlowReq.rx_size_thresh1    = (flowPrms->sizeThresh1 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009de60: 981b         	ldr	r0, [sp, #0x6c]
7009de62: 8c40         	ldrh	r0, [r0, #0x22]
7009de64: 0940         	lsrs	r0, r0, #0x5
7009de66: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmOptFlowReq.rx_size_thresh2    = (flowPrms->sizeThresh2 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009de6a: 981b         	ldr	r0, [sp, #0x6c]
7009de6c: 8c80         	ldrh	r0, [r0, #0x24]
7009de6e: 0940         	lsrs	r0, r0, #0x5
7009de70: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmOptFlowReq.rx_fdq0_sz1_qnum   = flowPrms->fdq0Sz1Qnum;
7009de74: 981b         	ldr	r0, [sp, #0x6c]
7009de76: 8cc0         	ldrh	r0, [r0, #0x26]
7009de78: f8ad 0022    	strh.w	r0, [sp, #0x22]
;         rmOptFlowReq.rx_fdq0_sz2_qnum   = flowPrms->fdq0Sz2Qnum;
7009de7c: 981b         	ldr	r0, [sp, #0x6c]
7009de7e: 8d00         	ldrh	r0, [r0, #0x28]
7009de80: f8ad 0024    	strh.w	r0, [sp, #0x24]
;         rmOptFlowReq.rx_fdq0_sz3_qnum   = flowPrms->fdq0Sz3Qnum;
7009de84: 981b         	ldr	r0, [sp, #0x6c]
7009de86: 8d40         	ldrh	r0, [r0, #0x2a]
7009de88: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmOptFlowReq.rx_size_thresh_en  = flowPrms->sizeThreshEn;
7009de8c: 981b         	ldr	r0, [sp, #0x6c]
7009de8e: 7d80         	ldrb	r0, [r0, #0x16]
7009de90: f88d 0028    	strb.w	r0, [sp, #0x28]
7009de94: a803         	add	r0, sp, #0xc
7009de96: a901         	add	r1, sp, #0x4
7009de98: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal += Sciclient_rmUdmapFlowSizeThreshCfg(
7009de9c: f00c fd18    	bl	0x700aa8d0 <Sciclient_rmUdmapFlowSizeThreshCfg> @ imm = #0xca30
7009dea0: 4601         	mov	r1, r0
7009dea2: 981a         	ldr	r0, [sp, #0x68]
7009dea4: 4408         	add	r0, r1
7009dea6: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009dea8: 981a         	ldr	r0, [sp, #0x68]
7009deaa: b108         	cbz	r0, 0x7009deb0 <Udma_flowConfig+0x1d0> @ imm = #0x2
7009deac: e7ff         	b	0x7009deae <Udma_flowConfig+0x1ce> @ imm = #-0x2
;         }
7009deae: e7ff         	b	0x7009deb0 <Udma_flowConfig+0x1d0> @ imm = #-0x2
;     }
7009deb0: e7ff         	b	0x7009deb2 <Udma_flowConfig+0x1d2> @ imm = #-0x2
;     return (retVal);
7009deb2: 981a         	ldr	r0, [sp, #0x68]
7009deb4: b01e         	add	sp, #0x78
7009deb6: bd80         	pop	{r7, pc}
		...

7009dec0 <SOC_moduleSetClockFrequency>:
; {
7009dec0: b580         	push	{r7, lr}
7009dec2: b090         	sub	sp, #0x40
7009dec4: 900f         	str	r0, [sp, #0x3c]
7009dec6: 910e         	str	r1, [sp, #0x38]
7009dec8: 930d         	str	r3, [sp, #0x34]
7009deca: 920c         	str	r2, [sp, #0x30]
7009decc: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009dece: 9002         	str	r0, [sp, #0x8]
7009ded0: 900b         	str	r0, [sp, #0x2c]
;     uint32_t i = 0U;
7009ded2: 900a         	str	r0, [sp, #0x28]
;     uint64_t respClkRate = 0;
7009ded4: 9009         	str	r0, [sp, #0x24]
7009ded6: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009ded8: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009deda: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009dedc: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009dede: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009dee0: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009dee2: 980f         	ldr	r0, [sp, #0x3c]
;                                             clkId,
7009dee4: 990e         	ldr	r1, [sp, #0x38]
7009dee6: aa05         	add	r2, sp, #0x14
7009dee8: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009deec: f009 f9a0    	bl	0x700a7230 <Sciclient_pmModuleGetClkStatus> @ imm = #0x9340
7009def0: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009def2: 980b         	ldr	r0, [sp, #0x2c]
7009def4: b948         	cbnz	r0, 0x7009df0a <SOC_moduleSetClockFrequency+0x4a> @ imm = #0x12
7009def6: e7ff         	b	0x7009def8 <SOC_moduleSetClockFrequency+0x38> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009def8: 980f         	ldr	r0, [sp, #0x3c]
;                                                    clkId,
7009defa: 990e         	ldr	r1, [sp, #0x38]
7009defc: aa07         	add	r2, sp, #0x1c
7009defe: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009df02: f008 fb25    	bl	0x700a6550 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x864a
7009df06: 900b         	str	r0, [sp, #0x2c]
;     }
7009df08: e7ff         	b	0x7009df0a <SOC_moduleSetClockFrequency+0x4a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009df0a: 980b         	ldr	r0, [sp, #0x2c]
7009df0c: b970         	cbnz	r0, 0x7009df2c <SOC_moduleSetClockFrequency+0x6c> @ imm = #0x1c
7009df0e: e7ff         	b	0x7009df10 <SOC_moduleSetClockFrequency+0x50> @ imm = #-0x2
;         if(numParents > 1U)
7009df10: 9807         	ldr	r0, [sp, #0x1c]
7009df12: 2802         	cmp	r0, #0x2
7009df14: d309         	blo	0x7009df2a <SOC_moduleSetClockFrequency+0x6a> @ imm = #0x12
7009df16: e7ff         	b	0x7009df18 <SOC_moduleSetClockFrequency+0x58> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009df18: 980f         	ldr	r0, [sp, #0x3c]
;                                                     clkId,
7009df1a: 990e         	ldr	r1, [sp, #0x38]
7009df1c: aa04         	add	r2, sp, #0x10
7009df1e: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009df22: f008 ffa5    	bl	0x700a6e70 <Sciclient_pmGetModuleClkParent> @ imm = #0x8f4a
7009df26: 900b         	str	r0, [sp, #0x2c]
;         }
7009df28: e7ff         	b	0x7009df2a <SOC_moduleSetClockFrequency+0x6a> @ imm = #-0x2
;     }
7009df2a: e7ff         	b	0x7009df2c <SOC_moduleSetClockFrequency+0x6c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009df2c: 980b         	ldr	r0, [sp, #0x2c]
7009df2e: b960         	cbnz	r0, 0x7009df4a <SOC_moduleSetClockFrequency+0x8a> @ imm = #0x18
7009df30: e7ff         	b	0x7009df32 <SOC_moduleSetClockFrequency+0x72> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009df32: 980f         	ldr	r0, [sp, #0x3c]
;                                               clkId,
7009df34: 990e         	ldr	r1, [sp, #0x38]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009df36: 466b         	mov	r3, sp
7009df38: f04f 32ff    	mov.w	r2, #0xffffffff
7009df3c: 601a         	str	r2, [r3]
7009df3e: 2300         	movs	r3, #0x0
7009df40: 461a         	mov	r2, r3
7009df42: f009 ff9d    	bl	0x700a7e80 <Sciclient_pmModuleClkRequest> @ imm = #0x9f3a
7009df46: 900b         	str	r0, [sp, #0x2c]
;     }
7009df48: e7ff         	b	0x7009df4a <SOC_moduleSetClockFrequency+0x8a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009df4a: 980b         	ldr	r0, [sp, #0x2c]
7009df4c: 2800         	cmp	r0, #0x0
7009df4e: d14d         	bne	0x7009dfec <SOC_moduleSetClockFrequency+0x12c> @ imm = #0x9a
7009df50: e7ff         	b	0x7009df52 <SOC_moduleSetClockFrequency+0x92> @ imm = #-0x2
7009df52: 2000         	movs	r0, #0x0
;         foundParent = 0U;
7009df54: 9003         	str	r0, [sp, #0xc]
;         for(i=0U;i<numParents;i++)
7009df56: 900a         	str	r0, [sp, #0x28]
7009df58: e7ff         	b	0x7009df5a <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x2
7009df5a: 980a         	ldr	r0, [sp, #0x28]
7009df5c: 9907         	ldr	r1, [sp, #0x1c]
7009df5e: 4288         	cmp	r0, r1
7009df60: d243         	bhs	0x7009dfea <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x86
7009df62: e7ff         	b	0x7009df64 <SOC_moduleSetClockFrequency+0xa4> @ imm = #-0x2
;             if (numParents > 1U)
7009df64: 9807         	ldr	r0, [sp, #0x1c]
7009df66: 2802         	cmp	r0, #0x2
7009df68: d311         	blo	0x7009df8e <SOC_moduleSetClockFrequency+0xce> @ imm = #0x22
7009df6a: e7ff         	b	0x7009df6c <SOC_moduleSetClockFrequency+0xac> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009df6c: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009df6e: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkId+i+1,
7009df70: 9a0a         	ldr	r2, [sp, #0x28]
7009df72: 440a         	add	r2, r1
7009df74: 3201         	adds	r2, #0x1
7009df76: f04f 33ff    	mov.w	r3, #0xffffffff
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009df7a: f008 ffc9    	bl	0x700a6f10 <Sciclient_pmSetModuleClkParent> @ imm = #0x8f92
7009df7e: 900b         	str	r0, [sp, #0x2c]
;                 if (status == SystemP_SUCCESS)
7009df80: 980b         	ldr	r0, [sp, #0x2c]
7009df82: b918         	cbnz	r0, 0x7009df8c <SOC_moduleSetClockFrequency+0xcc> @ imm = #0x6
7009df84: e7ff         	b	0x7009df86 <SOC_moduleSetClockFrequency+0xc6> @ imm = #-0x2
7009df86: 2001         	movs	r0, #0x1
;                     moduleClockParentChanged = 1U;
7009df88: 9006         	str	r0, [sp, #0x18]
;                 }
7009df8a: e7ff         	b	0x7009df8c <SOC_moduleSetClockFrequency+0xcc> @ imm = #-0x2
;             }
7009df8c: e7ff         	b	0x7009df8e <SOC_moduleSetClockFrequency+0xce> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009df8e: 980b         	ldr	r0, [sp, #0x2c]
7009df90: b988         	cbnz	r0, 0x7009dfb6 <SOC_moduleSetClockFrequency+0xf6> @ imm = #0x22
7009df92: e7ff         	b	0x7009df94 <SOC_moduleSetClockFrequency+0xd4> @ imm = #-0x2
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009df94: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009df96: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkRate,
7009df98: 9a0c         	ldr	r2, [sp, #0x30]
7009df9a: 9b0d         	ldr	r3, [sp, #0x34]
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009df9c: 46ee         	mov	lr, sp
7009df9e: f04f 3cff    	mov.w	r12, #0xffffffff
7009dfa2: f8ce c004    	str.w	r12, [lr, #0x4]
7009dfa6: f10d 0c20    	add.w	r12, sp, #0x20
7009dfaa: f8ce c000    	str.w	r12, [lr]
7009dfae: f003 fc1f    	bl	0x700a17f0 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x383e
7009dfb2: 900b         	str	r0, [sp, #0x2c]
;             }
7009dfb4: e7ff         	b	0x7009dfb6 <SOC_moduleSetClockFrequency+0xf6> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009dfb6: 980b         	ldr	r0, [sp, #0x2c]
7009dfb8: b970         	cbnz	r0, 0x7009dfd8 <SOC_moduleSetClockFrequency+0x118> @ imm = #0x1c
7009dfba: e7ff         	b	0x7009dfbc <SOC_moduleSetClockFrequency+0xfc> @ imm = #-0x2
;                 if(respClkRate == clkRate)
7009dfbc: 9808         	ldr	r0, [sp, #0x20]
7009dfbe: 9909         	ldr	r1, [sp, #0x24]
7009dfc0: 9a0c         	ldr	r2, [sp, #0x30]
7009dfc2: 9b0d         	ldr	r3, [sp, #0x34]
7009dfc4: 4059         	eors	r1, r3
7009dfc6: ea80 0002    	eor.w	r0, r0, r2
7009dfca: 4308         	orrs	r0, r1
7009dfcc: b918         	cbnz	r0, 0x7009dfd6 <SOC_moduleSetClockFrequency+0x116> @ imm = #0x6
7009dfce: e7ff         	b	0x7009dfd0 <SOC_moduleSetClockFrequency+0x110> @ imm = #-0x2
7009dfd0: 2001         	movs	r0, #0x1
;                     foundParent = 1U;
7009dfd2: 9003         	str	r0, [sp, #0xc]
;                 }
7009dfd4: e7ff         	b	0x7009dfd6 <SOC_moduleSetClockFrequency+0x116> @ imm = #-0x2
;             }
7009dfd6: e7ff         	b	0x7009dfd8 <SOC_moduleSetClockFrequency+0x118> @ imm = #-0x2
;             if(foundParent)
7009dfd8: 9803         	ldr	r0, [sp, #0xc]
7009dfda: b108         	cbz	r0, 0x7009dfe0 <SOC_moduleSetClockFrequency+0x120> @ imm = #0x2
7009dfdc: e7ff         	b	0x7009dfde <SOC_moduleSetClockFrequency+0x11e> @ imm = #-0x2
;                 break; /* found a parent to set clock frequency, rebak form the loop */
7009dfde: e004         	b	0x7009dfea <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x8
;         }
7009dfe0: e7ff         	b	0x7009dfe2 <SOC_moduleSetClockFrequency+0x122> @ imm = #-0x2
;         for(i=0U;i<numParents;i++)
7009dfe2: 980a         	ldr	r0, [sp, #0x28]
7009dfe4: 3001         	adds	r0, #0x1
7009dfe6: 900a         	str	r0, [sp, #0x28]
7009dfe8: e7b7         	b	0x7009df5a <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x92
;     }
7009dfea: e7ff         	b	0x7009dfec <SOC_moduleSetClockFrequency+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009dfec: 980b         	ldr	r0, [sp, #0x2c]
7009dfee: b9d0         	cbnz	r0, 0x7009e026 <SOC_moduleSetClockFrequency+0x166> @ imm = #0x34
7009dff0: e7ff         	b	0x7009dff2 <SOC_moduleSetClockFrequency+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009dff2: 9803         	ldr	r0, [sp, #0xc]
7009dff4: 2801         	cmp	r0, #0x1
7009dff6: d111         	bne	0x7009e01c <SOC_moduleSetClockFrequency+0x15c> @ imm = #0x22
7009dff8: e7ff         	b	0x7009dffa <SOC_moduleSetClockFrequency+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009dffa: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009dffc: 990e         	ldr	r1, [sp, #0x38]
;                                                   clkRate,
7009dffe: 9a0c         	ldr	r2, [sp, #0x30]
7009e000: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009e002: 46ee         	mov	lr, sp
7009e004: f04f 3cff    	mov.w	r12, #0xffffffff
7009e008: f8ce c004    	str.w	r12, [lr, #0x4]
7009e00c: f44f 7c00    	mov.w	r12, #0x200
7009e010: f8ce c000    	str.w	r12, [lr]
7009e014: f005 f934    	bl	0x700a3280 <Sciclient_pmSetModuleClkFreq> @ imm = #0x5268
7009e018: 900b         	str	r0, [sp, #0x2c]
;         }
7009e01a: e003         	b	0x7009e024 <SOC_moduleSetClockFrequency+0x164> @ imm = #0x6
7009e01c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009e020: 900b         	str	r0, [sp, #0x2c]
7009e022: e7ff         	b	0x7009e024 <SOC_moduleSetClockFrequency+0x164> @ imm = #-0x2
;     }
7009e024: e7ff         	b	0x7009e026 <SOC_moduleSetClockFrequency+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e026: 980b         	ldr	r0, [sp, #0x2c]
7009e028: b988         	cbnz	r0, 0x7009e04e <SOC_moduleSetClockFrequency+0x18e> @ imm = #0x22
7009e02a: e7ff         	b	0x7009e02c <SOC_moduleSetClockFrequency+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009e02c: 9805         	ldr	r0, [sp, #0x14]
7009e02e: b968         	cbnz	r0, 0x7009e04c <SOC_moduleSetClockFrequency+0x18c> @ imm = #0x1a
7009e030: e7ff         	b	0x7009e032 <SOC_moduleSetClockFrequency+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009e032: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009e034: 990e         	ldr	r1, [sp, #0x38]
;                                                   clockStatus,
7009e036: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009e038: 46ec         	mov	r12, sp
7009e03a: f04f 33ff    	mov.w	r3, #0xffffffff
7009e03e: f8cc 3000    	str.w	r3, [r12]
7009e042: 2300         	movs	r3, #0x0
7009e044: f009 ff1c    	bl	0x700a7e80 <Sciclient_pmModuleClkRequest> @ imm = #0x9e38
7009e048: 900b         	str	r0, [sp, #0x2c]
;         }
7009e04a: e7ff         	b	0x7009e04c <SOC_moduleSetClockFrequency+0x18c> @ imm = #-0x2
;     }
7009e04c: e7ff         	b	0x7009e04e <SOC_moduleSetClockFrequency+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009e04e: 980b         	ldr	r0, [sp, #0x2c]
7009e050: b168         	cbz	r0, 0x7009e06e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #0x1a
7009e052: e7ff         	b	0x7009e054 <SOC_moduleSetClockFrequency+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009e054: 9806         	ldr	r0, [sp, #0x18]
7009e056: 2801         	cmp	r0, #0x1
7009e058: d108         	bne	0x7009e06c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #0x10
7009e05a: e7ff         	b	0x7009e05c <SOC_moduleSetClockFrequency+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009e05c: 980f         	ldr	r0, [sp, #0x3c]
;                                            clkId,
7009e05e: 990e         	ldr	r1, [sp, #0x38]
;                                            origParent,
7009e060: 9a04         	ldr	r2, [sp, #0x10]
7009e062: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009e066: f008 ff53    	bl	0x700a6f10 <Sciclient_pmSetModuleClkParent> @ imm = #0x8ea6
;         }
7009e06a: e7ff         	b	0x7009e06c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #-0x2
;     }
7009e06c: e7ff         	b	0x7009e06e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #-0x2
;     return status;
7009e06e: 980b         	ldr	r0, [sp, #0x2c]
7009e070: b010         	add	sp, #0x40
7009e072: bd80         	pop	{r7, pc}
		...

7009e080 <SOC_moduleSetClockFrequencyWithParent>:
; {
7009e080: b580         	push	{r7, lr}
7009e082: b092         	sub	sp, #0x48
7009e084: 460b         	mov	r3, r1
7009e086: 4684         	mov	r12, r0
7009e088: 9915         	ldr	r1, [sp, #0x54]
7009e08a: 9814         	ldr	r0, [sp, #0x50]
7009e08c: f8cd c044    	str.w	r12, [sp, #0x44]
7009e090: 9310         	str	r3, [sp, #0x40]
7009e092: 920f         	str	r2, [sp, #0x3c]
7009e094: 910d         	str	r1, [sp, #0x34]
7009e096: 900c         	str	r0, [sp, #0x30]
7009e098: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009e09a: 9002         	str	r0, [sp, #0x8]
7009e09c: 900b         	str	r0, [sp, #0x2c]
;     uint64_t respClkRate = 0;
7009e09e: 9009         	str	r0, [sp, #0x24]
7009e0a0: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009e0a2: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009e0a4: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009e0a6: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009e0a8: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009e0aa: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009e0ac: 9811         	ldr	r0, [sp, #0x44]
;                                             clkId,
7009e0ae: 9910         	ldr	r1, [sp, #0x40]
7009e0b0: aa05         	add	r2, sp, #0x14
7009e0b2: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009e0b6: f009 f8bb    	bl	0x700a7230 <Sciclient_pmModuleGetClkStatus> @ imm = #0x9176
7009e0ba: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009e0bc: 980b         	ldr	r0, [sp, #0x2c]
7009e0be: b948         	cbnz	r0, 0x7009e0d4 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #0x12
7009e0c0: e7ff         	b	0x7009e0c2 <SOC_moduleSetClockFrequencyWithParent+0x42> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009e0c2: 9811         	ldr	r0, [sp, #0x44]
;                                                    clkId,
7009e0c4: 9910         	ldr	r1, [sp, #0x40]
7009e0c6: aa07         	add	r2, sp, #0x1c
7009e0c8: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009e0cc: f008 fa40    	bl	0x700a6550 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x8480
7009e0d0: 900b         	str	r0, [sp, #0x2c]
;     }
7009e0d2: e7ff         	b	0x7009e0d4 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e0d4: 980b         	ldr	r0, [sp, #0x2c]
7009e0d6: b970         	cbnz	r0, 0x7009e0f6 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #0x1c
7009e0d8: e7ff         	b	0x7009e0da <SOC_moduleSetClockFrequencyWithParent+0x5a> @ imm = #-0x2
;         if(numParents > 1U)
7009e0da: 9807         	ldr	r0, [sp, #0x1c]
7009e0dc: 2802         	cmp	r0, #0x2
7009e0de: d309         	blo	0x7009e0f4 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #0x12
7009e0e0: e7ff         	b	0x7009e0e2 <SOC_moduleSetClockFrequencyWithParent+0x62> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009e0e2: 9811         	ldr	r0, [sp, #0x44]
;                                                     clkId,
7009e0e4: 9910         	ldr	r1, [sp, #0x40]
7009e0e6: aa04         	add	r2, sp, #0x10
7009e0e8: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009e0ec: f008 fec0    	bl	0x700a6e70 <Sciclient_pmGetModuleClkParent> @ imm = #0x8d80
7009e0f0: 900b         	str	r0, [sp, #0x2c]
;         }
7009e0f2: e7ff         	b	0x7009e0f4 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #-0x2
;     }
7009e0f4: e7ff         	b	0x7009e0f6 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e0f6: 980b         	ldr	r0, [sp, #0x2c]
7009e0f8: b960         	cbnz	r0, 0x7009e114 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #0x18
7009e0fa: e7ff         	b	0x7009e0fc <SOC_moduleSetClockFrequencyWithParent+0x7c> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009e0fc: 9811         	ldr	r0, [sp, #0x44]
;                                               clkId,
7009e0fe: 9910         	ldr	r1, [sp, #0x40]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009e100: 466b         	mov	r3, sp
7009e102: f04f 32ff    	mov.w	r2, #0xffffffff
7009e106: 601a         	str	r2, [r3]
7009e108: 2300         	movs	r3, #0x0
7009e10a: 461a         	mov	r2, r3
7009e10c: f009 feb8    	bl	0x700a7e80 <Sciclient_pmModuleClkRequest> @ imm = #0x9d70
7009e110: 900b         	str	r0, [sp, #0x2c]
;     }
7009e112: e7ff         	b	0x7009e114 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e114: 980b         	ldr	r0, [sp, #0x2c]
7009e116: b960         	cbnz	r0, 0x7009e132 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #0x18
7009e118: e7ff         	b	0x7009e11a <SOC_moduleSetClockFrequencyWithParent+0x9a> @ imm = #-0x2
;         if (clkParent > (clkId + numParents))
7009e11a: 980f         	ldr	r0, [sp, #0x3c]
7009e11c: 9910         	ldr	r1, [sp, #0x40]
7009e11e: 9a07         	ldr	r2, [sp, #0x1c]
7009e120: 4411         	add	r1, r2
7009e122: 4288         	cmp	r0, r1
7009e124: d904         	bls	0x7009e130 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #0x8
7009e126: e7ff         	b	0x7009e128 <SOC_moduleSetClockFrequencyWithParent+0xa8> @ imm = #-0x2
7009e128: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009e12c: 900b         	str	r0, [sp, #0x2c]
;         }
7009e12e: e7ff         	b	0x7009e130 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #-0x2
;     }
7009e130: e7ff         	b	0x7009e132 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e132: 980b         	ldr	r0, [sp, #0x2c]
7009e134: b9a8         	cbnz	r0, 0x7009e162 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #0x2a
7009e136: e7ff         	b	0x7009e138 <SOC_moduleSetClockFrequencyWithParent+0xb8> @ imm = #-0x2
;         if (clkParent != origParent)
7009e138: 980f         	ldr	r0, [sp, #0x3c]
7009e13a: 9904         	ldr	r1, [sp, #0x10]
7009e13c: 4288         	cmp	r0, r1
7009e13e: d00f         	beq	0x7009e160 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #0x1e
7009e140: e7ff         	b	0x7009e142 <SOC_moduleSetClockFrequencyWithParent+0xc2> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009e142: 9811         	ldr	r0, [sp, #0x44]
;                                                         clkId,
7009e144: 9910         	ldr	r1, [sp, #0x40]
;                                                         clkParent,
7009e146: 9a0f         	ldr	r2, [sp, #0x3c]
7009e148: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009e14c: f008 fee0    	bl	0x700a6f10 <Sciclient_pmSetModuleClkParent> @ imm = #0x8dc0
7009e150: 900b         	str	r0, [sp, #0x2c]
;             if (status == SystemP_SUCCESS)
7009e152: 980b         	ldr	r0, [sp, #0x2c]
7009e154: b918         	cbnz	r0, 0x7009e15e <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #0x6
7009e156: e7ff         	b	0x7009e158 <SOC_moduleSetClockFrequencyWithParent+0xd8> @ imm = #-0x2
7009e158: 2001         	movs	r0, #0x1
;                 moduleClockParentChanged = 1U;
7009e15a: 9006         	str	r0, [sp, #0x18]
;             }
7009e15c: e7ff         	b	0x7009e15e <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #-0x2
;         }
7009e15e: e7ff         	b	0x7009e160 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #-0x2
;     }
7009e160: e7ff         	b	0x7009e162 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e162: 980b         	ldr	r0, [sp, #0x2c]
7009e164: b988         	cbnz	r0, 0x7009e18a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #0x22
7009e166: e7ff         	b	0x7009e168 <SOC_moduleSetClockFrequencyWithParent+0xe8> @ imm = #-0x2
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009e168: 9811         	ldr	r0, [sp, #0x44]
;                                                 clkId,
7009e16a: 9910         	ldr	r1, [sp, #0x40]
;                                                 clkRate,
7009e16c: 9a0c         	ldr	r2, [sp, #0x30]
7009e16e: 9b0d         	ldr	r3, [sp, #0x34]
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009e170: 46ee         	mov	lr, sp
7009e172: f04f 3cff    	mov.w	r12, #0xffffffff
7009e176: f8ce c004    	str.w	r12, [lr, #0x4]
7009e17a: f10d 0c20    	add.w	r12, sp, #0x20
7009e17e: f8ce c000    	str.w	r12, [lr]
7009e182: f003 fb35    	bl	0x700a17f0 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x366a
7009e186: 900b         	str	r0, [sp, #0x2c]
;     }
7009e188: e7ff         	b	0x7009e18a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e18a: 980b         	ldr	r0, [sp, #0x2c]
7009e18c: b970         	cbnz	r0, 0x7009e1ac <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #0x1c
7009e18e: e7ff         	b	0x7009e190 <SOC_moduleSetClockFrequencyWithParent+0x110> @ imm = #-0x2
;         if(respClkRate == clkRate)
7009e190: 9808         	ldr	r0, [sp, #0x20]
7009e192: 9909         	ldr	r1, [sp, #0x24]
7009e194: 9a0c         	ldr	r2, [sp, #0x30]
7009e196: 9b0d         	ldr	r3, [sp, #0x34]
7009e198: 4059         	eors	r1, r3
7009e19a: ea80 0002    	eor.w	r0, r0, r2
7009e19e: 4308         	orrs	r0, r1
7009e1a0: b918         	cbnz	r0, 0x7009e1aa <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #0x6
7009e1a2: e7ff         	b	0x7009e1a4 <SOC_moduleSetClockFrequencyWithParent+0x124> @ imm = #-0x2
7009e1a4: 2001         	movs	r0, #0x1
;             foundParent = 1U;
7009e1a6: 9003         	str	r0, [sp, #0xc]
;         }
7009e1a8: e7ff         	b	0x7009e1aa <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #-0x2
;     }
7009e1aa: e7ff         	b	0x7009e1ac <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e1ac: 980b         	ldr	r0, [sp, #0x2c]
7009e1ae: b9d0         	cbnz	r0, 0x7009e1e6 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #0x34
7009e1b0: e7ff         	b	0x7009e1b2 <SOC_moduleSetClockFrequencyWithParent+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009e1b2: 9803         	ldr	r0, [sp, #0xc]
7009e1b4: 2801         	cmp	r0, #0x1
7009e1b6: d111         	bne	0x7009e1dc <SOC_moduleSetClockFrequencyWithParent+0x15c> @ imm = #0x22
7009e1b8: e7ff         	b	0x7009e1ba <SOC_moduleSetClockFrequencyWithParent+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009e1ba: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009e1bc: 9910         	ldr	r1, [sp, #0x40]
;                                                   clkRate,
7009e1be: 9a0c         	ldr	r2, [sp, #0x30]
7009e1c0: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009e1c2: 46ee         	mov	lr, sp
7009e1c4: f04f 3cff    	mov.w	r12, #0xffffffff
7009e1c8: f8ce c004    	str.w	r12, [lr, #0x4]
7009e1cc: f44f 7c00    	mov.w	r12, #0x200
7009e1d0: f8ce c000    	str.w	r12, [lr]
7009e1d4: f005 f854    	bl	0x700a3280 <Sciclient_pmSetModuleClkFreq> @ imm = #0x50a8
7009e1d8: 900b         	str	r0, [sp, #0x2c]
;         }
7009e1da: e003         	b	0x7009e1e4 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #0x6
7009e1dc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009e1e0: 900b         	str	r0, [sp, #0x2c]
7009e1e2: e7ff         	b	0x7009e1e4 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #-0x2
;     }
7009e1e4: e7ff         	b	0x7009e1e6 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e1e6: 980b         	ldr	r0, [sp, #0x2c]
7009e1e8: b988         	cbnz	r0, 0x7009e20e <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #0x22
7009e1ea: e7ff         	b	0x7009e1ec <SOC_moduleSetClockFrequencyWithParent+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009e1ec: 9805         	ldr	r0, [sp, #0x14]
7009e1ee: b968         	cbnz	r0, 0x7009e20c <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #0x1a
7009e1f0: e7ff         	b	0x7009e1f2 <SOC_moduleSetClockFrequencyWithParent+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009e1f2: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009e1f4: 9910         	ldr	r1, [sp, #0x40]
;                                                   clockStatus,
7009e1f6: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009e1f8: 46ec         	mov	r12, sp
7009e1fa: f04f 33ff    	mov.w	r3, #0xffffffff
7009e1fe: f8cc 3000    	str.w	r3, [r12]
7009e202: 2300         	movs	r3, #0x0
7009e204: f009 fe3c    	bl	0x700a7e80 <Sciclient_pmModuleClkRequest> @ imm = #0x9c78
7009e208: 900b         	str	r0, [sp, #0x2c]
;         }
7009e20a: e7ff         	b	0x7009e20c <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #-0x2
;     }
7009e20c: e7ff         	b	0x7009e20e <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009e20e: 980b         	ldr	r0, [sp, #0x2c]
7009e210: b168         	cbz	r0, 0x7009e22e <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #0x1a
7009e212: e7ff         	b	0x7009e214 <SOC_moduleSetClockFrequencyWithParent+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009e214: 9806         	ldr	r0, [sp, #0x18]
7009e216: 2801         	cmp	r0, #0x1
7009e218: d108         	bne	0x7009e22c <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #0x10
7009e21a: e7ff         	b	0x7009e21c <SOC_moduleSetClockFrequencyWithParent+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009e21c: 9811         	ldr	r0, [sp, #0x44]
;                                            clkId,
7009e21e: 9910         	ldr	r1, [sp, #0x40]
;                                            origParent,
7009e220: 9a04         	ldr	r2, [sp, #0x10]
7009e222: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009e226: f008 fe73    	bl	0x700a6f10 <Sciclient_pmSetModuleClkParent> @ imm = #0x8ce6
;         }
7009e22a: e7ff         	b	0x7009e22c <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #-0x2
;     }
7009e22c: e7ff         	b	0x7009e22e <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #-0x2
;     return status;
7009e22e: 980b         	ldr	r0, [sp, #0x2c]
7009e230: b012         	add	sp, #0x48
7009e232: bd80         	pop	{r7, pc}
		...

7009e240 <UART_close>:
; {
7009e240: b580         	push	{r7, lr}
7009e242: b08a         	sub	sp, #0x28
7009e244: 9009         	str	r0, [sp, #0x24]
;     config = (UART_Config *) handle;
7009e246: 9809         	ldr	r0, [sp, #0x24]
7009e248: 9008         	str	r0, [sp, #0x20]
;     if ((NULL != config) && (config->object != NULL) && (config->object->isOpen != FALSE))
7009e24a: 9808         	ldr	r0, [sp, #0x20]
7009e24c: 2800         	cmp	r0, #0x0
7009e24e: f000 80ce    	beq.w	0x7009e3ee <UART_close+0x1ae> @ imm = #0x19c
7009e252: e7ff         	b	0x7009e254 <UART_close+0x14> @ imm = #-0x2
7009e254: 9808         	ldr	r0, [sp, #0x20]
7009e256: 6840         	ldr	r0, [r0, #0x4]
7009e258: 2800         	cmp	r0, #0x0
7009e25a: f000 80c8    	beq.w	0x7009e3ee <UART_close+0x1ae> @ imm = #0x190
7009e25e: e7ff         	b	0x7009e260 <UART_close+0x20> @ imm = #-0x2
7009e260: 9808         	ldr	r0, [sp, #0x20]
7009e262: 6840         	ldr	r0, [r0, #0x4]
7009e264: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009e268: 2800         	cmp	r0, #0x0
7009e26a: f000 80c0    	beq.w	0x7009e3ee <UART_close+0x1ae> @ imm = #0x180
7009e26e: e7ff         	b	0x7009e270 <UART_close+0x30> @ imm = #-0x2
;         object = config->object;
7009e270: 9808         	ldr	r0, [sp, #0x20]
7009e272: 6840         	ldr	r0, [r0, #0x4]
7009e274: 9007         	str	r0, [sp, #0x1c]
;         attrs = config->attrs;
7009e276: 9808         	ldr	r0, [sp, #0x20]
7009e278: 6800         	ldr	r0, [r0]
7009e27a: 9006         	str	r0, [sp, #0x18]
;         object->uartLld_handle = &object->uartLld_object;
7009e27c: 9907         	ldr	r1, [sp, #0x1c]
7009e27e: f501 7022    	add.w	r0, r1, #0x288
7009e282: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle = object->uartLld_handle;
7009e286: 9807         	ldr	r0, [sp, #0x1c]
7009e288: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009e28c: 9005         	str	r0, [sp, #0x14]
;         DebugP_assert(NULL_PTR != object);
7009e28e: 9807         	ldr	r0, [sp, #0x1c]
7009e290: 2800         	cmp	r0, #0x0
7009e292: bf18         	it	ne
7009e294: 2001         	movne	r0, #0x1
7009e296: f64f 316f    	movw	r1, #0xfb6f
7009e29a: f2c7 010a    	movt	r1, #0x700a
7009e29e: 466a         	mov	r2, sp
7009e2a0: 6011         	str	r1, [r2]
7009e2a2: f64f 3182    	movw	r1, #0xfb82
7009e2a6: f2c7 010a    	movt	r1, #0x700a
7009e2aa: 9101         	str	r1, [sp, #0x4]
7009e2ac: f64f 426d    	movw	r2, #0xfc6d
7009e2b0: f2c7 020a    	movt	r2, #0x700a
7009e2b4: 9202         	str	r2, [sp, #0x8]
7009e2b6: f240 13c5    	movw	r3, #0x1c5
7009e2ba: f00a fcb1    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xa962
7009e2be: 9901         	ldr	r1, [sp, #0x4]
7009e2c0: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
7009e2c2: 9806         	ldr	r0, [sp, #0x18]
7009e2c4: 2800         	cmp	r0, #0x0
7009e2c6: bf18         	it	ne
7009e2c8: 2001         	movne	r0, #0x1
7009e2ca: f64f 33b8    	movw	r3, #0xfbb8
7009e2ce: f2c7 030a    	movt	r3, #0x700a
7009e2d2: 46ec         	mov	r12, sp
7009e2d4: f8cc 3000    	str.w	r3, [r12]
7009e2d8: f44f 73e3    	mov.w	r3, #0x1c6
7009e2dc: f00a fca0    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xa940
7009e2e0: 9901         	ldr	r1, [sp, #0x4]
7009e2e2: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009e2e4: f240 2330    	movw	r3, #0x230
7009e2e8: f2c7 030b    	movt	r3, #0x700b
7009e2ec: f853 0b04    	ldr	r0, [r3], #4
7009e2f0: 9303         	str	r3, [sp, #0xc]
7009e2f2: 2800         	cmp	r0, #0x0
7009e2f4: bf18         	it	ne
7009e2f6: 2001         	movne	r0, #0x1
7009e2f8: f64f 1388    	movw	r3, #0xf988
7009e2fc: f2c7 030a    	movt	r3, #0x700a
7009e300: 46ec         	mov	r12, sp
7009e302: f8cc 3000    	str.w	r3, [r12]
7009e306: f44f 73e4    	mov.w	r3, #0x1c8
7009e30a: f00a fc89    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xa912
7009e30e: 9803         	ldr	r0, [sp, #0xc]
7009e310: f04f 31ff    	mov.w	r1, #0xffffffff
;         (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009e314: f00a f9ec    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0xa3d8
;         UART_flushTxFifo(handle);
7009e318: 9809         	ldr	r0, [sp, #0x24]
7009e31a: f007 f879    	bl	0x700a5410 <UART_flushTxFifo> @ imm = #0x70f2
;         UART_intrDisable(attrs->baseAddr,
7009e31e: 9806         	ldr	r0, [sp, #0x18]
7009e320: 6800         	ldr	r0, [r0]
7009e322: 2107         	movs	r1, #0x7
7009e324: 9104         	str	r1, [sp, #0x10]
7009e326: f006 f8f3    	bl	0x700a4510 <UART_intrDisable> @ imm = #0x61e6
;         UART_intr2Disable(attrs->baseAddr, UART_INT2_TX_EMPTY);
7009e32a: 9806         	ldr	r0, [sp, #0x18]
7009e32c: 6800         	ldr	r0, [r0]
7009e32e: 2102         	movs	r1, #0x2
7009e330: f00e fc26    	bl	0x700acb80 <UART_intr2Disable> @ imm = #0xe84c
7009e334: 9904         	ldr	r1, [sp, #0x10]
;         (void)UART_operatingModeSelect(attrs->baseAddr, UART_OPER_MODE_DISABLED);
7009e336: 9806         	ldr	r0, [sp, #0x18]
7009e338: 6800         	ldr	r0, [r0]
7009e33a: f00e fc69    	bl	0x700acc10 <UART_operatingModeSelect> @ imm = #0xe8d2
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009e33e: 9807         	ldr	r0, [sp, #0x1c]
7009e340: 6b00         	ldr	r0, [r0, #0x30]
7009e342: 2803         	cmp	r0, #0x3
7009e344: d104         	bne	0x7009e350 <UART_close+0x110> @ imm = #0x8
7009e346: e7ff         	b	0x7009e348 <UART_close+0x108> @ imm = #-0x2
;             (void)UART_lld_deInitDma(uartLld_handle);
7009e348: 9805         	ldr	r0, [sp, #0x14]
7009e34a: f00b fbd9    	bl	0x700a9b00 <UART_lld_deInitDma> @ imm = #0xb7b2
;         }
7009e34e: e003         	b	0x7009e358 <UART_close+0x118> @ imm = #0x6
;             (void)UART_lld_deInit(uartLld_handle);
7009e350: 9805         	ldr	r0, [sp, #0x14]
7009e352: f00c f8dd    	bl	0x700aa510 <UART_lld_deInit> @ imm = #0xc1ba
7009e356: e7ff         	b	0x7009e358 <UART_close+0x118> @ imm = #-0x2
;         if(NULL != object->lock)
7009e358: 9807         	ldr	r0, [sp, #0x1c]
7009e35a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009e35e: b148         	cbz	r0, 0x7009e374 <UART_close+0x134> @ imm = #0x12
7009e360: e7ff         	b	0x7009e362 <UART_close+0x122> @ imm = #-0x2
;             SemaphoreP_destruct(&object->lockObj);
7009e362: 9807         	ldr	r0, [sp, #0x1c]
7009e364: 308c         	adds	r0, #0x8c
7009e366: f00f f953    	bl	0x700ad610 <SemaphoreP_destruct> @ imm = #0xf2a6
;             object->lock = NULL;
7009e36a: 9907         	ldr	r1, [sp, #0x1c]
7009e36c: 2000         	movs	r0, #0x0
7009e36e: f8c1 0088    	str.w	r0, [r1, #0x88]
;         }
7009e372: e7ff         	b	0x7009e374 <UART_close+0x134> @ imm = #-0x2
;         if(NULL != object->readTransferSem)
7009e374: 9807         	ldr	r0, [sp, #0x1c]
7009e376: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009e37a: b160         	cbz	r0, 0x7009e396 <UART_close+0x156> @ imm = #0x18
7009e37c: e7ff         	b	0x7009e37e <UART_close+0x13e> @ imm = #-0x2
;             SemaphoreP_destruct(&object->readTransferSemObj);
7009e37e: 9807         	ldr	r0, [sp, #0x1c]
7009e380: f500 7094    	add.w	r0, r0, #0x128
7009e384: f00f f944    	bl	0x700ad610 <SemaphoreP_destruct> @ imm = #0xf288
;             object->readTransferSem = NULL;
7009e388: 9907         	ldr	r1, [sp, #0x1c]
7009e38a: 2000         	movs	r0, #0x0
7009e38c: f8c1 0124    	str.w	r0, [r1, #0x124]
;             uartLld_handle->readTransferMutex = NULL;
7009e390: 9905         	ldr	r1, [sp, #0x14]
7009e392: 6588         	str	r0, [r1, #0x58]
;         }
7009e394: e7ff         	b	0x7009e396 <UART_close+0x156> @ imm = #-0x2
;         if(NULL != object->writeTransferSem)
7009e396: 9807         	ldr	r0, [sp, #0x1c]
7009e398: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009e39c: b160         	cbz	r0, 0x7009e3b8 <UART_close+0x178> @ imm = #0x18
7009e39e: e7ff         	b	0x7009e3a0 <UART_close+0x160> @ imm = #-0x2
;             SemaphoreP_destruct(&object->writeTransferSemObj);
7009e3a0: 9807         	ldr	r0, [sp, #0x1c]
7009e3a2: f500 70e2    	add.w	r0, r0, #0x1c4
7009e3a6: f00f f933    	bl	0x700ad610 <SemaphoreP_destruct> @ imm = #0xf266
;             object->writeTransferSem = NULL;
7009e3aa: 9907         	ldr	r1, [sp, #0x1c]
7009e3ac: 2000         	movs	r0, #0x0
7009e3ae: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;             uartLld_handle->writeTransferMutex = NULL;
7009e3b2: 9905         	ldr	r1, [sp, #0x14]
7009e3b4: 65c8         	str	r0, [r1, #0x5c]
;         }
7009e3b6: e7ff         	b	0x7009e3b8 <UART_close+0x178> @ imm = #-0x2
;         if(NULL != object->hwiHandle)
7009e3b8: 9807         	ldr	r0, [sp, #0x1c]
7009e3ba: f8d0 025c    	ldr.w	r0, [r0, #0x25c]
7009e3be: b150         	cbz	r0, 0x7009e3d6 <UART_close+0x196> @ imm = #0x14
7009e3c0: e7ff         	b	0x7009e3c2 <UART_close+0x182> @ imm = #-0x2
;             HwiP_destruct(&object->hwiObj);
7009e3c2: 9807         	ldr	r0, [sp, #0x1c]
7009e3c4: f500 7018    	add.w	r0, r0, #0x260
7009e3c8: f00f fd62    	bl	0x700ade90 <HwiP_destruct> @ imm = #0xfac4
;             object->hwiHandle = NULL;
7009e3cc: 9907         	ldr	r1, [sp, #0x1c]
7009e3ce: 2000         	movs	r0, #0x0
7009e3d0: f8c1 025c    	str.w	r0, [r1, #0x25c]
;         }
7009e3d4: e7ff         	b	0x7009e3d6 <UART_close+0x196> @ imm = #-0x2
;         object->isOpen = FALSE;
7009e3d6: 9907         	ldr	r1, [sp, #0x1c]
7009e3d8: 2000         	movs	r0, #0x0
7009e3da: f8c1 0084    	str.w	r0, [r1, #0x84]
;         SemaphoreP_post(&gUartDrvObj.lockObj);
7009e3de: f240 2030    	movw	r0, #0x230
7009e3e2: f2c7 000b    	movt	r0, #0x700b
7009e3e6: 3004         	adds	r0, #0x4
7009e3e8: f00b fcda    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0xb9b4
;     }
7009e3ec: e7ff         	b	0x7009e3ee <UART_close+0x1ae> @ imm = #-0x2
;     return;
7009e3ee: b00a         	add	sp, #0x28
7009e3f0: bd80         	pop	{r7, pc}
		...
7009e3fe: 0000         	movs	r0, r0

7009e400 <UART_lld_controllerIsr>:
; {
7009e400: b580         	push	{r7, lr}
7009e402: b086         	sub	sp, #0x18
7009e404: 9005         	str	r0, [sp, #0x14]
7009e406: 2001         	movs	r0, #0x1
;     uint32_t            retVal = TRUE;
7009e408: 9001         	str	r0, [sp, #0x4]
;     if(NULL != args)
7009e40a: 9805         	ldr	r0, [sp, #0x14]
7009e40c: 2800         	cmp	r0, #0x0
7009e40e: f000 80c8    	beq.w	0x7009e5a2 <UART_lld_controllerIsr+0x1a2> @ imm = #0x190
7009e412: e7ff         	b	0x7009e414 <UART_lld_controllerIsr+0x14> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
7009e414: 9805         	ldr	r0, [sp, #0x14]
7009e416: 9002         	str	r0, [sp, #0x8]
;         while (retVal == TRUE)
7009e418: e7ff         	b	0x7009e41a <UART_lld_controllerIsr+0x1a> @ imm = #-0x2
7009e41a: 9801         	ldr	r0, [sp, #0x4]
7009e41c: 2801         	cmp	r0, #0x1
7009e41e: f040 80bf    	bne.w	0x7009e5a0 <UART_lld_controllerIsr+0x1a0> @ imm = #0x17e
7009e422: e7ff         	b	0x7009e424 <UART_lld_controllerIsr+0x24> @ imm = #-0x2
;             intType = UART_getIntrIdentityStatus(hUart->baseAddr);
7009e424: 9802         	ldr	r0, [sp, #0x8]
7009e426: 6800         	ldr	r0, [r0]
7009e428: f00c ff92    	bl	0x700ab350 <UART_getIntrIdentityStatus> @ imm = #0xcf24
7009e42c: 9004         	str	r0, [sp, #0x10]
;             if ((intType & UART_INTID_RX_THRES_REACH) == UART_INTID_RX_THRES_REACH)
7009e42e: f89d 0010    	ldrb.w	r0, [sp, #0x10]
7009e432: 0740         	lsls	r0, r0, #0x1d
7009e434: 2800         	cmp	r0, #0x0
7009e436: d561         	bpl	0x7009e4fc <UART_lld_controllerIsr+0xfc> @ imm = #0xc2
7009e438: e7ff         	b	0x7009e43a <UART_lld_controllerIsr+0x3a> @ imm = #-0x2
;                 if ((intType & UART_INTID_RX_LINE_STAT_ERROR) ==
7009e43a: 9804         	ldr	r0, [sp, #0x10]
7009e43c: f000 0006    	and	r0, r0, #0x6
7009e440: 2806         	cmp	r0, #0x6
7009e442: d104         	bne	0x7009e44e <UART_lld_controllerIsr+0x4e> @ imm = #0x8
7009e444: e7ff         	b	0x7009e446 <UART_lld_controllerIsr+0x46> @ imm = #-0x2
;                     (void)UART_procLineStatusErr(hUart);
7009e446: 9802         	ldr	r0, [sp, #0x8]
7009e448: f002 fc52    	bl	0x700a0cf0 <UART_procLineStatusErr> @ imm = #0x28a4
;                 }
7009e44c: e055         	b	0x7009e4fa <UART_lld_controllerIsr+0xfa> @ imm = #0xaa
;                     if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
7009e44e: 9804         	ldr	r0, [sp, #0x10]
7009e450: f000 000c    	and	r0, r0, #0xc
7009e454: 280c         	cmp	r0, #0xc
7009e456: d10a         	bne	0x7009e46e <UART_lld_controllerIsr+0x6e> @ imm = #0x14
7009e458: e7ff         	b	0x7009e45a <UART_lld_controllerIsr+0x5a> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e45a: 9802         	ldr	r0, [sp, #0x8]
7009e45c: 6800         	ldr	r0, [r0]
7009e45e: 2105         	movs	r1, #0x5
7009e460: f006 f856    	bl	0x700a4510 <UART_intrDisable> @ imm = #0x60ac
;                         hUart->rxTimeoutCnt++;
7009e464: 9902         	ldr	r1, [sp, #0x8]
7009e466: 6a08         	ldr	r0, [r1, #0x20]
7009e468: 3001         	adds	r0, #0x1
7009e46a: 6208         	str	r0, [r1, #0x20]
;                     }
7009e46c: e7ff         	b	0x7009e46e <UART_lld_controllerIsr+0x6e> @ imm = #-0x2
;                     if (hUart->readSizeRemaining > 0U)
7009e46e: 9802         	ldr	r0, [sp, #0x8]
7009e470: 69c0         	ldr	r0, [r0, #0x1c]
7009e472: b3a8         	cbz	r0, 0x7009e4e0 <UART_lld_controllerIsr+0xe0> @ imm = #0x6a
7009e474: e7ff         	b	0x7009e476 <UART_lld_controllerIsr+0x76> @ imm = #-0x2
;                         hUart->readSizeRemaining = UART_readData(hUart, hUart->readSizeRemaining);
7009e476: 9802         	ldr	r0, [sp, #0x8]
7009e478: 69c1         	ldr	r1, [r0, #0x1c]
7009e47a: f00a fb91    	bl	0x700a8ba0 <UART_readData> @ imm = #0xa722
7009e47e: 9902         	ldr	r1, [sp, #0x8]
7009e480: 61c8         	str	r0, [r1, #0x1c]
;                         if ((hUart->readSizeRemaining == 0U) ||
7009e482: 9802         	ldr	r0, [sp, #0x8]
7009e484: 69c0         	ldr	r0, [r0, #0x1c]
7009e486: b130         	cbz	r0, 0x7009e496 <UART_lld_controllerIsr+0x96> @ imm = #0xc
7009e488: e7ff         	b	0x7009e48a <UART_lld_controllerIsr+0x8a> @ imm = #-0x2
;                             (hUart->hUartInit->readReturnMode == UART_READ_RETURN_MODE_PARTIAL))
7009e48a: 9802         	ldr	r0, [sp, #0x8]
7009e48c: 6840         	ldr	r0, [r0, #0x4]
7009e48e: 6940         	ldr	r0, [r0, #0x14]
;                         if ((hUart->readSizeRemaining == 0U) ||
7009e490: 2801         	cmp	r0, #0x1
7009e492: d11e         	bne	0x7009e4d2 <UART_lld_controllerIsr+0xd2> @ imm = #0x3c
7009e494: e7ff         	b	0x7009e496 <UART_lld_controllerIsr+0x96> @ imm = #-0x2
;                             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e496: 9802         	ldr	r0, [sp, #0x8]
7009e498: 6800         	ldr	r0, [r0]
7009e49a: 2105         	movs	r1, #0x5
7009e49c: f006 f838    	bl	0x700a4510 <UART_intrDisable> @ imm = #0x6070
;                             hUart->readBuf = (uint8_t *)hUart->readBuf - hUart->readCount;
7009e4a0: 9902         	ldr	r1, [sp, #0x8]
7009e4a2: 6948         	ldr	r0, [r1, #0x14]
7009e4a4: 698a         	ldr	r2, [r1, #0x18]
7009e4a6: 1a80         	subs	r0, r0, r2
7009e4a8: 6148         	str	r0, [r1, #0x14]
;                             if (hUart->readTrans.buf != NULL)
7009e4aa: 9802         	ldr	r0, [sp, #0x8]
7009e4ac: 6a80         	ldr	r0, [r0, #0x28]
7009e4ae: b138         	cbz	r0, 0x7009e4c0 <UART_lld_controllerIsr+0xc0> @ imm = #0xe
7009e4b0: e7ff         	b	0x7009e4b2 <UART_lld_controllerIsr+0xb2> @ imm = #-0x2
;                                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
7009e4b2: 9902         	ldr	r1, [sp, #0x8]
7009e4b4: 6988         	ldr	r0, [r1, #0x18]
7009e4b6: 62c8         	str	r0, [r1, #0x2c]
;                                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
7009e4b8: 9902         	ldr	r1, [sp, #0x8]
7009e4ba: 2000         	movs	r0, #0x0
7009e4bc: 6348         	str	r0, [r1, #0x34]
;                             }
7009e4be: e7ff         	b	0x7009e4c0 <UART_lld_controllerIsr+0xc0> @ imm = #-0x2
;                             hUart->hUartInit->readCompleteCallbackFxn(hUart);
7009e4c0: 9802         	ldr	r0, [sp, #0x8]
7009e4c2: 6841         	ldr	r1, [r0, #0x4]
7009e4c4: 6dc9         	ldr	r1, [r1, #0x5c]
7009e4c6: 4788         	blx	r1
;                             UART_lld_Transaction_deInit(&hUart->readTrans);
7009e4c8: 9802         	ldr	r0, [sp, #0x8]
7009e4ca: 3028         	adds	r0, #0x28
7009e4cc: f00e fea8    	bl	0x700ad220 <UART_lld_Transaction_deInit> @ imm = #0xed50
;                         }
7009e4d0: e005         	b	0x7009e4de <UART_lld_controllerIsr+0xde> @ imm = #0xa
;                             UART_intrEnable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e4d2: 9802         	ldr	r0, [sp, #0x8]
7009e4d4: 6800         	ldr	r0, [r0]
7009e4d6: 2105         	movs	r1, #0x5
7009e4d8: f005 ff3a    	bl	0x700a4350 <UART_intrEnable> @ imm = #0x5e74
7009e4dc: e7ff         	b	0x7009e4de <UART_lld_controllerIsr+0xde> @ imm = #-0x2
;                     }
7009e4de: e00b         	b	0x7009e4f8 <UART_lld_controllerIsr+0xf8> @ imm = #0x16
;                         (void)UART_getChar(hUart->baseAddr, &rdData);
7009e4e0: 9802         	ldr	r0, [sp, #0x8]
7009e4e2: 6800         	ldr	r0, [r0]
7009e4e4: f10d 010f    	add.w	r1, sp, #0xf
7009e4e8: f00b fec2    	bl	0x700aa270 <UART_getChar> @ imm = #0xbd84
;                         UART_intrDisable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e4ec: 9802         	ldr	r0, [sp, #0x8]
7009e4ee: 6800         	ldr	r0, [r0]
7009e4f0: 2105         	movs	r1, #0x5
7009e4f2: f006 f80d    	bl	0x700a4510 <UART_intrDisable> @ imm = #0x601a
7009e4f6: e7ff         	b	0x7009e4f8 <UART_lld_controllerIsr+0xf8> @ imm = #-0x2
7009e4f8: e7ff         	b	0x7009e4fa <UART_lld_controllerIsr+0xfa> @ imm = #-0x2
;             }
7009e4fa: e050         	b	0x7009e59e <UART_lld_controllerIsr+0x19e> @ imm = #0xa0
;             else if ((intType & UART_INTID_TX_THRES_REACH) == UART_INTID_TX_THRES_REACH)
7009e4fc: f89d 0010    	ldrb.w	r0, [sp, #0x10]
7009e500: 0780         	lsls	r0, r0, #0x1e
7009e502: 2800         	cmp	r0, #0x0
7009e504: d534         	bpl	0x7009e570 <UART_lld_controllerIsr+0x170> @ imm = #0x68
7009e506: e7ff         	b	0x7009e508 <UART_lld_controllerIsr+0x108> @ imm = #-0x2
;                 if (hUart->writeSizeRemaining > 0U)
7009e508: 9802         	ldr	r0, [sp, #0x8]
7009e50a: 6900         	ldr	r0, [r0, #0x10]
7009e50c: b348         	cbz	r0, 0x7009e562 <UART_lld_controllerIsr+0x162> @ imm = #0x52
7009e50e: e7ff         	b	0x7009e510 <UART_lld_controllerIsr+0x110> @ imm = #-0x2
;                     hUart->writeSizeRemaining = (uint32_t)UART_writeData(hUart, (hUart->writeSizeRemaining));
7009e510: 9802         	ldr	r0, [sp, #0x8]
7009e512: 6901         	ldr	r1, [r0, #0x10]
7009e514: f00b fedc    	bl	0x700aa2d0 <UART_writeData> @ imm = #0xbdb8
7009e518: 9902         	ldr	r1, [sp, #0x8]
7009e51a: 6108         	str	r0, [r1, #0x10]
;                     if ((hUart->writeSizeRemaining) == 0U)
7009e51c: 9802         	ldr	r0, [sp, #0x8]
7009e51e: 6900         	ldr	r0, [r0, #0x10]
7009e520: b9f0         	cbnz	r0, 0x7009e560 <UART_lld_controllerIsr+0x160> @ imm = #0x3c
7009e522: e7ff         	b	0x7009e524 <UART_lld_controllerIsr+0x124> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
7009e524: 9802         	ldr	r0, [sp, #0x8]
7009e526: 6800         	ldr	r0, [r0]
7009e528: 2102         	movs	r1, #0x2
7009e52a: f005 fff1    	bl	0x700a4510 <UART_intrDisable> @ imm = #0x5fe2
;                         hUart->writeBuf = (const void *)((uint8_t *)hUart->writeBuf - hUart->writeCount);
7009e52e: 9902         	ldr	r1, [sp, #0x8]
7009e530: 6888         	ldr	r0, [r1, #0x8]
7009e532: 68ca         	ldr	r2, [r1, #0xc]
7009e534: 1a80         	subs	r0, r0, r2
7009e536: 6088         	str	r0, [r1, #0x8]
;                         if (hUart->writeTrans.buf != NULL)
7009e538: 9802         	ldr	r0, [sp, #0x8]
7009e53a: 6bc0         	ldr	r0, [r0, #0x3c]
7009e53c: b138         	cbz	r0, 0x7009e54e <UART_lld_controllerIsr+0x14e> @ imm = #0xe
7009e53e: e7ff         	b	0x7009e540 <UART_lld_controllerIsr+0x140> @ imm = #-0x2
;                             hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
7009e540: 9902         	ldr	r1, [sp, #0x8]
7009e542: 68c8         	ldr	r0, [r1, #0xc]
7009e544: 6408         	str	r0, [r1, #0x40]
;                             hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
7009e546: 9902         	ldr	r1, [sp, #0x8]
7009e548: 2000         	movs	r0, #0x0
7009e54a: 6488         	str	r0, [r1, #0x48]
;                         }
7009e54c: e7ff         	b	0x7009e54e <UART_lld_controllerIsr+0x14e> @ imm = #-0x2
;                         hUart->hUartInit->writeCompleteCallbackFxn(hUart);
7009e54e: 9802         	ldr	r0, [sp, #0x8]
7009e550: 6841         	ldr	r1, [r0, #0x4]
7009e552: 6e09         	ldr	r1, [r1, #0x60]
7009e554: 4788         	blx	r1
;                         UART_lld_Transaction_deInit(&hUart->writeTrans);
7009e556: 9802         	ldr	r0, [sp, #0x8]
7009e558: 303c         	adds	r0, #0x3c
7009e55a: f00e fe61    	bl	0x700ad220 <UART_lld_Transaction_deInit> @ imm = #0xecc2
;                     }
7009e55e: e7ff         	b	0x7009e560 <UART_lld_controllerIsr+0x160> @ imm = #-0x2
;                 }
7009e560: e005         	b	0x7009e56e <UART_lld_controllerIsr+0x16e> @ imm = #0xa
;                     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
7009e562: 9802         	ldr	r0, [sp, #0x8]
7009e564: 6800         	ldr	r0, [r0]
7009e566: 2102         	movs	r1, #0x2
7009e568: f005 ffd2    	bl	0x700a4510 <UART_intrDisable> @ imm = #0x5fa4
7009e56c: e7ff         	b	0x7009e56e <UART_lld_controllerIsr+0x16e> @ imm = #-0x2
;             }
7009e56e: e015         	b	0x7009e59c <UART_lld_controllerIsr+0x19c> @ imm = #0x2a
;             else if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
7009e570: 9804         	ldr	r0, [sp, #0x10]
7009e572: f000 000c    	and	r0, r0, #0xc
7009e576: 280c         	cmp	r0, #0xc
7009e578: d10c         	bne	0x7009e594 <UART_lld_controllerIsr+0x194> @ imm = #0x18
7009e57a: e7ff         	b	0x7009e57c <UART_lld_controllerIsr+0x17c> @ imm = #-0x2
;                 if (FALSE == UART_checkCharsAvailInFifo(hUart->baseAddr))
7009e57c: 9802         	ldr	r0, [sp, #0x8]
7009e57e: 6800         	ldr	r0, [r0]
7009e580: f00c fd2e    	bl	0x700aafe0 <UART_checkCharsAvailInFifo> @ imm = #0xca5c
7009e584: b928         	cbnz	r0, 0x7009e592 <UART_lld_controllerIsr+0x192> @ imm = #0xa
7009e586: e7ff         	b	0x7009e588 <UART_lld_controllerIsr+0x188> @ imm = #-0x2
;                     UART_i2310WA(hUart->baseAddr);
7009e588: 9802         	ldr	r0, [sp, #0x8]
7009e58a: 6800         	ldr	r0, [r0]
7009e58c: f00d fb88    	bl	0x700abca0 <UART_i2310WA> @ imm = #0xd710
;                 }
7009e590: e7ff         	b	0x7009e592 <UART_lld_controllerIsr+0x192> @ imm = #-0x2
;             }
7009e592: e002         	b	0x7009e59a <UART_lld_controllerIsr+0x19a> @ imm = #0x4
7009e594: 2000         	movs	r0, #0x0
;                 retVal = FALSE;
7009e596: 9001         	str	r0, [sp, #0x4]
7009e598: e7ff         	b	0x7009e59a <UART_lld_controllerIsr+0x19a> @ imm = #-0x2
7009e59a: e7ff         	b	0x7009e59c <UART_lld_controllerIsr+0x19c> @ imm = #-0x2
7009e59c: e7ff         	b	0x7009e59e <UART_lld_controllerIsr+0x19e> @ imm = #-0x2
;         while (retVal == TRUE)
7009e59e: e73c         	b	0x7009e41a <UART_lld_controllerIsr+0x1a> @ imm = #-0x188
;     }
7009e5a0: e000         	b	0x7009e5a4 <UART_lld_controllerIsr+0x1a4> @ imm = #0x0
7009e5a2: e7ff         	b	0x7009e5a4 <UART_lld_controllerIsr+0x1a4> @ imm = #-0x2
; }
7009e5a4: b006         	add	sp, #0x18
7009e5a6: bd80         	pop	{r7, pc}

7009e5a8 <free>:
7009e5a8: e3500000     	cmp	r0, #0
7009e5ac: 012fff1e     	bxeq	lr
7009e5b0: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
7009e5b4: e1a04000     	mov	r4, r0
7009e5b8: e59f0180     	ldr	r0, [pc, #0x180]        @ 0x7009e740 <free+0x198>
7009e5bc: e5900000     	ldr	r0, [r0]
7009e5c0: e12fff30     	blx	r0
7009e5c4: e59f6178     	ldr	r6, [pc, #0x178]        @ 0x7009e744 <free+0x19c>
7009e5c8: e2444008     	sub	r4, r4, #8
7009e5cc: e3a02000     	mov	r2, #0
7009e5d0: e5960000     	ldr	r0, [r6]
7009e5d4: e1a01006     	mov	r1, r6
7009e5d8: e1a05002     	mov	r5, r2
7009e5dc: e1510004     	cmp	r1, r4
7009e5e0: e3c03001     	bic	r3, r0, #1
7009e5e4: e1a02001     	mov	r2, r1
7009e5e8: e0863003     	add	r3, r6, r3
7009e5ec: e2836008     	add	r6, r3, #8
7009e5f0: 3afffff6     	blo	0x7009e5d0 <free+0x28>  @ imm = #-0x28
7009e5f4: e59f214c     	ldr	r2, [pc, #0x14c]        @ 0x7009e748 <free+0x1a0>
7009e5f8: e59f3144     	ldr	r3, [pc, #0x144]        @ 0x7009e744 <free+0x19c>
7009e5fc: e3520007     	cmp	r2, #7
7009e600: e0827003     	add	r7, r2, r3
7009e604: 82473008     	subhi	r3, r7, #8
7009e608: e1560003     	cmp	r6, r3
7009e60c: 83006000     	movwhi	r6, #0x0
7009e610: e1510004     	cmp	r1, r4
7009e614: 1a000045     	bne	0x7009e730 <free+0x188> @ imm = #0x114
7009e618: e2100001     	ands	r0, r0, #1
7009e61c: 0a000043     	beq	0x7009e730 <free+0x188> @ imm = #0x10c
7009e620: e3550000     	cmp	r5, #0
7009e624: 0a000009     	beq	0x7009e650 <free+0xa8>  @ imm = #0x24
7009e628: e5951000     	ldr	r1, [r5]
7009e62c: e3a00000     	mov	r0, #0
7009e630: e3a07000     	mov	r7, #0
7009e634: e3110001     	tst	r1, #1
7009e638: 01a00005     	moveq	r0, r5
7009e63c: e3560000     	cmp	r6, #0
7009e640: 1a000005     	bne	0x7009e65c <free+0xb4>  @ imm = #0x14
7009e644: e3110001     	tst	r1, #1
7009e648: 0a00000b     	beq	0x7009e67c <free+0xd4>  @ imm = #0x2c
7009e64c: ea000022     	b	0x7009e6dc <free+0x134> @ imm = #0x88
7009e650: e3a00000     	mov	r0, #0
7009e654: e3560000     	cmp	r6, #0
7009e658: 0a00001f     	beq	0x7009e6dc <free+0x134> @ imm = #0x7c
7009e65c: e5d61000     	ldrb	r1, [r6]
7009e660: e3a07000     	mov	r7, #0
7009e664: e3a08000     	mov	r8, #0
7009e668: e3110001     	tst	r1, #1
7009e66c: 01a07006     	moveq	r7, r6
7009e670: e3500000     	cmp	r0, #0
7009e674: 0a000007     	beq	0x7009e698 <free+0xf0>  @ imm = #0x1c
7009e678: e1a05000     	mov	r5, r0
7009e67c: e1a00005     	mov	r0, r5
7009e680: eb003763     	bl	0x700ac414 <free_list_remove> @ imm = #0xdd8c
7009e684: e3a08001     	mov	r8, #1
7009e688: e3570000     	cmp	r7, #0
7009e68c: 0a00001d     	beq	0x7009e708 <free+0x160> @ imm = #0x74
7009e690: e1a06007     	mov	r6, r7
7009e694: ea000002     	b	0x7009e6a4 <free+0xfc>  @ imm = #0x8
7009e698: e3a05000     	mov	r5, #0
7009e69c: e3570000     	cmp	r7, #0
7009e6a0: 0a00000d     	beq	0x7009e6dc <free+0x134> @ imm = #0x34
7009e6a4: e1a00006     	mov	r0, r6
7009e6a8: eb003759     	bl	0x700ac414 <free_list_remove> @ imm = #0xdd64
7009e6ac: e3580000     	cmp	r8, #0
7009e6b0: 0a00000c     	beq	0x7009e6e8 <free+0x140> @ imm = #0x30
7009e6b4: e5950000     	ldr	r0, [r5]
7009e6b8: e5941000     	ldr	r1, [r4]
7009e6bc: e5962000     	ldr	r2, [r6]
7009e6c0: e3c00001     	bic	r0, r0, #1
7009e6c4: e3c11001     	bic	r1, r1, #1
7009e6c8: e3c22001     	bic	r2, r2, #1
7009e6cc: e0800001     	add	r0, r0, r1
7009e6d0: e0800002     	add	r0, r0, r2
7009e6d4: e2800010     	add	r0, r0, #16
7009e6d8: ea000010     	b	0x7009e720 <free+0x178> @ imm = #0x40
7009e6dc: e5940000     	ldr	r0, [r4]
7009e6e0: e3c00001     	bic	r0, r0, #1
7009e6e4: ea000005     	b	0x7009e700 <free+0x158> @ imm = #0x14
7009e6e8: e5940000     	ldr	r0, [r4]
7009e6ec: e5961000     	ldr	r1, [r6]
7009e6f0: e3c00001     	bic	r0, r0, #1
7009e6f4: e3c11001     	bic	r1, r1, #1
7009e6f8: e0800001     	add	r0, r0, r1
7009e6fc: e2800008     	add	r0, r0, #8
7009e700: e5840000     	str	r0, [r4]
7009e704: ea000007     	b	0x7009e728 <free+0x180> @ imm = #0x1c
7009e708: e5950000     	ldr	r0, [r5]
7009e70c: e5941000     	ldr	r1, [r4]
7009e710: e3c00001     	bic	r0, r0, #1
7009e714: e3c11001     	bic	r1, r1, #1
7009e718: e0800001     	add	r0, r0, r1
7009e71c: e2800008     	add	r0, r0, #8
7009e720: e1a04005     	mov	r4, r5
7009e724: e5850000     	str	r0, [r5]
7009e728: e1a00004     	mov	r0, r4
7009e72c: eb0034fb     	bl	0x700abb20 <free_list_insert> @ imm = #0xd3ec
7009e730: e59f0014     	ldr	r0, [pc, #0x14]         @ 0x7009e74c <free+0x1a4>
7009e734: e5900000     	ldr	r0, [r0]
7009e738: e8bd41f0     	pop	{r4, r5, r6, r7, r8, lr}
7009e73c: e12fff10     	bx	r0
7009e740: a4 04 0b 70  	.word	0x700b04a4
7009e744: 00 50 08 70  	.word	0x70085000
7009e748: 00 00 01 00  	.word	0x00010000
7009e74c: a8 04 0b 70  	.word	0x700b04a8

7009e750 <UART_write>:
; {
7009e750: b580         	push	{r7, lr}
7009e752: b08e         	sub	sp, #0x38
7009e754: 900d         	str	r0, [sp, #0x34]
7009e756: 910c         	str	r1, [sp, #0x30]
7009e758: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS, semStatus = SystemP_SUCCESS;
7009e75a: 900b         	str	r0, [sp, #0x2c]
7009e75c: 900a         	str	r0, [sp, #0x28]
;     if ((NULL_PTR == handle) || (NULL_PTR == trans))
7009e75e: 980d         	ldr	r0, [sp, #0x34]
7009e760: b118         	cbz	r0, 0x7009e76a <UART_write+0x1a> @ imm = #0x6
7009e762: e7ff         	b	0x7009e764 <UART_write+0x14> @ imm = #-0x2
7009e764: 980c         	ldr	r0, [sp, #0x30]
7009e766: b920         	cbnz	r0, 0x7009e772 <UART_write+0x22> @ imm = #0x8
7009e768: e7ff         	b	0x7009e76a <UART_write+0x1a> @ imm = #-0x2
7009e76a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009e76e: 900b         	str	r0, [sp, #0x2c]
;     }
7009e770: e7ff         	b	0x7009e772 <UART_write+0x22> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009e772: 980b         	ldr	r0, [sp, #0x2c]
7009e774: 2800         	cmp	r0, #0x0
7009e776: d141         	bne	0x7009e7fc <UART_write+0xac> @ imm = #0x82
7009e778: e7ff         	b	0x7009e77a <UART_write+0x2a> @ imm = #-0x2
;         config  = (UART_Config *) handle;
7009e77a: 980d         	ldr	r0, [sp, #0x34]
7009e77c: 9009         	str	r0, [sp, #0x24]
;         object  = config->object;
7009e77e: 9809         	ldr	r0, [sp, #0x24]
7009e780: 6840         	ldr	r0, [r0, #0x4]
7009e782: 9008         	str	r0, [sp, #0x20]
;         attrs   = config->attrs;
7009e784: 9809         	ldr	r0, [sp, #0x24]
7009e786: 6800         	ldr	r0, [r0]
7009e788: 9007         	str	r0, [sp, #0x1c]
;         prms    = &config->object->prms;
7009e78a: 9809         	ldr	r0, [sp, #0x24]
7009e78c: 6840         	ldr	r0, [r0, #0x4]
7009e78e: 3004         	adds	r0, #0x4
7009e790: 9006         	str	r0, [sp, #0x18]
;         uartLld_handle = object->uartLld_handle;
7009e792: 9808         	ldr	r0, [sp, #0x20]
7009e794: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009e798: 9004         	str	r0, [sp, #0x10]
;         object->writeTrans = trans;
7009e79a: 980c         	ldr	r0, [sp, #0x30]
7009e79c: 9908         	ldr	r1, [sp, #0x20]
7009e79e: f8c1 0080    	str.w	r0, [r1, #0x80]
;         DebugP_assert(NULL_PTR != object);
7009e7a2: 9808         	ldr	r0, [sp, #0x20]
7009e7a4: 2800         	cmp	r0, #0x0
7009e7a6: bf18         	it	ne
7009e7a8: 2001         	movne	r0, #0x1
7009e7aa: f64f 316f    	movw	r1, #0xfb6f
7009e7ae: f2c7 010a    	movt	r1, #0x700a
7009e7b2: 466a         	mov	r2, sp
7009e7b4: 6011         	str	r1, [r2]
7009e7b6: f64f 3182    	movw	r1, #0xfb82
7009e7ba: f2c7 010a    	movt	r1, #0x700a
7009e7be: 9101         	str	r1, [sp, #0x4]
7009e7c0: f64f 4262    	movw	r2, #0xfc62
7009e7c4: f2c7 020a    	movt	r2, #0x700a
7009e7c8: 9202         	str	r2, [sp, #0x8]
7009e7ca: f44f 7305    	mov.w	r3, #0x214
7009e7ce: f00a fa27    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xa44e
7009e7d2: 9901         	ldr	r1, [sp, #0x4]
7009e7d4: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
7009e7d6: 9807         	ldr	r0, [sp, #0x1c]
7009e7d8: 2800         	cmp	r0, #0x0
7009e7da: bf18         	it	ne
7009e7dc: 2001         	movne	r0, #0x1
7009e7de: f64f 33b8    	movw	r3, #0xfbb8
7009e7e2: f2c7 030a    	movt	r3, #0x700a
7009e7e6: 46ec         	mov	r12, sp
7009e7e8: f8cc 3000    	str.w	r3, [r12]
7009e7ec: f240 2315    	movw	r3, #0x215
7009e7f0: f00a fa16    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0xa42c
;         extendedParams.args = trans->args;
7009e7f4: 980c         	ldr	r0, [sp, #0x30]
7009e7f6: 6900         	ldr	r0, [r0, #0x10]
7009e7f8: 9003         	str	r0, [sp, #0xc]
;     }
7009e7fa: e7ff         	b	0x7009e7fc <UART_write+0xac> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009e7fc: 980b         	ldr	r0, [sp, #0x2c]
7009e7fe: b950         	cbnz	r0, 0x7009e816 <UART_write+0xc6> @ imm = #0x14
7009e800: e7ff         	b	0x7009e802 <UART_write+0xb2> @ imm = #-0x2
;         if (TRUE == prms->skipIntrReg)
7009e802: 9806         	ldr	r0, [sp, #0x18]
7009e804: 6b80         	ldr	r0, [r0, #0x38]
7009e806: 2801         	cmp	r0, #0x1
7009e808: d104         	bne	0x7009e814 <UART_write+0xc4> @ imm = #0x8
7009e80a: e7ff         	b	0x7009e80c <UART_write+0xbc> @ imm = #-0x2
7009e80c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009e810: 900b         	str	r0, [sp, #0x2c]
;         }
7009e812: e7ff         	b	0x7009e814 <UART_write+0xc4> @ imm = #-0x2
;     }
7009e814: e7ff         	b	0x7009e816 <UART_write+0xc6> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009e816: 980b         	ldr	r0, [sp, #0x2c]
7009e818: 2800         	cmp	r0, #0x0
7009e81a: d168         	bne	0x7009e8ee <UART_write+0x19e> @ imm = #0xd0
7009e81c: e7ff         	b	0x7009e81e <UART_write+0xce> @ imm = #-0x2
;         key = HwiP_disable();
7009e81e: f00f ef28    	blx	0x700ae670 <HwiP_disable> @ imm = #0xfe50
7009e822: 9005         	str	r0, [sp, #0x14]
;         HwiP_restore(key);
7009e824: 9805         	ldr	r0, [sp, #0x14]
7009e826: f00f ef44    	blx	0x700ae6b0 <HwiP_restore> @ imm = #0xfe88
;         uartLld_handle->state = UART_STATE_READY;
7009e82a: 9904         	ldr	r1, [sp, #0x10]
7009e82c: 2001         	movs	r0, #0x1
7009e82e: 6548         	str	r0, [r1, #0x54]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
7009e830: 9806         	ldr	r0, [sp, #0x18]
7009e832: 6ac0         	ldr	r0, [r0, #0x2c]
7009e834: 2801         	cmp	r0, #0x1
7009e836: d005         	beq	0x7009e844 <UART_write+0xf4> @ imm = #0xa
7009e838: e7ff         	b	0x7009e83a <UART_write+0xea> @ imm = #-0x2
;             (UART_CONFIG_MODE_DMA == prms->transferMode))
7009e83a: 9806         	ldr	r0, [sp, #0x18]
7009e83c: 6ac0         	ldr	r0, [r0, #0x2c]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
7009e83e: 2803         	cmp	r0, #0x3
7009e840: d146         	bne	0x7009e8d0 <UART_write+0x180> @ imm = #0x8c
7009e842: e7ff         	b	0x7009e844 <UART_write+0xf4> @ imm = #-0x2
;             if (UART_CONFIG_MODE_INTERRUPT == prms->transferMode)
7009e844: 9806         	ldr	r0, [sp, #0x18]
7009e846: 6ac0         	ldr	r0, [r0, #0x2c]
7009e848: 2801         	cmp	r0, #0x1
7009e84a: d109         	bne	0x7009e860 <UART_write+0x110> @ imm = #0x12
7009e84c: e7ff         	b	0x7009e84e <UART_write+0xfe> @ imm = #-0x2
;                 status = UART_lld_writeIntr(uartLld_handle, trans->buf, trans->count, &extendedParams);
7009e84e: 9804         	ldr	r0, [sp, #0x10]
7009e850: 9a0c         	ldr	r2, [sp, #0x30]
7009e852: 6811         	ldr	r1, [r2]
7009e854: 6852         	ldr	r2, [r2, #0x4]
7009e856: ab03         	add	r3, sp, #0xc
7009e858: f006 fca2    	bl	0x700a51a0 <UART_lld_writeIntr> @ imm = #0x6944
7009e85c: 900b         	str	r0, [sp, #0x2c]
;             }
7009e85e: e008         	b	0x7009e872 <UART_write+0x122> @ imm = #0x10
;                 status = UART_lld_writeDma(uartLld_handle, trans->buf, trans->count, &extendedParams);
7009e860: 9804         	ldr	r0, [sp, #0x10]
7009e862: 9a0c         	ldr	r2, [sp, #0x30]
7009e864: 6811         	ldr	r1, [r2]
7009e866: 6852         	ldr	r2, [r2, #0x4]
7009e868: ab03         	add	r3, sp, #0xc
7009e86a: f006 fa91    	bl	0x700a4d90 <UART_lld_writeDma> @ imm = #0x6522
7009e86e: 900b         	str	r0, [sp, #0x2c]
7009e870: e7ff         	b	0x7009e872 <UART_write+0x122> @ imm = #-0x2
;             if (SystemP_SUCCESS == status)
7009e872: 980b         	ldr	r0, [sp, #0x2c]
7009e874: bb58         	cbnz	r0, 0x7009e8ce <UART_write+0x17e> @ imm = #0x56
7009e876: e7ff         	b	0x7009e878 <UART_write+0x128> @ imm = #-0x2
;                 if(object->prms.writeMode == UART_TRANSFER_MODE_BLOCKING)
7009e878: 9808         	ldr	r0, [sp, #0x20]
7009e87a: 69c0         	ldr	r0, [r0, #0x1c]
7009e87c: bb18         	cbnz	r0, 0x7009e8c6 <UART_write+0x176> @ imm = #0x46
7009e87e: e7ff         	b	0x7009e880 <UART_write+0x130> @ imm = #-0x2
;                     semStatus = SemaphoreP_pend(&object->writeTransferSemObj, trans->timeout);
7009e880: 9808         	ldr	r0, [sp, #0x20]
7009e882: f500 70e2    	add.w	r0, r0, #0x1c4
7009e886: 990c         	ldr	r1, [sp, #0x30]
7009e888: 6889         	ldr	r1, [r1, #0x8]
7009e88a: f009 ff31    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x9e62
7009e88e: 900a         	str	r0, [sp, #0x28]
;                     if (semStatus == SystemP_SUCCESS)
7009e890: 980a         	ldr	r0, [sp, #0x28]
7009e892: b960         	cbnz	r0, 0x7009e8ae <UART_write+0x15e> @ imm = #0x18
7009e894: e7ff         	b	0x7009e896 <UART_write+0x146> @ imm = #-0x2
;                         if (trans->status == (uint32_t)UART_STATUS_SUCCESS)
7009e896: 980c         	ldr	r0, [sp, #0x30]
7009e898: 68c0         	ldr	r0, [r0, #0xc]
7009e89a: b918         	cbnz	r0, 0x7009e8a4 <UART_write+0x154> @ imm = #0x6
7009e89c: e7ff         	b	0x7009e89e <UART_write+0x14e> @ imm = #-0x2
7009e89e: 2000         	movs	r0, #0x0
;                             status = SystemP_SUCCESS;
7009e8a0: 900b         	str	r0, [sp, #0x2c]
;                         }
7009e8a2: e003         	b	0x7009e8ac <UART_write+0x15c> @ imm = #0x6
7009e8a4: f04f 30ff    	mov.w	r0, #0xffffffff
;                             status = SystemP_FAILURE;
7009e8a8: 900b         	str	r0, [sp, #0x2c]
7009e8aa: e7ff         	b	0x7009e8ac <UART_write+0x15c> @ imm = #-0x2
;                     }
7009e8ac: e00a         	b	0x7009e8c4 <UART_write+0x174> @ imm = #0x14
;                         trans->status = UART_TRANSFER_TIMEOUT;
7009e8ae: 990c         	ldr	r1, [sp, #0x30]
7009e8b0: f06f 0001    	mvn	r0, #0x1
7009e8b4: 60c8         	str	r0, [r1, #0xc]
;                         (void)UART_writeCancelNoCB(uartLld_handle);
7009e8b6: 9804         	ldr	r0, [sp, #0x10]
7009e8b8: f009 fbba    	bl	0x700a8030 <UART_writeCancelNoCB> @ imm = #0x9774
7009e8bc: f04f 30ff    	mov.w	r0, #0xffffffff
;                         status = SystemP_FAILURE;
7009e8c0: 900b         	str	r0, [sp, #0x2c]
7009e8c2: e7ff         	b	0x7009e8c4 <UART_write+0x174> @ imm = #-0x2
;                 }
7009e8c4: e002         	b	0x7009e8cc <UART_write+0x17c> @ imm = #0x4
7009e8c6: 2000         	movs	r0, #0x0
;                     status = SystemP_SUCCESS;
7009e8c8: 900b         	str	r0, [sp, #0x2c]
7009e8ca: e7ff         	b	0x7009e8cc <UART_write+0x17c> @ imm = #-0x2
;             }
7009e8cc: e7ff         	b	0x7009e8ce <UART_write+0x17e> @ imm = #-0x2
;         }
7009e8ce: e00d         	b	0x7009e8ec <UART_write+0x19c> @ imm = #0x1a
;             status = UART_lld_write(uartLld_handle, trans->buf, trans->count, trans->timeout, &extendedParams);
7009e8d0: 9804         	ldr	r0, [sp, #0x10]
7009e8d2: 9b0c         	ldr	r3, [sp, #0x30]
7009e8d4: 6819         	ldr	r1, [r3]
7009e8d6: 685a         	ldr	r2, [r3, #0x4]
7009e8d8: 689b         	ldr	r3, [r3, #0x8]
7009e8da: 46ee         	mov	lr, sp
7009e8dc: f10d 0c0c    	add.w	r12, sp, #0xc
7009e8e0: f8ce c000    	str.w	r12, [lr]
7009e8e4: f005 ffd4    	bl	0x700a4890 <UART_lld_write> @ imm = #0x5fa8
7009e8e8: 900b         	str	r0, [sp, #0x2c]
7009e8ea: e7ff         	b	0x7009e8ec <UART_write+0x19c> @ imm = #-0x2
;     }
7009e8ec: e7ff         	b	0x7009e8ee <UART_write+0x19e> @ imm = #-0x2
;     return (status);
7009e8ee: 980b         	ldr	r0, [sp, #0x2c]
7009e8f0: b00e         	add	sp, #0x38
7009e8f2: bd80         	pop	{r7, pc}

7009e8f4 <memalign>:
7009e8f4: e92d4bf0     	push	{r4, r5, r6, r7, r8, r9, r11, lr}
7009e8f8: e3510000     	cmp	r1, #0
7009e8fc: 0a000058     	beq	0x7009ea64 <memalign+0x170> @ imm = #0x160
7009e900: e59f5178     	ldr	r5, [pc, #0x178]        @ 0x7009ea80 <memalign+0x18c>
7009e904: e3a04000     	mov	r4, #0
7009e908: e3a08000     	mov	r8, #0
7009e90c: e3550007     	cmp	r5, #7
7009e910: 82454008     	subhi	r4, r5, #8
7009e914: e1540001     	cmp	r4, r1
7009e918: 3a000056     	blo	0x7009ea78 <memalign+0x184> @ imm = #0x158
7009e91c: e2402001     	sub	r2, r0, #1
7009e920: e59f315c     	ldr	r3, [pc, #0x15c]        @ 0x7009ea84 <memalign+0x190>
7009e924: e3a07008     	mov	r7, #8
7009e928: e2816007     	add	r6, r1, #7
7009e92c: e1100002     	tst	r0, r2
7009e930: 01a07000     	moveq	r7, r0
7009e934: e3500007     	cmp	r0, #7
7009e938: e5930000     	ldr	r0, [r3]
7009e93c: e3a02008     	mov	r2, #8
7009e940: 91a07002     	movls	r7, r2
7009e944: e12fff30     	blx	r0
7009e948: e59f0138     	ldr	r0, [pc, #0x138]        @ 0x7009ea88 <memalign+0x194>
7009e94c: e5d01000     	ldrb	r1, [r0]
7009e950: e3510000     	cmp	r1, #0
7009e954: 1a00000a     	bne	0x7009e984 <memalign+0x90> @ imm = #0x28
7009e958: e3a01000     	mov	r1, #0
7009e95c: e3550009     	cmp	r5, #9
7009e960: 3a000003     	blo	0x7009e974 <memalign+0x80> @ imm = #0xc
7009e964: e59f1120     	ldr	r1, [pc, #0x120]        @ 0x7009ea8c <memalign+0x198>
7009e968: e3a02000     	mov	r2, #0
7009e96c: e5814000     	str	r4, [r1]
7009e970: e5812008     	str	r2, [r1, #0x8]
7009e974: e3a03001     	mov	r3, #1
7009e978: e59f2110     	ldr	r2, [pc, #0x110]        @ 0x7009ea90 <memalign+0x19c>
7009e97c: e5821000     	str	r1, [r2]
7009e980: e5c03000     	strb	r3, [r0]
7009e984: e59f5104     	ldr	r5, [pc, #0x104]        @ 0x7009ea90 <memalign+0x19c>
7009e988: e3c69007     	bic	r9, r6, #7
7009e98c: e2470001     	sub	r0, r7, #1
7009e990: e2671000     	rsb	r1, r7, #0
7009e994: e5956000     	ldr	r6, [r5]
7009e998: e3560000     	cmp	r6, #0
7009e99c: 0a000032     	beq	0x7009ea6c <memalign+0x178> @ imm = #0xc8
7009e9a0: e2865008     	add	r5, r6, #8
7009e9a4: e0802005     	add	r2, r0, r5
7009e9a8: e0024001     	and	r4, r2, r1
7009e9ac: e1550004     	cmp	r5, r4
7009e9b0: 0a00000c     	beq	0x7009e9e8 <memalign+0xf4> @ imm = #0x30
7009e9b4: e2862010     	add	r2, r6, #16
7009e9b8: e2443008     	sub	r3, r4, #8
7009e9bc: e1520003     	cmp	r2, r3
7009e9c0: 9a000001     	bls	0x7009e9cc <memalign+0xd8> @ imm = #0x4
7009e9c4: e0844007     	add	r4, r4, r7
7009e9c8: eafffffa     	b	0x7009e9b8 <memalign+0xc4> @ imm = #-0x18
7009e9cc: e5962000     	ldr	r2, [r6]
7009e9d0: e0843009     	add	r3, r4, r9
7009e9d4: e3c22001     	bic	r2, r2, #1
7009e9d8: e0852002     	add	r2, r5, r2
7009e9dc: e1520003     	cmp	r2, r3
7009e9e0: 3affffeb     	blo	0x7009e994 <memalign+0xa0> @ imm = #-0x54
7009e9e4: ea000004     	b	0x7009e9fc <memalign+0x108> @ imm = #0x10
7009e9e8: e5962000     	ldr	r2, [r6]
7009e9ec: e3c22001     	bic	r2, r2, #1
7009e9f0: e1520009     	cmp	r2, r9
7009e9f4: baffffe6     	blt	0x7009e994 <memalign+0xa0> @ imm = #-0x68
7009e9f8: e1a04005     	mov	r4, r5
7009e9fc: e1a00006     	mov	r0, r6
7009ea00: eb003683     	bl	0x700ac414 <free_list_remove> @ imm = #0xda0c
7009ea04: e1540005     	cmp	r4, r5
7009ea08: 0a00000d     	beq	0x7009ea44 <memalign+0x150> @ imm = #0x34
7009ea0c: e5960000     	ldr	r0, [r6]
7009ea10: e0441005     	sub	r1, r4, r5
7009ea14: e2411008     	sub	r1, r1, #8
7009ea18: e1a04006     	mov	r4, r6
7009ea1c: e3c00001     	bic	r0, r0, #1
7009ea20: e3c12001     	bic	r2, r1, #1
7009ea24: e0400001     	sub	r0, r0, r1
7009ea28: e3800001     	orr	r0, r0, #1
7009ea2c: e2400008     	sub	r0, r0, #8
7009ea30: e6841002     	str	r1, [r4], r2
7009ea34: e5a40008     	str	r0, [r4, #0x8]!
7009ea38: e1a00006     	mov	r0, r6
7009ea3c: eb003437     	bl	0x700abb20 <free_list_insert> @ imm = #0xd0dc
7009ea40: e1a06004     	mov	r6, r4
7009ea44: e1a00006     	mov	r0, r6
7009ea48: e1a01009     	mov	r1, r9
7009ea4c: eb001f6c     	bl	0x700a6804 <split>      @ imm = #0x7db0
7009ea50: e59f003c     	ldr	r0, [pc, #0x3c]         @ 0x7009ea94 <memalign+0x1a0>
7009ea54: e5900000     	ldr	r0, [r0]
7009ea58: e12fff30     	blx	r0
7009ea5c: e2868008     	add	r8, r6, #8
7009ea60: ea000004     	b	0x7009ea78 <memalign+0x184> @ imm = #0x10
7009ea64: e3a08000     	mov	r8, #0
7009ea68: ea000002     	b	0x7009ea78 <memalign+0x184> @ imm = #0x8
7009ea6c: e59f0020     	ldr	r0, [pc, #0x20]         @ 0x7009ea94 <memalign+0x1a0>
7009ea70: e5900000     	ldr	r0, [r0]
7009ea74: e12fff30     	blx	r0
7009ea78: e1a00008     	mov	r0, r8
7009ea7c: e8bd8bf0     	pop	{r4, r5, r6, r7, r8, r9, r11, pc}
7009ea80: 00 00 01 00  	.word	0x00010000
7009ea84: a4 04 0b 70  	.word	0x700b04a4
7009ea88: 34 05 0b 70  	.word	0x700b0534
7009ea8c: 00 50 08 70  	.word	0x70085000
7009ea90: c4 4f 08 70  	.word	0x70084fc4
7009ea94: a8 04 0b 70  	.word	0x700b04a8
7009ea98: 00 00 00 00  	.word	0x00000000
7009ea9c: 00 00 00 00  	.word	0x00000000

7009eaa0 <Sciclient_rmClearInterruptRoute>:
; {
7009eaa0: b580         	push	{r7, lr}
7009eaa2: b08e         	sub	sp, #0x38
7009eaa4: 900d         	str	r0, [sp, #0x34]
7009eaa6: 910c         	str	r1, [sp, #0x30]
7009eaa8: 920b         	str	r2, [sp, #0x2c]
7009eaaa: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009eaac: 9001         	str	r0, [sp, #0x4]
7009eaae: 900a         	str	r0, [sp, #0x28]
7009eab0: f241 0101    	movw	r1, #0x1001
;     uint16_t messageType = TISCI_MSG_RM_IRQ_RELEASE;
7009eab4: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
7009eab8: 9008         	str	r0, [sp, #0x20]
7009eaba: 9007         	str	r0, [sp, #0x1c]
7009eabc: 9006         	str	r0, [sp, #0x18]
7009eabe: 9005         	str	r0, [sp, #0x14]
7009eac0: 9004         	str	r0, [sp, #0x10]
7009eac2: 9003         	str	r0, [sp, #0xc]
7009eac4: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
7009eac6: 980d         	ldr	r0, [sp, #0x34]
7009eac8: b118         	cbz	r0, 0x7009ead2 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #0x6
7009eaca: e7ff         	b	0x7009eacc <Sciclient_rmClearInterruptRoute+0x2c> @ imm = #-0x2
7009eacc: 980c         	ldr	r0, [sp, #0x30]
7009eace: b920         	cbnz	r0, 0x7009eada <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #0x8
7009ead0: e7ff         	b	0x7009ead2 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #-0x2
7009ead2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009ead6: 900a         	str	r0, [sp, #0x28]
;     }
7009ead8: e7ff         	b	0x7009eada <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009eada: 980a         	ldr	r0, [sp, #0x28]
7009eadc: b968         	cbnz	r0, 0x7009eafa <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0x1a
7009eade: e7ff         	b	0x7009eae0 <Sciclient_rmClearInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009eae0: 980d         	ldr	r0, [sp, #0x34]
7009eae2: 6880         	ldr	r0, [r0, #0x8]
7009eae4: f04f 4100    	mov.w	r1, #0x80000000
7009eae8: f00e f802    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0xe004
;     if (r == SystemP_SUCCESS &&
7009eaec: b128         	cbz	r0, 0x7009eafa <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0xa
7009eaee: e7ff         	b	0x7009eaf0 <Sciclient_rmClearInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
7009eaf0: 980d         	ldr	r0, [sp, #0x34]
7009eaf2: 7ec0         	ldrb	r0, [r0, #0x1b]
7009eaf4: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
7009eaf8: e00f         	b	0x7009eb1a <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
7009eafa: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009eafe: f006 fff7    	bl	0x700a5af0 <Sciclient_getCurrentContext> @ imm = #0x6fee
7009eb02: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009eb06: f24f 0068    	movw	r0, #0xf068
7009eb0a: f2c7 000a    	movt	r0, #0x700a
7009eb0e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009eb12: 6840         	ldr	r0, [r0, #0x4]
7009eb14: f88d 0025    	strb.w	r0, [sp, #0x25]
7009eb18: e7ff         	b	0x7009eb1a <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009eb1a: 980a         	ldr	r0, [sp, #0x28]
7009eb1c: b960         	cbnz	r0, 0x7009eb38 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0x18
7009eb1e: e7ff         	b	0x7009eb20 <Sciclient_rmClearInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009eb20: 980d         	ldr	r0, [sp, #0x34]
7009eb22: 6880         	ldr	r0, [r0, #0x8]
7009eb24: 2104         	movs	r1, #0x4
7009eb26: f00d ffe3    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0xdfc6
;     if (r == SystemP_SUCCESS &&
7009eb2a: b128         	cbz	r0, 0x7009eb38 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0xa
7009eb2c: e7ff         	b	0x7009eb2e <Sciclient_rmClearInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
7009eb2e: 980d         	ldr	r0, [sp, #0x34]
7009eb30: 8a80         	ldrh	r0, [r0, #0x14]
7009eb32: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
7009eb36: e003         	b	0x7009eb40 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #0x6
7009eb38: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
7009eb3a: f8ad 0018    	strh.w	r0, [sp, #0x18]
7009eb3e: e7ff         	b	0x7009eb40 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009eb40: 980a         	ldr	r0, [sp, #0x28]
7009eb42: 2800         	cmp	r0, #0x0
7009eb44: d175         	bne	0x7009ec32 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #0xea
7009eb46: e7ff         	b	0x7009eb48 <Sciclient_rmClearInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
7009eb48: 980d         	ldr	r0, [sp, #0x34]
7009eb4a: 6880         	ldr	r0, [r0, #0x8]
7009eb4c: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
7009eb4e: f89d 0025    	ldrb.w	r0, [sp, #0x25]
7009eb52: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
7009eb56: 980d         	ldr	r0, [sp, #0x34]
7009eb58: 8980         	ldrh	r0, [r0, #0xc]
7009eb5a: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
7009eb5e: 980d         	ldr	r0, [sp, #0x34]
7009eb60: 89c0         	ldrh	r0, [r0, #0xe]
7009eb62: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
7009eb66: 980d         	ldr	r0, [sp, #0x34]
7009eb68: 8a00         	ldrh	r0, [r0, #0x10]
7009eb6a: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
7009eb6e: 980d         	ldr	r0, [sp, #0x34]
7009eb70: 8a40         	ldrh	r0, [r0, #0x12]
7009eb72: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
7009eb76: 980d         	ldr	r0, [sp, #0x34]
7009eb78: 8b00         	ldrh	r0, [r0, #0x18]
7009eb7a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
7009eb7e: 980d         	ldr	r0, [sp, #0x34]
7009eb80: 8ac0         	ldrh	r0, [r0, #0x16]
7009eb82: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
7009eb86: 980d         	ldr	r0, [sp, #0x34]
7009eb88: 7e80         	ldrb	r0, [r0, #0x1a]
7009eb8a: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
7009eb8e: 9802         	ldr	r0, [sp, #0x8]
7009eb90: f00a fdf6    	bl	0x700a9780 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xabec
7009eb94: b310         	cbz	r0, 0x7009ebdc <Sciclient_rmClearInterruptRoute+0x13c> @ imm = #0x44
7009eb96: e7ff         	b	0x7009eb98 <Sciclient_rmClearInterruptRoute+0xf8> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
7009eb98: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
7009eb9c: f00d fdb0    	bl	0x700ac700 <Sciclient_rmIaIsIa> @ imm = #0xdb60
7009eba0: b168         	cbz	r0, 0x7009ebbe <Sciclient_rmClearInterruptRoute+0x11e> @ imm = #0x1a
7009eba2: e7ff         	b	0x7009eba4 <Sciclient_rmClearInterruptRoute+0x104> @ imm = #-0x2
;                 cfg.s_ia = cfg.s_id;
7009eba4: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
7009eba8: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                 cfg.vint = cfg.s_idx;
7009ebac: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
7009ebb0: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009ebb4: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
7009ebb6: f00b fdfb    	bl	0x700aa7b0 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xbbf6
7009ebba: 900a         	str	r0, [sp, #0x28]
;             } else {
7009ebbc: e00d         	b	0x7009ebda <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #0x1a
7009ebbe: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqGetRoute(&cfg);
7009ebc0: f7fc fe56    	bl	0x7009b870 <Sciclient_rmIrqGetRoute> @ imm = #-0x3354
7009ebc4: 900a         	str	r0, [sp, #0x28]
;                 if (r == SystemP_SUCCESS) {
7009ebc6: 980a         	ldr	r0, [sp, #0x28]
7009ebc8: b930         	cbnz	r0, 0x7009ebd8 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #0xc
7009ebca: e7ff         	b	0x7009ebcc <Sciclient_rmClearInterruptRoute+0x12c> @ imm = #-0x2
7009ebcc: a802         	add	r0, sp, #0x8
7009ebce: 2100         	movs	r1, #0x0
;                     r = Sciclient_rmIrqDeleteRoute(&cfg, false);
7009ebd0: f000 f9ce    	bl	0x7009ef70 <Sciclient_rmIrqDeleteRoute> @ imm = #0x39c
7009ebd4: 900a         	str	r0, [sp, #0x28]
;                 }
7009ebd6: e7ff         	b	0x7009ebd8 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #-0x2
7009ebd8: e7ff         	b	0x7009ebda <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009ebda: e029         	b	0x7009ec30 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #0x52
7009ebdc: 9802         	ldr	r0, [sp, #0x8]
7009ebde: f00a fd97    	bl	0x700a9710 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xab2e
;                 true) ||
7009ebe2: b928         	cbnz	r0, 0x7009ebf0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #0xa
7009ebe4: e7ff         	b	0x7009ebe6 <Sciclient_rmClearInterruptRoute+0x146> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
7009ebe6: 9802         	ldr	r0, [sp, #0x8]
7009ebe8: f00a fe02    	bl	0x700a97f0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xac04
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009ebec: b128         	cbz	r0, 0x7009ebfa <Sciclient_rmClearInterruptRoute+0x15a> @ imm = #0xa
7009ebee: e7ff         	b	0x7009ebf0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #-0x2
7009ebf0: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintDelete(&cfg);
7009ebf2: f002 fa5d    	bl	0x700a10b0 <Sciclient_rmIrqVintDelete> @ imm = #0x24ba
7009ebf6: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
7009ebf8: e019         	b	0x7009ec2e <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #0x32
7009ebfa: 9802         	ldr	r0, [sp, #0x8]
7009ebfc: f00a fe68    	bl	0x700a98d0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xacd0
7009ec00: b128         	cbz	r0, 0x7009ec0e <Sciclient_rmClearInterruptRoute+0x16e> @ imm = #0xa
7009ec02: e7ff         	b	0x7009ec04 <Sciclient_rmClearInterruptRoute+0x164> @ imm = #-0x2
7009ec04: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
7009ec06: f00b fdd3    	bl	0x700aa7b0 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xbba6
7009ec0a: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
7009ec0c: e00e         	b	0x7009ec2c <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #0x1c
7009ec0e: 9802         	ldr	r0, [sp, #0x8]
7009ec10: f00a fe26    	bl	0x700a9860 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xac4c
7009ec14: b128         	cbz	r0, 0x7009ec22 <Sciclient_rmClearInterruptRoute+0x182> @ imm = #0xa
7009ec16: e7ff         	b	0x7009ec18 <Sciclient_rmClearInterruptRoute+0x178> @ imm = #-0x2
7009ec18: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqClearOesRegister(&cfg);
7009ec1a: f00d f921    	bl	0x700abe60 <Sciclient_rmIrqClearOesRegister> @ imm = #0xd242
7009ec1e: 900a         	str	r0, [sp, #0x28]
;         } else {
7009ec20: e003         	b	0x7009ec2a <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #0x6
7009ec22: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
7009ec26: 900a         	str	r0, [sp, #0x28]
7009ec28: e7ff         	b	0x7009ec2a <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #-0x2
7009ec2a: e7ff         	b	0x7009ec2c <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #-0x2
7009ec2c: e7ff         	b	0x7009ec2e <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #-0x2
7009ec2e: e7ff         	b	0x7009ec30 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #-0x2
;     }
7009ec30: e7ff         	b	0x7009ec32 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #-0x2
;     return r;
7009ec32: 980a         	ldr	r0, [sp, #0x28]
7009ec34: b00e         	add	sp, #0x38
7009ec36: bd80         	pop	{r7, pc}
		...

7009ec40 <Udma_chConfigTx>:
; {
7009ec40: b580         	push	{r7, lr}
7009ec42: b090         	sub	sp, #0x40
7009ec44: 900f         	str	r0, [sp, #0x3c]
7009ec46: 910e         	str	r1, [sp, #0x38]
7009ec48: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009ec4a: 900d         	str	r0, [sp, #0x34]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
7009ec4c: 980f         	ldr	r0, [sp, #0x3c]
7009ec4e: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
7009ec50: 980b         	ldr	r0, [sp, #0x2c]
7009ec52: b178         	cbz	r0, 0x7009ec74 <Udma_chConfigTx+0x34> @ imm = #0x1e
7009ec54: e7ff         	b	0x7009ec56 <Udma_chConfigTx+0x16> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009ec56: 980b         	ldr	r0, [sp, #0x2c]
7009ec58: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009ec5c: f64a 31cd    	movw	r1, #0xabcd
7009ec60: f6ca 31dc    	movt	r1, #0xabdc
7009ec64: 4288         	cmp	r0, r1
7009ec66: d105         	bne	0x7009ec74 <Udma_chConfigTx+0x34> @ imm = #0xa
7009ec68: e7ff         	b	0x7009ec6a <Udma_chConfigTx+0x2a> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_TX) != UDMA_CH_FLAG_TX))
7009ec6a: 980b         	ldr	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
7009ec6c: 7800         	ldrb	r0, [r0]
7009ec6e: 07c0         	lsls	r0, r0, #0x1f
7009ec70: b920         	cbnz	r0, 0x7009ec7c <Udma_chConfigTx+0x3c> @ imm = #0x8
7009ec72: e7ff         	b	0x7009ec74 <Udma_chConfigTx+0x34> @ imm = #-0x2
7009ec74: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009ec78: 900d         	str	r0, [sp, #0x34]
;     }
7009ec7a: e7ff         	b	0x7009ec7c <Udma_chConfigTx+0x3c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ec7c: 980d         	ldr	r0, [sp, #0x34]
7009ec7e: b9a8         	cbnz	r0, 0x7009ecac <Udma_chConfigTx+0x6c> @ imm = #0x2a
7009ec80: e7ff         	b	0x7009ec82 <Udma_chConfigTx+0x42> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009ec82: 980b         	ldr	r0, [sp, #0x2c]
7009ec84: 6e80         	ldr	r0, [r0, #0x68]
7009ec86: 900c         	str	r0, [sp, #0x30]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009ec88: 980c         	ldr	r0, [sp, #0x30]
7009ec8a: b150         	cbz	r0, 0x7009eca2 <Udma_chConfigTx+0x62> @ imm = #0x14
7009ec8c: e7ff         	b	0x7009ec8e <Udma_chConfigTx+0x4e> @ imm = #-0x2
7009ec8e: 980c         	ldr	r0, [sp, #0x30]
7009ec90: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009ec94: f64a 31cd    	movw	r1, #0xabcd
7009ec98: f6ca 31dc    	movt	r1, #0xabdc
7009ec9c: 4288         	cmp	r0, r1
7009ec9e: d004         	beq	0x7009ecaa <Udma_chConfigTx+0x6a> @ imm = #0x8
7009eca0: e7ff         	b	0x7009eca2 <Udma_chConfigTx+0x62> @ imm = #-0x2
7009eca2: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009eca6: 900d         	str	r0, [sp, #0x34]
;         }
7009eca8: e7ff         	b	0x7009ecaa <Udma_chConfigTx+0x6a> @ imm = #-0x2
;     }
7009ecaa: e7ff         	b	0x7009ecac <Udma_chConfigTx+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ecac: 980d         	ldr	r0, [sp, #0x34]
7009ecae: 2800         	cmp	r0, #0x0
7009ecb0: f040 808e    	bne.w	0x7009edd0 <Udma_chConfigTx+0x190> @ imm = #0x11c
7009ecb4: e7ff         	b	0x7009ecb6 <Udma_chConfigTx+0x76> @ imm = #-0x2
7009ecb6: f647 70ff    	movw	r0, #0x7fff
;         rmUdmaTxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
7009ecba: 9004         	str	r0, [sp, #0x10]
;         rmUdmaTxReq.nav_id              = drvHandle->devIdUdma;
7009ecbc: 980c         	ldr	r0, [sp, #0x30]
7009ecbe: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009ecc2: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmUdmaTxReq.index               = (uint16_t)chHandleInt->txChNum;
7009ecc6: 980b         	ldr	r0, [sp, #0x2c]
7009ecc8: 6ec0         	ldr	r0, [r0, #0x6c]
7009ecca: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmUdmaTxReq.tx_pause_on_err     = txPrms->pauseOnError;
7009ecce: 980e         	ldr	r0, [sp, #0x38]
7009ecd0: 7800         	ldrb	r0, [r0]
7009ecd2: f88d 0018    	strb.w	r0, [sp, #0x18]
;         rmUdmaTxReq.tx_filt_einfo       = txPrms->filterEinfo;
7009ecd6: 980e         	ldr	r0, [sp, #0x38]
7009ecd8: 7840         	ldrb	r0, [r0, #0x1]
7009ecda: f88d 0019    	strb.w	r0, [sp, #0x19]
;         rmUdmaTxReq.tx_filt_pswords     = txPrms->filterPsWords;
7009ecde: 980e         	ldr	r0, [sp, #0x38]
7009ece0: 7880         	ldrb	r0, [r0, #0x2]
7009ece2: f88d 001a    	strb.w	r0, [sp, #0x1a]
;         rmUdmaTxReq.tx_atype            = txPrms->addrType;
7009ece6: 980e         	ldr	r0, [sp, #0x38]
7009ece8: 78c0         	ldrb	r0, [r0, #0x3]
7009ecea: f88d 001b    	strb.w	r0, [sp, #0x1b]
;         rmUdmaTxReq.tx_chan_type        = txPrms->chanType;
7009ecee: 980e         	ldr	r0, [sp, #0x38]
7009ecf0: 7900         	ldrb	r0, [r0, #0x4]
7009ecf2: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         rmUdmaTxReq.tx_fetch_size       = txPrms->fetchWordSize;
7009ecf6: 980e         	ldr	r0, [sp, #0x38]
7009ecf8: 88c0         	ldrh	r0, [r0, #0x6]
7009ecfa: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmUdmaTxReq.tx_priority         = txPrms->busPriority;
7009ecfe: 980e         	ldr	r0, [sp, #0x38]
7009ed00: 7a00         	ldrb	r0, [r0, #0x8]
7009ed02: f88d 0023    	strb.w	r0, [sp, #0x23]
;         rmUdmaTxReq.tx_qos              = txPrms->busQos;
7009ed06: 980e         	ldr	r0, [sp, #0x38]
7009ed08: 7a40         	ldrb	r0, [r0, #0x9]
7009ed0a: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmUdmaTxReq.tx_orderid          = txPrms->busOrderId;
7009ed0e: 980e         	ldr	r0, [sp, #0x38]
7009ed10: 7a80         	ldrb	r0, [r0, #0xa]
7009ed12: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmUdmaTxReq.fdepth              = txPrms->fifoDepth;
7009ed16: 980e         	ldr	r0, [sp, #0x38]
7009ed18: 89c0         	ldrh	r0, [r0, #0xe]
7009ed1a: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmUdmaTxReq.tx_burst_size       = txPrms->burstSize;
7009ed1e: 980e         	ldr	r0, [sp, #0x38]
7009ed20: 7c00         	ldrb	r0, [r0, #0x10]
7009ed22: f88d 0029    	strb.w	r0, [sp, #0x29]
;         rmUdmaTxReq.tx_sched_priority   = txPrms->dmaPriority;
7009ed26: 980e         	ldr	r0, [sp, #0x38]
7009ed28: 7ac0         	ldrb	r0, [r0, #0xb]
7009ed2a: f88d 0028    	strb.w	r0, [sp, #0x28]
;         rmUdmaTxReq.tx_credit_count     = txPrms->txCredit;
7009ed2e: 980e         	ldr	r0, [sp, #0x38]
7009ed30: 7b00         	ldrb	r0, [r0, #0xc]
7009ed32: f88d 0020    	strb.w	r0, [sp, #0x20]
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009ed36: 980c         	ldr	r0, [sp, #0x30]
7009ed38: 6800         	ldr	r0, [r0]
7009ed3a: 2801         	cmp	r0, #0x1
7009ed3c: d11d         	bne	0x7009ed7a <Udma_chConfigTx+0x13a> @ imm = #0x3a
7009ed3e: e7ff         	b	0x7009ed40 <Udma_chConfigTx+0x100> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009ed40: 980b         	ldr	r0, [sp, #0x2c]
7009ed42: 7800         	ldrb	r0, [r0]
7009ed44: 0740         	lsls	r0, r0, #0x1d
7009ed46: 2800         	cmp	r0, #0x0
7009ed48: d508         	bpl	0x7009ed5c <Udma_chConfigTx+0x11c> @ imm = #0x10
7009ed4a: e7ff         	b	0x7009ed4c <Udma_chConfigTx+0x10c> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
7009ed4c: 9804         	ldr	r0, [sp, #0x10]
7009ed4e: f440 3080    	orr	r0, r0, #0x10000
7009ed52: 9004         	str	r0, [sp, #0x10]
7009ed54: 2001         	movs	r0, #0x1
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_BLK_CPY;
7009ed56: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
7009ed5a: e00d         	b	0x7009ed78 <Udma_chConfigTx+0x138> @ imm = #0x1a
;             else if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009ed5c: 980b         	ldr	r0, [sp, #0x2c]
7009ed5e: 7800         	ldrb	r0, [r0]
7009ed60: 07c0         	lsls	r0, r0, #0x1f
7009ed62: b140         	cbz	r0, 0x7009ed76 <Udma_chConfigTx+0x136> @ imm = #0x10
7009ed64: e7ff         	b	0x7009ed66 <Udma_chConfigTx+0x126> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
7009ed66: 9804         	ldr	r0, [sp, #0x10]
7009ed68: f440 3080    	orr	r0, r0, #0x10000
7009ed6c: 9004         	str	r0, [sp, #0x10]
7009ed6e: 2000         	movs	r0, #0x0
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_SPLIT_TR_TX;
7009ed70: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
7009ed74: e7ff         	b	0x7009ed76 <Udma_chConfigTx+0x136> @ imm = #-0x2
7009ed76: e7ff         	b	0x7009ed78 <Udma_chConfigTx+0x138> @ imm = #-0x2
;         }
7009ed78: e7ff         	b	0x7009ed7a <Udma_chConfigTx+0x13a> @ imm = #-0x2
;         if(NULL_PTR != chHandleInt->tdCqRing)
7009ed7a: 980b         	ldr	r0, [sp, #0x2c]
7009ed7c: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ed80: b158         	cbz	r0, 0x7009ed9a <Udma_chConfigTx+0x15a> @ imm = #0x16
7009ed82: e7ff         	b	0x7009ed84 <Udma_chConfigTx+0x144> @ imm = #-0x2
;             rmUdmaTxReq.txcq_qnum       = chHandleInt->tdCqRing->ringNum;
7009ed84: 980b         	ldr	r0, [sp, #0x2c]
7009ed86: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ed8a: 8880         	ldrh	r0, [r0, #0x4]
7009ed8c: f8ad 0021    	strh.w	r0, [sp, #0x21]
;             rmUdmaTxReq.tx_supr_tdpkt   = txPrms->supressTdCqPkt;
7009ed90: 980e         	ldr	r0, [sp, #0x38]
7009ed92: 7c40         	ldrb	r0, [r0, #0x11]
7009ed94: f88d 001d    	strb.w	r0, [sp, #0x1d]
;         }
7009ed98: e007         	b	0x7009edaa <Udma_chConfigTx+0x16a> @ imm = #0xe
7009ed9a: f64f 70ff    	movw	r0, #0xffff
;             rmUdmaTxReq.txcq_qnum       = UDMA_RING_INVALID;
7009ed9e: f8ad 0021    	strh.w	r0, [sp, #0x21]
7009eda2: 2001         	movs	r0, #0x1
;             rmUdmaTxReq.tx_supr_tdpkt   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_ENABLED;
7009eda4: f88d 001d    	strb.w	r0, [sp, #0x1d]
7009eda8: e7ff         	b	0x7009edaa <Udma_chConfigTx+0x16a> @ imm = #-0x2
7009edaa: a802         	add	r0, sp, #0x8
7009edac: 4669         	mov	r1, sp
7009edae: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapTxChCfg(
7009edb2: f00b fded    	bl	0x700aa990 <Sciclient_rmUdmapTxChCfg> @ imm = #0xbbda
7009edb6: 900d         	str	r0, [sp, #0x34]
;         if(CSL_PASS != retVal)
7009edb8: 980d         	ldr	r0, [sp, #0x34]
7009edba: b108         	cbz	r0, 0x7009edc0 <Udma_chConfigTx+0x180> @ imm = #0x2
7009edbc: e7ff         	b	0x7009edbe <Udma_chConfigTx+0x17e> @ imm = #-0x2
;         }
7009edbe: e7ff         	b	0x7009edc0 <Udma_chConfigTx+0x180> @ imm = #-0x2
;         (void) memcpy(&chHandleInt->txPrms, txPrms, sizeof(chHandleInt->txPrms));
7009edc0: 980b         	ldr	r0, [sp, #0x2c]
7009edc2: f500 70f2    	add.w	r0, r0, #0x1e4
7009edc6: 990e         	ldr	r1, [sp, #0x38]
7009edc8: 2212         	movs	r2, #0x12
7009edca: f7fb ee08    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0x43f0
;     }
7009edce: e7ff         	b	0x7009edd0 <Udma_chConfigTx+0x190> @ imm = #-0x2
;     return (retVal);
7009edd0: 980d         	ldr	r0, [sp, #0x34]
7009edd2: b010         	add	sp, #0x40
7009edd4: bd80         	pop	{r7, pc}
		...
7009edde: 0000         	movs	r0, r0

7009ede0 <ClockP_init>:
; {
7009ede0: b580         	push	{r7, lr}
7009ede2: b096         	sub	sp, #0x58
;     DebugP_assert( gClockConfig.timerInputPreScaler != 0U);
7009ede4: f240 4008    	movw	r0, #0x408
7009ede8: f2c7 000b    	movt	r0, #0x700b
7009edec: 9009         	str	r0, [sp, #0x24]
7009edee: 68c0         	ldr	r0, [r0, #0xc]
7009edf0: 2800         	cmp	r0, #0x0
7009edf2: bf18         	it	ne
7009edf4: 2001         	movne	r0, #0x1
7009edf6: f24f 7172    	movw	r1, #0xf772
7009edfa: f2c7 010a    	movt	r1, #0x700a
7009edfe: 466a         	mov	r2, sp
7009ee00: 6011         	str	r1, [r2]
7009ee02: f64f 11a5    	movw	r1, #0xf9a5
7009ee06: f2c7 010a    	movt	r1, #0x700a
7009ee0a: 9107         	str	r1, [sp, #0x1c]
7009ee0c: f64f 424a    	movw	r2, #0xfc4a
7009ee10: f2c7 020a    	movt	r2, #0x700a
7009ee14: 9208         	str	r2, [sp, #0x20]
7009ee16: 2334         	movs	r3, #0x34
7009ee18: f009 ff02    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x9e04
7009ee1c: 9907         	ldr	r1, [sp, #0x1c]
7009ee1e: 9a08         	ldr	r2, [sp, #0x20]
7009ee20: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerInputClkHz != 0U);
7009ee22: 6880         	ldr	r0, [r0, #0x8]
7009ee24: 2800         	cmp	r0, #0x0
7009ee26: bf18         	it	ne
7009ee28: 2001         	movne	r0, #0x1
7009ee2a: f24f 73e4    	movw	r3, #0xf7e4
7009ee2e: f2c7 030a    	movt	r3, #0x700a
7009ee32: 46ec         	mov	r12, sp
7009ee34: f8cc 3000    	str.w	r3, [r12]
7009ee38: 2335         	movs	r3, #0x35
7009ee3a: f009 fef1    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x9de2
7009ee3e: 9907         	ldr	r1, [sp, #0x1c]
7009ee40: 9a08         	ldr	r2, [sp, #0x20]
7009ee42: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.usecPerTick != 0U);
7009ee44: 6900         	ldr	r0, [r0, #0x10]
7009ee46: 2800         	cmp	r0, #0x0
7009ee48: bf18         	it	ne
7009ee4a: 2001         	movne	r0, #0x1
7009ee4c: f64f 03f0    	movw	r3, #0xf8f0
7009ee50: f2c7 030a    	movt	r3, #0x700a
7009ee54: 46ec         	mov	r12, sp
7009ee56: f8cc 3000    	str.w	r3, [r12]
7009ee5a: 2336         	movs	r3, #0x36
7009ee5c: f009 fee0    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x9dc0
7009ee60: 9907         	ldr	r1, [sp, #0x1c]
7009ee62: 9a08         	ldr	r2, [sp, #0x20]
7009ee64: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerBaseAddr != 0U);
7009ee66: 6800         	ldr	r0, [r0]
7009ee68: 2800         	cmp	r0, #0x0
7009ee6a: bf18         	it	ne
7009ee6c: 2001         	movne	r0, #0x1
7009ee6e: f64f 036d    	movw	r3, #0xf86d
7009ee72: f2c7 030a    	movt	r3, #0x700a
7009ee76: 46ec         	mov	r12, sp
7009ee78: f8cc 3000    	str.w	r3, [r12]
7009ee7c: 2337         	movs	r3, #0x37
7009ee7e: f009 fecf    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x9d9e
7009ee82: 9809         	ldr	r0, [sp, #0x24]
;     gClockCtrl.ticks = 0;
7009ee84: f644 6298    	movw	r2, #0x4e98
7009ee88: f2c7 0208    	movt	r2, #0x7008
7009ee8c: 2100         	movs	r1, #0x0
7009ee8e: 6051         	str	r1, [r2, #0x4]
7009ee90: 6011         	str	r1, [r2]
;     gClockCtrl.usecPerTick = gClockConfig.usecPerTick;
7009ee92: 6903         	ldr	r3, [r0, #0x10]
7009ee94: 6093         	str	r3, [r2, #0x8]
;     gClockCtrl.timerBaseAddr = gClockConfig.timerBaseAddr;
7009ee96: 6800         	ldr	r0, [r0]
7009ee98: 62d0         	str	r0, [r2, #0x2c]
7009ee9a: f244 2040    	movw	r0, #0x4240
7009ee9e: f2c0 000f    	movt	r0, #0xf
;     if( pdMS_TO_TICKS( TIME_IN_MILLI_SECONDS ) != ClockP_usecToTicks( TIME_IN_MICRO_SECONDS ) )
7009eea2: f00e f91d    	bl	0x700ad0e0 <ClockP_usecToTicks> @ imm = #0xe23a
7009eea6: f5b0 7f7a    	cmp.w	r0, #0x3e8
7009eeaa: d01d         	beq	0x7009eee8 <ClockP_init+0x108> @ imm = #0x3a
7009eeac: e7ff         	b	0x7009eeae <ClockP_init+0xce> @ imm = #-0x2
;         DebugP_logWarn("FreeRTOS configTICK_RATE_HZ (%d), does not match ClockP tick rate Hz (%d)\r\n",
7009eeae: f240 4008    	movw	r0, #0x408
7009eeb2: f2c7 000b    	movt	r0, #0x700b
7009eeb6: 6901         	ldr	r1, [r0, #0x10]
7009eeb8: f244 2040    	movw	r0, #0x4240
7009eebc: f2c0 000f    	movt	r0, #0xf
7009eec0: fbb0 f0f1    	udiv	r0, r0, r1
7009eec4: 4669         	mov	r1, sp
7009eec6: 6048         	str	r0, [r1, #0x4]
7009eec8: f44f 707a    	mov.w	r0, #0x3e8
7009eecc: 6008         	str	r0, [r1]
7009eece: f24f 4170    	movw	r1, #0xf470
7009eed2: f2c7 010a    	movt	r1, #0x700a
7009eed6: f64f 424a    	movw	r2, #0xfc4a
7009eeda: f2c7 020a    	movt	r2, #0x700a
7009eede: 2004         	movs	r0, #0x4
7009eee0: 2346         	movs	r3, #0x46
7009eee2: f008 fea5    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #0x8d4a
;     }
7009eee6: e7ff         	b	0x7009eee8 <ClockP_init+0x108> @ imm = #-0x2
7009eee8: a80f         	add	r0, sp, #0x3c
;     TimerP_Params_init(&timerParams);
7009eeea: 9002         	str	r0, [sp, #0x8]
7009eeec: f00d fa38    	bl	0x700ac360 <TimerP_Params_init> @ imm = #0xd470
7009eef0: 9902         	ldr	r1, [sp, #0x8]
;     timerParams.inputPreScaler    = gClockConfig.timerInputPreScaler;
7009eef2: f240 4008    	movw	r0, #0x408
7009eef6: f2c7 000b    	movt	r0, #0x700b
7009eefa: 9004         	str	r0, [sp, #0x10]
7009eefc: 68c2         	ldr	r2, [r0, #0xc]
7009eefe: 920f         	str	r2, [sp, #0x3c]
;     timerParams.inputClkHz        = gClockConfig.timerInputClkHz;
7009ef00: 6882         	ldr	r2, [r0, #0x8]
7009ef02: 9210         	str	r2, [sp, #0x40]
;     timerParams.periodInUsec      = gClockConfig.usecPerTick;
7009ef04: 6900         	ldr	r0, [r0, #0x10]
7009ef06: 9011         	str	r0, [sp, #0x44]
7009ef08: 2000         	movs	r0, #0x0
;     timerParams.oneshotMode       = 0;
7009ef0a: 9003         	str	r0, [sp, #0xc]
7009ef0c: 9013         	str	r0, [sp, #0x4c]
7009ef0e: 2001         	movs	r0, #0x1
;     timerParams.enableOverflowInt = 1;
7009ef10: 9014         	str	r0, [sp, #0x50]
;     TimerP_setup(gClockCtrl.timerBaseAddr, &timerParams);
7009ef12: f644 6098    	movw	r0, #0x4e98
7009ef16: f2c7 0008    	movt	r0, #0x7008
7009ef1a: 9006         	str	r0, [sp, #0x18]
7009ef1c: 6ac0         	ldr	r0, [r0, #0x2c]
7009ef1e: f7fd fbcf    	bl	0x7009c6c0 <TimerP_setup> @ imm = #-0x2862
7009ef22: 9806         	ldr	r0, [sp, #0x18]
;     gClockCtrl.timerReloadCount = TimerP_getReloadCount(gClockCtrl.timerBaseAddr);
7009ef24: 6ac0         	ldr	r0, [r0, #0x2c]
7009ef26: f00e fc23    	bl	0x700ad770 <TimerP_getReloadCount> @ imm = #0xe846
7009ef2a: 9906         	ldr	r1, [sp, #0x18]
7009ef2c: 6308         	str	r0, [r1, #0x30]
7009ef2e: a80a         	add	r0, sp, #0x28
;     HwiP_Params_init(&timerHwiParams);
7009ef30: 9005         	str	r0, [sp, #0x14]
7009ef32: f00e fe95    	bl	0x700adc60 <HwiP_Params_init> @ imm = #0xed2a
7009ef36: 9b03         	ldr	r3, [sp, #0xc]
7009ef38: 9a04         	ldr	r2, [sp, #0x10]
7009ef3a: 9905         	ldr	r1, [sp, #0x14]
7009ef3c: 9806         	ldr	r0, [sp, #0x18]
;     timerHwiParams.intNum = gClockConfig.timerHwiIntNum;
7009ef3e: f8d2 c004    	ldr.w	r12, [r2, #0x4]
7009ef42: f8cd c028    	str.w	r12, [sp, #0x28]
;     timerHwiParams.callback = ClockP_timerTickIsr;
7009ef46: f24c 4c91    	movw	r12, #0xc491
7009ef4a: f2c7 0c0a    	movt	r12, #0x700a
7009ef4e: f8cd c02c    	str.w	r12, [sp, #0x2c]
;     timerHwiParams.isPulse = 0;
7009ef52: f88d 3038    	strb.w	r3, [sp, #0x38]
;     timerHwiParams.priority = gClockConfig.intrPriority;
7009ef56: 7d12         	ldrb	r2, [r2, #0x14]
7009ef58: f88d 2036    	strb.w	r2, [sp, #0x36]
;     (void)HwiP_construct(&gClockCtrl.timerHwiObj, &timerHwiParams);
7009ef5c: 300c         	adds	r0, #0xc
7009ef5e: f00e fe97    	bl	0x700adc90 <HwiP_construct> @ imm = #0xed2e
;     TimerP_start(gClockCtrl.timerBaseAddr);
7009ef62: 9806         	ldr	r0, [sp, #0x18]
7009ef64: 6ac0         	ldr	r0, [r0, #0x2c]
7009ef66: f00e fa6b    	bl	0x700ad440 <TimerP_start> @ imm = #0xe4d6
; }
7009ef6a: b016         	add	sp, #0x58
7009ef6c: bd80         	pop	{r7, pc}
7009ef6e: 0000         	movs	r0, r0

7009ef70 <Sciclient_rmIrqDeleteRoute>:
; {
7009ef70: b580         	push	{r7, lr}
7009ef72: b090         	sub	sp, #0x40
7009ef74: 900f         	str	r0, [sp, #0x3c]
7009ef76: f88d 103b    	strb.w	r1, [sp, #0x3b]
7009ef7a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009ef7c: 900d         	str	r0, [sp, #0x34]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
7009ef7e: 9002         	str	r0, [sp, #0x8]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
7009ef80: 9001         	str	r0, [sp, #0x4]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009ef82: f8ad 0032    	strh.w	r0, [sp, #0x32]
7009ef86: e7ff         	b	0x7009ef88 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x2
7009ef88: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009ef8c: 9000         	str	r0, [sp]
7009ef8e: f00e fd1f    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0xea3e
7009ef92: 4601         	mov	r1, r0
7009ef94: 9800         	ldr	r0, [sp]
7009ef96: 4288         	cmp	r0, r1
7009ef98: f280 80ac    	bge.w	0x7009f0f4 <Sciclient_rmIrqDeleteRoute+0x184> @ imm = #0x158
7009ef9c: e7ff         	b	0x7009ef9e <Sciclient_rmIrqDeleteRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
7009ef9e: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009efa2: f00e f90d    	bl	0x700ad1c0 <Sciclient_rmPsGetIrqNode> @ imm = #0xe21a
7009efa6: 900b         	str	r0, [sp, #0x2c]
;         cur_inp = Sciclient_rmPsGetInp(i);
7009efa8: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009efac: f00c fd78    	bl	0x700abaa0 <Sciclient_rmPsGetInp> @ imm = #0xcaf0
7009efb0: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;         cur_outp = Sciclient_rmPsGetOutp(i);
7009efb4: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009efb8: f00c fd92    	bl	0x700abae0 <Sciclient_rmPsGetOutp> @ imm = #0xcb24
7009efbc: f8ad 0028    	strh.w	r0, [sp, #0x28]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009efc0: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009efc4: 2800         	cmp	r0, #0x0
7009efc6: d156         	bne	0x7009f076 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0xac
7009efc8: e7ff         	b	0x7009efca <Sciclient_rmIrqDeleteRoute+0x5a> @ imm = #-0x2
7009efca: 980b         	ldr	r0, [sp, #0x2c]
7009efcc: 8800         	ldrh	r0, [r0]
7009efce: f00d fb97    	bl	0x700ac700 <Sciclient_rmIaIsIa> @ imm = #0xd72e
7009efd2: 2800         	cmp	r0, #0x0
7009efd4: d04f         	beq	0x7009f076 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x9e
7009efd6: e7ff         	b	0x7009efd8 <Sciclient_rmIrqDeleteRoute+0x68> @ imm = #-0x2
;             (unmap_vint == true)) {
7009efd8: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009efdc: 07c0         	lsls	r0, r0, #0x1f
7009efde: 2800         	cmp	r0, #0x0
7009efe0: d049         	beq	0x7009f076 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x92
7009efe2: e7ff         	b	0x7009efe4 <Sciclient_rmIrqDeleteRoute+0x74> @ imm = #-0x2
7009efe4: 203c         	movs	r0, #0x3c
7009efe6: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
7009efea: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
7009efec: 980f         	ldr	r0, [sp, #0x3c]
7009efee: 7900         	ldrb	r0, [r0, #0x4]
7009eff0: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cfg->s_id;
7009eff4: 980f         	ldr	r0, [sp, #0x3c]
7009eff6: 88c0         	ldrh	r0, [r0, #0x6]
7009eff8: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cfg->s_idx;
7009effc: 980f         	ldr	r0, [sp, #0x3c]
7009effe: 8900         	ldrh	r0, [r0, #0x8]
7009f000: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.ia_id = cfg->s_ia;
7009f004: 980f         	ldr	r0, [sp, #0x3c]
7009f006: 8a00         	ldrh	r0, [r0, #0x10]
7009f008: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.vint = cur_outp;
7009f00c: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
7009f010: f8ad 0022    	strh.w	r0, [sp, #0x22]
;             req.global_event = cur_inp;
7009f014: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009f018: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint_status_bit_index = cfg->vint_sb;
7009f01c: 980f         	ldr	r0, [sp, #0x3c]
7009f01e: 7d00         	ldrb	r0, [r0, #0x14]
7009f020: f88d 0026    	strb.w	r0, [sp, #0x26]
7009f024: a803         	add	r0, sp, #0xc
7009f026: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
7009f02a: f00b fce1    	bl	0x700aa9f0 <Sciclient_rmIrqReleaseRaw> @ imm = #0xb9c2
7009f02e: 900d         	str	r0, [sp, #0x34]
;             if (r == SystemP_SUCCESS) {
7009f030: 980d         	ldr	r0, [sp, #0x34]
7009f032: b9f8         	cbnz	r0, 0x7009f074 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #0x3e
7009f034: e7ff         	b	0x7009f036 <Sciclient_rmIrqDeleteRoute+0xc6> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
7009f036: 980b         	ldr	r0, [sp, #0x2c]
7009f038: 8800         	ldrh	r0, [r0]
7009f03a: f00b fa09    	bl	0x700aa450 <Sciclient_rmIaGetInst> @ imm = #0xb412
7009f03e: 9002         	str	r0, [sp, #0x8]
;                 if (ia_inst != NULL) {
7009f040: 9802         	ldr	r0, [sp, #0x8]
7009f042: b1b0         	cbz	r0, 0x7009f072 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #0x2c
7009f044: e7ff         	b	0x7009f046 <Sciclient_rmIrqDeleteRoute+0xd6> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]--;
7009f046: 9802         	ldr	r0, [sp, #0x8]
7009f048: 6901         	ldr	r1, [r0, #0x10]
7009f04a: f8bd 2028    	ldrh.w	r2, [sp, #0x28]
7009f04e: 5c88         	ldrb	r0, [r1, r2]
7009f050: 3801         	subs	r0, #0x1
7009f052: 5488         	strb	r0, [r1, r2]
;                     if (ia_inst->v0_b0_evt == cur_inp - ia_inst->sevt_offset) {
7009f054: 9a02         	ldr	r2, [sp, #0x8]
7009f056: 8a90         	ldrh	r0, [r2, #0x14]
7009f058: f8bd 102a    	ldrh.w	r1, [sp, #0x2a]
7009f05c: 8912         	ldrh	r2, [r2, #0x8]
7009f05e: 1a89         	subs	r1, r1, r2
7009f060: 4288         	cmp	r0, r1
7009f062: d105         	bne	0x7009f070 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #0xa
7009f064: e7ff         	b	0x7009f066 <Sciclient_rmIrqDeleteRoute+0xf6> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
7009f066: 9902         	ldr	r1, [sp, #0x8]
7009f068: f64f 70ff    	movw	r0, #0xffff
7009f06c: 8288         	strh	r0, [r1, #0x14]
;                     }
7009f06e: e7ff         	b	0x7009f070 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #-0x2
;                 }
7009f070: e7ff         	b	0x7009f072 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #-0x2
;             }
7009f072: e7ff         	b	0x7009f074 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #-0x2
;         }
7009f074: e7ff         	b	0x7009f076 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #-0x2
;         if (i > 0u) {
7009f076: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009f07a: b3a0         	cbz	r0, 0x7009f0e6 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #0x68
7009f07c: e7ff         	b	0x7009f07e <Sciclient_rmIrqDeleteRoute+0x10e> @ imm = #-0x2
7009f07e: 2003         	movs	r0, #0x3
7009f080: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
7009f084: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
7009f086: 980f         	ldr	r0, [sp, #0x3c]
7009f088: 7900         	ldrb	r0, [r0, #0x4]
7009f08a: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cur_n->id;
7009f08e: 980b         	ldr	r0, [sp, #0x2c]
7009f090: 8800         	ldrh	r0, [r0]
7009f092: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cur_inp;
7009f096: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009f09a: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.dst_id = cur_n->id;
7009f09e: 980b         	ldr	r0, [sp, #0x2c]
7009f0a0: 8800         	ldrh	r0, [r0]
7009f0a2: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.dst_host_irq = cur_outp;
7009f0a6: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
7009f0aa: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009f0ae: a803         	add	r0, sp, #0xc
7009f0b0: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
7009f0b4: f00b fc9c    	bl	0x700aa9f0 <Sciclient_rmIrqReleaseRaw> @ imm = #0xb938
7009f0b8: 900d         	str	r0, [sp, #0x34]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
7009f0ba: 980d         	ldr	r0, [sp, #0x34]
7009f0bc: b990         	cbnz	r0, 0x7009f0e4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x24
7009f0be: e7ff         	b	0x7009f0c0 <Sciclient_rmIrqDeleteRoute+0x150> @ imm = #-0x2
7009f0c0: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
7009f0c4: b970         	cbnz	r0, 0x7009f0e4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x1c
7009f0c6: e7ff         	b	0x7009f0c8 <Sciclient_rmIrqDeleteRoute+0x158> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
7009f0c8: 980b         	ldr	r0, [sp, #0x2c]
7009f0ca: 8800         	ldrh	r0, [r0]
7009f0cc: f00a fca8    	bl	0x700a9a20 <Sciclient_rmIrGetInst> @ imm = #0xa950
7009f0d0: 9001         	str	r0, [sp, #0x4]
;                 if (ir_inst != NULL) {
7009f0d2: 9801         	ldr	r0, [sp, #0x4]
7009f0d4: b128         	cbz	r0, 0x7009f0e2 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #0xa
7009f0d6: e7ff         	b	0x7009f0d8 <Sciclient_rmIrqDeleteRoute+0x168> @ imm = #-0x2
;                     ir_inst->inp0_mapping = SCICLIENT_RM_IR_MAPPING_FREE;
7009f0d8: 9901         	ldr	r1, [sp, #0x4]
7009f0da: f64f 70ff    	movw	r0, #0xffff
7009f0de: 8188         	strh	r0, [r1, #0xc]
;                 }
7009f0e0: e7ff         	b	0x7009f0e2 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #-0x2
;             }
7009f0e2: e7ff         	b	0x7009f0e4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #-0x2
;         }
7009f0e4: e7ff         	b	0x7009f0e6 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #-0x2
;     }
7009f0e6: e7ff         	b	0x7009f0e8 <Sciclient_rmIrqDeleteRoute+0x178> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009f0e8: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009f0ec: 3001         	adds	r0, #0x1
7009f0ee: f8ad 0032    	strh.w	r0, [sp, #0x32]
7009f0f2: e749         	b	0x7009ef88 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x16e
;     return r;
7009f0f4: 980d         	ldr	r0, [sp, #0x34]
7009f0f6: b010         	add	sp, #0x40
7009f0f8: bd80         	pop	{r7, pc}
7009f0fa: 0000         	movs	r0, r0
7009f0fc: 0000         	movs	r0, r0
7009f0fe: 0000         	movs	r0, r0

7009f100 <Sciclient_rmProgramInterruptRoute>:
; {
7009f100: b580         	push	{r7, lr}
7009f102: b08e         	sub	sp, #0x38
7009f104: 900d         	str	r0, [sp, #0x34]
7009f106: 910c         	str	r1, [sp, #0x30]
7009f108: 920b         	str	r2, [sp, #0x2c]
7009f10a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009f10c: 9001         	str	r0, [sp, #0x4]
7009f10e: 900a         	str	r0, [sp, #0x28]
7009f110: f44f 5180    	mov.w	r1, #0x1000
;     uint16_t messageType = TISCI_MSG_RM_IRQ_SET;
7009f114: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
7009f118: 9008         	str	r0, [sp, #0x20]
7009f11a: 9007         	str	r0, [sp, #0x1c]
7009f11c: 9006         	str	r0, [sp, #0x18]
7009f11e: 9005         	str	r0, [sp, #0x14]
7009f120: 9004         	str	r0, [sp, #0x10]
7009f122: 9003         	str	r0, [sp, #0xc]
7009f124: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
7009f126: 980d         	ldr	r0, [sp, #0x34]
7009f128: b118         	cbz	r0, 0x7009f132 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #0x6
7009f12a: e7ff         	b	0x7009f12c <Sciclient_rmProgramInterruptRoute+0x2c> @ imm = #-0x2
7009f12c: 980c         	ldr	r0, [sp, #0x30]
7009f12e: b920         	cbnz	r0, 0x7009f13a <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #0x8
7009f130: e7ff         	b	0x7009f132 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #-0x2
7009f132: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009f136: 900a         	str	r0, [sp, #0x28]
;     }
7009f138: e7ff         	b	0x7009f13a <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009f13a: 980a         	ldr	r0, [sp, #0x28]
7009f13c: b968         	cbnz	r0, 0x7009f15a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0x1a
7009f13e: e7ff         	b	0x7009f140 <Sciclient_rmProgramInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009f140: 980d         	ldr	r0, [sp, #0x34]
7009f142: 6880         	ldr	r0, [r0, #0x8]
7009f144: f04f 4100    	mov.w	r1, #0x80000000
7009f148: f00d fcd2    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0xd9a4
;     if (r == SystemP_SUCCESS &&
7009f14c: b128         	cbz	r0, 0x7009f15a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0xa
7009f14e: e7ff         	b	0x7009f150 <Sciclient_rmProgramInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
7009f150: 980d         	ldr	r0, [sp, #0x34]
7009f152: 7ec0         	ldrb	r0, [r0, #0x1b]
7009f154: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
7009f158: e00f         	b	0x7009f17a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
7009f15a: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009f15e: f006 fcc7    	bl	0x700a5af0 <Sciclient_getCurrentContext> @ imm = #0x698e
7009f162: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009f166: f24f 0068    	movw	r0, #0xf068
7009f16a: f2c7 000a    	movt	r0, #0x700a
7009f16e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009f172: 6840         	ldr	r0, [r0, #0x4]
7009f174: f88d 0025    	strb.w	r0, [sp, #0x25]
7009f178: e7ff         	b	0x7009f17a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009f17a: 980a         	ldr	r0, [sp, #0x28]
7009f17c: b960         	cbnz	r0, 0x7009f198 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0x18
7009f17e: e7ff         	b	0x7009f180 <Sciclient_rmProgramInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009f180: 980d         	ldr	r0, [sp, #0x34]
7009f182: 6880         	ldr	r0, [r0, #0x8]
7009f184: 2104         	movs	r1, #0x4
7009f186: f00d fcb3    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0xd966
;     if (r == SystemP_SUCCESS &&
7009f18a: b128         	cbz	r0, 0x7009f198 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0xa
7009f18c: e7ff         	b	0x7009f18e <Sciclient_rmProgramInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
7009f18e: 980d         	ldr	r0, [sp, #0x34]
7009f190: 8a80         	ldrh	r0, [r0, #0x14]
7009f192: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
7009f196: e003         	b	0x7009f1a0 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #0x6
7009f198: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
7009f19a: f8ad 0018    	strh.w	r0, [sp, #0x18]
7009f19e: e7ff         	b	0x7009f1a0 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009f1a0: 980a         	ldr	r0, [sp, #0x28]
7009f1a2: 2800         	cmp	r0, #0x0
7009f1a4: d16e         	bne	0x7009f284 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #0xdc
7009f1a6: e7ff         	b	0x7009f1a8 <Sciclient_rmProgramInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
7009f1a8: 980d         	ldr	r0, [sp, #0x34]
7009f1aa: 6880         	ldr	r0, [r0, #0x8]
7009f1ac: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
7009f1ae: f89d 0025    	ldrb.w	r0, [sp, #0x25]
7009f1b2: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
7009f1b6: 980d         	ldr	r0, [sp, #0x34]
7009f1b8: 8980         	ldrh	r0, [r0, #0xc]
7009f1ba: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
7009f1be: 980d         	ldr	r0, [sp, #0x34]
7009f1c0: 89c0         	ldrh	r0, [r0, #0xe]
7009f1c2: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
7009f1c6: 980d         	ldr	r0, [sp, #0x34]
7009f1c8: 8a00         	ldrh	r0, [r0, #0x10]
7009f1ca: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
7009f1ce: 980d         	ldr	r0, [sp, #0x34]
7009f1d0: 8a40         	ldrh	r0, [r0, #0x12]
7009f1d2: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
7009f1d6: 980d         	ldr	r0, [sp, #0x34]
7009f1d8: 8b00         	ldrh	r0, [r0, #0x18]
7009f1da: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
7009f1de: 980d         	ldr	r0, [sp, #0x34]
7009f1e0: 8ac0         	ldrh	r0, [r0, #0x16]
7009f1e2: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
7009f1e6: 980d         	ldr	r0, [sp, #0x34]
7009f1e8: 7e80         	ldrb	r0, [r0, #0x1a]
7009f1ea: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         cfg.set_resp = resp;
7009f1ee: 980c         	ldr	r0, [sp, #0x30]
7009f1f0: 9008         	str	r0, [sp, #0x20]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
7009f1f2: 9802         	ldr	r0, [sp, #0x8]
7009f1f4: f00a fac4    	bl	0x700a9780 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xa588
7009f1f8: b1c8         	cbz	r0, 0x7009f22e <Sciclient_rmProgramInterruptRoute+0x12e> @ imm = #0x32
7009f1fa: e7ff         	b	0x7009f1fc <Sciclient_rmProgramInterruptRoute+0xfc> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
7009f1fc: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
7009f200: f00d fa7e    	bl	0x700ac700 <Sciclient_rmIaIsIa> @ imm = #0xd4fc
7009f204: b128         	cbz	r0, 0x7009f212 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #0xa
7009f206: e7ff         	b	0x7009f208 <Sciclient_rmProgramInterruptRoute+0x108> @ imm = #-0x2
;                 cfg.vint = cfg.s_idx;
7009f208: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
7009f20c: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             }
7009f210: e7ff         	b	0x7009f212 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #-0x2
7009f212: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqFindRoute(&cfg);
7009f214: f7fd fcc4    	bl	0x7009cba0 <Sciclient_rmIrqFindRoute> @ imm = #-0x2678
7009f218: 900a         	str	r0, [sp, #0x28]
;             if (r == SystemP_SUCCESS) {
7009f21a: 980a         	ldr	r0, [sp, #0x28]
7009f21c: b930         	cbnz	r0, 0x7009f22c <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #0xc
7009f21e: e7ff         	b	0x7009f220 <Sciclient_rmProgramInterruptRoute+0x120> @ imm = #-0x2
7009f220: a802         	add	r0, sp, #0x8
7009f222: 2100         	movs	r1, #0x0
;                 r = Sciclient_rmIrqProgramRoute(&cfg, false);
7009f224: f000 f834    	bl	0x7009f290 <Sciclient_rmIrqProgramRoute> @ imm = #0x68
7009f228: 900a         	str	r0, [sp, #0x28]
;             }
7009f22a: e7ff         	b	0x7009f22c <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009f22c: e029         	b	0x7009f282 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #0x52
7009f22e: 9802         	ldr	r0, [sp, #0x8]
7009f230: f00a fa6e    	bl	0x700a9710 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xa4dc
;                 true) ||
7009f234: b928         	cbnz	r0, 0x7009f242 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #0xa
7009f236: e7ff         	b	0x7009f238 <Sciclient_rmProgramInterruptRoute+0x138> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
7009f238: 9802         	ldr	r0, [sp, #0x8]
7009f23a: f00a fad9    	bl	0x700a97f0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xa5b2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009f23e: b128         	cbz	r0, 0x7009f24c <Sciclient_rmProgramInterruptRoute+0x14c> @ imm = #0xa
7009f240: e7ff         	b	0x7009f242 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #-0x2
7009f242: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintAdd(&cfg);
7009f244: f003 fba4    	bl	0x700a2990 <Sciclient_rmIrqVintAdd> @ imm = #0x3748
7009f248: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
7009f24a: e019         	b	0x7009f280 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #0x32
7009f24c: 9802         	ldr	r0, [sp, #0x8]
7009f24e: f00a fb3f    	bl	0x700a98d0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xa67e
7009f252: b128         	cbz	r0, 0x7009f260 <Sciclient_rmProgramInterruptRoute+0x160> @ imm = #0xa
7009f254: e7ff         	b	0x7009f256 <Sciclient_rmProgramInterruptRoute+0x156> @ imm = #-0x2
7009f256: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmUnmappedVintRouteCreate(&cfg);
7009f258: f00b fcea    	bl	0x700aac30 <Sciclient_rmUnmappedVintRouteCreate> @ imm = #0xb9d4
7009f25c: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
7009f25e: e00e         	b	0x7009f27e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #0x1c
7009f260: 9802         	ldr	r0, [sp, #0x8]
7009f262: f00a fafd    	bl	0x700a9860 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xa5fa
7009f266: b128         	cbz	r0, 0x7009f274 <Sciclient_rmProgramInterruptRoute+0x174> @ imm = #0xa
7009f268: e7ff         	b	0x7009f26a <Sciclient_rmProgramInterruptRoute+0x16a> @ imm = #-0x2
7009f26a: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqProgramOesRegister(&cfg);
7009f26c: f00c fbd8    	bl	0x700aba20 <Sciclient_rmIrqProgramOesRegister> @ imm = #0xc7b0
7009f270: 900a         	str	r0, [sp, #0x28]
;         } else {
7009f272: e003         	b	0x7009f27c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #0x6
7009f274: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
7009f278: 900a         	str	r0, [sp, #0x28]
7009f27a: e7ff         	b	0x7009f27c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #-0x2
7009f27c: e7ff         	b	0x7009f27e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #-0x2
7009f27e: e7ff         	b	0x7009f280 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #-0x2
7009f280: e7ff         	b	0x7009f282 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #-0x2
;     }
7009f282: e7ff         	b	0x7009f284 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #-0x2
;     return r;
7009f284: 980a         	ldr	r0, [sp, #0x28]
7009f286: b00e         	add	sp, #0x38
7009f288: bd80         	pop	{r7, pc}
7009f28a: 0000         	movs	r0, r0
7009f28c: 0000         	movs	r0, r0
7009f28e: 0000         	movs	r0, r0

7009f290 <Sciclient_rmIrqProgramRoute>:
; {
7009f290: b580         	push	{r7, lr}
7009f292: b092         	sub	sp, #0x48
7009f294: 9011         	str	r0, [sp, #0x44]
7009f296: f88d 1043    	strb.w	r1, [sp, #0x43]
7009f29a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009f29c: 900f         	str	r0, [sp, #0x3c]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
7009f29e: 9003         	str	r0, [sp, #0xc]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
7009f2a0: 9002         	str	r0, [sp, #0x8]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009f2a2: f8ad 003a    	strh.w	r0, [sp, #0x3a]
7009f2a6: e7ff         	b	0x7009f2a8 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x2
7009f2a8: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f2ac: 9001         	str	r0, [sp, #0x4]
7009f2ae: f00e fb8f    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0xe71e
7009f2b2: 4601         	mov	r1, r0
7009f2b4: 9801         	ldr	r0, [sp, #0x4]
7009f2b6: 4288         	cmp	r0, r1
7009f2b8: f280 80aa    	bge.w	0x7009f410 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0x154
7009f2bc: e7ff         	b	0x7009f2be <Sciclient_rmIrqProgramRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
7009f2be: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f2c2: f00d ff7d    	bl	0x700ad1c0 <Sciclient_rmPsGetIrqNode> @ imm = #0xdefa
7009f2c6: 900d         	str	r0, [sp, #0x34]
;         cur_inp = Sciclient_rmPsGetInp(i);
7009f2c8: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f2cc: f00c fbe8    	bl	0x700abaa0 <Sciclient_rmPsGetInp> @ imm = #0xc7d0
7009f2d0: 900c         	str	r0, [sp, #0x30]
;         cur_outp = Sciclient_rmPsGetOutp(i);
7009f2d2: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f2d6: f00c fc03    	bl	0x700abae0 <Sciclient_rmPsGetOutp> @ imm = #0xc806
7009f2da: 900b         	str	r0, [sp, #0x2c]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009f2dc: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f2e0: 2800         	cmp	r0, #0x0
7009f2e2: d154         	bne	0x7009f38e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0xa8
7009f2e4: e7ff         	b	0x7009f2e6 <Sciclient_rmIrqProgramRoute+0x56> @ imm = #-0x2
7009f2e6: 980d         	ldr	r0, [sp, #0x34]
7009f2e8: 8800         	ldrh	r0, [r0]
7009f2ea: f00d fa09    	bl	0x700ac700 <Sciclient_rmIaIsIa> @ imm = #0xd412
7009f2ee: 2800         	cmp	r0, #0x0
7009f2f0: d04d         	beq	0x7009f38e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x9a
7009f2f2: e7ff         	b	0x7009f2f4 <Sciclient_rmIrqProgramRoute+0x64> @ imm = #-0x2
;             (map_vint == true)) {
7009f2f4: f89d 0043    	ldrb.w	r0, [sp, #0x43]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009f2f8: 07c0         	lsls	r0, r0, #0x1f
7009f2fa: 2800         	cmp	r0, #0x0
7009f2fc: d047         	beq	0x7009f38e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x8e
7009f2fe: e7ff         	b	0x7009f300 <Sciclient_rmIrqProgramRoute+0x70> @ imm = #-0x2
7009f300: 203c         	movs	r0, #0x3c
7009f302: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
7009f306: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
7009f308: 9811         	ldr	r0, [sp, #0x44]
7009f30a: 7900         	ldrb	r0, [r0, #0x4]
7009f30c: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cfg->s_id;
7009f310: 9811         	ldr	r0, [sp, #0x44]
7009f312: 88c0         	ldrh	r0, [r0, #0x6]
7009f314: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cfg->s_idx;
7009f318: 9811         	ldr	r0, [sp, #0x44]
7009f31a: 8900         	ldrh	r0, [r0, #0x8]
7009f31c: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.ia_id = cfg->s_ia;
7009f320: 9811         	ldr	r0, [sp, #0x44]
7009f322: 8a00         	ldrh	r0, [r0, #0x10]
7009f324: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint = cur_outp;
7009f328: 980b         	ldr	r0, [sp, #0x2c]
7009f32a: f8ad 0026    	strh.w	r0, [sp, #0x26]
;             req.global_event = cur_inp;
7009f32e: 980c         	ldr	r0, [sp, #0x30]
7009f330: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             req.vint_status_bit_index = cfg->vint_sb;
7009f334: 9811         	ldr	r0, [sp, #0x44]
7009f336: 7d00         	ldrb	r0, [r0, #0x14]
7009f338: f88d 002a    	strb.w	r0, [sp, #0x2a]
;                                       cfg->set_resp,
7009f33c: 9811         	ldr	r0, [sp, #0x44]
7009f33e: 6981         	ldr	r1, [r0, #0x18]
7009f340: a804         	add	r0, sp, #0x10
7009f342: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
7009f346: f00b fa03    	bl	0x700aa750 <Sciclient_rmIrqSetRaw> @ imm = #0xb406
7009f34a: 900f         	str	r0, [sp, #0x3c]
;             if (r == SystemP_SUCCESS) {
7009f34c: 980f         	ldr	r0, [sp, #0x3c]
7009f34e: b9e8         	cbnz	r0, 0x7009f38c <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #0x3a
7009f350: e7ff         	b	0x7009f352 <Sciclient_rmIrqProgramRoute+0xc2> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
7009f352: 980d         	ldr	r0, [sp, #0x34]
7009f354: 8800         	ldrh	r0, [r0]
7009f356: f00b f87b    	bl	0x700aa450 <Sciclient_rmIaGetInst> @ imm = #0xb0f6
7009f35a: 9003         	str	r0, [sp, #0xc]
;                 if (ia_inst != NULL) {
7009f35c: 9803         	ldr	r0, [sp, #0xc]
7009f35e: b1a0         	cbz	r0, 0x7009f38a <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #0x28
7009f360: e7ff         	b	0x7009f362 <Sciclient_rmIrqProgramRoute+0xd2> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]++;
7009f362: 9803         	ldr	r0, [sp, #0xc]
7009f364: 6901         	ldr	r1, [r0, #0x10]
7009f366: 9a0b         	ldr	r2, [sp, #0x2c]
7009f368: 5c88         	ldrb	r0, [r1, r2]
7009f36a: 3001         	adds	r0, #0x1
7009f36c: 5488         	strb	r0, [r1, r2]
;                     if ((cur_outp == 0) && (cfg->vint_sb == 0)) {
7009f36e: 980b         	ldr	r0, [sp, #0x2c]
7009f370: b950         	cbnz	r0, 0x7009f388 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0x14
7009f372: e7ff         	b	0x7009f374 <Sciclient_rmIrqProgramRoute+0xe4> @ imm = #-0x2
7009f374: 9811         	ldr	r0, [sp, #0x44]
7009f376: 7d00         	ldrb	r0, [r0, #0x14]
7009f378: b930         	cbnz	r0, 0x7009f388 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0xc
7009f37a: e7ff         	b	0x7009f37c <Sciclient_rmIrqProgramRoute+0xec> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = cur_inp - ia_inst->sevt_offset;
7009f37c: 980c         	ldr	r0, [sp, #0x30]
7009f37e: 9903         	ldr	r1, [sp, #0xc]
7009f380: 890a         	ldrh	r2, [r1, #0x8]
7009f382: 1a80         	subs	r0, r0, r2
7009f384: 8288         	strh	r0, [r1, #0x14]
;                     }
7009f386: e7ff         	b	0x7009f388 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #-0x2
;                 }
7009f388: e7ff         	b	0x7009f38a <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #-0x2
;             }
7009f38a: e7ff         	b	0x7009f38c <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #-0x2
;         }
7009f38c: e7ff         	b	0x7009f38e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #-0x2
;         if (i > 0u) {
7009f38e: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f392: b390         	cbz	r0, 0x7009f3fa <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #0x64
7009f394: e7ff         	b	0x7009f396 <Sciclient_rmIrqProgramRoute+0x106> @ imm = #-0x2
7009f396: 2003         	movs	r0, #0x3
7009f398: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
7009f39c: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
7009f39e: 9811         	ldr	r0, [sp, #0x44]
7009f3a0: 7900         	ldrb	r0, [r0, #0x4]
7009f3a2: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cur_n->id;
7009f3a6: 980d         	ldr	r0, [sp, #0x34]
7009f3a8: 8800         	ldrh	r0, [r0]
7009f3aa: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cur_inp;
7009f3ae: 980c         	ldr	r0, [sp, #0x30]
7009f3b0: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.dst_id = cur_n->id;
7009f3b4: 980d         	ldr	r0, [sp, #0x34]
7009f3b6: 8800         	ldrh	r0, [r0]
7009f3b8: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.dst_host_irq = cur_outp;
7009f3bc: 980b         	ldr	r0, [sp, #0x2c]
7009f3be: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                                       cfg->set_resp,
7009f3c2: 9811         	ldr	r0, [sp, #0x44]
7009f3c4: 6981         	ldr	r1, [r0, #0x18]
7009f3c6: a804         	add	r0, sp, #0x10
7009f3c8: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
7009f3cc: f00b f9c0    	bl	0x700aa750 <Sciclient_rmIrqSetRaw> @ imm = #0xb380
7009f3d0: 900f         	str	r0, [sp, #0x3c]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
7009f3d2: 980f         	ldr	r0, [sp, #0x3c]
7009f3d4: b980         	cbnz	r0, 0x7009f3f8 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x20
7009f3d6: e7ff         	b	0x7009f3d8 <Sciclient_rmIrqProgramRoute+0x148> @ imm = #-0x2
7009f3d8: 980b         	ldr	r0, [sp, #0x2c]
7009f3da: b968         	cbnz	r0, 0x7009f3f8 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x1a
7009f3dc: e7ff         	b	0x7009f3de <Sciclient_rmIrqProgramRoute+0x14e> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
7009f3de: 980d         	ldr	r0, [sp, #0x34]
7009f3e0: 8800         	ldrh	r0, [r0]
7009f3e2: f00a fb1d    	bl	0x700a9a20 <Sciclient_rmIrGetInst> @ imm = #0xa63a
7009f3e6: 9002         	str	r0, [sp, #0x8]
;                 if (ir_inst != NULL) {
7009f3e8: 9802         	ldr	r0, [sp, #0x8]
7009f3ea: b120         	cbz	r0, 0x7009f3f6 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #0x8
7009f3ec: e7ff         	b	0x7009f3ee <Sciclient_rmIrqProgramRoute+0x15e> @ imm = #-0x2
;                     ir_inst->inp0_mapping = cur_outp;
7009f3ee: 980b         	ldr	r0, [sp, #0x2c]
7009f3f0: 9902         	ldr	r1, [sp, #0x8]
7009f3f2: 8188         	strh	r0, [r1, #0xc]
;                 }
7009f3f4: e7ff         	b	0x7009f3f6 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #-0x2
;             }
7009f3f6: e7ff         	b	0x7009f3f8 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #-0x2
;         }
7009f3f8: e7ff         	b	0x7009f3fa <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #-0x2
;         if (r != SystemP_SUCCESS) {
7009f3fa: 980f         	ldr	r0, [sp, #0x3c]
7009f3fc: b108         	cbz	r0, 0x7009f402 <Sciclient_rmIrqProgramRoute+0x172> @ imm = #0x2
7009f3fe: e7ff         	b	0x7009f400 <Sciclient_rmIrqProgramRoute+0x170> @ imm = #-0x2
;             break;
7009f400: e006         	b	0x7009f410 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0xc
;     }
7009f402: e7ff         	b	0x7009f404 <Sciclient_rmIrqProgramRoute+0x174> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009f404: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f408: 3001         	adds	r0, #0x1
7009f40a: f8ad 003a    	strh.w	r0, [sp, #0x3a]
7009f40e: e74b         	b	0x7009f2a8 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x16a
;     return r;
7009f410: 980f         	ldr	r0, [sp, #0x3c]
7009f412: b012         	add	sp, #0x48
7009f414: bd80         	pop	{r7, pc}
		...
7009f41e: 0000         	movs	r0, r0

7009f420 <Udma_chEnableLocal>:
; {
7009f420: b580         	push	{r7, lr}
7009f422: b08e         	sub	sp, #0x38
7009f424: 900d         	str	r0, [sp, #0x34]
;     drvHandle = chHandle->drvHandle;
7009f426: 980d         	ldr	r0, [sp, #0x34]
7009f428: 6e80         	ldr	r0, [r0, #0x68]
7009f42a: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f42c: 980b         	ldr	r0, [sp, #0x2c]
7009f42e: 6800         	ldr	r0, [r0]
7009f430: 2801         	cmp	r0, #0x1
7009f432: d163         	bne	0x7009f4fc <Udma_chEnableLocal+0xdc> @ imm = #0xc6
7009f434: e7ff         	b	0x7009f436 <Udma_chEnableLocal+0x16> @ imm = #-0x2
7009f436: 2001         	movs	r0, #0x1
;         bcdmaRtEnable.enable         = TRUE;
7009f438: 9005         	str	r0, [sp, #0x14]
7009f43a: 2000         	movs	r0, #0x0
;         bcdmaRtEnable.teardown       = FALSE;
7009f43c: 9006         	str	r0, [sp, #0x18]
;         bcdmaRtEnable.forcedTeardown = FALSE;
7009f43e: 9009         	str	r0, [sp, #0x24]
;         bcdmaRtEnable.pause          = FALSE;
7009f440: 9007         	str	r0, [sp, #0x1c]
;         bcdmaRtEnable.error          = FALSE;
7009f442: 9008         	str	r0, [sp, #0x20]
;         if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009f444: 980d         	ldr	r0, [sp, #0x34]
7009f446: 7800         	ldrb	r0, [r0]
7009f448: 0740         	lsls	r0, r0, #0x1d
7009f44a: 2800         	cmp	r0, #0x0
7009f44c: d508         	bpl	0x7009f460 <Udma_chEnableLocal+0x40> @ imm = #0x10
7009f44e: e7ff         	b	0x7009f450 <Udma_chEnableLocal+0x30> @ imm = #-0x2
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum , &bcdmaRtEnable);
7009f450: 980b         	ldr	r0, [sp, #0x2c]
7009f452: 3008         	adds	r0, #0x8
7009f454: 990d         	ldr	r1, [sp, #0x34]
7009f456: 6ec9         	ldr	r1, [r1, #0x6c]
7009f458: aa05         	add	r2, sp, #0x14
7009f45a: f00d fa71    	bl	0x700ac940 <CSL_bcdmaSetTxRT> @ imm = #0xd4e2
;         }
7009f45e: e04c         	b	0x7009f4fa <Udma_chEnableLocal+0xda> @ imm = #0x98
;         else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009f460: 980d         	ldr	r0, [sp, #0x34]
7009f462: 7800         	ldrb	r0, [r0]
7009f464: 07c0         	lsls	r0, r0, #0x1f
7009f466: b300         	cbz	r0, 0x7009f4aa <Udma_chEnableLocal+0x8a> @ imm = #0x40
7009f468: e7ff         	b	0x7009f46a <Udma_chEnableLocal+0x4a> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaTxRtRegs->PEER8);
7009f46a: 980d         	ldr	r0, [sp, #0x34]
7009f46c: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f470: f500 7008    	add.w	r0, r0, #0x220
7009f474: f00e fa94    	bl	0x700ad9a0 <CSL_REG32_RD_RAW> @ imm = #0xe528
7009f478: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f47a: 980c         	ldr	r0, [sp, #0x30]
7009f47c: f040 4000    	orr	r0, r0, #0x80000000
7009f480: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaTxRtRegs->PEER8, regVal);
7009f482: 980d         	ldr	r0, [sp, #0x34]
7009f484: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f488: f500 7008    	add.w	r0, r0, #0x220
7009f48c: 990c         	ldr	r1, [sp, #0x30]
7009f48e: f00e f9e7    	bl	0x700ad860 <CSL_REG32_WR_RAW> @ imm = #0xe3ce
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtEnable);
7009f492: 9a0b         	ldr	r2, [sp, #0x2c]
7009f494: f102 0008    	add.w	r0, r2, #0x8
7009f498: 990d         	ldr	r1, [sp, #0x34]
7009f49a: 6ec9         	ldr	r1, [r1, #0x6c]
7009f49c: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009f4a0: 4411         	add	r1, r2
7009f4a2: aa05         	add	r2, sp, #0x14
7009f4a4: f00d fa4c    	bl	0x700ac940 <CSL_bcdmaSetTxRT> @ imm = #0xd498
;         }
7009f4a8: e026         	b	0x7009f4f8 <Udma_chEnableLocal+0xd8> @ imm = #0x4c
;         else if ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009f4aa: 980d         	ldr	r0, [sp, #0x34]
7009f4ac: 7800         	ldrb	r0, [r0]
7009f4ae: 0780         	lsls	r0, r0, #0x1e
7009f4b0: 2800         	cmp	r0, #0x0
7009f4b2: d520         	bpl	0x7009f4f6 <Udma_chEnableLocal+0xd6> @ imm = #0x40
7009f4b4: e7ff         	b	0x7009f4b6 <Udma_chEnableLocal+0x96> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtEnable);
7009f4b6: 9a0b         	ldr	r2, [sp, #0x2c]
7009f4b8: f102 0008    	add.w	r0, r2, #0x8
7009f4bc: 990d         	ldr	r1, [sp, #0x34]
7009f4be: 6f09         	ldr	r1, [r1, #0x70]
7009f4c0: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009f4c4: 4411         	add	r1, r2
7009f4c6: aa05         	add	r2, sp, #0x14
;             (void) CSL_bcdmaSetRxRT(
7009f4c8: f00d fa22    	bl	0x700ac910 <CSL_bcdmaSetRxRT> @ imm = #0xd444
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
7009f4cc: 980d         	ldr	r0, [sp, #0x34]
7009f4ce: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f4d2: f500 7008    	add.w	r0, r0, #0x220
7009f4d6: f00e fa63    	bl	0x700ad9a0 <CSL_REG32_RD_RAW> @ imm = #0xe4c6
7009f4da: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f4dc: 980c         	ldr	r0, [sp, #0x30]
7009f4de: f040 4000    	orr	r0, r0, #0x80000000
7009f4e2: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
7009f4e4: 980d         	ldr	r0, [sp, #0x34]
7009f4e6: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f4ea: f500 7008    	add.w	r0, r0, #0x220
7009f4ee: 990c         	ldr	r1, [sp, #0x30]
7009f4f0: f00e f9b6    	bl	0x700ad860 <CSL_REG32_WR_RAW> @ imm = #0xe36c
;         }
7009f4f4: e7ff         	b	0x7009f4f6 <Udma_chEnableLocal+0xd6> @ imm = #-0x2
7009f4f6: e7ff         	b	0x7009f4f8 <Udma_chEnableLocal+0xd8> @ imm = #-0x2
7009f4f8: e7ff         	b	0x7009f4fa <Udma_chEnableLocal+0xda> @ imm = #-0x2
;     }
7009f4fa: e050         	b	0x7009f59e <Udma_chEnableLocal+0x17e> @ imm = #0xa0
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f4fc: 980b         	ldr	r0, [sp, #0x2c]
7009f4fe: 6800         	ldr	r0, [r0]
7009f500: 2802         	cmp	r0, #0x2
7009f502: d14b         	bne	0x7009f59c <Udma_chEnableLocal+0x17c> @ imm = #0x96
7009f504: e7ff         	b	0x7009f506 <Udma_chEnableLocal+0xe6> @ imm = #-0x2
7009f506: 2001         	movs	r0, #0x1
;         pktdmaRtEnable.enable         = TRUE;
7009f508: 9000         	str	r0, [sp]
7009f50a: 2000         	movs	r0, #0x0
;         pktdmaRtEnable.teardown       = FALSE;
7009f50c: 9001         	str	r0, [sp, #0x4]
;         pktdmaRtEnable.forcedTeardown = FALSE;
7009f50e: 9004         	str	r0, [sp, #0x10]
;         pktdmaRtEnable.pause          = FALSE;
7009f510: 9002         	str	r0, [sp, #0x8]
;         pktdmaRtEnable.error          = FALSE;
7009f512: 9003         	str	r0, [sp, #0xc]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009f514: 980d         	ldr	r0, [sp, #0x34]
7009f516: 7800         	ldrb	r0, [r0]
7009f518: 07c0         	lsls	r0, r0, #0x1f
7009f51a: b1e0         	cbz	r0, 0x7009f556 <Udma_chEnableLocal+0x136> @ imm = #0x38
7009f51c: e7ff         	b	0x7009f51e <Udma_chEnableLocal+0xfe> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaTxRtRegs->PEER8);
7009f51e: 980d         	ldr	r0, [sp, #0x34]
7009f520: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f524: f500 7008    	add.w	r0, r0, #0x220
7009f528: f00e fa3a    	bl	0x700ad9a0 <CSL_REG32_RD_RAW> @ imm = #0xe474
7009f52c: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f52e: 980c         	ldr	r0, [sp, #0x30]
7009f530: f040 4000    	orr	r0, r0, #0x80000000
7009f534: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaTxRtRegs->PEER8, regVal);
7009f536: 980d         	ldr	r0, [sp, #0x34]
7009f538: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f53c: f500 7008    	add.w	r0, r0, #0x220
7009f540: 990c         	ldr	r1, [sp, #0x30]
7009f542: f00e f98d    	bl	0x700ad860 <CSL_REG32_WR_RAW> @ imm = #0xe31a
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtEnable);
7009f546: 980b         	ldr	r0, [sp, #0x2c]
7009f548: 3054         	adds	r0, #0x54
7009f54a: 990d         	ldr	r1, [sp, #0x34]
7009f54c: 6ec9         	ldr	r1, [r1, #0x6c]
7009f54e: 466a         	mov	r2, sp
7009f550: f00c fc66    	bl	0x700abe20 <CSL_pktdmaSetTxRT> @ imm = #0xc8cc
;         }
7009f554: e7ff         	b	0x7009f556 <Udma_chEnableLocal+0x136> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009f556: 980d         	ldr	r0, [sp, #0x34]
7009f558: 7800         	ldrb	r0, [r0]
7009f55a: 0780         	lsls	r0, r0, #0x1e
7009f55c: 2800         	cmp	r0, #0x0
7009f55e: d51c         	bpl	0x7009f59a <Udma_chEnableLocal+0x17a> @ imm = #0x38
7009f560: e7ff         	b	0x7009f562 <Udma_chEnableLocal+0x142> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtEnable);
7009f562: 980b         	ldr	r0, [sp, #0x2c]
7009f564: 3054         	adds	r0, #0x54
7009f566: 990d         	ldr	r1, [sp, #0x34]
7009f568: 6f09         	ldr	r1, [r1, #0x70]
7009f56a: 466a         	mov	r2, sp
;             (void) CSL_pktdmaSetRxRT(
7009f56c: f00c fc38    	bl	0x700abde0 <CSL_pktdmaSetRxRT> @ imm = #0xc870
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
7009f570: 980d         	ldr	r0, [sp, #0x34]
7009f572: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f576: f500 7008    	add.w	r0, r0, #0x220
7009f57a: f00e fa11    	bl	0x700ad9a0 <CSL_REG32_RD_RAW> @ imm = #0xe422
7009f57e: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f580: 980c         	ldr	r0, [sp, #0x30]
7009f582: f040 4000    	orr	r0, r0, #0x80000000
7009f586: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
7009f588: 980d         	ldr	r0, [sp, #0x34]
7009f58a: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f58e: f500 7008    	add.w	r0, r0, #0x220
7009f592: 990c         	ldr	r1, [sp, #0x30]
7009f594: f00e f964    	bl	0x700ad860 <CSL_REG32_WR_RAW> @ imm = #0xe2c8
;         }
7009f598: e7ff         	b	0x7009f59a <Udma_chEnableLocal+0x17a> @ imm = #-0x2
;     }
7009f59a: e7ff         	b	0x7009f59c <Udma_chEnableLocal+0x17c> @ imm = #-0x2
7009f59c: e7ff         	b	0x7009f59e <Udma_chEnableLocal+0x17e> @ imm = #-0x2
;     return;
7009f59e: b00e         	add	sp, #0x38
7009f5a0: bd80         	pop	{r7, pc}
		...
7009f5ae: 0000         	movs	r0, r0

7009f5b0 <Udma_chConfigPdma>:
; {
7009f5b0: b580         	push	{r7, lr}
7009f5b2: b08a         	sub	sp, #0x28
7009f5b4: 9009         	str	r0, [sp, #0x24]
7009f5b6: 9108         	str	r1, [sp, #0x20]
7009f5b8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f5ba: 9007         	str	r0, [sp, #0x1c]
;     volatile uint32_t  *PEER8=NULL, *PEER0=NULL, *PEER1=NULL;
7009f5bc: 9006         	str	r0, [sp, #0x18]
7009f5be: 9005         	str	r0, [sp, #0x14]
7009f5c0: 9004         	str	r0, [sp, #0x10]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
7009f5c2: 9809         	ldr	r0, [sp, #0x24]
7009f5c4: 9002         	str	r0, [sp, #0x8]
;     if((NULL_PTR == chHandleInt) ||
7009f5c6: 9802         	ldr	r0, [sp, #0x8]
7009f5c8: b1a0         	cbz	r0, 0x7009f5f4 <Udma_chConfigPdma+0x44> @ imm = #0x28
7009f5ca: e7ff         	b	0x7009f5cc <Udma_chConfigPdma+0x1c> @ imm = #-0x2
;        (NULL_PTR == pdmaPrms) ||
7009f5cc: 9808         	ldr	r0, [sp, #0x20]
7009f5ce: b188         	cbz	r0, 0x7009f5f4 <Udma_chConfigPdma+0x44> @ imm = #0x22
7009f5d0: e7ff         	b	0x7009f5d2 <Udma_chConfigPdma+0x22> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009f5d2: 9802         	ldr	r0, [sp, #0x8]
7009f5d4: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009f5d8: f64a 31cd    	movw	r1, #0xabcd
7009f5dc: f6ca 31dc    	movt	r1, #0xabdc
7009f5e0: 4288         	cmp	r0, r1
7009f5e2: d107         	bne	0x7009f5f4 <Udma_chConfigPdma+0x44> @ imm = #0xe
7009f5e4: e7ff         	b	0x7009f5e6 <Udma_chConfigPdma+0x36> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_PDMA) != UDMA_CH_FLAG_PDMA))
7009f5e6: 9802         	ldr	r0, [sp, #0x8]
7009f5e8: 6800         	ldr	r0, [r0]
7009f5ea: f000 0008    	and	r0, r0, #0x8
;     if((NULL_PTR == chHandleInt) ||
7009f5ee: 2808         	cmp	r0, #0x8
7009f5f0: d004         	beq	0x7009f5fc <Udma_chConfigPdma+0x4c> @ imm = #0x8
7009f5f2: e7ff         	b	0x7009f5f4 <Udma_chConfigPdma+0x44> @ imm = #-0x2
7009f5f4: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009f5f8: 9007         	str	r0, [sp, #0x1c]
;     }
7009f5fa: e7ff         	b	0x7009f5fc <Udma_chConfigPdma+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f5fc: 9807         	ldr	r0, [sp, #0x1c]
7009f5fe: b9a8         	cbnz	r0, 0x7009f62c <Udma_chConfigPdma+0x7c> @ imm = #0x2a
7009f600: e7ff         	b	0x7009f602 <Udma_chConfigPdma+0x52> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009f602: 9802         	ldr	r0, [sp, #0x8]
7009f604: 6e80         	ldr	r0, [r0, #0x68]
7009f606: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009f608: 9803         	ldr	r0, [sp, #0xc]
7009f60a: b150         	cbz	r0, 0x7009f622 <Udma_chConfigPdma+0x72> @ imm = #0x14
7009f60c: e7ff         	b	0x7009f60e <Udma_chConfigPdma+0x5e> @ imm = #-0x2
7009f60e: 9803         	ldr	r0, [sp, #0xc]
7009f610: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009f614: f64a 31cd    	movw	r1, #0xabcd
7009f618: f6ca 31dc    	movt	r1, #0xabdc
7009f61c: 4288         	cmp	r0, r1
7009f61e: d004         	beq	0x7009f62a <Udma_chConfigPdma+0x7a> @ imm = #0x8
7009f620: e7ff         	b	0x7009f622 <Udma_chConfigPdma+0x72> @ imm = #-0x2
7009f622: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009f626: 9007         	str	r0, [sp, #0x1c]
;         }
7009f628: e7ff         	b	0x7009f62a <Udma_chConfigPdma+0x7a> @ imm = #-0x2
;     }
7009f62a: e7ff         	b	0x7009f62c <Udma_chConfigPdma+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f62c: 9807         	ldr	r0, [sp, #0x1c]
7009f62e: 2800         	cmp	r0, #0x0
7009f630: d17a         	bne	0x7009f728 <Udma_chConfigPdma+0x178> @ imm = #0xf4
7009f632: e7ff         	b	0x7009f634 <Udma_chConfigPdma+0x84> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f634: 9803         	ldr	r0, [sp, #0xc]
7009f636: 6800         	ldr	r0, [r0]
7009f638: 2801         	cmp	r0, #0x1
7009f63a: d137         	bne	0x7009f6ac <Udma_chConfigPdma+0xfc> @ imm = #0x6e
7009f63c: e7ff         	b	0x7009f63e <Udma_chConfigPdma+0x8e> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009f63e: 9802         	ldr	r0, [sp, #0x8]
7009f640: 7800         	ldrb	r0, [r0]
7009f642: 07c0         	lsls	r0, r0, #0x1f
7009f644: b198         	cbz	r0, 0x7009f66e <Udma_chConfigPdma+0xbe> @ imm = #0x26
7009f646: e7ff         	b	0x7009f648 <Udma_chConfigPdma+0x98> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pBcdmaTxRtRegs->PEER8;
7009f648: 9802         	ldr	r0, [sp, #0x8]
7009f64a: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f64e: f500 7008    	add.w	r0, r0, #0x220
7009f652: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaTxRtRegs->PEER1;
7009f654: 9802         	ldr	r0, [sp, #0x8]
7009f656: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f65a: f500 7001    	add.w	r0, r0, #0x204
7009f65e: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaTxRtRegs->PEER0;
7009f660: 9802         	ldr	r0, [sp, #0x8]
7009f662: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f666: f500 7000    	add.w	r0, r0, #0x200
7009f66a: 9005         	str	r0, [sp, #0x14]
;             }
7009f66c: e012         	b	0x7009f694 <Udma_chConfigPdma+0xe4> @ imm = #0x24
;                 PEER8 = &chHandleInt->pBcdmaRxRtRegs->PEER8;
7009f66e: 9802         	ldr	r0, [sp, #0x8]
7009f670: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f674: f500 7008    	add.w	r0, r0, #0x220
7009f678: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaRxRtRegs->PEER1;
7009f67a: 9802         	ldr	r0, [sp, #0x8]
7009f67c: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f680: f500 7001    	add.w	r0, r0, #0x204
7009f684: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaRxRtRegs->PEER0;
7009f686: 9802         	ldr	r0, [sp, #0x8]
7009f688: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f68c: f500 7000    	add.w	r0, r0, #0x200
7009f690: 9005         	str	r0, [sp, #0x14]
7009f692: e7ff         	b	0x7009f694 <Udma_chConfigPdma+0xe4> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
7009f694: 9803         	ldr	r0, [sp, #0xc]
7009f696: 9908         	ldr	r1, [sp, #0x20]
7009f698: 9a06         	ldr	r2, [sp, #0x18]
7009f69a: 9b04         	ldr	r3, [sp, #0x10]
7009f69c: f8dd c014    	ldr.w	r12, [sp, #0x14]
7009f6a0: 46ee         	mov	lr, sp
7009f6a2: f8ce c000    	str.w	r12, [lr]
7009f6a6: f00b fa33    	bl	0x700aab10 <Udma_chSetPeerReg> @ imm = #0xb466
;         }
7009f6aa: e03c         	b	0x7009f726 <Udma_chConfigPdma+0x176> @ imm = #0x78
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f6ac: 9803         	ldr	r0, [sp, #0xc]
7009f6ae: 6800         	ldr	r0, [r0]
7009f6b0: 2802         	cmp	r0, #0x2
7009f6b2: d137         	bne	0x7009f724 <Udma_chConfigPdma+0x174> @ imm = #0x6e
7009f6b4: e7ff         	b	0x7009f6b6 <Udma_chConfigPdma+0x106> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009f6b6: 9802         	ldr	r0, [sp, #0x8]
7009f6b8: 7800         	ldrb	r0, [r0]
7009f6ba: 07c0         	lsls	r0, r0, #0x1f
7009f6bc: b198         	cbz	r0, 0x7009f6e6 <Udma_chConfigPdma+0x136> @ imm = #0x26
7009f6be: e7ff         	b	0x7009f6c0 <Udma_chConfigPdma+0x110> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pPktdmaTxRtRegs->PEER8;
7009f6c0: 9802         	ldr	r0, [sp, #0x8]
7009f6c2: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f6c6: f500 7008    	add.w	r0, r0, #0x220
7009f6ca: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaTxRtRegs->PEER1;
7009f6cc: 9802         	ldr	r0, [sp, #0x8]
7009f6ce: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f6d2: f500 7001    	add.w	r0, r0, #0x204
7009f6d6: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaTxRtRegs->PEER0;
7009f6d8: 9802         	ldr	r0, [sp, #0x8]
7009f6da: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f6de: f500 7000    	add.w	r0, r0, #0x200
7009f6e2: 9005         	str	r0, [sp, #0x14]
;             }
7009f6e4: e012         	b	0x7009f70c <Udma_chConfigPdma+0x15c> @ imm = #0x24
;                 PEER8 = &chHandleInt->pPktdmaRxRtRegs->PEER8;
7009f6e6: 9802         	ldr	r0, [sp, #0x8]
7009f6e8: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f6ec: f500 7008    	add.w	r0, r0, #0x220
7009f6f0: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaRxRtRegs->PEER1;
7009f6f2: 9802         	ldr	r0, [sp, #0x8]
7009f6f4: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f6f8: f500 7001    	add.w	r0, r0, #0x204
7009f6fc: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaRxRtRegs->PEER0;
7009f6fe: 9802         	ldr	r0, [sp, #0x8]
7009f700: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f704: f500 7000    	add.w	r0, r0, #0x200
7009f708: 9005         	str	r0, [sp, #0x14]
7009f70a: e7ff         	b	0x7009f70c <Udma_chConfigPdma+0x15c> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
7009f70c: 9803         	ldr	r0, [sp, #0xc]
7009f70e: 9908         	ldr	r1, [sp, #0x20]
7009f710: 9a06         	ldr	r2, [sp, #0x18]
7009f712: 9b04         	ldr	r3, [sp, #0x10]
7009f714: f8dd c014    	ldr.w	r12, [sp, #0x14]
7009f718: 46ee         	mov	lr, sp
7009f71a: f8ce c000    	str.w	r12, [lr]
7009f71e: f00b f9f7    	bl	0x700aab10 <Udma_chSetPeerReg> @ imm = #0xb3ee
;         }
7009f722: e7ff         	b	0x7009f724 <Udma_chConfigPdma+0x174> @ imm = #-0x2
7009f724: e7ff         	b	0x7009f726 <Udma_chConfigPdma+0x176> @ imm = #-0x2
;     }
7009f726: e7ff         	b	0x7009f728 <Udma_chConfigPdma+0x178> @ imm = #-0x2
;     return (retVal);
7009f728: 9807         	ldr	r0, [sp, #0x1c]
7009f72a: b00a         	add	sp, #0x28
7009f72c: bd80         	pop	{r7, pc}
7009f72e: 0000         	movs	r0, r0

7009f730 <xQueueSemaphoreTake>:
; {
7009f730: b580         	push	{r7, lr}
7009f732: b08a         	sub	sp, #0x28
7009f734: 9008         	str	r0, [sp, #0x20]
7009f736: 9107         	str	r1, [sp, #0x1c]
7009f738: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
7009f73a: 9006         	str	r0, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
7009f73c: 9908         	ldr	r1, [sp, #0x20]
7009f73e: 9103         	str	r1, [sp, #0xc]
;         BaseType_t xInheritanceOccurred = pdFALSE;
7009f740: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
7009f742: e7ff         	b	0x7009f744 <xQueueSemaphoreTake+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
7009f744: f00c ff24    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0xce48
;             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
7009f748: 9803         	ldr	r0, [sp, #0xc]
7009f74a: 6b80         	ldr	r0, [r0, #0x38]
7009f74c: 9001         	str	r0, [sp, #0x4]
;             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
7009f74e: 9801         	ldr	r0, [sp, #0x4]
7009f750: b310         	cbz	r0, 0x7009f798 <xQueueSemaphoreTake+0x68> @ imm = #0x44
7009f752: e7ff         	b	0x7009f754 <xQueueSemaphoreTake+0x24> @ imm = #-0x2
;                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
7009f754: 9801         	ldr	r0, [sp, #0x4]
7009f756: 3801         	subs	r0, #0x1
7009f758: 9903         	ldr	r1, [sp, #0xc]
7009f75a: 6388         	str	r0, [r1, #0x38]
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
7009f75c: 9803         	ldr	r0, [sp, #0xc]
7009f75e: 6800         	ldr	r0, [r0]
7009f760: b928         	cbnz	r0, 0x7009f76e <xQueueSemaphoreTake+0x3e> @ imm = #0xa
7009f762: e7ff         	b	0x7009f764 <xQueueSemaphoreTake+0x34> @ imm = #-0x2
;                             pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
7009f764: f00d f97c    	bl	0x700aca60 <pvTaskIncrementMutexHeldCount> @ imm = #0xd2f8
7009f768: 9903         	ldr	r1, [sp, #0xc]
7009f76a: 6088         	str	r0, [r1, #0x8]
;                         }
7009f76c: e000         	b	0x7009f770 <xQueueSemaphoreTake+0x40> @ imm = #0x0
7009f76e: e7ff         	b	0x7009f770 <xQueueSemaphoreTake+0x40> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
7009f770: 9803         	ldr	r0, [sp, #0xc]
7009f772: 6900         	ldr	r0, [r0, #0x10]
7009f774: b150         	cbz	r0, 0x7009f78c <xQueueSemaphoreTake+0x5c> @ imm = #0x14
7009f776: e7ff         	b	0x7009f778 <xQueueSemaphoreTake+0x48> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
7009f778: 9803         	ldr	r0, [sp, #0xc]
7009f77a: 3010         	adds	r0, #0x10
7009f77c: f006 fd88    	bl	0x700a6290 <xTaskRemoveFromEventList> @ imm = #0x6b10
7009f780: b110         	cbz	r0, 0x7009f788 <xQueueSemaphoreTake+0x58> @ imm = #0x4
7009f782: e7ff         	b	0x7009f784 <xQueueSemaphoreTake+0x54> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
7009f784: df00         	svc	#0x0
;                     }
7009f786: e000         	b	0x7009f78a <xQueueSemaphoreTake+0x5a> @ imm = #0x0
7009f788: e7ff         	b	0x7009f78a <xQueueSemaphoreTake+0x5a> @ imm = #-0x2
;                 }
7009f78a: e000         	b	0x7009f78e <xQueueSemaphoreTake+0x5e> @ imm = #0x0
7009f78c: e7ff         	b	0x7009f78e <xQueueSemaphoreTake+0x5e> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
7009f78e: f00b ffbf    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xbf7e
7009f792: 2001         	movs	r0, #0x1
;                 return pdPASS;
7009f794: 9009         	str	r0, [sp, #0x24]
7009f796: e083         	b	0x7009f8a0 <xQueueSemaphoreTake+0x170> @ imm = #0x106
;                 if( xTicksToWait == ( TickType_t ) 0 )
7009f798: 9807         	ldr	r0, [sp, #0x1c]
7009f79a: b928         	cbnz	r0, 0x7009f7a8 <xQueueSemaphoreTake+0x78> @ imm = #0xa
7009f79c: e7ff         	b	0x7009f79e <xQueueSemaphoreTake+0x6e> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
7009f79e: f00b ffb7    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xbf6e
7009f7a2: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
7009f7a4: 9009         	str	r0, [sp, #0x24]
7009f7a6: e07b         	b	0x7009f8a0 <xQueueSemaphoreTake+0x170> @ imm = #0xf6
;                 else if( xEntryTimeSet == pdFALSE )
7009f7a8: 9806         	ldr	r0, [sp, #0x18]
7009f7aa: b930         	cbnz	r0, 0x7009f7ba <xQueueSemaphoreTake+0x8a> @ imm = #0xc
7009f7ac: e7ff         	b	0x7009f7ae <xQueueSemaphoreTake+0x7e> @ imm = #-0x2
7009f7ae: a804         	add	r0, sp, #0x10
;                     vTaskInternalSetTimeOutState( &xTimeOut );
7009f7b0: f00d fc36    	bl	0x700ad020 <vTaskInternalSetTimeOutState> @ imm = #0xd86c
7009f7b4: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
7009f7b6: 9006         	str	r0, [sp, #0x18]
;                 }
7009f7b8: e000         	b	0x7009f7bc <xQueueSemaphoreTake+0x8c> @ imm = #0x0
7009f7ba: e7ff         	b	0x7009f7bc <xQueueSemaphoreTake+0x8c> @ imm = #-0x2
7009f7bc: e7ff         	b	0x7009f7be <xQueueSemaphoreTake+0x8e> @ imm = #-0x2
7009f7be: e7ff         	b	0x7009f7c0 <xQueueSemaphoreTake+0x90> @ imm = #-0x2
;         taskEXIT_CRITICAL();
7009f7c0: f00b ffa6    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xbf4c
;         vTaskSuspendAll();
7009f7c4: f00e f8a4    	bl	0x700ad910 <vTaskSuspendAll> @ imm = #0xe148
;         prvLockQueue( pxQueue );
7009f7c8: f00c fee2    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0xcdc4
7009f7cc: 9803         	ldr	r0, [sp, #0xc]
7009f7ce: f990 0044    	ldrsb.w	r0, [r0, #0x44]
7009f7d2: 3001         	adds	r0, #0x1
7009f7d4: b928         	cbnz	r0, 0x7009f7e2 <xQueueSemaphoreTake+0xb2> @ imm = #0xa
7009f7d6: e7ff         	b	0x7009f7d8 <xQueueSemaphoreTake+0xa8> @ imm = #-0x2
7009f7d8: 9903         	ldr	r1, [sp, #0xc]
7009f7da: 2000         	movs	r0, #0x0
7009f7dc: f881 0044    	strb.w	r0, [r1, #0x44]
7009f7e0: e7ff         	b	0x7009f7e2 <xQueueSemaphoreTake+0xb2> @ imm = #-0x2
7009f7e2: 9803         	ldr	r0, [sp, #0xc]
7009f7e4: f990 0045    	ldrsb.w	r0, [r0, #0x45]
7009f7e8: 3001         	adds	r0, #0x1
7009f7ea: b928         	cbnz	r0, 0x7009f7f8 <xQueueSemaphoreTake+0xc8> @ imm = #0xa
7009f7ec: e7ff         	b	0x7009f7ee <xQueueSemaphoreTake+0xbe> @ imm = #-0x2
7009f7ee: 9903         	ldr	r1, [sp, #0xc]
7009f7f0: 2000         	movs	r0, #0x0
7009f7f2: f881 0045    	strb.w	r0, [r1, #0x45]
7009f7f6: e7ff         	b	0x7009f7f8 <xQueueSemaphoreTake+0xc8> @ imm = #-0x2
7009f7f8: f00b ff8a    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xbf14
7009f7fc: a804         	add	r0, sp, #0x10
7009f7fe: a907         	add	r1, sp, #0x1c
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
7009f800: f007 fc76    	bl	0x700a70f0 <xTaskCheckForTimeOut> @ imm = #0x78ec
7009f804: bb58         	cbnz	r0, 0x7009f85e <xQueueSemaphoreTake+0x12e> @ imm = #0x56
7009f806: e7ff         	b	0x7009f808 <xQueueSemaphoreTake+0xd8> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
7009f808: 9803         	ldr	r0, [sp, #0xc]
7009f80a: f00d fa61    	bl	0x700accd0 <prvIsQueueEmpty> @ imm = #0xd4c2
7009f80e: b1f8         	cbz	r0, 0x7009f850 <xQueueSemaphoreTake+0x120> @ imm = #0x3e
7009f810: e7ff         	b	0x7009f812 <xQueueSemaphoreTake+0xe2> @ imm = #-0x2
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
7009f812: 9803         	ldr	r0, [sp, #0xc]
7009f814: 6800         	ldr	r0, [r0]
7009f816: b950         	cbnz	r0, 0x7009f82e <xQueueSemaphoreTake+0xfe> @ imm = #0x14
7009f818: e7ff         	b	0x7009f81a <xQueueSemaphoreTake+0xea> @ imm = #-0x2
;                             taskENTER_CRITICAL();
7009f81a: f00c feb9    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0xcd72
;                                 xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
7009f81e: 9803         	ldr	r0, [sp, #0xc]
7009f820: 6880         	ldr	r0, [r0, #0x8]
7009f822: f003 f945    	bl	0x700a2ab0 <xTaskPriorityInherit> @ imm = #0x328a
7009f826: 9002         	str	r0, [sp, #0x8]
;                             taskEXIT_CRITICAL();
7009f828: f00b ff72    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xbee4
;                         }
7009f82c: e000         	b	0x7009f830 <xQueueSemaphoreTake+0x100> @ imm = #0x0
7009f82e: e7ff         	b	0x7009f830 <xQueueSemaphoreTake+0x100> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
7009f830: 9803         	ldr	r0, [sp, #0xc]
7009f832: 3024         	adds	r0, #0x24
7009f834: 9907         	ldr	r1, [sp, #0x1c]
7009f836: f00d fb0b    	bl	0x700ace50 <vTaskPlaceOnEventList> @ imm = #0xd616
;                 prvUnlockQueue( pxQueue );
7009f83a: 9803         	ldr	r0, [sp, #0xc]
7009f83c: f006 fac0    	bl	0x700a5dc0 <prvUnlockQueue> @ imm = #0x6580
;                 if( xTaskResumeAll() == pdFALSE )
7009f840: f001 f9b6    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #0x136c
7009f844: b910         	cbnz	r0, 0x7009f84c <xQueueSemaphoreTake+0x11c> @ imm = #0x4
7009f846: e7ff         	b	0x7009f848 <xQueueSemaphoreTake+0x118> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
7009f848: df00         	svc	#0x0
;                 }
7009f84a: e000         	b	0x7009f84e <xQueueSemaphoreTake+0x11e> @ imm = #0x0
7009f84c: e7ff         	b	0x7009f84e <xQueueSemaphoreTake+0x11e> @ imm = #-0x2
;             }
7009f84e: e005         	b	0x7009f85c <xQueueSemaphoreTake+0x12c> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
7009f850: 9803         	ldr	r0, [sp, #0xc]
7009f852: f006 fab5    	bl	0x700a5dc0 <prvUnlockQueue> @ imm = #0x656a
;                 ( void ) xTaskResumeAll();
7009f856: f001 f9ab    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #0x1356
7009f85a: e7ff         	b	0x7009f85c <xQueueSemaphoreTake+0x12c> @ imm = #-0x2
;         }
7009f85c: e01f         	b	0x7009f89e <xQueueSemaphoreTake+0x16e> @ imm = #0x3e
;             prvUnlockQueue( pxQueue );
7009f85e: 9803         	ldr	r0, [sp, #0xc]
7009f860: f006 faae    	bl	0x700a5dc0 <prvUnlockQueue> @ imm = #0x655c
;             ( void ) xTaskResumeAll();
7009f864: f001 f9a4    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #0x1348
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
7009f868: 9803         	ldr	r0, [sp, #0xc]
7009f86a: f00d fa31    	bl	0x700accd0 <prvIsQueueEmpty> @ imm = #0xd462
7009f86e: b1a0         	cbz	r0, 0x7009f89a <xQueueSemaphoreTake+0x16a> @ imm = #0x28
7009f870: e7ff         	b	0x7009f872 <xQueueSemaphoreTake+0x142> @ imm = #-0x2
;                         if( xInheritanceOccurred != pdFALSE )
7009f872: 9802         	ldr	r0, [sp, #0x8]
7009f874: b170         	cbz	r0, 0x7009f894 <xQueueSemaphoreTake+0x164> @ imm = #0x1c
7009f876: e7ff         	b	0x7009f878 <xQueueSemaphoreTake+0x148> @ imm = #-0x2
;                             taskENTER_CRITICAL();
7009f878: f00c fe8a    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0xcd14
;                                 uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
7009f87c: 9803         	ldr	r0, [sp, #0xc]
7009f87e: f00d facf    	bl	0x700ace20 <prvGetDisinheritPriorityAfterTimeout> @ imm = #0xd59e
7009f882: 9000         	str	r0, [sp]
;                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
7009f884: 9803         	ldr	r0, [sp, #0xc]
7009f886: 6880         	ldr	r0, [r0, #0x8]
7009f888: 9900         	ldr	r1, [sp]
7009f88a: f004 f8a9    	bl	0x700a39e0 <vTaskPriorityDisinheritAfterTimeout> @ imm = #0x4152
;                             taskEXIT_CRITICAL();
7009f88e: f00b ff3f    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xbe7e
;                         }
7009f892: e7ff         	b	0x7009f894 <xQueueSemaphoreTake+0x164> @ imm = #-0x2
7009f894: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
7009f896: 9009         	str	r0, [sp, #0x24]
7009f898: e002         	b	0x7009f8a0 <xQueueSemaphoreTake+0x170> @ imm = #0x4
7009f89a: e7ff         	b	0x7009f89c <xQueueSemaphoreTake+0x16c> @ imm = #-0x2
7009f89c: e7ff         	b	0x7009f89e <xQueueSemaphoreTake+0x16e> @ imm = #-0x2
;     for( ; ; )
7009f89e: e751         	b	0x7009f744 <xQueueSemaphoreTake+0x14> @ imm = #-0x15e
; }
7009f8a0: 9809         	ldr	r0, [sp, #0x24]
7009f8a2: b00a         	add	sp, #0x28
7009f8a4: bd80         	pop	{r7, pc}
		...
7009f8ae: 0000         	movs	r0, r0

7009f8b0 <CSL_bcdmaChanOpTeardownChan>:
; {
7009f8b0: b580         	push	{r7, lr}
7009f8b2: b08c         	sub	sp, #0x30
7009f8b4: 900b         	str	r0, [sp, #0x2c]
7009f8b6: 910a         	str	r1, [sp, #0x28]
7009f8b8: 9209         	str	r2, [sp, #0x24]
7009f8ba: 9308         	str	r3, [sp, #0x20]
7009f8bc: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
7009f8be: 9007         	str	r0, [sp, #0x1c]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
7009f8c0: 980b         	ldr	r0, [sp, #0x2c]
7009f8c2: 990a         	ldr	r1, [sp, #0x28]
7009f8c4: 9a09         	ldr	r2, [sp, #0x24]
7009f8c6: f009 f86b    	bl	0x700a89a0 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x90d6
7009f8ca: b920         	cbnz	r0, 0x7009f8d6 <CSL_bcdmaChanOpTeardownChan+0x26> @ imm = #0x8
7009f8cc: e7ff         	b	0x7009f8ce <CSL_bcdmaChanOpTeardownChan+0x1e> @ imm = #-0x2
7009f8ce: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
7009f8d2: 9007         	str	r0, [sp, #0x1c]
;     }
7009f8d4: e09f         	b	0x7009fa16 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #0x13e
7009f8d6: 2000         	movs	r0, #0x0
;         uint32_t force = (uint32_t)0U, wait = (uint32_t)0U;
7009f8d8: 9005         	str	r0, [sp, #0x14]
7009f8da: 9004         	str	r0, [sp, #0x10]
;         if( pOpData != NULL )
7009f8dc: 9808         	ldr	r0, [sp, #0x20]
7009f8de: b148         	cbz	r0, 0x7009f8f4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #0x12
7009f8e0: e7ff         	b	0x7009f8e2 <CSL_bcdmaChanOpTeardownChan+0x32> @ imm = #-0x2
;             CSL_BcdmaTeardownOpts *pTdOpts = (CSL_BcdmaTeardownOpts *)pOpData;
7009f8e2: 9808         	ldr	r0, [sp, #0x20]
7009f8e4: 9003         	str	r0, [sp, #0xc]
;             force = pTdOpts->force;
7009f8e6: 9803         	ldr	r0, [sp, #0xc]
7009f8e8: 6800         	ldr	r0, [r0]
7009f8ea: 9005         	str	r0, [sp, #0x14]
;             wait  = pTdOpts->wait;
7009f8ec: 9803         	ldr	r0, [sp, #0xc]
7009f8ee: 6840         	ldr	r0, [r0, #0x4]
7009f8f0: 9004         	str	r0, [sp, #0x10]
;         }
7009f8f2: e7ff         	b	0x7009f8f4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #-0x2
;         switch( chanType )
7009f8f4: 980a         	ldr	r0, [sp, #0x28]
7009f8f6: 9001         	str	r0, [sp, #0x4]
7009f8f8: b148         	cbz	r0, 0x7009f90e <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #0x12
7009f8fa: e7ff         	b	0x7009f8fc <CSL_bcdmaChanOpTeardownChan+0x4c> @ imm = #-0x2
7009f8fc: 9801         	ldr	r0, [sp, #0x4]
7009f8fe: 2801         	cmp	r0, #0x1
7009f900: d024         	beq	0x7009f94c <CSL_bcdmaChanOpTeardownChan+0x9c> @ imm = #0x48
7009f902: e7ff         	b	0x7009f904 <CSL_bcdmaChanOpTeardownChan+0x54> @ imm = #-0x2
7009f904: 9801         	ldr	r0, [sp, #0x4]
7009f906: 2802         	cmp	r0, #0x2
7009f908: d03f         	beq	0x7009f98a <CSL_bcdmaChanOpTeardownChan+0xda> @ imm = #0x7e
7009f90a: e7ff         	b	0x7009f90c <CSL_bcdmaChanOpTeardownChan+0x5c> @ imm = #-0x2
;         {
7009f90c: e7ff         	b	0x7009f90e <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
7009f90e: 980b         	ldr	r0, [sp, #0x2c]
7009f910: 6880         	ldr	r0, [r0, #0x8]
7009f912: 9909         	ldr	r1, [sp, #0x24]
7009f914: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f918: f00e f81a    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xe034
7009f91c: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
7009f91e: 9806         	ldr	r0, [sp, #0x18]
7009f920: f040 4080    	orr	r0, r0, #0x40000000
7009f924: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
7009f926: 9806         	ldr	r0, [sp, #0x18]
7009f928: f020 5180    	bic	r1, r0, #0x10000000
7009f92c: 9a05         	ldr	r2, [sp, #0x14]
7009f92e: f101 5080    	add.w	r0, r1, #0x10000000
7009f932: 2a00         	cmp	r2, #0x0
7009f934: bf08         	it	eq
7009f936: 4608         	moveq	r0, r1
7009f938: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, regVal );
7009f93a: 980b         	ldr	r0, [sp, #0x2c]
7009f93c: 6880         	ldr	r0, [r0, #0x8]
7009f93e: 9909         	ldr	r1, [sp, #0x24]
7009f940: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f944: 9906         	ldr	r1, [sp, #0x18]
7009f946: f00d ff63    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xdec6
;                 break;
7009f94a: e03d         	b	0x7009f9c8 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x7a
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
7009f94c: 980b         	ldr	r0, [sp, #0x2c]
7009f94e: 6900         	ldr	r0, [r0, #0x10]
7009f950: 9909         	ldr	r1, [sp, #0x24]
7009f952: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f956: f00d fffb    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xdff6
7009f95a: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
7009f95c: 9806         	ldr	r0, [sp, #0x18]
7009f95e: f040 4080    	orr	r0, r0, #0x40000000
7009f962: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
7009f964: 9806         	ldr	r0, [sp, #0x18]
7009f966: f020 5180    	bic	r1, r0, #0x10000000
7009f96a: 9a05         	ldr	r2, [sp, #0x14]
7009f96c: f101 5080    	add.w	r0, r1, #0x10000000
7009f970: 2a00         	cmp	r2, #0x0
7009f972: bf08         	it	eq
7009f974: 4608         	moveq	r0, r1
7009f976: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
7009f978: 980b         	ldr	r0, [sp, #0x2c]
7009f97a: 6900         	ldr	r0, [r0, #0x10]
7009f97c: 9909         	ldr	r1, [sp, #0x24]
7009f97e: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f982: 9906         	ldr	r1, [sp, #0x18]
7009f984: f00d ff44    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xde88
;                 break;
7009f988: e01e         	b	0x7009f9c8 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x3c
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
7009f98a: 980b         	ldr	r0, [sp, #0x2c]
7009f98c: 6980         	ldr	r0, [r0, #0x18]
7009f98e: 9909         	ldr	r1, [sp, #0x24]
7009f990: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f994: f00d ffdc    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xdfb8
7009f998: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
7009f99a: 9806         	ldr	r0, [sp, #0x18]
7009f99c: f040 4080    	orr	r0, r0, #0x40000000
7009f9a0: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
7009f9a2: 9806         	ldr	r0, [sp, #0x18]
7009f9a4: f020 5180    	bic	r1, r0, #0x10000000
7009f9a8: 9a05         	ldr	r2, [sp, #0x14]
7009f9aa: f101 5080    	add.w	r0, r1, #0x10000000
7009f9ae: 2a00         	cmp	r2, #0x0
7009f9b0: bf08         	it	eq
7009f9b2: 4608         	moveq	r0, r1
7009f9b4: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
7009f9b6: 980b         	ldr	r0, [sp, #0x2c]
7009f9b8: 6980         	ldr	r0, [r0, #0x18]
7009f9ba: 9909         	ldr	r1, [sp, #0x24]
7009f9bc: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f9c0: 9906         	ldr	r1, [sp, #0x18]
7009f9c2: f00d ff25    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xde4a
;                 break;
7009f9c6: e7ff         	b	0x7009f9c8 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #-0x2
;         if(wait != 0U)
7009f9c8: 9804         	ldr	r0, [sp, #0x10]
7009f9ca: b318         	cbz	r0, 0x7009fa14 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #0x46
7009f9cc: e7ff         	b	0x7009f9ce <CSL_bcdmaChanOpTeardownChan+0x11e> @ imm = #-0x2
7009f9ce: 2080         	movs	r0, #0x80
;             uint32_t retryCnt = CSL_BCDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
7009f9d0: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
7009f9d2: e7ff         	b	0x7009f9d4 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x2
7009f9d4: 980b         	ldr	r0, [sp, #0x2c]
7009f9d6: 990a         	ldr	r1, [sp, #0x28]
7009f9d8: 9a09         	ldr	r2, [sp, #0x24]
7009f9da: f008 ffe1    	bl	0x700a89a0 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x8fc2
7009f9de: 4601         	mov	r1, r0
7009f9e0: 2000         	movs	r0, #0x0
7009f9e2: 9000         	str	r0, [sp]
7009f9e4: b131         	cbz	r1, 0x7009f9f4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #0xc
7009f9e6: e7ff         	b	0x7009f9e8 <CSL_bcdmaChanOpTeardownChan+0x138> @ imm = #-0x2
7009f9e8: 9802         	ldr	r0, [sp, #0x8]
7009f9ea: 2800         	cmp	r0, #0x0
7009f9ec: bf18         	it	ne
7009f9ee: 2001         	movne	r0, #0x1
7009f9f0: 9000         	str	r0, [sp]
7009f9f2: e7ff         	b	0x7009f9f4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #-0x2
7009f9f4: 9800         	ldr	r0, [sp]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
7009f9f6: 07c0         	lsls	r0, r0, #0x1f
7009f9f8: b120         	cbz	r0, 0x7009fa04 <CSL_bcdmaChanOpTeardownChan+0x154> @ imm = #0x8
7009f9fa: e7ff         	b	0x7009f9fc <CSL_bcdmaChanOpTeardownChan+0x14c> @ imm = #-0x2
;                 retryCnt--;
7009f9fc: 9802         	ldr	r0, [sp, #0x8]
7009f9fe: 3801         	subs	r0, #0x1
7009fa00: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
7009fa02: e7e7         	b	0x7009f9d4 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x32
;             if( retryCnt == (uint32_t)0U ) {
7009fa04: 9802         	ldr	r0, [sp, #0x8]
7009fa06: b920         	cbnz	r0, 0x7009fa12 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #0x8
7009fa08: e7ff         	b	0x7009fa0a <CSL_bcdmaChanOpTeardownChan+0x15a> @ imm = #-0x2
7009fa0a: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = CSL_EFAIL;
7009fa0e: 9007         	str	r0, [sp, #0x1c]
;             }
7009fa10: e7ff         	b	0x7009fa12 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #-0x2
;         }
7009fa12: e7ff         	b	0x7009fa14 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #-0x2
7009fa14: e7ff         	b	0x7009fa16 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #-0x2
;     return retVal;
7009fa16: 9807         	ldr	r0, [sp, #0x1c]
7009fa18: b00c         	add	sp, #0x30
7009fa1a: bd80         	pop	{r7, pc}
7009fa1c: 0000         	movs	r0, r0
7009fa1e: 0000         	movs	r0, r0

7009fa20 <CSL_bcdmaChanOp>:
; {
7009fa20: b580         	push	{r7, lr}
7009fa22: b088         	sub	sp, #0x20
7009fa24: f8dd c028    	ldr.w	r12, [sp, #0x28]
7009fa28: 9007         	str	r0, [sp, #0x1c]
7009fa2a: 9106         	str	r1, [sp, #0x18]
7009fa2c: 9205         	str	r2, [sp, #0x14]
7009fa2e: 9304         	str	r3, [sp, #0x10]
7009fa30: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
7009fa32: 9003         	str	r0, [sp, #0xc]
;     if( ( pCfg == NULL )                                    ||
7009fa34: 9807         	ldr	r0, [sp, #0x1c]
7009fa36: b158         	cbz	r0, 0x7009fa50 <CSL_bcdmaChanOp+0x30> @ imm = #0x16
7009fa38: e7ff         	b	0x7009fa3a <CSL_bcdmaChanOp+0x1a> @ imm = #-0x2
;         ( chanType > CSL_BCDMA_CHAN_TYPE_SPLIT_RX )         ||
7009fa3a: 9805         	ldr	r0, [sp, #0x14]
7009fa3c: 2802         	cmp	r0, #0x2
7009fa3e: d807         	bhi	0x7009fa50 <CSL_bcdmaChanOp+0x30> @ imm = #0xe
7009fa40: e7ff         	b	0x7009fa42 <CSL_bcdmaChanOp+0x22> @ imm = #-0x2
;         ( !CSL_bcdmaChanOpIsValidChanIdx( pCfg, chanType, chanIdx ) )
7009fa42: 9807         	ldr	r0, [sp, #0x1c]
7009fa44: 9905         	ldr	r1, [sp, #0x14]
7009fa46: 9a04         	ldr	r2, [sp, #0x10]
7009fa48: f008 ffea    	bl	0x700a8a20 <CSL_bcdmaChanOpIsValidChanIdx> @ imm = #0x8fd4
;     if( ( pCfg == NULL )                                    ||
7009fa4c: b920         	cbnz	r0, 0x7009fa58 <CSL_bcdmaChanOp+0x38> @ imm = #0x8
7009fa4e: e7ff         	b	0x7009fa50 <CSL_bcdmaChanOp+0x30> @ imm = #-0x2
7009fa50: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
7009fa54: 9003         	str	r0, [sp, #0xc]
;     }
7009fa56: e094         	b	0x7009fb82 <CSL_bcdmaChanOp+0x162> @ imm = #0x128
;         switch(chanOp )
7009fa58: 9806         	ldr	r0, [sp, #0x18]
7009fa5a: 9002         	str	r0, [sp, #0x8]
7009fa5c: 280e         	cmp	r0, #0xe
7009fa5e: f200 808b    	bhi.w	0x7009fb78 <CSL_bcdmaChanOp+0x158> @ imm = #0x116
7009fa62: 9902         	ldr	r1, [sp, #0x8]
7009fa64: e8df f001    	tbb	[pc, r1]
7009fa68: 08 10 18 20  	.word	0x20181008
7009fa6c: 28 30 38 3f  	.word	0x3f383028
7009fa70: 47 4f 57 5f  	.word	0x5f574f47
7009fa74: 6c 79 81 00  	.word	0x0081796c
;                 retVal = CSL_bcdmaChanOpCfgChan( pCfg, chanType, chanIdx, pOpData );
7009fa78: 9807         	ldr	r0, [sp, #0x1c]
7009fa7a: 9905         	ldr	r1, [sp, #0x14]
7009fa7c: 9a04         	ldr	r2, [sp, #0x10]
7009fa7e: 9b0a         	ldr	r3, [sp, #0x28]
7009fa80: f7fc fcce    	bl	0x7009c420 <CSL_bcdmaChanOpCfgChan> @ imm = #-0x3664
7009fa84: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa86: e07b         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0xf6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)true );
7009fa88: 9807         	ldr	r0, [sp, #0x1c]
7009fa8a: 9905         	ldr	r1, [sp, #0x14]
7009fa8c: 9a04         	ldr	r2, [sp, #0x10]
7009fa8e: 2301         	movs	r3, #0x1
7009fa90: f007 fb7e    	bl	0x700a7190 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x76fc
7009fa94: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa96: e073         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0xe6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)false );
7009fa98: 9807         	ldr	r0, [sp, #0x1c]
7009fa9a: 9905         	ldr	r1, [sp, #0x14]
7009fa9c: 9a04         	ldr	r2, [sp, #0x10]
7009fa9e: 2300         	movs	r3, #0x0
7009faa0: f007 fb76    	bl	0x700a7190 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x76ec
7009faa4: 9003         	str	r0, [sp, #0xc]
;                 break;
7009faa6: e06b         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0xd6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)true );
7009faa8: 9807         	ldr	r0, [sp, #0x1c]
7009faaa: 9905         	ldr	r1, [sp, #0x14]
7009faac: 9a04         	ldr	r2, [sp, #0x10]
7009faae: 2301         	movs	r3, #0x1
7009fab0: f006 fb3e    	bl	0x700a6130 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x667c
7009fab4: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fab6: e063         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0xc6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)false );
7009fab8: 9807         	ldr	r0, [sp, #0x1c]
7009faba: 9905         	ldr	r1, [sp, #0x14]
7009fabc: 9a04         	ldr	r2, [sp, #0x10]
7009fabe: 2300         	movs	r3, #0x0
7009fac0: f006 fb36    	bl	0x700a6130 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x666c
7009fac4: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fac6: e05b         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0xb6
;                 retVal = CSL_bcdmaChanOpTeardownChan( pCfg, chanType, chanIdx, pOpData );
7009fac8: 9807         	ldr	r0, [sp, #0x1c]
7009faca: 9905         	ldr	r1, [sp, #0x14]
7009facc: 9a04         	ldr	r2, [sp, #0x10]
7009face: 9b0a         	ldr	r3, [sp, #0x28]
7009fad0: f7ff feee    	bl	0x7009f8b0 <CSL_bcdmaChanOpTeardownChan> @ imm = #-0x224
7009fad4: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fad6: e053         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0xa6
;                 retVal = CSL_bcdmaChanOpTriggerChan( pCfg, chanType, chanIdx );
7009fad8: 9807         	ldr	r0, [sp, #0x1c]
7009fada: 9905         	ldr	r1, [sp, #0x14]
7009fadc: 9a04         	ldr	r2, [sp, #0x10]
7009fade: f009 fb5f    	bl	0x700a91a0 <CSL_bcdmaChanOpTriggerChan> @ imm = #0x96be
7009fae2: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fae4: e04c         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0x98
;                 retVal = CSL_bcdmaChanOpGetChanRT( pCfg, chanType, chanIdx, pOpData );
7009fae6: 9807         	ldr	r0, [sp, #0x1c]
7009fae8: 9905         	ldr	r1, [sp, #0x14]
7009faea: 9a04         	ldr	r2, [sp, #0x10]
7009faec: 9b0a         	ldr	r3, [sp, #0x28]
7009faee: f004 fdef    	bl	0x700a46d0 <CSL_bcdmaChanOpGetChanRT> @ imm = #0x4bde
7009faf2: 9003         	str	r0, [sp, #0xc]
;                 break;
7009faf4: e044         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0x88
;                 retVal = CSL_bcdmaChanOpSetChanRT( pCfg, chanType, chanIdx, pOpData );
7009faf6: 9807         	ldr	r0, [sp, #0x1c]
7009faf8: 9905         	ldr	r1, [sp, #0x14]
7009fafa: 9a04         	ldr	r2, [sp, #0x10]
7009fafc: 9b0a         	ldr	r3, [sp, #0x28]
7009fafe: f006 fb6f    	bl	0x700a61e0 <CSL_bcdmaChanOpSetChanRT> @ imm = #0x66de
7009fb02: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fb04: e03c         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0x78
;                 retVal = CSL_bcdmaChanOpGetChanStats( pCfg, chanType, chanIdx, pOpData );
7009fb06: 9807         	ldr	r0, [sp, #0x1c]
7009fb08: 9905         	ldr	r1, [sp, #0x14]
7009fb0a: 9a04         	ldr	r2, [sp, #0x10]
7009fb0c: 9b0a         	ldr	r3, [sp, #0x28]
7009fb0e: f000 fb0f    	bl	0x700a0130 <CSL_bcdmaChanOpGetChanStats> @ imm = #0x61e
7009fb12: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fb14: e034         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0x68
;                 retVal = CSL_bcdmaChanOpDecChanStats( pCfg, chanType, chanIdx, pOpData );
7009fb16: 9807         	ldr	r0, [sp, #0x1c]
7009fb18: 9905         	ldr	r1, [sp, #0x14]
7009fb1a: 9a04         	ldr	r2, [sp, #0x10]
7009fb1c: 9b0a         	ldr	r3, [sp, #0x28]
7009fb1e: f003 f9ff    	bl	0x700a2f20 <CSL_bcdmaChanOpDecChanStats> @ imm = #0x33fe
7009fb22: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fb24: e02c         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0x58
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)true );
7009fb26: 9807         	ldr	r0, [sp, #0x1c]
7009fb28: 9905         	ldr	r1, [sp, #0x14]
7009fb2a: 9a04         	ldr	r2, [sp, #0x10]
7009fb2c: 9b0a         	ldr	r3, [sp, #0x28]
7009fb2e: 46ee         	mov	lr, sp
7009fb30: f04f 0c01    	mov.w	r12, #0x1
7009fb34: f8ce c000    	str.w	r12, [lr]
7009fb38: f005 fd3a    	bl	0x700a55b0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5a74
7009fb3c: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fb3e: e01f         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0x3e
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)false );
7009fb40: 9807         	ldr	r0, [sp, #0x1c]
7009fb42: 9905         	ldr	r1, [sp, #0x14]
7009fb44: 9a04         	ldr	r2, [sp, #0x10]
7009fb46: 9b0a         	ldr	r3, [sp, #0x28]
7009fb48: 46ee         	mov	lr, sp
7009fb4a: f04f 0c00    	mov.w	r12, #0x0
7009fb4e: f8ce c000    	str.w	r12, [lr]
7009fb52: f005 fd2d    	bl	0x700a55b0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5a5a
7009fb56: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fb58: e012         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0x24
;                 retVal = CSL_bcdmaChanOpSetBurstSize( pCfg, chanType, chanIdx, pOpData );
7009fb5a: 9807         	ldr	r0, [sp, #0x1c]
7009fb5c: 9905         	ldr	r1, [sp, #0x14]
7009fb5e: 9a04         	ldr	r2, [sp, #0x10]
7009fb60: 9b0a         	ldr	r3, [sp, #0x28]
7009fb62: f005 f845    	bl	0x700a4bf0 <CSL_bcdmaChanOpSetBurstSize> @ imm = #0x508a
7009fb66: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fb68: e00a         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0x14
;                 retVal = CSL_bcdmaChanOpClearError( pCfg, chanType, chanIdx );
7009fb6a: 9807         	ldr	r0, [sp, #0x1c]
7009fb6c: 9905         	ldr	r1, [sp, #0x14]
7009fb6e: 9a04         	ldr	r2, [sp, #0x10]
7009fb70: f009 f996    	bl	0x700a8ea0 <CSL_bcdmaChanOpClearError> @ imm = #0x932c
7009fb74: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fb76: e003         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #0x6
7009fb78: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
7009fb7c: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fb7e: e7ff         	b	0x7009fb80 <CSL_bcdmaChanOp+0x160> @ imm = #-0x2
7009fb80: e7ff         	b	0x7009fb82 <CSL_bcdmaChanOp+0x162> @ imm = #-0x2
;     return retVal;
7009fb82: 9803         	ldr	r0, [sp, #0xc]
7009fb84: b008         	add	sp, #0x20
7009fb86: bd80         	pop	{r7, pc}
		...

7009fb90 <Udma_chOpen>:
; {
7009fb90: b580         	push	{r7, lr}
7009fb92: b08a         	sub	sp, #0x28
7009fb94: 9009         	str	r0, [sp, #0x24]
7009fb96: 9108         	str	r1, [sp, #0x20]
7009fb98: 9207         	str	r2, [sp, #0x1c]
7009fb9a: 9306         	str	r3, [sp, #0x18]
7009fb9c: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK, tempRetVal;
7009fb9e: 9005         	str	r0, [sp, #0x14]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009fba0: 9003         	str	r0, [sp, #0xc]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009fba2: 9809         	ldr	r0, [sp, #0x24]
7009fba4: 9001         	str	r0, [sp, #0x4]
;     if((drvHandleInt == NULL_PTR) || (NULL_PTR == chHandle) || (NULL_PTR == chPrms))
7009fba6: 9801         	ldr	r0, [sp, #0x4]
7009fba8: b130         	cbz	r0, 0x7009fbb8 <Udma_chOpen+0x28> @ imm = #0xc
7009fbaa: e7ff         	b	0x7009fbac <Udma_chOpen+0x1c> @ imm = #-0x2
7009fbac: 9808         	ldr	r0, [sp, #0x20]
7009fbae: b118         	cbz	r0, 0x7009fbb8 <Udma_chOpen+0x28> @ imm = #0x6
7009fbb0: e7ff         	b	0x7009fbb2 <Udma_chOpen+0x22> @ imm = #-0x2
7009fbb2: 9806         	ldr	r0, [sp, #0x18]
7009fbb4: b920         	cbnz	r0, 0x7009fbc0 <Udma_chOpen+0x30> @ imm = #0x8
7009fbb6: e7ff         	b	0x7009fbb8 <Udma_chOpen+0x28> @ imm = #-0x2
7009fbb8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009fbbc: 9005         	str	r0, [sp, #0x14]
;     }
7009fbbe: e7ff         	b	0x7009fbc0 <Udma_chOpen+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fbc0: 9805         	ldr	r0, [sp, #0x14]
7009fbc2: b978         	cbnz	r0, 0x7009fbe4 <Udma_chOpen+0x54> @ imm = #0x1e
7009fbc4: e7ff         	b	0x7009fbc6 <Udma_chOpen+0x36> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009fbc6: 9801         	ldr	r0, [sp, #0x4]
7009fbc8: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009fbcc: f64a 31cd    	movw	r1, #0xabcd
7009fbd0: f6ca 31dc    	movt	r1, #0xabdc
7009fbd4: 4288         	cmp	r0, r1
7009fbd6: d004         	beq	0x7009fbe2 <Udma_chOpen+0x52> @ imm = #0x8
7009fbd8: e7ff         	b	0x7009fbda <Udma_chOpen+0x4a> @ imm = #-0x2
7009fbda: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009fbde: 9005         	str	r0, [sp, #0x14]
;         }
7009fbe0: e7ff         	b	0x7009fbe2 <Udma_chOpen+0x52> @ imm = #-0x2
;     }
7009fbe2: e7ff         	b	0x7009fbe4 <Udma_chOpen+0x54> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fbe4: 9805         	ldr	r0, [sp, #0x14]
7009fbe6: b938         	cbnz	r0, 0x7009fbf8 <Udma_chOpen+0x68> @ imm = #0xe
7009fbe8: e7ff         	b	0x7009fbea <Udma_chOpen+0x5a> @ imm = #-0x2
;         retVal = Udma_chCheckParams(drvHandleInt, chType, chPrms);
7009fbea: 9801         	ldr	r0, [sp, #0x4]
7009fbec: 9907         	ldr	r1, [sp, #0x1c]
7009fbee: 9a06         	ldr	r2, [sp, #0x18]
7009fbf0: f006 f836    	bl	0x700a5c60 <Udma_chCheckParams> @ imm = #0x606c
7009fbf4: 9005         	str	r0, [sp, #0x14]
;     }
7009fbf6: e7ff         	b	0x7009fbf8 <Udma_chOpen+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fbf8: 9805         	ldr	r0, [sp, #0x14]
7009fbfa: 2800         	cmp	r0, #0x0
7009fbfc: d145         	bne	0x7009fc8a <Udma_chOpen+0xfa> @ imm = #0x8a
7009fbfe: e7ff         	b	0x7009fc00 <Udma_chOpen+0x70> @ imm = #-0x2
;         chHandleInt = (Udma_ChHandleInt) chHandle;
7009fc00: 9808         	ldr	r0, [sp, #0x20]
7009fc02: 9002         	str	r0, [sp, #0x8]
;         (void) memset(chHandleInt, 0, sizeof(Udma_ChObject));
7009fc04: 9802         	ldr	r0, [sp, #0x8]
7009fc06: f44f 7116    	mov.w	r1, #0x258
7009fc0a: f7f9 ef14    	blx	0x70099a34 <__aeabi_memclr8> @ imm = #-0x61d8
;         (void) memcpy(&chHandleInt->chPrms, chPrms, sizeof(Udma_ChPrms));
7009fc0e: 9802         	ldr	r0, [sp, #0x8]
7009fc10: 3004         	adds	r0, #0x4
7009fc12: 9906         	ldr	r1, [sp, #0x18]
7009fc14: 2264         	movs	r2, #0x64
7009fc16: f7fa eee2    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0x523c
;         chHandleInt->chType            = chType;
7009fc1a: 9807         	ldr	r0, [sp, #0x1c]
7009fc1c: 9902         	ldr	r1, [sp, #0x8]
7009fc1e: 6008         	str	r0, [r1]
;         chHandleInt->drvHandle         = drvHandleInt;
7009fc20: 9801         	ldr	r0, [sp, #0x4]
7009fc22: 9902         	ldr	r1, [sp, #0x8]
7009fc24: 6688         	str	r0, [r1, #0x68]
;         chHandleInt->txChNum           = UDMA_DMA_CH_INVALID;
7009fc26: 9902         	ldr	r1, [sp, #0x8]
7009fc28: 2000         	movs	r0, #0x0
7009fc2a: f6cf 70ff    	movt	r0, #0xffff
7009fc2e: 66c8         	str	r0, [r1, #0x6c]
;         chHandleInt->rxChNum           = UDMA_DMA_CH_INVALID;
7009fc30: 9902         	ldr	r1, [sp, #0x8]
7009fc32: 6708         	str	r0, [r1, #0x70]
;         chHandleInt->extChNum          = UDMA_DMA_CH_INVALID;
7009fc34: 9902         	ldr	r1, [sp, #0x8]
7009fc36: 6748         	str	r0, [r1, #0x74]
;         chHandleInt->pdmaChNum         = UDMA_DMA_CH_INVALID;
7009fc38: 9902         	ldr	r1, [sp, #0x8]
7009fc3a: 6788         	str	r0, [r1, #0x78]
;         chHandleInt->peerThreadId      = UDMA_THREAD_ID_INVALID;
7009fc3c: 9902         	ldr	r1, [sp, #0x8]
7009fc3e: 2004         	movs	r0, #0x4
7009fc40: f6cf 70ff    	movt	r0, #0xffff
7009fc44: 67c8         	str	r0, [r1, #0x7c]
;         chHandleInt->fqRing            = (Udma_RingHandleInt) NULL_PTR;
7009fc46: 9902         	ldr	r1, [sp, #0x8]
7009fc48: 2000         	movs	r0, #0x0
7009fc4a: 9000         	str	r0, [sp]
7009fc4c: f8c1 0080    	str.w	r0, [r1, #0x80]
;         chHandleInt->cqRing            = (Udma_RingHandleInt) NULL_PTR;
7009fc50: 9902         	ldr	r1, [sp, #0x8]
7009fc52: f8c1 0084    	str.w	r0, [r1, #0x84]
;         chHandleInt->tdCqRing          = (Udma_RingHandleInt) NULL_PTR;
7009fc56: 9902         	ldr	r1, [sp, #0x8]
7009fc58: f8c1 0088    	str.w	r0, [r1, #0x88]
;         UdmaChTxPrms_init(&chHandleInt->txPrms, chType);
7009fc5c: 9802         	ldr	r0, [sp, #0x8]
7009fc5e: f500 70f2    	add.w	r0, r0, #0x1e4
7009fc62: 9907         	ldr	r1, [sp, #0x1c]
7009fc64: f006 f9b4    	bl	0x700a5fd0 <UdmaChTxPrms_init> @ imm = #0x6368
;         UdmaChRxPrms_init(&chHandleInt->rxPrms, chType);
7009fc68: 9802         	ldr	r0, [sp, #0x8]
7009fc6a: f500 70fc    	add.w	r0, r0, #0x1f8
7009fc6e: 9907         	ldr	r1, [sp, #0x1c]
7009fc70: f006 f956    	bl	0x700a5f20 <UdmaChRxPrms_init> @ imm = #0x62ac
;         Udma_chInitRegs(chHandleInt);
7009fc74: 9802         	ldr	r0, [sp, #0x8]
7009fc76: f00b f923    	bl	0x700aaec0 <Udma_chInitRegs> @ imm = #0xb246
7009fc7a: 9800         	ldr	r0, [sp]
;         chHandleInt->chOesAllocDone    = FALSE;
7009fc7c: 9902         	ldr	r1, [sp, #0x8]
7009fc7e: f8c1 0248    	str.w	r0, [r1, #0x248]
;         chHandleInt->trigger           = CSL_UDMAP_TR_FLAGS_TRIGGER_NONE;
7009fc82: 9902         	ldr	r1, [sp, #0x8]
7009fc84: f8c1 024c    	str.w	r0, [r1, #0x24c]
;     }
7009fc88: e7ff         	b	0x7009fc8a <Udma_chOpen+0xfa> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fc8a: 9805         	ldr	r0, [sp, #0x14]
7009fc8c: b960         	cbnz	r0, 0x7009fca8 <Udma_chOpen+0x118> @ imm = #0x18
7009fc8e: e7ff         	b	0x7009fc90 <Udma_chOpen+0x100> @ imm = #-0x2
;         retVal = Udma_chAllocResource(chHandleInt);
7009fc90: 9802         	ldr	r0, [sp, #0x8]
7009fc92: f7fb f8bd    	bl	0x7009ae10 <Udma_chAllocResource> @ imm = #-0x4e86
7009fc96: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK == retVal)
7009fc98: 9805         	ldr	r0, [sp, #0x14]
7009fc9a: b918         	cbnz	r0, 0x7009fca4 <Udma_chOpen+0x114> @ imm = #0x6
7009fc9c: e7ff         	b	0x7009fc9e <Udma_chOpen+0x10e> @ imm = #-0x2
7009fc9e: 2001         	movs	r0, #0x1
;             allocDone = (uint32_t) TRUE;
7009fca0: 9003         	str	r0, [sp, #0xc]
;         }
7009fca2: e000         	b	0x7009fca6 <Udma_chOpen+0x116> @ imm = #0x0
7009fca4: e7ff         	b	0x7009fca6 <Udma_chOpen+0x116> @ imm = #-0x2
;     }
7009fca6: e7ff         	b	0x7009fca8 <Udma_chOpen+0x118> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fca8: 9805         	ldr	r0, [sp, #0x14]
7009fcaa: b948         	cbnz	r0, 0x7009fcc0 <Udma_chOpen+0x130> @ imm = #0x12
7009fcac: e7ff         	b	0x7009fcae <Udma_chOpen+0x11e> @ imm = #-0x2
;         retVal = Udma_chPair(chHandleInt);
7009fcae: 9802         	ldr	r0, [sp, #0x8]
7009fcb0: f008 fd66    	bl	0x700a8780 <Udma_chPair> @ imm = #0x8acc
7009fcb4: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != retVal)
7009fcb6: 9805         	ldr	r0, [sp, #0x14]
7009fcb8: b108         	cbz	r0, 0x7009fcbe <Udma_chOpen+0x12e> @ imm = #0x2
7009fcba: e7ff         	b	0x7009fcbc <Udma_chOpen+0x12c> @ imm = #-0x2
;         }
7009fcbc: e7ff         	b	0x7009fcbe <Udma_chOpen+0x12e> @ imm = #-0x2
;     }
7009fcbe: e7ff         	b	0x7009fcc0 <Udma_chOpen+0x130> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fcc0: 9805         	ldr	r0, [sp, #0x14]
7009fcc2: b940         	cbnz	r0, 0x7009fcd6 <Udma_chOpen+0x146> @ imm = #0x10
7009fcc4: e7ff         	b	0x7009fcc6 <Udma_chOpen+0x136> @ imm = #-0x2
;         chHandleInt->chInitDone = UDMA_INIT_DONE;
7009fcc6: 9902         	ldr	r1, [sp, #0x8]
7009fcc8: f64a 30cd    	movw	r0, #0xabcd
7009fccc: f6ca 30dc    	movt	r0, #0xabdc
7009fcd0: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
7009fcd4: e00d         	b	0x7009fcf2 <Udma_chOpen+0x162> @ imm = #0x1a
;         if(((uint32_t) TRUE) == allocDone)
7009fcd6: 9803         	ldr	r0, [sp, #0xc]
7009fcd8: 2801         	cmp	r0, #0x1
7009fcda: d109         	bne	0x7009fcf0 <Udma_chOpen+0x160> @ imm = #0x12
7009fcdc: e7ff         	b	0x7009fcde <Udma_chOpen+0x14e> @ imm = #-0x2
;             tempRetVal = Udma_chFreeResource(chHandleInt);
7009fcde: 9802         	ldr	r0, [sp, #0x8]
7009fce0: f7fd fcf6    	bl	0x7009d6d0 <Udma_chFreeResource> @ imm = #-0x2614
7009fce4: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK != tempRetVal)
7009fce6: 9804         	ldr	r0, [sp, #0x10]
7009fce8: b108         	cbz	r0, 0x7009fcee <Udma_chOpen+0x15e> @ imm = #0x2
7009fcea: e7ff         	b	0x7009fcec <Udma_chOpen+0x15c> @ imm = #-0x2
;             }
7009fcec: e7ff         	b	0x7009fcee <Udma_chOpen+0x15e> @ imm = #-0x2
;         }
7009fcee: e7ff         	b	0x7009fcf0 <Udma_chOpen+0x160> @ imm = #-0x2
7009fcf0: e7ff         	b	0x7009fcf2 <Udma_chOpen+0x162> @ imm = #-0x2
;     return (retVal);
7009fcf2: 9805         	ldr	r0, [sp, #0x14]
7009fcf4: b00a         	add	sp, #0x28
7009fcf6: bd80         	pop	{r7, pc}
		...

7009fd00 <xTaskIncrementTick>:
; BaseType_t xTaskIncrementTick(void) {
7009fd00: b580         	push	{r7, lr}
7009fd02: b086         	sub	sp, #0x18
7009fd04: 2000         	movs	r0, #0x0
;   BaseType_t xSwitchRequired = pdFALSE;
7009fd06: 9003         	str	r0, [sp, #0xc]
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
7009fd08: f240 5000    	movw	r0, #0x500
7009fd0c: f2c7 000b    	movt	r0, #0x700b
7009fd10: 6800         	ldr	r0, [r0]
7009fd12: 2800         	cmp	r0, #0x0
7009fd14: f040 809d    	bne.w	0x7009fe52 <xTaskIncrementTick+0x152> @ imm = #0x13a
7009fd18: e7ff         	b	0x7009fd1a <xTaskIncrementTick+0x1a> @ imm = #-0x2
;     const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
7009fd1a: f240 5120    	movw	r1, #0x520
7009fd1e: f2c7 010b    	movt	r1, #0x700b
7009fd22: 6808         	ldr	r0, [r1]
7009fd24: 3001         	adds	r0, #0x1
7009fd26: 9002         	str	r0, [sp, #0x8]
;     xTickCount = xConstTickCount;
7009fd28: 9802         	ldr	r0, [sp, #0x8]
7009fd2a: 6008         	str	r0, [r1]
;     if (xConstTickCount ==
7009fd2c: 9802         	ldr	r0, [sp, #0x8]
7009fd2e: b9c0         	cbnz	r0, 0x7009fd62 <xTaskIncrementTick+0x62> @ imm = #0x30
7009fd30: e7ff         	b	0x7009fd32 <xTaskIncrementTick+0x32> @ imm = #-0x2
;       taskSWITCH_DELAYED_LISTS();
7009fd32: f644 72b8    	movw	r2, #0x4fb8
7009fd36: f2c7 0208    	movt	r2, #0x7008
7009fd3a: 6810         	ldr	r0, [r2]
7009fd3c: 9001         	str	r0, [sp, #0x4]
7009fd3e: f644 71bc    	movw	r1, #0x4fbc
7009fd42: f2c7 0108    	movt	r1, #0x7008
7009fd46: 6808         	ldr	r0, [r1]
7009fd48: 6010         	str	r0, [r2]
7009fd4a: 9801         	ldr	r0, [sp, #0x4]
7009fd4c: 6008         	str	r0, [r1]
7009fd4e: f240 5114    	movw	r1, #0x514
7009fd52: f2c7 010b    	movt	r1, #0x700b
7009fd56: 6808         	ldr	r0, [r1]
7009fd58: 3001         	adds	r0, #0x1
7009fd5a: 6008         	str	r0, [r1]
7009fd5c: f00c f940    	bl	0x700abfe0 <prvResetNextTaskUnblockTime> @ imm = #0xc280
;     } else {
7009fd60: e000         	b	0x7009fd64 <xTaskIncrementTick+0x64> @ imm = #0x0
7009fd62: e7ff         	b	0x7009fd64 <xTaskIncrementTick+0x64> @ imm = #-0x2
;     if (xConstTickCount >= xNextTaskUnblockTime) {
7009fd64: 9802         	ldr	r0, [sp, #0x8]
7009fd66: f240 5110    	movw	r1, #0x510
7009fd6a: f2c7 010b    	movt	r1, #0x700b
7009fd6e: 6809         	ldr	r1, [r1]
7009fd70: 4288         	cmp	r0, r1
7009fd72: d362         	blo	0x7009fe3a <xTaskIncrementTick+0x13a> @ imm = #0xc4
7009fd74: e7ff         	b	0x7009fd76 <xTaskIncrementTick+0x76> @ imm = #-0x2
;       for (;;) {
7009fd76: e7ff         	b	0x7009fd78 <xTaskIncrementTick+0x78> @ imm = #-0x2
;         if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
7009fd78: f644 70b8    	movw	r0, #0x4fb8
7009fd7c: f2c7 0008    	movt	r0, #0x7008
7009fd80: 6800         	ldr	r0, [r0]
7009fd82: 6800         	ldr	r0, [r0]
7009fd84: b940         	cbnz	r0, 0x7009fd98 <xTaskIncrementTick+0x98> @ imm = #0x10
7009fd86: e7ff         	b	0x7009fd88 <xTaskIncrementTick+0x88> @ imm = #-0x2
;           xNextTaskUnblockTime =
7009fd88: f240 5110    	movw	r1, #0x510
7009fd8c: f2c7 010b    	movt	r1, #0x700b
7009fd90: f04f 30ff    	mov.w	r0, #0xffffffff
7009fd94: 6008         	str	r0, [r1]
;           break;
7009fd96: e04f         	b	0x7009fe38 <xTaskIncrementTick+0x138> @ imm = #0x9e
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
7009fd98: f644 70b8    	movw	r0, #0x4fb8
7009fd9c: f2c7 0008    	movt	r0, #0x7008
7009fda0: 6800         	ldr	r0, [r0]
7009fda2: 68c0         	ldr	r0, [r0, #0xc]
7009fda4: 68c0         	ldr	r0, [r0, #0xc]
7009fda6: 9005         	str	r0, [sp, #0x14]
;           xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
7009fda8: 9805         	ldr	r0, [sp, #0x14]
7009fdaa: 6840         	ldr	r0, [r0, #0x4]
7009fdac: 9004         	str	r0, [sp, #0x10]
;           if (xConstTickCount < xItemValue) {
7009fdae: 9802         	ldr	r0, [sp, #0x8]
7009fdb0: 9904         	ldr	r1, [sp, #0x10]
7009fdb2: 4288         	cmp	r0, r1
7009fdb4: d207         	bhs	0x7009fdc6 <xTaskIncrementTick+0xc6> @ imm = #0xe
7009fdb6: e7ff         	b	0x7009fdb8 <xTaskIncrementTick+0xb8> @ imm = #-0x2
;             xNextTaskUnblockTime = xItemValue;
7009fdb8: 9804         	ldr	r0, [sp, #0x10]
7009fdba: f240 5110    	movw	r1, #0x510
7009fdbe: f2c7 010b    	movt	r1, #0x700b
7009fdc2: 6008         	str	r0, [r1]
;             break; /*lint !e9011 Code structure here is deedmed easier to
7009fdc4: e038         	b	0x7009fe38 <xTaskIncrementTick+0x138> @ imm = #0x70
7009fdc6: e7ff         	b	0x7009fdc8 <xTaskIncrementTick+0xc8> @ imm = #-0x2
;           (void)uxListRemove(&(pxTCB->xStateListItem));
7009fdc8: 9805         	ldr	r0, [sp, #0x14]
7009fdca: 3004         	adds	r0, #0x4
7009fdcc: f00b fbb0    	bl	0x700ab530 <uxListRemove> @ imm = #0xb760
;           if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
7009fdd0: 9805         	ldr	r0, [sp, #0x14]
7009fdd2: 6a80         	ldr	r0, [r0, #0x28]
7009fdd4: b128         	cbz	r0, 0x7009fde2 <xTaskIncrementTick+0xe2> @ imm = #0xa
7009fdd6: e7ff         	b	0x7009fdd8 <xTaskIncrementTick+0xd8> @ imm = #-0x2
;             (void)uxListRemove(&(pxTCB->xEventListItem));
7009fdd8: 9805         	ldr	r0, [sp, #0x14]
7009fdda: 3018         	adds	r0, #0x18
7009fddc: f00b fba8    	bl	0x700ab530 <uxListRemove> @ imm = #0xb750
;           } else {
7009fde0: e000         	b	0x7009fde4 <xTaskIncrementTick+0xe4> @ imm = #0x0
7009fde2: e7ff         	b	0x7009fde4 <xTaskIncrementTick+0xe4> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
7009fde4: 9805         	ldr	r0, [sp, #0x14]
7009fde6: 6ac1         	ldr	r1, [r0, #0x2c]
7009fde8: 2001         	movs	r0, #0x1
7009fdea: fa00 f201    	lsl.w	r2, r0, r1
7009fdee: f240 5108    	movw	r1, #0x508
7009fdf2: f2c7 010b    	movt	r1, #0x700b
7009fdf6: 6808         	ldr	r0, [r1]
7009fdf8: 4310         	orrs	r0, r2
7009fdfa: 6008         	str	r0, [r1]
7009fdfc: 9905         	ldr	r1, [sp, #0x14]
7009fdfe: 6ac8         	ldr	r0, [r1, #0x2c]
7009fe00: eb00 0280    	add.w	r2, r0, r0, lsl #2
7009fe04: f244 40f8    	movw	r0, #0x44f8
7009fe08: f2c7 0008    	movt	r0, #0x7008
7009fe0c: eb00 0082    	add.w	r0, r0, r2, lsl #2
7009fe10: 3104         	adds	r1, #0x4
7009fe12: f00c f945    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #0xc28a
;             if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
7009fe16: 9805         	ldr	r0, [sp, #0x14]
7009fe18: 6ac0         	ldr	r0, [r0, #0x2c]
7009fe1a: f240 41dc    	movw	r1, #0x4dc
7009fe1e: f2c7 010b    	movt	r1, #0x700b
7009fe22: 6809         	ldr	r1, [r1]
7009fe24: 6ac9         	ldr	r1, [r1, #0x2c]
7009fe26: 4288         	cmp	r0, r1
7009fe28: d303         	blo	0x7009fe32 <xTaskIncrementTick+0x132> @ imm = #0x6
7009fe2a: e7ff         	b	0x7009fe2c <xTaskIncrementTick+0x12c> @ imm = #-0x2
7009fe2c: 2001         	movs	r0, #0x1
;               xSwitchRequired = pdTRUE;
7009fe2e: 9003         	str	r0, [sp, #0xc]
;             } else {
7009fe30: e000         	b	0x7009fe34 <xTaskIncrementTick+0x134> @ imm = #0x0
7009fe32: e7ff         	b	0x7009fe34 <xTaskIncrementTick+0x134> @ imm = #-0x2
7009fe34: e7ff         	b	0x7009fe36 <xTaskIncrementTick+0x136> @ imm = #-0x2
;       for (;;) {
7009fe36: e79f         	b	0x7009fd78 <xTaskIncrementTick+0x78> @ imm = #-0xc2
;     }
7009fe38: e7ff         	b	0x7009fe3a <xTaskIncrementTick+0x13a> @ imm = #-0x2
;       if (xYieldPending != pdFALSE) {
7009fe3a: f240 502c    	movw	r0, #0x52c
7009fe3e: f2c7 000b    	movt	r0, #0x700b
7009fe42: 6800         	ldr	r0, [r0]
7009fe44: b118         	cbz	r0, 0x7009fe4e <xTaskIncrementTick+0x14e> @ imm = #0x6
7009fe46: e7ff         	b	0x7009fe48 <xTaskIncrementTick+0x148> @ imm = #-0x2
7009fe48: 2001         	movs	r0, #0x1
;         xSwitchRequired = pdTRUE;
7009fe4a: 9003         	str	r0, [sp, #0xc]
;       } else {
7009fe4c: e000         	b	0x7009fe50 <xTaskIncrementTick+0x150> @ imm = #0x0
7009fe4e: e7ff         	b	0x7009fe50 <xTaskIncrementTick+0x150> @ imm = #-0x2
;   } else {
7009fe50: e007         	b	0x7009fe62 <xTaskIncrementTick+0x162> @ imm = #0xe
;     ++xPendedTicks;
7009fe52: f240 5118    	movw	r1, #0x518
7009fe56: f2c7 010b    	movt	r1, #0x700b
7009fe5a: 6808         	ldr	r0, [r1]
7009fe5c: 3001         	adds	r0, #0x1
7009fe5e: 6008         	str	r0, [r1]
7009fe60: e7ff         	b	0x7009fe62 <xTaskIncrementTick+0x162> @ imm = #-0x2
;   return xSwitchRequired;
7009fe62: 9803         	ldr	r0, [sp, #0xc]
7009fe64: b006         	add	sp, #0x18
7009fe66: bd80         	pop	{r7, pc}
		...

7009fe70 <Udma_rmAllocMappedRxCh>:
; {
7009fe70: b580         	push	{r7, lr}
7009fe72: b08a         	sub	sp, #0x28
7009fe74: 9009         	str	r0, [sp, #0x24]
7009fe76: 9108         	str	r1, [sp, #0x20]
7009fe78: 9207         	str	r2, [sp, #0x1c]
7009fe7a: 2000         	movs	r0, #0x0
7009fe7c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
7009fe80: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
7009fe82: 9808         	ldr	r0, [sp, #0x20]
7009fe84: f500 70ea    	add.w	r0, r0, #0x1d4
7009fe88: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
7009fe8a: 9808         	ldr	r0, [sp, #0x20]
7009fe8c: f500 609f    	add.w	r0, r0, #0x4f8
7009fe90: f04f 31ff    	mov.w	r1, #0xffffffff
7009fe94: f008 fc2c    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x8858
;     if(UDMA_DMA_CH_ANY == preferredChNum)
7009fe98: 9809         	ldr	r0, [sp, #0x24]
7009fe9a: 2101         	movs	r1, #0x1
7009fe9c: f6cf 71ff    	movt	r1, #0xffff
7009fea0: 4288         	cmp	r0, r1
7009fea2: d142         	bne	0x7009ff2a <Udma_rmAllocMappedRxCh+0xba> @ imm = #0x84
7009fea4: e7ff         	b	0x7009fea6 <Udma_rmAllocMappedRxCh+0x36> @ imm = #-0x2
7009fea6: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
7009fea8: 9005         	str	r0, [sp, #0x14]
7009feaa: e7ff         	b	0x7009feac <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x2
7009feac: 9805         	ldr	r0, [sp, #0x14]
7009feae: 9901         	ldr	r1, [sp, #0x4]
7009feb0: 9a07         	ldr	r2, [sp, #0x1c]
7009feb2: eb01 0182    	add.w	r1, r1, r2, lsl #2
7009feb6: 6f89         	ldr	r1, [r1, #0x78]
7009feb8: 4288         	cmp	r0, r1
7009feba: d235         	bhs	0x7009ff28 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x6a
7009febc: e7ff         	b	0x7009febe <Udma_rmAllocMappedRxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
7009febe: 9805         	ldr	r0, [sp, #0x14]
7009fec0: 0940         	lsrs	r0, r0, #0x5
7009fec2: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
7009fec4: 9805         	ldr	r0, [sp, #0x14]
7009fec6: 9904         	ldr	r1, [sp, #0x10]
7009fec8: eba0 1041    	sub.w	r0, r0, r1, lsl #5
7009fecc: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
7009fece: 9903         	ldr	r1, [sp, #0xc]
7009fed0: 2001         	movs	r0, #0x1
7009fed2: 4088         	lsls	r0, r1
7009fed4: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
7009fed6: 9808         	ldr	r0, [sp, #0x20]
7009fed8: 9907         	ldr	r1, [sp, #0x1c]
7009feda: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009fede: 9904         	ldr	r1, [sp, #0x10]
7009fee0: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009fee4: f8d0 0334    	ldr.w	r0, [r0, #0x334]
7009fee8: 9902         	ldr	r1, [sp, #0x8]
7009feea: 4008         	ands	r0, r1
7009feec: 4288         	cmp	r0, r1
7009feee: d116         	bne	0x7009ff1e <Udma_rmAllocMappedRxCh+0xae> @ imm = #0x2c
7009fef0: e7ff         	b	0x7009fef2 <Udma_rmAllocMappedRxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
7009fef2: 9a02         	ldr	r2, [sp, #0x8]
7009fef4: 9808         	ldr	r0, [sp, #0x20]
7009fef6: 9907         	ldr	r1, [sp, #0x1c]
7009fef8: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009fefc: 9904         	ldr	r1, [sp, #0x10]
7009fefe: eb00 0181    	add.w	r1, r0, r1, lsl #2
7009ff02: f8d1 0334    	ldr.w	r0, [r1, #0x334]
7009ff06: 4390         	bics	r0, r2
7009ff08: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = i + rmInitPrms->startMappedRxCh[mappedChGrp];  /* Add start offset */
7009ff0c: 9805         	ldr	r0, [sp, #0x14]
7009ff0e: 9901         	ldr	r1, [sp, #0x4]
7009ff10: 9a07         	ldr	r2, [sp, #0x1c]
7009ff12: eb01 0182    	add.w	r1, r1, r2, lsl #2
7009ff16: 6e89         	ldr	r1, [r1, #0x68]
7009ff18: 4408         	add	r0, r1
7009ff1a: 9006         	str	r0, [sp, #0x18]
;                 break;
7009ff1c: e004         	b	0x7009ff28 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x8
;         }
7009ff1e: e7ff         	b	0x7009ff20 <Udma_rmAllocMappedRxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
7009ff20: 9805         	ldr	r0, [sp, #0x14]
7009ff22: 3001         	adds	r0, #0x1
7009ff24: 9005         	str	r0, [sp, #0x14]
7009ff26: e7c1         	b	0x7009feac <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x7e
;     }
7009ff28: e047         	b	0x7009ffba <Udma_rmAllocMappedRxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
7009ff2a: 9809         	ldr	r0, [sp, #0x24]
7009ff2c: 9901         	ldr	r1, [sp, #0x4]
7009ff2e: 9a07         	ldr	r2, [sp, #0x1c]
7009ff30: eb01 0182    	add.w	r1, r1, r2, lsl #2
7009ff34: 6e89         	ldr	r1, [r1, #0x68]
7009ff36: 4288         	cmp	r0, r1
7009ff38: d33e         	blo	0x7009ffb8 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x7c
7009ff3a: e7ff         	b	0x7009ff3c <Udma_rmAllocMappedRxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedRxCh[mappedChGrp] + rmInitPrms->numMappedRxCh[mappedChGrp])))
7009ff3c: 9809         	ldr	r0, [sp, #0x24]
7009ff3e: 9901         	ldr	r1, [sp, #0x4]
7009ff40: 9a07         	ldr	r2, [sp, #0x1c]
7009ff42: eb01 0282    	add.w	r2, r1, r2, lsl #2
7009ff46: 6e91         	ldr	r1, [r2, #0x68]
7009ff48: 6f92         	ldr	r2, [r2, #0x78]
7009ff4a: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
7009ff4c: 4288         	cmp	r0, r1
7009ff4e: d233         	bhs	0x7009ffb8 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x66
7009ff50: e7ff         	b	0x7009ff52 <Udma_rmAllocMappedRxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedRxCh[mappedChGrp];
7009ff52: 9809         	ldr	r0, [sp, #0x24]
7009ff54: 9901         	ldr	r1, [sp, #0x4]
7009ff56: 9a07         	ldr	r2, [sp, #0x1c]
7009ff58: eb01 0182    	add.w	r1, r1, r2, lsl #2
7009ff5c: 6e89         	ldr	r1, [r1, #0x68]
7009ff5e: 1a40         	subs	r0, r0, r1
7009ff60: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
7009ff62: 9805         	ldr	r0, [sp, #0x14]
7009ff64: 0940         	lsrs	r0, r0, #0x5
7009ff66: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
7009ff68: 9805         	ldr	r0, [sp, #0x14]
7009ff6a: 9904         	ldr	r1, [sp, #0x10]
7009ff6c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
7009ff70: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
7009ff72: 9903         	ldr	r1, [sp, #0xc]
7009ff74: 2001         	movs	r0, #0x1
7009ff76: 4088         	lsls	r0, r1
7009ff78: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
7009ff7a: 9808         	ldr	r0, [sp, #0x20]
7009ff7c: 9907         	ldr	r1, [sp, #0x1c]
7009ff7e: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009ff82: 9904         	ldr	r1, [sp, #0x10]
7009ff84: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009ff88: f8d0 0334    	ldr.w	r0, [r0, #0x334]
7009ff8c: 9902         	ldr	r1, [sp, #0x8]
7009ff8e: 4008         	ands	r0, r1
7009ff90: 4288         	cmp	r0, r1
7009ff92: d110         	bne	0x7009ffb6 <Udma_rmAllocMappedRxCh+0x146> @ imm = #0x20
7009ff94: e7ff         	b	0x7009ff96 <Udma_rmAllocMappedRxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
7009ff96: 9a02         	ldr	r2, [sp, #0x8]
7009ff98: 9808         	ldr	r0, [sp, #0x20]
7009ff9a: 9907         	ldr	r1, [sp, #0x1c]
7009ff9c: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009ffa0: 9904         	ldr	r1, [sp, #0x10]
7009ffa2: eb00 0181    	add.w	r1, r0, r1, lsl #2
7009ffa6: f8d1 0334    	ldr.w	r0, [r1, #0x334]
7009ffaa: 4390         	bics	r0, r2
7009ffac: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = preferredChNum;
7009ffb0: 9809         	ldr	r0, [sp, #0x24]
7009ffb2: 9006         	str	r0, [sp, #0x18]
;             }
7009ffb4: e7ff         	b	0x7009ffb6 <Udma_rmAllocMappedRxCh+0x146> @ imm = #-0x2
;         }
7009ffb6: e7ff         	b	0x7009ffb8 <Udma_rmAllocMappedRxCh+0x148> @ imm = #-0x2
7009ffb8: e7ff         	b	0x7009ffba <Udma_rmAllocMappedRxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
7009ffba: 9808         	ldr	r0, [sp, #0x20]
7009ffbc: f500 609f    	add.w	r0, r0, #0x4f8
7009ffc0: f009 feee    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x9ddc
;     return (chNum);
7009ffc4: 9806         	ldr	r0, [sp, #0x18]
7009ffc6: b00a         	add	sp, #0x28
7009ffc8: bd80         	pop	{r7, pc}
7009ffca: 0000         	movs	r0, r0
7009ffcc: 0000         	movs	r0, r0
7009ffce: 0000         	movs	r0, r0

7009ffd0 <Udma_rmAllocMappedTxCh>:
; {
7009ffd0: b580         	push	{r7, lr}
7009ffd2: b08a         	sub	sp, #0x28
7009ffd4: 9009         	str	r0, [sp, #0x24]
7009ffd6: 9108         	str	r1, [sp, #0x20]
7009ffd8: 9207         	str	r2, [sp, #0x1c]
7009ffda: 2000         	movs	r0, #0x0
7009ffdc: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
7009ffe0: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
7009ffe2: 9808         	ldr	r0, [sp, #0x20]
7009ffe4: f500 70ea    	add.w	r0, r0, #0x1d4
7009ffe8: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
7009ffea: 9808         	ldr	r0, [sp, #0x20]
7009ffec: f500 609f    	add.w	r0, r0, #0x4f8
7009fff0: f04f 31ff    	mov.w	r1, #0xffffffff
7009fff4: f008 fb7c    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x86f8
;     if(UDMA_DMA_CH_ANY == preferredChNum)
7009fff8: 9809         	ldr	r0, [sp, #0x24]
7009fffa: 2101         	movs	r1, #0x1
7009fffc: f6cf 71ff    	movt	r1, #0xffff
700a0000: 4288         	cmp	r0, r1
700a0002: d142         	bne	0x700a008a <Udma_rmAllocMappedTxCh+0xba> @ imm = #0x84
700a0004: e7ff         	b	0x700a0006 <Udma_rmAllocMappedTxCh+0x36> @ imm = #-0x2
700a0006: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a0008: 9005         	str	r0, [sp, #0x14]
700a000a: e7ff         	b	0x700a000c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x2
700a000c: 9805         	ldr	r0, [sp, #0x14]
700a000e: 9901         	ldr	r1, [sp, #0x4]
700a0010: 9a07         	ldr	r2, [sp, #0x1c]
700a0012: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0016: 6d89         	ldr	r1, [r1, #0x58]
700a0018: 4288         	cmp	r0, r1
700a001a: d235         	bhs	0x700a0088 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x6a
700a001c: e7ff         	b	0x700a001e <Udma_rmAllocMappedTxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
700a001e: 9805         	ldr	r0, [sp, #0x14]
700a0020: 0940         	lsrs	r0, r0, #0x5
700a0022: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a0024: 9805         	ldr	r0, [sp, #0x14]
700a0026: 9904         	ldr	r1, [sp, #0x10]
700a0028: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a002c: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a002e: 9903         	ldr	r1, [sp, #0xc]
700a0030: 2001         	movs	r0, #0x1
700a0032: 4088         	lsls	r0, r1
700a0034: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a0036: 9808         	ldr	r0, [sp, #0x20]
700a0038: 9907         	ldr	r1, [sp, #0x1c]
700a003a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a003e: 9904         	ldr	r1, [sp, #0x10]
700a0040: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0044: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a0048: 9902         	ldr	r1, [sp, #0x8]
700a004a: 4008         	ands	r0, r1
700a004c: 4288         	cmp	r0, r1
700a004e: d116         	bne	0x700a007e <Udma_rmAllocMappedTxCh+0xae> @ imm = #0x2c
700a0050: e7ff         	b	0x700a0052 <Udma_rmAllocMappedTxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a0052: 9a02         	ldr	r2, [sp, #0x8]
700a0054: 9808         	ldr	r0, [sp, #0x20]
700a0056: 9907         	ldr	r1, [sp, #0x1c]
700a0058: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a005c: 9904         	ldr	r1, [sp, #0x10]
700a005e: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a0062: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a0066: 4390         	bics	r0, r2
700a0068: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = i + rmInitPrms->startMappedTxCh[mappedChGrp];  /* Add start offset */
700a006c: 9805         	ldr	r0, [sp, #0x14]
700a006e: 9901         	ldr	r1, [sp, #0x4]
700a0070: 9a07         	ldr	r2, [sp, #0x1c]
700a0072: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0076: 6c89         	ldr	r1, [r1, #0x48]
700a0078: 4408         	add	r0, r1
700a007a: 9006         	str	r0, [sp, #0x18]
;                 break;
700a007c: e004         	b	0x700a0088 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x8
;         }
700a007e: e7ff         	b	0x700a0080 <Udma_rmAllocMappedTxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a0080: 9805         	ldr	r0, [sp, #0x14]
700a0082: 3001         	adds	r0, #0x1
700a0084: 9005         	str	r0, [sp, #0x14]
700a0086: e7c1         	b	0x700a000c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x7e
;     }
700a0088: e047         	b	0x700a011a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a008a: 9809         	ldr	r0, [sp, #0x24]
700a008c: 9901         	ldr	r1, [sp, #0x4]
700a008e: 9a07         	ldr	r2, [sp, #0x1c]
700a0090: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0094: 6c89         	ldr	r1, [r1, #0x48]
700a0096: 4288         	cmp	r0, r1
700a0098: d33e         	blo	0x700a0118 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x7c
700a009a: e7ff         	b	0x700a009c <Udma_rmAllocMappedTxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedTxCh[mappedChGrp] + rmInitPrms->numMappedTxCh[mappedChGrp])))
700a009c: 9809         	ldr	r0, [sp, #0x24]
700a009e: 9901         	ldr	r1, [sp, #0x4]
700a00a0: 9a07         	ldr	r2, [sp, #0x1c]
700a00a2: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a00a6: 6c91         	ldr	r1, [r2, #0x48]
700a00a8: 6d92         	ldr	r2, [r2, #0x58]
700a00aa: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a00ac: 4288         	cmp	r0, r1
700a00ae: d233         	bhs	0x700a0118 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x66
700a00b0: e7ff         	b	0x700a00b2 <Udma_rmAllocMappedTxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700a00b2: 9809         	ldr	r0, [sp, #0x24]
700a00b4: 9901         	ldr	r1, [sp, #0x4]
700a00b6: 9a07         	ldr	r2, [sp, #0x1c]
700a00b8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a00bc: 6c89         	ldr	r1, [r1, #0x48]
700a00be: 1a40         	subs	r0, r0, r1
700a00c0: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a00c2: 9805         	ldr	r0, [sp, #0x14]
700a00c4: 0940         	lsrs	r0, r0, #0x5
700a00c6: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a00c8: 9805         	ldr	r0, [sp, #0x14]
700a00ca: 9904         	ldr	r1, [sp, #0x10]
700a00cc: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a00d0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a00d2: 9903         	ldr	r1, [sp, #0xc]
700a00d4: 2001         	movs	r0, #0x1
700a00d6: 4088         	lsls	r0, r1
700a00d8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a00da: 9808         	ldr	r0, [sp, #0x20]
700a00dc: 9907         	ldr	r1, [sp, #0x1c]
700a00de: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a00e2: 9904         	ldr	r1, [sp, #0x10]
700a00e4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a00e8: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a00ec: 9902         	ldr	r1, [sp, #0x8]
700a00ee: 4008         	ands	r0, r1
700a00f0: 4288         	cmp	r0, r1
700a00f2: d110         	bne	0x700a0116 <Udma_rmAllocMappedTxCh+0x146> @ imm = #0x20
700a00f4: e7ff         	b	0x700a00f6 <Udma_rmAllocMappedTxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a00f6: 9a02         	ldr	r2, [sp, #0x8]
700a00f8: 9808         	ldr	r0, [sp, #0x20]
700a00fa: 9907         	ldr	r1, [sp, #0x1c]
700a00fc: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0100: 9904         	ldr	r1, [sp, #0x10]
700a0102: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a0106: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a010a: 4390         	bics	r0, r2
700a010c: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = preferredChNum;
700a0110: 9809         	ldr	r0, [sp, #0x24]
700a0112: 9006         	str	r0, [sp, #0x18]
;             }
700a0114: e7ff         	b	0x700a0116 <Udma_rmAllocMappedTxCh+0x146> @ imm = #-0x2
;         }
700a0116: e7ff         	b	0x700a0118 <Udma_rmAllocMappedTxCh+0x148> @ imm = #-0x2
700a0118: e7ff         	b	0x700a011a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a011a: 9808         	ldr	r0, [sp, #0x20]
700a011c: f500 609f    	add.w	r0, r0, #0x4f8
700a0120: f009 fe3e    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x9c7c
;     return (chNum);
700a0124: 9806         	ldr	r0, [sp, #0x18]
700a0126: b00a         	add	sp, #0x28
700a0128: bd80         	pop	{r7, pc}
700a012a: 0000         	movs	r0, r0
700a012c: 0000         	movs	r0, r0
700a012e: 0000         	movs	r0, r0

700a0130 <CSL_bcdmaChanOpGetChanStats>:
; {
700a0130: b580         	push	{r7, lr}
700a0132: b088         	sub	sp, #0x20
700a0134: 9007         	str	r0, [sp, #0x1c]
700a0136: 9106         	str	r1, [sp, #0x18]
700a0138: 9205         	str	r2, [sp, #0x14]
700a013a: 9304         	str	r3, [sp, #0x10]
700a013c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a013e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a0140: 9804         	ldr	r0, [sp, #0x10]
700a0142: b920         	cbnz	r0, 0x700a014e <CSL_bcdmaChanOpGetChanStats+0x1e> @ imm = #0x8
700a0144: e7ff         	b	0x700a0146 <CSL_bcdmaChanOpGetChanStats+0x16> @ imm = #-0x2
700a0146: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a014a: 9003         	str	r0, [sp, #0xc]
;     }
700a014c: e099         	b	0x700a0282 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #0x132
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a014e: 9804         	ldr	r0, [sp, #0x10]
700a0150: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a0152: 9806         	ldr	r0, [sp, #0x18]
700a0154: 9001         	str	r0, [sp, #0x4]
700a0156: b140         	cbz	r0, 0x700a016a <CSL_bcdmaChanOpGetChanStats+0x3a> @ imm = #0x10
700a0158: e7ff         	b	0x700a015a <CSL_bcdmaChanOpGetChanStats+0x2a> @ imm = #-0x2
700a015a: 9801         	ldr	r0, [sp, #0x4]
700a015c: 2801         	cmp	r0, #0x1
700a015e: d031         	beq	0x700a01c4 <CSL_bcdmaChanOpGetChanStats+0x94> @ imm = #0x62
700a0160: e7ff         	b	0x700a0162 <CSL_bcdmaChanOpGetChanStats+0x32> @ imm = #-0x2
700a0162: 9801         	ldr	r0, [sp, #0x4]
700a0164: 2802         	cmp	r0, #0x2
700a0166: d05a         	beq	0x700a021e <CSL_bcdmaChanOpGetChanStats+0xee> @ imm = #0xb4
700a0168: e086         	b	0x700a0278 <CSL_bcdmaChanOpGetChanStats+0x148> @ imm = #0x10c
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT );
700a016a: 9807         	ldr	r0, [sp, #0x1c]
700a016c: 6880         	ldr	r0, [r0, #0x8]
700a016e: 9905         	ldr	r1, [sp, #0x14]
700a0170: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a0174: f500 6080    	add.w	r0, r0, #0x400
700a0178: f00d fbea    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xd7d4
700a017c: 9902         	ldr	r1, [sp, #0x8]
700a017e: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT );
700a0180: 9807         	ldr	r0, [sp, #0x1c]
700a0182: 6880         	ldr	r0, [r0, #0x8]
700a0184: 9905         	ldr	r1, [sp, #0x14]
700a0186: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a018a: f500 6081    	add.w	r0, r0, #0x408
700a018e: f00d fbdf    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xd7be
700a0192: 9902         	ldr	r1, [sp, #0x8]
700a0194: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT );
700a0196: 9807         	ldr	r0, [sp, #0x1c]
700a0198: 6880         	ldr	r0, [r0, #0x8]
700a019a: 9905         	ldr	r1, [sp, #0x14]
700a019c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a01a0: f500 6082    	add.w	r0, r0, #0x410
700a01a4: f00d fbd4    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xd7a8
700a01a8: 9902         	ldr	r1, [sp, #0x8]
700a01aa: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a01ac: 9902         	ldr	r1, [sp, #0x8]
700a01ae: 2000         	movs	r0, #0x0
700a01b0: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a01b2: 9902         	ldr	r1, [sp, #0x8]
700a01b4: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a01b6: 9902         	ldr	r1, [sp, #0x8]
700a01b8: 6848         	ldr	r0, [r1, #0x4]
700a01ba: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a01bc: 9902         	ldr	r1, [sp, #0x8]
700a01be: 6888         	ldr	r0, [r1, #0x8]
700a01c0: 6188         	str	r0, [r1, #0x18]
;                 break;
700a01c2: e05d         	b	0x700a0280 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0xba
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT );
700a01c4: 9807         	ldr	r0, [sp, #0x1c]
700a01c6: 6900         	ldr	r0, [r0, #0x10]
700a01c8: 9905         	ldr	r1, [sp, #0x14]
700a01ca: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a01ce: f500 6080    	add.w	r0, r0, #0x400
700a01d2: f00d fbbd    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xd77a
700a01d6: 9902         	ldr	r1, [sp, #0x8]
700a01d8: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT );
700a01da: 9807         	ldr	r0, [sp, #0x1c]
700a01dc: 6900         	ldr	r0, [r0, #0x10]
700a01de: 9905         	ldr	r1, [sp, #0x14]
700a01e0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a01e4: f500 6081    	add.w	r0, r0, #0x408
700a01e8: f00d fbb2    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xd764
700a01ec: 9902         	ldr	r1, [sp, #0x8]
700a01ee: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT );
700a01f0: 9807         	ldr	r0, [sp, #0x1c]
700a01f2: 6900         	ldr	r0, [r0, #0x10]
700a01f4: 9905         	ldr	r1, [sp, #0x14]
700a01f6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a01fa: f500 6082    	add.w	r0, r0, #0x410
700a01fe: f00d fba7    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xd74e
700a0202: 9902         	ldr	r1, [sp, #0x8]
700a0204: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a0206: 9902         	ldr	r1, [sp, #0x8]
700a0208: 2000         	movs	r0, #0x0
700a020a: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a020c: 9902         	ldr	r1, [sp, #0x8]
700a020e: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a0210: 9902         	ldr	r1, [sp, #0x8]
700a0212: 6848         	ldr	r0, [r1, #0x4]
700a0214: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a0216: 9902         	ldr	r1, [sp, #0x8]
700a0218: 6888         	ldr	r0, [r1, #0x8]
700a021a: 6188         	str	r0, [r1, #0x18]
;                 break;
700a021c: e030         	b	0x700a0280 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x60
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT );
700a021e: 9807         	ldr	r0, [sp, #0x1c]
700a0220: 6980         	ldr	r0, [r0, #0x18]
700a0222: 9905         	ldr	r1, [sp, #0x14]
700a0224: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a0228: f500 6080    	add.w	r0, r0, #0x400
700a022c: f00d fb90    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xd720
700a0230: 9902         	ldr	r1, [sp, #0x8]
700a0232: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = (uint32_t)0U;
700a0234: 9902         	ldr	r1, [sp, #0x8]
700a0236: 2000         	movs	r0, #0x0
700a0238: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = (uint32_t)0U;
700a023a: 9902         	ldr	r1, [sp, #0x8]
700a023c: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT );
700a023e: 9807         	ldr	r0, [sp, #0x1c]
700a0240: 6980         	ldr	r0, [r0, #0x18]
700a0242: 9905         	ldr	r1, [sp, #0x14]
700a0244: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a0248: f500 6081    	add.w	r0, r0, #0x408
700a024c: f00d fb80    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xd700
700a0250: 9902         	ldr	r1, [sp, #0x8]
700a0252: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT );
700a0254: 9807         	ldr	r0, [sp, #0x1c]
700a0256: 6980         	ldr	r0, [r0, #0x18]
700a0258: 9905         	ldr	r1, [sp, #0x14]
700a025a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a025e: f500 6082    	add.w	r0, r0, #0x410
700a0262: f00d fb75    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xd6ea
700a0266: 9902         	ldr	r1, [sp, #0x8]
700a0268: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->rxPayloadByteCnt;
700a026a: 9902         	ldr	r1, [sp, #0x8]
700a026c: 68c8         	ldr	r0, [r1, #0xc]
700a026e: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->rxStartedByteCnt;
700a0270: 9902         	ldr	r1, [sp, #0x8]
700a0272: 6908         	ldr	r0, [r1, #0x10]
700a0274: 6188         	str	r0, [r1, #0x18]
;                 break;
700a0276: e003         	b	0x700a0280 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x6
700a0278: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a027c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a027e: e7ff         	b	0x700a0280 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #-0x2
700a0280: e7ff         	b	0x700a0282 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #-0x2
;     return retVal;
700a0282: 9803         	ldr	r0, [sp, #0xc]
700a0284: b008         	add	sp, #0x20
700a0286: bd80         	pop	{r7, pc}
		...

700a0290 <UART_lld_initDma>:
; {
700a0290: b580         	push	{r7, lr}
700a0292: b084         	sub	sp, #0x10
700a0294: 9003         	str	r0, [sp, #0xc]
700a0296: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a0298: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a029a: 9803         	ldr	r0, [sp, #0xc]
700a029c: b168         	cbz	r0, 0x700a02ba <UART_lld_initDma+0x2a> @ imm = #0x1a
700a029e: e7ff         	b	0x700a02a0 <UART_lld_initDma+0x10> @ imm = #-0x2
700a02a0: 9803         	ldr	r0, [sp, #0xc]
700a02a2: 6840         	ldr	r0, [r0, #0x4]
700a02a4: b148         	cbz	r0, 0x700a02ba <UART_lld_initDma+0x2a> @ imm = #0x12
700a02a6: e7ff         	b	0x700a02a8 <UART_lld_initDma+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a02a8: 9803         	ldr	r0, [sp, #0xc]
700a02aa: 6d40         	ldr	r0, [r0, #0x54]
700a02ac: b120         	cbz	r0, 0x700a02b8 <UART_lld_initDma+0x28> @ imm = #0x8
700a02ae: e7ff         	b	0x700a02b0 <UART_lld_initDma+0x20> @ imm = #-0x2
700a02b0: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a02b4: 9002         	str	r0, [sp, #0x8]
;         }
700a02b6: e7ff         	b	0x700a02b8 <UART_lld_initDma+0x28> @ imm = #-0x2
;     }
700a02b8: e003         	b	0x700a02c2 <UART_lld_initDma+0x32> @ imm = #0x6
700a02ba: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a02be: 9002         	str	r0, [sp, #0x8]
700a02c0: e7ff         	b	0x700a02c2 <UART_lld_initDma+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a02c2: 9802         	ldr	r0, [sp, #0x8]
700a02c4: 2800         	cmp	r0, #0x0
700a02c6: d170         	bne	0x700a03aa <UART_lld_initDma+0x11a> @ imm = #0xe0
700a02c8: e7ff         	b	0x700a02ca <UART_lld_initDma+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a02ca: 9903         	ldr	r1, [sp, #0xc]
700a02cc: 2002         	movs	r0, #0x2
700a02ce: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a02d0: 9803         	ldr	r0, [sp, #0xc]
700a02d2: 6840         	ldr	r0, [r0, #0x4]
700a02d4: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a02d6: 9801         	ldr	r0, [sp, #0x4]
700a02d8: 6d82         	ldr	r2, [r0, #0x58]
700a02da: f244 2040    	movw	r0, #0x4240
700a02de: f2c0 000f    	movt	r0, #0xf
700a02e2: 2100         	movs	r1, #0x0
700a02e4: 9100         	str	r1, [sp]
700a02e6: 4790         	blx	r2
700a02e8: 9a00         	ldr	r2, [sp]
700a02ea: 9903         	ldr	r1, [sp, #0xc]
700a02ec: 66ca         	str	r2, [r1, #0x6c]
700a02ee: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a02f0: 9803         	ldr	r0, [sp, #0xc]
700a02f2: 6800         	ldr	r0, [r0]
700a02f4: f006 fa34    	bl	0x700a6760 <UART_IsBaseAddrValid> @ imm = #0x6468
700a02f8: 4601         	mov	r1, r0
700a02fa: 9802         	ldr	r0, [sp, #0x8]
700a02fc: 4408         	add	r0, r1
700a02fe: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a0300: 9801         	ldr	r0, [sp, #0x4]
700a0302: 6800         	ldr	r0, [r0]
700a0304: f00c fffc    	bl	0x700ad300 <UART_IsParameter> @ imm = #0xcff8
700a0308: 4601         	mov	r1, r0
700a030a: 9802         	ldr	r0, [sp, #0x8]
700a030c: 4408         	add	r0, r1
700a030e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a0310: 9801         	ldr	r0, [sp, #0x4]
700a0312: 6840         	ldr	r0, [r0, #0x4]
700a0314: f00c fff4    	bl	0x700ad300 <UART_IsParameter> @ imm = #0xcfe8
700a0318: 4601         	mov	r1, r0
700a031a: 9802         	ldr	r0, [sp, #0x8]
700a031c: 4408         	add	r0, r1
700a031e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a0320: 9801         	ldr	r0, [sp, #0x4]
700a0322: 6880         	ldr	r0, [r0, #0x8]
700a0324: f00c f83c    	bl	0x700ac3a0 <UART_IsDataLengthValid> @ imm = #0xc078
700a0328: 4601         	mov	r1, r0
700a032a: 9802         	ldr	r0, [sp, #0x8]
700a032c: 4408         	add	r0, r1
700a032e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a0330: 9801         	ldr	r0, [sp, #0x4]
700a0332: 68c0         	ldr	r0, [r0, #0xc]
700a0334: f00c fe34    	bl	0x700acfa0 <UART_IsStopBitsValid> @ imm = #0xcc68
700a0338: 4601         	mov	r1, r0
700a033a: 9802         	ldr	r0, [sp, #0x8]
700a033c: 4408         	add	r0, r1
700a033e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a0340: 9801         	ldr	r0, [sp, #0x4]
700a0342: 6900         	ldr	r0, [r0, #0x10]
700a0344: f00b fdac    	bl	0x700abea0 <UART_IsParityTypeValid> @ imm = #0xbb58
700a0348: 4601         	mov	r1, r0
700a034a: 9802         	ldr	r0, [sp, #0x8]
700a034c: 4408         	add	r0, r1
700a034e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a0350: 9801         	ldr	r0, [sp, #0x4]
700a0352: 69c0         	ldr	r0, [r0, #0x1c]
700a0354: f00b fc44    	bl	0x700abbe0 <UART_IsHWFlowCtrlValid> @ imm = #0xb888
700a0358: 4601         	mov	r1, r0
700a035a: 9802         	ldr	r0, [sp, #0x8]
700a035c: 4408         	add	r0, r1
700a035e: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a0360: 9801         	ldr	r0, [sp, #0x4]
700a0362: 6ac0         	ldr	r0, [r0, #0x2c]
700a0364: f00a fc94    	bl	0x700aac90 <UART_OperModeValid> @ imm = #0xa928
700a0368: 4601         	mov	r1, r0
700a036a: 9802         	ldr	r0, [sp, #0x8]
700a036c: 4408         	add	r0, r1
700a036e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a0370: 9801         	ldr	r0, [sp, #0x4]
700a0372: 6b80         	ldr	r0, [r0, #0x38]
700a0374: f00b fc54    	bl	0x700abc20 <UART_IsRxTrigLvlValid> @ imm = #0xb8a8
700a0378: 4601         	mov	r1, r0
700a037a: 9802         	ldr	r0, [sp, #0x8]
700a037c: 4408         	add	r0, r1
700a037e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a0380: 9801         	ldr	r0, [sp, #0x4]
700a0382: 6bc0         	ldr	r0, [r0, #0x3c]
700a0384: f00b fc6c    	bl	0x700abc60 <UART_IsTxTrigLvlValid> @ imm = #0xb8d8
700a0388: 4601         	mov	r1, r0
700a038a: 9802         	ldr	r0, [sp, #0x8]
700a038c: 4408         	add	r0, r1
700a038e: 9002         	str	r0, [sp, #0x8]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a0390: 9801         	ldr	r0, [sp, #0x4]
700a0392: 6c80         	ldr	r0, [r0, #0x48]
;             || (hUartInit->dmaChCfg == NULL_PTR))
700a0394: b120         	cbz	r0, 0x700a03a0 <UART_lld_initDma+0x110> @ imm = #0x8
700a0396: e7ff         	b	0x700a0398 <UART_lld_initDma+0x108> @ imm = #-0x2
700a0398: 9801         	ldr	r0, [sp, #0x4]
700a039a: 6cc0         	ldr	r0, [r0, #0x4c]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a039c: b920         	cbnz	r0, 0x700a03a8 <UART_lld_initDma+0x118> @ imm = #0x8
700a039e: e7ff         	b	0x700a03a0 <UART_lld_initDma+0x110> @ imm = #-0x2
;             status += UART_INVALID_PARAM;
700a03a0: 9802         	ldr	r0, [sp, #0x8]
700a03a2: 3803         	subs	r0, #0x3
700a03a4: 9002         	str	r0, [sp, #0x8]
;         }
700a03a6: e7ff         	b	0x700a03a8 <UART_lld_initDma+0x118> @ imm = #-0x2
;     }
700a03a8: e7ff         	b	0x700a03aa <UART_lld_initDma+0x11a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a03aa: 9802         	ldr	r0, [sp, #0x8]
700a03ac: b950         	cbnz	r0, 0x700a03c4 <UART_lld_initDma+0x134> @ imm = #0x14
700a03ae: e7ff         	b	0x700a03b0 <UART_lld_initDma+0x120> @ imm = #-0x2
;         UART_configInstance(hUart);
700a03b0: 9803         	ldr	r0, [sp, #0xc]
700a03b2: f003 f985    	bl	0x700a36c0 <UART_configInstance> @ imm = #0x330a
;         status = UART_lld_dmaInit(hUart, hUart->hUartInit->dmaChCfg);
700a03b6: 9803         	ldr	r0, [sp, #0xc]
700a03b8: 6841         	ldr	r1, [r0, #0x4]
700a03ba: 6cc9         	ldr	r1, [r1, #0x4c]
700a03bc: f00b f818    	bl	0x700ab3f0 <UART_lld_dmaInit> @ imm = #0xb030
700a03c0: 9002         	str	r0, [sp, #0x8]
;     }
700a03c2: e7ff         	b	0x700a03c4 <UART_lld_initDma+0x134> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a03c4: 9802         	ldr	r0, [sp, #0x8]
700a03c6: b920         	cbnz	r0, 0x700a03d2 <UART_lld_initDma+0x142> @ imm = #0x8
700a03c8: e7ff         	b	0x700a03ca <UART_lld_initDma+0x13a> @ imm = #-0x2
;         hUart->state = UART_STATE_READY;
700a03ca: 9903         	ldr	r1, [sp, #0xc]
700a03cc: 2001         	movs	r0, #0x1
700a03ce: 6548         	str	r0, [r1, #0x54]
;     }
700a03d0: e004         	b	0x700a03dc <UART_lld_initDma+0x14c> @ imm = #0x8
;        status = UART_lld_deInitDma(hUart);
700a03d2: 9803         	ldr	r0, [sp, #0xc]
700a03d4: f009 fb94    	bl	0x700a9b00 <UART_lld_deInitDma> @ imm = #0x9728
700a03d8: 9002         	str	r0, [sp, #0x8]
700a03da: e7ff         	b	0x700a03dc <UART_lld_initDma+0x14c> @ imm = #-0x2
;     return status;
700a03dc: 9802         	ldr	r0, [sp, #0x8]
700a03de: b004         	add	sp, #0x10
700a03e0: bd80         	pop	{r7, pc}
700a03e2: 0000         	movs	r0, r0

700a03e4 <CSL_armR5PmuSelectCntr>:
;     AND     r0, r0, #0x1F
700a03e4: e200001f     	and	r0, r0, #31
;     MCR     p15, #0, r0, c9, c12, #5        /* Write PMSELR Register */
700a03e8: ee090fbc     	mcr	p15, #0x0, r0, c9, c12, #0x5
;     BX      lr
700a03ec: e12fff1e     	bx	lr

700a03f0 <CSL_armR5PmuCfg>:
;     MRC     p15, #0, r3, c9, c12, #0        /* Read PMCR Register */
700a03f0: ee193f1c     	mrc	p15, #0x0, r3, c9, c12, #0x0
;     BIC     r3, r3, #((1<<3) | (1<<4))      /* Clear D and X bits */
700a03f4: e3c33018     	bic	r3, r3, #24
;     CMP     r0, #0
700a03f8: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuCfg_00
700a03fc: 0a000000     	beq	0x700a0404 <armR5PmuCfg_00> @ imm = #0x0
;     ORR     r3, r3, #(1<<3)                 /* Set D bit */
700a0400: e3833008     	orr	r3, r3, #8

700a0404 <armR5PmuCfg_00>:
;     CMP     r1, #0
700a0404: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuCfg_01
700a0408: 0a000000     	beq	0x700a0410 <armR5PmuCfg_01> @ imm = #0x0
;     ORR     r3, r3, #(1<<4)                 /* Set X bit */
700a040c: e3833010     	orr	r3, r3, #16

700a0410 <armR5PmuCfg_01>:
;     MCR     p15, #0, r3, c9, c12, #0        /* Write PMCR Register */
700a0410: ee093f1c     	mcr	p15, #0x0, r3, c9, c12, #0x0
;     EOR     r3, r3, r3                      /* Clear r3 */
700a0414: e0233003     	eor	r3, r3, r3
;     CMP     r2, #0
700a0418: e3520000     	cmp	r2, #0
;     BEQ     armR5PmuCfg_02
700a041c: 0a000000     	beq	0x700a0424 <armR5PmuCfg_02> @ imm = #0x0
;     ORR     r3, r3, #1
700a0420: e3833001     	orr	r3, r3, #1

700a0424 <armR5PmuCfg_02>:
;     MCR     p15, #0, r3, c9, c14, #0        /* Write PMUSERENR Register */
700a0424: ee093f1e     	mcr	p15, #0x0, r3, c9, c14, #0x0
;     BX      lr
700a0428: e12fff1e     	bx	lr

700a042c <CSL_armR5PmuEnableAllCntrs>:
;     MRC     p15, #0, r1, c9, c12, #0        /* Read PMCR */
700a042c: ee191f1c     	mrc	p15, #0x0, r1, c9, c12, #0x0
;     CMP     r0, #0
700a0430: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuEnableAllCntrs_disable
700a0434: 0a000001     	beq	0x700a0440 <armR5PmuEnableAllCntrs_disable> @ imm = #0x4
;     ORR     r1, r1, #0x1                    /* Set E bit to enable all counters */
700a0438: e3811001     	orr	r1, r1, #1
;     B       armR5PmuEnableAllCntrs_00
700a043c: ea000000     	b	0x700a0444 <armR5PmuEnableAllCntrs_00> @ imm = #0x0

700a0440 <armR5PmuEnableAllCntrs_disable>:
;     BIC     r1, r1, #0x1                    /* Clr E bit to disable all counters */
700a0440: e3c11001     	bic	r1, r1, #1

700a0444 <armR5PmuEnableAllCntrs_00>:
;     MCR     p15, #0, r1, c9, c12, #0        /* Write modified PMCR */
700a0444: ee091f1c     	mcr	p15, #0x0, r1, c9, c12, #0x0
;     BX      lr
700a0448: e12fff1e     	bx	lr

700a044c <CSL_armR5PmuGetNumCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR (Performance Monitor Control Register) */
700a044c: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     LSR     r0, r0, #11                     /* Shift and */
700a0450: e1a005a0     	lsr	r0, r0, #11
;     AND     r0, r0, #0x1F                   /*   mask to get N */
700a0454: e200001f     	and	r0, r0, #31
;     BX      lr
700a0458: e12fff1e     	bx	lr

700a045c <CSL_armR5PmuCfgCntr>:
;     PUSH    {lr}
700a045c: e52de004     	str	lr, [sp, #-0x4]!
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a0460: ebffffdf     	bl	0x700a03e4 <CSL_armR5PmuSelectCntr> @ imm = #-0x84
;     AND     r1, r1, #0xFF
700a0464: e20110ff     	and	r1, r1, #255
;     MCR     p15, #0, r1, c9, c13, #1        /* Write PMXEVTYPERx Register */
700a0468: ee091f3d     	mcr	p15, #0x0, r1, c9, c13, #0x1
;     POP     {lr}
700a046c: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a0470: e12fff1e     	bx	lr

700a0474 <CSL_armR5PmuEnableCntrOverflowIntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a0474: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a0478: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a047c: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a0480: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrOverflowIntr_clear
700a0484: 0a000001     	beq	0x700a0490 <armR5PmuEnableCntrOverflowIntr_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c14, #1        /* Write PMINTENSET Register (writes of 0 have no effect) */
700a0488: ee090f3e     	mcr	p15, #0x0, r0, c9, c14, #0x1
;     B       armR5PmuEnableCntrOverflowIntr_00
700a048c: ea000000     	b	0x700a0494 <armR5PmuEnableCntrOverflowIntr_00> @ imm = #0x0

700a0490 <armR5PmuEnableCntrOverflowIntr_clear>:
;     MCR     p15, #0, r0, c9, c14, #2        /* Write PMINTENCLR Register (writes of 0 have no effect) */
700a0490: ee090f5e     	mcr	p15, #0x0, r0, c9, c14, #0x2

700a0494 <armR5PmuEnableCntrOverflowIntr_00>:
;     BX      lr
700a0494: e12fff1e     	bx	lr

700a0498 <CSL_armR5PmuEnableCntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a0498: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a049c: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a04a0: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a04a4: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrs_clear
700a04a8: 0a000001     	beq	0x700a04b4 <armR5PmuEnableCntrs_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c12, #1        /* Write PMCNTENSET Register (writes of 0 have no effect) */
700a04ac: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;     B       armR5PmuEnableCntrs_00
700a04b0: ea000000     	b	0x700a04b8 <armR5PmuEnableCntrs_00> @ imm = #0x0

700a04b4 <armR5PmuEnableCntrs_clear>:
;     MCR     p15, #0, r0, c9, c12, #2        /* Write PMCNTENCLR Register (writes of 0 have no effect) */
700a04b4: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2

700a04b8 <armR5PmuEnableCntrs_00>:
;     BX      lr
700a04b8: e12fff1e     	bx	lr

700a04bc <CSL_armR5PmuReadCntr>:
;     PUSH    {lr}
700a04bc: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a04c0: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuReadCntr_cycles
700a04c4: 0a000002     	beq	0x700a04d4 <armR5PmuReadCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a04c8: ebffffc5     	bl	0x700a03e4 <CSL_armR5PmuSelectCntr> @ imm = #-0xec
;     MRC     p15, #0, r0, c9, c13, #2        /* Read current PMNx Register */
700a04cc: ee190f5d     	mrc	p15, #0x0, r0, c9, c13, #0x2
;     B       armR5PmuReadCntr_00
700a04d0: ea000000     	b	0x700a04d8 <armR5PmuReadCntr_00> @ imm = #0x0

700a04d4 <armR5PmuReadCntr_cycles>:
;     MRC     p15, #0, r0, c9, c13, #0        /* Read PMCCNTR Register */
700a04d4: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0

700a04d8 <armR5PmuReadCntr_00>:
;     POP     {lr}
700a04d8: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a04dc: e12fff1e     	bx	lr

700a04e0 <CSL_armR5PmuSetCntr>:
;     PUSH    {lr}
700a04e0: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a04e4: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuSetCntr_cycles
700a04e8: 0a000002     	beq	0x700a04f8 <armR5PmuSetCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a04ec: ebffffbc     	bl	0x700a03e4 <CSL_armR5PmuSelectCntr> @ imm = #-0x110
;     MCR     p15, #0, r1, c9, c13, #2        /* Write current PMNx Register */
700a04f0: ee091f5d     	mcr	p15, #0x0, r1, c9, c13, #0x2
;     B       armR5PmuSetCntr_00
700a04f4: ea000000     	b	0x700a04fc <armR5PmuSetCntr_00> @ imm = #0x0

700a04f8 <armR5PmuSetCntr_cycles>:
;     MCR     p15, #0, r1, c9, c13, #0        /* Write PMCCNTR Register */
700a04f8: ee091f1d     	mcr	p15, #0x0, r1, c9, c13, #0x0

700a04fc <armR5PmuSetCntr_00>:
;     POP     {lr}
700a04fc: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a0500: e12fff1e     	bx	lr

700a0504 <CSL_armR5PmuReadCntrOverflowStatus>:
;     MRC     p15, #0, r0, c9, c12, #3        /* Read PMOVSR Register */
700a0504: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a0508: e12fff1e     	bx	lr

700a050c <CSL_armR5PmuClearCntrOverflowStatus>:
;     MCR     p15, #0, r0, c9, c12, #3        /* Write PMOVSR Register */
700a050c: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a0510: e12fff1e     	bx	lr

700a0514 <CSL_armR5PmuResetCycleCnt>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a0514: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<2)                 /* Set C bit to reset the cycle counter, PMCCNTR, to zero */
700a0518: e3800004     	orr	r0, r0, #4
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR*/
700a051c: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a0520: e12fff1e     	bx	lr

700a0524 <CSL_armR5PmuResetCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a0524: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<1)                 /* Set P bit to reset all event counters to zero */
700a0528: e3800002     	orr	r0, r0, #2
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR */
700a052c: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a0530: e12fff1e     	bx	lr
		...

700a0540 <Udma_chAssignRegOverlay>:
; {
700a0540: b082         	sub	sp, #0x8
700a0542: 9001         	str	r0, [sp, #0x4]
700a0544: 9100         	str	r1, [sp]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a0546: 9801         	ldr	r0, [sp, #0x4]
700a0548: 6800         	ldr	r0, [r0]
700a054a: 2801         	cmp	r0, #0x1
700a054c: d147         	bne	0x700a05de <Udma_chAssignRegOverlay+0x9e> @ imm = #0x8e
700a054e: e7ff         	b	0x700a0550 <Udma_chAssignRegOverlay+0x10> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a0550: 9800         	ldr	r0, [sp]
700a0552: 6ec0         	ldr	r0, [r0, #0x6c]
700a0554: f510 3f80    	cmn.w	r0, #0x10000
700a0558: d029         	beq	0x700a05ae <Udma_chAssignRegOverlay+0x6e> @ imm = #0x52
700a055a: e7ff         	b	0x700a055c <Udma_chAssignRegOverlay+0x1c> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a055c: 9800         	ldr	r0, [sp]
700a055e: 7800         	ldrb	r0, [r0]
700a0560: 0740         	lsls	r0, r0, #0x1d
700a0562: 2800         	cmp	r0, #0x0
700a0564: d511         	bpl	0x700a058a <Udma_chAssignRegOverlay+0x4a> @ imm = #0x22
700a0566: e7ff         	b	0x700a0568 <Udma_chAssignRegOverlay+0x28> @ imm = #-0x2
;                     &drvHandle->bcdmaRegs.pBcChanCfgRegs->CHAN[chHandle->txChNum];
700a0568: 9801         	ldr	r0, [sp, #0x4]
700a056a: 68c0         	ldr	r0, [r0, #0xc]
700a056c: 9900         	ldr	r1, [sp]
700a056e: 6eca         	ldr	r2, [r1, #0x6c]
700a0570: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaBcCfgRegs =
700a0574: f8c1 0214    	str.w	r0, [r1, #0x214]
;                     &drvHandle->bcdmaRegs.pBcChanRtRegs->CHAN[chHandle->txChNum];
700a0578: 9801         	ldr	r0, [sp, #0x4]
700a057a: 6900         	ldr	r0, [r0, #0x10]
700a057c: 9900         	ldr	r1, [sp]
700a057e: 6eca         	ldr	r2, [r1, #0x6c]
700a0580: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaBcRtRegs  =
700a0584: f8c1 0218    	str.w	r0, [r1, #0x218]
;             }
700a0588: e010         	b	0x700a05ac <Udma_chAssignRegOverlay+0x6c> @ imm = #0x20
;                     &drvHandle->bcdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a058a: 9801         	ldr	r0, [sp, #0x4]
700a058c: 6940         	ldr	r0, [r0, #0x14]
700a058e: 9900         	ldr	r1, [sp]
700a0590: 6eca         	ldr	r2, [r1, #0x6c]
700a0592: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaTxCfgRegs =
700a0596: f8c1 021c    	str.w	r0, [r1, #0x21c]
;                     &drvHandle->bcdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a059a: 9801         	ldr	r0, [sp, #0x4]
700a059c: 6980         	ldr	r0, [r0, #0x18]
700a059e: 9900         	ldr	r1, [sp]
700a05a0: 6eca         	ldr	r2, [r1, #0x6c]
700a05a2: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaTxRtRegs  =
700a05a6: f8c1 0220    	str.w	r0, [r1, #0x220]
700a05aa: e7ff         	b	0x700a05ac <Udma_chAssignRegOverlay+0x6c> @ imm = #-0x2
;         }
700a05ac: e7ff         	b	0x700a05ae <Udma_chAssignRegOverlay+0x6e> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a05ae: 9800         	ldr	r0, [sp]
700a05b0: 6f00         	ldr	r0, [r0, #0x70]
700a05b2: f510 3f80    	cmn.w	r0, #0x10000
700a05b6: d011         	beq	0x700a05dc <Udma_chAssignRegOverlay+0x9c> @ imm = #0x22
700a05b8: e7ff         	b	0x700a05ba <Udma_chAssignRegOverlay+0x7a> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a05ba: 9801         	ldr	r0, [sp, #0x4]
700a05bc: 69c0         	ldr	r0, [r0, #0x1c]
700a05be: 9900         	ldr	r1, [sp]
700a05c0: 6f0a         	ldr	r2, [r1, #0x70]
700a05c2: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pBcdmaRxCfgRegs =
700a05c6: f8c1 0224    	str.w	r0, [r1, #0x224]
;                 &drvHandle->bcdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a05ca: 9801         	ldr	r0, [sp, #0x4]
700a05cc: 6a00         	ldr	r0, [r0, #0x20]
700a05ce: 9900         	ldr	r1, [sp]
700a05d0: 6f0a         	ldr	r2, [r1, #0x70]
700a05d2: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pBcdmaRxRtRegs  =
700a05d6: f8c1 0228    	str.w	r0, [r1, #0x228]
;         }
700a05da: e7ff         	b	0x700a05dc <Udma_chAssignRegOverlay+0x9c> @ imm = #-0x2
;     }
700a05dc: e051         	b	0x700a0682 <Udma_chAssignRegOverlay+0x142> @ imm = #0xa2
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a05de: 9801         	ldr	r0, [sp, #0x4]
700a05e0: 6800         	ldr	r0, [r0]
700a05e2: 2802         	cmp	r0, #0x2
700a05e4: d14c         	bne	0x700a0680 <Udma_chAssignRegOverlay+0x140> @ imm = #0x98
700a05e6: e7ff         	b	0x700a05e8 <Udma_chAssignRegOverlay+0xa8> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a05e8: 9800         	ldr	r0, [sp]
700a05ea: 6ec0         	ldr	r0, [r0, #0x6c]
700a05ec: f510 3f80    	cmn.w	r0, #0x10000
700a05f0: d011         	beq	0x700a0616 <Udma_chAssignRegOverlay+0xd6> @ imm = #0x22
700a05f2: e7ff         	b	0x700a05f4 <Udma_chAssignRegOverlay+0xb4> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a05f4: 9801         	ldr	r0, [sp, #0x4]
700a05f6: 6dc0         	ldr	r0, [r0, #0x5c]
700a05f8: 9900         	ldr	r1, [sp]
700a05fa: 6eca         	ldr	r2, [r1, #0x6c]
700a05fc: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaTxCfgRegs =
700a0600: f8c1 022c    	str.w	r0, [r1, #0x22c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a0604: 9801         	ldr	r0, [sp, #0x4]
700a0606: 6e40         	ldr	r0, [r0, #0x64]
700a0608: 9900         	ldr	r1, [sp]
700a060a: 6eca         	ldr	r2, [r1, #0x6c]
700a060c: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaTxRtRegs  =
700a0610: f8c1 0230    	str.w	r0, [r1, #0x230]
;         }
700a0614: e7ff         	b	0x700a0616 <Udma_chAssignRegOverlay+0xd6> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a0616: 9800         	ldr	r0, [sp]
700a0618: 6f00         	ldr	r0, [r0, #0x70]
700a061a: f510 3f80    	cmn.w	r0, #0x10000
700a061e: d011         	beq	0x700a0644 <Udma_chAssignRegOverlay+0x104> @ imm = #0x22
700a0620: e7ff         	b	0x700a0622 <Udma_chAssignRegOverlay+0xe2> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a0622: 9801         	ldr	r0, [sp, #0x4]
700a0624: 6e00         	ldr	r0, [r0, #0x60]
700a0626: 9900         	ldr	r1, [sp]
700a0628: 6f0a         	ldr	r2, [r1, #0x70]
700a062a: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaRxCfgRegs =
700a062e: f8c1 0234    	str.w	r0, [r1, #0x234]
;                 &drvHandle->pktdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a0632: 9801         	ldr	r0, [sp, #0x4]
700a0634: 6e80         	ldr	r0, [r0, #0x68]
700a0636: 9900         	ldr	r1, [sp]
700a0638: 6f0a         	ldr	r2, [r1, #0x70]
700a063a: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaRxRtRegs  =
700a063e: f8c1 0238    	str.w	r0, [r1, #0x238]
;         }
700a0642: e7ff         	b	0x700a0644 <Udma_chAssignRegOverlay+0x104> @ imm = #-0x2
;         if(chHandle->extChNum != UDMA_DMA_CH_INVALID)
700a0644: 9800         	ldr	r0, [sp]
700a0646: 6f40         	ldr	r0, [r0, #0x74]
700a0648: f510 3f80    	cmn.w	r0, #0x10000
700a064c: d017         	beq	0x700a067e <Udma_chAssignRegOverlay+0x13e> @ imm = #0x2e
700a064e: e7ff         	b	0x700a0650 <Udma_chAssignRegOverlay+0x110> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a0650: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a0652: 9900         	ldr	r1, [sp]
700a0654: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a0656: 6dd8         	ldr	r0, [r3, #0x5c]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a0658: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a065c: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a065e: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaExtCfgRegs =
700a0662: f8c1 023c    	str.w	r0, [r1, #0x23c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a0666: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a0668: 9900         	ldr	r1, [sp]
700a066a: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a066c: 6e58         	ldr	r0, [r3, #0x64]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a066e: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a0672: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a0674: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaExtRtRegs  =
700a0678: f8c1 0240    	str.w	r0, [r1, #0x240]
;         }
700a067c: e7ff         	b	0x700a067e <Udma_chAssignRegOverlay+0x13e> @ imm = #-0x2
;     }
700a067e: e7ff         	b	0x700a0680 <Udma_chAssignRegOverlay+0x140> @ imm = #-0x2
700a0680: e7ff         	b	0x700a0682 <Udma_chAssignRegOverlay+0x142> @ imm = #-0x2
; }
700a0682: b002         	add	sp, #0x8
700a0684: 4770         	bx	lr
		...
700a068e: 0000         	movs	r0, r0

700a0690 <DebugP_memLogWriterPutChar>:
; {
700a0690: b580         	push	{r7, lr}
700a0692: b088         	sub	sp, #0x20
700a0694: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     if(lineBufIndex==0U)
700a0698: f240 30c4    	movw	r0, #0x3c4
700a069c: f2c7 000b    	movt	r0, #0x700b
700a06a0: 6800         	ldr	r0, [r0]
700a06a2: bb40         	cbnz	r0, 0x700a06f6 <DebugP_memLogWriterPutChar+0x66> @ imm = #0x50
700a06a4: e7ff         	b	0x700a06a6 <DebugP_memLogWriterPutChar+0x16> @ imm = #-0x2
;         uint64_t curTime = ClockP_getTimeUsec();
700a06a6: f008 fa3b    	bl	0x700a8b20 <ClockP_getTimeUsec> @ imm = #0x8476
700a06aa: 9105         	str	r1, [sp, #0x14]
700a06ac: 9004         	str	r0, [sp, #0x10]
;                             gDebugP_memTraceLogWriterSelfCoreName,
700a06ae: f240 40c0    	movw	r0, #0x4c0
700a06b2: f2c7 000b    	movt	r0, #0x700b
700a06b6: 6800         	ldr	r0, [r0]
;                             (uint32_t)(curTime/TIME_IN_MICRO_SECONDS),
700a06b8: 9003         	str	r0, [sp, #0xc]
700a06ba: 9804         	ldr	r0, [sp, #0x10]
700a06bc: 9905         	ldr	r1, [sp, #0x14]
700a06be: f244 2240    	movw	r2, #0x4240
700a06c2: f2c0 020f    	movt	r2, #0xf
700a06c6: 2300         	movs	r3, #0x0
;                             (uint32_t)(curTime%TIME_IN_MICRO_SECONDS)
700a06c8: f00c ec7c    	blx	0x700acfc4 <__aeabi_uldivmod> @ imm = #0xc8f8
700a06cc: 9b03         	ldr	r3, [sp, #0xc]
;         lineBufIndex = (uint32_t)snprintf_((char*)lineBuf, DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE, "[%6s] %5d.%06ds : ",
700a06ce: 4669         	mov	r1, sp
700a06d0: 604a         	str	r2, [r1, #0x4]
700a06d2: 6008         	str	r0, [r1]
700a06d4: f644 50c8    	movw	r0, #0x4dc8
700a06d8: f2c7 0008    	movt	r0, #0x7008
700a06dc: f64f 3249    	movw	r2, #0xfb49
700a06e0: f2c7 020a    	movt	r2, #0x700a
700a06e4: 2178         	movs	r1, #0x78
700a06e6: f00b fcbb    	bl	0x700ac060 <snprintf_>  @ imm = #0xb976
700a06ea: f240 31c4    	movw	r1, #0x3c4
700a06ee: f2c7 010b    	movt	r1, #0x700b
700a06f2: 6008         	str	r0, [r1]
;     }
700a06f4: e7ff         	b	0x700a06f6 <DebugP_memLogWriterPutChar+0x66> @ imm = #-0x2
;     lineBuf[lineBufIndex]=(uint8_t)character;
700a06f6: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a06fa: f240 31c4    	movw	r1, #0x3c4
700a06fe: f2c7 010b    	movt	r1, #0x700b
700a0702: 680b         	ldr	r3, [r1]
700a0704: f644 52c8    	movw	r2, #0x4dc8
700a0708: f2c7 0208    	movt	r2, #0x7008
700a070c: 54d0         	strb	r0, [r2, r3]
; 	lineBufIndex = lineBufIndex + 1U;
700a070e: 6808         	ldr	r0, [r1]
700a0710: 3001         	adds	r0, #0x1
700a0712: 6008         	str	r0, [r1]
;     if( (character == '\n') ||
700a0714: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a0718: 280a         	cmp	r0, #0xa
700a071a: d008         	beq	0x700a072e <DebugP_memLogWriterPutChar+0x9e> @ imm = #0x10
700a071c: e7ff         	b	0x700a071e <DebugP_memLogWriterPutChar+0x8e> @ imm = #-0x2
;         (lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE)))
700a071e: f240 30c4    	movw	r0, #0x3c4
700a0722: f2c7 000b    	movt	r0, #0x700b
700a0726: 6800         	ldr	r0, [r0]
;     if( (character == '\n') ||
700a0728: 2878         	cmp	r0, #0x78
700a072a: d350         	blo	0x700a07ce <DebugP_memLogWriterPutChar+0x13e> @ imm = #0xa0
700a072c: e7ff         	b	0x700a072e <DebugP_memLogWriterPutChar+0x9e> @ imm = #-0x2
;         if(lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE))
700a072e: f240 30c4    	movw	r0, #0x3c4
700a0732: f2c7 000b    	movt	r0, #0x700b
700a0736: 6800         	ldr	r0, [r0]
700a0738: 2878         	cmp	r0, #0x78
700a073a: d315         	blo	0x700a0768 <DebugP_memLogWriterPutChar+0xd8> @ imm = #0x2a
700a073c: e7ff         	b	0x700a073e <DebugP_memLogWriterPutChar+0xae> @ imm = #-0x2
;             lineBuf[lineBufIndex]=(uint8_t)'\r';
700a073e: f240 31c4    	movw	r1, #0x3c4
700a0742: f2c7 010b    	movt	r1, #0x700b
700a0746: 680b         	ldr	r3, [r1]
700a0748: f644 52c8    	movw	r2, #0x4dc8
700a074c: f2c7 0208    	movt	r2, #0x7008
700a0750: 200d         	movs	r0, #0xd
700a0752: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a0754: 6808         	ldr	r0, [r1]
700a0756: 3001         	adds	r0, #0x1
700a0758: 6008         	str	r0, [r1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a075a: 680b         	ldr	r3, [r1]
700a075c: 200a         	movs	r0, #0xa
700a075e: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a0760: 6808         	ldr	r0, [r1]
700a0762: 3001         	adds	r0, #0x1
700a0764: 6008         	str	r0, [r1]
;         }
700a0766: e7ff         	b	0x700a0768 <DebugP_memLogWriterPutChar+0xd8> @ imm = #-0x2
;         if(lineBuf[lineBufIndex-UNSIGNED_INTEGERVAL_TWO]!=(uint8_t)'\r')
700a0768: f240 30c4    	movw	r0, #0x3c4
700a076c: f2c7 000b    	movt	r0, #0x700b
700a0770: 6800         	ldr	r0, [r0]
700a0772: f644 51c8    	movw	r1, #0x4dc8
700a0776: f2c7 0108    	movt	r1, #0x7008
700a077a: 4408         	add	r0, r1
700a077c: f810 0c02    	ldrb	r0, [r0, #-2]
700a0780: 280d         	cmp	r0, #0xd
700a0782: d014         	beq	0x700a07ae <DebugP_memLogWriterPutChar+0x11e> @ imm = #0x28
700a0784: e7ff         	b	0x700a0786 <DebugP_memLogWriterPutChar+0xf6> @ imm = #-0x2
;             lineBuf[lineBufIndex-1U]=(uint8_t)'\r';
700a0786: f240 31c4    	movw	r1, #0x3c4
700a078a: f2c7 010b    	movt	r1, #0x700b
700a078e: 6808         	ldr	r0, [r1]
700a0790: f644 52c8    	movw	r2, #0x4dc8
700a0794: f2c7 0208    	movt	r2, #0x7008
700a0798: 1883         	adds	r3, r0, r2
700a079a: 200d         	movs	r0, #0xd
700a079c: f803 0c01    	strb	r0, [r3, #-1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a07a0: 680b         	ldr	r3, [r1]
700a07a2: 200a         	movs	r0, #0xa
700a07a4: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a07a6: 6808         	ldr	r0, [r1]
700a07a8: 3001         	adds	r0, #0x1
700a07aa: 6008         	str	r0, [r1]
;         }
700a07ac: e7ff         	b	0x700a07ae <DebugP_memLogWriterPutChar+0x11e> @ imm = #-0x2
;         DebugP_memTraceLogWriterPutLine(lineBuf, (uint16_t)lineBufIndex);
700a07ae: f240 30c4    	movw	r0, #0x3c4
700a07b2: f2c7 000b    	movt	r0, #0x700b
700a07b6: 9002         	str	r0, [sp, #0x8]
700a07b8: 8801         	ldrh	r1, [r0]
700a07ba: f644 50c8    	movw	r0, #0x4dc8
700a07be: f2c7 0008    	movt	r0, #0x7008
700a07c2: f003 fbf5    	bl	0x700a3fb0 <DebugP_memTraceLogWriterPutLine> @ imm = #0x37ea
700a07c6: 9902         	ldr	r1, [sp, #0x8]
700a07c8: 2000         	movs	r0, #0x0
;         lineBufIndex = 0;
700a07ca: 6008         	str	r0, [r1]
;     }
700a07cc: e7ff         	b	0x700a07ce <DebugP_memLogWriterPutChar+0x13e> @ imm = #-0x2
; }
700a07ce: b008         	add	sp, #0x20
700a07d0: bd80         	pop	{r7, pc}
		...
700a07de: 0000         	movs	r0, r0

700a07e0 <Sciclient_sendMessage>:
; {
700a07e0: b580         	push	{r7, lr}
700a07e2: b08a         	sub	sp, #0x28
700a07e4: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a07e8: 9009         	str	r0, [sp, #0x24]
700a07ea: 9108         	str	r1, [sp, #0x20]
700a07ec: 9207         	str	r2, [sp, #0x1c]
700a07ee: 9306         	str	r3, [sp, #0x18]
700a07f0: 2200         	movs	r2, #0x0
;     uint32_t        i   = 0U;
700a07f2: 9205         	str	r2, [sp, #0x14]
;     const uint8_t *msg = pSecHeader;
700a07f4: 9808         	ldr	r0, [sp, #0x20]
700a07f6: 9004         	str	r0, [sp, #0x10]
;     uint32_t numWords   = 0U;
700a07f8: 9203         	str	r2, [sp, #0xc]
;     uint32_t test = 0U;
700a07fa: 9202         	str	r2, [sp, #0x8]
;     uintptr_t threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U);
700a07fc: 9909         	ldr	r1, [sp, #0x24]
700a07fe: f240 30c8    	movw	r0, #0x3c8
700a0802: f2c7 000b    	movt	r0, #0x700b
700a0806: f00c fd6b    	bl	0x700ad2e0 <CSL_secProxyGetDataAddr> @ imm = #0xcad6
700a080a: 9001         	str	r0, [sp, #0x4]
;     if(pSecHeader != NULL)
700a080c: 9808         	ldr	r0, [sp, #0x20]
700a080e: b1f8         	cbz	r0, 0x700a0850 <Sciclient_sendMessage+0x70> @ imm = #0x3e
700a0810: e7ff         	b	0x700a0812 <Sciclient_sendMessage+0x32> @ imm = #-0x2
700a0812: 2000         	movs	r0, #0x0
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a0814: 9005         	str	r0, [sp, #0x14]
700a0816: e7ff         	b	0x700a0818 <Sciclient_sendMessage+0x38> @ imm = #-0x2
700a0818: 9805         	ldr	r0, [sp, #0x14]
700a081a: f240 5130    	movw	r1, #0x530
700a081e: f2c7 010b    	movt	r1, #0x700b
700a0822: 7809         	ldrb	r1, [r1]
700a0824: 4288         	cmp	r0, r1
700a0826: d212         	bhs	0x700a084e <Sciclient_sendMessage+0x6e> @ imm = #0x24
700a0828: e7ff         	b	0x700a082a <Sciclient_sendMessage+0x4a> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a082a: 9804         	ldr	r0, [sp, #0x10]
700a082c: 6800         	ldr	r0, [r0]
700a082e: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a0830: 9801         	ldr	r0, [sp, #0x4]
700a0832: 9902         	ldr	r1, [sp, #0x8]
700a0834: f00d f804    	bl	0x700ad840 <CSL_REG32_WR_RAW> @ imm = #0xd008
;             msg += 4;
700a0838: 9804         	ldr	r0, [sp, #0x10]
700a083a: 3004         	adds	r0, #0x4
700a083c: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a083e: 9801         	ldr	r0, [sp, #0x4]
700a0840: 3004         	adds	r0, #0x4
700a0842: 9001         	str	r0, [sp, #0x4]
;         }
700a0844: e7ff         	b	0x700a0846 <Sciclient_sendMessage+0x66> @ imm = #-0x2
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a0846: 9805         	ldr	r0, [sp, #0x14]
700a0848: 3001         	adds	r0, #0x1
700a084a: 9005         	str	r0, [sp, #0x14]
700a084c: e7e4         	b	0x700a0818 <Sciclient_sendMessage+0x38> @ imm = #-0x38
;     }
700a084e: e7ff         	b	0x700a0850 <Sciclient_sendMessage+0x70> @ imm = #-0x2
;     msg = pHeader;
700a0850: 9807         	ldr	r0, [sp, #0x1c]
700a0852: 9004         	str	r0, [sp, #0x10]
700a0854: 2000         	movs	r0, #0x0
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a0856: 9005         	str	r0, [sp, #0x14]
700a0858: e7ff         	b	0x700a085a <Sciclient_sendMessage+0x7a> @ imm = #-0x2
700a085a: 9805         	ldr	r0, [sp, #0x14]
700a085c: 2801         	cmp	r0, #0x1
700a085e: d812         	bhi	0x700a0886 <Sciclient_sendMessage+0xa6> @ imm = #0x24
700a0860: e7ff         	b	0x700a0862 <Sciclient_sendMessage+0x82> @ imm = #-0x2
;         (void) memcpy((void *)&test, (const void *)msg, 4);
700a0862: 9804         	ldr	r0, [sp, #0x10]
700a0864: 6800         	ldr	r0, [r0]
700a0866: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(threadAddr, test);
700a0868: 9801         	ldr	r0, [sp, #0x4]
700a086a: 9902         	ldr	r1, [sp, #0x8]
700a086c: f00c ffe8    	bl	0x700ad840 <CSL_REG32_WR_RAW> @ imm = #0xcfd0
;         msg += 4;
700a0870: 9804         	ldr	r0, [sp, #0x10]
700a0872: 3004         	adds	r0, #0x4
700a0874: 9004         	str	r0, [sp, #0x10]
;         threadAddr+=sizeof(uint32_t);
700a0876: 9801         	ldr	r0, [sp, #0x4]
700a0878: 3004         	adds	r0, #0x4
700a087a: 9001         	str	r0, [sp, #0x4]
;     }
700a087c: e7ff         	b	0x700a087e <Sciclient_sendMessage+0x9e> @ imm = #-0x2
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a087e: 9805         	ldr	r0, [sp, #0x14]
700a0880: 3001         	adds	r0, #0x1
700a0882: 9005         	str	r0, [sp, #0x14]
700a0884: e7e9         	b	0x700a085a <Sciclient_sendMessage+0x7a> @ imm = #-0x2e
;     if (payloadSize > 0U)
700a0886: 980c         	ldr	r0, [sp, #0x30]
700a0888: b300         	cbz	r0, 0x700a08cc <Sciclient_sendMessage+0xec> @ imm = #0x40
700a088a: e7ff         	b	0x700a088c <Sciclient_sendMessage+0xac> @ imm = #-0x2
;         numWords   = (payloadSize+3U)/4U;
700a088c: 980c         	ldr	r0, [sp, #0x30]
700a088e: 3003         	adds	r0, #0x3
700a0890: 0880         	lsrs	r0, r0, #0x2
700a0892: 9003         	str	r0, [sp, #0xc]
;         msg = pPayload;
700a0894: 9806         	ldr	r0, [sp, #0x18]
700a0896: 9004         	str	r0, [sp, #0x10]
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a0898: e7ff         	b	0x700a089a <Sciclient_sendMessage+0xba> @ imm = #-0x2
700a089a: 9805         	ldr	r0, [sp, #0x14]
700a089c: 9903         	ldr	r1, [sp, #0xc]
700a089e: 3102         	adds	r1, #0x2
700a08a0: 4288         	cmp	r0, r1
700a08a2: d212         	bhs	0x700a08ca <Sciclient_sendMessage+0xea> @ imm = #0x24
700a08a4: e7ff         	b	0x700a08a6 <Sciclient_sendMessage+0xc6> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a08a6: 9804         	ldr	r0, [sp, #0x10]
700a08a8: 6800         	ldr	r0, [r0]
700a08aa: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a08ac: 9801         	ldr	r0, [sp, #0x4]
700a08ae: 9902         	ldr	r1, [sp, #0x8]
700a08b0: f00c ffc6    	bl	0x700ad840 <CSL_REG32_WR_RAW> @ imm = #0xcf8c
;             msg += 4;
700a08b4: 9804         	ldr	r0, [sp, #0x10]
700a08b6: 3004         	adds	r0, #0x4
700a08b8: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a08ba: 9801         	ldr	r0, [sp, #0x4]
700a08bc: 3004         	adds	r0, #0x4
700a08be: 9001         	str	r0, [sp, #0x4]
;         }
700a08c0: e7ff         	b	0x700a08c2 <Sciclient_sendMessage+0xe2> @ imm = #-0x2
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a08c2: 9805         	ldr	r0, [sp, #0x14]
700a08c4: 3001         	adds	r0, #0x1
700a08c6: 9005         	str	r0, [sp, #0x14]
700a08c8: e7e7         	b	0x700a089a <Sciclient_sendMessage+0xba> @ imm = #-0x32
;     }
700a08ca: e7ff         	b	0x700a08cc <Sciclient_sendMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a08cc: f240 5030    	movw	r0, #0x530
700a08d0: f2c7 000b    	movt	r0, #0x700b
700a08d4: 7801         	ldrb	r1, [r0]
700a08d6: 980c         	ldr	r0, [sp, #0x30]
700a08d8: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a08dc: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a08de: f240 4138    	movw	r1, #0x438
700a08e2: f2c7 010b    	movt	r1, #0x700b
700a08e6: 6949         	ldr	r1, [r1, #0x14]
700a08e8: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a08ea: 4288         	cmp	r0, r1
700a08ec: d817         	bhi	0x700a091e <Sciclient_sendMessage+0x13e> @ imm = #0x2e
700a08ee: e7ff         	b	0x700a08f0 <Sciclient_sendMessage+0x110> @ imm = #-0x2
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a08f0: 9909         	ldr	r1, [sp, #0x24]
700a08f2: f240 30c8    	movw	r0, #0x3c8
700a08f6: f2c7 000b    	movt	r0, #0x700b
700a08fa: 2200         	movs	r2, #0x0
700a08fc: 9200         	str	r2, [sp]
700a08fe: f00c fcef    	bl	0x700ad2e0 <CSL_secProxyGetDataAddr> @ imm = #0xc9de
700a0902: 9900         	ldr	r1, [sp]
700a0904: 4602         	mov	r2, r0
;         ((uintptr_t) gSciclientHandle.maxMsgSizeBytes  - (uintptr_t) 4U) ;
700a0906: f240 4038    	movw	r0, #0x438
700a090a: f2c7 000b    	movt	r0, #0x700b
700a090e: 6940         	ldr	r0, [r0, #0x14]
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a0910: 4410         	add	r0, r2
700a0912: 3804         	subs	r0, #0x4
700a0914: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(threadAddr,0U);
700a0916: 9801         	ldr	r0, [sp, #0x4]
700a0918: f00c ff92    	bl	0x700ad840 <CSL_REG32_WR_RAW> @ imm = #0xcf24
;     }
700a091c: e7ff         	b	0x700a091e <Sciclient_sendMessage+0x13e> @ imm = #-0x2
; }
700a091e: b00a         	add	sp, #0x28
700a0920: bd80         	pop	{r7, pc}
		...
700a092e: 0000         	movs	r0, r0

700a0930 <Sciclient_rmIaValidateMapping>:
; {
700a0930: b580         	push	{r7, lr}
700a0932: b088         	sub	sp, #0x20
700a0934: 4684         	mov	r12, r0
700a0936: 980a         	ldr	r0, [sp, #0x28]
700a0938: f88d c01f    	strb.w	r12, [sp, #0x1f]
700a093c: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a0940: f8ad 201a    	strh.w	r2, [sp, #0x1a]
700a0944: f8ad 3018    	strh.w	r3, [sp, #0x18]
700a0948: f88d 0017    	strb.w	r0, [sp, #0x17]
700a094c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a094e: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700a0950: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700a0952: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a0956: f009 fd7b    	bl	0x700aa450 <Sciclient_rmIaGetInst> @ imm = #0x9af6
700a095a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a095c: 9803         	ldr	r0, [sp, #0xc]
700a095e: b920         	cbnz	r0, 0x700a096a <Sciclient_rmIaValidateMapping+0x3a> @ imm = #0x8
700a0960: e7ff         	b	0x700a0962 <Sciclient_rmIaValidateMapping+0x32> @ imm = #-0x2
700a0962: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0966: 9004         	str	r0, [sp, #0x10]
;     } else {
700a0968: e00b         	b	0x700a0982 <Sciclient_rmIaValidateMapping+0x52> @ imm = #0x16
;         if (vint >= inst->n_vint) {
700a096a: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a096e: 9903         	ldr	r1, [sp, #0xc]
700a0970: 8989         	ldrh	r1, [r1, #0xc]
700a0972: 4288         	cmp	r0, r1
700a0974: db04         	blt	0x700a0980 <Sciclient_rmIaValidateMapping+0x50> @ imm = #0x8
700a0976: e7ff         	b	0x700a0978 <Sciclient_rmIaValidateMapping+0x48> @ imm = #-0x2
700a0978: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a097c: 9004         	str	r0, [sp, #0x10]
;         }
700a097e: e7ff         	b	0x700a0980 <Sciclient_rmIaValidateMapping+0x50> @ imm = #-0x2
700a0980: e7ff         	b	0x700a0982 <Sciclient_rmIaValidateMapping+0x52> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (vint_sb_index >= SCICLIENT_IA_VINT_MAX_BITS)) {
700a0982: 9804         	ldr	r0, [sp, #0x10]
700a0984: b948         	cbnz	r0, 0x700a099a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x12
700a0986: e7ff         	b	0x700a0988 <Sciclient_rmIaValidateMapping+0x58> @ imm = #-0x2
700a0988: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a098c: 2840         	cmp	r0, #0x40
700a098e: d304         	blo	0x700a099a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x8
700a0990: e7ff         	b	0x700a0992 <Sciclient_rmIaValidateMapping+0x62> @ imm = #-0x2
700a0992: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0996: 9004         	str	r0, [sp, #0x10]
;     }
700a0998: e7ff         	b	0x700a099a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a099a: 9804         	ldr	r0, [sp, #0x10]
700a099c: b998         	cbnz	r0, 0x700a09c6 <Sciclient_rmIaValidateMapping+0x96> @ imm = #0x26
700a099e: e7ff         	b	0x700a09a0 <Sciclient_rmIaValidateMapping+0x70> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700a09a0: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a09a4: 9903         	ldr	r1, [sp, #0xc]
700a09a6: 8909         	ldrh	r1, [r1, #0x8]
700a09a8: 1a40         	subs	r0, r0, r1
700a09aa: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         if (evt >= inst->n_sevt) {
700a09ae: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a09b2: 9903         	ldr	r1, [sp, #0xc]
700a09b4: 8949         	ldrh	r1, [r1, #0xa]
700a09b6: 4288         	cmp	r0, r1
700a09b8: db04         	blt	0x700a09c4 <Sciclient_rmIaValidateMapping+0x94> @ imm = #0x8
700a09ba: e7ff         	b	0x700a09bc <Sciclient_rmIaValidateMapping+0x8c> @ imm = #-0x2
700a09bc: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a09c0: 9004         	str	r0, [sp, #0x10]
;         }
700a09c2: e7ff         	b	0x700a09c4 <Sciclient_rmIaValidateMapping+0x94> @ imm = #-0x2
;     }
700a09c4: e7ff         	b	0x700a09c6 <Sciclient_rmIaValidateMapping+0x96> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a09c6: 9804         	ldr	r0, [sp, #0x10]
700a09c8: 2800         	cmp	r0, #0x0
700a09ca: d14e         	bne	0x700a0a6a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #0x9c
700a09cc: e7ff         	b	0x700a09ce <Sciclient_rmIaValidateMapping+0x9e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a09ce: 9803         	ldr	r0, [sp, #0xc]
700a09d0: 6840         	ldr	r0, [r0, #0x4]
700a09d2: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a09d6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a09da: 9001         	str	r0, [sp, #0x4]
;         reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a09dc: 9801         	ldr	r0, [sp, #0x4]
700a09de: f64f 7100    	movw	r1, #0xff00
700a09e2: f2c0 0101    	movt	r1, #0x1
700a09e6: 2208         	movs	r2, #0x8
700a09e8: f00c faaa    	bl	0x700acf40 <CSL_REG32_FEXT_RAW> @ imm = #0xc554
700a09ec: f8ad 0002    	strh.w	r0, [sp, #0x2]
;         reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a09f0: 9801         	ldr	r0, [sp, #0x4]
700a09f2: 213f         	movs	r1, #0x3f
700a09f4: 2200         	movs	r2, #0x0
700a09f6: f00c faa3    	bl	0x700acf40 <CSL_REG32_FEXT_RAW> @ imm = #0xc546
700a09fa: f8ad 0000    	strh.w	r0, [sp]
;         if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a09fe: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a0a02: b9f0         	cbnz	r0, 0x700a0a42 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x3c
700a0a04: e7ff         	b	0x700a0a06 <Sciclient_rmIaValidateMapping+0xd6> @ imm = #-0x2
700a0a06: f8bd 0000    	ldrh.w	r0, [sp]
700a0a0a: b9d0         	cbnz	r0, 0x700a0a42 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x34
700a0a0c: e7ff         	b	0x700a0a0e <Sciclient_rmIaValidateMapping+0xde> @ imm = #-0x2
;             if ((vint != reg_vint) &&
700a0a0e: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a0a12: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a0a16: 4288         	cmp	r0, r1
700a0a18: d012         	beq	0x700a0a40 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x24
700a0a1a: e7ff         	b	0x700a0a1c <Sciclient_rmIaValidateMapping+0xec> @ imm = #-0x2
;                 (vint_sb_index != reg_sb) &&
700a0a1c: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a0a20: f8bd 1000    	ldrh.w	r1, [sp]
700a0a24: 4288         	cmp	r0, r1
700a0a26: d00b         	beq	0x700a0a40 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x16
700a0a28: e7ff         	b	0x700a0a2a <Sciclient_rmIaValidateMapping+0xfa> @ imm = #-0x2
;                 (evt != inst->v0_b0_evt)) {
700a0a2a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a0a2e: 9903         	ldr	r1, [sp, #0xc]
700a0a30: 8a89         	ldrh	r1, [r1, #0x14]
;             if ((vint != reg_vint) &&
700a0a32: 4288         	cmp	r0, r1
700a0a34: d004         	beq	0x700a0a40 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x8
700a0a36: e7ff         	b	0x700a0a38 <Sciclient_rmIaValidateMapping+0x108> @ imm = #-0x2
700a0a38: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a0a3c: 9004         	str	r0, [sp, #0x10]
;             }
700a0a3e: e7ff         	b	0x700a0a40 <Sciclient_rmIaValidateMapping+0x110> @ imm = #-0x2
;         } else {
700a0a40: e012         	b	0x700a0a68 <Sciclient_rmIaValidateMapping+0x138> @ imm = #0x24
;             if ((vint != reg_vint) &&
700a0a42: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a0a46: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a0a4a: 4288         	cmp	r0, r1
700a0a4c: d00b         	beq	0x700a0a66 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x16
700a0a4e: e7ff         	b	0x700a0a50 <Sciclient_rmIaValidateMapping+0x120> @ imm = #-0x2
;                 (vint_sb_index != reg_sb)) {
700a0a50: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a0a54: f8bd 1000    	ldrh.w	r1, [sp]
;             if ((vint != reg_vint) &&
700a0a58: 4288         	cmp	r0, r1
700a0a5a: d004         	beq	0x700a0a66 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x8
700a0a5c: e7ff         	b	0x700a0a5e <Sciclient_rmIaValidateMapping+0x12e> @ imm = #-0x2
700a0a5e: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a0a62: 9004         	str	r0, [sp, #0x10]
;             }
700a0a64: e7ff         	b	0x700a0a66 <Sciclient_rmIaValidateMapping+0x136> @ imm = #-0x2
700a0a66: e7ff         	b	0x700a0a68 <Sciclient_rmIaValidateMapping+0x138> @ imm = #-0x2
;     }
700a0a68: e7ff         	b	0x700a0a6a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #-0x2
;     return r;
700a0a6a: 9804         	ldr	r0, [sp, #0x10]
700a0a6c: b008         	add	sp, #0x20
700a0a6e: bd80         	pop	{r7, pc}

700a0a70 <Udma_rmAllocMappedRing>:
; {
700a0a70: b580         	push	{r7, lr}
700a0a72: b090         	sub	sp, #0x40
700a0a74: 900f         	str	r0, [sp, #0x3c]
700a0a76: 910e         	str	r1, [sp, #0x38]
700a0a78: 920d         	str	r2, [sp, #0x34]
700a0a7a: f64f 70ff    	movw	r0, #0xffff
;     uint32_t    ringNum = UDMA_RING_INVALID;
700a0a7e: 900c         	str	r0, [sp, #0x30]
700a0a80: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a0a82: 9005         	str	r0, [sp, #0x14]
;     Udma_RmInitPrms             *rmInitPrms = &drvHandle->rmInitPrms;
700a0a84: 980f         	ldr	r0, [sp, #0x3c]
700a0a86: f500 70ea    	add.w	r0, r0, #0x1d4
700a0a8a: 9004         	str	r0, [sp, #0x10]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a0a8c: 980f         	ldr	r0, [sp, #0x3c]
700a0a8e: 990e         	ldr	r1, [sp, #0x38]
700a0a90: 9a0d         	ldr	r2, [sp, #0x34]
700a0a92: ab01         	add	r3, sp, #0x4
700a0a94: f005 f93c    	bl	0x700a5d10 <Udma_getMappedChRingAttributes> @ imm = #0x5278
700a0a98: 9005         	str	r0, [sp, #0x14]
;     if(UDMA_SOK == retVal)
700a0a9a: 9805         	ldr	r0, [sp, #0x14]
700a0a9c: 2800         	cmp	r0, #0x0
700a0a9e: f040 8084    	bne.w	0x700a0baa <Udma_rmAllocMappedRing+0x13a> @ imm = #0x108
700a0aa2: e7ff         	b	0x700a0aa4 <Udma_rmAllocMappedRing+0x34> @ imm = #-0x2
700a0aa4: 2000         	movs	r0, #0x0
;         loopStart = 0;
700a0aa6: 9007         	str	r0, [sp, #0x1c]
;         loopMax   = rmInitPrms->numMappedRing[mappedRingGrp];
700a0aa8: 9804         	ldr	r0, [sp, #0x10]
700a0aaa: 990e         	ldr	r1, [sp, #0x38]
700a0aac: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0ab0: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
700a0ab4: 9006         	str	r0, [sp, #0x18]
;         if(chAttr.startFreeRing > rmInitPrms->startMappedRing[mappedRingGrp])
700a0ab6: 9802         	ldr	r0, [sp, #0x8]
700a0ab8: 9904         	ldr	r1, [sp, #0x10]
700a0aba: 9a0e         	ldr	r2, [sp, #0x38]
700a0abc: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0ac0: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a0ac4: 4288         	cmp	r0, r1
700a0ac6: d90a         	bls	0x700a0ade <Udma_rmAllocMappedRing+0x6e> @ imm = #0x14
700a0ac8: e7ff         	b	0x700a0aca <Udma_rmAllocMappedRing+0x5a> @ imm = #-0x2
;             loopStart = chAttr.startFreeRing - rmInitPrms->startMappedRing[mappedRingGrp];
700a0aca: 9802         	ldr	r0, [sp, #0x8]
700a0acc: 9904         	ldr	r1, [sp, #0x10]
700a0ace: 9a0e         	ldr	r2, [sp, #0x38]
700a0ad0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0ad4: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a0ad8: 1a40         	subs	r0, r0, r1
700a0ada: 9007         	str	r0, [sp, #0x1c]
;         }
700a0adc: e7ff         	b	0x700a0ade <Udma_rmAllocMappedRing+0x6e> @ imm = #-0x2
;         if((chAttr.startFreeRing + chAttr.numFreeRing) < (rmInitPrms->startMappedRing[mappedRingGrp] + rmInitPrms->numMappedRing[mappedRingGrp]))
700a0ade: 9802         	ldr	r0, [sp, #0x8]
700a0ae0: 9903         	ldr	r1, [sp, #0xc]
700a0ae2: 4408         	add	r0, r1
700a0ae4: 9904         	ldr	r1, [sp, #0x10]
700a0ae6: 9a0e         	ldr	r2, [sp, #0x38]
700a0ae8: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a0aec: f8d2 1088    	ldr.w	r1, [r2, #0x88]
700a0af0: f8d2 20a8    	ldr.w	r2, [r2, #0xa8]
700a0af4: 4411         	add	r1, r2
700a0af6: 4288         	cmp	r0, r1
700a0af8: d20c         	bhs	0x700a0b14 <Udma_rmAllocMappedRing+0xa4> @ imm = #0x18
700a0afa: e7ff         	b	0x700a0afc <Udma_rmAllocMappedRing+0x8c> @ imm = #-0x2
;             loopMax = (chAttr.startFreeRing + chAttr.numFreeRing) - rmInitPrms->startMappedRing[mappedRingGrp];
700a0afc: 9802         	ldr	r0, [sp, #0x8]
700a0afe: 9903         	ldr	r1, [sp, #0xc]
700a0b00: 4408         	add	r0, r1
700a0b02: 9904         	ldr	r1, [sp, #0x10]
700a0b04: 9a0e         	ldr	r2, [sp, #0x38]
700a0b06: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0b0a: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a0b0e: 1a40         	subs	r0, r0, r1
700a0b10: 9006         	str	r0, [sp, #0x18]
;         }
700a0b12: e7ff         	b	0x700a0b14 <Udma_rmAllocMappedRing+0xa4> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a0b14: 980f         	ldr	r0, [sp, #0x3c]
700a0b16: f500 609f    	add.w	r0, r0, #0x4f8
700a0b1a: f04f 31ff    	mov.w	r1, #0xffffffff
700a0b1e: f007 fde7    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x7bce
;         for(i = loopStart; i < loopMax; i++)
700a0b22: 9807         	ldr	r0, [sp, #0x1c]
700a0b24: 900b         	str	r0, [sp, #0x2c]
700a0b26: e7ff         	b	0x700a0b28 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x2
700a0b28: 980b         	ldr	r0, [sp, #0x2c]
700a0b2a: 9906         	ldr	r1, [sp, #0x18]
700a0b2c: 4288         	cmp	r0, r1
700a0b2e: d236         	bhs	0x700a0b9e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x6c
700a0b30: e7ff         	b	0x700a0b32 <Udma_rmAllocMappedRing+0xc2> @ imm = #-0x2
;             offset = i >> 5U;
700a0b32: 980b         	ldr	r0, [sp, #0x2c]
700a0b34: 0940         	lsrs	r0, r0, #0x5
700a0b36: 900a         	str	r0, [sp, #0x28]
;             bitPos = i - (offset << 5U);
700a0b38: 980b         	ldr	r0, [sp, #0x2c]
700a0b3a: 990a         	ldr	r1, [sp, #0x28]
700a0b3c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a0b40: 9009         	str	r0, [sp, #0x24]
;             bitMask = (uint32_t) 1U << bitPos;
700a0b42: 9909         	ldr	r1, [sp, #0x24]
700a0b44: 2001         	movs	r0, #0x1
700a0b46: 4088         	lsls	r0, r1
700a0b48: 9008         	str	r0, [sp, #0x20]
;             if((drvHandle->mappedRingFlag[mappedRingGrp][offset] & bitMask) == bitMask)
700a0b4a: 980f         	ldr	r0, [sp, #0x3c]
700a0b4c: 990e         	ldr	r1, [sp, #0x38]
700a0b4e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a0b52: 990a         	ldr	r1, [sp, #0x28]
700a0b54: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0b58: f8d0 0344    	ldr.w	r0, [r0, #0x344]
700a0b5c: 9908         	ldr	r1, [sp, #0x20]
700a0b5e: 4008         	ands	r0, r1
700a0b60: 4288         	cmp	r0, r1
700a0b62: d117         	bne	0x700a0b94 <Udma_rmAllocMappedRing+0x124> @ imm = #0x2e
700a0b64: e7ff         	b	0x700a0b66 <Udma_rmAllocMappedRing+0xf6> @ imm = #-0x2
;                 drvHandle->mappedRingFlag[mappedRingGrp][offset] &= ~bitMask;
700a0b66: 9a08         	ldr	r2, [sp, #0x20]
700a0b68: 980f         	ldr	r0, [sp, #0x3c]
700a0b6a: 990e         	ldr	r1, [sp, #0x38]
700a0b6c: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a0b70: 990a         	ldr	r1, [sp, #0x28]
700a0b72: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a0b76: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a0b7a: 4390         	bics	r0, r2
700a0b7c: f8c1 0344    	str.w	r0, [r1, #0x344]
;                 ringNum = i + rmInitPrms->startMappedRing[mappedRingGrp];  /* Add start offset */
700a0b80: 980b         	ldr	r0, [sp, #0x2c]
700a0b82: 9904         	ldr	r1, [sp, #0x10]
700a0b84: 9a0e         	ldr	r2, [sp, #0x38]
700a0b86: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0b8a: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a0b8e: 4408         	add	r0, r1
700a0b90: 900c         	str	r0, [sp, #0x30]
;                 break;
700a0b92: e004         	b	0x700a0b9e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x8
;         }
700a0b94: e7ff         	b	0x700a0b96 <Udma_rmAllocMappedRing+0x126> @ imm = #-0x2
;         for(i = loopStart; i < loopMax; i++)
700a0b96: 980b         	ldr	r0, [sp, #0x2c]
700a0b98: 3001         	adds	r0, #0x1
700a0b9a: 900b         	str	r0, [sp, #0x2c]
700a0b9c: e7c4         	b	0x700a0b28 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x78
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a0b9e: 980f         	ldr	r0, [sp, #0x3c]
700a0ba0: f500 609f    	add.w	r0, r0, #0x4f8
700a0ba4: f009 f8fc    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x91f8
;     }
700a0ba8: e7ff         	b	0x700a0baa <Udma_rmAllocMappedRing+0x13a> @ imm = #-0x2
;     return (ringNum);
700a0baa: 980c         	ldr	r0, [sp, #0x30]
700a0bac: b010         	add	sp, #0x40
700a0bae: bd80         	pop	{r7, pc}

700a0bb0 <xTaskResumeAll>:
; BaseType_t xTaskResumeAll(void) {
700a0bb0: b580         	push	{r7, lr}
700a0bb2: b084         	sub	sp, #0x10
700a0bb4: 2000         	movs	r0, #0x0
;   TCB_t *pxTCB = NULL;
700a0bb6: 9003         	str	r0, [sp, #0xc]
;   BaseType_t xAlreadyYielded = pdFALSE;
700a0bb8: 9002         	str	r0, [sp, #0x8]
;   taskENTER_CRITICAL();
700a0bba: f00b fce9    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0xb9d2
;     --uxSchedulerSuspended;
700a0bbe: f240 5000    	movw	r0, #0x500
700a0bc2: f2c7 000b    	movt	r0, #0x700b
700a0bc6: 6801         	ldr	r1, [r0]
700a0bc8: 3901         	subs	r1, #0x1
700a0bca: 6001         	str	r1, [r0]
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a0bcc: 6800         	ldr	r0, [r0]
700a0bce: 2800         	cmp	r0, #0x0
700a0bd0: f040 8088    	bne.w	0x700a0ce4 <xTaskResumeAll+0x134> @ imm = #0x110
700a0bd4: e7ff         	b	0x700a0bd6 <xTaskResumeAll+0x26> @ imm = #-0x2
;       if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
700a0bd6: f240 40f8    	movw	r0, #0x4f8
700a0bda: f2c7 000b    	movt	r0, #0x700b
700a0bde: 6800         	ldr	r0, [r0]
700a0be0: 2800         	cmp	r0, #0x0
700a0be2: f000 807e    	beq.w	0x700a0ce2 <xTaskResumeAll+0x132> @ imm = #0xfc
700a0be6: e7ff         	b	0x700a0be8 <xTaskResumeAll+0x38> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a0be8: e7ff         	b	0x700a0bea <xTaskResumeAll+0x3a> @ imm = #-0x2
700a0bea: f644 7068    	movw	r0, #0x4f68
700a0bee: f2c7 0008    	movt	r0, #0x7008
700a0bf2: 6800         	ldr	r0, [r0]
700a0bf4: b3e0         	cbz	r0, 0x700a0c70 <xTaskResumeAll+0xc0> @ imm = #0x78
700a0bf6: e7ff         	b	0x700a0bf8 <xTaskResumeAll+0x48> @ imm = #-0x2
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a0bf8: f644 7068    	movw	r0, #0x4f68
700a0bfc: f2c7 0008    	movt	r0, #0x7008
700a0c00: 68c0         	ldr	r0, [r0, #0xc]
700a0c02: 68c0         	ldr	r0, [r0, #0xc]
700a0c04: 9003         	str	r0, [sp, #0xc]
;           (void)uxListRemove(&(pxTCB->xEventListItem));
700a0c06: 9803         	ldr	r0, [sp, #0xc]
700a0c08: 3018         	adds	r0, #0x18
700a0c0a: f00a fc91    	bl	0x700ab530 <uxListRemove> @ imm = #0xa922
;           (void)uxListRemove(&(pxTCB->xStateListItem));
700a0c0e: 9803         	ldr	r0, [sp, #0xc]
700a0c10: 3004         	adds	r0, #0x4
700a0c12: f00a fc8d    	bl	0x700ab530 <uxListRemove> @ imm = #0xa91a
;           prvAddTaskToReadyList(pxTCB);
700a0c16: 9803         	ldr	r0, [sp, #0xc]
700a0c18: 6ac1         	ldr	r1, [r0, #0x2c]
700a0c1a: 2001         	movs	r0, #0x1
700a0c1c: fa00 f201    	lsl.w	r2, r0, r1
700a0c20: f240 5108    	movw	r1, #0x508
700a0c24: f2c7 010b    	movt	r1, #0x700b
700a0c28: 6808         	ldr	r0, [r1]
700a0c2a: 4310         	orrs	r0, r2
700a0c2c: 6008         	str	r0, [r1]
700a0c2e: 9903         	ldr	r1, [sp, #0xc]
700a0c30: 6ac8         	ldr	r0, [r1, #0x2c]
700a0c32: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a0c36: f244 40f8    	movw	r0, #0x44f8
700a0c3a: f2c7 0008    	movt	r0, #0x7008
700a0c3e: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a0c42: 3104         	adds	r1, #0x4
700a0c44: f00b fa2c    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #0xb458
;           if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a0c48: 9803         	ldr	r0, [sp, #0xc]
700a0c4a: 6ac0         	ldr	r0, [r0, #0x2c]
700a0c4c: f240 41dc    	movw	r1, #0x4dc
700a0c50: f2c7 010b    	movt	r1, #0x700b
700a0c54: 6809         	ldr	r1, [r1]
700a0c56: 6ac9         	ldr	r1, [r1, #0x2c]
700a0c58: 4288         	cmp	r0, r1
700a0c5a: d307         	blo	0x700a0c6c <xTaskResumeAll+0xbc> @ imm = #0xe
700a0c5c: e7ff         	b	0x700a0c5e <xTaskResumeAll+0xae> @ imm = #-0x2
;             xYieldPending = pdTRUE;
700a0c5e: f240 512c    	movw	r1, #0x52c
700a0c62: f2c7 010b    	movt	r1, #0x700b
700a0c66: 2001         	movs	r0, #0x1
700a0c68: 6008         	str	r0, [r1]
;           } else {
700a0c6a: e000         	b	0x700a0c6e <xTaskResumeAll+0xbe> @ imm = #0x0
700a0c6c: e7ff         	b	0x700a0c6e <xTaskResumeAll+0xbe> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a0c6e: e7bc         	b	0x700a0bea <xTaskResumeAll+0x3a> @ imm = #-0x88
;         if (pxTCB != NULL) {
700a0c70: 9803         	ldr	r0, [sp, #0xc]
700a0c72: b118         	cbz	r0, 0x700a0c7c <xTaskResumeAll+0xcc> @ imm = #0x6
700a0c74: e7ff         	b	0x700a0c76 <xTaskResumeAll+0xc6> @ imm = #-0x2
;           prvResetNextTaskUnblockTime();
700a0c76: f00b f9b3    	bl	0x700abfe0 <prvResetNextTaskUnblockTime> @ imm = #0xb366
;         }
700a0c7a: e7ff         	b	0x700a0c7c <xTaskResumeAll+0xcc> @ imm = #-0x2
;           TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
700a0c7c: f240 5018    	movw	r0, #0x518
700a0c80: f2c7 000b    	movt	r0, #0x700b
700a0c84: 6800         	ldr	r0, [r0]
700a0c86: 9001         	str	r0, [sp, #0x4]
;           if (xPendedCounts > (TickType_t)0U) {
700a0c88: 9801         	ldr	r0, [sp, #0x4]
700a0c8a: b1e0         	cbz	r0, 0x700a0cc6 <xTaskResumeAll+0x116> @ imm = #0x38
700a0c8c: e7ff         	b	0x700a0c8e <xTaskResumeAll+0xde> @ imm = #-0x2
;             do {
700a0c8e: e7ff         	b	0x700a0c90 <xTaskResumeAll+0xe0> @ imm = #-0x2
;               if (xTaskIncrementTick() != pdFALSE) {
700a0c90: f7ff f836    	bl	0x7009fd00 <xTaskIncrementTick> @ imm = #-0xf94
700a0c94: b138         	cbz	r0, 0x700a0ca6 <xTaskResumeAll+0xf6> @ imm = #0xe
700a0c96: e7ff         	b	0x700a0c98 <xTaskResumeAll+0xe8> @ imm = #-0x2
;                 xYieldPending = pdTRUE;
700a0c98: f240 512c    	movw	r1, #0x52c
700a0c9c: f2c7 010b    	movt	r1, #0x700b
700a0ca0: 2001         	movs	r0, #0x1
700a0ca2: 6008         	str	r0, [r1]
;               } else {
700a0ca4: e000         	b	0x700a0ca8 <xTaskResumeAll+0xf8> @ imm = #0x0
700a0ca6: e7ff         	b	0x700a0ca8 <xTaskResumeAll+0xf8> @ imm = #-0x2
;               --xPendedCounts;
700a0ca8: 9801         	ldr	r0, [sp, #0x4]
700a0caa: 3801         	subs	r0, #0x1
700a0cac: 9001         	str	r0, [sp, #0x4]
;             } while (xPendedCounts > (TickType_t)0U);
700a0cae: e7ff         	b	0x700a0cb0 <xTaskResumeAll+0x100> @ imm = #-0x2
700a0cb0: 9801         	ldr	r0, [sp, #0x4]
700a0cb2: 2800         	cmp	r0, #0x0
700a0cb4: d1ec         	bne	0x700a0c90 <xTaskResumeAll+0xe0> @ imm = #-0x28
700a0cb6: e7ff         	b	0x700a0cb8 <xTaskResumeAll+0x108> @ imm = #-0x2
;             xPendedTicks = 0;
700a0cb8: f240 5118    	movw	r1, #0x518
700a0cbc: f2c7 010b    	movt	r1, #0x700b
700a0cc0: 2000         	movs	r0, #0x0
700a0cc2: 6008         	str	r0, [r1]
;           } else {
700a0cc4: e000         	b	0x700a0cc8 <xTaskResumeAll+0x118> @ imm = #0x0
700a0cc6: e7ff         	b	0x700a0cc8 <xTaskResumeAll+0x118> @ imm = #-0x2
;         if (xYieldPending != pdFALSE) {
700a0cc8: f240 502c    	movw	r0, #0x52c
700a0ccc: f2c7 000b    	movt	r0, #0x700b
700a0cd0: 6800         	ldr	r0, [r0]
700a0cd2: b120         	cbz	r0, 0x700a0cde <xTaskResumeAll+0x12e> @ imm = #0x8
700a0cd4: e7ff         	b	0x700a0cd6 <xTaskResumeAll+0x126> @ imm = #-0x2
700a0cd6: 2001         	movs	r0, #0x1
;             xAlreadyYielded = pdTRUE;
700a0cd8: 9002         	str	r0, [sp, #0x8]
;           taskYIELD_IF_USING_PREEMPTION();
700a0cda: df00         	svc	#0x0
;         } else {
700a0cdc: e000         	b	0x700a0ce0 <xTaskResumeAll+0x130> @ imm = #0x0
700a0cde: e7ff         	b	0x700a0ce0 <xTaskResumeAll+0x130> @ imm = #-0x2
;       }
700a0ce0: e7ff         	b	0x700a0ce2 <xTaskResumeAll+0x132> @ imm = #-0x2
;     } else {
700a0ce2: e000         	b	0x700a0ce6 <xTaskResumeAll+0x136> @ imm = #0x0
700a0ce4: e7ff         	b	0x700a0ce6 <xTaskResumeAll+0x136> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a0ce6: f00a fd13    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xaa26
;   return xAlreadyYielded;
700a0cea: 9802         	ldr	r0, [sp, #0x8]
700a0cec: b004         	add	sp, #0x10
700a0cee: bd80         	pop	{r7, pc}

700a0cf0 <UART_procLineStatusErr>:
; {
700a0cf0: b580         	push	{r7, lr}
700a0cf2: b086         	sub	sp, #0x18
700a0cf4: 9005         	str	r0, [sp, #0x14]
700a0cf6: 2000         	movs	r0, #0x0
;     int32_t            status = UART_STATUS_SUCCESS;
700a0cf8: 9004         	str	r0, [sp, #0x10]
;     uint32_t           lineStatus, iteration = 0U;
700a0cfa: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == hUart)
700a0cfc: 9805         	ldr	r0, [sp, #0x14]
700a0cfe: b920         	cbnz	r0, 0x700a0d0a <UART_procLineStatusErr+0x1a> @ imm = #0x8
700a0d00: e7ff         	b	0x700a0d02 <UART_procLineStatusErr+0x12> @ imm = #-0x2
700a0d02: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a0d06: 9004         	str	r0, [sp, #0x10]
;     }
700a0d08: e7ff         	b	0x700a0d0a <UART_procLineStatusErr+0x1a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a0d0a: 9804         	ldr	r0, [sp, #0x10]
700a0d0c: 2800         	cmp	r0, #0x0
700a0d0e: f040 808b    	bne.w	0x700a0e28 <UART_procLineStatusErr+0x138> @ imm = #0x116
700a0d12: e7ff         	b	0x700a0d14 <UART_procLineStatusErr+0x24> @ imm = #-0x2
;         lineStatus = UART_readLineStatus(hUart->baseAddr);
700a0d14: 9805         	ldr	r0, [sp, #0x14]
700a0d16: 6800         	ldr	r0, [r0]
700a0d18: f00a fcd2    	bl	0x700ab6c0 <UART_readLineStatus> @ imm = #0xa9a4
700a0d1c: 9003         	str	r0, [sp, #0xc]
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a0d1e: 9803         	ldr	r0, [sp, #0xc]
700a0d20: f000 0080    	and	r0, r0, #0x80
;                 || ((lineStatus & UART_OVERRUN_ERROR) == UART_OVERRUN_ERROR))
700a0d24: 2880         	cmp	r0, #0x80
700a0d26: d006         	beq	0x700a0d36 <UART_procLineStatusErr+0x46> @ imm = #0xc
700a0d28: e7ff         	b	0x700a0d2a <UART_procLineStatusErr+0x3a> @ imm = #-0x2
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a0d2a: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a0d2e: 0780         	lsls	r0, r0, #0x1e
700a0d30: 2800         	cmp	r0, #0x0
700a0d32: d578         	bpl	0x700a0e26 <UART_procLineStatusErr+0x136> @ imm = #0xf0
700a0d34: e7ff         	b	0x700a0d36 <UART_procLineStatusErr+0x46> @ imm = #-0x2
;             if (hUart->readTrans.buf != NULL)
700a0d36: 9805         	ldr	r0, [sp, #0x14]
700a0d38: 6a80         	ldr	r0, [r0, #0x28]
700a0d3a: b120         	cbz	r0, 0x700a0d46 <UART_procLineStatusErr+0x56> @ imm = #0x8
700a0d3c: e7ff         	b	0x700a0d3e <UART_procLineStatusErr+0x4e> @ imm = #-0x2
;                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
700a0d3e: 9905         	ldr	r1, [sp, #0x14]
700a0d40: 6988         	ldr	r0, [r1, #0x18]
700a0d42: 62c8         	str	r0, [r1, #0x2c]
;             }
700a0d44: e7ff         	b	0x700a0d46 <UART_procLineStatusErr+0x56> @ imm = #-0x2
700a0d46: 2040         	movs	r0, #0x40
;             iteration = UART_FIFO_SIZE;
700a0d48: 9002         	str	r0, [sp, #0x8]
;             do
700a0d4a: e7ff         	b	0x700a0d4c <UART_procLineStatusErr+0x5c> @ imm = #-0x2
;                 (void)UART_fifoCharGet(hUart->baseAddr);
700a0d4c: 9805         	ldr	r0, [sp, #0x14]
700a0d4e: 6800         	ldr	r0, [r0]
700a0d50: f00c fb26    	bl	0x700ad3a0 <UART_fifoCharGet> @ imm = #0xc64c
;                 iteration--;
700a0d54: 9802         	ldr	r0, [sp, #0x8]
700a0d56: 3801         	subs	r0, #0x1
700a0d58: 9002         	str	r0, [sp, #0x8]
;                 lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a0d5a: 9805         	ldr	r0, [sp, #0x14]
700a0d5c: 6800         	ldr	r0, [r0]
700a0d5e: f00a fcaf    	bl	0x700ab6c0 <UART_readLineStatus> @ imm = #0xa95e
700a0d62: 9003         	str	r0, [sp, #0xc]
;                 lineStatus &= (UART_LSR_RX_FIFO_STS_MASK |
700a0d64: 9803         	ldr	r0, [sp, #0xc]
700a0d66: f000 009f    	and	r0, r0, #0x9f
700a0d6a: 9003         	str	r0, [sp, #0xc]
;             }
700a0d6c: e7ff         	b	0x700a0d6e <UART_procLineStatusErr+0x7e> @ imm = #-0x2
;             while ((lineStatus != 0U) && (iteration != 0U));
700a0d6e: 9903         	ldr	r1, [sp, #0xc]
700a0d70: 2000         	movs	r0, #0x0
700a0d72: 9001         	str	r0, [sp, #0x4]
700a0d74: b131         	cbz	r1, 0x700a0d84 <UART_procLineStatusErr+0x94> @ imm = #0xc
700a0d76: e7ff         	b	0x700a0d78 <UART_procLineStatusErr+0x88> @ imm = #-0x2
700a0d78: 9802         	ldr	r0, [sp, #0x8]
700a0d7a: 2800         	cmp	r0, #0x0
700a0d7c: bf18         	it	ne
700a0d7e: 2001         	movne	r0, #0x1
700a0d80: 9001         	str	r0, [sp, #0x4]
700a0d82: e7ff         	b	0x700a0d84 <UART_procLineStatusErr+0x94> @ imm = #-0x2
700a0d84: 9801         	ldr	r0, [sp, #0x4]
;             }
700a0d86: 07c0         	lsls	r0, r0, #0x1f
700a0d88: 2800         	cmp	r0, #0x0
700a0d8a: d1df         	bne	0x700a0d4c <UART_procLineStatusErr+0x5c> @ imm = #-0x42
700a0d8c: e7ff         	b	0x700a0d8e <UART_procLineStatusErr+0x9e> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a0d8e: 9805         	ldr	r0, [sp, #0x14]
700a0d90: 6800         	ldr	r0, [r0]
700a0d92: 2105         	movs	r1, #0x5
700a0d94: f003 fbbc    	bl	0x700a4510 <UART_intrDisable> @ imm = #0x3778
;             hUart->readBuf = (void *)((uint8_t *)hUart->readBuf - hUart->readCount);
700a0d98: 9905         	ldr	r1, [sp, #0x14]
700a0d9a: 6948         	ldr	r0, [r1, #0x14]
700a0d9c: 698a         	ldr	r2, [r1, #0x18]
700a0d9e: 1a80         	subs	r0, r0, r2
700a0da0: 6148         	str	r0, [r1, #0x14]
;             if (hUart->readTrans.buf != NULL)
700a0da2: 9805         	ldr	r0, [sp, #0x14]
700a0da4: 6a80         	ldr	r0, [r0, #0x28]
700a0da6: b3a8         	cbz	r0, 0x700a0e14 <UART_procLineStatusErr+0x124> @ imm = #0x6a
700a0da8: e7ff         	b	0x700a0daa <UART_procLineStatusErr+0xba> @ imm = #-0x2
;                 if ((lineStatus & UART_BREAK_DETECTED_ERROR) != 0U)
700a0daa: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a0dae: 06c0         	lsls	r0, r0, #0x1b
700a0db0: 2800         	cmp	r0, #0x0
700a0db2: d508         	bpl	0x700a0dc6 <UART_procLineStatusErr+0xd6> @ imm = #0x10
700a0db4: e7ff         	b	0x700a0db6 <UART_procLineStatusErr+0xc6> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_BI;
700a0db6: 9905         	ldr	r1, [sp, #0x14]
700a0db8: 2002         	movs	r0, #0x2
700a0dba: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a0dbc: 9905         	ldr	r1, [sp, #0x14]
700a0dbe: 6a48         	ldr	r0, [r1, #0x24]
700a0dc0: 3001         	adds	r0, #0x1
700a0dc2: 6248         	str	r0, [r1, #0x24]
;                 }
700a0dc4: e025         	b	0x700a0e12 <UART_procLineStatusErr+0x122> @ imm = #0x4a
;                 else if ((lineStatus & UART_FRAMING_ERROR) != 0U)
700a0dc6: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a0dca: 0700         	lsls	r0, r0, #0x1c
700a0dcc: 2800         	cmp	r0, #0x0
700a0dce: d508         	bpl	0x700a0de2 <UART_procLineStatusErr+0xf2> @ imm = #0x10
700a0dd0: e7ff         	b	0x700a0dd2 <UART_procLineStatusErr+0xe2> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_FE;
700a0dd2: 9905         	ldr	r1, [sp, #0x14]
700a0dd4: 2003         	movs	r0, #0x3
700a0dd6: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a0dd8: 9905         	ldr	r1, [sp, #0x14]
700a0dda: 6a48         	ldr	r0, [r1, #0x24]
700a0ddc: 3001         	adds	r0, #0x1
700a0dde: 6248         	str	r0, [r1, #0x24]
;                 }
700a0de0: e016         	b	0x700a0e10 <UART_procLineStatusErr+0x120> @ imm = #0x2c
;                 else if ((lineStatus & UART_PARITY_ERROR) != 0U)
700a0de2: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a0de6: 0740         	lsls	r0, r0, #0x1d
700a0de8: 2800         	cmp	r0, #0x0
700a0dea: d508         	bpl	0x700a0dfe <UART_procLineStatusErr+0x10e> @ imm = #0x10
700a0dec: e7ff         	b	0x700a0dee <UART_procLineStatusErr+0xfe> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_PE;
700a0dee: 9905         	ldr	r1, [sp, #0x14]
700a0df0: 2004         	movs	r0, #0x4
700a0df2: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a0df4: 9905         	ldr	r1, [sp, #0x14]
700a0df6: 6a48         	ldr	r0, [r1, #0x24]
700a0df8: 3001         	adds	r0, #0x1
700a0dfa: 6248         	str	r0, [r1, #0x24]
;                 }
700a0dfc: e007         	b	0x700a0e0e <UART_procLineStatusErr+0x11e> @ imm = #0xe
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OE;
700a0dfe: 9905         	ldr	r1, [sp, #0x14]
700a0e00: 2005         	movs	r0, #0x5
700a0e02: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a0e04: 9905         	ldr	r1, [sp, #0x14]
700a0e06: 6a48         	ldr	r0, [r1, #0x24]
700a0e08: 3001         	adds	r0, #0x1
700a0e0a: 6248         	str	r0, [r1, #0x24]
700a0e0c: e7ff         	b	0x700a0e0e <UART_procLineStatusErr+0x11e> @ imm = #-0x2
700a0e0e: e7ff         	b	0x700a0e10 <UART_procLineStatusErr+0x120> @ imm = #-0x2
700a0e10: e7ff         	b	0x700a0e12 <UART_procLineStatusErr+0x122> @ imm = #-0x2
;             }
700a0e12: e7ff         	b	0x700a0e14 <UART_procLineStatusErr+0x124> @ imm = #-0x2
;             hUart->hUartInit->errorCallbackFxn(hUart);
700a0e14: 9805         	ldr	r0, [sp, #0x14]
700a0e16: 6841         	ldr	r1, [r0, #0x4]
700a0e18: 6e49         	ldr	r1, [r1, #0x64]
700a0e1a: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a0e1c: 9805         	ldr	r0, [sp, #0x14]
700a0e1e: 3028         	adds	r0, #0x28
700a0e20: f00c f9fe    	bl	0x700ad220 <UART_lld_Transaction_deInit> @ imm = #0xc3fc
;         }
700a0e24: e7ff         	b	0x700a0e26 <UART_procLineStatusErr+0x136> @ imm = #-0x2
;     }
700a0e26: e7ff         	b	0x700a0e28 <UART_procLineStatusErr+0x138> @ imm = #-0x2
;     return status;
700a0e28: 9804         	ldr	r0, [sp, #0x10]
700a0e2a: b006         	add	sp, #0x18
700a0e2c: bd80         	pop	{r7, pc}
700a0e2e: 0000         	movs	r0, r0

700a0e30 <prvProcessReceivedCommands>:
;     {
700a0e30: b580         	push	{r7, lr}
700a0e32: b08c         	sub	sp, #0x30
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a0e34: e7ff         	b	0x700a0e36 <prvProcessReceivedCommands+0x6> @ imm = #-0x2
700a0e36: f240 5024    	movw	r0, #0x524
700a0e3a: f2c7 000b    	movt	r0, #0x700b
700a0e3e: 6800         	ldr	r0, [r0]
700a0e40: a908         	add	r1, sp, #0x20
700a0e42: 2200         	movs	r2, #0x0
700a0e44: f000 fd6c    	bl	0x700a1920 <xQueueReceive> @ imm = #0xad8
700a0e48: 2800         	cmp	r0, #0x0
700a0e4a: f000 808c    	beq.w	0x700a0f66 <prvProcessReceivedCommands+0x136> @ imm = #0x118
700a0e4e: e7ff         	b	0x700a0e50 <prvProcessReceivedCommands+0x20> @ imm = #-0x2
;                     if( xMessage.xMessageID < ( BaseType_t ) 0 )
700a0e50: 9808         	ldr	r0, [sp, #0x20]
700a0e52: f1b0 3fff    	cmp.w	r0, #0xffffffff
700a0e56: dc09         	bgt	0x700a0e6c <prvProcessReceivedCommands+0x3c> @ imm = #0x12
700a0e58: e7ff         	b	0x700a0e5a <prvProcessReceivedCommands+0x2a> @ imm = #-0x2
700a0e5a: a808         	add	r0, sp, #0x20
;                         const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
700a0e5c: 3004         	adds	r0, #0x4
700a0e5e: 9003         	str	r0, [sp, #0xc]
;                         pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
700a0e60: 9903         	ldr	r1, [sp, #0xc]
700a0e62: 680a         	ldr	r2, [r1]
700a0e64: 6848         	ldr	r0, [r1, #0x4]
700a0e66: 6889         	ldr	r1, [r1, #0x8]
700a0e68: 4790         	blx	r2
;                     }
700a0e6a: e000         	b	0x700a0e6e <prvProcessReceivedCommands+0x3e> @ imm = #0x0
700a0e6c: e7ff         	b	0x700a0e6e <prvProcessReceivedCommands+0x3e> @ imm = #-0x2
;             if( xMessage.xMessageID >= ( BaseType_t ) 0 )
700a0e6e: 9808         	ldr	r0, [sp, #0x20]
700a0e70: 2800         	cmp	r0, #0x0
700a0e72: f100 8077    	bmi.w	0x700a0f64 <prvProcessReceivedCommands+0x134> @ imm = #0xee
700a0e76: e7ff         	b	0x700a0e78 <prvProcessReceivedCommands+0x48> @ imm = #-0x2
;                 pxTimer = xMessage.u.xTimerParameters.pxTimer;
700a0e78: 980a         	ldr	r0, [sp, #0x28]
700a0e7a: 9007         	str	r0, [sp, #0x1c]
;                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
700a0e7c: 9807         	ldr	r0, [sp, #0x1c]
700a0e7e: 6940         	ldr	r0, [r0, #0x14]
700a0e80: b128         	cbz	r0, 0x700a0e8e <prvProcessReceivedCommands+0x5e> @ imm = #0xa
700a0e82: e7ff         	b	0x700a0e84 <prvProcessReceivedCommands+0x54> @ imm = #-0x2
;                     ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a0e84: 9807         	ldr	r0, [sp, #0x1c]
700a0e86: 3004         	adds	r0, #0x4
700a0e88: f00a fb52    	bl	0x700ab530 <uxListRemove> @ imm = #0xa6a4
;                 }
700a0e8c: e000         	b	0x700a0e90 <prvProcessReceivedCommands+0x60> @ imm = #0x0
700a0e8e: e7ff         	b	0x700a0e90 <prvProcessReceivedCommands+0x60> @ imm = #-0x2
700a0e90: a806         	add	r0, sp, #0x18
;                 xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700a0e92: f00a fcb5    	bl	0x700ab800 <prvSampleTimeNow> @ imm = #0xa96a
700a0e96: 9004         	str	r0, [sp, #0x10]
;                 switch( xMessage.xMessageID )
700a0e98: 9808         	ldr	r0, [sp, #0x20]
700a0e9a: 9002         	str	r0, [sp, #0x8]
700a0e9c: 2809         	cmp	r0, #0x9
700a0e9e: d85f         	bhi	0x700a0f60 <prvProcessReceivedCommands+0x130> @ imm = #0xbe
700a0ea0: 9902         	ldr	r1, [sp, #0x8]
700a0ea2: e8df f001    	tbb	[pc, r1]
700a0ea6: 05 05 05 2f  	.word	0x2f050505
700a0eaa: 37 49 05 05  	.word	0x05054937
700a0eae: 2f 37        	.short	0x372f
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a0eb0: 9907         	ldr	r1, [sp, #0x1c]
700a0eb2: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a0eb6: f040 0001    	orr	r0, r0, #0x1
700a0eba: f881 0028    	strb.w	r0, [r1, #0x28]
;                         if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
700a0ebe: 9807         	ldr	r0, [sp, #0x1c]
700a0ec0: 9b09         	ldr	r3, [sp, #0x24]
700a0ec2: 6981         	ldr	r1, [r0, #0x18]
700a0ec4: 4419         	add	r1, r3
700a0ec6: 9a04         	ldr	r2, [sp, #0x10]
700a0ec8: f007 faf2    	bl	0x700a84b0 <prvInsertTimerInActiveList> @ imm = #0x75e4
700a0ecc: b1c0         	cbz	r0, 0x700a0f00 <prvProcessReceivedCommands+0xd0> @ imm = #0x30
700a0ece: e7ff         	b	0x700a0ed0 <prvProcessReceivedCommands+0xa0> @ imm = #-0x2
;                             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a0ed0: 9807         	ldr	r0, [sp, #0x1c]
700a0ed2: 6a01         	ldr	r1, [r0, #0x20]
700a0ed4: 4788         	blx	r1
;                             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a0ed6: 9807         	ldr	r0, [sp, #0x1c]
700a0ed8: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a0edc: 0740         	lsls	r0, r0, #0x1d
700a0ede: 2800         	cmp	r0, #0x0
700a0ee0: d50c         	bpl	0x700a0efc <prvProcessReceivedCommands+0xcc> @ imm = #0x18
700a0ee2: e7ff         	b	0x700a0ee4 <prvProcessReceivedCommands+0xb4> @ imm = #-0x2
;                                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
700a0ee4: 9807         	ldr	r0, [sp, #0x1c]
700a0ee6: 9909         	ldr	r1, [sp, #0x24]
700a0ee8: 6982         	ldr	r2, [r0, #0x18]
700a0eea: 440a         	add	r2, r1
700a0eec: 4669         	mov	r1, sp
700a0eee: 2300         	movs	r3, #0x0
700a0ef0: 600b         	str	r3, [r1]
700a0ef2: 4619         	mov	r1, r3
700a0ef4: f006 fdac    	bl	0x700a7a50 <xTimerGenericCommand> @ imm = #0x6b58
700a0ef8: 9005         	str	r0, [sp, #0x14]
;                             }
700a0efa: e000         	b	0x700a0efe <prvProcessReceivedCommands+0xce> @ imm = #0x0
700a0efc: e7ff         	b	0x700a0efe <prvProcessReceivedCommands+0xce> @ imm = #-0x2
;                         }
700a0efe: e000         	b	0x700a0f02 <prvProcessReceivedCommands+0xd2> @ imm = #0x0
700a0f00: e7ff         	b	0x700a0f02 <prvProcessReceivedCommands+0xd2> @ imm = #-0x2
;                         break;
700a0f02: e02e         	b	0x700a0f62 <prvProcessReceivedCommands+0x132> @ imm = #0x5c
;                         pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a0f04: 9907         	ldr	r1, [sp, #0x1c]
700a0f06: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a0f0a: f000 00fe    	and	r0, r0, #0xfe
700a0f0e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         break;
700a0f12: e026         	b	0x700a0f62 <prvProcessReceivedCommands+0x132> @ imm = #0x4c
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a0f14: 9907         	ldr	r1, [sp, #0x1c]
700a0f16: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a0f1a: f040 0001    	orr	r0, r0, #0x1
700a0f1e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
700a0f22: 9809         	ldr	r0, [sp, #0x24]
700a0f24: 9907         	ldr	r1, [sp, #0x1c]
700a0f26: 6188         	str	r0, [r1, #0x18]
;                         ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
700a0f28: 9807         	ldr	r0, [sp, #0x1c]
700a0f2a: 9b04         	ldr	r3, [sp, #0x10]
700a0f2c: 6981         	ldr	r1, [r0, #0x18]
700a0f2e: 4419         	add	r1, r3
700a0f30: 461a         	mov	r2, r3
700a0f32: f007 fabd    	bl	0x700a84b0 <prvInsertTimerInActiveList> @ imm = #0x757a
;                         break;
700a0f36: e014         	b	0x700a0f62 <prvProcessReceivedCommands+0x132> @ imm = #0x28
;                                 if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
700a0f38: 9807         	ldr	r0, [sp, #0x1c]
700a0f3a: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a0f3e: 0780         	lsls	r0, r0, #0x1e
700a0f40: 2800         	cmp	r0, #0x0
700a0f42: d404         	bmi	0x700a0f4e <prvProcessReceivedCommands+0x11e> @ imm = #0x8
700a0f44: e7ff         	b	0x700a0f46 <prvProcessReceivedCommands+0x116> @ imm = #-0x2
;                                     vPortFree( pxTimer );
700a0f46: 9807         	ldr	r0, [sp, #0x1c]
700a0f48: f00c f90a    	bl	0x700ad160 <vPortFree>  @ imm = #0xc214
;                                 }
700a0f4c: e007         	b	0x700a0f5e <prvProcessReceivedCommands+0x12e> @ imm = #0xe
;                                     pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a0f4e: 9907         	ldr	r1, [sp, #0x1c]
700a0f50: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a0f54: f000 00fe    	and	r0, r0, #0xfe
700a0f58: f881 0028    	strb.w	r0, [r1, #0x28]
700a0f5c: e7ff         	b	0x700a0f5e <prvProcessReceivedCommands+0x12e> @ imm = #-0x2
;                         break;
700a0f5e: e000         	b	0x700a0f62 <prvProcessReceivedCommands+0x132> @ imm = #0x0
;                         break;
700a0f60: e7ff         	b	0x700a0f62 <prvProcessReceivedCommands+0x132> @ imm = #-0x2
;             }
700a0f62: e7ff         	b	0x700a0f64 <prvProcessReceivedCommands+0x134> @ imm = #-0x2
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a0f64: e767         	b	0x700a0e36 <prvProcessReceivedCommands+0x6> @ imm = #-0x132
;     }
700a0f66: b00c         	add	sp, #0x30
700a0f68: bd80         	pop	{r7, pc}
700a0f6a: 0000         	movs	r0, r0
700a0f6c: 0000         	movs	r0, r0
700a0f6e: 0000         	movs	r0, r0

700a0f70 <_ntoa_long_long>:
; {
700a0f70: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a0f74: b09e         	sub	sp, #0x78
700a0f76: 469e         	mov	lr, r3
700a0f78: 4614         	mov	r4, r2
700a0f7a: 460d         	mov	r5, r1
700a0f7c: 4606         	mov	r6, r0
700a0f7e: 9929         	ldr	r1, [sp, #0xa4]
700a0f80: 9828         	ldr	r0, [sp, #0xa0]
700a0f82: f8dd c094    	ldr.w	r12, [sp, #0x94]
700a0f86: 9b24         	ldr	r3, [sp, #0x90]
700a0f88: 9a2c         	ldr	r2, [sp, #0xb0]
700a0f8a: 9a2b         	ldr	r2, [sp, #0xac]
700a0f8c: 9a2a         	ldr	r2, [sp, #0xa8]
700a0f8e: 9a26         	ldr	r2, [sp, #0x98]
700a0f90: 961d         	str	r6, [sp, #0x74]
700a0f92: 951c         	str	r5, [sp, #0x70]
700a0f94: 941b         	str	r4, [sp, #0x6c]
700a0f96: f8cd e068    	str.w	lr, [sp, #0x68]
700a0f9a: f8cd c064    	str.w	r12, [sp, #0x64]
700a0f9e: 9318         	str	r3, [sp, #0x60]
700a0fa0: f88d 205f    	strb.w	r2, [sp, #0x5f]
700a0fa4: 9115         	str	r1, [sp, #0x54]
700a0fa6: 9014         	str	r0, [sp, #0x50]
700a0fa8: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a0faa: 900b         	str	r0, [sp, #0x2c]
;   if (!value) {
700a0fac: 9818         	ldr	r0, [sp, #0x60]
700a0fae: 9919         	ldr	r1, [sp, #0x64]
700a0fb0: 4308         	orrs	r0, r1
700a0fb2: b928         	cbnz	r0, 0x700a0fc0 <_ntoa_long_long+0x50> @ imm = #0xa
700a0fb4: e7ff         	b	0x700a0fb6 <_ntoa_long_long+0x46> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a0fb6: 982c         	ldr	r0, [sp, #0xb0]
700a0fb8: f020 0010    	bic	r0, r0, #0x10
700a0fbc: 902c         	str	r0, [sp, #0xb0]
;   }
700a0fbe: e7ff         	b	0x700a0fc0 <_ntoa_long_long+0x50> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a0fc0: f89d 00b1    	ldrb.w	r0, [sp, #0xb1]
700a0fc4: 0740         	lsls	r0, r0, #0x1d
700a0fc6: 2800         	cmp	r0, #0x0
700a0fc8: d506         	bpl	0x700a0fd8 <_ntoa_long_long+0x68> @ imm = #0xc
700a0fca: e7ff         	b	0x700a0fcc <_ntoa_long_long+0x5c> @ imm = #-0x2
700a0fcc: 9818         	ldr	r0, [sp, #0x60]
700a0fce: 9919         	ldr	r1, [sp, #0x64]
700a0fd0: 4308         	orrs	r0, r1
700a0fd2: 2800         	cmp	r0, #0x0
700a0fd4: d043         	beq	0x700a105e <_ntoa_long_long+0xee> @ imm = #0x86
700a0fd6: e7ff         	b	0x700a0fd8 <_ntoa_long_long+0x68> @ imm = #-0x2
;     do {
700a0fd8: e7ff         	b	0x700a0fda <_ntoa_long_long+0x6a> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a0fda: 9818         	ldr	r0, [sp, #0x60]
700a0fdc: 9919         	ldr	r1, [sp, #0x64]
700a0fde: 9a14         	ldr	r2, [sp, #0x50]
700a0fe0: 9b15         	ldr	r3, [sp, #0x54]
700a0fe2: f00b eff0    	blx	0x700acfc4 <__aeabi_uldivmod> @ imm = #0xbfe0
700a0fe6: f88d 202b    	strb.w	r2, [sp, #0x2b]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a0fea: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a0fee: 2809         	cmp	r0, #0x9
700a0ff0: dc05         	bgt	0x700a0ffe <_ntoa_long_long+0x8e> @ imm = #0xa
700a0ff2: e7ff         	b	0x700a0ff4 <_ntoa_long_long+0x84> @ imm = #-0x2
700a0ff4: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a0ff8: 3030         	adds	r0, #0x30
700a0ffa: 9009         	str	r0, [sp, #0x24]
700a0ffc: e00c         	b	0x700a1018 <_ntoa_long_long+0xa8> @ imm = #0x18
700a0ffe: f89d 00b0    	ldrb.w	r0, [sp, #0xb0]
700a1002: 0681         	lsls	r1, r0, #0x1a
700a1004: 2061         	movs	r0, #0x61
700a1006: 2900         	cmp	r1, #0x0
700a1008: bf48         	it	mi
700a100a: 2041         	movmi	r0, #0x41
700a100c: f89d 102b    	ldrb.w	r1, [sp, #0x2b]
700a1010: 4408         	add	r0, r1
700a1012: 380a         	subs	r0, #0xa
700a1014: 9009         	str	r0, [sp, #0x24]
700a1016: e7ff         	b	0x700a1018 <_ntoa_long_long+0xa8> @ imm = #-0x2
700a1018: 9809         	ldr	r0, [sp, #0x24]
700a101a: 9a0b         	ldr	r2, [sp, #0x2c]
700a101c: 1c51         	adds	r1, r2, #0x1
700a101e: 910b         	str	r1, [sp, #0x2c]
700a1020: a90c         	add	r1, sp, #0x30
700a1022: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a1024: 9a14         	ldr	r2, [sp, #0x50]
700a1026: 9b15         	ldr	r3, [sp, #0x54]
700a1028: 9818         	ldr	r0, [sp, #0x60]
700a102a: 9919         	ldr	r1, [sp, #0x64]
700a102c: f00b efca    	blx	0x700acfc4 <__aeabi_uldivmod> @ imm = #0xbf94
700a1030: 9119         	str	r1, [sp, #0x64]
700a1032: 9018         	str	r0, [sp, #0x60]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a1034: e7ff         	b	0x700a1036 <_ntoa_long_long+0xc6> @ imm = #-0x2
700a1036: 9818         	ldr	r0, [sp, #0x60]
700a1038: 9919         	ldr	r1, [sp, #0x64]
700a103a: 4301         	orrs	r1, r0
700a103c: 2000         	movs	r0, #0x0
700a103e: 9008         	str	r0, [sp, #0x20]
700a1040: b139         	cbz	r1, 0x700a1052 <_ntoa_long_long+0xe2> @ imm = #0xe
700a1042: e7ff         	b	0x700a1044 <_ntoa_long_long+0xd4> @ imm = #-0x2
700a1044: 990b         	ldr	r1, [sp, #0x2c]
700a1046: 2000         	movs	r0, #0x0
700a1048: 2920         	cmp	r1, #0x20
700a104a: bf38         	it	lo
700a104c: 2001         	movlo	r0, #0x1
700a104e: 9008         	str	r0, [sp, #0x20]
700a1050: e7ff         	b	0x700a1052 <_ntoa_long_long+0xe2> @ imm = #-0x2
700a1052: 9808         	ldr	r0, [sp, #0x20]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a1054: 07c0         	lsls	r0, r0, #0x1f
700a1056: 2800         	cmp	r0, #0x0
700a1058: d1bf         	bne	0x700a0fda <_ntoa_long_long+0x6a> @ imm = #-0x82
700a105a: e7ff         	b	0x700a105c <_ntoa_long_long+0xec> @ imm = #-0x2
;   }
700a105c: e7ff         	b	0x700a105e <_ntoa_long_long+0xee> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a105e: 981d         	ldr	r0, [sp, #0x74]
700a1060: 991c         	ldr	r1, [sp, #0x70]
700a1062: 9a1b         	ldr	r2, [sp, #0x6c]
700a1064: 9b1a         	ldr	r3, [sp, #0x68]
700a1066: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a106a: 9d14         	ldr	r5, [sp, #0x50]
700a106c: 9e2a         	ldr	r6, [sp, #0xa8]
700a106e: 9f2b         	ldr	r7, [sp, #0xac]
700a1070: f8dd 80b0    	ldr.w	r8, [sp, #0xb0]
700a1074: f89d 405f    	ldrb.w	r4, [sp, #0x5f]
700a1078: 46ee         	mov	lr, sp
700a107a: f8ce 8018    	str.w	r8, [lr, #0x18]
700a107e: f8ce 7014    	str.w	r7, [lr, #0x14]
700a1082: f8ce 6010    	str.w	r6, [lr, #0x10]
700a1086: f8ce 500c    	str.w	r5, [lr, #0xc]
700a108a: f004 0401    	and	r4, r4, #0x1
700a108e: f8ce 4008    	str.w	r4, [lr, #0x8]
700a1092: f8ce c004    	str.w	r12, [lr, #0x4]
700a1096: f10d 0c30    	add.w	r12, sp, #0x30
700a109a: f8ce c000    	str.w	r12, [lr]
700a109e: f7fb ffcf    	bl	0x7009d040 <_ntoa_format> @ imm = #-0x4062
700a10a2: b01e         	add	sp, #0x78
700a10a4: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a10b0 <Sciclient_rmIrqVintDelete>:
; {
700a10b0: b580         	push	{r7, lr}
700a10b2: b08c         	sub	sp, #0x30
700a10b4: 900b         	str	r0, [sp, #0x2c]
700a10b6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a10b8: 900a         	str	r0, [sp, #0x28]
;     bool del_mapping = false;
700a10ba: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool del_whole_route = false;
700a10be: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a10c2: 9008         	str	r0, [sp, #0x20]
;     if (r == SystemP_SUCCESS) {
700a10c4: 980a         	ldr	r0, [sp, #0x28]
700a10c6: b948         	cbnz	r0, 0x700a10dc <Sciclient_rmIrqVintDelete+0x2c> @ imm = #0x12
700a10c8: e7ff         	b	0x700a10ca <Sciclient_rmIrqVintDelete+0x1a> @ imm = #-0x2
;         r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700a10ca: 990b         	ldr	r1, [sp, #0x2c]
700a10cc: 8a08         	ldrh	r0, [r1, #0x10]
700a10ce: 8a49         	ldrh	r1, [r1, #0x12]
700a10d0: f10d 0227    	add.w	r2, sp, #0x27
700a10d4: f008 fa04    	bl	0x700a94e0 <Sciclient_rmIaVintGetInfo> @ imm = #0x8408
700a10d8: 900a         	str	r0, [sp, #0x28]
;     }
700a10da: e7ff         	b	0x700a10dc <Sciclient_rmIrqVintDelete+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a10dc: 980a         	ldr	r0, [sp, #0x28]
700a10de: b9e8         	cbnz	r0, 0x700a111c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #0x3a
700a10e0: e7ff         	b	0x700a10e2 <Sciclient_rmIrqVintDelete+0x32> @ imm = #-0x2
;         if (num_evts == 0u) {
700a10e2: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a10e6: b920         	cbnz	r0, 0x700a10f2 <Sciclient_rmIrqVintDelete+0x42> @ imm = #0x8
700a10e8: e7ff         	b	0x700a10ea <Sciclient_rmIrqVintDelete+0x3a> @ imm = #-0x2
700a10ea: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a10ee: 900a         	str	r0, [sp, #0x28]
;         } else if ((num_evts > 1u) ||
700a10f0: e013         	b	0x700a111a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #0x26
700a10f2: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a10f6: 2801         	cmp	r0, #0x1
700a10f8: d806         	bhi	0x700a1108 <Sciclient_rmIrqVintDelete+0x58> @ imm = #0xc
700a10fa: e7ff         	b	0x700a10fc <Sciclient_rmIrqVintDelete+0x4c> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a10fc: 980b         	ldr	r0, [sp, #0x2c]
700a10fe: 6800         	ldr	r0, [r0]
700a1100: f008 fb76    	bl	0x700a97f0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x86ec
;         } else if ((num_evts > 1u) ||
700a1104: b120         	cbz	r0, 0x700a1110 <Sciclient_rmIrqVintDelete+0x60> @ imm = #0x8
700a1106: e7ff         	b	0x700a1108 <Sciclient_rmIrqVintDelete+0x58> @ imm = #-0x2
700a1108: 2001         	movs	r0, #0x1
;             del_mapping = true;
700a110a: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a110e: e003         	b	0x700a1118 <Sciclient_rmIrqVintDelete+0x68> @ imm = #0x6
700a1110: 2001         	movs	r0, #0x1
;             del_whole_route = true;
700a1112: f88d 0025    	strb.w	r0, [sp, #0x25]
700a1116: e7ff         	b	0x700a1118 <Sciclient_rmIrqVintDelete+0x68> @ imm = #-0x2
700a1118: e7ff         	b	0x700a111a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #-0x2
;     }
700a111a: e7ff         	b	0x700a111c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #-0x2
;     if (del_mapping == true) {
700a111c: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a1120: 07c0         	lsls	r0, r0, #0x1f
700a1122: 2800         	cmp	r0, #0x0
700a1124: d049         	beq	0x700a11ba <Sciclient_rmIrqVintDelete+0x10a> @ imm = #0x92
700a1126: e7ff         	b	0x700a1128 <Sciclient_rmIrqVintDelete+0x78> @ imm = #-0x2
700a1128: 203c         	movs	r0, #0x3c
700a112a: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a112e: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a1130: 980b         	ldr	r0, [sp, #0x2c]
700a1132: 7900         	ldrb	r0, [r0, #0x4]
700a1134: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a1138: 980b         	ldr	r0, [sp, #0x2c]
700a113a: 88c0         	ldrh	r0, [r0, #0x6]
700a113c: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a1140: 980b         	ldr	r0, [sp, #0x2c]
700a1142: 8900         	ldrh	r0, [r0, #0x8]
700a1144: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a1148: 980b         	ldr	r0, [sp, #0x2c]
700a114a: 8a00         	ldrh	r0, [r0, #0x10]
700a114c: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a1150: 980b         	ldr	r0, [sp, #0x2c]
700a1152: 8a40         	ldrh	r0, [r0, #0x12]
700a1154: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a1158: 980b         	ldr	r0, [sp, #0x2c]
700a115a: 89c0         	ldrh	r0, [r0, #0xe]
700a115c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a1160: 980b         	ldr	r0, [sp, #0x2c]
700a1162: 7d00         	ldrb	r0, [r0, #0x14]
700a1164: f88d 001e    	strb.w	r0, [sp, #0x1e]
700a1168: a801         	add	r0, sp, #0x4
700a116a: f04f 31ff    	mov.w	r1, #0xffffffff
;         r = Sciclient_rmIrqReleaseRaw(&req,
700a116e: f009 fc3f    	bl	0x700aa9f0 <Sciclient_rmIrqReleaseRaw> @ imm = #0x987e
700a1172: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a1174: 980a         	ldr	r0, [sp, #0x28]
700a1176: b9f8         	cbnz	r0, 0x700a11b8 <Sciclient_rmIrqVintDelete+0x108> @ imm = #0x3e
700a1178: e7ff         	b	0x700a117a <Sciclient_rmIrqVintDelete+0xca> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a117a: 980b         	ldr	r0, [sp, #0x2c]
700a117c: 8a00         	ldrh	r0, [r0, #0x10]
700a117e: f009 f967    	bl	0x700aa450 <Sciclient_rmIaGetInst> @ imm = #0x92ce
700a1182: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a1184: 9808         	ldr	r0, [sp, #0x20]
700a1186: b1b0         	cbz	r0, 0x700a11b6 <Sciclient_rmIrqVintDelete+0x106> @ imm = #0x2c
700a1188: e7ff         	b	0x700a118a <Sciclient_rmIrqVintDelete+0xda> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]--;
700a118a: 9808         	ldr	r0, [sp, #0x20]
700a118c: 6901         	ldr	r1, [r0, #0x10]
700a118e: 980b         	ldr	r0, [sp, #0x2c]
700a1190: 8a42         	ldrh	r2, [r0, #0x12]
700a1192: 5c88         	ldrb	r0, [r1, r2]
700a1194: 3801         	subs	r0, #0x1
700a1196: 5488         	strb	r0, [r1, r2]
;                 if (ia_inst->v0_b0_evt == cfg->global_evt - ia_inst->sevt_offset) {
700a1198: 9a08         	ldr	r2, [sp, #0x20]
700a119a: 8a90         	ldrh	r0, [r2, #0x14]
700a119c: 990b         	ldr	r1, [sp, #0x2c]
700a119e: 89c9         	ldrh	r1, [r1, #0xe]
700a11a0: 8912         	ldrh	r2, [r2, #0x8]
700a11a2: 1a89         	subs	r1, r1, r2
700a11a4: 4288         	cmp	r0, r1
700a11a6: d105         	bne	0x700a11b4 <Sciclient_rmIrqVintDelete+0x104> @ imm = #0xa
700a11a8: e7ff         	b	0x700a11aa <Sciclient_rmIrqVintDelete+0xfa> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
700a11aa: 9908         	ldr	r1, [sp, #0x20]
700a11ac: f64f 70ff    	movw	r0, #0xffff
700a11b0: 8288         	strh	r0, [r1, #0x14]
;                 }
700a11b2: e7ff         	b	0x700a11b4 <Sciclient_rmIrqVintDelete+0x104> @ imm = #-0x2
;             }
700a11b4: e7ff         	b	0x700a11b6 <Sciclient_rmIrqVintDelete+0x106> @ imm = #-0x2
;         }
700a11b6: e7ff         	b	0x700a11b8 <Sciclient_rmIrqVintDelete+0x108> @ imm = #-0x2
;     }
700a11b8: e7ff         	b	0x700a11ba <Sciclient_rmIrqVintDelete+0x10a> @ imm = #-0x2
;     if (del_whole_route == true) {
700a11ba: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a11be: 07c0         	lsls	r0, r0, #0x1f
700a11c0: b170         	cbz	r0, 0x700a11e0 <Sciclient_rmIrqVintDelete+0x130> @ imm = #0x1c
700a11c2: e7ff         	b	0x700a11c4 <Sciclient_rmIrqVintDelete+0x114> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700a11c4: 980b         	ldr	r0, [sp, #0x2c]
700a11c6: f7fa fb53    	bl	0x7009b870 <Sciclient_rmIrqGetRoute> @ imm = #-0x595a
700a11ca: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a11cc: 980a         	ldr	r0, [sp, #0x28]
700a11ce: b930         	cbnz	r0, 0x700a11de <Sciclient_rmIrqVintDelete+0x12e> @ imm = #0xc
700a11d0: e7ff         	b	0x700a11d2 <Sciclient_rmIrqVintDelete+0x122> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, true);
700a11d2: 980b         	ldr	r0, [sp, #0x2c]
700a11d4: 2101         	movs	r1, #0x1
700a11d6: f7fd fecb    	bl	0x7009ef70 <Sciclient_rmIrqDeleteRoute> @ imm = #-0x226a
700a11da: 900a         	str	r0, [sp, #0x28]
;         }
700a11dc: e7ff         	b	0x700a11de <Sciclient_rmIrqVintDelete+0x12e> @ imm = #-0x2
;     }
700a11de: e7ff         	b	0x700a11e0 <Sciclient_rmIrqVintDelete+0x130> @ imm = #-0x2
;     return r;
700a11e0: 980a         	ldr	r0, [sp, #0x28]
700a11e2: b00c         	add	sp, #0x30
700a11e4: bd80         	pop	{r7, pc}
		...
700a11ee: 0000         	movs	r0, r0

700a11f0 <UART_writePolling>:
; {
700a11f0: b580         	push	{r7, lr}
700a11f2: b08c         	sub	sp, #0x30
700a11f4: 900b         	str	r0, [sp, #0x2c]
700a11f6: 910a         	str	r1, [sp, #0x28]
700a11f8: 2000         	movs	r0, #0x0
;     int32_t             retVal          = UART_TRANSFER_STATUS_SUCCESS;
700a11fa: 9007         	str	r0, [sp, #0x1c]
;     uint32_t            timeoutElapsed  = FALSE;
700a11fc: 9006         	str	r0, [sp, #0x18]
;     uint32_t            baseAddr        = hUart->baseAddr;
700a11fe: 990b         	ldr	r1, [sp, #0x2c]
700a1200: 6809         	ldr	r1, [r1]
700a1202: 9105         	str	r1, [sp, #0x14]
;     uint32_t            lineStatus      = 0U;
700a1204: 9004         	str	r0, [sp, #0x10]
;     hUartInit = hUart->hUartInit;
700a1206: 980b         	ldr	r0, [sp, #0x2c]
700a1208: 6840         	ldr	r0, [r0, #0x4]
700a120a: 9003         	str	r0, [sp, #0xc]
;     hUart->writeSizeRemaining = trans->count;
700a120c: 980a         	ldr	r0, [sp, #0x28]
700a120e: 6840         	ldr	r0, [r0, #0x4]
700a1210: 990b         	ldr	r1, [sp, #0x2c]
700a1212: 6108         	str	r0, [r1, #0x10]
;     startTicks = hUartInit->clockP_get();
700a1214: 9803         	ldr	r0, [sp, #0xc]
700a1216: 6d40         	ldr	r0, [r0, #0x54]
700a1218: 4780         	blx	r0
700a121a: 9009         	str	r0, [sp, #0x24]
;     while ((FALSE == timeoutElapsed)
700a121c: e7ff         	b	0x700a121e <UART_writePolling+0x2e> @ imm = #-0x2
700a121e: 9906         	ldr	r1, [sp, #0x18]
700a1220: 2000         	movs	r0, #0x0
;            && (0U != hUart->writeSizeRemaining))
700a1222: 9002         	str	r0, [sp, #0x8]
700a1224: b939         	cbnz	r1, 0x700a1236 <UART_writePolling+0x46> @ imm = #0xe
700a1226: e7ff         	b	0x700a1228 <UART_writePolling+0x38> @ imm = #-0x2
700a1228: 980b         	ldr	r0, [sp, #0x2c]
700a122a: 6900         	ldr	r0, [r0, #0x10]
700a122c: 2800         	cmp	r0, #0x0
700a122e: bf18         	it	ne
700a1230: 2001         	movne	r0, #0x1
700a1232: 9002         	str	r0, [sp, #0x8]
700a1234: e7ff         	b	0x700a1236 <UART_writePolling+0x46> @ imm = #-0x2
700a1236: 9802         	ldr	r0, [sp, #0x8]
;     while ((FALSE == timeoutElapsed)
700a1238: 07c0         	lsls	r0, r0, #0x1f
700a123a: b198         	cbz	r0, 0x700a1264 <UART_writePolling+0x74> @ imm = #0x26
700a123c: e7ff         	b	0x700a123e <UART_writePolling+0x4e> @ imm = #-0x2
;         UART_writeDataPolling(hUart);
700a123e: 980b         	ldr	r0, [sp, #0x2c]
700a1240: f00a ffae    	bl	0x700ac1a0 <UART_writeDataPolling> @ imm = #0xaf5c
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700a1244: 9803         	ldr	r0, [sp, #0xc]
700a1246: 6d40         	ldr	r0, [r0, #0x54]
700a1248: 4780         	blx	r0
700a124a: 9909         	ldr	r1, [sp, #0x24]
700a124c: 1a40         	subs	r0, r0, r1
700a124e: 9008         	str	r0, [sp, #0x20]
;         if (elapsedTicks >= trans->timeout)
700a1250: 9808         	ldr	r0, [sp, #0x20]
700a1252: 990a         	ldr	r1, [sp, #0x28]
700a1254: 6889         	ldr	r1, [r1, #0x8]
700a1256: 4288         	cmp	r0, r1
700a1258: d303         	blo	0x700a1262 <UART_writePolling+0x72> @ imm = #0x6
700a125a: e7ff         	b	0x700a125c <UART_writePolling+0x6c> @ imm = #-0x2
700a125c: 2001         	movs	r0, #0x1
;             timeoutElapsed = TRUE;
700a125e: 9006         	str	r0, [sp, #0x18]
;         }
700a1260: e7ff         	b	0x700a1262 <UART_writePolling+0x72> @ imm = #-0x2
;     while ((FALSE == timeoutElapsed)
700a1262: e7dc         	b	0x700a121e <UART_writePolling+0x2e> @ imm = #-0x48
;     if (0U == hUart->writeSizeRemaining)
700a1264: 980b         	ldr	r0, [sp, #0x2c]
700a1266: 6900         	ldr	r0, [r0, #0x10]
700a1268: 2800         	cmp	r0, #0x0
700a126a: d149         	bne	0x700a1300 <UART_writePolling+0x110> @ imm = #0x92
700a126c: e7ff         	b	0x700a126e <UART_writePolling+0x7e> @ imm = #-0x2
;         do
700a126e: e7ff         	b	0x700a1270 <UART_writePolling+0x80> @ imm = #-0x2
;             lineStatus = UART_readLineStatus(baseAddr);
700a1270: 9805         	ldr	r0, [sp, #0x14]
700a1272: f00a fa25    	bl	0x700ab6c0 <UART_readLineStatus> @ imm = #0xa44a
700a1276: 9004         	str	r0, [sp, #0x10]
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700a1278: 9803         	ldr	r0, [sp, #0xc]
700a127a: 6d40         	ldr	r0, [r0, #0x54]
700a127c: 4780         	blx	r0
700a127e: 9909         	ldr	r1, [sp, #0x24]
700a1280: 1a40         	subs	r0, r0, r1
700a1282: 9008         	str	r0, [sp, #0x20]
;         }
700a1284: e7ff         	b	0x700a1286 <UART_writePolling+0x96> @ imm = #-0x2
;                (lineStatus & (uint32_t) (UART_LSR_TX_FIFO_E_MASK |
700a1286: 9804         	ldr	r0, [sp, #0x10]
700a1288: f000 0160    	and	r1, r0, #0x60
700a128c: 2000         	movs	r0, #0x0
;                 && (elapsedTicks < hUart->lineStatusTimeout));
700a128e: 2960         	cmp	r1, #0x60
700a1290: 9001         	str	r0, [sp, #0x4]
700a1292: d00d         	beq	0x700a12b0 <UART_writePolling+0xc0> @ imm = #0x1a
700a1294: e7ff         	b	0x700a1296 <UART_writePolling+0xa6> @ imm = #-0x2
700a1296: 9808         	ldr	r0, [sp, #0x20]
700a1298: 990b         	ldr	r1, [sp, #0x2c]
700a129a: 6e8a         	ldr	r2, [r1, #0x68]
700a129c: 6ec9         	ldr	r1, [r1, #0x6c]
700a129e: 1a80         	subs	r0, r0, r2
700a12a0: f04f 0000    	mov.w	r0, #0x0
700a12a4: eb70 0101    	sbcs.w	r1, r0, r1
700a12a8: bf38         	it	lo
700a12aa: 2001         	movlo	r0, #0x1
700a12ac: 9001         	str	r0, [sp, #0x4]
700a12ae: e7ff         	b	0x700a12b0 <UART_writePolling+0xc0> @ imm = #-0x2
700a12b0: 9801         	ldr	r0, [sp, #0x4]
;         }
700a12b2: 07c0         	lsls	r0, r0, #0x1f
700a12b4: 2800         	cmp	r0, #0x0
700a12b6: d1db         	bne	0x700a1270 <UART_writePolling+0x80> @ imm = #-0x4a
700a12b8: e7ff         	b	0x700a12ba <UART_writePolling+0xca> @ imm = #-0x2
;         if(elapsedTicks >= hUart->lineStatusTimeout)
700a12ba: 9808         	ldr	r0, [sp, #0x20]
700a12bc: 990b         	ldr	r1, [sp, #0x2c]
700a12be: 6e8a         	ldr	r2, [r1, #0x68]
700a12c0: 6ec9         	ldr	r1, [r1, #0x6c]
700a12c2: 1a80         	subs	r0, r0, r2
700a12c4: f04f 0000    	mov.w	r0, #0x0
700a12c8: 4188         	sbcs	r0, r1
700a12ca: d30f         	blo	0x700a12ec <UART_writePolling+0xfc> @ imm = #0x1e
700a12cc: e7ff         	b	0x700a12ce <UART_writePolling+0xde> @ imm = #-0x2
700a12ce: f06f 0001    	mvn	r0, #0x1
;             retVal             = UART_TRANSFER_TIMEOUT;
700a12d2: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a12d4: 990a         	ldr	r1, [sp, #0x28]
700a12d6: 2001         	movs	r0, #0x1
700a12d8: 60c8         	str	r0, [r1, #0xc]
;             trans->count       = hUart->writeCount;
700a12da: 980b         	ldr	r0, [sp, #0x2c]
700a12dc: 68c0         	ldr	r0, [r0, #0xc]
700a12de: 990a         	ldr	r1, [sp, #0x28]
700a12e0: 6048         	str	r0, [r1, #0x4]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a12e2: 980b         	ldr	r0, [sp, #0x2c]
700a12e4: 303c         	adds	r0, #0x3c
700a12e6: f00b ff9b    	bl	0x700ad220 <UART_lld_Transaction_deInit> @ imm = #0xbf36
;         }
700a12ea: e008         	b	0x700a12fe <UART_writePolling+0x10e> @ imm = #0x10
700a12ec: 2000         	movs	r0, #0x0
;             retVal             = UART_TRANSFER_STATUS_SUCCESS;
700a12ee: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_SUCCESS;
700a12f0: 990a         	ldr	r1, [sp, #0x28]
700a12f2: 60c8         	str	r0, [r1, #0xc]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a12f4: 980b         	ldr	r0, [sp, #0x2c]
700a12f6: 303c         	adds	r0, #0x3c
700a12f8: f00b ff92    	bl	0x700ad220 <UART_lld_Transaction_deInit> @ imm = #0xbf24
700a12fc: e7ff         	b	0x700a12fe <UART_writePolling+0x10e> @ imm = #-0x2
;     }
700a12fe: e00e         	b	0x700a131e <UART_writePolling+0x12e> @ imm = #0x1c
700a1300: f06f 0001    	mvn	r0, #0x1
;         retVal             = UART_TRANSFER_TIMEOUT;
700a1304: 9007         	str	r0, [sp, #0x1c]
;         trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a1306: 990a         	ldr	r1, [sp, #0x28]
700a1308: 2001         	movs	r0, #0x1
700a130a: 60c8         	str	r0, [r1, #0xc]
;         trans->count       = hUart->writeCount;
700a130c: 980b         	ldr	r0, [sp, #0x2c]
700a130e: 68c0         	ldr	r0, [r0, #0xc]
700a1310: 990a         	ldr	r1, [sp, #0x28]
700a1312: 6048         	str	r0, [r1, #0x4]
;         UART_lld_Transaction_deInit(&hUart->writeTrans);
700a1314: 980b         	ldr	r0, [sp, #0x2c]
700a1316: 303c         	adds	r0, #0x3c
700a1318: f00b ff82    	bl	0x700ad220 <UART_lld_Transaction_deInit> @ imm = #0xbf04
700a131c: e7ff         	b	0x700a131e <UART_writePolling+0x12e> @ imm = #-0x2
;     return (retVal);
700a131e: 9807         	ldr	r0, [sp, #0x1c]
700a1320: b00c         	add	sp, #0x30
700a1322: bd80         	pop	{r7, pc}
		...

700a1330 <Sciclient_recvMessage>:
; {
700a1330: b580         	push	{r7, lr}
700a1332: b08e         	sub	sp, #0x38
700a1334: 900d         	str	r0, [sp, #0x34]
700a1336: 910c         	str	r1, [sp, #0x30]
700a1338: 920b         	str	r2, [sp, #0x2c]
700a133a: 2000         	movs	r0, #0x0
;     uint8_t  trailBytes = 0U;
700a133c: f88d 0023    	strb.w	r0, [sp, #0x23]
;     numWords   = (uint32_t) (rxPayloadSize / 4U);
700a1340: 990b         	ldr	r1, [sp, #0x2c]
700a1342: ea4f 0191    	lsr.w	r1, r1, #0x2
700a1346: 910a         	str	r1, [sp, #0x28]
;     trailBytes = (uint8_t) (rxPayloadSize - (numWords * 4U));
700a1348: 990b         	ldr	r1, [sp, #0x2c]
700a134a: 9a0a         	ldr	r2, [sp, #0x28]
700a134c: eba1 0182    	sub.w	r1, r1, r2, lsl #2
700a1350: f88d 1023    	strb.w	r1, [sp, #0x23]
;     for (i = 0; i < numWords; i++)
700a1354: 9009         	str	r0, [sp, #0x24]
700a1356: e7ff         	b	0x700a1358 <Sciclient_recvMessage+0x28> @ imm = #-0x2
700a1358: 9809         	ldr	r0, [sp, #0x24]
700a135a: 990a         	ldr	r1, [sp, #0x28]
700a135c: 4288         	cmp	r0, r1
700a135e: d22c         	bhs	0x700a13ba <Sciclient_recvMessage+0x8a> @ imm = #0x58
700a1360: e7ff         	b	0x700a1362 <Sciclient_recvMessage+0x32> @ imm = #-0x2
;             rxThread,
700a1362: 980d         	ldr	r0, [sp, #0x34]
;             ((uint8_t) i +
700a1364: 9909         	ldr	r1, [sp, #0x24]
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a1366: f240 5230    	movw	r2, #0x530
700a136a: f2c7 020b    	movt	r2, #0x700b
700a136e: 7812         	ldrb	r2, [r2]
;             ((uint8_t) i +
700a1370: 4411         	add	r1, r2
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a1372: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a1374: b2c9         	uxtb	r1, r1
700a1376: f00b f9f3    	bl	0x700ac760 <Sciclient_secProxyReadThread32> @ imm = #0xb3e6
700a137a: 9007         	str	r0, [sp, #0x1c]
700a137c: a807         	add	r0, sp, #0x1c
;         uint8_t * tempWordPtr = (uint8_t*) & tempWord;
700a137e: 9006         	str	r0, [sp, #0x18]
700a1380: 2000         	movs	r0, #0x0
;         uint32_t j = 0U;
700a1382: 9005         	str	r0, [sp, #0x14]
;         for (j = 0U; j < 4U; j++)
700a1384: 9005         	str	r0, [sp, #0x14]
700a1386: e7ff         	b	0x700a1388 <Sciclient_recvMessage+0x58> @ imm = #-0x2
700a1388: 9805         	ldr	r0, [sp, #0x14]
700a138a: 2803         	cmp	r0, #0x3
700a138c: d810         	bhi	0x700a13b0 <Sciclient_recvMessage+0x80> @ imm = #0x20
700a138e: e7ff         	b	0x700a1390 <Sciclient_recvMessage+0x60> @ imm = #-0x2
;             *(pLocalRespPayload + i * 4 + j) = *tempWordPtr;
700a1390: 9806         	ldr	r0, [sp, #0x18]
700a1392: 7800         	ldrb	r0, [r0]
700a1394: 990c         	ldr	r1, [sp, #0x30]
700a1396: 9a09         	ldr	r2, [sp, #0x24]
700a1398: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a139c: 9a05         	ldr	r2, [sp, #0x14]
700a139e: 5488         	strb	r0, [r1, r2]
;             tempWordPtr++;
700a13a0: 9806         	ldr	r0, [sp, #0x18]
700a13a2: 3001         	adds	r0, #0x1
700a13a4: 9006         	str	r0, [sp, #0x18]
;         }
700a13a6: e7ff         	b	0x700a13a8 <Sciclient_recvMessage+0x78> @ imm = #-0x2
;         for (j = 0U; j < 4U; j++)
700a13a8: 9805         	ldr	r0, [sp, #0x14]
700a13aa: 3001         	adds	r0, #0x1
700a13ac: 9005         	str	r0, [sp, #0x14]
700a13ae: e7eb         	b	0x700a1388 <Sciclient_recvMessage+0x58> @ imm = #-0x2a
;     }
700a13b0: e7ff         	b	0x700a13b2 <Sciclient_recvMessage+0x82> @ imm = #-0x2
;     for (i = 0; i < numWords; i++)
700a13b2: 9809         	ldr	r0, [sp, #0x24]
700a13b4: 3001         	adds	r0, #0x1
700a13b6: 9009         	str	r0, [sp, #0x24]
700a13b8: e7ce         	b	0x700a1358 <Sciclient_recvMessage+0x28> @ imm = #-0x64
;     if (trailBytes > 0U)
700a13ba: f89d 0023    	ldrb.w	r0, [sp, #0x23]
700a13be: b368         	cbz	r0, 0x700a141c <Sciclient_recvMessage+0xec> @ imm = #0x5a
700a13c0: e7ff         	b	0x700a13c2 <Sciclient_recvMessage+0x92> @ imm = #-0x2
;                 rxThread,
700a13c2: 980d         	ldr	r0, [sp, #0x34]
;                 ((uint8_t)i +
700a13c4: 9909         	ldr	r1, [sp, #0x24]
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a13c6: f240 5230    	movw	r2, #0x530
700a13ca: f2c7 020b    	movt	r2, #0x700b
700a13ce: 7812         	ldrb	r2, [r2]
;                 ((uint8_t)i +
700a13d0: 4411         	add	r1, r2
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a13d2: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a13d4: b2c9         	uxtb	r1, r1
700a13d6: f00b f9c3    	bl	0x700ac760 <Sciclient_secProxyReadThread32> @ imm = #0xb386
700a13da: 9004         	str	r0, [sp, #0x10]
700a13dc: a804         	add	r0, sp, #0x10
;         uint8_t * pTempWord = (uint8_t*) &tempWord;
700a13de: 9003         	str	r0, [sp, #0xc]
700a13e0: 2000         	movs	r0, #0x0
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a13e2: 9002         	str	r0, [sp, #0x8]
700a13e4: e7ff         	b	0x700a13e6 <Sciclient_recvMessage+0xb6> @ imm = #-0x2
700a13e6: 9802         	ldr	r0, [sp, #0x8]
700a13e8: f89d 1023    	ldrb.w	r1, [sp, #0x23]
700a13ec: 4288         	cmp	r0, r1
700a13ee: d214         	bhs	0x700a141a <Sciclient_recvMessage+0xea> @ imm = #0x28
700a13f0: e7ff         	b	0x700a13f2 <Sciclient_recvMessage+0xc2> @ imm = #-0x2
;             uint8_t * address = (uint8_t*)pLocalRespPayload;
700a13f2: 980c         	ldr	r0, [sp, #0x30]
700a13f4: 9001         	str	r0, [sp, #0x4]
;             uint8_t value = *(uint8_t*)(pTempWord + bytes);
700a13f6: 9803         	ldr	r0, [sp, #0xc]
700a13f8: 9902         	ldr	r1, [sp, #0x8]
700a13fa: 5c40         	ldrb	r0, [r0, r1]
700a13fc: f88d 0003    	strb.w	r0, [sp, #0x3]
;             *(uint8_t*)(address + i*4 + bytes) = value;
700a1400: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a1404: 9901         	ldr	r1, [sp, #0x4]
700a1406: 9a09         	ldr	r2, [sp, #0x24]
700a1408: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a140c: 9a02         	ldr	r2, [sp, #0x8]
700a140e: 5488         	strb	r0, [r1, r2]
;         }
700a1410: e7ff         	b	0x700a1412 <Sciclient_recvMessage+0xe2> @ imm = #-0x2
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a1412: 9802         	ldr	r0, [sp, #0x8]
700a1414: 3001         	adds	r0, #0x1
700a1416: 9002         	str	r0, [sp, #0x8]
700a1418: e7e5         	b	0x700a13e6 <Sciclient_recvMessage+0xb6> @ imm = #-0x36
;     }
700a141a: e7ff         	b	0x700a141c <Sciclient_recvMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a141c: f240 5030    	movw	r0, #0x530
700a1420: f2c7 000b    	movt	r0, #0x700b
700a1424: 7801         	ldrb	r1, [r0]
;         rxPayloadSize) <=
700a1426: 980b         	ldr	r0, [sp, #0x2c]
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a1428: eb00 0081    	add.w	r0, r0, r1, lsl #2
;         (SCICLIENT_HEADER_SIZE_IN_WORDS*4U) +
700a142c: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a142e: f240 4138    	movw	r1, #0x438
700a1432: f2c7 010b    	movt	r1, #0x700b
700a1436: 6949         	ldr	r1, [r1, #0x14]
700a1438: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a143a: 4288         	cmp	r0, r1
700a143c: d80e         	bhi	0x700a145c <Sciclient_recvMessage+0x12c> @ imm = #0x1c
700a143e: e7ff         	b	0x700a1440 <Sciclient_recvMessage+0x110> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a1440: 980d         	ldr	r0, [sp, #0x34]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a1442: f240 4138    	movw	r1, #0x438
700a1446: f2c7 010b    	movt	r1, #0x700b
700a144a: 694a         	ldr	r2, [r1, #0x14]
700a144c: f04f 31ff    	mov.w	r1, #0xffffffff
700a1450: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a1454: b2c9         	uxtb	r1, r1
700a1456: f00b f983    	bl	0x700ac760 <Sciclient_secProxyReadThread32> @ imm = #0xb306
;     }
700a145a: e7ff         	b	0x700a145c <Sciclient_recvMessage+0x12c> @ imm = #-0x2
; }
700a145c: b00e         	add	sp, #0x38
700a145e: bd80         	pop	{r7, pc}

700a1460 <Udma_rmAllocIrIntr>:
; {
700a1460: b580         	push	{r7, lr}
700a1462: b088         	sub	sp, #0x20
700a1464: 9007         	str	r0, [sp, #0x1c]
700a1466: 9106         	str	r1, [sp, #0x18]
700a1468: 2000         	movs	r0, #0x0
700a146a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            irIntrNum = UDMA_INTR_INVALID;
700a146e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1470: 9806         	ldr	r0, [sp, #0x18]
700a1472: f500 70ea    	add.w	r0, r0, #0x1d4
700a1476: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1478: 9806         	ldr	r0, [sp, #0x18]
700a147a: f500 609f    	add.w	r0, r0, #0x4f8
700a147e: f04f 31ff    	mov.w	r1, #0xffffffff
700a1482: f007 f935    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x726a
;     if(UDMA_CORE_INTR_ANY == preferredIrIntrNum)
700a1486: 9807         	ldr	r0, [sp, #0x1c]
700a1488: 2101         	movs	r1, #0x1
700a148a: f6cf 71ff    	movt	r1, #0xffff
700a148e: 4288         	cmp	r0, r1
700a1490: d138         	bne	0x700a1504 <Udma_rmAllocIrIntr+0xa4> @ imm = #0x70
700a1492: e7ff         	b	0x700a1494 <Udma_rmAllocIrIntr+0x34> @ imm = #-0x2
700a1494: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a1496: 9005         	str	r0, [sp, #0x14]
700a1498: e7ff         	b	0x700a149a <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x2
700a149a: 9805         	ldr	r0, [sp, #0x14]
700a149c: 9900         	ldr	r1, [sp]
700a149e: f8d1 10ec    	ldr.w	r1, [r1, #0xec]
700a14a2: 4288         	cmp	r0, r1
700a14a4: d22d         	bhs	0x700a1502 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x5a
700a14a6: e7ff         	b	0x700a14a8 <Udma_rmAllocIrIntr+0x48> @ imm = #-0x2
;             offset = i >> 5U;
700a14a8: 9805         	ldr	r0, [sp, #0x14]
700a14aa: 0940         	lsrs	r0, r0, #0x5
700a14ac: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a14ae: 9805         	ldr	r0, [sp, #0x14]
700a14b0: 9904         	ldr	r1, [sp, #0x10]
700a14b2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a14b6: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a14b8: 9903         	ldr	r1, [sp, #0xc]
700a14ba: 2001         	movs	r0, #0x1
700a14bc: 4088         	lsls	r0, r1
700a14be: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a14c0: 9806         	ldr	r0, [sp, #0x18]
700a14c2: 9904         	ldr	r1, [sp, #0x10]
700a14c4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a14c8: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a14cc: 9902         	ldr	r1, [sp, #0x8]
700a14ce: 4008         	ands	r0, r1
700a14d0: 4288         	cmp	r0, r1
700a14d2: d111         	bne	0x700a14f8 <Udma_rmAllocIrIntr+0x98> @ imm = #0x22
700a14d4: e7ff         	b	0x700a14d6 <Udma_rmAllocIrIntr+0x76> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a14d6: 9a02         	ldr	r2, [sp, #0x8]
700a14d8: 9806         	ldr	r0, [sp, #0x18]
700a14da: 9904         	ldr	r1, [sp, #0x10]
700a14dc: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a14e0: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a14e4: 4390         	bics	r0, r2
700a14e6: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = i + rmInitPrms->startIrIntr;    /* Add start offset */
700a14ea: 9805         	ldr	r0, [sp, #0x14]
700a14ec: 9900         	ldr	r1, [sp]
700a14ee: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a14f2: 4408         	add	r0, r1
700a14f4: 9001         	str	r0, [sp, #0x4]
;                 break;
700a14f6: e004         	b	0x700a1502 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x8
;         }
700a14f8: e7ff         	b	0x700a14fa <Udma_rmAllocIrIntr+0x9a> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a14fa: 9805         	ldr	r0, [sp, #0x14]
700a14fc: 3001         	adds	r0, #0x1
700a14fe: 9005         	str	r0, [sp, #0x14]
700a1500: e7cb         	b	0x700a149a <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x6a
;     }
700a1502: e03c         	b	0x700a157e <Udma_rmAllocIrIntr+0x11e> @ imm = #0x78
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a1504: 9807         	ldr	r0, [sp, #0x1c]
700a1506: 9900         	ldr	r1, [sp]
700a1508: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a150c: 4288         	cmp	r0, r1
700a150e: d335         	blo	0x700a157c <Udma_rmAllocIrIntr+0x11c> @ imm = #0x6a
700a1510: e7ff         	b	0x700a1512 <Udma_rmAllocIrIntr+0xb2> @ imm = #-0x2
;            (preferredIrIntrNum < (rmInitPrms->startIrIntr + rmInitPrms->numIrIntr)))
700a1512: 9807         	ldr	r0, [sp, #0x1c]
700a1514: 9a00         	ldr	r2, [sp]
700a1516: f8d2 10e8    	ldr.w	r1, [r2, #0xe8]
700a151a: f8d2 20ec    	ldr.w	r2, [r2, #0xec]
700a151e: 4411         	add	r1, r2
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a1520: 4288         	cmp	r0, r1
700a1522: d22b         	bhs	0x700a157c <Udma_rmAllocIrIntr+0x11c> @ imm = #0x56
700a1524: e7ff         	b	0x700a1526 <Udma_rmAllocIrIntr+0xc6> @ imm = #-0x2
;             i = preferredIrIntrNum - rmInitPrms->startIrIntr;
700a1526: 9807         	ldr	r0, [sp, #0x1c]
700a1528: 9900         	ldr	r1, [sp]
700a152a: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a152e: 1a40         	subs	r0, r0, r1
700a1530: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1532: 9805         	ldr	r0, [sp, #0x14]
700a1534: 0940         	lsrs	r0, r0, #0x5
700a1536: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1538: 9805         	ldr	r0, [sp, #0x14]
700a153a: 9904         	ldr	r1, [sp, #0x10]
700a153c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1540: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1542: 9903         	ldr	r1, [sp, #0xc]
700a1544: 2001         	movs	r0, #0x1
700a1546: 4088         	lsls	r0, r1
700a1548: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a154a: 9806         	ldr	r0, [sp, #0x18]
700a154c: 9904         	ldr	r1, [sp, #0x10]
700a154e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1552: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a1556: 9902         	ldr	r1, [sp, #0x8]
700a1558: 4008         	ands	r0, r1
700a155a: 4288         	cmp	r0, r1
700a155c: d10d         	bne	0x700a157a <Udma_rmAllocIrIntr+0x11a> @ imm = #0x1a
700a155e: e7ff         	b	0x700a1560 <Udma_rmAllocIrIntr+0x100> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a1560: 9a02         	ldr	r2, [sp, #0x8]
700a1562: 9806         	ldr	r0, [sp, #0x18]
700a1564: 9904         	ldr	r1, [sp, #0x10]
700a1566: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a156a: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a156e: 4390         	bics	r0, r2
700a1570: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = preferredIrIntrNum;
700a1574: 9807         	ldr	r0, [sp, #0x1c]
700a1576: 9001         	str	r0, [sp, #0x4]
;             }
700a1578: e7ff         	b	0x700a157a <Udma_rmAllocIrIntr+0x11a> @ imm = #-0x2
;         }
700a157a: e7ff         	b	0x700a157c <Udma_rmAllocIrIntr+0x11c> @ imm = #-0x2
700a157c: e7ff         	b	0x700a157e <Udma_rmAllocIrIntr+0x11e> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a157e: 9806         	ldr	r0, [sp, #0x18]
700a1580: f500 609f    	add.w	r0, r0, #0x4f8
700a1584: f008 fc0c    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x8818
;     return (irIntrNum);
700a1588: 9801         	ldr	r0, [sp, #0x4]
700a158a: b008         	add	sp, #0x20
700a158c: bd80         	pop	{r7, pc}
700a158e: 0000         	movs	r0, r0

700a1590 <xQueueGenericSend>:
; {
700a1590: b580         	push	{r7, lr}
700a1592: b08a         	sub	sp, #0x28
700a1594: 9008         	str	r0, [sp, #0x20]
700a1596: 9107         	str	r1, [sp, #0x1c]
700a1598: 9206         	str	r2, [sp, #0x18]
700a159a: 9305         	str	r3, [sp, #0x14]
700a159c: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
700a159e: 9004         	str	r0, [sp, #0x10]
;     Queue_t * const pxQueue = xQueue;
700a15a0: 9808         	ldr	r0, [sp, #0x20]
700a15a2: 9000         	str	r0, [sp]
;     for( ; ; )
700a15a4: e7ff         	b	0x700a15a6 <xQueueGenericSend+0x16> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a15a6: f00a fff3    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0xafe6
;             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a15aa: 9800         	ldr	r0, [sp]
700a15ac: 6b80         	ldr	r0, [r0, #0x38]
700a15ae: 9900         	ldr	r1, [sp]
700a15b0: 6bc9         	ldr	r1, [r1, #0x3c]
700a15b2: 4288         	cmp	r0, r1
700a15b4: d304         	blo	0x700a15c0 <xQueueGenericSend+0x30> @ imm = #0x8
700a15b6: e7ff         	b	0x700a15b8 <xQueueGenericSend+0x28> @ imm = #-0x2
700a15b8: 9805         	ldr	r0, [sp, #0x14]
700a15ba: 2802         	cmp	r0, #0x2
700a15bc: d120         	bne	0x700a1600 <xQueueGenericSend+0x70> @ imm = #0x40
700a15be: e7ff         	b	0x700a15c0 <xQueueGenericSend+0x30> @ imm = #-0x2
;                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a15c0: 9800         	ldr	r0, [sp]
700a15c2: 9907         	ldr	r1, [sp, #0x1c]
700a15c4: 9a05         	ldr	r2, [sp, #0x14]
700a15c6: f003 faab    	bl	0x700a4b20 <prvCopyDataToQueue> @ imm = #0x3556
700a15ca: 9003         	str	r0, [sp, #0xc]
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a15cc: 9800         	ldr	r0, [sp]
700a15ce: 6a40         	ldr	r0, [r0, #0x24]
700a15d0: b150         	cbz	r0, 0x700a15e8 <xQueueGenericSend+0x58> @ imm = #0x14
700a15d2: e7ff         	b	0x700a15d4 <xQueueGenericSend+0x44> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a15d4: 9800         	ldr	r0, [sp]
700a15d6: 3024         	adds	r0, #0x24
700a15d8: f004 fe5a    	bl	0x700a6290 <xTaskRemoveFromEventList> @ imm = #0x4cb4
700a15dc: b110         	cbz	r0, 0x700a15e4 <xQueueGenericSend+0x54> @ imm = #0x4
700a15de: e7ff         	b	0x700a15e0 <xQueueGenericSend+0x50> @ imm = #-0x2
;                                 queueYIELD_IF_USING_PREEMPTION();
700a15e0: df00         	svc	#0x0
;                             }
700a15e2: e000         	b	0x700a15e6 <xQueueGenericSend+0x56> @ imm = #0x0
700a15e4: e7ff         	b	0x700a15e6 <xQueueGenericSend+0x56> @ imm = #-0x2
;                         }
700a15e6: e006         	b	0x700a15f6 <xQueueGenericSend+0x66> @ imm = #0xc
;                         else if( xYieldRequired != pdFALSE )
700a15e8: 9803         	ldr	r0, [sp, #0xc]
700a15ea: b110         	cbz	r0, 0x700a15f2 <xQueueGenericSend+0x62> @ imm = #0x4
700a15ec: e7ff         	b	0x700a15ee <xQueueGenericSend+0x5e> @ imm = #-0x2
;                             queueYIELD_IF_USING_PREEMPTION();
700a15ee: df00         	svc	#0x0
;                         }
700a15f0: e000         	b	0x700a15f4 <xQueueGenericSend+0x64> @ imm = #0x0
700a15f2: e7ff         	b	0x700a15f4 <xQueueGenericSend+0x64> @ imm = #-0x2
700a15f4: e7ff         	b	0x700a15f6 <xQueueGenericSend+0x66> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a15f6: f00a f88b    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xa116
700a15fa: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a15fc: 9009         	str	r0, [sp, #0x24]
700a15fe: e05b         	b	0x700a16b8 <xQueueGenericSend+0x128> @ imm = #0xb6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a1600: 9806         	ldr	r0, [sp, #0x18]
700a1602: b928         	cbnz	r0, 0x700a1610 <xQueueGenericSend+0x80> @ imm = #0xa
700a1604: e7ff         	b	0x700a1606 <xQueueGenericSend+0x76> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a1606: f00a f883    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xa106
700a160a: 2000         	movs	r0, #0x0
;                     return errQUEUE_FULL;
700a160c: 9009         	str	r0, [sp, #0x24]
700a160e: e053         	b	0x700a16b8 <xQueueGenericSend+0x128> @ imm = #0xa6
;                 else if( xEntryTimeSet == pdFALSE )
700a1610: 9804         	ldr	r0, [sp, #0x10]
700a1612: b930         	cbnz	r0, 0x700a1622 <xQueueGenericSend+0x92> @ imm = #0xc
700a1614: e7ff         	b	0x700a1616 <xQueueGenericSend+0x86> @ imm = #-0x2
700a1616: a801         	add	r0, sp, #0x4
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a1618: f00b fd02    	bl	0x700ad020 <vTaskInternalSetTimeOutState> @ imm = #0xba04
700a161c: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a161e: 9004         	str	r0, [sp, #0x10]
;                 }
700a1620: e000         	b	0x700a1624 <xQueueGenericSend+0x94> @ imm = #0x0
700a1622: e7ff         	b	0x700a1624 <xQueueGenericSend+0x94> @ imm = #-0x2
700a1624: e7ff         	b	0x700a1626 <xQueueGenericSend+0x96> @ imm = #-0x2
700a1626: e7ff         	b	0x700a1628 <xQueueGenericSend+0x98> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a1628: f00a f872    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xa0e4
;         vTaskSuspendAll();
700a162c: f00c f970    	bl	0x700ad910 <vTaskSuspendAll> @ imm = #0xc2e0
;         prvLockQueue( pxQueue );
700a1630: f00a ffae    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0xaf5c
700a1634: 9800         	ldr	r0, [sp]
700a1636: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a163a: 3001         	adds	r0, #0x1
700a163c: b928         	cbnz	r0, 0x700a164a <xQueueGenericSend+0xba> @ imm = #0xa
700a163e: e7ff         	b	0x700a1640 <xQueueGenericSend+0xb0> @ imm = #-0x2
700a1640: 9900         	ldr	r1, [sp]
700a1642: 2000         	movs	r0, #0x0
700a1644: f881 0044    	strb.w	r0, [r1, #0x44]
700a1648: e7ff         	b	0x700a164a <xQueueGenericSend+0xba> @ imm = #-0x2
700a164a: 9800         	ldr	r0, [sp]
700a164c: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a1650: 3001         	adds	r0, #0x1
700a1652: b928         	cbnz	r0, 0x700a1660 <xQueueGenericSend+0xd0> @ imm = #0xa
700a1654: e7ff         	b	0x700a1656 <xQueueGenericSend+0xc6> @ imm = #-0x2
700a1656: 9900         	ldr	r1, [sp]
700a1658: 2000         	movs	r0, #0x0
700a165a: f881 0045    	strb.w	r0, [r1, #0x45]
700a165e: e7ff         	b	0x700a1660 <xQueueGenericSend+0xd0> @ imm = #-0x2
700a1660: f00a f856    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xa0ac
700a1664: a801         	add	r0, sp, #0x4
700a1666: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a1668: f005 fd42    	bl	0x700a70f0 <xTaskCheckForTimeOut> @ imm = #0x5a84
700a166c: b9d8         	cbnz	r0, 0x700a16a6 <xQueueGenericSend+0x116> @ imm = #0x36
700a166e: e7ff         	b	0x700a1670 <xQueueGenericSend+0xe0> @ imm = #-0x2
;             if( prvIsQueueFull( pxQueue ) != pdFALSE )
700a1670: 9800         	ldr	r0, [sp]
700a1672: f00b f8bd    	bl	0x700ac7f0 <prvIsQueueFull> @ imm = #0xb17a
700a1676: b178         	cbz	r0, 0x700a1698 <xQueueGenericSend+0x108> @ imm = #0x1e
700a1678: e7ff         	b	0x700a167a <xQueueGenericSend+0xea> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
700a167a: 9800         	ldr	r0, [sp]
700a167c: 3010         	adds	r0, #0x10
700a167e: 9906         	ldr	r1, [sp, #0x18]
700a1680: f00b fbe6    	bl	0x700ace50 <vTaskPlaceOnEventList> @ imm = #0xb7cc
;                 prvUnlockQueue( pxQueue );
700a1684: 9800         	ldr	r0, [sp]
700a1686: f004 fb9b    	bl	0x700a5dc0 <prvUnlockQueue> @ imm = #0x4736
;                 if( xTaskResumeAll() == pdFALSE )
700a168a: f7ff fa91    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0xade
700a168e: b910         	cbnz	r0, 0x700a1696 <xQueueGenericSend+0x106> @ imm = #0x4
700a1690: e7ff         	b	0x700a1692 <xQueueGenericSend+0x102> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a1692: df00         	svc	#0x0
;                 }
700a1694: e7ff         	b	0x700a1696 <xQueueGenericSend+0x106> @ imm = #-0x2
;             }
700a1696: e005         	b	0x700a16a4 <xQueueGenericSend+0x114> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a1698: 9800         	ldr	r0, [sp]
700a169a: f004 fb91    	bl	0x700a5dc0 <prvUnlockQueue> @ imm = #0x4722
;                 ( void ) xTaskResumeAll();
700a169e: f7ff fa87    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0xaf2
700a16a2: e7ff         	b	0x700a16a4 <xQueueGenericSend+0x114> @ imm = #-0x2
;         }
700a16a4: e007         	b	0x700a16b6 <xQueueGenericSend+0x126> @ imm = #0xe
;             prvUnlockQueue( pxQueue );
700a16a6: 9800         	ldr	r0, [sp]
700a16a8: f004 fb8a    	bl	0x700a5dc0 <prvUnlockQueue> @ imm = #0x4714
;             ( void ) xTaskResumeAll();
700a16ac: f7ff fa80    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0xb00
700a16b0: 2000         	movs	r0, #0x0
;             return errQUEUE_FULL;
700a16b2: 9009         	str	r0, [sp, #0x24]
700a16b4: e000         	b	0x700a16b8 <xQueueGenericSend+0x128> @ imm = #0x0
;     for( ; ; )
700a16b6: e776         	b	0x700a15a6 <xQueueGenericSend+0x16> @ imm = #-0x114
; }
700a16b8: 9809         	ldr	r0, [sp, #0x24]
700a16ba: b00a         	add	sp, #0x28
700a16bc: bd80         	pop	{r7, pc}
700a16be: 0000         	movs	r0, r0

700a16c0 <UART_lld_init>:
; {
700a16c0: b580         	push	{r7, lr}
700a16c2: b084         	sub	sp, #0x10
700a16c4: 9003         	str	r0, [sp, #0xc]
700a16c6: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a16c8: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a16ca: 9803         	ldr	r0, [sp, #0xc]
700a16cc: b168         	cbz	r0, 0x700a16ea <UART_lld_init+0x2a> @ imm = #0x1a
700a16ce: e7ff         	b	0x700a16d0 <UART_lld_init+0x10> @ imm = #-0x2
700a16d0: 9803         	ldr	r0, [sp, #0xc]
700a16d2: 6840         	ldr	r0, [r0, #0x4]
700a16d4: b148         	cbz	r0, 0x700a16ea <UART_lld_init+0x2a> @ imm = #0x12
700a16d6: e7ff         	b	0x700a16d8 <UART_lld_init+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a16d8: 9803         	ldr	r0, [sp, #0xc]
700a16da: 6d40         	ldr	r0, [r0, #0x54]
700a16dc: b120         	cbz	r0, 0x700a16e8 <UART_lld_init+0x28> @ imm = #0x8
700a16de: e7ff         	b	0x700a16e0 <UART_lld_init+0x20> @ imm = #-0x2
700a16e0: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a16e4: 9002         	str	r0, [sp, #0x8]
;         }
700a16e6: e7ff         	b	0x700a16e8 <UART_lld_init+0x28> @ imm = #-0x2
;     }
700a16e8: e003         	b	0x700a16f2 <UART_lld_init+0x32> @ imm = #0x6
700a16ea: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a16ee: 9002         	str	r0, [sp, #0x8]
700a16f0: e7ff         	b	0x700a16f2 <UART_lld_init+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a16f2: 9802         	ldr	r0, [sp, #0x8]
700a16f4: 2800         	cmp	r0, #0x0
700a16f6: d176         	bne	0x700a17e6 <UART_lld_init+0x126> @ imm = #0xec
700a16f8: e7ff         	b	0x700a16fa <UART_lld_init+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a16fa: 9903         	ldr	r1, [sp, #0xc]
700a16fc: 2002         	movs	r0, #0x2
700a16fe: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a1700: 9803         	ldr	r0, [sp, #0xc]
700a1702: 6840         	ldr	r0, [r0, #0x4]
700a1704: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a1706: 9801         	ldr	r0, [sp, #0x4]
700a1708: 6d82         	ldr	r2, [r0, #0x58]
700a170a: f244 2040    	movw	r0, #0x4240
700a170e: f2c0 000f    	movt	r0, #0xf
700a1712: 2100         	movs	r1, #0x0
700a1714: 9100         	str	r1, [sp]
700a1716: 4790         	blx	r2
700a1718: 9a00         	ldr	r2, [sp]
700a171a: 9903         	ldr	r1, [sp, #0xc]
700a171c: 66ca         	str	r2, [r1, #0x6c]
700a171e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a1720: 9803         	ldr	r0, [sp, #0xc]
700a1722: 6800         	ldr	r0, [r0]
700a1724: f005 f81c    	bl	0x700a6760 <UART_IsBaseAddrValid> @ imm = #0x5038
700a1728: 4601         	mov	r1, r0
700a172a: 9802         	ldr	r0, [sp, #0x8]
700a172c: 4408         	add	r0, r1
700a172e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a1730: 9801         	ldr	r0, [sp, #0x4]
700a1732: 6800         	ldr	r0, [r0]
700a1734: f00b fde4    	bl	0x700ad300 <UART_IsParameter> @ imm = #0xbbc8
700a1738: 4601         	mov	r1, r0
700a173a: 9802         	ldr	r0, [sp, #0x8]
700a173c: 4408         	add	r0, r1
700a173e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a1740: 9801         	ldr	r0, [sp, #0x4]
700a1742: 6840         	ldr	r0, [r0, #0x4]
700a1744: f00b fddc    	bl	0x700ad300 <UART_IsParameter> @ imm = #0xbbb8
700a1748: 4601         	mov	r1, r0
700a174a: 9802         	ldr	r0, [sp, #0x8]
700a174c: 4408         	add	r0, r1
700a174e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a1750: 9801         	ldr	r0, [sp, #0x4]
700a1752: 6880         	ldr	r0, [r0, #0x8]
700a1754: f00a fe24    	bl	0x700ac3a0 <UART_IsDataLengthValid> @ imm = #0xac48
700a1758: 4601         	mov	r1, r0
700a175a: 9802         	ldr	r0, [sp, #0x8]
700a175c: 4408         	add	r0, r1
700a175e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a1760: 9801         	ldr	r0, [sp, #0x4]
700a1762: 68c0         	ldr	r0, [r0, #0xc]
700a1764: f00b fc1c    	bl	0x700acfa0 <UART_IsStopBitsValid> @ imm = #0xb838
700a1768: 4601         	mov	r1, r0
700a176a: 9802         	ldr	r0, [sp, #0x8]
700a176c: 4408         	add	r0, r1
700a176e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a1770: 9801         	ldr	r0, [sp, #0x4]
700a1772: 6900         	ldr	r0, [r0, #0x10]
700a1774: f00a fb94    	bl	0x700abea0 <UART_IsParityTypeValid> @ imm = #0xa728
700a1778: 4601         	mov	r1, r0
700a177a: 9802         	ldr	r0, [sp, #0x8]
700a177c: 4408         	add	r0, r1
700a177e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a1780: 9801         	ldr	r0, [sp, #0x4]
700a1782: 69c0         	ldr	r0, [r0, #0x1c]
700a1784: f00a fa2c    	bl	0x700abbe0 <UART_IsHWFlowCtrlValid> @ imm = #0xa458
700a1788: 4601         	mov	r1, r0
700a178a: 9802         	ldr	r0, [sp, #0x8]
700a178c: 4408         	add	r0, r1
700a178e: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a1790: 9801         	ldr	r0, [sp, #0x4]
700a1792: 6ac0         	ldr	r0, [r0, #0x2c]
700a1794: f009 fa7c    	bl	0x700aac90 <UART_OperModeValid> @ imm = #0x94f8
700a1798: 4601         	mov	r1, r0
700a179a: 9802         	ldr	r0, [sp, #0x8]
700a179c: 4408         	add	r0, r1
700a179e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a17a0: 9801         	ldr	r0, [sp, #0x4]
700a17a2: 6b80         	ldr	r0, [r0, #0x38]
700a17a4: f00a fa3c    	bl	0x700abc20 <UART_IsRxTrigLvlValid> @ imm = #0xa478
700a17a8: 4601         	mov	r1, r0
700a17aa: 9802         	ldr	r0, [sp, #0x8]
700a17ac: 4408         	add	r0, r1
700a17ae: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a17b0: 9801         	ldr	r0, [sp, #0x4]
700a17b2: 6bc0         	ldr	r0, [r0, #0x3c]
700a17b4: f00a fa54    	bl	0x700abc60 <UART_IsTxTrigLvlValid> @ imm = #0xa4a8
700a17b8: 4601         	mov	r1, r0
700a17ba: 9802         	ldr	r0, [sp, #0x8]
700a17bc: 4408         	add	r0, r1
700a17be: 9002         	str	r0, [sp, #0x8]
;         if(UART_STATUS_SUCCESS == status)
700a17c0: 9802         	ldr	r0, [sp, #0x8]
700a17c2: b938         	cbnz	r0, 0x700a17d4 <UART_lld_init+0x114> @ imm = #0xe
700a17c4: e7ff         	b	0x700a17c6 <UART_lld_init+0x106> @ imm = #-0x2
;             UART_configInstance(hUart);
700a17c6: 9803         	ldr	r0, [sp, #0xc]
700a17c8: f001 ff7a    	bl	0x700a36c0 <UART_configInstance> @ imm = #0x1ef4
;             hUart->state = UART_STATE_READY;
700a17cc: 9903         	ldr	r1, [sp, #0xc]
700a17ce: 2001         	movs	r0, #0x1
700a17d0: 6548         	str	r0, [r1, #0x54]
;         }
700a17d2: e007         	b	0x700a17e4 <UART_lld_init+0x124> @ imm = #0xe
;             status += UART_lld_deInit(hUart);
700a17d4: 9803         	ldr	r0, [sp, #0xc]
700a17d6: f008 fe9b    	bl	0x700aa510 <UART_lld_deInit> @ imm = #0x8d36
700a17da: 4601         	mov	r1, r0
700a17dc: 9802         	ldr	r0, [sp, #0x8]
700a17de: 4408         	add	r0, r1
700a17e0: 9002         	str	r0, [sp, #0x8]
700a17e2: e7ff         	b	0x700a17e4 <UART_lld_init+0x124> @ imm = #-0x2
;     }
700a17e4: e7ff         	b	0x700a17e6 <UART_lld_init+0x126> @ imm = #-0x2
;     return status;
700a17e6: 9802         	ldr	r0, [sp, #0x8]
700a17e8: b004         	add	sp, #0x10
700a17ea: bd80         	pop	{r7, pc}
700a17ec: 0000         	movs	r0, r0
700a17ee: 0000         	movs	r0, r0

700a17f0 <Sciclient_pmQueryModuleClkFreq>:
; {
700a17f0: b580         	push	{r7, lr}
700a17f2: b09e         	sub	sp, #0x78
700a17f4: f8dd c084    	ldr.w	r12, [sp, #0x84]
700a17f8: f8dd c080    	ldr.w	r12, [sp, #0x80]
700a17fc: 901d         	str	r0, [sp, #0x74]
700a17fe: 911c         	str	r1, [sp, #0x70]
700a1800: 931b         	str	r3, [sp, #0x6c]
700a1802: 921a         	str	r2, [sp, #0x68]
700a1804: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a1806: 9019         	str	r0, [sp, #0x64]
;     request.device         = (uint32_t) moduleId;
700a1808: 981d         	ldr	r0, [sp, #0x74]
700a180a: 9010         	str	r0, [sp, #0x40]
;     request.min_freq_hz    = (uint64_t) reqFreqHz;
700a180c: 981a         	ldr	r0, [sp, #0x68]
700a180e: 991b         	ldr	r1, [sp, #0x6c]
700a1810: 9112         	str	r1, [sp, #0x48]
700a1812: 9011         	str	r0, [sp, #0x44]
;     request.target_freq_hz = (uint64_t) reqFreqHz;
700a1814: 981a         	ldr	r0, [sp, #0x68]
700a1816: 991b         	ldr	r1, [sp, #0x6c]
700a1818: 9114         	str	r1, [sp, #0x50]
700a181a: 9013         	str	r0, [sp, #0x4c]
;     request.max_freq_hz    = (uint64_t) reqFreqHz;
700a181c: 981a         	ldr	r0, [sp, #0x68]
700a181e: 991b         	ldr	r1, [sp, #0x6c]
700a1820: 9116         	str	r1, [sp, #0x58]
700a1822: 9015         	str	r0, [sp, #0x54]
;     if((reqFreqHz%10U) != 0U)
700a1824: 9b1a         	ldr	r3, [sp, #0x68]
700a1826: 981b         	ldr	r0, [sp, #0x6c]
700a1828: f64c 41cd    	movw	r1, #0xcccd
700a182c: f6cc 41cc    	movt	r1, #0xcccc
700a1830: fba3 2e01    	umull	r2, lr, r3, r1
700a1834: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a1838: fb03 e30c    	mla	r3, r3, r12, lr
700a183c: fb00 3101    	mla	r1, r0, r1, r3
700a1840: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a1844: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a1848: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a184c: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a1850: f649 129a    	movw	r2, #0x999a
700a1854: f6c9 1299    	movt	r2, #0x9999
700a1858: 1a89         	subs	r1, r1, r2
700a185a: f649 1199    	movw	r1, #0x9999
700a185e: f6c1 1199    	movt	r1, #0x1999
700a1862: 4188         	sbcs	r0, r1
700a1864: d316         	blo	0x700a1894 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #0x2c
700a1866: e7ff         	b	0x700a1868 <Sciclient_pmQueryModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(reqFreqHz-(reqFreqHz%10U));
700a1868: 981a         	ldr	r0, [sp, #0x68]
700a186a: 9001         	str	r0, [sp, #0x4]
700a186c: 991b         	ldr	r1, [sp, #0x6c]
700a186e: 9100         	str	r1, [sp]
700a1870: 220a         	movs	r2, #0xa
700a1872: 2300         	movs	r3, #0x0
700a1874: f00b eba6    	blx	0x700acfc4 <__aeabi_uldivmod> @ imm = #0xb74c
700a1878: 9800         	ldr	r0, [sp]
700a187a: 9901         	ldr	r1, [sp, #0x4]
700a187c: 1a89         	subs	r1, r1, r2
700a187e: 4198         	sbcs	r0, r3
700a1880: 9111         	str	r1, [sp, #0x44]
700a1882: 9012         	str	r0, [sp, #0x48]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a1884: 9911         	ldr	r1, [sp, #0x44]
700a1886: 9812         	ldr	r0, [sp, #0x48]
700a1888: 310a         	adds	r1, #0xa
700a188a: f140 0000    	adc	r0, r0, #0x0
700a188e: 9115         	str	r1, [sp, #0x54]
700a1890: 9016         	str	r0, [sp, #0x58]
;     }
700a1892: e7ff         	b	0x700a1894 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a1894: 981c         	ldr	r0, [sp, #0x70]
700a1896: 28ff         	cmp	r0, #0xff
700a1898: d307         	blo	0x700a18aa <Sciclient_pmQueryModuleClkFreq+0xba> @ imm = #0xe
700a189a: e7ff         	b	0x700a189c <Sciclient_pmQueryModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a189c: 981c         	ldr	r0, [sp, #0x70]
700a189e: f8cd 005d    	str.w	r0, [sp, #0x5d]
700a18a2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a18a4: f88d 005c    	strb.w	r0, [sp, #0x5c]
;     }
700a18a8: e003         	b	0x700a18b2 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a18aa: 981c         	ldr	r0, [sp, #0x70]
700a18ac: f88d 005c    	strb.w	r0, [sp, #0x5c]
700a18b0: e7ff         	b	0x700a18b2 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #-0x2
700a18b2: 2000         	movs	r0, #0x0
;     struct tisci_msg_query_freq_resp response = {{0}};
700a18b4: 900d         	str	r0, [sp, #0x34]
700a18b6: 900c         	str	r0, [sp, #0x30]
700a18b8: 900b         	str	r0, [sp, #0x2c]
700a18ba: 900a         	str	r0, [sp, #0x28]
700a18bc: f240 110d    	movw	r1, #0x10d
;     reqParam.messageType    = (uint16_t) TISCI_MSG_QUERY_FREQ;
700a18c0: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a18c4: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a18c6: 9106         	str	r1, [sp, #0x18]
700a18c8: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a18ca: 9107         	str	r1, [sp, #0x1c]
700a18cc: 2129         	movs	r1, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a18ce: 9108         	str	r1, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a18d0: 9921         	ldr	r1, [sp, #0x84]
700a18d2: 9109         	str	r1, [sp, #0x24]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a18d4: 9002         	str	r0, [sp, #0x8]
700a18d6: a80a         	add	r0, sp, #0x28
;     respParam.pRespPayload    = (uint8_t *) &response;
700a18d8: 9003         	str	r0, [sp, #0xc]
700a18da: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a18dc: 9004         	str	r0, [sp, #0x10]
700a18de: a805         	add	r0, sp, #0x14
700a18e0: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a18e2: f7fa facd    	bl	0x7009be80 <Sciclient_service> @ imm = #-0x5a66
700a18e6: 9019         	str	r0, [sp, #0x64]
;     if((retVal != SystemP_SUCCESS) ||
700a18e8: 9819         	ldr	r0, [sp, #0x64]
700a18ea: b930         	cbnz	r0, 0x700a18fa <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #0xc
700a18ec: e7ff         	b	0x700a18ee <Sciclient_pmQueryModuleClkFreq+0xfe> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a18ee: 9802         	ldr	r0, [sp, #0x8]
700a18f0: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a18f4: 2802         	cmp	r0, #0x2
700a18f6: d004         	beq	0x700a1902 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #0x8
700a18f8: e7ff         	b	0x700a18fa <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #-0x2
700a18fa: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a18fe: 9019         	str	r0, [sp, #0x64]
;     }
700a1900: e7ff         	b	0x700a1902 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a1902: 9819         	ldr	r0, [sp, #0x64]
700a1904: b930         	cbnz	r0, 0x700a1914 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #0xc
700a1906: e7ff         	b	0x700a1908 <Sciclient_pmQueryModuleClkFreq+0x118> @ imm = #-0x2
;         *respFreqHz = (uint64_t) response.freq_hz;
700a1908: 980c         	ldr	r0, [sp, #0x30]
700a190a: 9a0d         	ldr	r2, [sp, #0x34]
700a190c: 9920         	ldr	r1, [sp, #0x80]
700a190e: 604a         	str	r2, [r1, #0x4]
700a1910: 6008         	str	r0, [r1]
;     }
700a1912: e7ff         	b	0x700a1914 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #-0x2
;     return retVal;
700a1914: 9819         	ldr	r0, [sp, #0x64]
700a1916: b01e         	add	sp, #0x78
700a1918: bd80         	pop	{r7, pc}
700a191a: 0000         	movs	r0, r0
700a191c: 0000         	movs	r0, r0
700a191e: 0000         	movs	r0, r0

700a1920 <xQueueReceive>:
; {
700a1920: b580         	push	{r7, lr}
700a1922: b08a         	sub	sp, #0x28
700a1924: 9008         	str	r0, [sp, #0x20]
700a1926: 9107         	str	r1, [sp, #0x1c]
700a1928: 9206         	str	r2, [sp, #0x18]
700a192a: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
700a192c: 9005         	str	r0, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a192e: 9808         	ldr	r0, [sp, #0x20]
700a1930: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
700a1932: e7ff         	b	0x700a1934 <xQueueReceive+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a1934: f00a fe2c    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0xac58
;             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a1938: 9802         	ldr	r0, [sp, #0x8]
700a193a: 6b80         	ldr	r0, [r0, #0x38]
700a193c: 9001         	str	r0, [sp, #0x4]
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a193e: 9801         	ldr	r0, [sp, #0x4]
700a1940: b1e0         	cbz	r0, 0x700a197c <xQueueReceive+0x5c> @ imm = #0x38
700a1942: e7ff         	b	0x700a1944 <xQueueReceive+0x24> @ imm = #-0x2
;                 prvCopyDataFromQueue( pxQueue, pvBuffer );
700a1944: 9802         	ldr	r0, [sp, #0x8]
700a1946: 9907         	ldr	r1, [sp, #0x1c]
700a1948: f00a f822    	bl	0x700ab990 <prvCopyDataFromQueue> @ imm = #0xa044
;                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a194c: 9801         	ldr	r0, [sp, #0x4]
700a194e: 3801         	subs	r0, #0x1
700a1950: 9902         	ldr	r1, [sp, #0x8]
700a1952: 6388         	str	r0, [r1, #0x38]
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a1954: 9802         	ldr	r0, [sp, #0x8]
700a1956: 6900         	ldr	r0, [r0, #0x10]
700a1958: b150         	cbz	r0, 0x700a1970 <xQueueReceive+0x50> @ imm = #0x14
700a195a: e7ff         	b	0x700a195c <xQueueReceive+0x3c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a195c: 9802         	ldr	r0, [sp, #0x8]
700a195e: 3010         	adds	r0, #0x10
700a1960: f004 fc96    	bl	0x700a6290 <xTaskRemoveFromEventList> @ imm = #0x492c
700a1964: b110         	cbz	r0, 0x700a196c <xQueueReceive+0x4c> @ imm = #0x4
700a1966: e7ff         	b	0x700a1968 <xQueueReceive+0x48> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
700a1968: df00         	svc	#0x0
;                     }
700a196a: e000         	b	0x700a196e <xQueueReceive+0x4e> @ imm = #0x0
700a196c: e7ff         	b	0x700a196e <xQueueReceive+0x4e> @ imm = #-0x2
;                 }
700a196e: e000         	b	0x700a1972 <xQueueReceive+0x52> @ imm = #0x0
700a1970: e7ff         	b	0x700a1972 <xQueueReceive+0x52> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a1972: f009 fecd    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x9d9a
700a1976: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a1978: 9009         	str	r0, [sp, #0x24]
700a197a: e063         	b	0x700a1a44 <xQueueReceive+0x124> @ imm = #0xc6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a197c: 9806         	ldr	r0, [sp, #0x18]
700a197e: b928         	cbnz	r0, 0x700a198c <xQueueReceive+0x6c> @ imm = #0xa
700a1980: e7ff         	b	0x700a1982 <xQueueReceive+0x62> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a1982: f009 fec5    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x9d8a
700a1986: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
700a1988: 9009         	str	r0, [sp, #0x24]
700a198a: e05b         	b	0x700a1a44 <xQueueReceive+0x124> @ imm = #0xb6
;                 else if( xEntryTimeSet == pdFALSE )
700a198c: 9805         	ldr	r0, [sp, #0x14]
700a198e: b930         	cbnz	r0, 0x700a199e <xQueueReceive+0x7e> @ imm = #0xc
700a1990: e7ff         	b	0x700a1992 <xQueueReceive+0x72> @ imm = #-0x2
700a1992: a803         	add	r0, sp, #0xc
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a1994: f00b fb44    	bl	0x700ad020 <vTaskInternalSetTimeOutState> @ imm = #0xb688
700a1998: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a199a: 9005         	str	r0, [sp, #0x14]
;                 }
700a199c: e000         	b	0x700a19a0 <xQueueReceive+0x80> @ imm = #0x0
700a199e: e7ff         	b	0x700a19a0 <xQueueReceive+0x80> @ imm = #-0x2
700a19a0: e7ff         	b	0x700a19a2 <xQueueReceive+0x82> @ imm = #-0x2
700a19a2: e7ff         	b	0x700a19a4 <xQueueReceive+0x84> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a19a4: f009 feb4    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x9d68
;         vTaskSuspendAll();
700a19a8: f00b ffb2    	bl	0x700ad910 <vTaskSuspendAll> @ imm = #0xbf64
;         prvLockQueue( pxQueue );
700a19ac: f00a fdf0    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0xabe0
700a19b0: 9802         	ldr	r0, [sp, #0x8]
700a19b2: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a19b6: 3001         	adds	r0, #0x1
700a19b8: b928         	cbnz	r0, 0x700a19c6 <xQueueReceive+0xa6> @ imm = #0xa
700a19ba: e7ff         	b	0x700a19bc <xQueueReceive+0x9c> @ imm = #-0x2
700a19bc: 9902         	ldr	r1, [sp, #0x8]
700a19be: 2000         	movs	r0, #0x0
700a19c0: f881 0044    	strb.w	r0, [r1, #0x44]
700a19c4: e7ff         	b	0x700a19c6 <xQueueReceive+0xa6> @ imm = #-0x2
700a19c6: 9802         	ldr	r0, [sp, #0x8]
700a19c8: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a19cc: 3001         	adds	r0, #0x1
700a19ce: b928         	cbnz	r0, 0x700a19dc <xQueueReceive+0xbc> @ imm = #0xa
700a19d0: e7ff         	b	0x700a19d2 <xQueueReceive+0xb2> @ imm = #-0x2
700a19d2: 9902         	ldr	r1, [sp, #0x8]
700a19d4: 2000         	movs	r0, #0x0
700a19d6: f881 0045    	strb.w	r0, [r1, #0x45]
700a19da: e7ff         	b	0x700a19dc <xQueueReceive+0xbc> @ imm = #-0x2
700a19dc: f009 fe98    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x9d30
700a19e0: a803         	add	r0, sp, #0xc
700a19e2: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a19e4: f005 fb84    	bl	0x700a70f0 <xTaskCheckForTimeOut> @ imm = #0x5708
700a19e8: b9e0         	cbnz	r0, 0x700a1a24 <xQueueReceive+0x104> @ imm = #0x38
700a19ea: e7ff         	b	0x700a19ec <xQueueReceive+0xcc> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a19ec: 9802         	ldr	r0, [sp, #0x8]
700a19ee: f00b f96f    	bl	0x700accd0 <prvIsQueueEmpty> @ imm = #0xb2de
700a19f2: b180         	cbz	r0, 0x700a1a16 <xQueueReceive+0xf6> @ imm = #0x20
700a19f4: e7ff         	b	0x700a19f6 <xQueueReceive+0xd6> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
700a19f6: 9802         	ldr	r0, [sp, #0x8]
700a19f8: 3024         	adds	r0, #0x24
700a19fa: 9906         	ldr	r1, [sp, #0x18]
700a19fc: f00b fa28    	bl	0x700ace50 <vTaskPlaceOnEventList> @ imm = #0xb450
;                 prvUnlockQueue( pxQueue );
700a1a00: 9802         	ldr	r0, [sp, #0x8]
700a1a02: f004 f9dd    	bl	0x700a5dc0 <prvUnlockQueue> @ imm = #0x43ba
;                 if( xTaskResumeAll() == pdFALSE )
700a1a06: f7ff f8d3    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0xe5a
700a1a0a: b910         	cbnz	r0, 0x700a1a12 <xQueueReceive+0xf2> @ imm = #0x4
700a1a0c: e7ff         	b	0x700a1a0e <xQueueReceive+0xee> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a1a0e: df00         	svc	#0x0
;                 }
700a1a10: e000         	b	0x700a1a14 <xQueueReceive+0xf4> @ imm = #0x0
700a1a12: e7ff         	b	0x700a1a14 <xQueueReceive+0xf4> @ imm = #-0x2
;             }
700a1a14: e005         	b	0x700a1a22 <xQueueReceive+0x102> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a1a16: 9802         	ldr	r0, [sp, #0x8]
700a1a18: f004 f9d2    	bl	0x700a5dc0 <prvUnlockQueue> @ imm = #0x43a4
;                 ( void ) xTaskResumeAll();
700a1a1c: f7ff f8c8    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0xe70
700a1a20: e7ff         	b	0x700a1a22 <xQueueReceive+0x102> @ imm = #-0x2
;         }
700a1a22: e00e         	b	0x700a1a42 <xQueueReceive+0x122> @ imm = #0x1c
;             prvUnlockQueue( pxQueue );
700a1a24: 9802         	ldr	r0, [sp, #0x8]
700a1a26: f004 f9cb    	bl	0x700a5dc0 <prvUnlockQueue> @ imm = #0x4396
;             ( void ) xTaskResumeAll();
700a1a2a: f7ff f8c1    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0xe7e
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a1a2e: 9802         	ldr	r0, [sp, #0x8]
700a1a30: f00b f94e    	bl	0x700accd0 <prvIsQueueEmpty> @ imm = #0xb29c
700a1a34: b118         	cbz	r0, 0x700a1a3e <xQueueReceive+0x11e> @ imm = #0x6
700a1a36: e7ff         	b	0x700a1a38 <xQueueReceive+0x118> @ imm = #-0x2
700a1a38: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
700a1a3a: 9009         	str	r0, [sp, #0x24]
700a1a3c: e002         	b	0x700a1a44 <xQueueReceive+0x124> @ imm = #0x4
700a1a3e: e7ff         	b	0x700a1a40 <xQueueReceive+0x120> @ imm = #-0x2
700a1a40: e7ff         	b	0x700a1a42 <xQueueReceive+0x122> @ imm = #-0x2
;     for( ; ; )
700a1a42: e777         	b	0x700a1934 <xQueueReceive+0x14> @ imm = #-0x112
; }
700a1a44: 9809         	ldr	r0, [sp, #0x24]
700a1a46: b00a         	add	sp, #0x28
700a1a48: bd80         	pop	{r7, pc}
700a1a4a: 0000         	movs	r0, r0
700a1a4c: 0000         	movs	r0, r0
700a1a4e: 0000         	movs	r0, r0

700a1a50 <pxPortInitialiseStack>:
;                                    TaskFunction_t pxCode, void *pvParameters) {
700a1a50: b083         	sub	sp, #0xc
700a1a52: 9002         	str	r0, [sp, #0x8]
700a1a54: 9101         	str	r1, [sp, #0x4]
700a1a56: 9200         	str	r2, [sp]
;   *pxTopOfStack = (StackType_t)NULL;
700a1a58: 9902         	ldr	r1, [sp, #0x8]
700a1a5a: 2000         	movs	r0, #0x0
700a1a5c: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a5e: 9902         	ldr	r1, [sp, #0x8]
700a1a60: 3904         	subs	r1, #0x4
700a1a62: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a1a64: 9902         	ldr	r1, [sp, #0x8]
700a1a66: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a68: 9902         	ldr	r1, [sp, #0x8]
700a1a6a: 3904         	subs	r1, #0x4
700a1a6c: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a1a6e: 9902         	ldr	r1, [sp, #0x8]
700a1a70: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a72: 9802         	ldr	r0, [sp, #0x8]
700a1a74: 3804         	subs	r0, #0x4
700a1a76: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portINITIAL_SPSR;
700a1a78: 9902         	ldr	r1, [sp, #0x8]
700a1a7a: 201f         	movs	r0, #0x1f
700a1a7c: 6008         	str	r0, [r1]
;   if (((uint32_t)pxCode & portTHUMB_MODE_ADDRESS) != 0x00UL) {
700a1a7e: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a1a82: 07c0         	lsls	r0, r0, #0x1f
700a1a84: b130         	cbz	r0, 0x700a1a94 <pxPortInitialiseStack+0x44> @ imm = #0xc
700a1a86: e7ff         	b	0x700a1a88 <pxPortInitialiseStack+0x38> @ imm = #-0x2
;     *pxTopOfStack |= portTHUMB_MODE_BIT;
700a1a88: 9902         	ldr	r1, [sp, #0x8]
700a1a8a: 6808         	ldr	r0, [r1]
700a1a8c: f040 0020    	orr	r0, r0, #0x20
700a1a90: 6008         	str	r0, [r1]
;   }
700a1a92: e7ff         	b	0x700a1a94 <pxPortInitialiseStack+0x44> @ imm = #-0x2
;   pxTopOfStack--;
700a1a94: 9802         	ldr	r0, [sp, #0x8]
700a1a96: 3804         	subs	r0, #0x4
700a1a98: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pxCode;
700a1a9a: 9801         	ldr	r0, [sp, #0x4]
700a1a9c: 9902         	ldr	r1, [sp, #0x8]
700a1a9e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1aa0: 9802         	ldr	r0, [sp, #0x8]
700a1aa2: 3804         	subs	r0, #0x4
700a1aa4: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* R14 */
700a1aa6: 9902         	ldr	r1, [sp, #0x8]
700a1aa8: f64d 2021    	movw	r0, #0xda21
700a1aac: f2c7 000a    	movt	r0, #0x700a
700a1ab0: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1ab2: 9802         	ldr	r0, [sp, #0x8]
700a1ab4: 3804         	subs	r0, #0x4
700a1ab6: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x12121212; /* R12 */
700a1ab8: 9902         	ldr	r1, [sp, #0x8]
700a1aba: f04f 3012    	mov.w	r0, #0x12121212
700a1abe: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1ac0: 9802         	ldr	r0, [sp, #0x8]
700a1ac2: 3804         	subs	r0, #0x4
700a1ac4: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x11111111; /* R11 */
700a1ac6: 9902         	ldr	r1, [sp, #0x8]
700a1ac8: f04f 3011    	mov.w	r0, #0x11111111
700a1acc: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1ace: 9802         	ldr	r0, [sp, #0x8]
700a1ad0: 3804         	subs	r0, #0x4
700a1ad2: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x10101010; /* R10 */
700a1ad4: 9902         	ldr	r1, [sp, #0x8]
700a1ad6: f04f 3010    	mov.w	r0, #0x10101010
700a1ada: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1adc: 9802         	ldr	r0, [sp, #0x8]
700a1ade: 3804         	subs	r0, #0x4
700a1ae0: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x09090909; /* R9 */
700a1ae2: 9902         	ldr	r1, [sp, #0x8]
700a1ae4: f04f 3009    	mov.w	r0, #0x9090909
700a1ae8: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1aea: 9802         	ldr	r0, [sp, #0x8]
700a1aec: 3804         	subs	r0, #0x4
700a1aee: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x08080808; /* R8 */
700a1af0: 9902         	ldr	r1, [sp, #0x8]
700a1af2: f04f 3008    	mov.w	r0, #0x8080808
700a1af6: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1af8: 9802         	ldr	r0, [sp, #0x8]
700a1afa: 3804         	subs	r0, #0x4
700a1afc: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x07070707; /* R7 */
700a1afe: 9902         	ldr	r1, [sp, #0x8]
700a1b00: f04f 3007    	mov.w	r0, #0x7070707
700a1b04: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1b06: 9802         	ldr	r0, [sp, #0x8]
700a1b08: 3804         	subs	r0, #0x4
700a1b0a: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x06060606; /* R6 */
700a1b0c: 9902         	ldr	r1, [sp, #0x8]
700a1b0e: f04f 3006    	mov.w	r0, #0x6060606
700a1b12: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1b14: 9802         	ldr	r0, [sp, #0x8]
700a1b16: 3804         	subs	r0, #0x4
700a1b18: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x05050505; /* R5 */
700a1b1a: 9902         	ldr	r1, [sp, #0x8]
700a1b1c: f04f 3005    	mov.w	r0, #0x5050505
700a1b20: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1b22: 9802         	ldr	r0, [sp, #0x8]
700a1b24: 3804         	subs	r0, #0x4
700a1b26: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x04040404; /* R4 */
700a1b28: 9902         	ldr	r1, [sp, #0x8]
700a1b2a: f04f 3004    	mov.w	r0, #0x4040404
700a1b2e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1b30: 9802         	ldr	r0, [sp, #0x8]
700a1b32: 3804         	subs	r0, #0x4
700a1b34: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x03030303; /* R3 */
700a1b36: 9902         	ldr	r1, [sp, #0x8]
700a1b38: f04f 3003    	mov.w	r0, #0x3030303
700a1b3c: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1b3e: 9802         	ldr	r0, [sp, #0x8]
700a1b40: 3804         	subs	r0, #0x4
700a1b42: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x02020202; /* R2 */
700a1b44: 9902         	ldr	r1, [sp, #0x8]
700a1b46: f04f 3002    	mov.w	r0, #0x2020202
700a1b4a: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1b4c: 9802         	ldr	r0, [sp, #0x8]
700a1b4e: 3804         	subs	r0, #0x4
700a1b50: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x01010101; /* R1 */
700a1b52: 9902         	ldr	r1, [sp, #0x8]
700a1b54: f04f 3001    	mov.w	r0, #0x1010101
700a1b58: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1b5a: 9802         	ldr	r0, [sp, #0x8]
700a1b5c: 3804         	subs	r0, #0x4
700a1b5e: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pvParameters; /* R0 */
700a1b60: 9800         	ldr	r0, [sp]
700a1b62: 9902         	ldr	r1, [sp, #0x8]
700a1b64: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1b66: 9802         	ldr	r0, [sp, #0x8]
700a1b68: 3804         	subs	r0, #0x4
700a1b6a: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
700a1b6c: 9902         	ldr	r1, [sp, #0x8]
700a1b6e: 2000         	movs	r0, #0x0
700a1b70: 6008         	str	r0, [r1]
;   return pxTopOfStack;
700a1b72: 9802         	ldr	r0, [sp, #0x8]
700a1b74: b003         	add	sp, #0xc
700a1b76: 4770         	bx	lr
		...

700a1b80 <Udma_rmAllocBlkCopyCh>:
; {
700a1b80: b580         	push	{r7, lr}
700a1b82: b088         	sub	sp, #0x20
700a1b84: 9007         	str	r0, [sp, #0x1c]
700a1b86: 9106         	str	r1, [sp, #0x18]
700a1b88: 2000         	movs	r0, #0x0
700a1b8a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1b8e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1b90: 9806         	ldr	r0, [sp, #0x18]
700a1b92: f500 70ea    	add.w	r0, r0, #0x1d4
700a1b96: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1b98: 9806         	ldr	r0, [sp, #0x18]
700a1b9a: f500 609f    	add.w	r0, r0, #0x4f8
700a1b9e: f04f 31ff    	mov.w	r1, #0xffffffff
700a1ba2: f006 fda5    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x6b4a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1ba6: 9807         	ldr	r0, [sp, #0x1c]
700a1ba8: 2101         	movs	r1, #0x1
700a1baa: f6cf 71ff    	movt	r1, #0xffff
700a1bae: 4288         	cmp	r0, r1
700a1bb0: d136         	bne	0x700a1c20 <Udma_rmAllocBlkCopyCh+0xa0> @ imm = #0x6c
700a1bb2: e7ff         	b	0x700a1bb4 <Udma_rmAllocBlkCopyCh+0x34> @ imm = #-0x2
700a1bb4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a1bb6: 9005         	str	r0, [sp, #0x14]
700a1bb8: e7ff         	b	0x700a1bba <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x2
700a1bba: 9805         	ldr	r0, [sp, #0x14]
700a1bbc: 9900         	ldr	r1, [sp]
700a1bbe: 6949         	ldr	r1, [r1, #0x14]
700a1bc0: 4288         	cmp	r0, r1
700a1bc2: d22c         	bhs	0x700a1c1e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x58
700a1bc4: e7ff         	b	0x700a1bc6 <Udma_rmAllocBlkCopyCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a1bc6: 9805         	ldr	r0, [sp, #0x14]
700a1bc8: 0940         	lsrs	r0, r0, #0x5
700a1bca: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1bcc: 9805         	ldr	r0, [sp, #0x14]
700a1bce: 9904         	ldr	r1, [sp, #0x10]
700a1bd0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1bd4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1bd6: 9903         	ldr	r1, [sp, #0xc]
700a1bd8: 2001         	movs	r0, #0x1
700a1bda: 4088         	lsls	r0, r1
700a1bdc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a1bde: 9806         	ldr	r0, [sp, #0x18]
700a1be0: 9904         	ldr	r1, [sp, #0x10]
700a1be2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1be6: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a1bea: 9902         	ldr	r1, [sp, #0x8]
700a1bec: 4008         	ands	r0, r1
700a1bee: 4288         	cmp	r0, r1
700a1bf0: d110         	bne	0x700a1c14 <Udma_rmAllocBlkCopyCh+0x94> @ imm = #0x20
700a1bf2: e7ff         	b	0x700a1bf4 <Udma_rmAllocBlkCopyCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a1bf4: 9a02         	ldr	r2, [sp, #0x8]
700a1bf6: 9806         	ldr	r0, [sp, #0x18]
700a1bf8: 9904         	ldr	r1, [sp, #0x10]
700a1bfa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1bfe: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a1c02: 4390         	bics	r0, r2
700a1c04: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = i + rmInitPrms->startBlkCopyCh;  /* Add start offset */
700a1c08: 9805         	ldr	r0, [sp, #0x14]
700a1c0a: 9900         	ldr	r1, [sp]
700a1c0c: 6909         	ldr	r1, [r1, #0x10]
700a1c0e: 4408         	add	r0, r1
700a1c10: 9001         	str	r0, [sp, #0x4]
;                 break;
700a1c12: e004         	b	0x700a1c1e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x8
;         }
700a1c14: e7ff         	b	0x700a1c16 <Udma_rmAllocBlkCopyCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a1c16: 9805         	ldr	r0, [sp, #0x14]
700a1c18: 3001         	adds	r0, #0x1
700a1c1a: 9005         	str	r0, [sp, #0x14]
700a1c1c: e7cd         	b	0x700a1bba <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x66
;     }
700a1c1e: e038         	b	0x700a1c92 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a1c20: 9807         	ldr	r0, [sp, #0x1c]
700a1c22: 9900         	ldr	r1, [sp]
700a1c24: 6909         	ldr	r1, [r1, #0x10]
700a1c26: 4288         	cmp	r0, r1
700a1c28: d332         	blo	0x700a1c90 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x64
700a1c2a: e7ff         	b	0x700a1c2c <Udma_rmAllocBlkCopyCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyCh + rmInitPrms->numBlkCopyCh)))
700a1c2c: 9807         	ldr	r0, [sp, #0x1c]
700a1c2e: 9a00         	ldr	r2, [sp]
700a1c30: 6911         	ldr	r1, [r2, #0x10]
700a1c32: 6952         	ldr	r2, [r2, #0x14]
700a1c34: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a1c36: 4288         	cmp	r0, r1
700a1c38: d22a         	bhs	0x700a1c90 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x54
700a1c3a: e7ff         	b	0x700a1c3c <Udma_rmAllocBlkCopyCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyCh;
700a1c3c: 9807         	ldr	r0, [sp, #0x1c]
700a1c3e: 9900         	ldr	r1, [sp]
700a1c40: 6909         	ldr	r1, [r1, #0x10]
700a1c42: 1a40         	subs	r0, r0, r1
700a1c44: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1c46: 9805         	ldr	r0, [sp, #0x14]
700a1c48: 0940         	lsrs	r0, r0, #0x5
700a1c4a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1c4c: 9805         	ldr	r0, [sp, #0x14]
700a1c4e: 9904         	ldr	r1, [sp, #0x10]
700a1c50: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1c54: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1c56: 9903         	ldr	r1, [sp, #0xc]
700a1c58: 2001         	movs	r0, #0x1
700a1c5a: 4088         	lsls	r0, r1
700a1c5c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a1c5e: 9806         	ldr	r0, [sp, #0x18]
700a1c60: 9904         	ldr	r1, [sp, #0x10]
700a1c62: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c66: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a1c6a: 9902         	ldr	r1, [sp, #0x8]
700a1c6c: 4008         	ands	r0, r1
700a1c6e: 4288         	cmp	r0, r1
700a1c70: d10d         	bne	0x700a1c8e <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #0x1a
700a1c72: e7ff         	b	0x700a1c74 <Udma_rmAllocBlkCopyCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a1c74: 9a02         	ldr	r2, [sp, #0x8]
700a1c76: 9806         	ldr	r0, [sp, #0x18]
700a1c78: 9904         	ldr	r1, [sp, #0x10]
700a1c7a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1c7e: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a1c82: 4390         	bics	r0, r2
700a1c84: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = preferredChNum;
700a1c88: 9807         	ldr	r0, [sp, #0x1c]
700a1c8a: 9001         	str	r0, [sp, #0x4]
;             }
700a1c8c: e7ff         	b	0x700a1c8e <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #-0x2
;         }
700a1c8e: e7ff         	b	0x700a1c90 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #-0x2
700a1c90: e7ff         	b	0x700a1c92 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1c92: 9806         	ldr	r0, [sp, #0x18]
700a1c94: f500 609f    	add.w	r0, r0, #0x4f8
700a1c98: f008 f882    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x8104
;     return (chNum);
700a1c9c: 9801         	ldr	r0, [sp, #0x4]
700a1c9e: b008         	add	sp, #0x20
700a1ca0: bd80         	pop	{r7, pc}
		...
700a1cae: 0000         	movs	r0, r0

700a1cb0 <Udma_rmAllocBlkCopyHcCh>:
; {
700a1cb0: b580         	push	{r7, lr}
700a1cb2: b088         	sub	sp, #0x20
700a1cb4: 9007         	str	r0, [sp, #0x1c]
700a1cb6: 9106         	str	r1, [sp, #0x18]
700a1cb8: 2000         	movs	r0, #0x0
700a1cba: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1cbe: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1cc0: 9806         	ldr	r0, [sp, #0x18]
700a1cc2: f500 70ea    	add.w	r0, r0, #0x1d4
700a1cc6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1cc8: 9806         	ldr	r0, [sp, #0x18]
700a1cca: f500 609f    	add.w	r0, r0, #0x4f8
700a1cce: f04f 31ff    	mov.w	r1, #0xffffffff
700a1cd2: f006 fd0d    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x6a1a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1cd6: 9807         	ldr	r0, [sp, #0x1c]
700a1cd8: 2101         	movs	r1, #0x1
700a1cda: f6cf 71ff    	movt	r1, #0xffff
700a1cde: 4288         	cmp	r0, r1
700a1ce0: d136         	bne	0x700a1d50 <Udma_rmAllocBlkCopyHcCh+0xa0> @ imm = #0x6c
700a1ce2: e7ff         	b	0x700a1ce4 <Udma_rmAllocBlkCopyHcCh+0x34> @ imm = #-0x2
700a1ce4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a1ce6: 9005         	str	r0, [sp, #0x14]
700a1ce8: e7ff         	b	0x700a1cea <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x2
700a1cea: 9805         	ldr	r0, [sp, #0x14]
700a1cec: 9900         	ldr	r1, [sp]
700a1cee: 68c9         	ldr	r1, [r1, #0xc]
700a1cf0: 4288         	cmp	r0, r1
700a1cf2: d22c         	bhs	0x700a1d4e <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x58
700a1cf4: e7ff         	b	0x700a1cf6 <Udma_rmAllocBlkCopyHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a1cf6: 9805         	ldr	r0, [sp, #0x14]
700a1cf8: 0940         	lsrs	r0, r0, #0x5
700a1cfa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1cfc: 9805         	ldr	r0, [sp, #0x14]
700a1cfe: 9904         	ldr	r1, [sp, #0x10]
700a1d00: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1d04: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1d06: 9903         	ldr	r1, [sp, #0xc]
700a1d08: 2001         	movs	r0, #0x1
700a1d0a: 4088         	lsls	r0, r1
700a1d0c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a1d0e: 9806         	ldr	r0, [sp, #0x18]
700a1d10: 9904         	ldr	r1, [sp, #0x10]
700a1d12: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1d16: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a1d1a: 9902         	ldr	r1, [sp, #0x8]
700a1d1c: 4008         	ands	r0, r1
700a1d1e: 4288         	cmp	r0, r1
700a1d20: d110         	bne	0x700a1d44 <Udma_rmAllocBlkCopyHcCh+0x94> @ imm = #0x20
700a1d22: e7ff         	b	0x700a1d24 <Udma_rmAllocBlkCopyHcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a1d24: 9a02         	ldr	r2, [sp, #0x8]
700a1d26: 9806         	ldr	r0, [sp, #0x18]
700a1d28: 9904         	ldr	r1, [sp, #0x10]
700a1d2a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1d2e: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a1d32: 4390         	bics	r0, r2
700a1d34: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = i + rmInitPrms->startBlkCopyHcCh;  /* Add start offset */
700a1d38: 9805         	ldr	r0, [sp, #0x14]
700a1d3a: 9900         	ldr	r1, [sp]
700a1d3c: 6889         	ldr	r1, [r1, #0x8]
700a1d3e: 4408         	add	r0, r1
700a1d40: 9001         	str	r0, [sp, #0x4]
;                 break;
700a1d42: e004         	b	0x700a1d4e <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x8
;         }
700a1d44: e7ff         	b	0x700a1d46 <Udma_rmAllocBlkCopyHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a1d46: 9805         	ldr	r0, [sp, #0x14]
700a1d48: 3001         	adds	r0, #0x1
700a1d4a: 9005         	str	r0, [sp, #0x14]
700a1d4c: e7cd         	b	0x700a1cea <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x66
;     }
700a1d4e: e038         	b	0x700a1dc2 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a1d50: 9807         	ldr	r0, [sp, #0x1c]
700a1d52: 9900         	ldr	r1, [sp]
700a1d54: 6889         	ldr	r1, [r1, #0x8]
700a1d56: 4288         	cmp	r0, r1
700a1d58: d332         	blo	0x700a1dc0 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x64
700a1d5a: e7ff         	b	0x700a1d5c <Udma_rmAllocBlkCopyHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyHcCh + rmInitPrms->numBlkCopyHcCh)))
700a1d5c: 9807         	ldr	r0, [sp, #0x1c]
700a1d5e: 9a00         	ldr	r2, [sp]
700a1d60: 6891         	ldr	r1, [r2, #0x8]
700a1d62: 68d2         	ldr	r2, [r2, #0xc]
700a1d64: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a1d66: 4288         	cmp	r0, r1
700a1d68: d22a         	bhs	0x700a1dc0 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x54
700a1d6a: e7ff         	b	0x700a1d6c <Udma_rmAllocBlkCopyHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyHcCh;
700a1d6c: 9807         	ldr	r0, [sp, #0x1c]
700a1d6e: 9900         	ldr	r1, [sp]
700a1d70: 6889         	ldr	r1, [r1, #0x8]
700a1d72: 1a40         	subs	r0, r0, r1
700a1d74: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1d76: 9805         	ldr	r0, [sp, #0x14]
700a1d78: 0940         	lsrs	r0, r0, #0x5
700a1d7a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1d7c: 9805         	ldr	r0, [sp, #0x14]
700a1d7e: 9904         	ldr	r1, [sp, #0x10]
700a1d80: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1d84: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1d86: 9903         	ldr	r1, [sp, #0xc]
700a1d88: 2001         	movs	r0, #0x1
700a1d8a: 4088         	lsls	r0, r1
700a1d8c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a1d8e: 9806         	ldr	r0, [sp, #0x18]
700a1d90: 9904         	ldr	r1, [sp, #0x10]
700a1d92: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1d96: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a1d9a: 9902         	ldr	r1, [sp, #0x8]
700a1d9c: 4008         	ands	r0, r1
700a1d9e: 4288         	cmp	r0, r1
700a1da0: d10d         	bne	0x700a1dbe <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #0x1a
700a1da2: e7ff         	b	0x700a1da4 <Udma_rmAllocBlkCopyHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a1da4: 9a02         	ldr	r2, [sp, #0x8]
700a1da6: 9806         	ldr	r0, [sp, #0x18]
700a1da8: 9904         	ldr	r1, [sp, #0x10]
700a1daa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1dae: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a1db2: 4390         	bics	r0, r2
700a1db4: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = preferredChNum;
700a1db8: 9807         	ldr	r0, [sp, #0x1c]
700a1dba: 9001         	str	r0, [sp, #0x4]
;             }
700a1dbc: e7ff         	b	0x700a1dbe <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #-0x2
;         }
700a1dbe: e7ff         	b	0x700a1dc0 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #-0x2
700a1dc0: e7ff         	b	0x700a1dc2 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1dc2: 9806         	ldr	r0, [sp, #0x18]
700a1dc4: f500 609f    	add.w	r0, r0, #0x4f8
700a1dc8: f007 ffea    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x7fd4
;     return (chNum);
700a1dcc: 9801         	ldr	r0, [sp, #0x4]
700a1dce: b008         	add	sp, #0x20
700a1dd0: bd80         	pop	{r7, pc}
		...
700a1dde: 0000         	movs	r0, r0

700a1de0 <Udma_rmAllocBlkCopyUhcCh>:
; {
700a1de0: b580         	push	{r7, lr}
700a1de2: b088         	sub	sp, #0x20
700a1de4: 9007         	str	r0, [sp, #0x1c]
700a1de6: 9106         	str	r1, [sp, #0x18]
700a1de8: 2000         	movs	r0, #0x0
700a1dea: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1dee: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1df0: 9806         	ldr	r0, [sp, #0x18]
700a1df2: f500 70ea    	add.w	r0, r0, #0x1d4
700a1df6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1df8: 9806         	ldr	r0, [sp, #0x18]
700a1dfa: f500 609f    	add.w	r0, r0, #0x4f8
700a1dfe: f04f 31ff    	mov.w	r1, #0xffffffff
700a1e02: f006 fc75    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x68ea
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1e06: 9807         	ldr	r0, [sp, #0x1c]
700a1e08: 2101         	movs	r1, #0x1
700a1e0a: f6cf 71ff    	movt	r1, #0xffff
700a1e0e: 4288         	cmp	r0, r1
700a1e10: d136         	bne	0x700a1e80 <Udma_rmAllocBlkCopyUhcCh+0xa0> @ imm = #0x6c
700a1e12: e7ff         	b	0x700a1e14 <Udma_rmAllocBlkCopyUhcCh+0x34> @ imm = #-0x2
700a1e14: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a1e16: 9005         	str	r0, [sp, #0x14]
700a1e18: e7ff         	b	0x700a1e1a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x2
700a1e1a: 9805         	ldr	r0, [sp, #0x14]
700a1e1c: 9900         	ldr	r1, [sp]
700a1e1e: 6849         	ldr	r1, [r1, #0x4]
700a1e20: 4288         	cmp	r0, r1
700a1e22: d22c         	bhs	0x700a1e7e <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x58
700a1e24: e7ff         	b	0x700a1e26 <Udma_rmAllocBlkCopyUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a1e26: 9805         	ldr	r0, [sp, #0x14]
700a1e28: 0940         	lsrs	r0, r0, #0x5
700a1e2a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1e2c: 9805         	ldr	r0, [sp, #0x14]
700a1e2e: 9904         	ldr	r1, [sp, #0x10]
700a1e30: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1e34: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1e36: 9903         	ldr	r1, [sp, #0xc]
700a1e38: 2001         	movs	r0, #0x1
700a1e3a: 4088         	lsls	r0, r1
700a1e3c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a1e3e: 9806         	ldr	r0, [sp, #0x18]
700a1e40: 9904         	ldr	r1, [sp, #0x10]
700a1e42: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1e46: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a1e4a: 9902         	ldr	r1, [sp, #0x8]
700a1e4c: 4008         	ands	r0, r1
700a1e4e: 4288         	cmp	r0, r1
700a1e50: d110         	bne	0x700a1e74 <Udma_rmAllocBlkCopyUhcCh+0x94> @ imm = #0x20
700a1e52: e7ff         	b	0x700a1e54 <Udma_rmAllocBlkCopyUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a1e54: 9a02         	ldr	r2, [sp, #0x8]
700a1e56: 9806         	ldr	r0, [sp, #0x18]
700a1e58: 9904         	ldr	r1, [sp, #0x10]
700a1e5a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1e5e: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a1e62: 4390         	bics	r0, r2
700a1e64: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = i + rmInitPrms->startBlkCopyUhcCh;  /* Add start offset */
700a1e68: 9805         	ldr	r0, [sp, #0x14]
700a1e6a: 9900         	ldr	r1, [sp]
700a1e6c: 6809         	ldr	r1, [r1]
700a1e6e: 4408         	add	r0, r1
700a1e70: 9001         	str	r0, [sp, #0x4]
;                 break;
700a1e72: e004         	b	0x700a1e7e <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x8
;         }
700a1e74: e7ff         	b	0x700a1e76 <Udma_rmAllocBlkCopyUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a1e76: 9805         	ldr	r0, [sp, #0x14]
700a1e78: 3001         	adds	r0, #0x1
700a1e7a: 9005         	str	r0, [sp, #0x14]
700a1e7c: e7cd         	b	0x700a1e1a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x66
;     }
700a1e7e: e038         	b	0x700a1ef2 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a1e80: 9807         	ldr	r0, [sp, #0x1c]
700a1e82: 9900         	ldr	r1, [sp]
700a1e84: 6809         	ldr	r1, [r1]
700a1e86: 4288         	cmp	r0, r1
700a1e88: d332         	blo	0x700a1ef0 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x64
700a1e8a: e7ff         	b	0x700a1e8c <Udma_rmAllocBlkCopyUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyUhcCh + rmInitPrms->numBlkCopyUhcCh)))
700a1e8c: 9807         	ldr	r0, [sp, #0x1c]
700a1e8e: 9a00         	ldr	r2, [sp]
700a1e90: 6811         	ldr	r1, [r2]
700a1e92: 6852         	ldr	r2, [r2, #0x4]
700a1e94: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a1e96: 4288         	cmp	r0, r1
700a1e98: d22a         	bhs	0x700a1ef0 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x54
700a1e9a: e7ff         	b	0x700a1e9c <Udma_rmAllocBlkCopyUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyUhcCh;
700a1e9c: 9807         	ldr	r0, [sp, #0x1c]
700a1e9e: 9900         	ldr	r1, [sp]
700a1ea0: 6809         	ldr	r1, [r1]
700a1ea2: 1a40         	subs	r0, r0, r1
700a1ea4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1ea6: 9805         	ldr	r0, [sp, #0x14]
700a1ea8: 0940         	lsrs	r0, r0, #0x5
700a1eaa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1eac: 9805         	ldr	r0, [sp, #0x14]
700a1eae: 9904         	ldr	r1, [sp, #0x10]
700a1eb0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1eb4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1eb6: 9903         	ldr	r1, [sp, #0xc]
700a1eb8: 2001         	movs	r0, #0x1
700a1eba: 4088         	lsls	r0, r1
700a1ebc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a1ebe: 9806         	ldr	r0, [sp, #0x18]
700a1ec0: 9904         	ldr	r1, [sp, #0x10]
700a1ec2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1ec6: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a1eca: 9902         	ldr	r1, [sp, #0x8]
700a1ecc: 4008         	ands	r0, r1
700a1ece: 4288         	cmp	r0, r1
700a1ed0: d10d         	bne	0x700a1eee <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #0x1a
700a1ed2: e7ff         	b	0x700a1ed4 <Udma_rmAllocBlkCopyUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a1ed4: 9a02         	ldr	r2, [sp, #0x8]
700a1ed6: 9806         	ldr	r0, [sp, #0x18]
700a1ed8: 9904         	ldr	r1, [sp, #0x10]
700a1eda: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1ede: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a1ee2: 4390         	bics	r0, r2
700a1ee4: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = preferredChNum;
700a1ee8: 9807         	ldr	r0, [sp, #0x1c]
700a1eea: 9001         	str	r0, [sp, #0x4]
;             }
700a1eec: e7ff         	b	0x700a1eee <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #-0x2
;         }
700a1eee: e7ff         	b	0x700a1ef0 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #-0x2
700a1ef0: e7ff         	b	0x700a1ef2 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1ef2: 9806         	ldr	r0, [sp, #0x18]
700a1ef4: f500 609f    	add.w	r0, r0, #0x4f8
700a1ef8: f007 ff52    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x7ea4
;     return (chNum);
700a1efc: 9801         	ldr	r0, [sp, #0x4]
700a1efe: b008         	add	sp, #0x20
700a1f00: bd80         	pop	{r7, pc}
		...
700a1f0e: 0000         	movs	r0, r0

700a1f10 <Udma_rmAllocRxCh>:
; {
700a1f10: b580         	push	{r7, lr}
700a1f12: b088         	sub	sp, #0x20
700a1f14: 9007         	str	r0, [sp, #0x1c]
700a1f16: 9106         	str	r1, [sp, #0x18]
700a1f18: 2000         	movs	r0, #0x0
700a1f1a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1f1e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1f20: 9806         	ldr	r0, [sp, #0x18]
700a1f22: f500 70ea    	add.w	r0, r0, #0x1d4
700a1f26: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1f28: 9806         	ldr	r0, [sp, #0x18]
700a1f2a: f500 609f    	add.w	r0, r0, #0x4f8
700a1f2e: f04f 31ff    	mov.w	r1, #0xffffffff
700a1f32: f006 fbdd    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x67ba
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1f36: 9807         	ldr	r0, [sp, #0x1c]
700a1f38: 2101         	movs	r1, #0x1
700a1f3a: f6cf 71ff    	movt	r1, #0xffff
700a1f3e: 4288         	cmp	r0, r1
700a1f40: d136         	bne	0x700a1fb0 <Udma_rmAllocRxCh+0xa0> @ imm = #0x6c
700a1f42: e7ff         	b	0x700a1f44 <Udma_rmAllocRxCh+0x34> @ imm = #-0x2
700a1f44: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a1f46: 9005         	str	r0, [sp, #0x14]
700a1f48: e7ff         	b	0x700a1f4a <Udma_rmAllocRxCh+0x3a> @ imm = #-0x2
700a1f4a: 9805         	ldr	r0, [sp, #0x14]
700a1f4c: 9900         	ldr	r1, [sp]
700a1f4e: 6c49         	ldr	r1, [r1, #0x44]
700a1f50: 4288         	cmp	r0, r1
700a1f52: d22c         	bhs	0x700a1fae <Udma_rmAllocRxCh+0x9e> @ imm = #0x58
700a1f54: e7ff         	b	0x700a1f56 <Udma_rmAllocRxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a1f56: 9805         	ldr	r0, [sp, #0x14]
700a1f58: 0940         	lsrs	r0, r0, #0x5
700a1f5a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1f5c: 9805         	ldr	r0, [sp, #0x14]
700a1f5e: 9904         	ldr	r1, [sp, #0x10]
700a1f60: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1f64: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1f66: 9903         	ldr	r1, [sp, #0xc]
700a1f68: 2001         	movs	r0, #0x1
700a1f6a: 4088         	lsls	r0, r1
700a1f6c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a1f6e: 9806         	ldr	r0, [sp, #0x18]
700a1f70: 9904         	ldr	r1, [sp, #0x10]
700a1f72: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1f76: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a1f7a: 9902         	ldr	r1, [sp, #0x8]
700a1f7c: 4008         	ands	r0, r1
700a1f7e: 4288         	cmp	r0, r1
700a1f80: d110         	bne	0x700a1fa4 <Udma_rmAllocRxCh+0x94> @ imm = #0x20
700a1f82: e7ff         	b	0x700a1f84 <Udma_rmAllocRxCh+0x74> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a1f84: 9a02         	ldr	r2, [sp, #0x8]
700a1f86: 9806         	ldr	r0, [sp, #0x18]
700a1f88: 9904         	ldr	r1, [sp, #0x10]
700a1f8a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1f8e: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a1f92: 4390         	bics	r0, r2
700a1f94: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = i + rmInitPrms->startRxCh;  /* Add start offset */
700a1f98: 9805         	ldr	r0, [sp, #0x14]
700a1f9a: 9900         	ldr	r1, [sp]
700a1f9c: 6c09         	ldr	r1, [r1, #0x40]
700a1f9e: 4408         	add	r0, r1
700a1fa0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a1fa2: e004         	b	0x700a1fae <Udma_rmAllocRxCh+0x9e> @ imm = #0x8
;         }
700a1fa4: e7ff         	b	0x700a1fa6 <Udma_rmAllocRxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a1fa6: 9805         	ldr	r0, [sp, #0x14]
700a1fa8: 3001         	adds	r0, #0x1
700a1faa: 9005         	str	r0, [sp, #0x14]
700a1fac: e7cd         	b	0x700a1f4a <Udma_rmAllocRxCh+0x3a> @ imm = #-0x66
;     }
700a1fae: e038         	b	0x700a2022 <Udma_rmAllocRxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a1fb0: 9807         	ldr	r0, [sp, #0x1c]
700a1fb2: 9900         	ldr	r1, [sp]
700a1fb4: 6c09         	ldr	r1, [r1, #0x40]
700a1fb6: 4288         	cmp	r0, r1
700a1fb8: d332         	blo	0x700a2020 <Udma_rmAllocRxCh+0x110> @ imm = #0x64
700a1fba: e7ff         	b	0x700a1fbc <Udma_rmAllocRxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxCh + rmInitPrms->numRxCh)))
700a1fbc: 9807         	ldr	r0, [sp, #0x1c]
700a1fbe: 9a00         	ldr	r2, [sp]
700a1fc0: 6c11         	ldr	r1, [r2, #0x40]
700a1fc2: 6c52         	ldr	r2, [r2, #0x44]
700a1fc4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a1fc6: 4288         	cmp	r0, r1
700a1fc8: d22a         	bhs	0x700a2020 <Udma_rmAllocRxCh+0x110> @ imm = #0x54
700a1fca: e7ff         	b	0x700a1fcc <Udma_rmAllocRxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxCh;
700a1fcc: 9807         	ldr	r0, [sp, #0x1c]
700a1fce: 9900         	ldr	r1, [sp]
700a1fd0: 6c09         	ldr	r1, [r1, #0x40]
700a1fd2: 1a40         	subs	r0, r0, r1
700a1fd4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1fd6: 9805         	ldr	r0, [sp, #0x14]
700a1fd8: 0940         	lsrs	r0, r0, #0x5
700a1fda: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1fdc: 9805         	ldr	r0, [sp, #0x14]
700a1fde: 9904         	ldr	r1, [sp, #0x10]
700a1fe0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1fe4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1fe6: 9903         	ldr	r1, [sp, #0xc]
700a1fe8: 2001         	movs	r0, #0x1
700a1fea: 4088         	lsls	r0, r1
700a1fec: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a1fee: 9806         	ldr	r0, [sp, #0x18]
700a1ff0: 9904         	ldr	r1, [sp, #0x10]
700a1ff2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1ff6: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a1ffa: 9902         	ldr	r1, [sp, #0x8]
700a1ffc: 4008         	ands	r0, r1
700a1ffe: 4288         	cmp	r0, r1
700a2000: d10d         	bne	0x700a201e <Udma_rmAllocRxCh+0x10e> @ imm = #0x1a
700a2002: e7ff         	b	0x700a2004 <Udma_rmAllocRxCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a2004: 9a02         	ldr	r2, [sp, #0x8]
700a2006: 9806         	ldr	r0, [sp, #0x18]
700a2008: 9904         	ldr	r1, [sp, #0x10]
700a200a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a200e: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a2012: 4390         	bics	r0, r2
700a2014: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = preferredChNum;
700a2018: 9807         	ldr	r0, [sp, #0x1c]
700a201a: 9001         	str	r0, [sp, #0x4]
;             }
700a201c: e7ff         	b	0x700a201e <Udma_rmAllocRxCh+0x10e> @ imm = #-0x2
;         }
700a201e: e7ff         	b	0x700a2020 <Udma_rmAllocRxCh+0x110> @ imm = #-0x2
700a2020: e7ff         	b	0x700a2022 <Udma_rmAllocRxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2022: 9806         	ldr	r0, [sp, #0x18]
700a2024: f500 609f    	add.w	r0, r0, #0x4f8
700a2028: f007 feba    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x7d74
;     return (chNum);
700a202c: 9801         	ldr	r0, [sp, #0x4]
700a202e: b008         	add	sp, #0x20
700a2030: bd80         	pop	{r7, pc}
		...
700a203e: 0000         	movs	r0, r0

700a2040 <Udma_rmAllocRxHcCh>:
; {
700a2040: b580         	push	{r7, lr}
700a2042: b088         	sub	sp, #0x20
700a2044: 9007         	str	r0, [sp, #0x1c]
700a2046: 9106         	str	r1, [sp, #0x18]
700a2048: 2000         	movs	r0, #0x0
700a204a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a204e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2050: 9806         	ldr	r0, [sp, #0x18]
700a2052: f500 70ea    	add.w	r0, r0, #0x1d4
700a2056: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2058: 9806         	ldr	r0, [sp, #0x18]
700a205a: f500 609f    	add.w	r0, r0, #0x4f8
700a205e: f04f 31ff    	mov.w	r1, #0xffffffff
700a2062: f006 fb45    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x668a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2066: 9807         	ldr	r0, [sp, #0x1c]
700a2068: 2101         	movs	r1, #0x1
700a206a: f6cf 71ff    	movt	r1, #0xffff
700a206e: 4288         	cmp	r0, r1
700a2070: d136         	bne	0x700a20e0 <Udma_rmAllocRxHcCh+0xa0> @ imm = #0x6c
700a2072: e7ff         	b	0x700a2074 <Udma_rmAllocRxHcCh+0x34> @ imm = #-0x2
700a2074: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a2076: 9005         	str	r0, [sp, #0x14]
700a2078: e7ff         	b	0x700a207a <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x2
700a207a: 9805         	ldr	r0, [sp, #0x14]
700a207c: 9900         	ldr	r1, [sp]
700a207e: 6bc9         	ldr	r1, [r1, #0x3c]
700a2080: 4288         	cmp	r0, r1
700a2082: d22c         	bhs	0x700a20de <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x58
700a2084: e7ff         	b	0x700a2086 <Udma_rmAllocRxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2086: 9805         	ldr	r0, [sp, #0x14]
700a2088: 0940         	lsrs	r0, r0, #0x5
700a208a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a208c: 9805         	ldr	r0, [sp, #0x14]
700a208e: 9904         	ldr	r1, [sp, #0x10]
700a2090: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2094: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2096: 9903         	ldr	r1, [sp, #0xc]
700a2098: 2001         	movs	r0, #0x1
700a209a: 4088         	lsls	r0, r1
700a209c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a209e: 9806         	ldr	r0, [sp, #0x18]
700a20a0: 9904         	ldr	r1, [sp, #0x10]
700a20a2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a20a6: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a20aa: 9902         	ldr	r1, [sp, #0x8]
700a20ac: 4008         	ands	r0, r1
700a20ae: 4288         	cmp	r0, r1
700a20b0: d110         	bne	0x700a20d4 <Udma_rmAllocRxHcCh+0x94> @ imm = #0x20
700a20b2: e7ff         	b	0x700a20b4 <Udma_rmAllocRxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a20b4: 9a02         	ldr	r2, [sp, #0x8]
700a20b6: 9806         	ldr	r0, [sp, #0x18]
700a20b8: 9904         	ldr	r1, [sp, #0x10]
700a20ba: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a20be: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a20c2: 4390         	bics	r0, r2
700a20c4: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = i + rmInitPrms->startRxHcCh;  /* Add start offset */
700a20c8: 9805         	ldr	r0, [sp, #0x14]
700a20ca: 9900         	ldr	r1, [sp]
700a20cc: 6b89         	ldr	r1, [r1, #0x38]
700a20ce: 4408         	add	r0, r1
700a20d0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a20d2: e004         	b	0x700a20de <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x8
;         }
700a20d4: e7ff         	b	0x700a20d6 <Udma_rmAllocRxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a20d6: 9805         	ldr	r0, [sp, #0x14]
700a20d8: 3001         	adds	r0, #0x1
700a20da: 9005         	str	r0, [sp, #0x14]
700a20dc: e7cd         	b	0x700a207a <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x66
;     }
700a20de: e038         	b	0x700a2152 <Udma_rmAllocRxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a20e0: 9807         	ldr	r0, [sp, #0x1c]
700a20e2: 9900         	ldr	r1, [sp]
700a20e4: 6b89         	ldr	r1, [r1, #0x38]
700a20e6: 4288         	cmp	r0, r1
700a20e8: d332         	blo	0x700a2150 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x64
700a20ea: e7ff         	b	0x700a20ec <Udma_rmAllocRxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxHcCh + rmInitPrms->numRxHcCh)))
700a20ec: 9807         	ldr	r0, [sp, #0x1c]
700a20ee: 9a00         	ldr	r2, [sp]
700a20f0: 6b91         	ldr	r1, [r2, #0x38]
700a20f2: 6bd2         	ldr	r2, [r2, #0x3c]
700a20f4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a20f6: 4288         	cmp	r0, r1
700a20f8: d22a         	bhs	0x700a2150 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x54
700a20fa: e7ff         	b	0x700a20fc <Udma_rmAllocRxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxHcCh;
700a20fc: 9807         	ldr	r0, [sp, #0x1c]
700a20fe: 9900         	ldr	r1, [sp]
700a2100: 6b89         	ldr	r1, [r1, #0x38]
700a2102: 1a40         	subs	r0, r0, r1
700a2104: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2106: 9805         	ldr	r0, [sp, #0x14]
700a2108: 0940         	lsrs	r0, r0, #0x5
700a210a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a210c: 9805         	ldr	r0, [sp, #0x14]
700a210e: 9904         	ldr	r1, [sp, #0x10]
700a2110: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2114: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2116: 9903         	ldr	r1, [sp, #0xc]
700a2118: 2001         	movs	r0, #0x1
700a211a: 4088         	lsls	r0, r1
700a211c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a211e: 9806         	ldr	r0, [sp, #0x18]
700a2120: 9904         	ldr	r1, [sp, #0x10]
700a2122: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2126: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a212a: 9902         	ldr	r1, [sp, #0x8]
700a212c: 4008         	ands	r0, r1
700a212e: 4288         	cmp	r0, r1
700a2130: d10d         	bne	0x700a214e <Udma_rmAllocRxHcCh+0x10e> @ imm = #0x1a
700a2132: e7ff         	b	0x700a2134 <Udma_rmAllocRxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a2134: 9a02         	ldr	r2, [sp, #0x8]
700a2136: 9806         	ldr	r0, [sp, #0x18]
700a2138: 9904         	ldr	r1, [sp, #0x10]
700a213a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a213e: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a2142: 4390         	bics	r0, r2
700a2144: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = preferredChNum;
700a2148: 9807         	ldr	r0, [sp, #0x1c]
700a214a: 9001         	str	r0, [sp, #0x4]
;             }
700a214c: e7ff         	b	0x700a214e <Udma_rmAllocRxHcCh+0x10e> @ imm = #-0x2
;         }
700a214e: e7ff         	b	0x700a2150 <Udma_rmAllocRxHcCh+0x110> @ imm = #-0x2
700a2150: e7ff         	b	0x700a2152 <Udma_rmAllocRxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2152: 9806         	ldr	r0, [sp, #0x18]
700a2154: f500 609f    	add.w	r0, r0, #0x4f8
700a2158: f007 fe22    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x7c44
;     return (chNum);
700a215c: 9801         	ldr	r0, [sp, #0x4]
700a215e: b008         	add	sp, #0x20
700a2160: bd80         	pop	{r7, pc}
		...
700a216e: 0000         	movs	r0, r0

700a2170 <Udma_rmAllocRxUhcCh>:
; {
700a2170: b580         	push	{r7, lr}
700a2172: b088         	sub	sp, #0x20
700a2174: 9007         	str	r0, [sp, #0x1c]
700a2176: 9106         	str	r1, [sp, #0x18]
700a2178: 2000         	movs	r0, #0x0
700a217a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a217e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2180: 9806         	ldr	r0, [sp, #0x18]
700a2182: f500 70ea    	add.w	r0, r0, #0x1d4
700a2186: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2188: 9806         	ldr	r0, [sp, #0x18]
700a218a: f500 609f    	add.w	r0, r0, #0x4f8
700a218e: f04f 31ff    	mov.w	r1, #0xffffffff
700a2192: f006 faad    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x655a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2196: 9807         	ldr	r0, [sp, #0x1c]
700a2198: 2101         	movs	r1, #0x1
700a219a: f6cf 71ff    	movt	r1, #0xffff
700a219e: 4288         	cmp	r0, r1
700a21a0: d136         	bne	0x700a2210 <Udma_rmAllocRxUhcCh+0xa0> @ imm = #0x6c
700a21a2: e7ff         	b	0x700a21a4 <Udma_rmAllocRxUhcCh+0x34> @ imm = #-0x2
700a21a4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a21a6: 9005         	str	r0, [sp, #0x14]
700a21a8: e7ff         	b	0x700a21aa <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x2
700a21aa: 9805         	ldr	r0, [sp, #0x14]
700a21ac: 9900         	ldr	r1, [sp]
700a21ae: 6b49         	ldr	r1, [r1, #0x34]
700a21b0: 4288         	cmp	r0, r1
700a21b2: d22c         	bhs	0x700a220e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x58
700a21b4: e7ff         	b	0x700a21b6 <Udma_rmAllocRxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a21b6: 9805         	ldr	r0, [sp, #0x14]
700a21b8: 0940         	lsrs	r0, r0, #0x5
700a21ba: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a21bc: 9805         	ldr	r0, [sp, #0x14]
700a21be: 9904         	ldr	r1, [sp, #0x10]
700a21c0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a21c4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a21c6: 9903         	ldr	r1, [sp, #0xc]
700a21c8: 2001         	movs	r0, #0x1
700a21ca: 4088         	lsls	r0, r1
700a21cc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a21ce: 9806         	ldr	r0, [sp, #0x18]
700a21d0: 9904         	ldr	r1, [sp, #0x10]
700a21d2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a21d6: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a21da: 9902         	ldr	r1, [sp, #0x8]
700a21dc: 4008         	ands	r0, r1
700a21de: 4288         	cmp	r0, r1
700a21e0: d110         	bne	0x700a2204 <Udma_rmAllocRxUhcCh+0x94> @ imm = #0x20
700a21e2: e7ff         	b	0x700a21e4 <Udma_rmAllocRxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a21e4: 9a02         	ldr	r2, [sp, #0x8]
700a21e6: 9806         	ldr	r0, [sp, #0x18]
700a21e8: 9904         	ldr	r1, [sp, #0x10]
700a21ea: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a21ee: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a21f2: 4390         	bics	r0, r2
700a21f4: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = i + rmInitPrms->startRxUhcCh;  /* Add start offset */
700a21f8: 9805         	ldr	r0, [sp, #0x14]
700a21fa: 9900         	ldr	r1, [sp]
700a21fc: 6b09         	ldr	r1, [r1, #0x30]
700a21fe: 4408         	add	r0, r1
700a2200: 9001         	str	r0, [sp, #0x4]
;                 break;
700a2202: e004         	b	0x700a220e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x8
;         }
700a2204: e7ff         	b	0x700a2206 <Udma_rmAllocRxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a2206: 9805         	ldr	r0, [sp, #0x14]
700a2208: 3001         	adds	r0, #0x1
700a220a: 9005         	str	r0, [sp, #0x14]
700a220c: e7cd         	b	0x700a21aa <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x66
;     }
700a220e: e038         	b	0x700a2282 <Udma_rmAllocRxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a2210: 9807         	ldr	r0, [sp, #0x1c]
700a2212: 9900         	ldr	r1, [sp]
700a2214: 6b09         	ldr	r1, [r1, #0x30]
700a2216: 4288         	cmp	r0, r1
700a2218: d332         	blo	0x700a2280 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x64
700a221a: e7ff         	b	0x700a221c <Udma_rmAllocRxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxUhcCh + rmInitPrms->numRxUhcCh)))
700a221c: 9807         	ldr	r0, [sp, #0x1c]
700a221e: 9a00         	ldr	r2, [sp]
700a2220: 6b11         	ldr	r1, [r2, #0x30]
700a2222: 6b52         	ldr	r2, [r2, #0x34]
700a2224: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a2226: 4288         	cmp	r0, r1
700a2228: d22a         	bhs	0x700a2280 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x54
700a222a: e7ff         	b	0x700a222c <Udma_rmAllocRxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxUhcCh;
700a222c: 9807         	ldr	r0, [sp, #0x1c]
700a222e: 9900         	ldr	r1, [sp]
700a2230: 6b09         	ldr	r1, [r1, #0x30]
700a2232: 1a40         	subs	r0, r0, r1
700a2234: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2236: 9805         	ldr	r0, [sp, #0x14]
700a2238: 0940         	lsrs	r0, r0, #0x5
700a223a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a223c: 9805         	ldr	r0, [sp, #0x14]
700a223e: 9904         	ldr	r1, [sp, #0x10]
700a2240: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2244: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2246: 9903         	ldr	r1, [sp, #0xc]
700a2248: 2001         	movs	r0, #0x1
700a224a: 4088         	lsls	r0, r1
700a224c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a224e: 9806         	ldr	r0, [sp, #0x18]
700a2250: 9904         	ldr	r1, [sp, #0x10]
700a2252: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2256: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a225a: 9902         	ldr	r1, [sp, #0x8]
700a225c: 4008         	ands	r0, r1
700a225e: 4288         	cmp	r0, r1
700a2260: d10d         	bne	0x700a227e <Udma_rmAllocRxUhcCh+0x10e> @ imm = #0x1a
700a2262: e7ff         	b	0x700a2264 <Udma_rmAllocRxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a2264: 9a02         	ldr	r2, [sp, #0x8]
700a2266: 9806         	ldr	r0, [sp, #0x18]
700a2268: 9904         	ldr	r1, [sp, #0x10]
700a226a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a226e: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a2272: 4390         	bics	r0, r2
700a2274: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = preferredChNum;
700a2278: 9807         	ldr	r0, [sp, #0x1c]
700a227a: 9001         	str	r0, [sp, #0x4]
;             }
700a227c: e7ff         	b	0x700a227e <Udma_rmAllocRxUhcCh+0x10e> @ imm = #-0x2
;         }
700a227e: e7ff         	b	0x700a2280 <Udma_rmAllocRxUhcCh+0x110> @ imm = #-0x2
700a2280: e7ff         	b	0x700a2282 <Udma_rmAllocRxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2282: 9806         	ldr	r0, [sp, #0x18]
700a2284: f500 609f    	add.w	r0, r0, #0x4f8
700a2288: f007 fd8a    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x7b14
;     return (chNum);
700a228c: 9801         	ldr	r0, [sp, #0x4]
700a228e: b008         	add	sp, #0x20
700a2290: bd80         	pop	{r7, pc}
		...
700a229e: 0000         	movs	r0, r0

700a22a0 <Udma_rmAllocTxCh>:
; {
700a22a0: b580         	push	{r7, lr}
700a22a2: b088         	sub	sp, #0x20
700a22a4: 9007         	str	r0, [sp, #0x1c]
700a22a6: 9106         	str	r1, [sp, #0x18]
700a22a8: 2000         	movs	r0, #0x0
700a22aa: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a22ae: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a22b0: 9806         	ldr	r0, [sp, #0x18]
700a22b2: f500 70ea    	add.w	r0, r0, #0x1d4
700a22b6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a22b8: 9806         	ldr	r0, [sp, #0x18]
700a22ba: f500 609f    	add.w	r0, r0, #0x4f8
700a22be: f04f 31ff    	mov.w	r1, #0xffffffff
700a22c2: f006 fa15    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x642a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a22c6: 9807         	ldr	r0, [sp, #0x1c]
700a22c8: 2101         	movs	r1, #0x1
700a22ca: f6cf 71ff    	movt	r1, #0xffff
700a22ce: 4288         	cmp	r0, r1
700a22d0: d136         	bne	0x700a2340 <Udma_rmAllocTxCh+0xa0> @ imm = #0x6c
700a22d2: e7ff         	b	0x700a22d4 <Udma_rmAllocTxCh+0x34> @ imm = #-0x2
700a22d4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a22d6: 9005         	str	r0, [sp, #0x14]
700a22d8: e7ff         	b	0x700a22da <Udma_rmAllocTxCh+0x3a> @ imm = #-0x2
700a22da: 9805         	ldr	r0, [sp, #0x14]
700a22dc: 9900         	ldr	r1, [sp]
700a22de: 6ac9         	ldr	r1, [r1, #0x2c]
700a22e0: 4288         	cmp	r0, r1
700a22e2: d22c         	bhs	0x700a233e <Udma_rmAllocTxCh+0x9e> @ imm = #0x58
700a22e4: e7ff         	b	0x700a22e6 <Udma_rmAllocTxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a22e6: 9805         	ldr	r0, [sp, #0x14]
700a22e8: 0940         	lsrs	r0, r0, #0x5
700a22ea: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a22ec: 9805         	ldr	r0, [sp, #0x14]
700a22ee: 9904         	ldr	r1, [sp, #0x10]
700a22f0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a22f4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a22f6: 9903         	ldr	r1, [sp, #0xc]
700a22f8: 2001         	movs	r0, #0x1
700a22fa: 4088         	lsls	r0, r1
700a22fc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a22fe: 9806         	ldr	r0, [sp, #0x18]
700a2300: 9904         	ldr	r1, [sp, #0x10]
700a2302: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2306: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a230a: 9902         	ldr	r1, [sp, #0x8]
700a230c: 4008         	ands	r0, r1
700a230e: 4288         	cmp	r0, r1
700a2310: d110         	bne	0x700a2334 <Udma_rmAllocTxCh+0x94> @ imm = #0x20
700a2312: e7ff         	b	0x700a2314 <Udma_rmAllocTxCh+0x74> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a2314: 9a02         	ldr	r2, [sp, #0x8]
700a2316: 9806         	ldr	r0, [sp, #0x18]
700a2318: 9904         	ldr	r1, [sp, #0x10]
700a231a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a231e: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a2322: 4390         	bics	r0, r2
700a2324: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = i + rmInitPrms->startTxCh;  /* Add start offset */
700a2328: 9805         	ldr	r0, [sp, #0x14]
700a232a: 9900         	ldr	r1, [sp]
700a232c: 6a89         	ldr	r1, [r1, #0x28]
700a232e: 4408         	add	r0, r1
700a2330: 9001         	str	r0, [sp, #0x4]
;                 break;
700a2332: e004         	b	0x700a233e <Udma_rmAllocTxCh+0x9e> @ imm = #0x8
;         }
700a2334: e7ff         	b	0x700a2336 <Udma_rmAllocTxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a2336: 9805         	ldr	r0, [sp, #0x14]
700a2338: 3001         	adds	r0, #0x1
700a233a: 9005         	str	r0, [sp, #0x14]
700a233c: e7cd         	b	0x700a22da <Udma_rmAllocTxCh+0x3a> @ imm = #-0x66
;     }
700a233e: e038         	b	0x700a23b2 <Udma_rmAllocTxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a2340: 9807         	ldr	r0, [sp, #0x1c]
700a2342: 9900         	ldr	r1, [sp]
700a2344: 6a89         	ldr	r1, [r1, #0x28]
700a2346: 4288         	cmp	r0, r1
700a2348: d332         	blo	0x700a23b0 <Udma_rmAllocTxCh+0x110> @ imm = #0x64
700a234a: e7ff         	b	0x700a234c <Udma_rmAllocTxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxCh + rmInitPrms->numTxCh)))
700a234c: 9807         	ldr	r0, [sp, #0x1c]
700a234e: 9a00         	ldr	r2, [sp]
700a2350: 6a91         	ldr	r1, [r2, #0x28]
700a2352: 6ad2         	ldr	r2, [r2, #0x2c]
700a2354: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a2356: 4288         	cmp	r0, r1
700a2358: d22a         	bhs	0x700a23b0 <Udma_rmAllocTxCh+0x110> @ imm = #0x54
700a235a: e7ff         	b	0x700a235c <Udma_rmAllocTxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxCh;
700a235c: 9807         	ldr	r0, [sp, #0x1c]
700a235e: 9900         	ldr	r1, [sp]
700a2360: 6a89         	ldr	r1, [r1, #0x28]
700a2362: 1a40         	subs	r0, r0, r1
700a2364: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2366: 9805         	ldr	r0, [sp, #0x14]
700a2368: 0940         	lsrs	r0, r0, #0x5
700a236a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a236c: 9805         	ldr	r0, [sp, #0x14]
700a236e: 9904         	ldr	r1, [sp, #0x10]
700a2370: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2374: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2376: 9903         	ldr	r1, [sp, #0xc]
700a2378: 2001         	movs	r0, #0x1
700a237a: 4088         	lsls	r0, r1
700a237c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a237e: 9806         	ldr	r0, [sp, #0x18]
700a2380: 9904         	ldr	r1, [sp, #0x10]
700a2382: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2386: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a238a: 9902         	ldr	r1, [sp, #0x8]
700a238c: 4008         	ands	r0, r1
700a238e: 4288         	cmp	r0, r1
700a2390: d10d         	bne	0x700a23ae <Udma_rmAllocTxCh+0x10e> @ imm = #0x1a
700a2392: e7ff         	b	0x700a2394 <Udma_rmAllocTxCh+0xf4> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a2394: 9a02         	ldr	r2, [sp, #0x8]
700a2396: 9806         	ldr	r0, [sp, #0x18]
700a2398: 9904         	ldr	r1, [sp, #0x10]
700a239a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a239e: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a23a2: 4390         	bics	r0, r2
700a23a4: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = preferredChNum;
700a23a8: 9807         	ldr	r0, [sp, #0x1c]
700a23aa: 9001         	str	r0, [sp, #0x4]
;             }
700a23ac: e7ff         	b	0x700a23ae <Udma_rmAllocTxCh+0x10e> @ imm = #-0x2
;         }
700a23ae: e7ff         	b	0x700a23b0 <Udma_rmAllocTxCh+0x110> @ imm = #-0x2
700a23b0: e7ff         	b	0x700a23b2 <Udma_rmAllocTxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a23b2: 9806         	ldr	r0, [sp, #0x18]
700a23b4: f500 609f    	add.w	r0, r0, #0x4f8
700a23b8: f007 fcf2    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x79e4
;     return (chNum);
700a23bc: 9801         	ldr	r0, [sp, #0x4]
700a23be: b008         	add	sp, #0x20
700a23c0: bd80         	pop	{r7, pc}
		...
700a23ce: 0000         	movs	r0, r0

700a23d0 <Udma_rmAllocTxHcCh>:
; {
700a23d0: b580         	push	{r7, lr}
700a23d2: b088         	sub	sp, #0x20
700a23d4: 9007         	str	r0, [sp, #0x1c]
700a23d6: 9106         	str	r1, [sp, #0x18]
700a23d8: 2000         	movs	r0, #0x0
700a23da: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a23de: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a23e0: 9806         	ldr	r0, [sp, #0x18]
700a23e2: f500 70ea    	add.w	r0, r0, #0x1d4
700a23e6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a23e8: 9806         	ldr	r0, [sp, #0x18]
700a23ea: f500 609f    	add.w	r0, r0, #0x4f8
700a23ee: f04f 31ff    	mov.w	r1, #0xffffffff
700a23f2: f006 f97d    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x62fa
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a23f6: 9807         	ldr	r0, [sp, #0x1c]
700a23f8: 2101         	movs	r1, #0x1
700a23fa: f6cf 71ff    	movt	r1, #0xffff
700a23fe: 4288         	cmp	r0, r1
700a2400: d136         	bne	0x700a2470 <Udma_rmAllocTxHcCh+0xa0> @ imm = #0x6c
700a2402: e7ff         	b	0x700a2404 <Udma_rmAllocTxHcCh+0x34> @ imm = #-0x2
700a2404: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a2406: 9005         	str	r0, [sp, #0x14]
700a2408: e7ff         	b	0x700a240a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x2
700a240a: 9805         	ldr	r0, [sp, #0x14]
700a240c: 9900         	ldr	r1, [sp]
700a240e: 6a49         	ldr	r1, [r1, #0x24]
700a2410: 4288         	cmp	r0, r1
700a2412: d22c         	bhs	0x700a246e <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x58
700a2414: e7ff         	b	0x700a2416 <Udma_rmAllocTxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2416: 9805         	ldr	r0, [sp, #0x14]
700a2418: 0940         	lsrs	r0, r0, #0x5
700a241a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a241c: 9805         	ldr	r0, [sp, #0x14]
700a241e: 9904         	ldr	r1, [sp, #0x10]
700a2420: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2424: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2426: 9903         	ldr	r1, [sp, #0xc]
700a2428: 2001         	movs	r0, #0x1
700a242a: 4088         	lsls	r0, r1
700a242c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a242e: 9806         	ldr	r0, [sp, #0x18]
700a2430: 9904         	ldr	r1, [sp, #0x10]
700a2432: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2436: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a243a: 9902         	ldr	r1, [sp, #0x8]
700a243c: 4008         	ands	r0, r1
700a243e: 4288         	cmp	r0, r1
700a2440: d110         	bne	0x700a2464 <Udma_rmAllocTxHcCh+0x94> @ imm = #0x20
700a2442: e7ff         	b	0x700a2444 <Udma_rmAllocTxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a2444: 9a02         	ldr	r2, [sp, #0x8]
700a2446: 9806         	ldr	r0, [sp, #0x18]
700a2448: 9904         	ldr	r1, [sp, #0x10]
700a244a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a244e: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a2452: 4390         	bics	r0, r2
700a2454: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = i + rmInitPrms->startTxHcCh;  /* Add start offset */
700a2458: 9805         	ldr	r0, [sp, #0x14]
700a245a: 9900         	ldr	r1, [sp]
700a245c: 6a09         	ldr	r1, [r1, #0x20]
700a245e: 4408         	add	r0, r1
700a2460: 9001         	str	r0, [sp, #0x4]
;                 break;
700a2462: e004         	b	0x700a246e <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x8
;         }
700a2464: e7ff         	b	0x700a2466 <Udma_rmAllocTxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a2466: 9805         	ldr	r0, [sp, #0x14]
700a2468: 3001         	adds	r0, #0x1
700a246a: 9005         	str	r0, [sp, #0x14]
700a246c: e7cd         	b	0x700a240a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x66
;     }
700a246e: e038         	b	0x700a24e2 <Udma_rmAllocTxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a2470: 9807         	ldr	r0, [sp, #0x1c]
700a2472: 9900         	ldr	r1, [sp]
700a2474: 6a09         	ldr	r1, [r1, #0x20]
700a2476: 4288         	cmp	r0, r1
700a2478: d332         	blo	0x700a24e0 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x64
700a247a: e7ff         	b	0x700a247c <Udma_rmAllocTxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxHcCh + rmInitPrms->numTxHcCh)))
700a247c: 9807         	ldr	r0, [sp, #0x1c]
700a247e: 9a00         	ldr	r2, [sp]
700a2480: 6a11         	ldr	r1, [r2, #0x20]
700a2482: 6a52         	ldr	r2, [r2, #0x24]
700a2484: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a2486: 4288         	cmp	r0, r1
700a2488: d22a         	bhs	0x700a24e0 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x54
700a248a: e7ff         	b	0x700a248c <Udma_rmAllocTxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxHcCh;
700a248c: 9807         	ldr	r0, [sp, #0x1c]
700a248e: 9900         	ldr	r1, [sp]
700a2490: 6a09         	ldr	r1, [r1, #0x20]
700a2492: 1a40         	subs	r0, r0, r1
700a2494: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2496: 9805         	ldr	r0, [sp, #0x14]
700a2498: 0940         	lsrs	r0, r0, #0x5
700a249a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a249c: 9805         	ldr	r0, [sp, #0x14]
700a249e: 9904         	ldr	r1, [sp, #0x10]
700a24a0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a24a4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a24a6: 9903         	ldr	r1, [sp, #0xc]
700a24a8: 2001         	movs	r0, #0x1
700a24aa: 4088         	lsls	r0, r1
700a24ac: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a24ae: 9806         	ldr	r0, [sp, #0x18]
700a24b0: 9904         	ldr	r1, [sp, #0x10]
700a24b2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a24b6: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a24ba: 9902         	ldr	r1, [sp, #0x8]
700a24bc: 4008         	ands	r0, r1
700a24be: 4288         	cmp	r0, r1
700a24c0: d10d         	bne	0x700a24de <Udma_rmAllocTxHcCh+0x10e> @ imm = #0x1a
700a24c2: e7ff         	b	0x700a24c4 <Udma_rmAllocTxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a24c4: 9a02         	ldr	r2, [sp, #0x8]
700a24c6: 9806         	ldr	r0, [sp, #0x18]
700a24c8: 9904         	ldr	r1, [sp, #0x10]
700a24ca: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a24ce: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a24d2: 4390         	bics	r0, r2
700a24d4: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = preferredChNum;
700a24d8: 9807         	ldr	r0, [sp, #0x1c]
700a24da: 9001         	str	r0, [sp, #0x4]
;             }
700a24dc: e7ff         	b	0x700a24de <Udma_rmAllocTxHcCh+0x10e> @ imm = #-0x2
;         }
700a24de: e7ff         	b	0x700a24e0 <Udma_rmAllocTxHcCh+0x110> @ imm = #-0x2
700a24e0: e7ff         	b	0x700a24e2 <Udma_rmAllocTxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a24e2: 9806         	ldr	r0, [sp, #0x18]
700a24e4: f500 609f    	add.w	r0, r0, #0x4f8
700a24e8: f007 fc5a    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x78b4
;     return (chNum);
700a24ec: 9801         	ldr	r0, [sp, #0x4]
700a24ee: b008         	add	sp, #0x20
700a24f0: bd80         	pop	{r7, pc}
		...
700a24fe: 0000         	movs	r0, r0

700a2500 <Udma_rmAllocTxUhcCh>:
; {
700a2500: b580         	push	{r7, lr}
700a2502: b088         	sub	sp, #0x20
700a2504: 9007         	str	r0, [sp, #0x1c]
700a2506: 9106         	str	r1, [sp, #0x18]
700a2508: 2000         	movs	r0, #0x0
700a250a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a250e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2510: 9806         	ldr	r0, [sp, #0x18]
700a2512: f500 70ea    	add.w	r0, r0, #0x1d4
700a2516: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2518: 9806         	ldr	r0, [sp, #0x18]
700a251a: f500 609f    	add.w	r0, r0, #0x4f8
700a251e: f04f 31ff    	mov.w	r1, #0xffffffff
700a2522: f006 f8e5    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x61ca
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2526: 9807         	ldr	r0, [sp, #0x1c]
700a2528: 2101         	movs	r1, #0x1
700a252a: f6cf 71ff    	movt	r1, #0xffff
700a252e: 4288         	cmp	r0, r1
700a2530: d136         	bne	0x700a25a0 <Udma_rmAllocTxUhcCh+0xa0> @ imm = #0x6c
700a2532: e7ff         	b	0x700a2534 <Udma_rmAllocTxUhcCh+0x34> @ imm = #-0x2
700a2534: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a2536: 9005         	str	r0, [sp, #0x14]
700a2538: e7ff         	b	0x700a253a <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x2
700a253a: 9805         	ldr	r0, [sp, #0x14]
700a253c: 9900         	ldr	r1, [sp]
700a253e: 69c9         	ldr	r1, [r1, #0x1c]
700a2540: 4288         	cmp	r0, r1
700a2542: d22c         	bhs	0x700a259e <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x58
700a2544: e7ff         	b	0x700a2546 <Udma_rmAllocTxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2546: 9805         	ldr	r0, [sp, #0x14]
700a2548: 0940         	lsrs	r0, r0, #0x5
700a254a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a254c: 9805         	ldr	r0, [sp, #0x14]
700a254e: 9904         	ldr	r1, [sp, #0x10]
700a2550: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2554: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2556: 9903         	ldr	r1, [sp, #0xc]
700a2558: 2001         	movs	r0, #0x1
700a255a: 4088         	lsls	r0, r1
700a255c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a255e: 9806         	ldr	r0, [sp, #0x18]
700a2560: 9904         	ldr	r1, [sp, #0x10]
700a2562: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2566: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a256a: 9902         	ldr	r1, [sp, #0x8]
700a256c: 4008         	ands	r0, r1
700a256e: 4288         	cmp	r0, r1
700a2570: d110         	bne	0x700a2594 <Udma_rmAllocTxUhcCh+0x94> @ imm = #0x20
700a2572: e7ff         	b	0x700a2574 <Udma_rmAllocTxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a2574: 9a02         	ldr	r2, [sp, #0x8]
700a2576: 9806         	ldr	r0, [sp, #0x18]
700a2578: 9904         	ldr	r1, [sp, #0x10]
700a257a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a257e: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a2582: 4390         	bics	r0, r2
700a2584: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = i + rmInitPrms->startTxUhcCh;  /* Add start offset */
700a2588: 9805         	ldr	r0, [sp, #0x14]
700a258a: 9900         	ldr	r1, [sp]
700a258c: 6989         	ldr	r1, [r1, #0x18]
700a258e: 4408         	add	r0, r1
700a2590: 9001         	str	r0, [sp, #0x4]
;                 break;
700a2592: e004         	b	0x700a259e <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x8
;         }
700a2594: e7ff         	b	0x700a2596 <Udma_rmAllocTxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a2596: 9805         	ldr	r0, [sp, #0x14]
700a2598: 3001         	adds	r0, #0x1
700a259a: 9005         	str	r0, [sp, #0x14]
700a259c: e7cd         	b	0x700a253a <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x66
;     }
700a259e: e038         	b	0x700a2612 <Udma_rmAllocTxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a25a0: 9807         	ldr	r0, [sp, #0x1c]
700a25a2: 9900         	ldr	r1, [sp]
700a25a4: 6989         	ldr	r1, [r1, #0x18]
700a25a6: 4288         	cmp	r0, r1
700a25a8: d332         	blo	0x700a2610 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x64
700a25aa: e7ff         	b	0x700a25ac <Udma_rmAllocTxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxUhcCh + rmInitPrms->numTxUhcCh)))
700a25ac: 9807         	ldr	r0, [sp, #0x1c]
700a25ae: 9a00         	ldr	r2, [sp]
700a25b0: 6991         	ldr	r1, [r2, #0x18]
700a25b2: 69d2         	ldr	r2, [r2, #0x1c]
700a25b4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a25b6: 4288         	cmp	r0, r1
700a25b8: d22a         	bhs	0x700a2610 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x54
700a25ba: e7ff         	b	0x700a25bc <Udma_rmAllocTxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxUhcCh;
700a25bc: 9807         	ldr	r0, [sp, #0x1c]
700a25be: 9900         	ldr	r1, [sp]
700a25c0: 6989         	ldr	r1, [r1, #0x18]
700a25c2: 1a40         	subs	r0, r0, r1
700a25c4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a25c6: 9805         	ldr	r0, [sp, #0x14]
700a25c8: 0940         	lsrs	r0, r0, #0x5
700a25ca: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a25cc: 9805         	ldr	r0, [sp, #0x14]
700a25ce: 9904         	ldr	r1, [sp, #0x10]
700a25d0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a25d4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a25d6: 9903         	ldr	r1, [sp, #0xc]
700a25d8: 2001         	movs	r0, #0x1
700a25da: 4088         	lsls	r0, r1
700a25dc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a25de: 9806         	ldr	r0, [sp, #0x18]
700a25e0: 9904         	ldr	r1, [sp, #0x10]
700a25e2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a25e6: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a25ea: 9902         	ldr	r1, [sp, #0x8]
700a25ec: 4008         	ands	r0, r1
700a25ee: 4288         	cmp	r0, r1
700a25f0: d10d         	bne	0x700a260e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #0x1a
700a25f2: e7ff         	b	0x700a25f4 <Udma_rmAllocTxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a25f4: 9a02         	ldr	r2, [sp, #0x8]
700a25f6: 9806         	ldr	r0, [sp, #0x18]
700a25f8: 9904         	ldr	r1, [sp, #0x10]
700a25fa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a25fe: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a2602: 4390         	bics	r0, r2
700a2604: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = preferredChNum;
700a2608: 9807         	ldr	r0, [sp, #0x1c]
700a260a: 9001         	str	r0, [sp, #0x4]
;             }
700a260c: e7ff         	b	0x700a260e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #-0x2
;         }
700a260e: e7ff         	b	0x700a2610 <Udma_rmAllocTxUhcCh+0x110> @ imm = #-0x2
700a2610: e7ff         	b	0x700a2612 <Udma_rmAllocTxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2612: 9806         	ldr	r0, [sp, #0x18]
700a2614: f500 609f    	add.w	r0, r0, #0x4f8
700a2618: f007 fbc2    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x7784
;     return (chNum);
700a261c: 9801         	ldr	r0, [sp, #0x4]
700a261e: b008         	add	sp, #0x20
700a2620: bd80         	pop	{r7, pc}
		...
700a262e: 0000         	movs	r0, r0

700a2630 <UART_udmaInitRxCh>:
; {
700a2630: b580         	push	{r7, lr}
700a2632: b0be         	sub	sp, #0xf8
700a2634: 903d         	str	r0, [sp, #0xf4]
700a2636: 913c         	str	r1, [sp, #0xf0]
700a2638: 200a         	movs	r0, #0xa
;     chType = UDMA_CH_TYPE_PDMA_RX;
700a263a: 903a         	str	r0, [sp, #0xe8]
;     UdmaChPrms_init(&chPrms, chType);
700a263c: 993a         	ldr	r1, [sp, #0xe8]
700a263e: a821         	add	r0, sp, #0x84
700a2640: f006 ffbe    	bl	0x700a95c0 <UdmaChPrms_init> @ imm = #0x6f7c
;     chPrms.peerChNum                = hUart->hUartInit->rxEvtNum;
700a2644: 983d         	ldr	r0, [sp, #0xf4]
700a2646: 6840         	ldr	r0, [r0, #0x4]
700a2648: 6c00         	ldr	r0, [r0, #0x40]
700a264a: 9022         	str	r0, [sp, #0x88]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->rxRingMem;
700a264c: 983c         	ldr	r0, [sp, #0xf0]
700a264e: 6a80         	ldr	r0, [r0, #0x28]
700a2650: 9025         	str	r0, [sp, #0x94]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a2652: 983c         	ldr	r0, [sp, #0xf0]
700a2654: 6b00         	ldr	r0, [r0, #0x30]
700a2656: 9026         	str	r0, [sp, #0x98]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a2658: 983c         	ldr	r0, [sp, #0xf0]
700a265a: 6b40         	ldr	r0, [r0, #0x34]
700a265c: 9028         	str	r0, [sp, #0xa0]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a265e: 983c         	ldr	r0, [sp, #0xf0]
700a2660: 6bc0         	ldr	r0, [r0, #0x3c]
700a2662: 2801         	cmp	r0, #0x1
700a2664: d10a         	bne	0x700a267c <UART_udmaInitRxCh+0x4c> @ imm = #0x14
700a2666: e7ff         	b	0x700a2668 <UART_udmaInitRxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqRxRingMem;
700a2668: 983c         	ldr	r0, [sp, #0xf0]
700a266a: 6ac0         	ldr	r0, [r0, #0x2c]
700a266c: 902c         	str	r0, [sp, #0xb0]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a266e: 983c         	ldr	r0, [sp, #0xf0]
700a2670: 6b00         	ldr	r0, [r0, #0x30]
700a2672: 902d         	str	r0, [sp, #0xb4]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a2674: 983c         	ldr	r0, [sp, #0xf0]
700a2676: 6b40         	ldr	r0, [r0, #0x34]
700a2678: 902f         	str	r0, [sp, #0xbc]
;     }
700a267a: e7ff         	b	0x700a267c <UART_udmaInitRxCh+0x4c> @ imm = #-0x2
;     rxChHandle                      = udmaChCfg->rxChHandle;
700a267c: 983c         	ldr	r0, [sp, #0xf0]
700a267e: 6880         	ldr	r0, [r0, #0x8]
700a2680: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a2682: 983c         	ldr	r0, [sp, #0xf0]
700a2684: 6800         	ldr	r0, [r0]
700a2686: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, rxChHandle, chType, &chPrms);
700a2688: 9807         	ldr	r0, [sp, #0x1c]
700a268a: 9906         	ldr	r1, [sp, #0x18]
700a268c: 9a3a         	ldr	r2, [sp, #0xe8]
700a268e: ab21         	add	r3, sp, #0x84
700a2690: f7fd fa7e    	bl	0x7009fb90 <Udma_chOpen> @ imm = #-0x2b04
700a2694: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a2696: 983b         	ldr	r0, [sp, #0xec]
700a2698: fab0 f080    	clz	r0, r0
700a269c: 0940         	lsrs	r0, r0, #0x5
700a269e: f64f 3123    	movw	r1, #0xfb23
700a26a2: f2c7 010a    	movt	r1, #0x700a
700a26a6: 9103         	str	r1, [sp, #0xc]
700a26a8: 466a         	mov	r2, sp
700a26aa: 6011         	str	r1, [r2]
700a26ac: f24f 7199    	movw	r1, #0xf799
700a26b0: f2c7 010a    	movt	r1, #0x700a
700a26b4: 9104         	str	r1, [sp, #0x10]
700a26b6: f64f 3294    	movw	r2, #0xfb94
700a26ba: f2c7 020a    	movt	r2, #0x700a
700a26be: 9205         	str	r2, [sp, #0x14]
700a26c0: 2366         	movs	r3, #0x66
700a26c2: f006 faad    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x655a
;     UdmaChRxPrms_init(&rxPrms, chType);
700a26c6: 993a         	ldr	r1, [sp, #0xe8]
700a26c8: a81a         	add	r0, sp, #0x68
700a26ca: 9001         	str	r0, [sp, #0x4]
700a26cc: f003 fc28    	bl	0x700a5f20 <UdmaChRxPrms_init> @ imm = #0x3850
700a26d0: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigRx(rxChHandle, &rxPrms);
700a26d2: 9806         	ldr	r0, [sp, #0x18]
700a26d4: f7fa f934    	bl	0x7009c940 <Udma_chConfigRx> @ imm = #-0x5d98
700a26d8: 9b03         	ldr	r3, [sp, #0xc]
700a26da: 9904         	ldr	r1, [sp, #0x10]
700a26dc: 9a05         	ldr	r2, [sp, #0x14]
700a26de: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a26e0: 983b         	ldr	r0, [sp, #0xec]
700a26e2: fab0 f080    	clz	r0, r0
700a26e6: 0940         	lsrs	r0, r0, #0x5
700a26e8: 46ec         	mov	r12, sp
700a26ea: f8cc 3000    	str.w	r3, [r12]
700a26ee: 236b         	movs	r3, #0x6b
700a26f0: f006 fa96    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x652c
;     eventHandle = udmaChCfg->cqRxEvtHandle;
700a26f4: 983c         	ldr	r0, [sp, #0xf0]
700a26f6: 6900         	ldr	r0, [r0, #0x10]
700a26f8: 9019         	str	r0, [sp, #0x64]
700a26fa: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a26fc: 9002         	str	r0, [sp, #0x8]
700a26fe: f007 fb87    	bl	0x700a9e10 <UdmaEventPrms_init> @ imm = #0x770e
700a2702: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a2704: 9008         	str	r0, [sp, #0x20]
700a2706: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a2708: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = rxChHandle;
700a270a: 9806         	ldr	r0, [sp, #0x18]
700a270c: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a270e: 9807         	ldr	r0, [sp, #0x1c]
700a2710: f008 fa2e    	bl	0x700aab70 <Udma_eventGetGlobalHandle> @ imm = #0x845c
700a2714: 9a02         	ldr	r2, [sp, #0x8]
700a2716: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrRx;
700a2718: f247 50f1    	movw	r0, #0x75f1
700a271c: f2c7 000a    	movt	r0, #0x700a
700a2720: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a2722: 983d         	ldr	r0, [sp, #0xf4]
700a2724: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a2726: 9807         	ldr	r0, [sp, #0x1c]
700a2728: 9919         	ldr	r1, [sp, #0x64]
700a272a: f7fa fda9    	bl	0x7009d280 <Udma_eventRegister> @ imm = #-0x54ae
700a272e: 9b03         	ldr	r3, [sp, #0xc]
700a2730: 9904         	ldr	r1, [sp, #0x10]
700a2732: 9a05         	ldr	r2, [sp, #0x14]
700a2734: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a2736: 983b         	ldr	r0, [sp, #0xec]
700a2738: fab0 f080    	clz	r0, r0
700a273c: 0940         	lsrs	r0, r0, #0x5
700a273e: 46ec         	mov	r12, sp
700a2740: f8cc 3000    	str.w	r3, [r12]
700a2744: 2377         	movs	r3, #0x77
700a2746: f006 fa6b    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x64d6
;     return retVal;
700a274a: 983b         	ldr	r0, [sp, #0xec]
700a274c: b03e         	add	sp, #0xf8
700a274e: bd80         	pop	{r7, pc}

700a2750 <UART_udmaInitTxCh>:
; {
700a2750: b580         	push	{r7, lr}
700a2752: b0bc         	sub	sp, #0xf0
700a2754: 903b         	str	r0, [sp, #0xec]
700a2756: 913a         	str	r1, [sp, #0xe8]
700a2758: 2009         	movs	r0, #0x9
;     chType = UDMA_CH_TYPE_PDMA_TX;
700a275a: 9038         	str	r0, [sp, #0xe0]
;     UdmaChPrms_init(&chPrms, chType);
700a275c: 9938         	ldr	r1, [sp, #0xe0]
700a275e: a81f         	add	r0, sp, #0x7c
700a2760: f006 ff2e    	bl	0x700a95c0 <UdmaChPrms_init> @ imm = #0x6e5c
;     chPrms.peerChNum                = hUart->hUartInit->txEvtNum;
700a2764: 983b         	ldr	r0, [sp, #0xec]
700a2766: 6840         	ldr	r0, [r0, #0x4]
700a2768: 6c40         	ldr	r0, [r0, #0x44]
700a276a: 9020         	str	r0, [sp, #0x80]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->txRingMem;
700a276c: 983a         	ldr	r0, [sp, #0xe8]
700a276e: 6a00         	ldr	r0, [r0, #0x20]
700a2770: 9023         	str	r0, [sp, #0x8c]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a2772: 983a         	ldr	r0, [sp, #0xe8]
700a2774: 6b00         	ldr	r0, [r0, #0x30]
700a2776: 9024         	str	r0, [sp, #0x90]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a2778: 983a         	ldr	r0, [sp, #0xe8]
700a277a: 6b40         	ldr	r0, [r0, #0x34]
700a277c: 9026         	str	r0, [sp, #0x98]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a277e: 983a         	ldr	r0, [sp, #0xe8]
700a2780: 6bc0         	ldr	r0, [r0, #0x3c]
700a2782: 2801         	cmp	r0, #0x1
700a2784: d10a         	bne	0x700a279c <UART_udmaInitTxCh+0x4c> @ imm = #0x14
700a2786: e7ff         	b	0x700a2788 <UART_udmaInitTxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqTxRingMem;
700a2788: 983a         	ldr	r0, [sp, #0xe8]
700a278a: 6a40         	ldr	r0, [r0, #0x24]
700a278c: 902a         	str	r0, [sp, #0xa8]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a278e: 983a         	ldr	r0, [sp, #0xe8]
700a2790: 6b00         	ldr	r0, [r0, #0x30]
700a2792: 902b         	str	r0, [sp, #0xac]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a2794: 983a         	ldr	r0, [sp, #0xe8]
700a2796: 6b40         	ldr	r0, [r0, #0x34]
700a2798: 902d         	str	r0, [sp, #0xb4]
;     }
700a279a: e7ff         	b	0x700a279c <UART_udmaInitTxCh+0x4c> @ imm = #-0x2
;     txChHandle                      = udmaChCfg->txChHandle;
700a279c: 983a         	ldr	r0, [sp, #0xe8]
700a279e: 6840         	ldr	r0, [r0, #0x4]
700a27a0: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a27a2: 983a         	ldr	r0, [sp, #0xe8]
700a27a4: 6800         	ldr	r0, [r0]
700a27a6: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, txChHandle, chType, &chPrms);
700a27a8: 9807         	ldr	r0, [sp, #0x1c]
700a27aa: 9906         	ldr	r1, [sp, #0x18]
700a27ac: 9a38         	ldr	r2, [sp, #0xe0]
700a27ae: ab1f         	add	r3, sp, #0x7c
700a27b0: f7fd f9ee    	bl	0x7009fb90 <Udma_chOpen> @ imm = #-0x2c24
700a27b4: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a27b6: 9839         	ldr	r0, [sp, #0xe4]
700a27b8: fab0 f080    	clz	r0, r0
700a27bc: 0940         	lsrs	r0, r0, #0x5
700a27be: f64f 3123    	movw	r1, #0xfb23
700a27c2: f2c7 010a    	movt	r1, #0x700a
700a27c6: 9103         	str	r1, [sp, #0xc]
700a27c8: 466a         	mov	r2, sp
700a27ca: 6011         	str	r1, [r2]
700a27cc: f24f 7199    	movw	r1, #0xf799
700a27d0: f2c7 010a    	movt	r1, #0x700a
700a27d4: 9104         	str	r1, [sp, #0x10]
700a27d6: f64f 32ca    	movw	r2, #0xfbca
700a27da: f2c7 020a    	movt	r2, #0x700a
700a27de: 9205         	str	r2, [sp, #0x14]
700a27e0: 2398         	movs	r3, #0x98
700a27e2: f006 fa1d    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x643a
;     UdmaChTxPrms_init(&txPrms, chType);
700a27e6: 9938         	ldr	r1, [sp, #0xe0]
700a27e8: a81a         	add	r0, sp, #0x68
700a27ea: 9001         	str	r0, [sp, #0x4]
700a27ec: f003 fbf0    	bl	0x700a5fd0 <UdmaChTxPrms_init> @ imm = #0x37e0
700a27f0: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigTx(txChHandle, &txPrms);
700a27f2: 9806         	ldr	r0, [sp, #0x18]
700a27f4: f7fc fa24    	bl	0x7009ec40 <Udma_chConfigTx> @ imm = #-0x3bb8
700a27f8: 9b03         	ldr	r3, [sp, #0xc]
700a27fa: 9904         	ldr	r1, [sp, #0x10]
700a27fc: 9a05         	ldr	r2, [sp, #0x14]
700a27fe: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a2800: 9839         	ldr	r0, [sp, #0xe4]
700a2802: fab0 f080    	clz	r0, r0
700a2806: 0940         	lsrs	r0, r0, #0x5
700a2808: 46ec         	mov	r12, sp
700a280a: f8cc 3000    	str.w	r3, [r12]
700a280e: 239d         	movs	r3, #0x9d
700a2810: f006 fa06    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x640c
;     eventHandle = udmaChCfg->cqTxEvtHandle;
700a2814: 983a         	ldr	r0, [sp, #0xe8]
700a2816: 68c0         	ldr	r0, [r0, #0xc]
700a2818: 9019         	str	r0, [sp, #0x64]
700a281a: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a281c: 9002         	str	r0, [sp, #0x8]
700a281e: f007 faf7    	bl	0x700a9e10 <UdmaEventPrms_init> @ imm = #0x75ee
700a2822: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a2824: 9008         	str	r0, [sp, #0x20]
700a2826: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a2828: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = txChHandle;
700a282a: 9806         	ldr	r0, [sp, #0x18]
700a282c: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a282e: 9807         	ldr	r0, [sp, #0x1c]
700a2830: f008 f99e    	bl	0x700aab70 <Udma_eventGetGlobalHandle> @ imm = #0x833c
700a2834: 9a02         	ldr	r2, [sp, #0x8]
700a2836: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrTx;
700a2838: f247 6091    	movw	r0, #0x7691
700a283c: f2c7 000a    	movt	r0, #0x700a
700a2840: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a2842: 983b         	ldr	r0, [sp, #0xec]
700a2844: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a2846: 9807         	ldr	r0, [sp, #0x1c]
700a2848: 9919         	ldr	r1, [sp, #0x64]
700a284a: f7fa fd19    	bl	0x7009d280 <Udma_eventRegister> @ imm = #-0x55ce
700a284e: 9b03         	ldr	r3, [sp, #0xc]
700a2850: 9904         	ldr	r1, [sp, #0x10]
700a2852: 9a05         	ldr	r2, [sp, #0x14]
700a2854: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a2856: 9839         	ldr	r0, [sp, #0xe4]
700a2858: fab0 f080    	clz	r0, r0
700a285c: 0940         	lsrs	r0, r0, #0x5
700a285e: 46ec         	mov	r12, sp
700a2860: f8cc 3000    	str.w	r3, [r12]
700a2864: 23a9         	movs	r3, #0xa9
700a2866: f006 f9db    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x63b6
;     return retVal;
700a286a: 9839         	ldr	r0, [sp, #0xe4]
700a286c: b03c         	add	sp, #0xf0
700a286e: bd80         	pop	{r7, pc}

700a2870 <Sciclient_rmIaValidateEvt>:
; {
700a2870: b580         	push	{r7, lr}
700a2872: b086         	sub	sp, #0x18
700a2874: 4684         	mov	r12, r0
700a2876: 9808         	ldr	r0, [sp, #0x20]
700a2878: f8cd c014    	str.w	r12, [sp, #0x14]
700a287c: f8ad 1012    	strh.w	r1, [sp, #0x12]
700a2880: f8ad 2010    	strh.w	r2, [sp, #0x10]
700a2884: f88d 300f    	strb.w	r3, [sp, #0xf]
700a2888: f88d 000e    	strb.w	r0, [sp, #0xe]
700a288c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a288e: 9002         	str	r0, [sp, #0x8]
;     if (evt >= inst->n_sevt) {
700a2890: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a2894: 9905         	ldr	r1, [sp, #0x14]
700a2896: 8949         	ldrh	r1, [r1, #0xa]
700a2898: 4288         	cmp	r0, r1
700a289a: db04         	blt	0x700a28a6 <Sciclient_rmIaValidateEvt+0x36> @ imm = #0x8
700a289c: e7ff         	b	0x700a289e <Sciclient_rmIaValidateEvt+0x2e> @ imm = #-0x2
700a289e: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a28a2: 9002         	str	r0, [sp, #0x8]
;     }
700a28a4: e7ff         	b	0x700a28a6 <Sciclient_rmIaValidateEvt+0x36> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a28a6: 9802         	ldr	r0, [sp, #0x8]
700a28a8: 2800         	cmp	r0, #0x0
700a28aa: d16d         	bne	0x700a2988 <Sciclient_rmIaValidateEvt+0x118> @ imm = #0xda
700a28ac: e7ff         	b	0x700a28ae <Sciclient_rmIaValidateEvt+0x3e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a28ae: 9805         	ldr	r0, [sp, #0x14]
700a28b0: 6840         	ldr	r0, [r0, #0x4]
700a28b2: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a28b6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a28ba: 9001         	str	r0, [sp, #0x4]
;         if (in_use == true) {
700a28bc: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700a28c0: 07c0         	lsls	r0, r0, #0x1f
700a28c2: 2800         	cmp	r0, #0x0
700a28c4: d047         	beq	0x700a2956 <Sciclient_rmIaValidateEvt+0xe6> @ imm = #0x8e
700a28c6: e7ff         	b	0x700a28c8 <Sciclient_rmIaValidateEvt+0x58> @ imm = #-0x2
;             reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a28c8: 9801         	ldr	r0, [sp, #0x4]
700a28ca: f64f 7100    	movw	r1, #0xff00
700a28ce: f2c0 0101    	movt	r1, #0x1
700a28d2: 2208         	movs	r2, #0x8
700a28d4: f00a fb34    	bl	0x700acf40 <CSL_REG32_FEXT_RAW> @ imm = #0xa668
700a28d8: f8ad 0002    	strh.w	r0, [sp, #0x2]
;             reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a28dc: 9801         	ldr	r0, [sp, #0x4]
700a28de: 213f         	movs	r1, #0x3f
700a28e0: 2200         	movs	r2, #0x0
700a28e2: f00a fb2d    	bl	0x700acf40 <CSL_REG32_FEXT_RAW> @ imm = #0xa65a
700a28e6: f8ad 0000    	strh.w	r0, [sp]
;             if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a28ea: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a28ee: b9f0         	cbnz	r0, 0x700a292e <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x3c
700a28f0: e7ff         	b	0x700a28f2 <Sciclient_rmIaValidateEvt+0x82> @ imm = #-0x2
700a28f2: f8bd 0000    	ldrh.w	r0, [sp]
700a28f6: b9d0         	cbnz	r0, 0x700a292e <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x34
700a28f8: e7ff         	b	0x700a28fa <Sciclient_rmIaValidateEvt+0x8a> @ imm = #-0x2
;                 if ((vint != reg_vint) &&
700a28fa: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a28fe: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a2902: 4288         	cmp	r0, r1
700a2904: d012         	beq	0x700a292c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x24
700a2906: e7ff         	b	0x700a2908 <Sciclient_rmIaValidateEvt+0x98> @ imm = #-0x2
;                     (vint_sb_index != reg_sb) &&
700a2908: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a290c: f8bd 1000    	ldrh.w	r1, [sp]
700a2910: 4288         	cmp	r0, r1
700a2912: d00b         	beq	0x700a292c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x16
700a2914: e7ff         	b	0x700a2916 <Sciclient_rmIaValidateEvt+0xa6> @ imm = #-0x2
;                     (evt != inst->v0_b0_evt)) {
700a2916: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a291a: 9905         	ldr	r1, [sp, #0x14]
700a291c: 8a89         	ldrh	r1, [r1, #0x14]
;                 if ((vint != reg_vint) &&
700a291e: 4288         	cmp	r0, r1
700a2920: d004         	beq	0x700a292c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x8
700a2922: e7ff         	b	0x700a2924 <Sciclient_rmIaValidateEvt+0xb4> @ imm = #-0x2
700a2924: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a2928: 9002         	str	r0, [sp, #0x8]
;                 }
700a292a: e7ff         	b	0x700a292c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #-0x2
;             } else {
700a292c: e012         	b	0x700a2954 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #0x24
;                 if ((vint != reg_vint) &&
700a292e: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a2932: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a2936: 4288         	cmp	r0, r1
700a2938: d00b         	beq	0x700a2952 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x16
700a293a: e7ff         	b	0x700a293c <Sciclient_rmIaValidateEvt+0xcc> @ imm = #-0x2
;                     (vint_sb_index != reg_sb)) {
700a293c: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a2940: f8bd 1000    	ldrh.w	r1, [sp]
;                 if ((vint != reg_vint) &&
700a2944: 4288         	cmp	r0, r1
700a2946: d004         	beq	0x700a2952 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x8
700a2948: e7ff         	b	0x700a294a <Sciclient_rmIaValidateEvt+0xda> @ imm = #-0x2
700a294a: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a294e: 9002         	str	r0, [sp, #0x8]
;                 }
700a2950: e7ff         	b	0x700a2952 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #-0x2
700a2952: e7ff         	b	0x700a2954 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #-0x2
;         } else {
700a2954: e017         	b	0x700a2986 <Sciclient_rmIaValidateEvt+0x116> @ imm = #0x2e
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a2956: 9801         	ldr	r0, [sp, #0x4]
700a2958: f00b f81a    	bl	0x700ad990 <CSL_REG32_RD_RAW> @ imm = #0xb034
700a295c: b138         	cbz	r0, 0x700a296e <Sciclient_rmIaValidateEvt+0xfe> @ imm = #0xe
700a295e: e7ff         	b	0x700a2960 <Sciclient_rmIaValidateEvt+0xf0> @ imm = #-0x2
;                  (Sciclient_rmIaEvtRomMapped(inst, evt) == false)) ||
700a2960: 9805         	ldr	r0, [sp, #0x14]
700a2962: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a2966: f005 fb1b    	bl	0x700a7fa0 <Sciclient_rmIaEvtRomMapped> @ imm = #0x5636
700a296a: b138         	cbz	r0, 0x700a297c <Sciclient_rmIaValidateEvt+0x10c> @ imm = #0xe
700a296c: e7ff         	b	0x700a296e <Sciclient_rmIaValidateEvt+0xfe> @ imm = #-0x2
;                 (evt == inst->v0_b0_evt)) {
700a296e: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a2972: 9905         	ldr	r1, [sp, #0x14]
700a2974: 8a89         	ldrh	r1, [r1, #0x14]
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a2976: 4288         	cmp	r0, r1
700a2978: d104         	bne	0x700a2984 <Sciclient_rmIaValidateEvt+0x114> @ imm = #0x8
700a297a: e7ff         	b	0x700a297c <Sciclient_rmIaValidateEvt+0x10c> @ imm = #-0x2
700a297c: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a2980: 9002         	str	r0, [sp, #0x8]
;             }
700a2982: e7ff         	b	0x700a2984 <Sciclient_rmIaValidateEvt+0x114> @ imm = #-0x2
700a2984: e7ff         	b	0x700a2986 <Sciclient_rmIaValidateEvt+0x116> @ imm = #-0x2
;     }
700a2986: e7ff         	b	0x700a2988 <Sciclient_rmIaValidateEvt+0x118> @ imm = #-0x2
;     return r;
700a2988: 9802         	ldr	r0, [sp, #0x8]
700a298a: b006         	add	sp, #0x18
700a298c: bd80         	pop	{r7, pc}
700a298e: 0000         	movs	r0, r0

700a2990 <Sciclient_rmIrqVintAdd>:
; {
700a2990: b580         	push	{r7, lr}
700a2992: b08c         	sub	sp, #0x30
700a2994: 900b         	str	r0, [sp, #0x2c]
700a2996: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a2998: 900a         	str	r0, [sp, #0x28]
;     bool cfg_new_mapping = false;
700a299a: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool cfg_whole_route = false;
700a299e: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a29a2: 9008         	str	r0, [sp, #0x20]
;     r = Sciclient_rmIrqIsVintRouteSet(cfg, &vint_used);
700a29a4: 980b         	ldr	r0, [sp, #0x2c]
700a29a6: f10d 0127    	add.w	r1, sp, #0x27
700a29aa: f002 fcc9    	bl	0x700a5340 <Sciclient_rmIrqIsVintRouteSet> @ imm = #0x2992
700a29ae: 900a         	str	r0, [sp, #0x28]
;     if (r == SystemP_SUCCESS) {
700a29b0: 980a         	ldr	r0, [sp, #0x28]
700a29b2: b9a0         	cbnz	r0, 0x700a29de <Sciclient_rmIrqVintAdd+0x4e> @ imm = #0x28
700a29b4: e7ff         	b	0x700a29b6 <Sciclient_rmIrqVintAdd+0x26> @ imm = #-0x2
;         if ((vint_used == true) ||
700a29b6: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a29ba: 07c0         	lsls	r0, r0, #0x1f
700a29bc: b930         	cbnz	r0, 0x700a29cc <Sciclient_rmIrqVintAdd+0x3c> @ imm = #0xc
700a29be: e7ff         	b	0x700a29c0 <Sciclient_rmIrqVintAdd+0x30> @ imm = #-0x2
;             (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a29c0: 980b         	ldr	r0, [sp, #0x2c]
700a29c2: 6800         	ldr	r0, [r0]
700a29c4: f006 ff14    	bl	0x700a97f0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x6e28
;         if ((vint_used == true) ||
700a29c8: b120         	cbz	r0, 0x700a29d4 <Sciclient_rmIrqVintAdd+0x44> @ imm = #0x8
700a29ca: e7ff         	b	0x700a29cc <Sciclient_rmIrqVintAdd+0x3c> @ imm = #-0x2
700a29cc: 2001         	movs	r0, #0x1
;             cfg_new_mapping = true;
700a29ce: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a29d2: e003         	b	0x700a29dc <Sciclient_rmIrqVintAdd+0x4c> @ imm = #0x6
700a29d4: 2001         	movs	r0, #0x1
;             cfg_whole_route = true;
700a29d6: f88d 0025    	strb.w	r0, [sp, #0x25]
700a29da: e7ff         	b	0x700a29dc <Sciclient_rmIrqVintAdd+0x4c> @ imm = #-0x2
;     }
700a29dc: e7ff         	b	0x700a29de <Sciclient_rmIrqVintAdd+0x4e> @ imm = #-0x2
;     if (cfg_new_mapping == true) {
700a29de: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a29e2: 07c0         	lsls	r0, r0, #0x1f
700a29e4: 2800         	cmp	r0, #0x0
700a29e6: d04c         	beq	0x700a2a82 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #0x98
700a29e8: e7ff         	b	0x700a29ea <Sciclient_rmIrqVintAdd+0x5a> @ imm = #-0x2
700a29ea: 203c         	movs	r0, #0x3c
700a29ec: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a29f0: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a29f2: 980b         	ldr	r0, [sp, #0x2c]
700a29f4: 7900         	ldrb	r0, [r0, #0x4]
700a29f6: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a29fa: 980b         	ldr	r0, [sp, #0x2c]
700a29fc: 88c0         	ldrh	r0, [r0, #0x6]
700a29fe: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a2a02: 980b         	ldr	r0, [sp, #0x2c]
700a2a04: 8900         	ldrh	r0, [r0, #0x8]
700a2a06: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a2a0a: 980b         	ldr	r0, [sp, #0x2c]
700a2a0c: 8a00         	ldrh	r0, [r0, #0x10]
700a2a0e: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a2a12: 980b         	ldr	r0, [sp, #0x2c]
700a2a14: 8a40         	ldrh	r0, [r0, #0x12]
700a2a16: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a2a1a: 980b         	ldr	r0, [sp, #0x2c]
700a2a1c: 89c0         	ldrh	r0, [r0, #0xe]
700a2a1e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a2a22: 980b         	ldr	r0, [sp, #0x2c]
700a2a24: 7d00         	ldrb	r0, [r0, #0x14]
700a2a26: f88d 001e    	strb.w	r0, [sp, #0x1e]
;                                   cfg->set_resp,
700a2a2a: 980b         	ldr	r0, [sp, #0x2c]
700a2a2c: 6981         	ldr	r1, [r0, #0x18]
700a2a2e: a801         	add	r0, sp, #0x4
700a2a30: f04f 32ff    	mov.w	r2, #0xffffffff
;         r = Sciclient_rmIrqSetRaw(&req,
700a2a34: f007 fe8c    	bl	0x700aa750 <Sciclient_rmIrqSetRaw> @ imm = #0x7d18
700a2a38: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2a3a: 980a         	ldr	r0, [sp, #0x28]
700a2a3c: bb00         	cbnz	r0, 0x700a2a80 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #0x40
700a2a3e: e7ff         	b	0x700a2a40 <Sciclient_rmIrqVintAdd+0xb0> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a2a40: 980b         	ldr	r0, [sp, #0x2c]
700a2a42: 8a00         	ldrh	r0, [r0, #0x10]
700a2a44: f007 fd04    	bl	0x700aa450 <Sciclient_rmIaGetInst> @ imm = #0x7a08
700a2a48: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a2a4a: 9808         	ldr	r0, [sp, #0x20]
700a2a4c: b1b8         	cbz	r0, 0x700a2a7e <Sciclient_rmIrqVintAdd+0xee> @ imm = #0x2e
700a2a4e: e7ff         	b	0x700a2a50 <Sciclient_rmIrqVintAdd+0xc0> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]++;
700a2a50: 9808         	ldr	r0, [sp, #0x20]
700a2a52: 6901         	ldr	r1, [r0, #0x10]
700a2a54: 980b         	ldr	r0, [sp, #0x2c]
700a2a56: 8a42         	ldrh	r2, [r0, #0x12]
700a2a58: 5c88         	ldrb	r0, [r1, r2]
700a2a5a: 3001         	adds	r0, #0x1
700a2a5c: 5488         	strb	r0, [r1, r2]
;                 if ((cfg->vint == 0) && (cfg->vint_sb == 0)) {
700a2a5e: 980b         	ldr	r0, [sp, #0x2c]
700a2a60: 8a40         	ldrh	r0, [r0, #0x12]
700a2a62: b958         	cbnz	r0, 0x700a2a7c <Sciclient_rmIrqVintAdd+0xec> @ imm = #0x16
700a2a64: e7ff         	b	0x700a2a66 <Sciclient_rmIrqVintAdd+0xd6> @ imm = #-0x2
700a2a66: 980b         	ldr	r0, [sp, #0x2c]
700a2a68: 7d00         	ldrb	r0, [r0, #0x14]
700a2a6a: b938         	cbnz	r0, 0x700a2a7c <Sciclient_rmIrqVintAdd+0xec> @ imm = #0xe
700a2a6c: e7ff         	b	0x700a2a6e <Sciclient_rmIrqVintAdd+0xde> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = cfg->global_evt - ia_inst->sevt_offset;
700a2a6e: 980b         	ldr	r0, [sp, #0x2c]
700a2a70: 89c0         	ldrh	r0, [r0, #0xe]
700a2a72: 9908         	ldr	r1, [sp, #0x20]
700a2a74: 890a         	ldrh	r2, [r1, #0x8]
700a2a76: 1a80         	subs	r0, r0, r2
700a2a78: 8288         	strh	r0, [r1, #0x14]
;                 }
700a2a7a: e7ff         	b	0x700a2a7c <Sciclient_rmIrqVintAdd+0xec> @ imm = #-0x2
;             }
700a2a7c: e7ff         	b	0x700a2a7e <Sciclient_rmIrqVintAdd+0xee> @ imm = #-0x2
;         }
700a2a7e: e7ff         	b	0x700a2a80 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #-0x2
;     }
700a2a80: e7ff         	b	0x700a2a82 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #-0x2
;     if (cfg_whole_route == true) {
700a2a82: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a2a86: 07c0         	lsls	r0, r0, #0x1f
700a2a88: b170         	cbz	r0, 0x700a2aa8 <Sciclient_rmIrqVintAdd+0x118> @ imm = #0x1c
700a2a8a: e7ff         	b	0x700a2a8c <Sciclient_rmIrqVintAdd+0xfc> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700a2a8c: 980b         	ldr	r0, [sp, #0x2c]
700a2a8e: f7fa f887    	bl	0x7009cba0 <Sciclient_rmIrqFindRoute> @ imm = #-0x5ef2
700a2a92: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2a94: 980a         	ldr	r0, [sp, #0x28]
700a2a96: b930         	cbnz	r0, 0x700a2aa6 <Sciclient_rmIrqVintAdd+0x116> @ imm = #0xc
700a2a98: e7ff         	b	0x700a2a9a <Sciclient_rmIrqVintAdd+0x10a> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, true);
700a2a9a: 980b         	ldr	r0, [sp, #0x2c]
700a2a9c: 2101         	movs	r1, #0x1
700a2a9e: f7fc fbf7    	bl	0x7009f290 <Sciclient_rmIrqProgramRoute> @ imm = #-0x3812
700a2aa2: 900a         	str	r0, [sp, #0x28]
;         }
700a2aa4: e7ff         	b	0x700a2aa6 <Sciclient_rmIrqVintAdd+0x116> @ imm = #-0x2
;     }
700a2aa6: e7ff         	b	0x700a2aa8 <Sciclient_rmIrqVintAdd+0x118> @ imm = #-0x2
;     return r;
700a2aa8: 980a         	ldr	r0, [sp, #0x28]
700a2aaa: b00c         	add	sp, #0x30
700a2aac: bd80         	pop	{r7, pc}
700a2aae: 0000         	movs	r0, r0

700a2ab0 <xTaskPriorityInherit>:
; BaseType_t xTaskPriorityInherit(TaskHandle_t const pxMutexHolder) {
700a2ab0: b580         	push	{r7, lr}
700a2ab2: b084         	sub	sp, #0x10
700a2ab4: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxMutexHolderTCB = pxMutexHolder;
700a2ab6: 9803         	ldr	r0, [sp, #0xc]
700a2ab8: 9002         	str	r0, [sp, #0x8]
700a2aba: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a2abc: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a2abe: 9803         	ldr	r0, [sp, #0xc]
700a2ac0: 2800         	cmp	r0, #0x0
700a2ac2: d07e         	beq	0x700a2bc2 <xTaskPriorityInherit+0x112> @ imm = #0xfc
700a2ac4: e7ff         	b	0x700a2ac6 <xTaskPriorityInherit+0x16> @ imm = #-0x2
;     if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority) {
700a2ac6: 9802         	ldr	r0, [sp, #0x8]
700a2ac8: 6ac0         	ldr	r0, [r0, #0x2c]
700a2aca: f240 41dc    	movw	r1, #0x4dc
700a2ace: f2c7 010b    	movt	r1, #0x700b
700a2ad2: 6809         	ldr	r1, [r1]
700a2ad4: 6ac9         	ldr	r1, [r1, #0x2c]
700a2ad6: 4288         	cmp	r0, r1
700a2ad8: d262         	bhs	0x700a2ba0 <xTaskPriorityInherit+0xf0> @ imm = #0xc4
700a2ada: e7ff         	b	0x700a2adc <xTaskPriorityInherit+0x2c> @ imm = #-0x2
;       if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) &
700a2adc: 9802         	ldr	r0, [sp, #0x8]
700a2ade: 7ec0         	ldrb	r0, [r0, #0x1b]
700a2ae0: 0600         	lsls	r0, r0, #0x18
700a2ae2: 2800         	cmp	r0, #0x0
700a2ae4: d40b         	bmi	0x700a2afe <xTaskPriorityInherit+0x4e> @ imm = #0x16
700a2ae6: e7ff         	b	0x700a2ae8 <xTaskPriorityInherit+0x38> @ imm = #-0x2
;         listSET_LIST_ITEM_VALUE(
700a2ae8: f240 40dc    	movw	r0, #0x4dc
700a2aec: f2c7 000b    	movt	r0, #0x700b
700a2af0: 6800         	ldr	r0, [r0]
700a2af2: 6ac0         	ldr	r0, [r0, #0x2c]
700a2af4: f1c0 0020    	rsb.w	r0, r0, #0x20
700a2af8: 9902         	ldr	r1, [sp, #0x8]
700a2afa: 6188         	str	r0, [r1, #0x18]
;       } else {
700a2afc: e000         	b	0x700a2b00 <xTaskPriorityInherit+0x50> @ imm = #0x0
700a2afe: e7ff         	b	0x700a2b00 <xTaskPriorityInherit+0x50> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(
700a2b00: 9902         	ldr	r1, [sp, #0x8]
700a2b02: 6948         	ldr	r0, [r1, #0x14]
700a2b04: 6ac9         	ldr	r1, [r1, #0x2c]
700a2b06: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a2b0a: f244 41f8    	movw	r1, #0x44f8
700a2b0e: f2c7 0108    	movt	r1, #0x7008
700a2b12: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2b16: 4288         	cmp	r0, r1
700a2b18: d136         	bne	0x700a2b88 <xTaskPriorityInherit+0xd8> @ imm = #0x6c
700a2b1a: e7ff         	b	0x700a2b1c <xTaskPriorityInherit+0x6c> @ imm = #-0x2
;         if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) ==
700a2b1c: 9802         	ldr	r0, [sp, #0x8]
700a2b1e: 3004         	adds	r0, #0x4
700a2b20: f008 fd06    	bl	0x700ab530 <uxListRemove> @ imm = #0x8a0c
700a2b24: b968         	cbnz	r0, 0x700a2b42 <xTaskPriorityInherit+0x92> @ imm = #0x1a
700a2b26: e7ff         	b	0x700a2b28 <xTaskPriorityInherit+0x78> @ imm = #-0x2
;           portRESET_READY_PRIORITY(pxMutexHolderTCB->uxPriority,
700a2b28: 9802         	ldr	r0, [sp, #0x8]
700a2b2a: 6ac1         	ldr	r1, [r0, #0x2c]
700a2b2c: 2001         	movs	r0, #0x1
700a2b2e: fa00 f201    	lsl.w	r2, r0, r1
700a2b32: f240 5108    	movw	r1, #0x508
700a2b36: f2c7 010b    	movt	r1, #0x700b
700a2b3a: 6808         	ldr	r0, [r1]
700a2b3c: 4390         	bics	r0, r2
700a2b3e: 6008         	str	r0, [r1]
;         } else {
700a2b40: e000         	b	0x700a2b44 <xTaskPriorityInherit+0x94> @ imm = #0x0
700a2b42: e7ff         	b	0x700a2b44 <xTaskPriorityInherit+0x94> @ imm = #-0x2
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a2b44: f240 40dc    	movw	r0, #0x4dc
700a2b48: f2c7 000b    	movt	r0, #0x700b
700a2b4c: 6800         	ldr	r0, [r0]
700a2b4e: 6ac0         	ldr	r0, [r0, #0x2c]
700a2b50: 9902         	ldr	r1, [sp, #0x8]
700a2b52: 62c8         	str	r0, [r1, #0x2c]
;         prvAddTaskToReadyList(pxMutexHolderTCB);
700a2b54: 9802         	ldr	r0, [sp, #0x8]
700a2b56: 6ac1         	ldr	r1, [r0, #0x2c]
700a2b58: 2001         	movs	r0, #0x1
700a2b5a: fa00 f201    	lsl.w	r2, r0, r1
700a2b5e: f240 5108    	movw	r1, #0x508
700a2b62: f2c7 010b    	movt	r1, #0x700b
700a2b66: 6808         	ldr	r0, [r1]
700a2b68: 4310         	orrs	r0, r2
700a2b6a: 6008         	str	r0, [r1]
700a2b6c: 9902         	ldr	r1, [sp, #0x8]
700a2b6e: 6ac8         	ldr	r0, [r1, #0x2c]
700a2b70: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a2b74: f244 40f8    	movw	r0, #0x44f8
700a2b78: f2c7 0008    	movt	r0, #0x7008
700a2b7c: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a2b80: 3104         	adds	r1, #0x4
700a2b82: f009 fa8d    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #0x951a
;       } else {
700a2b86: e008         	b	0x700a2b9a <xTaskPriorityInherit+0xea> @ imm = #0x10
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a2b88: f240 40dc    	movw	r0, #0x4dc
700a2b8c: f2c7 000b    	movt	r0, #0x700b
700a2b90: 6800         	ldr	r0, [r0]
700a2b92: 6ac0         	ldr	r0, [r0, #0x2c]
700a2b94: 9902         	ldr	r1, [sp, #0x8]
700a2b96: 62c8         	str	r0, [r1, #0x2c]
700a2b98: e7ff         	b	0x700a2b9a <xTaskPriorityInherit+0xea> @ imm = #-0x2
700a2b9a: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a2b9c: 9001         	str	r0, [sp, #0x4]
;     } else {
700a2b9e: e00f         	b	0x700a2bc0 <xTaskPriorityInherit+0x110> @ imm = #0x1e
;       if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority) {
700a2ba0: 9802         	ldr	r0, [sp, #0x8]
700a2ba2: 6e00         	ldr	r0, [r0, #0x60]
700a2ba4: f240 41dc    	movw	r1, #0x4dc
700a2ba8: f2c7 010b    	movt	r1, #0x700b
700a2bac: 6809         	ldr	r1, [r1]
700a2bae: 6ac9         	ldr	r1, [r1, #0x2c]
700a2bb0: 4288         	cmp	r0, r1
700a2bb2: d203         	bhs	0x700a2bbc <xTaskPriorityInherit+0x10c> @ imm = #0x6
700a2bb4: e7ff         	b	0x700a2bb6 <xTaskPriorityInherit+0x106> @ imm = #-0x2
700a2bb6: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a2bb8: 9001         	str	r0, [sp, #0x4]
;       } else {
700a2bba: e000         	b	0x700a2bbe <xTaskPriorityInherit+0x10e> @ imm = #0x0
700a2bbc: e7ff         	b	0x700a2bbe <xTaskPriorityInherit+0x10e> @ imm = #-0x2
700a2bbe: e7ff         	b	0x700a2bc0 <xTaskPriorityInherit+0x110> @ imm = #-0x2
;   } else {
700a2bc0: e000         	b	0x700a2bc4 <xTaskPriorityInherit+0x114> @ imm = #0x0
700a2bc2: e7ff         	b	0x700a2bc4 <xTaskPriorityInherit+0x114> @ imm = #-0x2
;   return xReturn;
700a2bc4: 9801         	ldr	r0, [sp, #0x4]
700a2bc6: b004         	add	sp, #0x10
700a2bc8: bd80         	pop	{r7, pc}
700a2bca: 0000         	movs	r0, r0
700a2bcc: 0000         	movs	r0, r0
700a2bce: 0000         	movs	r0, r0

700a2bd0 <TaskP_loadUpdateAll>:
; {
700a2bd0: b580         	push	{r7, lr}
700a2bd2: b090         	sub	sp, #0x40
;     vTaskSuspendAll();
700a2bd4: f00a fe9c    	bl	0x700ad910 <vTaskSuspendAll> @ imm = #0xad38
700a2bd8: 2000         	movs	r0, #0x0
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a2bda: 9005         	str	r0, [sp, #0x14]
700a2bdc: e7ff         	b	0x700a2bde <TaskP_loadUpdateAll+0xe> @ imm = #-0x2
700a2bde: 9805         	ldr	r0, [sp, #0x14]
700a2be0: 281f         	cmp	r0, #0x1f
700a2be2: d837         	bhi	0x700a2c54 <TaskP_loadUpdateAll+0x84> @ imm = #0x6e
700a2be4: e7ff         	b	0x700a2be6 <TaskP_loadUpdateAll+0x16> @ imm = #-0x2
;         if(gTaskP_ctrl.taskRegistry[i]!=NULL)
700a2be6: 9905         	ldr	r1, [sp, #0x14]
700a2be8: f644 3078    	movw	r0, #0x4b78
700a2bec: f2c7 0008    	movt	r0, #0x7008
700a2bf0: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a2bf4: b348         	cbz	r0, 0x700a2c4a <TaskP_loadUpdateAll+0x7a> @ imm = #0x52
700a2bf6: e7ff         	b	0x700a2bf8 <TaskP_loadUpdateAll+0x28> @ imm = #-0x2
;             taskObj = gTaskP_ctrl.taskRegistry[i];
700a2bf8: 9905         	ldr	r1, [sp, #0x14]
700a2bfa: f644 3078    	movw	r0, #0x4b78
700a2bfe: f2c7 0008    	movt	r0, #0x7008
700a2c02: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a2c06: 900f         	str	r0, [sp, #0x3c]
;             vTaskGetInfo(taskObj->taskHndl, &taskStatus, pdFALSE, eReady);
700a2c08: 980f         	ldr	r0, [sp, #0x3c]
700a2c0a: f8d0 008c    	ldr.w	r0, [r0, #0x8c]
700a2c0e: a906         	add	r1, sp, #0x18
700a2c10: 2200         	movs	r2, #0x0
700a2c12: 2301         	movs	r3, #0x1
700a2c14: f001 fabc    	bl	0x700a4190 <vTaskGetInfo> @ imm = #0x1578
;             delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, taskObj->lastRunTime);
700a2c18: 980c         	ldr	r0, [sp, #0x30]
700a2c1a: 990f         	ldr	r1, [sp, #0x3c]
700a2c1c: f8d1 1090    	ldr.w	r1, [r1, #0x90]
700a2c20: f009 fed6    	bl	0x700ac9d0 <TaskP_calcCounterDiff> @ imm = #0x9dac
700a2c24: 9004         	str	r0, [sp, #0x10]
;             taskObj->accRunTime += delta;
700a2c26: 9b04         	ldr	r3, [sp, #0x10]
700a2c28: 990f         	ldr	r1, [sp, #0x3c]
700a2c2a: f8d1 2098    	ldr.w	r2, [r1, #0x98]
700a2c2e: f8d1 009c    	ldr.w	r0, [r1, #0x9c]
700a2c32: 18d2         	adds	r2, r2, r3
700a2c34: f140 0000    	adc	r0, r0, #0x0
700a2c38: f8c1 2098    	str.w	r2, [r1, #0x98]
700a2c3c: f8c1 009c    	str.w	r0, [r1, #0x9c]
;             taskObj->lastRunTime = taskStatus.ulRunTimeCounter;
700a2c40: 980c         	ldr	r0, [sp, #0x30]
700a2c42: 990f         	ldr	r1, [sp, #0x3c]
700a2c44: f8c1 0090    	str.w	r0, [r1, #0x90]
;         }
700a2c48: e7ff         	b	0x700a2c4a <TaskP_loadUpdateAll+0x7a> @ imm = #-0x2
;     }
700a2c4a: e7ff         	b	0x700a2c4c <TaskP_loadUpdateAll+0x7c> @ imm = #-0x2
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a2c4c: 9805         	ldr	r0, [sp, #0x14]
700a2c4e: 3001         	adds	r0, #0x1
700a2c50: 9005         	str	r0, [sp, #0x14]
700a2c52: e7c4         	b	0x700a2bde <TaskP_loadUpdateAll+0xe> @ imm = #-0x78
;     idleTskHndl = xTaskGetIdleTaskHandle();
700a2c54: f00a fed4    	bl	0x700ada00 <xTaskGetIdleTaskHandle> @ imm = #0xada8
700a2c58: 9002         	str	r0, [sp, #0x8]
;     if(idleTskHndl != NULL)
700a2c5a: 9802         	ldr	r0, [sp, #0x8]
700a2c5c: b310         	cbz	r0, 0x700a2ca4 <TaskP_loadUpdateAll+0xd4> @ imm = #0x44
700a2c5e: e7ff         	b	0x700a2c60 <TaskP_loadUpdateAll+0x90> @ imm = #-0x2
;         vTaskGetInfo(idleTskHndl, &taskStatus, pdFALSE, eReady);
700a2c60: 9802         	ldr	r0, [sp, #0x8]
700a2c62: a906         	add	r1, sp, #0x18
700a2c64: 2200         	movs	r2, #0x0
700a2c66: 2301         	movs	r3, #0x1
700a2c68: f001 fa92    	bl	0x700a4190 <vTaskGetInfo> @ imm = #0x1524
;         delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, gTaskP_ctrl.idleTskLastRunTime);
700a2c6c: 980c         	ldr	r0, [sp, #0x30]
700a2c6e: f644 3178    	movw	r1, #0x4b78
700a2c72: f2c7 0108    	movt	r1, #0x7008
700a2c76: 9101         	str	r1, [sp, #0x4]
700a2c78: f8d1 1090    	ldr.w	r1, [r1, #0x90]
700a2c7c: f009 fea8    	bl	0x700ac9d0 <TaskP_calcCounterDiff> @ imm = #0x9d50
700a2c80: 9901         	ldr	r1, [sp, #0x4]
700a2c82: 9004         	str	r0, [sp, #0x10]
;         gTaskP_ctrl.idleTskAccRunTime += delta;
700a2c84: 9b04         	ldr	r3, [sp, #0x10]
700a2c86: f8d1 2098    	ldr.w	r2, [r1, #0x98]
700a2c8a: f8d1 009c    	ldr.w	r0, [r1, #0x9c]
700a2c8e: 18d2         	adds	r2, r2, r3
700a2c90: f140 0000    	adc	r0, r0, #0x0
700a2c94: f8c1 2098    	str.w	r2, [r1, #0x98]
700a2c98: f8c1 009c    	str.w	r0, [r1, #0x9c]
;         gTaskP_ctrl.idleTskLastRunTime = taskStatus.ulRunTimeCounter;
700a2c9c: 980c         	ldr	r0, [sp, #0x30]
700a2c9e: f8c1 0090    	str.w	r0, [r1, #0x90]
;     }
700a2ca2: e7ff         	b	0x700a2ca4 <TaskP_loadUpdateAll+0xd4> @ imm = #-0x2
;     curTotalTime = portGET_RUN_TIME_COUNTER_VALUE();
700a2ca4: f00a fda4    	bl	0x700ad7f0 <uiPortGetRunTimeCounterValue> @ imm = #0xab48
700a2ca8: 9003         	str	r0, [sp, #0xc]
;     delta = TaskP_calcCounterDiff(curTotalTime, gTaskP_ctrl.lastTotalTime);
700a2caa: 9803         	ldr	r0, [sp, #0xc]
700a2cac: f644 3178    	movw	r1, #0x4b78
700a2cb0: f2c7 0108    	movt	r1, #0x7008
700a2cb4: 9100         	str	r1, [sp]
700a2cb6: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700a2cba: f009 fe89    	bl	0x700ac9d0 <TaskP_calcCounterDiff> @ imm = #0x9d12
700a2cbe: 9900         	ldr	r1, [sp]
700a2cc0: 9004         	str	r0, [sp, #0x10]
;     gTaskP_ctrl.accTotalTime += delta;
700a2cc2: 9b04         	ldr	r3, [sp, #0x10]
700a2cc4: f8d1 2088    	ldr.w	r2, [r1, #0x88]
700a2cc8: f8d1 008c    	ldr.w	r0, [r1, #0x8c]
700a2ccc: 18d2         	adds	r2, r2, r3
700a2cce: f140 0000    	adc	r0, r0, #0x0
700a2cd2: f8c1 2088    	str.w	r2, [r1, #0x88]
700a2cd6: f8c1 008c    	str.w	r0, [r1, #0x8c]
;     gTaskP_ctrl.lastTotalTime = curTotalTime;
700a2cda: 9803         	ldr	r0, [sp, #0xc]
700a2cdc: f8c1 0080    	str.w	r0, [r1, #0x80]
;     (void)xTaskResumeAll();
700a2ce0: f7fd ff66    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0x2134
; }
700a2ce4: b010         	add	sp, #0x40
700a2ce6: bd80         	pop	{r7, pc}
		...

700a2cf0 <prvInitialiseNewTask>:
;     const MemoryRegion_t *const xRegions) {
700a2cf0: b580         	push	{r7, lr}
700a2cf2: b088         	sub	sp, #0x20
700a2cf4: f8dd c034    	ldr.w	r12, [sp, #0x34]
700a2cf8: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a2cfc: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a2d00: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a2d04: 9007         	str	r0, [sp, #0x1c]
700a2d06: 9106         	str	r1, [sp, #0x18]
700a2d08: 9205         	str	r2, [sp, #0x14]
700a2d0a: 9304         	str	r3, [sp, #0x10]
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a2d0c: 980c         	ldr	r0, [sp, #0x30]
700a2d0e: 6b00         	ldr	r0, [r0, #0x30]
;                  (size_t)ulStackDepth * sizeof(StackType_t));
700a2d10: 9905         	ldr	r1, [sp, #0x14]
700a2d12: 0089         	lsls	r1, r1, #0x2
700a2d14: 22a5         	movs	r2, #0xa5
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a2d16: f00a edec    	blx	0x700ad8f0 <__aeabi_memset8> @ imm = #0xabd8
;     pxTopOfStack = &(pxNewTCB->pxStack[ulStackDepth - (uint32_t)1]);
700a2d1a: 980c         	ldr	r0, [sp, #0x30]
700a2d1c: 6b00         	ldr	r0, [r0, #0x30]
700a2d1e: 9905         	ldr	r1, [sp, #0x14]
700a2d20: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2d24: 3804         	subs	r0, #0x4
700a2d26: 9003         	str	r0, [sp, #0xc]
;              *)(((portPOINTER_SIZE_TYPE)pxTopOfStack) &
700a2d28: 9803         	ldr	r0, [sp, #0xc]
700a2d2a: f020 0007    	bic	r0, r0, #0x7
;     pxTopOfStack =
700a2d2e: 9003         	str	r0, [sp, #0xc]
;   if (pcName != NULL) {
700a2d30: 9806         	ldr	r0, [sp, #0x18]
700a2d32: b1f8         	cbz	r0, 0x700a2d74 <prvInitialiseNewTask+0x84> @ imm = #0x3e
700a2d34: e7ff         	b	0x700a2d36 <prvInitialiseNewTask+0x46> @ imm = #-0x2
700a2d36: 2000         	movs	r0, #0x0
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a2d38: 9002         	str	r0, [sp, #0x8]
700a2d3a: e7ff         	b	0x700a2d3c <prvInitialiseNewTask+0x4c> @ imm = #-0x2
700a2d3c: 9802         	ldr	r0, [sp, #0x8]
700a2d3e: 281f         	cmp	r0, #0x1f
700a2d40: d813         	bhi	0x700a2d6a <prvInitialiseNewTask+0x7a> @ imm = #0x26
700a2d42: e7ff         	b	0x700a2d44 <prvInitialiseNewTask+0x54> @ imm = #-0x2
;       pxNewTCB->pcTaskName[x] = pcName[x];
700a2d44: 9806         	ldr	r0, [sp, #0x18]
700a2d46: 9a02         	ldr	r2, [sp, #0x8]
700a2d48: 5c80         	ldrb	r0, [r0, r2]
700a2d4a: 990c         	ldr	r1, [sp, #0x30]
700a2d4c: 4411         	add	r1, r2
700a2d4e: f881 0034    	strb.w	r0, [r1, #0x34]
;       if (pcName[x] == (char)0x00) {
700a2d52: 9806         	ldr	r0, [sp, #0x18]
700a2d54: 9902         	ldr	r1, [sp, #0x8]
700a2d56: 5c40         	ldrb	r0, [r0, r1]
700a2d58: b908         	cbnz	r0, 0x700a2d5e <prvInitialiseNewTask+0x6e> @ imm = #0x2
700a2d5a: e7ff         	b	0x700a2d5c <prvInitialiseNewTask+0x6c> @ imm = #-0x2
;         break;
700a2d5c: e005         	b	0x700a2d6a <prvInitialiseNewTask+0x7a> @ imm = #0xa
700a2d5e: e7ff         	b	0x700a2d60 <prvInitialiseNewTask+0x70> @ imm = #-0x2
;     }
700a2d60: e7ff         	b	0x700a2d62 <prvInitialiseNewTask+0x72> @ imm = #-0x2
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a2d62: 9802         	ldr	r0, [sp, #0x8]
700a2d64: 3001         	adds	r0, #0x1
700a2d66: 9002         	str	r0, [sp, #0x8]
700a2d68: e7e8         	b	0x700a2d3c <prvInitialiseNewTask+0x4c> @ imm = #-0x30
;     pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
700a2d6a: 990c         	ldr	r1, [sp, #0x30]
700a2d6c: 2000         	movs	r0, #0x0
700a2d6e: f881 0053    	strb.w	r0, [r1, #0x53]
;   } else {
700a2d72: e004         	b	0x700a2d7e <prvInitialiseNewTask+0x8e> @ imm = #0x8
;     pxNewTCB->pcTaskName[0] = 0x00;
700a2d74: 990c         	ldr	r1, [sp, #0x30]
700a2d76: 2000         	movs	r0, #0x0
700a2d78: f881 0034    	strb.w	r0, [r1, #0x34]
700a2d7c: e7ff         	b	0x700a2d7e <prvInitialiseNewTask+0x8e> @ imm = #-0x2
;   if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES) {
700a2d7e: 980a         	ldr	r0, [sp, #0x28]
700a2d80: 2820         	cmp	r0, #0x20
700a2d82: d303         	blo	0x700a2d8c <prvInitialiseNewTask+0x9c> @ imm = #0x6
700a2d84: e7ff         	b	0x700a2d86 <prvInitialiseNewTask+0x96> @ imm = #-0x2
700a2d86: 201f         	movs	r0, #0x1f
;     uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
700a2d88: 900a         	str	r0, [sp, #0x28]
;   } else {
700a2d8a: e000         	b	0x700a2d8e <prvInitialiseNewTask+0x9e> @ imm = #0x0
700a2d8c: e7ff         	b	0x700a2d8e <prvInitialiseNewTask+0x9e> @ imm = #-0x2
;   pxNewTCB->uxPriority = uxPriority;
700a2d8e: 980a         	ldr	r0, [sp, #0x28]
700a2d90: 990c         	ldr	r1, [sp, #0x30]
700a2d92: 62c8         	str	r0, [r1, #0x2c]
;     pxNewTCB->uxBasePriority = uxPriority;
700a2d94: 980a         	ldr	r0, [sp, #0x28]
700a2d96: 990c         	ldr	r1, [sp, #0x30]
700a2d98: 6608         	str	r0, [r1, #0x60]
;     pxNewTCB->uxMutexesHeld = 0;
700a2d9a: 990c         	ldr	r1, [sp, #0x30]
700a2d9c: 2000         	movs	r0, #0x0
700a2d9e: 9001         	str	r0, [sp, #0x4]
700a2da0: 6648         	str	r0, [r1, #0x64]
;   vListInitialiseItem(&(pxNewTCB->xStateListItem));
700a2da2: 980c         	ldr	r0, [sp, #0x30]
700a2da4: 3004         	adds	r0, #0x4
700a2da6: f00a fdc3    	bl	0x700ad930 <vListInitialiseItem> @ imm = #0xab86
;   vListInitialiseItem(&(pxNewTCB->xEventListItem));
700a2daa: 980c         	ldr	r0, [sp, #0x30]
700a2dac: 3018         	adds	r0, #0x18
700a2dae: f00a fdbf    	bl	0x700ad930 <vListInitialiseItem> @ imm = #0xab7e
700a2db2: 9801         	ldr	r0, [sp, #0x4]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
700a2db4: 990c         	ldr	r1, [sp, #0x30]
700a2db6: 6109         	str	r1, [r1, #0x10]
;   listSET_LIST_ITEM_VALUE(
700a2db8: 990a         	ldr	r1, [sp, #0x28]
700a2dba: f1c1 0120    	rsb.w	r1, r1, #0x20
700a2dbe: 9a0c         	ldr	r2, [sp, #0x30]
700a2dc0: 6191         	str	r1, [r2, #0x18]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
700a2dc2: 990c         	ldr	r1, [sp, #0x30]
700a2dc4: 6249         	str	r1, [r1, #0x24]
;     pxNewTCB->uxCriticalNesting = (UBaseType_t)0U;
700a2dc6: 990c         	ldr	r1, [sp, #0x30]
700a2dc8: 6548         	str	r0, [r1, #0x54]
;     pxNewTCB->pxTaskTag = NULL;
700a2dca: 990c         	ldr	r1, [sp, #0x30]
700a2dcc: 6688         	str	r0, [r1, #0x68]
;     memset((void *)&(pxNewTCB->pvThreadLocalStoragePointers[0]), 0x00,
700a2dce: 990c         	ldr	r1, [sp, #0x30]
700a2dd0: 6788         	str	r0, [r1, #0x78]
700a2dd2: 6748         	str	r0, [r1, #0x74]
700a2dd4: 6708         	str	r0, [r1, #0x70]
700a2dd6: 66c8         	str	r0, [r1, #0x6c]
;     memset((void *)&(pxNewTCB->ulNotifiedValue[0]), 0x00,
700a2dd8: 990c         	ldr	r1, [sp, #0x30]
700a2dda: f8c1 0080    	str.w	r0, [r1, #0x80]
700a2dde: 67c8         	str	r0, [r1, #0x7c]
;     memset((void *)&(pxNewTCB->ucNotifyState[0]), 0x00,
700a2de0: 990c         	ldr	r1, [sp, #0x30]
700a2de2: f8a1 0084    	strh.w	r0, [r1, #0x84]
;           pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
700a2de6: 9803         	ldr	r0, [sp, #0xc]
700a2de8: 9907         	ldr	r1, [sp, #0x1c]
700a2dea: 9a04         	ldr	r2, [sp, #0x10]
700a2dec: f7fe fe30    	bl	0x700a1a50 <pxPortInitialiseStack> @ imm = #-0x13a0
;       pxNewTCB->pxTopOfStack =
700a2df0: 990c         	ldr	r1, [sp, #0x30]
700a2df2: 6008         	str	r0, [r1]
;   if (pxCreatedTask != NULL) {
700a2df4: 980b         	ldr	r0, [sp, #0x2c]
700a2df6: b120         	cbz	r0, 0x700a2e02 <prvInitialiseNewTask+0x112> @ imm = #0x8
700a2df8: e7ff         	b	0x700a2dfa <prvInitialiseNewTask+0x10a> @ imm = #-0x2
;     *pxCreatedTask = (TaskHandle_t)pxNewTCB;
700a2dfa: 980c         	ldr	r0, [sp, #0x30]
700a2dfc: 990b         	ldr	r1, [sp, #0x2c]
700a2dfe: 6008         	str	r0, [r1]
;   } else {
700a2e00: e000         	b	0x700a2e04 <prvInitialiseNewTask+0x114> @ imm = #0x0
700a2e02: e7ff         	b	0x700a2e04 <prvInitialiseNewTask+0x114> @ imm = #-0x2
; }
700a2e04: b008         	add	sp, #0x20
700a2e06: bd80         	pop	{r7, pc}

700a2e08 <__udivmoddi4>:
700a2e08: e1530001     	cmp	r3, r1
700a2e0c: 01520000     	cmpeq	r2, r0
700a2e10: 9a000007     	bls	0x700a2e34 <__udivmoddi4+0x2c> @ imm = #0x1c
700a2e14: e59d2000     	ldr	r2, [sp]
700a2e18: e3520000     	cmp	r2, #0
700a2e1c: 0a000001     	beq	0x700a2e28 <__udivmoddi4+0x20> @ imm = #0x4
700a2e20: e5820000     	str	r0, [r2]
700a2e24: e5821004     	str	r1, [r2, #0x4]
700a2e28: e3b01000     	movs	r1, #0
700a2e2c: e3b00000     	movs	r0, #0
700a2e30: e12fff1e     	bx	lr
700a2e34: e3530000     	cmp	r3, #0
700a2e38: 03520000     	cmpeq	r2, #0
700a2e3c: 1a00000d     	bne	0x700a2e78 <__udivmoddi4+0x70> @ imm = #0x34
700a2e40: e59d2000     	ldr	r2, [sp]
700a2e44: e3520000     	cmp	r2, #0
700a2e48: 0a000001     	beq	0x700a2e54 <__udivmoddi4+0x4c> @ imm = #0x4
700a2e4c: e5820000     	str	r0, [r2]
700a2e50: e5821004     	str	r1, [r2, #0x4]
700a2e54: e1b02000     	movs	r2, r0
700a2e58: e1b03001     	movs	r3, r1
700a2e5c: e3b01000     	movs	r1, #0
700a2e60: e3b00000     	movs	r0, #0
700a2e64: e3530000     	cmp	r3, #0
700a2e68: 03520000     	cmpeq	r2, #0
700a2e6c: 11e01001     	mvnne	r1, r1
700a2e70: 11e00000     	mvnne	r0, r0
700a2e74: eaffded7     	b	0x7009a9d8 <__aeabi_ldiv0> @ imm = #-0x84a4
700a2e78: e92d40f0     	push	{r4, r5, r6, r7, lr}
700a2e7c: e1a04003     	mov	r4, r3
700a2e80: e1a05002     	mov	r5, r2
700a2e84: e1a03001     	mov	r3, r1
700a2e88: e1a02000     	mov	r2, r0
700a2e8c: e3b00000     	movs	r0, #0
700a2e90: e3b01000     	movs	r1, #0
700a2e94: e16f6f14     	clz	r6, r4
700a2e98: e3560020     	cmp	r6, #32
700a2e9c: 016f6f15     	clzeq	r6, r5
700a2ea0: 02866020     	addeq	r6, r6, #32
700a2ea4: e16f7f13     	clz	r7, r3
700a2ea8: e3570020     	cmp	r7, #32
700a2eac: 016f7f12     	clzeq	r7, r2
700a2eb0: 02877020     	addeq	r7, r7, #32
700a2eb4: e0566007     	subs	r6, r6, r7
700a2eb8: e2567020     	subs	r7, r6, #32
700a2ebc: 21a04715     	lslhs	r4, r5, r7
700a2ec0: 23a05000     	movhs	r5, #0
700a2ec4: 32677000     	rsblo	r7, r7, #0
700a2ec8: 31a04614     	lsllo	r4, r4, r6
700a2ecc: 31a07735     	lsrlo	r7, r5, r7
700a2ed0: 31844007     	orrlo	r4, r4, r7
700a2ed4: 31a05615     	lsllo	r5, r5, r6
700a2ed8: e1530004     	cmp	r3, r4
700a2edc: 01520005     	cmpeq	r2, r5
700a2ee0: 3a000001     	blo	0x700a2eec <__udivmoddi4+0xe4> @ imm = #0x4
700a2ee4: e0522005     	subs	r2, r2, r5
700a2ee8: e0d33004     	sbcs	r3, r3, r4
700a2eec: e0b00000     	adcs	r0, r0, r0
700a2ef0: e0b11001     	adcs	r1, r1, r1
700a2ef4: e1b050a5     	lsrs	r5, r5, #1
700a2ef8: e1855f84     	orr	r5, r5, r4, lsl #31
700a2efc: e1b040a4     	lsrs	r4, r4, #1
700a2f00: e2566001     	subs	r6, r6, #1
700a2f04: 5afffff3     	bpl	0x700a2ed8 <__udivmoddi4+0xd0> @ imm = #-0x34
700a2f08: e59d7014     	ldr	r7, [sp, #0x14]
700a2f0c: e3570000     	cmp	r7, #0
700a2f10: 0a000001     	beq	0x700a2f1c <__udivmoddi4+0x114> @ imm = #0x4
700a2f14: e5872000     	str	r2, [r7]
700a2f18: e5873004     	str	r3, [r7, #0x4]
700a2f1c: e8bd80f0     	pop	{r4, r5, r6, r7, pc}

700a2f20 <CSL_bcdmaChanOpDecChanStats>:
; {
700a2f20: b580         	push	{r7, lr}
700a2f22: b088         	sub	sp, #0x20
700a2f24: 9007         	str	r0, [sp, #0x1c]
700a2f26: 9106         	str	r1, [sp, #0x18]
700a2f28: 9205         	str	r2, [sp, #0x14]
700a2f2a: 9304         	str	r3, [sp, #0x10]
700a2f2c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a2f2e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a2f30: 9804         	ldr	r0, [sp, #0x10]
700a2f32: b920         	cbnz	r0, 0x700a2f3e <CSL_bcdmaChanOpDecChanStats+0x1e> @ imm = #0x8
700a2f34: e7ff         	b	0x700a2f36 <CSL_bcdmaChanOpDecChanStats+0x16> @ imm = #-0x2
700a2f36: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a2f3a: 9003         	str	r0, [sp, #0xc]
;     }
700a2f3c: e078         	b	0x700a3030 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #0xf0
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a2f3e: 9804         	ldr	r0, [sp, #0x10]
700a2f40: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a2f42: 9806         	ldr	r0, [sp, #0x18]
700a2f44: 9001         	str	r0, [sp, #0x4]
700a2f46: b140         	cbz	r0, 0x700a2f5a <CSL_bcdmaChanOpDecChanStats+0x3a> @ imm = #0x10
700a2f48: e7ff         	b	0x700a2f4a <CSL_bcdmaChanOpDecChanStats+0x2a> @ imm = #-0x2
700a2f4a: 9801         	ldr	r0, [sp, #0x4]
700a2f4c: 2801         	cmp	r0, #0x1
700a2f4e: d026         	beq	0x700a2f9e <CSL_bcdmaChanOpDecChanStats+0x7e> @ imm = #0x4c
700a2f50: e7ff         	b	0x700a2f52 <CSL_bcdmaChanOpDecChanStats+0x32> @ imm = #-0x2
700a2f52: 9801         	ldr	r0, [sp, #0x4]
700a2f54: 2802         	cmp	r0, #0x2
700a2f56: d044         	beq	0x700a2fe2 <CSL_bcdmaChanOpDecChanStats+0xc2> @ imm = #0x88
700a2f58: e065         	b	0x700a3026 <CSL_bcdmaChanOpDecChanStats+0x106> @ imm = #0xca
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a2f5a: 9807         	ldr	r0, [sp, #0x1c]
700a2f5c: 6880         	ldr	r0, [r0, #0x8]
700a2f5e: 9905         	ldr	r1, [sp, #0x14]
700a2f60: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2f64: f500 6080    	add.w	r0, r0, #0x400
700a2f68: 9902         	ldr	r1, [sp, #0x8]
700a2f6a: 6809         	ldr	r1, [r1]
700a2f6c: f00a fc50    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xa8a0
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a2f70: 9807         	ldr	r0, [sp, #0x1c]
700a2f72: 6880         	ldr	r0, [r0, #0x8]
700a2f74: 9905         	ldr	r1, [sp, #0x14]
700a2f76: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2f7a: f500 6081    	add.w	r0, r0, #0x408
700a2f7e: 9902         	ldr	r1, [sp, #0x8]
700a2f80: 6849         	ldr	r1, [r1, #0x4]
700a2f82: f00a fc45    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xa88a
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a2f86: 9807         	ldr	r0, [sp, #0x1c]
700a2f88: 6880         	ldr	r0, [r0, #0x8]
700a2f8a: 9905         	ldr	r1, [sp, #0x14]
700a2f8c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2f90: f500 6082    	add.w	r0, r0, #0x410
700a2f94: 9902         	ldr	r1, [sp, #0x8]
700a2f96: 6889         	ldr	r1, [r1, #0x8]
700a2f98: f00a fc3a    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xa874
;                 break;
700a2f9c: e047         	b	0x700a302e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x8e
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a2f9e: 9807         	ldr	r0, [sp, #0x1c]
700a2fa0: 6900         	ldr	r0, [r0, #0x10]
700a2fa2: 9905         	ldr	r1, [sp, #0x14]
700a2fa4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2fa8: f500 6080    	add.w	r0, r0, #0x400
700a2fac: 9902         	ldr	r1, [sp, #0x8]
700a2fae: 6809         	ldr	r1, [r1]
700a2fb0: f00a fc2e    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xa85c
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a2fb4: 9807         	ldr	r0, [sp, #0x1c]
700a2fb6: 6900         	ldr	r0, [r0, #0x10]
700a2fb8: 9905         	ldr	r1, [sp, #0x14]
700a2fba: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2fbe: f500 6081    	add.w	r0, r0, #0x408
700a2fc2: 9902         	ldr	r1, [sp, #0x8]
700a2fc4: 6849         	ldr	r1, [r1, #0x4]
700a2fc6: f00a fc23    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xa846
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a2fca: 9807         	ldr	r0, [sp, #0x1c]
700a2fcc: 6900         	ldr	r0, [r0, #0x10]
700a2fce: 9905         	ldr	r1, [sp, #0x14]
700a2fd0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2fd4: f500 6082    	add.w	r0, r0, #0x410
700a2fd8: 9902         	ldr	r1, [sp, #0x8]
700a2fda: 6889         	ldr	r1, [r1, #0x8]
700a2fdc: f00a fc18    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xa830
;                 break;
700a2fe0: e025         	b	0x700a302e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x4a
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a2fe2: 9807         	ldr	r0, [sp, #0x1c]
700a2fe4: 6980         	ldr	r0, [r0, #0x18]
700a2fe6: 9905         	ldr	r1, [sp, #0x14]
700a2fe8: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2fec: f500 6080    	add.w	r0, r0, #0x400
700a2ff0: 9902         	ldr	r1, [sp, #0x8]
700a2ff2: 6809         	ldr	r1, [r1]
700a2ff4: f00a fc0c    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xa818
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->rxPayloadByteCnt );
700a2ff8: 9807         	ldr	r0, [sp, #0x1c]
700a2ffa: 6980         	ldr	r0, [r0, #0x18]
700a2ffc: 9905         	ldr	r1, [sp, #0x14]
700a2ffe: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3002: f500 6081    	add.w	r0, r0, #0x408
700a3006: 9902         	ldr	r1, [sp, #0x8]
700a3008: 68c9         	ldr	r1, [r1, #0xc]
700a300a: f00a fc01    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xa802
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->rxStartedByteCnt );
700a300e: 9807         	ldr	r0, [sp, #0x1c]
700a3010: 6980         	ldr	r0, [r0, #0x18]
700a3012: 9905         	ldr	r1, [sp, #0x14]
700a3014: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3018: f500 6082    	add.w	r0, r0, #0x410
700a301c: 9902         	ldr	r1, [sp, #0x8]
700a301e: 6909         	ldr	r1, [r1, #0x10]
700a3020: f00a fbf6    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0xa7ec
;                 break;
700a3024: e003         	b	0x700a302e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x6
700a3026: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a302a: 9003         	str	r0, [sp, #0xc]
;                 break;
700a302c: e7ff         	b	0x700a302e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #-0x2
700a302e: e7ff         	b	0x700a3030 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #-0x2
;     return retVal;
700a3030: 9803         	ldr	r0, [sp, #0xc]
700a3032: b008         	add	sp, #0x20
700a3034: bd80         	pop	{r7, pc}
		...
700a303e: 0000         	movs	r0, r0

700a3040 <UART_divisorLatchWrite>:
; {
700a3040: b580         	push	{r7, lr}
700a3042: b08c         	sub	sp, #0x30
700a3044: 900b         	str	r0, [sp, #0x2c]
700a3046: 910a         	str	r1, [sp, #0x28]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a3048: 980b         	ldr	r0, [sp, #0x2c]
700a304a: 21bf         	movs	r1, #0xbf
700a304c: 9102         	str	r1, [sp, #0x8]
700a304e: f007 fb1f    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x763e
700a3052: 9007         	str	r0, [sp, #0x1c]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a3054: 980b         	ldr	r0, [sp, #0x2c]
700a3056: 3008         	adds	r0, #0x8
700a3058: 2110         	movs	r1, #0x10
700a305a: 9103         	str	r1, [sp, #0xc]
700a305c: 2204         	movs	r2, #0x4
700a305e: 9204         	str	r2, [sp, #0x10]
700a3060: f00a f84e    	bl	0x700ad100 <HW_RD_FIELD32_RAW> @ imm = #0xa09c
700a3064: 9903         	ldr	r1, [sp, #0xc]
700a3066: 9a04         	ldr	r2, [sp, #0x10]
700a3068: 9009         	str	r0, [sp, #0x24]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a306a: 980b         	ldr	r0, [sp, #0x2c]
700a306c: 3008         	adds	r0, #0x8
700a306e: 2301         	movs	r3, #0x1
700a3070: f009 fa2e    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x945c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a3074: 980b         	ldr	r0, [sp, #0x2c]
700a3076: 300c         	adds	r0, #0xc
700a3078: 9907         	ldr	r1, [sp, #0x1c]
700a307a: f00a fc29    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0xa852
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a307e: 980b         	ldr	r0, [sp, #0x2c]
700a3080: 217f         	movs	r1, #0x7f
700a3082: 9101         	str	r1, [sp, #0x4]
700a3084: f007 fb04    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x7608
700a3088: 9903         	ldr	r1, [sp, #0xc]
700a308a: 9a04         	ldr	r2, [sp, #0x10]
700a308c: 9007         	str	r0, [sp, #0x1c]
;     sleepMdBitVal = HW_RD_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE);
700a308e: 980b         	ldr	r0, [sp, #0x2c]
700a3090: 3004         	adds	r0, #0x4
700a3092: f00a f835    	bl	0x700ad100 <HW_RD_FIELD32_RAW> @ imm = #0xa06a
700a3096: 9903         	ldr	r1, [sp, #0xc]
700a3098: 9a04         	ldr	r2, [sp, #0x10]
700a309a: 9008         	str	r0, [sp, #0x20]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, 0U);
700a309c: 980b         	ldr	r0, [sp, #0x2c]
700a309e: 3004         	adds	r0, #0x4
700a30a0: 2300         	movs	r3, #0x0
700a30a2: f009 fa15    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x942a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a30a6: 980b         	ldr	r0, [sp, #0x2c]
700a30a8: 300c         	adds	r0, #0xc
700a30aa: 9907         	ldr	r1, [sp, #0x1c]
700a30ac: f00a fc10    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0xa820
700a30b0: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a30b2: 980b         	ldr	r0, [sp, #0x2c]
700a30b4: f007 faec    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x75d8
700a30b8: 9007         	str	r0, [sp, #0x1c]
;     divRegVal  = HW_RD_REG32(baseAddr + UART_DLL) & 0xFFU;
700a30ba: 980b         	ldr	r0, [sp, #0x2c]
700a30bc: f00a fc00    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0xa800
700a30c0: b2c0         	uxtb	r0, r0
700a30c2: 9005         	str	r0, [sp, #0x14]
;     divRegVal |= (HW_RD_REG32(baseAddr + UART_DLH) & 0x3FU) << 8;
700a30c4: 980b         	ldr	r0, [sp, #0x2c]
700a30c6: 3004         	adds	r0, #0x4
700a30c8: f00a fbfa    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0xa7f4
700a30cc: f000 013f    	and	r1, r0, #0x3f
700a30d0: 9805         	ldr	r0, [sp, #0x14]
700a30d2: ea40 2001    	orr.w	r0, r0, r1, lsl #8
700a30d6: 9005         	str	r0, [sp, #0x14]
;     operMode = UART_operatingModeSelect(baseAddr,
700a30d8: 980b         	ldr	r0, [sp, #0x2c]
700a30da: 2107         	movs	r1, #0x7
700a30dc: f009 fd98    	bl	0x700acc10 <UART_operatingModeSelect> @ imm = #0x9b30
700a30e0: 9006         	str	r0, [sp, #0x18]
;     HW_WR_REG32(baseAddr + UART_DLL, divisorValue & 0x00FFU);
700a30e2: 980b         	ldr	r0, [sp, #0x2c]
700a30e4: f89d 1028    	ldrb.w	r1, [sp, #0x28]
700a30e8: f00a fbf2    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0xa7e4
;     HW_WR_REG32(baseAddr + UART_DLH, (divisorValue & 0x3F00U) >> 8);
700a30ec: 980b         	ldr	r0, [sp, #0x2c]
700a30ee: 3004         	adds	r0, #0x4
700a30f0: 990a         	ldr	r1, [sp, #0x28]
700a30f2: f3c1 2105    	ubfx	r1, r1, #0x8, #0x6
700a30f6: f00a fbeb    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0xa7d6
;     (void) UART_operatingModeSelect(baseAddr, operMode);
700a30fa: 980b         	ldr	r0, [sp, #0x2c]
700a30fc: 9906         	ldr	r1, [sp, #0x18]
700a30fe: f009 fd87    	bl	0x700acc10 <UART_operatingModeSelect> @ imm = #0x9b0e
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a3102: 980b         	ldr	r0, [sp, #0x2c]
700a3104: 300c         	adds	r0, #0xc
700a3106: 9907         	ldr	r1, [sp, #0x1c]
700a3108: f00a fbe2    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0xa7c4
700a310c: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a310e: 980b         	ldr	r0, [sp, #0x2c]
700a3110: f007 fabe    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x757c
700a3114: 9903         	ldr	r1, [sp, #0xc]
700a3116: 9a04         	ldr	r2, [sp, #0x10]
700a3118: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, sleepMdBitVal);
700a311a: 980b         	ldr	r0, [sp, #0x2c]
700a311c: 3004         	adds	r0, #0x4
700a311e: 9b08         	ldr	r3, [sp, #0x20]
700a3120: f009 f9d6    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x93ac
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a3124: 980b         	ldr	r0, [sp, #0x2c]
700a3126: 300c         	adds	r0, #0xc
700a3128: 9907         	ldr	r1, [sp, #0x1c]
700a312a: f00a fbd1    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0xa7a2
700a312e: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a3130: 980b         	ldr	r0, [sp, #0x2c]
700a3132: f007 faad    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x755a
700a3136: 9903         	ldr	r1, [sp, #0xc]
700a3138: 9a04         	ldr	r2, [sp, #0x10]
700a313a: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a313c: 980b         	ldr	r0, [sp, #0x2c]
700a313e: 3008         	adds	r0, #0x8
700a3140: 9b09         	ldr	r3, [sp, #0x24]
700a3142: f009 f9c5    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x938a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a3146: 980b         	ldr	r0, [sp, #0x2c]
700a3148: 300c         	adds	r0, #0xc
700a314a: 9907         	ldr	r1, [sp, #0x1c]
700a314c: f00a fbc0    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0xa780
;     return divRegVal;
700a3150: 9805         	ldr	r0, [sp, #0x14]
700a3152: b00c         	add	sp, #0x30
700a3154: bd80         	pop	{r7, pc}
		...
700a315e: 0000         	movs	r0, r0

700a3160 <_ntoa_long>:
; {
700a3160: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a3164: b098         	sub	sp, #0x60
700a3166: 4684         	mov	r12, r0
700a3168: 9823         	ldr	r0, [sp, #0x8c]
700a316a: 9822         	ldr	r0, [sp, #0x88]
700a316c: 9821         	ldr	r0, [sp, #0x84]
700a316e: 9820         	ldr	r0, [sp, #0x80]
700a3170: 981f         	ldr	r0, [sp, #0x7c]
700a3172: f8dd e078    	ldr.w	lr, [sp, #0x78]
700a3176: f8cd c05c    	str.w	r12, [sp, #0x5c]
700a317a: 9116         	str	r1, [sp, #0x58]
700a317c: 9215         	str	r2, [sp, #0x54]
700a317e: 9314         	str	r3, [sp, #0x50]
700a3180: f88d 004f    	strb.w	r0, [sp, #0x4f]
700a3184: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a3186: 900a         	str	r0, [sp, #0x28]
;   if (!value) {
700a3188: 981e         	ldr	r0, [sp, #0x78]
700a318a: b928         	cbnz	r0, 0x700a3198 <_ntoa_long+0x38> @ imm = #0xa
700a318c: e7ff         	b	0x700a318e <_ntoa_long+0x2e> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a318e: 9823         	ldr	r0, [sp, #0x8c]
700a3190: f020 0010    	bic	r0, r0, #0x10
700a3194: 9023         	str	r0, [sp, #0x8c]
;   }
700a3196: e7ff         	b	0x700a3198 <_ntoa_long+0x38> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a3198: f89d 008d    	ldrb.w	r0, [sp, #0x8d]
700a319c: 0740         	lsls	r0, r0, #0x1d
700a319e: 2800         	cmp	r0, #0x0
700a31a0: d504         	bpl	0x700a31ac <_ntoa_long+0x4c> @ imm = #0x8
700a31a2: e7ff         	b	0x700a31a4 <_ntoa_long+0x44> @ imm = #-0x2
700a31a4: 981e         	ldr	r0, [sp, #0x78]
700a31a6: 2800         	cmp	r0, #0x0
700a31a8: d03f         	beq	0x700a322a <_ntoa_long+0xca> @ imm = #0x7e
700a31aa: e7ff         	b	0x700a31ac <_ntoa_long+0x4c> @ imm = #-0x2
;     do {
700a31ac: e7ff         	b	0x700a31ae <_ntoa_long+0x4e> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a31ae: 9a1e         	ldr	r2, [sp, #0x78]
700a31b0: 9920         	ldr	r1, [sp, #0x80]
700a31b2: fbb2 f0f1    	udiv	r0, r2, r1
700a31b6: fb00 2011    	mls	r0, r0, r1, r2
700a31ba: f88d 0027    	strb.w	r0, [sp, #0x27]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a31be: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a31c2: 2809         	cmp	r0, #0x9
700a31c4: dc05         	bgt	0x700a31d2 <_ntoa_long+0x72> @ imm = #0xa
700a31c6: e7ff         	b	0x700a31c8 <_ntoa_long+0x68> @ imm = #-0x2
700a31c8: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a31cc: 3030         	adds	r0, #0x30
700a31ce: 9008         	str	r0, [sp, #0x20]
700a31d0: e00c         	b	0x700a31ec <_ntoa_long+0x8c> @ imm = #0x18
700a31d2: f89d 008c    	ldrb.w	r0, [sp, #0x8c]
700a31d6: 0681         	lsls	r1, r0, #0x1a
700a31d8: 2061         	movs	r0, #0x61
700a31da: 2900         	cmp	r1, #0x0
700a31dc: bf48         	it	mi
700a31de: 2041         	movmi	r0, #0x41
700a31e0: f89d 1027    	ldrb.w	r1, [sp, #0x27]
700a31e4: 4408         	add	r0, r1
700a31e6: 380a         	subs	r0, #0xa
700a31e8: 9008         	str	r0, [sp, #0x20]
700a31ea: e7ff         	b	0x700a31ec <_ntoa_long+0x8c> @ imm = #-0x2
700a31ec: 9808         	ldr	r0, [sp, #0x20]
700a31ee: 9a0a         	ldr	r2, [sp, #0x28]
700a31f0: 1c51         	adds	r1, r2, #0x1
700a31f2: 910a         	str	r1, [sp, #0x28]
700a31f4: f10d 012f    	add.w	r1, sp, #0x2f
700a31f8: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a31fa: 9920         	ldr	r1, [sp, #0x80]
700a31fc: 981e         	ldr	r0, [sp, #0x78]
700a31fe: fbb0 f0f1    	udiv	r0, r0, r1
700a3202: 901e         	str	r0, [sp, #0x78]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a3204: e7ff         	b	0x700a3206 <_ntoa_long+0xa6> @ imm = #-0x2
700a3206: 991e         	ldr	r1, [sp, #0x78]
700a3208: 2000         	movs	r0, #0x0
700a320a: 9007         	str	r0, [sp, #0x1c]
700a320c: b139         	cbz	r1, 0x700a321e <_ntoa_long+0xbe> @ imm = #0xe
700a320e: e7ff         	b	0x700a3210 <_ntoa_long+0xb0> @ imm = #-0x2
700a3210: 990a         	ldr	r1, [sp, #0x28]
700a3212: 2000         	movs	r0, #0x0
700a3214: 2920         	cmp	r1, #0x20
700a3216: bf38         	it	lo
700a3218: 2001         	movlo	r0, #0x1
700a321a: 9007         	str	r0, [sp, #0x1c]
700a321c: e7ff         	b	0x700a321e <_ntoa_long+0xbe> @ imm = #-0x2
700a321e: 9807         	ldr	r0, [sp, #0x1c]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a3220: 07c0         	lsls	r0, r0, #0x1f
700a3222: 2800         	cmp	r0, #0x0
700a3224: d1c3         	bne	0x700a31ae <_ntoa_long+0x4e> @ imm = #-0x7a
700a3226: e7ff         	b	0x700a3228 <_ntoa_long+0xc8> @ imm = #-0x2
;   }
700a3228: e7ff         	b	0x700a322a <_ntoa_long+0xca> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a322a: 9817         	ldr	r0, [sp, #0x5c]
700a322c: 9916         	ldr	r1, [sp, #0x58]
700a322e: 9a15         	ldr	r2, [sp, #0x54]
700a3230: 9b14         	ldr	r3, [sp, #0x50]
700a3232: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a3236: 9d20         	ldr	r5, [sp, #0x80]
700a3238: 9e21         	ldr	r6, [sp, #0x84]
700a323a: 9f22         	ldr	r7, [sp, #0x88]
700a323c: f8dd 808c    	ldr.w	r8, [sp, #0x8c]
700a3240: f89d 404f    	ldrb.w	r4, [sp, #0x4f]
700a3244: 46ee         	mov	lr, sp
700a3246: f8ce 8018    	str.w	r8, [lr, #0x18]
700a324a: f8ce 7014    	str.w	r7, [lr, #0x14]
700a324e: f8ce 6010    	str.w	r6, [lr, #0x10]
700a3252: f8ce 500c    	str.w	r5, [lr, #0xc]
700a3256: f004 0401    	and	r4, r4, #0x1
700a325a: f8ce 4008    	str.w	r4, [lr, #0x8]
700a325e: f8ce c004    	str.w	r12, [lr, #0x4]
700a3262: f10d 0c2f    	add.w	r12, sp, #0x2f
700a3266: f8ce c000    	str.w	r12, [lr]
700a326a: f7f9 fee9    	bl	0x7009d040 <_ntoa_format> @ imm = #-0x622e
700a326e: b018         	add	sp, #0x60
700a3270: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a3280 <Sciclient_pmSetModuleClkFreq>:
; {
700a3280: b580         	push	{r7, lr}
700a3282: b09a         	sub	sp, #0x68
700a3284: f8dd c074    	ldr.w	r12, [sp, #0x74]
700a3288: f8dd c070    	ldr.w	r12, [sp, #0x70]
700a328c: 9019         	str	r0, [sp, #0x64]
700a328e: 9118         	str	r1, [sp, #0x60]
700a3290: 9317         	str	r3, [sp, #0x5c]
700a3292: 9216         	str	r2, [sp, #0x58]
700a3294: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a3296: 9015         	str	r0, [sp, #0x54]
;     request.device         = (uint32_t) moduleId;
700a3298: 9819         	ldr	r0, [sp, #0x64]
700a329a: 900c         	str	r0, [sp, #0x30]
;     request.min_freq_hz    = (uint64_t) freqHz;
700a329c: 9816         	ldr	r0, [sp, #0x58]
700a329e: 9917         	ldr	r1, [sp, #0x5c]
700a32a0: 910e         	str	r1, [sp, #0x38]
700a32a2: 900d         	str	r0, [sp, #0x34]
;     request.target_freq_hz = (uint64_t) freqHz;
700a32a4: 9816         	ldr	r0, [sp, #0x58]
700a32a6: 9917         	ldr	r1, [sp, #0x5c]
700a32a8: 9110         	str	r1, [sp, #0x40]
700a32aa: 900f         	str	r0, [sp, #0x3c]
;     request.max_freq_hz    = (uint64_t) freqHz;
700a32ac: 9816         	ldr	r0, [sp, #0x58]
700a32ae: 9917         	ldr	r1, [sp, #0x5c]
700a32b0: 9112         	str	r1, [sp, #0x48]
700a32b2: 9011         	str	r0, [sp, #0x44]
;     if((freqHz%10U) != 0U)
700a32b4: 9b16         	ldr	r3, [sp, #0x58]
700a32b6: 9817         	ldr	r0, [sp, #0x5c]
700a32b8: f64c 41cd    	movw	r1, #0xcccd
700a32bc: f6cc 41cc    	movt	r1, #0xcccc
700a32c0: fba3 2e01    	umull	r2, lr, r3, r1
700a32c4: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a32c8: fb03 e30c    	mla	r3, r3, r12, lr
700a32cc: fb00 3101    	mla	r1, r0, r1, r3
700a32d0: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a32d4: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a32d8: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a32dc: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a32e0: f649 129a    	movw	r2, #0x999a
700a32e4: f6c9 1299    	movt	r2, #0x9999
700a32e8: 1a89         	subs	r1, r1, r2
700a32ea: f649 1199    	movw	r1, #0x9999
700a32ee: f6c1 1199    	movt	r1, #0x1999
700a32f2: 4188         	sbcs	r0, r1
700a32f4: d316         	blo	0x700a3324 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #0x2c
700a32f6: e7ff         	b	0x700a32f8 <Sciclient_pmSetModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(freqHz-(freqHz%10U));
700a32f8: 9816         	ldr	r0, [sp, #0x58]
700a32fa: 9001         	str	r0, [sp, #0x4]
700a32fc: 9917         	ldr	r1, [sp, #0x5c]
700a32fe: 9100         	str	r1, [sp]
700a3300: 220a         	movs	r2, #0xa
700a3302: 2300         	movs	r3, #0x0
700a3304: f009 ee5e    	blx	0x700acfc4 <__aeabi_uldivmod> @ imm = #0x9cbc
700a3308: 9800         	ldr	r0, [sp]
700a330a: 9901         	ldr	r1, [sp, #0x4]
700a330c: 1a89         	subs	r1, r1, r2
700a330e: 4198         	sbcs	r0, r3
700a3310: 910d         	str	r1, [sp, #0x34]
700a3312: 900e         	str	r0, [sp, #0x38]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a3314: 990d         	ldr	r1, [sp, #0x34]
700a3316: 980e         	ldr	r0, [sp, #0x38]
700a3318: 310a         	adds	r1, #0xa
700a331a: f140 0000    	adc	r0, r0, #0x0
700a331e: 9111         	str	r1, [sp, #0x44]
700a3320: 9012         	str	r0, [sp, #0x48]
;     }
700a3322: e7ff         	b	0x700a3324 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a3324: 9818         	ldr	r0, [sp, #0x60]
700a3326: 28ff         	cmp	r0, #0xff
700a3328: d307         	blo	0x700a333a <Sciclient_pmSetModuleClkFreq+0xba> @ imm = #0xe
700a332a: e7ff         	b	0x700a332c <Sciclient_pmSetModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a332c: 9818         	ldr	r0, [sp, #0x60]
700a332e: f8cd 004d    	str.w	r0, [sp, #0x4d]
700a3332: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a3334: f88d 004c    	strb.w	r0, [sp, #0x4c]
;     }
700a3338: e003         	b	0x700a3342 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a333a: 9818         	ldr	r0, [sp, #0x60]
700a333c: f88d 004c    	strb.w	r0, [sp, #0x4c]
700a3340: e7ff         	b	0x700a3342 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #-0x2
700a3342: f44f 7086    	mov.w	r0, #0x10c
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_FREQ;
700a3346: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     reqParam.flags          = (uint32_t)(TISCI_MSG_FLAG_AOP | additionalFlag);
700a334a: 981c         	ldr	r0, [sp, #0x70]
700a334c: f040 0002    	orr	r0, r0, #0x2
700a3350: 9006         	str	r0, [sp, #0x18]
700a3352: a80a         	add	r0, sp, #0x28
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a3354: 9007         	str	r0, [sp, #0x1c]
700a3356: 2029         	movs	r0, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a3358: 9008         	str	r0, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a335a: 981d         	ldr	r0, [sp, #0x74]
700a335c: 9009         	str	r0, [sp, #0x24]
700a335e: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a3360: 9002         	str	r0, [sp, #0x8]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a3362: 9003         	str	r0, [sp, #0xc]
;     respParam.respPayloadSize = (uint32_t) 0;
700a3364: 9004         	str	r0, [sp, #0x10]
700a3366: a805         	add	r0, sp, #0x14
700a3368: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a336a: f7f8 fd89    	bl	0x7009be80 <Sciclient_service> @ imm = #-0x74ee
700a336e: 9015         	str	r0, [sp, #0x54]
;     if((retVal != SystemP_SUCCESS) ||
700a3370: 9815         	ldr	r0, [sp, #0x54]
700a3372: b930         	cbnz	r0, 0x700a3382 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #0xc
700a3374: e7ff         	b	0x700a3376 <Sciclient_pmSetModuleClkFreq+0xf6> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a3376: 9802         	ldr	r0, [sp, #0x8]
700a3378: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a337c: 2802         	cmp	r0, #0x2
700a337e: d004         	beq	0x700a338a <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #0x8
700a3380: e7ff         	b	0x700a3382 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #-0x2
700a3382: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a3386: 9015         	str	r0, [sp, #0x54]
;     }
700a3388: e7ff         	b	0x700a338a <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #-0x2
;     return retVal;
700a338a: 9815         	ldr	r0, [sp, #0x54]
700a338c: b01a         	add	sp, #0x68
700a338e: bd80         	pop	{r7, pc}

700a3390 <vTaskDelete>:
; void vTaskDelete(TaskHandle_t xTaskToDelete) {
700a3390: b580         	push	{r7, lr}
700a3392: b084         	sub	sp, #0x10
700a3394: 9003         	str	r0, [sp, #0xc]
;   taskENTER_CRITICAL();
700a3396: f009 f8fb    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x91f6
;     pxTCB = prvGetTCBFromHandle(xTaskToDelete);
700a339a: 9803         	ldr	r0, [sp, #0xc]
700a339c: b938         	cbnz	r0, 0x700a33ae <vTaskDelete+0x1e> @ imm = #0xe
700a339e: e7ff         	b	0x700a33a0 <vTaskDelete+0x10> @ imm = #-0x2
700a33a0: f240 40dc    	movw	r0, #0x4dc
700a33a4: f2c7 000b    	movt	r0, #0x700b
700a33a8: 6800         	ldr	r0, [r0]
700a33aa: 9001         	str	r0, [sp, #0x4]
700a33ac: e002         	b	0x700a33b4 <vTaskDelete+0x24> @ imm = #0x4
700a33ae: 9803         	ldr	r0, [sp, #0xc]
700a33b0: 9001         	str	r0, [sp, #0x4]
700a33b2: e7ff         	b	0x700a33b4 <vTaskDelete+0x24> @ imm = #-0x2
700a33b4: 9801         	ldr	r0, [sp, #0x4]
700a33b6: 9002         	str	r0, [sp, #0x8]
;     if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a33b8: 9802         	ldr	r0, [sp, #0x8]
700a33ba: 3004         	adds	r0, #0x4
700a33bc: f008 f8b8    	bl	0x700ab530 <uxListRemove> @ imm = #0x8170
700a33c0: b9d0         	cbnz	r0, 0x700a33f8 <vTaskDelete+0x68> @ imm = #0x34
700a33c2: e7ff         	b	0x700a33c4 <vTaskDelete+0x34> @ imm = #-0x2
;       taskRESET_READY_PRIORITY(pxTCB->uxPriority);
700a33c4: 9802         	ldr	r0, [sp, #0x8]
700a33c6: 6ac0         	ldr	r0, [r0, #0x2c]
700a33c8: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a33cc: f244 40f8    	movw	r0, #0x44f8
700a33d0: f2c7 0008    	movt	r0, #0x7008
700a33d4: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a33d8: b968         	cbnz	r0, 0x700a33f6 <vTaskDelete+0x66> @ imm = #0x1a
700a33da: e7ff         	b	0x700a33dc <vTaskDelete+0x4c> @ imm = #-0x2
700a33dc: 9802         	ldr	r0, [sp, #0x8]
700a33de: 6ac1         	ldr	r1, [r0, #0x2c]
700a33e0: 2001         	movs	r0, #0x1
700a33e2: fa00 f201    	lsl.w	r2, r0, r1
700a33e6: f240 5108    	movw	r1, #0x508
700a33ea: f2c7 010b    	movt	r1, #0x700b
700a33ee: 6808         	ldr	r0, [r1]
700a33f0: 4390         	bics	r0, r2
700a33f2: 6008         	str	r0, [r1]
700a33f4: e7ff         	b	0x700a33f6 <vTaskDelete+0x66> @ imm = #-0x2
;     } else {
700a33f6: e000         	b	0x700a33fa <vTaskDelete+0x6a> @ imm = #0x0
700a33f8: e7ff         	b	0x700a33fa <vTaskDelete+0x6a> @ imm = #-0x2
;     if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a33fa: 9802         	ldr	r0, [sp, #0x8]
700a33fc: 6a80         	ldr	r0, [r0, #0x28]
700a33fe: b128         	cbz	r0, 0x700a340c <vTaskDelete+0x7c> @ imm = #0xa
700a3400: e7ff         	b	0x700a3402 <vTaskDelete+0x72> @ imm = #-0x2
;       (void)uxListRemove(&(pxTCB->xEventListItem));
700a3402: 9802         	ldr	r0, [sp, #0x8]
700a3404: 3018         	adds	r0, #0x18
700a3406: f008 f893    	bl	0x700ab530 <uxListRemove> @ imm = #0x8126
;     } else {
700a340a: e000         	b	0x700a340e <vTaskDelete+0x7e> @ imm = #0x0
700a340c: e7ff         	b	0x700a340e <vTaskDelete+0x7e> @ imm = #-0x2
;     uxTaskNumber++;
700a340e: f240 5104    	movw	r1, #0x504
700a3412: f2c7 010b    	movt	r1, #0x700b
700a3416: 6808         	ldr	r0, [r1]
700a3418: 3001         	adds	r0, #0x1
700a341a: 6008         	str	r0, [r1]
;     if (pxTCB == pxCurrentTCB) {
700a341c: 9802         	ldr	r0, [sp, #0x8]
700a341e: f240 41dc    	movw	r1, #0x4dc
700a3422: f2c7 010b    	movt	r1, #0x700b
700a3426: 6809         	ldr	r1, [r1]
700a3428: 4288         	cmp	r0, r1
700a342a: d110         	bne	0x700a344e <vTaskDelete+0xbe> @ imm = #0x20
700a342c: e7ff         	b	0x700a342e <vTaskDelete+0x9e> @ imm = #-0x2
;       vListInsertEnd(&xTasksWaitingTermination, &(pxTCB->xStateListItem));
700a342e: 9802         	ldr	r0, [sp, #0x8]
700a3430: 1d01         	adds	r1, r0, #0x4
700a3432: f644 7090    	movw	r0, #0x4f90
700a3436: f2c7 0008    	movt	r0, #0x7008
700a343a: f008 fe31    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #0x8c62
;       ++uxDeletedTasksWaitingCleanUp;
700a343e: f240 41fc    	movw	r1, #0x4fc
700a3442: f2c7 010b    	movt	r1, #0x700b
700a3446: 6808         	ldr	r0, [r1]
700a3448: 3001         	adds	r0, #0x1
700a344a: 6008         	str	r0, [r1]
;     } else {
700a344c: e00c         	b	0x700a3468 <vTaskDelete+0xd8> @ imm = #0x18
;       --uxCurrentNumberOfTasks;
700a344e: f240 41f8    	movw	r1, #0x4f8
700a3452: f2c7 010b    	movt	r1, #0x700b
700a3456: 6808         	ldr	r0, [r1]
700a3458: 3801         	subs	r0, #0x1
700a345a: 6008         	str	r0, [r1]
;       prvDeleteTCB(pxTCB);
700a345c: 9802         	ldr	r0, [sp, #0x8]
700a345e: f008 fd9f    	bl	0x700abfa0 <prvDeleteTCB> @ imm = #0x8b3e
;       prvResetNextTaskUnblockTime();
700a3462: f008 fdbd    	bl	0x700abfe0 <prvResetNextTaskUnblockTime> @ imm = #0x8b7a
700a3466: e7ff         	b	0x700a3468 <vTaskDelete+0xd8> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a3468: f008 f952    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x82a4
;   if (xSchedulerRunning != pdFALSE) {
700a346c: f240 501c    	movw	r0, #0x51c
700a3470: f2c7 000b    	movt	r0, #0x700b
700a3474: 6800         	ldr	r0, [r0]
700a3476: b168         	cbz	r0, 0x700a3494 <vTaskDelete+0x104> @ imm = #0x1a
700a3478: e7ff         	b	0x700a347a <vTaskDelete+0xea> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a347a: 9802         	ldr	r0, [sp, #0x8]
700a347c: f240 41dc    	movw	r1, #0x4dc
700a3480: f2c7 010b    	movt	r1, #0x700b
700a3484: 6809         	ldr	r1, [r1]
700a3486: 4288         	cmp	r0, r1
700a3488: d102         	bne	0x700a3490 <vTaskDelete+0x100> @ imm = #0x4
700a348a: e7ff         	b	0x700a348c <vTaskDelete+0xfc> @ imm = #-0x2
;       portYIELD_WITHIN_API();
700a348c: df00         	svc	#0x0
;     } else {
700a348e: e000         	b	0x700a3492 <vTaskDelete+0x102> @ imm = #0x0
700a3490: e7ff         	b	0x700a3492 <vTaskDelete+0x102> @ imm = #-0x2
;   }
700a3492: e7ff         	b	0x700a3494 <vTaskDelete+0x104> @ imm = #-0x2
; }
700a3494: b004         	add	sp, #0x10
700a3496: bd80         	pop	{r7, pc}
		...

700a34a0 <Udma_eventCheckParams>:
; {
700a34a0: b084         	sub	sp, #0x10
700a34a2: 9003         	str	r0, [sp, #0xc]
700a34a4: 9102         	str	r1, [sp, #0x8]
700a34a6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a34a8: 9001         	str	r0, [sp, #0x4]
;     if(UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode)
700a34aa: 9802         	ldr	r0, [sp, #0x8]
700a34ac: 6840         	ldr	r0, [r0, #0x4]
700a34ae: 2801         	cmp	r0, #0x1
700a34b0: d109         	bne	0x700a34c6 <Udma_eventCheckParams+0x26> @ imm = #0x12
700a34b2: e7ff         	b	0x700a34b4 <Udma_eventCheckParams+0x14> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a34b4: 9802         	ldr	r0, [sp, #0x8]
700a34b6: 6900         	ldr	r0, [r0, #0x10]
700a34b8: b120         	cbz	r0, 0x700a34c4 <Udma_eventCheckParams+0x24> @ imm = #0x8
700a34ba: e7ff         	b	0x700a34bc <Udma_eventCheckParams+0x1c> @ imm = #-0x2
700a34bc: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a34c0: 9001         	str	r0, [sp, #0x4]
;         }
700a34c2: e7ff         	b	0x700a34c4 <Udma_eventCheckParams+0x24> @ imm = #-0x2
;     }
700a34c4: e7ff         	b	0x700a34c6 <Udma_eventCheckParams+0x26> @ imm = #-0x2
;     if(UDMA_EVENT_MODE_SHARED == eventPrms->eventMode)
700a34c6: 9802         	ldr	r0, [sp, #0x8]
700a34c8: 6840         	ldr	r0, [r0, #0x4]
700a34ca: 2802         	cmp	r0, #0x2
700a34cc: d126         	bne	0x700a351c <Udma_eventCheckParams+0x7c> @ imm = #0x4c
700a34ce: e7ff         	b	0x700a34d0 <Udma_eventCheckParams+0x30> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a34d0: 9802         	ldr	r0, [sp, #0x8]
700a34d2: 6900         	ldr	r0, [r0, #0x10]
700a34d4: b308         	cbz	r0, 0x700a351a <Udma_eventCheckParams+0x7a> @ imm = #0x42
700a34d6: e7ff         	b	0x700a34d8 <Udma_eventCheckParams+0x38> @ imm = #-0x2
;             controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a34d8: 9802         	ldr	r0, [sp, #0x8]
700a34da: 6900         	ldr	r0, [r0, #0x10]
700a34dc: 9000         	str	r0, [sp]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a34de: 9800         	ldr	r0, [sp]
700a34e0: 69c0         	ldr	r0, [r0, #0x1c]
700a34e2: b140         	cbz	r0, 0x700a34f6 <Udma_eventCheckParams+0x56> @ imm = #0x10
700a34e4: e7ff         	b	0x700a34e6 <Udma_eventCheckParams+0x46> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR == eventPrms->eventCb))
700a34e6: 9802         	ldr	r0, [sp, #0x8]
700a34e8: 6940         	ldr	r0, [r0, #0x14]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a34ea: b920         	cbnz	r0, 0x700a34f6 <Udma_eventCheckParams+0x56> @ imm = #0x8
700a34ec: e7ff         	b	0x700a34ee <Udma_eventCheckParams+0x4e> @ imm = #-0x2
700a34ee: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a34f2: 9001         	str	r0, [sp, #0x4]
;             }
700a34f4: e7ff         	b	0x700a34f6 <Udma_eventCheckParams+0x56> @ imm = #-0x2
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a34f6: 9800         	ldr	r0, [sp]
700a34f8: 69c0         	ldr	r0, [r0, #0x1c]
700a34fa: b968         	cbnz	r0, 0x700a3518 <Udma_eventCheckParams+0x78> @ imm = #0x1a
700a34fc: e7ff         	b	0x700a34fe <Udma_eventCheckParams+0x5e> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
700a34fe: 9802         	ldr	r0, [sp, #0x8]
700a3500: 6940         	ldr	r0, [r0, #0x14]
700a3502: b148         	cbz	r0, 0x700a3518 <Udma_eventCheckParams+0x78> @ imm = #0x12
700a3504: e7ff         	b	0x700a3506 <Udma_eventCheckParams+0x66> @ imm = #-0x2
;                (UDMA_EVENT_TYPE_MASTER != controllerEventHandle->eventPrms.eventType))
700a3506: 9800         	ldr	r0, [sp]
700a3508: 6880         	ldr	r0, [r0, #0x8]
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a350a: 2805         	cmp	r0, #0x5
700a350c: d004         	beq	0x700a3518 <Udma_eventCheckParams+0x78> @ imm = #0x8
700a350e: e7ff         	b	0x700a3510 <Udma_eventCheckParams+0x70> @ imm = #-0x2
700a3510: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a3514: 9001         	str	r0, [sp, #0x4]
;             }
700a3516: e7ff         	b	0x700a3518 <Udma_eventCheckParams+0x78> @ imm = #-0x2
;         }
700a3518: e7ff         	b	0x700a351a <Udma_eventCheckParams+0x7a> @ imm = #-0x2
;     }
700a351a: e7ff         	b	0x700a351c <Udma_eventCheckParams+0x7c> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a351c: 9802         	ldr	r0, [sp, #0x8]
700a351e: 6800         	ldr	r0, [r0]
700a3520: 2801         	cmp	r0, #0x1
700a3522: d00f         	beq	0x700a3544 <Udma_eventCheckParams+0xa4> @ imm = #0x1e
700a3524: e7ff         	b	0x700a3526 <Udma_eventCheckParams+0x86> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a3526: 9802         	ldr	r0, [sp, #0x8]
700a3528: 6800         	ldr	r0, [r0]
700a352a: 2806         	cmp	r0, #0x6
700a352c: d00a         	beq	0x700a3544 <Udma_eventCheckParams+0xa4> @ imm = #0x14
700a352e: e7ff         	b	0x700a3530 <Udma_eventCheckParams+0x90> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
700a3530: 9802         	ldr	r0, [sp, #0x8]
700a3532: 6800         	ldr	r0, [r0]
700a3534: 2802         	cmp	r0, #0x2
700a3536: d005         	beq	0x700a3544 <Udma_eventCheckParams+0xa4> @ imm = #0xa
700a3538: e7ff         	b	0x700a353a <Udma_eventCheckParams+0x9a> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TR == eventPrms->eventType))
700a353a: 9802         	ldr	r0, [sp, #0x8]
700a353c: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a353e: 2803         	cmp	r0, #0x3
700a3540: d109         	bne	0x700a3556 <Udma_eventCheckParams+0xb6> @ imm = #0x12
700a3542: e7ff         	b	0x700a3544 <Udma_eventCheckParams+0xa4> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->chHandle)
700a3544: 9802         	ldr	r0, [sp, #0x8]
700a3546: 6880         	ldr	r0, [r0, #0x8]
700a3548: b920         	cbnz	r0, 0x700a3554 <Udma_eventCheckParams+0xb4> @ imm = #0x8
700a354a: e7ff         	b	0x700a354c <Udma_eventCheckParams+0xac> @ imm = #-0x2
700a354c: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a3550: 9001         	str	r0, [sp, #0x4]
;         }
700a3552: e7ff         	b	0x700a3554 <Udma_eventCheckParams+0xb4> @ imm = #-0x2
;     }
700a3554: e7ff         	b	0x700a3556 <Udma_eventCheckParams+0xb6> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
700a3556: 9802         	ldr	r0, [sp, #0x8]
700a3558: 6800         	ldr	r0, [r0]
700a355a: 2804         	cmp	r0, #0x4
700a355c: d109         	bne	0x700a3572 <Udma_eventCheckParams+0xd2> @ imm = #0x12
700a355e: e7ff         	b	0x700a3560 <Udma_eventCheckParams+0xc0> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->ringHandle)
700a3560: 9802         	ldr	r0, [sp, #0x8]
700a3562: 68c0         	ldr	r0, [r0, #0xc]
700a3564: b920         	cbnz	r0, 0x700a3570 <Udma_eventCheckParams+0xd0> @ imm = #0x8
700a3566: e7ff         	b	0x700a3568 <Udma_eventCheckParams+0xc8> @ imm = #-0x2
700a3568: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a356c: 9001         	str	r0, [sp, #0x4]
;         }
700a356e: e7ff         	b	0x700a3570 <Udma_eventCheckParams+0xd0> @ imm = #-0x2
;     }
700a3570: e7ff         	b	0x700a3572 <Udma_eventCheckParams+0xd2> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_MASTER == eventPrms->eventType)
700a3572: 9802         	ldr	r0, [sp, #0x8]
700a3574: 6800         	ldr	r0, [r0]
700a3576: 2805         	cmp	r0, #0x5
700a3578: d112         	bne	0x700a35a0 <Udma_eventCheckParams+0x100> @ imm = #0x24
700a357a: e7ff         	b	0x700a357c <Udma_eventCheckParams+0xdc> @ imm = #-0x2
;         if(UDMA_EVENT_MODE_SHARED != eventPrms->eventMode)
700a357c: 9802         	ldr	r0, [sp, #0x8]
700a357e: 6840         	ldr	r0, [r0, #0x4]
700a3580: 2802         	cmp	r0, #0x2
700a3582: d004         	beq	0x700a358e <Udma_eventCheckParams+0xee> @ imm = #0x8
700a3584: e7ff         	b	0x700a3586 <Udma_eventCheckParams+0xe6> @ imm = #-0x2
700a3586: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a358a: 9001         	str	r0, [sp, #0x4]
;         }
700a358c: e7ff         	b	0x700a358e <Udma_eventCheckParams+0xee> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a358e: 9802         	ldr	r0, [sp, #0x8]
700a3590: 6900         	ldr	r0, [r0, #0x10]
700a3592: b120         	cbz	r0, 0x700a359e <Udma_eventCheckParams+0xfe> @ imm = #0x8
700a3594: e7ff         	b	0x700a3596 <Udma_eventCheckParams+0xf6> @ imm = #-0x2
700a3596: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a359a: 9001         	str	r0, [sp, #0x4]
;         }
700a359c: e7ff         	b	0x700a359e <Udma_eventCheckParams+0xfe> @ imm = #-0x2
;     }
700a359e: e7ff         	b	0x700a35a0 <Udma_eventCheckParams+0x100> @ imm = #-0x2
;     return (retVal);
700a35a0: 9801         	ldr	r0, [sp, #0x4]
700a35a2: b004         	add	sp, #0x10
700a35a4: 4770         	bx	lr
		...
700a35ae: 0000         	movs	r0, r0

700a35b0 <CSL_pktdmaTeardownChan>:
; {
700a35b0: b580         	push	{r7, lr}
700a35b2: b088         	sub	sp, #0x20
700a35b4: 4684         	mov	r12, r0
700a35b6: 980a         	ldr	r0, [sp, #0x28]
700a35b8: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a35bc: 9106         	str	r1, [sp, #0x18]
700a35be: 9205         	str	r2, [sp, #0x14]
700a35c0: f88d 3013    	strb.w	r3, [sp, #0x13]
700a35c4: f88d 0012    	strb.w	r0, [sp, #0x12]
700a35c8: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
700a35ca: 9003         	str	r0, [sp, #0xc]
;     if( (pCfg == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a35cc: 9807         	ldr	r0, [sp, #0x1c]
700a35ce: b138         	cbz	r0, 0x700a35e0 <CSL_pktdmaTeardownChan+0x30> @ imm = #0xe
700a35d0: e7ff         	b	0x700a35d2 <CSL_pktdmaTeardownChan+0x22> @ imm = #-0x2
700a35d2: 9807         	ldr	r0, [sp, #0x1c]
700a35d4: 9906         	ldr	r1, [sp, #0x18]
700a35d6: 9a05         	ldr	r2, [sp, #0x14]
700a35d8: f007 fafa    	bl	0x700aabd0 <CSL_pktdmaIsValidChanIdx> @ imm = #0x75f4
700a35dc: b920         	cbnz	r0, 0x700a35e8 <CSL_pktdmaTeardownChan+0x38> @ imm = #0x8
700a35de: e7ff         	b	0x700a35e0 <CSL_pktdmaTeardownChan+0x30> @ imm = #-0x2
700a35e0: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a35e4: 9003         	str	r0, [sp, #0xc]
;     }
700a35e6: e062         	b	0x700a36ae <CSL_pktdmaTeardownChan+0xfe> @ imm = #0xc4
;         if( CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true )
700a35e8: 9807         	ldr	r0, [sp, #0x1c]
700a35ea: 9906         	ldr	r1, [sp, #0x18]
700a35ec: 9a05         	ldr	r2, [sp, #0x14]
700a35ee: f007 fd47    	bl	0x700ab080 <CSL_pktdmaIsChanEnabled> @ imm = #0x7a8e
700a35f2: 2800         	cmp	r0, #0x0
700a35f4: d056         	beq	0x700a36a4 <CSL_pktdmaTeardownChan+0xf4> @ imm = #0xac
700a35f6: e7ff         	b	0x700a35f8 <CSL_pktdmaTeardownChan+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a35f8: 9805         	ldr	r0, [sp, #0x14]
700a35fa: b9a8         	cbnz	r0, 0x700a3628 <CSL_pktdmaTeardownChan+0x78> @ imm = #0x2a
700a35fc: e7ff         	b	0x700a35fe <CSL_pktdmaTeardownChan+0x4e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a35fe: 9807         	ldr	r0, [sp, #0x1c]
700a3600: 6900         	ldr	r0, [r0, #0x10]
700a3602: 9906         	ldr	r1, [sp, #0x18]
700a3604: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3608: f00a f9b2    	bl	0x700ad970 <CSL_REG32_RD_RAW> @ imm = #0xa364
700a360c: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a360e: 9802         	ldr	r0, [sp, #0x8]
700a3610: f040 4080    	orr	r0, r0, #0x40000000
700a3614: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a3616: 9807         	ldr	r0, [sp, #0x1c]
700a3618: 6900         	ldr	r0, [r0, #0x10]
700a361a: 9906         	ldr	r1, [sp, #0x18]
700a361c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3620: 9902         	ldr	r1, [sp, #0x8]
700a3622: f00a f8fd    	bl	0x700ad820 <CSL_REG32_WR_RAW> @ imm = #0xa1fa
;             }
700a3626: e014         	b	0x700a3652 <CSL_pktdmaTeardownChan+0xa2> @ imm = #0x28
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a3628: 9807         	ldr	r0, [sp, #0x1c]
700a362a: 6940         	ldr	r0, [r0, #0x14]
700a362c: 9906         	ldr	r1, [sp, #0x18]
700a362e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3632: f00a f99d    	bl	0x700ad970 <CSL_REG32_RD_RAW> @ imm = #0xa33a
700a3636: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a3638: 9802         	ldr	r0, [sp, #0x8]
700a363a: f040 4080    	orr	r0, r0, #0x40000000
700a363e: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a3640: 9807         	ldr	r0, [sp, #0x1c]
700a3642: 6940         	ldr	r0, [r0, #0x14]
700a3644: 9906         	ldr	r1, [sp, #0x18]
700a3646: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a364a: 9902         	ldr	r1, [sp, #0x8]
700a364c: f00a f8e8    	bl	0x700ad820 <CSL_REG32_WR_RAW> @ imm = #0xa1d0
700a3650: e7ff         	b	0x700a3652 <CSL_pktdmaTeardownChan+0xa2> @ imm = #-0x2
;             if( bWait == (bool)true )
700a3652: f89d 0012    	ldrb.w	r0, [sp, #0x12]
700a3656: 07c0         	lsls	r0, r0, #0x1f
700a3658: b318         	cbz	r0, 0x700a36a2 <CSL_pktdmaTeardownChan+0xf2> @ imm = #0x46
700a365a: e7ff         	b	0x700a365c <CSL_pktdmaTeardownChan+0xac> @ imm = #-0x2
700a365c: 2080         	movs	r0, #0x80
;                 uint32_t retryCnt = CSL_PKTDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
700a365e: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a3660: e7ff         	b	0x700a3662 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x2
700a3662: 9807         	ldr	r0, [sp, #0x1c]
700a3664: 9906         	ldr	r1, [sp, #0x18]
700a3666: 9a05         	ldr	r2, [sp, #0x14]
700a3668: f007 fd0a    	bl	0x700ab080 <CSL_pktdmaIsChanEnabled> @ imm = #0x7a14
700a366c: 4601         	mov	r1, r0
700a366e: 2000         	movs	r0, #0x0
700a3670: 9000         	str	r0, [sp]
700a3672: b131         	cbz	r1, 0x700a3682 <CSL_pktdmaTeardownChan+0xd2> @ imm = #0xc
700a3674: e7ff         	b	0x700a3676 <CSL_pktdmaTeardownChan+0xc6> @ imm = #-0x2
700a3676: 9801         	ldr	r0, [sp, #0x4]
700a3678: 2800         	cmp	r0, #0x0
700a367a: bf18         	it	ne
700a367c: 2001         	movne	r0, #0x1
700a367e: 9000         	str	r0, [sp]
700a3680: e7ff         	b	0x700a3682 <CSL_pktdmaTeardownChan+0xd2> @ imm = #-0x2
700a3682: 9800         	ldr	r0, [sp]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a3684: 07c0         	lsls	r0, r0, #0x1f
700a3686: b120         	cbz	r0, 0x700a3692 <CSL_pktdmaTeardownChan+0xe2> @ imm = #0x8
700a3688: e7ff         	b	0x700a368a <CSL_pktdmaTeardownChan+0xda> @ imm = #-0x2
;                     retryCnt--;
700a368a: 9801         	ldr	r0, [sp, #0x4]
700a368c: 3801         	subs	r0, #0x1
700a368e: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a3690: e7e7         	b	0x700a3662 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x32
;                 if( retryCnt == (uint32_t)0U ) {
700a3692: 9801         	ldr	r0, [sp, #0x4]
700a3694: b920         	cbnz	r0, 0x700a36a0 <CSL_pktdmaTeardownChan+0xf0> @ imm = #0x8
700a3696: e7ff         	b	0x700a3698 <CSL_pktdmaTeardownChan+0xe8> @ imm = #-0x2
700a3698: f04f 30ff    	mov.w	r0, #0xffffffff
;                     retVal = CSL_EFAIL;
700a369c: 9003         	str	r0, [sp, #0xc]
;                 }
700a369e: e7ff         	b	0x700a36a0 <CSL_pktdmaTeardownChan+0xf0> @ imm = #-0x2
;             }
700a36a0: e7ff         	b	0x700a36a2 <CSL_pktdmaTeardownChan+0xf2> @ imm = #-0x2
;         }
700a36a2: e003         	b	0x700a36ac <CSL_pktdmaTeardownChan+0xfc> @ imm = #0x6
700a36a4: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a36a8: 9003         	str	r0, [sp, #0xc]
700a36aa: e7ff         	b	0x700a36ac <CSL_pktdmaTeardownChan+0xfc> @ imm = #-0x2
700a36ac: e7ff         	b	0x700a36ae <CSL_pktdmaTeardownChan+0xfe> @ imm = #-0x2
;     return retVal;
700a36ae: 9803         	ldr	r0, [sp, #0xc]
700a36b0: b008         	add	sp, #0x20
700a36b2: bd80         	pop	{r7, pc}
		...

700a36c0 <UART_configInstance>:
; {
700a36c0: b580         	push	{r7, lr}
700a36c2: b088         	sub	sp, #0x20
700a36c4: 9007         	str	r0, [sp, #0x1c]
;     baseAddr = hUart->baseAddr;
700a36c6: 9807         	ldr	r0, [sp, #0x1c]
700a36c8: 6800         	ldr	r0, [r0]
700a36ca: 9006         	str	r0, [sp, #0x18]
;     hUartInit = hUart->hUartInit;
700a36cc: 9807         	ldr	r0, [sp, #0x1c]
700a36ce: 6840         	ldr	r0, [r0, #0x4]
700a36d0: 9001         	str	r0, [sp, #0x4]
;     UART_resetModule(hUart);
700a36d2: 9807         	ldr	r0, [sp, #0x1c]
700a36d4: f007 fedc    	bl	0x700ab490 <UART_resetModule> @ imm = #0x7db8
;     if(UART_CONFIG_MODE_DMA == hUartInit->transferMode)
700a36d8: 9801         	ldr	r0, [sp, #0x4]
700a36da: 6a00         	ldr	r0, [r0, #0x20]
700a36dc: 2803         	cmp	r0, #0x3
700a36de: d10e         	bne	0x700a36fe <UART_configInstance+0x3e> @ imm = #0x1c
700a36e0: e7ff         	b	0x700a36e2 <UART_configInstance+0x22> @ imm = #-0x2
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a36e2: 9801         	ldr	r0, [sp, #0x4]
700a36e4: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a36e8: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a36ec: 0380         	lsls	r0, r0, #0xe
700a36ee: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a36f2: 2131         	movs	r1, #0x31
700a36f4: f2c0 4140    	movt	r1, #0x440
700a36f8: 4308         	orrs	r0, r1
700a36fa: 9005         	str	r0, [sp, #0x14]
;     }
700a36fc: e00d         	b	0x700a371a <UART_configInstance+0x5a> @ imm = #0x1a
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a36fe: 9801         	ldr	r0, [sp, #0x4]
700a3700: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a3704: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a3708: 0380         	lsls	r0, r0, #0xe
700a370a: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a370e: 2130         	movs	r1, #0x30
700a3710: f2c0 4140    	movt	r1, #0x440
700a3714: 4308         	orrs	r0, r1
700a3716: 9005         	str	r0, [sp, #0x14]
700a3718: e7ff         	b	0x700a371a <UART_configInstance+0x5a> @ imm = #-0x2
;     (void)UART_fifoConfig(baseAddr, regVal);
700a371a: 9806         	ldr	r0, [sp, #0x18]
700a371c: 9905         	ldr	r1, [sp, #0x14]
700a371e: f7f9 fb67    	bl	0x7009cdf0 <UART_fifoConfig> @ imm = #-0x6932
;     UART_timeGuardConfig(baseAddr, hUartInit->timeGuardVal);
700a3722: 9806         	ldr	r0, [sp, #0x18]
700a3724: 9901         	ldr	r1, [sp, #0x4]
700a3726: 6d09         	ldr	r1, [r1, #0x50]
700a3728: f009 fe4a    	bl	0x700ad3c0 <UART_timeGuardConfig> @ imm = #0x9c94
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a372c: 9a01         	ldr	r2, [sp, #0x4]
700a372e: 6810         	ldr	r0, [r2]
;                                     hUartInit->baudRate,
700a3730: 6851         	ldr	r1, [r2, #0x4]
;                                     hUartInit->operMode,
700a3732: 6ad2         	ldr	r2, [r2, #0x2c]
700a3734: 232a         	movs	r3, #0x2a
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a3736: f006 f903    	bl	0x700a9940 <UART_divisorValCompute> @ imm = #0x6206
700a373a: 9004         	str	r0, [sp, #0x10]
;     (void)UART_divisorLatchWrite(baseAddr, divisorVal);
700a373c: 9806         	ldr	r0, [sp, #0x18]
700a373e: 9904         	ldr	r1, [sp, #0x10]
700a3740: f7ff fc7e    	bl	0x700a3040 <UART_divisorLatchWrite> @ imm = #-0x704
;     (void)UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a3744: 9806         	ldr	r0, [sp, #0x18]
700a3746: 21bf         	movs	r1, #0xbf
700a3748: f006 ffa2    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x6f44
;     wLenStbFlag = (hUartInit->dataLength << UART_LCR_CHAR_LENGTH_SHIFT);
700a374c: 9801         	ldr	r0, [sp, #0x4]
700a374e: 6880         	ldr	r0, [r0, #0x8]
700a3750: 9003         	str	r0, [sp, #0xc]
;     wLenStbFlag |= (hUartInit->stopBits << UART_LCR_NB_STOP_SHIFT);
700a3752: 9801         	ldr	r0, [sp, #0x4]
700a3754: 68c1         	ldr	r1, [r0, #0xc]
700a3756: 9803         	ldr	r0, [sp, #0xc]
700a3758: ea40 0081    	orr.w	r0, r0, r1, lsl #2
700a375c: 9003         	str	r0, [sp, #0xc]
;     parityFlag = (hUartInit->parityType << UART_LCR_PARITY_EN_SHIFT);
700a375e: 9801         	ldr	r0, [sp, #0x4]
700a3760: 6900         	ldr	r0, [r0, #0x10]
700a3762: 00c0         	lsls	r0, r0, #0x3
700a3764: 9002         	str	r0, [sp, #0x8]
;     UART_lineCharConfig(baseAddr, wLenStbFlag, parityFlag);
700a3766: 9806         	ldr	r0, [sp, #0x18]
700a3768: 9903         	ldr	r1, [sp, #0xc]
700a376a: 9a02         	ldr	r2, [sp, #0x8]
700a376c: f007 fe18    	bl	0x700ab3a0 <UART_lineCharConfig> @ imm = #0x7c30
;     UART_divisorLatchDisable(baseAddr);
700a3770: 9806         	ldr	r0, [sp, #0x18]
700a3772: f009 fe85    	bl	0x700ad480 <UART_divisorLatchDisable> @ imm = #0x9d0a
;     UART_breakCtl(baseAddr, UART_BREAK_COND_DISABLE);
700a3776: 9806         	ldr	r0, [sp, #0x18]
700a3778: 2100         	movs	r1, #0x0
700a377a: f009 fd41    	bl	0x700ad200 <UART_breakCtl> @ imm = #0x9a82
;     (void)UART_operatingModeSelect(baseAddr, hUartInit->operMode);
700a377e: 9806         	ldr	r0, [sp, #0x18]
700a3780: 9901         	ldr	r1, [sp, #0x4]
700a3782: 6ac9         	ldr	r1, [r1, #0x2c]
700a3784: f009 fa44    	bl	0x700acc10 <UART_operatingModeSelect> @ imm = #0x9488
;     if (hUartInit->hwFlowControl == (uint32_t)TRUE)
700a3788: 9801         	ldr	r0, [sp, #0x4]
700a378a: 6980         	ldr	r0, [r0, #0x18]
700a378c: 2801         	cmp	r0, #0x1
700a378e: d112         	bne	0x700a37b6 <UART_configInstance+0xf6> @ imm = #0x24
700a3790: e7ff         	b	0x700a3792 <UART_configInstance+0xd2> @ imm = #-0x2
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_RTS_CTS_ENABLE);
700a3792: 9806         	ldr	r0, [sp, #0x18]
700a3794: 2103         	movs	r1, #0x3
700a3796: f008 fedb    	bl	0x700ac550 <UART_hardwareFlowCtrlOptSet> @ imm = #0x8db6
;         if (hUartInit->hwFlowControlThr >= hUartInit->rxTrigLvl)
700a379a: 9901         	ldr	r1, [sp, #0x4]
700a379c: 69c8         	ldr	r0, [r1, #0x1c]
700a379e: 6b89         	ldr	r1, [r1, #0x38]
700a37a0: 4288         	cmp	r0, r1
700a37a2: d307         	blo	0x700a37b4 <UART_configInstance+0xf4> @ imm = #0xe
700a37a4: e7ff         	b	0x700a37a6 <UART_configInstance+0xe6> @ imm = #-0x2
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a37a6: 9806         	ldr	r0, [sp, #0x18]
;                                     hUartInit->hwFlowControlThr,
700a37a8: 9a01         	ldr	r2, [sp, #0x4]
700a37aa: 69d1         	ldr	r1, [r2, #0x1c]
;                                     hUartInit->rxTrigLvl);
700a37ac: 6b92         	ldr	r2, [r2, #0x38]
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a37ae: f008 ff5f    	bl	0x700ac670 <UART_flowCtrlTrigLvlConfig> @ imm = #0x8ebe
;         }
700a37b2: e7ff         	b	0x700a37b4 <UART_configInstance+0xf4> @ imm = #-0x2
;     }
700a37b4: e004         	b	0x700a37c0 <UART_configInstance+0x100> @ imm = #0x8
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_NO_HARDWARE_FLOW_CONTROL);
700a37b6: 9806         	ldr	r0, [sp, #0x18]
700a37b8: 2100         	movs	r1, #0x0
700a37ba: f008 fec9    	bl	0x700ac550 <UART_hardwareFlowCtrlOptSet> @ imm = #0x8d92
700a37be: e7ff         	b	0x700a37c0 <UART_configInstance+0x100> @ imm = #-0x2
;     return;
700a37c0: b008         	add	sp, #0x20
700a37c2: bd80         	pop	{r7, pc}
		...

700a37d0 <prvAddNewTaskToReadyList>:
; static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB) {
700a37d0: b580         	push	{r7, lr}
700a37d2: b082         	sub	sp, #0x8
700a37d4: 9001         	str	r0, [sp, #0x4]
;   taskENTER_CRITICAL();
700a37d6: f008 fedb    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x8db6
;     uxCurrentNumberOfTasks++;
700a37da: f240 41f8    	movw	r1, #0x4f8
700a37de: f2c7 010b    	movt	r1, #0x700b
700a37e2: 6808         	ldr	r0, [r1]
700a37e4: 3001         	adds	r0, #0x1
700a37e6: 6008         	str	r0, [r1]
;     if (pxCurrentTCB == NULL) {
700a37e8: f240 40dc    	movw	r0, #0x4dc
700a37ec: f2c7 000b    	movt	r0, #0x700b
700a37f0: 6800         	ldr	r0, [r0]
700a37f2: b998         	cbnz	r0, 0x700a381c <prvAddNewTaskToReadyList+0x4c> @ imm = #0x26
700a37f4: e7ff         	b	0x700a37f6 <prvAddNewTaskToReadyList+0x26> @ imm = #-0x2
;       pxCurrentTCB = pxNewTCB;
700a37f6: 9801         	ldr	r0, [sp, #0x4]
700a37f8: f240 41dc    	movw	r1, #0x4dc
700a37fc: f2c7 010b    	movt	r1, #0x700b
700a3800: 6008         	str	r0, [r1]
;       if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
700a3802: f240 40f8    	movw	r0, #0x4f8
700a3806: f2c7 000b    	movt	r0, #0x700b
700a380a: 6800         	ldr	r0, [r0]
700a380c: 2801         	cmp	r0, #0x1
700a380e: d103         	bne	0x700a3818 <prvAddNewTaskToReadyList+0x48> @ imm = #0x6
700a3810: e7ff         	b	0x700a3812 <prvAddNewTaskToReadyList+0x42> @ imm = #-0x2
;         prvInitialiseTaskLists();
700a3812: f004 faa5    	bl	0x700a7d60 <prvInitialiseTaskLists> @ imm = #0x454a
;       } else {
700a3816: e000         	b	0x700a381a <prvAddNewTaskToReadyList+0x4a> @ imm = #0x0
700a3818: e7ff         	b	0x700a381a <prvAddNewTaskToReadyList+0x4a> @ imm = #-0x2
;     } else {
700a381a: e01c         	b	0x700a3856 <prvAddNewTaskToReadyList+0x86> @ imm = #0x38
;       if (xSchedulerRunning == pdFALSE) {
700a381c: f240 501c    	movw	r0, #0x51c
700a3820: f2c7 000b    	movt	r0, #0x700b
700a3824: 6800         	ldr	r0, [r0]
700a3826: b9a0         	cbnz	r0, 0x700a3852 <prvAddNewTaskToReadyList+0x82> @ imm = #0x28
700a3828: e7ff         	b	0x700a382a <prvAddNewTaskToReadyList+0x5a> @ imm = #-0x2
;         if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
700a382a: f240 40dc    	movw	r0, #0x4dc
700a382e: f2c7 000b    	movt	r0, #0x700b
700a3832: 6800         	ldr	r0, [r0]
700a3834: 6ac0         	ldr	r0, [r0, #0x2c]
700a3836: 9901         	ldr	r1, [sp, #0x4]
700a3838: 6ac9         	ldr	r1, [r1, #0x2c]
700a383a: 4288         	cmp	r0, r1
700a383c: d807         	bhi	0x700a384e <prvAddNewTaskToReadyList+0x7e> @ imm = #0xe
700a383e: e7ff         	b	0x700a3840 <prvAddNewTaskToReadyList+0x70> @ imm = #-0x2
;           pxCurrentTCB = pxNewTCB;
700a3840: 9801         	ldr	r0, [sp, #0x4]
700a3842: f240 41dc    	movw	r1, #0x4dc
700a3846: f2c7 010b    	movt	r1, #0x700b
700a384a: 6008         	str	r0, [r1]
;         } else {
700a384c: e000         	b	0x700a3850 <prvAddNewTaskToReadyList+0x80> @ imm = #0x0
700a384e: e7ff         	b	0x700a3850 <prvAddNewTaskToReadyList+0x80> @ imm = #-0x2
;       } else {
700a3850: e000         	b	0x700a3854 <prvAddNewTaskToReadyList+0x84> @ imm = #0x0
700a3852: e7ff         	b	0x700a3854 <prvAddNewTaskToReadyList+0x84> @ imm = #-0x2
700a3854: e7ff         	b	0x700a3856 <prvAddNewTaskToReadyList+0x86> @ imm = #-0x2
;     uxTaskNumber++;
700a3856: f240 5004    	movw	r0, #0x504
700a385a: f2c7 000b    	movt	r0, #0x700b
700a385e: 6801         	ldr	r1, [r0]
700a3860: 3101         	adds	r1, #0x1
700a3862: 6001         	str	r1, [r0]
;       pxNewTCB->uxTCBNumber = uxTaskNumber;
700a3864: 6800         	ldr	r0, [r0]
700a3866: 9901         	ldr	r1, [sp, #0x4]
700a3868: 6588         	str	r0, [r1, #0x58]
;     prvAddTaskToReadyList(pxNewTCB);
700a386a: 9801         	ldr	r0, [sp, #0x4]
700a386c: 6ac1         	ldr	r1, [r0, #0x2c]
700a386e: 2001         	movs	r0, #0x1
700a3870: fa00 f201    	lsl.w	r2, r0, r1
700a3874: f240 5108    	movw	r1, #0x508
700a3878: f2c7 010b    	movt	r1, #0x700b
700a387c: 6808         	ldr	r0, [r1]
700a387e: 4310         	orrs	r0, r2
700a3880: 6008         	str	r0, [r1]
700a3882: 9901         	ldr	r1, [sp, #0x4]
700a3884: 6ac8         	ldr	r0, [r1, #0x2c]
700a3886: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a388a: f244 40f8    	movw	r0, #0x44f8
700a388e: f2c7 0008    	movt	r0, #0x7008
700a3892: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a3896: 3104         	adds	r1, #0x4
700a3898: f008 fc02    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #0x8804
;   taskEXIT_CRITICAL();
700a389c: f007 ff38    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x7e70
;   if (xSchedulerRunning != pdFALSE) {
700a38a0: f240 501c    	movw	r0, #0x51c
700a38a4: f2c7 000b    	movt	r0, #0x700b
700a38a8: 6800         	ldr	r0, [r0]
700a38aa: b178         	cbz	r0, 0x700a38cc <prvAddNewTaskToReadyList+0xfc> @ imm = #0x1e
700a38ac: e7ff         	b	0x700a38ae <prvAddNewTaskToReadyList+0xde> @ imm = #-0x2
;     if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
700a38ae: f240 40dc    	movw	r0, #0x4dc
700a38b2: f2c7 000b    	movt	r0, #0x700b
700a38b6: 6800         	ldr	r0, [r0]
700a38b8: 6ac0         	ldr	r0, [r0, #0x2c]
700a38ba: 9901         	ldr	r1, [sp, #0x4]
700a38bc: 6ac9         	ldr	r1, [r1, #0x2c]
700a38be: 4288         	cmp	r0, r1
700a38c0: d202         	bhs	0x700a38c8 <prvAddNewTaskToReadyList+0xf8> @ imm = #0x4
700a38c2: e7ff         	b	0x700a38c4 <prvAddNewTaskToReadyList+0xf4> @ imm = #-0x2
;       taskYIELD_IF_USING_PREEMPTION();
700a38c4: df00         	svc	#0x0
;     } else {
700a38c6: e000         	b	0x700a38ca <prvAddNewTaskToReadyList+0xfa> @ imm = #0x0
700a38c8: e7ff         	b	0x700a38ca <prvAddNewTaskToReadyList+0xfa> @ imm = #-0x2
;   } else {
700a38ca: e000         	b	0x700a38ce <prvAddNewTaskToReadyList+0xfe> @ imm = #0x0
700a38cc: e7ff         	b	0x700a38ce <prvAddNewTaskToReadyList+0xfe> @ imm = #-0x2
; }
700a38ce: b002         	add	sp, #0x8
700a38d0: bd80         	pop	{r7, pc}
		...
700a38de: 0000         	movs	r0, r0

700a38e0 <Sciclient_rmIrGetOutp>:
; {
700a38e0: b580         	push	{r7, lr}
700a38e2: b088         	sub	sp, #0x20
700a38e4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
700a38e8: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a38ec: 9206         	str	r2, [sp, #0x18]
700a38ee: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a38f0: 9005         	str	r0, [sp, #0x14]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a38f2: 9004         	str	r0, [sp, #0x10]
;     if (outp == NULL) {
700a38f4: 9806         	ldr	r0, [sp, #0x18]
700a38f6: b920         	cbnz	r0, 0x700a3902 <Sciclient_rmIrGetOutp+0x22> @ imm = #0x8
700a38f8: e7ff         	b	0x700a38fa <Sciclient_rmIrGetOutp+0x1a> @ imm = #-0x2
700a38fa: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a38fe: 9005         	str	r0, [sp, #0x14]
;     } else {
700a3900: e018         	b	0x700a3934 <Sciclient_rmIrGetOutp+0x54> @ imm = #0x30
;         inst = Sciclient_rmIrGetInst(id);
700a3902: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
700a3906: f006 f88b    	bl	0x700a9a20 <Sciclient_rmIrGetInst> @ imm = #0x6116
700a390a: 9004         	str	r0, [sp, #0x10]
;         if (inst == NULL) {
700a390c: 9804         	ldr	r0, [sp, #0x10]
700a390e: b920         	cbnz	r0, 0x700a391a <Sciclient_rmIrGetOutp+0x3a> @ imm = #0x8
700a3910: e7ff         	b	0x700a3912 <Sciclient_rmIrGetOutp+0x32> @ imm = #-0x2
700a3912: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a3916: 9005         	str	r0, [sp, #0x14]
;         } else {
700a3918: e00b         	b	0x700a3932 <Sciclient_rmIrGetOutp+0x52> @ imm = #0x16
;             if (inp >= inst->n_inp) {
700a391a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a391e: 9904         	ldr	r1, [sp, #0x10]
700a3920: 8909         	ldrh	r1, [r1, #0x8]
700a3922: 4288         	cmp	r0, r1
700a3924: db04         	blt	0x700a3930 <Sciclient_rmIrGetOutp+0x50> @ imm = #0x8
700a3926: e7ff         	b	0x700a3928 <Sciclient_rmIrGetOutp+0x48> @ imm = #-0x2
700a3928: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a392c: 9005         	str	r0, [sp, #0x14]
;             }
700a392e: e7ff         	b	0x700a3930 <Sciclient_rmIrGetOutp+0x50> @ imm = #-0x2
700a3930: e7ff         	b	0x700a3932 <Sciclient_rmIrGetOutp+0x52> @ imm = #-0x2
700a3932: e7ff         	b	0x700a3934 <Sciclient_rmIrGetOutp+0x54> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp == 0u)) {
700a3934: 9805         	ldr	r0, [sp, #0x14]
700a3936: b9a8         	cbnz	r0, 0x700a3964 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x2a
700a3938: e7ff         	b	0x700a393a <Sciclient_rmIrGetOutp+0x5a> @ imm = #-0x2
700a393a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a393e: b988         	cbnz	r0, 0x700a3964 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x22
700a3940: e7ff         	b	0x700a3942 <Sciclient_rmIrGetOutp+0x62> @ imm = #-0x2
;         if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a3942: 9804         	ldr	r0, [sp, #0x10]
700a3944: 8980         	ldrh	r0, [r0, #0xc]
700a3946: f64f 71ff    	movw	r1, #0xffff
700a394a: 4288         	cmp	r0, r1
700a394c: d005         	beq	0x700a395a <Sciclient_rmIrGetOutp+0x7a> @ imm = #0xa
700a394e: e7ff         	b	0x700a3950 <Sciclient_rmIrGetOutp+0x70> @ imm = #-0x2
;             *outp = inst->inp0_mapping;
700a3950: 9804         	ldr	r0, [sp, #0x10]
700a3952: 8980         	ldrh	r0, [r0, #0xc]
700a3954: 9906         	ldr	r1, [sp, #0x18]
700a3956: 8008         	strh	r0, [r1]
;         } else {
700a3958: e003         	b	0x700a3962 <Sciclient_rmIrGetOutp+0x82> @ imm = #0x6
700a395a: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a395e: 9005         	str	r0, [sp, #0x14]
700a3960: e7ff         	b	0x700a3962 <Sciclient_rmIrGetOutp+0x82> @ imm = #-0x2
;     }
700a3962: e7ff         	b	0x700a3964 <Sciclient_rmIrGetOutp+0x84> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp != 0u)) {
700a3964: 9805         	ldr	r0, [sp, #0x14]
700a3966: bbb8         	cbnz	r0, 0x700a39d8 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x6e
700a3968: e7ff         	b	0x700a396a <Sciclient_rmIrGetOutp+0x8a> @ imm = #-0x2
700a396a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a396e: b398         	cbz	r0, 0x700a39d8 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x66
700a3970: e7ff         	b	0x700a3972 <Sciclient_rmIrGetOutp+0x92> @ imm = #-0x2
700a3972: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a3976: 9005         	str	r0, [sp, #0x14]
700a3978: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_outp; i++) {
700a397a: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a397e: e7ff         	b	0x700a3980 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x2
700a3980: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a3984: 9904         	ldr	r1, [sp, #0x10]
700a3986: 8949         	ldrh	r1, [r1, #0xa]
700a3988: 4288         	cmp	r0, r1
700a398a: da24         	bge	0x700a39d6 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0x48
700a398c: e7ff         	b	0x700a398e <Sciclient_rmIrGetOutp+0xae> @ imm = #-0x2
;             int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, i);
700a398e: 9804         	ldr	r0, [sp, #0x10]
700a3990: 6840         	ldr	r0, [r0, #0x4]
700a3992: f8bd 100e    	ldrh.w	r1, [sp, #0xe]
700a3996: f009 f803    	bl	0x700ac9a0 <Sciclient_getIrAddr> @ imm = #0x9006
700a399a: 9002         	str	r0, [sp, #0x8]
;             extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a399c: 9802         	ldr	r0, [sp, #0x8]
700a399e: f240 31ff    	movw	r1, #0x3ff
700a39a2: 2200         	movs	r2, #0x0
700a39a4: f009 facc    	bl	0x700acf40 <CSL_REG32_FEXT_RAW> @ imm = #0x9598
700a39a8: f8ad 0006    	strh.w	r0, [sp, #0x6]
;             if (inp == extracted_inp) {
700a39ac: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a39b0: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700a39b4: 4288         	cmp	r0, r1
700a39b6: d107         	bne	0x700a39c8 <Sciclient_rmIrGetOutp+0xe8> @ imm = #0xe
700a39b8: e7ff         	b	0x700a39ba <Sciclient_rmIrGetOutp+0xda> @ imm = #-0x2
;                 *outp = i;
700a39ba: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a39be: 9906         	ldr	r1, [sp, #0x18]
700a39c0: 8008         	strh	r0, [r1]
700a39c2: 2000         	movs	r0, #0x0
;                 r = SystemP_SUCCESS;
700a39c4: 9005         	str	r0, [sp, #0x14]
;                 break;
700a39c6: e006         	b	0x700a39d6 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0xc
;         }
700a39c8: e7ff         	b	0x700a39ca <Sciclient_rmIrGetOutp+0xea> @ imm = #-0x2
;         for (i = 0u; i < inst->n_outp; i++) {
700a39ca: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a39ce: 3001         	adds	r0, #0x1
700a39d0: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a39d4: e7d4         	b	0x700a3980 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x58
;     }
700a39d6: e7ff         	b	0x700a39d8 <Sciclient_rmIrGetOutp+0xf8> @ imm = #-0x2
;     return r;
700a39d8: 9805         	ldr	r0, [sp, #0x14]
700a39da: b008         	add	sp, #0x20
700a39dc: bd80         	pop	{r7, pc}
700a39de: 0000         	movs	r0, r0

700a39e0 <vTaskPriorityDisinheritAfterTimeout>:
;     UBaseType_t uxHighestPriorityWaitingTask) {
700a39e0: b580         	push	{r7, lr}
700a39e2: b086         	sub	sp, #0x18
700a39e4: 9005         	str	r0, [sp, #0x14]
700a39e6: 9104         	str	r1, [sp, #0x10]
;   TCB_t *const pxTCB = pxMutexHolder;
700a39e8: 9805         	ldr	r0, [sp, #0x14]
700a39ea: 9003         	str	r0, [sp, #0xc]
700a39ec: 2001         	movs	r0, #0x1
;   const UBaseType_t uxOnlyOneMutexHeld = (UBaseType_t)1;
700a39ee: 9000         	str	r0, [sp]
;   if (pxMutexHolder != NULL) {
700a39f0: 9805         	ldr	r0, [sp, #0x14]
700a39f2: 2800         	cmp	r0, #0x0
700a39f4: d06d         	beq	0x700a3ad2 <vTaskPriorityDisinheritAfterTimeout+0xf2> @ imm = #0xda
700a39f6: e7ff         	b	0x700a39f8 <vTaskPriorityDisinheritAfterTimeout+0x18> @ imm = #-0x2
;     if (pxTCB->uxBasePriority < uxHighestPriorityWaitingTask) {
700a39f8: 9803         	ldr	r0, [sp, #0xc]
700a39fa: 6e00         	ldr	r0, [r0, #0x60]
700a39fc: 9904         	ldr	r1, [sp, #0x10]
700a39fe: 4288         	cmp	r0, r1
700a3a00: d203         	bhs	0x700a3a0a <vTaskPriorityDisinheritAfterTimeout+0x2a> @ imm = #0x6
700a3a02: e7ff         	b	0x700a3a04 <vTaskPriorityDisinheritAfterTimeout+0x24> @ imm = #-0x2
;       uxPriorityToUse = uxHighestPriorityWaitingTask;
700a3a04: 9804         	ldr	r0, [sp, #0x10]
700a3a06: 9001         	str	r0, [sp, #0x4]
;     } else {
700a3a08: e003         	b	0x700a3a12 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #0x6
;       uxPriorityToUse = pxTCB->uxBasePriority;
700a3a0a: 9803         	ldr	r0, [sp, #0xc]
700a3a0c: 6e00         	ldr	r0, [r0, #0x60]
700a3a0e: 9001         	str	r0, [sp, #0x4]
700a3a10: e7ff         	b	0x700a3a12 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #-0x2
;     if (pxTCB->uxPriority != uxPriorityToUse) {
700a3a12: 9803         	ldr	r0, [sp, #0xc]
700a3a14: 6ac0         	ldr	r0, [r0, #0x2c]
700a3a16: 9901         	ldr	r1, [sp, #0x4]
700a3a18: 4288         	cmp	r0, r1
700a3a1a: d058         	beq	0x700a3ace <vTaskPriorityDisinheritAfterTimeout+0xee> @ imm = #0xb0
700a3a1c: e7ff         	b	0x700a3a1e <vTaskPriorityDisinheritAfterTimeout+0x3e> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld) {
700a3a1e: 9803         	ldr	r0, [sp, #0xc]
700a3a20: 6e40         	ldr	r0, [r0, #0x64]
700a3a22: 2801         	cmp	r0, #0x1
700a3a24: d151         	bne	0x700a3aca <vTaskPriorityDisinheritAfterTimeout+0xea> @ imm = #0xa2
700a3a26: e7ff         	b	0x700a3a28 <vTaskPriorityDisinheritAfterTimeout+0x48> @ imm = #-0x2
;         uxPriorityUsedOnEntry = pxTCB->uxPriority;
700a3a28: 9803         	ldr	r0, [sp, #0xc]
700a3a2a: 6ac0         	ldr	r0, [r0, #0x2c]
700a3a2c: 9002         	str	r0, [sp, #0x8]
;         pxTCB->uxPriority = uxPriorityToUse;
700a3a2e: 9801         	ldr	r0, [sp, #0x4]
700a3a30: 9903         	ldr	r1, [sp, #0xc]
700a3a32: 62c8         	str	r0, [r1, #0x2c]
;         if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) &
700a3a34: 9803         	ldr	r0, [sp, #0xc]
700a3a36: 7ec0         	ldrb	r0, [r0, #0x1b]
700a3a38: 0600         	lsls	r0, r0, #0x18
700a3a3a: 2800         	cmp	r0, #0x0
700a3a3c: d406         	bmi	0x700a3a4c <vTaskPriorityDisinheritAfterTimeout+0x6c> @ imm = #0xc
700a3a3e: e7ff         	b	0x700a3a40 <vTaskPriorityDisinheritAfterTimeout+0x60> @ imm = #-0x2
;           listSET_LIST_ITEM_VALUE(
700a3a40: 9801         	ldr	r0, [sp, #0x4]
700a3a42: f1c0 0020    	rsb.w	r0, r0, #0x20
700a3a46: 9903         	ldr	r1, [sp, #0xc]
700a3a48: 6188         	str	r0, [r1, #0x18]
;         } else {
700a3a4a: e000         	b	0x700a3a4e <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #0x0
700a3a4c: e7ff         	b	0x700a3a4e <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #-0x2
;         if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]),
700a3a4e: 9803         	ldr	r0, [sp, #0xc]
700a3a50: 6940         	ldr	r0, [r0, #0x14]
700a3a52: 9902         	ldr	r1, [sp, #0x8]
700a3a54: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a3a58: f244 41f8    	movw	r1, #0x44f8
700a3a5c: f2c7 0108    	movt	r1, #0x7008
700a3a60: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a3a64: 4288         	cmp	r0, r1
700a3a66: d12e         	bne	0x700a3ac6 <vTaskPriorityDisinheritAfterTimeout+0xe6> @ imm = #0x5c
700a3a68: e7ff         	b	0x700a3a6a <vTaskPriorityDisinheritAfterTimeout+0x8a> @ imm = #-0x2
;           if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a3a6a: 9803         	ldr	r0, [sp, #0xc]
700a3a6c: 3004         	adds	r0, #0x4
700a3a6e: f007 fd5f    	bl	0x700ab530 <uxListRemove> @ imm = #0x7abe
700a3a72: b968         	cbnz	r0, 0x700a3a90 <vTaskPriorityDisinheritAfterTimeout+0xb0> @ imm = #0x1a
700a3a74: e7ff         	b	0x700a3a76 <vTaskPriorityDisinheritAfterTimeout+0x96> @ imm = #-0x2
;             portRESET_READY_PRIORITY(pxTCB->uxPriority, uxTopReadyPriority);
700a3a76: 9803         	ldr	r0, [sp, #0xc]
700a3a78: 6ac1         	ldr	r1, [r0, #0x2c]
700a3a7a: 2001         	movs	r0, #0x1
700a3a7c: fa00 f201    	lsl.w	r2, r0, r1
700a3a80: f240 5108    	movw	r1, #0x508
700a3a84: f2c7 010b    	movt	r1, #0x700b
700a3a88: 6808         	ldr	r0, [r1]
700a3a8a: 4390         	bics	r0, r2
700a3a8c: 6008         	str	r0, [r1]
;           } else {
700a3a8e: e000         	b	0x700a3a92 <vTaskPriorityDisinheritAfterTimeout+0xb2> @ imm = #0x0
700a3a90: e7ff         	b	0x700a3a92 <vTaskPriorityDisinheritAfterTimeout+0xb2> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
700a3a92: 9803         	ldr	r0, [sp, #0xc]
700a3a94: 6ac1         	ldr	r1, [r0, #0x2c]
700a3a96: 2001         	movs	r0, #0x1
700a3a98: fa00 f201    	lsl.w	r2, r0, r1
700a3a9c: f240 5108    	movw	r1, #0x508
700a3aa0: f2c7 010b    	movt	r1, #0x700b
700a3aa4: 6808         	ldr	r0, [r1]
700a3aa6: 4310         	orrs	r0, r2
700a3aa8: 6008         	str	r0, [r1]
700a3aaa: 9903         	ldr	r1, [sp, #0xc]
700a3aac: 6ac8         	ldr	r0, [r1, #0x2c]
700a3aae: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a3ab2: f244 40f8    	movw	r0, #0x44f8
700a3ab6: f2c7 0008    	movt	r0, #0x7008
700a3aba: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a3abe: 3104         	adds	r1, #0x4
700a3ac0: f008 faee    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #0x85dc
;         } else {
700a3ac4: e000         	b	0x700a3ac8 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #0x0
700a3ac6: e7ff         	b	0x700a3ac8 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #-0x2
;       } else {
700a3ac8: e000         	b	0x700a3acc <vTaskPriorityDisinheritAfterTimeout+0xec> @ imm = #0x0
700a3aca: e7ff         	b	0x700a3acc <vTaskPriorityDisinheritAfterTimeout+0xec> @ imm = #-0x2
;     } else {
700a3acc: e000         	b	0x700a3ad0 <vTaskPriorityDisinheritAfterTimeout+0xf0> @ imm = #0x0
700a3ace: e7ff         	b	0x700a3ad0 <vTaskPriorityDisinheritAfterTimeout+0xf0> @ imm = #-0x2
;   } else {
700a3ad0: e000         	b	0x700a3ad4 <vTaskPriorityDisinheritAfterTimeout+0xf4> @ imm = #0x0
700a3ad2: e7ff         	b	0x700a3ad4 <vTaskPriorityDisinheritAfterTimeout+0xf4> @ imm = #-0x2
; }
700a3ad4: b006         	add	sp, #0x18
700a3ad6: bd80         	pop	{r7, pc}
		...

700a3ae0 <eTaskGetState>:
; eTaskState eTaskGetState(TaskHandle_t xTask) {
700a3ae0: b580         	push	{r7, lr}
700a3ae2: b088         	sub	sp, #0x20
700a3ae4: 9007         	str	r0, [sp, #0x1c]
;   const TCB_t *const pxTCB = xTask;
700a3ae6: 9807         	ldr	r0, [sp, #0x1c]
700a3ae8: 9002         	str	r0, [sp, #0x8]
;   if (pxTCB == pxCurrentTCB) {
700a3aea: 9802         	ldr	r0, [sp, #0x8]
700a3aec: f240 41dc    	movw	r1, #0x4dc
700a3af0: f2c7 010b    	movt	r1, #0x700b
700a3af4: 6809         	ldr	r1, [r1]
700a3af6: 4288         	cmp	r0, r1
700a3af8: d104         	bne	0x700a3b04 <eTaskGetState+0x24> @ imm = #0x8
700a3afa: e7ff         	b	0x700a3afc <eTaskGetState+0x1c> @ imm = #-0x2
700a3afc: 2000         	movs	r0, #0x0
;     eReturn = eRunning;
700a3afe: f88d 001b    	strb.w	r0, [sp, #0x1b]
;   } else {
700a3b02: e063         	b	0x700a3bcc <eTaskGetState+0xec> @ imm = #0xc6
;     taskENTER_CRITICAL();
700a3b04: f008 fd44    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x8a88
;       pxStateList = listLIST_ITEM_CONTAINER(&(pxTCB->xStateListItem));
700a3b08: 9802         	ldr	r0, [sp, #0x8]
700a3b0a: 6940         	ldr	r0, [r0, #0x14]
700a3b0c: 9005         	str	r0, [sp, #0x14]
;       pxDelayedList = pxDelayedTaskList;
700a3b0e: f644 70b8    	movw	r0, #0x4fb8
700a3b12: f2c7 0008    	movt	r0, #0x7008
700a3b16: 6800         	ldr	r0, [r0]
700a3b18: 9004         	str	r0, [sp, #0x10]
;       pxOverflowedDelayedList = pxOverflowDelayedTaskList;
700a3b1a: f644 70bc    	movw	r0, #0x4fbc
700a3b1e: f2c7 0008    	movt	r0, #0x7008
700a3b22: 6800         	ldr	r0, [r0]
700a3b24: 9003         	str	r0, [sp, #0xc]
;     taskEXIT_CRITICAL();
700a3b26: f007 fdf3    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x7be6
;     if ((pxStateList == pxDelayedList) ||
700a3b2a: 9805         	ldr	r0, [sp, #0x14]
700a3b2c: 9904         	ldr	r1, [sp, #0x10]
700a3b2e: 4288         	cmp	r0, r1
700a3b30: d005         	beq	0x700a3b3e <eTaskGetState+0x5e> @ imm = #0xa
700a3b32: e7ff         	b	0x700a3b34 <eTaskGetState+0x54> @ imm = #-0x2
;         (pxStateList == pxOverflowedDelayedList)) {
700a3b34: 9805         	ldr	r0, [sp, #0x14]
700a3b36: 9903         	ldr	r1, [sp, #0xc]
;     if ((pxStateList == pxDelayedList) ||
700a3b38: 4288         	cmp	r0, r1
700a3b3a: d104         	bne	0x700a3b46 <eTaskGetState+0x66> @ imm = #0x8
700a3b3c: e7ff         	b	0x700a3b3e <eTaskGetState+0x5e> @ imm = #-0x2
700a3b3e: 2002         	movs	r0, #0x2
;       eReturn = eBlocked;
700a3b40: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a3b44: e041         	b	0x700a3bca <eTaskGetState+0xea> @ imm = #0x82
;     else if (pxStateList == &xSuspendedTaskList) {
700a3b46: 9805         	ldr	r0, [sp, #0x14]
700a3b48: f644 717c    	movw	r1, #0x4f7c
700a3b4c: f2c7 0108    	movt	r1, #0x7008
700a3b50: 4288         	cmp	r0, r1
700a3b52: d125         	bne	0x700a3ba0 <eTaskGetState+0xc0> @ imm = #0x4a
700a3b54: e7ff         	b	0x700a3b56 <eTaskGetState+0x76> @ imm = #-0x2
;       if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL) {
700a3b56: 9802         	ldr	r0, [sp, #0x8]
700a3b58: 6a80         	ldr	r0, [r0, #0x28]
700a3b5a: b9e0         	cbnz	r0, 0x700a3b96 <eTaskGetState+0xb6> @ imm = #0x38
700a3b5c: e7ff         	b	0x700a3b5e <eTaskGetState+0x7e> @ imm = #-0x2
700a3b5e: 2003         	movs	r0, #0x3
;           eReturn = eSuspended;
700a3b60: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a3b64: 2000         	movs	r0, #0x0
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a3b66: 9001         	str	r0, [sp, #0x4]
700a3b68: e7ff         	b	0x700a3b6a <eTaskGetState+0x8a> @ imm = #-0x2
700a3b6a: 9801         	ldr	r0, [sp, #0x4]
700a3b6c: 2801         	cmp	r0, #0x1
700a3b6e: dc11         	bgt	0x700a3b94 <eTaskGetState+0xb4> @ imm = #0x22
700a3b70: e7ff         	b	0x700a3b72 <eTaskGetState+0x92> @ imm = #-0x2
;             if (pxTCB->ucNotifyState[x] == taskWAITING_NOTIFICATION) {
700a3b72: 9802         	ldr	r0, [sp, #0x8]
700a3b74: 9901         	ldr	r1, [sp, #0x4]
700a3b76: 4408         	add	r0, r1
700a3b78: f890 0084    	ldrb.w	r0, [r0, #0x84]
700a3b7c: 2801         	cmp	r0, #0x1
700a3b7e: d104         	bne	0x700a3b8a <eTaskGetState+0xaa> @ imm = #0x8
700a3b80: e7ff         	b	0x700a3b82 <eTaskGetState+0xa2> @ imm = #-0x2
700a3b82: 2002         	movs	r0, #0x2
;               eReturn = eBlocked;
700a3b84: f88d 001b    	strb.w	r0, [sp, #0x1b]
;               break;
700a3b88: e004         	b	0x700a3b94 <eTaskGetState+0xb4> @ imm = #0x8
;           }
700a3b8a: e7ff         	b	0x700a3b8c <eTaskGetState+0xac> @ imm = #-0x2
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a3b8c: 9801         	ldr	r0, [sp, #0x4]
700a3b8e: 3001         	adds	r0, #0x1
700a3b90: 9001         	str	r0, [sp, #0x4]
700a3b92: e7ea         	b	0x700a3b6a <eTaskGetState+0x8a> @ imm = #-0x2c
;       } else {
700a3b94: e003         	b	0x700a3b9e <eTaskGetState+0xbe> @ imm = #0x6
700a3b96: 2002         	movs	r0, #0x2
;         eReturn = eBlocked;
700a3b98: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a3b9c: e7ff         	b	0x700a3b9e <eTaskGetState+0xbe> @ imm = #-0x2
;     }
700a3b9e: e013         	b	0x700a3bc8 <eTaskGetState+0xe8> @ imm = #0x26
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a3ba0: 9805         	ldr	r0, [sp, #0x14]
700a3ba2: f644 7190    	movw	r1, #0x4f90
700a3ba6: f2c7 0108    	movt	r1, #0x7008
700a3baa: 4288         	cmp	r0, r1
700a3bac: d003         	beq	0x700a3bb6 <eTaskGetState+0xd6> @ imm = #0x6
700a3bae: e7ff         	b	0x700a3bb0 <eTaskGetState+0xd0> @ imm = #-0x2
;              (pxStateList == NULL)) {
700a3bb0: 9805         	ldr	r0, [sp, #0x14]
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a3bb2: b920         	cbnz	r0, 0x700a3bbe <eTaskGetState+0xde> @ imm = #0x8
700a3bb4: e7ff         	b	0x700a3bb6 <eTaskGetState+0xd6> @ imm = #-0x2
700a3bb6: 2004         	movs	r0, #0x4
;       eReturn = eDeleted;
700a3bb8: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a3bbc: e003         	b	0x700a3bc6 <eTaskGetState+0xe6> @ imm = #0x6
700a3bbe: 2001         	movs	r0, #0x1
;       eReturn = eReady;
700a3bc0: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a3bc4: e7ff         	b	0x700a3bc6 <eTaskGetState+0xe6> @ imm = #-0x2
700a3bc6: e7ff         	b	0x700a3bc8 <eTaskGetState+0xe8> @ imm = #-0x2
700a3bc8: e7ff         	b	0x700a3bca <eTaskGetState+0xea> @ imm = #-0x2
700a3bca: e7ff         	b	0x700a3bcc <eTaskGetState+0xec> @ imm = #-0x2
;   return eReturn;
700a3bcc: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a3bd0: b008         	add	sp, #0x20
700a3bd2: bd80         	pop	{r7, pc}
		...

700a3be0 <prvAddCurrentTaskToDelayedList>:
;                                const BaseType_t xCanBlockIndefinitely) {
700a3be0: b580         	push	{r7, lr}
700a3be2: b084         	sub	sp, #0x10
700a3be4: 9003         	str	r0, [sp, #0xc]
700a3be6: 9102         	str	r1, [sp, #0x8]
;   const TickType_t xConstTickCount = xTickCount;
700a3be8: f240 5020    	movw	r0, #0x520
700a3bec: f2c7 000b    	movt	r0, #0x700b
700a3bf0: 6800         	ldr	r0, [r0]
700a3bf2: 9000         	str	r0, [sp]
;   if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
700a3bf4: f240 40dc    	movw	r0, #0x4dc
700a3bf8: f2c7 000b    	movt	r0, #0x700b
700a3bfc: 6800         	ldr	r0, [r0]
700a3bfe: 3004         	adds	r0, #0x4
700a3c00: f007 fc96    	bl	0x700ab530 <uxListRemove> @ imm = #0x792c
700a3c04: b988         	cbnz	r0, 0x700a3c2a <prvAddCurrentTaskToDelayedList+0x4a> @ imm = #0x22
700a3c06: e7ff         	b	0x700a3c08 <prvAddCurrentTaskToDelayedList+0x28> @ imm = #-0x2
;     portRESET_READY_PRIORITY(
700a3c08: f240 40dc    	movw	r0, #0x4dc
700a3c0c: f2c7 000b    	movt	r0, #0x700b
700a3c10: 6800         	ldr	r0, [r0]
700a3c12: 6ac1         	ldr	r1, [r0, #0x2c]
700a3c14: 2001         	movs	r0, #0x1
700a3c16: fa00 f201    	lsl.w	r2, r0, r1
700a3c1a: f240 5108    	movw	r1, #0x508
700a3c1e: f2c7 010b    	movt	r1, #0x700b
700a3c22: 6808         	ldr	r0, [r1]
700a3c24: 4390         	bics	r0, r2
700a3c26: 6008         	str	r0, [r1]
;   } else {
700a3c28: e000         	b	0x700a3c2c <prvAddCurrentTaskToDelayedList+0x4c> @ imm = #0x0
700a3c2a: e7ff         	b	0x700a3c2c <prvAddCurrentTaskToDelayedList+0x4c> @ imm = #-0x2
;     if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
700a3c2c: 9803         	ldr	r0, [sp, #0xc]
700a3c2e: 3001         	adds	r0, #0x1
700a3c30: b980         	cbnz	r0, 0x700a3c54 <prvAddCurrentTaskToDelayedList+0x74> @ imm = #0x20
700a3c32: e7ff         	b	0x700a3c34 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #-0x2
700a3c34: 9802         	ldr	r0, [sp, #0x8]
700a3c36: b168         	cbz	r0, 0x700a3c54 <prvAddCurrentTaskToDelayedList+0x74> @ imm = #0x1a
700a3c38: e7ff         	b	0x700a3c3a <prvAddCurrentTaskToDelayedList+0x5a> @ imm = #-0x2
;       vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
700a3c3a: f240 40dc    	movw	r0, #0x4dc
700a3c3e: f2c7 000b    	movt	r0, #0x700b
700a3c42: 6800         	ldr	r0, [r0]
700a3c44: 1d01         	adds	r1, r0, #0x4
700a3c46: f644 707c    	movw	r0, #0x4f7c
700a3c4a: f2c7 0008    	movt	r0, #0x7008
700a3c4e: f008 fa27    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #0x844e
;     } else {
700a3c52: e03d         	b	0x700a3cd0 <prvAddCurrentTaskToDelayedList+0xf0> @ imm = #0x7a
;       xTimeToWake = xConstTickCount + xTicksToWait;
700a3c54: 9800         	ldr	r0, [sp]
700a3c56: 9903         	ldr	r1, [sp, #0xc]
700a3c58: 4408         	add	r0, r1
700a3c5a: 9001         	str	r0, [sp, #0x4]
;       listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
700a3c5c: 9801         	ldr	r0, [sp, #0x4]
700a3c5e: f240 41dc    	movw	r1, #0x4dc
700a3c62: f2c7 010b    	movt	r1, #0x700b
700a3c66: 6809         	ldr	r1, [r1]
700a3c68: 6048         	str	r0, [r1, #0x4]
;       if (xTimeToWake < xConstTickCount) {
700a3c6a: 9801         	ldr	r0, [sp, #0x4]
700a3c6c: 9900         	ldr	r1, [sp]
700a3c6e: 4288         	cmp	r0, r1
700a3c70: d20e         	bhs	0x700a3c90 <prvAddCurrentTaskToDelayedList+0xb0> @ imm = #0x1c
700a3c72: e7ff         	b	0x700a3c74 <prvAddCurrentTaskToDelayedList+0x94> @ imm = #-0x2
;         vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a3c74: f644 70bc    	movw	r0, #0x4fbc
700a3c78: f2c7 0008    	movt	r0, #0x7008
700a3c7c: 6800         	ldr	r0, [r0]
700a3c7e: f240 41dc    	movw	r1, #0x4dc
700a3c82: f2c7 010b    	movt	r1, #0x700b
700a3c86: 6809         	ldr	r1, [r1]
700a3c88: 3104         	adds	r1, #0x4
700a3c8a: f005 fd09    	bl	0x700a96a0 <vListInsert> @ imm = #0x5a12
;       } else {
700a3c8e: e01e         	b	0x700a3cce <prvAddCurrentTaskToDelayedList+0xee> @ imm = #0x3c
;         vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a3c90: f644 70b8    	movw	r0, #0x4fb8
700a3c94: f2c7 0008    	movt	r0, #0x7008
700a3c98: 6800         	ldr	r0, [r0]
700a3c9a: f240 41dc    	movw	r1, #0x4dc
700a3c9e: f2c7 010b    	movt	r1, #0x700b
700a3ca2: 6809         	ldr	r1, [r1]
700a3ca4: 3104         	adds	r1, #0x4
700a3ca6: f005 fcfb    	bl	0x700a96a0 <vListInsert> @ imm = #0x59f6
;         if (xTimeToWake < xNextTaskUnblockTime) {
700a3caa: 9801         	ldr	r0, [sp, #0x4]
700a3cac: f240 5110    	movw	r1, #0x510
700a3cb0: f2c7 010b    	movt	r1, #0x700b
700a3cb4: 6809         	ldr	r1, [r1]
700a3cb6: 4288         	cmp	r0, r1
700a3cb8: d207         	bhs	0x700a3cca <prvAddCurrentTaskToDelayedList+0xea> @ imm = #0xe
700a3cba: e7ff         	b	0x700a3cbc <prvAddCurrentTaskToDelayedList+0xdc> @ imm = #-0x2
;           xNextTaskUnblockTime = xTimeToWake;
700a3cbc: 9801         	ldr	r0, [sp, #0x4]
700a3cbe: f240 5110    	movw	r1, #0x510
700a3cc2: f2c7 010b    	movt	r1, #0x700b
700a3cc6: 6008         	str	r0, [r1]
;         } else {
700a3cc8: e000         	b	0x700a3ccc <prvAddCurrentTaskToDelayedList+0xec> @ imm = #0x0
700a3cca: e7ff         	b	0x700a3ccc <prvAddCurrentTaskToDelayedList+0xec> @ imm = #-0x2
700a3ccc: e7ff         	b	0x700a3cce <prvAddCurrentTaskToDelayedList+0xee> @ imm = #-0x2
700a3cce: e7ff         	b	0x700a3cd0 <prvAddCurrentTaskToDelayedList+0xf0> @ imm = #-0x2
; }
700a3cd0: b004         	add	sp, #0x10
700a3cd2: bd80         	pop	{r7, pc}
		...

700a3ce0 <Udma_eventIsrFxn>:
; {
700a3ce0: b580         	push	{r7, lr}
700a3ce2: b088         	sub	sp, #0x20
700a3ce4: 9007         	str	r0, [sp, #0x1c]
;     Udma_EventHandleInt eventHandle = (Udma_EventHandleInt) args;
700a3ce6: 9807         	ldr	r0, [sp, #0x1c]
700a3ce8: 9003         	str	r0, [sp, #0xc]
700a3cea: 2001         	movs	r0, #0x1
;     teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_NA;
700a3cec: 9004         	str	r0, [sp, #0x10]
700a3cee: 2000         	movs	r0, #0x0
;     ringHandle = NULL;
700a3cf0: 9000         	str	r0, [sp]
;     drvHandle = eventHandle->drvHandle;
700a3cf2: 9803         	ldr	r0, [sp, #0xc]
700a3cf4: 6800         	ldr	r0, [r0]
700a3cf6: 9002         	str	r0, [sp, #0x8]
;     vintrNum = eventHandle->vintrNum;
700a3cf8: 9803         	ldr	r0, [sp, #0xc]
700a3cfa: 6cc0         	ldr	r0, [r0, #0x4c]
700a3cfc: 9005         	str	r0, [sp, #0x14]
;     while(eventHandle != NULL_PTR)
700a3cfe: e7ff         	b	0x700a3d00 <Udma_eventIsrFxn+0x20> @ imm = #-0x2
700a3d00: 9803         	ldr	r0, [sp, #0xc]
700a3d02: 2800         	cmp	r0, #0x0
700a3d04: d060         	beq	0x700a3dc8 <Udma_eventIsrFxn+0xe8> @ imm = #0xc0
700a3d06: e7ff         	b	0x700a3d08 <Udma_eventIsrFxn+0x28> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventHandle->eventPrms.eventType)
700a3d08: 9803         	ldr	r0, [sp, #0xc]
700a3d0a: 6880         	ldr	r0, [r0, #0x8]
700a3d0c: 2805         	cmp	r0, #0x5
700a3d0e: d057         	beq	0x700a3dc0 <Udma_eventIsrFxn+0xe0> @ imm = #0xae
700a3d10: e7ff         	b	0x700a3d12 <Udma_eventIsrFxn+0x32> @ imm = #-0x2
;             vintrBitNum = vintrNum * UDMA_MAX_EVENTS_PER_VINTR;
700a3d12: 9805         	ldr	r0, [sp, #0x14]
700a3d14: 0180         	lsls	r0, r0, #0x6
700a3d16: 9006         	str	r0, [sp, #0x18]
;             vintrBitNum += eventHandle->vintrBitNum;
700a3d18: 9803         	ldr	r0, [sp, #0xc]
700a3d1a: 6d01         	ldr	r1, [r0, #0x50]
700a3d1c: 9806         	ldr	r0, [sp, #0x18]
700a3d1e: 4408         	add	r0, r1
700a3d20: 9006         	str	r0, [sp, #0x18]
;             if((bool)true == CSL_intaggrIsIntrPending(&drvHandle->iaRegs, vintrBitNum, (bool)true))
700a3d22: 9802         	ldr	r0, [sp, #0x8]
700a3d24: 309c         	adds	r0, #0x9c
700a3d26: 9906         	ldr	r1, [sp, #0x18]
700a3d28: 2201         	movs	r2, #0x1
700a3d2a: f002 fc69    	bl	0x700a6600 <CSL_intaggrIsIntrPending> @ imm = #0x28d2
700a3d2e: 2800         	cmp	r0, #0x0
700a3d30: d045         	beq	0x700a3dbe <Udma_eventIsrFxn+0xde> @ imm = #0x8a
700a3d32: e7ff         	b	0x700a3d34 <Udma_eventIsrFxn+0x54> @ imm = #-0x2
;                 (void) CSL_intaggrClrIntr(&drvHandle->iaRegs, vintrBitNum);
700a3d34: 9802         	ldr	r0, [sp, #0x8]
700a3d36: 309c         	adds	r0, #0x9c
700a3d38: 9906         	ldr	r1, [sp, #0x18]
700a3d3a: f005 faf1    	bl	0x700a9320 <CSL_intaggrClrIntr> @ imm = #0x55e2
;                 eventPrms = &eventHandle->eventPrms;
700a3d3e: 9803         	ldr	r0, [sp, #0xc]
700a3d40: 3008         	adds	r0, #0x8
700a3d42: 9001         	str	r0, [sp, #0x4]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a3d44: 9801         	ldr	r0, [sp, #0x4]
700a3d46: 6800         	ldr	r0, [r0]
700a3d48: 2801         	cmp	r0, #0x1
700a3d4a: d005         	beq	0x700a3d58 <Udma_eventIsrFxn+0x78> @ imm = #0xa
700a3d4c: e7ff         	b	0x700a3d4e <Udma_eventIsrFxn+0x6e> @ imm = #-0x2
;                    (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a3d4e: 9801         	ldr	r0, [sp, #0x4]
700a3d50: 6800         	ldr	r0, [r0]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a3d52: 2806         	cmp	r0, #0x6
700a3d54: d114         	bne	0x700a3d80 <Udma_eventIsrFxn+0xa0> @ imm = #0x28
700a3d56: e7ff         	b	0x700a3d58 <Udma_eventIsrFxn+0x78> @ imm = #-0x2
;                     ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a3d58: 9801         	ldr	r0, [sp, #0x4]
700a3d5a: 6880         	ldr	r0, [r0, #0x8]
700a3d5c: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a3d60: 9000         	str	r0, [sp]
;                     if( CSL_lcdma_ringaccIsTeardownComplete(&ringHandle->drvHandle->lcdmaRaRegs, ringHandle->ringNum) == TRUE )
700a3d62: 9900         	ldr	r1, [sp]
700a3d64: 6808         	ldr	r0, [r1]
700a3d66: 308c         	adds	r0, #0x8c
700a3d68: 8889         	ldrh	r1, [r1, #0x4]
700a3d6a: f007 fe39    	bl	0x700ab9e0 <CSL_lcdma_ringaccIsTeardownComplete> @ imm = #0x7c72
700a3d6e: b118         	cbz	r0, 0x700a3d78 <Udma_eventIsrFxn+0x98> @ imm = #0x6
700a3d70: e7ff         	b	0x700a3d72 <Udma_eventIsrFxn+0x92> @ imm = #-0x2
700a3d72: 2002         	movs	r0, #0x2
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE;
700a3d74: 9004         	str	r0, [sp, #0x10]
;                     }
700a3d76: e002         	b	0x700a3d7e <Udma_eventIsrFxn+0x9e> @ imm = #0x4
700a3d78: 2003         	movs	r0, #0x3
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE;
700a3d7a: 9004         	str	r0, [sp, #0x10]
700a3d7c: e7ff         	b	0x700a3d7e <Udma_eventIsrFxn+0x9e> @ imm = #-0x2
;                 }
700a3d7e: e7ff         	b	0x700a3d80 <Udma_eventIsrFxn+0xa0> @ imm = #-0x2
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a3d80: 9803         	ldr	r0, [sp, #0xc]
700a3d82: 6880         	ldr	r0, [r0, #0x8]
700a3d84: 2801         	cmp	r0, #0x1
700a3d86: d104         	bne	0x700a3d92 <Udma_eventIsrFxn+0xb2> @ imm = #0x8
700a3d88: e7ff         	b	0x700a3d8a <Udma_eventIsrFxn+0xaa> @ imm = #-0x2
700a3d8a: 9804         	ldr	r0, [sp, #0x10]
700a3d8c: 2802         	cmp	r0, #0x2
700a3d8e: d015         	beq	0x700a3dbc <Udma_eventIsrFxn+0xdc> @ imm = #0x2a
700a3d90: e7ff         	b	0x700a3d92 <Udma_eventIsrFxn+0xb2> @ imm = #-0x2
;                  ((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_TEARDOWN_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE))))
700a3d92: 9803         	ldr	r0, [sp, #0xc]
700a3d94: 6880         	ldr	r0, [r0, #0x8]
700a3d96: 2806         	cmp	r0, #0x6
700a3d98: d104         	bne	0x700a3da4 <Udma_eventIsrFxn+0xc4> @ imm = #0x8
700a3d9a: e7ff         	b	0x700a3d9c <Udma_eventIsrFxn+0xbc> @ imm = #-0x2
700a3d9c: 9804         	ldr	r0, [sp, #0x10]
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a3d9e: 2803         	cmp	r0, #0x3
700a3da0: d00c         	beq	0x700a3dbc <Udma_eventIsrFxn+0xdc> @ imm = #0x18
700a3da2: e7ff         	b	0x700a3da4 <Udma_eventIsrFxn+0xc4> @ imm = #-0x2
;                     if((Udma_EventCallback) NULL_PTR != eventPrms->eventCb)
700a3da4: 9801         	ldr	r0, [sp, #0x4]
700a3da6: 6940         	ldr	r0, [r0, #0x14]
700a3da8: b138         	cbz	r0, 0x700a3dba <Udma_eventIsrFxn+0xda> @ imm = #0xe
700a3daa: e7ff         	b	0x700a3dac <Udma_eventIsrFxn+0xcc> @ imm = #-0x2
;                         eventPrms->eventCb(
700a3dac: 9a01         	ldr	r2, [sp, #0x4]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a3dae: 9803         	ldr	r0, [sp, #0xc]
700a3db0: 6811         	ldr	r1, [r2]
;                         eventPrms->eventCb(
700a3db2: 6953         	ldr	r3, [r2, #0x14]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a3db4: 69d2         	ldr	r2, [r2, #0x1c]
;                         eventPrms->eventCb(
700a3db6: 4798         	blx	r3
;                     }
700a3db8: e7ff         	b	0x700a3dba <Udma_eventIsrFxn+0xda> @ imm = #-0x2
;                 }
700a3dba: e7ff         	b	0x700a3dbc <Udma_eventIsrFxn+0xdc> @ imm = #-0x2
;             }
700a3dbc: e7ff         	b	0x700a3dbe <Udma_eventIsrFxn+0xde> @ imm = #-0x2
;         }
700a3dbe: e7ff         	b	0x700a3dc0 <Udma_eventIsrFxn+0xe0> @ imm = #-0x2
;         eventHandle = eventHandle->nextEvent;
700a3dc0: 9803         	ldr	r0, [sp, #0xc]
700a3dc2: 6dc0         	ldr	r0, [r0, #0x5c]
700a3dc4: 9003         	str	r0, [sp, #0xc]
;     while(eventHandle != NULL_PTR)
700a3dc6: e79b         	b	0x700a3d00 <Udma_eventIsrFxn+0x20> @ imm = #-0xca
;     return;
700a3dc8: b008         	add	sp, #0x20
700a3dca: bd80         	pop	{r7, pc}
700a3dcc: 0000         	movs	r0, r0
700a3dce: 0000         	movs	r0, r0

700a3dd0 <AddrTranslateP_getLocalAddr>:
; {
700a3dd0: b580         	push	{r7, lr}
700a3dd2: b08e         	sub	sp, #0x38
700a3dd4: 910d         	str	r1, [sp, #0x34]
700a3dd6: 900c         	str	r0, [sp, #0x30]
;     DebugP_assertNoLog(gAddrTranslateConfig.numRegions<AddrTranslateP_MAX_REGIONS);
700a3dd8: f240 4064    	movw	r0, #0x464
700a3ddc: f2c7 000b    	movt	r0, #0x700b
700a3de0: 6801         	ldr	r1, [r0]
700a3de2: 2000         	movs	r0, #0x0
700a3de4: 9001         	str	r0, [sp, #0x4]
700a3de6: 2910         	cmp	r1, #0x10
700a3de8: bf38         	it	lo
700a3dea: 2001         	movlo	r0, #0x1
700a3dec: f00b f900    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0xb200
700a3df0: 9801         	ldr	r0, [sp, #0x4]
;     found = 0;
700a3df2: 900b         	str	r0, [sp, #0x2c]
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a3df4: 900a         	str	r0, [sp, #0x28]
700a3df6: e7ff         	b	0x700a3df8 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x2
700a3df8: 980a         	ldr	r0, [sp, #0x28]
700a3dfa: f240 4164    	movw	r1, #0x464
700a3dfe: f2c7 010b    	movt	r1, #0x700b
700a3e02: 6809         	ldr	r1, [r1]
700a3e04: 4288         	cmp	r0, r1
700a3e06: d23b         	bhs	0x700a3e80 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x76
700a3e08: e7ff         	b	0x700a3e0a <AddrTranslateP_getLocalAddr+0x3a> @ imm = #-0x2
;         sizeMask = ( (uint32_t)( ((uint64_t)1U << gAddrTranslateConfig.regionConfig[regionId].size) - 1U) );
700a3e0a: f240 4064    	movw	r0, #0x464
700a3e0e: f2c7 000b    	movt	r0, #0x700b
700a3e12: 6881         	ldr	r1, [r0, #0x8]
700a3e14: 9a0a         	ldr	r2, [sp, #0x28]
700a3e16: eb01 1102    	add.w	r1, r1, r2, lsl #4
700a3e1a: 68ca         	ldr	r2, [r1, #0xc]
700a3e1c: 2101         	movs	r1, #0x1
700a3e1e: 4091         	lsls	r1, r2
700a3e20: 3a20         	subs	r2, #0x20
700a3e22: 2a00         	cmp	r2, #0x0
700a3e24: bf58         	it	pl
700a3e26: 2100         	movpl	r1, #0x0
700a3e28: 3901         	subs	r1, #0x1
700a3e2a: 9103         	str	r1, [sp, #0xc]
;         startAddr = gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a3e2c: 6880         	ldr	r0, [r0, #0x8]
700a3e2e: 9a0a         	ldr	r2, [sp, #0x28]
700a3e30: eb00 1102    	add.w	r1, r0, r2, lsl #4
700a3e34: ea4f 1202    	lsl.w	r2, r2, #0x4
700a3e38: 5880         	ldr	r0, [r0, r2]
700a3e3a: 6849         	ldr	r1, [r1, #0x4]
700a3e3c: 9107         	str	r1, [sp, #0x1c]
700a3e3e: 9006         	str	r0, [sp, #0x18]
;         endAddr = startAddr + sizeMask;
700a3e40: 9906         	ldr	r1, [sp, #0x18]
700a3e42: 9807         	ldr	r0, [sp, #0x1c]
700a3e44: 9a03         	ldr	r2, [sp, #0xc]
700a3e46: 1889         	adds	r1, r1, r2
700a3e48: f140 0000    	adc	r0, r0, #0x0
700a3e4c: 9104         	str	r1, [sp, #0x10]
700a3e4e: 9005         	str	r0, [sp, #0x14]
;         if((systemAddr >= startAddr) && (systemAddr <= endAddr))
700a3e50: 9a0c         	ldr	r2, [sp, #0x30]
700a3e52: 980d         	ldr	r0, [sp, #0x34]
700a3e54: 9b06         	ldr	r3, [sp, #0x18]
700a3e56: 9907         	ldr	r1, [sp, #0x1c]
700a3e58: 1ad2         	subs	r2, r2, r3
700a3e5a: 4188         	sbcs	r0, r1
700a3e5c: d30b         	blo	0x700a3e76 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x16
700a3e5e: e7ff         	b	0x700a3e60 <AddrTranslateP_getLocalAddr+0x90> @ imm = #-0x2
700a3e60: 9b0c         	ldr	r3, [sp, #0x30]
700a3e62: 990d         	ldr	r1, [sp, #0x34]
700a3e64: 9a04         	ldr	r2, [sp, #0x10]
700a3e66: 9805         	ldr	r0, [sp, #0x14]
700a3e68: 1ad2         	subs	r2, r2, r3
700a3e6a: 4188         	sbcs	r0, r1
700a3e6c: d303         	blo	0x700a3e76 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x6
700a3e6e: e7ff         	b	0x700a3e70 <AddrTranslateP_getLocalAddr+0xa0> @ imm = #-0x2
700a3e70: 2001         	movs	r0, #0x1
;             found = 1;
700a3e72: 900b         	str	r0, [sp, #0x2c]
;             break;
700a3e74: e004         	b	0x700a3e80 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x8
;     }
700a3e76: e7ff         	b	0x700a3e78 <AddrTranslateP_getLocalAddr+0xa8> @ imm = #-0x2
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a3e78: 980a         	ldr	r0, [sp, #0x28]
700a3e7a: 3001         	adds	r0, #0x1
700a3e7c: 900a         	str	r0, [sp, #0x28]
700a3e7e: e7bb         	b	0x700a3df8 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x8a
;     if(found != 0U)
700a3e80: 980b         	ldr	r0, [sp, #0x2c]
700a3e82: b1a0         	cbz	r0, 0x700a3eae <AddrTranslateP_getLocalAddr+0xde> @ imm = #0x28
700a3e84: e7ff         	b	0x700a3e86 <AddrTranslateP_getLocalAddr+0xb6> @ imm = #-0x2
;         uint32_t offset = systemAddr - gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a3e86: 990c         	ldr	r1, [sp, #0x30]
700a3e88: f240 4064    	movw	r0, #0x464
700a3e8c: f2c7 000b    	movt	r0, #0x700b
700a3e90: 6882         	ldr	r2, [r0, #0x8]
700a3e92: 9b0a         	ldr	r3, [sp, #0x28]
700a3e94: 011b         	lsls	r3, r3, #0x4
700a3e96: 58d2         	ldr	r2, [r2, r3]
700a3e98: 1a89         	subs	r1, r1, r2
700a3e9a: 9102         	str	r1, [sp, #0x8]
;         localAddr = (void *) (gAddrTranslateConfig.regionConfig[regionId].localAddr + offset);
700a3e9c: 6880         	ldr	r0, [r0, #0x8]
700a3e9e: 990a         	ldr	r1, [sp, #0x28]
700a3ea0: eb00 1001    	add.w	r0, r0, r1, lsl #4
700a3ea4: 6880         	ldr	r0, [r0, #0x8]
700a3ea6: 9902         	ldr	r1, [sp, #0x8]
700a3ea8: 4408         	add	r0, r1
700a3eaa: 9009         	str	r0, [sp, #0x24]
;     }
700a3eac: e002         	b	0x700a3eb4 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #0x4
;         localAddr = (void *) systemAddr;
700a3eae: 980c         	ldr	r0, [sp, #0x30]
700a3eb0: 9009         	str	r0, [sp, #0x24]
700a3eb2: e7ff         	b	0x700a3eb4 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #-0x2
;     return localAddr;
700a3eb4: 9809         	ldr	r0, [sp, #0x24]
700a3eb6: b00e         	add	sp, #0x38
700a3eb8: bd80         	pop	{r7, pc}
700a3eba: 0000         	movs	r0, r0
700a3ebc: 0000         	movs	r0, r0
700a3ebe: 0000         	movs	r0, r0

700a3ec0 <Udma_eventFreeResource>:
; {
700a3ec0: b580         	push	{r7, lr}
700a3ec2: b084         	sub	sp, #0x10
700a3ec4: 9003         	str	r0, [sp, #0xc]
700a3ec6: 9102         	str	r1, [sp, #0x8]
;     cookie = HwiP_disable();
700a3ec8: f00a ebd2    	blx	0x700ae670 <HwiP_disable> @ imm = #0xa7a4
700a3ecc: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventHandle->prevEvent)
700a3ece: 9802         	ldr	r0, [sp, #0x8]
700a3ed0: 6e00         	ldr	r0, [r0, #0x60]
700a3ed2: b128         	cbz	r0, 0x700a3ee0 <Udma_eventFreeResource+0x20> @ imm = #0xa
700a3ed4: e7ff         	b	0x700a3ed6 <Udma_eventFreeResource+0x16> @ imm = #-0x2
;         eventHandle->prevEvent->nextEvent = eventHandle->nextEvent;
700a3ed6: 9902         	ldr	r1, [sp, #0x8]
700a3ed8: 6dc8         	ldr	r0, [r1, #0x5c]
700a3eda: 6e09         	ldr	r1, [r1, #0x60]
700a3edc: 65c8         	str	r0, [r1, #0x5c]
;     }
700a3ede: e7ff         	b	0x700a3ee0 <Udma_eventFreeResource+0x20> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->nextEvent)
700a3ee0: 9802         	ldr	r0, [sp, #0x8]
700a3ee2: 6dc0         	ldr	r0, [r0, #0x5c]
700a3ee4: b128         	cbz	r0, 0x700a3ef2 <Udma_eventFreeResource+0x32> @ imm = #0xa
700a3ee6: e7ff         	b	0x700a3ee8 <Udma_eventFreeResource+0x28> @ imm = #-0x2
;         eventHandle->nextEvent->prevEvent = eventHandle->prevEvent;
700a3ee8: 9802         	ldr	r0, [sp, #0x8]
700a3eea: 6dc1         	ldr	r1, [r0, #0x5c]
700a3eec: 6e00         	ldr	r0, [r0, #0x60]
700a3eee: 6608         	str	r0, [r1, #0x60]
;     }
700a3ef0: e7ff         	b	0x700a3ef2 <Udma_eventFreeResource+0x32> @ imm = #-0x2
;     HwiP_restore(cookie);
700a3ef2: 9801         	ldr	r0, [sp, #0x4]
700a3ef4: f00a ebdc    	blx	0x700ae6b0 <HwiP_restore> @ imm = #0xa7b8
;     if(NULL_PTR != eventHandle->hwiHandle)
700a3ef8: 9802         	ldr	r0, [sp, #0x8]
700a3efa: 6e40         	ldr	r0, [r0, #0x64]
700a3efc: b140         	cbz	r0, 0x700a3f10 <Udma_eventFreeResource+0x50> @ imm = #0x10
700a3efe: e7ff         	b	0x700a3f00 <Udma_eventFreeResource+0x40> @ imm = #-0x2
;         HwiP_destruct(&eventHandle->hwiObject);
700a3f00: 9802         	ldr	r0, [sp, #0x8]
700a3f02: 3068         	adds	r0, #0x68
700a3f04: f009 ffc4    	bl	0x700ade90 <HwiP_destruct> @ imm = #0x9f88
;         eventHandle->hwiHandle = NULL_PTR;
700a3f08: 9902         	ldr	r1, [sp, #0x8]
700a3f0a: 2000         	movs	r0, #0x0
700a3f0c: 6648         	str	r0, [r1, #0x64]
;     }
700a3f0e: e7ff         	b	0x700a3f10 <Udma_eventFreeResource+0x50> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
700a3f10: 9802         	ldr	r0, [sp, #0x8]
700a3f12: 6d40         	ldr	r0, [r0, #0x54]
700a3f14: f510 3f80    	cmn.w	r0, #0x10000
700a3f18: d00d         	beq	0x700a3f36 <Udma_eventFreeResource+0x76> @ imm = #0x1a
700a3f1a: e7ff         	b	0x700a3f1c <Udma_eventFreeResource+0x5c> @ imm = #-0x2
;         Udma_rmFreeIrIntr(eventHandle->irIntrNum, drvHandle);
700a3f1c: 9802         	ldr	r0, [sp, #0x8]
700a3f1e: 6d40         	ldr	r0, [r0, #0x54]
700a3f20: 9903         	ldr	r1, [sp, #0xc]
700a3f22: f005 fe5d    	bl	0x700a9be0 <Udma_rmFreeIrIntr> @ imm = #0x5cba
;         eventHandle->irIntrNum = UDMA_INTR_INVALID;
700a3f26: 9902         	ldr	r1, [sp, #0x8]
700a3f28: 2000         	movs	r0, #0x0
700a3f2a: f6cf 70ff    	movt	r0, #0xffff
700a3f2e: 6548         	str	r0, [r1, #0x54]
;         eventHandle->coreIntrNum = UDMA_INTR_INVALID;
700a3f30: 9902         	ldr	r1, [sp, #0x8]
700a3f32: 6588         	str	r0, [r1, #0x58]
;     }
700a3f34: e7ff         	b	0x700a3f36 <Udma_eventFreeResource+0x76> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->globalEvent)
700a3f36: 9802         	ldr	r0, [sp, #0x8]
700a3f38: 6c80         	ldr	r0, [r0, #0x48]
700a3f3a: f64f 71ff    	movw	r1, #0xffff
700a3f3e: 4288         	cmp	r0, r1
700a3f40: d00e         	beq	0x700a3f60 <Udma_eventFreeResource+0xa0> @ imm = #0x1c
700a3f42: e7ff         	b	0x700a3f44 <Udma_eventFreeResource+0x84> @ imm = #-0x2
;         Udma_eventResetSteering(drvHandle, eventHandle);
700a3f44: 9803         	ldr	r0, [sp, #0xc]
700a3f46: 9902         	ldr	r1, [sp, #0x8]
700a3f48: f008 fe92    	bl	0x700acc70 <Udma_eventResetSteering> @ imm = #0x8d24
;         Udma_rmFreeEvent(eventHandle->globalEvent, drvHandle);
700a3f4c: 9802         	ldr	r0, [sp, #0x8]
700a3f4e: 6c80         	ldr	r0, [r0, #0x48]
700a3f50: 9903         	ldr	r1, [sp, #0xc]
700a3f52: f005 fe0d    	bl	0x700a9b70 <Udma_rmFreeEvent> @ imm = #0x5c1a
;         eventHandle->globalEvent = UDMA_EVENT_INVALID;
700a3f56: 9902         	ldr	r1, [sp, #0x8]
700a3f58: f64f 70ff    	movw	r0, #0xffff
700a3f5c: 6488         	str	r0, [r1, #0x48]
;     }
700a3f5e: e7ff         	b	0x700a3f60 <Udma_eventFreeResource+0xa0> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
700a3f60: 9802         	ldr	r0, [sp, #0x8]
700a3f62: 6d00         	ldr	r0, [r0, #0x50]
700a3f64: f64f 71ff    	movw	r1, #0xffff
700a3f68: 4288         	cmp	r0, r1
700a3f6a: d00a         	beq	0x700a3f82 <Udma_eventFreeResource+0xc2> @ imm = #0x14
700a3f6c: e7ff         	b	0x700a3f6e <Udma_eventFreeResource+0xae> @ imm = #-0x2
;         Udma_rmFreeVintrBit(eventHandle->vintrBitNum, drvHandle, eventHandle);
700a3f6e: 9a02         	ldr	r2, [sp, #0x8]
700a3f70: 6d10         	ldr	r0, [r2, #0x50]
700a3f72: 9903         	ldr	r1, [sp, #0xc]
700a3f74: f004 f97c    	bl	0x700a8270 <Udma_rmFreeVintrBit> @ imm = #0x42f8
;         eventHandle->vintrBitNum = UDMA_EVENT_INVALID;
700a3f78: 9902         	ldr	r1, [sp, #0x8]
700a3f7a: f64f 70ff    	movw	r0, #0xffff
700a3f7e: 6508         	str	r0, [r1, #0x50]
;     }
700a3f80: e7ff         	b	0x700a3f82 <Udma_eventFreeResource+0xc2> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrNum)
700a3f82: 9802         	ldr	r0, [sp, #0x8]
700a3f84: 6cc0         	ldr	r0, [r0, #0x4c]
700a3f86: f64f 71ff    	movw	r1, #0xffff
700a3f8a: 4288         	cmp	r0, r1
700a3f8c: d00a         	beq	0x700a3fa4 <Udma_eventFreeResource+0xe4> @ imm = #0x14
700a3f8e: e7ff         	b	0x700a3f90 <Udma_eventFreeResource+0xd0> @ imm = #-0x2
;         Udma_rmFreeVintr(eventHandle->vintrNum, drvHandle);
700a3f90: 9802         	ldr	r0, [sp, #0x8]
700a3f92: 6cc0         	ldr	r0, [r0, #0x4c]
700a3f94: 9903         	ldr	r1, [sp, #0xc]
700a3f96: f005 fe5b    	bl	0x700a9c50 <Udma_rmFreeVintr> @ imm = #0x5cb6
;         eventHandle->vintrNum = UDMA_EVENT_INVALID;
700a3f9a: 9902         	ldr	r1, [sp, #0x8]
700a3f9c: f64f 70ff    	movw	r0, #0xffff
700a3fa0: 64c8         	str	r0, [r1, #0x4c]
;     }
700a3fa2: e7ff         	b	0x700a3fa4 <Udma_eventFreeResource+0xe4> @ imm = #-0x2
;     return;
700a3fa4: b004         	add	sp, #0x10
700a3fa6: bd80         	pop	{r7, pc}
		...

700a3fb0 <DebugP_memTraceLogWriterPutLine>:
; {
700a3fb0: b580         	push	{r7, lr}
700a3fb2: b08a         	sub	sp, #0x28
700a3fb4: 9009         	str	r0, [sp, #0x24]
700a3fb6: f8ad 1022    	strh.w	r1, [sp, #0x22]
700a3fba: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a3fbc: 9007         	str	r0, [sp, #0x1c]
;     if (gDebugMemLogSize == 0U)
700a3fbe: f240 40b8    	movw	r0, #0x4b8
700a3fc2: f2c7 000b    	movt	r0, #0x700b
700a3fc6: 6800         	ldr	r0, [r0]
700a3fc8: b920         	cbnz	r0, 0x700a3fd4 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #0x8
700a3fca: e7ff         	b	0x700a3fcc <DebugP_memTraceLogWriterPutLine+0x1c> @ imm = #-0x2
700a3fcc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a3fd0: 9007         	str	r0, [sp, #0x1c]
;     }
700a3fd2: e7ff         	b	0x700a3fd4 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a3fd4: 9807         	ldr	r0, [sp, #0x1c]
700a3fd6: 2800         	cmp	r0, #0x0
700a3fd8: d15a         	bne	0x700a4090 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #0xb4
700a3fda: e7ff         	b	0x700a3fdc <DebugP_memTraceLogWriterPutLine+0x2c> @ imm = #-0x2
;         wr_idx = gDebugMemLogWriteIndex;
700a3fdc: f240 40bc    	movw	r0, #0x4bc
700a3fe0: f2c7 000b    	movt	r0, #0x700b
700a3fe4: 6800         	ldr	r0, [r0]
700a3fe6: 9006         	str	r0, [sp, #0x18]
;         dst = (uint8_t*)&gDebugMemLog[0];
700a3fe8: f241 0080    	movw	r0, #0x1080
700a3fec: f2c7 0008    	movt	r0, #0x7008
700a3ff0: 9003         	str	r0, [sp, #0xc]
700a3ff2: 2000         	movs	r0, #0x0
;         idx = 0;
700a3ff4: 9004         	str	r0, [sp, #0x10]
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a3ff6: 9005         	str	r0, [sp, #0x14]
700a3ff8: e7ff         	b	0x700a3ffa <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x2
700a3ffa: 9805         	ldr	r0, [sp, #0x14]
700a3ffc: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a4000: 4288         	cmp	r0, r1
700a4002: d233         	bhs	0x700a406c <DebugP_memTraceLogWriterPutLine+0xbc> @ imm = #0x66
700a4004: e7ff         	b	0x700a4006 <DebugP_memTraceLogWriterPutLine+0x56> @ imm = #-0x2
;             dst[wr_idx] = buf[idx];
700a4006: 9809         	ldr	r0, [sp, #0x24]
700a4008: 9904         	ldr	r1, [sp, #0x10]
700a400a: 5c40         	ldrb	r0, [r0, r1]
700a400c: 9903         	ldr	r1, [sp, #0xc]
700a400e: 9a06         	ldr	r2, [sp, #0x18]
700a4010: 5488         	strb	r0, [r1, r2]
;             wr_idx = wr_idx + 1U;
700a4012: 9806         	ldr	r0, [sp, #0x18]
700a4014: 3001         	adds	r0, #0x1
700a4016: 9006         	str	r0, [sp, #0x18]
;             if (wr_idx >= gDebugMemLogSize)
700a4018: 9806         	ldr	r0, [sp, #0x18]
700a401a: f240 41b8    	movw	r1, #0x4b8
700a401e: f2c7 010b    	movt	r1, #0x700b
700a4022: 6809         	ldr	r1, [r1]
700a4024: 4288         	cmp	r0, r1
700a4026: d319         	blo	0x700a405c <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #0x32
700a4028: e7ff         	b	0x700a402a <DebugP_memTraceLogWriterPutLine+0x7a> @ imm = #-0x2
;                         &dst[gDebugMemLogWriteIndex],
700a402a: 9803         	ldr	r0, [sp, #0xc]
700a402c: f240 42bc    	movw	r2, #0x4bc
700a4030: f2c7 020b    	movt	r2, #0x700b
700a4034: 9202         	str	r2, [sp, #0x8]
700a4036: 6811         	ldr	r1, [r2]
700a4038: 4408         	add	r0, r1
;                         (wr_idx - gDebugMemLogWriteIndex),
700a403a: 9906         	ldr	r1, [sp, #0x18]
700a403c: 6812         	ldr	r2, [r2]
700a403e: 1a89         	subs	r1, r1, r2
700a4040: 220f         	movs	r2, #0xf
;                 CacheP_wbInv(
700a4042: f00a ec0e    	blx	0x700ae860 <CacheP_wbInv> @ imm = #0xa81c
700a4046: 9902         	ldr	r1, [sp, #0x8]
700a4048: 2000         	movs	r0, #0x0
;                 wr_idx = 0;
700a404a: 9006         	str	r0, [sp, #0x18]
;                 gDebugMemLogWriteIndex = 0;
700a404c: 6008         	str	r0, [r1]
;                 gDebugMemLogIsWrapAround = 1;
700a404e: f240 41b4    	movw	r1, #0x4b4
700a4052: f2c7 010b    	movt	r1, #0x700b
700a4056: 2001         	movs	r0, #0x1
700a4058: 6008         	str	r0, [r1]
;             }
700a405a: e7ff         	b	0x700a405c <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #-0x2
;             idx ++;
700a405c: 9804         	ldr	r0, [sp, #0x10]
700a405e: 3001         	adds	r0, #0x1
700a4060: 9004         	str	r0, [sp, #0x10]
;         }
700a4062: e7ff         	b	0x700a4064 <DebugP_memTraceLogWriterPutLine+0xb4> @ imm = #-0x2
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a4064: 9805         	ldr	r0, [sp, #0x14]
700a4066: 3001         	adds	r0, #0x1
700a4068: 9005         	str	r0, [sp, #0x14]
700a406a: e7c6         	b	0x700a3ffa <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x74
;                 &dst[gDebugMemLogWriteIndex],
700a406c: 9803         	ldr	r0, [sp, #0xc]
700a406e: f240 42bc    	movw	r2, #0x4bc
700a4072: f2c7 020b    	movt	r2, #0x700b
700a4076: 9201         	str	r2, [sp, #0x4]
700a4078: 6811         	ldr	r1, [r2]
700a407a: 4408         	add	r0, r1
;                 (wr_idx - gDebugMemLogWriteIndex),
700a407c: 9906         	ldr	r1, [sp, #0x18]
700a407e: 6812         	ldr	r2, [r2]
700a4080: 1a89         	subs	r1, r1, r2
700a4082: 220f         	movs	r2, #0xf
;         CacheP_wbInv(
700a4084: f00a ebec    	blx	0x700ae860 <CacheP_wbInv> @ imm = #0xa7d8
700a4088: 9901         	ldr	r1, [sp, #0x4]
;         gDebugMemLogWriteIndex = wr_idx;
700a408a: 9806         	ldr	r0, [sp, #0x18]
700a408c: 6008         	str	r0, [r1]
;     }
700a408e: e7ff         	b	0x700a4090 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #-0x2
; }
700a4090: b00a         	add	sp, #0x28
700a4092: bd80         	pop	{r7, pc}
		...

700a40a0 <Sciclient_rmIrqGetNode>:
; {
700a40a0: b089         	sub	sp, #0x24
700a40a2: f8ad 0022    	strh.w	r0, [sp, #0x22]
700a40a6: 9107         	str	r1, [sp, #0x1c]
700a40a8: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700a40ac: 9006         	str	r0, [sp, #0x18]
700a40ae: 2000         	movs	r0, #0x0
;     lower = 0u;
700a40b0: 9004         	str	r0, [sp, #0x10]
;     upper = gRmIrqTreeCount - 1u;
700a40b2: f240 1144    	movw	r1, #0x144
700a40b6: f2c7 010b    	movt	r1, #0x700b
700a40ba: 680a         	ldr	r2, [r1]
700a40bc: 3a01         	subs	r2, #0x1
700a40be: 9203         	str	r2, [sp, #0xc]
;     count = gRmIrqTreeCount;
700a40c0: 6809         	ldr	r1, [r1]
700a40c2: f8ad 1006    	strh.w	r1, [sp, #0x6]
;     *found_n = NULL;
700a40c6: 9907         	ldr	r1, [sp, #0x1c]
700a40c8: 6008         	str	r0, [r1]
;     while ((lower <= upper) &&
700a40ca: e7ff         	b	0x700a40cc <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0x2
700a40cc: 9904         	ldr	r1, [sp, #0x10]
700a40ce: 9a03         	ldr	r2, [sp, #0xc]
700a40d0: 2000         	movs	r0, #0x0
700a40d2: 4291         	cmp	r1, r2
700a40d4: 9000         	str	r0, [sp]
700a40d6: d81d         	bhi	0x700a4114 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x3a
700a40d8: e7ff         	b	0x700a40da <Sciclient_rmIrqGetNode+0x3a> @ imm = #-0x2
;            (lower < gRmIrqTreeCount) &&
700a40da: 9904         	ldr	r1, [sp, #0x10]
700a40dc: f240 1044    	movw	r0, #0x144
700a40e0: f2c7 000b    	movt	r0, #0x700b
700a40e4: 6802         	ldr	r2, [r0]
700a40e6: 2000         	movs	r0, #0x0
700a40e8: 4291         	cmp	r1, r2
700a40ea: 9000         	str	r0, [sp]
700a40ec: d212         	bhs	0x700a4114 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x24
700a40ee: e7ff         	b	0x700a40f0 <Sciclient_rmIrqGetNode+0x50> @ imm = #-0x2
;            (upper < gRmIrqTreeCount) &&
700a40f0: 9903         	ldr	r1, [sp, #0xc]
700a40f2: f240 1044    	movw	r0, #0x144
700a40f6: f2c7 000b    	movt	r0, #0x700b
700a40fa: 6802         	ldr	r2, [r0]
700a40fc: 2000         	movs	r0, #0x0
700a40fe: 4291         	cmp	r1, r2
700a4100: 9000         	str	r0, [sp]
700a4102: d207         	bhs	0x700a4114 <Sciclient_rmIrqGetNode+0x74> @ imm = #0xe
700a4104: e7ff         	b	0x700a4106 <Sciclient_rmIrqGetNode+0x66> @ imm = #-0x2
;            (count > 0u)) {
700a4106: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a410a: 2800         	cmp	r0, #0x0
700a410c: bf18         	it	ne
700a410e: 2001         	movne	r0, #0x1
700a4110: 9000         	str	r0, [sp]
700a4112: e7ff         	b	0x700a4114 <Sciclient_rmIrqGetNode+0x74> @ imm = #-0x2
700a4114: 9800         	ldr	r0, [sp]
;     while ((lower <= upper) &&
700a4116: 07c0         	lsls	r0, r0, #0x1f
700a4118: b380         	cbz	r0, 0x700a417c <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x60
700a411a: e7ff         	b	0x700a411c <Sciclient_rmIrqGetNode+0x7c> @ imm = #-0x2
;         current = (lower + upper) / (2u);
700a411c: 9804         	ldr	r0, [sp, #0x10]
700a411e: 9903         	ldr	r1, [sp, #0xc]
700a4120: 4408         	add	r0, r1
700a4122: 0840         	lsrs	r0, r0, #0x1
700a4124: 9002         	str	r0, [sp, #0x8]
;         cur_n = (const struct Sciclient_rmIrqNode *) gRmIrqTree[current];
700a4126: 9902         	ldr	r1, [sp, #0x8]
700a4128: f24f 40cc    	movw	r0, #0xf4cc
700a412c: f2c7 000a    	movt	r0, #0x700a
700a4130: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a4134: 9005         	str	r0, [sp, #0x14]
;         if (cur_n->id == id) {
700a4136: 9805         	ldr	r0, [sp, #0x14]
700a4138: 8800         	ldrh	r0, [r0]
700a413a: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a413e: 4288         	cmp	r0, r1
700a4140: d106         	bne	0x700a4150 <Sciclient_rmIrqGetNode+0xb0> @ imm = #0xc
700a4142: e7ff         	b	0x700a4144 <Sciclient_rmIrqGetNode+0xa4> @ imm = #-0x2
;             *found_n = cur_n;
700a4144: 9805         	ldr	r0, [sp, #0x14]
700a4146: 9907         	ldr	r1, [sp, #0x1c]
700a4148: 6008         	str	r0, [r1]
700a414a: 2000         	movs	r0, #0x0
;             r = SystemP_SUCCESS;
700a414c: 9006         	str	r0, [sp, #0x18]
;             break;
700a414e: e015         	b	0x700a417c <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x2a
;             if (cur_n->id < id) {
700a4150: 9805         	ldr	r0, [sp, #0x14]
700a4152: 8800         	ldrh	r0, [r0]
700a4154: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a4158: 4288         	cmp	r0, r1
700a415a: da04         	bge	0x700a4166 <Sciclient_rmIrqGetNode+0xc6> @ imm = #0x8
700a415c: e7ff         	b	0x700a415e <Sciclient_rmIrqGetNode+0xbe> @ imm = #-0x2
;                 lower = current + (1u);
700a415e: 9802         	ldr	r0, [sp, #0x8]
700a4160: 3001         	adds	r0, #0x1
700a4162: 9004         	str	r0, [sp, #0x10]
;             } else {
700a4164: e003         	b	0x700a416e <Sciclient_rmIrqGetNode+0xce> @ imm = #0x6
;                 upper = current - (1u);
700a4166: 9802         	ldr	r0, [sp, #0x8]
700a4168: 3801         	subs	r0, #0x1
700a416a: 9003         	str	r0, [sp, #0xc]
700a416c: e7ff         	b	0x700a416e <Sciclient_rmIrqGetNode+0xce> @ imm = #-0x2
700a416e: e7ff         	b	0x700a4170 <Sciclient_rmIrqGetNode+0xd0> @ imm = #-0x2
;         count--;
700a4170: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a4174: 3801         	subs	r0, #0x1
700a4176: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     while ((lower <= upper) &&
700a417a: e7a7         	b	0x700a40cc <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0xb2
;     return r;
700a417c: 9806         	ldr	r0, [sp, #0x18]
700a417e: b009         	add	sp, #0x24
700a4180: 4770         	bx	lr
		...
700a418e: 0000         	movs	r0, r0

700a4190 <vTaskGetInfo>:
;                   BaseType_t xGetFreeStackSpace, eTaskState eState) {
700a4190: b580         	push	{r7, lr}
700a4192: b086         	sub	sp, #0x18
700a4194: 9005         	str	r0, [sp, #0x14]
700a4196: 9104         	str	r1, [sp, #0x10]
700a4198: 9203         	str	r2, [sp, #0xc]
700a419a: f88d 300b    	strb.w	r3, [sp, #0xb]
;   pxTCB = prvGetTCBFromHandle(xTask);
700a419e: 9805         	ldr	r0, [sp, #0x14]
700a41a0: b938         	cbnz	r0, 0x700a41b2 <vTaskGetInfo+0x22> @ imm = #0xe
700a41a2: e7ff         	b	0x700a41a4 <vTaskGetInfo+0x14> @ imm = #-0x2
700a41a4: f240 40dc    	movw	r0, #0x4dc
700a41a8: f2c7 000b    	movt	r0, #0x700b
700a41ac: 6800         	ldr	r0, [r0]
700a41ae: 9000         	str	r0, [sp]
700a41b0: e002         	b	0x700a41b8 <vTaskGetInfo+0x28> @ imm = #0x4
700a41b2: 9805         	ldr	r0, [sp, #0x14]
700a41b4: 9000         	str	r0, [sp]
700a41b6: e7ff         	b	0x700a41b8 <vTaskGetInfo+0x28> @ imm = #-0x2
700a41b8: 9800         	ldr	r0, [sp]
700a41ba: 9001         	str	r0, [sp, #0x4]
;   pxTaskStatus->xHandle = (TaskHandle_t)pxTCB;
700a41bc: 9801         	ldr	r0, [sp, #0x4]
700a41be: 9904         	ldr	r1, [sp, #0x10]
700a41c0: 6008         	str	r0, [r1]
;   pxTaskStatus->pcTaskName = (const char *)&(pxTCB->pcTaskName[0]);
700a41c2: 9801         	ldr	r0, [sp, #0x4]
700a41c4: 3034         	adds	r0, #0x34
700a41c6: 9904         	ldr	r1, [sp, #0x10]
700a41c8: 6048         	str	r0, [r1, #0x4]
;   pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
700a41ca: 9801         	ldr	r0, [sp, #0x4]
700a41cc: 6ac0         	ldr	r0, [r0, #0x2c]
700a41ce: 9904         	ldr	r1, [sp, #0x10]
700a41d0: 6108         	str	r0, [r1, #0x10]
;   pxTaskStatus->pxStackBase = pxTCB->pxStack;
700a41d2: 9801         	ldr	r0, [sp, #0x4]
700a41d4: 6b00         	ldr	r0, [r0, #0x30]
700a41d6: 9904         	ldr	r1, [sp, #0x10]
700a41d8: 61c8         	str	r0, [r1, #0x1c]
;   pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
700a41da: 9801         	ldr	r0, [sp, #0x4]
700a41dc: 6d80         	ldr	r0, [r0, #0x58]
700a41de: 9904         	ldr	r1, [sp, #0x10]
700a41e0: 6088         	str	r0, [r1, #0x8]
;     pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
700a41e2: 9801         	ldr	r0, [sp, #0x4]
700a41e4: 6e00         	ldr	r0, [r0, #0x60]
700a41e6: 9904         	ldr	r1, [sp, #0x10]
700a41e8: 6148         	str	r0, [r1, #0x14]
;     pxTaskStatus->ulRunTimeCounter = 0;
700a41ea: 9904         	ldr	r1, [sp, #0x10]
700a41ec: 2000         	movs	r0, #0x0
700a41ee: 6188         	str	r0, [r1, #0x18]
;   if (eState != eInvalid) {
700a41f0: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a41f4: 2805         	cmp	r0, #0x5
700a41f6: d025         	beq	0x700a4244 <vTaskGetInfo+0xb4> @ imm = #0x4a
700a41f8: e7ff         	b	0x700a41fa <vTaskGetInfo+0x6a> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a41fa: 9801         	ldr	r0, [sp, #0x4]
700a41fc: f240 41dc    	movw	r1, #0x4dc
700a4200: f2c7 010b    	movt	r1, #0x700b
700a4204: 6809         	ldr	r1, [r1]
700a4206: 4288         	cmp	r0, r1
700a4208: d104         	bne	0x700a4214 <vTaskGetInfo+0x84> @ imm = #0x8
700a420a: e7ff         	b	0x700a420c <vTaskGetInfo+0x7c> @ imm = #-0x2
;       pxTaskStatus->eCurrentState = eRunning;
700a420c: 9904         	ldr	r1, [sp, #0x10]
700a420e: 2000         	movs	r0, #0x0
700a4210: 7308         	strb	r0, [r1, #0xc]
;     } else {
700a4212: e016         	b	0x700a4242 <vTaskGetInfo+0xb2> @ imm = #0x2c
;       pxTaskStatus->eCurrentState = eState;
700a4214: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a4218: 9904         	ldr	r1, [sp, #0x10]
700a421a: 7308         	strb	r0, [r1, #0xc]
;         if (eState == eSuspended) {
700a421c: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a4220: 2803         	cmp	r0, #0x3
700a4222: d10d         	bne	0x700a4240 <vTaskGetInfo+0xb0> @ imm = #0x1a
700a4224: e7ff         	b	0x700a4226 <vTaskGetInfo+0x96> @ imm = #-0x2
;           vTaskSuspendAll();
700a4226: f009 fb73    	bl	0x700ad910 <vTaskSuspendAll> @ imm = #0x96e6
;             if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a422a: 9801         	ldr	r0, [sp, #0x4]
700a422c: 6a80         	ldr	r0, [r0, #0x28]
700a422e: b120         	cbz	r0, 0x700a423a <vTaskGetInfo+0xaa> @ imm = #0x8
700a4230: e7ff         	b	0x700a4232 <vTaskGetInfo+0xa2> @ imm = #-0x2
;               pxTaskStatus->eCurrentState = eBlocked;
700a4232: 9904         	ldr	r1, [sp, #0x10]
700a4234: 2002         	movs	r0, #0x2
700a4236: 7308         	strb	r0, [r1, #0xc]
;             }
700a4238: e7ff         	b	0x700a423a <vTaskGetInfo+0xaa> @ imm = #-0x2
;           (void)xTaskResumeAll();
700a423a: f7fc fcb9    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0x368e
;         }
700a423e: e7ff         	b	0x700a4240 <vTaskGetInfo+0xb0> @ imm = #-0x2
700a4240: e7ff         	b	0x700a4242 <vTaskGetInfo+0xb2> @ imm = #-0x2
;   } else {
700a4242: e005         	b	0x700a4250 <vTaskGetInfo+0xc0> @ imm = #0xa
;     pxTaskStatus->eCurrentState = eTaskGetState(pxTCB);
700a4244: 9801         	ldr	r0, [sp, #0x4]
700a4246: f7ff fc4b    	bl	0x700a3ae0 <eTaskGetState> @ imm = #-0x76a
700a424a: 9904         	ldr	r1, [sp, #0x10]
700a424c: 7308         	strb	r0, [r1, #0xc]
700a424e: e7ff         	b	0x700a4250 <vTaskGetInfo+0xc0> @ imm = #-0x2
;   if (xGetFreeStackSpace != pdFALSE) {
700a4250: 9803         	ldr	r0, [sp, #0xc]
700a4252: b138         	cbz	r0, 0x700a4264 <vTaskGetInfo+0xd4> @ imm = #0xe
700a4254: e7ff         	b	0x700a4256 <vTaskGetInfo+0xc6> @ imm = #-0x2
;           prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
700a4256: 9801         	ldr	r0, [sp, #0x4]
700a4258: 6b00         	ldr	r0, [r0, #0x30]
700a425a: f008 fae1    	bl	0x700ac820 <prvTaskCheckFreeStackSpace> @ imm = #0x85c2
;       pxTaskStatus->usStackHighWaterMark =
700a425e: 9904         	ldr	r1, [sp, #0x10]
700a4260: 6208         	str	r0, [r1, #0x20]
;   } else {
700a4262: e003         	b	0x700a426c <vTaskGetInfo+0xdc> @ imm = #0x6
;     pxTaskStatus->usStackHighWaterMark = 0;
700a4264: 9904         	ldr	r1, [sp, #0x10]
700a4266: 2000         	movs	r0, #0x0
700a4268: 6208         	str	r0, [r1, #0x20]
700a426a: e7ff         	b	0x700a426c <vTaskGetInfo+0xdc> @ imm = #-0x2
; }
700a426c: b006         	add	sp, #0x18
700a426e: bd80         	pop	{r7, pc}

700a4270 <Sciclient_waitForMessage>:
; {
700a4270: b580         	push	{r7, lr}
700a4272: b088         	sub	sp, #0x20
700a4274: 9007         	str	r0, [sp, #0x1c]
700a4276: 9106         	str	r1, [sp, #0x18]
700a4278: 9205         	str	r2, [sp, #0x14]
700a427a: f88d 3013    	strb.w	r3, [sp, #0x13]
;     uint32_t timeToWait = timeout;
700a427e: 9806         	ldr	r0, [sp, #0x18]
700a4280: 9002         	str	r0, [sp, #0x8]
700a4282: 2200         	movs	r2, #0x0
;     int32_t status = SystemP_SUCCESS;
700a4284: 9201         	str	r2, [sp, #0x4]
;                                         &gSciclientSecProxyCfg, rxThread, 0U)
700a4286: 9907         	ldr	r1, [sp, #0x1c]
;         (struct tisci_header *)(CSL_secProxyGetDataAddr(
700a4288: f240 30c8    	movw	r0, #0x3c8
700a428c: f2c7 000b    	movt	r0, #0x700b
700a4290: f009 f826    	bl	0x700ad2e0 <CSL_secProxyGetDataAddr> @ imm = #0x904c
;                                 + ((uintptr_t) gSecHeaderSizeWords * (uintptr_t) 4U));
700a4294: f240 5130    	movw	r1, #0x530
700a4298: f2c7 010b    	movt	r1, #0x700b
700a429c: 7809         	ldrb	r1, [r1]
700a429e: eb00 0081    	add.w	r0, r0, r1, lsl #2
;     pLocalRespHdr =
700a42a2: 9003         	str	r0, [sp, #0xc]
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a42a4: e7ff         	b	0x700a42a6 <Sciclient_waitForMessage+0x36> @ imm = #-0x2
700a42a6: 9807         	ldr	r0, [sp, #0x1c]
700a42a8: f009 f8ba    	bl	0x700ad420 <Sciclient_secProxyThreadStatusReg> @ imm = #0x9174
700a42ac: f009 fb68    	bl	0x700ad980 <CSL_REG32_RD_RAW> @ imm = #0x96d0
700a42b0: b2c0         	uxtb	r0, r0
;             CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount) <= 0U)
700a42b2: 9905         	ldr	r1, [sp, #0x14]
700a42b4: 1a40         	subs	r0, r0, r1
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a42b6: b960         	cbnz	r0, 0x700a42d2 <Sciclient_waitForMessage+0x62> @ imm = #0x18
700a42b8: e7ff         	b	0x700a42ba <Sciclient_waitForMessage+0x4a> @ imm = #-0x2
;         if (timeToWait != 0U)
700a42ba: 9802         	ldr	r0, [sp, #0x8]
700a42bc: b120         	cbz	r0, 0x700a42c8 <Sciclient_waitForMessage+0x58> @ imm = #0x8
700a42be: e7ff         	b	0x700a42c0 <Sciclient_waitForMessage+0x50> @ imm = #-0x2
;             timeToWait--;
700a42c0: 9802         	ldr	r0, [sp, #0x8]
700a42c2: 3801         	subs	r0, #0x1
700a42c4: 9002         	str	r0, [sp, #0x8]
;         }
700a42c6: e003         	b	0x700a42d0 <Sciclient_waitForMessage+0x60> @ imm = #0x6
700a42c8: f06f 0001    	mvn	r0, #0x1
;             status = SystemP_TIMEOUT;
700a42cc: 9001         	str	r0, [sp, #0x4]
;             break;
700a42ce: e000         	b	0x700a42d2 <Sciclient_waitForMessage+0x62> @ imm = #0x0
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a42d0: e7e9         	b	0x700a42a6 <Sciclient_waitForMessage+0x36> @ imm = #-0x2e
;     if (status == SystemP_SUCCESS)
700a42d2: 9801         	ldr	r0, [sp, #0x4]
700a42d4: bbc0         	cbnz	r0, 0x700a4348 <Sciclient_waitForMessage+0xd8> @ imm = #0x70
700a42d6: e7ff         	b	0x700a42d8 <Sciclient_waitForMessage+0x68> @ imm = #-0x2
700a42d8: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700a42dc: 9001         	str	r0, [sp, #0x4]
;         timeToWait =  timeout;
700a42de: 9806         	ldr	r0, [sp, #0x18]
700a42e0: 9002         	str	r0, [sp, #0x8]
;         while(1)
700a42e2: e7ff         	b	0x700a42e4 <Sciclient_waitForMessage+0x74> @ imm = #-0x2
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a42e4: 9807         	ldr	r0, [sp, #0x1c]
700a42e6: f009 f89b    	bl	0x700ad420 <Sciclient_secProxyThreadStatusReg> @ imm = #0x9136
700a42ea: f009 fb49    	bl	0x700ad980 <CSL_REG32_RD_RAW> @ imm = #0x9692
700a42ee: b2c0         	uxtb	r0, r0
;                     CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount;
700a42f0: 9905         	ldr	r1, [sp, #0x14]
700a42f2: 1a40         	subs	r0, r0, r1
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a42f4: 9000         	str	r0, [sp]
;             if (pLocalRespHdr->seq == (uint32_t)localSeqId)
700a42f6: 9803         	ldr	r0, [sp, #0xc]
700a42f8: 78c0         	ldrb	r0, [r0, #0x3]
700a42fa: f89d 1013    	ldrb.w	r1, [sp, #0x13]
700a42fe: 4288         	cmp	r0, r1
700a4300: d103         	bne	0x700a430a <Sciclient_waitForMessage+0x9a> @ imm = #0x6
700a4302: e7ff         	b	0x700a4304 <Sciclient_waitForMessage+0x94> @ imm = #-0x2
700a4304: 2000         	movs	r0, #0x0
;                 status = SystemP_SUCCESS;
700a4306: 9001         	str	r0, [sp, #0x4]
;                 break;
700a4308: e01d         	b	0x700a4346 <Sciclient_waitForMessage+0xd6> @ imm = #0x3a
;             if (numCurrentMsgs > 1U)
700a430a: 9800         	ldr	r0, [sp]
700a430c: 2802         	cmp	r0, #0x2
700a430e: d30e         	blo	0x700a432e <Sciclient_waitForMessage+0xbe> @ imm = #0x1c
700a4310: e7ff         	b	0x700a4312 <Sciclient_waitForMessage+0xa2> @ imm = #-0x2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a4312: 9807         	ldr	r0, [sp, #0x1c]
;                                             (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a4314: f240 4138    	movw	r1, #0x438
700a4318: f2c7 010b    	movt	r1, #0x700b
700a431c: 694a         	ldr	r2, [r1, #0x14]
700a431e: f04f 31ff    	mov.w	r1, #0xffffffff
700a4322: eb01 0192    	add.w	r1, r1, r2, lsr #2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a4326: b2c9         	uxtb	r1, r1
700a4328: f008 fa1a    	bl	0x700ac760 <Sciclient_secProxyReadThread32> @ imm = #0x8434
;             }
700a432c: e7ff         	b	0x700a432e <Sciclient_waitForMessage+0xbe> @ imm = #-0x2
;             if (timeToWait != 0U)
700a432e: 9802         	ldr	r0, [sp, #0x8]
700a4330: b120         	cbz	r0, 0x700a433c <Sciclient_waitForMessage+0xcc> @ imm = #0x8
700a4332: e7ff         	b	0x700a4334 <Sciclient_waitForMessage+0xc4> @ imm = #-0x2
;                 timeToWait--;
700a4334: 9802         	ldr	r0, [sp, #0x8]
700a4336: 3801         	subs	r0, #0x1
700a4338: 9002         	str	r0, [sp, #0x8]
;             }
700a433a: e003         	b	0x700a4344 <Sciclient_waitForMessage+0xd4> @ imm = #0x6
700a433c: f06f 0001    	mvn	r0, #0x1
;                 status = SystemP_TIMEOUT;
700a4340: 9001         	str	r0, [sp, #0x4]
;                 break;
700a4342: e000         	b	0x700a4346 <Sciclient_waitForMessage+0xd6> @ imm = #0x0
;         while(1)
700a4344: e7ce         	b	0x700a42e4 <Sciclient_waitForMessage+0x74> @ imm = #-0x64
;     }
700a4346: e7ff         	b	0x700a4348 <Sciclient_waitForMessage+0xd8> @ imm = #-0x2
;     return status;
700a4348: 9801         	ldr	r0, [sp, #0x4]
700a434a: b008         	add	sp, #0x20
700a434c: bd80         	pop	{r7, pc}
700a434e: 0000         	movs	r0, r0

700a4350 <UART_intrEnable>:
; {
700a4350: b580         	push	{r7, lr}
700a4352: b08a         	sub	sp, #0x28
700a4354: 9009         	str	r0, [sp, #0x24]
700a4356: 9108         	str	r1, [sp, #0x20]
700a4358: 2000         	movs	r0, #0x0
;     uint32_t enhanFnBitVal = 0U;
700a435a: 9007         	str	r0, [sp, #0x1c]
;     uint32_t lcrRegValue   = 0U;
700a435c: 9006         	str	r0, [sp, #0x18]
;     if ((intrFlag & 0xF0U) > 0U)
700a435e: f89d 0020    	ldrb.w	r0, [sp, #0x20]
700a4362: f010 0ff0    	tst.w	r0, #0xf0
700a4366: d053         	beq	0x700a4410 <UART_intrEnable+0xc0> @ imm = #0xa6
700a4368: e7ff         	b	0x700a436a <UART_intrEnable+0x1a> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a436a: 9809         	ldr	r0, [sp, #0x24]
700a436c: 300c         	adds	r0, #0xc
700a436e: f009 faa7    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x954e
700a4372: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a4374: 9809         	ldr	r0, [sp, #0x24]
700a4376: 300c         	adds	r0, #0xc
700a4378: 21bf         	movs	r1, #0xbf
700a437a: 9103         	str	r1, [sp, #0xc]
700a437c: f009 faa8    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x9550
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a4380: 9809         	ldr	r0, [sp, #0x24]
700a4382: 3008         	adds	r0, #0x8
700a4384: 2110         	movs	r1, #0x10
700a4386: 9104         	str	r1, [sp, #0x10]
700a4388: 2204         	movs	r2, #0x4
700a438a: 9205         	str	r2, [sp, #0x14]
700a438c: f008 feb8    	bl	0x700ad100 <HW_RD_FIELD32_RAW> @ imm = #0x8d70
700a4390: 9904         	ldr	r1, [sp, #0x10]
700a4392: 9a05         	ldr	r2, [sp, #0x14]
700a4394: 9007         	str	r0, [sp, #0x1c]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a4396: 9809         	ldr	r0, [sp, #0x24]
700a4398: 3008         	adds	r0, #0x8
700a439a: 2301         	movs	r3, #0x1
700a439c: f008 f898    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x8130
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a43a0: 9809         	ldr	r0, [sp, #0x24]
700a43a2: 300c         	adds	r0, #0xc
700a43a4: 9906         	ldr	r1, [sp, #0x18]
700a43a6: f009 fa93    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x9526
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a43aa: 9809         	ldr	r0, [sp, #0x24]
700a43ac: 300c         	adds	r0, #0xc
700a43ae: f009 fa87    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x950e
700a43b2: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a43b4: 9809         	ldr	r0, [sp, #0x24]
700a43b6: 300c         	adds	r0, #0xc
700a43b8: 9002         	str	r0, [sp, #0x8]
700a43ba: f009 fa81    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x9502
700a43be: 4601         	mov	r1, r0
700a43c0: 9802         	ldr	r0, [sp, #0x8]
700a43c2: f001 017f    	and	r1, r1, #0x7f
700a43c6: f009 fa83    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x9506
;         HW_WR_REG32(baseAddr + UART_IER, intrFlag & 0xF0U);
700a43ca: 9809         	ldr	r0, [sp, #0x24]
700a43cc: 3004         	adds	r0, #0x4
700a43ce: 9908         	ldr	r1, [sp, #0x20]
700a43d0: f001 01f0    	and	r1, r1, #0xf0
700a43d4: f009 fa7c    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x94f8
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a43d8: 9809         	ldr	r0, [sp, #0x24]
700a43da: 300c         	adds	r0, #0xc
700a43dc: 9906         	ldr	r1, [sp, #0x18]
700a43de: f009 fa77    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x94ee
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a43e2: 9809         	ldr	r0, [sp, #0x24]
700a43e4: 300c         	adds	r0, #0xc
700a43e6: f009 fa6b    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x94d6
700a43ea: 9903         	ldr	r1, [sp, #0xc]
700a43ec: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a43ee: 9809         	ldr	r0, [sp, #0x24]
700a43f0: 300c         	adds	r0, #0xc
700a43f2: f009 fa6d    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x94da
700a43f6: 9904         	ldr	r1, [sp, #0x10]
700a43f8: 9a05         	ldr	r2, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a43fa: 9809         	ldr	r0, [sp, #0x24]
700a43fc: 3008         	adds	r0, #0x8
700a43fe: 9b07         	ldr	r3, [sp, #0x1c]
700a4400: f008 f866    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x80cc
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4404: 9809         	ldr	r0, [sp, #0x24]
700a4406: 300c         	adds	r0, #0xc
700a4408: 9906         	ldr	r1, [sp, #0x18]
700a440a: f009 fa61    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x94c2
;     }
700a440e: e7ff         	b	0x700a4410 <UART_intrEnable+0xc0> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) |
700a4410: 9809         	ldr	r0, [sp, #0x24]
700a4412: 3004         	adds	r0, #0x4
700a4414: 9001         	str	r0, [sp, #0x4]
700a4416: f009 fa53    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x94a6
700a441a: 4601         	mov	r1, r0
700a441c: 9801         	ldr	r0, [sp, #0x4]
700a441e: 9a08         	ldr	r2, [sp, #0x20]
700a4420: f002 020f    	and	r2, r2, #0xf
700a4424: 4311         	orrs	r1, r2
700a4426: f009 fa53    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x94a6
; }
700a442a: b00a         	add	sp, #0x28
700a442c: bd80         	pop	{r7, pc}
700a442e: 0000         	movs	r0, r0

700a4430 <Sciclient_rmIrInpIsFree>:
; {
700a4430: b580         	push	{r7, lr}
700a4432: b086         	sub	sp, #0x18
700a4434: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a4438: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a443c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a443e: 9004         	str	r0, [sp, #0x10]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a4440: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a4442: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a4446: f005 faeb    	bl	0x700a9a20 <Sciclient_rmIrGetInst> @ imm = #0x55d6
700a444a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a444c: 9803         	ldr	r0, [sp, #0xc]
700a444e: b920         	cbnz	r0, 0x700a445a <Sciclient_rmIrInpIsFree+0x2a> @ imm = #0x8
700a4450: e7ff         	b	0x700a4452 <Sciclient_rmIrInpIsFree+0x22> @ imm = #-0x2
700a4452: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a4456: 9004         	str	r0, [sp, #0x10]
;     } else {
700a4458: e00b         	b	0x700a4472 <Sciclient_rmIrInpIsFree+0x42> @ imm = #0x16
;         if (inp >= inst->n_inp) {
700a445a: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a445e: 9903         	ldr	r1, [sp, #0xc]
700a4460: 8909         	ldrh	r1, [r1, #0x8]
700a4462: 4288         	cmp	r0, r1
700a4464: db04         	blt	0x700a4470 <Sciclient_rmIrInpIsFree+0x40> @ imm = #0x8
700a4466: e7ff         	b	0x700a4468 <Sciclient_rmIrInpIsFree+0x38> @ imm = #-0x2
700a4468: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a446c: 9004         	str	r0, [sp, #0x10]
;         }
700a446e: e7ff         	b	0x700a4470 <Sciclient_rmIrInpIsFree+0x40> @ imm = #-0x2
700a4470: e7ff         	b	0x700a4472 <Sciclient_rmIrInpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a4472: 9804         	ldr	r0, [sp, #0x10]
700a4474: 2800         	cmp	r0, #0x0
700a4476: d145         	bne	0x700a4504 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #0x8a
700a4478: e7ff         	b	0x700a447a <Sciclient_rmIrInpIsFree+0x4a> @ imm = #-0x2
;         if (inp == 0u) {
700a447a: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a447e: b960         	cbnz	r0, 0x700a449a <Sciclient_rmIrInpIsFree+0x6a> @ imm = #0x18
700a4480: e7ff         	b	0x700a4482 <Sciclient_rmIrInpIsFree+0x52> @ imm = #-0x2
;             if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a4482: 9803         	ldr	r0, [sp, #0xc]
700a4484: 8980         	ldrh	r0, [r0, #0xc]
700a4486: f64f 71ff    	movw	r1, #0xffff
700a448a: 4288         	cmp	r0, r1
700a448c: d004         	beq	0x700a4498 <Sciclient_rmIrInpIsFree+0x68> @ imm = #0x8
700a448e: e7ff         	b	0x700a4490 <Sciclient_rmIrInpIsFree+0x60> @ imm = #-0x2
700a4490: f04f 30ff    	mov.w	r0, #0xffffffff
;                 r = SystemP_FAILURE;
700a4494: 9004         	str	r0, [sp, #0x10]
;             }
700a4496: e7ff         	b	0x700a4498 <Sciclient_rmIrInpIsFree+0x68> @ imm = #-0x2
;         } else {
700a4498: e033         	b	0x700a4502 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #0x66
700a449a: 2000         	movs	r0, #0x0
;             for (i = 0u; i < inst->n_outp; i++) {
700a449c: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a44a0: e7ff         	b	0x700a44a2 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x2
700a44a2: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a44a6: 9903         	ldr	r1, [sp, #0xc]
700a44a8: 8949         	ldrh	r1, [r1, #0xa]
700a44aa: 4288         	cmp	r0, r1
700a44ac: da28         	bge	0x700a4500 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0x50
700a44ae: e7ff         	b	0x700a44b0 <Sciclient_rmIrInpIsFree+0x80> @ imm = #-0x2
;                 int_ctrl_reg = (volatile uint32_t *)Sciclient_getIrAddr(inst->cfg, i);
700a44b0: 9803         	ldr	r0, [sp, #0xc]
700a44b2: 6840         	ldr	r0, [r0, #0x4]
700a44b4: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a44b8: f008 fa72    	bl	0x700ac9a0 <Sciclient_getIrAddr> @ imm = #0x84e4
700a44bc: 9001         	str	r0, [sp, #0x4]
;                 extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a44be: 9801         	ldr	r0, [sp, #0x4]
700a44c0: f240 31ff    	movw	r1, #0x3ff
700a44c4: 2200         	movs	r2, #0x0
700a44c6: f008 fd3b    	bl	0x700acf40 <CSL_REG32_FEXT_RAW> @ imm = #0x8a76
700a44ca: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 if ((extracted_inp == inp) &&
700a44ce: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a44d2: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a44d6: 4288         	cmp	r0, r1
700a44d8: d10b         	bne	0x700a44f2 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x16
700a44da: e7ff         	b	0x700a44dc <Sciclient_rmIrInpIsFree+0xac> @ imm = #-0x2
;                     (Sciclient_rmIrInpRomMapped(inst, inp) == false)) {
700a44dc: 9803         	ldr	r0, [sp, #0xc]
700a44de: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a44e2: f001 ff2d    	bl	0x700a6340 <Sciclient_rmIrInpRomMapped> @ imm = #0x1e5a
;                 if ((extracted_inp == inp) &&
700a44e6: b920         	cbnz	r0, 0x700a44f2 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x8
700a44e8: e7ff         	b	0x700a44ea <Sciclient_rmIrInpIsFree+0xba> @ imm = #-0x2
700a44ea: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
700a44ee: 9004         	str	r0, [sp, #0x10]
;                     break;
700a44f0: e006         	b	0x700a4500 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0xc
;             }
700a44f2: e7ff         	b	0x700a44f4 <Sciclient_rmIrInpIsFree+0xc4> @ imm = #-0x2
;             for (i = 0u; i < inst->n_outp; i++) {
700a44f4: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a44f8: 3001         	adds	r0, #0x1
700a44fa: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a44fe: e7d0         	b	0x700a44a2 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x60
700a4500: e7ff         	b	0x700a4502 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #-0x2
;     }
700a4502: e7ff         	b	0x700a4504 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #-0x2
;     return r;
700a4504: 9804         	ldr	r0, [sp, #0x10]
700a4506: b006         	add	sp, #0x18
700a4508: bd80         	pop	{r7, pc}
700a450a: 0000         	movs	r0, r0
700a450c: 0000         	movs	r0, r0
700a450e: 0000         	movs	r0, r0

700a4510 <UART_intrDisable>:
; {
700a4510: b580         	push	{r7, lr}
700a4512: b088         	sub	sp, #0x20
700a4514: 9007         	str	r0, [sp, #0x1c]
700a4516: 9106         	str	r1, [sp, #0x18]
;     if((intrFlag & 0xF0U) > 0U)
700a4518: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a451c: f010 0ff0    	tst.w	r0, #0xf0
700a4520: d020         	beq	0x700a4564 <UART_intrDisable+0x54> @ imm = #0x40
700a4522: e7ff         	b	0x700a4524 <UART_intrDisable+0x14> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a4524: 9807         	ldr	r0, [sp, #0x1c]
700a4526: 300c         	adds	r0, #0xc
700a4528: f009 f9ca    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x9394
700a452c: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a452e: 9807         	ldr	r0, [sp, #0x1c]
700a4530: 300c         	adds	r0, #0xc
700a4532: 21bf         	movs	r1, #0xbf
700a4534: f009 f9cc    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x9398
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a4538: 9807         	ldr	r0, [sp, #0x1c]
700a453a: 3008         	adds	r0, #0x8
700a453c: 2110         	movs	r1, #0x10
700a453e: 9102         	str	r1, [sp, #0x8]
700a4540: 2204         	movs	r2, #0x4
700a4542: 9203         	str	r2, [sp, #0xc]
700a4544: f008 fddc    	bl	0x700ad100 <HW_RD_FIELD32_RAW> @ imm = #0x8bb8
700a4548: 9902         	ldr	r1, [sp, #0x8]
700a454a: 9a03         	ldr	r2, [sp, #0xc]
700a454c: 9005         	str	r0, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a454e: 9807         	ldr	r0, [sp, #0x1c]
700a4550: 3008         	adds	r0, #0x8
700a4552: 2301         	movs	r3, #0x1
700a4554: f007 ffbc    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x7f78
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4558: 9807         	ldr	r0, [sp, #0x1c]
700a455a: 300c         	adds	r0, #0xc
700a455c: 9904         	ldr	r1, [sp, #0x10]
700a455e: f009 f9b7    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x936e
;     }
700a4562: e7ff         	b	0x700a4564 <UART_intrDisable+0x54> @ imm = #-0x2
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a4564: 9807         	ldr	r0, [sp, #0x1c]
700a4566: 300c         	adds	r0, #0xc
700a4568: f009 f9aa    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x9354
700a456c: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a456e: 9807         	ldr	r0, [sp, #0x1c]
700a4570: 300c         	adds	r0, #0xc
700a4572: 9000         	str	r0, [sp]
700a4574: f009 f9a4    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x9348
700a4578: 4601         	mov	r1, r0
700a457a: 9800         	ldr	r0, [sp]
700a457c: f001 017f    	and	r1, r1, #0x7f
700a4580: f009 f9a6    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x934c
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) &
700a4584: 9807         	ldr	r0, [sp, #0x1c]
700a4586: 3004         	adds	r0, #0x4
700a4588: 9001         	str	r0, [sp, #0x4]
700a458a: f009 f999    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x9332
700a458e: 4601         	mov	r1, r0
700a4590: 9801         	ldr	r0, [sp, #0x4]
700a4592: 9b06         	ldr	r3, [sp, #0x18]
700a4594: f06f 02ff    	mvn	r2, #0xff
700a4598: ea62 0203    	orn	r2, r2, r3
700a459c: 4011         	ands	r1, r2
700a459e: f009 f997    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x932e
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a45a2: 9807         	ldr	r0, [sp, #0x1c]
700a45a4: 300c         	adds	r0, #0xc
700a45a6: 9904         	ldr	r1, [sp, #0x10]
700a45a8: f009 f992    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x9324
;     if((intrFlag & 0xF0U) > 0U)
700a45ac: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a45b0: f010 0ff0    	tst.w	r0, #0xf0
700a45b4: d017         	beq	0x700a45e6 <UART_intrDisable+0xd6> @ imm = #0x2e
700a45b6: e7ff         	b	0x700a45b8 <UART_intrDisable+0xa8> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a45b8: 9807         	ldr	r0, [sp, #0x1c]
700a45ba: 300c         	adds	r0, #0xc
700a45bc: f009 f980    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x9300
700a45c0: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a45c2: 9807         	ldr	r0, [sp, #0x1c]
700a45c4: 300c         	adds	r0, #0xc
700a45c6: 21bf         	movs	r1, #0xbf
700a45c8: f009 f982    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x9304
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a45cc: 9807         	ldr	r0, [sp, #0x1c]
700a45ce: 3008         	adds	r0, #0x8
700a45d0: 9b05         	ldr	r3, [sp, #0x14]
700a45d2: 2110         	movs	r1, #0x10
700a45d4: 2204         	movs	r2, #0x4
700a45d6: f007 ff7b    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x7ef6
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a45da: 9807         	ldr	r0, [sp, #0x1c]
700a45dc: 300c         	adds	r0, #0xc
700a45de: 9904         	ldr	r1, [sp, #0x10]
700a45e0: f009 f976    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x92ec
;     }
700a45e4: e7ff         	b	0x700a45e6 <UART_intrDisable+0xd6> @ imm = #-0x2
; }
700a45e6: b008         	add	sp, #0x20
700a45e8: bd80         	pop	{r7, pc}
700a45ea: 0000         	movs	r0, r0
700a45ec: 0000         	movs	r0, r0
700a45ee: 0000         	movs	r0, r0

700a45f0 <UART_udmaConfigPdmaTx>:
; {
700a45f0: b580         	push	{r7, lr}
700a45f2: b090         	sub	sp, #0x40
700a45f4: 900f         	str	r0, [sp, #0x3c]
700a45f6: 910e         	str	r1, [sp, #0x38]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a45f8: 980f         	ldr	r0, [sp, #0x3c]
700a45fa: 6840         	ldr	r0, [r0, #0x4]
700a45fc: 6cc0         	ldr	r0, [r0, #0x4c]
700a45fe: 9008         	str	r0, [sp, #0x20]
;     txChHandle  = udmaChCfg->txChHandle;
700a4600: 9808         	ldr	r0, [sp, #0x20]
700a4602: 6840         	ldr	r0, [r0, #0x4]
700a4604: 9009         	str	r0, [sp, #0x24]
700a4606: a80a         	add	r0, sp, #0x28
;     UdmaChPdmaPrms_init(&pdmaPrms);
700a4608: 9002         	str	r0, [sp, #0x8]
700a460a: f008 fe29    	bl	0x700ad260 <UdmaChPdmaPrms_init> @ imm = #0x8c52
700a460e: 9902         	ldr	r1, [sp, #0x8]
700a4610: 2000         	movs	r0, #0x0
;     pdmaPrms.elemSize = UDMA_PDMA_ES_8BITS;
700a4612: 9003         	str	r0, [sp, #0xc]
700a4614: 900a         	str	r0, [sp, #0x28]
700a4616: 2201         	movs	r2, #0x1
;     pdmaPrms.elemCnt  = 1U;
700a4618: 920b         	str	r2, [sp, #0x2c]
;     pdmaPrms.fifoCnt  = 0U;
700a461a: 900c         	str	r0, [sp, #0x30]
;     retVal = Udma_chConfigPdma(txChHandle, &pdmaPrms);
700a461c: 9809         	ldr	r0, [sp, #0x24]
700a461e: f7fa ffc7    	bl	0x7009f5b0 <Udma_chConfigPdma> @ imm = #-0x5072
700a4622: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a4624: 980d         	ldr	r0, [sp, #0x34]
700a4626: fab0 f080    	clz	r0, r0
700a462a: 0940         	lsrs	r0, r0, #0x5
700a462c: f64f 3123    	movw	r1, #0xfb23
700a4630: f2c7 010a    	movt	r1, #0x700a
700a4634: 9105         	str	r1, [sp, #0x14]
700a4636: 466a         	mov	r2, sp
700a4638: 6011         	str	r1, [r2]
700a463a: f24f 7199    	movw	r1, #0xf799
700a463e: f2c7 010a    	movt	r1, #0x700a
700a4642: 9106         	str	r1, [sp, #0x18]
700a4644: f64f 22e3    	movw	r2, #0xfae3
700a4648: f2c7 020a    	movt	r2, #0x700a
700a464c: 9207         	str	r2, [sp, #0x1c]
700a464e: 23ee         	movs	r3, #0xee
700a4650: f004 fae6    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x45cc
;     retVal = Udma_chEnable(txChHandle);
700a4654: 9809         	ldr	r0, [sp, #0x24]
700a4656: f004 fd63    	bl	0x700a9120 <Udma_chEnable> @ imm = #0x4ac6
700a465a: 9b05         	ldr	r3, [sp, #0x14]
700a465c: 9906         	ldr	r1, [sp, #0x18]
700a465e: 9a07         	ldr	r2, [sp, #0x1c]
700a4660: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a4662: 980d         	ldr	r0, [sp, #0x34]
700a4664: fab0 f080    	clz	r0, r0
700a4668: 0940         	lsrs	r0, r0, #0x5
700a466a: 46ec         	mov	r12, sp
700a466c: f8cc 3000    	str.w	r3, [r12]
700a4670: 23f1         	movs	r3, #0xf1
700a4672: f004 fad5    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x45aa
;     UART_udmaHpdInit(txChHandle, (uint8_t *) udmaChCfg->txHpdMem, hUart->writeBuf, transaction->count);
700a4676: 9809         	ldr	r0, [sp, #0x24]
700a4678: 9908         	ldr	r1, [sp, #0x20]
700a467a: 6949         	ldr	r1, [r1, #0x14]
700a467c: 9a0f         	ldr	r2, [sp, #0x3c]
700a467e: 6892         	ldr	r2, [r2, #0x8]
700a4680: 9b0e         	ldr	r3, [sp, #0x38]
700a4682: 685b         	ldr	r3, [r3, #0x4]
700a4684: f000 fbec    	bl	0x700a4e60 <UART_udmaHpdInit> @ imm = #0x7d8
;                  Udma_chGetFqRingHandle(txChHandle),
700a4688: 9809         	ldr	r0, [sp, #0x24]
700a468a: f004 fcc9    	bl	0x700a9020 <Udma_chGetFqRingHandle> @ imm = #0x4992
700a468e: 9a03         	ldr	r2, [sp, #0xc]
;                  (uint64_t) Udma_defaultVirtToPhyFxn(udmaChCfg->txHpdMem, 0U, NULL));
700a4690: 9004         	str	r0, [sp, #0x10]
700a4692: 9808         	ldr	r0, [sp, #0x20]
700a4694: 6940         	ldr	r0, [r0, #0x14]
700a4696: 4611         	mov	r1, r2
700a4698: f009 f922    	bl	0x700ad8e0 <Udma_defaultVirtToPhyFxn> @ imm = #0x9244
700a469c: 4602         	mov	r2, r0
700a469e: 9804         	ldr	r0, [sp, #0x10]
700a46a0: 460b         	mov	r3, r1
;     retVal = Udma_ringQueueRaw(
700a46a2: f002 fcd5    	bl	0x700a7050 <Udma_ringQueueRaw> @ imm = #0x29aa
700a46a6: 9b05         	ldr	r3, [sp, #0x14]
700a46a8: 9906         	ldr	r1, [sp, #0x18]
700a46aa: 9a07         	ldr	r2, [sp, #0x1c]
700a46ac: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a46ae: 980d         	ldr	r0, [sp, #0x34]
700a46b0: fab0 f080    	clz	r0, r0
700a46b4: 0940         	lsrs	r0, r0, #0x5
700a46b6: 46ec         	mov	r12, sp
700a46b8: f8cc 3000    	str.w	r3, [r12]
700a46bc: 23f9         	movs	r3, #0xf9
700a46be: f004 faaf    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x455e
;     return (retVal);
700a46c2: 980d         	ldr	r0, [sp, #0x34]
700a46c4: b010         	add	sp, #0x40
700a46c6: bd80         	pop	{r7, pc}
		...

700a46d0 <CSL_bcdmaChanOpGetChanRT>:
; {
700a46d0: b580         	push	{r7, lr}
700a46d2: b088         	sub	sp, #0x20
700a46d4: 9007         	str	r0, [sp, #0x1c]
700a46d6: 9106         	str	r1, [sp, #0x18]
700a46d8: 9205         	str	r2, [sp, #0x14]
700a46da: 9304         	str	r3, [sp, #0x10]
700a46dc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a46de: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a46e0: 9804         	ldr	r0, [sp, #0x10]
700a46e2: b920         	cbnz	r0, 0x700a46ee <CSL_bcdmaChanOpGetChanRT+0x1e> @ imm = #0x8
700a46e4: e7ff         	b	0x700a46e6 <CSL_bcdmaChanOpGetChanRT+0x16> @ imm = #-0x2
700a46e6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a46ea: 9003         	str	r0, [sp, #0xc]
;     }
700a46ec: e057         	b	0x700a479e <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #0xae
;         switch( chanType )
700a46ee: 9806         	ldr	r0, [sp, #0x18]
700a46f0: 9000         	str	r0, [sp]
700a46f2: b140         	cbz	r0, 0x700a4706 <CSL_bcdmaChanOpGetChanRT+0x36> @ imm = #0x10
700a46f4: e7ff         	b	0x700a46f6 <CSL_bcdmaChanOpGetChanRT+0x26> @ imm = #-0x2
700a46f6: 9800         	ldr	r0, [sp]
700a46f8: 2801         	cmp	r0, #0x1
700a46fa: d00d         	beq	0x700a4718 <CSL_bcdmaChanOpGetChanRT+0x48> @ imm = #0x1a
700a46fc: e7ff         	b	0x700a46fe <CSL_bcdmaChanOpGetChanRT+0x2e> @ imm = #-0x2
700a46fe: 9800         	ldr	r0, [sp]
700a4700: 2802         	cmp	r0, #0x2
700a4702: d012         	beq	0x700a472a <CSL_bcdmaChanOpGetChanRT+0x5a> @ imm = #0x24
700a4704: e01a         	b	0x700a473c <CSL_bcdmaChanOpGetChanRT+0x6c> @ imm = #0x34
;                 val = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
700a4706: 9807         	ldr	r0, [sp, #0x1c]
700a4708: 6880         	ldr	r0, [r0, #0x8]
700a470a: 9905         	ldr	r1, [sp, #0x14]
700a470c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4710: f009 f91e    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0x923c
700a4714: 9002         	str	r0, [sp, #0x8]
;                 break;
700a4716: e015         	b	0x700a4744 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x2a
;                 val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a4718: 9807         	ldr	r0, [sp, #0x1c]
700a471a: 6900         	ldr	r0, [r0, #0x10]
700a471c: 9905         	ldr	r1, [sp, #0x14]
700a471e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4722: f009 f915    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0x922a
700a4726: 9002         	str	r0, [sp, #0x8]
;                 break;
700a4728: e00c         	b	0x700a4744 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x18
;                 val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a472a: 9807         	ldr	r0, [sp, #0x1c]
700a472c: 6980         	ldr	r0, [r0, #0x18]
700a472e: 9905         	ldr	r1, [sp, #0x14]
700a4730: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4734: f009 f90c    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0x9218
700a4738: 9002         	str	r0, [sp, #0x8]
;                 break;
700a473a: e003         	b	0x700a4744 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x6
700a473c: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a4740: 9003         	str	r0, [sp, #0xc]
;                 break;
700a4742: e7ff         	b	0x700a4744 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #-0x2
;         if( retVal == CSL_PASS )
700a4744: 9803         	ldr	r0, [sp, #0xc]
700a4746: bb48         	cbnz	r0, 0x700a479c <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #0x52
700a4748: e7ff         	b	0x700a474a <CSL_bcdmaChanOpGetChanRT+0x7a> @ imm = #-0x2
;             CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a474a: 9804         	ldr	r0, [sp, #0x10]
700a474c: 9001         	str	r0, [sp, #0x4]
;             pRT->enable         = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_EN );
700a474e: 9802         	ldr	r0, [sp, #0x8]
700a4750: 0fc0         	lsrs	r0, r0, #0x1f
700a4752: 9901         	ldr	r1, [sp, #0x4]
700a4754: 6008         	str	r0, [r1]
;             pRT->teardown       = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_TDOWN );
700a4756: 9802         	ldr	r0, [sp, #0x8]
700a4758: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700a475c: 9901         	ldr	r1, [sp, #0x4]
700a475e: 6048         	str	r0, [r1, #0x4]
;             pRT->forcedTeardown = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_FTDOWN );
700a4760: 9802         	ldr	r0, [sp, #0x8]
700a4762: f3c0 7000    	ubfx	r0, r0, #0x1c, #0x1
700a4766: 9901         	ldr	r1, [sp, #0x4]
700a4768: 6108         	str	r0, [r1, #0x10]
;             pRT->pause          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_PAUSE );
700a476a: 9802         	ldr	r0, [sp, #0x8]
700a476c: f3c0 7040    	ubfx	r0, r0, #0x1d, #0x1
700a4770: 9901         	ldr	r1, [sp, #0x4]
700a4772: 6088         	str	r0, [r1, #0x8]
;             pRT->error          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_ERROR );
700a4774: 9802         	ldr	r0, [sp, #0x8]
700a4776: f000 0001    	and	r0, r0, #0x1
700a477a: 9901         	ldr	r1, [sp, #0x4]
700a477c: 60c8         	str	r0, [r1, #0xc]
;             if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a477e: 9806         	ldr	r0, [sp, #0x18]
700a4780: 2802         	cmp	r0, #0x2
700a4782: d106         	bne	0x700a4792 <CSL_bcdmaChanOpGetChanRT+0xc2> @ imm = #0xc
700a4784: e7ff         	b	0x700a4786 <CSL_bcdmaChanOpGetChanRT+0xb6> @ imm = #-0x2
;                 pRT->starvation = CSL_FEXT( val, BCDMA_RXCRT_CHAN_CTL_STARVATION );
700a4786: 9802         	ldr	r0, [sp, #0x8]
700a4788: f3c0 0040    	ubfx	r0, r0, #0x1, #0x1
700a478c: 9901         	ldr	r1, [sp, #0x4]
700a478e: 6148         	str	r0, [r1, #0x14]
;             }
700a4790: e003         	b	0x700a479a <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #0x6
;                 pRT->starvation = (uint32_t)0U;
700a4792: 9901         	ldr	r1, [sp, #0x4]
700a4794: 2000         	movs	r0, #0x0
700a4796: 6148         	str	r0, [r1, #0x14]
700a4798: e7ff         	b	0x700a479a <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #-0x2
;         }
700a479a: e7ff         	b	0x700a479c <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #-0x2
700a479c: e7ff         	b	0x700a479e <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #-0x2
;     return retVal;
700a479e: 9803         	ldr	r0, [sp, #0xc]
700a47a0: b008         	add	sp, #0x20
700a47a2: bd80         	pop	{r7, pc}
		...

700a47b0 <Pinmux_unlockMMR>:
; {
700a47b0: b580         	push	{r7, lr}
700a47b2: b088         	sub	sp, #0x20
700a47b4: 9007         	str	r0, [sp, #0x1c]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a47b6: 9807         	ldr	r0, [sp, #0x1c]
700a47b8: bb78         	cbnz	r0, 0x700a481a <Pinmux_unlockMMR+0x6a> @ imm = #0x5e
700a47ba: e7ff         	b	0x700a47bc <Pinmux_unlockMMR+0xc> @ imm = #-0x2
700a47bc: f44f 2070    	mov.w	r0, #0xf0000
700a47c0: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_PADCFG_CTRL0_CFG0_BASE);
700a47c2: f7ff fb05    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x9f6
700a47c6: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK0_KICK0_OFFSET);
700a47c8: 9806         	ldr	r0, [sp, #0x18]
700a47ca: f241 0108    	movw	r1, #0x1008
700a47ce: 4408         	add	r0, r1
700a47d0: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a47d2: 9805         	ldr	r0, [sp, #0x14]
700a47d4: f243 4190    	movw	r1, #0x3490
700a47d8: f6c6 01ef    	movt	r1, #0x68ef
700a47dc: 9103         	str	r1, [sp, #0xc]
700a47de: f009 f827    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x904e
;         kickAddr++;
700a47e2: 9805         	ldr	r0, [sp, #0x14]
700a47e4: 3004         	adds	r0, #0x4
700a47e6: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a47e8: 9805         	ldr	r0, [sp, #0x14]
700a47ea: f64b 415a    	movw	r1, #0xbc5a
700a47ee: f2cd 1172    	movt	r1, #0xd172
700a47f2: 9104         	str	r1, [sp, #0x10]
700a47f4: f009 f81c    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x9038
700a47f8: 9903         	ldr	r1, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK1_KICK0_OFFSET);
700a47fa: 9806         	ldr	r0, [sp, #0x18]
700a47fc: f245 0208    	movw	r2, #0x5008
700a4800: 4410         	add	r0, r2
700a4802: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a4804: 9805         	ldr	r0, [sp, #0x14]
700a4806: f009 f813    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x9026
700a480a: 9904         	ldr	r1, [sp, #0x10]
;         kickAddr++;
700a480c: 9805         	ldr	r0, [sp, #0x14]
700a480e: 3004         	adds	r0, #0x4
700a4810: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a4812: 9805         	ldr	r0, [sp, #0x14]
700a4814: f009 f80c    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x9018
;     }
700a4818: e7ff         	b	0x700a481a <Pinmux_unlockMMR+0x6a> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700a481a: 9807         	ldr	r0, [sp, #0x1c]
700a481c: 2801         	cmp	r0, #0x1
700a481e: d12f         	bne	0x700a4880 <Pinmux_unlockMMR+0xd0> @ imm = #0x5e
700a4820: e7ff         	b	0x700a4822 <Pinmux_unlockMMR+0x72> @ imm = #-0x2
700a4822: f04f 6081    	mov.w	r0, #0x4080000
700a4826: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700a4828: f7ff fad2    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0xa5c
700a482c: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700a482e: 9806         	ldr	r0, [sp, #0x18]
700a4830: f241 0108    	movw	r1, #0x1008
700a4834: 4408         	add	r0, r1
700a4836: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a4838: 9805         	ldr	r0, [sp, #0x14]
700a483a: f243 4190    	movw	r1, #0x3490
700a483e: f6c6 01ef    	movt	r1, #0x68ef
700a4842: 9101         	str	r1, [sp, #0x4]
700a4844: f008 fff4    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x8fe8
;         kickAddr++;
700a4848: 9805         	ldr	r0, [sp, #0x14]
700a484a: 3004         	adds	r0, #0x4
700a484c: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a484e: 9805         	ldr	r0, [sp, #0x14]
700a4850: f64b 415a    	movw	r1, #0xbc5a
700a4854: f2cd 1172    	movt	r1, #0xd172
700a4858: 9102         	str	r1, [sp, #0x8]
700a485a: f008 ffe9    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x8fd2
700a485e: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700a4860: 9806         	ldr	r0, [sp, #0x18]
700a4862: f245 0208    	movw	r2, #0x5008
700a4866: 4410         	add	r0, r2
700a4868: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a486a: 9805         	ldr	r0, [sp, #0x14]
700a486c: f008 ffe0    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x8fc0
700a4870: 9902         	ldr	r1, [sp, #0x8]
;         kickAddr++;
700a4872: 9805         	ldr	r0, [sp, #0x14]
700a4874: 3004         	adds	r0, #0x4
700a4876: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a4878: 9805         	ldr	r0, [sp, #0x14]
700a487a: f008 ffd9    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x8fb2
;     }
700a487e: e7ff         	b	0x700a4880 <Pinmux_unlockMMR+0xd0> @ imm = #-0x2
;     return;
700a4880: b008         	add	sp, #0x20
700a4882: bd80         	pop	{r7, pc}
		...

700a4890 <UART_lld_write>:
; {
700a4890: b580         	push	{r7, lr}
700a4892: b086         	sub	sp, #0x18
700a4894: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a4898: 9005         	str	r0, [sp, #0x14]
700a489a: 9104         	str	r1, [sp, #0x10]
700a489c: 9203         	str	r2, [sp, #0xc]
700a489e: 9302         	str	r3, [sp, #0x8]
700a48a0: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a48a2: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a48a4: 9805         	ldr	r0, [sp, #0x14]
700a48a6: 2800         	cmp	r0, #0x0
700a48a8: d054         	beq	0x700a4954 <UART_lld_write+0xc4> @ imm = #0xa8
700a48aa: e7ff         	b	0x700a48ac <UART_lld_write+0x1c> @ imm = #-0x2
;          trans = &hUart->writeTrans;
700a48ac: 9805         	ldr	r0, [sp, #0x14]
700a48ae: 303c         	adds	r0, #0x3c
700a48b0: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a48b2: 9800         	ldr	r0, [sp]
700a48b4: 6800         	ldr	r0, [r0]
700a48b6: b138         	cbz	r0, 0x700a48c8 <UART_lld_write+0x38> @ imm = #0xe
700a48b8: e7ff         	b	0x700a48ba <UART_lld_write+0x2a> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a48ba: 9900         	ldr	r1, [sp]
700a48bc: 2009         	movs	r0, #0x9
700a48be: 60c8         	str	r0, [r1, #0xc]
700a48c0: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a48c4: 9001         	str	r0, [sp, #0x4]
;         }
700a48c6: e044         	b	0x700a4952 <UART_lld_write+0xc2> @ imm = #0x88
;             UART_lld_Transaction_init(trans);
700a48c8: 9800         	ldr	r0, [sp]
700a48ca: f008 f971    	bl	0x700acbb0 <UART_lld_Transaction_init> @ imm = #0x82e2
;             if(extendedParams != NULL)
700a48ce: 9808         	ldr	r0, [sp, #0x20]
700a48d0: b128         	cbz	r0, 0x700a48de <UART_lld_write+0x4e> @ imm = #0xa
700a48d2: e7ff         	b	0x700a48d4 <UART_lld_write+0x44> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a48d4: 9808         	ldr	r0, [sp, #0x20]
700a48d6: 6800         	ldr	r0, [r0]
700a48d8: 9900         	ldr	r1, [sp]
700a48da: 6108         	str	r0, [r1, #0x10]
;             }
700a48dc: e003         	b	0x700a48e6 <UART_lld_write+0x56> @ imm = #0x6
;                 trans->args = NULL;
700a48de: 9900         	ldr	r1, [sp]
700a48e0: 2000         	movs	r0, #0x0
700a48e2: 6108         	str	r0, [r1, #0x10]
700a48e4: e7ff         	b	0x700a48e6 <UART_lld_write+0x56> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a48e6: 9804         	ldr	r0, [sp, #0x10]
700a48e8: 9900         	ldr	r1, [sp]
700a48ea: 6008         	str	r0, [r1]
;             trans->count = size;
700a48ec: 9803         	ldr	r0, [sp, #0xc]
700a48ee: 9900         	ldr	r1, [sp]
700a48f0: 6048         	str	r0, [r1, #0x4]
;             trans->timeout = timeout;
700a48f2: 9802         	ldr	r0, [sp, #0x8]
700a48f4: 9900         	ldr	r1, [sp]
700a48f6: 6088         	str	r0, [r1, #0x8]
;             if(hUart->state == UART_STATE_READY)
700a48f8: 9805         	ldr	r0, [sp, #0x14]
700a48fa: 6d40         	ldr	r0, [r0, #0x54]
700a48fc: 2801         	cmp	r0, #0x1
700a48fe: d105         	bne	0x700a490c <UART_lld_write+0x7c> @ imm = #0xa
700a4900: e7ff         	b	0x700a4902 <UART_lld_write+0x72> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a4902: 9800         	ldr	r0, [sp]
700a4904: f007 fd6c    	bl	0x700ac3e0 <UART_checkTransaction> @ imm = #0x7ad8
700a4908: 9001         	str	r0, [sp, #0x4]
;             }
700a490a: e003         	b	0x700a4914 <UART_lld_write+0x84> @ imm = #0x6
700a490c: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a4910: 9001         	str	r0, [sp, #0x4]
700a4912: e7ff         	b	0x700a4914 <UART_lld_write+0x84> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a4914: 9801         	ldr	r0, [sp, #0x4]
700a4916: b980         	cbnz	r0, 0x700a493a <UART_lld_write+0xaa> @ imm = #0x20
700a4918: e7ff         	b	0x700a491a <UART_lld_write+0x8a> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a491a: 9800         	ldr	r0, [sp]
700a491c: 6800         	ldr	r0, [r0]
700a491e: 9905         	ldr	r1, [sp, #0x14]
700a4920: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a4922: 9800         	ldr	r0, [sp]
700a4924: 6880         	ldr	r0, [r0, #0x8]
700a4926: 9905         	ldr	r1, [sp, #0x14]
700a4928: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a492a: 9905         	ldr	r1, [sp, #0x14]
700a492c: 2000         	movs	r0, #0x0
700a492e: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a4930: 9800         	ldr	r0, [sp]
700a4932: 6840         	ldr	r0, [r0, #0x4]
700a4934: 9905         	ldr	r1, [sp, #0x14]
700a4936: 6108         	str	r0, [r1, #0x10]
;             }
700a4938: e7ff         	b	0x700a493a <UART_lld_write+0xaa> @ imm = #-0x2
;             hUart->state = UART_STATE_BUSY;
700a493a: 9905         	ldr	r1, [sp, #0x14]
700a493c: 2002         	movs	r0, #0x2
700a493e: 6548         	str	r0, [r1, #0x54]
;             status = UART_writePolling(hUart, trans);
700a4940: 9805         	ldr	r0, [sp, #0x14]
700a4942: 9900         	ldr	r1, [sp]
700a4944: f7fc fc54    	bl	0x700a11f0 <UART_writePolling> @ imm = #-0x3758
700a4948: 9001         	str	r0, [sp, #0x4]
;             hUart->state = UART_STATE_READY;
700a494a: 9905         	ldr	r1, [sp, #0x14]
700a494c: 2001         	movs	r0, #0x1
700a494e: 6548         	str	r0, [r1, #0x54]
700a4950: e7ff         	b	0x700a4952 <UART_lld_write+0xc2> @ imm = #-0x2
;     }
700a4952: e003         	b	0x700a495c <UART_lld_write+0xcc> @ imm = #0x6
700a4954: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a4958: 9001         	str	r0, [sp, #0x4]
700a495a: e7ff         	b	0x700a495c <UART_lld_write+0xcc> @ imm = #-0x2
;     return status;
700a495c: 9801         	ldr	r0, [sp, #0x4]
700a495e: b006         	add	sp, #0x18
700a4960: bd80         	pop	{r7, pc}
		...
700a496e: 0000         	movs	r0, r0

700a4970 <UART_udmaDeInitCh>:
; {
700a4970: b580         	push	{r7, lr}
700a4972: b08c         	sub	sp, #0x30
700a4974: 900b         	str	r0, [sp, #0x2c]
700a4976: 910a         	str	r1, [sp, #0x28]
700a4978: 2000         	movs	r0, #0x0
;     int32_t status = UDMA_SOK;
700a497a: 9009         	str	r0, [sp, #0x24]
700a497c: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a497e: 9008         	str	r0, [sp, #0x20]
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a4980: 980b         	ldr	r0, [sp, #0x2c]
700a4982: 2164         	movs	r1, #0x64
700a4984: f001 fb7c    	bl	0x700a6080 <Udma_chDisable> @ imm = #0x16f8
700a4988: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a498a: 9809         	ldr	r0, [sp, #0x24]
700a498c: fab0 f080    	clz	r0, r0
700a4990: 0940         	lsrs	r0, r0, #0x5
700a4992: f64f 315c    	movw	r1, #0xfb5c
700a4996: f2c7 010a    	movt	r1, #0x700a
700a499a: 9102         	str	r1, [sp, #0x8]
700a499c: 466a         	mov	r2, sp
700a499e: 6011         	str	r1, [r2]
700a49a0: f24f 7199    	movw	r1, #0xf799
700a49a4: f2c7 010a    	movt	r1, #0x700a
700a49a8: 9103         	str	r1, [sp, #0xc]
700a49aa: f64f 32a6    	movw	r2, #0xfba6
700a49ae: f2c7 020a    	movt	r2, #0x700a
700a49b2: 9204         	str	r2, [sp, #0x10]
700a49b4: f240 134b    	movw	r3, #0x14b
700a49b8: f004 f932    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x4264
;     status = Udma_eventUnRegister(eventHandle);
700a49bc: 980a         	ldr	r0, [sp, #0x28]
700a49be: f000 fc57    	bl	0x700a5270 <Udma_eventUnRegister> @ imm = #0x8ae
700a49c2: 9b02         	ldr	r3, [sp, #0x8]
700a49c4: 9903         	ldr	r1, [sp, #0xc]
700a49c6: 9a04         	ldr	r2, [sp, #0x10]
700a49c8: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a49ca: 9809         	ldr	r0, [sp, #0x24]
700a49cc: fab0 f080    	clz	r0, r0
700a49d0: 0940         	lsrs	r0, r0, #0x5
700a49d2: 46ec         	mov	r12, sp
700a49d4: f8cc 3000    	str.w	r3, [r12]
700a49d8: f240 134f    	movw	r3, #0x14f
700a49dc: f004 f920    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x4240
;     while(temp == TRUE)
700a49e0: e7ff         	b	0x700a49e2 <UART_udmaDeInitCh+0x72> @ imm = #-0x2
700a49e2: 9808         	ldr	r0, [sp, #0x20]
700a49e4: 2801         	cmp	r0, #0x1
700a49e6: d10f         	bne	0x700a4a08 <UART_udmaDeInitCh+0x98> @ imm = #0x1e
700a49e8: e7ff         	b	0x700a49ea <UART_udmaDeInitCh+0x7a> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a49ea: 980b         	ldr	r0, [sp, #0x2c]
700a49ec: f004 fb18    	bl	0x700a9020 <Udma_chGetFqRingHandle> @ imm = #0x4630
700a49f0: a906         	add	r1, sp, #0x18
;         tempRetVal = Udma_ringFlushRaw(
700a49f2: f003 fb65    	bl	0x700a80c0 <Udma_ringFlushRaw> @ imm = #0x36ca
700a49f6: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a49f8: 9805         	ldr	r0, [sp, #0x14]
700a49fa: 3004         	adds	r0, #0x4
700a49fc: b918         	cbnz	r0, 0x700a4a06 <UART_udmaDeInitCh+0x96> @ imm = #0x6
700a49fe: e7ff         	b	0x700a4a00 <UART_udmaDeInitCh+0x90> @ imm = #-0x2
700a4a00: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a4a02: 9008         	str	r0, [sp, #0x20]
;         }
700a4a04: e7ff         	b	0x700a4a06 <UART_udmaDeInitCh+0x96> @ imm = #-0x2
;     while(temp == TRUE)
700a4a06: e7ec         	b	0x700a49e2 <UART_udmaDeInitCh+0x72> @ imm = #-0x28
;     status = Udma_chClose(chHandle);
700a4a08: 980b         	ldr	r0, [sp, #0x2c]
700a4a0a: f000 fd69    	bl	0x700a54e0 <Udma_chClose> @ imm = #0xad2
700a4a0e: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a4a10: 9809         	ldr	r0, [sp, #0x24]
700a4a12: fab0 f080    	clz	r0, r0
700a4a16: 0940         	lsrs	r0, r0, #0x5
700a4a18: f64f 315c    	movw	r1, #0xfb5c
700a4a1c: f2c7 010a    	movt	r1, #0x700a
700a4a20: 466a         	mov	r2, sp
700a4a22: 6011         	str	r1, [r2]
700a4a24: f24f 7199    	movw	r1, #0xf799
700a4a28: f2c7 010a    	movt	r1, #0x700a
700a4a2c: f64f 32a6    	movw	r2, #0xfba6
700a4a30: f2c7 020a    	movt	r2, #0x700a
700a4a34: f240 1361    	movw	r3, #0x161
700a4a38: f004 f8f2    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x41e4
;     return status;
700a4a3c: 9809         	ldr	r0, [sp, #0x24]
700a4a3e: b00c         	add	sp, #0x30
700a4a40: bd80         	pop	{r7, pc}
		...
700a4a4e: 0000         	movs	r0, r0

700a4a50 <Udma_rmAllocVintrBit>:
; {
700a4a50: b580         	push	{r7, lr}
700a4a52: b08a         	sub	sp, #0x28
700a4a54: 9009         	str	r0, [sp, #0x24]
700a4a56: f64f 70ff    	movw	r0, #0xffff
;     uint32_t                vintrBitNum = UDMA_EVENT_INVALID;
700a4a5a: 9007         	str	r0, [sp, #0x1c]
;     Udma_DrvHandleInt       drvHandle = eventHandle->drvHandle;
700a4a5c: 9809         	ldr	r0, [sp, #0x24]
700a4a5e: 6800         	ldr	r0, [r0]
700a4a60: 9001         	str	r0, [sp, #0x4]
;     controllerEventHandle = eventHandle;
700a4a62: 9809         	ldr	r0, [sp, #0x24]
700a4a64: 9003         	str	r0, [sp, #0xc]
;     eventPrms = &eventHandle->eventPrms;
700a4a66: 9809         	ldr	r0, [sp, #0x24]
700a4a68: 3008         	adds	r0, #0x8
700a4a6a: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700a4a6c: 9802         	ldr	r0, [sp, #0x8]
700a4a6e: 6900         	ldr	r0, [r0, #0x10]
700a4a70: b120         	cbz	r0, 0x700a4a7c <Udma_rmAllocVintrBit+0x2c> @ imm = #0x8
700a4a72: e7ff         	b	0x700a4a74 <Udma_rmAllocVintrBit+0x24> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a4a74: 9802         	ldr	r0, [sp, #0x8]
700a4a76: 6900         	ldr	r0, [r0, #0x10]
700a4a78: 9003         	str	r0, [sp, #0xc]
;     }
700a4a7a: e7ff         	b	0x700a4a7c <Udma_rmAllocVintrBit+0x2c> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a4a7c: 9801         	ldr	r0, [sp, #0x4]
700a4a7e: f500 609f    	add.w	r0, r0, #0x4f8
700a4a82: f04f 31ff    	mov.w	r1, #0xffffffff
700a4a86: f003 fe33    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x3c66
700a4a8a: 2000         	movs	r0, #0x0
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a4a8c: 9008         	str	r0, [sp, #0x20]
700a4a8e: e7ff         	b	0x700a4a90 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x2
700a4a90: 9808         	ldr	r0, [sp, #0x20]
700a4a92: 283f         	cmp	r0, #0x3f
700a4a94: d83a         	bhi	0x700a4b0c <Udma_rmAllocVintrBit+0xbc> @ imm = #0x74
700a4a96: e7ff         	b	0x700a4a98 <Udma_rmAllocVintrBit+0x48> @ imm = #-0x2
;         bitMask = ((uint64_t) 1U << i);
700a4a98: 9b08         	ldr	r3, [sp, #0x20]
700a4a9a: f1a3 0220    	sub.w	r2, r3, #0x20
700a4a9e: 2101         	movs	r1, #0x1
700a4aa0: fa01 fc02    	lsl.w	r12, r1, r2
700a4aa4: f1c3 0020    	rsb.w	r0, r3, #0x20
700a4aa8: fa21 f000    	lsr.w	r0, r1, r0
700a4aac: 2a00         	cmp	r2, #0x0
700a4aae: bf58         	it	pl
700a4ab0: 4660         	movpl	r0, r12
700a4ab2: fa01 f103    	lsl.w	r1, r1, r3
700a4ab6: 2a00         	cmp	r2, #0x0
700a4ab8: bf58         	it	pl
700a4aba: 2100         	movpl	r1, #0x0
700a4abc: 9104         	str	r1, [sp, #0x10]
700a4abe: 9005         	str	r0, [sp, #0x14]
;         if((controllerEventHandle->vintrBitAllocFlag & bitMask) == 0U)
700a4ac0: 9903         	ldr	r1, [sp, #0xc]
700a4ac2: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a4ac6: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a4aca: 9a04         	ldr	r2, [sp, #0x10]
700a4acc: 9b05         	ldr	r3, [sp, #0x14]
700a4ace: ea01 0103    	and.w	r1, r1, r3
700a4ad2: ea00 0002    	and.w	r0, r0, r2
700a4ad6: ea40 0001    	orr.w	r0, r0, r1
700a4ada: b990         	cbnz	r0, 0x700a4b02 <Udma_rmAllocVintrBit+0xb2> @ imm = #0x24
700a4adc: e7ff         	b	0x700a4ade <Udma_rmAllocVintrBit+0x8e> @ imm = #-0x2
;             controllerEventHandle->vintrBitAllocFlag |= bitMask;
700a4ade: f8dd c010    	ldr.w	r12, [sp, #0x10]
700a4ae2: 9b05         	ldr	r3, [sp, #0x14]
700a4ae4: 9903         	ldr	r1, [sp, #0xc]
700a4ae6: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a4aea: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700a4aee: ea40 000c    	orr.w	r0, r0, r12
700a4af2: 431a         	orrs	r2, r3
700a4af4: f8c1 208c    	str.w	r2, [r1, #0x8c]
700a4af8: f8c1 0088    	str.w	r0, [r1, #0x88]
;             vintrBitNum = i;
700a4afc: 9808         	ldr	r0, [sp, #0x20]
700a4afe: 9007         	str	r0, [sp, #0x1c]
;             break;
700a4b00: e004         	b	0x700a4b0c <Udma_rmAllocVintrBit+0xbc> @ imm = #0x8
;     }
700a4b02: e7ff         	b	0x700a4b04 <Udma_rmAllocVintrBit+0xb4> @ imm = #-0x2
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a4b04: 9808         	ldr	r0, [sp, #0x20]
700a4b06: 3001         	adds	r0, #0x1
700a4b08: 9008         	str	r0, [sp, #0x20]
700a4b0a: e7c1         	b	0x700a4a90 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x7e
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a4b0c: 9801         	ldr	r0, [sp, #0x4]
700a4b0e: f500 609f    	add.w	r0, r0, #0x4f8
700a4b12: f005 f945    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x528a
;     return (vintrBitNum);
700a4b16: 9807         	ldr	r0, [sp, #0x1c]
700a4b18: b00a         	add	sp, #0x28
700a4b1a: bd80         	pop	{r7, pc}
700a4b1c: 0000         	movs	r0, r0
700a4b1e: 0000         	movs	r0, r0

700a4b20 <prvCopyDataToQueue>:
; {
700a4b20: b580         	push	{r7, lr}
700a4b22: b086         	sub	sp, #0x18
700a4b24: 9005         	str	r0, [sp, #0x14]
700a4b26: 9104         	str	r1, [sp, #0x10]
700a4b28: 9203         	str	r2, [sp, #0xc]
700a4b2a: 2000         	movs	r0, #0x0
;     BaseType_t xReturn = pdFALSE;
700a4b2c: 9002         	str	r0, [sp, #0x8]
;     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a4b2e: 9805         	ldr	r0, [sp, #0x14]
700a4b30: 6b80         	ldr	r0, [r0, #0x38]
700a4b32: 9001         	str	r0, [sp, #0x4]
;     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
700a4b34: 9805         	ldr	r0, [sp, #0x14]
700a4b36: 6c00         	ldr	r0, [r0, #0x40]
700a4b38: b978         	cbnz	r0, 0x700a4b5a <prvCopyDataToQueue+0x3a> @ imm = #0x1e
700a4b3a: e7ff         	b	0x700a4b3c <prvCopyDataToQueue+0x1c> @ imm = #-0x2
;                 if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a4b3c: 9805         	ldr	r0, [sp, #0x14]
700a4b3e: 6800         	ldr	r0, [r0]
700a4b40: b948         	cbnz	r0, 0x700a4b56 <prvCopyDataToQueue+0x36> @ imm = #0x12
700a4b42: e7ff         	b	0x700a4b44 <prvCopyDataToQueue+0x24> @ imm = #-0x2
;                     xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
700a4b44: 9805         	ldr	r0, [sp, #0x14]
700a4b46: 6880         	ldr	r0, [r0, #0x8]
700a4b48: f000 ff72    	bl	0x700a5a30 <xTaskPriorityDisinherit> @ imm = #0xee4
700a4b4c: 9002         	str	r0, [sp, #0x8]
;                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
700a4b4e: 9905         	ldr	r1, [sp, #0x14]
700a4b50: 2000         	movs	r0, #0x0
700a4b52: 6088         	str	r0, [r1, #0x8]
;                 }
700a4b54: e000         	b	0x700a4b58 <prvCopyDataToQueue+0x38> @ imm = #0x0
700a4b56: e7ff         	b	0x700a4b58 <prvCopyDataToQueue+0x38> @ imm = #-0x2
;     }
700a4b58: e041         	b	0x700a4bde <prvCopyDataToQueue+0xbe> @ imm = #0x82
;     else if( xPosition == queueSEND_TO_BACK )
700a4b5a: 9803         	ldr	r0, [sp, #0xc]
700a4b5c: b9b8         	cbnz	r0, 0x700a4b8e <prvCopyDataToQueue+0x6e> @ imm = #0x2e
700a4b5e: e7ff         	b	0x700a4b60 <prvCopyDataToQueue+0x40> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700a4b60: 9a05         	ldr	r2, [sp, #0x14]
700a4b62: 9904         	ldr	r1, [sp, #0x10]
700a4b64: 6850         	ldr	r0, [r2, #0x4]
700a4b66: 6c12         	ldr	r2, [r2, #0x40]
700a4b68: f7f5 ef38    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0xa190
;         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700a4b6c: 9905         	ldr	r1, [sp, #0x14]
700a4b6e: 6848         	ldr	r0, [r1, #0x4]
700a4b70: 6c0a         	ldr	r2, [r1, #0x40]
700a4b72: 4410         	add	r0, r2
700a4b74: 6048         	str	r0, [r1, #0x4]
;         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a4b76: 9905         	ldr	r1, [sp, #0x14]
700a4b78: 6848         	ldr	r0, [r1, #0x4]
700a4b7a: 6889         	ldr	r1, [r1, #0x8]
700a4b7c: 4288         	cmp	r0, r1
700a4b7e: d304         	blo	0x700a4b8a <prvCopyDataToQueue+0x6a> @ imm = #0x8
700a4b80: e7ff         	b	0x700a4b82 <prvCopyDataToQueue+0x62> @ imm = #-0x2
;             pxQueue->pcWriteTo = pxQueue->pcHead;
700a4b82: 9905         	ldr	r1, [sp, #0x14]
700a4b84: 6808         	ldr	r0, [r1]
700a4b86: 6048         	str	r0, [r1, #0x4]
;         }
700a4b88: e000         	b	0x700a4b8c <prvCopyDataToQueue+0x6c> @ imm = #0x0
700a4b8a: e7ff         	b	0x700a4b8c <prvCopyDataToQueue+0x6c> @ imm = #-0x2
;     }
700a4b8c: e026         	b	0x700a4bdc <prvCopyDataToQueue+0xbc> @ imm = #0x4c
;         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
700a4b8e: 9a05         	ldr	r2, [sp, #0x14]
700a4b90: 9904         	ldr	r1, [sp, #0x10]
700a4b92: 68d0         	ldr	r0, [r2, #0xc]
700a4b94: 6c12         	ldr	r2, [r2, #0x40]
700a4b96: f7f5 ef22    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0xa1bc
;         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
700a4b9a: 9905         	ldr	r1, [sp, #0x14]
700a4b9c: 68c8         	ldr	r0, [r1, #0xc]
700a4b9e: 6c0a         	ldr	r2, [r1, #0x40]
700a4ba0: 1a80         	subs	r0, r0, r2
700a4ba2: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a4ba4: 9805         	ldr	r0, [sp, #0x14]
700a4ba6: 6801         	ldr	r1, [r0]
700a4ba8: 68c0         	ldr	r0, [r0, #0xc]
700a4baa: 4288         	cmp	r0, r1
700a4bac: d206         	bhs	0x700a4bbc <prvCopyDataToQueue+0x9c> @ imm = #0xc
700a4bae: e7ff         	b	0x700a4bb0 <prvCopyDataToQueue+0x90> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
700a4bb0: 9905         	ldr	r1, [sp, #0x14]
700a4bb2: 6888         	ldr	r0, [r1, #0x8]
700a4bb4: 6c0a         	ldr	r2, [r1, #0x40]
700a4bb6: 1a80         	subs	r0, r0, r2
700a4bb8: 60c8         	str	r0, [r1, #0xc]
;         }
700a4bba: e000         	b	0x700a4bbe <prvCopyDataToQueue+0x9e> @ imm = #0x0
700a4bbc: e7ff         	b	0x700a4bbe <prvCopyDataToQueue+0x9e> @ imm = #-0x2
;         if( xPosition == queueOVERWRITE )
700a4bbe: 9803         	ldr	r0, [sp, #0xc]
700a4bc0: 2802         	cmp	r0, #0x2
700a4bc2: d109         	bne	0x700a4bd8 <prvCopyDataToQueue+0xb8> @ imm = #0x12
700a4bc4: e7ff         	b	0x700a4bc6 <prvCopyDataToQueue+0xa6> @ imm = #-0x2
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a4bc6: 9801         	ldr	r0, [sp, #0x4]
700a4bc8: b120         	cbz	r0, 0x700a4bd4 <prvCopyDataToQueue+0xb4> @ imm = #0x8
700a4bca: e7ff         	b	0x700a4bcc <prvCopyDataToQueue+0xac> @ imm = #-0x2
;                 --uxMessagesWaiting;
700a4bcc: 9801         	ldr	r0, [sp, #0x4]
700a4bce: 3801         	subs	r0, #0x1
700a4bd0: 9001         	str	r0, [sp, #0x4]
;             }
700a4bd2: e000         	b	0x700a4bd6 <prvCopyDataToQueue+0xb6> @ imm = #0x0
700a4bd4: e7ff         	b	0x700a4bd6 <prvCopyDataToQueue+0xb6> @ imm = #-0x2
;         }
700a4bd6: e000         	b	0x700a4bda <prvCopyDataToQueue+0xba> @ imm = #0x0
700a4bd8: e7ff         	b	0x700a4bda <prvCopyDataToQueue+0xba> @ imm = #-0x2
700a4bda: e7ff         	b	0x700a4bdc <prvCopyDataToQueue+0xbc> @ imm = #-0x2
700a4bdc: e7ff         	b	0x700a4bde <prvCopyDataToQueue+0xbe> @ imm = #-0x2
;     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a4bde: 9801         	ldr	r0, [sp, #0x4]
700a4be0: 3001         	adds	r0, #0x1
700a4be2: 9905         	ldr	r1, [sp, #0x14]
700a4be4: 6388         	str	r0, [r1, #0x38]
;     return xReturn;
700a4be6: 9802         	ldr	r0, [sp, #0x8]
700a4be8: b006         	add	sp, #0x18
700a4bea: bd80         	pop	{r7, pc}
700a4bec: 0000         	movs	r0, r0
700a4bee: 0000         	movs	r0, r0

700a4bf0 <CSL_bcdmaChanOpSetBurstSize>:
; {
700a4bf0: b580         	push	{r7, lr}
700a4bf2: b088         	sub	sp, #0x20
700a4bf4: 9007         	str	r0, [sp, #0x1c]
700a4bf6: 9106         	str	r1, [sp, #0x18]
700a4bf8: 9205         	str	r2, [sp, #0x14]
700a4bfa: 9304         	str	r3, [sp, #0x10]
700a4bfc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a4bfe: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a4c00: 9804         	ldr	r0, [sp, #0x10]
700a4c02: b920         	cbnz	r0, 0x700a4c0e <CSL_bcdmaChanOpSetBurstSize+0x1e> @ imm = #0x8
700a4c04: e7ff         	b	0x700a4c06 <CSL_bcdmaChanOpSetBurstSize+0x16> @ imm = #-0x2
700a4c06: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a4c0a: 9003         	str	r0, [sp, #0xc]
;     }
700a4c0c: e052         	b	0x700a4cb4 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #0xa4
;         CSL_BcdmaChanBurstSize burstSize = *(CSL_BcdmaChanBurstSize *)pOpData;
700a4c0e: 9804         	ldr	r0, [sp, #0x10]
700a4c10: 6800         	ldr	r0, [r0]
700a4c12: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a4c14: 9806         	ldr	r0, [sp, #0x18]
700a4c16: 9001         	str	r0, [sp, #0x4]
700a4c18: b140         	cbz	r0, 0x700a4c2c <CSL_bcdmaChanOpSetBurstSize+0x3c> @ imm = #0x10
700a4c1a: e7ff         	b	0x700a4c1c <CSL_bcdmaChanOpSetBurstSize+0x2c> @ imm = #-0x2
700a4c1c: 9801         	ldr	r0, [sp, #0x4]
700a4c1e: 2801         	cmp	r0, #0x1
700a4c20: d019         	beq	0x700a4c56 <CSL_bcdmaChanOpSetBurstSize+0x66> @ imm = #0x32
700a4c22: e7ff         	b	0x700a4c24 <CSL_bcdmaChanOpSetBurstSize+0x34> @ imm = #-0x2
700a4c24: 9801         	ldr	r0, [sp, #0x4]
700a4c26: 2802         	cmp	r0, #0x2
700a4c28: d02a         	beq	0x700a4c80 <CSL_bcdmaChanOpSetBurstSize+0x90> @ imm = #0x54
700a4c2a: e03e         	b	0x700a4caa <CSL_bcdmaChanOpSetBurstSize+0xba> @ imm = #0x7c
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES )   /* Block-copy supports 32, 64, and 128-byte bursts */
700a4c2c: 9802         	ldr	r0, [sp, #0x8]
700a4c2e: 2803         	cmp	r0, #0x3
700a4c30: d304         	blo	0x700a4c3c <CSL_bcdmaChanOpSetBurstSize+0x4c> @ imm = #0x8
700a4c32: e7ff         	b	0x700a4c34 <CSL_bcdmaChanOpSetBurstSize+0x44> @ imm = #-0x2
700a4c34: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a4c38: 9003         	str	r0, [sp, #0xc]
;                 }
700a4c3a: e00b         	b	0x700a4c54 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, burstSize );
700a4c3c: 9807         	ldr	r0, [sp, #0x1c]
700a4c3e: 6840         	ldr	r0, [r0, #0x4]
700a4c40: 9905         	ldr	r1, [sp, #0x14]
700a4c42: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a4c46: 9b02         	ldr	r3, [sp, #0x8]
700a4c48: f44f 6140    	mov.w	r1, #0xc00
700a4c4c: 220a         	movs	r2, #0xa
700a4c4e: f007 fa47    	bl	0x700ac0e0 <CSL_REG32_FINS_RAW> @ imm = #0x748e
700a4c52: e7ff         	b	0x700a4c54 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #-0x2
;                 break;
700a4c54: e02d         	b	0x700a4cb2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x5a
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-tx supports 32, and 64-byte bursts */
700a4c56: 9802         	ldr	r0, [sp, #0x8]
700a4c58: 2802         	cmp	r0, #0x2
700a4c5a: d304         	blo	0x700a4c66 <CSL_bcdmaChanOpSetBurstSize+0x76> @ imm = #0x8
700a4c5c: e7ff         	b	0x700a4c5e <CSL_bcdmaChanOpSetBurstSize+0x6e> @ imm = #-0x2
700a4c5e: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a4c62: 9003         	str	r0, [sp, #0xc]
;                 }
700a4c64: e00b         	b	0x700a4c7e <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, burstSize );
700a4c66: 9807         	ldr	r0, [sp, #0x1c]
700a4c68: 68c0         	ldr	r0, [r0, #0xc]
700a4c6a: 9905         	ldr	r1, [sp, #0x14]
700a4c6c: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a4c70: 9b02         	ldr	r3, [sp, #0x8]
700a4c72: f44f 6140    	mov.w	r1, #0xc00
700a4c76: 220a         	movs	r2, #0xa
700a4c78: f007 fa32    	bl	0x700ac0e0 <CSL_REG32_FINS_RAW> @ imm = #0x7464
700a4c7c: e7ff         	b	0x700a4c7e <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #-0x2
;                 break;
700a4c7e: e018         	b	0x700a4cb2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x30
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-rx supports 32, and 64-byte bursts */
700a4c80: 9802         	ldr	r0, [sp, #0x8]
700a4c82: 2802         	cmp	r0, #0x2
700a4c84: d304         	blo	0x700a4c90 <CSL_bcdmaChanOpSetBurstSize+0xa0> @ imm = #0x8
700a4c86: e7ff         	b	0x700a4c88 <CSL_bcdmaChanOpSetBurstSize+0x98> @ imm = #-0x2
700a4c88: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a4c8c: 9003         	str	r0, [sp, #0xc]
;                 }
700a4c8e: e00b         	b	0x700a4ca8 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, burstSize );
700a4c90: 9807         	ldr	r0, [sp, #0x1c]
700a4c92: 6940         	ldr	r0, [r0, #0x14]
700a4c94: 9905         	ldr	r1, [sp, #0x14]
700a4c96: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a4c9a: 9b02         	ldr	r3, [sp, #0x8]
700a4c9c: f44f 6140    	mov.w	r1, #0xc00
700a4ca0: 220a         	movs	r2, #0xa
700a4ca2: f007 fa1d    	bl	0x700ac0e0 <CSL_REG32_FINS_RAW> @ imm = #0x743a
700a4ca6: e7ff         	b	0x700a4ca8 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #-0x2
;                 break;
700a4ca8: e003         	b	0x700a4cb2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x6
700a4caa: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a4cae: 9003         	str	r0, [sp, #0xc]
;                 break;
700a4cb0: e7ff         	b	0x700a4cb2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #-0x2
700a4cb2: e7ff         	b	0x700a4cb4 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #-0x2
;     return retVal;
700a4cb4: 9803         	ldr	r0, [sp, #0xc]
700a4cb6: b008         	add	sp, #0x20
700a4cb8: bd80         	pop	{r7, pc}
700a4cba: 0000         	movs	r0, r0
700a4cbc: 0000         	movs	r0, r0
700a4cbe: 0000         	movs	r0, r0

700a4cc0 <Udma_ringCheckParams>:
; {
700a4cc0: b580         	push	{r7, lr}
700a4cc2: b084         	sub	sp, #0x10
700a4cc4: 9003         	str	r0, [sp, #0xc]
700a4cc6: 9102         	str	r1, [sp, #0x8]
700a4cc8: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a4cca: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR == ringPrms->ringMem)
700a4ccc: 9802         	ldr	r0, [sp, #0x8]
700a4cce: 6800         	ldr	r0, [r0]
700a4cd0: b920         	cbnz	r0, 0x700a4cdc <Udma_ringCheckParams+0x1c> @ imm = #0x8
700a4cd2: e7ff         	b	0x700a4cd4 <Udma_ringCheckParams+0x14> @ imm = #-0x2
700a4cd4: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a4cd8: 9001         	str	r0, [sp, #0x4]
;     }
700a4cda: e009         	b	0x700a4cf0 <Udma_ringCheckParams+0x30> @ imm = #0x12
;         if(((uintptr_t)ringPrms->ringMem & (UDMA_CACHELINE_ALIGNMENT - 1U)) != 0U)
700a4cdc: 9802         	ldr	r0, [sp, #0x8]
700a4cde: 7800         	ldrb	r0, [r0]
700a4ce0: 0640         	lsls	r0, r0, #0x19
700a4ce2: b120         	cbz	r0, 0x700a4cee <Udma_ringCheckParams+0x2e> @ imm = #0x8
700a4ce4: e7ff         	b	0x700a4ce6 <Udma_ringCheckParams+0x26> @ imm = #-0x2
700a4ce6: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a4cea: 9001         	str	r0, [sp, #0x4]
;         }
700a4cec: e7ff         	b	0x700a4cee <Udma_ringCheckParams+0x2e> @ imm = #-0x2
700a4cee: e7ff         	b	0x700a4cf0 <Udma_ringCheckParams+0x30> @ imm = #-0x2
;     if(0U == ringPrms->elemCnt)
700a4cf0: 9802         	ldr	r0, [sp, #0x8]
700a4cf2: 68c0         	ldr	r0, [r0, #0xc]
700a4cf4: b920         	cbnz	r0, 0x700a4d00 <Udma_ringCheckParams+0x40> @ imm = #0x8
700a4cf6: e7ff         	b	0x700a4cf8 <Udma_ringCheckParams+0x38> @ imm = #-0x2
700a4cf8: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a4cfc: 9001         	str	r0, [sp, #0x4]
;     }
700a4cfe: e7ff         	b	0x700a4d00 <Udma_ringCheckParams+0x40> @ imm = #-0x2
;     if(UDMA_INST_TYPE_NORMAL != drvHandle->instType)
700a4d00: 9803         	ldr	r0, [sp, #0xc]
700a4d02: 6800         	ldr	r0, [r0]
700a4d04: b148         	cbz	r0, 0x700a4d1a <Udma_ringCheckParams+0x5a> @ imm = #0x12
700a4d06: e7ff         	b	0x700a4d08 <Udma_ringCheckParams+0x48> @ imm = #-0x2
;         if(TISCI_MSG_VALUE_RM_RING_MODE_RING != ringPrms->mode)
700a4d08: 9802         	ldr	r0, [sp, #0x8]
700a4d0a: 7a00         	ldrb	r0, [r0, #0x8]
700a4d0c: b120         	cbz	r0, 0x700a4d18 <Udma_ringCheckParams+0x58> @ imm = #0x8
700a4d0e: e7ff         	b	0x700a4d10 <Udma_ringCheckParams+0x50> @ imm = #-0x2
700a4d10: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a4d14: 9001         	str	r0, [sp, #0x4]
;         }
700a4d16: e7ff         	b	0x700a4d18 <Udma_ringCheckParams+0x58> @ imm = #-0x2
;     }
700a4d18: e7ff         	b	0x700a4d1a <Udma_ringCheckParams+0x5a> @ imm = #-0x2
;     if(UDMA_RING_SIZE_CHECK_SKIP != ringPrms->ringMemSize)
700a4d1a: 9802         	ldr	r0, [sp, #0x8]
700a4d1c: 6840         	ldr	r0, [r0, #0x4]
700a4d1e: f64a 31cd    	movw	r1, #0xabcd
700a4d22: f6ca 31dc    	movt	r1, #0xabdc
700a4d26: 4288         	cmp	r0, r1
700a4d28: d012         	beq	0x700a4d50 <Udma_ringCheckParams+0x90> @ imm = #0x24
700a4d2a: e7ff         	b	0x700a4d2c <Udma_ringCheckParams+0x6c> @ imm = #-0x2
;                           ringPrms->mode,
700a4d2c: 9a02         	ldr	r2, [sp, #0x8]
700a4d2e: 7a10         	ldrb	r0, [r2, #0x8]
;                           ringPrms->elemCnt,
700a4d30: 68d1         	ldr	r1, [r2, #0xc]
;                           ringPrms->elemSize);
700a4d32: 7c12         	ldrb	r2, [r2, #0x10]
;         ringMemSize = UdmaUtils_getRingMemSize(
700a4d34: f006 fe04    	bl	0x700ab940 <UdmaUtils_getRingMemSize> @ imm = #0x6c08
700a4d38: 9000         	str	r0, [sp]
;         if(ringPrms->ringMemSize < ringMemSize)
700a4d3a: 9802         	ldr	r0, [sp, #0x8]
700a4d3c: 6840         	ldr	r0, [r0, #0x4]
700a4d3e: 9900         	ldr	r1, [sp]
700a4d40: 4288         	cmp	r0, r1
700a4d42: d204         	bhs	0x700a4d4e <Udma_ringCheckParams+0x8e> @ imm = #0x8
700a4d44: e7ff         	b	0x700a4d46 <Udma_ringCheckParams+0x86> @ imm = #-0x2
700a4d46: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
700a4d4a: 9001         	str	r0, [sp, #0x4]
;         }
700a4d4c: e7ff         	b	0x700a4d4e <Udma_ringCheckParams+0x8e> @ imm = #-0x2
;     }
700a4d4e: e7ff         	b	0x700a4d50 <Udma_ringCheckParams+0x90> @ imm = #-0x2
;     if (UDMA_RING_ORDERID_MAX < ringPrms->orderId)
700a4d50: 9802         	ldr	r0, [sp, #0x8]
700a4d52: 7c40         	ldrb	r0, [r0, #0x11]
700a4d54: 2810         	cmp	r0, #0x10
700a4d56: d304         	blo	0x700a4d62 <Udma_ringCheckParams+0xa2> @ imm = #0x8
700a4d58: e7ff         	b	0x700a4d5a <Udma_ringCheckParams+0x9a> @ imm = #-0x2
700a4d5a: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a4d5e: 9001         	str	r0, [sp, #0x4]
;     }
700a4d60: e7ff         	b	0x700a4d62 <Udma_ringCheckParams+0xa2> @ imm = #-0x2
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a4d62: 9802         	ldr	r0, [sp, #0x8]
700a4d64: 6940         	ldr	r0, [r0, #0x14]
700a4d66: 2104         	movs	r1, #0x4
700a4d68: f6cf 71ff    	movt	r1, #0xffff
700a4d6c: 4288         	cmp	r0, r1
700a4d6e: d009         	beq	0x700a4d84 <Udma_ringCheckParams+0xc4> @ imm = #0x12
700a4d70: e7ff         	b	0x700a4d72 <Udma_ringCheckParams+0xb2> @ imm = #-0x2
;        (ringPrms->mappedRingGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a4d72: 9802         	ldr	r0, [sp, #0x8]
700a4d74: 6940         	ldr	r0, [r0, #0x14]
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a4d76: 2808         	cmp	r0, #0x8
700a4d78: d304         	blo	0x700a4d84 <Udma_ringCheckParams+0xc4> @ imm = #0x8
700a4d7a: e7ff         	b	0x700a4d7c <Udma_ringCheckParams+0xbc> @ imm = #-0x2
700a4d7c: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a4d80: 9001         	str	r0, [sp, #0x4]
;     }
700a4d82: e7ff         	b	0x700a4d84 <Udma_ringCheckParams+0xc4> @ imm = #-0x2
;     return (retVal);
700a4d84: 9801         	ldr	r0, [sp, #0x4]
700a4d86: b004         	add	sp, #0x10
700a4d88: bd80         	pop	{r7, pc}
700a4d8a: 0000         	movs	r0, r0
700a4d8c: 0000         	movs	r0, r0
700a4d8e: 0000         	movs	r0, r0

700a4d90 <UART_lld_writeDma>:
; {
700a4d90: b580         	push	{r7, lr}
700a4d92: b086         	sub	sp, #0x18
700a4d94: 9005         	str	r0, [sp, #0x14]
700a4d96: 9104         	str	r1, [sp, #0x10]
700a4d98: 9203         	str	r2, [sp, #0xc]
700a4d9a: 9302         	str	r3, [sp, #0x8]
700a4d9c: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a4d9e: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a4da0: 9805         	ldr	r0, [sp, #0x14]
700a4da2: 2800         	cmp	r0, #0x0
700a4da4: d051         	beq	0x700a4e4a <UART_lld_writeDma+0xba> @ imm = #0xa2
700a4da6: e7ff         	b	0x700a4da8 <UART_lld_writeDma+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a4da8: 9805         	ldr	r0, [sp, #0x14]
700a4daa: 303c         	adds	r0, #0x3c
700a4dac: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a4dae: 9800         	ldr	r0, [sp]
700a4db0: 6800         	ldr	r0, [r0]
700a4db2: b138         	cbz	r0, 0x700a4dc4 <UART_lld_writeDma+0x34> @ imm = #0xe
700a4db4: e7ff         	b	0x700a4db6 <UART_lld_writeDma+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a4db6: 9900         	ldr	r1, [sp]
700a4db8: 2009         	movs	r0, #0x9
700a4dba: 60c8         	str	r0, [r1, #0xc]
700a4dbc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a4dc0: 9001         	str	r0, [sp, #0x4]
;         }
700a4dc2: e041         	b	0x700a4e48 <UART_lld_writeDma+0xb8> @ imm = #0x82
;             UART_lld_Transaction_init(trans);
700a4dc4: 9800         	ldr	r0, [sp]
700a4dc6: f007 fef3    	bl	0x700acbb0 <UART_lld_Transaction_init> @ imm = #0x7de6
;             if(extendedParams != NULL)
700a4dca: 9802         	ldr	r0, [sp, #0x8]
700a4dcc: b128         	cbz	r0, 0x700a4dda <UART_lld_writeDma+0x4a> @ imm = #0xa
700a4dce: e7ff         	b	0x700a4dd0 <UART_lld_writeDma+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a4dd0: 9802         	ldr	r0, [sp, #0x8]
700a4dd2: 6800         	ldr	r0, [r0]
700a4dd4: 9900         	ldr	r1, [sp]
700a4dd6: 6108         	str	r0, [r1, #0x10]
;             }
700a4dd8: e003         	b	0x700a4de2 <UART_lld_writeDma+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a4dda: 9900         	ldr	r1, [sp]
700a4ddc: 2000         	movs	r0, #0x0
700a4dde: 6108         	str	r0, [r1, #0x10]
700a4de0: e7ff         	b	0x700a4de2 <UART_lld_writeDma+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a4de2: 9804         	ldr	r0, [sp, #0x10]
700a4de4: 9900         	ldr	r1, [sp]
700a4de6: 6008         	str	r0, [r1]
;             trans->count = size;
700a4de8: 9803         	ldr	r0, [sp, #0xc]
700a4dea: 9900         	ldr	r1, [sp]
700a4dec: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a4dee: 9805         	ldr	r0, [sp, #0x14]
700a4df0: 6d40         	ldr	r0, [r0, #0x54]
700a4df2: 2801         	cmp	r0, #0x1
700a4df4: d105         	bne	0x700a4e02 <UART_lld_writeDma+0x72> @ imm = #0xa
700a4df6: e7ff         	b	0x700a4df8 <UART_lld_writeDma+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a4df8: 9800         	ldr	r0, [sp]
700a4dfa: f007 faf1    	bl	0x700ac3e0 <UART_checkTransaction> @ imm = #0x75e2
700a4dfe: 9001         	str	r0, [sp, #0x4]
;             }
700a4e00: e003         	b	0x700a4e0a <UART_lld_writeDma+0x7a> @ imm = #0x6
700a4e02: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a4e06: 9001         	str	r0, [sp, #0x4]
700a4e08: e7ff         	b	0x700a4e0a <UART_lld_writeDma+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a4e0a: 9801         	ldr	r0, [sp, #0x4]
700a4e0c: b9d8         	cbnz	r0, 0x700a4e46 <UART_lld_writeDma+0xb6> @ imm = #0x36
700a4e0e: e7ff         	b	0x700a4e10 <UART_lld_writeDma+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a4e10: 9800         	ldr	r0, [sp]
700a4e12: 6800         	ldr	r0, [r0]
700a4e14: 9905         	ldr	r1, [sp, #0x14]
700a4e16: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a4e18: 9800         	ldr	r0, [sp]
700a4e1a: 6880         	ldr	r0, [r0, #0x8]
700a4e1c: 9905         	ldr	r1, [sp, #0x14]
700a4e1e: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a4e20: 9905         	ldr	r1, [sp, #0x14]
700a4e22: 2000         	movs	r0, #0x0
700a4e24: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a4e26: 9800         	ldr	r0, [sp]
700a4e28: 6840         	ldr	r0, [r0, #0x4]
700a4e2a: 9905         	ldr	r1, [sp, #0x14]
700a4e2c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a4e2e: 9905         	ldr	r1, [sp, #0x14]
700a4e30: 2002         	movs	r0, #0x2
700a4e32: 6548         	str	r0, [r1, #0x54]
;                 status = UART_lld_dmaWrite(hUart, trans);
700a4e34: 9805         	ldr	r0, [sp, #0x14]
700a4e36: 9900         	ldr	r1, [sp]
700a4e38: f007 fed2    	bl	0x700acbe0 <UART_lld_dmaWrite> @ imm = #0x7da4
700a4e3c: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a4e3e: 9905         	ldr	r1, [sp, #0x14]
700a4e40: 2001         	movs	r0, #0x1
700a4e42: 6548         	str	r0, [r1, #0x54]
;             }
700a4e44: e7ff         	b	0x700a4e46 <UART_lld_writeDma+0xb6> @ imm = #-0x2
700a4e46: e7ff         	b	0x700a4e48 <UART_lld_writeDma+0xb8> @ imm = #-0x2
;     }
700a4e48: e003         	b	0x700a4e52 <UART_lld_writeDma+0xc2> @ imm = #0x6
700a4e4a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a4e4e: 9001         	str	r0, [sp, #0x4]
700a4e50: e7ff         	b	0x700a4e52 <UART_lld_writeDma+0xc2> @ imm = #-0x2
;     return status;
700a4e52: 9801         	ldr	r0, [sp, #0x4]
700a4e54: b006         	add	sp, #0x18
700a4e56: bd80         	pop	{r7, pc}
		...

700a4e60 <UART_udmaHpdInit>:
; {
700a4e60: b580         	push	{r7, lr}
700a4e62: b08a         	sub	sp, #0x28
700a4e64: 9009         	str	r0, [sp, #0x24]
700a4e66: 9108         	str	r1, [sp, #0x20]
700a4e68: 9207         	str	r2, [sp, #0x1c]
700a4e6a: 9306         	str	r3, [sp, #0x18]
;     CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700a4e6c: 9808         	ldr	r0, [sp, #0x20]
700a4e6e: 9005         	str	r0, [sp, #0x14]
700a4e70: 2001         	movs	r0, #0x1
;     uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700a4e72: 9004         	str	r0, [sp, #0x10]
;     CSL_udmapCppi5SetDescType(pHpd, descType);
700a4e74: 9805         	ldr	r0, [sp, #0x14]
700a4e76: 9904         	ldr	r1, [sp, #0x10]
700a4e78: f008 fa82    	bl	0x700ad380 <CSL_udmapCppi5SetDescType> @ imm = #0x8504
;     CSL_udmapCppi5SetEpiDataPresent(pHpd, FALSE);
700a4e7c: 9805         	ldr	r0, [sp, #0x14]
700a4e7e: 2100         	movs	r1, #0x0
700a4e80: 9102         	str	r1, [sp, #0x8]
700a4e82: f008 f97d    	bl	0x700ad180 <CSL_udmapCppi5SetEpiDataPresent> @ imm = #0x82fa
700a4e86: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLoc(pHpd, 0U);
700a4e88: 9805         	ldr	r0, [sp, #0x14]
700a4e8a: f008 fb81    	bl	0x700ad590 <CSL_udmapCppi5SetPsDataLoc> @ imm = #0x8702
700a4e8e: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLen(pHpd, 0U);
700a4e90: 9805         	ldr	r0, [sp, #0x14]
700a4e92: f008 faa5    	bl	0x700ad3e0 <CSL_udmapCppi5SetPsDataLen> @ imm = #0x854a
;     CSL_udmapCppi5SetPktLen(pHpd, descType, length);
700a4e96: 9805         	ldr	r0, [sp, #0x14]
700a4e98: 9904         	ldr	r1, [sp, #0x10]
700a4e9a: 9a06         	ldr	r2, [sp, #0x18]
700a4e9c: f006 fcd8    	bl	0x700ab850 <CSL_udmapCppi5SetPktLen> @ imm = #0x69b0
700a4ea0: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsFlags(pHpd, 0U);
700a4ea2: 9805         	ldr	r0, [sp, #0x14]
700a4ea4: f008 fb84    	bl	0x700ad5b0 <CSL_udmapCppi5SetPsFlags> @ imm = #0x8708
;     CSL_udmapCppi5SetIds(pHpd, descType, 0x321, UDMA_DEFAULT_FLOW_ID);
700a4ea8: 9805         	ldr	r0, [sp, #0x14]
700a4eaa: 9904         	ldr	r1, [sp, #0x10]
700a4eac: f240 3221    	movw	r2, #0x321
700a4eb0: f643 73ff    	movw	r3, #0x3fff
700a4eb4: f004 fd7c    	bl	0x700a99b0 <CSL_udmapCppi5SetIds> @ imm = #0x4af8
700a4eb8: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetSrcTag(pHpd, 0x0000);     /* Not used */
700a4eba: 9805         	ldr	r0, [sp, #0x14]
700a4ebc: f008 fc38    	bl	0x700ad730 <CSL_udmapCppi5SetSrcTag> @ imm = #0x8870
700a4ec0: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetDstTag(pHpd, 0x0000);     /* Not used */
700a4ec2: 9805         	ldr	r0, [sp, #0x14]
700a4ec4: f008 fcd4    	bl	0x700ad870 <CSL_udmapCppi5SetDstTag> @ imm = #0x89a8
;     UART_udmapSetReturnPolicy(chHandle, pHpdMem);
700a4ec8: 9809         	ldr	r0, [sp, #0x24]
700a4eca: 9908         	ldr	r1, [sp, #0x20]
700a4ecc: f007 ff48    	bl	0x700acd60 <UART_udmapSetReturnPolicy> @ imm = #0x7e90
700a4ed0: 9b02         	ldr	r3, [sp, #0x8]
;     CSL_udmapCppi5LinkDesc(pHpd, 0U);
700a4ed2: 9805         	ldr	r0, [sp, #0x14]
700a4ed4: 461a         	mov	r2, r3
700a4ed6: f008 fb1b    	bl	0x700ad510 <CSL_udmapCppi5LinkDesc> @ imm = #0x8636
700a4eda: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a4edc: 9805         	ldr	r0, [sp, #0x14]
700a4ede: 9001         	str	r0, [sp, #0x4]
700a4ee0: 9807         	ldr	r0, [sp, #0x1c]
700a4ee2: 4611         	mov	r1, r2
700a4ee4: f008 fcfc    	bl	0x700ad8e0 <Udma_defaultVirtToPhyFxn> @ imm = #0x89f8
700a4ee8: 4602         	mov	r2, r0
700a4eea: 9801         	ldr	r0, [sp, #0x4]
700a4eec: 460b         	mov	r3, r1
700a4eee: f008 fb1f    	bl	0x700ad530 <CSL_udmapCppi5SetBufferAddr> @ imm = #0x863e
;     CSL_udmapCppi5SetBufferLen(pHpd, length);
700a4ef2: 9805         	ldr	r0, [sp, #0x14]
700a4ef4: 9906         	ldr	r1, [sp, #0x18]
700a4ef6: f008 fb2b    	bl	0x700ad550 <CSL_udmapCppi5SetBufferLen> @ imm = #0x8656
700a4efa: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetOrgBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a4efc: 9805         	ldr	r0, [sp, #0x14]
700a4efe: 9003         	str	r0, [sp, #0xc]
700a4f00: 9807         	ldr	r0, [sp, #0x1c]
700a4f02: 4611         	mov	r1, r2
700a4f04: f008 fcec    	bl	0x700ad8e0 <Udma_defaultVirtToPhyFxn> @ imm = #0x89d8
700a4f08: 4602         	mov	r2, r0
700a4f0a: 9803         	ldr	r0, [sp, #0xc]
700a4f0c: 460b         	mov	r3, r1
700a4f0e: f008 fb2f    	bl	0x700ad570 <CSL_udmapCppi5SetOrgBufferAddr> @ imm = #0x865e
;     CSL_udmapCppi5SetOrgBufferLen(pHpd, length);
700a4f12: 9805         	ldr	r0, [sp, #0x14]
700a4f14: 9906         	ldr	r1, [sp, #0x18]
700a4f16: f008 fcb3    	bl	0x700ad880 <CSL_udmapCppi5SetOrgBufferLen> @ imm = #0x8966
;     CacheP_wb(pHpdMem, sizeof(CSL_UdmapCppi5HMPD), CacheP_TYPE_ALLD);
700a4f1a: 9808         	ldr	r0, [sp, #0x20]
700a4f1c: 2130         	movs	r1, #0x30
700a4f1e: 220a         	movs	r2, #0xa
700a4f20: f009 ec80    	blx	0x700ae824 <CacheP_wb>  @ imm = #0x9900
;     return;
700a4f24: b00a         	add	sp, #0x28
700a4f26: bd80         	pop	{r7, pc}
		...

700a4f30 <Udma_eventCheckUnRegister>:
; {
700a4f30: b580         	push	{r7, lr}
700a4f32: b088         	sub	sp, #0x20
700a4f34: 9007         	str	r0, [sp, #0x1c]
700a4f36: 9106         	str	r1, [sp, #0x18]
700a4f38: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a4f3a: 9005         	str	r0, [sp, #0x14]
;     eventPrms = &eventHandle->eventPrms;
700a4f3c: 9806         	ldr	r0, [sp, #0x18]
700a4f3e: 3008         	adds	r0, #0x8
700a4f40: 9004         	str	r0, [sp, #0x10]
;     if(eventHandle->eventInitDone != UDMA_INIT_DONE)
700a4f42: 9806         	ldr	r0, [sp, #0x18]
700a4f44: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700a4f48: f64a 31cd    	movw	r1, #0xabcd
700a4f4c: f6ca 31dc    	movt	r1, #0xabdc
700a4f50: 4288         	cmp	r0, r1
700a4f52: d004         	beq	0x700a4f5e <Udma_eventCheckUnRegister+0x2e> @ imm = #0x8
700a4f54: e7ff         	b	0x700a4f56 <Udma_eventCheckUnRegister+0x26> @ imm = #-0x2
700a4f56: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = UDMA_EFAIL;
700a4f5a: 9005         	str	r0, [sp, #0x14]
;     }
700a4f5c: e7ff         	b	0x700a4f5e <Udma_eventCheckUnRegister+0x2e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a4f5e: 9805         	ldr	r0, [sp, #0x14]
700a4f60: b968         	cbnz	r0, 0x700a4f7e <Udma_eventCheckUnRegister+0x4e> @ imm = #0x1a
700a4f62: e7ff         	b	0x700a4f64 <Udma_eventCheckUnRegister+0x34> @ imm = #-0x2
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a4f64: 9804         	ldr	r0, [sp, #0x10]
700a4f66: 6900         	ldr	r0, [r0, #0x10]
700a4f68: b940         	cbnz	r0, 0x700a4f7c <Udma_eventCheckUnRegister+0x4c> @ imm = #0x10
700a4f6a: e7ff         	b	0x700a4f6c <Udma_eventCheckUnRegister+0x3c> @ imm = #-0x2
;            (NULL_PTR != eventHandle->nextEvent))
700a4f6c: 9806         	ldr	r0, [sp, #0x18]
700a4f6e: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a4f70: b120         	cbz	r0, 0x700a4f7c <Udma_eventCheckUnRegister+0x4c> @ imm = #0x8
700a4f72: e7ff         	b	0x700a4f74 <Udma_eventCheckUnRegister+0x44> @ imm = #-0x2
700a4f74: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a4f78: 9005         	str	r0, [sp, #0x14]
;         }
700a4f7a: e7ff         	b	0x700a4f7c <Udma_eventCheckUnRegister+0x4c> @ imm = #-0x2
;     }
700a4f7c: e7ff         	b	0x700a4f7e <Udma_eventCheckUnRegister+0x4e> @ imm = #-0x2
;      if(UDMA_SOK == retVal)
700a4f7e: 9805         	ldr	r0, [sp, #0x14]
700a4f80: bbb8         	cbnz	r0, 0x700a4ff2 <Udma_eventCheckUnRegister+0xc2> @ imm = #0x6e
700a4f82: e7ff         	b	0x700a4f84 <Udma_eventCheckUnRegister+0x54> @ imm = #-0x2
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a4f84: 9804         	ldr	r0, [sp, #0x10]
700a4f86: 6800         	ldr	r0, [r0]
700a4f88: 2801         	cmp	r0, #0x1
700a4f8a: d00a         	beq	0x700a4fa2 <Udma_eventCheckUnRegister+0x72> @ imm = #0x14
700a4f8c: e7ff         	b	0x700a4f8e <Udma_eventCheckUnRegister+0x5e> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a4f8e: 9804         	ldr	r0, [sp, #0x10]
700a4f90: 6800         	ldr	r0, [r0]
700a4f92: 2806         	cmp	r0, #0x6
700a4f94: d005         	beq	0x700a4fa2 <Udma_eventCheckUnRegister+0x72> @ imm = #0xa
700a4f96: e7ff         	b	0x700a4f98 <Udma_eventCheckUnRegister+0x68> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_RING == eventPrms->eventType))
700a4f98: 9804         	ldr	r0, [sp, #0x10]
700a4f9a: 6800         	ldr	r0, [r0]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a4f9c: 2804         	cmp	r0, #0x4
700a4f9e: d127         	bne	0x700a4ff0 <Udma_eventCheckUnRegister+0xc0> @ imm = #0x4e
700a4fa0: e7ff         	b	0x700a4fa2 <Udma_eventCheckUnRegister+0x72> @ imm = #-0x2
;             if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a4fa2: 9804         	ldr	r0, [sp, #0x10]
700a4fa4: 6800         	ldr	r0, [r0]
700a4fa6: 2801         	cmp	r0, #0x1
700a4fa8: d005         	beq	0x700a4fb6 <Udma_eventCheckUnRegister+0x86> @ imm = #0xa
700a4faa: e7ff         	b	0x700a4fac <Udma_eventCheckUnRegister+0x7c> @ imm = #-0x2
700a4fac: 9804         	ldr	r0, [sp, #0x10]
700a4fae: 6800         	ldr	r0, [r0]
700a4fb0: 2806         	cmp	r0, #0x6
700a4fb2: d106         	bne	0x700a4fc2 <Udma_eventCheckUnRegister+0x92> @ imm = #0xc
700a4fb4: e7ff         	b	0x700a4fb6 <Udma_eventCheckUnRegister+0x86> @ imm = #-0x2
;                 ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a4fb6: 9804         	ldr	r0, [sp, #0x10]
700a4fb8: 6880         	ldr	r0, [r0, #0x8]
700a4fba: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a4fbe: 9003         	str	r0, [sp, #0xc]
;             }
700a4fc0: e003         	b	0x700a4fca <Udma_eventCheckUnRegister+0x9a> @ imm = #0x6
;                 ringHandle = eventPrms->ringHandle;
700a4fc2: 9804         	ldr	r0, [sp, #0x10]
700a4fc4: 68c0         	ldr	r0, [r0, #0xc]
700a4fc6: 9003         	str	r0, [sp, #0xc]
700a4fc8: e7ff         	b	0x700a4fca <Udma_eventCheckUnRegister+0x9a> @ imm = #-0x2
;             fOcc = Udma_ringGetForwardRingOcc(ringHandle);
700a4fca: 9803         	ldr	r0, [sp, #0xc]
700a4fcc: f007 fee0    	bl	0x700acd90 <Udma_ringGetForwardRingOcc> @ imm = #0x7dc0
700a4fd0: 9002         	str	r0, [sp, #0x8]
;             rOcc = Udma_ringGetReverseRingOcc(ringHandle);
700a4fd2: 9803         	ldr	r0, [sp, #0xc]
700a4fd4: f007 fef4    	bl	0x700acdc0 <Udma_ringGetReverseRingOcc> @ imm = #0x7de8
700a4fd8: 9001         	str	r0, [sp, #0x4]
;             if((0U != fOcc) || (0U != rOcc))
700a4fda: 9802         	ldr	r0, [sp, #0x8]
700a4fdc: b918         	cbnz	r0, 0x700a4fe6 <Udma_eventCheckUnRegister+0xb6> @ imm = #0x6
700a4fde: e7ff         	b	0x700a4fe0 <Udma_eventCheckUnRegister+0xb0> @ imm = #-0x2
700a4fe0: 9801         	ldr	r0, [sp, #0x4]
700a4fe2: b120         	cbz	r0, 0x700a4fee <Udma_eventCheckUnRegister+0xbe> @ imm = #0x8
700a4fe4: e7ff         	b	0x700a4fe6 <Udma_eventCheckUnRegister+0xb6> @ imm = #-0x2
700a4fe6: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = UDMA_EFAIL;
700a4fea: 9005         	str	r0, [sp, #0x14]
;             }
700a4fec: e7ff         	b	0x700a4fee <Udma_eventCheckUnRegister+0xbe> @ imm = #-0x2
;         }
700a4fee: e7ff         	b	0x700a4ff0 <Udma_eventCheckUnRegister+0xc0> @ imm = #-0x2
;     }
700a4ff0: e7ff         	b	0x700a4ff2 <Udma_eventCheckUnRegister+0xc2> @ imm = #-0x2
;     return (retVal);
700a4ff2: 9805         	ldr	r0, [sp, #0x14]
700a4ff4: b008         	add	sp, #0x20
700a4ff6: bd80         	pop	{r7, pc}
		...

700a5000 <Udma_ringFree>:
; {
700a5000: b580         	push	{r7, lr}
700a5002: b086         	sub	sp, #0x18
700a5004: 9005         	str	r0, [sp, #0x14]
700a5006: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a5008: 9004         	str	r0, [sp, #0x10]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a500a: 9805         	ldr	r0, [sp, #0x14]
700a500c: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == ringHandleInt)
700a500e: 9802         	ldr	r0, [sp, #0x8]
700a5010: b920         	cbnz	r0, 0x700a501c <Udma_ringFree+0x1c> @ imm = #0x8
700a5012: e7ff         	b	0x700a5014 <Udma_ringFree+0x14> @ imm = #-0x2
700a5014: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a5018: 9004         	str	r0, [sp, #0x10]
;     }
700a501a: e7ff         	b	0x700a501c <Udma_ringFree+0x1c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a501c: 9804         	ldr	r0, [sp, #0x10]
700a501e: b970         	cbnz	r0, 0x700a503e <Udma_ringFree+0x3e> @ imm = #0x1c
700a5020: e7ff         	b	0x700a5022 <Udma_ringFree+0x22> @ imm = #-0x2
;         if(ringHandleInt->ringInitDone != UDMA_INIT_DONE)
700a5022: 9802         	ldr	r0, [sp, #0x8]
700a5024: 6d80         	ldr	r0, [r0, #0x58]
700a5026: f64a 31cd    	movw	r1, #0xabcd
700a502a: f6ca 31dc    	movt	r1, #0xabdc
700a502e: 4288         	cmp	r0, r1
700a5030: d004         	beq	0x700a503c <Udma_ringFree+0x3c> @ imm = #0x8
700a5032: e7ff         	b	0x700a5034 <Udma_ringFree+0x34> @ imm = #-0x2
700a5034: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a5038: 9004         	str	r0, [sp, #0x10]
;         }
700a503a: e7ff         	b	0x700a503c <Udma_ringFree+0x3c> @ imm = #-0x2
;     }
700a503c: e7ff         	b	0x700a503e <Udma_ringFree+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a503e: 9804         	ldr	r0, [sp, #0x10]
700a5040: b9a8         	cbnz	r0, 0x700a506e <Udma_ringFree+0x6e> @ imm = #0x2a
700a5042: e7ff         	b	0x700a5044 <Udma_ringFree+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a5044: 9802         	ldr	r0, [sp, #0x8]
700a5046: 6800         	ldr	r0, [r0]
700a5048: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a504a: 9803         	ldr	r0, [sp, #0xc]
700a504c: b150         	cbz	r0, 0x700a5064 <Udma_ringFree+0x64> @ imm = #0x14
700a504e: e7ff         	b	0x700a5050 <Udma_ringFree+0x50> @ imm = #-0x2
700a5050: 9803         	ldr	r0, [sp, #0xc]
700a5052: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a5056: f64a 31cd    	movw	r1, #0xabcd
700a505a: f6ca 31dc    	movt	r1, #0xabdc
700a505e: 4288         	cmp	r0, r1
700a5060: d004         	beq	0x700a506c <Udma_ringFree+0x6c> @ imm = #0x8
700a5062: e7ff         	b	0x700a5064 <Udma_ringFree+0x64> @ imm = #-0x2
700a5064: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a5068: 9004         	str	r0, [sp, #0x10]
;         }
700a506a: e7ff         	b	0x700a506c <Udma_ringFree+0x6c> @ imm = #-0x2
;     }
700a506c: e7ff         	b	0x700a506e <Udma_ringFree+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a506e: 9804         	ldr	r0, [sp, #0x10]
700a5070: bb38         	cbnz	r0, 0x700a50c2 <Udma_ringFree+0xc2> @ imm = #0x4e
700a5072: e7ff         	b	0x700a5074 <Udma_ringFree+0x74> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == ringHandleInt->mappedRingGrp)
700a5074: 9802         	ldr	r0, [sp, #0x8]
700a5076: 6dc0         	ldr	r0, [r0, #0x5c]
700a5078: 2104         	movs	r1, #0x4
700a507a: f6cf 71ff    	movt	r1, #0xffff
700a507e: 4288         	cmp	r0, r1
700a5080: d106         	bne	0x700a5090 <Udma_ringFree+0x90> @ imm = #0xc
700a5082: e7ff         	b	0x700a5084 <Udma_ringFree+0x84> @ imm = #-0x2
;             Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandle);
700a5084: 9802         	ldr	r0, [sp, #0x8]
700a5086: 8880         	ldrh	r0, [r0, #0x4]
700a5088: 9903         	ldr	r1, [sp, #0xc]
700a508a: f008 fca9    	bl	0x700ad9e0 <Udma_rmFreeFreeRing> @ imm = #0x8952
;         }
700a508e: e007         	b	0x700a50a0 <Udma_ringFree+0xa0> @ imm = #0xe
;                 ringHandleInt->ringNum,
700a5090: 9b02         	ldr	r3, [sp, #0x8]
700a5092: 8898         	ldrh	r0, [r3, #0x4]
;                 drvHandle,
700a5094: 9903         	ldr	r1, [sp, #0xc]
;                 ringHandleInt->mappedRingGrp,
700a5096: 6dda         	ldr	r2, [r3, #0x5c]
;                 ringHandleInt->mappedChNum);
700a5098: 6e1b         	ldr	r3, [r3, #0x60]
;             Udma_rmFreeMappedRing(
700a509a: f002 fe19    	bl	0x700a7cd0 <Udma_rmFreeMappedRing> @ imm = #0x2c32
700a509e: e7ff         	b	0x700a50a0 <Udma_ringFree+0xa0> @ imm = #-0x2
;         ringHandleInt->ringNum         = UDMA_RING_INVALID;
700a50a0: 9902         	ldr	r1, [sp, #0x8]
700a50a2: f64f 70ff    	movw	r0, #0xffff
700a50a6: 8088         	strh	r0, [r1, #0x4]
;         ringHandleInt->ringInitDone    = UDMA_DEINIT_DONE;
700a50a8: 9902         	ldr	r1, [sp, #0x8]
700a50aa: 2000         	movs	r0, #0x0
700a50ac: 9001         	str	r0, [sp, #0x4]
700a50ae: 6588         	str	r0, [r1, #0x58]
;         drvHandle->ringHandleClearRegs(ringHandleInt);
700a50b0: 9803         	ldr	r0, [sp, #0xc]
700a50b2: f8d0 15c8    	ldr.w	r1, [r0, #0x5c8]
700a50b6: 9802         	ldr	r0, [sp, #0x8]
700a50b8: 4788         	blx	r1
700a50ba: 9801         	ldr	r0, [sp, #0x4]
;         ringHandleInt->drvHandle       = (Udma_DrvHandleInt) NULL_PTR;
700a50bc: 9902         	ldr	r1, [sp, #0x8]
700a50be: 6008         	str	r0, [r1]
;     }
700a50c0: e7ff         	b	0x700a50c2 <Udma_ringFree+0xc2> @ imm = #-0x2
;     return (retVal);
700a50c2: 9804         	ldr	r0, [sp, #0x10]
700a50c4: b006         	add	sp, #0x18
700a50c6: bd80         	pop	{r7, pc}
		...

700a50d0 <vTaskSwitchContext>:
; void vTaskSwitchContext(void) {
700a50d0: b082         	sub	sp, #0x8
;   if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
700a50d2: f240 5000    	movw	r0, #0x500
700a50d6: f2c7 000b    	movt	r0, #0x700b
700a50da: 6800         	ldr	r0, [r0]
700a50dc: b138         	cbz	r0, 0x700a50ee <vTaskSwitchContext+0x1e> @ imm = #0xe
700a50de: e7ff         	b	0x700a50e0 <vTaskSwitchContext+0x10> @ imm = #-0x2
;     xYieldPending = pdTRUE;
700a50e0: f240 512c    	movw	r1, #0x52c
700a50e4: f2c7 010b    	movt	r1, #0x700b
700a50e8: 2001         	movs	r0, #0x1
700a50ea: 6008         	str	r0, [r1]
;   } else {
700a50ec: e052         	b	0x700a5194 <vTaskSwitchContext+0xc4> @ imm = #0xa4
;     xYieldPending = pdFALSE;
700a50ee: f240 512c    	movw	r1, #0x52c
700a50f2: f2c7 010b    	movt	r1, #0x700b
700a50f6: 2000         	movs	r0, #0x0
700a50f8: 6008         	str	r0, [r1]
;       pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
700a50fa: f240 40a0    	movw	r0, #0x4a0
700a50fe: f2c7 000b    	movt	r0, #0x700b
700a5102: 6800         	ldr	r0, [r0]
700a5104: f240 41dc    	movw	r1, #0x4dc
700a5108: f2c7 010b    	movt	r1, #0x700b
700a510c: 6809         	ldr	r1, [r1]
700a510e: f8c1 0088    	str.w	r0, [r1, #0x88]
;     taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this
700a5112: e7ff         	b	0x700a5114 <vTaskSwitchContext+0x44> @ imm = #-0x2
700a5114: f240 5008    	movw	r0, #0x508
700a5118: f2c7 000b    	movt	r0, #0x700b
700a511c: 6800         	ldr	r0, [r0]
700a511e: b158         	cbz	r0, 0x700a5138 <vTaskSwitchContext+0x68> @ imm = #0x16
700a5120: e7ff         	b	0x700a5122 <vTaskSwitchContext+0x52> @ imm = #-0x2
700a5122: f240 5008    	movw	r0, #0x508
700a5126: f2c7 000b    	movt	r0, #0x700b
700a512a: 6800         	ldr	r0, [r0]
700a512c: fab0 f080    	clz	r0, r0
700a5130: f1c0 001f    	rsb.w	r0, r0, #0x1f
700a5134: 9001         	str	r0, [sp, #0x4]
700a5136: e002         	b	0x700a513e <vTaskSwitchContext+0x6e> @ imm = #0x4
700a5138: 2000         	movs	r0, #0x0
;     taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this
700a513a: 9001         	str	r0, [sp, #0x4]
700a513c: e7ff         	b	0x700a513e <vTaskSwitchContext+0x6e> @ imm = #-0x2
700a513e: e7ff         	b	0x700a5140 <vTaskSwitchContext+0x70> @ imm = #-0x2
700a5140: 9801         	ldr	r0, [sp, #0x4]
700a5142: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a5146: f244 40f8    	movw	r0, #0x44f8
700a514a: f2c7 0008    	movt	r0, #0x7008
700a514e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5152: 9000         	str	r0, [sp]
700a5154: 9900         	ldr	r1, [sp]
700a5156: 6848         	ldr	r0, [r1, #0x4]
700a5158: 6840         	ldr	r0, [r0, #0x4]
700a515a: 6048         	str	r0, [r1, #0x4]
700a515c: 9900         	ldr	r1, [sp]
700a515e: 6848         	ldr	r0, [r1, #0x4]
700a5160: 3108         	adds	r1, #0x8
700a5162: 4288         	cmp	r0, r1
700a5164: d105         	bne	0x700a5172 <vTaskSwitchContext+0xa2> @ imm = #0xa
700a5166: e7ff         	b	0x700a5168 <vTaskSwitchContext+0x98> @ imm = #-0x2
700a5168: 9900         	ldr	r1, [sp]
700a516a: 6848         	ldr	r0, [r1, #0x4]
700a516c: 6840         	ldr	r0, [r0, #0x4]
700a516e: 6048         	str	r0, [r1, #0x4]
700a5170: e7ff         	b	0x700a5172 <vTaskSwitchContext+0xa2> @ imm = #-0x2
700a5172: 9800         	ldr	r0, [sp]
700a5174: 6840         	ldr	r0, [r0, #0x4]
700a5176: 68c1         	ldr	r1, [r0, #0xc]
700a5178: f240 40dc    	movw	r0, #0x4dc
700a517c: f2c7 000b    	movt	r0, #0x700b
700a5180: 6001         	str	r1, [r0]
;       FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
700a5182: 6800         	ldr	r0, [r0]
700a5184: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a5188: f240 41a0    	movw	r1, #0x4a0
700a518c: f2c7 010b    	movt	r1, #0x700b
700a5190: 6008         	str	r0, [r1]
700a5192: e7ff         	b	0x700a5194 <vTaskSwitchContext+0xc4> @ imm = #-0x2
; }
700a5194: b002         	add	sp, #0x8
700a5196: 4770         	bx	lr
		...

700a51a0 <UART_lld_writeIntr>:
; {
700a51a0: b580         	push	{r7, lr}
700a51a2: b086         	sub	sp, #0x18
700a51a4: 9005         	str	r0, [sp, #0x14]
700a51a6: 9104         	str	r1, [sp, #0x10]
700a51a8: 9203         	str	r2, [sp, #0xc]
700a51aa: 9302         	str	r3, [sp, #0x8]
700a51ac: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a51ae: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a51b0: 9805         	ldr	r0, [sp, #0x14]
700a51b2: 2800         	cmp	r0, #0x0
700a51b4: d050         	beq	0x700a5258 <UART_lld_writeIntr+0xb8> @ imm = #0xa0
700a51b6: e7ff         	b	0x700a51b8 <UART_lld_writeIntr+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a51b8: 9805         	ldr	r0, [sp, #0x14]
700a51ba: 303c         	adds	r0, #0x3c
700a51bc: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a51be: 9800         	ldr	r0, [sp]
700a51c0: 6800         	ldr	r0, [r0]
700a51c2: b138         	cbz	r0, 0x700a51d4 <UART_lld_writeIntr+0x34> @ imm = #0xe
700a51c4: e7ff         	b	0x700a51c6 <UART_lld_writeIntr+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a51c6: 9900         	ldr	r1, [sp]
700a51c8: 2009         	movs	r0, #0x9
700a51ca: 60c8         	str	r0, [r1, #0xc]
700a51cc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a51d0: 9001         	str	r0, [sp, #0x4]
;         }
700a51d2: e040         	b	0x700a5256 <UART_lld_writeIntr+0xb6> @ imm = #0x80
;             UART_lld_Transaction_init(trans);
700a51d4: 9800         	ldr	r0, [sp]
700a51d6: f007 fceb    	bl	0x700acbb0 <UART_lld_Transaction_init> @ imm = #0x79d6
;             if(extendedParams != NULL)
700a51da: 9802         	ldr	r0, [sp, #0x8]
700a51dc: b128         	cbz	r0, 0x700a51ea <UART_lld_writeIntr+0x4a> @ imm = #0xa
700a51de: e7ff         	b	0x700a51e0 <UART_lld_writeIntr+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a51e0: 9802         	ldr	r0, [sp, #0x8]
700a51e2: 6800         	ldr	r0, [r0]
700a51e4: 9900         	ldr	r1, [sp]
700a51e6: 6108         	str	r0, [r1, #0x10]
;             }
700a51e8: e003         	b	0x700a51f2 <UART_lld_writeIntr+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a51ea: 9900         	ldr	r1, [sp]
700a51ec: 2000         	movs	r0, #0x0
700a51ee: 6108         	str	r0, [r1, #0x10]
700a51f0: e7ff         	b	0x700a51f2 <UART_lld_writeIntr+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a51f2: 9804         	ldr	r0, [sp, #0x10]
700a51f4: 9900         	ldr	r1, [sp]
700a51f6: 6008         	str	r0, [r1]
;             trans->count = size;
700a51f8: 9803         	ldr	r0, [sp, #0xc]
700a51fa: 9900         	ldr	r1, [sp]
700a51fc: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a51fe: 9805         	ldr	r0, [sp, #0x14]
700a5200: 6d40         	ldr	r0, [r0, #0x54]
700a5202: 2801         	cmp	r0, #0x1
700a5204: d105         	bne	0x700a5212 <UART_lld_writeIntr+0x72> @ imm = #0xa
700a5206: e7ff         	b	0x700a5208 <UART_lld_writeIntr+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a5208: 9800         	ldr	r0, [sp]
700a520a: f007 f8e9    	bl	0x700ac3e0 <UART_checkTransaction> @ imm = #0x71d2
700a520e: 9001         	str	r0, [sp, #0x4]
;             }
700a5210: e003         	b	0x700a521a <UART_lld_writeIntr+0x7a> @ imm = #0x6
700a5212: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a5216: 9001         	str	r0, [sp, #0x4]
700a5218: e7ff         	b	0x700a521a <UART_lld_writeIntr+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a521a: 9801         	ldr	r0, [sp, #0x4]
700a521c: b9d0         	cbnz	r0, 0x700a5254 <UART_lld_writeIntr+0xb4> @ imm = #0x34
700a521e: e7ff         	b	0x700a5220 <UART_lld_writeIntr+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a5220: 9800         	ldr	r0, [sp]
700a5222: 6800         	ldr	r0, [r0]
700a5224: 9905         	ldr	r1, [sp, #0x14]
700a5226: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a5228: 9800         	ldr	r0, [sp]
700a522a: 6880         	ldr	r0, [r0, #0x8]
700a522c: 9905         	ldr	r1, [sp, #0x14]
700a522e: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a5230: 9905         	ldr	r1, [sp, #0x14]
700a5232: 2000         	movs	r0, #0x0
700a5234: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a5236: 9800         	ldr	r0, [sp]
700a5238: 6840         	ldr	r0, [r0, #0x4]
700a523a: 9905         	ldr	r1, [sp, #0x14]
700a523c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a523e: 9905         	ldr	r1, [sp, #0x14]
700a5240: 2002         	movs	r0, #0x2
700a5242: 6548         	str	r0, [r1, #0x54]
;                 status = UART_writeInterrupt(hUart);
700a5244: 9805         	ldr	r0, [sp, #0x14]
700a5246: f007 fffb    	bl	0x700ad240 <UART_writeInterrupt> @ imm = #0x7ff6
700a524a: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a524c: 9905         	ldr	r1, [sp, #0x14]
700a524e: 2001         	movs	r0, #0x1
700a5250: 6548         	str	r0, [r1, #0x54]
;             }
700a5252: e7ff         	b	0x700a5254 <UART_lld_writeIntr+0xb4> @ imm = #-0x2
700a5254: e7ff         	b	0x700a5256 <UART_lld_writeIntr+0xb6> @ imm = #-0x2
;     }
700a5256: e003         	b	0x700a5260 <UART_lld_writeIntr+0xc0> @ imm = #0x6
700a5258: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a525c: 9001         	str	r0, [sp, #0x4]
700a525e: e7ff         	b	0x700a5260 <UART_lld_writeIntr+0xc0> @ imm = #-0x2
;     return status;
700a5260: 9801         	ldr	r0, [sp, #0x4]
700a5262: b006         	add	sp, #0x18
700a5264: bd80         	pop	{r7, pc}
		...
700a526e: 0000         	movs	r0, r0

700a5270 <Udma_eventUnRegister>:
; {
700a5270: b580         	push	{r7, lr}
700a5272: b084         	sub	sp, #0x10
700a5274: 9003         	str	r0, [sp, #0xc]
700a5276: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a5278: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == eventHandle)
700a527a: 9803         	ldr	r0, [sp, #0xc]
700a527c: b920         	cbnz	r0, 0x700a5288 <Udma_eventUnRegister+0x18> @ imm = #0x8
700a527e: e7ff         	b	0x700a5280 <Udma_eventUnRegister+0x10> @ imm = #-0x2
700a5280: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a5284: 9002         	str	r0, [sp, #0x8]
;     }
700a5286: e7ff         	b	0x700a5288 <Udma_eventUnRegister+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a5288: 9802         	ldr	r0, [sp, #0x8]
700a528a: b9b8         	cbnz	r0, 0x700a52bc <Udma_eventUnRegister+0x4c> @ imm = #0x2e
700a528c: e7ff         	b	0x700a528e <Udma_eventUnRegister+0x1e> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
700a528e: 9803         	ldr	r0, [sp, #0xc]
700a5290: 9000         	str	r0, [sp]
;         drvHandle = eventHandleInt->drvHandle;
700a5292: 9800         	ldr	r0, [sp]
700a5294: 6800         	ldr	r0, [r0]
700a5296: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a5298: 9801         	ldr	r0, [sp, #0x4]
700a529a: b150         	cbz	r0, 0x700a52b2 <Udma_eventUnRegister+0x42> @ imm = #0x14
700a529c: e7ff         	b	0x700a529e <Udma_eventUnRegister+0x2e> @ imm = #-0x2
700a529e: 9801         	ldr	r0, [sp, #0x4]
700a52a0: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a52a4: f64a 31cd    	movw	r1, #0xabcd
700a52a8: f6ca 31dc    	movt	r1, #0xabdc
700a52ac: 4288         	cmp	r0, r1
700a52ae: d004         	beq	0x700a52ba <Udma_eventUnRegister+0x4a> @ imm = #0x8
700a52b0: e7ff         	b	0x700a52b2 <Udma_eventUnRegister+0x42> @ imm = #-0x2
700a52b2: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a52b6: 9002         	str	r0, [sp, #0x8]
;         }
700a52b8: e7ff         	b	0x700a52ba <Udma_eventUnRegister+0x4a> @ imm = #-0x2
;     }
700a52ba: e7ff         	b	0x700a52bc <Udma_eventUnRegister+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a52bc: 9802         	ldr	r0, [sp, #0x8]
700a52be: bbb8         	cbnz	r0, 0x700a5330 <Udma_eventUnRegister+0xc0> @ imm = #0x6e
700a52c0: e7ff         	b	0x700a52c2 <Udma_eventUnRegister+0x52> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a52c2: 9801         	ldr	r0, [sp, #0x4]
700a52c4: 6800         	ldr	r0, [r0]
700a52c6: b130         	cbz	r0, 0x700a52d6 <Udma_eventUnRegister+0x66> @ imm = #0xc
700a52c8: e7ff         	b	0x700a52ca <Udma_eventUnRegister+0x5a> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventHandleInt->eventPrms.eventType))
700a52ca: 9800         	ldr	r0, [sp]
700a52cc: 6880         	ldr	r0, [r0, #0x8]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a52ce: 2802         	cmp	r0, #0x2
700a52d0: d101         	bne	0x700a52d6 <Udma_eventUnRegister+0x66> @ imm = #0x2
700a52d2: e7ff         	b	0x700a52d4 <Udma_eventUnRegister+0x64> @ imm = #-0x2
;         }
700a52d4: e02b         	b	0x700a532e <Udma_eventUnRegister+0xbe> @ imm = #0x56
;             retVal = Udma_eventCheckUnRegister(drvHandle, eventHandleInt);
700a52d6: 9801         	ldr	r0, [sp, #0x4]
700a52d8: 9900         	ldr	r1, [sp]
700a52da: f7ff fe29    	bl	0x700a4f30 <Udma_eventCheckUnRegister> @ imm = #-0x3ae
700a52de: 9002         	str	r0, [sp, #0x8]
;             if(UDMA_SOK == retVal)
700a52e0: 9802         	ldr	r0, [sp, #0x8]
700a52e2: bb18         	cbnz	r0, 0x700a532c <Udma_eventUnRegister+0xbc> @ imm = #0x46
700a52e4: e7ff         	b	0x700a52e6 <Udma_eventUnRegister+0x76> @ imm = #-0x2
;                 if(NULL_PTR != eventHandleInt->hwiHandle)
700a52e6: 9800         	ldr	r0, [sp]
700a52e8: 6e40         	ldr	r0, [r0, #0x64]
700a52ea: b128         	cbz	r0, 0x700a52f8 <Udma_eventUnRegister+0x88> @ imm = #0xa
700a52ec: e7ff         	b	0x700a52ee <Udma_eventUnRegister+0x7e> @ imm = #-0x2
;                     HwiP_disableInt(eventHandleInt->coreIntrNum);
700a52ee: 9800         	ldr	r0, [sp]
700a52f0: 6d80         	ldr	r0, [r0, #0x58]
700a52f2: f008 fc2d    	bl	0x700adb50 <HwiP_disableInt> @ imm = #0x885a
;                 }
700a52f6: e7ff         	b	0x700a52f8 <Udma_eventUnRegister+0x88> @ imm = #-0x2
;                 retVal = Udma_eventReset(drvHandle, eventHandleInt);
700a52f8: 9801         	ldr	r0, [sp, #0x4]
700a52fa: 9900         	ldr	r1, [sp]
700a52fc: f7f6 fc40    	bl	0x7009bb80 <Udma_eventReset> @ imm = #-0x9780
700a5300: 9002         	str	r0, [sp, #0x8]
;                 if(UDMA_SOK != retVal)
700a5302: 9802         	ldr	r0, [sp, #0x8]
700a5304: b108         	cbz	r0, 0x700a530a <Udma_eventUnRegister+0x9a> @ imm = #0x2
700a5306: e7ff         	b	0x700a5308 <Udma_eventUnRegister+0x98> @ imm = #-0x2
;                 }
700a5308: e7ff         	b	0x700a530a <Udma_eventUnRegister+0x9a> @ imm = #-0x2
;                 Udma_eventFreeResource(drvHandle, eventHandleInt);
700a530a: 9801         	ldr	r0, [sp, #0x4]
700a530c: 9900         	ldr	r1, [sp]
700a530e: f7fe fdd7    	bl	0x700a3ec0 <Udma_eventFreeResource> @ imm = #-0x1452
;                 eventHandleInt->eventInitDone  = UDMA_DEINIT_DONE;
700a5312: 9900         	ldr	r1, [sp]
700a5314: 2000         	movs	r0, #0x0
700a5316: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 eventHandleInt->pIaGeviRegs    = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
700a531a: 9900         	ldr	r1, [sp]
700a531c: f8c1 0090    	str.w	r0, [r1, #0x90]
;                 eventHandleInt->pIaVintrRegs   = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
700a5320: 9900         	ldr	r1, [sp]
700a5322: f8c1 0094    	str.w	r0, [r1, #0x94]
;                 eventHandleInt->drvHandle      = (Udma_DrvHandleInt) NULL_PTR;
700a5326: 9900         	ldr	r1, [sp]
700a5328: 6008         	str	r0, [r1]
;             }
700a532a: e7ff         	b	0x700a532c <Udma_eventUnRegister+0xbc> @ imm = #-0x2
700a532c: e7ff         	b	0x700a532e <Udma_eventUnRegister+0xbe> @ imm = #-0x2
;     }
700a532e: e7ff         	b	0x700a5330 <Udma_eventUnRegister+0xc0> @ imm = #-0x2
;     return (retVal);
700a5330: 9802         	ldr	r0, [sp, #0x8]
700a5332: b004         	add	sp, #0x10
700a5334: bd80         	pop	{r7, pc}
		...
700a533e: 0000         	movs	r0, r0

700a5340 <Sciclient_rmIrqIsVintRouteSet>:
; {
700a5340: b580         	push	{r7, lr}
700a5342: b088         	sub	sp, #0x20
700a5344: 9007         	str	r0, [sp, #0x1c]
700a5346: 9106         	str	r1, [sp, #0x18]
700a5348: 2000         	movs	r0, #0x0
;     bool found_iface = false;
700a534a: f88d 0007    	strb.w	r0, [sp, #0x7]
;     *vint_used = false;
700a534e: 9906         	ldr	r1, [sp, #0x18]
700a5350: 7008         	strb	r0, [r1]
;     r = Sciclient_rmIrqGetNode(cfg->s_ia, &ia_node);
700a5352: 9807         	ldr	r0, [sp, #0x1c]
700a5354: 8a00         	ldrh	r0, [r0, #0x10]
700a5356: a903         	add	r1, sp, #0xc
700a5358: f7fe fea2    	bl	0x700a40a0 <Sciclient_rmIrqGetNode> @ imm = #-0x12bc
700a535c: 9005         	str	r0, [sp, #0x14]
;     if (r == SystemP_SUCCESS) {
700a535e: 9805         	ldr	r0, [sp, #0x14]
700a5360: bb90         	cbnz	r0, 0x700a53c8 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #0x64
700a5362: e7ff         	b	0x700a5364 <Sciclient_rmIrqIsVintRouteSet+0x24> @ imm = #-0x2
700a5364: 2000         	movs	r0, #0x0
;         for (i = 0U; i < ia_node->n_if; i++) {
700a5366: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a536a: e7ff         	b	0x700a536c <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x2
700a536c: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a5370: 9903         	ldr	r1, [sp, #0xc]
700a5372: 8849         	ldrh	r1, [r1, #0x2]
700a5374: 4288         	cmp	r0, r1
700a5376: da26         	bge	0x700a53c6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x4c
700a5378: e7ff         	b	0x700a537a <Sciclient_rmIrqIsVintRouteSet+0x3a> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(ia_node, i, &iface);
700a537a: 9803         	ldr	r0, [sp, #0xc]
700a537c: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a5380: aa02         	add	r2, sp, #0x8
700a5382: f006 fa8d    	bl	0x700ab8a0 <Sciclient_rmIrqGetNodeItf> @ imm = #0x651a
700a5386: 9005         	str	r0, [sp, #0x14]
;             if (r != SystemP_SUCCESS) {
700a5388: 9805         	ldr	r0, [sp, #0x14]
700a538a: b108         	cbz	r0, 0x700a5390 <Sciclient_rmIrqIsVintRouteSet+0x50> @ imm = #0x2
700a538c: e7ff         	b	0x700a538e <Sciclient_rmIrqIsVintRouteSet+0x4e> @ imm = #-0x2
;                 break;
700a538e: e01a         	b	0x700a53c6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x34
;             if ((cfg->vint >= iface->lbase) &&
700a5390: 9807         	ldr	r0, [sp, #0x1c]
700a5392: 8a40         	ldrh	r0, [r0, #0x12]
700a5394: 9902         	ldr	r1, [sp, #0x8]
700a5396: 8809         	ldrh	r1, [r1]
700a5398: 4288         	cmp	r0, r1
700a539a: db0d         	blt	0x700a53b8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x1a
700a539c: e7ff         	b	0x700a539e <Sciclient_rmIrqIsVintRouteSet+0x5e> @ imm = #-0x2
;                 (cfg->vint < (iface->lbase + iface->len))) {
700a539e: 9807         	ldr	r0, [sp, #0x1c]
700a53a0: 8a40         	ldrh	r0, [r0, #0x12]
700a53a2: 9a02         	ldr	r2, [sp, #0x8]
700a53a4: 8811         	ldrh	r1, [r2]
700a53a6: 8892         	ldrh	r2, [r2, #0x4]
700a53a8: 4411         	add	r1, r2
;             if ((cfg->vint >= iface->lbase) &&
700a53aa: 4288         	cmp	r0, r1
700a53ac: da04         	bge	0x700a53b8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x8
700a53ae: e7ff         	b	0x700a53b0 <Sciclient_rmIrqIsVintRouteSet+0x70> @ imm = #-0x2
700a53b0: 2001         	movs	r0, #0x1
;                 found_iface = true;
700a53b2: f88d 0007    	strb.w	r0, [sp, #0x7]
;                 break;
700a53b6: e006         	b	0x700a53c6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0xc
;         }
700a53b8: e7ff         	b	0x700a53ba <Sciclient_rmIrqIsVintRouteSet+0x7a> @ imm = #-0x2
;         for (i = 0U; i < ia_node->n_if; i++) {
700a53ba: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a53be: 3001         	adds	r0, #0x1
700a53c0: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a53c4: e7d2         	b	0x700a536c <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x5c
;     }
700a53c6: e7ff         	b	0x700a53c8 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #-0x2
;     if (found_iface) {
700a53c8: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a53cc: 07c0         	lsls	r0, r0, #0x1f
700a53ce: b1b0         	cbz	r0, 0x700a53fe <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #0x2c
700a53d0: e7ff         	b	0x700a53d2 <Sciclient_rmIrqIsVintRouteSet+0x92> @ imm = #-0x2
;         ir_inp = SCICLIENT_OUTP_TO_INP(cfg->vint, iface->lbase, iface->rbase);
700a53d2: 9a02         	ldr	r2, [sp, #0x8]
700a53d4: 8850         	ldrh	r0, [r2, #0x2]
700a53d6: 9907         	ldr	r1, [sp, #0x1c]
700a53d8: 8a49         	ldrh	r1, [r1, #0x12]
700a53da: 8812         	ldrh	r2, [r2]
700a53dc: 1a89         	subs	r1, r1, r2
700a53de: 4408         	add	r0, r1
700a53e0: f8ad 0004    	strh.w	r0, [sp, #0x4]
;         if (Sciclient_rmIrInpIsFree(iface->rid, ir_inp) != SystemP_SUCCESS) {
700a53e4: 9802         	ldr	r0, [sp, #0x8]
700a53e6: 88c0         	ldrh	r0, [r0, #0x6]
700a53e8: f8bd 1004    	ldrh.w	r1, [sp, #0x4]
700a53ec: f7ff f820    	bl	0x700a4430 <Sciclient_rmIrInpIsFree> @ imm = #-0xfc0
700a53f0: b120         	cbz	r0, 0x700a53fc <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #0x8
700a53f2: e7ff         	b	0x700a53f4 <Sciclient_rmIrqIsVintRouteSet+0xb4> @ imm = #-0x2
;             *vint_used = true;
700a53f4: 9906         	ldr	r1, [sp, #0x18]
700a53f6: 2001         	movs	r0, #0x1
700a53f8: 7008         	strb	r0, [r1]
;         }
700a53fa: e7ff         	b	0x700a53fc <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #-0x2
;     }
700a53fc: e7ff         	b	0x700a53fe <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #-0x2
;     return r;
700a53fe: 9805         	ldr	r0, [sp, #0x14]
700a5400: b008         	add	sp, #0x20
700a5402: bd80         	pop	{r7, pc}
		...

700a5410 <UART_flushTxFifo>:
; {
700a5410: b580         	push	{r7, lr}
700a5412: b08a         	sub	sp, #0x28
700a5414: 9009         	str	r0, [sp, #0x24]
700a5416: f640 30b8    	movw	r0, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700a541a: 9003         	str	r0, [sp, #0xc]
700a541c: 2000         	movs	r0, #0x0
;     uint32_t            timeoutElapsed  = FALSE;
700a541e: 9002         	str	r0, [sp, #0x8]
;     config = (UART_Config *) handle;
700a5420: 9809         	ldr	r0, [sp, #0x24]
700a5422: 9008         	str	r0, [sp, #0x20]
;     if (NULL != config)
700a5424: 9808         	ldr	r0, [sp, #0x20]
700a5426: 2800         	cmp	r0, #0x0
700a5428: d052         	beq	0x700a54d0 <UART_flushTxFifo+0xc0> @ imm = #0xa4
700a542a: e7ff         	b	0x700a542c <UART_flushTxFifo+0x1c> @ imm = #-0x2
;         attrs = config->attrs;
700a542c: 9808         	ldr	r0, [sp, #0x20]
700a542e: 6800         	ldr	r0, [r0]
700a5430: 9007         	str	r0, [sp, #0x1c]
;         DebugP_assert(NULL_PTR != attrs);
700a5432: 9807         	ldr	r0, [sp, #0x1c]
700a5434: 2800         	cmp	r0, #0x0
700a5436: bf18         	it	ne
700a5438: 2001         	movne	r0, #0x1
700a543a: f64f 31b8    	movw	r1, #0xfbb8
700a543e: f2c7 010a    	movt	r1, #0x700a
700a5442: 466a         	mov	r2, sp
700a5444: 6011         	str	r1, [r2]
700a5446: f64f 3182    	movw	r1, #0xfb82
700a544a: f2c7 010a    	movt	r1, #0x700a
700a544e: f64f 32ed    	movw	r2, #0xfbed
700a5452: f2c7 020a    	movt	r2, #0x700a
700a5456: f240 3355    	movw	r3, #0x355
700a545a: f003 fbe1    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x37c2
;         startTicks = ClockP_getTicks();
700a545e: f008 faef    	bl	0x700ada40 <ClockP_getTicks> @ imm = #0x85de
700a5462: 9005         	str	r0, [sp, #0x14]
;         while (FALSE == timeoutElapsed)
700a5464: e7ff         	b	0x700a5466 <UART_flushTxFifo+0x56> @ imm = #-0x2
700a5466: 9802         	ldr	r0, [sp, #0x8]
700a5468: b9d8         	cbnz	r0, 0x700a54a2 <UART_flushTxFifo+0x92> @ imm = #0x36
700a546a: e7ff         	b	0x700a546c <UART_flushTxFifo+0x5c> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(attrs->baseAddr);
700a546c: 9807         	ldr	r0, [sp, #0x1c]
700a546e: 6800         	ldr	r0, [r0]
700a5470: f006 fc36    	bl	0x700abce0 <UART_spaceAvail> @ imm = #0x686c
700a5474: 9006         	str	r0, [sp, #0x18]
;             if (TRUE == isTxFifoEmpty)
700a5476: 9806         	ldr	r0, [sp, #0x18]
700a5478: 2801         	cmp	r0, #0x1
700a547a: d101         	bne	0x700a5480 <UART_flushTxFifo+0x70> @ imm = #0x2
700a547c: e7ff         	b	0x700a547e <UART_flushTxFifo+0x6e> @ imm = #-0x2
;                 break;
700a547e: e010         	b	0x700a54a2 <UART_flushTxFifo+0x92> @ imm = #0x20
;             elapsedTicks = ClockP_getTicks() - startTicks;
700a5480: f008 fade    	bl	0x700ada40 <ClockP_getTicks> @ imm = #0x85bc
700a5484: 9905         	ldr	r1, [sp, #0x14]
700a5486: 1a40         	subs	r0, r0, r1
700a5488: 9004         	str	r0, [sp, #0x10]
;             if (elapsedTicks >= timeout)
700a548a: 9804         	ldr	r0, [sp, #0x10]
700a548c: 9903         	ldr	r1, [sp, #0xc]
700a548e: 4288         	cmp	r0, r1
700a5490: d303         	blo	0x700a549a <UART_flushTxFifo+0x8a> @ imm = #0x6
700a5492: e7ff         	b	0x700a5494 <UART_flushTxFifo+0x84> @ imm = #-0x2
700a5494: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700a5496: 9002         	str	r0, [sp, #0x8]
;             }
700a5498: e002         	b	0x700a54a0 <UART_flushTxFifo+0x90> @ imm = #0x4
;                 TaskP_yield();
700a549a: f008 fb01    	bl	0x700adaa0 <TaskP_yield> @ imm = #0x8602
700a549e: e7ff         	b	0x700a54a0 <UART_flushTxFifo+0x90> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700a54a0: e7e1         	b	0x700a5466 <UART_flushTxFifo+0x56> @ imm = #-0x3e
;         DebugP_assert(FALSE == timeoutElapsed);
700a54a2: 9802         	ldr	r0, [sp, #0x8]
700a54a4: fab0 f080    	clz	r0, r0
700a54a8: 0940         	lsrs	r0, r0, #0x5
700a54aa: f64f 2199    	movw	r1, #0xfa99
700a54ae: f2c7 010a    	movt	r1, #0x700a
700a54b2: 466a         	mov	r2, sp
700a54b4: 6011         	str	r1, [r2]
700a54b6: f64f 3182    	movw	r1, #0xfb82
700a54ba: f2c7 010a    	movt	r1, #0x700a
700a54be: f64f 32ed    	movw	r2, #0xfbed
700a54c2: f2c7 020a    	movt	r2, #0x700a
700a54c6: f240 336f    	movw	r3, #0x36f
700a54ca: f003 fba9    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x3752
;     }
700a54ce: e7ff         	b	0x700a54d0 <UART_flushTxFifo+0xc0> @ imm = #-0x2
;     return;
700a54d0: b00a         	add	sp, #0x28
700a54d2: bd80         	pop	{r7, pc}
		...

700a54e0 <Udma_chClose>:
; {
700a54e0: b580         	push	{r7, lr}
700a54e2: b084         	sub	sp, #0x10
700a54e4: 9003         	str	r0, [sp, #0xc]
700a54e6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a54e8: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a54ea: 9803         	ldr	r0, [sp, #0xc]
700a54ec: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a54ee: 9800         	ldr	r0, [sp]
700a54f0: b150         	cbz	r0, 0x700a5508 <Udma_chClose+0x28> @ imm = #0x14
700a54f2: e7ff         	b	0x700a54f4 <Udma_chClose+0x14> @ imm = #-0x2
700a54f4: 9800         	ldr	r0, [sp]
700a54f6: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a54fa: f64a 31cd    	movw	r1, #0xabcd
700a54fe: f6ca 31dc    	movt	r1, #0xabdc
700a5502: 4288         	cmp	r0, r1
700a5504: d004         	beq	0x700a5510 <Udma_chClose+0x30> @ imm = #0x8
700a5506: e7ff         	b	0x700a5508 <Udma_chClose+0x28> @ imm = #-0x2
700a5508: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a550c: 9002         	str	r0, [sp, #0x8]
;     }
700a550e: e7ff         	b	0x700a5510 <Udma_chClose+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a5510: 9802         	ldr	r0, [sp, #0x8]
700a5512: b9a8         	cbnz	r0, 0x700a5540 <Udma_chClose+0x60> @ imm = #0x2a
700a5514: e7ff         	b	0x700a5516 <Udma_chClose+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a5516: 9800         	ldr	r0, [sp]
700a5518: 6e80         	ldr	r0, [r0, #0x68]
700a551a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a551c: 9801         	ldr	r0, [sp, #0x4]
700a551e: b150         	cbz	r0, 0x700a5536 <Udma_chClose+0x56> @ imm = #0x14
700a5520: e7ff         	b	0x700a5522 <Udma_chClose+0x42> @ imm = #-0x2
700a5522: 9801         	ldr	r0, [sp, #0x4]
700a5524: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a5528: f64a 31cd    	movw	r1, #0xabcd
700a552c: f6ca 31dc    	movt	r1, #0xabdc
700a5530: 4288         	cmp	r0, r1
700a5532: d004         	beq	0x700a553e <Udma_chClose+0x5e> @ imm = #0x8
700a5534: e7ff         	b	0x700a5536 <Udma_chClose+0x56> @ imm = #-0x2
700a5536: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a553a: 9002         	str	r0, [sp, #0x8]
;         }
700a553c: e7ff         	b	0x700a553e <Udma_chClose+0x5e> @ imm = #-0x2
;     }
700a553e: e7ff         	b	0x700a5540 <Udma_chClose+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a5540: 9802         	ldr	r0, [sp, #0x8]
700a5542: b958         	cbnz	r0, 0x700a555c <Udma_chClose+0x7c> @ imm = #0x16
700a5544: e7ff         	b	0x700a5546 <Udma_chClose+0x66> @ imm = #-0x2
;         if(TRUE == chHandleInt->chOesAllocDone)
700a5546: 9800         	ldr	r0, [sp]
700a5548: f8d0 0248    	ldr.w	r0, [r0, #0x248]
700a554c: 2801         	cmp	r0, #0x1
700a554e: d104         	bne	0x700a555a <Udma_chClose+0x7a> @ imm = #0x8
700a5550: e7ff         	b	0x700a5552 <Udma_chClose+0x72> @ imm = #-0x2
700a5552: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a5556: 9002         	str	r0, [sp, #0x8]
;         }
700a5558: e7ff         	b	0x700a555a <Udma_chClose+0x7a> @ imm = #-0x2
;     }
700a555a: e7ff         	b	0x700a555c <Udma_chClose+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a555c: 9802         	ldr	r0, [sp, #0x8]
700a555e: b9e8         	cbnz	r0, 0x700a559c <Udma_chClose+0xbc> @ imm = #0x3a
700a5560: e7ff         	b	0x700a5562 <Udma_chClose+0x82> @ imm = #-0x2
;         retVal = Udma_chUnpair(chHandleInt);
700a5562: 9800         	ldr	r0, [sp]
700a5564: f003 f954    	bl	0x700a8810 <Udma_chUnpair> @ imm = #0x32a8
700a5568: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a556a: 9802         	ldr	r0, [sp, #0x8]
700a556c: b108         	cbz	r0, 0x700a5572 <Udma_chClose+0x92> @ imm = #0x2
700a556e: e7ff         	b	0x700a5570 <Udma_chClose+0x90> @ imm = #-0x2
;         }
700a5570: e7ff         	b	0x700a5572 <Udma_chClose+0x92> @ imm = #-0x2
;         retVal += Udma_chFreeResource(chHandleInt);
700a5572: 9800         	ldr	r0, [sp]
700a5574: f7f8 f8ac    	bl	0x7009d6d0 <Udma_chFreeResource> @ imm = #-0x7ea8
700a5578: 4601         	mov	r1, r0
700a557a: 9802         	ldr	r0, [sp, #0x8]
700a557c: 4408         	add	r0, r1
700a557e: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a5580: 9802         	ldr	r0, [sp, #0x8]
700a5582: b108         	cbz	r0, 0x700a5588 <Udma_chClose+0xa8> @ imm = #0x2
700a5584: e7ff         	b	0x700a5586 <Udma_chClose+0xa6> @ imm = #-0x2
;         }
700a5586: e7ff         	b	0x700a5588 <Udma_chClose+0xa8> @ imm = #-0x2
;         (void) memset(chHandleInt, 0, sizeof(*chHandleInt));
700a5588: 9800         	ldr	r0, [sp]
700a558a: f44f 7114    	mov.w	r1, #0x250
700a558e: f7f4 ea52    	blx	0x70099a34 <__aeabi_memclr8> @ imm = #-0xbb5c
;         chHandleInt->chInitDone = UDMA_DEINIT_DONE;
700a5592: 9900         	ldr	r1, [sp]
700a5594: 2000         	movs	r0, #0x0
700a5596: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a559a: e7ff         	b	0x700a559c <Udma_chClose+0xbc> @ imm = #-0x2
;     return (retVal);
700a559c: 9802         	ldr	r0, [sp, #0x8]
700a559e: b004         	add	sp, #0x10
700a55a0: bd80         	pop	{r7, pc}
		...
700a55ae: 0000         	movs	r0, r0

700a55b0 <CSL_bcdmaChanOpAccessRemotePeerReg>:
; {
700a55b0: b580         	push	{r7, lr}
700a55b2: b08a         	sub	sp, #0x28
700a55b4: 4684         	mov	r12, r0
700a55b6: 980c         	ldr	r0, [sp, #0x30]
700a55b8: f8cd c024    	str.w	r12, [sp, #0x24]
700a55bc: 9108         	str	r1, [sp, #0x20]
700a55be: 9207         	str	r2, [sp, #0x1c]
700a55c0: 9306         	str	r3, [sp, #0x18]
700a55c2: f88d 0017    	strb.w	r0, [sp, #0x17]
700a55c6: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a55c8: 9004         	str	r0, [sp, #0x10]
;     if( pOpData == NULL )
700a55ca: 9806         	ldr	r0, [sp, #0x18]
700a55cc: b920         	cbnz	r0, 0x700a55d8 <CSL_bcdmaChanOpAccessRemotePeerReg+0x28> @ imm = #0x8
700a55ce: e7ff         	b	0x700a55d0 <CSL_bcdmaChanOpAccessRemotePeerReg+0x20> @ imm = #-0x2
700a55d0: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a55d4: 9004         	str	r0, [sp, #0x10]
;     }
700a55d6: e048         	b	0x700a566a <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #0x90
700a55d8: 2000         	movs	r0, #0x0
;         uint32_t *pRemotePeerReg = NULL;
700a55da: 9003         	str	r0, [sp, #0xc]
;         switch( chanType )
700a55dc: 9808         	ldr	r0, [sp, #0x20]
700a55de: 9001         	str	r0, [sp, #0x4]
700a55e0: 2801         	cmp	r0, #0x1
700a55e2: d004         	beq	0x700a55ee <CSL_bcdmaChanOpAccessRemotePeerReg+0x3e> @ imm = #0x8
700a55e4: e7ff         	b	0x700a55e6 <CSL_bcdmaChanOpAccessRemotePeerReg+0x36> @ imm = #-0x2
700a55e6: 9801         	ldr	r0, [sp, #0x4]
700a55e8: 2802         	cmp	r0, #0x2
700a55ea: d009         	beq	0x700a5600 <CSL_bcdmaChanOpAccessRemotePeerReg+0x50> @ imm = #0x12
700a55ec: e011         	b	0x700a5612 <CSL_bcdmaChanOpAccessRemotePeerReg+0x62> @ imm = #0x22
;                 pRemotePeerReg = (uint32_t *)&pCfg->pTxChanRtRegs->CHAN[chanIdx].PEER0;
700a55ee: 9809         	ldr	r0, [sp, #0x24]
700a55f0: 6900         	ldr	r0, [r0, #0x10]
700a55f2: 9907         	ldr	r1, [sp, #0x1c]
700a55f4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a55f8: f500 7000    	add.w	r0, r0, #0x200
700a55fc: 9003         	str	r0, [sp, #0xc]
;                 break;
700a55fe: e00c         	b	0x700a561a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x18
;                 pRemotePeerReg = (uint32_t *)&pCfg->pRxChanRtRegs->CHAN[chanIdx].PEER0;
700a5600: 9809         	ldr	r0, [sp, #0x24]
700a5602: 6980         	ldr	r0, [r0, #0x18]
700a5604: 9907         	ldr	r1, [sp, #0x1c]
700a5606: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a560a: f500 7000    	add.w	r0, r0, #0x200
700a560e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a5610: e003         	b	0x700a561a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x6
700a5612: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a5616: 9004         	str	r0, [sp, #0x10]
;                 break;
700a5618: e7ff         	b	0x700a561a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #-0x2
;         if( pRemotePeerReg != NULL )
700a561a: 9803         	ldr	r0, [sp, #0xc]
700a561c: b320         	cbz	r0, 0x700a5668 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #0x48
700a561e: e7ff         	b	0x700a5620 <CSL_bcdmaChanOpAccessRemotePeerReg+0x70> @ imm = #-0x2
;             CSL_BcdmaRemotePeerOpts *pPeerOpts = (CSL_BcdmaRemotePeerOpts *)pOpData;
700a5620: 9806         	ldr	r0, [sp, #0x18]
700a5622: 9002         	str	r0, [sp, #0x8]
;             if( pPeerOpts->regIdx >= (uint32_t)16u )
700a5624: 9802         	ldr	r0, [sp, #0x8]
700a5626: 6800         	ldr	r0, [r0]
700a5628: 2810         	cmp	r0, #0x10
700a562a: d304         	blo	0x700a5636 <CSL_bcdmaChanOpAccessRemotePeerReg+0x86> @ imm = #0x8
700a562c: e7ff         	b	0x700a562e <CSL_bcdmaChanOpAccessRemotePeerReg+0x7e> @ imm = #-0x2
700a562e: f06f 0002    	mvn	r0, #0x2
;                 retVal = CSL_EINVALID_PARAMS;
700a5632: 9004         	str	r0, [sp, #0x10]
;             }
700a5634: e017         	b	0x700a5666 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #0x2e
;                 pRemotePeerReg += pPeerOpts->regIdx;    /* Increment to specified peer register */
700a5636: 9802         	ldr	r0, [sp, #0x8]
700a5638: 6801         	ldr	r1, [r0]
700a563a: 9803         	ldr	r0, [sp, #0xc]
700a563c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5640: 9003         	str	r0, [sp, #0xc]
;                 if( bRead == (bool)true )
700a5642: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a5646: 07c0         	lsls	r0, r0, #0x1f
700a5648: b130         	cbz	r0, 0x700a5658 <CSL_bcdmaChanOpAccessRemotePeerReg+0xa8> @ imm = #0xc
700a564a: e7ff         	b	0x700a564c <CSL_bcdmaChanOpAccessRemotePeerReg+0x9c> @ imm = #-0x2
;                     pPeerOpts->regVal = CSL_REG32_RD( pRemotePeerReg );
700a564c: 9803         	ldr	r0, [sp, #0xc]
700a564e: f008 f97f    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0x82fe
700a5652: 9902         	ldr	r1, [sp, #0x8]
700a5654: 6048         	str	r0, [r1, #0x4]
;                 }
700a5656: e005         	b	0x700a5664 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #0xa
;                     CSL_REG32_WR( pRemotePeerReg, pPeerOpts->regVal );
700a5658: 9803         	ldr	r0, [sp, #0xc]
700a565a: 9902         	ldr	r1, [sp, #0x8]
700a565c: 6849         	ldr	r1, [r1, #0x4]
700a565e: f008 f8d7    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x81ae
700a5662: e7ff         	b	0x700a5664 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #-0x2
700a5664: e7ff         	b	0x700a5666 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #-0x2
;         }
700a5666: e7ff         	b	0x700a5668 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #-0x2
700a5668: e7ff         	b	0x700a566a <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #-0x2
;     return retVal;
700a566a: 9804         	ldr	r0, [sp, #0x10]
700a566c: b00a         	add	sp, #0x28
700a566e: bd80         	pop	{r7, pc}

700a5670 <_out_rev>:
; {
700a5670: b580         	push	{r7, lr}
700a5672: b086         	sub	sp, #0x18
700a5674: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a5678: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a567c: f8dd c024    	ldr.w	r12, [sp, #0x24]
700a5680: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a5684: 9005         	str	r0, [sp, #0x14]
700a5686: 9104         	str	r1, [sp, #0x10]
700a5688: 9203         	str	r2, [sp, #0xc]
700a568a: 9302         	str	r3, [sp, #0x8]
;   const size_t start_idx = idx;
700a568c: 9803         	ldr	r0, [sp, #0xc]
700a568e: 9001         	str	r0, [sp, #0x4]
;   if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
700a5690: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a5694: 0780         	lsls	r0, r0, #0x1e
700a5696: 2800         	cmp	r0, #0x0
700a5698: d41c         	bmi	0x700a56d4 <_out_rev+0x64> @ imm = #0x38
700a569a: e7ff         	b	0x700a569c <_out_rev+0x2c> @ imm = #-0x2
700a569c: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a56a0: 07c0         	lsls	r0, r0, #0x1f
700a56a2: b9b8         	cbnz	r0, 0x700a56d4 <_out_rev+0x64> @ imm = #0x2e
700a56a4: e7ff         	b	0x700a56a6 <_out_rev+0x36> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a56a6: 9809         	ldr	r0, [sp, #0x24]
700a56a8: 9000         	str	r0, [sp]
700a56aa: e7ff         	b	0x700a56ac <_out_rev+0x3c> @ imm = #-0x2
700a56ac: 9800         	ldr	r0, [sp]
700a56ae: 990a         	ldr	r1, [sp, #0x28]
700a56b0: 4288         	cmp	r0, r1
700a56b2: d20e         	bhs	0x700a56d2 <_out_rev+0x62> @ imm = #0x1c
700a56b4: e7ff         	b	0x700a56b6 <_out_rev+0x46> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a56b6: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a56ba: 9904         	ldr	r1, [sp, #0x10]
700a56bc: 9a03         	ldr	r2, [sp, #0xc]
700a56be: 1c50         	adds	r0, r2, #0x1
700a56c0: 9003         	str	r0, [sp, #0xc]
700a56c2: 9b02         	ldr	r3, [sp, #0x8]
700a56c4: 2020         	movs	r0, #0x20
700a56c6: 47e0         	blx	r12
;     }
700a56c8: e7ff         	b	0x700a56ca <_out_rev+0x5a> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a56ca: 9800         	ldr	r0, [sp]
700a56cc: 3001         	adds	r0, #0x1
700a56ce: 9000         	str	r0, [sp]
700a56d0: e7ec         	b	0x700a56ac <_out_rev+0x3c> @ imm = #-0x28
;   }
700a56d2: e7ff         	b	0x700a56d4 <_out_rev+0x64> @ imm = #-0x2
;   while (len) {
700a56d4: e7ff         	b	0x700a56d6 <_out_rev+0x66> @ imm = #-0x2
700a56d6: 9809         	ldr	r0, [sp, #0x24]
700a56d8: b170         	cbz	r0, 0x700a56f8 <_out_rev+0x88> @ imm = #0x1c
700a56da: e7ff         	b	0x700a56dc <_out_rev+0x6c> @ imm = #-0x2
;     out(buf[--len], buffer, idx++, maxlen);
700a56dc: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a56e0: 9808         	ldr	r0, [sp, #0x20]
700a56e2: 9909         	ldr	r1, [sp, #0x24]
700a56e4: 3901         	subs	r1, #0x1
700a56e6: 9109         	str	r1, [sp, #0x24]
700a56e8: 5c40         	ldrb	r0, [r0, r1]
700a56ea: 9904         	ldr	r1, [sp, #0x10]
700a56ec: 9a03         	ldr	r2, [sp, #0xc]
700a56ee: 1c53         	adds	r3, r2, #0x1
700a56f0: 9303         	str	r3, [sp, #0xc]
700a56f2: 9b02         	ldr	r3, [sp, #0x8]
700a56f4: 47e0         	blx	r12
;   while (len) {
700a56f6: e7ee         	b	0x700a56d6 <_out_rev+0x66> @ imm = #-0x24
;   if (flags & FLAGS_LEFT) {
700a56f8: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a56fc: 0780         	lsls	r0, r0, #0x1e
700a56fe: 2800         	cmp	r0, #0x0
700a5700: d513         	bpl	0x700a572a <_out_rev+0xba> @ imm = #0x26
700a5702: e7ff         	b	0x700a5704 <_out_rev+0x94> @ imm = #-0x2
;     while (idx - start_idx < width) {
700a5704: e7ff         	b	0x700a5706 <_out_rev+0x96> @ imm = #-0x2
700a5706: 9803         	ldr	r0, [sp, #0xc]
700a5708: 9901         	ldr	r1, [sp, #0x4]
700a570a: 1a40         	subs	r0, r0, r1
700a570c: 990a         	ldr	r1, [sp, #0x28]
700a570e: 4288         	cmp	r0, r1
700a5710: d20a         	bhs	0x700a5728 <_out_rev+0xb8> @ imm = #0x14
700a5712: e7ff         	b	0x700a5714 <_out_rev+0xa4> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a5714: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a5718: 9904         	ldr	r1, [sp, #0x10]
700a571a: 9a03         	ldr	r2, [sp, #0xc]
700a571c: 1c50         	adds	r0, r2, #0x1
700a571e: 9003         	str	r0, [sp, #0xc]
700a5720: 9b02         	ldr	r3, [sp, #0x8]
700a5722: 2020         	movs	r0, #0x20
700a5724: 47e0         	blx	r12
;     while (idx - start_idx < width) {
700a5726: e7ee         	b	0x700a5706 <_out_rev+0x96> @ imm = #-0x24
;   }
700a5728: e7ff         	b	0x700a572a <_out_rev+0xba> @ imm = #-0x2
;   return idx;
700a572a: 9803         	ldr	r0, [sp, #0xc]
700a572c: b006         	add	sp, #0x18
700a572e: bd80         	pop	{r7, pc}

700a5730 <vTaskStartScheduler>:
; void vTaskStartScheduler(void) {
700a5730: b580         	push	{r7, lr}
700a5732: b088         	sub	sp, #0x20
700a5734: 2000         	movs	r0, #0x0
;     StaticTask_t *pxIdleTaskTCBBuffer = NULL;
700a5736: 9003         	str	r0, [sp, #0xc]
700a5738: 9006         	str	r0, [sp, #0x18]
;     StackType_t *pxIdleTaskStackBuffer = NULL;
700a573a: 9005         	str	r0, [sp, #0x14]
700a573c: a806         	add	r0, sp, #0x18
700a573e: a905         	add	r1, sp, #0x14
700a5740: aa04         	add	r2, sp, #0x10
;     vApplicationGetIdleTaskMemory(&pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer,
700a5742: f007 f9a5    	bl	0x700aca90 <vApplicationGetIdleTaskMemory> @ imm = #0x734a
700a5746: 9b03         	ldr	r3, [sp, #0xc]
;         prvIdleTask, configIDLE_TASK_NAME, ulIdleTaskStackSize,
700a5748: 9a04         	ldr	r2, [sp, #0x10]
;         pxIdleTaskStackBuffer,
700a574a: 9905         	ldr	r1, [sp, #0x14]
;         pxIdleTaskTCBBuffer); /*lint !e961 MISRA exception, justified as it is
700a574c: f8dd c018    	ldr.w	r12, [sp, #0x18]
;     xIdleTaskHandle = xTaskCreateStatic(
700a5750: 4668         	mov	r0, sp
700a5752: f8c0 c008    	str.w	r12, [r0, #0x8]
700a5756: 6041         	str	r1, [r0, #0x4]
700a5758: 6003         	str	r3, [r0]
700a575a: f64a 5051    	movw	r0, #0xad51
700a575e: f2c7 000a    	movt	r0, #0x700a
700a5762: f240 1138    	movw	r1, #0x138
700a5766: f2c7 010b    	movt	r1, #0x700b
700a576a: f003 fd99    	bl	0x700a92a0 <xTaskCreateStatic> @ imm = #0x3b32
700a576e: 4601         	mov	r1, r0
700a5770: f240 500c    	movw	r0, #0x50c
700a5774: f2c7 000b    	movt	r0, #0x700b
700a5778: 6001         	str	r1, [r0]
;     if (xIdleTaskHandle != NULL) {
700a577a: 6800         	ldr	r0, [r0]
700a577c: b118         	cbz	r0, 0x700a5786 <vTaskStartScheduler+0x56> @ imm = #0x6
700a577e: e7ff         	b	0x700a5780 <vTaskStartScheduler+0x50> @ imm = #-0x2
700a5780: 2001         	movs	r0, #0x1
;       xReturn = pdPASS;
700a5782: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a5784: e002         	b	0x700a578c <vTaskStartScheduler+0x5c> @ imm = #0x4
700a5786: 2000         	movs	r0, #0x0
;       xReturn = pdFAIL;
700a5788: 9007         	str	r0, [sp, #0x1c]
700a578a: e7ff         	b	0x700a578c <vTaskStartScheduler+0x5c> @ imm = #-0x2
;     if (xReturn == pdPASS) {
700a578c: 9807         	ldr	r0, [sp, #0x1c]
700a578e: 2801         	cmp	r0, #0x1
700a5790: d104         	bne	0x700a579c <vTaskStartScheduler+0x6c> @ imm = #0x8
700a5792: e7ff         	b	0x700a5794 <vTaskStartScheduler+0x64> @ imm = #-0x2
;       xReturn = xTimerCreateTimerTask();
700a5794: f003 fb44    	bl	0x700a8e20 <xTimerCreateTimerTask> @ imm = #0x3688
700a5798: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a579a: e000         	b	0x700a579e <vTaskStartScheduler+0x6e> @ imm = #0x0
700a579c: e7ff         	b	0x700a579e <vTaskStartScheduler+0x6e> @ imm = #-0x2
;   if (xReturn == pdPASS) {
700a579e: 9807         	ldr	r0, [sp, #0x1c]
700a57a0: 2801         	cmp	r0, #0x1
700a57a2: d11d         	bne	0x700a57e0 <vTaskStartScheduler+0xb0> @ imm = #0x3a
700a57a4: e7ff         	b	0x700a57a6 <vTaskStartScheduler+0x76> @ imm = #-0x2
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700a57a6: b672         	cpsid i
;     xNextTaskUnblockTime = portMAX_DELAY;
700a57a8: f240 5110    	movw	r1, #0x510
700a57ac: f2c7 010b    	movt	r1, #0x700b
700a57b0: f04f 30ff    	mov.w	r0, #0xffffffff
700a57b4: 6008         	str	r0, [r1]
;     xSchedulerRunning = pdTRUE;
700a57b6: f240 511c    	movw	r1, #0x51c
700a57ba: f2c7 010b    	movt	r1, #0x700b
700a57be: 2001         	movs	r0, #0x1
700a57c0: 6008         	str	r0, [r1]
;     xTickCount = (TickType_t)configINITIAL_TICK_COUNT;
700a57c2: f240 5120    	movw	r1, #0x520
700a57c6: f2c7 010b    	movt	r1, #0x700b
700a57ca: 2000         	movs	r0, #0x0
700a57cc: 6008         	str	r0, [r1]
;     portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
700a57ce: f008 f997    	bl	0x700adb00 <vPortConfigTimerForRunTimeStats> @ imm = #0x832e
;     if (xPortStartScheduler() != pdFALSE) {
700a57d2: f007 fd65    	bl	0x700ad2a0 <xPortStartScheduler> @ imm = #0x7aca
700a57d6: b108         	cbz	r0, 0x700a57dc <vTaskStartScheduler+0xac> @ imm = #0x2
700a57d8: e7ff         	b	0x700a57da <vTaskStartScheduler+0xaa> @ imm = #-0x2
;     } else {
700a57da: e000         	b	0x700a57de <vTaskStartScheduler+0xae> @ imm = #0x0
700a57dc: e7ff         	b	0x700a57de <vTaskStartScheduler+0xae> @ imm = #-0x2
;   } else {
700a57de: e000         	b	0x700a57e2 <vTaskStartScheduler+0xb2> @ imm = #0x0
700a57e0: e7ff         	b	0x700a57e2 <vTaskStartScheduler+0xb2> @ imm = #-0x2
;   (void)uxTopUsedPriority;
700a57e2: f240 1074    	movw	r0, #0x174
700a57e6: f2c7 000b    	movt	r0, #0x700b
700a57ea: 6800         	ldr	r0, [r0]
; }
700a57ec: b008         	add	sp, #0x20
700a57ee: bd80         	pop	{r7, pc}

700a57f0 <prvSwitchTimerLists>:
;     {
700a57f0: b580         	push	{r7, lr}
700a57f2: b086         	sub	sp, #0x18
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a57f4: e7ff         	b	0x700a57f6 <prvSwitchTimerLists+0x6> @ imm = #-0x2
700a57f6: f644 70b4    	movw	r0, #0x4fb4
700a57fa: f2c7 0008    	movt	r0, #0x7008
700a57fe: 6800         	ldr	r0, [r0]
700a5800: 6800         	ldr	r0, [r0]
700a5802: 2800         	cmp	r0, #0x0
700a5804: d040         	beq	0x700a5888 <prvSwitchTimerLists+0x98> @ imm = #0x80
700a5806: e7ff         	b	0x700a5808 <prvSwitchTimerLists+0x18> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700a5808: f644 70b4    	movw	r0, #0x4fb4
700a580c: f2c7 0008    	movt	r0, #0x7008
700a5810: 6801         	ldr	r1, [r0]
700a5812: 68c9         	ldr	r1, [r1, #0xc]
700a5814: 6809         	ldr	r1, [r1]
700a5816: 9105         	str	r1, [sp, #0x14]
;             pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700a5818: 6800         	ldr	r0, [r0]
700a581a: 68c0         	ldr	r0, [r0, #0xc]
700a581c: 68c0         	ldr	r0, [r0, #0xc]
700a581e: 9002         	str	r0, [sp, #0x8]
;             ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a5820: 9802         	ldr	r0, [sp, #0x8]
700a5822: 3004         	adds	r0, #0x4
700a5824: f005 fe84    	bl	0x700ab530 <uxListRemove> @ imm = #0x5d08
;             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a5828: 9802         	ldr	r0, [sp, #0x8]
700a582a: 6a01         	ldr	r1, [r0, #0x20]
700a582c: 4788         	blx	r1
;             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a582e: 9802         	ldr	r0, [sp, #0x8]
700a5830: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a5834: 0740         	lsls	r0, r0, #0x1d
700a5836: 2800         	cmp	r0, #0x0
700a5838: d524         	bpl	0x700a5884 <prvSwitchTimerLists+0x94> @ imm = #0x48
700a583a: e7ff         	b	0x700a583c <prvSwitchTimerLists+0x4c> @ imm = #-0x2
;                 xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
700a583c: 9805         	ldr	r0, [sp, #0x14]
700a583e: 9902         	ldr	r1, [sp, #0x8]
700a5840: 6989         	ldr	r1, [r1, #0x18]
700a5842: 4408         	add	r0, r1
700a5844: 9004         	str	r0, [sp, #0x10]
;                 if( xReloadTime > xNextExpireTime )
700a5846: 9804         	ldr	r0, [sp, #0x10]
700a5848: 9905         	ldr	r1, [sp, #0x14]
700a584a: 4288         	cmp	r0, r1
700a584c: d90f         	bls	0x700a586e <prvSwitchTimerLists+0x7e> @ imm = #0x1e
700a584e: e7ff         	b	0x700a5850 <prvSwitchTimerLists+0x60> @ imm = #-0x2
;                     listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
700a5850: 9804         	ldr	r0, [sp, #0x10]
700a5852: 9902         	ldr	r1, [sp, #0x8]
700a5854: 6048         	str	r0, [r1, #0x4]
;                     listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700a5856: 9802         	ldr	r0, [sp, #0x8]
700a5858: 6100         	str	r0, [r0, #0x10]
;                     vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700a585a: f644 70b4    	movw	r0, #0x4fb4
700a585e: f2c7 0008    	movt	r0, #0x7008
700a5862: 6800         	ldr	r0, [r0]
700a5864: 9902         	ldr	r1, [sp, #0x8]
700a5866: 3104         	adds	r1, #0x4
700a5868: f003 ff1a    	bl	0x700a96a0 <vListInsert> @ imm = #0x3e34
;                 }
700a586c: e009         	b	0x700a5882 <prvSwitchTimerLists+0x92> @ imm = #0x12
;                     xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700a586e: 9802         	ldr	r0, [sp, #0x8]
700a5870: 9a05         	ldr	r2, [sp, #0x14]
700a5872: 4669         	mov	r1, sp
700a5874: 2300         	movs	r3, #0x0
700a5876: 600b         	str	r3, [r1]
700a5878: 4619         	mov	r1, r3
700a587a: f002 f8e9    	bl	0x700a7a50 <xTimerGenericCommand> @ imm = #0x21d2
700a587e: 9001         	str	r0, [sp, #0x4]
700a5880: e7ff         	b	0x700a5882 <prvSwitchTimerLists+0x92> @ imm = #-0x2
;             }
700a5882: e000         	b	0x700a5886 <prvSwitchTimerLists+0x96> @ imm = #0x0
700a5884: e7ff         	b	0x700a5886 <prvSwitchTimerLists+0x96> @ imm = #-0x2
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a5886: e7b6         	b	0x700a57f6 <prvSwitchTimerLists+0x6> @ imm = #-0x94
;         pxTemp = pxCurrentTimerList;
700a5888: f644 72b4    	movw	r2, #0x4fb4
700a588c: f2c7 0208    	movt	r2, #0x7008
700a5890: 6810         	ldr	r0, [r2]
700a5892: 9003         	str	r0, [sp, #0xc]
;         pxCurrentTimerList = pxOverflowTimerList;
700a5894: f644 71c0    	movw	r1, #0x4fc0
700a5898: f2c7 0108    	movt	r1, #0x7008
700a589c: 6808         	ldr	r0, [r1]
700a589e: 6010         	str	r0, [r2]
;         pxOverflowTimerList = pxTemp;
700a58a0: 9803         	ldr	r0, [sp, #0xc]
700a58a2: 6008         	str	r0, [r1]
;     }
700a58a4: b006         	add	sp, #0x18
700a58a6: bd80         	pop	{r7, pc}
		...

700a58b0 <CSL_pktdmaAccessChanPeerReg>:
; {
700a58b0: b580         	push	{r7, lr}
700a58b2: b088         	sub	sp, #0x20
700a58b4: 4684         	mov	r12, r0
700a58b6: 980b         	ldr	r0, [sp, #0x2c]
700a58b8: f8dd e028    	ldr.w	lr, [sp, #0x28]
700a58bc: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a58c0: 9106         	str	r1, [sp, #0x18]
700a58c2: 9205         	str	r2, [sp, #0x14]
700a58c4: 9304         	str	r3, [sp, #0x10]
700a58c6: f88d 000f    	strb.w	r0, [sp, #0xf]
700a58ca: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a58cc: 9002         	str	r0, [sp, #0x8]
;     if( (pCfg == NULL) || (pVal == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a58ce: 9807         	ldr	r0, [sp, #0x1c]
700a58d0: b150         	cbz	r0, 0x700a58e8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0x14
700a58d2: e7ff         	b	0x700a58d4 <CSL_pktdmaAccessChanPeerReg+0x24> @ imm = #-0x2
700a58d4: 9804         	ldr	r0, [sp, #0x10]
700a58d6: b138         	cbz	r0, 0x700a58e8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0xe
700a58d8: e7ff         	b	0x700a58da <CSL_pktdmaAccessChanPeerReg+0x2a> @ imm = #-0x2
700a58da: 9807         	ldr	r0, [sp, #0x1c]
700a58dc: 9906         	ldr	r1, [sp, #0x18]
700a58de: 9a0a         	ldr	r2, [sp, #0x28]
700a58e0: f005 f976    	bl	0x700aabd0 <CSL_pktdmaIsValidChanIdx> @ imm = #0x52ec
700a58e4: b920         	cbnz	r0, 0x700a58f0 <CSL_pktdmaAccessChanPeerReg+0x40> @ imm = #0x8
700a58e6: e7ff         	b	0x700a58e8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #-0x2
700a58e8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a58ec: 9002         	str	r0, [sp, #0x8]
;     }
700a58ee: e037         	b	0x700a5960 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #0x6e
;         if( regIdx < CSL_PKTDMA_NUM_PEER_REGS )
700a58f0: 9805         	ldr	r0, [sp, #0x14]
700a58f2: 280f         	cmp	r0, #0xf
700a58f4: d82f         	bhi	0x700a5956 <CSL_pktdmaAccessChanPeerReg+0xa6> @ imm = #0x5e
700a58f6: e7ff         	b	0x700a58f8 <CSL_pktdmaAccessChanPeerReg+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a58f8: 980a         	ldr	r0, [sp, #0x28]
700a58fa: b960         	cbnz	r0, 0x700a5916 <CSL_pktdmaAccessChanPeerReg+0x66> @ imm = #0x18
700a58fc: e7ff         	b	0x700a58fe <CSL_pktdmaAccessChanPeerReg+0x4e> @ imm = #-0x2
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pTxChanRtRegs) + (uintptr_t)CSL_PKTDMA_TXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a58fe: 9807         	ldr	r0, [sp, #0x1c]
700a5900: 6900         	ldr	r0, [r0, #0x10]
700a5902: 9906         	ldr	r1, [sp, #0x18]
700a5904: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5908: 9905         	ldr	r1, [sp, #0x14]
700a590a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a590e: f500 7000    	add.w	r0, r0, #0x200
700a5912: 9001         	str	r0, [sp, #0x4]
;             }
700a5914: e00b         	b	0x700a592e <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #0x16
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pRxChanRtRegs) + (uintptr_t)CSL_PKTDMA_RXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a5916: 9807         	ldr	r0, [sp, #0x1c]
700a5918: 6940         	ldr	r0, [r0, #0x14]
700a591a: 9906         	ldr	r1, [sp, #0x18]
700a591c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5920: 9905         	ldr	r1, [sp, #0x14]
700a5922: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5926: f500 7000    	add.w	r0, r0, #0x200
700a592a: 9001         	str	r0, [sp, #0x4]
700a592c: e7ff         	b	0x700a592e <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #-0x2
;             if( bRdAccess == (bool)true )
700a592e: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a5932: 07c0         	lsls	r0, r0, #0x1f
700a5934: b130         	cbz	r0, 0x700a5944 <CSL_pktdmaAccessChanPeerReg+0x94> @ imm = #0xc
700a5936: e7ff         	b	0x700a5938 <CSL_pktdmaAccessChanPeerReg+0x88> @ imm = #-0x2
;                 *pVal = CSL_REG32_RD( pPeerReg );
700a5938: 9801         	ldr	r0, [sp, #0x4]
700a593a: f008 f819    	bl	0x700ad970 <CSL_REG32_RD_RAW> @ imm = #0x8032
700a593e: 9904         	ldr	r1, [sp, #0x10]
700a5940: 6008         	str	r0, [r1]
;             }
700a5942: e005         	b	0x700a5950 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #0xa
;                 CSL_REG32_WR( pPeerReg, *pVal );
700a5944: 9801         	ldr	r0, [sp, #0x4]
700a5946: 9904         	ldr	r1, [sp, #0x10]
700a5948: 6809         	ldr	r1, [r1]
700a594a: f007 ff69    	bl	0x700ad820 <CSL_REG32_WR_RAW> @ imm = #0x7ed2
700a594e: e7ff         	b	0x700a5950 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #-0x2
700a5950: 2000         	movs	r0, #0x0
;             retVal = CSL_PASS;
700a5952: 9002         	str	r0, [sp, #0x8]
;         }
700a5954: e003         	b	0x700a595e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #0x6
700a5956: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a595a: 9002         	str	r0, [sp, #0x8]
700a595c: e7ff         	b	0x700a595e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #-0x2
700a595e: e7ff         	b	0x700a5960 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #-0x2
;     return retVal;
700a5960: 9802         	ldr	r0, [sp, #0x8]
700a5962: b008         	add	sp, #0x20
700a5964: bd80         	pop	{r7, pc}
		...
700a596e: 0000         	movs	r0, r0

700a5970 <UART_fifoWrite>:
; {
700a5970: b580         	push	{r7, lr}
700a5972: b08c         	sub	sp, #0x30
700a5974: 900b         	str	r0, [sp, #0x2c]
700a5976: 910a         	str	r1, [sp, #0x28]
700a5978: 9209         	str	r2, [sp, #0x24]
;     uint32_t tempWriteSizeRemaining = writeSizeRemaining;
700a597a: 9809         	ldr	r0, [sp, #0x24]
700a597c: 9008         	str	r0, [sp, #0x20]
;     uint32_t size                  = tempWriteSizeRemaining;
700a597e: 9808         	ldr	r0, [sp, #0x20]
700a5980: 9007         	str	r0, [sp, #0x1c]
;     const uint8_t *tempBuffer = buffer;
700a5982: 980a         	ldr	r0, [sp, #0x28]
700a5984: 9006         	str	r0, [sp, #0x18]
700a5986: 2000         	movs	r0, #0x0
;     uint32_t lineStatus            = 0U;
700a5988: 9005         	str	r0, [sp, #0x14]
;     uint32_t tempChunksize         = 0U;
700a598a: 9004         	str	r0, [sp, #0x10]
700a598c: f640 30b8    	movw	r0, #0xbb8
;     int32_t  maxTrialCount         = (int32_t) UART_TRANSMITEMPTY_TRIALCOUNT;
700a5990: 9003         	str	r0, [sp, #0xc]
700a5992: 2040         	movs	r0, #0x40
;     tempChunksize = UART_FIFO_SIZE;
700a5994: 9004         	str	r0, [sp, #0x10]
;     do
700a5996: e7ff         	b	0x700a5998 <UART_fifoWrite+0x28> @ imm = #-0x2
;         lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a5998: 980b         	ldr	r0, [sp, #0x2c]
700a599a: 6800         	ldr	r0, [r0]
700a599c: f005 fe90    	bl	0x700ab6c0 <UART_readLineStatus> @ imm = #0x5d20
700a59a0: 9005         	str	r0, [sp, #0x14]
;         maxTrialCount--;
700a59a2: 9803         	ldr	r0, [sp, #0xc]
700a59a4: 3801         	subs	r0, #0x1
700a59a6: 9003         	str	r0, [sp, #0xc]
;     }
700a59a8: e7ff         	b	0x700a59aa <UART_fifoWrite+0x3a> @ imm = #-0x2
;                        UART_LSR_TX_FIFO_E_MASK) & lineStatus))
700a59aa: 9805         	ldr	r0, [sp, #0x14]
700a59ac: f000 0160    	and	r1, r0, #0x60
700a59b0: 2000         	movs	r0, #0x0
;            && (0 < maxTrialCount));
700a59b2: 2960         	cmp	r1, #0x60
700a59b4: 9002         	str	r0, [sp, #0x8]
700a59b6: d007         	beq	0x700a59c8 <UART_fifoWrite+0x58> @ imm = #0xe
700a59b8: e7ff         	b	0x700a59ba <UART_fifoWrite+0x4a> @ imm = #-0x2
700a59ba: 9903         	ldr	r1, [sp, #0xc]
700a59bc: 2000         	movs	r0, #0x0
700a59be: 2900         	cmp	r1, #0x0
700a59c0: bfc8         	it	gt
700a59c2: 2001         	movgt	r0, #0x1
700a59c4: 9002         	str	r0, [sp, #0x8]
700a59c6: e7ff         	b	0x700a59c8 <UART_fifoWrite+0x58> @ imm = #-0x2
700a59c8: 9802         	ldr	r0, [sp, #0x8]
;     }
700a59ca: 07c0         	lsls	r0, r0, #0x1f
700a59cc: 2800         	cmp	r0, #0x0
700a59ce: d1e3         	bne	0x700a5998 <UART_fifoWrite+0x28> @ imm = #-0x3a
700a59d0: e7ff         	b	0x700a59d2 <UART_fifoWrite+0x62> @ imm = #-0x2
;     if (maxTrialCount > 0)
700a59d2: 9803         	ldr	r0, [sp, #0xc]
700a59d4: 2801         	cmp	r0, #0x1
700a59d6: db21         	blt	0x700a5a1c <UART_fifoWrite+0xac> @ imm = #0x42
700a59d8: e7ff         	b	0x700a59da <UART_fifoWrite+0x6a> @ imm = #-0x2
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a59da: e7ff         	b	0x700a59dc <UART_fifoWrite+0x6c> @ imm = #-0x2
700a59dc: 9904         	ldr	r1, [sp, #0x10]
700a59de: 2000         	movs	r0, #0x0
700a59e0: 9001         	str	r0, [sp, #0x4]
700a59e2: b131         	cbz	r1, 0x700a59f2 <UART_fifoWrite+0x82> @ imm = #0xc
700a59e4: e7ff         	b	0x700a59e6 <UART_fifoWrite+0x76> @ imm = #-0x2
700a59e6: 9808         	ldr	r0, [sp, #0x20]
700a59e8: 2800         	cmp	r0, #0x0
700a59ea: bf18         	it	ne
700a59ec: 2001         	movne	r0, #0x1
700a59ee: 9001         	str	r0, [sp, #0x4]
700a59f0: e7ff         	b	0x700a59f2 <UART_fifoWrite+0x82> @ imm = #-0x2
700a59f2: 9801         	ldr	r0, [sp, #0x4]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a59f4: 07c0         	lsls	r0, r0, #0x1f
700a59f6: b180         	cbz	r0, 0x700a5a1a <UART_fifoWrite+0xaa> @ imm = #0x20
700a59f8: e7ff         	b	0x700a59fa <UART_fifoWrite+0x8a> @ imm = #-0x2
;             UART_putChar(hUart->baseAddr, (*tempBuffer));
700a59fa: 980b         	ldr	r0, [sp, #0x2c]
700a59fc: 6800         	ldr	r0, [r0]
700a59fe: 9906         	ldr	r1, [sp, #0x18]
700a5a00: 7809         	ldrb	r1, [r1]
700a5a02: f007 fd5d    	bl	0x700ad4c0 <UART_putChar> @ imm = #0x7aba
;             tempBuffer++;
700a5a06: 9806         	ldr	r0, [sp, #0x18]
700a5a08: 3001         	adds	r0, #0x1
700a5a0a: 9006         	str	r0, [sp, #0x18]
;             tempWriteSizeRemaining--;
700a5a0c: 9808         	ldr	r0, [sp, #0x20]
700a5a0e: 3801         	subs	r0, #0x1
700a5a10: 9008         	str	r0, [sp, #0x20]
;             tempChunksize--;
700a5a12: 9804         	ldr	r0, [sp, #0x10]
700a5a14: 3801         	subs	r0, #0x1
700a5a16: 9004         	str	r0, [sp, #0x10]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a5a18: e7e0         	b	0x700a59dc <UART_fifoWrite+0x6c> @ imm = #-0x40
;     }
700a5a1a: e7ff         	b	0x700a5a1c <UART_fifoWrite+0xac> @ imm = #-0x2
;     return (size - tempWriteSizeRemaining);
700a5a1c: 9807         	ldr	r0, [sp, #0x1c]
700a5a1e: 9908         	ldr	r1, [sp, #0x20]
700a5a20: 1a40         	subs	r0, r0, r1
700a5a22: b00c         	add	sp, #0x30
700a5a24: bd80         	pop	{r7, pc}
		...
700a5a2e: 0000         	movs	r0, r0

700a5a30 <xTaskPriorityDisinherit>:
; BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder) {
700a5a30: b580         	push	{r7, lr}
700a5a32: b084         	sub	sp, #0x10
700a5a34: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxTCB = pxMutexHolder;
700a5a36: 9803         	ldr	r0, [sp, #0xc]
700a5a38: 9002         	str	r0, [sp, #0x8]
700a5a3a: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a5a3c: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a5a3e: 9803         	ldr	r0, [sp, #0xc]
700a5a40: 2800         	cmp	r0, #0x0
700a5a42: d04b         	beq	0x700a5adc <xTaskPriorityDisinherit+0xac> @ imm = #0x96
700a5a44: e7ff         	b	0x700a5a46 <xTaskPriorityDisinherit+0x16> @ imm = #-0x2
;     (pxTCB->uxMutexesHeld)--;
700a5a46: 9902         	ldr	r1, [sp, #0x8]
700a5a48: 6e48         	ldr	r0, [r1, #0x64]
700a5a4a: 3801         	subs	r0, #0x1
700a5a4c: 6648         	str	r0, [r1, #0x64]
;     if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
700a5a4e: 9902         	ldr	r1, [sp, #0x8]
700a5a50: 6ac8         	ldr	r0, [r1, #0x2c]
700a5a52: 6e09         	ldr	r1, [r1, #0x60]
700a5a54: 4288         	cmp	r0, r1
700a5a56: d03f         	beq	0x700a5ad8 <xTaskPriorityDisinherit+0xa8> @ imm = #0x7e
700a5a58: e7ff         	b	0x700a5a5a <xTaskPriorityDisinherit+0x2a> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
700a5a5a: 9802         	ldr	r0, [sp, #0x8]
700a5a5c: 6e40         	ldr	r0, [r0, #0x64]
700a5a5e: bbc8         	cbnz	r0, 0x700a5ad4 <xTaskPriorityDisinherit+0xa4> @ imm = #0x72
700a5a60: e7ff         	b	0x700a5a62 <xTaskPriorityDisinherit+0x32> @ imm = #-0x2
;         if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a5a62: 9802         	ldr	r0, [sp, #0x8]
700a5a64: 3004         	adds	r0, #0x4
700a5a66: f005 fd63    	bl	0x700ab530 <uxListRemove> @ imm = #0x5ac6
700a5a6a: b968         	cbnz	r0, 0x700a5a88 <xTaskPriorityDisinherit+0x58> @ imm = #0x1a
700a5a6c: e7ff         	b	0x700a5a6e <xTaskPriorityDisinherit+0x3e> @ imm = #-0x2
;           portRESET_READY_PRIORITY(pxTCB->uxPriority, uxTopReadyPriority);
700a5a6e: 9802         	ldr	r0, [sp, #0x8]
700a5a70: 6ac1         	ldr	r1, [r0, #0x2c]
700a5a72: 2001         	movs	r0, #0x1
700a5a74: fa00 f201    	lsl.w	r2, r0, r1
700a5a78: f240 5108    	movw	r1, #0x508
700a5a7c: f2c7 010b    	movt	r1, #0x700b
700a5a80: 6808         	ldr	r0, [r1]
700a5a82: 4390         	bics	r0, r2
700a5a84: 6008         	str	r0, [r1]
;         } else {
700a5a86: e000         	b	0x700a5a8a <xTaskPriorityDisinherit+0x5a> @ imm = #0x0
700a5a88: e7ff         	b	0x700a5a8a <xTaskPriorityDisinherit+0x5a> @ imm = #-0x2
;         pxTCB->uxPriority = pxTCB->uxBasePriority;
700a5a8a: 9902         	ldr	r1, [sp, #0x8]
700a5a8c: 6e08         	ldr	r0, [r1, #0x60]
700a5a8e: 62c8         	str	r0, [r1, #0x2c]
;         listSET_LIST_ITEM_VALUE(
700a5a90: 9902         	ldr	r1, [sp, #0x8]
700a5a92: 6ac8         	ldr	r0, [r1, #0x2c]
700a5a94: f1c0 0020    	rsb.w	r0, r0, #0x20
700a5a98: 6188         	str	r0, [r1, #0x18]
;         prvAddTaskToReadyList(pxTCB);
700a5a9a: 9802         	ldr	r0, [sp, #0x8]
700a5a9c: 6ac1         	ldr	r1, [r0, #0x2c]
700a5a9e: 2001         	movs	r0, #0x1
700a5aa0: 9000         	str	r0, [sp]
700a5aa2: fa00 f201    	lsl.w	r2, r0, r1
700a5aa6: f240 5108    	movw	r1, #0x508
700a5aaa: f2c7 010b    	movt	r1, #0x700b
700a5aae: 6808         	ldr	r0, [r1]
700a5ab0: 4310         	orrs	r0, r2
700a5ab2: 6008         	str	r0, [r1]
700a5ab4: 9902         	ldr	r1, [sp, #0x8]
700a5ab6: 6ac8         	ldr	r0, [r1, #0x2c]
700a5ab8: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a5abc: f244 40f8    	movw	r0, #0x44f8
700a5ac0: f2c7 0008    	movt	r0, #0x7008
700a5ac4: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a5ac8: 3104         	adds	r1, #0x4
700a5aca: f006 fae9    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #0x65d2
700a5ace: 9800         	ldr	r0, [sp]
;         xReturn = pdTRUE;
700a5ad0: 9001         	str	r0, [sp, #0x4]
;       } else {
700a5ad2: e000         	b	0x700a5ad6 <xTaskPriorityDisinherit+0xa6> @ imm = #0x0
700a5ad4: e7ff         	b	0x700a5ad6 <xTaskPriorityDisinherit+0xa6> @ imm = #-0x2
;     } else {
700a5ad6: e000         	b	0x700a5ada <xTaskPriorityDisinherit+0xaa> @ imm = #0x0
700a5ad8: e7ff         	b	0x700a5ada <xTaskPriorityDisinherit+0xaa> @ imm = #-0x2
;   } else {
700a5ada: e000         	b	0x700a5ade <xTaskPriorityDisinherit+0xae> @ imm = #0x0
700a5adc: e7ff         	b	0x700a5ade <xTaskPriorityDisinherit+0xae> @ imm = #-0x2
;   return xReturn;
700a5ade: 9801         	ldr	r0, [sp, #0x4]
700a5ae0: b004         	add	sp, #0x10
700a5ae2: bd80         	pop	{r7, pc}
		...

700a5af0 <Sciclient_getCurrentContext>:
; {
700a5af0: b082         	sub	sp, #0x8
700a5af2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700a5af6: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a5af8: 9000         	str	r0, [sp]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a5afa: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5afe: 280a         	cmp	r0, #0xa
700a5b00: d03e         	beq	0x700a5b80 <Sciclient_getCurrentContext+0x90> @ imm = #0x7c
700a5b02: e7ff         	b	0x700a5b04 <Sciclient_getCurrentContext+0x14> @ imm = #-0x2
;        (TISCI_MSG_SEC_HANDOVER == messageType) ||
700a5b04: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5b08: f249 0130    	movw	r1, #0x9030
700a5b0c: 4288         	cmp	r0, r1
700a5b0e: d037         	beq	0x700a5b80 <Sciclient_getCurrentContext+0x90> @ imm = #0x6e
700a5b10: e7ff         	b	0x700a5b12 <Sciclient_getCurrentContext+0x22> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG == messageType) ||
700a5b12: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5b16: 280b         	cmp	r0, #0xb
700a5b18: d032         	beq	0x700a5b80 <Sciclient_getCurrentContext+0x90> @ imm = #0x64
700a5b1a: e7ff         	b	0x700a5b1c <Sciclient_getCurrentContext+0x2c> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_RM == messageType) ||
700a5b1c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5b20: 280c         	cmp	r0, #0xc
700a5b22: d02d         	beq	0x700a5b80 <Sciclient_getCurrentContext+0x90> @ imm = #0x5a
700a5b24: e7ff         	b	0x700a5b26 <Sciclient_getCurrentContext+0x36> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_SECURITY == messageType) ||
700a5b26: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5b2a: 280d         	cmp	r0, #0xd
700a5b2c: d028         	beq	0x700a5b80 <Sciclient_getCurrentContext+0x90> @ imm = #0x50
700a5b2e: e7ff         	b	0x700a5b30 <Sciclient_getCurrentContext+0x40> @ imm = #-0x2
;        (TISCI_MSG_KEY_WRITER == messageType) ||
700a5b30: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5b34: f249 0131    	movw	r1, #0x9031
700a5b38: 4288         	cmp	r0, r1
700a5b3a: d021         	beq	0x700a5b80 <Sciclient_getCurrentContext+0x90> @ imm = #0x42
700a5b3c: e7ff         	b	0x700a5b3e <Sciclient_getCurrentContext+0x4e> @ imm = #-0x2
;        (TISCI_MSG_READ_OTP_MMR == messageType) ||
700a5b3e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5b42: f249 0122    	movw	r1, #0x9022
700a5b46: 4288         	cmp	r0, r1
700a5b48: d01a         	beq	0x700a5b80 <Sciclient_getCurrentContext+0x90> @ imm = #0x34
700a5b4a: e7ff         	b	0x700a5b4c <Sciclient_getCurrentContext+0x5c> @ imm = #-0x2
;        (TISCI_MSG_WRITE_OTP_ROW == messageType) ||
700a5b4c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5b50: f249 0123    	movw	r1, #0x9023
700a5b54: 4288         	cmp	r0, r1
700a5b56: d013         	beq	0x700a5b80 <Sciclient_getCurrentContext+0x90> @ imm = #0x26
700a5b58: e7ff         	b	0x700a5b5a <Sciclient_getCurrentContext+0x6a> @ imm = #-0x2
;        (TISCI_MSG_READ_SWREV == messageType) ||
700a5b5a: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5b5e: f249 0133    	movw	r1, #0x9033
700a5b62: 4288         	cmp	r0, r1
700a5b64: d00c         	beq	0x700a5b80 <Sciclient_getCurrentContext+0x90> @ imm = #0x18
700a5b66: e7ff         	b	0x700a5b68 <Sciclient_getCurrentContext+0x78> @ imm = #-0x2
;        (TISCI_MSG_WRITE_SWREV == messageType) ||
700a5b68: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5b6c: f249 0132    	movw	r1, #0x9032
700a5b70: 4288         	cmp	r0, r1
700a5b72: d005         	beq	0x700a5b80 <Sciclient_getCurrentContext+0x90> @ imm = #0xa
700a5b74: e7ff         	b	0x700a5b76 <Sciclient_getCurrentContext+0x86> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_PM == messageType))
700a5b76: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a5b7a: 280e         	cmp	r0, #0xe
700a5b7c: d107         	bne	0x700a5b8e <Sciclient_getCurrentContext+0x9e> @ imm = #0xe
700a5b7e: e7ff         	b	0x700a5b80 <Sciclient_getCurrentContext+0x90> @ imm = #-0x2
;         retVal = gSciclientHandle.secureContextId;
700a5b80: f240 4038    	movw	r0, #0x438
700a5b84: f2c7 000b    	movt	r0, #0x700b
700a5b88: 68c0         	ldr	r0, [r0, #0xc]
700a5b8a: 9000         	str	r0, [sp]
;     }
700a5b8c: e006         	b	0x700a5b9c <Sciclient_getCurrentContext+0xac> @ imm = #0xc
;         retVal = gSciclientHandle.nonSecureContextId;
700a5b8e: f240 4038    	movw	r0, #0x438
700a5b92: f2c7 000b    	movt	r0, #0x700b
700a5b96: 6900         	ldr	r0, [r0, #0x10]
700a5b98: 9000         	str	r0, [sp]
700a5b9a: e7ff         	b	0x700a5b9c <Sciclient_getCurrentContext+0xac> @ imm = #-0x2
;     return retVal;
700a5b9c: 9800         	ldr	r0, [sp]
700a5b9e: b002         	add	sp, #0x8
700a5ba0: 4770         	bx	lr
		...
700a5bae: 0000         	movs	r0, r0

700a5bb0 <UART_init>:
; {
700a5bb0: b580         	push	{r7, lr}
700a5bb2: b086         	sub	sp, #0x18
700a5bb4: 2000         	movs	r0, #0x0
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a5bb6: 9004         	str	r0, [sp, #0x10]
700a5bb8: e7ff         	b	0x700a5bba <UART_init+0xa> @ imm = #-0x2
700a5bba: 9804         	ldr	r0, [sp, #0x10]
700a5bbc: f240 41cc    	movw	r1, #0x4cc
700a5bc0: f2c7 010b    	movt	r1, #0x700b
700a5bc4: 6809         	ldr	r1, [r1]
700a5bc6: 4288         	cmp	r0, r1
700a5bc8: d236         	bhs	0x700a5c38 <UART_init+0x88> @ imm = #0x6c
700a5bca: e7ff         	b	0x700a5bcc <UART_init+0x1c> @ imm = #-0x2
;         object = gUartConfig[cnt].object;
700a5bcc: 9904         	ldr	r1, [sp, #0x10]
700a5bce: f240 4088    	movw	r0, #0x488
700a5bd2: f2c7 000b    	movt	r0, #0x700b
700a5bd6: 9002         	str	r0, [sp, #0x8]
700a5bd8: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a5bdc: 6840         	ldr	r0, [r0, #0x4]
700a5bde: 9003         	str	r0, [sp, #0xc]
;         DebugP_assert(NULL_PTR != object);
700a5be0: 9803         	ldr	r0, [sp, #0xc]
700a5be2: 2800         	cmp	r0, #0x0
700a5be4: bf18         	it	ne
700a5be6: 2001         	movne	r0, #0x1
700a5be8: f64f 316f    	movw	r1, #0xfb6f
700a5bec: f2c7 010a    	movt	r1, #0x700a
700a5bf0: 466a         	mov	r2, sp
700a5bf2: 6011         	str	r1, [r2]
700a5bf4: f64f 3182    	movw	r1, #0xfb82
700a5bf8: f2c7 010a    	movt	r1, #0x700a
700a5bfc: f64f 4278    	movw	r2, #0xfc78
700a5c00: f2c7 020a    	movt	r2, #0x700a
700a5c04: 23bf         	movs	r3, #0xbf
700a5c06: f003 f80b    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x3016
;         (void)memset(object, 0, sizeof(UART_Object));
700a5c0a: 9803         	ldr	r0, [sp, #0xc]
700a5c0c: f44f 715a    	mov.w	r1, #0x368
700a5c10: f7f3 ef10    	blx	0x70099a34 <__aeabi_memclr8> @ imm = #-0xc1e0
700a5c14: 9802         	ldr	r0, [sp, #0x8]
;         gUartConfig[cnt].attrs->baseAddr = (uint32_t) AddrTranslateP_getLocalAddr((uint64_t)gUartConfig[cnt].attrs->baseAddr);
700a5c16: 9904         	ldr	r1, [sp, #0x10]
700a5c18: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700a5c1c: 6800         	ldr	r0, [r0]
700a5c1e: 2100         	movs	r1, #0x0
700a5c20: f7fe f8d6    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x1e54
700a5c24: 9902         	ldr	r1, [sp, #0x8]
700a5c26: 9a04         	ldr	r2, [sp, #0x10]
700a5c28: f851 1032    	ldr.w	r1, [r1, r2, lsl #3]
700a5c2c: 6008         	str	r0, [r1]
;     }
700a5c2e: e7ff         	b	0x700a5c30 <UART_init+0x80> @ imm = #-0x2
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a5c30: 9804         	ldr	r0, [sp, #0x10]
700a5c32: 3001         	adds	r0, #0x1
700a5c34: 9004         	str	r0, [sp, #0x10]
700a5c36: e7c0         	b	0x700a5bba <UART_init+0xa> @ imm = #-0x80
;     status = SemaphoreP_constructMutex(&gUartDrvObj.lockObj);
700a5c38: f240 2030    	movw	r0, #0x230
700a5c3c: f2c7 000b    	movt	r0, #0x700b
700a5c40: 3004         	adds	r0, #0x4
700a5c42: f003 fc85    	bl	0x700a9550 <SemaphoreP_constructMutex> @ imm = #0x390a
700a5c46: 9005         	str	r0, [sp, #0x14]
;     if(SystemP_SUCCESS == status)
700a5c48: 9805         	ldr	r0, [sp, #0x14]
700a5c4a: b938         	cbnz	r0, 0x700a5c5c <UART_init+0xac> @ imm = #0xe
700a5c4c: e7ff         	b	0x700a5c4e <UART_init+0x9e> @ imm = #-0x2
;         gUartDrvObj.lock = &gUartDrvObj.lockObj;
700a5c4e: f240 2130    	movw	r1, #0x230
700a5c52: f2c7 010b    	movt	r1, #0x700b
700a5c56: 1d08         	adds	r0, r1, #0x4
700a5c58: 6008         	str	r0, [r1]
;     }
700a5c5a: e7ff         	b	0x700a5c5c <UART_init+0xac> @ imm = #-0x2
;     return;
700a5c5c: b006         	add	sp, #0x18
700a5c5e: bd80         	pop	{r7, pc}

700a5c60 <Udma_chCheckParams>:
; {
700a5c60: b084         	sub	sp, #0x10
700a5c62: 9003         	str	r0, [sp, #0xc]
700a5c64: 9102         	str	r1, [sp, #0x8]
700a5c66: 9201         	str	r2, [sp, #0x4]
700a5c68: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a5c6a: 9000         	str	r0, [sp]
;     if((chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
700a5c6c: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a5c70: 0700         	lsls	r0, r0, #0x1c
700a5c72: 2800         	cmp	r0, #0x0
700a5c74: d513         	bpl	0x700a5c9e <Udma_chCheckParams+0x3e> @ imm = #0x26
700a5c76: e7ff         	b	0x700a5c78 <Udma_chCheckParams+0x18> @ imm = #-0x2
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a5c78: 9801         	ldr	r0, [sp, #0x4]
700a5c7a: 6840         	ldr	r0, [r0, #0x4]
700a5c7c: f510 3f80    	cmn.w	r0, #0x10000
700a5c80: d008         	beq	0x700a5c94 <Udma_chCheckParams+0x34> @ imm = #0x10
700a5c82: e7ff         	b	0x700a5c84 <Udma_chCheckParams+0x24> @ imm = #-0x2
;            (UDMA_DMA_CH_NA == chPrms->peerChNum))
700a5c84: 9801         	ldr	r0, [sp, #0x4]
700a5c86: 6840         	ldr	r0, [r0, #0x4]
700a5c88: 2102         	movs	r1, #0x2
700a5c8a: f6cf 71ff    	movt	r1, #0xffff
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a5c8e: 4288         	cmp	r0, r1
700a5c90: d104         	bne	0x700a5c9c <Udma_chCheckParams+0x3c> @ imm = #0x8
700a5c92: e7ff         	b	0x700a5c94 <Udma_chCheckParams+0x34> @ imm = #-0x2
700a5c94: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5c98: 9000         	str	r0, [sp]
;         }
700a5c9a: e7ff         	b	0x700a5c9c <Udma_chCheckParams+0x3c> @ imm = #-0x2
;     }
700a5c9c: e7ff         	b	0x700a5c9e <Udma_chCheckParams+0x3e> @ imm = #-0x2
;     if((chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
700a5c9e: f89d 0009    	ldrb.w	r0, [sp, #0x9]
700a5ca2: 07c0         	lsls	r0, r0, #0x1f
700a5ca4: b388         	cbz	r0, 0x700a5d0a <Udma_chCheckParams+0xaa> @ imm = #0x62
700a5ca6: e7ff         	b	0x700a5ca8 <Udma_chCheckParams+0x48> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == chPrms->mappedChGrp)
700a5ca8: 9801         	ldr	r0, [sp, #0x4]
700a5caa: 6880         	ldr	r0, [r0, #0x8]
700a5cac: 2104         	movs	r1, #0x4
700a5cae: f6cf 71ff    	movt	r1, #0xffff
700a5cb2: 4288         	cmp	r0, r1
700a5cb4: d104         	bne	0x700a5cc0 <Udma_chCheckParams+0x60> @ imm = #0x8
700a5cb6: e7ff         	b	0x700a5cb8 <Udma_chCheckParams+0x58> @ imm = #-0x2
700a5cb8: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5cbc: 9000         	str	r0, [sp]
;         }
700a5cbe: e7ff         	b	0x700a5cc0 <Udma_chCheckParams+0x60> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a5cc0: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a5cc4: 07c0         	lsls	r0, r0, #0x1f
700a5cc6: b150         	cbz	r0, 0x700a5cde <Udma_chCheckParams+0x7e> @ imm = #0x14
700a5cc8: e7ff         	b	0x700a5cca <Udma_chCheckParams+0x6a> @ imm = #-0x2
;             if(chPrms->mappedChGrp >= UDMA_NUM_MAPPED_TX_GROUP)
700a5cca: 9801         	ldr	r0, [sp, #0x4]
700a5ccc: 6880         	ldr	r0, [r0, #0x8]
700a5cce: 2804         	cmp	r0, #0x4
700a5cd0: d304         	blo	0x700a5cdc <Udma_chCheckParams+0x7c> @ imm = #0x8
700a5cd2: e7ff         	b	0x700a5cd4 <Udma_chCheckParams+0x74> @ imm = #-0x2
700a5cd4: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a5cd8: 9000         	str	r0, [sp]
;             }
700a5cda: e7ff         	b	0x700a5cdc <Udma_chCheckParams+0x7c> @ imm = #-0x2
;         }
700a5cdc: e7ff         	b	0x700a5cde <Udma_chCheckParams+0x7e> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a5cde: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a5ce2: 0780         	lsls	r0, r0, #0x1e
700a5ce4: 2800         	cmp	r0, #0x0
700a5ce6: d50f         	bpl	0x700a5d08 <Udma_chCheckParams+0xa8> @ imm = #0x1e
700a5ce8: e7ff         	b	0x700a5cea <Udma_chCheckParams+0x8a> @ imm = #-0x2
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a5cea: 9801         	ldr	r0, [sp, #0x4]
700a5cec: 6880         	ldr	r0, [r0, #0x8]
700a5cee: 2804         	cmp	r0, #0x4
700a5cf0: d305         	blo	0x700a5cfe <Udma_chCheckParams+0x9e> @ imm = #0xa
700a5cf2: e7ff         	b	0x700a5cf4 <Udma_chCheckParams+0x94> @ imm = #-0x2
;                (chPrms->mappedChGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a5cf4: 9801         	ldr	r0, [sp, #0x4]
700a5cf6: 6880         	ldr	r0, [r0, #0x8]
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a5cf8: 2808         	cmp	r0, #0x8
700a5cfa: d304         	blo	0x700a5d06 <Udma_chCheckParams+0xa6> @ imm = #0x8
700a5cfc: e7ff         	b	0x700a5cfe <Udma_chCheckParams+0x9e> @ imm = #-0x2
700a5cfe: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a5d02: 9000         	str	r0, [sp]
;             }
700a5d04: e7ff         	b	0x700a5d06 <Udma_chCheckParams+0xa6> @ imm = #-0x2
;         }
700a5d06: e7ff         	b	0x700a5d08 <Udma_chCheckParams+0xa8> @ imm = #-0x2
;     }
700a5d08: e7ff         	b	0x700a5d0a <Udma_chCheckParams+0xaa> @ imm = #-0x2
;     return (retVal);
700a5d0a: 9800         	ldr	r0, [sp]
700a5d0c: b004         	add	sp, #0x10
700a5d0e: 4770         	bx	lr

700a5d10 <Udma_getMappedChRingAttributes>:
; {
700a5d10: b087         	sub	sp, #0x1c
700a5d12: 9006         	str	r0, [sp, #0x18]
700a5d14: 9105         	str	r1, [sp, #0x14]
700a5d16: 9204         	str	r2, [sp, #0x10]
700a5d18: 9303         	str	r3, [sp, #0xc]
700a5d1a: 2000         	movs	r0, #0x0
;     uint32_t index = 0U;
700a5d1c: 9001         	str	r0, [sp, #0x4]
;     int32_t retVal = UDMA_SOK;
700a5d1e: 9000         	str	r0, [sp]
;     if(mappedGrp < UDMA_NUM_MAPPED_TX_GROUP) /* Mapped TX Channel */
700a5d20: 9805         	ldr	r0, [sp, #0x14]
700a5d22: 2803         	cmp	r0, #0x3
700a5d24: d81e         	bhi	0x700a5d64 <Udma_getMappedChRingAttributes+0x54> @ imm = #0x3c
700a5d26: e7ff         	b	0x700a5d28 <Udma_getMappedChRingAttributes+0x18> @ imm = #-0x2
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a5d28: 9804         	ldr	r0, [sp, #0x10]
700a5d2a: 2810         	cmp	r0, #0x10
700a5d2c: d304         	blo	0x700a5d38 <Udma_getMappedChRingAttributes+0x28> @ imm = #0x8
700a5d2e: e7ff         	b	0x700a5d30 <Udma_getMappedChRingAttributes+0x20> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_TX_CHANS))
700a5d30: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a5d32: 282a         	cmp	r0, #0x2a
700a5d34: d304         	blo	0x700a5d40 <Udma_getMappedChRingAttributes+0x30> @ imm = #0x8
700a5d36: e7ff         	b	0x700a5d38 <Udma_getMappedChRingAttributes+0x28> @ imm = #-0x2
700a5d38: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5d3c: 9000         	str	r0, [sp]
;         }
700a5d3e: e7ff         	b	0x700a5d40 <Udma_getMappedChRingAttributes+0x30> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a5d40: 9800         	ldr	r0, [sp]
700a5d42: b970         	cbnz	r0, 0x700a5d62 <Udma_getMappedChRingAttributes+0x52> @ imm = #0x1c
700a5d44: e7ff         	b	0x700a5d46 <Udma_getMappedChRingAttributes+0x36> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START;
700a5d46: 9804         	ldr	r0, [sp, #0x10]
700a5d48: 3810         	subs	r0, #0x10
700a5d4a: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaTxMappedChRingAttributes[index];
700a5d4c: 9801         	ldr	r0, [sp, #0x4]
700a5d4e: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a5d52: f24f 10d0    	movw	r0, #0xf1d0
700a5d56: f2c7 000a    	movt	r0, #0x700a
700a5d5a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5d5e: 9002         	str	r0, [sp, #0x8]
;         }
700a5d60: e7ff         	b	0x700a5d62 <Udma_getMappedChRingAttributes+0x52> @ imm = #-0x2
;     }
700a5d62: e01d         	b	0x700a5da0 <Udma_getMappedChRingAttributes+0x90> @ imm = #0x3a
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a5d64: 9804         	ldr	r0, [sp, #0x10]
700a5d66: 2810         	cmp	r0, #0x10
700a5d68: d304         	blo	0x700a5d74 <Udma_getMappedChRingAttributes+0x64> @ imm = #0x8
700a5d6a: e7ff         	b	0x700a5d6c <Udma_getMappedChRingAttributes+0x5c> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_RX_CHANS))
700a5d6c: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a5d6e: 281d         	cmp	r0, #0x1d
700a5d70: d304         	blo	0x700a5d7c <Udma_getMappedChRingAttributes+0x6c> @ imm = #0x8
700a5d72: e7ff         	b	0x700a5d74 <Udma_getMappedChRingAttributes+0x64> @ imm = #-0x2
700a5d74: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5d78: 9000         	str	r0, [sp]
;         }
700a5d7a: e7ff         	b	0x700a5d7c <Udma_getMappedChRingAttributes+0x6c> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a5d7c: 9800         	ldr	r0, [sp]
700a5d7e: b970         	cbnz	r0, 0x700a5d9e <Udma_getMappedChRingAttributes+0x8e> @ imm = #0x1c
700a5d80: e7ff         	b	0x700a5d82 <Udma_getMappedChRingAttributes+0x72> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START;
700a5d82: 9804         	ldr	r0, [sp, #0x10]
700a5d84: 3810         	subs	r0, #0x10
700a5d86: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaRxMappedChRingAttributes[index];
700a5d88: 9801         	ldr	r0, [sp, #0x4]
700a5d8a: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a5d8e: f24f 3008    	movw	r0, #0xf308
700a5d92: f2c7 000a    	movt	r0, #0x700a
700a5d96: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5d9a: 9002         	str	r0, [sp, #0x8]
;         }
700a5d9c: e7ff         	b	0x700a5d9e <Udma_getMappedChRingAttributes+0x8e> @ imm = #-0x2
700a5d9e: e7ff         	b	0x700a5da0 <Udma_getMappedChRingAttributes+0x90> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a5da0: 9800         	ldr	r0, [sp]
700a5da2: b948         	cbnz	r0, 0x700a5db8 <Udma_getMappedChRingAttributes+0xa8> @ imm = #0x12
700a5da4: e7ff         	b	0x700a5da6 <Udma_getMappedChRingAttributes+0x96> @ imm = #-0x2
;         (void) memcpy(chAttr, mappedChRingAttributes, sizeof (Udma_MappedChRingAttributes));
700a5da6: 9903         	ldr	r1, [sp, #0xc]
700a5da8: 9b02         	ldr	r3, [sp, #0x8]
700a5daa: 6818         	ldr	r0, [r3]
700a5dac: 685a         	ldr	r2, [r3, #0x4]
700a5dae: 689b         	ldr	r3, [r3, #0x8]
700a5db0: 608b         	str	r3, [r1, #0x8]
700a5db2: 604a         	str	r2, [r1, #0x4]
700a5db4: 6008         	str	r0, [r1]
;     }
700a5db6: e7ff         	b	0x700a5db8 <Udma_getMappedChRingAttributes+0xa8> @ imm = #-0x2
;     return(retVal);
700a5db8: 9800         	ldr	r0, [sp]
700a5dba: b007         	add	sp, #0x1c
700a5dbc: 4770         	bx	lr
700a5dbe: 0000         	movs	r0, r0

700a5dc0 <prvUnlockQueue>:
; {
700a5dc0: b580         	push	{r7, lr}
700a5dc2: b082         	sub	sp, #0x8
700a5dc4: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700a5dc6: f006 fbe3    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x67c6
;         int8_t cTxLock = pxQueue->cTxLock;
700a5dca: 9801         	ldr	r0, [sp, #0x4]
700a5dcc: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a5dd0: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a5dd4: e7ff         	b	0x700a5dd6 <prvUnlockQueue+0x16> @ imm = #-0x2
700a5dd6: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a5dda: 2801         	cmp	r0, #0x1
700a5ddc: db16         	blt	0x700a5e0c <prvUnlockQueue+0x4c> @ imm = #0x2c
700a5dde: e7ff         	b	0x700a5de0 <prvUnlockQueue+0x20> @ imm = #-0x2
;                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a5de0: 9801         	ldr	r0, [sp, #0x4]
700a5de2: 6a40         	ldr	r0, [r0, #0x24]
700a5de4: b158         	cbz	r0, 0x700a5dfe <prvUnlockQueue+0x3e> @ imm = #0x16
700a5de6: e7ff         	b	0x700a5de8 <prvUnlockQueue+0x28> @ imm = #-0x2
;                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a5de8: 9801         	ldr	r0, [sp, #0x4]
700a5dea: 3024         	adds	r0, #0x24
700a5dec: f000 fa50    	bl	0x700a6290 <xTaskRemoveFromEventList> @ imm = #0x4a0
700a5df0: b118         	cbz	r0, 0x700a5dfa <prvUnlockQueue+0x3a> @ imm = #0x6
700a5df2: e7ff         	b	0x700a5df4 <prvUnlockQueue+0x34> @ imm = #-0x2
;                             vTaskMissedYield();
700a5df4: f007 fda4    	bl	0x700ad940 <vTaskMissedYield> @ imm = #0x7b48
;                         }
700a5df8: e000         	b	0x700a5dfc <prvUnlockQueue+0x3c> @ imm = #0x0
700a5dfa: e7ff         	b	0x700a5dfc <prvUnlockQueue+0x3c> @ imm = #-0x2
;                     }
700a5dfc: e000         	b	0x700a5e00 <prvUnlockQueue+0x40> @ imm = #0x0
;                         break;
700a5dfe: e005         	b	0x700a5e0c <prvUnlockQueue+0x4c> @ imm = #0xa
;             --cTxLock;
700a5e00: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a5e04: 3801         	subs	r0, #0x1
700a5e06: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a5e0a: e7e4         	b	0x700a5dd6 <prvUnlockQueue+0x16> @ imm = #-0x38
;         pxQueue->cTxLock = queueUNLOCKED;
700a5e0c: 9901         	ldr	r1, [sp, #0x4]
700a5e0e: 20ff         	movs	r0, #0xff
700a5e10: f881 0045    	strb.w	r0, [r1, #0x45]
;     taskEXIT_CRITICAL();
700a5e14: f005 fc7c    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x58f8
;     taskENTER_CRITICAL();
700a5e18: f006 fbba    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x6774
;         int8_t cRxLock = pxQueue->cRxLock;
700a5e1c: 9801         	ldr	r0, [sp, #0x4]
700a5e1e: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a5e22: f88d 0002    	strb.w	r0, [sp, #0x2]
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a5e26: e7ff         	b	0x700a5e28 <prvUnlockQueue+0x68> @ imm = #-0x2
700a5e28: f99d 0002    	ldrsb.w	r0, [sp, #0x2]
700a5e2c: 2801         	cmp	r0, #0x1
700a5e2e: db16         	blt	0x700a5e5e <prvUnlockQueue+0x9e> @ imm = #0x2c
700a5e30: e7ff         	b	0x700a5e32 <prvUnlockQueue+0x72> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a5e32: 9801         	ldr	r0, [sp, #0x4]
700a5e34: 6900         	ldr	r0, [r0, #0x10]
700a5e36: b180         	cbz	r0, 0x700a5e5a <prvUnlockQueue+0x9a> @ imm = #0x20
700a5e38: e7ff         	b	0x700a5e3a <prvUnlockQueue+0x7a> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a5e3a: 9801         	ldr	r0, [sp, #0x4]
700a5e3c: 3010         	adds	r0, #0x10
700a5e3e: f000 fa27    	bl	0x700a6290 <xTaskRemoveFromEventList> @ imm = #0x44e
700a5e42: b118         	cbz	r0, 0x700a5e4c <prvUnlockQueue+0x8c> @ imm = #0x6
700a5e44: e7ff         	b	0x700a5e46 <prvUnlockQueue+0x86> @ imm = #-0x2
;                     vTaskMissedYield();
700a5e46: f007 fd7b    	bl	0x700ad940 <vTaskMissedYield> @ imm = #0x7af6
;                 }
700a5e4a: e000         	b	0x700a5e4e <prvUnlockQueue+0x8e> @ imm = #0x0
700a5e4c: e7ff         	b	0x700a5e4e <prvUnlockQueue+0x8e> @ imm = #-0x2
;                 --cRxLock;
700a5e4e: f89d 0002    	ldrb.w	r0, [sp, #0x2]
700a5e52: 3801         	subs	r0, #0x1
700a5e54: f88d 0002    	strb.w	r0, [sp, #0x2]
;             }
700a5e58: e000         	b	0x700a5e5c <prvUnlockQueue+0x9c> @ imm = #0x0
;                 break;
700a5e5a: e000         	b	0x700a5e5e <prvUnlockQueue+0x9e> @ imm = #0x0
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a5e5c: e7e4         	b	0x700a5e28 <prvUnlockQueue+0x68> @ imm = #-0x38
;         pxQueue->cRxLock = queueUNLOCKED;
700a5e5e: 9901         	ldr	r1, [sp, #0x4]
700a5e60: 20ff         	movs	r0, #0xff
700a5e62: f881 0044    	strb.w	r0, [r1, #0x44]
;     taskEXIT_CRITICAL();
700a5e66: f005 fc53    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x58a6
; }
700a5e6a: b002         	add	sp, #0x8
700a5e6c: bd80         	pop	{r7, pc}
700a5e6e: 0000         	movs	r0, r0

700a5e70 <SemaphoreP_constructBinary>:
; {
700a5e70: b580         	push	{r7, lr}
700a5e72: b086         	sub	sp, #0x18
700a5e74: 9005         	str	r0, [sp, #0x14]
700a5e76: 9104         	str	r1, [sp, #0x10]
700a5e78: 2000         	movs	r0, #0x0
;     SemaphoreP_Struct *pSemaphore = NULL;
700a5e7a: 9003         	str	r0, [sp, #0xc]
700a5e7c: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700a5e80: 9002         	str	r0, [sp, #0x8]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700a5e82: f24f 6043    	movw	r0, #0xf643
700a5e86: f2c7 000a    	movt	r0, #0x700a
700a5e8a: 4669         	mov	r1, sp
700a5e8c: 6008         	str	r0, [r1]
700a5e8e: f64f 018e    	movw	r1, #0xf88e
700a5e92: f2c7 010a    	movt	r1, #0x700a
700a5e96: f64f 12fc    	movw	r2, #0xf9fc
700a5e9a: f2c7 020a    	movt	r2, #0x700a
700a5e9e: 2001         	movs	r0, #0x1
700a5ea0: 2332         	movs	r3, #0x32
700a5ea2: f002 febd    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x2d7a
;     if(obj != NULL)
700a5ea6: 9805         	ldr	r0, [sp, #0x14]
700a5ea8: b128         	cbz	r0, 0x700a5eb6 <SemaphoreP_constructBinary+0x46> @ imm = #0xa
700a5eaa: e7ff         	b	0x700a5eac <SemaphoreP_constructBinary+0x3c> @ imm = #-0x2
;         pSemaphore = (SemaphoreP_Struct *)obj;
700a5eac: 9805         	ldr	r0, [sp, #0x14]
700a5eae: 9003         	str	r0, [sp, #0xc]
700a5eb0: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a5eb2: 9002         	str	r0, [sp, #0x8]
;     }
700a5eb4: e7ff         	b	0x700a5eb6 <SemaphoreP_constructBinary+0x46> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a5eb6: 9802         	ldr	r0, [sp, #0x8]
700a5eb8: bb68         	cbnz	r0, 0x700a5f16 <SemaphoreP_constructBinary+0xa6> @ imm = #0x5a
700a5eba: e7ff         	b	0x700a5ebc <SemaphoreP_constructBinary+0x4c> @ imm = #-0x2
;         pSemaphore->isRecursiveMutex = 0;
700a5ebc: 9803         	ldr	r0, [sp, #0xc]
700a5ebe: 2200         	movs	r2, #0x0
700a5ec0: 6542         	str	r2, [r0, #0x54]
;         pSemaphore->semHndl = xSemaphoreCreateBinaryStatic(&pSemaphore->semObj);
700a5ec2: 9b03         	ldr	r3, [sp, #0xc]
700a5ec4: 4669         	mov	r1, sp
700a5ec6: 2003         	movs	r0, #0x3
700a5ec8: 6008         	str	r0, [r1]
700a5eca: 2001         	movs	r0, #0x1
700a5ecc: 4611         	mov	r1, r2
700a5ece: f005 fab7    	bl	0x700ab440 <xQueueGenericCreateStatic> @ imm = #0x556e
700a5ed2: 9903         	ldr	r1, [sp, #0xc]
700a5ed4: 6508         	str	r0, [r1, #0x50]
;         if( pSemaphore->semHndl == NULL )
700a5ed6: 9803         	ldr	r0, [sp, #0xc]
700a5ed8: 6d00         	ldr	r0, [r0, #0x50]
700a5eda: b920         	cbnz	r0, 0x700a5ee6 <SemaphoreP_constructBinary+0x76> @ imm = #0x8
700a5edc: e7ff         	b	0x700a5ede <SemaphoreP_constructBinary+0x6e> @ imm = #-0x2
700a5ede: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
700a5ee2: 9002         	str	r0, [sp, #0x8]
;         }
700a5ee4: e016         	b	0x700a5f14 <SemaphoreP_constructBinary+0xa4> @ imm = #0x2c
;             vQueueAddToRegistry(pSemaphore->semHndl, "Binary Sem (DPL)");
700a5ee6: 9803         	ldr	r0, [sp, #0xc]
700a5ee8: 6d00         	ldr	r0, [r0, #0x50]
700a5eea: f64f 31fe    	movw	r1, #0xfbfe
700a5eee: f2c7 010a    	movt	r1, #0x700a
700a5ef2: f005 f815    	bl	0x700aaf20 <vQueueAddToRegistry> @ imm = #0x502a
;             if(initCount == 1U)
700a5ef6: 9804         	ldr	r0, [sp, #0x10]
700a5ef8: 2801         	cmp	r0, #0x1
700a5efa: d108         	bne	0x700a5f0e <SemaphoreP_constructBinary+0x9e> @ imm = #0x10
700a5efc: e7ff         	b	0x700a5efe <SemaphoreP_constructBinary+0x8e> @ imm = #-0x2
;                 (void)xSemaphoreGive(pSemaphore->semHndl);
700a5efe: 9803         	ldr	r0, [sp, #0xc]
700a5f00: 6d00         	ldr	r0, [r0, #0x50]
700a5f02: 2300         	movs	r3, #0x0
700a5f04: 4619         	mov	r1, r3
700a5f06: 461a         	mov	r2, r3
700a5f08: f7fb fb42    	bl	0x700a1590 <xQueueGenericSend> @ imm = #-0x497c
;             }
700a5f0c: e7ff         	b	0x700a5f0e <SemaphoreP_constructBinary+0x9e> @ imm = #-0x2
700a5f0e: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700a5f10: 9002         	str	r0, [sp, #0x8]
700a5f12: e7ff         	b	0x700a5f14 <SemaphoreP_constructBinary+0xa4> @ imm = #-0x2
;     }
700a5f14: e7ff         	b	0x700a5f16 <SemaphoreP_constructBinary+0xa6> @ imm = #-0x2
;     return status;
700a5f16: 9802         	ldr	r0, [sp, #0x8]
700a5f18: b006         	add	sp, #0x18
700a5f1a: bd80         	pop	{r7, pc}
700a5f1c: 0000         	movs	r0, r0
700a5f1e: 0000         	movs	r0, r0

700a5f20 <UdmaChRxPrms_init>:
; {
700a5f20: b083         	sub	sp, #0xc
700a5f22: 9002         	str	r0, [sp, #0x8]
700a5f24: 9101         	str	r1, [sp, #0x4]
;     if(NULL_PTR != rxPrms)
700a5f26: 9802         	ldr	r0, [sp, #0x8]
700a5f28: 2800         	cmp	r0, #0x0
700a5f2a: d04d         	beq	0x700a5fc8 <UdmaChRxPrms_init+0xa8> @ imm = #0x9a
700a5f2c: e7ff         	b	0x700a5f2e <UdmaChRxPrms_init+0xe> @ imm = #-0x2
;         rxPrms->pauseOnError        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a5f2e: 9902         	ldr	r1, [sp, #0x8]
700a5f30: 2000         	movs	r0, #0x0
700a5f32: 7008         	strb	r0, [r1]
;         rxPrms->addrType            = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a5f34: 9902         	ldr	r1, [sp, #0x8]
700a5f36: 7048         	strb	r0, [r1, #0x1]
;         rxPrms->chanType            = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a5f38: 9902         	ldr	r1, [sp, #0x8]
700a5f3a: 2002         	movs	r0, #0x2
700a5f3c: 7088         	strb	r0, [r1, #0x2]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a5f3e: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a5f42: 0740         	lsls	r0, r0, #0x1d
700a5f44: 2800         	cmp	r0, #0x0
700a5f46: d504         	bpl	0x700a5f52 <UdmaChRxPrms_init+0x32> @ imm = #0x8
700a5f48: e7ff         	b	0x700a5f4a <UdmaChRxPrms_init+0x2a> @ imm = #-0x2
;             rxPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a5f4a: 9902         	ldr	r1, [sp, #0x8]
700a5f4c: 200c         	movs	r0, #0xc
700a5f4e: 7088         	strb	r0, [r1, #0x2]
;         }
700a5f50: e7ff         	b	0x700a5f52 <UdmaChRxPrms_init+0x32> @ imm = #-0x2
;         rxPrms->fetchWordSize       = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a5f52: 9902         	ldr	r1, [sp, #0x8]
700a5f54: 2010         	movs	r0, #0x10
700a5f56: 8088         	strh	r0, [r1, #0x4]
;         rxPrms->busPriority         = UDMA_DEFAULT_RX_CH_BUS_PRIORITY;
700a5f58: 9902         	ldr	r1, [sp, #0x8]
700a5f5a: 2004         	movs	r0, #0x4
700a5f5c: 7188         	strb	r0, [r1, #0x6]
;         rxPrms->busQos              = UDMA_DEFAULT_RX_CH_BUS_QOS;
700a5f5e: 9902         	ldr	r1, [sp, #0x8]
700a5f60: 71c8         	strb	r0, [r1, #0x7]
;         rxPrms->busOrderId          = UDMA_DEFAULT_RX_CH_BUS_ORDERID;
700a5f62: 9802         	ldr	r0, [sp, #0x8]
700a5f64: 2100         	movs	r1, #0x0
700a5f66: 9100         	str	r1, [sp]
700a5f68: 7201         	strb	r1, [r0, #0x8]
;         rxPrms->dmaPriority         = UDMA_DEFAULT_RX_CH_DMA_PRIORITY;
700a5f6a: 9a02         	ldr	r2, [sp, #0x8]
700a5f6c: 2001         	movs	r0, #0x1
700a5f6e: 7250         	strb	r0, [r2, #0x9]
;         rxPrms->flowIdFwRangeStart  = 0U;       /* Reset value - to use default flow */
700a5f70: 9a02         	ldr	r2, [sp, #0x8]
700a5f72: 8151         	strh	r1, [r2, #0xa]
;         rxPrms->flowIdFwRangeCnt    = 0U;       /* Reset value - to use default flow */
700a5f74: 9a02         	ldr	r2, [sp, #0x8]
700a5f76: 8191         	strh	r1, [r2, #0xc]
;         rxPrms->flowEInfoPresent    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;       /* Default no EINFO */
700a5f78: 9a02         	ldr	r2, [sp, #0x8]
700a5f7a: 7391         	strb	r1, [r2, #0xe]
;         rxPrms->flowPsInfoPresent   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;      /* Default no PSINFO */
700a5f7c: 9a02         	ldr	r2, [sp, #0x8]
700a5f7e: 73d1         	strb	r1, [r2, #0xf]
;         rxPrms->flowErrorHandling   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;       /* Default Re-try descriptor allocation operation on starvation error */
700a5f80: 9a02         	ldr	r2, [sp, #0x8]
700a5f82: 7410         	strb	r0, [r2, #0x10]
;         rxPrms->flowSopOffset       = 0U;      /* Default SOP offset is 0 */
700a5f84: 9a02         	ldr	r2, [sp, #0x8]
700a5f86: 7451         	strb	r1, [r2, #0x11]
;         rxPrms->ignoreShortPkts     = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a5f88: 9a02         	ldr	r2, [sp, #0x8]
700a5f8a: 7491         	strb	r1, [r2, #0x12]
;         rxPrms->ignoreLongPkts      = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a5f8c: 9a02         	ldr	r2, [sp, #0x8]
700a5f8e: 74d1         	strb	r1, [r2, #0x13]
;         rxPrms->configDefaultFlow   = TRUE;
700a5f90: 9902         	ldr	r1, [sp, #0x8]
700a5f92: 6148         	str	r0, [r1, #0x14]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a5f94: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a5f98: 0600         	lsls	r0, r0, #0x18
700a5f9a: 2800         	cmp	r0, #0x0
700a5f9c: d504         	bpl	0x700a5fa8 <UdmaChRxPrms_init+0x88> @ imm = #0x8
700a5f9e: e7ff         	b	0x700a5fa0 <UdmaChRxPrms_init+0x80> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a5fa0: 9902         	ldr	r1, [sp, #0x8]
700a5fa2: 2003         	movs	r0, #0x3
700a5fa4: 7608         	strb	r0, [r1, #0x18]
;         }
700a5fa6: e00e         	b	0x700a5fc6 <UdmaChRxPrms_init+0xa6> @ imm = #0x1c
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a5fa8: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a5fac: 0640         	lsls	r0, r0, #0x19
700a5fae: 2800         	cmp	r0, #0x0
700a5fb0: d504         	bpl	0x700a5fbc <UdmaChRxPrms_init+0x9c> @ imm = #0x8
700a5fb2: e7ff         	b	0x700a5fb4 <UdmaChRxPrms_init+0x94> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a5fb4: 9902         	ldr	r1, [sp, #0x8]
700a5fb6: 2003         	movs	r0, #0x3
700a5fb8: 7608         	strb	r0, [r1, #0x18]
;         }
700a5fba: e003         	b	0x700a5fc4 <UdmaChRxPrms_init+0xa4> @ imm = #0x6
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a5fbc: 9902         	ldr	r1, [sp, #0x8]
700a5fbe: 2001         	movs	r0, #0x1
700a5fc0: 7608         	strb	r0, [r1, #0x18]
700a5fc2: e7ff         	b	0x700a5fc4 <UdmaChRxPrms_init+0xa4> @ imm = #-0x2
700a5fc4: e7ff         	b	0x700a5fc6 <UdmaChRxPrms_init+0xa6> @ imm = #-0x2
;     }
700a5fc6: e7ff         	b	0x700a5fc8 <UdmaChRxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a5fc8: b003         	add	sp, #0xc
700a5fca: 4770         	bx	lr
700a5fcc: 0000         	movs	r0, r0
700a5fce: 0000         	movs	r0, r0

700a5fd0 <UdmaChTxPrms_init>:
; {
700a5fd0: b082         	sub	sp, #0x8
700a5fd2: 9001         	str	r0, [sp, #0x4]
700a5fd4: 9100         	str	r1, [sp]
;     if(NULL_PTR != txPrms)
700a5fd6: 9801         	ldr	r0, [sp, #0x4]
700a5fd8: 2800         	cmp	r0, #0x0
700a5fda: d04d         	beq	0x700a6078 <UdmaChTxPrms_init+0xa8> @ imm = #0x9a
700a5fdc: e7ff         	b	0x700a5fde <UdmaChTxPrms_init+0xe> @ imm = #-0x2
;         txPrms->pauseOnError    = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a5fde: 9901         	ldr	r1, [sp, #0x4]
700a5fe0: 2000         	movs	r0, #0x0
700a5fe2: 7008         	strb	r0, [r1]
;         txPrms->filterEinfo     = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_EINFO_DISABLED;
700a5fe4: 9901         	ldr	r1, [sp, #0x4]
700a5fe6: 7048         	strb	r0, [r1, #0x1]
;         txPrms->filterPsWords   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_PSWORDS_DISABLED;
700a5fe8: 9901         	ldr	r1, [sp, #0x4]
700a5fea: 7088         	strb	r0, [r1, #0x2]
;         txPrms->addrType        = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a5fec: 9901         	ldr	r1, [sp, #0x4]
700a5fee: 70c8         	strb	r0, [r1, #0x3]
;         txPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a5ff0: 9901         	ldr	r1, [sp, #0x4]
700a5ff2: 2002         	movs	r0, #0x2
700a5ff4: 7108         	strb	r0, [r1, #0x4]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a5ff6: f89d 0000    	ldrb.w	r0, [sp]
700a5ffa: 0740         	lsls	r0, r0, #0x1d
700a5ffc: 2800         	cmp	r0, #0x0
700a5ffe: d504         	bpl	0x700a600a <UdmaChTxPrms_init+0x3a> @ imm = #0x8
700a6000: e7ff         	b	0x700a6002 <UdmaChTxPrms_init+0x32> @ imm = #-0x2
;             txPrms->chanType    = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a6002: 9901         	ldr	r1, [sp, #0x4]
700a6004: 200c         	movs	r0, #0xc
700a6006: 7108         	strb	r0, [r1, #0x4]
;         }
700a6008: e7ff         	b	0x700a600a <UdmaChTxPrms_init+0x3a> @ imm = #-0x2
;         txPrms->fetchWordSize   = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a600a: 9901         	ldr	r1, [sp, #0x4]
700a600c: 2010         	movs	r0, #0x10
700a600e: 80c8         	strh	r0, [r1, #0x6]
;         txPrms->busPriority     = UDMA_DEFAULT_TX_CH_BUS_PRIORITY;
700a6010: 9901         	ldr	r1, [sp, #0x4]
700a6012: 2004         	movs	r0, #0x4
700a6014: 7208         	strb	r0, [r1, #0x8]
;         txPrms->busQos          = UDMA_DEFAULT_TX_CH_BUS_QOS;
700a6016: 9901         	ldr	r1, [sp, #0x4]
700a6018: 7248         	strb	r0, [r1, #0x9]
;         txPrms->busOrderId      = UDMA_DEFAULT_TX_CH_BUS_ORDERID;
700a601a: 9901         	ldr	r1, [sp, #0x4]
700a601c: 2000         	movs	r0, #0x0
700a601e: 7288         	strb	r0, [r1, #0xa]
;         txPrms->dmaPriority     = UDMA_DEFAULT_TX_CH_DMA_PRIORITY;
700a6020: 9a01         	ldr	r2, [sp, #0x4]
700a6022: 2101         	movs	r1, #0x1
700a6024: 72d1         	strb	r1, [r2, #0xb]
;         txPrms->txCredit        = 0U;
700a6026: 9901         	ldr	r1, [sp, #0x4]
700a6028: 7308         	strb	r0, [r1, #0xc]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a602a: f89d 0000    	ldrb.w	r0, [sp]
700a602e: ea4f 6000    	lsl.w	r0, r0, #0x18
700a6032: 2800         	cmp	r0, #0x0
700a6034: d507         	bpl	0x700a6046 <UdmaChTxPrms_init+0x76> @ imm = #0xe
700a6036: e7ff         	b	0x700a6038 <UdmaChTxPrms_init+0x68> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_UHC_CHANS_FDEPTH;
700a6038: 9901         	ldr	r1, [sp, #0x4]
700a603a: 2000         	movs	r0, #0x0
700a603c: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a603e: 9901         	ldr	r1, [sp, #0x4]
700a6040: 2003         	movs	r0, #0x3
700a6042: 7408         	strb	r0, [r1, #0x10]
;         }
700a6044: e014         	b	0x700a6070 <UdmaChTxPrms_init+0xa0> @ imm = #0x28
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a6046: f89d 0000    	ldrb.w	r0, [sp]
700a604a: 0640         	lsls	r0, r0, #0x19
700a604c: 2800         	cmp	r0, #0x0
700a604e: d507         	bpl	0x700a6060 <UdmaChTxPrms_init+0x90> @ imm = #0xe
700a6050: e7ff         	b	0x700a6052 <UdmaChTxPrms_init+0x82> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_HC_CHANS_FDEPTH;
700a6052: 9901         	ldr	r1, [sp, #0x4]
700a6054: 2000         	movs	r0, #0x0
700a6056: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a6058: 9901         	ldr	r1, [sp, #0x4]
700a605a: 2003         	movs	r0, #0x3
700a605c: 7408         	strb	r0, [r1, #0x10]
;         }
700a605e: e006         	b	0x700a606e <UdmaChTxPrms_init+0x9e> @ imm = #0xc
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_CHANS_FDEPTH;
700a6060: 9901         	ldr	r1, [sp, #0x4]
700a6062: 20c0         	movs	r0, #0xc0
700a6064: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a6066: 9901         	ldr	r1, [sp, #0x4]
700a6068: 2001         	movs	r0, #0x1
700a606a: 7408         	strb	r0, [r1, #0x10]
700a606c: e7ff         	b	0x700a606e <UdmaChTxPrms_init+0x9e> @ imm = #-0x2
700a606e: e7ff         	b	0x700a6070 <UdmaChTxPrms_init+0xa0> @ imm = #-0x2
;         txPrms->supressTdCqPkt  = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_DISABLED;
700a6070: 9901         	ldr	r1, [sp, #0x4]
700a6072: 2000         	movs	r0, #0x0
700a6074: 7448         	strb	r0, [r1, #0x11]
;     }
700a6076: e7ff         	b	0x700a6078 <UdmaChTxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a6078: b002         	add	sp, #0x8
700a607a: 4770         	bx	lr
700a607c: 0000         	movs	r0, r0
700a607e: 0000         	movs	r0, r0

700a6080 <Udma_chDisable>:
; {
700a6080: b580         	push	{r7, lr}
700a6082: b086         	sub	sp, #0x18
700a6084: 9005         	str	r0, [sp, #0x14]
700a6086: 9104         	str	r1, [sp, #0x10]
700a6088: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a608a: 9003         	str	r0, [sp, #0xc]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a608c: 9805         	ldr	r0, [sp, #0x14]
700a608e: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a6090: 9801         	ldr	r0, [sp, #0x4]
700a6092: b150         	cbz	r0, 0x700a60aa <Udma_chDisable+0x2a> @ imm = #0x14
700a6094: e7ff         	b	0x700a6096 <Udma_chDisable+0x16> @ imm = #-0x2
700a6096: 9801         	ldr	r0, [sp, #0x4]
700a6098: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a609c: f64a 31cd    	movw	r1, #0xabcd
700a60a0: f6ca 31dc    	movt	r1, #0xabdc
700a60a4: 4288         	cmp	r0, r1
700a60a6: d004         	beq	0x700a60b2 <Udma_chDisable+0x32> @ imm = #0x8
700a60a8: e7ff         	b	0x700a60aa <Udma_chDisable+0x2a> @ imm = #-0x2
700a60aa: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a60ae: 9003         	str	r0, [sp, #0xc]
;     }
700a60b0: e7ff         	b	0x700a60b2 <Udma_chDisable+0x32> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a60b2: 9803         	ldr	r0, [sp, #0xc]
700a60b4: b9a8         	cbnz	r0, 0x700a60e2 <Udma_chDisable+0x62> @ imm = #0x2a
700a60b6: e7ff         	b	0x700a60b8 <Udma_chDisable+0x38> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a60b8: 9801         	ldr	r0, [sp, #0x4]
700a60ba: 6e80         	ldr	r0, [r0, #0x68]
700a60bc: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a60be: 9802         	ldr	r0, [sp, #0x8]
700a60c0: b150         	cbz	r0, 0x700a60d8 <Udma_chDisable+0x58> @ imm = #0x14
700a60c2: e7ff         	b	0x700a60c4 <Udma_chDisable+0x44> @ imm = #-0x2
700a60c4: 9802         	ldr	r0, [sp, #0x8]
700a60c6: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a60ca: f64a 31cd    	movw	r1, #0xabcd
700a60ce: f6ca 31dc    	movt	r1, #0xabdc
700a60d2: 4288         	cmp	r0, r1
700a60d4: d004         	beq	0x700a60e0 <Udma_chDisable+0x60> @ imm = #0x8
700a60d6: e7ff         	b	0x700a60d8 <Udma_chDisable+0x58> @ imm = #-0x2
700a60d8: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a60dc: 9003         	str	r0, [sp, #0xc]
;         }
700a60de: e7ff         	b	0x700a60e0 <Udma_chDisable+0x60> @ imm = #-0x2
;     }
700a60e0: e7ff         	b	0x700a60e2 <Udma_chDisable+0x62> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a60e2: 9803         	ldr	r0, [sp, #0xc]
700a60e4: b9f8         	cbnz	r0, 0x700a6126 <Udma_chDisable+0xa6> @ imm = #0x3e
700a60e6: e7ff         	b	0x700a60e8 <Udma_chDisable+0x68> @ imm = #-0x2
;         if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a60e8: 9801         	ldr	r0, [sp, #0x4]
700a60ea: 7800         	ldrb	r0, [r0]
700a60ec: 0740         	lsls	r0, r0, #0x1d
700a60ee: 2800         	cmp	r0, #0x0
700a60f0: d506         	bpl	0x700a6100 <Udma_chDisable+0x80> @ imm = #0xc
700a60f2: e7ff         	b	0x700a60f4 <Udma_chDisable+0x74> @ imm = #-0x2
;             retVal = Udma_chDisableBlkCpyChan(chHandleInt, timeout);
700a60f4: 9801         	ldr	r0, [sp, #0x4]
700a60f6: 9904         	ldr	r1, [sp, #0x10]
700a60f8: f7f7 fcfa    	bl	0x7009daf0 <Udma_chDisableBlkCpyChan> @ imm = #-0x860c
700a60fc: 9003         	str	r0, [sp, #0xc]
;         }
700a60fe: e011         	b	0x700a6124 <Udma_chDisable+0xa4> @ imm = #0x22
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a6100: 9801         	ldr	r0, [sp, #0x4]
700a6102: 7800         	ldrb	r0, [r0]
700a6104: 07c0         	lsls	r0, r0, #0x1f
700a6106: b130         	cbz	r0, 0x700a6116 <Udma_chDisable+0x96> @ imm = #0xc
700a6108: e7ff         	b	0x700a610a <Udma_chDisable+0x8a> @ imm = #-0x2
;                 retVal = Udma_chDisableTxChan(chHandleInt, timeout);
700a610a: 9801         	ldr	r0, [sp, #0x4]
700a610c: 9904         	ldr	r1, [sp, #0x10]
700a610e: f7f5 f84f    	bl	0x7009b1b0 <Udma_chDisableTxChan> @ imm = #-0xaf62
700a6112: 9003         	str	r0, [sp, #0xc]
;             }
700a6114: e005         	b	0x700a6122 <Udma_chDisable+0xa2> @ imm = #0xa
;                 retVal = Udma_chDisableRxChan(chHandleInt, timeout);
700a6116: 9801         	ldr	r0, [sp, #0x4]
700a6118: 9904         	ldr	r1, [sp, #0x10]
700a611a: f7f6 f819    	bl	0x7009c150 <Udma_chDisableRxChan> @ imm = #-0x9fce
700a611e: 9003         	str	r0, [sp, #0xc]
700a6120: e7ff         	b	0x700a6122 <Udma_chDisable+0xa2> @ imm = #-0x2
700a6122: e7ff         	b	0x700a6124 <Udma_chDisable+0xa4> @ imm = #-0x2
;     }
700a6124: e7ff         	b	0x700a6126 <Udma_chDisable+0xa6> @ imm = #-0x2
;     return (retVal);
700a6126: 9803         	ldr	r0, [sp, #0xc]
700a6128: b006         	add	sp, #0x18
700a612a: bd80         	pop	{r7, pc}
700a612c: 0000         	movs	r0, r0
700a612e: 0000         	movs	r0, r0

700a6130 <CSL_bcdmaChanOpSetChanPause>:
; {
700a6130: b580         	push	{r7, lr}
700a6132: b086         	sub	sp, #0x18
700a6134: 9005         	str	r0, [sp, #0x14]
700a6136: 9104         	str	r1, [sp, #0x10]
700a6138: 9203         	str	r2, [sp, #0xc]
700a613a: f88d 300b    	strb.w	r3, [sp, #0xb]
700a613e: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a6140: 9001         	str	r0, [sp, #0x4]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
700a6142: 9805         	ldr	r0, [sp, #0x14]
700a6144: 9904         	ldr	r1, [sp, #0x10]
700a6146: 9a03         	ldr	r2, [sp, #0xc]
700a6148: f002 fc2a    	bl	0x700a89a0 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x2854
700a614c: b920         	cbnz	r0, 0x700a6158 <CSL_bcdmaChanOpSetChanPause+0x28> @ imm = #0x8
700a614e: e7ff         	b	0x700a6150 <CSL_bcdmaChanOpSetChanPause+0x20> @ imm = #-0x2
700a6150: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a6154: 9001         	str	r0, [sp, #0x4]
;     }
700a6156: e03d         	b	0x700a61d4 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #0x7a
;         switch( chanType )
700a6158: 9804         	ldr	r0, [sp, #0x10]
700a615a: 9000         	str	r0, [sp]
700a615c: b140         	cbz	r0, 0x700a6170 <CSL_bcdmaChanOpSetChanPause+0x40> @ imm = #0x10
700a615e: e7ff         	b	0x700a6160 <CSL_bcdmaChanOpSetChanPause+0x30> @ imm = #-0x2
700a6160: 9800         	ldr	r0, [sp]
700a6162: 2801         	cmp	r0, #0x1
700a6164: d013         	beq	0x700a618e <CSL_bcdmaChanOpSetChanPause+0x5e> @ imm = #0x26
700a6166: e7ff         	b	0x700a6168 <CSL_bcdmaChanOpSetChanPause+0x38> @ imm = #-0x2
700a6168: 9800         	ldr	r0, [sp]
700a616a: 2802         	cmp	r0, #0x2
700a616c: d01e         	beq	0x700a61ac <CSL_bcdmaChanOpSetChanPause+0x7c> @ imm = #0x3c
700a616e: e02c         	b	0x700a61ca <CSL_bcdmaChanOpSetChanPause+0x9a> @ imm = #0x58
;                 CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a6170: 9805         	ldr	r0, [sp, #0x14]
700a6172: 6880         	ldr	r0, [r0, #0x8]
700a6174: 9903         	ldr	r1, [sp, #0xc]
700a6176: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a617a: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a617e: f001 0301    	and	r3, r1, #0x1
700a6182: f04f 5100    	mov.w	r1, #0x20000000
700a6186: 221d         	movs	r2, #0x1d
700a6188: f005 ffaa    	bl	0x700ac0e0 <CSL_REG32_FINS_RAW> @ imm = #0x5f54
;                 break;
700a618c: e021         	b	0x700a61d2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x42
;                 CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a618e: 9805         	ldr	r0, [sp, #0x14]
700a6190: 6900         	ldr	r0, [r0, #0x10]
700a6192: 9903         	ldr	r1, [sp, #0xc]
700a6194: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6198: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a619c: f001 0301    	and	r3, r1, #0x1
700a61a0: f04f 5100    	mov.w	r1, #0x20000000
700a61a4: 221d         	movs	r2, #0x1d
700a61a6: f005 ff9b    	bl	0x700ac0e0 <CSL_REG32_FINS_RAW> @ imm = #0x5f36
;                 break;
700a61aa: e012         	b	0x700a61d2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x24
;                 CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a61ac: 9805         	ldr	r0, [sp, #0x14]
700a61ae: 6980         	ldr	r0, [r0, #0x18]
700a61b0: 9903         	ldr	r1, [sp, #0xc]
700a61b2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a61b6: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a61ba: f001 0301    	and	r3, r1, #0x1
700a61be: f04f 5100    	mov.w	r1, #0x20000000
700a61c2: 221d         	movs	r2, #0x1d
700a61c4: f005 ff8c    	bl	0x700ac0e0 <CSL_REG32_FINS_RAW> @ imm = #0x5f18
;                 break;
700a61c8: e003         	b	0x700a61d2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x6
700a61ca: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a61ce: 9001         	str	r0, [sp, #0x4]
;                 break;
700a61d0: e7ff         	b	0x700a61d2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #-0x2
700a61d2: e7ff         	b	0x700a61d4 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #-0x2
;     return retVal;
700a61d4: 9801         	ldr	r0, [sp, #0x4]
700a61d6: b006         	add	sp, #0x18
700a61d8: bd80         	pop	{r7, pc}
700a61da: 0000         	movs	r0, r0
700a61dc: 0000         	movs	r0, r0
700a61de: 0000         	movs	r0, r0

700a61e0 <CSL_bcdmaChanOpSetChanRT>:
; {
700a61e0: b580         	push	{r7, lr}
700a61e2: b088         	sub	sp, #0x20
700a61e4: 9007         	str	r0, [sp, #0x1c]
700a61e6: 9106         	str	r1, [sp, #0x18]
700a61e8: 9205         	str	r2, [sp, #0x14]
700a61ea: 9304         	str	r3, [sp, #0x10]
700a61ec: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a61ee: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a61f0: 9804         	ldr	r0, [sp, #0x10]
700a61f2: b920         	cbnz	r0, 0x700a61fe <CSL_bcdmaChanOpSetChanRT+0x1e> @ imm = #0x8
700a61f4: e7ff         	b	0x700a61f6 <CSL_bcdmaChanOpSetChanRT+0x16> @ imm = #-0x2
700a61f6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a61fa: 9003         	str	r0, [sp, #0xc]
;     }
700a61fc: e042         	b	0x700a6284 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #0x84
;         CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a61fe: 9804         	ldr	r0, [sp, #0x10]
700a6200: 9001         	str	r0, [sp, #0x4]
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a6202: 9801         	ldr	r0, [sp, #0x4]
700a6204: 6803         	ldr	r3, [r0]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a6206: f8d0 c004    	ldr.w	r12, [r0, #0x4]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a620a: 6881         	ldr	r1, [r0, #0x8]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a620c: 6902         	ldr	r2, [r0, #0x10]
700a620e: f04f 4080    	mov.w	r0, #0x40000000
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a6212: ea00 708c    	and.w	r0, r0, r12, lsl #30
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a6216: ea40 70c3    	orr.w	r0, r0, r3, lsl #31
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a621a: f002 0201    	and	r2, r2, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a621e: ea40 7002    	orr.w	r0, r0, r2, lsl #28
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a6222: f001 0101    	and	r1, r1, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a6226: ea40 7041    	orr.w	r0, r0, r1, lsl #29
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a622a: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a622c: 9806         	ldr	r0, [sp, #0x18]
700a622e: 9000         	str	r0, [sp]
700a6230: b140         	cbz	r0, 0x700a6244 <CSL_bcdmaChanOpSetChanRT+0x64> @ imm = #0x10
700a6232: e7ff         	b	0x700a6234 <CSL_bcdmaChanOpSetChanRT+0x54> @ imm = #-0x2
700a6234: 9800         	ldr	r0, [sp]
700a6236: 2801         	cmp	r0, #0x1
700a6238: d00d         	beq	0x700a6256 <CSL_bcdmaChanOpSetChanRT+0x76> @ imm = #0x1a
700a623a: e7ff         	b	0x700a623c <CSL_bcdmaChanOpSetChanRT+0x5c> @ imm = #-0x2
700a623c: 9800         	ldr	r0, [sp]
700a623e: 2802         	cmp	r0, #0x2
700a6240: d012         	beq	0x700a6268 <CSL_bcdmaChanOpSetChanRT+0x88> @ imm = #0x24
700a6242: e01a         	b	0x700a627a <CSL_bcdmaChanOpSetChanRT+0x9a> @ imm = #0x34
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, val );
700a6244: 9807         	ldr	r0, [sp, #0x1c]
700a6246: 6880         	ldr	r0, [r0, #0x8]
700a6248: 9905         	ldr	r1, [sp, #0x14]
700a624a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a624e: 9902         	ldr	r1, [sp, #0x8]
700a6250: f007 fade    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x75bc
;                 break;
700a6254: e015         	b	0x700a6282 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x2a
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, val );
700a6256: 9807         	ldr	r0, [sp, #0x1c]
700a6258: 6900         	ldr	r0, [r0, #0x10]
700a625a: 9905         	ldr	r1, [sp, #0x14]
700a625c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6260: 9902         	ldr	r1, [sp, #0x8]
700a6262: f007 fad5    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x75aa
;                 break;
700a6266: e00c         	b	0x700a6282 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x18
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, val );
700a6268: 9807         	ldr	r0, [sp, #0x1c]
700a626a: 6980         	ldr	r0, [r0, #0x18]
700a626c: 9905         	ldr	r1, [sp, #0x14]
700a626e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6272: 9902         	ldr	r1, [sp, #0x8]
700a6274: f007 facc    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x7598
;                 break;
700a6278: e003         	b	0x700a6282 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x6
700a627a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a627e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a6280: e7ff         	b	0x700a6282 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #-0x2
700a6282: e7ff         	b	0x700a6284 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #-0x2
;     return retVal;
700a6284: 9803         	ldr	r0, [sp, #0xc]
700a6286: b008         	add	sp, #0x20
700a6288: bd80         	pop	{r7, pc}
700a628a: 0000         	movs	r0, r0
700a628c: 0000         	movs	r0, r0
700a628e: 0000         	movs	r0, r0

700a6290 <xTaskRemoveFromEventList>:
; BaseType_t xTaskRemoveFromEventList(const List_t *const pxEventList) {
700a6290: b580         	push	{r7, lr}
700a6292: b084         	sub	sp, #0x10
700a6294: 9003         	str	r0, [sp, #0xc]
;   pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a6296: 9803         	ldr	r0, [sp, #0xc]
700a6298: 68c0         	ldr	r0, [r0, #0xc]
700a629a: 68c0         	ldr	r0, [r0, #0xc]
700a629c: 9002         	str	r0, [sp, #0x8]
;   (void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
700a629e: 9802         	ldr	r0, [sp, #0x8]
700a62a0: 3018         	adds	r0, #0x18
700a62a2: f005 f945    	bl	0x700ab530 <uxListRemove> @ imm = #0x528a
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a62a6: f240 5000    	movw	r0, #0x500
700a62aa: f2c7 000b    	movt	r0, #0x700b
700a62ae: 6800         	ldr	r0, [r0]
700a62b0: bb00         	cbnz	r0, 0x700a62f4 <xTaskRemoveFromEventList+0x64> @ imm = #0x40
700a62b2: e7ff         	b	0x700a62b4 <xTaskRemoveFromEventList+0x24> @ imm = #-0x2
;     (void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
700a62b4: 9802         	ldr	r0, [sp, #0x8]
700a62b6: 3004         	adds	r0, #0x4
700a62b8: f005 f93a    	bl	0x700ab530 <uxListRemove> @ imm = #0x5274
;     prvAddTaskToReadyList(pxUnblockedTCB);
700a62bc: 9802         	ldr	r0, [sp, #0x8]
700a62be: 6ac1         	ldr	r1, [r0, #0x2c]
700a62c0: 2001         	movs	r0, #0x1
700a62c2: fa00 f201    	lsl.w	r2, r0, r1
700a62c6: f240 5108    	movw	r1, #0x508
700a62ca: f2c7 010b    	movt	r1, #0x700b
700a62ce: 6808         	ldr	r0, [r1]
700a62d0: 4310         	orrs	r0, r2
700a62d2: 6008         	str	r0, [r1]
700a62d4: 9902         	ldr	r1, [sp, #0x8]
700a62d6: 6ac8         	ldr	r0, [r1, #0x2c]
700a62d8: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a62dc: f244 40f8    	movw	r0, #0x44f8
700a62e0: f2c7 0008    	movt	r0, #0x7008
700a62e4: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a62e8: 3104         	adds	r1, #0x4
700a62ea: f005 fed9    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #0x5db2
;       prvResetNextTaskUnblockTime();
700a62ee: f005 fe77    	bl	0x700abfe0 <prvResetNextTaskUnblockTime> @ imm = #0x5cee
;   } else {
700a62f2: e009         	b	0x700a6308 <xTaskRemoveFromEventList+0x78> @ imm = #0x12
;     vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
700a62f4: 9802         	ldr	r0, [sp, #0x8]
700a62f6: f100 0118    	add.w	r1, r0, #0x18
700a62fa: f644 7068    	movw	r0, #0x4f68
700a62fe: f2c7 0008    	movt	r0, #0x7008
700a6302: f005 fecd    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #0x5d9a
700a6306: e7ff         	b	0x700a6308 <xTaskRemoveFromEventList+0x78> @ imm = #-0x2
;   if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
700a6308: 9802         	ldr	r0, [sp, #0x8]
700a630a: 6ac0         	ldr	r0, [r0, #0x2c]
700a630c: f240 41dc    	movw	r1, #0x4dc
700a6310: f2c7 010b    	movt	r1, #0x700b
700a6314: 6809         	ldr	r1, [r1]
700a6316: 6ac9         	ldr	r1, [r1, #0x2c]
700a6318: 4288         	cmp	r0, r1
700a631a: d908         	bls	0x700a632e <xTaskRemoveFromEventList+0x9e> @ imm = #0x10
700a631c: e7ff         	b	0x700a631e <xTaskRemoveFromEventList+0x8e> @ imm = #-0x2
700a631e: 2001         	movs	r0, #0x1
;     xReturn = pdTRUE;
700a6320: 9001         	str	r0, [sp, #0x4]
;     xYieldPending = pdTRUE;
700a6322: f240 512c    	movw	r1, #0x52c
700a6326: f2c7 010b    	movt	r1, #0x700b
700a632a: 6008         	str	r0, [r1]
;   } else {
700a632c: e002         	b	0x700a6334 <xTaskRemoveFromEventList+0xa4> @ imm = #0x4
700a632e: 2000         	movs	r0, #0x0
;     xReturn = pdFALSE;
700a6330: 9001         	str	r0, [sp, #0x4]
700a6332: e7ff         	b	0x700a6334 <xTaskRemoveFromEventList+0xa4> @ imm = #-0x2
;   return xReturn;
700a6334: 9801         	ldr	r0, [sp, #0x4]
700a6336: b004         	add	sp, #0x10
700a6338: bd80         	pop	{r7, pc}
700a633a: 0000         	movs	r0, r0
700a633c: 0000         	movs	r0, r0
700a633e: 0000         	movs	r0, r0

700a6340 <Sciclient_rmIrInpRomMapped>:
; {
700a6340: b082         	sub	sp, #0x8
700a6342: 9001         	str	r0, [sp, #0x4]
700a6344: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a6348: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a634a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a634e: 9801         	ldr	r0, [sp, #0x4]
700a6350: 6900         	ldr	r0, [r0, #0x10]
700a6352: 2800         	cmp	r0, #0x0
700a6354: d042         	beq	0x700a63dc <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #0x84
700a6356: e7ff         	b	0x700a6358 <Sciclient_rmIrInpRomMapped+0x18> @ imm = #-0x2
700a6358: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a635a: f88d 0000    	strb.w	r0, [sp]
700a635e: e7ff         	b	0x700a6360 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x2
700a6360: f89d 0000    	ldrb.w	r0, [sp]
700a6364: 9901         	ldr	r1, [sp, #0x4]
700a6366: 7d09         	ldrb	r1, [r1, #0x14]
700a6368: 4288         	cmp	r0, r1
700a636a: da36         	bge	0x700a63da <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0x6c
700a636c: e7ff         	b	0x700a636e <Sciclient_rmIrInpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a636e: 9801         	ldr	r0, [sp, #0x4]
700a6370: 6900         	ldr	r0, [r0, #0x10]
700a6372: f89d 1000    	ldrb.w	r1, [sp]
700a6376: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a637a: 7980         	ldrb	r0, [r0, #0x6]
700a637c: 07c0         	lsls	r0, r0, #0x1f
700a637e: bb28         	cbnz	r0, 0x700a63cc <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x4a
700a6380: e7ff         	b	0x700a6382 <Sciclient_rmIrInpRomMapped+0x42> @ imm = #-0x2
;                 (inp >= inst->rom_usage[i].inp_start) &&
700a6382: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a6386: 9901         	ldr	r1, [sp, #0x4]
700a6388: 6909         	ldr	r1, [r1, #0x10]
700a638a: f89d 2000    	ldrb.w	r2, [sp]
700a638e: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700a6392: 4288         	cmp	r0, r1
700a6394: db1a         	blt	0x700a63cc <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x34
700a6396: e7ff         	b	0x700a6398 <Sciclient_rmIrInpRomMapped+0x58> @ imm = #-0x2
;                 (inp < (inst->rom_usage[i].inp_start +
700a6398: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a639c: 9901         	ldr	r1, [sp, #0x4]
700a639e: 6909         	ldr	r1, [r1, #0x10]
700a63a0: f89d 3000    	ldrb.w	r3, [sp]
700a63a4: eb01 02c3    	add.w	r2, r1, r3, lsl #3
700a63a8: f831 1033    	ldrh.w	r1, [r1, r3, lsl #3]
;                         inst->rom_usage[i].length))) {
700a63ac: 8892         	ldrh	r2, [r2, #0x4]
;                 (inp < (inst->rom_usage[i].inp_start +
700a63ae: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a63b0: 4288         	cmp	r0, r1
700a63b2: da0b         	bge	0x700a63cc <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x16
700a63b4: e7ff         	b	0x700a63b6 <Sciclient_rmIrInpRomMapped+0x76> @ imm = #-0x2
700a63b6: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a63b8: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a63bc: 9901         	ldr	r1, [sp, #0x4]
700a63be: 6909         	ldr	r1, [r1, #0x10]
700a63c0: f89d 2000    	ldrb.w	r2, [sp]
700a63c4: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a63c8: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a63ca: e006         	b	0x700a63da <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0xc
;         }
700a63cc: e7ff         	b	0x700a63ce <Sciclient_rmIrInpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a63ce: f89d 0000    	ldrb.w	r0, [sp]
700a63d2: 3001         	adds	r0, #0x1
700a63d4: f88d 0000    	strb.w	r0, [sp]
700a63d8: e7c2         	b	0x700a6360 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x7c
;     }
700a63da: e7ff         	b	0x700a63dc <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a63dc: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a63e0: f000 0001    	and	r0, r0, #0x1
700a63e4: b002         	add	sp, #0x8
700a63e6: 4770         	bx	lr
		...

700a63f0 <Sciclient_rmIrOutpRomMapped>:
; {
700a63f0: b082         	sub	sp, #0x8
700a63f2: 9001         	str	r0, [sp, #0x4]
700a63f4: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a63f8: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a63fa: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a63fe: 9801         	ldr	r0, [sp, #0x4]
700a6400: 6900         	ldr	r0, [r0, #0x10]
700a6402: 2800         	cmp	r0, #0x0
700a6404: d042         	beq	0x700a648c <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #0x84
700a6406: e7ff         	b	0x700a6408 <Sciclient_rmIrOutpRomMapped+0x18> @ imm = #-0x2
700a6408: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a640a: f88d 0000    	strb.w	r0, [sp]
700a640e: e7ff         	b	0x700a6410 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x2
700a6410: f89d 0000    	ldrb.w	r0, [sp]
700a6414: 9901         	ldr	r1, [sp, #0x4]
700a6416: 7d09         	ldrb	r1, [r1, #0x14]
700a6418: 4288         	cmp	r0, r1
700a641a: da36         	bge	0x700a648a <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0x6c
700a641c: e7ff         	b	0x700a641e <Sciclient_rmIrOutpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a641e: 9801         	ldr	r0, [sp, #0x4]
700a6420: 6900         	ldr	r0, [r0, #0x10]
700a6422: f89d 1000    	ldrb.w	r1, [sp]
700a6426: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a642a: 7980         	ldrb	r0, [r0, #0x6]
700a642c: 07c0         	lsls	r0, r0, #0x1f
700a642e: bb28         	cbnz	r0, 0x700a647c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x4a
700a6430: e7ff         	b	0x700a6432 <Sciclient_rmIrOutpRomMapped+0x42> @ imm = #-0x2
;                 (outp >= inst->rom_usage[i].outp_start) &&
700a6432: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a6436: 9901         	ldr	r1, [sp, #0x4]
700a6438: 6909         	ldr	r1, [r1, #0x10]
700a643a: f89d 2000    	ldrb.w	r2, [sp]
700a643e: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a6442: 8849         	ldrh	r1, [r1, #0x2]
700a6444: 4288         	cmp	r0, r1
700a6446: db19         	blt	0x700a647c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x32
700a6448: e7ff         	b	0x700a644a <Sciclient_rmIrOutpRomMapped+0x5a> @ imm = #-0x2
;                 (outp < (inst->rom_usage[i].outp_start +
700a644a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a644e: 9901         	ldr	r1, [sp, #0x4]
700a6450: 6909         	ldr	r1, [r1, #0x10]
700a6452: f89d 2000    	ldrb.w	r2, [sp]
700a6456: eb01 02c2    	add.w	r2, r1, r2, lsl #3
700a645a: 8851         	ldrh	r1, [r2, #0x2]
;                         inst->rom_usage[i].length))) {
700a645c: 8892         	ldrh	r2, [r2, #0x4]
;                 (outp < (inst->rom_usage[i].outp_start +
700a645e: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a6460: 4288         	cmp	r0, r1
700a6462: da0b         	bge	0x700a647c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x16
700a6464: e7ff         	b	0x700a6466 <Sciclient_rmIrOutpRomMapped+0x76> @ imm = #-0x2
700a6466: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a6468: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a646c: 9901         	ldr	r1, [sp, #0x4]
700a646e: 6909         	ldr	r1, [r1, #0x10]
700a6470: f89d 2000    	ldrb.w	r2, [sp]
700a6474: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a6478: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a647a: e006         	b	0x700a648a <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0xc
;         }
700a647c: e7ff         	b	0x700a647e <Sciclient_rmIrOutpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a647e: f89d 0000    	ldrb.w	r0, [sp]
700a6482: 3001         	adds	r0, #0x1
700a6484: f88d 0000    	strb.w	r0, [sp]
700a6488: e7c2         	b	0x700a6410 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x7c
;     }
700a648a: e7ff         	b	0x700a648c <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a648c: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a6490: f000 0001    	and	r0, r0, #0x1
700a6494: b002         	add	sp, #0x8
700a6496: 4770         	bx	lr
		...

700a64a0 <CycleCounterP_init>:
; {
700a64a0: b580         	push	{r7, lr}
700a64a2: b082         	sub	sp, #0x8
700a64a4: 9101         	str	r1, [sp, #0x4]
700a64a6: 9000         	str	r0, [sp]
;     gCounterFreqHz = cpuFreqHz/PmuP_SETUP_COUNTER_DIVIDER_VAL;
700a64a8: 9800         	ldr	r0, [sp]
700a64aa: 9a01         	ldr	r2, [sp, #0x4]
700a64ac: f240 4190    	movw	r1, #0x490
700a64b0: f2c7 010b    	movt	r1, #0x700b
700a64b4: 604a         	str	r2, [r1, #0x4]
700a64b6: 6008         	str	r0, [r1]
;     CycleCounterP_reset();
700a64b8: f000 f802    	bl	0x700a64c0 <CycleCounterP_reset> @ imm = #0x4
; }
700a64bc: b002         	add	sp, #0x8
700a64be: bd80         	pop	{r7, pc}

700a64c0 <CycleCounterP_reset>:
; {
700a64c0: b580         	push	{r7, lr}
700a64c2: b082         	sub	sp, #0x8
700a64c4: 2000         	movs	r0, #0x0
;     uint32_t setupFlags = 0;
700a64c6: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_CYCLE_COUNTER_RESET;
700a64c8: 9801         	ldr	r0, [sp, #0x4]
700a64ca: f040 0004    	orr	r0, r0, #0x4
700a64ce: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_EVENT_COUNTER_RESET;
700a64d0: 9801         	ldr	r0, [sp, #0x4]
700a64d2: f040 0002    	orr	r0, r0, #0x2
700a64d6: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_ENABLE_ALL_COUNTERS;
700a64d8: 9801         	ldr	r0, [sp, #0x4]
700a64da: f040 0001    	orr	r0, r0, #0x1
700a64de: 9001         	str	r0, [sp, #0x4]
700a64e0: f04f 30ff    	mov.w	r0, #0xffffffff
;     PmuP_disableCounters(PmuP_COUNTER_MASK_ALL_COUNTERS); /* disable all counters */
700a64e4: 9000         	str	r0, [sp]
700a64e6: f006 e8e8    	blx	0x700ac6b8 <PmuP_disableCounters> @ imm = #0x61d0
700a64ea: 9800         	ldr	r0, [sp]
;     PmuP_clearOverflowStatus(PmuP_COUNTER_MASK_ALL_COUNTERS); /* clear all overflow flags */
700a64ec: f006 e8ec    	blx	0x700ac6c8 <PmuP_clearOverflowStatus> @ imm = #0x61d8
;     PmuP_setup(setupFlags); /* setup counters */
700a64f0: 9801         	ldr	r0, [sp, #0x4]
700a64f2: f006 e8da    	blx	0x700ac6a8 <PmuP_setup> @ imm = #0x61b4
700a64f6: f04f 4000    	mov.w	r0, #0x80000000
;     PmuP_enableCounters(PmuP_COUNTER_MASK_CYCLE_COUNTER); /* enable cycle counter only */
700a64fa: f006 e8da    	blx	0x700ac6b0 <PmuP_enableCounters> @ imm = #0x61b4
; }
700a64fe: b002         	add	sp, #0x8
700a6500: bd80         	pop	{r7, pc}
700a6502: bf00         	nop
700a6504: bf00         	nop
700a6506: bf00         	nop
700a6508: bf00         	nop
700a650a: bf00         	nop
700a650c: bf00         	nop
700a650e: bf00         	nop

700a6510 <CycleCounterP_nsToTicks>:
; {
700a6510: b580         	push	{r7, lr}
700a6512: b082         	sub	sp, #0x8
700a6514: 9101         	str	r1, [sp, #0x4]
700a6516: 9000         	str	r0, [sp]
;     return (((uint64_t)nanosecs*gCounterFreqHz)/PmuP_SEC_TO_NANOSEC);
700a6518: 9b00         	ldr	r3, [sp]
700a651a: 9901         	ldr	r1, [sp, #0x4]
700a651c: f240 4090    	movw	r0, #0x490
700a6520: f2c7 000b    	movt	r0, #0x700b
700a6524: 6802         	ldr	r2, [r0]
700a6526: f8d0 c004    	ldr.w	r12, [r0, #0x4]
700a652a: fba3 0e02    	umull	r0, lr, r3, r2
700a652e: fb03 e30c    	mla	r3, r3, r12, lr
700a6532: fb01 3102    	mla	r1, r1, r2, r3
700a6536: f64c 2200    	movw	r2, #0xca00
700a653a: f6c3 329a    	movt	r2, #0x3b9a
700a653e: 2300         	movs	r3, #0x0
700a6540: f006 ed40    	blx	0x700acfc4 <__aeabi_uldivmod> @ imm = #0x6a80
700a6544: b002         	add	sp, #0x8
700a6546: bd80         	pop	{r7, pc}
		...

700a6550 <Sciclient_pmGetModuleClkNumParent>:
; {
700a6550: b580         	push	{r7, lr}
700a6552: b096         	sub	sp, #0x58
700a6554: 9015         	str	r0, [sp, #0x54]
700a6556: 9114         	str	r1, [sp, #0x50]
700a6558: 9213         	str	r2, [sp, #0x4c]
700a655a: 9312         	str	r3, [sp, #0x48]
700a655c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a655e: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_num_clock_parents_req request = {{0}};
700a6560: f88d 0040    	strb.w	r0, [sp, #0x40]
700a6564: 900f         	str	r0, [sp, #0x3c]
700a6566: 900e         	str	r0, [sp, #0x38]
700a6568: 900d         	str	r0, [sp, #0x34]
700a656a: 900c         	str	r0, [sp, #0x30]
;     request.device = (uint32_t) moduleId;
700a656c: 9815         	ldr	r0, [sp, #0x54]
700a656e: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a6570: 9814         	ldr	r0, [sp, #0x50]
700a6572: 28ff         	cmp	r0, #0xff
700a6574: d307         	blo	0x700a6586 <Sciclient_pmGetModuleClkNumParent+0x36> @ imm = #0xe
700a6576: e7ff         	b	0x700a6578 <Sciclient_pmGetModuleClkNumParent+0x28> @ imm = #-0x2
;         request.clk32 = clockId;
700a6578: 9814         	ldr	r0, [sp, #0x50]
700a657a: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a657e: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a6580: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a6584: e003         	b	0x700a658e <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a6586: 9814         	ldr	r0, [sp, #0x50]
700a6588: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a658c: e7ff         	b	0x700a658e <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #-0x2
700a658e: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_num_clock_parents_resp response = {{0}};
700a6590: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a6594: 900a         	str	r0, [sp, #0x28]
700a6596: 9009         	str	r0, [sp, #0x24]
700a6598: 9008         	str	r0, [sp, #0x20]
700a659a: f44f 7182    	mov.w	r1, #0x104
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_NUM_CLOCK_PARENTS;
700a659e: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a65a2: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a65a4: 9104         	str	r1, [sp, #0x10]
700a65a6: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a65a8: 9105         	str	r1, [sp, #0x14]
700a65aa: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a65ac: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a65ae: 9912         	ldr	r1, [sp, #0x48]
700a65b0: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a65b2: 9000         	str	r0, [sp]
700a65b4: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a65b6: 9001         	str	r0, [sp, #0x4]
700a65b8: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a65ba: 9002         	str	r0, [sp, #0x8]
700a65bc: a803         	add	r0, sp, #0xc
700a65be: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a65c0: f7f5 fc5e    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xa744
700a65c4: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a65c6: 9811         	ldr	r0, [sp, #0x44]
700a65c8: b930         	cbnz	r0, 0x700a65d8 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #0xc
700a65ca: e7ff         	b	0x700a65cc <Sciclient_pmGetModuleClkNumParent+0x7c> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a65cc: 9800         	ldr	r0, [sp]
700a65ce: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a65d2: 2802         	cmp	r0, #0x2
700a65d4: d004         	beq	0x700a65e0 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #0x8
700a65d6: e7ff         	b	0x700a65d8 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #-0x2
700a65d8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a65dc: 9011         	str	r0, [sp, #0x44]
;     }
700a65de: e7ff         	b	0x700a65e0 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a65e0: 9811         	ldr	r0, [sp, #0x44]
700a65e2: b928         	cbnz	r0, 0x700a65f0 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #0xa
700a65e4: e7ff         	b	0x700a65e6 <Sciclient_pmGetModuleClkNumParent+0x96> @ imm = #-0x2
;         *numParent = (uint32_t) response.num_parents;
700a65e6: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a65ea: 9913         	ldr	r1, [sp, #0x4c]
700a65ec: 6008         	str	r0, [r1]
;     }
700a65ee: e7ff         	b	0x700a65f0 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #-0x2
;     return retVal;
700a65f0: 9811         	ldr	r0, [sp, #0x44]
700a65f2: b016         	add	sp, #0x58
700a65f4: bd80         	pop	{r7, pc}
		...
700a65fe: 0000         	movs	r0, r0

700a6600 <CSL_intaggrIsIntrPending>:
; {
700a6600: b580         	push	{r7, lr}
700a6602: b088         	sub	sp, #0x20
700a6604: 9007         	str	r0, [sp, #0x1c]
700a6606: 9106         	str	r1, [sp, #0x18]
700a6608: f88d 2017    	strb.w	r2, [sp, #0x17]
700a660c: 2000         	movs	r0, #0x0
;     bool     retVal = (bool)false;
700a660e: f88d 0016    	strb.w	r0, [sp, #0x16]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700a6612: 9807         	ldr	r0, [sp, #0x1c]
700a6614: 9906         	ldr	r1, [sp, #0x18]
700a6616: f005 fbc3    	bl	0x700abda0 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x5786
700a661a: b3e8         	cbz	r0, 0x700a6698 <CSL_intaggrIsIntrPending+0x98> @ imm = #0x7a
700a661c: e7ff         	b	0x700a661e <CSL_intaggrIsIntrPending+0x1e> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700a661e: 9806         	ldr	r0, [sp, #0x18]
700a6620: 0980         	lsrs	r0, r0, #0x6
700a6622: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700a6624: 9806         	ldr	r0, [sp, #0x18]
700a6626: f000 003f    	and	r0, r0, #0x3f
700a662a: 9000         	str	r0, [sp]
;         if( bMaskedStatus == (bool)true )
700a662c: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a6630: 07c0         	lsls	r0, r0, #0x1f
700a6632: b158         	cbz	r0, 0x700a664c <CSL_intaggrIsIntrPending+0x4c> @ imm = #0x16
700a6634: e7ff         	b	0x700a6636 <CSL_intaggrIsIntrPending+0x36> @ imm = #-0x2
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUSM );
700a6636: 9807         	ldr	r0, [sp, #0x1c]
700a6638: 6880         	ldr	r0, [r0, #0x8]
700a663a: 9901         	ldr	r1, [sp, #0x4]
700a663c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6640: 3020         	adds	r0, #0x20
700a6642: f007 f96d    	bl	0x700ad920 <CSL_REG64_RD_RAW> @ imm = #0x72da
700a6646: 9103         	str	r1, [sp, #0xc]
700a6648: 9002         	str	r0, [sp, #0x8]
;         }
700a664a: e00a         	b	0x700a6662 <CSL_intaggrIsIntrPending+0x62> @ imm = #0x14
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUS_SET );
700a664c: 9807         	ldr	r0, [sp, #0x1c]
700a664e: 6880         	ldr	r0, [r0, #0x8]
700a6650: 9901         	ldr	r1, [sp, #0x4]
700a6652: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6656: 3010         	adds	r0, #0x10
700a6658: f007 f962    	bl	0x700ad920 <CSL_REG64_RD_RAW> @ imm = #0x72c4
700a665c: 9103         	str	r1, [sp, #0xc]
700a665e: 9002         	str	r0, [sp, #0x8]
700a6660: e7ff         	b	0x700a6662 <CSL_intaggrIsIntrPending+0x62> @ imm = #-0x2
;         if( (regVal & (((uint64_t)1U) << bitNum)) == 0U )
700a6662: 9802         	ldr	r0, [sp, #0x8]
700a6664: 9903         	ldr	r1, [sp, #0xc]
700a6666: 9a00         	ldr	r2, [sp]
700a6668: 40d0         	lsrs	r0, r2
700a666a: f1c2 0320    	rsb.w	r3, r2, #0x20
700a666e: fa01 f303    	lsl.w	r3, r1, r3
700a6672: 4318         	orrs	r0, r3
700a6674: 3a20         	subs	r2, #0x20
700a6676: 40d1         	lsrs	r1, r2
700a6678: 2a00         	cmp	r2, #0x0
700a667a: bf58         	it	pl
700a667c: 4608         	movpl	r0, r1
700a667e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
700a6682: b920         	cbnz	r0, 0x700a668e <CSL_intaggrIsIntrPending+0x8e> @ imm = #0x8
700a6684: e7ff         	b	0x700a6686 <CSL_intaggrIsIntrPending+0x86> @ imm = #-0x2
700a6686: 2000         	movs	r0, #0x0
;             retVal = (bool)false; /* Interrupt is not pending */
700a6688: f88d 0016    	strb.w	r0, [sp, #0x16]
;         }
700a668c: e003         	b	0x700a6696 <CSL_intaggrIsIntrPending+0x96> @ imm = #0x6
700a668e: 2001         	movs	r0, #0x1
;             retVal = (bool)true;  /* Interrupt is pending */
700a6690: f88d 0016    	strb.w	r0, [sp, #0x16]
700a6694: e7ff         	b	0x700a6696 <CSL_intaggrIsIntrPending+0x96> @ imm = #-0x2
;     }
700a6696: e7ff         	b	0x700a6698 <CSL_intaggrIsIntrPending+0x98> @ imm = #-0x2
;     return retVal;
700a6698: f89d 0016    	ldrb.w	r0, [sp, #0x16]
700a669c: f000 0001    	and	r0, r0, #0x1
700a66a0: b008         	add	sp, #0x20
700a66a2: bd80         	pop	{r7, pc}
		...

700a66b0 <Sciclient_rmIrqCheckLoop>:
; {
700a66b0: b580         	push	{r7, lr}
700a66b2: b088         	sub	sp, #0x20
700a66b4: 9007         	str	r0, [sp, #0x1c]
700a66b6: 2000         	movs	r0, #0x0
;     bool loop = false;
700a66b8: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a66bc: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a66c0: e7ff         	b	0x700a66c2 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x2
700a66c2: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a66c6: 9002         	str	r0, [sp, #0x8]
700a66c8: f007 f982    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0x7304
700a66cc: 4601         	mov	r1, r0
700a66ce: 9802         	ldr	r0, [sp, #0x8]
700a66d0: 4288         	cmp	r0, r1
700a66d2: da39         	bge	0x700a6748 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0x72
700a66d4: e7ff         	b	0x700a66d6 <Sciclient_rmIrqCheckLoop+0x26> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a66d6: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a66da: f006 fd71    	bl	0x700ad1c0 <Sciclient_rmPsGetIrqNode> @ imm = #0x6ae2
700a66de: 9004         	str	r0, [sp, #0x10]
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a66e0: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a66e4: 3001         	adds	r0, #0x1
700a66e6: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a66ea: e7ff         	b	0x700a66ec <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x2
700a66ec: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a66f0: 9001         	str	r0, [sp, #0x4]
700a66f2: f007 f96d    	bl	0x700ad9d0 <Sciclient_rmPsGetPsp> @ imm = #0x72da
700a66f6: 4601         	mov	r1, r0
700a66f8: 9801         	ldr	r0, [sp, #0x4]
700a66fa: 4288         	cmp	r0, r1
700a66fc: da17         	bge	0x700a672e <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0x2e
700a66fe: e7ff         	b	0x700a6700 <Sciclient_rmIrqCheckLoop+0x50> @ imm = #-0x2
;             future_n = Sciclient_rmPsGetIrqNode(j);
700a6700: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a6704: f006 fd5c    	bl	0x700ad1c0 <Sciclient_rmPsGetIrqNode> @ imm = #0x6ab8
700a6708: 9003         	str	r0, [sp, #0xc]
;             if (cur_n->id == future_n->id) {
700a670a: 9804         	ldr	r0, [sp, #0x10]
700a670c: 8800         	ldrh	r0, [r0]
700a670e: 9903         	ldr	r1, [sp, #0xc]
700a6710: 8809         	ldrh	r1, [r1]
700a6712: 4288         	cmp	r0, r1
700a6714: d104         	bne	0x700a6720 <Sciclient_rmIrqCheckLoop+0x70> @ imm = #0x8
700a6716: e7ff         	b	0x700a6718 <Sciclient_rmIrqCheckLoop+0x68> @ imm = #-0x2
700a6718: 2001         	movs	r0, #0x1
;                 loop = true;
700a671a: f88d 001b    	strb.w	r0, [sp, #0x1b]
;                 break;
700a671e: e006         	b	0x700a672e <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0xc
;         }
700a6720: e7ff         	b	0x700a6722 <Sciclient_rmIrqCheckLoop+0x72> @ imm = #-0x2
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a6722: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a6726: 3001         	adds	r0, #0x1
700a6728: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a672c: e7de         	b	0x700a66ec <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x44
;         if (loop == true) {
700a672e: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a6732: 07c0         	lsls	r0, r0, #0x1f
700a6734: b108         	cbz	r0, 0x700a673a <Sciclient_rmIrqCheckLoop+0x8a> @ imm = #0x2
700a6736: e7ff         	b	0x700a6738 <Sciclient_rmIrqCheckLoop+0x88> @ imm = #-0x2
;             break;
700a6738: e006         	b	0x700a6748 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0xc
;     }
700a673a: e7ff         	b	0x700a673c <Sciclient_rmIrqCheckLoop+0x8c> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a673c: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a6740: 3001         	adds	r0, #0x1
700a6742: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a6746: e7bc         	b	0x700a66c2 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x88
;     return loop;
700a6748: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a674c: f000 0001    	and	r0, r0, #0x1
700a6750: b008         	add	sp, #0x20
700a6752: bd80         	pop	{r7, pc}
		...

700a6760 <UART_IsBaseAddrValid>:
; {
700a6760: b082         	sub	sp, #0x8
700a6762: 9001         	str	r0, [sp, #0x4]
700a6764: f06f 0002    	mvn	r0, #0x2
;     int32_t status = (int32_t)-3;
700a6768: 9000         	str	r0, [sp]
;     if ((baseAddr == CSL_UART0_BASE) ||
700a676a: 9801         	ldr	r0, [sp, #0x4]
700a676c: f1b0 7f20    	cmp.w	r0, #0x2800000
700a6770: d042         	beq	0x700a67f8 <UART_IsBaseAddrValid+0x98> @ imm = #0x84
700a6772: e7ff         	b	0x700a6774 <UART_IsBaseAddrValid+0x14> @ imm = #-0x2
;         (baseAddr == CSL_UART1_BASE) ||
700a6774: 9801         	ldr	r0, [sp, #0x4]
700a6776: 2100         	movs	r1, #0x0
700a6778: f2c0 2181    	movt	r1, #0x281
700a677c: 4288         	cmp	r0, r1
700a677e: d03b         	beq	0x700a67f8 <UART_IsBaseAddrValid+0x98> @ imm = #0x76
700a6780: e7ff         	b	0x700a6782 <UART_IsBaseAddrValid+0x22> @ imm = #-0x2
;         (baseAddr == CSL_UART2_BASE) ||
700a6782: 9801         	ldr	r0, [sp, #0x4]
700a6784: 2100         	movs	r1, #0x0
700a6786: f2c0 2182    	movt	r1, #0x282
700a678a: 4288         	cmp	r0, r1
700a678c: d034         	beq	0x700a67f8 <UART_IsBaseAddrValid+0x98> @ imm = #0x68
700a678e: e7ff         	b	0x700a6790 <UART_IsBaseAddrValid+0x30> @ imm = #-0x2
;         (baseAddr == CSL_UART3_BASE) ||
700a6790: 9801         	ldr	r0, [sp, #0x4]
700a6792: 2100         	movs	r1, #0x0
700a6794: f2c0 2183    	movt	r1, #0x283
700a6798: 4288         	cmp	r0, r1
700a679a: d02d         	beq	0x700a67f8 <UART_IsBaseAddrValid+0x98> @ imm = #0x5a
700a679c: e7ff         	b	0x700a679e <UART_IsBaseAddrValid+0x3e> @ imm = #-0x2
;         (baseAddr == CSL_UART4_BASE) ||
700a679e: 9801         	ldr	r0, [sp, #0x4]
700a67a0: f1b0 7f21    	cmp.w	r0, #0x2840000
700a67a4: d028         	beq	0x700a67f8 <UART_IsBaseAddrValid+0x98> @ imm = #0x50
700a67a6: e7ff         	b	0x700a67a8 <UART_IsBaseAddrValid+0x48> @ imm = #-0x2
;         (baseAddr == CSL_UART5_BASE) ||
700a67a8: 9801         	ldr	r0, [sp, #0x4]
700a67aa: 2100         	movs	r1, #0x0
700a67ac: f2c0 2185    	movt	r1, #0x285
700a67b0: 4288         	cmp	r0, r1
700a67b2: d021         	beq	0x700a67f8 <UART_IsBaseAddrValid+0x98> @ imm = #0x42
700a67b4: e7ff         	b	0x700a67b6 <UART_IsBaseAddrValid+0x56> @ imm = #-0x2
;         (baseAddr == CSL_UART6_BASE) ||
700a67b6: 9801         	ldr	r0, [sp, #0x4]
700a67b8: 2100         	movs	r1, #0x0
700a67ba: f2c0 2186    	movt	r1, #0x286
700a67be: 4288         	cmp	r0, r1
700a67c0: d01a         	beq	0x700a67f8 <UART_IsBaseAddrValid+0x98> @ imm = #0x34
700a67c2: e7ff         	b	0x700a67c4 <UART_IsBaseAddrValid+0x64> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART0_BASE) ||
700a67c4: 9801         	ldr	r0, [sp, #0x4]
700a67c6: f1b0 6f94    	cmp.w	r0, #0x4a00000
700a67ca: d015         	beq	0x700a67f8 <UART_IsBaseAddrValid+0x98> @ imm = #0x2a
700a67cc: e7ff         	b	0x700a67ce <UART_IsBaseAddrValid+0x6e> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART1_BASE) ||
700a67ce: 9801         	ldr	r0, [sp, #0x4]
700a67d0: 2100         	movs	r1, #0x0
700a67d2: f2c0 41a1    	movt	r1, #0x4a1
700a67d6: 4288         	cmp	r0, r1
700a67d8: d00e         	beq	0x700a67f8 <UART_IsBaseAddrValid+0x98> @ imm = #0x1c
700a67da: e7ff         	b	0x700a67dc <UART_IsBaseAddrValid+0x7c> @ imm = #-0x2
;         (baseAddr == MCU_UART0_BASE_AFTER_ADDR_TRANSLATE) ||
700a67dc: 9801         	ldr	r0, [sp, #0x4]
700a67de: 2100         	movs	r1, #0x0
700a67e0: f2c8 41a0    	movt	r1, #0x84a0
700a67e4: 4288         	cmp	r0, r1
700a67e6: d007         	beq	0x700a67f8 <UART_IsBaseAddrValid+0x98> @ imm = #0xe
700a67e8: e7ff         	b	0x700a67ea <UART_IsBaseAddrValid+0x8a> @ imm = #-0x2
;         (baseAddr == MCU_UART1_BASE_AFTER_ADDR_TRANSLATE))
700a67ea: 9801         	ldr	r0, [sp, #0x4]
700a67ec: 2100         	movs	r1, #0x0
700a67ee: f2c8 41a1    	movt	r1, #0x84a1
;     if ((baseAddr == CSL_UART0_BASE) ||
700a67f2: 4288         	cmp	r0, r1
700a67f4: d103         	bne	0x700a67fe <UART_IsBaseAddrValid+0x9e> @ imm = #0x6
700a67f6: e7ff         	b	0x700a67f8 <UART_IsBaseAddrValid+0x98> @ imm = #-0x2
700a67f8: 2000         	movs	r0, #0x0
;         status = 0;
700a67fa: 9000         	str	r0, [sp]
;     }
700a67fc: e7ff         	b	0x700a67fe <UART_IsBaseAddrValid+0x9e> @ imm = #-0x2
;     return status;
700a67fe: 9800         	ldr	r0, [sp]
700a6800: b002         	add	sp, #0x8
700a6802: 4770         	bx	lr

700a6804 <split>:
700a6804: e92d48f0     	push	{r4, r5, r6, r7, r11, lr}
700a6808: e1a04000     	mov	r4, r0
700a680c: e5900000     	ldr	r0, [r0]
700a6810: e1a05001     	mov	r5, r1
700a6814: e3c01001     	bic	r1, r0, #1
700a6818: e0411005     	sub	r1, r1, r5
700a681c: e3510010     	cmp	r1, #16
700a6820: 3a00001b     	blo	0x700a6894 <split+0x90> @ imm = #0x6c
700a6824: e2410008     	sub	r0, r1, #8
700a6828: e0846005     	add	r6, r4, r5
700a682c: e59f106c     	ldr	r1, [pc, #0x6c]         @ 0x700a68a0 <split+0x9c>
700a6830: e59f206c     	ldr	r2, [pc, #0x6c]         @ 0x700a68a4 <split+0xa0>
700a6834: e5a60008     	str	r0, [r6, #0x8]!
700a6838: e3c00001     	bic	r0, r0, #1
700a683c: e3510007     	cmp	r1, #7
700a6840: e0860000     	add	r0, r6, r0
700a6844: e2807008     	add	r7, r0, #8
700a6848: e0810002     	add	r0, r1, r2
700a684c: 82402008     	subhi	r2, r0, #8
700a6850: e1570002     	cmp	r7, r2
700a6854: 2a00000b     	bhs	0x700a6888 <split+0x84> @ imm = #0x2c
700a6858: e5d70000     	ldrb	r0, [r7]
700a685c: e3100001     	tst	r0, #1
700a6860: 1a000008     	bne	0x700a6888 <split+0x84> @ imm = #0x20
700a6864: e1a00007     	mov	r0, r7
700a6868: eb0016e9     	bl	0x700ac414 <free_list_remove> @ imm = #0x5ba4
700a686c: e5960000     	ldr	r0, [r6]
700a6870: e5971000     	ldr	r1, [r7]
700a6874: e3c00001     	bic	r0, r0, #1
700a6878: e3c11001     	bic	r1, r1, #1
700a687c: e0800001     	add	r0, r0, r1
700a6880: e2800008     	add	r0, r0, #8
700a6884: e5860000     	str	r0, [r6]
700a6888: e1a00006     	mov	r0, r6
700a688c: eb0014a3     	bl	0x700abb20 <free_list_insert> @ imm = #0x528c
700a6890: e1a00005     	mov	r0, r5
700a6894: e3800001     	orr	r0, r0, #1
700a6898: e5840000     	str	r0, [r4]
700a689c: e8bd88f0     	pop	{r4, r5, r6, r7, r11, pc}
700a68a0: 00 00 01 00  	.word	0x00010000
700a68a4: 00 50 08 70  	.word	0x70085000
700a68a8: 00 00 00 00  	.word	0x00000000
700a68ac: 00 00 00 00  	.word	0x00000000

700a68b0 <xQueueGenericSendFromISR>:
; {
700a68b0: b580         	push	{r7, lr}
700a68b2: b08a         	sub	sp, #0x28
700a68b4: 9009         	str	r0, [sp, #0x24]
700a68b6: 9108         	str	r1, [sp, #0x20]
700a68b8: 9207         	str	r2, [sp, #0x1c]
700a68ba: 9306         	str	r3, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a68bc: 9809         	ldr	r0, [sp, #0x24]
700a68be: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a68c0: f007 eed6    	blx	0x700ae670 <HwiP_disable> @ imm = #0x7dac
700a68c4: 9004         	str	r0, [sp, #0x10]
;         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a68c6: 9803         	ldr	r0, [sp, #0xc]
700a68c8: 6b80         	ldr	r0, [r0, #0x38]
700a68ca: 9903         	ldr	r1, [sp, #0xc]
700a68cc: 6bc9         	ldr	r1, [r1, #0x3c]
700a68ce: 4288         	cmp	r0, r1
700a68d0: d304         	blo	0x700a68dc <xQueueGenericSendFromISR+0x2c> @ imm = #0x8
700a68d2: e7ff         	b	0x700a68d4 <xQueueGenericSendFromISR+0x24> @ imm = #-0x2
700a68d4: 9806         	ldr	r0, [sp, #0x18]
700a68d6: 2802         	cmp	r0, #0x2
700a68d8: d133         	bne	0x700a6942 <xQueueGenericSendFromISR+0x92> @ imm = #0x66
700a68da: e7ff         	b	0x700a68dc <xQueueGenericSendFromISR+0x2c> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a68dc: 9803         	ldr	r0, [sp, #0xc]
700a68de: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a68e2: f88d 000b    	strb.w	r0, [sp, #0xb]
;             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
700a68e6: 9803         	ldr	r0, [sp, #0xc]
700a68e8: 6b80         	ldr	r0, [r0, #0x38]
700a68ea: 9001         	str	r0, [sp, #0x4]
;             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a68ec: 9803         	ldr	r0, [sp, #0xc]
700a68ee: 9908         	ldr	r1, [sp, #0x20]
700a68f0: 9a06         	ldr	r2, [sp, #0x18]
700a68f2: f7fe f915    	bl	0x700a4b20 <prvCopyDataToQueue> @ imm = #-0x1dd6
;             if( cTxLock == queueUNLOCKED )
700a68f6: f99d 000b    	ldrsb.w	r0, [sp, #0xb]
700a68fa: 3001         	adds	r0, #0x1
700a68fc: b9b8         	cbnz	r0, 0x700a692e <xQueueGenericSendFromISR+0x7e> @ imm = #0x2e
700a68fe: e7ff         	b	0x700a6900 <xQueueGenericSendFromISR+0x50> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a6900: 9803         	ldr	r0, [sp, #0xc]
700a6902: 6a40         	ldr	r0, [r0, #0x24]
700a6904: b188         	cbz	r0, 0x700a692a <xQueueGenericSendFromISR+0x7a> @ imm = #0x22
700a6906: e7ff         	b	0x700a6908 <xQueueGenericSendFromISR+0x58> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a6908: 9803         	ldr	r0, [sp, #0xc]
700a690a: 3024         	adds	r0, #0x24
700a690c: f7ff fcc0    	bl	0x700a6290 <xTaskRemoveFromEventList> @ imm = #-0x680
700a6910: b148         	cbz	r0, 0x700a6926 <xQueueGenericSendFromISR+0x76> @ imm = #0x12
700a6912: e7ff         	b	0x700a6914 <xQueueGenericSendFromISR+0x64> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a6914: 9807         	ldr	r0, [sp, #0x1c]
700a6916: b120         	cbz	r0, 0x700a6922 <xQueueGenericSendFromISR+0x72> @ imm = #0x8
700a6918: e7ff         	b	0x700a691a <xQueueGenericSendFromISR+0x6a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a691a: 9907         	ldr	r1, [sp, #0x1c]
700a691c: 2001         	movs	r0, #0x1
700a691e: 6008         	str	r0, [r1]
;                                 }
700a6920: e000         	b	0x700a6924 <xQueueGenericSendFromISR+0x74> @ imm = #0x0
700a6922: e7ff         	b	0x700a6924 <xQueueGenericSendFromISR+0x74> @ imm = #-0x2
;                             }
700a6924: e000         	b	0x700a6928 <xQueueGenericSendFromISR+0x78> @ imm = #0x0
700a6926: e7ff         	b	0x700a6928 <xQueueGenericSendFromISR+0x78> @ imm = #-0x2
;                         }
700a6928: e000         	b	0x700a692c <xQueueGenericSendFromISR+0x7c> @ imm = #0x0
700a692a: e7ff         	b	0x700a692c <xQueueGenericSendFromISR+0x7c> @ imm = #-0x2
;             }
700a692c: e006         	b	0x700a693c <xQueueGenericSendFromISR+0x8c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a692e: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a6932: 3001         	adds	r0, #0x1
700a6934: 9903         	ldr	r1, [sp, #0xc]
700a6936: f881 0045    	strb.w	r0, [r1, #0x45]
700a693a: e7ff         	b	0x700a693c <xQueueGenericSendFromISR+0x8c> @ imm = #-0x2
700a693c: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a693e: 9005         	str	r0, [sp, #0x14]
;         }
700a6940: e002         	b	0x700a6948 <xQueueGenericSendFromISR+0x98> @ imm = #0x4
700a6942: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a6944: 9005         	str	r0, [sp, #0x14]
700a6946: e7ff         	b	0x700a6948 <xQueueGenericSendFromISR+0x98> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a6948: 9804         	ldr	r0, [sp, #0x10]
700a694a: f007 eeb2    	blx	0x700ae6b0 <HwiP_restore> @ imm = #0x7d64
;     return xReturn;
700a694e: 9805         	ldr	r0, [sp, #0x14]
700a6950: b00a         	add	sp, #0x28
700a6952: bd80         	pop	{r7, pc}
		...

700a6960 <prvCheckForValidListAndQueue>:
;     {
700a6960: b580         	push	{r7, lr}
700a6962: b084         	sub	sp, #0x10
;         taskENTER_CRITICAL();
700a6964: f005 fe14    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x5c28
;             if( xTimerQueue == NULL )
700a6968: f240 5024    	movw	r0, #0x524
700a696c: f2c7 000b    	movt	r0, #0x700b
700a6970: 6800         	ldr	r0, [r0]
700a6972: 2800         	cmp	r0, #0x0
700a6974: d140         	bne	0x700a69f8 <prvCheckForValidListAndQueue+0x98> @ imm = #0x80
700a6976: e7ff         	b	0x700a6978 <prvCheckForValidListAndQueue+0x18> @ imm = #-0x2
;                 vListInitialise( &xActiveTimerList1 );
700a6978: f644 7018    	movw	r0, #0x4f18
700a697c: f2c7 0008    	movt	r0, #0x7008
700a6980: 9002         	str	r0, [sp, #0x8]
700a6982: f005 ff7d    	bl	0x700ac880 <vListInitialise> @ imm = #0x5efa
;                 vListInitialise( &xActiveTimerList2 );
700a6986: f644 702c    	movw	r0, #0x4f2c
700a698a: f2c7 0008    	movt	r0, #0x7008
700a698e: 9003         	str	r0, [sp, #0xc]
700a6990: f005 ff76    	bl	0x700ac880 <vListInitialise> @ imm = #0x5eec
700a6994: 9902         	ldr	r1, [sp, #0x8]
700a6996: 9803         	ldr	r0, [sp, #0xc]
;                 pxCurrentTimerList = &xActiveTimerList1;
700a6998: f644 72b4    	movw	r2, #0x4fb4
700a699c: f2c7 0208    	movt	r2, #0x7008
700a69a0: 6011         	str	r1, [r2]
;                 pxOverflowTimerList = &xActiveTimerList2;
700a69a2: f644 71c0    	movw	r1, #0x4fc0
700a69a6: f2c7 0108    	movt	r1, #0x7008
700a69aa: 6008         	str	r0, [r1]
;                         xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
700a69ac: 4669         	mov	r1, sp
700a69ae: 2000         	movs	r0, #0x0
700a69b0: 6008         	str	r0, [r1]
700a69b2: f644 1278    	movw	r2, #0x4978
700a69b6: f2c7 0208    	movt	r2, #0x7008
700a69ba: f241 0308    	movw	r3, #0x1008
700a69be: f2c7 0308    	movt	r3, #0x7008
700a69c2: 2110         	movs	r1, #0x10
700a69c4: 4608         	mov	r0, r1
700a69c6: f004 fd3b    	bl	0x700ab440 <xQueueGenericCreateStatic> @ imm = #0x4a76
700a69ca: 4601         	mov	r1, r0
700a69cc: f240 5024    	movw	r0, #0x524
700a69d0: f2c7 000b    	movt	r0, #0x700b
700a69d4: 6001         	str	r1, [r0]
;                         if( xTimerQueue != NULL )
700a69d6: 6800         	ldr	r0, [r0]
700a69d8: b160         	cbz	r0, 0x700a69f4 <prvCheckForValidListAndQueue+0x94> @ imm = #0x18
700a69da: e7ff         	b	0x700a69dc <prvCheckForValidListAndQueue+0x7c> @ imm = #-0x2
;                             vQueueAddToRegistry( xTimerQueue, "TmrQ" );
700a69dc: f240 5024    	movw	r0, #0x524
700a69e0: f2c7 000b    	movt	r0, #0x700b
700a69e4: 6800         	ldr	r0, [r0]
700a69e6: f240 112e    	movw	r1, #0x12e
700a69ea: f2c7 010b    	movt	r1, #0x700b
700a69ee: f004 fa97    	bl	0x700aaf20 <vQueueAddToRegistry> @ imm = #0x452e
;                         }
700a69f2: e000         	b	0x700a69f6 <prvCheckForValidListAndQueue+0x96> @ imm = #0x0
700a69f4: e7ff         	b	0x700a69f6 <prvCheckForValidListAndQueue+0x96> @ imm = #-0x2
;             }
700a69f6: e000         	b	0x700a69fa <prvCheckForValidListAndQueue+0x9a> @ imm = #0x0
700a69f8: e7ff         	b	0x700a69fa <prvCheckForValidListAndQueue+0x9a> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a69fa: f004 fe89    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x4d12
;     }
700a69fe: b004         	add	sp, #0x10
700a6a00: bd80         	pop	{r7, pc}
		...
700a6a0e: 0000         	movs	r0, r0

700a6a10 <Udma_rmAllocEvent>:
; {
700a6a10: b580         	push	{r7, lr}
700a6a12: b088         	sub	sp, #0x20
700a6a14: 9007         	str	r0, [sp, #0x1c]
700a6a16: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            globalEvent = UDMA_EVENT_INVALID;
700a6a1a: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a6a1c: 9807         	ldr	r0, [sp, #0x1c]
700a6a1e: f500 70ea    	add.w	r0, r0, #0x1d4
700a6a22: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a6a24: 9807         	ldr	r0, [sp, #0x1c]
700a6a26: f500 609f    	add.w	r0, r0, #0x4f8
700a6a2a: f04f 31ff    	mov.w	r1, #0xffffffff
700a6a2e: f001 fe5f    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x1cbe
700a6a32: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a6a34: 9005         	str	r0, [sp, #0x14]
700a6a36: e7ff         	b	0x700a6a38 <Udma_rmAllocEvent+0x28> @ imm = #-0x2
700a6a38: 9805         	ldr	r0, [sp, #0x14]
700a6a3a: 9901         	ldr	r1, [sp, #0x4]
700a6a3c: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
700a6a40: 4288         	cmp	r0, r1
700a6a42: d22d         	bhs	0x700a6aa0 <Udma_rmAllocEvent+0x90> @ imm = #0x5a
700a6a44: e7ff         	b	0x700a6a46 <Udma_rmAllocEvent+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a6a46: 9805         	ldr	r0, [sp, #0x14]
700a6a48: 0940         	lsrs	r0, r0, #0x5
700a6a4a: 9004         	str	r0, [sp, #0x10]
;         bitPos = i - (offset << 5U);
700a6a4c: 9805         	ldr	r0, [sp, #0x14]
700a6a4e: 9904         	ldr	r1, [sp, #0x10]
700a6a50: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a6a54: 9003         	str	r0, [sp, #0xc]
;         bitMask = (uint32_t) 1U << bitPos;
700a6a56: 9903         	ldr	r1, [sp, #0xc]
700a6a58: 2001         	movs	r0, #0x1
700a6a5a: 4088         	lsls	r0, r1
700a6a5c: 9002         	str	r0, [sp, #0x8]
;         if((drvHandle->globalEventFlag[offset] & bitMask) == bitMask)
700a6a5e: 9807         	ldr	r0, [sp, #0x1c]
700a6a60: 9904         	ldr	r1, [sp, #0x10]
700a6a62: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a6a66: f8d0 0424    	ldr.w	r0, [r0, #0x424]
700a6a6a: 9902         	ldr	r1, [sp, #0x8]
700a6a6c: 4008         	ands	r0, r1
700a6a6e: 4288         	cmp	r0, r1
700a6a70: d111         	bne	0x700a6a96 <Udma_rmAllocEvent+0x86> @ imm = #0x22
700a6a72: e7ff         	b	0x700a6a74 <Udma_rmAllocEvent+0x64> @ imm = #-0x2
;             drvHandle->globalEventFlag[offset] &= ~bitMask;
700a6a74: 9a02         	ldr	r2, [sp, #0x8]
700a6a76: 9807         	ldr	r0, [sp, #0x1c]
700a6a78: 9904         	ldr	r1, [sp, #0x10]
700a6a7a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a6a7e: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700a6a82: 4390         	bics	r0, r2
700a6a84: f8c1 0424    	str.w	r0, [r1, #0x424]
;             globalEvent = i + rmInitPrms->startGlobalEvent;  /* Add start offset */
700a6a88: 9805         	ldr	r0, [sp, #0x14]
700a6a8a: 9901         	ldr	r1, [sp, #0x4]
700a6a8c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a6a90: 4408         	add	r0, r1
700a6a92: 9006         	str	r0, [sp, #0x18]
;             break;
700a6a94: e004         	b	0x700a6aa0 <Udma_rmAllocEvent+0x90> @ imm = #0x8
;     }
700a6a96: e7ff         	b	0x700a6a98 <Udma_rmAllocEvent+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a6a98: 9805         	ldr	r0, [sp, #0x14]
700a6a9a: 3001         	adds	r0, #0x1
700a6a9c: 9005         	str	r0, [sp, #0x14]
700a6a9e: e7cb         	b	0x700a6a38 <Udma_rmAllocEvent+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a6aa0: 9807         	ldr	r0, [sp, #0x1c]
700a6aa2: f500 609f    	add.w	r0, r0, #0x4f8
700a6aa6: f003 f97b    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x32f6
;     return (globalEvent);
700a6aaa: 9806         	ldr	r0, [sp, #0x18]
700a6aac: b008         	add	sp, #0x20
700a6aae: bd80         	pop	{r7, pc}

700a6ab0 <Udma_rmAllocVintr>:
; {
700a6ab0: b580         	push	{r7, lr}
700a6ab2: b088         	sub	sp, #0x20
700a6ab4: 9007         	str	r0, [sp, #0x1c]
700a6ab6: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            vintrNum = UDMA_EVENT_INVALID;
700a6aba: 9002         	str	r0, [sp, #0x8]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a6abc: 9807         	ldr	r0, [sp, #0x1c]
700a6abe: f500 70ea    	add.w	r0, r0, #0x1d4
700a6ac2: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a6ac4: 9807         	ldr	r0, [sp, #0x1c]
700a6ac6: f500 609f    	add.w	r0, r0, #0x4f8
700a6aca: f04f 31ff    	mov.w	r1, #0xffffffff
700a6ace: f001 fe0f    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x1c1e
700a6ad2: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a6ad4: 9006         	str	r0, [sp, #0x18]
700a6ad6: e7ff         	b	0x700a6ad8 <Udma_rmAllocVintr+0x28> @ imm = #-0x2
700a6ad8: 9806         	ldr	r0, [sp, #0x18]
700a6ada: 9901         	ldr	r1, [sp, #0x4]
700a6adc: f8d1 10e4    	ldr.w	r1, [r1, #0xe4]
700a6ae0: 4288         	cmp	r0, r1
700a6ae2: d22d         	bhs	0x700a6b40 <Udma_rmAllocVintr+0x90> @ imm = #0x5a
700a6ae4: e7ff         	b	0x700a6ae6 <Udma_rmAllocVintr+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a6ae6: 9806         	ldr	r0, [sp, #0x18]
700a6ae8: 0940         	lsrs	r0, r0, #0x5
700a6aea: 9005         	str	r0, [sp, #0x14]
;         bitPos = i - (offset << 5U);
700a6aec: 9806         	ldr	r0, [sp, #0x18]
700a6aee: 9905         	ldr	r1, [sp, #0x14]
700a6af0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a6af4: 9004         	str	r0, [sp, #0x10]
;         bitMask = (uint32_t) 1U << bitPos;
700a6af6: 9904         	ldr	r1, [sp, #0x10]
700a6af8: 2001         	movs	r0, #0x1
700a6afa: 4088         	lsls	r0, r1
700a6afc: 9003         	str	r0, [sp, #0xc]
;         if((drvHandle->vintrFlag[offset] & bitMask) == bitMask)
700a6afe: 9807         	ldr	r0, [sp, #0x1c]
700a6b00: 9905         	ldr	r1, [sp, #0x14]
700a6b02: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a6b06: f8d0 04a4    	ldr.w	r0, [r0, #0x4a4]
700a6b0a: 9903         	ldr	r1, [sp, #0xc]
700a6b0c: 4008         	ands	r0, r1
700a6b0e: 4288         	cmp	r0, r1
700a6b10: d111         	bne	0x700a6b36 <Udma_rmAllocVintr+0x86> @ imm = #0x22
700a6b12: e7ff         	b	0x700a6b14 <Udma_rmAllocVintr+0x64> @ imm = #-0x2
;             drvHandle->vintrFlag[offset] &= ~bitMask;
700a6b14: 9a03         	ldr	r2, [sp, #0xc]
700a6b16: 9807         	ldr	r0, [sp, #0x1c]
700a6b18: 9905         	ldr	r1, [sp, #0x14]
700a6b1a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a6b1e: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700a6b22: 4390         	bics	r0, r2
700a6b24: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;             vintrNum = i + rmInitPrms->startVintr;  /* Add start offset */
700a6b28: 9806         	ldr	r0, [sp, #0x18]
700a6b2a: 9901         	ldr	r1, [sp, #0x4]
700a6b2c: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700a6b30: 4408         	add	r0, r1
700a6b32: 9002         	str	r0, [sp, #0x8]
;             break;
700a6b34: e004         	b	0x700a6b40 <Udma_rmAllocVintr+0x90> @ imm = #0x8
;     }
700a6b36: e7ff         	b	0x700a6b38 <Udma_rmAllocVintr+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a6b38: 9806         	ldr	r0, [sp, #0x18]
700a6b3a: 3001         	adds	r0, #0x1
700a6b3c: 9006         	str	r0, [sp, #0x18]
700a6b3e: e7cb         	b	0x700a6ad8 <Udma_rmAllocVintr+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a6b40: 9807         	ldr	r0, [sp, #0x1c]
700a6b42: f500 609f    	add.w	r0, r0, #0x4f8
700a6b46: f003 f92b    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x3256
;     return (vintrNum);
700a6b4a: 9802         	ldr	r0, [sp, #0x8]
700a6b4c: b008         	add	sp, #0x20
700a6b4e: bd80         	pop	{r7, pc}

700a6b50 <Sciclient_getContext>:
; {
700a6b50: b084         	sub	sp, #0x10
700a6b52: 9003         	str	r0, [sp, #0xc]
700a6b54: 9102         	str	r1, [sp, #0x8]
700a6b56: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a6b58: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700a6b5a: 9802         	ldr	r0, [sp, #0x8]
700a6b5c: 9000         	str	r0, [sp]
700a6b5e: 2805         	cmp	r0, #0x5
700a6b60: d841         	bhi	0x700a6be6 <Sciclient_getContext+0x96> @ imm = #0x82
700a6b62: 9900         	ldr	r1, [sp]
700a6b64: e8df f001    	tbb	[pc, r1]
700a6b68: 03 0d 17 21  	.word	0x21170d03
700a6b6c: 2b 35        	.short	0x352b
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6b6e: 9803         	ldr	r0, [sp, #0xc]
700a6b70: b918         	cbnz	r0, 0x700a6b7a <Sciclient_getContext+0x2a> @ imm = #0x6
700a6b72: e7ff         	b	0x700a6b74 <Sciclient_getContext+0x24> @ imm = #-0x2
700a6b74: 200e         	movs	r0, #0xe
;             retVal = SCICLIENT_CONTEXT_M4_SEC_0;
700a6b76: 9001         	str	r0, [sp, #0x4]
;         }
700a6b78: e002         	b	0x700a6b80 <Sciclient_getContext+0x30> @ imm = #0x4
700a6b7a: 2008         	movs	r0, #0x8
;             retVal = SCICLIENT_CONTEXT_M4_NONSEC_0;
700a6b7c: 9001         	str	r0, [sp, #0x4]
700a6b7e: e7ff         	b	0x700a6b80 <Sciclient_getContext+0x30> @ imm = #-0x2
;         break;
700a6b80: e032         	b	0x700a6be8 <Sciclient_getContext+0x98> @ imm = #0x64
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6b82: 9803         	ldr	r0, [sp, #0xc]
700a6b84: b918         	cbnz	r0, 0x700a6b8e <Sciclient_getContext+0x3e> @ imm = #0x6
700a6b86: e7ff         	b	0x700a6b88 <Sciclient_getContext+0x38> @ imm = #-0x2
700a6b88: 2000         	movs	r0, #0x0
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_0;
700a6b8a: 9001         	str	r0, [sp, #0x4]
;         }
700a6b8c: e002         	b	0x700a6b94 <Sciclient_getContext+0x44> @ imm = #0x4
700a6b8e: 2001         	movs	r0, #0x1
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_0;
700a6b90: 9001         	str	r0, [sp, #0x4]
700a6b92: e7ff         	b	0x700a6b94 <Sciclient_getContext+0x44> @ imm = #-0x2
;         break;
700a6b94: e028         	b	0x700a6be8 <Sciclient_getContext+0x98> @ imm = #0x50
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6b96: 9803         	ldr	r0, [sp, #0xc]
700a6b98: b918         	cbnz	r0, 0x700a6ba2 <Sciclient_getContext+0x52> @ imm = #0x6
700a6b9a: e7ff         	b	0x700a6b9c <Sciclient_getContext+0x4c> @ imm = #-0x2
700a6b9c: 2002         	movs	r0, #0x2
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_1;
700a6b9e: 9001         	str	r0, [sp, #0x4]
;         }
700a6ba0: e002         	b	0x700a6ba8 <Sciclient_getContext+0x58> @ imm = #0x4
700a6ba2: 2003         	movs	r0, #0x3
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_1;
700a6ba4: 9001         	str	r0, [sp, #0x4]
700a6ba6: e7ff         	b	0x700a6ba8 <Sciclient_getContext+0x58> @ imm = #-0x2
;         break;
700a6ba8: e01e         	b	0x700a6be8 <Sciclient_getContext+0x98> @ imm = #0x3c
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6baa: 9803         	ldr	r0, [sp, #0xc]
700a6bac: b918         	cbnz	r0, 0x700a6bb6 <Sciclient_getContext+0x66> @ imm = #0x6
700a6bae: e7ff         	b	0x700a6bb0 <Sciclient_getContext+0x60> @ imm = #-0x2
700a6bb0: 2009         	movs	r0, #0x9
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_0;
700a6bb2: 9001         	str	r0, [sp, #0x4]
;         }
700a6bb4: e002         	b	0x700a6bbc <Sciclient_getContext+0x6c> @ imm = #0x4
700a6bb6: 200a         	movs	r0, #0xa
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_0;
700a6bb8: 9001         	str	r0, [sp, #0x4]
700a6bba: e7ff         	b	0x700a6bbc <Sciclient_getContext+0x6c> @ imm = #-0x2
;         break;
700a6bbc: e014         	b	0x700a6be8 <Sciclient_getContext+0x98> @ imm = #0x28
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6bbe: 9803         	ldr	r0, [sp, #0xc]
700a6bc0: b918         	cbnz	r0, 0x700a6bca <Sciclient_getContext+0x7a> @ imm = #0x6
700a6bc2: e7ff         	b	0x700a6bc4 <Sciclient_getContext+0x74> @ imm = #-0x2
700a6bc4: 200b         	movs	r0, #0xb
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_1;
700a6bc6: 9001         	str	r0, [sp, #0x4]
;         }
700a6bc8: e002         	b	0x700a6bd0 <Sciclient_getContext+0x80> @ imm = #0x4
700a6bca: 200c         	movs	r0, #0xc
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_1;
700a6bcc: 9001         	str	r0, [sp, #0x4]
700a6bce: e7ff         	b	0x700a6bd0 <Sciclient_getContext+0x80> @ imm = #-0x2
;         break;
700a6bd0: e00a         	b	0x700a6be8 <Sciclient_getContext+0x98> @ imm = #0x14
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6bd2: 9803         	ldr	r0, [sp, #0xc]
700a6bd4: b918         	cbnz	r0, 0x700a6bde <Sciclient_getContext+0x8e> @ imm = #0x6
700a6bd6: e7ff         	b	0x700a6bd8 <Sciclient_getContext+0x88> @ imm = #-0x2
700a6bd8: 2004         	movs	r0, #0x4
;             retVal = SCICLIENT_CONTEXT_A53_SEC_0;
700a6bda: 9001         	str	r0, [sp, #0x4]
;         }
700a6bdc: e002         	b	0x700a6be4 <Sciclient_getContext+0x94> @ imm = #0x4
700a6bde: 2006         	movs	r0, #0x6
;             retVal = SCICLIENT_CONTEXT_A53_NONSEC_1;
700a6be0: 9001         	str	r0, [sp, #0x4]
700a6be2: e7ff         	b	0x700a6be4 <Sciclient_getContext+0x94> @ imm = #-0x2
;         break;
700a6be4: e000         	b	0x700a6be8 <Sciclient_getContext+0x98> @ imm = #0x0
;         break;
700a6be6: e7ff         	b	0x700a6be8 <Sciclient_getContext+0x98> @ imm = #-0x2
;     return retVal;
700a6be8: 9801         	ldr	r0, [sp, #0x4]
700a6bea: b004         	add	sp, #0x10
700a6bec: 4770         	bx	lr
700a6bee: 0000         	movs	r0, r0

700a6bf0 <Pinmux_config>:
; {
700a6bf0: b580         	push	{r7, lr}
700a6bf2: b086         	sub	sp, #0x18
700a6bf4: 9005         	str	r0, [sp, #0x14]
700a6bf6: 9104         	str	r1, [sp, #0x10]
700a6bf8: 2000         	movs	r0, #0x0
;     uint32_t            isUnlocked = 0;
700a6bfa: 9001         	str	r0, [sp, #0x4]
;     if((NULL != pinmuxCfg) && (pinmuxCfg->offset != PINMUX_END))
700a6bfc: 9805         	ldr	r0, [sp, #0x14]
700a6bfe: 2800         	cmp	r0, #0x0
700a6c00: d042         	beq	0x700a6c88 <Pinmux_config+0x98> @ imm = #0x84
700a6c02: e7ff         	b	0x700a6c04 <Pinmux_config+0x14> @ imm = #-0x2
700a6c04: 9805         	ldr	r0, [sp, #0x14]
700a6c06: f9b0 0000    	ldrsh.w	r0, [r0]
700a6c0a: 3001         	adds	r0, #0x1
700a6c0c: b3e0         	cbz	r0, 0x700a6c88 <Pinmux_config+0x98> @ imm = #0x78
700a6c0e: e7ff         	b	0x700a6c10 <Pinmux_config+0x20> @ imm = #-0x2
;         if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a6c10: 9804         	ldr	r0, [sp, #0x10]
700a6c12: b920         	cbnz	r0, 0x700a6c1e <Pinmux_config+0x2e> @ imm = #0x8
700a6c14: e7ff         	b	0x700a6c16 <Pinmux_config+0x26> @ imm = #-0x2
700a6c16: f44f 2074    	mov.w	r0, #0xf4000
;             baseAddr = CSL_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a6c1a: 9003         	str	r0, [sp, #0xc]
;         }
700a6c1c: e005         	b	0x700a6c2a <Pinmux_config+0x3a> @ imm = #0xa
700a6c1e: f244 0000    	movw	r0, #0x4000
700a6c22: f2c0 4008    	movt	r0, #0x408
;             baseAddr = CSL_MCU_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a6c26: 9003         	str	r0, [sp, #0xc]
700a6c28: e7ff         	b	0x700a6c2a <Pinmux_config+0x3a> @ imm = #-0x2
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(baseAddr);
700a6c2a: 9803         	ldr	r0, [sp, #0xc]
700a6c2c: 2100         	movs	r1, #0x0
700a6c2e: f7fd f8cf    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x2e62
700a6c32: 9003         	str	r0, [sp, #0xc]
;         if (pinmuxCfg->offset != PINMUX_END)
700a6c34: 9805         	ldr	r0, [sp, #0x14]
700a6c36: f9b0 0000    	ldrsh.w	r0, [r0]
700a6c3a: 3001         	adds	r0, #0x1
700a6c3c: b130         	cbz	r0, 0x700a6c4c <Pinmux_config+0x5c> @ imm = #0xc
700a6c3e: e7ff         	b	0x700a6c40 <Pinmux_config+0x50> @ imm = #-0x2
700a6c40: 2001         	movs	r0, #0x1
;             isUnlocked = 1;
700a6c42: 9001         	str	r0, [sp, #0x4]
;             Pinmux_unlockMMR(domainId);
700a6c44: 9804         	ldr	r0, [sp, #0x10]
700a6c46: f7fd fdb3    	bl	0x700a47b0 <Pinmux_unlockMMR> @ imm = #-0x249a
;         }
700a6c4a: e7ff         	b	0x700a6c4c <Pinmux_config+0x5c> @ imm = #-0x2
;         while( pinmuxCfg->offset != PINMUX_END )
700a6c4c: e7ff         	b	0x700a6c4e <Pinmux_config+0x5e> @ imm = #-0x2
700a6c4e: 9805         	ldr	r0, [sp, #0x14]
700a6c50: f9b0 0000    	ldrsh.w	r0, [r0]
700a6c54: 3001         	adds	r0, #0x1
700a6c56: b178         	cbz	r0, 0x700a6c78 <Pinmux_config+0x88> @ imm = #0x1e
700a6c58: e7ff         	b	0x700a6c5a <Pinmux_config+0x6a> @ imm = #-0x2
;             regAddr = (volatile uint32_t *)(baseAddr + pinmuxCfg->offset);
700a6c5a: 9803         	ldr	r0, [sp, #0xc]
700a6c5c: 9905         	ldr	r1, [sp, #0x14]
700a6c5e: f9b1 1000    	ldrsh.w	r1, [r1]
700a6c62: 4408         	add	r0, r1
700a6c64: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(regAddr, pinmuxCfg->settings);
700a6c66: 9802         	ldr	r0, [sp, #0x8]
700a6c68: 9905         	ldr	r1, [sp, #0x14]
700a6c6a: 6849         	ldr	r1, [r1, #0x4]
700a6c6c: f006 fde0    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x6bc0
;             pinmuxCfg++;
700a6c70: 9805         	ldr	r0, [sp, #0x14]
700a6c72: 3008         	adds	r0, #0x8
700a6c74: 9005         	str	r0, [sp, #0x14]
;         while( pinmuxCfg->offset != PINMUX_END )
700a6c76: e7ea         	b	0x700a6c4e <Pinmux_config+0x5e> @ imm = #-0x2c
;         if (isUnlocked)
700a6c78: 9801         	ldr	r0, [sp, #0x4]
700a6c7a: b120         	cbz	r0, 0x700a6c86 <Pinmux_config+0x96> @ imm = #0x8
700a6c7c: e7ff         	b	0x700a6c7e <Pinmux_config+0x8e> @ imm = #-0x2
;             Pinmux_lockMMR(domainId);
700a6c7e: 9804         	ldr	r0, [sp, #0x10]
700a6c80: f002 fcd6    	bl	0x700a9630 <Pinmux_lockMMR> @ imm = #0x29ac
;         }
700a6c84: e7ff         	b	0x700a6c86 <Pinmux_config+0x96> @ imm = #-0x2
;     }
700a6c86: e7ff         	b	0x700a6c88 <Pinmux_config+0x98> @ imm = #-0x2
;     return;
700a6c88: b006         	add	sp, #0x18
700a6c8a: bd80         	pop	{r7, pc}
700a6c8c: 0000         	movs	r0, r0
700a6c8e: 0000         	movs	r0, r0

700a6c90 <rtos_main_freertos>:
; {
700a6c90: b082         	sub	sp, #0x8
;    System_init();
700a6c92: f005 fd7d    	bl	0x700ac790 <System_init> @ imm = #0x5afa
;    Board_init();
700a6c96: f006 ff23    	bl	0x700adae0 <Board_init> @ imm = #0x6e46
;    Drivers_open();
700a6c9a: f004 f8e1    	bl	0x700aae60 <Drivers_open> @ imm = #0x41c2
;    Board_driversOpen();
700a6c9e: f006 feef    	bl	0x700ada80 <Board_driversOpen> @ imm = #0x6dde
;    printf("Initializing FreeRTOS system...\r\n");
700a6ca2: f64f 0107    	movw	r1, #0xf807
700a6ca6: 2001         	movs	r0, #0x1
700a6ca8: f2c7 010a    	movt	r1, #0x700a
700a6cac: f000 ffc0    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #0xf80
;    BaseType_t status = xTaskCreate(main_task, "MainTask", MAIN_TASK_STACK_SIZE, NULL, MAIN_TASK_PRI, NULL);
700a6cb0: f648 50a1    	movw	r0, #0x8da1
700a6cb4: f64f 418c    	movw	r1, #0xfc8c
700a6cb8: f2c7 000a    	movt	r0, #0x700a
700a6cbc: f2c7 010a    	movt	r1, #0x700a
700a6cc0: f04f 0c1e    	mov.w	r12, #0x1e
700a6cc4: f44f 5200    	mov.w	r2, #0x2000
700a6cc8: 2300         	movs	r3, #0x0
700a6cca: 2400         	movs	r4, #0x0
700a6ccc: e9cd c400    	strd	r12, r4, [sp]
700a6cd0: f000 fb4e    	bl	0x700a7370 <xTaskCreate> @ imm = #0x69c
;    if (status != pdPASS)
700a6cd4: 2801         	cmp	r0, #0x1
700a6cd6: d010         	beq	0x700a6cfa <rtos_main_freertos+0x6a> @ imm = #0x20
;       DebugP_assert(status == pdPASS);
700a6cd8: f64f 21cc    	movw	r1, #0xfacc
700a6cdc: f64f 3210    	movw	r2, #0xfb10
700a6ce0: f64f 440f    	movw	r4, #0xfc0f
700a6ce4: f2c7 010a    	movt	r1, #0x700a
700a6ce8: f2c7 020a    	movt	r2, #0x700a
700a6cec: f2c7 040a    	movt	r4, #0x700a
700a6cf0: 2000         	movs	r0, #0x0
700a6cf2: 2381         	movs	r3, #0x81
700a6cf4: 9400         	str	r4, [sp]
700a6cf6: f001 ff93    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x1f26
;    vTaskStartScheduler();
700a6cfa: f7fe fd19    	bl	0x700a5730 <vTaskStartScheduler> @ imm = #-0x15ce
700a6cfe: f64f 044b    	movw	r4, #0xf84b
700a6d02: f2c7 040a    	movt	r4, #0x700a
700a6d06: bf00         	nop
700a6d08: bf00         	nop
700a6d0a: bf00         	nop
700a6d0c: bf00         	nop
700a6d0e: bf00         	nop
;       printf("Scheduler returned unexpectedly\r\n");
700a6d10: 4621         	mov	r1, r4
700a6d12: f04f 0001    	mov.w	r0, #0x1
700a6d16: f000 ff8b    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #0xf16
700a6d1a: 4621         	mov	r1, r4
700a6d1c: 2001         	movs	r0, #0x1
700a6d1e: f000 ff87    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #0xf0e
700a6d22: 4621         	mov	r1, r4
700a6d24: 2001         	movs	r0, #0x1
700a6d26: f000 ff83    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #0xf06
;    for (;;)
700a6d2a: e7f1         	b	0x700a6d10 <rtos_main_freertos+0x80> @ imm = #-0x1e
700a6d2c: 0000         	movs	r0, r0
700a6d2e: 0000         	movs	r0, r0

700a6d30 <SOC_controlModuleUnlockMMR>:
; {
700a6d30: b580         	push	{r7, lr}
700a6d32: b084         	sub	sp, #0x10
700a6d34: 9003         	str	r0, [sp, #0xc]
700a6d36: 9102         	str	r1, [sp, #0x8]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700a6d38: 9803         	ldr	r0, [sp, #0xc]
700a6d3a: bb00         	cbnz	r0, 0x700a6d7e <SOC_controlModuleUnlockMMR+0x4e> @ imm = #0x40
700a6d3c: e7ff         	b	0x700a6d3e <SOC_controlModuleUnlockMMR+0xe> @ imm = #-0x2
700a6d3e: f04f 4086    	mov.w	r0, #0x43000000
700a6d42: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700a6d44: f7fd f844    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x2f78
700a6d48: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a6d4a: 9801         	ldr	r0, [sp, #0x4]
700a6d4c: 9902         	ldr	r1, [sp, #0x8]
700a6d4e: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a6d52: f241 0108    	movw	r1, #0x1008
700a6d56: 4408         	add	r0, r1
700a6d58: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6d5a: 9800         	ldr	r0, [sp]
700a6d5c: f243 4190    	movw	r1, #0x3490
700a6d60: f6c6 01ef    	movt	r1, #0x68ef
700a6d64: f006 fd74    	bl	0x700ad850 <CSL_REG32_WR_RAW> @ imm = #0x6ae8
;         kickAddr++;
700a6d68: 9800         	ldr	r0, [sp]
700a6d6a: 3004         	adds	r0, #0x4
700a6d6c: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6d6e: 9800         	ldr	r0, [sp]
700a6d70: f64b 415a    	movw	r1, #0xbc5a
700a6d74: f2cd 1172    	movt	r1, #0xd172
700a6d78: f006 fd6a    	bl	0x700ad850 <CSL_REG32_WR_RAW> @ imm = #0x6ad4
;     }
700a6d7c: e7ff         	b	0x700a6d7e <SOC_controlModuleUnlockMMR+0x4e> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700a6d7e: 9803         	ldr	r0, [sp, #0xc]
700a6d80: 2801         	cmp	r0, #0x1
700a6d82: d120         	bne	0x700a6dc6 <SOC_controlModuleUnlockMMR+0x96> @ imm = #0x40
700a6d84: e7ff         	b	0x700a6d86 <SOC_controlModuleUnlockMMR+0x56> @ imm = #-0x2
700a6d86: f04f 608a    	mov.w	r0, #0x4500000
700a6d8a: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700a6d8c: f7fd f820    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x2fc0
700a6d90: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a6d92: 9801         	ldr	r0, [sp, #0x4]
700a6d94: 9902         	ldr	r1, [sp, #0x8]
700a6d96: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a6d9a: f241 0108    	movw	r1, #0x1008
700a6d9e: 4408         	add	r0, r1
700a6da0: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6da2: 9800         	ldr	r0, [sp]
700a6da4: f243 4190    	movw	r1, #0x3490
700a6da8: f6c6 01ef    	movt	r1, #0x68ef
700a6dac: f006 fd50    	bl	0x700ad850 <CSL_REG32_WR_RAW> @ imm = #0x6aa0
;         kickAddr++;
700a6db0: 9800         	ldr	r0, [sp]
700a6db2: 3004         	adds	r0, #0x4
700a6db4: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6db6: 9800         	ldr	r0, [sp]
700a6db8: f64b 415a    	movw	r1, #0xbc5a
700a6dbc: f2cd 1172    	movt	r1, #0xd172
700a6dc0: f006 fd46    	bl	0x700ad850 <CSL_REG32_WR_RAW> @ imm = #0x6a8c
;     }
700a6dc4: e7ff         	b	0x700a6dc6 <SOC_controlModuleUnlockMMR+0x96> @ imm = #-0x2
;     return;
700a6dc6: b004         	add	sp, #0x10
700a6dc8: bd80         	pop	{r7, pc}
700a6dca: 0000         	movs	r0, r0
700a6dcc: 0000         	movs	r0, r0
700a6dce: 0000         	movs	r0, r0

700a6dd0 <Sciclient_pmGetModuleClkFreq>:
; {
700a6dd0: b580         	push	{r7, lr}
700a6dd2: b096         	sub	sp, #0x58
700a6dd4: 9015         	str	r0, [sp, #0x54]
700a6dd6: 9114         	str	r1, [sp, #0x50]
700a6dd8: 9213         	str	r2, [sp, #0x4c]
700a6dda: 9312         	str	r3, [sp, #0x48]
700a6ddc: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a6dde: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a6de0: 9815         	ldr	r0, [sp, #0x54]
700a6de2: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a6de4: 9814         	ldr	r0, [sp, #0x50]
700a6de6: 28ff         	cmp	r0, #0xff
700a6de8: d307         	blo	0x700a6dfa <Sciclient_pmGetModuleClkFreq+0x2a> @ imm = #0xe
700a6dea: e7ff         	b	0x700a6dec <Sciclient_pmGetModuleClkFreq+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a6dec: 9814         	ldr	r0, [sp, #0x50]
700a6dee: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a6df2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a6df4: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a6df8: e003         	b	0x700a6e02 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a6dfa: 9814         	ldr	r0, [sp, #0x50]
700a6dfc: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a6e00: e7ff         	b	0x700a6e02 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #-0x2
700a6e02: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_freq_resp response = {{0}};
700a6e04: 900b         	str	r0, [sp, #0x2c]
700a6e06: 900a         	str	r0, [sp, #0x28]
700a6e08: 9009         	str	r0, [sp, #0x24]
700a6e0a: 9008         	str	r0, [sp, #0x20]
700a6e0c: f44f 7187    	mov.w	r1, #0x10e
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_FREQ;
700a6e10: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a6e14: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a6e16: 9104         	str	r1, [sp, #0x10]
700a6e18: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a6e1a: 9105         	str	r1, [sp, #0x14]
700a6e1c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a6e1e: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a6e20: 9912         	ldr	r1, [sp, #0x48]
700a6e22: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a6e24: 9000         	str	r0, [sp]
700a6e26: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a6e28: 9001         	str	r0, [sp, #0x4]
700a6e2a: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a6e2c: 9002         	str	r0, [sp, #0x8]
700a6e2e: a803         	add	r0, sp, #0xc
700a6e30: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a6e32: f7f5 f825    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xafb6
700a6e36: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a6e38: 9811         	ldr	r0, [sp, #0x44]
700a6e3a: b930         	cbnz	r0, 0x700a6e4a <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #0xc
700a6e3c: e7ff         	b	0x700a6e3e <Sciclient_pmGetModuleClkFreq+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a6e3e: 9800         	ldr	r0, [sp]
700a6e40: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a6e44: 2802         	cmp	r0, #0x2
700a6e46: d004         	beq	0x700a6e52 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #0x8
700a6e48: e7ff         	b	0x700a6e4a <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #-0x2
700a6e4a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a6e4e: 9011         	str	r0, [sp, #0x44]
;     }
700a6e50: e7ff         	b	0x700a6e52 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a6e52: 9811         	ldr	r0, [sp, #0x44]
700a6e54: b930         	cbnz	r0, 0x700a6e64 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #0xc
700a6e56: e7ff         	b	0x700a6e58 <Sciclient_pmGetModuleClkFreq+0x88> @ imm = #-0x2
;         *freqHz = (uint64_t) response.freq_hz;
700a6e58: 980a         	ldr	r0, [sp, #0x28]
700a6e5a: 9a0b         	ldr	r2, [sp, #0x2c]
700a6e5c: 9913         	ldr	r1, [sp, #0x4c]
700a6e5e: 604a         	str	r2, [r1, #0x4]
700a6e60: 6008         	str	r0, [r1]
;     }
700a6e62: e7ff         	b	0x700a6e64 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #-0x2
;     return retVal;
700a6e64: 9811         	ldr	r0, [sp, #0x44]
700a6e66: b016         	add	sp, #0x58
700a6e68: bd80         	pop	{r7, pc}
700a6e6a: 0000         	movs	r0, r0
700a6e6c: 0000         	movs	r0, r0
700a6e6e: 0000         	movs	r0, r0

700a6e70 <Sciclient_pmGetModuleClkParent>:
; {
700a6e70: b580         	push	{r7, lr}
700a6e72: b096         	sub	sp, #0x58
700a6e74: 9015         	str	r0, [sp, #0x54]
700a6e76: 9114         	str	r1, [sp, #0x50]
700a6e78: 9213         	str	r2, [sp, #0x4c]
700a6e7a: 9312         	str	r3, [sp, #0x48]
700a6e7c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a6e7e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a6e80: 9815         	ldr	r0, [sp, #0x54]
700a6e82: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a6e84: 9814         	ldr	r0, [sp, #0x50]
700a6e86: 28ff         	cmp	r0, #0xff
700a6e88: d307         	blo	0x700a6e9a <Sciclient_pmGetModuleClkParent+0x2a> @ imm = #0xe
700a6e8a: e7ff         	b	0x700a6e8c <Sciclient_pmGetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a6e8c: 9814         	ldr	r0, [sp, #0x50]
700a6e8e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a6e92: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a6e94: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a6e98: e003         	b	0x700a6ea2 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a6e9a: 9814         	ldr	r0, [sp, #0x50]
700a6e9c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a6ea0: e7ff         	b	0x700a6ea2 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #-0x2
700a6ea2: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_parent_resp response = {{0}};
700a6ea4: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a6ea8: 900a         	str	r0, [sp, #0x28]
700a6eaa: 9009         	str	r0, [sp, #0x24]
700a6eac: 9008         	str	r0, [sp, #0x20]
700a6eae: f240 1103    	movw	r1, #0x103
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK_PARENT;
700a6eb2: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a6eb6: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a6eb8: 9104         	str	r1, [sp, #0x10]
700a6eba: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a6ebc: 9105         	str	r1, [sp, #0x14]
700a6ebe: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a6ec0: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a6ec2: 9912         	ldr	r1, [sp, #0x48]
700a6ec4: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a6ec6: 9000         	str	r0, [sp]
700a6ec8: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a6eca: 9001         	str	r0, [sp, #0x4]
700a6ecc: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a6ece: 9002         	str	r0, [sp, #0x8]
700a6ed0: a803         	add	r0, sp, #0xc
700a6ed2: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a6ed4: f7f4 ffd4    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xb058
700a6ed8: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a6eda: 9811         	ldr	r0, [sp, #0x44]
700a6edc: b930         	cbnz	r0, 0x700a6eec <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #0xc
700a6ede: e7ff         	b	0x700a6ee0 <Sciclient_pmGetModuleClkParent+0x70> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a6ee0: 9800         	ldr	r0, [sp]
700a6ee2: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a6ee6: 2802         	cmp	r0, #0x2
700a6ee8: d004         	beq	0x700a6ef4 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #0x8
700a6eea: e7ff         	b	0x700a6eec <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #-0x2
700a6eec: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a6ef0: 9011         	str	r0, [sp, #0x44]
;     }
700a6ef2: e7ff         	b	0x700a6ef4 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a6ef4: 9811         	ldr	r0, [sp, #0x44]
700a6ef6: b928         	cbnz	r0, 0x700a6f04 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #0xa
700a6ef8: e7ff         	b	0x700a6efa <Sciclient_pmGetModuleClkParent+0x8a> @ imm = #-0x2
;         *parent = (uint32_t) response.parent;
700a6efa: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a6efe: 9913         	ldr	r1, [sp, #0x4c]
700a6f00: 6008         	str	r0, [r1]
;     }
700a6f02: e7ff         	b	0x700a6f04 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a6f04: 9811         	ldr	r0, [sp, #0x44]
700a6f06: b016         	add	sp, #0x58
700a6f08: bd80         	pop	{r7, pc}
700a6f0a: 0000         	movs	r0, r0
700a6f0c: 0000         	movs	r0, r0
700a6f0e: 0000         	movs	r0, r0

700a6f10 <Sciclient_pmSetModuleClkParent>:
; {
700a6f10: b580         	push	{r7, lr}
700a6f12: b094         	sub	sp, #0x50
700a6f14: 9013         	str	r0, [sp, #0x4c]
700a6f16: 9112         	str	r1, [sp, #0x48]
700a6f18: 9211         	str	r2, [sp, #0x44]
700a6f1a: 9310         	str	r3, [sp, #0x40]
700a6f1c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a6f1e: 900f         	str	r0, [sp, #0x3c]
;     request.device = (uint32_t) moduleId;
700a6f20: 9813         	ldr	r0, [sp, #0x4c]
700a6f22: 900b         	str	r0, [sp, #0x2c]
;     if (clockId >= 255U)
700a6f24: 9812         	ldr	r0, [sp, #0x48]
700a6f26: 28ff         	cmp	r0, #0xff
700a6f28: d307         	blo	0x700a6f3a <Sciclient_pmSetModuleClkParent+0x2a> @ imm = #0xe
700a6f2a: e7ff         	b	0x700a6f2c <Sciclient_pmSetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a6f2c: 9812         	ldr	r0, [sp, #0x48]
700a6f2e: f8cd 0032    	str.w	r0, [sp, #0x32]
700a6f32: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a6f34: f88d 0030    	strb.w	r0, [sp, #0x30]
;     }
700a6f38: e003         	b	0x700a6f42 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a6f3a: 9812         	ldr	r0, [sp, #0x48]
700a6f3c: f88d 0030    	strb.w	r0, [sp, #0x30]
700a6f40: e7ff         	b	0x700a6f42 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #-0x2
;     if (parent >= 255U)
700a6f42: 9811         	ldr	r0, [sp, #0x44]
700a6f44: 28ff         	cmp	r0, #0xff
700a6f46: d307         	blo	0x700a6f58 <Sciclient_pmSetModuleClkParent+0x48> @ imm = #0xe
700a6f48: e7ff         	b	0x700a6f4a <Sciclient_pmSetModuleClkParent+0x3a> @ imm = #-0x2
;         request.parent32 = parent;
700a6f4a: 9811         	ldr	r0, [sp, #0x44]
700a6f4c: f8cd 0036    	str.w	r0, [sp, #0x36]
700a6f50: 20ff         	movs	r0, #0xff
;         request.parent   = (uint8_t) 255U;
700a6f52: f88d 0031    	strb.w	r0, [sp, #0x31]
;     }
700a6f56: e003         	b	0x700a6f60 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #0x6
;         request.parent = (uint8_t) parent;
700a6f58: 9811         	ldr	r0, [sp, #0x44]
700a6f5a: f88d 0031    	strb.w	r0, [sp, #0x31]
700a6f5e: e7ff         	b	0x700a6f60 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #-0x2
700a6f60: f44f 7081    	mov.w	r0, #0x102
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK_PARENT;
700a6f64: f8ad 0010    	strh.w	r0, [sp, #0x10]
700a6f68: 2002         	movs	r0, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a6f6a: 9005         	str	r0, [sp, #0x14]
700a6f6c: a809         	add	r0, sp, #0x24
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a6f6e: 9006         	str	r0, [sp, #0x18]
700a6f70: 2016         	movs	r0, #0x16
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a6f72: 9007         	str	r0, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a6f74: 9810         	ldr	r0, [sp, #0x40]
700a6f76: 9008         	str	r0, [sp, #0x20]
700a6f78: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a6f7a: 9001         	str	r0, [sp, #0x4]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a6f7c: 9002         	str	r0, [sp, #0x8]
;     respParam.respPayloadSize = (uint32_t) 0;
700a6f7e: 9003         	str	r0, [sp, #0xc]
700a6f80: a804         	add	r0, sp, #0x10
700a6f82: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a6f84: f7f4 ff7c    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xb108
700a6f88: 900f         	str	r0, [sp, #0x3c]
;     if((retVal != SystemP_SUCCESS) ||
700a6f8a: 980f         	ldr	r0, [sp, #0x3c]
700a6f8c: b930         	cbnz	r0, 0x700a6f9c <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #0xc
700a6f8e: e7ff         	b	0x700a6f90 <Sciclient_pmSetModuleClkParent+0x80> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a6f90: 9801         	ldr	r0, [sp, #0x4]
700a6f92: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a6f96: 2802         	cmp	r0, #0x2
700a6f98: d004         	beq	0x700a6fa4 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #0x8
700a6f9a: e7ff         	b	0x700a6f9c <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #-0x2
700a6f9c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a6fa0: 900f         	str	r0, [sp, #0x3c]
;     }
700a6fa2: e7ff         	b	0x700a6fa4 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a6fa4: 980f         	ldr	r0, [sp, #0x3c]
700a6fa6: b014         	add	sp, #0x50
700a6fa8: bd80         	pop	{r7, pc}
700a6faa: 0000         	movs	r0, r0
700a6fac: 0000         	movs	r0, r0
700a6fae: 0000         	movs	r0, r0

700a6fb0 <Sciclient_rmIrOutpIsFree>:
; {
700a6fb0: b580         	push	{r7, lr}
700a6fb2: b086         	sub	sp, #0x18
700a6fb4: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a6fb8: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a6fbc: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a6fbe: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIrInst *inst = NULL;
700a6fc0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a6fc2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a6fc6: f002 fd2b    	bl	0x700a9a20 <Sciclient_rmIrGetInst> @ imm = #0x2a56
700a6fca: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a6fcc: 9803         	ldr	r0, [sp, #0xc]
700a6fce: b920         	cbnz	r0, 0x700a6fda <Sciclient_rmIrOutpIsFree+0x2a> @ imm = #0x8
700a6fd0: e7ff         	b	0x700a6fd2 <Sciclient_rmIrOutpIsFree+0x22> @ imm = #-0x2
700a6fd2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a6fd6: 9004         	str	r0, [sp, #0x10]
;     } else {
700a6fd8: e00b         	b	0x700a6ff2 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #0x16
;         if (outp >= inst->n_outp) {
700a6fda: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a6fde: 9903         	ldr	r1, [sp, #0xc]
700a6fe0: 8949         	ldrh	r1, [r1, #0xa]
700a6fe2: 4288         	cmp	r0, r1
700a6fe4: db04         	blt	0x700a6ff0 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #0x8
700a6fe6: e7ff         	b	0x700a6fe8 <Sciclient_rmIrOutpIsFree+0x38> @ imm = #-0x2
700a6fe8: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a6fec: 9004         	str	r0, [sp, #0x10]
;         }
700a6fee: e7ff         	b	0x700a6ff0 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #-0x2
700a6ff0: e7ff         	b	0x700a6ff2 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a6ff2: 9804         	ldr	r0, [sp, #0x10]
700a6ff4: bb30         	cbnz	r0, 0x700a7044 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #0x4c
700a6ff6: e7ff         	b	0x700a6ff8 <Sciclient_rmIrOutpIsFree+0x48> @ imm = #-0x2
;         int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, outp);
700a6ff8: 9803         	ldr	r0, [sp, #0xc]
700a6ffa: 6840         	ldr	r0, [r0, #0x4]
700a6ffc: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a7000: f005 fcce    	bl	0x700ac9a0 <Sciclient_getIrAddr> @ imm = #0x599c
700a7004: 9002         	str	r0, [sp, #0x8]
;         extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a7006: 9802         	ldr	r0, [sp, #0x8]
700a7008: f240 31ff    	movw	r1, #0x3ff
700a700c: 2200         	movs	r2, #0x0
700a700e: f005 ff97    	bl	0x700acf40 <CSL_REG32_FEXT_RAW> @ imm = #0x5f2e
700a7012: f8ad 0006    	strh.w	r0, [sp, #0x6]
;         if (((extracted_inp != 0u) &&
700a7016: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a701a: b138         	cbz	r0, 0x700a702c <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #0xe
700a701c: e7ff         	b	0x700a701e <Sciclient_rmIrOutpIsFree+0x6e> @ imm = #-0x2
;              (Sciclient_rmIrOutpRomMapped(inst, outp) == false)) ||
700a701e: 9803         	ldr	r0, [sp, #0xc]
700a7020: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a7024: f7ff f9e4    	bl	0x700a63f0 <Sciclient_rmIrOutpRomMapped> @ imm = #-0xc38
700a7028: b138         	cbz	r0, 0x700a703a <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #0xe
700a702a: e7ff         	b	0x700a702c <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #-0x2
;             (outp == inst->inp0_mapping)) {
700a702c: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a7030: 9903         	ldr	r1, [sp, #0xc]
700a7032: 8989         	ldrh	r1, [r1, #0xc]
;         if (((extracted_inp != 0u) &&
700a7034: 4288         	cmp	r0, r1
700a7036: d104         	bne	0x700a7042 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #0x8
700a7038: e7ff         	b	0x700a703a <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #-0x2
700a703a: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a703e: 9004         	str	r0, [sp, #0x10]
;         }
700a7040: e7ff         	b	0x700a7042 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #-0x2
;     }
700a7042: e7ff         	b	0x700a7044 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #-0x2
;     return r;
700a7044: 9804         	ldr	r0, [sp, #0x10]
700a7046: b006         	add	sp, #0x18
700a7048: bd80         	pop	{r7, pc}
700a704a: 0000         	movs	r0, r0
700a704c: 0000         	movs	r0, r0
700a704e: 0000         	movs	r0, r0

700a7050 <Udma_ringQueueRaw>:
; {
700a7050: b580         	push	{r7, lr}
700a7052: b088         	sub	sp, #0x20
700a7054: 9007         	str	r0, [sp, #0x1c]
700a7056: 9305         	str	r3, [sp, #0x14]
700a7058: 9204         	str	r2, [sp, #0x10]
700a705a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a705c: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a705e: 9807         	ldr	r0, [sp, #0x1c]
700a7060: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a7062: 9800         	ldr	r0, [sp]
700a7064: b180         	cbz	r0, 0x700a7088 <Udma_ringQueueRaw+0x38> @ imm = #0x20
700a7066: e7ff         	b	0x700a7068 <Udma_ringQueueRaw+0x18> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a7068: 9800         	ldr	r0, [sp]
700a706a: 6d80         	ldr	r0, [r0, #0x58]
700a706c: f64a 31cd    	movw	r1, #0xabcd
700a7070: f6ca 31dc    	movt	r1, #0xabdc
700a7074: 4288         	cmp	r0, r1
700a7076: d107         	bne	0x700a7088 <Udma_ringQueueRaw+0x38> @ imm = #0xe
700a7078: e7ff         	b	0x700a707a <Udma_ringQueueRaw+0x2a> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a707a: 9800         	ldr	r0, [sp]
700a707c: 8880         	ldrh	r0, [r0, #0x4]
700a707e: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a7082: 4288         	cmp	r0, r1
700a7084: d104         	bne	0x700a7090 <Udma_ringQueueRaw+0x40> @ imm = #0x8
700a7086: e7ff         	b	0x700a7088 <Udma_ringQueueRaw+0x38> @ imm = #-0x2
700a7088: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a708c: 9003         	str	r0, [sp, #0xc]
;     }
700a708e: e7ff         	b	0x700a7090 <Udma_ringQueueRaw+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7090: 9803         	ldr	r0, [sp, #0xc]
700a7092: b9a8         	cbnz	r0, 0x700a70c0 <Udma_ringQueueRaw+0x70> @ imm = #0x2a
700a7094: e7ff         	b	0x700a7096 <Udma_ringQueueRaw+0x46> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a7096: 9800         	ldr	r0, [sp]
700a7098: 6800         	ldr	r0, [r0]
700a709a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a709c: 9801         	ldr	r0, [sp, #0x4]
700a709e: b150         	cbz	r0, 0x700a70b6 <Udma_ringQueueRaw+0x66> @ imm = #0x14
700a70a0: e7ff         	b	0x700a70a2 <Udma_ringQueueRaw+0x52> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a70a2: 9801         	ldr	r0, [sp, #0x4]
700a70a4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a70a8: f64a 31cd    	movw	r1, #0xabcd
700a70ac: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a70b0: 4288         	cmp	r0, r1
700a70b2: d004         	beq	0x700a70be <Udma_ringQueueRaw+0x6e> @ imm = #0x8
700a70b4: e7ff         	b	0x700a70b6 <Udma_ringQueueRaw+0x66> @ imm = #-0x2
700a70b6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a70ba: 9003         	str	r0, [sp, #0xc]
;         }
700a70bc: e7ff         	b	0x700a70be <Udma_ringQueueRaw+0x6e> @ imm = #-0x2
;     }
700a70be: e7ff         	b	0x700a70c0 <Udma_ringQueueRaw+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a70c0: 9803         	ldr	r0, [sp, #0xc]
700a70c2: b978         	cbnz	r0, 0x700a70e4 <Udma_ringQueueRaw+0x94> @ imm = #0x1e
700a70c4: e7ff         	b	0x700a70c6 <Udma_ringQueueRaw+0x76> @ imm = #-0x2
;         cookie = HwiP_disable();
700a70c6: f007 ead4    	blx	0x700ae670 <HwiP_disable> @ imm = #0x75a8
700a70ca: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringQueueRaw(drvHandle, ringHandleInt, phyDescMem);
700a70cc: 9801         	ldr	r0, [sp, #0x4]
700a70ce: f8d0 c594    	ldr.w	r12, [r0, #0x594]
700a70d2: 9900         	ldr	r1, [sp]
700a70d4: 9a04         	ldr	r2, [sp, #0x10]
700a70d6: 9b05         	ldr	r3, [sp, #0x14]
700a70d8: 47e0         	blx	r12
700a70da: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a70dc: 9802         	ldr	r0, [sp, #0x8]
700a70de: f007 eae8    	blx	0x700ae6b0 <HwiP_restore> @ imm = #0x75d0
;     }
700a70e2: e7ff         	b	0x700a70e4 <Udma_ringQueueRaw+0x94> @ imm = #-0x2
;     return (retVal);
700a70e4: 9803         	ldr	r0, [sp, #0xc]
700a70e6: b008         	add	sp, #0x20
700a70e8: bd80         	pop	{r7, pc}
700a70ea: 0000         	movs	r0, r0
700a70ec: 0000         	movs	r0, r0
700a70ee: 0000         	movs	r0, r0

700a70f0 <xTaskCheckForTimeOut>:
;                                 TickType_t *const pxTicksToWait) {
700a70f0: b580         	push	{r7, lr}
700a70f2: b086         	sub	sp, #0x18
700a70f4: 9005         	str	r0, [sp, #0x14]
700a70f6: 9104         	str	r1, [sp, #0x10]
;   taskENTER_CRITICAL();
700a70f8: f005 fa4a    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x5494
;     const TickType_t xConstTickCount = xTickCount;
700a70fc: f240 5020    	movw	r0, #0x520
700a7100: f2c7 000b    	movt	r0, #0x700b
700a7104: 6800         	ldr	r0, [r0]
700a7106: 9002         	str	r0, [sp, #0x8]
;         xConstTickCount - pxTimeOut->xTimeOnEntering;
700a7108: 9802         	ldr	r0, [sp, #0x8]
700a710a: 9905         	ldr	r1, [sp, #0x14]
700a710c: 6849         	ldr	r1, [r1, #0x4]
700a710e: 1a40         	subs	r0, r0, r1
;     const TickType_t xElapsedTime =
700a7110: 9001         	str	r0, [sp, #0x4]
;         if (*pxTicksToWait == portMAX_DELAY) {
700a7112: 9804         	ldr	r0, [sp, #0x10]
700a7114: 6800         	ldr	r0, [r0]
700a7116: 3001         	adds	r0, #0x1
700a7118: b918         	cbnz	r0, 0x700a7122 <xTaskCheckForTimeOut+0x32> @ imm = #0x6
700a711a: e7ff         	b	0x700a711c <xTaskCheckForTimeOut+0x2c> @ imm = #-0x2
700a711c: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a711e: 9003         	str	r0, [sp, #0xc]
;     } else
700a7120: e02e         	b	0x700a7180 <xTaskCheckForTimeOut+0x90> @ imm = #0x5c
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a7122: f240 5014    	movw	r0, #0x514
700a7126: f2c7 000b    	movt	r0, #0x700b
700a712a: 6800         	ldr	r0, [r0]
700a712c: 9905         	ldr	r1, [sp, #0x14]
700a712e: 6809         	ldr	r1, [r1]
700a7130: 4288         	cmp	r0, r1
700a7132: d00c         	beq	0x700a714e <xTaskCheckForTimeOut+0x5e> @ imm = #0x18
700a7134: e7ff         	b	0x700a7136 <xTaskCheckForTimeOut+0x46> @ imm = #-0x2
;             (xConstTickCount >=
700a7136: 9802         	ldr	r0, [sp, #0x8]
;              pxTimeOut
700a7138: 9905         	ldr	r1, [sp, #0x14]
;                  ->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to
700a713a: 6849         	ldr	r1, [r1, #0x4]
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a713c: 4288         	cmp	r0, r1
700a713e: d306         	blo	0x700a714e <xTaskCheckForTimeOut+0x5e> @ imm = #0xc
700a7140: e7ff         	b	0x700a7142 <xTaskCheckForTimeOut+0x52> @ imm = #-0x2
700a7142: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a7144: 9003         	str	r0, [sp, #0xc]
;       *pxTicksToWait = (TickType_t)0;
700a7146: 9904         	ldr	r1, [sp, #0x10]
700a7148: 2000         	movs	r0, #0x0
700a714a: 6008         	str	r0, [r1]
;     } else if (xElapsedTime <
700a714c: e017         	b	0x700a717e <xTaskCheckForTimeOut+0x8e> @ imm = #0x2e
700a714e: 9801         	ldr	r0, [sp, #0x4]
;                *pxTicksToWait) /*lint !e961 Explicit casting is only redundant
700a7150: 9904         	ldr	r1, [sp, #0x10]
700a7152: 6809         	ldr	r1, [r1]
;     } else if (xElapsedTime <
700a7154: 4288         	cmp	r0, r1
700a7156: d20b         	bhs	0x700a7170 <xTaskCheckForTimeOut+0x80> @ imm = #0x16
700a7158: e7ff         	b	0x700a715a <xTaskCheckForTimeOut+0x6a> @ imm = #-0x2
;       *pxTicksToWait -= xElapsedTime;
700a715a: 9a01         	ldr	r2, [sp, #0x4]
700a715c: 9904         	ldr	r1, [sp, #0x10]
700a715e: 6808         	ldr	r0, [r1]
700a7160: 1a80         	subs	r0, r0, r2
700a7162: 6008         	str	r0, [r1]
;       vTaskInternalSetTimeOutState(pxTimeOut);
700a7164: 9805         	ldr	r0, [sp, #0x14]
700a7166: f005 ff5b    	bl	0x700ad020 <vTaskInternalSetTimeOutState> @ imm = #0x5eb6
700a716a: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a716c: 9003         	str	r0, [sp, #0xc]
;     } else {
700a716e: e005         	b	0x700a717c <xTaskCheckForTimeOut+0x8c> @ imm = #0xa
;       *pxTicksToWait = (TickType_t)0;
700a7170: 9904         	ldr	r1, [sp, #0x10]
700a7172: 2000         	movs	r0, #0x0
700a7174: 6008         	str	r0, [r1]
700a7176: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a7178: 9003         	str	r0, [sp, #0xc]
700a717a: e7ff         	b	0x700a717c <xTaskCheckForTimeOut+0x8c> @ imm = #-0x2
700a717c: e7ff         	b	0x700a717e <xTaskCheckForTimeOut+0x8e> @ imm = #-0x2
700a717e: e7ff         	b	0x700a7180 <xTaskCheckForTimeOut+0x90> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a7180: f004 fac6    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x458c
;   return xReturn;
700a7184: 9803         	ldr	r0, [sp, #0xc]
700a7186: b006         	add	sp, #0x18
700a7188: bd80         	pop	{r7, pc}
700a718a: 0000         	movs	r0, r0
700a718c: 0000         	movs	r0, r0
700a718e: 0000         	movs	r0, r0

700a7190 <CSL_bcdmaChanOpSetChanEnable>:
; {
700a7190: b580         	push	{r7, lr}
700a7192: b086         	sub	sp, #0x18
700a7194: 9005         	str	r0, [sp, #0x14]
700a7196: 9104         	str	r1, [sp, #0x10]
700a7198: 9203         	str	r2, [sp, #0xc]
700a719a: f88d 300b    	strb.w	r3, [sp, #0xb]
700a719e: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a71a0: 9001         	str	r0, [sp, #0x4]
;     switch( chanType )
700a71a2: 9804         	ldr	r0, [sp, #0x10]
700a71a4: 9000         	str	r0, [sp]
700a71a6: b140         	cbz	r0, 0x700a71ba <CSL_bcdmaChanOpSetChanEnable+0x2a> @ imm = #0x10
700a71a8: e7ff         	b	0x700a71aa <CSL_bcdmaChanOpSetChanEnable+0x1a> @ imm = #-0x2
700a71aa: 9800         	ldr	r0, [sp]
700a71ac: 2801         	cmp	r0, #0x1
700a71ae: d014         	beq	0x700a71da <CSL_bcdmaChanOpSetChanEnable+0x4a> @ imm = #0x28
700a71b0: e7ff         	b	0x700a71b2 <CSL_bcdmaChanOpSetChanEnable+0x22> @ imm = #-0x2
700a71b2: 9800         	ldr	r0, [sp]
700a71b4: 2802         	cmp	r0, #0x2
700a71b6: d020         	beq	0x700a71fa <CSL_bcdmaChanOpSetChanEnable+0x6a> @ imm = #0x40
700a71b8: e02f         	b	0x700a721a <CSL_bcdmaChanOpSetChanEnable+0x8a> @ imm = #0x5e
;             CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_BCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a71ba: 9805         	ldr	r0, [sp, #0x14]
700a71bc: 6880         	ldr	r0, [r0, #0x8]
700a71be: 9903         	ldr	r1, [sp, #0xc]
700a71c0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a71c4: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a71c8: f001 0101    	and	r1, r1, #0x1
700a71cc: 2900         	cmp	r1, #0x0
700a71ce: bf18         	it	ne
700a71d0: f04f 4100    	movne.w	r1, #0x80000000
700a71d4: f006 fb1c    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x6638
;             break;
700a71d8: e023         	b	0x700a7222 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x46
;             CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a71da: 9805         	ldr	r0, [sp, #0x14]
700a71dc: 6900         	ldr	r0, [r0, #0x10]
700a71de: 9903         	ldr	r1, [sp, #0xc]
700a71e0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a71e4: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a71e8: f001 0101    	and	r1, r1, #0x1
700a71ec: 2900         	cmp	r1, #0x0
700a71ee: bf18         	it	ne
700a71f0: f04f 4100    	movne.w	r1, #0x80000000
700a71f4: f006 fb0c    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x6618
;             break;
700a71f8: e013         	b	0x700a7222 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x26
;             CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_RXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a71fa: 9805         	ldr	r0, [sp, #0x14]
700a71fc: 6980         	ldr	r0, [r0, #0x18]
700a71fe: 9903         	ldr	r1, [sp, #0xc]
700a7200: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a7204: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a7208: f001 0101    	and	r1, r1, #0x1
700a720c: 2900         	cmp	r1, #0x0
700a720e: bf18         	it	ne
700a7210: f04f 4100    	movne.w	r1, #0x80000000
700a7214: f006 fafc    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x65f8
;             break;
700a7218: e003         	b	0x700a7222 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x6
700a721a: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700a721e: 9001         	str	r0, [sp, #0x4]
;             break;
700a7220: e7ff         	b	0x700a7222 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #-0x2
;     return retVal;
700a7222: 9801         	ldr	r0, [sp, #0x4]
700a7224: b006         	add	sp, #0x18
700a7226: bd80         	pop	{r7, pc}
		...

700a7230 <Sciclient_pmModuleGetClkStatus>:
; {
700a7230: b580         	push	{r7, lr}
700a7232: b096         	sub	sp, #0x58
700a7234: 9015         	str	r0, [sp, #0x54]
700a7236: 9114         	str	r1, [sp, #0x50]
700a7238: 9213         	str	r2, [sp, #0x4c]
700a723a: 9312         	str	r3, [sp, #0x48]
700a723c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a723e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a7240: 9815         	ldr	r0, [sp, #0x54]
700a7242: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a7244: 9814         	ldr	r0, [sp, #0x50]
700a7246: 28ff         	cmp	r0, #0xff
700a7248: d307         	blo	0x700a725a <Sciclient_pmModuleGetClkStatus+0x2a> @ imm = #0xe
700a724a: e7ff         	b	0x700a724c <Sciclient_pmModuleGetClkStatus+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a724c: 9814         	ldr	r0, [sp, #0x50]
700a724e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a7252: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a7254: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a7258: e003         	b	0x700a7262 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a725a: 9814         	ldr	r0, [sp, #0x50]
700a725c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a7260: e7ff         	b	0x700a7262 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #-0x2
700a7262: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_resp response = {{0}};
700a7264: f8ad 002c    	strh.w	r0, [sp, #0x2c]
700a7268: 900a         	str	r0, [sp, #0x28]
700a726a: 9009         	str	r0, [sp, #0x24]
700a726c: f240 1101    	movw	r1, #0x101
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK;
700a7270: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a7274: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a7276: 9105         	str	r1, [sp, #0x14]
700a7278: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a727a: 9106         	str	r1, [sp, #0x18]
700a727c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a727e: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a7280: 9912         	ldr	r1, [sp, #0x48]
700a7282: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a7284: 9001         	str	r0, [sp, #0x4]
700a7286: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a7288: 9002         	str	r0, [sp, #0x8]
700a728a: 200a         	movs	r0, #0xa
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a728c: 9003         	str	r0, [sp, #0xc]
700a728e: a804         	add	r0, sp, #0x10
700a7290: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a7292: f7f4 fdf5    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xb416
700a7296: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a7298: 9811         	ldr	r0, [sp, #0x44]
700a729a: b930         	cbnz	r0, 0x700a72aa <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #0xc
700a729c: e7ff         	b	0x700a729e <Sciclient_pmModuleGetClkStatus+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a729e: 9801         	ldr	r0, [sp, #0x4]
700a72a0: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a72a4: 2802         	cmp	r0, #0x2
700a72a6: d004         	beq	0x700a72b2 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #0x8
700a72a8: e7ff         	b	0x700a72aa <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #-0x2
700a72aa: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a72ae: 9011         	str	r0, [sp, #0x44]
;     }
700a72b0: e7ff         	b	0x700a72b2 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a72b2: 9811         	ldr	r0, [sp, #0x44]
700a72b4: b928         	cbnz	r0, 0x700a72c2 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #0xa
700a72b6: e7ff         	b	0x700a72b8 <Sciclient_pmModuleGetClkStatus+0x88> @ imm = #-0x2
;         *state = (uint32_t) response.current_state;
700a72b8: f89d 002d    	ldrb.w	r0, [sp, #0x2d]
700a72bc: 9913         	ldr	r1, [sp, #0x4c]
700a72be: 6008         	str	r0, [r1]
;     }
700a72c0: e7ff         	b	0x700a72c2 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #-0x2
;     return retVal;
700a72c2: 9811         	ldr	r0, [sp, #0x44]
700a72c4: b016         	add	sp, #0x58
700a72c6: bd80         	pop	{r7, pc}
		...

700a72d0 <xQueueReceiveFromISR>:
; {
700a72d0: b580         	push	{r7, lr}
700a72d2: b088         	sub	sp, #0x20
700a72d4: 9007         	str	r0, [sp, #0x1c]
700a72d6: 9106         	str	r1, [sp, #0x18]
700a72d8: 9205         	str	r2, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a72da: 9807         	ldr	r0, [sp, #0x1c]
700a72dc: 9002         	str	r0, [sp, #0x8]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a72de: f007 e9c8    	blx	0x700ae670 <HwiP_disable> @ imm = #0x7390
700a72e2: 9003         	str	r0, [sp, #0xc]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a72e4: 9802         	ldr	r0, [sp, #0x8]
700a72e6: 6b80         	ldr	r0, [r0, #0x38]
700a72e8: 9001         	str	r0, [sp, #0x4]
;         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a72ea: 9801         	ldr	r0, [sp, #0x4]
700a72ec: b398         	cbz	r0, 0x700a7356 <xQueueReceiveFromISR+0x86> @ imm = #0x66
700a72ee: e7ff         	b	0x700a72f0 <xQueueReceiveFromISR+0x20> @ imm = #-0x2
;             const int8_t cRxLock = pxQueue->cRxLock;
700a72f0: 9802         	ldr	r0, [sp, #0x8]
700a72f2: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a72f6: f88d 0003    	strb.w	r0, [sp, #0x3]
;             prvCopyDataFromQueue( pxQueue, pvBuffer );
700a72fa: 9802         	ldr	r0, [sp, #0x8]
700a72fc: 9906         	ldr	r1, [sp, #0x18]
700a72fe: f004 fb47    	bl	0x700ab990 <prvCopyDataFromQueue> @ imm = #0x468e
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a7302: 9801         	ldr	r0, [sp, #0x4]
700a7304: 3801         	subs	r0, #0x1
700a7306: 9902         	ldr	r1, [sp, #0x8]
700a7308: 6388         	str	r0, [r1, #0x38]
;             if( cRxLock == queueUNLOCKED )
700a730a: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a730e: 3001         	adds	r0, #0x1
700a7310: b9b8         	cbnz	r0, 0x700a7342 <xQueueReceiveFromISR+0x72> @ imm = #0x2e
700a7312: e7ff         	b	0x700a7314 <xQueueReceiveFromISR+0x44> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a7314: 9802         	ldr	r0, [sp, #0x8]
700a7316: 6900         	ldr	r0, [r0, #0x10]
700a7318: b188         	cbz	r0, 0x700a733e <xQueueReceiveFromISR+0x6e> @ imm = #0x22
700a731a: e7ff         	b	0x700a731c <xQueueReceiveFromISR+0x4c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a731c: 9802         	ldr	r0, [sp, #0x8]
700a731e: 3010         	adds	r0, #0x10
700a7320: f7fe ffb6    	bl	0x700a6290 <xTaskRemoveFromEventList> @ imm = #-0x1094
700a7324: b148         	cbz	r0, 0x700a733a <xQueueReceiveFromISR+0x6a> @ imm = #0x12
700a7326: e7ff         	b	0x700a7328 <xQueueReceiveFromISR+0x58> @ imm = #-0x2
;                         if( pxHigherPriorityTaskWoken != NULL )
700a7328: 9805         	ldr	r0, [sp, #0x14]
700a732a: b120         	cbz	r0, 0x700a7336 <xQueueReceiveFromISR+0x66> @ imm = #0x8
700a732c: e7ff         	b	0x700a732e <xQueueReceiveFromISR+0x5e> @ imm = #-0x2
;                             *pxHigherPriorityTaskWoken = pdTRUE;
700a732e: 9905         	ldr	r1, [sp, #0x14]
700a7330: 2001         	movs	r0, #0x1
700a7332: 6008         	str	r0, [r1]
;                         }
700a7334: e000         	b	0x700a7338 <xQueueReceiveFromISR+0x68> @ imm = #0x0
700a7336: e7ff         	b	0x700a7338 <xQueueReceiveFromISR+0x68> @ imm = #-0x2
;                     }
700a7338: e000         	b	0x700a733c <xQueueReceiveFromISR+0x6c> @ imm = #0x0
700a733a: e7ff         	b	0x700a733c <xQueueReceiveFromISR+0x6c> @ imm = #-0x2
;                 }
700a733c: e000         	b	0x700a7340 <xQueueReceiveFromISR+0x70> @ imm = #0x0
700a733e: e7ff         	b	0x700a7340 <xQueueReceiveFromISR+0x70> @ imm = #-0x2
;             }
700a7340: e006         	b	0x700a7350 <xQueueReceiveFromISR+0x80> @ imm = #0xc
;                 pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
700a7342: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a7346: 3001         	adds	r0, #0x1
700a7348: 9902         	ldr	r1, [sp, #0x8]
700a734a: f881 0044    	strb.w	r0, [r1, #0x44]
700a734e: e7ff         	b	0x700a7350 <xQueueReceiveFromISR+0x80> @ imm = #-0x2
700a7350: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a7352: 9004         	str	r0, [sp, #0x10]
;         }
700a7354: e002         	b	0x700a735c <xQueueReceiveFromISR+0x8c> @ imm = #0x4
700a7356: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700a7358: 9004         	str	r0, [sp, #0x10]
700a735a: e7ff         	b	0x700a735c <xQueueReceiveFromISR+0x8c> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a735c: 9803         	ldr	r0, [sp, #0xc]
700a735e: f007 e9a8    	blx	0x700ae6b0 <HwiP_restore> @ imm = #0x7350
;     return xReturn;
700a7362: 9804         	ldr	r0, [sp, #0x10]
700a7364: b008         	add	sp, #0x20
700a7366: bd80         	pop	{r7, pc}
		...

700a7370 <xTaskCreate>:
;     UBaseType_t uxPriority, TaskHandle_t *const pxCreatedTask) {
700a7370: b570         	push	{r4, r5, r6, lr}
700a7372: b08c         	sub	sp, #0x30
700a7374: f8dd c044    	ldr.w	r12, [sp, #0x44]
700a7378: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a737c: 900b         	str	r0, [sp, #0x2c]
700a737e: 910a         	str	r1, [sp, #0x28]
700a7380: 9209         	str	r2, [sp, #0x24]
700a7382: 9308         	str	r3, [sp, #0x20]
;         (((size_t)usStackDepth) *
700a7384: 9809         	ldr	r0, [sp, #0x24]
700a7386: 0080         	lsls	r0, r0, #0x2
;     pxStack = (StackType_t *)pvPortMalloc(
700a7388: f005 ffca    	bl	0x700ad320 <pvPortMalloc> @ imm = #0x5f94
700a738c: 9005         	str	r0, [sp, #0x14]
;     if (pxStack != NULL) {
700a738e: 9805         	ldr	r0, [sp, #0x14]
700a7390: b180         	cbz	r0, 0x700a73b4 <xTaskCreate+0x44> @ imm = #0x20
700a7392: e7ff         	b	0x700a7394 <xTaskCreate+0x24> @ imm = #-0x2
700a7394: 208c         	movs	r0, #0x8c
;       pxNewTCB = (TCB_t *)pvPortMalloc(
700a7396: f005 ffc3    	bl	0x700ad320 <pvPortMalloc> @ imm = #0x5f86
700a739a: 9007         	str	r0, [sp, #0x1c]
;       if (pxNewTCB != NULL) {
700a739c: 9807         	ldr	r0, [sp, #0x1c]
700a739e: b120         	cbz	r0, 0x700a73aa <xTaskCreate+0x3a> @ imm = #0x8
700a73a0: e7ff         	b	0x700a73a2 <xTaskCreate+0x32> @ imm = #-0x2
;         pxNewTCB->pxStack = pxStack;
700a73a2: 9805         	ldr	r0, [sp, #0x14]
700a73a4: 9907         	ldr	r1, [sp, #0x1c]
700a73a6: 6308         	str	r0, [r1, #0x30]
;       } else {
700a73a8: e003         	b	0x700a73b2 <xTaskCreate+0x42> @ imm = #0x6
;         vPortFree(pxStack);
700a73aa: 9805         	ldr	r0, [sp, #0x14]
700a73ac: f005 fed8    	bl	0x700ad160 <vPortFree>  @ imm = #0x5db0
700a73b0: e7ff         	b	0x700a73b2 <xTaskCreate+0x42> @ imm = #-0x2
;     } else {
700a73b2: e002         	b	0x700a73ba <xTaskCreate+0x4a> @ imm = #0x4
700a73b4: 2000         	movs	r0, #0x0
;       pxNewTCB = NULL;
700a73b6: 9007         	str	r0, [sp, #0x1c]
700a73b8: e7ff         	b	0x700a73ba <xTaskCreate+0x4a> @ imm = #-0x2
;   if (pxNewTCB != NULL) {
700a73ba: 9807         	ldr	r0, [sp, #0x1c]
700a73bc: b1e8         	cbz	r0, 0x700a73fa <xTaskCreate+0x8a> @ imm = #0x3a
700a73be: e7ff         	b	0x700a73c0 <xTaskCreate+0x50> @ imm = #-0x2
;       pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
700a73c0: 9807         	ldr	r0, [sp, #0x1c]
700a73c2: 2600         	movs	r6, #0x0
700a73c4: f880 6086    	strb.w	r6, [r0, #0x86]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a73c8: 980b         	ldr	r0, [sp, #0x2c]
700a73ca: 990a         	ldr	r1, [sp, #0x28]
700a73cc: 9a09         	ldr	r2, [sp, #0x24]
;                          pvParameters, uxPriority, pxCreatedTask, pxNewTCB,
700a73ce: 9b08         	ldr	r3, [sp, #0x20]
700a73d0: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a73d4: 9c11         	ldr	r4, [sp, #0x44]
700a73d6: 9d07         	ldr	r5, [sp, #0x1c]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a73d8: 46ee         	mov	lr, sp
700a73da: f8ce 600c    	str.w	r6, [lr, #0xc]
700a73de: f8ce 5008    	str.w	r5, [lr, #0x8]
700a73e2: f8ce 4004    	str.w	r4, [lr, #0x4]
700a73e6: f8ce c000    	str.w	r12, [lr]
700a73ea: f7fb fc81    	bl	0x700a2cf0 <prvInitialiseNewTask> @ imm = #-0x46fe
;     prvAddNewTaskToReadyList(pxNewTCB);
700a73ee: 9807         	ldr	r0, [sp, #0x1c]
700a73f0: f7fc f9ee    	bl	0x700a37d0 <prvAddNewTaskToReadyList> @ imm = #-0x3c24
700a73f4: 2001         	movs	r0, #0x1
;     xReturn = pdPASS;
700a73f6: 9006         	str	r0, [sp, #0x18]
;   } else {
700a73f8: e003         	b	0x700a7402 <xTaskCreate+0x92> @ imm = #0x6
700a73fa: f04f 30ff    	mov.w	r0, #0xffffffff
;     xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
700a73fe: 9006         	str	r0, [sp, #0x18]
700a7400: e7ff         	b	0x700a7402 <xTaskCreate+0x92> @ imm = #-0x2
;   return xReturn;
700a7402: 9806         	ldr	r0, [sp, #0x18]
700a7404: b00c         	add	sp, #0x30
700a7406: bd70         	pop	{r4, r5, r6, pc}
		...

700a7410 <PMU_profileStart>:
; int32_t PMU_profileStart(const char *name) {
700a7410: b580         	push	{r7, lr}
700a7412: b088         	sub	sp, #0x20
700a7414: 9006         	str	r0, [sp, #0x18]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a7416: f243 0080    	movw	r0, #0x3080
700a741a: f2c7 0008    	movt	r0, #0x7008
700a741e: 6800         	ldr	r0, [r0]
700a7420: 2840         	cmp	r0, #0x40
700a7422: d304         	blo	0x700a742e <PMU_profileStart+0x1e> @ imm = #0x8
700a7424: e7ff         	b	0x700a7426 <PMU_profileStart+0x16> @ imm = #-0x2
700a7426: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a742a: 9007         	str	r0, [sp, #0x1c]
700a742c: e038         	b	0x700a74a0 <PMU_profileStart+0x90> @ imm = #0x70
;   uint32_t i = gProfileObject.logIndex;
700a742e: f243 0280    	movw	r2, #0x3080
700a7432: f2c7 0208    	movt	r2, #0x7008
700a7436: 6810         	ldr	r0, [r2]
700a7438: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a743a: 6890         	ldr	r0, [r2, #0x8]
700a743c: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a743e: 6850         	ldr	r0, [r2, #0x4]
700a7440: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a7442: 9805         	ldr	r0, [sp, #0x14]
700a7444: 2134         	movs	r1, #0x34
700a7446: fb00 2001    	mla	r0, r0, r1, r2
700a744a: 300c         	adds	r0, #0xc
700a744c: 9001         	str	r0, [sp, #0x4]
;   p->name = name;
700a744e: 9806         	ldr	r0, [sp, #0x18]
700a7450: 9901         	ldr	r1, [sp, #0x4]
700a7452: 6308         	str	r0, [r1, #0x30]
;   PMU_resetCounters();
700a7454: f006 faac    	bl	0x700ad9b0 <PMU_resetCounters> @ imm = #0x6558
;   if (bCCnt == TRUE) {
700a7458: 9802         	ldr	r0, [sp, #0x8]
700a745a: 2801         	cmp	r0, #0x1
700a745c: d106         	bne	0x700a746c <PMU_profileStart+0x5c> @ imm = #0xc
700a745e: e7ff         	b	0x700a7460 <PMU_profileStart+0x50> @ imm = #-0x2
700a7460: 201f         	movs	r0, #0x1f
;         CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a7462: f7f9 e82c    	blx	0x700a04bc <CSL_armR5PmuReadCntr> @ imm = #-0x6fa8
;     p->cycleCount.value =
700a7466: 9901         	ldr	r1, [sp, #0x4]
700a7468: 62c8         	str	r0, [r1, #0x2c]
;   }
700a746a: e7ff         	b	0x700a746c <PMU_profileStart+0x5c> @ imm = #-0x2
700a746c: 2000         	movs	r0, #0x0
;   for (j = 0; j < numEvents; j++) {
700a746e: 9004         	str	r0, [sp, #0x10]
700a7470: e7ff         	b	0x700a7472 <PMU_profileStart+0x62> @ imm = #-0x2
700a7472: 9804         	ldr	r0, [sp, #0x10]
700a7474: 9903         	ldr	r1, [sp, #0xc]
700a7476: 4288         	cmp	r0, r1
700a7478: d20f         	bhs	0x700a749a <PMU_profileStart+0x8a> @ imm = #0x1e
700a747a: e7ff         	b	0x700a747c <PMU_profileStart+0x6c> @ imm = #-0x2
;     p->events[j].value = CSL_armR5PmuReadCntr(j);
700a747c: 9804         	ldr	r0, [sp, #0x10]
700a747e: f7f9 e81e    	blx	0x700a04bc <CSL_armR5PmuReadCntr> @ imm = #-0x6fc4
700a7482: 9901         	ldr	r1, [sp, #0x4]
700a7484: 9a04         	ldr	r2, [sp, #0x10]
700a7486: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a748a: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a748e: 6088         	str	r0, [r1, #0x8]
;   }
700a7490: e7ff         	b	0x700a7492 <PMU_profileStart+0x82> @ imm = #-0x2
;   for (j = 0; j < numEvents; j++) {
700a7492: 9804         	ldr	r0, [sp, #0x10]
700a7494: 3001         	adds	r0, #0x1
700a7496: 9004         	str	r0, [sp, #0x10]
700a7498: e7eb         	b	0x700a7472 <PMU_profileStart+0x62> @ imm = #-0x2a
700a749a: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
700a749c: 9007         	str	r0, [sp, #0x1c]
700a749e: e7ff         	b	0x700a74a0 <PMU_profileStart+0x90> @ imm = #-0x2
; }
700a74a0: 9807         	ldr	r0, [sp, #0x1c]
700a74a2: b008         	add	sp, #0x20
700a74a4: bd80         	pop	{r7, pc}
		...
700a74ae: 0000         	movs	r0, r0

700a74b0 <Sciclient_init>:
; {
700a74b0: b580         	push	{r7, lr}
700a74b2: b086         	sub	sp, #0x18
700a74b4: 9005         	str	r0, [sp, #0x14]
700a74b6: 2100         	movs	r1, #0x0
;     int32_t   status = SystemP_SUCCESS;
700a74b8: 9101         	str	r1, [sp, #0x4]
700a74ba: 9104         	str	r1, [sp, #0x10]
;         = (CSL_sec_proxyRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRegs);
700a74bc: f240 30c8    	movw	r0, #0x3c8
700a74c0: f2c7 000b    	movt	r0, #0x700b
700a74c4: 9002         	str	r0, [sp, #0x8]
700a74c6: 6800         	ldr	r0, [r0]
700a74c8: f7fc fc82    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x36fc
700a74cc: 9901         	ldr	r1, [sp, #0x4]
700a74ce: 4602         	mov	r2, r0
700a74d0: 9802         	ldr	r0, [sp, #0x8]
700a74d2: 6002         	str	r2, [r0]
;         = (CSL_sec_proxy_scfgRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyScfgRegs);
700a74d4: 6840         	ldr	r0, [r0, #0x4]
700a74d6: f7fc fc7b    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x370a
700a74da: 9901         	ldr	r1, [sp, #0x4]
700a74dc: 4602         	mov	r2, r0
700a74de: 9802         	ldr	r0, [sp, #0x8]
700a74e0: 6042         	str	r2, [r0, #0x4]
;         = (CSL_sec_proxy_rtRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRtRegs);
700a74e2: 6880         	ldr	r0, [r0, #0x8]
700a74e4: f7fc fc74    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x3718
700a74e8: 9902         	ldr	r1, [sp, #0x8]
700a74ea: 6088         	str	r0, [r1, #0x8]
;         = (uint64_t)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.proxyTargetAddr);
700a74ec: 6908         	ldr	r0, [r1, #0x10]
700a74ee: 6949         	ldr	r1, [r1, #0x14]
700a74f0: f7fc fc6e    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x3724
700a74f4: 9a02         	ldr	r2, [sp, #0x8]
700a74f6: 4601         	mov	r1, r0
700a74f8: 9801         	ldr	r0, [sp, #0x4]
700a74fa: 6150         	str	r0, [r2, #0x14]
700a74fc: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.currSeqId = 0;
700a74fe: f240 4138    	movw	r1, #0x438
700a7502: f2c7 010b    	movt	r1, #0x700b
700a7506: 9103         	str	r1, [sp, #0xc]
700a7508: 6008         	str	r0, [r1]
;     gSciclientHandle.coreId = coreId;
700a750a: 9805         	ldr	r0, [sp, #0x14]
700a750c: 6048         	str	r0, [r1, #0x4]
;     gSciclientHandle.devIdCore = Sciclient_getDevId(coreId);
700a750e: 9805         	ldr	r0, [sp, #0x14]
700a7510: f003 fef6    	bl	0x700ab300 <Sciclient_getDevId> @ imm = #0x3dec
700a7514: 9a03         	ldr	r2, [sp, #0xc]
700a7516: 4601         	mov	r1, r0
700a7518: 9801         	ldr	r0, [sp, #0x4]
700a751a: 6091         	str	r1, [r2, #0x8]
;     gSciclientHandle.secureContextId = Sciclient_getContext(SCICLIENT_SECURE_CONTEXT, coreId);
700a751c: 9905         	ldr	r1, [sp, #0x14]
700a751e: f7ff fb17    	bl	0x700a6b50 <Sciclient_getContext> @ imm = #-0x9d2
700a7522: 9903         	ldr	r1, [sp, #0xc]
700a7524: 60c8         	str	r0, [r1, #0xc]
;     gSciclientHandle.nonSecureContextId = Sciclient_getContext(SCICLIENT_NON_SECURE_CONTEXT, coreId);
700a7526: 9905         	ldr	r1, [sp, #0x14]
700a7528: 2001         	movs	r0, #0x1
700a752a: f7ff fb11    	bl	0x700a6b50 <Sciclient_getContext> @ imm = #-0x9de
700a752e: 9a03         	ldr	r2, [sp, #0xc]
700a7530: 4601         	mov	r1, r0
700a7532: 9802         	ldr	r0, [sp, #0x8]
700a7534: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
700a7536: f005 f8cb    	bl	0x700ac6d0 <CSL_secProxyGetMaxMsgSize> @ imm = #0x5196
700a753a: 9903         	ldr	r1, [sp, #0xc]
700a753c: 3804         	subs	r0, #0x4
700a753e: 6148         	str	r0, [r1, #0x14]
;     return status;
700a7540: 9804         	ldr	r0, [sp, #0x10]
700a7542: b006         	add	sp, #0x18
700a7544: bd80         	pop	{r7, pc}
		...
700a754e: 0000         	movs	r0, r0

700a7550 <UART_subConfigTCRTLRModeEn>:
; {
700a7550: b580         	push	{r7, lr}
700a7552: b088         	sub	sp, #0x20
700a7554: 9007         	str	r0, [sp, #0x1c]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a7556: 9807         	ldr	r0, [sp, #0x1c]
700a7558: 21bf         	movs	r1, #0xbf
700a755a: 9101         	str	r1, [sp, #0x4]
700a755c: f003 f898    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x3130
700a7560: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a7562: 9807         	ldr	r0, [sp, #0x1c]
700a7564: 3008         	adds	r0, #0x8
700a7566: 2110         	movs	r1, #0x10
700a7568: 9102         	str	r1, [sp, #0x8]
700a756a: 2204         	movs	r2, #0x4
700a756c: 9203         	str	r2, [sp, #0xc]
700a756e: f005 fdc7    	bl	0x700ad100 <HW_RD_FIELD32_RAW> @ imm = #0x5b8e
700a7572: 9902         	ldr	r1, [sp, #0x8]
700a7574: 9a03         	ldr	r2, [sp, #0xc]
700a7576: 9006         	str	r0, [sp, #0x18]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a7578: 9807         	ldr	r0, [sp, #0x1c]
700a757a: 3008         	adds	r0, #0x8
700a757c: 2301         	movs	r3, #0x1
700a757e: 9300         	str	r3, [sp]
700a7580: f004 ffa6    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x4f4c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a7584: 9807         	ldr	r0, [sp, #0x1c]
700a7586: 300c         	adds	r0, #0xc
700a7588: 9904         	ldr	r1, [sp, #0x10]
700a758a: f006 f9a1    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x6342
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a758e: 9807         	ldr	r0, [sp, #0x1c]
700a7590: 2180         	movs	r1, #0x80
700a7592: f003 f87d    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x30fa
700a7596: 9004         	str	r0, [sp, #0x10]
;     tcrTlrValue = HW_RD_REG32(baseAddr + UART_MCR) & UART_MCR_TCR_TLR_MASK;
700a7598: 9807         	ldr	r0, [sp, #0x1c]
700a759a: 3010         	adds	r0, #0x10
700a759c: f006 f990    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x6320
700a75a0: 9b00         	ldr	r3, [sp]
700a75a2: f000 0040    	and	r0, r0, #0x40
700a75a6: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR,
700a75a8: 9807         	ldr	r0, [sp, #0x1c]
700a75aa: 3010         	adds	r0, #0x10
700a75ac: 2140         	movs	r1, #0x40
700a75ae: 2206         	movs	r2, #0x6
700a75b0: f004 ff8e    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x4f1c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a75b4: 9807         	ldr	r0, [sp, #0x1c]
700a75b6: 300c         	adds	r0, #0xc
700a75b8: 9904         	ldr	r1, [sp, #0x10]
700a75ba: f006 f989    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x6312
700a75be: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a75c0: 9807         	ldr	r0, [sp, #0x1c]
700a75c2: f003 f865    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x30ca
700a75c6: 9902         	ldr	r1, [sp, #0x8]
700a75c8: 9a03         	ldr	r2, [sp, #0xc]
700a75ca: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a75cc: 9807         	ldr	r0, [sp, #0x1c]
700a75ce: 3008         	adds	r0, #0x8
700a75d0: 9b06         	ldr	r3, [sp, #0x18]
700a75d2: f004 ff7d    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x4efa
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a75d6: 9807         	ldr	r0, [sp, #0x1c]
700a75d8: 300c         	adds	r0, #0xc
700a75da: 9904         	ldr	r1, [sp, #0x10]
700a75dc: f006 f978    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x62f0
;     return tcrTlrValue;
700a75e0: 9805         	ldr	r0, [sp, #0x14]
700a75e2: b008         	add	sp, #0x20
700a75e4: bd80         	pop	{r7, pc}
		...
700a75ee: 0000         	movs	r0, r0

700a75f0 <UART_udmaIsrRx>:
; {
700a75f0: b580         	push	{r7, lr}
700a75f2: b08a         	sub	sp, #0x28
700a75f4: 9009         	str	r0, [sp, #0x24]
700a75f6: 9108         	str	r1, [sp, #0x20]
700a75f8: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a75fa: 9807         	ldr	r0, [sp, #0x1c]
700a75fc: 2800         	cmp	r0, #0x0
700a75fe: d040         	beq	0x700a7682 <UART_udmaIsrRx+0x92> @ imm = #0x80
700a7600: e7ff         	b	0x700a7602 <UART_udmaIsrRx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a7602: 9807         	ldr	r0, [sp, #0x1c]
700a7604: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a7606: 9800         	ldr	r0, [sp]
700a7608: 6840         	ldr	r0, [r0, #0x4]
700a760a: 6cc0         	ldr	r0, [r0, #0x4c]
700a760c: 9001         	str	r0, [sp, #0x4]
;         rxChHandle  = udmaChCfg->rxChHandle;
700a760e: 9801         	ldr	r0, [sp, #0x4]
700a7610: 6880         	ldr	r0, [r0, #0x8]
700a7612: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a7614: 9808         	ldr	r0, [sp, #0x20]
700a7616: 2801         	cmp	r0, #0x1
700a7618: d12e         	bne	0x700a7678 <UART_udmaIsrRx+0x88> @ imm = #0x5c
700a761a: e7ff         	b	0x700a761c <UART_udmaIsrRx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->rxHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a761c: 9901         	ldr	r1, [sp, #0x4]
700a761e: 6988         	ldr	r0, [r1, #0x18]
700a7620: 69c9         	ldr	r1, [r1, #0x1c]
700a7622: 220a         	movs	r2, #0xa
700a7624: f007 fab4    	bl	0x700aeb90 <CacheP_inv> @ imm = #0x7568
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a7628: 9802         	ldr	r0, [sp, #0x8]
700a762a: f001 fcb9    	bl	0x700a8fa0 <Udma_chGetCqRingHandle> @ imm = #0x1972
700a762e: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a7630: f000 f8ce    	bl	0x700a77d0 <Udma_ringDequeueRaw> @ imm = #0x19c
700a7634: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a7636: 9806         	ldr	r0, [sp, #0x18]
700a7638: b988         	cbnz	r0, 0x700a765e <UART_udmaIsrRx+0x6e> @ imm = #0x22
700a763a: e7ff         	b	0x700a763c <UART_udmaIsrRx+0x4c> @ imm = #-0x2
700a763c: 9804         	ldr	r0, [sp, #0x10]
700a763e: 9905         	ldr	r1, [sp, #0x14]
700a7640: 4308         	orrs	r0, r1
700a7642: b160         	cbz	r0, 0x700a765e <UART_udmaIsrRx+0x6e> @ imm = #0x18
700a7644: e7ff         	b	0x700a7646 <UART_udmaIsrRx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a7646: 9804         	ldr	r0, [sp, #0x10]
700a7648: 9003         	str	r0, [sp, #0xc]
;                 hUart->readTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a764a: 9803         	ldr	r0, [sp, #0xc]
700a764c: 6800         	ldr	r0, [r0]
700a764e: f36f 509f    	bfc	r0, #22, #10
700a7652: 9900         	ldr	r1, [sp]
700a7654: 62c8         	str	r0, [r1, #0x2c]
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a7656: 9900         	ldr	r1, [sp]
700a7658: 2000         	movs	r0, #0x0
700a765a: 6348         	str	r0, [r1, #0x34]
;             }
700a765c: e003         	b	0x700a7666 <UART_udmaIsrRx+0x76> @ imm = #0x6
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a765e: 9900         	ldr	r1, [sp]
700a7660: 200a         	movs	r0, #0xa
700a7662: 6348         	str	r0, [r1, #0x34]
700a7664: e7ff         	b	0x700a7666 <UART_udmaIsrRx+0x76> @ imm = #-0x2
;             hUart->hUartInit->readCompleteCallbackFxn(hUart);
700a7666: 9800         	ldr	r0, [sp]
700a7668: 6841         	ldr	r1, [r0, #0x4]
700a766a: 6dc9         	ldr	r1, [r1, #0x5c]
700a766c: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a766e: 9800         	ldr	r0, [sp]
700a7670: 3028         	adds	r0, #0x28
700a7672: f005 fdd5    	bl	0x700ad220 <UART_lld_Transaction_deInit> @ imm = #0x5baa
;         }
700a7676: e003         	b	0x700a7680 <UART_udmaIsrRx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a7678: 9900         	ldr	r1, [sp]
700a767a: 200a         	movs	r0, #0xa
700a767c: 6488         	str	r0, [r1, #0x48]
700a767e: e7ff         	b	0x700a7680 <UART_udmaIsrRx+0x90> @ imm = #-0x2
;     }
700a7680: e7ff         	b	0x700a7682 <UART_udmaIsrRx+0x92> @ imm = #-0x2
;     return;
700a7682: b00a         	add	sp, #0x28
700a7684: bd80         	pop	{r7, pc}
		...
700a768e: 0000         	movs	r0, r0

700a7690 <UART_udmaIsrTx>:
; {
700a7690: b580         	push	{r7, lr}
700a7692: b08a         	sub	sp, #0x28
700a7694: 9009         	str	r0, [sp, #0x24]
700a7696: 9108         	str	r1, [sp, #0x20]
700a7698: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a769a: 9807         	ldr	r0, [sp, #0x1c]
700a769c: 2800         	cmp	r0, #0x0
700a769e: d040         	beq	0x700a7722 <UART_udmaIsrTx+0x92> @ imm = #0x80
700a76a0: e7ff         	b	0x700a76a2 <UART_udmaIsrTx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a76a2: 9807         	ldr	r0, [sp, #0x1c]
700a76a4: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a76a6: 9800         	ldr	r0, [sp]
700a76a8: 6840         	ldr	r0, [r0, #0x4]
700a76aa: 6cc0         	ldr	r0, [r0, #0x4c]
700a76ac: 9001         	str	r0, [sp, #0x4]
;         txChHandle  = udmaChCfg->txChHandle;
700a76ae: 9801         	ldr	r0, [sp, #0x4]
700a76b0: 6840         	ldr	r0, [r0, #0x4]
700a76b2: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a76b4: 9808         	ldr	r0, [sp, #0x20]
700a76b6: 2801         	cmp	r0, #0x1
700a76b8: d12e         	bne	0x700a7718 <UART_udmaIsrTx+0x88> @ imm = #0x5c
700a76ba: e7ff         	b	0x700a76bc <UART_udmaIsrTx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->txHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a76bc: 9901         	ldr	r1, [sp, #0x4]
700a76be: 6948         	ldr	r0, [r1, #0x14]
700a76c0: 69c9         	ldr	r1, [r1, #0x1c]
700a76c2: 220a         	movs	r2, #0xa
700a76c4: f007 fa64    	bl	0x700aeb90 <CacheP_inv> @ imm = #0x74c8
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a76c8: 9802         	ldr	r0, [sp, #0x8]
700a76ca: f001 fc69    	bl	0x700a8fa0 <Udma_chGetCqRingHandle> @ imm = #0x18d2
700a76ce: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a76d0: f000 f87e    	bl	0x700a77d0 <Udma_ringDequeueRaw> @ imm = #0xfc
700a76d4: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a76d6: 9806         	ldr	r0, [sp, #0x18]
700a76d8: b988         	cbnz	r0, 0x700a76fe <UART_udmaIsrTx+0x6e> @ imm = #0x22
700a76da: e7ff         	b	0x700a76dc <UART_udmaIsrTx+0x4c> @ imm = #-0x2
700a76dc: 9804         	ldr	r0, [sp, #0x10]
700a76de: 9905         	ldr	r1, [sp, #0x14]
700a76e0: 4308         	orrs	r0, r1
700a76e2: b160         	cbz	r0, 0x700a76fe <UART_udmaIsrTx+0x6e> @ imm = #0x18
700a76e4: e7ff         	b	0x700a76e6 <UART_udmaIsrTx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a76e6: 9804         	ldr	r0, [sp, #0x10]
700a76e8: 9003         	str	r0, [sp, #0xc]
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a76ea: 9900         	ldr	r1, [sp]
700a76ec: 2000         	movs	r0, #0x0
700a76ee: 6488         	str	r0, [r1, #0x48]
;                 hUart->writeTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a76f0: 9803         	ldr	r0, [sp, #0xc]
700a76f2: 6800         	ldr	r0, [r0]
700a76f4: f36f 509f    	bfc	r0, #22, #10
700a76f8: 9900         	ldr	r1, [sp]
700a76fa: 6408         	str	r0, [r1, #0x40]
;             }
700a76fc: e003         	b	0x700a7706 <UART_udmaIsrTx+0x76> @ imm = #0x6
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a76fe: 9900         	ldr	r1, [sp]
700a7700: 200a         	movs	r0, #0xa
700a7702: 6488         	str	r0, [r1, #0x48]
700a7704: e7ff         	b	0x700a7706 <UART_udmaIsrTx+0x76> @ imm = #-0x2
;             hUart->hUartInit->writeCompleteCallbackFxn(hUart);
700a7706: 9800         	ldr	r0, [sp]
700a7708: 6841         	ldr	r1, [r0, #0x4]
700a770a: 6e09         	ldr	r1, [r1, #0x60]
700a770c: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a770e: 9800         	ldr	r0, [sp]
700a7710: 303c         	adds	r0, #0x3c
700a7712: f005 fd85    	bl	0x700ad220 <UART_lld_Transaction_deInit> @ imm = #0x5b0a
;         }
700a7716: e003         	b	0x700a7720 <UART_udmaIsrTx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a7718: 9900         	ldr	r1, [sp]
700a771a: 200a         	movs	r0, #0xa
700a771c: 6488         	str	r0, [r1, #0x48]
700a771e: e7ff         	b	0x700a7720 <UART_udmaIsrTx+0x90> @ imm = #-0x2
;     }
700a7720: e7ff         	b	0x700a7722 <UART_udmaIsrTx+0x92> @ imm = #-0x2
;     return;
700a7722: b00a         	add	sp, #0x28
700a7724: bd80         	pop	{r7, pc}
		...
700a772e: 0000         	movs	r0, r0

700a7730 <UdmaFlowPrms_init>:
; {
700a7730: b084         	sub	sp, #0x10
700a7732: 9003         	str	r0, [sp, #0xc]
700a7734: 9102         	str	r1, [sp, #0x8]
;     if(NULL_PTR != flowPrms)
700a7736: 9803         	ldr	r0, [sp, #0xc]
700a7738: 2800         	cmp	r0, #0x0
700a773a: d042         	beq	0x700a77c2 <UdmaFlowPrms_init+0x92> @ imm = #0x84
700a773c: e7ff         	b	0x700a773e <UdmaFlowPrms_init+0xe> @ imm = #-0x2
;         flowPrms->rxChHandle    = (Udma_ChHandle) NULL_PTR;
700a773e: 9803         	ldr	r0, [sp, #0xc]
700a7740: 2100         	movs	r1, #0x0
700a7742: 9100         	str	r1, [sp]
700a7744: 6001         	str	r1, [r0]
;         flowPrms->einfoPresent  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;
700a7746: 9803         	ldr	r0, [sp, #0xc]
700a7748: 7101         	strb	r1, [r0, #0x4]
;         flowPrms->psInfoPresent = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;
700a774a: 9803         	ldr	r0, [sp, #0xc]
700a774c: 7141         	strb	r1, [r0, #0x5]
;         flowPrms->errorHandling = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;
700a774e: 9a03         	ldr	r2, [sp, #0xc]
700a7750: 2001         	movs	r0, #0x1
700a7752: 7190         	strb	r0, [r2, #0x6]
;         flowPrms->descType      = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DESC_HOST;
700a7754: 9803         	ldr	r0, [sp, #0xc]
700a7756: 71c1         	strb	r1, [r0, #0x7]
;         flowPrms->psLocation    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PS_END_PD;
700a7758: 9803         	ldr	r0, [sp, #0xc]
700a775a: 7201         	strb	r1, [r0, #0x8]
;         flowPrms->sopOffset     = 0U;
700a775c: 9803         	ldr	r0, [sp, #0xc]
700a775e: 8141         	strh	r1, [r0, #0xa]
;         flowPrms->defaultRxCQ   = UDMA_RING_INVALID;
700a7760: 9a03         	ldr	r2, [sp, #0xc]
700a7762: f64f 70ff    	movw	r0, #0xffff
700a7766: 9001         	str	r0, [sp, #0x4]
700a7768: 8190         	strh	r0, [r2, #0xc]
;         flowPrms->srcTagLo      = 0U;
700a776a: 9a03         	ldr	r2, [sp, #0xc]
700a776c: 73d1         	strb	r1, [r2, #0xf]
;         flowPrms->srcTagLoSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_SRC_TAG;
700a776e: 9b03         	ldr	r3, [sp, #0xc]
700a7770: 2204         	movs	r2, #0x4
700a7772: 745a         	strb	r2, [r3, #0x11]
;         flowPrms->srcTagHi      = 0U;
700a7774: 9b03         	ldr	r3, [sp, #0xc]
700a7776: 7399         	strb	r1, [r3, #0xe]
;         flowPrms->srcTagHiSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_FLOW_ID;
700a7778: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700a777c: 2302         	movs	r3, #0x2
700a777e: f88c 3010    	strb.w	r3, [r12, #0x10]
;         flowPrms->destTagLo     = 0U;
700a7782: 9b03         	ldr	r3, [sp, #0xc]
700a7784: 74d9         	strb	r1, [r3, #0x13]
;         flowPrms->destTagLoSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_LO;
700a7786: 9b03         	ldr	r3, [sp, #0xc]
700a7788: 755a         	strb	r2, [r3, #0x15]
;         flowPrms->destTagHi     = 0U;
700a778a: 9a03         	ldr	r2, [sp, #0xc]
700a778c: 7491         	strb	r1, [r2, #0x12]
;         flowPrms->destTagHiSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_HI;
700a778e: 9b03         	ldr	r3, [sp, #0xc]
700a7790: 2205         	movs	r2, #0x5
700a7792: 751a         	strb	r2, [r3, #0x14]
;         flowPrms->sizeThreshEn  = 0U;
700a7794: 9a03         	ldr	r2, [sp, #0xc]
700a7796: 7591         	strb	r1, [r2, #0x16]
;         flowPrms->fdq0Sz0Qnum   = UDMA_RING_INVALID;
700a7798: 9a03         	ldr	r2, [sp, #0xc]
700a779a: 8310         	strh	r0, [r2, #0x18]
;         flowPrms->fdq1Qnum      = UDMA_RING_INVALID;
700a779c: 9a03         	ldr	r2, [sp, #0xc]
700a779e: 8350         	strh	r0, [r2, #0x1a]
;         flowPrms->fdq2Qnum      = UDMA_RING_INVALID;
700a77a0: 9a03         	ldr	r2, [sp, #0xc]
700a77a2: 8390         	strh	r0, [r2, #0x1c]
;         flowPrms->fdq3Qnum      = UDMA_RING_INVALID;
700a77a4: 9a03         	ldr	r2, [sp, #0xc]
700a77a6: 83d0         	strh	r0, [r2, #0x1e]
;         flowPrms->sizeThresh0   = 0U;
700a77a8: 9a03         	ldr	r2, [sp, #0xc]
700a77aa: 8411         	strh	r1, [r2, #0x20]
;         flowPrms->sizeThresh1   = 0U;
700a77ac: 9a03         	ldr	r2, [sp, #0xc]
700a77ae: 8451         	strh	r1, [r2, #0x22]
;         flowPrms->sizeThresh2   = 0U;
700a77b0: 9a03         	ldr	r2, [sp, #0xc]
700a77b2: 8491         	strh	r1, [r2, #0x24]
;         flowPrms->fdq0Sz1Qnum   = UDMA_RING_INVALID;
700a77b4: 9903         	ldr	r1, [sp, #0xc]
700a77b6: 84c8         	strh	r0, [r1, #0x26]
;         flowPrms->fdq0Sz2Qnum   = UDMA_RING_INVALID;
700a77b8: 9903         	ldr	r1, [sp, #0xc]
700a77ba: 8508         	strh	r0, [r1, #0x28]
;         flowPrms->fdq0Sz3Qnum   = UDMA_RING_INVALID;
700a77bc: 9903         	ldr	r1, [sp, #0xc]
700a77be: 8548         	strh	r0, [r1, #0x2a]
;     }
700a77c0: e7ff         	b	0x700a77c2 <UdmaFlowPrms_init+0x92> @ imm = #-0x2
;     return;
700a77c2: b004         	add	sp, #0x10
700a77c4: 4770         	bx	lr
		...
700a77ce: 0000         	movs	r0, r0

700a77d0 <Udma_ringDequeueRaw>:
; {
700a77d0: b580         	push	{r7, lr}
700a77d2: b086         	sub	sp, #0x18
700a77d4: 9005         	str	r0, [sp, #0x14]
700a77d6: 9104         	str	r1, [sp, #0x10]
700a77d8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a77da: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a77dc: 9805         	ldr	r0, [sp, #0x14]
700a77de: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a77e0: 9800         	ldr	r0, [sp]
700a77e2: b180         	cbz	r0, 0x700a7806 <Udma_ringDequeueRaw+0x36> @ imm = #0x20
700a77e4: e7ff         	b	0x700a77e6 <Udma_ringDequeueRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a77e6: 9800         	ldr	r0, [sp]
700a77e8: 6d80         	ldr	r0, [r0, #0x58]
700a77ea: f64a 31cd    	movw	r1, #0xabcd
700a77ee: f6ca 31dc    	movt	r1, #0xabdc
700a77f2: 4288         	cmp	r0, r1
700a77f4: d107         	bne	0x700a7806 <Udma_ringDequeueRaw+0x36> @ imm = #0xe
700a77f6: e7ff         	b	0x700a77f8 <Udma_ringDequeueRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a77f8: 9800         	ldr	r0, [sp]
700a77fa: 8880         	ldrh	r0, [r0, #0x4]
700a77fc: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a7800: 4288         	cmp	r0, r1
700a7802: d104         	bne	0x700a780e <Udma_ringDequeueRaw+0x3e> @ imm = #0x8
700a7804: e7ff         	b	0x700a7806 <Udma_ringDequeueRaw+0x36> @ imm = #-0x2
700a7806: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a780a: 9003         	str	r0, [sp, #0xc]
;     }
700a780c: e7ff         	b	0x700a780e <Udma_ringDequeueRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a780e: 9803         	ldr	r0, [sp, #0xc]
700a7810: b9a8         	cbnz	r0, 0x700a783e <Udma_ringDequeueRaw+0x6e> @ imm = #0x2a
700a7812: e7ff         	b	0x700a7814 <Udma_ringDequeueRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a7814: 9800         	ldr	r0, [sp]
700a7816: 6800         	ldr	r0, [r0]
700a7818: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a781a: 9801         	ldr	r0, [sp, #0x4]
700a781c: b150         	cbz	r0, 0x700a7834 <Udma_ringDequeueRaw+0x64> @ imm = #0x14
700a781e: e7ff         	b	0x700a7820 <Udma_ringDequeueRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a7820: 9801         	ldr	r0, [sp, #0x4]
700a7822: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7826: f64a 31cd    	movw	r1, #0xabcd
700a782a: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a782e: 4288         	cmp	r0, r1
700a7830: d004         	beq	0x700a783c <Udma_ringDequeueRaw+0x6c> @ imm = #0x8
700a7832: e7ff         	b	0x700a7834 <Udma_ringDequeueRaw+0x64> @ imm = #-0x2
700a7834: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7838: 9003         	str	r0, [sp, #0xc]
;         }
700a783a: e7ff         	b	0x700a783c <Udma_ringDequeueRaw+0x6c> @ imm = #-0x2
;     }
700a783c: e7ff         	b	0x700a783e <Udma_ringDequeueRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a783e: 9803         	ldr	r0, [sp, #0xc]
700a7840: b970         	cbnz	r0, 0x700a7860 <Udma_ringDequeueRaw+0x90> @ imm = #0x1c
700a7842: e7ff         	b	0x700a7844 <Udma_ringDequeueRaw+0x74> @ imm = #-0x2
;         cookie = HwiP_disable();
700a7844: f006 ef14    	blx	0x700ae670 <HwiP_disable> @ imm = #0x6e28
700a7848: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringDequeueRaw(drvHandle, ringHandleInt, phyDescMem);
700a784a: 9801         	ldr	r0, [sp, #0x4]
700a784c: f8d0 3590    	ldr.w	r3, [r0, #0x590]
700a7850: 9900         	ldr	r1, [sp]
700a7852: 9a04         	ldr	r2, [sp, #0x10]
700a7854: 4798         	blx	r3
700a7856: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a7858: 9802         	ldr	r0, [sp, #0x8]
700a785a: f006 ef2a    	blx	0x700ae6b0 <HwiP_restore> @ imm = #0x6e54
;     }
700a785e: e7ff         	b	0x700a7860 <Udma_ringDequeueRaw+0x90> @ imm = #-0x2
;     return (retVal);
700a7860: 9803         	ldr	r0, [sp, #0xc]
700a7862: b006         	add	sp, #0x18
700a7864: bd80         	pop	{r7, pc}
		...
700a786e: 0000         	movs	r0, r0

700a7870 <vTaskResume>:
; void vTaskResume(TaskHandle_t xTaskToResume) {
700a7870: b580         	push	{r7, lr}
700a7872: b082         	sub	sp, #0x8
700a7874: 9001         	str	r0, [sp, #0x4]
;   TCB_t *const pxTCB = xTaskToResume;
700a7876: 9801         	ldr	r0, [sp, #0x4]
700a7878: 9000         	str	r0, [sp]
;   if ((pxTCB != pxCurrentTCB) && (pxTCB != NULL)) {
700a787a: 9800         	ldr	r0, [sp]
700a787c: f240 41dc    	movw	r1, #0x4dc
700a7880: f2c7 010b    	movt	r1, #0x700b
700a7884: 6809         	ldr	r1, [r1]
700a7886: 4288         	cmp	r0, r1
700a7888: d03a         	beq	0x700a7900 <vTaskResume+0x90> @ imm = #0x74
700a788a: e7ff         	b	0x700a788c <vTaskResume+0x1c> @ imm = #-0x2
700a788c: 9800         	ldr	r0, [sp]
700a788e: b3b8         	cbz	r0, 0x700a7900 <vTaskResume+0x90> @ imm = #0x6e
700a7890: e7ff         	b	0x700a7892 <vTaskResume+0x22> @ imm = #-0x2
;     taskENTER_CRITICAL();
700a7892: f004 fe7d    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x4cfa
;       if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE) {
700a7896: 9800         	ldr	r0, [sp]
700a7898: f003 fc42    	bl	0x700ab120 <prvTaskIsTaskSuspended> @ imm = #0x3884
700a789c: b360         	cbz	r0, 0x700a78f8 <vTaskResume+0x88> @ imm = #0x58
700a789e: e7ff         	b	0x700a78a0 <vTaskResume+0x30> @ imm = #-0x2
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700a78a0: 9800         	ldr	r0, [sp]
700a78a2: 3004         	adds	r0, #0x4
700a78a4: f003 fe44    	bl	0x700ab530 <uxListRemove> @ imm = #0x3c88
;         prvAddTaskToReadyList(pxTCB);
700a78a8: 9800         	ldr	r0, [sp]
700a78aa: 6ac1         	ldr	r1, [r0, #0x2c]
700a78ac: 2001         	movs	r0, #0x1
700a78ae: fa00 f201    	lsl.w	r2, r0, r1
700a78b2: f240 5108    	movw	r1, #0x508
700a78b6: f2c7 010b    	movt	r1, #0x700b
700a78ba: 6808         	ldr	r0, [r1]
700a78bc: 4310         	orrs	r0, r2
700a78be: 6008         	str	r0, [r1]
700a78c0: 9900         	ldr	r1, [sp]
700a78c2: 6ac8         	ldr	r0, [r1, #0x2c]
700a78c4: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a78c8: f244 40f8    	movw	r0, #0x44f8
700a78cc: f2c7 0008    	movt	r0, #0x7008
700a78d0: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a78d4: 3104         	adds	r1, #0x4
700a78d6: f004 fbe3    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #0x47c6
;         if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a78da: 9800         	ldr	r0, [sp]
700a78dc: 6ac0         	ldr	r0, [r0, #0x2c]
700a78de: f240 41dc    	movw	r1, #0x4dc
700a78e2: f2c7 010b    	movt	r1, #0x700b
700a78e6: 6809         	ldr	r1, [r1]
700a78e8: 6ac9         	ldr	r1, [r1, #0x2c]
700a78ea: 4288         	cmp	r0, r1
700a78ec: d302         	blo	0x700a78f4 <vTaskResume+0x84> @ imm = #0x4
700a78ee: e7ff         	b	0x700a78f0 <vTaskResume+0x80> @ imm = #-0x2
;           taskYIELD_IF_USING_PREEMPTION();
700a78f0: df00         	svc	#0x0
;         } else {
700a78f2: e000         	b	0x700a78f6 <vTaskResume+0x86> @ imm = #0x0
700a78f4: e7ff         	b	0x700a78f6 <vTaskResume+0x86> @ imm = #-0x2
;       } else {
700a78f6: e000         	b	0x700a78fa <vTaskResume+0x8a> @ imm = #0x0
700a78f8: e7ff         	b	0x700a78fa <vTaskResume+0x8a> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700a78fa: f003 ff09    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x3e12
;   } else {
700a78fe: e000         	b	0x700a7902 <vTaskResume+0x92> @ imm = #0x0
700a7900: e7ff         	b	0x700a7902 <vTaskResume+0x92> @ imm = #-0x2
; }
700a7902: b002         	add	sp, #0x8
700a7904: bd80         	pop	{r7, pc}
		...
700a790e: 0000         	movs	r0, r0

700a7910 <UART_lld_dmaDisableChannel>:
; {
700a7910: b580         	push	{r7, lr}
700a7912: b08a         	sub	sp, #0x28
700a7914: 9009         	str	r0, [sp, #0x24]
700a7916: 9108         	str	r1, [sp, #0x20]
700a7918: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a791a: 9007         	str	r0, [sp, #0x1c]
700a791c: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a791e: 9006         	str	r0, [sp, #0x18]
;     udmaChCfg   = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a7920: 9809         	ldr	r0, [sp, #0x24]
700a7922: 6840         	ldr	r0, [r0, #0x4]
700a7924: 6cc0         	ldr	r0, [r0, #0x4c]
700a7926: 9005         	str	r0, [sp, #0x14]
;     if (isChannelTx == TRUE)
700a7928: 9808         	ldr	r0, [sp, #0x20]
700a792a: 2801         	cmp	r0, #0x1
700a792c: d104         	bne	0x700a7938 <UART_lld_dmaDisableChannel+0x28> @ imm = #0x8
700a792e: e7ff         	b	0x700a7930 <UART_lld_dmaDisableChannel+0x20> @ imm = #-0x2
;         chHandle = udmaChCfg->txChHandle;
700a7930: 9805         	ldr	r0, [sp, #0x14]
700a7932: 6840         	ldr	r0, [r0, #0x4]
700a7934: 9004         	str	r0, [sp, #0x10]
;     }
700a7936: e003         	b	0x700a7940 <UART_lld_dmaDisableChannel+0x30> @ imm = #0x6
;         chHandle = udmaChCfg->rxChHandle;
700a7938: 9805         	ldr	r0, [sp, #0x14]
700a793a: 6880         	ldr	r0, [r0, #0x8]
700a793c: 9004         	str	r0, [sp, #0x10]
700a793e: e7ff         	b	0x700a7940 <UART_lld_dmaDisableChannel+0x30> @ imm = #-0x2
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a7940: 9804         	ldr	r0, [sp, #0x10]
700a7942: 2164         	movs	r1, #0x64
700a7944: f7fe fb9c    	bl	0x700a6080 <Udma_chDisable> @ imm = #-0x18c8
700a7948: 9007         	str	r0, [sp, #0x1c]
;     DebugP_assert(UDMA_SOK == status);
700a794a: 9807         	ldr	r0, [sp, #0x1c]
700a794c: fab0 f080    	clz	r0, r0
700a7950: 0940         	lsrs	r0, r0, #0x5
700a7952: f64f 315c    	movw	r1, #0xfb5c
700a7956: f2c7 010a    	movt	r1, #0x700a
700a795a: 466a         	mov	r2, sp
700a795c: 6011         	str	r1, [r2]
700a795e: f24f 7199    	movw	r1, #0xf799
700a7962: f2c7 010a    	movt	r1, #0x700a
700a7966: f64f 2217    	movw	r2, #0xfa17
700a796a: f2c7 020a    	movt	r2, #0x700a
700a796e: f240 137b    	movw	r3, #0x17b
700a7972: f001 f955    	bl	0x700a8c20 <_DebugP_assert> @ imm = #0x12aa
;     while(temp == TRUE)
700a7976: e7ff         	b	0x700a7978 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x2
700a7978: 9806         	ldr	r0, [sp, #0x18]
700a797a: 2801         	cmp	r0, #0x1
700a797c: d10f         	bne	0x700a799e <UART_lld_dmaDisableChannel+0x8e> @ imm = #0x1e
700a797e: e7ff         	b	0x700a7980 <UART_lld_dmaDisableChannel+0x70> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a7980: 9804         	ldr	r0, [sp, #0x10]
700a7982: f001 fb4d    	bl	0x700a9020 <Udma_chGetFqRingHandle> @ imm = #0x169a
700a7986: a902         	add	r1, sp, #0x8
;         tempRetVal = Udma_ringFlushRaw(
700a7988: f000 fb9a    	bl	0x700a80c0 <Udma_ringFlushRaw> @ imm = #0x734
700a798c: 9001         	str	r0, [sp, #0x4]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a798e: 9801         	ldr	r0, [sp, #0x4]
700a7990: 3004         	adds	r0, #0x4
700a7992: b918         	cbnz	r0, 0x700a799c <UART_lld_dmaDisableChannel+0x8c> @ imm = #0x6
700a7994: e7ff         	b	0x700a7996 <UART_lld_dmaDisableChannel+0x86> @ imm = #-0x2
700a7996: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a7998: 9006         	str	r0, [sp, #0x18]
;         }
700a799a: e7ff         	b	0x700a799c <UART_lld_dmaDisableChannel+0x8c> @ imm = #-0x2
;     while(temp == TRUE)
700a799c: e7ec         	b	0x700a7978 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x28
;     return status;
700a799e: 9807         	ldr	r0, [sp, #0x1c]
700a79a0: b00a         	add	sp, #0x28
700a79a2: bd80         	pop	{r7, pc}
		...

700a79b0 <xQueueGiveFromISR>:
; {
700a79b0: b580         	push	{r7, lr}
700a79b2: b088         	sub	sp, #0x20
700a79b4: 9007         	str	r0, [sp, #0x1c]
700a79b6: 9106         	str	r1, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a79b8: 9807         	ldr	r0, [sp, #0x1c]
700a79ba: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a79bc: f006 ee58    	blx	0x700ae670 <HwiP_disable> @ imm = #0x6cb0
700a79c0: 9004         	str	r0, [sp, #0x10]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a79c2: 9803         	ldr	r0, [sp, #0xc]
700a79c4: 6b80         	ldr	r0, [r0, #0x38]
700a79c6: 9002         	str	r0, [sp, #0x8]
;         if( uxMessagesWaiting < pxQueue->uxLength )
700a79c8: 9802         	ldr	r0, [sp, #0x8]
700a79ca: 9903         	ldr	r1, [sp, #0xc]
700a79cc: 6bc9         	ldr	r1, [r1, #0x3c]
700a79ce: 4288         	cmp	r0, r1
700a79d0: d22f         	bhs	0x700a7a32 <xQueueGiveFromISR+0x82> @ imm = #0x5e
700a79d2: e7ff         	b	0x700a79d4 <xQueueGiveFromISR+0x24> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a79d4: 9803         	ldr	r0, [sp, #0xc]
700a79d6: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a79da: f88d 0007    	strb.w	r0, [sp, #0x7]
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a79de: 9802         	ldr	r0, [sp, #0x8]
700a79e0: 3001         	adds	r0, #0x1
700a79e2: 9903         	ldr	r1, [sp, #0xc]
700a79e4: 6388         	str	r0, [r1, #0x38]
;             if( cTxLock == queueUNLOCKED )
700a79e6: f99d 0007    	ldrsb.w	r0, [sp, #0x7]
700a79ea: 3001         	adds	r0, #0x1
700a79ec: b9b8         	cbnz	r0, 0x700a7a1e <xQueueGiveFromISR+0x6e> @ imm = #0x2e
700a79ee: e7ff         	b	0x700a79f0 <xQueueGiveFromISR+0x40> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a79f0: 9803         	ldr	r0, [sp, #0xc]
700a79f2: 6a40         	ldr	r0, [r0, #0x24]
700a79f4: b188         	cbz	r0, 0x700a7a1a <xQueueGiveFromISR+0x6a> @ imm = #0x22
700a79f6: e7ff         	b	0x700a79f8 <xQueueGiveFromISR+0x48> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a79f8: 9803         	ldr	r0, [sp, #0xc]
700a79fa: 3024         	adds	r0, #0x24
700a79fc: f7fe fc48    	bl	0x700a6290 <xTaskRemoveFromEventList> @ imm = #-0x1770
700a7a00: b148         	cbz	r0, 0x700a7a16 <xQueueGiveFromISR+0x66> @ imm = #0x12
700a7a02: e7ff         	b	0x700a7a04 <xQueueGiveFromISR+0x54> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a7a04: 9806         	ldr	r0, [sp, #0x18]
700a7a06: b120         	cbz	r0, 0x700a7a12 <xQueueGiveFromISR+0x62> @ imm = #0x8
700a7a08: e7ff         	b	0x700a7a0a <xQueueGiveFromISR+0x5a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a7a0a: 9906         	ldr	r1, [sp, #0x18]
700a7a0c: 2001         	movs	r0, #0x1
700a7a0e: 6008         	str	r0, [r1]
;                                 }
700a7a10: e000         	b	0x700a7a14 <xQueueGiveFromISR+0x64> @ imm = #0x0
700a7a12: e7ff         	b	0x700a7a14 <xQueueGiveFromISR+0x64> @ imm = #-0x2
;                             }
700a7a14: e000         	b	0x700a7a18 <xQueueGiveFromISR+0x68> @ imm = #0x0
700a7a16: e7ff         	b	0x700a7a18 <xQueueGiveFromISR+0x68> @ imm = #-0x2
;                         }
700a7a18: e000         	b	0x700a7a1c <xQueueGiveFromISR+0x6c> @ imm = #0x0
700a7a1a: e7ff         	b	0x700a7a1c <xQueueGiveFromISR+0x6c> @ imm = #-0x2
;             }
700a7a1c: e006         	b	0x700a7a2c <xQueueGiveFromISR+0x7c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a7a1e: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a7a22: 3001         	adds	r0, #0x1
700a7a24: 9903         	ldr	r1, [sp, #0xc]
700a7a26: f881 0045    	strb.w	r0, [r1, #0x45]
700a7a2a: e7ff         	b	0x700a7a2c <xQueueGiveFromISR+0x7c> @ imm = #-0x2
700a7a2c: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a7a2e: 9005         	str	r0, [sp, #0x14]
;         }
700a7a30: e002         	b	0x700a7a38 <xQueueGiveFromISR+0x88> @ imm = #0x4
700a7a32: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a7a34: 9005         	str	r0, [sp, #0x14]
700a7a36: e7ff         	b	0x700a7a38 <xQueueGiveFromISR+0x88> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a7a38: 9804         	ldr	r0, [sp, #0x10]
700a7a3a: f006 ee3a    	blx	0x700ae6b0 <HwiP_restore> @ imm = #0x6c74
;     return xReturn;
700a7a3e: 9805         	ldr	r0, [sp, #0x14]
700a7a40: b008         	add	sp, #0x20
700a7a42: bd80         	pop	{r7, pc}
		...

700a7a50 <xTimerGenericCommand>:
;     {
700a7a50: b580         	push	{r7, lr}
700a7a52: b08a         	sub	sp, #0x28
700a7a54: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a7a58: 9009         	str	r0, [sp, #0x24]
700a7a5a: 9108         	str	r1, [sp, #0x20]
700a7a5c: 9207         	str	r2, [sp, #0x1c]
700a7a5e: 9306         	str	r3, [sp, #0x18]
700a7a60: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700a7a62: 9005         	str	r0, [sp, #0x14]
;         if( xTimerQueue != NULL )
700a7a64: f240 5024    	movw	r0, #0x524
700a7a68: f2c7 000b    	movt	r0, #0x700b
700a7a6c: 6800         	ldr	r0, [r0]
700a7a6e: b3a8         	cbz	r0, 0x700a7adc <xTimerGenericCommand+0x8c> @ imm = #0x6a
700a7a70: e7ff         	b	0x700a7a72 <xTimerGenericCommand+0x22> @ imm = #-0x2
;             xMessage.xMessageID = xCommandID;
700a7a72: 9808         	ldr	r0, [sp, #0x20]
700a7a74: 9001         	str	r0, [sp, #0x4]
;             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
700a7a76: 9807         	ldr	r0, [sp, #0x1c]
700a7a78: 9002         	str	r0, [sp, #0x8]
;             xMessage.u.xTimerParameters.pxTimer = xTimer;
700a7a7a: 9809         	ldr	r0, [sp, #0x24]
700a7a7c: 9003         	str	r0, [sp, #0xc]
;             if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
700a7a7e: 9808         	ldr	r0, [sp, #0x20]
700a7a80: 2805         	cmp	r0, #0x5
700a7a82: dc1e         	bgt	0x700a7ac2 <xTimerGenericCommand+0x72> @ imm = #0x3c
700a7a84: e7ff         	b	0x700a7a86 <xTimerGenericCommand+0x36> @ imm = #-0x2
;                 if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
700a7a86: f004 fbab    	bl	0x700ac1e0 <xTaskGetSchedulerState> @ imm = #0x4756
700a7a8a: 2802         	cmp	r0, #0x2
700a7a8c: d10c         	bne	0x700a7aa8 <xTimerGenericCommand+0x58> @ imm = #0x18
700a7a8e: e7ff         	b	0x700a7a90 <xTimerGenericCommand+0x40> @ imm = #-0x2
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
700a7a90: f240 5024    	movw	r0, #0x524
700a7a94: f2c7 000b    	movt	r0, #0x700b
700a7a98: 6800         	ldr	r0, [r0]
700a7a9a: 9a0c         	ldr	r2, [sp, #0x30]
700a7a9c: a901         	add	r1, sp, #0x4
700a7a9e: 2300         	movs	r3, #0x0
700a7aa0: f7f9 fd76    	bl	0x700a1590 <xQueueGenericSend> @ imm = #-0x6514
700a7aa4: 9005         	str	r0, [sp, #0x14]
;                 }
700a7aa6: e00b         	b	0x700a7ac0 <xTimerGenericCommand+0x70> @ imm = #0x16
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
700a7aa8: f240 5024    	movw	r0, #0x524
700a7aac: f2c7 000b    	movt	r0, #0x700b
700a7ab0: 6800         	ldr	r0, [r0]
700a7ab2: a901         	add	r1, sp, #0x4
700a7ab4: 2300         	movs	r3, #0x0
700a7ab6: 461a         	mov	r2, r3
700a7ab8: f7f9 fd6a    	bl	0x700a1590 <xQueueGenericSend> @ imm = #-0x652c
700a7abc: 9005         	str	r0, [sp, #0x14]
700a7abe: e7ff         	b	0x700a7ac0 <xTimerGenericCommand+0x70> @ imm = #-0x2
;             }
700a7ac0: e00b         	b	0x700a7ada <xTimerGenericCommand+0x8a> @ imm = #0x16
;                 xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
700a7ac2: f240 5024    	movw	r0, #0x524
700a7ac6: f2c7 000b    	movt	r0, #0x700b
700a7aca: 6800         	ldr	r0, [r0]
700a7acc: 9a06         	ldr	r2, [sp, #0x18]
700a7ace: a901         	add	r1, sp, #0x4
700a7ad0: 2300         	movs	r3, #0x0
700a7ad2: f7fe feed    	bl	0x700a68b0 <xQueueGenericSendFromISR> @ imm = #-0x1226
700a7ad6: 9005         	str	r0, [sp, #0x14]
700a7ad8: e7ff         	b	0x700a7ada <xTimerGenericCommand+0x8a> @ imm = #-0x2
;         }
700a7ada: e000         	b	0x700a7ade <xTimerGenericCommand+0x8e> @ imm = #0x0
700a7adc: e7ff         	b	0x700a7ade <xTimerGenericCommand+0x8e> @ imm = #-0x2
;         return xReturn;
700a7ade: 9805         	ldr	r0, [sp, #0x14]
700a7ae0: b00a         	add	sp, #0x28
700a7ae2: bd80         	pop	{r7, pc}
		...

700a7af0 <SOC_moduleClockEnable>:
; {
700a7af0: b580         	push	{r7, lr}
700a7af2: b088         	sub	sp, #0x20
700a7af4: 9007         	str	r0, [sp, #0x1c]
700a7af6: 9106         	str	r1, [sp, #0x18]
700a7af8: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a7afa: 9005         	str	r0, [sp, #0x14]
700a7afc: 2102         	movs	r1, #0x2
;     uint32_t moduleState = TISCI_MSG_VALUE_DEVICE_HW_STATE_TRANS;
700a7afe: 9104         	str	r1, [sp, #0x10]
;     uint32_t resetState = 0U;
700a7b00: 9003         	str	r0, [sp, #0xc]
;     uint32_t contextLossState = 0U;
700a7b02: 9002         	str	r0, [sp, #0x8]
;     status = Sciclient_pmGetModuleState(moduleId,
700a7b04: 9807         	ldr	r0, [sp, #0x1c]
700a7b06: 466a         	mov	r2, sp
700a7b08: f04f 31ff    	mov.w	r1, #0xffffffff
700a7b0c: 6011         	str	r1, [r2]
700a7b0e: a904         	add	r1, sp, #0x10
700a7b10: aa03         	add	r2, sp, #0xc
700a7b12: ab02         	add	r3, sp, #0x8
700a7b14: f000 f96c    	bl	0x700a7df0 <Sciclient_pmGetModuleState> @ imm = #0x2d8
700a7b18: 9005         	str	r0, [sp, #0x14]
;     if(status == SystemP_SUCCESS)
700a7b1a: 9805         	ldr	r0, [sp, #0x14]
700a7b1c: bb70         	cbnz	r0, 0x700a7b7c <SOC_moduleClockEnable+0x8c> @ imm = #0x5c
700a7b1e: e7ff         	b	0x700a7b20 <SOC_moduleClockEnable+0x30> @ imm = #-0x2
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_OFF && (enable == 1))
700a7b20: 9804         	ldr	r0, [sp, #0x10]
700a7b22: b9c8         	cbnz	r0, 0x700a7b58 <SOC_moduleClockEnable+0x68> @ imm = #0x32
700a7b24: e7ff         	b	0x700a7b26 <SOC_moduleClockEnable+0x36> @ imm = #-0x2
700a7b26: 9806         	ldr	r0, [sp, #0x18]
700a7b28: 2801         	cmp	r0, #0x1
700a7b2a: d115         	bne	0x700a7b58 <SOC_moduleClockEnable+0x68> @ imm = #0x2a
700a7b2c: e7ff         	b	0x700a7b2e <SOC_moduleClockEnable+0x3e> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a7b2e: 9807         	ldr	r0, [sp, #0x1c]
700a7b30: 2102         	movs	r1, #0x2
700a7b32: f240 2202    	movw	r2, #0x202
700a7b36: f04f 33ff    	mov.w	r3, #0xffffffff
700a7b3a: f000 f9e9    	bl	0x700a7f10 <Sciclient_pmSetModuleState> @ imm = #0x3d2
700a7b3e: 9005         	str	r0, [sp, #0x14]
;             if (status == SystemP_SUCCESS)
700a7b40: 9805         	ldr	r0, [sp, #0x14]
700a7b42: b940         	cbnz	r0, 0x700a7b56 <SOC_moduleClockEnable+0x66> @ imm = #0x10
700a7b44: e7ff         	b	0x700a7b46 <SOC_moduleClockEnable+0x56> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleRst(moduleId,
700a7b46: 9807         	ldr	r0, [sp, #0x1c]
700a7b48: 2100         	movs	r1, #0x0
700a7b4a: f04f 32ff    	mov.w	r2, #0xffffffff
700a7b4e: f002 fc4f    	bl	0x700aa3f0 <Sciclient_pmSetModuleRst> @ imm = #0x289e
700a7b52: 9005         	str	r0, [sp, #0x14]
;             }
700a7b54: e7ff         	b	0x700a7b56 <SOC_moduleClockEnable+0x66> @ imm = #-0x2
;         }
700a7b56: e010         	b	0x700a7b7a <SOC_moduleClockEnable+0x8a> @ imm = #0x20
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_ON && (enable == 0))
700a7b58: 9804         	ldr	r0, [sp, #0x10]
700a7b5a: 2801         	cmp	r0, #0x1
700a7b5c: d10c         	bne	0x700a7b78 <SOC_moduleClockEnable+0x88> @ imm = #0x18
700a7b5e: e7ff         	b	0x700a7b60 <SOC_moduleClockEnable+0x70> @ imm = #-0x2
700a7b60: 9806         	ldr	r0, [sp, #0x18]
700a7b62: b948         	cbnz	r0, 0x700a7b78 <SOC_moduleClockEnable+0x88> @ imm = #0x12
700a7b64: e7ff         	b	0x700a7b66 <SOC_moduleClockEnable+0x76> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a7b66: 9807         	ldr	r0, [sp, #0x1c]
700a7b68: 2100         	movs	r1, #0x0
700a7b6a: 2202         	movs	r2, #0x2
700a7b6c: f04f 33ff    	mov.w	r3, #0xffffffff
700a7b70: f000 f9ce    	bl	0x700a7f10 <Sciclient_pmSetModuleState> @ imm = #0x39c
700a7b74: 9005         	str	r0, [sp, #0x14]
;         }
700a7b76: e7ff         	b	0x700a7b78 <SOC_moduleClockEnable+0x88> @ imm = #-0x2
700a7b78: e7ff         	b	0x700a7b7a <SOC_moduleClockEnable+0x8a> @ imm = #-0x2
;     }
700a7b7a: e7ff         	b	0x700a7b7c <SOC_moduleClockEnable+0x8c> @ imm = #-0x2
;     return status;
700a7b7c: 9805         	ldr	r0, [sp, #0x14]
700a7b7e: b008         	add	sp, #0x20
700a7b80: bd80         	pop	{r7, pc}
		...
700a7b8e: 0000         	movs	r0, r0

700a7b90 <Sciclient_rmPsPop>:
; {
700a7b90: b084         	sub	sp, #0x10
700a7b92: 9003         	str	r0, [sp, #0xc]
700a7b94: 9102         	str	r1, [sp, #0x8]
700a7b96: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a7b98: 9001         	str	r0, [sp, #0x4]
;     if ((gPstack.psp > (0u)) && (n != NULL) && (if_idx != NULL)) {
700a7b9a: f241 0058    	movw	r0, #0x1058
700a7b9e: f2c7 0008    	movt	r0, #0x7008
700a7ba2: 8c80         	ldrh	r0, [r0, #0x24]
700a7ba4: b3b0         	cbz	r0, 0x700a7c14 <Sciclient_rmPsPop+0x84> @ imm = #0x6c
700a7ba6: e7ff         	b	0x700a7ba8 <Sciclient_rmPsPop+0x18> @ imm = #-0x2
700a7ba8: 9803         	ldr	r0, [sp, #0xc]
700a7baa: b398         	cbz	r0, 0x700a7c14 <Sciclient_rmPsPop+0x84> @ imm = #0x66
700a7bac: e7ff         	b	0x700a7bae <Sciclient_rmPsPop+0x1e> @ imm = #-0x2
700a7bae: 9802         	ldr	r0, [sp, #0x8]
700a7bb0: b380         	cbz	r0, 0x700a7c14 <Sciclient_rmPsPop+0x84> @ imm = #0x60
700a7bb2: e7ff         	b	0x700a7bb4 <Sciclient_rmPsPop+0x24> @ imm = #-0x2
;         gPstack.psp--;
700a7bb4: f241 0158    	movw	r1, #0x1058
700a7bb8: f2c7 0108    	movt	r1, #0x7008
700a7bbc: 9100         	str	r1, [sp]
700a7bbe: 8c88         	ldrh	r0, [r1, #0x24]
700a7bc0: 3801         	subs	r0, #0x1
700a7bc2: 8488         	strh	r0, [r1, #0x24]
;         *n = gPstack.ps[gPstack.psp].p_n;
700a7bc4: 8c88         	ldrh	r0, [r1, #0x24]
700a7bc6: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a7bca: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700a7bce: 9a03         	ldr	r2, [sp, #0xc]
700a7bd0: 6010         	str	r0, [r2]
;         *if_idx = gPstack.ps[gPstack.psp].if_idx;
700a7bd2: 8c88         	ldrh	r0, [r1, #0x24]
700a7bd4: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a7bd8: eb01 0080    	add.w	r0, r1, r0, lsl #2
700a7bdc: 8880         	ldrh	r0, [r0, #0x4]
700a7bde: 9a02         	ldr	r2, [sp, #0x8]
700a7be0: 8010         	strh	r0, [r2]
;         gPstack.ps[gPstack.psp].p_n = NULL;
700a7be2: 8c88         	ldrh	r0, [r1, #0x24]
700a7be4: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a7be8: 2000         	movs	r0, #0x0
700a7bea: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = 0;
700a7bee: 8c8a         	ldrh	r2, [r1, #0x24]
700a7bf0: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a7bf4: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a7bf8: 8090         	strh	r0, [r2, #0x4]
;         gPstack.ps[gPstack.psp].inp = 0;
700a7bfa: 8c8a         	ldrh	r2, [r1, #0x24]
700a7bfc: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a7c00: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a7c04: 80d0         	strh	r0, [r2, #0x6]
;         gPstack.ps[gPstack.psp].outp = 0;
700a7c06: 8c8a         	ldrh	r2, [r1, #0x24]
700a7c08: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a7c0c: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a7c10: 8108         	strh	r0, [r1, #0x8]
;     } else {
700a7c12: e003         	b	0x700a7c1c <Sciclient_rmPsPop+0x8c> @ imm = #0x6
700a7c14: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a7c18: 9001         	str	r0, [sp, #0x4]
700a7c1a: e7ff         	b	0x700a7c1c <Sciclient_rmPsPop+0x8c> @ imm = #-0x2
;     return r;
700a7c1c: 9801         	ldr	r0, [sp, #0x4]
700a7c1e: b004         	add	sp, #0x10
700a7c20: 4770         	bx	lr
		...
700a7c2e: 0000         	movs	r0, r0

700a7c30 <_DebugP_logZone>:
; {
700a7c30: b082         	sub	sp, #0x8
700a7c32: b580         	push	{r7, lr}
700a7c34: b086         	sub	sp, #0x18
700a7c36: 9309         	str	r3, [sp, #0x24]
700a7c38: 9208         	str	r2, [sp, #0x20]
700a7c3a: 9005         	str	r0, [sp, #0x14]
700a7c3c: 9104         	str	r1, [sp, #0x10]
;     if((HwiP_inISR()) == 0U )
700a7c3e: f006 fa37    	bl	0x700ae0b0 <HwiP_inISR> @ imm = #0x646e
700a7c42: bbc8         	cbnz	r0, 0x700a7cb8 <_DebugP_logZone+0x88> @ imm = #0x72
700a7c44: e7ff         	b	0x700a7c46 <_DebugP_logZone+0x16> @ imm = #-0x2
;         if(gDebugLogIsInitDone == 0U)
700a7c46: f240 40ac    	movw	r0, #0x4ac
700a7c4a: f2c7 000b    	movt	r0, #0x700b
700a7c4e: 6800         	ldr	r0, [r0]
700a7c50: b9a0         	cbnz	r0, 0x700a7c7c <_DebugP_logZone+0x4c> @ imm = #0x28
700a7c52: e7ff         	b	0x700a7c54 <_DebugP_logZone+0x24> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&gDebugLogLockObj);
700a7c54: f644 4018    	movw	r0, #0x4c18
700a7c58: f2c7 0008    	movt	r0, #0x7008
700a7c5c: f001 fc78    	bl	0x700a9550 <SemaphoreP_constructMutex> @ imm = #0x18f0
700a7c60: 9003         	str	r0, [sp, #0xc]
;             DebugP_assertNoLog(status == SystemP_SUCCESS);
700a7c62: 9803         	ldr	r0, [sp, #0xc]
700a7c64: fab0 f080    	clz	r0, r0
700a7c68: 0940         	lsrs	r0, r0, #0x5
700a7c6a: f007 f9c1    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x7382
;             gDebugLogIsInitDone = 1;
700a7c6e: f240 41ac    	movw	r1, #0x4ac
700a7c72: f2c7 010b    	movt	r1, #0x700b
700a7c76: 2001         	movs	r0, #0x1
700a7c78: 6008         	str	r0, [r1]
;         }
700a7c7a: e7ff         	b	0x700a7c7c <_DebugP_logZone+0x4c> @ imm = #-0x2
;         if( ( gDebugLogZone & logZone ) == logZone )
700a7c7c: f240 40b0    	movw	r0, #0x4b0
700a7c80: f2c7 000b    	movt	r0, #0x700b
700a7c84: 6800         	ldr	r0, [r0]
700a7c86: 9905         	ldr	r1, [sp, #0x14]
700a7c88: 4008         	ands	r0, r1
700a7c8a: 4288         	cmp	r0, r1
700a7c8c: d113         	bne	0x700a7cb6 <_DebugP_logZone+0x86> @ imm = #0x26
700a7c8e: e7ff         	b	0x700a7c90 <_DebugP_logZone+0x60> @ imm = #-0x2
;             SemaphoreP_pend(&gDebugLogLockObj, SystemP_WAIT_FOREVER);
700a7c90: f644 4018    	movw	r0, #0x4c18
700a7c94: f2c7 0008    	movt	r0, #0x7008
700a7c98: 9001         	str	r0, [sp, #0x4]
700a7c9a: f04f 31ff    	mov.w	r1, #0xffffffff
700a7c9e: f000 fd27    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0xa4e
700a7ca2: a808         	add	r0, sp, #0x20
;             va_start(va, format);
700a7ca4: 9002         	str	r0, [sp, #0x8]
;             vprintf_(format, va);
700a7ca6: 9804         	ldr	r0, [sp, #0x10]
700a7ca8: 9902         	ldr	r1, [sp, #0x8]
700a7caa: f005 f841    	bl	0x700acd30 <vprintf_>   @ imm = #0x5082
;             SemaphoreP_post(&gDebugLogLockObj);
700a7cae: 9801         	ldr	r0, [sp, #0x4]
700a7cb0: f002 f876    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x20ec
;         }
700a7cb4: e7ff         	b	0x700a7cb6 <_DebugP_logZone+0x86> @ imm = #-0x2
;     }
700a7cb6: e7ff         	b	0x700a7cb8 <_DebugP_logZone+0x88> @ imm = #-0x2
; }
700a7cb8: b006         	add	sp, #0x18
700a7cba: e8bd 4080    	pop.w	{r7, lr}
700a7cbe: b002         	add	sp, #0x8
700a7cc0: 4770         	bx	lr
		...
700a7cce: 0000         	movs	r0, r0

700a7cd0 <Udma_rmFreeMappedRing>:
; {
700a7cd0: b580         	push	{r7, lr}
700a7cd2: b08e         	sub	sp, #0x38
700a7cd4: 900d         	str	r0, [sp, #0x34]
700a7cd6: 910c         	str	r1, [sp, #0x30]
700a7cd8: 920b         	str	r2, [sp, #0x2c]
700a7cda: 930a         	str	r3, [sp, #0x28]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a7cdc: 980c         	ldr	r0, [sp, #0x30]
700a7cde: f500 70ea    	add.w	r0, r0, #0x1d4
700a7ce2: 9005         	str	r0, [sp, #0x14]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a7ce4: 980c         	ldr	r0, [sp, #0x30]
700a7ce6: 990b         	ldr	r1, [sp, #0x2c]
700a7ce8: 9a0a         	ldr	r2, [sp, #0x28]
700a7cea: ab02         	add	r3, sp, #0x8
700a7cec: f7fe f810    	bl	0x700a5d10 <Udma_getMappedChRingAttributes> @ imm = #-0x1fe0
700a7cf0: 9001         	str	r0, [sp, #0x4]
;     if(ringNum != chAttr.defaultRing)
700a7cf2: 980d         	ldr	r0, [sp, #0x34]
700a7cf4: 9902         	ldr	r1, [sp, #0x8]
700a7cf6: 4288         	cmp	r0, r1
700a7cf8: d02f         	beq	0x700a7d5a <Udma_rmFreeMappedRing+0x8a> @ imm = #0x5e
700a7cfa: e7ff         	b	0x700a7cfc <Udma_rmFreeMappedRing+0x2c> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a7cfc: 980c         	ldr	r0, [sp, #0x30]
700a7cfe: f500 609f    	add.w	r0, r0, #0x4f8
700a7d02: f04f 31ff    	mov.w	r1, #0xffffffff
700a7d06: f000 fcf3    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x9e6
;         i = ringNum - rmInitPrms->startMappedRing[mappedRingGrp];
700a7d0a: 980d         	ldr	r0, [sp, #0x34]
700a7d0c: 9905         	ldr	r1, [sp, #0x14]
700a7d0e: 9a0b         	ldr	r2, [sp, #0x2c]
700a7d10: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a7d14: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a7d18: 1a40         	subs	r0, r0, r1
700a7d1a: 9009         	str	r0, [sp, #0x24]
;         offset = i >> 5U;
700a7d1c: 9809         	ldr	r0, [sp, #0x24]
700a7d1e: 0940         	lsrs	r0, r0, #0x5
700a7d20: 9008         	str	r0, [sp, #0x20]
;         bitPos = i - (offset << 5U);
700a7d22: 9809         	ldr	r0, [sp, #0x24]
700a7d24: 9908         	ldr	r1, [sp, #0x20]
700a7d26: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a7d2a: 9007         	str	r0, [sp, #0x1c]
;         bitMask = (uint32_t) 1U << bitPos;
700a7d2c: 9907         	ldr	r1, [sp, #0x1c]
700a7d2e: 2001         	movs	r0, #0x1
700a7d30: 4088         	lsls	r0, r1
700a7d32: 9006         	str	r0, [sp, #0x18]
;         drvHandle->mappedRingFlag[mappedRingGrp][offset] |= bitMask;
700a7d34: 9a06         	ldr	r2, [sp, #0x18]
700a7d36: 980c         	ldr	r0, [sp, #0x30]
700a7d38: 990b         	ldr	r1, [sp, #0x2c]
700a7d3a: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a7d3e: 9908         	ldr	r1, [sp, #0x20]
700a7d40: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a7d44: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a7d48: 4310         	orrs	r0, r2
700a7d4a: f8c1 0344    	str.w	r0, [r1, #0x344]
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a7d4e: 980c         	ldr	r0, [sp, #0x30]
700a7d50: f500 609f    	add.w	r0, r0, #0x4f8
700a7d54: f002 f824    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x2048
;     }
700a7d58: e7ff         	b	0x700a7d5a <Udma_rmFreeMappedRing+0x8a> @ imm = #-0x2
;     return;
700a7d5a: b00e         	add	sp, #0x38
700a7d5c: bd80         	pop	{r7, pc}
700a7d5e: 0000         	movs	r0, r0

700a7d60 <prvInitialiseTaskLists>:
; static void prvInitialiseTaskLists(void) {
700a7d60: b580         	push	{r7, lr}
700a7d62: b084         	sub	sp, #0x10
700a7d64: 2000         	movs	r0, #0x0
;   for (uxPriority = (UBaseType_t)0U;
700a7d66: 9003         	str	r0, [sp, #0xc]
700a7d68: e7ff         	b	0x700a7d6a <prvInitialiseTaskLists+0xa> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a7d6a: 9803         	ldr	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a7d6c: 281f         	cmp	r0, #0x1f
700a7d6e: d810         	bhi	0x700a7d92 <prvInitialiseTaskLists+0x32> @ imm = #0x20
700a7d70: e7ff         	b	0x700a7d72 <prvInitialiseTaskLists+0x12> @ imm = #-0x2
;     vListInitialise(&(pxReadyTasksLists[uxPriority]));
700a7d72: 9803         	ldr	r0, [sp, #0xc]
700a7d74: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a7d78: f244 40f8    	movw	r0, #0x44f8
700a7d7c: f2c7 0008    	movt	r0, #0x7008
700a7d80: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7d84: f004 fd7c    	bl	0x700ac880 <vListInitialise> @ imm = #0x4af8
;   }
700a7d88: e7ff         	b	0x700a7d8a <prvInitialiseTaskLists+0x2a> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a7d8a: 9803         	ldr	r0, [sp, #0xc]
700a7d8c: 3001         	adds	r0, #0x1
700a7d8e: 9003         	str	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a7d90: e7eb         	b	0x700a7d6a <prvInitialiseTaskLists+0xa> @ imm = #-0x2a
;   vListInitialise(&xDelayedTaskList1);
700a7d92: f644 7040    	movw	r0, #0x4f40
700a7d96: f2c7 0008    	movt	r0, #0x7008
700a7d9a: 9001         	str	r0, [sp, #0x4]
700a7d9c: f004 fd70    	bl	0x700ac880 <vListInitialise> @ imm = #0x4ae0
;   vListInitialise(&xDelayedTaskList2);
700a7da0: f644 7054    	movw	r0, #0x4f54
700a7da4: f2c7 0008    	movt	r0, #0x7008
700a7da8: 9002         	str	r0, [sp, #0x8]
700a7daa: f004 fd69    	bl	0x700ac880 <vListInitialise> @ imm = #0x4ad2
;   vListInitialise(&xPendingReadyList);
700a7dae: f644 7068    	movw	r0, #0x4f68
700a7db2: f2c7 0008    	movt	r0, #0x7008
700a7db6: f004 fd63    	bl	0x700ac880 <vListInitialise> @ imm = #0x4ac6
;     vListInitialise(&xTasksWaitingTermination);
700a7dba: f644 7090    	movw	r0, #0x4f90
700a7dbe: f2c7 0008    	movt	r0, #0x7008
700a7dc2: f004 fd5d    	bl	0x700ac880 <vListInitialise> @ imm = #0x4aba
;     vListInitialise(&xSuspendedTaskList);
700a7dc6: f644 707c    	movw	r0, #0x4f7c
700a7dca: f2c7 0008    	movt	r0, #0x7008
700a7dce: f004 fd57    	bl	0x700ac880 <vListInitialise> @ imm = #0x4aae
700a7dd2: 9901         	ldr	r1, [sp, #0x4]
700a7dd4: 9802         	ldr	r0, [sp, #0x8]
;   pxDelayedTaskList = &xDelayedTaskList1;
700a7dd6: f644 72b8    	movw	r2, #0x4fb8
700a7dda: f2c7 0208    	movt	r2, #0x7008
700a7dde: 6011         	str	r1, [r2]
;   pxOverflowDelayedTaskList = &xDelayedTaskList2;
700a7de0: f644 71bc    	movw	r1, #0x4fbc
700a7de4: f2c7 0108    	movt	r1, #0x7008
700a7de8: 6008         	str	r0, [r1]
; }
700a7dea: b004         	add	sp, #0x10
700a7dec: bd80         	pop	{r7, pc}
700a7dee: 0000         	movs	r0, r0

700a7df0 <Sciclient_pmGetModuleState>:
; {
700a7df0: b580         	push	{r7, lr}
700a7df2: b096         	sub	sp, #0x58
700a7df4: f8dd c060    	ldr.w	r12, [sp, #0x60]
700a7df8: 9015         	str	r0, [sp, #0x54]
700a7dfa: 9114         	str	r1, [sp, #0x50]
700a7dfc: 9213         	str	r2, [sp, #0x4c]
700a7dfe: 9312         	str	r3, [sp, #0x48]
700a7e00: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a7e02: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_device_resp response = {{0}};
700a7e04: f8ad 0034    	strh.w	r0, [sp, #0x34]
700a7e08: 900c         	str	r0, [sp, #0x30]
700a7e0a: 900b         	str	r0, [sp, #0x2c]
700a7e0c: 900a         	str	r0, [sp, #0x28]
700a7e0e: 9009         	str	r0, [sp, #0x24]
;     request.id = (uint32_t) moduleId;
700a7e10: 9915         	ldr	r1, [sp, #0x54]
700a7e12: 9110         	str	r1, [sp, #0x40]
700a7e14: f240 2101    	movw	r1, #0x201
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_DEVICE;
700a7e18: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a7e1c: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a7e1e: 9105         	str	r1, [sp, #0x14]
700a7e20: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a7e22: 9106         	str	r1, [sp, #0x18]
700a7e24: 210c         	movs	r1, #0xc
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a7e26: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a7e28: 9918         	ldr	r1, [sp, #0x60]
700a7e2a: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a7e2c: 9001         	str	r0, [sp, #0x4]
700a7e2e: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a7e30: 9002         	str	r0, [sp, #0x8]
700a7e32: 2012         	movs	r0, #0x12
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a7e34: 9003         	str	r0, [sp, #0xc]
700a7e36: a804         	add	r0, sp, #0x10
700a7e38: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a7e3a: f7f4 f821    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xbfbe
700a7e3e: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a7e40: 9811         	ldr	r0, [sp, #0x44]
700a7e42: b930         	cbnz	r0, 0x700a7e52 <Sciclient_pmGetModuleState+0x62> @ imm = #0xc
700a7e44: e7ff         	b	0x700a7e46 <Sciclient_pmGetModuleState+0x56> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a7e46: 9801         	ldr	r0, [sp, #0x4]
700a7e48: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a7e4c: 2802         	cmp	r0, #0x2
700a7e4e: d004         	beq	0x700a7e5a <Sciclient_pmGetModuleState+0x6a> @ imm = #0x8
700a7e50: e7ff         	b	0x700a7e52 <Sciclient_pmGetModuleState+0x62> @ imm = #-0x2
700a7e52: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a7e56: 9011         	str	r0, [sp, #0x44]
;     }
700a7e58: e7ff         	b	0x700a7e5a <Sciclient_pmGetModuleState+0x6a> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a7e5a: 9811         	ldr	r0, [sp, #0x44]
700a7e5c: b958         	cbnz	r0, 0x700a7e76 <Sciclient_pmGetModuleState+0x86> @ imm = #0x16
700a7e5e: e7ff         	b	0x700a7e60 <Sciclient_pmGetModuleState+0x70> @ imm = #-0x2
;         *moduleState = (uint32_t) response.current_state;
700a7e60: f89d 0035    	ldrb.w	r0, [sp, #0x35]
700a7e64: 9914         	ldr	r1, [sp, #0x50]
700a7e66: 6008         	str	r0, [r1]
;         *resetState = (uint32_t) response.resets;
700a7e68: 980c         	ldr	r0, [sp, #0x30]
700a7e6a: 9913         	ldr	r1, [sp, #0x4c]
700a7e6c: 6008         	str	r0, [r1]
;         *contextLossState = (uint32_t) response.context_loss_count;
700a7e6e: 980b         	ldr	r0, [sp, #0x2c]
700a7e70: 9912         	ldr	r1, [sp, #0x48]
700a7e72: 6008         	str	r0, [r1]
;     }
700a7e74: e7ff         	b	0x700a7e76 <Sciclient_pmGetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a7e76: 9811         	ldr	r0, [sp, #0x44]
700a7e78: b016         	add	sp, #0x58
700a7e7a: bd80         	pop	{r7, pc}
700a7e7c: 0000         	movs	r0, r0
700a7e7e: 0000         	movs	r0, r0

700a7e80 <Sciclient_pmModuleClkRequest>:
; {
700a7e80: b580         	push	{r7, lr}
700a7e82: b092         	sub	sp, #0x48
700a7e84: f8dd c050    	ldr.w	r12, [sp, #0x50]
700a7e88: 9011         	str	r0, [sp, #0x44]
700a7e8a: 9110         	str	r1, [sp, #0x40]
700a7e8c: 920f         	str	r2, [sp, #0x3c]
700a7e8e: 930e         	str	r3, [sp, #0x38]
700a7e90: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a7e92: 900d         	str	r0, [sp, #0x34]
;     request.device = (uint32_t) moduleId;
700a7e94: 9811         	ldr	r0, [sp, #0x44]
700a7e96: 900a         	str	r0, [sp, #0x28]
;     if(clockId > (uint32_t)(255U))
700a7e98: 9810         	ldr	r0, [sp, #0x40]
700a7e9a: f5b0 7f80    	cmp.w	r0, #0x100
700a7e9e: d307         	blo	0x700a7eb0 <Sciclient_pmModuleClkRequest+0x30> @ imm = #0xe
700a7ea0: e7ff         	b	0x700a7ea2 <Sciclient_pmModuleClkRequest+0x22> @ imm = #-0x2
700a7ea2: 20ff         	movs	r0, #0xff
;         request.clk = (uint8_t)(255U);
700a7ea4: f88d 002c    	strb.w	r0, [sp, #0x2c]
;         request.clk32 = clockId;
700a7ea8: 9810         	ldr	r0, [sp, #0x40]
700a7eaa: f8cd 002e    	str.w	r0, [sp, #0x2e]
;     }
700a7eae: e003         	b	0x700a7eb8 <Sciclient_pmModuleClkRequest+0x38> @ imm = #0x6
;         request.clk    = (uint8_t)clockId;
700a7eb0: 9810         	ldr	r0, [sp, #0x40]
700a7eb2: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a7eb6: e7ff         	b	0x700a7eb8 <Sciclient_pmModuleClkRequest+0x38> @ imm = #-0x2
;     request.state  = (uint8_t) state;
700a7eb8: 980f         	ldr	r0, [sp, #0x3c]
700a7eba: f88d 002d    	strb.w	r0, [sp, #0x2d]
700a7ebe: f44f 7080    	mov.w	r0, #0x100
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK;
700a7ec2: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP | additionalFlag;
700a7ec6: 980e         	ldr	r0, [sp, #0x38]
700a7ec8: f040 0002    	orr	r0, r0, #0x2
700a7ecc: 9004         	str	r0, [sp, #0x10]
700a7ece: a808         	add	r0, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a7ed0: 9005         	str	r0, [sp, #0x14]
700a7ed2: 2012         	movs	r0, #0x12
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a7ed4: 9006         	str	r0, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a7ed6: 9814         	ldr	r0, [sp, #0x50]
700a7ed8: 9007         	str	r0, [sp, #0x1c]
700a7eda: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a7edc: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a7ede: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a7ee0: 9002         	str	r0, [sp, #0x8]
700a7ee2: a803         	add	r0, sp, #0xc
700a7ee4: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a7ee6: f7f3 ffcb    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xc06a
700a7eea: 900d         	str	r0, [sp, #0x34]
;     if((retVal != SystemP_SUCCESS) ||
700a7eec: 980d         	ldr	r0, [sp, #0x34]
700a7eee: b930         	cbnz	r0, 0x700a7efe <Sciclient_pmModuleClkRequest+0x7e> @ imm = #0xc
700a7ef0: e7ff         	b	0x700a7ef2 <Sciclient_pmModuleClkRequest+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a7ef2: 9800         	ldr	r0, [sp]
700a7ef4: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a7ef8: 2802         	cmp	r0, #0x2
700a7efa: d004         	beq	0x700a7f06 <Sciclient_pmModuleClkRequest+0x86> @ imm = #0x8
700a7efc: e7ff         	b	0x700a7efe <Sciclient_pmModuleClkRequest+0x7e> @ imm = #-0x2
700a7efe: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a7f02: 900d         	str	r0, [sp, #0x34]
;     }
700a7f04: e7ff         	b	0x700a7f06 <Sciclient_pmModuleClkRequest+0x86> @ imm = #-0x2
;     return retVal;
700a7f06: 980d         	ldr	r0, [sp, #0x34]
700a7f08: b012         	add	sp, #0x48
700a7f0a: bd80         	pop	{r7, pc}
700a7f0c: 0000         	movs	r0, r0
700a7f0e: 0000         	movs	r0, r0

700a7f10 <Sciclient_pmSetModuleState>:
; {
700a7f10: b580         	push	{r7, lr}
700a7f12: b092         	sub	sp, #0x48
700a7f14: 9011         	str	r0, [sp, #0x44]
700a7f16: 9110         	str	r1, [sp, #0x40]
700a7f18: 920f         	str	r2, [sp, #0x3c]
700a7f1a: 930e         	str	r3, [sp, #0x38]
700a7f1c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a7f1e: 900d         	str	r0, [sp, #0x34]
;     request.id       = (uint32_t) moduleId;
700a7f20: 9911         	ldr	r1, [sp, #0x44]
700a7f22: 910a         	str	r1, [sp, #0x28]
;     request.reserved = (uint32_t) 0;
700a7f24: 900b         	str	r0, [sp, #0x2c]
;     request.state    = (uint8_t) state;
700a7f26: 9910         	ldr	r1, [sp, #0x40]
700a7f28: f88d 1030    	strb.w	r1, [sp, #0x30]
700a7f2c: f44f 7100    	mov.w	r1, #0x200
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE;
700a7f30: f8ad 100c    	strh.w	r1, [sp, #0xc]
;     reqParam.flags          = (uint32_t) reqFlag;
700a7f34: 990f         	ldr	r1, [sp, #0x3c]
700a7f36: 9104         	str	r1, [sp, #0x10]
700a7f38: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a7f3a: 9105         	str	r1, [sp, #0x14]
700a7f3c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a7f3e: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a7f40: 990e         	ldr	r1, [sp, #0x38]
700a7f42: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a7f44: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a7f46: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a7f48: 9002         	str	r0, [sp, #0x8]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700a7f4a: 980f         	ldr	r0, [sp, #0x3c]
700a7f4c: f000 0002    	and	r0, r0, #0x2
700a7f50: 2802         	cmp	r0, #0x2
700a7f52: d007         	beq	0x700a7f64 <Sciclient_pmSetModuleState+0x54> @ imm = #0xe
700a7f54: e7ff         	b	0x700a7f56 <Sciclient_pmSetModuleState+0x46> @ imm = #-0x2
;         (reqFlag != 0U))
700a7f56: 980f         	ldr	r0, [sp, #0x3c]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700a7f58: b120         	cbz	r0, 0x700a7f64 <Sciclient_pmSetModuleState+0x54> @ imm = #0x8
700a7f5a: e7ff         	b	0x700a7f5c <Sciclient_pmSetModuleState+0x4c> @ imm = #-0x2
700a7f5c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a7f60: 900d         	str	r0, [sp, #0x34]
;     }
700a7f62: e7ff         	b	0x700a7f64 <Sciclient_pmSetModuleState+0x54> @ imm = #-0x2
;     if(retVal == SystemP_SUCCESS)
700a7f64: 980d         	ldr	r0, [sp, #0x34]
700a7f66: b930         	cbnz	r0, 0x700a7f76 <Sciclient_pmSetModuleState+0x66> @ imm = #0xc
700a7f68: e7ff         	b	0x700a7f6a <Sciclient_pmSetModuleState+0x5a> @ imm = #-0x2
700a7f6a: a803         	add	r0, sp, #0xc
700a7f6c: 4669         	mov	r1, sp
;         retVal = Sciclient_service(&reqParam, &respParam);
700a7f6e: f7f3 ff87    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xc0f2
700a7f72: 900d         	str	r0, [sp, #0x34]
;     }
700a7f74: e7ff         	b	0x700a7f76 <Sciclient_pmSetModuleState+0x66> @ imm = #-0x2
;     if((retVal != SystemP_SUCCESS) ||
700a7f76: 980d         	ldr	r0, [sp, #0x34]
700a7f78: b948         	cbnz	r0, 0x700a7f8e <Sciclient_pmSetModuleState+0x7e> @ imm = #0x12
700a7f7a: e7ff         	b	0x700a7f7c <Sciclient_pmSetModuleState+0x6c> @ imm = #-0x2
;         ((reqFlag != 0U) &&
700a7f7c: 980f         	ldr	r0, [sp, #0x3c]
700a7f7e: b150         	cbz	r0, 0x700a7f96 <Sciclient_pmSetModuleState+0x86> @ imm = #0x14
700a7f80: e7ff         	b	0x700a7f82 <Sciclient_pmSetModuleState+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)))
700a7f82: 9800         	ldr	r0, [sp]
700a7f84: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a7f88: 2802         	cmp	r0, #0x2
700a7f8a: d004         	beq	0x700a7f96 <Sciclient_pmSetModuleState+0x86> @ imm = #0x8
700a7f8c: e7ff         	b	0x700a7f8e <Sciclient_pmSetModuleState+0x7e> @ imm = #-0x2
700a7f8e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a7f92: 900d         	str	r0, [sp, #0x34]
;     }
700a7f94: e7ff         	b	0x700a7f96 <Sciclient_pmSetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a7f96: 980d         	ldr	r0, [sp, #0x34]
700a7f98: b012         	add	sp, #0x48
700a7f9a: bd80         	pop	{r7, pc}
700a7f9c: 0000         	movs	r0, r0
700a7f9e: 0000         	movs	r0, r0

700a7fa0 <Sciclient_rmIaEvtRomMapped>:
; {
700a7fa0: b082         	sub	sp, #0x8
700a7fa2: 9001         	str	r0, [sp, #0x4]
700a7fa4: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a7fa8: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a7faa: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a7fae: 9801         	ldr	r0, [sp, #0x4]
700a7fb0: 6980         	ldr	r0, [r0, #0x18]
700a7fb2: b3a8         	cbz	r0, 0x700a8020 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #0x6a
700a7fb4: e7ff         	b	0x700a7fb6 <Sciclient_rmIaEvtRomMapped+0x16> @ imm = #-0x2
700a7fb6: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a7fb8: f88d 0000    	strb.w	r0, [sp]
700a7fbc: e7ff         	b	0x700a7fbe <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x2
700a7fbe: f89d 0000    	ldrb.w	r0, [sp]
700a7fc2: 9901         	ldr	r1, [sp, #0x4]
700a7fc4: 7f09         	ldrb	r1, [r1, #0x1c]
700a7fc6: 4288         	cmp	r0, r1
700a7fc8: da29         	bge	0x700a801e <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0x52
700a7fca: e7ff         	b	0x700a7fcc <Sciclient_rmIaEvtRomMapped+0x2c> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a7fcc: 9801         	ldr	r0, [sp, #0x4]
700a7fce: 6980         	ldr	r0, [r0, #0x18]
700a7fd0: f89d 1000    	ldrb.w	r1, [sp]
700a7fd4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7fd8: 7880         	ldrb	r0, [r0, #0x2]
700a7fda: 07c0         	lsls	r0, r0, #0x1f
700a7fdc: b9c0         	cbnz	r0, 0x700a8010 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x30
700a7fde: e7ff         	b	0x700a7fe0 <Sciclient_rmIaEvtRomMapped+0x40> @ imm = #-0x2
;                 (evt == (inst->rom_usage[i].event - inst->sevt_offset))) {
700a7fe0: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a7fe4: 9a01         	ldr	r2, [sp, #0x4]
700a7fe6: 6991         	ldr	r1, [r2, #0x18]
700a7fe8: f89d 3000    	ldrb.w	r3, [sp]
700a7fec: f831 1023    	ldrh.w	r1, [r1, r3, lsl #2]
700a7ff0: 8912         	ldrh	r2, [r2, #0x8]
700a7ff2: 1a89         	subs	r1, r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a7ff4: 4288         	cmp	r0, r1
700a7ff6: d10b         	bne	0x700a8010 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x16
700a7ff8: e7ff         	b	0x700a7ffa <Sciclient_rmIaEvtRomMapped+0x5a> @ imm = #-0x2
700a7ffa: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a7ffc: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a8000: 9901         	ldr	r1, [sp, #0x4]
700a8002: 6989         	ldr	r1, [r1, #0x18]
700a8004: f89d 2000    	ldrb.w	r2, [sp]
700a8008: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a800c: 7088         	strb	r0, [r1, #0x2]
;                 break;
700a800e: e006         	b	0x700a801e <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0xc
;         }
700a8010: e7ff         	b	0x700a8012 <Sciclient_rmIaEvtRomMapped+0x72> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a8012: f89d 0000    	ldrb.w	r0, [sp]
700a8016: 3001         	adds	r0, #0x1
700a8018: f88d 0000    	strb.w	r0, [sp]
700a801c: e7cf         	b	0x700a7fbe <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x62
;     }
700a801e: e7ff         	b	0x700a8020 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #-0x2
;     return rom_mapped;
700a8020: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a8024: f000 0001    	and	r0, r0, #0x1
700a8028: b002         	add	sp, #0x8
700a802a: 4770         	bx	lr
700a802c: 0000         	movs	r0, r0
700a802e: 0000         	movs	r0, r0

700a8030 <UART_writeCancelNoCB>:
; {
700a8030: b580         	push	{r7, lr}
700a8032: b084         	sub	sp, #0x10
700a8034: 9003         	str	r0, [sp, #0xc]
700a8036: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a8038: 9001         	str	r0, [sp, #0x4]
;     hUartInit = hUart->hUartInit;
700a803a: 9803         	ldr	r0, [sp, #0xc]
700a803c: 6840         	ldr	r0, [r0, #0x4]
700a803e: 9000         	str	r0, [sp]
;     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700a8040: 9803         	ldr	r0, [sp, #0xc]
700a8042: 6800         	ldr	r0, [r0]
700a8044: 2102         	movs	r1, #0x2
700a8046: f7fc fa63    	bl	0x700a4510 <UART_intrDisable> @ imm = #-0x3b3a
;     key = HwiP_disable();
700a804a: f006 eb12    	blx	0x700ae670 <HwiP_disable> @ imm = #0x6624
700a804e: 9002         	str	r0, [sp, #0x8]
;     if ((hUart->writeSizeRemaining) == 0U)
700a8050: 9803         	ldr	r0, [sp, #0xc]
700a8052: 6900         	ldr	r0, [r0, #0x10]
700a8054: b920         	cbnz	r0, 0x700a8060 <UART_writeCancelNoCB+0x30> @ imm = #0x8
700a8056: e7ff         	b	0x700a8058 <UART_writeCancelNoCB+0x28> @ imm = #-0x2
700a8058: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700a805c: 9001         	str	r0, [sp, #0x4]
;     }
700a805e: e027         	b	0x700a80b0 <UART_writeCancelNoCB+0x80> @ imm = #0x4e
;         if (hUartInit->transferMode == UART_CONFIG_MODE_DMA)
700a8060: 9800         	ldr	r0, [sp]
700a8062: 6a00         	ldr	r0, [r0, #0x20]
700a8064: 2803         	cmp	r0, #0x3
700a8066: d111         	bne	0x700a808c <UART_writeCancelNoCB+0x5c> @ imm = #0x22
700a8068: e7ff         	b	0x700a806a <UART_writeCancelNoCB+0x3a> @ imm = #-0x2
;             UART_lld_dmaDisableChannel(hUart, (Bool)TRUE);
700a806a: 9803         	ldr	r0, [sp, #0xc]
700a806c: 2101         	movs	r1, #0x1
700a806e: f7ff fc4f    	bl	0x700a7910 <UART_lld_dmaDisableChannel> @ imm = #-0x762
;             if (hUart->writeTrans.buf != NULL)
700a8072: 9803         	ldr	r0, [sp, #0xc]
700a8074: 6bc0         	ldr	r0, [r0, #0x3c]
700a8076: b120         	cbz	r0, 0x700a8082 <UART_writeCancelNoCB+0x52> @ imm = #0x8
700a8078: e7ff         	b	0x700a807a <UART_writeCancelNoCB+0x4a> @ imm = #-0x2
;                 hUart->writeTrans.count = 0;
700a807a: 9903         	ldr	r1, [sp, #0xc]
700a807c: 2000         	movs	r0, #0x0
700a807e: 6408         	str	r0, [r1, #0x40]
;             }
700a8080: e003         	b	0x700a808a <UART_writeCancelNoCB+0x5a> @ imm = #0x6
;                 hUart->writeCount = 0;
700a8082: 9903         	ldr	r1, [sp, #0xc]
700a8084: 2000         	movs	r0, #0x0
700a8086: 60c8         	str	r0, [r1, #0xc]
700a8088: e7ff         	b	0x700a808a <UART_writeCancelNoCB+0x5a> @ imm = #-0x2
;         }
700a808a: e010         	b	0x700a80ae <UART_writeCancelNoCB+0x7e> @ imm = #0x20
;             hUart->writeBuf = (const uint8_t *)hUart->writeBuf - hUart->writeCount;
700a808c: 9903         	ldr	r1, [sp, #0xc]
700a808e: 6888         	ldr	r0, [r1, #0x8]
700a8090: 68ca         	ldr	r2, [r1, #0xc]
700a8092: 1a80         	subs	r0, r0, r2
700a8094: 6088         	str	r0, [r1, #0x8]
;             if (hUart->writeTrans.buf != NULL)
700a8096: 9803         	ldr	r0, [sp, #0xc]
700a8098: 6bc0         	ldr	r0, [r0, #0x3c]
700a809a: b120         	cbz	r0, 0x700a80a6 <UART_writeCancelNoCB+0x76> @ imm = #0x8
700a809c: e7ff         	b	0x700a809e <UART_writeCancelNoCB+0x6e> @ imm = #-0x2
;                 hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
700a809e: 9903         	ldr	r1, [sp, #0xc]
700a80a0: 68c8         	ldr	r0, [r1, #0xc]
700a80a2: 6408         	str	r0, [r1, #0x40]
;             }
700a80a4: e7ff         	b	0x700a80a6 <UART_writeCancelNoCB+0x76> @ imm = #-0x2
;             hUart->writeSizeRemaining = 0;
700a80a6: 9903         	ldr	r1, [sp, #0xc]
700a80a8: 2000         	movs	r0, #0x0
700a80aa: 6108         	str	r0, [r1, #0x10]
700a80ac: e7ff         	b	0x700a80ae <UART_writeCancelNoCB+0x7e> @ imm = #-0x2
700a80ae: e7ff         	b	0x700a80b0 <UART_writeCancelNoCB+0x80> @ imm = #-0x2
;     HwiP_restore(key);
700a80b0: 9802         	ldr	r0, [sp, #0x8]
700a80b2: f006 eafe    	blx	0x700ae6b0 <HwiP_restore> @ imm = #0x65fc
;     return (status);
700a80b6: 9801         	ldr	r0, [sp, #0x4]
700a80b8: b004         	add	sp, #0x10
700a80ba: bd80         	pop	{r7, pc}
700a80bc: 0000         	movs	r0, r0
700a80be: 0000         	movs	r0, r0

700a80c0 <Udma_ringFlushRaw>:
; {
700a80c0: b580         	push	{r7, lr}
700a80c2: b086         	sub	sp, #0x18
700a80c4: 9005         	str	r0, [sp, #0x14]
700a80c6: 9104         	str	r1, [sp, #0x10]
700a80c8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a80ca: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a80cc: 9805         	ldr	r0, [sp, #0x14]
700a80ce: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == ringHandleInt) ||
700a80d0: 9801         	ldr	r0, [sp, #0x4]
700a80d2: b180         	cbz	r0, 0x700a80f6 <Udma_ringFlushRaw+0x36> @ imm = #0x20
700a80d4: e7ff         	b	0x700a80d6 <Udma_ringFlushRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a80d6: 9801         	ldr	r0, [sp, #0x4]
700a80d8: 6d80         	ldr	r0, [r0, #0x58]
700a80da: f64a 31cd    	movw	r1, #0xabcd
700a80de: f6ca 31dc    	movt	r1, #0xabdc
700a80e2: 4288         	cmp	r0, r1
700a80e4: d107         	bne	0x700a80f6 <Udma_ringFlushRaw+0x36> @ imm = #0xe
700a80e6: e7ff         	b	0x700a80e8 <Udma_ringFlushRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a80e8: 9801         	ldr	r0, [sp, #0x4]
700a80ea: 8880         	ldrh	r0, [r0, #0x4]
700a80ec: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a80f0: 4288         	cmp	r0, r1
700a80f2: d104         	bne	0x700a80fe <Udma_ringFlushRaw+0x3e> @ imm = #0x8
700a80f4: e7ff         	b	0x700a80f6 <Udma_ringFlushRaw+0x36> @ imm = #-0x2
700a80f6: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a80fa: 9003         	str	r0, [sp, #0xc]
;     }
700a80fc: e7ff         	b	0x700a80fe <Udma_ringFlushRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a80fe: 9803         	ldr	r0, [sp, #0xc]
700a8100: b9a8         	cbnz	r0, 0x700a812e <Udma_ringFlushRaw+0x6e> @ imm = #0x2a
700a8102: e7ff         	b	0x700a8104 <Udma_ringFlushRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a8104: 9801         	ldr	r0, [sp, #0x4]
700a8106: 6800         	ldr	r0, [r0]
700a8108: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) ||
700a810a: 9802         	ldr	r0, [sp, #0x8]
700a810c: b150         	cbz	r0, 0x700a8124 <Udma_ringFlushRaw+0x64> @ imm = #0x14
700a810e: e7ff         	b	0x700a8110 <Udma_ringFlushRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a8110: 9802         	ldr	r0, [sp, #0x8]
700a8112: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a8116: f64a 31cd    	movw	r1, #0xabcd
700a811a: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a811e: 4288         	cmp	r0, r1
700a8120: d004         	beq	0x700a812c <Udma_ringFlushRaw+0x6c> @ imm = #0x8
700a8122: e7ff         	b	0x700a8124 <Udma_ringFlushRaw+0x64> @ imm = #-0x2
700a8124: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a8128: 9003         	str	r0, [sp, #0xc]
;         }
700a812a: e7ff         	b	0x700a812c <Udma_ringFlushRaw+0x6c> @ imm = #-0x2
;     }
700a812c: e7ff         	b	0x700a812e <Udma_ringFlushRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a812e: 9803         	ldr	r0, [sp, #0xc]
700a8130: b940         	cbnz	r0, 0x700a8144 <Udma_ringFlushRaw+0x84> @ imm = #0x10
700a8132: e7ff         	b	0x700a8134 <Udma_ringFlushRaw+0x74> @ imm = #-0x2
;         retVal = drvHandle->ringFlushRaw(drvHandle, ringHandleInt, phyDescMem);
700a8134: 9802         	ldr	r0, [sp, #0x8]
700a8136: f8d0 3598    	ldr.w	r3, [r0, #0x598]
700a813a: 9901         	ldr	r1, [sp, #0x4]
700a813c: 9a04         	ldr	r2, [sp, #0x10]
700a813e: 4798         	blx	r3
700a8140: 9003         	str	r0, [sp, #0xc]
;     }
700a8142: e7ff         	b	0x700a8144 <Udma_ringFlushRaw+0x84> @ imm = #-0x2
;     return (retVal);
700a8144: 9803         	ldr	r0, [sp, #0xc]
700a8146: b006         	add	sp, #0x18
700a8148: bd80         	pop	{r7, pc}
700a814a: 0000         	movs	r0, r0
700a814c: 0000         	movs	r0, r0
700a814e: 0000         	movs	r0, r0

700a8150 <xQueueGenericReset>:
; {
700a8150: b580         	push	{r7, lr}
700a8152: b084         	sub	sp, #0x10
700a8154: 9003         	str	r0, [sp, #0xc]
700a8156: 9102         	str	r1, [sp, #0x8]
;     Queue_t * const pxQueue = xQueue;
700a8158: 9803         	ldr	r0, [sp, #0xc]
700a815a: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700a815c: f004 fa18    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x4430
;         pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700a8160: 9901         	ldr	r1, [sp, #0x4]
700a8162: 680b         	ldr	r3, [r1]
700a8164: 6bc8         	ldr	r0, [r1, #0x3c]
700a8166: 6c0a         	ldr	r2, [r1, #0x40]
700a8168: fb00 3002    	mla	r0, r0, r2, r3
700a816c: 6088         	str	r0, [r1, #0x8]
;         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
700a816e: 9901         	ldr	r1, [sp, #0x4]
700a8170: 2000         	movs	r0, #0x0
700a8172: 6388         	str	r0, [r1, #0x38]
;         pxQueue->pcWriteTo = pxQueue->pcHead;
700a8174: 9901         	ldr	r1, [sp, #0x4]
700a8176: 6808         	ldr	r0, [r1]
700a8178: 6048         	str	r0, [r1, #0x4]
;         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700a817a: 9901         	ldr	r1, [sp, #0x4]
700a817c: 680b         	ldr	r3, [r1]
700a817e: 6bc8         	ldr	r0, [r1, #0x3c]
700a8180: 6c0a         	ldr	r2, [r1, #0x40]
700a8182: 3801         	subs	r0, #0x1
700a8184: fb00 3002    	mla	r0, r0, r2, r3
700a8188: 60c8         	str	r0, [r1, #0xc]
;         pxQueue->cRxLock = queueUNLOCKED;
700a818a: 9901         	ldr	r1, [sp, #0x4]
700a818c: 20ff         	movs	r0, #0xff
700a818e: f881 0044    	strb.w	r0, [r1, #0x44]
;         pxQueue->cTxLock = queueUNLOCKED;
700a8192: 9901         	ldr	r1, [sp, #0x4]
700a8194: f881 0045    	strb.w	r0, [r1, #0x45]
;         if( xNewQueue == pdFALSE )
700a8198: 9802         	ldr	r0, [sp, #0x8]
700a819a: b980         	cbnz	r0, 0x700a81be <xQueueGenericReset+0x6e> @ imm = #0x20
700a819c: e7ff         	b	0x700a819e <xQueueGenericReset+0x4e> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a819e: 9801         	ldr	r0, [sp, #0x4]
700a81a0: 6900         	ldr	r0, [r0, #0x10]
700a81a2: b150         	cbz	r0, 0x700a81ba <xQueueGenericReset+0x6a> @ imm = #0x14
700a81a4: e7ff         	b	0x700a81a6 <xQueueGenericReset+0x56> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a81a6: 9801         	ldr	r0, [sp, #0x4]
700a81a8: 3010         	adds	r0, #0x10
700a81aa: f7fe f871    	bl	0x700a6290 <xTaskRemoveFromEventList> @ imm = #-0x1f1e
700a81ae: b110         	cbz	r0, 0x700a81b6 <xQueueGenericReset+0x66> @ imm = #0x4
700a81b0: e7ff         	b	0x700a81b2 <xQueueGenericReset+0x62> @ imm = #-0x2
;                     queueYIELD_IF_USING_PREEMPTION();
700a81b2: df00         	svc	#0x0
;                 }
700a81b4: e000         	b	0x700a81b8 <xQueueGenericReset+0x68> @ imm = #0x0
700a81b6: e7ff         	b	0x700a81b8 <xQueueGenericReset+0x68> @ imm = #-0x2
;             }
700a81b8: e000         	b	0x700a81bc <xQueueGenericReset+0x6c> @ imm = #0x0
700a81ba: e7ff         	b	0x700a81bc <xQueueGenericReset+0x6c> @ imm = #-0x2
;         }
700a81bc: e008         	b	0x700a81d0 <xQueueGenericReset+0x80> @ imm = #0x10
;             vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
700a81be: 9801         	ldr	r0, [sp, #0x4]
700a81c0: 3010         	adds	r0, #0x10
700a81c2: f004 fb5d    	bl	0x700ac880 <vListInitialise> @ imm = #0x46ba
;             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
700a81c6: 9801         	ldr	r0, [sp, #0x4]
700a81c8: 3024         	adds	r0, #0x24
700a81ca: f004 fb59    	bl	0x700ac880 <vListInitialise> @ imm = #0x46b2
700a81ce: e7ff         	b	0x700a81d0 <xQueueGenericReset+0x80> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700a81d0: f003 fa9e    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x353c
700a81d4: 2001         	movs	r0, #0x1
;     return pdPASS;
700a81d6: b004         	add	sp, #0x10
700a81d8: bd80         	pop	{r7, pc}
700a81da: 0000         	movs	r0, r0
700a81dc: 0000         	movs	r0, r0
700a81de: 0000         	movs	r0, r0

700a81e0 <CSL_bcdmaGetCfg>:
; {
700a81e0: b580         	push	{r7, lr}
700a81e2: b082         	sub	sp, #0x8
700a81e4: 9001         	str	r0, [sp, #0x4]
;     if( ! ((pCfg == NULL) || (pCfg->pGenCfgRegs == NULL)) )
700a81e6: 9801         	ldr	r0, [sp, #0x4]
700a81e8: b3e0         	cbz	r0, 0x700a8264 <CSL_bcdmaGetCfg+0x84> @ imm = #0x78
700a81ea: e7ff         	b	0x700a81ec <CSL_bcdmaGetCfg+0xc> @ imm = #-0x2
700a81ec: 9801         	ldr	r0, [sp, #0x4]
700a81ee: 6800         	ldr	r0, [r0]
700a81f0: b3c0         	cbz	r0, 0x700a8264 <CSL_bcdmaGetCfg+0x84> @ imm = #0x70
700a81f2: e7ff         	b	0x700a81f4 <CSL_bcdmaGetCfg+0x14> @ imm = #-0x2
;         pCfg->cap0 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP0 );
700a81f4: 9801         	ldr	r0, [sp, #0x4]
700a81f6: 6800         	ldr	r0, [r0]
700a81f8: 3020         	adds	r0, #0x20
700a81fa: f005 fba9    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0x5752
700a81fe: 9901         	ldr	r1, [sp, #0x4]
700a8200: 61c8         	str	r0, [r1, #0x1c]
;         pCfg->cap1 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP1 );
700a8202: 9801         	ldr	r0, [sp, #0x4]
700a8204: 6800         	ldr	r0, [r0]
700a8206: 3024         	adds	r0, #0x24
700a8208: f005 fba2    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0x5744
700a820c: 9901         	ldr	r1, [sp, #0x4]
700a820e: 6208         	str	r0, [r1, #0x20]
;         regVal = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP2 );
700a8210: 9801         	ldr	r0, [sp, #0x4]
700a8212: 6800         	ldr	r0, [r0]
700a8214: 3028         	adds	r0, #0x28
700a8216: f005 fb9b    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0x5736
700a821a: 9000         	str	r0, [sp]
;         pCfg->bcChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_CHAN_CNT );
700a821c: 9800         	ldr	r0, [sp]
700a821e: f36f 205f    	bfc	r0, #9, #23
700a8222: 9901         	ldr	r1, [sp, #0x4]
700a8224: 6248         	str	r0, [r1, #0x24]
;         pCfg->splitTxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_TCHAN_CNT );
700a8226: 9800         	ldr	r0, [sp]
700a8228: f3c0 2048    	ubfx	r0, r0, #0x9, #0x9
700a822c: 9901         	ldr	r1, [sp, #0x4]
700a822e: 62c8         	str	r0, [r1, #0x2c]
;         pCfg->splitRxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_RCHAN_CNT );
700a8230: 9800         	ldr	r0, [sp]
700a8232: f3c0 4088    	ubfx	r0, r0, #0x12, #0x9
700a8236: 9901         	ldr	r1, [sp, #0x4]
700a8238: 6288         	str	r0, [r1, #0x28]
;         pCfg->flowCnt = (uint32_t)0U;
700a823a: 9901         	ldr	r1, [sp, #0x4]
700a823c: 2000         	movs	r0, #0x0
700a823e: 6308         	str	r0, [r1, #0x30]
;         pCfg->txChanCnt                     = pCfg->bcChanCnt + pCfg->splitTxChanCnt;
700a8240: 9a01         	ldr	r2, [sp, #0x4]
700a8242: 6a51         	ldr	r1, [r2, #0x24]
700a8244: 6ad3         	ldr	r3, [r2, #0x2c]
700a8246: 4419         	add	r1, r3
700a8248: 6351         	str	r1, [r2, #0x34]
;         pCfg->rxChanCnt                     = pCfg->splitRxChanCnt;
700a824a: 9a01         	ldr	r2, [sp, #0x4]
700a824c: 6a91         	ldr	r1, [r2, #0x28]
700a824e: 6391         	str	r1, [r2, #0x38]
;         pCfg->rxFlowCnt                     = pCfg->flowCnt;
700a8250: 9a01         	ldr	r2, [sp, #0x4]
700a8252: 6b11         	ldr	r1, [r2, #0x30]
700a8254: 63d1         	str	r1, [r2, #0x3c]
;         pCfg->txExtUtcChanCnt               = (uint32_t)0U;
700a8256: 9901         	ldr	r1, [sp, #0x4]
700a8258: 6408         	str	r0, [r1, #0x40]
;         pCfg->txHighCapacityChanCnt         = (uint32_t)0U;
700a825a: 9901         	ldr	r1, [sp, #0x4]
700a825c: 6448         	str	r0, [r1, #0x44]
;         pCfg->txUltraHighCapacityChanCnt    = (uint32_t)0U;
700a825e: 9901         	ldr	r1, [sp, #0x4]
700a8260: 6488         	str	r0, [r1, #0x48]
;     }
700a8262: e7ff         	b	0x700a8264 <CSL_bcdmaGetCfg+0x84> @ imm = #-0x2
; }
700a8264: b002         	add	sp, #0x8
700a8266: bd80         	pop	{r7, pc}
		...

700a8270 <Udma_rmFreeVintrBit>:
; {
700a8270: b580         	push	{r7, lr}
700a8272: b088         	sub	sp, #0x20
700a8274: 9007         	str	r0, [sp, #0x1c]
700a8276: 9106         	str	r1, [sp, #0x18]
700a8278: 9205         	str	r2, [sp, #0x14]
;     controllerEventHandle = eventHandle;
700a827a: 9805         	ldr	r0, [sp, #0x14]
700a827c: 9001         	str	r0, [sp, #0x4]
;     eventPrms = &eventHandle->eventPrms;
700a827e: 9805         	ldr	r0, [sp, #0x14]
700a8280: 3008         	adds	r0, #0x8
700a8282: 9000         	str	r0, [sp]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700a8284: 9800         	ldr	r0, [sp]
700a8286: 6900         	ldr	r0, [r0, #0x10]
700a8288: b120         	cbz	r0, 0x700a8294 <Udma_rmFreeVintrBit+0x24> @ imm = #0x8
700a828a: e7ff         	b	0x700a828c <Udma_rmFreeVintrBit+0x1c> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a828c: 9800         	ldr	r0, [sp]
700a828e: 6900         	ldr	r0, [r0, #0x10]
700a8290: 9001         	str	r0, [sp, #0x4]
;     }
700a8292: e7ff         	b	0x700a8294 <Udma_rmFreeVintrBit+0x24> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a8294: 9806         	ldr	r0, [sp, #0x18]
700a8296: f500 609f    	add.w	r0, r0, #0x4f8
700a829a: f04f 31ff    	mov.w	r1, #0xffffffff
700a829e: f000 fa27    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x44e
;     bitMask = ((uint64_t) 1U << vintrBitNum);
700a82a2: 9b07         	ldr	r3, [sp, #0x1c]
700a82a4: f1a3 0220    	sub.w	r2, r3, #0x20
700a82a8: 2101         	movs	r1, #0x1
700a82aa: fa01 fc02    	lsl.w	r12, r1, r2
700a82ae: f1c3 0020    	rsb.w	r0, r3, #0x20
700a82b2: fa21 f000    	lsr.w	r0, r1, r0
700a82b6: 2a00         	cmp	r2, #0x0
700a82b8: bf58         	it	pl
700a82ba: 4660         	movpl	r0, r12
700a82bc: fa01 f103    	lsl.w	r1, r1, r3
700a82c0: 2a00         	cmp	r2, #0x0
700a82c2: bf58         	it	pl
700a82c4: 2100         	movpl	r1, #0x0
700a82c6: 9102         	str	r1, [sp, #0x8]
700a82c8: 9003         	str	r0, [sp, #0xc]
;     controllerEventHandle->vintrBitAllocFlag &= ~bitMask;
700a82ca: f8dd c008    	ldr.w	r12, [sp, #0x8]
700a82ce: 9b03         	ldr	r3, [sp, #0xc]
700a82d0: 9901         	ldr	r1, [sp, #0x4]
700a82d2: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a82d6: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700a82da: ea20 000c    	bic.w	r0, r0, r12
700a82de: ea22 0203    	bic.w	r2, r2, r3
700a82e2: f8c1 208c    	str.w	r2, [r1, #0x8c]
700a82e6: f8c1 0088    	str.w	r0, [r1, #0x88]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a82ea: 9806         	ldr	r0, [sp, #0x18]
700a82ec: f500 609f    	add.w	r0, r0, #0x4f8
700a82f0: f001 fd56    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x1aac
;     return;
700a82f4: b008         	add	sp, #0x20
700a82f6: bd80         	pop	{r7, pc}
		...

700a8300 <SOC_controlModuleLockMMR>:
; {
700a8300: b580         	push	{r7, lr}
700a8302: b086         	sub	sp, #0x18
700a8304: 9005         	str	r0, [sp, #0x14]
700a8306: 9104         	str	r1, [sp, #0x10]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700a8308: 9805         	ldr	r0, [sp, #0x14]
700a830a: b9d8         	cbnz	r0, 0x700a8344 <SOC_controlModuleLockMMR+0x44> @ imm = #0x36
700a830c: e7ff         	b	0x700a830e <SOC_controlModuleLockMMR+0xe> @ imm = #-0x2
700a830e: f04f 4086    	mov.w	r0, #0x43000000
700a8312: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700a8314: 9101         	str	r1, [sp, #0x4]
700a8316: f7fb fd5b    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x454a
700a831a: 9901         	ldr	r1, [sp, #0x4]
700a831c: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a831e: 9803         	ldr	r0, [sp, #0xc]
700a8320: 9a04         	ldr	r2, [sp, #0x10]
700a8322: eb00 3082    	add.w	r0, r0, r2, lsl #14
700a8326: f241 0208    	movw	r2, #0x1008
700a832a: 4410         	add	r0, r2
700a832c: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a832e: 9802         	ldr	r0, [sp, #0x8]
700a8330: f005 fa8e    	bl	0x700ad850 <CSL_REG32_WR_RAW> @ imm = #0x551c
700a8334: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr++;
700a8336: 9802         	ldr	r0, [sp, #0x8]
700a8338: 3004         	adds	r0, #0x4
700a833a: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a833c: 9802         	ldr	r0, [sp, #0x8]
700a833e: f005 fa87    	bl	0x700ad850 <CSL_REG32_WR_RAW> @ imm = #0x550e
;     }
700a8342: e7ff         	b	0x700a8344 <SOC_controlModuleLockMMR+0x44> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700a8344: 9805         	ldr	r0, [sp, #0x14]
700a8346: 2801         	cmp	r0, #0x1
700a8348: d11b         	bne	0x700a8382 <SOC_controlModuleLockMMR+0x82> @ imm = #0x36
700a834a: e7ff         	b	0x700a834c <SOC_controlModuleLockMMR+0x4c> @ imm = #-0x2
700a834c: f04f 608a    	mov.w	r0, #0x4500000
700a8350: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700a8352: 9100         	str	r1, [sp]
700a8354: f7fb fd3c    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x4588
700a8358: 9900         	ldr	r1, [sp]
700a835a: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a835c: 9803         	ldr	r0, [sp, #0xc]
700a835e: 9a04         	ldr	r2, [sp, #0x10]
700a8360: eb00 3082    	add.w	r0, r0, r2, lsl #14
700a8364: f241 0208    	movw	r2, #0x1008
700a8368: 4410         	add	r0, r2
700a836a: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a836c: 9802         	ldr	r0, [sp, #0x8]
700a836e: f005 fa6f    	bl	0x700ad850 <CSL_REG32_WR_RAW> @ imm = #0x54de
700a8372: 9900         	ldr	r1, [sp]
;         kickAddr++;
700a8374: 9802         	ldr	r0, [sp, #0x8]
700a8376: 3004         	adds	r0, #0x4
700a8378: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a837a: 9802         	ldr	r0, [sp, #0x8]
700a837c: f005 fa68    	bl	0x700ad850 <CSL_REG32_WR_RAW> @ imm = #0x54d0
;     }
700a8380: e7ff         	b	0x700a8382 <SOC_controlModuleLockMMR+0x82> @ imm = #-0x2
;     return;
700a8382: b006         	add	sp, #0x18
700a8384: bd80         	pop	{r7, pc}
		...
700a838e: 0000         	movs	r0, r0

700a8390 <UART_lld_flushTxFifo>:
; {
700a8390: b580         	push	{r7, lr}
700a8392: b088         	sub	sp, #0x20
700a8394: 9007         	str	r0, [sp, #0x1c]
700a8396: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700a8398: 9006         	str	r0, [sp, #0x18]
700a839a: f640 31b8    	movw	r1, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700a839e: 9102         	str	r1, [sp, #0x8]
;     uint32_t            timeoutElapsed  = FALSE;
700a83a0: 9001         	str	r0, [sp, #0x4]
;     if (NULL_PTR != hUart)
700a83a2: 9807         	ldr	r0, [sp, #0x1c]
700a83a4: b380         	cbz	r0, 0x700a8408 <UART_lld_flushTxFifo+0x78> @ imm = #0x60
700a83a6: e7ff         	b	0x700a83a8 <UART_lld_flushTxFifo+0x18> @ imm = #-0x2
;         hUartInit = hUart->hUartInit;
700a83a8: 9807         	ldr	r0, [sp, #0x1c]
700a83aa: 6840         	ldr	r0, [r0, #0x4]
700a83ac: 9000         	str	r0, [sp]
;         startTicks = hUartInit->clockP_get();
700a83ae: 9800         	ldr	r0, [sp]
700a83b0: 6d40         	ldr	r0, [r0, #0x54]
700a83b2: 4780         	blx	r0
700a83b4: 9004         	str	r0, [sp, #0x10]
;         while (FALSE == timeoutElapsed)
700a83b6: e7ff         	b	0x700a83b8 <UART_lld_flushTxFifo+0x28> @ imm = #-0x2
700a83b8: 9801         	ldr	r0, [sp, #0x4]
700a83ba: b9e0         	cbnz	r0, 0x700a83f6 <UART_lld_flushTxFifo+0x66> @ imm = #0x38
700a83bc: e7ff         	b	0x700a83be <UART_lld_flushTxFifo+0x2e> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(hUart->baseAddr);
700a83be: 9807         	ldr	r0, [sp, #0x1c]
700a83c0: 6800         	ldr	r0, [r0]
700a83c2: f003 fc8d    	bl	0x700abce0 <UART_spaceAvail> @ imm = #0x391a
700a83c6: 9005         	str	r0, [sp, #0x14]
;             if ((uint32_t) TRUE == isTxFifoEmpty)
700a83c8: 9805         	ldr	r0, [sp, #0x14]
700a83ca: 2801         	cmp	r0, #0x1
700a83cc: d101         	bne	0x700a83d2 <UART_lld_flushTxFifo+0x42> @ imm = #0x2
700a83ce: e7ff         	b	0x700a83d0 <UART_lld_flushTxFifo+0x40> @ imm = #-0x2
;                 break;
700a83d0: e011         	b	0x700a83f6 <UART_lld_flushTxFifo+0x66> @ imm = #0x22
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700a83d2: 9800         	ldr	r0, [sp]
700a83d4: 6d40         	ldr	r0, [r0, #0x54]
700a83d6: 4780         	blx	r0
700a83d8: 9904         	ldr	r1, [sp, #0x10]
700a83da: 1a40         	subs	r0, r0, r1
700a83dc: 9003         	str	r0, [sp, #0xc]
;             if (elapsedTicks >= timeout)
700a83de: 9803         	ldr	r0, [sp, #0xc]
700a83e0: 9902         	ldr	r1, [sp, #0x8]
700a83e2: 4288         	cmp	r0, r1
700a83e4: d303         	blo	0x700a83ee <UART_lld_flushTxFifo+0x5e> @ imm = #0x6
700a83e6: e7ff         	b	0x700a83e8 <UART_lld_flushTxFifo+0x58> @ imm = #-0x2
700a83e8: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700a83ea: 9001         	str	r0, [sp, #0x4]
;             }
700a83ec: e002         	b	0x700a83f4 <UART_lld_flushTxFifo+0x64> @ imm = #0x4
;                 TaskP_yield();
700a83ee: f005 fb57    	bl	0x700adaa0 <TaskP_yield> @ imm = #0x56ae
700a83f2: e7ff         	b	0x700a83f4 <UART_lld_flushTxFifo+0x64> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700a83f4: e7e0         	b	0x700a83b8 <UART_lld_flushTxFifo+0x28> @ imm = #-0x40
;         if(TRUE == timeoutElapsed)
700a83f6: 9801         	ldr	r0, [sp, #0x4]
700a83f8: 2801         	cmp	r0, #0x1
700a83fa: d104         	bne	0x700a8406 <UART_lld_flushTxFifo+0x76> @ imm = #0x8
700a83fc: e7ff         	b	0x700a83fe <UART_lld_flushTxFifo+0x6e> @ imm = #-0x2
700a83fe: f06f 0001    	mvn	r0, #0x1
;             status = UART_TRANSFER_TIMEOUT;
700a8402: 9006         	str	r0, [sp, #0x18]
;         }
700a8404: e7ff         	b	0x700a8406 <UART_lld_flushTxFifo+0x76> @ imm = #-0x2
;     }
700a8406: e003         	b	0x700a8410 <UART_lld_flushTxFifo+0x80> @ imm = #0x6
700a8408: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a840c: 9006         	str	r0, [sp, #0x18]
700a840e: e7ff         	b	0x700a8410 <UART_lld_flushTxFifo+0x80> @ imm = #-0x2
;     return status;
700a8410: 9806         	ldr	r0, [sp, #0x18]
700a8412: b008         	add	sp, #0x20
700a8414: bd80         	pop	{r7, pc}
		...
700a841e: 0000         	movs	r0, r0

700a8420 <UART_tcrTlrBitValRestore>:
; {
700a8420: b580         	push	{r7, lr}
700a8422: b088         	sub	sp, #0x20
700a8424: 9007         	str	r0, [sp, #0x1c]
700a8426: 9106         	str	r1, [sp, #0x18]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a8428: 9807         	ldr	r0, [sp, #0x1c]
700a842a: 21bf         	movs	r1, #0xbf
700a842c: 9101         	str	r1, [sp, #0x4]
700a842e: f002 f92f    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x225e
700a8432: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a8434: 9807         	ldr	r0, [sp, #0x1c]
700a8436: 3008         	adds	r0, #0x8
700a8438: 2110         	movs	r1, #0x10
700a843a: 9102         	str	r1, [sp, #0x8]
700a843c: 2204         	movs	r2, #0x4
700a843e: 9203         	str	r2, [sp, #0xc]
700a8440: f004 fe5e    	bl	0x700ad100 <HW_RD_FIELD32_RAW> @ imm = #0x4cbc
700a8444: 9902         	ldr	r1, [sp, #0x8]
700a8446: 9a03         	ldr	r2, [sp, #0xc]
700a8448: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a844a: 9807         	ldr	r0, [sp, #0x1c]
700a844c: 3008         	adds	r0, #0x8
700a844e: 2301         	movs	r3, #0x1
700a8450: f004 f83e    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x407c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a8454: 9807         	ldr	r0, [sp, #0x1c]
700a8456: 300c         	adds	r0, #0xc
700a8458: 9904         	ldr	r1, [sp, #0x10]
700a845a: f005 fa39    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x5472
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a845e: 9807         	ldr	r0, [sp, #0x1c]
700a8460: 2180         	movs	r1, #0x80
700a8462: f002 f915    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x222a
700a8466: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR, tcrTlrBitVal);
700a8468: 9807         	ldr	r0, [sp, #0x1c]
700a846a: 3010         	adds	r0, #0x10
700a846c: 9b06         	ldr	r3, [sp, #0x18]
700a846e: 2140         	movs	r1, #0x40
700a8470: 2206         	movs	r2, #0x6
700a8472: f004 f82d    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x405a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a8476: 9807         	ldr	r0, [sp, #0x1c]
700a8478: 300c         	adds	r0, #0xc
700a847a: 9904         	ldr	r1, [sp, #0x10]
700a847c: f005 fa28    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x5450
700a8480: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a8482: 9807         	ldr	r0, [sp, #0x1c]
700a8484: f002 f904    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0x2208
700a8488: 9902         	ldr	r1, [sp, #0x8]
700a848a: 9a03         	ldr	r2, [sp, #0xc]
700a848c: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a848e: 9807         	ldr	r0, [sp, #0x1c]
700a8490: 3008         	adds	r0, #0x8
700a8492: 9b05         	ldr	r3, [sp, #0x14]
700a8494: f004 f81c    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x4038
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a8498: 9807         	ldr	r0, [sp, #0x1c]
700a849a: 300c         	adds	r0, #0xc
700a849c: 9904         	ldr	r1, [sp, #0x10]
700a849e: f005 fa17    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x542e
; }
700a84a2: b008         	add	sp, #0x20
700a84a4: bd80         	pop	{r7, pc}
		...
700a84ae: 0000         	movs	r0, r0

700a84b0 <prvInsertTimerInActiveList>:
;     {
700a84b0: b580         	push	{r7, lr}
700a84b2: b086         	sub	sp, #0x18
700a84b4: 9005         	str	r0, [sp, #0x14]
700a84b6: 9104         	str	r1, [sp, #0x10]
700a84b8: 9203         	str	r2, [sp, #0xc]
700a84ba: 9302         	str	r3, [sp, #0x8]
700a84bc: 2000         	movs	r0, #0x0
;         BaseType_t xProcessTimerNow = pdFALSE;
700a84be: 9001         	str	r0, [sp, #0x4]
;         listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
700a84c0: 9804         	ldr	r0, [sp, #0x10]
700a84c2: 9905         	ldr	r1, [sp, #0x14]
700a84c4: 6048         	str	r0, [r1, #0x4]
;         listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700a84c6: 9805         	ldr	r0, [sp, #0x14]
700a84c8: 6100         	str	r0, [r0, #0x10]
;         if( xNextExpiryTime <= xTimeNow )
700a84ca: 9804         	ldr	r0, [sp, #0x10]
700a84cc: 9903         	ldr	r1, [sp, #0xc]
700a84ce: 4288         	cmp	r0, r1
700a84d0: d816         	bhi	0x700a8500 <prvInsertTimerInActiveList+0x50> @ imm = #0x2c
700a84d2: e7ff         	b	0x700a84d4 <prvInsertTimerInActiveList+0x24> @ imm = #-0x2
;             if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
700a84d4: 9803         	ldr	r0, [sp, #0xc]
700a84d6: 9902         	ldr	r1, [sp, #0x8]
700a84d8: 1a40         	subs	r0, r0, r1
700a84da: 9905         	ldr	r1, [sp, #0x14]
700a84dc: 6989         	ldr	r1, [r1, #0x18]
700a84de: 4288         	cmp	r0, r1
700a84e0: d303         	blo	0x700a84ea <prvInsertTimerInActiveList+0x3a> @ imm = #0x6
700a84e2: e7ff         	b	0x700a84e4 <prvInsertTimerInActiveList+0x34> @ imm = #-0x2
700a84e4: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700a84e6: 9001         	str	r0, [sp, #0x4]
;             }
700a84e8: e009         	b	0x700a84fe <prvInsertTimerInActiveList+0x4e> @ imm = #0x12
;                 vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
700a84ea: f644 70c0    	movw	r0, #0x4fc0
700a84ee: f2c7 0008    	movt	r0, #0x7008
700a84f2: 6800         	ldr	r0, [r0]
700a84f4: 9905         	ldr	r1, [sp, #0x14]
700a84f6: 3104         	adds	r1, #0x4
700a84f8: f001 f8d2    	bl	0x700a96a0 <vListInsert> @ imm = #0x11a4
700a84fc: e7ff         	b	0x700a84fe <prvInsertTimerInActiveList+0x4e> @ imm = #-0x2
;         }
700a84fe: e017         	b	0x700a8530 <prvInsertTimerInActiveList+0x80> @ imm = #0x2e
;             if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
700a8500: 9803         	ldr	r0, [sp, #0xc]
700a8502: 9902         	ldr	r1, [sp, #0x8]
700a8504: 4288         	cmp	r0, r1
700a8506: d208         	bhs	0x700a851a <prvInsertTimerInActiveList+0x6a> @ imm = #0x10
700a8508: e7ff         	b	0x700a850a <prvInsertTimerInActiveList+0x5a> @ imm = #-0x2
700a850a: 9804         	ldr	r0, [sp, #0x10]
700a850c: 9902         	ldr	r1, [sp, #0x8]
700a850e: 4288         	cmp	r0, r1
700a8510: d303         	blo	0x700a851a <prvInsertTimerInActiveList+0x6a> @ imm = #0x6
700a8512: e7ff         	b	0x700a8514 <prvInsertTimerInActiveList+0x64> @ imm = #-0x2
700a8514: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700a8516: 9001         	str	r0, [sp, #0x4]
;             }
700a8518: e009         	b	0x700a852e <prvInsertTimerInActiveList+0x7e> @ imm = #0x12
;                 vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700a851a: f644 70b4    	movw	r0, #0x4fb4
700a851e: f2c7 0008    	movt	r0, #0x7008
700a8522: 6800         	ldr	r0, [r0]
700a8524: 9905         	ldr	r1, [sp, #0x14]
700a8526: 3104         	adds	r1, #0x4
700a8528: f001 f8ba    	bl	0x700a96a0 <vListInsert> @ imm = #0x1174
700a852c: e7ff         	b	0x700a852e <prvInsertTimerInActiveList+0x7e> @ imm = #-0x2
700a852e: e7ff         	b	0x700a8530 <prvInsertTimerInActiveList+0x80> @ imm = #-0x2
;         return xProcessTimerNow;
700a8530: 9801         	ldr	r0, [sp, #0x4]
700a8532: b006         	add	sp, #0x18
700a8534: bd80         	pop	{r7, pc}
		...
700a853e: 0000         	movs	r0, r0

700a8540 <prvProcessTimerOrBlockTask>:
;     {
700a8540: b580         	push	{r7, lr}
700a8542: b084         	sub	sp, #0x10
700a8544: 9003         	str	r0, [sp, #0xc]
700a8546: 9102         	str	r1, [sp, #0x8]
;         vTaskSuspendAll();
700a8548: f005 f9e2    	bl	0x700ad910 <vTaskSuspendAll> @ imm = #0x53c4
700a854c: 4668         	mov	r0, sp
;             xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700a854e: f003 f957    	bl	0x700ab800 <prvSampleTimeNow> @ imm = #0x32ae
700a8552: 9001         	str	r0, [sp, #0x4]
;             if( xTimerListsWereSwitched == pdFALSE )
700a8554: 9800         	ldr	r0, [sp]
700a8556: bb88         	cbnz	r0, 0x700a85bc <prvProcessTimerOrBlockTask+0x7c> @ imm = #0x62
700a8558: e7ff         	b	0x700a855a <prvProcessTimerOrBlockTask+0x1a> @ imm = #-0x2
;                 if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
700a855a: 9802         	ldr	r0, [sp, #0x8]
700a855c: b960         	cbnz	r0, 0x700a8578 <prvProcessTimerOrBlockTask+0x38> @ imm = #0x18
700a855e: e7ff         	b	0x700a8560 <prvProcessTimerOrBlockTask+0x20> @ imm = #-0x2
700a8560: 9803         	ldr	r0, [sp, #0xc]
700a8562: 9901         	ldr	r1, [sp, #0x4]
700a8564: 4288         	cmp	r0, r1
700a8566: d807         	bhi	0x700a8578 <prvProcessTimerOrBlockTask+0x38> @ imm = #0xe
700a8568: e7ff         	b	0x700a856a <prvProcessTimerOrBlockTask+0x2a> @ imm = #-0x2
;                     ( void ) xTaskResumeAll();
700a856a: f7f8 fb21    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0x79be
;                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
700a856e: 9803         	ldr	r0, [sp, #0xc]
700a8570: 9901         	ldr	r1, [sp, #0x4]
700a8572: f000 fe55    	bl	0x700a9220 <prvProcessExpiredTimer> @ imm = #0xcaa
;                 }
700a8576: e020         	b	0x700a85ba <prvProcessTimerOrBlockTask+0x7a> @ imm = #0x40
;                     if( xListWasEmpty != pdFALSE )
700a8578: 9802         	ldr	r0, [sp, #0x8]
700a857a: b158         	cbz	r0, 0x700a8594 <prvProcessTimerOrBlockTask+0x54> @ imm = #0x16
700a857c: e7ff         	b	0x700a857e <prvProcessTimerOrBlockTask+0x3e> @ imm = #-0x2
;                         xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
700a857e: f644 70c0    	movw	r0, #0x4fc0
700a8582: f2c7 0008    	movt	r0, #0x7008
700a8586: 6800         	ldr	r0, [r0]
700a8588: 6800         	ldr	r0, [r0]
700a858a: fab0 f080    	clz	r0, r0
700a858e: 0940         	lsrs	r0, r0, #0x5
700a8590: 9002         	str	r0, [sp, #0x8]
;                     }
700a8592: e7ff         	b	0x700a8594 <prvProcessTimerOrBlockTask+0x54> @ imm = #-0x2
;                     vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
700a8594: f240 5024    	movw	r0, #0x524
700a8598: f2c7 000b    	movt	r0, #0x700b
700a859c: 6800         	ldr	r0, [r0]
700a859e: 9903         	ldr	r1, [sp, #0xc]
700a85a0: 9a01         	ldr	r2, [sp, #0x4]
700a85a2: 1a89         	subs	r1, r1, r2
700a85a4: 9a02         	ldr	r2, [sp, #0x8]
700a85a6: f001 fbc3    	bl	0x700a9d30 <vQueueWaitForMessageRestricted> @ imm = #0x1786
;                     if( xTaskResumeAll() == pdFALSE )
700a85aa: f7f8 fb01    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0x79fe
700a85ae: b910         	cbnz	r0, 0x700a85b6 <prvProcessTimerOrBlockTask+0x76> @ imm = #0x4
700a85b0: e7ff         	b	0x700a85b2 <prvProcessTimerOrBlockTask+0x72> @ imm = #-0x2
;                         portYIELD_WITHIN_API();
700a85b2: df00         	svc	#0x0
;                     }
700a85b4: e000         	b	0x700a85b8 <prvProcessTimerOrBlockTask+0x78> @ imm = #0x0
700a85b6: e7ff         	b	0x700a85b8 <prvProcessTimerOrBlockTask+0x78> @ imm = #-0x2
700a85b8: e7ff         	b	0x700a85ba <prvProcessTimerOrBlockTask+0x7a> @ imm = #-0x2
;             }
700a85ba: e002         	b	0x700a85c2 <prvProcessTimerOrBlockTask+0x82> @ imm = #0x4
;                 ( void ) xTaskResumeAll();
700a85bc: f7f8 faf8    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0x7a10
700a85c0: e7ff         	b	0x700a85c2 <prvProcessTimerOrBlockTask+0x82> @ imm = #-0x2
;     }
700a85c2: b004         	add	sp, #0x10
700a85c4: bd80         	pop	{r7, pc}
		...
700a85ce: 0000         	movs	r0, r0

700a85d0 <PowerClock_init>:
; {
700a85d0: b570         	push	{r4, r5, r6, lr}
700a85d2: b082         	sub	sp, #0x8
;     while(gSocModules[i]!=SOC_MODULES_END)
700a85d4: f240 4178    	movw	r1, #0x478
700a85d8: f2c7 010b    	movt	r1, #0x700b
700a85dc: 6808         	ldr	r0, [r1]
700a85de: 1c42         	adds	r2, r0, #0x1
700a85e0: d013         	beq	0x700a860a <PowerClock_init+0x3a> @ imm = #0x26
700a85e2: 1d0c         	adds	r4, r1, #0x4
700a85e4: bf00         	nop
700a85e6: bf00         	nop
700a85e8: bf00         	nop
700a85ea: bf00         	nop
700a85ec: bf00         	nop
700a85ee: bf00         	nop
;         status = SOC_moduleClockEnable(gSocModules[i], 1);
700a85f0: f04f 0101    	mov.w	r1, #0x1
700a85f4: f7ff fa7c    	bl	0x700a7af0 <SOC_moduleClockEnable> @ imm = #-0xb08
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700a85f8: fab0 f080    	clz	r0, r0
700a85fc: 0940         	lsrs	r0, r0, #0x5
700a85fe: f006 fcf7    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x69ee
;     while(gSocModules[i]!=SOC_MODULES_END)
700a8602: f854 0b04    	ldr	r0, [r4], #4
700a8606: 1c41         	adds	r1, r0, #0x1
700a8608: d1f2         	bne	0x700a85f0 <PowerClock_init+0x20> @ imm = #-0x1c
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700a860a: f240 31e8    	movw	r1, #0x3e8
700a860e: f2c7 010b    	movt	r1, #0x700b
700a8612: 6808         	ldr	r0, [r1]
700a8614: 1c42         	adds	r2, r0, #0x1
700a8616: d01b         	beq	0x700a8650 <PowerClock_init+0x80> @ imm = #0x36
700a8618: f101 0408    	add.w	r4, r1, #0x8
700a861c: 2600         	movs	r6, #0x0
700a861e: e00c         	b	0x700a863a <PowerClock_init+0x6a> @ imm = #0x18
;             status = SOC_moduleSetClockFrequency(
700a8620: 461a         	mov	r2, r3
700a8622: 2300         	movs	r3, #0x0
700a8624: f7f5 fc4c    	bl	0x7009dec0 <SOC_moduleSetClockFrequency> @ imm = #-0xa768
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700a8628: fab0 f080    	clz	r0, r0
700a862c: 0940         	lsrs	r0, r0, #0x5
700a862e: f006 fcdf    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x69be
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700a8632: 68a0         	ldr	r0, [r4, #0x8]
700a8634: 3410         	adds	r4, #0x10
700a8636: 1c41         	adds	r1, r0, #0x1
700a8638: d00a         	beq	0x700a8650 <PowerClock_init+0x80> @ imm = #0x14
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700a863a: 6862         	ldr	r2, [r4, #0x4]
700a863c: f854 1c04    	ldr	r1, [r4, #-4]
700a8640: 6823         	ldr	r3, [r4]
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700a8642: 1c55         	adds	r5, r2, #0x1
700a8644: d0ec         	beq	0x700a8620 <PowerClock_init+0x50> @ imm = #-0x28
;             status = SOC_moduleSetClockFrequencyWithParent(
700a8646: e9cd 3600    	strd	r3, r6, [sp]
700a864a: f7f5 fd19    	bl	0x7009e080 <SOC_moduleSetClockFrequencyWithParent> @ imm = #-0xa5ce
700a864e: e7eb         	b	0x700a8628 <PowerClock_init+0x58> @ imm = #-0x2a
; }
700a8650: b002         	add	sp, #0x8
700a8652: bd70         	pop	{r4, r5, r6, pc}
		...

700a8660 <CSL_udmapCppi5SetReturnPolicy>:
; {
700a8660: b085         	sub	sp, #0x14
700a8662: f8dd c018    	ldr.w	r12, [sp, #0x18]
700a8666: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a866a: 9004         	str	r0, [sp, #0x10]
700a866c: 9103         	str	r1, [sp, #0xc]
700a866e: 9202         	str	r2, [sp, #0x8]
700a8670: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700a8672: 9803         	ldr	r0, [sp, #0xc]
700a8674: 2803         	cmp	r0, #0x3
700a8676: d108         	bne	0x700a868a <CSL_udmapCppi5SetReturnPolicy+0x2a> @ imm = #0x10
700a8678: e7ff         	b	0x700a867a <CSL_udmapCppi5SetReturnPolicy+0x1a> @ imm = #-0x2
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700a867a: 9905         	ldr	r1, [sp, #0x14]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETQ, retQnum ) ;
700a867c: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700a8680: f361 4010    	bfi	r0, r1, #16, #1
;         ((CSL_UdmapCppi5TRPD *)pDesc)->retInfo =
700a8684: 9904         	ldr	r1, [sp, #0x10]
700a8686: 6088         	str	r0, [r1, #0x8]
;     }
700a8688: e029         	b	0x700a86de <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #0x52
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2;
700a868a: 9804         	ldr	r0, [sp, #0x10]
700a868c: 6880         	ldr	r0, [r0, #0x8]
700a868e: 9000         	str	r0, [sp]
;         if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO )
700a8690: 9803         	ldr	r0, [sp, #0xc]
700a8692: 2802         	cmp	r0, #0x2
700a8694: d105         	bne	0x700a86a2 <CSL_udmapCppi5SetReturnPolicy+0x42> @ imm = #0xa
700a8696: e7ff         	b	0x700a8698 <CSL_udmapCppi5SetReturnPolicy+0x38> @ imm = #-0x2
;             v &= (CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO2_DATA_OFFSET_MASK);
700a8698: 9800         	ldr	r0, [sp]
700a869a: f36f 0011    	bfc	r0, #0, #18
700a869e: 9000         	str	r0, [sp]
;         }
700a86a0: e00b         	b	0x700a86ba <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #0x16
;             v &= CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK;
700a86a2: 9800         	ldr	r0, [sp]
700a86a4: f000 4078    	and	r0, r0, #0xf8000000
700a86a8: 9000         	str	r0, [sp]
;             v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPOLICY, retPolicy );
700a86aa: 9802         	ldr	r0, [sp, #0x8]
700a86ac: f000 0101    	and	r1, r0, #0x1
700a86b0: 9800         	ldr	r0, [sp]
700a86b2: ea40 4081    	orr.w	r0, r0, r1, lsl #18
700a86b6: 9000         	str	r0, [sp]
700a86b8: e7ff         	b	0x700a86ba <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #-0x2
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700a86ba: 9901         	ldr	r1, [sp, #0x4]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700a86bc: 9a05         	ldr	r2, [sp, #0x14]
700a86be: f44f 3080    	mov.w	r0, #0x10000
700a86c2: ea00 4002    	and.w	r0, r0, r2, lsl #16
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700a86c6: f361 4051    	bfi	r0, r1, #17, #1
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETQ, retQnum );
700a86ca: f8bd 1018    	ldrh.w	r1, [sp, #0x18]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700a86ce: 4401         	add	r1, r0
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700a86d0: 9800         	ldr	r0, [sp]
700a86d2: 4308         	orrs	r0, r1
700a86d4: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2 = v;
700a86d6: 9800         	ldr	r0, [sp]
700a86d8: 9904         	ldr	r1, [sp, #0x10]
700a86da: 6088         	str	r0, [r1, #0x8]
700a86dc: e7ff         	b	0x700a86de <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #-0x2
; }
700a86de: b005         	add	sp, #0x14
700a86e0: 4770         	bx	lr
		...
700a86ee: 0000         	movs	r0, r0

700a86f0 <SemaphoreP_pend>:
; {
700a86f0: b580         	push	{r7, lr}
700a86f2: b086         	sub	sp, #0x18
700a86f4: 9005         	str	r0, [sp, #0x14]
700a86f6: 9104         	str	r1, [sp, #0x10]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700a86f8: 9805         	ldr	r0, [sp, #0x14]
700a86fa: 9003         	str	r0, [sp, #0xc]
700a86fc: 2000         	movs	r0, #0x0
;     uint32_t isSemTaken = 0U;
700a86fe: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700a8700: 9803         	ldr	r0, [sp, #0xc]
700a8702: 6d40         	ldr	r0, [r0, #0x54]
700a8704: b180         	cbz	r0, 0x700a8728 <SemaphoreP_pend+0x38> @ imm = #0x20
700a8706: e7ff         	b	0x700a8708 <SemaphoreP_pend+0x18> @ imm = #-0x2
;         if(HwiP_inISR() == 0U )
700a8708: f005 fcd2    	bl	0x700ae0b0 <HwiP_inISR> @ imm = #0x59a4
700a870c: b938         	cbnz	r0, 0x700a871e <SemaphoreP_pend+0x2e> @ imm = #0xe
700a870e: e7ff         	b	0x700a8710 <SemaphoreP_pend+0x20> @ imm = #-0x2
;             isSemTaken =(uint32_t) xSemaphoreTakeRecursive(pSemaphore->semHndl, timeout);
700a8710: 9803         	ldr	r0, [sp, #0xc]
700a8712: 6d00         	ldr	r0, [r0, #0x50]
700a8714: 9904         	ldr	r1, [sp, #0x10]
700a8716: f002 fc33    	bl	0x700aaf80 <xQueueTakeMutexRecursive> @ imm = #0x2866
700a871a: 9002         	str	r0, [sp, #0x8]
;         }
700a871c: e003         	b	0x700a8726 <SemaphoreP_pend+0x36> @ imm = #0x6
700a871e: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700a8720: f006 fc66    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x68cc
700a8724: e7ff         	b	0x700a8726 <SemaphoreP_pend+0x36> @ imm = #-0x2
;     }
700a8726: e017         	b	0x700a8758 <SemaphoreP_pend+0x68> @ imm = #0x2e
;         if( HwiP_inISR() != 0U )
700a8728: f005 fcc2    	bl	0x700ae0b0 <HwiP_inISR> @ imm = #0x5984
700a872c: b160         	cbz	r0, 0x700a8748 <SemaphoreP_pend+0x58> @ imm = #0x18
700a872e: e7ff         	b	0x700a8730 <SemaphoreP_pend+0x40> @ imm = #-0x2
700a8730: 2100         	movs	r1, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700a8732: 9100         	str	r1, [sp]
;             isSemTaken = (uint32_t) xSemaphoreTakeFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700a8734: 9803         	ldr	r0, [sp, #0xc]
700a8736: 6d00         	ldr	r0, [r0, #0x50]
700a8738: 466a         	mov	r2, sp
700a873a: f7fe fdc9    	bl	0x700a72d0 <xQueueReceiveFromISR> @ imm = #-0x146e
700a873e: 9002         	str	r0, [sp, #0x8]
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700a8740: 9800         	ldr	r0, [sp]
700a8742: f004 fdfd    	bl	0x700ad340 <vPortYeildFromISR> @ imm = #0x4bfa
;         }
700a8746: e006         	b	0x700a8756 <SemaphoreP_pend+0x66> @ imm = #0xc
;             isSemTaken = (uint32_t) xSemaphoreTake(pSemaphore->semHndl, timeout);
700a8748: 9803         	ldr	r0, [sp, #0xc]
700a874a: 6d00         	ldr	r0, [r0, #0x50]
700a874c: 9904         	ldr	r1, [sp, #0x10]
700a874e: f7f6 ffef    	bl	0x7009f730 <xQueueSemaphoreTake> @ imm = #-0x9022
700a8752: 9002         	str	r0, [sp, #0x8]
700a8754: e7ff         	b	0x700a8756 <SemaphoreP_pend+0x66> @ imm = #-0x2
700a8756: e7ff         	b	0x700a8758 <SemaphoreP_pend+0x68> @ imm = #-0x2
;     if(isSemTaken != 0U)
700a8758: 9802         	ldr	r0, [sp, #0x8]
700a875a: b118         	cbz	r0, 0x700a8764 <SemaphoreP_pend+0x74> @ imm = #0x6
700a875c: e7ff         	b	0x700a875e <SemaphoreP_pend+0x6e> @ imm = #-0x2
700a875e: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a8760: 9001         	str	r0, [sp, #0x4]
;     }
700a8762: e003         	b	0x700a876c <SemaphoreP_pend+0x7c> @ imm = #0x6
700a8764: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700a8768: 9001         	str	r0, [sp, #0x4]
700a876a: e7ff         	b	0x700a876c <SemaphoreP_pend+0x7c> @ imm = #-0x2
;     return status;
700a876c: 9801         	ldr	r0, [sp, #0x4]
700a876e: b006         	add	sp, #0x18
700a8770: bd80         	pop	{r7, pc}
		...
700a877e: 0000         	movs	r0, r0

700a8780 <Udma_chPair>:
; {
700a8780: b580         	push	{r7, lr}
700a8782: b088         	sub	sp, #0x20
700a8784: 9007         	str	r0, [sp, #0x1c]
700a8786: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
700a8788: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700a878a: 9807         	ldr	r0, [sp, #0x1c]
700a878c: 6e80         	ldr	r0, [r0, #0x68]
700a878e: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a8790: 9805         	ldr	r0, [sp, #0x14]
700a8792: 6800         	ldr	r0, [r0]
700a8794: 2801         	cmp	r0, #0x1
700a8796: d107         	bne	0x700a87a8 <Udma_chPair+0x28> @ imm = #0xe
700a8798: e7ff         	b	0x700a879a <Udma_chPair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700a879a: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a879c: 7800         	ldrb	r0, [r0]
700a879e: 0740         	lsls	r0, r0, #0x1d
700a87a0: 2800         	cmp	r0, #0x0
700a87a2: d501         	bpl	0x700a87a8 <Udma_chPair+0x28> @ imm = #0x2
700a87a4: e7ff         	b	0x700a87a6 <Udma_chPair+0x26> @ imm = #-0x2
;     }
700a87a6: e029         	b	0x700a87fc <Udma_chPair+0x7c> @ imm = #0x52
;         rmPairReq.nav_id = drvHandle->devIdPsil;
700a87a8: 9805         	ldr	r0, [sp, #0x14]
700a87aa: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700a87ae: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a87b0: 9807         	ldr	r0, [sp, #0x1c]
700a87b2: 7800         	ldrb	r0, [r0]
700a87b4: 07c0         	lsls	r0, r0, #0x1f
700a87b6: b158         	cbz	r0, 0x700a87d0 <Udma_chPair+0x50> @ imm = #0x16
700a87b8: e7ff         	b	0x700a87ba <Udma_chPair+0x3a> @ imm = #-0x2
;             rmPairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700a87ba: 9807         	ldr	r0, [sp, #0x1c]
700a87bc: 6ec0         	ldr	r0, [r0, #0x6c]
700a87be: 9905         	ldr	r1, [sp, #0x14]
700a87c0: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700a87c4: 4408         	add	r0, r1
700a87c6: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->peerThreadId;
700a87c8: 9807         	ldr	r0, [sp, #0x1c]
700a87ca: 6fc0         	ldr	r0, [r0, #0x7c]
700a87cc: 9004         	str	r0, [sp, #0x10]
;         }
700a87ce: e00a         	b	0x700a87e6 <Udma_chPair+0x66> @ imm = #0x14
;             rmPairReq.src_thread = chHandle->peerThreadId;
700a87d0: 9807         	ldr	r0, [sp, #0x1c]
700a87d2: 6fc0         	ldr	r0, [r0, #0x7c]
700a87d4: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700a87d6: 9807         	ldr	r0, [sp, #0x1c]
700a87d8: 6f00         	ldr	r0, [r0, #0x70]
700a87da: 9905         	ldr	r1, [sp, #0x14]
700a87dc: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a87e0: 4408         	add	r0, r1
700a87e2: 9004         	str	r0, [sp, #0x10]
700a87e4: e7ff         	b	0x700a87e6 <Udma_chPair+0x66> @ imm = #-0x2
700a87e6: 4668         	mov	r0, sp
700a87e8: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilPair(&rmPairReq, UDMA_SCICLIENT_TIMEOUT);
700a87ec: f002 f930    	bl	0x700aaa50 <Sciclient_rmPsilPair> @ imm = #0x2260
700a87f0: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700a87f2: 9806         	ldr	r0, [sp, #0x18]
700a87f4: b108         	cbz	r0, 0x700a87fa <Udma_chPair+0x7a> @ imm = #0x2
700a87f6: e7ff         	b	0x700a87f8 <Udma_chPair+0x78> @ imm = #-0x2
;         }
700a87f8: e7ff         	b	0x700a87fa <Udma_chPair+0x7a> @ imm = #-0x2
700a87fa: e7ff         	b	0x700a87fc <Udma_chPair+0x7c> @ imm = #-0x2
;     return (retVal);
700a87fc: 9806         	ldr	r0, [sp, #0x18]
700a87fe: b008         	add	sp, #0x20
700a8800: bd80         	pop	{r7, pc}
		...
700a880e: 0000         	movs	r0, r0

700a8810 <Udma_chUnpair>:
; {
700a8810: b580         	push	{r7, lr}
700a8812: b088         	sub	sp, #0x20
700a8814: 9007         	str	r0, [sp, #0x1c]
700a8816: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a8818: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700a881a: 9807         	ldr	r0, [sp, #0x1c]
700a881c: 6e80         	ldr	r0, [r0, #0x68]
700a881e: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a8820: 9805         	ldr	r0, [sp, #0x14]
700a8822: 6800         	ldr	r0, [r0]
700a8824: 2801         	cmp	r0, #0x1
700a8826: d107         	bne	0x700a8838 <Udma_chUnpair+0x28> @ imm = #0xe
700a8828: e7ff         	b	0x700a882a <Udma_chUnpair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700a882a: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a882c: 7800         	ldrb	r0, [r0]
700a882e: 0740         	lsls	r0, r0, #0x1d
700a8830: 2800         	cmp	r0, #0x0
700a8832: d501         	bpl	0x700a8838 <Udma_chUnpair+0x28> @ imm = #0x2
700a8834: e7ff         	b	0x700a8836 <Udma_chUnpair+0x26> @ imm = #-0x2
;     }
700a8836: e029         	b	0x700a888c <Udma_chUnpair+0x7c> @ imm = #0x52
;         rmUnpairReq.nav_id = drvHandle->devIdPsil;
700a8838: 9805         	ldr	r0, [sp, #0x14]
700a883a: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700a883e: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a8840: 9807         	ldr	r0, [sp, #0x1c]
700a8842: 7800         	ldrb	r0, [r0]
700a8844: 07c0         	lsls	r0, r0, #0x1f
700a8846: b158         	cbz	r0, 0x700a8860 <Udma_chUnpair+0x50> @ imm = #0x16
700a8848: e7ff         	b	0x700a884a <Udma_chUnpair+0x3a> @ imm = #-0x2
;             rmUnpairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700a884a: 9807         	ldr	r0, [sp, #0x1c]
700a884c: 6ec0         	ldr	r0, [r0, #0x6c]
700a884e: 9905         	ldr	r1, [sp, #0x14]
700a8850: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700a8854: 4408         	add	r0, r1
700a8856: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->peerThreadId;
700a8858: 9807         	ldr	r0, [sp, #0x1c]
700a885a: 6fc0         	ldr	r0, [r0, #0x7c]
700a885c: 9004         	str	r0, [sp, #0x10]
;         }
700a885e: e00a         	b	0x700a8876 <Udma_chUnpair+0x66> @ imm = #0x14
;             rmUnpairReq.src_thread = chHandle->peerThreadId;
700a8860: 9807         	ldr	r0, [sp, #0x1c]
700a8862: 6fc0         	ldr	r0, [r0, #0x7c]
700a8864: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700a8866: 9807         	ldr	r0, [sp, #0x1c]
700a8868: 6f00         	ldr	r0, [r0, #0x70]
700a886a: 9905         	ldr	r1, [sp, #0x14]
700a886c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a8870: 4408         	add	r0, r1
700a8872: 9004         	str	r0, [sp, #0x10]
700a8874: e7ff         	b	0x700a8876 <Udma_chUnpair+0x66> @ imm = #-0x2
700a8876: 4668         	mov	r0, sp
700a8878: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilUnpair(&rmUnpairReq, UDMA_SCICLIENT_TIMEOUT);
700a887c: f002 f918    	bl	0x700aaab0 <Sciclient_rmPsilUnpair> @ imm = #0x2230
700a8880: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700a8882: 9806         	ldr	r0, [sp, #0x18]
700a8884: b108         	cbz	r0, 0x700a888a <Udma_chUnpair+0x7a> @ imm = #0x2
700a8886: e7ff         	b	0x700a8888 <Udma_chUnpair+0x78> @ imm = #-0x2
;         }
700a8888: e7ff         	b	0x700a888a <Udma_chUnpair+0x7a> @ imm = #-0x2
700a888a: e7ff         	b	0x700a888c <Udma_chUnpair+0x7c> @ imm = #-0x2
;     return (retVal);
700a888c: 9806         	ldr	r0, [sp, #0x18]
700a888e: b008         	add	sp, #0x20
700a8890: bd80         	pop	{r7, pc}
		...
700a889e: 0000         	movs	r0, r0

700a88a0 <UART_moduleReset>:
; {
700a88a0: b580         	push	{r7, lr}
700a88a2: b088         	sub	sp, #0x20
700a88a4: 9007         	str	r0, [sp, #0x1c]
700a88a6: 2000         	movs	r0, #0x0
;     uint32_t startTicks, elapsedTicks = 0;
700a88a8: 9005         	str	r0, [sp, #0x14]
;     hUartInit = hUart->hUartInit;
700a88aa: 9807         	ldr	r0, [sp, #0x1c]
700a88ac: 6840         	ldr	r0, [r0, #0x4]
700a88ae: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(hUart->baseAddr + UART_SYSC, UART_SYSC_SOFTRESET,
700a88b0: 9807         	ldr	r0, [sp, #0x1c]
700a88b2: 6800         	ldr	r0, [r0]
700a88b4: 3054         	adds	r0, #0x54
700a88b6: 2102         	movs	r1, #0x2
700a88b8: 2301         	movs	r3, #0x1
700a88ba: 461a         	mov	r2, r3
700a88bc: f003 fe08    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x3c10
;     startTicks = hUartInit->clockP_get();
700a88c0: 9804         	ldr	r0, [sp, #0x10]
700a88c2: 6d40         	ldr	r0, [r0, #0x54]
700a88c4: 4780         	blx	r0
700a88c6: 9006         	str	r0, [sp, #0x18]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700a88c8: e7ff         	b	0x700a88ca <UART_moduleReset+0x2a> @ imm = #-0x2
700a88ca: 9807         	ldr	r0, [sp, #0x1c]
700a88cc: 6800         	ldr	r0, [r0]
700a88ce: 3058         	adds	r0, #0x58
700a88d0: 2101         	movs	r1, #0x1
700a88d2: 2200         	movs	r2, #0x0
700a88d4: 9202         	str	r2, [sp, #0x8]
700a88d6: f004 fc13    	bl	0x700ad100 <HW_RD_FIELD32_RAW> @ imm = #0x4826
700a88da: 4601         	mov	r1, r0
700a88dc: 9802         	ldr	r0, [sp, #0x8]
700a88de: 9003         	str	r0, [sp, #0xc]
700a88e0: b989         	cbnz	r1, 0x700a8906 <UART_moduleReset+0x66> @ imm = #0x22
700a88e2: e7ff         	b	0x700a88e4 <UART_moduleReset+0x44> @ imm = #-0x2
700a88e4: 9805         	ldr	r0, [sp, #0x14]
700a88e6: 9000         	str	r0, [sp]
700a88e8: 9804         	ldr	r0, [sp, #0x10]
700a88ea: 6d82         	ldr	r2, [r0, #0x58]
700a88ec: f44f 70fa    	mov.w	r0, #0x1f4
700a88f0: 2100         	movs	r1, #0x0
700a88f2: 9101         	str	r1, [sp, #0x4]
700a88f4: 4790         	blx	r2
700a88f6: 9900         	ldr	r1, [sp]
700a88f8: 4602         	mov	r2, r0
700a88fa: 9801         	ldr	r0, [sp, #0x4]
700a88fc: 4291         	cmp	r1, r2
700a88fe: bf38         	it	lo
700a8900: 2001         	movlo	r0, #0x1
700a8902: 9003         	str	r0, [sp, #0xc]
700a8904: e7ff         	b	0x700a8906 <UART_moduleReset+0x66> @ imm = #-0x2
700a8906: 9803         	ldr	r0, [sp, #0xc]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700a8908: 07c0         	lsls	r0, r0, #0x1f
700a890a: b138         	cbz	r0, 0x700a891c <UART_moduleReset+0x7c> @ imm = #0xe
700a890c: e7ff         	b	0x700a890e <UART_moduleReset+0x6e> @ imm = #-0x2
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700a890e: 9804         	ldr	r0, [sp, #0x10]
700a8910: 6d40         	ldr	r0, [r0, #0x54]
700a8912: 4780         	blx	r0
700a8914: 9906         	ldr	r1, [sp, #0x18]
700a8916: 1a40         	subs	r0, r0, r1
700a8918: 9005         	str	r0, [sp, #0x14]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700a891a: e7d6         	b	0x700a88ca <UART_moduleReset+0x2a> @ imm = #-0x54
; }
700a891c: b008         	add	sp, #0x20
700a891e: bd80         	pop	{r7, pc}

700a8920 <tm_memory_allocation_initialize>:
;    tm_memory_pool_create(0);
700a8920: 2000         	movs	r0, #0x0
700a8922: 2600         	movs	r6, #0x0
700a8924: f005 f8cc    	bl	0x700adac0 <tm_memory_pool_create> @ imm = #0x5198
;    tm_thread_create(0, 10, tm_memory_allocation_thread_0_entry);
700a8928: f64b 5221    	movw	r2, #0xbd21
700a892c: 2000         	movs	r0, #0x0
700a892e: f2c7 020a    	movt	r2, #0x700a
700a8932: 210a         	movs	r1, #0xa
700a8934: f003 fc74    	bl	0x700ac220 <tm_thread_create> @ imm = #0x38e8
;    tm_thread_resume(0);
700a8938: 2000         	movs	r0, #0x0
700a893a: f004 fea9    	bl	0x700ad690 <tm_thread_resume> @ imm = #0x4d52
700a893e: f24f 59c1    	movw	r9, #0xf5c1
700a8942: f644 75cc    	movw	r5, #0x4fcc
700a8946: f24f 5878    	movw	r8, #0xf578
700a894a: f64f 2766    	movw	r7, #0xfa66
700a894e: f2c7 090a    	movt	r9, #0x700a
700a8952: f2c7 0508    	movt	r5, #0x7008
700a8956: f2c7 080a    	movt	r8, #0x700a
700a895a: f2c7 070a    	movt	r7, #0x700a
700a895e: 241e         	movs	r4, #0x1e
700a8960: e00d         	b	0x700a897e <tm_memory_allocation_initialize+0x5e> @ imm = #0x1a
700a8962: bf00         	nop
700a8964: bf00         	nop
700a8966: bf00         	nop
700a8968: bf00         	nop
700a896a: bf00         	nop
700a896c: bf00         	nop
700a896e: bf00         	nop
;       printf("Time Period Total:  %lu\r\n", tm_memory_allocation_counter - last_counter);
700a8970: 1b82         	subs	r2, r0, r6
700a8972: 4639         	mov	r1, r7
700a8974: 2001         	movs	r0, #0x1
700a8976: f7ff f95b    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #-0xd4a
;       last_counter = tm_memory_allocation_counter;
700a897a: 682e         	ldr	r6, [r5]
;    while (1)
700a897c: 341e         	adds	r4, #0x1e
;       tm_thread_sleep(TM_TEST_DURATION);
700a897e: 201e         	movs	r0, #0x1e
700a8980: f005 f856    	bl	0x700ada30 <tm_thread_sleep> @ imm = #0x50ac
;       printf("**** Thread-Metric Memory Allocation Test **** Relative Time: %lu\r\n", relative_time);
700a8984: 4649         	mov	r1, r9
700a8986: 4622         	mov	r2, r4
700a8988: 2001         	movs	r0, #0x1
700a898a: f7ff f951    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #-0xd5e
;       if (tm_memory_allocation_counter == last_counter)
700a898e: 6828         	ldr	r0, [r5]
700a8990: 42b0         	cmp	r0, r6
700a8992: d1ed         	bne	0x700a8970 <tm_memory_allocation_initialize+0x50> @ imm = #-0x26
;          printf("ERROR: Invalid counter value(s). Error allocating/deallocating "
700a8994: 4641         	mov	r1, r8
700a8996: 2001         	movs	r0, #0x1
700a8998: f7ff f94a    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #-0xd6c
;       printf("Time Period Total:  %lu\r\n", tm_memory_allocation_counter - last_counter);
700a899c: 6828         	ldr	r0, [r5]
700a899e: e7e7         	b	0x700a8970 <tm_memory_allocation_initialize+0x50> @ imm = #-0x32

700a89a0 <CSL_bcdmaChanOpIsChanEnabled>:
; {
700a89a0: b580         	push	{r7, lr}
700a89a2: b086         	sub	sp, #0x18
700a89a4: 9005         	str	r0, [sp, #0x14]
700a89a6: 9104         	str	r1, [sp, #0x10]
700a89a8: 9203         	str	r2, [sp, #0xc]
;     switch( chanType )
700a89aa: 9804         	ldr	r0, [sp, #0x10]
700a89ac: 9001         	str	r0, [sp, #0x4]
700a89ae: b140         	cbz	r0, 0x700a89c2 <CSL_bcdmaChanOpIsChanEnabled+0x22> @ imm = #0x10
700a89b0: e7ff         	b	0x700a89b2 <CSL_bcdmaChanOpIsChanEnabled+0x12> @ imm = #-0x2
700a89b2: 9801         	ldr	r0, [sp, #0x4]
700a89b4: 2801         	cmp	r0, #0x1
700a89b6: d010         	beq	0x700a89da <CSL_bcdmaChanOpIsChanEnabled+0x3a> @ imm = #0x20
700a89b8: e7ff         	b	0x700a89ba <CSL_bcdmaChanOpIsChanEnabled+0x1a> @ imm = #-0x2
700a89ba: 9801         	ldr	r0, [sp, #0x4]
700a89bc: 2802         	cmp	r0, #0x2
700a89be: d018         	beq	0x700a89f2 <CSL_bcdmaChanOpIsChanEnabled+0x52> @ imm = #0x30
700a89c0: e023         	b	0x700a8a0a <CSL_bcdmaChanOpIsChanEnabled+0x6a> @ imm = #0x46
;             regVal = CSL_REG32_FEXT( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_EN );
700a89c2: 9805         	ldr	r0, [sp, #0x14]
700a89c4: 6880         	ldr	r0, [r0, #0x8]
700a89c6: 9903         	ldr	r1, [sp, #0xc]
700a89c8: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a89cc: f04f 4100    	mov.w	r1, #0x80000000
700a89d0: 221f         	movs	r2, #0x1f
700a89d2: f004 fa55    	bl	0x700ace80 <CSL_REG32_FEXT_RAW> @ imm = #0x44aa
700a89d6: 9002         	str	r0, [sp, #0x8]
;             break;
700a89d8: e01a         	b	0x700a8a10 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x34
;             regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_EN );
700a89da: 9805         	ldr	r0, [sp, #0x14]
700a89dc: 6900         	ldr	r0, [r0, #0x10]
700a89de: 9903         	ldr	r1, [sp, #0xc]
700a89e0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a89e4: f04f 4100    	mov.w	r1, #0x80000000
700a89e8: 221f         	movs	r2, #0x1f
700a89ea: f004 fa49    	bl	0x700ace80 <CSL_REG32_FEXT_RAW> @ imm = #0x4492
700a89ee: 9002         	str	r0, [sp, #0x8]
;             break;
700a89f0: e00e         	b	0x700a8a10 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x1c
;             regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_EN );
700a89f2: 9805         	ldr	r0, [sp, #0x14]
700a89f4: 6980         	ldr	r0, [r0, #0x18]
700a89f6: 9903         	ldr	r1, [sp, #0xc]
700a89f8: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a89fc: f04f 4100    	mov.w	r1, #0x80000000
700a8a00: 221f         	movs	r2, #0x1f
700a8a02: f004 fa3d    	bl	0x700ace80 <CSL_REG32_FEXT_RAW> @ imm = #0x447a
700a8a06: 9002         	str	r0, [sp, #0x8]
;             break;
700a8a08: e002         	b	0x700a8a10 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x4
700a8a0a: 2000         	movs	r0, #0x0
;             regVal = 0U;
700a8a0c: 9002         	str	r0, [sp, #0x8]
;             break;
700a8a0e: e7ff         	b	0x700a8a10 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700a8a10: 9802         	ldr	r0, [sp, #0x8]
700a8a12: 3801         	subs	r0, #0x1
700a8a14: fab0 f080    	clz	r0, r0
700a8a18: 0940         	lsrs	r0, r0, #0x5
700a8a1a: b006         	add	sp, #0x18
700a8a1c: bd80         	pop	{r7, pc}
700a8a1e: 0000         	movs	r0, r0

700a8a20 <CSL_bcdmaChanOpIsValidChanIdx>:
; {
700a8a20: b084         	sub	sp, #0x10
700a8a22: 9003         	str	r0, [sp, #0xc]
700a8a24: 9102         	str	r1, [sp, #0x8]
700a8a26: 9201         	str	r2, [sp, #0x4]
700a8a28: 2001         	movs	r0, #0x1
;     bool retVal = (bool)true;
700a8a2a: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700a8a2e: 9802         	ldr	r0, [sp, #0x8]
700a8a30: b958         	cbnz	r0, 0x700a8a4a <CSL_bcdmaChanOpIsValidChanIdx+0x2a> @ imm = #0x16
700a8a32: e7ff         	b	0x700a8a34 <CSL_bcdmaChanOpIsValidChanIdx+0x14> @ imm = #-0x2
;         if( chanIdx > pCfg->bcChanCnt )
700a8a34: 9801         	ldr	r0, [sp, #0x4]
700a8a36: 9903         	ldr	r1, [sp, #0xc]
700a8a38: 6a49         	ldr	r1, [r1, #0x24]
700a8a3a: 4288         	cmp	r0, r1
700a8a3c: d904         	bls	0x700a8a48 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #0x8
700a8a3e: e7ff         	b	0x700a8a40 <CSL_bcdmaChanOpIsValidChanIdx+0x20> @ imm = #-0x2
700a8a40: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700a8a42: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700a8a46: e7ff         	b	0x700a8a48 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #-0x2
;     }
700a8a48: e023         	b	0x700a8a92 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #0x46
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a8a4a: 9802         	ldr	r0, [sp, #0x8]
700a8a4c: 2802         	cmp	r0, #0x2
700a8a4e: d10b         	bne	0x700a8a68 <CSL_bcdmaChanOpIsValidChanIdx+0x48> @ imm = #0x16
700a8a50: e7ff         	b	0x700a8a52 <CSL_bcdmaChanOpIsValidChanIdx+0x32> @ imm = #-0x2
;         if( chanIdx > pCfg->splitRxChanCnt )
700a8a52: 9801         	ldr	r0, [sp, #0x4]
700a8a54: 9903         	ldr	r1, [sp, #0xc]
700a8a56: 6a89         	ldr	r1, [r1, #0x28]
700a8a58: 4288         	cmp	r0, r1
700a8a5a: d904         	bls	0x700a8a66 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #0x8
700a8a5c: e7ff         	b	0x700a8a5e <CSL_bcdmaChanOpIsValidChanIdx+0x3e> @ imm = #-0x2
700a8a5e: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700a8a60: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700a8a64: e7ff         	b	0x700a8a66 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #-0x2
;     }
700a8a66: e013         	b	0x700a8a90 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #0x26
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700a8a68: 9802         	ldr	r0, [sp, #0x8]
700a8a6a: 2801         	cmp	r0, #0x1
700a8a6c: d10b         	bne	0x700a8a86 <CSL_bcdmaChanOpIsValidChanIdx+0x66> @ imm = #0x16
700a8a6e: e7ff         	b	0x700a8a70 <CSL_bcdmaChanOpIsValidChanIdx+0x50> @ imm = #-0x2
;         if( chanIdx > pCfg->splitTxChanCnt )
700a8a70: 9801         	ldr	r0, [sp, #0x4]
700a8a72: 9903         	ldr	r1, [sp, #0xc]
700a8a74: 6ac9         	ldr	r1, [r1, #0x2c]
700a8a76: 4288         	cmp	r0, r1
700a8a78: d904         	bls	0x700a8a84 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #0x8
700a8a7a: e7ff         	b	0x700a8a7c <CSL_bcdmaChanOpIsValidChanIdx+0x5c> @ imm = #-0x2
700a8a7c: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700a8a7e: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700a8a82: e7ff         	b	0x700a8a84 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #-0x2
;     }
700a8a84: e003         	b	0x700a8a8e <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #0x6
700a8a86: 2000         	movs	r0, #0x0
;         retVal = (bool)false;
700a8a88: f88d 0003    	strb.w	r0, [sp, #0x3]
700a8a8c: e7ff         	b	0x700a8a8e <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #-0x2
700a8a8e: e7ff         	b	0x700a8a90 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #-0x2
700a8a90: e7ff         	b	0x700a8a92 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #-0x2
;     return retVal;
700a8a92: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a8a96: f000 0001    	and	r0, r0, #0x1
700a8a9a: b004         	add	sp, #0x10
700a8a9c: 4770         	bx	lr
700a8a9e: 0000         	movs	r0, r0

700a8aa0 <CSL_bcdmaMapChanIdx>:
; {
700a8aa0: b084         	sub	sp, #0x10
700a8aa2: 9003         	str	r0, [sp, #0xc]
700a8aa4: 9102         	str	r1, [sp, #0x8]
700a8aa6: 9201         	str	r2, [sp, #0x4]
;     if( chanIdx < pCfg->bcChanCnt )
700a8aa8: 9802         	ldr	r0, [sp, #0x8]
700a8aaa: 9903         	ldr	r1, [sp, #0xc]
700a8aac: 6a49         	ldr	r1, [r1, #0x24]
700a8aae: 4288         	cmp	r0, r1
700a8ab0: d206         	bhs	0x700a8ac0 <CSL_bcdmaMapChanIdx+0x20> @ imm = #0xc
700a8ab2: e7ff         	b	0x700a8ab4 <CSL_bcdmaMapChanIdx+0x14> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_BLOCK_COPY;
700a8ab4: 9901         	ldr	r1, [sp, #0x4]
700a8ab6: 2000         	movs	r0, #0x0
700a8ab8: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx;
700a8aba: 9802         	ldr	r0, [sp, #0x8]
700a8abc: 9000         	str	r0, [sp]
;     }
700a8abe: e02b         	b	0x700a8b18 <CSL_bcdmaMapChanIdx+0x78> @ imm = #0x56
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt) )
700a8ac0: 9802         	ldr	r0, [sp, #0x8]
700a8ac2: 9a03         	ldr	r2, [sp, #0xc]
700a8ac4: 6a51         	ldr	r1, [r2, #0x24]
700a8ac6: 6ad2         	ldr	r2, [r2, #0x2c]
700a8ac8: 4411         	add	r1, r2
700a8aca: 4288         	cmp	r0, r1
700a8acc: d209         	bhs	0x700a8ae2 <CSL_bcdmaMapChanIdx+0x42> @ imm = #0x12
700a8ace: e7ff         	b	0x700a8ad0 <CSL_bcdmaMapChanIdx+0x30> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_TX;
700a8ad0: 9901         	ldr	r1, [sp, #0x4]
700a8ad2: 2001         	movs	r0, #0x1
700a8ad4: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt;
700a8ad6: 9802         	ldr	r0, [sp, #0x8]
700a8ad8: 9903         	ldr	r1, [sp, #0xc]
700a8ada: 6a49         	ldr	r1, [r1, #0x24]
700a8adc: 1a40         	subs	r0, r0, r1
700a8ade: 9000         	str	r0, [sp]
;     }
700a8ae0: e019         	b	0x700a8b16 <CSL_bcdmaMapChanIdx+0x76> @ imm = #0x32
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt + pCfg->splitRxChanCnt) )
700a8ae2: 9802         	ldr	r0, [sp, #0x8]
700a8ae4: 9b03         	ldr	r3, [sp, #0xc]
700a8ae6: 6a59         	ldr	r1, [r3, #0x24]
700a8ae8: 6a9a         	ldr	r2, [r3, #0x28]
700a8aea: 6adb         	ldr	r3, [r3, #0x2c]
700a8aec: 4419         	add	r1, r3
700a8aee: 4411         	add	r1, r2
700a8af0: 4288         	cmp	r0, r1
700a8af2: d20b         	bhs	0x700a8b0c <CSL_bcdmaMapChanIdx+0x6c> @ imm = #0x16
700a8af4: e7ff         	b	0x700a8af6 <CSL_bcdmaMapChanIdx+0x56> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_RX;
700a8af6: 9901         	ldr	r1, [sp, #0x4]
700a8af8: 2002         	movs	r0, #0x2
700a8afa: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt - pCfg->splitTxChanCnt;
700a8afc: 9802         	ldr	r0, [sp, #0x8]
700a8afe: 9903         	ldr	r1, [sp, #0xc]
700a8b00: 6a4a         	ldr	r2, [r1, #0x24]
700a8b02: 6ac9         	ldr	r1, [r1, #0x2c]
700a8b04: 1a80         	subs	r0, r0, r2
700a8b06: 1a40         	subs	r0, r0, r1
700a8b08: 9000         	str	r0, [sp]
;     }
700a8b0a: e003         	b	0x700a8b14 <CSL_bcdmaMapChanIdx+0x74> @ imm = #0x6
700a8b0c: f04f 30ff    	mov.w	r0, #0xffffffff
;         base0chanIdx = CSL_BCDMA_INVALID_CHANNEL_INDEX;
700a8b10: 9000         	str	r0, [sp]
700a8b12: e7ff         	b	0x700a8b14 <CSL_bcdmaMapChanIdx+0x74> @ imm = #-0x2
700a8b14: e7ff         	b	0x700a8b16 <CSL_bcdmaMapChanIdx+0x76> @ imm = #-0x2
700a8b16: e7ff         	b	0x700a8b18 <CSL_bcdmaMapChanIdx+0x78> @ imm = #-0x2
;     return base0chanIdx;
700a8b18: 9800         	ldr	r0, [sp]
700a8b1a: b004         	add	sp, #0x10
700a8b1c: 4770         	bx	lr
700a8b1e: 0000         	movs	r0, r0

700a8b20 <ClockP_getTimeUsec>:
; {
700a8b20: b580         	push	{r7, lr}
700a8b22: b08a         	sub	sp, #0x28
700a8b24: 2000         	movs	r0, #0x0
;     uint64_t ts = 0U;
700a8b26: 9009         	str	r0, [sp, #0x24]
700a8b28: 9008         	str	r0, [sp, #0x20]
;     do {
700a8b2a: e7ff         	b	0x700a8b2c <ClockP_getTimeUsec+0xc> @ imm = #-0x2
;         ticks1 = gClockCtrl.ticks;
700a8b2c: f644 6098    	movw	r0, #0x4e98
700a8b30: f2c7 0008    	movt	r0, #0x7008
700a8b34: 9001         	str	r0, [sp, #0x4]
700a8b36: 6801         	ldr	r1, [r0]
700a8b38: 6842         	ldr	r2, [r0, #0x4]
700a8b3a: 9205         	str	r2, [sp, #0x14]
700a8b3c: 9104         	str	r1, [sp, #0x10]
;         timerCount = ClockP_getTimerCount(gClockCtrl.timerBaseAddr);
700a8b3e: 6ac0         	ldr	r0, [r0, #0x2c]
700a8b40: f004 fea6    	bl	0x700ad890 <ClockP_getTimerCount> @ imm = #0x4d4c
700a8b44: 9901         	ldr	r1, [sp, #0x4]
700a8b46: 9007         	str	r0, [sp, #0x1c]
;         ticks2 = gClockCtrl.ticks;
700a8b48: 6808         	ldr	r0, [r1]
700a8b4a: 6849         	ldr	r1, [r1, #0x4]
700a8b4c: 9103         	str	r1, [sp, #0xc]
700a8b4e: 9002         	str	r0, [sp, #0x8]
;     } while (ticks1 != ticks2);
700a8b50: e7ff         	b	0x700a8b52 <ClockP_getTimeUsec+0x32> @ imm = #-0x2
700a8b52: 9804         	ldr	r0, [sp, #0x10]
700a8b54: 9905         	ldr	r1, [sp, #0x14]
700a8b56: 9a02         	ldr	r2, [sp, #0x8]
700a8b58: 9b03         	ldr	r3, [sp, #0xc]
700a8b5a: 4059         	eors	r1, r3
700a8b5c: ea80 0002    	eor.w	r0, r0, r2
700a8b60: 4308         	orrs	r0, r1
700a8b62: 2800         	cmp	r0, #0x0
700a8b64: d1e2         	bne	0x700a8b2c <ClockP_getTimeUsec+0xc> @ imm = #-0x3c
700a8b66: e7ff         	b	0x700a8b68 <ClockP_getTimeUsec+0x48> @ imm = #-0x2
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700a8b68: 9a02         	ldr	r2, [sp, #0x8]
700a8b6a: 9803         	ldr	r0, [sp, #0xc]
700a8b6c: f644 6198    	movw	r1, #0x4e98
700a8b70: f2c7 0108    	movt	r1, #0x7008
700a8b74: 688b         	ldr	r3, [r1, #0x8]
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700a8b76: f8d1 c030    	ldr.w	r12, [r1, #0x30]
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700a8b7a: fb00 f103    	mul	r1, r0, r3
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700a8b7e: 9807         	ldr	r0, [sp, #0x1c]
700a8b80: eba0 000c    	sub.w	r0, r0, r12
700a8b84: 4358         	muls	r0, r3, r0
700a8b86: ea6f 0c0c    	mvn.w	r12, r12
700a8b8a: fbb0 f0fc    	udiv	r0, r0, r12
;              + (uint64_t) ( /* convert timer count to usecs */
700a8b8e: fbe2 0103    	umlal	r0, r1, r2, r3
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700a8b92: 9109         	str	r1, [sp, #0x24]
700a8b94: 9008         	str	r0, [sp, #0x20]
;     return (ts);
700a8b96: 9808         	ldr	r0, [sp, #0x20]
700a8b98: 9909         	ldr	r1, [sp, #0x24]
700a8b9a: b00a         	add	sp, #0x28
700a8b9c: bd80         	pop	{r7, pc}
700a8b9e: 0000         	movs	r0, r0

700a8ba0 <UART_readData>:
; {
700a8ba0: b580         	push	{r7, lr}
700a8ba2: b086         	sub	sp, #0x18
700a8ba4: 9005         	str	r0, [sp, #0x14]
700a8ba6: 9104         	str	r1, [sp, #0x10]
700a8ba8: 2000         	movs	r0, #0x0
;     uint8_t             readIn = 0;
700a8baa: f88d 000f    	strb.w	r0, [sp, #0xf]
;     uint32_t             rdSize = size;
700a8bae: 9804         	ldr	r0, [sp, #0x10]
700a8bb0: 9001         	str	r0, [sp, #0x4]
;     readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700a8bb2: 9805         	ldr	r0, [sp, #0x14]
700a8bb4: 6800         	ldr	r0, [r0]
700a8bb6: f10d 010f    	add.w	r1, sp, #0xf
700a8bba: f001 fb59    	bl	0x700aa270 <UART_getChar> @ imm = #0x16b2
700a8bbe: 9002         	str	r0, [sp, #0x8]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700a8bc0: e7ff         	b	0x700a8bc2 <UART_readData+0x22> @ imm = #-0x2
700a8bc2: 9901         	ldr	r1, [sp, #0x4]
700a8bc4: 2000         	movs	r0, #0x0
700a8bc6: 9000         	str	r0, [sp]
700a8bc8: b131         	cbz	r1, 0x700a8bd8 <UART_readData+0x38> @ imm = #0xc
700a8bca: e7ff         	b	0x700a8bcc <UART_readData+0x2c> @ imm = #-0x2
700a8bcc: 9802         	ldr	r0, [sp, #0x8]
700a8bce: 2800         	cmp	r0, #0x0
700a8bd0: bf18         	it	ne
700a8bd2: 2001         	movne	r0, #0x1
700a8bd4: 9000         	str	r0, [sp]
700a8bd6: e7ff         	b	0x700a8bd8 <UART_readData+0x38> @ imm = #-0x2
700a8bd8: 9800         	ldr	r0, [sp]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700a8bda: 07c0         	lsls	r0, r0, #0x1f
700a8bdc: b1e0         	cbz	r0, 0x700a8c18 <UART_readData+0x78> @ imm = #0x38
700a8bde: e7ff         	b	0x700a8be0 <UART_readData+0x40> @ imm = #-0x2
;         *(uint8_t *)hUart->readBuf = readIn;
700a8be0: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a8be4: 9905         	ldr	r1, [sp, #0x14]
700a8be6: 6949         	ldr	r1, [r1, #0x14]
700a8be8: 7008         	strb	r0, [r1]
;         hUart->readBuf = (uint8_t *)hUart->readBuf + 1U;
700a8bea: 9905         	ldr	r1, [sp, #0x14]
700a8bec: 6948         	ldr	r0, [r1, #0x14]
700a8bee: 3001         	adds	r0, #0x1
700a8bf0: 6148         	str	r0, [r1, #0x14]
;         hUart->readCount++;
700a8bf2: 9905         	ldr	r1, [sp, #0x14]
700a8bf4: 6988         	ldr	r0, [r1, #0x18]
700a8bf6: 3001         	adds	r0, #0x1
700a8bf8: 6188         	str	r0, [r1, #0x18]
;         rdSize--;
700a8bfa: 9801         	ldr	r0, [sp, #0x4]
700a8bfc: 3801         	subs	r0, #0x1
700a8bfe: 9001         	str	r0, [sp, #0x4]
;         if (rdSize != 0U)
700a8c00: 9801         	ldr	r0, [sp, #0x4]
700a8c02: b140         	cbz	r0, 0x700a8c16 <UART_readData+0x76> @ imm = #0x10
700a8c04: e7ff         	b	0x700a8c06 <UART_readData+0x66> @ imm = #-0x2
;             readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700a8c06: 9805         	ldr	r0, [sp, #0x14]
700a8c08: 6800         	ldr	r0, [r0]
700a8c0a: f10d 010f    	add.w	r1, sp, #0xf
700a8c0e: f001 fb2f    	bl	0x700aa270 <UART_getChar> @ imm = #0x165e
700a8c12: 9002         	str	r0, [sp, #0x8]
;         }
700a8c14: e7ff         	b	0x700a8c16 <UART_readData+0x76> @ imm = #-0x2
;     while ((rdSize != 0U) && (readSuccess != 0U))
700a8c16: e7d4         	b	0x700a8bc2 <UART_readData+0x22> @ imm = #-0x58
;     return (rdSize);
700a8c18: 9801         	ldr	r0, [sp, #0x4]
700a8c1a: b006         	add	sp, #0x18
700a8c1c: bd80         	pop	{r7, pc}
700a8c1e: 0000         	movs	r0, r0

700a8c20 <_DebugP_assert>:
; {
700a8c20: b5b0         	push	{r4, r5, r7, lr}
700a8c22: b08e         	sub	sp, #0x38
700a8c24: f8dd c048    	ldr.w	r12, [sp, #0x48]
700a8c28: 900d         	str	r0, [sp, #0x34]
700a8c2a: 910c         	str	r1, [sp, #0x30]
700a8c2c: 920b         	str	r2, [sp, #0x2c]
700a8c2e: 930a         	str	r3, [sp, #0x28]
;     if(expression==0)
700a8c30: 980d         	ldr	r0, [sp, #0x34]
700a8c32: bb88         	cbnz	r0, 0x700a8c98 <_DebugP_assert+0x78> @ imm = #0x62
700a8c34: e7ff         	b	0x700a8c36 <_DebugP_assert+0x16> @ imm = #-0x2
700a8c36: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700a8c38: 9004         	str	r0, [sp, #0x10]
700a8c3a: 9009         	str	r0, [sp, #0x24]
;         uint64_t curTime = ClockP_getTimeUsec();
700a8c3c: f7ff ff70    	bl	0x700a8b20 <ClockP_getTimeUsec> @ imm = #-0x120
700a8c40: 9107         	str	r1, [sp, #0x1c]
700a8c42: 9006         	str	r0, [sp, #0x18]
;         DebugP_log("ASSERT: %d.%ds: %s:%s:%d: %s failed !!!\r\n",
700a8c44: 9806         	ldr	r0, [sp, #0x18]
700a8c46: 9907         	ldr	r1, [sp, #0x1c]
700a8c48: f244 2240    	movw	r2, #0x4240
700a8c4c: f2c0 020f    	movt	r2, #0xf
700a8c50: 2300         	movs	r3, #0x0
700a8c52: f004 e9b8    	blx	0x700acfc4 <__aeabi_uldivmod> @ imm = #0x4370
700a8c56: 4603         	mov	r3, r0
700a8c58: 9804         	ldr	r0, [sp, #0x10]
700a8c5a: 9305         	str	r3, [sp, #0x14]
700a8c5c: 4613         	mov	r3, r2
700a8c5e: 9a05         	ldr	r2, [sp, #0x14]
700a8c60: 990c         	ldr	r1, [sp, #0x30]
700a8c62: f8dd e02c    	ldr.w	lr, [sp, #0x2c]
700a8c66: 9c0a         	ldr	r4, [sp, #0x28]
700a8c68: 9d12         	ldr	r5, [sp, #0x48]
700a8c6a: 46ec         	mov	r12, sp
700a8c6c: f8cc 500c    	str.w	r5, [r12, #0xc]
700a8c70: f8cc 4008    	str.w	r4, [r12, #0x8]
700a8c74: f8cc e004    	str.w	lr, [r12, #0x4]
700a8c78: f8cc 1000    	str.w	r1, [r12]
700a8c7c: f24f 7148    	movw	r1, #0xf748
700a8c80: f2c7 010a    	movt	r1, #0x700a
700a8c84: f7fe ffd4    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #-0x1058
;         (void) HwiP_disable();
700a8c88: f005 ecf2    	blx	0x700ae670 <HwiP_disable> @ imm = #0x59e4
;         while(assert_loop!= 0U)
700a8c8c: e7ff         	b	0x700a8c8e <_DebugP_assert+0x6e> @ imm = #-0x2
700a8c8e: 9809         	ldr	r0, [sp, #0x24]
700a8c90: b108         	cbz	r0, 0x700a8c96 <_DebugP_assert+0x76> @ imm = #0x2
700a8c92: e7ff         	b	0x700a8c94 <_DebugP_assert+0x74> @ imm = #-0x2
700a8c94: e7fb         	b	0x700a8c8e <_DebugP_assert+0x6e> @ imm = #-0xa
;     }
700a8c96: e7ff         	b	0x700a8c98 <_DebugP_assert+0x78> @ imm = #-0x2
; }
700a8c98: b00e         	add	sp, #0x38
700a8c9a: bdb0         	pop	{r4, r5, r7, pc}
700a8c9c: 0000         	movs	r0, r0
700a8c9e: 0000         	movs	r0, r0

700a8ca0 <prvGetExpectedIdleTime>:
; static TickType_t prvGetExpectedIdleTime(void) {
700a8ca0: b083         	sub	sp, #0xc
700a8ca2: 2000         	movs	r0, #0x0
;   UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
700a8ca4: 9001         	str	r0, [sp, #0x4]
700a8ca6: 2001         	movs	r0, #0x1
;     const UBaseType_t uxLeastSignificantBit = (UBaseType_t)0x01;
700a8ca8: 9000         	str	r0, [sp]
;     if (uxTopReadyPriority > uxLeastSignificantBit) {
700a8caa: f240 5008    	movw	r0, #0x508
700a8cae: f2c7 000b    	movt	r0, #0x700b
700a8cb2: 6800         	ldr	r0, [r0]
700a8cb4: 2802         	cmp	r0, #0x2
700a8cb6: d303         	blo	0x700a8cc0 <prvGetExpectedIdleTime+0x20> @ imm = #0x6
700a8cb8: e7ff         	b	0x700a8cba <prvGetExpectedIdleTime+0x1a> @ imm = #-0x2
700a8cba: 2001         	movs	r0, #0x1
;       uxHigherPriorityReadyTasks = pdTRUE;
700a8cbc: 9001         	str	r0, [sp, #0x4]
;     }
700a8cbe: e7ff         	b	0x700a8cc0 <prvGetExpectedIdleTime+0x20> @ imm = #-0x2
;   if (pxCurrentTCB->uxPriority > tskIDLE_PRIORITY) {
700a8cc0: f240 40dc    	movw	r0, #0x4dc
700a8cc4: f2c7 000b    	movt	r0, #0x700b
700a8cc8: 6800         	ldr	r0, [r0]
700a8cca: 6ac0         	ldr	r0, [r0, #0x2c]
700a8ccc: b118         	cbz	r0, 0x700a8cd6 <prvGetExpectedIdleTime+0x36> @ imm = #0x6
700a8cce: e7ff         	b	0x700a8cd0 <prvGetExpectedIdleTime+0x30> @ imm = #-0x2
700a8cd0: 2000         	movs	r0, #0x0
;     xReturn = 0;
700a8cd2: 9002         	str	r0, [sp, #0x8]
;   } else if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700a8cd4: e01f         	b	0x700a8d16 <prvGetExpectedIdleTime+0x76> @ imm = #0x3e
700a8cd6: f244 40f8    	movw	r0, #0x44f8
700a8cda: f2c7 0008    	movt	r0, #0x7008
700a8cde: 6800         	ldr	r0, [r0]
700a8ce0: 2802         	cmp	r0, #0x2
700a8ce2: d303         	blo	0x700a8cec <prvGetExpectedIdleTime+0x4c> @ imm = #0x6
700a8ce4: e7ff         	b	0x700a8ce6 <prvGetExpectedIdleTime+0x46> @ imm = #-0x2
700a8ce6: 2000         	movs	r0, #0x0
;     xReturn = 0;
700a8ce8: 9002         	str	r0, [sp, #0x8]
;   } else if (uxHigherPriorityReadyTasks != pdFALSE) {
700a8cea: e013         	b	0x700a8d14 <prvGetExpectedIdleTime+0x74> @ imm = #0x26
700a8cec: 9801         	ldr	r0, [sp, #0x4]
700a8cee: b118         	cbz	r0, 0x700a8cf8 <prvGetExpectedIdleTime+0x58> @ imm = #0x6
700a8cf0: e7ff         	b	0x700a8cf2 <prvGetExpectedIdleTime+0x52> @ imm = #-0x2
700a8cf2: 2000         	movs	r0, #0x0
;     xReturn = 0;
700a8cf4: 9002         	str	r0, [sp, #0x8]
;   } else {
700a8cf6: e00c         	b	0x700a8d12 <prvGetExpectedIdleTime+0x72> @ imm = #0x18
;     xReturn = xNextTaskUnblockTime - xTickCount;
700a8cf8: f240 5010    	movw	r0, #0x510
700a8cfc: f2c7 000b    	movt	r0, #0x700b
700a8d00: 6800         	ldr	r0, [r0]
700a8d02: f240 5120    	movw	r1, #0x520
700a8d06: f2c7 010b    	movt	r1, #0x700b
700a8d0a: 6809         	ldr	r1, [r1]
700a8d0c: 1a40         	subs	r0, r0, r1
700a8d0e: 9002         	str	r0, [sp, #0x8]
700a8d10: e7ff         	b	0x700a8d12 <prvGetExpectedIdleTime+0x72> @ imm = #-0x2
700a8d12: e7ff         	b	0x700a8d14 <prvGetExpectedIdleTime+0x74> @ imm = #-0x2
700a8d14: e7ff         	b	0x700a8d16 <prvGetExpectedIdleTime+0x76> @ imm = #-0x2
;   return xReturn;
700a8d16: 9802         	ldr	r0, [sp, #0x8]
700a8d18: b003         	add	sp, #0xc
700a8d1a: 4770         	bx	lr
700a8d1c: 0000         	movs	r0, r0
700a8d1e: 0000         	movs	r0, r0

700a8d20 <UART_Params_init>:
; {
700a8d20: b082         	sub	sp, #0x8
700a8d22: 9001         	str	r0, [sp, #0x4]
;     if(prms != NULL)
700a8d24: 9801         	ldr	r0, [sp, #0x4]
700a8d26: b3b0         	cbz	r0, 0x700a8d96 <UART_Params_init+0x76> @ imm = #0x6c
700a8d28: e7ff         	b	0x700a8d2a <UART_Params_init+0xa> @ imm = #-0x2
;         prms->baudRate           = 115200U;
700a8d2a: 9901         	ldr	r1, [sp, #0x4]
700a8d2c: f44f 30e1    	mov.w	r0, #0x1c200
700a8d30: 6008         	str	r0, [r1]
;         prms->dataLength         = UART_LEN_8;
700a8d32: 9901         	ldr	r1, [sp, #0x4]
700a8d34: 2003         	movs	r0, #0x3
700a8d36: 6048         	str	r0, [r1, #0x4]
;         prms->stopBits           = UART_STOPBITS_1;
700a8d38: 9901         	ldr	r1, [sp, #0x4]
700a8d3a: 2000         	movs	r0, #0x0
700a8d3c: 9000         	str	r0, [sp]
700a8d3e: 6088         	str	r0, [r1, #0x8]
;         prms->parityType         = UART_PARITY_NONE;
700a8d40: 9901         	ldr	r1, [sp, #0x4]
700a8d42: 60c8         	str	r0, [r1, #0xc]
;         prms->readMode           = UART_TRANSFER_MODE_BLOCKING;
700a8d44: 9901         	ldr	r1, [sp, #0x4]
700a8d46: 6108         	str	r0, [r1, #0x10]
;         prms->readReturnMode     = UART_READ_RETURN_MODE_FULL;
700a8d48: 9901         	ldr	r1, [sp, #0x4]
700a8d4a: 6148         	str	r0, [r1, #0x14]
;         prms->writeMode          = UART_TRANSFER_MODE_BLOCKING;
700a8d4c: 9901         	ldr	r1, [sp, #0x4]
700a8d4e: 6188         	str	r0, [r1, #0x18]
;         prms->readCallbackFxn    = NULL;
700a8d50: 9901         	ldr	r1, [sp, #0x4]
700a8d52: 61c8         	str	r0, [r1, #0x1c]
;         prms->writeCallbackFxn   = NULL;
700a8d54: 9901         	ldr	r1, [sp, #0x4]
700a8d56: 6208         	str	r0, [r1, #0x20]
;         prms->hwFlowControl      = FALSE;
700a8d58: 9901         	ldr	r1, [sp, #0x4]
700a8d5a: 6248         	str	r0, [r1, #0x24]
;         prms->hwFlowControlThr   = UART_RXTRIGLVL_16;
700a8d5c: 9a01         	ldr	r2, [sp, #0x4]
700a8d5e: 2110         	movs	r1, #0x10
700a8d60: 6291         	str	r1, [r2, #0x28]
;         prms->intrNum            = 0xFFFF;
700a8d62: 9a01         	ldr	r2, [sp, #0x4]
700a8d64: f64f 71ff    	movw	r1, #0xffff
700a8d68: 6311         	str	r1, [r2, #0x30]
;         prms->transferMode       = UART_CONFIG_MODE_INTERRUPT;
700a8d6a: 9a01         	ldr	r2, [sp, #0x4]
700a8d6c: 2101         	movs	r1, #0x1
700a8d6e: 62d1         	str	r1, [r2, #0x2c]
;         prms->intrPriority       = 4U;
700a8d70: 9a01         	ldr	r2, [sp, #0x4]
700a8d72: 2104         	movs	r1, #0x4
700a8d74: f882 1034    	strb.w	r1, [r2, #0x34]
;         prms->skipIntrReg        = FALSE;
700a8d78: 9901         	ldr	r1, [sp, #0x4]
700a8d7a: 6388         	str	r0, [r1, #0x38]
;         prms->uartDmaIndex       = -1;
700a8d7c: 9a01         	ldr	r2, [sp, #0x4]
700a8d7e: f04f 31ff    	mov.w	r1, #0xffffffff
700a8d82: 63d1         	str	r1, [r2, #0x3c]
;         prms->operMode           = UART_OPER_MODE_16X;
700a8d84: 9901         	ldr	r1, [sp, #0x4]
700a8d86: 6408         	str	r0, [r1, #0x40]
;         prms->rxTrigLvl          = UART_RXTRIGLVL_8;
700a8d88: 9901         	ldr	r1, [sp, #0x4]
700a8d8a: 2008         	movs	r0, #0x8
700a8d8c: 6448         	str	r0, [r1, #0x44]
;         prms->txTrigLvl          = UART_TXTRIGLVL_32;
700a8d8e: 9901         	ldr	r1, [sp, #0x4]
700a8d90: 2020         	movs	r0, #0x20
700a8d92: 6488         	str	r0, [r1, #0x48]
;     }
700a8d94: e7ff         	b	0x700a8d96 <UART_Params_init+0x76> @ imm = #-0x2
; }
700a8d96: b002         	add	sp, #0x8
700a8d98: 4770         	bx	lr
700a8d9a: 0000         	movs	r0, r0
700a8d9c: 0000         	movs	r0, r0
700a8d9e: 0000         	movs	r0, r0

700a8da0 <main_task>:
; {
700a8da0: b5b0         	push	{r4, r5, r7, lr}
700a8da2: b086         	sub	sp, #0x18
;    printf("Starting Thread-Metric tests...\r\n");
700a8da4: f64f 0129    	movw	r1, #0xf829
700a8da8: 2001         	movs	r0, #0x1
700a8daa: f2c7 010a    	movt	r1, #0x700a
700a8dae: 2501         	movs	r5, #0x1
700a8db0: f7fe ff3e    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #-0x1184
;    test_interrupt_handler = tm_isr_message_handler;
700a8db4: f24a 3091    	movw	r0, #0xa391
700a8db8: f240 41e0    	movw	r1, #0x4e0
700a8dbc: f2c7 000a    	movt	r0, #0x700a
700a8dc0: ac01         	add	r4, sp, #0x4
700a8dc2: f2c7 010b    	movt	r1, #0x700b
700a8dc6: 6008         	str	r0, [r1]
;    HwiP_Params_init(&hwiParams);
700a8dc8: 4620         	mov	r0, r4
700a8dca: f004 ff49    	bl	0x700adc60 <HwiP_Params_init> @ imm = #0x4e92
;    hwiParams.callback = tm_interrupt_handler; /* Interrupt handler */
700a8dce: f24d 71b1    	movw	r1, #0xd7b1
700a8dd2: 200a         	movs	r0, #0xa
700a8dd4: f2c7 010a    	movt	r1, #0x700a
;    hwiParams.priority = 1;                    /* Set a valid priority (lower is higher priority) */
700a8dd8: f8ad 5012    	strh.w	r5, [sp, #0x12]
;    hwiParams.intNum = SOFTWARE_INTERRUPT_ID;  /* Chosen interrupt ID */
700a8ddc: e9cd 0101    	strd	r0, r1, [sp, #4]
;    if (HwiP_construct(&hwiObj, &hwiParams) != SystemP_SUCCESS)
700a8de0: f644 60f8    	movw	r0, #0x4ef8
700a8de4: f2c7 0008    	movt	r0, #0x7008
700a8de8: 4621         	mov	r1, r4
700a8dea: f004 ff51    	bl	0x700adc90 <HwiP_construct> @ imm = #0x4ea2
700a8dee: b140         	cbz	r0, 0x700a8e02 <main_task+0x62> @ imm = #0x10
;       printf("Failed to register interrupt\r\n");
700a8df0: f64f 112e    	movw	r1, #0xf92e
700a8df4: 2001         	movs	r0, #0x1
700a8df6: f2c7 010a    	movt	r1, #0x700a
700a8dfa: f7fe ff19    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #-0x11ce
700a8dfe: bf00         	nop
;       while (1)
700a8e00: e7fe         	b	0x700a8e00 <main_task+0x60> @ imm = #-0x4
;    HwiP_enableInt(SOFTWARE_INTERRUPT_ID);
700a8e02: 200a         	movs	r0, #0xa
700a8e04: f004 fe84    	bl	0x700adb10 <HwiP_enableInt> @ imm = #0x4d08
;    HwiP_enable();
700a8e08: f005 ec42    	blx	0x700ae690 <HwiP_enable> @ imm = #0x5884
;    tm_main_four();
700a8e0c: f004 fce0    	bl	0x700ad7d0 <tm_main_four> @ imm = #0x49c0
;    vTaskDelete(NULL);
700a8e10: 2000         	movs	r0, #0x0
700a8e12: f7fa fabd    	bl	0x700a3390 <vTaskDelete> @ imm = #-0x5a86
; }
700a8e16: b006         	add	sp, #0x18
700a8e18: bdb0         	pop	{r4, r5, r7, pc}
700a8e1a: 0000         	movs	r0, r0
700a8e1c: 0000         	movs	r0, r0
700a8e1e: 0000         	movs	r0, r0

700a8e20 <xTimerCreateTimerTask>:
;     {
700a8e20: b580         	push	{r7, lr}
700a8e22: b088         	sub	sp, #0x20
700a8e24: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700a8e26: 9007         	str	r0, [sp, #0x1c]
;         prvCheckForValidListAndQueue();
700a8e28: f7fd fd9a    	bl	0x700a6960 <prvCheckForValidListAndQueue> @ imm = #-0x24cc
;         if( xTimerQueue != NULL )
700a8e2c: f240 5024    	movw	r0, #0x524
700a8e30: f2c7 000b    	movt	r0, #0x700b
700a8e34: 6800         	ldr	r0, [r0]
700a8e36: b358         	cbz	r0, 0x700a8e90 <xTimerCreateTimerTask+0x70> @ imm = #0x56
700a8e38: e7ff         	b	0x700a8e3a <xTimerCreateTimerTask+0x1a> @ imm = #-0x2
700a8e3a: 2000         	movs	r0, #0x0
;                     StaticTask_t * pxTimerTaskTCBBuffer = NULL;
700a8e3c: 9003         	str	r0, [sp, #0xc]
700a8e3e: 9006         	str	r0, [sp, #0x18]
;                     StackType_t * pxTimerTaskStackBuffer = NULL;
700a8e40: 9005         	str	r0, [sp, #0x14]
700a8e42: a806         	add	r0, sp, #0x18
700a8e44: a905         	add	r1, sp, #0x14
700a8e46: aa04         	add	r2, sp, #0x10
;                     vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
700a8e48: f003 fe3a    	bl	0x700acac0 <vApplicationGetTimerTaskMemory> @ imm = #0x3c74
700a8e4c: 9b03         	ldr	r3, [sp, #0xc]
;                                                           ulTimerTaskStackSize,
700a8e4e: 9a04         	ldr	r2, [sp, #0x10]
;                                                           pxTimerTaskStackBuffer,
700a8e50: 9805         	ldr	r0, [sp, #0x14]
;                                                           pxTimerTaskTCBBuffer );
700a8e52: f8dd c018    	ldr.w	r12, [sp, #0x18]
;                     xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
700a8e56: 4669         	mov	r1, sp
700a8e58: f8c1 c008    	str.w	r12, [r1, #0x8]
700a8e5c: 6048         	str	r0, [r1, #0x4]
700a8e5e: 201f         	movs	r0, #0x1f
700a8e60: 6008         	str	r0, [r1]
700a8e62: f24d 2081    	movw	r0, #0xd281
700a8e66: f2c7 000a    	movt	r0, #0x700a
700a8e6a: f240 011e    	movw	r1, #0x1e
700a8e6e: f2c7 010b    	movt	r1, #0x700b
700a8e72: f000 fa15    	bl	0x700a92a0 <xTaskCreateStatic> @ imm = #0x42a
700a8e76: 4601         	mov	r1, r0
700a8e78: f240 5028    	movw	r0, #0x528
700a8e7c: f2c7 000b    	movt	r0, #0x700b
700a8e80: 6001         	str	r1, [r0]
;                     if( xTimerTaskHandle != NULL )
700a8e82: 6800         	ldr	r0, [r0]
700a8e84: b118         	cbz	r0, 0x700a8e8e <xTimerCreateTimerTask+0x6e> @ imm = #0x6
700a8e86: e7ff         	b	0x700a8e88 <xTimerCreateTimerTask+0x68> @ imm = #-0x2
700a8e88: 2001         	movs	r0, #0x1
;                         xReturn = pdPASS;
700a8e8a: 9007         	str	r0, [sp, #0x1c]
;                     }
700a8e8c: e7ff         	b	0x700a8e8e <xTimerCreateTimerTask+0x6e> @ imm = #-0x2
;         }
700a8e8e: e000         	b	0x700a8e92 <xTimerCreateTimerTask+0x72> @ imm = #0x0
700a8e90: e7ff         	b	0x700a8e92 <xTimerCreateTimerTask+0x72> @ imm = #-0x2
;         return xReturn;
700a8e92: 9807         	ldr	r0, [sp, #0x1c]
700a8e94: b008         	add	sp, #0x20
700a8e96: bd80         	pop	{r7, pc}
		...

700a8ea0 <CSL_bcdmaChanOpClearError>:
; {
700a8ea0: b580         	push	{r7, lr}
700a8ea2: b086         	sub	sp, #0x18
700a8ea4: 9005         	str	r0, [sp, #0x14]
700a8ea6: 9104         	str	r1, [sp, #0x10]
700a8ea8: 9203         	str	r2, [sp, #0xc]
700a8eaa: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a8eac: 9002         	str	r0, [sp, #0x8]
;     switch( chanType )
700a8eae: 9804         	ldr	r0, [sp, #0x10]
700a8eb0: 9001         	str	r0, [sp, #0x4]
700a8eb2: b140         	cbz	r0, 0x700a8ec6 <CSL_bcdmaChanOpClearError+0x26> @ imm = #0x10
700a8eb4: e7ff         	b	0x700a8eb6 <CSL_bcdmaChanOpClearError+0x16> @ imm = #-0x2
700a8eb6: 9801         	ldr	r0, [sp, #0x4]
700a8eb8: 2801         	cmp	r0, #0x1
700a8eba: d00f         	beq	0x700a8edc <CSL_bcdmaChanOpClearError+0x3c> @ imm = #0x1e
700a8ebc: e7ff         	b	0x700a8ebe <CSL_bcdmaChanOpClearError+0x1e> @ imm = #-0x2
700a8ebe: 9801         	ldr	r0, [sp, #0x4]
700a8ec0: 2802         	cmp	r0, #0x2
700a8ec2: d016         	beq	0x700a8ef2 <CSL_bcdmaChanOpClearError+0x52> @ imm = #0x2c
700a8ec4: e020         	b	0x700a8f08 <CSL_bcdmaChanOpClearError+0x68> @ imm = #0x40
;             CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700a8ec6: 9805         	ldr	r0, [sp, #0x14]
700a8ec8: 6880         	ldr	r0, [r0, #0x8]
700a8eca: 9903         	ldr	r1, [sp, #0xc]
700a8ecc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8ed0: 2101         	movs	r1, #0x1
700a8ed2: 2300         	movs	r3, #0x0
700a8ed4: 461a         	mov	r2, r3
700a8ed6: f003 f903    	bl	0x700ac0e0 <CSL_REG32_FINS_RAW> @ imm = #0x3206
;             break;
700a8eda: e019         	b	0x700a8f10 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x32
;             CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700a8edc: 9805         	ldr	r0, [sp, #0x14]
700a8ede: 6900         	ldr	r0, [r0, #0x10]
700a8ee0: 9903         	ldr	r1, [sp, #0xc]
700a8ee2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8ee6: 2101         	movs	r1, #0x1
700a8ee8: 2300         	movs	r3, #0x0
700a8eea: 461a         	mov	r2, r3
700a8eec: f003 f8f8    	bl	0x700ac0e0 <CSL_REG32_FINS_RAW> @ imm = #0x31f0
;             break;
700a8ef0: e00e         	b	0x700a8f10 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x1c
;             CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700a8ef2: 9805         	ldr	r0, [sp, #0x14]
700a8ef4: 6980         	ldr	r0, [r0, #0x18]
700a8ef6: 9903         	ldr	r1, [sp, #0xc]
700a8ef8: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8efc: 2101         	movs	r1, #0x1
700a8efe: 2300         	movs	r3, #0x0
700a8f00: 461a         	mov	r2, r3
700a8f02: f003 f8ed    	bl	0x700ac0e0 <CSL_REG32_FINS_RAW> @ imm = #0x31da
;             break;
700a8f06: e003         	b	0x700a8f10 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x6
700a8f08: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700a8f0c: 9002         	str	r0, [sp, #0x8]
;             break;
700a8f0e: e7ff         	b	0x700a8f10 <CSL_bcdmaChanOpClearError+0x70> @ imm = #-0x2
;     return retVal;
700a8f10: 9802         	ldr	r0, [sp, #0x8]
700a8f12: b006         	add	sp, #0x18
700a8f14: bd80         	pop	{r7, pc}
		...
700a8f1e: 0000         	movs	r0, r0

700a8f20 <CSL_bcdmaDoChanOp>:
; {
700a8f20: b580         	push	{r7, lr}
700a8f22: b088         	sub	sp, #0x20
700a8f24: 9007         	str	r0, [sp, #0x1c]
700a8f26: 9106         	str	r1, [sp, #0x18]
700a8f28: 9205         	str	r2, [sp, #0x14]
700a8f2a: 9304         	str	r3, [sp, #0x10]
700a8f2c: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t retVal = CSL_EFAIL;
700a8f30: 9003         	str	r0, [sp, #0xc]
;     if( pCfg == NULL )
700a8f32: 9807         	ldr	r0, [sp, #0x1c]
700a8f34: b920         	cbnz	r0, 0x700a8f40 <CSL_bcdmaDoChanOp+0x20> @ imm = #0x8
700a8f36: e7ff         	b	0x700a8f38 <CSL_bcdmaDoChanOp+0x18> @ imm = #-0x2
700a8f38: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a8f3c: 9003         	str	r0, [sp, #0xc]
;     }
700a8f3e: e027         	b	0x700a8f90 <CSL_bcdmaDoChanOp+0x70> @ imm = #0x4e
;         if( (pCfg->bcChanCnt == (uint32_t)0U) || (pCfg->splitTxChanCnt == (uint32_t)0U) || (pCfg->splitRxChanCnt == (uint32_t)0U) ) {
700a8f40: 9807         	ldr	r0, [sp, #0x1c]
700a8f42: 6a40         	ldr	r0, [r0, #0x24]
700a8f44: b140         	cbz	r0, 0x700a8f58 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x10
700a8f46: e7ff         	b	0x700a8f48 <CSL_bcdmaDoChanOp+0x28> @ imm = #-0x2
700a8f48: 9807         	ldr	r0, [sp, #0x1c]
700a8f4a: 6ac0         	ldr	r0, [r0, #0x2c]
700a8f4c: b120         	cbz	r0, 0x700a8f58 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x8
700a8f4e: e7ff         	b	0x700a8f50 <CSL_bcdmaDoChanOp+0x30> @ imm = #-0x2
700a8f50: 9807         	ldr	r0, [sp, #0x1c]
700a8f52: 6a80         	ldr	r0, [r0, #0x28]
700a8f54: b920         	cbnz	r0, 0x700a8f60 <CSL_bcdmaDoChanOp+0x40> @ imm = #0x8
700a8f56: e7ff         	b	0x700a8f58 <CSL_bcdmaDoChanOp+0x38> @ imm = #-0x2
;             CSL_bcdmaGetCfg( pCfg );
700a8f58: 9807         	ldr	r0, [sp, #0x1c]
700a8f5a: f7ff f941    	bl	0x700a81e0 <CSL_bcdmaGetCfg> @ imm = #-0xd7e
;         }
700a8f5e: e7ff         	b	0x700a8f60 <CSL_bcdmaDoChanOp+0x40> @ imm = #-0x2
;         base0chanIdx = CSL_bcdmaMapChanIdx( pCfg, chanIdx, &chanType );
700a8f60: 9807         	ldr	r0, [sp, #0x1c]
700a8f62: 9905         	ldr	r1, [sp, #0x14]
700a8f64: aa01         	add	r2, sp, #0x4
700a8f66: f7ff fd9b    	bl	0x700a8aa0 <CSL_bcdmaMapChanIdx> @ imm = #-0x4ca
700a8f6a: 9002         	str	r0, [sp, #0x8]
;         if( base0chanIdx != CSL_BCDMA_INVALID_CHANNEL_INDEX )
700a8f6c: 9802         	ldr	r0, [sp, #0x8]
700a8f6e: 3001         	adds	r0, #0x1
700a8f70: b168         	cbz	r0, 0x700a8f8e <CSL_bcdmaDoChanOp+0x6e> @ imm = #0x1a
700a8f72: e7ff         	b	0x700a8f74 <CSL_bcdmaDoChanOp+0x54> @ imm = #-0x2
;             retVal = CSL_bcdmaChanOp( pCfg, chanOp, chanType, base0chanIdx, pOpData );
700a8f74: 9807         	ldr	r0, [sp, #0x1c]
700a8f76: 9906         	ldr	r1, [sp, #0x18]
700a8f78: 9a01         	ldr	r2, [sp, #0x4]
700a8f7a: 9b02         	ldr	r3, [sp, #0x8]
700a8f7c: f8dd c010    	ldr.w	r12, [sp, #0x10]
700a8f80: 46ee         	mov	lr, sp
700a8f82: f8ce c000    	str.w	r12, [lr]
700a8f86: f7f6 fd4b    	bl	0x7009fa20 <CSL_bcdmaChanOp> @ imm = #-0x956a
700a8f8a: 9003         	str	r0, [sp, #0xc]
;         }
700a8f8c: e7ff         	b	0x700a8f8e <CSL_bcdmaDoChanOp+0x6e> @ imm = #-0x2
700a8f8e: e7ff         	b	0x700a8f90 <CSL_bcdmaDoChanOp+0x70> @ imm = #-0x2
;     return retVal;
700a8f90: 9803         	ldr	r0, [sp, #0xc]
700a8f92: b008         	add	sp, #0x20
700a8f94: bd80         	pop	{r7, pc}
		...
700a8f9e: 0000         	movs	r0, r0

700a8fa0 <Udma_chGetCqRingHandle>:
; {
700a8fa0: b085         	sub	sp, #0x14
700a8fa2: 9004         	str	r0, [sp, #0x10]
700a8fa4: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a8fa6: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     cqRing = (Udma_RingHandle) NULL_PTR;
700a8fa8: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a8faa: 9804         	ldr	r0, [sp, #0x10]
700a8fac: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a8fae: 9800         	ldr	r0, [sp]
700a8fb0: b150         	cbz	r0, 0x700a8fc8 <Udma_chGetCqRingHandle+0x28> @ imm = #0x14
700a8fb2: e7ff         	b	0x700a8fb4 <Udma_chGetCqRingHandle+0x14> @ imm = #-0x2
700a8fb4: 9800         	ldr	r0, [sp]
700a8fb6: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a8fba: f64a 31cd    	movw	r1, #0xabcd
700a8fbe: f6ca 31dc    	movt	r1, #0xabdc
700a8fc2: 4288         	cmp	r0, r1
700a8fc4: d004         	beq	0x700a8fd0 <Udma_chGetCqRingHandle+0x30> @ imm = #0x8
700a8fc6: e7ff         	b	0x700a8fc8 <Udma_chGetCqRingHandle+0x28> @ imm = #-0x2
700a8fc8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a8fcc: 9003         	str	r0, [sp, #0xc]
;     }
700a8fce: e7ff         	b	0x700a8fd0 <Udma_chGetCqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a8fd0: 9803         	ldr	r0, [sp, #0xc]
700a8fd2: b9a8         	cbnz	r0, 0x700a9000 <Udma_chGetCqRingHandle+0x60> @ imm = #0x2a
700a8fd4: e7ff         	b	0x700a8fd6 <Udma_chGetCqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a8fd6: 9800         	ldr	r0, [sp]
700a8fd8: 6e80         	ldr	r0, [r0, #0x68]
700a8fda: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a8fdc: 9801         	ldr	r0, [sp, #0x4]
700a8fde: b150         	cbz	r0, 0x700a8ff6 <Udma_chGetCqRingHandle+0x56> @ imm = #0x14
700a8fe0: e7ff         	b	0x700a8fe2 <Udma_chGetCqRingHandle+0x42> @ imm = #-0x2
700a8fe2: 9801         	ldr	r0, [sp, #0x4]
700a8fe4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a8fe8: f64a 31cd    	movw	r1, #0xabcd
700a8fec: f6ca 31dc    	movt	r1, #0xabdc
700a8ff0: 4288         	cmp	r0, r1
700a8ff2: d004         	beq	0x700a8ffe <Udma_chGetCqRingHandle+0x5e> @ imm = #0x8
700a8ff4: e7ff         	b	0x700a8ff6 <Udma_chGetCqRingHandle+0x56> @ imm = #-0x2
700a8ff6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a8ffa: 9003         	str	r0, [sp, #0xc]
;         }
700a8ffc: e7ff         	b	0x700a8ffe <Udma_chGetCqRingHandle+0x5e> @ imm = #-0x2
;     }
700a8ffe: e7ff         	b	0x700a9000 <Udma_chGetCqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9000: 9803         	ldr	r0, [sp, #0xc]
700a9002: b928         	cbnz	r0, 0x700a9010 <Udma_chGetCqRingHandle+0x70> @ imm = #0xa
700a9004: e7ff         	b	0x700a9006 <Udma_chGetCqRingHandle+0x66> @ imm = #-0x2
;         cqRing = (Udma_RingHandle) chHandleInt->cqRing;
700a9006: 9800         	ldr	r0, [sp]
700a9008: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a900c: 9002         	str	r0, [sp, #0x8]
;     }
700a900e: e7ff         	b	0x700a9010 <Udma_chGetCqRingHandle+0x70> @ imm = #-0x2
;     return (cqRing);
700a9010: 9802         	ldr	r0, [sp, #0x8]
700a9012: b005         	add	sp, #0x14
700a9014: 4770         	bx	lr
		...
700a901e: 0000         	movs	r0, r0

700a9020 <Udma_chGetFqRingHandle>:
; {
700a9020: b085         	sub	sp, #0x14
700a9022: 9004         	str	r0, [sp, #0x10]
700a9024: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a9026: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     fqRing = (Udma_RingHandle) NULL_PTR;
700a9028: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a902a: 9804         	ldr	r0, [sp, #0x10]
700a902c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a902e: 9800         	ldr	r0, [sp]
700a9030: b150         	cbz	r0, 0x700a9048 <Udma_chGetFqRingHandle+0x28> @ imm = #0x14
700a9032: e7ff         	b	0x700a9034 <Udma_chGetFqRingHandle+0x14> @ imm = #-0x2
700a9034: 9800         	ldr	r0, [sp]
700a9036: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a903a: f64a 31cd    	movw	r1, #0xabcd
700a903e: f6ca 31dc    	movt	r1, #0xabdc
700a9042: 4288         	cmp	r0, r1
700a9044: d004         	beq	0x700a9050 <Udma_chGetFqRingHandle+0x30> @ imm = #0x8
700a9046: e7ff         	b	0x700a9048 <Udma_chGetFqRingHandle+0x28> @ imm = #-0x2
700a9048: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a904c: 9003         	str	r0, [sp, #0xc]
;     }
700a904e: e7ff         	b	0x700a9050 <Udma_chGetFqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9050: 9803         	ldr	r0, [sp, #0xc]
700a9052: b9a8         	cbnz	r0, 0x700a9080 <Udma_chGetFqRingHandle+0x60> @ imm = #0x2a
700a9054: e7ff         	b	0x700a9056 <Udma_chGetFqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a9056: 9800         	ldr	r0, [sp]
700a9058: 6e80         	ldr	r0, [r0, #0x68]
700a905a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a905c: 9801         	ldr	r0, [sp, #0x4]
700a905e: b150         	cbz	r0, 0x700a9076 <Udma_chGetFqRingHandle+0x56> @ imm = #0x14
700a9060: e7ff         	b	0x700a9062 <Udma_chGetFqRingHandle+0x42> @ imm = #-0x2
700a9062: 9801         	ldr	r0, [sp, #0x4]
700a9064: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a9068: f64a 31cd    	movw	r1, #0xabcd
700a906c: f6ca 31dc    	movt	r1, #0xabdc
700a9070: 4288         	cmp	r0, r1
700a9072: d004         	beq	0x700a907e <Udma_chGetFqRingHandle+0x5e> @ imm = #0x8
700a9074: e7ff         	b	0x700a9076 <Udma_chGetFqRingHandle+0x56> @ imm = #-0x2
700a9076: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a907a: 9003         	str	r0, [sp, #0xc]
;         }
700a907c: e7ff         	b	0x700a907e <Udma_chGetFqRingHandle+0x5e> @ imm = #-0x2
;     }
700a907e: e7ff         	b	0x700a9080 <Udma_chGetFqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9080: 9803         	ldr	r0, [sp, #0xc]
700a9082: b928         	cbnz	r0, 0x700a9090 <Udma_chGetFqRingHandle+0x70> @ imm = #0xa
700a9084: e7ff         	b	0x700a9086 <Udma_chGetFqRingHandle+0x66> @ imm = #-0x2
;         fqRing = (Udma_RingHandle) chHandleInt->fqRing;
700a9086: 9800         	ldr	r0, [sp]
700a9088: f8d0 0080    	ldr.w	r0, [r0, #0x80]
700a908c: 9002         	str	r0, [sp, #0x8]
;     }
700a908e: e7ff         	b	0x700a9090 <Udma_chGetFqRingHandle+0x70> @ imm = #-0x2
;     return (fqRing);
700a9090: 9802         	ldr	r0, [sp, #0x8]
700a9092: b005         	add	sp, #0x14
700a9094: 4770         	bx	lr
		...
700a909e: 0000         	movs	r0, r0

700a90a0 <ClockP_usleep>:
; {
700a90a0: b580         	push	{r7, lr}
700a90a2: b088         	sub	sp, #0x20
700a90a4: 9007         	str	r0, [sp, #0x1c]
;     curTime = ClockP_getTimeUsec();
700a90a6: f7ff fd3b    	bl	0x700a8b20 <ClockP_getTimeUsec> @ imm = #-0x58a
700a90aa: 9105         	str	r1, [sp, #0x14]
700a90ac: 9004         	str	r0, [sp, #0x10]
;     endTime = curTime + usec;
700a90ae: 9904         	ldr	r1, [sp, #0x10]
700a90b0: 9805         	ldr	r0, [sp, #0x14]
700a90b2: 9a07         	ldr	r2, [sp, #0x1c]
700a90b4: 1889         	adds	r1, r1, r2
700a90b6: f140 0000    	adc	r0, r0, #0x0
700a90ba: 9102         	str	r1, [sp, #0x8]
700a90bc: 9003         	str	r0, [sp, #0xc]
;     if (usec >= gClockCtrl.usecPerTick) {
700a90be: 9807         	ldr	r0, [sp, #0x1c]
700a90c0: f644 6198    	movw	r1, #0x4e98
700a90c4: f2c7 0108    	movt	r1, #0x7008
700a90c8: 6889         	ldr	r1, [r1, #0x8]
700a90ca: 4288         	cmp	r0, r1
700a90cc: d30d         	blo	0x700a90ea <ClockP_usleep+0x4a> @ imm = #0x1a
700a90ce: e7ff         	b	0x700a90d0 <ClockP_usleep+0x30> @ imm = #-0x2
;         ticksToSleep = usec / gClockCtrl.usecPerTick;
700a90d0: 9807         	ldr	r0, [sp, #0x1c]
700a90d2: f644 6198    	movw	r1, #0x4e98
700a90d6: f2c7 0108    	movt	r1, #0x7008
700a90da: 6889         	ldr	r1, [r1, #0x8]
700a90dc: fbb0 f0f1    	udiv	r0, r0, r1
700a90e0: 9001         	str	r0, [sp, #0x4]
;         ClockP_sleepTicks(ticksToSleep);
700a90e2: 9801         	ldr	r0, [sp, #0x4]
700a90e4: f004 fbdc    	bl	0x700ad8a0 <ClockP_sleepTicks> @ imm = #0x47b8
;     }
700a90e8: e012         	b	0x700a9110 <ClockP_usleep+0x70> @ imm = #0x24
;         curTime = ClockP_getTimeUsec();
700a90ea: f7ff fd19    	bl	0x700a8b20 <ClockP_getTimeUsec> @ imm = #-0x5ce
700a90ee: 9105         	str	r1, [sp, #0x14]
700a90f0: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700a90f2: e7ff         	b	0x700a90f4 <ClockP_usleep+0x54> @ imm = #-0x2
700a90f4: 9a04         	ldr	r2, [sp, #0x10]
700a90f6: 9805         	ldr	r0, [sp, #0x14]
700a90f8: 9b02         	ldr	r3, [sp, #0x8]
700a90fa: 9903         	ldr	r1, [sp, #0xc]
700a90fc: 1ad2         	subs	r2, r2, r3
700a90fe: 4188         	sbcs	r0, r1
700a9100: d205         	bhs	0x700a910e <ClockP_usleep+0x6e> @ imm = #0xa
700a9102: e7ff         	b	0x700a9104 <ClockP_usleep+0x64> @ imm = #-0x2
;             curTime = ClockP_getTimeUsec();
700a9104: f7ff fd0c    	bl	0x700a8b20 <ClockP_getTimeUsec> @ imm = #-0x5e8
700a9108: 9105         	str	r1, [sp, #0x14]
700a910a: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700a910c: e7f2         	b	0x700a90f4 <ClockP_usleep+0x54> @ imm = #-0x1c
700a910e: e7ff         	b	0x700a9110 <ClockP_usleep+0x70> @ imm = #-0x2
; }
700a9110: b008         	add	sp, #0x20
700a9112: bd80         	pop	{r7, pc}
		...

700a9120 <Udma_chEnable>:
; {
700a9120: b580         	push	{r7, lr}
700a9122: b084         	sub	sp, #0x10
700a9124: 9003         	str	r0, [sp, #0xc]
700a9126: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a9128: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a912a: 9803         	ldr	r0, [sp, #0xc]
700a912c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a912e: 9800         	ldr	r0, [sp]
700a9130: b150         	cbz	r0, 0x700a9148 <Udma_chEnable+0x28> @ imm = #0x14
700a9132: e7ff         	b	0x700a9134 <Udma_chEnable+0x14> @ imm = #-0x2
700a9134: 9800         	ldr	r0, [sp]
700a9136: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a913a: f64a 31cd    	movw	r1, #0xabcd
700a913e: f6ca 31dc    	movt	r1, #0xabdc
700a9142: 4288         	cmp	r0, r1
700a9144: d004         	beq	0x700a9150 <Udma_chEnable+0x30> @ imm = #0x8
700a9146: e7ff         	b	0x700a9148 <Udma_chEnable+0x28> @ imm = #-0x2
700a9148: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a914c: 9002         	str	r0, [sp, #0x8]
;     }
700a914e: e7ff         	b	0x700a9150 <Udma_chEnable+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9150: 9802         	ldr	r0, [sp, #0x8]
700a9152: b9a8         	cbnz	r0, 0x700a9180 <Udma_chEnable+0x60> @ imm = #0x2a
700a9154: e7ff         	b	0x700a9156 <Udma_chEnable+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a9156: 9800         	ldr	r0, [sp]
700a9158: 6e80         	ldr	r0, [r0, #0x68]
700a915a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a915c: 9801         	ldr	r0, [sp, #0x4]
700a915e: b150         	cbz	r0, 0x700a9176 <Udma_chEnable+0x56> @ imm = #0x14
700a9160: e7ff         	b	0x700a9162 <Udma_chEnable+0x42> @ imm = #-0x2
700a9162: 9801         	ldr	r0, [sp, #0x4]
700a9164: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a9168: f64a 31cd    	movw	r1, #0xabcd
700a916c: f6ca 31dc    	movt	r1, #0xabdc
700a9170: 4288         	cmp	r0, r1
700a9172: d004         	beq	0x700a917e <Udma_chEnable+0x5e> @ imm = #0x8
700a9174: e7ff         	b	0x700a9176 <Udma_chEnable+0x56> @ imm = #-0x2
700a9176: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a917a: 9002         	str	r0, [sp, #0x8]
;         }
700a917c: e7ff         	b	0x700a917e <Udma_chEnable+0x5e> @ imm = #-0x2
;     }
700a917e: e7ff         	b	0x700a9180 <Udma_chEnable+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9180: 9802         	ldr	r0, [sp, #0x8]
700a9182: b920         	cbnz	r0, 0x700a918e <Udma_chEnable+0x6e> @ imm = #0x8
700a9184: e7ff         	b	0x700a9186 <Udma_chEnable+0x66> @ imm = #-0x2
;         Udma_chEnableLocal(chHandleInt);
700a9186: 9800         	ldr	r0, [sp]
700a9188: f7f6 f94a    	bl	0x7009f420 <Udma_chEnableLocal> @ imm = #-0x9d6c
;     }
700a918c: e7ff         	b	0x700a918e <Udma_chEnable+0x6e> @ imm = #-0x2
;     return (retVal);
700a918e: 9802         	ldr	r0, [sp, #0x8]
700a9190: b004         	add	sp, #0x10
700a9192: bd80         	pop	{r7, pc}
		...

700a91a0 <CSL_bcdmaChanOpTriggerChan>:
; {
700a91a0: b580         	push	{r7, lr}
700a91a2: b084         	sub	sp, #0x10
700a91a4: 9003         	str	r0, [sp, #0xc]
700a91a6: 9102         	str	r1, [sp, #0x8]
700a91a8: 9201         	str	r2, [sp, #0x4]
700a91aa: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a91ac: 9000         	str	r0, [sp]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700a91ae: 9802         	ldr	r0, [sp, #0x8]
700a91b0: b950         	cbnz	r0, 0x700a91c8 <CSL_bcdmaChanOpTriggerChan+0x28> @ imm = #0x14
700a91b2: e7ff         	b	0x700a91b4 <CSL_bcdmaChanOpTriggerChan+0x14> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_BCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700a91b4: 9803         	ldr	r0, [sp, #0xc]
700a91b6: 6880         	ldr	r0, [r0, #0x8]
700a91b8: 9901         	ldr	r1, [sp, #0x4]
700a91ba: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a91be: 3008         	adds	r0, #0x8
700a91c0: 2101         	movs	r1, #0x1
700a91c2: f004 fb25    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x464a
;     }
700a91c6: e021         	b	0x700a920c <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #0x42
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700a91c8: 9802         	ldr	r0, [sp, #0x8]
700a91ca: 2801         	cmp	r0, #0x1
700a91cc: d10a         	bne	0x700a91e4 <CSL_bcdmaChanOpTriggerChan+0x44> @ imm = #0x14
700a91ce: e7ff         	b	0x700a91d0 <CSL_bcdmaChanOpTriggerChan+0x30> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_TXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700a91d0: 9803         	ldr	r0, [sp, #0xc]
700a91d2: 6900         	ldr	r0, [r0, #0x10]
700a91d4: 9901         	ldr	r1, [sp, #0x4]
700a91d6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a91da: 3008         	adds	r0, #0x8
700a91dc: 2101         	movs	r1, #0x1
700a91de: f004 fb17    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x462e
;     }
700a91e2: e012         	b	0x700a920a <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #0x24
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a91e4: 9802         	ldr	r0, [sp, #0x8]
700a91e6: 2802         	cmp	r0, #0x2
700a91e8: d10a         	bne	0x700a9200 <CSL_bcdmaChanOpTriggerChan+0x60> @ imm = #0x14
700a91ea: e7ff         	b	0x700a91ec <CSL_bcdmaChanOpTriggerChan+0x4c> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_RXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700a91ec: 9803         	ldr	r0, [sp, #0xc]
700a91ee: 6980         	ldr	r0, [r0, #0x18]
700a91f0: 9901         	ldr	r1, [sp, #0x4]
700a91f2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a91f6: 3008         	adds	r0, #0x8
700a91f8: 2101         	movs	r1, #0x1
700a91fa: f004 fb09    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x4612
;     }
700a91fe: e003         	b	0x700a9208 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #0x6
700a9200: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a9204: 9000         	str	r0, [sp]
700a9206: e7ff         	b	0x700a9208 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #-0x2
700a9208: e7ff         	b	0x700a920a <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #-0x2
700a920a: e7ff         	b	0x700a920c <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #-0x2
;     return retVal;
700a920c: 9800         	ldr	r0, [sp]
700a920e: b004         	add	sp, #0x10
700a9210: bd80         	pop	{r7, pc}
		...
700a921e: 0000         	movs	r0, r0

700a9220 <prvProcessExpiredTimer>:
;     {
700a9220: b580         	push	{r7, lr}
700a9222: b086         	sub	sp, #0x18
700a9224: 9005         	str	r0, [sp, #0x14]
700a9226: 9104         	str	r1, [sp, #0x10]
;         Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700a9228: f644 70b4    	movw	r0, #0x4fb4
700a922c: f2c7 0008    	movt	r0, #0x7008
700a9230: 6800         	ldr	r0, [r0]
700a9232: 68c0         	ldr	r0, [r0, #0xc]
700a9234: 68c0         	ldr	r0, [r0, #0xc]
700a9236: 9002         	str	r0, [sp, #0x8]
;         ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a9238: 9802         	ldr	r0, [sp, #0x8]
700a923a: 3004         	adds	r0, #0x4
700a923c: f002 f978    	bl	0x700ab530 <uxListRemove> @ imm = #0x22f0
;         if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a9240: 9802         	ldr	r0, [sp, #0x8]
700a9242: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a9246: 0740         	lsls	r0, r0, #0x1d
700a9248: 2800         	cmp	r0, #0x0
700a924a: d515         	bpl	0x700a9278 <prvProcessExpiredTimer+0x58> @ imm = #0x2a
700a924c: e7ff         	b	0x700a924e <prvProcessExpiredTimer+0x2e> @ imm = #-0x2
;             if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
700a924e: 9802         	ldr	r0, [sp, #0x8]
700a9250: 9b05         	ldr	r3, [sp, #0x14]
700a9252: 6981         	ldr	r1, [r0, #0x18]
700a9254: 4419         	add	r1, r3
700a9256: 9a04         	ldr	r2, [sp, #0x10]
700a9258: f7ff f92a    	bl	0x700a84b0 <prvInsertTimerInActiveList> @ imm = #-0xdac
700a925c: b150         	cbz	r0, 0x700a9274 <prvProcessExpiredTimer+0x54> @ imm = #0x14
700a925e: e7ff         	b	0x700a9260 <prvProcessExpiredTimer+0x40> @ imm = #-0x2
;                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700a9260: 9802         	ldr	r0, [sp, #0x8]
700a9262: 9a05         	ldr	r2, [sp, #0x14]
700a9264: 4669         	mov	r1, sp
700a9266: 2300         	movs	r3, #0x0
700a9268: 600b         	str	r3, [r1]
700a926a: 4619         	mov	r1, r3
700a926c: f7fe fbf0    	bl	0x700a7a50 <xTimerGenericCommand> @ imm = #-0x1820
700a9270: 9003         	str	r0, [sp, #0xc]
;             }
700a9272: e000         	b	0x700a9276 <prvProcessExpiredTimer+0x56> @ imm = #0x0
700a9274: e7ff         	b	0x700a9276 <prvProcessExpiredTimer+0x56> @ imm = #-0x2
;         }
700a9276: e007         	b	0x700a9288 <prvProcessExpiredTimer+0x68> @ imm = #0xe
;             pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a9278: 9902         	ldr	r1, [sp, #0x8]
700a927a: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a927e: f000 00fe    	and	r0, r0, #0xfe
700a9282: f881 0028    	strb.w	r0, [r1, #0x28]
700a9286: e7ff         	b	0x700a9288 <prvProcessExpiredTimer+0x68> @ imm = #-0x2
;         pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a9288: 9802         	ldr	r0, [sp, #0x8]
700a928a: 6a01         	ldr	r1, [r0, #0x20]
700a928c: 4788         	blx	r1
;     }
700a928e: b006         	add	sp, #0x18
700a9290: bd80         	pop	{r7, pc}
		...
700a929e: 0000         	movs	r0, r0

700a92a0 <xTaskCreateStatic>:
;     StaticTask_t *const pxTaskBuffer) {
700a92a0: b5b0         	push	{r4, r5, r7, lr}
700a92a2: b08a         	sub	sp, #0x28
700a92a4: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a92a8: f8dd c03c    	ldr.w	r12, [sp, #0x3c]
700a92ac: f8dd c038    	ldr.w	r12, [sp, #0x38]
700a92b0: 9009         	str	r0, [sp, #0x24]
700a92b2: 9108         	str	r1, [sp, #0x20]
700a92b4: 9207         	str	r2, [sp, #0x1c]
700a92b6: 9306         	str	r3, [sp, #0x18]
;   if ((pxTaskBuffer != NULL) && (puxStackBuffer != NULL)) {
700a92b8: 9810         	ldr	r0, [sp, #0x40]
700a92ba: b320         	cbz	r0, 0x700a9306 <xTaskCreateStatic+0x66> @ imm = #0x48
700a92bc: e7ff         	b	0x700a92be <xTaskCreateStatic+0x1e> @ imm = #-0x2
700a92be: 980f         	ldr	r0, [sp, #0x3c]
700a92c0: b308         	cbz	r0, 0x700a9306 <xTaskCreateStatic+0x66> @ imm = #0x42
700a92c2: e7ff         	b	0x700a92c4 <xTaskCreateStatic+0x24> @ imm = #-0x2
;         pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures
700a92c4: 9810         	ldr	r0, [sp, #0x40]
;     pxNewTCB = (TCB_t *)
700a92c6: 9005         	str	r0, [sp, #0x14]
;     pxNewTCB->pxStack = (StackType_t *)puxStackBuffer;
700a92c8: 980f         	ldr	r0, [sp, #0x3c]
700a92ca: 9905         	ldr	r1, [sp, #0x14]
700a92cc: 6308         	str	r0, [r1, #0x30]
;       pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
700a92ce: 9905         	ldr	r1, [sp, #0x14]
700a92d0: 2002         	movs	r0, #0x2
700a92d2: f881 0086    	strb.w	r0, [r1, #0x86]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700a92d6: 9809         	ldr	r0, [sp, #0x24]
700a92d8: 9908         	ldr	r1, [sp, #0x20]
700a92da: 9a07         	ldr	r2, [sp, #0x1c]
700a92dc: 9b06         	ldr	r3, [sp, #0x18]
;                          uxPriority, &xReturn, pxNewTCB, NULL);
700a92de: f8dd c038    	ldr.w	r12, [sp, #0x38]
700a92e2: 9c05         	ldr	r4, [sp, #0x14]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700a92e4: 46ee         	mov	lr, sp
700a92e6: 2500         	movs	r5, #0x0
700a92e8: f8ce 500c    	str.w	r5, [lr, #0xc]
700a92ec: f8ce 4008    	str.w	r4, [lr, #0x8]
700a92f0: ac04         	add	r4, sp, #0x10
700a92f2: f8ce 4004    	str.w	r4, [lr, #0x4]
700a92f6: f8ce c000    	str.w	r12, [lr]
700a92fa: f7f9 fcf9    	bl	0x700a2cf0 <prvInitialiseNewTask> @ imm = #-0x660e
;     prvAddNewTaskToReadyList(pxNewTCB);
700a92fe: 9805         	ldr	r0, [sp, #0x14]
700a9300: f7fa fa66    	bl	0x700a37d0 <prvAddNewTaskToReadyList> @ imm = #-0x5b34
;   } else {
700a9304: e002         	b	0x700a930c <xTaskCreateStatic+0x6c> @ imm = #0x4
700a9306: 2000         	movs	r0, #0x0
;     xReturn = NULL;
700a9308: 9004         	str	r0, [sp, #0x10]
700a930a: e7ff         	b	0x700a930c <xTaskCreateStatic+0x6c> @ imm = #-0x2
;   return xReturn;
700a930c: 9804         	ldr	r0, [sp, #0x10]
700a930e: b00a         	add	sp, #0x28
700a9310: bdb0         	pop	{r4, r5, r7, pc}
		...
700a931e: 0000         	movs	r0, r0

700a9320 <CSL_intaggrClrIntr>:
; {
700a9320: b580         	push	{r7, lr}
700a9322: b088         	sub	sp, #0x20
700a9324: 9007         	str	r0, [sp, #0x1c]
700a9326: 9106         	str	r1, [sp, #0x18]
700a9328: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t  retVal = CSL_EFAIL;
700a932c: 9005         	str	r0, [sp, #0x14]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700a932e: 9807         	ldr	r0, [sp, #0x1c]
700a9330: 9906         	ldr	r1, [sp, #0x18]
700a9332: f002 fd35    	bl	0x700abda0 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x2a6a
700a9336: b340         	cbz	r0, 0x700a938a <CSL_intaggrClrIntr+0x6a> @ imm = #0x50
700a9338: e7ff         	b	0x700a933a <CSL_intaggrClrIntr+0x1a> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700a933a: 9806         	ldr	r0, [sp, #0x18]
700a933c: 0980         	lsrs	r0, r0, #0x6
700a933e: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700a9340: 9806         	ldr	r0, [sp, #0x18]
700a9342: f000 003f    	and	r0, r0, #0x3f
700a9346: 9000         	str	r0, [sp]
;         regVal = (((uint64_t)1U) << bitNum);
700a9348: 9b00         	ldr	r3, [sp]
700a934a: f1a3 0220    	sub.w	r2, r3, #0x20
700a934e: 2101         	movs	r1, #0x1
700a9350: fa01 fc02    	lsl.w	r12, r1, r2
700a9354: f1c3 0020    	rsb.w	r0, r3, #0x20
700a9358: fa21 f000    	lsr.w	r0, r1, r0
700a935c: 2a00         	cmp	r2, #0x0
700a935e: bf58         	it	pl
700a9360: 4660         	movpl	r0, r12
700a9362: fa01 f103    	lsl.w	r1, r1, r3
700a9366: 2a00         	cmp	r2, #0x0
700a9368: bf58         	it	pl
700a936a: 2100         	movpl	r1, #0x0
700a936c: 9102         	str	r1, [sp, #0x8]
700a936e: 9003         	str	r0, [sp, #0xc]
;         CSL_REG64_WR( &pCfg->pIntrRegs->VINT[regNum].STATUS_CLEAR, regVal );
700a9370: 9807         	ldr	r0, [sp, #0x1c]
700a9372: 6880         	ldr	r0, [r0, #0x8]
700a9374: 9901         	ldr	r1, [sp, #0x4]
700a9376: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a937a: 3018         	adds	r0, #0x18
700a937c: 9a02         	ldr	r2, [sp, #0x8]
700a937e: 9b03         	ldr	r3, [sp, #0xc]
700a9380: f004 f8b6    	bl	0x700ad4f0 <CSL_REG64_WR_RAW> @ imm = #0x416c
700a9384: 2000         	movs	r0, #0x0
;         retVal = CSL_PASS;
700a9386: 9005         	str	r0, [sp, #0x14]
;     }
700a9388: e7ff         	b	0x700a938a <CSL_intaggrClrIntr+0x6a> @ imm = #-0x2
;     return retVal;
700a938a: 9805         	ldr	r0, [sp, #0x14]
700a938c: b008         	add	sp, #0x20
700a938e: bd80         	pop	{r7, pc}

700a9390 <Sciclient_rmGetResourceRange>:
; {
700a9390: b580         	push	{r7, lr}
700a9392: b090         	sub	sp, #0x40
700a9394: 900f         	str	r0, [sp, #0x3c]
700a9396: 910e         	str	r1, [sp, #0x38]
700a9398: 920d         	str	r2, [sp, #0x34]
700a939a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a939c: 900c         	str	r0, [sp, #0x30]
700a939e: f44f 51a8    	mov.w	r1, #0x1500
;     sciReq.messageType    = TISCI_MSG_RM_GET_RESOURCE_RANGE;
700a93a2: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a93a6: 2102         	movs	r1, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700a93a8: 9108         	str	r1, [sp, #0x20]
700a93aa: a904         	add	r1, sp, #0x10
;     sciReq.pReqPayload    = (const uint8_t *) &req_copy;
700a93ac: 9109         	str	r1, [sp, #0x24]
700a93ae: 210c         	movs	r1, #0xc
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700a93b0: 910a         	str	r1, [sp, #0x28]
;     sciReq.timeout        = timeout;
700a93b2: 990d         	ldr	r1, [sp, #0x34]
700a93b4: 910b         	str	r1, [sp, #0x2c]
;     sciResp.flags           = 0;
700a93b6: 9001         	str	r0, [sp, #0x4]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700a93b8: 980e         	ldr	r0, [sp, #0x38]
700a93ba: 9002         	str	r0, [sp, #0x8]
700a93bc: 2010         	movs	r0, #0x10
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700a93be: 9003         	str	r0, [sp, #0xc]
;     memcpy(&req_copy, req, sizeof(struct tisci_msg_rm_get_resource_range_req));
700a93c0: 9a0f         	ldr	r2, [sp, #0x3c]
700a93c2: 6810         	ldr	r0, [r2]
700a93c4: 6851         	ldr	r1, [r2, #0x4]
700a93c6: 6892         	ldr	r2, [r2, #0x8]
700a93c8: 9206         	str	r2, [sp, #0x18]
700a93ca: 9105         	str	r1, [sp, #0x14]
700a93cc: 9004         	str	r0, [sp, #0x10]
;     if (SystemP_SUCCESS == r)
700a93ce: 980c         	ldr	r0, [sp, #0x30]
700a93d0: b930         	cbnz	r0, 0x700a93e0 <Sciclient_rmGetResourceRange+0x50> @ imm = #0xc
700a93d2: e7ff         	b	0x700a93d4 <Sciclient_rmGetResourceRange+0x44> @ imm = #-0x2
700a93d4: a807         	add	r0, sp, #0x1c
700a93d6: a901         	add	r1, sp, #0x4
;         r = Sciclient_service(&sciReq, &sciResp);
700a93d8: f7f2 fd52    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xd55c
700a93dc: 900c         	str	r0, [sp, #0x30]
;     }
700a93de: e7ff         	b	0x700a93e0 <Sciclient_rmGetResourceRange+0x50> @ imm = #-0x2
;     if ((r != SystemP_SUCCESS) ||
700a93e0: 980c         	ldr	r0, [sp, #0x30]
700a93e2: b930         	cbnz	r0, 0x700a93f2 <Sciclient_rmGetResourceRange+0x62> @ imm = #0xc
700a93e4: e7ff         	b	0x700a93e6 <Sciclient_rmGetResourceRange+0x56> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700a93e6: 9801         	ldr	r0, [sp, #0x4]
700a93e8: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700a93ec: 2802         	cmp	r0, #0x2
700a93ee: d004         	beq	0x700a93fa <Sciclient_rmGetResourceRange+0x6a> @ imm = #0x8
700a93f0: e7ff         	b	0x700a93f2 <Sciclient_rmGetResourceRange+0x62> @ imm = #-0x2
700a93f2: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a93f6: 900c         	str	r0, [sp, #0x30]
;     }
700a93f8: e7ff         	b	0x700a93fa <Sciclient_rmGetResourceRange+0x6a> @ imm = #-0x2
;     return r;
700a93fa: 980c         	ldr	r0, [sp, #0x30]
700a93fc: b010         	add	sp, #0x40
700a93fe: bd80         	pop	{r7, pc}

700a9400 <Udma_rmFreeMappedRxCh>:
; {
700a9400: b580         	push	{r7, lr}
700a9402: b088         	sub	sp, #0x20
700a9404: 9007         	str	r0, [sp, #0x1c]
700a9406: 9106         	str	r1, [sp, #0x18]
700a9408: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a940a: 9806         	ldr	r0, [sp, #0x18]
700a940c: f500 70ea    	add.w	r0, r0, #0x1d4
700a9410: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9412: 9806         	ldr	r0, [sp, #0x18]
700a9414: f500 609f    	add.w	r0, r0, #0x4f8
700a9418: f04f 31ff    	mov.w	r1, #0xffffffff
700a941c: f7ff f968    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0xd30
;     i = chNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700a9420: 9807         	ldr	r0, [sp, #0x1c]
700a9422: 9900         	ldr	r1, [sp]
700a9424: 9a05         	ldr	r2, [sp, #0x14]
700a9426: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a942a: 6e89         	ldr	r1, [r1, #0x68]
700a942c: 1a40         	subs	r0, r0, r1
700a942e: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700a9430: 9804         	ldr	r0, [sp, #0x10]
700a9432: 0940         	lsrs	r0, r0, #0x5
700a9434: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700a9436: 9804         	ldr	r0, [sp, #0x10]
700a9438: 9903         	ldr	r1, [sp, #0xc]
700a943a: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a943e: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700a9440: 9902         	ldr	r1, [sp, #0x8]
700a9442: 2001         	movs	r0, #0x1
700a9444: 4088         	lsls	r0, r1
700a9446: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedRxChFlag[mappedChGrp][offset] |= bitMask;
700a9448: 9a01         	ldr	r2, [sp, #0x4]
700a944a: 9806         	ldr	r0, [sp, #0x18]
700a944c: 9905         	ldr	r1, [sp, #0x14]
700a944e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a9452: 9903         	ldr	r1, [sp, #0xc]
700a9454: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9458: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a945c: 4310         	orrs	r0, r2
700a945e: f8c1 0334    	str.w	r0, [r1, #0x334]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9462: 9806         	ldr	r0, [sp, #0x18]
700a9464: f500 609f    	add.w	r0, r0, #0x4f8
700a9468: f000 fc9a    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x934
;     return;
700a946c: b008         	add	sp, #0x20
700a946e: bd80         	pop	{r7, pc}

700a9470 <Udma_rmFreeMappedTxCh>:
; {
700a9470: b580         	push	{r7, lr}
700a9472: b088         	sub	sp, #0x20
700a9474: 9007         	str	r0, [sp, #0x1c]
700a9476: 9106         	str	r1, [sp, #0x18]
700a9478: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a947a: 9806         	ldr	r0, [sp, #0x18]
700a947c: f500 70ea    	add.w	r0, r0, #0x1d4
700a9480: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9482: 9806         	ldr	r0, [sp, #0x18]
700a9484: f500 609f    	add.w	r0, r0, #0x4f8
700a9488: f04f 31ff    	mov.w	r1, #0xffffffff
700a948c: f7ff f930    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0xda0
;     i = chNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700a9490: 9807         	ldr	r0, [sp, #0x1c]
700a9492: 9900         	ldr	r1, [sp]
700a9494: 9a05         	ldr	r2, [sp, #0x14]
700a9496: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a949a: 6c89         	ldr	r1, [r1, #0x48]
700a949c: 1a40         	subs	r0, r0, r1
700a949e: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700a94a0: 9804         	ldr	r0, [sp, #0x10]
700a94a2: 0940         	lsrs	r0, r0, #0x5
700a94a4: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700a94a6: 9804         	ldr	r0, [sp, #0x10]
700a94a8: 9903         	ldr	r1, [sp, #0xc]
700a94aa: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a94ae: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700a94b0: 9902         	ldr	r1, [sp, #0x8]
700a94b2: 2001         	movs	r0, #0x1
700a94b4: 4088         	lsls	r0, r1
700a94b6: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedTxChFlag[mappedChGrp][offset] |= bitMask;
700a94b8: 9a01         	ldr	r2, [sp, #0x4]
700a94ba: 9806         	ldr	r0, [sp, #0x18]
700a94bc: 9905         	ldr	r1, [sp, #0x14]
700a94be: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a94c2: 9903         	ldr	r1, [sp, #0xc]
700a94c4: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a94c8: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a94cc: 4310         	orrs	r0, r2
700a94ce: f8c1 0324    	str.w	r0, [r1, #0x324]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a94d2: 9806         	ldr	r0, [sp, #0x18]
700a94d4: f500 609f    	add.w	r0, r0, #0x4f8
700a94d8: f000 fc62    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x8c4
;     return;
700a94dc: b008         	add	sp, #0x20
700a94de: bd80         	pop	{r7, pc}

700a94e0 <Sciclient_rmIaVintGetInfo>:
; {
700a94e0: b580         	push	{r7, lr}
700a94e2: b084         	sub	sp, #0x10
700a94e4: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a94e8: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a94ec: 9202         	str	r2, [sp, #0x8]
700a94ee: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a94f0: 9001         	str	r0, [sp, #0x4]
;     if (n_evts == NULL) {
700a94f2: 9802         	ldr	r0, [sp, #0x8]
700a94f4: b920         	cbnz	r0, 0x700a9500 <Sciclient_rmIaVintGetInfo+0x20> @ imm = #0x8
700a94f6: e7ff         	b	0x700a94f8 <Sciclient_rmIaVintGetInfo+0x18> @ imm = #-0x2
700a94f8: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a94fc: 9001         	str	r0, [sp, #0x4]
;     } else {
700a94fe: e018         	b	0x700a9532 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #0x30
;         inst = Sciclient_rmIaGetInst(id);
700a9500: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a9504: f000 ffa4    	bl	0x700aa450 <Sciclient_rmIaGetInst> @ imm = #0xf48
700a9508: 9000         	str	r0, [sp]
;         if (inst == NULL) {
700a950a: 9800         	ldr	r0, [sp]
700a950c: b920         	cbnz	r0, 0x700a9518 <Sciclient_rmIaVintGetInfo+0x38> @ imm = #0x8
700a950e: e7ff         	b	0x700a9510 <Sciclient_rmIaVintGetInfo+0x30> @ imm = #-0x2
700a9510: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a9514: 9001         	str	r0, [sp, #0x4]
;         } else {
700a9516: e00b         	b	0x700a9530 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #0x16
;             if (vint >= inst->n_vint) {
700a9518: f8bd 000c    	ldrh.w	r0, [sp, #0xc]
700a951c: 9900         	ldr	r1, [sp]
700a951e: 8989         	ldrh	r1, [r1, #0xc]
700a9520: 4288         	cmp	r0, r1
700a9522: db04         	blt	0x700a952e <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #0x8
700a9524: e7ff         	b	0x700a9526 <Sciclient_rmIaVintGetInfo+0x46> @ imm = #-0x2
700a9526: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a952a: 9001         	str	r0, [sp, #0x4]
;             }
700a952c: e7ff         	b	0x700a952e <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #-0x2
700a952e: e7ff         	b	0x700a9530 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #-0x2
700a9530: e7ff         	b	0x700a9532 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a9532: 9801         	ldr	r0, [sp, #0x4]
700a9534: b940         	cbnz	r0, 0x700a9548 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #0x10
700a9536: e7ff         	b	0x700a9538 <Sciclient_rmIaVintGetInfo+0x58> @ imm = #-0x2
;         *n_evts = inst->vint_usage_count[vint];
700a9538: 9800         	ldr	r0, [sp]
700a953a: 6900         	ldr	r0, [r0, #0x10]
700a953c: f8bd 100c    	ldrh.w	r1, [sp, #0xc]
700a9540: 5c40         	ldrb	r0, [r0, r1]
700a9542: 9902         	ldr	r1, [sp, #0x8]
700a9544: 7008         	strb	r0, [r1]
;     }
700a9546: e7ff         	b	0x700a9548 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #-0x2
;     return r;
700a9548: 9801         	ldr	r0, [sp, #0x4]
700a954a: b004         	add	sp, #0x10
700a954c: bd80         	pop	{r7, pc}
700a954e: 0000         	movs	r0, r0

700a9550 <SemaphoreP_constructMutex>:
; {
700a9550: b580         	push	{r7, lr}
700a9552: b086         	sub	sp, #0x18
700a9554: 9005         	str	r0, [sp, #0x14]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700a9556: 9805         	ldr	r0, [sp, #0x14]
700a9558: 9004         	str	r0, [sp, #0x10]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700a955a: f24f 6043    	movw	r0, #0xf643
700a955e: f2c7 000a    	movt	r0, #0x700a
700a9562: 4669         	mov	r1, sp
700a9564: 6008         	str	r0, [r1]
700a9566: f64f 018e    	movw	r1, #0xf88e
700a956a: f2c7 010a    	movt	r1, #0x700a
700a956e: f64f 2232    	movw	r2, #0xfa32
700a9572: f2c7 020a    	movt	r2, #0x700a
700a9576: 2001         	movs	r0, #0x1
700a9578: 9002         	str	r0, [sp, #0x8]
700a957a: 2370         	movs	r3, #0x70
700a957c: f7ff fb50    	bl	0x700a8c20 <_DebugP_assert> @ imm = #-0x960
700a9580: 9802         	ldr	r0, [sp, #0x8]
;     pSemaphore->isRecursiveMutex = 1;
700a9582: 9904         	ldr	r1, [sp, #0x10]
700a9584: 6548         	str	r0, [r1, #0x54]
;     pSemaphore->semHndl = xSemaphoreCreateRecursiveMutexStatic(&pSemaphore->semObj);
700a9586: 9904         	ldr	r1, [sp, #0x10]
700a9588: 2004         	movs	r0, #0x4
700a958a: f003 f821    	bl	0x700ac5d0 <xQueueCreateMutexStatic> @ imm = #0x3042
700a958e: 9904         	ldr	r1, [sp, #0x10]
700a9590: 6508         	str	r0, [r1, #0x50]
;     if( pSemaphore->semHndl == NULL )
700a9592: 9804         	ldr	r0, [sp, #0x10]
700a9594: 6d00         	ldr	r0, [r0, #0x50]
700a9596: b920         	cbnz	r0, 0x700a95a2 <SemaphoreP_constructMutex+0x52> @ imm = #0x8
700a9598: e7ff         	b	0x700a959a <SemaphoreP_constructMutex+0x4a> @ imm = #-0x2
700a959a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a959e: 9003         	str	r0, [sp, #0xc]
;     }
700a95a0: e00a         	b	0x700a95b8 <SemaphoreP_constructMutex+0x68> @ imm = #0x14
;         vQueueAddToRegistry(pSemaphore->semHndl, "Mutex (DPL)");
700a95a2: 9804         	ldr	r0, [sp, #0x10]
700a95a4: 6d00         	ldr	r0, [r0, #0x50]
700a95a6: f64f 4156    	movw	r1, #0xfc56
700a95aa: f2c7 010a    	movt	r1, #0x700a
700a95ae: f001 fcb7    	bl	0x700aaf20 <vQueueAddToRegistry> @ imm = #0x196e
700a95b2: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a95b4: 9003         	str	r0, [sp, #0xc]
700a95b6: e7ff         	b	0x700a95b8 <SemaphoreP_constructMutex+0x68> @ imm = #-0x2
;     return status;
700a95b8: 9803         	ldr	r0, [sp, #0xc]
700a95ba: b006         	add	sp, #0x18
700a95bc: bd80         	pop	{r7, pc}
700a95be: 0000         	movs	r0, r0

700a95c0 <UdmaChPrms_init>:
; {
700a95c0: b580         	push	{r7, lr}
700a95c2: b082         	sub	sp, #0x8
700a95c4: 9001         	str	r0, [sp, #0x4]
700a95c6: 9100         	str	r1, [sp]
;     if(NULL_PTR != chPrms)
700a95c8: 9801         	ldr	r0, [sp, #0x4]
700a95ca: b368         	cbz	r0, 0x700a9628 <UdmaChPrms_init+0x68> @ imm = #0x5a
700a95cc: e7ff         	b	0x700a95ce <UdmaChPrms_init+0xe> @ imm = #-0x2
;         chPrms->chNum       = UDMA_DMA_CH_ANY;
700a95ce: 9901         	ldr	r1, [sp, #0x4]
700a95d0: 2001         	movs	r0, #0x1
700a95d2: f6cf 70ff    	movt	r0, #0xffff
700a95d6: 6008         	str	r0, [r1]
;         chPrms->peerChNum   = UDMA_DMA_CH_INVALID;
700a95d8: 9901         	ldr	r1, [sp, #0x4]
700a95da: 2000         	movs	r0, #0x0
700a95dc: f6cf 70ff    	movt	r0, #0xffff
700a95e0: 6048         	str	r0, [r1, #0x4]
;         if(UDMA_CH_TYPE_TR_BLK_COPY == chType)
700a95e2: 9800         	ldr	r0, [sp]
700a95e4: 2807         	cmp	r0, #0x7
700a95e6: d106         	bne	0x700a95f6 <UdmaChPrms_init+0x36> @ imm = #0xc
700a95e8: e7ff         	b	0x700a95ea <UdmaChPrms_init+0x2a> @ imm = #-0x2
;             chPrms->peerChNum   = UDMA_DMA_CH_NA;
700a95ea: 9901         	ldr	r1, [sp, #0x4]
700a95ec: 2002         	movs	r0, #0x2
700a95ee: f6cf 70ff    	movt	r0, #0xffff
700a95f2: 6048         	str	r0, [r1, #0x4]
;         }
700a95f4: e7ff         	b	0x700a95f6 <UdmaChPrms_init+0x36> @ imm = #-0x2
;         chPrms->mappedChGrp = UDMA_MAPPED_GROUP_INVALID;
700a95f6: 9901         	ldr	r1, [sp, #0x4]
700a95f8: 2004         	movs	r0, #0x4
700a95fa: f6cf 70ff    	movt	r0, #0xffff
700a95fe: 6088         	str	r0, [r1, #0x8]
;         chPrms->appData     = NULL_PTR;
700a9600: 9901         	ldr	r1, [sp, #0x4]
700a9602: 2000         	movs	r0, #0x0
700a9604: 60c8         	str	r0, [r1, #0xc]
;         UdmaRingPrms_init(&chPrms->fqRingPrms);
700a9606: 9801         	ldr	r0, [sp, #0x4]
700a9608: 3010         	adds	r0, #0x10
700a960a: f001 fb71    	bl	0x700aacf0 <UdmaRingPrms_init> @ imm = #0x16e2
;         UdmaRingPrms_init(&chPrms->cqRingPrms);
700a960e: 9801         	ldr	r0, [sp, #0x4]
700a9610: 302c         	adds	r0, #0x2c
700a9612: f001 fb6d    	bl	0x700aacf0 <UdmaRingPrms_init> @ imm = #0x16da
;         UdmaRingPrms_init(&chPrms->tdCqRingPrms);
700a9616: 9801         	ldr	r0, [sp, #0x4]
700a9618: 3048         	adds	r0, #0x48
700a961a: f001 fb69    	bl	0x700aacf0 <UdmaRingPrms_init> @ imm = #0x16d2
;         chPrms->tdCqRingPrms.elemSize = UDMA_RING_ES_8BYTES;
700a961e: 9901         	ldr	r1, [sp, #0x4]
700a9620: 2001         	movs	r0, #0x1
700a9622: f881 0058    	strb.w	r0, [r1, #0x58]
;     }
700a9626: e7ff         	b	0x700a9628 <UdmaChPrms_init+0x68> @ imm = #-0x2
;     return;
700a9628: b002         	add	sp, #0x8
700a962a: bd80         	pop	{r7, pc}
700a962c: 0000         	movs	r0, r0
700a962e: 0000         	movs	r0, r0

700a9630 <Pinmux_lockMMR>:
; {
700a9630: b580         	push	{r7, lr}
700a9632: b084         	sub	sp, #0x10
700a9634: 9003         	str	r0, [sp, #0xc]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a9636: 9803         	ldr	r0, [sp, #0xc]
700a9638: b908         	cbnz	r0, 0x700a963e <Pinmux_lockMMR+0xe> @ imm = #0x2
700a963a: e7ff         	b	0x700a963c <Pinmux_lockMMR+0xc> @ imm = #-0x2
;     }
700a963c: e7ff         	b	0x700a963e <Pinmux_lockMMR+0xe> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700a963e: 9803         	ldr	r0, [sp, #0xc]
700a9640: 2801         	cmp	r0, #0x1
700a9642: d128         	bne	0x700a9696 <Pinmux_lockMMR+0x66> @ imm = #0x50
700a9644: e7ff         	b	0x700a9646 <Pinmux_lockMMR+0x16> @ imm = #-0x2
700a9646: f04f 6081    	mov.w	r0, #0x4080000
700a964a: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700a964c: 9100         	str	r1, [sp]
700a964e: f7fa fbbf    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x5882
700a9652: 9900         	ldr	r1, [sp]
700a9654: 9002         	str	r0, [sp, #0x8]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700a9656: 9802         	ldr	r0, [sp, #0x8]
700a9658: f241 0208    	movw	r2, #0x1008
700a965c: 4410         	add	r0, r2
700a965e: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a9660: 9801         	ldr	r0, [sp, #0x4]
700a9662: f004 f8e5    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x41ca
700a9666: 9900         	ldr	r1, [sp]
;         kickAddr++;
700a9668: 9801         	ldr	r0, [sp, #0x4]
700a966a: 3004         	adds	r0, #0x4
700a966c: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a966e: 9801         	ldr	r0, [sp, #0x4]
700a9670: f004 f8de    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x41bc
700a9674: 9900         	ldr	r1, [sp]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700a9676: 9802         	ldr	r0, [sp, #0x8]
700a9678: f245 0208    	movw	r2, #0x5008
700a967c: 4410         	add	r0, r2
700a967e: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a9680: 9801         	ldr	r0, [sp, #0x4]
700a9682: f004 f8d5    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x41aa
700a9686: 9900         	ldr	r1, [sp]
;         kickAddr++;
700a9688: 9801         	ldr	r0, [sp, #0x4]
700a968a: 3004         	adds	r0, #0x4
700a968c: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a968e: 9801         	ldr	r0, [sp, #0x4]
700a9690: f004 f8ce    	bl	0x700ad830 <CSL_REG32_WR_RAW> @ imm = #0x419c
;     }
700a9694: e7ff         	b	0x700a9696 <Pinmux_lockMMR+0x66> @ imm = #-0x2
;     return;
700a9696: b004         	add	sp, #0x10
700a9698: bd80         	pop	{r7, pc}
700a969a: 0000         	movs	r0, r0
700a969c: 0000         	movs	r0, r0
700a969e: 0000         	movs	r0, r0

700a96a0 <vListInsert>:
; {
700a96a0: b084         	sub	sp, #0x10
700a96a2: 9003         	str	r0, [sp, #0xc]
700a96a4: 9102         	str	r1, [sp, #0x8]
;     const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
700a96a6: 9802         	ldr	r0, [sp, #0x8]
700a96a8: 6800         	ldr	r0, [r0]
700a96aa: 9000         	str	r0, [sp]
;     if( xValueOfInsertion == portMAX_DELAY )
700a96ac: 9800         	ldr	r0, [sp]
700a96ae: 3001         	adds	r0, #0x1
700a96b0: b920         	cbnz	r0, 0x700a96bc <vListInsert+0x1c> @ imm = #0x8
700a96b2: e7ff         	b	0x700a96b4 <vListInsert+0x14> @ imm = #-0x2
;         pxIterator = pxList->xListEnd.pxPrevious;
700a96b4: 9803         	ldr	r0, [sp, #0xc]
700a96b6: 6900         	ldr	r0, [r0, #0x10]
700a96b8: 9001         	str	r0, [sp, #0x4]
;     }
700a96ba: e010         	b	0x700a96de <vListInsert+0x3e> @ imm = #0x20
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700a96bc: 9803         	ldr	r0, [sp, #0xc]
700a96be: 3008         	adds	r0, #0x8
700a96c0: 9001         	str	r0, [sp, #0x4]
700a96c2: e7ff         	b	0x700a96c4 <vListInsert+0x24> @ imm = #-0x2
700a96c4: 9801         	ldr	r0, [sp, #0x4]
700a96c6: 6840         	ldr	r0, [r0, #0x4]
700a96c8: 6800         	ldr	r0, [r0]
700a96ca: 9900         	ldr	r1, [sp]
700a96cc: 4288         	cmp	r0, r1
700a96ce: d805         	bhi	0x700a96dc <vListInsert+0x3c> @ imm = #0xa
700a96d0: e7ff         	b	0x700a96d2 <vListInsert+0x32> @ imm = #-0x2
;         }
700a96d2: e7ff         	b	0x700a96d4 <vListInsert+0x34> @ imm = #-0x2
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700a96d4: 9801         	ldr	r0, [sp, #0x4]
700a96d6: 6840         	ldr	r0, [r0, #0x4]
700a96d8: 9001         	str	r0, [sp, #0x4]
700a96da: e7f3         	b	0x700a96c4 <vListInsert+0x24> @ imm = #-0x1a
700a96dc: e7ff         	b	0x700a96de <vListInsert+0x3e> @ imm = #-0x2
;     pxNewListItem->pxNext = pxIterator->pxNext;
700a96de: 9801         	ldr	r0, [sp, #0x4]
700a96e0: 6840         	ldr	r0, [r0, #0x4]
700a96e2: 9902         	ldr	r1, [sp, #0x8]
700a96e4: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxNext->pxPrevious = pxNewListItem;
700a96e6: 9802         	ldr	r0, [sp, #0x8]
700a96e8: 6841         	ldr	r1, [r0, #0x4]
700a96ea: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxPrevious = pxIterator;
700a96ec: 9801         	ldr	r0, [sp, #0x4]
700a96ee: 9902         	ldr	r1, [sp, #0x8]
700a96f0: 6088         	str	r0, [r1, #0x8]
;     pxIterator->pxNext = pxNewListItem;
700a96f2: 9802         	ldr	r0, [sp, #0x8]
700a96f4: 9901         	ldr	r1, [sp, #0x4]
700a96f6: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxContainer = pxList;
700a96f8: 9803         	ldr	r0, [sp, #0xc]
700a96fa: 9902         	ldr	r1, [sp, #0x8]
700a96fc: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700a96fe: 9903         	ldr	r1, [sp, #0xc]
700a9700: 6808         	ldr	r0, [r1]
700a9702: 3001         	adds	r0, #0x1
700a9704: 6008         	str	r0, [r1]
; }
700a9706: b004         	add	sp, #0x10
700a9708: 4770         	bx	lr
700a970a: 0000         	movs	r0, r0
700a970c: 0000         	movs	r0, r0
700a970e: 0000         	movs	r0, r0

700a9710 <Sciclient_rmIrqCfgIsDirectEvent>:
; {
700a9710: b580         	push	{r7, lr}
700a9712: b082         	sub	sp, #0x8
700a9714: 9001         	str	r0, [sp, #0x4]
700a9716: 2000         	movs	r0, #0x0
;     bool r = false;
700a9718: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a971c: 9801         	ldr	r0, [sp, #0x4]
700a971e: 2101         	movs	r1, #0x1
700a9720: f003 f9e6    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x33cc
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700a9724: b310         	cbz	r0, 0x700a976c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x44
700a9726: e7ff         	b	0x700a9728 <Sciclient_rmIrqCfgIsDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9728: 9801         	ldr	r0, [sp, #0x4]
700a972a: 2102         	movs	r1, #0x2
700a972c: f003 f9e0    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x33c0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700a9730: b1e0         	cbz	r0, 0x700a976c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x38
700a9732: e7ff         	b	0x700a9734 <Sciclient_rmIrqCfgIsDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9734: 9801         	ldr	r0, [sp, #0x4]
700a9736: 2104         	movs	r1, #0x4
700a9738: f003 f9da    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x33b4
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700a973c: b1b0         	cbz	r0, 0x700a976c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x2c
700a973e: e7ff         	b	0x700a9740 <Sciclient_rmIrqCfgIsDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9740: 9801         	ldr	r0, [sp, #0x4]
700a9742: 2108         	movs	r1, #0x8
700a9744: f003 f9d4    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x33a8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700a9748: b180         	cbz	r0, 0x700a976c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x20
700a974a: e7ff         	b	0x700a974c <Sciclient_rmIrqCfgIsDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a974c: 9801         	ldr	r0, [sp, #0x4]
700a974e: 2110         	movs	r1, #0x10
700a9750: f003 f9ce    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x339c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700a9754: b150         	cbz	r0, 0x700a976c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x14
700a9756: e7ff         	b	0x700a9758 <Sciclient_rmIrqCfgIsDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9758: 9801         	ldr	r0, [sp, #0x4]
700a975a: 2120         	movs	r1, #0x20
700a975c: f003 f9c8    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x3390
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9760: b120         	cbz	r0, 0x700a976c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x8
700a9762: e7ff         	b	0x700a9764 <Sciclient_rmIrqCfgIsDirectEvent+0x54> @ imm = #-0x2
700a9764: 2001         	movs	r0, #0x1
;         r = true;
700a9766: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a976a: e7ff         	b	0x700a976c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700a976c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9770: f000 0001    	and	r0, r0, #0x1
700a9774: b002         	add	sp, #0x8
700a9776: bd80         	pop	{r7, pc}
		...

700a9780 <Sciclient_rmIrqCfgIsDirectNonEvent>:
; {
700a9780: b580         	push	{r7, lr}
700a9782: b082         	sub	sp, #0x8
700a9784: 9001         	str	r0, [sp, #0x4]
700a9786: 2000         	movs	r0, #0x0
;     bool r = false;
700a9788: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a978c: 9801         	ldr	r0, [sp, #0x4]
700a978e: 2101         	movs	r1, #0x1
700a9790: f003 f9ae    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x335c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700a9794: b310         	cbz	r0, 0x700a97dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x44
700a9796: e7ff         	b	0x700a9798 <Sciclient_rmIrqCfgIsDirectNonEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9798: 9801         	ldr	r0, [sp, #0x4]
700a979a: 2102         	movs	r1, #0x2
700a979c: f003 f9a8    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x3350
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700a97a0: b1e0         	cbz	r0, 0x700a97dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x38
700a97a2: e7ff         	b	0x700a97a4 <Sciclient_rmIrqCfgIsDirectNonEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a97a4: 9801         	ldr	r0, [sp, #0x4]
700a97a6: 2104         	movs	r1, #0x4
700a97a8: f003 f9a2    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x3344
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700a97ac: b9b0         	cbnz	r0, 0x700a97dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x2c
700a97ae: e7ff         	b	0x700a97b0 <Sciclient_rmIrqCfgIsDirectNonEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a97b0: 9801         	ldr	r0, [sp, #0x4]
700a97b2: 2108         	movs	r1, #0x8
700a97b4: f003 f99c    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x3338
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700a97b8: b980         	cbnz	r0, 0x700a97dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x20
700a97ba: e7ff         	b	0x700a97bc <Sciclient_rmIrqCfgIsDirectNonEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a97bc: 9801         	ldr	r0, [sp, #0x4]
700a97be: 2110         	movs	r1, #0x10
700a97c0: f003 f996    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x332c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700a97c4: b950         	cbnz	r0, 0x700a97dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x14
700a97c6: e7ff         	b	0x700a97c8 <Sciclient_rmIrqCfgIsDirectNonEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a97c8: 9801         	ldr	r0, [sp, #0x4]
700a97ca: 2120         	movs	r1, #0x20
700a97cc: f003 f990    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x3320
;     if ((Sciclient_rmParamIsValid(valid_params,
700a97d0: b920         	cbnz	r0, 0x700a97dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x8
700a97d2: e7ff         	b	0x700a97d4 <Sciclient_rmIrqCfgIsDirectNonEvent+0x54> @ imm = #-0x2
700a97d4: 2001         	movs	r0, #0x1
;         r = true;
700a97d6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a97da: e7ff         	b	0x700a97dc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #-0x2
;     return r;
700a97dc: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a97e0: f000 0001    	and	r0, r0, #0x1
700a97e4: b002         	add	sp, #0x8
700a97e6: bd80         	pop	{r7, pc}
		...

700a97f0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly>:
; {
700a97f0: b580         	push	{r7, lr}
700a97f2: b082         	sub	sp, #0x8
700a97f4: 9001         	str	r0, [sp, #0x4]
700a97f6: 2000         	movs	r0, #0x0
;     bool r = false;
700a97f8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a97fc: 9801         	ldr	r0, [sp, #0x4]
700a97fe: 2101         	movs	r1, #0x1
700a9800: f003 f976    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x32ec
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700a9804: bb10         	cbnz	r0, 0x700a984c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x44
700a9806: e7ff         	b	0x700a9808 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9808: 9801         	ldr	r0, [sp, #0x4]
700a980a: 2102         	movs	r1, #0x2
700a980c: f003 f970    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x32e0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700a9810: b9e0         	cbnz	r0, 0x700a984c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x38
700a9812: e7ff         	b	0x700a9814 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9814: 9801         	ldr	r0, [sp, #0x4]
700a9816: 2104         	movs	r1, #0x4
700a9818: f003 f96a    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x32d4
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700a981c: b1b0         	cbz	r0, 0x700a984c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x2c
700a981e: e7ff         	b	0x700a9820 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9820: 9801         	ldr	r0, [sp, #0x4]
700a9822: 2108         	movs	r1, #0x8
700a9824: f003 f964    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x32c8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700a9828: b180         	cbz	r0, 0x700a984c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x20
700a982a: e7ff         	b	0x700a982c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a982c: 9801         	ldr	r0, [sp, #0x4]
700a982e: 2110         	movs	r1, #0x10
700a9830: f003 f95e    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x32bc
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700a9834: b150         	cbz	r0, 0x700a984c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x14
700a9836: e7ff         	b	0x700a9838 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9838: 9801         	ldr	r0, [sp, #0x4]
700a983a: 2120         	movs	r1, #0x20
700a983c: f003 f958    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x32b0
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9840: b120         	cbz	r0, 0x700a984c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x8
700a9842: e7ff         	b	0x700a9844 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x54> @ imm = #-0x2
700a9844: 2001         	movs	r0, #0x1
;         r = true;
700a9846: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a984a: e7ff         	b	0x700a984c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #-0x2
;     return r;
700a984c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9850: f000 0001    	and	r0, r0, #0x1
700a9854: b002         	add	sp, #0x8
700a9856: bd80         	pop	{r7, pc}
		...

700a9860 <Sciclient_rmIrqCfgIsOesOnly>:
; {
700a9860: b580         	push	{r7, lr}
700a9862: b082         	sub	sp, #0x8
700a9864: 9001         	str	r0, [sp, #0x4]
700a9866: 2000         	movs	r0, #0x0
;     bool r = false;
700a9868: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a986c: 9801         	ldr	r0, [sp, #0x4]
700a986e: 2101         	movs	r1, #0x1
700a9870: f003 f93e    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x327c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700a9874: bb10         	cbnz	r0, 0x700a98bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x44
700a9876: e7ff         	b	0x700a9878 <Sciclient_rmIrqCfgIsOesOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9878: 9801         	ldr	r0, [sp, #0x4]
700a987a: 2102         	movs	r1, #0x2
700a987c: f003 f938    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x3270
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700a9880: b9e0         	cbnz	r0, 0x700a98bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x38
700a9882: e7ff         	b	0x700a9884 <Sciclient_rmIrqCfgIsOesOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9884: 9801         	ldr	r0, [sp, #0x4]
700a9886: 2104         	movs	r1, #0x4
700a9888: f003 f932    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x3264
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700a988c: b9b0         	cbnz	r0, 0x700a98bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x2c
700a988e: e7ff         	b	0x700a9890 <Sciclient_rmIrqCfgIsOesOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9890: 9801         	ldr	r0, [sp, #0x4]
700a9892: 2108         	movs	r1, #0x8
700a9894: f003 f92c    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x3258
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700a9898: b980         	cbnz	r0, 0x700a98bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x20
700a989a: e7ff         	b	0x700a989c <Sciclient_rmIrqCfgIsOesOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a989c: 9801         	ldr	r0, [sp, #0x4]
700a989e: 2110         	movs	r1, #0x10
700a98a0: f003 f926    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x324c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700a98a4: b150         	cbz	r0, 0x700a98bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x14
700a98a6: e7ff         	b	0x700a98a8 <Sciclient_rmIrqCfgIsOesOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a98a8: 9801         	ldr	r0, [sp, #0x4]
700a98aa: 2120         	movs	r1, #0x20
700a98ac: f003 f920    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x3240
;     if ((Sciclient_rmParamIsValid(valid_params,
700a98b0: b920         	cbnz	r0, 0x700a98bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x8
700a98b2: e7ff         	b	0x700a98b4 <Sciclient_rmIrqCfgIsOesOnly+0x54> @ imm = #-0x2
700a98b4: 2001         	movs	r0, #0x1
;         r = true;
700a98b6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a98ba: e7ff         	b	0x700a98bc <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #-0x2
;     return r;
700a98bc: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a98c0: f000 0001    	and	r0, r0, #0x1
700a98c4: b002         	add	sp, #0x8
700a98c6: bd80         	pop	{r7, pc}
		...

700a98d0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent>:
; {
700a98d0: b580         	push	{r7, lr}
700a98d2: b082         	sub	sp, #0x8
700a98d4: 9001         	str	r0, [sp, #0x4]
700a98d6: 2000         	movs	r0, #0x0
;     bool r = false;
700a98d8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a98dc: 9801         	ldr	r0, [sp, #0x4]
700a98de: 2101         	movs	r1, #0x1
700a98e0: f003 f906    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x320c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700a98e4: b310         	cbz	r0, 0x700a992c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x44
700a98e6: e7ff         	b	0x700a98e8 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a98e8: 9801         	ldr	r0, [sp, #0x4]
700a98ea: 2102         	movs	r1, #0x2
700a98ec: f003 f900    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x3200
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700a98f0: b1e0         	cbz	r0, 0x700a992c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x38
700a98f2: e7ff         	b	0x700a98f4 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a98f4: 9801         	ldr	r0, [sp, #0x4]
700a98f6: 2104         	movs	r1, #0x4
700a98f8: f003 f8fa    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x31f4
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700a98fc: b1b0         	cbz	r0, 0x700a992c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x2c
700a98fe: e7ff         	b	0x700a9900 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9900: 9801         	ldr	r0, [sp, #0x4]
700a9902: 2108         	movs	r1, #0x8
700a9904: f003 f8f4    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x31e8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700a9908: b180         	cbz	r0, 0x700a992c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x20
700a990a: e7ff         	b	0x700a990c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a990c: 9801         	ldr	r0, [sp, #0x4]
700a990e: 2110         	movs	r1, #0x10
700a9910: f003 f8ee    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x31dc
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700a9914: b950         	cbnz	r0, 0x700a992c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x14
700a9916: e7ff         	b	0x700a9918 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9918: 9801         	ldr	r0, [sp, #0x4]
700a991a: 2120         	movs	r1, #0x20
700a991c: f003 f8e8    	bl	0x700acaf0 <Sciclient_rmParamIsValid> @ imm = #0x31d0
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9920: b920         	cbnz	r0, 0x700a992c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x8
700a9922: e7ff         	b	0x700a9924 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x54> @ imm = #-0x2
700a9924: 2001         	movs	r0, #0x1
;         r = true;
700a9926: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a992a: e7ff         	b	0x700a992c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700a992c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9930: f000 0001    	and	r0, r0, #0x1
700a9934: b002         	add	sp, #0x8
700a9936: bd80         	pop	{r7, pc}
		...

700a9940 <UART_divisorValCompute>:
; {
700a9940: b580         	push	{r7, lr}
700a9942: b088         	sub	sp, #0x20
700a9944: 9007         	str	r0, [sp, #0x1c]
700a9946: 9106         	str	r1, [sp, #0x18]
700a9948: 9205         	str	r2, [sp, #0x14]
700a994a: 9304         	str	r3, [sp, #0x10]
700a994c: 2000         	movs	r0, #0x0
;     uint32_t divisorValue = 0U;
700a994e: 9003         	str	r0, [sp, #0xc]
;     uint32_t tempModeFlag = modeFlag & UART_MDR1_MODE_SELECT_MASK;
700a9950: 9805         	ldr	r0, [sp, #0x14]
700a9952: f000 0007    	and	r0, r0, #0x7
700a9956: 9002         	str	r0, [sp, #0x8]
;     switch (tempModeFlag)
700a9958: 9802         	ldr	r0, [sp, #0x8]
700a995a: 9001         	str	r0, [sp, #0x4]
700a995c: 2805         	cmp	r0, #0x5
700a995e: d81f         	bhi	0x700a99a0 <UART_divisorValCompute+0x60> @ imm = #0x3e
700a9960: 9901         	ldr	r1, [sp, #0x4]
700a9962: e8df f001    	tbb	[pc, r1]
700a9966: 03 03 1d 0a  	.word	0x0a1d0303
700a996a: 12 1a        	.short	0x1a12
;             divisorValue = UART_divideRoundCloset(moduleClk, 16U * baudRate);
700a996c: 9807         	ldr	r0, [sp, #0x1c]
700a996e: 9906         	ldr	r1, [sp, #0x18]
700a9970: 0109         	lsls	r1, r1, #0x4
700a9972: f003 fe5d    	bl	0x700ad630 <UART_divideRoundCloset> @ imm = #0x3cba
700a9976: 9003         	str	r0, [sp, #0xc]
;             break;
700a9978: e013         	b	0x700a99a2 <UART_divisorValCompute+0x62> @ imm = #0x26
;             divisorValue = UART_divideRoundCloset(moduleClk, 13U * baudRate);
700a997a: 9807         	ldr	r0, [sp, #0x1c]
700a997c: 9906         	ldr	r1, [sp, #0x18]
700a997e: 220d         	movs	r2, #0xd
700a9980: 4351         	muls	r1, r2, r1
700a9982: f003 fe55    	bl	0x700ad630 <UART_divideRoundCloset> @ imm = #0x3caa
700a9986: 9003         	str	r0, [sp, #0xc]
;             break;
700a9988: e00b         	b	0x700a99a2 <UART_divisorValCompute+0x62> @ imm = #0x16
;             divisorValue = UART_divideRoundCloset(moduleClk, mirOverSampRate * baudRate);
700a998a: 9807         	ldr	r0, [sp, #0x1c]
700a998c: 9904         	ldr	r1, [sp, #0x10]
700a998e: 9a06         	ldr	r2, [sp, #0x18]
700a9990: 4351         	muls	r1, r2, r1
700a9992: f003 fe4d    	bl	0x700ad630 <UART_divideRoundCloset> @ imm = #0x3c9a
700a9996: 9003         	str	r0, [sp, #0xc]
;             break;
700a9998: e003         	b	0x700a99a2 <UART_divisorValCompute+0x62> @ imm = #0x6
700a999a: 2000         	movs	r0, #0x0
;             divisorValue = 0U;
700a999c: 9003         	str	r0, [sp, #0xc]
;             break;
700a999e: e000         	b	0x700a99a2 <UART_divisorValCompute+0x62> @ imm = #0x0
;             break;
700a99a0: e7ff         	b	0x700a99a2 <UART_divisorValCompute+0x62> @ imm = #-0x2
;     return divisorValue;
700a99a2: 9803         	ldr	r0, [sp, #0xc]
700a99a4: b008         	add	sp, #0x20
700a99a6: bd80         	pop	{r7, pc}
		...

700a99b0 <CSL_udmapCppi5SetIds>:
; {
700a99b0: b085         	sub	sp, #0x14
700a99b2: 9004         	str	r0, [sp, #0x10]
700a99b4: 9103         	str	r1, [sp, #0xc]
700a99b6: 9202         	str	r2, [sp, #0x8]
700a99b8: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700a99ba: 9803         	ldr	r0, [sp, #0xc]
700a99bc: 2803         	cmp	r0, #0x3
700a99be: d114         	bne	0x700a99ea <CSL_udmapCppi5SetIds+0x3a> @ imm = #0x28
700a99c0: e7ff         	b	0x700a99c2 <CSL_udmapCppi5SetIds+0x12> @ imm = #-0x2
;         v = ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo;
700a99c2: 9804         	ldr	r0, [sp, #0x10]
700a99c4: 6840         	ldr	r0, [r0, #0x4]
700a99c6: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_TRPD_PKTINFO_PKTID_MASK | CSL_UDMAP_CPPI5_TRPD_PKTINFO_FLOWID_MASK);
700a99c8: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a99cc: 0600         	lsls	r0, r0, #0x18
700a99ce: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700a99d0: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_FLOWID, flowId );
700a99d2: 9901         	ldr	r1, [sp, #0x4]
700a99d4: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700a99d8: f360 3197    	bfi	r1, r0, #14, #10
700a99dc: 9800         	ldr	r0, [sp]
700a99de: 4308         	orrs	r0, r1
700a99e0: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo = v;
700a99e2: 9800         	ldr	r0, [sp]
700a99e4: 9904         	ldr	r1, [sp, #0x10]
700a99e6: 6048         	str	r0, [r1, #0x4]
;     }
700a99e8: e013         	b	0x700a9a12 <CSL_udmapCppi5SetIds+0x62> @ imm = #0x26
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1;
700a99ea: 9804         	ldr	r0, [sp, #0x10]
700a99ec: 6840         	ldr	r0, [r0, #0x4]
700a99ee: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_PD_PKTINFO1_PKTID_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO1_FLOWID_MASK);
700a99f0: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a99f4: 0600         	lsls	r0, r0, #0x18
700a99f6: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700a99f8: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_FLOWID, flowId );
700a99fa: 9901         	ldr	r1, [sp, #0x4]
700a99fc: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700a9a00: f360 3197    	bfi	r1, r0, #14, #10
700a9a04: 9800         	ldr	r0, [sp]
700a9a06: 4308         	orrs	r0, r1
700a9a08: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1 = v;
700a9a0a: 9800         	ldr	r0, [sp]
700a9a0c: 9904         	ldr	r1, [sp, #0x10]
700a9a0e: 6048         	str	r0, [r1, #0x4]
700a9a10: e7ff         	b	0x700a9a12 <CSL_udmapCppi5SetIds+0x62> @ imm = #-0x2
; }
700a9a12: b005         	add	sp, #0x14
700a9a14: 4770         	bx	lr
		...
700a9a1e: 0000         	movs	r0, r0

700a9a20 <Sciclient_rmIrGetInst>:
; {
700a9a20: b083         	sub	sp, #0xc
700a9a22: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a9a26: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIrInst *inst = NULL;
700a9a28: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700a9a2a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700a9a2e: e7ff         	b	0x700a9a30 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x2
700a9a30: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a9a34: 2803         	cmp	r0, #0x3
700a9a36: dc22         	bgt	0x700a9a7e <Sciclient_rmIrGetInst+0x5e> @ imm = #0x44
700a9a38: e7ff         	b	0x700a9a3a <Sciclient_rmIrGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIrInstances[i].dev_id) {
700a9a3a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a9a3e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a9a42: eb01 0241    	add.w	r2, r1, r1, lsl #1
700a9a46: f240 21cc    	movw	r1, #0x2cc
700a9a4a: f2c7 010b    	movt	r1, #0x700b
700a9a4e: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700a9a52: 4288         	cmp	r0, r1
700a9a54: d10c         	bne	0x700a9a70 <Sciclient_rmIrGetInst+0x50> @ imm = #0x18
700a9a56: e7ff         	b	0x700a9a58 <Sciclient_rmIrGetInst+0x38> @ imm = #-0x2
;             inst = &gRmIrInstances[i];
700a9a58: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a9a5c: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a9a60: f240 20cc    	movw	r0, #0x2cc
700a9a64: f2c7 000b    	movt	r0, #0x700b
700a9a68: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a9a6c: 9001         	str	r0, [sp, #0x4]
;             break;
700a9a6e: e006         	b	0x700a9a7e <Sciclient_rmIrGetInst+0x5e> @ imm = #0xc
;     }
700a9a70: e7ff         	b	0x700a9a72 <Sciclient_rmIrGetInst+0x52> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700a9a72: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a9a76: 3001         	adds	r0, #0x1
700a9a78: f8ad 0002    	strh.w	r0, [sp, #0x2]
700a9a7c: e7d8         	b	0x700a9a30 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x50
;     return inst;
700a9a7e: 9801         	ldr	r0, [sp, #0x4]
700a9a80: b003         	add	sp, #0xc
700a9a82: 4770         	bx	lr
		...

700a9a90 <UART_fifoRegisterWrite>:
; {
700a9a90: b580         	push	{r7, lr}
700a9a92: b088         	sub	sp, #0x20
700a9a94: 9007         	str	r0, [sp, #0x1c]
700a9a96: 9106         	str	r1, [sp, #0x18]
700a9a98: 2000         	movs	r0, #0x0
;     uint32_t isTxRxFifoEmpty = FALSE;
700a9a9a: 9001         	str	r0, [sp, #0x4]
700a9a9c: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a9a9e: 9807         	ldr	r0, [sp, #0x1c]
700a9aa0: 2180         	movs	r1, #0x80
700a9aa2: f000 fdf5    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #0xbea
700a9aa6: 9901         	ldr	r1, [sp, #0x4]
700a9aa8: 9003         	str	r0, [sp, #0xc]
;     divLatchRegVal = UART_divisorLatchWrite(baseAddr, 0x0000U);
700a9aaa: 9807         	ldr	r0, [sp, #0x1c]
700a9aac: f7f9 fac8    	bl	0x700a3040 <UART_divisorLatchWrite> @ imm = #-0x6a70
700a9ab0: 9005         	str	r0, [sp, #0x14]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
700a9ab2: 9807         	ldr	r0, [sp, #0x1c]
700a9ab4: f002 fa34    	bl	0x700abf20 <UART_enhanFuncEnable> @ imm = #0x2468
700a9ab8: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_FCR, fcrValue);
700a9aba: 9807         	ldr	r0, [sp, #0x1c]
700a9abc: 3008         	adds	r0, #0x8
700a9abe: 9906         	ldr	r1, [sp, #0x18]
700a9ac0: f003 ff06    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x3e0c
;     while(isTxRxFifoEmpty == FALSE)
700a9ac4: e7ff         	b	0x700a9ac6 <UART_fifoRegisterWrite+0x36> @ imm = #-0x2
700a9ac6: 9802         	ldr	r0, [sp, #0x8]
700a9ac8: b928         	cbnz	r0, 0x700a9ad6 <UART_fifoRegisterWrite+0x46> @ imm = #0xa
700a9aca: e7ff         	b	0x700a9acc <UART_fifoRegisterWrite+0x3c> @ imm = #-0x2
;         isTxRxFifoEmpty = UART_IsTxRxFifoEmpty(baseAddr);
700a9acc: 9807         	ldr	r0, [sp, #0x1c]
700a9ace: f002 fa07    	bl	0x700abee0 <UART_IsTxRxFifoEmpty> @ imm = #0x240e
700a9ad2: 9002         	str	r0, [sp, #0x8]
;     while(isTxRxFifoEmpty == FALSE)
700a9ad4: e7f7         	b	0x700a9ac6 <UART_fifoRegisterWrite+0x36> @ imm = #-0x12
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
700a9ad6: 9807         	ldr	r0, [sp, #0x1c]
700a9ad8: 9904         	ldr	r1, [sp, #0x10]
700a9ada: f002 fd19    	bl	0x700ac510 <UART_enhanFuncBitValRestore> @ imm = #0x2a32
;     (void) UART_divisorLatchWrite(baseAddr, divLatchRegVal);
700a9ade: 9807         	ldr	r0, [sp, #0x1c]
700a9ae0: 9905         	ldr	r1, [sp, #0x14]
700a9ae2: f7f9 faad    	bl	0x700a3040 <UART_divisorLatchWrite> @ imm = #-0x6aa6
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9ae6: 9807         	ldr	r0, [sp, #0x1c]
700a9ae8: 300c         	adds	r0, #0xc
700a9aea: 9903         	ldr	r1, [sp, #0xc]
700a9aec: f003 fef0    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x3de0
; }
700a9af0: b008         	add	sp, #0x20
700a9af2: bd80         	pop	{r7, pc}
		...

700a9b00 <UART_lld_deInitDma>:
; {
700a9b00: b580         	push	{r7, lr}
700a9b02: b084         	sub	sp, #0x10
700a9b04: 9003         	str	r0, [sp, #0xc]
700a9b06: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700a9b08: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700a9b0a: 9803         	ldr	r0, [sp, #0xc]
700a9b0c: b318         	cbz	r0, 0x700a9b56 <UART_lld_deInitDma+0x56> @ imm = #0x46
700a9b0e: e7ff         	b	0x700a9b10 <UART_lld_deInitDma+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a9b10: 9903         	ldr	r1, [sp, #0xc]
700a9b12: 2002         	movs	r0, #0x2
700a9b14: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700a9b16: 9803         	ldr	r0, [sp, #0xc]
700a9b18: f7fe fc3a    	bl	0x700a8390 <UART_lld_flushTxFifo> @ imm = #-0x178c
700a9b1c: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700a9b1e: 9802         	ldr	r0, [sp, #0x8]
700a9b20: b9a0         	cbnz	r0, 0x700a9b4c <UART_lld_deInitDma+0x4c> @ imm = #0x28
700a9b22: e7ff         	b	0x700a9b24 <UART_lld_deInitDma+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700a9b24: 9803         	ldr	r0, [sp, #0xc]
700a9b26: 6800         	ldr	r0, [r0]
700a9b28: 2107         	movs	r1, #0x7
700a9b2a: 9101         	str	r1, [sp, #0x4]
700a9b2c: f7fa fcf0    	bl	0x700a4510 <UART_intrDisable> @ imm = #-0x5620
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700a9b30: 9803         	ldr	r0, [sp, #0xc]
700a9b32: 6800         	ldr	r0, [r0]
700a9b34: 2102         	movs	r1, #0x2
700a9b36: f003 f823    	bl	0x700acb80 <UART_intr2Disable> @ imm = #0x3046
700a9b3a: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700a9b3c: 9803         	ldr	r0, [sp, #0xc]
700a9b3e: 6800         	ldr	r0, [r0]
700a9b40: f003 f866    	bl	0x700acc10 <UART_operatingModeSelect> @ imm = #0x30cc
;             hUart->state = UART_STATE_RESET;
700a9b44: 9903         	ldr	r1, [sp, #0xc]
700a9b46: 2000         	movs	r0, #0x0
700a9b48: 6548         	str	r0, [r1, #0x54]
;         }
700a9b4a: e7ff         	b	0x700a9b4c <UART_lld_deInitDma+0x4c> @ imm = #-0x2
;         status = UART_lld_dmaDeInit(hUart);
700a9b4c: 9803         	ldr	r0, [sp, #0xc]
700a9b4e: f002 fa07    	bl	0x700abf60 <UART_lld_dmaDeInit> @ imm = #0x240e
700a9b52: 9002         	str	r0, [sp, #0x8]
;     }
700a9b54: e003         	b	0x700a9b5e <UART_lld_deInitDma+0x5e> @ imm = #0x6
700a9b56: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a9b5a: 9002         	str	r0, [sp, #0x8]
700a9b5c: e7ff         	b	0x700a9b5e <UART_lld_deInitDma+0x5e> @ imm = #-0x2
;     return status;
700a9b5e: 9802         	ldr	r0, [sp, #0x8]
700a9b60: b004         	add	sp, #0x10
700a9b62: bd80         	pop	{r7, pc}
		...

700a9b70 <Udma_rmFreeEvent>:
; {
700a9b70: b580         	push	{r7, lr}
700a9b72: b088         	sub	sp, #0x20
700a9b74: 9007         	str	r0, [sp, #0x1c]
700a9b76: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9b78: 9806         	ldr	r0, [sp, #0x18]
700a9b7a: f500 70ea    	add.w	r0, r0, #0x1d4
700a9b7e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9b80: 9806         	ldr	r0, [sp, #0x18]
700a9b82: f500 609f    	add.w	r0, r0, #0x4f8
700a9b86: f04f 31ff    	mov.w	r1, #0xffffffff
700a9b8a: f7fe fdb1    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x149e
;     i = globalEvent - rmInitPrms->startGlobalEvent;
700a9b8e: 9807         	ldr	r0, [sp, #0x1c]
700a9b90: 9901         	ldr	r1, [sp, #0x4]
700a9b92: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a9b96: 1a40         	subs	r0, r0, r1
700a9b98: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9b9a: 9805         	ldr	r0, [sp, #0x14]
700a9b9c: 0940         	lsrs	r0, r0, #0x5
700a9b9e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9ba0: 9805         	ldr	r0, [sp, #0x14]
700a9ba2: 9904         	ldr	r1, [sp, #0x10]
700a9ba4: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9ba8: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9baa: 9903         	ldr	r1, [sp, #0xc]
700a9bac: 2001         	movs	r0, #0x1
700a9bae: 4088         	lsls	r0, r1
700a9bb0: 9002         	str	r0, [sp, #0x8]
;     drvHandle->globalEventFlag[offset] |= bitMask;
700a9bb2: 9a02         	ldr	r2, [sp, #0x8]
700a9bb4: 9806         	ldr	r0, [sp, #0x18]
700a9bb6: 9904         	ldr	r1, [sp, #0x10]
700a9bb8: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9bbc: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700a9bc0: 4310         	orrs	r0, r2
700a9bc2: f8c1 0424    	str.w	r0, [r1, #0x424]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9bc6: 9806         	ldr	r0, [sp, #0x18]
700a9bc8: f500 609f    	add.w	r0, r0, #0x4f8
700a9bcc: f000 f8e8    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x1d0
;     return;
700a9bd0: b008         	add	sp, #0x20
700a9bd2: bd80         	pop	{r7, pc}
		...

700a9be0 <Udma_rmFreeIrIntr>:
; {
700a9be0: b580         	push	{r7, lr}
700a9be2: b088         	sub	sp, #0x20
700a9be4: 9007         	str	r0, [sp, #0x1c]
700a9be6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9be8: 9806         	ldr	r0, [sp, #0x18]
700a9bea: f500 70ea    	add.w	r0, r0, #0x1d4
700a9bee: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9bf0: 9806         	ldr	r0, [sp, #0x18]
700a9bf2: f500 609f    	add.w	r0, r0, #0x4f8
700a9bf6: f04f 31ff    	mov.w	r1, #0xffffffff
700a9bfa: f7fe fd79    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x150e
;     i = irIntrNum - rmInitPrms->startIrIntr;
700a9bfe: 9807         	ldr	r0, [sp, #0x1c]
700a9c00: 9901         	ldr	r1, [sp, #0x4]
700a9c02: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a9c06: 1a40         	subs	r0, r0, r1
700a9c08: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9c0a: 9805         	ldr	r0, [sp, #0x14]
700a9c0c: 0940         	lsrs	r0, r0, #0x5
700a9c0e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9c10: 9805         	ldr	r0, [sp, #0x14]
700a9c12: 9904         	ldr	r1, [sp, #0x10]
700a9c14: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9c18: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9c1a: 9903         	ldr	r1, [sp, #0xc]
700a9c1c: 2001         	movs	r0, #0x1
700a9c1e: 4088         	lsls	r0, r1
700a9c20: 9002         	str	r0, [sp, #0x8]
;     drvHandle->irIntrFlag[offset] |= bitMask;
700a9c22: 9a02         	ldr	r2, [sp, #0x8]
700a9c24: 9806         	ldr	r0, [sp, #0x18]
700a9c26: 9904         	ldr	r1, [sp, #0x10]
700a9c28: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9c2c: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a9c30: 4310         	orrs	r0, r2
700a9c32: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9c36: 9806         	ldr	r0, [sp, #0x18]
700a9c38: f500 609f    	add.w	r0, r0, #0x4f8
700a9c3c: f000 f8b0    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0x160
;     return;
700a9c40: b008         	add	sp, #0x20
700a9c42: bd80         	pop	{r7, pc}
		...

700a9c50 <Udma_rmFreeVintr>:
; {
700a9c50: b580         	push	{r7, lr}
700a9c52: b088         	sub	sp, #0x20
700a9c54: 9007         	str	r0, [sp, #0x1c]
700a9c56: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9c58: 9806         	ldr	r0, [sp, #0x18]
700a9c5a: f500 70ea    	add.w	r0, r0, #0x1d4
700a9c5e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9c60: 9806         	ldr	r0, [sp, #0x18]
700a9c62: f500 609f    	add.w	r0, r0, #0x4f8
700a9c66: f04f 31ff    	mov.w	r1, #0xffffffff
700a9c6a: f7fe fd41    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x157e
;     i = vintrNum - rmInitPrms->startVintr;
700a9c6e: 9807         	ldr	r0, [sp, #0x1c]
700a9c70: 9901         	ldr	r1, [sp, #0x4]
700a9c72: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700a9c76: 1a40         	subs	r0, r0, r1
700a9c78: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9c7a: 9805         	ldr	r0, [sp, #0x14]
700a9c7c: 0940         	lsrs	r0, r0, #0x5
700a9c7e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9c80: 9805         	ldr	r0, [sp, #0x14]
700a9c82: 9904         	ldr	r1, [sp, #0x10]
700a9c84: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9c88: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9c8a: 9903         	ldr	r1, [sp, #0xc]
700a9c8c: 2001         	movs	r0, #0x1
700a9c8e: 4088         	lsls	r0, r1
700a9c90: 9002         	str	r0, [sp, #0x8]
;     drvHandle->vintrFlag[offset] |= bitMask;
700a9c92: 9a02         	ldr	r2, [sp, #0x8]
700a9c94: 9806         	ldr	r0, [sp, #0x18]
700a9c96: 9904         	ldr	r1, [sp, #0x10]
700a9c98: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9c9c: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700a9ca0: 4310         	orrs	r0, r2
700a9ca2: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9ca6: 9806         	ldr	r0, [sp, #0x18]
700a9ca8: f500 609f    	add.w	r0, r0, #0x4f8
700a9cac: f000 f878    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #0xf0
;     return;
700a9cb0: b008         	add	sp, #0x20
700a9cb2: bd80         	pop	{r7, pc}
		...

700a9cc0 <vApplicationLoadHook>:
; {
700a9cc0: b580         	push	{r7, lr}
700a9cc2: b082         	sub	sp, #0x8
;     uint64_t curUpdateTime = ClockP_getTimeUsec();
700a9cc4: f7fe ff2c    	bl	0x700a8b20 <ClockP_getTimeUsec> @ imm = #-0x11a8
700a9cc8: 9101         	str	r1, [sp, #0x4]
700a9cca: 9000         	str	r0, [sp]
;     if( (curUpdateTime > lastUpdateTime) && ((curUpdateTime - lastUpdateTime) > (TaskP_LOAD_UPDATE_WINDOW_MSEC*1000u )) )
700a9ccc: 9b00         	ldr	r3, [sp]
700a9cce: 9901         	ldr	r1, [sp, #0x4]
700a9cd0: f240 4098    	movw	r0, #0x498
700a9cd4: f2c7 000b    	movt	r0, #0x700b
700a9cd8: 6802         	ldr	r2, [r0]
700a9cda: 6840         	ldr	r0, [r0, #0x4]
700a9cdc: 1ad2         	subs	r2, r2, r3
700a9cde: 4188         	sbcs	r0, r1
700a9ce0: d21e         	bhs	0x700a9d20 <vApplicationLoadHook+0x60> @ imm = #0x3c
700a9ce2: e7ff         	b	0x700a9ce4 <vApplicationLoadHook+0x24> @ imm = #-0x2
700a9ce4: 9900         	ldr	r1, [sp]
700a9ce6: 9801         	ldr	r0, [sp, #0x4]
700a9ce8: f240 4298    	movw	r2, #0x498
700a9cec: f2c7 020b    	movt	r2, #0x700b
700a9cf0: 6813         	ldr	r3, [r2]
700a9cf2: 6852         	ldr	r2, [r2, #0x4]
700a9cf4: 1ac9         	subs	r1, r1, r3
700a9cf6: 4190         	sbcs	r0, r2
700a9cf8: f24a 1221    	movw	r2, #0xa121
700a9cfc: f2c0 0207    	movt	r2, #0x7
700a9d00: 1a89         	subs	r1, r1, r2
700a9d02: f170 0000    	sbcs	r0, r0, #0x0
700a9d06: d30b         	blo	0x700a9d20 <vApplicationLoadHook+0x60> @ imm = #0x16
700a9d08: e7ff         	b	0x700a9d0a <vApplicationLoadHook+0x4a> @ imm = #-0x2
;         TaskP_loadUpdateAll();
700a9d0a: f7f8 ff61    	bl	0x700a2bd0 <TaskP_loadUpdateAll> @ imm = #-0x713e
;         lastUpdateTime = curUpdateTime;
700a9d0e: 9800         	ldr	r0, [sp]
700a9d10: 9a01         	ldr	r2, [sp, #0x4]
700a9d12: f240 4198    	movw	r1, #0x498
700a9d16: f2c7 010b    	movt	r1, #0x700b
700a9d1a: 604a         	str	r2, [r1, #0x4]
700a9d1c: 6008         	str	r0, [r1]
;     }
700a9d1e: e7ff         	b	0x700a9d20 <vApplicationLoadHook+0x60> @ imm = #-0x2
; }
700a9d20: b002         	add	sp, #0x8
700a9d22: bd80         	pop	{r7, pc}
		...

700a9d30 <vQueueWaitForMessageRestricted>:
;     {
700a9d30: b580         	push	{r7, lr}
700a9d32: b084         	sub	sp, #0x10
700a9d34: 9003         	str	r0, [sp, #0xc]
700a9d36: 9102         	str	r1, [sp, #0x8]
700a9d38: 9201         	str	r2, [sp, #0x4]
;         Queue_t * const pxQueue = xQueue;
700a9d3a: 9803         	ldr	r0, [sp, #0xc]
700a9d3c: 9000         	str	r0, [sp]
;         prvLockQueue( pxQueue );
700a9d3e: f002 fc27    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x284e
700a9d42: 9800         	ldr	r0, [sp]
700a9d44: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a9d48: 3001         	adds	r0, #0x1
700a9d4a: b928         	cbnz	r0, 0x700a9d58 <vQueueWaitForMessageRestricted+0x28> @ imm = #0xa
700a9d4c: e7ff         	b	0x700a9d4e <vQueueWaitForMessageRestricted+0x1e> @ imm = #-0x2
700a9d4e: 9900         	ldr	r1, [sp]
700a9d50: 2000         	movs	r0, #0x0
700a9d52: f881 0044    	strb.w	r0, [r1, #0x44]
700a9d56: e7ff         	b	0x700a9d58 <vQueueWaitForMessageRestricted+0x28> @ imm = #-0x2
700a9d58: 9800         	ldr	r0, [sp]
700a9d5a: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a9d5e: 3001         	adds	r0, #0x1
700a9d60: b928         	cbnz	r0, 0x700a9d6e <vQueueWaitForMessageRestricted+0x3e> @ imm = #0xa
700a9d62: e7ff         	b	0x700a9d64 <vQueueWaitForMessageRestricted+0x34> @ imm = #-0x2
700a9d64: 9900         	ldr	r1, [sp]
700a9d66: 2000         	movs	r0, #0x0
700a9d68: f881 0045    	strb.w	r0, [r1, #0x45]
700a9d6c: e7ff         	b	0x700a9d6e <vQueueWaitForMessageRestricted+0x3e> @ imm = #-0x2
700a9d6e: f001 fccf    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0x199e
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
700a9d72: 9800         	ldr	r0, [sp]
700a9d74: 6b80         	ldr	r0, [r0, #0x38]
700a9d76: b938         	cbnz	r0, 0x700a9d88 <vQueueWaitForMessageRestricted+0x58> @ imm = #0xe
700a9d78: e7ff         	b	0x700a9d7a <vQueueWaitForMessageRestricted+0x4a> @ imm = #-0x2
;             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
700a9d7a: 9800         	ldr	r0, [sp]
700a9d7c: 3024         	adds	r0, #0x24
700a9d7e: 9902         	ldr	r1, [sp, #0x8]
700a9d80: 9a01         	ldr	r2, [sp, #0x4]
700a9d82: f002 fa8d    	bl	0x700ac2a0 <vTaskPlaceOnEventListRestricted> @ imm = #0x251a
;         }
700a9d86: e000         	b	0x700a9d8a <vQueueWaitForMessageRestricted+0x5a> @ imm = #0x0
700a9d88: e7ff         	b	0x700a9d8a <vQueueWaitForMessageRestricted+0x5a> @ imm = #-0x2
;         prvUnlockQueue( pxQueue );
700a9d8a: 9800         	ldr	r0, [sp]
700a9d8c: f7fc f818    	bl	0x700a5dc0 <prvUnlockQueue> @ imm = #-0x3fd0
;     }
700a9d90: b004         	add	sp, #0x10
700a9d92: bd80         	pop	{r7, pc}
		...

700a9da0 <SemaphoreP_post>:
; {
700a9da0: b580         	push	{r7, lr}
700a9da2: b084         	sub	sp, #0x10
700a9da4: 9003         	str	r0, [sp, #0xc]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700a9da6: 9803         	ldr	r0, [sp, #0xc]
700a9da8: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700a9daa: 9802         	ldr	r0, [sp, #0x8]
700a9dac: 6d40         	ldr	r0, [r0, #0x54]
700a9dae: b170         	cbz	r0, 0x700a9dce <SemaphoreP_post+0x2e> @ imm = #0x1c
700a9db0: e7ff         	b	0x700a9db2 <SemaphoreP_post+0x12> @ imm = #-0x2
;         if( HwiP_inISR() == 0U)
700a9db2: f004 f97d    	bl	0x700ae0b0 <HwiP_inISR> @ imm = #0x42fa
700a9db6: b928         	cbnz	r0, 0x700a9dc4 <SemaphoreP_post+0x24> @ imm = #0xa
700a9db8: e7ff         	b	0x700a9dba <SemaphoreP_post+0x1a> @ imm = #-0x2
;             (void)xSemaphoreGiveRecursive(pSemaphore->semHndl);
700a9dba: 9802         	ldr	r0, [sp, #0x8]
700a9dbc: 6d00         	ldr	r0, [r0, #0x50]
700a9dbe: f001 f937    	bl	0x700ab030 <xQueueGiveMutexRecursive> @ imm = #0x126e
;         }
700a9dc2: e003         	b	0x700a9dcc <SemaphoreP_post+0x2c> @ imm = #0x6
700a9dc4: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700a9dc6: f005 f913    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x5226
700a9dca: e7ff         	b	0x700a9dcc <SemaphoreP_post+0x2c> @ imm = #-0x2
;     }
700a9dcc: e017         	b	0x700a9dfe <SemaphoreP_post+0x5e> @ imm = #0x2e
;         if( HwiP_inISR() != 0U)
700a9dce: f004 f96f    	bl	0x700ae0b0 <HwiP_inISR> @ imm = #0x42de
700a9dd2: b158         	cbz	r0, 0x700a9dec <SemaphoreP_post+0x4c> @ imm = #0x16
700a9dd4: e7ff         	b	0x700a9dd6 <SemaphoreP_post+0x36> @ imm = #-0x2
700a9dd6: 2000         	movs	r0, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700a9dd8: 9001         	str	r0, [sp, #0x4]
;             (void)xSemaphoreGiveFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700a9dda: 9802         	ldr	r0, [sp, #0x8]
700a9ddc: 6d00         	ldr	r0, [r0, #0x50]
700a9dde: a901         	add	r1, sp, #0x4
700a9de0: f7fd fde6    	bl	0x700a79b0 <xQueueGiveFromISR> @ imm = #-0x2434
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700a9de4: 9801         	ldr	r0, [sp, #0x4]
700a9de6: f003 faab    	bl	0x700ad340 <vPortYeildFromISR> @ imm = #0x3556
;         }
700a9dea: e007         	b	0x700a9dfc <SemaphoreP_post+0x5c> @ imm = #0xe
;             (void)xSemaphoreGive(pSemaphore->semHndl);
700a9dec: 9802         	ldr	r0, [sp, #0x8]
700a9dee: 6d00         	ldr	r0, [r0, #0x50]
700a9df0: 2300         	movs	r3, #0x0
700a9df2: 4619         	mov	r1, r3
700a9df4: 461a         	mov	r2, r3
700a9df6: f7f7 fbcb    	bl	0x700a1590 <xQueueGenericSend> @ imm = #-0x886a
700a9dfa: e7ff         	b	0x700a9dfc <SemaphoreP_post+0x5c> @ imm = #-0x2
700a9dfc: e7ff         	b	0x700a9dfe <SemaphoreP_post+0x5e> @ imm = #-0x2
; }
700a9dfe: b004         	add	sp, #0x10
700a9e00: bd80         	pop	{r7, pc}
		...
700a9e0e: 0000         	movs	r0, r0

700a9e10 <UdmaEventPrms_init>:
; {
700a9e10: b082         	sub	sp, #0x8
700a9e12: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventPrms)
700a9e14: 9801         	ldr	r0, [sp, #0x4]
700a9e16: b350         	cbz	r0, 0x700a9e6e <UdmaEventPrms_init+0x5e> @ imm = #0x54
700a9e18: e7ff         	b	0x700a9e1a <UdmaEventPrms_init+0xa> @ imm = #-0x2
;         eventPrms->eventType            = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a9e1a: 9801         	ldr	r0, [sp, #0x4]
700a9e1c: 2101         	movs	r1, #0x1
700a9e1e: 6001         	str	r1, [r0]
;         eventPrms->eventMode            = UDMA_EVENT_MODE_SHARED;
700a9e20: 9a01         	ldr	r2, [sp, #0x4]
700a9e22: 2002         	movs	r0, #0x2
700a9e24: 6050         	str	r0, [r2, #0x4]
;         eventPrms->chHandle             = (Udma_ChHandle) NULL_PTR;
700a9e26: 9a01         	ldr	r2, [sp, #0x4]
700a9e28: 2000         	movs	r0, #0x0
700a9e2a: 9000         	str	r0, [sp]
700a9e2c: 6090         	str	r0, [r2, #0x8]
;         eventPrms->ringHandle           = (Udma_RingHandle) NULL_PTR;
700a9e2e: 9a01         	ldr	r2, [sp, #0x4]
700a9e30: 60d0         	str	r0, [r2, #0xc]
;         eventPrms->controllerEventHandle    = (Udma_EventHandle) NULL_PTR;
700a9e32: 9a01         	ldr	r2, [sp, #0x4]
700a9e34: 6110         	str	r0, [r2, #0x10]
;         eventPrms->eventCb              = (Udma_EventCallback) NULL_PTR;
700a9e36: 9a01         	ldr	r2, [sp, #0x4]
700a9e38: 6150         	str	r0, [r2, #0x14]
;         eventPrms->intrPriority         = 1U;
700a9e3a: 9a01         	ldr	r2, [sp, #0x4]
700a9e3c: 6191         	str	r1, [r2, #0x18]
;         eventPrms->appData              = NULL_PTR;
700a9e3e: 9901         	ldr	r1, [sp, #0x4]
700a9e40: 61c8         	str	r0, [r1, #0x1c]
;         eventPrms->preferredCoreIntrNum = UDMA_CORE_INTR_ANY;
700a9e42: 9a01         	ldr	r2, [sp, #0x4]
700a9e44: 2101         	movs	r1, #0x1
700a9e46: f6cf 71ff    	movt	r1, #0xffff
700a9e4a: 6211         	str	r1, [r2, #0x20]
;         eventPrms->intrStatusReg        = (volatile uint64_t *) NULL_PTR;
700a9e4c: 9901         	ldr	r1, [sp, #0x4]
700a9e4e: 6248         	str	r0, [r1, #0x24]
;         eventPrms->intrClearReg         = (volatile uint64_t *) NULL_PTR;
700a9e50: 9901         	ldr	r1, [sp, #0x4]
700a9e52: 6288         	str	r0, [r1, #0x28]
;         eventPrms->intrMask             = 0U;
700a9e54: 9901         	ldr	r1, [sp, #0x4]
700a9e56: 6348         	str	r0, [r1, #0x34]
700a9e58: 6308         	str	r0, [r1, #0x30]
;         eventPrms->vintrNum             = UDMA_EVENT_INVALID;
700a9e5a: 9901         	ldr	r1, [sp, #0x4]
700a9e5c: f64f 70ff    	movw	r0, #0xffff
700a9e60: 6388         	str	r0, [r1, #0x38]
;         eventPrms->coreIntrNum          = UDMA_INTR_INVALID;
700a9e62: 9901         	ldr	r1, [sp, #0x4]
700a9e64: 2000         	movs	r0, #0x0
700a9e66: f6cf 70ff    	movt	r0, #0xffff
700a9e6a: 63c8         	str	r0, [r1, #0x3c]
;     }
700a9e6c: e7ff         	b	0x700a9e6e <UdmaEventPrms_init+0x5e> @ imm = #-0x2
;     return;
700a9e6e: b002         	add	sp, #0x8
700a9e70: 4770         	bx	lr
		...
700a9e7e: 0000         	movs	r0, r0

700a9e80 <Udma_rmFreeBlkCopyCh>:
; {
700a9e80: b580         	push	{r7, lr}
700a9e82: b088         	sub	sp, #0x20
700a9e84: 9007         	str	r0, [sp, #0x1c]
700a9e86: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9e88: 9806         	ldr	r0, [sp, #0x18]
700a9e8a: f500 70ea    	add.w	r0, r0, #0x1d4
700a9e8e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9e90: 9806         	ldr	r0, [sp, #0x18]
700a9e92: f500 609f    	add.w	r0, r0, #0x4f8
700a9e96: f04f 31ff    	mov.w	r1, #0xffffffff
700a9e9a: f7fe fc29    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x17ae
;     i = chNum - rmInitPrms->startBlkCopyCh;
700a9e9e: 9807         	ldr	r0, [sp, #0x1c]
700a9ea0: 9901         	ldr	r1, [sp, #0x4]
700a9ea2: 6909         	ldr	r1, [r1, #0x10]
700a9ea4: 1a40         	subs	r0, r0, r1
700a9ea6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9ea8: 9805         	ldr	r0, [sp, #0x14]
700a9eaa: 0940         	lsrs	r0, r0, #0x5
700a9eac: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9eae: 9805         	ldr	r0, [sp, #0x14]
700a9eb0: 9904         	ldr	r1, [sp, #0x10]
700a9eb2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9eb6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9eb8: 9903         	ldr	r1, [sp, #0xc]
700a9eba: 2001         	movs	r0, #0x1
700a9ebc: 4088         	lsls	r0, r1
700a9ebe: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyChFlag[offset] |= bitMask;
700a9ec0: 9a02         	ldr	r2, [sp, #0x8]
700a9ec2: 9806         	ldr	r0, [sp, #0x18]
700a9ec4: 9904         	ldr	r1, [sp, #0x10]
700a9ec6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9eca: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a9ece: 4310         	orrs	r0, r2
700a9ed0: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9ed4: 9806         	ldr	r0, [sp, #0x18]
700a9ed6: f500 609f    	add.w	r0, r0, #0x4f8
700a9eda: f7ff ff61    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #-0x13e
;     return;
700a9ede: b008         	add	sp, #0x20
700a9ee0: bd80         	pop	{r7, pc}
		...
700a9eee: 0000         	movs	r0, r0

700a9ef0 <Udma_rmFreeBlkCopyHcCh>:
; {
700a9ef0: b580         	push	{r7, lr}
700a9ef2: b088         	sub	sp, #0x20
700a9ef4: 9007         	str	r0, [sp, #0x1c]
700a9ef6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9ef8: 9806         	ldr	r0, [sp, #0x18]
700a9efa: f500 70ea    	add.w	r0, r0, #0x1d4
700a9efe: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9f00: 9806         	ldr	r0, [sp, #0x18]
700a9f02: f500 609f    	add.w	r0, r0, #0x4f8
700a9f06: f04f 31ff    	mov.w	r1, #0xffffffff
700a9f0a: f7fe fbf1    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x181e
;     i = chNum - rmInitPrms->startBlkCopyHcCh;
700a9f0e: 9807         	ldr	r0, [sp, #0x1c]
700a9f10: 9901         	ldr	r1, [sp, #0x4]
700a9f12: 6889         	ldr	r1, [r1, #0x8]
700a9f14: 1a40         	subs	r0, r0, r1
700a9f16: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9f18: 9805         	ldr	r0, [sp, #0x14]
700a9f1a: 0940         	lsrs	r0, r0, #0x5
700a9f1c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9f1e: 9805         	ldr	r0, [sp, #0x14]
700a9f20: 9904         	ldr	r1, [sp, #0x10]
700a9f22: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9f26: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9f28: 9903         	ldr	r1, [sp, #0xc]
700a9f2a: 2001         	movs	r0, #0x1
700a9f2c: 4088         	lsls	r0, r1
700a9f2e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyHcChFlag[offset] |= bitMask;
700a9f30: 9a02         	ldr	r2, [sp, #0x8]
700a9f32: 9806         	ldr	r0, [sp, #0x18]
700a9f34: 9904         	ldr	r1, [sp, #0x10]
700a9f36: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9f3a: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a9f3e: 4310         	orrs	r0, r2
700a9f40: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9f44: 9806         	ldr	r0, [sp, #0x18]
700a9f46: f500 609f    	add.w	r0, r0, #0x4f8
700a9f4a: f7ff ff29    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #-0x1ae
;     return;
700a9f4e: b008         	add	sp, #0x20
700a9f50: bd80         	pop	{r7, pc}
		...
700a9f5e: 0000         	movs	r0, r0

700a9f60 <Udma_rmFreeBlkCopyUhcCh>:
; {
700a9f60: b580         	push	{r7, lr}
700a9f62: b088         	sub	sp, #0x20
700a9f64: 9007         	str	r0, [sp, #0x1c]
700a9f66: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9f68: 9806         	ldr	r0, [sp, #0x18]
700a9f6a: f500 70ea    	add.w	r0, r0, #0x1d4
700a9f6e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9f70: 9806         	ldr	r0, [sp, #0x18]
700a9f72: f500 609f    	add.w	r0, r0, #0x4f8
700a9f76: f04f 31ff    	mov.w	r1, #0xffffffff
700a9f7a: f7fe fbb9    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x188e
;     i = chNum - rmInitPrms->startBlkCopyUhcCh;
700a9f7e: 9807         	ldr	r0, [sp, #0x1c]
700a9f80: 9901         	ldr	r1, [sp, #0x4]
700a9f82: 6809         	ldr	r1, [r1]
700a9f84: 1a40         	subs	r0, r0, r1
700a9f86: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9f88: 9805         	ldr	r0, [sp, #0x14]
700a9f8a: 0940         	lsrs	r0, r0, #0x5
700a9f8c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9f8e: 9805         	ldr	r0, [sp, #0x14]
700a9f90: 9904         	ldr	r1, [sp, #0x10]
700a9f92: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9f96: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9f98: 9903         	ldr	r1, [sp, #0xc]
700a9f9a: 2001         	movs	r0, #0x1
700a9f9c: 4088         	lsls	r0, r1
700a9f9e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyUhcChFlag[offset] |= bitMask;
700a9fa0: 9a02         	ldr	r2, [sp, #0x8]
700a9fa2: 9806         	ldr	r0, [sp, #0x18]
700a9fa4: 9904         	ldr	r1, [sp, #0x10]
700a9fa6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9faa: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a9fae: 4310         	orrs	r0, r2
700a9fb0: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9fb4: 9806         	ldr	r0, [sp, #0x18]
700a9fb6: f500 609f    	add.w	r0, r0, #0x4f8
700a9fba: f7ff fef1    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #-0x21e
;     return;
700a9fbe: b008         	add	sp, #0x20
700a9fc0: bd80         	pop	{r7, pc}
		...
700a9fce: 0000         	movs	r0, r0

700a9fd0 <Udma_rmFreeRxCh>:
; {
700a9fd0: b580         	push	{r7, lr}
700a9fd2: b088         	sub	sp, #0x20
700a9fd4: 9007         	str	r0, [sp, #0x1c]
700a9fd6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9fd8: 9806         	ldr	r0, [sp, #0x18]
700a9fda: f500 70ea    	add.w	r0, r0, #0x1d4
700a9fde: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9fe0: 9806         	ldr	r0, [sp, #0x18]
700a9fe2: f500 609f    	add.w	r0, r0, #0x4f8
700a9fe6: f04f 31ff    	mov.w	r1, #0xffffffff
700a9fea: f7fe fb81    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x18fe
;     i = chNum - rmInitPrms->startRxCh;
700a9fee: 9807         	ldr	r0, [sp, #0x1c]
700a9ff0: 9901         	ldr	r1, [sp, #0x4]
700a9ff2: 6c09         	ldr	r1, [r1, #0x40]
700a9ff4: 1a40         	subs	r0, r0, r1
700a9ff6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9ff8: 9805         	ldr	r0, [sp, #0x14]
700a9ffa: 0940         	lsrs	r0, r0, #0x5
700a9ffc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9ffe: 9805         	ldr	r0, [sp, #0x14]
700aa000: 9904         	ldr	r1, [sp, #0x10]
700aa002: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa006: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa008: 9903         	ldr	r1, [sp, #0xc]
700aa00a: 2001         	movs	r0, #0x1
700aa00c: 4088         	lsls	r0, r1
700aa00e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxChFlag[offset] |= bitMask;
700aa010: 9a02         	ldr	r2, [sp, #0x8]
700aa012: 9806         	ldr	r0, [sp, #0x18]
700aa014: 9904         	ldr	r1, [sp, #0x10]
700aa016: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa01a: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700aa01e: 4310         	orrs	r0, r2
700aa020: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa024: 9806         	ldr	r0, [sp, #0x18]
700aa026: f500 609f    	add.w	r0, r0, #0x4f8
700aa02a: f7ff feb9    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #-0x28e
;     return;
700aa02e: b008         	add	sp, #0x20
700aa030: bd80         	pop	{r7, pc}
		...
700aa03e: 0000         	movs	r0, r0

700aa040 <Udma_rmFreeRxHcCh>:
; {
700aa040: b580         	push	{r7, lr}
700aa042: b088         	sub	sp, #0x20
700aa044: 9007         	str	r0, [sp, #0x1c]
700aa046: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa048: 9806         	ldr	r0, [sp, #0x18]
700aa04a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa04e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa050: 9806         	ldr	r0, [sp, #0x18]
700aa052: f500 609f    	add.w	r0, r0, #0x4f8
700aa056: f04f 31ff    	mov.w	r1, #0xffffffff
700aa05a: f7fe fb49    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x196e
;     i = chNum - rmInitPrms->startRxHcCh;
700aa05e: 9807         	ldr	r0, [sp, #0x1c]
700aa060: 9901         	ldr	r1, [sp, #0x4]
700aa062: 6b89         	ldr	r1, [r1, #0x38]
700aa064: 1a40         	subs	r0, r0, r1
700aa066: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa068: 9805         	ldr	r0, [sp, #0x14]
700aa06a: 0940         	lsrs	r0, r0, #0x5
700aa06c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa06e: 9805         	ldr	r0, [sp, #0x14]
700aa070: 9904         	ldr	r1, [sp, #0x10]
700aa072: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa076: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa078: 9903         	ldr	r1, [sp, #0xc]
700aa07a: 2001         	movs	r0, #0x1
700aa07c: 4088         	lsls	r0, r1
700aa07e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxHcChFlag[offset] |= bitMask;
700aa080: 9a02         	ldr	r2, [sp, #0x8]
700aa082: 9806         	ldr	r0, [sp, #0x18]
700aa084: 9904         	ldr	r1, [sp, #0x10]
700aa086: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa08a: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700aa08e: 4310         	orrs	r0, r2
700aa090: f8c1 031c    	str.w	r0, [r1, #0x31c]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa094: 9806         	ldr	r0, [sp, #0x18]
700aa096: f500 609f    	add.w	r0, r0, #0x4f8
700aa09a: f7ff fe81    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #-0x2fe
;     return;
700aa09e: b008         	add	sp, #0x20
700aa0a0: bd80         	pop	{r7, pc}
		...
700aa0ae: 0000         	movs	r0, r0

700aa0b0 <Udma_rmFreeRxUhcCh>:
; {
700aa0b0: b580         	push	{r7, lr}
700aa0b2: b088         	sub	sp, #0x20
700aa0b4: 9007         	str	r0, [sp, #0x1c]
700aa0b6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa0b8: 9806         	ldr	r0, [sp, #0x18]
700aa0ba: f500 70ea    	add.w	r0, r0, #0x1d4
700aa0be: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa0c0: 9806         	ldr	r0, [sp, #0x18]
700aa0c2: f500 609f    	add.w	r0, r0, #0x4f8
700aa0c6: f04f 31ff    	mov.w	r1, #0xffffffff
700aa0ca: f7fe fb11    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x19de
;     i = chNum - rmInitPrms->startRxUhcCh;
700aa0ce: 9807         	ldr	r0, [sp, #0x1c]
700aa0d0: 9901         	ldr	r1, [sp, #0x4]
700aa0d2: 6b09         	ldr	r1, [r1, #0x30]
700aa0d4: 1a40         	subs	r0, r0, r1
700aa0d6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa0d8: 9805         	ldr	r0, [sp, #0x14]
700aa0da: 0940         	lsrs	r0, r0, #0x5
700aa0dc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa0de: 9805         	ldr	r0, [sp, #0x14]
700aa0e0: 9904         	ldr	r1, [sp, #0x10]
700aa0e2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa0e6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa0e8: 9903         	ldr	r1, [sp, #0xc]
700aa0ea: 2001         	movs	r0, #0x1
700aa0ec: 4088         	lsls	r0, r1
700aa0ee: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxUhcChFlag[offset] |= bitMask;
700aa0f0: 9a02         	ldr	r2, [sp, #0x8]
700aa0f2: 9806         	ldr	r0, [sp, #0x18]
700aa0f4: 9904         	ldr	r1, [sp, #0x10]
700aa0f6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa0fa: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700aa0fe: 4310         	orrs	r0, r2
700aa100: f8c1 0320    	str.w	r0, [r1, #0x320]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa104: 9806         	ldr	r0, [sp, #0x18]
700aa106: f500 609f    	add.w	r0, r0, #0x4f8
700aa10a: f7ff fe49    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #-0x36e
;     return;
700aa10e: b008         	add	sp, #0x20
700aa110: bd80         	pop	{r7, pc}
		...
700aa11e: 0000         	movs	r0, r0

700aa120 <Udma_rmFreeTxCh>:
; {
700aa120: b580         	push	{r7, lr}
700aa122: b088         	sub	sp, #0x20
700aa124: 9007         	str	r0, [sp, #0x1c]
700aa126: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa128: 9806         	ldr	r0, [sp, #0x18]
700aa12a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa12e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa130: 9806         	ldr	r0, [sp, #0x18]
700aa132: f500 609f    	add.w	r0, r0, #0x4f8
700aa136: f04f 31ff    	mov.w	r1, #0xffffffff
700aa13a: f7fe fad9    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x1a4e
;     i = chNum - rmInitPrms->startTxCh;
700aa13e: 9807         	ldr	r0, [sp, #0x1c]
700aa140: 9901         	ldr	r1, [sp, #0x4]
700aa142: 6a89         	ldr	r1, [r1, #0x28]
700aa144: 1a40         	subs	r0, r0, r1
700aa146: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa148: 9805         	ldr	r0, [sp, #0x14]
700aa14a: 0940         	lsrs	r0, r0, #0x5
700aa14c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa14e: 9805         	ldr	r0, [sp, #0x14]
700aa150: 9904         	ldr	r1, [sp, #0x10]
700aa152: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa156: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa158: 9903         	ldr	r1, [sp, #0xc]
700aa15a: 2001         	movs	r0, #0x1
700aa15c: 4088         	lsls	r0, r1
700aa15e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txChFlag[offset] |= bitMask;
700aa160: 9a02         	ldr	r2, [sp, #0x8]
700aa162: 9806         	ldr	r0, [sp, #0x18]
700aa164: 9904         	ldr	r1, [sp, #0x10]
700aa166: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa16a: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700aa16e: 4310         	orrs	r0, r2
700aa170: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa174: 9806         	ldr	r0, [sp, #0x18]
700aa176: f500 609f    	add.w	r0, r0, #0x4f8
700aa17a: f7ff fe11    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #-0x3de
;     return;
700aa17e: b008         	add	sp, #0x20
700aa180: bd80         	pop	{r7, pc}
		...
700aa18e: 0000         	movs	r0, r0

700aa190 <Udma_rmFreeTxHcCh>:
; {
700aa190: b580         	push	{r7, lr}
700aa192: b088         	sub	sp, #0x20
700aa194: 9007         	str	r0, [sp, #0x1c]
700aa196: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa198: 9806         	ldr	r0, [sp, #0x18]
700aa19a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa19e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa1a0: 9806         	ldr	r0, [sp, #0x18]
700aa1a2: f500 609f    	add.w	r0, r0, #0x4f8
700aa1a6: f04f 31ff    	mov.w	r1, #0xffffffff
700aa1aa: f7fe faa1    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x1abe
;     i = chNum - rmInitPrms->startTxHcCh;
700aa1ae: 9807         	ldr	r0, [sp, #0x1c]
700aa1b0: 9901         	ldr	r1, [sp, #0x4]
700aa1b2: 6a09         	ldr	r1, [r1, #0x20]
700aa1b4: 1a40         	subs	r0, r0, r1
700aa1b6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa1b8: 9805         	ldr	r0, [sp, #0x14]
700aa1ba: 0940         	lsrs	r0, r0, #0x5
700aa1bc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa1be: 9805         	ldr	r0, [sp, #0x14]
700aa1c0: 9904         	ldr	r1, [sp, #0x10]
700aa1c2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa1c6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa1c8: 9903         	ldr	r1, [sp, #0xc]
700aa1ca: 2001         	movs	r0, #0x1
700aa1cc: 4088         	lsls	r0, r1
700aa1ce: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txHcChFlag[offset] |= bitMask;
700aa1d0: 9a02         	ldr	r2, [sp, #0x8]
700aa1d2: 9806         	ldr	r0, [sp, #0x18]
700aa1d4: 9904         	ldr	r1, [sp, #0x10]
700aa1d6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa1da: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700aa1de: 4310         	orrs	r0, r2
700aa1e0: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa1e4: 9806         	ldr	r0, [sp, #0x18]
700aa1e6: f500 609f    	add.w	r0, r0, #0x4f8
700aa1ea: f7ff fdd9    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #-0x44e
;     return;
700aa1ee: b008         	add	sp, #0x20
700aa1f0: bd80         	pop	{r7, pc}
		...
700aa1fe: 0000         	movs	r0, r0

700aa200 <Udma_rmFreeTxUhcCh>:
; {
700aa200: b580         	push	{r7, lr}
700aa202: b088         	sub	sp, #0x20
700aa204: 9007         	str	r0, [sp, #0x1c]
700aa206: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa208: 9806         	ldr	r0, [sp, #0x18]
700aa20a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa20e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa210: 9806         	ldr	r0, [sp, #0x18]
700aa212: f500 609f    	add.w	r0, r0, #0x4f8
700aa216: f04f 31ff    	mov.w	r1, #0xffffffff
700aa21a: f7fe fa69    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x1b2e
;     i = chNum - rmInitPrms->startTxUhcCh;
700aa21e: 9807         	ldr	r0, [sp, #0x1c]
700aa220: 9901         	ldr	r1, [sp, #0x4]
700aa222: 6989         	ldr	r1, [r1, #0x18]
700aa224: 1a40         	subs	r0, r0, r1
700aa226: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa228: 9805         	ldr	r0, [sp, #0x14]
700aa22a: 0940         	lsrs	r0, r0, #0x5
700aa22c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa22e: 9805         	ldr	r0, [sp, #0x14]
700aa230: 9904         	ldr	r1, [sp, #0x10]
700aa232: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa236: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa238: 9903         	ldr	r1, [sp, #0xc]
700aa23a: 2001         	movs	r0, #0x1
700aa23c: 4088         	lsls	r0, r1
700aa23e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txUhcChFlag[offset] |= bitMask;
700aa240: 9a02         	ldr	r2, [sp, #0x8]
700aa242: 9806         	ldr	r0, [sp, #0x18]
700aa244: 9904         	ldr	r1, [sp, #0x10]
700aa246: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa24a: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700aa24e: 4310         	orrs	r0, r2
700aa250: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa254: 9806         	ldr	r0, [sp, #0x18]
700aa256: f500 609f    	add.w	r0, r0, #0x4f8
700aa25a: f7ff fda1    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #-0x4be
;     return;
700aa25e: b008         	add	sp, #0x20
700aa260: bd80         	pop	{r7, pc}
		...
700aa26e: 0000         	movs	r0, r0

700aa270 <UART_getChar>:
; {
700aa270: b580         	push	{r7, lr}
700aa272: b086         	sub	sp, #0x18
700aa274: 9005         	str	r0, [sp, #0x14]
700aa276: 9104         	str	r1, [sp, #0x10]
700aa278: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700aa27a: 9003         	str	r0, [sp, #0xc]
;     uint32_t retVal      = FALSE;
700aa27c: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700aa27e: 9805         	ldr	r0, [sp, #0x14]
700aa280: 300c         	adds	r0, #0xc
700aa282: f003 fb1d    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x363a
700aa286: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700aa288: 9805         	ldr	r0, [sp, #0x14]
700aa28a: 300c         	adds	r0, #0xc
700aa28c: 9000         	str	r0, [sp]
700aa28e: f003 fb17    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x362e
700aa292: 4601         	mov	r1, r0
700aa294: 9800         	ldr	r0, [sp]
700aa296: f001 017f    	and	r1, r1, #0x7f
700aa29a: f003 fb19    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x3632
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700aa29e: 9805         	ldr	r0, [sp, #0x14]
700aa2a0: 3014         	adds	r0, #0x14
700aa2a2: f003 fb0d    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x361a
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700aa2a6: 07c0         	lsls	r0, r0, #0x1f
700aa2a8: b150         	cbz	r0, 0x700aa2c0 <UART_getChar+0x50> @ imm = #0x14
700aa2aa: e7ff         	b	0x700aa2ac <UART_getChar+0x3c> @ imm = #-0x2
;         uint32_t tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700aa2ac: 9805         	ldr	r0, [sp, #0x14]
700aa2ae: f003 fb07    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x360e
700aa2b2: 9001         	str	r0, [sp, #0x4]
;         *pChar = (uint8_t)tempRetVal;
700aa2b4: 9801         	ldr	r0, [sp, #0x4]
700aa2b6: 9904         	ldr	r1, [sp, #0x10]
700aa2b8: 7008         	strb	r0, [r1]
700aa2ba: 2001         	movs	r0, #0x1
;         retVal = TRUE;
700aa2bc: 9002         	str	r0, [sp, #0x8]
;     }
700aa2be: e7ff         	b	0x700aa2c0 <UART_getChar+0x50> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa2c0: 9805         	ldr	r0, [sp, #0x14]
700aa2c2: 300c         	adds	r0, #0xc
700aa2c4: 9903         	ldr	r1, [sp, #0xc]
700aa2c6: f003 fb03    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x3606
;     return retVal;
700aa2ca: 9802         	ldr	r0, [sp, #0x8]
700aa2cc: b006         	add	sp, #0x18
700aa2ce: bd80         	pop	{r7, pc}

700aa2d0 <UART_writeData>:
; {
700aa2d0: b580         	push	{r7, lr}
700aa2d2: b086         	sub	sp, #0x18
700aa2d4: 9005         	str	r0, [sp, #0x14]
700aa2d6: 9104         	str	r1, [sp, #0x10]
;     UARTLLD_InitHandle hUartInit = hUart->hUartInit;
700aa2d8: 9805         	ldr	r0, [sp, #0x14]
700aa2da: 6840         	ldr	r0, [r0, #0x4]
700aa2dc: 9001         	str	r0, [sp, #0x4]
;     numBytesToTransfer = writeSizeRemaining;
700aa2de: 9804         	ldr	r0, [sp, #0x10]
700aa2e0: 9003         	str	r0, [sp, #0xc]
;     if (numBytesToTransfer >= hUartInit->txTrigLvl)
700aa2e2: 9803         	ldr	r0, [sp, #0xc]
700aa2e4: 9901         	ldr	r1, [sp, #0x4]
700aa2e6: 6bc9         	ldr	r1, [r1, #0x3c]
700aa2e8: 4288         	cmp	r0, r1
700aa2ea: d304         	blo	0x700aa2f6 <UART_writeData+0x26> @ imm = #0x8
700aa2ec: e7ff         	b	0x700aa2ee <UART_writeData+0x1e> @ imm = #-0x2
;         numBytesToTransfer = hUartInit->txTrigLvl;
700aa2ee: 9801         	ldr	r0, [sp, #0x4]
700aa2f0: 6bc0         	ldr	r0, [r0, #0x3c]
700aa2f2: 9003         	str	r0, [sp, #0xc]
;     }
700aa2f4: e7ff         	b	0x700aa2f6 <UART_writeData+0x26> @ imm = #-0x2
;     numBytesToTransferred = numBytesToTransfer;
700aa2f6: 9803         	ldr	r0, [sp, #0xc]
700aa2f8: 9002         	str	r0, [sp, #0x8]
;     while (numBytesToTransfer != 0U)
700aa2fa: e7ff         	b	0x700aa2fc <UART_writeData+0x2c> @ imm = #-0x2
700aa2fc: 9803         	ldr	r0, [sp, #0xc]
700aa2fe: b190         	cbz	r0, 0x700aa326 <UART_writeData+0x56> @ imm = #0x24
700aa300: e7ff         	b	0x700aa302 <UART_writeData+0x32> @ imm = #-0x2
;         UART_putChar(hUart->baseAddr, *(const uint8_t *)hUart->writeBuf);
700aa302: 9905         	ldr	r1, [sp, #0x14]
700aa304: 6808         	ldr	r0, [r1]
700aa306: 6889         	ldr	r1, [r1, #0x8]
700aa308: 7809         	ldrb	r1, [r1]
700aa30a: f003 f8d9    	bl	0x700ad4c0 <UART_putChar> @ imm = #0x31b2
;         hUart->writeBuf = (const uint8_t *)hUart->writeBuf + 1U;
700aa30e: 9905         	ldr	r1, [sp, #0x14]
700aa310: 6888         	ldr	r0, [r1, #0x8]
700aa312: 3001         	adds	r0, #0x1
700aa314: 6088         	str	r0, [r1, #0x8]
;         numBytesToTransfer--;
700aa316: 9803         	ldr	r0, [sp, #0xc]
700aa318: 3801         	subs	r0, #0x1
700aa31a: 9003         	str	r0, [sp, #0xc]
;         hUart->writeCount++;
700aa31c: 9905         	ldr	r1, [sp, #0x14]
700aa31e: 68c8         	ldr	r0, [r1, #0xc]
700aa320: 3001         	adds	r0, #0x1
700aa322: 60c8         	str	r0, [r1, #0xc]
;     while (numBytesToTransfer != 0U)
700aa324: e7ea         	b	0x700aa2fc <UART_writeData+0x2c> @ imm = #-0x2c
;     return (writeSizeRemaining - numBytesToTransferred);
700aa326: 9804         	ldr	r0, [sp, #0x10]
700aa328: 9902         	ldr	r1, [sp, #0x8]
700aa32a: 1a40         	subs	r0, r0, r1
700aa32c: b006         	add	sp, #0x18
700aa32e: bd80         	pop	{r7, pc}

700aa330 <Udma_virtToPhyFxn>:
; {
700aa330: b580         	push	{r7, lr}
700aa332: b088         	sub	sp, #0x20
700aa334: 9007         	str	r0, [sp, #0x1c]
700aa336: 9106         	str	r1, [sp, #0x18]
700aa338: 9205         	str	r2, [sp, #0x14]
700aa33a: 2000         	movs	r0, #0x0
700aa33c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700aa340: 9004         	str	r0, [sp, #0x10]
700aa342: 2000         	movs	r0, #0x0
;     void               *appData = NULL_PTR;
700aa344: 9003         	str	r0, [sp, #0xc]
;     if(NULL_PTR != chHandle)
700aa346: 9805         	ldr	r0, [sp, #0x14]
700aa348: b138         	cbz	r0, 0x700aa35a <Udma_virtToPhyFxn+0x2a> @ imm = #0xe
700aa34a: e7ff         	b	0x700aa34c <Udma_virtToPhyFxn+0x1c> @ imm = #-0x2
;         chNum   = chHandle->chPrms.chNum;
700aa34c: 9805         	ldr	r0, [sp, #0x14]
700aa34e: 6840         	ldr	r0, [r0, #0x4]
700aa350: 9004         	str	r0, [sp, #0x10]
;         appData = chHandle->chPrms.appData;
700aa352: 9805         	ldr	r0, [sp, #0x14]
700aa354: 6900         	ldr	r0, [r0, #0x10]
700aa356: 9003         	str	r0, [sp, #0xc]
;     }
700aa358: e7ff         	b	0x700aa35a <Udma_virtToPhyFxn+0x2a> @ imm = #-0x2
;     if((Udma_VirtToPhyFxn) NULL_PTR != drvHandle->initPrms.virtToPhyFxn)
700aa35a: 9806         	ldr	r0, [sp, #0x18]
700aa35c: f8d0 01cc    	ldr.w	r0, [r0, #0x1cc]
700aa360: b150         	cbz	r0, 0x700aa378 <Udma_virtToPhyFxn+0x48> @ imm = #0x14
700aa362: e7ff         	b	0x700aa364 <Udma_virtToPhyFxn+0x34> @ imm = #-0x2
;         phyAddr = drvHandle->initPrms.virtToPhyFxn(virtAddr, chNum, appData);
700aa364: 9806         	ldr	r0, [sp, #0x18]
700aa366: f8d0 31cc    	ldr.w	r3, [r0, #0x1cc]
700aa36a: 9807         	ldr	r0, [sp, #0x1c]
700aa36c: 9904         	ldr	r1, [sp, #0x10]
700aa36e: 9a03         	ldr	r2, [sp, #0xc]
700aa370: 4798         	blx	r3
700aa372: 9101         	str	r1, [sp, #0x4]
700aa374: 9000         	str	r0, [sp]
;     }
700aa376: e007         	b	0x700aa388 <Udma_virtToPhyFxn+0x58> @ imm = #0xe
;         phyAddr = Udma_defaultVirtToPhyFxn(virtAddr, chNum, appData);
700aa378: 9807         	ldr	r0, [sp, #0x1c]
700aa37a: 9904         	ldr	r1, [sp, #0x10]
700aa37c: 9a03         	ldr	r2, [sp, #0xc]
700aa37e: f003 faaf    	bl	0x700ad8e0 <Udma_defaultVirtToPhyFxn> @ imm = #0x355e
700aa382: 9101         	str	r1, [sp, #0x4]
700aa384: 9000         	str	r0, [sp]
700aa386: e7ff         	b	0x700aa388 <Udma_virtToPhyFxn+0x58> @ imm = #-0x2
;     return (phyAddr);
700aa388: 9800         	ldr	r0, [sp]
700aa38a: 9901         	ldr	r1, [sp, #0x4]
700aa38c: b008         	add	sp, #0x20
700aa38e: bd80         	pop	{r7, pc}

700aa390 <tm_isr_message_handler>:
; {
700aa390: b5b0         	push	{r4, r5, r7, lr}
;    tm_isr_counter++;
700aa392: f240 40e4    	movw	r0, #0x4e4
;    message[1] = isr_message_counter;
700aa396: f240 45d4    	movw	r5, #0x4d4
;    tm_isr_counter++;
700aa39a: f2c7 000b    	movt	r0, #0x700b
;    message[1] = isr_message_counter;
700aa39e: f2c7 050b    	movt	r5, #0x700b
700aa3a2: f240 32ea    	movw	r2, #0x3ea
;    message[0] = 1;
700aa3a6: f644 74a4    	movw	r4, #0x4fa4
700aa3aa: f2c7 0408    	movt	r4, #0x7008
;    tm_isr_counter++;
700aa3ae: 6801         	ldr	r1, [r0]
700aa3b0: 3101         	adds	r1, #0x1
700aa3b2: 6001         	str	r1, [r0]
;    message[1] = isr_message_counter;
700aa3b4: 6828         	ldr	r0, [r5]
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700aa3b6: 6829         	ldr	r1, [r5]
700aa3b8: eb01 0181    	add.w	r1, r1, r1, lsl #2
700aa3bc: eb02 0141    	add.w	r1, r2, r1, lsl #1
700aa3c0: 2201         	movs	r2, #0x1
;       checksum += msg[i];
700aa3c2: 1843         	adds	r3, r0, r1
;    message[0] = 1;
700aa3c4: e9c4 2000    	strd	r2, r0, [r4]
;       checksum += msg[i];
700aa3c8: 3301         	adds	r3, #0x1
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700aa3ca: e9c4 1302    	strd	r1, r3, [r4, #8]
;    tm_pmu_profile_start(pmu_send_names[isr_message_counter]);
700aa3ce: f244 7178    	movw	r1, #0x4778
700aa3d2: 6828         	ldr	r0, [r5]
700aa3d4: f2c7 0108    	movt	r1, #0x7008
700aa3d8: eb01 1000    	add.w	r0, r1, r0, lsl #4
700aa3dc: f003 fb78    	bl	0x700adad0 <tm_pmu_profile_start> @ imm = #0x36f0
;    tm_queue_send_from_isr(0, message);
700aa3e0: 4621         	mov	r1, r4
700aa3e2: 2000         	movs	r0, #0x0
700aa3e4: f002 fa34    	bl	0x700ac850 <tm_queue_send_from_isr> @ imm = #0x2468
;    isr_message_counter++; /* Prepare for next iteration */
700aa3e8: 6828         	ldr	r0, [r5]
700aa3ea: 3001         	adds	r0, #0x1
700aa3ec: 6028         	str	r0, [r5]
; }
700aa3ee: bdb0         	pop	{r4, r5, r7, pc}

700aa3f0 <Sciclient_pmSetModuleRst>:
; {
700aa3f0: b580         	push	{r7, lr}
700aa3f2: b090         	sub	sp, #0x40
700aa3f4: 900f         	str	r0, [sp, #0x3c]
700aa3f6: 910e         	str	r1, [sp, #0x38]
700aa3f8: 920d         	str	r2, [sp, #0x34]
700aa3fa: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700aa3fc: 900c         	str	r0, [sp, #0x30]
;     request.id     = (uint32_t) moduleId;
700aa3fe: 990f         	ldr	r1, [sp, #0x3c]
700aa400: 910a         	str	r1, [sp, #0x28]
;     request.resets = (uint32_t) resetBit;
700aa402: 990e         	ldr	r1, [sp, #0x38]
700aa404: 910b         	str	r1, [sp, #0x2c]
700aa406: f240 2102    	movw	r1, #0x202
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE_RESETS;
700aa40a: f8ad 100c    	strh.w	r1, [sp, #0xc]
700aa40e: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700aa410: 9104         	str	r1, [sp, #0x10]
700aa412: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700aa414: 9105         	str	r1, [sp, #0x14]
700aa416: 2110         	movs	r1, #0x10
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700aa418: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700aa41a: 990d         	ldr	r1, [sp, #0x34]
700aa41c: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700aa41e: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700aa420: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700aa422: 9002         	str	r0, [sp, #0x8]
700aa424: a803         	add	r0, sp, #0xc
700aa426: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700aa428: f7f1 fd2a    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xe5ac
700aa42c: 900c         	str	r0, [sp, #0x30]
;     if((retVal != SystemP_SUCCESS) ||
700aa42e: 980c         	ldr	r0, [sp, #0x30]
700aa430: b930         	cbnz	r0, 0x700aa440 <Sciclient_pmSetModuleRst+0x50> @ imm = #0xc
700aa432: e7ff         	b	0x700aa434 <Sciclient_pmSetModuleRst+0x44> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700aa434: 9800         	ldr	r0, [sp]
700aa436: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700aa43a: 2802         	cmp	r0, #0x2
700aa43c: d004         	beq	0x700aa448 <Sciclient_pmSetModuleRst+0x58> @ imm = #0x8
700aa43e: e7ff         	b	0x700aa440 <Sciclient_pmSetModuleRst+0x50> @ imm = #-0x2
700aa440: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700aa444: 900c         	str	r0, [sp, #0x30]
;     }
700aa446: e7ff         	b	0x700aa448 <Sciclient_pmSetModuleRst+0x58> @ imm = #-0x2
;     return retVal;
700aa448: 980c         	ldr	r0, [sp, #0x30]
700aa44a: b010         	add	sp, #0x40
700aa44c: bd80         	pop	{r7, pc}
700aa44e: 0000         	movs	r0, r0

700aa450 <Sciclient_rmIaGetInst>:
; {
700aa450: b083         	sub	sp, #0xc
700aa452: f8ad 000a    	strh.w	r0, [sp, #0xa]
700aa456: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIaInst *inst = NULL;
700aa458: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700aa45a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700aa45e: e7ff         	b	0x700aa460 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x2
700aa460: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700aa464: 2800         	cmp	r0, #0x0
700aa466: dc1e         	bgt	0x700aa4a6 <Sciclient_rmIaGetInst+0x56> @ imm = #0x3c
700aa468: e7ff         	b	0x700aa46a <Sciclient_rmIaGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIaInstances[i].dev_id) {
700aa46a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700aa46e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700aa472: 014a         	lsls	r2, r1, #0x5
700aa474: f240 31a4    	movw	r1, #0x3a4
700aa478: f2c7 010b    	movt	r1, #0x700b
700aa47c: 5a89         	ldrh	r1, [r1, r2]
700aa47e: 4288         	cmp	r0, r1
700aa480: d10a         	bne	0x700aa498 <Sciclient_rmIaGetInst+0x48> @ imm = #0x14
700aa482: e7ff         	b	0x700aa484 <Sciclient_rmIaGetInst+0x34> @ imm = #-0x2
;             inst = &gRmIaInstances[i];
700aa484: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700aa488: f240 30a4    	movw	r0, #0x3a4
700aa48c: f2c7 000b    	movt	r0, #0x700b
700aa490: eb00 1041    	add.w	r0, r0, r1, lsl #5
700aa494: 9001         	str	r0, [sp, #0x4]
;             break;
700aa496: e006         	b	0x700aa4a6 <Sciclient_rmIaGetInst+0x56> @ imm = #0xc
;     }
700aa498: e7ff         	b	0x700aa49a <Sciclient_rmIaGetInst+0x4a> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700aa49a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700aa49e: 3001         	adds	r0, #0x1
700aa4a0: f8ad 0002    	strh.w	r0, [sp, #0x2]
700aa4a4: e7dc         	b	0x700aa460 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x48
;     return inst;
700aa4a6: 9801         	ldr	r0, [sp, #0x4]
700aa4a8: b003         	add	sp, #0xc
700aa4aa: 4770         	bx	lr
700aa4ac: 0000         	movs	r0, r0
700aa4ae: 0000         	movs	r0, r0

700aa4b0 <Sciclient_rmPsPush>:
; {
700aa4b0: b083         	sub	sp, #0xc
700aa4b2: 9002         	str	r0, [sp, #0x8]
700aa4b4: f8ad 1006    	strh.w	r1, [sp, #0x6]
700aa4b8: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700aa4ba: 9000         	str	r0, [sp]
;     if ((gPstack.psp < SCICLIENT_PS_MAX_DEPTH) && (n != NULL)) {
700aa4bc: f241 0058    	movw	r0, #0x1058
700aa4c0: f2c7 0008    	movt	r0, #0x7008
700aa4c4: 8c80         	ldrh	r0, [r0, #0x24]
700aa4c6: 2802         	cmp	r0, #0x2
700aa4c8: dc19         	bgt	0x700aa4fe <Sciclient_rmPsPush+0x4e> @ imm = #0x32
700aa4ca: e7ff         	b	0x700aa4cc <Sciclient_rmPsPush+0x1c> @ imm = #-0x2
700aa4cc: 9802         	ldr	r0, [sp, #0x8]
700aa4ce: b1b0         	cbz	r0, 0x700aa4fe <Sciclient_rmPsPush+0x4e> @ imm = #0x2c
700aa4d0: e7ff         	b	0x700aa4d2 <Sciclient_rmPsPush+0x22> @ imm = #-0x2
;         gPstack.ps[gPstack.psp].p_n = n;
700aa4d2: 9802         	ldr	r0, [sp, #0x8]
700aa4d4: f241 0158    	movw	r1, #0x1058
700aa4d8: f2c7 0108    	movt	r1, #0x7008
700aa4dc: 8c8a         	ldrh	r2, [r1, #0x24]
700aa4de: eb02 0242    	add.w	r2, r2, r2, lsl #1
700aa4e2: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = if_idx;
700aa4e6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700aa4ea: 8c8a         	ldrh	r2, [r1, #0x24]
700aa4ec: eb02 0242    	add.w	r2, r2, r2, lsl #1
700aa4f0: eb01 0282    	add.w	r2, r1, r2, lsl #2
700aa4f4: 8090         	strh	r0, [r2, #0x4]
;         gPstack.psp++;
700aa4f6: 8c88         	ldrh	r0, [r1, #0x24]
700aa4f8: 3001         	adds	r0, #0x1
700aa4fa: 8488         	strh	r0, [r1, #0x24]
;     } else {
700aa4fc: e003         	b	0x700aa506 <Sciclient_rmPsPush+0x56> @ imm = #0x6
700aa4fe: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa502: 9000         	str	r0, [sp]
700aa504: e7ff         	b	0x700aa506 <Sciclient_rmPsPush+0x56> @ imm = #-0x2
;     return r;
700aa506: 9800         	ldr	r0, [sp]
700aa508: b003         	add	sp, #0xc
700aa50a: 4770         	bx	lr
700aa50c: 0000         	movs	r0, r0
700aa50e: 0000         	movs	r0, r0

700aa510 <UART_lld_deInit>:
; {
700aa510: b580         	push	{r7, lr}
700aa512: b084         	sub	sp, #0x10
700aa514: 9003         	str	r0, [sp, #0xc]
700aa516: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700aa518: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700aa51a: 9803         	ldr	r0, [sp, #0xc]
700aa51c: b1f8         	cbz	r0, 0x700aa55e <UART_lld_deInit+0x4e> @ imm = #0x3e
700aa51e: e7ff         	b	0x700aa520 <UART_lld_deInit+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700aa520: 9903         	ldr	r1, [sp, #0xc]
700aa522: 2002         	movs	r0, #0x2
700aa524: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700aa526: 9803         	ldr	r0, [sp, #0xc]
700aa528: f7fd ff32    	bl	0x700a8390 <UART_lld_flushTxFifo> @ imm = #-0x219c
700aa52c: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700aa52e: 9802         	ldr	r0, [sp, #0x8]
700aa530: b988         	cbnz	r0, 0x700aa556 <UART_lld_deInit+0x46> @ imm = #0x22
700aa532: e7ff         	b	0x700aa534 <UART_lld_deInit+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700aa534: 9803         	ldr	r0, [sp, #0xc]
700aa536: 6800         	ldr	r0, [r0]
700aa538: 2107         	movs	r1, #0x7
700aa53a: 9101         	str	r1, [sp, #0x4]
700aa53c: f7f9 ffe8    	bl	0x700a4510 <UART_intrDisable> @ imm = #-0x6030
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700aa540: 9803         	ldr	r0, [sp, #0xc]
700aa542: 6800         	ldr	r0, [r0]
700aa544: 2102         	movs	r1, #0x2
700aa546: f002 fb1b    	bl	0x700acb80 <UART_intr2Disable> @ imm = #0x2636
700aa54a: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700aa54c: 9803         	ldr	r0, [sp, #0xc]
700aa54e: 6800         	ldr	r0, [r0]
700aa550: f002 fb5e    	bl	0x700acc10 <UART_operatingModeSelect> @ imm = #0x26bc
;         }
700aa554: e7ff         	b	0x700aa556 <UART_lld_deInit+0x46> @ imm = #-0x2
;         hUart->state = UART_STATE_RESET;
700aa556: 9903         	ldr	r1, [sp, #0xc]
700aa558: 2000         	movs	r0, #0x0
700aa55a: 6548         	str	r0, [r1, #0x54]
;     }
700aa55c: e003         	b	0x700aa566 <UART_lld_deInit+0x56> @ imm = #0x6
700aa55e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700aa562: 9002         	str	r0, [sp, #0x8]
700aa564: e7ff         	b	0x700aa566 <UART_lld_deInit+0x56> @ imm = #-0x2
;     return status;
700aa566: 9802         	ldr	r0, [sp, #0x8]
700aa568: b004         	add	sp, #0x10
700aa56a: bd80         	pop	{r7, pc}
700aa56c: 0000         	movs	r0, r0
700aa56e: 0000         	movs	r0, r0

700aa570 <UART_lld_writeCompleteCallback>:
; {
700aa570: b580         	push	{r7, lr}
700aa572: b086         	sub	sp, #0x18
700aa574: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700aa576: 9805         	ldr	r0, [sp, #0x14]
700aa578: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700aa57a: 9802         	ldr	r0, [sp, #0x8]
700aa57c: b320         	cbz	r0, 0x700aa5c8 <UART_lld_writeCompleteCallback+0x58> @ imm = #0x48
700aa57e: e7ff         	b	0x700aa580 <UART_lld_writeCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700aa580: 9802         	ldr	r0, [sp, #0x8]
700aa582: 6e00         	ldr	r0, [r0, #0x60]
700aa584: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700aa586: 9801         	ldr	r0, [sp, #0x4]
700aa588: b1e8         	cbz	r0, 0x700aa5c6 <UART_lld_writeCompleteCallback+0x56> @ imm = #0x3a
700aa58a: e7ff         	b	0x700aa58c <UART_lld_writeCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700aa58c: 9801         	ldr	r0, [sp, #0x4]
700aa58e: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700aa590: 9804         	ldr	r0, [sp, #0x10]
700aa592: 6840         	ldr	r0, [r0, #0x4]
700aa594: 9003         	str	r0, [sp, #0xc]
;             obj->writeTrans->count = hUart->writeTrans.count;
700aa596: 9802         	ldr	r0, [sp, #0x8]
700aa598: 6c00         	ldr	r0, [r0, #0x40]
700aa59a: 9903         	ldr	r1, [sp, #0xc]
700aa59c: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700aa5a0: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.writeMode == UART_TRANSFER_MODE_CALLBACK)
700aa5a2: 9803         	ldr	r0, [sp, #0xc]
700aa5a4: 69c0         	ldr	r0, [r0, #0x1c]
700aa5a6: 2801         	cmp	r0, #0x1
700aa5a8: d107         	bne	0x700aa5ba <UART_lld_writeCompleteCallback+0x4a> @ imm = #0xe
700aa5aa: e7ff         	b	0x700aa5ac <UART_lld_writeCompleteCallback+0x3c> @ imm = #-0x2
;                 obj->prms.writeCallbackFxn(hUart, &hUart->writeTrans);
700aa5ac: 9803         	ldr	r0, [sp, #0xc]
700aa5ae: 6a42         	ldr	r2, [r0, #0x24]
700aa5b0: 9802         	ldr	r0, [sp, #0x8]
700aa5b2: f100 013c    	add.w	r1, r0, #0x3c
700aa5b6: 4790         	blx	r2
;             }
700aa5b8: e004         	b	0x700aa5c4 <UART_lld_writeCompleteCallback+0x54> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->writeTransferMutex);
700aa5ba: 9802         	ldr	r0, [sp, #0x8]
700aa5bc: 6dc0         	ldr	r0, [r0, #0x5c]
700aa5be: f7ff fbef    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #-0x822
700aa5c2: e7ff         	b	0x700aa5c4 <UART_lld_writeCompleteCallback+0x54> @ imm = #-0x2
;         }
700aa5c4: e7ff         	b	0x700aa5c6 <UART_lld_writeCompleteCallback+0x56> @ imm = #-0x2
;     }
700aa5c6: e7ff         	b	0x700aa5c8 <UART_lld_writeCompleteCallback+0x58> @ imm = #-0x2
; }
700aa5c8: b006         	add	sp, #0x18
700aa5ca: bd80         	pop	{r7, pc}
700aa5cc: 0000         	movs	r0, r0
700aa5ce: 0000         	movs	r0, r0

700aa5d0 <Sciclient_rmIaValidateGlobalEvt>:
; {
700aa5d0: b580         	push	{r7, lr}
700aa5d2: b086         	sub	sp, #0x18
700aa5d4: f8ad 0016    	strh.w	r0, [sp, #0x16]
700aa5d8: f8ad 1014    	strh.w	r1, [sp, #0x14]
700aa5dc: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700aa5de: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700aa5e0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700aa5e2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700aa5e6: f7ff ff33    	bl	0x700aa450 <Sciclient_rmIaGetInst> @ imm = #-0x19a
700aa5ea: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700aa5ec: 9803         	ldr	r0, [sp, #0xc]
700aa5ee: b920         	cbnz	r0, 0x700aa5fa <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #0x8
700aa5f0: e7ff         	b	0x700aa5f2 <Sciclient_rmIaValidateGlobalEvt+0x22> @ imm = #-0x2
700aa5f2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700aa5f6: 9004         	str	r0, [sp, #0x10]
;     }
700aa5f8: e7ff         	b	0x700aa5fa <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700aa5fa: 9804         	ldr	r0, [sp, #0x10]
700aa5fc: b990         	cbnz	r0, 0x700aa624 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #0x24
700aa5fe: e7ff         	b	0x700aa600 <Sciclient_rmIaValidateGlobalEvt+0x30> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700aa600: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700aa604: 9903         	ldr	r1, [sp, #0xc]
700aa606: 8909         	ldrh	r1, [r1, #0x8]
700aa608: 1a40         	subs	r0, r0, r1
700aa60a: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         r = Sciclient_rmIaValidateEvt(inst, evt, 0u, 0u, false);
700aa60e: 9803         	ldr	r0, [sp, #0xc]
700aa610: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700aa614: 466a         	mov	r2, sp
700aa616: 2300         	movs	r3, #0x0
700aa618: 6013         	str	r3, [r2]
700aa61a: 461a         	mov	r2, r3
700aa61c: f7f8 f928    	bl	0x700a2870 <Sciclient_rmIaValidateEvt> @ imm = #-0x7db0
700aa620: 9004         	str	r0, [sp, #0x10]
;     }
700aa622: e7ff         	b	0x700aa624 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #-0x2
;     return r;
700aa624: 9804         	ldr	r0, [sp, #0x10]
700aa626: b006         	add	sp, #0x18
700aa628: bd80         	pop	{r7, pc}
700aa62a: 0000         	movs	r0, r0
700aa62c: 0000         	movs	r0, r0
700aa62e: 0000         	movs	r0, r0

700aa630 <UART_lld_readCompleteCallback>:
; {
700aa630: b580         	push	{r7, lr}
700aa632: b086         	sub	sp, #0x18
700aa634: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700aa636: 9805         	ldr	r0, [sp, #0x14]
700aa638: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700aa63a: 9802         	ldr	r0, [sp, #0x8]
700aa63c: b318         	cbz	r0, 0x700aa686 <UART_lld_readCompleteCallback+0x56> @ imm = #0x46
700aa63e: e7ff         	b	0x700aa640 <UART_lld_readCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700aa640: 9802         	ldr	r0, [sp, #0x8]
700aa642: 6e00         	ldr	r0, [r0, #0x60]
700aa644: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700aa646: 9801         	ldr	r0, [sp, #0x4]
700aa648: b1e0         	cbz	r0, 0x700aa684 <UART_lld_readCompleteCallback+0x54> @ imm = #0x38
700aa64a: e7ff         	b	0x700aa64c <UART_lld_readCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700aa64c: 9801         	ldr	r0, [sp, #0x4]
700aa64e: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700aa650: 9804         	ldr	r0, [sp, #0x10]
700aa652: 6840         	ldr	r0, [r0, #0x4]
700aa654: 9003         	str	r0, [sp, #0xc]
;             obj->readTrans->count = hUart->readTrans.count;
700aa656: 9802         	ldr	r0, [sp, #0x8]
700aa658: 6ac0         	ldr	r0, [r0, #0x2c]
700aa65a: 9903         	ldr	r1, [sp, #0xc]
700aa65c: 6fc9         	ldr	r1, [r1, #0x7c]
700aa65e: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.readMode == UART_TRANSFER_MODE_CALLBACK)
700aa660: 9803         	ldr	r0, [sp, #0xc]
700aa662: 6940         	ldr	r0, [r0, #0x14]
700aa664: 2801         	cmp	r0, #0x1
700aa666: d107         	bne	0x700aa678 <UART_lld_readCompleteCallback+0x48> @ imm = #0xe
700aa668: e7ff         	b	0x700aa66a <UART_lld_readCompleteCallback+0x3a> @ imm = #-0x2
;                 obj->prms.readCallbackFxn(hUart, &hUart->readTrans);
700aa66a: 9803         	ldr	r0, [sp, #0xc]
700aa66c: 6a02         	ldr	r2, [r0, #0x20]
700aa66e: 9802         	ldr	r0, [sp, #0x8]
700aa670: f100 0128    	add.w	r1, r0, #0x28
700aa674: 4790         	blx	r2
;             }
700aa676: e004         	b	0x700aa682 <UART_lld_readCompleteCallback+0x52> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->readTransferMutex);
700aa678: 9802         	ldr	r0, [sp, #0x8]
700aa67a: 6d80         	ldr	r0, [r0, #0x58]
700aa67c: f7ff fb90    	bl	0x700a9da0 <SemaphoreP_post> @ imm = #-0x8e0
700aa680: e7ff         	b	0x700aa682 <UART_lld_readCompleteCallback+0x52> @ imm = #-0x2
;         }
700aa682: e7ff         	b	0x700aa684 <UART_lld_readCompleteCallback+0x54> @ imm = #-0x2
;     }
700aa684: e7ff         	b	0x700aa686 <UART_lld_readCompleteCallback+0x56> @ imm = #-0x2
; }
700aa686: b006         	add	sp, #0x18
700aa688: bd80         	pop	{r7, pc}
700aa68a: 0000         	movs	r0, r0
700aa68c: 0000         	movs	r0, r0
700aa68e: 0000         	movs	r0, r0

700aa690 <UART_regConfigModeEnable>:
; {
700aa690: b580         	push	{r7, lr}
700aa692: b086         	sub	sp, #0x18
700aa694: 9005         	str	r0, [sp, #0x14]
700aa696: 9104         	str	r1, [sp, #0x10]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700aa698: 9805         	ldr	r0, [sp, #0x14]
700aa69a: 300c         	adds	r0, #0xc
700aa69c: f003 f910    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x3220
700aa6a0: 9003         	str	r0, [sp, #0xc]
;     switch (modeFlag)
700aa6a2: 9804         	ldr	r0, [sp, #0x10]
700aa6a4: 9002         	str	r0, [sp, #0x8]
700aa6a6: 287f         	cmp	r0, #0x7f
700aa6a8: d00f         	beq	0x700aa6ca <UART_regConfigModeEnable+0x3a> @ imm = #0x1e
700aa6aa: e7ff         	b	0x700aa6ac <UART_regConfigModeEnable+0x1c> @ imm = #-0x2
700aa6ac: 9802         	ldr	r0, [sp, #0x8]
700aa6ae: 2880         	cmp	r0, #0x80
700aa6b0: d004         	beq	0x700aa6bc <UART_regConfigModeEnable+0x2c> @ imm = #0x8
700aa6b2: e7ff         	b	0x700aa6b4 <UART_regConfigModeEnable+0x24> @ imm = #-0x2
700aa6b4: 9802         	ldr	r0, [sp, #0x8]
700aa6b6: 28bf         	cmp	r0, #0xbf
700aa6b8: d113         	bne	0x700aa6e2 <UART_regConfigModeEnable+0x52> @ imm = #0x26
700aa6ba: e7ff         	b	0x700aa6bc <UART_regConfigModeEnable+0x2c> @ imm = #-0x2
;             HW_WR_REG32(baseAddr + UART_LCR, modeFlag & 0xFFU);
700aa6bc: 9805         	ldr	r0, [sp, #0x14]
700aa6be: 300c         	adds	r0, #0xc
700aa6c0: f89d 1010    	ldrb.w	r1, [sp, #0x10]
700aa6c4: f003 f904    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x3208
;             break;
700aa6c8: e00c         	b	0x700aa6e4 <UART_regConfigModeEnable+0x54> @ imm = #0x18
;             HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700aa6ca: 9805         	ldr	r0, [sp, #0x14]
700aa6cc: 300c         	adds	r0, #0xc
700aa6ce: 9001         	str	r0, [sp, #0x4]
700aa6d0: f003 f8f6    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x31ec
700aa6d4: 4601         	mov	r1, r0
700aa6d6: 9801         	ldr	r0, [sp, #0x4]
700aa6d8: f001 017f    	and	r1, r1, #0x7f
700aa6dc: f003 f8f8    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x31f0
;             break;
700aa6e0: e000         	b	0x700aa6e4 <UART_regConfigModeEnable+0x54> @ imm = #0x0
;             break;
700aa6e2: e7ff         	b	0x700aa6e4 <UART_regConfigModeEnable+0x54> @ imm = #-0x2
;     return lcrRegValue;
700aa6e4: 9803         	ldr	r0, [sp, #0xc]
700aa6e6: b006         	add	sp, #0x18
700aa6e8: bd80         	pop	{r7, pc}
700aa6ea: 0000         	movs	r0, r0
700aa6ec: 0000         	movs	r0, r0
700aa6ee: 0000         	movs	r0, r0

700aa6f0 <prvCheckTasksWaitingTermination>:
; static void prvCheckTasksWaitingTermination(void) {
700aa6f0: b580         	push	{r7, lr}
700aa6f2: b082         	sub	sp, #0x8
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700aa6f4: e7ff         	b	0x700aa6f6 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x2
700aa6f6: f240 40fc    	movw	r0, #0x4fc
700aa6fa: f2c7 000b    	movt	r0, #0x700b
700aa6fe: 6800         	ldr	r0, [r0]
700aa700: b308         	cbz	r0, 0x700aa746 <prvCheckTasksWaitingTermination+0x56> @ imm = #0x42
700aa702: e7ff         	b	0x700aa704 <prvCheckTasksWaitingTermination+0x14> @ imm = #-0x2
;       taskENTER_CRITICAL();
700aa704: f001 ff44    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x1e88
;         pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700aa708: f644 7090    	movw	r0, #0x4f90
700aa70c: f2c7 0008    	movt	r0, #0x7008
700aa710: 68c0         	ldr	r0, [r0, #0xc]
700aa712: 68c0         	ldr	r0, [r0, #0xc]
700aa714: 9001         	str	r0, [sp, #0x4]
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700aa716: 9801         	ldr	r0, [sp, #0x4]
700aa718: 3004         	adds	r0, #0x4
700aa71a: f000 ff09    	bl	0x700ab530 <uxListRemove> @ imm = #0xe12
;         --uxCurrentNumberOfTasks;
700aa71e: f240 41f8    	movw	r1, #0x4f8
700aa722: f2c7 010b    	movt	r1, #0x700b
700aa726: 6808         	ldr	r0, [r1]
700aa728: 3801         	subs	r0, #0x1
700aa72a: 6008         	str	r0, [r1]
;         --uxDeletedTasksWaitingCleanUp;
700aa72c: f240 41fc    	movw	r1, #0x4fc
700aa730: f2c7 010b    	movt	r1, #0x700b
700aa734: 6808         	ldr	r0, [r1]
700aa736: 3801         	subs	r0, #0x1
700aa738: 6008         	str	r0, [r1]
;       taskEXIT_CRITICAL();
700aa73a: f000 ffe9    	bl	0x700ab710 <vTaskExitCritical> @ imm = #0xfd2
;       prvDeleteTCB(pxTCB);
700aa73e: 9801         	ldr	r0, [sp, #0x4]
700aa740: f001 fc2e    	bl	0x700abfa0 <prvDeleteTCB> @ imm = #0x185c
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700aa744: e7d7         	b	0x700aa6f6 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x52
; }
700aa746: b002         	add	sp, #0x8
700aa748: bd80         	pop	{r7, pc}
700aa74a: 0000         	movs	r0, r0
700aa74c: 0000         	movs	r0, r0
700aa74e: 0000         	movs	r0, r0

700aa750 <Sciclient_rmIrqSetRaw>:
; {
700aa750: b580         	push	{r7, lr}
700aa752: b08c         	sub	sp, #0x30
700aa754: 900b         	str	r0, [sp, #0x2c]
700aa756: 910a         	str	r1, [sp, #0x28]
700aa758: 9209         	str	r2, [sp, #0x24]
700aa75a: f44f 5080    	mov.w	r0, #0x1000
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_SET;
700aa75e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa762: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa764: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa766: 980b         	ldr	r0, [sp, #0x2c]
700aa768: 9005         	str	r0, [sp, #0x14]
700aa76a: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa76c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa76e: 9809         	ldr	r0, [sp, #0x24]
700aa770: 9007         	str	r0, [sp, #0x1c]
700aa772: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa774: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa776: 980a         	ldr	r0, [sp, #0x28]
700aa778: 9001         	str	r0, [sp, #0x4]
700aa77a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa77c: 9002         	str	r0, [sp, #0x8]
700aa77e: a803         	add	r0, sp, #0xc
700aa780: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa782: f7f1 fb7d    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xe906
700aa786: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa788: 9808         	ldr	r0, [sp, #0x20]
700aa78a: b930         	cbnz	r0, 0x700aa79a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #0xc
700aa78c: e7ff         	b	0x700aa78e <Sciclient_rmIrqSetRaw+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa78e: 9800         	ldr	r0, [sp]
700aa790: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa794: 2802         	cmp	r0, #0x2
700aa796: d004         	beq	0x700aa7a2 <Sciclient_rmIrqSetRaw+0x52> @ imm = #0x8
700aa798: e7ff         	b	0x700aa79a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #-0x2
700aa79a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa79e: 9008         	str	r0, [sp, #0x20]
;     }
700aa7a0: e7ff         	b	0x700aa7a2 <Sciclient_rmIrqSetRaw+0x52> @ imm = #-0x2
;     return r;
700aa7a2: 9808         	ldr	r0, [sp, #0x20]
700aa7a4: b00c         	add	sp, #0x30
700aa7a6: bd80         	pop	{r7, pc}
		...

700aa7b0 <Sciclient_rmIrqUnmappedVintRouteDelete>:
; {
700aa7b0: b580         	push	{r7, lr}
700aa7b2: b084         	sub	sp, #0x10
700aa7b4: 9003         	str	r0, [sp, #0xc]
700aa7b6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700aa7b8: 9002         	str	r0, [sp, #0x8]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700aa7ba: 9903         	ldr	r1, [sp, #0xc]
700aa7bc: 8a08         	ldrh	r0, [r1, #0x10]
700aa7be: 8a49         	ldrh	r1, [r1, #0x12]
700aa7c0: f10d 0207    	add.w	r2, sp, #0x7
700aa7c4: f7fe fe8c    	bl	0x700a94e0 <Sciclient_rmIaVintGetInfo> @ imm = #-0x12e8
700aa7c8: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700aa7ca: 9802         	ldr	r0, [sp, #0x8]
700aa7cc: b940         	cbnz	r0, 0x700aa7e0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x10
700aa7ce: e7ff         	b	0x700aa7d0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x20> @ imm = #-0x2
700aa7d0: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700aa7d4: b120         	cbz	r0, 0x700aa7e0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x8
700aa7d6: e7ff         	b	0x700aa7d8 <Sciclient_rmIrqUnmappedVintRouteDelete+0x28> @ imm = #-0x2
700aa7d8: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700aa7dc: 9002         	str	r0, [sp, #0x8]
;     }
700aa7de: e7ff         	b	0x700aa7e0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700aa7e0: 9802         	ldr	r0, [sp, #0x8]
700aa7e2: b970         	cbnz	r0, 0x700aa802 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #0x1c
700aa7e4: e7ff         	b	0x700aa7e6 <Sciclient_rmIrqUnmappedVintRouteDelete+0x36> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700aa7e6: 9803         	ldr	r0, [sp, #0xc]
700aa7e8: f7f1 f842    	bl	0x7009b870 <Sciclient_rmIrqGetRoute> @ imm = #-0xef7c
700aa7ec: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700aa7ee: 9802         	ldr	r0, [sp, #0x8]
700aa7f0: b930         	cbnz	r0, 0x700aa800 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #0xc
700aa7f2: e7ff         	b	0x700aa7f4 <Sciclient_rmIrqUnmappedVintRouteDelete+0x44> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, false);
700aa7f4: 9803         	ldr	r0, [sp, #0xc]
700aa7f6: 2100         	movs	r1, #0x0
700aa7f8: f7f4 fbba    	bl	0x7009ef70 <Sciclient_rmIrqDeleteRoute> @ imm = #-0xb88c
700aa7fc: 9002         	str	r0, [sp, #0x8]
;         }
700aa7fe: e7ff         	b	0x700aa800 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #-0x2
;     }
700aa800: e7ff         	b	0x700aa802 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #-0x2
;     return r;
700aa802: 9802         	ldr	r0, [sp, #0x8]
700aa804: b004         	add	sp, #0x10
700aa806: bd80         	pop	{r7, pc}
		...

700aa810 <Sciclient_rmRingCfg>:
; {
700aa810: b580         	push	{r7, lr}
700aa812: b08c         	sub	sp, #0x30
700aa814: 900b         	str	r0, [sp, #0x2c]
700aa816: 910a         	str	r1, [sp, #0x28]
700aa818: 9209         	str	r2, [sp, #0x24]
700aa81a: f241 1010    	movw	r0, #0x1110
;     sciReq.messageType    = TISCI_MSG_RM_RING_CFG;
700aa81e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa822: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa824: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa826: 980b         	ldr	r0, [sp, #0x2c]
700aa828: 9005         	str	r0, [sp, #0x14]
700aa82a: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa82c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa82e: 9809         	ldr	r0, [sp, #0x24]
700aa830: 9007         	str	r0, [sp, #0x1c]
700aa832: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa834: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa836: 980a         	ldr	r0, [sp, #0x28]
700aa838: 9001         	str	r0, [sp, #0x4]
700aa83a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa83c: 9002         	str	r0, [sp, #0x8]
700aa83e: a803         	add	r0, sp, #0xc
700aa840: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa842: f7f1 fb1d    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xe9c6
700aa846: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa848: 9808         	ldr	r0, [sp, #0x20]
700aa84a: b930         	cbnz	r0, 0x700aa85a <Sciclient_rmRingCfg+0x4a> @ imm = #0xc
700aa84c: e7ff         	b	0x700aa84e <Sciclient_rmRingCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa84e: 9800         	ldr	r0, [sp]
700aa850: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa854: 2802         	cmp	r0, #0x2
700aa856: d004         	beq	0x700aa862 <Sciclient_rmRingCfg+0x52> @ imm = #0x8
700aa858: e7ff         	b	0x700aa85a <Sciclient_rmRingCfg+0x4a> @ imm = #-0x2
700aa85a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa85e: 9008         	str	r0, [sp, #0x20]
;     }
700aa860: e7ff         	b	0x700aa862 <Sciclient_rmRingCfg+0x52> @ imm = #-0x2
;     return r;
700aa862: 9808         	ldr	r0, [sp, #0x20]
700aa864: b00c         	add	sp, #0x30
700aa866: bd80         	pop	{r7, pc}
		...

700aa870 <Sciclient_rmUdmapFlowCfg>:
; {
700aa870: b580         	push	{r7, lr}
700aa872: b08c         	sub	sp, #0x30
700aa874: 900b         	str	r0, [sp, #0x2c]
700aa876: 910a         	str	r1, [sp, #0x28]
700aa878: 9209         	str	r2, [sp, #0x24]
700aa87a: f241 2030    	movw	r0, #0x1230
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_CFG;
700aa87e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa882: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa884: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa886: 980b         	ldr	r0, [sp, #0x2c]
700aa888: 9005         	str	r0, [sp, #0x14]
700aa88a: 2029         	movs	r0, #0x29
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa88c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa88e: 9809         	ldr	r0, [sp, #0x24]
700aa890: 9007         	str	r0, [sp, #0x1c]
700aa892: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa894: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa896: 980a         	ldr	r0, [sp, #0x28]
700aa898: 9001         	str	r0, [sp, #0x4]
700aa89a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa89c: 9002         	str	r0, [sp, #0x8]
700aa89e: a803         	add	r0, sp, #0xc
700aa8a0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa8a2: f7f1 faed    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xea26
700aa8a6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa8a8: 9808         	ldr	r0, [sp, #0x20]
700aa8aa: b930         	cbnz	r0, 0x700aa8ba <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #0xc
700aa8ac: e7ff         	b	0x700aa8ae <Sciclient_rmUdmapFlowCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa8ae: 9800         	ldr	r0, [sp]
700aa8b0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa8b4: 2802         	cmp	r0, #0x2
700aa8b6: d004         	beq	0x700aa8c2 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #0x8
700aa8b8: e7ff         	b	0x700aa8ba <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #-0x2
700aa8ba: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa8be: 9008         	str	r0, [sp, #0x20]
;     }
700aa8c0: e7ff         	b	0x700aa8c2 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #-0x2
;     return r;
700aa8c2: 9808         	ldr	r0, [sp, #0x20]
700aa8c4: b00c         	add	sp, #0x30
700aa8c6: bd80         	pop	{r7, pc}
		...

700aa8d0 <Sciclient_rmUdmapFlowSizeThreshCfg>:
; {
700aa8d0: b580         	push	{r7, lr}
700aa8d2: b08c         	sub	sp, #0x30
700aa8d4: 900b         	str	r0, [sp, #0x2c]
700aa8d6: 910a         	str	r1, [sp, #0x28]
700aa8d8: 9209         	str	r2, [sp, #0x24]
700aa8da: f241 2031    	movw	r0, #0x1231
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_SIZE_THRESH_CFG;
700aa8de: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa8e2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa8e4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa8e6: 980b         	ldr	r0, [sp, #0x2c]
700aa8e8: 9005         	str	r0, [sp, #0x14]
700aa8ea: 201d         	movs	r0, #0x1d
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa8ec: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa8ee: 9809         	ldr	r0, [sp, #0x24]
700aa8f0: 9007         	str	r0, [sp, #0x1c]
700aa8f2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa8f4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa8f6: 980a         	ldr	r0, [sp, #0x28]
700aa8f8: 9001         	str	r0, [sp, #0x4]
700aa8fa: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa8fc: 9002         	str	r0, [sp, #0x8]
700aa8fe: a803         	add	r0, sp, #0xc
700aa900: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa902: f7f1 fabd    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xea86
700aa906: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa908: 9808         	ldr	r0, [sp, #0x20]
700aa90a: b930         	cbnz	r0, 0x700aa91a <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #0xc
700aa90c: e7ff         	b	0x700aa90e <Sciclient_rmUdmapFlowSizeThreshCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa90e: 9800         	ldr	r0, [sp]
700aa910: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa914: 2802         	cmp	r0, #0x2
700aa916: d004         	beq	0x700aa922 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #0x8
700aa918: e7ff         	b	0x700aa91a <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #-0x2
700aa91a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa91e: 9008         	str	r0, [sp, #0x20]
;     }
700aa920: e7ff         	b	0x700aa922 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #-0x2
;     return r;
700aa922: 9808         	ldr	r0, [sp, #0x20]
700aa924: b00c         	add	sp, #0x30
700aa926: bd80         	pop	{r7, pc}
		...

700aa930 <Sciclient_rmUdmapRxChCfg>:
; {
700aa930: b580         	push	{r7, lr}
700aa932: b08c         	sub	sp, #0x30
700aa934: 900b         	str	r0, [sp, #0x2c]
700aa936: 910a         	str	r1, [sp, #0x28]
700aa938: 9209         	str	r2, [sp, #0x24]
700aa93a: f241 2015    	movw	r0, #0x1215
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_RX_CH_CFG;
700aa93e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa942: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa944: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa946: 980b         	ldr	r0, [sp, #0x2c]
700aa948: 9005         	str	r0, [sp, #0x14]
700aa94a: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa94c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa94e: 9809         	ldr	r0, [sp, #0x24]
700aa950: 9007         	str	r0, [sp, #0x1c]
700aa952: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa954: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa956: 980a         	ldr	r0, [sp, #0x28]
700aa958: 9001         	str	r0, [sp, #0x4]
700aa95a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa95c: 9002         	str	r0, [sp, #0x8]
700aa95e: a803         	add	r0, sp, #0xc
700aa960: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa962: f7f1 fa8d    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xeae6
700aa966: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa968: 9808         	ldr	r0, [sp, #0x20]
700aa96a: b930         	cbnz	r0, 0x700aa97a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #0xc
700aa96c: e7ff         	b	0x700aa96e <Sciclient_rmUdmapRxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa96e: 9800         	ldr	r0, [sp]
700aa970: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa974: 2802         	cmp	r0, #0x2
700aa976: d004         	beq	0x700aa982 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #0x8
700aa978: e7ff         	b	0x700aa97a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #-0x2
700aa97a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa97e: 9008         	str	r0, [sp, #0x20]
;     }
700aa980: e7ff         	b	0x700aa982 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #-0x2
;     return r;
700aa982: 9808         	ldr	r0, [sp, #0x20]
700aa984: b00c         	add	sp, #0x30
700aa986: bd80         	pop	{r7, pc}
		...

700aa990 <Sciclient_rmUdmapTxChCfg>:
; {
700aa990: b580         	push	{r7, lr}
700aa992: b08c         	sub	sp, #0x30
700aa994: 900b         	str	r0, [sp, #0x2c]
700aa996: 910a         	str	r1, [sp, #0x28]
700aa998: 9209         	str	r2, [sp, #0x24]
700aa99a: f241 2005    	movw	r0, #0x1205
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_TX_CH_CFG;
700aa99e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa9a2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa9a4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa9a6: 980b         	ldr	r0, [sp, #0x2c]
700aa9a8: 9005         	str	r0, [sp, #0x14]
700aa9aa: 2024         	movs	r0, #0x24
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa9ac: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa9ae: 9809         	ldr	r0, [sp, #0x24]
700aa9b0: 9007         	str	r0, [sp, #0x1c]
700aa9b2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa9b4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa9b6: 980a         	ldr	r0, [sp, #0x28]
700aa9b8: 9001         	str	r0, [sp, #0x4]
700aa9ba: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa9bc: 9002         	str	r0, [sp, #0x8]
700aa9be: a803         	add	r0, sp, #0xc
700aa9c0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa9c2: f7f1 fa5d    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xeb46
700aa9c6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa9c8: 9808         	ldr	r0, [sp, #0x20]
700aa9ca: b930         	cbnz	r0, 0x700aa9da <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #0xc
700aa9cc: e7ff         	b	0x700aa9ce <Sciclient_rmUdmapTxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa9ce: 9800         	ldr	r0, [sp]
700aa9d0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa9d4: 2802         	cmp	r0, #0x2
700aa9d6: d004         	beq	0x700aa9e2 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #0x8
700aa9d8: e7ff         	b	0x700aa9da <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #-0x2
700aa9da: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa9de: 9008         	str	r0, [sp, #0x20]
;     }
700aa9e0: e7ff         	b	0x700aa9e2 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #-0x2
;     return r;
700aa9e2: 9808         	ldr	r0, [sp, #0x20]
700aa9e4: b00c         	add	sp, #0x30
700aa9e6: bd80         	pop	{r7, pc}
		...

700aa9f0 <Sciclient_rmIrqReleaseRaw>:
; {
700aa9f0: b580         	push	{r7, lr}
700aa9f2: b08e         	sub	sp, #0x38
700aa9f4: 900d         	str	r0, [sp, #0x34]
700aa9f6: 910c         	str	r1, [sp, #0x30]
700aa9f8: f241 0001    	movw	r0, #0x1001
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_RELEASE;
700aa9fc: f8ad 0018    	strh.w	r0, [sp, #0x18]
700aaa00: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aaa02: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aaa04: 980d         	ldr	r0, [sp, #0x34]
700aaa06: 9008         	str	r0, [sp, #0x20]
700aaa08: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aaa0a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700aaa0c: 980c         	ldr	r0, [sp, #0x30]
700aaa0e: 900a         	str	r0, [sp, #0x28]
700aaa10: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aaa12: 9003         	str	r0, [sp, #0xc]
700aaa14: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700aaa16: 9004         	str	r0, [sp, #0x10]
700aaa18: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700aaa1a: 9005         	str	r0, [sp, #0x14]
700aaa1c: a806         	add	r0, sp, #0x18
700aaa1e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700aaa20: f7f1 fa2e    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xeba4
700aaa24: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700aaa26: 980b         	ldr	r0, [sp, #0x2c]
700aaa28: b930         	cbnz	r0, 0x700aaa38 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #0xc
700aaa2a: e7ff         	b	0x700aaa2c <Sciclient_rmIrqReleaseRaw+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aaa2c: 9803         	ldr	r0, [sp, #0xc]
700aaa2e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aaa32: 2802         	cmp	r0, #0x2
700aaa34: d004         	beq	0x700aaa40 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #0x8
700aaa36: e7ff         	b	0x700aaa38 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #-0x2
700aaa38: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aaa3c: 900b         	str	r0, [sp, #0x2c]
;     }
700aaa3e: e7ff         	b	0x700aaa40 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #-0x2
;     return r;
700aaa40: 980b         	ldr	r0, [sp, #0x2c]
700aaa42: b00e         	add	sp, #0x38
700aaa44: bd80         	pop	{r7, pc}
		...
700aaa4e: 0000         	movs	r0, r0

700aaa50 <Sciclient_rmPsilPair>:
; {
700aaa50: b580         	push	{r7, lr}
700aaa52: b08e         	sub	sp, #0x38
700aaa54: 900d         	str	r0, [sp, #0x34]
700aaa56: 910c         	str	r1, [sp, #0x30]
700aaa58: f44f 5094    	mov.w	r0, #0x1280
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_PAIR;
700aaa5c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700aaa60: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aaa62: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aaa64: 980d         	ldr	r0, [sp, #0x34]
700aaa66: 9008         	str	r0, [sp, #0x20]
700aaa68: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aaa6a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700aaa6c: 980c         	ldr	r0, [sp, #0x30]
700aaa6e: 900a         	str	r0, [sp, #0x28]
700aaa70: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aaa72: 9003         	str	r0, [sp, #0xc]
700aaa74: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t*)&resp;
700aaa76: 9004         	str	r0, [sp, #0x10]
700aaa78: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700aaa7a: 9005         	str	r0, [sp, #0x14]
700aaa7c: a806         	add	r0, sp, #0x18
700aaa7e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700aaa80: f7f1 f9fe    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xec04
700aaa84: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700aaa86: 980b         	ldr	r0, [sp, #0x2c]
700aaa88: b930         	cbnz	r0, 0x700aaa98 <Sciclient_rmPsilPair+0x48> @ imm = #0xc
700aaa8a: e7ff         	b	0x700aaa8c <Sciclient_rmPsilPair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aaa8c: 9803         	ldr	r0, [sp, #0xc]
700aaa8e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aaa92: 2802         	cmp	r0, #0x2
700aaa94: d004         	beq	0x700aaaa0 <Sciclient_rmPsilPair+0x50> @ imm = #0x8
700aaa96: e7ff         	b	0x700aaa98 <Sciclient_rmPsilPair+0x48> @ imm = #-0x2
700aaa98: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aaa9c: 900b         	str	r0, [sp, #0x2c]
;     }
700aaa9e: e7ff         	b	0x700aaaa0 <Sciclient_rmPsilPair+0x50> @ imm = #-0x2
;     return r;
700aaaa0: 980b         	ldr	r0, [sp, #0x2c]
700aaaa2: b00e         	add	sp, #0x38
700aaaa4: bd80         	pop	{r7, pc}
		...
700aaaae: 0000         	movs	r0, r0

700aaab0 <Sciclient_rmPsilUnpair>:
; {
700aaab0: b580         	push	{r7, lr}
700aaab2: b08e         	sub	sp, #0x38
700aaab4: 900d         	str	r0, [sp, #0x34]
700aaab6: 910c         	str	r1, [sp, #0x30]
700aaab8: f241 2081    	movw	r0, #0x1281
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_UNPAIR;
700aaabc: f8ad 0018    	strh.w	r0, [sp, #0x18]
700aaac0: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aaac2: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aaac4: 980d         	ldr	r0, [sp, #0x34]
700aaac6: 9008         	str	r0, [sp, #0x20]
700aaac8: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aaaca: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700aaacc: 980c         	ldr	r0, [sp, #0x30]
700aaace: 900a         	str	r0, [sp, #0x28]
700aaad0: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aaad2: 9003         	str	r0, [sp, #0xc]
700aaad4: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700aaad6: 9004         	str	r0, [sp, #0x10]
700aaad8: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700aaada: 9005         	str	r0, [sp, #0x14]
700aaadc: a806         	add	r0, sp, #0x18
700aaade: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700aaae0: f7f1 f9ce    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xec64
700aaae4: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700aaae6: 980b         	ldr	r0, [sp, #0x2c]
700aaae8: b930         	cbnz	r0, 0x700aaaf8 <Sciclient_rmPsilUnpair+0x48> @ imm = #0xc
700aaaea: e7ff         	b	0x700aaaec <Sciclient_rmPsilUnpair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aaaec: 9803         	ldr	r0, [sp, #0xc]
700aaaee: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aaaf2: 2802         	cmp	r0, #0x2
700aaaf4: d004         	beq	0x700aab00 <Sciclient_rmPsilUnpair+0x50> @ imm = #0x8
700aaaf6: e7ff         	b	0x700aaaf8 <Sciclient_rmPsilUnpair+0x48> @ imm = #-0x2
700aaaf8: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aaafc: 900b         	str	r0, [sp, #0x2c]
;     }
700aaafe: e7ff         	b	0x700aab00 <Sciclient_rmPsilUnpair+0x50> @ imm = #-0x2
;     return r;
700aab00: 980b         	ldr	r0, [sp, #0x2c]
700aab02: b00e         	add	sp, #0x38
700aab04: bd80         	pop	{r7, pc}
		...
700aab0e: 0000         	movs	r0, r0

700aab10 <Udma_chSetPeerReg>:
; {
700aab10: b580         	push	{r7, lr}
700aab12: b086         	sub	sp, #0x18
700aab14: f8dd c020    	ldr.w	r12, [sp, #0x20]
700aab18: 9005         	str	r0, [sp, #0x14]
700aab1a: 9104         	str	r1, [sp, #0x10]
700aab1c: 9203         	str	r2, [sp, #0xc]
700aab1e: 9302         	str	r3, [sp, #0x8]
;     regVal = CSL_REG32_RD(PEER8);
700aab20: 9803         	ldr	r0, [sp, #0xc]
700aab22: f002 ff3d    	bl	0x700ad9a0 <CSL_REG32_RD_RAW> @ imm = #0x2e7a
700aab26: 9001         	str	r0, [sp, #0x4]
;     CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 0U);
700aab28: 9801         	ldr	r0, [sp, #0x4]
700aab2a: f020 4000    	bic	r0, r0, #0x80000000
700aab2e: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER8, regVal);
700aab30: 9803         	ldr	r0, [sp, #0xc]
700aab32: 9901         	ldr	r1, [sp, #0x4]
700aab34: f002 fe94    	bl	0x700ad860 <CSL_REG32_WR_RAW> @ imm = #0x2d28
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700aab38: 9804         	ldr	r0, [sp, #0x10]
700aab3a: 6801         	ldr	r1, [r0]
;                 CSL_FMK(PSILCFG_REG_STATIC_TR_Y, pdmaPrms->elemCnt);
700aab3c: 6840         	ldr	r0, [r0, #0x4]
700aab3e: f36f 301f    	bfc	r0, #12, #20
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700aab42: f361 601a    	bfi	r0, r1, #24, #3
700aab46: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER0, regVal);
700aab48: 9808         	ldr	r0, [sp, #0x20]
700aab4a: 9901         	ldr	r1, [sp, #0x4]
700aab4c: f002 fe88    	bl	0x700ad860 <CSL_REG32_WR_RAW> @ imm = #0x2d10
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_Z, pdmaPrms->fifoCnt);
700aab50: 9804         	ldr	r0, [sp, #0x10]
700aab52: 6880         	ldr	r0, [r0, #0x8]
700aab54: f36f 301f    	bfc	r0, #12, #20
700aab58: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER1, regVal);
700aab5a: 9802         	ldr	r0, [sp, #0x8]
700aab5c: 9901         	ldr	r1, [sp, #0x4]
700aab5e: f002 fe7f    	bl	0x700ad860 <CSL_REG32_WR_RAW> @ imm = #0x2cfe
; }
700aab62: b006         	add	sp, #0x18
700aab64: bd80         	pop	{r7, pc}
		...
700aab6e: 0000         	movs	r0, r0

700aab70 <Udma_eventGetGlobalHandle>:
; {
700aab70: b084         	sub	sp, #0x10
700aab72: 9003         	str	r0, [sp, #0xc]
700aab74: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aab76: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandle    eventHandle = (Udma_EventHandle) NULL_PTR;
700aab78: 9000         	str	r0, [sp]
;     if(NULL_PTR == drvHandle)
700aab7a: 9803         	ldr	r0, [sp, #0xc]
700aab7c: b920         	cbnz	r0, 0x700aab88 <Udma_eventGetGlobalHandle+0x18> @ imm = #0x8
700aab7e: e7ff         	b	0x700aab80 <Udma_eventGetGlobalHandle+0x10> @ imm = #-0x2
700aab80: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700aab84: 9002         	str	r0, [sp, #0x8]
;     }
700aab86: e7ff         	b	0x700aab88 <Udma_eventGetGlobalHandle+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aab88: 9802         	ldr	r0, [sp, #0x8]
700aab8a: b988         	cbnz	r0, 0x700aabb0 <Udma_eventGetGlobalHandle+0x40> @ imm = #0x22
700aab8c: e7ff         	b	0x700aab8e <Udma_eventGetGlobalHandle+0x1e> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700aab8e: 9803         	ldr	r0, [sp, #0xc]
700aab90: 9001         	str	r0, [sp, #0x4]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700aab92: 9801         	ldr	r0, [sp, #0x4]
700aab94: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700aab98: f64a 31cd    	movw	r1, #0xabcd
700aab9c: f6ca 31dc    	movt	r1, #0xabdc
700aaba0: 4288         	cmp	r0, r1
700aaba2: d004         	beq	0x700aabae <Udma_eventGetGlobalHandle+0x3e> @ imm = #0x8
700aaba4: e7ff         	b	0x700aaba6 <Udma_eventGetGlobalHandle+0x36> @ imm = #-0x2
700aaba6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700aabaa: 9002         	str	r0, [sp, #0x8]
;         }
700aabac: e7ff         	b	0x700aabae <Udma_eventGetGlobalHandle+0x3e> @ imm = #-0x2
;     }
700aabae: e7ff         	b	0x700aabb0 <Udma_eventGetGlobalHandle+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aabb0: 9802         	ldr	r0, [sp, #0x8]
700aabb2: b928         	cbnz	r0, 0x700aabc0 <Udma_eventGetGlobalHandle+0x50> @ imm = #0xa
700aabb4: e7ff         	b	0x700aabb6 <Udma_eventGetGlobalHandle+0x46> @ imm = #-0x2
;         eventHandle = (Udma_EventHandle) drvHandleInt->globalEventHandle;
700aabb6: 9801         	ldr	r0, [sp, #0x4]
700aabb8: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
700aabbc: 9000         	str	r0, [sp]
;     }
700aabbe: e7ff         	b	0x700aabc0 <Udma_eventGetGlobalHandle+0x50> @ imm = #-0x2
;     return (eventHandle);
700aabc0: 9800         	ldr	r0, [sp]
700aabc2: b004         	add	sp, #0x10
700aabc4: 4770         	bx	lr
		...
700aabce: 0000         	movs	r0, r0

700aabd0 <CSL_pktdmaIsValidChanIdx>:
; {
700aabd0: b084         	sub	sp, #0x10
700aabd2: 9003         	str	r0, [sp, #0xc]
700aabd4: 9102         	str	r1, [sp, #0x8]
700aabd6: 9201         	str	r2, [sp, #0x4]
;     if( (chanDir == CSL_PKTDMA_CHAN_DIR_TX) && (chanIdx < pCfg->txChanCnt) )
700aabd8: 9801         	ldr	r0, [sp, #0x4]
700aabda: b950         	cbnz	r0, 0x700aabf2 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x14
700aabdc: e7ff         	b	0x700aabde <CSL_pktdmaIsValidChanIdx+0xe> @ imm = #-0x2
700aabde: 9802         	ldr	r0, [sp, #0x8]
700aabe0: 9903         	ldr	r1, [sp, #0xc]
700aabe2: 6a09         	ldr	r1, [r1, #0x20]
700aabe4: 4288         	cmp	r0, r1
700aabe6: d204         	bhs	0x700aabf2 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x8
700aabe8: e7ff         	b	0x700aabea <CSL_pktdmaIsValidChanIdx+0x1a> @ imm = #-0x2
700aabea: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700aabec: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aabf0: e012         	b	0x700aac18 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #0x24
;     else if( (chanDir == CSL_PKTDMA_CHAN_DIR_RX) && (chanIdx < pCfg->rxChanCnt) )
700aabf2: 9801         	ldr	r0, [sp, #0x4]
700aabf4: 2801         	cmp	r0, #0x1
700aabf6: d10a         	bne	0x700aac0e <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x14
700aabf8: e7ff         	b	0x700aabfa <CSL_pktdmaIsValidChanIdx+0x2a> @ imm = #-0x2
700aabfa: 9802         	ldr	r0, [sp, #0x8]
700aabfc: 9903         	ldr	r1, [sp, #0xc]
700aabfe: 6a49         	ldr	r1, [r1, #0x24]
700aac00: 4288         	cmp	r0, r1
700aac02: d204         	bhs	0x700aac0e <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x8
700aac04: e7ff         	b	0x700aac06 <CSL_pktdmaIsValidChanIdx+0x36> @ imm = #-0x2
700aac06: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700aac08: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aac0c: e003         	b	0x700aac16 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #0x6
700aac0e: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700aac10: f88d 0003    	strb.w	r0, [sp, #0x3]
700aac14: e7ff         	b	0x700aac16 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #-0x2
700aac16: e7ff         	b	0x700aac18 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #-0x2
;     return bRetVal;
700aac18: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aac1c: f000 0001    	and	r0, r0, #0x1
700aac20: b004         	add	sp, #0x10
700aac22: 4770         	bx	lr
		...

700aac30 <Sciclient_rmUnmappedVintRouteCreate>:
; {
700aac30: b580         	push	{r7, lr}
700aac32: b084         	sub	sp, #0x10
700aac34: 9003         	str	r0, [sp, #0xc]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700aac36: 9903         	ldr	r1, [sp, #0xc]
700aac38: 8a08         	ldrh	r0, [r1, #0x10]
700aac3a: 8a49         	ldrh	r1, [r1, #0x12]
700aac3c: f10d 0207    	add.w	r2, sp, #0x7
700aac40: f7fe fc4e    	bl	0x700a94e0 <Sciclient_rmIaVintGetInfo> @ imm = #-0x1764
700aac44: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700aac46: 9802         	ldr	r0, [sp, #0x8]
700aac48: b940         	cbnz	r0, 0x700aac5c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x10
700aac4a: e7ff         	b	0x700aac4c <Sciclient_rmUnmappedVintRouteCreate+0x1c> @ imm = #-0x2
700aac4c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700aac50: b120         	cbz	r0, 0x700aac5c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x8
700aac52: e7ff         	b	0x700aac54 <Sciclient_rmUnmappedVintRouteCreate+0x24> @ imm = #-0x2
700aac54: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700aac58: 9002         	str	r0, [sp, #0x8]
;     }
700aac5a: e7ff         	b	0x700aac5c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700aac5c: 9802         	ldr	r0, [sp, #0x8]
700aac5e: b970         	cbnz	r0, 0x700aac7e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #0x1c
700aac60: e7ff         	b	0x700aac62 <Sciclient_rmUnmappedVintRouteCreate+0x32> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700aac62: 9803         	ldr	r0, [sp, #0xc]
700aac64: f7f1 ff9c    	bl	0x7009cba0 <Sciclient_rmIrqFindRoute> @ imm = #-0xe0c8
700aac68: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700aac6a: 9802         	ldr	r0, [sp, #0x8]
700aac6c: b930         	cbnz	r0, 0x700aac7c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #0xc
700aac6e: e7ff         	b	0x700aac70 <Sciclient_rmUnmappedVintRouteCreate+0x40> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, false);
700aac70: 9803         	ldr	r0, [sp, #0xc]
700aac72: 2100         	movs	r1, #0x0
700aac74: f7f4 fb0c    	bl	0x7009f290 <Sciclient_rmIrqProgramRoute> @ imm = #-0xb9e8
700aac78: 9002         	str	r0, [sp, #0x8]
;         }
700aac7a: e7ff         	b	0x700aac7c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #-0x2
;     }
700aac7c: e7ff         	b	0x700aac7e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #-0x2
;     return r;
700aac7e: 9802         	ldr	r0, [sp, #0x8]
700aac80: b004         	add	sp, #0x10
700aac82: bd80         	pop	{r7, pc}
		...

700aac90 <UART_OperModeValid>:
; {
700aac90: b082         	sub	sp, #0x8
700aac92: 9001         	str	r0, [sp, #0x4]
700aac94: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700aac98: 9000         	str	r0, [sp]
;     if(((operMode == UART_OPER_MODE_16X) ||
700aac9a: 9801         	ldr	r0, [sp, #0x4]
700aac9c: b1e0         	cbz	r0, 0x700aacd8 <UART_OperModeValid+0x48> @ imm = #0x38
700aac9e: e7ff         	b	0x700aaca0 <UART_OperModeValid+0x10> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_SIR) ||
700aaca0: 9801         	ldr	r0, [sp, #0x4]
700aaca2: 2801         	cmp	r0, #0x1
700aaca4: d018         	beq	0x700aacd8 <UART_OperModeValid+0x48> @ imm = #0x30
700aaca6: e7ff         	b	0x700aaca8 <UART_OperModeValid+0x18> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_16X_AUTO_BAUD) ||
700aaca8: 9801         	ldr	r0, [sp, #0x4]
700aacaa: 2802         	cmp	r0, #0x2
700aacac: d014         	beq	0x700aacd8 <UART_OperModeValid+0x48> @ imm = #0x28
700aacae: e7ff         	b	0x700aacb0 <UART_OperModeValid+0x20> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_13X) ||
700aacb0: 9801         	ldr	r0, [sp, #0x4]
700aacb2: 2803         	cmp	r0, #0x3
700aacb4: d010         	beq	0x700aacd8 <UART_OperModeValid+0x48> @ imm = #0x20
700aacb6: e7ff         	b	0x700aacb8 <UART_OperModeValid+0x28> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_MIR) ||
700aacb8: 9801         	ldr	r0, [sp, #0x4]
700aacba: 2804         	cmp	r0, #0x4
700aacbc: d00c         	beq	0x700aacd8 <UART_OperModeValid+0x48> @ imm = #0x18
700aacbe: e7ff         	b	0x700aacc0 <UART_OperModeValid+0x30> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_FIR) ||
700aacc0: 9801         	ldr	r0, [sp, #0x4]
700aacc2: 2805         	cmp	r0, #0x5
700aacc4: d008         	beq	0x700aacd8 <UART_OperModeValid+0x48> @ imm = #0x10
700aacc6: e7ff         	b	0x700aacc8 <UART_OperModeValid+0x38> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_CIR) ||
700aacc8: 9801         	ldr	r0, [sp, #0x4]
700aacca: 2806         	cmp	r0, #0x6
700aaccc: d004         	beq	0x700aacd8 <UART_OperModeValid+0x48> @ imm = #0x8
700aacce: e7ff         	b	0x700aacd0 <UART_OperModeValid+0x40> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_DISABLED)))
700aacd0: 9801         	ldr	r0, [sp, #0x4]
;     if(((operMode == UART_OPER_MODE_16X) ||
700aacd2: 2807         	cmp	r0, #0x7
700aacd4: d103         	bne	0x700aacde <UART_OperModeValid+0x4e> @ imm = #0x6
700aacd6: e7ff         	b	0x700aacd8 <UART_OperModeValid+0x48> @ imm = #-0x2
700aacd8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700aacda: 9000         	str	r0, [sp]
;     }
700aacdc: e7ff         	b	0x700aacde <UART_OperModeValid+0x4e> @ imm = #-0x2
;     return status;
700aacde: 9800         	ldr	r0, [sp]
700aace0: b002         	add	sp, #0x8
700aace2: 4770         	bx	lr
		...

700aacf0 <UdmaRingPrms_init>:
; {
700aacf0: b081         	sub	sp, #0x4
700aacf2: 9000         	str	r0, [sp]
;     if(NULL_PTR != ringPrms)
700aacf4: 9800         	ldr	r0, [sp]
700aacf6: b318         	cbz	r0, 0x700aad40 <UdmaRingPrms_init+0x50> @ imm = #0x46
700aacf8: e7ff         	b	0x700aacfa <UdmaRingPrms_init+0xa> @ imm = #-0x2
;         ringPrms->ringMem       = NULL_PTR;
700aacfa: 9900         	ldr	r1, [sp]
700aacfc: 2000         	movs	r0, #0x0
700aacfe: 6008         	str	r0, [r1]
;         ringPrms->ringMemSize   = UDMA_RING_SIZE_CHECK_SKIP;
700aad00: 9a00         	ldr	r2, [sp]
700aad02: f64a 31cd    	movw	r1, #0xabcd
700aad06: f6ca 31dc    	movt	r1, #0xabdc
700aad0a: 6051         	str	r1, [r2, #0x4]
;         ringPrms->mode          = TISCI_MSG_VALUE_RM_RING_MODE_RING;
700aad0c: 9900         	ldr	r1, [sp]
700aad0e: 7208         	strb	r0, [r1, #0x8]
;         ringPrms->virtId        = UDMA_RING_VIRTID_INVALID;
700aad10: 9a00         	ldr	r2, [sp]
700aad12: f64f 71ff    	movw	r1, #0xffff
700aad16: 8151         	strh	r1, [r2, #0xa]
;         ringPrms->elemCnt       = 0U;
700aad18: 9900         	ldr	r1, [sp]
700aad1a: 60c8         	str	r0, [r1, #0xc]
;         ringPrms->elemSize      = UDMA_RING_ES_8BYTES;
700aad1c: 9a00         	ldr	r2, [sp]
700aad1e: 2101         	movs	r1, #0x1
700aad20: 7411         	strb	r1, [r2, #0x10]
;         ringPrms->orderId       = UDMA_DEFAULT_RING_ORDER_ID;
700aad22: 9900         	ldr	r1, [sp]
700aad24: 7448         	strb	r0, [r1, #0x11]
;         ringPrms->asel          = UDMA_RINGACC_ASEL_ENDPOINT_PHYSADDR;
700aad26: 9900         	ldr	r1, [sp]
700aad28: 7488         	strb	r0, [r1, #0x12]
;         ringPrms->mappedRingGrp = UDMA_MAPPED_GROUP_INVALID;
700aad2a: 9900         	ldr	r1, [sp]
700aad2c: 2004         	movs	r0, #0x4
700aad2e: f6cf 70ff    	movt	r0, #0xffff
700aad32: 6148         	str	r0, [r1, #0x14]
;         ringPrms->mappedChNum   = UDMA_DMA_CH_INVALID;
700aad34: 9900         	ldr	r1, [sp]
700aad36: 2000         	movs	r0, #0x0
700aad38: f6cf 70ff    	movt	r0, #0xffff
700aad3c: 6188         	str	r0, [r1, #0x18]
;     }
700aad3e: e7ff         	b	0x700aad40 <UdmaRingPrms_init+0x50> @ imm = #-0x2
;     return;
700aad40: b001         	add	sp, #0x4
700aad42: 4770         	bx	lr
		...

700aad50 <prvIdleTask>:
; static portTASK_FUNCTION(prvIdleTask, pvParameters) {
700aad50: b580         	push	{r7, lr}
700aad52: b082         	sub	sp, #0x8
700aad54: 9001         	str	r0, [sp, #0x4]
;   for (;;) {
700aad56: e7ff         	b	0x700aad58 <prvIdleTask+0x8> @ imm = #-0x2
;     prvCheckTasksWaitingTermination();
700aad58: f7ff fcca    	bl	0x700aa6f0 <prvCheckTasksWaitingTermination> @ imm = #-0x66c
;       if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700aad5c: f244 40f8    	movw	r0, #0x44f8
700aad60: f2c7 0008    	movt	r0, #0x7008
700aad64: 6800         	ldr	r0, [r0]
700aad66: 2802         	cmp	r0, #0x2
700aad68: d302         	blo	0x700aad70 <prvIdleTask+0x20> @ imm = #0x4
700aad6a: e7ff         	b	0x700aad6c <prvIdleTask+0x1c> @ imm = #-0x2
;         taskYIELD();
700aad6c: df00         	svc	#0x0
;       } else {
700aad6e: e000         	b	0x700aad72 <prvIdleTask+0x22> @ imm = #0x0
700aad70: e7ff         	b	0x700aad72 <prvIdleTask+0x22> @ imm = #-0x2
;       vApplicationIdleHook();
700aad72: f002 fe7d    	bl	0x700ada70 <vApplicationIdleHook> @ imm = #0x2cfa
;       xExpectedIdleTime = prvGetExpectedIdleTime();
700aad76: f7fd ff93    	bl	0x700a8ca0 <prvGetExpectedIdleTime> @ imm = #-0x20da
700aad7a: 9000         	str	r0, [sp]
;       if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700aad7c: 9800         	ldr	r0, [sp]
700aad7e: 2802         	cmp	r0, #0x2
700aad80: d30e         	blo	0x700aada0 <prvIdleTask+0x50> @ imm = #0x1c
700aad82: e7ff         	b	0x700aad84 <prvIdleTask+0x34> @ imm = #-0x2
;         vTaskSuspendAll();
700aad84: f002 fdc4    	bl	0x700ad910 <vTaskSuspendAll> @ imm = #0x2b88
;           xExpectedIdleTime = prvGetExpectedIdleTime();
700aad88: f7fd ff8a    	bl	0x700a8ca0 <prvGetExpectedIdleTime> @ imm = #-0x20ec
700aad8c: 9000         	str	r0, [sp]
;           if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700aad8e: 9800         	ldr	r0, [sp]
700aad90: 2802         	cmp	r0, #0x2
700aad92: d301         	blo	0x700aad98 <prvIdleTask+0x48> @ imm = #0x2
700aad94: e7ff         	b	0x700aad96 <prvIdleTask+0x46> @ imm = #-0x2
;           } else {
700aad96: e000         	b	0x700aad9a <prvIdleTask+0x4a> @ imm = #0x0
700aad98: e7ff         	b	0x700aad9a <prvIdleTask+0x4a> @ imm = #-0x2
;         (void)xTaskResumeAll();
700aad9a: f7f5 ff09    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0xa1ee
;       } else {
700aad9e: e000         	b	0x700aada2 <prvIdleTask+0x52> @ imm = #0x0
700aada0: e7ff         	b	0x700aada2 <prvIdleTask+0x52> @ imm = #-0x2
;   for (;;) {
700aada2: e7d9         	b	0x700aad58 <prvIdleTask+0x8> @ imm = #-0x4e
		...

700aadb0 <vQueueUnregisterQueue>:
;     {
700aadb0: b082         	sub	sp, #0x8
700aadb2: 9001         	str	r0, [sp, #0x4]
700aadb4: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700aadb6: 9000         	str	r0, [sp]
700aadb8: e7ff         	b	0x700aadba <vQueueUnregisterQueue+0xa> @ imm = #-0x2
700aadba: 9800         	ldr	r0, [sp]
700aadbc: 281f         	cmp	r0, #0x1f
700aadbe: d81f         	bhi	0x700aae00 <vQueueUnregisterQueue+0x50> @ imm = #0x3e
700aadc0: e7ff         	b	0x700aadc2 <vQueueUnregisterQueue+0x12> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].xHandle == xQueue )
700aadc2: 9900         	ldr	r1, [sp]
700aadc4: f644 2078    	movw	r0, #0x4a78
700aadc8: f2c7 0008    	movt	r0, #0x7008
700aadcc: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700aadd0: 6840         	ldr	r0, [r0, #0x4]
700aadd2: 9901         	ldr	r1, [sp, #0x4]
700aadd4: 4288         	cmp	r0, r1
700aadd6: d10d         	bne	0x700aadf4 <vQueueUnregisterQueue+0x44> @ imm = #0x1a
700aadd8: e7ff         	b	0x700aadda <vQueueUnregisterQueue+0x2a> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = NULL;
700aadda: 9a00         	ldr	r2, [sp]
700aaddc: f644 2178    	movw	r1, #0x4a78
700aade0: f2c7 0108    	movt	r1, #0x7008
700aade4: 2000         	movs	r0, #0x0
700aade6: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
700aadea: 9a00         	ldr	r2, [sp]
700aadec: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700aadf0: 6048         	str	r0, [r1, #0x4]
;                 break;
700aadf2: e005         	b	0x700aae00 <vQueueUnregisterQueue+0x50> @ imm = #0xa
700aadf4: e7ff         	b	0x700aadf6 <vQueueUnregisterQueue+0x46> @ imm = #-0x2
;         }
700aadf6: e7ff         	b	0x700aadf8 <vQueueUnregisterQueue+0x48> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700aadf8: 9800         	ldr	r0, [sp]
700aadfa: 3001         	adds	r0, #0x1
700aadfc: 9000         	str	r0, [sp]
700aadfe: e7dc         	b	0x700aadba <vQueueUnregisterQueue+0xa> @ imm = #-0x48
;     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
700aae00: b002         	add	sp, #0x8
700aae02: 4770         	bx	lr

700aae04 <__TI_auto_init_nobinit_nopinit>:
700aae04: e92d4070     	push	{r4, r5, r6, lr}
700aae08: e59f403c     	ldr	r4, [pc, #0x3c]         @ 0x700aae4c <__TI_auto_init_nobinit_nopinit+0x48>
700aae0c: e59f0034     	ldr	r0, [pc, #0x34]         @ 0x700aae48 <__TI_auto_init_nobinit_nopinit+0x44>
700aae10: e1540000     	cmp	r4, r0
700aae14: 0a000009     	beq	0x700aae40 <__TI_auto_init_nobinit_nopinit+0x3c> @ imm = #0x24
700aae18: e59f5030     	ldr	r5, [pc, #0x30]         @ 0x700aae50 <__TI_auto_init_nobinit_nopinit+0x4c>
700aae1c: e59f6030     	ldr	r6, [pc, #0x30]         @ 0x700aae54 <__TI_auto_init_nobinit_nopinit+0x50>
700aae20: e1550006     	cmp	r5, r6
700aae24: 0a000005     	beq	0x700aae40 <__TI_auto_init_nobinit_nopinit+0x3c> @ imm = #0x14
700aae28: e1c500d0     	ldrd	r0, r1, [r5]
700aae2c: e4d02001     	ldrb	r2, [r0], #1
700aae30: e7942102     	ldr	r2, [r4, r2, lsl #2]
700aae34: e12fff32     	blx	r2
700aae38: e2855008     	add	r5, r5, #8
700aae3c: eafffff7     	b	0x700aae20 <__TI_auto_init_nobinit_nopinit+0x1c> @ imm = #-0x24
700aae40: e1a00000     	mov	r0, r0
700aae44: e8bd8070     	pop	{r4, r5, r6, pc}
700aae48: 00 00 00 00  	.word	0x00000000
700aae4c: 00 00 00 00  	.word	0x00000000
700aae50: 00 00 00 00  	.word	0x00000000
700aae54: 00 00 00 00  	.word	0x00000000
700aae58: 00 00 00 00  	.word	0x00000000
700aae5c: 00 00 00 00  	.word	0x00000000

700aae60 <Drivers_open>:
; {
700aae60: b5b0         	push	{r4, r5, r7, lr}
700aae62: b082         	sub	sp, #0x8
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700aae64: f240 312c    	movw	r1, #0x32c
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700aae68: f644 74c8    	movw	r4, #0x4fc8
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700aae6c: f2c7 010b    	movt	r1, #0x700b
700aae70: 2500         	movs	r5, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700aae72: f2c7 0408    	movt	r4, #0x7008
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700aae76: 2000         	movs	r0, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700aae78: 6025         	str	r5, [r4]
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700aae7a: f7ef fdb1    	bl	0x7009a9e0 <UART_open>  @ imm = #-0x1049e
700aae7e: 6020         	str	r0, [r4]
;         if(NULL == gUartHandle[instCnt])
700aae80: b108         	cbz	r0, 0x700aae86 <Drivers_open+0x26> @ imm = #0x2
; }
700aae82: b002         	add	sp, #0x8
700aae84: bdb0         	pop	{r4, r5, r7, pc}
;             DebugP_logError("UART open failed for instance %d !!!\r\n", instCnt);
700aae86: f24f 617a    	movw	r1, #0xf67a
700aae8a: f64f 32dc    	movw	r2, #0xfbdc
700aae8e: f2c7 010a    	movt	r1, #0x700a
700aae92: f2c7 020a    	movt	r2, #0x700a
700aae96: 2002         	movs	r0, #0x2
700aae98: 236e         	movs	r3, #0x6e
700aae9a: 9500         	str	r5, [sp]
700aae9c: f7fc fec8    	bl	0x700a7c30 <_DebugP_logZone> @ imm = #-0x3270
;         if(gUartHandle[instCnt] != NULL)
700aaea0: 6820         	ldr	r0, [r4]
700aaea2: 2800         	cmp	r0, #0x0
700aaea4: d0ed         	beq	0x700aae82 <Drivers_open+0x22> @ imm = #-0x26
;             UART_close(gUartHandle[instCnt]);
700aaea6: f7f3 f9cb    	bl	0x7009e240 <UART_close> @ imm = #-0xcc6a
700aaeaa: 2000         	movs	r0, #0x0
;             gUartHandle[instCnt] = NULL;
700aaeac: 6020         	str	r0, [r4]
; }
700aaeae: b002         	add	sp, #0x8
700aaeb0: bdb0         	pop	{r4, r5, r7, pc}
		...
700aaebe: 0000         	movs	r0, r0

700aaec0 <Udma_chInitRegs>:
; {
700aaec0: b081         	sub	sp, #0x4
700aaec2: 9000         	str	r0, [sp]
;     chHandle->pBcdmaBcCfgRegs    = (volatile CSL_bcdma_bccfgRegs_chan *) NULL_PTR;
700aaec4: 9900         	ldr	r1, [sp]
700aaec6: 2000         	movs	r0, #0x0
700aaec8: f8c1 0214    	str.w	r0, [r1, #0x214]
;     chHandle->pBcdmaBcRtRegs     = (volatile CSL_bcdma_bcrtRegs_chan *) NULL_PTR;
700aaecc: 9900         	ldr	r1, [sp]
700aaece: f8c1 0218    	str.w	r0, [r1, #0x218]
;     chHandle->pBcdmaTxCfgRegs   = (volatile CSL_bcdma_txccfgRegs_chan *) NULL_PTR;
700aaed2: 9900         	ldr	r1, [sp]
700aaed4: f8c1 021c    	str.w	r0, [r1, #0x21c]
;     chHandle->pBcdmaTxRtRegs    = (volatile CSL_bcdma_txcrtRegs_chan *) NULL_PTR;
700aaed8: 9900         	ldr	r1, [sp]
700aaeda: f8c1 0220    	str.w	r0, [r1, #0x220]
;     chHandle->pBcdmaRxCfgRegs   = (volatile CSL_bcdma_rxccfgRegs_chan *) NULL_PTR;
700aaede: 9900         	ldr	r1, [sp]
700aaee0: f8c1 0224    	str.w	r0, [r1, #0x224]
;     chHandle->pBcdmaRxRtRegs    = (volatile CSL_bcdma_rxcrtRegs_chan *) NULL_PTR;
700aaee4: 9900         	ldr	r1, [sp]
700aaee6: f8c1 0228    	str.w	r0, [r1, #0x228]
;     chHandle->pPktdmaTxCfgRegs  = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700aaeea: 9900         	ldr	r1, [sp]
700aaeec: f8c1 022c    	str.w	r0, [r1, #0x22c]
;     chHandle->pPktdmaTxRtRegs   = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700aaef0: 9900         	ldr	r1, [sp]
700aaef2: f8c1 0230    	str.w	r0, [r1, #0x230]
;     chHandle->pPktdmaRxCfgRegs  = (volatile CSL_pktdma_rxccfgRegs_chan *) NULL_PTR;
700aaef6: 9900         	ldr	r1, [sp]
700aaef8: f8c1 0234    	str.w	r0, [r1, #0x234]
;     chHandle->pPktdmaRxRtRegs   = (volatile CSL_pktdma_rxcrtRegs_chan *) NULL_PTR;
700aaefc: 9900         	ldr	r1, [sp]
700aaefe: f8c1 0238    	str.w	r0, [r1, #0x238]
;     chHandle->pPktdmaExtCfgRegs = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700aaf02: 9900         	ldr	r1, [sp]
700aaf04: f8c1 023c    	str.w	r0, [r1, #0x23c]
;     chHandle->pPktdmaExtRtRegs  = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700aaf08: 9900         	ldr	r1, [sp]
700aaf0a: f8c1 0240    	str.w	r0, [r1, #0x240]
; }
700aaf0e: b001         	add	sp, #0x4
700aaf10: 4770         	bx	lr
		...
700aaf1e: 0000         	movs	r0, r0

700aaf20 <vQueueAddToRegistry>:
;     {
700aaf20: b083         	sub	sp, #0xc
700aaf22: 9002         	str	r0, [sp, #0x8]
700aaf24: 9101         	str	r1, [sp, #0x4]
700aaf26: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700aaf28: 9000         	str	r0, [sp]
700aaf2a: e7ff         	b	0x700aaf2c <vQueueAddToRegistry+0xc> @ imm = #-0x2
700aaf2c: 9800         	ldr	r0, [sp]
700aaf2e: 281f         	cmp	r0, #0x1f
700aaf30: d81d         	bhi	0x700aaf6e <vQueueAddToRegistry+0x4e> @ imm = #0x3a
700aaf32: e7ff         	b	0x700aaf34 <vQueueAddToRegistry+0x14> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].pcQueueName == NULL )
700aaf34: 9900         	ldr	r1, [sp]
700aaf36: f644 2078    	movw	r0, #0x4a78
700aaf3a: f2c7 0008    	movt	r0, #0x7008
700aaf3e: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700aaf42: b970         	cbnz	r0, 0x700aaf62 <vQueueAddToRegistry+0x42> @ imm = #0x1c
700aaf44: e7ff         	b	0x700aaf46 <vQueueAddToRegistry+0x26> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = pcQueueName;
700aaf46: 9801         	ldr	r0, [sp, #0x4]
700aaf48: 9a00         	ldr	r2, [sp]
700aaf4a: f644 2178    	movw	r1, #0x4a78
700aaf4e: f2c7 0108    	movt	r1, #0x7008
700aaf52: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = xQueue;
700aaf56: 9802         	ldr	r0, [sp, #0x8]
700aaf58: 9a00         	ldr	r2, [sp]
700aaf5a: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700aaf5e: 6048         	str	r0, [r1, #0x4]
;                 break;
700aaf60: e005         	b	0x700aaf6e <vQueueAddToRegistry+0x4e> @ imm = #0xa
700aaf62: e7ff         	b	0x700aaf64 <vQueueAddToRegistry+0x44> @ imm = #-0x2
;         }
700aaf64: e7ff         	b	0x700aaf66 <vQueueAddToRegistry+0x46> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700aaf66: 9800         	ldr	r0, [sp]
700aaf68: 3001         	adds	r0, #0x1
700aaf6a: 9000         	str	r0, [sp]
700aaf6c: e7de         	b	0x700aaf2c <vQueueAddToRegistry+0xc> @ imm = #-0x44
;     }
700aaf6e: b003         	add	sp, #0xc
700aaf70: 4770         	bx	lr
		...
700aaf7e: 0000         	movs	r0, r0

700aaf80 <xQueueTakeMutexRecursive>:
;     {
700aaf80: b580         	push	{r7, lr}
700aaf82: b086         	sub	sp, #0x18
700aaf84: 9005         	str	r0, [sp, #0x14]
700aaf86: 9104         	str	r1, [sp, #0x10]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700aaf88: 9805         	ldr	r0, [sp, #0x14]
700aaf8a: 9002         	str	r0, [sp, #0x8]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700aaf8c: 9802         	ldr	r0, [sp, #0x8]
700aaf8e: 6880         	ldr	r0, [r0, #0x8]
700aaf90: 9001         	str	r0, [sp, #0x4]
700aaf92: f002 fbbd    	bl	0x700ad710 <xTaskGetCurrentTaskHandle> @ imm = #0x277a
700aaf96: 4601         	mov	r1, r0
700aaf98: 9801         	ldr	r0, [sp, #0x4]
700aaf9a: 4288         	cmp	r0, r1
700aaf9c: d107         	bne	0x700aafae <xQueueTakeMutexRecursive+0x2e> @ imm = #0xe
700aaf9e: e7ff         	b	0x700aafa0 <xQueueTakeMutexRecursive+0x20> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700aafa0: 9902         	ldr	r1, [sp, #0x8]
700aafa2: 68c8         	ldr	r0, [r1, #0xc]
700aafa4: 3001         	adds	r0, #0x1
700aafa6: 60c8         	str	r0, [r1, #0xc]
700aafa8: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700aafaa: 9003         	str	r0, [sp, #0xc]
;         }
700aafac: e00e         	b	0x700aafcc <xQueueTakeMutexRecursive+0x4c> @ imm = #0x1c
;             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
700aafae: 9802         	ldr	r0, [sp, #0x8]
700aafb0: 9904         	ldr	r1, [sp, #0x10]
700aafb2: f7f4 fbbd    	bl	0x7009f730 <xQueueSemaphoreTake> @ imm = #-0xb886
700aafb6: 9003         	str	r0, [sp, #0xc]
;             if( xReturn != pdFAIL )
700aafb8: 9803         	ldr	r0, [sp, #0xc]
700aafba: b128         	cbz	r0, 0x700aafc8 <xQueueTakeMutexRecursive+0x48> @ imm = #0xa
700aafbc: e7ff         	b	0x700aafbe <xQueueTakeMutexRecursive+0x3e> @ imm = #-0x2
;                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700aafbe: 9902         	ldr	r1, [sp, #0x8]
700aafc0: 68c8         	ldr	r0, [r1, #0xc]
700aafc2: 3001         	adds	r0, #0x1
700aafc4: 60c8         	str	r0, [r1, #0xc]
;             }
700aafc6: e000         	b	0x700aafca <xQueueTakeMutexRecursive+0x4a> @ imm = #0x0
700aafc8: e7ff         	b	0x700aafca <xQueueTakeMutexRecursive+0x4a> @ imm = #-0x2
700aafca: e7ff         	b	0x700aafcc <xQueueTakeMutexRecursive+0x4c> @ imm = #-0x2
;         return xReturn;
700aafcc: 9803         	ldr	r0, [sp, #0xc]
700aafce: b006         	add	sp, #0x18
700aafd0: bd80         	pop	{r7, pc}
		...
700aafde: 0000         	movs	r0, r0

700aafe0 <UART_checkCharsAvailInFifo>:
; {
700aafe0: b580         	push	{r7, lr}
700aafe2: b084         	sub	sp, #0x10
700aafe4: 9003         	str	r0, [sp, #0xc]
700aafe6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700aafe8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700aafea: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700aafec: 9803         	ldr	r0, [sp, #0xc]
700aafee: 300c         	adds	r0, #0xc
700aaff0: f002 fc66    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x28cc
700aaff4: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700aaff6: 9803         	ldr	r0, [sp, #0xc]
700aaff8: 300c         	adds	r0, #0xc
700aaffa: 9000         	str	r0, [sp]
700aaffc: f002 fc60    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x28c0
700ab000: 4601         	mov	r1, r0
700ab002: 9800         	ldr	r0, [sp]
700ab004: f001 017f    	and	r1, r1, #0x7f
700ab008: f002 fc62    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x28c4
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ab00c: 9803         	ldr	r0, [sp, #0xc]
700ab00e: 3014         	adds	r0, #0x14
700ab010: f002 fc56    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x28ac
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700ab014: 07c0         	lsls	r0, r0, #0x1f
700ab016: b118         	cbz	r0, 0x700ab020 <UART_checkCharsAvailInFifo+0x40> @ imm = #0x6
700ab018: e7ff         	b	0x700ab01a <UART_checkCharsAvailInFifo+0x3a> @ imm = #-0x2
700ab01a: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700ab01c: 9001         	str	r0, [sp, #0x4]
;     }
700ab01e: e7ff         	b	0x700ab020 <UART_checkCharsAvailInFifo+0x40> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ab020: 9803         	ldr	r0, [sp, #0xc]
700ab022: 300c         	adds	r0, #0xc
700ab024: 9902         	ldr	r1, [sp, #0x8]
700ab026: f002 fc53    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x28a6
;     return retVal;
700ab02a: 9801         	ldr	r0, [sp, #0x4]
700ab02c: b004         	add	sp, #0x10
700ab02e: bd80         	pop	{r7, pc}

700ab030 <xQueueGiveMutexRecursive>:
;     {
700ab030: b580         	push	{r7, lr}
700ab032: b084         	sub	sp, #0x10
700ab034: 9003         	str	r0, [sp, #0xc]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700ab036: 9803         	ldr	r0, [sp, #0xc]
700ab038: 9001         	str	r0, [sp, #0x4]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700ab03a: 9801         	ldr	r0, [sp, #0x4]
700ab03c: 6880         	ldr	r0, [r0, #0x8]
700ab03e: 9000         	str	r0, [sp]
700ab040: f002 fb66    	bl	0x700ad710 <xTaskGetCurrentTaskHandle> @ imm = #0x26cc
700ab044: 4601         	mov	r1, r0
700ab046: 9800         	ldr	r0, [sp]
700ab048: 4288         	cmp	r0, r1
700ab04a: d113         	bne	0x700ab074 <xQueueGiveMutexRecursive+0x44> @ imm = #0x26
700ab04c: e7ff         	b	0x700ab04e <xQueueGiveMutexRecursive+0x1e> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
700ab04e: 9901         	ldr	r1, [sp, #0x4]
700ab050: 68c8         	ldr	r0, [r1, #0xc]
700ab052: 3801         	subs	r0, #0x1
700ab054: 60c8         	str	r0, [r1, #0xc]
;             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
700ab056: 9801         	ldr	r0, [sp, #0x4]
700ab058: 68c0         	ldr	r0, [r0, #0xc]
700ab05a: b938         	cbnz	r0, 0x700ab06c <xQueueGiveMutexRecursive+0x3c> @ imm = #0xe
700ab05c: e7ff         	b	0x700ab05e <xQueueGiveMutexRecursive+0x2e> @ imm = #-0x2
;                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
700ab05e: 9801         	ldr	r0, [sp, #0x4]
700ab060: 2300         	movs	r3, #0x0
700ab062: 4619         	mov	r1, r3
700ab064: 461a         	mov	r2, r3
700ab066: f7f6 fa93    	bl	0x700a1590 <xQueueGenericSend> @ imm = #-0x9ada
;             }
700ab06a: e000         	b	0x700ab06e <xQueueGiveMutexRecursive+0x3e> @ imm = #0x0
700ab06c: e7ff         	b	0x700ab06e <xQueueGiveMutexRecursive+0x3e> @ imm = #-0x2
700ab06e: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700ab070: 9002         	str	r0, [sp, #0x8]
;         }
700ab072: e002         	b	0x700ab07a <xQueueGiveMutexRecursive+0x4a> @ imm = #0x4
700ab074: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700ab076: 9002         	str	r0, [sp, #0x8]
700ab078: e7ff         	b	0x700ab07a <xQueueGiveMutexRecursive+0x4a> @ imm = #-0x2
;         return xReturn;
700ab07a: 9802         	ldr	r0, [sp, #0x8]
700ab07c: b004         	add	sp, #0x10
700ab07e: bd80         	pop	{r7, pc}

700ab080 <CSL_pktdmaIsChanEnabled>:
; {
700ab080: b580         	push	{r7, lr}
700ab082: b084         	sub	sp, #0x10
700ab084: 9003         	str	r0, [sp, #0xc]
700ab086: 9102         	str	r1, [sp, #0x8]
700ab088: 9201         	str	r2, [sp, #0x4]
;     if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700ab08a: 9801         	ldr	r0, [sp, #0x4]
700ab08c: b960         	cbnz	r0, 0x700ab0a8 <CSL_pktdmaIsChanEnabled+0x28> @ imm = #0x18
700ab08e: e7ff         	b	0x700ab090 <CSL_pktdmaIsChanEnabled+0x10> @ imm = #-0x2
;         regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_TXCRT_CHAN_CTL_EN );
700ab090: 9803         	ldr	r0, [sp, #0xc]
700ab092: 6900         	ldr	r0, [r0, #0x10]
700ab094: 9902         	ldr	r1, [sp, #0x8]
700ab096: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab09a: f04f 4100    	mov.w	r1, #0x80000000
700ab09e: 221f         	movs	r2, #0x1f
700ab0a0: f001 ff1e    	bl	0x700acee0 <CSL_REG32_FEXT_RAW> @ imm = #0x1e3c
700ab0a4: 9000         	str	r0, [sp]
;     }
700ab0a6: e00b         	b	0x700ab0c0 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #0x16
;         regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_RXCRT_CHAN_CTL_EN );
700ab0a8: 9803         	ldr	r0, [sp, #0xc]
700ab0aa: 6940         	ldr	r0, [r0, #0x14]
700ab0ac: 9902         	ldr	r1, [sp, #0x8]
700ab0ae: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab0b2: f04f 4100    	mov.w	r1, #0x80000000
700ab0b6: 221f         	movs	r2, #0x1f
700ab0b8: f001 ff12    	bl	0x700acee0 <CSL_REG32_FEXT_RAW> @ imm = #0x1e24
700ab0bc: 9000         	str	r0, [sp]
700ab0be: e7ff         	b	0x700ab0c0 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700ab0c0: 9800         	ldr	r0, [sp]
700ab0c2: 3801         	subs	r0, #0x1
700ab0c4: fab0 f080    	clz	r0, r0
700ab0c8: 0940         	lsrs	r0, r0, #0x5
700ab0ca: b004         	add	sp, #0x10
700ab0cc: bd80         	pop	{r7, pc}
700ab0ce: 0000         	movs	r0, r0

700ab0d0 <UART_getHandle>:
; {
700ab0d0: b083         	sub	sp, #0xc
700ab0d2: 9002         	str	r0, [sp, #0x8]
700ab0d4: 2000         	movs	r0, #0x0
;     UART_Handle         handle = NULL;
700ab0d6: 9001         	str	r0, [sp, #0x4]
;     if(index < gUartConfigNum)
700ab0d8: 9802         	ldr	r0, [sp, #0x8]
700ab0da: f240 41cc    	movw	r1, #0x4cc
700ab0de: f2c7 010b    	movt	r1, #0x700b
700ab0e2: 6809         	ldr	r1, [r1]
700ab0e4: 4288         	cmp	r0, r1
700ab0e6: d217         	bhs	0x700ab118 <UART_getHandle+0x48> @ imm = #0x2e
700ab0e8: e7ff         	b	0x700ab0ea <UART_getHandle+0x1a> @ imm = #-0x2
;         object = gUartConfig[index].object;
700ab0ea: 9902         	ldr	r1, [sp, #0x8]
700ab0ec: f240 4088    	movw	r0, #0x488
700ab0f0: f2c7 000b    	movt	r0, #0x700b
700ab0f4: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ab0f8: 6840         	ldr	r0, [r0, #0x4]
700ab0fa: 9000         	str	r0, [sp]
;         if(object && (TRUE == object->isOpen))
700ab0fc: 9800         	ldr	r0, [sp]
700ab0fe: b150         	cbz	r0, 0x700ab116 <UART_getHandle+0x46> @ imm = #0x14
700ab100: e7ff         	b	0x700ab102 <UART_getHandle+0x32> @ imm = #-0x2
700ab102: 9800         	ldr	r0, [sp]
700ab104: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700ab108: 2801         	cmp	r0, #0x1
700ab10a: d104         	bne	0x700ab116 <UART_getHandle+0x46> @ imm = #0x8
700ab10c: e7ff         	b	0x700ab10e <UART_getHandle+0x3e> @ imm = #-0x2
;             handle = object->handle;
700ab10e: 9800         	ldr	r0, [sp]
700ab110: 6800         	ldr	r0, [r0]
700ab112: 9001         	str	r0, [sp, #0x4]
;         }
700ab114: e7ff         	b	0x700ab116 <UART_getHandle+0x46> @ imm = #-0x2
;     }
700ab116: e7ff         	b	0x700ab118 <UART_getHandle+0x48> @ imm = #-0x2
;     return handle;
700ab118: 9801         	ldr	r0, [sp, #0x4]
700ab11a: b003         	add	sp, #0xc
700ab11c: 4770         	bx	lr
700ab11e: 0000         	movs	r0, r0

700ab120 <prvTaskIsTaskSuspended>:
; static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask) {
700ab120: b083         	sub	sp, #0xc
700ab122: 9002         	str	r0, [sp, #0x8]
700ab124: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700ab126: 9001         	str	r0, [sp, #0x4]
;   const TCB_t *const pxTCB = xTask;
700ab128: 9802         	ldr	r0, [sp, #0x8]
700ab12a: 9000         	str	r0, [sp]
;   if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) !=
700ab12c: 9800         	ldr	r0, [sp]
700ab12e: 6940         	ldr	r0, [r0, #0x14]
700ab130: f644 717c    	movw	r1, #0x4f7c
700ab134: f2c7 0108    	movt	r1, #0x7008
700ab138: 4288         	cmp	r0, r1
700ab13a: d114         	bne	0x700ab166 <prvTaskIsTaskSuspended+0x46> @ imm = #0x28
700ab13c: e7ff         	b	0x700ab13e <prvTaskIsTaskSuspended+0x1e> @ imm = #-0x2
;     if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) ==
700ab13e: 9800         	ldr	r0, [sp]
700ab140: 6a80         	ldr	r0, [r0, #0x28]
700ab142: f644 7168    	movw	r1, #0x4f68
700ab146: f2c7 0108    	movt	r1, #0x7008
700ab14a: 4288         	cmp	r0, r1
700ab14c: d009         	beq	0x700ab162 <prvTaskIsTaskSuspended+0x42> @ imm = #0x12
700ab14e: e7ff         	b	0x700ab150 <prvTaskIsTaskSuspended+0x30> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(NULL, &(pxTCB->xEventListItem)) !=
700ab150: 9800         	ldr	r0, [sp]
700ab152: 6a80         	ldr	r0, [r0, #0x28]
700ab154: b918         	cbnz	r0, 0x700ab15e <prvTaskIsTaskSuspended+0x3e> @ imm = #0x6
700ab156: e7ff         	b	0x700ab158 <prvTaskIsTaskSuspended+0x38> @ imm = #-0x2
700ab158: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700ab15a: 9001         	str	r0, [sp, #0x4]
;       } else {
700ab15c: e000         	b	0x700ab160 <prvTaskIsTaskSuspended+0x40> @ imm = #0x0
700ab15e: e7ff         	b	0x700ab160 <prvTaskIsTaskSuspended+0x40> @ imm = #-0x2
;     } else {
700ab160: e000         	b	0x700ab164 <prvTaskIsTaskSuspended+0x44> @ imm = #0x0
700ab162: e7ff         	b	0x700ab164 <prvTaskIsTaskSuspended+0x44> @ imm = #-0x2
;   } else {
700ab164: e000         	b	0x700ab168 <prvTaskIsTaskSuspended+0x48> @ imm = #0x0
700ab166: e7ff         	b	0x700ab168 <prvTaskIsTaskSuspended+0x48> @ imm = #-0x2
;   return xReturn;
700ab168: 9801         	ldr	r0, [sp, #0x4]
700ab16a: b003         	add	sp, #0xc
700ab16c: 4770         	bx	lr
700ab16e: 0000         	movs	r0, r0

700ab170 <Sciclient_rmPsSetInp>:
; {
700ab170: b082         	sub	sp, #0x8
700ab172: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ab176: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ab17a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab17c: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ab17e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ab182: f241 0158    	movw	r1, #0x1058
700ab186: f2c7 0108    	movt	r1, #0x7008
700ab18a: 8c89         	ldrh	r1, [r1, #0x24]
700ab18c: 4288         	cmp	r0, r1
700ab18e: da0e         	bge	0x700ab1ae <Sciclient_rmPsSetInp+0x3e> @ imm = #0x1c
700ab190: e7ff         	b	0x700ab192 <Sciclient_rmPsSetInp+0x22> @ imm = #-0x2
;         gPstack.ps[index].inp = inp;
700ab192: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ab196: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ab19a: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ab19e: f241 0158    	movw	r1, #0x1058
700ab1a2: f2c7 0108    	movt	r1, #0x7008
700ab1a6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab1aa: 80c8         	strh	r0, [r1, #0x6]
;     } else {
700ab1ac: e003         	b	0x700ab1b6 <Sciclient_rmPsSetInp+0x46> @ imm = #0x6
700ab1ae: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab1b2: 9000         	str	r0, [sp]
700ab1b4: e7ff         	b	0x700ab1b6 <Sciclient_rmPsSetInp+0x46> @ imm = #-0x2
;     return r;
700ab1b6: 9800         	ldr	r0, [sp]
700ab1b8: b002         	add	sp, #0x8
700ab1ba: 4770         	bx	lr
700ab1bc: 0000         	movs	r0, r0
700ab1be: 0000         	movs	r0, r0

700ab1c0 <Sciclient_rmPsSetOutp>:
; {
700ab1c0: b082         	sub	sp, #0x8
700ab1c2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ab1c6: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ab1ca: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab1cc: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ab1ce: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ab1d2: f241 0158    	movw	r1, #0x1058
700ab1d6: f2c7 0108    	movt	r1, #0x7008
700ab1da: 8c89         	ldrh	r1, [r1, #0x24]
700ab1dc: 4288         	cmp	r0, r1
700ab1de: da0e         	bge	0x700ab1fe <Sciclient_rmPsSetOutp+0x3e> @ imm = #0x1c
700ab1e0: e7ff         	b	0x700ab1e2 <Sciclient_rmPsSetOutp+0x22> @ imm = #-0x2
;         gPstack.ps[index].outp = outp;
700ab1e2: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ab1e6: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ab1ea: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ab1ee: f241 0158    	movw	r1, #0x1058
700ab1f2: f2c7 0108    	movt	r1, #0x7008
700ab1f6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab1fa: 8108         	strh	r0, [r1, #0x8]
;     } else {
700ab1fc: e003         	b	0x700ab206 <Sciclient_rmPsSetOutp+0x46> @ imm = #0x6
700ab1fe: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab202: 9000         	str	r0, [sp]
700ab204: e7ff         	b	0x700ab206 <Sciclient_rmPsSetOutp+0x46> @ imm = #-0x2
;     return r;
700ab206: 9800         	ldr	r0, [sp]
700ab208: b002         	add	sp, #0x8
700ab20a: 4770         	bx	lr
700ab20c: 0000         	movs	r0, r0
700ab20e: 0000         	movs	r0, r0

700ab210 <Udma_eventGetId>:
; {
700ab210: b084         	sub	sp, #0x10
700ab212: 9003         	str	r0, [sp, #0xc]
700ab214: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            evtNum = UDMA_EVENT_INVALID;
700ab218: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandleInt eventHandleInt = (Udma_EventHandleInt) eventHandle;
700ab21a: 9803         	ldr	r0, [sp, #0xc]
700ab21c: 9000         	str	r0, [sp]
;     if((NULL_PTR != eventHandleInt) &&
700ab21e: 9800         	ldr	r0, [sp]
700ab220: b1c8         	cbz	r0, 0x700ab256 <Udma_eventGetId+0x46> @ imm = #0x32
700ab222: e7ff         	b	0x700ab224 <Udma_eventGetId+0x14> @ imm = #-0x2
;        (UDMA_INIT_DONE == eventHandleInt->eventInitDone))
700ab224: 9800         	ldr	r0, [sp]
700ab226: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700ab22a: f64a 31cd    	movw	r1, #0xabcd
700ab22e: f6ca 31dc    	movt	r1, #0xabdc
;     if((NULL_PTR != eventHandleInt) &&
700ab232: 4288         	cmp	r0, r1
700ab234: d10f         	bne	0x700ab256 <Udma_eventGetId+0x46> @ imm = #0x1e
700ab236: e7ff         	b	0x700ab238 <Udma_eventGetId+0x28> @ imm = #-0x2
;         drvHandle = eventHandleInt->drvHandle;
700ab238: 9800         	ldr	r0, [sp]
700ab23a: 6800         	ldr	r0, [r0]
700ab23c: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != drvHandle)
700ab23e: 9801         	ldr	r0, [sp, #0x4]
700ab240: b140         	cbz	r0, 0x700ab254 <Udma_eventGetId+0x44> @ imm = #0x10
700ab242: e7ff         	b	0x700ab244 <Udma_eventGetId+0x34> @ imm = #-0x2
;             evtNum = drvHandle->iaGemOffset + eventHandleInt->globalEvent;
700ab244: 9801         	ldr	r0, [sp, #0x4]
700ab246: f8d0 0118    	ldr.w	r0, [r0, #0x118]
700ab24a: 9900         	ldr	r1, [sp]
700ab24c: 6c89         	ldr	r1, [r1, #0x48]
700ab24e: 4408         	add	r0, r1
700ab250: 9002         	str	r0, [sp, #0x8]
;         }
700ab252: e7ff         	b	0x700ab254 <Udma_eventGetId+0x44> @ imm = #-0x2
;     }
700ab254: e7ff         	b	0x700ab256 <Udma_eventGetId+0x46> @ imm = #-0x2
;     return (evtNum);
700ab256: 9802         	ldr	r0, [sp, #0x8]
700ab258: b004         	add	sp, #0x10
700ab25a: 4770         	bx	lr
700ab25c: 0000         	movs	r0, r0
700ab25e: 0000         	movs	r0, r0

700ab260 <CSL_pktdmaGetRxRT>:
; {
700ab260: b580         	push	{r7, lr}
700ab262: b084         	sub	sp, #0x10
700ab264: 9003         	str	r0, [sp, #0xc]
700ab266: 9102         	str	r1, [sp, #0x8]
700ab268: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700ab26a: 9803         	ldr	r0, [sp, #0xc]
700ab26c: 6940         	ldr	r0, [r0, #0x14]
700ab26e: 9902         	ldr	r1, [sp, #0x8]
700ab270: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab274: f002 fb7c    	bl	0x700ad970 <CSL_REG32_RD_RAW> @ imm = #0x26f8
700ab278: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_EN );
700ab27a: 9800         	ldr	r0, [sp]
700ab27c: 0fc0         	lsrs	r0, r0, #0x1f
700ab27e: 9901         	ldr	r1, [sp, #0x4]
700ab280: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_TDOWN );
700ab282: 9800         	ldr	r0, [sp]
700ab284: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ab288: 9901         	ldr	r1, [sp, #0x4]
700ab28a: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ab28c: 9901         	ldr	r1, [sp, #0x4]
700ab28e: 2000         	movs	r0, #0x0
700ab290: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_PAUSE );
700ab292: 9900         	ldr	r1, [sp]
700ab294: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ab298: 9a01         	ldr	r2, [sp, #0x4]
700ab29a: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_ERROR );
700ab29c: 9900         	ldr	r1, [sp]
700ab29e: f001 0101    	and	r1, r1, #0x1
700ab2a2: 9a01         	ldr	r2, [sp, #0x4]
700ab2a4: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ab2a6: b004         	add	sp, #0x10
700ab2a8: bd80         	pop	{r7, pc}
700ab2aa: 0000         	movs	r0, r0
700ab2ac: 0000         	movs	r0, r0
700ab2ae: 0000         	movs	r0, r0

700ab2b0 <CSL_pktdmaGetTxRT>:
; {
700ab2b0: b580         	push	{r7, lr}
700ab2b2: b084         	sub	sp, #0x10
700ab2b4: 9003         	str	r0, [sp, #0xc]
700ab2b6: 9102         	str	r1, [sp, #0x8]
700ab2b8: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700ab2ba: 9803         	ldr	r0, [sp, #0xc]
700ab2bc: 6900         	ldr	r0, [r0, #0x10]
700ab2be: 9902         	ldr	r1, [sp, #0x8]
700ab2c0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab2c4: f002 fb54    	bl	0x700ad970 <CSL_REG32_RD_RAW> @ imm = #0x26a8
700ab2c8: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_EN );
700ab2ca: 9800         	ldr	r0, [sp]
700ab2cc: 0fc0         	lsrs	r0, r0, #0x1f
700ab2ce: 9901         	ldr	r1, [sp, #0x4]
700ab2d0: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_TDOWN );
700ab2d2: 9800         	ldr	r0, [sp]
700ab2d4: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ab2d8: 9901         	ldr	r1, [sp, #0x4]
700ab2da: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ab2dc: 9901         	ldr	r1, [sp, #0x4]
700ab2de: 2000         	movs	r0, #0x0
700ab2e0: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_PAUSE );
700ab2e2: 9900         	ldr	r1, [sp]
700ab2e4: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ab2e8: 9a01         	ldr	r2, [sp, #0x4]
700ab2ea: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_ERROR );
700ab2ec: 9900         	ldr	r1, [sp]
700ab2ee: f001 0101    	and	r1, r1, #0x1
700ab2f2: 9a01         	ldr	r2, [sp, #0x4]
700ab2f4: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ab2f6: b004         	add	sp, #0x10
700ab2f8: bd80         	pop	{r7, pc}
700ab2fa: 0000         	movs	r0, r0
700ab2fc: 0000         	movs	r0, r0
700ab2fe: 0000         	movs	r0, r0

700ab300 <Sciclient_getDevId>:
; {
700ab300: b083         	sub	sp, #0xc
700ab302: 9002         	str	r0, [sp, #0x8]
700ab304: f04f 30ff    	mov.w	r0, #0xffffffff
;     uint32_t retVal = UINT32_MAX;
700ab308: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700ab30a: 9802         	ldr	r0, [sp, #0x8]
700ab30c: 9000         	str	r0, [sp]
700ab30e: 2805         	cmp	r0, #0x5
700ab310: d817         	bhi	0x700ab342 <Sciclient_getDevId+0x42> @ imm = #0x2e
700ab312: 9900         	ldr	r1, [sp]
700ab314: e8df f001    	tbb	[pc, r1]
700ab318: 03 06 09 0c  	.word	0x0c090603
700ab31c: 0f 12        	.short	0x120f
700ab31e: 2009         	movs	r0, #0x9
;         retVal = TISCI_DEV_MCU_M4FSS0_CORE0;
700ab320: 9001         	str	r0, [sp, #0x4]
;         break;
700ab322: e00f         	b	0x700ab344 <Sciclient_getDevId+0x44> @ imm = #0x1e
700ab324: 2079         	movs	r0, #0x79
;         retVal = TISCI_DEV_R5FSS0_CORE0;
700ab326: 9001         	str	r0, [sp, #0x4]
;         break;
700ab328: e00c         	b	0x700ab344 <Sciclient_getDevId+0x44> @ imm = #0x18
700ab32a: 207a         	movs	r0, #0x7a
;         retVal = TISCI_DEV_R5FSS0_CORE1;
700ab32c: 9001         	str	r0, [sp, #0x4]
;         break;
700ab32e: e009         	b	0x700ab344 <Sciclient_getDevId+0x44> @ imm = #0x12
700ab330: 207b         	movs	r0, #0x7b
;         retVal = TISCI_DEV_R5FSS1_CORE0;
700ab332: 9001         	str	r0, [sp, #0x4]
;         break;
700ab334: e006         	b	0x700ab344 <Sciclient_getDevId+0x44> @ imm = #0xc
700ab336: 207c         	movs	r0, #0x7c
;         retVal = TISCI_DEV_R5FSS1_CORE1;
700ab338: 9001         	str	r0, [sp, #0x4]
;         break;
700ab33a: e003         	b	0x700ab344 <Sciclient_getDevId+0x44> @ imm = #0x6
700ab33c: 2087         	movs	r0, #0x87
;         retVal = TISCI_DEV_A53SS0_CORE_0;
700ab33e: 9001         	str	r0, [sp, #0x4]
;         break;
700ab340: e000         	b	0x700ab344 <Sciclient_getDevId+0x44> @ imm = #0x0
;         break;
700ab342: e7ff         	b	0x700ab344 <Sciclient_getDevId+0x44> @ imm = #-0x2
;     return retVal;
700ab344: 9801         	ldr	r0, [sp, #0x4]
700ab346: b003         	add	sp, #0xc
700ab348: 4770         	bx	lr
700ab34a: 0000         	movs	r0, r0
700ab34c: 0000         	movs	r0, r0
700ab34e: 0000         	movs	r0, r0

700ab350 <UART_getIntrIdentityStatus>:
; {
700ab350: b580         	push	{r7, lr}
700ab352: b084         	sub	sp, #0x10
700ab354: 9003         	str	r0, [sp, #0xc]
700ab356: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ab358: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ab35a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ab35c: 9803         	ldr	r0, [sp, #0xc]
700ab35e: 300c         	adds	r0, #0xc
700ab360: f002 faae    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x255c
700ab364: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ab366: 9803         	ldr	r0, [sp, #0xc]
700ab368: 300c         	adds	r0, #0xc
700ab36a: 9000         	str	r0, [sp]
700ab36c: f002 faa8    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x2550
700ab370: 4601         	mov	r1, r0
700ab372: 9800         	ldr	r0, [sp]
700ab374: f001 017f    	and	r1, r1, #0x7f
700ab378: f002 faaa    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x2554
;     retVal = HW_RD_REG32(baseAddr + UART_IIR) & UART_IIR_IT_TYPE_MASK;
700ab37c: 9803         	ldr	r0, [sp, #0xc]
700ab37e: 3008         	adds	r0, #0x8
700ab380: f002 fa9e    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x253c
700ab384: f000 003e    	and	r0, r0, #0x3e
700ab388: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ab38a: 9803         	ldr	r0, [sp, #0xc]
700ab38c: 300c         	adds	r0, #0xc
700ab38e: 9902         	ldr	r1, [sp, #0x8]
700ab390: f002 fa9e    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x253c
;     return retVal;
700ab394: 9801         	ldr	r0, [sp, #0x4]
700ab396: b004         	add	sp, #0x10
700ab398: bd80         	pop	{r7, pc}
700ab39a: 0000         	movs	r0, r0
700ab39c: 0000         	movs	r0, r0
700ab39e: 0000         	movs	r0, r0

700ab3a0 <UART_lineCharConfig>:
; {
700ab3a0: b580         	push	{r7, lr}
700ab3a2: b084         	sub	sp, #0x10
700ab3a4: 9003         	str	r0, [sp, #0xc]
700ab3a6: 9102         	str	r1, [sp, #0x8]
700ab3a8: 9201         	str	r2, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ab3aa: 9803         	ldr	r0, [sp, #0xc]
700ab3ac: 300c         	adds	r0, #0xc
700ab3ae: f002 fa87    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x250e
700ab3b2: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_NB_STOP_MASK | (uint32_t) UART_LCR_CHAR_LENGTH_MASK);
700ab3b4: 9800         	ldr	r0, [sp]
700ab3b6: f020 0007    	bic	r0, r0, #0x7
700ab3ba: 9000         	str	r0, [sp]
;     lcrRegValue |= wLenStbFlag & (UART_LCR_NB_STOP_MASK |
700ab3bc: 9802         	ldr	r0, [sp, #0x8]
700ab3be: f000 0107    	and	r1, r0, #0x7
700ab3c2: 9800         	ldr	r0, [sp]
700ab3c4: 4308         	orrs	r0, r1
700ab3c6: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_PARITY_TYPE2_MASK |
700ab3c8: 9800         	ldr	r0, [sp]
700ab3ca: f020 0038    	bic	r0, r0, #0x38
700ab3ce: 9000         	str	r0, [sp]
;     lcrRegValue |= parityFlag & (UART_LCR_PARITY_TYPE2_MASK |
700ab3d0: 9801         	ldr	r0, [sp, #0x4]
700ab3d2: f000 0138    	and	r1, r0, #0x38
700ab3d6: 9800         	ldr	r0, [sp]
700ab3d8: 4308         	orrs	r0, r1
700ab3da: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ab3dc: 9803         	ldr	r0, [sp, #0xc]
700ab3de: 300c         	adds	r0, #0xc
700ab3e0: 9900         	ldr	r1, [sp]
700ab3e2: f002 fa75    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x24ea
; }
700ab3e6: b004         	add	sp, #0x10
700ab3e8: bd80         	pop	{r7, pc}
700ab3ea: 0000         	movs	r0, r0
700ab3ec: 0000         	movs	r0, r0
700ab3ee: 0000         	movs	r0, r0

700ab3f0 <UART_lld_dmaInit>:
; {
700ab3f0: b580         	push	{r7, lr}
700ab3f2: b084         	sub	sp, #0x10
700ab3f4: 9003         	str	r0, [sp, #0xc]
700ab3f6: 9102         	str	r1, [sp, #0x8]
700ab3f8: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ab3fa: 9001         	str	r0, [sp, #0x4]
;     UART_UdmaChConfig *udmaChCfg = (UART_UdmaChConfig *)dmaChCfg;
700ab3fc: 9802         	ldr	r0, [sp, #0x8]
700ab3fe: 9000         	str	r0, [sp]
;     status  = UART_udmaInitRxCh(hUart, udmaChCfg);
700ab400: 9803         	ldr	r0, [sp, #0xc]
700ab402: 9900         	ldr	r1, [sp]
700ab404: f7f7 f914    	bl	0x700a2630 <UART_udmaInitRxCh> @ imm = #-0x8dd8
700ab408: 9001         	str	r0, [sp, #0x4]
;     status += UART_udmaInitTxCh(hUart, udmaChCfg);
700ab40a: 9803         	ldr	r0, [sp, #0xc]
700ab40c: 9900         	ldr	r1, [sp]
700ab40e: f7f7 f99f    	bl	0x700a2750 <UART_udmaInitTxCh> @ imm = #-0x8cc2
700ab412: 4601         	mov	r1, r0
700ab414: 9801         	ldr	r0, [sp, #0x4]
700ab416: 4408         	add	r0, r1
700ab418: 9001         	str	r0, [sp, #0x4]
;     if (status == UDMA_SOK)
700ab41a: 9801         	ldr	r0, [sp, #0x4]
700ab41c: b930         	cbnz	r0, 0x700ab42c <UART_lld_dmaInit+0x3c> @ imm = #0xc
700ab41e: e7ff         	b	0x700ab420 <UART_lld_dmaInit+0x30> @ imm = #-0x2
;         udmaChCfg->isOpen = TRUE;
700ab420: 9900         	ldr	r1, [sp]
700ab422: 2001         	movs	r0, #0x1
700ab424: 6388         	str	r0, [r1, #0x38]
700ab426: 2000         	movs	r0, #0x0
;         status = UART_TRANSFER_STATUS_SUCCESS;
700ab428: 9001         	str	r0, [sp, #0x4]
;     }
700ab42a: e003         	b	0x700ab434 <UART_lld_dmaInit+0x44> @ imm = #0x6
700ab42c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ab430: 9001         	str	r0, [sp, #0x4]
700ab432: e7ff         	b	0x700ab434 <UART_lld_dmaInit+0x44> @ imm = #-0x2
;     return status;
700ab434: 9801         	ldr	r0, [sp, #0x4]
700ab436: b004         	add	sp, #0x10
700ab438: bd80         	pop	{r7, pc}
700ab43a: 0000         	movs	r0, r0
700ab43c: 0000         	movs	r0, r0
700ab43e: 0000         	movs	r0, r0

700ab440 <xQueueGenericCreateStatic>:
;     {
700ab440: b580         	push	{r7, lr}
700ab442: b088         	sub	sp, #0x20
700ab444: 4684         	mov	r12, r0
700ab446: 980a         	ldr	r0, [sp, #0x28]
700ab448: f8cd c01c    	str.w	r12, [sp, #0x1c]
700ab44c: 9106         	str	r1, [sp, #0x18]
700ab44e: 9205         	str	r2, [sp, #0x14]
700ab450: 9304         	str	r3, [sp, #0x10]
700ab452: f88d 000f    	strb.w	r0, [sp, #0xf]
;         pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
700ab456: 9804         	ldr	r0, [sp, #0x10]
700ab458: 9002         	str	r0, [sp, #0x8]
;         if( pxNewQueue != NULL )
700ab45a: 9802         	ldr	r0, [sp, #0x8]
700ab45c: b188         	cbz	r0, 0x700ab482 <xQueueGenericCreateStatic+0x42> @ imm = #0x22
700ab45e: e7ff         	b	0x700ab460 <xQueueGenericCreateStatic+0x20> @ imm = #-0x2
;                     pxNewQueue->ucStaticallyAllocated = pdTRUE;
700ab460: 9902         	ldr	r1, [sp, #0x8]
700ab462: 2001         	movs	r0, #0x1
700ab464: f881 0046    	strb.w	r0, [r1, #0x46]
;             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
700ab468: 9807         	ldr	r0, [sp, #0x1c]
700ab46a: 9906         	ldr	r1, [sp, #0x18]
700ab46c: 9a05         	ldr	r2, [sp, #0x14]
700ab46e: f89d 300f    	ldrb.w	r3, [sp, #0xf]
700ab472: f8dd c008    	ldr.w	r12, [sp, #0x8]
700ab476: 46ee         	mov	lr, sp
700ab478: f8ce c000    	str.w	r12, [lr]
700ab47c: f000 f830    	bl	0x700ab4e0 <prvInitialiseNewQueue> @ imm = #0x60
;         }
700ab480: e000         	b	0x700ab484 <xQueueGenericCreateStatic+0x44> @ imm = #0x0
700ab482: e7ff         	b	0x700ab484 <xQueueGenericCreateStatic+0x44> @ imm = #-0x2
;         return pxNewQueue;
700ab484: 9802         	ldr	r0, [sp, #0x8]
700ab486: b008         	add	sp, #0x20
700ab488: bd80         	pop	{r7, pc}
700ab48a: 0000         	movs	r0, r0
700ab48c: 0000         	movs	r0, r0
700ab48e: 0000         	movs	r0, r0

700ab490 <UART_resetModule>:
; {
700ab490: b580         	push	{r7, lr}
700ab492: b082         	sub	sp, #0x8
700ab494: 9001         	str	r0, [sp, #0x4]
;     (void)UART_enhanFuncEnable(hUart->baseAddr);
700ab496: 9801         	ldr	r0, [sp, #0x4]
700ab498: 6800         	ldr	r0, [r0]
700ab49a: f000 fd41    	bl	0x700abf20 <UART_enhanFuncEnable> @ imm = #0xa82
;     UART_regConfModeRestore(hUart->baseAddr, 0x00U);
700ab49e: 9801         	ldr	r0, [sp, #0x4]
700ab4a0: 6800         	ldr	r0, [r0]
700ab4a2: 2100         	movs	r1, #0x0
700ab4a4: f002 f8d4    	bl	0x700ad650 <UART_regConfModeRestore> @ imm = #0x21a8
;     UART_modemControlReset(hUart->baseAddr);
700ab4a8: 9801         	ldr	r0, [sp, #0x4]
700ab4aa: 6800         	ldr	r0, [r0]
700ab4ac: f001 fff8    	bl	0x700ad4a0 <UART_modemControlReset> @ imm = #0x1ff0
;     UART_intrDisable(hUart->baseAddr, 0xFFU);
700ab4b0: 9801         	ldr	r0, [sp, #0x4]
700ab4b2: 6800         	ldr	r0, [r0]
700ab4b4: 21ff         	movs	r1, #0xff
700ab4b6: f7f9 f82b    	bl	0x700a4510 <UART_intrDisable> @ imm = #-0x6faa
;     UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700ab4ba: 9801         	ldr	r0, [sp, #0x4]
700ab4bc: 6800         	ldr	r0, [r0]
700ab4be: 2102         	movs	r1, #0x2
700ab4c0: f001 fb5e    	bl	0x700acb80 <UART_intr2Disable> @ imm = #0x16bc
;     (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700ab4c4: 9801         	ldr	r0, [sp, #0x4]
700ab4c6: 6800         	ldr	r0, [r0]
700ab4c8: 2107         	movs	r1, #0x7
700ab4ca: f001 fba1    	bl	0x700acc10 <UART_operatingModeSelect> @ imm = #0x1742
;     UART_moduleReset(hUart);
700ab4ce: 9801         	ldr	r0, [sp, #0x4]
700ab4d0: f7fd f9e6    	bl	0x700a88a0 <UART_moduleReset> @ imm = #-0x2c34
;     return;
700ab4d4: b002         	add	sp, #0x8
700ab4d6: bd80         	pop	{r7, pc}
		...

700ab4e0 <prvInitialiseNewQueue>:
; {
700ab4e0: b580         	push	{r7, lr}
700ab4e2: b084         	sub	sp, #0x10
700ab4e4: f8dd c018    	ldr.w	r12, [sp, #0x18]
700ab4e8: 9003         	str	r0, [sp, #0xc]
700ab4ea: 9102         	str	r1, [sp, #0x8]
700ab4ec: 9201         	str	r2, [sp, #0x4]
700ab4ee: f88d 3003    	strb.w	r3, [sp, #0x3]
;     if( uxItemSize == ( UBaseType_t ) 0 )
700ab4f2: 9802         	ldr	r0, [sp, #0x8]
700ab4f4: b918         	cbnz	r0, 0x700ab4fe <prvInitialiseNewQueue+0x1e> @ imm = #0x6
700ab4f6: e7ff         	b	0x700ab4f8 <prvInitialiseNewQueue+0x18> @ imm = #-0x2
;         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
700ab4f8: 9806         	ldr	r0, [sp, #0x18]
700ab4fa: 6000         	str	r0, [r0]
;     }
700ab4fc: e003         	b	0x700ab506 <prvInitialiseNewQueue+0x26> @ imm = #0x6
;         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
700ab4fe: 9801         	ldr	r0, [sp, #0x4]
700ab500: 9906         	ldr	r1, [sp, #0x18]
700ab502: 6008         	str	r0, [r1]
700ab504: e7ff         	b	0x700ab506 <prvInitialiseNewQueue+0x26> @ imm = #-0x2
;     pxNewQueue->uxLength = uxQueueLength;
700ab506: 9803         	ldr	r0, [sp, #0xc]
700ab508: 9906         	ldr	r1, [sp, #0x18]
700ab50a: 63c8         	str	r0, [r1, #0x3c]
;     pxNewQueue->uxItemSize = uxItemSize;
700ab50c: 9802         	ldr	r0, [sp, #0x8]
700ab50e: 9906         	ldr	r1, [sp, #0x18]
700ab510: 6408         	str	r0, [r1, #0x40]
;     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
700ab512: 9806         	ldr	r0, [sp, #0x18]
700ab514: 2101         	movs	r1, #0x1
700ab516: f7fc fe1b    	bl	0x700a8150 <xQueueGenericReset> @ imm = #-0x33ca
;             pxNewQueue->ucQueueType = ucQueueType;
700ab51a: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab51e: 9906         	ldr	r1, [sp, #0x18]
700ab520: f881 004c    	strb.w	r0, [r1, #0x4c]
; }
700ab524: b004         	add	sp, #0x10
700ab526: bd80         	pop	{r7, pc}
		...

700ab530 <uxListRemove>:
; {
700ab530: b082         	sub	sp, #0x8
700ab532: 9001         	str	r0, [sp, #0x4]
;     List_t * const pxList = pxItemToRemove->pxContainer;
700ab534: 9801         	ldr	r0, [sp, #0x4]
700ab536: 6900         	ldr	r0, [r0, #0x10]
700ab538: 9000         	str	r0, [sp]
;     pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
700ab53a: 9801         	ldr	r0, [sp, #0x4]
700ab53c: 6841         	ldr	r1, [r0, #0x4]
700ab53e: 6880         	ldr	r0, [r0, #0x8]
700ab540: 6088         	str	r0, [r1, #0x8]
;     pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
700ab542: 9901         	ldr	r1, [sp, #0x4]
700ab544: 6848         	ldr	r0, [r1, #0x4]
700ab546: 6889         	ldr	r1, [r1, #0x8]
700ab548: 6048         	str	r0, [r1, #0x4]
;     if( pxList->pxIndex == pxItemToRemove )
700ab54a: 9800         	ldr	r0, [sp]
700ab54c: 6840         	ldr	r0, [r0, #0x4]
700ab54e: 9901         	ldr	r1, [sp, #0x4]
700ab550: 4288         	cmp	r0, r1
700ab552: d105         	bne	0x700ab560 <uxListRemove+0x30> @ imm = #0xa
700ab554: e7ff         	b	0x700ab556 <uxListRemove+0x26> @ imm = #-0x2
;         pxList->pxIndex = pxItemToRemove->pxPrevious;
700ab556: 9801         	ldr	r0, [sp, #0x4]
700ab558: 6880         	ldr	r0, [r0, #0x8]
700ab55a: 9900         	ldr	r1, [sp]
700ab55c: 6048         	str	r0, [r1, #0x4]
;     }
700ab55e: e000         	b	0x700ab562 <uxListRemove+0x32> @ imm = #0x0
700ab560: e7ff         	b	0x700ab562 <uxListRemove+0x32> @ imm = #-0x2
;     pxItemToRemove->pxContainer = NULL;
700ab562: 9901         	ldr	r1, [sp, #0x4]
700ab564: 2000         	movs	r0, #0x0
700ab566: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )--;
700ab568: 9900         	ldr	r1, [sp]
700ab56a: 6808         	ldr	r0, [r1]
700ab56c: 3801         	subs	r0, #0x1
700ab56e: 6008         	str	r0, [r1]
;     return pxList->uxNumberOfItems;
700ab570: 9800         	ldr	r0, [sp]
700ab572: 6800         	ldr	r0, [r0]
700ab574: b002         	add	sp, #0x8
700ab576: 4770         	bx	lr
		...

700ab580 <CSL_bcdmaTeardownRxChan>:
; {
700ab580: b580         	push	{r7, lr}
700ab582: b086         	sub	sp, #0x18
700ab584: 9005         	str	r0, [sp, #0x14]
700ab586: 9104         	str	r1, [sp, #0x10]
700ab588: f88d 200f    	strb.w	r2, [sp, #0xf]
700ab58c: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ab590: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ab594: f000 0001    	and	r0, r0, #0x1
700ab598: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ab59a: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ab59e: f000 0001    	and	r0, r0, #0x1
700ab5a2: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ab5a4: 9805         	ldr	r0, [sp, #0x14]
700ab5a6: 9a04         	ldr	r2, [sp, #0x10]
700ab5a8: 2105         	movs	r1, #0x5
700ab5aa: 466b         	mov	r3, sp
700ab5ac: f7fd fcb8    	bl	0x700a8f20 <CSL_bcdmaDoChanOp> @ imm = #-0x2690
700ab5b0: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ab5b2: 9802         	ldr	r0, [sp, #0x8]
700ab5b4: b120         	cbz	r0, 0x700ab5c0 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #0x8
700ab5b6: e7ff         	b	0x700ab5b8 <CSL_bcdmaTeardownRxChan+0x38> @ imm = #-0x2
700ab5b8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ab5bc: 9002         	str	r0, [sp, #0x8]
;     }
700ab5be: e7ff         	b	0x700ab5c0 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #-0x2
;     return retVal;
700ab5c0: 9802         	ldr	r0, [sp, #0x8]
700ab5c2: b006         	add	sp, #0x18
700ab5c4: bd80         	pop	{r7, pc}
		...
700ab5ce: 0000         	movs	r0, r0

700ab5d0 <CSL_bcdmaTeardownTxChan>:
; {
700ab5d0: b580         	push	{r7, lr}
700ab5d2: b086         	sub	sp, #0x18
700ab5d4: 9005         	str	r0, [sp, #0x14]
700ab5d6: 9104         	str	r1, [sp, #0x10]
700ab5d8: f88d 200f    	strb.w	r2, [sp, #0xf]
700ab5dc: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ab5e0: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ab5e4: f000 0001    	and	r0, r0, #0x1
700ab5e8: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ab5ea: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ab5ee: f000 0001    	and	r0, r0, #0x1
700ab5f2: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ab5f4: 9805         	ldr	r0, [sp, #0x14]
700ab5f6: 9a04         	ldr	r2, [sp, #0x10]
700ab5f8: 2105         	movs	r1, #0x5
700ab5fa: 466b         	mov	r3, sp
700ab5fc: f7fd fc90    	bl	0x700a8f20 <CSL_bcdmaDoChanOp> @ imm = #-0x26e0
700ab600: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ab602: 9802         	ldr	r0, [sp, #0x8]
700ab604: b120         	cbz	r0, 0x700ab610 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #0x8
700ab606: e7ff         	b	0x700ab608 <CSL_bcdmaTeardownTxChan+0x38> @ imm = #-0x2
700ab608: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ab60c: 9002         	str	r0, [sp, #0x8]
;     }
700ab60e: e7ff         	b	0x700ab610 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #-0x2
;     return retVal;
700ab610: 9802         	ldr	r0, [sp, #0x8]
700ab612: b006         	add	sp, #0x18
700ab614: bd80         	pop	{r7, pc}
		...
700ab61e: 0000         	movs	r0, r0

700ab620 <DebugP_uartLogWriterPutChar>:
; {
700ab620: b580         	push	{r7, lr}
700ab622: b088         	sub	sp, #0x20
700ab624: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     char value = character;
700ab628: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700ab62c: f88d 001e    	strb.w	r0, [sp, #0x1e]
;     UART_Handle uartHandle = UART_getHandle(gDebugP_uartDrvIndex);
700ab630: f240 40c4    	movw	r0, #0x4c4
700ab634: f2c7 000b    	movt	r0, #0x700b
700ab638: 6800         	ldr	r0, [r0]
700ab63a: f7ff fd49    	bl	0x700ab0d0 <UART_getHandle> @ imm = #-0x56e
700ab63e: 9006         	str	r0, [sp, #0x18]
;     if(uartHandle!=NULL)
700ab640: 9806         	ldr	r0, [sp, #0x18]
700ab642: b170         	cbz	r0, 0x700ab662 <DebugP_uartLogWriterPutChar+0x42> @ imm = #0x1c
700ab644: e7ff         	b	0x700ab646 <DebugP_uartLogWriterPutChar+0x26> @ imm = #-0x2
700ab646: a801         	add	r0, sp, #0x4
;         UART_Transaction_init(&trans);
700ab648: 9000         	str	r0, [sp]
700ab64a: f001 fa81    	bl	0x700acb50 <UART_Transaction_init> @ imm = #0x1502
700ab64e: 9900         	ldr	r1, [sp]
700ab650: f10d 001e    	add.w	r0, sp, #0x1e
;         trans.buf   = &value;
700ab654: 9001         	str	r0, [sp, #0x4]
700ab656: 2001         	movs	r0, #0x1
;         trans.count = 1;
700ab658: 9002         	str	r0, [sp, #0x8]
;         (void) UART_write(uartHandle, &trans);
700ab65a: 9806         	ldr	r0, [sp, #0x18]
700ab65c: f7f3 f878    	bl	0x7009e750 <UART_write> @ imm = #-0xcf10
;     }
700ab660: e7ff         	b	0x700ab662 <DebugP_uartLogWriterPutChar+0x42> @ imm = #-0x2
; }
700ab662: b008         	add	sp, #0x20
700ab664: bd80         	pop	{r7, pc}
		...
700ab66e: 0000         	movs	r0, r0

700ab670 <Dpl_init>:
; {
700ab670: b510         	push	{r4, lr}
;     HwiP_init();
700ab672: f002 fc45    	bl	0x700adf00 <HwiP_init>  @ imm = #0x288a
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_ERROR);
700ab676: 2002         	movs	r0, #0x2
700ab678: f001 f97a    	bl	0x700ac970 <DebugP_logZoneEnable> @ imm = #0x12f4
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_WARN);
700ab67c: 2004         	movs	r0, #0x4
700ab67e: f001 f977    	bl	0x700ac970 <DebugP_logZoneEnable> @ imm = #0x12ee
;     DebugP_memLogWriterInit(CSL_CORE_ID_R5FSS0_0);
700ab682: 2001         	movs	r0, #0x1
700ab684: f001 fd8c    	bl	0x700ad1a0 <DebugP_memLogWriterInit> @ imm = #0x1b18
;     DebugP_uartSetDrvIndex(CONFIG_UART_CONSOLE);
700ab688: 2000         	movs	r0, #0x0
700ab68a: 2400         	movs	r4, #0x0
700ab68c: f002 f810    	bl	0x700ad6b0 <DebugP_uartSetDrvIndex> @ imm = #0x2020
;     SOC_controlModuleUnlockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ab690: 2000         	movs	r0, #0x0
700ab692: 2102         	movs	r1, #0x2
700ab694: f7fb fb4c    	bl	0x700a6d30 <SOC_controlModuleUnlockMMR> @ imm = #-0x4968
700ab698: f248 10d0    	movw	r0, #0x81d0
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ab69c: 2102         	movs	r1, #0x2
700ab69e: f2c4 3000    	movt	r0, #0x4300
;     *(volatile uint32_t*)(TIMER8_CLOCK_SRC_MUX_ADDR) = TIMER8_CLOCK_SRC_MCU_HFOSC0;
700ab6a2: 6004         	str	r4, [r0]
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ab6a4: 2000         	movs	r0, #0x0
700ab6a6: f7fc fe2b    	bl	0x700a8300 <SOC_controlModuleLockMMR> @ imm = #-0x33aa
;     ClockP_init();
700ab6aa: f7f3 fb99    	bl	0x7009ede0 <ClockP_init> @ imm = #-0xc8ce
;     HwiP_enable();
700ab6ae: e8bd 4010    	pop.w	{r4, lr}
700ab6b2: f7f0 ba61    	b.w	0x7009bb78 <$Ven$TA$L$PI$$HwiP_enable> @ imm = #-0xfb3e
		...
700ab6be: 0000         	movs	r0, r0

700ab6c0 <UART_readLineStatus>:
; {
700ab6c0: b580         	push	{r7, lr}
700ab6c2: b084         	sub	sp, #0x10
700ab6c4: 9003         	str	r0, [sp, #0xc]
700ab6c6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ab6c8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ab6ca: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ab6cc: 9803         	ldr	r0, [sp, #0xc]
700ab6ce: 300c         	adds	r0, #0xc
700ab6d0: f002 f8f6    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x21ec
700ab6d4: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ab6d6: 9803         	ldr	r0, [sp, #0xc]
700ab6d8: 300c         	adds	r0, #0xc
700ab6da: 9000         	str	r0, [sp]
700ab6dc: f002 f8f0    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x21e0
700ab6e0: 4601         	mov	r1, r0
700ab6e2: 9800         	ldr	r0, [sp]
700ab6e4: f001 017f    	and	r1, r1, #0x7f
700ab6e8: f002 f8f2    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x21e4
;     retVal = HW_RD_REG32(baseAddr + UART_LSR);
700ab6ec: 9803         	ldr	r0, [sp, #0xc]
700ab6ee: 3014         	adds	r0, #0x14
700ab6f0: f002 f8e6    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x21cc
700ab6f4: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ab6f6: 9803         	ldr	r0, [sp, #0xc]
700ab6f8: 300c         	adds	r0, #0xc
700ab6fa: 9902         	ldr	r1, [sp, #0x8]
700ab6fc: f002 f8e8    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x21d0
;     return retVal;
700ab700: 9801         	ldr	r0, [sp, #0x4]
700ab702: b004         	add	sp, #0x10
700ab704: bd80         	pop	{r7, pc}
		...
700ab70e: 0000         	movs	r0, r0

700ab710 <vTaskExitCritical>:
;   if (xSchedulerRunning != pdFALSE) {
700ab710: f240 501c    	movw	r0, #0x51c
700ab714: f2c7 000b    	movt	r0, #0x700b
700ab718: 6800         	ldr	r0, [r0]
700ab71a: b1d0         	cbz	r0, 0x700ab752 <vTaskExitCritical+0x42> @ imm = #0x34
700ab71c: e7ff         	b	0x700ab71e <vTaskExitCritical+0xe> @ imm = #-0x2
;     if (pxCurrentTCB->uxCriticalNesting > 0U) {
700ab71e: f240 40dc    	movw	r0, #0x4dc
700ab722: f2c7 000b    	movt	r0, #0x700b
700ab726: 6800         	ldr	r0, [r0]
700ab728: 6d40         	ldr	r0, [r0, #0x54]
700ab72a: b180         	cbz	r0, 0x700ab74e <vTaskExitCritical+0x3e> @ imm = #0x20
700ab72c: e7ff         	b	0x700ab72e <vTaskExitCritical+0x1e> @ imm = #-0x2
;       (pxCurrentTCB->uxCriticalNesting)--;
700ab72e: f240 40dc    	movw	r0, #0x4dc
700ab732: f2c7 000b    	movt	r0, #0x700b
700ab736: 6802         	ldr	r2, [r0]
700ab738: 6d51         	ldr	r1, [r2, #0x54]
700ab73a: 3901         	subs	r1, #0x1
700ab73c: 6551         	str	r1, [r2, #0x54]
;       if (pxCurrentTCB->uxCriticalNesting == 0U) {
700ab73e: 6800         	ldr	r0, [r0]
700ab740: 6d40         	ldr	r0, [r0, #0x54]
700ab742: b910         	cbnz	r0, 0x700ab74a <vTaskExitCritical+0x3a> @ imm = #0x4
700ab744: e7ff         	b	0x700ab746 <vTaskExitCritical+0x36> @ imm = #-0x2
;     __asm__ volatile ( "CPSIE	i" ::: "cc" );
700ab746: b662         	cpsie i
;       } else {
700ab748: e000         	b	0x700ab74c <vTaskExitCritical+0x3c> @ imm = #0x0
700ab74a: e7ff         	b	0x700ab74c <vTaskExitCritical+0x3c> @ imm = #-0x2
;     } else {
700ab74c: e000         	b	0x700ab750 <vTaskExitCritical+0x40> @ imm = #0x0
700ab74e: e7ff         	b	0x700ab750 <vTaskExitCritical+0x40> @ imm = #-0x2
;   } else {
700ab750: e000         	b	0x700ab754 <vTaskExitCritical+0x44> @ imm = #0x0
700ab752: e7ff         	b	0x700ab754 <vTaskExitCritical+0x44> @ imm = #-0x2
; }
700ab754: 4770         	bx	lr
		...
700ab75e: 0000         	movs	r0, r0

700ab760 <CSL_bcdmaGetChanPeerReg>:
; {
700ab760: b580         	push	{r7, lr}
700ab762: b088         	sub	sp, #0x20
700ab764: f8dd c028    	ldr.w	r12, [sp, #0x28]
700ab768: 9007         	str	r0, [sp, #0x1c]
700ab76a: 9106         	str	r1, [sp, #0x18]
700ab76c: 9205         	str	r2, [sp, #0x14]
700ab76e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700ab770: 9804         	ldr	r0, [sp, #0x10]
700ab772: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700ab774: 9807         	ldr	r0, [sp, #0x1c]
700ab776: 9a06         	ldr	r2, [sp, #0x18]
700ab778: 210b         	movs	r1, #0xb
700ab77a: ab01         	add	r3, sp, #0x4
700ab77c: f7fd fbd0    	bl	0x700a8f20 <CSL_bcdmaDoChanOp> @ imm = #-0x2860
700ab780: 9003         	str	r0, [sp, #0xc]
;     if( retVal == CSL_PASS )
700ab782: 9803         	ldr	r0, [sp, #0xc]
700ab784: b920         	cbnz	r0, 0x700ab790 <CSL_bcdmaGetChanPeerReg+0x30> @ imm = #0x8
700ab786: e7ff         	b	0x700ab788 <CSL_bcdmaGetChanPeerReg+0x28> @ imm = #-0x2
;         *pVal = remotePeerOpts.regVal;
700ab788: 9802         	ldr	r0, [sp, #0x8]
700ab78a: 990a         	ldr	r1, [sp, #0x28]
700ab78c: 6008         	str	r0, [r1]
;     }
700ab78e: e006         	b	0x700ab79e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #0xc
;         *pVal = (uint32_t)0U;
700ab790: 990a         	ldr	r1, [sp, #0x28]
700ab792: 2000         	movs	r0, #0x0
700ab794: 6008         	str	r0, [r1]
700ab796: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ab79a: 9003         	str	r0, [sp, #0xc]
700ab79c: e7ff         	b	0x700ab79e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #-0x2
;     return retVal;
700ab79e: 9803         	ldr	r0, [sp, #0xc]
700ab7a0: b008         	add	sp, #0x20
700ab7a2: bd80         	pop	{r7, pc}
		...

700ab7b0 <_strnlen_s>:
; {
700ab7b0: b084         	sub	sp, #0x10
700ab7b2: 9003         	str	r0, [sp, #0xc]
700ab7b4: 9102         	str	r1, [sp, #0x8]
;   for (s = str; *s && maxsize--; ++s);
700ab7b6: 9803         	ldr	r0, [sp, #0xc]
700ab7b8: 9001         	str	r0, [sp, #0x4]
700ab7ba: e7ff         	b	0x700ab7bc <_strnlen_s+0xc> @ imm = #-0x2
700ab7bc: 9801         	ldr	r0, [sp, #0x4]
700ab7be: 7801         	ldrb	r1, [r0]
700ab7c0: 2000         	movs	r0, #0x0
700ab7c2: 9000         	str	r0, [sp]
700ab7c4: b141         	cbz	r1, 0x700ab7d8 <_strnlen_s+0x28> @ imm = #0x10
700ab7c6: e7ff         	b	0x700ab7c8 <_strnlen_s+0x18> @ imm = #-0x2
700ab7c8: 9802         	ldr	r0, [sp, #0x8]
700ab7ca: 1e41         	subs	r1, r0, #0x1
700ab7cc: 9102         	str	r1, [sp, #0x8]
700ab7ce: 2800         	cmp	r0, #0x0
700ab7d0: bf18         	it	ne
700ab7d2: 2001         	movne	r0, #0x1
700ab7d4: 9000         	str	r0, [sp]
700ab7d6: e7ff         	b	0x700ab7d8 <_strnlen_s+0x28> @ imm = #-0x2
700ab7d8: 9800         	ldr	r0, [sp]
;   for (s = str; *s && maxsize--; ++s);
700ab7da: 07c0         	lsls	r0, r0, #0x1f
700ab7dc: b128         	cbz	r0, 0x700ab7ea <_strnlen_s+0x3a> @ imm = #0xa
700ab7de: e7ff         	b	0x700ab7e0 <_strnlen_s+0x30> @ imm = #-0x2
700ab7e0: e7ff         	b	0x700ab7e2 <_strnlen_s+0x32> @ imm = #-0x2
700ab7e2: 9801         	ldr	r0, [sp, #0x4]
700ab7e4: 3001         	adds	r0, #0x1
700ab7e6: 9001         	str	r0, [sp, #0x4]
700ab7e8: e7e8         	b	0x700ab7bc <_strnlen_s+0xc> @ imm = #-0x30
;   return (unsigned int)(s - str);
700ab7ea: 9801         	ldr	r0, [sp, #0x4]
700ab7ec: 9903         	ldr	r1, [sp, #0xc]
700ab7ee: 1a40         	subs	r0, r0, r1
700ab7f0: b004         	add	sp, #0x10
700ab7f2: 4770         	bx	lr
		...

700ab800 <prvSampleTimeNow>:
;     {
700ab800: b580         	push	{r7, lr}
700ab802: b082         	sub	sp, #0x8
700ab804: 9001         	str	r0, [sp, #0x4]
;         xTimeNow = xTaskGetTickCount();
700ab806: f001 fd5b    	bl	0x700ad2c0 <xTaskGetTickCount> @ imm = #0x1ab6
700ab80a: 9000         	str	r0, [sp]
;         if( xTimeNow < xLastTime )
700ab80c: 9800         	ldr	r0, [sp]
700ab80e: f240 41d8    	movw	r1, #0x4d8
700ab812: f2c7 010b    	movt	r1, #0x700b
700ab816: 6809         	ldr	r1, [r1]
700ab818: 4288         	cmp	r0, r1
700ab81a: d206         	bhs	0x700ab82a <prvSampleTimeNow+0x2a> @ imm = #0xc
700ab81c: e7ff         	b	0x700ab81e <prvSampleTimeNow+0x1e> @ imm = #-0x2
;             prvSwitchTimerLists();
700ab81e: f7f9 ffe7    	bl	0x700a57f0 <prvSwitchTimerLists> @ imm = #-0x6032
;             *pxTimerListsWereSwitched = pdTRUE;
700ab822: 9901         	ldr	r1, [sp, #0x4]
700ab824: 2001         	movs	r0, #0x1
700ab826: 6008         	str	r0, [r1]
;         }
700ab828: e003         	b	0x700ab832 <prvSampleTimeNow+0x32> @ imm = #0x6
;             *pxTimerListsWereSwitched = pdFALSE;
700ab82a: 9901         	ldr	r1, [sp, #0x4]
700ab82c: 2000         	movs	r0, #0x0
700ab82e: 6008         	str	r0, [r1]
700ab830: e7ff         	b	0x700ab832 <prvSampleTimeNow+0x32> @ imm = #-0x2
;         xLastTime = xTimeNow;
700ab832: 9800         	ldr	r0, [sp]
700ab834: f240 41d8    	movw	r1, #0x4d8
700ab838: f2c7 010b    	movt	r1, #0x700b
700ab83c: 6008         	str	r0, [r1]
;         return xTimeNow;
700ab83e: 9800         	ldr	r0, [sp]
700ab840: b002         	add	sp, #0x8
700ab842: bd80         	pop	{r7, pc}
		...

700ab850 <CSL_udmapCppi5SetPktLen>:
; {
700ab850: b083         	sub	sp, #0xc
700ab852: 9002         	str	r0, [sp, #0x8]
700ab854: 9101         	str	r1, [sp, #0x4]
700ab856: 9200         	str	r2, [sp]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ab858: 9801         	ldr	r0, [sp, #0x4]
700ab85a: 2801         	cmp	r0, #0x1
700ab85c: d004         	beq	0x700ab868 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #0x8
700ab85e: e7ff         	b	0x700ab860 <CSL_udmapCppi5SetPktLen+0x10> @ imm = #-0x2
;         (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO) )
700ab860: 9801         	ldr	r0, [sp, #0x4]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ab862: 2802         	cmp	r0, #0x2
700ab864: d107         	bne	0x700ab876 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #0xe
700ab866: e7ff         	b	0x700ab868 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PKTLEN, pktLen );
700ab868: 9902         	ldr	r1, [sp, #0x8]
700ab86a: 6808         	ldr	r0, [r1]
700ab86c: 9a00         	ldr	r2, [sp]
700ab86e: f362 0015    	bfi	r0, r2, #0, #22
700ab872: 6008         	str	r0, [r1]
;     }
700ab874: e7ff         	b	0x700ab876 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #-0x2
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700ab876: 9801         	ldr	r0, [sp, #0x4]
700ab878: 2803         	cmp	r0, #0x3
700ab87a: d108         	bne	0x700ab88e <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #0x10
700ab87c: e7ff         	b	0x700ab87e <CSL_udmapCppi5SetPktLen+0x2e> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5TRPD *)pDesc)->descInfo, UDMAP_CPPI5_TRPD_DESCINFO_LASTIDX, pktLen-1U );
700ab87e: 9902         	ldr	r1, [sp, #0x8]
700ab880: 6808         	ldr	r0, [r1]
700ab882: 9a00         	ldr	r2, [sp]
700ab884: 3a01         	subs	r2, #0x1
700ab886: f362 000d    	bfi	r0, r2, #0, #14
700ab88a: 6008         	str	r0, [r1]
;     }
700ab88c: e7ff         	b	0x700ab88e <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #-0x2
; }
700ab88e: b003         	add	sp, #0xc
700ab890: 4770         	bx	lr
		...
700ab89e: 0000         	movs	r0, r0

700ab8a0 <Sciclient_rmIrqGetNodeItf>:
; {
700ab8a0: b084         	sub	sp, #0x10
700ab8a2: 9003         	str	r0, [sp, #0xc]
700ab8a4: f8ad 100a    	strh.w	r1, [sp, #0xa]
700ab8a8: 9201         	str	r2, [sp, #0x4]
700ab8aa: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab8ac: 9000         	str	r0, [sp]
;     if (n_itf < n->n_if) {
700ab8ae: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700ab8b2: 9903         	ldr	r1, [sp, #0xc]
700ab8b4: 8849         	ldrh	r1, [r1, #0x2]
700ab8b6: 4288         	cmp	r0, r1
700ab8b8: da09         	bge	0x700ab8ce <Sciclient_rmIrqGetNodeItf+0x2e> @ imm = #0x12
700ab8ba: e7ff         	b	0x700ab8bc <Sciclient_rmIrqGetNodeItf+0x1c> @ imm = #-0x2
;         *itf = n->p_if[n_itf];
700ab8bc: 9803         	ldr	r0, [sp, #0xc]
700ab8be: 6840         	ldr	r0, [r0, #0x4]
700ab8c0: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700ab8c4: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ab8c8: 9901         	ldr	r1, [sp, #0x4]
700ab8ca: 6008         	str	r0, [r1]
;     } else {
700ab8cc: e006         	b	0x700ab8dc <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #0xc
;         *itf = NULL;
700ab8ce: 9901         	ldr	r1, [sp, #0x4]
700ab8d0: 2000         	movs	r0, #0x0
700ab8d2: 6008         	str	r0, [r1]
700ab8d4: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab8d8: 9000         	str	r0, [sp]
700ab8da: e7ff         	b	0x700ab8dc <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #-0x2
;     return r;
700ab8dc: 9800         	ldr	r0, [sp]
700ab8de: b004         	add	sp, #0x10
700ab8e0: 4770         	bx	lr
		...
700ab8ee: 0000         	movs	r0, r0

700ab8f0 <UART_checkOpenParams>:
; {
700ab8f0: b082         	sub	sp, #0x8
700ab8f2: 9001         	str	r0, [sp, #0x4]
700ab8f4: 2000         	movs	r0, #0x0
;     int32_t     status = SystemP_SUCCESS;
700ab8f6: 9000         	str	r0, [sp]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700ab8f8: 9801         	ldr	r0, [sp, #0x4]
700ab8fa: 6900         	ldr	r0, [r0, #0x10]
700ab8fc: 2801         	cmp	r0, #0x1
700ab8fe: d108         	bne	0x700ab912 <UART_checkOpenParams+0x22> @ imm = #0x10
700ab900: e7ff         	b	0x700ab902 <UART_checkOpenParams+0x12> @ imm = #-0x2
;        (NULL_PTR == prms->readCallbackFxn))
700ab902: 9801         	ldr	r0, [sp, #0x4]
700ab904: 69c0         	ldr	r0, [r0, #0x1c]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700ab906: b920         	cbnz	r0, 0x700ab912 <UART_checkOpenParams+0x22> @ imm = #0x8
700ab908: e7ff         	b	0x700ab90a <UART_checkOpenParams+0x1a> @ imm = #-0x2
700ab90a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ab90e: 9000         	str	r0, [sp]
;     }
700ab910: e7ff         	b	0x700ab912 <UART_checkOpenParams+0x22> @ imm = #-0x2
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700ab912: 9801         	ldr	r0, [sp, #0x4]
700ab914: 6980         	ldr	r0, [r0, #0x18]
700ab916: 2801         	cmp	r0, #0x1
700ab918: d108         	bne	0x700ab92c <UART_checkOpenParams+0x3c> @ imm = #0x10
700ab91a: e7ff         	b	0x700ab91c <UART_checkOpenParams+0x2c> @ imm = #-0x2
;        (NULL_PTR == prms->writeCallbackFxn))
700ab91c: 9801         	ldr	r0, [sp, #0x4]
700ab91e: 6a00         	ldr	r0, [r0, #0x20]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700ab920: b920         	cbnz	r0, 0x700ab92c <UART_checkOpenParams+0x3c> @ imm = #0x8
700ab922: e7ff         	b	0x700ab924 <UART_checkOpenParams+0x34> @ imm = #-0x2
700ab924: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ab928: 9000         	str	r0, [sp]
;     }
700ab92a: e7ff         	b	0x700ab92c <UART_checkOpenParams+0x3c> @ imm = #-0x2
;     return (status);
700ab92c: 9800         	ldr	r0, [sp]
700ab92e: b002         	add	sp, #0x8
700ab930: 4770         	bx	lr
		...
700ab93e: 0000         	movs	r0, r0

700ab940 <UdmaUtils_getRingMemSize>:
; {
700ab940: b084         	sub	sp, #0x10
700ab942: f88d 000f    	strb.w	r0, [sp, #0xf]
700ab946: 9102         	str	r1, [sp, #0x8]
700ab948: f88d 2007    	strb.w	r2, [sp, #0x7]
;     ringMemSize = ((uint32_t) 1U << (elemSize + 2U));   /* Element size in bytes */
700ab94c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ab950: 1c81         	adds	r1, r0, #0x2
700ab952: 2001         	movs	r0, #0x1
700ab954: 4088         	lsls	r0, r1
700ab956: 9000         	str	r0, [sp]
;     ringMemSize *= elemCnt;
700ab958: 9902         	ldr	r1, [sp, #0x8]
700ab95a: 9800         	ldr	r0, [sp]
700ab95c: 4348         	muls	r0, r1, r0
700ab95e: 9000         	str	r0, [sp]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700ab960: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ab964: 2802         	cmp	r0, #0x2
700ab966: d005         	beq	0x700ab974 <UdmaUtils_getRingMemSize+0x34> @ imm = #0xa
700ab968: e7ff         	b	0x700ab96a <UdmaUtils_getRingMemSize+0x2a> @ imm = #-0x2
;        (TISCI_MSG_VALUE_RM_RING_MODE_QM == mode))
700ab96a: f89d 000f    	ldrb.w	r0, [sp, #0xf]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700ab96e: 2803         	cmp	r0, #0x3
700ab970: d104         	bne	0x700ab97c <UdmaUtils_getRingMemSize+0x3c> @ imm = #0x8
700ab972: e7ff         	b	0x700ab974 <UdmaUtils_getRingMemSize+0x34> @ imm = #-0x2
;         ringMemSize <<= 1U;
700ab974: 9800         	ldr	r0, [sp]
700ab976: 0040         	lsls	r0, r0, #0x1
700ab978: 9000         	str	r0, [sp]
;     }
700ab97a: e7ff         	b	0x700ab97c <UdmaUtils_getRingMemSize+0x3c> @ imm = #-0x2
;     return (ringMemSize);
700ab97c: 9800         	ldr	r0, [sp]
700ab97e: b004         	add	sp, #0x10
700ab980: 4770         	bx	lr
		...
700ab98e: 0000         	movs	r0, r0

700ab990 <prvCopyDataFromQueue>:
; {
700ab990: b580         	push	{r7, lr}
700ab992: b082         	sub	sp, #0x8
700ab994: 9001         	str	r0, [sp, #0x4]
700ab996: 9100         	str	r1, [sp]
;     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
700ab998: 9801         	ldr	r0, [sp, #0x4]
700ab99a: 6c00         	ldr	r0, [r0, #0x40]
700ab99c: b1b8         	cbz	r0, 0x700ab9ce <prvCopyDataFromQueue+0x3e> @ imm = #0x2e
700ab99e: e7ff         	b	0x700ab9a0 <prvCopyDataFromQueue+0x10> @ imm = #-0x2
;         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700ab9a0: 9901         	ldr	r1, [sp, #0x4]
700ab9a2: 68c8         	ldr	r0, [r1, #0xc]
700ab9a4: 6c0a         	ldr	r2, [r1, #0x40]
700ab9a6: 4410         	add	r0, r2
700ab9a8: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
700ab9aa: 9801         	ldr	r0, [sp, #0x4]
700ab9ac: 6881         	ldr	r1, [r0, #0x8]
700ab9ae: 68c0         	ldr	r0, [r0, #0xc]
700ab9b0: 4288         	cmp	r0, r1
700ab9b2: d304         	blo	0x700ab9be <prvCopyDataFromQueue+0x2e> @ imm = #0x8
700ab9b4: e7ff         	b	0x700ab9b6 <prvCopyDataFromQueue+0x26> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
700ab9b6: 9901         	ldr	r1, [sp, #0x4]
700ab9b8: 6808         	ldr	r0, [r1]
700ab9ba: 60c8         	str	r0, [r1, #0xc]
;         }
700ab9bc: e000         	b	0x700ab9c0 <prvCopyDataFromQueue+0x30> @ imm = #0x0
700ab9be: e7ff         	b	0x700ab9c0 <prvCopyDataFromQueue+0x30> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700ab9c0: 9800         	ldr	r0, [sp]
700ab9c2: 9a01         	ldr	r2, [sp, #0x4]
700ab9c4: 68d1         	ldr	r1, [r2, #0xc]
700ab9c6: 6c12         	ldr	r2, [r2, #0x40]
700ab9c8: f7ef e808    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0x10ff0
;     }
700ab9cc: e7ff         	b	0x700ab9ce <prvCopyDataFromQueue+0x3e> @ imm = #-0x2
; }
700ab9ce: b002         	add	sp, #0x8
700ab9d0: bd80         	pop	{r7, pc}
		...
700ab9de: 0000         	movs	r0, r0

700ab9e0 <CSL_lcdma_ringaccIsTeardownComplete>:
; {
700ab9e0: b580         	push	{r7, lr}
700ab9e2: b084         	sub	sp, #0x10
700ab9e4: 9003         	str	r0, [sp, #0xc]
700ab9e6: 9102         	str	r1, [sp, #0x8]
700ab9e8: 2000         	movs	r0, #0x0
;     bool bRetVal = (bool)false;
700ab9ea: f88d 0007    	strb.w	r0, [sp, #0x7]
;     if( CSL_REG32_FEXT( &pCfg->pRingRtRegs->RING[ringNum].ROCC, LCDMA_RINGACC_RINGRT_RING_ROCC_COMP ) != (uint32_t)0U )
700ab9ee: 9803         	ldr	r0, [sp, #0xc]
700ab9f0: 6840         	ldr	r0, [r0, #0x4]
700ab9f2: 9902         	ldr	r1, [sp, #0x8]
700ab9f4: eb00 3041    	add.w	r0, r0, r1, lsl #13
700ab9f8: f241 0118    	movw	r1, #0x1018
700ab9fc: 4408         	add	r0, r1
700ab9fe: f04f 4100    	mov.w	r1, #0x80000000
700aba02: 221f         	movs	r2, #0x1f
700aba04: f001 fa54    	bl	0x700aceb0 <CSL_REG32_FEXT_RAW> @ imm = #0x14a8
700aba08: b120         	cbz	r0, 0x700aba14 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #0x8
700aba0a: e7ff         	b	0x700aba0c <CSL_lcdma_ringaccIsTeardownComplete+0x2c> @ imm = #-0x2
700aba0c: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700aba0e: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700aba12: e7ff         	b	0x700aba14 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #-0x2
;     return bRetVal;
700aba14: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700aba18: f000 0001    	and	r0, r0, #0x1
700aba1c: b004         	add	sp, #0x10
700aba1e: bd80         	pop	{r7, pc}

700aba20 <Sciclient_rmIrqProgramOesRegister>:
; {
700aba20: b580         	push	{r7, lr}
700aba22: b088         	sub	sp, #0x20
700aba24: 9007         	str	r0, [sp, #0x1c]
700aba26: 2010         	movs	r0, #0x10
700aba28: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700aba2c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700aba2e: 9807         	ldr	r0, [sp, #0x1c]
700aba30: 7900         	ldrb	r0, [r0, #0x4]
700aba32: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700aba36: 9807         	ldr	r0, [sp, #0x1c]
700aba38: 88c0         	ldrh	r0, [r0, #0x6]
700aba3a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700aba3e: 9807         	ldr	r0, [sp, #0x1c]
700aba40: 8900         	ldrh	r0, [r0, #0x8]
700aba42: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700aba46: 9807         	ldr	r0, [sp, #0x1c]
700aba48: 89c0         	ldrh	r0, [r0, #0xe]
700aba4a: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                                  cfg->set_resp,
700aba4e: 9807         	ldr	r0, [sp, #0x1c]
700aba50: 6981         	ldr	r1, [r0, #0x18]
700aba52: 4668         	mov	r0, sp
700aba54: f04f 32ff    	mov.w	r2, #0xffffffff
;     return Sciclient_rmIrqSetRaw(&req,
700aba58: f7fe fe7a    	bl	0x700aa750 <Sciclient_rmIrqSetRaw> @ imm = #-0x130c
700aba5c: b008         	add	sp, #0x20
700aba5e: bd80         	pop	{r7, pc}

700aba60 <Sciclient_rmPsGetIfIdx>:
; {
700aba60: b082         	sub	sp, #0x8
700aba62: f8ad 0006    	strh.w	r0, [sp, #0x6]
700aba66: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700aba6a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700aba6c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700aba70: f241 0158    	movw	r1, #0x1058
700aba74: f2c7 0108    	movt	r1, #0x7008
700aba78: 8c89         	ldrh	r1, [r1, #0x24]
700aba7a: 4288         	cmp	r0, r1
700aba7c: da0d         	bge	0x700aba9a <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #0x1a
700aba7e: e7ff         	b	0x700aba80 <Sciclient_rmPsGetIfIdx+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].if_idx;
700aba80: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700aba84: eb00 0140    	add.w	r1, r0, r0, lsl #1
700aba88: f241 0058    	movw	r0, #0x1058
700aba8c: f2c7 0008    	movt	r0, #0x7008
700aba90: eb00 0081    	add.w	r0, r0, r1, lsl #2
700aba94: 8880         	ldrh	r0, [r0, #0x4]
700aba96: 9000         	str	r0, [sp]
;     }
700aba98: e7ff         	b	0x700aba9a <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #-0x2
;     return r;
700aba9a: 9800         	ldr	r0, [sp]
700aba9c: b002         	add	sp, #0x8
700aba9e: 4770         	bx	lr

700abaa0 <Sciclient_rmPsGetInp>:
; {
700abaa0: b082         	sub	sp, #0x8
700abaa2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700abaa6: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700abaaa: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700abaac: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700abab0: f241 0158    	movw	r1, #0x1058
700abab4: f2c7 0108    	movt	r1, #0x7008
700abab8: 8c89         	ldrh	r1, [r1, #0x24]
700ababa: 4288         	cmp	r0, r1
700ababc: da0d         	bge	0x700abada <Sciclient_rmPsGetInp+0x3a> @ imm = #0x1a
700ababe: e7ff         	b	0x700abac0 <Sciclient_rmPsGetInp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].inp;
700abac0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700abac4: eb00 0140    	add.w	r1, r0, r0, lsl #1
700abac8: f241 0058    	movw	r0, #0x1058
700abacc: f2c7 0008    	movt	r0, #0x7008
700abad0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700abad4: 88c0         	ldrh	r0, [r0, #0x6]
700abad6: 9000         	str	r0, [sp]
;     }
700abad8: e7ff         	b	0x700abada <Sciclient_rmPsGetInp+0x3a> @ imm = #-0x2
;     return r;
700abada: 9800         	ldr	r0, [sp]
700abadc: b002         	add	sp, #0x8
700abade: 4770         	bx	lr

700abae0 <Sciclient_rmPsGetOutp>:
; {
700abae0: b082         	sub	sp, #0x8
700abae2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700abae6: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700abaea: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700abaec: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700abaf0: f241 0158    	movw	r1, #0x1058
700abaf4: f2c7 0108    	movt	r1, #0x7008
700abaf8: 8c89         	ldrh	r1, [r1, #0x24]
700abafa: 4288         	cmp	r0, r1
700abafc: da0d         	bge	0x700abb1a <Sciclient_rmPsGetOutp+0x3a> @ imm = #0x1a
700abafe: e7ff         	b	0x700abb00 <Sciclient_rmPsGetOutp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].outp;
700abb00: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700abb04: eb00 0140    	add.w	r1, r0, r0, lsl #1
700abb08: f241 0058    	movw	r0, #0x1058
700abb0c: f2c7 0008    	movt	r0, #0x7008
700abb10: eb00 0081    	add.w	r0, r0, r1, lsl #2
700abb14: 8900         	ldrh	r0, [r0, #0x8]
700abb16: 9000         	str	r0, [sp]
;     }
700abb18: e7ff         	b	0x700abb1a <Sciclient_rmPsGetOutp+0x3a> @ imm = #-0x2
;     return r;
700abb1a: 9800         	ldr	r0, [sp]
700abb1c: b002         	add	sp, #0x8
700abb1e: 4770         	bx	lr

700abb20 <free_list_insert>:
700abb20: e5902000     	ldr	r2, [r0]
700abb24: e59f1030     	ldr	r1, [pc, #0x30]         @ 0x700abb5c <free_list_insert+0x3c>
700abb28: e3c2c001     	bic	r12, r2, #1
700abb2c: e5913000     	ldr	r3, [r1]
700abb30: e3530000     	cmp	r3, #0
700abb34: 0a000005     	beq	0x700abb50 <free_list_insert+0x30> @ imm = #0x14
700abb38: e5932000     	ldr	r2, [r3]
700abb3c: e3c22001     	bic	r2, r2, #1
700abb40: e152000c     	cmp	r2, r12
700abb44: 2a000001     	bhs	0x700abb50 <free_list_insert+0x30> @ imm = #0x4
700abb48: e2831008     	add	r1, r3, #8
700abb4c: eafffff6     	b	0x700abb2c <free_list_insert+0xc> @ imm = #-0x28
700abb50: e5803008     	str	r3, [r0, #0x8]
700abb54: e5810000     	str	r0, [r1]
700abb58: e12fff1e     	bx	lr
700abb5c: c4 4f 08 70  	.word	0x70084fc4

700abb60 <prvGetNextExpireTime>:
;     {
700abb60: b082         	sub	sp, #0x8
700abb62: 9001         	str	r0, [sp, #0x4]
;         *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
700abb64: f644 70b4    	movw	r0, #0x4fb4
700abb68: f2c7 0008    	movt	r0, #0x7008
700abb6c: 6800         	ldr	r0, [r0]
700abb6e: 6800         	ldr	r0, [r0]
700abb70: fab0 f080    	clz	r0, r0
700abb74: 0940         	lsrs	r0, r0, #0x5
700abb76: 9901         	ldr	r1, [sp, #0x4]
700abb78: 6008         	str	r0, [r1]
;         if( *pxListWasEmpty == pdFALSE )
700abb7a: 9801         	ldr	r0, [sp, #0x4]
700abb7c: 6800         	ldr	r0, [r0]
700abb7e: b948         	cbnz	r0, 0x700abb94 <prvGetNextExpireTime+0x34> @ imm = #0x12
700abb80: e7ff         	b	0x700abb82 <prvGetNextExpireTime+0x22> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700abb82: f644 70b4    	movw	r0, #0x4fb4
700abb86: f2c7 0008    	movt	r0, #0x7008
700abb8a: 6800         	ldr	r0, [r0]
700abb8c: 68c0         	ldr	r0, [r0, #0xc]
700abb8e: 6800         	ldr	r0, [r0]
700abb90: 9000         	str	r0, [sp]
;         }
700abb92: e002         	b	0x700abb9a <prvGetNextExpireTime+0x3a> @ imm = #0x4
700abb94: 2000         	movs	r0, #0x0
;             xNextExpireTime = ( TickType_t ) 0U;
700abb96: 9000         	str	r0, [sp]
700abb98: e7ff         	b	0x700abb9a <prvGetNextExpireTime+0x3a> @ imm = #-0x2
;         return xNextExpireTime;
700abb9a: 9800         	ldr	r0, [sp]
700abb9c: b002         	add	sp, #0x8
700abb9e: 4770         	bx	lr

700abba0 <Sciclient_secProxyWaitThread>:
; {
700abba0: b580         	push	{r7, lr}
700abba2: b084         	sub	sp, #0x10
700abba4: 9003         	str	r0, [sp, #0xc]
700abba6: 9102         	str	r1, [sp, #0x8]
700abba8: f06f 0003    	mvn	r0, #0x3
;     int32_t  status     = CSL_ETIMEOUT;
700abbac: 9001         	str	r0, [sp, #0x4]
;     uint32_t timeToWait = timeout;
700abbae: 9802         	ldr	r0, [sp, #0x8]
700abbb0: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700abbb2: e7ff         	b	0x700abbb4 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x2
700abbb4: 9800         	ldr	r0, [sp]
700abbb6: b178         	cbz	r0, 0x700abbd8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x1e
700abbb8: e7ff         	b	0x700abbba <Sciclient_secProxyWaitThread+0x1a> @ imm = #-0x2
;         if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700abbba: 9803         	ldr	r0, [sp, #0xc]
700abbbc: f001 fc30    	bl	0x700ad420 <Sciclient_secProxyThreadStatusReg> @ imm = #0x1860
700abbc0: f001 fede    	bl	0x700ad980 <CSL_REG32_RD_RAW> @ imm = #0x1dbc
700abbc4: 0600         	lsls	r0, r0, #0x18
700abbc6: b118         	cbz	r0, 0x700abbd0 <Sciclient_secProxyWaitThread+0x30> @ imm = #0x6
700abbc8: e7ff         	b	0x700abbca <Sciclient_secProxyWaitThread+0x2a> @ imm = #-0x2
700abbca: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700abbcc: 9001         	str	r0, [sp, #0x4]
;             break;
700abbce: e003         	b	0x700abbd8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x6
;         timeToWait--;
700abbd0: 9800         	ldr	r0, [sp]
700abbd2: 3801         	subs	r0, #0x1
700abbd4: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700abbd6: e7ed         	b	0x700abbb4 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x26
;     return status;
700abbd8: 9801         	ldr	r0, [sp, #0x4]
700abbda: b004         	add	sp, #0x10
700abbdc: bd80         	pop	{r7, pc}
700abbde: 0000         	movs	r0, r0

700abbe0 <UART_IsHWFlowCtrlValid>:
; {
700abbe0: b082         	sub	sp, #0x8
700abbe2: 9001         	str	r0, [sp, #0x4]
700abbe4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700abbe8: 9000         	str	r0, [sp]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700abbea: 9801         	ldr	r0, [sp, #0x4]
700abbec: 2801         	cmp	r0, #0x1
700abbee: d010         	beq	0x700abc12 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x20
700abbf0: e7ff         	b	0x700abbf2 <UART_IsHWFlowCtrlValid+0x12> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_8)  ||
700abbf2: 9801         	ldr	r0, [sp, #0x4]
700abbf4: 2808         	cmp	r0, #0x8
700abbf6: d00c         	beq	0x700abc12 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x18
700abbf8: e7ff         	b	0x700abbfa <UART_IsHWFlowCtrlValid+0x1a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_16) ||
700abbfa: 9801         	ldr	r0, [sp, #0x4]
700abbfc: 2810         	cmp	r0, #0x10
700abbfe: d008         	beq	0x700abc12 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x10
700abc00: e7ff         	b	0x700abc02 <UART_IsHWFlowCtrlValid+0x22> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_56) ||
700abc02: 9801         	ldr	r0, [sp, #0x4]
700abc04: 2838         	cmp	r0, #0x38
700abc06: d004         	beq	0x700abc12 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x8
700abc08: e7ff         	b	0x700abc0a <UART_IsHWFlowCtrlValid+0x2a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_60)))
700abc0a: 9801         	ldr	r0, [sp, #0x4]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700abc0c: 283c         	cmp	r0, #0x3c
700abc0e: d103         	bne	0x700abc18 <UART_IsHWFlowCtrlValid+0x38> @ imm = #0x6
700abc10: e7ff         	b	0x700abc12 <UART_IsHWFlowCtrlValid+0x32> @ imm = #-0x2
700abc12: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700abc14: 9000         	str	r0, [sp]
;     }
700abc16: e7ff         	b	0x700abc18 <UART_IsHWFlowCtrlValid+0x38> @ imm = #-0x2
;     return status;
700abc18: 9800         	ldr	r0, [sp]
700abc1a: b002         	add	sp, #0x8
700abc1c: 4770         	bx	lr
700abc1e: 0000         	movs	r0, r0

700abc20 <UART_IsRxTrigLvlValid>:
; {
700abc20: b082         	sub	sp, #0x8
700abc22: 9001         	str	r0, [sp, #0x4]
700abc24: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700abc28: 9000         	str	r0, [sp]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700abc2a: 9801         	ldr	r0, [sp, #0x4]
700abc2c: 2801         	cmp	r0, #0x1
700abc2e: d010         	beq	0x700abc52 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x20
700abc30: e7ff         	b	0x700abc32 <UART_IsRxTrigLvlValid+0x12> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_8)  ||
700abc32: 9801         	ldr	r0, [sp, #0x4]
700abc34: 2808         	cmp	r0, #0x8
700abc36: d00c         	beq	0x700abc52 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x18
700abc38: e7ff         	b	0x700abc3a <UART_IsRxTrigLvlValid+0x1a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_16) ||
700abc3a: 9801         	ldr	r0, [sp, #0x4]
700abc3c: 2810         	cmp	r0, #0x10
700abc3e: d008         	beq	0x700abc52 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x10
700abc40: e7ff         	b	0x700abc42 <UART_IsRxTrigLvlValid+0x22> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_56) ||
700abc42: 9801         	ldr	r0, [sp, #0x4]
700abc44: 2838         	cmp	r0, #0x38
700abc46: d004         	beq	0x700abc52 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x8
700abc48: e7ff         	b	0x700abc4a <UART_IsRxTrigLvlValid+0x2a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_60)))
700abc4a: 9801         	ldr	r0, [sp, #0x4]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700abc4c: 283c         	cmp	r0, #0x3c
700abc4e: d103         	bne	0x700abc58 <UART_IsRxTrigLvlValid+0x38> @ imm = #0x6
700abc50: e7ff         	b	0x700abc52 <UART_IsRxTrigLvlValid+0x32> @ imm = #-0x2
700abc52: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700abc54: 9000         	str	r0, [sp]
;     }
700abc56: e7ff         	b	0x700abc58 <UART_IsRxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700abc58: 9800         	ldr	r0, [sp]
700abc5a: b002         	add	sp, #0x8
700abc5c: 4770         	bx	lr
700abc5e: 0000         	movs	r0, r0

700abc60 <UART_IsTxTrigLvlValid>:
; {
700abc60: b082         	sub	sp, #0x8
700abc62: 9001         	str	r0, [sp, #0x4]
700abc64: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700abc68: 9000         	str	r0, [sp]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700abc6a: 9801         	ldr	r0, [sp, #0x4]
700abc6c: 2801         	cmp	r0, #0x1
700abc6e: d010         	beq	0x700abc92 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x20
700abc70: e7ff         	b	0x700abc72 <UART_IsTxTrigLvlValid+0x12> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_8)  ||
700abc72: 9801         	ldr	r0, [sp, #0x4]
700abc74: 2808         	cmp	r0, #0x8
700abc76: d00c         	beq	0x700abc92 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x18
700abc78: e7ff         	b	0x700abc7a <UART_IsTxTrigLvlValid+0x1a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_16) ||
700abc7a: 9801         	ldr	r0, [sp, #0x4]
700abc7c: 2810         	cmp	r0, #0x10
700abc7e: d008         	beq	0x700abc92 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x10
700abc80: e7ff         	b	0x700abc82 <UART_IsTxTrigLvlValid+0x22> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_32) ||
700abc82: 9801         	ldr	r0, [sp, #0x4]
700abc84: 2820         	cmp	r0, #0x20
700abc86: d004         	beq	0x700abc92 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x8
700abc88: e7ff         	b	0x700abc8a <UART_IsTxTrigLvlValid+0x2a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_56)))
700abc8a: 9801         	ldr	r0, [sp, #0x4]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700abc8c: 2838         	cmp	r0, #0x38
700abc8e: d103         	bne	0x700abc98 <UART_IsTxTrigLvlValid+0x38> @ imm = #0x6
700abc90: e7ff         	b	0x700abc92 <UART_IsTxTrigLvlValid+0x32> @ imm = #-0x2
700abc92: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700abc94: 9000         	str	r0, [sp]
;     }
700abc96: e7ff         	b	0x700abc98 <UART_IsTxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700abc98: 9800         	ldr	r0, [sp]
700abc9a: b002         	add	sp, #0x8
700abc9c: 4770         	bx	lr
700abc9e: 0000         	movs	r0, r0

700abca0 <UART_i2310WA>:
; {
700abca0: b580         	push	{r7, lr}
700abca2: b084         	sub	sp, #0x10
700abca4: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTL, 0xFF);
700abca6: 9803         	ldr	r0, [sp, #0xc]
700abca8: 3098         	adds	r0, #0x98
700abcaa: 21ff         	movs	r1, #0xff
700abcac: 9101         	str	r1, [sp, #0x4]
700abcae: f001 fe0f    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x1c1e
700abcb2: 9901         	ldr	r1, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTH, 0xFF);
700abcb4: 9803         	ldr	r0, [sp, #0xc]
700abcb6: 309c         	adds	r0, #0x9c
700abcb8: f001 fe0a    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x1c14
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 1);
700abcbc: 9803         	ldr	r0, [sp, #0xc]
700abcbe: 308c         	adds	r0, #0x8c
700abcc0: 2206         	movs	r2, #0x6
700abcc2: 9202         	str	r2, [sp, #0x8]
700abcc4: 2301         	movs	r3, #0x1
700abcc6: 4611         	mov	r1, r2
700abcc8: f000 fc02    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x804
700abccc: 9a02         	ldr	r2, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 0);
700abcce: 9803         	ldr	r0, [sp, #0xc]
700abcd0: 308c         	adds	r0, #0x8c
700abcd2: 2300         	movs	r3, #0x0
700abcd4: 4611         	mov	r1, r2
700abcd6: f000 fbfb    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x7f6
; }
700abcda: b004         	add	sp, #0x10
700abcdc: bd80         	pop	{r7, pc}
700abcde: 0000         	movs	r0, r0

700abce0 <UART_spaceAvail>:
; {
700abce0: b580         	push	{r7, lr}
700abce2: b084         	sub	sp, #0x10
700abce4: 9003         	str	r0, [sp, #0xc]
700abce6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700abce8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700abcea: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700abcec: 9803         	ldr	r0, [sp, #0xc]
700abcee: 217f         	movs	r1, #0x7f
700abcf0: f7fe fcce    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #-0x1664
700abcf4: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700abcf6: 9803         	ldr	r0, [sp, #0xc]
700abcf8: 3014         	adds	r0, #0x14
700abcfa: f001 fde1    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x1bc2
700abcfe: f000 0060    	and	r0, r0, #0x60
;     if ((UART_LSR_TX_SR_E_MASK | UART_LSR_TX_FIFO_E_MASK) ==
700abd02: 2860         	cmp	r0, #0x60
700abd04: d103         	bne	0x700abd0e <UART_spaceAvail+0x2e> @ imm = #0x6
700abd06: e7ff         	b	0x700abd08 <UART_spaceAvail+0x28> @ imm = #-0x2
700abd08: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700abd0a: 9001         	str	r0, [sp, #0x4]
;     }
700abd0c: e7ff         	b	0x700abd0e <UART_spaceAvail+0x2e> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700abd0e: 9803         	ldr	r0, [sp, #0xc]
700abd10: 300c         	adds	r0, #0xc
700abd12: 9902         	ldr	r1, [sp, #0x8]
700abd14: f001 fddc    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x1bb8
;     return retVal;
700abd18: 9801         	ldr	r0, [sp, #0x4]
700abd1a: b004         	add	sp, #0x10
700abd1c: bd80         	pop	{r7, pc}
700abd1e: 0000         	movs	r0, r0

700abd20 <tm_memory_allocation_thread_0_entry>:
; {
700abd20: b5b0         	push	{r4, r5, r7, lr}
700abd22: b082         	sub	sp, #0x8
700abd24: a901         	add	r1, sp, #0x4
;       tm_memory_pool_allocate(0, &memory_ptr);
700abd26: 2000         	movs	r0, #0x0
700abd28: f001 fca2    	bl	0x700ad670 <tm_memory_pool_allocate> @ imm = #0x1944
;       status = tm_memory_pool_deallocate(0, memory_ptr);
700abd2c: 9901         	ldr	r1, [sp, #0x4]
700abd2e: 2000         	movs	r0, #0x0
700abd30: f001 fe5e    	bl	0x700ad9f0 <tm_memory_pool_deallocate> @ imm = #0x1cbc
;       if (status != TM_SUCCESS)
700abd34: b988         	cbnz	r0, 0x700abd5a <tm_memory_allocation_thread_0_entry+0x3a> @ imm = #0x22
700abd36: f644 75cc    	movw	r5, #0x4fcc
700abd3a: ac01         	add	r4, sp, #0x4
700abd3c: f2c7 0508    	movt	r5, #0x7008
;       tm_memory_allocation_counter++;
700abd40: 6828         	ldr	r0, [r5]
;       tm_memory_pool_allocate(0, &memory_ptr);
700abd42: 4621         	mov	r1, r4
;       tm_memory_allocation_counter++;
700abd44: 3001         	adds	r0, #0x1
700abd46: 6028         	str	r0, [r5]
;       tm_memory_pool_allocate(0, &memory_ptr);
700abd48: 2000         	movs	r0, #0x0
700abd4a: f001 fc91    	bl	0x700ad670 <tm_memory_pool_allocate> @ imm = #0x1922
;       status = tm_memory_pool_deallocate(0, memory_ptr);
700abd4e: 9901         	ldr	r1, [sp, #0x4]
700abd50: 2000         	movs	r0, #0x0
700abd52: f001 fe4d    	bl	0x700ad9f0 <tm_memory_pool_deallocate> @ imm = #0x1c9a
;       if (status != TM_SUCCESS)
700abd56: 2800         	cmp	r0, #0x0
700abd58: d0f2         	beq	0x700abd40 <tm_memory_allocation_thread_0_entry+0x20> @ imm = #-0x1c
; }
700abd5a: b002         	add	sp, #0x8
700abd5c: bdb0         	pop	{r4, r5, r7, pc}
700abd5e: 0000         	movs	r0, r0

700abd60 <CSL_bcdmaSetChanPeerReg>:
; {
700abd60: b580         	push	{r7, lr}
700abd62: b088         	sub	sp, #0x20
700abd64: f8dd c028    	ldr.w	r12, [sp, #0x28]
700abd68: 9007         	str	r0, [sp, #0x1c]
700abd6a: 9106         	str	r1, [sp, #0x18]
700abd6c: 9205         	str	r2, [sp, #0x14]
700abd6e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700abd70: 9804         	ldr	r0, [sp, #0x10]
700abd72: 9001         	str	r0, [sp, #0x4]
;     remotePeerOpts.regVal = *pVal;
700abd74: 980a         	ldr	r0, [sp, #0x28]
700abd76: 6800         	ldr	r0, [r0]
700abd78: 9002         	str	r0, [sp, #0x8]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700abd7a: 9807         	ldr	r0, [sp, #0x1c]
700abd7c: 9a06         	ldr	r2, [sp, #0x18]
700abd7e: 210c         	movs	r1, #0xc
700abd80: ab01         	add	r3, sp, #0x4
700abd82: f7fd f8cd    	bl	0x700a8f20 <CSL_bcdmaDoChanOp> @ imm = #-0x2e66
700abd86: 9003         	str	r0, [sp, #0xc]
;     if( retVal != CSL_PASS )
700abd88: 9803         	ldr	r0, [sp, #0xc]
700abd8a: b120         	cbz	r0, 0x700abd96 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #0x8
700abd8c: e7ff         	b	0x700abd8e <CSL_bcdmaSetChanPeerReg+0x2e> @ imm = #-0x2
700abd8e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700abd92: 9003         	str	r0, [sp, #0xc]
;     }
700abd94: e7ff         	b	0x700abd96 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #-0x2
;     return retVal;
700abd96: 9803         	ldr	r0, [sp, #0xc]
700abd98: b008         	add	sp, #0x20
700abd9a: bd80         	pop	{r7, pc}
700abd9c: 0000         	movs	r0, r0
700abd9e: 0000         	movs	r0, r0

700abda0 <CSL_intaggrIsValidStatusBitNum>:
; {
700abda0: b084         	sub	sp, #0x10
700abda2: 9003         	str	r0, [sp, #0xc]
700abda4: 9102         	str	r1, [sp, #0x8]
;     uint32_t localStatusBitNum = statusBitNum;
700abda6: 9802         	ldr	r0, [sp, #0x8]
700abda8: 9000         	str	r0, [sp]
;     localStatusBitNum &= ~CSL_INTAGGR_INTR_MODE_FLAG;   /* Remove intr mode flag */
700abdaa: 9800         	ldr	r0, [sp]
700abdac: f020 4000    	bic	r0, r0, #0x80000000
700abdb0: 9000         	str	r0, [sp]
;     if( localStatusBitNum < (pCfg->virtIntrCnt << 6U) )
700abdb2: 9800         	ldr	r0, [sp]
700abdb4: 9903         	ldr	r1, [sp, #0xc]
700abdb6: 6a49         	ldr	r1, [r1, #0x24]
700abdb8: ebb0 1f81    	cmp.w	r0, r1, lsl #6
700abdbc: d204         	bhs	0x700abdc8 <CSL_intaggrIsValidStatusBitNum+0x28> @ imm = #0x8
700abdbe: e7ff         	b	0x700abdc0 <CSL_intaggrIsValidStatusBitNum+0x20> @ imm = #-0x2
700abdc0: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700abdc2: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700abdc6: e003         	b	0x700abdd0 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #0x6
700abdc8: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700abdca: f88d 0007    	strb.w	r0, [sp, #0x7]
700abdce: e7ff         	b	0x700abdd0 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #-0x2
;     return bRetVal;
700abdd0: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700abdd4: f000 0001    	and	r0, r0, #0x1
700abdd8: b004         	add	sp, #0x10
700abdda: 4770         	bx	lr
700abddc: 0000         	movs	r0, r0
700abdde: 0000         	movs	r0, r0

700abde0 <CSL_pktdmaSetRxRT>:
; {
700abde0: b580         	push	{r7, lr}
700abde2: b084         	sub	sp, #0x10
700abde4: 9003         	str	r0, [sp, #0xc]
700abde6: 9102         	str	r1, [sp, #0x8]
700abde8: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL,
700abdea: 9803         	ldr	r0, [sp, #0xc]
700abdec: 6940         	ldr	r0, [r0, #0x14]
700abdee: 9902         	ldr	r1, [sp, #0x8]
700abdf0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700abdf4: 9901         	ldr	r1, [sp, #0x4]
700abdf6: 680b         	ldr	r3, [r1]
700abdf8: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700abdfc: 688a         	ldr	r2, [r1, #0x8]
700abdfe: f04f 4180    	mov.w	r1, #0x40000000
700abe02: ea01 718c    	and.w	r1, r1, r12, lsl #30
700abe06: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700abe0a: f002 0201    	and	r2, r2, #0x1
700abe0e: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700abe12: f001 fd05    	bl	0x700ad820 <CSL_REG32_WR_RAW> @ imm = #0x1a0a
700abe16: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700abe18: b004         	add	sp, #0x10
700abe1a: bd80         	pop	{r7, pc}
700abe1c: 0000         	movs	r0, r0
700abe1e: 0000         	movs	r0, r0

700abe20 <CSL_pktdmaSetTxRT>:
; {
700abe20: b580         	push	{r7, lr}
700abe22: b084         	sub	sp, #0x10
700abe24: 9003         	str	r0, [sp, #0xc]
700abe26: 9102         	str	r1, [sp, #0x8]
700abe28: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL,
700abe2a: 9803         	ldr	r0, [sp, #0xc]
700abe2c: 6900         	ldr	r0, [r0, #0x10]
700abe2e: 9902         	ldr	r1, [sp, #0x8]
700abe30: eb00 3001    	add.w	r0, r0, r1, lsl #12
700abe34: 9901         	ldr	r1, [sp, #0x4]
700abe36: 680b         	ldr	r3, [r1]
700abe38: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700abe3c: 688a         	ldr	r2, [r1, #0x8]
700abe3e: f04f 4180    	mov.w	r1, #0x40000000
700abe42: ea01 718c    	and.w	r1, r1, r12, lsl #30
700abe46: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700abe4a: f002 0201    	and	r2, r2, #0x1
700abe4e: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700abe52: f001 fce5    	bl	0x700ad820 <CSL_REG32_WR_RAW> @ imm = #0x19ca
700abe56: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700abe58: b004         	add	sp, #0x10
700abe5a: bd80         	pop	{r7, pc}
700abe5c: 0000         	movs	r0, r0
700abe5e: 0000         	movs	r0, r0

700abe60 <Sciclient_rmIrqClearOesRegister>:
; {
700abe60: b580         	push	{r7, lr}
700abe62: b088         	sub	sp, #0x20
700abe64: 9007         	str	r0, [sp, #0x1c]
700abe66: 2010         	movs	r0, #0x10
700abe68: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700abe6c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700abe6e: 9807         	ldr	r0, [sp, #0x1c]
700abe70: 7900         	ldrb	r0, [r0, #0x4]
700abe72: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700abe76: 9807         	ldr	r0, [sp, #0x1c]
700abe78: 88c0         	ldrh	r0, [r0, #0x6]
700abe7a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700abe7e: 9807         	ldr	r0, [sp, #0x1c]
700abe80: 8900         	ldrh	r0, [r0, #0x8]
700abe82: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700abe86: 9807         	ldr	r0, [sp, #0x1c]
700abe88: 89c0         	ldrh	r0, [r0, #0xe]
700abe8a: f8ad 0018    	strh.w	r0, [sp, #0x18]
700abe8e: 4668         	mov	r0, sp
700abe90: f04f 31ff    	mov.w	r1, #0xffffffff
;     return Sciclient_rmIrqReleaseRaw(&req,
700abe94: f7fe fdac    	bl	0x700aa9f0 <Sciclient_rmIrqReleaseRaw> @ imm = #-0x14a8
700abe98: b008         	add	sp, #0x20
700abe9a: bd80         	pop	{r7, pc}
700abe9c: 0000         	movs	r0, r0
700abe9e: 0000         	movs	r0, r0

700abea0 <UART_IsParityTypeValid>:
; {
700abea0: b082         	sub	sp, #0x8
700abea2: 9001         	str	r0, [sp, #0x4]
700abea4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700abea8: 9000         	str	r0, [sp]
;     if(((parityType == UART_PARITY_NONE)    ||
700abeaa: 9801         	ldr	r0, [sp, #0x4]
700abeac: b180         	cbz	r0, 0x700abed0 <UART_IsParityTypeValid+0x30> @ imm = #0x20
700abeae: e7ff         	b	0x700abeb0 <UART_IsParityTypeValid+0x10> @ imm = #-0x2
;         (parityType == UART_PARITY_ODD)     ||
700abeb0: 9801         	ldr	r0, [sp, #0x4]
700abeb2: 2801         	cmp	r0, #0x1
700abeb4: d00c         	beq	0x700abed0 <UART_IsParityTypeValid+0x30> @ imm = #0x18
700abeb6: e7ff         	b	0x700abeb8 <UART_IsParityTypeValid+0x18> @ imm = #-0x2
;         (parityType == UART_PARITY_EVEN)    ||
700abeb8: 9801         	ldr	r0, [sp, #0x4]
700abeba: 2803         	cmp	r0, #0x3
700abebc: d008         	beq	0x700abed0 <UART_IsParityTypeValid+0x30> @ imm = #0x10
700abebe: e7ff         	b	0x700abec0 <UART_IsParityTypeValid+0x20> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED0) ||
700abec0: 9801         	ldr	r0, [sp, #0x4]
700abec2: 2807         	cmp	r0, #0x7
700abec4: d004         	beq	0x700abed0 <UART_IsParityTypeValid+0x30> @ imm = #0x8
700abec6: e7ff         	b	0x700abec8 <UART_IsParityTypeValid+0x28> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED1)))
700abec8: 9801         	ldr	r0, [sp, #0x4]
;     if(((parityType == UART_PARITY_NONE)    ||
700abeca: 2805         	cmp	r0, #0x5
700abecc: d103         	bne	0x700abed6 <UART_IsParityTypeValid+0x36> @ imm = #0x6
700abece: e7ff         	b	0x700abed0 <UART_IsParityTypeValid+0x30> @ imm = #-0x2
700abed0: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700abed2: 9000         	str	r0, [sp]
;     }
700abed4: e7ff         	b	0x700abed6 <UART_IsParityTypeValid+0x36> @ imm = #-0x2
;     return status;
700abed6: 9800         	ldr	r0, [sp]
700abed8: b002         	add	sp, #0x8
700abeda: 4770         	bx	lr
700abedc: 0000         	movs	r0, r0
700abede: 0000         	movs	r0, r0

700abee0 <UART_IsTxRxFifoEmpty>:
; {
700abee0: b580         	push	{r7, lr}
700abee2: b084         	sub	sp, #0x10
700abee4: 9003         	str	r0, [sp, #0xc]
700abee6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700abee8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700abeea: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700abeec: 9803         	ldr	r0, [sp, #0xc]
700abeee: 217f         	movs	r1, #0x7f
700abef0: f7fe fbce    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #-0x1864
700abef4: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700abef6: 9803         	ldr	r0, [sp, #0xc]
700abef8: 3014         	adds	r0, #0x14
700abefa: f001 fce1    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x19c2
;     if (((UART_LSR_TX_FIFO_E_TX_FIFO_E_VALUE_1 << UART_LSR_TX_FIFO_E_SHIFT) |
700abefe: 0680         	lsls	r0, r0, #0x1a
700abf00: 2800         	cmp	r0, #0x0
700abf02: d503         	bpl	0x700abf0c <UART_IsTxRxFifoEmpty+0x2c> @ imm = #0x6
700abf04: e7ff         	b	0x700abf06 <UART_IsTxRxFifoEmpty+0x26> @ imm = #-0x2
700abf06: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700abf08: 9001         	str	r0, [sp, #0x4]
;     }
700abf0a: e7ff         	b	0x700abf0c <UART_IsTxRxFifoEmpty+0x2c> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700abf0c: 9803         	ldr	r0, [sp, #0xc]
700abf0e: 300c         	adds	r0, #0xc
700abf10: 9902         	ldr	r1, [sp, #0x8]
700abf12: f001 fcdd    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x19ba
;     return retVal;
700abf16: 9801         	ldr	r0, [sp, #0x4]
700abf18: b004         	add	sp, #0x10
700abf1a: bd80         	pop	{r7, pc}
700abf1c: 0000         	movs	r0, r0
700abf1e: 0000         	movs	r0, r0

700abf20 <UART_enhanFuncEnable>:
; {
700abf20: b580         	push	{r7, lr}
700abf22: b084         	sub	sp, #0x10
700abf24: 9003         	str	r0, [sp, #0xc]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700abf26: 9803         	ldr	r0, [sp, #0xc]
700abf28: 21bf         	movs	r1, #0xbf
700abf2a: f7fe fbb1    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #-0x189e
700abf2e: 9001         	str	r0, [sp, #0x4]
;     enhanFnBitVal = HW_RD_REG32(baseAddr + UART_EFR) & UART_EFR_ENHANCED_EN_MASK;
700abf30: 9803         	ldr	r0, [sp, #0xc]
700abf32: 3008         	adds	r0, #0x8
700abf34: f001 fcc4    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x1988
700abf38: f000 0010    	and	r0, r0, #0x10
700abf3c: 9002         	str	r0, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700abf3e: 9803         	ldr	r0, [sp, #0xc]
700abf40: 3008         	adds	r0, #0x8
700abf42: 2110         	movs	r1, #0x10
700abf44: 2204         	movs	r2, #0x4
700abf46: 2301         	movs	r3, #0x1
700abf48: f000 fac2    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #0x584
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700abf4c: 9803         	ldr	r0, [sp, #0xc]
700abf4e: 300c         	adds	r0, #0xc
700abf50: 9901         	ldr	r1, [sp, #0x4]
700abf52: f001 fcbd    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x197a
;     return enhanFnBitVal;
700abf56: 9802         	ldr	r0, [sp, #0x8]
700abf58: b004         	add	sp, #0x10
700abf5a: bd80         	pop	{r7, pc}
700abf5c: 0000         	movs	r0, r0
700abf5e: 0000         	movs	r0, r0

700abf60 <UART_lld_dmaDeInit>:
; {
700abf60: b580         	push	{r7, lr}
700abf62: b084         	sub	sp, #0x10
700abf64: 9003         	str	r0, [sp, #0xc]
700abf66: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700abf68: 9002         	str	r0, [sp, #0x8]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700abf6a: 9803         	ldr	r0, [sp, #0xc]
700abf6c: 6840         	ldr	r0, [r0, #0x4]
700abf6e: 6cc0         	ldr	r0, [r0, #0x4c]
700abf70: 9001         	str	r0, [sp, #0x4]
;     if (udmaChCfg->isOpen != FALSE)
700abf72: 9801         	ldr	r0, [sp, #0x4]
700abf74: 6b80         	ldr	r0, [r0, #0x38]
700abf76: b170         	cbz	r0, 0x700abf96 <UART_lld_dmaDeInit+0x36> @ imm = #0x1c
700abf78: e7ff         	b	0x700abf7a <UART_lld_dmaDeInit+0x1a> @ imm = #-0x2
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700abf7a: 9901         	ldr	r1, [sp, #0x4]
700abf7c: 6888         	ldr	r0, [r1, #0x8]
;                           udmaChCfg->cqRxEvtHandle);
700abf7e: 6909         	ldr	r1, [r1, #0x10]
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700abf80: f7f8 fcf6    	bl	0x700a4970 <UART_udmaDeInitCh> @ imm = #-0x7614
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700abf84: 9901         	ldr	r1, [sp, #0x4]
700abf86: 6848         	ldr	r0, [r1, #0x4]
;                           udmaChCfg->cqTxEvtHandle);
700abf88: 68c9         	ldr	r1, [r1, #0xc]
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700abf8a: f7f8 fcf1    	bl	0x700a4970 <UART_udmaDeInitCh> @ imm = #-0x761e
;         udmaChCfg->isOpen = FALSE;
700abf8e: 9901         	ldr	r1, [sp, #0x4]
700abf90: 2000         	movs	r0, #0x0
700abf92: 6388         	str	r0, [r1, #0x38]
;     }
700abf94: e7ff         	b	0x700abf96 <UART_lld_dmaDeInit+0x36> @ imm = #-0x2
;     return status;
700abf96: 9802         	ldr	r0, [sp, #0x8]
700abf98: b004         	add	sp, #0x10
700abf9a: bd80         	pop	{r7, pc}
700abf9c: 0000         	movs	r0, r0
700abf9e: 0000         	movs	r0, r0

700abfa0 <prvDeleteTCB>:
; static void prvDeleteTCB(TCB_t *pxTCB) {
700abfa0: b580         	push	{r7, lr}
700abfa2: b082         	sub	sp, #0x8
700abfa4: 9001         	str	r0, [sp, #0x4]
;   portCLEAN_UP_TCB(pxTCB);
700abfa6: 9801         	ldr	r0, [sp, #0x4]
;     if (pxTCB->ucStaticallyAllocated ==
700abfa8: f890 0086    	ldrb.w	r0, [r0, #0x86]
700abfac: b940         	cbnz	r0, 0x700abfc0 <prvDeleteTCB+0x20> @ imm = #0x10
700abfae: e7ff         	b	0x700abfb0 <prvDeleteTCB+0x10> @ imm = #-0x2
;       vPortFree(pxTCB->pxStack);
700abfb0: 9801         	ldr	r0, [sp, #0x4]
700abfb2: 6b00         	ldr	r0, [r0, #0x30]
700abfb4: f001 f8d4    	bl	0x700ad160 <vPortFree>  @ imm = #0x11a8
;       vPortFree(pxTCB);
700abfb8: 9801         	ldr	r0, [sp, #0x4]
700abfba: f001 f8d1    	bl	0x700ad160 <vPortFree>  @ imm = #0x11a2
;     } else if (pxTCB->ucStaticallyAllocated ==
700abfbe: e00b         	b	0x700abfd8 <prvDeleteTCB+0x38> @ imm = #0x16
700abfc0: 9801         	ldr	r0, [sp, #0x4]
700abfc2: f890 0086    	ldrb.w	r0, [r0, #0x86]
700abfc6: 2801         	cmp	r0, #0x1
700abfc8: d104         	bne	0x700abfd4 <prvDeleteTCB+0x34> @ imm = #0x8
700abfca: e7ff         	b	0x700abfcc <prvDeleteTCB+0x2c> @ imm = #-0x2
;       vPortFree(pxTCB);
700abfcc: 9801         	ldr	r0, [sp, #0x4]
700abfce: f001 f8c7    	bl	0x700ad160 <vPortFree>  @ imm = #0x118e
;     } else {
700abfd2: e000         	b	0x700abfd6 <prvDeleteTCB+0x36> @ imm = #0x0
700abfd4: e7ff         	b	0x700abfd6 <prvDeleteTCB+0x36> @ imm = #-0x2
700abfd6: e7ff         	b	0x700abfd8 <prvDeleteTCB+0x38> @ imm = #-0x2
; }
700abfd8: b002         	add	sp, #0x8
700abfda: bd80         	pop	{r7, pc}
700abfdc: 0000         	movs	r0, r0
700abfde: 0000         	movs	r0, r0

700abfe0 <prvResetNextTaskUnblockTime>:
;   if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
700abfe0: f644 70b8    	movw	r0, #0x4fb8
700abfe4: f2c7 0008    	movt	r0, #0x7008
700abfe8: 6800         	ldr	r0, [r0]
700abfea: 6800         	ldr	r0, [r0]
700abfec: b940         	cbnz	r0, 0x700ac000 <prvResetNextTaskUnblockTime+0x20> @ imm = #0x10
700abfee: e7ff         	b	0x700abff0 <prvResetNextTaskUnblockTime+0x10> @ imm = #-0x2
;     xNextTaskUnblockTime = portMAX_DELAY;
700abff0: f240 5110    	movw	r1, #0x510
700abff4: f2c7 010b    	movt	r1, #0x700b
700abff8: f04f 30ff    	mov.w	r0, #0xffffffff
700abffc: 6008         	str	r0, [r1]
;   } else {
700abffe: e00c         	b	0x700ac01a <prvResetNextTaskUnblockTime+0x3a> @ imm = #0x18
;     xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxDelayedTaskList);
700ac000: f644 70b8    	movw	r0, #0x4fb8
700ac004: f2c7 0008    	movt	r0, #0x7008
700ac008: 6800         	ldr	r0, [r0]
700ac00a: 68c0         	ldr	r0, [r0, #0xc]
700ac00c: 6800         	ldr	r0, [r0]
700ac00e: f240 5110    	movw	r1, #0x510
700ac012: f2c7 010b    	movt	r1, #0x700b
700ac016: 6008         	str	r0, [r1]
700ac018: e7ff         	b	0x700ac01a <prvResetNextTaskUnblockTime+0x3a> @ imm = #-0x2
; }
700ac01a: 4770         	bx	lr
700ac01c: 0000         	movs	r0, r0
700ac01e: 0000         	movs	r0, r0

700ac020 <_atoi>:
; {
700ac020: b580         	push	{r7, lr}
700ac022: b082         	sub	sp, #0x8
700ac024: 9001         	str	r0, [sp, #0x4]
700ac026: 2000         	movs	r0, #0x0
;   unsigned int i = 0U;
700ac028: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700ac02a: e7ff         	b	0x700ac02c <_atoi+0xc>  @ imm = #-0x2
700ac02c: 9801         	ldr	r0, [sp, #0x4]
700ac02e: 6800         	ldr	r0, [r0]
700ac030: 7800         	ldrb	r0, [r0]
700ac032: f000 fbc5    	bl	0x700ac7c0 <_is_digit>  @ imm = #0x78a
700ac036: b168         	cbz	r0, 0x700ac054 <_atoi+0x34> @ imm = #0x1a
700ac038: e7ff         	b	0x700ac03a <_atoi+0x1a> @ imm = #-0x2
;     i = i * 10U + (unsigned int)(*((*str)++) - '0');
700ac03a: 9800         	ldr	r0, [sp]
700ac03c: eb00 0180    	add.w	r1, r0, r0, lsl #2
700ac040: 9b01         	ldr	r3, [sp, #0x4]
700ac042: 6818         	ldr	r0, [r3]
700ac044: 1c42         	adds	r2, r0, #0x1
700ac046: 601a         	str	r2, [r3]
700ac048: 7800         	ldrb	r0, [r0]
700ac04a: eb00 0041    	add.w	r0, r0, r1, lsl #1
700ac04e: 3830         	subs	r0, #0x30
700ac050: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700ac052: e7eb         	b	0x700ac02c <_atoi+0xc>  @ imm = #-0x2a
;   return i;
700ac054: 9800         	ldr	r0, [sp]
700ac056: b002         	add	sp, #0x8
700ac058: bd80         	pop	{r7, pc}
700ac05a: 0000         	movs	r0, r0
700ac05c: 0000         	movs	r0, r0
700ac05e: 0000         	movs	r0, r0

700ac060 <snprintf_>:
; {
700ac060: b081         	sub	sp, #0x4
700ac062: b580         	push	{r7, lr}
700ac064: b087         	sub	sp, #0x1c
700ac066: 9309         	str	r3, [sp, #0x24]
700ac068: 9006         	str	r0, [sp, #0x18]
700ac06a: 9105         	str	r1, [sp, #0x14]
700ac06c: 9204         	str	r2, [sp, #0x10]
700ac06e: a809         	add	r0, sp, #0x24
;   va_start(va, format);
700ac070: 9003         	str	r0, [sp, #0xc]
;   const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
700ac072: 9906         	ldr	r1, [sp, #0x18]
700ac074: 9a05         	ldr	r2, [sp, #0x14]
700ac076: 9b04         	ldr	r3, [sp, #0x10]
700ac078: 9803         	ldr	r0, [sp, #0xc]
700ac07a: 46ec         	mov	r12, sp
700ac07c: f8cc 0000    	str.w	r0, [r12]
700ac080: f64c 50f1    	movw	r0, #0xcdf1
700ac084: f2c7 000a    	movt	r0, #0x700a
700ac088: f7ec ffba    	bl	0x70099000 <_vsnprintf> @ imm = #-0x1308c
700ac08c: 9002         	str	r0, [sp, #0x8]
;   return ret;
700ac08e: 9802         	ldr	r0, [sp, #0x8]
700ac090: b007         	add	sp, #0x1c
700ac092: e8bd 4080    	pop.w	{r7, lr}
700ac096: b001         	add	sp, #0x4
700ac098: 4770         	bx	lr
700ac09a: 0000         	movs	r0, r0
700ac09c: 0000         	movs	r0, r0
700ac09e: 0000         	movs	r0, r0

700ac0a0 <vListInsertEnd>:
; {
700ac0a0: b083         	sub	sp, #0xc
700ac0a2: 9002         	str	r0, [sp, #0x8]
700ac0a4: 9101         	str	r1, [sp, #0x4]
;     ListItem_t * const pxIndex = pxList->pxIndex;
700ac0a6: 9802         	ldr	r0, [sp, #0x8]
700ac0a8: 6840         	ldr	r0, [r0, #0x4]
700ac0aa: 9000         	str	r0, [sp]
;     pxNewListItem->pxNext = pxIndex;
700ac0ac: 9800         	ldr	r0, [sp]
700ac0ae: 9901         	ldr	r1, [sp, #0x4]
700ac0b0: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxPrevious = pxIndex->pxPrevious;
700ac0b2: 9800         	ldr	r0, [sp]
700ac0b4: 6880         	ldr	r0, [r0, #0x8]
700ac0b6: 9901         	ldr	r1, [sp, #0x4]
700ac0b8: 6088         	str	r0, [r1, #0x8]
;     pxIndex->pxPrevious->pxNext = pxNewListItem;
700ac0ba: 9801         	ldr	r0, [sp, #0x4]
700ac0bc: 9900         	ldr	r1, [sp]
700ac0be: 6889         	ldr	r1, [r1, #0x8]
700ac0c0: 6048         	str	r0, [r1, #0x4]
;     pxIndex->pxPrevious = pxNewListItem;
700ac0c2: 9801         	ldr	r0, [sp, #0x4]
700ac0c4: 9900         	ldr	r1, [sp]
700ac0c6: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxContainer = pxList;
700ac0c8: 9802         	ldr	r0, [sp, #0x8]
700ac0ca: 9901         	ldr	r1, [sp, #0x4]
700ac0cc: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700ac0ce: 9902         	ldr	r1, [sp, #0x8]
700ac0d0: 6808         	ldr	r0, [r1]
700ac0d2: 3001         	adds	r0, #0x1
700ac0d4: 6008         	str	r0, [r1]
; }
700ac0d6: b003         	add	sp, #0xc
700ac0d8: 4770         	bx	lr
700ac0da: 0000         	movs	r0, r0
700ac0dc: 0000         	movs	r0, r0
700ac0de: 0000         	movs	r0, r0

700ac0e0 <CSL_REG32_FINS_RAW>:
; {
700ac0e0: b580         	push	{r7, lr}
700ac0e2: b086         	sub	sp, #0x18
700ac0e4: 9005         	str	r0, [sp, #0x14]
700ac0e6: 9104         	str	r1, [sp, #0x10]
700ac0e8: 9203         	str	r2, [sp, #0xc]
700ac0ea: 9302         	str	r3, [sp, #0x8]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ac0ec: 9805         	ldr	r0, [sp, #0x14]
700ac0ee: f001 fc2f    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0x185e
700ac0f2: 9001         	str	r0, [sp, #0x4]
;     regVal = (regVal & ~(mask));
700ac0f4: 9801         	ldr	r0, [sp, #0x4]
700ac0f6: 9904         	ldr	r1, [sp, #0x10]
700ac0f8: 4388         	bics	r0, r1
700ac0fa: 9001         	str	r0, [sp, #0x4]
;     regVal |= (v << shift) & mask;
700ac0fc: 9802         	ldr	r0, [sp, #0x8]
700ac0fe: 9903         	ldr	r1, [sp, #0xc]
700ac100: 4088         	lsls	r0, r1
700ac102: 9904         	ldr	r1, [sp, #0x10]
700ac104: 4001         	ands	r1, r0
700ac106: 9801         	ldr	r0, [sp, #0x4]
700ac108: 4308         	orrs	r0, r1
700ac10a: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR_RAW(p, regVal);
700ac10c: 9805         	ldr	r0, [sp, #0x14]
700ac10e: 9901         	ldr	r1, [sp, #0x4]
700ac110: f001 fb7e    	bl	0x700ad810 <CSL_REG32_WR_RAW> @ imm = #0x16fc
;     return;
700ac114: b006         	add	sp, #0x18
700ac116: bd80         	pop	{r7, pc}
		...

700ac120 <SOC_getCoreName>:
; {
700ac120: b082         	sub	sp, #0x8
700ac122: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     if(coreId < CSL_CORE_ID_MAX)
700ac126: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac12a: 2806         	cmp	r0, #0x6
700ac12c: d80a         	bhi	0x700ac144 <SOC_getCoreName+0x24> @ imm = #0x14
700ac12e: e7ff         	b	0x700ac130 <SOC_getCoreName+0x10> @ imm = #-0x2
;         name = coreIdNames[coreId];
700ac130: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ac134: f240 3084    	movw	r0, #0x384
700ac138: f2c7 000b    	movt	r0, #0x700b
700ac13c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ac140: 9000         	str	r0, [sp]
;     }
700ac142: e006         	b	0x700ac152 <SOC_getCoreName+0x32> @ imm = #0xc
;         name = coreIdNames[CSL_CORE_ID_MAX];
700ac144: f240 3084    	movw	r0, #0x384
700ac148: f2c7 000b    	movt	r0, #0x700b
700ac14c: 69c0         	ldr	r0, [r0, #0x1c]
700ac14e: 9000         	str	r0, [sp]
700ac150: e7ff         	b	0x700ac152 <SOC_getCoreName+0x32> @ imm = #-0x2
;     return name;
700ac152: 9800         	ldr	r0, [sp]
700ac154: b002         	add	sp, #0x8
700ac156: 4770         	bx	lr
		...

700ac160 <Sciclient_secProxyFlush>:
; {
700ac160: b580         	push	{r7, lr}
700ac162: b082         	sub	sp, #0x8
700ac164: 9001         	str	r0, [sp, #0x4]
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ac166: e7ff         	b	0x700ac168 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2
700ac168: 9801         	ldr	r0, [sp, #0x4]
700ac16a: f001 f959    	bl	0x700ad420 <Sciclient_secProxyThreadStatusReg> @ imm = #0x12b2
700ac16e: f001 fc07    	bl	0x700ad980 <CSL_REG32_RD_RAW> @ imm = #0x180e
700ac172: 0600         	lsls	r0, r0, #0x18
700ac174: b170         	cbz	r0, 0x700ac194 <Sciclient_secProxyFlush+0x34> @ imm = #0x1c
700ac176: e7ff         	b	0x700ac178 <Sciclient_secProxyFlush+0x18> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(thread,
700ac178: 9801         	ldr	r0, [sp, #0x4]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U)-1U));
700ac17a: f240 4138    	movw	r1, #0x438
700ac17e: f2c7 010b    	movt	r1, #0x700b
700ac182: 694a         	ldr	r2, [r1, #0x14]
700ac184: f04f 31ff    	mov.w	r1, #0xffffffff
700ac188: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(thread,
700ac18c: b2c9         	uxtb	r1, r1
700ac18e: f000 fae7    	bl	0x700ac760 <Sciclient_secProxyReadThread32> @ imm = #0x5ce
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ac192: e7e9         	b	0x700ac168 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2e
;     return ;
700ac194: b002         	add	sp, #0x8
700ac196: bd80         	pop	{r7, pc}
		...

700ac1a0 <UART_writeDataPolling>:
; {
700ac1a0: b580         	push	{r7, lr}
700ac1a2: b082         	sub	sp, #0x8
700ac1a4: 9001         	str	r0, [sp, #0x4]
700ac1a6: 2000         	movs	r0, #0x0
;     uint32_t numBytesWritten = 0U;
700ac1a8: 9000         	str	r0, [sp]
;     numBytesWritten = UART_fifoWrite(hUart,
700ac1aa: 9801         	ldr	r0, [sp, #0x4]
;                                      (const uint8_t *) hUart->writeBuf,
700ac1ac: 6881         	ldr	r1, [r0, #0x8]
;                                      hUart->writeSizeRemaining);
700ac1ae: 6902         	ldr	r2, [r0, #0x10]
;     numBytesWritten = UART_fifoWrite(hUart,
700ac1b0: f7f9 fbde    	bl	0x700a5970 <UART_fifoWrite> @ imm = #-0x6844
700ac1b4: 9000         	str	r0, [sp]
;     hUart->writeSizeRemaining -= numBytesWritten;
700ac1b6: 9a00         	ldr	r2, [sp]
700ac1b8: 9901         	ldr	r1, [sp, #0x4]
700ac1ba: 6908         	ldr	r0, [r1, #0x10]
700ac1bc: 1a80         	subs	r0, r0, r2
700ac1be: 6108         	str	r0, [r1, #0x10]
;     hUart->writeBuf           = (const void *)((uint8_t *)hUart->writeBuf + numBytesWritten);
700ac1c0: 9901         	ldr	r1, [sp, #0x4]
700ac1c2: 6888         	ldr	r0, [r1, #0x8]
700ac1c4: 9a00         	ldr	r2, [sp]
700ac1c6: 4410         	add	r0, r2
700ac1c8: 6088         	str	r0, [r1, #0x8]
;     hUart->writeCount         += numBytesWritten;
700ac1ca: 9a00         	ldr	r2, [sp]
700ac1cc: 9901         	ldr	r1, [sp, #0x4]
700ac1ce: 68c8         	ldr	r0, [r1, #0xc]
700ac1d0: 4410         	add	r0, r2
700ac1d2: 60c8         	str	r0, [r1, #0xc]
;     return;
700ac1d4: b002         	add	sp, #0x8
700ac1d6: bd80         	pop	{r7, pc}
		...

700ac1e0 <xTaskGetSchedulerState>:
; BaseType_t xTaskGetSchedulerState(void) {
700ac1e0: b081         	sub	sp, #0x4
;   if (xSchedulerRunning == pdFALSE) {
700ac1e2: f240 501c    	movw	r0, #0x51c
700ac1e6: f2c7 000b    	movt	r0, #0x700b
700ac1ea: 6800         	ldr	r0, [r0]
700ac1ec: b918         	cbnz	r0, 0x700ac1f6 <xTaskGetSchedulerState+0x16> @ imm = #0x6
700ac1ee: e7ff         	b	0x700ac1f0 <xTaskGetSchedulerState+0x10> @ imm = #-0x2
700ac1f0: 2001         	movs	r0, #0x1
;     xReturn = taskSCHEDULER_NOT_STARTED;
700ac1f2: 9000         	str	r0, [sp]
;   } else {
700ac1f4: e00d         	b	0x700ac212 <xTaskGetSchedulerState+0x32> @ imm = #0x1a
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700ac1f6: f240 5000    	movw	r0, #0x500
700ac1fa: f2c7 000b    	movt	r0, #0x700b
700ac1fe: 6800         	ldr	r0, [r0]
700ac200: b918         	cbnz	r0, 0x700ac20a <xTaskGetSchedulerState+0x2a> @ imm = #0x6
700ac202: e7ff         	b	0x700ac204 <xTaskGetSchedulerState+0x24> @ imm = #-0x2
700ac204: 2002         	movs	r0, #0x2
;       xReturn = taskSCHEDULER_RUNNING;
700ac206: 9000         	str	r0, [sp]
;     } else {
700ac208: e002         	b	0x700ac210 <xTaskGetSchedulerState+0x30> @ imm = #0x4
700ac20a: 2000         	movs	r0, #0x0
;       xReturn = taskSCHEDULER_SUSPENDED;
700ac20c: 9000         	str	r0, [sp]
700ac20e: e7ff         	b	0x700ac210 <xTaskGetSchedulerState+0x30> @ imm = #-0x2
700ac210: e7ff         	b	0x700ac212 <xTaskGetSchedulerState+0x32> @ imm = #-0x2
;   return xReturn;
700ac212: 9800         	ldr	r0, [sp]
700ac214: b001         	add	sp, #0x4
700ac216: 4770         	bx	lr
		...

700ac220 <tm_thread_create>:
; {
700ac220: b580         	push	{r7, lr}
700ac222: b082         	sub	sp, #0x8
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ac224: f644 63d0    	movw	r3, #0x4ed0
;    int new_priority = configMAX_PRIORITIES - priority + 1;
700ac228: f1c1 0c21    	rsb.w	r12, r1, #0x21
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ac22c: f2c7 0308    	movt	r3, #0x7008
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ac230: f64f 3136    	movw	r1, #0xfb36
700ac234: f2c7 010a    	movt	r1, #0x700a
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ac238: eb03 0e80    	add.w	lr, r3, r0, lsl #2
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ac23c: 4610         	mov	r0, r2
700ac23e: f44f 6280    	mov.w	r2, #0x400
700ac242: 2300         	movs	r3, #0x0
700ac244: e9cd ce00    	strd	r12, lr, [sp]
700ac248: f7fb f892    	bl	0x700a7370 <xTaskCreate> @ imm = #-0x4edc
;    if (status != pdPASS)
700ac24c: 3801         	subs	r0, #0x1
700ac24e: bf18         	it	ne
700ac250: 2001         	movne	r0, #0x1
; }
700ac252: b002         	add	sp, #0x8
700ac254: bd80         	pop	{r7, pc}
		...
700ac25e: 0000         	movs	r0, r0

700ac260 <vTaskDelay>:
; void vTaskDelay(const TickType_t xTicksToDelay) {
700ac260: b580         	push	{r7, lr}
700ac262: b082         	sub	sp, #0x8
700ac264: 9001         	str	r0, [sp, #0x4]
700ac266: 2000         	movs	r0, #0x0
;   BaseType_t xAlreadyYielded = pdFALSE;
700ac268: 9000         	str	r0, [sp]
;   if (xTicksToDelay > (TickType_t)0U) {
700ac26a: 9801         	ldr	r0, [sp, #0x4]
700ac26c: b150         	cbz	r0, 0x700ac284 <vTaskDelay+0x24> @ imm = #0x14
700ac26e: e7ff         	b	0x700ac270 <vTaskDelay+0x10> @ imm = #-0x2
;     vTaskSuspendAll();
700ac270: f001 fb4e    	bl	0x700ad910 <vTaskSuspendAll> @ imm = #0x169c
;       prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
700ac274: 9801         	ldr	r0, [sp, #0x4]
700ac276: 2100         	movs	r1, #0x0
700ac278: f7f7 fcb2    	bl	0x700a3be0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x869c
;     xAlreadyYielded = xTaskResumeAll();
700ac27c: f7f4 fc98    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0xb6d0
700ac280: 9000         	str	r0, [sp]
;   } else {
700ac282: e000         	b	0x700ac286 <vTaskDelay+0x26> @ imm = #0x0
700ac284: e7ff         	b	0x700ac286 <vTaskDelay+0x26> @ imm = #-0x2
;   if (xAlreadyYielded == pdFALSE) {
700ac286: 9800         	ldr	r0, [sp]
700ac288: b910         	cbnz	r0, 0x700ac290 <vTaskDelay+0x30> @ imm = #0x4
700ac28a: e7ff         	b	0x700ac28c <vTaskDelay+0x2c> @ imm = #-0x2
;     portYIELD_WITHIN_API();
700ac28c: df00         	svc	#0x0
;   } else {
700ac28e: e000         	b	0x700ac292 <vTaskDelay+0x32> @ imm = #0x0
700ac290: e7ff         	b	0x700ac292 <vTaskDelay+0x32> @ imm = #-0x2
; }
700ac292: b002         	add	sp, #0x8
700ac294: bd80         	pop	{r7, pc}
		...
700ac29e: 0000         	movs	r0, r0

700ac2a0 <vTaskPlaceOnEventListRestricted>:
;                                      const BaseType_t xWaitIndefinitely) {
700ac2a0: b580         	push	{r7, lr}
700ac2a2: b084         	sub	sp, #0x10
700ac2a4: 9003         	str	r0, [sp, #0xc]
700ac2a6: 9102         	str	r1, [sp, #0x8]
700ac2a8: 9201         	str	r2, [sp, #0x4]
;   vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
700ac2aa: 9803         	ldr	r0, [sp, #0xc]
700ac2ac: f240 41dc    	movw	r1, #0x4dc
700ac2b0: f2c7 010b    	movt	r1, #0x700b
700ac2b4: 6809         	ldr	r1, [r1]
700ac2b6: 3118         	adds	r1, #0x18
700ac2b8: f7ff fef2    	bl	0x700ac0a0 <vListInsertEnd> @ imm = #-0x21c
;   if (xWaitIndefinitely != pdFALSE) {
700ac2bc: 9801         	ldr	r0, [sp, #0x4]
700ac2be: b120         	cbz	r0, 0x700ac2ca <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #0x8
700ac2c0: e7ff         	b	0x700ac2c2 <vTaskPlaceOnEventListRestricted+0x22> @ imm = #-0x2
700ac2c2: f04f 30ff    	mov.w	r0, #0xffffffff
;     xTicksToWait = portMAX_DELAY;
700ac2c6: 9002         	str	r0, [sp, #0x8]
;   }
700ac2c8: e7ff         	b	0x700ac2ca <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #-0x2
;   prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
700ac2ca: 9802         	ldr	r0, [sp, #0x8]
700ac2cc: 9901         	ldr	r1, [sp, #0x4]
700ac2ce: f7f7 fc87    	bl	0x700a3be0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x86f2
; }
700ac2d2: b004         	add	sp, #0x10
700ac2d4: bd80         	pop	{r7, pc}
		...
700ac2de: 0000         	movs	r0, r0

700ac2e0 <CSL_pktdmaTeardownRxChan>:
; {
700ac2e0: b580         	push	{r7, lr}
700ac2e2: b084         	sub	sp, #0x10
700ac2e4: 9003         	str	r0, [sp, #0xc]
700ac2e6: 9102         	str	r1, [sp, #0x8]
700ac2e8: f88d 2007    	strb.w	r2, [sp, #0x7]
700ac2ec: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_RX, bForce, bWait );
700ac2f0: 9803         	ldr	r0, [sp, #0xc]
700ac2f2: 9902         	ldr	r1, [sp, #0x8]
700ac2f4: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ac2f8: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ac2fc: f003 0301    	and	r3, r3, #0x1
700ac300: 46ec         	mov	r12, sp
700ac302: f8cc 3000    	str.w	r3, [r12]
700ac306: f002 0301    	and	r3, r2, #0x1
700ac30a: 2201         	movs	r2, #0x1
700ac30c: f7f7 f950    	bl	0x700a35b0 <CSL_pktdmaTeardownChan> @ imm = #-0x8d60
700ac310: b004         	add	sp, #0x10
700ac312: bd80         	pop	{r7, pc}
		...

700ac320 <CSL_pktdmaTeardownTxChan>:
; {
700ac320: b580         	push	{r7, lr}
700ac322: b084         	sub	sp, #0x10
700ac324: 9003         	str	r0, [sp, #0xc]
700ac326: 9102         	str	r1, [sp, #0x8]
700ac328: f88d 2007    	strb.w	r2, [sp, #0x7]
700ac32c: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_TX, bForce, bWait );
700ac330: 9803         	ldr	r0, [sp, #0xc]
700ac332: 9902         	ldr	r1, [sp, #0x8]
700ac334: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ac338: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ac33c: f003 0301    	and	r3, r3, #0x1
700ac340: 46ec         	mov	r12, sp
700ac342: f8cc 3000    	str.w	r3, [r12]
700ac346: f002 0301    	and	r3, r2, #0x1
700ac34a: 2200         	movs	r2, #0x0
700ac34c: f7f7 f930    	bl	0x700a35b0 <CSL_pktdmaTeardownChan> @ imm = #-0x8da0
700ac350: b004         	add	sp, #0x10
700ac352: bd80         	pop	{r7, pc}
		...

700ac360 <TimerP_Params_init>:
; {
700ac360: b081         	sub	sp, #0x4
700ac362: 9000         	str	r0, [sp]
;     params->inputPreScaler = 1;
700ac364: 9800         	ldr	r0, [sp]
700ac366: 2101         	movs	r1, #0x1
700ac368: 6001         	str	r1, [r0]
;     params->inputClkHz = 25*1000000;
700ac36a: 9a00         	ldr	r2, [sp]
700ac36c: f647 0040    	movw	r0, #0x7840
700ac370: f2c0 107d    	movt	r0, #0x17d
700ac374: 6050         	str	r0, [r2, #0x4]
;     params->periodInUsec = 1000;
700ac376: 9a00         	ldr	r2, [sp]
700ac378: f44f 707a    	mov.w	r0, #0x3e8
700ac37c: 6090         	str	r0, [r2, #0x8]
;     params->periodInNsec = 0; /* periodInUsec is used when periodInNsec is 0 */
700ac37e: 9a00         	ldr	r2, [sp]
700ac380: 2000         	movs	r0, #0x0
700ac382: 60d0         	str	r0, [r2, #0xc]
;     params->oneshotMode = 0;
700ac384: 9a00         	ldr	r2, [sp]
700ac386: 6110         	str	r0, [r2, #0x10]
;     params->enableOverflowInt = 1;
700ac388: 9a00         	ldr	r2, [sp]
700ac38a: 6151         	str	r1, [r2, #0x14]
;     params->enableDmaTrigger = 0; /* NOT USED */
700ac38c: 9900         	ldr	r1, [sp]
700ac38e: 6188         	str	r0, [r1, #0x18]
; }
700ac390: b001         	add	sp, #0x4
700ac392: 4770         	bx	lr
		...

700ac3a0 <UART_IsDataLengthValid>:
; {
700ac3a0: b082         	sub	sp, #0x8
700ac3a2: 9001         	str	r0, [sp, #0x4]
700ac3a4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ac3a8: 9000         	str	r0, [sp]
;     if(((dataLength == UART_LEN_5) ||
700ac3aa: 9801         	ldr	r0, [sp, #0x4]
700ac3ac: b160         	cbz	r0, 0x700ac3c8 <UART_IsDataLengthValid+0x28> @ imm = #0x18
700ac3ae: e7ff         	b	0x700ac3b0 <UART_IsDataLengthValid+0x10> @ imm = #-0x2
;         (dataLength == UART_LEN_6) ||
700ac3b0: 9801         	ldr	r0, [sp, #0x4]
700ac3b2: 2801         	cmp	r0, #0x1
700ac3b4: d008         	beq	0x700ac3c8 <UART_IsDataLengthValid+0x28> @ imm = #0x10
700ac3b6: e7ff         	b	0x700ac3b8 <UART_IsDataLengthValid+0x18> @ imm = #-0x2
;         (dataLength == UART_LEN_7) ||
700ac3b8: 9801         	ldr	r0, [sp, #0x4]
700ac3ba: 2802         	cmp	r0, #0x2
700ac3bc: d004         	beq	0x700ac3c8 <UART_IsDataLengthValid+0x28> @ imm = #0x8
700ac3be: e7ff         	b	0x700ac3c0 <UART_IsDataLengthValid+0x20> @ imm = #-0x2
;         (dataLength == UART_LEN_8)))
700ac3c0: 9801         	ldr	r0, [sp, #0x4]
;     if(((dataLength == UART_LEN_5) ||
700ac3c2: 2803         	cmp	r0, #0x3
700ac3c4: d103         	bne	0x700ac3ce <UART_IsDataLengthValid+0x2e> @ imm = #0x6
700ac3c6: e7ff         	b	0x700ac3c8 <UART_IsDataLengthValid+0x28> @ imm = #-0x2
700ac3c8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ac3ca: 9000         	str	r0, [sp]
;     }
700ac3cc: e7ff         	b	0x700ac3ce <UART_IsDataLengthValid+0x2e> @ imm = #-0x2
;     return status;
700ac3ce: 9800         	ldr	r0, [sp]
700ac3d0: b002         	add	sp, #0x8
700ac3d2: 4770         	bx	lr
		...

700ac3e0 <UART_checkTransaction>:
; {
700ac3e0: b082         	sub	sp, #0x8
700ac3e2: 9001         	str	r0, [sp, #0x4]
700ac3e4: 2000         	movs	r0, #0x0
;     int32_t     status = UART_TRANSFER_STATUS_SUCCESS;
700ac3e6: 9000         	str	r0, [sp]
;     if(0U == trans->count)
700ac3e8: 9801         	ldr	r0, [sp, #0x4]
700ac3ea: 6840         	ldr	r0, [r0, #0x4]
700ac3ec: b938         	cbnz	r0, 0x700ac3fe <UART_checkTransaction+0x1e> @ imm = #0xe
700ac3ee: e7ff         	b	0x700ac3f0 <UART_checkTransaction+0x10> @ imm = #-0x2
;         trans->status = UART_TRANSFER_STATUS_ERROR_OTH;
700ac3f0: 9901         	ldr	r1, [sp, #0x4]
700ac3f2: 200a         	movs	r0, #0xa
700ac3f4: 60c8         	str	r0, [r1, #0xc]
700ac3f6: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ac3fa: 9000         	str	r0, [sp]
;     }
700ac3fc: e7ff         	b	0x700ac3fe <UART_checkTransaction+0x1e> @ imm = #-0x2
;     if(NULL == trans->buf)
700ac3fe: 9801         	ldr	r0, [sp, #0x4]
700ac400: 6800         	ldr	r0, [r0]
700ac402: b920         	cbnz	r0, 0x700ac40e <UART_checkTransaction+0x2e> @ imm = #0x8
700ac404: e7ff         	b	0x700ac406 <UART_checkTransaction+0x26> @ imm = #-0x2
700ac406: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ac40a: 9000         	str	r0, [sp]
;     }
700ac40c: e7ff         	b	0x700ac40e <UART_checkTransaction+0x2e> @ imm = #-0x2
;     return (status);
700ac40e: 9800         	ldr	r0, [sp]
700ac410: b002         	add	sp, #0x8
700ac412: 4770         	bx	lr

700ac414 <free_list_remove>:
700ac414: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700ac444 <free_list_remove+0x30>
700ac418: e5932000     	ldr	r2, [r3]
700ac41c: e1a01003     	mov	r1, r3
700ac420: e3520000     	cmp	r2, #0
700ac424: 12823008     	addne	r3, r2, #8
700ac428: 11520000     	cmpne	r2, r0
700ac42c: 1afffff9     	bne	0x700ac418 <free_list_remove+0x4> @ imm = #-0x1c
700ac430: e3520000     	cmp	r2, #0
700ac434: 012fff1e     	bxeq	lr
700ac438: e5900008     	ldr	r0, [r0, #0x8]
700ac43c: e5810000     	str	r0, [r1]
700ac440: e12fff1e     	bx	lr
700ac444: c4 4f 08 70  	.word	0x70084fc4
700ac448: 00 00 00 00  	.word	0x00000000
700ac44c: 00 00 00 00  	.word	0x00000000

700ac450 <vPortTimerTickHandler>:
; void vPortTimerTickHandler() {
700ac450: b580         	push	{r7, lr}
;   portENTER_CRITICAL();
700ac452: f000 f89d    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #0x13a
;   if (ulPortSchedularRunning == pdTRUE) {
700ac456: f240 40ec    	movw	r0, #0x4ec
700ac45a: f2c7 000b    	movt	r0, #0x700b
700ac45e: 6800         	ldr	r0, [r0]
700ac460: 2801         	cmp	r0, #0x1
700ac462: d10c         	bne	0x700ac47e <vPortTimerTickHandler+0x2e> @ imm = #0x18
700ac464: e7ff         	b	0x700ac466 <vPortTimerTickHandler+0x16> @ imm = #-0x2
;     if (xTaskIncrementTick() != pdFALSE) {
700ac466: f7f3 fc4b    	bl	0x7009fd00 <xTaskIncrementTick> @ imm = #-0xc76a
700ac46a: b138         	cbz	r0, 0x700ac47c <vPortTimerTickHandler+0x2c> @ imm = #0xe
700ac46c: e7ff         	b	0x700ac46e <vPortTimerTickHandler+0x1e> @ imm = #-0x2
;       ulPortYieldRequired = pdTRUE;
700ac46e: f240 41f4    	movw	r1, #0x4f4
700ac472: f2c7 010b    	movt	r1, #0x700b
700ac476: 2001         	movs	r0, #0x1
700ac478: 6008         	str	r0, [r1]
;     }
700ac47a: e7ff         	b	0x700ac47c <vPortTimerTickHandler+0x2c> @ imm = #-0x2
;   }
700ac47c: e7ff         	b	0x700ac47e <vPortTimerTickHandler+0x2e> @ imm = #-0x2
;   portEXIT_CRITICAL();
700ac47e: f7ff f947    	bl	0x700ab710 <vTaskExitCritical> @ imm = #-0xd72
; }
700ac482: bd80         	pop	{r7, pc}
		...

700ac490 <ClockP_timerTickIsr>:
; {
700ac490: b580         	push	{r7, lr}
700ac492: b082         	sub	sp, #0x8
700ac494: 9001         	str	r0, [sp, #0x4]
;     gClockCtrl.ticks++;
700ac496: f644 6198    	movw	r1, #0x4e98
700ac49a: f2c7 0108    	movt	r1, #0x7008
700ac49e: 680a         	ldr	r2, [r1]
700ac4a0: 6848         	ldr	r0, [r1, #0x4]
700ac4a2: 3201         	adds	r2, #0x1
700ac4a4: f140 0000    	adc	r0, r0, #0x0
700ac4a8: 600a         	str	r2, [r1]
700ac4aa: 6048         	str	r0, [r1, #0x4]
;     vPortTimerTickHandler();
700ac4ac: f7ff ffd0    	bl	0x700ac450 <vPortTimerTickHandler> @ imm = #-0x60
;     ClockP_timerClearOverflowInt(gClockConfig.timerBaseAddr);
700ac4b0: f240 4008    	movw	r0, #0x408
700ac4b4: f2c7 000b    	movt	r0, #0x700b
700ac4b8: 6800         	ldr	r0, [r0]
700ac4ba: f001 f9f9    	bl	0x700ad8b0 <ClockP_timerClearOverflowInt> @ imm = #0x13f2
; }
700ac4be: b002         	add	sp, #0x8
700ac4c0: bd80         	pop	{r7, pc}
		...
700ac4ce: 0000         	movs	r0, r0

700ac4d0 <HW_WR_FIELD32_RAW>:
; {
700ac4d0: b085         	sub	sp, #0x14
700ac4d2: 9004         	str	r0, [sp, #0x10]
700ac4d4: 9103         	str	r1, [sp, #0xc]
700ac4d6: 9202         	str	r2, [sp, #0x8]
700ac4d8: 9301         	str	r3, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700ac4da: 9804         	ldr	r0, [sp, #0x10]
700ac4dc: 6800         	ldr	r0, [r0]
700ac4de: 9000         	str	r0, [sp]
;     regVal &= (~mask);
700ac4e0: 9903         	ldr	r1, [sp, #0xc]
700ac4e2: 9800         	ldr	r0, [sp]
700ac4e4: 4388         	bics	r0, r1
700ac4e6: 9000         	str	r0, [sp]
;     regVal |= (value << shift) & mask;
700ac4e8: 9801         	ldr	r0, [sp, #0x4]
700ac4ea: 9902         	ldr	r1, [sp, #0x8]
700ac4ec: 4088         	lsls	r0, r1
700ac4ee: 9903         	ldr	r1, [sp, #0xc]
700ac4f0: 4001         	ands	r1, r0
700ac4f2: 9800         	ldr	r0, [sp]
700ac4f4: 4308         	orrs	r0, r1
700ac4f6: 9000         	str	r0, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = regVal;
700ac4f8: 9800         	ldr	r0, [sp]
700ac4fa: 9904         	ldr	r1, [sp, #0x10]
700ac4fc: 6008         	str	r0, [r1]
;     return;
700ac4fe: b005         	add	sp, #0x14
700ac500: 4770         	bx	lr
		...
700ac50e: 0000         	movs	r0, r0

700ac510 <UART_enhanFuncBitValRestore>:
; {
700ac510: b580         	push	{r7, lr}
700ac512: b084         	sub	sp, #0x10
700ac514: 9003         	str	r0, [sp, #0xc]
700ac516: 9102         	str	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ac518: 9803         	ldr	r0, [sp, #0xc]
700ac51a: 21bf         	movs	r1, #0xbf
700ac51c: f7fe f8b8    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #-0x1e90
700ac520: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700ac522: 9803         	ldr	r0, [sp, #0xc]
700ac524: 3008         	adds	r0, #0x8
700ac526: 9902         	ldr	r1, [sp, #0x8]
700ac528: ea4f 1311    	lsr.w	r3, r1, #0x4
700ac52c: 2110         	movs	r1, #0x10
700ac52e: 2204         	movs	r2, #0x4
700ac530: f7ff ffce    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #-0x64
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ac534: 9803         	ldr	r0, [sp, #0xc]
700ac536: 300c         	adds	r0, #0xc
700ac538: 9901         	ldr	r1, [sp, #0x4]
700ac53a: f001 f9c9    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x1392
; }
700ac53e: b004         	add	sp, #0x10
700ac540: bd80         	pop	{r7, pc}
		...
700ac54e: 0000         	movs	r0, r0

700ac550 <UART_hardwareFlowCtrlOptSet>:
; {
700ac550: b580         	push	{r7, lr}
700ac552: b084         	sub	sp, #0x10
700ac554: 9003         	str	r0, [sp, #0xc]
700ac556: 9102         	str	r1, [sp, #0x8]
700ac558: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ac55a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ac55c: 9803         	ldr	r0, [sp, #0xc]
700ac55e: 21bf         	movs	r1, #0xbf
700ac560: f7fe f896    	bl	0x700aa690 <UART_regConfigModeEnable> @ imm = #-0x1ed4
700ac564: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_HW_FLOW_CONTROL, hwFlowCtrl);
700ac566: 9803         	ldr	r0, [sp, #0xc]
700ac568: 3008         	adds	r0, #0x8
700ac56a: 9b02         	ldr	r3, [sp, #0x8]
700ac56c: 21c0         	movs	r1, #0xc0
700ac56e: 2206         	movs	r2, #0x6
700ac570: f7ff ffae    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #-0xa4
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ac574: 9803         	ldr	r0, [sp, #0xc]
700ac576: 300c         	adds	r0, #0xc
700ac578: 9901         	ldr	r1, [sp, #0x4]
700ac57a: f001 f9a9    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x1352
; }
700ac57e: b004         	add	sp, #0x10
700ac580: bd80         	pop	{r7, pc}
		...
700ac58e: 0000         	movs	r0, r0

700ac590 <vTaskEnterCritical>:
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700ac590: b672         	cpsid i
;   if (xSchedulerRunning != pdFALSE) {
700ac592: f240 501c    	movw	r0, #0x51c
700ac596: f2c7 000b    	movt	r0, #0x700b
700ac59a: 6800         	ldr	r0, [r0]
700ac59c: b178         	cbz	r0, 0x700ac5be <vTaskEnterCritical+0x2e> @ imm = #0x1e
700ac59e: e7ff         	b	0x700ac5a0 <vTaskEnterCritical+0x10> @ imm = #-0x2
;     (pxCurrentTCB->uxCriticalNesting)++;
700ac5a0: f240 40dc    	movw	r0, #0x4dc
700ac5a4: f2c7 000b    	movt	r0, #0x700b
700ac5a8: 6802         	ldr	r2, [r0]
700ac5aa: 6d51         	ldr	r1, [r2, #0x54]
700ac5ac: 3101         	adds	r1, #0x1
700ac5ae: 6551         	str	r1, [r2, #0x54]
;     if (pxCurrentTCB->uxCriticalNesting == 1) {
700ac5b0: 6800         	ldr	r0, [r0]
700ac5b2: 6d40         	ldr	r0, [r0, #0x54]
700ac5b4: 2801         	cmp	r0, #0x1
700ac5b6: d101         	bne	0x700ac5bc <vTaskEnterCritical+0x2c> @ imm = #0x2
700ac5b8: e7ff         	b	0x700ac5ba <vTaskEnterCritical+0x2a> @ imm = #-0x2
;     }
700ac5ba: e7ff         	b	0x700ac5bc <vTaskEnterCritical+0x2c> @ imm = #-0x2
;   } else {
700ac5bc: e000         	b	0x700ac5c0 <vTaskEnterCritical+0x30> @ imm = #0x0
700ac5be: e7ff         	b	0x700ac5c0 <vTaskEnterCritical+0x30> @ imm = #-0x2
; }
700ac5c0: 4770         	bx	lr
		...
700ac5ce: 0000         	movs	r0, r0

700ac5d0 <xQueueCreateMutexStatic>:
;     {
700ac5d0: b580         	push	{r7, lr}
700ac5d2: b086         	sub	sp, #0x18
700ac5d4: f88d 0017    	strb.w	r0, [sp, #0x17]
700ac5d8: 9104         	str	r1, [sp, #0x10]
700ac5da: 2001         	movs	r0, #0x1
;         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
700ac5dc: 9002         	str	r0, [sp, #0x8]
700ac5de: 2200         	movs	r2, #0x0
700ac5e0: 9201         	str	r2, [sp, #0x4]
;         ( void ) ucQueueType;
700ac5e2: f89d 1017    	ldrb.w	r1, [sp, #0x17]
;         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
700ac5e6: 9b04         	ldr	r3, [sp, #0x10]
700ac5e8: 46ec         	mov	r12, sp
700ac5ea: f8cc 1000    	str.w	r1, [r12]
700ac5ee: 4611         	mov	r1, r2
700ac5f0: f7fe ff26    	bl	0x700ab440 <xQueueGenericCreateStatic> @ imm = #-0x11b4
700ac5f4: 9003         	str	r0, [sp, #0xc]
;         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
700ac5f6: 9803         	ldr	r0, [sp, #0xc]
700ac5f8: f000 fa1a    	bl	0x700aca30 <prvInitialiseMutex> @ imm = #0x434
;         return xNewQueue;
700ac5fc: 9803         	ldr	r0, [sp, #0xc]
700ac5fe: b006         	add	sp, #0x18
700ac600: bd80         	pop	{r7, pc}
		...
700ac60e: 0000         	movs	r0, r0

700ac610 <CSL_pktdmaGetChanPeerReg>:
; {
700ac610: b510         	push	{r4, lr}
700ac612: b086         	sub	sp, #0x18
700ac614: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ac618: 9005         	str	r0, [sp, #0x14]
700ac61a: 9104         	str	r1, [sp, #0x10]
700ac61c: 9203         	str	r2, [sp, #0xc]
700ac61e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)true );
700ac620: 9805         	ldr	r0, [sp, #0x14]
700ac622: 9904         	ldr	r1, [sp, #0x10]
700ac624: 9a02         	ldr	r2, [sp, #0x8]
700ac626: 9b08         	ldr	r3, [sp, #0x20]
700ac628: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ac62c: 46ee         	mov	lr, sp
700ac62e: 2401         	movs	r4, #0x1
700ac630: f8ce 4004    	str.w	r4, [lr, #0x4]
700ac634: f8ce c000    	str.w	r12, [lr]
700ac638: f7f9 f93a    	bl	0x700a58b0 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6d8c
700ac63c: b006         	add	sp, #0x18
700ac63e: bd10         	pop	{r4, pc}

700ac640 <CSL_pktdmaSetChanPeerReg>:
; {
700ac640: b510         	push	{r4, lr}
700ac642: b086         	sub	sp, #0x18
700ac644: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ac648: 9005         	str	r0, [sp, #0x14]
700ac64a: 9104         	str	r1, [sp, #0x10]
700ac64c: 9203         	str	r2, [sp, #0xc]
700ac64e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)false );
700ac650: 9805         	ldr	r0, [sp, #0x14]
700ac652: 9904         	ldr	r1, [sp, #0x10]
700ac654: 9a02         	ldr	r2, [sp, #0x8]
700ac656: 9b08         	ldr	r3, [sp, #0x20]
700ac658: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ac65c: 46ee         	mov	lr, sp
700ac65e: 2400         	movs	r4, #0x0
700ac660: f8ce 4004    	str.w	r4, [lr, #0x4]
700ac664: f8ce c000    	str.w	r12, [lr]
700ac668: f7f9 f922    	bl	0x700a58b0 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6dbc
700ac66c: b006         	add	sp, #0x18
700ac66e: bd10         	pop	{r4, pc}

700ac670 <UART_flowCtrlTrigLvlConfig>:
; {
700ac670: b580         	push	{r7, lr}
700ac672: b084         	sub	sp, #0x10
700ac674: 9003         	str	r0, [sp, #0xc]
700ac676: 9102         	str	r1, [sp, #0x8]
700ac678: 9201         	str	r2, [sp, #0x4]
700ac67a: 2000         	movs	r0, #0x0
;     uint32_t tcrValue = 0;
700ac67c: 9000         	str	r0, [sp]
;     tcrValue = rtsHaltFlag & UART_TCR_RX_FIFO_TRIG_HALT_MASK;
700ac67e: 9802         	ldr	r0, [sp, #0x8]
700ac680: f000 000f    	and	r0, r0, #0xf
700ac684: 9000         	str	r0, [sp]
;     tcrValue |= (rtsStartFlag <<
700ac686: 9801         	ldr	r0, [sp, #0x4]
700ac688: 0100         	lsls	r0, r0, #0x4
;                  UART_TCR_RX_FIFO_TRIG_START_SHIFT) &
700ac68a: b2c1         	uxtb	r1, r0
;     tcrValue |= (rtsStartFlag <<
700ac68c: 9800         	ldr	r0, [sp]
700ac68e: 4308         	orrs	r0, r1
700ac690: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_TCR, tcrValue);
700ac692: 9803         	ldr	r0, [sp, #0xc]
700ac694: 3018         	adds	r0, #0x18
700ac696: 9900         	ldr	r1, [sp]
700ac698: f001 f91a    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x1234
; }
700ac69c: b004         	add	sp, #0x10
700ac69e: bd80         	pop	{r7, pc}

700ac6a0 <CycleCounterP_getCount32>:
;         MRC     p15, #0, r0, c9, c13, 0  // read PMCCNTR
700ac6a0: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0
;         bx      LR
700ac6a4: e12fff1e     	bx	lr

700ac6a8 <PmuP_setup>:
;         MCR     p15, #0, r0, c9, c12, 0 // write PMCR
700ac6a8: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;         bx      LR
700ac6ac: e12fff1e     	bx	lr

700ac6b0 <PmuP_enableCounters>:
;         MCR     p15, #0, r0, c9, c12, 1  // write PMCNTENSET
700ac6b0: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;         bx      LR
700ac6b4: e12fff1e     	bx	lr

700ac6b8 <PmuP_disableCounters>:
;         MCR     p15, #0, r0, c9, c12, 2  // write PMCNTENCLR
700ac6b8: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2
;         bx      LR
700ac6bc: e12fff1e     	bx	lr

700ac6c0 <PmuP_getOverflowStatus>:
;         MRC     p15, 0, r0, c9, c12, 3  // read PMOVSR
700ac6c0: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ac6c4: e12fff1e     	bx	lr

700ac6c8 <PmuP_clearOverflowStatus>:
;         MCR     p15, 0, r0, c9, c12, 3  // write PMOVSR
700ac6c8: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ac6cc: e12fff1e     	bx	lr

700ac6d0 <CSL_secProxyGetMaxMsgSize>:
; {
700ac6d0: b580         	push	{r7, lr}
700ac6d2: b082         	sub	sp, #0x8
700ac6d4: 9001         	str	r0, [sp, #0x4]
;     if( pSecProxyCfg->maxMsgSize == (uint32_t)0U )
700ac6d6: 9801         	ldr	r0, [sp, #0x4]
700ac6d8: 6980         	ldr	r0, [r0, #0x18]
700ac6da: b960         	cbnz	r0, 0x700ac6f6 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #0x18
700ac6dc: e7ff         	b	0x700ac6de <CSL_secProxyGetMaxMsgSize+0xe> @ imm = #-0x2
;         pSecProxyCfg->maxMsgSize = (uint32_t)CSL_REG32_FEXT( &pSecProxyCfg->pSecProxyRegs->CONFIG, SEC_PROXY_CONFIG_MSG_SIZE );
700ac6de: 9801         	ldr	r0, [sp, #0x4]
700ac6e0: 6800         	ldr	r0, [r0]
700ac6e2: 3004         	adds	r0, #0x4
700ac6e4: 2100         	movs	r1, #0x0
700ac6e6: f6cf 71ff    	movt	r1, #0xffff
700ac6ea: 2210         	movs	r2, #0x10
700ac6ec: f000 fc10    	bl	0x700acf10 <CSL_REG32_FEXT_RAW> @ imm = #0x820
700ac6f0: 9901         	ldr	r1, [sp, #0x4]
700ac6f2: 6188         	str	r0, [r1, #0x18]
;     }
700ac6f4: e7ff         	b	0x700ac6f6 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #-0x2
;     return pSecProxyCfg->maxMsgSize;
700ac6f6: 9801         	ldr	r0, [sp, #0x4]
700ac6f8: 6980         	ldr	r0, [r0, #0x18]
700ac6fa: b002         	add	sp, #0x8
700ac6fc: bd80         	pop	{r7, pc}
700ac6fe: 0000         	movs	r0, r0

700ac700 <Sciclient_rmIaIsIa>:
; {
700ac700: b580         	push	{r7, lr}
700ac702: b082         	sub	sp, #0x8
700ac704: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ac708: 2000         	movs	r0, #0x0
;     bool r = false;
700ac70a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIaGetInst(id) != NULL) {
700ac70e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac712: f7fd fe9d    	bl	0x700aa450 <Sciclient_rmIaGetInst> @ imm = #-0x22c6
700ac716: b120         	cbz	r0, 0x700ac722 <Sciclient_rmIaIsIa+0x22> @ imm = #0x8
700ac718: e7ff         	b	0x700ac71a <Sciclient_rmIaIsIa+0x1a> @ imm = #-0x2
700ac71a: 2001         	movs	r0, #0x1
;         r = true;
700ac71c: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ac720: e7ff         	b	0x700ac722 <Sciclient_rmIaIsIa+0x22> @ imm = #-0x2
;     return r;
700ac722: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ac726: f000 0001    	and	r0, r0, #0x1
700ac72a: b002         	add	sp, #0x8
700ac72c: bd80         	pop	{r7, pc}
700ac72e: 0000         	movs	r0, r0

700ac730 <Sciclient_rmIrIsIr>:
; {
700ac730: b580         	push	{r7, lr}
700ac732: b082         	sub	sp, #0x8
700ac734: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ac738: 2000         	movs	r0, #0x0
;     bool r = false;
700ac73a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIrGetInst(id) != NULL) {
700ac73e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac742: f7fd f96d    	bl	0x700a9a20 <Sciclient_rmIrGetInst> @ imm = #-0x2d26
700ac746: b120         	cbz	r0, 0x700ac752 <Sciclient_rmIrIsIr+0x22> @ imm = #0x8
700ac748: e7ff         	b	0x700ac74a <Sciclient_rmIrIsIr+0x1a> @ imm = #-0x2
700ac74a: 2001         	movs	r0, #0x1
;         r = true;
700ac74c: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ac750: e7ff         	b	0x700ac752 <Sciclient_rmIrIsIr+0x22> @ imm = #-0x2
;     return r;
700ac752: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ac756: f000 0001    	and	r0, r0, #0x1
700ac75a: b002         	add	sp, #0x8
700ac75c: bd80         	pop	{r7, pc}
700ac75e: 0000         	movs	r0, r0

700ac760 <Sciclient_secProxyReadThread32>:
; {
700ac760: b580         	push	{r7, lr}
700ac762: b084         	sub	sp, #0x10
700ac764: 9003         	str	r0, [sp, #0xc]
700ac766: f88d 100b    	strb.w	r1, [sp, #0xb]
;     ret = CSL_REG32_RD(CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg,thread,0U) +
700ac76a: 9903         	ldr	r1, [sp, #0xc]
700ac76c: f240 30c8    	movw	r0, #0x3c8
700ac770: f2c7 000b    	movt	r0, #0x700b
700ac774: 2200         	movs	r2, #0x0
700ac776: f000 fdb3    	bl	0x700ad2e0 <CSL_secProxyGetDataAddr> @ imm = #0xb66
700ac77a: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700ac77e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ac782: f001 f8fd    	bl	0x700ad980 <CSL_REG32_RD_RAW> @ imm = #0x11fa
700ac786: 9001         	str	r0, [sp, #0x4]
;     return ret;
700ac788: 9801         	ldr	r0, [sp, #0x4]
700ac78a: b004         	add	sp, #0x10
700ac78c: bd80         	pop	{r7, pc}
700ac78e: 0000         	movs	r0, r0

700ac790 <System_init>:
; {
700ac790: b580         	push	{r7, lr}
;     Dpl_init();
700ac792: f7fe ff6d    	bl	0x700ab670 <Dpl_init>   @ imm = #-0x1126
;         retVal = Sciclient_init(CSL_CORE_ID_R5FSS0_0);
700ac796: 2001         	movs	r0, #0x1
700ac798: f7fa fe8a    	bl	0x700a74b0 <Sciclient_init> @ imm = #-0x52ec
;         DebugP_assertNoLog(SystemP_SUCCESS == retVal);
700ac79c: fab0 f080    	clz	r0, r0
700ac7a0: 0940         	lsrs	r0, r0, #0x5
700ac7a2: f002 fc25    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x284a
;     CycleCounterP_init(SOC_getSelfCpuClk());
700ac7a6: f000 fbe3    	bl	0x700acf70 <SOC_getSelfCpuClk> @ imm = #0x7c6
700ac7aa: f7f9 fe79    	bl	0x700a64a0 <CycleCounterP_init> @ imm = #-0x630e
;     PowerClock_init();
700ac7ae: f7fb ff0f    	bl	0x700a85d0 <PowerClock_init> @ imm = #-0x41e2
;     Pinmux_init();
700ac7b2: f000 fc4d    	bl	0x700ad050 <Pinmux_init> @ imm = #0x89a
;     UART_init();
700ac7b6: e8bd 4080    	pop.w	{r7, lr}
700ac7ba: f7f9 b9f9    	b.w	0x700a5bb0 <UART_init>  @ imm = #-0x6c0e
700ac7be: 0000         	movs	r0, r0

700ac7c0 <_is_digit>:
; {
700ac7c0: b082         	sub	sp, #0x8
700ac7c2: f88d 0007    	strb.w	r0, [sp, #0x7]
;   return (ch >= '0') && (ch <= '9');
700ac7c6: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ac7ca: 2000         	movs	r0, #0x0
700ac7cc: 2930         	cmp	r1, #0x30
700ac7ce: 9000         	str	r0, [sp]
700ac7d0: db08         	blt	0x700ac7e4 <_is_digit+0x24> @ imm = #0x10
700ac7d2: e7ff         	b	0x700ac7d4 <_is_digit+0x14> @ imm = #-0x2
700ac7d4: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ac7d8: 2000         	movs	r0, #0x0
700ac7da: 293a         	cmp	r1, #0x3a
700ac7dc: bfb8         	it	lt
700ac7de: 2001         	movlt	r0, #0x1
700ac7e0: 9000         	str	r0, [sp]
700ac7e2: e7ff         	b	0x700ac7e4 <_is_digit+0x24> @ imm = #-0x2
700ac7e4: 9800         	ldr	r0, [sp]
;   return (ch >= '0') && (ch <= '9');
700ac7e6: f000 0001    	and	r0, r0, #0x1
700ac7ea: b002         	add	sp, #0x8
700ac7ec: 4770         	bx	lr
700ac7ee: 0000         	movs	r0, r0

700ac7f0 <prvIsQueueFull>:
; {
700ac7f0: b580         	push	{r7, lr}
700ac7f2: b082         	sub	sp, #0x8
700ac7f4: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700ac7f6: f7ff fecb    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #-0x26a
;         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
700ac7fa: 9801         	ldr	r0, [sp, #0x4]
700ac7fc: 6b80         	ldr	r0, [r0, #0x38]
700ac7fe: 9901         	ldr	r1, [sp, #0x4]
700ac800: 6bc9         	ldr	r1, [r1, #0x3c]
700ac802: 4288         	cmp	r0, r1
700ac804: d103         	bne	0x700ac80e <prvIsQueueFull+0x1e> @ imm = #0x6
700ac806: e7ff         	b	0x700ac808 <prvIsQueueFull+0x18> @ imm = #-0x2
700ac808: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700ac80a: 9000         	str	r0, [sp]
;         }
700ac80c: e002         	b	0x700ac814 <prvIsQueueFull+0x24> @ imm = #0x4
700ac80e: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700ac810: 9000         	str	r0, [sp]
700ac812: e7ff         	b	0x700ac814 <prvIsQueueFull+0x24> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700ac814: f7fe ff7c    	bl	0x700ab710 <vTaskExitCritical> @ imm = #-0x1108
;     return xReturn;
700ac818: 9800         	ldr	r0, [sp]
700ac81a: b002         	add	sp, #0x8
700ac81c: bd80         	pop	{r7, pc}
700ac81e: 0000         	movs	r0, r0

700ac820 <prvTaskCheckFreeStackSpace>:
; prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte) {
700ac820: b082         	sub	sp, #0x8
700ac822: 9001         	str	r0, [sp, #0x4]
700ac824: 2000         	movs	r0, #0x0
;   uint32_t ulCount = 0U;
700ac826: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700ac828: e7ff         	b	0x700ac82a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x2
700ac82a: 9801         	ldr	r0, [sp, #0x4]
700ac82c: 7800         	ldrb	r0, [r0]
700ac82e: 28a5         	cmp	r0, #0xa5
700ac830: d107         	bne	0x700ac842 <prvTaskCheckFreeStackSpace+0x22> @ imm = #0xe
700ac832: e7ff         	b	0x700ac834 <prvTaskCheckFreeStackSpace+0x14> @ imm = #-0x2
;     pucStackByte -= portSTACK_GROWTH;
700ac834: 9801         	ldr	r0, [sp, #0x4]
700ac836: 3001         	adds	r0, #0x1
700ac838: 9001         	str	r0, [sp, #0x4]
;     ulCount++;
700ac83a: 9800         	ldr	r0, [sp]
700ac83c: 3001         	adds	r0, #0x1
700ac83e: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700ac840: e7f3         	b	0x700ac82a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x1a
;   ulCount /=
700ac842: 9800         	ldr	r0, [sp]
700ac844: 0880         	lsrs	r0, r0, #0x2
700ac846: 9000         	str	r0, [sp]
;   return (configSTACK_DEPTH_TYPE)ulCount;
700ac848: 9800         	ldr	r0, [sp]
700ac84a: b002         	add	sp, #0x8
700ac84c: 4770         	bx	lr
700ac84e: 0000         	movs	r0, r0

700ac850 <tm_queue_send_from_isr>:
; {
700ac850: b580         	push	{r7, lr}
700ac852: b082         	sub	sp, #0x8
;    status = xQueueSendToBackFromISR(tm_queue_array[queue_id], (const void*) message_ptr, &xHigherPriorityTaskWoken);
700ac854: f644 72d0    	movw	r2, #0x4fd0
700ac858: 2300         	movs	r3, #0x0
700ac85a: f2c7 0208    	movt	r2, #0x7008
700ac85e: f852 0020    	ldr.w	r0, [r2, r0, lsl #2]
700ac862: aa01         	add	r2, sp, #0x4
;    status = xQueueSendToBackFromISR(tm_queue_array[queue_id], (const void*) message_ptr, &xHigherPriorityTaskWoken);
700ac864: f7fa f824    	bl	0x700a68b0 <xQueueGenericSendFromISR> @ imm = #-0x5fb8
;    if (status != pdTRUE)
700ac868: 2801         	cmp	r0, #0x1
700ac86a: d105         	bne	0x700ac878 <tm_queue_send_from_isr+0x28> @ imm = #0xa
;    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
700ac86c: 9801         	ldr	r0, [sp, #0x4]
700ac86e: f000 fd67    	bl	0x700ad340 <vPortYeildFromISR> @ imm = #0xace
700ac872: 2000         	movs	r0, #0x0
; }
700ac874: b002         	add	sp, #0x8
700ac876: bd80         	pop	{r7, pc}
700ac878: 2001         	movs	r0, #0x1
; }
700ac87a: b002         	add	sp, #0x8
700ac87c: bd80         	pop	{r7, pc}
700ac87e: 0000         	movs	r0, r0

700ac880 <vListInitialise>:
; {
700ac880: b081         	sub	sp, #0x4
700ac882: 9000         	str	r0, [sp]
;     pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ac884: 9900         	ldr	r1, [sp]
700ac886: f101 0008    	add.w	r0, r1, #0x8
700ac88a: 6048         	str	r0, [r1, #0x4]
;     pxList->xListEnd.xItemValue = portMAX_DELAY;
700ac88c: 9900         	ldr	r1, [sp]
700ac88e: f04f 30ff    	mov.w	r0, #0xffffffff
700ac892: 6088         	str	r0, [r1, #0x8]
;     pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ac894: 9900         	ldr	r1, [sp]
700ac896: f101 0008    	add.w	r0, r1, #0x8
700ac89a: 60c8         	str	r0, [r1, #0xc]
;     pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ac89c: 9900         	ldr	r1, [sp]
700ac89e: f101 0008    	add.w	r0, r1, #0x8
700ac8a2: 6108         	str	r0, [r1, #0x10]
;     pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
700ac8a4: 9900         	ldr	r1, [sp]
700ac8a6: 2000         	movs	r0, #0x0
700ac8a8: 6008         	str	r0, [r1]
; }
700ac8aa: b001         	add	sp, #0x4
700ac8ac: 4770         	bx	lr
700ac8ae: 0000         	movs	r0, r0

700ac8b0 <CSL_bcdmaGetRxRT>:
; {
700ac8b0: b580         	push	{r7, lr}
700ac8b2: b084         	sub	sp, #0x10
700ac8b4: 9003         	str	r0, [sp, #0xc]
700ac8b6: 9102         	str	r1, [sp, #0x8]
700ac8b8: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700ac8ba: 9803         	ldr	r0, [sp, #0xc]
700ac8bc: 9a02         	ldr	r2, [sp, #0x8]
700ac8be: 9b01         	ldr	r3, [sp, #0x4]
700ac8c0: 2107         	movs	r1, #0x7
700ac8c2: f7fc fb2d    	bl	0x700a8f20 <CSL_bcdmaDoChanOp> @ imm = #-0x39a6
700ac8c6: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ac8c8: 9800         	ldr	r0, [sp]
700ac8ca: b120         	cbz	r0, 0x700ac8d6 <CSL_bcdmaGetRxRT+0x26> @ imm = #0x8
700ac8cc: e7ff         	b	0x700ac8ce <CSL_bcdmaGetRxRT+0x1e> @ imm = #-0x2
700ac8ce: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ac8d2: 9000         	str	r0, [sp]
;     }
700ac8d4: e7ff         	b	0x700ac8d6 <CSL_bcdmaGetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700ac8d6: 9800         	ldr	r0, [sp]
700ac8d8: b004         	add	sp, #0x10
700ac8da: bd80         	pop	{r7, pc}
700ac8dc: 0000         	movs	r0, r0
700ac8de: 0000         	movs	r0, r0

700ac8e0 <CSL_bcdmaGetTxRT>:
; {
700ac8e0: b580         	push	{r7, lr}
700ac8e2: b084         	sub	sp, #0x10
700ac8e4: 9003         	str	r0, [sp, #0xc]
700ac8e6: 9102         	str	r1, [sp, #0x8]
700ac8e8: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700ac8ea: 9803         	ldr	r0, [sp, #0xc]
700ac8ec: 9a02         	ldr	r2, [sp, #0x8]
700ac8ee: 9b01         	ldr	r3, [sp, #0x4]
700ac8f0: 2107         	movs	r1, #0x7
700ac8f2: f7fc fb15    	bl	0x700a8f20 <CSL_bcdmaDoChanOp> @ imm = #-0x39d6
700ac8f6: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ac8f8: 9800         	ldr	r0, [sp]
700ac8fa: b120         	cbz	r0, 0x700ac906 <CSL_bcdmaGetTxRT+0x26> @ imm = #0x8
700ac8fc: e7ff         	b	0x700ac8fe <CSL_bcdmaGetTxRT+0x1e> @ imm = #-0x2
700ac8fe: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ac902: 9000         	str	r0, [sp]
;     }
700ac904: e7ff         	b	0x700ac906 <CSL_bcdmaGetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700ac906: 9800         	ldr	r0, [sp]
700ac908: b004         	add	sp, #0x10
700ac90a: bd80         	pop	{r7, pc}
700ac90c: 0000         	movs	r0, r0
700ac90e: 0000         	movs	r0, r0

700ac910 <CSL_bcdmaSetRxRT>:
; {
700ac910: b580         	push	{r7, lr}
700ac912: b084         	sub	sp, #0x10
700ac914: 9003         	str	r0, [sp, #0xc]
700ac916: 9102         	str	r1, [sp, #0x8]
700ac918: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700ac91a: 9803         	ldr	r0, [sp, #0xc]
700ac91c: 9a02         	ldr	r2, [sp, #0x8]
700ac91e: 9b01         	ldr	r3, [sp, #0x4]
700ac920: 2108         	movs	r1, #0x8
700ac922: f7fc fafd    	bl	0x700a8f20 <CSL_bcdmaDoChanOp> @ imm = #-0x3a06
700ac926: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ac928: 9800         	ldr	r0, [sp]
700ac92a: b120         	cbz	r0, 0x700ac936 <CSL_bcdmaSetRxRT+0x26> @ imm = #0x8
700ac92c: e7ff         	b	0x700ac92e <CSL_bcdmaSetRxRT+0x1e> @ imm = #-0x2
700ac92e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ac932: 9000         	str	r0, [sp]
;     }
700ac934: e7ff         	b	0x700ac936 <CSL_bcdmaSetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700ac936: 9800         	ldr	r0, [sp]
700ac938: b004         	add	sp, #0x10
700ac93a: bd80         	pop	{r7, pc}
700ac93c: 0000         	movs	r0, r0
700ac93e: 0000         	movs	r0, r0

700ac940 <CSL_bcdmaSetTxRT>:
; {
700ac940: b580         	push	{r7, lr}
700ac942: b084         	sub	sp, #0x10
700ac944: 9003         	str	r0, [sp, #0xc]
700ac946: 9102         	str	r1, [sp, #0x8]
700ac948: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700ac94a: 9803         	ldr	r0, [sp, #0xc]
700ac94c: 9a02         	ldr	r2, [sp, #0x8]
700ac94e: 9b01         	ldr	r3, [sp, #0x4]
700ac950: 2108         	movs	r1, #0x8
700ac952: f7fc fae5    	bl	0x700a8f20 <CSL_bcdmaDoChanOp> @ imm = #-0x3a36
700ac956: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ac958: 9800         	ldr	r0, [sp]
700ac95a: b120         	cbz	r0, 0x700ac966 <CSL_bcdmaSetTxRT+0x26> @ imm = #0x8
700ac95c: e7ff         	b	0x700ac95e <CSL_bcdmaSetTxRT+0x1e> @ imm = #-0x2
700ac95e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ac962: 9000         	str	r0, [sp]
;     }
700ac964: e7ff         	b	0x700ac966 <CSL_bcdmaSetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700ac966: 9800         	ldr	r0, [sp]
700ac968: b004         	add	sp, #0x10
700ac96a: bd80         	pop	{r7, pc}
700ac96c: 0000         	movs	r0, r0
700ac96e: 0000         	movs	r0, r0

700ac970 <DebugP_logZoneEnable>:
; {
700ac970: b580         	push	{r7, lr}
700ac972: b084         	sub	sp, #0x10
700ac974: 9003         	str	r0, [sp, #0xc]
;     oldIntState = HwiP_disable();
700ac976: f001 ee7c    	blx	0x700ae670 <HwiP_disable> @ imm = #0x1cf8
700ac97a: 9001         	str	r0, [sp, #0x4]
;     oldZoneMask = gDebugLogZone;
700ac97c: f240 41b0    	movw	r1, #0x4b0
700ac980: f2c7 010b    	movt	r1, #0x700b
700ac984: 6808         	ldr	r0, [r1]
700ac986: 9002         	str	r0, [sp, #0x8]
;     gDebugLogZone = gDebugLogZone | (logZoneMask);
700ac988: 6808         	ldr	r0, [r1]
700ac98a: 9a03         	ldr	r2, [sp, #0xc]
700ac98c: 4310         	orrs	r0, r2
700ac98e: 6008         	str	r0, [r1]
;     HwiP_restore(oldIntState);
700ac990: 9801         	ldr	r0, [sp, #0x4]
700ac992: f001 ee8e    	blx	0x700ae6b0 <HwiP_restore> @ imm = #0x1d1c
;     return oldZoneMask;
700ac996: 9802         	ldr	r0, [sp, #0x8]
700ac998: b004         	add	sp, #0x10
700ac99a: bd80         	pop	{r7, pc}
700ac99c: 0000         	movs	r0, r0
700ac99e: 0000         	movs	r0, r0

700ac9a0 <Sciclient_getIrAddr>:
; {
700ac9a0: b580         	push	{r7, lr}
700ac9a2: b084         	sub	sp, #0x10
700ac9a4: 9003         	str	r0, [sp, #0xc]
700ac9a6: 9102         	str	r1, [sp, #0x8]
;     int_ctrl_reg = (uint32_t *)(addr + Sciclient_rmIrIntControlReg(i));
700ac9a8: 9803         	ldr	r0, [sp, #0xc]
700ac9aa: 9000         	str	r0, [sp]
700ac9ac: f8bd 0008    	ldrh.w	r0, [sp, #0x8]
700ac9b0: f000 fe8e    	bl	0x700ad6d0 <Sciclient_rmIrIntControlReg> @ imm = #0xd1c
700ac9b4: 4601         	mov	r1, r0
700ac9b6: 9800         	ldr	r0, [sp]
700ac9b8: 4408         	add	r0, r1
700ac9ba: 9001         	str	r0, [sp, #0x4]
;     int_ctrl_reg = (uint32_t *)AddrTranslateP_getLocalAddr( (uint64_t)int_ctrl_reg);
700ac9bc: 9801         	ldr	r0, [sp, #0x4]
700ac9be: 2100         	movs	r1, #0x0
700ac9c0: f7f7 fa06    	bl	0x700a3dd0 <AddrTranslateP_getLocalAddr> @ imm = #-0x8bf4
700ac9c4: 9001         	str	r0, [sp, #0x4]
;     return int_ctrl_reg;
700ac9c6: 9801         	ldr	r0, [sp, #0x4]
700ac9c8: b004         	add	sp, #0x10
700ac9ca: bd80         	pop	{r7, pc}
700ac9cc: 0000         	movs	r0, r0
700ac9ce: 0000         	movs	r0, r0

700ac9d0 <TaskP_calcCounterDiff>:
; {
700ac9d0: b083         	sub	sp, #0xc
700ac9d2: 9002         	str	r0, [sp, #0x8]
700ac9d4: 9101         	str	r1, [sp, #0x4]
;     if(cur >= last)
700ac9d6: 9802         	ldr	r0, [sp, #0x8]
700ac9d8: 9901         	ldr	r1, [sp, #0x4]
700ac9da: 4288         	cmp	r0, r1
700ac9dc: d305         	blo	0x700ac9ea <TaskP_calcCounterDiff+0x1a> @ imm = #0xa
700ac9de: e7ff         	b	0x700ac9e0 <TaskP_calcCounterDiff+0x10> @ imm = #-0x2
;         delta = cur - last;
700ac9e0: 9802         	ldr	r0, [sp, #0x8]
700ac9e2: 9901         	ldr	r1, [sp, #0x4]
700ac9e4: 1a40         	subs	r0, r0, r1
700ac9e6: 9000         	str	r0, [sp]
;     }
700ac9e8: e005         	b	0x700ac9f6 <TaskP_calcCounterDiff+0x26> @ imm = #0xa
;         delta = (  0xFFFFFFFFU - last ) + cur;
700ac9ea: 9801         	ldr	r0, [sp, #0x4]
700ac9ec: 9902         	ldr	r1, [sp, #0x8]
700ac9ee: 43c0         	mvns	r0, r0
700ac9f0: 4408         	add	r0, r1
700ac9f2: 9000         	str	r0, [sp]
700ac9f4: e7ff         	b	0x700ac9f6 <TaskP_calcCounterDiff+0x26> @ imm = #-0x2
;     return delta;
700ac9f6: 9800         	ldr	r0, [sp]
700ac9f8: b003         	add	sp, #0xc
700ac9fa: 4770         	bx	lr
700ac9fc: 0000         	movs	r0, r0
700ac9fe: 0000         	movs	r0, r0

700aca00 <TimerP_clearOverflowInt>:
; {
700aca00: b083         	sub	sp, #0xc
700aca02: 9002         	str	r0, [sp, #0x8]
700aca04: 2002         	movs	r0, #0x2
;     uint32_t value = (0x1U << TIMER_OVF_INT_SHIFT);
700aca06: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_STATUS);
700aca08: 9802         	ldr	r0, [sp, #0x8]
700aca0a: 3028         	adds	r0, #0x28
700aca0c: 9001         	str	r0, [sp, #0x4]
;     *addr = value;
700aca0e: 9800         	ldr	r0, [sp]
700aca10: 9901         	ldr	r1, [sp, #0x4]
700aca12: 6008         	str	r0, [r1]
;     if((*addr & value) != 0U)
700aca14: 9801         	ldr	r0, [sp, #0x4]
700aca16: 6800         	ldr	r0, [r0]
700aca18: 9900         	ldr	r1, [sp]
700aca1a: 4208         	tst	r0, r1
700aca1c: d004         	beq	0x700aca28 <TimerP_clearOverflowInt+0x28> @ imm = #0x8
700aca1e: e7ff         	b	0x700aca20 <TimerP_clearOverflowInt+0x20> @ imm = #-0x2
;         *addr = value;
700aca20: 9800         	ldr	r0, [sp]
700aca22: 9901         	ldr	r1, [sp, #0x4]
700aca24: 6008         	str	r0, [r1]
;     }
700aca26: e7ff         	b	0x700aca28 <TimerP_clearOverflowInt+0x28> @ imm = #-0x2
; }
700aca28: b003         	add	sp, #0xc
700aca2a: 4770         	bx	lr
700aca2c: 0000         	movs	r0, r0
700aca2e: 0000         	movs	r0, r0

700aca30 <prvInitialiseMutex>:
;     {
700aca30: b580         	push	{r7, lr}
700aca32: b082         	sub	sp, #0x8
700aca34: 9001         	str	r0, [sp, #0x4]
;         if( pxNewQueue != NULL )
700aca36: 9801         	ldr	r0, [sp, #0x4]
700aca38: b168         	cbz	r0, 0x700aca56 <prvInitialiseMutex+0x26> @ imm = #0x1a
700aca3a: e7ff         	b	0x700aca3c <prvInitialiseMutex+0xc> @ imm = #-0x2
;             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
700aca3c: 9801         	ldr	r0, [sp, #0x4]
700aca3e: 2300         	movs	r3, #0x0
700aca40: 6083         	str	r3, [r0, #0x8]
;             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
700aca42: 9801         	ldr	r0, [sp, #0x4]
700aca44: 6003         	str	r3, [r0]
;             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
700aca46: 9801         	ldr	r0, [sp, #0x4]
700aca48: 60c3         	str	r3, [r0, #0xc]
;             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
700aca4a: 9801         	ldr	r0, [sp, #0x4]
700aca4c: 4619         	mov	r1, r3
700aca4e: 461a         	mov	r2, r3
700aca50: f7f4 fd9e    	bl	0x700a1590 <xQueueGenericSend> @ imm = #-0xb4c4
;         }
700aca54: e000         	b	0x700aca58 <prvInitialiseMutex+0x28> @ imm = #0x0
700aca56: e7ff         	b	0x700aca58 <prvInitialiseMutex+0x28> @ imm = #-0x2
;     }
700aca58: b002         	add	sp, #0x8
700aca5a: bd80         	pop	{r7, pc}
700aca5c: 0000         	movs	r0, r0
700aca5e: 0000         	movs	r0, r0

700aca60 <pvTaskIncrementMutexHeldCount>:
;   if (pxCurrentTCB != NULL) {
700aca60: f240 40dc    	movw	r0, #0x4dc
700aca64: f2c7 000b    	movt	r0, #0x700b
700aca68: 6800         	ldr	r0, [r0]
700aca6a: b148         	cbz	r0, 0x700aca80 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #0x12
700aca6c: e7ff         	b	0x700aca6e <pvTaskIncrementMutexHeldCount+0xe> @ imm = #-0x2
;     (pxCurrentTCB->uxMutexesHeld)++;
700aca6e: f240 40dc    	movw	r0, #0x4dc
700aca72: f2c7 000b    	movt	r0, #0x700b
700aca76: 6801         	ldr	r1, [r0]
700aca78: 6e48         	ldr	r0, [r1, #0x64]
700aca7a: 3001         	adds	r0, #0x1
700aca7c: 6648         	str	r0, [r1, #0x64]
;   }
700aca7e: e7ff         	b	0x700aca80 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #-0x2
;   return pxCurrentTCB;
700aca80: f240 40dc    	movw	r0, #0x4dc
700aca84: f2c7 000b    	movt	r0, #0x700b
700aca88: 6800         	ldr	r0, [r0]
700aca8a: 4770         	bx	lr
700aca8c: 0000         	movs	r0, r0
700aca8e: 0000         	movs	r0, r0

700aca90 <vApplicationGetIdleTaskMemory>:
;                                    uint32_t *pulIdleTaskStackSize) {
700aca90: b083         	sub	sp, #0xc
700aca92: 9002         	str	r0, [sp, #0x8]
700aca94: 9101         	str	r1, [sp, #0x4]
700aca96: 9200         	str	r2, [sp]
;   *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
700aca98: 9902         	ldr	r1, [sp, #0x8]
700aca9a: f644 40b0    	movw	r0, #0x4cb0
700aca9e: f2c7 0008    	movt	r0, #0x7008
700acaa2: 6008         	str	r0, [r1]
;   *ppxIdleTaskStackBuffer = uxIdleTaskStack;
700acaa4: 9901         	ldr	r1, [sp, #0x4]
700acaa6: f242 0080    	movw	r0, #0x2080
700acaaa: f2c7 0008    	movt	r0, #0x7008
700acaae: 6008         	str	r0, [r1]
;   *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
700acab0: 9900         	ldr	r1, [sp]
700acab2: f44f 6080    	mov.w	r0, #0x400
700acab6: 6008         	str	r0, [r1]
; }
700acab8: b003         	add	sp, #0xc
700acaba: 4770         	bx	lr
700acabc: 0000         	movs	r0, r0
700acabe: 0000         	movs	r0, r0

700acac0 <vApplicationGetTimerTaskMemory>:
;                                     uint32_t *pulTimerTaskStackSize) {
700acac0: b083         	sub	sp, #0xc
700acac2: 9002         	str	r0, [sp, #0x8]
700acac4: 9101         	str	r1, [sp, #0x4]
700acac6: 9200         	str	r2, [sp]
;   *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
700acac8: 9902         	ldr	r1, [sp, #0x8]
700acaca: f644 503c    	movw	r0, #0x4d3c
700acace: f2c7 0008    	movt	r0, #0x7008
700acad2: 6008         	str	r0, [r1]
;   *ppxTimerTaskStackBuffer = uxTimerTaskStack;
700acad4: 9901         	ldr	r1, [sp, #0x4]
700acad6: f643 508c    	movw	r0, #0x3d8c
700acada: f2c7 0008    	movt	r0, #0x7008
700acade: 6008         	str	r0, [r1]
;   *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
700acae0: 9900         	ldr	r1, [sp]
700acae2: f44f 7080    	mov.w	r0, #0x100
700acae6: 6008         	str	r0, [r1]
; }
700acae8: b003         	add	sp, #0xc
700acaea: 4770         	bx	lr
700acaec: 0000         	movs	r0, r0
700acaee: 0000         	movs	r0, r0

700acaf0 <Sciclient_rmParamIsValid>:
; {
700acaf0: b083         	sub	sp, #0xc
700acaf2: 9002         	str	r0, [sp, #0x8]
700acaf4: 9101         	str	r1, [sp, #0x4]
700acaf6: 2000         	movs	r0, #0x0
;     bool r = false;
700acaf8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((valid_params & param_mask) != 0) {
700acafc: 9802         	ldr	r0, [sp, #0x8]
700acafe: 9901         	ldr	r1, [sp, #0x4]
700acb00: 4208         	tst	r0, r1
700acb02: d004         	beq	0x700acb0e <Sciclient_rmParamIsValid+0x1e> @ imm = #0x8
700acb04: e7ff         	b	0x700acb06 <Sciclient_rmParamIsValid+0x16> @ imm = #-0x2
700acb06: 2001         	movs	r0, #0x1
;         r = true;
700acb08: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700acb0c: e7ff         	b	0x700acb0e <Sciclient_rmParamIsValid+0x1e> @ imm = #-0x2
;     return r;
700acb0e: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700acb12: f000 0001    	and	r0, r0, #0x1
700acb16: b003         	add	sp, #0xc
700acb18: 4770         	bx	lr
700acb1a: 0000         	movs	r0, r0
700acb1c: 0000         	movs	r0, r0
700acb1e: 0000         	movs	r0, r0

700acb20 <Sciclient_rmPsIsEmpty>:
; {
700acb20: b081         	sub	sp, #0x4
700acb22: 2001         	movs	r0, #0x1
;     bool e = true;
700acb24: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if (gPstack.psp != 0) {
700acb28: f241 0058    	movw	r0, #0x1058
700acb2c: f2c7 0008    	movt	r0, #0x7008
700acb30: 8c80         	ldrh	r0, [r0, #0x24]
700acb32: b120         	cbz	r0, 0x700acb3e <Sciclient_rmPsIsEmpty+0x1e> @ imm = #0x8
700acb34: e7ff         	b	0x700acb36 <Sciclient_rmPsIsEmpty+0x16> @ imm = #-0x2
700acb36: 2000         	movs	r0, #0x0
;         e = false;
700acb38: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700acb3c: e7ff         	b	0x700acb3e <Sciclient_rmPsIsEmpty+0x1e> @ imm = #-0x2
;     return e;
700acb3e: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700acb42: f000 0001    	and	r0, r0, #0x1
700acb46: b001         	add	sp, #0x4
700acb48: 4770         	bx	lr
700acb4a: 0000         	movs	r0, r0
700acb4c: 0000         	movs	r0, r0
700acb4e: 0000         	movs	r0, r0

700acb50 <UART_Transaction_init>:
; {
700acb50: b081         	sub	sp, #0x4
700acb52: 9000         	str	r0, [sp]
;     if(trans != NULL)
700acb54: 9800         	ldr	r0, [sp]
700acb56: b170         	cbz	r0, 0x700acb76 <UART_Transaction_init+0x26> @ imm = #0x1c
700acb58: e7ff         	b	0x700acb5a <UART_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700acb5a: 9900         	ldr	r1, [sp]
700acb5c: 2000         	movs	r0, #0x0
700acb5e: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700acb60: 9900         	ldr	r1, [sp]
700acb62: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = SystemP_WAIT_FOREVER;
700acb64: 9a00         	ldr	r2, [sp]
700acb66: f04f 31ff    	mov.w	r1, #0xffffffff
700acb6a: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700acb6c: 9900         	ldr	r1, [sp]
700acb6e: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700acb70: 9900         	ldr	r1, [sp]
700acb72: 6108         	str	r0, [r1, #0x10]
;     }
700acb74: e7ff         	b	0x700acb76 <UART_Transaction_init+0x26> @ imm = #-0x2
; }
700acb76: b001         	add	sp, #0x4
700acb78: 4770         	bx	lr
700acb7a: 0000         	movs	r0, r0
700acb7c: 0000         	movs	r0, r0
700acb7e: 0000         	movs	r0, r0

700acb80 <UART_intr2Disable>:
; {
700acb80: b580         	push	{r7, lr}
700acb82: b084         	sub	sp, #0x10
700acb84: 9003         	str	r0, [sp, #0xc]
700acb86: 9102         	str	r1, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_IER2, HW_RD_REG32(baseAddr + UART_IER2) &
700acb88: 9803         	ldr	r0, [sp, #0xc]
700acb8a: 306c         	adds	r0, #0x6c
700acb8c: 9001         	str	r0, [sp, #0x4]
700acb8e: f000 fe97    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0xd2e
700acb92: 4601         	mov	r1, r0
700acb94: 9801         	ldr	r0, [sp, #0x4]
700acb96: 9b02         	ldr	r3, [sp, #0x8]
700acb98: f06f 0203    	mvn	r2, #0x3
700acb9c: ea62 0203    	orn	r2, r2, r3
700acba0: 4011         	ands	r1, r2
700acba2: f000 fe95    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0xd2a
; }
700acba6: b004         	add	sp, #0x10
700acba8: bd80         	pop	{r7, pc}
700acbaa: 0000         	movs	r0, r0
700acbac: 0000         	movs	r0, r0
700acbae: 0000         	movs	r0, r0

700acbb0 <UART_lld_Transaction_init>:
; {
700acbb0: b081         	sub	sp, #0x4
700acbb2: 9000         	str	r0, [sp]
;     if(trans != NULL)
700acbb4: 9800         	ldr	r0, [sp]
700acbb6: b170         	cbz	r0, 0x700acbd6 <UART_lld_Transaction_init+0x26> @ imm = #0x1c
700acbb8: e7ff         	b	0x700acbba <UART_lld_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700acbba: 9900         	ldr	r1, [sp]
700acbbc: 2000         	movs	r0, #0x0
700acbbe: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700acbc0: 9900         	ldr	r1, [sp]
700acbc2: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = UART_WAIT_FOREVER;
700acbc4: 9a00         	ldr	r2, [sp]
700acbc6: f04f 31ff    	mov.w	r1, #0xffffffff
700acbca: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700acbcc: 9900         	ldr	r1, [sp]
700acbce: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700acbd0: 9900         	ldr	r1, [sp]
700acbd2: 6108         	str	r0, [r1, #0x10]
;     }
700acbd4: e7ff         	b	0x700acbd6 <UART_lld_Transaction_init+0x26> @ imm = #-0x2
; }
700acbd6: b001         	add	sp, #0x4
700acbd8: 4770         	bx	lr
700acbda: 0000         	movs	r0, r0
700acbdc: 0000         	movs	r0, r0
700acbde: 0000         	movs	r0, r0

700acbe0 <UART_lld_dmaWrite>:
; {
700acbe0: b580         	push	{r7, lr}
700acbe2: b084         	sub	sp, #0x10
700acbe4: 9003         	str	r0, [sp, #0xc]
700acbe6: 9102         	str	r1, [sp, #0x8]
700acbe8: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700acbea: 9001         	str	r0, [sp, #0x4]
;     status = UART_udmaConfigPdmaTx(hUart, transaction);
700acbec: 9803         	ldr	r0, [sp, #0xc]
700acbee: 9902         	ldr	r1, [sp, #0x8]
700acbf0: f7f7 fcfe    	bl	0x700a45f0 <UART_udmaConfigPdmaTx> @ imm = #-0x8604
700acbf4: 9001         	str	r0, [sp, #0x4]
;     if (status != UDMA_SOK)
700acbf6: 9801         	ldr	r0, [sp, #0x4]
700acbf8: b120         	cbz	r0, 0x700acc04 <UART_lld_dmaWrite+0x24> @ imm = #0x8
700acbfa: e7ff         	b	0x700acbfc <UART_lld_dmaWrite+0x1c> @ imm = #-0x2
700acbfc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700acc00: 9001         	str	r0, [sp, #0x4]
;     }
700acc02: e7ff         	b	0x700acc04 <UART_lld_dmaWrite+0x24> @ imm = #-0x2
;     return status;
700acc04: 9801         	ldr	r0, [sp, #0x4]
700acc06: b004         	add	sp, #0x10
700acc08: bd80         	pop	{r7, pc}
700acc0a: 0000         	movs	r0, r0
700acc0c: 0000         	movs	r0, r0
700acc0e: 0000         	movs	r0, r0

700acc10 <UART_operatingModeSelect>:
; {
700acc10: b580         	push	{r7, lr}
700acc12: b084         	sub	sp, #0x10
700acc14: 9003         	str	r0, [sp, #0xc]
700acc16: 9102         	str	r1, [sp, #0x8]
;     operMode = HW_RD_REG32(baseAddr + UART_MDR1) & UART_MDR1_MODE_SELECT_MASK;
700acc18: 9803         	ldr	r0, [sp, #0xc]
700acc1a: 3020         	adds	r0, #0x20
700acc1c: f000 fe50    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0xca0
700acc20: f000 0007    	and	r0, r0, #0x7
700acc24: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_MDR1, UART_MDR1_MODE_SELECT,
700acc26: 9803         	ldr	r0, [sp, #0xc]
700acc28: 3020         	adds	r0, #0x20
700acc2a: 9b02         	ldr	r3, [sp, #0x8]
700acc2c: 2107         	movs	r1, #0x7
700acc2e: 2200         	movs	r2, #0x0
700acc30: f7ff fc4e    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #-0x764
;     return operMode;
700acc34: 9801         	ldr	r0, [sp, #0x4]
700acc36: b004         	add	sp, #0x10
700acc38: bd80         	pop	{r7, pc}
700acc3a: 0000         	movs	r0, r0
700acc3c: 0000         	movs	r0, r0
700acc3e: 0000         	movs	r0, r0

700acc40 <Udma_eventProgramSteering>:
; {
700acc40: b084         	sub	sp, #0x10
700acc42: 9003         	str	r0, [sp, #0xc]
700acc44: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700acc46: 9802         	ldr	r0, [sp, #0x8]
700acc48: 3008         	adds	r0, #0x8
700acc4a: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700acc4c: 9800         	ldr	r0, [sp]
700acc4e: 6800         	ldr	r0, [r0]
700acc50: 2803         	cmp	r0, #0x3
700acc52: d108         	bne	0x700acc66 <Udma_eventProgramSteering+0x26> @ imm = #0x10
700acc54: e7ff         	b	0x700acc56 <Udma_eventProgramSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700acc56: 9800         	ldr	r0, [sp]
700acc58: 6880         	ldr	r0, [r0, #0x8]
700acc5a: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = TRUE;
700acc5c: 9901         	ldr	r1, [sp, #0x4]
700acc5e: 2001         	movs	r0, #0x1
700acc60: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700acc64: e7ff         	b	0x700acc66 <Udma_eventProgramSteering+0x26> @ imm = #-0x2
;     return;
700acc66: b004         	add	sp, #0x10
700acc68: 4770         	bx	lr
700acc6a: 0000         	movs	r0, r0
700acc6c: 0000         	movs	r0, r0
700acc6e: 0000         	movs	r0, r0

700acc70 <Udma_eventResetSteering>:
; {
700acc70: b084         	sub	sp, #0x10
700acc72: 9003         	str	r0, [sp, #0xc]
700acc74: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700acc76: 9802         	ldr	r0, [sp, #0x8]
700acc78: 3008         	adds	r0, #0x8
700acc7a: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700acc7c: 9800         	ldr	r0, [sp]
700acc7e: 6800         	ldr	r0, [r0]
700acc80: 2803         	cmp	r0, #0x3
700acc82: d108         	bne	0x700acc96 <Udma_eventResetSteering+0x26> @ imm = #0x10
700acc84: e7ff         	b	0x700acc86 <Udma_eventResetSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700acc86: 9800         	ldr	r0, [sp]
700acc88: 6880         	ldr	r0, [r0, #0x8]
700acc8a: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = FALSE;
700acc8c: 9901         	ldr	r1, [sp, #0x4]
700acc8e: 2000         	movs	r0, #0x0
700acc90: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700acc94: e7ff         	b	0x700acc96 <Udma_eventResetSteering+0x26> @ imm = #-0x2
;     return;
700acc96: b004         	add	sp, #0x10
700acc98: 4770         	bx	lr
700acc9a: 0000         	movs	r0, r0
700acc9c: 0000         	movs	r0, r0
700acc9e: 0000         	movs	r0, r0

700acca0 <Sciclient_secProxyVerifyThread>:
; {
700acca0: b580         	push	{r7, lr}
700acca2: b082         	sub	sp, #0x8
700acca4: 9001         	str	r0, [sp, #0x4]
700acca6: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700acca8: 9000         	str	r0, [sp]
;     if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700accaa: 9801         	ldr	r0, [sp, #0x4]
700accac: f000 fbb8    	bl	0x700ad420 <Sciclient_secProxyThreadStatusReg> @ imm = #0x770
700accb0: f000 fe66    	bl	0x700ad980 <CSL_REG32_RD_RAW> @ imm = #0xccc
700accb4: 0fc0         	lsrs	r0, r0, #0x1f
700accb6: b120         	cbz	r0, 0x700accc2 <Sciclient_secProxyVerifyThread+0x22> @ imm = #0x8
700accb8: e7ff         	b	0x700accba <Sciclient_secProxyVerifyThread+0x1a> @ imm = #-0x2
700accba: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700accbe: 9000         	str	r0, [sp]
;     }
700accc0: e7ff         	b	0x700accc2 <Sciclient_secProxyVerifyThread+0x22> @ imm = #-0x2
;     return status;
700accc2: 9800         	ldr	r0, [sp]
700accc4: b002         	add	sp, #0x8
700accc6: bd80         	pop	{r7, pc}
		...

700accd0 <prvIsQueueEmpty>:
; {
700accd0: b580         	push	{r7, lr}
700accd2: b082         	sub	sp, #0x8
700accd4: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700accd6: f7ff fc5b    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #-0x74a
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
700accda: 9801         	ldr	r0, [sp, #0x4]
700accdc: 6b80         	ldr	r0, [r0, #0x38]
700accde: b918         	cbnz	r0, 0x700acce8 <prvIsQueueEmpty+0x18> @ imm = #0x6
700acce0: e7ff         	b	0x700acce2 <prvIsQueueEmpty+0x12> @ imm = #-0x2
700acce2: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700acce4: 9000         	str	r0, [sp]
;         }
700acce6: e002         	b	0x700accee <prvIsQueueEmpty+0x1e> @ imm = #0x4
700acce8: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700accea: 9000         	str	r0, [sp]
700accec: e7ff         	b	0x700accee <prvIsQueueEmpty+0x1e> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700accee: f7fe fd0f    	bl	0x700ab710 <vTaskExitCritical> @ imm = #-0x15e2
;     return xReturn;
700accf2: 9800         	ldr	r0, [sp]
700accf4: b002         	add	sp, #0x8
700accf6: bd80         	pop	{r7, pc}
		...

700acd00 <vQueueDelete>:
; {
700acd00: b580         	push	{r7, lr}
700acd02: b082         	sub	sp, #0x8
700acd04: 9001         	str	r0, [sp, #0x4]
;     Queue_t * const pxQueue = xQueue;
700acd06: 9801         	ldr	r0, [sp, #0x4]
700acd08: 9000         	str	r0, [sp]
;             vQueueUnregisterQueue( pxQueue );
700acd0a: 9800         	ldr	r0, [sp]
700acd0c: f7fe f850    	bl	0x700aadb0 <vQueueUnregisterQueue> @ imm = #-0x1f60
;             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
700acd10: 9800         	ldr	r0, [sp]
700acd12: f890 0046    	ldrb.w	r0, [r0, #0x46]
700acd16: b920         	cbnz	r0, 0x700acd22 <vQueueDelete+0x22> @ imm = #0x8
700acd18: e7ff         	b	0x700acd1a <vQueueDelete+0x1a> @ imm = #-0x2
;                 vPortFree( pxQueue );
700acd1a: 9800         	ldr	r0, [sp]
700acd1c: f000 fa20    	bl	0x700ad160 <vPortFree>  @ imm = #0x440
;             }
700acd20: e000         	b	0x700acd24 <vQueueDelete+0x24> @ imm = #0x0
700acd22: e7ff         	b	0x700acd24 <vQueueDelete+0x24> @ imm = #-0x2
; }
700acd24: b002         	add	sp, #0x8
700acd26: bd80         	pop	{r7, pc}
		...

700acd30 <vprintf_>:
; {
700acd30: b580         	push	{r7, lr}
700acd32: b084         	sub	sp, #0x10
700acd34: 9103         	str	r1, [sp, #0xc]
700acd36: 9002         	str	r0, [sp, #0x8]
;   return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
700acd38: 9b02         	ldr	r3, [sp, #0x8]
700acd3a: 9803         	ldr	r0, [sp, #0xc]
700acd3c: 4669         	mov	r1, sp
700acd3e: 6008         	str	r0, [r1]
700acd40: f64c 70f1    	movw	r0, #0xcff1
700acd44: f2c7 000a    	movt	r0, #0x700a
700acd48: f10d 0107    	add.w	r1, sp, #0x7
700acd4c: f04f 32ff    	mov.w	r2, #0xffffffff
700acd50: f7ec f956    	bl	0x70099000 <_vsnprintf> @ imm = #-0x13d54
700acd54: b004         	add	sp, #0x10
700acd56: bd80         	pop	{r7, pc}
		...

700acd60 <UART_udmapSetReturnPolicy>:
; {
700acd60: b580         	push	{r7, lr}
700acd62: b086         	sub	sp, #0x18
700acd64: 9005         	str	r0, [sp, #0x14]
700acd66: 9104         	str	r1, [sp, #0x10]
700acd68: 2001         	movs	r0, #0x1
;         uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700acd6a: 9003         	str	r0, [sp, #0xc]
;         CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700acd6c: 9804         	ldr	r0, [sp, #0x10]
700acd6e: 9002         	str	r0, [sp, #0x8]
;         pHpd,
700acd70: 9802         	ldr	r0, [sp, #0x8]
;         descType,
700acd72: 9903         	ldr	r1, [sp, #0xc]
;         CSL_udmapCppi5SetReturnPolicy(
700acd74: 466a         	mov	r2, sp
700acd76: 2300         	movs	r3, #0x0
700acd78: 6053         	str	r3, [r2, #0x4]
700acd7a: 6013         	str	r3, [r2]
700acd7c: 461a         	mov	r2, r3
700acd7e: f7fb fc6f    	bl	0x700a8660 <CSL_udmapCppi5SetReturnPolicy> @ imm = #-0x4722
;         return;
700acd82: b006         	add	sp, #0x18
700acd84: bd80         	pop	{r7, pc}
		...
700acd8e: 0000         	movs	r0, r0

700acd90 <Udma_ringGetForwardRingOcc>:
; {
700acd90: b580         	push	{r7, lr}
700acd92: b084         	sub	sp, #0x10
700acd94: 9003         	str	r0, [sp, #0xc]
700acd96: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700acd98: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700acd9a: 9803         	ldr	r0, [sp, #0xc]
700acd9c: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700acd9e: 9801         	ldr	r0, [sp, #0x4]
700acda0: 6800         	ldr	r0, [r0]
700acda2: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetForwardRingOcc(ringHandleInt);
700acda4: 9800         	ldr	r0, [sp]
700acda6: f8d0 15a8    	ldr.w	r1, [r0, #0x5a8]
700acdaa: 9801         	ldr	r0, [sp, #0x4]
700acdac: 4788         	blx	r1
700acdae: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700acdb0: 9802         	ldr	r0, [sp, #0x8]
700acdb2: b004         	add	sp, #0x10
700acdb4: bd80         	pop	{r7, pc}
		...
700acdbe: 0000         	movs	r0, r0

700acdc0 <Udma_ringGetReverseRingOcc>:
; {
700acdc0: b580         	push	{r7, lr}
700acdc2: b084         	sub	sp, #0x10
700acdc4: 9003         	str	r0, [sp, #0xc]
700acdc6: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700acdc8: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700acdca: 9803         	ldr	r0, [sp, #0xc]
700acdcc: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700acdce: 9801         	ldr	r0, [sp, #0x4]
700acdd0: 6800         	ldr	r0, [r0]
700acdd2: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetReverseRingOcc(ringHandleInt);
700acdd4: 9800         	ldr	r0, [sp]
700acdd6: f8d0 15ac    	ldr.w	r1, [r0, #0x5ac]
700acdda: 9801         	ldr	r0, [sp, #0x4]
700acddc: 4788         	blx	r1
700acdde: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700acde0: 9802         	ldr	r0, [sp, #0x8]
700acde2: b004         	add	sp, #0x10
700acde4: bd80         	pop	{r7, pc}
		...
700acdee: 0000         	movs	r0, r0

700acdf0 <_out_buffer>:
; {
700acdf0: b084         	sub	sp, #0x10
700acdf2: f88d 000f    	strb.w	r0, [sp, #0xf]
700acdf6: 9102         	str	r1, [sp, #0x8]
700acdf8: 9201         	str	r2, [sp, #0x4]
700acdfa: 9300         	str	r3, [sp]
;   if (idx < maxlen) {
700acdfc: 9801         	ldr	r0, [sp, #0x4]
700acdfe: 9900         	ldr	r1, [sp]
700ace00: 4288         	cmp	r0, r1
700ace02: d206         	bhs	0x700ace12 <_out_buffer+0x22> @ imm = #0xc
700ace04: e7ff         	b	0x700ace06 <_out_buffer+0x16> @ imm = #-0x2
;     ((char*)buffer)[idx] = character;
700ace06: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ace0a: 9902         	ldr	r1, [sp, #0x8]
700ace0c: 9a01         	ldr	r2, [sp, #0x4]
700ace0e: 5488         	strb	r0, [r1, r2]
;   }
700ace10: e7ff         	b	0x700ace12 <_out_buffer+0x22> @ imm = #-0x2
; }
700ace12: b004         	add	sp, #0x10
700ace14: 4770         	bx	lr
		...
700ace1e: 0000         	movs	r0, r0

700ace20 <prvGetDisinheritPriorityAfterTimeout>:
;     {
700ace20: b082         	sub	sp, #0x8
700ace22: 9001         	str	r0, [sp, #0x4]
;         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
700ace24: 9801         	ldr	r0, [sp, #0x4]
700ace26: 6a40         	ldr	r0, [r0, #0x24]
700ace28: b138         	cbz	r0, 0x700ace3a <prvGetDisinheritPriorityAfterTimeout+0x1a> @ imm = #0xe
700ace2a: e7ff         	b	0x700ace2c <prvGetDisinheritPriorityAfterTimeout+0xc> @ imm = #-0x2
;             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
700ace2c: 9801         	ldr	r0, [sp, #0x4]
700ace2e: 6b00         	ldr	r0, [r0, #0x30]
700ace30: 6800         	ldr	r0, [r0]
700ace32: f1c0 0020    	rsb.w	r0, r0, #0x20
700ace36: 9000         	str	r0, [sp]
;         }
700ace38: e002         	b	0x700ace40 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #0x4
700ace3a: 2000         	movs	r0, #0x0
;             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
700ace3c: 9000         	str	r0, [sp]
700ace3e: e7ff         	b	0x700ace40 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #-0x2
;         return uxHighestPriorityOfWaitingTasks;
700ace40: 9800         	ldr	r0, [sp]
700ace42: b002         	add	sp, #0x8
700ace44: 4770         	bx	lr
		...
700ace4e: 0000         	movs	r0, r0

700ace50 <vTaskPlaceOnEventList>:
;                            const TickType_t xTicksToWait) {
700ace50: b580         	push	{r7, lr}
700ace52: b082         	sub	sp, #0x8
700ace54: 9001         	str	r0, [sp, #0x4]
700ace56: 9100         	str	r1, [sp]
;   vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
700ace58: 9801         	ldr	r0, [sp, #0x4]
700ace5a: f240 41dc    	movw	r1, #0x4dc
700ace5e: f2c7 010b    	movt	r1, #0x700b
700ace62: 6809         	ldr	r1, [r1]
700ace64: 3118         	adds	r1, #0x18
700ace66: f7fc fc1b    	bl	0x700a96a0 <vListInsert> @ imm = #-0x37ca
;   prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
700ace6a: 9800         	ldr	r0, [sp]
700ace6c: 2101         	movs	r1, #0x1
700ace6e: f7f6 feb7    	bl	0x700a3be0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x9292
; }
700ace72: b002         	add	sp, #0x8
700ace74: bd80         	pop	{r7, pc}
		...
700ace7e: 0000         	movs	r0, r0

700ace80 <CSL_REG32_FEXT_RAW>:
; {
700ace80: b580         	push	{r7, lr}
700ace82: b084         	sub	sp, #0x10
700ace84: 9003         	str	r0, [sp, #0xc]
700ace86: 9102         	str	r1, [sp, #0x8]
700ace88: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ace8a: 9803         	ldr	r0, [sp, #0xc]
700ace8c: f000 fd60    	bl	0x700ad950 <CSL_REG32_RD_RAW> @ imm = #0xac0
700ace90: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700ace92: 9800         	ldr	r0, [sp]
700ace94: 9902         	ldr	r1, [sp, #0x8]
700ace96: 4008         	ands	r0, r1
700ace98: 9901         	ldr	r1, [sp, #0x4]
700ace9a: 40c8         	lsrs	r0, r1
700ace9c: 9000         	str	r0, [sp]
;     return (regVal);
700ace9e: 9800         	ldr	r0, [sp]
700acea0: b004         	add	sp, #0x10
700acea2: bd80         	pop	{r7, pc}
		...

700aceb0 <CSL_REG32_FEXT_RAW>:
; {
700aceb0: b580         	push	{r7, lr}
700aceb2: b084         	sub	sp, #0x10
700aceb4: 9003         	str	r0, [sp, #0xc]
700aceb6: 9102         	str	r1, [sp, #0x8]
700aceb8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700aceba: 9803         	ldr	r0, [sp, #0xc]
700acebc: f000 fd50    	bl	0x700ad960 <CSL_REG32_RD_RAW> @ imm = #0xaa0
700acec0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700acec2: 9800         	ldr	r0, [sp]
700acec4: 9902         	ldr	r1, [sp, #0x8]
700acec6: 4008         	ands	r0, r1
700acec8: 9901         	ldr	r1, [sp, #0x4]
700aceca: 40c8         	lsrs	r0, r1
700acecc: 9000         	str	r0, [sp]
;     return (regVal);
700acece: 9800         	ldr	r0, [sp]
700aced0: b004         	add	sp, #0x10
700aced2: bd80         	pop	{r7, pc}
		...

700acee0 <CSL_REG32_FEXT_RAW>:
; {
700acee0: b580         	push	{r7, lr}
700acee2: b084         	sub	sp, #0x10
700acee4: 9003         	str	r0, [sp, #0xc]
700acee6: 9102         	str	r1, [sp, #0x8]
700acee8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700aceea: 9803         	ldr	r0, [sp, #0xc]
700aceec: f000 fd40    	bl	0x700ad970 <CSL_REG32_RD_RAW> @ imm = #0xa80
700acef0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700acef2: 9800         	ldr	r0, [sp]
700acef4: 9902         	ldr	r1, [sp, #0x8]
700acef6: 4008         	ands	r0, r1
700acef8: 9901         	ldr	r1, [sp, #0x4]
700acefa: 40c8         	lsrs	r0, r1
700acefc: 9000         	str	r0, [sp]
;     return (regVal);
700acefe: 9800         	ldr	r0, [sp]
700acf00: b004         	add	sp, #0x10
700acf02: bd80         	pop	{r7, pc}
		...

700acf10 <CSL_REG32_FEXT_RAW>:
; {
700acf10: b580         	push	{r7, lr}
700acf12: b084         	sub	sp, #0x10
700acf14: 9003         	str	r0, [sp, #0xc]
700acf16: 9102         	str	r1, [sp, #0x8]
700acf18: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700acf1a: 9803         	ldr	r0, [sp, #0xc]
700acf1c: f000 fd30    	bl	0x700ad980 <CSL_REG32_RD_RAW> @ imm = #0xa60
700acf20: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700acf22: 9800         	ldr	r0, [sp]
700acf24: 9902         	ldr	r1, [sp, #0x8]
700acf26: 4008         	ands	r0, r1
700acf28: 9901         	ldr	r1, [sp, #0x4]
700acf2a: 40c8         	lsrs	r0, r1
700acf2c: 9000         	str	r0, [sp]
;     return (regVal);
700acf2e: 9800         	ldr	r0, [sp]
700acf30: b004         	add	sp, #0x10
700acf32: bd80         	pop	{r7, pc}
		...

700acf40 <CSL_REG32_FEXT_RAW>:
; {
700acf40: b580         	push	{r7, lr}
700acf42: b084         	sub	sp, #0x10
700acf44: 9003         	str	r0, [sp, #0xc]
700acf46: 9102         	str	r1, [sp, #0x8]
700acf48: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700acf4a: 9803         	ldr	r0, [sp, #0xc]
700acf4c: f000 fd20    	bl	0x700ad990 <CSL_REG32_RD_RAW> @ imm = #0xa40
700acf50: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700acf52: 9800         	ldr	r0, [sp]
700acf54: 9902         	ldr	r1, [sp, #0x8]
700acf56: 4008         	ands	r0, r1
700acf58: 9901         	ldr	r1, [sp, #0x4]
700acf5a: 40c8         	lsrs	r0, r1
700acf5c: 9000         	str	r0, [sp]
;     return (regVal);
700acf5e: 9800         	ldr	r0, [sp]
700acf60: b004         	add	sp, #0x10
700acf62: bd80         	pop	{r7, pc}
		...

700acf70 <SOC_getSelfCpuClk>:
; {
700acf70: b580         	push	{r7, lr}
700acf72: b084         	sub	sp, #0x10
700acf74: 2000         	movs	r0, #0x0
;     uint64_t cpuClockRate = 0U;
700acf76: 9001         	str	r0, [sp, #0x4]
700acf78: 9003         	str	r0, [sp, #0xc]
700acf7a: 9002         	str	r0, [sp, #0x8]
;                     Sciclient_getSelfDevIdCore(),
700acf7c: f000 fd20    	bl	0x700ad9c0 <Sciclient_getSelfDevIdCore> @ imm = #0xa40
700acf80: 9901         	ldr	r1, [sp, #0x4]
700acf82: aa02         	add	r2, sp, #0x8
700acf84: f04f 33ff    	mov.w	r3, #0xffffffff
;     Sciclient_pmGetModuleClkFreq(
700acf88: f7f9 ff22    	bl	0x700a6dd0 <Sciclient_pmGetModuleClkFreq> @ imm = #-0x61bc
;     return cpuClockRate;
700acf8c: 9802         	ldr	r0, [sp, #0x8]
700acf8e: 9903         	ldr	r1, [sp, #0xc]
700acf90: b004         	add	sp, #0x10
700acf92: bd80         	pop	{r7, pc}
		...

700acfa0 <UART_IsStopBitsValid>:
; {
700acfa0: b082         	sub	sp, #0x8
700acfa2: 9001         	str	r0, [sp, #0x4]
700acfa4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700acfa8: 9000         	str	r0, [sp]
;     if((stopBits == UART_STOPBITS_1) ||
700acfaa: 9801         	ldr	r0, [sp, #0x4]
700acfac: b120         	cbz	r0, 0x700acfb8 <UART_IsStopBitsValid+0x18> @ imm = #0x8
700acfae: e7ff         	b	0x700acfb0 <UART_IsStopBitsValid+0x10> @ imm = #-0x2
;         (stopBits == UART_STOPBITS_2))
700acfb0: 9801         	ldr	r0, [sp, #0x4]
;     if((stopBits == UART_STOPBITS_1) ||
700acfb2: 2801         	cmp	r0, #0x1
700acfb4: d103         	bne	0x700acfbe <UART_IsStopBitsValid+0x1e> @ imm = #0x6
700acfb6: e7ff         	b	0x700acfb8 <UART_IsStopBitsValid+0x18> @ imm = #-0x2
700acfb8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700acfba: 9000         	str	r0, [sp]
;     }
700acfbc: e7ff         	b	0x700acfbe <UART_IsStopBitsValid+0x1e> @ imm = #-0x2
;     return status;
700acfbe: 9800         	ldr	r0, [sp]
700acfc0: b002         	add	sp, #0x8
700acfc2: 4770         	bx	lr

700acfc4 <__aeabi_uldivmod>:
700acfc4: e92d4040     	push	{r6, lr}
700acfc8: e24dd010     	sub	sp, sp, #16
700acfcc: e28d6008     	add	r6, sp, #8
700acfd0: e58d6000     	str	r6, [sp]
700acfd4: ebffd78b     	bl	0x700a2e08 <__udivmoddi4> @ imm = #-0xa1d4
700acfd8: e59d2008     	ldr	r2, [sp, #0x8]
700acfdc: e59d300c     	ldr	r3, [sp, #0xc]
700acfe0: e28dd010     	add	sp, sp, #16
700acfe4: e8bd8040     	pop	{r6, pc}
		...

700acff0 <_out_char>:
; {
700acff0: b580         	push	{r7, lr}
700acff2: b084         	sub	sp, #0x10
700acff4: f88d 000f    	strb.w	r0, [sp, #0xf]
700acff8: 9102         	str	r1, [sp, #0x8]
700acffa: 9201         	str	r2, [sp, #0x4]
700acffc: 9300         	str	r3, [sp]
;   if (character) {
700acffe: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad002: b128         	cbz	r0, 0x700ad010 <_out_char+0x20> @ imm = #0xa
700ad004: e7ff         	b	0x700ad006 <_out_char+0x16> @ imm = #-0x2
;     putchar_(character);
700ad006: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad00a: f000 fbc1    	bl	0x700ad790 <putchar_>   @ imm = #0x782
;   }
700ad00e: e7ff         	b	0x700ad010 <_out_char+0x20> @ imm = #-0x2
; }
700ad010: b004         	add	sp, #0x10
700ad012: bd80         	pop	{r7, pc}
		...

700ad020 <vTaskInternalSetTimeOutState>:
; void vTaskInternalSetTimeOutState(TimeOut_t *const pxTimeOut) {
700ad020: b081         	sub	sp, #0x4
700ad022: 9000         	str	r0, [sp]
;   pxTimeOut->xOverflowCount = xNumOfOverflows;
700ad024: f240 5014    	movw	r0, #0x514
700ad028: f2c7 000b    	movt	r0, #0x700b
700ad02c: 6800         	ldr	r0, [r0]
700ad02e: 9900         	ldr	r1, [sp]
700ad030: 6008         	str	r0, [r1]
;   pxTimeOut->xTimeOnEntering = xTickCount;
700ad032: f240 5020    	movw	r0, #0x520
700ad036: f2c7 000b    	movt	r0, #0x700b
700ad03a: 6800         	ldr	r0, [r0]
700ad03c: 9900         	ldr	r1, [sp]
700ad03e: 6048         	str	r0, [r1, #0x4]
; }
700ad040: b001         	add	sp, #0x4
700ad042: 4770         	bx	lr
		...

700ad050 <Pinmux_init>:
; {
700ad050: b580         	push	{r7, lr}
;     Pinmux_config(gPinMuxMainDomainCfg, PINMUX_DOMAIN_ID_MAIN);
700ad052: f240 4020    	movw	r0, #0x420
700ad056: 2100         	movs	r1, #0x0
700ad058: f2c7 000b    	movt	r0, #0x700b
700ad05c: f7f9 fdc8    	bl	0x700a6bf0 <Pinmux_config> @ imm = #-0x6470
;     Pinmux_config(gPinMuxMcuDomainCfg, PINMUX_DOMAIN_ID_MCU);
700ad060: f240 4070    	movw	r0, #0x470
700ad064: 2101         	movs	r1, #0x1
700ad066: f2c7 000b    	movt	r0, #0x700b
700ad06a: e8bd 4080    	pop.w	{r7, lr}
700ad06e: f7f9 bdbf    	b.w	0x700a6bf0 <Pinmux_config> @ imm = #-0x6482
		...
700ad07e: 0000         	movs	r0, r0

700ad080 <Udma_rmTranslateCoreIntrInput>:
; {
700ad080: b083         	sub	sp, #0xc
700ad082: 9002         	str	r0, [sp, #0x8]
700ad084: 9101         	str	r1, [sp, #0x4]
700ad086: 2000         	movs	r0, #0x0
700ad088: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    irIntrNum = UDMA_INTR_INVALID;
700ad08c: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700ad08e: 9802         	ldr	r0, [sp, #0x8]
700ad090: 6800         	ldr	r0, [r0]
700ad092: b118         	cbz	r0, 0x700ad09c <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #0x6
700ad094: e7ff         	b	0x700ad096 <Udma_rmTranslateCoreIntrInput+0x16> @ imm = #-0x2
;         irIntrNum = coreIntrNum;
700ad096: 9801         	ldr	r0, [sp, #0x4]
700ad098: 9000         	str	r0, [sp]
;     }
700ad09a: e7ff         	b	0x700ad09c <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #-0x2
;     return (irIntrNum);
700ad09c: 9800         	ldr	r0, [sp]
700ad09e: b003         	add	sp, #0xc
700ad0a0: 4770         	bx	lr
		...
700ad0ae: 0000         	movs	r0, r0

700ad0b0 <Udma_rmTranslateIrOutput>:
; {
700ad0b0: b083         	sub	sp, #0xc
700ad0b2: 9002         	str	r0, [sp, #0x8]
700ad0b4: 9101         	str	r1, [sp, #0x4]
700ad0b6: 2000         	movs	r0, #0x0
700ad0b8: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    coreIntrNum = UDMA_INTR_INVALID;
700ad0bc: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700ad0be: 9802         	ldr	r0, [sp, #0x8]
700ad0c0: 6800         	ldr	r0, [r0]
700ad0c2: b118         	cbz	r0, 0x700ad0cc <Udma_rmTranslateIrOutput+0x1c> @ imm = #0x6
700ad0c4: e7ff         	b	0x700ad0c6 <Udma_rmTranslateIrOutput+0x16> @ imm = #-0x2
;         coreIntrNum = irIntrNum;
700ad0c6: 9801         	ldr	r0, [sp, #0x4]
700ad0c8: 9000         	str	r0, [sp]
;     }
700ad0ca: e7ff         	b	0x700ad0cc <Udma_rmTranslateIrOutput+0x1c> @ imm = #-0x2
;     return (coreIntrNum);
700ad0cc: 9800         	ldr	r0, [sp]
700ad0ce: b003         	add	sp, #0xc
700ad0d0: 4770         	bx	lr
		...
700ad0de: 0000         	movs	r0, r0

700ad0e0 <ClockP_usecToTicks>:
; {
700ad0e0: b580         	push	{r7, lr}
700ad0e2: b082         	sub	sp, #0x8
700ad0e4: 9101         	str	r1, [sp, #0x4]
700ad0e6: 9000         	str	r0, [sp]
;     return (uint32_t)(usecs / gClockCtrl.usecPerTick);
700ad0e8: 9800         	ldr	r0, [sp]
700ad0ea: 9901         	ldr	r1, [sp, #0x4]
700ad0ec: f644 6298    	movw	r2, #0x4e98
700ad0f0: f2c7 0208    	movt	r2, #0x7008
700ad0f4: 6892         	ldr	r2, [r2, #0x8]
700ad0f6: 2300         	movs	r3, #0x0
700ad0f8: f7ff ef64    	blx	0x700acfc4 <__aeabi_uldivmod> @ imm = #-0x138
700ad0fc: b002         	add	sp, #0x8
700ad0fe: bd80         	pop	{r7, pc}

700ad100 <HW_RD_FIELD32_RAW>:
; {
700ad100: b084         	sub	sp, #0x10
700ad102: 9003         	str	r0, [sp, #0xc]
700ad104: 9102         	str	r1, [sp, #0x8]
700ad106: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700ad108: 9803         	ldr	r0, [sp, #0xc]
700ad10a: 6800         	ldr	r0, [r0]
700ad10c: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700ad10e: 9800         	ldr	r0, [sp]
700ad110: 9902         	ldr	r1, [sp, #0x8]
700ad112: 4008         	ands	r0, r1
700ad114: 9901         	ldr	r1, [sp, #0x4]
700ad116: 40c8         	lsrs	r0, r1
700ad118: 9000         	str	r0, [sp]
;     return (regVal);
700ad11a: 9800         	ldr	r0, [sp]
700ad11c: b004         	add	sp, #0x10
700ad11e: 4770         	bx	lr

700ad120 <Sciclient_getRxThreadId>:
; {
700ad120: b082         	sub	sp, #0x8
700ad122: 9001         	str	r0, [sp, #0x4]
;     rxThread = gSciclientMap[contextId].respThreadId;
700ad124: 9801         	ldr	r0, [sp, #0x4]
700ad126: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ad12a: f24f 0068    	movw	r0, #0xf068
700ad12e: f2c7 000a    	movt	r0, #0x700a
700ad132: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ad136: 68c0         	ldr	r0, [r0, #0xc]
700ad138: 9000         	str	r0, [sp]
;     return rxThread;
700ad13a: 9800         	ldr	r0, [sp]
700ad13c: b002         	add	sp, #0x8
700ad13e: 4770         	bx	lr

700ad140 <Sciclient_getTxThreadId>:
; {
700ad140: b082         	sub	sp, #0x8
700ad142: 9001         	str	r0, [sp, #0x4]
;     txThread = gSciclientMap[contextId].reqLowPrioThreadId;
700ad144: 9801         	ldr	r0, [sp, #0x4]
700ad146: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ad14a: f24f 0068    	movw	r0, #0xf068
700ad14e: f2c7 000a    	movt	r0, #0x700a
700ad152: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ad156: 6880         	ldr	r0, [r0, #0x8]
700ad158: 9000         	str	r0, [sp]
;     return txThread;
700ad15a: 9800         	ldr	r0, [sp]
700ad15c: b002         	add	sp, #0x8
700ad15e: 4770         	bx	lr

700ad160 <vPortFree>:
; {
700ad160: b580         	push	{r7, lr}
700ad162: b082         	sub	sp, #0x8
700ad164: 9001         	str	r0, [sp, #0x4]
;     if( pv )
700ad166: 9801         	ldr	r0, [sp, #0x4]
700ad168: b140         	cbz	r0, 0x700ad17c <vPortFree+0x1c> @ imm = #0x10
700ad16a: e7ff         	b	0x700ad16c <vPortFree+0xc> @ imm = #-0x2
;         vTaskSuspendAll();
700ad16c: f000 fbd0    	bl	0x700ad910 <vTaskSuspendAll> @ imm = #0x7a0
;             free( pv );
700ad170: 9801         	ldr	r0, [sp, #0x4]
700ad172: f7f1 ea1a    	blx	0x7009e5a8 <free>       @ imm = #-0xebcc
;         ( void ) xTaskResumeAll();
700ad176: f7f3 fd1b    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0xc5ca
;     }
700ad17a: e7ff         	b	0x700ad17c <vPortFree+0x1c> @ imm = #-0x2
; }
700ad17c: b002         	add	sp, #0x8
700ad17e: bd80         	pop	{r7, pc}

700ad180 <CSL_udmapCppi5SetEpiDataPresent>:
; {
700ad180: b082         	sub	sp, #0x8
700ad182: 9001         	str	r0, [sp, #0x4]
700ad184: f88d 1003    	strb.w	r1, [sp, #0x3]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_EINFO, (bEpiDataPresent==(bool)true) ? (uint32_t)1U : (uint32_t)0U );
700ad188: 9901         	ldr	r1, [sp, #0x4]
700ad18a: 6808         	ldr	r0, [r1]
700ad18c: f020 5000    	bic	r0, r0, #0x20000000
700ad190: f89d 2003    	ldrb.w	r2, [sp, #0x3]
700ad194: f362 705d    	bfi	r0, r2, #29, #1
700ad198: 6008         	str	r0, [r1]
; }
700ad19a: b002         	add	sp, #0x8
700ad19c: 4770         	bx	lr
700ad19e: 0000         	movs	r0, r0

700ad1a0 <DebugP_memLogWriterInit>:
; {
700ad1a0: b580         	push	{r7, lr}
700ad1a2: b082         	sub	sp, #0x8
700ad1a4: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     gDebugP_memTraceLogWriterSelfCoreName = SOC_getCoreName(selfCoreId);
700ad1a8: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad1ac: f7fe ffb8    	bl	0x700ac120 <SOC_getCoreName> @ imm = #-0x1090
700ad1b0: f240 41c0    	movw	r1, #0x4c0
700ad1b4: f2c7 010b    	movt	r1, #0x700b
700ad1b8: 6008         	str	r0, [r1]
; }
700ad1ba: b002         	add	sp, #0x8
700ad1bc: bd80         	pop	{r7, pc}
700ad1be: 0000         	movs	r0, r0

700ad1c0 <Sciclient_rmPsGetIrqNode>:
; {
700ad1c0: b081         	sub	sp, #0x4
700ad1c2: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return gPstack.ps[index].p_n;
700ad1c6: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ad1ca: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ad1ce: f241 0058    	movw	r0, #0x1058
700ad1d2: f2c7 0008    	movt	r0, #0x7008
700ad1d6: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ad1da: b001         	add	sp, #0x4
700ad1dc: 4770         	bx	lr
700ad1de: 0000         	movs	r0, r0

700ad1e0 <Sciclient_rmPsInit>:
; {
700ad1e0: b580         	push	{r7, lr}
700ad1e2: b082         	sub	sp, #0x8
;     memset(&gPstack.ps[0], 0, sizeof(gPstack.ps));
700ad1e4: f241 0058    	movw	r0, #0x1058
700ad1e8: f2c7 0008    	movt	r0, #0x7008
700ad1ec: 9001         	str	r0, [sp, #0x4]
700ad1ee: 2124         	movs	r1, #0x24
700ad1f0: f7ec ec20    	blx	0x70099a34 <__aeabi_memclr8> @ imm = #-0x137c0
700ad1f4: 9901         	ldr	r1, [sp, #0x4]
700ad1f6: 2000         	movs	r0, #0x0
;     gPstack.psp = 0;
700ad1f8: 8488         	strh	r0, [r1, #0x24]
; }
700ad1fa: b002         	add	sp, #0x8
700ad1fc: bd80         	pop	{r7, pc}
700ad1fe: 0000         	movs	r0, r0

700ad200 <UART_breakCtl>:
; {
700ad200: b580         	push	{r7, lr}
700ad202: b082         	sub	sp, #0x8
700ad204: 9001         	str	r0, [sp, #0x4]
700ad206: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_BREAK_EN,
700ad208: 9801         	ldr	r0, [sp, #0x4]
700ad20a: 300c         	adds	r0, #0xc
700ad20c: 9900         	ldr	r1, [sp]
700ad20e: ea4f 1391    	lsr.w	r3, r1, #0x6
700ad212: 2140         	movs	r1, #0x40
700ad214: 2206         	movs	r2, #0x6
700ad216: f7ff f95b    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #-0xd4a
; }
700ad21a: b002         	add	sp, #0x8
700ad21c: bd80         	pop	{r7, pc}
700ad21e: 0000         	movs	r0, r0

700ad220 <UART_lld_Transaction_deInit>:
; {
700ad220: b081         	sub	sp, #0x4
700ad222: 9000         	str	r0, [sp]
;     trans->buf              = NULL;
700ad224: 9900         	ldr	r1, [sp]
700ad226: 2000         	movs	r0, #0x0
700ad228: 6008         	str	r0, [r1]
;     trans->count            = 0U;
700ad22a: 9900         	ldr	r1, [sp]
700ad22c: 6048         	str	r0, [r1, #0x4]
;     trans->timeout          = 0U;
700ad22e: 9900         	ldr	r1, [sp]
700ad230: 6088         	str	r0, [r1, #0x8]
;     trans->status           = UART_STATUS_SUCCESS;
700ad232: 9900         	ldr	r1, [sp]
700ad234: 60c8         	str	r0, [r1, #0xc]
;     trans->args             = NULL;
700ad236: 9900         	ldr	r1, [sp]
700ad238: 6108         	str	r0, [r1, #0x10]
; }
700ad23a: b001         	add	sp, #0x4
700ad23c: 4770         	bx	lr
700ad23e: 0000         	movs	r0, r0

700ad240 <UART_writeInterrupt>:
; {
700ad240: b580         	push	{r7, lr}
700ad242: b084         	sub	sp, #0x10
700ad244: 9003         	str	r0, [sp, #0xc]
700ad246: 2000         	movs	r0, #0x0
;     int32_t     status = UART_STATUS_SUCCESS;
700ad248: 9002         	str	r0, [sp, #0x8]
;     baseAddr = hUart->baseAddr;
700ad24a: 9803         	ldr	r0, [sp, #0xc]
700ad24c: 6800         	ldr	r0, [r0]
700ad24e: 9001         	str	r0, [sp, #0x4]
;     UART_intrEnable(baseAddr, UART_INTR_THR);
700ad250: 9801         	ldr	r0, [sp, #0x4]
700ad252: 2102         	movs	r1, #0x2
700ad254: f7f7 f87c    	bl	0x700a4350 <UART_intrEnable> @ imm = #-0x8f08
;     return status;
700ad258: 9802         	ldr	r0, [sp, #0x8]
700ad25a: b004         	add	sp, #0x10
700ad25c: bd80         	pop	{r7, pc}
700ad25e: 0000         	movs	r0, r0

700ad260 <UdmaChPdmaPrms_init>:
; {
700ad260: b081         	sub	sp, #0x4
700ad262: 9000         	str	r0, [sp]
;     if(NULL_PTR != pdmaPrms)
700ad264: 9800         	ldr	r0, [sp]
700ad266: b140         	cbz	r0, 0x700ad27a <UdmaChPdmaPrms_init+0x1a> @ imm = #0x10
700ad268: e7ff         	b	0x700ad26a <UdmaChPdmaPrms_init+0xa> @ imm = #-0x2
;         pdmaPrms->elemSize  = UDMA_PDMA_ES_8BITS;
700ad26a: 9900         	ldr	r1, [sp]
700ad26c: 2000         	movs	r0, #0x0
700ad26e: 6008         	str	r0, [r1]
;         pdmaPrms->elemCnt   = 0U;
700ad270: 9900         	ldr	r1, [sp]
700ad272: 6048         	str	r0, [r1, #0x4]
;         pdmaPrms->fifoCnt   = 0U;
700ad274: 9900         	ldr	r1, [sp]
700ad276: 6088         	str	r0, [r1, #0x8]
;     }
700ad278: e7ff         	b	0x700ad27a <UdmaChPdmaPrms_init+0x1a> @ imm = #-0x2
;     return;
700ad27a: b001         	add	sp, #0x4
700ad27c: 4770         	bx	lr
700ad27e: 0000         	movs	r0, r0

700ad280 <prvTimerTask>:
;     {
700ad280: b580         	push	{r7, lr}
700ad282: b084         	sub	sp, #0x10
700ad284: 9003         	str	r0, [sp, #0xc]
;         for( ; ; )
700ad286: e7ff         	b	0x700ad288 <prvTimerTask+0x8> @ imm = #-0x2
700ad288: a801         	add	r0, sp, #0x4
;             xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
700ad28a: f7fe fc69    	bl	0x700abb60 <prvGetNextExpireTime> @ imm = #-0x172e
700ad28e: 9002         	str	r0, [sp, #0x8]
;             prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
700ad290: 9802         	ldr	r0, [sp, #0x8]
700ad292: 9901         	ldr	r1, [sp, #0x4]
700ad294: f7fb f954    	bl	0x700a8540 <prvProcessTimerOrBlockTask> @ imm = #-0x4d58
;             prvProcessReceivedCommands();
700ad298: f7f3 fdca    	bl	0x700a0e30 <prvProcessReceivedCommands> @ imm = #-0xc46c
;         for( ; ; )
700ad29c: e7f4         	b	0x700ad288 <prvTimerTask+0x8> @ imm = #-0x18
700ad29e: 0000         	movs	r0, r0

700ad2a0 <xPortStartScheduler>:
; BaseType_t xPortStartScheduler(void) {
700ad2a0: b580         	push	{r7, lr}
700ad2a2: b082         	sub	sp, #0x8
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700ad2a4: b672         	cpsid i
;   ulPortSchedularRunning = pdTRUE;
700ad2a6: f240 41ec    	movw	r1, #0x4ec
700ad2aa: f2c7 010b    	movt	r1, #0x700b
700ad2ae: 2001         	movs	r0, #0x1
700ad2b0: 9001         	str	r0, [sp, #0x4]
700ad2b2: 6008         	str	r0, [r1]
;   vPortRestoreTaskContext();
700ad2b4: f001 e8e6    	blx	0x700ae484 <vPortRestoreTaskContext> @ imm = #0x11cc
700ad2b8: 9801         	ldr	r0, [sp, #0x4]
;   return pdTRUE;
700ad2ba: b002         	add	sp, #0x8
700ad2bc: bd80         	pop	{r7, pc}
700ad2be: 0000         	movs	r0, r0

700ad2c0 <xTaskGetTickCount>:
; TickType_t xTaskGetTickCount(void) {
700ad2c0: b580         	push	{r7, lr}
700ad2c2: b082         	sub	sp, #0x8
;   portTICK_TYPE_ENTER_CRITICAL();
700ad2c4: f7ff f964    	bl	0x700ac590 <vTaskEnterCritical> @ imm = #-0xd38
;     xTicks = xTickCount;
700ad2c8: f240 5020    	movw	r0, #0x520
700ad2cc: f2c7 000b    	movt	r0, #0x700b
700ad2d0: 6800         	ldr	r0, [r0]
700ad2d2: 9001         	str	r0, [sp, #0x4]
;   portTICK_TYPE_EXIT_CRITICAL();
700ad2d4: f7fe fa1c    	bl	0x700ab710 <vTaskExitCritical> @ imm = #-0x1bc8
;   return xTicks;
700ad2d8: 9801         	ldr	r0, [sp, #0x4]
700ad2da: b002         	add	sp, #0x8
700ad2dc: bd80         	pop	{r7, pc}
700ad2de: 0000         	movs	r0, r0

700ad2e0 <CSL_secProxyGetDataAddr>:
; {
700ad2e0: b084         	sub	sp, #0x10
700ad2e2: 9003         	str	r0, [sp, #0xc]
700ad2e4: 9102         	str	r1, [sp, #0x8]
700ad2e6: 9201         	str	r2, [sp, #0x4]
;     dataAddr = (uintptr_t)pSecProxyCfg->proxyTargetAddr + ((uintptr_t)threadNum * CSL_SEC_PROXY_TARGET_CHAN_SIZE) + (uintptr_t)CSL_SEC_PROXY_RSVD_MSG_BYTES;
700ad2e8: 9803         	ldr	r0, [sp, #0xc]
700ad2ea: 6900         	ldr	r0, [r0, #0x10]
700ad2ec: 9902         	ldr	r1, [sp, #0x8]
700ad2ee: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad2f2: 3004         	adds	r0, #0x4
700ad2f4: 9000         	str	r0, [sp]
;     return dataAddr;
700ad2f6: 9800         	ldr	r0, [sp]
700ad2f8: b004         	add	sp, #0x10
700ad2fa: 4770         	bx	lr
700ad2fc: 0000         	movs	r0, r0
700ad2fe: 0000         	movs	r0, r0

700ad300 <UART_IsParameter>:
; {
700ad300: b082         	sub	sp, #0x8
700ad302: 9001         	str	r0, [sp, #0x4]
700ad304: 2000         	movs	r0, #0x0
;     int32_t status = UART_STATUS_SUCCESS;
700ad306: 9000         	str	r0, [sp]
;     if(InuptParameter == 0U)
700ad308: 9801         	ldr	r0, [sp, #0x4]
700ad30a: b920         	cbnz	r0, 0x700ad316 <UART_IsParameter+0x16> @ imm = #0x8
700ad30c: e7ff         	b	0x700ad30e <UART_IsParameter+0xe> @ imm = #-0x2
700ad30e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700ad312: 9000         	str	r0, [sp]
;     }
700ad314: e7ff         	b	0x700ad316 <UART_IsParameter+0x16> @ imm = #-0x2
;     return status;
700ad316: 9800         	ldr	r0, [sp]
700ad318: b002         	add	sp, #0x8
700ad31a: 4770         	bx	lr
700ad31c: 0000         	movs	r0, r0
700ad31e: 0000         	movs	r0, r0

700ad320 <pvPortMalloc>:
; {
700ad320: b580         	push	{r7, lr}
700ad322: b082         	sub	sp, #0x8
700ad324: 9001         	str	r0, [sp, #0x4]
;     vTaskSuspendAll();
700ad326: f000 faf3    	bl	0x700ad910 <vTaskSuspendAll> @ imm = #0x5e6
;         pvReturn = malloc( xWantedSize );
700ad32a: 9801         	ldr	r0, [sp, #0x4]
700ad32c: f7ec ee82    	blx	0x7009a034 <malloc>     @ imm = #-0x132fc
700ad330: 9000         	str	r0, [sp]
;     ( void ) xTaskResumeAll();
700ad332: f7f3 fc3d    	bl	0x700a0bb0 <xTaskResumeAll> @ imm = #-0xc786
;     return pvReturn;
700ad336: 9800         	ldr	r0, [sp]
700ad338: b002         	add	sp, #0x8
700ad33a: bd80         	pop	{r7, pc}
700ad33c: 0000         	movs	r0, r0
700ad33e: 0000         	movs	r0, r0

700ad340 <vPortYeildFromISR>:
; void vPortYeildFromISR(uint32_t xSwitchRequired) {
700ad340: b081         	sub	sp, #0x4
700ad342: 9000         	str	r0, [sp]
;   if (xSwitchRequired != pdFALSE) {
700ad344: 9800         	ldr	r0, [sp]
700ad346: b138         	cbz	r0, 0x700ad358 <vPortYeildFromISR+0x18> @ imm = #0xe
700ad348: e7ff         	b	0x700ad34a <vPortYeildFromISR+0xa> @ imm = #-0x2
;     ulPortYieldRequired = pdTRUE;
700ad34a: f240 41f4    	movw	r1, #0x4f4
700ad34e: f2c7 010b    	movt	r1, #0x700b
700ad352: 2001         	movs	r0, #0x1
700ad354: 6008         	str	r0, [r1]
;   }
700ad356: e7ff         	b	0x700ad358 <vPortYeildFromISR+0x18> @ imm = #-0x2
; }
700ad358: b001         	add	sp, #0x4
700ad35a: 4770         	bx	lr

700ad35c <TI_memcpy_small>:
700ad35c: e3a0c000     	mov	r12, #0

700ad360 <_loop>:
700ad360: e152000c     	cmp	r2, r12
700ad364: 012fff1e     	bxeq	lr
700ad368: e7d1300c     	ldrb	r3, [r1, r12]
700ad36c: e7c0300c     	strb	r3, [r0, r12]
700ad370: e28cc001     	add	r12, r12, #1
700ad374: eafffff9     	b	0x700ad360 <_loop>      @ imm = #-0x1c
		...

700ad380 <CSL_udmapCppi5SetDescType>:
; {
700ad380: b082         	sub	sp, #0x8
700ad382: 9001         	str	r0, [sp, #0x4]
700ad384: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_DTYPE, descType );
700ad386: 9901         	ldr	r1, [sp, #0x4]
700ad388: 6808         	ldr	r0, [r1]
700ad38a: f020 4040    	bic	r0, r0, #0xc0000000
700ad38e: 9a00         	ldr	r2, [sp]
700ad390: ea40 7082    	orr.w	r0, r0, r2, lsl #30
700ad394: 6008         	str	r0, [r1]
; }
700ad396: b002         	add	sp, #0x8
700ad398: 4770         	bx	lr
700ad39a: 0000         	movs	r0, r0
700ad39c: 0000         	movs	r0, r0
700ad39e: 0000         	movs	r0, r0

700ad3a0 <UART_fifoCharGet>:
; {
700ad3a0: b580         	push	{r7, lr}
700ad3a2: b082         	sub	sp, #0x8
700ad3a4: 9001         	str	r0, [sp, #0x4]
700ad3a6: 2000         	movs	r0, #0x0
;     uint32_t tempRetVal = 0U;
700ad3a8: 9000         	str	r0, [sp]
;     tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700ad3aa: 9801         	ldr	r0, [sp, #0x4]
700ad3ac: f000 fa88    	bl	0x700ad8c0 <HW_RD_REG32_RAW> @ imm = #0x510
700ad3b0: 9000         	str	r0, [sp]
;     return ((uint8_t) tempRetVal);
700ad3b2: f89d 0000    	ldrb.w	r0, [sp]
700ad3b6: b002         	add	sp, #0x8
700ad3b8: bd80         	pop	{r7, pc}
700ad3ba: 0000         	movs	r0, r0
700ad3bc: 0000         	movs	r0, r0
700ad3be: 0000         	movs	r0, r0

700ad3c0 <UART_timeGuardConfig>:
; {
700ad3c0: b580         	push	{r7, lr}
700ad3c2: b082         	sub	sp, #0x8
700ad3c4: 9001         	str	r0, [sp, #0x4]
700ad3c6: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_TIMEGUARD, UART_TIMEGUARD_TIMEGUARD,
700ad3c8: 9801         	ldr	r0, [sp, #0x4]
700ad3ca: 3094         	adds	r0, #0x94
700ad3cc: 9b00         	ldr	r3, [sp]
700ad3ce: 21ff         	movs	r1, #0xff
700ad3d0: 2200         	movs	r2, #0x0
700ad3d2: f7ff f87d    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #-0xf06
; }
700ad3d6: b002         	add	sp, #0x8
700ad3d8: bd80         	pop	{r7, pc}
700ad3da: 0000         	movs	r0, r0
700ad3dc: 0000         	movs	r0, r0
700ad3de: 0000         	movs	r0, r0

700ad3e0 <CSL_udmapCppi5SetPsDataLen>:
; {
700ad3e0: b082         	sub	sp, #0x8
700ad3e2: 9001         	str	r0, [sp, #0x4]
700ad3e4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSWCNT, (psDataLen/4U) );
700ad3e6: 9901         	ldr	r1, [sp, #0x4]
700ad3e8: 6808         	ldr	r0, [r1]
700ad3ea: 9a00         	ldr	r2, [sp]
700ad3ec: 0892         	lsrs	r2, r2, #0x2
700ad3ee: f362 509b    	bfi	r0, r2, #22, #6
700ad3f2: 6008         	str	r0, [r1]
; }
700ad3f4: b002         	add	sp, #0x8
700ad3f6: 4770         	bx	lr
		...

700ad400 <Sciclient_rmIrqSet>:
; {
700ad400: b580         	push	{r7, lr}
700ad402: b084         	sub	sp, #0x10
700ad404: 9003         	str	r0, [sp, #0xc]
700ad406: 9102         	str	r1, [sp, #0x8]
700ad408: 9201         	str	r2, [sp, #0x4]
;     return Sciclient_rmProgramInterruptRoute(req, resp, timeout);
700ad40a: 9803         	ldr	r0, [sp, #0xc]
700ad40c: 9902         	ldr	r1, [sp, #0x8]
700ad40e: 9a01         	ldr	r2, [sp, #0x4]
700ad410: f7f1 fe76    	bl	0x7009f100 <Sciclient_rmProgramInterruptRoute> @ imm = #-0xe314
700ad414: b004         	add	sp, #0x10
700ad416: bd80         	pop	{r7, pc}
		...

700ad420 <Sciclient_secProxyThreadStatusReg>:
; {
700ad420: b081         	sub	sp, #0x4
700ad422: 9000         	str	r0, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700ad424: f240 30c8    	movw	r0, #0x3c8
700ad428: f2c7 000b    	movt	r0, #0x700b
700ad42c: 6880         	ldr	r0, [r0, #0x8]
;         CSL_SEC_PROXY_RT_THREAD_STATUS(thread));
700ad42e: 9900         	ldr	r1, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700ad430: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad434: b001         	add	sp, #0x4
700ad436: 4770         	bx	lr
		...

700ad440 <TimerP_start>:
; {
700ad440: b082         	sub	sp, #0x8
700ad442: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (uint32_t *)(baseAddr + TIMER_TCLR);
700ad444: 9801         	ldr	r0, [sp, #0x4]
700ad446: 3038         	adds	r0, #0x38
700ad448: 9000         	str	r0, [sp]
;     *addr |= (0x1U << 0);
700ad44a: 9900         	ldr	r1, [sp]
700ad44c: 6808         	ldr	r0, [r1]
700ad44e: f040 0001    	orr	r0, r0, #0x1
700ad452: 6008         	str	r0, [r1]
; }
700ad454: b002         	add	sp, #0x8
700ad456: 4770         	bx	lr
		...

700ad460 <TimerP_stop>:
; {
700ad460: b082         	sub	sp, #0x8
700ad462: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
700ad464: 9801         	ldr	r0, [sp, #0x4]
700ad466: 3038         	adds	r0, #0x38
700ad468: 9000         	str	r0, [sp]
;     *addr &= ~(0x1U << 0);
700ad46a: 9900         	ldr	r1, [sp]
700ad46c: 6808         	ldr	r0, [r1]
700ad46e: f020 0001    	bic	r0, r0, #0x1
700ad472: 6008         	str	r0, [r1]
; }
700ad474: b002         	add	sp, #0x8
700ad476: 4770         	bx	lr
		...

700ad480 <UART_divisorLatchDisable>:
; {
700ad480: b580         	push	{r7, lr}
700ad482: b082         	sub	sp, #0x8
700ad484: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_DIV_EN,
700ad486: 9801         	ldr	r0, [sp, #0x4]
700ad488: 300c         	adds	r0, #0xc
700ad48a: 2180         	movs	r1, #0x80
700ad48c: 2207         	movs	r2, #0x7
700ad48e: 2300         	movs	r3, #0x0
700ad490: f7ff f81e    	bl	0x700ac4d0 <HW_WR_FIELD32_RAW> @ imm = #-0xfc4
; }
700ad494: b002         	add	sp, #0x8
700ad496: bd80         	pop	{r7, pc}
		...

700ad4a0 <UART_modemControlReset>:
; {
700ad4a0: b580         	push	{r7, lr}
700ad4a2: b082         	sub	sp, #0x8
700ad4a4: 9001         	str	r0, [sp, #0x4]
700ad4a6: 2000         	movs	r0, #0x0
;     uint32_t mcrResetVal = 0U;
700ad4a8: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_MCR, mcrResetVal);
700ad4aa: 9801         	ldr	r0, [sp, #0x4]
700ad4ac: 3010         	adds	r0, #0x10
700ad4ae: 9900         	ldr	r1, [sp]
700ad4b0: f000 fa0e    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x41c
; }
700ad4b4: b002         	add	sp, #0x8
700ad4b6: bd80         	pop	{r7, pc}
		...

700ad4c0 <UART_putChar>:
; {
700ad4c0: b580         	push	{r7, lr}
700ad4c2: b082         	sub	sp, #0x8
700ad4c4: 9001         	str	r0, [sp, #0x4]
700ad4c6: f88d 1003    	strb.w	r1, [sp, #0x3]
;     HW_WR_REG32(baseAddr + UART_THR, (uint32_t) byteTx);
700ad4ca: 9801         	ldr	r0, [sp, #0x4]
700ad4cc: f89d 1003    	ldrb.w	r1, [sp, #0x3]
700ad4d0: f000 f9fe    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x3fc
; }
700ad4d4: b002         	add	sp, #0x8
700ad4d6: bd80         	pop	{r7, pc}

700ad4d8 <TI_memset_small>:
700ad4d8: e3a03000     	mov	r3, #0

700ad4dc <_loop>:
700ad4dc: e1520003     	cmp	r2, r3
700ad4e0: 012fff1e     	bxeq	lr
700ad4e4: e7c01003     	strb	r1, [r0, r3]
700ad4e8: e2833001     	add	r3, r3, #1
700ad4ec: eafffffa     	b	0x700ad4dc <_loop>      @ imm = #-0x18

700ad4f0 <CSL_REG64_WR_RAW>:
; {
700ad4f0: b084         	sub	sp, #0x10
700ad4f2: 9003         	str	r0, [sp, #0xc]
700ad4f4: 9301         	str	r3, [sp, #0x4]
700ad4f6: 9200         	str	r2, [sp]
;     *p = v;
700ad4f8: 9800         	ldr	r0, [sp]
700ad4fa: 9901         	ldr	r1, [sp, #0x4]
700ad4fc: 9a03         	ldr	r2, [sp, #0xc]
700ad4fe: e9c2 0100    	strd	r0, r1, [r2]
;     return;
700ad502: b004         	add	sp, #0x10
700ad504: 4770         	bx	lr
		...
700ad50e: 0000         	movs	r0, r0

700ad510 <CSL_udmapCppi5LinkDesc>:
; {
700ad510: b084         	sub	sp, #0x10
700ad512: 9003         	str	r0, [sp, #0xc]
700ad514: 9301         	str	r3, [sp, #0x4]
700ad516: 9200         	str	r2, [sp]
;     pDesc->nextDescPtr = physBufferDescAddr;
700ad518: 9800         	ldr	r0, [sp]
700ad51a: 9a01         	ldr	r2, [sp, #0x4]
700ad51c: 9903         	ldr	r1, [sp, #0xc]
700ad51e: 614a         	str	r2, [r1, #0x14]
700ad520: 6108         	str	r0, [r1, #0x10]
; }
700ad522: b004         	add	sp, #0x10
700ad524: 4770         	bx	lr
		...
700ad52e: 0000         	movs	r0, r0

700ad530 <CSL_udmapCppi5SetBufferAddr>:
; {
700ad530: b084         	sub	sp, #0x10
700ad532: 9003         	str	r0, [sp, #0xc]
700ad534: 9301         	str	r3, [sp, #0x4]
700ad536: 9200         	str	r2, [sp]
;     pDesc->bufPtr    = physBufferAddr;
700ad538: 9800         	ldr	r0, [sp]
700ad53a: 9a01         	ldr	r2, [sp, #0x4]
700ad53c: 9903         	ldr	r1, [sp, #0xc]
700ad53e: 61ca         	str	r2, [r1, #0x1c]
700ad540: 6188         	str	r0, [r1, #0x18]
; }
700ad542: b004         	add	sp, #0x10
700ad544: 4770         	bx	lr
		...
700ad54e: 0000         	movs	r0, r0

700ad550 <CSL_udmapCppi5SetBufferLen>:
; {
700ad550: b082         	sub	sp, #0x8
700ad552: 9001         	str	r0, [sp, #0x4]
700ad554: 9100         	str	r1, [sp]
;     CSL_FINS( pDesc->bufInfo1, UDMAP_CPPI5_PD_BUFINFO1_LEN, bufferLenBytes );
700ad556: 9901         	ldr	r1, [sp, #0x4]
700ad558: 6a08         	ldr	r0, [r1, #0x20]
700ad55a: 9a00         	ldr	r2, [sp]
700ad55c: f362 0015    	bfi	r0, r2, #0, #22
700ad560: 6208         	str	r0, [r1, #0x20]
; }
700ad562: b002         	add	sp, #0x8
700ad564: 4770         	bx	lr
		...
700ad56e: 0000         	movs	r0, r0

700ad570 <CSL_udmapCppi5SetOrgBufferAddr>:
; {
700ad570: b084         	sub	sp, #0x10
700ad572: 9003         	str	r0, [sp, #0xc]
700ad574: 9301         	str	r3, [sp, #0x4]
700ad576: 9200         	str	r2, [sp]
;     pDesc->orgBufPtr = physBufferAddr;
700ad578: 9800         	ldr	r0, [sp]
700ad57a: 9a01         	ldr	r2, [sp, #0x4]
700ad57c: 9903         	ldr	r1, [sp, #0xc]
700ad57e: 62ca         	str	r2, [r1, #0x2c]
700ad580: 6288         	str	r0, [r1, #0x28]
; }
700ad582: b004         	add	sp, #0x10
700ad584: 4770         	bx	lr
		...
700ad58e: 0000         	movs	r0, r0

700ad590 <CSL_udmapCppi5SetPsDataLoc>:
; {
700ad590: b082         	sub	sp, #0x8
700ad592: 9001         	str	r0, [sp, #0x4]
700ad594: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSINFO, psLoc );
700ad596: 9901         	ldr	r1, [sp, #0x4]
700ad598: 6808         	ldr	r0, [r1]
700ad59a: 9a00         	ldr	r2, [sp]
700ad59c: f362 701c    	bfi	r0, r2, #28, #1
700ad5a0: 6008         	str	r0, [r1]
; }
700ad5a2: b002         	add	sp, #0x8
700ad5a4: 4770         	bx	lr
		...
700ad5ae: 0000         	movs	r0, r0

700ad5b0 <CSL_udmapCppi5SetPsFlags>:
; {
700ad5b0: b082         	sub	sp, #0x8
700ad5b2: 9001         	str	r0, [sp, #0x4]
700ad5b4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1, UDMAP_CPPI5_PD_PKTINFO1_PSFLGS, psFlags );
700ad5b6: 9901         	ldr	r1, [sp, #0x4]
700ad5b8: 6848         	ldr	r0, [r1, #0x4]
700ad5ba: 9a00         	ldr	r2, [sp]
700ad5bc: f362 601b    	bfi	r0, r2, #24, #4
700ad5c0: 6048         	str	r0, [r1, #0x4]
; }
700ad5c2: b002         	add	sp, #0x8
700ad5c4: 4770         	bx	lr
		...
700ad5ce: 0000         	movs	r0, r0

700ad5d0 <Sciclient_rmIrqRelease>:
; {
700ad5d0: b580         	push	{r7, lr}
700ad5d2: b084         	sub	sp, #0x10
700ad5d4: 9003         	str	r0, [sp, #0xc]
700ad5d6: 9102         	str	r1, [sp, #0x8]
;     return Sciclient_rmClearInterruptRoute(req, &resp, timeout);
700ad5d8: 9803         	ldr	r0, [sp, #0xc]
700ad5da: 9a02         	ldr	r2, [sp, #0x8]
700ad5dc: 4669         	mov	r1, sp
700ad5de: f7f1 fa5f    	bl	0x7009eaa0 <Sciclient_rmClearInterruptRoute> @ imm = #-0xeb42
700ad5e2: b004         	add	sp, #0x10
700ad5e4: bd80         	pop	{r7, pc}
		...
700ad5ee: 0000         	movs	r0, r0

700ad5f0 <Sciclient_secProxyReadThreadCount>:
; {
700ad5f0: b580         	push	{r7, lr}
700ad5f2: b082         	sub	sp, #0x8
700ad5f4: 9001         	str	r0, [sp, #0x4]
;     return (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ad5f6: 9801         	ldr	r0, [sp, #0x4]
700ad5f8: f7ff ff12    	bl	0x700ad420 <Sciclient_secProxyThreadStatusReg> @ imm = #-0x1dc
700ad5fc: f000 f9c0    	bl	0x700ad980 <CSL_REG32_RD_RAW> @ imm = #0x380
700ad600: b2c0         	uxtb	r0, r0
700ad602: b002         	add	sp, #0x8
700ad604: bd80         	pop	{r7, pc}
		...
700ad60e: 0000         	movs	r0, r0

700ad610 <SemaphoreP_destruct>:
; {
700ad610: b580         	push	{r7, lr}
700ad612: b082         	sub	sp, #0x8
700ad614: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700ad616: 9801         	ldr	r0, [sp, #0x4]
700ad618: 9000         	str	r0, [sp]
;     vSemaphoreDelete(pSemaphore->semHndl);
700ad61a: 9800         	ldr	r0, [sp]
700ad61c: 6d00         	ldr	r0, [r0, #0x50]
700ad61e: f7ff fb6f    	bl	0x700acd00 <vQueueDelete> @ imm = #-0x922
; }
700ad622: b002         	add	sp, #0x8
700ad624: bd80         	pop	{r7, pc}
		...
700ad62e: 0000         	movs	r0, r0

700ad630 <UART_divideRoundCloset>:
; {
700ad630: b082         	sub	sp, #0x8
700ad632: 9001         	str	r0, [sp, #0x4]
700ad634: 9100         	str	r1, [sp]
;     return ((divident + (divisor/2U))/divisor);
700ad636: 9801         	ldr	r0, [sp, #0x4]
700ad638: 9900         	ldr	r1, [sp]
700ad63a: eb00 0051    	add.w	r0, r0, r1, lsr #1
700ad63e: fbb0 f0f1    	udiv	r0, r0, r1
700ad642: b002         	add	sp, #0x8
700ad644: 4770         	bx	lr
		...
700ad64e: 0000         	movs	r0, r0

700ad650 <UART_regConfModeRestore>:
; {
700ad650: b580         	push	{r7, lr}
700ad652: b082         	sub	sp, #0x8
700ad654: 9001         	str	r0, [sp, #0x4]
700ad656: 9100         	str	r1, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad658: 9801         	ldr	r0, [sp, #0x4]
700ad65a: 300c         	adds	r0, #0xc
700ad65c: 9900         	ldr	r1, [sp]
700ad65e: f000 f937    	bl	0x700ad8d0 <HW_WR_REG32_RAW> @ imm = #0x26e
; }
700ad662: b002         	add	sp, #0x8
700ad664: bd80         	pop	{r7, pc}
		...
700ad66e: 0000         	movs	r0, r0

700ad670 <tm_memory_pool_allocate>:
; {
700ad670: b510         	push	{r4, lr}
;    *memory_ptr = pvPortMalloc(128);
700ad672: 2080         	movs	r0, #0x80
700ad674: 460c         	mov	r4, r1
;    *memory_ptr = pvPortMalloc(128);
700ad676: f7ff fe53    	bl	0x700ad320 <pvPortMalloc> @ imm = #-0x35a
700ad67a: 4601         	mov	r1, r0
;    if (*memory_ptr == NULL)
700ad67c: fab0 f080    	clz	r0, r0
700ad680: 0940         	lsrs	r0, r0, #0x5
;    *memory_ptr = pvPortMalloc(128);
700ad682: 6021         	str	r1, [r4]
; }
700ad684: bd10         	pop	{r4, pc}
		...
700ad68e: 0000         	movs	r0, r0

700ad690 <tm_thread_resume>:
; {
700ad690: b580         	push	{r7, lr}
;    vTaskResume(tm_thread_array[thread_id]);
700ad692: f644 61d0    	movw	r1, #0x4ed0
700ad696: f2c7 0108    	movt	r1, #0x7008
700ad69a: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700ad69e: f7fa f8e7    	bl	0x700a7870 <vTaskResume> @ imm = #-0x5e32
;    return TM_SUCCESS;
700ad6a2: 2000         	movs	r0, #0x0
700ad6a4: bd80         	pop	{r7, pc}
		...
700ad6ae: 0000         	movs	r0, r0

700ad6b0 <DebugP_uartSetDrvIndex>:
; {
700ad6b0: b081         	sub	sp, #0x4
700ad6b2: 9000         	str	r0, [sp]
;     gDebugP_uartDrvIndex = uartDrvIndex;
700ad6b4: 9800         	ldr	r0, [sp]
700ad6b6: f240 41c4    	movw	r1, #0x4c4
700ad6ba: f2c7 010b    	movt	r1, #0x700b
700ad6be: 6008         	str	r0, [r1]
; }
700ad6c0: b001         	add	sp, #0x4
700ad6c2: 4770         	bx	lr
		...

700ad6d0 <Sciclient_rmIrIntControlReg>:
; {
700ad6d0: b081         	sub	sp, #0x4
700ad6d2: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (outp * SCICLIENT_IR_INT_CONTROL_REG_STEP) +
700ad6d6: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700ad6da: 2004         	movs	r0, #0x4
700ad6dc: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ad6e0: b001         	add	sp, #0x4
700ad6e2: 4770         	bx	lr
		...

700ad6f0 <Udma_rmAllocFreeRing>:
; {
700ad6f0: b082         	sub	sp, #0x8
700ad6f2: 9001         	str	r0, [sp, #0x4]
700ad6f4: f64f 70ff    	movw	r0, #0xffff
;     uint16_t            ringNum = UDMA_RING_INVALID;
700ad6f8: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (ringNum);
700ad6fc: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ad700: b002         	add	sp, #0x8
700ad702: 4770         	bx	lr
		...

700ad710 <xTaskGetCurrentTaskHandle>:
; TaskHandle_t xTaskGetCurrentTaskHandle(void) {
700ad710: b081         	sub	sp, #0x4
;   xReturn = pxCurrentTCB;
700ad712: f240 40dc    	movw	r0, #0x4dc
700ad716: f2c7 000b    	movt	r0, #0x700b
700ad71a: 6800         	ldr	r0, [r0]
700ad71c: 9000         	str	r0, [sp]
;   return xReturn;
700ad71e: 9800         	ldr	r0, [sp]
700ad720: b001         	add	sp, #0x4
700ad722: 4770         	bx	lr
		...

700ad730 <CSL_udmapCppi5SetSrcTag>:
; {
700ad730: b082         	sub	sp, #0x8
700ad732: 9001         	str	r0, [sp, #0x4]
700ad734: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_SRCTAG, srcTag );
700ad736: 9901         	ldr	r1, [sp, #0x4]
700ad738: f8bd 0000    	ldrh.w	r0, [sp]
700ad73c: 81c8         	strh	r0, [r1, #0xe]
; }
700ad73e: b002         	add	sp, #0x8
700ad740: 4770         	bx	lr
		...
700ad74e: 0000         	movs	r0, r0

700ad750 <TimerP_getCount>:
; {
700ad750: b082         	sub	sp, #0x8
700ad752: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
700ad754: 9801         	ldr	r0, [sp, #0x4]
700ad756: 303c         	adds	r0, #0x3c
700ad758: 9000         	str	r0, [sp]
;     return *addr;
700ad75a: 9800         	ldr	r0, [sp]
700ad75c: 6800         	ldr	r0, [r0]
700ad75e: b002         	add	sp, #0x8
700ad760: 4770         	bx	lr
		...
700ad76e: 0000         	movs	r0, r0

700ad770 <TimerP_getReloadCount>:
; {
700ad770: b082         	sub	sp, #0x8
700ad772: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
700ad774: 9801         	ldr	r0, [sp, #0x4]
700ad776: 3040         	adds	r0, #0x40
700ad778: 9000         	str	r0, [sp]
;     return *addr;
700ad77a: 9800         	ldr	r0, [sp]
700ad77c: 6800         	ldr	r0, [r0]
700ad77e: b002         	add	sp, #0x8
700ad780: 4770         	bx	lr
		...
700ad78e: 0000         	movs	r0, r0

700ad790 <putchar_>:
; {
700ad790: b510         	push	{r4, lr}
700ad792: 4604         	mov	r4, r0
;     DebugP_memLogWriterPutChar(character);
700ad794: f7f2 ff7c    	bl	0x700a0690 <DebugP_memLogWriterPutChar> @ imm = #-0xd108
;     DebugP_uartLogWriterPutChar(character);
700ad798: 4620         	mov	r0, r4
700ad79a: e8bd 4010    	pop.w	{r4, lr}
700ad79e: f7fd bf3f    	b.w	0x700ab620 <DebugP_uartLogWriterPutChar> @ imm = #-0x2182
		...
700ad7ae: 0000         	movs	r0, r0

700ad7b0 <tm_interrupt_handler>:
;    if (test_interrupt_handler != NULL)
700ad7b0: f240 40e0    	movw	r0, #0x4e0
700ad7b4: f2c7 000b    	movt	r0, #0x700b
700ad7b8: 6800         	ldr	r0, [r0]
700ad7ba: 2800         	cmp	r0, #0x0
; }
700ad7bc: bf08         	it	eq
700ad7be: 4770         	bxeq	lr
;       ((void (*)(void)) test_interrupt_handler)();
700ad7c0: 4700         	bx	r0
		...
700ad7ce: 0000         	movs	r0, r0

700ad7d0 <tm_main_four>:
; {
700ad7d0: b580         	push	{r7, lr}
;    tm_initialize(tm_memory_allocation_initialize);
700ad7d2: f648 1021    	movw	r0, #0x8921
700ad7d6: f2c7 000a    	movt	r0, #0x700a
700ad7da: f000 f989    	bl	0x700adaf0 <tm_initialize> @ imm = #0x312
;    return 0;
700ad7de: 2000         	movs	r0, #0x0
700ad7e0: bd80         	pop	{r7, pc}
		...
700ad7ee: 0000         	movs	r0, r0

700ad7f0 <uiPortGetRunTimeCounterValue>:
; uint32_t uiPortGetRunTimeCounterValue() {
700ad7f0: b580         	push	{r7, lr}
700ad7f2: b082         	sub	sp, #0x8
;   uint64_t timeInUsecs = ClockP_getTimeUsec();
700ad7f4: f7fb f994    	bl	0x700a8b20 <ClockP_getTimeUsec> @ imm = #-0x4cd8
700ad7f8: 9101         	str	r1, [sp, #0x4]
700ad7fa: 9000         	str	r0, [sp]
;   return (uint32_t)(timeInUsecs);
700ad7fc: 9800         	ldr	r0, [sp]
700ad7fe: b002         	add	sp, #0x8
700ad800: bd80         	pop	{r7, pc}
		...
700ad80e: 0000         	movs	r0, r0

700ad810 <CSL_REG32_WR_RAW>:
; {
700ad810: b082         	sub	sp, #0x8
700ad812: 9001         	str	r0, [sp, #0x4]
700ad814: 9100         	str	r1, [sp]
;     *p = v;
700ad816: 9800         	ldr	r0, [sp]
700ad818: 9901         	ldr	r1, [sp, #0x4]
700ad81a: 6008         	str	r0, [r1]
;     return;
700ad81c: b002         	add	sp, #0x8
700ad81e: 4770         	bx	lr

700ad820 <CSL_REG32_WR_RAW>:
; {
700ad820: b082         	sub	sp, #0x8
700ad822: 9001         	str	r0, [sp, #0x4]
700ad824: 9100         	str	r1, [sp]
;     *p = v;
700ad826: 9800         	ldr	r0, [sp]
700ad828: 9901         	ldr	r1, [sp, #0x4]
700ad82a: 6008         	str	r0, [r1]
;     return;
700ad82c: b002         	add	sp, #0x8
700ad82e: 4770         	bx	lr

700ad830 <CSL_REG32_WR_RAW>:
; {
700ad830: b082         	sub	sp, #0x8
700ad832: 9001         	str	r0, [sp, #0x4]
700ad834: 9100         	str	r1, [sp]
;     *p = v;
700ad836: 9800         	ldr	r0, [sp]
700ad838: 9901         	ldr	r1, [sp, #0x4]
700ad83a: 6008         	str	r0, [r1]
;     return;
700ad83c: b002         	add	sp, #0x8
700ad83e: 4770         	bx	lr

700ad840 <CSL_REG32_WR_RAW>:
; {
700ad840: b082         	sub	sp, #0x8
700ad842: 9001         	str	r0, [sp, #0x4]
700ad844: 9100         	str	r1, [sp]
;     *p = v;
700ad846: 9800         	ldr	r0, [sp]
700ad848: 9901         	ldr	r1, [sp, #0x4]
700ad84a: 6008         	str	r0, [r1]
;     return;
700ad84c: b002         	add	sp, #0x8
700ad84e: 4770         	bx	lr

700ad850 <CSL_REG32_WR_RAW>:
; {
700ad850: b082         	sub	sp, #0x8
700ad852: 9001         	str	r0, [sp, #0x4]
700ad854: 9100         	str	r1, [sp]
;     *p = v;
700ad856: 9800         	ldr	r0, [sp]
700ad858: 9901         	ldr	r1, [sp, #0x4]
700ad85a: 6008         	str	r0, [r1]
;     return;
700ad85c: b002         	add	sp, #0x8
700ad85e: 4770         	bx	lr

700ad860 <CSL_REG32_WR_RAW>:
; {
700ad860: b082         	sub	sp, #0x8
700ad862: 9001         	str	r0, [sp, #0x4]
700ad864: 9100         	str	r1, [sp]
;     *p = v;
700ad866: 9800         	ldr	r0, [sp]
700ad868: 9901         	ldr	r1, [sp, #0x4]
700ad86a: 6008         	str	r0, [r1]
;     return;
700ad86c: b002         	add	sp, #0x8
700ad86e: 4770         	bx	lr

700ad870 <CSL_udmapCppi5SetDstTag>:
; {
700ad870: b082         	sub	sp, #0x8
700ad872: 9001         	str	r0, [sp, #0x4]
700ad874: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_DSTTAG, dstTag );
700ad876: 9901         	ldr	r1, [sp, #0x4]
700ad878: 9800         	ldr	r0, [sp]
700ad87a: 8188         	strh	r0, [r1, #0xc]
; }
700ad87c: b002         	add	sp, #0x8
700ad87e: 4770         	bx	lr

700ad880 <CSL_udmapCppi5SetOrgBufferLen>:
; {
700ad880: b082         	sub	sp, #0x8
700ad882: 9001         	str	r0, [sp, #0x4]
700ad884: 9100         	str	r1, [sp]
;     pDesc->orgBufLen = bufferLenBytes;
700ad886: 9800         	ldr	r0, [sp]
700ad888: 9901         	ldr	r1, [sp, #0x4]
700ad88a: 6248         	str	r0, [r1, #0x24]
; }
700ad88c: b002         	add	sp, #0x8
700ad88e: 4770         	bx	lr

700ad890 <ClockP_getTimerCount>:
; {
700ad890: b580         	push	{r7, lr}
700ad892: b082         	sub	sp, #0x8
700ad894: 9001         	str	r0, [sp, #0x4]
;     return TimerP_getCount(timerBaseAddr);
700ad896: 9801         	ldr	r0, [sp, #0x4]
700ad898: f7ff ff5a    	bl	0x700ad750 <TimerP_getCount> @ imm = #-0x14c
700ad89c: b002         	add	sp, #0x8
700ad89e: bd80         	pop	{r7, pc}

700ad8a0 <ClockP_sleepTicks>:
; {
700ad8a0: b580         	push	{r7, lr}
700ad8a2: b082         	sub	sp, #0x8
700ad8a4: 9001         	str	r0, [sp, #0x4]
;     vTaskDelay(ticks);
700ad8a6: 9801         	ldr	r0, [sp, #0x4]
700ad8a8: f7fe fcda    	bl	0x700ac260 <vTaskDelay> @ imm = #-0x164c
; }
700ad8ac: b002         	add	sp, #0x8
700ad8ae: bd80         	pop	{r7, pc}

700ad8b0 <ClockP_timerClearOverflowInt>:
; {
700ad8b0: b580         	push	{r7, lr}
700ad8b2: b082         	sub	sp, #0x8
700ad8b4: 9001         	str	r0, [sp, #0x4]
;     TimerP_clearOverflowInt(timerBaseAddr);
700ad8b6: 9801         	ldr	r0, [sp, #0x4]
700ad8b8: f7ff f8a2    	bl	0x700aca00 <TimerP_clearOverflowInt> @ imm = #-0xebc
; }
700ad8bc: b002         	add	sp, #0x8
700ad8be: bd80         	pop	{r7, pc}

700ad8c0 <HW_RD_REG32_RAW>:
; {
700ad8c0: b082         	sub	sp, #0x8
700ad8c2: 9001         	str	r0, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700ad8c4: 9801         	ldr	r0, [sp, #0x4]
700ad8c6: 6800         	ldr	r0, [r0]
700ad8c8: 9000         	str	r0, [sp]
;     return (regVal);
700ad8ca: 9800         	ldr	r0, [sp]
700ad8cc: b002         	add	sp, #0x8
700ad8ce: 4770         	bx	lr

700ad8d0 <HW_WR_REG32_RAW>:
; {
700ad8d0: b082         	sub	sp, #0x8
700ad8d2: 9001         	str	r0, [sp, #0x4]
700ad8d4: 9100         	str	r1, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = value;
700ad8d6: 9800         	ldr	r0, [sp]
700ad8d8: 9901         	ldr	r1, [sp, #0x4]
700ad8da: 6008         	str	r0, [r1]
;     return;
700ad8dc: b002         	add	sp, #0x8
700ad8de: 4770         	bx	lr

700ad8e0 <Udma_defaultVirtToPhyFxn>:
; {
700ad8e0: b083         	sub	sp, #0xc
700ad8e2: 9002         	str	r0, [sp, #0x8]
700ad8e4: 9101         	str	r1, [sp, #0x4]
700ad8e6: 9200         	str	r2, [sp]
;     return ((uint64_t) virtAddr);
700ad8e8: 9802         	ldr	r0, [sp, #0x8]
700ad8ea: 2100         	movs	r1, #0x0
700ad8ec: b003         	add	sp, #0xc
700ad8ee: 4770         	bx	lr

700ad8f0 <__aeabi_memset8>:
700ad8f0: e1a03001     	mov	r3, r1
700ad8f4: e1a01002     	mov	r1, r2
700ad8f8: e1a02003     	mov	r2, r3
700ad8fc: eafffef5     	b	0x700ad4d8 <TI_memset_small> @ imm = #-0x42c

700ad900 <_out_null>:
; {
700ad900: b084         	sub	sp, #0x10
700ad902: f88d 000f    	strb.w	r0, [sp, #0xf]
700ad906: 9102         	str	r1, [sp, #0x8]
700ad908: 9201         	str	r2, [sp, #0x4]
700ad90a: 9300         	str	r3, [sp]
; }
700ad90c: b004         	add	sp, #0x10
700ad90e: 4770         	bx	lr

700ad910 <vTaskSuspendAll>:
;   ++uxSchedulerSuspended;
700ad910: f240 5100    	movw	r1, #0x500
700ad914: f2c7 010b    	movt	r1, #0x700b
700ad918: 6808         	ldr	r0, [r1]
700ad91a: 3001         	adds	r0, #0x1
700ad91c: 6008         	str	r0, [r1]
; }
700ad91e: 4770         	bx	lr

700ad920 <CSL_REG64_RD_RAW>:
; {
700ad920: b081         	sub	sp, #0x4
700ad922: 9000         	str	r0, [sp]
;     return (*p);
700ad924: 9800         	ldr	r0, [sp]
700ad926: e9d0 0100    	ldrd	r0, r1, [r0]
700ad92a: b001         	add	sp, #0x4
700ad92c: 4770         	bx	lr
700ad92e: 0000         	movs	r0, r0

700ad930 <vListInitialiseItem>:
; {
700ad930: b081         	sub	sp, #0x4
700ad932: 9000         	str	r0, [sp]
;     pxItem->pxContainer = NULL;
700ad934: 9900         	ldr	r1, [sp]
700ad936: 2000         	movs	r0, #0x0
700ad938: 6108         	str	r0, [r1, #0x10]
; }
700ad93a: b001         	add	sp, #0x4
700ad93c: 4770         	bx	lr
700ad93e: 0000         	movs	r0, r0

700ad940 <vTaskMissedYield>:
; void vTaskMissedYield(void) { xYieldPending = pdTRUE; }
700ad940: f240 512c    	movw	r1, #0x52c
700ad944: f2c7 010b    	movt	r1, #0x700b
700ad948: 2001         	movs	r0, #0x1
700ad94a: 6008         	str	r0, [r1]
700ad94c: 4770         	bx	lr
700ad94e: 0000         	movs	r0, r0

700ad950 <CSL_REG32_RD_RAW>:
; {
700ad950: b081         	sub	sp, #0x4
700ad952: 9000         	str	r0, [sp]
;     return (*p);
700ad954: 9800         	ldr	r0, [sp]
700ad956: 6800         	ldr	r0, [r0]
700ad958: b001         	add	sp, #0x4
700ad95a: 4770         	bx	lr
700ad95c: 0000         	movs	r0, r0
700ad95e: 0000         	movs	r0, r0

700ad960 <CSL_REG32_RD_RAW>:
; {
700ad960: b081         	sub	sp, #0x4
700ad962: 9000         	str	r0, [sp]
;     return (*p);
700ad964: 9800         	ldr	r0, [sp]
700ad966: 6800         	ldr	r0, [r0]
700ad968: b001         	add	sp, #0x4
700ad96a: 4770         	bx	lr
700ad96c: 0000         	movs	r0, r0
700ad96e: 0000         	movs	r0, r0

700ad970 <CSL_REG32_RD_RAW>:
; {
700ad970: b081         	sub	sp, #0x4
700ad972: 9000         	str	r0, [sp]
;     return (*p);
700ad974: 9800         	ldr	r0, [sp]
700ad976: 6800         	ldr	r0, [r0]
700ad978: b001         	add	sp, #0x4
700ad97a: 4770         	bx	lr
700ad97c: 0000         	movs	r0, r0
700ad97e: 0000         	movs	r0, r0

700ad980 <CSL_REG32_RD_RAW>:
; {
700ad980: b081         	sub	sp, #0x4
700ad982: 9000         	str	r0, [sp]
;     return (*p);
700ad984: 9800         	ldr	r0, [sp]
700ad986: 6800         	ldr	r0, [r0]
700ad988: b001         	add	sp, #0x4
700ad98a: 4770         	bx	lr
700ad98c: 0000         	movs	r0, r0
700ad98e: 0000         	movs	r0, r0

700ad990 <CSL_REG32_RD_RAW>:
; {
700ad990: b081         	sub	sp, #0x4
700ad992: 9000         	str	r0, [sp]
;     return (*p);
700ad994: 9800         	ldr	r0, [sp]
700ad996: 6800         	ldr	r0, [r0]
700ad998: b001         	add	sp, #0x4
700ad99a: 4770         	bx	lr
700ad99c: 0000         	movs	r0, r0
700ad99e: 0000         	movs	r0, r0

700ad9a0 <CSL_REG32_RD_RAW>:
; {
700ad9a0: b081         	sub	sp, #0x4
700ad9a2: 9000         	str	r0, [sp]
;     return (*p);
700ad9a4: 9800         	ldr	r0, [sp]
700ad9a6: 6800         	ldr	r0, [r0]
700ad9a8: b001         	add	sp, #0x4
700ad9aa: 4770         	bx	lr
700ad9ac: 0000         	movs	r0, r0
700ad9ae: 0000         	movs	r0, r0

700ad9b0 <PMU_resetCounters>:
; static void PMU_resetCounters(void) {
700ad9b0: b580         	push	{r7, lr}
;   CSL_armR5PmuResetCycleCnt();
700ad9b2: f7f2 edb0    	blx	0x700a0514 <CSL_armR5PmuResetCycleCnt> @ imm = #-0xd4a0
;   CSL_armR5PmuResetCntrs();
700ad9b6: f7f2 edb6    	blx	0x700a0524 <CSL_armR5PmuResetCntrs> @ imm = #-0xd494
; }
700ad9ba: bd80         	pop	{r7, pc}
700ad9bc: 0000         	movs	r0, r0
700ad9be: 0000         	movs	r0, r0

700ad9c0 <Sciclient_getSelfDevIdCore>:
;     return gSciclientHandle.devIdCore;
700ad9c0: f240 4038    	movw	r0, #0x438
700ad9c4: f2c7 000b    	movt	r0, #0x700b
700ad9c8: 6880         	ldr	r0, [r0, #0x8]
700ad9ca: 4770         	bx	lr
700ad9cc: 0000         	movs	r0, r0
700ad9ce: 0000         	movs	r0, r0

700ad9d0 <Sciclient_rmPsGetPsp>:
;     return gPstack.psp;
700ad9d0: f241 0058    	movw	r0, #0x1058
700ad9d4: f2c7 0008    	movt	r0, #0x7008
700ad9d8: 8c80         	ldrh	r0, [r0, #0x24]
700ad9da: 4770         	bx	lr
700ad9dc: 0000         	movs	r0, r0
700ad9de: 0000         	movs	r0, r0

700ad9e0 <Udma_rmFreeFreeRing>:
; {
700ad9e0: b082         	sub	sp, #0x8
700ad9e2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad9e6: 9100         	str	r1, [sp]
;     return;
700ad9e8: b002         	add	sp, #0x8
700ad9ea: 4770         	bx	lr
700ad9ec: 0000         	movs	r0, r0
700ad9ee: 0000         	movs	r0, r0

700ad9f0 <tm_memory_pool_deallocate>:
; {
700ad9f0: b580         	push	{r7, lr}
700ad9f2: 4608         	mov	r0, r1
;    vPortFree(memory_ptr);
700ad9f4: f7ff fbb4    	bl	0x700ad160 <vPortFree>  @ imm = #-0x898
;    return TM_SUCCESS;
700ad9f8: 2000         	movs	r0, #0x0
700ad9fa: bd80         	pop	{r7, pc}
700ad9fc: 0000         	movs	r0, r0
700ad9fe: 0000         	movs	r0, r0

700ada00 <xTaskGetIdleTaskHandle>:
;   return xIdleTaskHandle;
700ada00: f240 500c    	movw	r0, #0x50c
700ada04: f2c7 000b    	movt	r0, #0x700b
700ada08: 6800         	ldr	r0, [r0]
700ada0a: 4770         	bx	lr
700ada0c: 0000         	movs	r0, r0
700ada0e: 0000         	movs	r0, r0

700ada10 <Hwip_dataAndInstructionBarrier>:
;     __asm__ __volatile__ (" isb"   "\n\t": : : "memory");
700ada10: f3bf 8f6f    	isb	sy
;     __asm__ __volatile__ (" dsb"   "\n\t": : : "memory");
700ada14: f3bf 8f4f    	dsb	sy
; }
700ada18: 4770         	bx	lr
700ada1a: 0000         	movs	r0, r0
700ada1c: 0000         	movs	r0, r0
700ada1e: 0000         	movs	r0, r0

700ada20 <prvTaskExitError>:
; static void prvTaskExitError(void) {
700ada20: b580         	push	{r7, lr}
700ada22: 2000         	movs	r0, #0x0
;   DebugP_assertNoLog(0);
700ada24: f001 fae4    	bl	0x700aeff0 <_DebugP_assertNoLog> @ imm = #0x15c8
; }
700ada28: bd80         	pop	{r7, pc}
700ada2a: 0000         	movs	r0, r0
700ada2c: 0000         	movs	r0, r0
700ada2e: 0000         	movs	r0, r0

700ada30 <tm_thread_sleep>:
; {
700ada30: f44f 717a    	mov.w	r1, #0x3e8
;    vTaskDelay((seconds * 1000U) / portTICK_RATE_MS);
700ada34: 4348         	muls	r0, r1, r0
700ada36: f7fe bc13    	b.w	0x700ac260 <vTaskDelay> @ imm = #-0x17da
700ada3a: 0000         	movs	r0, r0
700ada3c: 0000         	movs	r0, r0
700ada3e: 0000         	movs	r0, r0

700ada40 <ClockP_getTicks>:
; {
700ada40: b580         	push	{r7, lr}
;     return ((uint32_t)xTaskGetTickCount());
700ada42: f7ff fc3d    	bl	0x700ad2c0 <xTaskGetTickCount> @ imm = #-0x786
700ada46: bd80         	pop	{r7, pc}
		...

700ada50 <UART_lld_errorCallback>:
; {
700ada50: b081         	sub	sp, #0x4
700ada52: 9000         	str	r0, [sp]
; }
700ada54: b001         	add	sp, #0x4
700ada56: 4770         	bx	lr
		...

700ada60 <Udma_ringAssertFnPointers>:
; {
700ada60: b081         	sub	sp, #0x4
700ada62: 9000         	str	r0, [sp]
;     return;
700ada64: b001         	add	sp, #0x4
700ada66: 4770         	bx	lr
		...

700ada70 <vApplicationIdleHook>:
; void vApplicationIdleHook(void) {
700ada70: b580         	push	{r7, lr}
;   vApplicationLoadHook();
700ada72: f7fc f925    	bl	0x700a9cc0 <vApplicationLoadHook> @ imm = #-0x3db6
; }
700ada76: bd80         	pop	{r7, pc}
		...

700ada80 <Board_driversOpen>:
;     return status;
700ada80: 2000         	movs	r0, #0x0
700ada82: 4770         	bx	lr
		...

700ada90 <Sciclient_rmPsGetMaxPsp>:
; {
700ada90: 2003         	movs	r0, #0x3
;     return SCICLIENT_PS_MAX_DEPTH;
700ada92: 4770         	bx	lr
		...

700adaa0 <TaskP_yield>:
;     taskYIELD();
700adaa0: df00         	svc	#0x0
; }
700adaa2: 4770         	bx	lr
		...

700adab0 <main>:
;    return rtos_main_freertos();
700adab0: f7f9 b8ee    	b.w	0x700a6c90 <rtos_main_freertos> @ imm = #-0x6e24
		...

700adac0 <tm_memory_pool_create>:
;    return TM_SUCCESS;
700adac0: 2000         	movs	r0, #0x0
700adac2: 4770         	bx	lr
		...

700adad0 <tm_pmu_profile_start>:
;    PMU_profileStart(name);
700adad0: f7f9 bc9e    	b.w	0x700a7410 <PMU_profileStart> @ imm = #-0x66c4
		...

700adae0 <Board_init>:
; }
700adae0: 4770         	bx	lr
		...
700adaee: 0000         	movs	r0, r0

700adaf0 <tm_initialize>:
;    test_initialization_function();
700adaf0: 4700         	bx	r0
		...
700adafe: 0000         	movs	r0, r0

700adb00 <vPortConfigTimerForRunTimeStats>:
; }
700adb00: 4770         	bx	lr
		...
700adb0e: 0000         	movs	r0, r0
