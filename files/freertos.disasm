
.\files\freertos.out:	file format elf32-littlearm

Disassembly of section .vectors:

00000000 <_vectors>:
;         LDR pc, reset_addr          // Reset
       0: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x20 <reset_addr>
;         LDR pc, undefined_addr      // Undefined Instruction
       4: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x24 <undefined_addr>
;         LDR pc, svc_addr            // Software interrupt
       8: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x28 <svc_addr>
;         LDR pc, prefetch_abort_addr // Abort (prefetch)
       c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x2c <prefetch_abort_addr>
;         LDR pc, data_abort_addr     // Abort (data)
      10: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x30 <data_abort_addr>
;         LDR pc, reserved_addr       // rsvd
      14: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x34 <reserved_addr>
;         LDR pc, irq_addr            // IRQ
      18: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x38 <irq_addr>
;         LDR pc, fiq_addr            // FIQ
      1c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x3c <fiq_addr>

00000020 <reset_addr>:
      20: e4 eb 0a 70  	.word	0x700aebe4

00000024 <undefined_addr>:
      24: f1 e0 0a 70  	.word	0x700ae0f1

00000028 <svc_addr>:
      28: dc e1 0a 70  	.word	0x700ae1dc

0000002c <prefetch_abort_addr>:
      2c: 31 e1 0a 70  	.word	0x700ae131

00000030 <data_abort_addr>:
      30: 00 e4 0a 70  	.word	0x700ae400

00000034 <reserved_addr>:
      34: b1 e0 0a 70  	.word	0x700ae0b1

00000038 <irq_addr>:
      38: 4c e2 0a 70  	.word	0x700ae24c

0000003c <fiq_addr>:
      3c: 41 df 0a 70  	.word	0x700adf41

Disassembly of section .text.hwi:

700ad830 <HwiP_enableInt>:
; {
700ad830: b580         	push	{r7, lr}
700ad832: b084         	sub	sp, #0x10
700ad834: 9003         	str	r0, [sp, #0xc]
;     Hwip_dataAndInstructionBarrier();
700ad836: f7ff ff9b    	bl	0x700ad770 <Hwip_dataAndInstructionBarrier> @ imm = #-0xca
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_EN(intNum));
700ad83a: f240 10b8    	movw	r0, #0x1b8
700ad83e: f2c7 000b    	movt	r0, #0x700b
700ad842: 6801         	ldr	r1, [r0]
700ad844: 9803         	ldr	r0, [sp, #0xc]
700ad846: f400 70f0    	and	r0, r0, #0x1e0
700ad84a: 4408         	add	r0, r1
700ad84c: f500 6081    	add.w	r0, r0, #0x408
700ad850: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700ad852: 9803         	ldr	r0, [sp, #0xc]
700ad854: f000 001f    	and	r0, r0, #0x1f
700ad858: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700ad85a: 9901         	ldr	r1, [sp, #0x4]
700ad85c: 2001         	movs	r0, #0x1
700ad85e: 4088         	lsls	r0, r1
700ad860: 9902         	ldr	r1, [sp, #0x8]
700ad862: 6008         	str	r0, [r1]
; }
700ad864: b004         	add	sp, #0x10
700ad866: bd80         	pop	{r7, pc}
700ad868: bf00         	nop
700ad86a: bf00         	nop
700ad86c: bf00         	nop
700ad86e: bf00         	nop

700ad870 <HwiP_disableInt>:
; {
700ad870: b580         	push	{r7, lr}
700ad872: b084         	sub	sp, #0x10
700ad874: 9003         	str	r0, [sp, #0xc]
700ad876: 2000         	movs	r0, #0x0
;     uint32_t isEnable = 0;
700ad878: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(intNum));
700ad87a: f240 10b8    	movw	r0, #0x1b8
700ad87e: f2c7 000b    	movt	r0, #0x700b
700ad882: 6801         	ldr	r1, [r0]
700ad884: 9803         	ldr	r0, [sp, #0xc]
700ad886: f400 70f0    	and	r0, r0, #0x1e0
700ad88a: 4408         	add	r0, r1
700ad88c: f200 400c    	addw	r0, r0, #0x40c
700ad890: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700ad892: 9803         	ldr	r0, [sp, #0xc]
700ad894: f000 001f    	and	r0, r0, #0x1f
700ad898: 9001         	str	r0, [sp, #0x4]
;     if( (*addr & ((uint32_t)0x1 << bitPos))!=0U)
700ad89a: 9802         	ldr	r0, [sp, #0x8]
700ad89c: 6800         	ldr	r0, [r0]
700ad89e: 9901         	ldr	r1, [sp, #0x4]
700ad8a0: 40c8         	lsrs	r0, r1
700ad8a2: 07c0         	lsls	r0, r0, #0x1f
700ad8a4: b118         	cbz	r0, 0x700ad8ae <HwiP_disableInt+0x3e> @ imm = #0x6
700ad8a6: e7ff         	b	0x700ad8a8 <HwiP_disableInt+0x38> @ imm = #-0x2
700ad8a8: 2001         	movs	r0, #0x1
;         isEnable = 1;
700ad8aa: 9000         	str	r0, [sp]
;     }
700ad8ac: e7ff         	b	0x700ad8ae <HwiP_disableInt+0x3e> @ imm = #-0x2
;     *addr = ((uint32_t)0x1 << bitPos);
700ad8ae: 9901         	ldr	r1, [sp, #0x4]
700ad8b0: 2001         	movs	r0, #0x1
700ad8b2: 4088         	lsls	r0, r1
700ad8b4: 9902         	ldr	r1, [sp, #0x8]
700ad8b6: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700ad8b8: f7ff ff5a    	bl	0x700ad770 <Hwip_dataAndInstructionBarrier> @ imm = #-0x14c
;     return isEnable;
700ad8bc: 9800         	ldr	r0, [sp]
700ad8be: b004         	add	sp, #0x10
700ad8c0: bd80         	pop	{r7, pc}
700ad8c2: bf00         	nop
700ad8c4: bf00         	nop
700ad8c6: bf00         	nop
700ad8c8: bf00         	nop
700ad8ca: bf00         	nop
700ad8cc: bf00         	nop
700ad8ce: bf00         	nop

700ad8d0 <HwiP_restoreInt>:
; {
700ad8d0: b580         	push	{r7, lr}
700ad8d2: b082         	sub	sp, #0x8
700ad8d4: 9001         	str	r0, [sp, #0x4]
700ad8d6: 9100         	str	r1, [sp]
;     if(oldIntState!=0U)
700ad8d8: 9800         	ldr	r0, [sp]
700ad8da: b120         	cbz	r0, 0x700ad8e6 <HwiP_restoreInt+0x16> @ imm = #0x8
700ad8dc: e7ff         	b	0x700ad8de <HwiP_restoreInt+0xe> @ imm = #-0x2
;         HwiP_enableInt(intNum);
700ad8de: 9801         	ldr	r0, [sp, #0x4]
700ad8e0: f7ff ffa6    	bl	0x700ad830 <HwiP_enableInt> @ imm = #-0xb4
;     }
700ad8e4: e003         	b	0x700ad8ee <HwiP_restoreInt+0x1e> @ imm = #0x6
;        (void) HwiP_disableInt(intNum);
700ad8e6: 9801         	ldr	r0, [sp, #0x4]
700ad8e8: f7ff ffc2    	bl	0x700ad870 <HwiP_disableInt> @ imm = #-0x7c
700ad8ec: e7ff         	b	0x700ad8ee <HwiP_restoreInt+0x1e> @ imm = #-0x2
; }
700ad8ee: b002         	add	sp, #0x8
700ad8f0: bd80         	pop	{r7, pc}
700ad8f2: bf00         	nop
700ad8f4: bf00         	nop
700ad8f6: bf00         	nop
700ad8f8: bf00         	nop
700ad8fa: bf00         	nop
700ad8fc: bf00         	nop
700ad8fe: bf00         	nop

700ad900 <HwiP_clearInt>:
; {
700ad900: b083         	sub	sp, #0xc
700ad902: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_STS(intNum));
700ad904: f240 10b8    	movw	r0, #0x1b8
700ad908: f2c7 000b    	movt	r0, #0x700b
700ad90c: 6801         	ldr	r1, [r0]
700ad90e: 9802         	ldr	r0, [sp, #0x8]
700ad910: f400 70f0    	and	r0, r0, #0x1e0
700ad914: 4408         	add	r0, r1
700ad916: f200 4004    	addw	r0, r0, #0x404
700ad91a: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700ad91c: 9802         	ldr	r0, [sp, #0x8]
700ad91e: f000 001f    	and	r0, r0, #0x1f
700ad922: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)0x1 << bitPos);
700ad924: 9900         	ldr	r1, [sp]
700ad926: 2001         	movs	r0, #0x1
700ad928: 4088         	lsls	r0, r1
700ad92a: 9901         	ldr	r1, [sp, #0x4]
700ad92c: 6008         	str	r0, [r1]
; }
700ad92e: b003         	add	sp, #0xc
700ad930: 4770         	bx	lr
700ad932: bf00         	nop
700ad934: bf00         	nop
700ad936: bf00         	nop
700ad938: bf00         	nop
700ad93a: bf00         	nop
700ad93c: bf00         	nop
700ad93e: bf00         	nop

700ad940 <HwiP_post>:
; {
700ad940: b580         	push	{r7, lr}
700ad942: b084         	sub	sp, #0x10
700ad944: 9003         	str	r0, [sp, #0xc]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_RAW(intNum));
700ad946: f240 10b8    	movw	r0, #0x1b8
700ad94a: f2c7 000b    	movt	r0, #0x700b
700ad94e: 6801         	ldr	r1, [r0]
700ad950: 9803         	ldr	r0, [sp, #0xc]
700ad952: f400 70f0    	and	r0, r0, #0x1e0
700ad956: 4408         	add	r0, r1
700ad958: f500 6080    	add.w	r0, r0, #0x400
700ad95c: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700ad95e: 9803         	ldr	r0, [sp, #0xc]
700ad960: f000 001f    	and	r0, r0, #0x1f
700ad964: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700ad966: 9901         	ldr	r1, [sp, #0x4]
700ad968: 2001         	movs	r0, #0x1
700ad96a: 4088         	lsls	r0, r1
700ad96c: 9902         	ldr	r1, [sp, #0x8]
700ad96e: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700ad970: f7ff fefe    	bl	0x700ad770 <Hwip_dataAndInstructionBarrier> @ imm = #-0x204
; }
700ad974: b004         	add	sp, #0x10
700ad976: bd80         	pop	{r7, pc}
700ad978: bf00         	nop
700ad97a: bf00         	nop
700ad97c: bf00         	nop
700ad97e: bf00         	nop

700ad980 <HwiP_Params_init>:
; {
700ad980: b081         	sub	sp, #0x4
700ad982: 9000         	str	r0, [sp]
;     params->intNum = 0;
700ad984: 9900         	ldr	r1, [sp]
700ad986: 2000         	movs	r0, #0x0
700ad988: 6008         	str	r0, [r1]
;     params->callback = NULL;
700ad98a: 9900         	ldr	r1, [sp]
700ad98c: 6048         	str	r0, [r1, #0x4]
;     params->args = NULL;
700ad98e: 9900         	ldr	r1, [sp]
700ad990: 6088         	str	r0, [r1, #0x8]
;     params->eventId = 0; /* NOT USED */
700ad992: 9900         	ldr	r1, [sp]
700ad994: 8188         	strh	r0, [r1, #0xc]
;     params->priority = (HwiP_MAX_PRIORITY-1U);
700ad996: 9a00         	ldr	r2, [sp]
700ad998: 210f         	movs	r1, #0xf
700ad99a: 7391         	strb	r1, [r2, #0xe]
;     params->isFIQ = 0;
700ad99c: 9900         	ldr	r1, [sp]
700ad99e: 73c8         	strb	r0, [r1, #0xf]
;     params->isPulse = 0;
700ad9a0: 9900         	ldr	r1, [sp]
700ad9a2: 7408         	strb	r0, [r1, #0x10]
; }
700ad9a4: b001         	add	sp, #0x4
700ad9a6: 4770         	bx	lr
700ad9a8: bf00         	nop
700ad9aa: bf00         	nop
700ad9ac: bf00         	nop
700ad9ae: bf00         	nop

700ad9b0 <HwiP_construct>:
; {
700ad9b0: b580         	push	{r7, lr}
700ad9b2: b084         	sub	sp, #0x10
700ad9b4: 9003         	str	r0, [sp, #0xc]
700ad9b6: 9102         	str	r1, [sp, #0x8]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700ad9b8: 9803         	ldr	r0, [sp, #0xc]
700ad9ba: 9001         	str	r0, [sp, #0x4]
700ad9bc: 2001         	movs	r0, #0x1
;     DebugP_assertNoLog( sizeof(HwiP_Struct) <= sizeof(HwiP_Object) );
700ad9be: f001 f9a7    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x134e
;     DebugP_assertNoLog( params->callback != NULL );
700ad9c2: 9802         	ldr	r0, [sp, #0x8]
700ad9c4: 6840         	ldr	r0, [r0, #0x4]
700ad9c6: 2800         	cmp	r0, #0x0
700ad9c8: bf18         	it	ne
700ad9ca: 2001         	movne	r0, #0x1
700ad9cc: f001 f9a0    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x1340
;     DebugP_assertNoLog( params->intNum < HwiP_MAX_INTERRUPTS );
700ad9d0: 9802         	ldr	r0, [sp, #0x8]
700ad9d2: 6801         	ldr	r1, [r0]
700ad9d4: 2000         	movs	r0, #0x0
700ad9d6: 9000         	str	r0, [sp]
700ad9d8: f5b1 7f00    	cmp.w	r1, #0x200
700ad9dc: bf38         	it	lo
700ad9de: 2001         	movlo	r0, #0x1
700ad9e0: f001 f996    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x132c
700ad9e4: 9800         	ldr	r0, [sp]
;     DebugP_assertNoLog( params->priority < HwiP_MAX_PRIORITY );
700ad9e6: 9902         	ldr	r1, [sp, #0x8]
700ad9e8: 7b89         	ldrb	r1, [r1, #0xe]
700ad9ea: 2910         	cmp	r1, #0x10
700ad9ec: bf38         	it	lo
700ad9ee: 2001         	movlo	r0, #0x1
700ad9f0: f001 f98e    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x131c
;     (void) HwiP_disableInt(params->intNum);
700ad9f4: 9802         	ldr	r0, [sp, #0x8]
700ad9f6: 6800         	ldr	r0, [r0]
700ad9f8: f7ff ff3a    	bl	0x700ad870 <HwiP_disableInt> @ imm = #-0x18c
;     HwiP_clearInt(params->intNum);
700ad9fc: 9802         	ldr	r0, [sp, #0x8]
700ad9fe: 6800         	ldr	r0, [r0]
700ada00: f7ff ff7e    	bl	0x700ad900 <HwiP_clearInt> @ imm = #-0x104
;     HwiP_setAsFIQ(params->intNum, params->isFIQ);
700ada04: 9902         	ldr	r1, [sp, #0x8]
700ada06: 6808         	ldr	r0, [r1]
700ada08: 7bc9         	ldrb	r1, [r1, #0xf]
700ada0a: f000 f841    	bl	0x700ada90 <HwiP_setAsFIQ> @ imm = #0x82
;     HwiP_setPri(params->intNum, params->priority);
700ada0e: 9902         	ldr	r1, [sp, #0x8]
700ada10: 6808         	ldr	r0, [r1]
700ada12: 7b89         	ldrb	r1, [r1, #0xe]
700ada14: f000 f86c    	bl	0x700adaf0 <HwiP_setPri> @ imm = #0xd8
;     HwiP_setAsPulse(params->intNum, params->isPulse);
700ada18: 9902         	ldr	r1, [sp, #0x8]
700ada1a: 6808         	ldr	r0, [r1]
700ada1c: 7c09         	ldrb	r1, [r1, #0x10]
700ada1e: f000 f87f    	bl	0x700adb20 <HwiP_setAsPulse> @ imm = #0xfe
;     if(params->isFIQ != 0U)
700ada22: 9802         	ldr	r0, [sp, #0x8]
700ada24: 7bc0         	ldrb	r0, [r0, #0xf]
700ada26: b148         	cbz	r0, 0x700ada3c <HwiP_construct+0x8c> @ imm = #0x12
700ada28: e7ff         	b	0x700ada2a <HwiP_construct+0x7a> @ imm = #-0x2
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_fiq_handler);
700ada2a: 9802         	ldr	r0, [sp, #0x8]
700ada2c: 6800         	ldr	r0, [r0]
700ada2e: f64d 7141    	movw	r1, #0xdf41
700ada32: f2c7 010a    	movt	r1, #0x700a
700ada36: f000 f8a3    	bl	0x700adb80 <HwiP_setVecAddr> @ imm = #0x146
;     }
700ada3a: e008         	b	0x700ada4e <HwiP_construct+0x9e> @ imm = #0x10
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_irq_handler);
700ada3c: 9802         	ldr	r0, [sp, #0x8]
700ada3e: 6800         	ldr	r0, [r0]
700ada40: f24e 214c    	movw	r1, #0xe24c
700ada44: f2c7 010a    	movt	r1, #0x700a
700ada48: f000 f89a    	bl	0x700adb80 <HwiP_setVecAddr> @ imm = #0x134
700ada4c: e7ff         	b	0x700ada4e <HwiP_construct+0x9e> @ imm = #-0x2
;     gHwiCtrl.isr[params->intNum] = params->callback;
700ada4e: 9802         	ldr	r0, [sp, #0x8]
700ada50: 6802         	ldr	r2, [r0]
700ada52: 6840         	ldr	r0, [r0, #0x4]
700ada54: f240 0100    	movw	r1, #0x0
700ada58: f2c7 0108    	movt	r1, #0x7008
700ada5c: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[params->intNum] = params->args;
700ada60: 9802         	ldr	r0, [sp, #0x8]
700ada62: 6802         	ldr	r2, [r0]
700ada64: 6880         	ldr	r0, [r0, #0x8]
700ada66: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ada6a: f8c1 0800    	str.w	r0, [r1, #0x800]
;     obj->intNum = params->intNum;
700ada6e: 9802         	ldr	r0, [sp, #0x8]
700ada70: 6800         	ldr	r0, [r0]
700ada72: 9901         	ldr	r1, [sp, #0x4]
700ada74: 6008         	str	r0, [r1]
;     HwiP_enableInt(params->intNum);
700ada76: 9802         	ldr	r0, [sp, #0x8]
700ada78: 6800         	ldr	r0, [r0]
700ada7a: f7ff fed9    	bl	0x700ad830 <HwiP_enableInt> @ imm = #-0x24e
700ada7e: 2000         	movs	r0, #0x0
;     return SystemP_SUCCESS;
700ada80: b004         	add	sp, #0x10
700ada82: bd80         	pop	{r7, pc}
700ada84: bf00         	nop
700ada86: bf00         	nop
700ada88: bf00         	nop
700ada8a: bf00         	nop
700ada8c: bf00         	nop
700ada8e: bf00         	nop

700ada90 <HwiP_setAsFIQ>:
; {
700ada90: b084         	sub	sp, #0x10
700ada92: 9003         	str	r0, [sp, #0xc]
700ada94: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(intNum));
700ada96: f240 10b8    	movw	r0, #0x1b8
700ada9a: f2c7 000b    	movt	r0, #0x700b
700ada9e: 6801         	ldr	r1, [r0]
700adaa0: 9803         	ldr	r0, [sp, #0xc]
700adaa2: f400 70f0    	and	r0, r0, #0x1e0
700adaa6: 4408         	add	r0, r1
700adaa8: f500 6083    	add.w	r0, r0, #0x418
700adaac: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700adaae: 9803         	ldr	r0, [sp, #0xc]
700adab0: f000 001f    	and	r0, r0, #0x1f
700adab4: 9000         	str	r0, [sp]
;     if(isFIQ != 0U)
700adab6: 9802         	ldr	r0, [sp, #0x8]
700adab8: b148         	cbz	r0, 0x700adace <HwiP_setAsFIQ+0x3e> @ imm = #0x12
700adaba: e7ff         	b	0x700adabc <HwiP_setAsFIQ+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700adabc: 9900         	ldr	r1, [sp]
700adabe: 2001         	movs	r0, #0x1
700adac0: fa00 f201    	lsl.w	r2, r0, r1
700adac4: 9901         	ldr	r1, [sp, #0x4]
700adac6: 6808         	ldr	r0, [r1]
700adac8: 4310         	orrs	r0, r2
700adaca: 6008         	str	r0, [r1]
;     }
700adacc: e008         	b	0x700adae0 <HwiP_setAsFIQ+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700adace: 9900         	ldr	r1, [sp]
700adad0: 2001         	movs	r0, #0x1
700adad2: fa00 f201    	lsl.w	r2, r0, r1
700adad6: 9901         	ldr	r1, [sp, #0x4]
700adad8: 6808         	ldr	r0, [r1]
700adada: 4390         	bics	r0, r2
700adadc: 6008         	str	r0, [r1]
700adade: e7ff         	b	0x700adae0 <HwiP_setAsFIQ+0x50> @ imm = #-0x2
; }
700adae0: b004         	add	sp, #0x10
700adae2: 4770         	bx	lr
700adae4: bf00         	nop
700adae6: bf00         	nop
700adae8: bf00         	nop
700adaea: bf00         	nop
700adaec: bf00         	nop
700adaee: bf00         	nop

700adaf0 <HwiP_setPri>:
; {
700adaf0: b083         	sub	sp, #0xc
700adaf2: 9002         	str	r0, [sp, #0x8]
700adaf4: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_PRI(intNum));
700adaf6: f240 10b8    	movw	r0, #0x1b8
700adafa: f2c7 000b    	movt	r0, #0x700b
700adafe: 6800         	ldr	r0, [r0]
700adb00: 9902         	ldr	r1, [sp, #0x8]
700adb02: eb00 0081    	add.w	r0, r0, r1, lsl #2
700adb06: f500 5080    	add.w	r0, r0, #0x1000
700adb0a: 9000         	str	r0, [sp]
;     *addr = (priority & 0xFu);
700adb0c: 9801         	ldr	r0, [sp, #0x4]
700adb0e: f000 000f    	and	r0, r0, #0xf
700adb12: 9900         	ldr	r1, [sp]
700adb14: 6008         	str	r0, [r1]
; }
700adb16: b003         	add	sp, #0xc
700adb18: 4770         	bx	lr
700adb1a: bf00         	nop
700adb1c: bf00         	nop
700adb1e: bf00         	nop

700adb20 <HwiP_setAsPulse>:
; {
700adb20: b084         	sub	sp, #0x10
700adb22: 9003         	str	r0, [sp, #0xc]
700adb24: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700adb26: f240 10b8    	movw	r0, #0x1b8
700adb2a: f2c7 000b    	movt	r0, #0x700b
700adb2e: 6801         	ldr	r1, [r0]
700adb30: 9803         	ldr	r0, [sp, #0xc]
700adb32: f400 70f0    	and	r0, r0, #0x1e0
700adb36: 4408         	add	r0, r1
700adb38: f200 401c    	addw	r0, r0, #0x41c
700adb3c: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700adb3e: 9803         	ldr	r0, [sp, #0xc]
700adb40: f000 001f    	and	r0, r0, #0x1f
700adb44: 9000         	str	r0, [sp]
;     if(isPulse != 0U)
700adb46: 9802         	ldr	r0, [sp, #0x8]
700adb48: b148         	cbz	r0, 0x700adb5e <HwiP_setAsPulse+0x3e> @ imm = #0x12
700adb4a: e7ff         	b	0x700adb4c <HwiP_setAsPulse+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700adb4c: 9900         	ldr	r1, [sp]
700adb4e: 2001         	movs	r0, #0x1
700adb50: fa00 f201    	lsl.w	r2, r0, r1
700adb54: 9901         	ldr	r1, [sp, #0x4]
700adb56: 6808         	ldr	r0, [r1]
700adb58: 4310         	orrs	r0, r2
700adb5a: 6008         	str	r0, [r1]
;     }
700adb5c: e008         	b	0x700adb70 <HwiP_setAsPulse+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700adb5e: 9900         	ldr	r1, [sp]
700adb60: 2001         	movs	r0, #0x1
700adb62: fa00 f201    	lsl.w	r2, r0, r1
700adb66: 9901         	ldr	r1, [sp, #0x4]
700adb68: 6808         	ldr	r0, [r1]
700adb6a: 4390         	bics	r0, r2
700adb6c: 6008         	str	r0, [r1]
700adb6e: e7ff         	b	0x700adb70 <HwiP_setAsPulse+0x50> @ imm = #-0x2
; }
700adb70: b004         	add	sp, #0x10
700adb72: 4770         	bx	lr
700adb74: bf00         	nop
700adb76: bf00         	nop
700adb78: bf00         	nop
700adb7a: bf00         	nop
700adb7c: bf00         	nop
700adb7e: bf00         	nop

700adb80 <HwiP_setVecAddr>:
; {
700adb80: b083         	sub	sp, #0xc
700adb82: 9002         	str	r0, [sp, #0x8]
700adb84: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_VEC(intNum));
700adb86: f240 10b8    	movw	r0, #0x1b8
700adb8a: f2c7 000b    	movt	r0, #0x700b
700adb8e: 6800         	ldr	r0, [r0]
700adb90: 9902         	ldr	r1, [sp, #0x8]
700adb92: eb00 0081    	add.w	r0, r0, r1, lsl #2
700adb96: f500 5000    	add.w	r0, r0, #0x2000
700adb9a: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)vecAddr & 0xFFFFFFFCU);
700adb9c: 9801         	ldr	r0, [sp, #0x4]
700adb9e: f020 0003    	bic	r0, r0, #0x3
700adba2: 9900         	ldr	r1, [sp]
700adba4: 6008         	str	r0, [r1]
; }
700adba6: b003         	add	sp, #0xc
700adba8: 4770         	bx	lr
700adbaa: bf00         	nop
700adbac: bf00         	nop
700adbae: bf00         	nop

700adbb0 <HwiP_destruct>:
; {
700adbb0: b580         	push	{r7, lr}
700adbb2: b084         	sub	sp, #0x10
700adbb4: 9003         	str	r0, [sp, #0xc]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700adbb6: 9803         	ldr	r0, [sp, #0xc]
700adbb8: 9002         	str	r0, [sp, #0x8]
;    (void) HwiP_disableInt(obj->intNum);
700adbba: 9802         	ldr	r0, [sp, #0x8]
700adbbc: 6800         	ldr	r0, [r0]
700adbbe: f7ff fe57    	bl	0x700ad870 <HwiP_disableInt> @ imm = #-0x352
;     HwiP_clearInt(obj->intNum);
700adbc2: 9802         	ldr	r0, [sp, #0x8]
700adbc4: 6800         	ldr	r0, [r0]
700adbc6: f7ff fe9b    	bl	0x700ad900 <HwiP_clearInt> @ imm = #-0x2ca
;     HwiP_setAsFIQ(obj->intNum, 0);
700adbca: 9802         	ldr	r0, [sp, #0x8]
700adbcc: 6800         	ldr	r0, [r0]
700adbce: 2100         	movs	r1, #0x0
700adbd0: 9101         	str	r1, [sp, #0x4]
700adbd2: f7ff ff5d    	bl	0x700ada90 <HwiP_setAsFIQ> @ imm = #-0x146
;     HwiP_setPri(obj->intNum, HwiP_MAX_PRIORITY-1U);
700adbd6: 9802         	ldr	r0, [sp, #0x8]
700adbd8: 6800         	ldr	r0, [r0]
700adbda: 210f         	movs	r1, #0xf
700adbdc: f7ff ff88    	bl	0x700adaf0 <HwiP_setPri> @ imm = #-0xf0
700adbe0: 9901         	ldr	r1, [sp, #0x4]
;     HwiP_setAsPulse(obj->intNum, 0);
700adbe2: 9802         	ldr	r0, [sp, #0x8]
700adbe4: 6800         	ldr	r0, [r0]
700adbe6: f7ff ff9b    	bl	0x700adb20 <HwiP_setAsPulse> @ imm = #-0xca
;     HwiP_setVecAddr(obj->intNum, (uintptr_t)HwiP_irq_handler);
700adbea: 9802         	ldr	r0, [sp, #0x8]
700adbec: 6800         	ldr	r0, [r0]
700adbee: f24e 214c    	movw	r1, #0xe24c
700adbf2: f2c7 010a    	movt	r1, #0x700a
700adbf6: f7ff ffc3    	bl	0x700adb80 <HwiP_setVecAddr> @ imm = #-0x7a
700adbfa: 9801         	ldr	r0, [sp, #0x4]
;     gHwiCtrl.isr[obj->intNum] = NULL;
700adbfc: 9902         	ldr	r1, [sp, #0x8]
700adbfe: 680a         	ldr	r2, [r1]
700adc00: f240 0100    	movw	r1, #0x0
700adc04: f2c7 0108    	movt	r1, #0x7008
700adc08: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[obj->intNum] = NULL;
700adc0c: 9a02         	ldr	r2, [sp, #0x8]
700adc0e: 6812         	ldr	r2, [r2]
700adc10: eb01 0182    	add.w	r1, r1, r2, lsl #2
700adc14: f8c1 0800    	str.w	r0, [r1, #0x800]
; }
700adc18: b004         	add	sp, #0x10
700adc1a: bd80         	pop	{r7, pc}
700adc1c: bf00         	nop
700adc1e: bf00         	nop

700adc20 <HwiP_init>:
; {
700adc20: b580         	push	{r7, lr}
700adc22: b084         	sub	sp, #0x10
;     (void) HwiP_disable();
700adc24: f000 ebb4    	blx	0x700ae390 <HwiP_disable> @ imm = #0x768
;     (void) HwiP_disableFIQ();
700adc28: f000 ebba    	blx	0x700ae3a0 <HwiP_disableFIQ> @ imm = #0x774
;     DebugP_assertNoLog(gHwiConfig.intcBaseAddr != 0U);
700adc2c: f240 10b8    	movw	r0, #0x1b8
700adc30: f2c7 000b    	movt	r0, #0x700b
700adc34: 6800         	ldr	r0, [r0]
700adc36: 2800         	cmp	r0, #0x0
700adc38: bf18         	it	ne
700adc3a: 2001         	movne	r0, #0x1
700adc3c: f001 f868    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x10d0
;     gHwiCtrl.spuriousIRQCount = 0;
700adc40: f240 0100    	movw	r1, #0x0
700adc44: f2c7 0108    	movt	r1, #0x7008
700adc48: f44f 5280    	mov.w	r2, #0x1000
700adc4c: 2000         	movs	r0, #0x0
700adc4e: 5088         	str	r0, [r1, r2]
700adc50: f241 0204    	movw	r2, #0x1004
;     gHwiCtrl.spuriousFIQCount = 0;
700adc54: 5088         	str	r0, [r1, r2]
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700adc56: 9003         	str	r0, [sp, #0xc]
700adc58: e7ff         	b	0x700adc5a <HwiP_init+0x3a> @ imm = #-0x2
700adc5a: 9903         	ldr	r1, [sp, #0xc]
700adc5c: 2000         	movs	r0, #0x0
700adc5e: ebb0 2f51    	cmp.w	r0, r1, lsr #9
700adc62: d11d         	bne	0x700adca0 <HwiP_init+0x80> @ imm = #0x3a
700adc64: e7ff         	b	0x700adc66 <HwiP_init+0x46> @ imm = #-0x2
;         gHwiCtrl.isr[i] = NULL;
700adc66: 9a03         	ldr	r2, [sp, #0xc]
700adc68: f240 0100    	movw	r1, #0x0
700adc6c: f2c7 0108    	movt	r1, #0x7008
700adc70: 2000         	movs	r0, #0x0
700adc72: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gHwiCtrl.isrArgs[i] = NULL;
700adc76: 9a03         	ldr	r2, [sp, #0xc]
700adc78: eb01 0182    	add.w	r1, r1, r2, lsl #2
700adc7c: f8c1 0800    	str.w	r0, [r1, #0x800]
;         HwiP_setPri(i, 0xF);
700adc80: 9803         	ldr	r0, [sp, #0xc]
700adc82: 210f         	movs	r1, #0xf
700adc84: f7ff ff34    	bl	0x700adaf0 <HwiP_setPri> @ imm = #-0x198
;         HwiP_setVecAddr(i, (uintptr_t)HwiP_irq_handler);
700adc88: 9803         	ldr	r0, [sp, #0xc]
700adc8a: f24e 214c    	movw	r1, #0xe24c
700adc8e: f2c7 010a    	movt	r1, #0x700a
700adc92: f7ff ff75    	bl	0x700adb80 <HwiP_setVecAddr> @ imm = #-0x116
;     }
700adc96: e7ff         	b	0x700adc98 <HwiP_init+0x78> @ imm = #-0x2
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700adc98: 9803         	ldr	r0, [sp, #0xc]
700adc9a: 3001         	adds	r0, #0x1
700adc9c: 9003         	str	r0, [sp, #0xc]
700adc9e: e7dc         	b	0x700adc5a <HwiP_init+0x3a> @ imm = #-0x48
700adca0: 2000         	movs	r0, #0x0
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700adca2: 9003         	str	r0, [sp, #0xc]
700adca4: e7ff         	b	0x700adca6 <HwiP_init+0x86> @ imm = #-0x2
700adca6: 9803         	ldr	r0, [sp, #0xc]
700adca8: 280f         	cmp	r0, #0xf
700adcaa: d838         	bhi	0x700add1e <HwiP_init+0xfe> @ imm = #0x70
700adcac: e7ff         	b	0x700adcae <HwiP_init+0x8e> @ imm = #-0x2
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(i*INTERRUPT_VALUE));
700adcae: f240 11b8    	movw	r1, #0x1b8
700adcb2: f2c7 010b    	movt	r1, #0x700b
700adcb6: 6808         	ldr	r0, [r1]
700adcb8: 9a03         	ldr	r2, [sp, #0xc]
700adcba: f002 020f    	and	r2, r2, #0xf
700adcbe: eb00 1042    	add.w	r0, r0, r2, lsl #5
700adcc2: f200 400c    	addw	r0, r0, #0x40c
700adcc6: 9002         	str	r0, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700adcc8: 9a02         	ldr	r2, [sp, #0x8]
700adcca: f04f 30ff    	mov.w	r0, #0xffffffff
700adcce: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_STS(i*INTERRUPT_VALUE));
700adcd0: 680a         	ldr	r2, [r1]
700adcd2: 9b03         	ldr	r3, [sp, #0xc]
700adcd4: f003 030f    	and	r3, r3, #0xf
700adcd8: eb02 1243    	add.w	r2, r2, r3, lsl #5
700adcdc: f202 4204    	addw	r2, r2, #0x404
700adce0: 9202         	str	r2, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700adce2: 9a02         	ldr	r2, [sp, #0x8]
700adce4: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(i*INTERRUPT_VALUE));
700adce6: 6808         	ldr	r0, [r1]
700adce8: 9a03         	ldr	r2, [sp, #0xc]
700adcea: f002 020f    	and	r2, r2, #0xf
700adcee: eb00 1042    	add.w	r0, r0, r2, lsl #5
700adcf2: f200 401c    	addw	r0, r0, #0x41c
700adcf6: 9002         	str	r0, [sp, #0x8]
;         *addr = 0x0u;
700adcf8: 9a02         	ldr	r2, [sp, #0x8]
700adcfa: 2000         	movs	r0, #0x0
700adcfc: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(i*INTERRUPT_VALUE));
700adcfe: 6809         	ldr	r1, [r1]
700add00: 9a03         	ldr	r2, [sp, #0xc]
700add02: f002 020f    	and	r2, r2, #0xf
700add06: eb01 1142    	add.w	r1, r1, r2, lsl #5
700add0a: f501 6183    	add.w	r1, r1, #0x418
700add0e: 9102         	str	r1, [sp, #0x8]
;         *addr = 0x0u;
700add10: 9902         	ldr	r1, [sp, #0x8]
700add12: 6008         	str	r0, [r1]
;     }
700add14: e7ff         	b	0x700add16 <HwiP_init+0xf6> @ imm = #-0x2
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700add16: 9803         	ldr	r0, [sp, #0xc]
700add18: 3001         	adds	r0, #0x1
700add1a: 9003         	str	r0, [sp, #0xc]
700add1c: e7c3         	b	0x700adca6 <HwiP_init+0x86> @ imm = #-0x7a
;         gdummy = HwiP_getIRQVecAddr();
700add1e: f000 f817    	bl	0x700add50 <HwiP_getIRQVecAddr> @ imm = #0x2e
700add22: f644 6194    	movw	r1, #0x4e94
700add26: f2c7 0108    	movt	r1, #0x7008
700add2a: 9100         	str	r1, [sp]
700add2c: 6008         	str	r0, [r1]
;         gdummy = HwiP_getFIQVecAddr();
700add2e: f000 f81f    	bl	0x700add70 <HwiP_getFIQVecAddr> @ imm = #0x3e
700add32: 9900         	ldr	r1, [sp]
700add34: 6008         	str	r0, [r1]
700add36: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700add38: 9001         	str	r0, [sp, #0x4]
700add3a: f000 f829    	bl	0x700add90 <HwiP_ackIRQ> @ imm = #0x52
700add3e: 9801         	ldr	r0, [sp, #0x4]
;         HwiP_ackFIQ(0);
700add40: f000 f836    	bl	0x700addb0 <HwiP_ackFIQ> @ imm = #0x6c
;     HwiP_enableVIC();
700add44: f000 eb48    	blx	0x700ae3d8 <HwiP_enableVIC> @ imm = #0x690
;     HwiP_enableFIQ();
700add48: f000 eb3a    	blx	0x700ae3c0 <HwiP_enableFIQ> @ imm = #0x674
; }
700add4c: b004         	add	sp, #0x10
700add4e: bd80         	pop	{r7, pc}

700add50 <HwiP_getIRQVecAddr>:
; {
700add50: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700add52: f240 10b8    	movw	r0, #0x1b8
700add56: f2c7 000b    	movt	r0, #0x700b
700add5a: 6800         	ldr	r0, [r0]
700add5c: 3018         	adds	r0, #0x18
700add5e: 9000         	str	r0, [sp]
;     return *addr;
700add60: 9800         	ldr	r0, [sp]
700add62: 6800         	ldr	r0, [r0]
700add64: b001         	add	sp, #0x4
700add66: 4770         	bx	lr
700add68: bf00         	nop
700add6a: bf00         	nop
700add6c: bf00         	nop
700add6e: bf00         	nop

700add70 <HwiP_getFIQVecAddr>:
; {
700add70: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700add72: f240 10b8    	movw	r0, #0x1b8
700add76: f2c7 000b    	movt	r0, #0x700b
700add7a: 6800         	ldr	r0, [r0]
700add7c: 301c         	adds	r0, #0x1c
700add7e: 9000         	str	r0, [sp]
;     return *addr;
700add80: 9800         	ldr	r0, [sp]
700add82: 6800         	ldr	r0, [r0]
700add84: b001         	add	sp, #0x4
700add86: 4770         	bx	lr
700add88: bf00         	nop
700add8a: bf00         	nop
700add8c: bf00         	nop
700add8e: bf00         	nop

700add90 <HwiP_ackIRQ>:
; {
700add90: b082         	sub	sp, #0x8
700add92: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700add94: f240 10b8    	movw	r0, #0x1b8
700add98: f2c7 000b    	movt	r0, #0x700b
700add9c: 6800         	ldr	r0, [r0]
700add9e: 3018         	adds	r0, #0x18
700adda0: 9000         	str	r0, [sp]
;     *addr= intNum;
700adda2: 9801         	ldr	r0, [sp, #0x4]
700adda4: 9900         	ldr	r1, [sp]
700adda6: 6008         	str	r0, [r1]
; }
700adda8: b002         	add	sp, #0x8
700addaa: 4770         	bx	lr
700addac: bf00         	nop
700addae: bf00         	nop

700addb0 <HwiP_ackFIQ>:
; {
700addb0: b082         	sub	sp, #0x8
700addb2: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700addb4: f240 10b8    	movw	r0, #0x1b8
700addb8: f2c7 000b    	movt	r0, #0x700b
700addbc: 6800         	ldr	r0, [r0]
700addbe: 301c         	adds	r0, #0x1c
700addc0: 9000         	str	r0, [sp]
;     *addr= intNum;
700addc2: 9801         	ldr	r0, [sp, #0x4]
700addc4: 9900         	ldr	r1, [sp]
700addc6: 6008         	str	r0, [r1]
; }
700addc8: b002         	add	sp, #0x8
700addca: 4770         	bx	lr
700addcc: bf00         	nop
700addce: bf00         	nop

700addd0 <HwiP_inISR>:
; {
700addd0: b580         	push	{r7, lr}
700addd2: b082         	sub	sp, #0x8
;     uint32_t mode = (HwiP_getCPSR() & 0x1FU);
700addd4: f000 eb10    	blx	0x700ae3f8 <HwiP_getCPSR> @ imm = #0x620
700addd8: f000 001f    	and	r0, r0, #0x1f
700adddc: 9001         	str	r0, [sp, #0x4]
700addde: 2000         	movs	r0, #0x0
;     uint32_t result =0;
700adde0: 9000         	str	r0, [sp]
;     if(mode != ARMV7R_SYSTEM_MODE)
700adde2: 9801         	ldr	r0, [sp, #0x4]
700adde4: 281f         	cmp	r0, #0x1f
700adde6: d003         	beq	0x700addf0 <HwiP_inISR+0x20> @ imm = #0x6
700adde8: e7ff         	b	0x700addea <HwiP_inISR+0x1a> @ imm = #-0x2
700addea: 2001         	movs	r0, #0x1
;          result= 1;
700addec: 9000         	str	r0, [sp]
;     }
700addee: e7ff         	b	0x700addf0 <HwiP_inISR+0x20> @ imm = #-0x2
;     return result;
700addf0: 9800         	ldr	r0, [sp]
700addf2: b002         	add	sp, #0x8
700addf4: bd80         	pop	{r7, pc}
		...
700addfe: 0000         	movs	r0, r0

700ade00 <HwiP_irq_handler_c>:
; {
700ade00: b580         	push	{r7, lr}
700ade02: b086         	sub	sp, #0x18
700ade04: a804         	add	r0, sp, #0x10
;     status = HwiP_getIRQ(&intNum);
700ade06: f000 f843    	bl	0x700ade90 <HwiP_getIRQ> @ imm = #0x86
700ade0a: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700ade0c: 9805         	ldr	r0, [sp, #0x14]
700ade0e: bb78         	cbnz	r0, 0x700ade70 <HwiP_irq_handler_c+0x70> @ imm = #0x5e
700ade10: e7ff         	b	0x700ade12 <HwiP_irq_handler_c+0x12> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700ade12: 9804         	ldr	r0, [sp, #0x10]
700ade14: f000 f864    	bl	0x700adee0 <HwiP_isPulse> @ imm = #0xc8
700ade18: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700ade1a: 9803         	ldr	r0, [sp, #0xc]
700ade1c: b120         	cbz	r0, 0x700ade28 <HwiP_irq_handler_c+0x28> @ imm = #0x8
700ade1e: e7ff         	b	0x700ade20 <HwiP_irq_handler_c+0x20> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700ade20: 9804         	ldr	r0, [sp, #0x10]
700ade22: f7ff fd6d    	bl	0x700ad900 <HwiP_clearInt> @ imm = #-0x526
;         }
700ade26: e7ff         	b	0x700ade28 <HwiP_irq_handler_c+0x28> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700ade28: 9904         	ldr	r1, [sp, #0x10]
700ade2a: f240 0000    	movw	r0, #0x0
700ade2e: f2c7 0008    	movt	r0, #0x7008
700ade32: f850 1021    	ldr.w	r1, [r0, r1, lsl #2]
700ade36: 9102         	str	r1, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700ade38: 9904         	ldr	r1, [sp, #0x10]
700ade3a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ade3e: f8d0 0800    	ldr.w	r0, [r0, #0x800]
700ade42: 9001         	str	r0, [sp, #0x4]
;         HwiP_enable();
700ade44: f000 eab4    	blx	0x700ae3b0 <HwiP_enable> @ imm = #0x568
;         if(isr!=NULL)
700ade48: 9802         	ldr	r0, [sp, #0x8]
700ade4a: b120         	cbz	r0, 0x700ade56 <HwiP_irq_handler_c+0x56> @ imm = #0x8
700ade4c: e7ff         	b	0x700ade4e <HwiP_irq_handler_c+0x4e> @ imm = #-0x2
;             isr(args);
700ade4e: 9902         	ldr	r1, [sp, #0x8]
700ade50: 9801         	ldr	r0, [sp, #0x4]
700ade52: 4788         	blx	r1
;         }
700ade54: e7ff         	b	0x700ade56 <HwiP_irq_handler_c+0x56> @ imm = #-0x2
;         (void)HwiP_disable();
700ade56: f000 ea9c    	blx	0x700ae390 <HwiP_disable> @ imm = #0x538
;         if(isPulse == 0U)
700ade5a: 9803         	ldr	r0, [sp, #0xc]
700ade5c: b920         	cbnz	r0, 0x700ade68 <HwiP_irq_handler_c+0x68> @ imm = #0x8
700ade5e: e7ff         	b	0x700ade60 <HwiP_irq_handler_c+0x60> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700ade60: 9804         	ldr	r0, [sp, #0x10]
700ade62: f7ff fd4d    	bl	0x700ad900 <HwiP_clearInt> @ imm = #-0x566
;         }
700ade66: e7ff         	b	0x700ade68 <HwiP_irq_handler_c+0x68> @ imm = #-0x2
;         HwiP_ackIRQ(intNum);
700ade68: 9804         	ldr	r0, [sp, #0x10]
700ade6a: f000 f859    	bl	0x700adf20 <HwiP_ackIRQ> @ imm = #0xb2
;     }
700ade6e: e00c         	b	0x700ade8a <HwiP_irq_handler_c+0x8a> @ imm = #0x18
;         gHwiCtrl.spuriousIRQCount++;
700ade70: f240 0100    	movw	r1, #0x0
700ade74: f2c7 0108    	movt	r1, #0x7008
700ade78: f44f 5280    	mov.w	r2, #0x1000
700ade7c: 5888         	ldr	r0, [r1, r2]
700ade7e: 3001         	adds	r0, #0x1
700ade80: 5088         	str	r0, [r1, r2]
700ade82: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700ade84: f000 f84c    	bl	0x700adf20 <HwiP_ackIRQ> @ imm = #0x98
700ade88: e7ff         	b	0x700ade8a <HwiP_irq_handler_c+0x8a> @ imm = #-0x2
; }
700ade8a: b006         	add	sp, #0x18
700ade8c: bd80         	pop	{r7, pc}
700ade8e: bf00         	nop

700ade90 <HwiP_getIRQ>:
; {
700ade90: b084         	sub	sp, #0x10
700ade92: 9003         	str	r0, [sp, #0xc]
700ade94: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700ade98: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700ade9a: 9903         	ldr	r1, [sp, #0xc]
700ade9c: 2000         	movs	r0, #0x0
700ade9e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTIRQ);
700adea0: f240 10b8    	movw	r0, #0x1b8
700adea4: f2c7 000b    	movt	r0, #0x700b
700adea8: 6800         	ldr	r0, [r0]
700adeaa: 3020         	adds	r0, #0x20
700adeac: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700adeae: 9802         	ldr	r0, [sp, #0x8]
700adeb0: 6800         	ldr	r0, [r0]
700adeb2: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700adeb4: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700adeb8: 0600         	lsls	r0, r0, #0x18
700adeba: 2800         	cmp	r0, #0x0
700adebc: d508         	bpl	0x700aded0 <HwiP_getIRQ+0x40> @ imm = #0x10
700adebe: e7ff         	b	0x700adec0 <HwiP_getIRQ+0x30> @ imm = #-0x2
;         *intNum = (value & (HwiP_MAX_INTERRUPTS-1U));
700adec0: 9800         	ldr	r0, [sp]
700adec2: f36f 205f    	bfc	r0, #9, #23
700adec6: 9903         	ldr	r1, [sp, #0xc]
700adec8: 6008         	str	r0, [r1]
700adeca: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700adecc: 9001         	str	r0, [sp, #0x4]
;     }
700adece: e7ff         	b	0x700aded0 <HwiP_getIRQ+0x40> @ imm = #-0x2
;     return status;
700aded0: 9801         	ldr	r0, [sp, #0x4]
700aded2: b004         	add	sp, #0x10
700aded4: 4770         	bx	lr
700aded6: bf00         	nop
700aded8: bf00         	nop
700adeda: bf00         	nop
700adedc: bf00         	nop
700adede: bf00         	nop

700adee0 <HwiP_isPulse>:
; {
700adee0: b083         	sub	sp, #0xc
700adee2: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700adee4: f240 10b8    	movw	r0, #0x1b8
700adee8: f2c7 000b    	movt	r0, #0x700b
700adeec: 6801         	ldr	r1, [r0]
700adeee: 9802         	ldr	r0, [sp, #0x8]
700adef0: f400 70f0    	and	r0, r0, #0x1e0
700adef4: 4408         	add	r0, r1
700adef6: f200 401c    	addw	r0, r0, #0x41c
700adefa: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700adefc: 9802         	ldr	r0, [sp, #0x8]
700adefe: f000 001f    	and	r0, r0, #0x1f
700adf02: 9000         	str	r0, [sp]
;     return ((*addr >> bitPos) & 0x1u );
700adf04: 9801         	ldr	r0, [sp, #0x4]
700adf06: 6800         	ldr	r0, [r0]
700adf08: 9900         	ldr	r1, [sp]
700adf0a: 40c8         	lsrs	r0, r1
700adf0c: f000 0001    	and	r0, r0, #0x1
700adf10: b003         	add	sp, #0xc
700adf12: 4770         	bx	lr
700adf14: bf00         	nop
700adf16: bf00         	nop
700adf18: bf00         	nop
700adf1a: bf00         	nop
700adf1c: bf00         	nop
700adf1e: bf00         	nop

700adf20 <HwiP_ackIRQ>:
; {
700adf20: b082         	sub	sp, #0x8
700adf22: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700adf24: f240 10b8    	movw	r0, #0x1b8
700adf28: f2c7 000b    	movt	r0, #0x700b
700adf2c: 6800         	ldr	r0, [r0]
700adf2e: 3018         	adds	r0, #0x18
700adf30: 9000         	str	r0, [sp]
;     *addr= intNum;
700adf32: 9801         	ldr	r0, [sp, #0x4]
700adf34: 9900         	ldr	r1, [sp]
700adf36: 6008         	str	r0, [r1]
; }
700adf38: b002         	add	sp, #0x8
700adf3a: 4770         	bx	lr
700adf3c: bf00         	nop
700adf3e: bf00         	nop

700adf40 <HwiP_fiq_handler>:
; {
700adf40: b5df         	push	{r0, r1, r2, r3, r4, r6, r7, lr}
700adf42: af06         	add	r7, sp, #0x18
700adf44: b086         	sub	sp, #0x18
700adf46: 466c         	mov	r4, sp
700adf48: f36f 0402    	bfc	r4, #0, #3
700adf4c: 46a5         	mov	sp, r4
;     gdummy = HwiP_getFIQVecAddr();
700adf4e: f000 f867    	bl	0x700ae020 <HwiP_getFIQVecAddr> @ imm = #0xce
700adf52: f244 188c    	movw	r8, #0x418c
700adf56: f2c7 0808    	movt	r8, #0x7008
700adf5a: f8c8 0000    	str.w	r0, [r8]
700adf5e: a804         	add	r0, sp, #0x10
;     status = HwiP_getFIQ(&intNum);
700adf60: f000 f86e    	bl	0x700ae040 <HwiP_getFIQ> @ imm = #0xdc
700adf64: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700adf66: f8dd 8014    	ldr.w	r8, [sp, #0x14]
700adf6a: f1b8 0f00    	cmp.w	r8, #0x0
700adf6e: d13b         	bne	0x700adfe8 <HwiP_fiq_handler+0xa8> @ imm = #0x76
700adf70: e7ff         	b	0x700adf72 <HwiP_fiq_handler+0x32> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700adf72: 9804         	ldr	r0, [sp, #0x10]
700adf74: f7ff ffb4    	bl	0x700adee0 <HwiP_isPulse> @ imm = #-0x98
700adf78: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700adf7a: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700adf7e: f1b8 0f00    	cmp.w	r8, #0x0
700adf82: d004         	beq	0x700adf8e <HwiP_fiq_handler+0x4e> @ imm = #0x8
700adf84: e7ff         	b	0x700adf86 <HwiP_fiq_handler+0x46> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700adf86: 9804         	ldr	r0, [sp, #0x10]
700adf88: f7ff fcba    	bl	0x700ad900 <HwiP_clearInt> @ imm = #-0x68c
;         }
700adf8c: e7ff         	b	0x700adf8e <HwiP_fiq_handler+0x4e> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700adf8e: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700adf92: f240 0800    	movw	r8, #0x0
700adf96: f2c7 0808    	movt	r8, #0x7008
700adf9a: f858 9029    	ldr.w	r9, [r8, r9, lsl #2]
700adf9e: f8cd 9008    	str.w	r9, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700adfa2: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700adfa6: eb08 0889    	add.w	r8, r8, r9, lsl #2
700adfaa: f8d8 8800    	ldr.w	r8, [r8, #0x800]
700adfae: f8cd 8004    	str.w	r8, [sp, #0x4]
;         if(isr!=NULL)
700adfb2: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700adfb6: f1b8 0f00    	cmp.w	r8, #0x0
700adfba: d005         	beq	0x700adfc8 <HwiP_fiq_handler+0x88> @ imm = #0xa
700adfbc: e7ff         	b	0x700adfbe <HwiP_fiq_handler+0x7e> @ imm = #-0x2
;             isr(args);
700adfbe: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700adfc2: 9801         	ldr	r0, [sp, #0x4]
700adfc4: 47c0         	blx	r8
;         }
700adfc6: e7ff         	b	0x700adfc8 <HwiP_fiq_handler+0x88> @ imm = #-0x2
;         (void)HwiP_disableFIQ();
700adfc8: f000 e9ea    	blx	0x700ae3a0 <HwiP_disableFIQ> @ imm = #0x3d4
;         if(isPulse == 0U)
700adfcc: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700adfd0: f1b8 0f00    	cmp.w	r8, #0x0
700adfd4: d104         	bne	0x700adfe0 <HwiP_fiq_handler+0xa0> @ imm = #0x8
700adfd6: e7ff         	b	0x700adfd8 <HwiP_fiq_handler+0x98> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700adfd8: 9804         	ldr	r0, [sp, #0x10]
700adfda: f7ff fc91    	bl	0x700ad900 <HwiP_clearInt> @ imm = #-0x6de
;         }
700adfde: e7ff         	b	0x700adfe0 <HwiP_fiq_handler+0xa0> @ imm = #-0x2
;         HwiP_ackFIQ(intNum);
700adfe0: 9804         	ldr	r0, [sp, #0x10]
700adfe2: f000 f855    	bl	0x700ae090 <HwiP_ackFIQ> @ imm = #0xaa
;     }
700adfe6: e00f         	b	0x700ae008 <HwiP_fiq_handler+0xc8> @ imm = #0x1e
;         gHwiCtrl.spuriousFIQCount++;
700adfe8: f240 0900    	movw	r9, #0x0
700adfec: f2c7 0908    	movt	r9, #0x7008
700adff0: f241 0a04    	movw	r10, #0x1004
700adff4: f859 800a    	ldr.w	r8, [r9, r10]
700adff8: f108 0801    	add.w	r8, r8, #0x1
700adffc: f849 800a    	str.w	r8, [r9, r10]
700ae000: 2000         	movs	r0, #0x0
;         HwiP_ackFIQ(0);
700ae002: f000 f845    	bl	0x700ae090 <HwiP_ackFIQ> @ imm = #0x8a
700ae006: e7ff         	b	0x700ae008 <HwiP_fiq_handler+0xc8> @ imm = #-0x2
; }
700ae008: f1a7 0418    	sub.w	r4, r7, #0x18
700ae00c: 46a5         	mov	sp, r4
700ae00e: e8bd 40df    	pop.w	{r0, r1, r2, r3, r4, r6, r7, lr}
700ae012: f3de 8f04    	subs	pc, lr, #0x4
700ae016: bf00         	nop
700ae018: bf00         	nop
700ae01a: bf00         	nop
700ae01c: bf00         	nop
700ae01e: bf00         	nop

700ae020 <HwiP_getFIQVecAddr>:
; {
700ae020: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700ae022: f240 10b8    	movw	r0, #0x1b8
700ae026: f2c7 000b    	movt	r0, #0x700b
700ae02a: 6800         	ldr	r0, [r0]
700ae02c: 301c         	adds	r0, #0x1c
700ae02e: 9000         	str	r0, [sp]
;     return *addr;
700ae030: 9800         	ldr	r0, [sp]
700ae032: 6800         	ldr	r0, [r0]
700ae034: b001         	add	sp, #0x4
700ae036: 4770         	bx	lr
700ae038: bf00         	nop
700ae03a: bf00         	nop
700ae03c: bf00         	nop
700ae03e: bf00         	nop

700ae040 <HwiP_getFIQ>:
; {
700ae040: b084         	sub	sp, #0x10
700ae042: 9003         	str	r0, [sp, #0xc]
700ae044: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700ae048: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700ae04a: 9903         	ldr	r1, [sp, #0xc]
700ae04c: 2000         	movs	r0, #0x0
700ae04e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTFIQ);
700ae050: f240 10b8    	movw	r0, #0x1b8
700ae054: f2c7 000b    	movt	r0, #0x700b
700ae058: 6800         	ldr	r0, [r0]
700ae05a: 3024         	adds	r0, #0x24
700ae05c: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700ae05e: 9802         	ldr	r0, [sp, #0x8]
700ae060: 6800         	ldr	r0, [r0]
700ae062: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700ae064: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ae068: 0600         	lsls	r0, r0, #0x18
700ae06a: 2800         	cmp	r0, #0x0
700ae06c: d508         	bpl	0x700ae080 <HwiP_getFIQ+0x40> @ imm = #0x10
700ae06e: e7ff         	b	0x700ae070 <HwiP_getFIQ+0x30> @ imm = #-0x2
;         *intNum = (value & 0x3FFU);
700ae070: 9800         	ldr	r0, [sp]
700ae072: f36f 209f    	bfc	r0, #10, #22
700ae076: 9903         	ldr	r1, [sp, #0xc]
700ae078: 6008         	str	r0, [r1]
700ae07a: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700ae07c: 9001         	str	r0, [sp, #0x4]
;     }
700ae07e: e7ff         	b	0x700ae080 <HwiP_getFIQ+0x40> @ imm = #-0x2
;     return status;
700ae080: 9801         	ldr	r0, [sp, #0x4]
700ae082: b004         	add	sp, #0x10
700ae084: 4770         	bx	lr
700ae086: bf00         	nop
700ae088: bf00         	nop
700ae08a: bf00         	nop
700ae08c: bf00         	nop
700ae08e: bf00         	nop

700ae090 <HwiP_ackFIQ>:
; {
700ae090: b082         	sub	sp, #0x8
700ae092: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700ae094: f240 10b8    	movw	r0, #0x1b8
700ae098: f2c7 000b    	movt	r0, #0x700b
700ae09c: 6800         	ldr	r0, [r0]
700ae09e: 301c         	adds	r0, #0x1c
700ae0a0: 9000         	str	r0, [sp]
;     *addr= intNum;
700ae0a2: 9801         	ldr	r0, [sp, #0x4]
700ae0a4: 9900         	ldr	r1, [sp]
700ae0a6: 6008         	str	r0, [r1]
; }
700ae0a8: b002         	add	sp, #0x8
700ae0aa: 4770         	bx	lr
700ae0ac: bf00         	nop
700ae0ae: bf00         	nop

700ae0b0 <HwiP_reserved_handler>:
; {
700ae0b0: b5d0         	push	{r4, r6, r7, lr}
700ae0b2: af02         	add	r7, sp, #0x8
700ae0b4: b082         	sub	sp, #0x8
700ae0b6: 466c         	mov	r4, sp
700ae0b8: f36f 0402    	bfc	r4, #0, #3
700ae0bc: 46a5         	mov	sp, r4
700ae0be: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700ae0c2: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U) { ; }
700ae0c6: e7ff         	b	0x700ae0c8 <HwiP_reserved_handler+0x18> @ imm = #-0x2
700ae0c8: f8dd e004    	ldr.w	lr, [sp, #0x4]
700ae0cc: f1be 0f00    	cmp.w	lr, #0x0
700ae0d0: d001         	beq	0x700ae0d6 <HwiP_reserved_handler+0x26> @ imm = #0x2
700ae0d2: e7ff         	b	0x700ae0d4 <HwiP_reserved_handler+0x24> @ imm = #-0x2
700ae0d4: e7f8         	b	0x700ae0c8 <HwiP_reserved_handler+0x18> @ imm = #-0x10
; }
700ae0d6: f1a7 0408    	sub.w	r4, r7, #0x8
700ae0da: 46a5         	mov	sp, r4
700ae0dc: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700ae0e0: f3de 8f00    	subs	pc, lr, #0x0
700ae0e4: bf00         	nop
700ae0e6: bf00         	nop
700ae0e8: bf00         	nop
700ae0ea: bf00         	nop
700ae0ec: bf00         	nop
700ae0ee: bf00         	nop

700ae0f0 <HwiP_undefined_handler>:
; {
700ae0f0: b5d0         	push	{r4, r6, r7, lr}
700ae0f2: af02         	add	r7, sp, #0x8
700ae0f4: b082         	sub	sp, #0x8
700ae0f6: 466c         	mov	r4, sp
700ae0f8: f36f 0402    	bfc	r4, #0, #3
700ae0fc: 46a5         	mov	sp, r4
700ae0fe: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700ae102: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){  ; }
700ae106: e7ff         	b	0x700ae108 <HwiP_undefined_handler+0x18> @ imm = #-0x2
700ae108: f8dd e004    	ldr.w	lr, [sp, #0x4]
700ae10c: f1be 0f00    	cmp.w	lr, #0x0
700ae110: d001         	beq	0x700ae116 <HwiP_undefined_handler+0x26> @ imm = #0x2
700ae112: e7ff         	b	0x700ae114 <HwiP_undefined_handler+0x24> @ imm = #-0x2
700ae114: e7f8         	b	0x700ae108 <HwiP_undefined_handler+0x18> @ imm = #-0x10
; }
700ae116: f1a7 0408    	sub.w	r4, r7, #0x8
700ae11a: 46a5         	mov	sp, r4
700ae11c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700ae120: f3de 8f00    	subs	pc, lr, #0x0
700ae124: bf00         	nop
700ae126: bf00         	nop
700ae128: bf00         	nop
700ae12a: bf00         	nop
700ae12c: bf00         	nop
700ae12e: bf00         	nop

700ae130 <HwiP_prefetch_abort_handler>:
; {
700ae130: b5d0         	push	{r4, r6, r7, lr}
700ae132: af02         	add	r7, sp, #0x8
700ae134: b082         	sub	sp, #0x8
700ae136: 466c         	mov	r4, sp
700ae138: f36f 0402    	bfc	r4, #0, #3
700ae13c: 46a5         	mov	sp, r4
700ae13e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700ae142: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U)  { ;}
700ae146: e7ff         	b	0x700ae148 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x2
700ae148: f8dd e004    	ldr.w	lr, [sp, #0x4]
700ae14c: f1be 0f00    	cmp.w	lr, #0x0
700ae150: d001         	beq	0x700ae156 <HwiP_prefetch_abort_handler+0x26> @ imm = #0x2
700ae152: e7ff         	b	0x700ae154 <HwiP_prefetch_abort_handler+0x24> @ imm = #-0x2
700ae154: e7f8         	b	0x700ae148 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x10
; }
700ae156: f1a7 0408    	sub.w	r4, r7, #0x8
700ae15a: 46a5         	mov	sp, r4
700ae15c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700ae160: f3de 8f04    	subs	pc, lr, #0x4
700ae164: bf00         	nop
700ae166: bf00         	nop
700ae168: bf00         	nop
700ae16a: bf00         	nop
700ae16c: bf00         	nop
700ae16e: bf00         	nop

700ae170 <HwiP_data_abort_handler_c>:
; {
700ae170: b5d0         	push	{r4, r6, r7, lr}
700ae172: af02         	add	r7, sp, #0x8
700ae174: b082         	sub	sp, #0x8
700ae176: 466c         	mov	r4, sp
700ae178: f36f 0402    	bfc	r4, #0, #3
700ae17c: 46a5         	mov	sp, r4
700ae17e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700ae182: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){ ; }
700ae186: e7ff         	b	0x700ae188 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x2
700ae188: f8dd e004    	ldr.w	lr, [sp, #0x4]
700ae18c: f1be 0f00    	cmp.w	lr, #0x0
700ae190: d001         	beq	0x700ae196 <HwiP_data_abort_handler_c+0x26> @ imm = #0x2
700ae192: e7ff         	b	0x700ae194 <HwiP_data_abort_handler_c+0x24> @ imm = #-0x2
700ae194: e7f8         	b	0x700ae188 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x10
; }
700ae196: f1a7 0408    	sub.w	r4, r7, #0x8
700ae19a: 46a5         	mov	sp, r4
700ae19c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700ae1a0: f3de 8f04    	subs	pc, lr, #0x4

700ae1a4 <vPortRestoreTaskContext>:
;         CPS     #SYS_MODE
700ae1a4: f102001f     	cps	#0x1f
;         portRESTORE_CONTEXT
700ae1a8: e59f01c8     	ldr	r0, [pc, #0x1c8]        @ 0x700ae378 <pxCurrentTCBConst>
700ae1ac: e5901000     	ldr	r1, [r0]
700ae1b0: e591d000     	ldr	sp, [r1]
700ae1b4: e59f01c0     	ldr	r0, [pc, #0x1c0]        @ 0x700ae37c <ulPortTaskHasFPUContextConst>
700ae1b8: e49d1004     	ldr	r1, [sp], #4
700ae1bc: e5801000     	str	r1, [r0]
700ae1c0: e3510000     	cmp	r1, #0
700ae1c4: 149d0004     	ldrne	r0, [sp], #4
700ae1c8: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700ae1cc: 1ee10a10     	vmsrne	fpscr, r0
700ae1d0: f57ff01f     	clrex
700ae1d4: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700ae1d8: f8bd0a00     	rfeia	sp!

700ae1dc <HwiP_svc_handler>:
;         portSAVE_CONTEXT
700ae1dc: f96d051f     	srsdb	sp!, #0x1f
700ae1e0: f102001f     	cps	#0x1f
700ae1e4: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700ae1e8: e59f218c     	ldr	r2, [pc, #0x18c]        @ 0x700ae37c <ulPortTaskHasFPUContextConst>
700ae1ec: e5923000     	ldr	r3, [r2]
700ae1f0: e3530000     	cmp	r3, #0
700ae1f4: 1ef11a10     	vmrsne	r1, fpscr
700ae1f8: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700ae1fc: 152d1004     	strne	r1, [sp, #-0x4]!
700ae200: e52d3004     	str	r3, [sp, #-0x4]!
700ae204: e59f016c     	ldr	r0, [pc, #0x16c]        @ 0x700ae378 <pxCurrentTCBConst>
700ae208: e5901000     	ldr	r1, [r0]
700ae20c: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700ae210: e59f0168     	ldr	r0, [pc, #0x168]        @ 0x700ae380 <vTaskSwitchContextConst>
;         BLX     R0
700ae214: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700ae218: e59f0158     	ldr	r0, [pc, #0x158]        @ 0x700ae378 <pxCurrentTCBConst>
700ae21c: e5901000     	ldr	r1, [r0]
700ae220: e591d000     	ldr	sp, [r1]
700ae224: e59f0150     	ldr	r0, [pc, #0x150]        @ 0x700ae37c <ulPortTaskHasFPUContextConst>
700ae228: e49d1004     	ldr	r1, [sp], #4
700ae22c: e5801000     	str	r1, [r0]
700ae230: e3510000     	cmp	r1, #0
700ae234: 149d0004     	ldrne	r0, [sp], #4
700ae238: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700ae23c: 1ee10a10     	vmsrne	fpscr, r0
700ae240: f57ff01f     	clrex
700ae244: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700ae248: f8bd0a00     	rfeia	sp!

700ae24c <HwiP_irq_handler>:
;         SUB             lr, lr, #4
700ae24c: e24ee004     	sub	lr, lr, #4
;         PUSH    {lr}
700ae250: e52de004     	str	lr, [sp, #-0x4]!
;         MRS     lr, SPSR
700ae254: e14fe000     	mrs	lr, spsr
;         PUSH    {lr}
700ae258: e52de004     	str	lr, [sp, #-0x4]!
;         CPS  #SVC_MODE
700ae25c: f1020013     	cps	#0x13
;         PUSH    {r0-r4, r12}
700ae260: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         LDR     r3, ulPortInterruptNestingConst
700ae264: e59f3118     	ldr	r3, [pc, #0x118]        @ 0x700ae384 <ulPortInterruptNestingConst>
;         LDR     r1, [r3]
700ae268: e5931000     	ldr	r1, [r3]
;         ADD     r4, r1, #1
700ae26c: e2814001     	add	r4, r1, #1
;         STR     r4, [r3]
700ae270: e5834000     	str	r4, [r3]
;         FMRX  R0, FPSCR
700ae274: eef10a10     	vmrs	r0, fpscr
;         VPUSH {D0-D15}
700ae278: ed2d0b20     	vpush	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         PUSH  {R0}
700ae27c: e52d0004     	str	r0, [sp, #-0x4]!
;         MOV     r2, sp
700ae280: e1a0200d     	mov	r2, sp
;         AND     r2, r2, #4
700ae284: e2022004     	and	r2, r2, #4
;         SUB     sp, sp, r2
700ae288: e04dd002     	sub	sp, sp, r2
;         PUSH    {r0-r4, lr}
700ae28c: e92d401f     	push	{r0, r1, r2, r3, r4, lr}
;         LDR     r1, vApplicationIRQHandlerConst
700ae290: e59f10f0     	ldr	r1, [pc, #0xf0]         @ 0x700ae388 <vApplicationIRQHandlerConst>
;         BLX     r1
700ae294: e12fff31     	blx	r1
;         POP     {r0-r4, lr}
700ae298: e8bd401f     	pop	{r0, r1, r2, r3, r4, lr}
;         ADD     sp, sp, r2
700ae29c: e08dd002     	add	sp, sp, r2
;         CPSID   i
700ae2a0: f10c0080     	cpsid	i
;         DSB
700ae2a4: f57ff04f     	dsb	sy
;         ISB
700ae2a8: f57ff06f     	isb	sy
;         POP   {R0}
700ae2ac: e49d0004     	ldr	r0, [sp], #4
;         VPOP  {D0-D15}
700ae2b0: ecbd0b20     	vpop	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         VMSR  FPSCR, R0
700ae2b4: eee10a10     	vmsr	fpscr, r0
;         STR     r1, [r3]
700ae2b8: e5831000     	str	r1, [r3]
;         CMP     r1, #0
700ae2bc: e3510000     	cmp	r1, #0
;         BNE     exit_without_switch
700ae2c0: 1a000003     	bne	0x700ae2d4 <exit_without_switch> @ imm = #0xc
;         LDR     r1, =ulPortYieldRequired
700ae2c4: e59f10c0     	ldr	r1, [pc, #0xc0]         @ 0x700ae38c <vApplicationIRQHandlerConst+0x4>
;         LDR     r0, [r1]
700ae2c8: e5910000     	ldr	r0, [r1]
;         CMP     r0, #0
700ae2cc: e3500000     	cmp	r0, #0
;         BNE     switch_before_exit
700ae2d0: 1a000005     	bne	0x700ae2ec <switch_before_exit> @ imm = #0x14

700ae2d4 <exit_without_switch>:
;         POP     {r0-r4, r12}
700ae2d4: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700ae2d8: f1020012     	cps	#0x12
;         POP     {LR}
700ae2dc: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700ae2e0: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700ae2e4: e49de004     	ldr	lr, [sp], #4
;         MOVS    PC, LR
700ae2e8: e1b0f00e     	movs	pc, lr

700ae2ec <switch_before_exit>:
;         MOV     r0, #0
700ae2ec: e3a00000     	mov	r0, #0
;         STR     r0, [r1]
700ae2f0: e5810000     	str	r0, [r1]
;         POP     {r0-r4, r12}
700ae2f4: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700ae2f8: f1020012     	cps	#0x12
;         POP     {LR}
700ae2fc: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700ae300: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700ae304: e49de004     	ldr	lr, [sp], #4
;         portSAVE_CONTEXT
700ae308: f96d051f     	srsdb	sp!, #0x1f
700ae30c: f102001f     	cps	#0x1f
700ae310: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700ae314: e59f2060     	ldr	r2, [pc, #0x60]         @ 0x700ae37c <ulPortTaskHasFPUContextConst>
700ae318: e5923000     	ldr	r3, [r2]
700ae31c: e3530000     	cmp	r3, #0
700ae320: 1ef11a10     	vmrsne	r1, fpscr
700ae324: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700ae328: 152d1004     	strne	r1, [sp, #-0x4]!
700ae32c: e52d3004     	str	r3, [sp, #-0x4]!
700ae330: e59f0040     	ldr	r0, [pc, #0x40]         @ 0x700ae378 <pxCurrentTCBConst>
700ae334: e5901000     	ldr	r1, [r0]
700ae338: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700ae33c: e59f003c     	ldr	r0, [pc, #0x3c]         @ 0x700ae380 <vTaskSwitchContextConst>
;         BLX     R0
700ae340: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700ae344: e59f002c     	ldr	r0, [pc, #0x2c]         @ 0x700ae378 <pxCurrentTCBConst>
700ae348: e5901000     	ldr	r1, [r0]
700ae34c: e591d000     	ldr	sp, [r1]
700ae350: e59f0024     	ldr	r0, [pc, #0x24]         @ 0x700ae37c <ulPortTaskHasFPUContextConst>
700ae354: e49d1004     	ldr	r1, [sp], #4
700ae358: e5801000     	str	r1, [r0]
700ae35c: e3510000     	cmp	r1, #0
700ae360: 149d0004     	ldrne	r0, [sp], #4
700ae364: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700ae368: 1ee10a10     	vmsrne	fpscr, r0
700ae36c: f57ff01f     	clrex
700ae370: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700ae374: f8bd0a00     	rfeia	sp!

700ae378 <pxCurrentTCBConst>:
700ae378: cc 01 0b 70  	.word	0x700b01cc

700ae37c <ulPortTaskHasFPUContextConst>:
700ae37c: e0 01 0b 70  	.word	0x700b01e0

700ae380 <vTaskSwitchContextConst>:
700ae380: 11 50 0a 70  	.word	0x700a5011

700ae384 <ulPortInterruptNestingConst>:
700ae384: d8 01 0b 70  	.word	0x700b01d8

700ae388 <vApplicationIRQHandlerConst>:
700ae388: 01 de 0a 70  	.word	0x700ade01
700ae38c: e4 01 0b 70  	.word	0x700b01e4

700ae390 <HwiP_disable>:
;         mrs     r0, cpsr
700ae390: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x80
700ae394: e380c080     	orr	r12, r0, #128
;         msr     cpsr_cf, r12
700ae398: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700ae39c: e12fff1e     	bx	lr

700ae3a0 <HwiP_disableFIQ>:
;         mrs     r0, cpsr
700ae3a0: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x40
700ae3a4: e380c040     	orr	r12, r0, #64
;         msr     cpsr_cf, r12
700ae3a8: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700ae3ac: e12fff1e     	bx	lr

700ae3b0 <HwiP_enable>:
;         mrs     r0, cpsr
700ae3b0: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x80
700ae3b4: e3c0c080     	bic	r12, r0, #128
;         msr     cpsr_cf, r12
700ae3b8: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700ae3bc: e12fff1e     	bx	lr

700ae3c0 <HwiP_enableFIQ>:
;         mrs     r0, cpsr
700ae3c0: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x40
700ae3c4: e3c0c040     	bic	r12, r0, #64
;         msr     cpsr_cf, r12
700ae3c8: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700ae3cc: e12fff1e     	bx	lr

700ae3d0 <HwiP_restore>:
;         msr     cpsr_cf, r0
700ae3d0: e129f000     	msr	CPSR_fc, r0
;         bx      LR
700ae3d4: e12fff1e     	bx	lr

700ae3d8 <HwiP_enableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700ae3d8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR     r0, r0, #(1<<24)         /* Set VE mask (VIC controller provides handler address for IRQ) */
700ae3dc: e3800401     	orr	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700ae3e0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700ae3e4: e12fff1e     	bx	lr

700ae3e8 <HwiP_disableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700ae3e8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC     r0, r0, #(1<<24)         /* Clear VE mask (VIC controller provides handler address for IRQ) */
700ae3ec: e3c00401     	bic	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700ae3f0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700ae3f4: e12fff1e     	bx	lr

700ae3f8 <HwiP_getCPSR>:
;         mrs     r0, cpsr
700ae3f8: e10f0000     	mrs	r0, apsr
;         bx      LR
700ae3fc: e12fff1e     	bx	lr

700ae400 <HwiP_data_abort_handler>:
;         PUSH	{r0-r4, r12}
700ae400: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         MRS r0, SPSR
700ae404: e14f0000     	mrs	r0, spsr
;         AND r1, r0, #0x20
700ae408: e2001020     	and	r1, r0, #32
;         CMP R1, #0
700ae40c: e3510000     	cmp	r1, #0
;         BEQ ARM_STATE
700ae410: 0a000000     	beq	0x700ae418 <ARM_STATE>  @ imm = #0x0
;         SUB lr, lr, #2
700ae414: e24ee002     	sub	lr, lr, #2

700ae418 <ARM_STATE>:
;         SUB lr, lr, #4
700ae418: e24ee004     	sub	lr, lr, #4

700ae41c <END>:
;         PUSH	{lr}
700ae41c: e52de004     	str	lr, [sp, #-0x4]!
;         MRS	lr, SPSR
700ae420: e14fe000     	mrs	lr, spsr
;         PUSH	{lr}
700ae424: e52de004     	str	lr, [sp, #-0x4]!
;         LDR	r1, HwiP_data_abort_handler_const
700ae428: e59f1014     	ldr	r1, [pc, #0x14]         @ 0x700ae444 <HwiP_data_abort_handler_const>
;         BLX	r1
700ae42c: e12fff31     	blx	r1
;         POP	{LR}
700ae430: e49de004     	ldr	lr, [sp], #4
;         MSR	SPSR_cxsf, LR
700ae434: e16ff00e     	msr	SPSR_fsxc, lr
;         POP	{LR}
700ae438: e49de004     	ldr	lr, [sp], #4
;         POP	{r0-r4, r12}
700ae43c: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         MOVS	PC, LR
700ae440: e1b0f00e     	movs	pc, lr

700ae444 <HwiP_data_abort_handler_const>:
700ae444: 71 e1 0a 70  	.word	0x700ae171
700ae448: 00 00 00 00  	.word	0x00000000
700ae44c: 00 00 00 00  	.word	0x00000000

Disassembly of section .text.cache:

700ae450 <CacheP_disableL1d>:
;         push    {r0-r7, r9-r11, lr}
700ae450: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700ae454: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x0004         // clear C bit
700ae458: e3c00004     	bic	r0, r0, #4
;         dsb
700ae45c: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0 // L1D cache disabled
700ae460: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700ae464: e30e067c     	movw	r0, #0xe67c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700ae468: e347000a     	movt	r0, #0x700a
;         blx     r0
700ae46c: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700ae470: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700ae474: e12fff1e     	bx	lr

700ae478 <CacheP_disableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700ae478: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1000         // clear I bit
700ae47c: e3c00a01     	bic	r0, r0, #4096
;         mcr     p15, #0, r0, c1, c0, #0 // L1P cache disabled
700ae480: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700ae484: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         isb
700ae488: f57ff06f     	isb	sy
;         bx      lr
700ae48c: e12fff1e     	bx	lr

700ae490 <CacheP_enableL1d>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCR register
700ae490: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x0004          // set C bit (bit 2) to 1
700ae494: e3800004     	orr	r0, r0, #4
;         dsb
700ae498: f57ff04f     	dsb	sy
;         mcr     p15, #0, r1, c15, c5, #0 // Invalidate entire data cache
700ae49c: ee0f1f15     	mcr	p15, #0x0, r1, c15, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0  // L1D cache enabled
700ae4a0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      lr
700ae4a4: e12fff1e     	bx	lr

700ae4a8 <CacheP_enableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700ae4a8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1000         // set I bit (bit 12) to 1
700ae4ac: e3800a01     	orr	r0, r0, #4096
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700ae4b0: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0 // ICache enabled
700ae4b4: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb
700ae4b8: f57ff06f     	isb	sy
;         bx      lr
700ae4bc: e12fff1e     	bx	lr

700ae4c0 <CacheP_invL1d>:
;         push    {r4}
700ae4c0: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700ae4c4: e0801001     	add	r1, r0, r1
;         ldr     r3, l1dCacheLineSizeInvL1dAddr
700ae4c8: e59f3024     	ldr	r3, [pc, #0x24]         @ 0x700ae4f4 <l1dCacheLineSizeInvL1dAddr>
;         ldr     r3, [r3]
700ae4cc: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700ae4d0: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700ae4d4: e1c00004     	bic	r0, r0, r4

700ae4d8 <invL1dCache_loop>:
;         mcr     p15, #0, r0, c7, c6, #1 // invalidate single entry in L1D cache
700ae4d8: ee070f36     	mcr	p15, #0x0, r0, c7, c6, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700ae4dc: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700ae4e0: e1500001     	cmp	r0, r1
;         blo     invL1dCache_loop        // loop if > 0
700ae4e4: 3afffffb     	blo	0x700ae4d8 <invL1dCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700ae4e8: f57ff04f     	dsb	sy
;         pop     {r4}
700ae4ec: e49d4004     	ldr	r4, [sp], #4
;         bx      lr                      // return
700ae4f0: e12fff1e     	bx	lr

700ae4f4 <l1dCacheLineSizeInvL1dAddr>:
700ae4f4: 44 f2 0a 70  	.word	0x700af244

700ae4f8 <CacheP_invL1p>:
;         push    {r4}
700ae4f8: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700ae4fc: e0801001     	add	r1, r0, r1
;         ldr     r3, l1pCacheLineSizeAddr
700ae500: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700ae530 <l1pCacheLineSizeAddr>
;         ldr     r3, [r3]
700ae504: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700ae508: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700ae50c: e1c00004     	bic	r0, r0, r4

700ae510 <invL1pCache_loop>:
;         mcr     p15, #0, r0, c7, c5, #1 // invalidate single entry in ICache
700ae510: ee070f35     	mcr	p15, #0x0, r0, c7, c5, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700ae514: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700ae518: e1500001     	cmp	r0, r1
;         blo     invL1pCache_loop        // loop if > 0
700ae51c: 3afffffb     	blo	0x700ae510 <invL1pCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700ae520: f57ff04f     	dsb	sy
;         isb                             // flush instruction pipeline
700ae524: f57ff06f     	isb	sy
;         pop     {r4}
700ae528: e49d4004     	ldr	r4, [sp], #4
;         bx      lr
700ae52c: e12fff1e     	bx	lr

700ae530 <l1pCacheLineSizeAddr>:
700ae530: 60 fe 0a 70  	.word	0x700afe60

700ae534 <CacheP_invL1dAll>:
;         mcr     p15, #0, r0, c15, c5, #0 // Invalidate entire data cache
700ae534: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         bx      lr                       // return
700ae538: e12fff1e     	bx	lr

700ae53c <CacheP_invL1pAll>:
;         mcr     p15, #0, r0, c7, c5, #0 // invalidate all entries in ICache
700ae53c: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         bx      lr                      // return
700ae540: e12fff1e     	bx	lr

700ae544 <CacheP_wb>:
;         push    {r4, r5}
700ae544: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700ae548: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700ae54c: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbAddr
700ae550: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700ae57c <l1dCacheLineSizeWbAddr>
;         ldr     r4, [r4]
700ae554: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700ae558: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align address to cache line
700ae55c: e1c00005     	bic	r0, r0, r5

700ae560 <writeback>:
;         mcr     p15, #0, r0, c7, c10, #1 // write back a cache line
700ae560: ee070f3a     	mcr	p15, #0x0, r0, c7, c10, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700ae564: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700ae568: e1500001     	cmp	r0, r1
;         blo     writeback                // loop if count > 0
700ae56c: 3afffffb     	blo	0x700ae560 <writeback>  @ imm = #-0x14
;         dsb                              // drain write buffer
700ae570: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700ae574: e8bd0030     	pop	{r4, r5}
;         bx      lr
700ae578: e12fff1e     	bx	lr

700ae57c <l1dCacheLineSizeWbAddr>:
700ae57c: 44 f2 0a 70  	.word	0x700af244

700ae580 <CacheP_wbInv>:
;         push    {r4, r5}
700ae580: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700ae584: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700ae588: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbInvAddr
700ae58c: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700ae5b8 <l1dCacheLineSizeWbInvAddr>
;         ldr     r4, [r4]
700ae590: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700ae594: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align blockPtr to cache line
700ae598: e1c00005     	bic	r0, r0, r5

700ae59c <writebackInv>:
;         mcr     p15, #0, r0, c7, c14, #1 // writeback inv a cache line
700ae59c: ee070f3e     	mcr	p15, #0x0, r0, c7, c14, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700ae5a0: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700ae5a4: e1500001     	cmp	r0, r1
;         blo     writebackInv             // loop if count > 0
700ae5a8: 3afffffb     	blo	0x700ae59c <writebackInv> @ imm = #-0x14
;         dsb                              // drain write buffer
700ae5ac: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700ae5b0: e8bd0030     	pop	{r4, r5}
;         bx      lr
700ae5b4: e12fff1e     	bx	lr

700ae5b8 <l1dCacheLineSizeWbInvAddr>:
700ae5b8: 44 f2 0a 70  	.word	0x700af244

700ae5bc <CacheP_wbAll>:
;         stmfd   sp!, {r0-r7, r9-r11, lr}
700ae5bc: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         dmb                             // Ensure all previous memory accesses
700ae5c0: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700ae5c4: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700ae5c8: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700ae5cc: e1a03ba3     	lsr	r3, r3, #23
;         beq     wbafinished             // if loc is 0, then no need to clean
700ae5d0: 0a00001d     	beq	0x700ae64c <wbafinished> @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700ae5d4: e3a0a000     	mov	r10, #0

700ae5d8 <wbaloop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700ae5d8: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700ae5dc: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700ae5e0: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700ae5e4: e3510002     	cmp	r1, #2
;         blt     wbaskip                 // skip if no cache, or just i-cache
700ae5e8: ba000014     	blt	0x700ae640 <wbaskip>    @ imm = #0x50
;         mrs     r6, cpsr
700ae5ec: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700ae5f0: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700ae5f4: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700ae5f8: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700ae5fc: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700ae600: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700ae604: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700ae608: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700ae60c: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700ae610: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700ae614: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700ae618: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700ae61c: e01776a1     	ands	r7, r7, r1, lsr #13

700ae620 <wbaloop2>:
;         mov     r9, r4                  // create working copy of max way size
700ae620: e1a09004     	mov	r9, r4

700ae624 <wbaloop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700ae624: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700ae628: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c10, #2 // clean line by set/way
700ae62c: ee07bf5a     	mcr	p15, #0x0, r11, c7, c10, #0x2
;         subs    r9, r9, #1              // decrement the way
700ae630: e2599001     	subs	r9, r9, #1
;         bge     wbaloop3
700ae634: aafffffa     	bge	0x700ae624 <wbaloop3>   @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700ae638: e2577001     	subs	r7, r7, #1
;         bge     wbaloop2
700ae63c: aafffff7     	bge	0x700ae620 <wbaloop2>   @ imm = #-0x24

700ae640 <wbaskip>:
;         add     r10, r10, #2            // increment cache number
700ae640: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700ae644: e153000a     	cmp	r3, r10
;         bgt     wbaloop1
700ae648: caffffe2     	bgt	0x700ae5d8 <wbaloop1>   @ imm = #-0x78

700ae64c <wbafinished>:
;         mov     r10, #0                 // switch back to cache level 0
700ae64c: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700ae650: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700ae654: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700ae658: f57ff06f     	isb	sy
;         ldmfd   sp!, {r0-r7, r9-r11, lr}
700ae65c: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700ae660: e12fff1e     	bx	lr

700ae664 <CacheP_wbInvAll>:
;         push    {r0-r7, r9-r11, lr}
700ae664: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700ae668: e30e067c     	movw	r0, #0xe67c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700ae66c: e347000a     	movt	r0, #0x700a
;         blx     r0
700ae670: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700ae674: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700ae678: e12fff1e     	bx	lr

700ae67c <CacheP_wbInvAllAsm>:
;         dmb                             // Ensure all previous memory accesses
700ae67c: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700ae680: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700ae684: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700ae688: e1a03ba3     	lsr	r3, r3, #23
;         beq     finished                // if loc is 0, then no need to clean
700ae68c: 0a00001d     	beq	0x700ae708 <finished>   @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700ae690: e3a0a000     	mov	r10, #0

700ae694 <loop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700ae694: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700ae698: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700ae69c: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700ae6a0: e3510002     	cmp	r1, #2
;         blt     skip                    // skip if no cache, or just i-cache
700ae6a4: ba000014     	blt	0x700ae6fc <skip>       @ imm = #0x50
;         mrs     r6, cpsr
700ae6a8: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700ae6ac: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700ae6b0: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700ae6b4: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700ae6b8: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700ae6bc: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700ae6c0: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700ae6c4: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700ae6c8: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700ae6cc: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700ae6d0: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700ae6d4: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700ae6d8: e01776a1     	ands	r7, r7, r1, lsr #13

700ae6dc <loop2>:
;         mov     r9, r4                  // create working copy of max way size
700ae6dc: e1a09004     	mov	r9, r4

700ae6e0 <loop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700ae6e0: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700ae6e4: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c14, #2 // clean & invalidate by set/way
700ae6e8: ee07bf5e     	mcr	p15, #0x0, r11, c7, c14, #0x2
;         subs    r9, r9, #1              // decrement the way
700ae6ec: e2599001     	subs	r9, r9, #1
;         bge     loop3
700ae6f0: aafffffa     	bge	0x700ae6e0 <loop3>      @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700ae6f4: e2577001     	subs	r7, r7, #1
;         bge     loop2
700ae6f8: aafffff7     	bge	0x700ae6dc <loop2>      @ imm = #-0x24

700ae6fc <skip>:
;         add     r10, r10, #2            // increment cache number
700ae6fc: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700ae700: e153000a     	cmp	r3, r10
;         bgt     loop1
700ae704: caffffe2     	bgt	0x700ae694 <loop1>      @ imm = #-0x78

700ae708 <finished>:
;         mov     r10, #0                 // swith back to cache level 0
700ae708: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700ae70c: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700ae710: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700ae714: f57ff06f     	isb	sy
;         bx      lr
700ae718: e12fff1e     	bx	lr

700ae71c <CacheP_getEnabled>:
;         mov     r0, #0
700ae71c: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0 // fetch Control Register into r1
700ae720: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1000             // test I bit (bit 12) for L1P
700ae724: e3110a01     	tst	r1, #4096
;         addne   r0, r0, #1              // if I is true, L1P is enabled
700ae728: 12800001     	addne	r0, r0, #1
;         tst     r1, #0x0004             // test C bit (bit 2) for L1D
700ae72c: e3110004     	tst	r1, #4
;         addne   r0, r0, #2              // if C bit is true, L1D is enabled
700ae730: 12800002     	addne	r0, r0, #2
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700ae734: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         tst     r1, #0x0002             // test L2EN bit (bit 1) for L2EN
700ae738: e3110002     	tst	r1, #2
;         beq     getEnabledDone
700ae73c: 0a000003     	beq	0x700ae750 <getEnabledDone> @ imm = #0xc
;         tst     r0, #0x0001
700ae740: e3100001     	tst	r0, #1
;         addne   r0, r0, #4              // If L2EN and L1P then L2P
700ae744: 12800004     	addne	r0, r0, #4
;         tst     r0, #0x0002
700ae748: e3100002     	tst	r0, #2
;         addne   r0, r0, #8              // If L2EN and L1D then L2D
700ae74c: 12800008     	addne	r0, r0, #8

700ae750 <getEnabledDone>:
;         bx      lr
700ae750: e12fff1e     	bx	lr

700ae754 <CacheP_getCacheLevelInfo>:
;         mcr     p15, #2, r0, c0, c0, #0 // write to Cache Size Selection Reg
700ae754: ee400f10     	mcr	p15, #0x2, r0, c0, c0, #0x0
;         mrc     p15, #1, r0, c0, c0, #0 // read Cache Size Id Reg
700ae758: ee300f10     	mrc	p15, #0x1, r0, c0, c0, #0x0
;         bx      lr
700ae75c: e12fff1e     	bx	lr

700ae760 <CacheP_configForceWrThru>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700ae760: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         cmp     r0, #0
700ae764: e3500000     	cmp	r0, #0
;         beq     FWT_disable
700ae768: 0a000001     	beq	0x700ae774 <FWT_disable> @ imm = #0x4
;         orr     r1, r1, #(1 << 9)       // set (enable) force write-thru bit
700ae76c: e3811c02     	orr	r1, r1, #512
;         b       FWT_exit
700ae770: ea000000     	b	0x700ae778 <FWT_exit>   @ imm = #0x0

700ae774 <FWT_disable>:
;         bic     r1, r1, #(1 << 9)       // clear (disable) force write-thru bit
700ae774: e3c11c02     	bic	r1, r1, #512

700ae778 <FWT_exit>:
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700ae778: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700ae77c: e12fff1e     	bx	lr

700ae780 <CacheP_setDLFO>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700ae780: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         orr     r1, r1, #(1 << 13)      // set DLFO to disable LF optimization
700ae784: e3811a02     	orr	r1, r1, #8192
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700ae788: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700ae78c: e12fff1e     	bx	lr

700ae790 <CacheP_init>:
; {
700ae790: b580         	push	{r7, lr}
700ae792: b084         	sub	sp, #0x10
700ae794: 2000         	movs	r0, #0x0
;     info = CacheP_getCacheLevelInfo(0);
700ae796: f7ff efde    	blx	0x700ae754 <CacheP_getCacheLevelInfo> @ imm = #-0x44
700ae79a: 9003         	str	r0, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1dCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700ae79c: 9803         	ldr	r0, [sp, #0xc]
700ae79e: f000 0007    	and	r0, r0, #0x7
700ae7a2: 1c81         	adds	r1, r0, #0x2
700ae7a4: 2004         	movs	r0, #0x4
700ae7a6: 9001         	str	r0, [sp, #0x4]
700ae7a8: 4088         	lsls	r0, r1
700ae7aa: 3820         	subs	r0, #0x20
700ae7ac: fab0 f080    	clz	r0, r0
700ae7b0: 0940         	lsrs	r0, r0, #0x5
700ae7b2: f000 faad    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x55a
700ae7b6: 2001         	movs	r0, #0x1
;     info = CacheP_getCacheLevelInfo(1);
700ae7b8: f7ff efcc    	blx	0x700ae754 <CacheP_getCacheLevelInfo> @ imm = #-0x68
700ae7bc: 4601         	mov	r1, r0
700ae7be: 9801         	ldr	r0, [sp, #0x4]
700ae7c0: 9103         	str	r1, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1pCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700ae7c2: 9903         	ldr	r1, [sp, #0xc]
700ae7c4: f001 0107    	and	r1, r1, #0x7
700ae7c8: 3102         	adds	r1, #0x2
700ae7ca: 4088         	lsls	r0, r1
700ae7cc: 3820         	subs	r0, #0x20
700ae7ce: fab0 f080    	clz	r0, r0
700ae7d2: 0940         	lsrs	r0, r0, #0x5
700ae7d4: f000 fa9c    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x538
;     enabled = CacheP_getEnabled();
700ae7d8: f7ff efa0    	blx	0x700ae71c <CacheP_getEnabled> @ imm = #-0xc0
700ae7dc: 9002         	str	r0, [sp, #0x8]
;     if (enabled!=0U) {
700ae7de: 9802         	ldr	r0, [sp, #0x8]
700ae7e0: b120         	cbz	r0, 0x700ae7ec <CacheP_init+0x5c> @ imm = #0x8
700ae7e2: e7ff         	b	0x700ae7e4 <CacheP_init+0x54> @ imm = #-0x2
700ae7e4: 200f         	movs	r0, #0xf
;         CacheP_disable((uint32_t)CacheP_TYPE_ALL);
700ae7e6: f000 f81b    	bl	0x700ae820 <CacheP_disable> @ imm = #0x36
;     }
700ae7ea: e7ff         	b	0x700ae7ec <CacheP_init+0x5c> @ imm = #-0x2
;     if (gCacheConfig.enable!=0U) {
700ae7ec: f24f 102c    	movw	r0, #0xf12c
700ae7f0: f2c7 000a    	movt	r0, #0x700a
700ae7f4: 6800         	ldr	r0, [r0]
700ae7f6: b158         	cbz	r0, 0x700ae810 <CacheP_init+0x80> @ imm = #0x16
700ae7f8: e7ff         	b	0x700ae7fa <CacheP_init+0x6a> @ imm = #-0x2
;          CacheP_configForceWrThru(gCacheConfig.enableForceWrThru);
700ae7fa: f24f 102c    	movw	r0, #0xf12c
700ae7fe: f2c7 000a    	movt	r0, #0x700a
700ae802: 6840         	ldr	r0, [r0, #0x4]
700ae804: f7ff efac    	blx	0x700ae760 <CacheP_configForceWrThru> @ imm = #-0xa8
700ae808: 200f         	movs	r0, #0xf
;         CacheP_enable((uint32_t)CacheP_TYPE_ALL);
700ae80a: f000 f831    	bl	0x700ae870 <CacheP_enable> @ imm = #0x62
;     }
700ae80e: e7ff         	b	0x700ae810 <CacheP_init+0x80> @ imm = #-0x2
; }
700ae810: b004         	add	sp, #0x10
700ae812: bd80         	pop	{r7, pc}
700ae814: bf00         	nop
700ae816: bf00         	nop
700ae818: bf00         	nop
700ae81a: bf00         	nop
700ae81c: bf00         	nop
700ae81e: bf00         	nop

700ae820 <CacheP_disable>:
; {
700ae820: b580         	push	{r7, lr}
700ae822: b084         	sub	sp, #0x10
700ae824: 9003         	str	r0, [sp, #0xc]
;     enabled = CacheP_getEnabled();
700ae826: f7ff ef7a    	blx	0x700ae71c <CacheP_getEnabled> @ imm = #-0x10c
700ae82a: 9002         	str	r0, [sp, #0x8]
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700ae82c: 9902         	ldr	r1, [sp, #0x8]
700ae82e: 9803         	ldr	r0, [sp, #0xc]
700ae830: 4008         	ands	r0, r1
700ae832: 0780         	lsls	r0, r0, #0x1e
700ae834: 2800         	cmp	r0, #0x0
700ae836: d509         	bpl	0x700ae84c <CacheP_disable+0x2c> @ imm = #0x12
700ae838: e7ff         	b	0x700ae83a <CacheP_disable+0x1a> @ imm = #-0x2
;         key = HwiP_disable();
700ae83a: f7ff edaa    	blx	0x700ae390 <HwiP_disable> @ imm = #-0x4ac
700ae83e: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1d();             /* Disable L1D Cache */
700ae840: f7ff ee06    	blx	0x700ae450 <CacheP_disableL1d> @ imm = #-0x3f4
;         HwiP_restore(key);
700ae844: 9801         	ldr	r0, [sp, #0x4]
700ae846: f7ff edc4    	blx	0x700ae3d0 <HwiP_restore> @ imm = #-0x478
;     }
700ae84a: e7ff         	b	0x700ae84c <CacheP_disable+0x2c> @ imm = #-0x2
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700ae84c: 9902         	ldr	r1, [sp, #0x8]
700ae84e: 9803         	ldr	r0, [sp, #0xc]
700ae850: 4008         	ands	r0, r1
700ae852: 07c0         	lsls	r0, r0, #0x1f
700ae854: b148         	cbz	r0, 0x700ae86a <CacheP_disable+0x4a> @ imm = #0x12
700ae856: e7ff         	b	0x700ae858 <CacheP_disable+0x38> @ imm = #-0x2
;         key = HwiP_disable();
700ae858: f7ff ed9a    	blx	0x700ae390 <HwiP_disable> @ imm = #-0x4cc
700ae85c: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1p();             /* Disable L1P Cache */
700ae85e: f7ff ee0c    	blx	0x700ae478 <CacheP_disableL1p> @ imm = #-0x3e8
;         HwiP_restore(key);
700ae862: 9801         	ldr	r0, [sp, #0x4]
700ae864: f7ff edb4    	blx	0x700ae3d0 <HwiP_restore> @ imm = #-0x498
;     }
700ae868: e7ff         	b	0x700ae86a <CacheP_disable+0x4a> @ imm = #-0x2
; }
700ae86a: b004         	add	sp, #0x10
700ae86c: bd80         	pop	{r7, pc}
700ae86e: bf00         	nop

700ae870 <CacheP_enable>:
; {
700ae870: b580         	push	{r7, lr}
700ae872: b082         	sub	sp, #0x8
700ae874: 9001         	str	r0, [sp, #0x4]
;     disabled = ~(CacheP_getEnabled());
700ae876: f7ff ef52    	blx	0x700ae71c <CacheP_getEnabled> @ imm = #-0x15c
700ae87a: 43c0         	mvns	r0, r0
700ae87c: 9000         	str	r0, [sp]
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700ae87e: 9900         	ldr	r1, [sp]
700ae880: 9801         	ldr	r0, [sp, #0x4]
700ae882: 4008         	ands	r0, r1
700ae884: 0780         	lsls	r0, r0, #0x1e
700ae886: 2800         	cmp	r0, #0x0
700ae888: d503         	bpl	0x700ae892 <CacheP_enable+0x22> @ imm = #0x6
700ae88a: e7ff         	b	0x700ae88c <CacheP_enable+0x1c> @ imm = #-0x2
;         CacheP_enableL1d();              /* Enable L1D Cache */
700ae88c: f7ff ee00    	blx	0x700ae490 <CacheP_enableL1d> @ imm = #-0x400
;     }
700ae890: e7ff         	b	0x700ae892 <CacheP_enable+0x22> @ imm = #-0x2
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700ae892: 9900         	ldr	r1, [sp]
700ae894: 9801         	ldr	r0, [sp, #0x4]
700ae896: 4008         	ands	r0, r1
700ae898: 07c0         	lsls	r0, r0, #0x1f
700ae89a: b118         	cbz	r0, 0x700ae8a4 <CacheP_enable+0x34> @ imm = #0x6
700ae89c: e7ff         	b	0x700ae89e <CacheP_enable+0x2e> @ imm = #-0x2
;         CacheP_enableL1p();              /* Enable L1P Cache */
700ae89e: f7ff ee04    	blx	0x700ae4a8 <CacheP_enableL1p> @ imm = #-0x3f8
;     }
700ae8a2: e7ff         	b	0x700ae8a4 <CacheP_enable+0x34> @ imm = #-0x2
; }
700ae8a4: b002         	add	sp, #0x8
700ae8a6: bd80         	pop	{r7, pc}
700ae8a8: bf00         	nop
700ae8aa: bf00         	nop
700ae8ac: bf00         	nop
700ae8ae: bf00         	nop

700ae8b0 <CacheP_inv>:
; {
700ae8b0: b580         	push	{r7, lr}
700ae8b2: b084         	sub	sp, #0x10
700ae8b4: 9003         	str	r0, [sp, #0xc]
700ae8b6: 9102         	str	r1, [sp, #0x8]
700ae8b8: 9201         	str	r2, [sp, #0x4]
;     if (((type) & ((uint32_t)CacheP_TYPE_L1P))!=0U) {
700ae8ba: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700ae8be: 07c0         	lsls	r0, r0, #0x1f
700ae8c0: b128         	cbz	r0, 0x700ae8ce <CacheP_inv+0x1e> @ imm = #0xa
700ae8c2: e7ff         	b	0x700ae8c4 <CacheP_inv+0x14> @ imm = #-0x2
;         CacheP_invL1p((uint32_t)blockPtr, byteCnt);
700ae8c4: 9803         	ldr	r0, [sp, #0xc]
700ae8c6: 9902         	ldr	r1, [sp, #0x8]
700ae8c8: f7ff ee16    	blx	0x700ae4f8 <CacheP_invL1p> @ imm = #-0x3d4
;     }
700ae8cc: e7ff         	b	0x700ae8ce <CacheP_inv+0x1e> @ imm = #-0x2
;     if (((type) & ((uint32_t)CacheP_TYPE_L1D))!=0U) {
700ae8ce: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700ae8d2: 0780         	lsls	r0, r0, #0x1e
700ae8d4: 2800         	cmp	r0, #0x0
700ae8d6: d505         	bpl	0x700ae8e4 <CacheP_inv+0x34> @ imm = #0xa
700ae8d8: e7ff         	b	0x700ae8da <CacheP_inv+0x2a> @ imm = #-0x2
;         CacheP_invL1d((uint32_t)blockPtr, byteCnt);
700ae8da: 9803         	ldr	r0, [sp, #0xc]
700ae8dc: 9902         	ldr	r1, [sp, #0x8]
700ae8de: f7ff edf0    	blx	0x700ae4c0 <CacheP_invL1d> @ imm = #-0x420
;     }
700ae8e2: e7ff         	b	0x700ae8e4 <CacheP_inv+0x34> @ imm = #-0x2
; }
700ae8e4: b004         	add	sp, #0x10
700ae8e6: bd80         	pop	{r7, pc}
		...

Disassembly of section .text.mpu:

700ae8f0 <MpuP_RegionAttrs_init>:
; {
700ae8f0: b081         	sub	sp, #0x4
700ae8f2: 9000         	str	r0, [sp]
;     region->isExecuteNever = 0;
700ae8f4: 9900         	ldr	r1, [sp]
700ae8f6: 2000         	movs	r0, #0x0
700ae8f8: 7108         	strb	r0, [r1, #0x4]
;     region->accessPerm     = (uint8_t)MpuP_AP_S_RW_U_R;
700ae8fa: 9a00         	ldr	r2, [sp]
700ae8fc: 2102         	movs	r1, #0x2
700ae8fe: 7191         	strb	r1, [r2, #0x6]
;     region->tex            = 0;
700ae900: 9900         	ldr	r1, [sp]
700ae902: 7148         	strb	r0, [r1, #0x5]
;     region->isSharable     = 1;
700ae904: 9a00         	ldr	r2, [sp]
700ae906: 2101         	movs	r1, #0x1
700ae908: 70d1         	strb	r1, [r2, #0x3]
;     region->isCacheable    = 0;
700ae90a: 9900         	ldr	r1, [sp]
700ae90c: 7048         	strb	r0, [r1, #0x1]
;     region->isBufferable   = 0;
700ae90e: 9900         	ldr	r1, [sp]
700ae910: 7088         	strb	r0, [r1, #0x2]
;     region->isEnable       = 0;
700ae912: 9900         	ldr	r1, [sp]
700ae914: 7008         	strb	r0, [r1]
;     region->subregionDisableMask = 0;
700ae916: 9900         	ldr	r1, [sp]
700ae918: 71c8         	strb	r0, [r1, #0x7]
; }
700ae91a: b001         	add	sp, #0x4
700ae91c: 4770         	bx	lr
700ae91e: bf00         	nop

700ae920 <MpuP_setRegion>:
; {
700ae920: b580         	push	{r7, lr}
700ae922: b08a         	sub	sp, #0x28
700ae924: 9009         	str	r0, [sp, #0x24]
700ae926: 9108         	str	r1, [sp, #0x20]
700ae928: 9207         	str	r2, [sp, #0x1c]
700ae92a: 9306         	str	r3, [sp, #0x18]
;     uint32_t value = size;
700ae92c: 9807         	ldr	r0, [sp, #0x1c]
700ae92e: 9000         	str	r0, [sp]
;     DebugP_assertNoLog( regionNum < MpuP_MAX_REGIONS);
700ae930: 9909         	ldr	r1, [sp, #0x24]
700ae932: 2000         	movs	r0, #0x0
700ae934: 2910         	cmp	r1, #0x10
700ae936: bf38         	it	lo
700ae938: 2001         	movlo	r0, #0x1
700ae93a: f000 f9e9    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x3d2
;     value = (value & (uint32_t)0x1F);
700ae93e: 9800         	ldr	r0, [sp]
700ae940: f000 001f    	and	r0, r0, #0x1f
700ae944: 9000         	str	r0, [sp]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700ae946: 9806         	ldr	r0, [sp, #0x18]
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700ae948: 7801         	ldrb	r1, [r0]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700ae94a: 79c0         	ldrb	r0, [r0, #0x7]
700ae94c: 0200         	lsls	r0, r0, #0x8
;                   | ((uint32_t)(value            & (uint32_t)0x1F) << (uint32_t)1)
700ae94e: 9a00         	ldr	r2, [sp]
700ae950: f002 021f    	and	r2, r2, #0x1f
700ae954: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700ae958: f001 0101    	and	r1, r1, #0x1
700ae95c: 4408         	add	r0, r1
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700ae95e: 9004         	str	r0, [sp, #0x10]
;     baseAddress = ((uint32_t)addr & ~( (1U <<((uint64_t)value+1U))-1U ));
700ae960: 9808         	ldr	r0, [sp, #0x20]
700ae962: 9900         	ldr	r1, [sp]
700ae964: 1c4a         	adds	r2, r1, #0x1
700ae966: 2101         	movs	r1, #0x1
700ae968: 4091         	lsls	r1, r2
700ae96a: 4249         	rsbs	r1, r1, #0
700ae96c: 4008         	ands	r0, r1
700ae96e: 9005         	str	r0, [sp, #0x14]
;     regionAttrs = MpuP_getAttrs(attrs);
700ae970: 9806         	ldr	r0, [sp, #0x18]
700ae972: f000 f81d    	bl	0x700ae9b0 <MpuP_getAttrs> @ imm = #0x3a
700ae976: 9003         	str	r0, [sp, #0xc]
;     enabled = MpuP_isEnable();
700ae978: f000 f84a    	bl	0x700aea10 <MpuP_isEnable> @ imm = #0x94
700ae97c: 9002         	str	r0, [sp, #0x8]
;     MpuP_disable();
700ae97e: f000 f84f    	bl	0x700aea20 <MpuP_disable> @ imm = #0x9e
;     key = HwiP_disable();
700ae982: f7ff ed06    	blx	0x700ae390 <HwiP_disable> @ imm = #-0x5f4
700ae986: 9001         	str	r0, [sp, #0x4]
;     MpuP_setRegionAsm(regionNum, baseAddress, sizeAndEnable, regionAttrs);
700ae988: 9809         	ldr	r0, [sp, #0x24]
700ae98a: 9905         	ldr	r1, [sp, #0x14]
700ae98c: 9a04         	ldr	r2, [sp, #0x10]
700ae98e: 9b03         	ldr	r3, [sp, #0xc]
700ae990: f000 e90c    	blx	0x700aebac <MpuP_setRegionAsm> @ imm = #0x218
;     HwiP_restore(key);
700ae994: 9801         	ldr	r0, [sp, #0x4]
700ae996: f7ff ed1c    	blx	0x700ae3d0 <HwiP_restore> @ imm = #-0x5c8
;     if (enabled != 0U) {
700ae99a: 9802         	ldr	r0, [sp, #0x8]
700ae99c: b118         	cbz	r0, 0x700ae9a6 <MpuP_setRegion+0x86> @ imm = #0x6
700ae99e: e7ff         	b	0x700ae9a0 <MpuP_setRegion+0x80> @ imm = #-0x2
;         MpuP_enable();
700ae9a0: f000 f85e    	bl	0x700aea60 <MpuP_enable> @ imm = #0xbc
;     }
700ae9a4: e7ff         	b	0x700ae9a6 <MpuP_setRegion+0x86> @ imm = #-0x2
; }
700ae9a6: b00a         	add	sp, #0x28
700ae9a8: bd80         	pop	{r7, pc}
700ae9aa: bf00         	nop
700ae9ac: bf00         	nop
700ae9ae: bf00         	nop

700ae9b0 <MpuP_getAttrs>:
; {
700ae9b0: b580         	push	{r7, lr}
700ae9b2: b082         	sub	sp, #0x8
700ae9b4: 9001         	str	r0, [sp, #0x4]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700ae9b6: f8dd c004    	ldr.w	r12, [sp, #0x4]
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700ae9ba: f89c 2001    	ldrb.w	r2, [r12, #0x1]
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700ae9be: f89c 1002    	ldrb.w	r1, [r12, #0x2]
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700ae9c2: f89c 3003    	ldrb.w	r3, [r12, #0x3]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700ae9c6: f89c 0004    	ldrb.w	r0, [r12, #0x4]
700ae9ca: f000 0001    	and	r0, r0, #0x1
700ae9ce: 0300         	lsls	r0, r0, #0xc
;         | ((uint32_t)(region->accessPerm     & (uint32_t)0x7) << (uint32_t)8)
700ae9d0: f89c e006    	ldrb.w	lr, [r12, #0x6]
700ae9d4: f00e 0e07    	and	lr, lr, #0x7
700ae9d8: ea40 200e    	orr.w	r0, r0, lr, lsl #8
;         | ((uint32_t)(region->tex            & (uint32_t)0x7) << (uint32_t)3)
700ae9dc: f89c c005    	ldrb.w	r12, [r12, #0x5]
700ae9e0: f00c 0c07    	and	r12, r12, #0x7
700ae9e4: ea40 00cc    	orr.w	r0, r0, r12, lsl #3
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700ae9e8: f003 0301    	and	r3, r3, #0x1
700ae9ec: ea40 0083    	orr.w	r0, r0, r3, lsl #2
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700ae9f0: f002 0201    	and	r2, r2, #0x1
700ae9f4: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700ae9f8: f001 0101    	and	r1, r1, #0x1
700ae9fc: 4408         	add	r0, r1
;     uint32_t regionAttrs =
700ae9fe: 9000         	str	r0, [sp]
;     return regionAttrs;
700aea00: 9800         	ldr	r0, [sp]
700aea02: b002         	add	sp, #0x8
700aea04: bd80         	pop	{r7, pc}
700aea06: bf00         	nop
700aea08: bf00         	nop
700aea0a: bf00         	nop
700aea0c: bf00         	nop
700aea0e: bf00         	nop

700aea10 <MpuP_isEnable>:
; {
700aea10: b580         	push	{r7, lr}
;     return MpuP_isEnableAsm();
700aea12: f000 e8c2    	blx	0x700aeb98 <MpuP_isEnableAsm> @ imm = #0x184
700aea16: bd80         	pop	{r7, pc}
700aea18: bf00         	nop
700aea1a: bf00         	nop
700aea1c: bf00         	nop
700aea1e: bf00         	nop

700aea20 <MpuP_disable>:
; {
700aea20: b580         	push	{r7, lr}
700aea22: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()!=0U)
700aea24: f7ff fff4    	bl	0x700aea10 <MpuP_isEnable> @ imm = #-0x18
700aea28: b1a0         	cbz	r0, 0x700aea54 <MpuP_disable+0x34> @ imm = #0x28
700aea2a: e7ff         	b	0x700aea2c <MpuP_disable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700aea2c: f7ff ecb0    	blx	0x700ae390 <HwiP_disable> @ imm = #-0x6a0
700aea30: 9000         	str	r0, [sp]
;         type = CacheP_getEnabled();
700aea32: f7ff ee74    	blx	0x700ae71c <CacheP_getEnabled> @ imm = #-0x318
700aea36: 9001         	str	r0, [sp, #0x4]
;         CacheP_disable(type);
700aea38: 9801         	ldr	r0, [sp, #0x4]
700aea3a: f7ff fef1    	bl	0x700ae820 <CacheP_disable> @ imm = #-0x21e
;         __asm__ __volatile__ (" dsb" "\n\t": : : "memory");
700aea3e: f3bf 8f4f    	dsb	sy
;         MpuP_disableAsm();
700aea42: f000 e882    	blx	0x700aeb48 <MpuP_disableAsm> @ imm = #0x104
;         CacheP_enable(type);
700aea46: 9801         	ldr	r0, [sp, #0x4]
700aea48: f7ff ff12    	bl	0x700ae870 <CacheP_enable> @ imm = #-0x1dc
;         HwiP_restore(key);
700aea4c: 9800         	ldr	r0, [sp]
700aea4e: f7ff ecc0    	blx	0x700ae3d0 <HwiP_restore> @ imm = #-0x680
;     }
700aea52: e7ff         	b	0x700aea54 <MpuP_disable+0x34> @ imm = #-0x2
; }
700aea54: b002         	add	sp, #0x8
700aea56: bd80         	pop	{r7, pc}
700aea58: bf00         	nop
700aea5a: bf00         	nop
700aea5c: bf00         	nop
700aea5e: bf00         	nop

700aea60 <MpuP_enable>:
; {
700aea60: b580         	push	{r7, lr}
700aea62: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()==(uint32_t) 0U)
700aea64: f7ff ffd4    	bl	0x700aea10 <MpuP_isEnable> @ imm = #-0x58
700aea68: b9e0         	cbnz	r0, 0x700aeaa4 <MpuP_enable+0x44> @ imm = #0x38
700aea6a: e7ff         	b	0x700aea6c <MpuP_enable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700aea6c: f7ff ec90    	blx	0x700ae390 <HwiP_disable> @ imm = #-0x6e0
700aea70: 9000         	str	r0, [sp]
;         type = (uint32_t)CacheP_getEnabled();
700aea72: f7ff ee54    	blx	0x700ae71c <CacheP_getEnabled> @ imm = #-0x358
700aea76: 9001         	str	r0, [sp, #0x4]
;         if (type & CacheP_TYPE_L1) {
700aea78: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700aea7c: 0780         	lsls	r0, r0, #0x1e
700aea7e: b120         	cbz	r0, 0x700aea8a <MpuP_enable+0x2a> @ imm = #0x8
700aea80: e7ff         	b	0x700aea82 <MpuP_enable+0x22> @ imm = #-0x2
700aea82: 2003         	movs	r0, #0x3
;             CacheP_disable(CacheP_TYPE_L1);
700aea84: f7ff fecc    	bl	0x700ae820 <CacheP_disable> @ imm = #-0x268
;         }
700aea88: e7ff         	b	0x700aea8a <MpuP_enable+0x2a> @ imm = #-0x2
;         MpuP_enableAsm();
700aea8a: f000 e872    	blx	0x700aeb70 <MpuP_enableAsm> @ imm = #0xe4
;         CacheP_enable(type);
700aea8e: 9801         	ldr	r0, [sp, #0x4]
700aea90: f7ff feee    	bl	0x700ae870 <CacheP_enable> @ imm = #-0x224
;         __asm__  __volatile__ (" dsb" "\n\t": : : "memory");
700aea94: f3bf 8f4f    	dsb	sy
;         __asm__  __volatile__ (" isb" "\n\t": : : "memory");
700aea98: f3bf 8f6f    	isb	sy
;         HwiP_restore(key);
700aea9c: 9800         	ldr	r0, [sp]
700aea9e: f7ff ec98    	blx	0x700ae3d0 <HwiP_restore> @ imm = #-0x6d0
;     }
700aeaa2: e7ff         	b	0x700aeaa4 <MpuP_enable+0x44> @ imm = #-0x2
; }
700aeaa4: b002         	add	sp, #0x8
700aeaa6: bd80         	pop	{r7, pc}
700aeaa8: bf00         	nop
700aeaaa: bf00         	nop
700aeaac: bf00         	nop
700aeaae: bf00         	nop

700aeab0 <MpuP_init>:
; {
700aeab0: b580         	push	{r7, lr}
700aeab2: b082         	sub	sp, #0x8
;     if (MpuP_isEnable()!=0U) {
700aeab4: f7ff ffac    	bl	0x700aea10 <MpuP_isEnable> @ imm = #-0xa8
700aeab8: b118         	cbz	r0, 0x700aeac2 <MpuP_init+0x12> @ imm = #0x6
700aeaba: e7ff         	b	0x700aeabc <MpuP_init+0xc> @ imm = #-0x2
;         MpuP_disable();
700aeabc: f7ff ffb0    	bl	0x700aea20 <MpuP_disable> @ imm = #-0xa0
;     }
700aeac0: e7ff         	b	0x700aeac2 <MpuP_init+0x12> @ imm = #-0x2
;     MpuP_disableBRAsm();
700aeac2: f000 e84e    	blx	0x700aeb60 <MpuP_disableBRAsm> @ imm = #0x9c
;     DebugP_assertNoLog( gMpuConfig.numRegions < MpuP_MAX_REGIONS);
700aeac6: f24f 1034    	movw	r0, #0xf134
700aeaca: f2c7 000a    	movt	r0, #0x700a
700aeace: 6801         	ldr	r1, [r0]
700aead0: 2000         	movs	r0, #0x0
700aead2: 9000         	str	r0, [sp]
700aead4: 2910         	cmp	r1, #0x10
700aead6: bf38         	it	lo
700aead8: 2001         	movlo	r0, #0x1
700aeada: f000 f919    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x232
700aeade: 9800         	ldr	r0, [sp]
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700aeae0: 9001         	str	r0, [sp, #0x4]
700aeae2: e7ff         	b	0x700aeae4 <MpuP_init+0x34> @ imm = #-0x2
700aeae4: 9801         	ldr	r0, [sp, #0x4]
700aeae6: f24f 1134    	movw	r1, #0xf134
700aeaea: f2c7 010a    	movt	r1, #0x700a
700aeaee: 6809         	ldr	r1, [r1]
700aeaf0: 4288         	cmp	r0, r1
700aeaf2: d212         	bhs	0x700aeb1a <MpuP_init+0x6a> @ imm = #0x24
700aeaf4: e7ff         	b	0x700aeaf6 <MpuP_init+0x46> @ imm = #-0x2
;         MpuP_setRegion(i,
700aeaf6: 9801         	ldr	r0, [sp, #0x4]
;                 (void*)gMpuRegionConfig[i].baseAddr,
700aeaf8: f24f 1140    	movw	r1, #0xf140
700aeafc: f2c7 010a    	movt	r1, #0x700a
700aeb00: eb01 1300    	add.w	r3, r1, r0, lsl #4
700aeb04: 0102         	lsls	r2, r0, #0x4
700aeb06: 5889         	ldr	r1, [r1, r2]
;                 gMpuRegionConfig[i].size,
700aeb08: 685a         	ldr	r2, [r3, #0x4]
;                 &gMpuRegionConfig[i].attrs
700aeb0a: 3308         	adds	r3, #0x8
;         MpuP_setRegion(i,
700aeb0c: f7ff ff08    	bl	0x700ae920 <MpuP_setRegion> @ imm = #-0x1f0
;     }
700aeb10: e7ff         	b	0x700aeb12 <MpuP_init+0x62> @ imm = #-0x2
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700aeb12: 9801         	ldr	r0, [sp, #0x4]
700aeb14: 3001         	adds	r0, #0x1
700aeb16: 9001         	str	r0, [sp, #0x4]
700aeb18: e7e4         	b	0x700aeae4 <MpuP_init+0x34> @ imm = #-0x38
;     if (gMpuConfig.enableBackgroundRegion!=0U) {
700aeb1a: f24f 1034    	movw	r0, #0xf134
700aeb1e: f2c7 000a    	movt	r0, #0x700a
700aeb22: 6840         	ldr	r0, [r0, #0x4]
700aeb24: b118         	cbz	r0, 0x700aeb2e <MpuP_init+0x7e> @ imm = #0x6
700aeb26: e7ff         	b	0x700aeb28 <MpuP_init+0x78> @ imm = #-0x2
;         MpuP_enableBRAsm();
700aeb28: f000 e82e    	blx	0x700aeb88 <MpuP_enableBRAsm> @ imm = #0x5c
;     }
700aeb2c: e7ff         	b	0x700aeb2e <MpuP_init+0x7e> @ imm = #-0x2
;     if (gMpuConfig.enableMpu!=0U) {
700aeb2e: f24f 1034    	movw	r0, #0xf134
700aeb32: f2c7 000a    	movt	r0, #0x700a
700aeb36: 6880         	ldr	r0, [r0, #0x8]
700aeb38: b118         	cbz	r0, 0x700aeb42 <MpuP_init+0x92> @ imm = #0x6
700aeb3a: e7ff         	b	0x700aeb3c <MpuP_init+0x8c> @ imm = #-0x2
;         MpuP_enable();
700aeb3c: f7ff ff90    	bl	0x700aea60 <MpuP_enable> @ imm = #-0xe0
;     }
700aeb40: e7ff         	b	0x700aeb42 <MpuP_init+0x92> @ imm = #-0x2
; }
700aeb42: b002         	add	sp, #0x8
700aeb44: bd80         	pop	{r7, pc}
700aeb46: 0000         	movs	r0, r0

700aeb48 <MpuP_disableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700aeb48: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1             // clear bit 0 in r0
700aeb4c: e3c00001     	bic	r0, r0, #1
;         dsb
700aeb50: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU disabled (bit 0 = 0)
700aeb54: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700aeb58: f57ff06f     	isb	sy
;         bx      LR
700aeb5c: e12fff1e     	bx	lr

700aeb60 <MpuP_disableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700aeb60: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x20000         // clear bit 17 in r0
700aeb64: e3c00802     	bic	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // disable background region
700aeb68: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700aeb6c: e12fff1e     	bx	lr

700aeb70 <MpuP_enableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700aeb70: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1             // set bit 0 in r0
700aeb74: e3800001     	orr	r0, r0, #1
;         dsb
700aeb78: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU enabled (bit 0 = 1)
700aeb7c: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700aeb80: f57ff06f     	isb	sy
;         bx      LR
700aeb84: e12fff1e     	bx	lr

700aeb88 <MpuP_enableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700aeb88: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x20000         // set bit 17 in r0
700aeb8c: e3800802     	orr	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // background region enabled
700aeb90: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700aeb94: e12fff1e     	bx	lr

700aeb98 <MpuP_isEnableAsm>:
;         mov     r0, #0
700aeb98: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0  // read SCTLR register to r1
700aeb9c: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1                 // test bit 0
700aeba0: e3110001     	tst	r1, #1
;         movne   r0, #1                   // if not 0, MPU is enabled
700aeba4: 13a00001     	movne	r0, #1
;         bx      LR
700aeba8: e12fff1e     	bx	lr

700aebac <MpuP_setRegionAsm>:
;         mcr     p15, #0, r0, c6, c2, #0  // select MPU region
700aebac: ee060f12     	mcr	p15, #0x0, r0, c6, c2, #0x0
;         mcr     p15, #0, r1, c6, c1, #0  // set region base address
700aebb0: ee061f11     	mcr	p15, #0x0, r1, c6, c1, #0x0
;         mcr     p15, #0, r2, c6, c1, #2  // set region size and enable it
700aebb4: ee062f51     	mcr	p15, #0x0, r2, c6, c1, #0x2
;         mcr     p15, #0, r3, c6, c1, #4  // set protection attributes
700aebb8: ee063f91     	mcr	p15, #0x0, r3, c6, c1, #0x4
;         bx      LR
700aebbc: e12fff1e     	bx	lr

Disassembly of section .text.boot:

700aebc0 <_c_int00_sbl>:
;         MRC     p15, #0, r1, c0, c0, #5
700aebc0: ee101fb0     	mrc	p15, #0x0, r1, c0, c0, #0x5
;         BFC     r1, #8, #24
700aebc4: e7df141f     	bfc	r1, #8, #24
;         CMP     r1, #0
700aebc8: e3510000     	cmp	r1, #0
;         BNE     _sblLoopForever
700aebcc: 1a000001     	bne	0x700aebd8 <_sblLoopForever> @ imm = #0x4
;         LDR     r1, _c_int00_addr
700aebd0: e59f1008     	ldr	r1, [pc, #0x8]          @ 0x700aebe0 <_c_int00_addr>
;         BLX     r1
700aebd4: e12fff31     	blx	r1

700aebd8 <_sblLoopForever>:
;         WFI
700aebd8: e320f003     	wfi
;         B       _sblLoopForever
700aebdc: eafffffd     	b	0x700aebd8 <_sblLoopForever> @ imm = #-0xc

700aebe0 <_c_int00_addr>:
700aebe0: e4 eb 0a 70  	.word	0x700aebe4

700aebe4 <_c_int00>:
;         mrs     r0, cpsr
700aebe4: e10f0000     	mrs	r0, apsr
;         orr     r0, r0, #0xC0
700aebe8: e38000c0     	orr	r0, r0, #192
;         msr     cpsr_cf, r0
700aebec: e129f000     	msr	CPSR_fc, r0
;         MRC      p15,#0x0,r0,c1,c0,#2
700aebf0: ee110f50     	mrc	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r3,#0xf00000
700aebf4: e3a0360f     	mov	r3, #15728640
;         ORR      r0,r0,r3
700aebf8: e1800003     	orr	r0, r0, r3
;         MCR      p15,#0x0,r0,c1,c0,#2
700aebfc: ee010f50     	mcr	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r0,#0x40000000
700aec00: e3a00101     	mov	r0, #1073741824
;         FMXR     FPEXC,r0
700aec04: eee80a10     	vmsr	fpexc, r0
;         MRS     r0, cpsr
700aec08: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aec0c: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x11  // SET FIQ MODE
700aec10: e3800011     	orr	r0, r0, #17
;         MSR     cpsr_cf, r0
700aec14: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_FIQ_STACK_END
700aec18: e59fd0d4     	ldr	sp, [pc, #0xd4]         @ 0x700aecf4 <c_FIQ_STACK_END>
;         MRS     r0, cpsr
700aec1c: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aec20: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x12  // SET IRQ MODE
700aec24: e3800012     	orr	r0, r0, #18
;         MSR     cpsr_cf, r0
700aec28: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_IRQ_STACK_END
700aec2c: e59fd0bc     	ldr	sp, [pc, #0xbc]         @ 0x700aecf0 <c_IRQ_STACK_END>
;         MRS     r0, cpsr
700aec30: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aec34: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x13  // SET SVC MODE
700aec38: e3800013     	orr	r0, r0, #19
;         MSR     cpsr_cf, r0
700aec3c: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_SVC_STACK_END
700aec40: e59fd0b0     	ldr	sp, [pc, #0xb0]         @ 0x700aecf8 <c_SVC_STACK_END>
;         MRS     r0, cpsr
700aec44: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aec48: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x17  // SET ABORT MODE
700aec4c: e3800017     	orr	r0, r0, #23
;         MSR     cpsr_cf, r0
700aec50: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_ABORT_STACK_END
700aec54: e59fd0a0     	ldr	sp, [pc, #0xa0]         @ 0x700aecfc <c_ABORT_STACK_END>
;         MRS     r0, cpsr
700aec58: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aec5c: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1B  // SET ABORT MODE
700aec60: e380001b     	orr	r0, r0, #27
;         MSR     cpsr_cf, r0
700aec64: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_UNDEFINED_STACK_END
700aec68: e59fd090     	ldr	sp, [pc, #0x90]         @ 0x700aed00 <c_UNDEFINED_STACK_END>
;         MRS     r0, cpsr
700aec6c: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700aec70: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1F  // SET SYSTEM MODE
700aec74: e380001f     	orr	r0, r0, #31
;         MSR     cpsr_cf, r0
700aec78: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_STACK_END
700aec7c: e59fd068     	ldr	sp, [pc, #0x68]         @ 0x700aecec <c_STACK_END>
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700aec80: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC r0, r0, #0x1 << 2      // Disable data cache bit
700aec84: e3c00004     	bic	r0, r0, #4
;         BIC r0, r0, #0x1 << 12     // Disable instruction cache bit
700aec88: e3c00a01     	bic	r0, r0, #4096
;         DSB
700aec8c: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700aec90: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB                        // Ensures following instructions are not executed from cache
700aec94: f57ff06f     	isb	sy
;         MRC p15, 0, r1, c1, c0, 1  // Read Auxiliary Control Register
700aec98: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         ORR r1, r1, #(0x1 << 3)    //Enable ECC for Cache
700aec9c: e3811008     	orr	r1, r1, #8
;         ORR r1,r1,#(0x1 << 5)
700aeca0: e3811020     	orr	r1, r1, #32
;         MCR p15, 0, r1, c1, c0, 1  // Write Auxiliary Control Register
700aeca4: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         MCR p15, 0, r0, c15, c5, 0 // Invalidate entire data cache
700aeca8: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         MCR p15, 0, r0, c7, c5, 0  // Invalidate entire instruction cache
700aecac: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700aecb0: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR r0, r0, #0x1 << 2      // Enable data cache bit
700aecb4: e3800004     	orr	r0, r0, #4
;         ORR r0, r0, #0x1 << 12     // Enable instruction cache bit
700aecb8: e3800a01     	orr	r0, r0, #4096
;         DSB
700aecbc: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700aecc0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB
700aecc4: f57ff06f     	isb	sy
;         BL      __mpu_init
700aecc8: fa000028     	blx	0x700aed70 <__mpu_init> @ imm = #0xa0
;         BL      _system_pre_init
700aeccc: fa00001b     	blx	0x700aed40 <_system_pre_init> @ imm = #0x6c
;         CMP     R0, #0
700aecd0: e3500000     	cmp	r0, #0
;         BEQ     bypass_auto_init
700aecd4: 0a000000     	beq	0x700aecdc <bypass_auto_init> @ imm = #0x0
;         BL      __TI_auto_init
700aecd8: ebfff02d     	bl	0x700aad94 <__TI_auto_init_nobinit_nopinit> @ imm = #-0x3f4c

700aecdc <bypass_auto_init>:
;         BL      main
700aecdc: fafffac3     	blx	0x700ad7f0 <main>       @ imm = #-0x14f4
;         MOV     R0, #1
700aece0: e3a00001     	mov	r0, #1
;         BL      exit
700aece4: eb000025     	bl	0x700aed80 <abort>      @ imm = #0x94

700aece8 <L1>:
; L1:     B       L1
700aece8: eafffffe     	b	0x700aece8 <L1>         @ imm = #-0x8

700aecec <c_STACK_END>:
700aecec: 00 90 09 70  	.word	0x70099000

700aecf0 <c_IRQ_STACK_END>:
700aecf0: 28 03 0b 70  	.word	0x700b0328

700aecf4 <c_FIQ_STACK_END>:
700aecf4: 28 04 0b 70  	.word	0x700b0428

700aecf8 <c_SVC_STACK_END>:
700aecf8: 28 14 0b 70  	.word	0x700b1428

700aecfc <c_ABORT_STACK_END>:
700aecfc: 28 15 0b 70  	.word	0x700b1528

700aed00 <c_UNDEFINED_STACK_END>:
700aed00: 28 16 0b 70  	.word	0x700b1628
700aed04: 00 00 00 00  	.word	0x00000000
700aed08: 00 00 00 00  	.word	0x00000000
700aed0c: 00 00 00 00  	.word	0x00000000

700aed10 <_DebugP_assertNoLog>:
; {
700aed10: b580         	push	{r7, lr}
700aed12: b082         	sub	sp, #0x8
700aed14: 9001         	str	r0, [sp, #0x4]
;     if(expression==0)
700aed16: 9801         	ldr	r0, [sp, #0x4]
700aed18: b950         	cbnz	r0, 0x700aed30 <_DebugP_assertNoLog+0x20> @ imm = #0x14
700aed1a: e7ff         	b	0x700aed1c <_DebugP_assertNoLog+0xc> @ imm = #-0x2
700aed1c: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700aed1e: 9000         	str	r0, [sp]
;         (void) HwiP_disable();
700aed20: f7ff eb36    	blx	0x700ae390 <HwiP_disable> @ imm = #-0x994
;         while(assert_loop!= 0U)
700aed24: e7ff         	b	0x700aed26 <_DebugP_assertNoLog+0x16> @ imm = #-0x2
700aed26: 9800         	ldr	r0, [sp]
700aed28: b108         	cbz	r0, 0x700aed2e <_DebugP_assertNoLog+0x1e> @ imm = #0x2
700aed2a: e7ff         	b	0x700aed2c <_DebugP_assertNoLog+0x1c> @ imm = #-0x2
700aed2c: e7fb         	b	0x700aed26 <_DebugP_assertNoLog+0x16> @ imm = #-0xa
;     }
700aed2e: e7ff         	b	0x700aed30 <_DebugP_assertNoLog+0x20> @ imm = #-0x2
; }
700aed30: b002         	add	sp, #0x8
700aed32: bd80         	pop	{r7, pc}
		...

700aed40 <_system_pre_init>:
; {
700aed40: b580         	push	{r7, lr}
700aed42: b082         	sub	sp, #0x8
;     uint32_t bss_size = ((uintptr_t)&__BSS_END - (uintptr_t)&__BSS_START);
700aed44: f240 0000    	movw	r0, #0x0
700aed48: f2c7 0008    	movt	r0, #0x7008
700aed4c: f245 0100    	movw	r1, #0x5000
700aed50: f2c7 0108    	movt	r1, #0x7008
700aed54: 1a09         	subs	r1, r1, r0
700aed56: 9101         	str	r1, [sp, #0x4]
;     (void) memset((void*)&__BSS_START, 0x00, bss_size);
700aed58: 9901         	ldr	r1, [sp, #0x4]
700aed5a: f7ea ee6c    	blx	0x70099a34 <__aeabi_memclr8> @ imm = #-0x15328
700aed5e: 2001         	movs	r0, #0x1
;     return 1;
700aed60: b002         	add	sp, #0x8
700aed62: bd80         	pop	{r7, pc}
		...

700aed70 <__mpu_init>:
; {
700aed70: b580         	push	{r7, lr}
;     MpuP_init();
700aed72: f7ff fe9d    	bl	0x700aeab0 <MpuP_init>  @ imm = #-0x2c6
;     CacheP_init();
700aed76: e8bd 4080    	pop.w	{r7, lr}
700aed7a: f7ff bd09    	b.w	0x700ae790 <CacheP_init> @ imm = #-0x5ee
700aed7e: 0000         	movs	r0, r0

Disassembly of section .text:abort:

700aed80 <abort>:
700aed80: e320f000     	nop
700aed84: eafffffe     	b	0x700aed84 <abort+0x4>  @ imm = #-0x8

Disassembly of section .text:

70099000 <_vsnprintf>:
; {
70099000: e92d 43f0    	push.w	{r4, r5, r6, r7, r8, r9, lr}
70099004: b0c1         	sub	sp, #0x104
70099006: f8dd c120    	ldr.w	r12, [sp, #0x120]
7009900a: f8cd c100    	str.w	r12, [sp, #0x100]
7009900e: 903f         	str	r0, [sp, #0xfc]
70099010: 913e         	str	r1, [sp, #0xf8]
70099012: 923d         	str	r2, [sp, #0xf4]
70099014: 933c         	str	r3, [sp, #0xf0]
70099016: 2000         	movs	r0, #0x0
;   size_t idx = 0U;
70099018: 9037         	str	r0, [sp, #0xdc]
;   if (!buffer) {
7009901a: 983e         	ldr	r0, [sp, #0xf8]
7009901c: b930         	cbnz	r0, 0x7009902c <_vsnprintf+0x2c> @ imm = #0xc
7009901e: e7ff         	b	0x70099020 <_vsnprintf+0x20> @ imm = #-0x2
;     out = _out_null;
70099020: f24d 6071    	movw	r0, #0xd671
70099024: f2c7 000a    	movt	r0, #0x700a
70099028: 903f         	str	r0, [sp, #0xfc]
;   }
7009902a: e7ff         	b	0x7009902c <_vsnprintf+0x2c> @ imm = #-0x2
;   while (*format)
7009902c: e7ff         	b	0x7009902e <_vsnprintf+0x2e> @ imm = #-0x2
7009902e: 983c         	ldr	r0, [sp, #0xf0]
70099030: 7800         	ldrb	r0, [r0]
70099032: 2800         	cmp	r0, #0x0
70099034: f000 84e3    	beq.w	0x700999fe <_vsnprintf+0x9fe> @ imm = #0x9c6
70099038: e7ff         	b	0x7009903a <_vsnprintf+0x3a> @ imm = #-0x2
;     if (*format != '%') {
7009903a: 983c         	ldr	r0, [sp, #0xf0]
7009903c: 7800         	ldrb	r0, [r0]
7009903e: 2825         	cmp	r0, #0x25
70099040: d00e         	beq	0x70099060 <_vsnprintf+0x60> @ imm = #0x1c
70099042: e7ff         	b	0x70099044 <_vsnprintf+0x44> @ imm = #-0x2
;       out(*format, buffer, idx++, maxlen);
70099044: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099048: 983c         	ldr	r0, [sp, #0xf0]
7009904a: 7800         	ldrb	r0, [r0]
7009904c: 993e         	ldr	r1, [sp, #0xf8]
7009904e: 9a37         	ldr	r2, [sp, #0xdc]
70099050: 1c53         	adds	r3, r2, #0x1
70099052: 9337         	str	r3, [sp, #0xdc]
70099054: 9b3d         	ldr	r3, [sp, #0xf4]
70099056: 47e0         	blx	r12
;       format++;
70099058: 983c         	ldr	r0, [sp, #0xf0]
7009905a: 3001         	adds	r0, #0x1
7009905c: 903c         	str	r0, [sp, #0xf0]
;       continue;
7009905e: e7e6         	b	0x7009902e <_vsnprintf+0x2e> @ imm = #-0x34
;       format++;
70099060: 983c         	ldr	r0, [sp, #0xf0]
70099062: 3001         	adds	r0, #0x1
70099064: 903c         	str	r0, [sp, #0xf0]
70099066: e7ff         	b	0x70099068 <_vsnprintf+0x68> @ imm = #-0x2
70099068: 2000         	movs	r0, #0x0
;     flags = 0U;
7009906a: 903b         	str	r0, [sp, #0xec]
;     do {
7009906c: e7ff         	b	0x7009906e <_vsnprintf+0x6e> @ imm = #-0x2
;       switch (*format) {
7009906e: 983c         	ldr	r0, [sp, #0xf0]
70099070: 7800         	ldrb	r0, [r0]
70099072: 3820         	subs	r0, #0x20
70099074: 4601         	mov	r1, r0
70099076: 912a         	str	r1, [sp, #0xa8]
70099078: 2810         	cmp	r0, #0x10
7009907a: d83d         	bhi	0x700990f8 <_vsnprintf+0xf8> @ imm = #0x7a
7009907c: 992a         	ldr	r1, [sp, #0xa8]
7009907e: e8df f001    	tbb	[pc, r1]
70099082: 27 3b 3b 31  	.word	0x313b3b27
70099086: 3b 3b 3b 3b  	.word	0x3b3b3b3b
7009908a: 3b 3b 3b 1d  	.word	0x1d3b3b3b
7009908e: 3b 13 3b 3b  	.word	0x3b3b133b
70099092: 09 00        	.short	0x0009
;         case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
70099094: 983b         	ldr	r0, [sp, #0xec]
70099096: f040 0001    	orr	r0, r0, #0x1
7009909a: 903b         	str	r0, [sp, #0xec]
7009909c: 983c         	ldr	r0, [sp, #0xf0]
7009909e: 3001         	adds	r0, #0x1
700990a0: 903c         	str	r0, [sp, #0xf0]
700990a2: 2001         	movs	r0, #0x1
700990a4: 9038         	str	r0, [sp, #0xe0]
700990a6: e02a         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #0x54
;         case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
700990a8: 983b         	ldr	r0, [sp, #0xec]
700990aa: f040 0002    	orr	r0, r0, #0x2
700990ae: 903b         	str	r0, [sp, #0xec]
700990b0: 983c         	ldr	r0, [sp, #0xf0]
700990b2: 3001         	adds	r0, #0x1
700990b4: 903c         	str	r0, [sp, #0xf0]
700990b6: 2001         	movs	r0, #0x1
700990b8: 9038         	str	r0, [sp, #0xe0]
700990ba: e020         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #0x40
;         case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
700990bc: 983b         	ldr	r0, [sp, #0xec]
700990be: f040 0004    	orr	r0, r0, #0x4
700990c2: 903b         	str	r0, [sp, #0xec]
700990c4: 983c         	ldr	r0, [sp, #0xf0]
700990c6: 3001         	adds	r0, #0x1
700990c8: 903c         	str	r0, [sp, #0xf0]
700990ca: 2001         	movs	r0, #0x1
700990cc: 9038         	str	r0, [sp, #0xe0]
700990ce: e016         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #0x2c
;         case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
700990d0: 983b         	ldr	r0, [sp, #0xec]
700990d2: f040 0008    	orr	r0, r0, #0x8
700990d6: 903b         	str	r0, [sp, #0xec]
700990d8: 983c         	ldr	r0, [sp, #0xf0]
700990da: 3001         	adds	r0, #0x1
700990dc: 903c         	str	r0, [sp, #0xf0]
700990de: 2001         	movs	r0, #0x1
700990e0: 9038         	str	r0, [sp, #0xe0]
700990e2: e00c         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #0x18
;         case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
700990e4: 983b         	ldr	r0, [sp, #0xec]
700990e6: f040 0010    	orr	r0, r0, #0x10
700990ea: 903b         	str	r0, [sp, #0xec]
700990ec: 983c         	ldr	r0, [sp, #0xf0]
700990ee: 3001         	adds	r0, #0x1
700990f0: 903c         	str	r0, [sp, #0xf0]
700990f2: 2001         	movs	r0, #0x1
700990f4: 9038         	str	r0, [sp, #0xe0]
700990f6: e002         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #0x4
700990f8: 2000         	movs	r0, #0x0
;         default :                                   n = 0U; break;
700990fa: 9038         	str	r0, [sp, #0xe0]
700990fc: e7ff         	b	0x700990fe <_vsnprintf+0xfe> @ imm = #-0x2
;     } while (n);
700990fe: e7ff         	b	0x70099100 <_vsnprintf+0x100> @ imm = #-0x2
70099100: 9838         	ldr	r0, [sp, #0xe0]
70099102: 2800         	cmp	r0, #0x0
70099104: d1b3         	bne	0x7009906e <_vsnprintf+0x6e> @ imm = #-0x9a
70099106: e7ff         	b	0x70099108 <_vsnprintf+0x108> @ imm = #-0x2
70099108: 2000         	movs	r0, #0x0
;     width = 0U;
7009910a: 903a         	str	r0, [sp, #0xe8]
;     if (_is_digit(*format)) {
7009910c: 983c         	ldr	r0, [sp, #0xf0]
7009910e: 7800         	ldrb	r0, [r0]
70099110: f013 fa6e    	bl	0x700ac5f0 <_is_digit>  @ imm = #0x134dc
70099114: b128         	cbz	r0, 0x70099122 <_vsnprintf+0x122> @ imm = #0xa
70099116: e7ff         	b	0x70099118 <_vsnprintf+0x118> @ imm = #-0x2
70099118: a83c         	add	r0, sp, #0xf0
;       width = _atoi(&format);
7009911a: f012 fed1    	bl	0x700abec0 <_atoi>      @ imm = #0x12da2
7009911e: 903a         	str	r0, [sp, #0xe8]
;     }
70099120: e01e         	b	0x70099160 <_vsnprintf+0x160> @ imm = #0x3c
;     else if (*format == '*') {
70099122: 983c         	ldr	r0, [sp, #0xf0]
70099124: 7800         	ldrb	r0, [r0]
70099126: 282a         	cmp	r0, #0x2a
70099128: d119         	bne	0x7009915e <_vsnprintf+0x15e> @ imm = #0x32
7009912a: e7ff         	b	0x7009912c <_vsnprintf+0x12c> @ imm = #-0x2
;       const int w = va_arg(va, int);
7009912c: 9840         	ldr	r0, [sp, #0x100]
7009912e: 1d01         	adds	r1, r0, #0x4
70099130: 9140         	str	r1, [sp, #0x100]
70099132: 6800         	ldr	r0, [r0]
70099134: 9036         	str	r0, [sp, #0xd8]
;       if (w < 0) {
70099136: 9836         	ldr	r0, [sp, #0xd8]
70099138: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009913c: dc08         	bgt	0x70099150 <_vsnprintf+0x150> @ imm = #0x10
7009913e: e7ff         	b	0x70099140 <_vsnprintf+0x140> @ imm = #-0x2
;         flags |= FLAGS_LEFT;    // reverse padding
70099140: 983b         	ldr	r0, [sp, #0xec]
70099142: f040 0002    	orr	r0, r0, #0x2
70099146: 903b         	str	r0, [sp, #0xec]
;         width = (unsigned int)-w;
70099148: 9836         	ldr	r0, [sp, #0xd8]
7009914a: 4240         	rsbs	r0, r0, #0
7009914c: 903a         	str	r0, [sp, #0xe8]
;       }
7009914e: e002         	b	0x70099156 <_vsnprintf+0x156> @ imm = #0x4
;         width = (unsigned int)w;
70099150: 9836         	ldr	r0, [sp, #0xd8]
70099152: 903a         	str	r0, [sp, #0xe8]
70099154: e7ff         	b	0x70099156 <_vsnprintf+0x156> @ imm = #-0x2
;       format++;
70099156: 983c         	ldr	r0, [sp, #0xf0]
70099158: 3001         	adds	r0, #0x1
7009915a: 903c         	str	r0, [sp, #0xf0]
;     }
7009915c: e7ff         	b	0x7009915e <_vsnprintf+0x15e> @ imm = #-0x2
7009915e: e7ff         	b	0x70099160 <_vsnprintf+0x160> @ imm = #-0x2
70099160: 2000         	movs	r0, #0x0
;     precision = 0U;
70099162: 9039         	str	r0, [sp, #0xe4]
;     if (*format == '.') {
70099164: 983c         	ldr	r0, [sp, #0xf0]
70099166: 7800         	ldrb	r0, [r0]
70099168: 282e         	cmp	r0, #0x2e
7009916a: d12e         	bne	0x700991ca <_vsnprintf+0x1ca> @ imm = #0x5c
7009916c: e7ff         	b	0x7009916e <_vsnprintf+0x16e> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;
7009916e: 983b         	ldr	r0, [sp, #0xec]
70099170: f440 6080    	orr	r0, r0, #0x400
70099174: 903b         	str	r0, [sp, #0xec]
;       format++;
70099176: 983c         	ldr	r0, [sp, #0xf0]
70099178: 3001         	adds	r0, #0x1
7009917a: 903c         	str	r0, [sp, #0xf0]
;       if (_is_digit(*format)) {
7009917c: 983c         	ldr	r0, [sp, #0xf0]
7009917e: 7800         	ldrb	r0, [r0]
70099180: f013 fa36    	bl	0x700ac5f0 <_is_digit>  @ imm = #0x1346c
70099184: b128         	cbz	r0, 0x70099192 <_vsnprintf+0x192> @ imm = #0xa
70099186: e7ff         	b	0x70099188 <_vsnprintf+0x188> @ imm = #-0x2
70099188: a83c         	add	r0, sp, #0xf0
;         precision = _atoi(&format);
7009918a: f012 fe99    	bl	0x700abec0 <_atoi>      @ imm = #0x12d32
7009918e: 9039         	str	r0, [sp, #0xe4]
;       }
70099190: e01a         	b	0x700991c8 <_vsnprintf+0x1c8> @ imm = #0x34
;       else if (*format == '*') {
70099192: 983c         	ldr	r0, [sp, #0xf0]
70099194: 7800         	ldrb	r0, [r0]
70099196: 282a         	cmp	r0, #0x2a
70099198: d115         	bne	0x700991c6 <_vsnprintf+0x1c6> @ imm = #0x2a
7009919a: e7ff         	b	0x7009919c <_vsnprintf+0x19c> @ imm = #-0x2
;         const int prec = (int)va_arg(va, int);
7009919c: 9840         	ldr	r0, [sp, #0x100]
7009919e: 1d01         	adds	r1, r0, #0x4
700991a0: 9140         	str	r1, [sp, #0x100]
700991a2: 6800         	ldr	r0, [r0]
700991a4: 9035         	str	r0, [sp, #0xd4]
;         precision = prec > 0 ? (unsigned int)prec : 0U;
700991a6: 9835         	ldr	r0, [sp, #0xd4]
700991a8: 2801         	cmp	r0, #0x1
700991aa: db03         	blt	0x700991b4 <_vsnprintf+0x1b4> @ imm = #0x6
700991ac: e7ff         	b	0x700991ae <_vsnprintf+0x1ae> @ imm = #-0x2
700991ae: 9835         	ldr	r0, [sp, #0xd4]
700991b0: 9029         	str	r0, [sp, #0xa4]
700991b2: e002         	b	0x700991ba <_vsnprintf+0x1ba> @ imm = #0x4
700991b4: 2000         	movs	r0, #0x0
;         precision = prec > 0 ? (unsigned int)prec : 0U;
700991b6: 9029         	str	r0, [sp, #0xa4]
700991b8: e7ff         	b	0x700991ba <_vsnprintf+0x1ba> @ imm = #-0x2
700991ba: 9829         	ldr	r0, [sp, #0xa4]
700991bc: 9039         	str	r0, [sp, #0xe4]
;         format++;
700991be: 983c         	ldr	r0, [sp, #0xf0]
700991c0: 3001         	adds	r0, #0x1
700991c2: 903c         	str	r0, [sp, #0xf0]
;       }
700991c4: e7ff         	b	0x700991c6 <_vsnprintf+0x1c6> @ imm = #-0x2
700991c6: e7ff         	b	0x700991c8 <_vsnprintf+0x1c8> @ imm = #-0x2
;     }
700991c8: e7ff         	b	0x700991ca <_vsnprintf+0x1ca> @ imm = #-0x2
;     switch (*format) {
700991ca: 983c         	ldr	r0, [sp, #0xf0]
700991cc: 7800         	ldrb	r0, [r0]
700991ce: 3868         	subs	r0, #0x68
700991d0: 4601         	mov	r1, r0
700991d2: 9128         	str	r1, [sp, #0xa0]
700991d4: 2812         	cmp	r0, #0x12
700991d6: d84e         	bhi	0x70099276 <_vsnprintf+0x276> @ imm = #0x9c
700991d8: 9928         	ldr	r1, [sp, #0xa0]
700991da: e8df f001    	tbb	[pc, r1]
700991de: 1f 4c 3c 4c  	.word	0x4c3c4c1f
700991e2: 0a 4c 4c 4c  	.word	0x4c4c4c0a
700991e6: 4c 4c 4c 4c  	.word	0x4c4c4c4c
700991ea: 34 4c 4c 4c  	.word	0x4c4c4c34
700991ee: 4c 4c 44 00  	.word	0x00444c4c
;         flags |= FLAGS_LONG;
700991f2: 983b         	ldr	r0, [sp, #0xec]
700991f4: f440 7080    	orr	r0, r0, #0x100
700991f8: 903b         	str	r0, [sp, #0xec]
;         format++;
700991fa: 983c         	ldr	r0, [sp, #0xf0]
700991fc: 3001         	adds	r0, #0x1
700991fe: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'l') {
70099200: 983c         	ldr	r0, [sp, #0xf0]
70099202: 7800         	ldrb	r0, [r0]
70099204: 286c         	cmp	r0, #0x6c
70099206: d108         	bne	0x7009921a <_vsnprintf+0x21a> @ imm = #0x10
70099208: e7ff         	b	0x7009920a <_vsnprintf+0x20a> @ imm = #-0x2
;           flags |= FLAGS_LONG_LONG;
7009920a: 983b         	ldr	r0, [sp, #0xec]
7009920c: f440 7000    	orr	r0, r0, #0x200
70099210: 903b         	str	r0, [sp, #0xec]
;           format++;
70099212: 983c         	ldr	r0, [sp, #0xf0]
70099214: 3001         	adds	r0, #0x1
70099216: 903c         	str	r0, [sp, #0xf0]
;         }
70099218: e7ff         	b	0x7009921a <_vsnprintf+0x21a> @ imm = #-0x2
;         break;
7009921a: e02d         	b	0x70099278 <_vsnprintf+0x278> @ imm = #0x5a
;         flags |= FLAGS_SHORT;
7009921c: 983b         	ldr	r0, [sp, #0xec]
7009921e: f040 0080    	orr	r0, r0, #0x80
70099222: 903b         	str	r0, [sp, #0xec]
;         format++;
70099224: 983c         	ldr	r0, [sp, #0xf0]
70099226: 3001         	adds	r0, #0x1
70099228: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'h') {
7009922a: 983c         	ldr	r0, [sp, #0xf0]
7009922c: 7800         	ldrb	r0, [r0]
7009922e: 2868         	cmp	r0, #0x68
70099230: d108         	bne	0x70099244 <_vsnprintf+0x244> @ imm = #0x10
70099232: e7ff         	b	0x70099234 <_vsnprintf+0x234> @ imm = #-0x2
;           flags |= FLAGS_CHAR;
70099234: 983b         	ldr	r0, [sp, #0xec]
70099236: f040 0040    	orr	r0, r0, #0x40
7009923a: 903b         	str	r0, [sp, #0xec]
;           format++;
7009923c: 983c         	ldr	r0, [sp, #0xf0]
7009923e: 3001         	adds	r0, #0x1
70099240: 903c         	str	r0, [sp, #0xf0]
;         }
70099242: e7ff         	b	0x70099244 <_vsnprintf+0x244> @ imm = #-0x2
;         break;
70099244: e018         	b	0x70099278 <_vsnprintf+0x278> @ imm = #0x30
;         flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
70099246: 983b         	ldr	r0, [sp, #0xec]
70099248: f440 7080    	orr	r0, r0, #0x100
7009924c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009924e: 983c         	ldr	r0, [sp, #0xf0]
70099250: 3001         	adds	r0, #0x1
70099252: 903c         	str	r0, [sp, #0xf0]
;         break;
70099254: e010         	b	0x70099278 <_vsnprintf+0x278> @ imm = #0x20
;         flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
70099256: 983b         	ldr	r0, [sp, #0xec]
70099258: f440 7000    	orr	r0, r0, #0x200
7009925c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009925e: 983c         	ldr	r0, [sp, #0xf0]
70099260: 3001         	adds	r0, #0x1
70099262: 903c         	str	r0, [sp, #0xf0]
;         break;
70099264: e008         	b	0x70099278 <_vsnprintf+0x278> @ imm = #0x10
;         flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
70099266: 983b         	ldr	r0, [sp, #0xec]
70099268: f440 7080    	orr	r0, r0, #0x100
7009926c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009926e: 983c         	ldr	r0, [sp, #0xf0]
70099270: 3001         	adds	r0, #0x1
70099272: 903c         	str	r0, [sp, #0xf0]
;         break;
70099274: e000         	b	0x70099278 <_vsnprintf+0x278> @ imm = #0x0
;         break;
70099276: e7ff         	b	0x70099278 <_vsnprintf+0x278> @ imm = #-0x2
;     switch (*format) {
70099278: 983c         	ldr	r0, [sp, #0xf0]
7009927a: 7800         	ldrb	r0, [r0]
7009927c: 3825         	subs	r0, #0x25
7009927e: 4601         	mov	r1, r0
70099280: 9127         	str	r1, [sp, #0x9c]
70099282: 2853         	cmp	r0, #0x53
70099284: f200 83ab    	bhi.w	0x700999de <_vsnprintf+0x9de> @ imm = #0x756
70099288: 9927         	ldr	r1, [sp, #0x9c]
7009928a: e8df f011    	tbh	[pc, r1, lsl #1]
7009928e: 9b 03 a8 03  	.word	0x03a8039b
70099292: a8 03 a8 03  	.word	0x03a803a8
70099296: a8 03 a8 03  	.word	0x03a803a8
7009929a: a8 03 a8 03  	.word	0x03a803a8
7009929e: a8 03 a8 03  	.word	0x03a803a8
700992a2: a8 03 a8 03  	.word	0x03a803a8
700992a6: a8 03 a8 03  	.word	0x03a803a8
700992aa: a8 03 a8 03  	.word	0x03a803a8
700992ae: a8 03 a8 03  	.word	0x03a803a8
700992b2: a8 03 a8 03  	.word	0x03a803a8
700992b6: a8 03 a8 03  	.word	0x03a803a8
700992ba: a8 03 a8 03  	.word	0x03a803a8
700992be: a8 03 a8 03  	.word	0x03a803a8
700992c2: a8 03 a8 03  	.word	0x03a803a8
700992c6: a8 03 a8 03  	.word	0x03a803a8
700992ca: a8 03 a8 03  	.word	0x03a803a8
700992ce: 5e 02 32 02  	.word	0x0232025e
700992d2: 5e 02 a8 03  	.word	0x03a8025e
700992d6: a8 03 a8 03  	.word	0x03a803a8
700992da: a8 03 a8 03  	.word	0x03a803a8
700992de: a8 03 a8 03  	.word	0x03a803a8
700992e2: a8 03 a8 03  	.word	0x03a803a8
700992e6: a8 03 a8 03  	.word	0x03a803a8
700992ea: a8 03 a8 03  	.word	0x03a803a8
700992ee: a8 03 a8 03  	.word	0x03a803a8
700992f2: a8 03 54 00  	.word	0x005403a8
700992f6: a8 03 a8 03  	.word	0x03a803a8
700992fa: a8 03 a8 03  	.word	0x03a803a8
700992fe: a8 03 a8 03  	.word	0x03a803a8
70099302: a8 03 a8 03  	.word	0x03a803a8
70099306: a8 03 54 00  	.word	0x005403a8
7009930a: 9e 02 54 00  	.word	0x0054029e
7009930e: 5e 02 32 02  	.word	0x0232025e
70099312: 5e 02 a8 03  	.word	0x03a8025e
70099316: 54 00 a8 03  	.word	0x03a80054
7009931a: a8 03 a8 03  	.word	0x03a803a8
7009931e: a8 03 a8 03  	.word	0x03a803a8
70099322: 54 00 6e 03  	.word	0x036e0054
70099326: a8 03 a8 03  	.word	0x03a803a8
7009932a: e2 02 a8 03  	.word	0x03a802e2
7009932e: 54 00 a8 03  	.word	0x03a80054
70099332: a8 03 54 00  	.word	0x005403a8
;         if (*format == 'x' || *format == 'X') {
70099336: 983c         	ldr	r0, [sp, #0xf0]
70099338: 7800         	ldrb	r0, [r0]
7009933a: 2878         	cmp	r0, #0x78
7009933c: d005         	beq	0x7009934a <_vsnprintf+0x34a> @ imm = #0xa
7009933e: e7ff         	b	0x70099340 <_vsnprintf+0x340> @ imm = #-0x2
70099340: 983c         	ldr	r0, [sp, #0xf0]
70099342: 7800         	ldrb	r0, [r0]
70099344: 2858         	cmp	r0, #0x58
70099346: d103         	bne	0x70099350 <_vsnprintf+0x350> @ imm = #0x6
70099348: e7ff         	b	0x7009934a <_vsnprintf+0x34a> @ imm = #-0x2
7009934a: 2010         	movs	r0, #0x10
;           base = 16U;
7009934c: 9034         	str	r0, [sp, #0xd0]
;         }
7009934e: e018         	b	0x70099382 <_vsnprintf+0x382> @ imm = #0x30
;         else if (*format == 'o') {
70099350: 983c         	ldr	r0, [sp, #0xf0]
70099352: 7800         	ldrb	r0, [r0]
70099354: 286f         	cmp	r0, #0x6f
70099356: d103         	bne	0x70099360 <_vsnprintf+0x360> @ imm = #0x6
70099358: e7ff         	b	0x7009935a <_vsnprintf+0x35a> @ imm = #-0x2
7009935a: 2008         	movs	r0, #0x8
;           base =  8U;
7009935c: 9034         	str	r0, [sp, #0xd0]
;         }
7009935e: e00f         	b	0x70099380 <_vsnprintf+0x380> @ imm = #0x1e
;         else if (*format == 'b') {
70099360: 983c         	ldr	r0, [sp, #0xf0]
70099362: 7800         	ldrb	r0, [r0]
70099364: 2862         	cmp	r0, #0x62
70099366: d103         	bne	0x70099370 <_vsnprintf+0x370> @ imm = #0x6
70099368: e7ff         	b	0x7009936a <_vsnprintf+0x36a> @ imm = #-0x2
7009936a: 2002         	movs	r0, #0x2
;           base =  2U;
7009936c: 9034         	str	r0, [sp, #0xd0]
;         }
7009936e: e006         	b	0x7009937e <_vsnprintf+0x37e> @ imm = #0xc
70099370: 200a         	movs	r0, #0xa
;           base = 10U;
70099372: 9034         	str	r0, [sp, #0xd0]
;           flags &= ~FLAGS_HASH;   // no hash for dec format
70099374: 983b         	ldr	r0, [sp, #0xec]
70099376: f020 0010    	bic	r0, r0, #0x10
7009937a: 903b         	str	r0, [sp, #0xec]
7009937c: e7ff         	b	0x7009937e <_vsnprintf+0x37e> @ imm = #-0x2
7009937e: e7ff         	b	0x70099380 <_vsnprintf+0x380> @ imm = #-0x2
70099380: e7ff         	b	0x70099382 <_vsnprintf+0x382> @ imm = #-0x2
;         if (*format == 'X') {
70099382: 983c         	ldr	r0, [sp, #0xf0]
70099384: 7800         	ldrb	r0, [r0]
70099386: 2858         	cmp	r0, #0x58
70099388: d105         	bne	0x70099396 <_vsnprintf+0x396> @ imm = #0xa
7009938a: e7ff         	b	0x7009938c <_vsnprintf+0x38c> @ imm = #-0x2
;           flags |= FLAGS_UPPERCASE;
7009938c: 983b         	ldr	r0, [sp, #0xec]
7009938e: f040 0020    	orr	r0, r0, #0x20
70099392: 903b         	str	r0, [sp, #0xec]
;         }
70099394: e7ff         	b	0x70099396 <_vsnprintf+0x396> @ imm = #-0x2
;         if ((*format != 'i') && (*format != 'd')) {
70099396: 983c         	ldr	r0, [sp, #0xf0]
70099398: 7800         	ldrb	r0, [r0]
7009939a: 2869         	cmp	r0, #0x69
7009939c: d00a         	beq	0x700993b4 <_vsnprintf+0x3b4> @ imm = #0x14
7009939e: e7ff         	b	0x700993a0 <_vsnprintf+0x3a0> @ imm = #-0x2
700993a0: 983c         	ldr	r0, [sp, #0xf0]
700993a2: 7800         	ldrb	r0, [r0]
700993a4: 2864         	cmp	r0, #0x64
700993a6: d005         	beq	0x700993b4 <_vsnprintf+0x3b4> @ imm = #0xa
700993a8: e7ff         	b	0x700993aa <_vsnprintf+0x3aa> @ imm = #-0x2
;           flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
700993aa: 983b         	ldr	r0, [sp, #0xec]
700993ac: f020 000c    	bic	r0, r0, #0xc
700993b0: 903b         	str	r0, [sp, #0xec]
;         }
700993b2: e7ff         	b	0x700993b4 <_vsnprintf+0x3b4> @ imm = #-0x2
;         if (flags & FLAGS_PRECISION) {
700993b4: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
700993b8: 0740         	lsls	r0, r0, #0x1d
700993ba: 2800         	cmp	r0, #0x0
700993bc: d505         	bpl	0x700993ca <_vsnprintf+0x3ca> @ imm = #0xa
700993be: e7ff         	b	0x700993c0 <_vsnprintf+0x3c0> @ imm = #-0x2
;           flags &= ~FLAGS_ZEROPAD;
700993c0: 983b         	ldr	r0, [sp, #0xec]
700993c2: f020 0001    	bic	r0, r0, #0x1
700993c6: 903b         	str	r0, [sp, #0xec]
;         }
700993c8: e7ff         	b	0x700993ca <_vsnprintf+0x3ca> @ imm = #-0x2
;         if ((*format == 'i') || (*format == 'd')) {
700993ca: 983c         	ldr	r0, [sp, #0xf0]
700993cc: 7800         	ldrb	r0, [r0]
700993ce: 2869         	cmp	r0, #0x69
700993d0: d006         	beq	0x700993e0 <_vsnprintf+0x3e0> @ imm = #0xc
700993d2: e7ff         	b	0x700993d4 <_vsnprintf+0x3d4> @ imm = #-0x2
700993d4: 983c         	ldr	r0, [sp, #0xf0]
700993d6: 7800         	ldrb	r0, [r0]
700993d8: 2864         	cmp	r0, #0x64
700993da: f040 80e9    	bne.w	0x700995b0 <_vsnprintf+0x5b0> @ imm = #0x1d2
700993de: e7ff         	b	0x700993e0 <_vsnprintf+0x3e0> @ imm = #-0x2
;           if (flags & FLAGS_LONG_LONG) {
700993e0: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
700993e4: 0780         	lsls	r0, r0, #0x1e
700993e6: 2800         	cmp	r0, #0x0
700993e8: d550         	bpl	0x7009948c <_vsnprintf+0x48c> @ imm = #0xa0
700993ea: e7ff         	b	0x700993ec <_vsnprintf+0x3ec> @ imm = #-0x2
;             const long long value = va_arg(va, long long);
700993ec: 9840         	ldr	r0, [sp, #0x100]
700993ee: 3007         	adds	r0, #0x7
700993f0: f020 0107    	bic	r1, r0, #0x7
700993f4: f101 0008    	add.w	r0, r1, #0x8
700993f8: 9040         	str	r0, [sp, #0x100]
700993fa: 6808         	ldr	r0, [r1]
700993fc: 6849         	ldr	r1, [r1, #0x4]
700993fe: 9133         	str	r1, [sp, #0xcc]
70099400: 9032         	str	r0, [sp, #0xc8]
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
70099402: 983f         	ldr	r0, [sp, #0xfc]
70099404: 9023         	str	r0, [sp, #0x8c]
70099406: 983e         	ldr	r0, [sp, #0xf8]
70099408: 9024         	str	r0, [sp, #0x90]
7009940a: 9837         	ldr	r0, [sp, #0xdc]
7009940c: 9025         	str	r0, [sp, #0x94]
7009940e: 983d         	ldr	r0, [sp, #0xf4]
70099410: 9026         	str	r0, [sp, #0x98]
70099412: 9932         	ldr	r1, [sp, #0xc8]
70099414: 9833         	ldr	r0, [sp, #0xcc]
70099416: 3901         	subs	r1, #0x1
70099418: f170 0000    	sbcs	r0, r0, #0x0
7009941c: db05         	blt	0x7009942a <_vsnprintf+0x42a> @ imm = #0xa
7009941e: e7ff         	b	0x70099420 <_vsnprintf+0x420> @ imm = #-0x2
70099420: 9932         	ldr	r1, [sp, #0xc8]
70099422: 9833         	ldr	r0, [sp, #0xcc]
70099424: 9121         	str	r1, [sp, #0x84]
70099426: 9022         	str	r0, [sp, #0x88]
70099428: e008         	b	0x7009943c <_vsnprintf+0x43c> @ imm = #0x10
7009942a: 9832         	ldr	r0, [sp, #0xc8]
7009942c: 9a33         	ldr	r2, [sp, #0xcc]
7009942e: 4241         	rsbs	r1, r0, #0
70099430: f04f 0000    	mov.w	r0, #0x0
70099434: 4190         	sbcs	r0, r2
70099436: 9121         	str	r1, [sp, #0x84]
70099438: 9022         	str	r0, [sp, #0x88]
7009943a: e7ff         	b	0x7009943c <_vsnprintf+0x43c> @ imm = #-0x2
7009943c: 9b26         	ldr	r3, [sp, #0x98]
7009943e: 9a25         	ldr	r2, [sp, #0x94]
70099440: 9924         	ldr	r1, [sp, #0x90]
70099442: 9823         	ldr	r0, [sp, #0x8c]
70099444: f8dd c084    	ldr.w	r12, [sp, #0x84]
70099448: 9c22         	ldr	r4, [sp, #0x88]
7009944a: 9d33         	ldr	r5, [sp, #0xcc]
7009944c: 9e34         	ldr	r6, [sp, #0xd0]
7009944e: 9f39         	ldr	r7, [sp, #0xe4]
70099450: f8dd 80e8    	ldr.w	r8, [sp, #0xe8]
70099454: f8dd 90ec    	ldr.w	r9, [sp, #0xec]
70099458: 46ee         	mov	lr, sp
7009945a: f8cd e080    	str.w	lr, [sp, #0x80]
7009945e: f8ce 9020    	str.w	r9, [lr, #0x20]
70099462: f8ce 801c    	str.w	r8, [lr, #0x1c]
70099466: f8ce 7018    	str.w	r7, [lr, #0x18]
7009946a: 2700         	movs	r7, #0x0
7009946c: f8ce 7014    	str.w	r7, [lr, #0x14]
70099470: f8ce 6010    	str.w	r6, [lr, #0x10]
70099474: ea4f 75d5    	lsr.w	r5, r5, #0x1f
70099478: f8ce 5008    	str.w	r5, [lr, #0x8]
7009947c: f8ce 4004    	str.w	r4, [lr, #0x4]
70099480: f8ce c000    	str.w	r12, [lr]
70099484: f007 fd34    	bl	0x700a0ef0 <_ntoa_long_long> @ imm = #0x7a68
70099488: 9037         	str	r0, [sp, #0xdc]
;           }
7009948a: e090         	b	0x700995ae <_vsnprintf+0x5ae> @ imm = #0x120
;           else if (flags & FLAGS_LONG) {
7009948c: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
70099490: 07c0         	lsls	r0, r0, #0x1f
70099492: b3b0         	cbz	r0, 0x70099502 <_vsnprintf+0x502> @ imm = #0x6c
70099494: e7ff         	b	0x70099496 <_vsnprintf+0x496> @ imm = #-0x2
;             const long value = va_arg(va, long);
70099496: 9840         	ldr	r0, [sp, #0x100]
70099498: 1d01         	adds	r1, r0, #0x4
7009949a: 9140         	str	r1, [sp, #0x100]
7009949c: 6800         	ldr	r0, [r0]
7009949e: 9031         	str	r0, [sp, #0xc4]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
700994a0: 983f         	ldr	r0, [sp, #0xfc]
700994a2: 901c         	str	r0, [sp, #0x70]
700994a4: 983e         	ldr	r0, [sp, #0xf8]
700994a6: 901d         	str	r0, [sp, #0x74]
700994a8: 9837         	ldr	r0, [sp, #0xdc]
700994aa: 901e         	str	r0, [sp, #0x78]
700994ac: 983d         	ldr	r0, [sp, #0xf4]
700994ae: 901f         	str	r0, [sp, #0x7c]
700994b0: 9831         	ldr	r0, [sp, #0xc4]
700994b2: 2801         	cmp	r0, #0x1
700994b4: db03         	blt	0x700994be <_vsnprintf+0x4be> @ imm = #0x6
700994b6: e7ff         	b	0x700994b8 <_vsnprintf+0x4b8> @ imm = #-0x2
700994b8: 9831         	ldr	r0, [sp, #0xc4]
700994ba: 901b         	str	r0, [sp, #0x6c]
700994bc: e003         	b	0x700994c6 <_vsnprintf+0x4c6> @ imm = #0x6
700994be: 9831         	ldr	r0, [sp, #0xc4]
700994c0: 4240         	rsbs	r0, r0, #0
700994c2: 901b         	str	r0, [sp, #0x6c]
700994c4: e7ff         	b	0x700994c6 <_vsnprintf+0x4c6> @ imm = #-0x2
700994c6: 9b1f         	ldr	r3, [sp, #0x7c]
700994c8: 9a1e         	ldr	r2, [sp, #0x78]
700994ca: 991d         	ldr	r1, [sp, #0x74]
700994cc: 981c         	ldr	r0, [sp, #0x70]
700994ce: f8dd c06c    	ldr.w	r12, [sp, #0x6c]
700994d2: 9c31         	ldr	r4, [sp, #0xc4]
700994d4: 9d34         	ldr	r5, [sp, #0xd0]
700994d6: 9e39         	ldr	r6, [sp, #0xe4]
700994d8: 9f3a         	ldr	r7, [sp, #0xe8]
700994da: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
700994de: 46ee         	mov	lr, sp
700994e0: f8ce 8014    	str.w	r8, [lr, #0x14]
700994e4: f8ce 7010    	str.w	r7, [lr, #0x10]
700994e8: f8ce 600c    	str.w	r6, [lr, #0xc]
700994ec: f8ce 5008    	str.w	r5, [lr, #0x8]
700994f0: 0fe4         	lsrs	r4, r4, #0x1f
700994f2: f8ce 4004    	str.w	r4, [lr, #0x4]
700994f6: f8ce c000    	str.w	r12, [lr]
700994fa: f009 fdf1    	bl	0x700a30e0 <_ntoa_long> @ imm = #0x9be2
700994fe: 9037         	str	r0, [sp, #0xdc]
;           }
70099500: e054         	b	0x700995ac <_vsnprintf+0x5ac> @ imm = #0xa8
;             const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
70099502: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
70099506: 0640         	lsls	r0, r0, #0x19
70099508: 2800         	cmp	r0, #0x0
7009950a: d506         	bpl	0x7009951a <_vsnprintf+0x51a> @ imm = #0xc
7009950c: e7ff         	b	0x7009950e <_vsnprintf+0x50e> @ imm = #-0x2
7009950e: 9840         	ldr	r0, [sp, #0x100]
70099510: 1d01         	adds	r1, r0, #0x4
70099512: 9140         	str	r1, [sp, #0x100]
70099514: 7800         	ldrb	r0, [r0]
70099516: 901a         	str	r0, [sp, #0x68]
70099518: e015         	b	0x70099546 <_vsnprintf+0x546> @ imm = #0x2a
7009951a: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009951e: 0600         	lsls	r0, r0, #0x18
70099520: 2800         	cmp	r0, #0x0
70099522: d507         	bpl	0x70099534 <_vsnprintf+0x534> @ imm = #0xe
70099524: e7ff         	b	0x70099526 <_vsnprintf+0x526> @ imm = #-0x2
70099526: 9840         	ldr	r0, [sp, #0x100]
70099528: 1d01         	adds	r1, r0, #0x4
7009952a: 9140         	str	r1, [sp, #0x100]
7009952c: f9b0 0000    	ldrsh.w	r0, [r0]
70099530: 9019         	str	r0, [sp, #0x64]
70099532: e005         	b	0x70099540 <_vsnprintf+0x540> @ imm = #0xa
70099534: 9840         	ldr	r0, [sp, #0x100]
70099536: 1d01         	adds	r1, r0, #0x4
70099538: 9140         	str	r1, [sp, #0x100]
7009953a: 6800         	ldr	r0, [r0]
7009953c: 9019         	str	r0, [sp, #0x64]
7009953e: e7ff         	b	0x70099540 <_vsnprintf+0x540> @ imm = #-0x2
70099540: 9819         	ldr	r0, [sp, #0x64]
70099542: 901a         	str	r0, [sp, #0x68]
70099544: e7ff         	b	0x70099546 <_vsnprintf+0x546> @ imm = #-0x2
70099546: 981a         	ldr	r0, [sp, #0x68]
70099548: 9030         	str	r0, [sp, #0xc0]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009954a: 983f         	ldr	r0, [sp, #0xfc]
7009954c: 9015         	str	r0, [sp, #0x54]
7009954e: 983e         	ldr	r0, [sp, #0xf8]
70099550: 9016         	str	r0, [sp, #0x58]
70099552: 9837         	ldr	r0, [sp, #0xdc]
70099554: 9017         	str	r0, [sp, #0x5c]
70099556: 983d         	ldr	r0, [sp, #0xf4]
70099558: 9018         	str	r0, [sp, #0x60]
7009955a: 9830         	ldr	r0, [sp, #0xc0]
7009955c: 2801         	cmp	r0, #0x1
7009955e: db03         	blt	0x70099568 <_vsnprintf+0x568> @ imm = #0x6
70099560: e7ff         	b	0x70099562 <_vsnprintf+0x562> @ imm = #-0x2
70099562: 9830         	ldr	r0, [sp, #0xc0]
70099564: 9014         	str	r0, [sp, #0x50]
70099566: e003         	b	0x70099570 <_vsnprintf+0x570> @ imm = #0x6
70099568: 9830         	ldr	r0, [sp, #0xc0]
7009956a: 4240         	rsbs	r0, r0, #0
7009956c: 9014         	str	r0, [sp, #0x50]
7009956e: e7ff         	b	0x70099570 <_vsnprintf+0x570> @ imm = #-0x2
70099570: 9b18         	ldr	r3, [sp, #0x60]
70099572: 9a17         	ldr	r2, [sp, #0x5c]
70099574: 9916         	ldr	r1, [sp, #0x58]
70099576: 9815         	ldr	r0, [sp, #0x54]
70099578: f8dd c050    	ldr.w	r12, [sp, #0x50]
7009957c: 9c30         	ldr	r4, [sp, #0xc0]
7009957e: 9d34         	ldr	r5, [sp, #0xd0]
70099580: 9e39         	ldr	r6, [sp, #0xe4]
70099582: 9f3a         	ldr	r7, [sp, #0xe8]
70099584: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
70099588: 46ee         	mov	lr, sp
7009958a: f8ce 8014    	str.w	r8, [lr, #0x14]
7009958e: f8ce 7010    	str.w	r7, [lr, #0x10]
70099592: f8ce 600c    	str.w	r6, [lr, #0xc]
70099596: f8ce 5008    	str.w	r5, [lr, #0x8]
7009959a: 0fe4         	lsrs	r4, r4, #0x1f
7009959c: f8ce 4004    	str.w	r4, [lr, #0x4]
700995a0: f8ce c000    	str.w	r12, [lr]
700995a4: f009 fd9c    	bl	0x700a30e0 <_ntoa_long> @ imm = #0x9b38
700995a8: 9037         	str	r0, [sp, #0xdc]
700995aa: e7ff         	b	0x700995ac <_vsnprintf+0x5ac> @ imm = #-0x2
700995ac: e7ff         	b	0x700995ae <_vsnprintf+0x5ae> @ imm = #-0x2
;         }
700995ae: e09c         	b	0x700996ea <_vsnprintf+0x6ea> @ imm = #0x138
;           if (flags & FLAGS_LONG_LONG) {
700995b0: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
700995b4: 0780         	lsls	r0, r0, #0x1e
700995b6: 2800         	cmp	r0, #0x0
700995b8: d52f         	bpl	0x7009961a <_vsnprintf+0x61a> @ imm = #0x5e
700995ba: e7ff         	b	0x700995bc <_vsnprintf+0x5bc> @ imm = #-0x2
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
700995bc: 983f         	ldr	r0, [sp, #0xfc]
700995be: 993e         	ldr	r1, [sp, #0xf8]
700995c0: 9a37         	ldr	r2, [sp, #0xdc]
700995c2: 9b3d         	ldr	r3, [sp, #0xf4]
700995c4: f8dd c100    	ldr.w	r12, [sp, #0x100]
700995c8: f10c 0c07    	add.w	r12, r12, #0x7
700995cc: f02c 0e07    	bic	lr, r12, #0x7
700995d0: f10e 0c08    	add.w	r12, lr, #0x8
700995d4: f8cd c100    	str.w	r12, [sp, #0x100]
700995d8: f8de c000    	ldr.w	r12, [lr]
700995dc: f8de 4004    	ldr.w	r4, [lr, #0x4]
700995e0: 9e34         	ldr	r6, [sp, #0xd0]
700995e2: 9d39         	ldr	r5, [sp, #0xe4]
700995e4: 9f3a         	ldr	r7, [sp, #0xe8]
700995e6: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
700995ea: 46ee         	mov	lr, sp
700995ec: f8cd e04c    	str.w	lr, [sp, #0x4c]
700995f0: f8ce 8020    	str.w	r8, [lr, #0x20]
700995f4: f8ce 701c    	str.w	r7, [lr, #0x1c]
700995f8: f8ce 5018    	str.w	r5, [lr, #0x18]
700995fc: 2500         	movs	r5, #0x0
700995fe: f8ce 5014    	str.w	r5, [lr, #0x14]
70099602: f8ce 6010    	str.w	r6, [lr, #0x10]
70099606: f8ce 5008    	str.w	r5, [lr, #0x8]
7009960a: f8ce 4004    	str.w	r4, [lr, #0x4]
7009960e: f8ce c000    	str.w	r12, [lr]
70099612: f007 fc6d    	bl	0x700a0ef0 <_ntoa_long_long> @ imm = #0x78da
70099616: 9037         	str	r0, [sp, #0xdc]
;           }
70099618: e066         	b	0x700996e8 <_vsnprintf+0x6e8> @ imm = #0xcc
;           else if (flags & FLAGS_LONG) {
7009961a: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009961e: 07c0         	lsls	r0, r0, #0x1f
70099620: b310         	cbz	r0, 0x70099668 <_vsnprintf+0x668> @ imm = #0x44
70099622: e7ff         	b	0x70099624 <_vsnprintf+0x624> @ imm = #-0x2
;             idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
70099624: 983f         	ldr	r0, [sp, #0xfc]
70099626: 993e         	ldr	r1, [sp, #0xf8]
70099628: 9a37         	ldr	r2, [sp, #0xdc]
7009962a: 9b3d         	ldr	r3, [sp, #0xf4]
7009962c: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099630: f10c 0e04    	add.w	lr, r12, #0x4
70099634: f8cd e100    	str.w	lr, [sp, #0x100]
70099638: f8dc c000    	ldr.w	r12, [r12]
7009963c: 9c34         	ldr	r4, [sp, #0xd0]
7009963e: 9d39         	ldr	r5, [sp, #0xe4]
70099640: 9e3a         	ldr	r6, [sp, #0xe8]
70099642: 9f3b         	ldr	r7, [sp, #0xec]
70099644: 46ee         	mov	lr, sp
70099646: f8ce 7014    	str.w	r7, [lr, #0x14]
7009964a: f8ce 6010    	str.w	r6, [lr, #0x10]
7009964e: f8ce 500c    	str.w	r5, [lr, #0xc]
70099652: f8ce 4008    	str.w	r4, [lr, #0x8]
70099656: 2400         	movs	r4, #0x0
70099658: f8ce 4004    	str.w	r4, [lr, #0x4]
7009965c: f8ce c000    	str.w	r12, [lr]
70099660: f009 fd3e    	bl	0x700a30e0 <_ntoa_long> @ imm = #0x9a7c
70099664: 9037         	str	r0, [sp, #0xdc]
;           }
70099666: e03e         	b	0x700996e6 <_vsnprintf+0x6e6> @ imm = #0x7c
;             const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
70099668: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009966c: 0640         	lsls	r0, r0, #0x19
7009966e: 2800         	cmp	r0, #0x0
70099670: d506         	bpl	0x70099680 <_vsnprintf+0x680> @ imm = #0xc
70099672: e7ff         	b	0x70099674 <_vsnprintf+0x674> @ imm = #-0x2
70099674: 9840         	ldr	r0, [sp, #0x100]
70099676: 1d01         	adds	r1, r0, #0x4
70099678: 9140         	str	r1, [sp, #0x100]
7009967a: 7800         	ldrb	r0, [r0]
7009967c: 9012         	str	r0, [sp, #0x48]
7009967e: e014         	b	0x700996aa <_vsnprintf+0x6aa> @ imm = #0x28
70099680: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
70099684: 0600         	lsls	r0, r0, #0x18
70099686: 2800         	cmp	r0, #0x0
70099688: d506         	bpl	0x70099698 <_vsnprintf+0x698> @ imm = #0xc
7009968a: e7ff         	b	0x7009968c <_vsnprintf+0x68c> @ imm = #-0x2
7009968c: 9840         	ldr	r0, [sp, #0x100]
7009968e: 1d01         	adds	r1, r0, #0x4
70099690: 9140         	str	r1, [sp, #0x100]
70099692: 8800         	ldrh	r0, [r0]
70099694: 9011         	str	r0, [sp, #0x44]
70099696: e005         	b	0x700996a4 <_vsnprintf+0x6a4> @ imm = #0xa
70099698: 9840         	ldr	r0, [sp, #0x100]
7009969a: 1d01         	adds	r1, r0, #0x4
7009969c: 9140         	str	r1, [sp, #0x100]
7009969e: 6800         	ldr	r0, [r0]
700996a0: 9011         	str	r0, [sp, #0x44]
700996a2: e7ff         	b	0x700996a4 <_vsnprintf+0x6a4> @ imm = #-0x2
700996a4: 9811         	ldr	r0, [sp, #0x44]
700996a6: 9012         	str	r0, [sp, #0x48]
700996a8: e7ff         	b	0x700996aa <_vsnprintf+0x6aa> @ imm = #-0x2
700996aa: 9812         	ldr	r0, [sp, #0x48]
700996ac: 902f         	str	r0, [sp, #0xbc]
;             idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
700996ae: 983f         	ldr	r0, [sp, #0xfc]
700996b0: 993e         	ldr	r1, [sp, #0xf8]
700996b2: 9a37         	ldr	r2, [sp, #0xdc]
700996b4: 9b3d         	ldr	r3, [sp, #0xf4]
700996b6: f8dd c0bc    	ldr.w	r12, [sp, #0xbc]
700996ba: 9c34         	ldr	r4, [sp, #0xd0]
700996bc: 9d39         	ldr	r5, [sp, #0xe4]
700996be: 9e3a         	ldr	r6, [sp, #0xe8]
700996c0: 9f3b         	ldr	r7, [sp, #0xec]
700996c2: 46ee         	mov	lr, sp
700996c4: f8ce 7014    	str.w	r7, [lr, #0x14]
700996c8: f8ce 6010    	str.w	r6, [lr, #0x10]
700996cc: f8ce 500c    	str.w	r5, [lr, #0xc]
700996d0: f8ce 4008    	str.w	r4, [lr, #0x8]
700996d4: 2400         	movs	r4, #0x0
700996d6: f8ce 4004    	str.w	r4, [lr, #0x4]
700996da: f8ce c000    	str.w	r12, [lr]
700996de: f009 fcff    	bl	0x700a30e0 <_ntoa_long> @ imm = #0x99fe
700996e2: 9037         	str	r0, [sp, #0xdc]
700996e4: e7ff         	b	0x700996e6 <_vsnprintf+0x6e6> @ imm = #-0x2
700996e6: e7ff         	b	0x700996e8 <_vsnprintf+0x6e8> @ imm = #-0x2
700996e8: e7ff         	b	0x700996ea <_vsnprintf+0x6ea> @ imm = #-0x2
;         format++;
700996ea: 983c         	ldr	r0, [sp, #0xf0]
700996ec: 3001         	adds	r0, #0x1
700996ee: 903c         	str	r0, [sp, #0xf0]
;         break;
700996f0: e183         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x306
;         if (*format == 'F') flags |= FLAGS_UPPERCASE;
700996f2: 983c         	ldr	r0, [sp, #0xf0]
700996f4: 7800         	ldrb	r0, [r0]
700996f6: 2846         	cmp	r0, #0x46
700996f8: d105         	bne	0x70099706 <_vsnprintf+0x706> @ imm = #0xa
700996fa: e7ff         	b	0x700996fc <_vsnprintf+0x6fc> @ imm = #-0x2
700996fc: 983b         	ldr	r0, [sp, #0xec]
700996fe: f040 0020    	orr	r0, r0, #0x20
70099702: 903b         	str	r0, [sp, #0xec]
70099704: e7ff         	b	0x70099706 <_vsnprintf+0x706> @ imm = #-0x2
;         idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
70099706: 983f         	ldr	r0, [sp, #0xfc]
70099708: 993e         	ldr	r1, [sp, #0xf8]
7009970a: 9a37         	ldr	r2, [sp, #0xdc]
7009970c: 9b3d         	ldr	r3, [sp, #0xf4]
7009970e: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099712: f10c 0c07    	add.w	r12, r12, #0x7
70099716: f02c 0c07    	bic	r12, r12, #0x7
7009971a: f10c 0e08    	add.w	lr, r12, #0x8
7009971e: f8cd e100    	str.w	lr, [sp, #0x100]
70099722: ed9c 0b00    	vldr	d0, [r12]
70099726: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
7009972a: 9c3a         	ldr	r4, [sp, #0xe8]
7009972c: 9d3b         	ldr	r5, [sp, #0xec]
7009972e: 46ee         	mov	lr, sp
70099730: f8ce 5008    	str.w	r5, [lr, #0x8]
70099734: f8ce 4004    	str.w	r4, [lr, #0x4]
70099738: f8ce c000    	str.w	r12, [lr]
7009973c: f000 fc80    	bl	0x7009a040 <_ftoa>      @ imm = #0x900
70099740: 9037         	str	r0, [sp, #0xdc]
;         format++;
70099742: 983c         	ldr	r0, [sp, #0xf0]
70099744: 3001         	adds	r0, #0x1
70099746: 903c         	str	r0, [sp, #0xf0]
;         break;
70099748: e157         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x2ae
;         if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
7009974a: 983c         	ldr	r0, [sp, #0xf0]
7009974c: 7800         	ldrb	r0, [r0]
7009974e: 2867         	cmp	r0, #0x67
70099750: d005         	beq	0x7009975e <_vsnprintf+0x75e> @ imm = #0xa
70099752: e7ff         	b	0x70099754 <_vsnprintf+0x754> @ imm = #-0x2
70099754: 983c         	ldr	r0, [sp, #0xf0]
70099756: 7800         	ldrb	r0, [r0]
70099758: 2847         	cmp	r0, #0x47
7009975a: d105         	bne	0x70099768 <_vsnprintf+0x768> @ imm = #0xa
7009975c: e7ff         	b	0x7009975e <_vsnprintf+0x75e> @ imm = #-0x2
7009975e: 983b         	ldr	r0, [sp, #0xec]
70099760: f440 6000    	orr	r0, r0, #0x800
70099764: 903b         	str	r0, [sp, #0xec]
70099766: e7ff         	b	0x70099768 <_vsnprintf+0x768> @ imm = #-0x2
;         if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
70099768: 983c         	ldr	r0, [sp, #0xf0]
7009976a: 7800         	ldrb	r0, [r0]
7009976c: 2845         	cmp	r0, #0x45
7009976e: d005         	beq	0x7009977c <_vsnprintf+0x77c> @ imm = #0xa
70099770: e7ff         	b	0x70099772 <_vsnprintf+0x772> @ imm = #-0x2
70099772: 983c         	ldr	r0, [sp, #0xf0]
70099774: 7800         	ldrb	r0, [r0]
70099776: 2847         	cmp	r0, #0x47
70099778: d105         	bne	0x70099786 <_vsnprintf+0x786> @ imm = #0xa
7009977a: e7ff         	b	0x7009977c <_vsnprintf+0x77c> @ imm = #-0x2
7009977c: 983b         	ldr	r0, [sp, #0xec]
7009977e: f040 0020    	orr	r0, r0, #0x20
70099782: 903b         	str	r0, [sp, #0xec]
70099784: e7ff         	b	0x70099786 <_vsnprintf+0x786> @ imm = #-0x2
;         idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
70099786: 983f         	ldr	r0, [sp, #0xfc]
70099788: 993e         	ldr	r1, [sp, #0xf8]
7009978a: 9a37         	ldr	r2, [sp, #0xdc]
7009978c: 9b3d         	ldr	r3, [sp, #0xf4]
7009978e: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099792: f10c 0c07    	add.w	r12, r12, #0x7
70099796: f02c 0c07    	bic	r12, r12, #0x7
7009979a: f10c 0e08    	add.w	lr, r12, #0x8
7009979e: f8cd e100    	str.w	lr, [sp, #0x100]
700997a2: ed9c 0b00    	vldr	d0, [r12]
700997a6: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
700997aa: 9c3a         	ldr	r4, [sp, #0xe8]
700997ac: 9d3b         	ldr	r5, [sp, #0xec]
700997ae: 46ee         	mov	lr, sp
700997b0: f8ce 5008    	str.w	r5, [lr, #0x8]
700997b4: f8ce 4004    	str.w	r4, [lr, #0x4]
700997b8: f8ce c000    	str.w	r12, [lr]
700997bc: f000 fed0    	bl	0x7009a560 <_etoa>      @ imm = #0xda0
700997c0: 9037         	str	r0, [sp, #0xdc]
;         format++;
700997c2: 983c         	ldr	r0, [sp, #0xf0]
700997c4: 3001         	adds	r0, #0x1
700997c6: 903c         	str	r0, [sp, #0xf0]
;         break;
700997c8: e117         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x22e
700997ca: 2001         	movs	r0, #0x1
;         unsigned int l = 1U;
700997cc: 902e         	str	r0, [sp, #0xb8]
;         if (!(flags & FLAGS_LEFT)) {
700997ce: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
700997d2: 0780         	lsls	r0, r0, #0x1e
700997d4: 2800         	cmp	r0, #0x0
700997d6: d413         	bmi	0x70099800 <_vsnprintf+0x800> @ imm = #0x26
700997d8: e7ff         	b	0x700997da <_vsnprintf+0x7da> @ imm = #-0x2
;           while (l++ < width) {
700997da: e7ff         	b	0x700997dc <_vsnprintf+0x7dc> @ imm = #-0x2
700997dc: 982e         	ldr	r0, [sp, #0xb8]
700997de: 1c41         	adds	r1, r0, #0x1
700997e0: 912e         	str	r1, [sp, #0xb8]
700997e2: 993a         	ldr	r1, [sp, #0xe8]
700997e4: 4288         	cmp	r0, r1
700997e6: d20a         	bhs	0x700997fe <_vsnprintf+0x7fe> @ imm = #0x14
700997e8: e7ff         	b	0x700997ea <_vsnprintf+0x7ea> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
700997ea: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700997ee: 993e         	ldr	r1, [sp, #0xf8]
700997f0: 9a37         	ldr	r2, [sp, #0xdc]
700997f2: 1c50         	adds	r0, r2, #0x1
700997f4: 9037         	str	r0, [sp, #0xdc]
700997f6: 9b3d         	ldr	r3, [sp, #0xf4]
700997f8: 2020         	movs	r0, #0x20
700997fa: 47e0         	blx	r12
;           while (l++ < width) {
700997fc: e7ee         	b	0x700997dc <_vsnprintf+0x7dc> @ imm = #-0x24
;         }
700997fe: e7ff         	b	0x70099800 <_vsnprintf+0x800> @ imm = #-0x2
;         out((char)va_arg(va, int), buffer, idx++, maxlen);
70099800: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099804: 9840         	ldr	r0, [sp, #0x100]
70099806: 1d01         	adds	r1, r0, #0x4
70099808: 9140         	str	r1, [sp, #0x100]
7009980a: 7800         	ldrb	r0, [r0]
7009980c: 993e         	ldr	r1, [sp, #0xf8]
7009980e: 9a37         	ldr	r2, [sp, #0xdc]
70099810: 1c53         	adds	r3, r2, #0x1
70099812: 9337         	str	r3, [sp, #0xdc]
70099814: 9b3d         	ldr	r3, [sp, #0xf4]
70099816: 47e0         	blx	r12
;         if (flags & FLAGS_LEFT) {
70099818: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009981c: 0780         	lsls	r0, r0, #0x1e
7009981e: 2800         	cmp	r0, #0x0
70099820: d513         	bpl	0x7009984a <_vsnprintf+0x84a> @ imm = #0x26
70099822: e7ff         	b	0x70099824 <_vsnprintf+0x824> @ imm = #-0x2
;           while (l++ < width) {
70099824: e7ff         	b	0x70099826 <_vsnprintf+0x826> @ imm = #-0x2
70099826: 982e         	ldr	r0, [sp, #0xb8]
70099828: 1c41         	adds	r1, r0, #0x1
7009982a: 912e         	str	r1, [sp, #0xb8]
7009982c: 993a         	ldr	r1, [sp, #0xe8]
7009982e: 4288         	cmp	r0, r1
70099830: d20a         	bhs	0x70099848 <_vsnprintf+0x848> @ imm = #0x14
70099832: e7ff         	b	0x70099834 <_vsnprintf+0x834> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
70099834: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099838: 993e         	ldr	r1, [sp, #0xf8]
7009983a: 9a37         	ldr	r2, [sp, #0xdc]
7009983c: 1c50         	adds	r0, r2, #0x1
7009983e: 9037         	str	r0, [sp, #0xdc]
70099840: 9b3d         	ldr	r3, [sp, #0xf4]
70099842: 2020         	movs	r0, #0x20
70099844: 47e0         	blx	r12
;           while (l++ < width) {
70099846: e7ee         	b	0x70099826 <_vsnprintf+0x826> @ imm = #-0x24
;         }
70099848: e7ff         	b	0x7009984a <_vsnprintf+0x84a> @ imm = #-0x2
;         format++;
7009984a: 983c         	ldr	r0, [sp, #0xf0]
7009984c: 3001         	adds	r0, #0x1
7009984e: 903c         	str	r0, [sp, #0xf0]
;         break;
70099850: e0d3         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x1a6
;         const char* p = va_arg(va, char*);
70099852: 9840         	ldr	r0, [sp, #0x100]
70099854: 1d01         	adds	r1, r0, #0x4
70099856: 9140         	str	r1, [sp, #0x100]
70099858: 6800         	ldr	r0, [r0]
7009985a: 902d         	str	r0, [sp, #0xb4]
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
7009985c: 982d         	ldr	r0, [sp, #0xb4]
7009985e: 9010         	str	r0, [sp, #0x40]
70099860: 9839         	ldr	r0, [sp, #0xe4]
70099862: b118         	cbz	r0, 0x7009986c <_vsnprintf+0x86c> @ imm = #0x6
70099864: e7ff         	b	0x70099866 <_vsnprintf+0x866> @ imm = #-0x2
70099866: 9839         	ldr	r0, [sp, #0xe4]
70099868: 900f         	str	r0, [sp, #0x3c]
7009986a: e003         	b	0x70099874 <_vsnprintf+0x874> @ imm = #0x6
7009986c: f04f 30ff    	mov.w	r0, #0xffffffff
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
70099870: 900f         	str	r0, [sp, #0x3c]
70099872: e7ff         	b	0x70099874 <_vsnprintf+0x874> @ imm = #-0x2
70099874: 9810         	ldr	r0, [sp, #0x40]
70099876: 990f         	ldr	r1, [sp, #0x3c]
70099878: f011 ff0a    	bl	0x700ab690 <_strnlen_s> @ imm = #0x11e14
7009987c: 902c         	str	r0, [sp, #0xb0]
;         if (flags & FLAGS_PRECISION) {
7009987e: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
70099882: 0740         	lsls	r0, r0, #0x1d
70099884: 2800         	cmp	r0, #0x0
70099886: d50e         	bpl	0x700998a6 <_vsnprintf+0x8a6> @ imm = #0x1c
70099888: e7ff         	b	0x7009988a <_vsnprintf+0x88a> @ imm = #-0x2
;           l = (l < precision ? l : precision);
7009988a: 982c         	ldr	r0, [sp, #0xb0]
7009988c: 9939         	ldr	r1, [sp, #0xe4]
7009988e: 4288         	cmp	r0, r1
70099890: d203         	bhs	0x7009989a <_vsnprintf+0x89a> @ imm = #0x6
70099892: e7ff         	b	0x70099894 <_vsnprintf+0x894> @ imm = #-0x2
70099894: 982c         	ldr	r0, [sp, #0xb0]
70099896: 900e         	str	r0, [sp, #0x38]
70099898: e002         	b	0x700998a0 <_vsnprintf+0x8a0> @ imm = #0x4
7009989a: 9839         	ldr	r0, [sp, #0xe4]
7009989c: 900e         	str	r0, [sp, #0x38]
7009989e: e7ff         	b	0x700998a0 <_vsnprintf+0x8a0> @ imm = #-0x2
700998a0: 980e         	ldr	r0, [sp, #0x38]
700998a2: 902c         	str	r0, [sp, #0xb0]
;         }
700998a4: e7ff         	b	0x700998a6 <_vsnprintf+0x8a6> @ imm = #-0x2
;         if (!(flags & FLAGS_LEFT)) {
700998a6: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
700998aa: 0780         	lsls	r0, r0, #0x1e
700998ac: 2800         	cmp	r0, #0x0
700998ae: d413         	bmi	0x700998d8 <_vsnprintf+0x8d8> @ imm = #0x26
700998b0: e7ff         	b	0x700998b2 <_vsnprintf+0x8b2> @ imm = #-0x2
;           while (l++ < width) {
700998b2: e7ff         	b	0x700998b4 <_vsnprintf+0x8b4> @ imm = #-0x2
700998b4: 982c         	ldr	r0, [sp, #0xb0]
700998b6: 1c41         	adds	r1, r0, #0x1
700998b8: 912c         	str	r1, [sp, #0xb0]
700998ba: 993a         	ldr	r1, [sp, #0xe8]
700998bc: 4288         	cmp	r0, r1
700998be: d20a         	bhs	0x700998d6 <_vsnprintf+0x8d6> @ imm = #0x14
700998c0: e7ff         	b	0x700998c2 <_vsnprintf+0x8c2> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
700998c2: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700998c6: 993e         	ldr	r1, [sp, #0xf8]
700998c8: 9a37         	ldr	r2, [sp, #0xdc]
700998ca: 1c50         	adds	r0, r2, #0x1
700998cc: 9037         	str	r0, [sp, #0xdc]
700998ce: 9b3d         	ldr	r3, [sp, #0xf4]
700998d0: 2020         	movs	r0, #0x20
700998d2: 47e0         	blx	r12
;           while (l++ < width) {
700998d4: e7ee         	b	0x700998b4 <_vsnprintf+0x8b4> @ imm = #-0x24
;         }
700998d6: e7ff         	b	0x700998d8 <_vsnprintf+0x8d8> @ imm = #-0x2
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
700998d8: e7ff         	b	0x700998da <_vsnprintf+0x8da> @ imm = #-0x2
700998da: 982d         	ldr	r0, [sp, #0xb4]
700998dc: 7801         	ldrb	r1, [r0]
700998de: 2000         	movs	r0, #0x0
700998e0: 900d         	str	r0, [sp, #0x34]
700998e2: b1a1         	cbz	r1, 0x7009990e <_vsnprintf+0x90e> @ imm = #0x28
700998e4: e7ff         	b	0x700998e6 <_vsnprintf+0x8e6> @ imm = #-0x2
700998e6: 2001         	movs	r0, #0x1
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
700998e8: f89d 10ed    	ldrb.w	r1, [sp, #0xed]
700998ec: ea4f 7141    	lsl.w	r1, r1, #0x1d
700998f0: 2900         	cmp	r1, #0x0
700998f2: 900c         	str	r0, [sp, #0x30]
700998f4: d508         	bpl	0x70099908 <_vsnprintf+0x908> @ imm = #0x10
700998f6: e7ff         	b	0x700998f8 <_vsnprintf+0x8f8> @ imm = #-0x2
700998f8: 9839         	ldr	r0, [sp, #0xe4]
700998fa: 1e41         	subs	r1, r0, #0x1
700998fc: 9139         	str	r1, [sp, #0xe4]
700998fe: 2800         	cmp	r0, #0x0
70099900: bf18         	it	ne
70099902: 2001         	movne	r0, #0x1
70099904: 900c         	str	r0, [sp, #0x30]
70099906: e7ff         	b	0x70099908 <_vsnprintf+0x908> @ imm = #-0x2
70099908: 980c         	ldr	r0, [sp, #0x30]
7009990a: 900d         	str	r0, [sp, #0x34]
7009990c: e7ff         	b	0x7009990e <_vsnprintf+0x90e> @ imm = #-0x2
7009990e: 980d         	ldr	r0, [sp, #0x34]
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
70099910: 07c0         	lsls	r0, r0, #0x1f
70099912: b168         	cbz	r0, 0x70099930 <_vsnprintf+0x930> @ imm = #0x1a
70099914: e7ff         	b	0x70099916 <_vsnprintf+0x916> @ imm = #-0x2
;           out(*(p++), buffer, idx++, maxlen);
70099916: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009991a: 982d         	ldr	r0, [sp, #0xb4]
7009991c: 1c41         	adds	r1, r0, #0x1
7009991e: 912d         	str	r1, [sp, #0xb4]
70099920: 7800         	ldrb	r0, [r0]
70099922: 993e         	ldr	r1, [sp, #0xf8]
70099924: 9a37         	ldr	r2, [sp, #0xdc]
70099926: 1c53         	adds	r3, r2, #0x1
70099928: 9337         	str	r3, [sp, #0xdc]
7009992a: 9b3d         	ldr	r3, [sp, #0xf4]
7009992c: 47e0         	blx	r12
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009992e: e7d4         	b	0x700998da <_vsnprintf+0x8da> @ imm = #-0x58
;         if (flags & FLAGS_LEFT) {
70099930: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
70099934: 0780         	lsls	r0, r0, #0x1e
70099936: 2800         	cmp	r0, #0x0
70099938: d513         	bpl	0x70099962 <_vsnprintf+0x962> @ imm = #0x26
7009993a: e7ff         	b	0x7009993c <_vsnprintf+0x93c> @ imm = #-0x2
;           while (l++ < width) {
7009993c: e7ff         	b	0x7009993e <_vsnprintf+0x93e> @ imm = #-0x2
7009993e: 982c         	ldr	r0, [sp, #0xb0]
70099940: 1c41         	adds	r1, r0, #0x1
70099942: 912c         	str	r1, [sp, #0xb0]
70099944: 993a         	ldr	r1, [sp, #0xe8]
70099946: 4288         	cmp	r0, r1
70099948: d20a         	bhs	0x70099960 <_vsnprintf+0x960> @ imm = #0x14
7009994a: e7ff         	b	0x7009994c <_vsnprintf+0x94c> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009994c: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
70099950: 993e         	ldr	r1, [sp, #0xf8]
70099952: 9a37         	ldr	r2, [sp, #0xdc]
70099954: 1c50         	adds	r0, r2, #0x1
70099956: 9037         	str	r0, [sp, #0xdc]
70099958: 9b3d         	ldr	r3, [sp, #0xf4]
7009995a: 2020         	movs	r0, #0x20
7009995c: 47e0         	blx	r12
;           while (l++ < width) {
7009995e: e7ee         	b	0x7009993e <_vsnprintf+0x93e> @ imm = #-0x24
;         }
70099960: e7ff         	b	0x70099962 <_vsnprintf+0x962> @ imm = #-0x2
;         format++;
70099962: 983c         	ldr	r0, [sp, #0xf0]
70099964: 3001         	adds	r0, #0x1
70099966: 903c         	str	r0, [sp, #0xf0]
;         break;
70099968: e047         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x8e
7009996a: 2008         	movs	r0, #0x8
;         width = sizeof(void*) * 2U;
7009996c: 903a         	str	r0, [sp, #0xe8]
;         flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
7009996e: 983b         	ldr	r0, [sp, #0xec]
70099970: f040 0021    	orr	r0, r0, #0x21
70099974: 903b         	str	r0, [sp, #0xec]
70099976: 2400         	movs	r4, #0x0
;         const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
70099978: f88d 40af    	strb.w	r4, [sp, #0xaf]
;           idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
7009997c: 983f         	ldr	r0, [sp, #0xfc]
7009997e: 993e         	ldr	r1, [sp, #0xf8]
70099980: 9a37         	ldr	r2, [sp, #0xdc]
70099982: 9b3d         	ldr	r3, [sp, #0xf4]
70099984: f8dd c100    	ldr.w	r12, [sp, #0x100]
70099988: f10c 0e04    	add.w	lr, r12, #0x4
7009998c: f8cd e100    	str.w	lr, [sp, #0x100]
70099990: f8dc c000    	ldr.w	r12, [r12]
70099994: 9d39         	ldr	r5, [sp, #0xe4]
70099996: 9e3a         	ldr	r6, [sp, #0xe8]
70099998: 9f3b         	ldr	r7, [sp, #0xec]
7009999a: 46ee         	mov	lr, sp
7009999c: f8ce 7014    	str.w	r7, [lr, #0x14]
700999a0: f8ce 6010    	str.w	r6, [lr, #0x10]
700999a4: f8ce 500c    	str.w	r5, [lr, #0xc]
700999a8: 2510         	movs	r5, #0x10
700999aa: f8ce 5008    	str.w	r5, [lr, #0x8]
700999ae: f8ce 4004    	str.w	r4, [lr, #0x4]
700999b2: f8ce c000    	str.w	r12, [lr]
700999b6: f009 fb93    	bl	0x700a30e0 <_ntoa_long> @ imm = #0x9726
700999ba: 9037         	str	r0, [sp, #0xdc]
;         format++;
700999bc: 983c         	ldr	r0, [sp, #0xf0]
700999be: 3001         	adds	r0, #0x1
700999c0: 903c         	str	r0, [sp, #0xf0]
;         break;
700999c2: e01a         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x34
;         out('%', buffer, idx++, maxlen);
700999c4: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700999c8: 993e         	ldr	r1, [sp, #0xf8]
700999ca: 9a37         	ldr	r2, [sp, #0xdc]
700999cc: 1c50         	adds	r0, r2, #0x1
700999ce: 9037         	str	r0, [sp, #0xdc]
700999d0: 9b3d         	ldr	r3, [sp, #0xf4]
700999d2: 2025         	movs	r0, #0x25
700999d4: 47e0         	blx	r12
;         format++;
700999d6: 983c         	ldr	r0, [sp, #0xf0]
700999d8: 3001         	adds	r0, #0x1
700999da: 903c         	str	r0, [sp, #0xf0]
;         break;
700999dc: e00d         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #0x1a
;         out(*format, buffer, idx++, maxlen);
700999de: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
700999e2: 983c         	ldr	r0, [sp, #0xf0]
700999e4: 7800         	ldrb	r0, [r0]
700999e6: 993e         	ldr	r1, [sp, #0xf8]
700999e8: 9a37         	ldr	r2, [sp, #0xdc]
700999ea: 1c53         	adds	r3, r2, #0x1
700999ec: 9337         	str	r3, [sp, #0xdc]
700999ee: 9b3d         	ldr	r3, [sp, #0xf4]
700999f0: 47e0         	blx	r12
;         format++;
700999f2: 983c         	ldr	r0, [sp, #0xf0]
700999f4: 3001         	adds	r0, #0x1
700999f6: 903c         	str	r0, [sp, #0xf0]
;         break;
700999f8: e7ff         	b	0x700999fa <_vsnprintf+0x9fa> @ imm = #-0x2
;   while (*format)
700999fa: f7ff bb18    	b.w	0x7009902e <_vsnprintf+0x2e> @ imm = #-0x9d0
;   out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
700999fe: 983f         	ldr	r0, [sp, #0xfc]
70099a00: 900a         	str	r0, [sp, #0x28]
70099a02: 983e         	ldr	r0, [sp, #0xf8]
70099a04: 900b         	str	r0, [sp, #0x2c]
70099a06: 9837         	ldr	r0, [sp, #0xdc]
70099a08: 993d         	ldr	r1, [sp, #0xf4]
70099a0a: 4288         	cmp	r0, r1
70099a0c: d203         	bhs	0x70099a16 <_vsnprintf+0xa16> @ imm = #0x6
70099a0e: e7ff         	b	0x70099a10 <_vsnprintf+0xa10> @ imm = #-0x2
70099a10: 9837         	ldr	r0, [sp, #0xdc]
70099a12: 9009         	str	r0, [sp, #0x24]
70099a14: e003         	b	0x70099a1e <_vsnprintf+0xa1e> @ imm = #0x6
70099a16: 983d         	ldr	r0, [sp, #0xf4]
70099a18: 3801         	subs	r0, #0x1
70099a1a: 9009         	str	r0, [sp, #0x24]
70099a1c: e7ff         	b	0x70099a1e <_vsnprintf+0xa1e> @ imm = #-0x2
70099a1e: f8dd c028    	ldr.w	r12, [sp, #0x28]
70099a22: 990b         	ldr	r1, [sp, #0x2c]
70099a24: 9a09         	ldr	r2, [sp, #0x24]
70099a26: 9b3d         	ldr	r3, [sp, #0xf4]
70099a28: 2000         	movs	r0, #0x0
70099a2a: 47e0         	blx	r12
;   return (int)idx;
70099a2c: 9837         	ldr	r0, [sp, #0xdc]
70099a2e: b041         	add	sp, #0x104
70099a30: e8bd 83f0    	pop.w	{r4, r5, r6, r7, r8, r9, pc}

70099a34 <__aeabi_memclr8>:
70099a34: e1a02001     	mov	r2, r1
70099a38: e3b01000     	movs	r1, #0
70099a3c: ea00343f     	b	0x700a6b40 <memset>     @ imm = #0xd0fc

70099a40 <Sciclient_rmIrqRouteValidate>:
; {
70099a40: b580         	push	{r7, lr}
70099a42: b09e         	sub	sp, #0x78
70099a44: 901d         	str	r0, [sp, #0x74]
70099a46: 2001         	movs	r0, #0x1
;     bool valid = true;
70099a48: f88d 0073    	strb.w	r0, [sp, #0x73]
70099a4c: 2000         	movs	r0, #0x0
;     const struct Sciclient_rmIrqNode *cur_n, *next_n = NULL;
70099a4e: 9009         	str	r0, [sp, #0x24]
70099a50: 9019         	str	r0, [sp, #0x64]
;     bool cur_outp_valid = false, next_inp_valid = false;
70099a52: f88d 005f    	strb.w	r0, [sp, #0x5f]
70099a56: f88d 005e    	strb.w	r0, [sp, #0x5e]
;     uint16_t cur_outp = 0, next_inp = 0;
70099a5a: f8ad 0056    	strh.w	r0, [sp, #0x56]
70099a5e: f8ad 0054    	strh.w	r0, [sp, #0x54]
;     struct tisci_msg_rm_get_resource_range_req req = {{0}};
70099a62: 9014         	str	r0, [sp, #0x50]
70099a64: 9013         	str	r0, [sp, #0x4c]
70099a66: 9012         	str	r0, [sp, #0x48]
;     struct tisci_msg_rm_get_resource_range_resp host_resp = {{0}};
70099a68: 9011         	str	r0, [sp, #0x44]
70099a6a: 9010         	str	r0, [sp, #0x40]
70099a6c: 900f         	str	r0, [sp, #0x3c]
70099a6e: 900e         	str	r0, [sp, #0x38]
;     struct tisci_msg_rm_get_resource_range_resp all_resp = {{0}};
70099a70: 900d         	str	r0, [sp, #0x34]
70099a72: 900c         	str	r0, [sp, #0x30]
70099a74: 900b         	str	r0, [sp, #0x2c]
70099a76: 900a         	str	r0, [sp, #0x28]
;     if (cfg->s_ia == SCICLIENT_RM_DEV_NONE) {
70099a78: 981d         	ldr	r0, [sp, #0x74]
70099a7a: 8a00         	ldrh	r0, [r0, #0x10]
70099a7c: 28ff         	cmp	r0, #0xff
70099a7e: d12c         	bne	0x70099ada <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #0x58
70099a80: e7ff         	b	0x70099a82 <Sciclient_rmIrqRouteValidate+0x42> @ imm = #-0x2
70099a82: 2000         	movs	r0, #0x0
;         cur_n = Sciclient_rmPsGetIrqNode(0u);
70099a84: f013 fa9c    	bl	0x700acfc0 <Sciclient_rmPsGetIrqNode> @ imm = #0x13538
70099a88: 901a         	str	r0, [sp, #0x68]
;         if (cur_n == NULL) {
70099a8a: 981a         	ldr	r0, [sp, #0x68]
70099a8c: b920         	cbnz	r0, 0x70099a98 <Sciclient_rmIrqRouteValidate+0x58> @ imm = #0x8
70099a8e: e7ff         	b	0x70099a90 <Sciclient_rmIrqRouteValidate+0x50> @ imm = #-0x2
70099a90: 2000         	movs	r0, #0x0
;             valid = false;
70099a92: f88d 0073    	strb.w	r0, [sp, #0x73]
;         } else {
70099a96: e01f         	b	0x70099ad8 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #0x3e
;             cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(0u)];
70099a98: 981a         	ldr	r0, [sp, #0x68]
70099a9a: 6840         	ldr	r0, [r0, #0x4]
70099a9c: 9008         	str	r0, [sp, #0x20]
70099a9e: 2000         	movs	r0, #0x0
70099aa0: f011 ff6e    	bl	0x700ab980 <Sciclient_rmPsGetIfIdx> @ imm = #0x11edc
70099aa4: 4601         	mov	r1, r0
70099aa6: 9808         	ldr	r0, [sp, #0x20]
70099aa8: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
70099aac: 9018         	str	r0, [sp, #0x60]
;             if ((cfg->s_idx < cur_if->lbase) ||
70099aae: 981d         	ldr	r0, [sp, #0x74]
70099ab0: 8900         	ldrh	r0, [r0, #0x8]
70099ab2: 9918         	ldr	r1, [sp, #0x60]
70099ab4: 8809         	ldrh	r1, [r1]
70099ab6: 4288         	cmp	r0, r1
70099ab8: db09         	blt	0x70099ace <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #0x12
70099aba: e7ff         	b	0x70099abc <Sciclient_rmIrqRouteValidate+0x7c> @ imm = #-0x2
;                 (cfg->s_idx >= (cur_if->lbase + cur_if->len))) {
70099abc: 981d         	ldr	r0, [sp, #0x74]
70099abe: 8900         	ldrh	r0, [r0, #0x8]
70099ac0: 9a18         	ldr	r2, [sp, #0x60]
70099ac2: 8811         	ldrh	r1, [r2]
70099ac4: 8892         	ldrh	r2, [r2, #0x4]
70099ac6: 4411         	add	r1, r2
;             if ((cfg->s_idx < cur_if->lbase) ||
70099ac8: 4288         	cmp	r0, r1
70099aca: db04         	blt	0x70099ad6 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #0x8
70099acc: e7ff         	b	0x70099ace <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #-0x2
70099ace: 2000         	movs	r0, #0x0
;                 valid = false;
70099ad0: f88d 0073    	strb.w	r0, [sp, #0x73]
;             }
70099ad4: e7ff         	b	0x70099ad6 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #-0x2
70099ad6: e7ff         	b	0x70099ad8 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #-0x2
;     }
70099ad8: e7ff         	b	0x70099ada <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #-0x2
;     if ((valid == true) &&
70099ada: f89d 0073    	ldrb.w	r0, [sp, #0x73]
70099ade: 07c0         	lsls	r0, r0, #0x1f
70099ae0: b148         	cbz	r0, 0x70099af6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x12
70099ae2: e7ff         	b	0x70099ae4 <Sciclient_rmIrqRouteValidate+0xa4> @ imm = #-0x2
;         (Sciclient_rmPsGetPsp() <= 1U)) {
70099ae4: f013 fe2c    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0x13c58
;     if ((valid == true) &&
70099ae8: 2801         	cmp	r0, #0x1
70099aea: d804         	bhi	0x70099af6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x8
70099aec: e7ff         	b	0x70099aee <Sciclient_rmIrqRouteValidate+0xae> @ imm = #-0x2
70099aee: 2000         	movs	r0, #0x0
;         valid = false;
70099af0: f88d 0073    	strb.w	r0, [sp, #0x73]
;     }
70099af4: e7ff         	b	0x70099af6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #-0x2
;     if (valid == true) {
70099af6: f89d 0073    	ldrb.w	r0, [sp, #0x73]
70099afa: 07c0         	lsls	r0, r0, #0x1f
70099afc: b150         	cbz	r0, 0x70099b14 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #0x14
70099afe: e7ff         	b	0x70099b00 <Sciclient_rmIrqRouteValidate+0xc0> @ imm = #-0x2
;         if (Sciclient_rmIrqCheckLoop(cfg) == true) {
70099b00: 981d         	ldr	r0, [sp, #0x74]
70099b02: f00c fdcd    	bl	0x700a66a0 <Sciclient_rmIrqCheckLoop> @ imm = #0xcb9a
70099b06: b120         	cbz	r0, 0x70099b12 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #0x8
70099b08: e7ff         	b	0x70099b0a <Sciclient_rmIrqRouteValidate+0xca> @ imm = #-0x2
70099b0a: 2000         	movs	r0, #0x0
;             valid = false;
70099b0c: f88d 0073    	strb.w	r0, [sp, #0x73]
;         }
70099b10: e7ff         	b	0x70099b12 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #-0x2
;     }
70099b12: e7ff         	b	0x70099b14 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #-0x2
70099b14: 2000         	movs	r0, #0x0
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
70099b16: f8ad 0070    	strh.w	r0, [sp, #0x70]
70099b1a: e7ff         	b	0x70099b1c <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x2
70099b1c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099b20: 9006         	str	r0, [sp, #0x18]
70099b22: f013 fe0d    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0x13c1a
70099b26: 9906         	ldr	r1, [sp, #0x18]
70099b28: 4602         	mov	r2, r0
70099b2a: 2000         	movs	r0, #0x0
70099b2c: 4291         	cmp	r1, r2
70099b2e: 9007         	str	r0, [sp, #0x1c]
70099b30: da06         	bge	0x70099b40 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #0xc
70099b32: e7ff         	b	0x70099b34 <Sciclient_rmIrqRouteValidate+0xf4> @ imm = #-0x2
70099b34: f89d 0073    	ldrb.w	r0, [sp, #0x73]
70099b38: f000 0001    	and	r0, r0, #0x1
70099b3c: 9007         	str	r0, [sp, #0x1c]
70099b3e: e7ff         	b	0x70099b40 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #-0x2
70099b40: 9807         	ldr	r0, [sp, #0x1c]
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
70099b42: 07c0         	lsls	r0, r0, #0x1f
70099b44: 2800         	cmp	r0, #0x0
70099b46: f000 826f    	beq.w	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x4de
70099b4a: e7ff         	b	0x70099b4c <Sciclient_rmIrqRouteValidate+0x10c> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
70099b4c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099b50: f013 fa36    	bl	0x700acfc0 <Sciclient_rmPsGetIrqNode> @ imm = #0x1346c
70099b54: 901a         	str	r0, [sp, #0x68]
;         cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(i)];
70099b56: 981a         	ldr	r0, [sp, #0x68]
70099b58: 6840         	ldr	r0, [r0, #0x4]
70099b5a: 9004         	str	r0, [sp, #0x10]
70099b5c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099b60: f011 ff0e    	bl	0x700ab980 <Sciclient_rmPsGetIfIdx> @ imm = #0x11e1c
70099b64: 4601         	mov	r1, r0
70099b66: 9804         	ldr	r0, [sp, #0x10]
70099b68: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
70099b6c: 9018         	str	r0, [sp, #0x60]
;         if (i < (Sciclient_rmPsGetPsp() - 1u)) {
70099b6e: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099b72: 9005         	str	r0, [sp, #0x14]
70099b74: f013 fde4    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0x13bc8
70099b78: 4601         	mov	r1, r0
70099b7a: 9805         	ldr	r0, [sp, #0x14]
70099b7c: 3901         	subs	r1, #0x1
70099b7e: 4288         	cmp	r0, r1
70099b80: d20f         	bhs	0x70099ba2 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #0x1e
70099b82: e7ff         	b	0x70099b84 <Sciclient_rmIrqRouteValidate+0x144> @ imm = #-0x2
;             next_n = Sciclient_rmPsGetIrqNode(i + 1u);
70099b84: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099b88: 3001         	adds	r0, #0x1
70099b8a: b280         	uxth	r0, r0
70099b8c: f013 fa18    	bl	0x700acfc0 <Sciclient_rmPsGetIrqNode> @ imm = #0x13430
70099b90: 9019         	str	r0, [sp, #0x64]
;             if (next_n == NULL) {
70099b92: 9819         	ldr	r0, [sp, #0x64]
70099b94: b920         	cbnz	r0, 0x70099ba0 <Sciclient_rmIrqRouteValidate+0x160> @ imm = #0x8
70099b96: e7ff         	b	0x70099b98 <Sciclient_rmIrqRouteValidate+0x158> @ imm = #-0x2
70099b98: 2000         	movs	r0, #0x0
;                 valid = false;
70099b9a: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099b9e: e243         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x486
;         }
70099ba0: e7ff         	b	0x70099ba2 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #-0x2
;         if (i > 0u) {
70099ba2: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099ba6: b158         	cbz	r0, 0x70099bc0 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #0x16
70099ba8: e7ff         	b	0x70099baa <Sciclient_rmIrqRouteValidate+0x16a> @ imm = #-0x2
;             if (Sciclient_rmIrIsIr(cur_n->id) != true) {
70099baa: 981a         	ldr	r0, [sp, #0x68]
70099bac: 8800         	ldrh	r0, [r0]
70099bae: f012 fcef    	bl	0x700ac590 <Sciclient_rmIrIsIr> @ imm = #0x129de
70099bb2: b920         	cbnz	r0, 0x70099bbe <Sciclient_rmIrqRouteValidate+0x17e> @ imm = #0x8
70099bb4: e7ff         	b	0x70099bb6 <Sciclient_rmIrqRouteValidate+0x176> @ imm = #-0x2
70099bb6: 2000         	movs	r0, #0x0
;                 valid = false;
70099bb8: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099bbc: e234         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x468
;         }
70099bbe: e7ff         	b	0x70099bc0 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #-0x2
;         if ((i == 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
70099bc0: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099bc4: 2800         	cmp	r0, #0x0
70099bc6: f040 8080    	bne.w	0x70099cca <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0x100
70099bca: e7ff         	b	0x70099bcc <Sciclient_rmIrqRouteValidate+0x18c> @ imm = #-0x2
70099bcc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099bd0: 9003         	str	r0, [sp, #0xc]
70099bd2: f013 fdb5    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0x13b6a
70099bd6: 4601         	mov	r1, r0
70099bd8: 9803         	ldr	r0, [sp, #0xc]
70099bda: 3901         	subs	r1, #0x1
70099bdc: 4288         	cmp	r0, r1
70099bde: d274         	bhs	0x70099cca <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0xe8
70099be0: e7ff         	b	0x70099be2 <Sciclient_rmIrqRouteValidate+0x1a2> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cur_n->id) == true) {
70099be2: 981a         	ldr	r0, [sp, #0x68]
70099be4: 8800         	ldrh	r0, [r0]
70099be6: f012 fcbb    	bl	0x700ac560 <Sciclient_rmIaIsIa> @ imm = #0x12976
70099bea: 2800         	cmp	r0, #0x0
70099bec: d049         	beq	0x70099c82 <Sciclient_rmIrqRouteValidate+0x242> @ imm = #0x92
70099bee: e7ff         	b	0x70099bf0 <Sciclient_rmIrqRouteValidate+0x1b0> @ imm = #-0x2
70099bf0: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
70099bf2: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
70099bf6: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cfg->vint,
70099bfa: 9a18         	ldr	r2, [sp, #0x60]
70099bfc: 8850         	ldrh	r0, [r2, #0x2]
70099bfe: 991d         	ldr	r1, [sp, #0x74]
70099c00: 8a49         	ldrh	r1, [r1, #0x12]
70099c02: 8812         	ldrh	r2, [r2]
70099c04: 1a89         	subs	r1, r1, r2
70099c06: 4408         	add	r0, r1
70099c08: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 cur_outp = cfg->vint;
70099c0c: 981d         	ldr	r0, [sp, #0x74]
70099c0e: 8a40         	ldrh	r0, [r0, #0x12]
70099c10: f8ad 0056    	strh.w	r0, [sp, #0x56]
70099c14: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
70099c16: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
70099c1a: 9819         	ldr	r0, [sp, #0x64]
70099c1c: b160         	cbz	r0, 0x70099c38 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x18
70099c1e: e7ff         	b	0x70099c20 <Sciclient_rmIrqRouteValidate+0x1e0> @ imm = #-0x2
70099c20: 9819         	ldr	r0, [sp, #0x64]
70099c22: 8800         	ldrh	r0, [r0]
70099c24: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099c28: f00a fb3a    	bl	0x700a42a0 <Sciclient_rmIrInpIsFree> @ imm = #0xa674
70099c2c: b920         	cbnz	r0, 0x70099c38 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x8
70099c2e: e7ff         	b	0x70099c30 <Sciclient_rmIrqRouteValidate+0x1f0> @ imm = #-0x2
70099c30: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
70099c32: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
70099c36: e7ff         	b	0x70099c38 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #-0x2
;                 if (Sciclient_rmParamIsValid(cfg->valid_params,
70099c38: 981d         	ldr	r0, [sp, #0x74]
70099c3a: 6800         	ldr	r0, [r0]
70099c3c: 2110         	movs	r1, #0x10
70099c3e: f012 fe57    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x12cae
70099c42: b1e8         	cbz	r0, 0x70099c80 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #0x3a
70099c44: e7ff         	b	0x70099c46 <Sciclient_rmIrqRouteValidate+0x206> @ imm = #-0x2
;                     cur_inp = cfg->global_evt;
70099c46: 981d         	ldr	r0, [sp, #0x74]
70099c48: 89c0         	ldrh	r0, [r0, #0xe]
70099c4a: 9016         	str	r0, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
70099c4c: 981a         	ldr	r0, [sp, #0x68]
70099c4e: 8800         	ldrh	r0, [r0]
;                                       cur_inp) ==
70099c50: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
70099c54: f010 fc84    	bl	0x700aa560 <Sciclient_rmIaValidateGlobalEvt> @ imm = #0x10908
70099c58: b968         	cbnz	r0, 0x70099c76 <Sciclient_rmIrqRouteValidate+0x236> @ imm = #0x1a
70099c5a: e7ff         	b	0x70099c5c <Sciclient_rmIrqRouteValidate+0x21c> @ imm = #-0x2
;                         if (Sciclient_rmPsSetInp(i, cur_inp) != SystemP_SUCCESS) {
70099c5c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099c60: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
70099c64: f011 fa1c    	bl	0x700ab0a0 <Sciclient_rmPsSetInp> @ imm = #0x11438
70099c68: b120         	cbz	r0, 0x70099c74 <Sciclient_rmIrqRouteValidate+0x234> @ imm = #0x8
70099c6a: e7ff         	b	0x70099c6c <Sciclient_rmIrqRouteValidate+0x22c> @ imm = #-0x2
70099c6c: 2000         	movs	r0, #0x0
;                             valid = false;
70099c6e: f88d 0073    	strb.w	r0, [sp, #0x73]
;                             break;
70099c72: e1d9         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3b2
;                     } else {
70099c74: e003         	b	0x70099c7e <Sciclient_rmIrqRouteValidate+0x23e> @ imm = #0x6
70099c76: 2000         	movs	r0, #0x0
;                         valid = false;
70099c78: f88d 0073    	strb.w	r0, [sp, #0x73]
;                         break;
70099c7c: e1d4         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3a8
;                 }
70099c7e: e7ff         	b	0x70099c80 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #-0x2
;             } else {
70099c80: e022         	b	0x70099cc8 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #0x44
70099c82: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
70099c84: f88d 005f    	strb.w	r0, [sp, #0x5f]
70099c88: 2000         	movs	r0, #0x0
;                 next_inp_valid = false;
70099c8a: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = cfg->s_idx;
70099c8e: 981d         	ldr	r0, [sp, #0x74]
70099c90: 8900         	ldrh	r0, [r0, #0x8]
70099c92: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
70099c96: 9a18         	ldr	r2, [sp, #0x60]
70099c98: 8850         	ldrh	r0, [r2, #0x2]
70099c9a: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099c9e: 8812         	ldrh	r2, [r2]
70099ca0: 1a89         	subs	r1, r1, r2
70099ca2: 4408         	add	r0, r1
70099ca4: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
70099ca8: 9819         	ldr	r0, [sp, #0x64]
70099caa: b160         	cbz	r0, 0x70099cc6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x18
70099cac: e7ff         	b	0x70099cae <Sciclient_rmIrqRouteValidate+0x26e> @ imm = #-0x2
70099cae: 9819         	ldr	r0, [sp, #0x64]
70099cb0: 8800         	ldrh	r0, [r0]
70099cb2: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099cb6: f00a faf3    	bl	0x700a42a0 <Sciclient_rmIrInpIsFree> @ imm = #0xa5e6
70099cba: b920         	cbnz	r0, 0x70099cc6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x8
70099cbc: e7ff         	b	0x70099cbe <Sciclient_rmIrqRouteValidate+0x27e> @ imm = #-0x2
70099cbe: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
70099cc0: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
70099cc4: e7ff         	b	0x70099cc6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #-0x2
70099cc6: e7ff         	b	0x70099cc8 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #-0x2
;         }
70099cc8: e7ff         	b	0x70099cca <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #-0x2
;         if ((i > 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
70099cca: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099cce: 2800         	cmp	r0, #0x0
70099cd0: f000 80c4    	beq.w	0x70099e5c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x188
70099cd4: e7ff         	b	0x70099cd6 <Sciclient_rmIrqRouteValidate+0x296> @ imm = #-0x2
70099cd6: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099cda: 9002         	str	r0, [sp, #0x8]
70099cdc: f013 fd30    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0x13a60
70099ce0: 4601         	mov	r1, r0
70099ce2: 9802         	ldr	r0, [sp, #0x8]
70099ce4: 3901         	subs	r1, #0x1
70099ce6: 4288         	cmp	r0, r1
70099ce8: f080 80b8    	bhs.w	0x70099e5c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x170
70099cec: e7ff         	b	0x70099cee <Sciclient_rmIrqRouteValidate+0x2ae> @ imm = #-0x2
;             req.secondary_host = cfg->host;
70099cee: 981d         	ldr	r0, [sp, #0x74]
70099cf0: 7900         	ldrb	r0, [r0, #0x4]
70099cf2: f88d 0053    	strb.w	r0, [sp, #0x53]
;             req.type = cur_n->id;
70099cf6: 981a         	ldr	r0, [sp, #0x68]
70099cf8: 8800         	ldrh	r0, [r0]
70099cfa: f8ad 0050    	strh.w	r0, [sp, #0x50]
70099cfe: 2000         	movs	r0, #0x0
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
70099d00: f88d 0052    	strb.w	r0, [sp, #0x52]
70099d04: a812         	add	r0, sp, #0x48
70099d06: a90e         	add	r1, sp, #0x38
70099d08: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
70099d0c: f00f fb00    	bl	0x700a9310 <Sciclient_rmGetResourceRange> @ imm = #0xf600
70099d10: b120         	cbz	r0, 0x70099d1c <Sciclient_rmIrqRouteValidate+0x2dc> @ imm = #0x8
70099d12: e7ff         	b	0x70099d14 <Sciclient_rmIrqRouteValidate+0x2d4> @ imm = #-0x2
70099d14: 2000         	movs	r0, #0x0
;                 valid = false;
70099d16: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099d1a: e185         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30a
70099d1c: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
70099d1e: f88d 0053    	strb.w	r0, [sp, #0x53]
70099d22: a812         	add	r0, sp, #0x48
70099d24: a90a         	add	r1, sp, #0x28
70099d26: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
70099d2a: f00f faf1    	bl	0x700a9310 <Sciclient_rmGetResourceRange> @ imm = #0xf5e2
70099d2e: b120         	cbz	r0, 0x70099d3a <Sciclient_rmIrqRouteValidate+0x2fa> @ imm = #0x8
70099d30: e7ff         	b	0x70099d32 <Sciclient_rmIrqRouteValidate+0x2f2> @ imm = #-0x2
70099d32: 2000         	movs	r0, #0x0
;                 valid = false;
70099d34: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099d38: e176         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x2ec
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
70099d3a: 9818         	ldr	r0, [sp, #0x60]
70099d3c: 8800         	ldrh	r0, [r0]
70099d3e: f8ad 006e    	strh.w	r0, [sp, #0x6e]
70099d42: e7ff         	b	0x70099d44 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x2
70099d44: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
70099d48: 9a18         	ldr	r2, [sp, #0x60]
70099d4a: 8811         	ldrh	r1, [r2]
70099d4c: 8892         	ldrh	r2, [r2, #0x4]
70099d4e: 4411         	add	r1, r2
70099d50: 4288         	cmp	r0, r1
70099d52: f280 8082    	bge.w	0x70099e5a <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0x104
70099d56: e7ff         	b	0x70099d58 <Sciclient_rmIrqRouteValidate+0x318> @ imm = #-0x2
70099d58: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
70099d5a: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
70099d5e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = j;
70099d62: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
70099d66: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
70099d6a: 9a18         	ldr	r2, [sp, #0x60]
70099d6c: 8850         	ldrh	r0, [r2, #0x2]
70099d6e: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099d72: 8812         	ldrh	r2, [r2]
70099d74: 1a89         	subs	r1, r1, r2
70099d76: 4408         	add	r0, r1
70099d78: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((((cur_outp >= host_resp.range_start) &&
70099d7c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099d80: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099d84: 4288         	cmp	r0, r1
70099d86: db0a         	blt	0x70099d9e <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #0x14
70099d88: e7ff         	b	0x70099d8a <Sciclient_rmIrqRouteValidate+0x34a> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start + host_resp.range_num)) ||
70099d8a: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099d8e: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099d92: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
70099d96: 4411         	add	r1, r2
70099d98: 4288         	cmp	r0, r1
70099d9a: db33         	blt	0x70099e04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x66
70099d9c: e7ff         	b	0x70099d9e <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #-0x2
;                      ((cur_outp >= host_resp.range_start_sec) &&
70099d9e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099da2: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
70099da6: 4288         	cmp	r0, r1
70099da8: db0a         	blt	0x70099dc0 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #0x14
70099daa: e7ff         	b	0x70099dac <Sciclient_rmIrqRouteValidate+0x36c> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start_sec +
70099dac: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099db0: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                                   host_resp.range_num_sec))) ||
70099db4: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                       (cur_outp < host_resp.range_start_sec +
70099db8: 4411         	add	r1, r2
;                                   host_resp.range_num_sec))) ||
70099dba: 4288         	cmp	r0, r1
70099dbc: db22         	blt	0x70099e04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x44
70099dbe: e7ff         	b	0x70099dc0 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #-0x2
;                     (((cur_outp >= all_resp.range_start) &&
70099dc0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099dc4: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099dc8: 4288         	cmp	r0, r1
70099dca: db0a         	blt	0x70099de2 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #0x14
70099dcc: e7ff         	b	0x70099dce <Sciclient_rmIrqRouteValidate+0x38e> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start + all_resp.range_num)) ||
70099dce: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099dd2: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099dd6: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
70099dda: 4411         	add	r1, r2
70099ddc: 4288         	cmp	r0, r1
70099dde: db11         	blt	0x70099e04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x22
70099de0: e7ff         	b	0x70099de2 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #-0x2
;                      ((cur_outp >= all_resp.range_start_sec) &&
70099de2: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099de6: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
70099dea: 4288         	cmp	r0, r1
70099dec: db2e         	blt	0x70099e4c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x5c
70099dee: e7ff         	b	0x70099df0 <Sciclient_rmIrqRouteValidate+0x3b0> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start_sec +
70099df0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099df4: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                                   all_resp.range_num_sec)))) {
70099df8: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                       (cur_outp < all_resp.range_start_sec +
70099dfc: 4411         	add	r1, r2
;                 if ((((cur_outp >= host_resp.range_start) &&
70099dfe: 4288         	cmp	r0, r1
70099e00: da24         	bge	0x70099e4c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x48
70099e02: e7ff         	b	0x70099e04 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
70099e04: 981a         	ldr	r0, [sp, #0x68]
70099e06: 8800         	ldrh	r0, [r0]
70099e08: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099e0c: f00d f8c8    	bl	0x700a6fa0 <Sciclient_rmIrOutpIsFree> @ imm = #0xd190
70099e10: b920         	cbnz	r0, 0x70099e1c <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #0x8
70099e12: e7ff         	b	0x70099e14 <Sciclient_rmIrqRouteValidate+0x3d4> @ imm = #-0x2
70099e14: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
70099e16: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
70099e1a: e7ff         	b	0x70099e1c <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #-0x2
;                     if (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
70099e1c: 9819         	ldr	r0, [sp, #0x64]
70099e1e: 8800         	ldrh	r0, [r0]
70099e20: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099e24: f00a fa3c    	bl	0x700a42a0 <Sciclient_rmIrInpIsFree> @ imm = #0xa478
70099e28: b920         	cbnz	r0, 0x70099e34 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #0x8
70099e2a: e7ff         	b	0x70099e2c <Sciclient_rmIrqRouteValidate+0x3ec> @ imm = #-0x2
70099e2c: 2001         	movs	r0, #0x1
;                         next_inp_valid = true;
70099e2e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                     }
70099e32: e7ff         	b	0x70099e34 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #-0x2
;                     if ((cur_outp_valid == true) &&
70099e34: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
70099e38: 07c0         	lsls	r0, r0, #0x1f
70099e3a: b130         	cbz	r0, 0x70099e4a <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0xc
70099e3c: e7ff         	b	0x70099e3e <Sciclient_rmIrqRouteValidate+0x3fe> @ imm = #-0x2
;                         (next_inp_valid == true)) {
70099e3e: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
;                     if ((cur_outp_valid == true) &&
70099e42: 07c0         	lsls	r0, r0, #0x1f
70099e44: b108         	cbz	r0, 0x70099e4a <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0x2
70099e46: e7ff         	b	0x70099e48 <Sciclient_rmIrqRouteValidate+0x408> @ imm = #-0x2
;                         break;
70099e48: e007         	b	0x70099e5a <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0xe
;                 }
70099e4a: e7ff         	b	0x70099e4c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #-0x2
;             }
70099e4c: e7ff         	b	0x70099e4e <Sciclient_rmIrqRouteValidate+0x40e> @ imm = #-0x2
;                  j++) {
70099e4e: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
70099e52: 3001         	adds	r0, #0x1
70099e54: f8ad 006e    	strh.w	r0, [sp, #0x6e]
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
70099e58: e774         	b	0x70099d44 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x118
;         }
70099e5a: e7ff         	b	0x70099e5c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #-0x2
;         if (i == (Sciclient_rmPsGetPsp() - 1u)) {
70099e5c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099e60: 9001         	str	r0, [sp, #0x4]
70099e62: f013 fc6d    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0x138da
70099e66: 4601         	mov	r1, r0
70099e68: 9801         	ldr	r0, [sp, #0x4]
70099e6a: 3901         	subs	r1, #0x1
70099e6c: 4288         	cmp	r0, r1
70099e6e: f040 809f    	bne.w	0x70099fb0 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #0x13e
70099e72: e7ff         	b	0x70099e74 <Sciclient_rmIrqRouteValidate+0x434> @ imm = #-0x2
70099e74: 2000         	movs	r0, #0x0
;             cur_outp_valid = false;
70099e76: f88d 005f    	strb.w	r0, [sp, #0x5f]
70099e7a: 2101         	movs	r1, #0x1
;             next_inp_valid = true;
70099e7c: f88d 105e    	strb.w	r1, [sp, #0x5e]
;             req.secondary_host = cfg->host;
70099e80: 991d         	ldr	r1, [sp, #0x74]
70099e82: 7909         	ldrb	r1, [r1, #0x4]
70099e84: f88d 1053    	strb.w	r1, [sp, #0x53]
;             req.type = cur_n->id;
70099e88: 991a         	ldr	r1, [sp, #0x68]
70099e8a: 8809         	ldrh	r1, [r1]
70099e8c: f8ad 1050    	strh.w	r1, [sp, #0x50]
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
70099e90: f88d 0052    	strb.w	r0, [sp, #0x52]
70099e94: a812         	add	r0, sp, #0x48
70099e96: a90e         	add	r1, sp, #0x38
70099e98: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
70099e9c: f00f fa38    	bl	0x700a9310 <Sciclient_rmGetResourceRange> @ imm = #0xf470
70099ea0: b120         	cbz	r0, 0x70099eac <Sciclient_rmIrqRouteValidate+0x46c> @ imm = #0x8
70099ea2: e7ff         	b	0x70099ea4 <Sciclient_rmIrqRouteValidate+0x464> @ imm = #-0x2
70099ea4: 2000         	movs	r0, #0x0
;                 valid = false;
70099ea6: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099eaa: e0bd         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x17a
70099eac: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
70099eae: f88d 0053    	strb.w	r0, [sp, #0x53]
70099eb2: a812         	add	r0, sp, #0x48
70099eb4: a90a         	add	r1, sp, #0x28
70099eb6: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
70099eba: f00f fa29    	bl	0x700a9310 <Sciclient_rmGetResourceRange> @ imm = #0xf452
70099ebe: b120         	cbz	r0, 0x70099eca <Sciclient_rmIrqRouteValidate+0x48a> @ imm = #0x8
70099ec0: e7ff         	b	0x70099ec2 <Sciclient_rmIrqRouteValidate+0x482> @ imm = #-0x2
70099ec2: 2000         	movs	r0, #0x0
;                 valid = false;
70099ec4: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
70099ec8: e0ae         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x15c
;             cur_outp = SCICLIENT_INP_TO_OUTP(cfg->d_irq,
70099eca: 9a18         	ldr	r2, [sp, #0x60]
70099ecc: 8810         	ldrh	r0, [r2]
70099ece: 991d         	ldr	r1, [sp, #0x74]
70099ed0: 8989         	ldrh	r1, [r1, #0xc]
70099ed2: 8852         	ldrh	r2, [r2, #0x2]
70099ed4: 1a89         	subs	r1, r1, r2
70099ed6: 4408         	add	r0, r1
70099ed8: f8ad 0056    	strh.w	r0, [sp, #0x56]
;             if ((((cur_outp >= host_resp.range_start) &&
70099edc: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099ee0: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099ee4: 4288         	cmp	r0, r1
70099ee6: db0a         	blt	0x70099efe <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #0x14
70099ee8: e7ff         	b	0x70099eea <Sciclient_rmIrqRouteValidate+0x4aa> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start + host_resp.range_num)) ||
70099eea: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099eee: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
70099ef2: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
70099ef6: 4411         	add	r1, r2
70099ef8: 4288         	cmp	r0, r1
70099efa: db33         	blt	0x70099f64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x66
70099efc: e7ff         	b	0x70099efe <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #-0x2
;                  ((cur_outp >= host_resp.range_start_sec) &&
70099efe: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f02: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
70099f06: 4288         	cmp	r0, r1
70099f08: db0a         	blt	0x70099f20 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #0x14
70099f0a: e7ff         	b	0x70099f0c <Sciclient_rmIrqRouteValidate+0x4cc> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start_sec +
70099f0c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f10: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                               host_resp.range_num_sec))) ||
70099f14: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                   (cur_outp < host_resp.range_start_sec +
70099f18: 4411         	add	r1, r2
;                               host_resp.range_num_sec))) ||
70099f1a: 4288         	cmp	r0, r1
70099f1c: db22         	blt	0x70099f64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x44
70099f1e: e7ff         	b	0x70099f20 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #-0x2
;                 (((cur_outp >= all_resp.range_start) &&
70099f20: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f24: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099f28: 4288         	cmp	r0, r1
70099f2a: db0a         	blt	0x70099f42 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #0x14
70099f2c: e7ff         	b	0x70099f2e <Sciclient_rmIrqRouteValidate+0x4ee> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start + all_resp.range_num)) ||
70099f2e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f32: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
70099f36: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
70099f3a: 4411         	add	r1, r2
70099f3c: 4288         	cmp	r0, r1
70099f3e: db11         	blt	0x70099f64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x22
70099f40: e7ff         	b	0x70099f42 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #-0x2
;                  ((cur_outp >= all_resp.range_start_sec) &&
70099f42: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f46: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
70099f4a: 4288         	cmp	r0, r1
70099f4c: db2f         	blt	0x70099fae <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x5e
70099f4e: e7ff         	b	0x70099f50 <Sciclient_rmIrqRouteValidate+0x510> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start_sec +
70099f50: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
70099f54: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                               all_resp.range_num_sec)))) {
70099f58: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                   (cur_outp < all_resp.range_start_sec +
70099f5c: 4411         	add	r1, r2
;             if ((((cur_outp >= host_resp.range_start) &&
70099f5e: 4288         	cmp	r0, r1
70099f60: da25         	bge	0x70099fae <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x4a
70099f62: e7ff         	b	0x70099f64 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
70099f64: 9818         	ldr	r0, [sp, #0x60]
70099f66: 88c0         	ldrh	r0, [r0, #0x6]
70099f68: 991d         	ldr	r1, [sp, #0x74]
70099f6a: 8949         	ldrh	r1, [r1, #0xa]
70099f6c: 4288         	cmp	r0, r1
70099f6e: d11d         	bne	0x70099fac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x3a
70099f70: e7ff         	b	0x70099f72 <Sciclient_rmIrqRouteValidate+0x532> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
70099f72: 981d         	ldr	r0, [sp, #0x74]
70099f74: 8980         	ldrh	r0, [r0, #0xc]
70099f76: 9918         	ldr	r1, [sp, #0x60]
70099f78: 8849         	ldrh	r1, [r1, #0x2]
70099f7a: 4288         	cmp	r0, r1
70099f7c: db16         	blt	0x70099fac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x2c
70099f7e: e7ff         	b	0x70099f80 <Sciclient_rmIrqRouteValidate+0x540> @ imm = #-0x2
;                     (cfg->d_irq < (cur_if->rbase + cur_if->len))) {
70099f80: 981d         	ldr	r0, [sp, #0x74]
70099f82: 8980         	ldrh	r0, [r0, #0xc]
70099f84: 9a18         	ldr	r2, [sp, #0x60]
70099f86: 8851         	ldrh	r1, [r2, #0x2]
70099f88: 8892         	ldrh	r2, [r2, #0x4]
70099f8a: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
70099f8c: 4288         	cmp	r0, r1
70099f8e: da0d         	bge	0x70099fac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x1a
70099f90: e7ff         	b	0x70099f92 <Sciclient_rmIrqRouteValidate+0x552> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
70099f92: 981a         	ldr	r0, [sp, #0x68]
70099f94: 8800         	ldrh	r0, [r0]
70099f96: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
70099f9a: f00d f801    	bl	0x700a6fa0 <Sciclient_rmIrOutpIsFree> @ imm = #0xd002
70099f9e: b920         	cbnz	r0, 0x70099faa <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #0x8
70099fa0: e7ff         	b	0x70099fa2 <Sciclient_rmIrqRouteValidate+0x562> @ imm = #-0x2
70099fa2: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
70099fa4: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
70099fa8: e7ff         	b	0x70099faa <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #-0x2
;                 }
70099faa: e7ff         	b	0x70099fac <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #-0x2
; 	    }
70099fac: e7ff         	b	0x70099fae <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #-0x2
;         }
70099fae: e7ff         	b	0x70099fb0 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #-0x2
;         if ((cur_outp_valid == true) && (next_inp_valid == true)) {
70099fb0: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
70099fb4: 07c0         	lsls	r0, r0, #0x1f
70099fb6: b360         	cbz	r0, 0x7009a012 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x58
70099fb8: e7ff         	b	0x70099fba <Sciclient_rmIrqRouteValidate+0x57a> @ imm = #-0x2
70099fba: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
70099fbe: 07c0         	lsls	r0, r0, #0x1f
70099fc0: b338         	cbz	r0, 0x7009a012 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x4e
70099fc2: e7ff         	b	0x70099fc4 <Sciclient_rmIrqRouteValidate+0x584> @ imm = #-0x2
;             if (i < (Sciclient_rmPsGetPsp() - (1u))) {
70099fc4: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099fc8: 9000         	str	r0, [sp]
70099fca: f013 fbb9    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0x13772
70099fce: 4601         	mov	r1, r0
70099fd0: 9800         	ldr	r0, [sp]
70099fd2: 3901         	subs	r1, #0x1
70099fd4: 4288         	cmp	r0, r1
70099fd6: d20f         	bhs	0x70099ff8 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #0x1e
70099fd8: e7ff         	b	0x70099fda <Sciclient_rmIrqRouteValidate+0x59a> @ imm = #-0x2
;                 if (Sciclient_rmPsSetInp(i + (1u), next_inp) != SystemP_SUCCESS) {
70099fda: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099fde: 3001         	adds	r0, #0x1
70099fe0: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
70099fe4: b280         	uxth	r0, r0
70099fe6: f011 f85b    	bl	0x700ab0a0 <Sciclient_rmPsSetInp> @ imm = #0x110b6
70099fea: b120         	cbz	r0, 0x70099ff6 <Sciclient_rmIrqRouteValidate+0x5b6> @ imm = #0x8
70099fec: e7ff         	b	0x70099fee <Sciclient_rmIrqRouteValidate+0x5ae> @ imm = #-0x2
70099fee: 2000         	movs	r0, #0x0
;                     valid = false;
70099ff0: f88d 0073    	strb.w	r0, [sp, #0x73]
;                     break;
70099ff4: e018         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30
;             }
70099ff6: e7ff         	b	0x70099ff8 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #-0x2
;             if (Sciclient_rmPsSetOutp(i, cur_outp) != SystemP_SUCCESS) {
70099ff8: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
70099ffc: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009a000: f011 f876    	bl	0x700ab0f0 <Sciclient_rmPsSetOutp> @ imm = #0x110ec
7009a004: b120         	cbz	r0, 0x7009a010 <Sciclient_rmIrqRouteValidate+0x5d0> @ imm = #0x8
7009a006: e7ff         	b	0x7009a008 <Sciclient_rmIrqRouteValidate+0x5c8> @ imm = #-0x2
7009a008: 2000         	movs	r0, #0x0
;                 valid = false;
7009a00a: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009a00e: e00b         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x16
;         } else {
7009a010: e003         	b	0x7009a01a <Sciclient_rmIrqRouteValidate+0x5da> @ imm = #0x6
7009a012: 2000         	movs	r0, #0x0
;             valid = false;
7009a014: f88d 0073    	strb.w	r0, [sp, #0x73]
;             break;
7009a018: e006         	b	0x7009a028 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0xc
;     }
7009a01a: e7ff         	b	0x7009a01c <Sciclient_rmIrqRouteValidate+0x5dc> @ imm = #-0x2
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009a01c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009a020: 3001         	adds	r0, #0x1
7009a022: f8ad 0070    	strh.w	r0, [sp, #0x70]
7009a026: e579         	b	0x70099b1c <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x50e
;     return valid;
7009a028: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009a02c: f000 0001    	and	r0, r0, #0x1
7009a030: b01e         	add	sp, #0x78
7009a032: bd80         	pop	{r7, pc}

7009a034 <malloc>:
7009a034: e1a01000     	mov	r1, r0
7009a038: e3a00008     	mov	r0, #8
7009a03c: ea00159d     	b	0x7009f6b8 <memalign>   @ imm = #0x5674

7009a040 <_ftoa>:
; {
7009a040: b570         	push	{r4, r5, r6, lr}
7009a042: b0a2         	sub	sp, #0x88
7009a044: f8dd c0a0    	ldr.w	r12, [sp, #0xa0]
7009a048: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009a04c: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009a050: 9020         	str	r0, [sp, #0x80]
7009a052: 911f         	str	r1, [sp, #0x7c]
7009a054: 921e         	str	r2, [sp, #0x78]
7009a056: 931d         	str	r3, [sp, #0x74]
7009a058: ed8d 0b1a    	vstr	d0, [sp, #104]
7009a05c: 2000         	movs	r0, #0x0
;   size_t len  = 0U;
7009a05e: 9011         	str	r0, [sp, #0x44]
;   double diff = 0.0;
7009a060: 900f         	str	r0, [sp, #0x3c]
7009a062: 900e         	str	r0, [sp, #0x38]
;   if (value != value)
7009a064: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a068: eeb4 0b40    	vcmp.f64	d0, d0
7009a06c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a070: d71a         	bvc	0x7009a0a8 <_ftoa+0x68> @ imm = #0x34
7009a072: e7ff         	b	0x7009a074 <_ftoa+0x34> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
7009a074: 9820         	ldr	r0, [sp, #0x80]
7009a076: 991f         	ldr	r1, [sp, #0x7c]
7009a078: 9a1e         	ldr	r2, [sp, #0x78]
7009a07a: 9b1d         	ldr	r3, [sp, #0x74]
7009a07c: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009a080: 9c28         	ldr	r4, [sp, #0xa0]
7009a082: 46ee         	mov	lr, sp
7009a084: f8ce 400c    	str.w	r4, [lr, #0xc]
7009a088: f8ce c008    	str.w	r12, [lr, #0x8]
7009a08c: f04f 0c03    	mov.w	r12, #0x3
7009a090: f8ce c004    	str.w	r12, [lr, #0x4]
7009a094: f64f 6c6c    	movw	r12, #0xfe6c
7009a098: f2c7 0c0a    	movt	r12, #0x700a
7009a09c: f8ce c000    	str.w	r12, [lr]
7009a0a0: f00b fa86    	bl	0x700a55b0 <_out_rev>   @ imm = #0xb50c
7009a0a4: 9021         	str	r0, [sp, #0x84]
7009a0a6: e257         	b	0x7009a558 <_ftoa+0x518> @ imm = #0x4ae
;   if (value < -DBL_MAX)
7009a0a8: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a0ac: ed9f 1bd2    	vldr	d1, [pc, #840]          @ 0x7009a3f8 <_ftoa+0x3b8>
7009a0b0: eeb4 0b41    	vcmp.f64	d0, d1
7009a0b4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a0b8: d51a         	bpl	0x7009a0f0 <_ftoa+0xb0> @ imm = #0x34
7009a0ba: e7ff         	b	0x7009a0bc <_ftoa+0x7c> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
7009a0bc: 9820         	ldr	r0, [sp, #0x80]
7009a0be: 991f         	ldr	r1, [sp, #0x7c]
7009a0c0: 9a1e         	ldr	r2, [sp, #0x78]
7009a0c2: 9b1d         	ldr	r3, [sp, #0x74]
7009a0c4: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009a0c8: 9c28         	ldr	r4, [sp, #0xa0]
7009a0ca: 46ee         	mov	lr, sp
7009a0cc: f8ce 400c    	str.w	r4, [lr, #0xc]
7009a0d0: f8ce c008    	str.w	r12, [lr, #0x8]
7009a0d4: f04f 0c04    	mov.w	r12, #0x4
7009a0d8: f8ce c004    	str.w	r12, [lr, #0x4]
7009a0dc: f64f 6c49    	movw	r12, #0xfe49
7009a0e0: f2c7 0c0a    	movt	r12, #0x700a
7009a0e4: f8ce c000    	str.w	r12, [lr]
7009a0e8: f00b fa62    	bl	0x700a55b0 <_out_rev>   @ imm = #0xb4c4
7009a0ec: 9021         	str	r0, [sp, #0x84]
7009a0ee: e233         	b	0x7009a558 <_ftoa+0x518> @ imm = #0x466
;   if (value > DBL_MAX)
7009a0f0: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a0f4: ed9f 1bc2    	vldr	d1, [pc, #776]          @ 0x7009a400 <_ftoa+0x3c0>
7009a0f8: eeb4 0b41    	vcmp.f64	d0, d1
7009a0fc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a100: dd26         	ble	0x7009a150 <_ftoa+0x110> @ imm = #0x4c
7009a102: e7ff         	b	0x7009a104 <_ftoa+0xc4> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
7009a104: 9820         	ldr	r0, [sp, #0x80]
7009a106: 991f         	ldr	r1, [sp, #0x7c]
7009a108: 9a1e         	ldr	r2, [sp, #0x78]
7009a10a: 9b1d         	ldr	r3, [sp, #0x74]
7009a10c: 9e28         	ldr	r6, [sp, #0xa0]
7009a10e: f006 0e04    	and	lr, r6, #0x4
7009a112: f64f 6453    	movw	r4, #0xfe53
7009a116: f2c7 040a    	movt	r4, #0x700a
7009a11a: f64f 6c68    	movw	r12, #0xfe68
7009a11e: f2c7 0c0a    	movt	r12, #0x700a
7009a122: f1be 0f00    	cmp.w	lr, #0x0
7009a126: bf18         	it	ne
7009a128: 46a4         	movne	r12, r4
7009a12a: 2403         	movs	r4, #0x3
7009a12c: f1be 0f00    	cmp.w	lr, #0x0
7009a130: bf18         	it	ne
7009a132: 2404         	movne	r4, #0x4
7009a134: 9d27         	ldr	r5, [sp, #0x9c]
7009a136: 46ee         	mov	lr, sp
7009a138: f8ce 600c    	str.w	r6, [lr, #0xc]
7009a13c: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a140: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a144: f8ce c000    	str.w	r12, [lr]
7009a148: f00b fa32    	bl	0x700a55b0 <_out_rev>   @ imm = #0xb464
7009a14c: 9021         	str	r0, [sp, #0x84]
7009a14e: e203         	b	0x7009a558 <_ftoa+0x518> @ imm = #0x406
;   if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
7009a150: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a154: ed9f 1bac    	vldr	d1, [pc, #688]          @ 0x7009a408 <_ftoa+0x3c8>
7009a158: eeb4 0b41    	vcmp.f64	d0, d1
7009a15c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a160: dc0a         	bgt	0x7009a178 <_ftoa+0x138> @ imm = #0x14
7009a162: e7ff         	b	0x7009a164 <_ftoa+0x124> @ imm = #-0x2
7009a164: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a168: ed9f 1ba9    	vldr	d1, [pc, #676]          @ 0x7009a410 <_ftoa+0x3d0>
7009a16c: eeb4 0b41    	vcmp.f64	d0, d1
7009a170: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a174: d515         	bpl	0x7009a1a2 <_ftoa+0x162> @ imm = #0x2a
7009a176: e7ff         	b	0x7009a178 <_ftoa+0x138> @ imm = #-0x2
;     return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009a178: 9820         	ldr	r0, [sp, #0x80]
7009a17a: 991f         	ldr	r1, [sp, #0x7c]
7009a17c: 9a1e         	ldr	r2, [sp, #0x78]
7009a17e: 9b1d         	ldr	r3, [sp, #0x74]
7009a180: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a184: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009a188: 9c27         	ldr	r4, [sp, #0x9c]
7009a18a: 9d28         	ldr	r5, [sp, #0xa0]
7009a18c: 46ee         	mov	lr, sp
7009a18e: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a192: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a196: f8ce c000    	str.w	r12, [lr]
7009a19a: f000 f9e1    	bl	0x7009a560 <_etoa>      @ imm = #0x3c2
7009a19e: 9021         	str	r0, [sp, #0x84]
7009a1a0: e1da         	b	0x7009a558 <_ftoa+0x518> @ imm = #0x3b4
7009a1a2: f04f 0000    	mov.w	r0, #0x0
;   bool negative = false;
7009a1a6: f88d 0037    	strb.w	r0, [sp, #0x37]
;   if (value < 0) {
7009a1aa: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a1ae: eeb5 0b40    	vcmp.f64	d0, #0
7009a1b2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a1b6: d50d         	bpl	0x7009a1d4 <_ftoa+0x194> @ imm = #0x1a
7009a1b8: e7ff         	b	0x7009a1ba <_ftoa+0x17a> @ imm = #-0x2
7009a1ba: f04f 0001    	mov.w	r0, #0x1
;     negative = true;
7009a1be: f88d 0037    	strb.w	r0, [sp, #0x37]
;     value = 0 - value;
7009a1c2: ed9d 1b1a    	vldr	d1, [sp, #104]
7009a1c6: ed9f 0b94    	vldr	d0, [pc, #592]          @ 0x7009a418 <_ftoa+0x3d8>
7009a1ca: ee30 0b41    	vsub.f64	d0, d0, d1
7009a1ce: ed8d 0b1a    	vstr	d0, [sp, #104]
;   }
7009a1d2: e7ff         	b	0x7009a1d4 <_ftoa+0x194> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009a1d4: f89d 00a1    	ldrb.w	r0, [sp, #0xa1]
7009a1d8: ea4f 7040    	lsl.w	r0, r0, #0x1d
7009a1dc: 2800         	cmp	r0, #0x0
7009a1de: d403         	bmi	0x7009a1e8 <_ftoa+0x1a8> @ imm = #0x6
7009a1e0: e7ff         	b	0x7009a1e2 <_ftoa+0x1a2> @ imm = #-0x2
7009a1e2: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009a1e4: 9026         	str	r0, [sp, #0x98]
;   }
7009a1e6: e7ff         	b	0x7009a1e8 <_ftoa+0x1a8> @ imm = #-0x2
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009a1e8: e7ff         	b	0x7009a1ea <_ftoa+0x1aa> @ imm = #-0x2
7009a1ea: 9911         	ldr	r1, [sp, #0x44]
7009a1ec: 2000         	movs	r0, #0x0
7009a1ee: 291f         	cmp	r1, #0x1f
7009a1f0: 9007         	str	r0, [sp, #0x1c]
7009a1f2: d807         	bhi	0x7009a204 <_ftoa+0x1c4> @ imm = #0xe
7009a1f4: e7ff         	b	0x7009a1f6 <_ftoa+0x1b6> @ imm = #-0x2
7009a1f6: 9926         	ldr	r1, [sp, #0x98]
7009a1f8: 2000         	movs	r0, #0x0
7009a1fa: 2909         	cmp	r1, #0x9
7009a1fc: bf88         	it	hi
7009a1fe: 2001         	movhi	r0, #0x1
7009a200: 9007         	str	r0, [sp, #0x1c]
7009a202: e7ff         	b	0x7009a204 <_ftoa+0x1c4> @ imm = #-0x2
7009a204: 9807         	ldr	r0, [sp, #0x1c]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009a206: 07c0         	lsls	r0, r0, #0x1f
7009a208: b150         	cbz	r0, 0x7009a220 <_ftoa+0x1e0> @ imm = #0x14
7009a20a: e7ff         	b	0x7009a20c <_ftoa+0x1cc> @ imm = #-0x2
;     buf[len++] = '0';
7009a20c: 9a11         	ldr	r2, [sp, #0x44]
7009a20e: 1c50         	adds	r0, r2, #0x1
7009a210: 9011         	str	r0, [sp, #0x44]
7009a212: a912         	add	r1, sp, #0x48
7009a214: 2030         	movs	r0, #0x30
7009a216: 5488         	strb	r0, [r1, r2]
;     prec--;
7009a218: 9826         	ldr	r0, [sp, #0x98]
7009a21a: 3801         	subs	r0, #0x1
7009a21c: 9026         	str	r0, [sp, #0x98]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009a21e: e7e4         	b	0x7009a1ea <_ftoa+0x1aa> @ imm = #-0x38
;   int whole = (int)value;
7009a220: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a224: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009a228: ed8d 0a0c    	vstr	s0, [sp, #48]
;   double tmp = (value - whole) * pow10[prec];
7009a22c: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a230: ed9d 1a0c    	vldr	s2, [sp, #48]
7009a234: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009a238: ee30 0b41    	vsub.f64	d0, d0, d1
7009a23c: 9926         	ldr	r1, [sp, #0x98]
7009a23e: f24f 2048    	movw	r0, #0xf248
7009a242: f2c7 000a    	movt	r0, #0x700a
7009a246: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009a24a: ed90 1b00    	vldr	d1, [r0]
7009a24e: ee20 0b01    	vmul.f64	d0, d0, d1
7009a252: ed8d 0b0a    	vstr	d0, [sp, #40]
;   unsigned long frac = (unsigned long)tmp;
7009a256: ed9d 0b0a    	vldr	d0, [sp, #40]
7009a25a: eebc 0bc0    	vcvt.u32.f64	s0, d0
7009a25e: ed8d 0a09    	vstr	s0, [sp, #36]
;   diff = tmp - frac;
7009a262: ed9d 0b0a    	vldr	d0, [sp, #40]
7009a266: ed9d 1a09    	vldr	s2, [sp, #36]
7009a26a: eeb8 1b41    	vcvt.f64.u32	d1, s2
7009a26e: ee30 0b41    	vsub.f64	d0, d0, d1
7009a272: ed8d 0b0e    	vstr	d0, [sp, #56]
;   if (diff > 0.5) {
7009a276: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a27a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a27e: eeb4 0b41    	vcmp.f64	d0, d1
7009a282: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a286: dd1e         	ble	0x7009a2c6 <_ftoa+0x286> @ imm = #0x3c
7009a288: e7ff         	b	0x7009a28a <_ftoa+0x24a> @ imm = #-0x2
;     ++frac;
7009a28a: 9809         	ldr	r0, [sp, #0x24]
7009a28c: 3001         	adds	r0, #0x1
7009a28e: 9009         	str	r0, [sp, #0x24]
;     if (frac >= pow10[prec]) {
7009a290: ed9d 0a09    	vldr	s0, [sp, #36]
7009a294: eeb8 0b40    	vcvt.f64.u32	d0, s0
7009a298: 9926         	ldr	r1, [sp, #0x98]
7009a29a: f24f 2048    	movw	r0, #0xf248
7009a29e: f2c7 000a    	movt	r0, #0x700a
7009a2a2: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009a2a6: ed90 1b00    	vldr	d1, [r0]
7009a2aa: eeb4 0b41    	vcmp.f64	d0, d1
7009a2ae: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a2b2: db07         	blt	0x7009a2c4 <_ftoa+0x284> @ imm = #0xe
7009a2b4: e7ff         	b	0x7009a2b6 <_ftoa+0x276> @ imm = #-0x2
7009a2b6: f04f 0000    	mov.w	r0, #0x0
;       frac = 0;
7009a2ba: 9009         	str	r0, [sp, #0x24]
;       ++whole;
7009a2bc: 980c         	ldr	r0, [sp, #0x30]
7009a2be: 3001         	adds	r0, #0x1
7009a2c0: 900c         	str	r0, [sp, #0x30]
;     }
7009a2c2: e7ff         	b	0x7009a2c4 <_ftoa+0x284> @ imm = #-0x2
;   }
7009a2c4: e018         	b	0x7009a2f8 <_ftoa+0x2b8> @ imm = #0x30
;   else if (diff < 0.5) {
7009a2c6: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a2ca: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a2ce: eeb4 0b41    	vcmp.f64	d0, d1
7009a2d2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a2d6: d501         	bpl	0x7009a2dc <_ftoa+0x29c> @ imm = #0x2
7009a2d8: e7ff         	b	0x7009a2da <_ftoa+0x29a> @ imm = #-0x2
;   }
7009a2da: e00c         	b	0x7009a2f6 <_ftoa+0x2b6> @ imm = #0x18
;   else if ((frac == 0U) || (frac & 1U)) {
7009a2dc: 9809         	ldr	r0, [sp, #0x24]
7009a2de: b128         	cbz	r0, 0x7009a2ec <_ftoa+0x2ac> @ imm = #0xa
7009a2e0: e7ff         	b	0x7009a2e2 <_ftoa+0x2a2> @ imm = #-0x2
7009a2e2: f89d 0024    	ldrb.w	r0, [sp, #0x24]
7009a2e6: 07c0         	lsls	r0, r0, #0x1f
7009a2e8: b120         	cbz	r0, 0x7009a2f4 <_ftoa+0x2b4> @ imm = #0x8
7009a2ea: e7ff         	b	0x7009a2ec <_ftoa+0x2ac> @ imm = #-0x2
;     ++frac;
7009a2ec: 9809         	ldr	r0, [sp, #0x24]
7009a2ee: 3001         	adds	r0, #0x1
7009a2f0: 9009         	str	r0, [sp, #0x24]
;   }
7009a2f2: e7ff         	b	0x7009a2f4 <_ftoa+0x2b4> @ imm = #-0x2
7009a2f4: e7ff         	b	0x7009a2f6 <_ftoa+0x2b6> @ imm = #-0x2
7009a2f6: e7ff         	b	0x7009a2f8 <_ftoa+0x2b8> @ imm = #-0x2
;   if (prec == 0U) {
7009a2f8: 9826         	ldr	r0, [sp, #0x98]
7009a2fa: bb48         	cbnz	r0, 0x7009a350 <_ftoa+0x310> @ imm = #0x52
7009a2fc: e7ff         	b	0x7009a2fe <_ftoa+0x2be> @ imm = #-0x2
;     diff = value - (double)whole;
7009a2fe: ed9d 0b1a    	vldr	d0, [sp, #104]
7009a302: ed9d 1a0c    	vldr	s2, [sp, #48]
7009a306: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009a30a: ee30 0b41    	vsub.f64	d0, d0, d1
7009a30e: ed8d 0b0e    	vstr	d0, [sp, #56]
;     if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
7009a312: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a316: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a31a: eeb4 0b41    	vcmp.f64	d0, d1
7009a31e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a322: d50a         	bpl	0x7009a33a <_ftoa+0x2fa> @ imm = #0x14
7009a324: e7ff         	b	0x7009a326 <_ftoa+0x2e6> @ imm = #-0x2
7009a326: ed9d 0b0e    	vldr	d0, [sp, #56]
7009a32a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a32e: eeb4 0b41    	vcmp.f64	d0, d1
7009a332: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a336: dd0a         	ble	0x7009a34e <_ftoa+0x30e> @ imm = #0x14
7009a338: e7ff         	b	0x7009a33a <_ftoa+0x2fa> @ imm = #-0x2
7009a33a: f89d 0030    	ldrb.w	r0, [sp, #0x30]
7009a33e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009a342: b120         	cbz	r0, 0x7009a34e <_ftoa+0x30e> @ imm = #0x8
7009a344: e7ff         	b	0x7009a346 <_ftoa+0x306> @ imm = #-0x2
;       ++whole;
7009a346: 980c         	ldr	r0, [sp, #0x30]
7009a348: 3001         	adds	r0, #0x1
7009a34a: 900c         	str	r0, [sp, #0x30]
;     }
7009a34c: e7ff         	b	0x7009a34e <_ftoa+0x30e> @ imm = #-0x2
;   }
7009a34e: e04d         	b	0x7009a3ec <_ftoa+0x3ac> @ imm = #0x9a
;     unsigned int count = prec;
7009a350: 9826         	ldr	r0, [sp, #0x98]
7009a352: 9008         	str	r0, [sp, #0x20]
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a354: e7ff         	b	0x7009a356 <_ftoa+0x316> @ imm = #-0x2
7009a356: 9811         	ldr	r0, [sp, #0x44]
7009a358: 281f         	cmp	r0, #0x1f
7009a35a: d821         	bhi	0x7009a3a0 <_ftoa+0x360> @ imm = #0x42
7009a35c: e7ff         	b	0x7009a35e <_ftoa+0x31e> @ imm = #-0x2
;       --count;
7009a35e: 9808         	ldr	r0, [sp, #0x20]
7009a360: 3801         	subs	r0, #0x1
7009a362: 9008         	str	r0, [sp, #0x20]
;       buf[len++] = (char)(48U + (frac % 10U));
7009a364: 9809         	ldr	r0, [sp, #0x24]
7009a366: f64c 41cd    	movw	r1, #0xcccd
7009a36a: f6cc 41cc    	movt	r1, #0xcccc
7009a36e: fba0 3201    	umull	r3, r2, r0, r1
7009a372: ea4f 02d2    	lsr.w	r2, r2, #0x3
7009a376: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009a37a: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009a37e: f040 0030    	orr	r0, r0, #0x30
7009a382: 9b11         	ldr	r3, [sp, #0x44]
7009a384: 1c5a         	adds	r2, r3, #0x1
7009a386: 9211         	str	r2, [sp, #0x44]
7009a388: aa12         	add	r2, sp, #0x48
7009a38a: 54d0         	strb	r0, [r2, r3]
;       if (!(frac /= 10U)) {
7009a38c: 9809         	ldr	r0, [sp, #0x24]
7009a38e: fba0 1001    	umull	r1, r0, r0, r1
7009a392: ea4f 00d0    	lsr.w	r0, r0, #0x3
7009a396: 9009         	str	r0, [sp, #0x24]
7009a398: b908         	cbnz	r0, 0x7009a39e <_ftoa+0x35e> @ imm = #0x2
7009a39a: e7ff         	b	0x7009a39c <_ftoa+0x35c> @ imm = #-0x2
;         break;
7009a39c: e000         	b	0x7009a3a0 <_ftoa+0x360> @ imm = #0x0
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a39e: e7da         	b	0x7009a356 <_ftoa+0x316> @ imm = #-0x4c
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009a3a0: e7ff         	b	0x7009a3a2 <_ftoa+0x362> @ imm = #-0x2
7009a3a2: 9911         	ldr	r1, [sp, #0x44]
7009a3a4: 2000         	movs	r0, #0x0
7009a3a6: 291f         	cmp	r1, #0x1f
7009a3a8: 9006         	str	r0, [sp, #0x18]
7009a3aa: d808         	bhi	0x7009a3be <_ftoa+0x37e> @ imm = #0x10
7009a3ac: e7ff         	b	0x7009a3ae <_ftoa+0x36e> @ imm = #-0x2
7009a3ae: 9808         	ldr	r0, [sp, #0x20]
7009a3b0: 1e41         	subs	r1, r0, #0x1
7009a3b2: 9108         	str	r1, [sp, #0x20]
7009a3b4: 2800         	cmp	r0, #0x0
7009a3b6: bf18         	it	ne
7009a3b8: 2001         	movne	r0, #0x1
7009a3ba: 9006         	str	r0, [sp, #0x18]
7009a3bc: e7ff         	b	0x7009a3be <_ftoa+0x37e> @ imm = #-0x2
7009a3be: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009a3c0: 07c0         	lsls	r0, r0, #0x1f
7009a3c2: b138         	cbz	r0, 0x7009a3d4 <_ftoa+0x394> @ imm = #0xe
7009a3c4: e7ff         	b	0x7009a3c6 <_ftoa+0x386> @ imm = #-0x2
;       buf[len++] = '0';
7009a3c6: 9a11         	ldr	r2, [sp, #0x44]
7009a3c8: 1c50         	adds	r0, r2, #0x1
7009a3ca: 9011         	str	r0, [sp, #0x44]
7009a3cc: a912         	add	r1, sp, #0x48
7009a3ce: 2030         	movs	r0, #0x30
7009a3d0: 5488         	strb	r0, [r1, r2]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009a3d2: e7e6         	b	0x7009a3a2 <_ftoa+0x362> @ imm = #-0x34
;     if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a3d4: 9811         	ldr	r0, [sp, #0x44]
7009a3d6: 281f         	cmp	r0, #0x1f
7009a3d8: d807         	bhi	0x7009a3ea <_ftoa+0x3aa> @ imm = #0xe
7009a3da: e7ff         	b	0x7009a3dc <_ftoa+0x39c> @ imm = #-0x2
;       buf[len++] = '.';
7009a3dc: 9a11         	ldr	r2, [sp, #0x44]
7009a3de: 1c50         	adds	r0, r2, #0x1
7009a3e0: 9011         	str	r0, [sp, #0x44]
7009a3e2: a912         	add	r1, sp, #0x48
7009a3e4: 202e         	movs	r0, #0x2e
7009a3e6: 5488         	strb	r0, [r1, r2]
;     }
7009a3e8: e7ff         	b	0x7009a3ea <_ftoa+0x3aa> @ imm = #-0x2
7009a3ea: e7ff         	b	0x7009a3ec <_ftoa+0x3ac> @ imm = #-0x2
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a3ec: e7ff         	b	0x7009a3ee <_ftoa+0x3ae> @ imm = #-0x2
7009a3ee: 9811         	ldr	r0, [sp, #0x44]
7009a3f0: 281f         	cmp	r0, #0x1f
7009a3f2: d835         	bhi	0x7009a460 <_ftoa+0x420> @ imm = #0x6a
7009a3f4: e014         	b	0x7009a420 <_ftoa+0x3e0> @ imm = #0x28
7009a3f6: bf00         	nop
7009a3f8: ff ff ff ff  	.word	0xffffffff
7009a3fc: ff ff ef ff  	.word	0xffefffff
7009a400: ff ff ff ff  	.word	0xffffffff
7009a404: ff ff ef 7f  	.word	0x7fefffff
7009a408: 00 00 00 00  	.word	0x00000000
7009a40c: 65 cd cd 41  	.word	0x41cdcd65
7009a410: 00 00 00 00  	.word	0x00000000
7009a414: 65 cd cd c1  	.word	0xc1cdcd65
7009a418: 00 00 00 00  	.word	0x00000000
7009a41c: 00 00 00 00  	.word	0x00000000
;     buf[len++] = (char)(48 + (whole % 10));
7009a420: 980c         	ldr	r0, [sp, #0x30]
7009a422: f246 6167    	movw	r1, #0x6667
7009a426: f2c6 6166    	movt	r1, #0x6666
7009a42a: fb50 f301    	smmul	r3, r0, r1
7009a42e: 089a         	lsrs	r2, r3, #0x2
7009a430: eb02 72d3    	add.w	r2, r2, r3, lsr #31
7009a434: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009a438: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009a43c: 3030         	adds	r0, #0x30
7009a43e: 9b11         	ldr	r3, [sp, #0x44]
7009a440: 1c5a         	adds	r2, r3, #0x1
7009a442: 9211         	str	r2, [sp, #0x44]
7009a444: aa12         	add	r2, sp, #0x48
7009a446: 54d0         	strb	r0, [r2, r3]
;     if (!(whole /= 10)) {
7009a448: 980c         	ldr	r0, [sp, #0x30]
7009a44a: fb50 f101    	smmul	r1, r0, r1
7009a44e: ea4f 00a1    	asr.w	r0, r1, #0x2
7009a452: eb00 70d1    	add.w	r0, r0, r1, lsr #31
7009a456: 900c         	str	r0, [sp, #0x30]
7009a458: b908         	cbnz	r0, 0x7009a45e <_ftoa+0x41e> @ imm = #0x2
7009a45a: e7ff         	b	0x7009a45c <_ftoa+0x41c> @ imm = #-0x2
;       break;
7009a45c: e000         	b	0x7009a460 <_ftoa+0x420> @ imm = #0x0
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a45e: e7c6         	b	0x7009a3ee <_ftoa+0x3ae> @ imm = #-0x74
;   if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
7009a460: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a464: 0780         	lsls	r0, r0, #0x1e
7009a466: 2800         	cmp	r0, #0x0
7009a468: d432         	bmi	0x7009a4d0 <_ftoa+0x490> @ imm = #0x64
7009a46a: e7ff         	b	0x7009a46c <_ftoa+0x42c> @ imm = #-0x2
7009a46c: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a470: 07c0         	lsls	r0, r0, #0x1f
7009a472: b368         	cbz	r0, 0x7009a4d0 <_ftoa+0x490> @ imm = #0x5a
7009a474: e7ff         	b	0x7009a476 <_ftoa+0x436> @ imm = #-0x2
;     if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009a476: 9827         	ldr	r0, [sp, #0x9c]
7009a478: b178         	cbz	r0, 0x7009a49a <_ftoa+0x45a> @ imm = #0x1e
7009a47a: e7ff         	b	0x7009a47c <_ftoa+0x43c> @ imm = #-0x2
7009a47c: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009a480: 07c0         	lsls	r0, r0, #0x1f
7009a482: b930         	cbnz	r0, 0x7009a492 <_ftoa+0x452> @ imm = #0xc
7009a484: e7ff         	b	0x7009a486 <_ftoa+0x446> @ imm = #-0x2
7009a486: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a48a: f010 0f0c    	tst.w	r0, #0xc
7009a48e: d004         	beq	0x7009a49a <_ftoa+0x45a> @ imm = #0x8
7009a490: e7ff         	b	0x7009a492 <_ftoa+0x452> @ imm = #-0x2
;       width--;
7009a492: 9827         	ldr	r0, [sp, #0x9c]
7009a494: 3801         	subs	r0, #0x1
7009a496: 9027         	str	r0, [sp, #0x9c]
;     }
7009a498: e7ff         	b	0x7009a49a <_ftoa+0x45a> @ imm = #-0x2
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009a49a: e7ff         	b	0x7009a49c <_ftoa+0x45c> @ imm = #-0x2
7009a49c: 9911         	ldr	r1, [sp, #0x44]
7009a49e: 9a27         	ldr	r2, [sp, #0x9c]
7009a4a0: 2000         	movs	r0, #0x0
7009a4a2: 4291         	cmp	r1, r2
7009a4a4: 9005         	str	r0, [sp, #0x14]
7009a4a6: d207         	bhs	0x7009a4b8 <_ftoa+0x478> @ imm = #0xe
7009a4a8: e7ff         	b	0x7009a4aa <_ftoa+0x46a> @ imm = #-0x2
7009a4aa: 9911         	ldr	r1, [sp, #0x44]
7009a4ac: 2000         	movs	r0, #0x0
7009a4ae: 2920         	cmp	r1, #0x20
7009a4b0: bf38         	it	lo
7009a4b2: 2001         	movlo	r0, #0x1
7009a4b4: 9005         	str	r0, [sp, #0x14]
7009a4b6: e7ff         	b	0x7009a4b8 <_ftoa+0x478> @ imm = #-0x2
7009a4b8: 9805         	ldr	r0, [sp, #0x14]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009a4ba: 07c0         	lsls	r0, r0, #0x1f
7009a4bc: b138         	cbz	r0, 0x7009a4ce <_ftoa+0x48e> @ imm = #0xe
7009a4be: e7ff         	b	0x7009a4c0 <_ftoa+0x480> @ imm = #-0x2
;       buf[len++] = '0';
7009a4c0: 9a11         	ldr	r2, [sp, #0x44]
7009a4c2: 1c50         	adds	r0, r2, #0x1
7009a4c4: 9011         	str	r0, [sp, #0x44]
7009a4c6: a912         	add	r1, sp, #0x48
7009a4c8: 2030         	movs	r0, #0x30
7009a4ca: 5488         	strb	r0, [r1, r2]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009a4cc: e7e6         	b	0x7009a49c <_ftoa+0x45c> @ imm = #-0x34
;   }
7009a4ce: e7ff         	b	0x7009a4d0 <_ftoa+0x490> @ imm = #-0x2
;   if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009a4d0: 9811         	ldr	r0, [sp, #0x44]
7009a4d2: 281f         	cmp	r0, #0x1f
7009a4d4: d829         	bhi	0x7009a52a <_ftoa+0x4ea> @ imm = #0x52
7009a4d6: e7ff         	b	0x7009a4d8 <_ftoa+0x498> @ imm = #-0x2
;     if (negative) {
7009a4d8: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009a4dc: 07c0         	lsls	r0, r0, #0x1f
7009a4de: b138         	cbz	r0, 0x7009a4f0 <_ftoa+0x4b0> @ imm = #0xe
7009a4e0: e7ff         	b	0x7009a4e2 <_ftoa+0x4a2> @ imm = #-0x2
;       buf[len++] = '-';
7009a4e2: 9a11         	ldr	r2, [sp, #0x44]
7009a4e4: 1c50         	adds	r0, r2, #0x1
7009a4e6: 9011         	str	r0, [sp, #0x44]
7009a4e8: a912         	add	r1, sp, #0x48
7009a4ea: 202d         	movs	r0, #0x2d
7009a4ec: 5488         	strb	r0, [r1, r2]
;     }
7009a4ee: e01b         	b	0x7009a528 <_ftoa+0x4e8> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009a4f0: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a4f4: 0740         	lsls	r0, r0, #0x1d
7009a4f6: 2800         	cmp	r0, #0x0
7009a4f8: d507         	bpl	0x7009a50a <_ftoa+0x4ca> @ imm = #0xe
7009a4fa: e7ff         	b	0x7009a4fc <_ftoa+0x4bc> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009a4fc: 9a11         	ldr	r2, [sp, #0x44]
7009a4fe: 1c50         	adds	r0, r2, #0x1
7009a500: 9011         	str	r0, [sp, #0x44]
7009a502: a912         	add	r1, sp, #0x48
7009a504: 202b         	movs	r0, #0x2b
7009a506: 5488         	strb	r0, [r1, r2]
;     }
7009a508: e00d         	b	0x7009a526 <_ftoa+0x4e6> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009a50a: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009a50e: 0700         	lsls	r0, r0, #0x1c
7009a510: 2800         	cmp	r0, #0x0
7009a512: d507         	bpl	0x7009a524 <_ftoa+0x4e4> @ imm = #0xe
7009a514: e7ff         	b	0x7009a516 <_ftoa+0x4d6> @ imm = #-0x2
;       buf[len++] = ' ';
7009a516: 9a11         	ldr	r2, [sp, #0x44]
7009a518: 1c50         	adds	r0, r2, #0x1
7009a51a: 9011         	str	r0, [sp, #0x44]
7009a51c: a912         	add	r1, sp, #0x48
7009a51e: 2020         	movs	r0, #0x20
7009a520: 5488         	strb	r0, [r1, r2]
;     }
7009a522: e7ff         	b	0x7009a524 <_ftoa+0x4e4> @ imm = #-0x2
7009a524: e7ff         	b	0x7009a526 <_ftoa+0x4e6> @ imm = #-0x2
7009a526: e7ff         	b	0x7009a528 <_ftoa+0x4e8> @ imm = #-0x2
;   }
7009a528: e7ff         	b	0x7009a52a <_ftoa+0x4ea> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009a52a: 9820         	ldr	r0, [sp, #0x80]
7009a52c: 991f         	ldr	r1, [sp, #0x7c]
7009a52e: 9a1e         	ldr	r2, [sp, #0x78]
7009a530: 9b1d         	ldr	r3, [sp, #0x74]
7009a532: f8dd c044    	ldr.w	r12, [sp, #0x44]
7009a536: 9c27         	ldr	r4, [sp, #0x9c]
7009a538: 9d28         	ldr	r5, [sp, #0xa0]
7009a53a: 46ee         	mov	lr, sp
7009a53c: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a540: f8ce 4008    	str.w	r4, [lr, #0x8]
7009a544: f8ce c004    	str.w	r12, [lr, #0x4]
7009a548: f10d 0c48    	add.w	r12, sp, #0x48
7009a54c: f8ce c000    	str.w	r12, [lr]
7009a550: f00b f82e    	bl	0x700a55b0 <_out_rev>   @ imm = #0xb05c
7009a554: 9021         	str	r0, [sp, #0x84]
7009a556: e7ff         	b	0x7009a558 <_ftoa+0x518> @ imm = #-0x2
; }
7009a558: 9821         	ldr	r0, [sp, #0x84]
7009a55a: b022         	add	sp, #0x88
7009a55c: bd70         	pop	{r4, r5, r6, pc}
7009a55e: 0000         	movs	r0, r0

7009a560 <_etoa>:
; {
7009a560: b570         	push	{r4, r5, r6, lr}
7009a562: b0a8         	sub	sp, #0xa0
7009a564: f8dd c0b8    	ldr.w	r12, [sp, #0xb8]
7009a568: f8dd c0b4    	ldr.w	r12, [sp, #0xb4]
7009a56c: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009a570: 9026         	str	r0, [sp, #0x98]
7009a572: 9125         	str	r1, [sp, #0x94]
7009a574: 9224         	str	r2, [sp, #0x90]
7009a576: 9323         	str	r3, [sp, #0x8c]
7009a578: ed8d 0b20    	vstr	d0, [sp, #128]
;   if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
7009a57c: ed9d 0b20    	vldr	d0, [sp, #128]
7009a580: eeb4 0b40    	vcmp.f64	d0, d0
7009a584: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a588: d614         	bvs	0x7009a5b4 <_etoa+0x54> @ imm = #0x28
7009a58a: e7ff         	b	0x7009a58c <_etoa+0x2c> @ imm = #-0x2
7009a58c: ed9d 0b20    	vldr	d0, [sp, #128]
7009a590: ed9f 1bdb    	vldr	d1, [pc, #876]          @ 0x7009a900 <_etoa+0x3a0>
7009a594: eeb4 0b41    	vcmp.f64	d0, d1
7009a598: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a59c: dc0a         	bgt	0x7009a5b4 <_etoa+0x54> @ imm = #0x14
7009a59e: e7ff         	b	0x7009a5a0 <_etoa+0x40> @ imm = #-0x2
7009a5a0: ed9d 0b20    	vldr	d0, [sp, #128]
7009a5a4: ed9f 1bd8    	vldr	d1, [pc, #864]          @ 0x7009a908 <_etoa+0x3a8>
7009a5a8: eeb4 0b41    	vcmp.f64	d0, d1
7009a5ac: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a5b0: d515         	bpl	0x7009a5de <_etoa+0x7e> @ imm = #0x2a
7009a5b2: e7ff         	b	0x7009a5b4 <_etoa+0x54> @ imm = #-0x2
;     return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009a5b4: 9826         	ldr	r0, [sp, #0x98]
7009a5b6: 9925         	ldr	r1, [sp, #0x94]
7009a5b8: 9a24         	ldr	r2, [sp, #0x90]
7009a5ba: 9b23         	ldr	r3, [sp, #0x8c]
7009a5bc: ed9d 0b20    	vldr	d0, [sp, #128]
7009a5c0: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009a5c4: 9c2d         	ldr	r4, [sp, #0xb4]
7009a5c6: 9d2e         	ldr	r5, [sp, #0xb8]
7009a5c8: 46ee         	mov	lr, sp
7009a5ca: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a5ce: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a5d2: f8ce c000    	str.w	r12, [lr]
7009a5d6: f7ff fd33    	bl	0x7009a040 <_ftoa>      @ imm = #-0x59a
7009a5da: 9027         	str	r0, [sp, #0x9c]
7009a5dc: e1d8         	b	0x7009a990 <_etoa+0x430> @ imm = #0x3b0
;   const bool negative = value < 0;
7009a5de: ed9d 0b20    	vldr	d0, [sp, #128]
7009a5e2: f04f 0000    	mov.w	r0, #0x0
7009a5e6: eeb5 0b40    	vcmp.f64	d0, #0
7009a5ea: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a5ee: bf48         	it	mi
7009a5f0: 2001         	movmi	r0, #0x1
7009a5f2: f88d 007f    	strb.w	r0, [sp, #0x7f]
;   if (negative) {
7009a5f6: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009a5fa: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009a5fe: b138         	cbz	r0, 0x7009a610 <_etoa+0xb0> @ imm = #0xe
7009a600: e7ff         	b	0x7009a602 <_etoa+0xa2> @ imm = #-0x2
;     value = -value;
7009a602: ed9d 0b20    	vldr	d0, [sp, #128]
7009a606: eeb1 0b40    	vneg.f64	d0, d0
7009a60a: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009a60e: e7ff         	b	0x7009a610 <_etoa+0xb0> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009a610: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009a614: 0740         	lsls	r0, r0, #0x1d
7009a616: 2800         	cmp	r0, #0x0
7009a618: d403         	bmi	0x7009a622 <_etoa+0xc2> @ imm = #0x6
7009a61a: e7ff         	b	0x7009a61c <_etoa+0xbc> @ imm = #-0x2
7009a61c: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009a61e: 902c         	str	r0, [sp, #0xb0]
;   }
7009a620: e7ff         	b	0x7009a622 <_etoa+0xc2> @ imm = #-0x2
;   conv.F = value;
7009a622: ed9d 0b20    	vldr	d0, [sp, #128]
7009a626: ed8d 0b1c    	vstr	d0, [sp, #112]
;   int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
7009a62a: 981d         	ldr	r0, [sp, #0x74]
7009a62c: f3c0 500a    	ubfx	r0, r0, #0x14, #0xb
7009a630: f2a0 30ff    	subw	r0, r0, #0x3ff
7009a634: 901b         	str	r0, [sp, #0x6c]
;   conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
7009a636: 981d         	ldr	r0, [sp, #0x74]
7009a638: f240 31ff    	movw	r1, #0x3ff
7009a63c: f361 501f    	bfi	r0, r1, #20, #12
7009a640: 901d         	str	r0, [sp, #0x74]
;   int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
7009a642: ed9d 0a1b    	vldr	s0, [sp, #108]
7009a646: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009a64a: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009a998 <_etoa+0x438>
7009a64e: ee20 0b01    	vmul.f64	d0, d0, d1
7009a652: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009a9a0 <_etoa+0x440>
7009a656: ee30 1b01    	vadd.f64	d1, d0, d1
7009a65a: ed9d 0b1c    	vldr	d0, [sp, #112]
7009a65e: eebf 2b08    	vmov.f64	d2, #-1.500000e+00
7009a662: ee30 0b02    	vadd.f64	d0, d0, d2
7009a666: ed9f 2bd0    	vldr	d2, [pc, #832]          @ 0x7009a9a8 <_etoa+0x448>
7009a66a: ee20 0b02    	vmul.f64	d0, d0, d2
7009a66e: ee30 0b01    	vadd.f64	d0, d0, d1
7009a672: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009a676: ed8d 0a1a    	vstr	s0, [sp, #104]
;   exp2 = (int)(expval * 3.321928094887362 + 0.5);
7009a67a: ed9d 0a1a    	vldr	s0, [sp, #104]
7009a67e: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009a682: ed9f 1bcb    	vldr	d1, [pc, #812]          @ 0x7009a9b0 <_etoa+0x450>
7009a686: ee20 0b01    	vmul.f64	d0, d0, d1
7009a68a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009a68e: ee30 0b01    	vadd.f64	d0, d0, d1
7009a692: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009a696: ed8d 0a1b    	vstr	s0, [sp, #108]
;   const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
7009a69a: ed9d 0a1a    	vldr	s0, [sp, #104]
7009a69e: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009a6a2: ed9d 1a1b    	vldr	s2, [sp, #108]
7009a6a6: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009a6aa: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009a9b8 <_etoa+0x458>
7009a6ae: ee21 1b02    	vmul.f64	d1, d1, d2
7009a6b2: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009a9c0 <_etoa+0x460>
7009a6b6: ee20 0b02    	vmul.f64	d0, d0, d2
7009a6ba: ee30 0b01    	vadd.f64	d0, d0, d1
7009a6be: ed8d 0b18    	vstr	d0, [sp, #96]
;   const double z2 = z * z;
7009a6c2: ed9d 0b18    	vldr	d0, [sp, #96]
7009a6c6: ee20 0b00    	vmul.f64	d0, d0, d0
7009a6ca: ed8d 0b16    	vstr	d0, [sp, #88]
;   conv.U = (uint64_t)(exp2 + 1023) << 52U;
7009a6ce: 981b         	ldr	r0, [sp, #0x6c]
7009a6d0: f200 30ff    	addw	r0, r0, #0x3ff
7009a6d4: 0500         	lsls	r0, r0, #0x14
7009a6d6: 2100         	movs	r1, #0x0
7009a6d8: 911c         	str	r1, [sp, #0x70]
7009a6da: 901d         	str	r0, [sp, #0x74]
;   conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
7009a6dc: ed9d 2b18    	vldr	d2, [sp, #96]
7009a6e0: ee32 0b02    	vadd.f64	d0, d2, d2
7009a6e4: eeb0 1b00    	vmov.f64	d1, #2.000000e+00
7009a6e8: ee31 1b42    	vsub.f64	d1, d1, d2
7009a6ec: ed9d 2b16    	vldr	d2, [sp, #88]
7009a6f0: eeb2 3b0c    	vmov.f64	d3, #1.400000e+01
7009a6f4: ee82 3b03    	vdiv.f64	d3, d2, d3
7009a6f8: eeb2 4b04    	vmov.f64	d4, #1.000000e+01
7009a6fc: ee33 3b04    	vadd.f64	d3, d3, d4
7009a700: ee82 3b03    	vdiv.f64	d3, d2, d3
7009a704: eeb1 4b08    	vmov.f64	d4, #6.000000e+00
7009a708: ee33 3b04    	vadd.f64	d3, d3, d4
7009a70c: ee82 2b03    	vdiv.f64	d2, d2, d3
7009a710: ee31 1b02    	vadd.f64	d1, d1, d2
7009a714: ee80 0b01    	vdiv.f64	d0, d0, d1
7009a718: eeb7 1b00    	vmov.f64	d1, #1.000000e+00
7009a71c: ee30 1b01    	vadd.f64	d1, d0, d1
7009a720: ed9d 0b1c    	vldr	d0, [sp, #112]
7009a724: ee20 0b01    	vmul.f64	d0, d0, d1
7009a728: ed8d 0b1c    	vstr	d0, [sp, #112]
;   if (value < conv.F) {
7009a72c: ed9d 0b20    	vldr	d0, [sp, #128]
7009a730: ed9d 1b1c    	vldr	d1, [sp, #112]
7009a734: eeb4 0b41    	vcmp.f64	d0, d1
7009a738: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a73c: d50c         	bpl	0x7009a758 <_etoa+0x1f8> @ imm = #0x18
7009a73e: e7ff         	b	0x7009a740 <_etoa+0x1e0> @ imm = #-0x2
;     expval--;
7009a740: 981a         	ldr	r0, [sp, #0x68]
7009a742: 3801         	subs	r0, #0x1
7009a744: 901a         	str	r0, [sp, #0x68]
;     conv.F /= 10;
7009a746: ed9d 0b1c    	vldr	d0, [sp, #112]
7009a74a: eeb2 1b04    	vmov.f64	d1, #1.000000e+01
7009a74e: ee80 0b01    	vdiv.f64	d0, d0, d1
7009a752: ed8d 0b1c    	vstr	d0, [sp, #112]
;   }
7009a756: e7ff         	b	0x7009a758 <_etoa+0x1f8> @ imm = #-0x2
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009a758: 991a         	ldr	r1, [sp, #0x68]
7009a75a: f04f 0000    	mov.w	r0, #0x0
7009a75e: 2963         	cmp	r1, #0x63
7009a760: 9012         	str	r0, [sp, #0x48]
7009a762: dc08         	bgt	0x7009a776 <_etoa+0x216> @ imm = #0x10
7009a764: e7ff         	b	0x7009a766 <_etoa+0x206> @ imm = #-0x2
7009a766: 991a         	ldr	r1, [sp, #0x68]
7009a768: 2000         	movs	r0, #0x0
7009a76a: f111 0f64    	cmn.w	r1, #0x64
7009a76e: bfc8         	it	gt
7009a770: 2001         	movgt	r0, #0x1
7009a772: 9012         	str	r0, [sp, #0x48]
7009a774: e7ff         	b	0x7009a776 <_etoa+0x216> @ imm = #-0x2
7009a776: 9812         	ldr	r0, [sp, #0x48]
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009a778: 07c1         	lsls	r1, r0, #0x1f
7009a77a: 2005         	movs	r0, #0x5
7009a77c: 2900         	cmp	r1, #0x0
7009a77e: bf18         	it	ne
7009a780: 2004         	movne	r0, #0x4
7009a782: 9015         	str	r0, [sp, #0x54]
;   if (flags & FLAGS_ADAPT_EXP) {
7009a784: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009a788: ea4f 7000    	lsl.w	r0, r0, #0x1c
7009a78c: 2800         	cmp	r0, #0x0
7009a78e: d539         	bpl	0x7009a804 <_etoa+0x2a4> @ imm = #0x72
7009a790: e7ff         	b	0x7009a792 <_etoa+0x232> @ imm = #-0x2
;     if ((value >= 1e-4) && (value < 1e6)) {
7009a792: ed9d 0b20    	vldr	d0, [sp, #128]
7009a796: ed9f 1b8c    	vldr	d1, [pc, #560]          @ 0x7009a9c8 <_etoa+0x468>
7009a79a: eeb4 0b41    	vcmp.f64	d0, d1
7009a79e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a7a2: db20         	blt	0x7009a7e6 <_etoa+0x286> @ imm = #0x40
7009a7a4: e7ff         	b	0x7009a7a6 <_etoa+0x246> @ imm = #-0x2
7009a7a6: ed9d 0b20    	vldr	d0, [sp, #128]
7009a7aa: ed9f 1b89    	vldr	d1, [pc, #548]          @ 0x7009a9d0 <_etoa+0x470>
7009a7ae: eeb4 0b41    	vcmp.f64	d0, d1
7009a7b2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009a7b6: d516         	bpl	0x7009a7e6 <_etoa+0x286> @ imm = #0x2c
7009a7b8: e7ff         	b	0x7009a7ba <_etoa+0x25a> @ imm = #-0x2
;       if ((int)prec > expval) {
7009a7ba: 982c         	ldr	r0, [sp, #0xb0]
7009a7bc: 991a         	ldr	r1, [sp, #0x68]
7009a7be: 4288         	cmp	r0, r1
7009a7c0: dd06         	ble	0x7009a7d0 <_etoa+0x270> @ imm = #0xc
7009a7c2: e7ff         	b	0x7009a7c4 <_etoa+0x264> @ imm = #-0x2
;         prec = (unsigned)((int)prec - expval - 1);
7009a7c4: 992c         	ldr	r1, [sp, #0xb0]
7009a7c6: 981a         	ldr	r0, [sp, #0x68]
7009a7c8: 43c0         	mvns	r0, r0
7009a7ca: 4408         	add	r0, r1
7009a7cc: 902c         	str	r0, [sp, #0xb0]
;       }
7009a7ce: e002         	b	0x7009a7d6 <_etoa+0x276> @ imm = #0x4
7009a7d0: 2000         	movs	r0, #0x0
;         prec = 0;
7009a7d2: 902c         	str	r0, [sp, #0xb0]
7009a7d4: e7ff         	b	0x7009a7d6 <_etoa+0x276> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
7009a7d6: 982e         	ldr	r0, [sp, #0xb8]
7009a7d8: f440 6080    	orr	r0, r0, #0x400
7009a7dc: 902e         	str	r0, [sp, #0xb8]
7009a7de: 2000         	movs	r0, #0x0
;       minwidth = 0U;
7009a7e0: 9015         	str	r0, [sp, #0x54]
;       expval   = 0;
7009a7e2: 901a         	str	r0, [sp, #0x68]
;     }
7009a7e4: e00d         	b	0x7009a802 <_etoa+0x2a2> @ imm = #0x1a
;       if ((prec > 0) && (flags & FLAGS_PRECISION)) {
7009a7e6: 982c         	ldr	r0, [sp, #0xb0]
7009a7e8: b150         	cbz	r0, 0x7009a800 <_etoa+0x2a0> @ imm = #0x14
7009a7ea: e7ff         	b	0x7009a7ec <_etoa+0x28c> @ imm = #-0x2
7009a7ec: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009a7f0: 0740         	lsls	r0, r0, #0x1d
7009a7f2: 2800         	cmp	r0, #0x0
7009a7f4: d504         	bpl	0x7009a800 <_etoa+0x2a0> @ imm = #0x8
7009a7f6: e7ff         	b	0x7009a7f8 <_etoa+0x298> @ imm = #-0x2
;         --prec;
7009a7f8: 982c         	ldr	r0, [sp, #0xb0]
7009a7fa: 3801         	subs	r0, #0x1
7009a7fc: 902c         	str	r0, [sp, #0xb0]
;       }
7009a7fe: e7ff         	b	0x7009a800 <_etoa+0x2a0> @ imm = #-0x2
7009a800: e7ff         	b	0x7009a802 <_etoa+0x2a2> @ imm = #-0x2
;   }
7009a802: e7ff         	b	0x7009a804 <_etoa+0x2a4> @ imm = #-0x2
;   unsigned int fwidth = width;
7009a804: 982d         	ldr	r0, [sp, #0xb4]
7009a806: 9014         	str	r0, [sp, #0x50]
;   if (width > minwidth) {
7009a808: 982d         	ldr	r0, [sp, #0xb4]
7009a80a: 9915         	ldr	r1, [sp, #0x54]
7009a80c: 4288         	cmp	r0, r1
7009a80e: d905         	bls	0x7009a81c <_etoa+0x2bc> @ imm = #0xa
7009a810: e7ff         	b	0x7009a812 <_etoa+0x2b2> @ imm = #-0x2
;     fwidth -= minwidth;
7009a812: 9915         	ldr	r1, [sp, #0x54]
7009a814: 9814         	ldr	r0, [sp, #0x50]
7009a816: 1a40         	subs	r0, r0, r1
7009a818: 9014         	str	r0, [sp, #0x50]
;   } else {
7009a81a: e002         	b	0x7009a822 <_etoa+0x2c2> @ imm = #0x4
7009a81c: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009a81e: 9014         	str	r0, [sp, #0x50]
7009a820: e7ff         	b	0x7009a822 <_etoa+0x2c2> @ imm = #-0x2
;   if ((flags & FLAGS_LEFT) && minwidth) {
7009a822: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009a826: 0780         	lsls	r0, r0, #0x1e
7009a828: 2800         	cmp	r0, #0x0
7009a82a: d506         	bpl	0x7009a83a <_etoa+0x2da> @ imm = #0xc
7009a82c: e7ff         	b	0x7009a82e <_etoa+0x2ce> @ imm = #-0x2
7009a82e: 9815         	ldr	r0, [sp, #0x54]
7009a830: b118         	cbz	r0, 0x7009a83a <_etoa+0x2da> @ imm = #0x6
7009a832: e7ff         	b	0x7009a834 <_etoa+0x2d4> @ imm = #-0x2
7009a834: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009a836: 9014         	str	r0, [sp, #0x50]
;   }
7009a838: e7ff         	b	0x7009a83a <_etoa+0x2da> @ imm = #-0x2
;   if (expval) {
7009a83a: 981a         	ldr	r0, [sp, #0x68]
7009a83c: b148         	cbz	r0, 0x7009a852 <_etoa+0x2f2> @ imm = #0x12
7009a83e: e7ff         	b	0x7009a840 <_etoa+0x2e0> @ imm = #-0x2
;     value /= conv.F;
7009a840: ed9d 1b1c    	vldr	d1, [sp, #112]
7009a844: ed9d 0b20    	vldr	d0, [sp, #128]
7009a848: ee80 0b01    	vdiv.f64	d0, d0, d1
7009a84c: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009a850: e7ff         	b	0x7009a852 <_etoa+0x2f2> @ imm = #-0x2
;   const size_t start_idx = idx;
7009a852: 9824         	ldr	r0, [sp, #0x90]
7009a854: 9013         	str	r0, [sp, #0x4c]
;   idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
7009a856: 9826         	ldr	r0, [sp, #0x98]
7009a858: 900e         	str	r0, [sp, #0x38]
7009a85a: 9825         	ldr	r0, [sp, #0x94]
7009a85c: 900f         	str	r0, [sp, #0x3c]
7009a85e: 9824         	ldr	r0, [sp, #0x90]
7009a860: 9010         	str	r0, [sp, #0x40]
7009a862: 9823         	ldr	r0, [sp, #0x8c]
7009a864: 9011         	str	r0, [sp, #0x44]
7009a866: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009a86a: 07c0         	lsls	r0, r0, #0x1f
7009a86c: b138         	cbz	r0, 0x7009a87e <_etoa+0x31e> @ imm = #0xe
7009a86e: e7ff         	b	0x7009a870 <_etoa+0x310> @ imm = #-0x2
7009a870: ed9d 0b20    	vldr	d0, [sp, #128]
7009a874: eeb1 0b40    	vneg.f64	d0, d0
7009a878: ed8d 0b0c    	vstr	d0, [sp, #48]
7009a87c: e004         	b	0x7009a888 <_etoa+0x328> @ imm = #0x8
7009a87e: ed9d 0b20    	vldr	d0, [sp, #128]
7009a882: ed8d 0b0c    	vstr	d0, [sp, #48]
7009a886: e7ff         	b	0x7009a888 <_etoa+0x328> @ imm = #-0x2
7009a888: 9b11         	ldr	r3, [sp, #0x44]
7009a88a: 9a10         	ldr	r2, [sp, #0x40]
7009a88c: 990f         	ldr	r1, [sp, #0x3c]
7009a88e: 980e         	ldr	r0, [sp, #0x38]
7009a890: ed9d 0b0c    	vldr	d0, [sp, #48]
7009a894: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009a898: 9c14         	ldr	r4, [sp, #0x50]
7009a89a: f8dd e0b8    	ldr.w	lr, [sp, #0xb8]
7009a89e: f42e 6500    	bic	r5, lr, #0x800
7009a8a2: 46ee         	mov	lr, sp
7009a8a4: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a8a8: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a8ac: f8ce c000    	str.w	r12, [lr]
7009a8b0: f7ff fbc6    	bl	0x7009a040 <_ftoa>      @ imm = #-0x874
7009a8b4: 9024         	str	r0, [sp, #0x90]
;   if (minwidth) {
7009a8b6: 9815         	ldr	r0, [sp, #0x54]
7009a8b8: 2800         	cmp	r0, #0x0
7009a8ba: d066         	beq	0x7009a98a <_etoa+0x42a> @ imm = #0xcc
7009a8bc: e7ff         	b	0x7009a8be <_etoa+0x35e> @ imm = #-0x2
;     out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
7009a8be: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009a8c2: 982e         	ldr	r0, [sp, #0xb8]
7009a8c4: 0681         	lsls	r1, r0, #0x1a
7009a8c6: 2065         	movs	r0, #0x65
7009a8c8: 2900         	cmp	r1, #0x0
7009a8ca: bf48         	it	mi
7009a8cc: 2045         	movmi	r0, #0x45
7009a8ce: 9925         	ldr	r1, [sp, #0x94]
7009a8d0: 9a24         	ldr	r2, [sp, #0x90]
7009a8d2: 1c53         	adds	r3, r2, #0x1
7009a8d4: 9324         	str	r3, [sp, #0x90]
7009a8d6: 9b23         	ldr	r3, [sp, #0x8c]
7009a8d8: 47e0         	blx	r12
;     idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
7009a8da: 9826         	ldr	r0, [sp, #0x98]
7009a8dc: 9008         	str	r0, [sp, #0x20]
7009a8de: 9825         	ldr	r0, [sp, #0x94]
7009a8e0: 9009         	str	r0, [sp, #0x24]
7009a8e2: 9824         	ldr	r0, [sp, #0x90]
7009a8e4: 900a         	str	r0, [sp, #0x28]
7009a8e6: 9823         	ldr	r0, [sp, #0x8c]
7009a8e8: 900b         	str	r0, [sp, #0x2c]
7009a8ea: 981a         	ldr	r0, [sp, #0x68]
7009a8ec: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009a8f0: dc0e         	bgt	0x7009a910 <_etoa+0x3b0> @ imm = #0x1c
7009a8f2: e7ff         	b	0x7009a8f4 <_etoa+0x394> @ imm = #-0x2
7009a8f4: 981a         	ldr	r0, [sp, #0x68]
7009a8f6: 4240         	rsbs	r0, r0, #0
7009a8f8: 9007         	str	r0, [sp, #0x1c]
7009a8fa: e00c         	b	0x7009a916 <_etoa+0x3b6> @ imm = #0x18
7009a8fc: bf00         	nop
7009a8fe: bf00         	nop
7009a900: ff ff ff ff  	.word	0xffffffff
7009a904: ff ff ef 7f  	.word	0x7fefffff
7009a908: ff ff ff ff  	.word	0xffffffff
7009a90c: ff ff ef ff  	.word	0xffefffff
7009a910: 981a         	ldr	r0, [sp, #0x68]
7009a912: 9007         	str	r0, [sp, #0x1c]
7009a914: e7ff         	b	0x7009a916 <_etoa+0x3b6> @ imm = #-0x2
7009a916: 9b0b         	ldr	r3, [sp, #0x2c]
7009a918: 9a0a         	ldr	r2, [sp, #0x28]
7009a91a: 9909         	ldr	r1, [sp, #0x24]
7009a91c: 9808         	ldr	r0, [sp, #0x20]
7009a91e: f8dd c01c    	ldr.w	r12, [sp, #0x1c]
7009a922: 9c1a         	ldr	r4, [sp, #0x68]
7009a924: f8dd e054    	ldr.w	lr, [sp, #0x54]
7009a928: f1ae 0501    	sub.w	r5, lr, #0x1
7009a92c: 46ee         	mov	lr, sp
7009a92e: 2605         	movs	r6, #0x5
7009a930: f8ce 6014    	str.w	r6, [lr, #0x14]
7009a934: f8ce 5010    	str.w	r5, [lr, #0x10]
7009a938: 2500         	movs	r5, #0x0
7009a93a: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a93e: 250a         	movs	r5, #0xa
7009a940: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a944: ea4f 74d4    	lsr.w	r4, r4, #0x1f
7009a948: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a94c: f8ce c000    	str.w	r12, [lr]
7009a950: f008 fbc6    	bl	0x700a30e0 <_ntoa_long> @ imm = #0x878c
7009a954: 9024         	str	r0, [sp, #0x90]
;     if (flags & FLAGS_LEFT) {
7009a956: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009a95a: 0780         	lsls	r0, r0, #0x1e
7009a95c: 2800         	cmp	r0, #0x0
7009a95e: d513         	bpl	0x7009a988 <_etoa+0x428> @ imm = #0x26
7009a960: e7ff         	b	0x7009a962 <_etoa+0x402> @ imm = #-0x2
;       while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
7009a962: e7ff         	b	0x7009a964 <_etoa+0x404> @ imm = #-0x2
7009a964: 9824         	ldr	r0, [sp, #0x90]
7009a966: 9913         	ldr	r1, [sp, #0x4c]
7009a968: 1a40         	subs	r0, r0, r1
7009a96a: 992d         	ldr	r1, [sp, #0xb4]
7009a96c: 4288         	cmp	r0, r1
7009a96e: d20a         	bhs	0x7009a986 <_etoa+0x426> @ imm = #0x14
7009a970: e7ff         	b	0x7009a972 <_etoa+0x412> @ imm = #-0x2
7009a972: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009a976: 9925         	ldr	r1, [sp, #0x94]
7009a978: 9a24         	ldr	r2, [sp, #0x90]
7009a97a: 1c50         	adds	r0, r2, #0x1
7009a97c: 9024         	str	r0, [sp, #0x90]
7009a97e: 9b23         	ldr	r3, [sp, #0x8c]
7009a980: 2020         	movs	r0, #0x20
7009a982: 47e0         	blx	r12
7009a984: e7ee         	b	0x7009a964 <_etoa+0x404> @ imm = #-0x24
;     }
7009a986: e7ff         	b	0x7009a988 <_etoa+0x428> @ imm = #-0x2
;   }
7009a988: e7ff         	b	0x7009a98a <_etoa+0x42a> @ imm = #-0x2
;   return idx;
7009a98a: 9824         	ldr	r0, [sp, #0x90]
7009a98c: 9027         	str	r0, [sp, #0x9c]
7009a98e: e7ff         	b	0x7009a990 <_etoa+0x430> @ imm = #-0x2
; }
7009a990: 9827         	ldr	r0, [sp, #0x9c]
7009a992: b028         	add	sp, #0xa0
7009a994: bd70         	pop	{r4, r5, r6, pc}
7009a996: bf00         	nop
7009a998: fb 79 9f 50  	.word	0x509f79fb
7009a99c: 13 44 d3 3f  	.word	0x3fd34413
7009a9a0: b3 c8 60 8b  	.word	0x8b60c8b3
7009a9a4: 28 8a c6 3f  	.word	0x3fc68a28
7009a9a8: 61 43 6f 63  	.word	0x636f4361
7009a9ac: a7 87 d2 3f  	.word	0x3fd287a7
7009a9b0: 71 a3 79 09  	.word	0x0979a371
7009a9b4: 4f 93 0a 40  	.word	0x400a934f
7009a9b8: ef 39 fa fe  	.word	0xfefa39ef
7009a9bc: 42 2e e6 bf  	.word	0xbfe62e42
7009a9c0: 16 55 b5 bb  	.word	0xbbb55516
7009a9c4: b1 6b 02 40  	.word	0x40026bb1
7009a9c8: 2d 43 1c eb  	.word	0xeb1c432d
7009a9cc: e2 36 1a 3f  	.word	0x3f1a36e2
7009a9d0: 00 00 00 00  	.word	0x00000000
7009a9d4: 80 84 2e 41  	.word	0x412e8480

7009a9d8 <__aeabi_ldiv0>:
7009a9d8: e12fff1e     	bx	lr

7009a9dc <__aeabi_memcpy8>:
7009a9dc: ea001214     	b	0x7009f234 <memcpy>     @ imm = #0x4850

7009a9e0 <UART_open>:
; {
7009a9e0: b580         	push	{r7, lr}
7009a9e2: b092         	sub	sp, #0x48
7009a9e4: 9011         	str	r0, [sp, #0x44]
7009a9e6: 9110         	str	r1, [sp, #0x40]
7009a9e8: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS;
7009a9ea: 900f         	str	r0, [sp, #0x3c]
;     UART_Handle         handle = NULL;
7009a9ec: 900e         	str	r0, [sp, #0x38]
;     UART_Config        *config = NULL;
7009a9ee: 900d         	str	r0, [sp, #0x34]
;     UART_Object        *object    = NULL;
7009a9f0: 900c         	str	r0, [sp, #0x30]
;     if(index >= gUartConfigNum)
7009a9f2: 9811         	ldr	r0, [sp, #0x44]
7009a9f4: f240 11bc    	movw	r1, #0x1bc
7009a9f8: f2c7 010b    	movt	r1, #0x700b
7009a9fc: 6809         	ldr	r1, [r1]
7009a9fe: 4288         	cmp	r0, r1
7009aa00: d304         	blo	0x7009aa0c <UART_open+0x2c> @ imm = #0x8
7009aa02: e7ff         	b	0x7009aa04 <UART_open+0x24> @ imm = #-0x2
7009aa04: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009aa08: 900f         	str	r0, [sp, #0x3c]
;     }
7009aa0a: e008         	b	0x7009aa1e <UART_open+0x3e> @ imm = #0x10
;         config = &gUartConfig[index];
7009aa0c: 9911         	ldr	r1, [sp, #0x44]
7009aa0e: f240 1080    	movw	r0, #0x180
7009aa12: f2c7 000b    	movt	r0, #0x700b
7009aa16: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009aa1a: 900d         	str	r0, [sp, #0x34]
7009aa1c: e7ff         	b	0x7009aa1e <UART_open+0x3e> @ imm = #-0x2
;     DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009aa1e: f64f 7150    	movw	r1, #0xff50
7009aa22: f2c7 010a    	movt	r1, #0x700a
7009aa26: f851 0b04    	ldr	r0, [r1], #4
7009aa2a: 9103         	str	r1, [sp, #0xc]
7009aa2c: 2800         	cmp	r0, #0x0
7009aa2e: bf18         	it	ne
7009aa30: 2001         	movne	r0, #0x1
7009aa32: f24f 61a8    	movw	r1, #0xf6a8
7009aa36: f2c7 010a    	movt	r1, #0x700a
7009aa3a: 466a         	mov	r2, sp
7009aa3c: 6011         	str	r1, [r2]
7009aa3e: f64f 01a2    	movw	r1, #0xf8a2
7009aa42: f2c7 010a    	movt	r1, #0x700a
7009aa46: f64f 12a2    	movw	r2, #0xf9a2
7009aa4a: f2c7 020a    	movt	r2, #0x700a
7009aa4e: f240 1301    	movw	r3, #0x101
7009aa52: f00e f8a5    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xe14a
7009aa56: 9803         	ldr	r0, [sp, #0xc]
7009aa58: f04f 31ff    	mov.w	r1, #0xffffffff
;     (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009aa5c: f00d fe48    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0xdc90
;     if(SystemP_SUCCESS  == status)
7009aa60: 980f         	ldr	r0, [sp, #0x3c]
7009aa62: bb38         	cbnz	r0, 0x7009aab4 <UART_open+0xd4> @ imm = #0x4e
7009aa64: e7ff         	b	0x7009aa66 <UART_open+0x86> @ imm = #-0x2
;         object = config->object;
7009aa66: 980d         	ldr	r0, [sp, #0x34]
7009aa68: 6840         	ldr	r0, [r0, #0x4]
7009aa6a: 900c         	str	r0, [sp, #0x30]
;         attrs  = config->attrs;
7009aa6c: 980d         	ldr	r0, [sp, #0x34]
7009aa6e: 6800         	ldr	r0, [r0]
7009aa70: 900b         	str	r0, [sp, #0x2c]
;         DebugP_assert(NULL_PTR != object);
7009aa72: 980c         	ldr	r0, [sp, #0x30]
7009aa74: 2800         	cmp	r0, #0x0
7009aa76: bf18         	it	ne
7009aa78: 2001         	movne	r0, #0x1
7009aa7a: f64f 017c    	movw	r1, #0xf87c
7009aa7e: f2c7 010a    	movt	r1, #0x700a
7009aa82: 466a         	mov	r2, sp
7009aa84: 6011         	str	r1, [r2]
7009aa86: f64f 01a2    	movw	r1, #0xf8a2
7009aa8a: f2c7 010a    	movt	r1, #0x700a
7009aa8e: f64f 12a2    	movw	r2, #0xf9a2
7009aa92: f2c7 020a    	movt	r2, #0x700a
7009aa96: f44f 7384    	mov.w	r3, #0x108
7009aa9a: f00e f881    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xe102
;         if(TRUE == object->isOpen)
7009aa9e: 980c         	ldr	r0, [sp, #0x30]
7009aaa0: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009aaa4: 2801         	cmp	r0, #0x1
7009aaa6: d104         	bne	0x7009aab2 <UART_open+0xd2> @ imm = #0x8
7009aaa8: e7ff         	b	0x7009aaaa <UART_open+0xca> @ imm = #-0x2
7009aaaa: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009aaae: 900f         	str	r0, [sp, #0x3c]
;         }
7009aab0: e7ff         	b	0x7009aab2 <UART_open+0xd2> @ imm = #-0x2
;     }
7009aab2: e7ff         	b	0x7009aab4 <UART_open+0xd4> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009aab4: 980f         	ldr	r0, [sp, #0x3c]
7009aab6: 2800         	cmp	r0, #0x0
7009aab8: f040 80cd    	bne.w	0x7009ac56 <UART_open+0x276> @ imm = #0x19a
7009aabc: e7ff         	b	0x7009aabe <UART_open+0xde> @ imm = #-0x2
;         object->handle = (UART_Handle) config;
7009aabe: 980d         	ldr	r0, [sp, #0x34]
7009aac0: 990c         	ldr	r1, [sp, #0x30]
7009aac2: 6008         	str	r0, [r1]
;         if(NULL != prms)
7009aac4: 9810         	ldr	r0, [sp, #0x40]
7009aac6: b138         	cbz	r0, 0x7009aad8 <UART_open+0xf8> @ imm = #0xe
7009aac8: e7ff         	b	0x7009aaca <UART_open+0xea> @ imm = #-0x2
;             ( void )memcpy(&object->prms, prms, sizeof(UART_Params));
7009aaca: 980c         	ldr	r0, [sp, #0x30]
7009aacc: 3004         	adds	r0, #0x4
7009aace: 9910         	ldr	r1, [sp, #0x40]
7009aad0: 2258         	movs	r2, #0x58
7009aad2: f7ff ef84    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0xf8
;         }
7009aad6: e004         	b	0x7009aae2 <UART_open+0x102> @ imm = #0x8
;             UART_Params_init(&object->prms);
7009aad8: 980c         	ldr	r0, [sp, #0x30]
7009aada: 3004         	adds	r0, #0x4
7009aadc: f00e f8e0    	bl	0x700a8ca0 <UART_Params_init> @ imm = #0xe1c0
7009aae0: e7ff         	b	0x7009aae2 <UART_open+0x102> @ imm = #-0x2
;         object->uartLld_handle             = &object->uartLld_object;
7009aae2: 990c         	ldr	r1, [sp, #0x30]
7009aae4: f501 7022    	add.w	r0, r1, #0x288
7009aae8: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle                     = object->uartLld_handle;
7009aaec: 980c         	ldr	r0, [sp, #0x30]
7009aaee: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009aaf2: 9005         	str	r0, [sp, #0x14]
;         object->uartLld_initHandle         = &object->uartLld_initObject;
7009aaf4: 990c         	ldr	r1, [sp, #0x30]
7009aaf6: f501 7040    	add.w	r0, r1, #0x300
7009aafa: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;         uartLldInit_handle                 = object->uartLld_initHandle;
7009aafe: 980c         	ldr	r0, [sp, #0x30]
7009ab00: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
7009ab04: 9004         	str	r0, [sp, #0x10]
;         uartLld_handle->hUartInit          = uartLldInit_handle;
7009ab06: 9804         	ldr	r0, [sp, #0x10]
7009ab08: 9905         	ldr	r1, [sp, #0x14]
7009ab0a: 6048         	str	r0, [r1, #0x4]
;         uartLld_handle->baseAddr           = attrs->baseAddr;
7009ab0c: 980b         	ldr	r0, [sp, #0x2c]
7009ab0e: 6800         	ldr	r0, [r0]
7009ab10: 9905         	ldr	r1, [sp, #0x14]
7009ab12: 6008         	str	r0, [r1]
;         uartLld_handle->args               = (void *)object->handle;
7009ab14: 980c         	ldr	r0, [sp, #0x30]
7009ab16: 6800         	ldr	r0, [r0]
7009ab18: 9905         	ldr	r1, [sp, #0x14]
7009ab1a: 6608         	str	r0, [r1, #0x60]
;         uartLld_handle->writeBuf           = object->writeBuf;
7009ab1c: 980c         	ldr	r0, [sp, #0x30]
7009ab1e: 6dc0         	ldr	r0, [r0, #0x5c]
7009ab20: 9905         	ldr	r1, [sp, #0x14]
7009ab22: 6088         	str	r0, [r1, #0x8]
;         uartLld_handle->writeCount         = object->writeCount;
7009ab24: 980c         	ldr	r0, [sp, #0x30]
7009ab26: 6e00         	ldr	r0, [r0, #0x60]
7009ab28: 9905         	ldr	r1, [sp, #0x14]
7009ab2a: 60c8         	str	r0, [r1, #0xc]
;         uartLld_handle->writeSizeRemaining = object->writeSizeRemaining;
7009ab2c: 980c         	ldr	r0, [sp, #0x30]
7009ab2e: 6e40         	ldr	r0, [r0, #0x64]
7009ab30: 9905         	ldr	r1, [sp, #0x14]
7009ab32: 6108         	str	r0, [r1, #0x10]
;         uartLld_handle->readBuf            = object->readBuf;
7009ab34: 980c         	ldr	r0, [sp, #0x30]
7009ab36: 6e80         	ldr	r0, [r0, #0x68]
7009ab38: 9905         	ldr	r1, [sp, #0x14]
7009ab3a: 6148         	str	r0, [r1, #0x14]
;         uartLld_handle->readCount          = object->readCount;
7009ab3c: 980c         	ldr	r0, [sp, #0x30]
7009ab3e: 6ec0         	ldr	r0, [r0, #0x6c]
7009ab40: 9905         	ldr	r1, [sp, #0x14]
7009ab42: 6188         	str	r0, [r1, #0x18]
;         uartLld_handle->readSizeRemaining  = object->readSizeRemaining;
7009ab44: 980c         	ldr	r0, [sp, #0x30]
7009ab46: 6f00         	ldr	r0, [r0, #0x70]
7009ab48: 9905         	ldr	r1, [sp, #0x14]
7009ab4a: 61c8         	str	r0, [r1, #0x1c]
;         uartLld_handle->rxTimeoutCnt       = object->rxTimeoutCnt;
7009ab4c: 980c         	ldr	r0, [sp, #0x30]
7009ab4e: 6f40         	ldr	r0, [r0, #0x74]
7009ab50: 9905         	ldr	r1, [sp, #0x14]
7009ab52: 6208         	str	r0, [r1, #0x20]
;         uartLld_handle->readErrorCnt       = object->readErrorCnt;
7009ab54: 980c         	ldr	r0, [sp, #0x30]
7009ab56: 6f80         	ldr	r0, [r0, #0x78]
7009ab58: 9905         	ldr	r1, [sp, #0x14]
7009ab5a: 6248         	str	r0, [r1, #0x24]
;         uartLld_handle->state              = UART_STATE_RESET;
7009ab5c: 9905         	ldr	r1, [sp, #0x14]
7009ab5e: 2000         	movs	r0, #0x0
7009ab60: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->inputClkFreq      = attrs->inputClkFreq;
7009ab62: 990b         	ldr	r1, [sp, #0x2c]
7009ab64: 6849         	ldr	r1, [r1, #0x4]
7009ab66: 9a04         	ldr	r2, [sp, #0x10]
7009ab68: 6011         	str	r1, [r2]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009ab6a: 990c         	ldr	r1, [sp, #0x30]
7009ab6c: 6849         	ldr	r1, [r1, #0x4]
7009ab6e: 9a04         	ldr	r2, [sp, #0x10]
7009ab70: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009ab72: 990c         	ldr	r1, [sp, #0x30]
7009ab74: 6849         	ldr	r1, [r1, #0x4]
7009ab76: 9a04         	ldr	r2, [sp, #0x10]
7009ab78: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->dataLength        = object->prms.dataLength;
7009ab7a: 990c         	ldr	r1, [sp, #0x30]
7009ab7c: 6889         	ldr	r1, [r1, #0x8]
7009ab7e: 9a04         	ldr	r2, [sp, #0x10]
7009ab80: 6091         	str	r1, [r2, #0x8]
;         uartLldInit_handle->stopBits          = object->prms.stopBits;
7009ab82: 990c         	ldr	r1, [sp, #0x30]
7009ab84: 68c9         	ldr	r1, [r1, #0xc]
7009ab86: 9a04         	ldr	r2, [sp, #0x10]
7009ab88: 60d1         	str	r1, [r2, #0xc]
;         uartLldInit_handle->parityType        = object->prms.parityType;
7009ab8a: 990c         	ldr	r1, [sp, #0x30]
7009ab8c: 6909         	ldr	r1, [r1, #0x10]
7009ab8e: 9a04         	ldr	r2, [sp, #0x10]
7009ab90: 6111         	str	r1, [r2, #0x10]
;         uartLldInit_handle->readReturnMode    = object->prms.readReturnMode;
7009ab92: 990c         	ldr	r1, [sp, #0x30]
7009ab94: 6989         	ldr	r1, [r1, #0x18]
7009ab96: 9a04         	ldr	r2, [sp, #0x10]
7009ab98: 6151         	str	r1, [r2, #0x14]
;         uartLldInit_handle->hwFlowControl     = object->prms.hwFlowControl;
7009ab9a: 990c         	ldr	r1, [sp, #0x30]
7009ab9c: 6a89         	ldr	r1, [r1, #0x28]
7009ab9e: 9a04         	ldr	r2, [sp, #0x10]
7009aba0: 6191         	str	r1, [r2, #0x18]
;         uartLldInit_handle->hwFlowControlThr  = object->prms.hwFlowControlThr;
7009aba2: 990c         	ldr	r1, [sp, #0x30]
7009aba4: 6ac9         	ldr	r1, [r1, #0x2c]
7009aba6: 9a04         	ldr	r2, [sp, #0x10]
7009aba8: 61d1         	str	r1, [r2, #0x1c]
;         uartLldInit_handle->intrNum           = object->prms.intrNum;
7009abaa: 990c         	ldr	r1, [sp, #0x30]
7009abac: 6b49         	ldr	r1, [r1, #0x34]
7009abae: 9a04         	ldr	r2, [sp, #0x10]
7009abb0: 6251         	str	r1, [r2, #0x24]
;         uartLldInit_handle->transferMode      = object->prms.transferMode;
7009abb2: 990c         	ldr	r1, [sp, #0x30]
7009abb4: 6b09         	ldr	r1, [r1, #0x30]
7009abb6: 9a04         	ldr	r2, [sp, #0x10]
7009abb8: 6211         	str	r1, [r2, #0x20]
;         uartLldInit_handle->intrPriority      = object->prms.intrPriority;
7009abba: 990c         	ldr	r1, [sp, #0x30]
7009abbc: f891 1038    	ldrb.w	r1, [r1, #0x38]
7009abc0: 9a04         	ldr	r2, [sp, #0x10]
7009abc2: f882 1028    	strb.w	r1, [r2, #0x28]
;         uartLldInit_handle->operMode          = object->prms.operMode;
7009abc6: 990c         	ldr	r1, [sp, #0x30]
7009abc8: 6c49         	ldr	r1, [r1, #0x44]
7009abca: 9a04         	ldr	r2, [sp, #0x10]
7009abcc: 62d1         	str	r1, [r2, #0x2c]
;         uartLldInit_handle->rxTrigLvl         = object->prms.rxTrigLvl;
7009abce: 990c         	ldr	r1, [sp, #0x30]
7009abd0: 6c89         	ldr	r1, [r1, #0x48]
7009abd2: 9a04         	ldr	r2, [sp, #0x10]
7009abd4: 6391         	str	r1, [r2, #0x38]
;         uartLldInit_handle->txTrigLvl         = object->prms.txTrigLvl;
7009abd6: 990c         	ldr	r1, [sp, #0x30]
7009abd8: 6cc9         	ldr	r1, [r1, #0x4c]
7009abda: 9a04         	ldr	r2, [sp, #0x10]
7009abdc: 63d1         	str	r1, [r2, #0x3c]
;         uartLldInit_handle->uartDmaHandle     = NULL;
7009abde: 9904         	ldr	r1, [sp, #0x10]
7009abe0: 6488         	str	r0, [r1, #0x48]
;         uartLldInit_handle->dmaChCfg          = NULL;
7009abe2: 9904         	ldr	r1, [sp, #0x10]
7009abe4: 64c8         	str	r0, [r1, #0x4c]
;         uartLldInit_handle->rxEvtNum          = object->prms.rxEvtNum;
7009abe6: 980c         	ldr	r0, [sp, #0x30]
7009abe8: 6d00         	ldr	r0, [r0, #0x50]
7009abea: 9904         	ldr	r1, [sp, #0x10]
7009abec: 6408         	str	r0, [r1, #0x40]
;         uartLldInit_handle->txEvtNum          = object->prms.txEvtNum;
7009abee: 980c         	ldr	r0, [sp, #0x30]
7009abf0: 6d40         	ldr	r0, [r0, #0x54]
7009abf2: 9904         	ldr	r1, [sp, #0x10]
7009abf4: 6448         	str	r0, [r1, #0x44]
;         uartLldInit_handle->writeMode         = object->prms.writeMode;
7009abf6: 980c         	ldr	r0, [sp, #0x30]
7009abf8: 69c0         	ldr	r0, [r0, #0x1c]
7009abfa: 9904         	ldr	r1, [sp, #0x10]
7009abfc: 6348         	str	r0, [r1, #0x34]
;         uartLldInit_handle->readMode          = object->prms.readMode;
7009abfe: 980c         	ldr	r0, [sp, #0x30]
7009ac00: 6940         	ldr	r0, [r0, #0x14]
7009ac02: 9904         	ldr	r1, [sp, #0x10]
7009ac04: 6308         	str	r0, [r1, #0x30]
;         uartLldInit_handle->timeGuardVal      = object->prms.timeGuardVal;
7009ac06: 980c         	ldr	r0, [sp, #0x30]
7009ac08: 6d80         	ldr	r0, [r0, #0x58]
7009ac0a: 9904         	ldr	r1, [sp, #0x10]
7009ac0c: 6508         	str	r0, [r1, #0x50]
;         uartLldInit_handle->clockP_get        = ClockP_getTicks;
7009ac0e: 9904         	ldr	r1, [sp, #0x10]
7009ac10: f24d 7091    	movw	r0, #0xd791
7009ac14: f2c7 000a    	movt	r0, #0x700a
7009ac18: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->clockP_usecToTick = ClockP_usecToTicks;
7009ac1a: 9904         	ldr	r1, [sp, #0x10]
7009ac1c: f64c 60e1    	movw	r0, #0xcee1
7009ac20: f2c7 000a    	movt	r0, #0x700a
7009ac24: 6588         	str	r0, [r1, #0x58]
;         uartLldInit_handle->readCompleteCallbackFxn =  UART_lld_readCompleteCallback;
7009ac26: 9904         	ldr	r1, [sp, #0x10]
7009ac28: f24a 50c1    	movw	r0, #0xa5c1
7009ac2c: f2c7 000a    	movt	r0, #0x700a
7009ac30: 65c8         	str	r0, [r1, #0x5c]
;         uartLldInit_handle->writeCompleteCallbackFxn = UART_lld_writeCompleteCallback;
7009ac32: 9904         	ldr	r1, [sp, #0x10]
7009ac34: f24a 5001    	movw	r0, #0xa501
7009ac38: f2c7 000a    	movt	r0, #0x700a
7009ac3c: 6608         	str	r0, [r1, #0x60]
;         uartLldInit_handle->errorCallbackFxn =         UART_lld_errorCallback;
7009ac3e: 9904         	ldr	r1, [sp, #0x10]
7009ac40: f24d 70a1    	movw	r0, #0xd7a1
7009ac44: f2c7 000a    	movt	r0, #0x700a
7009ac48: 6648         	str	r0, [r1, #0x64]
;         status = UART_checkOpenParams(&object->prms);
7009ac4a: 980c         	ldr	r0, [sp, #0x30]
7009ac4c: 3004         	adds	r0, #0x4
7009ac4e: f010 fddf    	bl	0x700ab810 <UART_checkOpenParams> @ imm = #0x10bbe
7009ac52: 900f         	str	r0, [sp, #0x3c]
;     }
7009ac54: e7ff         	b	0x7009ac56 <UART_open+0x276> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009ac56: 980f         	ldr	r0, [sp, #0x3c]
7009ac58: 2800         	cmp	r0, #0x0
7009ac5a: f040 80b8    	bne.w	0x7009adce <UART_open+0x3ee> @ imm = #0x170
7009ac5e: e7ff         	b	0x7009ac60 <UART_open+0x280> @ imm = #-0x2
;         uartLld_handle->state = UART_STATE_RESET;
7009ac60: 9905         	ldr	r1, [sp, #0x14]
7009ac62: 2000         	movs	r0, #0x0
7009ac64: 6548         	str	r0, [r1, #0x54]
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009ac66: 980c         	ldr	r0, [sp, #0x30]
7009ac68: 6b00         	ldr	r0, [r0, #0x30]
7009ac6a: 2803         	cmp	r0, #0x3
7009ac6c: d117         	bne	0x7009ac9e <UART_open+0x2be> @ imm = #0x2e
7009ac6e: e7ff         	b	0x7009ac70 <UART_open+0x290> @ imm = #-0x2
;             uartLldInit_handle->uartDmaHandle = (UART_DmaHandle) gUartDmaHandle[index];
7009ac70: 9911         	ldr	r1, [sp, #0x44]
7009ac72: f64f 6098    	movw	r0, #0xfe98
7009ac76: f2c7 000a    	movt	r0, #0x700a
7009ac7a: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009ac7e: 9904         	ldr	r1, [sp, #0x10]
7009ac80: 6488         	str	r0, [r1, #0x48]
;             uartLldInit_handle->dmaChCfg      = gUartDmaChConfig[index];
7009ac82: 9911         	ldr	r1, [sp, #0x44]
7009ac84: f240 10c0    	movw	r0, #0x1c0
7009ac88: f2c7 000b    	movt	r0, #0x700b
7009ac8c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009ac90: 9904         	ldr	r1, [sp, #0x10]
7009ac92: 64c8         	str	r0, [r1, #0x4c]
;             status = UART_lld_initDma(uartLld_handle);
7009ac94: 9805         	ldr	r0, [sp, #0x14]
7009ac96: f005 fabb    	bl	0x700a0210 <UART_lld_initDma> @ imm = #0x5576
7009ac9a: 900f         	str	r0, [sp, #0x3c]
;         }
7009ac9c: e008         	b	0x7009acb0 <UART_open+0x2d0> @ imm = #0x10
;             status = UART_lld_init(uartLld_handle);
7009ac9e: 9805         	ldr	r0, [sp, #0x14]
7009aca0: f006 fcce    	bl	0x700a1640 <UART_lld_init> @ imm = #0x699c
7009aca4: 900f         	str	r0, [sp, #0x3c]
;             object->uartDmaHandle = NULL;
7009aca6: 990c         	ldr	r1, [sp, #0x30]
7009aca8: 2000         	movs	r0, #0x0
7009acaa: f8c1 0280    	str.w	r0, [r1, #0x280]
7009acae: e7ff         	b	0x7009acb0 <UART_open+0x2d0> @ imm = #-0x2
;         if(SystemP_SUCCESS == status)
7009acb0: 980f         	ldr	r0, [sp, #0x3c]
7009acb2: 2800         	cmp	r0, #0x0
7009acb4: f040 808a    	bne.w	0x7009adcc <UART_open+0x3ec> @ imm = #0x114
7009acb8: e7ff         	b	0x7009acba <UART_open+0x2da> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&object->lockObj);
7009acba: 980c         	ldr	r0, [sp, #0x30]
7009acbc: 308c         	adds	r0, #0x8c
7009acbe: f00e fc3f    	bl	0x700a9540 <SemaphoreP_constructMutex> @ imm = #0xe87e
7009acc2: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009acc4: 980f         	ldr	r0, [sp, #0x3c]
7009acc6: b930         	cbnz	r0, 0x7009acd6 <UART_open+0x2f6> @ imm = #0xc
7009acc8: e7ff         	b	0x7009acca <UART_open+0x2ea> @ imm = #-0x2
;                 object->lock = &object->lockObj;
7009acca: 990c         	ldr	r1, [sp, #0x30]
7009accc: f101 008c    	add.w	r0, r1, #0x8c
7009acd0: f8c1 0088    	str.w	r0, [r1, #0x88]
;             }
7009acd4: e7ff         	b	0x7009acd6 <UART_open+0x2f6> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->readTransferSemObj, 0U);
7009acd6: 980c         	ldr	r0, [sp, #0x30]
7009acd8: f500 7094    	add.w	r0, r0, #0x128
7009acdc: 2100         	movs	r1, #0x0
7009acde: f00b f867    	bl	0x700a5db0 <SemaphoreP_constructBinary> @ imm = #0xb0ce
7009ace2: 4601         	mov	r1, r0
7009ace4: 980f         	ldr	r0, [sp, #0x3c]
7009ace6: 4408         	add	r0, r1
7009ace8: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009acea: 980f         	ldr	r0, [sp, #0x3c]
7009acec: b958         	cbnz	r0, 0x7009ad06 <UART_open+0x326> @ imm = #0x16
7009acee: e7ff         	b	0x7009acf0 <UART_open+0x310> @ imm = #-0x2
;                 object->readTransferSem = &object->readTransferSemObj;
7009acf0: 990c         	ldr	r1, [sp, #0x30]
7009acf2: f501 7094    	add.w	r0, r1, #0x128
7009acf6: f8c1 0124    	str.w	r0, [r1, #0x124]
;                 uartLld_handle->readTransferMutex = object->readTransferSem;
7009acfa: 980c         	ldr	r0, [sp, #0x30]
7009acfc: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009ad00: 9905         	ldr	r1, [sp, #0x14]
7009ad02: 6588         	str	r0, [r1, #0x58]
;             }
7009ad04: e7ff         	b	0x7009ad06 <UART_open+0x326> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->writeTransferSemObj, 0U);
7009ad06: 980c         	ldr	r0, [sp, #0x30]
7009ad08: f500 70e2    	add.w	r0, r0, #0x1c4
7009ad0c: 2100         	movs	r1, #0x0
7009ad0e: f00b f84f    	bl	0x700a5db0 <SemaphoreP_constructBinary> @ imm = #0xb09e
7009ad12: 4601         	mov	r1, r0
7009ad14: 980f         	ldr	r0, [sp, #0x3c]
7009ad16: 4408         	add	r0, r1
7009ad18: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009ad1a: 980f         	ldr	r0, [sp, #0x3c]
7009ad1c: b958         	cbnz	r0, 0x7009ad36 <UART_open+0x356> @ imm = #0x16
7009ad1e: e7ff         	b	0x7009ad20 <UART_open+0x340> @ imm = #-0x2
;                 object->writeTransferSem = &object->writeTransferSemObj;
7009ad20: 990c         	ldr	r1, [sp, #0x30]
7009ad22: f501 70e2    	add.w	r0, r1, #0x1c4
7009ad26: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;                 uartLld_handle->writeTransferMutex = object->writeTransferSem;
7009ad2a: 980c         	ldr	r0, [sp, #0x30]
7009ad2c: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009ad30: 9905         	ldr	r1, [sp, #0x14]
7009ad32: 65c8         	str	r0, [r1, #0x5c]
;             }
7009ad34: e7ff         	b	0x7009ad36 <UART_open+0x356> @ imm = #-0x2
;             if((UART_CONFIG_MODE_INTERRUPT == object->prms.transferMode) && (TRUE != object->prms.skipIntrReg))
7009ad36: 980c         	ldr	r0, [sp, #0x30]
7009ad38: 6b00         	ldr	r0, [r0, #0x30]
7009ad3a: 2801         	cmp	r0, #0x1
7009ad3c: d145         	bne	0x7009adca <UART_open+0x3ea> @ imm = #0x8a
7009ad3e: e7ff         	b	0x7009ad40 <UART_open+0x360> @ imm = #-0x2
7009ad40: 980c         	ldr	r0, [sp, #0x30]
7009ad42: 6bc0         	ldr	r0, [r0, #0x3c]
7009ad44: 2801         	cmp	r0, #0x1
7009ad46: d040         	beq	0x7009adca <UART_open+0x3ea> @ imm = #0x80
7009ad48: e7ff         	b	0x7009ad4a <UART_open+0x36a> @ imm = #-0x2
;                 DebugP_assert(object->prms.intrNum != 0xFFFFU);
7009ad4a: 980c         	ldr	r0, [sp, #0x30]
7009ad4c: 6b40         	ldr	r0, [r0, #0x34]
7009ad4e: f64f 71ff    	movw	r1, #0xffff
7009ad52: 1a40         	subs	r0, r0, r1
7009ad54: bf18         	it	ne
7009ad56: 2001         	movne	r0, #0x1
7009ad58: f24f 51cf    	movw	r1, #0xf5cf
7009ad5c: f2c7 010a    	movt	r1, #0x700a
7009ad60: 466a         	mov	r2, sp
7009ad62: 6011         	str	r1, [r2]
7009ad64: f64f 01a2    	movw	r1, #0xf8a2
7009ad68: f2c7 010a    	movt	r1, #0x700a
7009ad6c: f64f 12a2    	movw	r2, #0xf9a2
7009ad70: f2c7 020a    	movt	r2, #0x700a
7009ad74: f44f 73bf    	mov.w	r3, #0x17e
7009ad78: f00d ff12    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xde24
7009ad7c: a806         	add	r0, sp, #0x18
;                 HwiP_Params_init(&hwiPrms);
7009ad7e: 9002         	str	r0, [sp, #0x8]
7009ad80: f012 fdfe    	bl	0x700ad980 <HwiP_Params_init> @ imm = #0x12bfc
7009ad84: 9902         	ldr	r1, [sp, #0x8]
;                 hwiPrms.intNum      = object->prms.intrNum;
7009ad86: 980c         	ldr	r0, [sp, #0x30]
7009ad88: 6b40         	ldr	r0, [r0, #0x34]
7009ad8a: 9006         	str	r0, [sp, #0x18]
;                 hwiPrms.callback    = &UART_lld_controllerIsr;
7009ad8c: f24e 2041    	movw	r0, #0xe241
7009ad90: f2c7 0009    	movt	r0, #0x7009
7009ad94: 9007         	str	r0, [sp, #0x1c]
;                 hwiPrms.priority    = object->prms.intrPriority;
7009ad96: 980c         	ldr	r0, [sp, #0x30]
7009ad98: f890 0038    	ldrb.w	r0, [r0, #0x38]
7009ad9c: f88d 0026    	strb.w	r0, [sp, #0x26]
;                 hwiPrms.args        = (void *) uartLld_handle;
7009ada0: 9805         	ldr	r0, [sp, #0x14]
7009ada2: 9008         	str	r0, [sp, #0x20]
;                 status += HwiP_construct(&object->hwiObj, &hwiPrms);
7009ada4: 980c         	ldr	r0, [sp, #0x30]
7009ada6: f500 7018    	add.w	r0, r0, #0x260
7009adaa: f012 fe01    	bl	0x700ad9b0 <HwiP_construct> @ imm = #0x12c02
7009adae: 4601         	mov	r1, r0
7009adb0: 980f         	ldr	r0, [sp, #0x3c]
7009adb2: 4408         	add	r0, r1
7009adb4: 900f         	str	r0, [sp, #0x3c]
;                 if(SystemP_SUCCESS == status)
7009adb6: 980f         	ldr	r0, [sp, #0x3c]
7009adb8: b930         	cbnz	r0, 0x7009adc8 <UART_open+0x3e8> @ imm = #0xc
7009adba: e7ff         	b	0x7009adbc <UART_open+0x3dc> @ imm = #-0x2
;                     object->hwiHandle = &object->hwiObj;
7009adbc: 990c         	ldr	r1, [sp, #0x30]
7009adbe: f501 7018    	add.w	r0, r1, #0x260
7009adc2: f8c1 025c    	str.w	r0, [r1, #0x25c]
;                 }
7009adc6: e7ff         	b	0x7009adc8 <UART_open+0x3e8> @ imm = #-0x2
;             }
7009adc8: e7ff         	b	0x7009adca <UART_open+0x3ea> @ imm = #-0x2
;         }
7009adca: e7ff         	b	0x7009adcc <UART_open+0x3ec> @ imm = #-0x2
;     }
7009adcc: e7ff         	b	0x7009adce <UART_open+0x3ee> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009adce: 980f         	ldr	r0, [sp, #0x3c]
7009add0: b938         	cbnz	r0, 0x7009ade2 <UART_open+0x402> @ imm = #0xe
7009add2: e7ff         	b	0x7009add4 <UART_open+0x3f4> @ imm = #-0x2
;         object->isOpen = TRUE;
7009add4: 990c         	ldr	r1, [sp, #0x30]
7009add6: 2001         	movs	r0, #0x1
7009add8: f8c1 0084    	str.w	r0, [r1, #0x84]
;         handle = (UART_Handle) config;
7009addc: 980d         	ldr	r0, [sp, #0x34]
7009adde: 900e         	str	r0, [sp, #0x38]
;     }
7009ade0: e7ff         	b	0x7009ade2 <UART_open+0x402> @ imm = #-0x2
;     SemaphoreP_post(&gUartDrvObj.lockObj);
7009ade2: f64f 7050    	movw	r0, #0xff50
7009ade6: f2c7 000a    	movt	r0, #0x700a
7009adea: 3004         	adds	r0, #0x4
7009adec: f00e ffd0    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0xefa0
;     if(SystemP_SUCCESS != status)
7009adf0: 980f         	ldr	r0, [sp, #0x3c]
7009adf2: b140         	cbz	r0, 0x7009ae06 <UART_open+0x426> @ imm = #0x10
7009adf4: e7ff         	b	0x7009adf6 <UART_open+0x416> @ imm = #-0x2
;         if(NULL != config)
7009adf6: 980d         	ldr	r0, [sp, #0x34]
7009adf8: b120         	cbz	r0, 0x7009ae04 <UART_open+0x424> @ imm = #0x8
7009adfa: e7ff         	b	0x7009adfc <UART_open+0x41c> @ imm = #-0x2
;             UART_close((UART_Handle) config);
7009adfc: 980d         	ldr	r0, [sp, #0x34]
7009adfe: f003 f93f    	bl	0x7009e080 <UART_close> @ imm = #0x327e
;         }
7009ae02: e7ff         	b	0x7009ae04 <UART_open+0x424> @ imm = #-0x2
;     }
7009ae04: e7ff         	b	0x7009ae06 <UART_open+0x426> @ imm = #-0x2
;     return (handle);
7009ae06: 980e         	ldr	r0, [sp, #0x38]
7009ae08: b012         	add	sp, #0x48
7009ae0a: bd80         	pop	{r7, pc}
7009ae0c: 0000         	movs	r0, r0
7009ae0e: 0000         	movs	r0, r0

7009ae10 <Udma_chAllocResource>:
; {
7009ae10: b580         	push	{r7, lr}
7009ae12: b088         	sub	sp, #0x20
7009ae14: 9007         	str	r0, [sp, #0x1c]
7009ae16: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK, tempRetVal;
7009ae18: 9006         	str	r0, [sp, #0x18]
7009ae1a: f64f 70ff    	movw	r0, #0xffff
;     uint16_t                ringNum = UDMA_RING_INVALID;
7009ae1e: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     drvHandle = chHandle->drvHandle;
7009ae22: 9807         	ldr	r0, [sp, #0x1c]
7009ae24: 6e80         	ldr	r0, [r0, #0x68]
7009ae26: 9004         	str	r0, [sp, #0x10]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009ae28: 9807         	ldr	r0, [sp, #0x1c]
7009ae2a: 7800         	ldrb	r0, [r0]
7009ae2c: 0740         	lsls	r0, r0, #0x1d
7009ae2e: 2800         	cmp	r0, #0x0
7009ae30: d54d         	bpl	0x7009aece <Udma_chAllocResource+0xbe> @ imm = #0x9a
7009ae32: e7ff         	b	0x7009ae34 <Udma_chAllocResource+0x24> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009ae34: 9807         	ldr	r0, [sp, #0x1c]
7009ae36: 7800         	ldrb	r0, [r0]
7009ae38: 0640         	lsls	r0, r0, #0x19
7009ae3a: 2800         	cmp	r0, #0x0
7009ae3c: d508         	bpl	0x7009ae50 <Udma_chAllocResource+0x40> @ imm = #0x10
7009ae3e: e7ff         	b	0x7009ae40 <Udma_chAllocResource+0x30> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyHcCh(chHandle->chPrms.chNum, drvHandle);
7009ae40: 9807         	ldr	r0, [sp, #0x1c]
7009ae42: 6840         	ldr	r0, [r0, #0x4]
7009ae44: 9904         	ldr	r1, [sp, #0x10]
7009ae46: f006 fef3    	bl	0x700a1c30 <Udma_rmAllocBlkCopyHcCh> @ imm = #0x6de6
;             chHandle->txChNum =
7009ae4a: 9907         	ldr	r1, [sp, #0x1c]
7009ae4c: 66c8         	str	r0, [r1, #0x6c]
;         }
7009ae4e: e016         	b	0x7009ae7e <Udma_chAllocResource+0x6e> @ imm = #0x2c
;         else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009ae50: 9807         	ldr	r0, [sp, #0x1c]
7009ae52: 7800         	ldrb	r0, [r0]
7009ae54: 0600         	lsls	r0, r0, #0x18
7009ae56: 2800         	cmp	r0, #0x0
7009ae58: d508         	bpl	0x7009ae6c <Udma_chAllocResource+0x5c> @ imm = #0x10
7009ae5a: e7ff         	b	0x7009ae5c <Udma_chAllocResource+0x4c> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyUhcCh(chHandle->chPrms.chNum, drvHandle);
7009ae5c: 9807         	ldr	r0, [sp, #0x1c]
7009ae5e: 6840         	ldr	r0, [r0, #0x4]
7009ae60: 9904         	ldr	r1, [sp, #0x10]
7009ae62: f006 ff7d    	bl	0x700a1d60 <Udma_rmAllocBlkCopyUhcCh> @ imm = #0x6efa
;             chHandle->txChNum =
7009ae66: 9907         	ldr	r1, [sp, #0x1c]
7009ae68: 66c8         	str	r0, [r1, #0x6c]
;         }
7009ae6a: e007         	b	0x7009ae7c <Udma_chAllocResource+0x6c> @ imm = #0xe
;                 Udma_rmAllocBlkCopyCh(chHandle->chPrms.chNum, drvHandle);
7009ae6c: 9807         	ldr	r0, [sp, #0x1c]
7009ae6e: 6840         	ldr	r0, [r0, #0x4]
7009ae70: 9904         	ldr	r1, [sp, #0x10]
7009ae72: f006 fe45    	bl	0x700a1b00 <Udma_rmAllocBlkCopyCh> @ imm = #0x6c8a
;             chHandle->txChNum =
7009ae76: 9907         	ldr	r1, [sp, #0x1c]
7009ae78: 66c8         	str	r0, [r1, #0x6c]
7009ae7a: e7ff         	b	0x7009ae7c <Udma_chAllocResource+0x6c> @ imm = #-0x2
7009ae7c: e7ff         	b	0x7009ae7e <Udma_chAllocResource+0x6e> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009ae7e: 9807         	ldr	r0, [sp, #0x1c]
7009ae80: 6ec0         	ldr	r0, [r0, #0x6c]
7009ae82: f510 3f80    	cmn.w	r0, #0x10000
7009ae86: d104         	bne	0x7009ae92 <Udma_chAllocResource+0x82> @ imm = #0x8
7009ae88: e7ff         	b	0x7009ae8a <Udma_chAllocResource+0x7a> @ imm = #-0x2
7009ae8a: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009ae8e: 9006         	str	r0, [sp, #0x18]
;         }
7009ae90: e01c         	b	0x7009aecc <Udma_chAllocResource+0xbc> @ imm = #0x38
;             if (UDMA_INST_TYPE_LCDMA_BCDMA == chHandle->drvHandle->instType)
7009ae92: 9807         	ldr	r0, [sp, #0x1c]
7009ae94: 6e80         	ldr	r0, [r0, #0x68]
7009ae96: 6800         	ldr	r0, [r0]
7009ae98: 2801         	cmp	r0, #0x1
7009ae9a: d10b         	bne	0x7009aeb4 <Udma_chAllocResource+0xa4> @ imm = #0x16
7009ae9c: e7ff         	b	0x7009ae9e <Udma_chAllocResource+0x8e> @ imm = #-0x2
;                 chHandle->rxChNum     = UDMA_DMA_CH_INVALID;
7009ae9e: 9907         	ldr	r1, [sp, #0x1c]
7009aea0: 2000         	movs	r0, #0x0
7009aea2: f6cf 70ff    	movt	r0, #0xffff
7009aea6: 6708         	str	r0, [r1, #0x70]
;                 chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009aea8: 9907         	ldr	r1, [sp, #0x1c]
7009aeaa: 2004         	movs	r0, #0x4
7009aeac: f6cf 70ff    	movt	r0, #0xffff
7009aeb0: 67c8         	str	r0, [r1, #0x7c]
;             }
7009aeb2: e00a         	b	0x7009aeca <Udma_chAllocResource+0xba> @ imm = #0x14
;                 chHandle->rxChNum = chHandle->txChNum;
7009aeb4: 9907         	ldr	r1, [sp, #0x1c]
7009aeb6: 6ec8         	ldr	r0, [r1, #0x6c]
7009aeb8: 6708         	str	r0, [r1, #0x70]
;                     chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
7009aeba: 9907         	ldr	r1, [sp, #0x1c]
7009aebc: 6f08         	ldr	r0, [r1, #0x70]
7009aebe: 9a04         	ldr	r2, [sp, #0x10]
7009aec0: f8d2 20d8    	ldr.w	r2, [r2, #0xd8]
7009aec4: 4410         	add	r0, r2
;                 chHandle->peerThreadId =
7009aec6: 67c8         	str	r0, [r1, #0x7c]
7009aec8: e7ff         	b	0x7009aeca <Udma_chAllocResource+0xba> @ imm = #-0x2
7009aeca: e7ff         	b	0x7009aecc <Udma_chAllocResource+0xbc> @ imm = #-0x2
;     }
7009aecc: e0bd         	b	0x7009b04a <Udma_chAllocResource+0x23a> @ imm = #0x17a
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009aece: 9807         	ldr	r0, [sp, #0x1c]
7009aed0: 7800         	ldrb	r0, [r0]
7009aed2: 07c0         	lsls	r0, r0, #0x1f
7009aed4: 2800         	cmp	r0, #0x0
7009aed6: d03f         	beq	0x7009af58 <Udma_chAllocResource+0x148> @ imm = #0x7e
7009aed8: e7ff         	b	0x7009aeda <Udma_chAllocResource+0xca> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009aeda: 9807         	ldr	r0, [sp, #0x1c]
7009aedc: 7800         	ldrb	r0, [r0]
7009aede: 0640         	lsls	r0, r0, #0x19
7009aee0: 2800         	cmp	r0, #0x0
7009aee2: d508         	bpl	0x7009aef6 <Udma_chAllocResource+0xe6> @ imm = #0x10
7009aee4: e7ff         	b	0x7009aee6 <Udma_chAllocResource+0xd6> @ imm = #-0x2
;                     Udma_rmAllocTxHcCh(chHandle->chPrms.chNum, drvHandle);
7009aee6: 9807         	ldr	r0, [sp, #0x1c]
7009aee8: 6840         	ldr	r0, [r0, #0x4]
7009aeea: 9904         	ldr	r1, [sp, #0x10]
7009aeec: f007 fa30    	bl	0x700a2350 <Udma_rmAllocTxHcCh> @ imm = #0x7460
;                 chHandle->txChNum =
7009aef0: 9907         	ldr	r1, [sp, #0x1c]
7009aef2: 66c8         	str	r0, [r1, #0x6c]
;             }
7009aef4: e025         	b	0x7009af42 <Udma_chAllocResource+0x132> @ imm = #0x4a
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009aef6: 9807         	ldr	r0, [sp, #0x1c]
7009aef8: 7840         	ldrb	r0, [r0, #0x1]
7009aefa: 07c0         	lsls	r0, r0, #0x1f
7009aefc: b148         	cbz	r0, 0x7009af12 <Udma_chAllocResource+0x102> @ imm = #0x12
7009aefe: e7ff         	b	0x7009af00 <Udma_chAllocResource+0xf0> @ imm = #-0x2
;                     Udma_rmAllocMappedTxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009af00: 9a07         	ldr	r2, [sp, #0x1c]
7009af02: 9904         	ldr	r1, [sp, #0x10]
7009af04: 6850         	ldr	r0, [r2, #0x4]
7009af06: 68d2         	ldr	r2, [r2, #0xc]
7009af08: f005 f822    	bl	0x7009ff50 <Udma_rmAllocMappedTxCh> @ imm = #0x5044
;                 chHandle->txChNum =
7009af0c: 9907         	ldr	r1, [sp, #0x1c]
7009af0e: 66c8         	str	r0, [r1, #0x6c]
;             }
7009af10: e016         	b	0x7009af40 <Udma_chAllocResource+0x130> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009af12: 9807         	ldr	r0, [sp, #0x1c]
7009af14: 7800         	ldrb	r0, [r0]
7009af16: 0600         	lsls	r0, r0, #0x18
7009af18: 2800         	cmp	r0, #0x0
7009af1a: d508         	bpl	0x7009af2e <Udma_chAllocResource+0x11e> @ imm = #0x10
7009af1c: e7ff         	b	0x7009af1e <Udma_chAllocResource+0x10e> @ imm = #-0x2
;                     Udma_rmAllocTxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009af1e: 9807         	ldr	r0, [sp, #0x1c]
7009af20: 6840         	ldr	r0, [r0, #0x4]
7009af22: 9904         	ldr	r1, [sp, #0x10]
7009af24: f007 faac    	bl	0x700a2480 <Udma_rmAllocTxUhcCh> @ imm = #0x7558
;                 chHandle->txChNum =
7009af28: 9907         	ldr	r1, [sp, #0x1c]
7009af2a: 66c8         	str	r0, [r1, #0x6c]
;             }
7009af2c: e007         	b	0x7009af3e <Udma_chAllocResource+0x12e> @ imm = #0xe
;                     Udma_rmAllocTxCh(chHandle->chPrms.chNum, drvHandle);
7009af2e: 9807         	ldr	r0, [sp, #0x1c]
7009af30: 6840         	ldr	r0, [r0, #0x4]
7009af32: 9904         	ldr	r1, [sp, #0x10]
7009af34: f007 f974    	bl	0x700a2220 <Udma_rmAllocTxCh> @ imm = #0x72e8
;                 chHandle->txChNum =
7009af38: 9907         	ldr	r1, [sp, #0x1c]
7009af3a: 66c8         	str	r0, [r1, #0x6c]
7009af3c: e7ff         	b	0x7009af3e <Udma_chAllocResource+0x12e> @ imm = #-0x2
7009af3e: e7ff         	b	0x7009af40 <Udma_chAllocResource+0x130> @ imm = #-0x2
7009af40: e7ff         	b	0x7009af42 <Udma_chAllocResource+0x132> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009af42: 9807         	ldr	r0, [sp, #0x1c]
7009af44: 6ec0         	ldr	r0, [r0, #0x6c]
7009af46: f510 3f80    	cmn.w	r0, #0x10000
7009af4a: d104         	bne	0x7009af56 <Udma_chAllocResource+0x146> @ imm = #0x8
7009af4c: e7ff         	b	0x7009af4e <Udma_chAllocResource+0x13e> @ imm = #-0x2
7009af4e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009af52: 9006         	str	r0, [sp, #0x18]
;             }
7009af54: e7ff         	b	0x7009af56 <Udma_chAllocResource+0x146> @ imm = #-0x2
;         }
7009af56: e05c         	b	0x7009b012 <Udma_chAllocResource+0x202> @ imm = #0xb8
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009af58: 9807         	ldr	r0, [sp, #0x1c]
7009af5a: 7800         	ldrb	r0, [r0]
7009af5c: 0640         	lsls	r0, r0, #0x19
7009af5e: 2800         	cmp	r0, #0x0
7009af60: d508         	bpl	0x7009af74 <Udma_chAllocResource+0x164> @ imm = #0x10
7009af62: e7ff         	b	0x7009af64 <Udma_chAllocResource+0x154> @ imm = #-0x2
;                     Udma_rmAllocRxHcCh(chHandle->chPrms.chNum, drvHandle);
7009af64: 9807         	ldr	r0, [sp, #0x1c]
7009af66: 6840         	ldr	r0, [r0, #0x4]
7009af68: 9904         	ldr	r1, [sp, #0x10]
7009af6a: f007 f829    	bl	0x700a1fc0 <Udma_rmAllocRxHcCh> @ imm = #0x7052
;                 chHandle->rxChNum =
7009af6e: 9907         	ldr	r1, [sp, #0x1c]
7009af70: 6708         	str	r0, [r1, #0x70]
;             }
7009af72: e026         	b	0x7009afc2 <Udma_chAllocResource+0x1b2> @ imm = #0x4c
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009af74: 9807         	ldr	r0, [sp, #0x1c]
7009af76: 7840         	ldrb	r0, [r0, #0x1]
7009af78: 07c0         	lsls	r0, r0, #0x1f
7009af7a: b150         	cbz	r0, 0x7009af92 <Udma_chAllocResource+0x182> @ imm = #0x14
7009af7c: e7ff         	b	0x7009af7e <Udma_chAllocResource+0x16e> @ imm = #-0x2
;                     Udma_rmAllocMappedRxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009af7e: 9a07         	ldr	r2, [sp, #0x1c]
7009af80: 9904         	ldr	r1, [sp, #0x10]
7009af82: 6850         	ldr	r0, [r2, #0x4]
7009af84: 68d2         	ldr	r2, [r2, #0xc]
7009af86: 3a04         	subs	r2, #0x4
7009af88: f004 ff32    	bl	0x7009fdf0 <Udma_rmAllocMappedRxCh> @ imm = #0x4e64
;                 chHandle->rxChNum =
7009af8c: 9907         	ldr	r1, [sp, #0x1c]
7009af8e: 6708         	str	r0, [r1, #0x70]
;             }
7009af90: e016         	b	0x7009afc0 <Udma_chAllocResource+0x1b0> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009af92: 9807         	ldr	r0, [sp, #0x1c]
7009af94: 7800         	ldrb	r0, [r0]
7009af96: 0600         	lsls	r0, r0, #0x18
7009af98: 2800         	cmp	r0, #0x0
7009af9a: d508         	bpl	0x7009afae <Udma_chAllocResource+0x19e> @ imm = #0x10
7009af9c: e7ff         	b	0x7009af9e <Udma_chAllocResource+0x18e> @ imm = #-0x2
;                     Udma_rmAllocRxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009af9e: 9807         	ldr	r0, [sp, #0x1c]
7009afa0: 6840         	ldr	r0, [r0, #0x4]
7009afa2: 9904         	ldr	r1, [sp, #0x10]
7009afa4: f007 f8a4    	bl	0x700a20f0 <Udma_rmAllocRxUhcCh> @ imm = #0x7148
;                 chHandle->rxChNum =
7009afa8: 9907         	ldr	r1, [sp, #0x1c]
7009afaa: 6708         	str	r0, [r1, #0x70]
;             }
7009afac: e007         	b	0x7009afbe <Udma_chAllocResource+0x1ae> @ imm = #0xe
;                     Udma_rmAllocRxCh(chHandle->chPrms.chNum, drvHandle);
7009afae: 9807         	ldr	r0, [sp, #0x1c]
7009afb0: 6840         	ldr	r0, [r0, #0x4]
7009afb2: 9904         	ldr	r1, [sp, #0x10]
7009afb4: f006 ff6c    	bl	0x700a1e90 <Udma_rmAllocRxCh> @ imm = #0x6ed8
;                 chHandle->rxChNum =
7009afb8: 9907         	ldr	r1, [sp, #0x1c]
7009afba: 6708         	str	r0, [r1, #0x70]
7009afbc: e7ff         	b	0x7009afbe <Udma_chAllocResource+0x1ae> @ imm = #-0x2
7009afbe: e7ff         	b	0x7009afc0 <Udma_chAllocResource+0x1b0> @ imm = #-0x2
7009afc0: e7ff         	b	0x7009afc2 <Udma_chAllocResource+0x1b2> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->rxChNum)
7009afc2: 9807         	ldr	r0, [sp, #0x1c]
7009afc4: 6f00         	ldr	r0, [r0, #0x70]
7009afc6: f510 3f80    	cmn.w	r0, #0x10000
7009afca: d104         	bne	0x7009afd6 <Udma_chAllocResource+0x1c6> @ imm = #0x8
7009afcc: e7ff         	b	0x7009afce <Udma_chAllocResource+0x1be> @ imm = #-0x2
7009afce: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009afd2: 9006         	str	r0, [sp, #0x18]
;             }
7009afd4: e01c         	b	0x7009b010 <Udma_chAllocResource+0x200> @ imm = #0x38
;                 chHandle->defaultFlow               = &chHandle->defaultFlowObj;
7009afd6: 9907         	ldr	r1, [sp, #0x1c]
7009afd8: f501 70e6    	add.w	r0, r1, #0x1cc
7009afdc: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
;                 chHandle->defaultFlow->drvHandle    = drvHandle;
7009afe0: 9804         	ldr	r0, [sp, #0x10]
7009afe2: 9907         	ldr	r1, [sp, #0x1c]
7009afe4: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009afe8: 6008         	str	r0, [r1]
;                 chHandle->defaultFlow->flowStart    = chHandle->rxChNum;
7009afea: 9907         	ldr	r1, [sp, #0x1c]
7009afec: 6f08         	ldr	r0, [r1, #0x70]
7009afee: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009aff2: 6048         	str	r0, [r1, #0x4]
;                 chHandle->defaultFlow->flowCnt      = 1U;
7009aff4: 9807         	ldr	r0, [sp, #0x1c]
7009aff6: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009affa: 2001         	movs	r0, #0x1
7009affc: 6088         	str	r0, [r1, #0x8]
;                 chHandle->defaultFlow->flowInitDone = UDMA_INIT_DONE;
7009affe: 9807         	ldr	r0, [sp, #0x1c]
7009b000: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009b004: f64a 30cd    	movw	r0, #0xabcd
7009b008: f6ca 30dc    	movt	r0, #0xabdc
7009b00c: 60c8         	str	r0, [r1, #0xc]
7009b00e: e7ff         	b	0x7009b010 <Udma_chAllocResource+0x200> @ imm = #-0x2
7009b010: e7ff         	b	0x7009b012 <Udma_chAllocResource+0x202> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
7009b012: 9806         	ldr	r0, [sp, #0x18]
7009b014: b9c0         	cbnz	r0, 0x7009b048 <Udma_chAllocResource+0x238> @ imm = #0x30
7009b016: e7ff         	b	0x7009b018 <Udma_chAllocResource+0x208> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
7009b018: 9807         	ldr	r0, [sp, #0x1c]
7009b01a: 7800         	ldrb	r0, [r0]
7009b01c: 0700         	lsls	r0, r0, #0x1c
7009b01e: 2800         	cmp	r0, #0x0
7009b020: d507         	bpl	0x7009b032 <Udma_chAllocResource+0x222> @ imm = #0xe
7009b022: e7ff         	b	0x7009b024 <Udma_chAllocResource+0x214> @ imm = #-0x2
;                 chHandle->pdmaChNum = chHandle->chPrms.peerChNum;
7009b024: 9907         	ldr	r1, [sp, #0x1c]
7009b026: 6888         	ldr	r0, [r1, #0x8]
7009b028: 6788         	str	r0, [r1, #0x78]
;                 chHandle->peerThreadId = chHandle->pdmaChNum;
7009b02a: 9907         	ldr	r1, [sp, #0x1c]
7009b02c: 6f88         	ldr	r0, [r1, #0x78]
7009b02e: 67c8         	str	r0, [r1, #0x7c]
;             }
7009b030: e7ff         	b	0x7009b032 <Udma_chAllocResource+0x222> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)
7009b032: 9807         	ldr	r0, [sp, #0x1c]
7009b034: 7800         	ldrb	r0, [r0]
7009b036: 06c0         	lsls	r0, r0, #0x1b
7009b038: 2800         	cmp	r0, #0x0
7009b03a: d504         	bpl	0x7009b046 <Udma_chAllocResource+0x236> @ imm = #0x8
7009b03c: e7ff         	b	0x7009b03e <Udma_chAllocResource+0x22e> @ imm = #-0x2
;                 chHandle->peerThreadId = chHandle->chPrms.peerChNum;
7009b03e: 9907         	ldr	r1, [sp, #0x1c]
7009b040: 6888         	ldr	r0, [r1, #0x8]
7009b042: 67c8         	str	r0, [r1, #0x7c]
;             }
7009b044: e7ff         	b	0x7009b046 <Udma_chAllocResource+0x236> @ imm = #-0x2
;         }
7009b046: e7ff         	b	0x7009b048 <Udma_chAllocResource+0x238> @ imm = #-0x2
7009b048: e7ff         	b	0x7009b04a <Udma_chAllocResource+0x23a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b04a: 9806         	ldr	r0, [sp, #0x18]
7009b04c: 2800         	cmp	r0, #0x0
7009b04e: f040 8088    	bne.w	0x7009b162 <Udma_chAllocResource+0x352> @ imm = #0x110
7009b052: e7ff         	b	0x7009b054 <Udma_chAllocResource+0x244> @ imm = #-0x2
;         if(NULL_PTR != chHandle->chPrms.fqRingPrms.ringMem)
7009b054: 9807         	ldr	r0, [sp, #0x1c]
7009b056: 6940         	ldr	r0, [r0, #0x14]
7009b058: 2800         	cmp	r0, #0x0
7009b05a: f000 8081    	beq.w	0x7009b160 <Udma_chAllocResource+0x350> @ imm = #0x102
7009b05e: e7ff         	b	0x7009b060 <Udma_chAllocResource+0x250> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) ==
7009b060: 9807         	ldr	r0, [sp, #0x1c]
7009b062: 7800         	ldrb	r0, [r0]
7009b064: 0740         	lsls	r0, r0, #0x1d
7009b066: 2800         	cmp	r0, #0x0
7009b068: d505         	bpl	0x7009b076 <Udma_chAllocResource+0x266> @ imm = #0xa
7009b06a: e7ff         	b	0x7009b06c <Udma_chAllocResource+0x25c> @ imm = #-0x2
;                 ringNum = (uint16_t)chHandle->txChNum;
7009b06c: 9807         	ldr	r0, [sp, #0x1c]
7009b06e: 6ec0         	ldr	r0, [r0, #0x6c]
7009b070: f8ad 000e    	strh.w	r0, [sp, #0xe]
;             }
7009b074: e044         	b	0x7009b100 <Udma_chAllocResource+0x2f0> @ imm = #0x88
;                 if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009b076: 9807         	ldr	r0, [sp, #0x1c]
7009b078: 7840         	ldrb	r0, [r0, #0x1]
7009b07a: 07c0         	lsls	r0, r0, #0x1f
7009b07c: b338         	cbz	r0, 0x7009b0ce <Udma_chAllocResource+0x2be> @ imm = #0x4e
7009b07e: e7ff         	b	0x7009b080 <Udma_chAllocResource+0x270> @ imm = #-0x2
;                     chHandle->chPrms.fqRingPrms.mappedRingGrp  = chHandle->chPrms.mappedChGrp;
7009b080: 9907         	ldr	r1, [sp, #0x1c]
7009b082: 68c8         	ldr	r0, [r1, #0xc]
7009b084: 6288         	str	r0, [r1, #0x28]
;                     if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009b086: 9807         	ldr	r0, [sp, #0x1c]
7009b088: 7800         	ldrb	r0, [r0]
7009b08a: 07c0         	lsls	r0, r0, #0x1f
7009b08c: b178         	cbz	r0, 0x7009b0ae <Udma_chAllocResource+0x29e> @ imm = #0x1e
7009b08e: e7ff         	b	0x7009b090 <Udma_chAllocResource+0x280> @ imm = #-0x2
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->txChNum;
7009b090: 9907         	ldr	r1, [sp, #0x1c]
7009b092: 6ec8         	ldr	r0, [r1, #0x6c]
7009b094: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->txChNum, &chAttr);
7009b096: 9804         	ldr	r0, [sp, #0x10]
7009b098: 9a07         	ldr	r2, [sp, #0x1c]
7009b09a: 68d1         	ldr	r1, [r2, #0xc]
7009b09c: 6ed2         	ldr	r2, [r2, #0x6c]
7009b09e: 466b         	mov	r3, sp
7009b0a0: f00a fdd6    	bl	0x700a5c50 <Udma_getMappedChRingAttributes> @ imm = #0xabac
7009b0a4: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009b0a6: 9800         	ldr	r0, [sp]
7009b0a8: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                     }
7009b0ac: e00e         	b	0x7009b0cc <Udma_chAllocResource+0x2bc> @ imm = #0x1c
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->rxChNum;
7009b0ae: 9907         	ldr	r1, [sp, #0x1c]
7009b0b0: 6f08         	ldr	r0, [r1, #0x70]
7009b0b2: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->rxChNum, &chAttr);
7009b0b4: 9804         	ldr	r0, [sp, #0x10]
7009b0b6: 9a07         	ldr	r2, [sp, #0x1c]
7009b0b8: 68d1         	ldr	r1, [r2, #0xc]
7009b0ba: 6f12         	ldr	r2, [r2, #0x70]
7009b0bc: 466b         	mov	r3, sp
7009b0be: f00a fdc7    	bl	0x700a5c50 <Udma_getMappedChRingAttributes> @ imm = #0xab8e
7009b0c2: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009b0c4: 9800         	ldr	r0, [sp]
7009b0c6: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009b0ca: e7ff         	b	0x7009b0cc <Udma_chAllocResource+0x2bc> @ imm = #-0x2
;                 }
7009b0cc: e017         	b	0x7009b0fe <Udma_chAllocResource+0x2ee> @ imm = #0x2e
;                 else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009b0ce: 9807         	ldr	r0, [sp, #0x1c]
7009b0d0: 7800         	ldrb	r0, [r0]
7009b0d2: 07c0         	lsls	r0, r0, #0x1f
7009b0d4: b148         	cbz	r0, 0x7009b0ea <Udma_chAllocResource+0x2da> @ imm = #0x12
7009b0d6: e7ff         	b	0x7009b0d8 <Udma_chAllocResource+0x2c8> @ imm = #-0x2
;                     ringNum = (uint16_t)(chHandle->txChNum + drvHandle->txChOffset);
7009b0d8: 9807         	ldr	r0, [sp, #0x1c]
7009b0da: 6ec0         	ldr	r0, [r0, #0x6c]
7009b0dc: 9904         	ldr	r1, [sp, #0x10]
7009b0de: f8d1 110c    	ldr.w	r1, [r1, #0x10c]
7009b0e2: 4408         	add	r0, r1
7009b0e4: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 }
7009b0e8: e008         	b	0x7009b0fc <Udma_chAllocResource+0x2ec> @ imm = #0x10
;                     ringNum = (uint16_t)(chHandle->rxChNum + drvHandle->rxChOffset);
7009b0ea: 9807         	ldr	r0, [sp, #0x1c]
7009b0ec: 6f00         	ldr	r0, [r0, #0x70]
7009b0ee: 9904         	ldr	r1, [sp, #0x10]
7009b0f0: f8d1 1114    	ldr.w	r1, [r1, #0x114]
7009b0f4: 4408         	add	r0, r1
7009b0f6: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009b0fa: e7ff         	b	0x7009b0fc <Udma_chAllocResource+0x2ec> @ imm = #-0x2
7009b0fc: e7ff         	b	0x7009b0fe <Udma_chAllocResource+0x2ee> @ imm = #-0x2
7009b0fe: e7ff         	b	0x7009b100 <Udma_chAllocResource+0x2f0> @ imm = #-0x2
;             chHandle->fqRing = &chHandle->fqRingObj;
7009b100: 9907         	ldr	r1, [sp, #0x1c]
7009b102: f101 0090    	add.w	r0, r1, #0x90
7009b106: f8c1 0080    	str.w	r0, [r1, #0x80]
;                          drvHandle,
7009b10a: 9804         	ldr	r0, [sp, #0x10]
;                          chHandle->fqRing,
7009b10c: 9b07         	ldr	r3, [sp, #0x1c]
7009b10e: f8d3 1080    	ldr.w	r1, [r3, #0x80]
;                          ringNum,
7009b112: f8bd 200e    	ldrh.w	r2, [sp, #0xe]
;                          &chHandle->chPrms.fqRingPrms);
7009b116: 3314         	adds	r3, #0x14
;             retVal = Udma_ringAlloc(
7009b118: f002 fbe2    	bl	0x7009d8e0 <Udma_ringAlloc> @ imm = #0x27c4
7009b11c: 9006         	str	r0, [sp, #0x18]
;             if(UDMA_SOK != retVal)
7009b11e: 9806         	ldr	r0, [sp, #0x18]
7009b120: b128         	cbz	r0, 0x7009b12e <Udma_chAllocResource+0x31e> @ imm = #0xa
7009b122: e7ff         	b	0x7009b124 <Udma_chAllocResource+0x314> @ imm = #-0x2
;                 chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009b124: 9907         	ldr	r1, [sp, #0x1c]
7009b126: 2000         	movs	r0, #0x0
7009b128: f8c1 0080    	str.w	r0, [r1, #0x80]
;             }
7009b12c: e017         	b	0x7009b15e <Udma_chAllocResource+0x34e> @ imm = #0x2e
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009b12e: 9807         	ldr	r0, [sp, #0x1c]
7009b130: 7840         	ldrb	r0, [r0, #0x1]
7009b132: 07c0         	lsls	r0, r0, #0x1f
7009b134: b190         	cbz	r0, 0x7009b15c <Udma_chAllocResource+0x34c> @ imm = #0x24
7009b136: e7ff         	b	0x7009b138 <Udma_chAllocResource+0x328> @ imm = #-0x2
;                     ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX))
7009b138: 9807         	ldr	r0, [sp, #0x1c]
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009b13a: 7800         	ldrb	r0, [r0]
7009b13c: 0780         	lsls	r0, r0, #0x1e
7009b13e: 2800         	cmp	r0, #0x0
7009b140: d50c         	bpl	0x7009b15c <Udma_chAllocResource+0x34c> @ imm = #0x18
7009b142: e7ff         	b	0x7009b144 <Udma_chAllocResource+0x334> @ imm = #-0x2
;                 chHandle->defaultFlow->flowStart    = chHandle->fqRing->ringNum - drvHandle->rxChOffset;
7009b144: 9907         	ldr	r1, [sp, #0x1c]
7009b146: f8d1 0080    	ldr.w	r0, [r1, #0x80]
7009b14a: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009b14e: 8880         	ldrh	r0, [r0, #0x4]
7009b150: 9a04         	ldr	r2, [sp, #0x10]
7009b152: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009b156: 1a80         	subs	r0, r0, r2
7009b158: 6048         	str	r0, [r1, #0x4]
;             }
7009b15a: e7ff         	b	0x7009b15c <Udma_chAllocResource+0x34c> @ imm = #-0x2
7009b15c: e7ff         	b	0x7009b15e <Udma_chAllocResource+0x34e> @ imm = #-0x2
;         }
7009b15e: e7ff         	b	0x7009b160 <Udma_chAllocResource+0x350> @ imm = #-0x2
;     }
7009b160: e7ff         	b	0x7009b162 <Udma_chAllocResource+0x352> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b162: 9806         	ldr	r0, [sp, #0x18]
7009b164: b930         	cbnz	r0, 0x7009b174 <Udma_chAllocResource+0x364> @ imm = #0xc
7009b166: e7ff         	b	0x7009b168 <Udma_chAllocResource+0x358> @ imm = #-0x2
;         chHandle->cqRing = &chHandle->fqRingObj;
7009b168: 9907         	ldr	r1, [sp, #0x1c]
7009b16a: f101 0090    	add.w	r0, r1, #0x90
7009b16e: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009b172: e7ff         	b	0x7009b174 <Udma_chAllocResource+0x364> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b174: 9806         	ldr	r0, [sp, #0x18]
7009b176: b928         	cbnz	r0, 0x7009b184 <Udma_chAllocResource+0x374> @ imm = #0xa
7009b178: e7ff         	b	0x7009b17a <Udma_chAllocResource+0x36a> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009b17a: 9907         	ldr	r1, [sp, #0x1c]
7009b17c: 2000         	movs	r0, #0x0
7009b17e: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009b182: e7ff         	b	0x7009b184 <Udma_chAllocResource+0x374> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009b184: 9806         	ldr	r0, [sp, #0x18]
7009b186: b148         	cbz	r0, 0x7009b19c <Udma_chAllocResource+0x38c> @ imm = #0x12
7009b188: e7ff         	b	0x7009b18a <Udma_chAllocResource+0x37a> @ imm = #-0x2
;         tempRetVal = Udma_chFreeResource(chHandle);
7009b18a: 9807         	ldr	r0, [sp, #0x1c]
7009b18c: f002 faa0    	bl	0x7009d6d0 <Udma_chFreeResource> @ imm = #0x2540
7009b190: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != tempRetVal)
7009b192: 9805         	ldr	r0, [sp, #0x14]
7009b194: b108         	cbz	r0, 0x7009b19a <Udma_chAllocResource+0x38a> @ imm = #0x2
7009b196: e7ff         	b	0x7009b198 <Udma_chAllocResource+0x388> @ imm = #-0x2
;         }
7009b198: e7ff         	b	0x7009b19a <Udma_chAllocResource+0x38a> @ imm = #-0x2
;     }
7009b19a: e004         	b	0x7009b1a6 <Udma_chAllocResource+0x396> @ imm = #0x8
;         Udma_chAssignRegOverlay(drvHandle, chHandle);
7009b19c: 9804         	ldr	r0, [sp, #0x10]
7009b19e: 9907         	ldr	r1, [sp, #0x1c]
7009b1a0: f005 f98e    	bl	0x700a04c0 <Udma_chAssignRegOverlay> @ imm = #0x531c
7009b1a4: e7ff         	b	0x7009b1a6 <Udma_chAllocResource+0x396> @ imm = #-0x2
;     return (retVal);
7009b1a6: 9806         	ldr	r0, [sp, #0x18]
7009b1a8: b008         	add	sp, #0x20
7009b1aa: bd80         	pop	{r7, pc}
7009b1ac: 0000         	movs	r0, r0
7009b1ae: 0000         	movs	r0, r0

7009b1b0 <Udma_chDisableTxChan>:
; {
7009b1b0: b580         	push	{r7, lr}
7009b1b2: b09a         	sub	sp, #0x68
7009b1b4: 9019         	str	r0, [sp, #0x64]
7009b1b6: 9118         	str	r1, [sp, #0x60]
7009b1b8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009b1ba: 9017         	str	r0, [sp, #0x5c]
;     uint32_t            peerRtEnable = 0U, currTimeout = 0U;
7009b1bc: 9016         	str	r0, [sp, #0x58]
7009b1be: 9015         	str	r0, [sp, #0x54]
;     drvHandle = chHandle->drvHandle;
7009b1c0: 9819         	ldr	r0, [sp, #0x64]
7009b1c2: 6e80         	ldr	r0, [r0, #0x68]
7009b1c4: 9014         	str	r0, [sp, #0x50]
7009b1c6: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009b1c8: 9008         	str	r0, [sp, #0x20]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b1ca: 9814         	ldr	r0, [sp, #0x50]
7009b1cc: 6800         	ldr	r0, [r0]
7009b1ce: 2801         	cmp	r0, #0x1
7009b1d0: d10e         	bne	0x7009b1f0 <Udma_chDisableTxChan+0x40> @ imm = #0x1c
7009b1d2: e7ff         	b	0x7009b1d4 <Udma_chDisableTxChan+0x24> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)false, (bool)false);
7009b1d4: 9a14         	ldr	r2, [sp, #0x50]
7009b1d6: f102 0008    	add.w	r0, r2, #0x8
7009b1da: 9919         	ldr	r1, [sp, #0x64]
7009b1dc: 6ec9         	ldr	r1, [r1, #0x6c]
7009b1de: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b1e2: 4411         	add	r1, r2
7009b1e4: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009b1e6: 461a         	mov	r2, r3
7009b1e8: f010 f98a    	bl	0x700ab500 <CSL_bcdmaTeardownTxChan> @ imm = #0x10314
7009b1ec: 9017         	str	r0, [sp, #0x5c]
;     }
7009b1ee: e00f         	b	0x7009b210 <Udma_chDisableTxChan+0x60> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b1f0: 9814         	ldr	r0, [sp, #0x50]
7009b1f2: 6800         	ldr	r0, [r0]
7009b1f4: 2802         	cmp	r0, #0x2
7009b1f6: d10a         	bne	0x7009b20e <Udma_chDisableTxChan+0x5e> @ imm = #0x14
7009b1f8: e7ff         	b	0x7009b1fa <Udma_chDisableTxChan+0x4a> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009b1fa: 9814         	ldr	r0, [sp, #0x50]
7009b1fc: 3054         	adds	r0, #0x54
7009b1fe: 9919         	ldr	r1, [sp, #0x64]
7009b200: 6ec9         	ldr	r1, [r1, #0x6c]
7009b202: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009b204: 461a         	mov	r2, r3
7009b206: f010 ffbb    	bl	0x700ac180 <CSL_pktdmaTeardownTxChan> @ imm = #0x10f76
7009b20a: 9017         	str	r0, [sp, #0x5c]
;     }
7009b20c: e7ff         	b	0x7009b20e <Udma_chDisableTxChan+0x5e> @ imm = #-0x2
7009b20e: e7ff         	b	0x7009b210 <Udma_chDisableTxChan+0x60> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009b210: 9817         	ldr	r0, [sp, #0x5c]
7009b212: b108         	cbz	r0, 0x7009b218 <Udma_chDisableTxChan+0x68> @ imm = #0x2
7009b214: e7ff         	b	0x7009b216 <Udma_chDisableTxChan+0x66> @ imm = #-0x2
;     }
7009b216: e7ff         	b	0x7009b218 <Udma_chDisableTxChan+0x68> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009b218: e7ff         	b	0x7009b21a <Udma_chDisableTxChan+0x6a> @ imm = #-0x2
7009b21a: 9817         	ldr	r0, [sp, #0x5c]
7009b21c: bbc8         	cbnz	r0, 0x7009b292 <Udma_chDisableTxChan+0xe2> @ imm = #0x72
7009b21e: e7ff         	b	0x7009b220 <Udma_chDisableTxChan+0x70> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b220: 9814         	ldr	r0, [sp, #0x50]
7009b222: 6800         	ldr	r0, [r0]
7009b224: 2801         	cmp	r0, #0x1
7009b226: d110         	bne	0x7009b24a <Udma_chDisableTxChan+0x9a> @ imm = #0x20
7009b228: e7ff         	b	0x7009b22a <Udma_chDisableTxChan+0x7a> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009b22a: 9a14         	ldr	r2, [sp, #0x50]
7009b22c: f102 0008    	add.w	r0, r2, #0x8
7009b230: 9919         	ldr	r1, [sp, #0x64]
7009b232: 6ec9         	ldr	r1, [r1, #0x6c]
7009b234: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b238: 4411         	add	r1, r2
7009b23a: aa0e         	add	r2, sp, #0x38
7009b23c: f011 fa50    	bl	0x700ac6e0 <CSL_bcdmaGetTxRT> @ imm = #0x114a0
;             if(FALSE == bcdmaRtStatus.enable)
7009b240: 980e         	ldr	r0, [sp, #0x38]
7009b242: b908         	cbnz	r0, 0x7009b248 <Udma_chDisableTxChan+0x98> @ imm = #0x2
7009b244: e7ff         	b	0x7009b246 <Udma_chDisableTxChan+0x96> @ imm = #-0x2
;                 break;
7009b246: e024         	b	0x7009b292 <Udma_chDisableTxChan+0xe2> @ imm = #0x48
;         }
7009b248: e011         	b	0x7009b26e <Udma_chDisableTxChan+0xbe> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b24a: 9814         	ldr	r0, [sp, #0x50]
7009b24c: 6800         	ldr	r0, [r0]
7009b24e: 2802         	cmp	r0, #0x2
7009b250: d10c         	bne	0x7009b26c <Udma_chDisableTxChan+0xbc> @ imm = #0x18
7009b252: e7ff         	b	0x7009b254 <Udma_chDisableTxChan+0xa4> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009b254: 9814         	ldr	r0, [sp, #0x50]
7009b256: 3054         	adds	r0, #0x54
7009b258: 9919         	ldr	r1, [sp, #0x64]
7009b25a: 6ec9         	ldr	r1, [r1, #0x6c]
7009b25c: aa09         	add	r2, sp, #0x24
7009b25e: f00f ffbf    	bl	0x700ab1e0 <CSL_pktdmaGetTxRT> @ imm = #0xff7e
;             if(FALSE == pktdmaRtStatus.enable)
7009b262: 9809         	ldr	r0, [sp, #0x24]
7009b264: b908         	cbnz	r0, 0x7009b26a <Udma_chDisableTxChan+0xba> @ imm = #0x2
7009b266: e7ff         	b	0x7009b268 <Udma_chDisableTxChan+0xb8> @ imm = #-0x2
;                 break;
7009b268: e013         	b	0x7009b292 <Udma_chDisableTxChan+0xe2> @ imm = #0x26
;         }
7009b26a: e7ff         	b	0x7009b26c <Udma_chDisableTxChan+0xbc> @ imm = #-0x2
7009b26c: e7ff         	b	0x7009b26e <Udma_chDisableTxChan+0xbe> @ imm = #-0x2
;         if(currTimeout > timeout)
7009b26e: 9815         	ldr	r0, [sp, #0x54]
7009b270: 9918         	ldr	r1, [sp, #0x60]
7009b272: 4288         	cmp	r0, r1
7009b274: d904         	bls	0x7009b280 <Udma_chDisableTxChan+0xd0> @ imm = #0x8
7009b276: e7ff         	b	0x7009b278 <Udma_chDisableTxChan+0xc8> @ imm = #-0x2
7009b278: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009b27c: 9017         	str	r0, [sp, #0x5c]
;         }
7009b27e: e007         	b	0x7009b290 <Udma_chDisableTxChan+0xe0> @ imm = #0xe
7009b280: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009b284: f00d fe8c    	bl	0x700a8fa0 <ClockP_usleep> @ imm = #0xdd18
;             currTimeout++;
7009b288: 9815         	ldr	r0, [sp, #0x54]
7009b28a: 3001         	adds	r0, #0x1
7009b28c: 9015         	str	r0, [sp, #0x54]
7009b28e: e7ff         	b	0x7009b290 <Udma_chDisableTxChan+0xe0> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009b290: e7c3         	b	0x7009b21a <Udma_chDisableTxChan+0x6a> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009b292: 9817         	ldr	r0, [sp, #0x5c]
7009b294: 2800         	cmp	r0, #0x0
7009b296: f000 80e4    	beq.w	0x7009b462 <Udma_chDisableTxChan+0x2b2> @ imm = #0x1c8
7009b29a: e7ff         	b	0x7009b29c <Udma_chDisableTxChan+0xec> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b29c: 9814         	ldr	r0, [sp, #0x50]
7009b29e: 6800         	ldr	r0, [r0]
7009b2a0: 2801         	cmp	r0, #0x1
7009b2a2: d10e         	bne	0x7009b2c2 <Udma_chDisableTxChan+0x112> @ imm = #0x1c
7009b2a4: e7ff         	b	0x7009b2a6 <Udma_chDisableTxChan+0xf6> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)true, (bool)false);
7009b2a6: 9a14         	ldr	r2, [sp, #0x50]
7009b2a8: f102 0008    	add.w	r0, r2, #0x8
7009b2ac: 9919         	ldr	r1, [sp, #0x64]
7009b2ae: 6ec9         	ldr	r1, [r1, #0x6c]
7009b2b0: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b2b4: 4411         	add	r1, r2
7009b2b6: 2201         	movs	r2, #0x1
7009b2b8: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009b2ba: f010 f921    	bl	0x700ab500 <CSL_bcdmaTeardownTxChan> @ imm = #0x10242
7009b2be: 9017         	str	r0, [sp, #0x5c]
;         }
7009b2c0: e00f         	b	0x7009b2e2 <Udma_chDisableTxChan+0x132> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b2c2: 9814         	ldr	r0, [sp, #0x50]
7009b2c4: 6800         	ldr	r0, [r0]
7009b2c6: 2802         	cmp	r0, #0x2
7009b2c8: d10a         	bne	0x7009b2e0 <Udma_chDisableTxChan+0x130> @ imm = #0x14
7009b2ca: e7ff         	b	0x7009b2cc <Udma_chDisableTxChan+0x11c> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009b2cc: 9814         	ldr	r0, [sp, #0x50]
7009b2ce: 3054         	adds	r0, #0x54
7009b2d0: 9919         	ldr	r1, [sp, #0x64]
7009b2d2: 6ec9         	ldr	r1, [r1, #0x6c]
7009b2d4: 2201         	movs	r2, #0x1
7009b2d6: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009b2d8: f010 ff52    	bl	0x700ac180 <CSL_pktdmaTeardownTxChan> @ imm = #0x10ea4
7009b2dc: 9017         	str	r0, [sp, #0x5c]
;         }
7009b2de: e7ff         	b	0x7009b2e0 <Udma_chDisableTxChan+0x130> @ imm = #-0x2
7009b2e0: e7ff         	b	0x7009b2e2 <Udma_chDisableTxChan+0x132> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009b2e2: 9817         	ldr	r0, [sp, #0x5c]
7009b2e4: b108         	cbz	r0, 0x7009b2ea <Udma_chDisableTxChan+0x13a> @ imm = #0x2
7009b2e6: e7ff         	b	0x7009b2e8 <Udma_chDisableTxChan+0x138> @ imm = #-0x2
;         }
7009b2e8: e7ff         	b	0x7009b2ea <Udma_chDisableTxChan+0x13a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b2ea: 9814         	ldr	r0, [sp, #0x50]
7009b2ec: 6800         	ldr	r0, [r0]
7009b2ee: 2801         	cmp	r0, #0x1
7009b2f0: d128         	bne	0x7009b344 <Udma_chDisableTxChan+0x194> @ imm = #0x50
7009b2f2: e7ff         	b	0x7009b2f4 <Udma_chDisableTxChan+0x144> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs,
7009b2f4: 9a14         	ldr	r2, [sp, #0x50]
7009b2f6: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009b2fa: 9919         	ldr	r1, [sp, #0x64]
7009b2fc: 6ec9         	ldr	r1, [r1, #0x6c]
7009b2fe: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b302: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009b304: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaGetChanPeerReg(
7009b306: 46ec         	mov	r12, sp
7009b308: aa16         	add	r2, sp, #0x58
7009b30a: 9206         	str	r2, [sp, #0x18]
7009b30c: f8cc 2000    	str.w	r2, [r12]
7009b310: 2200         	movs	r2, #0x0
7009b312: 9207         	str	r2, [sp, #0x1c]
7009b314: f010 f994    	bl	0x700ab640 <CSL_bcdmaGetChanPeerReg> @ imm = #0x10328
7009b318: f8dd c018    	ldr.w	r12, [sp, #0x18]
7009b31c: 9a07         	ldr	r2, [sp, #0x1c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009b31e: 9816         	ldr	r0, [sp, #0x58]
7009b320: f040 5080    	orr	r0, r0, #0x10000000
7009b324: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->bcdmaRegs,
7009b326: 9b14         	ldr	r3, [sp, #0x50]
7009b328: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009b32c: 9919         	ldr	r1, [sp, #0x64]
7009b32e: 6ec9         	ldr	r1, [r1, #0x6c]
7009b330: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009b334: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009b336: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009b338: 46ee         	mov	lr, sp
7009b33a: f8ce c000    	str.w	r12, [lr]
7009b33e: f010 fc5f    	bl	0x700abc00 <CSL_bcdmaSetChanPeerReg> @ imm = #0x108be
;         }
7009b342: e025         	b	0x7009b390 <Udma_chDisableTxChan+0x1e0> @ imm = #0x4a
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b344: 9814         	ldr	r0, [sp, #0x50]
7009b346: 6800         	ldr	r0, [r0]
7009b348: 2802         	cmp	r0, #0x2
7009b34a: d120         	bne	0x7009b38e <Udma_chDisableTxChan+0x1de> @ imm = #0x40
7009b34c: e7ff         	b	0x7009b34e <Udma_chDisableTxChan+0x19e> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs,
7009b34e: 9814         	ldr	r0, [sp, #0x50]
7009b350: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009b352: 9919         	ldr	r1, [sp, #0x64]
7009b354: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009b356: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaGetChanPeerReg(
7009b358: 46ec         	mov	r12, sp
7009b35a: aa16         	add	r2, sp, #0x58
7009b35c: 9204         	str	r2, [sp, #0x10]
7009b35e: f8cc 2000    	str.w	r2, [r12]
7009b362: 2200         	movs	r2, #0x0
7009b364: 9205         	str	r2, [sp, #0x14]
7009b366: f011 f883    	bl	0x700ac470 <CSL_pktdmaGetChanPeerReg> @ imm = #0x11106
7009b36a: f8dd c010    	ldr.w	r12, [sp, #0x10]
7009b36e: 9a05         	ldr	r2, [sp, #0x14]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009b370: 9816         	ldr	r0, [sp, #0x58]
7009b372: f040 5080    	orr	r0, r0, #0x10000000
7009b376: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->pktdmaRegs,
7009b378: 9814         	ldr	r0, [sp, #0x50]
7009b37a: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009b37c: 9919         	ldr	r1, [sp, #0x64]
7009b37e: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009b380: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009b382: 46ee         	mov	lr, sp
7009b384: f8ce c000    	str.w	r12, [lr]
7009b388: f011 f88a    	bl	0x700ac4a0 <CSL_pktdmaSetChanPeerReg> @ imm = #0x11114
;         }
7009b38c: e7ff         	b	0x7009b38e <Udma_chDisableTxChan+0x1de> @ imm = #-0x2
7009b38e: e7ff         	b	0x7009b390 <Udma_chDisableTxChan+0x1e0> @ imm = #-0x2
7009b390: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009b392: 9015         	str	r0, [sp, #0x54]
;         while(UDMA_SOK == retVal)
7009b394: e7ff         	b	0x7009b396 <Udma_chDisableTxChan+0x1e6> @ imm = #-0x2
7009b396: 9817         	ldr	r0, [sp, #0x5c]
7009b398: 2800         	cmp	r0, #0x0
7009b39a: d161         	bne	0x7009b460 <Udma_chDisableTxChan+0x2b0> @ imm = #0xc2
7009b39c: e7ff         	b	0x7009b39e <Udma_chDisableTxChan+0x1ee> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b39e: 9814         	ldr	r0, [sp, #0x50]
7009b3a0: 6800         	ldr	r0, [r0]
7009b3a2: 2801         	cmp	r0, #0x1
7009b3a4: d126         	bne	0x7009b3f4 <Udma_chDisableTxChan+0x244> @ imm = #0x4c
7009b3a6: e7ff         	b	0x7009b3a8 <Udma_chDisableTxChan+0x1f8> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009b3a8: 9a14         	ldr	r2, [sp, #0x50]
7009b3aa: f102 0008    	add.w	r0, r2, #0x8
7009b3ae: 9919         	ldr	r1, [sp, #0x64]
7009b3b0: 6ec9         	ldr	r1, [r1, #0x6c]
7009b3b2: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b3b6: 4411         	add	r1, r2
7009b3b8: aa0e         	add	r2, sp, #0x38
7009b3ba: f011 f991    	bl	0x700ac6e0 <CSL_bcdmaGetTxRT> @ imm = #0x11322
;                     &drvHandle->bcdmaRegs,
7009b3be: 9a14         	ldr	r2, [sp, #0x50]
7009b3c0: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->txChNum + drvHandle->txChOffset,
7009b3c4: 9919         	ldr	r1, [sp, #0x64]
7009b3c6: 6ec9         	ldr	r1, [r1, #0x6c]
7009b3c8: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b3cc: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009b3ce: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009b3d0: 46ec         	mov	r12, sp
7009b3d2: aa16         	add	r2, sp, #0x58
7009b3d4: f8cc 2000    	str.w	r2, [r12]
7009b3d8: 2200         	movs	r2, #0x0
7009b3da: f010 f931    	bl	0x700ab640 <CSL_bcdmaGetChanPeerReg> @ imm = #0x10262
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009b3de: 980e         	ldr	r0, [sp, #0x38]
7009b3e0: b938         	cbnz	r0, 0x7009b3f2 <Udma_chDisableTxChan+0x242> @ imm = #0xe
7009b3e2: e7ff         	b	0x7009b3e4 <Udma_chDisableTxChan+0x234> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009b3e4: 9916         	ldr	r1, [sp, #0x58]
7009b3e6: 2000         	movs	r0, #0x0
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009b3e8: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009b3ec: d101         	bne	0x7009b3f2 <Udma_chDisableTxChan+0x242> @ imm = #0x2
7009b3ee: e7ff         	b	0x7009b3f0 <Udma_chDisableTxChan+0x240> @ imm = #-0x2
;                     break;
7009b3f0: e036         	b	0x7009b460 <Udma_chDisableTxChan+0x2b0> @ imm = #0x6c
;             }
7009b3f2: e023         	b	0x7009b43c <Udma_chDisableTxChan+0x28c> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b3f4: 9814         	ldr	r0, [sp, #0x50]
7009b3f6: 6800         	ldr	r0, [r0]
7009b3f8: 2802         	cmp	r0, #0x2
7009b3fa: d11e         	bne	0x7009b43a <Udma_chDisableTxChan+0x28a> @ imm = #0x3c
7009b3fc: e7ff         	b	0x7009b3fe <Udma_chDisableTxChan+0x24e> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009b3fe: 9814         	ldr	r0, [sp, #0x50]
7009b400: 3054         	adds	r0, #0x54
7009b402: 9919         	ldr	r1, [sp, #0x64]
7009b404: 6ec9         	ldr	r1, [r1, #0x6c]
7009b406: aa09         	add	r2, sp, #0x24
7009b408: f00f feea    	bl	0x700ab1e0 <CSL_pktdmaGetTxRT> @ imm = #0xfdd4
;                     &drvHandle->pktdmaRegs,
7009b40c: 9814         	ldr	r0, [sp, #0x50]
7009b40e: 3054         	adds	r0, #0x54
;                     chHandle->txChNum,
7009b410: 9919         	ldr	r1, [sp, #0x64]
7009b412: 6ec9         	ldr	r1, [r1, #0x6c]
;                     rtEnableRegOffset, &peerRtEnable);
7009b414: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009b416: 46ec         	mov	r12, sp
7009b418: aa16         	add	r2, sp, #0x58
7009b41a: f8cc 2000    	str.w	r2, [r12]
7009b41e: 2200         	movs	r2, #0x0
7009b420: f011 f826    	bl	0x700ac470 <CSL_pktdmaGetChanPeerReg> @ imm = #0x1104c
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009b424: 9809         	ldr	r0, [sp, #0x24]
7009b426: b938         	cbnz	r0, 0x7009b438 <Udma_chDisableTxChan+0x288> @ imm = #0xe
7009b428: e7ff         	b	0x7009b42a <Udma_chDisableTxChan+0x27a> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009b42a: 9916         	ldr	r1, [sp, #0x58]
7009b42c: 2000         	movs	r0, #0x0
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009b42e: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009b432: d101         	bne	0x7009b438 <Udma_chDisableTxChan+0x288> @ imm = #0x2
7009b434: e7ff         	b	0x7009b436 <Udma_chDisableTxChan+0x286> @ imm = #-0x2
;                     break;
7009b436: e013         	b	0x7009b460 <Udma_chDisableTxChan+0x2b0> @ imm = #0x26
;             }
7009b438: e7ff         	b	0x7009b43a <Udma_chDisableTxChan+0x28a> @ imm = #-0x2
7009b43a: e7ff         	b	0x7009b43c <Udma_chDisableTxChan+0x28c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009b43c: 9815         	ldr	r0, [sp, #0x54]
7009b43e: 9918         	ldr	r1, [sp, #0x60]
7009b440: 4288         	cmp	r0, r1
7009b442: d904         	bls	0x7009b44e <Udma_chDisableTxChan+0x29e> @ imm = #0x8
7009b444: e7ff         	b	0x7009b446 <Udma_chDisableTxChan+0x296> @ imm = #-0x2
7009b446: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009b44a: 9017         	str	r0, [sp, #0x5c]
;             }
7009b44c: e007         	b	0x7009b45e <Udma_chDisableTxChan+0x2ae> @ imm = #0xe
7009b44e: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009b452: f00d fda5    	bl	0x700a8fa0 <ClockP_usleep> @ imm = #0xdb4a
;                 currTimeout++;
7009b456: 9815         	ldr	r0, [sp, #0x54]
7009b458: 3001         	adds	r0, #0x1
7009b45a: 9015         	str	r0, [sp, #0x54]
7009b45c: e7ff         	b	0x7009b45e <Udma_chDisableTxChan+0x2ae> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009b45e: e79a         	b	0x7009b396 <Udma_chDisableTxChan+0x1e6> @ imm = #-0xcc
;     }
7009b460: e7ff         	b	0x7009b462 <Udma_chDisableTxChan+0x2b2> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b462: 9817         	ldr	r0, [sp, #0x5c]
7009b464: 2800         	cmp	r0, #0x0
7009b466: d150         	bne	0x7009b50a <Udma_chDisableTxChan+0x35a> @ imm = #0xa0
7009b468: e7ff         	b	0x7009b46a <Udma_chDisableTxChan+0x2ba> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009b46a: 9814         	ldr	r0, [sp, #0x50]
7009b46c: 6800         	ldr	r0, [r0]
7009b46e: 2801         	cmp	r0, #0x1
7009b470: d126         	bne	0x7009b4c0 <Udma_chDisableTxChan+0x310> @ imm = #0x4c
7009b472: e7ff         	b	0x7009b474 <Udma_chDisableTxChan+0x2c4> @ imm = #-0x2
7009b474: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009b476: 9003         	str	r0, [sp, #0xc]
7009b478: 900e         	str	r0, [sp, #0x38]
;             bcdmaRtStatus.teardown = FALSE;
7009b47a: 900f         	str	r0, [sp, #0x3c]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009b47c: 9012         	str	r0, [sp, #0x48]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009b47e: 9816         	ldr	r0, [sp, #0x58]
7009b480: f020 4080    	bic	r0, r0, #0x40000000
7009b484: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009b486: 9a14         	ldr	r2, [sp, #0x50]
7009b488: f102 0008    	add.w	r0, r2, #0x8
7009b48c: 9919         	ldr	r1, [sp, #0x64]
7009b48e: 6ec9         	ldr	r1, [r1, #0x6c]
7009b490: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009b494: 4411         	add	r1, r2
7009b496: aa0e         	add	r2, sp, #0x38
7009b498: f011 f952    	bl	0x700ac740 <CSL_bcdmaSetTxRT> @ imm = #0x112a4
7009b49c: 9a03         	ldr	r2, [sp, #0xc]
;                 &drvHandle->bcdmaRegs,
7009b49e: 9b14         	ldr	r3, [sp, #0x50]
7009b4a0: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009b4a4: 9919         	ldr	r1, [sp, #0x64]
7009b4a6: 6ec9         	ldr	r1, [r1, #0x6c]
7009b4a8: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009b4ac: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009b4ae: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009b4b0: 46ee         	mov	lr, sp
7009b4b2: f10d 0c58    	add.w	r12, sp, #0x58
7009b4b6: f8ce c000    	str.w	r12, [lr]
7009b4ba: f010 fba1    	bl	0x700abc00 <CSL_bcdmaSetChanPeerReg> @ imm = #0x10742
;         }
7009b4be: e023         	b	0x7009b508 <Udma_chDisableTxChan+0x358> @ imm = #0x46
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b4c0: 9814         	ldr	r0, [sp, #0x50]
7009b4c2: 6800         	ldr	r0, [r0]
7009b4c4: 2802         	cmp	r0, #0x2
7009b4c6: d11e         	bne	0x7009b506 <Udma_chDisableTxChan+0x356> @ imm = #0x3c
7009b4c8: e7ff         	b	0x7009b4ca <Udma_chDisableTxChan+0x31a> @ imm = #-0x2
7009b4ca: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009b4cc: 9002         	str	r0, [sp, #0x8]
7009b4ce: 9009         	str	r0, [sp, #0x24]
;             pktdmaRtStatus.teardown = FALSE;
7009b4d0: 900a         	str	r0, [sp, #0x28]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009b4d2: 900d         	str	r0, [sp, #0x34]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009b4d4: 9816         	ldr	r0, [sp, #0x58]
7009b4d6: f020 4080    	bic	r0, r0, #0x40000000
7009b4da: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009b4dc: 9814         	ldr	r0, [sp, #0x50]
7009b4de: 3054         	adds	r0, #0x54
7009b4e0: 9919         	ldr	r1, [sp, #0x64]
7009b4e2: 6ec9         	ldr	r1, [r1, #0x6c]
7009b4e4: aa09         	add	r2, sp, #0x24
7009b4e6: f010 fbeb    	bl	0x700abcc0 <CSL_pktdmaSetTxRT> @ imm = #0x107d6
7009b4ea: 9a02         	ldr	r2, [sp, #0x8]
;                 &drvHandle->pktdmaRegs,
7009b4ec: 9814         	ldr	r0, [sp, #0x50]
7009b4ee: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009b4f0: 9919         	ldr	r1, [sp, #0x64]
7009b4f2: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009b4f4: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009b4f6: 46ee         	mov	lr, sp
7009b4f8: f10d 0c58    	add.w	r12, sp, #0x58
7009b4fc: f8ce c000    	str.w	r12, [lr]
7009b500: f010 ffce    	bl	0x700ac4a0 <CSL_pktdmaSetChanPeerReg> @ imm = #0x10f9c
;         }
7009b504: e7ff         	b	0x7009b506 <Udma_chDisableTxChan+0x356> @ imm = #-0x2
7009b506: e7ff         	b	0x7009b508 <Udma_chDisableTxChan+0x358> @ imm = #-0x2
;     }
7009b508: e7ff         	b	0x7009b50a <Udma_chDisableTxChan+0x35a> @ imm = #-0x2
;     return (retVal);
7009b50a: 9817         	ldr	r0, [sp, #0x5c]
7009b50c: b01a         	add	sp, #0x68
7009b50e: bd80         	pop	{r7, pc}

7009b510 <Udma_eventConfig>:
; {
7009b510: b580         	push	{r7, lr}
7009b512: b098         	sub	sp, #0x60
7009b514: 9017         	str	r0, [sp, #0x5c]
7009b516: 9116         	str	r1, [sp, #0x58]
7009b518: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009b51a: 9001         	str	r0, [sp, #0x4]
7009b51c: 9015         	str	r0, [sp, #0x54]
;     eventPrms = &eventHandle->eventPrms;
7009b51e: 9916         	ldr	r1, [sp, #0x58]
7009b520: 3108         	adds	r1, #0x8
7009b522: 9110         	str	r1, [sp, #0x40]
;     rmIrqReq.valid_params           = 0U;
7009b524: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.global_event           = 0U;
7009b526: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     rmIrqReq.src_id                 = 0U;
7009b52a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.src_index              = 0U;
7009b52e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.dst_id                 = 0U;
7009b532: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.dst_host_irq           = 0U;
7009b536: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     rmIrqReq.ia_id                  = 0U;
7009b53a: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint                   = 0U;
7009b53e: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009b542: f88d 002a    	strb.w	r0, [sp, #0x2a]
7009b546: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009b548: f88d 002b    	strb.w	r0, [sp, #0x2b]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009b54c: 9810         	ldr	r0, [sp, #0x40]
7009b54e: 6800         	ldr	r0, [r0]
7009b550: 2805         	cmp	r0, #0x5
7009b552: d00a         	beq	0x7009b56a <Udma_eventConfig+0x5a> @ imm = #0x14
7009b554: e7ff         	b	0x7009b556 <Udma_eventConfig+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009b556: 9806         	ldr	r0, [sp, #0x18]
7009b558: f040 0010    	orr	r0, r0, #0x10
7009b55c: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009b55e: 9816         	ldr	r0, [sp, #0x58]
7009b560: f00f fdee    	bl	0x700ab140 <Udma_eventGetId> @ imm = #0xfbdc
7009b564: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     }
7009b568: e7ff         	b	0x7009b56a <Udma_eventConfig+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009b56a: 9816         	ldr	r0, [sp, #0x58]
7009b56c: 6d80         	ldr	r0, [r0, #0x58]
7009b56e: f510 3f80    	cmn.w	r0, #0x10000
7009b572: d012         	beq	0x7009b59a <Udma_eventConfig+0x8a> @ imm = #0x24
7009b574: e7ff         	b	0x7009b576 <Udma_eventConfig+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009b576: 9806         	ldr	r0, [sp, #0x18]
7009b578: f040 0001    	orr	r0, r0, #0x1
7009b57c: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009b57e: 9806         	ldr	r0, [sp, #0x18]
7009b580: f040 0002    	orr	r0, r0, #0x2
7009b584: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.dst_id        = drvHandle->devIdCore;
7009b586: 9817         	ldr	r0, [sp, #0x5c]
7009b588: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009b58c: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmIrqReq.dst_host_irq  = (uint16_t)eventHandle->coreIntrNum;
7009b590: 9816         	ldr	r0, [sp, #0x58]
7009b592: 6d80         	ldr	r0, [r0, #0x58]
7009b594: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     }
7009b598: e7ff         	b	0x7009b59a <Udma_eventConfig+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009b59a: 9816         	ldr	r0, [sp, #0x58]
7009b59c: 6980         	ldr	r0, [r0, #0x18]
7009b59e: b128         	cbz	r0, 0x7009b5ac <Udma_eventConfig+0x9c> @ imm = #0xa
7009b5a0: e7ff         	b	0x7009b5a2 <Udma_eventConfig+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009b5a2: 9816         	ldr	r0, [sp, #0x58]
7009b5a4: 6980         	ldr	r0, [r0, #0x18]
7009b5a6: 6cc0         	ldr	r0, [r0, #0x4c]
7009b5a8: 9014         	str	r0, [sp, #0x50]
;     }
7009b5aa: e003         	b	0x7009b5b4 <Udma_eventConfig+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009b5ac: 9816         	ldr	r0, [sp, #0x58]
7009b5ae: 6cc0         	ldr	r0, [r0, #0x4c]
7009b5b0: 9014         	str	r0, [sp, #0x50]
7009b5b2: e7ff         	b	0x7009b5b4 <Udma_eventConfig+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009b5b4: 9806         	ldr	r0, [sp, #0x18]
7009b5b6: f040 0004    	orr	r0, r0, #0x4
7009b5ba: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009b5bc: 9806         	ldr	r0, [sp, #0x18]
7009b5be: f040 0008    	orr	r0, r0, #0x8
7009b5c2: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009b5c4: 9817         	ldr	r0, [sp, #0x5c]
7009b5c6: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009b5ca: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009b5ce: 9814         	ldr	r0, [sp, #0x50]
7009b5d0: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009b5d4: 9816         	ldr	r0, [sp, #0x58]
7009b5d6: 6d00         	ldr	r0, [r0, #0x50]
7009b5d8: f64f 71ff    	movw	r1, #0xffff
7009b5dc: 4288         	cmp	r0, r1
7009b5de: d009         	beq	0x7009b5f4 <Udma_eventConfig+0xe4> @ imm = #0x12
7009b5e0: e7ff         	b	0x7009b5e2 <Udma_eventConfig+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009b5e2: 9806         	ldr	r0, [sp, #0x18]
7009b5e4: f040 0020    	orr	r0, r0, #0x20
7009b5e8: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009b5ea: 9816         	ldr	r0, [sp, #0x58]
7009b5ec: 6d00         	ldr	r0, [r0, #0x50]
7009b5ee: f88d 002a    	strb.w	r0, [sp, #0x2a]
;     }
7009b5f2: e7ff         	b	0x7009b5f4 <Udma_eventConfig+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009b5f4: 9810         	ldr	r0, [sp, #0x40]
7009b5f6: 6800         	ldr	r0, [r0]
7009b5f8: 2801         	cmp	r0, #0x1
7009b5fa: d00a         	beq	0x7009b612 <Udma_eventConfig+0x102> @ imm = #0x14
7009b5fc: e7ff         	b	0x7009b5fe <Udma_eventConfig+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
7009b5fe: 9810         	ldr	r0, [sp, #0x40]
7009b600: 6800         	ldr	r0, [r0]
7009b602: 2802         	cmp	r0, #0x2
7009b604: d005         	beq	0x7009b612 <Udma_eventConfig+0x102> @ imm = #0xa
7009b606: e7ff         	b	0x7009b608 <Udma_eventConfig+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009b608: 9810         	ldr	r0, [sp, #0x40]
7009b60a: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009b60c: 2806         	cmp	r0, #0x6
7009b60e: d14d         	bne	0x7009b6ac <Udma_eventConfig+0x19c> @ imm = #0x9a
7009b610: e7ff         	b	0x7009b612 <Udma_eventConfig+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009b612: 9810         	ldr	r0, [sp, #0x40]
7009b614: 6880         	ldr	r0, [r0, #0x8]
7009b616: 9012         	str	r0, [sp, #0x48]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009b618: 9817         	ldr	r0, [sp, #0x5c]
7009b61a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009b61e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009b622: 9810         	ldr	r0, [sp, #0x40]
7009b624: 6800         	ldr	r0, [r0]
7009b626: 2801         	cmp	r0, #0x1
7009b628: d005         	beq	0x7009b636 <Udma_eventConfig+0x126> @ imm = #0xa
7009b62a: e7ff         	b	0x7009b62c <Udma_eventConfig+0x11c> @ imm = #-0x2
7009b62c: 9810         	ldr	r0, [sp, #0x40]
7009b62e: 6800         	ldr	r0, [r0]
7009b630: 2806         	cmp	r0, #0x6
7009b632: d12e         	bne	0x7009b692 <Udma_eventConfig+0x182> @ imm = #0x5c
7009b634: e7ff         	b	0x7009b636 <Udma_eventConfig+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009b636: 9812         	ldr	r0, [sp, #0x48]
7009b638: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009b63c: 8880         	ldrh	r0, [r0, #0x4]
7009b63e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009b642: 9812         	ldr	r0, [sp, #0x48]
7009b644: 7800         	ldrb	r0, [r0]
7009b646: 0740         	lsls	r0, r0, #0x1d
7009b648: 2800         	cmp	r0, #0x0
7009b64a: d509         	bpl	0x7009b660 <Udma_eventConfig+0x150> @ imm = #0x12
7009b64c: e7ff         	b	0x7009b64e <Udma_eventConfig+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009b64e: 9817         	ldr	r0, [sp, #0x5c]
7009b650: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009b654: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b658: 4408         	add	r0, r1
7009b65a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b65e: e017         	b	0x7009b690 <Udma_eventConfig+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009b660: 9812         	ldr	r0, [sp, #0x48]
7009b662: 7800         	ldrb	r0, [r0]
7009b664: 07c0         	lsls	r0, r0, #0x1f
7009b666: b148         	cbz	r0, 0x7009b67c <Udma_eventConfig+0x16c> @ imm = #0x12
7009b668: e7ff         	b	0x7009b66a <Udma_eventConfig+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009b66a: 9817         	ldr	r0, [sp, #0x5c]
7009b66c: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009b670: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b674: 4408         	add	r0, r1
7009b676: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b67a: e008         	b	0x7009b68e <Udma_eventConfig+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009b67c: 9817         	ldr	r0, [sp, #0x5c]
7009b67e: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009b682: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b686: 4408         	add	r0, r1
7009b688: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009b68c: e7ff         	b	0x7009b68e <Udma_eventConfig+0x17e> @ imm = #-0x2
7009b68e: e7ff         	b	0x7009b690 <Udma_eventConfig+0x180> @ imm = #-0x2
;         }
7009b690: e00b         	b	0x7009b6aa <Udma_eventConfig+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009b692: 9812         	ldr	r0, [sp, #0x48]
7009b694: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009b698: 8880         	ldrh	r0, [r0, #0x4]
7009b69a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009b69e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b6a2: 3014         	adds	r0, #0x14
7009b6a4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009b6a8: e7ff         	b	0x7009b6aa <Udma_eventConfig+0x19a> @ imm = #-0x2
;     }
7009b6aa: e7ff         	b	0x7009b6ac <Udma_eventConfig+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009b6ac: 9810         	ldr	r0, [sp, #0x40]
7009b6ae: 6800         	ldr	r0, [r0]
7009b6b0: 2803         	cmp	r0, #0x3
7009b6b2: d156         	bne	0x7009b762 <Udma_eventConfig+0x252> @ imm = #0xac
7009b6b4: e7ff         	b	0x7009b6b6 <Udma_eventConfig+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009b6b6: 9817         	ldr	r0, [sp, #0x5c]
7009b6b8: 6800         	ldr	r0, [r0]
7009b6ba: 2802         	cmp	r0, #0x2
7009b6bc: d104         	bne	0x7009b6c8 <Udma_eventConfig+0x1b8> @ imm = #0x8
7009b6be: e7ff         	b	0x7009b6c0 <Udma_eventConfig+0x1b0> @ imm = #-0x2
7009b6c0: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009b6c4: 9015         	str	r0, [sp, #0x54]
;         }
7009b6c6: e04b         	b	0x7009b760 <Udma_eventConfig+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009b6c8: 9810         	ldr	r0, [sp, #0x40]
7009b6ca: 6880         	ldr	r0, [r0, #0x8]
7009b6cc: 9012         	str	r0, [sp, #0x48]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009b6ce: 9817         	ldr	r0, [sp, #0x5c]
7009b6d0: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009b6d4: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009b6d8: 9812         	ldr	r0, [sp, #0x48]
7009b6da: 7800         	ldrb	r0, [r0]
7009b6dc: 0740         	lsls	r0, r0, #0x1d
7009b6de: 2800         	cmp	r0, #0x0
7009b6e0: d50d         	bpl	0x7009b6fe <Udma_eventConfig+0x1ee> @ imm = #0x1a
7009b6e2: e7ff         	b	0x7009b6e4 <Udma_eventConfig+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009b6e4: 9812         	ldr	r0, [sp, #0x48]
7009b6e6: 6ec0         	ldr	r0, [r0, #0x6c]
7009b6e8: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009b6ec: 9817         	ldr	r0, [sp, #0x5c]
7009b6ee: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009b6f2: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b6f6: 4408         	add	r0, r1
7009b6f8: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b6fc: e02f         	b	0x7009b75e <Udma_eventConfig+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009b6fe: 9812         	ldr	r0, [sp, #0x48]
7009b700: 7800         	ldrb	r0, [r0]
7009b702: 0780         	lsls	r0, r0, #0x1e
7009b704: 2800         	cmp	r0, #0x0
7009b706: d50d         	bpl	0x7009b724 <Udma_eventConfig+0x214> @ imm = #0x1a
7009b708: e7ff         	b	0x7009b70a <Udma_eventConfig+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009b70a: 9812         	ldr	r0, [sp, #0x48]
7009b70c: 6f00         	ldr	r0, [r0, #0x70]
7009b70e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009b712: 9817         	ldr	r0, [sp, #0x5c]
7009b714: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009b718: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b71c: 4408         	add	r0, r1
7009b71e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b722: e01b         	b	0x7009b75c <Udma_eventConfig+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009b724: 9812         	ldr	r0, [sp, #0x48]
7009b726: 7800         	ldrb	r0, [r0]
7009b728: 07c0         	lsls	r0, r0, #0x1f
7009b72a: b168         	cbz	r0, 0x7009b748 <Udma_eventConfig+0x238> @ imm = #0x1a
7009b72c: e7ff         	b	0x7009b72e <Udma_eventConfig+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009b72e: 9812         	ldr	r0, [sp, #0x48]
7009b730: 6ec0         	ldr	r0, [r0, #0x6c]
7009b732: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009b736: 9817         	ldr	r0, [sp, #0x5c]
7009b738: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009b73c: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b740: 4408         	add	r0, r1
7009b742: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009b746: e008         	b	0x7009b75a <Udma_eventConfig+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009b748: 9817         	ldr	r0, [sp, #0x5c]
7009b74a: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009b74e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009b752: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009b754: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009b758: e7ff         	b	0x7009b75a <Udma_eventConfig+0x24a> @ imm = #-0x2
7009b75a: e7ff         	b	0x7009b75c <Udma_eventConfig+0x24c> @ imm = #-0x2
7009b75c: e7ff         	b	0x7009b75e <Udma_eventConfig+0x24e> @ imm = #-0x2
7009b75e: e7ff         	b	0x7009b760 <Udma_eventConfig+0x250> @ imm = #-0x2
;     }
7009b760: e7ff         	b	0x7009b762 <Udma_eventConfig+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009b762: 9810         	ldr	r0, [sp, #0x40]
7009b764: 6800         	ldr	r0, [r0]
7009b766: 2804         	cmp	r0, #0x4
7009b768: d130         	bne	0x7009b7cc <Udma_eventConfig+0x2bc> @ imm = #0x60
7009b76a: e7ff         	b	0x7009b76c <Udma_eventConfig+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009b76c: 9810         	ldr	r0, [sp, #0x40]
7009b76e: 68c0         	ldr	r0, [r0, #0xc]
7009b770: 9011         	str	r0, [sp, #0x44]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009b772: 9817         	ldr	r0, [sp, #0x5c]
7009b774: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009b778: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009b77c: 9811         	ldr	r0, [sp, #0x44]
7009b77e: 8880         	ldrh	r0, [r0, #0x4]
7009b780: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009b784: 9817         	ldr	r0, [sp, #0x5c]
7009b786: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009b78a: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b78e: 4408         	add	r0, r1
7009b790: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009b794: 9811         	ldr	r0, [sp, #0x44]
7009b796: 6dc0         	ldr	r0, [r0, #0x5c]
7009b798: 2804         	cmp	r0, #0x4
7009b79a: d316         	blo	0x7009b7ca <Udma_eventConfig+0x2ba> @ imm = #0x2c
7009b79c: e7ff         	b	0x7009b79e <Udma_eventConfig+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009b79e: 9811         	ldr	r0, [sp, #0x44]
7009b7a0: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009b7a2: 2807         	cmp	r0, #0x7
7009b7a4: d811         	bhi	0x7009b7ca <Udma_eventConfig+0x2ba> @ imm = #0x22
7009b7a6: e7ff         	b	0x7009b7a8 <Udma_eventConfig+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009b7a8: 9817         	ldr	r0, [sp, #0x5c]
7009b7aa: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009b7ae: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b7b2: 1a40         	subs	r0, r0, r1
7009b7b4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009b7b8: 9817         	ldr	r0, [sp, #0x5c]
7009b7ba: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009b7be: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009b7c2: 4408         	add	r0, r1
7009b7c4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         }
7009b7c8: e7ff         	b	0x7009b7ca <Udma_eventConfig+0x2ba> @ imm = #-0x2
;     }
7009b7ca: e7ff         	b	0x7009b7cc <Udma_eventConfig+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b7cc: 9815         	ldr	r0, [sp, #0x54]
7009b7ce: b9d8         	cbnz	r0, 0x7009b808 <Udma_eventConfig+0x2f8> @ imm = #0x36
7009b7d0: e7ff         	b	0x7009b7d2 <Udma_eventConfig+0x2c2> @ imm = #-0x2
;         Udma_eventProgramSteering(drvHandle, eventHandle);
7009b7d2: 9817         	ldr	r0, [sp, #0x5c]
7009b7d4: 9916         	ldr	r1, [sp, #0x58]
7009b7d6: f011 f933    	bl	0x700aca40 <Udma_eventProgramSteering> @ imm = #0x11266
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009b7da: 9817         	ldr	r0, [sp, #0x5c]
7009b7dc: 6800         	ldr	r0, [r0]
7009b7de: b130         	cbz	r0, 0x7009b7ee <Udma_eventConfig+0x2de> @ imm = #0xc
7009b7e0: e7ff         	b	0x7009b7e2 <Udma_eventConfig+0x2d2> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009b7e2: 9810         	ldr	r0, [sp, #0x40]
7009b7e4: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009b7e6: 2805         	cmp	r0, #0x5
7009b7e8: d101         	bne	0x7009b7ee <Udma_eventConfig+0x2de> @ imm = #0x2
7009b7ea: e7ff         	b	0x7009b7ec <Udma_eventConfig+0x2dc> @ imm = #-0x2
;         }
7009b7ec: e00b         	b	0x7009b806 <Udma_eventConfig+0x2f6> @ imm = #0x16
7009b7ee: a804         	add	r0, sp, #0x10
7009b7f0: a902         	add	r1, sp, #0x8
7009b7f2: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmIrqSet(
7009b7f6: f011 fcf3    	bl	0x700ad1e0 <Sciclient_rmIrqSet> @ imm = #0x119e6
7009b7fa: 9015         	str	r0, [sp, #0x54]
;             if(CSL_PASS != retVal)
7009b7fc: 9815         	ldr	r0, [sp, #0x54]
7009b7fe: b108         	cbz	r0, 0x7009b804 <Udma_eventConfig+0x2f4> @ imm = #0x2
7009b800: e7ff         	b	0x7009b802 <Udma_eventConfig+0x2f2> @ imm = #-0x2
;             }
7009b802: e7ff         	b	0x7009b804 <Udma_eventConfig+0x2f4> @ imm = #-0x2
7009b804: e7ff         	b	0x7009b806 <Udma_eventConfig+0x2f6> @ imm = #-0x2
;     }
7009b806: e7ff         	b	0x7009b808 <Udma_eventConfig+0x2f8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009b808: 9815         	ldr	r0, [sp, #0x54]
7009b80a: bb58         	cbnz	r0, 0x7009b864 <Udma_eventConfig+0x354> @ imm = #0x56
7009b80c: e7ff         	b	0x7009b80e <Udma_eventConfig+0x2fe> @ imm = #-0x2
;         if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009b80e: 9816         	ldr	r0, [sp, #0x58]
7009b810: 6d80         	ldr	r0, [r0, #0x58]
7009b812: f510 3f80    	cmn.w	r0, #0x10000
7009b816: d024         	beq	0x7009b862 <Udma_eventConfig+0x352> @ imm = #0x48
7009b818: e7ff         	b	0x7009b81a <Udma_eventConfig+0x30a> @ imm = #-0x2
;             coreIntrNum = eventHandle->coreIntrNum;
7009b81a: 9816         	ldr	r0, [sp, #0x58]
7009b81c: 6d80         	ldr	r0, [r0, #0x58]
7009b81e: 9013         	str	r0, [sp, #0x4c]
7009b820: a80b         	add	r0, sp, #0x2c
;             HwiP_Params_init(&hwiPrms);
7009b822: 9000         	str	r0, [sp]
7009b824: f012 f8ac    	bl	0x700ad980 <HwiP_Params_init> @ imm = #0x12158
7009b828: 9900         	ldr	r1, [sp]
;             hwiPrms.intNum = coreIntrNum;
7009b82a: 9813         	ldr	r0, [sp, #0x4c]
7009b82c: 900b         	str	r0, [sp, #0x2c]
;             hwiPrms.callback = &Udma_eventIsrFxn;
7009b82e: f643 3051    	movw	r0, #0x3b51
7009b832: f2c7 000a    	movt	r0, #0x700a
7009b836: 900c         	str	r0, [sp, #0x30]
;             hwiPrms.args = eventHandle;
7009b838: 9816         	ldr	r0, [sp, #0x58]
7009b83a: 900d         	str	r0, [sp, #0x34]
;             hwiPrms.priority = eventHandle->eventPrms.intrPriority;
7009b83c: 9816         	ldr	r0, [sp, #0x58]
7009b83e: 6a00         	ldr	r0, [r0, #0x20]
7009b840: f88d 003a    	strb.w	r0, [sp, #0x3a]
;             retVal = HwiP_construct(&eventHandle->hwiObject, &hwiPrms);
7009b844: 9816         	ldr	r0, [sp, #0x58]
7009b846: 3068         	adds	r0, #0x68
7009b848: f012 f8b2    	bl	0x700ad9b0 <HwiP_construct> @ imm = #0x12164
7009b84c: 9015         	str	r0, [sp, #0x54]
;             if(SystemP_SUCCESS != retVal)
7009b84e: 9815         	ldr	r0, [sp, #0x54]
7009b850: b108         	cbz	r0, 0x7009b856 <Udma_eventConfig+0x346> @ imm = #0x2
7009b852: e7ff         	b	0x7009b854 <Udma_eventConfig+0x344> @ imm = #-0x2
;             }
7009b854: e004         	b	0x7009b860 <Udma_eventConfig+0x350> @ imm = #0x8
;                 eventHandle->hwiHandle = &eventHandle->hwiObject;
7009b856: 9916         	ldr	r1, [sp, #0x58]
7009b858: f101 0068    	add.w	r0, r1, #0x68
7009b85c: 6648         	str	r0, [r1, #0x64]
7009b85e: e7ff         	b	0x7009b860 <Udma_eventConfig+0x350> @ imm = #-0x2
;         }
7009b860: e7ff         	b	0x7009b862 <Udma_eventConfig+0x352> @ imm = #-0x2
;     }
7009b862: e7ff         	b	0x7009b864 <Udma_eventConfig+0x354> @ imm = #-0x2
;     return (retVal);
7009b864: 9815         	ldr	r0, [sp, #0x54]
7009b866: b018         	add	sp, #0x60
7009b868: bd80         	pop	{r7, pc}
7009b86a: 0000         	movs	r0, r0
7009b86c: 0000         	movs	r0, r0
7009b86e: 0000         	movs	r0, r0

7009b870 <Sciclient_rmIrqGetRoute>:
; {
7009b870: b580         	push	{r7, lr}
7009b872: b08e         	sub	sp, #0x38
7009b874: 900d         	str	r0, [sp, #0x34]
7009b876: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009b878: 900c         	str	r0, [sp, #0x30]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009b87a: 980d         	ldr	r0, [sp, #0x34]
7009b87c: 88c0         	ldrh	r0, [r0, #0x6]
7009b87e: f010 fe87    	bl	0x700ac590 <Sciclient_rmIrIsIr> @ imm = #0x10d0e
7009b882: b930         	cbnz	r0, 0x7009b892 <Sciclient_rmIrqGetRoute+0x22> @ imm = #0xc
7009b884: e7ff         	b	0x7009b886 <Sciclient_rmIrqGetRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009b886: 980d         	ldr	r0, [sp, #0x34]
7009b888: 8940         	ldrh	r0, [r0, #0xa]
7009b88a: f010 fe81    	bl	0x700ac590 <Sciclient_rmIrIsIr> @ imm = #0x10d02
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009b88e: b120         	cbz	r0, 0x7009b89a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #0x8
7009b890: e7ff         	b	0x7009b892 <Sciclient_rmIrqGetRoute+0x22> @ imm = #-0x2
7009b892: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009b896: 900c         	str	r0, [sp, #0x30]
;     }
7009b898: e7ff         	b	0x7009b89a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009b89a: 980c         	ldr	r0, [sp, #0x30]
7009b89c: 2800         	cmp	r0, #0x0
7009b89e: d156         	bne	0x7009b94e <Sciclient_rmIrqGetRoute+0xde> @ imm = #0xac
7009b8a0: e7ff         	b	0x7009b8a2 <Sciclient_rmIrqGetRoute+0x32> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009b8a2: 980d         	ldr	r0, [sp, #0x34]
7009b8a4: 8a00         	ldrh	r0, [r0, #0x10]
7009b8a6: 28ff         	cmp	r0, #0xff
7009b8a8: d042         	beq	0x7009b930 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x84
7009b8aa: e7ff         	b	0x7009b8ac <Sciclient_rmIrqGetRoute+0x3c> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009b8ac: 980d         	ldr	r0, [sp, #0x34]
7009b8ae: 6800         	ldr	r0, [r0]
7009b8b0: 2104         	movs	r1, #0x4
7009b8b2: f011 f81d    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x1103a
;              true) &&
7009b8b6: b3d8         	cbz	r0, 0x7009b930 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x76
7009b8b8: e7ff         	b	0x7009b8ba <Sciclient_rmIrqGetRoute+0x4a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009b8ba: 980d         	ldr	r0, [sp, #0x34]
7009b8bc: 6800         	ldr	r0, [r0]
7009b8be: 2108         	movs	r1, #0x8
7009b8c0: f011 f816    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x1102c
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009b8c4: b3a0         	cbz	r0, 0x7009b930 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x68
7009b8c6: e7ff         	b	0x7009b8c8 <Sciclient_rmIrqGetRoute+0x58> @ imm = #-0x2
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009b8c8: 980d         	ldr	r0, [sp, #0x34]
7009b8ca: 6800         	ldr	r0, [r0]
7009b8cc: 2110         	movs	r1, #0x10
7009b8ce: f011 f80f    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x1101e
;                  true) &&
7009b8d2: b1d0         	cbz	r0, 0x7009b90a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x34
7009b8d4: e7ff         	b	0x7009b8d6 <Sciclient_rmIrqGetRoute+0x66> @ imm = #-0x2
;                 (Sciclient_rmParamIsValid(cfg->valid_params,
7009b8d6: 980d         	ldr	r0, [sp, #0x34]
7009b8d8: 6800         	ldr	r0, [r0]
7009b8da: 2120         	movs	r1, #0x20
7009b8dc: f011 f808    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x11010
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009b8e0: b198         	cbz	r0, 0x7009b90a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x26
7009b8e2: e7ff         	b	0x7009b8e4 <Sciclient_rmIrqGetRoute+0x74> @ imm = #-0x2
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009b8e4: f8dd c034    	ldr.w	r12, [sp, #0x34]
7009b8e8: f8bc 1010    	ldrh.w	r1, [r12, #0x10]
;                                cfg->vint, cfg->global_evt,
7009b8ec: f8bc 2012    	ldrh.w	r2, [r12, #0x12]
7009b8f0: f8bc 300e    	ldrh.w	r3, [r12, #0xe]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009b8f4: f89c 0004    	ldrb.w	r0, [r12, #0x4]
;                                cfg->vint_sb);
7009b8f8: f89c c014    	ldrb.w	r12, [r12, #0x14]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009b8fc: 46ee         	mov	lr, sp
7009b8fe: f8ce c000    	str.w	r12, [lr]
7009b902: f004 ffd5    	bl	0x700a08b0 <Sciclient_rmIaValidateMapping> @ imm = #0x4faa
7009b906: 900c         	str	r0, [sp, #0x30]
;             }
7009b908: e7ff         	b	0x7009b90a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #-0x2
;             if (r == SystemP_SUCCESS) {
7009b90a: 980c         	ldr	r0, [sp, #0x30]
7009b90c: b978         	cbnz	r0, 0x7009b92e <Sciclient_rmIrqGetRoute+0xbe> @ imm = #0x1e
7009b90e: e7ff         	b	0x7009b910 <Sciclient_rmIrqGetRoute+0xa0> @ imm = #-0x2
;                 inp = cfg->global_evt;
7009b910: 980d         	ldr	r0, [sp, #0x34]
7009b912: 89c0         	ldrh	r0, [r0, #0xe]
7009b914: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = cfg->vint;
7009b918: 980d         	ldr	r0, [sp, #0x34]
7009b91a: 8a40         	ldrh	r0, [r0, #0x12]
7009b91c: f8ad 0024    	strh.w	r0, [sp, #0x24]
;                 r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009b920: 980d         	ldr	r0, [sp, #0x34]
7009b922: 8a00         	ldrh	r0, [r0, #0x10]
7009b924: a906         	add	r1, sp, #0x18
7009b926: f008 faf3    	bl	0x700a3f10 <Sciclient_rmIrqGetNode> @ imm = #0x85e6
7009b92a: 900c         	str	r0, [sp, #0x30]
;             }
7009b92c: e7ff         	b	0x7009b92e <Sciclient_rmIrqGetRoute+0xbe> @ imm = #-0x2
;         } else {
7009b92e: e00d         	b	0x7009b94c <Sciclient_rmIrqGetRoute+0xdc> @ imm = #0x1a
7009b930: 2000         	movs	r0, #0x0
;             inp = 0u;
7009b932: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             outp = cfg->s_idx;
7009b936: 980d         	ldr	r0, [sp, #0x34]
7009b938: 8900         	ldrh	r0, [r0, #0x8]
7009b93a: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009b93e: 980d         	ldr	r0, [sp, #0x34]
7009b940: 88c0         	ldrh	r0, [r0, #0x6]
7009b942: a906         	add	r1, sp, #0x18
7009b944: f008 fae4    	bl	0x700a3f10 <Sciclient_rmIrqGetNode> @ imm = #0x85c8
7009b948: 900c         	str	r0, [sp, #0x30]
7009b94a: e7ff         	b	0x7009b94c <Sciclient_rmIrqGetRoute+0xdc> @ imm = #-0x2
;     }
7009b94c: e7ff         	b	0x7009b94e <Sciclient_rmIrqGetRoute+0xde> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009b94e: 980c         	ldr	r0, [sp, #0x30]
7009b950: b948         	cbnz	r0, 0x7009b966 <Sciclient_rmIrqGetRoute+0xf6> @ imm = #0x12
7009b952: e7ff         	b	0x7009b954 <Sciclient_rmIrqGetRoute+0xe4> @ imm = #-0x2
7009b954: 2001         	movs	r0, #0x1
;         search = true;
7009b956: f88d 0021    	strb.w	r0, [sp, #0x21]
7009b95a: 2000         	movs	r0, #0x0
;         rt_complete = false;
7009b95c: f88d 0020    	strb.w	r0, [sp, #0x20]
;         Sciclient_rmPsInit();
7009b960: f011 fb3e    	bl	0x700acfe0 <Sciclient_rmPsInit> @ imm = #0x1167c
;     } else {
7009b964: e003         	b	0x7009b96e <Sciclient_rmIrqGetRoute+0xfe> @ imm = #0x6
7009b966: 2000         	movs	r0, #0x0
;         search = false;
7009b968: f88d 0021    	strb.w	r0, [sp, #0x21]
7009b96c: e7ff         	b	0x7009b96e <Sciclient_rmIrqGetRoute+0xfe> @ imm = #-0x2
7009b96e: 2000         	movs	r0, #0x0
;     for (search_depth = 0u;
7009b970: f8ad 002e    	strh.w	r0, [sp, #0x2e]
7009b974: e7ff         	b	0x7009b976 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x2
;          (search_depth < Sciclient_rmPsGetMaxPsp()) && (search == true);
7009b976: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009b97a: 9002         	str	r0, [sp, #0x8]
7009b97c: f011 ff28    	bl	0x700ad7d0 <Sciclient_rmPsGetMaxPsp> @ imm = #0x11e50
7009b980: 9902         	ldr	r1, [sp, #0x8]
7009b982: 4602         	mov	r2, r0
7009b984: 2000         	movs	r0, #0x0
7009b986: 4291         	cmp	r1, r2
7009b988: 9003         	str	r0, [sp, #0xc]
7009b98a: da06         	bge	0x7009b99a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #0xc
7009b98c: e7ff         	b	0x7009b98e <Sciclient_rmIrqGetRoute+0x11e> @ imm = #-0x2
7009b98e: f89d 0021    	ldrb.w	r0, [sp, #0x21]
7009b992: f000 0001    	and	r0, r0, #0x1
7009b996: 9003         	str	r0, [sp, #0xc]
7009b998: e7ff         	b	0x7009b99a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #-0x2
7009b99a: 9803         	ldr	r0, [sp, #0xc]
;     for (search_depth = 0u;
7009b99c: 07c0         	lsls	r0, r0, #0x1f
7009b99e: 2800         	cmp	r0, #0x0
7009b9a0: f000 80d8    	beq.w	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x1b0
7009b9a4: e7ff         	b	0x7009b9a6 <Sciclient_rmIrqGetRoute+0x136> @ imm = #-0x2
7009b9a6: 2000         	movs	r0, #0x0
;         push_node = false;
7009b9a8: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009b9ac: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009b9b0: e7ff         	b	0x7009b9b2 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0x2
7009b9b2: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009b9b6: 9906         	ldr	r1, [sp, #0x18]
7009b9b8: 8849         	ldrh	r1, [r1, #0x2]
7009b9ba: 4288         	cmp	r0, r1
7009b9bc: da6b         	bge	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xd6
7009b9be: e7ff         	b	0x7009b9c0 <Sciclient_rmIrqGetRoute+0x150> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009b9c0: 9806         	ldr	r0, [sp, #0x18]
7009b9c2: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009b9c6: aa04         	add	r2, sp, #0x10
7009b9c8: f00f fefa    	bl	0x700ab7c0 <Sciclient_rmIrqGetNodeItf> @ imm = #0xfdf4
7009b9cc: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009b9ce: 980c         	ldr	r0, [sp, #0x30]
7009b9d0: b108         	cbz	r0, 0x7009b9d6 <Sciclient_rmIrqGetRoute+0x166> @ imm = #0x2
7009b9d2: e7ff         	b	0x7009b9d4 <Sciclient_rmIrqGetRoute+0x164> @ imm = #-0x2
;                 break;
7009b9d4: e05f         	b	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xbe
;             if ((outp >= cur_if->lbase) &&
7009b9d6: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009b9da: 9904         	ldr	r1, [sp, #0x10]
7009b9dc: 8809         	ldrh	r1, [r1]
7009b9de: 4288         	cmp	r0, r1
7009b9e0: db52         	blt	0x7009ba88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0xa4
7009b9e2: e7ff         	b	0x7009b9e4 <Sciclient_rmIrqGetRoute+0x174> @ imm = #-0x2
;                 (outp < (cur_if->lbase + cur_if->len))) {
7009b9e4: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009b9e8: 9a04         	ldr	r2, [sp, #0x10]
7009b9ea: 8811         	ldrh	r1, [r2]
7009b9ec: 8892         	ldrh	r2, [r2, #0x4]
7009b9ee: 4411         	add	r1, r2
;             if ((outp >= cur_if->lbase) &&
7009b9f0: 4288         	cmp	r0, r1
7009b9f2: da49         	bge	0x7009ba88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0x92
7009b9f4: e7ff         	b	0x7009b9f6 <Sciclient_rmIrqGetRoute+0x186> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
7009b9f6: 9804         	ldr	r0, [sp, #0x10]
7009b9f8: 88c0         	ldrh	r0, [r0, #0x6]
7009b9fa: 990d         	ldr	r1, [sp, #0x34]
7009b9fc: 8949         	ldrh	r1, [r1, #0xa]
7009b9fe: 4288         	cmp	r0, r1
7009ba00: d110         	bne	0x7009ba24 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x20
7009ba02: e7ff         	b	0x7009ba04 <Sciclient_rmIrqGetRoute+0x194> @ imm = #-0x2
;                     (SCICLIENT_OUTP_TO_INP(outp, cur_if->lbase,
7009ba04: 9a04         	ldr	r2, [sp, #0x10]
7009ba06: 8850         	ldrh	r0, [r2, #0x2]
7009ba08: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009ba0c: 8812         	ldrh	r2, [r2]
7009ba0e: 1a89         	subs	r1, r1, r2
7009ba10: 4408         	add	r0, r1
;                      cfg->d_irq)) {
7009ba12: 990d         	ldr	r1, [sp, #0x34]
7009ba14: 8989         	ldrh	r1, [r1, #0xc]
;                 if ((cur_if->rid == cfg->d_id) &&
7009ba16: 4288         	cmp	r0, r1
7009ba18: d104         	bne	0x7009ba24 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x8
7009ba1a: e7ff         	b	0x7009ba1c <Sciclient_rmIrqGetRoute+0x1ac> @ imm = #-0x2
7009ba1c: 2001         	movs	r0, #0x1
;                     rt_complete = true;
7009ba1e: f88d 0020    	strb.w	r0, [sp, #0x20]
;                     break;
7009ba22: e038         	b	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x70
;                 if (Sciclient_rmIrIsIr(cur_if->rid) == true) {
7009ba24: 9804         	ldr	r0, [sp, #0x10]
7009ba26: 88c0         	ldrh	r0, [r0, #0x6]
7009ba28: f010 fdb2    	bl	0x700ac590 <Sciclient_rmIrIsIr> @ imm = #0x10b64
7009ba2c: b358         	cbz	r0, 0x7009ba86 <Sciclient_rmIrqGetRoute+0x216> @ imm = #0x56
7009ba2e: e7ff         	b	0x7009ba30 <Sciclient_rmIrqGetRoute+0x1c0> @ imm = #-0x2
;                     r = Sciclient_rmIrqGetNode(cur_if->rid, &next_n);
7009ba30: 9804         	ldr	r0, [sp, #0x10]
7009ba32: 88c0         	ldrh	r0, [r0, #0x6]
7009ba34: a905         	add	r1, sp, #0x14
7009ba36: f008 fa6b    	bl	0x700a3f10 <Sciclient_rmIrqGetNode> @ imm = #0x84d6
7009ba3a: 900c         	str	r0, [sp, #0x30]
;                     if (r != SystemP_SUCCESS) {
7009ba3c: 980c         	ldr	r0, [sp, #0x30]
7009ba3e: b108         	cbz	r0, 0x7009ba44 <Sciclient_rmIrqGetRoute+0x1d4> @ imm = #0x2
7009ba40: e7ff         	b	0x7009ba42 <Sciclient_rmIrqGetRoute+0x1d2> @ imm = #-0x2
;                         break;
7009ba42: e028         	b	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x50
;                     next_inp = SCICLIENT_OUTP_TO_INP(outp,
7009ba44: 9a04         	ldr	r2, [sp, #0x10]
7009ba46: 8850         	ldrh	r0, [r2, #0x2]
7009ba48: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009ba4c: 8812         	ldrh	r2, [r2]
7009ba4e: 1a89         	subs	r1, r1, r2
7009ba50: 4408         	add	r0, r1
7009ba52: f8ad 0026    	strh.w	r0, [sp, #0x26]
;                     r = Sciclient_rmIrGetOutp(next_n->id, next_inp,
7009ba56: 9805         	ldr	r0, [sp, #0x14]
7009ba58: 8800         	ldrh	r0, [r0]
7009ba5a: f8bd 1026    	ldrh.w	r1, [sp, #0x26]
7009ba5e: f10d 0222    	add.w	r2, sp, #0x22
7009ba62: f007 fe75    	bl	0x700a3750 <Sciclient_rmIrGetOutp> @ imm = #0x7cea
7009ba66: 900c         	str	r0, [sp, #0x30]
;                     if (r == SystemP_SUCCESS) {
7009ba68: 980c         	ldr	r0, [sp, #0x30]
7009ba6a: b930         	cbnz	r0, 0x7009ba7a <Sciclient_rmIrqGetRoute+0x20a> @ imm = #0xc
7009ba6c: e7ff         	b	0x7009ba6e <Sciclient_rmIrqGetRoute+0x1fe> @ imm = #-0x2
7009ba6e: 2001         	movs	r0, #0x1
;                         push_node = true;
7009ba70: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009ba74: 2000         	movs	r0, #0x0
;                         r = SystemP_SUCCESS;
7009ba76: 900c         	str	r0, [sp, #0x30]
;                         break;
7009ba78: e00d         	b	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x1a
;                     if (r != SystemP_FAILURE) {
7009ba7a: 980c         	ldr	r0, [sp, #0x30]
7009ba7c: 3001         	adds	r0, #0x1
7009ba7e: b108         	cbz	r0, 0x7009ba84 <Sciclient_rmIrqGetRoute+0x214> @ imm = #0x2
7009ba80: e7ff         	b	0x7009ba82 <Sciclient_rmIrqGetRoute+0x212> @ imm = #-0x2
;                         break;
7009ba82: e008         	b	0x7009ba96 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x10
;                 }
7009ba84: e7ff         	b	0x7009ba86 <Sciclient_rmIrqGetRoute+0x216> @ imm = #-0x2
;             }
7009ba86: e7ff         	b	0x7009ba88 <Sciclient_rmIrqGetRoute+0x218> @ imm = #-0x2
;         }
7009ba88: e7ff         	b	0x7009ba8a <Sciclient_rmIrqGetRoute+0x21a> @ imm = #-0x2
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009ba8a: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009ba8e: 3001         	adds	r0, #0x1
7009ba90: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009ba94: e78d         	b	0x7009b9b2 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0xe6
;         if (r != SystemP_SUCCESS) {
7009ba96: 980c         	ldr	r0, [sp, #0x30]
7009ba98: b108         	cbz	r0, 0x7009ba9e <Sciclient_rmIrqGetRoute+0x22e> @ imm = #0x2
7009ba9a: e7ff         	b	0x7009ba9c <Sciclient_rmIrqGetRoute+0x22c> @ imm = #-0x2
;             break;
7009ba9c: e05a         	b	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0xb4
;         if ((rt_complete == true) || (push_node == true)) {
7009ba9e: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009baa2: 07c0         	lsls	r0, r0, #0x1f
7009baa4: b930         	cbnz	r0, 0x7009bab4 <Sciclient_rmIrqGetRoute+0x244> @ imm = #0xc
7009baa6: e7ff         	b	0x7009baa8 <Sciclient_rmIrqGetRoute+0x238> @ imm = #-0x2
7009baa8: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009baac: 07c0         	lsls	r0, r0, #0x1f
7009baae: 2800         	cmp	r0, #0x0
7009bab0: d049         	beq	0x7009bb46 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #0x92
7009bab2: e7ff         	b	0x7009bab4 <Sciclient_rmIrqGetRoute+0x244> @ imm = #-0x2
;             r = Sciclient_rmPsPush(cur_n, if_idx);
7009bab4: 9806         	ldr	r0, [sp, #0x18]
7009bab6: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009baba: f00e fcc1    	bl	0x700aa440 <Sciclient_rmPsPush> @ imm = #0xe982
7009babe: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009bac0: 980c         	ldr	r0, [sp, #0x30]
7009bac2: b108         	cbz	r0, 0x7009bac8 <Sciclient_rmIrqGetRoute+0x258> @ imm = #0x2
7009bac4: e7ff         	b	0x7009bac6 <Sciclient_rmIrqGetRoute+0x256> @ imm = #-0x2
;                 break;
7009bac6: e045         	b	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x8a
;             if ((search_depth > 0u) ||
7009bac8: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bacc: b950         	cbnz	r0, 0x7009bae4 <Sciclient_rmIrqGetRoute+0x274> @ imm = #0x14
7009bace: e7ff         	b	0x7009bad0 <Sciclient_rmIrqGetRoute+0x260> @ imm = #-0x2
;                 ((search_depth == 0u) &&
7009bad0: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bad4: bb28         	cbnz	r0, 0x7009bb22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x4a
7009bad6: e7ff         	b	0x7009bad8 <Sciclient_rmIrqGetRoute+0x268> @ imm = #-0x2
;                  (Sciclient_rmIaIsIa(cur_n->id) == true))) {
7009bad8: 9806         	ldr	r0, [sp, #0x18]
7009bada: 8800         	ldrh	r0, [r0]
7009badc: f010 fd40    	bl	0x700ac560 <Sciclient_rmIaIsIa> @ imm = #0x10a80
;             if ((search_depth > 0u) ||
7009bae0: b1f8         	cbz	r0, 0x7009bb22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x3e
7009bae2: e7ff         	b	0x7009bae4 <Sciclient_rmIrqGetRoute+0x274> @ imm = #-0x2
;                 cur_psp = Sciclient_rmPsGetPsp();
7009bae4: f011 fe2c    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0x11c58
7009bae8: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 r = Sciclient_rmPsSetInp(cur_psp - (1u), inp);
7009baec: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009baf0: 3801         	subs	r0, #0x1
7009baf2: f8bd 1028    	ldrh.w	r1, [sp, #0x28]
7009baf6: b280         	uxth	r0, r0
7009baf8: f00f fad2    	bl	0x700ab0a0 <Sciclient_rmPsSetInp> @ imm = #0xf5a4
7009bafc: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009bafe: 980c         	ldr	r0, [sp, #0x30]
7009bb00: b108         	cbz	r0, 0x7009bb06 <Sciclient_rmIrqGetRoute+0x296> @ imm = #0x2
7009bb02: e7ff         	b	0x7009bb04 <Sciclient_rmIrqGetRoute+0x294> @ imm = #-0x2
;                     break;
7009bb04: e026         	b	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x4c
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009bb06: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009bb0a: 3801         	subs	r0, #0x1
;                         outp);
7009bb0c: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009bb10: b280         	uxth	r0, r0
7009bb12: f00f faed    	bl	0x700ab0f0 <Sciclient_rmPsSetOutp> @ imm = #0xf5da
7009bb16: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009bb18: 980c         	ldr	r0, [sp, #0x30]
7009bb1a: b108         	cbz	r0, 0x7009bb20 <Sciclient_rmIrqGetRoute+0x2b0> @ imm = #0x2
7009bb1c: e7ff         	b	0x7009bb1e <Sciclient_rmIrqGetRoute+0x2ae> @ imm = #-0x2
;                     break;
7009bb1e: e019         	b	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x32
;             }
7009bb20: e7ff         	b	0x7009bb22 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #-0x2
;             if (rt_complete == true) {
7009bb22: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009bb26: 07c0         	lsls	r0, r0, #0x1f
7009bb28: b108         	cbz	r0, 0x7009bb2e <Sciclient_rmIrqGetRoute+0x2be> @ imm = #0x2
7009bb2a: e7ff         	b	0x7009bb2c <Sciclient_rmIrqGetRoute+0x2bc> @ imm = #-0x2
;                 break;
7009bb2c: e012         	b	0x7009bb54 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x24
;                 cur_n = next_n;
7009bb2e: 9805         	ldr	r0, [sp, #0x14]
7009bb30: 9006         	str	r0, [sp, #0x18]
;                 inp = next_inp;
7009bb32: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009bb36: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = next_outp;
7009bb3a: f8bd 0022    	ldrh.w	r0, [sp, #0x22]
7009bb3e: f8ad 0024    	strh.w	r0, [sp, #0x24]
7009bb42: e7ff         	b	0x7009bb44 <Sciclient_rmIrqGetRoute+0x2d4> @ imm = #-0x2
;         }
7009bb44: e7ff         	b	0x7009bb46 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #-0x2
;     }
7009bb46: e7ff         	b	0x7009bb48 <Sciclient_rmIrqGetRoute+0x2d8> @ imm = #-0x2
;          search_depth++) {
7009bb48: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bb4c: 3001         	adds	r0, #0x1
7009bb4e: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;     for (search_depth = 0u;
7009bb52: e710         	b	0x7009b976 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x1e0
;     if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009bb54: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009bb58: 9001         	str	r0, [sp, #0x4]
7009bb5a: f011 fe39    	bl	0x700ad7d0 <Sciclient_rmPsGetMaxPsp> @ imm = #0x11c72
7009bb5e: 4601         	mov	r1, r0
7009bb60: 9801         	ldr	r0, [sp, #0x4]
7009bb62: 4288         	cmp	r0, r1
7009bb64: db04         	blt	0x7009bb70 <Sciclient_rmIrqGetRoute+0x300> @ imm = #0x8
7009bb66: e7ff         	b	0x7009bb68 <Sciclient_rmIrqGetRoute+0x2f8> @ imm = #-0x2
7009bb68: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
7009bb6c: 900c         	str	r0, [sp, #0x30]
;     }
7009bb6e: e7ff         	b	0x7009bb70 <Sciclient_rmIrqGetRoute+0x300> @ imm = #-0x2
;     return r;
7009bb70: 980c         	ldr	r0, [sp, #0x30]
7009bb72: b00e         	add	sp, #0x38
7009bb74: bd80         	pop	{r7, pc}
		...
7009bb7e: 0000         	movs	r0, r0

7009bb80 <Udma_eventReset>:
; {
7009bb80: b580         	push	{r7, lr}
7009bb82: b090         	sub	sp, #0x40
7009bb84: 900f         	str	r0, [sp, #0x3c]
7009bb86: 910e         	str	r1, [sp, #0x38]
7009bb88: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009bb8a: 9001         	str	r0, [sp, #0x4]
7009bb8c: 900d         	str	r0, [sp, #0x34]
;     eventPrms = &eventHandle->eventPrms;
7009bb8e: 990e         	ldr	r1, [sp, #0x38]
7009bb90: 3108         	adds	r1, #0x8
7009bb92: 9109         	str	r1, [sp, #0x24]
;     rmIrqReq.valid_params           = 0U;
7009bb94: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.global_event           = 0U;
7009bb96: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.src_id                 = 0U;
7009bb9a: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     rmIrqReq.src_index              = 0U;
7009bb9e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;     rmIrqReq.dst_id                 = 0U;
7009bba2: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     rmIrqReq.dst_host_irq           = 0U;
7009bba6: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     rmIrqReq.ia_id                  = 0U;
7009bbaa: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint                   = 0U;
7009bbae: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009bbb2: f88d 0022    	strb.w	r0, [sp, #0x22]
7009bbb6: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009bbb8: f88d 0023    	strb.w	r0, [sp, #0x23]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009bbbc: 9809         	ldr	r0, [sp, #0x24]
7009bbbe: 6800         	ldr	r0, [r0]
7009bbc0: 2805         	cmp	r0, #0x5
7009bbc2: d00a         	beq	0x7009bbda <Udma_eventReset+0x5a> @ imm = #0x14
7009bbc4: e7ff         	b	0x7009bbc6 <Udma_eventReset+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009bbc6: 9804         	ldr	r0, [sp, #0x10]
7009bbc8: f040 0010    	orr	r0, r0, #0x10
7009bbcc: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009bbce: 980e         	ldr	r0, [sp, #0x38]
7009bbd0: f00f fab6    	bl	0x700ab140 <Udma_eventGetId> @ imm = #0xf56c
7009bbd4: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     }
7009bbd8: e7ff         	b	0x7009bbda <Udma_eventReset+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009bbda: 980e         	ldr	r0, [sp, #0x38]
7009bbdc: 6d80         	ldr	r0, [r0, #0x58]
7009bbde: f510 3f80    	cmn.w	r0, #0x10000
7009bbe2: d012         	beq	0x7009bc0a <Udma_eventReset+0x8a> @ imm = #0x24
7009bbe4: e7ff         	b	0x7009bbe6 <Udma_eventReset+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009bbe6: 9804         	ldr	r0, [sp, #0x10]
7009bbe8: f040 0001    	orr	r0, r0, #0x1
7009bbec: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009bbee: 9804         	ldr	r0, [sp, #0x10]
7009bbf0: f040 0002    	orr	r0, r0, #0x2
7009bbf4: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.dst_id       = drvHandle->devIdCore;
7009bbf6: 980f         	ldr	r0, [sp, #0x3c]
7009bbf8: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009bbfc: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmIrqReq.dst_host_irq = (uint16_t)eventHandle->coreIntrNum;
7009bc00: 980e         	ldr	r0, [sp, #0x38]
7009bc02: 6d80         	ldr	r0, [r0, #0x58]
7009bc04: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     }
7009bc08: e7ff         	b	0x7009bc0a <Udma_eventReset+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009bc0a: 980e         	ldr	r0, [sp, #0x38]
7009bc0c: 6980         	ldr	r0, [r0, #0x18]
7009bc0e: b128         	cbz	r0, 0x7009bc1c <Udma_eventReset+0x9c> @ imm = #0xa
7009bc10: e7ff         	b	0x7009bc12 <Udma_eventReset+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009bc12: 980e         	ldr	r0, [sp, #0x38]
7009bc14: 6980         	ldr	r0, [r0, #0x18]
7009bc16: 6cc0         	ldr	r0, [r0, #0x4c]
7009bc18: 900c         	str	r0, [sp, #0x30]
;     }
7009bc1a: e003         	b	0x7009bc24 <Udma_eventReset+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009bc1c: 980e         	ldr	r0, [sp, #0x38]
7009bc1e: 6cc0         	ldr	r0, [r0, #0x4c]
7009bc20: 900c         	str	r0, [sp, #0x30]
7009bc22: e7ff         	b	0x7009bc24 <Udma_eventReset+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009bc24: 9804         	ldr	r0, [sp, #0x10]
7009bc26: f040 0004    	orr	r0, r0, #0x4
7009bc2a: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009bc2c: 9804         	ldr	r0, [sp, #0x10]
7009bc2e: f040 0008    	orr	r0, r0, #0x8
7009bc32: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009bc34: 980f         	ldr	r0, [sp, #0x3c]
7009bc36: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009bc3a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009bc3e: 980c         	ldr	r0, [sp, #0x30]
7009bc40: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009bc44: 980e         	ldr	r0, [sp, #0x38]
7009bc46: 6d00         	ldr	r0, [r0, #0x50]
7009bc48: f64f 71ff    	movw	r1, #0xffff
7009bc4c: 4288         	cmp	r0, r1
7009bc4e: d009         	beq	0x7009bc64 <Udma_eventReset+0xe4> @ imm = #0x12
7009bc50: e7ff         	b	0x7009bc52 <Udma_eventReset+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009bc52: 9804         	ldr	r0, [sp, #0x10]
7009bc54: f040 0020    	orr	r0, r0, #0x20
7009bc58: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009bc5a: 980e         	ldr	r0, [sp, #0x38]
7009bc5c: 6d00         	ldr	r0, [r0, #0x50]
7009bc5e: f88d 0022    	strb.w	r0, [sp, #0x22]
;     }
7009bc62: e7ff         	b	0x7009bc64 <Udma_eventReset+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009bc64: 9809         	ldr	r0, [sp, #0x24]
7009bc66: 6800         	ldr	r0, [r0]
7009bc68: 2801         	cmp	r0, #0x1
7009bc6a: d00a         	beq	0x7009bc82 <Udma_eventReset+0x102> @ imm = #0x14
7009bc6c: e7ff         	b	0x7009bc6e <Udma_eventReset+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType)||
7009bc6e: 9809         	ldr	r0, [sp, #0x24]
7009bc70: 6800         	ldr	r0, [r0]
7009bc72: 2806         	cmp	r0, #0x6
7009bc74: d005         	beq	0x7009bc82 <Udma_eventReset+0x102> @ imm = #0xa
7009bc76: e7ff         	b	0x7009bc78 <Udma_eventReset+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009bc78: 9809         	ldr	r0, [sp, #0x24]
7009bc7a: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009bc7c: 2802         	cmp	r0, #0x2
7009bc7e: d14d         	bne	0x7009bd1c <Udma_eventReset+0x19c> @ imm = #0x9a
7009bc80: e7ff         	b	0x7009bc82 <Udma_eventReset+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009bc82: 9809         	ldr	r0, [sp, #0x24]
7009bc84: 6880         	ldr	r0, [r0, #0x8]
7009bc86: 900b         	str	r0, [sp, #0x2c]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009bc88: 980f         	ldr	r0, [sp, #0x3c]
7009bc8a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009bc8e: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009bc92: 9809         	ldr	r0, [sp, #0x24]
7009bc94: 6800         	ldr	r0, [r0]
7009bc96: 2801         	cmp	r0, #0x1
7009bc98: d005         	beq	0x7009bca6 <Udma_eventReset+0x126> @ imm = #0xa
7009bc9a: e7ff         	b	0x7009bc9c <Udma_eventReset+0x11c> @ imm = #-0x2
7009bc9c: 9809         	ldr	r0, [sp, #0x24]
7009bc9e: 6800         	ldr	r0, [r0]
7009bca0: 2806         	cmp	r0, #0x6
7009bca2: d12e         	bne	0x7009bd02 <Udma_eventReset+0x182> @ imm = #0x5c
7009bca4: e7ff         	b	0x7009bca6 <Udma_eventReset+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009bca6: 980b         	ldr	r0, [sp, #0x2c]
7009bca8: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009bcac: 8880         	ldrh	r0, [r0, #0x4]
7009bcae: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009bcb2: 980b         	ldr	r0, [sp, #0x2c]
7009bcb4: 7800         	ldrb	r0, [r0]
7009bcb6: 0740         	lsls	r0, r0, #0x1d
7009bcb8: 2800         	cmp	r0, #0x0
7009bcba: d509         	bpl	0x7009bcd0 <Udma_eventReset+0x150> @ imm = #0x12
7009bcbc: e7ff         	b	0x7009bcbe <Udma_eventReset+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009bcbe: 980f         	ldr	r0, [sp, #0x3c]
7009bcc0: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009bcc4: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bcc8: 4408         	add	r0, r1
7009bcca: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bcce: e017         	b	0x7009bd00 <Udma_eventReset+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009bcd0: 980b         	ldr	r0, [sp, #0x2c]
7009bcd2: 7800         	ldrb	r0, [r0]
7009bcd4: 07c0         	lsls	r0, r0, #0x1f
7009bcd6: b148         	cbz	r0, 0x7009bcec <Udma_eventReset+0x16c> @ imm = #0x12
7009bcd8: e7ff         	b	0x7009bcda <Udma_eventReset+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009bcda: 980f         	ldr	r0, [sp, #0x3c]
7009bcdc: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009bce0: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bce4: 4408         	add	r0, r1
7009bce6: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bcea: e008         	b	0x7009bcfe <Udma_eventReset+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009bcec: 980f         	ldr	r0, [sp, #0x3c]
7009bcee: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009bcf2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bcf6: 4408         	add	r0, r1
7009bcf8: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009bcfc: e7ff         	b	0x7009bcfe <Udma_eventReset+0x17e> @ imm = #-0x2
7009bcfe: e7ff         	b	0x7009bd00 <Udma_eventReset+0x180> @ imm = #-0x2
;         }
7009bd00: e00b         	b	0x7009bd1a <Udma_eventReset+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009bd02: 980b         	ldr	r0, [sp, #0x2c]
7009bd04: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009bd08: 8880         	ldrh	r0, [r0, #0x4]
7009bd0a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009bd0e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bd12: 3014         	adds	r0, #0x14
7009bd14: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009bd18: e7ff         	b	0x7009bd1a <Udma_eventReset+0x19a> @ imm = #-0x2
;     }
7009bd1a: e7ff         	b	0x7009bd1c <Udma_eventReset+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009bd1c: 9809         	ldr	r0, [sp, #0x24]
7009bd1e: 6800         	ldr	r0, [r0]
7009bd20: 2803         	cmp	r0, #0x3
7009bd22: d156         	bne	0x7009bdd2 <Udma_eventReset+0x252> @ imm = #0xac
7009bd24: e7ff         	b	0x7009bd26 <Udma_eventReset+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009bd26: 980f         	ldr	r0, [sp, #0x3c]
7009bd28: 6800         	ldr	r0, [r0]
7009bd2a: 2802         	cmp	r0, #0x2
7009bd2c: d104         	bne	0x7009bd38 <Udma_eventReset+0x1b8> @ imm = #0x8
7009bd2e: e7ff         	b	0x7009bd30 <Udma_eventReset+0x1b0> @ imm = #-0x2
7009bd30: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009bd34: 900d         	str	r0, [sp, #0x34]
;         }
7009bd36: e04b         	b	0x7009bdd0 <Udma_eventReset+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009bd38: 9809         	ldr	r0, [sp, #0x24]
7009bd3a: 6880         	ldr	r0, [r0, #0x8]
7009bd3c: 900b         	str	r0, [sp, #0x2c]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009bd3e: 980f         	ldr	r0, [sp, #0x3c]
7009bd40: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009bd44: f8ad 0014    	strh.w	r0, [sp, #0x14]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009bd48: 980b         	ldr	r0, [sp, #0x2c]
7009bd4a: 7800         	ldrb	r0, [r0]
7009bd4c: 0740         	lsls	r0, r0, #0x1d
7009bd4e: 2800         	cmp	r0, #0x0
7009bd50: d50d         	bpl	0x7009bd6e <Udma_eventReset+0x1ee> @ imm = #0x1a
7009bd52: e7ff         	b	0x7009bd54 <Udma_eventReset+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009bd54: 980b         	ldr	r0, [sp, #0x2c]
7009bd56: 6ec0         	ldr	r0, [r0, #0x6c]
7009bd58: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009bd5c: 980f         	ldr	r0, [sp, #0x3c]
7009bd5e: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009bd62: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bd66: 4408         	add	r0, r1
7009bd68: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bd6c: e02f         	b	0x7009bdce <Udma_eventReset+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009bd6e: 980b         	ldr	r0, [sp, #0x2c]
7009bd70: 7800         	ldrb	r0, [r0]
7009bd72: 0780         	lsls	r0, r0, #0x1e
7009bd74: 2800         	cmp	r0, #0x0
7009bd76: d50d         	bpl	0x7009bd94 <Udma_eventReset+0x214> @ imm = #0x1a
7009bd78: e7ff         	b	0x7009bd7a <Udma_eventReset+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009bd7a: 980b         	ldr	r0, [sp, #0x2c]
7009bd7c: 6f00         	ldr	r0, [r0, #0x70]
7009bd7e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009bd82: 980f         	ldr	r0, [sp, #0x3c]
7009bd84: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009bd88: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bd8c: 4408         	add	r0, r1
7009bd8e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bd92: e01b         	b	0x7009bdcc <Udma_eventReset+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009bd94: 980b         	ldr	r0, [sp, #0x2c]
7009bd96: 7800         	ldrb	r0, [r0]
7009bd98: 07c0         	lsls	r0, r0, #0x1f
7009bd9a: b168         	cbz	r0, 0x7009bdb8 <Udma_eventReset+0x238> @ imm = #0x1a
7009bd9c: e7ff         	b	0x7009bd9e <Udma_eventReset+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009bd9e: 980b         	ldr	r0, [sp, #0x2c]
7009bda0: 6ec0         	ldr	r0, [r0, #0x6c]
7009bda2: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009bda6: 980f         	ldr	r0, [sp, #0x3c]
7009bda8: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009bdac: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bdb0: 4408         	add	r0, r1
7009bdb2: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009bdb6: e008         	b	0x7009bdca <Udma_eventReset+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009bdb8: 980f         	ldr	r0, [sp, #0x3c]
7009bdba: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009bdbe: f8ad 0014    	strh.w	r0, [sp, #0x14]
7009bdc2: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009bdc4: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009bdc8: e7ff         	b	0x7009bdca <Udma_eventReset+0x24a> @ imm = #-0x2
7009bdca: e7ff         	b	0x7009bdcc <Udma_eventReset+0x24c> @ imm = #-0x2
7009bdcc: e7ff         	b	0x7009bdce <Udma_eventReset+0x24e> @ imm = #-0x2
7009bdce: e7ff         	b	0x7009bdd0 <Udma_eventReset+0x250> @ imm = #-0x2
;     }
7009bdd0: e7ff         	b	0x7009bdd2 <Udma_eventReset+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009bdd2: 9809         	ldr	r0, [sp, #0x24]
7009bdd4: 6800         	ldr	r0, [r0]
7009bdd6: 2804         	cmp	r0, #0x4
7009bdd8: d130         	bne	0x7009be3c <Udma_eventReset+0x2bc> @ imm = #0x60
7009bdda: e7ff         	b	0x7009bddc <Udma_eventReset+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009bddc: 9809         	ldr	r0, [sp, #0x24]
7009bdde: 68c0         	ldr	r0, [r0, #0xc]
7009bde0: 900a         	str	r0, [sp, #0x28]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009bde2: 980f         	ldr	r0, [sp, #0x3c]
7009bde4: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009bde8: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009bdec: 980a         	ldr	r0, [sp, #0x28]
7009bdee: 8880         	ldrh	r0, [r0, #0x4]
7009bdf0: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009bdf4: 980f         	ldr	r0, [sp, #0x3c]
7009bdf6: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009bdfa: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009bdfe: 4408         	add	r0, r1
7009be00: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009be04: 980a         	ldr	r0, [sp, #0x28]
7009be06: 6dc0         	ldr	r0, [r0, #0x5c]
7009be08: 2804         	cmp	r0, #0x4
7009be0a: d316         	blo	0x7009be3a <Udma_eventReset+0x2ba> @ imm = #0x2c
7009be0c: e7ff         	b	0x7009be0e <Udma_eventReset+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009be0e: 980a         	ldr	r0, [sp, #0x28]
7009be10: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009be12: 2807         	cmp	r0, #0x7
7009be14: d811         	bhi	0x7009be3a <Udma_eventReset+0x2ba> @ imm = #0x22
7009be16: e7ff         	b	0x7009be18 <Udma_eventReset+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009be18: 980f         	ldr	r0, [sp, #0x3c]
7009be1a: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009be1e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009be22: 1a40         	subs	r0, r0, r1
7009be24: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009be28: 980f         	ldr	r0, [sp, #0x3c]
7009be2a: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009be2e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009be32: 4408         	add	r0, r1
7009be34: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         }
7009be38: e7ff         	b	0x7009be3a <Udma_eventReset+0x2ba> @ imm = #-0x2
;     }
7009be3a: e7ff         	b	0x7009be3c <Udma_eventReset+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009be3c: 980d         	ldr	r0, [sp, #0x34]
7009be3e: b9b0         	cbnz	r0, 0x7009be6e <Udma_eventReset+0x2ee> @ imm = #0x2c
7009be40: e7ff         	b	0x7009be42 <Udma_eventReset+0x2c2> @ imm = #-0x2
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009be42: 980f         	ldr	r0, [sp, #0x3c]
7009be44: 6800         	ldr	r0, [r0]
7009be46: b130         	cbz	r0, 0x7009be56 <Udma_eventReset+0x2d6> @ imm = #0xc
7009be48: e7ff         	b	0x7009be4a <Udma_eventReset+0x2ca> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009be4a: 9809         	ldr	r0, [sp, #0x24]
7009be4c: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009be4e: 2805         	cmp	r0, #0x5
7009be50: d101         	bne	0x7009be56 <Udma_eventReset+0x2d6> @ imm = #0x2
7009be52: e7ff         	b	0x7009be54 <Udma_eventReset+0x2d4> @ imm = #-0x2
;         }
7009be54: e00a         	b	0x7009be6c <Udma_eventReset+0x2ec> @ imm = #0x14
7009be56: a802         	add	r0, sp, #0x8
7009be58: f04f 31ff    	mov.w	r1, #0xffffffff
;             retVal = Sciclient_rmIrqRelease(&rmIrqReq, UDMA_SCICLIENT_TIMEOUT);
7009be5c: f011 faa0    	bl	0x700ad3a0 <Sciclient_rmIrqRelease> @ imm = #0x11540
7009be60: 900d         	str	r0, [sp, #0x34]
;             if(CSL_PASS != retVal)
7009be62: 980d         	ldr	r0, [sp, #0x34]
7009be64: b108         	cbz	r0, 0x7009be6a <Udma_eventReset+0x2ea> @ imm = #0x2
7009be66: e7ff         	b	0x7009be68 <Udma_eventReset+0x2e8> @ imm = #-0x2
;             }
7009be68: e7ff         	b	0x7009be6a <Udma_eventReset+0x2ea> @ imm = #-0x2
7009be6a: e7ff         	b	0x7009be6c <Udma_eventReset+0x2ec> @ imm = #-0x2
;     }
7009be6c: e7ff         	b	0x7009be6e <Udma_eventReset+0x2ee> @ imm = #-0x2
;     return (retVal);
7009be6e: 980d         	ldr	r0, [sp, #0x34]
7009be70: b010         	add	sp, #0x40
7009be72: bd80         	pop	{r7, pc}
		...

7009be80 <Sciclient_service>:
; {
7009be80: b580         	push	{r7, lr}
7009be82: b094         	sub	sp, #0x50
7009be84: 9013         	str	r0, [sp, #0x4c]
7009be86: 9112         	str	r1, [sp, #0x48]
7009be88: 2000         	movs	r0, #0x0
;     int32_t   status        = SystemP_SUCCESS;
7009be8a: 9011         	str	r0, [sp, #0x44]
7009be8c: 210f         	movs	r1, #0xf
;     uint32_t  contextId     = SCICLIENT_CONTEXT_MAX_NUM;
7009be8e: 9110         	str	r1, [sp, #0x40]
;     uint32_t  initialCount  = 0U;
7009be90: 900f         	str	r0, [sp, #0x3c]
;     uint8_t   localSeqId    = gSciclientHandle.currSeqId;
7009be92: f240 1138    	movw	r1, #0x138
7009be96: f2c7 010b    	movt	r1, #0x700b
7009be9a: 6809         	ldr	r1, [r1]
7009be9c: f88d 103b    	strb.w	r1, [sp, #0x3b]
;     uint32_t  txPayloadSize = 0U;
7009bea0: 900d         	str	r0, [sp, #0x34]
;     uint32_t  rxPayloadSize = 0U;
7009bea2: 900c         	str	r0, [sp, #0x30]
;     uint8_t  *pLocalRespPayload = NULL;
7009bea4: 900b         	str	r0, [sp, #0x2c]
;     uint8_t  *pSecHeader = NULL;
7009bea6: 9007         	str	r0, [sp, #0x1c]
;     if((pReqPrm == NULL) || (pRespPrm == NULL) || (pReqPrm->pReqPayload == NULL))
7009bea8: 9813         	ldr	r0, [sp, #0x4c]
7009beaa: b138         	cbz	r0, 0x7009bebc <Sciclient_service+0x3c> @ imm = #0xe
7009beac: e7ff         	b	0x7009beae <Sciclient_service+0x2e> @ imm = #-0x2
7009beae: 9812         	ldr	r0, [sp, #0x48]
7009beb0: b120         	cbz	r0, 0x7009bebc <Sciclient_service+0x3c> @ imm = #0x8
7009beb2: e7ff         	b	0x7009beb4 <Sciclient_service+0x34> @ imm = #-0x2
7009beb4: 9813         	ldr	r0, [sp, #0x4c]
7009beb6: 6880         	ldr	r0, [r0, #0x8]
7009beb8: b920         	cbnz	r0, 0x7009bec4 <Sciclient_service+0x44> @ imm = #0x8
7009beba: e7ff         	b	0x7009bebc <Sciclient_service+0x3c> @ imm = #-0x2
7009bebc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009bec0: 9011         	str	r0, [sp, #0x44]
;     }
7009bec2: e09e         	b	0x7009c002 <Sciclient_service+0x182> @ imm = #0x13c
;         contextId = Sciclient_getCurrentContext(pReqPrm->messageType);
7009bec4: 9813         	ldr	r0, [sp, #0x4c]
7009bec6: 8800         	ldrh	r0, [r0]
7009bec8: f009 fdb2    	bl	0x700a5a30 <Sciclient_getCurrentContext> @ imm = #0x9b64
7009becc: 9010         	str	r0, [sp, #0x40]
;         if(contextId < SCICLIENT_CONTEXT_MAX_NUM)
7009bece: 9810         	ldr	r0, [sp, #0x40]
7009bed0: 280e         	cmp	r0, #0xe
7009bed2: f200 8091    	bhi.w	0x7009bff8 <Sciclient_service+0x178> @ imm = #0x122
7009bed6: e7ff         	b	0x7009bed8 <Sciclient_service+0x58> @ imm = #-0x2
;             txThread = Sciclient_getTxThreadId(contextId);
7009bed8: 9810         	ldr	r0, [sp, #0x40]
7009beda: f011 f831    	bl	0x700acf40 <Sciclient_getTxThreadId> @ imm = #0x11062
7009bede: 900a         	str	r0, [sp, #0x28]
;             rxThread = Sciclient_getRxThreadId(contextId);
7009bee0: 9810         	ldr	r0, [sp, #0x40]
7009bee2: f011 f81d    	bl	0x700acf20 <Sciclient_getRxThreadId> @ imm = #0x1103a
7009bee6: 9009         	str	r0, [sp, #0x24]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009bee8: 9810         	ldr	r0, [sp, #0x40]
7009beea: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009beee: f64e 5088    	movw	r0, #0xed88
7009bef2: f2c7 000a    	movt	r0, #0x700a
7009bef6: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009befa: b938         	cbnz	r0, 0x7009bf0c <Sciclient_service+0x8c> @ imm = #0xe
7009befc: e7ff         	b	0x7009befe <Sciclient_service+0x7e> @ imm = #-0x2
;                 gSecHeaderSizeWords = sizeof(struct tisci_sec_header)/sizeof(uint32_t);
7009befe: f240 2120    	movw	r1, #0x220
7009bf02: f2c7 010b    	movt	r1, #0x700b
7009bf06: 2001         	movs	r0, #0x1
7009bf08: 7008         	strb	r0, [r1]
;             }
7009bf0a: e006         	b	0x7009bf1a <Sciclient_service+0x9a> @ imm = #0xc
;                 gSecHeaderSizeWords = 0;
7009bf0c: f240 2120    	movw	r1, #0x220
7009bf10: f2c7 010b    	movt	r1, #0x700b
7009bf14: 2000         	movs	r0, #0x0
7009bf16: 7008         	strb	r0, [r1]
7009bf18: e7ff         	b	0x7009bf1a <Sciclient_service+0x9a> @ imm = #-0x2
;             gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
7009bf1a: f240 00e8    	movw	r0, #0xe8
7009bf1e: f2c7 000b    	movt	r0, #0x700b
7009bf22: f010 fb05    	bl	0x700ac530 <CSL_secProxyGetMaxMsgSize> @ imm = #0x1060a
7009bf26: 3804         	subs	r0, #0x4
7009bf28: f240 1138    	movw	r1, #0x138
7009bf2c: f2c7 010b    	movt	r1, #0x700b
7009bf30: 6148         	str	r0, [r1, #0x14]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009bf32: 9810         	ldr	r0, [sp, #0x40]
7009bf34: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009bf38: f64e 5088    	movw	r0, #0xed88
7009bf3c: f2c7 000a    	movt	r0, #0x700a
7009bf40: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009bf44: b940         	cbnz	r0, 0x7009bf58 <Sciclient_service+0xd8> @ imm = #0x10
7009bf46: e7ff         	b	0x7009bf48 <Sciclient_service+0xc8> @ imm = #-0x2
7009bf48: 2000         	movs	r0, #0x0
;                 secHeader.integ_check = (uint16_t)0;
7009bf4a: f8ad 0014    	strh.w	r0, [sp, #0x14]
;                 secHeader.rsvd = (uint16_t)0;
7009bf4e: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009bf52: a805         	add	r0, sp, #0x14
;                 pSecHeader = (uint8_t * )(&secHeader);
7009bf54: 9007         	str	r0, [sp, #0x1c]
;             }
7009bf56: e7ff         	b	0x7009bf58 <Sciclient_service+0xd8> @ imm = #-0x2
;             if (pReqPrm->reqPayloadSize > 0U)
7009bf58: 9813         	ldr	r0, [sp, #0x4c]
7009bf5a: 68c0         	ldr	r0, [r0, #0xc]
7009bf5c: b128         	cbz	r0, 0x7009bf6a <Sciclient_service+0xea> @ imm = #0xa
7009bf5e: e7ff         	b	0x7009bf60 <Sciclient_service+0xe0> @ imm = #-0x2
;                 txPayloadSize = pReqPrm->reqPayloadSize - sizeof(struct tisci_header);
7009bf60: 9813         	ldr	r0, [sp, #0x4c]
7009bf62: 68c0         	ldr	r0, [r0, #0xc]
7009bf64: 3808         	subs	r0, #0x8
7009bf66: 900d         	str	r0, [sp, #0x34]
;             }
7009bf68: e002         	b	0x7009bf70 <Sciclient_service+0xf0> @ imm = #0x4
7009bf6a: 2000         	movs	r0, #0x0
;                 txPayloadSize = 0U;
7009bf6c: 900d         	str	r0, [sp, #0x34]
7009bf6e: e7ff         	b	0x7009bf70 <Sciclient_service+0xf0> @ imm = #-0x2
;             if (txPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009bf70: 980d         	ldr	r0, [sp, #0x34]
7009bf72: f240 1138    	movw	r1, #0x138
7009bf76: f2c7 010b    	movt	r1, #0x700b
7009bf7a: 6949         	ldr	r1, [r1, #0x14]
7009bf7c: 3908         	subs	r1, #0x8
7009bf7e: 4288         	cmp	r0, r1
7009bf80: d904         	bls	0x7009bf8c <Sciclient_service+0x10c> @ imm = #0x8
7009bf82: e7ff         	b	0x7009bf84 <Sciclient_service+0x104> @ imm = #-0x2
7009bf84: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009bf88: 9011         	str	r0, [sp, #0x44]
;             }
7009bf8a: e7ff         	b	0x7009bf8c <Sciclient_service+0x10c> @ imm = #-0x2
;             if ((txPayloadSize > 0U) && (pReqPrm->pReqPayload == NULL))
7009bf8c: 980d         	ldr	r0, [sp, #0x34]
7009bf8e: b140         	cbz	r0, 0x7009bfa2 <Sciclient_service+0x122> @ imm = #0x10
7009bf90: e7ff         	b	0x7009bf92 <Sciclient_service+0x112> @ imm = #-0x2
7009bf92: 9813         	ldr	r0, [sp, #0x4c]
7009bf94: 6880         	ldr	r0, [r0, #0x8]
7009bf96: b920         	cbnz	r0, 0x7009bfa2 <Sciclient_service+0x122> @ imm = #0x8
7009bf98: e7ff         	b	0x7009bf9a <Sciclient_service+0x11a> @ imm = #-0x2
7009bf9a: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009bf9e: 9011         	str	r0, [sp, #0x44]
;             }
7009bfa0: e7ff         	b	0x7009bfa2 <Sciclient_service+0x122> @ imm = #-0x2
;             if (pRespPrm->respPayloadSize > 0U)
7009bfa2: 9812         	ldr	r0, [sp, #0x48]
7009bfa4: 6880         	ldr	r0, [r0, #0x8]
7009bfa6: b128         	cbz	r0, 0x7009bfb4 <Sciclient_service+0x134> @ imm = #0xa
7009bfa8: e7ff         	b	0x7009bfaa <Sciclient_service+0x12a> @ imm = #-0x2
;                 rxPayloadSize = pRespPrm->respPayloadSize - sizeof(struct tisci_header);
7009bfaa: 9812         	ldr	r0, [sp, #0x48]
7009bfac: 6880         	ldr	r0, [r0, #0x8]
7009bfae: 3808         	subs	r0, #0x8
7009bfb0: 900c         	str	r0, [sp, #0x30]
;             }
7009bfb2: e002         	b	0x7009bfba <Sciclient_service+0x13a> @ imm = #0x4
7009bfb4: 2000         	movs	r0, #0x0
;                 rxPayloadSize = 0U;
7009bfb6: 900c         	str	r0, [sp, #0x30]
7009bfb8: e7ff         	b	0x7009bfba <Sciclient_service+0x13a> @ imm = #-0x2
;             if (rxPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009bfba: 980c         	ldr	r0, [sp, #0x30]
7009bfbc: f240 1138    	movw	r1, #0x138
7009bfc0: f2c7 010b    	movt	r1, #0x700b
7009bfc4: 6949         	ldr	r1, [r1, #0x14]
7009bfc6: 3908         	subs	r1, #0x8
7009bfc8: 4288         	cmp	r0, r1
7009bfca: d904         	bls	0x7009bfd6 <Sciclient_service+0x156> @ imm = #0x8
7009bfcc: e7ff         	b	0x7009bfce <Sciclient_service+0x14e> @ imm = #-0x2
7009bfce: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009bfd2: 9011         	str	r0, [sp, #0x44]
;             }
7009bfd4: e7ff         	b	0x7009bfd6 <Sciclient_service+0x156> @ imm = #-0x2
;             if ((rxPayloadSize > 0U) && (pRespPrm->pRespPayload == NULL))
7009bfd6: 980c         	ldr	r0, [sp, #0x30]
7009bfd8: b140         	cbz	r0, 0x7009bfec <Sciclient_service+0x16c> @ imm = #0x10
7009bfda: e7ff         	b	0x7009bfdc <Sciclient_service+0x15c> @ imm = #-0x2
7009bfdc: 9812         	ldr	r0, [sp, #0x48]
7009bfde: 6840         	ldr	r0, [r0, #0x4]
7009bfe0: b920         	cbnz	r0, 0x7009bfec <Sciclient_service+0x16c> @ imm = #0x8
7009bfe2: e7ff         	b	0x7009bfe4 <Sciclient_service+0x164> @ imm = #-0x2
7009bfe4: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009bfe8: 9011         	str	r0, [sp, #0x44]
;             }
7009bfea: e004         	b	0x7009bff6 <Sciclient_service+0x176> @ imm = #0x8
;                 pLocalRespPayload = (uint8_t *)(pRespPrm->pRespPayload + sizeof(struct tisci_header));
7009bfec: 9812         	ldr	r0, [sp, #0x48]
7009bfee: 6840         	ldr	r0, [r0, #0x4]
7009bff0: 3008         	adds	r0, #0x8
7009bff2: 900b         	str	r0, [sp, #0x2c]
7009bff4: e7ff         	b	0x7009bff6 <Sciclient_service+0x176> @ imm = #-0x2
;         }
7009bff6: e003         	b	0x7009c000 <Sciclient_service+0x180> @ imm = #0x6
7009bff8: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009bffc: 9011         	str	r0, [sp, #0x44]
7009bffe: e7ff         	b	0x7009c000 <Sciclient_service+0x180> @ imm = #-0x2
7009c000: e7ff         	b	0x7009c002 <Sciclient_service+0x182> @ imm = #-0x2
;     key = HwiP_disable();
7009c002: f012 e9c6    	blx	0x700ae390 <HwiP_disable> @ imm = #0x1238c
7009c006: 9008         	str	r0, [sp, #0x20]
;     if (SystemP_SUCCESS == status)
7009c008: 9811         	ldr	r0, [sp, #0x44]
7009c00a: 2800         	cmp	r0, #0x0
7009c00c: d159         	bne	0x7009c0c2 <Sciclient_service+0x242> @ imm = #0xb2
7009c00e: e7ff         	b	0x7009c010 <Sciclient_service+0x190> @ imm = #-0x2
;         Sciclient_secProxyFlush(rxThread);
7009c010: 9809         	ldr	r0, [sp, #0x24]
7009c012: f00f fff5    	bl	0x700ac000 <Sciclient_secProxyFlush> @ imm = #0xffea
;         header = (struct tisci_header*)pReqPrm->pReqPayload;
7009c016: 9813         	ldr	r0, [sp, #0x4c]
7009c018: 6880         	ldr	r0, [r0, #0x8]
7009c01a: 9006         	str	r0, [sp, #0x18]
;         header->type = pReqPrm->messageType;
7009c01c: 9813         	ldr	r0, [sp, #0x4c]
7009c01e: 8800         	ldrh	r0, [r0]
7009c020: 9906         	ldr	r1, [sp, #0x18]
7009c022: 8008         	strh	r0, [r1]
;         header->host = (uint8_t) gSciclientMap[contextId].hostId;
7009c024: 9810         	ldr	r0, [sp, #0x40]
7009c026: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009c02a: f64e 5088    	movw	r0, #0xed88
7009c02e: f2c7 000a    	movt	r0, #0x700a
7009c032: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009c036: 6840         	ldr	r0, [r0, #0x4]
7009c038: 9906         	ldr	r1, [sp, #0x18]
7009c03a: 7088         	strb	r0, [r1, #0x2]
;         header->seq = localSeqId;
7009c03c: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
7009c040: 9906         	ldr	r1, [sp, #0x18]
7009c042: 70c8         	strb	r0, [r1, #0x3]
;         pFlags = (uint8_t*)&pReqPrm->flags;
7009c044: 9813         	ldr	r0, [sp, #0x4c]
7009c046: 3004         	adds	r0, #0x4
7009c048: 9004         	str	r0, [sp, #0x10]
7009c04a: 2000         	movs	r0, #0x0
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009c04c: 9003         	str	r0, [sp, #0xc]
7009c04e: e7ff         	b	0x7009c050 <Sciclient_service+0x1d0> @ imm = #-0x2
7009c050: 9803         	ldr	r0, [sp, #0xc]
7009c052: 2803         	cmp	r0, #0x3
7009c054: d811         	bhi	0x7009c07a <Sciclient_service+0x1fa> @ imm = #0x22
7009c056: e7ff         	b	0x7009c058 <Sciclient_service+0x1d8> @ imm = #-0x2
;             uint8_t *pDestFlags = ((uint8_t*)&header->flags) + numBytes;
7009c058: 9806         	ldr	r0, [sp, #0x18]
7009c05a: 9903         	ldr	r1, [sp, #0xc]
7009c05c: 4408         	add	r0, r1
7009c05e: 3004         	adds	r0, #0x4
7009c060: 9002         	str	r0, [sp, #0x8]
;             *pDestFlags = *pFlags;
7009c062: 9804         	ldr	r0, [sp, #0x10]
7009c064: 7800         	ldrb	r0, [r0]
7009c066: 9902         	ldr	r1, [sp, #0x8]
7009c068: 7008         	strb	r0, [r1]
;             pFlags++;
7009c06a: 9804         	ldr	r0, [sp, #0x10]
7009c06c: 3001         	adds	r0, #0x1
7009c06e: 9004         	str	r0, [sp, #0x10]
;         }
7009c070: e7ff         	b	0x7009c072 <Sciclient_service+0x1f2> @ imm = #-0x2
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009c072: 9803         	ldr	r0, [sp, #0xc]
7009c074: 3001         	adds	r0, #0x1
7009c076: 9003         	str	r0, [sp, #0xc]
7009c078: e7ea         	b	0x7009c050 <Sciclient_service+0x1d0> @ imm = #-0x2c
;         gSciclientHandle.currSeqId = (gSciclientHandle.currSeqId + 1U) %
7009c07a: f240 1138    	movw	r1, #0x138
7009c07e: f2c7 010b    	movt	r1, #0x700b
7009c082: 6808         	ldr	r0, [r1]
7009c084: 3001         	adds	r0, #0x1
7009c086: f644 1225    	movw	r2, #0x4925
7009c08a: f2c2 4292    	movt	r2, #0x2492
7009c08e: fba0 3202    	umull	r3, r2, r0, r2
7009c092: 1a83         	subs	r3, r0, r2
7009c094: eb02 0353    	add.w	r3, r2, r3, lsr #1
7009c098: 089a         	lsrs	r2, r3, #0x2
7009c09a: 00d2         	lsls	r2, r2, #0x3
7009c09c: eba2 0293    	sub.w	r2, r2, r3, lsr #2
7009c0a0: 1a80         	subs	r0, r0, r2
7009c0a2: 6008         	str	r0, [r1]
;         status = Sciclient_secProxyVerifyThread(txThread);
7009c0a4: 980a         	ldr	r0, [sp, #0x28]
7009c0a6: f010 fcfb    	bl	0x700acaa0 <Sciclient_secProxyVerifyThread> @ imm = #0x109f6
7009c0aa: 9011         	str	r0, [sp, #0x44]
;         if (SystemP_SUCCESS == status)
7009c0ac: 9811         	ldr	r0, [sp, #0x44]
7009c0ae: b938         	cbnz	r0, 0x7009c0c0 <Sciclient_service+0x240> @ imm = #0xe
7009c0b0: e7ff         	b	0x7009c0b2 <Sciclient_service+0x232> @ imm = #-0x2
;             status = Sciclient_secProxyWaitThread(txThread, pReqPrm->timeout);
7009c0b2: 980a         	ldr	r0, [sp, #0x28]
7009c0b4: 9913         	ldr	r1, [sp, #0x4c]
7009c0b6: 6909         	ldr	r1, [r1, #0x10]
7009c0b8: f00f fce2    	bl	0x700aba80 <Sciclient_secProxyWaitThread> @ imm = #0xf9c4
7009c0bc: 9011         	str	r0, [sp, #0x44]
;         }
7009c0be: e7ff         	b	0x7009c0c0 <Sciclient_service+0x240> @ imm = #-0x2
;     }
7009c0c0: e7ff         	b	0x7009c0c2 <Sciclient_service+0x242> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
7009c0c2: 9811         	ldr	r0, [sp, #0x44]
7009c0c4: b9b0         	cbnz	r0, 0x7009c0f4 <Sciclient_service+0x274> @ imm = #0x2c
7009c0c6: e7ff         	b	0x7009c0c8 <Sciclient_service+0x248> @ imm = #-0x2
;         initialCount = Sciclient_secProxyReadThreadCount(rxThread);
7009c0c8: 9809         	ldr	r0, [sp, #0x24]
7009c0ca: f011 f979    	bl	0x700ad3c0 <Sciclient_secProxyReadThreadCount> @ imm = #0x112f2
7009c0ce: 900f         	str	r0, [sp, #0x3c]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009c0d0: 980a         	ldr	r0, [sp, #0x28]
7009c0d2: 9907         	ldr	r1, [sp, #0x1c]
7009c0d4: 9a06         	ldr	r2, [sp, #0x18]
;                               (pReqPrm->pReqPayload + sizeof(struct tisci_header)),
7009c0d6: 9b13         	ldr	r3, [sp, #0x4c]
7009c0d8: 689b         	ldr	r3, [r3, #0x8]
7009c0da: 3308         	adds	r3, #0x8
;                               txPayloadSize);
7009c0dc: f8dd c034    	ldr.w	r12, [sp, #0x34]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009c0e0: 46ee         	mov	lr, sp
7009c0e2: f8ce c000    	str.w	r12, [lr]
7009c0e6: f004 fb3b    	bl	0x700a0760 <Sciclient_sendMessage> @ imm = #0x4676
;         status = Sciclient_secProxyVerifyThread(rxThread);
7009c0ea: 9809         	ldr	r0, [sp, #0x24]
7009c0ec: f010 fcd8    	bl	0x700acaa0 <Sciclient_secProxyVerifyThread> @ imm = #0x109b0
7009c0f0: 9011         	str	r0, [sp, #0x44]
;     }
7009c0f2: e7ff         	b	0x7009c0f4 <Sciclient_service+0x274> @ imm = #-0x2
;     if ((status == SystemP_SUCCESS) &&
7009c0f4: 9811         	ldr	r0, [sp, #0x44]
7009c0f6: b978         	cbnz	r0, 0x7009c118 <Sciclient_service+0x298> @ imm = #0x1e
7009c0f8: e7ff         	b	0x7009c0fa <Sciclient_service+0x27a> @ imm = #-0x2
;         ((pReqPrm->flags & TISCI_MSG_FLAG_MASK) != 0U))
7009c0fa: 9813         	ldr	r0, [sp, #0x4c]
;     if ((status == SystemP_SUCCESS) &&
7009c0fc: 7900         	ldrb	r0, [r0, #0x4]
7009c0fe: 0780         	lsls	r0, r0, #0x1e
7009c100: b150         	cbz	r0, 0x7009c118 <Sciclient_service+0x298> @ imm = #0x14
7009c102: e7ff         	b	0x7009c104 <Sciclient_service+0x284> @ imm = #-0x2
;         status = Sciclient_waitForMessage(rxThread, pReqPrm->timeout, initialCount, localSeqId);
7009c104: 9809         	ldr	r0, [sp, #0x24]
7009c106: 9913         	ldr	r1, [sp, #0x4c]
7009c108: 6909         	ldr	r1, [r1, #0x10]
7009c10a: 9a0f         	ldr	r2, [sp, #0x3c]
7009c10c: f89d 303b    	ldrb.w	r3, [sp, #0x3b]
7009c110: f007 ffe6    	bl	0x700a40e0 <Sciclient_waitForMessage> @ imm = #0x7fcc
7009c114: 9011         	str	r0, [sp, #0x44]
;     }
7009c116: e7ff         	b	0x7009c118 <Sciclient_service+0x298> @ imm = #-0x2
;     if(status == SystemP_SUCCESS)
7009c118: 9811         	ldr	r0, [sp, #0x44]
7009c11a: b990         	cbnz	r0, 0x7009c142 <Sciclient_service+0x2c2> @ imm = #0x24
7009c11c: e7ff         	b	0x7009c11e <Sciclient_service+0x29e> @ imm = #-0x2
;         pRespPrm->flags = Sciclient_secProxyReadThread32(rxThread, 1U+gSecHeaderSizeWords);
7009c11e: 9809         	ldr	r0, [sp, #0x24]
7009c120: f240 2120    	movw	r1, #0x220
7009c124: f2c7 010b    	movt	r1, #0x700b
7009c128: 7809         	ldrb	r1, [r1]
7009c12a: 3101         	adds	r1, #0x1
7009c12c: b2c9         	uxtb	r1, r1
7009c12e: f010 fa47    	bl	0x700ac5c0 <Sciclient_secProxyReadThread32> @ imm = #0x1048e
7009c132: 9912         	ldr	r1, [sp, #0x48]
7009c134: 6008         	str	r0, [r1]
;         Sciclient_recvMessage(rxThread, pLocalRespPayload, rxPayloadSize);
7009c136: 9809         	ldr	r0, [sp, #0x24]
7009c138: 990b         	ldr	r1, [sp, #0x2c]
7009c13a: 9a0c         	ldr	r2, [sp, #0x30]
7009c13c: f005 f8b8    	bl	0x700a12b0 <Sciclient_recvMessage> @ imm = #0x5170
;     }
7009c140: e7ff         	b	0x7009c142 <Sciclient_service+0x2c2> @ imm = #-0x2
;     HwiP_restore(key);
7009c142: 9808         	ldr	r0, [sp, #0x20]
7009c144: f012 e944    	blx	0x700ae3d0 <HwiP_restore> @ imm = #0x12288
;     return status;
7009c148: 9811         	ldr	r0, [sp, #0x44]
7009c14a: b014         	add	sp, #0x50
7009c14c: bd80         	pop	{r7, pc}
7009c14e: 0000         	movs	r0, r0

7009c150 <Udma_chDisableRxChan>:
; {
7009c150: b580         	push	{r7, lr}
7009c152: b096         	sub	sp, #0x58
7009c154: 9015         	str	r0, [sp, #0x54]
7009c156: 9114         	str	r1, [sp, #0x50]
7009c158: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009c15a: 9013         	str	r0, [sp, #0x4c]
;     uint32_t            currTimeout = 0U, regVal;
7009c15c: 9012         	str	r0, [sp, #0x48]
;     uint32_t            peerRtEnable = 0U, peerRtEnableBit = 0U;
7009c15e: 9004         	str	r0, [sp, #0x10]
7009c160: 9003         	str	r0, [sp, #0xc]
;     drvHandle = chHandle->drvHandle;
7009c162: 9815         	ldr	r0, [sp, #0x54]
7009c164: 6e80         	ldr	r0, [r0, #0x68]
7009c166: 9010         	str	r0, [sp, #0x40]
7009c168: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009c16a: 9002         	str	r0, [sp, #0x8]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c16c: 9810         	ldr	r0, [sp, #0x40]
7009c16e: 6800         	ldr	r0, [r0]
7009c170: 2801         	cmp	r0, #0x1
7009c172: d115         	bne	0x7009c1a0 <Udma_chDisableRxChan+0x50> @ imm = #0x2a
7009c174: e7ff         	b	0x7009c176 <Udma_chDisableRxChan+0x26> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
7009c176: 9815         	ldr	r0, [sp, #0x54]
7009c178: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009c17c: f500 7008    	add.w	r0, r0, #0x220
7009c180: f011 fac6    	bl	0x700ad710 <CSL_REG32_RD_RAW> @ imm = #0x1158c
7009c184: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009c186: 9811         	ldr	r0, [sp, #0x44]
7009c188: f040 4080    	orr	r0, r0, #0x40000000
7009c18c: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
7009c18e: 9815         	ldr	r0, [sp, #0x54]
7009c190: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009c194: f500 7008    	add.w	r0, r0, #0x220
7009c198: 9911         	ldr	r1, [sp, #0x44]
7009c19a: f011 fa19    	bl	0x700ad5d0 <CSL_REG32_WR_RAW> @ imm = #0x11432
;     }
7009c19e: e01a         	b	0x7009c1d6 <Udma_chDisableRxChan+0x86> @ imm = #0x34
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c1a0: 9810         	ldr	r0, [sp, #0x40]
7009c1a2: 6800         	ldr	r0, [r0]
7009c1a4: 2802         	cmp	r0, #0x2
7009c1a6: d115         	bne	0x7009c1d4 <Udma_chDisableRxChan+0x84> @ imm = #0x2a
7009c1a8: e7ff         	b	0x7009c1aa <Udma_chDisableRxChan+0x5a> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
7009c1aa: 9815         	ldr	r0, [sp, #0x54]
7009c1ac: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009c1b0: f500 7008    	add.w	r0, r0, #0x220
7009c1b4: f011 faac    	bl	0x700ad710 <CSL_REG32_RD_RAW> @ imm = #0x11558
7009c1b8: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009c1ba: 9811         	ldr	r0, [sp, #0x44]
7009c1bc: f040 4080    	orr	r0, r0, #0x40000000
7009c1c0: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
7009c1c2: 9815         	ldr	r0, [sp, #0x54]
7009c1c4: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009c1c8: f500 7008    	add.w	r0, r0, #0x220
7009c1cc: 9911         	ldr	r1, [sp, #0x44]
7009c1ce: f011 f9ff    	bl	0x700ad5d0 <CSL_REG32_WR_RAW> @ imm = #0x113fe
;     }
7009c1d2: e7ff         	b	0x7009c1d4 <Udma_chDisableRxChan+0x84> @ imm = #-0x2
7009c1d4: e7ff         	b	0x7009c1d6 <Udma_chDisableRxChan+0x86> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c1d6: e7ff         	b	0x7009c1d8 <Udma_chDisableRxChan+0x88> @ imm = #-0x2
7009c1d8: 9813         	ldr	r0, [sp, #0x4c]
7009c1da: bbc8         	cbnz	r0, 0x7009c250 <Udma_chDisableRxChan+0x100> @ imm = #0x72
7009c1dc: e7ff         	b	0x7009c1de <Udma_chDisableRxChan+0x8e> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c1de: 9810         	ldr	r0, [sp, #0x40]
7009c1e0: 6800         	ldr	r0, [r0]
7009c1e2: 2801         	cmp	r0, #0x1
7009c1e4: d110         	bne	0x7009c208 <Udma_chDisableRxChan+0xb8> @ imm = #0x20
7009c1e6: e7ff         	b	0x7009c1e8 <Udma_chDisableRxChan+0x98> @ imm = #-0x2
;             (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009c1e8: 9a10         	ldr	r2, [sp, #0x40]
7009c1ea: f102 0008    	add.w	r0, r2, #0x8
7009c1ee: 9915         	ldr	r1, [sp, #0x54]
7009c1f0: 6f09         	ldr	r1, [r1, #0x70]
7009c1f2: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c1f6: 4411         	add	r1, r2
7009c1f8: aa0a         	add	r2, sp, #0x28
7009c1fa: f010 fa59    	bl	0x700ac6b0 <CSL_bcdmaGetRxRT> @ imm = #0x104b2
;             if(FALSE == bcdmaRtStatus.enable)
7009c1fe: 980a         	ldr	r0, [sp, #0x28]
7009c200: b908         	cbnz	r0, 0x7009c206 <Udma_chDisableRxChan+0xb6> @ imm = #0x2
7009c202: e7ff         	b	0x7009c204 <Udma_chDisableRxChan+0xb4> @ imm = #-0x2
;                 break;
7009c204: e024         	b	0x7009c250 <Udma_chDisableRxChan+0x100> @ imm = #0x48
;         }
7009c206: e011         	b	0x7009c22c <Udma_chDisableRxChan+0xdc> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c208: 9810         	ldr	r0, [sp, #0x40]
7009c20a: 6800         	ldr	r0, [r0]
7009c20c: 2802         	cmp	r0, #0x2
7009c20e: d10c         	bne	0x7009c22a <Udma_chDisableRxChan+0xda> @ imm = #0x18
7009c210: e7ff         	b	0x7009c212 <Udma_chDisableRxChan+0xc2> @ imm = #-0x2
;             (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009c212: 9810         	ldr	r0, [sp, #0x40]
7009c214: 3054         	adds	r0, #0x54
7009c216: 9915         	ldr	r1, [sp, #0x54]
7009c218: 6f09         	ldr	r1, [r1, #0x70]
7009c21a: aa05         	add	r2, sp, #0x14
7009c21c: f00e ffb8    	bl	0x700ab190 <CSL_pktdmaGetRxRT> @ imm = #0xef70
;             if(FALSE == pktdmaRtStatus.enable)
7009c220: 9805         	ldr	r0, [sp, #0x14]
7009c222: b908         	cbnz	r0, 0x7009c228 <Udma_chDisableRxChan+0xd8> @ imm = #0x2
7009c224: e7ff         	b	0x7009c226 <Udma_chDisableRxChan+0xd6> @ imm = #-0x2
;                 break;
7009c226: e013         	b	0x7009c250 <Udma_chDisableRxChan+0x100> @ imm = #0x26
;         }
7009c228: e7ff         	b	0x7009c22a <Udma_chDisableRxChan+0xda> @ imm = #-0x2
7009c22a: e7ff         	b	0x7009c22c <Udma_chDisableRxChan+0xdc> @ imm = #-0x2
;         if(currTimeout > timeout)
7009c22c: 9812         	ldr	r0, [sp, #0x48]
7009c22e: 9914         	ldr	r1, [sp, #0x50]
7009c230: 4288         	cmp	r0, r1
7009c232: d904         	bls	0x7009c23e <Udma_chDisableRxChan+0xee> @ imm = #0x8
7009c234: e7ff         	b	0x7009c236 <Udma_chDisableRxChan+0xe6> @ imm = #-0x2
7009c236: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009c23a: 9013         	str	r0, [sp, #0x4c]
;         }
7009c23c: e007         	b	0x7009c24e <Udma_chDisableRxChan+0xfe> @ imm = #0xe
7009c23e: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009c242: f00c fead    	bl	0x700a8fa0 <ClockP_usleep> @ imm = #0xcd5a
;             currTimeout++;
7009c246: 9812         	ldr	r0, [sp, #0x48]
7009c248: 3001         	adds	r0, #0x1
7009c24a: 9012         	str	r0, [sp, #0x48]
7009c24c: e7ff         	b	0x7009c24e <Udma_chDisableRxChan+0xfe> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c24e: e7c3         	b	0x7009c1d8 <Udma_chDisableRxChan+0x88> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009c250: 9813         	ldr	r0, [sp, #0x4c]
7009c252: 2800         	cmp	r0, #0x0
7009c254: f000 8091    	beq.w	0x7009c37a <Udma_chDisableRxChan+0x22a> @ imm = #0x122
7009c258: e7ff         	b	0x7009c25a <Udma_chDisableRxChan+0x10a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c25a: 9810         	ldr	r0, [sp, #0x40]
7009c25c: 6800         	ldr	r0, [r0]
7009c25e: 2801         	cmp	r0, #0x1
7009c260: d10e         	bne	0x7009c280 <Udma_chDisableRxChan+0x130> @ imm = #0x1c
7009c262: e7ff         	b	0x7009c264 <Udma_chDisableRxChan+0x114> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, (bool)true, (bool)false);
7009c264: 9a10         	ldr	r2, [sp, #0x40]
7009c266: f102 0008    	add.w	r0, r2, #0x8
7009c26a: 9915         	ldr	r1, [sp, #0x54]
7009c26c: 6f09         	ldr	r1, [r1, #0x70]
7009c26e: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c272: 4411         	add	r1, r2
7009c274: 2201         	movs	r2, #0x1
7009c276: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownRxChan(
7009c278: f00f f91a    	bl	0x700ab4b0 <CSL_bcdmaTeardownRxChan> @ imm = #0xf234
7009c27c: 9013         	str	r0, [sp, #0x4c]
;         }
7009c27e: e00f         	b	0x7009c2a0 <Udma_chDisableRxChan+0x150> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c280: 9810         	ldr	r0, [sp, #0x40]
7009c282: 6800         	ldr	r0, [r0]
7009c284: 2802         	cmp	r0, #0x2
7009c286: d10a         	bne	0x7009c29e <Udma_chDisableRxChan+0x14e> @ imm = #0x14
7009c288: e7ff         	b	0x7009c28a <Udma_chDisableRxChan+0x13a> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->rxChNum, (bool)true, (bool)false);
7009c28a: 9810         	ldr	r0, [sp, #0x40]
7009c28c: 3054         	adds	r0, #0x54
7009c28e: 9915         	ldr	r1, [sp, #0x54]
7009c290: 6f09         	ldr	r1, [r1, #0x70]
7009c292: 2201         	movs	r2, #0x1
7009c294: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownRxChan(
7009c296: f00f ff53    	bl	0x700ac140 <CSL_pktdmaTeardownRxChan> @ imm = #0xfea6
7009c29a: 9013         	str	r0, [sp, #0x4c]
;         }
7009c29c: e7ff         	b	0x7009c29e <Udma_chDisableRxChan+0x14e> @ imm = #-0x2
7009c29e: e7ff         	b	0x7009c2a0 <Udma_chDisableRxChan+0x150> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009c2a0: 9813         	ldr	r0, [sp, #0x4c]
7009c2a2: b108         	cbz	r0, 0x7009c2a8 <Udma_chDisableRxChan+0x158> @ imm = #0x2
7009c2a4: e7ff         	b	0x7009c2a6 <Udma_chDisableRxChan+0x156> @ imm = #-0x2
;         }
7009c2a6: e7ff         	b	0x7009c2a8 <Udma_chDisableRxChan+0x158> @ imm = #-0x2
7009c2a8: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009c2aa: 9012         	str	r0, [sp, #0x48]
;         while(UDMA_SOK == retVal)
7009c2ac: e7ff         	b	0x7009c2ae <Udma_chDisableRxChan+0x15e> @ imm = #-0x2
7009c2ae: 9813         	ldr	r0, [sp, #0x4c]
7009c2b0: 2800         	cmp	r0, #0x0
7009c2b2: d161         	bne	0x7009c378 <Udma_chDisableRxChan+0x228> @ imm = #0xc2
7009c2b4: e7ff         	b	0x7009c2b6 <Udma_chDisableRxChan+0x166> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c2b6: 9810         	ldr	r0, [sp, #0x40]
7009c2b8: 6800         	ldr	r0, [r0]
7009c2ba: 2801         	cmp	r0, #0x1
7009c2bc: d126         	bne	0x7009c30c <Udma_chDisableRxChan+0x1bc> @ imm = #0x4c
7009c2be: e7ff         	b	0x7009c2c0 <Udma_chDisableRxChan+0x170> @ imm = #-0x2
;                 (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009c2c0: 9a10         	ldr	r2, [sp, #0x40]
7009c2c2: f102 0008    	add.w	r0, r2, #0x8
7009c2c6: 9915         	ldr	r1, [sp, #0x54]
7009c2c8: 6f09         	ldr	r1, [r1, #0x70]
7009c2ca: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c2ce: 4411         	add	r1, r2
7009c2d0: aa0a         	add	r2, sp, #0x28
7009c2d2: f010 f9ed    	bl	0x700ac6b0 <CSL_bcdmaGetRxRT> @ imm = #0x103da
;                     &drvHandle->bcdmaRegs,
7009c2d6: 9a10         	ldr	r2, [sp, #0x40]
7009c2d8: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->rxChNum + drvHandle->rxChOffset,
7009c2dc: 9915         	ldr	r1, [sp, #0x54]
7009c2de: 6f09         	ldr	r1, [r1, #0x70]
7009c2e0: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c2e4: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009c2e6: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009c2e8: 46ec         	mov	r12, sp
7009c2ea: aa04         	add	r2, sp, #0x10
7009c2ec: f8cc 2000    	str.w	r2, [r12]
7009c2f0: 2201         	movs	r2, #0x1
7009c2f2: f00f f9a5    	bl	0x700ab640 <CSL_bcdmaGetChanPeerReg> @ imm = #0xf34a
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009c2f6: 9804         	ldr	r0, [sp, #0x10]
7009c2f8: 0fc0         	lsrs	r0, r0, #0x1f
7009c2fa: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == bcdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009c2fc: 980a         	ldr	r0, [sp, #0x28]
7009c2fe: b920         	cbnz	r0, 0x7009c30a <Udma_chDisableRxChan+0x1ba> @ imm = #0x8
7009c300: e7ff         	b	0x7009c302 <Udma_chDisableRxChan+0x1b2> @ imm = #-0x2
7009c302: 9803         	ldr	r0, [sp, #0xc]
7009c304: b908         	cbnz	r0, 0x7009c30a <Udma_chDisableRxChan+0x1ba> @ imm = #0x2
7009c306: e7ff         	b	0x7009c308 <Udma_chDisableRxChan+0x1b8> @ imm = #-0x2
;                     break;
7009c308: e036         	b	0x7009c378 <Udma_chDisableRxChan+0x228> @ imm = #0x6c
;             }
7009c30a: e023         	b	0x7009c354 <Udma_chDisableRxChan+0x204> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c30c: 9810         	ldr	r0, [sp, #0x40]
7009c30e: 6800         	ldr	r0, [r0]
7009c310: 2802         	cmp	r0, #0x2
7009c312: d11e         	bne	0x7009c352 <Udma_chDisableRxChan+0x202> @ imm = #0x3c
7009c314: e7ff         	b	0x7009c316 <Udma_chDisableRxChan+0x1c6> @ imm = #-0x2
;                 (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009c316: 9810         	ldr	r0, [sp, #0x40]
7009c318: 3054         	adds	r0, #0x54
7009c31a: 9915         	ldr	r1, [sp, #0x54]
7009c31c: 6f09         	ldr	r1, [r1, #0x70]
7009c31e: aa05         	add	r2, sp, #0x14
7009c320: f00e ff36    	bl	0x700ab190 <CSL_pktdmaGetRxRT> @ imm = #0xee6c
;                     &drvHandle->pktdmaRegs,
7009c324: 9810         	ldr	r0, [sp, #0x40]
7009c326: 3054         	adds	r0, #0x54
;                     chHandle->rxChNum,
7009c328: 9915         	ldr	r1, [sp, #0x54]
7009c32a: 6f09         	ldr	r1, [r1, #0x70]
;                     rtEnableRegOffset, &peerRtEnable);
7009c32c: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009c32e: 46ec         	mov	r12, sp
7009c330: aa04         	add	r2, sp, #0x10
7009c332: f8cc 2000    	str.w	r2, [r12]
7009c336: 2201         	movs	r2, #0x1
7009c338: f010 f89a    	bl	0x700ac470 <CSL_pktdmaGetChanPeerReg> @ imm = #0x10134
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009c33c: 9804         	ldr	r0, [sp, #0x10]
7009c33e: 0fc0         	lsrs	r0, r0, #0x1f
7009c340: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == pktdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009c342: 9805         	ldr	r0, [sp, #0x14]
7009c344: b920         	cbnz	r0, 0x7009c350 <Udma_chDisableRxChan+0x200> @ imm = #0x8
7009c346: e7ff         	b	0x7009c348 <Udma_chDisableRxChan+0x1f8> @ imm = #-0x2
7009c348: 9803         	ldr	r0, [sp, #0xc]
7009c34a: b908         	cbnz	r0, 0x7009c350 <Udma_chDisableRxChan+0x200> @ imm = #0x2
7009c34c: e7ff         	b	0x7009c34e <Udma_chDisableRxChan+0x1fe> @ imm = #-0x2
;                     break;
7009c34e: e013         	b	0x7009c378 <Udma_chDisableRxChan+0x228> @ imm = #0x26
;             }
7009c350: e7ff         	b	0x7009c352 <Udma_chDisableRxChan+0x202> @ imm = #-0x2
7009c352: e7ff         	b	0x7009c354 <Udma_chDisableRxChan+0x204> @ imm = #-0x2
;             if(currTimeout > timeout)
7009c354: 9812         	ldr	r0, [sp, #0x48]
7009c356: 9914         	ldr	r1, [sp, #0x50]
7009c358: 4288         	cmp	r0, r1
7009c35a: d904         	bls	0x7009c366 <Udma_chDisableRxChan+0x216> @ imm = #0x8
7009c35c: e7ff         	b	0x7009c35e <Udma_chDisableRxChan+0x20e> @ imm = #-0x2
7009c35e: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009c362: 9013         	str	r0, [sp, #0x4c]
;             }
7009c364: e007         	b	0x7009c376 <Udma_chDisableRxChan+0x226> @ imm = #0xe
7009c366: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009c36a: f00c fe19    	bl	0x700a8fa0 <ClockP_usleep> @ imm = #0xcc32
;                 currTimeout++;
7009c36e: 9812         	ldr	r0, [sp, #0x48]
7009c370: 3001         	adds	r0, #0x1
7009c372: 9012         	str	r0, [sp, #0x48]
7009c374: e7ff         	b	0x7009c376 <Udma_chDisableRxChan+0x226> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009c376: e79a         	b	0x7009c2ae <Udma_chDisableRxChan+0x15e> @ imm = #-0xcc
;     }
7009c378: e7ff         	b	0x7009c37a <Udma_chDisableRxChan+0x22a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c37a: 9813         	ldr	r0, [sp, #0x4c]
7009c37c: 2800         	cmp	r0, #0x0
7009c37e: d148         	bne	0x7009c412 <Udma_chDisableRxChan+0x2c2> @ imm = #0x90
7009c380: e7ff         	b	0x7009c382 <Udma_chDisableRxChan+0x232> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c382: 9810         	ldr	r0, [sp, #0x40]
7009c384: 6800         	ldr	r0, [r0]
7009c386: 2801         	cmp	r0, #0x1
7009c388: d122         	bne	0x7009c3d0 <Udma_chDisableRxChan+0x280> @ imm = #0x44
7009c38a: e7ff         	b	0x7009c38c <Udma_chDisableRxChan+0x23c> @ imm = #-0x2
7009c38c: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009c38e: 900b         	str	r0, [sp, #0x2c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009c390: 9804         	ldr	r0, [sp, #0x10]
7009c392: f020 4080    	bic	r0, r0, #0x40000000
7009c396: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009c398: 9a10         	ldr	r2, [sp, #0x40]
7009c39a: f102 0008    	add.w	r0, r2, #0x8
7009c39e: 9915         	ldr	r1, [sp, #0x54]
7009c3a0: 6f09         	ldr	r1, [r1, #0x70]
7009c3a2: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c3a6: 4411         	add	r1, r2
7009c3a8: aa0a         	add	r2, sp, #0x28
;             (void) CSL_bcdmaSetRxRT(
7009c3aa: f010 f9b1    	bl	0x700ac710 <CSL_bcdmaSetRxRT> @ imm = #0x10362
;                 &drvHandle->bcdmaRegs,
7009c3ae: 9a10         	ldr	r2, [sp, #0x40]
7009c3b0: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->rxChNum + drvHandle->rxChOffset,
7009c3b4: 9915         	ldr	r1, [sp, #0x54]
7009c3b6: 6f09         	ldr	r1, [r1, #0x70]
7009c3b8: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c3bc: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009c3be: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_bcdmaSetChanPeerReg(
7009c3c0: 46ec         	mov	r12, sp
7009c3c2: aa04         	add	r2, sp, #0x10
7009c3c4: f8cc 2000    	str.w	r2, [r12]
7009c3c8: 2201         	movs	r2, #0x1
7009c3ca: f00f fc19    	bl	0x700abc00 <CSL_bcdmaSetChanPeerReg> @ imm = #0xf832
;         }
7009c3ce: e01f         	b	0x7009c410 <Udma_chDisableRxChan+0x2c0> @ imm = #0x3e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c3d0: 9810         	ldr	r0, [sp, #0x40]
7009c3d2: 6800         	ldr	r0, [r0]
7009c3d4: 2802         	cmp	r0, #0x2
7009c3d6: d11a         	bne	0x7009c40e <Udma_chDisableRxChan+0x2be> @ imm = #0x34
7009c3d8: e7ff         	b	0x7009c3da <Udma_chDisableRxChan+0x28a> @ imm = #-0x2
7009c3da: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009c3dc: 9006         	str	r0, [sp, #0x18]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009c3de: 9804         	ldr	r0, [sp, #0x10]
7009c3e0: f020 4080    	bic	r0, r0, #0x40000000
7009c3e4: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009c3e6: 9810         	ldr	r0, [sp, #0x40]
7009c3e8: 3054         	adds	r0, #0x54
7009c3ea: 9915         	ldr	r1, [sp, #0x54]
7009c3ec: 6f09         	ldr	r1, [r1, #0x70]
7009c3ee: aa05         	add	r2, sp, #0x14
;             (void) CSL_pktdmaSetRxRT(
7009c3f0: f00f fc46    	bl	0x700abc80 <CSL_pktdmaSetRxRT> @ imm = #0xf88c
;                 &drvHandle->pktdmaRegs,
7009c3f4: 9810         	ldr	r0, [sp, #0x40]
7009c3f6: 3054         	adds	r0, #0x54
;                 chHandle->rxChNum,
7009c3f8: 9915         	ldr	r1, [sp, #0x54]
7009c3fa: 6f09         	ldr	r1, [r1, #0x70]
;                 rtEnableRegOffset,
7009c3fc: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_pktdmaSetChanPeerReg(
7009c3fe: 46ec         	mov	r12, sp
7009c400: aa04         	add	r2, sp, #0x10
7009c402: f8cc 2000    	str.w	r2, [r12]
7009c406: 2201         	movs	r2, #0x1
7009c408: f010 f84a    	bl	0x700ac4a0 <CSL_pktdmaSetChanPeerReg> @ imm = #0x10094
;         }
7009c40c: e7ff         	b	0x7009c40e <Udma_chDisableRxChan+0x2be> @ imm = #-0x2
7009c40e: e7ff         	b	0x7009c410 <Udma_chDisableRxChan+0x2c0> @ imm = #-0x2
;     }
7009c410: e7ff         	b	0x7009c412 <Udma_chDisableRxChan+0x2c2> @ imm = #-0x2
;     return (retVal);
7009c412: 9813         	ldr	r0, [sp, #0x4c]
7009c414: b016         	add	sp, #0x58
7009c416: bd80         	pop	{r7, pc}
		...

7009c420 <CSL_bcdmaChanOpCfgChan>:
; {
7009c420: b580         	push	{r7, lr}
7009c422: b08a         	sub	sp, #0x28
7009c424: 9009         	str	r0, [sp, #0x24]
7009c426: 9108         	str	r1, [sp, #0x20]
7009c428: 9207         	str	r2, [sp, #0x1c]
7009c42a: 9306         	str	r3, [sp, #0x18]
7009c42c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
7009c42e: 9005         	str	r0, [sp, #0x14]
;     if( pOpData == NULL )
7009c430: 9806         	ldr	r0, [sp, #0x18]
7009c432: b920         	cbnz	r0, 0x7009c43e <CSL_bcdmaChanOpCfgChan+0x1e> @ imm = #0x8
7009c434: e7ff         	b	0x7009c436 <CSL_bcdmaChanOpCfgChan+0x16> @ imm = #-0x2
7009c436: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
7009c43a: 9005         	str	r0, [sp, #0x14]
;     }
7009c43c: e137         	b	0x7009c6ae <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #0x26e
;         switch( chanType )
7009c43e: 9808         	ldr	r0, [sp, #0x20]
7009c440: 9000         	str	r0, [sp]
7009c442: b148         	cbz	r0, 0x7009c458 <CSL_bcdmaChanOpCfgChan+0x38> @ imm = #0x12
7009c444: e7ff         	b	0x7009c446 <CSL_bcdmaChanOpCfgChan+0x26> @ imm = #-0x2
7009c446: 9800         	ldr	r0, [sp]
7009c448: 2801         	cmp	r0, #0x1
7009c44a: d057         	beq	0x7009c4fc <CSL_bcdmaChanOpCfgChan+0xdc> @ imm = #0xae
7009c44c: e7ff         	b	0x7009c44e <CSL_bcdmaChanOpCfgChan+0x2e> @ imm = #-0x2
7009c44e: 9800         	ldr	r0, [sp]
7009c450: 2802         	cmp	r0, #0x2
7009c452: f000 80c1    	beq.w	0x7009c5d8 <CSL_bcdmaChanOpCfgChan+0x1b8> @ imm = #0x182
7009c456: e125         	b	0x7009c6a4 <CSL_bcdmaChanOpCfgChan+0x284> @ imm = #0x24a
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009c458: 9806         	ldr	r0, [sp, #0x18]
7009c45a: 9003         	str	r0, [sp, #0xc]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009c45c: 9803         	ldr	r0, [sp, #0xc]
7009c45e: 6c40         	ldr	r0, [r0, #0x44]
7009c460: 2802         	cmp	r0, #0x2
7009c462: d80a         	bhi	0x7009c47a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0x14
7009c464: e7ff         	b	0x7009c466 <CSL_bcdmaChanOpCfgChan+0x46> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009c466: 9803         	ldr	r0, [sp, #0xc]
7009c468: 6a00         	ldr	r0, [r0, #0x20]
7009c46a: 2807         	cmp	r0, #0x7
7009c46c: d805         	bhi	0x7009c47a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0xa
7009c46e: e7ff         	b	0x7009c470 <CSL_bcdmaChanOpCfgChan+0x50> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009c470: 9803         	ldr	r0, [sp, #0xc]
7009c472: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009c474: 2804         	cmp	r0, #0x4
7009c476: d304         	blo	0x7009c482 <CSL_bcdmaChanOpCfgChan+0x62> @ imm = #0x8
7009c478: e7ff         	b	0x7009c47a <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #-0x2
7009c47a: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009c47e: 9005         	str	r0, [sp, #0x14]
;                     }
7009c480: e03b         	b	0x7009c4fa <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #0x76
;                         regVal = CSL_REG32_RD( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG );
7009c482: 9809         	ldr	r0, [sp, #0x24]
7009c484: 6840         	ldr	r0, [r0, #0x4]
7009c486: 9907         	ldr	r1, [sp, #0x1c]
7009c488: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c48c: f011 f918    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0x11230
7009c490: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_PAUSE_ON_ERR, pChanCfg->pauseOnError );
7009c492: 9804         	ldr	r0, [sp, #0x10]
7009c494: f020 4000    	bic	r0, r0, #0x80000000
7009c498: 9903         	ldr	r1, [sp, #0xc]
7009c49a: 6809         	ldr	r1, [r1]
7009c49c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009c4a0: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, pChanCfg->burstSize );
7009c4a2: 9804         	ldr	r0, [sp, #0x10]
7009c4a4: 9903         	ldr	r1, [sp, #0xc]
7009c4a6: 6c49         	ldr	r1, [r1, #0x44]
7009c4a8: f361 208b    	bfi	r0, r1, #10, #2
7009c4ac: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, regVal );
7009c4ae: 9809         	ldr	r0, [sp, #0x24]
7009c4b0: 6840         	ldr	r0, [r0, #0x4]
7009c4b2: 9907         	ldr	r1, [sp, #0x1c]
7009c4b4: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c4b8: 9904         	ldr	r1, [sp, #0x10]
7009c4ba: f011 f861    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x110c2
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c4be: 9803         	ldr	r0, [sp, #0xc]
7009c4c0: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009c4c2: 6a80         	ldr	r0, [r0, #0x28]
7009c4c4: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c4c8: f361 701e    	bfi	r0, r1, #28, #3
7009c4cc: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].PRI_CTRL, regVal );
7009c4ce: 9809         	ldr	r0, [sp, #0x24]
7009c4d0: 6840         	ldr	r0, [r0, #0x4]
7009c4d2: 9907         	ldr	r1, [sp, #0x1c]
7009c4d4: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c4d8: 3064         	adds	r0, #0x64
7009c4da: 9904         	ldr	r1, [sp, #0x10]
7009c4dc: f011 f850    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x110a0
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_BCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009c4e0: 9809         	ldr	r0, [sp, #0x24]
7009c4e2: 6840         	ldr	r0, [r0, #0x4]
7009c4e4: 9907         	ldr	r1, [sp, #0x1c]
7009c4e6: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c4ea: 3080         	adds	r0, #0x80
7009c4ec: 9903         	ldr	r1, [sp, #0xc]
7009c4ee: 6ac9         	ldr	r1, [r1, #0x2c]
7009c4f0: f001 0103    	and	r1, r1, #0x3
7009c4f4: f011 f844    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x11088
7009c4f8: e7ff         	b	0x7009c4fa <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #-0x2
;                 break;
7009c4fa: e0d7         	b	0x7009c6ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x1ae
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009c4fc: 9806         	ldr	r0, [sp, #0x18]
7009c4fe: 9002         	str	r0, [sp, #0x8]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009c500: 9802         	ldr	r0, [sp, #0x8]
7009c502: 6c40         	ldr	r0, [r0, #0x44]
7009c504: 2801         	cmp	r0, #0x1
7009c506: d80a         	bhi	0x7009c51e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0x14
7009c508: e7ff         	b	0x7009c50a <CSL_bcdmaChanOpCfgChan+0xea> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009c50a: 9802         	ldr	r0, [sp, #0x8]
7009c50c: 6a00         	ldr	r0, [r0, #0x20]
7009c50e: 2807         	cmp	r0, #0x7
7009c510: d805         	bhi	0x7009c51e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0xa
7009c512: e7ff         	b	0x7009c514 <CSL_bcdmaChanOpCfgChan+0xf4> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009c514: 9802         	ldr	r0, [sp, #0x8]
7009c516: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009c518: 2804         	cmp	r0, #0x4
7009c51a: d304         	blo	0x7009c526 <CSL_bcdmaChanOpCfgChan+0x106> @ imm = #0x8
7009c51c: e7ff         	b	0x7009c51e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #-0x2
7009c51e: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009c522: 9005         	str	r0, [sp, #0x14]
;                     }
7009c524: e057         	b	0x7009c5d6 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #0xae
;                         regVal = CSL_REG32_RD( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG );
7009c526: 9809         	ldr	r0, [sp, #0x24]
7009c528: 68c0         	ldr	r0, [r0, #0xc]
7009c52a: 9907         	ldr	r1, [sp, #0x1c]
7009c52c: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c530: f011 f8c6    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0x1118c
7009c534: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009c536: 9804         	ldr	r0, [sp, #0x10]
7009c538: f020 4000    	bic	r0, r0, #0x80000000
7009c53c: 9902         	ldr	r1, [sp, #0x8]
7009c53e: 6809         	ldr	r1, [r1]
7009c540: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009c544: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, pChanCfg->burstSize );
7009c546: 9804         	ldr	r0, [sp, #0x10]
7009c548: 9902         	ldr	r1, [sp, #0x8]
7009c54a: 6c49         	ldr	r1, [r1, #0x44]
7009c54c: f361 208b    	bfi	r0, r1, #10, #2
7009c550: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_TDTYPE, pChanCfg->tdType );
7009c552: 9804         	ldr	r0, [sp, #0x10]
7009c554: 9902         	ldr	r1, [sp, #0x8]
7009c556: 6c09         	ldr	r1, [r1, #0x40]
7009c558: f361 2049    	bfi	r0, r1, #9, #1
7009c55c: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_NOTDPKT, pChanCfg->bNoTeardownCompletePkt );
7009c55e: 9804         	ldr	r0, [sp, #0x10]
7009c560: f420 7080    	bic	r0, r0, #0x100
7009c564: 9902         	ldr	r1, [sp, #0x8]
7009c566: f891 103c    	ldrb.w	r1, [r1, #0x3c]
7009c56a: f001 0101    	and	r1, r1, #0x1
7009c56e: ea40 2001    	orr.w	r0, r0, r1, lsl #8
7009c572: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, regVal );
7009c574: 9809         	ldr	r0, [sp, #0x24]
7009c576: 68c0         	ldr	r0, [r0, #0xc]
7009c578: 9907         	ldr	r1, [sp, #0x1c]
7009c57a: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c57e: 9904         	ldr	r1, [sp, #0x10]
7009c580: f010 fffe    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x10ffc
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c584: 9802         	ldr	r0, [sp, #0x8]
7009c586: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009c588: 6a80         	ldr	r0, [r0, #0x28]
7009c58a: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c58e: f361 701e    	bfi	r0, r1, #28, #3
7009c592: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TPRI_CTRL, regVal );
7009c594: 9809         	ldr	r0, [sp, #0x24]
7009c596: 68c0         	ldr	r0, [r0, #0xc]
7009c598: 9907         	ldr	r1, [sp, #0x1c]
7009c59a: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c59e: 3064         	adds	r0, #0x64
7009c5a0: 9904         	ldr	r1, [sp, #0x10]
7009c5a2: f010 ffed    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x10fda
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_TXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009c5a6: 9809         	ldr	r0, [sp, #0x24]
7009c5a8: 68c0         	ldr	r0, [r0, #0xc]
7009c5aa: 9907         	ldr	r1, [sp, #0x1c]
7009c5ac: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c5b0: 3068         	adds	r0, #0x68
7009c5b2: 9902         	ldr	r1, [sp, #0x8]
7009c5b4: f8b1 1048    	ldrh.w	r1, [r1, #0x48]
7009c5b8: f010 ffe2    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x10fc4
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_TXCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009c5bc: 9809         	ldr	r0, [sp, #0x24]
7009c5be: 68c0         	ldr	r0, [r0, #0xc]
7009c5c0: 9907         	ldr	r1, [sp, #0x1c]
7009c5c2: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c5c6: 3080         	adds	r0, #0x80
7009c5c8: 9902         	ldr	r1, [sp, #0x8]
7009c5ca: 6ac9         	ldr	r1, [r1, #0x2c]
7009c5cc: f001 0103    	and	r1, r1, #0x3
7009c5d0: f010 ffd6    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x10fac
7009c5d4: e7ff         	b	0x7009c5d6 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #-0x2
;                 break;
7009c5d6: e069         	b	0x7009c6ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0xd2
;                     CSL_BcdmaRxChanCfg *pChanCfg = (CSL_BcdmaRxChanCfg *)pOpData;
7009c5d8: 9806         	ldr	r0, [sp, #0x18]
7009c5da: 9001         	str	r0, [sp, #0x4]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009c5dc: 9801         	ldr	r0, [sp, #0x4]
7009c5de: 6bc0         	ldr	r0, [r0, #0x3c]
7009c5e0: 2801         	cmp	r0, #0x1
7009c5e2: d80a         	bhi	0x7009c5fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0x14
7009c5e4: e7ff         	b	0x7009c5e6 <CSL_bcdmaChanOpCfgChan+0x1c6> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009c5e6: 9801         	ldr	r0, [sp, #0x4]
7009c5e8: 6980         	ldr	r0, [r0, #0x18]
7009c5ea: 2807         	cmp	r0, #0x7
7009c5ec: d805         	bhi	0x7009c5fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0xa
7009c5ee: e7ff         	b	0x7009c5f0 <CSL_bcdmaChanOpCfgChan+0x1d0> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009c5f0: 9801         	ldr	r0, [sp, #0x4]
7009c5f2: 6b80         	ldr	r0, [r0, #0x38]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009c5f4: 2804         	cmp	r0, #0x4
7009c5f6: d304         	blo	0x7009c602 <CSL_bcdmaChanOpCfgChan+0x1e2> @ imm = #0x8
7009c5f8: e7ff         	b	0x7009c5fa <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #-0x2
7009c5fa: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009c5fe: 9005         	str	r0, [sp, #0x14]
;                     }
7009c600: e04f         	b	0x7009c6a2 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #0x9e
;                         regVal = CSL_REG32_RD( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG );
7009c602: 9809         	ldr	r0, [sp, #0x24]
7009c604: 6940         	ldr	r0, [r0, #0x14]
7009c606: 9907         	ldr	r1, [sp, #0x1c]
7009c608: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c60c: f011 f858    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0x110b0
7009c610: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009c612: 9804         	ldr	r0, [sp, #0x10]
7009c614: f020 4000    	bic	r0, r0, #0x80000000
7009c618: 9901         	ldr	r1, [sp, #0x4]
7009c61a: 6809         	ldr	r1, [r1]
7009c61c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009c620: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, pChanCfg->burstSize );
7009c622: 9804         	ldr	r0, [sp, #0x10]
7009c624: 9901         	ldr	r1, [sp, #0x4]
7009c626: 6bc9         	ldr	r1, [r1, #0x3c]
7009c628: f361 208b    	bfi	r0, r1, #10, #2
7009c62c: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_IGNORE_LONG, pChanCfg->bIgnoreLongPkts ? (uint32_t)1U : (uint32_t)0U );
7009c62e: 9804         	ldr	r0, [sp, #0x10]
7009c630: f420 4080    	bic	r0, r0, #0x4000
7009c634: 9901         	ldr	r1, [sp, #0x4]
7009c636: f891 1035    	ldrb.w	r1, [r1, #0x35]
7009c63a: f361 308e    	bfi	r0, r1, #14, #1
7009c63e: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, regVal );
7009c640: 9809         	ldr	r0, [sp, #0x24]
7009c642: 6940         	ldr	r0, [r0, #0x14]
7009c644: 9907         	ldr	r1, [sp, #0x1c]
7009c646: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c64a: 9904         	ldr	r1, [sp, #0x10]
7009c64c: f010 ff98    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x10f30
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c650: 9801         	ldr	r0, [sp, #0x4]
7009c652: 6981         	ldr	r1, [r0, #0x18]
;                                  CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009c654: 6a00         	ldr	r0, [r0, #0x20]
7009c656: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009c65a: f361 701e    	bfi	r0, r1, #28, #3
7009c65e: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RPRI_CTRL, regVal );
7009c660: 9809         	ldr	r0, [sp, #0x24]
7009c662: 6940         	ldr	r0, [r0, #0x14]
7009c664: 9907         	ldr	r1, [sp, #0x1c]
7009c666: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c66a: 3064         	adds	r0, #0x64
7009c66c: 9904         	ldr	r1, [sp, #0x10]
7009c66e: f010 ff87    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x10f0e
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_RXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009c672: 9809         	ldr	r0, [sp, #0x24]
7009c674: 6940         	ldr	r0, [r0, #0x14]
7009c676: 9907         	ldr	r1, [sp, #0x1c]
7009c678: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c67c: 3068         	adds	r0, #0x68
7009c67e: 9901         	ldr	r1, [sp, #0x4]
7009c680: f8b1 1040    	ldrh.w	r1, [r1, #0x40]
7009c684: f010 ff7c    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x10ef8
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RST_SCHED, CSL_FMK(BCDMA_RXCCFG_CHAN_RST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009c688: 9809         	ldr	r0, [sp, #0x24]
7009c68a: 6940         	ldr	r0, [r0, #0x14]
7009c68c: 9907         	ldr	r1, [sp, #0x1c]
7009c68e: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009c692: 3080         	adds	r0, #0x80
7009c694: 9901         	ldr	r1, [sp, #0x4]
7009c696: 6b89         	ldr	r1, [r1, #0x38]
7009c698: f001 0103    	and	r1, r1, #0x3
7009c69c: f010 ff70    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x10ee0
7009c6a0: e7ff         	b	0x7009c6a2 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #-0x2
;                 break;
7009c6a2: e003         	b	0x7009c6ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x6
7009c6a4: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
7009c6a8: 9005         	str	r0, [sp, #0x14]
;                 break;
7009c6aa: e7ff         	b	0x7009c6ac <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #-0x2
7009c6ac: e7ff         	b	0x7009c6ae <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #-0x2
;     return retVal;
7009c6ae: 9805         	ldr	r0, [sp, #0x14]
7009c6b0: b00a         	add	sp, #0x28
7009c6b2: bd80         	pop	{r7, pc}
		...

7009c6c0 <TimerP_setup>:
; {
7009c6c0: b510         	push	{r4, lr}
7009c6c2: b096         	sub	sp, #0x58
7009c6c4: 9015         	str	r0, [sp, #0x54]
7009c6c6: 9114         	str	r1, [sp, #0x50]
;     DebugP_assert( baseAddr!=0U);
7009c6c8: 9815         	ldr	r0, [sp, #0x54]
7009c6ca: 2800         	cmp	r0, #0x0
7009c6cc: bf18         	it	ne
7009c6ce: 2001         	movne	r0, #0x1
7009c6d0: f64f 1150    	movw	r1, #0xf950
7009c6d4: f2c7 010a    	movt	r1, #0x700a
7009c6d8: 466a         	mov	r2, sp
7009c6da: 6011         	str	r1, [r2]
7009c6dc: f24f 616d    	movw	r1, #0xf66d
7009c6e0: f2c7 010a    	movt	r1, #0x700a
7009c6e4: 9106         	str	r1, [sp, #0x18]
7009c6e6: f64f 125d    	movw	r2, #0xf95d
7009c6ea: f2c7 020a    	movt	r2, #0x700a
7009c6ee: 9207         	str	r2, [sp, #0x1c]
7009c6f0: 2342         	movs	r3, #0x42
7009c6f2: f00c fa55    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xc4aa
7009c6f6: 9906         	ldr	r1, [sp, #0x18]
7009c6f8: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputPreScaler != 0U);
7009c6fa: 9814         	ldr	r0, [sp, #0x50]
7009c6fc: 6800         	ldr	r0, [r0]
7009c6fe: 2800         	cmp	r0, #0x0
7009c700: bf18         	it	ne
7009c702: 2001         	movne	r0, #0x1
7009c704: f24f 638b    	movw	r3, #0xf68b
7009c708: f2c7 030a    	movt	r3, #0x700a
7009c70c: 46ec         	mov	r12, sp
7009c70e: f8cc 3000    	str.w	r3, [r12]
7009c712: 2343         	movs	r3, #0x43
7009c714: f00c fa44    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xc488
7009c718: 9906         	ldr	r1, [sp, #0x18]
7009c71a: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputClkHz != 0U);
7009c71c: 9814         	ldr	r0, [sp, #0x50]
7009c71e: 6840         	ldr	r0, [r0, #0x4]
7009c720: 2800         	cmp	r0, #0x0
7009c722: bf18         	it	ne
7009c724: 2001         	movne	r0, #0x1
7009c726: f24f 73a0    	movw	r3, #0xf7a0
7009c72a: f2c7 030a    	movt	r3, #0x700a
7009c72e: 46ec         	mov	r12, sp
7009c730: f8cc 3000    	str.w	r3, [r12]
7009c734: 2344         	movs	r3, #0x44
7009c736: f00c fa33    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xc466
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009c73a: 9814         	ldr	r0, [sp, #0x50]
7009c73c: 6881         	ldr	r1, [r0, #0x8]
7009c73e: 2001         	movs	r0, #0x1
7009c740: 9008         	str	r0, [sp, #0x20]
7009c742: b939         	cbnz	r1, 0x7009c754 <TimerP_setup+0x94> @ imm = #0xe
7009c744: e7ff         	b	0x7009c746 <TimerP_setup+0x86> @ imm = #-0x2
7009c746: 9814         	ldr	r0, [sp, #0x50]
7009c748: 68c0         	ldr	r0, [r0, #0xc]
7009c74a: 2800         	cmp	r0, #0x0
7009c74c: bf18         	it	ne
7009c74e: 2001         	movne	r0, #0x1
7009c750: 9008         	str	r0, [sp, #0x20]
7009c752: e7ff         	b	0x7009c754 <TimerP_setup+0x94> @ imm = #-0x2
7009c754: 9808         	ldr	r0, [sp, #0x20]
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009c756: f000 0001    	and	r0, r0, #0x1
7009c75a: f24f 3125    	movw	r1, #0xf325
7009c75e: f2c7 010a    	movt	r1, #0x700a
7009c762: 466a         	mov	r2, sp
7009c764: 6011         	str	r1, [r2]
7009c766: f24f 616d    	movw	r1, #0xf66d
7009c76a: f2c7 010a    	movt	r1, #0x700a
7009c76e: 9103         	str	r1, [sp, #0xc]
7009c770: f64f 125d    	movw	r2, #0xf95d
7009c774: f2c7 020a    	movt	r2, #0x700a
7009c778: 9204         	str	r2, [sp, #0x10]
7009c77a: 2345         	movs	r3, #0x45
7009c77c: f00c fa10    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xc420
7009c780: 9903         	ldr	r1, [sp, #0xc]
7009c782: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( params->inputPreScaler <= 256U);
7009c784: 9814         	ldr	r0, [sp, #0x50]
7009c786: 6803         	ldr	r3, [r0]
7009c788: 2000         	movs	r0, #0x0
7009c78a: 9005         	str	r0, [sp, #0x14]
7009c78c: f5b3 7f80    	cmp.w	r3, #0x100
7009c790: bf98         	it	ls
7009c792: 2001         	movls	r0, #0x1
7009c794: f24f 632f    	movw	r3, #0xf62f
7009c798: f2c7 030a    	movt	r3, #0x700a
7009c79c: 46ec         	mov	r12, sp
7009c79e: f8cc 3000    	str.w	r3, [r12]
7009c7a2: 2347         	movs	r3, #0x47
7009c7a4: f00c f9fc    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xc3f8
7009c7a8: 9903         	ldr	r1, [sp, #0xc]
7009c7aa: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( (params->inputClkHz % params->inputPreScaler) == 0U);
7009c7ac: 9814         	ldr	r0, [sp, #0x50]
7009c7ae: 6803         	ldr	r3, [r0]
7009c7b0: f8d0 c004    	ldr.w	r12, [r0, #0x4]
7009c7b4: fbbc f0f3    	udiv	r0, r12, r3
7009c7b8: fb00 c013    	mls	r0, r0, r3, r12
7009c7bc: fab0 f080    	clz	r0, r0
7009c7c0: 0940         	lsrs	r0, r0, #0x5
7009c7c2: f24f 33cf    	movw	r3, #0xf3cf
7009c7c6: f2c7 030a    	movt	r3, #0x700a
7009c7ca: 46ec         	mov	r12, sp
7009c7cc: f8cc 3000    	str.w	r3, [r12]
7009c7d0: 2349         	movs	r3, #0x49
7009c7d2: f00c f9e5    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xc3ca
;     TimerP_stop(baseAddr);
7009c7d6: 9815         	ldr	r0, [sp, #0x54]
7009c7d8: f010 fd32    	bl	0x700ad240 <TimerP_stop> @ imm = #0x10a64
;     TimerP_clearOverflowInt(baseAddr);
7009c7dc: 9815         	ldr	r0, [sp, #0x54]
7009c7de: f010 f80f    	bl	0x700ac800 <TimerP_clearOverflowInt> @ imm = #0x1001e
7009c7e2: 9905         	ldr	r1, [sp, #0x14]
;     timeInNsec = (uint64_t)params->periodInNsec;
7009c7e4: 9814         	ldr	r0, [sp, #0x50]
7009c7e6: 68c0         	ldr	r0, [r0, #0xc]
7009c7e8: 910f         	str	r1, [sp, #0x3c]
7009c7ea: 900e         	str	r0, [sp, #0x38]
;     if(timeInNsec == 0U)
7009c7ec: 980e         	ldr	r0, [sp, #0x38]
7009c7ee: 990f         	ldr	r1, [sp, #0x3c]
7009c7f0: 4308         	orrs	r0, r1
7009c7f2: b948         	cbnz	r0, 0x7009c808 <TimerP_setup+0x148> @ imm = #0x12
7009c7f4: e7ff         	b	0x7009c7f6 <TimerP_setup+0x136> @ imm = #-0x2
;         timeInNsec = (uint64_t)params->periodInUsec*1000U;
7009c7f6: 9814         	ldr	r0, [sp, #0x50]
7009c7f8: 6880         	ldr	r0, [r0, #0x8]
7009c7fa: f44f 717a    	mov.w	r1, #0x3e8
7009c7fe: fba0 0101    	umull	r0, r1, r0, r1
7009c802: 910f         	str	r1, [sp, #0x3c]
7009c804: 900e         	str	r0, [sp, #0x38]
;     }
7009c806: e7ff         	b	0x7009c808 <TimerP_setup+0x148> @ imm = #-0x2
;     inputClkHz = (uint64_t)params->inputClkHz / (uint64_t)params->inputPreScaler;
7009c808: 9814         	ldr	r0, [sp, #0x50]
7009c80a: 6802         	ldr	r2, [r0]
7009c80c: 6840         	ldr	r0, [r0, #0x4]
7009c80e: 2300         	movs	r3, #0x0
7009c810: 9302         	str	r3, [sp, #0x8]
7009c812: 4619         	mov	r1, r3
7009c814: f010 ead6    	blx	0x700acdc4 <__aeabi_uldivmod> @ imm = #0x105ac
7009c818: 9b02         	ldr	r3, [sp, #0x8]
7009c81a: 910d         	str	r1, [sp, #0x34]
7009c81c: 900c         	str	r0, [sp, #0x30]
;     timerCycles =  ( inputClkHz * timeInNsec ) / 1000000000U;
7009c81e: f8dd c030    	ldr.w	r12, [sp, #0x30]
7009c822: 990d         	ldr	r1, [sp, #0x34]
7009c824: 9a0e         	ldr	r2, [sp, #0x38]
7009c826: f8dd e03c    	ldr.w	lr, [sp, #0x3c]
7009c82a: fbac 0402    	umull	r0, r4, r12, r2
7009c82e: fb0c 4c0e    	mla	r12, r12, lr, r4
7009c832: fb01 c102    	mla	r1, r1, r2, r12
7009c836: f64c 2200    	movw	r2, #0xca00
7009c83a: f6c3 329a    	movt	r2, #0x3b9a
7009c83e: f010 eac2    	blx	0x700acdc4 <__aeabi_uldivmod> @ imm = #0x10584
7009c842: 4602         	mov	r2, r0
7009c844: 9802         	ldr	r0, [sp, #0x8]
7009c846: 9201         	str	r2, [sp, #0x4]
7009c848: 460a         	mov	r2, r1
7009c84a: 9901         	ldr	r1, [sp, #0x4]
7009c84c: 920b         	str	r2, [sp, #0x2c]
7009c84e: 910a         	str	r1, [sp, #0x28]
;     DebugP_assert( timerCycles < 0xFFFFFFFFU );
7009c850: 9a0a         	ldr	r2, [sp, #0x28]
7009c852: 990b         	ldr	r1, [sp, #0x2c]
7009c854: f1b2 32ff    	subs.w	r2, r2, #0xffffffff
7009c858: f171 0100    	sbcs	r1, r1, #0x0
7009c85c: bf38         	it	lo
7009c85e: 2001         	movlo	r0, #0x1
7009c860: f24f 7186    	movw	r1, #0xf786
7009c864: f2c7 010a    	movt	r1, #0x700a
7009c868: 466a         	mov	r2, sp
7009c86a: 6011         	str	r1, [r2]
7009c86c: f24f 616d    	movw	r1, #0xf66d
7009c870: f2c7 010a    	movt	r1, #0x700a
7009c874: f64f 125d    	movw	r2, #0xf95d
7009c878: f2c7 020a    	movt	r2, #0x700a
7009c87c: 2359         	movs	r3, #0x59
7009c87e: f00c f98f    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xc31e
7009c882: 9802         	ldr	r0, [sp, #0x8]
;     countVal = 0xFFFFFFFFu - (timerCycles - 1U);
7009c884: 990a         	ldr	r1, [sp, #0x28]
7009c886: 4249         	rsbs	r1, r1, #0
7009c888: 9111         	str	r1, [sp, #0x44]
;     reloadVal = 0;
7009c88a: 9010         	str	r0, [sp, #0x40]
;     ctrlVal = 0;
7009c88c: 9012         	str	r0, [sp, #0x48]
;     if(params->inputPreScaler>1U)
7009c88e: 9814         	ldr	r0, [sp, #0x50]
7009c890: 6800         	ldr	r0, [r0]
7009c892: 2802         	cmp	r0, #0x2
7009c894: d320         	blo	0x7009c8d8 <TimerP_setup+0x218> @ imm = #0x40
7009c896: e7ff         	b	0x7009c898 <TimerP_setup+0x1d8> @ imm = #-0x2
7009c898: 2008         	movs	r0, #0x8
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009c89a: 9009         	str	r0, [sp, #0x24]
7009c89c: e7ff         	b	0x7009c89e <TimerP_setup+0x1de> @ imm = #-0x2
7009c89e: 9809         	ldr	r0, [sp, #0x24]
7009c8a0: b168         	cbz	r0, 0x7009c8be <TimerP_setup+0x1fe> @ imm = #0x1a
7009c8a2: e7ff         	b	0x7009c8a4 <TimerP_setup+0x1e4> @ imm = #-0x2
;             if( (params->inputPreScaler & (0x1U << preScaleVal)) != 0U )
7009c8a4: 9814         	ldr	r0, [sp, #0x50]
7009c8a6: 6800         	ldr	r0, [r0]
7009c8a8: 9909         	ldr	r1, [sp, #0x24]
7009c8aa: 40c8         	lsrs	r0, r1
7009c8ac: 07c0         	lsls	r0, r0, #0x1f
7009c8ae: b108         	cbz	r0, 0x7009c8b4 <TimerP_setup+0x1f4> @ imm = #0x2
7009c8b0: e7ff         	b	0x7009c8b2 <TimerP_setup+0x1f2> @ imm = #-0x2
;                 break;
7009c8b2: e004         	b	0x7009c8be <TimerP_setup+0x1fe> @ imm = #0x8
;         }
7009c8b4: e7ff         	b	0x7009c8b6 <TimerP_setup+0x1f6> @ imm = #-0x2
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009c8b6: 9809         	ldr	r0, [sp, #0x24]
7009c8b8: 3801         	subs	r0, #0x1
7009c8ba: 9009         	str	r0, [sp, #0x24]
7009c8bc: e7ef         	b	0x7009c89e <TimerP_setup+0x1de> @ imm = #-0x22
;         ctrlVal |= (0x1U << 5);
7009c8be: 9812         	ldr	r0, [sp, #0x48]
7009c8c0: f040 0020    	orr	r0, r0, #0x20
7009c8c4: 9012         	str	r0, [sp, #0x48]
;         ctrlVal |= ( ((preScaleVal - 1U) & 0x7U) << 2);
7009c8c6: 9809         	ldr	r0, [sp, #0x24]
7009c8c8: 3801         	subs	r0, #0x1
7009c8ca: f000 0107    	and	r1, r0, #0x7
7009c8ce: 9812         	ldr	r0, [sp, #0x48]
7009c8d0: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009c8d4: 9012         	str	r0, [sp, #0x48]
;     }
7009c8d6: e7ff         	b	0x7009c8d8 <TimerP_setup+0x218> @ imm = #-0x2
;     if(params->oneshotMode==0U)
7009c8d8: 9814         	ldr	r0, [sp, #0x50]
7009c8da: 6900         	ldr	r0, [r0, #0x10]
7009c8dc: b938         	cbnz	r0, 0x7009c8ee <TimerP_setup+0x22e> @ imm = #0xe
7009c8de: e7ff         	b	0x7009c8e0 <TimerP_setup+0x220> @ imm = #-0x2
;         ctrlVal |= (0x1U << 1);
7009c8e0: 9812         	ldr	r0, [sp, #0x48]
7009c8e2: f040 0002    	orr	r0, r0, #0x2
7009c8e6: 9012         	str	r0, [sp, #0x48]
;         reloadVal = countVal;
7009c8e8: 9811         	ldr	r0, [sp, #0x44]
7009c8ea: 9010         	str	r0, [sp, #0x40]
;     }
7009c8ec: e7ff         	b	0x7009c8ee <TimerP_setup+0x22e> @ imm = #-0x2
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
7009c8ee: 9815         	ldr	r0, [sp, #0x54]
7009c8f0: 3038         	adds	r0, #0x38
7009c8f2: 9013         	str	r0, [sp, #0x4c]
;     *addr = ctrlVal;
7009c8f4: 9812         	ldr	r0, [sp, #0x48]
7009c8f6: 9913         	ldr	r1, [sp, #0x4c]
7009c8f8: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
7009c8fa: 9815         	ldr	r0, [sp, #0x54]
7009c8fc: 303c         	adds	r0, #0x3c
7009c8fe: 9013         	str	r0, [sp, #0x4c]
;     *addr = countVal;
7009c900: 9811         	ldr	r0, [sp, #0x44]
7009c902: 9913         	ldr	r1, [sp, #0x4c]
7009c904: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
7009c906: 9815         	ldr	r0, [sp, #0x54]
7009c908: 3040         	adds	r0, #0x40
7009c90a: 9013         	str	r0, [sp, #0x4c]
;     *addr = reloadVal;
7009c90c: 9810         	ldr	r0, [sp, #0x40]
7009c90e: 9913         	ldr	r1, [sp, #0x4c]
7009c910: 6008         	str	r0, [r1]
;     if((params->enableOverflowInt) != 0U)
7009c912: 9814         	ldr	r0, [sp, #0x50]
7009c914: 6940         	ldr	r0, [r0, #0x14]
7009c916: b138         	cbz	r0, 0x7009c928 <TimerP_setup+0x268> @ imm = #0xe
7009c918: e7ff         	b	0x7009c91a <TimerP_setup+0x25a> @ imm = #-0x2
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_ENABLE);
7009c91a: 9815         	ldr	r0, [sp, #0x54]
7009c91c: 302c         	adds	r0, #0x2c
7009c91e: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009c920: 9913         	ldr	r1, [sp, #0x4c]
7009c922: 2002         	movs	r0, #0x2
7009c924: 6008         	str	r0, [r1]
;     }
7009c926: e006         	b	0x7009c936 <TimerP_setup+0x276> @ imm = #0xc
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_DISABLE);
7009c928: 9815         	ldr	r0, [sp, #0x54]
7009c92a: 3030         	adds	r0, #0x30
7009c92c: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009c92e: 9913         	ldr	r1, [sp, #0x4c]
7009c930: 2002         	movs	r0, #0x2
7009c932: 6008         	str	r0, [r1]
7009c934: e7ff         	b	0x7009c936 <TimerP_setup+0x276> @ imm = #-0x2
; }
7009c936: b016         	add	sp, #0x58
7009c938: bd10         	pop	{r4, pc}
7009c93a: 0000         	movs	r0, r0
7009c93c: 0000         	movs	r0, r0
7009c93e: 0000         	movs	r0, r0

7009c940 <Udma_chConfigRx>:
; {
7009c940: b580         	push	{r7, lr}
7009c942: b09c         	sub	sp, #0x70
7009c944: 901b         	str	r0, [sp, #0x6c]
7009c946: 911a         	str	r1, [sp, #0x68]
7009c948: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009c94a: 9019         	str	r0, [sp, #0x64]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
7009c94c: 981b         	ldr	r0, [sp, #0x6c]
7009c94e: 9017         	str	r0, [sp, #0x5c]
;     if((NULL_PTR == chHandleInt) ||
7009c950: 9817         	ldr	r0, [sp, #0x5c]
7009c952: b188         	cbz	r0, 0x7009c978 <Udma_chConfigRx+0x38> @ imm = #0x22
7009c954: e7ff         	b	0x7009c956 <Udma_chConfigRx+0x16> @ imm = #-0x2
;         (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009c956: 9817         	ldr	r0, [sp, #0x5c]
7009c958: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009c95c: f64a 31cd    	movw	r1, #0xabcd
7009c960: f6ca 31dc    	movt	r1, #0xabdc
7009c964: 4288         	cmp	r0, r1
7009c966: d107         	bne	0x7009c978 <Udma_chConfigRx+0x38> @ imm = #0xe
7009c968: e7ff         	b	0x7009c96a <Udma_chConfigRx+0x2a> @ imm = #-0x2
;         ((chHandleInt->chType & UDMA_CH_FLAG_RX) != UDMA_CH_FLAG_RX))
7009c96a: 9817         	ldr	r0, [sp, #0x5c]
7009c96c: 6800         	ldr	r0, [r0]
7009c96e: f000 0002    	and	r0, r0, #0x2
;     if((NULL_PTR == chHandleInt) ||
7009c972: 2802         	cmp	r0, #0x2
7009c974: d004         	beq	0x7009c980 <Udma_chConfigRx+0x40> @ imm = #0x8
7009c976: e7ff         	b	0x7009c978 <Udma_chConfigRx+0x38> @ imm = #-0x2
7009c978: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009c97c: 9019         	str	r0, [sp, #0x64]
;     }
7009c97e: e7ff         	b	0x7009c980 <Udma_chConfigRx+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c980: 9819         	ldr	r0, [sp, #0x64]
7009c982: b9a8         	cbnz	r0, 0x7009c9b0 <Udma_chConfigRx+0x70> @ imm = #0x2a
7009c984: e7ff         	b	0x7009c986 <Udma_chConfigRx+0x46> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009c986: 9817         	ldr	r0, [sp, #0x5c]
7009c988: 6e80         	ldr	r0, [r0, #0x68]
7009c98a: 9018         	str	r0, [sp, #0x60]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009c98c: 9818         	ldr	r0, [sp, #0x60]
7009c98e: b150         	cbz	r0, 0x7009c9a6 <Udma_chConfigRx+0x66> @ imm = #0x14
7009c990: e7ff         	b	0x7009c992 <Udma_chConfigRx+0x52> @ imm = #-0x2
7009c992: 9818         	ldr	r0, [sp, #0x60]
7009c994: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009c998: f64a 31cd    	movw	r1, #0xabcd
7009c99c: f6ca 31dc    	movt	r1, #0xabdc
7009c9a0: 4288         	cmp	r0, r1
7009c9a2: d004         	beq	0x7009c9ae <Udma_chConfigRx+0x6e> @ imm = #0x8
7009c9a4: e7ff         	b	0x7009c9a6 <Udma_chConfigRx+0x66> @ imm = #-0x2
7009c9a6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009c9aa: 9019         	str	r0, [sp, #0x64]
;         }
7009c9ac: e7ff         	b	0x7009c9ae <Udma_chConfigRx+0x6e> @ imm = #-0x2
;     }
7009c9ae: e7ff         	b	0x7009c9b0 <Udma_chConfigRx+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c9b0: 9819         	ldr	r0, [sp, #0x64]
7009c9b2: 2800         	cmp	r0, #0x0
7009c9b4: f040 80f1    	bne.w	0x7009cb9a <Udma_chConfigRx+0x25a> @ imm = #0x1e2
7009c9b8: e7ff         	b	0x7009c9ba <Udma_chConfigRx+0x7a> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009c9ba: 9818         	ldr	r0, [sp, #0x60]
7009c9bc: 6800         	ldr	r0, [r0]
7009c9be: 2801         	cmp	r0, #0x1
7009c9c0: d107         	bne	0x7009c9d2 <Udma_chConfigRx+0x92> @ imm = #0xe
7009c9c2: e7ff         	b	0x7009c9c4 <Udma_chConfigRx+0x84> @ imm = #-0x2
;             ((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
7009c9c4: 9817         	ldr	r0, [sp, #0x5c]
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009c9c6: 7800         	ldrb	r0, [r0]
7009c9c8: 0740         	lsls	r0, r0, #0x1d
7009c9ca: 2800         	cmp	r0, #0x0
7009c9cc: d501         	bpl	0x7009c9d2 <Udma_chConfigRx+0x92> @ imm = #0x2
7009c9ce: e7ff         	b	0x7009c9d0 <Udma_chConfigRx+0x90> @ imm = #-0x2
;         }
7009c9d0: e0e2         	b	0x7009cb98 <Udma_chConfigRx+0x258> @ imm = #0x1c4
7009c9d2: f645 70ff    	movw	r0, #0x5fff
;             rmUdmaRxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
7009c9d6: 9010         	str	r0, [sp, #0x40]
;             rmUdmaRxReq.nav_id              = drvHandle->devIdUdma;
7009c9d8: 9818         	ldr	r0, [sp, #0x60]
7009c9da: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009c9de: f8ad 0044    	strh.w	r0, [sp, #0x44]
;             rmUdmaRxReq.index               = (uint16_t)chHandleInt->rxChNum;
7009c9e2: 9817         	ldr	r0, [sp, #0x5c]
7009c9e4: 6f00         	ldr	r0, [r0, #0x70]
7009c9e6: f8ad 0046    	strh.w	r0, [sp, #0x46]
;             rmUdmaRxReq.rx_pause_on_err     = rxPrms->pauseOnError;
7009c9ea: 981a         	ldr	r0, [sp, #0x68]
7009c9ec: 7800         	ldrb	r0, [r0]
7009c9ee: f88d 0054    	strb.w	r0, [sp, #0x54]
;             rmUdmaRxReq.rx_atype            = rxPrms->addrType;
7009c9f2: 981a         	ldr	r0, [sp, #0x68]
7009c9f4: 7840         	ldrb	r0, [r0, #0x1]
7009c9f6: f88d 0055    	strb.w	r0, [sp, #0x55]
;             rmUdmaRxReq.rx_chan_type        = rxPrms->chanType;
7009c9fa: 981a         	ldr	r0, [sp, #0x68]
7009c9fc: 7880         	ldrb	r0, [r0, #0x2]
7009c9fe: f88d 0056    	strb.w	r0, [sp, #0x56]
;             rmUdmaRxReq.rx_fetch_size       = rxPrms->fetchWordSize;
7009ca02: 981a         	ldr	r0, [sp, #0x68]
7009ca04: 8880         	ldrh	r0, [r0, #0x4]
7009ca06: f8ad 0048    	strh.w	r0, [sp, #0x48]
;             rmUdmaRxReq.rx_priority         = rxPrms->busPriority;
7009ca0a: 981a         	ldr	r0, [sp, #0x68]
7009ca0c: 7980         	ldrb	r0, [r0, #0x6]
7009ca0e: f88d 004c    	strb.w	r0, [sp, #0x4c]
;             rmUdmaRxReq.rx_qos              = rxPrms->busQos;
7009ca12: 981a         	ldr	r0, [sp, #0x68]
7009ca14: 79c0         	ldrb	r0, [r0, #0x7]
7009ca16: f88d 004d    	strb.w	r0, [sp, #0x4d]
;             rmUdmaRxReq.rx_orderid          = rxPrms->busOrderId;
7009ca1a: 981a         	ldr	r0, [sp, #0x68]
7009ca1c: 7a00         	ldrb	r0, [r0, #0x8]
7009ca1e: f88d 004e    	strb.w	r0, [sp, #0x4e]
;             rmUdmaRxReq.rx_sched_priority   = rxPrms->dmaPriority;
7009ca22: 981a         	ldr	r0, [sp, #0x68]
7009ca24: 7a40         	ldrb	r0, [r0, #0x9]
7009ca26: f88d 004f    	strb.w	r0, [sp, #0x4f]
;             rmUdmaRxReq.flowid_start        = rxPrms->flowIdFwRangeStart;
7009ca2a: 981a         	ldr	r0, [sp, #0x68]
7009ca2c: 8940         	ldrh	r0, [r0, #0xa]
7009ca2e: f8ad 0050    	strh.w	r0, [sp, #0x50]
;             rmUdmaRxReq.flowid_cnt          = rxPrms->flowIdFwRangeCnt;
7009ca32: 981a         	ldr	r0, [sp, #0x68]
7009ca34: 8980         	ldrh	r0, [r0, #0xc]
7009ca36: f8ad 0052    	strh.w	r0, [sp, #0x52]
;             rmUdmaRxReq.rx_ignore_short     = rxPrms->ignoreShortPkts;
7009ca3a: 981a         	ldr	r0, [sp, #0x68]
7009ca3c: 7c80         	ldrb	r0, [r0, #0x12]
7009ca3e: f88d 0057    	strb.w	r0, [sp, #0x57]
;             rmUdmaRxReq.rx_ignore_long      = rxPrms->ignoreLongPkts;
7009ca42: 981a         	ldr	r0, [sp, #0x68]
7009ca44: 7cc0         	ldrb	r0, [r0, #0x13]
7009ca46: f88d 0058    	strb.w	r0, [sp, #0x58]
;             rmUdmaRxReq.rx_burst_size       = rxPrms->burstSize;
7009ca4a: 981a         	ldr	r0, [sp, #0x68]
7009ca4c: 7e00         	ldrb	r0, [r0, #0x18]
7009ca4e: f88d 0059    	strb.w	r0, [sp, #0x59]
;             if(NULL_PTR != chHandleInt->tdCqRing)
7009ca52: 9817         	ldr	r0, [sp, #0x5c]
7009ca54: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ca58: b138         	cbz	r0, 0x7009ca6a <Udma_chConfigRx+0x12a> @ imm = #0xe
7009ca5a: e7ff         	b	0x7009ca5c <Udma_chConfigRx+0x11c> @ imm = #-0x2
;                 rmUdmaRxReq.rxcq_qnum          = chHandleInt->tdCqRing->ringNum;
7009ca5c: 9817         	ldr	r0, [sp, #0x5c]
7009ca5e: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009ca62: 8880         	ldrh	r0, [r0, #0x4]
7009ca64: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;             }
7009ca68: e004         	b	0x7009ca74 <Udma_chConfigRx+0x134> @ imm = #0x8
7009ca6a: f64f 70ff    	movw	r0, #0xffff
;                 rmUdmaRxReq.rxcq_qnum          = UDMA_RING_INVALID;
7009ca6e: f8ad 004a    	strh.w	r0, [sp, #0x4a]
7009ca72: e7ff         	b	0x7009ca74 <Udma_chConfigRx+0x134> @ imm = #-0x2
7009ca74: a80e         	add	r0, sp, #0x38
7009ca76: a90c         	add	r1, sp, #0x30
7009ca78: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmUdmapRxChCfg(
7009ca7c: f00d ff20    	bl	0x700aa8c0 <Sciclient_rmUdmapRxChCfg> @ imm = #0xde40
7009ca80: 9019         	str	r0, [sp, #0x64]
;             if(CSL_PASS != retVal)
7009ca82: 9819         	ldr	r0, [sp, #0x64]
7009ca84: b108         	cbz	r0, 0x7009ca8a <Udma_chConfigRx+0x14a> @ imm = #0x2
7009ca86: e7ff         	b	0x7009ca88 <Udma_chConfigRx+0x148> @ imm = #-0x2
;             }
7009ca88: e7ff         	b	0x7009ca8a <Udma_chConfigRx+0x14a> @ imm = #-0x2
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009ca8a: 9817         	ldr	r0, [sp, #0x5c]
7009ca8c: 6800         	ldr	r0, [r0]
7009ca8e: f000 0008    	and	r0, r0, #0x8
7009ca92: 2808         	cmp	r0, #0x8
7009ca94: d006         	beq	0x7009caa4 <Udma_chConfigRx+0x164> @ imm = #0xc
7009ca96: e7ff         	b	0x7009ca98 <Udma_chConfigRx+0x158> @ imm = #-0x2
;                     ((chHandleInt->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)) &&
7009ca98: 9817         	ldr	r0, [sp, #0x5c]
7009ca9a: 7800         	ldrb	r0, [r0]
7009ca9c: 06c0         	lsls	r0, r0, #0x1b
7009ca9e: 2800         	cmp	r0, #0x0
7009caa0: d569         	bpl	0x7009cb76 <Udma_chConfigRx+0x236> @ imm = #0xd2
7009caa2: e7ff         	b	0x7009caa4 <Udma_chConfigRx+0x164> @ imm = #-0x2
;                (TRUE == rxPrms->configDefaultFlow))
7009caa4: 981a         	ldr	r0, [sp, #0x68]
7009caa6: 6940         	ldr	r0, [r0, #0x14]
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009caa8: 2801         	cmp	r0, #0x1
7009caaa: d164         	bne	0x7009cb76 <Udma_chConfigRx+0x236> @ imm = #0xc8
7009caac: e7ff         	b	0x7009caae <Udma_chConfigRx+0x16e> @ imm = #-0x2
;                 UdmaFlowPrms_init(&flowPrms, chHandleInt->chType);
7009caae: 9817         	ldr	r0, [sp, #0x5c]
7009cab0: 6801         	ldr	r1, [r0]
7009cab2: a801         	add	r0, sp, #0x4
7009cab4: f00a fe34    	bl	0x700a7720 <UdmaFlowPrms_init> @ imm = #0xac68
;                 flowPrms.psInfoPresent = rxPrms->flowPsInfoPresent;
7009cab8: 981a         	ldr	r0, [sp, #0x68]
7009caba: 7bc0         	ldrb	r0, [r0, #0xf]
7009cabc: f88d 0009    	strb.w	r0, [sp, #0x9]
;                 flowPrms.einfoPresent  = rxPrms->flowEInfoPresent;
7009cac0: 981a         	ldr	r0, [sp, #0x68]
7009cac2: 7b80         	ldrb	r0, [r0, #0xe]
7009cac4: f88d 0008    	strb.w	r0, [sp, #0x8]
;                 flowPrms.errorHandling = rxPrms->flowErrorHandling;
7009cac8: 981a         	ldr	r0, [sp, #0x68]
7009caca: 7c00         	ldrb	r0, [r0, #0x10]
7009cacc: f88d 000a    	strb.w	r0, [sp, #0xa]
;                 flowPrms.sopOffset     = rxPrms->flowSopOffset;
7009cad0: 981a         	ldr	r0, [sp, #0x68]
7009cad2: 7c40         	ldrb	r0, [r0, #0x11]
7009cad4: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 if(NULL_PTR == chHandleInt->cqRing)
7009cad8: 9817         	ldr	r0, [sp, #0x5c]
7009cada: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009cade: b928         	cbnz	r0, 0x7009caec <Udma_chConfigRx+0x1ac> @ imm = #0xa
7009cae0: e7ff         	b	0x7009cae2 <Udma_chConfigRx+0x1a2> @ imm = #-0x2
7009cae2: f64f 70ff    	movw	r0, #0xffff
;                     cqRing = UDMA_RING_INVALID;
7009cae6: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 }
7009caea: e006         	b	0x7009cafa <Udma_chConfigRx+0x1ba> @ imm = #0xc
;                     cqRing = chHandleInt->cqRing->ringNum;
7009caec: 9817         	ldr	r0, [sp, #0x5c]
7009caee: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009caf2: 8880         	ldrh	r0, [r0, #0x4]
7009caf4: f8ad 0002    	strh.w	r0, [sp, #0x2]
7009caf8: e7ff         	b	0x7009cafa <Udma_chConfigRx+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == chHandleInt->fqRing)
7009cafa: 9817         	ldr	r0, [sp, #0x5c]
7009cafc: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009cb00: b928         	cbnz	r0, 0x7009cb0e <Udma_chConfigRx+0x1ce> @ imm = #0xa
7009cb02: e7ff         	b	0x7009cb04 <Udma_chConfigRx+0x1c4> @ imm = #-0x2
7009cb04: f64f 70ff    	movw	r0, #0xffff
;                     fqRing = UDMA_RING_INVALID;
7009cb08: f8ad 0000    	strh.w	r0, [sp]
;                 }
7009cb0c: e006         	b	0x7009cb1c <Udma_chConfigRx+0x1dc> @ imm = #0xc
;                     fqRing = chHandleInt->fqRing->ringNum;
7009cb0e: 9817         	ldr	r0, [sp, #0x5c]
7009cb10: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009cb14: 8880         	ldrh	r0, [r0, #0x4]
7009cb16: f8ad 0000    	strh.w	r0, [sp]
7009cb1a: e7ff         	b	0x7009cb1c <Udma_chConfigRx+0x1dc> @ imm = #-0x2
;                 flowPrms.defaultRxCQ    = cqRing;
7009cb1c: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
7009cb20: f8ad 0010    	strh.w	r0, [sp, #0x10]
;                 flowPrms.fdq0Sz0Qnum    = fqRing;
7009cb24: f8bd 0000    	ldrh.w	r0, [sp]
7009cb28: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 flowPrms.fdq0Sz1Qnum    = fqRing;
7009cb2c: f8bd 0000    	ldrh.w	r0, [sp]
7009cb30: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 flowPrms.fdq0Sz2Qnum    = fqRing;
7009cb34: f8bd 0000    	ldrh.w	r0, [sp]
7009cb38: f8ad 002c    	strh.w	r0, [sp, #0x2c]
;                 flowPrms.fdq0Sz3Qnum    = fqRing;
7009cb3c: f8bd 0000    	ldrh.w	r0, [sp]
7009cb40: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;                 flowPrms.fdq1Qnum       = fqRing;
7009cb44: f8bd 0000    	ldrh.w	r0, [sp]
7009cb48: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 flowPrms.fdq2Qnum       = fqRing;
7009cb4c: f8bd 0000    	ldrh.w	r0, [sp]
7009cb50: f8ad 0020    	strh.w	r0, [sp, #0x20]
;                 flowPrms.fdq3Qnum       = fqRing;
7009cb54: f8bd 0000    	ldrh.w	r0, [sp]
7009cb58: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                 retVal = Udma_flowConfig(chHandleInt->defaultFlow, 0U, &flowPrms);
7009cb5c: 9817         	ldr	r0, [sp, #0x5c]
7009cb5e: f8d0 01c8    	ldr.w	r0, [r0, #0x1c8]
7009cb62: 2100         	movs	r1, #0x0
7009cb64: aa01         	add	r2, sp, #0x4
7009cb66: f001 f8bb    	bl	0x7009dce0 <Udma_flowConfig> @ imm = #0x1176
7009cb6a: 9019         	str	r0, [sp, #0x64]
;                 if(UDMA_SOK != retVal)
7009cb6c: 9819         	ldr	r0, [sp, #0x64]
7009cb6e: b108         	cbz	r0, 0x7009cb74 <Udma_chConfigRx+0x234> @ imm = #0x2
7009cb70: e7ff         	b	0x7009cb72 <Udma_chConfigRx+0x232> @ imm = #-0x2
;                 }
7009cb72: e7ff         	b	0x7009cb74 <Udma_chConfigRx+0x234> @ imm = #-0x2
;             }
7009cb74: e7ff         	b	0x7009cb76 <Udma_chConfigRx+0x236> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009cb76: 9819         	ldr	r0, [sp, #0x64]
7009cb78: b968         	cbnz	r0, 0x7009cb96 <Udma_chConfigRx+0x256> @ imm = #0x1a
7009cb7a: e7ff         	b	0x7009cb7c <Udma_chConfigRx+0x23c> @ imm = #-0x2
;                 (void) memcpy(&chHandleInt->rxPrms, rxPrms, sizeof(chHandleInt->rxPrms));
7009cb7c: 9817         	ldr	r0, [sp, #0x5c]
7009cb7e: f500 70fc    	add.w	r0, r0, #0x1f8
7009cb82: 991a         	ldr	r1, [sp, #0x68]
7009cb84: e8b1 100c    	ldm.w	r1!, {r2, r3, r12}
7009cb88: e8a0 100c    	stm.w	r0!, {r2, r3, r12}
7009cb8c: e891 500c    	ldm.w	r1, {r2, r3, r12, lr}
7009cb90: e880 500c    	stm.w	r0, {r2, r3, r12, lr}
;             }
7009cb94: e7ff         	b	0x7009cb96 <Udma_chConfigRx+0x256> @ imm = #-0x2
7009cb96: e7ff         	b	0x7009cb98 <Udma_chConfigRx+0x258> @ imm = #-0x2
;     }
7009cb98: e7ff         	b	0x7009cb9a <Udma_chConfigRx+0x25a> @ imm = #-0x2
;     return (retVal);
7009cb9a: 9819         	ldr	r0, [sp, #0x64]
7009cb9c: b01c         	add	sp, #0x70
7009cb9e: bd80         	pop	{r7, pc}

7009cba0 <Sciclient_rmIrqFindRoute>:
; {
7009cba0: b580         	push	{r7, lr}
7009cba2: b08a         	sub	sp, #0x28
7009cba4: 9009         	str	r0, [sp, #0x24]
7009cba6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009cba8: 9008         	str	r0, [sp, #0x20]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cbaa: 9809         	ldr	r0, [sp, #0x24]
7009cbac: 88c0         	ldrh	r0, [r0, #0x6]
7009cbae: f00f fcef    	bl	0x700ac590 <Sciclient_rmIrIsIr> @ imm = #0xf9de
7009cbb2: b930         	cbnz	r0, 0x7009cbc2 <Sciclient_rmIrqFindRoute+0x22> @ imm = #0xc
7009cbb4: e7ff         	b	0x7009cbb6 <Sciclient_rmIrqFindRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009cbb6: 9809         	ldr	r0, [sp, #0x24]
7009cbb8: 8940         	ldrh	r0, [r0, #0xa]
7009cbba: f00f fce9    	bl	0x700ac590 <Sciclient_rmIrIsIr> @ imm = #0xf9d2
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cbbe: b120         	cbz	r0, 0x7009cbca <Sciclient_rmIrqFindRoute+0x2a> @ imm = #0x8
7009cbc0: e7ff         	b	0x7009cbc2 <Sciclient_rmIrqFindRoute+0x22> @ imm = #-0x2
7009cbc2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009cbc6: 9008         	str	r0, [sp, #0x20]
;     }
7009cbc8: e7ff         	b	0x7009cbca <Sciclient_rmIrqFindRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cbca: 9808         	ldr	r0, [sp, #0x20]
7009cbcc: bb20         	cbnz	r0, 0x7009cc18 <Sciclient_rmIrqFindRoute+0x78> @ imm = #0x48
7009cbce: e7ff         	b	0x7009cbd0 <Sciclient_rmIrqFindRoute+0x30> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cbd0: 9809         	ldr	r0, [sp, #0x24]
7009cbd2: 8a00         	ldrh	r0, [r0, #0x10]
7009cbd4: 28ff         	cmp	r0, #0xff
7009cbd6: d015         	beq	0x7009cc04 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x2a
7009cbd8: e7ff         	b	0x7009cbda <Sciclient_rmIrqFindRoute+0x3a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cbda: 9809         	ldr	r0, [sp, #0x24]
7009cbdc: 6800         	ldr	r0, [r0]
7009cbde: 2104         	movs	r1, #0x4
7009cbe0: f00f fe86    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0xfd0c
;              true) &&
7009cbe4: b170         	cbz	r0, 0x7009cc04 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x1c
7009cbe6: e7ff         	b	0x7009cbe8 <Sciclient_rmIrqFindRoute+0x48> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cbe8: 9809         	ldr	r0, [sp, #0x24]
7009cbea: 6800         	ldr	r0, [r0]
7009cbec: 2108         	movs	r1, #0x8
7009cbee: f00f fe7f    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0xfcfe
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cbf2: b138         	cbz	r0, 0x7009cc04 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0xe
7009cbf4: e7ff         	b	0x7009cbf6 <Sciclient_rmIrqFindRoute+0x56> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009cbf6: 9809         	ldr	r0, [sp, #0x24]
7009cbf8: 8a00         	ldrh	r0, [r0, #0x10]
7009cbfa: a905         	add	r1, sp, #0x14
7009cbfc: f007 f988    	bl	0x700a3f10 <Sciclient_rmIrqGetNode> @ imm = #0x7310
7009cc00: 9008         	str	r0, [sp, #0x20]
;         } else {
7009cc02: e006         	b	0x7009cc12 <Sciclient_rmIrqFindRoute+0x72> @ imm = #0xc
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009cc04: 9809         	ldr	r0, [sp, #0x24]
7009cc06: 88c0         	ldrh	r0, [r0, #0x6]
7009cc08: a905         	add	r1, sp, #0x14
7009cc0a: f007 f981    	bl	0x700a3f10 <Sciclient_rmIrqGetNode> @ imm = #0x7302
7009cc0e: 9008         	str	r0, [sp, #0x20]
7009cc10: e7ff         	b	0x7009cc12 <Sciclient_rmIrqFindRoute+0x72> @ imm = #-0x2
;         root_n = cur_n;
7009cc12: 9805         	ldr	r0, [sp, #0x14]
7009cc14: 9004         	str	r0, [sp, #0x10]
;     }
7009cc16: e7ff         	b	0x7009cc18 <Sciclient_rmIrqFindRoute+0x78> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cc18: 9808         	ldr	r0, [sp, #0x20]
7009cc1a: b968         	cbnz	r0, 0x7009cc38 <Sciclient_rmIrqFindRoute+0x98> @ imm = #0x1a
7009cc1c: e7ff         	b	0x7009cc1e <Sciclient_rmIrqFindRoute+0x7e> @ imm = #-0x2
7009cc1e: 2001         	movs	r0, #0x1
;         search = true;
7009cc20: 9002         	str	r0, [sp, #0x8]
7009cc22: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         Sciclient_rmPsInit();
7009cc26: f010 f9db    	bl	0x700acfe0 <Sciclient_rmPsInit> @ imm = #0x103b6
7009cc2a: 9802         	ldr	r0, [sp, #0x8]
;         search_depth = 1u;
7009cc2c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009cc30: 2000         	movs	r0, #0x0
;         if_idx = 0u;
7009cc32: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     } else {
7009cc36: e003         	b	0x7009cc40 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #0x6
7009cc38: 2000         	movs	r0, #0x0
;         search = false;
7009cc3a: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009cc3e: e7ff         	b	0x7009cc40 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #-0x2
;     while (search == true) {
7009cc40: e7ff         	b	0x7009cc42 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x2
7009cc42: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009cc46: 07c0         	lsls	r0, r0, #0x1f
7009cc48: 2800         	cmp	r0, #0x0
7009cc4a: f000 80ca    	beq.w	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x194
7009cc4e: e7ff         	b	0x7009cc50 <Sciclient_rmIrqFindRoute+0xb0> @ imm = #-0x2
7009cc50: 2000         	movs	r0, #0x0
;         node_clear = false;
7009cc52: f88d 0019    	strb.w	r0, [sp, #0x19]
;         if (if_idx < cur_n->n_if) {
7009cc56: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009cc5a: 9905         	ldr	r1, [sp, #0x14]
7009cc5c: 8849         	ldrh	r1, [r1, #0x2]
7009cc5e: 4288         	cmp	r0, r1
7009cc60: f280 8087    	bge.w	0x7009cd72 <Sciclient_rmIrqFindRoute+0x1d2> @ imm = #0x10e
7009cc64: e7ff         	b	0x7009cc66 <Sciclient_rmIrqFindRoute+0xc6> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009cc66: 9805         	ldr	r0, [sp, #0x14]
7009cc68: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009cc6c: aa03         	add	r2, sp, #0xc
7009cc6e: f00e fda7    	bl	0x700ab7c0 <Sciclient_rmIrqGetNodeItf> @ imm = #0xeb4e
7009cc72: 9008         	str	r0, [sp, #0x20]
;             if (r != SystemP_SUCCESS) {
7009cc74: 9808         	ldr	r0, [sp, #0x20]
7009cc76: b108         	cbz	r0, 0x7009cc7c <Sciclient_rmIrqFindRoute+0xdc> @ imm = #0x2
7009cc78: e7ff         	b	0x7009cc7a <Sciclient_rmIrqFindRoute+0xda> @ imm = #-0x2
;                 break;
7009cc7a: e0b2         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x164
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009cc7c: 9805         	ldr	r0, [sp, #0x14]
7009cc7e: 8800         	ldrh	r0, [r0]
7009cc80: f00f fc6e    	bl	0x700ac560 <Sciclient_rmIaIsIa> @ imm = #0xf8dc
7009cc84: b9d0         	cbnz	r0, 0x7009ccbc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x34
7009cc86: e7ff         	b	0x7009cc88 <Sciclient_rmIrqFindRoute+0xe8> @ imm = #-0x2
;                 (Sciclient_rmPsIsEmpty() == true) &&
7009cc88: f00f fe4a    	bl	0x700ac920 <Sciclient_rmPsIsEmpty> @ imm = #0xfc94
7009cc8c: b1b0         	cbz	r0, 0x7009ccbc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x2c
7009cc8e: e7ff         	b	0x7009cc90 <Sciclient_rmIrqFindRoute+0xf0> @ imm = #-0x2
;                 ((cfg->s_idx < cur_if->lbase) ||
7009cc90: 9809         	ldr	r0, [sp, #0x24]
7009cc92: 8900         	ldrh	r0, [r0, #0x8]
7009cc94: 9903         	ldr	r1, [sp, #0xc]
7009cc96: 8809         	ldrh	r1, [r1]
7009cc98: 4288         	cmp	r0, r1
7009cc9a: db09         	blt	0x7009ccb0 <Sciclient_rmIrqFindRoute+0x110> @ imm = #0x12
7009cc9c: e7ff         	b	0x7009cc9e <Sciclient_rmIrqFindRoute+0xfe> @ imm = #-0x2
;                  (cfg->s_idx >= (cur_if->lbase + cur_if->len)))) {
7009cc9e: 9809         	ldr	r0, [sp, #0x24]
7009cca0: 8900         	ldrh	r0, [r0, #0x8]
7009cca2: 9a03         	ldr	r2, [sp, #0xc]
7009cca4: 8811         	ldrh	r1, [r2]
7009cca6: 8892         	ldrh	r2, [r2, #0x4]
7009cca8: 4411         	add	r1, r2
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009ccaa: 4288         	cmp	r0, r1
7009ccac: db06         	blt	0x7009ccbc <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0xc
7009ccae: e7ff         	b	0x7009ccb0 <Sciclient_rmIrqFindRoute+0x110> @ imm = #-0x2
;                 if_idx++;
7009ccb0: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009ccb4: 3001         	adds	r0, #0x1
7009ccb6: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             } else if (Sciclient_rmPsGetPsp() < search_depth) {
7009ccba: e059         	b	0x7009cd70 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #0xb2
7009ccbc: f010 fd40    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0x10a80
7009ccc0: f8bd 101c    	ldrh.w	r1, [sp, #0x1c]
7009ccc4: 4288         	cmp	r0, r1
7009ccc6: da1e         	bge	0x7009cd06 <Sciclient_rmIrqFindRoute+0x166> @ imm = #0x3c
7009ccc8: e7ff         	b	0x7009ccca <Sciclient_rmIrqFindRoute+0x12a> @ imm = #-0x2
;                 r = Sciclient_rmPsPush(cur_n, if_idx);
7009ccca: 9805         	ldr	r0, [sp, #0x14]
7009cccc: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009ccd0: f00d fbb6    	bl	0x700aa440 <Sciclient_rmPsPush> @ imm = #0xd76c
7009ccd4: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009ccd6: 9808         	ldr	r0, [sp, #0x20]
7009ccd8: b108         	cbz	r0, 0x7009ccde <Sciclient_rmIrqFindRoute+0x13e> @ imm = #0x2
7009ccda: e7ff         	b	0x7009ccdc <Sciclient_rmIrqFindRoute+0x13c> @ imm = #-0x2
;                     break;
7009ccdc: e081         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x102
;                 r = Sciclient_rmIrqGetNode(cur_if->rid, &cur_n);
7009ccde: 9803         	ldr	r0, [sp, #0xc]
7009cce0: 88c0         	ldrh	r0, [r0, #0x6]
7009cce2: a905         	add	r1, sp, #0x14
7009cce4: f007 f914    	bl	0x700a3f10 <Sciclient_rmIrqGetNode> @ imm = #0x7228
7009cce8: 9008         	str	r0, [sp, #0x20]
;                 if (cur_n == NULL) {
7009ccea: 9805         	ldr	r0, [sp, #0x14]
7009ccec: b930         	cbnz	r0, 0x7009ccfc <Sciclient_rmIrqFindRoute+0x15c> @ imm = #0xc
7009ccee: e7ff         	b	0x7009ccf0 <Sciclient_rmIrqFindRoute+0x150> @ imm = #-0x2
7009ccf0: 2001         	movs	r0, #0x1
;                     node_clear = true;
7009ccf2: f88d 0019    	strb.w	r0, [sp, #0x19]
7009ccf6: 2000         	movs	r0, #0x0
;                     r = SystemP_SUCCESS;
7009ccf8: 9008         	str	r0, [sp, #0x20]
;                 } else {
7009ccfa: e003         	b	0x7009cd04 <Sciclient_rmIrqFindRoute+0x164> @ imm = #0x6
7009ccfc: 2000         	movs	r0, #0x0
;                     if_idx = 0u;
7009ccfe: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009cd02: e7ff         	b	0x7009cd04 <Sciclient_rmIrqFindRoute+0x164> @ imm = #-0x2
;             } else {
7009cd04: e033         	b	0x7009cd6e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #0x66
;                 if ((cur_if->rid == cfg->d_id) &&
7009cd06: 9803         	ldr	r0, [sp, #0xc]
7009cd08: 88c0         	ldrh	r0, [r0, #0x6]
7009cd0a: 9909         	ldr	r1, [sp, #0x24]
7009cd0c: 8949         	ldrh	r1, [r1, #0xa]
7009cd0e: 4288         	cmp	r0, r1
7009cd10: d127         	bne	0x7009cd62 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x4e
7009cd12: e7ff         	b	0x7009cd14 <Sciclient_rmIrqFindRoute+0x174> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
7009cd14: 9809         	ldr	r0, [sp, #0x24]
7009cd16: 8980         	ldrh	r0, [r0, #0xc]
7009cd18: 9903         	ldr	r1, [sp, #0xc]
7009cd1a: 8849         	ldrh	r1, [r1, #0x2]
7009cd1c: 4288         	cmp	r0, r1
7009cd1e: db20         	blt	0x7009cd62 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x40
7009cd20: e7ff         	b	0x7009cd22 <Sciclient_rmIrqFindRoute+0x182> @ imm = #-0x2
;                     (cfg->d_irq <
7009cd22: 9809         	ldr	r0, [sp, #0x24]
7009cd24: 8980         	ldrh	r0, [r0, #0xc]
;                      (cur_if->rbase + cur_if->len))) {
7009cd26: 9a03         	ldr	r2, [sp, #0xc]
7009cd28: 8851         	ldrh	r1, [r2, #0x2]
7009cd2a: 8892         	ldrh	r2, [r2, #0x4]
7009cd2c: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
7009cd2e: 4288         	cmp	r0, r1
7009cd30: da17         	bge	0x7009cd62 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x2e
7009cd32: e7ff         	b	0x7009cd34 <Sciclient_rmIrqFindRoute+0x194> @ imm = #-0x2
;                     r = Sciclient_rmPsPush(cur_n, if_idx);
7009cd34: 9805         	ldr	r0, [sp, #0x14]
7009cd36: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009cd3a: f00d fb81    	bl	0x700aa440 <Sciclient_rmPsPush> @ imm = #0xd702
7009cd3e: 9008         	str	r0, [sp, #0x20]
;                     if (r != SystemP_SUCCESS) {
7009cd40: 9808         	ldr	r0, [sp, #0x20]
7009cd42: b108         	cbz	r0, 0x7009cd48 <Sciclient_rmIrqFindRoute+0x1a8> @ imm = #0x2
7009cd44: e7ff         	b	0x7009cd46 <Sciclient_rmIrqFindRoute+0x1a6> @ imm = #-0x2
;                         break;
7009cd46: e04c         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x98
;                     if (Sciclient_rmIrqRouteValidate(cfg) == true) {
7009cd48: 9809         	ldr	r0, [sp, #0x24]
7009cd4a: f7fc fe79    	bl	0x70099a40 <Sciclient_rmIrqRouteValidate> @ imm = #-0x330e
7009cd4e: b108         	cbz	r0, 0x7009cd54 <Sciclient_rmIrqFindRoute+0x1b4> @ imm = #0x2
7009cd50: e7ff         	b	0x7009cd52 <Sciclient_rmIrqFindRoute+0x1b2> @ imm = #-0x2
;                         break;
7009cd52: e046         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x8c
7009cd54: a805         	add	r0, sp, #0x14
7009cd56: f10d 011a    	add.w	r1, sp, #0x1a
;                         Sciclient_rmPsPop(&cur_n, &if_idx);
7009cd5a: f00a ff11    	bl	0x700a7b80 <Sciclient_rmPsPop> @ imm = #0xae22
7009cd5e: e7ff         	b	0x7009cd60 <Sciclient_rmIrqFindRoute+0x1c0> @ imm = #-0x2
;                 }
7009cd60: e7ff         	b	0x7009cd62 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #-0x2
;                 if_idx++;
7009cd62: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009cd66: 3001         	adds	r0, #0x1
7009cd68: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009cd6c: e7ff         	b	0x7009cd6e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #-0x2
7009cd6e: e7ff         	b	0x7009cd70 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #-0x2
;         } else {
7009cd70: e003         	b	0x7009cd7a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #0x6
7009cd72: 2001         	movs	r0, #0x1
;             node_clear = true;
7009cd74: f88d 0019    	strb.w	r0, [sp, #0x19]
7009cd78: e7ff         	b	0x7009cd7a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #-0x2
;         if (node_clear == true) {
7009cd7a: f89d 0019    	ldrb.w	r0, [sp, #0x19]
7009cd7e: 07c0         	lsls	r0, r0, #0x1f
7009cd80: b370         	cbz	r0, 0x7009cde0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #0x5c
7009cd82: e7ff         	b	0x7009cd84 <Sciclient_rmIrqFindRoute+0x1e4> @ imm = #-0x2
;             if (Sciclient_rmPsIsEmpty() == true) {
7009cd84: f00f fdcc    	bl	0x700ac920 <Sciclient_rmPsIsEmpty> @ imm = #0xfb98
7009cd88: b1c8         	cbz	r0, 0x7009cdbe <Sciclient_rmIrqFindRoute+0x21e> @ imm = #0x32
7009cd8a: e7ff         	b	0x7009cd8c <Sciclient_rmIrqFindRoute+0x1ec> @ imm = #-0x2
;                 search_depth++;
7009cd8c: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009cd90: 3001         	adds	r0, #0x1
7009cd92: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 cur_n = root_n;
7009cd96: 9804         	ldr	r0, [sp, #0x10]
7009cd98: 9005         	str	r0, [sp, #0x14]
7009cd9a: 2000         	movs	r0, #0x0
;                 if_idx = 0u;
7009cd9c: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;                 if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009cda0: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009cda4: 9001         	str	r0, [sp, #0x4]
7009cda6: f010 fd13    	bl	0x700ad7d0 <Sciclient_rmPsGetMaxPsp> @ imm = #0x10a26
7009cdaa: 4601         	mov	r1, r0
7009cdac: 9801         	ldr	r0, [sp, #0x4]
7009cdae: 4288         	cmp	r0, r1
7009cdb0: db04         	blt	0x7009cdbc <Sciclient_rmIrqFindRoute+0x21c> @ imm = #0x8
7009cdb2: e7ff         	b	0x7009cdb4 <Sciclient_rmIrqFindRoute+0x214> @ imm = #-0x2
7009cdb4: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
7009cdb8: 9008         	str	r0, [sp, #0x20]
;                     break;
7009cdba: e012         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x24
;             } else {
7009cdbc: e00f         	b	0x7009cdde <Sciclient_rmIrqFindRoute+0x23e> @ imm = #0x1e
7009cdbe: a805         	add	r0, sp, #0x14
7009cdc0: f10d 011a    	add.w	r1, sp, #0x1a
;                 r = Sciclient_rmPsPop(&cur_n, &if_idx);
7009cdc4: f00a fedc    	bl	0x700a7b80 <Sciclient_rmPsPop> @ imm = #0xadb8
7009cdc8: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009cdca: 9808         	ldr	r0, [sp, #0x20]
7009cdcc: b108         	cbz	r0, 0x7009cdd2 <Sciclient_rmIrqFindRoute+0x232> @ imm = #0x2
7009cdce: e7ff         	b	0x7009cdd0 <Sciclient_rmIrqFindRoute+0x230> @ imm = #-0x2
;                     break;
7009cdd0: e007         	b	0x7009cde2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0xe
;                 if_idx++;
7009cdd2: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009cdd6: 3001         	adds	r0, #0x1
7009cdd8: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009cddc: e7ff         	b	0x7009cdde <Sciclient_rmIrqFindRoute+0x23e> @ imm = #-0x2
;         }
7009cdde: e7ff         	b	0x7009cde0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #-0x2
;     while (search == true) {
7009cde0: e72f         	b	0x7009cc42 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x1a2
;     return r;
7009cde2: 9808         	ldr	r0, [sp, #0x20]
7009cde4: b00a         	add	sp, #0x28
7009cde6: bd80         	pop	{r7, pc}
		...

7009cdf0 <UART_fifoConfig>:
; {
7009cdf0: b580         	push	{r7, lr}
7009cdf2: b092         	sub	sp, #0x48
7009cdf4: 9011         	str	r0, [sp, #0x44]
7009cdf6: 9110         	str	r1, [sp, #0x40]
7009cdf8: 2000         	movs	r0, #0x0
;     uint32_t fcrValue = 0U;
7009cdfa: 900c         	str	r0, [sp, #0x30]
;     uint32_t txGra = (fifoConfig & UART_FIFO_CONFIG_TXGRA) >> 26;
7009cdfc: 9810         	ldr	r0, [sp, #0x40]
7009cdfe: f3c0 6083    	ubfx	r0, r0, #0x1a, #0x4
7009ce02: 900b         	str	r0, [sp, #0x2c]
;     uint32_t rxGra = (fifoConfig & UART_FIFO_CONFIG_RXGRA) >> 22;
7009ce04: 9810         	ldr	r0, [sp, #0x40]
7009ce06: f3c0 5083    	ubfx	r0, r0, #0x16, #0x4
7009ce0a: 900a         	str	r0, [sp, #0x28]
;     uint32_t txTrig = (fifoConfig & UART_FIFO_CONFIG_TXTRIG) >> 14;
7009ce0c: 9810         	ldr	r0, [sp, #0x40]
7009ce0e: f3c0 3087    	ubfx	r0, r0, #0xe, #0x8
7009ce12: 9009         	str	r0, [sp, #0x24]
;     uint32_t rxTrig = (fifoConfig & UART_FIFO_CONFIG_RXTRIG) >> 6;
7009ce14: 9810         	ldr	r0, [sp, #0x40]
7009ce16: f3c0 1087    	ubfx	r0, r0, #0x6, #0x8
7009ce1a: 9008         	str	r0, [sp, #0x20]
;     uint32_t txClr = (fifoConfig & UART_FIFO_CONFIG_TXCLR) >> 5;
7009ce1c: 9810         	ldr	r0, [sp, #0x40]
7009ce1e: f3c0 1040    	ubfx	r0, r0, #0x5, #0x1
7009ce22: 9007         	str	r0, [sp, #0x1c]
;     uint32_t rxClr = (fifoConfig & UART_FIFO_CONFIG_RXCLR) >> 4;
7009ce24: 9810         	ldr	r0, [sp, #0x40]
7009ce26: f3c0 1000    	ubfx	r0, r0, #0x4, #0x1
7009ce2a: 9006         	str	r0, [sp, #0x18]
;     uint32_t dmaEnPath = (fifoConfig & UART_FIFO_CONFIG_DMAENPATH) >> 3;
7009ce2c: 9810         	ldr	r0, [sp, #0x40]
7009ce2e: f3c0 00c0    	ubfx	r0, r0, #0x3, #0x1
7009ce32: 9005         	str	r0, [sp, #0x14]
;     uint32_t dmaMode   = (fifoConfig & UART_FIFO_CONFIG_DMAMODE);
7009ce34: 9810         	ldr	r0, [sp, #0x40]
7009ce36: f000 0007    	and	r0, r0, #0x7
7009ce3a: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
7009ce3c: 9811         	ldr	r0, [sp, #0x44]
7009ce3e: f00e ffbf    	bl	0x700abdc0 <UART_enhanFuncEnable> @ imm = #0xef7e
7009ce42: 900f         	str	r0, [sp, #0x3c]
;     tcrTlrBitVal = UART_subConfigTCRTLRModeEn(baseAddr);
7009ce44: 9811         	ldr	r0, [sp, #0x44]
7009ce46: f00a fb7b    	bl	0x700a7540 <UART_subConfigTCRTLRModeEn> @ imm = #0xa6f6
7009ce4a: 900e         	str	r0, [sp, #0x38]
;     fcrValue |= UART_FCR_FIFO_EN_MASK;
7009ce4c: 980c         	ldr	r0, [sp, #0x30]
7009ce4e: f040 0001    	orr	r0, r0, #0x1
7009ce52: 900c         	str	r0, [sp, #0x30]
;     if(UART_TRIG_LVL_GRANULARITY_1 != rxGra)
7009ce54: 980a         	ldr	r0, [sp, #0x28]
7009ce56: 2801         	cmp	r0, #0x1
7009ce58: d033         	beq	0x7009cec2 <UART_fifoConfig+0xd2> @ imm = #0x66
7009ce5a: e7ff         	b	0x7009ce5c <UART_fifoConfig+0x6c> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009ce5c: 9811         	ldr	r0, [sp, #0x44]
7009ce5e: 3040         	adds	r0, #0x40
7009ce60: 2180         	movs	r1, #0x80
7009ce62: 2207         	movs	r2, #0x7
7009ce64: 2300         	movs	r3, #0x0
7009ce66: 9303         	str	r3, [sp, #0xc]
7009ce68: f00f fa62    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf4c4
7009ce6c: 9b03         	ldr	r3, [sp, #0xc]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009ce6e: 9811         	ldr	r0, [sp, #0x44]
7009ce70: 301c         	adds	r0, #0x1c
7009ce72: 21f0         	movs	r1, #0xf0
7009ce74: 2204         	movs	r2, #0x4
7009ce76: f00f fa5b    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf4b6
;         fcrValue &= ~((uint32_t) UART_FCR_RX_FIFO_TRIG_MASK);
7009ce7a: 980c         	ldr	r0, [sp, #0x30]
7009ce7c: f020 00c0    	bic	r0, r0, #0xc0
7009ce80: 900c         	str	r0, [sp, #0x30]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009ce82: 9808         	ldr	r0, [sp, #0x20]
7009ce84: 2808         	cmp	r0, #0x8
7009ce86: d00c         	beq	0x7009cea2 <UART_fifoConfig+0xb2> @ imm = #0x18
7009ce88: e7ff         	b	0x7009ce8a <UART_fifoConfig+0x9a> @ imm = #-0x2
;            (UART_RXTRIGLVL_16 == rxTrig) ||
7009ce8a: 9808         	ldr	r0, [sp, #0x20]
7009ce8c: 2810         	cmp	r0, #0x10
7009ce8e: d008         	beq	0x7009cea2 <UART_fifoConfig+0xb2> @ imm = #0x10
7009ce90: e7ff         	b	0x7009ce92 <UART_fifoConfig+0xa2> @ imm = #-0x2
;            (UART_RXTRIGLVL_56 == rxTrig) ||
7009ce92: 9808         	ldr	r0, [sp, #0x20]
7009ce94: 2838         	cmp	r0, #0x38
7009ce96: d004         	beq	0x7009cea2 <UART_fifoConfig+0xb2> @ imm = #0x8
7009ce98: e7ff         	b	0x7009ce9a <UART_fifoConfig+0xaa> @ imm = #-0x2
;            (UART_RXTRIGLVL_60 == rxTrig))
7009ce9a: 9808         	ldr	r0, [sp, #0x20]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009ce9c: 283c         	cmp	r0, #0x3c
7009ce9e: d107         	bne	0x7009ceb0 <UART_fifoConfig+0xc0> @ imm = #0xe
7009cea0: e7ff         	b	0x7009cea2 <UART_fifoConfig+0xb2> @ imm = #-0x2
;             fcrValue |= rxTrig & UART_FCR_RX_FIFO_TRIG_MASK;
7009cea2: 9808         	ldr	r0, [sp, #0x20]
7009cea4: f000 01c0    	and	r1, r0, #0xc0
7009cea8: 980c         	ldr	r0, [sp, #0x30]
7009ceaa: 4308         	orrs	r0, r1
7009ceac: 900c         	str	r0, [sp, #0x30]
;         }
7009ceae: e007         	b	0x7009cec0 <UART_fifoConfig+0xd0> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009ceb0: 9811         	ldr	r0, [sp, #0x44]
7009ceb2: 301c         	adds	r0, #0x1c
7009ceb4: 9b08         	ldr	r3, [sp, #0x20]
7009ceb6: 21f0         	movs	r1, #0xf0
7009ceb8: 2204         	movs	r2, #0x4
7009ceba: f00f fa39    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf472
7009cebe: e7ff         	b	0x7009cec0 <UART_fifoConfig+0xd0> @ imm = #-0x2
;     }
7009cec0: e01d         	b	0x7009cefe <UART_fifoConfig+0x10e> @ imm = #0x3a
;         rxTrig &= 0x003FU;
7009cec2: 9808         	ldr	r0, [sp, #0x20]
7009cec4: f000 003f    	and	r0, r0, #0x3f
7009cec8: 9008         	str	r0, [sp, #0x20]
;         tlrValue = (rxTrig & 0x003CU) >> 2;
7009ceca: 9808         	ldr	r0, [sp, #0x20]
7009cecc: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009ced0: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (rxTrig & 0x0003U) << UART_FCR_RX_FIFO_TRIG_SHIFT;
7009ced2: 9808         	ldr	r0, [sp, #0x20]
7009ced4: f000 0103    	and	r1, r0, #0x3
7009ced8: 980c         	ldr	r0, [sp, #0x30]
7009ceda: ea40 1081    	orr.w	r0, r0, r1, lsl #6
7009cede: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009cee0: 9811         	ldr	r0, [sp, #0x44]
7009cee2: 3040         	adds	r0, #0x40
7009cee4: 2180         	movs	r1, #0x80
7009cee6: 2207         	movs	r2, #0x7
7009cee8: 2301         	movs	r3, #0x1
7009ceea: f00f fa21    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf442
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA, tlrValue);
7009ceee: 9811         	ldr	r0, [sp, #0x44]
7009cef0: 301c         	adds	r0, #0x1c
7009cef2: 9b0d         	ldr	r3, [sp, #0x34]
7009cef4: 21f0         	movs	r1, #0xf0
7009cef6: 2204         	movs	r2, #0x4
7009cef8: f00f fa1a    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf434
7009cefc: e7ff         	b	0x7009cefe <UART_fifoConfig+0x10e> @ imm = #-0x2
;     if(UART_TRIG_LVL_GRANULARITY_1 != txGra)
7009cefe: 980b         	ldr	r0, [sp, #0x2c]
7009cf00: 2801         	cmp	r0, #0x1
7009cf02: d033         	beq	0x7009cf6c <UART_fifoConfig+0x17c> @ imm = #0x66
7009cf04: e7ff         	b	0x7009cf06 <UART_fifoConfig+0x116> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009cf06: 9811         	ldr	r0, [sp, #0x44]
7009cf08: 3040         	adds	r0, #0x40
7009cf0a: 2140         	movs	r1, #0x40
7009cf0c: 2206         	movs	r2, #0x6
7009cf0e: 2300         	movs	r3, #0x0
7009cf10: 9302         	str	r3, [sp, #0x8]
7009cf12: f00f fa0d    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf41a
7009cf16: 9b02         	ldr	r3, [sp, #0x8]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009cf18: 9811         	ldr	r0, [sp, #0x44]
7009cf1a: 301c         	adds	r0, #0x1c
7009cf1c: 210f         	movs	r1, #0xf
7009cf1e: 461a         	mov	r2, r3
7009cf20: f00f fa06    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf40c
;         fcrValue &= ~((uint32_t) UART_FCR_TX_FIFO_TRIG_MASK);
7009cf24: 980c         	ldr	r0, [sp, #0x30]
7009cf26: f020 0030    	bic	r0, r0, #0x30
7009cf2a: 900c         	str	r0, [sp, #0x30]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009cf2c: 9809         	ldr	r0, [sp, #0x24]
7009cf2e: 2808         	cmp	r0, #0x8
7009cf30: d00c         	beq	0x7009cf4c <UART_fifoConfig+0x15c> @ imm = #0x18
7009cf32: e7ff         	b	0x7009cf34 <UART_fifoConfig+0x144> @ imm = #-0x2
;            (UART_TXTRIGLVL_16 == (txTrig)) ||
7009cf34: 9809         	ldr	r0, [sp, #0x24]
7009cf36: 2810         	cmp	r0, #0x10
7009cf38: d008         	beq	0x7009cf4c <UART_fifoConfig+0x15c> @ imm = #0x10
7009cf3a: e7ff         	b	0x7009cf3c <UART_fifoConfig+0x14c> @ imm = #-0x2
;            (UART_TXTRIGLVL_32 == (txTrig)) ||
7009cf3c: 9809         	ldr	r0, [sp, #0x24]
7009cf3e: 2820         	cmp	r0, #0x20
7009cf40: d004         	beq	0x7009cf4c <UART_fifoConfig+0x15c> @ imm = #0x8
7009cf42: e7ff         	b	0x7009cf44 <UART_fifoConfig+0x154> @ imm = #-0x2
;            (UART_TXTRIGLVL_56 == (txTrig)))
7009cf44: 9809         	ldr	r0, [sp, #0x24]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009cf46: 2838         	cmp	r0, #0x38
7009cf48: d107         	bne	0x7009cf5a <UART_fifoConfig+0x16a> @ imm = #0xe
7009cf4a: e7ff         	b	0x7009cf4c <UART_fifoConfig+0x15c> @ imm = #-0x2
;             fcrValue |= txTrig & UART_FCR_TX_FIFO_TRIG_MASK;
7009cf4c: 9809         	ldr	r0, [sp, #0x24]
7009cf4e: f000 0130    	and	r1, r0, #0x30
7009cf52: 980c         	ldr	r0, [sp, #0x30]
7009cf54: 4308         	orrs	r0, r1
7009cf56: 900c         	str	r0, [sp, #0x30]
;         }
7009cf58: e007         	b	0x7009cf6a <UART_fifoConfig+0x17a> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009cf5a: 9811         	ldr	r0, [sp, #0x44]
7009cf5c: 301c         	adds	r0, #0x1c
7009cf5e: 9b09         	ldr	r3, [sp, #0x24]
7009cf60: 210f         	movs	r1, #0xf
7009cf62: 2200         	movs	r2, #0x0
7009cf64: f00f f9e4    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf3c8
7009cf68: e7ff         	b	0x7009cf6a <UART_fifoConfig+0x17a> @ imm = #-0x2
;     }
7009cf6a: e01d         	b	0x7009cfa8 <UART_fifoConfig+0x1b8> @ imm = #0x3a
;         txTrig &= 0x003FU;
7009cf6c: 9809         	ldr	r0, [sp, #0x24]
7009cf6e: f000 003f    	and	r0, r0, #0x3f
7009cf72: 9009         	str	r0, [sp, #0x24]
;         tlrValue = (txTrig & 0x003CU) >> 2;
7009cf74: 9809         	ldr	r0, [sp, #0x24]
7009cf76: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009cf7a: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (txTrig & 0x0003U) << UART_FCR_TX_FIFO_TRIG_SHIFT;
7009cf7c: 9809         	ldr	r0, [sp, #0x24]
7009cf7e: f000 0103    	and	r1, r0, #0x3
7009cf82: 980c         	ldr	r0, [sp, #0x30]
7009cf84: ea40 1001    	orr.w	r0, r0, r1, lsl #4
7009cf88: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009cf8a: 9811         	ldr	r0, [sp, #0x44]
7009cf8c: 3040         	adds	r0, #0x40
7009cf8e: 2140         	movs	r1, #0x40
7009cf90: 2206         	movs	r2, #0x6
7009cf92: 2301         	movs	r3, #0x1
7009cf94: f00f f9cc    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf398
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA, tlrValue);
7009cf98: 9811         	ldr	r0, [sp, #0x44]
7009cf9a: 301c         	adds	r0, #0x1c
7009cf9c: 9b0d         	ldr	r3, [sp, #0x34]
7009cf9e: 210f         	movs	r1, #0xf
7009cfa0: 2200         	movs	r2, #0x0
7009cfa2: f00f f9c5    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf38a
7009cfa6: e7ff         	b	0x7009cfa8 <UART_fifoConfig+0x1b8> @ imm = #-0x2
;     if(UART_DMA_EN_PATH_FCR == dmaEnPath)
7009cfa8: 9805         	ldr	r0, [sp, #0x14]
7009cfaa: b9a8         	cbnz	r0, 0x7009cfd8 <UART_fifoConfig+0x1e8> @ imm = #0x2a
7009cfac: e7ff         	b	0x7009cfae <UART_fifoConfig+0x1be> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009cfae: 9811         	ldr	r0, [sp, #0x44]
7009cfb0: 3040         	adds	r0, #0x40
7009cfb2: 2101         	movs	r1, #0x1
7009cfb4: 2300         	movs	r3, #0x0
7009cfb6: 461a         	mov	r2, r3
7009cfb8: f00f f9ba    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf374
;         dmaMode &= 0x1U;
7009cfbc: 9804         	ldr	r0, [sp, #0x10]
7009cfbe: f000 0001    	and	r0, r0, #0x1
7009cfc2: 9004         	str	r0, [sp, #0x10]
;         fcrValue &= ~((uint32_t) UART_FCR_DMA_MODE_MASK);
7009cfc4: 980c         	ldr	r0, [sp, #0x30]
7009cfc6: f020 0008    	bic	r0, r0, #0x8
7009cfca: 900c         	str	r0, [sp, #0x30]
;         fcrValue |= dmaMode << UART_FCR_DMA_MODE_SHIFT;
7009cfcc: 9904         	ldr	r1, [sp, #0x10]
7009cfce: 980c         	ldr	r0, [sp, #0x30]
7009cfd0: ea40 00c1    	orr.w	r0, r0, r1, lsl #3
7009cfd4: 900c         	str	r0, [sp, #0x30]
;     }
7009cfd6: e013         	b	0x7009d000 <UART_fifoConfig+0x210> @ imm = #0x26
;         dmaMode &= 0x3U;
7009cfd8: 9804         	ldr	r0, [sp, #0x10]
7009cfda: f000 0003    	and	r0, r0, #0x3
7009cfde: 9004         	str	r0, [sp, #0x10]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009cfe0: 9811         	ldr	r0, [sp, #0x44]
7009cfe2: 3040         	adds	r0, #0x40
7009cfe4: 2200         	movs	r2, #0x0
7009cfe6: 2301         	movs	r3, #0x1
7009cfe8: 9301         	str	r3, [sp, #0x4]
7009cfea: 4619         	mov	r1, r3
7009cfec: f00f f9a0    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf340
7009cff0: 9a01         	ldr	r2, [sp, #0x4]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_2, dmaMode);
7009cff2: 9811         	ldr	r0, [sp, #0x44]
7009cff4: 3040         	adds	r0, #0x40
7009cff6: 9b04         	ldr	r3, [sp, #0x10]
7009cff8: 2106         	movs	r1, #0x6
7009cffa: f00f f999    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0xf332
7009cffe: e7ff         	b	0x7009d000 <UART_fifoConfig+0x210> @ imm = #-0x2
;     fcrValue |= rxClr << UART_FCR_RX_FIFO_CLEAR_SHIFT;
7009d000: 9906         	ldr	r1, [sp, #0x18]
7009d002: 980c         	ldr	r0, [sp, #0x30]
7009d004: ea40 0041    	orr.w	r0, r0, r1, lsl #1
7009d008: 900c         	str	r0, [sp, #0x30]
;     fcrValue |= txClr << UART_FCR_TX_FIFO_CLEAR_SHIFT;
7009d00a: 9907         	ldr	r1, [sp, #0x1c]
7009d00c: 980c         	ldr	r0, [sp, #0x30]
7009d00e: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009d012: 900c         	str	r0, [sp, #0x30]
;     UART_fifoRegisterWrite(baseAddr, fcrValue);
7009d014: 9811         	ldr	r0, [sp, #0x44]
7009d016: 990c         	ldr	r1, [sp, #0x30]
7009d018: f00c fd32    	bl	0x700a9a80 <UART_fifoRegisterWrite> @ imm = #0xca64
;     UART_tcrTlrBitValRestore(baseAddr, tcrTlrBitVal);
7009d01c: 9811         	ldr	r0, [sp, #0x44]
7009d01e: 990e         	ldr	r1, [sp, #0x38]
7009d020: f00b fa46    	bl	0x700a84b0 <UART_tcrTlrBitValRestore> @ imm = #0xb48c
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
7009d024: 9811         	ldr	r0, [sp, #0x44]
7009d026: 990f         	ldr	r1, [sp, #0x3c]
7009d028: f00f f9a2    	bl	0x700ac370 <UART_enhanFuncBitValRestore> @ imm = #0xf344
;     return fcrValue;
7009d02c: 980c         	ldr	r0, [sp, #0x30]
7009d02e: b012         	add	sp, #0x48
7009d030: bd80         	pop	{r7, pc}
		...
7009d03e: 0000         	movs	r0, r0

7009d040 <_ntoa_format>:
; {
7009d040: b570         	push	{r4, r5, r6, lr}
7009d042: b08c         	sub	sp, #0x30
7009d044: 4684         	mov	r12, r0
7009d046: 9816         	ldr	r0, [sp, #0x58]
7009d048: 9815         	ldr	r0, [sp, #0x54]
7009d04a: 9814         	ldr	r0, [sp, #0x50]
7009d04c: 9813         	ldr	r0, [sp, #0x4c]
7009d04e: 9812         	ldr	r0, [sp, #0x48]
7009d050: f8dd e044    	ldr.w	lr, [sp, #0x44]
7009d054: f8dd e040    	ldr.w	lr, [sp, #0x40]
7009d058: f8cd c02c    	str.w	r12, [sp, #0x2c]
7009d05c: 910a         	str	r1, [sp, #0x28]
7009d05e: 9209         	str	r2, [sp, #0x24]
7009d060: 9308         	str	r3, [sp, #0x20]
7009d062: f88d 001f    	strb.w	r0, [sp, #0x1f]
;   if (!(flags & FLAGS_LEFT)) {
7009d066: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d06a: 0780         	lsls	r0, r0, #0x1e
7009d06c: 2800         	cmp	r0, #0x0
7009d06e: d454         	bmi	0x7009d11a <_ntoa_format+0xda> @ imm = #0xa8
7009d070: e7ff         	b	0x7009d072 <_ntoa_format+0x32> @ imm = #-0x2
;     if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009d072: 9815         	ldr	r0, [sp, #0x54]
7009d074: b1a0         	cbz	r0, 0x7009d0a0 <_ntoa_format+0x60> @ imm = #0x28
7009d076: e7ff         	b	0x7009d078 <_ntoa_format+0x38> @ imm = #-0x2
7009d078: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d07c: 07c0         	lsls	r0, r0, #0x1f
7009d07e: b178         	cbz	r0, 0x7009d0a0 <_ntoa_format+0x60> @ imm = #0x1e
7009d080: e7ff         	b	0x7009d082 <_ntoa_format+0x42> @ imm = #-0x2
7009d082: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009d086: 07c0         	lsls	r0, r0, #0x1f
7009d088: b930         	cbnz	r0, 0x7009d098 <_ntoa_format+0x58> @ imm = #0xc
7009d08a: e7ff         	b	0x7009d08c <_ntoa_format+0x4c> @ imm = #-0x2
7009d08c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d090: f010 0f0c    	tst.w	r0, #0xc
7009d094: d004         	beq	0x7009d0a0 <_ntoa_format+0x60> @ imm = #0x8
7009d096: e7ff         	b	0x7009d098 <_ntoa_format+0x58> @ imm = #-0x2
;       width--;
7009d098: 9815         	ldr	r0, [sp, #0x54]
7009d09a: 3801         	subs	r0, #0x1
7009d09c: 9015         	str	r0, [sp, #0x54]
;     }
7009d09e: e7ff         	b	0x7009d0a0 <_ntoa_format+0x60> @ imm = #-0x2
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d0a0: e7ff         	b	0x7009d0a2 <_ntoa_format+0x62> @ imm = #-0x2
7009d0a2: 9911         	ldr	r1, [sp, #0x44]
7009d0a4: 9a14         	ldr	r2, [sp, #0x50]
7009d0a6: 2000         	movs	r0, #0x0
7009d0a8: 4291         	cmp	r1, r2
7009d0aa: 9006         	str	r0, [sp, #0x18]
7009d0ac: d207         	bhs	0x7009d0be <_ntoa_format+0x7e> @ imm = #0xe
7009d0ae: e7ff         	b	0x7009d0b0 <_ntoa_format+0x70> @ imm = #-0x2
7009d0b0: 9911         	ldr	r1, [sp, #0x44]
7009d0b2: 2000         	movs	r0, #0x0
7009d0b4: 2920         	cmp	r1, #0x20
7009d0b6: bf38         	it	lo
7009d0b8: 2001         	movlo	r0, #0x1
7009d0ba: 9006         	str	r0, [sp, #0x18]
7009d0bc: e7ff         	b	0x7009d0be <_ntoa_format+0x7e> @ imm = #-0x2
7009d0be: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d0c0: 07c0         	lsls	r0, r0, #0x1f
7009d0c2: b138         	cbz	r0, 0x7009d0d4 <_ntoa_format+0x94> @ imm = #0xe
7009d0c4: e7ff         	b	0x7009d0c6 <_ntoa_format+0x86> @ imm = #-0x2
;       buf[len++] = '0';
7009d0c6: 9910         	ldr	r1, [sp, #0x40]
7009d0c8: 9a11         	ldr	r2, [sp, #0x44]
7009d0ca: 1c50         	adds	r0, r2, #0x1
7009d0cc: 9011         	str	r0, [sp, #0x44]
7009d0ce: 2030         	movs	r0, #0x30
7009d0d0: 5488         	strb	r0, [r1, r2]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d0d2: e7e6         	b	0x7009d0a2 <_ntoa_format+0x62> @ imm = #-0x34
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d0d4: e7ff         	b	0x7009d0d6 <_ntoa_format+0x96> @ imm = #-0x2
7009d0d6: 2000         	movs	r0, #0x0
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d0d8: f89d 1058    	ldrb.w	r1, [sp, #0x58]
7009d0dc: ea4f 71c1    	lsl.w	r1, r1, #0x1f
7009d0e0: 9005         	str	r0, [sp, #0x14]
7009d0e2: b171         	cbz	r1, 0x7009d102 <_ntoa_format+0xc2> @ imm = #0x1c
7009d0e4: e7ff         	b	0x7009d0e6 <_ntoa_format+0xa6> @ imm = #-0x2
7009d0e6: 9911         	ldr	r1, [sp, #0x44]
7009d0e8: 9a15         	ldr	r2, [sp, #0x54]
7009d0ea: 2000         	movs	r0, #0x0
7009d0ec: 4291         	cmp	r1, r2
7009d0ee: 9005         	str	r0, [sp, #0x14]
7009d0f0: d207         	bhs	0x7009d102 <_ntoa_format+0xc2> @ imm = #0xe
7009d0f2: e7ff         	b	0x7009d0f4 <_ntoa_format+0xb4> @ imm = #-0x2
7009d0f4: 9911         	ldr	r1, [sp, #0x44]
7009d0f6: 2000         	movs	r0, #0x0
7009d0f8: 2920         	cmp	r1, #0x20
7009d0fa: bf38         	it	lo
7009d0fc: 2001         	movlo	r0, #0x1
7009d0fe: 9005         	str	r0, [sp, #0x14]
7009d100: e7ff         	b	0x7009d102 <_ntoa_format+0xc2> @ imm = #-0x2
7009d102: 9805         	ldr	r0, [sp, #0x14]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d104: 07c0         	lsls	r0, r0, #0x1f
7009d106: b138         	cbz	r0, 0x7009d118 <_ntoa_format+0xd8> @ imm = #0xe
7009d108: e7ff         	b	0x7009d10a <_ntoa_format+0xca> @ imm = #-0x2
;       buf[len++] = '0';
7009d10a: 9910         	ldr	r1, [sp, #0x40]
7009d10c: 9a11         	ldr	r2, [sp, #0x44]
7009d10e: 1c50         	adds	r0, r2, #0x1
7009d110: 9011         	str	r0, [sp, #0x44]
7009d112: 2030         	movs	r0, #0x30
7009d114: 5488         	strb	r0, [r1, r2]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d116: e7de         	b	0x7009d0d6 <_ntoa_format+0x96> @ imm = #-0x44
;   }
7009d118: e7ff         	b	0x7009d11a <_ntoa_format+0xda> @ imm = #-0x2
;   if (flags & FLAGS_HASH) {
7009d11a: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d11e: 06c0         	lsls	r0, r0, #0x1b
7009d120: 2800         	cmp	r0, #0x0
7009d122: d569         	bpl	0x7009d1f8 <_ntoa_format+0x1b8> @ imm = #0xd2
7009d124: e7ff         	b	0x7009d126 <_ntoa_format+0xe6> @ imm = #-0x2
;     if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
7009d126: f89d 0059    	ldrb.w	r0, [sp, #0x59]
7009d12a: 0740         	lsls	r0, r0, #0x1d
7009d12c: 2800         	cmp	r0, #0x0
7009d12e: d41c         	bmi	0x7009d16a <_ntoa_format+0x12a> @ imm = #0x38
7009d130: e7ff         	b	0x7009d132 <_ntoa_format+0xf2> @ imm = #-0x2
7009d132: 9811         	ldr	r0, [sp, #0x44]
7009d134: b1c8         	cbz	r0, 0x7009d16a <_ntoa_format+0x12a> @ imm = #0x32
7009d136: e7ff         	b	0x7009d138 <_ntoa_format+0xf8> @ imm = #-0x2
7009d138: 9811         	ldr	r0, [sp, #0x44]
7009d13a: 9914         	ldr	r1, [sp, #0x50]
7009d13c: 4288         	cmp	r0, r1
7009d13e: d005         	beq	0x7009d14c <_ntoa_format+0x10c> @ imm = #0xa
7009d140: e7ff         	b	0x7009d142 <_ntoa_format+0x102> @ imm = #-0x2
7009d142: 9811         	ldr	r0, [sp, #0x44]
7009d144: 9915         	ldr	r1, [sp, #0x54]
7009d146: 4288         	cmp	r0, r1
7009d148: d10f         	bne	0x7009d16a <_ntoa_format+0x12a> @ imm = #0x1e
7009d14a: e7ff         	b	0x7009d14c <_ntoa_format+0x10c> @ imm = #-0x2
;       len--;
7009d14c: 9811         	ldr	r0, [sp, #0x44]
7009d14e: 3801         	subs	r0, #0x1
7009d150: 9011         	str	r0, [sp, #0x44]
;       if (len && (base == 16U)) {
7009d152: 9811         	ldr	r0, [sp, #0x44]
7009d154: b140         	cbz	r0, 0x7009d168 <_ntoa_format+0x128> @ imm = #0x10
7009d156: e7ff         	b	0x7009d158 <_ntoa_format+0x118> @ imm = #-0x2
7009d158: 9813         	ldr	r0, [sp, #0x4c]
7009d15a: 2810         	cmp	r0, #0x10
7009d15c: d104         	bne	0x7009d168 <_ntoa_format+0x128> @ imm = #0x8
7009d15e: e7ff         	b	0x7009d160 <_ntoa_format+0x120> @ imm = #-0x2
;         len--;
7009d160: 9811         	ldr	r0, [sp, #0x44]
7009d162: 3801         	subs	r0, #0x1
7009d164: 9011         	str	r0, [sp, #0x44]
;       }
7009d166: e7ff         	b	0x7009d168 <_ntoa_format+0x128> @ imm = #-0x2
;     }
7009d168: e7ff         	b	0x7009d16a <_ntoa_format+0x12a> @ imm = #-0x2
;     if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d16a: 9813         	ldr	r0, [sp, #0x4c]
7009d16c: 2810         	cmp	r0, #0x10
7009d16e: d111         	bne	0x7009d194 <_ntoa_format+0x154> @ imm = #0x22
7009d170: e7ff         	b	0x7009d172 <_ntoa_format+0x132> @ imm = #-0x2
7009d172: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d176: 0680         	lsls	r0, r0, #0x1a
7009d178: 2800         	cmp	r0, #0x0
7009d17a: d40b         	bmi	0x7009d194 <_ntoa_format+0x154> @ imm = #0x16
7009d17c: e7ff         	b	0x7009d17e <_ntoa_format+0x13e> @ imm = #-0x2
7009d17e: 9811         	ldr	r0, [sp, #0x44]
7009d180: 281f         	cmp	r0, #0x1f
7009d182: d807         	bhi	0x7009d194 <_ntoa_format+0x154> @ imm = #0xe
7009d184: e7ff         	b	0x7009d186 <_ntoa_format+0x146> @ imm = #-0x2
;       buf[len++] = 'x';
7009d186: 9910         	ldr	r1, [sp, #0x40]
7009d188: 9a11         	ldr	r2, [sp, #0x44]
7009d18a: 1c50         	adds	r0, r2, #0x1
7009d18c: 9011         	str	r0, [sp, #0x44]
7009d18e: 2078         	movs	r0, #0x78
7009d190: 5488         	strb	r0, [r1, r2]
;     }
7009d192: e025         	b	0x7009d1e0 <_ntoa_format+0x1a0> @ imm = #0x4a
;     else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d194: 9813         	ldr	r0, [sp, #0x4c]
7009d196: 2810         	cmp	r0, #0x10
7009d198: d111         	bne	0x7009d1be <_ntoa_format+0x17e> @ imm = #0x22
7009d19a: e7ff         	b	0x7009d19c <_ntoa_format+0x15c> @ imm = #-0x2
7009d19c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d1a0: 0680         	lsls	r0, r0, #0x1a
7009d1a2: 2800         	cmp	r0, #0x0
7009d1a4: d50b         	bpl	0x7009d1be <_ntoa_format+0x17e> @ imm = #0x16
7009d1a6: e7ff         	b	0x7009d1a8 <_ntoa_format+0x168> @ imm = #-0x2
7009d1a8: 9811         	ldr	r0, [sp, #0x44]
7009d1aa: 281f         	cmp	r0, #0x1f
7009d1ac: d807         	bhi	0x7009d1be <_ntoa_format+0x17e> @ imm = #0xe
7009d1ae: e7ff         	b	0x7009d1b0 <_ntoa_format+0x170> @ imm = #-0x2
;       buf[len++] = 'X';
7009d1b0: 9910         	ldr	r1, [sp, #0x40]
7009d1b2: 9a11         	ldr	r2, [sp, #0x44]
7009d1b4: 1c50         	adds	r0, r2, #0x1
7009d1b6: 9011         	str	r0, [sp, #0x44]
7009d1b8: 2058         	movs	r0, #0x58
7009d1ba: 5488         	strb	r0, [r1, r2]
;     }
7009d1bc: e00f         	b	0x7009d1de <_ntoa_format+0x19e> @ imm = #0x1e
;     else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009d1be: 9813         	ldr	r0, [sp, #0x4c]
7009d1c0: 2802         	cmp	r0, #0x2
7009d1c2: d10b         	bne	0x7009d1dc <_ntoa_format+0x19c> @ imm = #0x16
7009d1c4: e7ff         	b	0x7009d1c6 <_ntoa_format+0x186> @ imm = #-0x2
7009d1c6: 9811         	ldr	r0, [sp, #0x44]
7009d1c8: 281f         	cmp	r0, #0x1f
7009d1ca: d807         	bhi	0x7009d1dc <_ntoa_format+0x19c> @ imm = #0xe
7009d1cc: e7ff         	b	0x7009d1ce <_ntoa_format+0x18e> @ imm = #-0x2
;       buf[len++] = 'b';
7009d1ce: 9910         	ldr	r1, [sp, #0x40]
7009d1d0: 9a11         	ldr	r2, [sp, #0x44]
7009d1d2: 1c50         	adds	r0, r2, #0x1
7009d1d4: 9011         	str	r0, [sp, #0x44]
7009d1d6: 2062         	movs	r0, #0x62
7009d1d8: 5488         	strb	r0, [r1, r2]
;     }
7009d1da: e7ff         	b	0x7009d1dc <_ntoa_format+0x19c> @ imm = #-0x2
7009d1dc: e7ff         	b	0x7009d1de <_ntoa_format+0x19e> @ imm = #-0x2
7009d1de: e7ff         	b	0x7009d1e0 <_ntoa_format+0x1a0> @ imm = #-0x2
;     if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009d1e0: 9811         	ldr	r0, [sp, #0x44]
7009d1e2: 281f         	cmp	r0, #0x1f
7009d1e4: d807         	bhi	0x7009d1f6 <_ntoa_format+0x1b6> @ imm = #0xe
7009d1e6: e7ff         	b	0x7009d1e8 <_ntoa_format+0x1a8> @ imm = #-0x2
;       buf[len++] = '0';
7009d1e8: 9910         	ldr	r1, [sp, #0x40]
7009d1ea: 9a11         	ldr	r2, [sp, #0x44]
7009d1ec: 1c50         	adds	r0, r2, #0x1
7009d1ee: 9011         	str	r0, [sp, #0x44]
7009d1f0: 2030         	movs	r0, #0x30
7009d1f2: 5488         	strb	r0, [r1, r2]
;     }
7009d1f4: e7ff         	b	0x7009d1f6 <_ntoa_format+0x1b6> @ imm = #-0x2
;   }
7009d1f6: e7ff         	b	0x7009d1f8 <_ntoa_format+0x1b8> @ imm = #-0x2
;   if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009d1f8: 9811         	ldr	r0, [sp, #0x44]
7009d1fa: 281f         	cmp	r0, #0x1f
7009d1fc: d829         	bhi	0x7009d252 <_ntoa_format+0x212> @ imm = #0x52
7009d1fe: e7ff         	b	0x7009d200 <_ntoa_format+0x1c0> @ imm = #-0x2
;     if (negative) {
7009d200: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009d204: 07c0         	lsls	r0, r0, #0x1f
7009d206: b138         	cbz	r0, 0x7009d218 <_ntoa_format+0x1d8> @ imm = #0xe
7009d208: e7ff         	b	0x7009d20a <_ntoa_format+0x1ca> @ imm = #-0x2
;       buf[len++] = '-';
7009d20a: 9910         	ldr	r1, [sp, #0x40]
7009d20c: 9a11         	ldr	r2, [sp, #0x44]
7009d20e: 1c50         	adds	r0, r2, #0x1
7009d210: 9011         	str	r0, [sp, #0x44]
7009d212: 202d         	movs	r0, #0x2d
7009d214: 5488         	strb	r0, [r1, r2]
;     }
7009d216: e01b         	b	0x7009d250 <_ntoa_format+0x210> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009d218: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d21c: 0740         	lsls	r0, r0, #0x1d
7009d21e: 2800         	cmp	r0, #0x0
7009d220: d507         	bpl	0x7009d232 <_ntoa_format+0x1f2> @ imm = #0xe
7009d222: e7ff         	b	0x7009d224 <_ntoa_format+0x1e4> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009d224: 9910         	ldr	r1, [sp, #0x40]
7009d226: 9a11         	ldr	r2, [sp, #0x44]
7009d228: 1c50         	adds	r0, r2, #0x1
7009d22a: 9011         	str	r0, [sp, #0x44]
7009d22c: 202b         	movs	r0, #0x2b
7009d22e: 5488         	strb	r0, [r1, r2]
;     }
7009d230: e00d         	b	0x7009d24e <_ntoa_format+0x20e> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009d232: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009d236: 0700         	lsls	r0, r0, #0x1c
7009d238: 2800         	cmp	r0, #0x0
7009d23a: d507         	bpl	0x7009d24c <_ntoa_format+0x20c> @ imm = #0xe
7009d23c: e7ff         	b	0x7009d23e <_ntoa_format+0x1fe> @ imm = #-0x2
;       buf[len++] = ' ';
7009d23e: 9910         	ldr	r1, [sp, #0x40]
7009d240: 9a11         	ldr	r2, [sp, #0x44]
7009d242: 1c50         	adds	r0, r2, #0x1
7009d244: 9011         	str	r0, [sp, #0x44]
7009d246: 2020         	movs	r0, #0x20
7009d248: 5488         	strb	r0, [r1, r2]
;     }
7009d24a: e7ff         	b	0x7009d24c <_ntoa_format+0x20c> @ imm = #-0x2
7009d24c: e7ff         	b	0x7009d24e <_ntoa_format+0x20e> @ imm = #-0x2
7009d24e: e7ff         	b	0x7009d250 <_ntoa_format+0x210> @ imm = #-0x2
;   }
7009d250: e7ff         	b	0x7009d252 <_ntoa_format+0x212> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009d252: 980b         	ldr	r0, [sp, #0x2c]
7009d254: 990a         	ldr	r1, [sp, #0x28]
7009d256: 9a09         	ldr	r2, [sp, #0x24]
7009d258: 9b08         	ldr	r3, [sp, #0x20]
7009d25a: f8dd c040    	ldr.w	r12, [sp, #0x40]
7009d25e: 9c11         	ldr	r4, [sp, #0x44]
7009d260: 9d15         	ldr	r5, [sp, #0x54]
7009d262: 9e16         	ldr	r6, [sp, #0x58]
7009d264: 46ee         	mov	lr, sp
7009d266: f8ce 600c    	str.w	r6, [lr, #0xc]
7009d26a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009d26e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009d272: f8ce c000    	str.w	r12, [lr]
7009d276: f008 f99b    	bl	0x700a55b0 <_out_rev>   @ imm = #0x8336
7009d27a: b00c         	add	sp, #0x30
7009d27c: bd70         	pop	{r4, r5, r6, pc}
7009d27e: 0000         	movs	r0, r0

7009d280 <Udma_eventRegister>:
; {
7009d280: b5b0         	push	{r4, r5, r7, lr}
7009d282: b088         	sub	sp, #0x20
7009d284: 9007         	str	r0, [sp, #0x1c]
7009d286: 9106         	str	r1, [sp, #0x18]
7009d288: 9205         	str	r2, [sp, #0x14]
7009d28a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d28c: 9004         	str	r0, [sp, #0x10]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009d28e: 9003         	str	r0, [sp, #0xc]
;     if((NULL_PTR == drvHandle) || (NULL_PTR == eventHandle) || (NULL_PTR == eventPrms))
7009d290: 9807         	ldr	r0, [sp, #0x1c]
7009d292: b130         	cbz	r0, 0x7009d2a2 <Udma_eventRegister+0x22> @ imm = #0xc
7009d294: e7ff         	b	0x7009d296 <Udma_eventRegister+0x16> @ imm = #-0x2
7009d296: 9806         	ldr	r0, [sp, #0x18]
7009d298: b118         	cbz	r0, 0x7009d2a2 <Udma_eventRegister+0x22> @ imm = #0x6
7009d29a: e7ff         	b	0x7009d29c <Udma_eventRegister+0x1c> @ imm = #-0x2
7009d29c: 9805         	ldr	r0, [sp, #0x14]
7009d29e: b920         	cbnz	r0, 0x7009d2aa <Udma_eventRegister+0x2a> @ imm = #0x8
7009d2a0: e7ff         	b	0x7009d2a2 <Udma_eventRegister+0x22> @ imm = #-0x2
7009d2a2: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009d2a6: 9004         	str	r0, [sp, #0x10]
;     }
7009d2a8: e7ff         	b	0x7009d2aa <Udma_eventRegister+0x2a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d2aa: 9804         	ldr	r0, [sp, #0x10]
7009d2ac: b988         	cbnz	r0, 0x7009d2d2 <Udma_eventRegister+0x52> @ imm = #0x22
7009d2ae: e7ff         	b	0x7009d2b0 <Udma_eventRegister+0x30> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009d2b0: 9807         	ldr	r0, [sp, #0x1c]
7009d2b2: 9002         	str	r0, [sp, #0x8]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009d2b4: 9802         	ldr	r0, [sp, #0x8]
7009d2b6: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009d2ba: f64a 31cd    	movw	r1, #0xabcd
7009d2be: f6ca 31dc    	movt	r1, #0xabdc
7009d2c2: 4288         	cmp	r0, r1
7009d2c4: d004         	beq	0x7009d2d0 <Udma_eventRegister+0x50> @ imm = #0x8
7009d2c6: e7ff         	b	0x7009d2c8 <Udma_eventRegister+0x48> @ imm = #-0x2
7009d2c8: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009d2cc: 9004         	str	r0, [sp, #0x10]
;         }
7009d2ce: e7ff         	b	0x7009d2d0 <Udma_eventRegister+0x50> @ imm = #-0x2
;     }
7009d2d0: e7ff         	b	0x7009d2d2 <Udma_eventRegister+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d2d2: 9804         	ldr	r0, [sp, #0x10]
7009d2d4: b930         	cbnz	r0, 0x7009d2e4 <Udma_eventRegister+0x64> @ imm = #0xc
7009d2d6: e7ff         	b	0x7009d2d8 <Udma_eventRegister+0x58> @ imm = #-0x2
;         retVal = Udma_eventCheckParams(drvHandleInt, eventPrms);
7009d2d8: 9802         	ldr	r0, [sp, #0x8]
7009d2da: 9905         	ldr	r1, [sp, #0x14]
7009d2dc: f006 f818    	bl	0x700a3310 <Udma_eventCheckParams> @ imm = #0x6030
7009d2e0: 9004         	str	r0, [sp, #0x10]
;     }
7009d2e2: e7ff         	b	0x7009d2e4 <Udma_eventRegister+0x64> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d2e4: 9804         	ldr	r0, [sp, #0x10]
7009d2e6: bbb0         	cbnz	r0, 0x7009d356 <Udma_eventRegister+0xd6> @ imm = #0x6c
7009d2e8: e7ff         	b	0x7009d2ea <Udma_eventRegister+0x6a> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
7009d2ea: 9806         	ldr	r0, [sp, #0x18]
7009d2ec: 9001         	str	r0, [sp, #0x4]
;             &eventHandleInt->eventPrms, eventPrms, sizeof(eventHandleInt->eventPrms));
7009d2ee: 9801         	ldr	r0, [sp, #0x4]
7009d2f0: 3008         	adds	r0, #0x8
7009d2f2: 9905         	ldr	r1, [sp, #0x14]
;         (void) memcpy(
7009d2f4: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009d2f8: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009d2fc: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009d300: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009d304: e891 503c    	ldm.w	r1, {r2, r3, r4, r5, r12, lr}
7009d308: e880 503c    	stm.w	r0, {r2, r3, r4, r5, r12, lr}
;         eventHandleInt->drvHandle       = drvHandleInt;
7009d30c: 9802         	ldr	r0, [sp, #0x8]
7009d30e: 9901         	ldr	r1, [sp, #0x4]
7009d310: 6008         	str	r0, [r1]
;         eventHandleInt->globalEvent     = UDMA_EVENT_INVALID;
7009d312: 9901         	ldr	r1, [sp, #0x4]
7009d314: f64f 70ff    	movw	r0, #0xffff
7009d318: 6488         	str	r0, [r1, #0x48]
;         eventHandleInt->vintrNum        = UDMA_EVENT_INVALID;
7009d31a: 9901         	ldr	r1, [sp, #0x4]
7009d31c: 64c8         	str	r0, [r1, #0x4c]
;         eventHandleInt->vintrBitNum     = UDMA_EVENT_INVALID;
7009d31e: 9901         	ldr	r1, [sp, #0x4]
7009d320: 6508         	str	r0, [r1, #0x50]
;         eventHandleInt->irIntrNum       = UDMA_INTR_INVALID;
7009d322: 9901         	ldr	r1, [sp, #0x4]
7009d324: 2000         	movs	r0, #0x0
7009d326: f6cf 70ff    	movt	r0, #0xffff
7009d32a: 6548         	str	r0, [r1, #0x54]
;         eventHandleInt->coreIntrNum     = UDMA_INTR_INVALID;
7009d32c: 9901         	ldr	r1, [sp, #0x4]
7009d32e: 6588         	str	r0, [r1, #0x58]
;         eventHandleInt->nextEvent       = (Udma_EventHandleInt) NULL_PTR;
7009d330: 9901         	ldr	r1, [sp, #0x4]
7009d332: 2000         	movs	r0, #0x0
7009d334: 65c8         	str	r0, [r1, #0x5c]
;         eventHandleInt->prevEvent       = (Udma_EventHandleInt) NULL_PTR;
7009d336: 9901         	ldr	r1, [sp, #0x4]
7009d338: 6608         	str	r0, [r1, #0x60]
;         eventHandleInt->hwiHandle       = NULL_PTR;
7009d33a: 9901         	ldr	r1, [sp, #0x4]
7009d33c: 6648         	str	r0, [r1, #0x64]
;         eventHandleInt->vintrBitAllocFlag = 0U;
7009d33e: 9901         	ldr	r1, [sp, #0x4]
7009d340: f8c1 008c    	str.w	r0, [r1, #0x8c]
7009d344: f8c1 0088    	str.w	r0, [r1, #0x88]
;         eventHandleInt->pIaGeviRegs     = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
7009d348: 9901         	ldr	r1, [sp, #0x4]
7009d34a: f8c1 0090    	str.w	r0, [r1, #0x90]
;         eventHandleInt->pIaVintrRegs    = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
7009d34e: 9901         	ldr	r1, [sp, #0x4]
7009d350: f8c1 0094    	str.w	r0, [r1, #0x94]
;     }
7009d354: e7ff         	b	0x7009d356 <Udma_eventRegister+0xd6> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d356: 9804         	ldr	r0, [sp, #0x10]
7009d358: 2800         	cmp	r0, #0x0
7009d35a: f040 809f    	bne.w	0x7009d49c <Udma_eventRegister+0x21c> @ imm = #0x13e
7009d35e: e7ff         	b	0x7009d360 <Udma_eventRegister+0xe0> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009d360: 9802         	ldr	r0, [sp, #0x8]
7009d362: 6800         	ldr	r0, [r0]
7009d364: b130         	cbz	r0, 0x7009d374 <Udma_eventRegister+0xf4> @ imm = #0xc
7009d366: e7ff         	b	0x7009d368 <Udma_eventRegister+0xe8> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009d368: 9805         	ldr	r0, [sp, #0x14]
7009d36a: 6800         	ldr	r0, [r0]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009d36c: 2802         	cmp	r0, #0x2
7009d36e: d101         	bne	0x7009d374 <Udma_eventRegister+0xf4> @ imm = #0x2
7009d370: e7ff         	b	0x7009d372 <Udma_eventRegister+0xf2> @ imm = #-0x2
;         }
7009d372: e092         	b	0x7009d49a <Udma_eventRegister+0x21a> @ imm = #0x124
;             retVal = Udma_eventAllocResource(drvHandleInt, eventHandleInt);
7009d374: 9802         	ldr	r0, [sp, #0x8]
7009d376: 9901         	ldr	r1, [sp, #0x4]
7009d378: f000 f89a    	bl	0x7009d4b0 <Udma_eventAllocResource> @ imm = #0x134
7009d37c: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK == retVal)
7009d37e: 9804         	ldr	r0, [sp, #0x10]
7009d380: b918         	cbnz	r0, 0x7009d38a <Udma_eventRegister+0x10a> @ imm = #0x6
7009d382: e7ff         	b	0x7009d384 <Udma_eventRegister+0x104> @ imm = #-0x2
7009d384: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009d386: 9003         	str	r0, [sp, #0xc]
;             }
7009d388: e000         	b	0x7009d38c <Udma_eventRegister+0x10c> @ imm = #0x0
7009d38a: e7ff         	b	0x7009d38c <Udma_eventRegister+0x10c> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009d38c: 9804         	ldr	r0, [sp, #0x10]
7009d38e: b9a0         	cbnz	r0, 0x7009d3ba <Udma_eventRegister+0x13a> @ imm = #0x28
7009d390: e7ff         	b	0x7009d392 <Udma_eventRegister+0x112> @ imm = #-0x2
;                 eventHandleInt->eventInitDone = UDMA_INIT_DONE;
7009d392: 9901         	ldr	r1, [sp, #0x4]
7009d394: f64a 30cd    	movw	r0, #0xabcd
7009d398: f6ca 30dc    	movt	r0, #0xabdc
7009d39c: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 retVal = Udma_eventConfig(drvHandleInt, eventHandleInt);
7009d3a0: 9802         	ldr	r0, [sp, #0x8]
7009d3a2: 9901         	ldr	r1, [sp, #0x4]
7009d3a4: f7fe f8b4    	bl	0x7009b510 <Udma_eventConfig> @ imm = #-0x1e98
7009d3a8: 9004         	str	r0, [sp, #0x10]
;                 if(UDMA_SOK == retVal)
7009d3aa: 9804         	ldr	r0, [sp, #0x10]
7009d3ac: b918         	cbnz	r0, 0x7009d3b6 <Udma_eventRegister+0x136> @ imm = #0x6
7009d3ae: e7ff         	b	0x7009d3b0 <Udma_eventRegister+0x130> @ imm = #-0x2
7009d3b0: 2001         	movs	r0, #0x1
;                     allocDone = (uint32_t) TRUE;
7009d3b2: 9003         	str	r0, [sp, #0xc]
;                 }
7009d3b4: e000         	b	0x7009d3b8 <Udma_eventRegister+0x138> @ imm = #0x0
7009d3b6: e7ff         	b	0x7009d3b8 <Udma_eventRegister+0x138> @ imm = #-0x2
;             }
7009d3b8: e7ff         	b	0x7009d3ba <Udma_eventRegister+0x13a> @ imm = #-0x2
;             if(UDMA_SOK != retVal)
7009d3ba: 9804         	ldr	r0, [sp, #0x10]
7009d3bc: b170         	cbz	r0, 0x7009d3dc <Udma_eventRegister+0x15c> @ imm = #0x1c
7009d3be: e7ff         	b	0x7009d3c0 <Udma_eventRegister+0x140> @ imm = #-0x2
;                 if(((uint32_t) TRUE) == allocDone)
7009d3c0: 9803         	ldr	r0, [sp, #0xc]
7009d3c2: 2801         	cmp	r0, #0x1
7009d3c4: d109         	bne	0x7009d3da <Udma_eventRegister+0x15a> @ imm = #0x12
7009d3c6: e7ff         	b	0x7009d3c8 <Udma_eventRegister+0x148> @ imm = #-0x2
;                     Udma_eventFreeResource(drvHandleInt, eventHandleInt);
7009d3c8: 9802         	ldr	r0, [sp, #0x8]
7009d3ca: 9901         	ldr	r1, [sp, #0x4]
7009d3cc: f006 fcb0    	bl	0x700a3d30 <Udma_eventFreeResource> @ imm = #0x6960
;                     eventHandleInt->eventInitDone = UDMA_DEINIT_DONE;
7009d3d0: 9901         	ldr	r1, [sp, #0x4]
7009d3d2: 2000         	movs	r0, #0x0
7009d3d4: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 }
7009d3d8: e7ff         	b	0x7009d3da <Udma_eventRegister+0x15a> @ imm = #-0x2
;             }
7009d3da: e05d         	b	0x7009d498 <Udma_eventRegister+0x218> @ imm = #0xba
;                 eventPrms->intrStatusReg    = &eventHandleInt->pIaVintrRegs->STATUSM;
7009d3dc: 9801         	ldr	r0, [sp, #0x4]
7009d3de: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009d3e2: 3020         	adds	r0, #0x20
7009d3e4: 9905         	ldr	r1, [sp, #0x14]
7009d3e6: 6248         	str	r0, [r1, #0x24]
;                 eventPrms->intrClearReg     = &eventHandleInt->pIaVintrRegs->STATUS_CLEAR;
7009d3e8: 9801         	ldr	r0, [sp, #0x4]
7009d3ea: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009d3ee: 3018         	adds	r0, #0x18
7009d3f0: 9905         	ldr	r1, [sp, #0x14]
7009d3f2: 6288         	str	r0, [r1, #0x28]
;                 if(eventHandleInt->vintrBitNum != UDMA_EVENT_INVALID)
7009d3f4: 9801         	ldr	r0, [sp, #0x4]
7009d3f6: 6d00         	ldr	r0, [r0, #0x50]
7009d3f8: f64f 71ff    	movw	r1, #0xffff
7009d3fc: 4288         	cmp	r0, r1
7009d3fe: d017         	beq	0x7009d430 <Udma_eventRegister+0x1b0> @ imm = #0x2e
7009d400: e7ff         	b	0x7009d402 <Udma_eventRegister+0x182> @ imm = #-0x2
;                     eventPrms->intrMask     = ((uint64_t)1U << eventHandleInt->vintrBitNum);
7009d402: 9801         	ldr	r0, [sp, #0x4]
7009d404: 6d03         	ldr	r3, [r0, #0x50]
7009d406: f1a3 0120    	sub.w	r1, r3, #0x20
7009d40a: 2201         	movs	r2, #0x1
7009d40c: fa02 fc01    	lsl.w	r12, r2, r1
7009d410: f1c3 0020    	rsb.w	r0, r3, #0x20
7009d414: fa22 f000    	lsr.w	r0, r2, r0
7009d418: 2900         	cmp	r1, #0x0
7009d41a: bf58         	it	pl
7009d41c: 4660         	movpl	r0, r12
7009d41e: fa02 f203    	lsl.w	r2, r2, r3
7009d422: 2900         	cmp	r1, #0x0
7009d424: bf58         	it	pl
7009d426: 2200         	movpl	r2, #0x0
7009d428: 9905         	ldr	r1, [sp, #0x14]
7009d42a: 630a         	str	r2, [r1, #0x30]
7009d42c: 6348         	str	r0, [r1, #0x34]
;                 }
7009d42e: e004         	b	0x7009d43a <Udma_eventRegister+0x1ba> @ imm = #0x8
;                     eventPrms->intrMask     = 0U;
7009d430: 9905         	ldr	r1, [sp, #0x14]
7009d432: 2000         	movs	r0, #0x0
7009d434: 6348         	str	r0, [r1, #0x34]
7009d436: 6308         	str	r0, [r1, #0x30]
7009d438: e7ff         	b	0x7009d43a <Udma_eventRegister+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == eventHandleInt->eventPrms.controllerEventHandle)
7009d43a: 9801         	ldr	r0, [sp, #0x4]
7009d43c: 6980         	ldr	r0, [r0, #0x18]
7009d43e: b948         	cbnz	r0, 0x7009d454 <Udma_eventRegister+0x1d4> @ imm = #0x12
7009d440: e7ff         	b	0x7009d442 <Udma_eventRegister+0x1c2> @ imm = #-0x2
;                     eventPrms->vintrNum     = eventHandleInt->vintrNum;
7009d442: 9801         	ldr	r0, [sp, #0x4]
7009d444: 6cc0         	ldr	r0, [r0, #0x4c]
7009d446: 9905         	ldr	r1, [sp, #0x14]
7009d448: 6388         	str	r0, [r1, #0x38]
;                     eventPrms->coreIntrNum  = eventHandleInt->coreIntrNum;
7009d44a: 9801         	ldr	r0, [sp, #0x4]
7009d44c: 6d80         	ldr	r0, [r0, #0x58]
7009d44e: 9905         	ldr	r1, [sp, #0x14]
7009d450: 63c8         	str	r0, [r1, #0x3c]
;                 }
7009d452: e00a         	b	0x7009d46a <Udma_eventRegister+0x1ea> @ imm = #0x14
;                        ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->vintrNum;
7009d454: 9801         	ldr	r0, [sp, #0x4]
7009d456: 6980         	ldr	r0, [r0, #0x18]
7009d458: 6cc0         	ldr	r0, [r0, #0x4c]
;                     eventPrms->vintrNum       =
7009d45a: 9905         	ldr	r1, [sp, #0x14]
7009d45c: 6388         	str	r0, [r1, #0x38]
;                         ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->coreIntrNum;
7009d45e: 9801         	ldr	r0, [sp, #0x4]
7009d460: 6980         	ldr	r0, [r0, #0x18]
7009d462: 6d80         	ldr	r0, [r0, #0x58]
;                     eventPrms->coreIntrNum    =
7009d464: 9905         	ldr	r1, [sp, #0x14]
7009d466: 63c8         	str	r0, [r1, #0x3c]
7009d468: e7ff         	b	0x7009d46a <Udma_eventRegister+0x1ea> @ imm = #-0x2
;                 eventHandleInt->eventPrms.intrStatusReg   = eventPrms->intrStatusReg;
7009d46a: 9805         	ldr	r0, [sp, #0x14]
7009d46c: 6a40         	ldr	r0, [r0, #0x24]
7009d46e: 9901         	ldr	r1, [sp, #0x4]
7009d470: 62c8         	str	r0, [r1, #0x2c]
;                 eventHandleInt->eventPrms.intrClearReg    = eventPrms->intrClearReg;
7009d472: 9805         	ldr	r0, [sp, #0x14]
7009d474: 6a80         	ldr	r0, [r0, #0x28]
7009d476: 9901         	ldr	r1, [sp, #0x4]
7009d478: 6308         	str	r0, [r1, #0x30]
;                 eventHandleInt->eventPrms.intrMask        = eventPrms->intrMask;
7009d47a: 9905         	ldr	r1, [sp, #0x14]
7009d47c: 6b08         	ldr	r0, [r1, #0x30]
7009d47e: 6b4a         	ldr	r2, [r1, #0x34]
7009d480: 9901         	ldr	r1, [sp, #0x4]
7009d482: 63ca         	str	r2, [r1, #0x3c]
7009d484: 6388         	str	r0, [r1, #0x38]
;                 eventHandleInt->eventPrms.vintrNum        = eventPrms->vintrNum;
7009d486: 9805         	ldr	r0, [sp, #0x14]
7009d488: 6b80         	ldr	r0, [r0, #0x38]
7009d48a: 9901         	ldr	r1, [sp, #0x4]
7009d48c: 6408         	str	r0, [r1, #0x40]
;                 eventHandleInt->eventPrms.coreIntrNum     = eventPrms->coreIntrNum;
7009d48e: 9805         	ldr	r0, [sp, #0x14]
7009d490: 6bc0         	ldr	r0, [r0, #0x3c]
7009d492: 9901         	ldr	r1, [sp, #0x4]
7009d494: 6448         	str	r0, [r1, #0x44]
7009d496: e7ff         	b	0x7009d498 <Udma_eventRegister+0x218> @ imm = #-0x2
7009d498: e7ff         	b	0x7009d49a <Udma_eventRegister+0x21a> @ imm = #-0x2
;     }
7009d49a: e7ff         	b	0x7009d49c <Udma_eventRegister+0x21c> @ imm = #-0x2
;     return (retVal);
7009d49c: 9804         	ldr	r0, [sp, #0x10]
7009d49e: b008         	add	sp, #0x20
7009d4a0: bdb0         	pop	{r4, r5, r7, pc}
		...
7009d4ae: 0000         	movs	r0, r0

7009d4b0 <Udma_eventAllocResource>:
; {
7009d4b0: b580         	push	{r7, lr}
7009d4b2: b08a         	sub	sp, #0x28
7009d4b4: 9009         	str	r0, [sp, #0x24]
7009d4b6: 9108         	str	r1, [sp, #0x20]
7009d4b8: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009d4ba: 9007         	str	r0, [sp, #0x1c]
;     eventPrms = &eventHandle->eventPrms;
7009d4bc: 9808         	ldr	r0, [sp, #0x20]
7009d4be: 3008         	adds	r0, #0x8
7009d4c0: 9004         	str	r0, [sp, #0x10]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009d4c2: 9804         	ldr	r0, [sp, #0x10]
7009d4c4: 6800         	ldr	r0, [r0]
7009d4c6: 2805         	cmp	r0, #0x5
7009d4c8: d01b         	beq	0x7009d502 <Udma_eventAllocResource+0x52> @ imm = #0x36
7009d4ca: e7ff         	b	0x7009d4cc <Udma_eventAllocResource+0x1c> @ imm = #-0x2
;         eventHandle->globalEvent = Udma_rmAllocEvent(drvHandle);
7009d4cc: 9809         	ldr	r0, [sp, #0x24]
7009d4ce: f009 fa97    	bl	0x700a6a00 <Udma_rmAllocEvent> @ imm = #0x952e
7009d4d2: 9908         	ldr	r1, [sp, #0x20]
7009d4d4: 6488         	str	r0, [r1, #0x48]
;         if(UDMA_EVENT_INVALID == eventHandle->globalEvent)
7009d4d6: 9808         	ldr	r0, [sp, #0x20]
7009d4d8: 6c80         	ldr	r0, [r0, #0x48]
7009d4da: f64f 71ff    	movw	r1, #0xffff
7009d4de: 4288         	cmp	r0, r1
7009d4e0: d104         	bne	0x7009d4ec <Udma_eventAllocResource+0x3c> @ imm = #0x8
7009d4e2: e7ff         	b	0x7009d4e4 <Udma_eventAllocResource+0x34> @ imm = #-0x2
7009d4e4: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009d4e8: 9007         	str	r0, [sp, #0x1c]
;         }
7009d4ea: e009         	b	0x7009d500 <Udma_eventAllocResource+0x50> @ imm = #0x12
;                 &drvHandle->iaRegs.pImapRegs->GEVI[eventHandle->globalEvent];
7009d4ec: 9809         	ldr	r0, [sp, #0x24]
7009d4ee: f8d0 00a0    	ldr.w	r0, [r0, #0xa0]
7009d4f2: 9908         	ldr	r1, [sp, #0x20]
7009d4f4: 6c8a         	ldr	r2, [r1, #0x48]
7009d4f6: eb00 00c2    	add.w	r0, r0, r2, lsl #3
;             eventHandle->pIaGeviRegs =
7009d4fa: f8c1 0090    	str.w	r0, [r1, #0x90]
7009d4fe: e7ff         	b	0x7009d500 <Udma_eventAllocResource+0x50> @ imm = #-0x2
;     }
7009d500: e7ff         	b	0x7009d502 <Udma_eventAllocResource+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d502: 9807         	ldr	r0, [sp, #0x1c]
7009d504: bb00         	cbnz	r0, 0x7009d548 <Udma_eventAllocResource+0x98> @ imm = #0x40
7009d506: e7ff         	b	0x7009d508 <Udma_eventAllocResource+0x58> @ imm = #-0x2
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009d508: 9804         	ldr	r0, [sp, #0x10]
7009d50a: 6840         	ldr	r0, [r0, #0x4]
7009d50c: 2801         	cmp	r0, #0x1
7009d50e: d009         	beq	0x7009d524 <Udma_eventAllocResource+0x74> @ imm = #0x12
7009d510: e7ff         	b	0x7009d512 <Udma_eventAllocResource+0x62> @ imm = #-0x2
;             ((UDMA_EVENT_MODE_SHARED == eventPrms->eventMode) &&
7009d512: 9804         	ldr	r0, [sp, #0x10]
7009d514: 6840         	ldr	r0, [r0, #0x4]
7009d516: 2802         	cmp	r0, #0x2
7009d518: d115         	bne	0x7009d546 <Udma_eventAllocResource+0x96> @ imm = #0x2a
7009d51a: e7ff         	b	0x7009d51c <Udma_eventAllocResource+0x6c> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)))
7009d51c: 9804         	ldr	r0, [sp, #0x10]
7009d51e: 6900         	ldr	r0, [r0, #0x10]
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009d520: b988         	cbnz	r0, 0x7009d546 <Udma_eventAllocResource+0x96> @ imm = #0x22
7009d522: e7ff         	b	0x7009d524 <Udma_eventAllocResource+0x74> @ imm = #-0x2
;             eventHandle->vintrNum = Udma_rmAllocVintr(drvHandle);
7009d524: 9809         	ldr	r0, [sp, #0x24]
7009d526: f009 fabb    	bl	0x700a6aa0 <Udma_rmAllocVintr> @ imm = #0x9576
7009d52a: 9908         	ldr	r1, [sp, #0x20]
7009d52c: 64c8         	str	r0, [r1, #0x4c]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrNum)
7009d52e: 9808         	ldr	r0, [sp, #0x20]
7009d530: 6cc0         	ldr	r0, [r0, #0x4c]
7009d532: f64f 71ff    	movw	r1, #0xffff
7009d536: 4288         	cmp	r0, r1
7009d538: d104         	bne	0x7009d544 <Udma_eventAllocResource+0x94> @ imm = #0x8
7009d53a: e7ff         	b	0x7009d53c <Udma_eventAllocResource+0x8c> @ imm = #-0x2
7009d53c: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d540: 9007         	str	r0, [sp, #0x1c]
;             }
7009d542: e7ff         	b	0x7009d544 <Udma_eventAllocResource+0x94> @ imm = #-0x2
;         }
7009d544: e7ff         	b	0x7009d546 <Udma_eventAllocResource+0x96> @ imm = #-0x2
;     }
7009d546: e7ff         	b	0x7009d548 <Udma_eventAllocResource+0x98> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d548: 9807         	ldr	r0, [sp, #0x1c]
7009d54a: b9b8         	cbnz	r0, 0x7009d57c <Udma_eventAllocResource+0xcc> @ imm = #0x2e
7009d54c: e7ff         	b	0x7009d54e <Udma_eventAllocResource+0x9e> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009d54e: 9804         	ldr	r0, [sp, #0x10]
7009d550: 6800         	ldr	r0, [r0]
7009d552: 2805         	cmp	r0, #0x5
7009d554: d011         	beq	0x7009d57a <Udma_eventAllocResource+0xca> @ imm = #0x22
7009d556: e7ff         	b	0x7009d558 <Udma_eventAllocResource+0xa8> @ imm = #-0x2
;             eventHandle->vintrBitNum = Udma_rmAllocVintrBit(eventHandle);
7009d558: 9808         	ldr	r0, [sp, #0x20]
7009d55a: f007 f9b1    	bl	0x700a48c0 <Udma_rmAllocVintrBit> @ imm = #0x7362
7009d55e: 9908         	ldr	r1, [sp, #0x20]
7009d560: 6508         	str	r0, [r1, #0x50]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrBitNum)
7009d562: 9808         	ldr	r0, [sp, #0x20]
7009d564: 6d00         	ldr	r0, [r0, #0x50]
7009d566: f64f 71ff    	movw	r1, #0xffff
7009d56a: 4288         	cmp	r0, r1
7009d56c: d104         	bne	0x7009d578 <Udma_eventAllocResource+0xc8> @ imm = #0x8
7009d56e: e7ff         	b	0x7009d570 <Udma_eventAllocResource+0xc0> @ imm = #-0x2
7009d570: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d574: 9007         	str	r0, [sp, #0x1c]
;             }
7009d576: e7ff         	b	0x7009d578 <Udma_eventAllocResource+0xc8> @ imm = #-0x2
;         }
7009d578: e7ff         	b	0x7009d57a <Udma_eventAllocResource+0xca> @ imm = #-0x2
;     }
7009d57a: e7ff         	b	0x7009d57c <Udma_eventAllocResource+0xcc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d57c: 9807         	ldr	r0, [sp, #0x1c]
7009d57e: 2800         	cmp	r0, #0x0
7009d580: d146         	bne	0x7009d610 <Udma_eventAllocResource+0x160> @ imm = #0x8c
7009d582: e7ff         	b	0x7009d584 <Udma_eventAllocResource+0xd4> @ imm = #-0x2
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009d584: 9804         	ldr	r0, [sp, #0x10]
7009d586: 6940         	ldr	r0, [r0, #0x14]
7009d588: b120         	cbz	r0, 0x7009d594 <Udma_eventAllocResource+0xe4> @ imm = #0x8
7009d58a: e7ff         	b	0x7009d58c <Udma_eventAllocResource+0xdc> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)) ||
7009d58c: 9804         	ldr	r0, [sp, #0x10]
7009d58e: 6900         	ldr	r0, [r0, #0x10]
7009d590: b128         	cbz	r0, 0x7009d59e <Udma_eventAllocResource+0xee> @ imm = #0xa
7009d592: e7ff         	b	0x7009d594 <Udma_eventAllocResource+0xe4> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009d594: 9804         	ldr	r0, [sp, #0x10]
7009d596: 6800         	ldr	r0, [r0]
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009d598: 2805         	cmp	r0, #0x5
7009d59a: d138         	bne	0x7009d60e <Udma_eventAllocResource+0x15e> @ imm = #0x70
7009d59c: e7ff         	b	0x7009d59e <Udma_eventAllocResource+0xee> @ imm = #-0x2
;             if(UDMA_CORE_INTR_ANY != eventPrms->preferredCoreIntrNum)
7009d59e: 9804         	ldr	r0, [sp, #0x10]
7009d5a0: 6a00         	ldr	r0, [r0, #0x20]
7009d5a2: 2101         	movs	r1, #0x1
7009d5a4: f6cf 71ff    	movt	r1, #0xffff
7009d5a8: 4288         	cmp	r0, r1
7009d5aa: d007         	beq	0x7009d5bc <Udma_eventAllocResource+0x10c> @ imm = #0xe
7009d5ac: e7ff         	b	0x7009d5ae <Udma_eventAllocResource+0xfe> @ imm = #-0x2
;                 preferredIrIntrNum = Udma_rmTranslateCoreIntrInput(drvHandle, eventPrms->preferredCoreIntrNum);
7009d5ae: 9809         	ldr	r0, [sp, #0x24]
7009d5b0: 9904         	ldr	r1, [sp, #0x10]
7009d5b2: 6a09         	ldr	r1, [r1, #0x20]
7009d5b4: f00f fc64    	bl	0x700ace80 <Udma_rmTranslateCoreIntrInput> @ imm = #0xf8c8
7009d5b8: 9005         	str	r0, [sp, #0x14]
;             }
7009d5ba: e003         	b	0x7009d5c4 <Udma_eventAllocResource+0x114> @ imm = #0x6
;                 preferredIrIntrNum = eventPrms->preferredCoreIntrNum;
7009d5bc: 9804         	ldr	r0, [sp, #0x10]
7009d5be: 6a00         	ldr	r0, [r0, #0x20]
7009d5c0: 9005         	str	r0, [sp, #0x14]
7009d5c2: e7ff         	b	0x7009d5c4 <Udma_eventAllocResource+0x114> @ imm = #-0x2
;             if(UDMA_INTR_INVALID != preferredIrIntrNum)
7009d5c4: 9805         	ldr	r0, [sp, #0x14]
7009d5c6: f510 3f80    	cmn.w	r0, #0x10000
7009d5ca: d015         	beq	0x7009d5f8 <Udma_eventAllocResource+0x148> @ imm = #0x2a
7009d5cc: e7ff         	b	0x7009d5ce <Udma_eventAllocResource+0x11e> @ imm = #-0x2
;                     Udma_rmAllocIrIntr(preferredIrIntrNum, drvHandle);
7009d5ce: 9805         	ldr	r0, [sp, #0x14]
7009d5d0: 9909         	ldr	r1, [sp, #0x24]
7009d5d2: f003 ff05    	bl	0x700a13e0 <Udma_rmAllocIrIntr> @ imm = #0x3e0a
;                 eventHandle->irIntrNum =
7009d5d6: 9908         	ldr	r1, [sp, #0x20]
7009d5d8: 6548         	str	r0, [r1, #0x54]
;                 if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
7009d5da: 9808         	ldr	r0, [sp, #0x20]
7009d5dc: 6d40         	ldr	r0, [r0, #0x54]
7009d5de: f510 3f80    	cmn.w	r0, #0x10000
7009d5e2: d008         	beq	0x7009d5f6 <Udma_eventAllocResource+0x146> @ imm = #0x10
7009d5e4: e7ff         	b	0x7009d5e6 <Udma_eventAllocResource+0x136> @ imm = #-0x2
;                     eventHandle->coreIntrNum = Udma_rmTranslateIrOutput(drvHandle, eventHandle->irIntrNum);
7009d5e6: 9809         	ldr	r0, [sp, #0x24]
7009d5e8: 9908         	ldr	r1, [sp, #0x20]
7009d5ea: 6d49         	ldr	r1, [r1, #0x54]
7009d5ec: f00f fc60    	bl	0x700aceb0 <Udma_rmTranslateIrOutput> @ imm = #0xf8c0
7009d5f0: 9908         	ldr	r1, [sp, #0x20]
7009d5f2: 6588         	str	r0, [r1, #0x58]
;                 }
7009d5f4: e7ff         	b	0x7009d5f6 <Udma_eventAllocResource+0x146> @ imm = #-0x2
;             }
7009d5f6: e7ff         	b	0x7009d5f8 <Udma_eventAllocResource+0x148> @ imm = #-0x2
;             if(UDMA_INTR_INVALID == eventHandle->coreIntrNum)
7009d5f8: 9808         	ldr	r0, [sp, #0x20]
7009d5fa: 6d80         	ldr	r0, [r0, #0x58]
7009d5fc: f510 3f80    	cmn.w	r0, #0x10000
7009d600: d104         	bne	0x7009d60c <Udma_eventAllocResource+0x15c> @ imm = #0x8
7009d602: e7ff         	b	0x7009d604 <Udma_eventAllocResource+0x154> @ imm = #-0x2
7009d604: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d608: 9007         	str	r0, [sp, #0x1c]
;             }
7009d60a: e7ff         	b	0x7009d60c <Udma_eventAllocResource+0x15c> @ imm = #-0x2
;         }
7009d60c: e7ff         	b	0x7009d60e <Udma_eventAllocResource+0x15e> @ imm = #-0x2
;     }
7009d60e: e7ff         	b	0x7009d610 <Udma_eventAllocResource+0x160> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d610: 9807         	ldr	r0, [sp, #0x1c]
7009d612: bb18         	cbnz	r0, 0x7009d65c <Udma_eventAllocResource+0x1ac> @ imm = #0x46
7009d614: e7ff         	b	0x7009d616 <Udma_eventAllocResource+0x166> @ imm = #-0x2
;         cookie = HwiP_disable();
7009d616: f010 eebc    	blx	0x700ae390 <HwiP_disable> @ imm = #0x10d78
7009d61a: 9002         	str	r0, [sp, #0x8]
;         eventHandle->prevEvent = (Udma_EventHandleInt) NULL_PTR;
7009d61c: 9908         	ldr	r1, [sp, #0x20]
7009d61e: 2000         	movs	r0, #0x0
7009d620: 6608         	str	r0, [r1, #0x60]
;         eventHandle->nextEvent = (Udma_EventHandleInt) NULL_PTR;
7009d622: 9908         	ldr	r1, [sp, #0x20]
7009d624: 65c8         	str	r0, [r1, #0x5c]
;         if(NULL_PTR != eventPrms->controllerEventHandle)
7009d626: 9804         	ldr	r0, [sp, #0x10]
7009d628: 6900         	ldr	r0, [r0, #0x10]
7009d62a: b198         	cbz	r0, 0x7009d654 <Udma_eventAllocResource+0x1a4> @ imm = #0x26
7009d62c: e7ff         	b	0x7009d62e <Udma_eventAllocResource+0x17e> @ imm = #-0x2
;             lastEvent = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
7009d62e: 9804         	ldr	r0, [sp, #0x10]
7009d630: 6900         	ldr	r0, [r0, #0x10]
7009d632: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009d634: e7ff         	b	0x7009d636 <Udma_eventAllocResource+0x186> @ imm = #-0x2
7009d636: 9803         	ldr	r0, [sp, #0xc]
7009d638: 6dc0         	ldr	r0, [r0, #0x5c]
7009d63a: b120         	cbz	r0, 0x7009d646 <Udma_eventAllocResource+0x196> @ imm = #0x8
7009d63c: e7ff         	b	0x7009d63e <Udma_eventAllocResource+0x18e> @ imm = #-0x2
;                 lastEvent = lastEvent->nextEvent;
7009d63e: 9803         	ldr	r0, [sp, #0xc]
7009d640: 6dc0         	ldr	r0, [r0, #0x5c]
7009d642: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009d644: e7f7         	b	0x7009d636 <Udma_eventAllocResource+0x186> @ imm = #-0x12
;             eventHandle->prevEvent = lastEvent;
7009d646: 9803         	ldr	r0, [sp, #0xc]
7009d648: 9908         	ldr	r1, [sp, #0x20]
7009d64a: 6608         	str	r0, [r1, #0x60]
;             lastEvent->nextEvent   = eventHandle;
7009d64c: 9808         	ldr	r0, [sp, #0x20]
7009d64e: 9903         	ldr	r1, [sp, #0xc]
7009d650: 65c8         	str	r0, [r1, #0x5c]
;         }
7009d652: e7ff         	b	0x7009d654 <Udma_eventAllocResource+0x1a4> @ imm = #-0x2
;         HwiP_restore(cookie);
7009d654: 9802         	ldr	r0, [sp, #0x8]
7009d656: f010 eebc    	blx	0x700ae3d0 <HwiP_restore> @ imm = #0x10d78
;     }
7009d65a: e7ff         	b	0x7009d65c <Udma_eventAllocResource+0x1ac> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d65c: 9807         	ldr	r0, [sp, #0x1c]
7009d65e: b9a0         	cbnz	r0, 0x7009d68a <Udma_eventAllocResource+0x1da> @ imm = #0x28
7009d660: e7ff         	b	0x7009d662 <Udma_eventAllocResource+0x1b2> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009d662: 9804         	ldr	r0, [sp, #0x10]
7009d664: 6800         	ldr	r0, [r0]
7009d666: 2803         	cmp	r0, #0x3
7009d668: d10e         	bne	0x7009d688 <Udma_eventAllocResource+0x1d8> @ imm = #0x1c
7009d66a: e7ff         	b	0x7009d66c <Udma_eventAllocResource+0x1bc> @ imm = #-0x2
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009d66c: 9804         	ldr	r0, [sp, #0x10]
7009d66e: 6880         	ldr	r0, [r0, #0x8]
7009d670: 9001         	str	r0, [sp, #0x4]
;             if(TRUE == chHandle->chOesAllocDone)
7009d672: 9801         	ldr	r0, [sp, #0x4]
7009d674: f8d0 0248    	ldr.w	r0, [r0, #0x248]
7009d678: 2801         	cmp	r0, #0x1
7009d67a: d104         	bne	0x7009d686 <Udma_eventAllocResource+0x1d6> @ imm = #0x8
7009d67c: e7ff         	b	0x7009d67e <Udma_eventAllocResource+0x1ce> @ imm = #-0x2
7009d67e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d682: 9007         	str	r0, [sp, #0x1c]
;             }
7009d684: e7ff         	b	0x7009d686 <Udma_eventAllocResource+0x1d6> @ imm = #-0x2
;         }
7009d686: e7ff         	b	0x7009d688 <Udma_eventAllocResource+0x1d8> @ imm = #-0x2
;     }
7009d688: e7ff         	b	0x7009d68a <Udma_eventAllocResource+0x1da> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009d68a: 9807         	ldr	r0, [sp, #0x1c]
7009d68c: b128         	cbz	r0, 0x7009d69a <Udma_eventAllocResource+0x1ea> @ imm = #0xa
7009d68e: e7ff         	b	0x7009d690 <Udma_eventAllocResource+0x1e0> @ imm = #-0x2
;         Udma_eventFreeResource(drvHandle, eventHandle);
7009d690: 9809         	ldr	r0, [sp, #0x24]
7009d692: 9908         	ldr	r1, [sp, #0x20]
7009d694: f006 fb4c    	bl	0x700a3d30 <Udma_eventFreeResource> @ imm = #0x6698
;     }
7009d698: e016         	b	0x7009d6c8 <Udma_eventAllocResource+0x218> @ imm = #0x2c
;         if(NULL_PTR == eventPrms->controllerEventHandle)
7009d69a: 9804         	ldr	r0, [sp, #0x10]
7009d69c: 6900         	ldr	r0, [r0, #0x10]
7009d69e: b920         	cbnz	r0, 0x7009d6aa <Udma_eventAllocResource+0x1fa> @ imm = #0x8
7009d6a0: e7ff         	b	0x7009d6a2 <Udma_eventAllocResource+0x1f2> @ imm = #-0x2
;             vintrNum = eventHandle->vintrNum;
7009d6a2: 9808         	ldr	r0, [sp, #0x20]
7009d6a4: 6cc0         	ldr	r0, [r0, #0x4c]
7009d6a6: 9006         	str	r0, [sp, #0x18]
;         }
7009d6a8: e004         	b	0x7009d6b4 <Udma_eventAllocResource+0x204> @ imm = #0x8
;             vintrNum = ((Udma_EventHandleInt) (eventPrms->controllerEventHandle))->vintrNum;
7009d6aa: 9804         	ldr	r0, [sp, #0x10]
7009d6ac: 6900         	ldr	r0, [r0, #0x10]
7009d6ae: 6cc0         	ldr	r0, [r0, #0x4c]
7009d6b0: 9006         	str	r0, [sp, #0x18]
7009d6b2: e7ff         	b	0x7009d6b4 <Udma_eventAllocResource+0x204> @ imm = #-0x2
;         eventHandle->pIaVintrRegs = &drvHandle->iaRegs.pIntrRegs->VINT[vintrNum];
7009d6b4: 9809         	ldr	r0, [sp, #0x24]
7009d6b6: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
7009d6ba: 9906         	ldr	r1, [sp, #0x18]
7009d6bc: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009d6c0: 9908         	ldr	r1, [sp, #0x20]
7009d6c2: f8c1 0094    	str.w	r0, [r1, #0x94]
7009d6c6: e7ff         	b	0x7009d6c8 <Udma_eventAllocResource+0x218> @ imm = #-0x2
;     return (retVal);
7009d6c8: 9807         	ldr	r0, [sp, #0x1c]
7009d6ca: b00a         	add	sp, #0x28
7009d6cc: bd80         	pop	{r7, pc}
7009d6ce: 0000         	movs	r0, r0

7009d6d0 <Udma_chFreeResource>:
; {
7009d6d0: b580         	push	{r7, lr}
7009d6d2: b084         	sub	sp, #0x10
7009d6d4: 9003         	str	r0, [sp, #0xc]
7009d6d6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d6d8: 9002         	str	r0, [sp, #0x8]
;     drvHandle = chHandle->drvHandle;
7009d6da: 9803         	ldr	r0, [sp, #0xc]
7009d6dc: 6e80         	ldr	r0, [r0, #0x68]
7009d6de: 9001         	str	r0, [sp, #0x4]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009d6e0: 9803         	ldr	r0, [sp, #0xc]
7009d6e2: 7800         	ldrb	r0, [r0]
7009d6e4: 0740         	lsls	r0, r0, #0x1d
7009d6e6: 2800         	cmp	r0, #0x0
7009d6e8: d52e         	bpl	0x7009d748 <Udma_chFreeResource+0x78> @ imm = #0x5c
7009d6ea: e7ff         	b	0x7009d6ec <Udma_chFreeResource+0x1c> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009d6ec: 9803         	ldr	r0, [sp, #0xc]
7009d6ee: 6ec0         	ldr	r0, [r0, #0x6c]
7009d6f0: f510 3f80    	cmn.w	r0, #0x10000
7009d6f4: d027         	beq	0x7009d746 <Udma_chFreeResource+0x76> @ imm = #0x4e
7009d6f6: e7ff         	b	0x7009d6f8 <Udma_chFreeResource+0x28> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009d6f8: 9803         	ldr	r0, [sp, #0xc]
7009d6fa: 7800         	ldrb	r0, [r0]
7009d6fc: 0640         	lsls	r0, r0, #0x19
7009d6fe: 2800         	cmp	r0, #0x0
7009d700: d506         	bpl	0x7009d710 <Udma_chFreeResource+0x40> @ imm = #0xc
7009d702: e7ff         	b	0x7009d704 <Udma_chFreeResource+0x34> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyHcCh(chHandle->txChNum, drvHandle);
7009d704: 9803         	ldr	r0, [sp, #0xc]
7009d706: 6ec0         	ldr	r0, [r0, #0x6c]
7009d708: 9901         	ldr	r1, [sp, #0x4]
7009d70a: f00c fbe9    	bl	0x700a9ee0 <Udma_rmFreeBlkCopyHcCh> @ imm = #0xc7d2
;             }
7009d70e: e012         	b	0x7009d736 <Udma_chFreeResource+0x66> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009d710: 9803         	ldr	r0, [sp, #0xc]
7009d712: 7800         	ldrb	r0, [r0]
7009d714: 0600         	lsls	r0, r0, #0x18
7009d716: 2800         	cmp	r0, #0x0
7009d718: d506         	bpl	0x7009d728 <Udma_chFreeResource+0x58> @ imm = #0xc
7009d71a: e7ff         	b	0x7009d71c <Udma_chFreeResource+0x4c> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyUhcCh(chHandle->txChNum, drvHandle);
7009d71c: 9803         	ldr	r0, [sp, #0xc]
7009d71e: 6ec0         	ldr	r0, [r0, #0x6c]
7009d720: 9901         	ldr	r1, [sp, #0x4]
7009d722: f00c fc15    	bl	0x700a9f50 <Udma_rmFreeBlkCopyUhcCh> @ imm = #0xc82a
;             }
7009d726: e005         	b	0x7009d734 <Udma_chFreeResource+0x64> @ imm = #0xa
;                 Udma_rmFreeBlkCopyCh(chHandle->txChNum, drvHandle);
7009d728: 9803         	ldr	r0, [sp, #0xc]
7009d72a: 6ec0         	ldr	r0, [r0, #0x6c]
7009d72c: 9901         	ldr	r1, [sp, #0x4]
7009d72e: f00c fb9f    	bl	0x700a9e70 <Udma_rmFreeBlkCopyCh> @ imm = #0xc73e
7009d732: e7ff         	b	0x7009d734 <Udma_chFreeResource+0x64> @ imm = #-0x2
7009d734: e7ff         	b	0x7009d736 <Udma_chFreeResource+0x66> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009d736: 9903         	ldr	r1, [sp, #0xc]
7009d738: 2000         	movs	r0, #0x0
7009d73a: f6cf 70ff    	movt	r0, #0xffff
7009d73e: 66c8         	str	r0, [r1, #0x6c]
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009d740: 9903         	ldr	r1, [sp, #0xc]
7009d742: 6708         	str	r0, [r1, #0x70]
;         }
7009d744: e7ff         	b	0x7009d746 <Udma_chFreeResource+0x76> @ imm = #-0x2
;     }
7009d746: e084         	b	0x7009d852 <Udma_chFreeResource+0x182> @ imm = #0x108
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009d748: 9803         	ldr	r0, [sp, #0xc]
7009d74a: 6ec0         	ldr	r0, [r0, #0x6c]
7009d74c: f510 3f80    	cmn.w	r0, #0x10000
7009d750: d032         	beq	0x7009d7b8 <Udma_chFreeResource+0xe8> @ imm = #0x64
7009d752: e7ff         	b	0x7009d754 <Udma_chFreeResource+0x84> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009d754: 9803         	ldr	r0, [sp, #0xc]
7009d756: 7800         	ldrb	r0, [r0]
7009d758: 0640         	lsls	r0, r0, #0x19
7009d75a: 2800         	cmp	r0, #0x0
7009d75c: d506         	bpl	0x7009d76c <Udma_chFreeResource+0x9c> @ imm = #0xc
7009d75e: e7ff         	b	0x7009d760 <Udma_chFreeResource+0x90> @ imm = #-0x2
;                 Udma_rmFreeTxHcCh(chHandle->txChNum, drvHandle);
7009d760: 9803         	ldr	r0, [sp, #0xc]
7009d762: 6ec0         	ldr	r0, [r0, #0x6c]
7009d764: 9901         	ldr	r1, [sp, #0x4]
7009d766: f00c fd0b    	bl	0x700aa180 <Udma_rmFreeTxHcCh> @ imm = #0xca16
;             }
7009d76a: e01f         	b	0x7009d7ac <Udma_chFreeResource+0xdc> @ imm = #0x3e
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009d76c: 9803         	ldr	r0, [sp, #0xc]
7009d76e: 7840         	ldrb	r0, [r0, #0x1]
7009d770: 07c0         	lsls	r0, r0, #0x1f
7009d772: b138         	cbz	r0, 0x7009d784 <Udma_chFreeResource+0xb4> @ imm = #0xe
7009d774: e7ff         	b	0x7009d776 <Udma_chFreeResource+0xa6> @ imm = #-0x2
;                 Udma_rmFreeMappedTxCh(chHandle->txChNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009d776: 9803         	ldr	r0, [sp, #0xc]
7009d778: 68c2         	ldr	r2, [r0, #0xc]
7009d77a: 6ec0         	ldr	r0, [r0, #0x6c]
7009d77c: 9901         	ldr	r1, [sp, #0x4]
7009d77e: f00b fe37    	bl	0x700a93f0 <Udma_rmFreeMappedTxCh> @ imm = #0xbc6e
;             }
7009d782: e012         	b	0x7009d7aa <Udma_chFreeResource+0xda> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009d784: 9803         	ldr	r0, [sp, #0xc]
7009d786: 7800         	ldrb	r0, [r0]
7009d788: 0600         	lsls	r0, r0, #0x18
7009d78a: 2800         	cmp	r0, #0x0
7009d78c: d506         	bpl	0x7009d79c <Udma_chFreeResource+0xcc> @ imm = #0xc
7009d78e: e7ff         	b	0x7009d790 <Udma_chFreeResource+0xc0> @ imm = #-0x2
;                 Udma_rmFreeTxUhcCh(chHandle->txChNum, drvHandle);
7009d790: 9803         	ldr	r0, [sp, #0xc]
7009d792: 6ec0         	ldr	r0, [r0, #0x6c]
7009d794: 9901         	ldr	r1, [sp, #0x4]
7009d796: f00c fd2b    	bl	0x700aa1f0 <Udma_rmFreeTxUhcCh> @ imm = #0xca56
;             }
7009d79a: e005         	b	0x7009d7a8 <Udma_chFreeResource+0xd8> @ imm = #0xa
;                 Udma_rmFreeTxCh(chHandle->txChNum, drvHandle);
7009d79c: 9803         	ldr	r0, [sp, #0xc]
7009d79e: 6ec0         	ldr	r0, [r0, #0x6c]
7009d7a0: 9901         	ldr	r1, [sp, #0x4]
7009d7a2: f00c fcb5    	bl	0x700aa110 <Udma_rmFreeTxCh> @ imm = #0xc96a
7009d7a6: e7ff         	b	0x7009d7a8 <Udma_chFreeResource+0xd8> @ imm = #-0x2
7009d7a8: e7ff         	b	0x7009d7aa <Udma_chFreeResource+0xda> @ imm = #-0x2
7009d7aa: e7ff         	b	0x7009d7ac <Udma_chFreeResource+0xdc> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009d7ac: 9903         	ldr	r1, [sp, #0xc]
7009d7ae: 2000         	movs	r0, #0x0
7009d7b0: f6cf 70ff    	movt	r0, #0xffff
7009d7b4: 66c8         	str	r0, [r1, #0x6c]
;         }
7009d7b6: e7ff         	b	0x7009d7b8 <Udma_chFreeResource+0xe8> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->rxChNum)
7009d7b8: 9803         	ldr	r0, [sp, #0xc]
7009d7ba: 6f00         	ldr	r0, [r0, #0x70]
7009d7bc: f510 3f80    	cmn.w	r0, #0x10000
7009d7c0: d033         	beq	0x7009d82a <Udma_chFreeResource+0x15a> @ imm = #0x66
7009d7c2: e7ff         	b	0x7009d7c4 <Udma_chFreeResource+0xf4> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009d7c4: 9803         	ldr	r0, [sp, #0xc]
7009d7c6: 7800         	ldrb	r0, [r0]
7009d7c8: 0640         	lsls	r0, r0, #0x19
7009d7ca: 2800         	cmp	r0, #0x0
7009d7cc: d506         	bpl	0x7009d7dc <Udma_chFreeResource+0x10c> @ imm = #0xc
7009d7ce: e7ff         	b	0x7009d7d0 <Udma_chFreeResource+0x100> @ imm = #-0x2
;                 Udma_rmFreeRxHcCh(chHandle->rxChNum, drvHandle);
7009d7d0: 9803         	ldr	r0, [sp, #0xc]
7009d7d2: 6f00         	ldr	r0, [r0, #0x70]
7009d7d4: 9901         	ldr	r1, [sp, #0x4]
7009d7d6: f00c fc2b    	bl	0x700aa030 <Udma_rmFreeRxHcCh> @ imm = #0xc856
;             }
7009d7da: e020         	b	0x7009d81e <Udma_chFreeResource+0x14e> @ imm = #0x40
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009d7dc: 9803         	ldr	r0, [sp, #0xc]
7009d7de: 7840         	ldrb	r0, [r0, #0x1]
7009d7e0: 07c0         	lsls	r0, r0, #0x1f
7009d7e2: b140         	cbz	r0, 0x7009d7f6 <Udma_chFreeResource+0x126> @ imm = #0x10
7009d7e4: e7ff         	b	0x7009d7e6 <Udma_chFreeResource+0x116> @ imm = #-0x2
;                 Udma_rmFreeMappedRxCh(chHandle->rxChNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009d7e6: 9803         	ldr	r0, [sp, #0xc]
7009d7e8: 68c2         	ldr	r2, [r0, #0xc]
7009d7ea: 6f00         	ldr	r0, [r0, #0x70]
7009d7ec: 9901         	ldr	r1, [sp, #0x4]
7009d7ee: 3a04         	subs	r2, #0x4
7009d7f0: f00b fdc6    	bl	0x700a9380 <Udma_rmFreeMappedRxCh> @ imm = #0xbb8c
;             }
7009d7f4: e012         	b	0x7009d81c <Udma_chFreeResource+0x14c> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009d7f6: 9803         	ldr	r0, [sp, #0xc]
7009d7f8: 7800         	ldrb	r0, [r0]
7009d7fa: 0600         	lsls	r0, r0, #0x18
7009d7fc: 2800         	cmp	r0, #0x0
7009d7fe: d506         	bpl	0x7009d80e <Udma_chFreeResource+0x13e> @ imm = #0xc
7009d800: e7ff         	b	0x7009d802 <Udma_chFreeResource+0x132> @ imm = #-0x2
;                 Udma_rmFreeRxUhcCh(chHandle->rxChNum, drvHandle);
7009d802: 9803         	ldr	r0, [sp, #0xc]
7009d804: 6f00         	ldr	r0, [r0, #0x70]
7009d806: 9901         	ldr	r1, [sp, #0x4]
7009d808: f00c fc4a    	bl	0x700aa0a0 <Udma_rmFreeRxUhcCh> @ imm = #0xc894
;             }
7009d80c: e005         	b	0x7009d81a <Udma_chFreeResource+0x14a> @ imm = #0xa
;                 Udma_rmFreeRxCh(chHandle->rxChNum, drvHandle);
7009d80e: 9803         	ldr	r0, [sp, #0xc]
7009d810: 6f00         	ldr	r0, [r0, #0x70]
7009d812: 9901         	ldr	r1, [sp, #0x4]
7009d814: f00c fbd4    	bl	0x700a9fc0 <Udma_rmFreeRxCh> @ imm = #0xc7a8
7009d818: e7ff         	b	0x7009d81a <Udma_chFreeResource+0x14a> @ imm = #-0x2
7009d81a: e7ff         	b	0x7009d81c <Udma_chFreeResource+0x14c> @ imm = #-0x2
7009d81c: e7ff         	b	0x7009d81e <Udma_chFreeResource+0x14e> @ imm = #-0x2
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009d81e: 9903         	ldr	r1, [sp, #0xc]
7009d820: 2000         	movs	r0, #0x0
7009d822: f6cf 70ff    	movt	r0, #0xffff
7009d826: 6708         	str	r0, [r1, #0x70]
;         }
7009d828: e7ff         	b	0x7009d82a <Udma_chFreeResource+0x15a> @ imm = #-0x2
;         chHandle->defaultFlowObj.drvHandle    = (Udma_DrvHandleInt) NULL_PTR;
7009d82a: 9903         	ldr	r1, [sp, #0xc]
7009d82c: 2000         	movs	r0, #0x0
7009d82e: f8c1 01cc    	str.w	r0, [r1, #0x1cc]
;         chHandle->defaultFlowObj.flowStart    = UDMA_FLOW_INVALID;
7009d832: 9a03         	ldr	r2, [sp, #0xc]
7009d834: 2100         	movs	r1, #0x0
7009d836: f6cf 71ff    	movt	r1, #0xffff
7009d83a: f8c2 11d0    	str.w	r1, [r2, #0x1d0]
;         chHandle->defaultFlowObj.flowCnt      = 0U;
7009d83e: 9903         	ldr	r1, [sp, #0xc]
7009d840: f8c1 01d4    	str.w	r0, [r1, #0x1d4]
;         chHandle->defaultFlowObj.flowInitDone = UDMA_DEINIT_DONE;
7009d844: 9903         	ldr	r1, [sp, #0xc]
7009d846: f8c1 01d8    	str.w	r0, [r1, #0x1d8]
;         chHandle->defaultFlow                 = (Udma_FlowHandleInt) NULL_PTR;
7009d84a: 9903         	ldr	r1, [sp, #0xc]
7009d84c: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
7009d850: e7ff         	b	0x7009d852 <Udma_chFreeResource+0x182> @ imm = #-0x2
;     chHandle->pdmaChNum = UDMA_DMA_CH_INVALID;
7009d852: 9903         	ldr	r1, [sp, #0xc]
7009d854: 2000         	movs	r0, #0x0
7009d856: f6cf 70ff    	movt	r0, #0xffff
7009d85a: 6788         	str	r0, [r1, #0x78]
;     chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009d85c: 9903         	ldr	r1, [sp, #0xc]
7009d85e: 2004         	movs	r0, #0x4
7009d860: f6cf 70ff    	movt	r0, #0xffff
7009d864: 67c8         	str	r0, [r1, #0x7c]
;     if(NULL_PTR != chHandle->fqRing)
7009d866: 9803         	ldr	r0, [sp, #0xc]
7009d868: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009d86c: b190         	cbz	r0, 0x7009d894 <Udma_chFreeResource+0x1c4> @ imm = #0x24
7009d86e: e7ff         	b	0x7009d870 <Udma_chFreeResource+0x1a0> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->fqRing);
7009d870: 9803         	ldr	r0, [sp, #0xc]
7009d872: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009d876: f007 fb63    	bl	0x700a4f40 <Udma_ringFree> @ imm = #0x76c6
7009d87a: 4601         	mov	r1, r0
7009d87c: 9802         	ldr	r0, [sp, #0x8]
7009d87e: 4408         	add	r0, r1
7009d880: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009d882: 9802         	ldr	r0, [sp, #0x8]
7009d884: b108         	cbz	r0, 0x7009d88a <Udma_chFreeResource+0x1ba> @ imm = #0x2
7009d886: e7ff         	b	0x7009d888 <Udma_chFreeResource+0x1b8> @ imm = #-0x2
;         }
7009d888: e7ff         	b	0x7009d88a <Udma_chFreeResource+0x1ba> @ imm = #-0x2
;         chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009d88a: 9903         	ldr	r1, [sp, #0xc]
7009d88c: 2000         	movs	r0, #0x0
7009d88e: f8c1 0080    	str.w	r0, [r1, #0x80]
;     }
7009d892: e7ff         	b	0x7009d894 <Udma_chFreeResource+0x1c4> @ imm = #-0x2
;     if(NULL_PTR != chHandle->cqRing)
7009d894: 9803         	ldr	r0, [sp, #0xc]
7009d896: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009d89a: b128         	cbz	r0, 0x7009d8a8 <Udma_chFreeResource+0x1d8> @ imm = #0xa
7009d89c: e7ff         	b	0x7009d89e <Udma_chFreeResource+0x1ce> @ imm = #-0x2
;         chHandle->cqRing = (Udma_RingHandleInt) NULL_PTR;
7009d89e: 9903         	ldr	r1, [sp, #0xc]
7009d8a0: 2000         	movs	r0, #0x0
7009d8a2: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009d8a6: e7ff         	b	0x7009d8a8 <Udma_chFreeResource+0x1d8> @ imm = #-0x2
;     if(NULL_PTR != chHandle->tdCqRing)
7009d8a8: 9803         	ldr	r0, [sp, #0xc]
7009d8aa: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009d8ae: b190         	cbz	r0, 0x7009d8d6 <Udma_chFreeResource+0x206> @ imm = #0x24
7009d8b0: e7ff         	b	0x7009d8b2 <Udma_chFreeResource+0x1e2> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->tdCqRing);
7009d8b2: 9803         	ldr	r0, [sp, #0xc]
7009d8b4: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009d8b8: f007 fb42    	bl	0x700a4f40 <Udma_ringFree> @ imm = #0x7684
7009d8bc: 4601         	mov	r1, r0
7009d8be: 9802         	ldr	r0, [sp, #0x8]
7009d8c0: 4408         	add	r0, r1
7009d8c2: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009d8c4: 9802         	ldr	r0, [sp, #0x8]
7009d8c6: b108         	cbz	r0, 0x7009d8cc <Udma_chFreeResource+0x1fc> @ imm = #0x2
7009d8c8: e7ff         	b	0x7009d8ca <Udma_chFreeResource+0x1fa> @ imm = #-0x2
;         }
7009d8ca: e7ff         	b	0x7009d8cc <Udma_chFreeResource+0x1fc> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009d8cc: 9903         	ldr	r1, [sp, #0xc]
7009d8ce: 2000         	movs	r0, #0x0
7009d8d0: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009d8d4: e7ff         	b	0x7009d8d6 <Udma_chFreeResource+0x206> @ imm = #-0x2
;     return (retVal);
7009d8d6: 9802         	ldr	r0, [sp, #0x8]
7009d8d8: b004         	add	sp, #0x10
7009d8da: bd80         	pop	{r7, pc}
7009d8dc: 0000         	movs	r0, r0
7009d8de: 0000         	movs	r0, r0

7009d8e0 <Udma_ringAlloc>:
; {
7009d8e0: b580         	push	{r7, lr}
7009d8e2: b096         	sub	sp, #0x58
7009d8e4: 9015         	str	r0, [sp, #0x54]
7009d8e6: 9114         	str	r1, [sp, #0x50]
7009d8e8: f8ad 204e    	strh.w	r2, [sp, #0x4e]
7009d8ec: 9312         	str	r3, [sp, #0x48]
7009d8ee: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d8f0: 9011         	str	r0, [sp, #0x44]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009d8f2: 900d         	str	r0, [sp, #0x34]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009d8f4: 9815         	ldr	r0, [sp, #0x54]
7009d8f6: 900c         	str	r0, [sp, #0x30]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
7009d8f8: 9814         	ldr	r0, [sp, #0x50]
7009d8fa: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == drvHandleInt) ||
7009d8fc: 980c         	ldr	r0, [sp, #0x30]
7009d8fe: b130         	cbz	r0, 0x7009d90e <Udma_ringAlloc+0x2e> @ imm = #0xc
7009d900: e7ff         	b	0x7009d902 <Udma_ringAlloc+0x22> @ imm = #-0x2
;        (NULL_PTR == ringHandleInt) ||
7009d902: 980b         	ldr	r0, [sp, #0x2c]
7009d904: b118         	cbz	r0, 0x7009d90e <Udma_ringAlloc+0x2e> @ imm = #0x6
7009d906: e7ff         	b	0x7009d908 <Udma_ringAlloc+0x28> @ imm = #-0x2
;        (NULL_PTR == ringPrms))
7009d908: 9812         	ldr	r0, [sp, #0x48]
;     if((NULL_PTR == drvHandleInt) ||
7009d90a: b920         	cbnz	r0, 0x7009d916 <Udma_ringAlloc+0x36> @ imm = #0x8
7009d90c: e7ff         	b	0x7009d90e <Udma_ringAlloc+0x2e> @ imm = #-0x2
7009d90e: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009d912: 9011         	str	r0, [sp, #0x44]
;     }
7009d914: e7ff         	b	0x7009d916 <Udma_ringAlloc+0x36> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d916: 9811         	ldr	r0, [sp, #0x44]
7009d918: b978         	cbnz	r0, 0x7009d93a <Udma_ringAlloc+0x5a> @ imm = #0x1e
7009d91a: e7ff         	b	0x7009d91c <Udma_ringAlloc+0x3c> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009d91c: 980c         	ldr	r0, [sp, #0x30]
7009d91e: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009d922: f64a 31cd    	movw	r1, #0xabcd
7009d926: f6ca 31dc    	movt	r1, #0xabdc
7009d92a: 4288         	cmp	r0, r1
7009d92c: d004         	beq	0x7009d938 <Udma_ringAlloc+0x58> @ imm = #0x8
7009d92e: e7ff         	b	0x7009d930 <Udma_ringAlloc+0x50> @ imm = #-0x2
7009d930: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009d934: 9011         	str	r0, [sp, #0x44]
;         }
7009d936: e7ff         	b	0x7009d938 <Udma_ringAlloc+0x58> @ imm = #-0x2
;     }
7009d938: e7ff         	b	0x7009d93a <Udma_ringAlloc+0x5a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d93a: 9811         	ldr	r0, [sp, #0x44]
7009d93c: b930         	cbnz	r0, 0x7009d94c <Udma_ringAlloc+0x6c> @ imm = #0xc
7009d93e: e7ff         	b	0x7009d940 <Udma_ringAlloc+0x60> @ imm = #-0x2
;         retVal = Udma_ringCheckParams(drvHandleInt, ringPrms);
7009d940: 980c         	ldr	r0, [sp, #0x30]
7009d942: 9912         	ldr	r1, [sp, #0x48]
7009d944: f007 f95c    	bl	0x700a4c00 <Udma_ringCheckParams> @ imm = #0x72b8
7009d948: 9011         	str	r0, [sp, #0x44]
;     }
7009d94a: e7ff         	b	0x7009d94c <Udma_ringAlloc+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d94c: 9811         	ldr	r0, [sp, #0x44]
7009d94e: 2800         	cmp	r0, #0x0
7009d950: d140         	bne	0x7009d9d4 <Udma_ringAlloc+0xf4> @ imm = #0x80
7009d952: e7ff         	b	0x7009d954 <Udma_ringAlloc+0x74> @ imm = #-0x2
;         if(UDMA_RING_ANY == ringNum)
7009d954: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009d958: f64f 71fe    	movw	r1, #0xfffe
7009d95c: 4288         	cmp	r0, r1
7009d95e: d126         	bne	0x7009d9ae <Udma_ringAlloc+0xce> @ imm = #0x4c
7009d960: e7ff         	b	0x7009d962 <Udma_ringAlloc+0x82> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009d962: 9812         	ldr	r0, [sp, #0x48]
7009d964: 6940         	ldr	r0, [r0, #0x14]
7009d966: 2104         	movs	r1, #0x4
7009d968: f6cf 71ff    	movt	r1, #0xffff
7009d96c: 4288         	cmp	r0, r1
7009d96e: d106         	bne	0x7009d97e <Udma_ringAlloc+0x9e> @ imm = #0xc
7009d970: e7ff         	b	0x7009d972 <Udma_ringAlloc+0x92> @ imm = #-0x2
;                 ringHandleInt->ringNum = Udma_rmAllocFreeRing(drvHandleInt);
7009d972: 980c         	ldr	r0, [sp, #0x30]
7009d974: f00f fd84    	bl	0x700ad480 <Udma_rmAllocFreeRing> @ imm = #0xfb08
7009d978: 990b         	ldr	r1, [sp, #0x2c]
7009d97a: 8088         	strh	r0, [r1, #0x4]
;             }
7009d97c: e008         	b	0x7009d990 <Udma_ringAlloc+0xb0> @ imm = #0x10
;                 ringHandleInt->ringNum = Udma_rmAllocMappedRing(drvHandleInt, ringPrms->mappedRingGrp, ringPrms->mappedChNum);
7009d97e: 980c         	ldr	r0, [sp, #0x30]
7009d980: 9a12         	ldr	r2, [sp, #0x48]
7009d982: 6951         	ldr	r1, [r2, #0x14]
7009d984: 6992         	ldr	r2, [r2, #0x18]
7009d986: f003 f833    	bl	0x700a09f0 <Udma_rmAllocMappedRing> @ imm = #0x3066
7009d98a: 990b         	ldr	r1, [sp, #0x2c]
7009d98c: 8088         	strh	r0, [r1, #0x4]
7009d98e: e7ff         	b	0x7009d990 <Udma_ringAlloc+0xb0> @ imm = #-0x2
;             if(UDMA_RING_INVALID == ringHandleInt->ringNum)
7009d990: 980b         	ldr	r0, [sp, #0x2c]
7009d992: 8880         	ldrh	r0, [r0, #0x4]
7009d994: f64f 71ff    	movw	r1, #0xffff
7009d998: 4288         	cmp	r0, r1
7009d99a: d104         	bne	0x7009d9a6 <Udma_ringAlloc+0xc6> @ imm = #0x8
7009d99c: e7ff         	b	0x7009d99e <Udma_ringAlloc+0xbe> @ imm = #-0x2
7009d99e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009d9a2: 9011         	str	r0, [sp, #0x44]
;             }
7009d9a4: e002         	b	0x7009d9ac <Udma_ringAlloc+0xcc> @ imm = #0x4
7009d9a6: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009d9a8: 900d         	str	r0, [sp, #0x34]
7009d9aa: e7ff         	b	0x7009d9ac <Udma_ringAlloc+0xcc> @ imm = #-0x2
;         }
7009d9ac: e011         	b	0x7009d9d2 <Udma_ringAlloc+0xf2> @ imm = #0x22
;             if(ringNum >= drvHandleInt->maxRings)
7009d9ae: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009d9b2: 990c         	ldr	r1, [sp, #0x30]
7009d9b4: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
7009d9b8: 4288         	cmp	r0, r1
7009d9ba: d304         	blo	0x7009d9c6 <Udma_ringAlloc+0xe6> @ imm = #0x8
7009d9bc: e7ff         	b	0x7009d9be <Udma_ringAlloc+0xde> @ imm = #-0x2
7009d9be: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
7009d9c2: 9011         	str	r0, [sp, #0x44]
;             }
7009d9c4: e004         	b	0x7009d9d0 <Udma_ringAlloc+0xf0> @ imm = #0x8
;                 ringHandleInt->ringNum = ringNum;
7009d9c6: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009d9ca: 990b         	ldr	r1, [sp, #0x2c]
7009d9cc: 8088         	strh	r0, [r1, #0x4]
7009d9ce: e7ff         	b	0x7009d9d0 <Udma_ringAlloc+0xf0> @ imm = #-0x2
7009d9d0: e7ff         	b	0x7009d9d2 <Udma_ringAlloc+0xf2> @ imm = #-0x2
;     }
7009d9d2: e7ff         	b	0x7009d9d4 <Udma_ringAlloc+0xf4> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d9d4: 9811         	ldr	r0, [sp, #0x44]
7009d9d6: b9a8         	cbnz	r0, 0x7009da04 <Udma_ringAlloc+0x124> @ imm = #0x2a
7009d9d8: e7ff         	b	0x7009d9da <Udma_ringAlloc+0xfa> @ imm = #-0x2
;         Udma_ringAssertFnPointers(drvHandleInt);
7009d9da: 980c         	ldr	r0, [sp, #0x30]
7009d9dc: f00f fee8    	bl	0x700ad7b0 <Udma_ringAssertFnPointers> @ imm = #0xfdd0
;         ringHandleInt->drvHandle = drvHandleInt;
7009d9e0: 980c         	ldr	r0, [sp, #0x30]
7009d9e2: 990b         	ldr	r1, [sp, #0x2c]
7009d9e4: 6008         	str	r0, [r1]
;         ringHandleInt->mappedRingGrp   = ringPrms->mappedRingGrp;
7009d9e6: 9812         	ldr	r0, [sp, #0x48]
7009d9e8: 6940         	ldr	r0, [r0, #0x14]
7009d9ea: 990b         	ldr	r1, [sp, #0x2c]
7009d9ec: 65c8         	str	r0, [r1, #0x5c]
;         ringHandleInt->mappedChNum     = ringPrms->mappedChNum;
7009d9ee: 9812         	ldr	r0, [sp, #0x48]
7009d9f0: 6980         	ldr	r0, [r0, #0x18]
7009d9f2: 990b         	ldr	r1, [sp, #0x2c]
7009d9f4: 6608         	str	r0, [r1, #0x60]
;         drvHandleInt->ringSetCfg(drvHandleInt, ringHandleInt, ringPrms);
7009d9f6: 980c         	ldr	r0, [sp, #0x30]
7009d9f8: f8d0 35c4    	ldr.w	r3, [r0, #0x5c4]
7009d9fc: 990b         	ldr	r1, [sp, #0x2c]
7009d9fe: 9a12         	ldr	r2, [sp, #0x48]
7009da00: 4798         	blx	r3
;     }
7009da02: e7ff         	b	0x7009da04 <Udma_ringAlloc+0x124> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009da04: 9811         	ldr	r0, [sp, #0x44]
7009da06: 2800         	cmp	r0, #0x0
7009da08: d146         	bne	0x7009da98 <Udma_ringAlloc+0x1b8> @ imm = #0x8c
7009da0a: e7ff         	b	0x7009da0c <Udma_ringAlloc+0x12c> @ imm = #-0x2
7009da0c: 20bf         	movs	r0, #0xbf
;         rmRingReq.valid_params  = TISCI_MSG_VALUE_RM_RING_ADDR_LO_VALID |
7009da0e: 9004         	str	r0, [sp, #0x10]
;         rmRingReq.nav_id        = drvHandleInt->devIdRing;
7009da10: 980c         	ldr	r0, [sp, #0x30]
7009da12: f8b0 00e0    	ldrh.w	r0, [r0, #0xe0]
7009da16: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmRingReq.index         = ringHandleInt->ringNum;
7009da1a: 980b         	ldr	r0, [sp, #0x2c]
7009da1c: 8880         	ldrh	r0, [r0, #0x4]
7009da1e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         physBase = Udma_virtToPhyFxn(ringPrms->ringMem, drvHandleInt, (Udma_ChHandleInt) NULL_PTR);
7009da22: 9812         	ldr	r0, [sp, #0x48]
7009da24: 6800         	ldr	r0, [r0]
7009da26: 990c         	ldr	r1, [sp, #0x30]
7009da28: 2200         	movs	r2, #0x0
7009da2a: f00c fc79    	bl	0x700aa320 <Udma_virtToPhyFxn> @ imm = #0xc8f2
7009da2e: 910f         	str	r1, [sp, #0x3c]
7009da30: 900e         	str	r0, [sp, #0x38]
;         rmRingReq.addr_lo       = (uint32_t)physBase;
7009da32: 980e         	ldr	r0, [sp, #0x38]
7009da34: 9006         	str	r0, [sp, #0x18]
;         rmRingReq.addr_hi       = (uint32_t)(physBase >> 32UL);
7009da36: 980f         	ldr	r0, [sp, #0x3c]
7009da38: 9007         	str	r0, [sp, #0x1c]
;         rmRingReq.count         = ringPrms->elemCnt;
7009da3a: 9812         	ldr	r0, [sp, #0x48]
7009da3c: 68c0         	ldr	r0, [r0, #0xc]
7009da3e: 9008         	str	r0, [sp, #0x20]
;         rmRingReq.mode          = ringPrms->mode;
7009da40: 9812         	ldr	r0, [sp, #0x48]
7009da42: 7a00         	ldrb	r0, [r0, #0x8]
7009da44: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmRingReq.size          = ringPrms->elemSize;
7009da48: 9812         	ldr	r0, [sp, #0x48]
7009da4a: 7c00         	ldrb	r0, [r0, #0x10]
7009da4c: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmRingReq.order_id      = ringPrms->orderId;
7009da50: 9812         	ldr	r0, [sp, #0x48]
7009da52: 7c40         	ldrb	r0, [r0, #0x11]
7009da54: f88d 0026    	strb.w	r0, [sp, #0x26]
;         rmRingReq.asel          = ringPrms->asel;
7009da58: 9812         	ldr	r0, [sp, #0x48]
7009da5a: 7c80         	ldrb	r0, [r0, #0x12]
7009da5c: f88d 0029    	strb.w	r0, [sp, #0x29]
;         if(UDMA_RING_VIRTID_INVALID != ringPrms->virtId)
7009da60: 9812         	ldr	r0, [sp, #0x48]
7009da62: 8940         	ldrh	r0, [r0, #0xa]
7009da64: f64f 71ff    	movw	r1, #0xffff
7009da68: 4288         	cmp	r0, r1
7009da6a: d009         	beq	0x7009da80 <Udma_ringAlloc+0x1a0> @ imm = #0x12
7009da6c: e7ff         	b	0x7009da6e <Udma_ringAlloc+0x18e> @ imm = #-0x2
;             rmRingReq.valid_params |= TISCI_MSG_VALUE_RM_RING_VIRTID_VALID;
7009da6e: 9804         	ldr	r0, [sp, #0x10]
7009da70: f040 0040    	orr	r0, r0, #0x40
7009da74: 9004         	str	r0, [sp, #0x10]
;             rmRingReq.virtid        = ringPrms->virtId;
7009da76: 9812         	ldr	r0, [sp, #0x48]
7009da78: 8940         	ldrh	r0, [r0, #0xa]
7009da7a: f8ad 0027    	strh.w	r0, [sp, #0x27]
;         }
7009da7e: e7ff         	b	0x7009da80 <Udma_ringAlloc+0x1a0> @ imm = #-0x2
7009da80: a802         	add	r0, sp, #0x8
7009da82: 4669         	mov	r1, sp
7009da84: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmRingCfg(
7009da88: f00c fe8a    	bl	0x700aa7a0 <Sciclient_rmRingCfg> @ imm = #0xcd14
7009da8c: 9011         	str	r0, [sp, #0x44]
;         if(CSL_PASS != retVal)
7009da8e: 9811         	ldr	r0, [sp, #0x44]
7009da90: b108         	cbz	r0, 0x7009da96 <Udma_ringAlloc+0x1b6> @ imm = #0x2
7009da92: e7ff         	b	0x7009da94 <Udma_ringAlloc+0x1b4> @ imm = #-0x2
;         }
7009da94: e7ff         	b	0x7009da96 <Udma_ringAlloc+0x1b6> @ imm = #-0x2
;     }
7009da96: e7ff         	b	0x7009da98 <Udma_ringAlloc+0x1b8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009da98: 9811         	ldr	r0, [sp, #0x44]
7009da9a: b938         	cbnz	r0, 0x7009daac <Udma_ringAlloc+0x1cc> @ imm = #0xe
7009da9c: e7ff         	b	0x7009da9e <Udma_ringAlloc+0x1be> @ imm = #-0x2
;         ringHandleInt->ringInitDone = UDMA_INIT_DONE;
7009da9e: 990b         	ldr	r1, [sp, #0x2c]
7009daa0: f64a 30cd    	movw	r0, #0xabcd
7009daa4: f6ca 30dc    	movt	r0, #0xabdc
7009daa8: 6588         	str	r0, [r1, #0x58]
;     }
7009daaa: e01b         	b	0x7009dae4 <Udma_ringAlloc+0x204> @ imm = #0x36
;         if(((uint32_t) TRUE) == allocDone)
7009daac: 980d         	ldr	r0, [sp, #0x34]
7009daae: 2801         	cmp	r0, #0x1
7009dab0: d117         	bne	0x7009dae2 <Udma_ringAlloc+0x202> @ imm = #0x2e
7009dab2: e7ff         	b	0x7009dab4 <Udma_ringAlloc+0x1d4> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009dab4: 9812         	ldr	r0, [sp, #0x48]
7009dab6: 6940         	ldr	r0, [r0, #0x14]
7009dab8: 2104         	movs	r1, #0x4
7009daba: f6cf 71ff    	movt	r1, #0xffff
7009dabe: 4288         	cmp	r0, r1
7009dac0: d106         	bne	0x7009dad0 <Udma_ringAlloc+0x1f0> @ imm = #0xc
7009dac2: e7ff         	b	0x7009dac4 <Udma_ringAlloc+0x1e4> @ imm = #-0x2
;                 Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandleInt);
7009dac4: 980b         	ldr	r0, [sp, #0x2c]
7009dac6: 8880         	ldrh	r0, [r0, #0x4]
7009dac8: 990c         	ldr	r1, [sp, #0x30]
7009daca: f00f fe41    	bl	0x700ad750 <Udma_rmFreeFreeRing> @ imm = #0xfc82
;             }
7009dace: e007         	b	0x7009dae0 <Udma_ringAlloc+0x200> @ imm = #0xe
;                 Udma_rmFreeMappedRing(ringHandleInt->ringNum, drvHandleInt, ringHandleInt->mappedRingGrp, ringHandleInt->mappedChNum);
7009dad0: 9b0b         	ldr	r3, [sp, #0x2c]
7009dad2: 8898         	ldrh	r0, [r3, #0x4]
7009dad4: 990c         	ldr	r1, [sp, #0x30]
7009dad6: 6dda         	ldr	r2, [r3, #0x5c]
7009dad8: 6e1b         	ldr	r3, [r3, #0x60]
7009dada: f00a f941    	bl	0x700a7d60 <Udma_rmFreeMappedRing> @ imm = #0xa282
7009dade: e7ff         	b	0x7009dae0 <Udma_ringAlloc+0x200> @ imm = #-0x2
;         }
7009dae0: e7ff         	b	0x7009dae2 <Udma_ringAlloc+0x202> @ imm = #-0x2
7009dae2: e7ff         	b	0x7009dae4 <Udma_ringAlloc+0x204> @ imm = #-0x2
;     return (retVal);
7009dae4: 9811         	ldr	r0, [sp, #0x44]
7009dae6: b016         	add	sp, #0x58
7009dae8: bd80         	pop	{r7, pc}
7009daea: 0000         	movs	r0, r0
7009daec: 0000         	movs	r0, r0
7009daee: 0000         	movs	r0, r0

7009daf0 <Udma_chDisableBlkCpyChan>:
; {
7009daf0: b580         	push	{r7, lr}
7009daf2: b090         	sub	sp, #0x40
7009daf4: 900f         	str	r0, [sp, #0x3c]
7009daf6: 910e         	str	r1, [sp, #0x38]
7009daf8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009dafa: 900d         	str	r0, [sp, #0x34]
;     uint32_t            currTimeout = 0U;
7009dafc: 900c         	str	r0, [sp, #0x30]
;     drvHandle = chHandle->drvHandle;
7009dafe: 980f         	ldr	r0, [sp, #0x3c]
7009db00: 6e80         	ldr	r0, [r0, #0x68]
7009db02: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009db04: 980b         	ldr	r0, [sp, #0x2c]
7009db06: 6800         	ldr	r0, [r0]
7009db08: 2801         	cmp	r0, #0x1
7009db0a: d10a         	bne	0x7009db22 <Udma_chDisableBlkCpyChan+0x32> @ imm = #0x14
7009db0c: e7ff         	b	0x7009db0e <Udma_chDisableBlkCpyChan+0x1e> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009db0e: 980b         	ldr	r0, [sp, #0x2c]
7009db10: 3008         	adds	r0, #0x8
7009db12: 990f         	ldr	r1, [sp, #0x3c]
7009db14: 6ec9         	ldr	r1, [r1, #0x6c]
7009db16: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009db18: 461a         	mov	r2, r3
7009db1a: f00d fcf1    	bl	0x700ab500 <CSL_bcdmaTeardownTxChan> @ imm = #0xd9e2
7009db1e: 900d         	str	r0, [sp, #0x34]
;     }
7009db20: e00f         	b	0x7009db42 <Udma_chDisableBlkCpyChan+0x52> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009db22: 980b         	ldr	r0, [sp, #0x2c]
7009db24: 6800         	ldr	r0, [r0]
7009db26: 2802         	cmp	r0, #0x2
7009db28: d10a         	bne	0x7009db40 <Udma_chDisableBlkCpyChan+0x50> @ imm = #0x14
7009db2a: e7ff         	b	0x7009db2c <Udma_chDisableBlkCpyChan+0x3c> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009db2c: 980b         	ldr	r0, [sp, #0x2c]
7009db2e: 3054         	adds	r0, #0x54
7009db30: 990f         	ldr	r1, [sp, #0x3c]
7009db32: 6ec9         	ldr	r1, [r1, #0x6c]
7009db34: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009db36: 461a         	mov	r2, r3
7009db38: f00e fb22    	bl	0x700ac180 <CSL_pktdmaTeardownTxChan> @ imm = #0xe644
7009db3c: 900d         	str	r0, [sp, #0x34]
;     }
7009db3e: e7ff         	b	0x7009db40 <Udma_chDisableBlkCpyChan+0x50> @ imm = #-0x2
7009db40: e7ff         	b	0x7009db42 <Udma_chDisableBlkCpyChan+0x52> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009db42: 980d         	ldr	r0, [sp, #0x34]
7009db44: b108         	cbz	r0, 0x7009db4a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #0x2
7009db46: e7ff         	b	0x7009db48 <Udma_chDisableBlkCpyChan+0x58> @ imm = #-0x2
;     }
7009db48: e7ff         	b	0x7009db4a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009db4a: e7ff         	b	0x7009db4c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x2
7009db4c: 980d         	ldr	r0, [sp, #0x34]
7009db4e: bba8         	cbnz	r0, 0x7009dbbc <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x6a
7009db50: e7ff         	b	0x7009db52 <Udma_chDisableBlkCpyChan+0x62> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009db52: 980b         	ldr	r0, [sp, #0x2c]
7009db54: 6800         	ldr	r0, [r0]
7009db56: 2801         	cmp	r0, #0x1
7009db58: d10c         	bne	0x7009db74 <Udma_chDisableBlkCpyChan+0x84> @ imm = #0x18
7009db5a: e7ff         	b	0x7009db5c <Udma_chDisableBlkCpyChan+0x6c> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009db5c: 980b         	ldr	r0, [sp, #0x2c]
7009db5e: 3008         	adds	r0, #0x8
7009db60: 990f         	ldr	r1, [sp, #0x3c]
7009db62: 6ec9         	ldr	r1, [r1, #0x6c]
7009db64: aa05         	add	r2, sp, #0x14
7009db66: f00e fdbb    	bl	0x700ac6e0 <CSL_bcdmaGetTxRT> @ imm = #0xeb76
;             if(FALSE == bcdmaRtStatus.enable)
7009db6a: 9805         	ldr	r0, [sp, #0x14]
7009db6c: b908         	cbnz	r0, 0x7009db72 <Udma_chDisableBlkCpyChan+0x82> @ imm = #0x2
7009db6e: e7ff         	b	0x7009db70 <Udma_chDisableBlkCpyChan+0x80> @ imm = #-0x2
;                 break;
7009db70: e024         	b	0x7009dbbc <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x48
;         }
7009db72: e011         	b	0x7009db98 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009db74: 980b         	ldr	r0, [sp, #0x2c]
7009db76: 6800         	ldr	r0, [r0]
7009db78: 2802         	cmp	r0, #0x2
7009db7a: d10c         	bne	0x7009db96 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #0x18
7009db7c: e7ff         	b	0x7009db7e <Udma_chDisableBlkCpyChan+0x8e> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009db7e: 980b         	ldr	r0, [sp, #0x2c]
7009db80: 3054         	adds	r0, #0x54
7009db82: 990f         	ldr	r1, [sp, #0x3c]
7009db84: 6ec9         	ldr	r1, [r1, #0x6c]
7009db86: 466a         	mov	r2, sp
7009db88: f00d fb2a    	bl	0x700ab1e0 <CSL_pktdmaGetTxRT> @ imm = #0xd654
;             if(FALSE == pktdmaRtStatus.enable)
7009db8c: 9800         	ldr	r0, [sp]
7009db8e: b908         	cbnz	r0, 0x7009db94 <Udma_chDisableBlkCpyChan+0xa4> @ imm = #0x2
7009db90: e7ff         	b	0x7009db92 <Udma_chDisableBlkCpyChan+0xa2> @ imm = #-0x2
;                 break;
7009db92: e013         	b	0x7009dbbc <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x26
;         }
7009db94: e7ff         	b	0x7009db96 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #-0x2
7009db96: e7ff         	b	0x7009db98 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #-0x2
;         if(currTimeout > timeout)
7009db98: 980c         	ldr	r0, [sp, #0x30]
7009db9a: 990e         	ldr	r1, [sp, #0x38]
7009db9c: 4288         	cmp	r0, r1
7009db9e: d904         	bls	0x7009dbaa <Udma_chDisableBlkCpyChan+0xba> @ imm = #0x8
7009dba0: e7ff         	b	0x7009dba2 <Udma_chDisableBlkCpyChan+0xb2> @ imm = #-0x2
7009dba2: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009dba6: 900d         	str	r0, [sp, #0x34]
;         }
7009dba8: e007         	b	0x7009dbba <Udma_chDisableBlkCpyChan+0xca> @ imm = #0xe
7009dbaa: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009dbae: f00b f9f7    	bl	0x700a8fa0 <ClockP_usleep> @ imm = #0xb3ee
;             currTimeout++;
7009dbb2: 980c         	ldr	r0, [sp, #0x30]
7009dbb4: 3001         	adds	r0, #0x1
7009dbb6: 900c         	str	r0, [sp, #0x30]
7009dbb8: e7ff         	b	0x7009dbba <Udma_chDisableBlkCpyChan+0xca> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009dbba: e7c7         	b	0x7009db4c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x72
;     if(UDMA_SOK != retVal)
7009dbbc: 980d         	ldr	r0, [sp, #0x34]
7009dbbe: 2800         	cmp	r0, #0x0
7009dbc0: d05f         	beq	0x7009dc82 <Udma_chDisableBlkCpyChan+0x192> @ imm = #0xbe
7009dbc2: e7ff         	b	0x7009dbc4 <Udma_chDisableBlkCpyChan+0xd4> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009dbc4: 980b         	ldr	r0, [sp, #0x2c]
7009dbc6: 6800         	ldr	r0, [r0]
7009dbc8: 2801         	cmp	r0, #0x1
7009dbca: d10a         	bne	0x7009dbe2 <Udma_chDisableBlkCpyChan+0xf2> @ imm = #0x14
7009dbcc: e7ff         	b	0x7009dbce <Udma_chDisableBlkCpyChan+0xde> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009dbce: 980b         	ldr	r0, [sp, #0x2c]
7009dbd0: 3008         	adds	r0, #0x8
7009dbd2: 990f         	ldr	r1, [sp, #0x3c]
7009dbd4: 6ec9         	ldr	r1, [r1, #0x6c]
7009dbd6: 2201         	movs	r2, #0x1
7009dbd8: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009dbda: f00d fc91    	bl	0x700ab500 <CSL_bcdmaTeardownTxChan> @ imm = #0xd922
7009dbde: 900d         	str	r0, [sp, #0x34]
;         }
7009dbe0: e00f         	b	0x7009dc02 <Udma_chDisableBlkCpyChan+0x112> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009dbe2: 980b         	ldr	r0, [sp, #0x2c]
7009dbe4: 6800         	ldr	r0, [r0]
7009dbe6: 2802         	cmp	r0, #0x2
7009dbe8: d10a         	bne	0x7009dc00 <Udma_chDisableBlkCpyChan+0x110> @ imm = #0x14
7009dbea: e7ff         	b	0x7009dbec <Udma_chDisableBlkCpyChan+0xfc> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009dbec: 980b         	ldr	r0, [sp, #0x2c]
7009dbee: 3054         	adds	r0, #0x54
7009dbf0: 990f         	ldr	r1, [sp, #0x3c]
7009dbf2: 6ec9         	ldr	r1, [r1, #0x6c]
7009dbf4: 2201         	movs	r2, #0x1
7009dbf6: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009dbf8: f00e fac2    	bl	0x700ac180 <CSL_pktdmaTeardownTxChan> @ imm = #0xe584
7009dbfc: 900d         	str	r0, [sp, #0x34]
;         }
7009dbfe: e7ff         	b	0x7009dc00 <Udma_chDisableBlkCpyChan+0x110> @ imm = #-0x2
7009dc00: e7ff         	b	0x7009dc02 <Udma_chDisableBlkCpyChan+0x112> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009dc02: 980d         	ldr	r0, [sp, #0x34]
7009dc04: b108         	cbz	r0, 0x7009dc0a <Udma_chDisableBlkCpyChan+0x11a> @ imm = #0x2
7009dc06: e7ff         	b	0x7009dc08 <Udma_chDisableBlkCpyChan+0x118> @ imm = #-0x2
;         }
7009dc08: e7ff         	b	0x7009dc0a <Udma_chDisableBlkCpyChan+0x11a> @ imm = #-0x2
7009dc0a: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009dc0c: 900c         	str	r0, [sp, #0x30]
;         while(UDMA_SOK == retVal)
7009dc0e: e7ff         	b	0x7009dc10 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x2
7009dc10: 980d         	ldr	r0, [sp, #0x34]
7009dc12: bba8         	cbnz	r0, 0x7009dc80 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x6a
7009dc14: e7ff         	b	0x7009dc16 <Udma_chDisableBlkCpyChan+0x126> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009dc16: 980b         	ldr	r0, [sp, #0x2c]
7009dc18: 6800         	ldr	r0, [r0]
7009dc1a: 2801         	cmp	r0, #0x1
7009dc1c: d10c         	bne	0x7009dc38 <Udma_chDisableBlkCpyChan+0x148> @ imm = #0x18
7009dc1e: e7ff         	b	0x7009dc20 <Udma_chDisableBlkCpyChan+0x130> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009dc20: 980b         	ldr	r0, [sp, #0x2c]
7009dc22: 3008         	adds	r0, #0x8
7009dc24: 990f         	ldr	r1, [sp, #0x3c]
7009dc26: 6ec9         	ldr	r1, [r1, #0x6c]
7009dc28: aa05         	add	r2, sp, #0x14
7009dc2a: f00e fd59    	bl	0x700ac6e0 <CSL_bcdmaGetTxRT> @ imm = #0xeab2
;                 if(FALSE == bcdmaRtStatus.enable)
7009dc2e: 9805         	ldr	r0, [sp, #0x14]
7009dc30: b908         	cbnz	r0, 0x7009dc36 <Udma_chDisableBlkCpyChan+0x146> @ imm = #0x2
7009dc32: e7ff         	b	0x7009dc34 <Udma_chDisableBlkCpyChan+0x144> @ imm = #-0x2
;                     break;
7009dc34: e024         	b	0x7009dc80 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x48
;             }
7009dc36: e011         	b	0x7009dc5c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #0x22
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009dc38: 980b         	ldr	r0, [sp, #0x2c]
7009dc3a: 6800         	ldr	r0, [r0]
7009dc3c: 2802         	cmp	r0, #0x2
7009dc3e: d10c         	bne	0x7009dc5a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #0x18
7009dc40: e7ff         	b	0x7009dc42 <Udma_chDisableBlkCpyChan+0x152> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009dc42: 980b         	ldr	r0, [sp, #0x2c]
7009dc44: 3054         	adds	r0, #0x54
7009dc46: 990f         	ldr	r1, [sp, #0x3c]
7009dc48: 6ec9         	ldr	r1, [r1, #0x6c]
7009dc4a: 466a         	mov	r2, sp
7009dc4c: f00d fac8    	bl	0x700ab1e0 <CSL_pktdmaGetTxRT> @ imm = #0xd590
;                 if(FALSE == pktdmaRtStatus.enable)
7009dc50: 9800         	ldr	r0, [sp]
7009dc52: b908         	cbnz	r0, 0x7009dc58 <Udma_chDisableBlkCpyChan+0x168> @ imm = #0x2
7009dc54: e7ff         	b	0x7009dc56 <Udma_chDisableBlkCpyChan+0x166> @ imm = #-0x2
;                     break;
7009dc56: e013         	b	0x7009dc80 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x26
;             }
7009dc58: e7ff         	b	0x7009dc5a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #-0x2
7009dc5a: e7ff         	b	0x7009dc5c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009dc5c: 980c         	ldr	r0, [sp, #0x30]
7009dc5e: 990e         	ldr	r1, [sp, #0x38]
7009dc60: 4288         	cmp	r0, r1
7009dc62: d904         	bls	0x7009dc6e <Udma_chDisableBlkCpyChan+0x17e> @ imm = #0x8
7009dc64: e7ff         	b	0x7009dc66 <Udma_chDisableBlkCpyChan+0x176> @ imm = #-0x2
7009dc66: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009dc6a: 900d         	str	r0, [sp, #0x34]
;             }
7009dc6c: e007         	b	0x7009dc7e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #0xe
7009dc6e: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009dc72: f00b f995    	bl	0x700a8fa0 <ClockP_usleep> @ imm = #0xb32a
;                 currTimeout++;
7009dc76: 980c         	ldr	r0, [sp, #0x30]
7009dc78: 3001         	adds	r0, #0x1
7009dc7a: 900c         	str	r0, [sp, #0x30]
7009dc7c: e7ff         	b	0x7009dc7e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009dc7e: e7c7         	b	0x7009dc10 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x72
;     }
7009dc80: e7ff         	b	0x7009dc82 <Udma_chDisableBlkCpyChan+0x192> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dc82: 980d         	ldr	r0, [sp, #0x34]
7009dc84: bb20         	cbnz	r0, 0x7009dcd0 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #0x48
7009dc86: e7ff         	b	0x7009dc88 <Udma_chDisableBlkCpyChan+0x198> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009dc88: 980b         	ldr	r0, [sp, #0x2c]
7009dc8a: 6800         	ldr	r0, [r0]
7009dc8c: 2801         	cmp	r0, #0x1
7009dc8e: d10c         	bne	0x7009dcaa <Udma_chDisableBlkCpyChan+0x1ba> @ imm = #0x18
7009dc90: e7ff         	b	0x7009dc92 <Udma_chDisableBlkCpyChan+0x1a2> @ imm = #-0x2
7009dc92: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009dc94: 9005         	str	r0, [sp, #0x14]
;             bcdmaRtStatus.teardown = FALSE;
7009dc96: 9006         	str	r0, [sp, #0x18]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009dc98: 9009         	str	r0, [sp, #0x24]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009dc9a: 980b         	ldr	r0, [sp, #0x2c]
7009dc9c: 3008         	adds	r0, #0x8
7009dc9e: 990f         	ldr	r1, [sp, #0x3c]
7009dca0: 6ec9         	ldr	r1, [r1, #0x6c]
7009dca2: aa05         	add	r2, sp, #0x14
7009dca4: f00e fd4c    	bl	0x700ac740 <CSL_bcdmaSetTxRT> @ imm = #0xea98
;         }
7009dca8: e011         	b	0x7009dcce <Udma_chDisableBlkCpyChan+0x1de> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009dcaa: 980b         	ldr	r0, [sp, #0x2c]
7009dcac: 6800         	ldr	r0, [r0]
7009dcae: 2802         	cmp	r0, #0x2
7009dcb0: d10c         	bne	0x7009dccc <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #0x18
7009dcb2: e7ff         	b	0x7009dcb4 <Udma_chDisableBlkCpyChan+0x1c4> @ imm = #-0x2
7009dcb4: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009dcb6: 9000         	str	r0, [sp]
;             pktdmaRtStatus.teardown = FALSE;
7009dcb8: 9001         	str	r0, [sp, #0x4]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009dcba: 9004         	str	r0, [sp, #0x10]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009dcbc: 980b         	ldr	r0, [sp, #0x2c]
7009dcbe: 3054         	adds	r0, #0x54
7009dcc0: 990f         	ldr	r1, [sp, #0x3c]
7009dcc2: 6ec9         	ldr	r1, [r1, #0x6c]
7009dcc4: 466a         	mov	r2, sp
7009dcc6: f00d fffb    	bl	0x700abcc0 <CSL_pktdmaSetTxRT> @ imm = #0xdff6
;         }
7009dcca: e7ff         	b	0x7009dccc <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #-0x2
7009dccc: e7ff         	b	0x7009dcce <Udma_chDisableBlkCpyChan+0x1de> @ imm = #-0x2
;     }
7009dcce: e7ff         	b	0x7009dcd0 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #-0x2
;     return (retVal);
7009dcd0: 980d         	ldr	r0, [sp, #0x34]
7009dcd2: b010         	add	sp, #0x40
7009dcd4: bd80         	pop	{r7, pc}
		...
7009dcde: 0000         	movs	r0, r0

7009dce0 <Udma_flowConfig>:
; {
7009dce0: b580         	push	{r7, lr}
7009dce2: b09e         	sub	sp, #0x78
7009dce4: 901d         	str	r0, [sp, #0x74]
7009dce6: 911c         	str	r1, [sp, #0x70]
7009dce8: 921b         	str	r2, [sp, #0x6c]
7009dcea: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009dcec: 901a         	str	r0, [sp, #0x68]
;     Udma_FlowHandleInt  flowHandleInt = (Udma_FlowHandleInt) flowHandle;
7009dcee: 981d         	ldr	r0, [sp, #0x74]
7009dcf0: 9018         	str	r0, [sp, #0x60]
;     if((NULL_PTR == flowHandleInt) ||
7009dcf2: 9818         	ldr	r0, [sp, #0x60]
7009dcf4: b160         	cbz	r0, 0x7009dd10 <Udma_flowConfig+0x30> @ imm = #0x18
7009dcf6: e7ff         	b	0x7009dcf8 <Udma_flowConfig+0x18> @ imm = #-0x2
;        (flowHandleInt->flowInitDone != UDMA_INIT_DONE) ||
7009dcf8: 9818         	ldr	r0, [sp, #0x60]
7009dcfa: 68c0         	ldr	r0, [r0, #0xc]
7009dcfc: f64a 31cd    	movw	r1, #0xabcd
7009dd00: f6ca 31dc    	movt	r1, #0xabdc
7009dd04: 4288         	cmp	r0, r1
7009dd06: d103         	bne	0x7009dd10 <Udma_flowConfig+0x30> @ imm = #0x6
7009dd08: e7ff         	b	0x7009dd0a <Udma_flowConfig+0x2a> @ imm = #-0x2
;        (NULL_PTR == flowPrms))
7009dd0a: 981b         	ldr	r0, [sp, #0x6c]
;     if((NULL_PTR == flowHandleInt) ||
7009dd0c: b920         	cbnz	r0, 0x7009dd18 <Udma_flowConfig+0x38> @ imm = #0x8
7009dd0e: e7ff         	b	0x7009dd10 <Udma_flowConfig+0x30> @ imm = #-0x2
7009dd10: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009dd14: 901a         	str	r0, [sp, #0x68]
;     }
7009dd16: e7ff         	b	0x7009dd18 <Udma_flowConfig+0x38> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dd18: 981a         	ldr	r0, [sp, #0x68]
7009dd1a: b9a8         	cbnz	r0, 0x7009dd48 <Udma_flowConfig+0x68> @ imm = #0x2a
7009dd1c: e7ff         	b	0x7009dd1e <Udma_flowConfig+0x3e> @ imm = #-0x2
;         drvHandle = flowHandleInt->drvHandle;
7009dd1e: 9818         	ldr	r0, [sp, #0x60]
7009dd20: 6800         	ldr	r0, [r0]
7009dd22: 9019         	str	r0, [sp, #0x64]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009dd24: 9819         	ldr	r0, [sp, #0x64]
7009dd26: b150         	cbz	r0, 0x7009dd3e <Udma_flowConfig+0x5e> @ imm = #0x14
7009dd28: e7ff         	b	0x7009dd2a <Udma_flowConfig+0x4a> @ imm = #-0x2
7009dd2a: 9819         	ldr	r0, [sp, #0x64]
7009dd2c: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009dd30: f64a 31cd    	movw	r1, #0xabcd
7009dd34: f6ca 31dc    	movt	r1, #0xabdc
7009dd38: 4288         	cmp	r0, r1
7009dd3a: d004         	beq	0x7009dd46 <Udma_flowConfig+0x66> @ imm = #0x8
7009dd3c: e7ff         	b	0x7009dd3e <Udma_flowConfig+0x5e> @ imm = #-0x2
7009dd3e: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009dd42: 901a         	str	r0, [sp, #0x68]
;         }
7009dd44: e7ff         	b	0x7009dd46 <Udma_flowConfig+0x66> @ imm = #-0x2
;     }
7009dd46: e7ff         	b	0x7009dd48 <Udma_flowConfig+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dd48: 981a         	ldr	r0, [sp, #0x68]
7009dd4a: b958         	cbnz	r0, 0x7009dd64 <Udma_flowConfig+0x84> @ imm = #0x16
7009dd4c: e7ff         	b	0x7009dd4e <Udma_flowConfig+0x6e> @ imm = #-0x2
;         if(flowIdx >= flowHandleInt->flowCnt)
7009dd4e: 981c         	ldr	r0, [sp, #0x70]
7009dd50: 9918         	ldr	r1, [sp, #0x60]
7009dd52: 6889         	ldr	r1, [r1, #0x8]
7009dd54: 4288         	cmp	r0, r1
7009dd56: d304         	blo	0x7009dd62 <Udma_flowConfig+0x82> @ imm = #0x8
7009dd58: e7ff         	b	0x7009dd5a <Udma_flowConfig+0x7a> @ imm = #-0x2
7009dd5a: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
7009dd5e: 901a         	str	r0, [sp, #0x68]
;         }
7009dd60: e7ff         	b	0x7009dd62 <Udma_flowConfig+0x82> @ imm = #-0x2
;     }
7009dd62: e7ff         	b	0x7009dd64 <Udma_flowConfig+0x84> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dd64: 981a         	ldr	r0, [sp, #0x68]
7009dd66: 2800         	cmp	r0, #0x0
7009dd68: f040 80a3    	bne.w	0x7009deb2 <Udma_flowConfig+0x1d2> @ imm = #0x146
7009dd6c: e7ff         	b	0x7009dd6e <Udma_flowConfig+0x8e> @ imm = #-0x2
7009dd6e: f64f 70ff    	movw	r0, #0xffff
7009dd72: f2c0 0007    	movt	r0, #0x7
;         rmFlowReq.valid_params          = TISCI_MSG_VALUE_RM_UDMAP_FLOW_EINFO_PRESENT_VALID |
7009dd76: 900f         	str	r0, [sp, #0x3c]
;         rmFlowReq.nav_id                = drvHandle->devIdUdma;
7009dd78: 9819         	ldr	r0, [sp, #0x64]
7009dd7a: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009dd7e: f8ad 0040    	strh.w	r0, [sp, #0x40]
;         rmFlowReq.flow_index            = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009dd82: 9818         	ldr	r0, [sp, #0x60]
7009dd84: 6840         	ldr	r0, [r0, #0x4]
7009dd86: 991c         	ldr	r1, [sp, #0x70]
7009dd88: 4408         	add	r0, r1
7009dd8a: f8ad 0042    	strh.w	r0, [sp, #0x42]
;         rmFlowReq.rx_einfo_present      = flowPrms->einfoPresent;
7009dd8e: 981b         	ldr	r0, [sp, #0x6c]
7009dd90: 7900         	ldrb	r0, [r0, #0x4]
7009dd92: f88d 0044    	strb.w	r0, [sp, #0x44]
;         rmFlowReq.rx_psinfo_present     = flowPrms->psInfoPresent;
7009dd96: 981b         	ldr	r0, [sp, #0x6c]
7009dd98: 7940         	ldrb	r0, [r0, #0x5]
7009dd9a: f88d 0045    	strb.w	r0, [sp, #0x45]
;         rmFlowReq.rx_error_handling     = flowPrms->errorHandling;
7009dd9e: 981b         	ldr	r0, [sp, #0x6c]
7009dda0: 7980         	ldrb	r0, [r0, #0x6]
7009dda2: f88d 0046    	strb.w	r0, [sp, #0x46]
;         rmFlowReq.rx_desc_type          = flowPrms->descType;
7009dda6: 981b         	ldr	r0, [sp, #0x6c]
7009dda8: 79c0         	ldrb	r0, [r0, #0x7]
7009ddaa: f88d 0047    	strb.w	r0, [sp, #0x47]
;         rmFlowReq.rx_ps_location        = flowPrms->psLocation;
7009ddae: 981b         	ldr	r0, [sp, #0x6c]
7009ddb0: 7a00         	ldrb	r0, [r0, #0x8]
7009ddb2: f88d 005c    	strb.w	r0, [sp, #0x5c]
;         rmFlowReq.rx_sop_offset         = flowPrms->sopOffset;
7009ddb6: 981b         	ldr	r0, [sp, #0x6c]
7009ddb8: 8940         	ldrh	r0, [r0, #0xa]
7009ddba: f8ad 0048    	strh.w	r0, [sp, #0x48]
;         rmFlowReq.rx_dest_qnum          = flowPrms->defaultRxCQ;
7009ddbe: 981b         	ldr	r0, [sp, #0x6c]
7009ddc0: 8980         	ldrh	r0, [r0, #0xc]
7009ddc2: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;         rmFlowReq.rx_src_tag_hi         = flowPrms->srcTagHi;
7009ddc6: 981b         	ldr	r0, [sp, #0x6c]
7009ddc8: 7b80         	ldrb	r0, [r0, #0xe]
7009ddca: f88d 004c    	strb.w	r0, [sp, #0x4c]
;         rmFlowReq.rx_src_tag_lo         = flowPrms->srcTagLo;
7009ddce: 981b         	ldr	r0, [sp, #0x6c]
7009ddd0: 7bc0         	ldrb	r0, [r0, #0xf]
7009ddd2: f88d 004d    	strb.w	r0, [sp, #0x4d]
;         rmFlowReq.rx_src_tag_hi_sel     = flowPrms->srcTagHiSel;
7009ddd6: 981b         	ldr	r0, [sp, #0x6c]
7009ddd8: 7c00         	ldrb	r0, [r0, #0x10]
7009ddda: f88d 0050    	strb.w	r0, [sp, #0x50]
;         rmFlowReq.rx_src_tag_lo_sel     = flowPrms->srcTagLoSel;
7009ddde: 981b         	ldr	r0, [sp, #0x6c]
7009dde0: 7c40         	ldrb	r0, [r0, #0x11]
7009dde2: f88d 0051    	strb.w	r0, [sp, #0x51]
;         rmFlowReq.rx_dest_tag_hi        = flowPrms->destTagHi;
7009dde6: 981b         	ldr	r0, [sp, #0x6c]
7009dde8: 7c80         	ldrb	r0, [r0, #0x12]
7009ddea: f88d 004e    	strb.w	r0, [sp, #0x4e]
;         rmFlowReq.rx_dest_tag_lo        = flowPrms->destTagLo;
7009ddee: 981b         	ldr	r0, [sp, #0x6c]
7009ddf0: 7cc0         	ldrb	r0, [r0, #0x13]
7009ddf2: f88d 004f    	strb.w	r0, [sp, #0x4f]
;         rmFlowReq.rx_dest_tag_hi_sel    = flowPrms->destTagHiSel;
7009ddf6: 981b         	ldr	r0, [sp, #0x6c]
7009ddf8: 7d00         	ldrb	r0, [r0, #0x14]
7009ddfa: f88d 0052    	strb.w	r0, [sp, #0x52]
;         rmFlowReq.rx_dest_tag_lo_sel    = flowPrms->destTagLoSel;
7009ddfe: 981b         	ldr	r0, [sp, #0x6c]
7009de00: 7d40         	ldrb	r0, [r0, #0x15]
7009de02: f88d 0053    	strb.w	r0, [sp, #0x53]
;         rmFlowReq.rx_fdq0_sz0_qnum      = flowPrms->fdq0Sz0Qnum;
7009de06: 981b         	ldr	r0, [sp, #0x6c]
7009de08: 8b00         	ldrh	r0, [r0, #0x18]
7009de0a: f8ad 0054    	strh.w	r0, [sp, #0x54]
;         rmFlowReq.rx_fdq1_qnum          = flowPrms->fdq1Qnum;
7009de0e: 981b         	ldr	r0, [sp, #0x6c]
7009de10: 8b40         	ldrh	r0, [r0, #0x1a]
7009de12: f8ad 0056    	strh.w	r0, [sp, #0x56]
;         rmFlowReq.rx_fdq2_qnum          = flowPrms->fdq2Qnum;
7009de16: 981b         	ldr	r0, [sp, #0x6c]
7009de18: 8b80         	ldrh	r0, [r0, #0x1c]
7009de1a: f8ad 0058    	strh.w	r0, [sp, #0x58]
;         rmFlowReq.rx_fdq3_qnum          = flowPrms->fdq3Qnum;
7009de1e: 981b         	ldr	r0, [sp, #0x6c]
7009de20: 8bc0         	ldrh	r0, [r0, #0x1e]
7009de22: f8ad 005a    	strh.w	r0, [sp, #0x5a]
7009de26: a80d         	add	r0, sp, #0x34
7009de28: a90b         	add	r1, sp, #0x2c
7009de2a: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapFlowCfg(
7009de2e: f00c fce7    	bl	0x700aa800 <Sciclient_rmUdmapFlowCfg> @ imm = #0xc9ce
7009de32: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009de34: 981a         	ldr	r0, [sp, #0x68]
7009de36: b108         	cbz	r0, 0x7009de3c <Udma_flowConfig+0x15c> @ imm = #0x2
7009de38: e7ff         	b	0x7009de3a <Udma_flowConfig+0x15a> @ imm = #-0x2
;         }
7009de3a: e7ff         	b	0x7009de3c <Udma_flowConfig+0x15c> @ imm = #-0x2
7009de3c: 207f         	movs	r0, #0x7f
;         rmOptFlowReq.valid_params       = TISCI_MSG_VALUE_RM_UDMAP_FLOW_SIZE_THRESH0_VALID |
7009de3e: 9005         	str	r0, [sp, #0x14]
;         rmOptFlowReq.nav_id             = drvHandle->devIdUdma;
7009de40: 9819         	ldr	r0, [sp, #0x64]
7009de42: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009de46: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmOptFlowReq.flow_index         = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009de4a: 9818         	ldr	r0, [sp, #0x60]
7009de4c: 6840         	ldr	r0, [r0, #0x4]
7009de4e: 991c         	ldr	r1, [sp, #0x70]
7009de50: 4408         	add	r0, r1
7009de52: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         rmOptFlowReq.rx_size_thresh0    = (flowPrms->sizeThresh0 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009de56: 981b         	ldr	r0, [sp, #0x6c]
7009de58: 8c00         	ldrh	r0, [r0, #0x20]
7009de5a: 0940         	lsrs	r0, r0, #0x5
7009de5c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmOptFlowReq.rx_size_thresh1    = (flowPrms->sizeThresh1 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009de60: 981b         	ldr	r0, [sp, #0x6c]
7009de62: 8c40         	ldrh	r0, [r0, #0x22]
7009de64: 0940         	lsrs	r0, r0, #0x5
7009de66: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmOptFlowReq.rx_size_thresh2    = (flowPrms->sizeThresh2 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009de6a: 981b         	ldr	r0, [sp, #0x6c]
7009de6c: 8c80         	ldrh	r0, [r0, #0x24]
7009de6e: 0940         	lsrs	r0, r0, #0x5
7009de70: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmOptFlowReq.rx_fdq0_sz1_qnum   = flowPrms->fdq0Sz1Qnum;
7009de74: 981b         	ldr	r0, [sp, #0x6c]
7009de76: 8cc0         	ldrh	r0, [r0, #0x26]
7009de78: f8ad 0022    	strh.w	r0, [sp, #0x22]
;         rmOptFlowReq.rx_fdq0_sz2_qnum   = flowPrms->fdq0Sz2Qnum;
7009de7c: 981b         	ldr	r0, [sp, #0x6c]
7009de7e: 8d00         	ldrh	r0, [r0, #0x28]
7009de80: f8ad 0024    	strh.w	r0, [sp, #0x24]
;         rmOptFlowReq.rx_fdq0_sz3_qnum   = flowPrms->fdq0Sz3Qnum;
7009de84: 981b         	ldr	r0, [sp, #0x6c]
7009de86: 8d40         	ldrh	r0, [r0, #0x2a]
7009de88: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmOptFlowReq.rx_size_thresh_en  = flowPrms->sizeThreshEn;
7009de8c: 981b         	ldr	r0, [sp, #0x6c]
7009de8e: 7d80         	ldrb	r0, [r0, #0x16]
7009de90: f88d 0028    	strb.w	r0, [sp, #0x28]
7009de94: a803         	add	r0, sp, #0xc
7009de96: a901         	add	r1, sp, #0x4
7009de98: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal += Sciclient_rmUdmapFlowSizeThreshCfg(
7009de9c: f00c fce0    	bl	0x700aa860 <Sciclient_rmUdmapFlowSizeThreshCfg> @ imm = #0xc9c0
7009dea0: 4601         	mov	r1, r0
7009dea2: 981a         	ldr	r0, [sp, #0x68]
7009dea4: 4408         	add	r0, r1
7009dea6: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009dea8: 981a         	ldr	r0, [sp, #0x68]
7009deaa: b108         	cbz	r0, 0x7009deb0 <Udma_flowConfig+0x1d0> @ imm = #0x2
7009deac: e7ff         	b	0x7009deae <Udma_flowConfig+0x1ce> @ imm = #-0x2
;         }
7009deae: e7ff         	b	0x7009deb0 <Udma_flowConfig+0x1d0> @ imm = #-0x2
;     }
7009deb0: e7ff         	b	0x7009deb2 <Udma_flowConfig+0x1d2> @ imm = #-0x2
;     return (retVal);
7009deb2: 981a         	ldr	r0, [sp, #0x68]
7009deb4: b01e         	add	sp, #0x78
7009deb6: bd80         	pop	{r7, pc}
		...

7009dec0 <SOC_moduleSetClockFrequency>:
; {
7009dec0: b580         	push	{r7, lr}
7009dec2: b090         	sub	sp, #0x40
7009dec4: 900f         	str	r0, [sp, #0x3c]
7009dec6: 910e         	str	r1, [sp, #0x38]
7009dec8: 930d         	str	r3, [sp, #0x34]
7009deca: 920c         	str	r2, [sp, #0x30]
7009decc: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009dece: 9002         	str	r0, [sp, #0x8]
7009ded0: 900b         	str	r0, [sp, #0x2c]
;     uint32_t i = 0U;
7009ded2: 900a         	str	r0, [sp, #0x28]
;     uint64_t respClkRate = 0;
7009ded4: 9009         	str	r0, [sp, #0x24]
7009ded6: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009ded8: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009deda: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009dedc: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009dede: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009dee0: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009dee2: 980f         	ldr	r0, [sp, #0x3c]
;                                             clkId,
7009dee4: 990e         	ldr	r1, [sp, #0x38]
7009dee6: aa05         	add	r2, sp, #0x14
7009dee8: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009deec: f009 f998    	bl	0x700a7220 <Sciclient_pmModuleGetClkStatus> @ imm = #0x9330
7009def0: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009def2: 980b         	ldr	r0, [sp, #0x2c]
7009def4: b948         	cbnz	r0, 0x7009df0a <SOC_moduleSetClockFrequency+0x4a> @ imm = #0x12
7009def6: e7ff         	b	0x7009def8 <SOC_moduleSetClockFrequency+0x38> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009def8: 980f         	ldr	r0, [sp, #0x3c]
;                                                    clkId,
7009defa: 990e         	ldr	r1, [sp, #0x38]
7009defc: aa07         	add	r2, sp, #0x1c
7009defe: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009df02: f008 fb1d    	bl	0x700a6540 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x863a
7009df06: 900b         	str	r0, [sp, #0x2c]
;     }
7009df08: e7ff         	b	0x7009df0a <SOC_moduleSetClockFrequency+0x4a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009df0a: 980b         	ldr	r0, [sp, #0x2c]
7009df0c: b970         	cbnz	r0, 0x7009df2c <SOC_moduleSetClockFrequency+0x6c> @ imm = #0x1c
7009df0e: e7ff         	b	0x7009df10 <SOC_moduleSetClockFrequency+0x50> @ imm = #-0x2
;         if(numParents > 1U)
7009df10: 9807         	ldr	r0, [sp, #0x1c]
7009df12: 2802         	cmp	r0, #0x2
7009df14: d309         	blo	0x7009df2a <SOC_moduleSetClockFrequency+0x6a> @ imm = #0x12
7009df16: e7ff         	b	0x7009df18 <SOC_moduleSetClockFrequency+0x58> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009df18: 980f         	ldr	r0, [sp, #0x3c]
;                                                     clkId,
7009df1a: 990e         	ldr	r1, [sp, #0x38]
7009df1c: aa04         	add	r2, sp, #0x10
7009df1e: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009df22: f008 ff9d    	bl	0x700a6e60 <Sciclient_pmGetModuleClkParent> @ imm = #0x8f3a
7009df26: 900b         	str	r0, [sp, #0x2c]
;         }
7009df28: e7ff         	b	0x7009df2a <SOC_moduleSetClockFrequency+0x6a> @ imm = #-0x2
;     }
7009df2a: e7ff         	b	0x7009df2c <SOC_moduleSetClockFrequency+0x6c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009df2c: 980b         	ldr	r0, [sp, #0x2c]
7009df2e: b960         	cbnz	r0, 0x7009df4a <SOC_moduleSetClockFrequency+0x8a> @ imm = #0x18
7009df30: e7ff         	b	0x7009df32 <SOC_moduleSetClockFrequency+0x72> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009df32: 980f         	ldr	r0, [sp, #0x3c]
;                                               clkId,
7009df34: 990e         	ldr	r1, [sp, #0x38]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009df36: 466b         	mov	r3, sp
7009df38: f04f 32ff    	mov.w	r2, #0xffffffff
7009df3c: 601a         	str	r2, [r3]
7009df3e: 2300         	movs	r3, #0x0
7009df40: 461a         	mov	r2, r3
7009df42: f009 ffe5    	bl	0x700a7f10 <Sciclient_pmModuleClkRequest> @ imm = #0x9fca
7009df46: 900b         	str	r0, [sp, #0x2c]
;     }
7009df48: e7ff         	b	0x7009df4a <SOC_moduleSetClockFrequency+0x8a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009df4a: 980b         	ldr	r0, [sp, #0x2c]
7009df4c: 2800         	cmp	r0, #0x0
7009df4e: d14d         	bne	0x7009dfec <SOC_moduleSetClockFrequency+0x12c> @ imm = #0x9a
7009df50: e7ff         	b	0x7009df52 <SOC_moduleSetClockFrequency+0x92> @ imm = #-0x2
7009df52: 2000         	movs	r0, #0x0
;         foundParent = 0U;
7009df54: 9003         	str	r0, [sp, #0xc]
;         for(i=0U;i<numParents;i++)
7009df56: 900a         	str	r0, [sp, #0x28]
7009df58: e7ff         	b	0x7009df5a <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x2
7009df5a: 980a         	ldr	r0, [sp, #0x28]
7009df5c: 9907         	ldr	r1, [sp, #0x1c]
7009df5e: 4288         	cmp	r0, r1
7009df60: d243         	bhs	0x7009dfea <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x86
7009df62: e7ff         	b	0x7009df64 <SOC_moduleSetClockFrequency+0xa4> @ imm = #-0x2
;             if (numParents > 1U)
7009df64: 9807         	ldr	r0, [sp, #0x1c]
7009df66: 2802         	cmp	r0, #0x2
7009df68: d311         	blo	0x7009df8e <SOC_moduleSetClockFrequency+0xce> @ imm = #0x22
7009df6a: e7ff         	b	0x7009df6c <SOC_moduleSetClockFrequency+0xac> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009df6c: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009df6e: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkId+i+1,
7009df70: 9a0a         	ldr	r2, [sp, #0x28]
7009df72: 440a         	add	r2, r1
7009df74: 3201         	adds	r2, #0x1
7009df76: f04f 33ff    	mov.w	r3, #0xffffffff
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009df7a: f008 ffc1    	bl	0x700a6f00 <Sciclient_pmSetModuleClkParent> @ imm = #0x8f82
7009df7e: 900b         	str	r0, [sp, #0x2c]
;                 if (status == SystemP_SUCCESS)
7009df80: 980b         	ldr	r0, [sp, #0x2c]
7009df82: b918         	cbnz	r0, 0x7009df8c <SOC_moduleSetClockFrequency+0xcc> @ imm = #0x6
7009df84: e7ff         	b	0x7009df86 <SOC_moduleSetClockFrequency+0xc6> @ imm = #-0x2
7009df86: 2001         	movs	r0, #0x1
;                     moduleClockParentChanged = 1U;
7009df88: 9006         	str	r0, [sp, #0x18]
;                 }
7009df8a: e7ff         	b	0x7009df8c <SOC_moduleSetClockFrequency+0xcc> @ imm = #-0x2
;             }
7009df8c: e7ff         	b	0x7009df8e <SOC_moduleSetClockFrequency+0xce> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009df8e: 980b         	ldr	r0, [sp, #0x2c]
7009df90: b988         	cbnz	r0, 0x7009dfb6 <SOC_moduleSetClockFrequency+0xf6> @ imm = #0x22
7009df92: e7ff         	b	0x7009df94 <SOC_moduleSetClockFrequency+0xd4> @ imm = #-0x2
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009df94: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009df96: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkRate,
7009df98: 9a0c         	ldr	r2, [sp, #0x30]
7009df9a: 9b0d         	ldr	r3, [sp, #0x34]
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009df9c: 46ee         	mov	lr, sp
7009df9e: f04f 3cff    	mov.w	r12, #0xffffffff
7009dfa2: f8ce c004    	str.w	r12, [lr, #0x4]
7009dfa6: f10d 0c20    	add.w	r12, sp, #0x20
7009dfaa: f8ce c000    	str.w	r12, [lr]
7009dfae: f003 fbdf    	bl	0x700a1770 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x37be
7009dfb2: 900b         	str	r0, [sp, #0x2c]
;             }
7009dfb4: e7ff         	b	0x7009dfb6 <SOC_moduleSetClockFrequency+0xf6> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009dfb6: 980b         	ldr	r0, [sp, #0x2c]
7009dfb8: b970         	cbnz	r0, 0x7009dfd8 <SOC_moduleSetClockFrequency+0x118> @ imm = #0x1c
7009dfba: e7ff         	b	0x7009dfbc <SOC_moduleSetClockFrequency+0xfc> @ imm = #-0x2
;                 if(respClkRate == clkRate)
7009dfbc: 9808         	ldr	r0, [sp, #0x20]
7009dfbe: 9909         	ldr	r1, [sp, #0x24]
7009dfc0: 9a0c         	ldr	r2, [sp, #0x30]
7009dfc2: 9b0d         	ldr	r3, [sp, #0x34]
7009dfc4: 4059         	eors	r1, r3
7009dfc6: ea80 0002    	eor.w	r0, r0, r2
7009dfca: 4308         	orrs	r0, r1
7009dfcc: b918         	cbnz	r0, 0x7009dfd6 <SOC_moduleSetClockFrequency+0x116> @ imm = #0x6
7009dfce: e7ff         	b	0x7009dfd0 <SOC_moduleSetClockFrequency+0x110> @ imm = #-0x2
7009dfd0: 2001         	movs	r0, #0x1
;                     foundParent = 1U;
7009dfd2: 9003         	str	r0, [sp, #0xc]
;                 }
7009dfd4: e7ff         	b	0x7009dfd6 <SOC_moduleSetClockFrequency+0x116> @ imm = #-0x2
;             }
7009dfd6: e7ff         	b	0x7009dfd8 <SOC_moduleSetClockFrequency+0x118> @ imm = #-0x2
;             if(foundParent)
7009dfd8: 9803         	ldr	r0, [sp, #0xc]
7009dfda: b108         	cbz	r0, 0x7009dfe0 <SOC_moduleSetClockFrequency+0x120> @ imm = #0x2
7009dfdc: e7ff         	b	0x7009dfde <SOC_moduleSetClockFrequency+0x11e> @ imm = #-0x2
;                 break; /* found a parent to set clock frequency, rebak form the loop */
7009dfde: e004         	b	0x7009dfea <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x8
;         }
7009dfe0: e7ff         	b	0x7009dfe2 <SOC_moduleSetClockFrequency+0x122> @ imm = #-0x2
;         for(i=0U;i<numParents;i++)
7009dfe2: 980a         	ldr	r0, [sp, #0x28]
7009dfe4: 3001         	adds	r0, #0x1
7009dfe6: 900a         	str	r0, [sp, #0x28]
7009dfe8: e7b7         	b	0x7009df5a <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x92
;     }
7009dfea: e7ff         	b	0x7009dfec <SOC_moduleSetClockFrequency+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009dfec: 980b         	ldr	r0, [sp, #0x2c]
7009dfee: b9d0         	cbnz	r0, 0x7009e026 <SOC_moduleSetClockFrequency+0x166> @ imm = #0x34
7009dff0: e7ff         	b	0x7009dff2 <SOC_moduleSetClockFrequency+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009dff2: 9803         	ldr	r0, [sp, #0xc]
7009dff4: 2801         	cmp	r0, #0x1
7009dff6: d111         	bne	0x7009e01c <SOC_moduleSetClockFrequency+0x15c> @ imm = #0x22
7009dff8: e7ff         	b	0x7009dffa <SOC_moduleSetClockFrequency+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009dffa: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009dffc: 990e         	ldr	r1, [sp, #0x38]
;                                                   clkRate,
7009dffe: 9a0c         	ldr	r2, [sp, #0x30]
7009e000: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009e002: 46ee         	mov	lr, sp
7009e004: f04f 3cff    	mov.w	r12, #0xffffffff
7009e008: f8ce c004    	str.w	r12, [lr, #0x4]
7009e00c: f44f 7c00    	mov.w	r12, #0x200
7009e010: f8ce c000    	str.w	r12, [lr]
7009e014: f005 f8f4    	bl	0x700a3200 <Sciclient_pmSetModuleClkFreq> @ imm = #0x51e8
7009e018: 900b         	str	r0, [sp, #0x2c]
;         }
7009e01a: e003         	b	0x7009e024 <SOC_moduleSetClockFrequency+0x164> @ imm = #0x6
7009e01c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009e020: 900b         	str	r0, [sp, #0x2c]
7009e022: e7ff         	b	0x7009e024 <SOC_moduleSetClockFrequency+0x164> @ imm = #-0x2
;     }
7009e024: e7ff         	b	0x7009e026 <SOC_moduleSetClockFrequency+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009e026: 980b         	ldr	r0, [sp, #0x2c]
7009e028: b988         	cbnz	r0, 0x7009e04e <SOC_moduleSetClockFrequency+0x18e> @ imm = #0x22
7009e02a: e7ff         	b	0x7009e02c <SOC_moduleSetClockFrequency+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009e02c: 9805         	ldr	r0, [sp, #0x14]
7009e02e: b968         	cbnz	r0, 0x7009e04c <SOC_moduleSetClockFrequency+0x18c> @ imm = #0x1a
7009e030: e7ff         	b	0x7009e032 <SOC_moduleSetClockFrequency+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009e032: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009e034: 990e         	ldr	r1, [sp, #0x38]
;                                                   clockStatus,
7009e036: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009e038: 46ec         	mov	r12, sp
7009e03a: f04f 33ff    	mov.w	r3, #0xffffffff
7009e03e: f8cc 3000    	str.w	r3, [r12]
7009e042: 2300         	movs	r3, #0x0
7009e044: f009 ff64    	bl	0x700a7f10 <Sciclient_pmModuleClkRequest> @ imm = #0x9ec8
7009e048: 900b         	str	r0, [sp, #0x2c]
;         }
7009e04a: e7ff         	b	0x7009e04c <SOC_moduleSetClockFrequency+0x18c> @ imm = #-0x2
;     }
7009e04c: e7ff         	b	0x7009e04e <SOC_moduleSetClockFrequency+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009e04e: 980b         	ldr	r0, [sp, #0x2c]
7009e050: b168         	cbz	r0, 0x7009e06e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #0x1a
7009e052: e7ff         	b	0x7009e054 <SOC_moduleSetClockFrequency+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009e054: 9806         	ldr	r0, [sp, #0x18]
7009e056: 2801         	cmp	r0, #0x1
7009e058: d108         	bne	0x7009e06c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #0x10
7009e05a: e7ff         	b	0x7009e05c <SOC_moduleSetClockFrequency+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009e05c: 980f         	ldr	r0, [sp, #0x3c]
;                                            clkId,
7009e05e: 990e         	ldr	r1, [sp, #0x38]
;                                            origParent,
7009e060: 9a04         	ldr	r2, [sp, #0x10]
7009e062: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009e066: f008 ff4b    	bl	0x700a6f00 <Sciclient_pmSetModuleClkParent> @ imm = #0x8e96
;         }
7009e06a: e7ff         	b	0x7009e06c <SOC_moduleSetClockFrequency+0x1ac> @ imm = #-0x2
;     }
7009e06c: e7ff         	b	0x7009e06e <SOC_moduleSetClockFrequency+0x1ae> @ imm = #-0x2
;     return status;
7009e06e: 980b         	ldr	r0, [sp, #0x2c]
7009e070: b010         	add	sp, #0x40
7009e072: bd80         	pop	{r7, pc}
		...

7009e080 <UART_close>:
; {
7009e080: b580         	push	{r7, lr}
7009e082: b08a         	sub	sp, #0x28
7009e084: 9009         	str	r0, [sp, #0x24]
;     config = (UART_Config *) handle;
7009e086: 9809         	ldr	r0, [sp, #0x24]
7009e088: 9008         	str	r0, [sp, #0x20]
;     if ((NULL != config) && (config->object != NULL) && (config->object->isOpen != FALSE))
7009e08a: 9808         	ldr	r0, [sp, #0x20]
7009e08c: 2800         	cmp	r0, #0x0
7009e08e: f000 80ce    	beq.w	0x7009e22e <UART_close+0x1ae> @ imm = #0x19c
7009e092: e7ff         	b	0x7009e094 <UART_close+0x14> @ imm = #-0x2
7009e094: 9808         	ldr	r0, [sp, #0x20]
7009e096: 6840         	ldr	r0, [r0, #0x4]
7009e098: 2800         	cmp	r0, #0x0
7009e09a: f000 80c8    	beq.w	0x7009e22e <UART_close+0x1ae> @ imm = #0x190
7009e09e: e7ff         	b	0x7009e0a0 <UART_close+0x20> @ imm = #-0x2
7009e0a0: 9808         	ldr	r0, [sp, #0x20]
7009e0a2: 6840         	ldr	r0, [r0, #0x4]
7009e0a4: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009e0a8: 2800         	cmp	r0, #0x0
7009e0aa: f000 80c0    	beq.w	0x7009e22e <UART_close+0x1ae> @ imm = #0x180
7009e0ae: e7ff         	b	0x7009e0b0 <UART_close+0x30> @ imm = #-0x2
;         object = config->object;
7009e0b0: 9808         	ldr	r0, [sp, #0x20]
7009e0b2: 6840         	ldr	r0, [r0, #0x4]
7009e0b4: 9007         	str	r0, [sp, #0x1c]
;         attrs = config->attrs;
7009e0b6: 9808         	ldr	r0, [sp, #0x20]
7009e0b8: 6800         	ldr	r0, [r0]
7009e0ba: 9006         	str	r0, [sp, #0x18]
;         object->uartLld_handle = &object->uartLld_object;
7009e0bc: 9907         	ldr	r1, [sp, #0x1c]
7009e0be: f501 7022    	add.w	r0, r1, #0x288
7009e0c2: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle = object->uartLld_handle;
7009e0c6: 9807         	ldr	r0, [sp, #0x1c]
7009e0c8: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009e0cc: 9005         	str	r0, [sp, #0x14]
;         DebugP_assert(NULL_PTR != object);
7009e0ce: 9807         	ldr	r0, [sp, #0x1c]
7009e0d0: 2800         	cmp	r0, #0x0
7009e0d2: bf18         	it	ne
7009e0d4: 2001         	movne	r0, #0x1
7009e0d6: f64f 017c    	movw	r1, #0xf87c
7009e0da: f2c7 010a    	movt	r1, #0x700a
7009e0de: 466a         	mov	r2, sp
7009e0e0: 6011         	str	r1, [r2]
7009e0e2: f64f 01a2    	movw	r1, #0xf8a2
7009e0e6: f2c7 010a    	movt	r1, #0x700a
7009e0ea: 9101         	str	r1, [sp, #0x4]
7009e0ec: f64f 128d    	movw	r2, #0xf98d
7009e0f0: f2c7 020a    	movt	r2, #0x700a
7009e0f4: 9202         	str	r2, [sp, #0x8]
7009e0f6: f240 13c5    	movw	r3, #0x1c5
7009e0fa: f00a fd51    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xaaa2
7009e0fe: 9901         	ldr	r1, [sp, #0x4]
7009e100: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
7009e102: 9806         	ldr	r0, [sp, #0x18]
7009e104: 2800         	cmp	r0, #0x0
7009e106: bf18         	it	ne
7009e108: 2001         	movne	r0, #0x1
7009e10a: f64f 03d8    	movw	r3, #0xf8d8
7009e10e: f2c7 030a    	movt	r3, #0x700a
7009e112: 46ec         	mov	r12, sp
7009e114: f8cc 3000    	str.w	r3, [r12]
7009e118: f44f 73e3    	mov.w	r3, #0x1c6
7009e11c: f00a fd40    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xaa80
7009e120: 9901         	ldr	r1, [sp, #0x4]
7009e122: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009e124: f64f 7350    	movw	r3, #0xff50
7009e128: f2c7 030a    	movt	r3, #0x700a
7009e12c: f853 0b04    	ldr	r0, [r3], #4
7009e130: 9303         	str	r3, [sp, #0xc]
7009e132: 2800         	cmp	r0, #0x0
7009e134: bf18         	it	ne
7009e136: 2001         	movne	r0, #0x1
7009e138: f24f 63a8    	movw	r3, #0xf6a8
7009e13c: f2c7 030a    	movt	r3, #0x700a
7009e140: 46ec         	mov	r12, sp
7009e142: f8cc 3000    	str.w	r3, [r12]
7009e146: f44f 73e4    	mov.w	r3, #0x1c8
7009e14a: f00a fd29    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xaa52
7009e14e: 9803         	ldr	r0, [sp, #0xc]
7009e150: f04f 31ff    	mov.w	r1, #0xffffffff
;         (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009e154: f00a facc    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0xa598
;         UART_flushTxFifo(handle);
7009e158: 9809         	ldr	r0, [sp, #0x24]
7009e15a: f007 f8f9    	bl	0x700a5350 <UART_flushTxFifo> @ imm = #0x71f2
;         UART_intrDisable(attrs->baseAddr,
7009e15e: 9806         	ldr	r0, [sp, #0x18]
7009e160: 6800         	ldr	r0, [r0]
7009e162: 2107         	movs	r1, #0x7
7009e164: 9104         	str	r1, [sp, #0x10]
7009e166: f006 f90b    	bl	0x700a4380 <UART_intrDisable> @ imm = #0x6216
;         UART_intr2Disable(attrs->baseAddr, UART_INT2_TX_EMPTY);
7009e16a: 9806         	ldr	r0, [sp, #0x18]
7009e16c: 6800         	ldr	r0, [r0]
7009e16e: 2102         	movs	r1, #0x2
7009e170: f00e fc06    	bl	0x700ac980 <UART_intr2Disable> @ imm = #0xe80c
7009e174: 9904         	ldr	r1, [sp, #0x10]
;         (void)UART_operatingModeSelect(attrs->baseAddr, UART_OPER_MODE_DISABLED);
7009e176: 9806         	ldr	r0, [sp, #0x18]
7009e178: 6800         	ldr	r0, [r0]
7009e17a: f00e fc49    	bl	0x700aca10 <UART_operatingModeSelect> @ imm = #0xe892
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009e17e: 9807         	ldr	r0, [sp, #0x1c]
7009e180: 6b00         	ldr	r0, [r0, #0x30]
7009e182: 2803         	cmp	r0, #0x3
7009e184: d104         	bne	0x7009e190 <UART_close+0x110> @ imm = #0x8
7009e186: e7ff         	b	0x7009e188 <UART_close+0x108> @ imm = #-0x2
;             (void)UART_lld_deInitDma(uartLld_handle);
7009e188: 9805         	ldr	r0, [sp, #0x14]
7009e18a: f00b fcb1    	bl	0x700a9af0 <UART_lld_deInitDma> @ imm = #0xb962
;         }
7009e18e: e003         	b	0x7009e198 <UART_close+0x118> @ imm = #0x6
;             (void)UART_lld_deInit(uartLld_handle);
7009e190: 9805         	ldr	r0, [sp, #0x14]
7009e192: f00c f985    	bl	0x700aa4a0 <UART_lld_deInit> @ imm = #0xc30a
7009e196: e7ff         	b	0x7009e198 <UART_close+0x118> @ imm = #-0x2
;         if(NULL != object->lock)
7009e198: 9807         	ldr	r0, [sp, #0x1c]
7009e19a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009e19e: b148         	cbz	r0, 0x7009e1b4 <UART_close+0x134> @ imm = #0x12
7009e1a0: e7ff         	b	0x7009e1a2 <UART_close+0x122> @ imm = #-0x2
;             SemaphoreP_destruct(&object->lockObj);
7009e1a2: 9807         	ldr	r0, [sp, #0x1c]
7009e1a4: 308c         	adds	r0, #0x8c
7009e1a6: f00f f91b    	bl	0x700ad3e0 <SemaphoreP_destruct> @ imm = #0xf236
;             object->lock = NULL;
7009e1aa: 9907         	ldr	r1, [sp, #0x1c]
7009e1ac: 2000         	movs	r0, #0x0
7009e1ae: f8c1 0088    	str.w	r0, [r1, #0x88]
;         }
7009e1b2: e7ff         	b	0x7009e1b4 <UART_close+0x134> @ imm = #-0x2
;         if(NULL != object->readTransferSem)
7009e1b4: 9807         	ldr	r0, [sp, #0x1c]
7009e1b6: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009e1ba: b160         	cbz	r0, 0x7009e1d6 <UART_close+0x156> @ imm = #0x18
7009e1bc: e7ff         	b	0x7009e1be <UART_close+0x13e> @ imm = #-0x2
;             SemaphoreP_destruct(&object->readTransferSemObj);
7009e1be: 9807         	ldr	r0, [sp, #0x1c]
7009e1c0: f500 7094    	add.w	r0, r0, #0x128
7009e1c4: f00f f90c    	bl	0x700ad3e0 <SemaphoreP_destruct> @ imm = #0xf218
;             object->readTransferSem = NULL;
7009e1c8: 9907         	ldr	r1, [sp, #0x1c]
7009e1ca: 2000         	movs	r0, #0x0
7009e1cc: f8c1 0124    	str.w	r0, [r1, #0x124]
;             uartLld_handle->readTransferMutex = NULL;
7009e1d0: 9905         	ldr	r1, [sp, #0x14]
7009e1d2: 6588         	str	r0, [r1, #0x58]
;         }
7009e1d4: e7ff         	b	0x7009e1d6 <UART_close+0x156> @ imm = #-0x2
;         if(NULL != object->writeTransferSem)
7009e1d6: 9807         	ldr	r0, [sp, #0x1c]
7009e1d8: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009e1dc: b160         	cbz	r0, 0x7009e1f8 <UART_close+0x178> @ imm = #0x18
7009e1de: e7ff         	b	0x7009e1e0 <UART_close+0x160> @ imm = #-0x2
;             SemaphoreP_destruct(&object->writeTransferSemObj);
7009e1e0: 9807         	ldr	r0, [sp, #0x1c]
7009e1e2: f500 70e2    	add.w	r0, r0, #0x1c4
7009e1e6: f00f f8fb    	bl	0x700ad3e0 <SemaphoreP_destruct> @ imm = #0xf1f6
;             object->writeTransferSem = NULL;
7009e1ea: 9907         	ldr	r1, [sp, #0x1c]
7009e1ec: 2000         	movs	r0, #0x0
7009e1ee: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;             uartLld_handle->writeTransferMutex = NULL;
7009e1f2: 9905         	ldr	r1, [sp, #0x14]
7009e1f4: 65c8         	str	r0, [r1, #0x5c]
;         }
7009e1f6: e7ff         	b	0x7009e1f8 <UART_close+0x178> @ imm = #-0x2
;         if(NULL != object->hwiHandle)
7009e1f8: 9807         	ldr	r0, [sp, #0x1c]
7009e1fa: f8d0 025c    	ldr.w	r0, [r0, #0x25c]
7009e1fe: b150         	cbz	r0, 0x7009e216 <UART_close+0x196> @ imm = #0x14
7009e200: e7ff         	b	0x7009e202 <UART_close+0x182> @ imm = #-0x2
;             HwiP_destruct(&object->hwiObj);
7009e202: 9807         	ldr	r0, [sp, #0x1c]
7009e204: f500 7018    	add.w	r0, r0, #0x260
7009e208: f00f fcd2    	bl	0x700adbb0 <HwiP_destruct> @ imm = #0xf9a4
;             object->hwiHandle = NULL;
7009e20c: 9907         	ldr	r1, [sp, #0x1c]
7009e20e: 2000         	movs	r0, #0x0
7009e210: f8c1 025c    	str.w	r0, [r1, #0x25c]
;         }
7009e214: e7ff         	b	0x7009e216 <UART_close+0x196> @ imm = #-0x2
;         object->isOpen = FALSE;
7009e216: 9907         	ldr	r1, [sp, #0x1c]
7009e218: 2000         	movs	r0, #0x0
7009e21a: f8c1 0084    	str.w	r0, [r1, #0x84]
;         SemaphoreP_post(&gUartDrvObj.lockObj);
7009e21e: f64f 7050    	movw	r0, #0xff50
7009e222: f2c7 000a    	movt	r0, #0x700a
7009e226: 3004         	adds	r0, #0x4
7009e228: f00b fdb2    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0xbb64
;     }
7009e22c: e7ff         	b	0x7009e22e <UART_close+0x1ae> @ imm = #-0x2
;     return;
7009e22e: b00a         	add	sp, #0x28
7009e230: bd80         	pop	{r7, pc}
		...
7009e23e: 0000         	movs	r0, r0

7009e240 <UART_lld_controllerIsr>:
; {
7009e240: b580         	push	{r7, lr}
7009e242: b086         	sub	sp, #0x18
7009e244: 9005         	str	r0, [sp, #0x14]
7009e246: 2001         	movs	r0, #0x1
;     uint32_t            retVal = TRUE;
7009e248: 9001         	str	r0, [sp, #0x4]
;     if(NULL != args)
7009e24a: 9805         	ldr	r0, [sp, #0x14]
7009e24c: 2800         	cmp	r0, #0x0
7009e24e: f000 80c8    	beq.w	0x7009e3e2 <UART_lld_controllerIsr+0x1a2> @ imm = #0x190
7009e252: e7ff         	b	0x7009e254 <UART_lld_controllerIsr+0x14> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
7009e254: 9805         	ldr	r0, [sp, #0x14]
7009e256: 9002         	str	r0, [sp, #0x8]
;         while (retVal == TRUE)
7009e258: e7ff         	b	0x7009e25a <UART_lld_controllerIsr+0x1a> @ imm = #-0x2
7009e25a: 9801         	ldr	r0, [sp, #0x4]
7009e25c: 2801         	cmp	r0, #0x1
7009e25e: f040 80bf    	bne.w	0x7009e3e0 <UART_lld_controllerIsr+0x1a0> @ imm = #0x17e
7009e262: e7ff         	b	0x7009e264 <UART_lld_controllerIsr+0x24> @ imm = #-0x2
;             intType = UART_getIntrIdentityStatus(hUart->baseAddr);
7009e264: 9802         	ldr	r0, [sp, #0x8]
7009e266: 6800         	ldr	r0, [r0]
7009e268: f00d f80a    	bl	0x700ab280 <UART_getIntrIdentityStatus> @ imm = #0xd014
7009e26c: 9004         	str	r0, [sp, #0x10]
;             if ((intType & UART_INTID_RX_THRES_REACH) == UART_INTID_RX_THRES_REACH)
7009e26e: f89d 0010    	ldrb.w	r0, [sp, #0x10]
7009e272: 0740         	lsls	r0, r0, #0x1d
7009e274: 2800         	cmp	r0, #0x0
7009e276: d561         	bpl	0x7009e33c <UART_lld_controllerIsr+0xfc> @ imm = #0xc2
7009e278: e7ff         	b	0x7009e27a <UART_lld_controllerIsr+0x3a> @ imm = #-0x2
;                 if ((intType & UART_INTID_RX_LINE_STAT_ERROR) ==
7009e27a: 9804         	ldr	r0, [sp, #0x10]
7009e27c: f000 0006    	and	r0, r0, #0x6
7009e280: 2806         	cmp	r0, #0x6
7009e282: d104         	bne	0x7009e28e <UART_lld_controllerIsr+0x4e> @ imm = #0x8
7009e284: e7ff         	b	0x7009e286 <UART_lld_controllerIsr+0x46> @ imm = #-0x2
;                     (void)UART_procLineStatusErr(hUart);
7009e286: 9802         	ldr	r0, [sp, #0x8]
7009e288: f002 fcf2    	bl	0x700a0c70 <UART_procLineStatusErr> @ imm = #0x29e4
;                 }
7009e28c: e055         	b	0x7009e33a <UART_lld_controllerIsr+0xfa> @ imm = #0xaa
;                     if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
7009e28e: 9804         	ldr	r0, [sp, #0x10]
7009e290: f000 000c    	and	r0, r0, #0xc
7009e294: 280c         	cmp	r0, #0xc
7009e296: d10a         	bne	0x7009e2ae <UART_lld_controllerIsr+0x6e> @ imm = #0x14
7009e298: e7ff         	b	0x7009e29a <UART_lld_controllerIsr+0x5a> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e29a: 9802         	ldr	r0, [sp, #0x8]
7009e29c: 6800         	ldr	r0, [r0]
7009e29e: 2105         	movs	r1, #0x5
7009e2a0: f006 f86e    	bl	0x700a4380 <UART_intrDisable> @ imm = #0x60dc
;                         hUart->rxTimeoutCnt++;
7009e2a4: 9902         	ldr	r1, [sp, #0x8]
7009e2a6: 6a08         	ldr	r0, [r1, #0x20]
7009e2a8: 3001         	adds	r0, #0x1
7009e2aa: 6208         	str	r0, [r1, #0x20]
;                     }
7009e2ac: e7ff         	b	0x7009e2ae <UART_lld_controllerIsr+0x6e> @ imm = #-0x2
;                     if (hUart->readSizeRemaining > 0U)
7009e2ae: 9802         	ldr	r0, [sp, #0x8]
7009e2b0: 69c0         	ldr	r0, [r0, #0x1c]
7009e2b2: b3a8         	cbz	r0, 0x7009e320 <UART_lld_controllerIsr+0xe0> @ imm = #0x6a
7009e2b4: e7ff         	b	0x7009e2b6 <UART_lld_controllerIsr+0x76> @ imm = #-0x2
;                         hUart->readSizeRemaining = UART_readData(hUart, hUart->readSizeRemaining);
7009e2b6: 9802         	ldr	r0, [sp, #0x8]
7009e2b8: 69c1         	ldr	r1, [r0, #0x1c]
7009e2ba: f00a fc31    	bl	0x700a8b20 <UART_readData> @ imm = #0xa862
7009e2be: 9902         	ldr	r1, [sp, #0x8]
7009e2c0: 61c8         	str	r0, [r1, #0x1c]
;                         if ((hUart->readSizeRemaining == 0U) ||
7009e2c2: 9802         	ldr	r0, [sp, #0x8]
7009e2c4: 69c0         	ldr	r0, [r0, #0x1c]
7009e2c6: b130         	cbz	r0, 0x7009e2d6 <UART_lld_controllerIsr+0x96> @ imm = #0xc
7009e2c8: e7ff         	b	0x7009e2ca <UART_lld_controllerIsr+0x8a> @ imm = #-0x2
;                             (hUart->hUartInit->readReturnMode == UART_READ_RETURN_MODE_PARTIAL))
7009e2ca: 9802         	ldr	r0, [sp, #0x8]
7009e2cc: 6840         	ldr	r0, [r0, #0x4]
7009e2ce: 6940         	ldr	r0, [r0, #0x14]
;                         if ((hUart->readSizeRemaining == 0U) ||
7009e2d0: 2801         	cmp	r0, #0x1
7009e2d2: d11e         	bne	0x7009e312 <UART_lld_controllerIsr+0xd2> @ imm = #0x3c
7009e2d4: e7ff         	b	0x7009e2d6 <UART_lld_controllerIsr+0x96> @ imm = #-0x2
;                             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e2d6: 9802         	ldr	r0, [sp, #0x8]
7009e2d8: 6800         	ldr	r0, [r0]
7009e2da: 2105         	movs	r1, #0x5
7009e2dc: f006 f850    	bl	0x700a4380 <UART_intrDisable> @ imm = #0x60a0
;                             hUart->readBuf = (uint8_t *)hUart->readBuf - hUart->readCount;
7009e2e0: 9902         	ldr	r1, [sp, #0x8]
7009e2e2: 6948         	ldr	r0, [r1, #0x14]
7009e2e4: 698a         	ldr	r2, [r1, #0x18]
7009e2e6: 1a80         	subs	r0, r0, r2
7009e2e8: 6148         	str	r0, [r1, #0x14]
;                             if (hUart->readTrans.buf != NULL)
7009e2ea: 9802         	ldr	r0, [sp, #0x8]
7009e2ec: 6a80         	ldr	r0, [r0, #0x28]
7009e2ee: b138         	cbz	r0, 0x7009e300 <UART_lld_controllerIsr+0xc0> @ imm = #0xe
7009e2f0: e7ff         	b	0x7009e2f2 <UART_lld_controllerIsr+0xb2> @ imm = #-0x2
;                                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
7009e2f2: 9902         	ldr	r1, [sp, #0x8]
7009e2f4: 6988         	ldr	r0, [r1, #0x18]
7009e2f6: 62c8         	str	r0, [r1, #0x2c]
;                                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
7009e2f8: 9902         	ldr	r1, [sp, #0x8]
7009e2fa: 2000         	movs	r0, #0x0
7009e2fc: 6348         	str	r0, [r1, #0x34]
;                             }
7009e2fe: e7ff         	b	0x7009e300 <UART_lld_controllerIsr+0xc0> @ imm = #-0x2
;                             hUart->hUartInit->readCompleteCallbackFxn(hUart);
7009e300: 9802         	ldr	r0, [sp, #0x8]
7009e302: 6841         	ldr	r1, [r0, #0x4]
7009e304: 6dc9         	ldr	r1, [r1, #0x5c]
7009e306: 4788         	blx	r1
;                             UART_lld_Transaction_deInit(&hUart->readTrans);
7009e308: 9802         	ldr	r0, [sp, #0x8]
7009e30a: 3028         	adds	r0, #0x28
7009e30c: f00e fe88    	bl	0x700ad020 <UART_lld_Transaction_deInit> @ imm = #0xed10
;                         }
7009e310: e005         	b	0x7009e31e <UART_lld_controllerIsr+0xde> @ imm = #0xa
;                             UART_intrEnable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e312: 9802         	ldr	r0, [sp, #0x8]
7009e314: 6800         	ldr	r0, [r0]
7009e316: 2105         	movs	r1, #0x5
7009e318: f005 ff52    	bl	0x700a41c0 <UART_intrEnable> @ imm = #0x5ea4
7009e31c: e7ff         	b	0x7009e31e <UART_lld_controllerIsr+0xde> @ imm = #-0x2
;                     }
7009e31e: e00b         	b	0x7009e338 <UART_lld_controllerIsr+0xf8> @ imm = #0x16
;                         (void)UART_getChar(hUart->baseAddr, &rdData);
7009e320: 9802         	ldr	r0, [sp, #0x8]
7009e322: 6800         	ldr	r0, [r0]
7009e324: f10d 010f    	add.w	r1, sp, #0xf
7009e328: f00b ff9a    	bl	0x700aa260 <UART_getChar> @ imm = #0xbf34
;                         UART_intrDisable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
7009e32c: 9802         	ldr	r0, [sp, #0x8]
7009e32e: 6800         	ldr	r0, [r0]
7009e330: 2105         	movs	r1, #0x5
7009e332: f006 f825    	bl	0x700a4380 <UART_intrDisable> @ imm = #0x604a
7009e336: e7ff         	b	0x7009e338 <UART_lld_controllerIsr+0xf8> @ imm = #-0x2
7009e338: e7ff         	b	0x7009e33a <UART_lld_controllerIsr+0xfa> @ imm = #-0x2
;             }
7009e33a: e050         	b	0x7009e3de <UART_lld_controllerIsr+0x19e> @ imm = #0xa0
;             else if ((intType & UART_INTID_TX_THRES_REACH) == UART_INTID_TX_THRES_REACH)
7009e33c: f89d 0010    	ldrb.w	r0, [sp, #0x10]
7009e340: 0780         	lsls	r0, r0, #0x1e
7009e342: 2800         	cmp	r0, #0x0
7009e344: d534         	bpl	0x7009e3b0 <UART_lld_controllerIsr+0x170> @ imm = #0x68
7009e346: e7ff         	b	0x7009e348 <UART_lld_controllerIsr+0x108> @ imm = #-0x2
;                 if (hUart->writeSizeRemaining > 0U)
7009e348: 9802         	ldr	r0, [sp, #0x8]
7009e34a: 6900         	ldr	r0, [r0, #0x10]
7009e34c: b348         	cbz	r0, 0x7009e3a2 <UART_lld_controllerIsr+0x162> @ imm = #0x52
7009e34e: e7ff         	b	0x7009e350 <UART_lld_controllerIsr+0x110> @ imm = #-0x2
;                     hUart->writeSizeRemaining = (uint32_t)UART_writeData(hUart, (hUart->writeSizeRemaining));
7009e350: 9802         	ldr	r0, [sp, #0x8]
7009e352: 6901         	ldr	r1, [r0, #0x10]
7009e354: f00b ffb4    	bl	0x700aa2c0 <UART_writeData> @ imm = #0xbf68
7009e358: 9902         	ldr	r1, [sp, #0x8]
7009e35a: 6108         	str	r0, [r1, #0x10]
;                     if ((hUart->writeSizeRemaining) == 0U)
7009e35c: 9802         	ldr	r0, [sp, #0x8]
7009e35e: 6900         	ldr	r0, [r0, #0x10]
7009e360: b9f0         	cbnz	r0, 0x7009e3a0 <UART_lld_controllerIsr+0x160> @ imm = #0x3c
7009e362: e7ff         	b	0x7009e364 <UART_lld_controllerIsr+0x124> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
7009e364: 9802         	ldr	r0, [sp, #0x8]
7009e366: 6800         	ldr	r0, [r0]
7009e368: 2102         	movs	r1, #0x2
7009e36a: f006 f809    	bl	0x700a4380 <UART_intrDisable> @ imm = #0x6012
;                         hUart->writeBuf = (const void *)((uint8_t *)hUart->writeBuf - hUart->writeCount);
7009e36e: 9902         	ldr	r1, [sp, #0x8]
7009e370: 6888         	ldr	r0, [r1, #0x8]
7009e372: 68ca         	ldr	r2, [r1, #0xc]
7009e374: 1a80         	subs	r0, r0, r2
7009e376: 6088         	str	r0, [r1, #0x8]
;                         if (hUart->writeTrans.buf != NULL)
7009e378: 9802         	ldr	r0, [sp, #0x8]
7009e37a: 6bc0         	ldr	r0, [r0, #0x3c]
7009e37c: b138         	cbz	r0, 0x7009e38e <UART_lld_controllerIsr+0x14e> @ imm = #0xe
7009e37e: e7ff         	b	0x7009e380 <UART_lld_controllerIsr+0x140> @ imm = #-0x2
;                             hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
7009e380: 9902         	ldr	r1, [sp, #0x8]
7009e382: 68c8         	ldr	r0, [r1, #0xc]
7009e384: 6408         	str	r0, [r1, #0x40]
;                             hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
7009e386: 9902         	ldr	r1, [sp, #0x8]
7009e388: 2000         	movs	r0, #0x0
7009e38a: 6488         	str	r0, [r1, #0x48]
;                         }
7009e38c: e7ff         	b	0x7009e38e <UART_lld_controllerIsr+0x14e> @ imm = #-0x2
;                         hUart->hUartInit->writeCompleteCallbackFxn(hUart);
7009e38e: 9802         	ldr	r0, [sp, #0x8]
7009e390: 6841         	ldr	r1, [r0, #0x4]
7009e392: 6e09         	ldr	r1, [r1, #0x60]
7009e394: 4788         	blx	r1
;                         UART_lld_Transaction_deInit(&hUart->writeTrans);
7009e396: 9802         	ldr	r0, [sp, #0x8]
7009e398: 303c         	adds	r0, #0x3c
7009e39a: f00e fe41    	bl	0x700ad020 <UART_lld_Transaction_deInit> @ imm = #0xec82
;                     }
7009e39e: e7ff         	b	0x7009e3a0 <UART_lld_controllerIsr+0x160> @ imm = #-0x2
;                 }
7009e3a0: e005         	b	0x7009e3ae <UART_lld_controllerIsr+0x16e> @ imm = #0xa
;                     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
7009e3a2: 9802         	ldr	r0, [sp, #0x8]
7009e3a4: 6800         	ldr	r0, [r0]
7009e3a6: 2102         	movs	r1, #0x2
7009e3a8: f005 ffea    	bl	0x700a4380 <UART_intrDisable> @ imm = #0x5fd4
7009e3ac: e7ff         	b	0x7009e3ae <UART_lld_controllerIsr+0x16e> @ imm = #-0x2
;             }
7009e3ae: e015         	b	0x7009e3dc <UART_lld_controllerIsr+0x19c> @ imm = #0x2a
;             else if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
7009e3b0: 9804         	ldr	r0, [sp, #0x10]
7009e3b2: f000 000c    	and	r0, r0, #0xc
7009e3b6: 280c         	cmp	r0, #0xc
7009e3b8: d10c         	bne	0x7009e3d4 <UART_lld_controllerIsr+0x194> @ imm = #0x18
7009e3ba: e7ff         	b	0x7009e3bc <UART_lld_controllerIsr+0x17c> @ imm = #-0x2
;                 if (FALSE == UART_checkCharsAvailInFifo(hUart->baseAddr))
7009e3bc: 9802         	ldr	r0, [sp, #0x8]
7009e3be: 6800         	ldr	r0, [r0]
7009e3c0: f00c fda6    	bl	0x700aaf10 <UART_checkCharsAvailInFifo> @ imm = #0xcb4c
7009e3c4: b928         	cbnz	r0, 0x7009e3d2 <UART_lld_controllerIsr+0x192> @ imm = #0xa
7009e3c6: e7ff         	b	0x7009e3c8 <UART_lld_controllerIsr+0x188> @ imm = #-0x2
;                     UART_i2310WA(hUart->baseAddr);
7009e3c8: 9802         	ldr	r0, [sp, #0x8]
7009e3ca: 6800         	ldr	r0, [r0]
7009e3cc: f00d fbd8    	bl	0x700abb80 <UART_i2310WA> @ imm = #0xd7b0
;                 }
7009e3d0: e7ff         	b	0x7009e3d2 <UART_lld_controllerIsr+0x192> @ imm = #-0x2
;             }
7009e3d2: e002         	b	0x7009e3da <UART_lld_controllerIsr+0x19a> @ imm = #0x4
7009e3d4: 2000         	movs	r0, #0x0
;                 retVal = FALSE;
7009e3d6: 9001         	str	r0, [sp, #0x4]
7009e3d8: e7ff         	b	0x7009e3da <UART_lld_controllerIsr+0x19a> @ imm = #-0x2
7009e3da: e7ff         	b	0x7009e3dc <UART_lld_controllerIsr+0x19c> @ imm = #-0x2
7009e3dc: e7ff         	b	0x7009e3de <UART_lld_controllerIsr+0x19e> @ imm = #-0x2
;         while (retVal == TRUE)
7009e3de: e73c         	b	0x7009e25a <UART_lld_controllerIsr+0x1a> @ imm = #-0x188
;     }
7009e3e0: e000         	b	0x7009e3e4 <UART_lld_controllerIsr+0x1a4> @ imm = #0x0
7009e3e2: e7ff         	b	0x7009e3e4 <UART_lld_controllerIsr+0x1a4> @ imm = #-0x2
; }
7009e3e4: b006         	add	sp, #0x18
7009e3e6: bd80         	pop	{r7, pc}
		...

7009e3f0 <UART_write>:
; {
7009e3f0: b580         	push	{r7, lr}
7009e3f2: b08e         	sub	sp, #0x38
7009e3f4: 900d         	str	r0, [sp, #0x34]
7009e3f6: 910c         	str	r1, [sp, #0x30]
7009e3f8: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS, semStatus = SystemP_SUCCESS;
7009e3fa: 900b         	str	r0, [sp, #0x2c]
7009e3fc: 900a         	str	r0, [sp, #0x28]
;     if ((NULL_PTR == handle) || (NULL_PTR == trans))
7009e3fe: 980d         	ldr	r0, [sp, #0x34]
7009e400: b118         	cbz	r0, 0x7009e40a <UART_write+0x1a> @ imm = #0x6
7009e402: e7ff         	b	0x7009e404 <UART_write+0x14> @ imm = #-0x2
7009e404: 980c         	ldr	r0, [sp, #0x30]
7009e406: b920         	cbnz	r0, 0x7009e412 <UART_write+0x22> @ imm = #0x8
7009e408: e7ff         	b	0x7009e40a <UART_write+0x1a> @ imm = #-0x2
7009e40a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009e40e: 900b         	str	r0, [sp, #0x2c]
;     }
7009e410: e7ff         	b	0x7009e412 <UART_write+0x22> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009e412: 980b         	ldr	r0, [sp, #0x2c]
7009e414: 2800         	cmp	r0, #0x0
7009e416: d141         	bne	0x7009e49c <UART_write+0xac> @ imm = #0x82
7009e418: e7ff         	b	0x7009e41a <UART_write+0x2a> @ imm = #-0x2
;         config  = (UART_Config *) handle;
7009e41a: 980d         	ldr	r0, [sp, #0x34]
7009e41c: 9009         	str	r0, [sp, #0x24]
;         object  = config->object;
7009e41e: 9809         	ldr	r0, [sp, #0x24]
7009e420: 6840         	ldr	r0, [r0, #0x4]
7009e422: 9008         	str	r0, [sp, #0x20]
;         attrs   = config->attrs;
7009e424: 9809         	ldr	r0, [sp, #0x24]
7009e426: 6800         	ldr	r0, [r0]
7009e428: 9007         	str	r0, [sp, #0x1c]
;         prms    = &config->object->prms;
7009e42a: 9809         	ldr	r0, [sp, #0x24]
7009e42c: 6840         	ldr	r0, [r0, #0x4]
7009e42e: 3004         	adds	r0, #0x4
7009e430: 9006         	str	r0, [sp, #0x18]
;         uartLld_handle = object->uartLld_handle;
7009e432: 9808         	ldr	r0, [sp, #0x20]
7009e434: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009e438: 9004         	str	r0, [sp, #0x10]
;         object->writeTrans = trans;
7009e43a: 980c         	ldr	r0, [sp, #0x30]
7009e43c: 9908         	ldr	r1, [sp, #0x20]
7009e43e: f8c1 0080    	str.w	r0, [r1, #0x80]
;         DebugP_assert(NULL_PTR != object);
7009e442: 9808         	ldr	r0, [sp, #0x20]
7009e444: 2800         	cmp	r0, #0x0
7009e446: bf18         	it	ne
7009e448: 2001         	movne	r0, #0x1
7009e44a: f64f 017c    	movw	r1, #0xf87c
7009e44e: f2c7 010a    	movt	r1, #0x700a
7009e452: 466a         	mov	r2, sp
7009e454: 6011         	str	r1, [r2]
7009e456: f64f 01a2    	movw	r1, #0xf8a2
7009e45a: f2c7 010a    	movt	r1, #0x700a
7009e45e: 9101         	str	r1, [sp, #0x4]
7009e460: f64f 1282    	movw	r2, #0xf982
7009e464: f2c7 020a    	movt	r2, #0x700a
7009e468: 9202         	str	r2, [sp, #0x8]
7009e46a: f44f 7305    	mov.w	r3, #0x214
7009e46e: f00a fb97    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xa72e
7009e472: 9901         	ldr	r1, [sp, #0x4]
7009e474: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
7009e476: 9807         	ldr	r0, [sp, #0x1c]
7009e478: 2800         	cmp	r0, #0x0
7009e47a: bf18         	it	ne
7009e47c: 2001         	movne	r0, #0x1
7009e47e: f64f 03d8    	movw	r3, #0xf8d8
7009e482: f2c7 030a    	movt	r3, #0x700a
7009e486: 46ec         	mov	r12, sp
7009e488: f8cc 3000    	str.w	r3, [r12]
7009e48c: f240 2315    	movw	r3, #0x215
7009e490: f00a fb86    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xa70c
;         extendedParams.args = trans->args;
7009e494: 980c         	ldr	r0, [sp, #0x30]
7009e496: 6900         	ldr	r0, [r0, #0x10]
7009e498: 9003         	str	r0, [sp, #0xc]
;     }
7009e49a: e7ff         	b	0x7009e49c <UART_write+0xac> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009e49c: 980b         	ldr	r0, [sp, #0x2c]
7009e49e: b950         	cbnz	r0, 0x7009e4b6 <UART_write+0xc6> @ imm = #0x14
7009e4a0: e7ff         	b	0x7009e4a2 <UART_write+0xb2> @ imm = #-0x2
;         if (TRUE == prms->skipIntrReg)
7009e4a2: 9806         	ldr	r0, [sp, #0x18]
7009e4a4: 6b80         	ldr	r0, [r0, #0x38]
7009e4a6: 2801         	cmp	r0, #0x1
7009e4a8: d104         	bne	0x7009e4b4 <UART_write+0xc4> @ imm = #0x8
7009e4aa: e7ff         	b	0x7009e4ac <UART_write+0xbc> @ imm = #-0x2
7009e4ac: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009e4b0: 900b         	str	r0, [sp, #0x2c]
;         }
7009e4b2: e7ff         	b	0x7009e4b4 <UART_write+0xc4> @ imm = #-0x2
;     }
7009e4b4: e7ff         	b	0x7009e4b6 <UART_write+0xc6> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009e4b6: 980b         	ldr	r0, [sp, #0x2c]
7009e4b8: 2800         	cmp	r0, #0x0
7009e4ba: d168         	bne	0x7009e58e <UART_write+0x19e> @ imm = #0xd0
7009e4bc: e7ff         	b	0x7009e4be <UART_write+0xce> @ imm = #-0x2
;         key = HwiP_disable();
7009e4be: f00f ef68    	blx	0x700ae390 <HwiP_disable> @ imm = #0xfed0
7009e4c2: 9005         	str	r0, [sp, #0x14]
;         HwiP_restore(key);
7009e4c4: 9805         	ldr	r0, [sp, #0x14]
7009e4c6: f00f ef84    	blx	0x700ae3d0 <HwiP_restore> @ imm = #0xff08
;         uartLld_handle->state = UART_STATE_READY;
7009e4ca: 9904         	ldr	r1, [sp, #0x10]
7009e4cc: 2001         	movs	r0, #0x1
7009e4ce: 6548         	str	r0, [r1, #0x54]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
7009e4d0: 9806         	ldr	r0, [sp, #0x18]
7009e4d2: 6ac0         	ldr	r0, [r0, #0x2c]
7009e4d4: 2801         	cmp	r0, #0x1
7009e4d6: d005         	beq	0x7009e4e4 <UART_write+0xf4> @ imm = #0xa
7009e4d8: e7ff         	b	0x7009e4da <UART_write+0xea> @ imm = #-0x2
;             (UART_CONFIG_MODE_DMA == prms->transferMode))
7009e4da: 9806         	ldr	r0, [sp, #0x18]
7009e4dc: 6ac0         	ldr	r0, [r0, #0x2c]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
7009e4de: 2803         	cmp	r0, #0x3
7009e4e0: d146         	bne	0x7009e570 <UART_write+0x180> @ imm = #0x8c
7009e4e2: e7ff         	b	0x7009e4e4 <UART_write+0xf4> @ imm = #-0x2
;             if (UART_CONFIG_MODE_INTERRUPT == prms->transferMode)
7009e4e4: 9806         	ldr	r0, [sp, #0x18]
7009e4e6: 6ac0         	ldr	r0, [r0, #0x2c]
7009e4e8: 2801         	cmp	r0, #0x1
7009e4ea: d109         	bne	0x7009e500 <UART_write+0x110> @ imm = #0x12
7009e4ec: e7ff         	b	0x7009e4ee <UART_write+0xfe> @ imm = #-0x2
;                 status = UART_lld_writeIntr(uartLld_handle, trans->buf, trans->count, &extendedParams);
7009e4ee: 9804         	ldr	r0, [sp, #0x10]
7009e4f0: 9a0c         	ldr	r2, [sp, #0x30]
7009e4f2: 6811         	ldr	r1, [r2]
7009e4f4: 6852         	ldr	r2, [r2, #0x4]
7009e4f6: ab03         	add	r3, sp, #0xc
7009e4f8: f006 fdf2    	bl	0x700a50e0 <UART_lld_writeIntr> @ imm = #0x6be4
7009e4fc: 900b         	str	r0, [sp, #0x2c]
;             }
7009e4fe: e008         	b	0x7009e512 <UART_write+0x122> @ imm = #0x10
;                 status = UART_lld_writeDma(uartLld_handle, trans->buf, trans->count, &extendedParams);
7009e500: 9804         	ldr	r0, [sp, #0x10]
7009e502: 9a0c         	ldr	r2, [sp, #0x30]
7009e504: 6811         	ldr	r1, [r2]
7009e506: 6852         	ldr	r2, [r2, #0x4]
7009e508: ab03         	add	r3, sp, #0xc
7009e50a: f006 fbe1    	bl	0x700a4cd0 <UART_lld_writeDma> @ imm = #0x67c2
7009e50e: 900b         	str	r0, [sp, #0x2c]
7009e510: e7ff         	b	0x7009e512 <UART_write+0x122> @ imm = #-0x2
;             if (SystemP_SUCCESS == status)
7009e512: 980b         	ldr	r0, [sp, #0x2c]
7009e514: bb58         	cbnz	r0, 0x7009e56e <UART_write+0x17e> @ imm = #0x56
7009e516: e7ff         	b	0x7009e518 <UART_write+0x128> @ imm = #-0x2
;                 if(object->prms.writeMode == UART_TRANSFER_MODE_BLOCKING)
7009e518: 9808         	ldr	r0, [sp, #0x20]
7009e51a: 69c0         	ldr	r0, [r0, #0x1c]
7009e51c: bb18         	cbnz	r0, 0x7009e566 <UART_write+0x176> @ imm = #0x46
7009e51e: e7ff         	b	0x7009e520 <UART_write+0x130> @ imm = #-0x2
;                     semStatus = SemaphoreP_pend(&object->writeTransferSemObj, trans->timeout);
7009e520: 9808         	ldr	r0, [sp, #0x20]
7009e522: f500 70e2    	add.w	r0, r0, #0x1c4
7009e526: 990c         	ldr	r1, [sp, #0x30]
7009e528: 6889         	ldr	r1, [r1, #0x8]
7009e52a: f00a f8e1    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0xa1c2
7009e52e: 900a         	str	r0, [sp, #0x28]
;                     if (semStatus == SystemP_SUCCESS)
7009e530: 980a         	ldr	r0, [sp, #0x28]
7009e532: b960         	cbnz	r0, 0x7009e54e <UART_write+0x15e> @ imm = #0x18
7009e534: e7ff         	b	0x7009e536 <UART_write+0x146> @ imm = #-0x2
;                         if (trans->status == (uint32_t)UART_STATUS_SUCCESS)
7009e536: 980c         	ldr	r0, [sp, #0x30]
7009e538: 68c0         	ldr	r0, [r0, #0xc]
7009e53a: b918         	cbnz	r0, 0x7009e544 <UART_write+0x154> @ imm = #0x6
7009e53c: e7ff         	b	0x7009e53e <UART_write+0x14e> @ imm = #-0x2
7009e53e: 2000         	movs	r0, #0x0
;                             status = SystemP_SUCCESS;
7009e540: 900b         	str	r0, [sp, #0x2c]
;                         }
7009e542: e003         	b	0x7009e54c <UART_write+0x15c> @ imm = #0x6
7009e544: f04f 30ff    	mov.w	r0, #0xffffffff
;                             status = SystemP_FAILURE;
7009e548: 900b         	str	r0, [sp, #0x2c]
7009e54a: e7ff         	b	0x7009e54c <UART_write+0x15c> @ imm = #-0x2
;                     }
7009e54c: e00a         	b	0x7009e564 <UART_write+0x174> @ imm = #0x14
;                         trans->status = UART_TRANSFER_TIMEOUT;
7009e54e: 990c         	ldr	r1, [sp, #0x30]
7009e550: f06f 0001    	mvn	r0, #0x1
7009e554: 60c8         	str	r0, [r1, #0xc]
;                         (void)UART_writeCancelNoCB(uartLld_handle);
7009e556: 9804         	ldr	r0, [sp, #0x10]
7009e558: f009 fdb2    	bl	0x700a80c0 <UART_writeCancelNoCB> @ imm = #0x9b64
7009e55c: f04f 30ff    	mov.w	r0, #0xffffffff
;                         status = SystemP_FAILURE;
7009e560: 900b         	str	r0, [sp, #0x2c]
7009e562: e7ff         	b	0x7009e564 <UART_write+0x174> @ imm = #-0x2
;                 }
7009e564: e002         	b	0x7009e56c <UART_write+0x17c> @ imm = #0x4
7009e566: 2000         	movs	r0, #0x0
;                     status = SystemP_SUCCESS;
7009e568: 900b         	str	r0, [sp, #0x2c]
7009e56a: e7ff         	b	0x7009e56c <UART_write+0x17c> @ imm = #-0x2
;             }
7009e56c: e7ff         	b	0x7009e56e <UART_write+0x17e> @ imm = #-0x2
;         }
7009e56e: e00d         	b	0x7009e58c <UART_write+0x19c> @ imm = #0x1a
;             status = UART_lld_write(uartLld_handle, trans->buf, trans->count, trans->timeout, &extendedParams);
7009e570: 9804         	ldr	r0, [sp, #0x10]
7009e572: 9b0c         	ldr	r3, [sp, #0x30]
7009e574: 6819         	ldr	r1, [r3]
7009e576: 685a         	ldr	r2, [r3, #0x4]
7009e578: 689b         	ldr	r3, [r3, #0x8]
7009e57a: 46ee         	mov	lr, sp
7009e57c: f10d 0c0c    	add.w	r12, sp, #0xc
7009e580: f8ce c000    	str.w	r12, [lr]
7009e584: f006 f8bc    	bl	0x700a4700 <UART_lld_write> @ imm = #0x6178
7009e588: 900b         	str	r0, [sp, #0x2c]
7009e58a: e7ff         	b	0x7009e58c <UART_write+0x19c> @ imm = #-0x2
;     }
7009e58c: e7ff         	b	0x7009e58e <UART_write+0x19e> @ imm = #-0x2
;     return (status);
7009e58e: 980b         	ldr	r0, [sp, #0x2c]
7009e590: b00e         	add	sp, #0x38
7009e592: bd80         	pop	{r7, pc}
		...

7009e5a0 <Sciclient_rmClearInterruptRoute>:
; {
7009e5a0: b580         	push	{r7, lr}
7009e5a2: b08e         	sub	sp, #0x38
7009e5a4: 900d         	str	r0, [sp, #0x34]
7009e5a6: 910c         	str	r1, [sp, #0x30]
7009e5a8: 920b         	str	r2, [sp, #0x2c]
7009e5aa: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009e5ac: 9001         	str	r0, [sp, #0x4]
7009e5ae: 900a         	str	r0, [sp, #0x28]
7009e5b0: f241 0101    	movw	r1, #0x1001
;     uint16_t messageType = TISCI_MSG_RM_IRQ_RELEASE;
7009e5b4: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
7009e5b8: 9008         	str	r0, [sp, #0x20]
7009e5ba: 9007         	str	r0, [sp, #0x1c]
7009e5bc: 9006         	str	r0, [sp, #0x18]
7009e5be: 9005         	str	r0, [sp, #0x14]
7009e5c0: 9004         	str	r0, [sp, #0x10]
7009e5c2: 9003         	str	r0, [sp, #0xc]
7009e5c4: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
7009e5c6: 980d         	ldr	r0, [sp, #0x34]
7009e5c8: b118         	cbz	r0, 0x7009e5d2 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #0x6
7009e5ca: e7ff         	b	0x7009e5cc <Sciclient_rmClearInterruptRoute+0x2c> @ imm = #-0x2
7009e5cc: 980c         	ldr	r0, [sp, #0x30]
7009e5ce: b920         	cbnz	r0, 0x7009e5da <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #0x8
7009e5d0: e7ff         	b	0x7009e5d2 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #-0x2
7009e5d2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009e5d6: 900a         	str	r0, [sp, #0x28]
;     }
7009e5d8: e7ff         	b	0x7009e5da <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009e5da: 980a         	ldr	r0, [sp, #0x28]
7009e5dc: b968         	cbnz	r0, 0x7009e5fa <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0x1a
7009e5de: e7ff         	b	0x7009e5e0 <Sciclient_rmClearInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009e5e0: 980d         	ldr	r0, [sp, #0x34]
7009e5e2: 6880         	ldr	r0, [r0, #0x8]
7009e5e4: f04f 4100    	mov.w	r1, #0x80000000
7009e5e8: f00e f982    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0xe304
;     if (r == SystemP_SUCCESS &&
7009e5ec: b128         	cbz	r0, 0x7009e5fa <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0xa
7009e5ee: e7ff         	b	0x7009e5f0 <Sciclient_rmClearInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
7009e5f0: 980d         	ldr	r0, [sp, #0x34]
7009e5f2: 7ec0         	ldrb	r0, [r0, #0x1b]
7009e5f4: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
7009e5f8: e00f         	b	0x7009e61a <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
7009e5fa: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009e5fe: f007 fa17    	bl	0x700a5a30 <Sciclient_getCurrentContext> @ imm = #0x742e
7009e602: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009e606: f64e 5088    	movw	r0, #0xed88
7009e60a: f2c7 000a    	movt	r0, #0x700a
7009e60e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009e612: 6840         	ldr	r0, [r0, #0x4]
7009e614: f88d 0025    	strb.w	r0, [sp, #0x25]
7009e618: e7ff         	b	0x7009e61a <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009e61a: 980a         	ldr	r0, [sp, #0x28]
7009e61c: b960         	cbnz	r0, 0x7009e638 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0x18
7009e61e: e7ff         	b	0x7009e620 <Sciclient_rmClearInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009e620: 980d         	ldr	r0, [sp, #0x34]
7009e622: 6880         	ldr	r0, [r0, #0x8]
7009e624: 2104         	movs	r1, #0x4
7009e626: f00e f963    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0xe2c6
;     if (r == SystemP_SUCCESS &&
7009e62a: b128         	cbz	r0, 0x7009e638 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0xa
7009e62c: e7ff         	b	0x7009e62e <Sciclient_rmClearInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
7009e62e: 980d         	ldr	r0, [sp, #0x34]
7009e630: 8a80         	ldrh	r0, [r0, #0x14]
7009e632: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
7009e636: e003         	b	0x7009e640 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #0x6
7009e638: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
7009e63a: f8ad 0018    	strh.w	r0, [sp, #0x18]
7009e63e: e7ff         	b	0x7009e640 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009e640: 980a         	ldr	r0, [sp, #0x28]
7009e642: 2800         	cmp	r0, #0x0
7009e644: d175         	bne	0x7009e732 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #0xea
7009e646: e7ff         	b	0x7009e648 <Sciclient_rmClearInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
7009e648: 980d         	ldr	r0, [sp, #0x34]
7009e64a: 6880         	ldr	r0, [r0, #0x8]
7009e64c: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
7009e64e: f89d 0025    	ldrb.w	r0, [sp, #0x25]
7009e652: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
7009e656: 980d         	ldr	r0, [sp, #0x34]
7009e658: 8980         	ldrh	r0, [r0, #0xc]
7009e65a: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
7009e65e: 980d         	ldr	r0, [sp, #0x34]
7009e660: 89c0         	ldrh	r0, [r0, #0xe]
7009e662: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
7009e666: 980d         	ldr	r0, [sp, #0x34]
7009e668: 8a00         	ldrh	r0, [r0, #0x10]
7009e66a: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
7009e66e: 980d         	ldr	r0, [sp, #0x34]
7009e670: 8a40         	ldrh	r0, [r0, #0x12]
7009e672: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
7009e676: 980d         	ldr	r0, [sp, #0x34]
7009e678: 8b00         	ldrh	r0, [r0, #0x18]
7009e67a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
7009e67e: 980d         	ldr	r0, [sp, #0x34]
7009e680: 8ac0         	ldrh	r0, [r0, #0x16]
7009e682: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
7009e686: 980d         	ldr	r0, [sp, #0x34]
7009e688: 7e80         	ldrb	r0, [r0, #0x1a]
7009e68a: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
7009e68e: 9802         	ldr	r0, [sp, #0x8]
7009e690: f00b f86e    	bl	0x700a9770 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xb0dc
7009e694: b310         	cbz	r0, 0x7009e6dc <Sciclient_rmClearInterruptRoute+0x13c> @ imm = #0x44
7009e696: e7ff         	b	0x7009e698 <Sciclient_rmClearInterruptRoute+0xf8> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
7009e698: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
7009e69c: f00d ff60    	bl	0x700ac560 <Sciclient_rmIaIsIa> @ imm = #0xdec0
7009e6a0: b168         	cbz	r0, 0x7009e6be <Sciclient_rmClearInterruptRoute+0x11e> @ imm = #0x1a
7009e6a2: e7ff         	b	0x7009e6a4 <Sciclient_rmClearInterruptRoute+0x104> @ imm = #-0x2
;                 cfg.s_ia = cfg.s_id;
7009e6a4: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
7009e6a8: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                 cfg.vint = cfg.s_idx;
7009e6ac: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
7009e6b0: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e6b4: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
7009e6b6: f00c f843    	bl	0x700aa740 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xc086
7009e6ba: 900a         	str	r0, [sp, #0x28]
;             } else {
7009e6bc: e00d         	b	0x7009e6da <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #0x1a
7009e6be: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqGetRoute(&cfg);
7009e6c0: f7fd f8d6    	bl	0x7009b870 <Sciclient_rmIrqGetRoute> @ imm = #-0x2e54
7009e6c4: 900a         	str	r0, [sp, #0x28]
;                 if (r == SystemP_SUCCESS) {
7009e6c6: 980a         	ldr	r0, [sp, #0x28]
7009e6c8: b930         	cbnz	r0, 0x7009e6d8 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #0xc
7009e6ca: e7ff         	b	0x7009e6cc <Sciclient_rmClearInterruptRoute+0x12c> @ imm = #-0x2
7009e6cc: a802         	add	r0, sp, #0x8
7009e6ce: 2100         	movs	r1, #0x0
;                     r = Sciclient_rmIrqDeleteRoute(&cfg, false);
7009e6d0: f000 f9ce    	bl	0x7009ea70 <Sciclient_rmIrqDeleteRoute> @ imm = #0x39c
7009e6d4: 900a         	str	r0, [sp, #0x28]
;                 }
7009e6d6: e7ff         	b	0x7009e6d8 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #-0x2
7009e6d8: e7ff         	b	0x7009e6da <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009e6da: e029         	b	0x7009e730 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #0x52
7009e6dc: 9802         	ldr	r0, [sp, #0x8]
7009e6de: f00b f80f    	bl	0x700a9700 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xb01e
;                 true) ||
7009e6e2: b928         	cbnz	r0, 0x7009e6f0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #0xa
7009e6e4: e7ff         	b	0x7009e6e6 <Sciclient_rmClearInterruptRoute+0x146> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
7009e6e6: 9802         	ldr	r0, [sp, #0x8]
7009e6e8: f00b f87a    	bl	0x700a97e0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xb0f4
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009e6ec: b128         	cbz	r0, 0x7009e6fa <Sciclient_rmClearInterruptRoute+0x15a> @ imm = #0xa
7009e6ee: e7ff         	b	0x7009e6f0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #-0x2
7009e6f0: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintDelete(&cfg);
7009e6f2: f002 fc9d    	bl	0x700a1030 <Sciclient_rmIrqVintDelete> @ imm = #0x293a
7009e6f6: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
7009e6f8: e019         	b	0x7009e72e <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #0x32
7009e6fa: 9802         	ldr	r0, [sp, #0x8]
7009e6fc: f00b f8e0    	bl	0x700a98c0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xb1c0
7009e700: b128         	cbz	r0, 0x7009e70e <Sciclient_rmClearInterruptRoute+0x16e> @ imm = #0xa
7009e702: e7ff         	b	0x7009e704 <Sciclient_rmClearInterruptRoute+0x164> @ imm = #-0x2
7009e704: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
7009e706: f00c f81b    	bl	0x700aa740 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xc036
7009e70a: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
7009e70c: e00e         	b	0x7009e72c <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #0x1c
7009e70e: 9802         	ldr	r0, [sp, #0x8]
7009e710: f00b f89e    	bl	0x700a9850 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xb13c
7009e714: b128         	cbz	r0, 0x7009e722 <Sciclient_rmClearInterruptRoute+0x182> @ imm = #0xa
7009e716: e7ff         	b	0x7009e718 <Sciclient_rmClearInterruptRoute+0x178> @ imm = #-0x2
7009e718: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqClearOesRegister(&cfg);
7009e71a: f00d faf1    	bl	0x700abd00 <Sciclient_rmIrqClearOesRegister> @ imm = #0xd5e2
7009e71e: 900a         	str	r0, [sp, #0x28]
;         } else {
7009e720: e003         	b	0x7009e72a <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #0x6
7009e722: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
7009e726: 900a         	str	r0, [sp, #0x28]
7009e728: e7ff         	b	0x7009e72a <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #-0x2
7009e72a: e7ff         	b	0x7009e72c <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #-0x2
7009e72c: e7ff         	b	0x7009e72e <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #-0x2
7009e72e: e7ff         	b	0x7009e730 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #-0x2
;     }
7009e730: e7ff         	b	0x7009e732 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #-0x2
;     return r;
7009e732: 980a         	ldr	r0, [sp, #0x28]
7009e734: b00e         	add	sp, #0x38
7009e736: bd80         	pop	{r7, pc}
		...

7009e740 <Udma_chConfigTx>:
; {
7009e740: b580         	push	{r7, lr}
7009e742: b090         	sub	sp, #0x40
7009e744: 900f         	str	r0, [sp, #0x3c]
7009e746: 910e         	str	r1, [sp, #0x38]
7009e748: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009e74a: 900d         	str	r0, [sp, #0x34]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
7009e74c: 980f         	ldr	r0, [sp, #0x3c]
7009e74e: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
7009e750: 980b         	ldr	r0, [sp, #0x2c]
7009e752: b178         	cbz	r0, 0x7009e774 <Udma_chConfigTx+0x34> @ imm = #0x1e
7009e754: e7ff         	b	0x7009e756 <Udma_chConfigTx+0x16> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009e756: 980b         	ldr	r0, [sp, #0x2c]
7009e758: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009e75c: f64a 31cd    	movw	r1, #0xabcd
7009e760: f6ca 31dc    	movt	r1, #0xabdc
7009e764: 4288         	cmp	r0, r1
7009e766: d105         	bne	0x7009e774 <Udma_chConfigTx+0x34> @ imm = #0xa
7009e768: e7ff         	b	0x7009e76a <Udma_chConfigTx+0x2a> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_TX) != UDMA_CH_FLAG_TX))
7009e76a: 980b         	ldr	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
7009e76c: 7800         	ldrb	r0, [r0]
7009e76e: 07c0         	lsls	r0, r0, #0x1f
7009e770: b920         	cbnz	r0, 0x7009e77c <Udma_chConfigTx+0x3c> @ imm = #0x8
7009e772: e7ff         	b	0x7009e774 <Udma_chConfigTx+0x34> @ imm = #-0x2
7009e774: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009e778: 900d         	str	r0, [sp, #0x34]
;     }
7009e77a: e7ff         	b	0x7009e77c <Udma_chConfigTx+0x3c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e77c: 980d         	ldr	r0, [sp, #0x34]
7009e77e: b9a8         	cbnz	r0, 0x7009e7ac <Udma_chConfigTx+0x6c> @ imm = #0x2a
7009e780: e7ff         	b	0x7009e782 <Udma_chConfigTx+0x42> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009e782: 980b         	ldr	r0, [sp, #0x2c]
7009e784: 6e80         	ldr	r0, [r0, #0x68]
7009e786: 900c         	str	r0, [sp, #0x30]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009e788: 980c         	ldr	r0, [sp, #0x30]
7009e78a: b150         	cbz	r0, 0x7009e7a2 <Udma_chConfigTx+0x62> @ imm = #0x14
7009e78c: e7ff         	b	0x7009e78e <Udma_chConfigTx+0x4e> @ imm = #-0x2
7009e78e: 980c         	ldr	r0, [sp, #0x30]
7009e790: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009e794: f64a 31cd    	movw	r1, #0xabcd
7009e798: f6ca 31dc    	movt	r1, #0xabdc
7009e79c: 4288         	cmp	r0, r1
7009e79e: d004         	beq	0x7009e7aa <Udma_chConfigTx+0x6a> @ imm = #0x8
7009e7a0: e7ff         	b	0x7009e7a2 <Udma_chConfigTx+0x62> @ imm = #-0x2
7009e7a2: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009e7a6: 900d         	str	r0, [sp, #0x34]
;         }
7009e7a8: e7ff         	b	0x7009e7aa <Udma_chConfigTx+0x6a> @ imm = #-0x2
;     }
7009e7aa: e7ff         	b	0x7009e7ac <Udma_chConfigTx+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e7ac: 980d         	ldr	r0, [sp, #0x34]
7009e7ae: 2800         	cmp	r0, #0x0
7009e7b0: f040 808e    	bne.w	0x7009e8d0 <Udma_chConfigTx+0x190> @ imm = #0x11c
7009e7b4: e7ff         	b	0x7009e7b6 <Udma_chConfigTx+0x76> @ imm = #-0x2
7009e7b6: f647 70ff    	movw	r0, #0x7fff
;         rmUdmaTxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
7009e7ba: 9004         	str	r0, [sp, #0x10]
;         rmUdmaTxReq.nav_id              = drvHandle->devIdUdma;
7009e7bc: 980c         	ldr	r0, [sp, #0x30]
7009e7be: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009e7c2: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmUdmaTxReq.index               = (uint16_t)chHandleInt->txChNum;
7009e7c6: 980b         	ldr	r0, [sp, #0x2c]
7009e7c8: 6ec0         	ldr	r0, [r0, #0x6c]
7009e7ca: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmUdmaTxReq.tx_pause_on_err     = txPrms->pauseOnError;
7009e7ce: 980e         	ldr	r0, [sp, #0x38]
7009e7d0: 7800         	ldrb	r0, [r0]
7009e7d2: f88d 0018    	strb.w	r0, [sp, #0x18]
;         rmUdmaTxReq.tx_filt_einfo       = txPrms->filterEinfo;
7009e7d6: 980e         	ldr	r0, [sp, #0x38]
7009e7d8: 7840         	ldrb	r0, [r0, #0x1]
7009e7da: f88d 0019    	strb.w	r0, [sp, #0x19]
;         rmUdmaTxReq.tx_filt_pswords     = txPrms->filterPsWords;
7009e7de: 980e         	ldr	r0, [sp, #0x38]
7009e7e0: 7880         	ldrb	r0, [r0, #0x2]
7009e7e2: f88d 001a    	strb.w	r0, [sp, #0x1a]
;         rmUdmaTxReq.tx_atype            = txPrms->addrType;
7009e7e6: 980e         	ldr	r0, [sp, #0x38]
7009e7e8: 78c0         	ldrb	r0, [r0, #0x3]
7009e7ea: f88d 001b    	strb.w	r0, [sp, #0x1b]
;         rmUdmaTxReq.tx_chan_type        = txPrms->chanType;
7009e7ee: 980e         	ldr	r0, [sp, #0x38]
7009e7f0: 7900         	ldrb	r0, [r0, #0x4]
7009e7f2: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         rmUdmaTxReq.tx_fetch_size       = txPrms->fetchWordSize;
7009e7f6: 980e         	ldr	r0, [sp, #0x38]
7009e7f8: 88c0         	ldrh	r0, [r0, #0x6]
7009e7fa: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmUdmaTxReq.tx_priority         = txPrms->busPriority;
7009e7fe: 980e         	ldr	r0, [sp, #0x38]
7009e800: 7a00         	ldrb	r0, [r0, #0x8]
7009e802: f88d 0023    	strb.w	r0, [sp, #0x23]
;         rmUdmaTxReq.tx_qos              = txPrms->busQos;
7009e806: 980e         	ldr	r0, [sp, #0x38]
7009e808: 7a40         	ldrb	r0, [r0, #0x9]
7009e80a: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmUdmaTxReq.tx_orderid          = txPrms->busOrderId;
7009e80e: 980e         	ldr	r0, [sp, #0x38]
7009e810: 7a80         	ldrb	r0, [r0, #0xa]
7009e812: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmUdmaTxReq.fdepth              = txPrms->fifoDepth;
7009e816: 980e         	ldr	r0, [sp, #0x38]
7009e818: 89c0         	ldrh	r0, [r0, #0xe]
7009e81a: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmUdmaTxReq.tx_burst_size       = txPrms->burstSize;
7009e81e: 980e         	ldr	r0, [sp, #0x38]
7009e820: 7c00         	ldrb	r0, [r0, #0x10]
7009e822: f88d 0029    	strb.w	r0, [sp, #0x29]
;         rmUdmaTxReq.tx_sched_priority   = txPrms->dmaPriority;
7009e826: 980e         	ldr	r0, [sp, #0x38]
7009e828: 7ac0         	ldrb	r0, [r0, #0xb]
7009e82a: f88d 0028    	strb.w	r0, [sp, #0x28]
;         rmUdmaTxReq.tx_credit_count     = txPrms->txCredit;
7009e82e: 980e         	ldr	r0, [sp, #0x38]
7009e830: 7b00         	ldrb	r0, [r0, #0xc]
7009e832: f88d 0020    	strb.w	r0, [sp, #0x20]
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009e836: 980c         	ldr	r0, [sp, #0x30]
7009e838: 6800         	ldr	r0, [r0]
7009e83a: 2801         	cmp	r0, #0x1
7009e83c: d11d         	bne	0x7009e87a <Udma_chConfigTx+0x13a> @ imm = #0x3a
7009e83e: e7ff         	b	0x7009e840 <Udma_chConfigTx+0x100> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009e840: 980b         	ldr	r0, [sp, #0x2c]
7009e842: 7800         	ldrb	r0, [r0]
7009e844: 0740         	lsls	r0, r0, #0x1d
7009e846: 2800         	cmp	r0, #0x0
7009e848: d508         	bpl	0x7009e85c <Udma_chConfigTx+0x11c> @ imm = #0x10
7009e84a: e7ff         	b	0x7009e84c <Udma_chConfigTx+0x10c> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
7009e84c: 9804         	ldr	r0, [sp, #0x10]
7009e84e: f440 3080    	orr	r0, r0, #0x10000
7009e852: 9004         	str	r0, [sp, #0x10]
7009e854: 2001         	movs	r0, #0x1
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_BLK_CPY;
7009e856: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
7009e85a: e00d         	b	0x7009e878 <Udma_chConfigTx+0x138> @ imm = #0x1a
;             else if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009e85c: 980b         	ldr	r0, [sp, #0x2c]
7009e85e: 7800         	ldrb	r0, [r0]
7009e860: 07c0         	lsls	r0, r0, #0x1f
7009e862: b140         	cbz	r0, 0x7009e876 <Udma_chConfigTx+0x136> @ imm = #0x10
7009e864: e7ff         	b	0x7009e866 <Udma_chConfigTx+0x126> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
7009e866: 9804         	ldr	r0, [sp, #0x10]
7009e868: f440 3080    	orr	r0, r0, #0x10000
7009e86c: 9004         	str	r0, [sp, #0x10]
7009e86e: 2000         	movs	r0, #0x0
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_SPLIT_TR_TX;
7009e870: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
7009e874: e7ff         	b	0x7009e876 <Udma_chConfigTx+0x136> @ imm = #-0x2
7009e876: e7ff         	b	0x7009e878 <Udma_chConfigTx+0x138> @ imm = #-0x2
;         }
7009e878: e7ff         	b	0x7009e87a <Udma_chConfigTx+0x13a> @ imm = #-0x2
;         if(NULL_PTR != chHandleInt->tdCqRing)
7009e87a: 980b         	ldr	r0, [sp, #0x2c]
7009e87c: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009e880: b158         	cbz	r0, 0x7009e89a <Udma_chConfigTx+0x15a> @ imm = #0x16
7009e882: e7ff         	b	0x7009e884 <Udma_chConfigTx+0x144> @ imm = #-0x2
;             rmUdmaTxReq.txcq_qnum       = chHandleInt->tdCqRing->ringNum;
7009e884: 980b         	ldr	r0, [sp, #0x2c]
7009e886: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009e88a: 8880         	ldrh	r0, [r0, #0x4]
7009e88c: f8ad 0021    	strh.w	r0, [sp, #0x21]
;             rmUdmaTxReq.tx_supr_tdpkt   = txPrms->supressTdCqPkt;
7009e890: 980e         	ldr	r0, [sp, #0x38]
7009e892: 7c40         	ldrb	r0, [r0, #0x11]
7009e894: f88d 001d    	strb.w	r0, [sp, #0x1d]
;         }
7009e898: e007         	b	0x7009e8aa <Udma_chConfigTx+0x16a> @ imm = #0xe
7009e89a: f64f 70ff    	movw	r0, #0xffff
;             rmUdmaTxReq.txcq_qnum       = UDMA_RING_INVALID;
7009e89e: f8ad 0021    	strh.w	r0, [sp, #0x21]
7009e8a2: 2001         	movs	r0, #0x1
;             rmUdmaTxReq.tx_supr_tdpkt   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_ENABLED;
7009e8a4: f88d 001d    	strb.w	r0, [sp, #0x1d]
7009e8a8: e7ff         	b	0x7009e8aa <Udma_chConfigTx+0x16a> @ imm = #-0x2
7009e8aa: a802         	add	r0, sp, #0x8
7009e8ac: 4669         	mov	r1, sp
7009e8ae: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapTxChCfg(
7009e8b2: f00c f835    	bl	0x700aa920 <Sciclient_rmUdmapTxChCfg> @ imm = #0xc06a
7009e8b6: 900d         	str	r0, [sp, #0x34]
;         if(CSL_PASS != retVal)
7009e8b8: 980d         	ldr	r0, [sp, #0x34]
7009e8ba: b108         	cbz	r0, 0x7009e8c0 <Udma_chConfigTx+0x180> @ imm = #0x2
7009e8bc: e7ff         	b	0x7009e8be <Udma_chConfigTx+0x17e> @ imm = #-0x2
;         }
7009e8be: e7ff         	b	0x7009e8c0 <Udma_chConfigTx+0x180> @ imm = #-0x2
;         (void) memcpy(&chHandleInt->txPrms, txPrms, sizeof(chHandleInt->txPrms));
7009e8c0: 980b         	ldr	r0, [sp, #0x2c]
7009e8c2: f500 70f2    	add.w	r0, r0, #0x1e4
7009e8c6: 990e         	ldr	r1, [sp, #0x38]
7009e8c8: 2212         	movs	r2, #0x12
7009e8ca: f7fc e888    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0x3ef0
;     }
7009e8ce: e7ff         	b	0x7009e8d0 <Udma_chConfigTx+0x190> @ imm = #-0x2
;     return (retVal);
7009e8d0: 980d         	ldr	r0, [sp, #0x34]
7009e8d2: b010         	add	sp, #0x40
7009e8d4: bd80         	pop	{r7, pc}
		...
7009e8de: 0000         	movs	r0, r0

7009e8e0 <ClockP_init>:
; {
7009e8e0: b580         	push	{r7, lr}
7009e8e2: b096         	sub	sp, #0x58
;     DebugP_assert( gClockConfig.timerInputPreScaler != 0U);
7009e8e4: f240 1008    	movw	r0, #0x108
7009e8e8: f2c7 000b    	movt	r0, #0x700b
7009e8ec: 9009         	str	r0, [sp, #0x24]
7009e8ee: 68c0         	ldr	r0, [r0, #0xc]
7009e8f0: 2800         	cmp	r0, #0x0
7009e8f2: bf18         	it	ne
7009e8f4: 2001         	movne	r0, #0x1
7009e8f6: f24f 4192    	movw	r1, #0xf492
7009e8fa: f2c7 010a    	movt	r1, #0x700a
7009e8fe: 466a         	mov	r2, sp
7009e900: 6011         	str	r1, [r2]
7009e902: f24f 61c5    	movw	r1, #0xf6c5
7009e906: f2c7 010a    	movt	r1, #0x700a
7009e90a: 9107         	str	r1, [sp, #0x1c]
7009e90c: f64f 126a    	movw	r2, #0xf96a
7009e910: f2c7 020a    	movt	r2, #0x700a
7009e914: 9208         	str	r2, [sp, #0x20]
7009e916: 2334         	movs	r3, #0x34
7009e918: f00a f942    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xa284
7009e91c: 9907         	ldr	r1, [sp, #0x1c]
7009e91e: 9a08         	ldr	r2, [sp, #0x20]
7009e920: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerInputClkHz != 0U);
7009e922: 6880         	ldr	r0, [r0, #0x8]
7009e924: 2800         	cmp	r0, #0x0
7009e926: bf18         	it	ne
7009e928: 2001         	movne	r0, #0x1
7009e92a: f24f 5304    	movw	r3, #0xf504
7009e92e: f2c7 030a    	movt	r3, #0x700a
7009e932: 46ec         	mov	r12, sp
7009e934: f8cc 3000    	str.w	r3, [r12]
7009e938: 2335         	movs	r3, #0x35
7009e93a: f00a f931    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xa262
7009e93e: 9907         	ldr	r1, [sp, #0x1c]
7009e940: 9a08         	ldr	r2, [sp, #0x20]
7009e942: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.usecPerTick != 0U);
7009e944: 6900         	ldr	r0, [r0, #0x10]
7009e946: 2800         	cmp	r0, #0x0
7009e948: bf18         	it	ne
7009e94a: 2001         	movne	r0, #0x1
7009e94c: f24f 6310    	movw	r3, #0xf610
7009e950: f2c7 030a    	movt	r3, #0x700a
7009e954: 46ec         	mov	r12, sp
7009e956: f8cc 3000    	str.w	r3, [r12]
7009e95a: 2336         	movs	r3, #0x36
7009e95c: f00a f920    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xa240
7009e960: 9907         	ldr	r1, [sp, #0x1c]
7009e962: 9a08         	ldr	r2, [sp, #0x20]
7009e964: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerBaseAddr != 0U);
7009e966: 6800         	ldr	r0, [r0]
7009e968: 2800         	cmp	r0, #0x0
7009e96a: bf18         	it	ne
7009e96c: 2001         	movne	r0, #0x1
7009e96e: f24f 538d    	movw	r3, #0xf58d
7009e972: f2c7 030a    	movt	r3, #0x700a
7009e976: 46ec         	mov	r12, sp
7009e978: f8cc 3000    	str.w	r3, [r12]
7009e97c: 2337         	movs	r3, #0x37
7009e97e: f00a f90f    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0xa21e
7009e982: 9809         	ldr	r0, [sp, #0x24]
;     gClockCtrl.ticks = 0;
7009e984: f644 6298    	movw	r2, #0x4e98
7009e988: f2c7 0208    	movt	r2, #0x7008
7009e98c: 2100         	movs	r1, #0x0
7009e98e: 6051         	str	r1, [r2, #0x4]
7009e990: 6011         	str	r1, [r2]
;     gClockCtrl.usecPerTick = gClockConfig.usecPerTick;
7009e992: 6903         	ldr	r3, [r0, #0x10]
7009e994: 6093         	str	r3, [r2, #0x8]
;     gClockCtrl.timerBaseAddr = gClockConfig.timerBaseAddr;
7009e996: 6800         	ldr	r0, [r0]
7009e998: 62d0         	str	r0, [r2, #0x2c]
7009e99a: f244 2040    	movw	r0, #0x4240
7009e99e: f2c0 000f    	movt	r0, #0xf
;     if( pdMS_TO_TICKS( TIME_IN_MILLI_SECONDS ) != ClockP_usecToTicks( TIME_IN_MICRO_SECONDS ) )
7009e9a2: f00e fa9d    	bl	0x700acee0 <ClockP_usecToTicks> @ imm = #0xe53a
7009e9a6: f5b0 7f7a    	cmp.w	r0, #0x3e8
7009e9aa: d01d         	beq	0x7009e9e8 <ClockP_init+0x108> @ imm = #0x3a
7009e9ac: e7ff         	b	0x7009e9ae <ClockP_init+0xce> @ imm = #-0x2
;         DebugP_logWarn("FreeRTOS configTICK_RATE_HZ (%d), does not match ClockP tick rate Hz (%d)\r\n",
7009e9ae: f240 1008    	movw	r0, #0x108
7009e9b2: f2c7 000b    	movt	r0, #0x700b
7009e9b6: 6901         	ldr	r1, [r0, #0x10]
7009e9b8: f244 2040    	movw	r0, #0x4240
7009e9bc: f2c0 000f    	movt	r0, #0xf
7009e9c0: fbb0 f0f1    	udiv	r0, r0, r1
7009e9c4: 4669         	mov	r1, sp
7009e9c6: 6048         	str	r0, [r1, #0x4]
7009e9c8: f44f 707a    	mov.w	r0, #0x3e8
7009e9cc: 6008         	str	r0, [r1]
7009e9ce: f24f 1190    	movw	r1, #0xf190
7009e9d2: f2c7 010a    	movt	r1, #0x700a
7009e9d6: f64f 126a    	movw	r2, #0xf96a
7009e9da: f2c7 020a    	movt	r2, #0x700a
7009e9de: 2004         	movs	r0, #0x4
7009e9e0: 2346         	movs	r3, #0x46
7009e9e2: f009 f91d    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #0x923a
;     }
7009e9e6: e7ff         	b	0x7009e9e8 <ClockP_init+0x108> @ imm = #-0x2
7009e9e8: a80f         	add	r0, sp, #0x3c
;     TimerP_Params_init(&timerParams);
7009e9ea: 9002         	str	r0, [sp, #0x8]
7009e9ec: f00d fbe8    	bl	0x700ac1c0 <TimerP_Params_init> @ imm = #0xd7d0
7009e9f0: 9902         	ldr	r1, [sp, #0x8]
;     timerParams.inputPreScaler    = gClockConfig.timerInputPreScaler;
7009e9f2: f240 1008    	movw	r0, #0x108
7009e9f6: f2c7 000b    	movt	r0, #0x700b
7009e9fa: 9004         	str	r0, [sp, #0x10]
7009e9fc: 68c2         	ldr	r2, [r0, #0xc]
7009e9fe: 920f         	str	r2, [sp, #0x3c]
;     timerParams.inputClkHz        = gClockConfig.timerInputClkHz;
7009ea00: 6882         	ldr	r2, [r0, #0x8]
7009ea02: 9210         	str	r2, [sp, #0x40]
;     timerParams.periodInUsec      = gClockConfig.usecPerTick;
7009ea04: 6900         	ldr	r0, [r0, #0x10]
7009ea06: 9011         	str	r0, [sp, #0x44]
7009ea08: 2000         	movs	r0, #0x0
;     timerParams.oneshotMode       = 0;
7009ea0a: 9003         	str	r0, [sp, #0xc]
7009ea0c: 9013         	str	r0, [sp, #0x4c]
7009ea0e: 2001         	movs	r0, #0x1
;     timerParams.enableOverflowInt = 1;
7009ea10: 9014         	str	r0, [sp, #0x50]
;     TimerP_setup(gClockCtrl.timerBaseAddr, &timerParams);
7009ea12: f644 6098    	movw	r0, #0x4e98
7009ea16: f2c7 0008    	movt	r0, #0x7008
7009ea1a: 9006         	str	r0, [sp, #0x18]
7009ea1c: 6ac0         	ldr	r0, [r0, #0x2c]
7009ea1e: f7fd fe4f    	bl	0x7009c6c0 <TimerP_setup> @ imm = #-0x2362
7009ea22: 9806         	ldr	r0, [sp, #0x18]
;     gClockCtrl.timerReloadCount = TimerP_getReloadCount(gClockCtrl.timerBaseAddr);
7009ea24: 6ac0         	ldr	r0, [r0, #0x2c]
7009ea26: f00e fd6b    	bl	0x700ad500 <TimerP_getReloadCount> @ imm = #0xead6
7009ea2a: 9906         	ldr	r1, [sp, #0x18]
7009ea2c: 6308         	str	r0, [r1, #0x30]
7009ea2e: a80a         	add	r0, sp, #0x28
;     HwiP_Params_init(&timerHwiParams);
7009ea30: 9005         	str	r0, [sp, #0x14]
7009ea32: f00e ffa5    	bl	0x700ad980 <HwiP_Params_init> @ imm = #0xef4a
7009ea36: 9b03         	ldr	r3, [sp, #0xc]
7009ea38: 9a04         	ldr	r2, [sp, #0x10]
7009ea3a: 9905         	ldr	r1, [sp, #0x14]
7009ea3c: 9806         	ldr	r0, [sp, #0x18]
;     timerHwiParams.intNum = gClockConfig.timerHwiIntNum;
7009ea3e: f8d2 c004    	ldr.w	r12, [r2, #0x4]
7009ea42: f8cd c028    	str.w	r12, [sp, #0x28]
;     timerHwiParams.callback = ClockP_timerTickIsr;
7009ea46: f24c 2cf1    	movw	r12, #0xc2f1
7009ea4a: f2c7 0c0a    	movt	r12, #0x700a
7009ea4e: f8cd c02c    	str.w	r12, [sp, #0x2c]
;     timerHwiParams.isPulse = 0;
7009ea52: f88d 3038    	strb.w	r3, [sp, #0x38]
;     timerHwiParams.priority = gClockConfig.intrPriority;
7009ea56: 7d12         	ldrb	r2, [r2, #0x14]
7009ea58: f88d 2036    	strb.w	r2, [sp, #0x36]
;     (void)HwiP_construct(&gClockCtrl.timerHwiObj, &timerHwiParams);
7009ea5c: 300c         	adds	r0, #0xc
7009ea5e: f00e ffa7    	bl	0x700ad9b0 <HwiP_construct> @ imm = #0xef4e
;     TimerP_start(gClockCtrl.timerBaseAddr);
7009ea62: 9806         	ldr	r0, [sp, #0x18]
7009ea64: 6ac0         	ldr	r0, [r0, #0x2c]
7009ea66: f00e fbdb    	bl	0x700ad220 <TimerP_start> @ imm = #0xe7b6
; }
7009ea6a: b016         	add	sp, #0x58
7009ea6c: bd80         	pop	{r7, pc}
7009ea6e: 0000         	movs	r0, r0

7009ea70 <Sciclient_rmIrqDeleteRoute>:
; {
7009ea70: b580         	push	{r7, lr}
7009ea72: b090         	sub	sp, #0x40
7009ea74: 900f         	str	r0, [sp, #0x3c]
7009ea76: f88d 103b    	strb.w	r1, [sp, #0x3b]
7009ea7a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009ea7c: 900d         	str	r0, [sp, #0x34]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
7009ea7e: 9002         	str	r0, [sp, #0x8]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
7009ea80: 9001         	str	r0, [sp, #0x4]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009ea82: f8ad 0032    	strh.w	r0, [sp, #0x32]
7009ea86: e7ff         	b	0x7009ea88 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x2
7009ea88: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009ea8c: 9000         	str	r0, [sp]
7009ea8e: f00e fe57    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0xecae
7009ea92: 4601         	mov	r1, r0
7009ea94: 9800         	ldr	r0, [sp]
7009ea96: 4288         	cmp	r0, r1
7009ea98: f280 80ac    	bge.w	0x7009ebf4 <Sciclient_rmIrqDeleteRoute+0x184> @ imm = #0x158
7009ea9c: e7ff         	b	0x7009ea9e <Sciclient_rmIrqDeleteRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
7009ea9e: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009eaa2: f00e fa8d    	bl	0x700acfc0 <Sciclient_rmPsGetIrqNode> @ imm = #0xe51a
7009eaa6: 900b         	str	r0, [sp, #0x2c]
;         cur_inp = Sciclient_rmPsGetInp(i);
7009eaa8: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009eaac: f00c ff88    	bl	0x700ab9c0 <Sciclient_rmPsGetInp> @ imm = #0xcf10
7009eab0: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;         cur_outp = Sciclient_rmPsGetOutp(i);
7009eab4: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009eab8: f00c ffa2    	bl	0x700aba00 <Sciclient_rmPsGetOutp> @ imm = #0xcf44
7009eabc: f8ad 0028    	strh.w	r0, [sp, #0x28]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009eac0: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009eac4: 2800         	cmp	r0, #0x0
7009eac6: d156         	bne	0x7009eb76 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0xac
7009eac8: e7ff         	b	0x7009eaca <Sciclient_rmIrqDeleteRoute+0x5a> @ imm = #-0x2
7009eaca: 980b         	ldr	r0, [sp, #0x2c]
7009eacc: 8800         	ldrh	r0, [r0]
7009eace: f00d fd47    	bl	0x700ac560 <Sciclient_rmIaIsIa> @ imm = #0xda8e
7009ead2: 2800         	cmp	r0, #0x0
7009ead4: d04f         	beq	0x7009eb76 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x9e
7009ead6: e7ff         	b	0x7009ead8 <Sciclient_rmIrqDeleteRoute+0x68> @ imm = #-0x2
;             (unmap_vint == true)) {
7009ead8: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009eadc: 07c0         	lsls	r0, r0, #0x1f
7009eade: 2800         	cmp	r0, #0x0
7009eae0: d049         	beq	0x7009eb76 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x92
7009eae2: e7ff         	b	0x7009eae4 <Sciclient_rmIrqDeleteRoute+0x74> @ imm = #-0x2
7009eae4: 203c         	movs	r0, #0x3c
7009eae6: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
7009eaea: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
7009eaec: 980f         	ldr	r0, [sp, #0x3c]
7009eaee: 7900         	ldrb	r0, [r0, #0x4]
7009eaf0: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cfg->s_id;
7009eaf4: 980f         	ldr	r0, [sp, #0x3c]
7009eaf6: 88c0         	ldrh	r0, [r0, #0x6]
7009eaf8: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cfg->s_idx;
7009eafc: 980f         	ldr	r0, [sp, #0x3c]
7009eafe: 8900         	ldrh	r0, [r0, #0x8]
7009eb00: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.ia_id = cfg->s_ia;
7009eb04: 980f         	ldr	r0, [sp, #0x3c]
7009eb06: 8a00         	ldrh	r0, [r0, #0x10]
7009eb08: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.vint = cur_outp;
7009eb0c: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
7009eb10: f8ad 0022    	strh.w	r0, [sp, #0x22]
;             req.global_event = cur_inp;
7009eb14: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009eb18: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint_status_bit_index = cfg->vint_sb;
7009eb1c: 980f         	ldr	r0, [sp, #0x3c]
7009eb1e: 7d00         	ldrb	r0, [r0, #0x14]
7009eb20: f88d 0026    	strb.w	r0, [sp, #0x26]
7009eb24: a803         	add	r0, sp, #0xc
7009eb26: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
7009eb2a: f00b ff29    	bl	0x700aa980 <Sciclient_rmIrqReleaseRaw> @ imm = #0xbe52
7009eb2e: 900d         	str	r0, [sp, #0x34]
;             if (r == SystemP_SUCCESS) {
7009eb30: 980d         	ldr	r0, [sp, #0x34]
7009eb32: b9f8         	cbnz	r0, 0x7009eb74 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #0x3e
7009eb34: e7ff         	b	0x7009eb36 <Sciclient_rmIrqDeleteRoute+0xc6> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
7009eb36: 980b         	ldr	r0, [sp, #0x2c]
7009eb38: 8800         	ldrh	r0, [r0]
7009eb3a: f00b fc51    	bl	0x700aa3e0 <Sciclient_rmIaGetInst> @ imm = #0xb8a2
7009eb3e: 9002         	str	r0, [sp, #0x8]
;                 if (ia_inst != NULL) {
7009eb40: 9802         	ldr	r0, [sp, #0x8]
7009eb42: b1b0         	cbz	r0, 0x7009eb72 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #0x2c
7009eb44: e7ff         	b	0x7009eb46 <Sciclient_rmIrqDeleteRoute+0xd6> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]--;
7009eb46: 9802         	ldr	r0, [sp, #0x8]
7009eb48: 6901         	ldr	r1, [r0, #0x10]
7009eb4a: f8bd 2028    	ldrh.w	r2, [sp, #0x28]
7009eb4e: 5c88         	ldrb	r0, [r1, r2]
7009eb50: 3801         	subs	r0, #0x1
7009eb52: 5488         	strb	r0, [r1, r2]
;                     if (ia_inst->v0_b0_evt == cur_inp - ia_inst->sevt_offset) {
7009eb54: 9a02         	ldr	r2, [sp, #0x8]
7009eb56: 8a90         	ldrh	r0, [r2, #0x14]
7009eb58: f8bd 102a    	ldrh.w	r1, [sp, #0x2a]
7009eb5c: 8912         	ldrh	r2, [r2, #0x8]
7009eb5e: 1a89         	subs	r1, r1, r2
7009eb60: 4288         	cmp	r0, r1
7009eb62: d105         	bne	0x7009eb70 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #0xa
7009eb64: e7ff         	b	0x7009eb66 <Sciclient_rmIrqDeleteRoute+0xf6> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
7009eb66: 9902         	ldr	r1, [sp, #0x8]
7009eb68: f64f 70ff    	movw	r0, #0xffff
7009eb6c: 8288         	strh	r0, [r1, #0x14]
;                     }
7009eb6e: e7ff         	b	0x7009eb70 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #-0x2
;                 }
7009eb70: e7ff         	b	0x7009eb72 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #-0x2
;             }
7009eb72: e7ff         	b	0x7009eb74 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #-0x2
;         }
7009eb74: e7ff         	b	0x7009eb76 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #-0x2
;         if (i > 0u) {
7009eb76: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009eb7a: b3a0         	cbz	r0, 0x7009ebe6 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #0x68
7009eb7c: e7ff         	b	0x7009eb7e <Sciclient_rmIrqDeleteRoute+0x10e> @ imm = #-0x2
7009eb7e: 2003         	movs	r0, #0x3
7009eb80: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
7009eb84: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
7009eb86: 980f         	ldr	r0, [sp, #0x3c]
7009eb88: 7900         	ldrb	r0, [r0, #0x4]
7009eb8a: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cur_n->id;
7009eb8e: 980b         	ldr	r0, [sp, #0x2c]
7009eb90: 8800         	ldrh	r0, [r0]
7009eb92: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cur_inp;
7009eb96: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009eb9a: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.dst_id = cur_n->id;
7009eb9e: 980b         	ldr	r0, [sp, #0x2c]
7009eba0: 8800         	ldrh	r0, [r0]
7009eba2: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.dst_host_irq = cur_outp;
7009eba6: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
7009ebaa: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009ebae: a803         	add	r0, sp, #0xc
7009ebb0: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
7009ebb4: f00b fee4    	bl	0x700aa980 <Sciclient_rmIrqReleaseRaw> @ imm = #0xbdc8
7009ebb8: 900d         	str	r0, [sp, #0x34]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
7009ebba: 980d         	ldr	r0, [sp, #0x34]
7009ebbc: b990         	cbnz	r0, 0x7009ebe4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x24
7009ebbe: e7ff         	b	0x7009ebc0 <Sciclient_rmIrqDeleteRoute+0x150> @ imm = #-0x2
7009ebc0: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
7009ebc4: b970         	cbnz	r0, 0x7009ebe4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x1c
7009ebc6: e7ff         	b	0x7009ebc8 <Sciclient_rmIrqDeleteRoute+0x158> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
7009ebc8: 980b         	ldr	r0, [sp, #0x2c]
7009ebca: 8800         	ldrh	r0, [r0]
7009ebcc: f00a ff20    	bl	0x700a9a10 <Sciclient_rmIrGetInst> @ imm = #0xae40
7009ebd0: 9001         	str	r0, [sp, #0x4]
;                 if (ir_inst != NULL) {
7009ebd2: 9801         	ldr	r0, [sp, #0x4]
7009ebd4: b128         	cbz	r0, 0x7009ebe2 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #0xa
7009ebd6: e7ff         	b	0x7009ebd8 <Sciclient_rmIrqDeleteRoute+0x168> @ imm = #-0x2
;                     ir_inst->inp0_mapping = SCICLIENT_RM_IR_MAPPING_FREE;
7009ebd8: 9901         	ldr	r1, [sp, #0x4]
7009ebda: f64f 70ff    	movw	r0, #0xffff
7009ebde: 8188         	strh	r0, [r1, #0xc]
;                 }
7009ebe0: e7ff         	b	0x7009ebe2 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #-0x2
;             }
7009ebe2: e7ff         	b	0x7009ebe4 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #-0x2
;         }
7009ebe4: e7ff         	b	0x7009ebe6 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #-0x2
;     }
7009ebe6: e7ff         	b	0x7009ebe8 <Sciclient_rmIrqDeleteRoute+0x178> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009ebe8: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
7009ebec: 3001         	adds	r0, #0x1
7009ebee: f8ad 0032    	strh.w	r0, [sp, #0x32]
7009ebf2: e749         	b	0x7009ea88 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x16e
;     return r;
7009ebf4: 980d         	ldr	r0, [sp, #0x34]
7009ebf6: b010         	add	sp, #0x40
7009ebf8: bd80         	pop	{r7, pc}
7009ebfa: 0000         	movs	r0, r0
7009ebfc: 0000         	movs	r0, r0
7009ebfe: 0000         	movs	r0, r0

7009ec00 <Sciclient_rmProgramInterruptRoute>:
; {
7009ec00: b580         	push	{r7, lr}
7009ec02: b08e         	sub	sp, #0x38
7009ec04: 900d         	str	r0, [sp, #0x34]
7009ec06: 910c         	str	r1, [sp, #0x30]
7009ec08: 920b         	str	r2, [sp, #0x2c]
7009ec0a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009ec0c: 9001         	str	r0, [sp, #0x4]
7009ec0e: 900a         	str	r0, [sp, #0x28]
7009ec10: f44f 5180    	mov.w	r1, #0x1000
;     uint16_t messageType = TISCI_MSG_RM_IRQ_SET;
7009ec14: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
7009ec18: 9008         	str	r0, [sp, #0x20]
7009ec1a: 9007         	str	r0, [sp, #0x1c]
7009ec1c: 9006         	str	r0, [sp, #0x18]
7009ec1e: 9005         	str	r0, [sp, #0x14]
7009ec20: 9004         	str	r0, [sp, #0x10]
7009ec22: 9003         	str	r0, [sp, #0xc]
7009ec24: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
7009ec26: 980d         	ldr	r0, [sp, #0x34]
7009ec28: b118         	cbz	r0, 0x7009ec32 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #0x6
7009ec2a: e7ff         	b	0x7009ec2c <Sciclient_rmProgramInterruptRoute+0x2c> @ imm = #-0x2
7009ec2c: 980c         	ldr	r0, [sp, #0x30]
7009ec2e: b920         	cbnz	r0, 0x7009ec3a <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #0x8
7009ec30: e7ff         	b	0x7009ec32 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #-0x2
7009ec32: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009ec36: 900a         	str	r0, [sp, #0x28]
;     }
7009ec38: e7ff         	b	0x7009ec3a <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009ec3a: 980a         	ldr	r0, [sp, #0x28]
7009ec3c: b968         	cbnz	r0, 0x7009ec5a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0x1a
7009ec3e: e7ff         	b	0x7009ec40 <Sciclient_rmProgramInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009ec40: 980d         	ldr	r0, [sp, #0x34]
7009ec42: 6880         	ldr	r0, [r0, #0x8]
7009ec44: f04f 4100    	mov.w	r1, #0x80000000
7009ec48: f00d fe52    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0xdca4
;     if (r == SystemP_SUCCESS &&
7009ec4c: b128         	cbz	r0, 0x7009ec5a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0xa
7009ec4e: e7ff         	b	0x7009ec50 <Sciclient_rmProgramInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
7009ec50: 980d         	ldr	r0, [sp, #0x34]
7009ec52: 7ec0         	ldrb	r0, [r0, #0x1b]
7009ec54: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
7009ec58: e00f         	b	0x7009ec7a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
7009ec5a: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009ec5e: f006 fee7    	bl	0x700a5a30 <Sciclient_getCurrentContext> @ imm = #0x6dce
7009ec62: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009ec66: f64e 5088    	movw	r0, #0xed88
7009ec6a: f2c7 000a    	movt	r0, #0x700a
7009ec6e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009ec72: 6840         	ldr	r0, [r0, #0x4]
7009ec74: f88d 0025    	strb.w	r0, [sp, #0x25]
7009ec78: e7ff         	b	0x7009ec7a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
7009ec7a: 980a         	ldr	r0, [sp, #0x28]
7009ec7c: b960         	cbnz	r0, 0x7009ec98 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0x18
7009ec7e: e7ff         	b	0x7009ec80 <Sciclient_rmProgramInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
7009ec80: 980d         	ldr	r0, [sp, #0x34]
7009ec82: 6880         	ldr	r0, [r0, #0x8]
7009ec84: 2104         	movs	r1, #0x4
7009ec86: f00d fe33    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0xdc66
;     if (r == SystemP_SUCCESS &&
7009ec8a: b128         	cbz	r0, 0x7009ec98 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0xa
7009ec8c: e7ff         	b	0x7009ec8e <Sciclient_rmProgramInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
7009ec8e: 980d         	ldr	r0, [sp, #0x34]
7009ec90: 8a80         	ldrh	r0, [r0, #0x14]
7009ec92: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
7009ec96: e003         	b	0x7009eca0 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #0x6
7009ec98: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
7009ec9a: f8ad 0018    	strh.w	r0, [sp, #0x18]
7009ec9e: e7ff         	b	0x7009eca0 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009eca0: 980a         	ldr	r0, [sp, #0x28]
7009eca2: 2800         	cmp	r0, #0x0
7009eca4: d16e         	bne	0x7009ed84 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #0xdc
7009eca6: e7ff         	b	0x7009eca8 <Sciclient_rmProgramInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
7009eca8: 980d         	ldr	r0, [sp, #0x34]
7009ecaa: 6880         	ldr	r0, [r0, #0x8]
7009ecac: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
7009ecae: f89d 0025    	ldrb.w	r0, [sp, #0x25]
7009ecb2: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
7009ecb6: 980d         	ldr	r0, [sp, #0x34]
7009ecb8: 8980         	ldrh	r0, [r0, #0xc]
7009ecba: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
7009ecbe: 980d         	ldr	r0, [sp, #0x34]
7009ecc0: 89c0         	ldrh	r0, [r0, #0xe]
7009ecc2: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
7009ecc6: 980d         	ldr	r0, [sp, #0x34]
7009ecc8: 8a00         	ldrh	r0, [r0, #0x10]
7009ecca: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
7009ecce: 980d         	ldr	r0, [sp, #0x34]
7009ecd0: 8a40         	ldrh	r0, [r0, #0x12]
7009ecd2: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
7009ecd6: 980d         	ldr	r0, [sp, #0x34]
7009ecd8: 8b00         	ldrh	r0, [r0, #0x18]
7009ecda: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
7009ecde: 980d         	ldr	r0, [sp, #0x34]
7009ece0: 8ac0         	ldrh	r0, [r0, #0x16]
7009ece2: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
7009ece6: 980d         	ldr	r0, [sp, #0x34]
7009ece8: 7e80         	ldrb	r0, [r0, #0x1a]
7009ecea: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         cfg.set_resp = resp;
7009ecee: 980c         	ldr	r0, [sp, #0x30]
7009ecf0: 9008         	str	r0, [sp, #0x20]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
7009ecf2: 9802         	ldr	r0, [sp, #0x8]
7009ecf4: f00a fd3c    	bl	0x700a9770 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xaa78
7009ecf8: b1c8         	cbz	r0, 0x7009ed2e <Sciclient_rmProgramInterruptRoute+0x12e> @ imm = #0x32
7009ecfa: e7ff         	b	0x7009ecfc <Sciclient_rmProgramInterruptRoute+0xfc> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
7009ecfc: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
7009ed00: f00d fc2e    	bl	0x700ac560 <Sciclient_rmIaIsIa> @ imm = #0xd85c
7009ed04: b128         	cbz	r0, 0x7009ed12 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #0xa
7009ed06: e7ff         	b	0x7009ed08 <Sciclient_rmProgramInterruptRoute+0x108> @ imm = #-0x2
;                 cfg.vint = cfg.s_idx;
7009ed08: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
7009ed0c: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             }
7009ed10: e7ff         	b	0x7009ed12 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #-0x2
7009ed12: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqFindRoute(&cfg);
7009ed14: f7fd ff44    	bl	0x7009cba0 <Sciclient_rmIrqFindRoute> @ imm = #-0x2178
7009ed18: 900a         	str	r0, [sp, #0x28]
;             if (r == SystemP_SUCCESS) {
7009ed1a: 980a         	ldr	r0, [sp, #0x28]
7009ed1c: b930         	cbnz	r0, 0x7009ed2c <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #0xc
7009ed1e: e7ff         	b	0x7009ed20 <Sciclient_rmProgramInterruptRoute+0x120> @ imm = #-0x2
7009ed20: a802         	add	r0, sp, #0x8
7009ed22: 2100         	movs	r1, #0x0
;                 r = Sciclient_rmIrqProgramRoute(&cfg, false);
7009ed24: f000 f8fc    	bl	0x7009ef20 <Sciclient_rmIrqProgramRoute> @ imm = #0x1f8
7009ed28: 900a         	str	r0, [sp, #0x28]
;             }
7009ed2a: e7ff         	b	0x7009ed2c <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009ed2c: e029         	b	0x7009ed82 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #0x52
7009ed2e: 9802         	ldr	r0, [sp, #0x8]
7009ed30: f00a fce6    	bl	0x700a9700 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xa9cc
;                 true) ||
7009ed34: b928         	cbnz	r0, 0x7009ed42 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #0xa
7009ed36: e7ff         	b	0x7009ed38 <Sciclient_rmProgramInterruptRoute+0x138> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
7009ed38: 9802         	ldr	r0, [sp, #0x8]
7009ed3a: f00a fd51    	bl	0x700a97e0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xaaa2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
7009ed3e: b128         	cbz	r0, 0x7009ed4c <Sciclient_rmProgramInterruptRoute+0x14c> @ imm = #0xa
7009ed40: e7ff         	b	0x7009ed42 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #-0x2
7009ed42: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintAdd(&cfg);
7009ed44: f003 fde4    	bl	0x700a2910 <Sciclient_rmIrqVintAdd> @ imm = #0x3bc8
7009ed48: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
7009ed4a: e019         	b	0x7009ed80 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #0x32
7009ed4c: 9802         	ldr	r0, [sp, #0x8]
7009ed4e: f00a fdb7    	bl	0x700a98c0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xab6e
7009ed52: b128         	cbz	r0, 0x7009ed60 <Sciclient_rmProgramInterruptRoute+0x160> @ imm = #0xa
7009ed54: e7ff         	b	0x7009ed56 <Sciclient_rmProgramInterruptRoute+0x156> @ imm = #-0x2
7009ed56: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmUnmappedVintRouteCreate(&cfg);
7009ed58: f00b ff32    	bl	0x700aabc0 <Sciclient_rmUnmappedVintRouteCreate> @ imm = #0xbe64
7009ed5c: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
7009ed5e: e00e         	b	0x7009ed7e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #0x1c
7009ed60: 9802         	ldr	r0, [sp, #0x8]
7009ed62: f00a fd75    	bl	0x700a9850 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xaaea
7009ed66: b128         	cbz	r0, 0x7009ed74 <Sciclient_rmProgramInterruptRoute+0x174> @ imm = #0xa
7009ed68: e7ff         	b	0x7009ed6a <Sciclient_rmProgramInterruptRoute+0x16a> @ imm = #-0x2
7009ed6a: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqProgramOesRegister(&cfg);
7009ed6c: f00c fde8    	bl	0x700ab940 <Sciclient_rmIrqProgramOesRegister> @ imm = #0xcbd0
7009ed70: 900a         	str	r0, [sp, #0x28]
;         } else {
7009ed72: e003         	b	0x7009ed7c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #0x6
7009ed74: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
7009ed78: 900a         	str	r0, [sp, #0x28]
7009ed7a: e7ff         	b	0x7009ed7c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #-0x2
7009ed7c: e7ff         	b	0x7009ed7e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #-0x2
7009ed7e: e7ff         	b	0x7009ed80 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #-0x2
7009ed80: e7ff         	b	0x7009ed82 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #-0x2
;     }
7009ed82: e7ff         	b	0x7009ed84 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #-0x2
;     return r;
7009ed84: 980a         	ldr	r0, [sp, #0x28]
7009ed86: b00e         	add	sp, #0x38
7009ed88: bd80         	pop	{r7, pc}
7009ed8a: 0000         	movs	r0, r0

7009ed8c <free>:
7009ed8c: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
7009ed90: e3500000     	cmp	r0, #0
7009ed94: 0a000022     	beq	0x7009ee24 <free+0x98>  @ imm = #0x88
7009ed98: e59f616c     	ldr	r6, [pc, #0x16c]        @ 0x7009ef0c <free+0x180>
7009ed9c: e2404008     	sub	r4, r0, #8
7009eda0: e3a02000     	mov	r2, #0
7009eda4: e5960000     	ldr	r0, [r6]
7009eda8: e1a01006     	mov	r1, r6
7009edac: e1a05002     	mov	r5, r2
7009edb0: e1510004     	cmp	r1, r4
7009edb4: e3c03001     	bic	r3, r0, #1
7009edb8: e1a02001     	mov	r2, r1
7009edbc: e0863003     	add	r3, r6, r3
7009edc0: e2836008     	add	r6, r3, #8
7009edc4: 3afffff6     	blo	0x7009eda4 <free+0x18>  @ imm = #-0x28
7009edc8: e59f2140     	ldr	r2, [pc, #0x140]        @ 0x7009ef10 <free+0x184>
7009edcc: e59f3138     	ldr	r3, [pc, #0x138]        @ 0x7009ef0c <free+0x180>
7009edd0: e3520007     	cmp	r2, #7
7009edd4: e0827003     	add	r7, r2, r3
7009edd8: 82473008     	subhi	r3, r7, #8
7009eddc: e1560003     	cmp	r6, r3
7009ede0: 83006000     	movwhi	r6, #0x0
7009ede4: e1510004     	cmp	r1, r4
7009ede8: 1a00000d     	bne	0x7009ee24 <free+0x98>  @ imm = #0x34
7009edec: e2100001     	ands	r0, r0, #1
7009edf0: 0a00000b     	beq	0x7009ee24 <free+0x98>  @ imm = #0x2c
7009edf4: e3550000     	cmp	r5, #0
7009edf8: 0a00000a     	beq	0x7009ee28 <free+0x9c>  @ imm = #0x28
7009edfc: e5951000     	ldr	r1, [r5]
7009ee00: e3a00000     	mov	r0, #0
7009ee04: e3a07000     	mov	r7, #0
7009ee08: e3110001     	tst	r1, #1
7009ee0c: 01a00005     	moveq	r0, r5
7009ee10: e3560000     	cmp	r6, #0
7009ee14: 1a000006     	bne	0x7009ee34 <free+0xa8>  @ imm = #0x18
7009ee18: e3110001     	tst	r1, #1
7009ee1c: 0a00000c     	beq	0x7009ee54 <free+0xc8>  @ imm = #0x30
7009ee20: ea000023     	b	0x7009eeb4 <free+0x128> @ imm = #0x8c
7009ee24: e8bd81f0     	pop	{r4, r5, r6, r7, r8, pc}
7009ee28: e3a00000     	mov	r0, #0
7009ee2c: e3560000     	cmp	r6, #0
7009ee30: 0a00001f     	beq	0x7009eeb4 <free+0x128> @ imm = #0x7c
7009ee34: e5d61000     	ldrb	r1, [r6]
7009ee38: e3a07000     	mov	r7, #0
7009ee3c: e3a08000     	mov	r8, #0
7009ee40: e3110001     	tst	r1, #1
7009ee44: 01a07006     	moveq	r7, r6
7009ee48: e3500000     	cmp	r0, #0
7009ee4c: 0a000007     	beq	0x7009ee70 <free+0xe4>  @ imm = #0x1c
7009ee50: e1a05000     	mov	r5, r0
7009ee54: e1a00005     	mov	r0, r5
7009ee58: eb003505     	bl	0x700ac274 <free_list_remove> @ imm = #0xd414
7009ee5c: e3a08001     	mov	r8, #1
7009ee60: e3570000     	cmp	r7, #0
7009ee64: 0a00001d     	beq	0x7009eee0 <free+0x154> @ imm = #0x74
7009ee68: e1a06007     	mov	r6, r7
7009ee6c: ea000002     	b	0x7009ee7c <free+0xf0>  @ imm = #0x8
7009ee70: e3a05000     	mov	r5, #0
7009ee74: e3570000     	cmp	r7, #0
7009ee78: 0a00000d     	beq	0x7009eeb4 <free+0x128> @ imm = #0x34
7009ee7c: e1a00006     	mov	r0, r6
7009ee80: eb0034fb     	bl	0x700ac274 <free_list_remove> @ imm = #0xd3ec
7009ee84: e3580000     	cmp	r8, #0
7009ee88: 0a00000c     	beq	0x7009eec0 <free+0x134> @ imm = #0x30
7009ee8c: e5950000     	ldr	r0, [r5]
7009ee90: e5941000     	ldr	r1, [r4]
7009ee94: e5962000     	ldr	r2, [r6]
7009ee98: e3c00001     	bic	r0, r0, #1
7009ee9c: e3c11001     	bic	r1, r1, #1
7009eea0: e3c22001     	bic	r2, r2, #1
7009eea4: e0800001     	add	r0, r0, r1
7009eea8: e0800002     	add	r0, r0, r2
7009eeac: e2800010     	add	r0, r0, #16
7009eeb0: ea000010     	b	0x7009eef8 <free+0x16c> @ imm = #0x40
7009eeb4: e5940000     	ldr	r0, [r4]
7009eeb8: e3c00001     	bic	r0, r0, #1
7009eebc: ea000005     	b	0x7009eed8 <free+0x14c> @ imm = #0x14
7009eec0: e5940000     	ldr	r0, [r4]
7009eec4: e5961000     	ldr	r1, [r6]
7009eec8: e3c00001     	bic	r0, r0, #1
7009eecc: e3c11001     	bic	r1, r1, #1
7009eed0: e0800001     	add	r0, r0, r1
7009eed4: e2800008     	add	r0, r0, #8
7009eed8: e5840000     	str	r0, [r4]
7009eedc: ea000007     	b	0x7009ef00 <free+0x174> @ imm = #0x1c
7009eee0: e5950000     	ldr	r0, [r5]
7009eee4: e5941000     	ldr	r1, [r4]
7009eee8: e3c00001     	bic	r0, r0, #1
7009eeec: e3c11001     	bic	r1, r1, #1
7009eef0: e0800001     	add	r0, r0, r1
7009eef4: e2800008     	add	r0, r0, #8
7009eef8: e1a04005     	mov	r4, r5
7009eefc: e5850000     	str	r0, [r5]
7009ef00: e1a00004     	mov	r0, r4
7009ef04: e8bd41f0     	pop	{r4, r5, r6, r7, r8, lr}
7009ef08: ea0031f1     	b	0x700ab6d4 <free_list_insert> @ imm = #0xc7c4
7009ef0c: 00 50 08 70  	.word	0x70085000
7009ef10: 00 00 01 00  	.word	0x00010000
7009ef14: 00 00 00 00  	.word	0x00000000
7009ef18: 00 00 00 00  	.word	0x00000000
7009ef1c: 00 00 00 00  	.word	0x00000000

7009ef20 <Sciclient_rmIrqProgramRoute>:
; {
7009ef20: b580         	push	{r7, lr}
7009ef22: b092         	sub	sp, #0x48
7009ef24: 9011         	str	r0, [sp, #0x44]
7009ef26: f88d 1043    	strb.w	r1, [sp, #0x43]
7009ef2a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009ef2c: 900f         	str	r0, [sp, #0x3c]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
7009ef2e: 9003         	str	r0, [sp, #0xc]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
7009ef30: 9002         	str	r0, [sp, #0x8]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009ef32: f8ad 003a    	strh.w	r0, [sp, #0x3a]
7009ef36: e7ff         	b	0x7009ef38 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x2
7009ef38: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009ef3c: 9001         	str	r0, [sp, #0x4]
7009ef3e: f00e fbff    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0xe7fe
7009ef42: 4601         	mov	r1, r0
7009ef44: 9801         	ldr	r0, [sp, #0x4]
7009ef46: 4288         	cmp	r0, r1
7009ef48: f280 80aa    	bge.w	0x7009f0a0 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0x154
7009ef4c: e7ff         	b	0x7009ef4e <Sciclient_rmIrqProgramRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
7009ef4e: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009ef52: f00e f835    	bl	0x700acfc0 <Sciclient_rmPsGetIrqNode> @ imm = #0xe06a
7009ef56: 900d         	str	r0, [sp, #0x34]
;         cur_inp = Sciclient_rmPsGetInp(i);
7009ef58: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009ef5c: f00c fd30    	bl	0x700ab9c0 <Sciclient_rmPsGetInp> @ imm = #0xca60
7009ef60: 900c         	str	r0, [sp, #0x30]
;         cur_outp = Sciclient_rmPsGetOutp(i);
7009ef62: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009ef66: f00c fd4b    	bl	0x700aba00 <Sciclient_rmPsGetOutp> @ imm = #0xca96
7009ef6a: 900b         	str	r0, [sp, #0x2c]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009ef6c: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009ef70: 2800         	cmp	r0, #0x0
7009ef72: d154         	bne	0x7009f01e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0xa8
7009ef74: e7ff         	b	0x7009ef76 <Sciclient_rmIrqProgramRoute+0x56> @ imm = #-0x2
7009ef76: 980d         	ldr	r0, [sp, #0x34]
7009ef78: 8800         	ldrh	r0, [r0]
7009ef7a: f00d faf1    	bl	0x700ac560 <Sciclient_rmIaIsIa> @ imm = #0xd5e2
7009ef7e: 2800         	cmp	r0, #0x0
7009ef80: d04d         	beq	0x7009f01e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x9a
7009ef82: e7ff         	b	0x7009ef84 <Sciclient_rmIrqProgramRoute+0x64> @ imm = #-0x2
;             (map_vint == true)) {
7009ef84: f89d 0043    	ldrb.w	r0, [sp, #0x43]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
7009ef88: 07c0         	lsls	r0, r0, #0x1f
7009ef8a: 2800         	cmp	r0, #0x0
7009ef8c: d047         	beq	0x7009f01e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x8e
7009ef8e: e7ff         	b	0x7009ef90 <Sciclient_rmIrqProgramRoute+0x70> @ imm = #-0x2
7009ef90: 203c         	movs	r0, #0x3c
7009ef92: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
7009ef96: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
7009ef98: 9811         	ldr	r0, [sp, #0x44]
7009ef9a: 7900         	ldrb	r0, [r0, #0x4]
7009ef9c: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cfg->s_id;
7009efa0: 9811         	ldr	r0, [sp, #0x44]
7009efa2: 88c0         	ldrh	r0, [r0, #0x6]
7009efa4: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cfg->s_idx;
7009efa8: 9811         	ldr	r0, [sp, #0x44]
7009efaa: 8900         	ldrh	r0, [r0, #0x8]
7009efac: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.ia_id = cfg->s_ia;
7009efb0: 9811         	ldr	r0, [sp, #0x44]
7009efb2: 8a00         	ldrh	r0, [r0, #0x10]
7009efb4: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint = cur_outp;
7009efb8: 980b         	ldr	r0, [sp, #0x2c]
7009efba: f8ad 0026    	strh.w	r0, [sp, #0x26]
;             req.global_event = cur_inp;
7009efbe: 980c         	ldr	r0, [sp, #0x30]
7009efc0: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             req.vint_status_bit_index = cfg->vint_sb;
7009efc4: 9811         	ldr	r0, [sp, #0x44]
7009efc6: 7d00         	ldrb	r0, [r0, #0x14]
7009efc8: f88d 002a    	strb.w	r0, [sp, #0x2a]
;                                       cfg->set_resp,
7009efcc: 9811         	ldr	r0, [sp, #0x44]
7009efce: 6981         	ldr	r1, [r0, #0x18]
7009efd0: a804         	add	r0, sp, #0x10
7009efd2: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
7009efd6: f00b fb83    	bl	0x700aa6e0 <Sciclient_rmIrqSetRaw> @ imm = #0xb706
7009efda: 900f         	str	r0, [sp, #0x3c]
;             if (r == SystemP_SUCCESS) {
7009efdc: 980f         	ldr	r0, [sp, #0x3c]
7009efde: b9e8         	cbnz	r0, 0x7009f01c <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #0x3a
7009efe0: e7ff         	b	0x7009efe2 <Sciclient_rmIrqProgramRoute+0xc2> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
7009efe2: 980d         	ldr	r0, [sp, #0x34]
7009efe4: 8800         	ldrh	r0, [r0]
7009efe6: f00b f9fb    	bl	0x700aa3e0 <Sciclient_rmIaGetInst> @ imm = #0xb3f6
7009efea: 9003         	str	r0, [sp, #0xc]
;                 if (ia_inst != NULL) {
7009efec: 9803         	ldr	r0, [sp, #0xc]
7009efee: b1a0         	cbz	r0, 0x7009f01a <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #0x28
7009eff0: e7ff         	b	0x7009eff2 <Sciclient_rmIrqProgramRoute+0xd2> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]++;
7009eff2: 9803         	ldr	r0, [sp, #0xc]
7009eff4: 6901         	ldr	r1, [r0, #0x10]
7009eff6: 9a0b         	ldr	r2, [sp, #0x2c]
7009eff8: 5c88         	ldrb	r0, [r1, r2]
7009effa: 3001         	adds	r0, #0x1
7009effc: 5488         	strb	r0, [r1, r2]
;                     if ((cur_outp == 0) && (cfg->vint_sb == 0)) {
7009effe: 980b         	ldr	r0, [sp, #0x2c]
7009f000: b950         	cbnz	r0, 0x7009f018 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0x14
7009f002: e7ff         	b	0x7009f004 <Sciclient_rmIrqProgramRoute+0xe4> @ imm = #-0x2
7009f004: 9811         	ldr	r0, [sp, #0x44]
7009f006: 7d00         	ldrb	r0, [r0, #0x14]
7009f008: b930         	cbnz	r0, 0x7009f018 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0xc
7009f00a: e7ff         	b	0x7009f00c <Sciclient_rmIrqProgramRoute+0xec> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = cur_inp - ia_inst->sevt_offset;
7009f00c: 980c         	ldr	r0, [sp, #0x30]
7009f00e: 9903         	ldr	r1, [sp, #0xc]
7009f010: 890a         	ldrh	r2, [r1, #0x8]
7009f012: 1a80         	subs	r0, r0, r2
7009f014: 8288         	strh	r0, [r1, #0x14]
;                     }
7009f016: e7ff         	b	0x7009f018 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #-0x2
;                 }
7009f018: e7ff         	b	0x7009f01a <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #-0x2
;             }
7009f01a: e7ff         	b	0x7009f01c <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #-0x2
;         }
7009f01c: e7ff         	b	0x7009f01e <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #-0x2
;         if (i > 0u) {
7009f01e: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f022: b390         	cbz	r0, 0x7009f08a <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #0x64
7009f024: e7ff         	b	0x7009f026 <Sciclient_rmIrqProgramRoute+0x106> @ imm = #-0x2
7009f026: 2003         	movs	r0, #0x3
7009f028: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
7009f02c: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
7009f02e: 9811         	ldr	r0, [sp, #0x44]
7009f030: 7900         	ldrb	r0, [r0, #0x4]
7009f032: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cur_n->id;
7009f036: 980d         	ldr	r0, [sp, #0x34]
7009f038: 8800         	ldrh	r0, [r0]
7009f03a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cur_inp;
7009f03e: 980c         	ldr	r0, [sp, #0x30]
7009f040: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.dst_id = cur_n->id;
7009f044: 980d         	ldr	r0, [sp, #0x34]
7009f046: 8800         	ldrh	r0, [r0]
7009f048: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.dst_host_irq = cur_outp;
7009f04c: 980b         	ldr	r0, [sp, #0x2c]
7009f04e: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                                       cfg->set_resp,
7009f052: 9811         	ldr	r0, [sp, #0x44]
7009f054: 6981         	ldr	r1, [r0, #0x18]
7009f056: a804         	add	r0, sp, #0x10
7009f058: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
7009f05c: f00b fb40    	bl	0x700aa6e0 <Sciclient_rmIrqSetRaw> @ imm = #0xb680
7009f060: 900f         	str	r0, [sp, #0x3c]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
7009f062: 980f         	ldr	r0, [sp, #0x3c]
7009f064: b980         	cbnz	r0, 0x7009f088 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x20
7009f066: e7ff         	b	0x7009f068 <Sciclient_rmIrqProgramRoute+0x148> @ imm = #-0x2
7009f068: 980b         	ldr	r0, [sp, #0x2c]
7009f06a: b968         	cbnz	r0, 0x7009f088 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x1a
7009f06c: e7ff         	b	0x7009f06e <Sciclient_rmIrqProgramRoute+0x14e> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
7009f06e: 980d         	ldr	r0, [sp, #0x34]
7009f070: 8800         	ldrh	r0, [r0]
7009f072: f00a fccd    	bl	0x700a9a10 <Sciclient_rmIrGetInst> @ imm = #0xa99a
7009f076: 9002         	str	r0, [sp, #0x8]
;                 if (ir_inst != NULL) {
7009f078: 9802         	ldr	r0, [sp, #0x8]
7009f07a: b120         	cbz	r0, 0x7009f086 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #0x8
7009f07c: e7ff         	b	0x7009f07e <Sciclient_rmIrqProgramRoute+0x15e> @ imm = #-0x2
;                     ir_inst->inp0_mapping = cur_outp;
7009f07e: 980b         	ldr	r0, [sp, #0x2c]
7009f080: 9902         	ldr	r1, [sp, #0x8]
7009f082: 8188         	strh	r0, [r1, #0xc]
;                 }
7009f084: e7ff         	b	0x7009f086 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #-0x2
;             }
7009f086: e7ff         	b	0x7009f088 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #-0x2
;         }
7009f088: e7ff         	b	0x7009f08a <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #-0x2
;         if (r != SystemP_SUCCESS) {
7009f08a: 980f         	ldr	r0, [sp, #0x3c]
7009f08c: b108         	cbz	r0, 0x7009f092 <Sciclient_rmIrqProgramRoute+0x172> @ imm = #0x2
7009f08e: e7ff         	b	0x7009f090 <Sciclient_rmIrqProgramRoute+0x170> @ imm = #-0x2
;             break;
7009f090: e006         	b	0x7009f0a0 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0xc
;     }
7009f092: e7ff         	b	0x7009f094 <Sciclient_rmIrqProgramRoute+0x174> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
7009f094: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
7009f098: 3001         	adds	r0, #0x1
7009f09a: f8ad 003a    	strh.w	r0, [sp, #0x3a]
7009f09e: e74b         	b	0x7009ef38 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x16a
;     return r;
7009f0a0: 980f         	ldr	r0, [sp, #0x3c]
7009f0a2: b012         	add	sp, #0x48
7009f0a4: bd80         	pop	{r7, pc}
		...
7009f0ae: 0000         	movs	r0, r0

7009f0b0 <Udma_chEnableLocal>:
; {
7009f0b0: b580         	push	{r7, lr}
7009f0b2: b08e         	sub	sp, #0x38
7009f0b4: 900d         	str	r0, [sp, #0x34]
;     drvHandle = chHandle->drvHandle;
7009f0b6: 980d         	ldr	r0, [sp, #0x34]
7009f0b8: 6e80         	ldr	r0, [r0, #0x68]
7009f0ba: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f0bc: 980b         	ldr	r0, [sp, #0x2c]
7009f0be: 6800         	ldr	r0, [r0]
7009f0c0: 2801         	cmp	r0, #0x1
7009f0c2: d163         	bne	0x7009f18c <Udma_chEnableLocal+0xdc> @ imm = #0xc6
7009f0c4: e7ff         	b	0x7009f0c6 <Udma_chEnableLocal+0x16> @ imm = #-0x2
7009f0c6: 2001         	movs	r0, #0x1
;         bcdmaRtEnable.enable         = TRUE;
7009f0c8: 9005         	str	r0, [sp, #0x14]
7009f0ca: 2000         	movs	r0, #0x0
;         bcdmaRtEnable.teardown       = FALSE;
7009f0cc: 9006         	str	r0, [sp, #0x18]
;         bcdmaRtEnable.forcedTeardown = FALSE;
7009f0ce: 9009         	str	r0, [sp, #0x24]
;         bcdmaRtEnable.pause          = FALSE;
7009f0d0: 9007         	str	r0, [sp, #0x1c]
;         bcdmaRtEnable.error          = FALSE;
7009f0d2: 9008         	str	r0, [sp, #0x20]
;         if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009f0d4: 980d         	ldr	r0, [sp, #0x34]
7009f0d6: 7800         	ldrb	r0, [r0]
7009f0d8: 0740         	lsls	r0, r0, #0x1d
7009f0da: 2800         	cmp	r0, #0x0
7009f0dc: d508         	bpl	0x7009f0f0 <Udma_chEnableLocal+0x40> @ imm = #0x10
7009f0de: e7ff         	b	0x7009f0e0 <Udma_chEnableLocal+0x30> @ imm = #-0x2
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum , &bcdmaRtEnable);
7009f0e0: 980b         	ldr	r0, [sp, #0x2c]
7009f0e2: 3008         	adds	r0, #0x8
7009f0e4: 990d         	ldr	r1, [sp, #0x34]
7009f0e6: 6ec9         	ldr	r1, [r1, #0x6c]
7009f0e8: aa05         	add	r2, sp, #0x14
7009f0ea: f00d fb29    	bl	0x700ac740 <CSL_bcdmaSetTxRT> @ imm = #0xd652
;         }
7009f0ee: e04c         	b	0x7009f18a <Udma_chEnableLocal+0xda> @ imm = #0x98
;         else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009f0f0: 980d         	ldr	r0, [sp, #0x34]
7009f0f2: 7800         	ldrb	r0, [r0]
7009f0f4: 07c0         	lsls	r0, r0, #0x1f
7009f0f6: b300         	cbz	r0, 0x7009f13a <Udma_chEnableLocal+0x8a> @ imm = #0x40
7009f0f8: e7ff         	b	0x7009f0fa <Udma_chEnableLocal+0x4a> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaTxRtRegs->PEER8);
7009f0fa: 980d         	ldr	r0, [sp, #0x34]
7009f0fc: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f100: f500 7008    	add.w	r0, r0, #0x220
7009f104: f00e fb04    	bl	0x700ad710 <CSL_REG32_RD_RAW> @ imm = #0xe608
7009f108: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f10a: 980c         	ldr	r0, [sp, #0x30]
7009f10c: f040 4000    	orr	r0, r0, #0x80000000
7009f110: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaTxRtRegs->PEER8, regVal);
7009f112: 980d         	ldr	r0, [sp, #0x34]
7009f114: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f118: f500 7008    	add.w	r0, r0, #0x220
7009f11c: 990c         	ldr	r1, [sp, #0x30]
7009f11e: f00e fa57    	bl	0x700ad5d0 <CSL_REG32_WR_RAW> @ imm = #0xe4ae
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtEnable);
7009f122: 9a0b         	ldr	r2, [sp, #0x2c]
7009f124: f102 0008    	add.w	r0, r2, #0x8
7009f128: 990d         	ldr	r1, [sp, #0x34]
7009f12a: 6ec9         	ldr	r1, [r1, #0x6c]
7009f12c: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009f130: 4411         	add	r1, r2
7009f132: aa05         	add	r2, sp, #0x14
7009f134: f00d fb04    	bl	0x700ac740 <CSL_bcdmaSetTxRT> @ imm = #0xd608
;         }
7009f138: e026         	b	0x7009f188 <Udma_chEnableLocal+0xd8> @ imm = #0x4c
;         else if ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009f13a: 980d         	ldr	r0, [sp, #0x34]
7009f13c: 7800         	ldrb	r0, [r0]
7009f13e: 0780         	lsls	r0, r0, #0x1e
7009f140: 2800         	cmp	r0, #0x0
7009f142: d520         	bpl	0x7009f186 <Udma_chEnableLocal+0xd6> @ imm = #0x40
7009f144: e7ff         	b	0x7009f146 <Udma_chEnableLocal+0x96> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtEnable);
7009f146: 9a0b         	ldr	r2, [sp, #0x2c]
7009f148: f102 0008    	add.w	r0, r2, #0x8
7009f14c: 990d         	ldr	r1, [sp, #0x34]
7009f14e: 6f09         	ldr	r1, [r1, #0x70]
7009f150: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009f154: 4411         	add	r1, r2
7009f156: aa05         	add	r2, sp, #0x14
;             (void) CSL_bcdmaSetRxRT(
7009f158: f00d fada    	bl	0x700ac710 <CSL_bcdmaSetRxRT> @ imm = #0xd5b4
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
7009f15c: 980d         	ldr	r0, [sp, #0x34]
7009f15e: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f162: f500 7008    	add.w	r0, r0, #0x220
7009f166: f00e fad3    	bl	0x700ad710 <CSL_REG32_RD_RAW> @ imm = #0xe5a6
7009f16a: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f16c: 980c         	ldr	r0, [sp, #0x30]
7009f16e: f040 4000    	orr	r0, r0, #0x80000000
7009f172: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
7009f174: 980d         	ldr	r0, [sp, #0x34]
7009f176: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f17a: f500 7008    	add.w	r0, r0, #0x220
7009f17e: 990c         	ldr	r1, [sp, #0x30]
7009f180: f00e fa26    	bl	0x700ad5d0 <CSL_REG32_WR_RAW> @ imm = #0xe44c
;         }
7009f184: e7ff         	b	0x7009f186 <Udma_chEnableLocal+0xd6> @ imm = #-0x2
7009f186: e7ff         	b	0x7009f188 <Udma_chEnableLocal+0xd8> @ imm = #-0x2
7009f188: e7ff         	b	0x7009f18a <Udma_chEnableLocal+0xda> @ imm = #-0x2
;     }
7009f18a: e050         	b	0x7009f22e <Udma_chEnableLocal+0x17e> @ imm = #0xa0
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f18c: 980b         	ldr	r0, [sp, #0x2c]
7009f18e: 6800         	ldr	r0, [r0]
7009f190: 2802         	cmp	r0, #0x2
7009f192: d14b         	bne	0x7009f22c <Udma_chEnableLocal+0x17c> @ imm = #0x96
7009f194: e7ff         	b	0x7009f196 <Udma_chEnableLocal+0xe6> @ imm = #-0x2
7009f196: 2001         	movs	r0, #0x1
;         pktdmaRtEnable.enable         = TRUE;
7009f198: 9000         	str	r0, [sp]
7009f19a: 2000         	movs	r0, #0x0
;         pktdmaRtEnable.teardown       = FALSE;
7009f19c: 9001         	str	r0, [sp, #0x4]
;         pktdmaRtEnable.forcedTeardown = FALSE;
7009f19e: 9004         	str	r0, [sp, #0x10]
;         pktdmaRtEnable.pause          = FALSE;
7009f1a0: 9002         	str	r0, [sp, #0x8]
;         pktdmaRtEnable.error          = FALSE;
7009f1a2: 9003         	str	r0, [sp, #0xc]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009f1a4: 980d         	ldr	r0, [sp, #0x34]
7009f1a6: 7800         	ldrb	r0, [r0]
7009f1a8: 07c0         	lsls	r0, r0, #0x1f
7009f1aa: b1e0         	cbz	r0, 0x7009f1e6 <Udma_chEnableLocal+0x136> @ imm = #0x38
7009f1ac: e7ff         	b	0x7009f1ae <Udma_chEnableLocal+0xfe> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaTxRtRegs->PEER8);
7009f1ae: 980d         	ldr	r0, [sp, #0x34]
7009f1b0: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f1b4: f500 7008    	add.w	r0, r0, #0x220
7009f1b8: f00e faaa    	bl	0x700ad710 <CSL_REG32_RD_RAW> @ imm = #0xe554
7009f1bc: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f1be: 980c         	ldr	r0, [sp, #0x30]
7009f1c0: f040 4000    	orr	r0, r0, #0x80000000
7009f1c4: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaTxRtRegs->PEER8, regVal);
7009f1c6: 980d         	ldr	r0, [sp, #0x34]
7009f1c8: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f1cc: f500 7008    	add.w	r0, r0, #0x220
7009f1d0: 990c         	ldr	r1, [sp, #0x30]
7009f1d2: f00e f9fd    	bl	0x700ad5d0 <CSL_REG32_WR_RAW> @ imm = #0xe3fa
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtEnable);
7009f1d6: 980b         	ldr	r0, [sp, #0x2c]
7009f1d8: 3054         	adds	r0, #0x54
7009f1da: 990d         	ldr	r1, [sp, #0x34]
7009f1dc: 6ec9         	ldr	r1, [r1, #0x6c]
7009f1de: 466a         	mov	r2, sp
7009f1e0: f00c fd6e    	bl	0x700abcc0 <CSL_pktdmaSetTxRT> @ imm = #0xcadc
;         }
7009f1e4: e7ff         	b	0x7009f1e6 <Udma_chEnableLocal+0x136> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009f1e6: 980d         	ldr	r0, [sp, #0x34]
7009f1e8: 7800         	ldrb	r0, [r0]
7009f1ea: 0780         	lsls	r0, r0, #0x1e
7009f1ec: 2800         	cmp	r0, #0x0
7009f1ee: d51c         	bpl	0x7009f22a <Udma_chEnableLocal+0x17a> @ imm = #0x38
7009f1f0: e7ff         	b	0x7009f1f2 <Udma_chEnableLocal+0x142> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtEnable);
7009f1f2: 980b         	ldr	r0, [sp, #0x2c]
7009f1f4: 3054         	adds	r0, #0x54
7009f1f6: 990d         	ldr	r1, [sp, #0x34]
7009f1f8: 6f09         	ldr	r1, [r1, #0x70]
7009f1fa: 466a         	mov	r2, sp
;             (void) CSL_pktdmaSetRxRT(
7009f1fc: f00c fd40    	bl	0x700abc80 <CSL_pktdmaSetRxRT> @ imm = #0xca80
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
7009f200: 980d         	ldr	r0, [sp, #0x34]
7009f202: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f206: f500 7008    	add.w	r0, r0, #0x220
7009f20a: f00e fa81    	bl	0x700ad710 <CSL_REG32_RD_RAW> @ imm = #0xe502
7009f20e: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
7009f210: 980c         	ldr	r0, [sp, #0x30]
7009f212: f040 4000    	orr	r0, r0, #0x80000000
7009f216: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
7009f218: 980d         	ldr	r0, [sp, #0x34]
7009f21a: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f21e: f500 7008    	add.w	r0, r0, #0x220
7009f222: 990c         	ldr	r1, [sp, #0x30]
7009f224: f00e f9d4    	bl	0x700ad5d0 <CSL_REG32_WR_RAW> @ imm = #0xe3a8
;         }
7009f228: e7ff         	b	0x7009f22a <Udma_chEnableLocal+0x17a> @ imm = #-0x2
;     }
7009f22a: e7ff         	b	0x7009f22c <Udma_chEnableLocal+0x17c> @ imm = #-0x2
7009f22c: e7ff         	b	0x7009f22e <Udma_chEnableLocal+0x17e> @ imm = #-0x2
;     return;
7009f22e: b00e         	add	sp, #0x38
7009f230: bd80         	pop	{r7, pc}
7009f232: 0000         	movs	r0, r0

7009f234 <memcpy>:
7009f234: e3520000     	cmp	r2, #0
7009f238: 012fff1e     	bxeq	lr
7009f23c: e92d4001     	push	{r0, lr}
7009f240: e3110003     	tst	r1, #3
7009f244: 1a00002b     	bne	0x7009f2f8 <_unaln>     @ imm = #0xac
7009f248: e3100003     	tst	r0, #3
7009f24c: 1a00002f     	bne	0x7009f310 <_saln>      @ imm = #0xbc

7009f250 <_aln>:
7009f250: e3520010     	cmp	r2, #16
7009f254: 3a000008     	blo	0x7009f27c <_l16>       @ imm = #0x20
7009f258: e92d0010     	stmdb	sp!, {r4}
7009f25c: e2422010     	sub	r2, r2, #16

7009f260 <_c16>:
7009f260: e8b15018     	ldm	r1!, {r3, r4, r12, lr}
7009f264: e8a05018     	stm	r0!, {r3, r4, r12, lr}
7009f268: e2522010     	subs	r2, r2, #16
7009f26c: 2afffffb     	bhs	0x7009f260 <_c16>       @ imm = #-0x14
7009f270: e8bd0010     	ldm	sp!, {r4}
7009f274: e2922010     	adds	r2, r2, #16
7009f278: 08bd8001     	popeq	{r0, pc}

7009f27c <_l16>:
7009f27c: e212300c     	ands	r3, r2, #12
7009f280: 0a00000d     	beq	0x7009f2bc <_cp1>       @ imm = #0x34
7009f284: e3d2200c     	bics	r2, r2, #12
7009f288: e24fc010     	sub	r12, pc, #16
7009f28c: e08cf103     	add	pc, r12, r3, lsl #2

7009f290 <_4line>:
7009f290: e4913004     	ldr	r3, [r1], #4
7009f294: e4803004     	str	r3, [r0], #4
7009f298: 08bd8001     	popeq	{r0, pc}
7009f29c: ea000006     	b	0x7009f2bc <_cp1>       @ imm = #0x18
7009f2a0: e8b11008     	ldm	r1!, {r3, r12}
7009f2a4: e8a01008     	stm	r0!, {r3, r12}
7009f2a8: 08bd8001     	popeq	{r0, pc}
7009f2ac: ea000002     	b	0x7009f2bc <_cp1>       @ imm = #0x8
7009f2b0: e8b15008     	ldm	r1!, {r3, r12, lr}
7009f2b4: e8a05008     	stm	r0!, {r3, r12, lr}
7009f2b8: 08bd8001     	popeq	{r0, pc}

7009f2bc <_cp1>:
7009f2bc: e2522001     	subs	r2, r2, #1
7009f2c0: 124f3004     	subne	r3, pc, #4
7009f2c4: 1083f202     	addne	pc, r3, r2, lsl #4

7009f2c8 <_1line>:
7009f2c8: e4d13001     	ldrb	r3, [r1], #1
7009f2cc: e4c03001     	strb	r3, [r0], #1
7009f2d0: e8bd8001     	pop	{r0, pc}
7009f2d4: e0d130b2     	ldrh	r3, [r1], #2
7009f2d8: e0c030b2     	strh	r3, [r0], #2
7009f2dc: e8bd8001     	pop	{r0, pc}
7009f2e0: e320f000     	nop
7009f2e4: e0d130b2     	ldrh	r3, [r1], #2
7009f2e8: e0c030b2     	strh	r3, [r0], #2
7009f2ec: e4d13001     	ldrb	r3, [r1], #1
7009f2f0: e4c03001     	strb	r3, [r0], #1
7009f2f4: e8bd8001     	pop	{r0, pc}

7009f2f8 <_unaln>:
7009f2f8: e4d13001     	ldrb	r3, [r1], #1
7009f2fc: e4c03001     	strb	r3, [r0], #1
7009f300: e2522001     	subs	r2, r2, #1
7009f304: 08bd8001     	popeq	{r0, pc}
7009f308: e3110003     	tst	r1, #3
7009f30c: 1afffff9     	bne	0x7009f2f8 <_unaln>     @ imm = #-0x1c

7009f310 <_saln>:
7009f310: e3100001     	tst	r0, #1
7009f314: 1a000013     	bne	0x7009f368 <_off1>      @ imm = #0x4c
7009f318: e3100002     	tst	r0, #2
7009f31c: 0affffcb     	beq	0x7009f250 <_aln>       @ imm = #-0xd4

7009f320 <_off2>:
7009f320: e2522004     	subs	r2, r2, #4
7009f324: 3a000007     	blo	0x7009f348 <_c1h>       @ imm = #0x1c

7009f328 <_c2>:
7009f328: e4913004     	ldr	r3, [r1], #4
7009f32c: e0c030b4     	strh	r3, [r0], #4
7009f330: e1a03823     	lsr	r3, r3, #16
7009f334: e14030b2     	strh	r3, [r0, #-2]
7009f338: e2522004     	subs	r2, r2, #4
7009f33c: 2afffff9     	bhs	0x7009f328 <_c2>        @ imm = #-0x1c
7009f340: e3720004     	cmn	r2, #4
7009f344: 08bd8001     	popeq	{r0, pc}

7009f348 <_c1h>:
7009f348: e2922002     	adds	r2, r2, #2
7009f34c: 20d130b2     	ldrhhs	r3, [r1], #2
7009f350: 20c030b2     	strhhs	r3, [r0], #2
7009f354: 22422002     	subhs	r2, r2, #2
7009f358: e2922001     	adds	r2, r2, #1
7009f35c: 24d13001     	ldrbhs	r3, [r1], #1
7009f360: 24c03001     	strbhs	r3, [r0], #1
7009f364: e8bd8001     	pop	{r0, pc}

7009f368 <_off1>:
7009f368: e2522004     	subs	r2, r2, #4
7009f36c: 3a000009     	blo	0x7009f398 <_c1b>       @ imm = #0x24

7009f370 <_c1>:
7009f370: e4913004     	ldr	r3, [r1], #4
7009f374: e4c03004     	strb	r3, [r0], #4
7009f378: e1a03423     	lsr	r3, r3, #8
7009f37c: e5403003     	strb	r3, [r0, #-0x3]
7009f380: e1a03423     	lsr	r3, r3, #8
7009f384: e5403002     	strb	r3, [r0, #-0x2]
7009f388: e1a03423     	lsr	r3, r3, #8
7009f38c: e5403001     	strb	r3, [r0, #-0x1]
7009f390: e2522004     	subs	r2, r2, #4
7009f394: 2afffff5     	bhs	0x7009f370 <_c1>        @ imm = #-0x2c

7009f398 <_c1b>:
7009f398: e2922004     	adds	r2, r2, #4
7009f39c: 08bd8001     	popeq	{r0, pc}

7009f3a0 <_lp1>:
7009f3a0: e4d13001     	ldrb	r3, [r1], #1
7009f3a4: e4c03001     	strb	r3, [r0], #1
7009f3a8: e2522001     	subs	r2, r2, #1
7009f3ac: 1afffffb     	bne	0x7009f3a0 <_lp1>       @ imm = #-0x14

7009f3b0 <_ret>:
7009f3b0: e8bd8001     	pop	{r0, pc}
		...

7009f3c0 <Udma_chConfigPdma>:
; {
7009f3c0: b580         	push	{r7, lr}
7009f3c2: b08a         	sub	sp, #0x28
7009f3c4: 9009         	str	r0, [sp, #0x24]
7009f3c6: 9108         	str	r1, [sp, #0x20]
7009f3c8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f3ca: 9007         	str	r0, [sp, #0x1c]
;     volatile uint32_t  *PEER8=NULL, *PEER0=NULL, *PEER1=NULL;
7009f3cc: 9006         	str	r0, [sp, #0x18]
7009f3ce: 9005         	str	r0, [sp, #0x14]
7009f3d0: 9004         	str	r0, [sp, #0x10]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
7009f3d2: 9809         	ldr	r0, [sp, #0x24]
7009f3d4: 9002         	str	r0, [sp, #0x8]
;     if((NULL_PTR == chHandleInt) ||
7009f3d6: 9802         	ldr	r0, [sp, #0x8]
7009f3d8: b1a0         	cbz	r0, 0x7009f404 <Udma_chConfigPdma+0x44> @ imm = #0x28
7009f3da: e7ff         	b	0x7009f3dc <Udma_chConfigPdma+0x1c> @ imm = #-0x2
;        (NULL_PTR == pdmaPrms) ||
7009f3dc: 9808         	ldr	r0, [sp, #0x20]
7009f3de: b188         	cbz	r0, 0x7009f404 <Udma_chConfigPdma+0x44> @ imm = #0x22
7009f3e0: e7ff         	b	0x7009f3e2 <Udma_chConfigPdma+0x22> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009f3e2: 9802         	ldr	r0, [sp, #0x8]
7009f3e4: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009f3e8: f64a 31cd    	movw	r1, #0xabcd
7009f3ec: f6ca 31dc    	movt	r1, #0xabdc
7009f3f0: 4288         	cmp	r0, r1
7009f3f2: d107         	bne	0x7009f404 <Udma_chConfigPdma+0x44> @ imm = #0xe
7009f3f4: e7ff         	b	0x7009f3f6 <Udma_chConfigPdma+0x36> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_PDMA) != UDMA_CH_FLAG_PDMA))
7009f3f6: 9802         	ldr	r0, [sp, #0x8]
7009f3f8: 6800         	ldr	r0, [r0]
7009f3fa: f000 0008    	and	r0, r0, #0x8
;     if((NULL_PTR == chHandleInt) ||
7009f3fe: 2808         	cmp	r0, #0x8
7009f400: d004         	beq	0x7009f40c <Udma_chConfigPdma+0x4c> @ imm = #0x8
7009f402: e7ff         	b	0x7009f404 <Udma_chConfigPdma+0x44> @ imm = #-0x2
7009f404: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009f408: 9007         	str	r0, [sp, #0x1c]
;     }
7009f40a: e7ff         	b	0x7009f40c <Udma_chConfigPdma+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f40c: 9807         	ldr	r0, [sp, #0x1c]
7009f40e: b9a8         	cbnz	r0, 0x7009f43c <Udma_chConfigPdma+0x7c> @ imm = #0x2a
7009f410: e7ff         	b	0x7009f412 <Udma_chConfigPdma+0x52> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009f412: 9802         	ldr	r0, [sp, #0x8]
7009f414: 6e80         	ldr	r0, [r0, #0x68]
7009f416: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009f418: 9803         	ldr	r0, [sp, #0xc]
7009f41a: b150         	cbz	r0, 0x7009f432 <Udma_chConfigPdma+0x72> @ imm = #0x14
7009f41c: e7ff         	b	0x7009f41e <Udma_chConfigPdma+0x5e> @ imm = #-0x2
7009f41e: 9803         	ldr	r0, [sp, #0xc]
7009f420: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009f424: f64a 31cd    	movw	r1, #0xabcd
7009f428: f6ca 31dc    	movt	r1, #0xabdc
7009f42c: 4288         	cmp	r0, r1
7009f42e: d004         	beq	0x7009f43a <Udma_chConfigPdma+0x7a> @ imm = #0x8
7009f430: e7ff         	b	0x7009f432 <Udma_chConfigPdma+0x72> @ imm = #-0x2
7009f432: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009f436: 9007         	str	r0, [sp, #0x1c]
;         }
7009f438: e7ff         	b	0x7009f43a <Udma_chConfigPdma+0x7a> @ imm = #-0x2
;     }
7009f43a: e7ff         	b	0x7009f43c <Udma_chConfigPdma+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f43c: 9807         	ldr	r0, [sp, #0x1c]
7009f43e: 2800         	cmp	r0, #0x0
7009f440: d17a         	bne	0x7009f538 <Udma_chConfigPdma+0x178> @ imm = #0xf4
7009f442: e7ff         	b	0x7009f444 <Udma_chConfigPdma+0x84> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f444: 9803         	ldr	r0, [sp, #0xc]
7009f446: 6800         	ldr	r0, [r0]
7009f448: 2801         	cmp	r0, #0x1
7009f44a: d137         	bne	0x7009f4bc <Udma_chConfigPdma+0xfc> @ imm = #0x6e
7009f44c: e7ff         	b	0x7009f44e <Udma_chConfigPdma+0x8e> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009f44e: 9802         	ldr	r0, [sp, #0x8]
7009f450: 7800         	ldrb	r0, [r0]
7009f452: 07c0         	lsls	r0, r0, #0x1f
7009f454: b198         	cbz	r0, 0x7009f47e <Udma_chConfigPdma+0xbe> @ imm = #0x26
7009f456: e7ff         	b	0x7009f458 <Udma_chConfigPdma+0x98> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pBcdmaTxRtRegs->PEER8;
7009f458: 9802         	ldr	r0, [sp, #0x8]
7009f45a: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f45e: f500 7008    	add.w	r0, r0, #0x220
7009f462: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaTxRtRegs->PEER1;
7009f464: 9802         	ldr	r0, [sp, #0x8]
7009f466: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f46a: f500 7001    	add.w	r0, r0, #0x204
7009f46e: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaTxRtRegs->PEER0;
7009f470: 9802         	ldr	r0, [sp, #0x8]
7009f472: f8d0 0220    	ldr.w	r0, [r0, #0x220]
7009f476: f500 7000    	add.w	r0, r0, #0x200
7009f47a: 9005         	str	r0, [sp, #0x14]
;             }
7009f47c: e012         	b	0x7009f4a4 <Udma_chConfigPdma+0xe4> @ imm = #0x24
;                 PEER8 = &chHandleInt->pBcdmaRxRtRegs->PEER8;
7009f47e: 9802         	ldr	r0, [sp, #0x8]
7009f480: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f484: f500 7008    	add.w	r0, r0, #0x220
7009f488: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaRxRtRegs->PEER1;
7009f48a: 9802         	ldr	r0, [sp, #0x8]
7009f48c: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f490: f500 7001    	add.w	r0, r0, #0x204
7009f494: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaRxRtRegs->PEER0;
7009f496: 9802         	ldr	r0, [sp, #0x8]
7009f498: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009f49c: f500 7000    	add.w	r0, r0, #0x200
7009f4a0: 9005         	str	r0, [sp, #0x14]
7009f4a2: e7ff         	b	0x7009f4a4 <Udma_chConfigPdma+0xe4> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
7009f4a4: 9803         	ldr	r0, [sp, #0xc]
7009f4a6: 9908         	ldr	r1, [sp, #0x20]
7009f4a8: 9a06         	ldr	r2, [sp, #0x18]
7009f4aa: 9b04         	ldr	r3, [sp, #0x10]
7009f4ac: f8dd c014    	ldr.w	r12, [sp, #0x14]
7009f4b0: 46ee         	mov	lr, sp
7009f4b2: f8ce c000    	str.w	r12, [lr]
7009f4b6: f00b faf3    	bl	0x700aaaa0 <Udma_chSetPeerReg> @ imm = #0xb5e6
;         }
7009f4ba: e03c         	b	0x7009f536 <Udma_chConfigPdma+0x176> @ imm = #0x78
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f4bc: 9803         	ldr	r0, [sp, #0xc]
7009f4be: 6800         	ldr	r0, [r0]
7009f4c0: 2802         	cmp	r0, #0x2
7009f4c2: d137         	bne	0x7009f534 <Udma_chConfigPdma+0x174> @ imm = #0x6e
7009f4c4: e7ff         	b	0x7009f4c6 <Udma_chConfigPdma+0x106> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009f4c6: 9802         	ldr	r0, [sp, #0x8]
7009f4c8: 7800         	ldrb	r0, [r0]
7009f4ca: 07c0         	lsls	r0, r0, #0x1f
7009f4cc: b198         	cbz	r0, 0x7009f4f6 <Udma_chConfigPdma+0x136> @ imm = #0x26
7009f4ce: e7ff         	b	0x7009f4d0 <Udma_chConfigPdma+0x110> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pPktdmaTxRtRegs->PEER8;
7009f4d0: 9802         	ldr	r0, [sp, #0x8]
7009f4d2: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f4d6: f500 7008    	add.w	r0, r0, #0x220
7009f4da: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaTxRtRegs->PEER1;
7009f4dc: 9802         	ldr	r0, [sp, #0x8]
7009f4de: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f4e2: f500 7001    	add.w	r0, r0, #0x204
7009f4e6: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaTxRtRegs->PEER0;
7009f4e8: 9802         	ldr	r0, [sp, #0x8]
7009f4ea: f8d0 0230    	ldr.w	r0, [r0, #0x230]
7009f4ee: f500 7000    	add.w	r0, r0, #0x200
7009f4f2: 9005         	str	r0, [sp, #0x14]
;             }
7009f4f4: e012         	b	0x7009f51c <Udma_chConfigPdma+0x15c> @ imm = #0x24
;                 PEER8 = &chHandleInt->pPktdmaRxRtRegs->PEER8;
7009f4f6: 9802         	ldr	r0, [sp, #0x8]
7009f4f8: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f4fc: f500 7008    	add.w	r0, r0, #0x220
7009f500: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaRxRtRegs->PEER1;
7009f502: 9802         	ldr	r0, [sp, #0x8]
7009f504: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f508: f500 7001    	add.w	r0, r0, #0x204
7009f50c: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaRxRtRegs->PEER0;
7009f50e: 9802         	ldr	r0, [sp, #0x8]
7009f510: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009f514: f500 7000    	add.w	r0, r0, #0x200
7009f518: 9005         	str	r0, [sp, #0x14]
7009f51a: e7ff         	b	0x7009f51c <Udma_chConfigPdma+0x15c> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
7009f51c: 9803         	ldr	r0, [sp, #0xc]
7009f51e: 9908         	ldr	r1, [sp, #0x20]
7009f520: 9a06         	ldr	r2, [sp, #0x18]
7009f522: 9b04         	ldr	r3, [sp, #0x10]
7009f524: f8dd c014    	ldr.w	r12, [sp, #0x14]
7009f528: 46ee         	mov	lr, sp
7009f52a: f8ce c000    	str.w	r12, [lr]
7009f52e: f00b fab7    	bl	0x700aaaa0 <Udma_chSetPeerReg> @ imm = #0xb56e
;         }
7009f532: e7ff         	b	0x7009f534 <Udma_chConfigPdma+0x174> @ imm = #-0x2
7009f534: e7ff         	b	0x7009f536 <Udma_chConfigPdma+0x176> @ imm = #-0x2
;     }
7009f536: e7ff         	b	0x7009f538 <Udma_chConfigPdma+0x178> @ imm = #-0x2
;     return (retVal);
7009f538: 9807         	ldr	r0, [sp, #0x1c]
7009f53a: b00a         	add	sp, #0x28
7009f53c: bd80         	pop	{r7, pc}
7009f53e: 0000         	movs	r0, r0

7009f540 <xQueueSemaphoreTake>:
; {
7009f540: b580         	push	{r7, lr}
7009f542: b08a         	sub	sp, #0x28
7009f544: 9008         	str	r0, [sp, #0x20]
7009f546: 9107         	str	r1, [sp, #0x1c]
7009f548: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
7009f54a: 9006         	str	r0, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
7009f54c: 9908         	ldr	r1, [sp, #0x20]
7009f54e: 9103         	str	r1, [sp, #0xc]
;         BaseType_t xInheritanceOccurred = pdFALSE;
7009f550: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
7009f552: e7ff         	b	0x7009f554 <xQueueSemaphoreTake+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
7009f554: f00c ff4c    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0xce98
;             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
7009f558: 9803         	ldr	r0, [sp, #0xc]
7009f55a: 6b80         	ldr	r0, [r0, #0x38]
7009f55c: 9001         	str	r0, [sp, #0x4]
;             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
7009f55e: 9801         	ldr	r0, [sp, #0x4]
7009f560: b310         	cbz	r0, 0x7009f5a8 <xQueueSemaphoreTake+0x68> @ imm = #0x44
7009f562: e7ff         	b	0x7009f564 <xQueueSemaphoreTake+0x24> @ imm = #-0x2
;                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
7009f564: 9801         	ldr	r0, [sp, #0x4]
7009f566: 3801         	subs	r0, #0x1
7009f568: 9903         	ldr	r1, [sp, #0xc]
7009f56a: 6388         	str	r0, [r1, #0x38]
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
7009f56c: 9803         	ldr	r0, [sp, #0xc]
7009f56e: 6800         	ldr	r0, [r0]
7009f570: b928         	cbnz	r0, 0x7009f57e <xQueueSemaphoreTake+0x3e> @ imm = #0xa
7009f572: e7ff         	b	0x7009f574 <xQueueSemaphoreTake+0x34> @ imm = #-0x2
;                             pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
7009f574: f00d f974    	bl	0x700ac860 <pvTaskIncrementMutexHeldCount> @ imm = #0xd2e8
7009f578: 9903         	ldr	r1, [sp, #0xc]
7009f57a: 6088         	str	r0, [r1, #0x8]
;                         }
7009f57c: e000         	b	0x7009f580 <xQueueSemaphoreTake+0x40> @ imm = #0x0
7009f57e: e7ff         	b	0x7009f580 <xQueueSemaphoreTake+0x40> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
7009f580: 9803         	ldr	r0, [sp, #0xc]
7009f582: 6900         	ldr	r0, [r0, #0x10]
7009f584: b150         	cbz	r0, 0x7009f59c <xQueueSemaphoreTake+0x5c> @ imm = #0x14
7009f586: e7ff         	b	0x7009f588 <xQueueSemaphoreTake+0x48> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
7009f588: 9803         	ldr	r0, [sp, #0xc]
7009f58a: 3010         	adds	r0, #0x10
7009f58c: f006 fe78    	bl	0x700a6280 <xTaskRemoveFromEventList> @ imm = #0x6cf0
7009f590: b110         	cbz	r0, 0x7009f598 <xQueueSemaphoreTake+0x58> @ imm = #0x4
7009f592: e7ff         	b	0x7009f594 <xQueueSemaphoreTake+0x54> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
7009f594: df00         	svc	#0x0
;                     }
7009f596: e000         	b	0x7009f59a <xQueueSemaphoreTake+0x5a> @ imm = #0x0
7009f598: e7ff         	b	0x7009f59a <xQueueSemaphoreTake+0x5a> @ imm = #-0x2
;                 }
7009f59a: e000         	b	0x7009f59e <xQueueSemaphoreTake+0x5e> @ imm = #0x0
7009f59c: e7ff         	b	0x7009f59e <xQueueSemaphoreTake+0x5e> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
7009f59e: f00c f827    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xc04e
7009f5a2: 2001         	movs	r0, #0x1
;                 return pdPASS;
7009f5a4: 9009         	str	r0, [sp, #0x24]
7009f5a6: e083         	b	0x7009f6b0 <xQueueSemaphoreTake+0x170> @ imm = #0x106
;                 if( xTicksToWait == ( TickType_t ) 0 )
7009f5a8: 9807         	ldr	r0, [sp, #0x1c]
7009f5aa: b928         	cbnz	r0, 0x7009f5b8 <xQueueSemaphoreTake+0x78> @ imm = #0xa
7009f5ac: e7ff         	b	0x7009f5ae <xQueueSemaphoreTake+0x6e> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
7009f5ae: f00c f81f    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xc03e
7009f5b2: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
7009f5b4: 9009         	str	r0, [sp, #0x24]
7009f5b6: e07b         	b	0x7009f6b0 <xQueueSemaphoreTake+0x170> @ imm = #0xf6
;                 else if( xEntryTimeSet == pdFALSE )
7009f5b8: 9806         	ldr	r0, [sp, #0x18]
7009f5ba: b930         	cbnz	r0, 0x7009f5ca <xQueueSemaphoreTake+0x8a> @ imm = #0xc
7009f5bc: e7ff         	b	0x7009f5be <xQueueSemaphoreTake+0x7e> @ imm = #-0x2
7009f5be: a804         	add	r0, sp, #0x10
;                     vTaskInternalSetTimeOutState( &xTimeOut );
7009f5c0: f00d fc46    	bl	0x700ace50 <vTaskInternalSetTimeOutState> @ imm = #0xd88c
7009f5c4: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
7009f5c6: 9006         	str	r0, [sp, #0x18]
;                 }
7009f5c8: e000         	b	0x7009f5cc <xQueueSemaphoreTake+0x8c> @ imm = #0x0
7009f5ca: e7ff         	b	0x7009f5cc <xQueueSemaphoreTake+0x8c> @ imm = #-0x2
7009f5cc: e7ff         	b	0x7009f5ce <xQueueSemaphoreTake+0x8e> @ imm = #-0x2
7009f5ce: e7ff         	b	0x7009f5d0 <xQueueSemaphoreTake+0x90> @ imm = #-0x2
;         taskEXIT_CRITICAL();
7009f5d0: f00c f80e    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xc01c
;         vTaskSuspendAll();
7009f5d4: f00e f854    	bl	0x700ad680 <vTaskSuspendAll> @ imm = #0xe0a8
;         prvLockQueue( pxQueue );
7009f5d8: f00c ff0a    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0xce14
7009f5dc: 9803         	ldr	r0, [sp, #0xc]
7009f5de: f990 0044    	ldrsb.w	r0, [r0, #0x44]
7009f5e2: 3001         	adds	r0, #0x1
7009f5e4: b928         	cbnz	r0, 0x7009f5f2 <xQueueSemaphoreTake+0xb2> @ imm = #0xa
7009f5e6: e7ff         	b	0x7009f5e8 <xQueueSemaphoreTake+0xa8> @ imm = #-0x2
7009f5e8: 9903         	ldr	r1, [sp, #0xc]
7009f5ea: 2000         	movs	r0, #0x0
7009f5ec: f881 0044    	strb.w	r0, [r1, #0x44]
7009f5f0: e7ff         	b	0x7009f5f2 <xQueueSemaphoreTake+0xb2> @ imm = #-0x2
7009f5f2: 9803         	ldr	r0, [sp, #0xc]
7009f5f4: f990 0045    	ldrsb.w	r0, [r0, #0x45]
7009f5f8: 3001         	adds	r0, #0x1
7009f5fa: b928         	cbnz	r0, 0x7009f608 <xQueueSemaphoreTake+0xc8> @ imm = #0xa
7009f5fc: e7ff         	b	0x7009f5fe <xQueueSemaphoreTake+0xbe> @ imm = #-0x2
7009f5fe: 9903         	ldr	r1, [sp, #0xc]
7009f600: 2000         	movs	r0, #0x0
7009f602: f881 0045    	strb.w	r0, [r1, #0x45]
7009f606: e7ff         	b	0x7009f608 <xQueueSemaphoreTake+0xc8> @ imm = #-0x2
7009f608: f00b fff2    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xbfe4
7009f60c: a804         	add	r0, sp, #0x10
7009f60e: a907         	add	r1, sp, #0x1c
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
7009f610: f007 fd66    	bl	0x700a70e0 <xTaskCheckForTimeOut> @ imm = #0x7acc
7009f614: bb58         	cbnz	r0, 0x7009f66e <xQueueSemaphoreTake+0x12e> @ imm = #0x56
7009f616: e7ff         	b	0x7009f618 <xQueueSemaphoreTake+0xd8> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
7009f618: 9803         	ldr	r0, [sp, #0xc]
7009f61a: f00d fa59    	bl	0x700acad0 <prvIsQueueEmpty> @ imm = #0xd4b2
7009f61e: b1f8         	cbz	r0, 0x7009f660 <xQueueSemaphoreTake+0x120> @ imm = #0x3e
7009f620: e7ff         	b	0x7009f622 <xQueueSemaphoreTake+0xe2> @ imm = #-0x2
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
7009f622: 9803         	ldr	r0, [sp, #0xc]
7009f624: 6800         	ldr	r0, [r0]
7009f626: b950         	cbnz	r0, 0x7009f63e <xQueueSemaphoreTake+0xfe> @ imm = #0x14
7009f628: e7ff         	b	0x7009f62a <xQueueSemaphoreTake+0xea> @ imm = #-0x2
;                             taskENTER_CRITICAL();
7009f62a: f00c fee1    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0xcdc2
;                                 xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
7009f62e: 9803         	ldr	r0, [sp, #0xc]
7009f630: 6880         	ldr	r0, [r0, #0x8]
7009f632: f003 f9fd    	bl	0x700a2a30 <xTaskPriorityInherit> @ imm = #0x33fa
7009f636: 9002         	str	r0, [sp, #0x8]
;                             taskEXIT_CRITICAL();
7009f638: f00b ffda    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xbfb4
;                         }
7009f63c: e000         	b	0x7009f640 <xQueueSemaphoreTake+0x100> @ imm = #0x0
7009f63e: e7ff         	b	0x7009f640 <xQueueSemaphoreTake+0x100> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
7009f640: 9803         	ldr	r0, [sp, #0xc]
7009f642: 3024         	adds	r0, #0x24
7009f644: 9907         	ldr	r1, [sp, #0x1c]
7009f646: f00d fb03    	bl	0x700acc50 <vTaskPlaceOnEventList> @ imm = #0xd606
;                 prvUnlockQueue( pxQueue );
7009f64a: 9803         	ldr	r0, [sp, #0xc]
7009f64c: f006 fb58    	bl	0x700a5d00 <prvUnlockQueue> @ imm = #0x66b0
;                 if( xTaskResumeAll() == pdFALSE )
7009f650: f001 fa6e    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #0x14dc
7009f654: b910         	cbnz	r0, 0x7009f65c <xQueueSemaphoreTake+0x11c> @ imm = #0x4
7009f656: e7ff         	b	0x7009f658 <xQueueSemaphoreTake+0x118> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
7009f658: df00         	svc	#0x0
;                 }
7009f65a: e000         	b	0x7009f65e <xQueueSemaphoreTake+0x11e> @ imm = #0x0
7009f65c: e7ff         	b	0x7009f65e <xQueueSemaphoreTake+0x11e> @ imm = #-0x2
;             }
7009f65e: e005         	b	0x7009f66c <xQueueSemaphoreTake+0x12c> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
7009f660: 9803         	ldr	r0, [sp, #0xc]
7009f662: f006 fb4d    	bl	0x700a5d00 <prvUnlockQueue> @ imm = #0x669a
;                 ( void ) xTaskResumeAll();
7009f666: f001 fa63    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #0x14c6
7009f66a: e7ff         	b	0x7009f66c <xQueueSemaphoreTake+0x12c> @ imm = #-0x2
;         }
7009f66c: e01f         	b	0x7009f6ae <xQueueSemaphoreTake+0x16e> @ imm = #0x3e
;             prvUnlockQueue( pxQueue );
7009f66e: 9803         	ldr	r0, [sp, #0xc]
7009f670: f006 fb46    	bl	0x700a5d00 <prvUnlockQueue> @ imm = #0x668c
;             ( void ) xTaskResumeAll();
7009f674: f001 fa5c    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #0x14b8
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
7009f678: 9803         	ldr	r0, [sp, #0xc]
7009f67a: f00d fa29    	bl	0x700acad0 <prvIsQueueEmpty> @ imm = #0xd452
7009f67e: b1a0         	cbz	r0, 0x7009f6aa <xQueueSemaphoreTake+0x16a> @ imm = #0x28
7009f680: e7ff         	b	0x7009f682 <xQueueSemaphoreTake+0x142> @ imm = #-0x2
;                         if( xInheritanceOccurred != pdFALSE )
7009f682: 9802         	ldr	r0, [sp, #0x8]
7009f684: b170         	cbz	r0, 0x7009f6a4 <xQueueSemaphoreTake+0x164> @ imm = #0x1c
7009f686: e7ff         	b	0x7009f688 <xQueueSemaphoreTake+0x148> @ imm = #-0x2
;                             taskENTER_CRITICAL();
7009f688: f00c feb2    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0xcd64
;                                 uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
7009f68c: 9803         	ldr	r0, [sp, #0xc]
7009f68e: f00d fac7    	bl	0x700acc20 <prvGetDisinheritPriorityAfterTimeout> @ imm = #0xd58e
7009f692: 9000         	str	r0, [sp]
;                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
7009f694: 9803         	ldr	r0, [sp, #0xc]
7009f696: 6880         	ldr	r0, [r0, #0x8]
7009f698: 9900         	ldr	r1, [sp]
7009f69a: f004 f8d9    	bl	0x700a3850 <vTaskPriorityDisinheritAfterTimeout> @ imm = #0x41b2
;                             taskEXIT_CRITICAL();
7009f69e: f00b ffa7    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xbf4e
;                         }
7009f6a2: e7ff         	b	0x7009f6a4 <xQueueSemaphoreTake+0x164> @ imm = #-0x2
7009f6a4: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
7009f6a6: 9009         	str	r0, [sp, #0x24]
7009f6a8: e002         	b	0x7009f6b0 <xQueueSemaphoreTake+0x170> @ imm = #0x4
7009f6aa: e7ff         	b	0x7009f6ac <xQueueSemaphoreTake+0x16c> @ imm = #-0x2
7009f6ac: e7ff         	b	0x7009f6ae <xQueueSemaphoreTake+0x16e> @ imm = #-0x2
;     for( ; ; )
7009f6ae: e751         	b	0x7009f554 <xQueueSemaphoreTake+0x14> @ imm = #-0x15e
; }
7009f6b0: 9809         	ldr	r0, [sp, #0x24]
7009f6b2: b00a         	add	sp, #0x28
7009f6b4: bd80         	pop	{r7, pc}
7009f6b6: 0000         	movs	r0, r0

7009f6b8 <memalign>:
7009f6b8: e3510000     	cmp	r1, #0
7009f6bc: 0a000054     	beq	0x7009f814 <memalign+0x15c> @ imm = #0x150
7009f6c0: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
7009f6c4: e59f6150     	ldr	r6, [pc, #0x150]        @ 0x7009f81c <memalign+0x164>
7009f6c8: e3a07000     	mov	r7, #0
7009f6cc: e1a02000     	mov	r2, r0
7009f6d0: e3a00000     	mov	r0, #0
7009f6d4: e3560007     	cmp	r6, #7
7009f6d8: 82467008     	subhi	r7, r6, #8
7009f6dc: e1570001     	cmp	r7, r1
7009f6e0: 38bd81f0     	poplo	{r4, r5, r6, r7, r8, pc}
7009f6e4: e2424001     	sub	r4, r2, #1
7009f6e8: e59f5130     	ldr	r5, [pc, #0x130]        @ 0x7009f820 <memalign+0x168>
7009f6ec: e3a03008     	mov	r3, #8
7009f6f0: e2811007     	add	r1, r1, #7
7009f6f4: e1120004     	tst	r2, r4
7009f6f8: e3a04008     	mov	r4, #8
7009f6fc: 01a03002     	moveq	r3, r2
7009f700: e3520007     	cmp	r2, #7
7009f704: e5d52000     	ldrb	r2, [r5]
7009f708: 91a03004     	movls	r3, r4
7009f70c: e3520000     	cmp	r2, #0
7009f710: 1a00000a     	bne	0x7009f740 <memalign+0x88> @ imm = #0x28
7009f714: e3a02000     	mov	r2, #0
7009f718: e3560009     	cmp	r6, #9
7009f71c: 3a000003     	blo	0x7009f730 <memalign+0x78> @ imm = #0xc
7009f720: e59f20fc     	ldr	r2, [pc, #0xfc]         @ 0x7009f824 <memalign+0x16c>
7009f724: e3a06000     	mov	r6, #0
7009f728: e5827000     	str	r7, [r2]
7009f72c: e5826008     	str	r6, [r2, #0x8]
7009f730: e3a06001     	mov	r6, #1
7009f734: e59f70ec     	ldr	r7, [pc, #0xec]         @ 0x7009f828 <memalign+0x170>
7009f738: e5872000     	str	r2, [r7]
7009f73c: e5c56000     	strb	r6, [r5]
7009f740: e59f60e0     	ldr	r6, [pc, #0xe0]         @ 0x7009f828 <memalign+0x170>
7009f744: e3c18007     	bic	r8, r1, #7
7009f748: e243c001     	sub	r12, r3, #1
7009f74c: e2632000     	rsb	r2, r3, #0
7009f750: e5965000     	ldr	r5, [r6]
7009f754: e3550000     	cmp	r5, #0
7009f758: 0a00002c     	beq	0x7009f810 <memalign+0x158> @ imm = #0xb0
7009f75c: e2856008     	add	r6, r5, #8
7009f760: e08c7006     	add	r7, r12, r6
7009f764: e0077002     	and	r7, r7, r2
7009f768: e1560007     	cmp	r6, r7
7009f76c: 0a00000c     	beq	0x7009f7a4 <memalign+0xec> @ imm = #0x30
7009f770: e2854010     	add	r4, r5, #16
7009f774: e2471008     	sub	r1, r7, #8
7009f778: e1540001     	cmp	r4, r1
7009f77c: 9a000001     	bls	0x7009f788 <memalign+0xd0> @ imm = #0x4
7009f780: e0877003     	add	r7, r7, r3
7009f784: eafffffa     	b	0x7009f774 <memalign+0xbc> @ imm = #-0x18
7009f788: e5951000     	ldr	r1, [r5]
7009f78c: e0874008     	add	r4, r7, r8
7009f790: e3c11001     	bic	r1, r1, #1
7009f794: e0861001     	add	r1, r6, r1
7009f798: e1510004     	cmp	r1, r4
7009f79c: 3affffeb     	blo	0x7009f750 <memalign+0x98> @ imm = #-0x54
7009f7a0: ea000004     	b	0x7009f7b8 <memalign+0x100> @ imm = #0x10
7009f7a4: e5951000     	ldr	r1, [r5]
7009f7a8: e3c11001     	bic	r1, r1, #1
7009f7ac: e1510008     	cmp	r1, r8
7009f7b0: baffffe6     	blt	0x7009f750 <memalign+0x98> @ imm = #-0x68
7009f7b4: e1a07006     	mov	r7, r6
7009f7b8: e1a00005     	mov	r0, r5
7009f7bc: eb0032ac     	bl	0x700ac274 <free_list_remove> @ imm = #0xcab0
7009f7c0: e1570006     	cmp	r7, r6
7009f7c4: 0a00000d     	beq	0x7009f800 <memalign+0x148> @ imm = #0x34
7009f7c8: e5950000     	ldr	r0, [r5]
7009f7cc: e0471006     	sub	r1, r7, r6
7009f7d0: e2411008     	sub	r1, r1, #8
7009f7d4: e1a04005     	mov	r4, r5
7009f7d8: e3c00001     	bic	r0, r0, #1
7009f7dc: e3c12001     	bic	r2, r1, #1
7009f7e0: e0400001     	sub	r0, r0, r1
7009f7e4: e3800001     	orr	r0, r0, #1
7009f7e8: e2400008     	sub	r0, r0, #8
7009f7ec: e6841002     	str	r1, [r4], r2
7009f7f0: e5a40008     	str	r0, [r4, #0x8]!
7009f7f4: e1a00005     	mov	r0, r5
7009f7f8: eb002fb5     	bl	0x700ab6d4 <free_list_insert> @ imm = #0xbed4
7009f7fc: e1a05004     	mov	r5, r4
7009f800: e1a00005     	mov	r0, r5
7009f804: e1a01008     	mov	r1, r8
7009f808: eb001bf9     	bl	0x700a67f4 <split>      @ imm = #0x6fe4
7009f80c: e2850008     	add	r0, r5, #8
7009f810: e8bd81f0     	pop	{r4, r5, r6, r7, r8, pc}
7009f814: e3a00000     	mov	r0, #0
7009f818: e12fff1e     	bx	lr
7009f81c: 00 00 01 00  	.word	0x00010000
7009f820: 24 02 0b 70  	.word	0x700b0224
7009f824: 00 50 08 70  	.word	0x70085000
7009f828: c4 4f 08 70  	.word	0x70084fc4
7009f82c: 00 00 00 00  	.word	0x00000000

7009f830 <CSL_bcdmaChanOpTeardownChan>:
; {
7009f830: b580         	push	{r7, lr}
7009f832: b08c         	sub	sp, #0x30
7009f834: 900b         	str	r0, [sp, #0x2c]
7009f836: 910a         	str	r1, [sp, #0x28]
7009f838: 9209         	str	r2, [sp, #0x24]
7009f83a: 9308         	str	r3, [sp, #0x20]
7009f83c: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
7009f83e: 9007         	str	r0, [sp, #0x1c]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
7009f840: 980b         	ldr	r0, [sp, #0x2c]
7009f842: 990a         	ldr	r1, [sp, #0x28]
7009f844: 9a09         	ldr	r2, [sp, #0x24]
7009f846: f009 f86b    	bl	0x700a8920 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x90d6
7009f84a: b920         	cbnz	r0, 0x7009f856 <CSL_bcdmaChanOpTeardownChan+0x26> @ imm = #0x8
7009f84c: e7ff         	b	0x7009f84e <CSL_bcdmaChanOpTeardownChan+0x1e> @ imm = #-0x2
7009f84e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
7009f852: 9007         	str	r0, [sp, #0x1c]
;     }
7009f854: e09f         	b	0x7009f996 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #0x13e
7009f856: 2000         	movs	r0, #0x0
;         uint32_t force = (uint32_t)0U, wait = (uint32_t)0U;
7009f858: 9005         	str	r0, [sp, #0x14]
7009f85a: 9004         	str	r0, [sp, #0x10]
;         if( pOpData != NULL )
7009f85c: 9808         	ldr	r0, [sp, #0x20]
7009f85e: b148         	cbz	r0, 0x7009f874 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #0x12
7009f860: e7ff         	b	0x7009f862 <CSL_bcdmaChanOpTeardownChan+0x32> @ imm = #-0x2
;             CSL_BcdmaTeardownOpts *pTdOpts = (CSL_BcdmaTeardownOpts *)pOpData;
7009f862: 9808         	ldr	r0, [sp, #0x20]
7009f864: 9003         	str	r0, [sp, #0xc]
;             force = pTdOpts->force;
7009f866: 9803         	ldr	r0, [sp, #0xc]
7009f868: 6800         	ldr	r0, [r0]
7009f86a: 9005         	str	r0, [sp, #0x14]
;             wait  = pTdOpts->wait;
7009f86c: 9803         	ldr	r0, [sp, #0xc]
7009f86e: 6840         	ldr	r0, [r0, #0x4]
7009f870: 9004         	str	r0, [sp, #0x10]
;         }
7009f872: e7ff         	b	0x7009f874 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #-0x2
;         switch( chanType )
7009f874: 980a         	ldr	r0, [sp, #0x28]
7009f876: 9001         	str	r0, [sp, #0x4]
7009f878: b148         	cbz	r0, 0x7009f88e <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #0x12
7009f87a: e7ff         	b	0x7009f87c <CSL_bcdmaChanOpTeardownChan+0x4c> @ imm = #-0x2
7009f87c: 9801         	ldr	r0, [sp, #0x4]
7009f87e: 2801         	cmp	r0, #0x1
7009f880: d024         	beq	0x7009f8cc <CSL_bcdmaChanOpTeardownChan+0x9c> @ imm = #0x48
7009f882: e7ff         	b	0x7009f884 <CSL_bcdmaChanOpTeardownChan+0x54> @ imm = #-0x2
7009f884: 9801         	ldr	r0, [sp, #0x4]
7009f886: 2802         	cmp	r0, #0x2
7009f888: d03f         	beq	0x7009f90a <CSL_bcdmaChanOpTeardownChan+0xda> @ imm = #0x7e
7009f88a: e7ff         	b	0x7009f88c <CSL_bcdmaChanOpTeardownChan+0x5c> @ imm = #-0x2
;         {
7009f88c: e7ff         	b	0x7009f88e <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
7009f88e: 980b         	ldr	r0, [sp, #0x2c]
7009f890: 6880         	ldr	r0, [r0, #0x8]
7009f892: 9909         	ldr	r1, [sp, #0x24]
7009f894: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f898: f00d ff12    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xde24
7009f89c: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
7009f89e: 9806         	ldr	r0, [sp, #0x18]
7009f8a0: f040 4080    	orr	r0, r0, #0x40000000
7009f8a4: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
7009f8a6: 9806         	ldr	r0, [sp, #0x18]
7009f8a8: f020 5180    	bic	r1, r0, #0x10000000
7009f8ac: 9a05         	ldr	r2, [sp, #0x14]
7009f8ae: f101 5080    	add.w	r0, r1, #0x10000000
7009f8b2: 2a00         	cmp	r2, #0x0
7009f8b4: bf08         	it	eq
7009f8b6: 4608         	moveq	r0, r1
7009f8b8: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, regVal );
7009f8ba: 980b         	ldr	r0, [sp, #0x2c]
7009f8bc: 6880         	ldr	r0, [r0, #0x8]
7009f8be: 9909         	ldr	r1, [sp, #0x24]
7009f8c0: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f8c4: 9906         	ldr	r1, [sp, #0x18]
7009f8c6: f00d fe5b    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xdcb6
;                 break;
7009f8ca: e03d         	b	0x7009f948 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x7a
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
7009f8cc: 980b         	ldr	r0, [sp, #0x2c]
7009f8ce: 6900         	ldr	r0, [r0, #0x10]
7009f8d0: 9909         	ldr	r1, [sp, #0x24]
7009f8d2: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f8d6: f00d fef3    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xdde6
7009f8da: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
7009f8dc: 9806         	ldr	r0, [sp, #0x18]
7009f8de: f040 4080    	orr	r0, r0, #0x40000000
7009f8e2: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
7009f8e4: 9806         	ldr	r0, [sp, #0x18]
7009f8e6: f020 5180    	bic	r1, r0, #0x10000000
7009f8ea: 9a05         	ldr	r2, [sp, #0x14]
7009f8ec: f101 5080    	add.w	r0, r1, #0x10000000
7009f8f0: 2a00         	cmp	r2, #0x0
7009f8f2: bf08         	it	eq
7009f8f4: 4608         	moveq	r0, r1
7009f8f6: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
7009f8f8: 980b         	ldr	r0, [sp, #0x2c]
7009f8fa: 6900         	ldr	r0, [r0, #0x10]
7009f8fc: 9909         	ldr	r1, [sp, #0x24]
7009f8fe: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f902: 9906         	ldr	r1, [sp, #0x18]
7009f904: f00d fe3c    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xdc78
;                 break;
7009f908: e01e         	b	0x7009f948 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x3c
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
7009f90a: 980b         	ldr	r0, [sp, #0x2c]
7009f90c: 6980         	ldr	r0, [r0, #0x18]
7009f90e: 9909         	ldr	r1, [sp, #0x24]
7009f910: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f914: f00d fed4    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xdda8
7009f918: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
7009f91a: 9806         	ldr	r0, [sp, #0x18]
7009f91c: f040 4080    	orr	r0, r0, #0x40000000
7009f920: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
7009f922: 9806         	ldr	r0, [sp, #0x18]
7009f924: f020 5180    	bic	r1, r0, #0x10000000
7009f928: 9a05         	ldr	r2, [sp, #0x14]
7009f92a: f101 5080    	add.w	r0, r1, #0x10000000
7009f92e: 2a00         	cmp	r2, #0x0
7009f930: bf08         	it	eq
7009f932: 4608         	moveq	r0, r1
7009f934: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
7009f936: 980b         	ldr	r0, [sp, #0x2c]
7009f938: 6980         	ldr	r0, [r0, #0x18]
7009f93a: 9909         	ldr	r1, [sp, #0x24]
7009f93c: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f940: 9906         	ldr	r1, [sp, #0x18]
7009f942: f00d fe1d    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xdc3a
;                 break;
7009f946: e7ff         	b	0x7009f948 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #-0x2
;         if(wait != 0U)
7009f948: 9804         	ldr	r0, [sp, #0x10]
7009f94a: b318         	cbz	r0, 0x7009f994 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #0x46
7009f94c: e7ff         	b	0x7009f94e <CSL_bcdmaChanOpTeardownChan+0x11e> @ imm = #-0x2
7009f94e: 2080         	movs	r0, #0x80
;             uint32_t retryCnt = CSL_BCDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
7009f950: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
7009f952: e7ff         	b	0x7009f954 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x2
7009f954: 980b         	ldr	r0, [sp, #0x2c]
7009f956: 990a         	ldr	r1, [sp, #0x28]
7009f958: 9a09         	ldr	r2, [sp, #0x24]
7009f95a: f008 ffe1    	bl	0x700a8920 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x8fc2
7009f95e: 4601         	mov	r1, r0
7009f960: 2000         	movs	r0, #0x0
7009f962: 9000         	str	r0, [sp]
7009f964: b131         	cbz	r1, 0x7009f974 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #0xc
7009f966: e7ff         	b	0x7009f968 <CSL_bcdmaChanOpTeardownChan+0x138> @ imm = #-0x2
7009f968: 9802         	ldr	r0, [sp, #0x8]
7009f96a: 2800         	cmp	r0, #0x0
7009f96c: bf18         	it	ne
7009f96e: 2001         	movne	r0, #0x1
7009f970: 9000         	str	r0, [sp]
7009f972: e7ff         	b	0x7009f974 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #-0x2
7009f974: 9800         	ldr	r0, [sp]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
7009f976: 07c0         	lsls	r0, r0, #0x1f
7009f978: b120         	cbz	r0, 0x7009f984 <CSL_bcdmaChanOpTeardownChan+0x154> @ imm = #0x8
7009f97a: e7ff         	b	0x7009f97c <CSL_bcdmaChanOpTeardownChan+0x14c> @ imm = #-0x2
;                 retryCnt--;
7009f97c: 9802         	ldr	r0, [sp, #0x8]
7009f97e: 3801         	subs	r0, #0x1
7009f980: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
7009f982: e7e7         	b	0x7009f954 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x32
;             if( retryCnt == (uint32_t)0U ) {
7009f984: 9802         	ldr	r0, [sp, #0x8]
7009f986: b920         	cbnz	r0, 0x7009f992 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #0x8
7009f988: e7ff         	b	0x7009f98a <CSL_bcdmaChanOpTeardownChan+0x15a> @ imm = #-0x2
7009f98a: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = CSL_EFAIL;
7009f98e: 9007         	str	r0, [sp, #0x1c]
;             }
7009f990: e7ff         	b	0x7009f992 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #-0x2
;         }
7009f992: e7ff         	b	0x7009f994 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #-0x2
7009f994: e7ff         	b	0x7009f996 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #-0x2
;     return retVal;
7009f996: 9807         	ldr	r0, [sp, #0x1c]
7009f998: b00c         	add	sp, #0x30
7009f99a: bd80         	pop	{r7, pc}
7009f99c: 0000         	movs	r0, r0
7009f99e: 0000         	movs	r0, r0

7009f9a0 <CSL_bcdmaChanOp>:
; {
7009f9a0: b580         	push	{r7, lr}
7009f9a2: b088         	sub	sp, #0x20
7009f9a4: f8dd c028    	ldr.w	r12, [sp, #0x28]
7009f9a8: 9007         	str	r0, [sp, #0x1c]
7009f9aa: 9106         	str	r1, [sp, #0x18]
7009f9ac: 9205         	str	r2, [sp, #0x14]
7009f9ae: 9304         	str	r3, [sp, #0x10]
7009f9b0: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
7009f9b2: 9003         	str	r0, [sp, #0xc]
;     if( ( pCfg == NULL )                                    ||
7009f9b4: 9807         	ldr	r0, [sp, #0x1c]
7009f9b6: b158         	cbz	r0, 0x7009f9d0 <CSL_bcdmaChanOp+0x30> @ imm = #0x16
7009f9b8: e7ff         	b	0x7009f9ba <CSL_bcdmaChanOp+0x1a> @ imm = #-0x2
;         ( chanType > CSL_BCDMA_CHAN_TYPE_SPLIT_RX )         ||
7009f9ba: 9805         	ldr	r0, [sp, #0x14]
7009f9bc: 2802         	cmp	r0, #0x2
7009f9be: d807         	bhi	0x7009f9d0 <CSL_bcdmaChanOp+0x30> @ imm = #0xe
7009f9c0: e7ff         	b	0x7009f9c2 <CSL_bcdmaChanOp+0x22> @ imm = #-0x2
;         ( !CSL_bcdmaChanOpIsValidChanIdx( pCfg, chanType, chanIdx ) )
7009f9c2: 9807         	ldr	r0, [sp, #0x1c]
7009f9c4: 9905         	ldr	r1, [sp, #0x14]
7009f9c6: 9a04         	ldr	r2, [sp, #0x10]
7009f9c8: f008 ffea    	bl	0x700a89a0 <CSL_bcdmaChanOpIsValidChanIdx> @ imm = #0x8fd4
;     if( ( pCfg == NULL )                                    ||
7009f9cc: b920         	cbnz	r0, 0x7009f9d8 <CSL_bcdmaChanOp+0x38> @ imm = #0x8
7009f9ce: e7ff         	b	0x7009f9d0 <CSL_bcdmaChanOp+0x30> @ imm = #-0x2
7009f9d0: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
7009f9d4: 9003         	str	r0, [sp, #0xc]
;     }
7009f9d6: e094         	b	0x7009fb02 <CSL_bcdmaChanOp+0x162> @ imm = #0x128
;         switch(chanOp )
7009f9d8: 9806         	ldr	r0, [sp, #0x18]
7009f9da: 9002         	str	r0, [sp, #0x8]
7009f9dc: 280e         	cmp	r0, #0xe
7009f9de: f200 808b    	bhi.w	0x7009faf8 <CSL_bcdmaChanOp+0x158> @ imm = #0x116
7009f9e2: 9902         	ldr	r1, [sp, #0x8]
7009f9e4: e8df f001    	tbb	[pc, r1]
7009f9e8: 08 10 18 20  	.word	0x20181008
7009f9ec: 28 30 38 3f  	.word	0x3f383028
7009f9f0: 47 4f 57 5f  	.word	0x5f574f47
7009f9f4: 6c 79 81 00  	.word	0x0081796c
;                 retVal = CSL_bcdmaChanOpCfgChan( pCfg, chanType, chanIdx, pOpData );
7009f9f8: 9807         	ldr	r0, [sp, #0x1c]
7009f9fa: 9905         	ldr	r1, [sp, #0x14]
7009f9fc: 9a04         	ldr	r2, [sp, #0x10]
7009f9fe: 9b0a         	ldr	r3, [sp, #0x28]
7009fa00: f7fc fd0e    	bl	0x7009c420 <CSL_bcdmaChanOpCfgChan> @ imm = #-0x35e4
7009fa04: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa06: e07b         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0xf6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)true );
7009fa08: 9807         	ldr	r0, [sp, #0x1c]
7009fa0a: 9905         	ldr	r1, [sp, #0x14]
7009fa0c: 9a04         	ldr	r2, [sp, #0x10]
7009fa0e: 2301         	movs	r3, #0x1
7009fa10: f007 fbb6    	bl	0x700a7180 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x776c
7009fa14: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa16: e073         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0xe6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)false );
7009fa18: 9807         	ldr	r0, [sp, #0x1c]
7009fa1a: 9905         	ldr	r1, [sp, #0x14]
7009fa1c: 9a04         	ldr	r2, [sp, #0x10]
7009fa1e: 2300         	movs	r3, #0x0
7009fa20: f007 fbae    	bl	0x700a7180 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x775c
7009fa24: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa26: e06b         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0xd6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)true );
7009fa28: 9807         	ldr	r0, [sp, #0x1c]
7009fa2a: 9905         	ldr	r1, [sp, #0x14]
7009fa2c: 9a04         	ldr	r2, [sp, #0x10]
7009fa2e: 2301         	movs	r3, #0x1
7009fa30: f006 fb76    	bl	0x700a6120 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x66ec
7009fa34: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa36: e063         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0xc6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)false );
7009fa38: 9807         	ldr	r0, [sp, #0x1c]
7009fa3a: 9905         	ldr	r1, [sp, #0x14]
7009fa3c: 9a04         	ldr	r2, [sp, #0x10]
7009fa3e: 2300         	movs	r3, #0x0
7009fa40: f006 fb6e    	bl	0x700a6120 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x66dc
7009fa44: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa46: e05b         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0xb6
;                 retVal = CSL_bcdmaChanOpTeardownChan( pCfg, chanType, chanIdx, pOpData );
7009fa48: 9807         	ldr	r0, [sp, #0x1c]
7009fa4a: 9905         	ldr	r1, [sp, #0x14]
7009fa4c: 9a04         	ldr	r2, [sp, #0x10]
7009fa4e: 9b0a         	ldr	r3, [sp, #0x28]
7009fa50: f7ff feee    	bl	0x7009f830 <CSL_bcdmaChanOpTeardownChan> @ imm = #-0x224
7009fa54: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa56: e053         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0xa6
;                 retVal = CSL_bcdmaChanOpTriggerChan( pCfg, chanType, chanIdx );
7009fa58: 9807         	ldr	r0, [sp, #0x1c]
7009fa5a: 9905         	ldr	r1, [sp, #0x14]
7009fa5c: 9a04         	ldr	r2, [sp, #0x10]
7009fa5e: f009 fb1f    	bl	0x700a90a0 <CSL_bcdmaChanOpTriggerChan> @ imm = #0x963e
7009fa62: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa64: e04c         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0x98
;                 retVal = CSL_bcdmaChanOpGetChanRT( pCfg, chanType, chanIdx, pOpData );
7009fa66: 9807         	ldr	r0, [sp, #0x1c]
7009fa68: 9905         	ldr	r1, [sp, #0x14]
7009fa6a: 9a04         	ldr	r2, [sp, #0x10]
7009fa6c: 9b0a         	ldr	r3, [sp, #0x28]
7009fa6e: f004 fd67    	bl	0x700a4540 <CSL_bcdmaChanOpGetChanRT> @ imm = #0x4ace
7009fa72: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa74: e044         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0x88
;                 retVal = CSL_bcdmaChanOpSetChanRT( pCfg, chanType, chanIdx, pOpData );
7009fa76: 9807         	ldr	r0, [sp, #0x1c]
7009fa78: 9905         	ldr	r1, [sp, #0x14]
7009fa7a: 9a04         	ldr	r2, [sp, #0x10]
7009fa7c: 9b0a         	ldr	r3, [sp, #0x28]
7009fa7e: f006 fba7    	bl	0x700a61d0 <CSL_bcdmaChanOpSetChanRT> @ imm = #0x674e
7009fa82: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa84: e03c         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0x78
;                 retVal = CSL_bcdmaChanOpGetChanStats( pCfg, chanType, chanIdx, pOpData );
7009fa86: 9807         	ldr	r0, [sp, #0x1c]
7009fa88: 9905         	ldr	r1, [sp, #0x14]
7009fa8a: 9a04         	ldr	r2, [sp, #0x10]
7009fa8c: 9b0a         	ldr	r3, [sp, #0x28]
7009fa8e: f000 fb0f    	bl	0x700a00b0 <CSL_bcdmaChanOpGetChanStats> @ imm = #0x61e
7009fa92: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fa94: e034         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0x68
;                 retVal = CSL_bcdmaChanOpDecChanStats( pCfg, chanType, chanIdx, pOpData );
7009fa96: 9807         	ldr	r0, [sp, #0x1c]
7009fa98: 9905         	ldr	r1, [sp, #0x14]
7009fa9a: 9a04         	ldr	r2, [sp, #0x10]
7009fa9c: 9b0a         	ldr	r3, [sp, #0x28]
7009fa9e: f003 f9ff    	bl	0x700a2ea0 <CSL_bcdmaChanOpDecChanStats> @ imm = #0x33fe
7009faa2: 9003         	str	r0, [sp, #0xc]
;                 break;
7009faa4: e02c         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0x58
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)true );
7009faa6: 9807         	ldr	r0, [sp, #0x1c]
7009faa8: 9905         	ldr	r1, [sp, #0x14]
7009faaa: 9a04         	ldr	r2, [sp, #0x10]
7009faac: 9b0a         	ldr	r3, [sp, #0x28]
7009faae: 46ee         	mov	lr, sp
7009fab0: f04f 0c01    	mov.w	r12, #0x1
7009fab4: f8ce c000    	str.w	r12, [lr]
7009fab8: f005 fd1a    	bl	0x700a54f0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5a34
7009fabc: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fabe: e01f         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0x3e
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)false );
7009fac0: 9807         	ldr	r0, [sp, #0x1c]
7009fac2: 9905         	ldr	r1, [sp, #0x14]
7009fac4: 9a04         	ldr	r2, [sp, #0x10]
7009fac6: 9b0a         	ldr	r3, [sp, #0x28]
7009fac8: 46ee         	mov	lr, sp
7009faca: f04f 0c00    	mov.w	r12, #0x0
7009face: f8ce c000    	str.w	r12, [lr]
7009fad2: f005 fd0d    	bl	0x700a54f0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5a1a
7009fad6: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fad8: e012         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0x24
;                 retVal = CSL_bcdmaChanOpSetBurstSize( pCfg, chanType, chanIdx, pOpData );
7009fada: 9807         	ldr	r0, [sp, #0x1c]
7009fadc: 9905         	ldr	r1, [sp, #0x14]
7009fade: 9a04         	ldr	r2, [sp, #0x10]
7009fae0: 9b0a         	ldr	r3, [sp, #0x28]
7009fae2: f005 f825    	bl	0x700a4b30 <CSL_bcdmaChanOpSetBurstSize> @ imm = #0x504a
7009fae6: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fae8: e00a         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0x14
;                 retVal = CSL_bcdmaChanOpClearError( pCfg, chanType, chanIdx );
7009faea: 9807         	ldr	r0, [sp, #0x1c]
7009faec: 9905         	ldr	r1, [sp, #0x14]
7009faee: 9a04         	ldr	r2, [sp, #0x10]
7009faf0: f009 f956    	bl	0x700a8da0 <CSL_bcdmaChanOpClearError> @ imm = #0x92ac
7009faf4: 9003         	str	r0, [sp, #0xc]
;                 break;
7009faf6: e003         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #0x6
7009faf8: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
7009fafc: 9003         	str	r0, [sp, #0xc]
;                 break;
7009fafe: e7ff         	b	0x7009fb00 <CSL_bcdmaChanOp+0x160> @ imm = #-0x2
7009fb00: e7ff         	b	0x7009fb02 <CSL_bcdmaChanOp+0x162> @ imm = #-0x2
;     return retVal;
7009fb02: 9803         	ldr	r0, [sp, #0xc]
7009fb04: b008         	add	sp, #0x20
7009fb06: bd80         	pop	{r7, pc}
		...

7009fb10 <Udma_chOpen>:
; {
7009fb10: b580         	push	{r7, lr}
7009fb12: b08a         	sub	sp, #0x28
7009fb14: 9009         	str	r0, [sp, #0x24]
7009fb16: 9108         	str	r1, [sp, #0x20]
7009fb18: 9207         	str	r2, [sp, #0x1c]
7009fb1a: 9306         	str	r3, [sp, #0x18]
7009fb1c: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK, tempRetVal;
7009fb1e: 9005         	str	r0, [sp, #0x14]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009fb20: 9003         	str	r0, [sp, #0xc]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009fb22: 9809         	ldr	r0, [sp, #0x24]
7009fb24: 9001         	str	r0, [sp, #0x4]
;     if((drvHandleInt == NULL_PTR) || (NULL_PTR == chHandle) || (NULL_PTR == chPrms))
7009fb26: 9801         	ldr	r0, [sp, #0x4]
7009fb28: b130         	cbz	r0, 0x7009fb38 <Udma_chOpen+0x28> @ imm = #0xc
7009fb2a: e7ff         	b	0x7009fb2c <Udma_chOpen+0x1c> @ imm = #-0x2
7009fb2c: 9808         	ldr	r0, [sp, #0x20]
7009fb2e: b118         	cbz	r0, 0x7009fb38 <Udma_chOpen+0x28> @ imm = #0x6
7009fb30: e7ff         	b	0x7009fb32 <Udma_chOpen+0x22> @ imm = #-0x2
7009fb32: 9806         	ldr	r0, [sp, #0x18]
7009fb34: b920         	cbnz	r0, 0x7009fb40 <Udma_chOpen+0x30> @ imm = #0x8
7009fb36: e7ff         	b	0x7009fb38 <Udma_chOpen+0x28> @ imm = #-0x2
7009fb38: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009fb3c: 9005         	str	r0, [sp, #0x14]
;     }
7009fb3e: e7ff         	b	0x7009fb40 <Udma_chOpen+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fb40: 9805         	ldr	r0, [sp, #0x14]
7009fb42: b978         	cbnz	r0, 0x7009fb64 <Udma_chOpen+0x54> @ imm = #0x1e
7009fb44: e7ff         	b	0x7009fb46 <Udma_chOpen+0x36> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009fb46: 9801         	ldr	r0, [sp, #0x4]
7009fb48: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009fb4c: f64a 31cd    	movw	r1, #0xabcd
7009fb50: f6ca 31dc    	movt	r1, #0xabdc
7009fb54: 4288         	cmp	r0, r1
7009fb56: d004         	beq	0x7009fb62 <Udma_chOpen+0x52> @ imm = #0x8
7009fb58: e7ff         	b	0x7009fb5a <Udma_chOpen+0x4a> @ imm = #-0x2
7009fb5a: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009fb5e: 9005         	str	r0, [sp, #0x14]
;         }
7009fb60: e7ff         	b	0x7009fb62 <Udma_chOpen+0x52> @ imm = #-0x2
;     }
7009fb62: e7ff         	b	0x7009fb64 <Udma_chOpen+0x54> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fb64: 9805         	ldr	r0, [sp, #0x14]
7009fb66: b938         	cbnz	r0, 0x7009fb78 <Udma_chOpen+0x68> @ imm = #0xe
7009fb68: e7ff         	b	0x7009fb6a <Udma_chOpen+0x5a> @ imm = #-0x2
;         retVal = Udma_chCheckParams(drvHandleInt, chType, chPrms);
7009fb6a: 9801         	ldr	r0, [sp, #0x4]
7009fb6c: 9907         	ldr	r1, [sp, #0x1c]
7009fb6e: 9a06         	ldr	r2, [sp, #0x18]
7009fb70: f006 f816    	bl	0x700a5ba0 <Udma_chCheckParams> @ imm = #0x602c
7009fb74: 9005         	str	r0, [sp, #0x14]
;     }
7009fb76: e7ff         	b	0x7009fb78 <Udma_chOpen+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fb78: 9805         	ldr	r0, [sp, #0x14]
7009fb7a: 2800         	cmp	r0, #0x0
7009fb7c: d145         	bne	0x7009fc0a <Udma_chOpen+0xfa> @ imm = #0x8a
7009fb7e: e7ff         	b	0x7009fb80 <Udma_chOpen+0x70> @ imm = #-0x2
;         chHandleInt = (Udma_ChHandleInt) chHandle;
7009fb80: 9808         	ldr	r0, [sp, #0x20]
7009fb82: 9002         	str	r0, [sp, #0x8]
;         (void) memset(chHandleInt, 0, sizeof(Udma_ChObject));
7009fb84: 9802         	ldr	r0, [sp, #0x8]
7009fb86: f44f 7116    	mov.w	r1, #0x258
7009fb8a: f7f9 ef54    	blx	0x70099a34 <__aeabi_memclr8> @ imm = #-0x6158
;         (void) memcpy(&chHandleInt->chPrms, chPrms, sizeof(Udma_ChPrms));
7009fb8e: 9802         	ldr	r0, [sp, #0x8]
7009fb90: 3004         	adds	r0, #0x4
7009fb92: 9906         	ldr	r1, [sp, #0x18]
7009fb94: 2264         	movs	r2, #0x64
7009fb96: f7fa ef22    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0x51bc
;         chHandleInt->chType            = chType;
7009fb9a: 9807         	ldr	r0, [sp, #0x1c]
7009fb9c: 9902         	ldr	r1, [sp, #0x8]
7009fb9e: 6008         	str	r0, [r1]
;         chHandleInt->drvHandle         = drvHandleInt;
7009fba0: 9801         	ldr	r0, [sp, #0x4]
7009fba2: 9902         	ldr	r1, [sp, #0x8]
7009fba4: 6688         	str	r0, [r1, #0x68]
;         chHandleInt->txChNum           = UDMA_DMA_CH_INVALID;
7009fba6: 9902         	ldr	r1, [sp, #0x8]
7009fba8: 2000         	movs	r0, #0x0
7009fbaa: f6cf 70ff    	movt	r0, #0xffff
7009fbae: 66c8         	str	r0, [r1, #0x6c]
;         chHandleInt->rxChNum           = UDMA_DMA_CH_INVALID;
7009fbb0: 9902         	ldr	r1, [sp, #0x8]
7009fbb2: 6708         	str	r0, [r1, #0x70]
;         chHandleInt->extChNum          = UDMA_DMA_CH_INVALID;
7009fbb4: 9902         	ldr	r1, [sp, #0x8]
7009fbb6: 6748         	str	r0, [r1, #0x74]
;         chHandleInt->pdmaChNum         = UDMA_DMA_CH_INVALID;
7009fbb8: 9902         	ldr	r1, [sp, #0x8]
7009fbba: 6788         	str	r0, [r1, #0x78]
;         chHandleInt->peerThreadId      = UDMA_THREAD_ID_INVALID;
7009fbbc: 9902         	ldr	r1, [sp, #0x8]
7009fbbe: 2004         	movs	r0, #0x4
7009fbc0: f6cf 70ff    	movt	r0, #0xffff
7009fbc4: 67c8         	str	r0, [r1, #0x7c]
;         chHandleInt->fqRing            = (Udma_RingHandleInt) NULL_PTR;
7009fbc6: 9902         	ldr	r1, [sp, #0x8]
7009fbc8: 2000         	movs	r0, #0x0
7009fbca: 9000         	str	r0, [sp]
7009fbcc: f8c1 0080    	str.w	r0, [r1, #0x80]
;         chHandleInt->cqRing            = (Udma_RingHandleInt) NULL_PTR;
7009fbd0: 9902         	ldr	r1, [sp, #0x8]
7009fbd2: f8c1 0084    	str.w	r0, [r1, #0x84]
;         chHandleInt->tdCqRing          = (Udma_RingHandleInt) NULL_PTR;
7009fbd6: 9902         	ldr	r1, [sp, #0x8]
7009fbd8: f8c1 0088    	str.w	r0, [r1, #0x88]
;         UdmaChTxPrms_init(&chHandleInt->txPrms, chType);
7009fbdc: 9802         	ldr	r0, [sp, #0x8]
7009fbde: f500 70f2    	add.w	r0, r0, #0x1e4
7009fbe2: 9907         	ldr	r1, [sp, #0x1c]
7009fbe4: f006 f9ec    	bl	0x700a5fc0 <UdmaChTxPrms_init> @ imm = #0x63d8
;         UdmaChRxPrms_init(&chHandleInt->rxPrms, chType);
7009fbe8: 9802         	ldr	r0, [sp, #0x8]
7009fbea: f500 70fc    	add.w	r0, r0, #0x1f8
7009fbee: 9907         	ldr	r1, [sp, #0x1c]
7009fbf0: f006 f98e    	bl	0x700a5f10 <UdmaChRxPrms_init> @ imm = #0x631c
;         Udma_chInitRegs(chHandleInt);
7009fbf4: 9802         	ldr	r0, [sp, #0x8]
7009fbf6: f00b f8fb    	bl	0x700aadf0 <Udma_chInitRegs> @ imm = #0xb1f6
7009fbfa: 9800         	ldr	r0, [sp]
;         chHandleInt->chOesAllocDone    = FALSE;
7009fbfc: 9902         	ldr	r1, [sp, #0x8]
7009fbfe: f8c1 0248    	str.w	r0, [r1, #0x248]
;         chHandleInt->trigger           = CSL_UDMAP_TR_FLAGS_TRIGGER_NONE;
7009fc02: 9902         	ldr	r1, [sp, #0x8]
7009fc04: f8c1 024c    	str.w	r0, [r1, #0x24c]
;     }
7009fc08: e7ff         	b	0x7009fc0a <Udma_chOpen+0xfa> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fc0a: 9805         	ldr	r0, [sp, #0x14]
7009fc0c: b960         	cbnz	r0, 0x7009fc28 <Udma_chOpen+0x118> @ imm = #0x18
7009fc0e: e7ff         	b	0x7009fc10 <Udma_chOpen+0x100> @ imm = #-0x2
;         retVal = Udma_chAllocResource(chHandleInt);
7009fc10: 9802         	ldr	r0, [sp, #0x8]
7009fc12: f7fb f8fd    	bl	0x7009ae10 <Udma_chAllocResource> @ imm = #-0x4e06
7009fc16: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK == retVal)
7009fc18: 9805         	ldr	r0, [sp, #0x14]
7009fc1a: b918         	cbnz	r0, 0x7009fc24 <Udma_chOpen+0x114> @ imm = #0x6
7009fc1c: e7ff         	b	0x7009fc1e <Udma_chOpen+0x10e> @ imm = #-0x2
7009fc1e: 2001         	movs	r0, #0x1
;             allocDone = (uint32_t) TRUE;
7009fc20: 9003         	str	r0, [sp, #0xc]
;         }
7009fc22: e000         	b	0x7009fc26 <Udma_chOpen+0x116> @ imm = #0x0
7009fc24: e7ff         	b	0x7009fc26 <Udma_chOpen+0x116> @ imm = #-0x2
;     }
7009fc26: e7ff         	b	0x7009fc28 <Udma_chOpen+0x118> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fc28: 9805         	ldr	r0, [sp, #0x14]
7009fc2a: b948         	cbnz	r0, 0x7009fc40 <Udma_chOpen+0x130> @ imm = #0x12
7009fc2c: e7ff         	b	0x7009fc2e <Udma_chOpen+0x11e> @ imm = #-0x2
;         retVal = Udma_chPair(chHandleInt);
7009fc2e: 9802         	ldr	r0, [sp, #0x8]
7009fc30: f008 fda6    	bl	0x700a8780 <Udma_chPair> @ imm = #0x8b4c
7009fc34: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != retVal)
7009fc36: 9805         	ldr	r0, [sp, #0x14]
7009fc38: b108         	cbz	r0, 0x7009fc3e <Udma_chOpen+0x12e> @ imm = #0x2
7009fc3a: e7ff         	b	0x7009fc3c <Udma_chOpen+0x12c> @ imm = #-0x2
;         }
7009fc3c: e7ff         	b	0x7009fc3e <Udma_chOpen+0x12e> @ imm = #-0x2
;     }
7009fc3e: e7ff         	b	0x7009fc40 <Udma_chOpen+0x130> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009fc40: 9805         	ldr	r0, [sp, #0x14]
7009fc42: b940         	cbnz	r0, 0x7009fc56 <Udma_chOpen+0x146> @ imm = #0x10
7009fc44: e7ff         	b	0x7009fc46 <Udma_chOpen+0x136> @ imm = #-0x2
;         chHandleInt->chInitDone = UDMA_INIT_DONE;
7009fc46: 9902         	ldr	r1, [sp, #0x8]
7009fc48: f64a 30cd    	movw	r0, #0xabcd
7009fc4c: f6ca 30dc    	movt	r0, #0xabdc
7009fc50: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
7009fc54: e00d         	b	0x7009fc72 <Udma_chOpen+0x162> @ imm = #0x1a
;         if(((uint32_t) TRUE) == allocDone)
7009fc56: 9803         	ldr	r0, [sp, #0xc]
7009fc58: 2801         	cmp	r0, #0x1
7009fc5a: d109         	bne	0x7009fc70 <Udma_chOpen+0x160> @ imm = #0x12
7009fc5c: e7ff         	b	0x7009fc5e <Udma_chOpen+0x14e> @ imm = #-0x2
;             tempRetVal = Udma_chFreeResource(chHandleInt);
7009fc5e: 9802         	ldr	r0, [sp, #0x8]
7009fc60: f7fd fd36    	bl	0x7009d6d0 <Udma_chFreeResource> @ imm = #-0x2594
7009fc64: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK != tempRetVal)
7009fc66: 9804         	ldr	r0, [sp, #0x10]
7009fc68: b108         	cbz	r0, 0x7009fc6e <Udma_chOpen+0x15e> @ imm = #0x2
7009fc6a: e7ff         	b	0x7009fc6c <Udma_chOpen+0x15c> @ imm = #-0x2
;             }
7009fc6c: e7ff         	b	0x7009fc6e <Udma_chOpen+0x15e> @ imm = #-0x2
;         }
7009fc6e: e7ff         	b	0x7009fc70 <Udma_chOpen+0x160> @ imm = #-0x2
7009fc70: e7ff         	b	0x7009fc72 <Udma_chOpen+0x162> @ imm = #-0x2
;     return (retVal);
7009fc72: 9805         	ldr	r0, [sp, #0x14]
7009fc74: b00a         	add	sp, #0x28
7009fc76: bd80         	pop	{r7, pc}
		...

7009fc80 <xTaskIncrementTick>:
; BaseType_t xTaskIncrementTick(void) {
7009fc80: b580         	push	{r7, lr}
7009fc82: b086         	sub	sp, #0x18
7009fc84: 2000         	movs	r0, #0x0
;   BaseType_t xSwitchRequired = pdFALSE;
7009fc86: 9003         	str	r0, [sp, #0xc]
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
7009fc88: f240 10f0    	movw	r0, #0x1f0
7009fc8c: f2c7 000b    	movt	r0, #0x700b
7009fc90: 6800         	ldr	r0, [r0]
7009fc92: 2800         	cmp	r0, #0x0
7009fc94: f040 809d    	bne.w	0x7009fdd2 <xTaskIncrementTick+0x152> @ imm = #0x13a
7009fc98: e7ff         	b	0x7009fc9a <xTaskIncrementTick+0x1a> @ imm = #-0x2
;     const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
7009fc9a: f240 2110    	movw	r1, #0x210
7009fc9e: f2c7 010b    	movt	r1, #0x700b
7009fca2: 6808         	ldr	r0, [r1]
7009fca4: 3001         	adds	r0, #0x1
7009fca6: 9002         	str	r0, [sp, #0x8]
;     xTickCount = xConstTickCount;
7009fca8: 9802         	ldr	r0, [sp, #0x8]
7009fcaa: 6008         	str	r0, [r1]
;     if (xConstTickCount ==
7009fcac: 9802         	ldr	r0, [sp, #0x8]
7009fcae: b9c0         	cbnz	r0, 0x7009fce2 <xTaskIncrementTick+0x62> @ imm = #0x30
7009fcb0: e7ff         	b	0x7009fcb2 <xTaskIncrementTick+0x32> @ imm = #-0x2
;       taskSWITCH_DELAYED_LISTS();
7009fcb2: f644 72b8    	movw	r2, #0x4fb8
7009fcb6: f2c7 0208    	movt	r2, #0x7008
7009fcba: 6810         	ldr	r0, [r2]
7009fcbc: 9001         	str	r0, [sp, #0x4]
7009fcbe: f644 71bc    	movw	r1, #0x4fbc
7009fcc2: f2c7 0108    	movt	r1, #0x7008
7009fcc6: 6808         	ldr	r0, [r1]
7009fcc8: 6010         	str	r0, [r2]
7009fcca: 9801         	ldr	r0, [sp, #0x4]
7009fccc: 6008         	str	r0, [r1]
7009fcce: f240 2104    	movw	r1, #0x204
7009fcd2: f2c7 010b    	movt	r1, #0x700b
7009fcd6: 6808         	ldr	r0, [r1]
7009fcd8: 3001         	adds	r0, #0x1
7009fcda: 6008         	str	r0, [r1]
7009fcdc: f00c f8d0    	bl	0x700abe80 <prvResetNextTaskUnblockTime> @ imm = #0xc1a0
;     } else {
7009fce0: e000         	b	0x7009fce4 <xTaskIncrementTick+0x64> @ imm = #0x0
7009fce2: e7ff         	b	0x7009fce4 <xTaskIncrementTick+0x64> @ imm = #-0x2
;     if (xConstTickCount >= xNextTaskUnblockTime) {
7009fce4: 9802         	ldr	r0, [sp, #0x8]
7009fce6: f240 2100    	movw	r1, #0x200
7009fcea: f2c7 010b    	movt	r1, #0x700b
7009fcee: 6809         	ldr	r1, [r1]
7009fcf0: 4288         	cmp	r0, r1
7009fcf2: d362         	blo	0x7009fdba <xTaskIncrementTick+0x13a> @ imm = #0xc4
7009fcf4: e7ff         	b	0x7009fcf6 <xTaskIncrementTick+0x76> @ imm = #-0x2
;       for (;;) {
7009fcf6: e7ff         	b	0x7009fcf8 <xTaskIncrementTick+0x78> @ imm = #-0x2
;         if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
7009fcf8: f644 70b8    	movw	r0, #0x4fb8
7009fcfc: f2c7 0008    	movt	r0, #0x7008
7009fd00: 6800         	ldr	r0, [r0]
7009fd02: 6800         	ldr	r0, [r0]
7009fd04: b940         	cbnz	r0, 0x7009fd18 <xTaskIncrementTick+0x98> @ imm = #0x10
7009fd06: e7ff         	b	0x7009fd08 <xTaskIncrementTick+0x88> @ imm = #-0x2
;           xNextTaskUnblockTime =
7009fd08: f240 2100    	movw	r1, #0x200
7009fd0c: f2c7 010b    	movt	r1, #0x700b
7009fd10: f04f 30ff    	mov.w	r0, #0xffffffff
7009fd14: 6008         	str	r0, [r1]
;           break;
7009fd16: e04f         	b	0x7009fdb8 <xTaskIncrementTick+0x138> @ imm = #0x9e
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
7009fd18: f644 70b8    	movw	r0, #0x4fb8
7009fd1c: f2c7 0008    	movt	r0, #0x7008
7009fd20: 6800         	ldr	r0, [r0]
7009fd22: 68c0         	ldr	r0, [r0, #0xc]
7009fd24: 68c0         	ldr	r0, [r0, #0xc]
7009fd26: 9005         	str	r0, [sp, #0x14]
;           xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
7009fd28: 9805         	ldr	r0, [sp, #0x14]
7009fd2a: 6840         	ldr	r0, [r0, #0x4]
7009fd2c: 9004         	str	r0, [sp, #0x10]
;           if (xConstTickCount < xItemValue) {
7009fd2e: 9802         	ldr	r0, [sp, #0x8]
7009fd30: 9904         	ldr	r1, [sp, #0x10]
7009fd32: 4288         	cmp	r0, r1
7009fd34: d207         	bhs	0x7009fd46 <xTaskIncrementTick+0xc6> @ imm = #0xe
7009fd36: e7ff         	b	0x7009fd38 <xTaskIncrementTick+0xb8> @ imm = #-0x2
;             xNextTaskUnblockTime = xItemValue;
7009fd38: 9804         	ldr	r0, [sp, #0x10]
7009fd3a: f240 2100    	movw	r1, #0x200
7009fd3e: f2c7 010b    	movt	r1, #0x700b
7009fd42: 6008         	str	r0, [r1]
;             break; /*lint !e9011 Code structure here is deedmed easier to
7009fd44: e038         	b	0x7009fdb8 <xTaskIncrementTick+0x138> @ imm = #0x70
7009fd46: e7ff         	b	0x7009fd48 <xTaskIncrementTick+0xc8> @ imm = #-0x2
;           (void)uxListRemove(&(pxTCB->xStateListItem));
7009fd48: 9805         	ldr	r0, [sp, #0x14]
7009fd4a: 3004         	adds	r0, #0x4
7009fd4c: f00b fb88    	bl	0x700ab460 <uxListRemove> @ imm = #0xb710
;           if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
7009fd50: 9805         	ldr	r0, [sp, #0x14]
7009fd52: 6a80         	ldr	r0, [r0, #0x28]
7009fd54: b128         	cbz	r0, 0x7009fd62 <xTaskIncrementTick+0xe2> @ imm = #0xa
7009fd56: e7ff         	b	0x7009fd58 <xTaskIncrementTick+0xd8> @ imm = #-0x2
;             (void)uxListRemove(&(pxTCB->xEventListItem));
7009fd58: 9805         	ldr	r0, [sp, #0x14]
7009fd5a: 3018         	adds	r0, #0x18
7009fd5c: f00b fb80    	bl	0x700ab460 <uxListRemove> @ imm = #0xb700
;           } else {
7009fd60: e000         	b	0x7009fd64 <xTaskIncrementTick+0xe4> @ imm = #0x0
7009fd62: e7ff         	b	0x7009fd64 <xTaskIncrementTick+0xe4> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
7009fd64: 9805         	ldr	r0, [sp, #0x14]
7009fd66: 6ac1         	ldr	r1, [r0, #0x2c]
7009fd68: 2001         	movs	r0, #0x1
7009fd6a: fa00 f201    	lsl.w	r2, r0, r1
7009fd6e: f240 11f8    	movw	r1, #0x1f8
7009fd72: f2c7 010b    	movt	r1, #0x700b
7009fd76: 6808         	ldr	r0, [r1]
7009fd78: 4310         	orrs	r0, r2
7009fd7a: 6008         	str	r0, [r1]
7009fd7c: 9905         	ldr	r1, [sp, #0x14]
7009fd7e: 6ac8         	ldr	r0, [r1, #0x2c]
7009fd80: eb00 0280    	add.w	r2, r0, r0, lsl #2
7009fd84: f244 40f8    	movw	r0, #0x44f8
7009fd88: f2c7 0008    	movt	r0, #0x7008
7009fd8c: eb00 0082    	add.w	r0, r0, r2, lsl #2
7009fd90: 3104         	adds	r1, #0x4
7009fd92: f00c f8d5    	bl	0x700abf40 <vListInsertEnd> @ imm = #0xc1aa
;             if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
7009fd96: 9805         	ldr	r0, [sp, #0x14]
7009fd98: 6ac0         	ldr	r0, [r0, #0x2c]
7009fd9a: f240 11cc    	movw	r1, #0x1cc
7009fd9e: f2c7 010b    	movt	r1, #0x700b
7009fda2: 6809         	ldr	r1, [r1]
7009fda4: 6ac9         	ldr	r1, [r1, #0x2c]
7009fda6: 4288         	cmp	r0, r1
7009fda8: d303         	blo	0x7009fdb2 <xTaskIncrementTick+0x132> @ imm = #0x6
7009fdaa: e7ff         	b	0x7009fdac <xTaskIncrementTick+0x12c> @ imm = #-0x2
7009fdac: 2001         	movs	r0, #0x1
;               xSwitchRequired = pdTRUE;
7009fdae: 9003         	str	r0, [sp, #0xc]
;             } else {
7009fdb0: e000         	b	0x7009fdb4 <xTaskIncrementTick+0x134> @ imm = #0x0
7009fdb2: e7ff         	b	0x7009fdb4 <xTaskIncrementTick+0x134> @ imm = #-0x2
7009fdb4: e7ff         	b	0x7009fdb6 <xTaskIncrementTick+0x136> @ imm = #-0x2
;       for (;;) {
7009fdb6: e79f         	b	0x7009fcf8 <xTaskIncrementTick+0x78> @ imm = #-0xc2
;     }
7009fdb8: e7ff         	b	0x7009fdba <xTaskIncrementTick+0x13a> @ imm = #-0x2
;       if (xYieldPending != pdFALSE) {
7009fdba: f240 201c    	movw	r0, #0x21c
7009fdbe: f2c7 000b    	movt	r0, #0x700b
7009fdc2: 6800         	ldr	r0, [r0]
7009fdc4: b118         	cbz	r0, 0x7009fdce <xTaskIncrementTick+0x14e> @ imm = #0x6
7009fdc6: e7ff         	b	0x7009fdc8 <xTaskIncrementTick+0x148> @ imm = #-0x2
7009fdc8: 2001         	movs	r0, #0x1
;         xSwitchRequired = pdTRUE;
7009fdca: 9003         	str	r0, [sp, #0xc]
;       } else {
7009fdcc: e000         	b	0x7009fdd0 <xTaskIncrementTick+0x150> @ imm = #0x0
7009fdce: e7ff         	b	0x7009fdd0 <xTaskIncrementTick+0x150> @ imm = #-0x2
;   } else {
7009fdd0: e007         	b	0x7009fde2 <xTaskIncrementTick+0x162> @ imm = #0xe
;     ++xPendedTicks;
7009fdd2: f240 2108    	movw	r1, #0x208
7009fdd6: f2c7 010b    	movt	r1, #0x700b
7009fdda: 6808         	ldr	r0, [r1]
7009fddc: 3001         	adds	r0, #0x1
7009fdde: 6008         	str	r0, [r1]
7009fde0: e7ff         	b	0x7009fde2 <xTaskIncrementTick+0x162> @ imm = #-0x2
;   return xSwitchRequired;
7009fde2: 9803         	ldr	r0, [sp, #0xc]
7009fde4: b006         	add	sp, #0x18
7009fde6: bd80         	pop	{r7, pc}
		...

7009fdf0 <Udma_rmAllocMappedRxCh>:
; {
7009fdf0: b580         	push	{r7, lr}
7009fdf2: b08a         	sub	sp, #0x28
7009fdf4: 9009         	str	r0, [sp, #0x24]
7009fdf6: 9108         	str	r1, [sp, #0x20]
7009fdf8: 9207         	str	r2, [sp, #0x1c]
7009fdfa: 2000         	movs	r0, #0x0
7009fdfc: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
7009fe00: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
7009fe02: 9808         	ldr	r0, [sp, #0x20]
7009fe04: f500 70ea    	add.w	r0, r0, #0x1d4
7009fe08: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
7009fe0a: 9808         	ldr	r0, [sp, #0x20]
7009fe0c: f500 609f    	add.w	r0, r0, #0x4f8
7009fe10: f04f 31ff    	mov.w	r1, #0xffffffff
7009fe14: f008 fc6c    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x88d8
;     if(UDMA_DMA_CH_ANY == preferredChNum)
7009fe18: 9809         	ldr	r0, [sp, #0x24]
7009fe1a: 2101         	movs	r1, #0x1
7009fe1c: f6cf 71ff    	movt	r1, #0xffff
7009fe20: 4288         	cmp	r0, r1
7009fe22: d142         	bne	0x7009feaa <Udma_rmAllocMappedRxCh+0xba> @ imm = #0x84
7009fe24: e7ff         	b	0x7009fe26 <Udma_rmAllocMappedRxCh+0x36> @ imm = #-0x2
7009fe26: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
7009fe28: 9005         	str	r0, [sp, #0x14]
7009fe2a: e7ff         	b	0x7009fe2c <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x2
7009fe2c: 9805         	ldr	r0, [sp, #0x14]
7009fe2e: 9901         	ldr	r1, [sp, #0x4]
7009fe30: 9a07         	ldr	r2, [sp, #0x1c]
7009fe32: eb01 0182    	add.w	r1, r1, r2, lsl #2
7009fe36: 6f89         	ldr	r1, [r1, #0x78]
7009fe38: 4288         	cmp	r0, r1
7009fe3a: d235         	bhs	0x7009fea8 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x6a
7009fe3c: e7ff         	b	0x7009fe3e <Udma_rmAllocMappedRxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
7009fe3e: 9805         	ldr	r0, [sp, #0x14]
7009fe40: 0940         	lsrs	r0, r0, #0x5
7009fe42: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
7009fe44: 9805         	ldr	r0, [sp, #0x14]
7009fe46: 9904         	ldr	r1, [sp, #0x10]
7009fe48: eba0 1041    	sub.w	r0, r0, r1, lsl #5
7009fe4c: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
7009fe4e: 9903         	ldr	r1, [sp, #0xc]
7009fe50: 2001         	movs	r0, #0x1
7009fe52: 4088         	lsls	r0, r1
7009fe54: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
7009fe56: 9808         	ldr	r0, [sp, #0x20]
7009fe58: 9907         	ldr	r1, [sp, #0x1c]
7009fe5a: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009fe5e: 9904         	ldr	r1, [sp, #0x10]
7009fe60: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009fe64: f8d0 0334    	ldr.w	r0, [r0, #0x334]
7009fe68: 9902         	ldr	r1, [sp, #0x8]
7009fe6a: 4008         	ands	r0, r1
7009fe6c: 4288         	cmp	r0, r1
7009fe6e: d116         	bne	0x7009fe9e <Udma_rmAllocMappedRxCh+0xae> @ imm = #0x2c
7009fe70: e7ff         	b	0x7009fe72 <Udma_rmAllocMappedRxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
7009fe72: 9a02         	ldr	r2, [sp, #0x8]
7009fe74: 9808         	ldr	r0, [sp, #0x20]
7009fe76: 9907         	ldr	r1, [sp, #0x1c]
7009fe78: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009fe7c: 9904         	ldr	r1, [sp, #0x10]
7009fe7e: eb00 0181    	add.w	r1, r0, r1, lsl #2
7009fe82: f8d1 0334    	ldr.w	r0, [r1, #0x334]
7009fe86: 4390         	bics	r0, r2
7009fe88: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = i + rmInitPrms->startMappedRxCh[mappedChGrp];  /* Add start offset */
7009fe8c: 9805         	ldr	r0, [sp, #0x14]
7009fe8e: 9901         	ldr	r1, [sp, #0x4]
7009fe90: 9a07         	ldr	r2, [sp, #0x1c]
7009fe92: eb01 0182    	add.w	r1, r1, r2, lsl #2
7009fe96: 6e89         	ldr	r1, [r1, #0x68]
7009fe98: 4408         	add	r0, r1
7009fe9a: 9006         	str	r0, [sp, #0x18]
;                 break;
7009fe9c: e004         	b	0x7009fea8 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x8
;         }
7009fe9e: e7ff         	b	0x7009fea0 <Udma_rmAllocMappedRxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
7009fea0: 9805         	ldr	r0, [sp, #0x14]
7009fea2: 3001         	adds	r0, #0x1
7009fea4: 9005         	str	r0, [sp, #0x14]
7009fea6: e7c1         	b	0x7009fe2c <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x7e
;     }
7009fea8: e047         	b	0x7009ff3a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
7009feaa: 9809         	ldr	r0, [sp, #0x24]
7009feac: 9901         	ldr	r1, [sp, #0x4]
7009feae: 9a07         	ldr	r2, [sp, #0x1c]
7009feb0: eb01 0182    	add.w	r1, r1, r2, lsl #2
7009feb4: 6e89         	ldr	r1, [r1, #0x68]
7009feb6: 4288         	cmp	r0, r1
7009feb8: d33e         	blo	0x7009ff38 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x7c
7009feba: e7ff         	b	0x7009febc <Udma_rmAllocMappedRxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedRxCh[mappedChGrp] + rmInitPrms->numMappedRxCh[mappedChGrp])))
7009febc: 9809         	ldr	r0, [sp, #0x24]
7009febe: 9901         	ldr	r1, [sp, #0x4]
7009fec0: 9a07         	ldr	r2, [sp, #0x1c]
7009fec2: eb01 0282    	add.w	r2, r1, r2, lsl #2
7009fec6: 6e91         	ldr	r1, [r2, #0x68]
7009fec8: 6f92         	ldr	r2, [r2, #0x78]
7009feca: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
7009fecc: 4288         	cmp	r0, r1
7009fece: d233         	bhs	0x7009ff38 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x66
7009fed0: e7ff         	b	0x7009fed2 <Udma_rmAllocMappedRxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedRxCh[mappedChGrp];
7009fed2: 9809         	ldr	r0, [sp, #0x24]
7009fed4: 9901         	ldr	r1, [sp, #0x4]
7009fed6: 9a07         	ldr	r2, [sp, #0x1c]
7009fed8: eb01 0182    	add.w	r1, r1, r2, lsl #2
7009fedc: 6e89         	ldr	r1, [r1, #0x68]
7009fede: 1a40         	subs	r0, r0, r1
7009fee0: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
7009fee2: 9805         	ldr	r0, [sp, #0x14]
7009fee4: 0940         	lsrs	r0, r0, #0x5
7009fee6: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
7009fee8: 9805         	ldr	r0, [sp, #0x14]
7009feea: 9904         	ldr	r1, [sp, #0x10]
7009feec: eba0 1041    	sub.w	r0, r0, r1, lsl #5
7009fef0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
7009fef2: 9903         	ldr	r1, [sp, #0xc]
7009fef4: 2001         	movs	r0, #0x1
7009fef6: 4088         	lsls	r0, r1
7009fef8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
7009fefa: 9808         	ldr	r0, [sp, #0x20]
7009fefc: 9907         	ldr	r1, [sp, #0x1c]
7009fefe: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009ff02: 9904         	ldr	r1, [sp, #0x10]
7009ff04: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009ff08: f8d0 0334    	ldr.w	r0, [r0, #0x334]
7009ff0c: 9902         	ldr	r1, [sp, #0x8]
7009ff0e: 4008         	ands	r0, r1
7009ff10: 4288         	cmp	r0, r1
7009ff12: d110         	bne	0x7009ff36 <Udma_rmAllocMappedRxCh+0x146> @ imm = #0x20
7009ff14: e7ff         	b	0x7009ff16 <Udma_rmAllocMappedRxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
7009ff16: 9a02         	ldr	r2, [sp, #0x8]
7009ff18: 9808         	ldr	r0, [sp, #0x20]
7009ff1a: 9907         	ldr	r1, [sp, #0x1c]
7009ff1c: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009ff20: 9904         	ldr	r1, [sp, #0x10]
7009ff22: eb00 0181    	add.w	r1, r0, r1, lsl #2
7009ff26: f8d1 0334    	ldr.w	r0, [r1, #0x334]
7009ff2a: 4390         	bics	r0, r2
7009ff2c: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = preferredChNum;
7009ff30: 9809         	ldr	r0, [sp, #0x24]
7009ff32: 9006         	str	r0, [sp, #0x18]
;             }
7009ff34: e7ff         	b	0x7009ff36 <Udma_rmAllocMappedRxCh+0x146> @ imm = #-0x2
;         }
7009ff36: e7ff         	b	0x7009ff38 <Udma_rmAllocMappedRxCh+0x148> @ imm = #-0x2
7009ff38: e7ff         	b	0x7009ff3a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
7009ff3a: 9808         	ldr	r0, [sp, #0x20]
7009ff3c: f500 609f    	add.w	r0, r0, #0x4f8
7009ff40: f009 ff26    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x9e4c
;     return (chNum);
7009ff44: 9806         	ldr	r0, [sp, #0x18]
7009ff46: b00a         	add	sp, #0x28
7009ff48: bd80         	pop	{r7, pc}
7009ff4a: 0000         	movs	r0, r0
7009ff4c: 0000         	movs	r0, r0
7009ff4e: 0000         	movs	r0, r0

7009ff50 <Udma_rmAllocMappedTxCh>:
; {
7009ff50: b580         	push	{r7, lr}
7009ff52: b08a         	sub	sp, #0x28
7009ff54: 9009         	str	r0, [sp, #0x24]
7009ff56: 9108         	str	r1, [sp, #0x20]
7009ff58: 9207         	str	r2, [sp, #0x1c]
7009ff5a: 2000         	movs	r0, #0x0
7009ff5c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
7009ff60: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
7009ff62: 9808         	ldr	r0, [sp, #0x20]
7009ff64: f500 70ea    	add.w	r0, r0, #0x1d4
7009ff68: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
7009ff6a: 9808         	ldr	r0, [sp, #0x20]
7009ff6c: f500 609f    	add.w	r0, r0, #0x4f8
7009ff70: f04f 31ff    	mov.w	r1, #0xffffffff
7009ff74: f008 fbbc    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x8778
;     if(UDMA_DMA_CH_ANY == preferredChNum)
7009ff78: 9809         	ldr	r0, [sp, #0x24]
7009ff7a: 2101         	movs	r1, #0x1
7009ff7c: f6cf 71ff    	movt	r1, #0xffff
7009ff80: 4288         	cmp	r0, r1
7009ff82: d142         	bne	0x700a000a <Udma_rmAllocMappedTxCh+0xba> @ imm = #0x84
7009ff84: e7ff         	b	0x7009ff86 <Udma_rmAllocMappedTxCh+0x36> @ imm = #-0x2
7009ff86: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
7009ff88: 9005         	str	r0, [sp, #0x14]
7009ff8a: e7ff         	b	0x7009ff8c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x2
7009ff8c: 9805         	ldr	r0, [sp, #0x14]
7009ff8e: 9901         	ldr	r1, [sp, #0x4]
7009ff90: 9a07         	ldr	r2, [sp, #0x1c]
7009ff92: eb01 0182    	add.w	r1, r1, r2, lsl #2
7009ff96: 6d89         	ldr	r1, [r1, #0x58]
7009ff98: 4288         	cmp	r0, r1
7009ff9a: d235         	bhs	0x700a0008 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x6a
7009ff9c: e7ff         	b	0x7009ff9e <Udma_rmAllocMappedTxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
7009ff9e: 9805         	ldr	r0, [sp, #0x14]
7009ffa0: 0940         	lsrs	r0, r0, #0x5
7009ffa2: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
7009ffa4: 9805         	ldr	r0, [sp, #0x14]
7009ffa6: 9904         	ldr	r1, [sp, #0x10]
7009ffa8: eba0 1041    	sub.w	r0, r0, r1, lsl #5
7009ffac: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
7009ffae: 9903         	ldr	r1, [sp, #0xc]
7009ffb0: 2001         	movs	r0, #0x1
7009ffb2: 4088         	lsls	r0, r1
7009ffb4: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
7009ffb6: 9808         	ldr	r0, [sp, #0x20]
7009ffb8: 9907         	ldr	r1, [sp, #0x1c]
7009ffba: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009ffbe: 9904         	ldr	r1, [sp, #0x10]
7009ffc0: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009ffc4: f8d0 0324    	ldr.w	r0, [r0, #0x324]
7009ffc8: 9902         	ldr	r1, [sp, #0x8]
7009ffca: 4008         	ands	r0, r1
7009ffcc: 4288         	cmp	r0, r1
7009ffce: d116         	bne	0x7009fffe <Udma_rmAllocMappedTxCh+0xae> @ imm = #0x2c
7009ffd0: e7ff         	b	0x7009ffd2 <Udma_rmAllocMappedTxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
7009ffd2: 9a02         	ldr	r2, [sp, #0x8]
7009ffd4: 9808         	ldr	r0, [sp, #0x20]
7009ffd6: 9907         	ldr	r1, [sp, #0x1c]
7009ffd8: eb00 0081    	add.w	r0, r0, r1, lsl #2
7009ffdc: 9904         	ldr	r1, [sp, #0x10]
7009ffde: eb00 0181    	add.w	r1, r0, r1, lsl #2
7009ffe2: f8d1 0324    	ldr.w	r0, [r1, #0x324]
7009ffe6: 4390         	bics	r0, r2
7009ffe8: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = i + rmInitPrms->startMappedTxCh[mappedChGrp];  /* Add start offset */
7009ffec: 9805         	ldr	r0, [sp, #0x14]
7009ffee: 9901         	ldr	r1, [sp, #0x4]
7009fff0: 9a07         	ldr	r2, [sp, #0x1c]
7009fff2: eb01 0182    	add.w	r1, r1, r2, lsl #2
7009fff6: 6c89         	ldr	r1, [r1, #0x48]
7009fff8: 4408         	add	r0, r1
7009fffa: 9006         	str	r0, [sp, #0x18]
;                 break;
7009fffc: e004         	b	0x700a0008 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x8
;         }
7009fffe: e7ff         	b	0x700a0000 <Udma_rmAllocMappedTxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a0000: 9805         	ldr	r0, [sp, #0x14]
700a0002: 3001         	adds	r0, #0x1
700a0004: 9005         	str	r0, [sp, #0x14]
700a0006: e7c1         	b	0x7009ff8c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x7e
;     }
700a0008: e047         	b	0x700a009a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a000a: 9809         	ldr	r0, [sp, #0x24]
700a000c: 9901         	ldr	r1, [sp, #0x4]
700a000e: 9a07         	ldr	r2, [sp, #0x1c]
700a0010: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0014: 6c89         	ldr	r1, [r1, #0x48]
700a0016: 4288         	cmp	r0, r1
700a0018: d33e         	blo	0x700a0098 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x7c
700a001a: e7ff         	b	0x700a001c <Udma_rmAllocMappedTxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedTxCh[mappedChGrp] + rmInitPrms->numMappedTxCh[mappedChGrp])))
700a001c: 9809         	ldr	r0, [sp, #0x24]
700a001e: 9901         	ldr	r1, [sp, #0x4]
700a0020: 9a07         	ldr	r2, [sp, #0x1c]
700a0022: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a0026: 6c91         	ldr	r1, [r2, #0x48]
700a0028: 6d92         	ldr	r2, [r2, #0x58]
700a002a: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a002c: 4288         	cmp	r0, r1
700a002e: d233         	bhs	0x700a0098 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x66
700a0030: e7ff         	b	0x700a0032 <Udma_rmAllocMappedTxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700a0032: 9809         	ldr	r0, [sp, #0x24]
700a0034: 9901         	ldr	r1, [sp, #0x4]
700a0036: 9a07         	ldr	r2, [sp, #0x1c]
700a0038: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a003c: 6c89         	ldr	r1, [r1, #0x48]
700a003e: 1a40         	subs	r0, r0, r1
700a0040: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a0042: 9805         	ldr	r0, [sp, #0x14]
700a0044: 0940         	lsrs	r0, r0, #0x5
700a0046: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a0048: 9805         	ldr	r0, [sp, #0x14]
700a004a: 9904         	ldr	r1, [sp, #0x10]
700a004c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a0050: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a0052: 9903         	ldr	r1, [sp, #0xc]
700a0054: 2001         	movs	r0, #0x1
700a0056: 4088         	lsls	r0, r1
700a0058: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a005a: 9808         	ldr	r0, [sp, #0x20]
700a005c: 9907         	ldr	r1, [sp, #0x1c]
700a005e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0062: 9904         	ldr	r1, [sp, #0x10]
700a0064: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0068: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a006c: 9902         	ldr	r1, [sp, #0x8]
700a006e: 4008         	ands	r0, r1
700a0070: 4288         	cmp	r0, r1
700a0072: d110         	bne	0x700a0096 <Udma_rmAllocMappedTxCh+0x146> @ imm = #0x20
700a0074: e7ff         	b	0x700a0076 <Udma_rmAllocMappedTxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a0076: 9a02         	ldr	r2, [sp, #0x8]
700a0078: 9808         	ldr	r0, [sp, #0x20]
700a007a: 9907         	ldr	r1, [sp, #0x1c]
700a007c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0080: 9904         	ldr	r1, [sp, #0x10]
700a0082: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a0086: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a008a: 4390         	bics	r0, r2
700a008c: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = preferredChNum;
700a0090: 9809         	ldr	r0, [sp, #0x24]
700a0092: 9006         	str	r0, [sp, #0x18]
;             }
700a0094: e7ff         	b	0x700a0096 <Udma_rmAllocMappedTxCh+0x146> @ imm = #-0x2
;         }
700a0096: e7ff         	b	0x700a0098 <Udma_rmAllocMappedTxCh+0x148> @ imm = #-0x2
700a0098: e7ff         	b	0x700a009a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a009a: 9808         	ldr	r0, [sp, #0x20]
700a009c: f500 609f    	add.w	r0, r0, #0x4f8
700a00a0: f009 fe76    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x9cec
;     return (chNum);
700a00a4: 9806         	ldr	r0, [sp, #0x18]
700a00a6: b00a         	add	sp, #0x28
700a00a8: bd80         	pop	{r7, pc}
700a00aa: 0000         	movs	r0, r0
700a00ac: 0000         	movs	r0, r0
700a00ae: 0000         	movs	r0, r0

700a00b0 <CSL_bcdmaChanOpGetChanStats>:
; {
700a00b0: b580         	push	{r7, lr}
700a00b2: b088         	sub	sp, #0x20
700a00b4: 9007         	str	r0, [sp, #0x1c]
700a00b6: 9106         	str	r1, [sp, #0x18]
700a00b8: 9205         	str	r2, [sp, #0x14]
700a00ba: 9304         	str	r3, [sp, #0x10]
700a00bc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a00be: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a00c0: 9804         	ldr	r0, [sp, #0x10]
700a00c2: b920         	cbnz	r0, 0x700a00ce <CSL_bcdmaChanOpGetChanStats+0x1e> @ imm = #0x8
700a00c4: e7ff         	b	0x700a00c6 <CSL_bcdmaChanOpGetChanStats+0x16> @ imm = #-0x2
700a00c6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a00ca: 9003         	str	r0, [sp, #0xc]
;     }
700a00cc: e099         	b	0x700a0202 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #0x132
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a00ce: 9804         	ldr	r0, [sp, #0x10]
700a00d0: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a00d2: 9806         	ldr	r0, [sp, #0x18]
700a00d4: 9001         	str	r0, [sp, #0x4]
700a00d6: b140         	cbz	r0, 0x700a00ea <CSL_bcdmaChanOpGetChanStats+0x3a> @ imm = #0x10
700a00d8: e7ff         	b	0x700a00da <CSL_bcdmaChanOpGetChanStats+0x2a> @ imm = #-0x2
700a00da: 9801         	ldr	r0, [sp, #0x4]
700a00dc: 2801         	cmp	r0, #0x1
700a00de: d031         	beq	0x700a0144 <CSL_bcdmaChanOpGetChanStats+0x94> @ imm = #0x62
700a00e0: e7ff         	b	0x700a00e2 <CSL_bcdmaChanOpGetChanStats+0x32> @ imm = #-0x2
700a00e2: 9801         	ldr	r0, [sp, #0x4]
700a00e4: 2802         	cmp	r0, #0x2
700a00e6: d05a         	beq	0x700a019e <CSL_bcdmaChanOpGetChanStats+0xee> @ imm = #0xb4
700a00e8: e086         	b	0x700a01f8 <CSL_bcdmaChanOpGetChanStats+0x148> @ imm = #0x10c
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT );
700a00ea: 9807         	ldr	r0, [sp, #0x1c]
700a00ec: 6880         	ldr	r0, [r0, #0x8]
700a00ee: 9905         	ldr	r1, [sp, #0x14]
700a00f0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a00f4: f500 6080    	add.w	r0, r0, #0x400
700a00f8: f00d fae2    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xd5c4
700a00fc: 9902         	ldr	r1, [sp, #0x8]
700a00fe: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT );
700a0100: 9807         	ldr	r0, [sp, #0x1c]
700a0102: 6880         	ldr	r0, [r0, #0x8]
700a0104: 9905         	ldr	r1, [sp, #0x14]
700a0106: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a010a: f500 6081    	add.w	r0, r0, #0x408
700a010e: f00d fad7    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xd5ae
700a0112: 9902         	ldr	r1, [sp, #0x8]
700a0114: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT );
700a0116: 9807         	ldr	r0, [sp, #0x1c]
700a0118: 6880         	ldr	r0, [r0, #0x8]
700a011a: 9905         	ldr	r1, [sp, #0x14]
700a011c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a0120: f500 6082    	add.w	r0, r0, #0x410
700a0124: f00d facc    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xd598
700a0128: 9902         	ldr	r1, [sp, #0x8]
700a012a: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a012c: 9902         	ldr	r1, [sp, #0x8]
700a012e: 2000         	movs	r0, #0x0
700a0130: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a0132: 9902         	ldr	r1, [sp, #0x8]
700a0134: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a0136: 9902         	ldr	r1, [sp, #0x8]
700a0138: 6848         	ldr	r0, [r1, #0x4]
700a013a: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a013c: 9902         	ldr	r1, [sp, #0x8]
700a013e: 6888         	ldr	r0, [r1, #0x8]
700a0140: 6188         	str	r0, [r1, #0x18]
;                 break;
700a0142: e05d         	b	0x700a0200 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0xba
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT );
700a0144: 9807         	ldr	r0, [sp, #0x1c]
700a0146: 6900         	ldr	r0, [r0, #0x10]
700a0148: 9905         	ldr	r1, [sp, #0x14]
700a014a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a014e: f500 6080    	add.w	r0, r0, #0x400
700a0152: f00d fab5    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xd56a
700a0156: 9902         	ldr	r1, [sp, #0x8]
700a0158: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT );
700a015a: 9807         	ldr	r0, [sp, #0x1c]
700a015c: 6900         	ldr	r0, [r0, #0x10]
700a015e: 9905         	ldr	r1, [sp, #0x14]
700a0160: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a0164: f500 6081    	add.w	r0, r0, #0x408
700a0168: f00d faaa    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xd554
700a016c: 9902         	ldr	r1, [sp, #0x8]
700a016e: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT );
700a0170: 9807         	ldr	r0, [sp, #0x1c]
700a0172: 6900         	ldr	r0, [r0, #0x10]
700a0174: 9905         	ldr	r1, [sp, #0x14]
700a0176: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a017a: f500 6082    	add.w	r0, r0, #0x410
700a017e: f00d fa9f    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xd53e
700a0182: 9902         	ldr	r1, [sp, #0x8]
700a0184: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a0186: 9902         	ldr	r1, [sp, #0x8]
700a0188: 2000         	movs	r0, #0x0
700a018a: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a018c: 9902         	ldr	r1, [sp, #0x8]
700a018e: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a0190: 9902         	ldr	r1, [sp, #0x8]
700a0192: 6848         	ldr	r0, [r1, #0x4]
700a0194: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a0196: 9902         	ldr	r1, [sp, #0x8]
700a0198: 6888         	ldr	r0, [r1, #0x8]
700a019a: 6188         	str	r0, [r1, #0x18]
;                 break;
700a019c: e030         	b	0x700a0200 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x60
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT );
700a019e: 9807         	ldr	r0, [sp, #0x1c]
700a01a0: 6980         	ldr	r0, [r0, #0x18]
700a01a2: 9905         	ldr	r1, [sp, #0x14]
700a01a4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a01a8: f500 6080    	add.w	r0, r0, #0x400
700a01ac: f00d fa88    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xd510
700a01b0: 9902         	ldr	r1, [sp, #0x8]
700a01b2: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = (uint32_t)0U;
700a01b4: 9902         	ldr	r1, [sp, #0x8]
700a01b6: 2000         	movs	r0, #0x0
700a01b8: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = (uint32_t)0U;
700a01ba: 9902         	ldr	r1, [sp, #0x8]
700a01bc: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT );
700a01be: 9807         	ldr	r0, [sp, #0x1c]
700a01c0: 6980         	ldr	r0, [r0, #0x18]
700a01c2: 9905         	ldr	r1, [sp, #0x14]
700a01c4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a01c8: f500 6081    	add.w	r0, r0, #0x408
700a01cc: f00d fa78    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xd4f0
700a01d0: 9902         	ldr	r1, [sp, #0x8]
700a01d2: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT );
700a01d4: 9807         	ldr	r0, [sp, #0x1c]
700a01d6: 6980         	ldr	r0, [r0, #0x18]
700a01d8: 9905         	ldr	r1, [sp, #0x14]
700a01da: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a01de: f500 6082    	add.w	r0, r0, #0x410
700a01e2: f00d fa6d    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xd4da
700a01e6: 9902         	ldr	r1, [sp, #0x8]
700a01e8: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->rxPayloadByteCnt;
700a01ea: 9902         	ldr	r1, [sp, #0x8]
700a01ec: 68c8         	ldr	r0, [r1, #0xc]
700a01ee: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->rxStartedByteCnt;
700a01f0: 9902         	ldr	r1, [sp, #0x8]
700a01f2: 6908         	ldr	r0, [r1, #0x10]
700a01f4: 6188         	str	r0, [r1, #0x18]
;                 break;
700a01f6: e003         	b	0x700a0200 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x6
700a01f8: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a01fc: 9003         	str	r0, [sp, #0xc]
;                 break;
700a01fe: e7ff         	b	0x700a0200 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #-0x2
700a0200: e7ff         	b	0x700a0202 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #-0x2
;     return retVal;
700a0202: 9803         	ldr	r0, [sp, #0xc]
700a0204: b008         	add	sp, #0x20
700a0206: bd80         	pop	{r7, pc}
		...

700a0210 <UART_lld_initDma>:
; {
700a0210: b580         	push	{r7, lr}
700a0212: b084         	sub	sp, #0x10
700a0214: 9003         	str	r0, [sp, #0xc]
700a0216: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a0218: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a021a: 9803         	ldr	r0, [sp, #0xc]
700a021c: b168         	cbz	r0, 0x700a023a <UART_lld_initDma+0x2a> @ imm = #0x1a
700a021e: e7ff         	b	0x700a0220 <UART_lld_initDma+0x10> @ imm = #-0x2
700a0220: 9803         	ldr	r0, [sp, #0xc]
700a0222: 6840         	ldr	r0, [r0, #0x4]
700a0224: b148         	cbz	r0, 0x700a023a <UART_lld_initDma+0x2a> @ imm = #0x12
700a0226: e7ff         	b	0x700a0228 <UART_lld_initDma+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a0228: 9803         	ldr	r0, [sp, #0xc]
700a022a: 6d40         	ldr	r0, [r0, #0x54]
700a022c: b120         	cbz	r0, 0x700a0238 <UART_lld_initDma+0x28> @ imm = #0x8
700a022e: e7ff         	b	0x700a0230 <UART_lld_initDma+0x20> @ imm = #-0x2
700a0230: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a0234: 9002         	str	r0, [sp, #0x8]
;         }
700a0236: e7ff         	b	0x700a0238 <UART_lld_initDma+0x28> @ imm = #-0x2
;     }
700a0238: e003         	b	0x700a0242 <UART_lld_initDma+0x32> @ imm = #0x6
700a023a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a023e: 9002         	str	r0, [sp, #0x8]
700a0240: e7ff         	b	0x700a0242 <UART_lld_initDma+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a0242: 9802         	ldr	r0, [sp, #0x8]
700a0244: 2800         	cmp	r0, #0x0
700a0246: d170         	bne	0x700a032a <UART_lld_initDma+0x11a> @ imm = #0xe0
700a0248: e7ff         	b	0x700a024a <UART_lld_initDma+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a024a: 9903         	ldr	r1, [sp, #0xc]
700a024c: 2002         	movs	r0, #0x2
700a024e: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a0250: 9803         	ldr	r0, [sp, #0xc]
700a0252: 6840         	ldr	r0, [r0, #0x4]
700a0254: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a0256: 9801         	ldr	r0, [sp, #0x4]
700a0258: 6d82         	ldr	r2, [r0, #0x58]
700a025a: f244 2040    	movw	r0, #0x4240
700a025e: f2c0 000f    	movt	r0, #0xf
700a0262: 2100         	movs	r1, #0x0
700a0264: 9100         	str	r1, [sp]
700a0266: 4790         	blx	r2
700a0268: 9a00         	ldr	r2, [sp]
700a026a: 9903         	ldr	r1, [sp, #0xc]
700a026c: 66ca         	str	r2, [r1, #0x6c]
700a026e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a0270: 9803         	ldr	r0, [sp, #0xc]
700a0272: 6800         	ldr	r0, [r0]
700a0274: f006 fa6c    	bl	0x700a6750 <UART_IsBaseAddrValid> @ imm = #0x64d8
700a0278: 4601         	mov	r1, r0
700a027a: 9802         	ldr	r0, [sp, #0x8]
700a027c: 4408         	add	r0, r1
700a027e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a0280: 9801         	ldr	r0, [sp, #0x4]
700a0282: 6800         	ldr	r0, [r0]
700a0284: f00c ff3c    	bl	0x700ad100 <UART_IsParameter> @ imm = #0xce78
700a0288: 4601         	mov	r1, r0
700a028a: 9802         	ldr	r0, [sp, #0x8]
700a028c: 4408         	add	r0, r1
700a028e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a0290: 9801         	ldr	r0, [sp, #0x4]
700a0292: 6840         	ldr	r0, [r0, #0x4]
700a0294: f00c ff34    	bl	0x700ad100 <UART_IsParameter> @ imm = #0xce68
700a0298: 4601         	mov	r1, r0
700a029a: 9802         	ldr	r0, [sp, #0x8]
700a029c: 4408         	add	r0, r1
700a029e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a02a0: 9801         	ldr	r0, [sp, #0x4]
700a02a2: 6880         	ldr	r0, [r0, #0x8]
700a02a4: f00b ffac    	bl	0x700ac200 <UART_IsDataLengthValid> @ imm = #0xbf58
700a02a8: 4601         	mov	r1, r0
700a02aa: 9802         	ldr	r0, [sp, #0x8]
700a02ac: 4408         	add	r0, r1
700a02ae: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a02b0: 9801         	ldr	r0, [sp, #0x4]
700a02b2: 68c0         	ldr	r0, [r0, #0xc]
700a02b4: f00c fd74    	bl	0x700acda0 <UART_IsStopBitsValid> @ imm = #0xcae8
700a02b8: 4601         	mov	r1, r0
700a02ba: 9802         	ldr	r0, [sp, #0x8]
700a02bc: 4408         	add	r0, r1
700a02be: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a02c0: 9801         	ldr	r0, [sp, #0x4]
700a02c2: 6900         	ldr	r0, [r0, #0x10]
700a02c4: f00b fd3c    	bl	0x700abd40 <UART_IsParityTypeValid> @ imm = #0xba78
700a02c8: 4601         	mov	r1, r0
700a02ca: 9802         	ldr	r0, [sp, #0x8]
700a02cc: 4408         	add	r0, r1
700a02ce: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a02d0: 9801         	ldr	r0, [sp, #0x4]
700a02d2: 69c0         	ldr	r0, [r0, #0x1c]
700a02d4: f00b fbf4    	bl	0x700abac0 <UART_IsHWFlowCtrlValid> @ imm = #0xb7e8
700a02d8: 4601         	mov	r1, r0
700a02da: 9802         	ldr	r0, [sp, #0x8]
700a02dc: 4408         	add	r0, r1
700a02de: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a02e0: 9801         	ldr	r0, [sp, #0x4]
700a02e2: 6ac0         	ldr	r0, [r0, #0x2c]
700a02e4: f00a fc9c    	bl	0x700aac20 <UART_OperModeValid> @ imm = #0xa938
700a02e8: 4601         	mov	r1, r0
700a02ea: 9802         	ldr	r0, [sp, #0x8]
700a02ec: 4408         	add	r0, r1
700a02ee: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a02f0: 9801         	ldr	r0, [sp, #0x4]
700a02f2: 6b80         	ldr	r0, [r0, #0x38]
700a02f4: f00b fc04    	bl	0x700abb00 <UART_IsRxTrigLvlValid> @ imm = #0xb808
700a02f8: 4601         	mov	r1, r0
700a02fa: 9802         	ldr	r0, [sp, #0x8]
700a02fc: 4408         	add	r0, r1
700a02fe: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a0300: 9801         	ldr	r0, [sp, #0x4]
700a0302: 6bc0         	ldr	r0, [r0, #0x3c]
700a0304: f00b fc1c    	bl	0x700abb40 <UART_IsTxTrigLvlValid> @ imm = #0xb838
700a0308: 4601         	mov	r1, r0
700a030a: 9802         	ldr	r0, [sp, #0x8]
700a030c: 4408         	add	r0, r1
700a030e: 9002         	str	r0, [sp, #0x8]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a0310: 9801         	ldr	r0, [sp, #0x4]
700a0312: 6c80         	ldr	r0, [r0, #0x48]
;             || (hUartInit->dmaChCfg == NULL_PTR))
700a0314: b120         	cbz	r0, 0x700a0320 <UART_lld_initDma+0x110> @ imm = #0x8
700a0316: e7ff         	b	0x700a0318 <UART_lld_initDma+0x108> @ imm = #-0x2
700a0318: 9801         	ldr	r0, [sp, #0x4]
700a031a: 6cc0         	ldr	r0, [r0, #0x4c]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a031c: b920         	cbnz	r0, 0x700a0328 <UART_lld_initDma+0x118> @ imm = #0x8
700a031e: e7ff         	b	0x700a0320 <UART_lld_initDma+0x110> @ imm = #-0x2
;             status += UART_INVALID_PARAM;
700a0320: 9802         	ldr	r0, [sp, #0x8]
700a0322: 3803         	subs	r0, #0x3
700a0324: 9002         	str	r0, [sp, #0x8]
;         }
700a0326: e7ff         	b	0x700a0328 <UART_lld_initDma+0x118> @ imm = #-0x2
;     }
700a0328: e7ff         	b	0x700a032a <UART_lld_initDma+0x11a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a032a: 9802         	ldr	r0, [sp, #0x8]
700a032c: b950         	cbnz	r0, 0x700a0344 <UART_lld_initDma+0x134> @ imm = #0x14
700a032e: e7ff         	b	0x700a0330 <UART_lld_initDma+0x120> @ imm = #-0x2
;         UART_configInstance(hUart);
700a0330: 9803         	ldr	r0, [sp, #0xc]
700a0332: f003 f8fd    	bl	0x700a3530 <UART_configInstance> @ imm = #0x31fa
;         status = UART_lld_dmaInit(hUart, hUart->hUartInit->dmaChCfg);
700a0336: 9803         	ldr	r0, [sp, #0xc]
700a0338: 6841         	ldr	r1, [r0, #0x4]
700a033a: 6cc9         	ldr	r1, [r1, #0x4c]
700a033c: f00a fff0    	bl	0x700ab320 <UART_lld_dmaInit> @ imm = #0xafe0
700a0340: 9002         	str	r0, [sp, #0x8]
;     }
700a0342: e7ff         	b	0x700a0344 <UART_lld_initDma+0x134> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a0344: 9802         	ldr	r0, [sp, #0x8]
700a0346: b920         	cbnz	r0, 0x700a0352 <UART_lld_initDma+0x142> @ imm = #0x8
700a0348: e7ff         	b	0x700a034a <UART_lld_initDma+0x13a> @ imm = #-0x2
;         hUart->state = UART_STATE_READY;
700a034a: 9903         	ldr	r1, [sp, #0xc]
700a034c: 2001         	movs	r0, #0x1
700a034e: 6548         	str	r0, [r1, #0x54]
;     }
700a0350: e004         	b	0x700a035c <UART_lld_initDma+0x14c> @ imm = #0x8
;        status = UART_lld_deInitDma(hUart);
700a0352: 9803         	ldr	r0, [sp, #0xc]
700a0354: f009 fbcc    	bl	0x700a9af0 <UART_lld_deInitDma> @ imm = #0x9798
700a0358: 9002         	str	r0, [sp, #0x8]
700a035a: e7ff         	b	0x700a035c <UART_lld_initDma+0x14c> @ imm = #-0x2
;     return status;
700a035c: 9802         	ldr	r0, [sp, #0x8]
700a035e: b004         	add	sp, #0x10
700a0360: bd80         	pop	{r7, pc}
700a0362: 0000         	movs	r0, r0

700a0364 <CSL_armR5PmuSelectCntr>:
;     AND     r0, r0, #0x1F
700a0364: e200001f     	and	r0, r0, #31
;     MCR     p15, #0, r0, c9, c12, #5        /* Write PMSELR Register */
700a0368: ee090fbc     	mcr	p15, #0x0, r0, c9, c12, #0x5
;     BX      lr
700a036c: e12fff1e     	bx	lr

700a0370 <CSL_armR5PmuCfg>:
;     MRC     p15, #0, r3, c9, c12, #0        /* Read PMCR Register */
700a0370: ee193f1c     	mrc	p15, #0x0, r3, c9, c12, #0x0
;     BIC     r3, r3, #((1<<3) | (1<<4))      /* Clear D and X bits */
700a0374: e3c33018     	bic	r3, r3, #24
;     CMP     r0, #0
700a0378: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuCfg_00
700a037c: 0a000000     	beq	0x700a0384 <armR5PmuCfg_00> @ imm = #0x0
;     ORR     r3, r3, #(1<<3)                 /* Set D bit */
700a0380: e3833008     	orr	r3, r3, #8

700a0384 <armR5PmuCfg_00>:
;     CMP     r1, #0
700a0384: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuCfg_01
700a0388: 0a000000     	beq	0x700a0390 <armR5PmuCfg_01> @ imm = #0x0
;     ORR     r3, r3, #(1<<4)                 /* Set X bit */
700a038c: e3833010     	orr	r3, r3, #16

700a0390 <armR5PmuCfg_01>:
;     MCR     p15, #0, r3, c9, c12, #0        /* Write PMCR Register */
700a0390: ee093f1c     	mcr	p15, #0x0, r3, c9, c12, #0x0
;     EOR     r3, r3, r3                      /* Clear r3 */
700a0394: e0233003     	eor	r3, r3, r3
;     CMP     r2, #0
700a0398: e3520000     	cmp	r2, #0
;     BEQ     armR5PmuCfg_02
700a039c: 0a000000     	beq	0x700a03a4 <armR5PmuCfg_02> @ imm = #0x0
;     ORR     r3, r3, #1
700a03a0: e3833001     	orr	r3, r3, #1

700a03a4 <armR5PmuCfg_02>:
;     MCR     p15, #0, r3, c9, c14, #0        /* Write PMUSERENR Register */
700a03a4: ee093f1e     	mcr	p15, #0x0, r3, c9, c14, #0x0
;     BX      lr
700a03a8: e12fff1e     	bx	lr

700a03ac <CSL_armR5PmuEnableAllCntrs>:
;     MRC     p15, #0, r1, c9, c12, #0        /* Read PMCR */
700a03ac: ee191f1c     	mrc	p15, #0x0, r1, c9, c12, #0x0
;     CMP     r0, #0
700a03b0: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuEnableAllCntrs_disable
700a03b4: 0a000001     	beq	0x700a03c0 <armR5PmuEnableAllCntrs_disable> @ imm = #0x4
;     ORR     r1, r1, #0x1                    /* Set E bit to enable all counters */
700a03b8: e3811001     	orr	r1, r1, #1
;     B       armR5PmuEnableAllCntrs_00
700a03bc: ea000000     	b	0x700a03c4 <armR5PmuEnableAllCntrs_00> @ imm = #0x0

700a03c0 <armR5PmuEnableAllCntrs_disable>:
;     BIC     r1, r1, #0x1                    /* Clr E bit to disable all counters */
700a03c0: e3c11001     	bic	r1, r1, #1

700a03c4 <armR5PmuEnableAllCntrs_00>:
;     MCR     p15, #0, r1, c9, c12, #0        /* Write modified PMCR */
700a03c4: ee091f1c     	mcr	p15, #0x0, r1, c9, c12, #0x0
;     BX      lr
700a03c8: e12fff1e     	bx	lr

700a03cc <CSL_armR5PmuGetNumCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR (Performance Monitor Control Register) */
700a03cc: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     LSR     r0, r0, #11                     /* Shift and */
700a03d0: e1a005a0     	lsr	r0, r0, #11
;     AND     r0, r0, #0x1F                   /*   mask to get N */
700a03d4: e200001f     	and	r0, r0, #31
;     BX      lr
700a03d8: e12fff1e     	bx	lr

700a03dc <CSL_armR5PmuCfgCntr>:
;     PUSH    {lr}
700a03dc: e52de004     	str	lr, [sp, #-0x4]!
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a03e0: ebffffdf     	bl	0x700a0364 <CSL_armR5PmuSelectCntr> @ imm = #-0x84
;     AND     r1, r1, #0xFF
700a03e4: e20110ff     	and	r1, r1, #255
;     MCR     p15, #0, r1, c9, c13, #1        /* Write PMXEVTYPERx Register */
700a03e8: ee091f3d     	mcr	p15, #0x0, r1, c9, c13, #0x1
;     POP     {lr}
700a03ec: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a03f0: e12fff1e     	bx	lr

700a03f4 <CSL_armR5PmuEnableCntrOverflowIntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a03f4: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a03f8: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a03fc: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a0400: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrOverflowIntr_clear
700a0404: 0a000001     	beq	0x700a0410 <armR5PmuEnableCntrOverflowIntr_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c14, #1        /* Write PMINTENSET Register (writes of 0 have no effect) */
700a0408: ee090f3e     	mcr	p15, #0x0, r0, c9, c14, #0x1
;     B       armR5PmuEnableCntrOverflowIntr_00
700a040c: ea000000     	b	0x700a0414 <armR5PmuEnableCntrOverflowIntr_00> @ imm = #0x0

700a0410 <armR5PmuEnableCntrOverflowIntr_clear>:
;     MCR     p15, #0, r0, c9, c14, #2        /* Write PMINTENCLR Register (writes of 0 have no effect) */
700a0410: ee090f5e     	mcr	p15, #0x0, r0, c9, c14, #0x2

700a0414 <armR5PmuEnableCntrOverflowIntr_00>:
;     BX      lr
700a0414: e12fff1e     	bx	lr

700a0418 <CSL_armR5PmuEnableCntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a0418: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a041c: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a0420: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a0424: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrs_clear
700a0428: 0a000001     	beq	0x700a0434 <armR5PmuEnableCntrs_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c12, #1        /* Write PMCNTENSET Register (writes of 0 have no effect) */
700a042c: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;     B       armR5PmuEnableCntrs_00
700a0430: ea000000     	b	0x700a0438 <armR5PmuEnableCntrs_00> @ imm = #0x0

700a0434 <armR5PmuEnableCntrs_clear>:
;     MCR     p15, #0, r0, c9, c12, #2        /* Write PMCNTENCLR Register (writes of 0 have no effect) */
700a0434: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2

700a0438 <armR5PmuEnableCntrs_00>:
;     BX      lr
700a0438: e12fff1e     	bx	lr

700a043c <CSL_armR5PmuReadCntr>:
;     PUSH    {lr}
700a043c: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a0440: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuReadCntr_cycles
700a0444: 0a000002     	beq	0x700a0454 <armR5PmuReadCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a0448: ebffffc5     	bl	0x700a0364 <CSL_armR5PmuSelectCntr> @ imm = #-0xec
;     MRC     p15, #0, r0, c9, c13, #2        /* Read current PMNx Register */
700a044c: ee190f5d     	mrc	p15, #0x0, r0, c9, c13, #0x2
;     B       armR5PmuReadCntr_00
700a0450: ea000000     	b	0x700a0458 <armR5PmuReadCntr_00> @ imm = #0x0

700a0454 <armR5PmuReadCntr_cycles>:
;     MRC     p15, #0, r0, c9, c13, #0        /* Read PMCCNTR Register */
700a0454: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0

700a0458 <armR5PmuReadCntr_00>:
;     POP     {lr}
700a0458: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a045c: e12fff1e     	bx	lr

700a0460 <CSL_armR5PmuSetCntr>:
;     PUSH    {lr}
700a0460: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a0464: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuSetCntr_cycles
700a0468: 0a000002     	beq	0x700a0478 <armR5PmuSetCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a046c: ebffffbc     	bl	0x700a0364 <CSL_armR5PmuSelectCntr> @ imm = #-0x110
;     MCR     p15, #0, r1, c9, c13, #2        /* Write current PMNx Register */
700a0470: ee091f5d     	mcr	p15, #0x0, r1, c9, c13, #0x2
;     B       armR5PmuSetCntr_00
700a0474: ea000000     	b	0x700a047c <armR5PmuSetCntr_00> @ imm = #0x0

700a0478 <armR5PmuSetCntr_cycles>:
;     MCR     p15, #0, r1, c9, c13, #0        /* Write PMCCNTR Register */
700a0478: ee091f1d     	mcr	p15, #0x0, r1, c9, c13, #0x0

700a047c <armR5PmuSetCntr_00>:
;     POP     {lr}
700a047c: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a0480: e12fff1e     	bx	lr

700a0484 <CSL_armR5PmuReadCntrOverflowStatus>:
;     MRC     p15, #0, r0, c9, c12, #3        /* Read PMOVSR Register */
700a0484: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a0488: e12fff1e     	bx	lr

700a048c <CSL_armR5PmuClearCntrOverflowStatus>:
;     MCR     p15, #0, r0, c9, c12, #3        /* Write PMOVSR Register */
700a048c: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a0490: e12fff1e     	bx	lr

700a0494 <CSL_armR5PmuResetCycleCnt>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a0494: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<2)                 /* Set C bit to reset the cycle counter, PMCCNTR, to zero */
700a0498: e3800004     	orr	r0, r0, #4
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR*/
700a049c: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a04a0: e12fff1e     	bx	lr

700a04a4 <CSL_armR5PmuResetCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a04a4: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<1)                 /* Set P bit to reset all event counters to zero */
700a04a8: e3800002     	orr	r0, r0, #2
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR */
700a04ac: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a04b0: e12fff1e     	bx	lr
		...

700a04c0 <Udma_chAssignRegOverlay>:
; {
700a04c0: b082         	sub	sp, #0x8
700a04c2: 9001         	str	r0, [sp, #0x4]
700a04c4: 9100         	str	r1, [sp]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a04c6: 9801         	ldr	r0, [sp, #0x4]
700a04c8: 6800         	ldr	r0, [r0]
700a04ca: 2801         	cmp	r0, #0x1
700a04cc: d147         	bne	0x700a055e <Udma_chAssignRegOverlay+0x9e> @ imm = #0x8e
700a04ce: e7ff         	b	0x700a04d0 <Udma_chAssignRegOverlay+0x10> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a04d0: 9800         	ldr	r0, [sp]
700a04d2: 6ec0         	ldr	r0, [r0, #0x6c]
700a04d4: f510 3f80    	cmn.w	r0, #0x10000
700a04d8: d029         	beq	0x700a052e <Udma_chAssignRegOverlay+0x6e> @ imm = #0x52
700a04da: e7ff         	b	0x700a04dc <Udma_chAssignRegOverlay+0x1c> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a04dc: 9800         	ldr	r0, [sp]
700a04de: 7800         	ldrb	r0, [r0]
700a04e0: 0740         	lsls	r0, r0, #0x1d
700a04e2: 2800         	cmp	r0, #0x0
700a04e4: d511         	bpl	0x700a050a <Udma_chAssignRegOverlay+0x4a> @ imm = #0x22
700a04e6: e7ff         	b	0x700a04e8 <Udma_chAssignRegOverlay+0x28> @ imm = #-0x2
;                     &drvHandle->bcdmaRegs.pBcChanCfgRegs->CHAN[chHandle->txChNum];
700a04e8: 9801         	ldr	r0, [sp, #0x4]
700a04ea: 68c0         	ldr	r0, [r0, #0xc]
700a04ec: 9900         	ldr	r1, [sp]
700a04ee: 6eca         	ldr	r2, [r1, #0x6c]
700a04f0: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaBcCfgRegs =
700a04f4: f8c1 0214    	str.w	r0, [r1, #0x214]
;                     &drvHandle->bcdmaRegs.pBcChanRtRegs->CHAN[chHandle->txChNum];
700a04f8: 9801         	ldr	r0, [sp, #0x4]
700a04fa: 6900         	ldr	r0, [r0, #0x10]
700a04fc: 9900         	ldr	r1, [sp]
700a04fe: 6eca         	ldr	r2, [r1, #0x6c]
700a0500: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaBcRtRegs  =
700a0504: f8c1 0218    	str.w	r0, [r1, #0x218]
;             }
700a0508: e010         	b	0x700a052c <Udma_chAssignRegOverlay+0x6c> @ imm = #0x20
;                     &drvHandle->bcdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a050a: 9801         	ldr	r0, [sp, #0x4]
700a050c: 6940         	ldr	r0, [r0, #0x14]
700a050e: 9900         	ldr	r1, [sp]
700a0510: 6eca         	ldr	r2, [r1, #0x6c]
700a0512: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaTxCfgRegs =
700a0516: f8c1 021c    	str.w	r0, [r1, #0x21c]
;                     &drvHandle->bcdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a051a: 9801         	ldr	r0, [sp, #0x4]
700a051c: 6980         	ldr	r0, [r0, #0x18]
700a051e: 9900         	ldr	r1, [sp]
700a0520: 6eca         	ldr	r2, [r1, #0x6c]
700a0522: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaTxRtRegs  =
700a0526: f8c1 0220    	str.w	r0, [r1, #0x220]
700a052a: e7ff         	b	0x700a052c <Udma_chAssignRegOverlay+0x6c> @ imm = #-0x2
;         }
700a052c: e7ff         	b	0x700a052e <Udma_chAssignRegOverlay+0x6e> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a052e: 9800         	ldr	r0, [sp]
700a0530: 6f00         	ldr	r0, [r0, #0x70]
700a0532: f510 3f80    	cmn.w	r0, #0x10000
700a0536: d011         	beq	0x700a055c <Udma_chAssignRegOverlay+0x9c> @ imm = #0x22
700a0538: e7ff         	b	0x700a053a <Udma_chAssignRegOverlay+0x7a> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a053a: 9801         	ldr	r0, [sp, #0x4]
700a053c: 69c0         	ldr	r0, [r0, #0x1c]
700a053e: 9900         	ldr	r1, [sp]
700a0540: 6f0a         	ldr	r2, [r1, #0x70]
700a0542: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pBcdmaRxCfgRegs =
700a0546: f8c1 0224    	str.w	r0, [r1, #0x224]
;                 &drvHandle->bcdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a054a: 9801         	ldr	r0, [sp, #0x4]
700a054c: 6a00         	ldr	r0, [r0, #0x20]
700a054e: 9900         	ldr	r1, [sp]
700a0550: 6f0a         	ldr	r2, [r1, #0x70]
700a0552: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pBcdmaRxRtRegs  =
700a0556: f8c1 0228    	str.w	r0, [r1, #0x228]
;         }
700a055a: e7ff         	b	0x700a055c <Udma_chAssignRegOverlay+0x9c> @ imm = #-0x2
;     }
700a055c: e051         	b	0x700a0602 <Udma_chAssignRegOverlay+0x142> @ imm = #0xa2
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a055e: 9801         	ldr	r0, [sp, #0x4]
700a0560: 6800         	ldr	r0, [r0]
700a0562: 2802         	cmp	r0, #0x2
700a0564: d14c         	bne	0x700a0600 <Udma_chAssignRegOverlay+0x140> @ imm = #0x98
700a0566: e7ff         	b	0x700a0568 <Udma_chAssignRegOverlay+0xa8> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a0568: 9800         	ldr	r0, [sp]
700a056a: 6ec0         	ldr	r0, [r0, #0x6c]
700a056c: f510 3f80    	cmn.w	r0, #0x10000
700a0570: d011         	beq	0x700a0596 <Udma_chAssignRegOverlay+0xd6> @ imm = #0x22
700a0572: e7ff         	b	0x700a0574 <Udma_chAssignRegOverlay+0xb4> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a0574: 9801         	ldr	r0, [sp, #0x4]
700a0576: 6dc0         	ldr	r0, [r0, #0x5c]
700a0578: 9900         	ldr	r1, [sp]
700a057a: 6eca         	ldr	r2, [r1, #0x6c]
700a057c: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaTxCfgRegs =
700a0580: f8c1 022c    	str.w	r0, [r1, #0x22c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a0584: 9801         	ldr	r0, [sp, #0x4]
700a0586: 6e40         	ldr	r0, [r0, #0x64]
700a0588: 9900         	ldr	r1, [sp]
700a058a: 6eca         	ldr	r2, [r1, #0x6c]
700a058c: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaTxRtRegs  =
700a0590: f8c1 0230    	str.w	r0, [r1, #0x230]
;         }
700a0594: e7ff         	b	0x700a0596 <Udma_chAssignRegOverlay+0xd6> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a0596: 9800         	ldr	r0, [sp]
700a0598: 6f00         	ldr	r0, [r0, #0x70]
700a059a: f510 3f80    	cmn.w	r0, #0x10000
700a059e: d011         	beq	0x700a05c4 <Udma_chAssignRegOverlay+0x104> @ imm = #0x22
700a05a0: e7ff         	b	0x700a05a2 <Udma_chAssignRegOverlay+0xe2> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a05a2: 9801         	ldr	r0, [sp, #0x4]
700a05a4: 6e00         	ldr	r0, [r0, #0x60]
700a05a6: 9900         	ldr	r1, [sp]
700a05a8: 6f0a         	ldr	r2, [r1, #0x70]
700a05aa: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaRxCfgRegs =
700a05ae: f8c1 0234    	str.w	r0, [r1, #0x234]
;                 &drvHandle->pktdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a05b2: 9801         	ldr	r0, [sp, #0x4]
700a05b4: 6e80         	ldr	r0, [r0, #0x68]
700a05b6: 9900         	ldr	r1, [sp]
700a05b8: 6f0a         	ldr	r2, [r1, #0x70]
700a05ba: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaRxRtRegs  =
700a05be: f8c1 0238    	str.w	r0, [r1, #0x238]
;         }
700a05c2: e7ff         	b	0x700a05c4 <Udma_chAssignRegOverlay+0x104> @ imm = #-0x2
;         if(chHandle->extChNum != UDMA_DMA_CH_INVALID)
700a05c4: 9800         	ldr	r0, [sp]
700a05c6: 6f40         	ldr	r0, [r0, #0x74]
700a05c8: f510 3f80    	cmn.w	r0, #0x10000
700a05cc: d017         	beq	0x700a05fe <Udma_chAssignRegOverlay+0x13e> @ imm = #0x2e
700a05ce: e7ff         	b	0x700a05d0 <Udma_chAssignRegOverlay+0x110> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a05d0: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a05d2: 9900         	ldr	r1, [sp]
700a05d4: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a05d6: 6dd8         	ldr	r0, [r3, #0x5c]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a05d8: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a05dc: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a05de: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaExtCfgRegs =
700a05e2: f8c1 023c    	str.w	r0, [r1, #0x23c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a05e6: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a05e8: 9900         	ldr	r1, [sp]
700a05ea: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a05ec: 6e58         	ldr	r0, [r3, #0x64]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a05ee: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a05f2: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a05f4: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaExtRtRegs  =
700a05f8: f8c1 0240    	str.w	r0, [r1, #0x240]
;         }
700a05fc: e7ff         	b	0x700a05fe <Udma_chAssignRegOverlay+0x13e> @ imm = #-0x2
;     }
700a05fe: e7ff         	b	0x700a0600 <Udma_chAssignRegOverlay+0x140> @ imm = #-0x2
700a0600: e7ff         	b	0x700a0602 <Udma_chAssignRegOverlay+0x142> @ imm = #-0x2
; }
700a0602: b002         	add	sp, #0x8
700a0604: 4770         	bx	lr
		...
700a060e: 0000         	movs	r0, r0

700a0610 <DebugP_memLogWriterPutChar>:
; {
700a0610: b580         	push	{r7, lr}
700a0612: b088         	sub	sp, #0x20
700a0614: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     if(lineBufIndex==0U)
700a0618: f240 00e4    	movw	r0, #0xe4
700a061c: f2c7 000b    	movt	r0, #0x700b
700a0620: 6800         	ldr	r0, [r0]
700a0622: bb40         	cbnz	r0, 0x700a0676 <DebugP_memLogWriterPutChar+0x66> @ imm = #0x50
700a0624: e7ff         	b	0x700a0626 <DebugP_memLogWriterPutChar+0x16> @ imm = #-0x2
;         uint64_t curTime = ClockP_getTimeUsec();
700a0626: f008 fa3b    	bl	0x700a8aa0 <ClockP_getTimeUsec> @ imm = #0x8476
700a062a: 9105         	str	r1, [sp, #0x14]
700a062c: 9004         	str	r0, [sp, #0x10]
;                             gDebugP_memTraceLogWriterSelfCoreName,
700a062e: f240 10b0    	movw	r0, #0x1b0
700a0632: f2c7 000b    	movt	r0, #0x700b
700a0636: 6800         	ldr	r0, [r0]
;                             (uint32_t)(curTime/TIME_IN_MICRO_SECONDS),
700a0638: 9003         	str	r0, [sp, #0xc]
700a063a: 9804         	ldr	r0, [sp, #0x10]
700a063c: 9905         	ldr	r1, [sp, #0x14]
700a063e: f244 2240    	movw	r2, #0x4240
700a0642: f2c0 020f    	movt	r2, #0xf
700a0646: 2300         	movs	r3, #0x0
;                             (uint32_t)(curTime%TIME_IN_MICRO_SECONDS)
700a0648: f00c ebbc    	blx	0x700acdc4 <__aeabi_uldivmod> @ imm = #0xc778
700a064c: 9b03         	ldr	r3, [sp, #0xc]
;         lineBufIndex = (uint32_t)snprintf_((char*)lineBuf, DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE, "[%6s] %5d.%06ds : ",
700a064e: 4669         	mov	r1, sp
700a0650: 604a         	str	r2, [r1, #0x4]
700a0652: 6008         	str	r0, [r1]
700a0654: f644 50c8    	movw	r0, #0x4dc8
700a0658: f2c7 0008    	movt	r0, #0x7008
700a065c: f64f 0256    	movw	r2, #0xf856
700a0660: f2c7 020a    	movt	r2, #0x700a
700a0664: 2178         	movs	r1, #0x78
700a0666: f00b fc4b    	bl	0x700abf00 <snprintf_>  @ imm = #0xb896
700a066a: f240 01e4    	movw	r1, #0xe4
700a066e: f2c7 010b    	movt	r1, #0x700b
700a0672: 6008         	str	r0, [r1]
;     }
700a0674: e7ff         	b	0x700a0676 <DebugP_memLogWriterPutChar+0x66> @ imm = #-0x2
;     lineBuf[lineBufIndex]=(uint8_t)character;
700a0676: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a067a: f240 01e4    	movw	r1, #0xe4
700a067e: f2c7 010b    	movt	r1, #0x700b
700a0682: 680b         	ldr	r3, [r1]
700a0684: f644 52c8    	movw	r2, #0x4dc8
700a0688: f2c7 0208    	movt	r2, #0x7008
700a068c: 54d0         	strb	r0, [r2, r3]
; 	lineBufIndex = lineBufIndex + 1U;
700a068e: 6808         	ldr	r0, [r1]
700a0690: 3001         	adds	r0, #0x1
700a0692: 6008         	str	r0, [r1]
;     if( (character == '\n') ||
700a0694: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a0698: 280a         	cmp	r0, #0xa
700a069a: d008         	beq	0x700a06ae <DebugP_memLogWriterPutChar+0x9e> @ imm = #0x10
700a069c: e7ff         	b	0x700a069e <DebugP_memLogWriterPutChar+0x8e> @ imm = #-0x2
;         (lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE)))
700a069e: f240 00e4    	movw	r0, #0xe4
700a06a2: f2c7 000b    	movt	r0, #0x700b
700a06a6: 6800         	ldr	r0, [r0]
;     if( (character == '\n') ||
700a06a8: 2878         	cmp	r0, #0x78
700a06aa: d350         	blo	0x700a074e <DebugP_memLogWriterPutChar+0x13e> @ imm = #0xa0
700a06ac: e7ff         	b	0x700a06ae <DebugP_memLogWriterPutChar+0x9e> @ imm = #-0x2
;         if(lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE))
700a06ae: f240 00e4    	movw	r0, #0xe4
700a06b2: f2c7 000b    	movt	r0, #0x700b
700a06b6: 6800         	ldr	r0, [r0]
700a06b8: 2878         	cmp	r0, #0x78
700a06ba: d315         	blo	0x700a06e8 <DebugP_memLogWriterPutChar+0xd8> @ imm = #0x2a
700a06bc: e7ff         	b	0x700a06be <DebugP_memLogWriterPutChar+0xae> @ imm = #-0x2
;             lineBuf[lineBufIndex]=(uint8_t)'\r';
700a06be: f240 01e4    	movw	r1, #0xe4
700a06c2: f2c7 010b    	movt	r1, #0x700b
700a06c6: 680b         	ldr	r3, [r1]
700a06c8: f644 52c8    	movw	r2, #0x4dc8
700a06cc: f2c7 0208    	movt	r2, #0x7008
700a06d0: 200d         	movs	r0, #0xd
700a06d2: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a06d4: 6808         	ldr	r0, [r1]
700a06d6: 3001         	adds	r0, #0x1
700a06d8: 6008         	str	r0, [r1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a06da: 680b         	ldr	r3, [r1]
700a06dc: 200a         	movs	r0, #0xa
700a06de: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a06e0: 6808         	ldr	r0, [r1]
700a06e2: 3001         	adds	r0, #0x1
700a06e4: 6008         	str	r0, [r1]
;         }
700a06e6: e7ff         	b	0x700a06e8 <DebugP_memLogWriterPutChar+0xd8> @ imm = #-0x2
;         if(lineBuf[lineBufIndex-UNSIGNED_INTEGERVAL_TWO]!=(uint8_t)'\r')
700a06e8: f240 00e4    	movw	r0, #0xe4
700a06ec: f2c7 000b    	movt	r0, #0x700b
700a06f0: 6800         	ldr	r0, [r0]
700a06f2: f644 51c8    	movw	r1, #0x4dc8
700a06f6: f2c7 0108    	movt	r1, #0x7008
700a06fa: 4408         	add	r0, r1
700a06fc: f810 0c02    	ldrb	r0, [r0, #-2]
700a0700: 280d         	cmp	r0, #0xd
700a0702: d014         	beq	0x700a072e <DebugP_memLogWriterPutChar+0x11e> @ imm = #0x28
700a0704: e7ff         	b	0x700a0706 <DebugP_memLogWriterPutChar+0xf6> @ imm = #-0x2
;             lineBuf[lineBufIndex-1U]=(uint8_t)'\r';
700a0706: f240 01e4    	movw	r1, #0xe4
700a070a: f2c7 010b    	movt	r1, #0x700b
700a070e: 6808         	ldr	r0, [r1]
700a0710: f644 52c8    	movw	r2, #0x4dc8
700a0714: f2c7 0208    	movt	r2, #0x7008
700a0718: 1883         	adds	r3, r0, r2
700a071a: 200d         	movs	r0, #0xd
700a071c: f803 0c01    	strb	r0, [r3, #-1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a0720: 680b         	ldr	r3, [r1]
700a0722: 200a         	movs	r0, #0xa
700a0724: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a0726: 6808         	ldr	r0, [r1]
700a0728: 3001         	adds	r0, #0x1
700a072a: 6008         	str	r0, [r1]
;         }
700a072c: e7ff         	b	0x700a072e <DebugP_memLogWriterPutChar+0x11e> @ imm = #-0x2
;         DebugP_memTraceLogWriterPutLine(lineBuf, (uint16_t)lineBufIndex);
700a072e: f240 00e4    	movw	r0, #0xe4
700a0732: f2c7 000b    	movt	r0, #0x700b
700a0736: 9002         	str	r0, [sp, #0x8]
700a0738: 8801         	ldrh	r1, [r0]
700a073a: f644 50c8    	movw	r0, #0x4dc8
700a073e: f2c7 0008    	movt	r0, #0x7008
700a0742: f003 fb6d    	bl	0x700a3e20 <DebugP_memTraceLogWriterPutLine> @ imm = #0x36da
700a0746: 9902         	ldr	r1, [sp, #0x8]
700a0748: 2000         	movs	r0, #0x0
;         lineBufIndex = 0;
700a074a: 6008         	str	r0, [r1]
;     }
700a074c: e7ff         	b	0x700a074e <DebugP_memLogWriterPutChar+0x13e> @ imm = #-0x2
; }
700a074e: b008         	add	sp, #0x20
700a0750: bd80         	pop	{r7, pc}
		...
700a075e: 0000         	movs	r0, r0

700a0760 <Sciclient_sendMessage>:
; {
700a0760: b580         	push	{r7, lr}
700a0762: b08a         	sub	sp, #0x28
700a0764: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a0768: 9009         	str	r0, [sp, #0x24]
700a076a: 9108         	str	r1, [sp, #0x20]
700a076c: 9207         	str	r2, [sp, #0x1c]
700a076e: 9306         	str	r3, [sp, #0x18]
700a0770: 2200         	movs	r2, #0x0
;     uint32_t        i   = 0U;
700a0772: 9205         	str	r2, [sp, #0x14]
;     const uint8_t *msg = pSecHeader;
700a0774: 9808         	ldr	r0, [sp, #0x20]
700a0776: 9004         	str	r0, [sp, #0x10]
;     uint32_t numWords   = 0U;
700a0778: 9203         	str	r2, [sp, #0xc]
;     uint32_t test = 0U;
700a077a: 9202         	str	r2, [sp, #0x8]
;     uintptr_t threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U);
700a077c: 9909         	ldr	r1, [sp, #0x24]
700a077e: f240 00e8    	movw	r0, #0xe8
700a0782: f2c7 000b    	movt	r0, #0x700b
700a0786: f00c fcab    	bl	0x700ad0e0 <CSL_secProxyGetDataAddr> @ imm = #0xc956
700a078a: 9001         	str	r0, [sp, #0x4]
;     if(pSecHeader != NULL)
700a078c: 9808         	ldr	r0, [sp, #0x20]
700a078e: b1f8         	cbz	r0, 0x700a07d0 <Sciclient_sendMessage+0x70> @ imm = #0x3e
700a0790: e7ff         	b	0x700a0792 <Sciclient_sendMessage+0x32> @ imm = #-0x2
700a0792: 2000         	movs	r0, #0x0
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a0794: 9005         	str	r0, [sp, #0x14]
700a0796: e7ff         	b	0x700a0798 <Sciclient_sendMessage+0x38> @ imm = #-0x2
700a0798: 9805         	ldr	r0, [sp, #0x14]
700a079a: f240 2120    	movw	r1, #0x220
700a079e: f2c7 010b    	movt	r1, #0x700b
700a07a2: 7809         	ldrb	r1, [r1]
700a07a4: 4288         	cmp	r0, r1
700a07a6: d212         	bhs	0x700a07ce <Sciclient_sendMessage+0x6e> @ imm = #0x24
700a07a8: e7ff         	b	0x700a07aa <Sciclient_sendMessage+0x4a> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a07aa: 9804         	ldr	r0, [sp, #0x10]
700a07ac: 6800         	ldr	r0, [r0]
700a07ae: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a07b0: 9801         	ldr	r0, [sp, #0x4]
700a07b2: 9902         	ldr	r1, [sp, #0x8]
700a07b4: f00c fefc    	bl	0x700ad5b0 <CSL_REG32_WR_RAW> @ imm = #0xcdf8
;             msg += 4;
700a07b8: 9804         	ldr	r0, [sp, #0x10]
700a07ba: 3004         	adds	r0, #0x4
700a07bc: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a07be: 9801         	ldr	r0, [sp, #0x4]
700a07c0: 3004         	adds	r0, #0x4
700a07c2: 9001         	str	r0, [sp, #0x4]
;         }
700a07c4: e7ff         	b	0x700a07c6 <Sciclient_sendMessage+0x66> @ imm = #-0x2
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a07c6: 9805         	ldr	r0, [sp, #0x14]
700a07c8: 3001         	adds	r0, #0x1
700a07ca: 9005         	str	r0, [sp, #0x14]
700a07cc: e7e4         	b	0x700a0798 <Sciclient_sendMessage+0x38> @ imm = #-0x38
;     }
700a07ce: e7ff         	b	0x700a07d0 <Sciclient_sendMessage+0x70> @ imm = #-0x2
;     msg = pHeader;
700a07d0: 9807         	ldr	r0, [sp, #0x1c]
700a07d2: 9004         	str	r0, [sp, #0x10]
700a07d4: 2000         	movs	r0, #0x0
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a07d6: 9005         	str	r0, [sp, #0x14]
700a07d8: e7ff         	b	0x700a07da <Sciclient_sendMessage+0x7a> @ imm = #-0x2
700a07da: 9805         	ldr	r0, [sp, #0x14]
700a07dc: 2801         	cmp	r0, #0x1
700a07de: d812         	bhi	0x700a0806 <Sciclient_sendMessage+0xa6> @ imm = #0x24
700a07e0: e7ff         	b	0x700a07e2 <Sciclient_sendMessage+0x82> @ imm = #-0x2
;         (void) memcpy((void *)&test, (const void *)msg, 4);
700a07e2: 9804         	ldr	r0, [sp, #0x10]
700a07e4: 6800         	ldr	r0, [r0]
700a07e6: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(threadAddr, test);
700a07e8: 9801         	ldr	r0, [sp, #0x4]
700a07ea: 9902         	ldr	r1, [sp, #0x8]
700a07ec: f00c fee0    	bl	0x700ad5b0 <CSL_REG32_WR_RAW> @ imm = #0xcdc0
;         msg += 4;
700a07f0: 9804         	ldr	r0, [sp, #0x10]
700a07f2: 3004         	adds	r0, #0x4
700a07f4: 9004         	str	r0, [sp, #0x10]
;         threadAddr+=sizeof(uint32_t);
700a07f6: 9801         	ldr	r0, [sp, #0x4]
700a07f8: 3004         	adds	r0, #0x4
700a07fa: 9001         	str	r0, [sp, #0x4]
;     }
700a07fc: e7ff         	b	0x700a07fe <Sciclient_sendMessage+0x9e> @ imm = #-0x2
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a07fe: 9805         	ldr	r0, [sp, #0x14]
700a0800: 3001         	adds	r0, #0x1
700a0802: 9005         	str	r0, [sp, #0x14]
700a0804: e7e9         	b	0x700a07da <Sciclient_sendMessage+0x7a> @ imm = #-0x2e
;     if (payloadSize > 0U)
700a0806: 980c         	ldr	r0, [sp, #0x30]
700a0808: b300         	cbz	r0, 0x700a084c <Sciclient_sendMessage+0xec> @ imm = #0x40
700a080a: e7ff         	b	0x700a080c <Sciclient_sendMessage+0xac> @ imm = #-0x2
;         numWords   = (payloadSize+3U)/4U;
700a080c: 980c         	ldr	r0, [sp, #0x30]
700a080e: 3003         	adds	r0, #0x3
700a0810: 0880         	lsrs	r0, r0, #0x2
700a0812: 9003         	str	r0, [sp, #0xc]
;         msg = pPayload;
700a0814: 9806         	ldr	r0, [sp, #0x18]
700a0816: 9004         	str	r0, [sp, #0x10]
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a0818: e7ff         	b	0x700a081a <Sciclient_sendMessage+0xba> @ imm = #-0x2
700a081a: 9805         	ldr	r0, [sp, #0x14]
700a081c: 9903         	ldr	r1, [sp, #0xc]
700a081e: 3102         	adds	r1, #0x2
700a0820: 4288         	cmp	r0, r1
700a0822: d212         	bhs	0x700a084a <Sciclient_sendMessage+0xea> @ imm = #0x24
700a0824: e7ff         	b	0x700a0826 <Sciclient_sendMessage+0xc6> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a0826: 9804         	ldr	r0, [sp, #0x10]
700a0828: 6800         	ldr	r0, [r0]
700a082a: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a082c: 9801         	ldr	r0, [sp, #0x4]
700a082e: 9902         	ldr	r1, [sp, #0x8]
700a0830: f00c febe    	bl	0x700ad5b0 <CSL_REG32_WR_RAW> @ imm = #0xcd7c
;             msg += 4;
700a0834: 9804         	ldr	r0, [sp, #0x10]
700a0836: 3004         	adds	r0, #0x4
700a0838: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a083a: 9801         	ldr	r0, [sp, #0x4]
700a083c: 3004         	adds	r0, #0x4
700a083e: 9001         	str	r0, [sp, #0x4]
;         }
700a0840: e7ff         	b	0x700a0842 <Sciclient_sendMessage+0xe2> @ imm = #-0x2
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a0842: 9805         	ldr	r0, [sp, #0x14]
700a0844: 3001         	adds	r0, #0x1
700a0846: 9005         	str	r0, [sp, #0x14]
700a0848: e7e7         	b	0x700a081a <Sciclient_sendMessage+0xba> @ imm = #-0x32
;     }
700a084a: e7ff         	b	0x700a084c <Sciclient_sendMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a084c: f240 2020    	movw	r0, #0x220
700a0850: f2c7 000b    	movt	r0, #0x700b
700a0854: 7801         	ldrb	r1, [r0]
700a0856: 980c         	ldr	r0, [sp, #0x30]
700a0858: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a085c: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a085e: f240 1138    	movw	r1, #0x138
700a0862: f2c7 010b    	movt	r1, #0x700b
700a0866: 6949         	ldr	r1, [r1, #0x14]
700a0868: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a086a: 4288         	cmp	r0, r1
700a086c: d817         	bhi	0x700a089e <Sciclient_sendMessage+0x13e> @ imm = #0x2e
700a086e: e7ff         	b	0x700a0870 <Sciclient_sendMessage+0x110> @ imm = #-0x2
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a0870: 9909         	ldr	r1, [sp, #0x24]
700a0872: f240 00e8    	movw	r0, #0xe8
700a0876: f2c7 000b    	movt	r0, #0x700b
700a087a: 2200         	movs	r2, #0x0
700a087c: 9200         	str	r2, [sp]
700a087e: f00c fc2f    	bl	0x700ad0e0 <CSL_secProxyGetDataAddr> @ imm = #0xc85e
700a0882: 9900         	ldr	r1, [sp]
700a0884: 4602         	mov	r2, r0
;         ((uintptr_t) gSciclientHandle.maxMsgSizeBytes  - (uintptr_t) 4U) ;
700a0886: f240 1038    	movw	r0, #0x138
700a088a: f2c7 000b    	movt	r0, #0x700b
700a088e: 6940         	ldr	r0, [r0, #0x14]
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a0890: 4410         	add	r0, r2
700a0892: 3804         	subs	r0, #0x4
700a0894: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(threadAddr,0U);
700a0896: 9801         	ldr	r0, [sp, #0x4]
700a0898: f00c fe8a    	bl	0x700ad5b0 <CSL_REG32_WR_RAW> @ imm = #0xcd14
;     }
700a089c: e7ff         	b	0x700a089e <Sciclient_sendMessage+0x13e> @ imm = #-0x2
; }
700a089e: b00a         	add	sp, #0x28
700a08a0: bd80         	pop	{r7, pc}
		...
700a08ae: 0000         	movs	r0, r0

700a08b0 <Sciclient_rmIaValidateMapping>:
; {
700a08b0: b580         	push	{r7, lr}
700a08b2: b088         	sub	sp, #0x20
700a08b4: 4684         	mov	r12, r0
700a08b6: 980a         	ldr	r0, [sp, #0x28]
700a08b8: f88d c01f    	strb.w	r12, [sp, #0x1f]
700a08bc: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a08c0: f8ad 201a    	strh.w	r2, [sp, #0x1a]
700a08c4: f8ad 3018    	strh.w	r3, [sp, #0x18]
700a08c8: f88d 0017    	strb.w	r0, [sp, #0x17]
700a08cc: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a08ce: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700a08d0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700a08d2: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a08d6: f009 fd83    	bl	0x700aa3e0 <Sciclient_rmIaGetInst> @ imm = #0x9b06
700a08da: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a08dc: 9803         	ldr	r0, [sp, #0xc]
700a08de: b920         	cbnz	r0, 0x700a08ea <Sciclient_rmIaValidateMapping+0x3a> @ imm = #0x8
700a08e0: e7ff         	b	0x700a08e2 <Sciclient_rmIaValidateMapping+0x32> @ imm = #-0x2
700a08e2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a08e6: 9004         	str	r0, [sp, #0x10]
;     } else {
700a08e8: e00b         	b	0x700a0902 <Sciclient_rmIaValidateMapping+0x52> @ imm = #0x16
;         if (vint >= inst->n_vint) {
700a08ea: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a08ee: 9903         	ldr	r1, [sp, #0xc]
700a08f0: 8989         	ldrh	r1, [r1, #0xc]
700a08f2: 4288         	cmp	r0, r1
700a08f4: db04         	blt	0x700a0900 <Sciclient_rmIaValidateMapping+0x50> @ imm = #0x8
700a08f6: e7ff         	b	0x700a08f8 <Sciclient_rmIaValidateMapping+0x48> @ imm = #-0x2
700a08f8: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a08fc: 9004         	str	r0, [sp, #0x10]
;         }
700a08fe: e7ff         	b	0x700a0900 <Sciclient_rmIaValidateMapping+0x50> @ imm = #-0x2
700a0900: e7ff         	b	0x700a0902 <Sciclient_rmIaValidateMapping+0x52> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (vint_sb_index >= SCICLIENT_IA_VINT_MAX_BITS)) {
700a0902: 9804         	ldr	r0, [sp, #0x10]
700a0904: b948         	cbnz	r0, 0x700a091a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x12
700a0906: e7ff         	b	0x700a0908 <Sciclient_rmIaValidateMapping+0x58> @ imm = #-0x2
700a0908: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a090c: 2840         	cmp	r0, #0x40
700a090e: d304         	blo	0x700a091a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x8
700a0910: e7ff         	b	0x700a0912 <Sciclient_rmIaValidateMapping+0x62> @ imm = #-0x2
700a0912: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0916: 9004         	str	r0, [sp, #0x10]
;     }
700a0918: e7ff         	b	0x700a091a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a091a: 9804         	ldr	r0, [sp, #0x10]
700a091c: b998         	cbnz	r0, 0x700a0946 <Sciclient_rmIaValidateMapping+0x96> @ imm = #0x26
700a091e: e7ff         	b	0x700a0920 <Sciclient_rmIaValidateMapping+0x70> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700a0920: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a0924: 9903         	ldr	r1, [sp, #0xc]
700a0926: 8909         	ldrh	r1, [r1, #0x8]
700a0928: 1a40         	subs	r0, r0, r1
700a092a: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         if (evt >= inst->n_sevt) {
700a092e: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a0932: 9903         	ldr	r1, [sp, #0xc]
700a0934: 8949         	ldrh	r1, [r1, #0xa]
700a0936: 4288         	cmp	r0, r1
700a0938: db04         	blt	0x700a0944 <Sciclient_rmIaValidateMapping+0x94> @ imm = #0x8
700a093a: e7ff         	b	0x700a093c <Sciclient_rmIaValidateMapping+0x8c> @ imm = #-0x2
700a093c: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a0940: 9004         	str	r0, [sp, #0x10]
;         }
700a0942: e7ff         	b	0x700a0944 <Sciclient_rmIaValidateMapping+0x94> @ imm = #-0x2
;     }
700a0944: e7ff         	b	0x700a0946 <Sciclient_rmIaValidateMapping+0x96> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a0946: 9804         	ldr	r0, [sp, #0x10]
700a0948: 2800         	cmp	r0, #0x0
700a094a: d14e         	bne	0x700a09ea <Sciclient_rmIaValidateMapping+0x13a> @ imm = #0x9c
700a094c: e7ff         	b	0x700a094e <Sciclient_rmIaValidateMapping+0x9e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a094e: 9803         	ldr	r0, [sp, #0xc]
700a0950: 6840         	ldr	r0, [r0, #0x4]
700a0952: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a0956: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a095a: 9001         	str	r0, [sp, #0x4]
;         reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a095c: 9801         	ldr	r0, [sp, #0x4]
700a095e: f64f 7100    	movw	r1, #0xff00
700a0962: f2c0 0101    	movt	r1, #0x1
700a0966: 2208         	movs	r2, #0x8
700a0968: f00c f9ea    	bl	0x700acd40 <CSL_REG32_FEXT_RAW> @ imm = #0xc3d4
700a096c: f8ad 0002    	strh.w	r0, [sp, #0x2]
;         reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a0970: 9801         	ldr	r0, [sp, #0x4]
700a0972: 213f         	movs	r1, #0x3f
700a0974: 2200         	movs	r2, #0x0
700a0976: f00c f9e3    	bl	0x700acd40 <CSL_REG32_FEXT_RAW> @ imm = #0xc3c6
700a097a: f8ad 0000    	strh.w	r0, [sp]
;         if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a097e: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a0982: b9f0         	cbnz	r0, 0x700a09c2 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x3c
700a0984: e7ff         	b	0x700a0986 <Sciclient_rmIaValidateMapping+0xd6> @ imm = #-0x2
700a0986: f8bd 0000    	ldrh.w	r0, [sp]
700a098a: b9d0         	cbnz	r0, 0x700a09c2 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x34
700a098c: e7ff         	b	0x700a098e <Sciclient_rmIaValidateMapping+0xde> @ imm = #-0x2
;             if ((vint != reg_vint) &&
700a098e: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a0992: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a0996: 4288         	cmp	r0, r1
700a0998: d012         	beq	0x700a09c0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x24
700a099a: e7ff         	b	0x700a099c <Sciclient_rmIaValidateMapping+0xec> @ imm = #-0x2
;                 (vint_sb_index != reg_sb) &&
700a099c: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a09a0: f8bd 1000    	ldrh.w	r1, [sp]
700a09a4: 4288         	cmp	r0, r1
700a09a6: d00b         	beq	0x700a09c0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x16
700a09a8: e7ff         	b	0x700a09aa <Sciclient_rmIaValidateMapping+0xfa> @ imm = #-0x2
;                 (evt != inst->v0_b0_evt)) {
700a09aa: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a09ae: 9903         	ldr	r1, [sp, #0xc]
700a09b0: 8a89         	ldrh	r1, [r1, #0x14]
;             if ((vint != reg_vint) &&
700a09b2: 4288         	cmp	r0, r1
700a09b4: d004         	beq	0x700a09c0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x8
700a09b6: e7ff         	b	0x700a09b8 <Sciclient_rmIaValidateMapping+0x108> @ imm = #-0x2
700a09b8: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a09bc: 9004         	str	r0, [sp, #0x10]
;             }
700a09be: e7ff         	b	0x700a09c0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #-0x2
;         } else {
700a09c0: e012         	b	0x700a09e8 <Sciclient_rmIaValidateMapping+0x138> @ imm = #0x24
;             if ((vint != reg_vint) &&
700a09c2: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a09c6: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a09ca: 4288         	cmp	r0, r1
700a09cc: d00b         	beq	0x700a09e6 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x16
700a09ce: e7ff         	b	0x700a09d0 <Sciclient_rmIaValidateMapping+0x120> @ imm = #-0x2
;                 (vint_sb_index != reg_sb)) {
700a09d0: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a09d4: f8bd 1000    	ldrh.w	r1, [sp]
;             if ((vint != reg_vint) &&
700a09d8: 4288         	cmp	r0, r1
700a09da: d004         	beq	0x700a09e6 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x8
700a09dc: e7ff         	b	0x700a09de <Sciclient_rmIaValidateMapping+0x12e> @ imm = #-0x2
700a09de: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a09e2: 9004         	str	r0, [sp, #0x10]
;             }
700a09e4: e7ff         	b	0x700a09e6 <Sciclient_rmIaValidateMapping+0x136> @ imm = #-0x2
700a09e6: e7ff         	b	0x700a09e8 <Sciclient_rmIaValidateMapping+0x138> @ imm = #-0x2
;     }
700a09e8: e7ff         	b	0x700a09ea <Sciclient_rmIaValidateMapping+0x13a> @ imm = #-0x2
;     return r;
700a09ea: 9804         	ldr	r0, [sp, #0x10]
700a09ec: b008         	add	sp, #0x20
700a09ee: bd80         	pop	{r7, pc}

700a09f0 <Udma_rmAllocMappedRing>:
; {
700a09f0: b580         	push	{r7, lr}
700a09f2: b090         	sub	sp, #0x40
700a09f4: 900f         	str	r0, [sp, #0x3c]
700a09f6: 910e         	str	r1, [sp, #0x38]
700a09f8: 920d         	str	r2, [sp, #0x34]
700a09fa: f64f 70ff    	movw	r0, #0xffff
;     uint32_t    ringNum = UDMA_RING_INVALID;
700a09fe: 900c         	str	r0, [sp, #0x30]
700a0a00: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a0a02: 9005         	str	r0, [sp, #0x14]
;     Udma_RmInitPrms             *rmInitPrms = &drvHandle->rmInitPrms;
700a0a04: 980f         	ldr	r0, [sp, #0x3c]
700a0a06: f500 70ea    	add.w	r0, r0, #0x1d4
700a0a0a: 9004         	str	r0, [sp, #0x10]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a0a0c: 980f         	ldr	r0, [sp, #0x3c]
700a0a0e: 990e         	ldr	r1, [sp, #0x38]
700a0a10: 9a0d         	ldr	r2, [sp, #0x34]
700a0a12: ab01         	add	r3, sp, #0x4
700a0a14: f005 f91c    	bl	0x700a5c50 <Udma_getMappedChRingAttributes> @ imm = #0x5238
700a0a18: 9005         	str	r0, [sp, #0x14]
;     if(UDMA_SOK == retVal)
700a0a1a: 9805         	ldr	r0, [sp, #0x14]
700a0a1c: 2800         	cmp	r0, #0x0
700a0a1e: f040 8084    	bne.w	0x700a0b2a <Udma_rmAllocMappedRing+0x13a> @ imm = #0x108
700a0a22: e7ff         	b	0x700a0a24 <Udma_rmAllocMappedRing+0x34> @ imm = #-0x2
700a0a24: 2000         	movs	r0, #0x0
;         loopStart = 0;
700a0a26: 9007         	str	r0, [sp, #0x1c]
;         loopMax   = rmInitPrms->numMappedRing[mappedRingGrp];
700a0a28: 9804         	ldr	r0, [sp, #0x10]
700a0a2a: 990e         	ldr	r1, [sp, #0x38]
700a0a2c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0a30: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
700a0a34: 9006         	str	r0, [sp, #0x18]
;         if(chAttr.startFreeRing > rmInitPrms->startMappedRing[mappedRingGrp])
700a0a36: 9802         	ldr	r0, [sp, #0x8]
700a0a38: 9904         	ldr	r1, [sp, #0x10]
700a0a3a: 9a0e         	ldr	r2, [sp, #0x38]
700a0a3c: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0a40: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a0a44: 4288         	cmp	r0, r1
700a0a46: d90a         	bls	0x700a0a5e <Udma_rmAllocMappedRing+0x6e> @ imm = #0x14
700a0a48: e7ff         	b	0x700a0a4a <Udma_rmAllocMappedRing+0x5a> @ imm = #-0x2
;             loopStart = chAttr.startFreeRing - rmInitPrms->startMappedRing[mappedRingGrp];
700a0a4a: 9802         	ldr	r0, [sp, #0x8]
700a0a4c: 9904         	ldr	r1, [sp, #0x10]
700a0a4e: 9a0e         	ldr	r2, [sp, #0x38]
700a0a50: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0a54: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a0a58: 1a40         	subs	r0, r0, r1
700a0a5a: 9007         	str	r0, [sp, #0x1c]
;         }
700a0a5c: e7ff         	b	0x700a0a5e <Udma_rmAllocMappedRing+0x6e> @ imm = #-0x2
;         if((chAttr.startFreeRing + chAttr.numFreeRing) < (rmInitPrms->startMappedRing[mappedRingGrp] + rmInitPrms->numMappedRing[mappedRingGrp]))
700a0a5e: 9802         	ldr	r0, [sp, #0x8]
700a0a60: 9903         	ldr	r1, [sp, #0xc]
700a0a62: 4408         	add	r0, r1
700a0a64: 9904         	ldr	r1, [sp, #0x10]
700a0a66: 9a0e         	ldr	r2, [sp, #0x38]
700a0a68: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a0a6c: f8d2 1088    	ldr.w	r1, [r2, #0x88]
700a0a70: f8d2 20a8    	ldr.w	r2, [r2, #0xa8]
700a0a74: 4411         	add	r1, r2
700a0a76: 4288         	cmp	r0, r1
700a0a78: d20c         	bhs	0x700a0a94 <Udma_rmAllocMappedRing+0xa4> @ imm = #0x18
700a0a7a: e7ff         	b	0x700a0a7c <Udma_rmAllocMappedRing+0x8c> @ imm = #-0x2
;             loopMax = (chAttr.startFreeRing + chAttr.numFreeRing) - rmInitPrms->startMappedRing[mappedRingGrp];
700a0a7c: 9802         	ldr	r0, [sp, #0x8]
700a0a7e: 9903         	ldr	r1, [sp, #0xc]
700a0a80: 4408         	add	r0, r1
700a0a82: 9904         	ldr	r1, [sp, #0x10]
700a0a84: 9a0e         	ldr	r2, [sp, #0x38]
700a0a86: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0a8a: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a0a8e: 1a40         	subs	r0, r0, r1
700a0a90: 9006         	str	r0, [sp, #0x18]
;         }
700a0a92: e7ff         	b	0x700a0a94 <Udma_rmAllocMappedRing+0xa4> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a0a94: 980f         	ldr	r0, [sp, #0x3c]
700a0a96: f500 609f    	add.w	r0, r0, #0x4f8
700a0a9a: f04f 31ff    	mov.w	r1, #0xffffffff
700a0a9e: f007 fe27    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x7c4e
;         for(i = loopStart; i < loopMax; i++)
700a0aa2: 9807         	ldr	r0, [sp, #0x1c]
700a0aa4: 900b         	str	r0, [sp, #0x2c]
700a0aa6: e7ff         	b	0x700a0aa8 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x2
700a0aa8: 980b         	ldr	r0, [sp, #0x2c]
700a0aaa: 9906         	ldr	r1, [sp, #0x18]
700a0aac: 4288         	cmp	r0, r1
700a0aae: d236         	bhs	0x700a0b1e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x6c
700a0ab0: e7ff         	b	0x700a0ab2 <Udma_rmAllocMappedRing+0xc2> @ imm = #-0x2
;             offset = i >> 5U;
700a0ab2: 980b         	ldr	r0, [sp, #0x2c]
700a0ab4: 0940         	lsrs	r0, r0, #0x5
700a0ab6: 900a         	str	r0, [sp, #0x28]
;             bitPos = i - (offset << 5U);
700a0ab8: 980b         	ldr	r0, [sp, #0x2c]
700a0aba: 990a         	ldr	r1, [sp, #0x28]
700a0abc: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a0ac0: 9009         	str	r0, [sp, #0x24]
;             bitMask = (uint32_t) 1U << bitPos;
700a0ac2: 9909         	ldr	r1, [sp, #0x24]
700a0ac4: 2001         	movs	r0, #0x1
700a0ac6: 4088         	lsls	r0, r1
700a0ac8: 9008         	str	r0, [sp, #0x20]
;             if((drvHandle->mappedRingFlag[mappedRingGrp][offset] & bitMask) == bitMask)
700a0aca: 980f         	ldr	r0, [sp, #0x3c]
700a0acc: 990e         	ldr	r1, [sp, #0x38]
700a0ace: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a0ad2: 990a         	ldr	r1, [sp, #0x28]
700a0ad4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a0ad8: f8d0 0344    	ldr.w	r0, [r0, #0x344]
700a0adc: 9908         	ldr	r1, [sp, #0x20]
700a0ade: 4008         	ands	r0, r1
700a0ae0: 4288         	cmp	r0, r1
700a0ae2: d117         	bne	0x700a0b14 <Udma_rmAllocMappedRing+0x124> @ imm = #0x2e
700a0ae4: e7ff         	b	0x700a0ae6 <Udma_rmAllocMappedRing+0xf6> @ imm = #-0x2
;                 drvHandle->mappedRingFlag[mappedRingGrp][offset] &= ~bitMask;
700a0ae6: 9a08         	ldr	r2, [sp, #0x20]
700a0ae8: 980f         	ldr	r0, [sp, #0x3c]
700a0aea: 990e         	ldr	r1, [sp, #0x38]
700a0aec: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a0af0: 990a         	ldr	r1, [sp, #0x28]
700a0af2: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a0af6: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a0afa: 4390         	bics	r0, r2
700a0afc: f8c1 0344    	str.w	r0, [r1, #0x344]
;                 ringNum = i + rmInitPrms->startMappedRing[mappedRingGrp];  /* Add start offset */
700a0b00: 980b         	ldr	r0, [sp, #0x2c]
700a0b02: 9904         	ldr	r1, [sp, #0x10]
700a0b04: 9a0e         	ldr	r2, [sp, #0x38]
700a0b06: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0b0a: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a0b0e: 4408         	add	r0, r1
700a0b10: 900c         	str	r0, [sp, #0x30]
;                 break;
700a0b12: e004         	b	0x700a0b1e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x8
;         }
700a0b14: e7ff         	b	0x700a0b16 <Udma_rmAllocMappedRing+0x126> @ imm = #-0x2
;         for(i = loopStart; i < loopMax; i++)
700a0b16: 980b         	ldr	r0, [sp, #0x2c]
700a0b18: 3001         	adds	r0, #0x1
700a0b1a: 900b         	str	r0, [sp, #0x2c]
700a0b1c: e7c4         	b	0x700a0aa8 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x78
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a0b1e: 980f         	ldr	r0, [sp, #0x3c]
700a0b20: f500 609f    	add.w	r0, r0, #0x4f8
700a0b24: f009 f934    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x9268
;     }
700a0b28: e7ff         	b	0x700a0b2a <Udma_rmAllocMappedRing+0x13a> @ imm = #-0x2
;     return (ringNum);
700a0b2a: 980c         	ldr	r0, [sp, #0x30]
700a0b2c: b010         	add	sp, #0x40
700a0b2e: bd80         	pop	{r7, pc}

700a0b30 <xTaskResumeAll>:
; BaseType_t xTaskResumeAll(void) {
700a0b30: b580         	push	{r7, lr}
700a0b32: b084         	sub	sp, #0x10
700a0b34: 2000         	movs	r0, #0x0
;   TCB_t *pxTCB = NULL;
700a0b36: 9003         	str	r0, [sp, #0xc]
;   BaseType_t xAlreadyYielded = pdFALSE;
700a0b38: 9002         	str	r0, [sp, #0x8]
;   taskENTER_CRITICAL();
700a0b3a: f00b fc59    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0xb8b2
;     --uxSchedulerSuspended;
700a0b3e: f240 10f0    	movw	r0, #0x1f0
700a0b42: f2c7 000b    	movt	r0, #0x700b
700a0b46: 6801         	ldr	r1, [r0]
700a0b48: 3901         	subs	r1, #0x1
700a0b4a: 6001         	str	r1, [r0]
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a0b4c: 6800         	ldr	r0, [r0]
700a0b4e: 2800         	cmp	r0, #0x0
700a0b50: f040 8088    	bne.w	0x700a0c64 <xTaskResumeAll+0x134> @ imm = #0x110
700a0b54: e7ff         	b	0x700a0b56 <xTaskResumeAll+0x26> @ imm = #-0x2
;       if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
700a0b56: f240 10e8    	movw	r0, #0x1e8
700a0b5a: f2c7 000b    	movt	r0, #0x700b
700a0b5e: 6800         	ldr	r0, [r0]
700a0b60: 2800         	cmp	r0, #0x0
700a0b62: f000 807e    	beq.w	0x700a0c62 <xTaskResumeAll+0x132> @ imm = #0xfc
700a0b66: e7ff         	b	0x700a0b68 <xTaskResumeAll+0x38> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a0b68: e7ff         	b	0x700a0b6a <xTaskResumeAll+0x3a> @ imm = #-0x2
700a0b6a: f644 7068    	movw	r0, #0x4f68
700a0b6e: f2c7 0008    	movt	r0, #0x7008
700a0b72: 6800         	ldr	r0, [r0]
700a0b74: b3e0         	cbz	r0, 0x700a0bf0 <xTaskResumeAll+0xc0> @ imm = #0x78
700a0b76: e7ff         	b	0x700a0b78 <xTaskResumeAll+0x48> @ imm = #-0x2
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a0b78: f644 7068    	movw	r0, #0x4f68
700a0b7c: f2c7 0008    	movt	r0, #0x7008
700a0b80: 68c0         	ldr	r0, [r0, #0xc]
700a0b82: 68c0         	ldr	r0, [r0, #0xc]
700a0b84: 9003         	str	r0, [sp, #0xc]
;           (void)uxListRemove(&(pxTCB->xEventListItem));
700a0b86: 9803         	ldr	r0, [sp, #0xc]
700a0b88: 3018         	adds	r0, #0x18
700a0b8a: f00a fc69    	bl	0x700ab460 <uxListRemove> @ imm = #0xa8d2
;           (void)uxListRemove(&(pxTCB->xStateListItem));
700a0b8e: 9803         	ldr	r0, [sp, #0xc]
700a0b90: 3004         	adds	r0, #0x4
700a0b92: f00a fc65    	bl	0x700ab460 <uxListRemove> @ imm = #0xa8ca
;           prvAddTaskToReadyList(pxTCB);
700a0b96: 9803         	ldr	r0, [sp, #0xc]
700a0b98: 6ac1         	ldr	r1, [r0, #0x2c]
700a0b9a: 2001         	movs	r0, #0x1
700a0b9c: fa00 f201    	lsl.w	r2, r0, r1
700a0ba0: f240 11f8    	movw	r1, #0x1f8
700a0ba4: f2c7 010b    	movt	r1, #0x700b
700a0ba8: 6808         	ldr	r0, [r1]
700a0baa: 4310         	orrs	r0, r2
700a0bac: 6008         	str	r0, [r1]
700a0bae: 9903         	ldr	r1, [sp, #0xc]
700a0bb0: 6ac8         	ldr	r0, [r1, #0x2c]
700a0bb2: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a0bb6: f244 40f8    	movw	r0, #0x44f8
700a0bba: f2c7 0008    	movt	r0, #0x7008
700a0bbe: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a0bc2: 3104         	adds	r1, #0x4
700a0bc4: f00b f9bc    	bl	0x700abf40 <vListInsertEnd> @ imm = #0xb378
;           if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a0bc8: 9803         	ldr	r0, [sp, #0xc]
700a0bca: 6ac0         	ldr	r0, [r0, #0x2c]
700a0bcc: f240 11cc    	movw	r1, #0x1cc
700a0bd0: f2c7 010b    	movt	r1, #0x700b
700a0bd4: 6809         	ldr	r1, [r1]
700a0bd6: 6ac9         	ldr	r1, [r1, #0x2c]
700a0bd8: 4288         	cmp	r0, r1
700a0bda: d307         	blo	0x700a0bec <xTaskResumeAll+0xbc> @ imm = #0xe
700a0bdc: e7ff         	b	0x700a0bde <xTaskResumeAll+0xae> @ imm = #-0x2
;             xYieldPending = pdTRUE;
700a0bde: f240 211c    	movw	r1, #0x21c
700a0be2: f2c7 010b    	movt	r1, #0x700b
700a0be6: 2001         	movs	r0, #0x1
700a0be8: 6008         	str	r0, [r1]
;           } else {
700a0bea: e000         	b	0x700a0bee <xTaskResumeAll+0xbe> @ imm = #0x0
700a0bec: e7ff         	b	0x700a0bee <xTaskResumeAll+0xbe> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a0bee: e7bc         	b	0x700a0b6a <xTaskResumeAll+0x3a> @ imm = #-0x88
;         if (pxTCB != NULL) {
700a0bf0: 9803         	ldr	r0, [sp, #0xc]
700a0bf2: b118         	cbz	r0, 0x700a0bfc <xTaskResumeAll+0xcc> @ imm = #0x6
700a0bf4: e7ff         	b	0x700a0bf6 <xTaskResumeAll+0xc6> @ imm = #-0x2
;           prvResetNextTaskUnblockTime();
700a0bf6: f00b f943    	bl	0x700abe80 <prvResetNextTaskUnblockTime> @ imm = #0xb286
;         }
700a0bfa: e7ff         	b	0x700a0bfc <xTaskResumeAll+0xcc> @ imm = #-0x2
;           TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
700a0bfc: f240 2008    	movw	r0, #0x208
700a0c00: f2c7 000b    	movt	r0, #0x700b
700a0c04: 6800         	ldr	r0, [r0]
700a0c06: 9001         	str	r0, [sp, #0x4]
;           if (xPendedCounts > (TickType_t)0U) {
700a0c08: 9801         	ldr	r0, [sp, #0x4]
700a0c0a: b1e0         	cbz	r0, 0x700a0c46 <xTaskResumeAll+0x116> @ imm = #0x38
700a0c0c: e7ff         	b	0x700a0c0e <xTaskResumeAll+0xde> @ imm = #-0x2
;             do {
700a0c0e: e7ff         	b	0x700a0c10 <xTaskResumeAll+0xe0> @ imm = #-0x2
;               if (xTaskIncrementTick() != pdFALSE) {
700a0c10: f7ff f836    	bl	0x7009fc80 <xTaskIncrementTick> @ imm = #-0xf94
700a0c14: b138         	cbz	r0, 0x700a0c26 <xTaskResumeAll+0xf6> @ imm = #0xe
700a0c16: e7ff         	b	0x700a0c18 <xTaskResumeAll+0xe8> @ imm = #-0x2
;                 xYieldPending = pdTRUE;
700a0c18: f240 211c    	movw	r1, #0x21c
700a0c1c: f2c7 010b    	movt	r1, #0x700b
700a0c20: 2001         	movs	r0, #0x1
700a0c22: 6008         	str	r0, [r1]
;               } else {
700a0c24: e000         	b	0x700a0c28 <xTaskResumeAll+0xf8> @ imm = #0x0
700a0c26: e7ff         	b	0x700a0c28 <xTaskResumeAll+0xf8> @ imm = #-0x2
;               --xPendedCounts;
700a0c28: 9801         	ldr	r0, [sp, #0x4]
700a0c2a: 3801         	subs	r0, #0x1
700a0c2c: 9001         	str	r0, [sp, #0x4]
;             } while (xPendedCounts > (TickType_t)0U);
700a0c2e: e7ff         	b	0x700a0c30 <xTaskResumeAll+0x100> @ imm = #-0x2
700a0c30: 9801         	ldr	r0, [sp, #0x4]
700a0c32: 2800         	cmp	r0, #0x0
700a0c34: d1ec         	bne	0x700a0c10 <xTaskResumeAll+0xe0> @ imm = #-0x28
700a0c36: e7ff         	b	0x700a0c38 <xTaskResumeAll+0x108> @ imm = #-0x2
;             xPendedTicks = 0;
700a0c38: f240 2108    	movw	r1, #0x208
700a0c3c: f2c7 010b    	movt	r1, #0x700b
700a0c40: 2000         	movs	r0, #0x0
700a0c42: 6008         	str	r0, [r1]
;           } else {
700a0c44: e000         	b	0x700a0c48 <xTaskResumeAll+0x118> @ imm = #0x0
700a0c46: e7ff         	b	0x700a0c48 <xTaskResumeAll+0x118> @ imm = #-0x2
;         if (xYieldPending != pdFALSE) {
700a0c48: f240 201c    	movw	r0, #0x21c
700a0c4c: f2c7 000b    	movt	r0, #0x700b
700a0c50: 6800         	ldr	r0, [r0]
700a0c52: b120         	cbz	r0, 0x700a0c5e <xTaskResumeAll+0x12e> @ imm = #0x8
700a0c54: e7ff         	b	0x700a0c56 <xTaskResumeAll+0x126> @ imm = #-0x2
700a0c56: 2001         	movs	r0, #0x1
;             xAlreadyYielded = pdTRUE;
700a0c58: 9002         	str	r0, [sp, #0x8]
;           taskYIELD_IF_USING_PREEMPTION();
700a0c5a: df00         	svc	#0x0
;         } else {
700a0c5c: e000         	b	0x700a0c60 <xTaskResumeAll+0x130> @ imm = #0x0
700a0c5e: e7ff         	b	0x700a0c60 <xTaskResumeAll+0x130> @ imm = #-0x2
;       }
700a0c60: e7ff         	b	0x700a0c62 <xTaskResumeAll+0x132> @ imm = #-0x2
;     } else {
700a0c62: e000         	b	0x700a0c66 <xTaskResumeAll+0x136> @ imm = #0x0
700a0c64: e7ff         	b	0x700a0c66 <xTaskResumeAll+0x136> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a0c66: f00a fcc3    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xa986
;   return xAlreadyYielded;
700a0c6a: 9802         	ldr	r0, [sp, #0x8]
700a0c6c: b004         	add	sp, #0x10
700a0c6e: bd80         	pop	{r7, pc}

700a0c70 <UART_procLineStatusErr>:
; {
700a0c70: b580         	push	{r7, lr}
700a0c72: b086         	sub	sp, #0x18
700a0c74: 9005         	str	r0, [sp, #0x14]
700a0c76: 2000         	movs	r0, #0x0
;     int32_t            status = UART_STATUS_SUCCESS;
700a0c78: 9004         	str	r0, [sp, #0x10]
;     uint32_t           lineStatus, iteration = 0U;
700a0c7a: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == hUart)
700a0c7c: 9805         	ldr	r0, [sp, #0x14]
700a0c7e: b920         	cbnz	r0, 0x700a0c8a <UART_procLineStatusErr+0x1a> @ imm = #0x8
700a0c80: e7ff         	b	0x700a0c82 <UART_procLineStatusErr+0x12> @ imm = #-0x2
700a0c82: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a0c86: 9004         	str	r0, [sp, #0x10]
;     }
700a0c88: e7ff         	b	0x700a0c8a <UART_procLineStatusErr+0x1a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a0c8a: 9804         	ldr	r0, [sp, #0x10]
700a0c8c: 2800         	cmp	r0, #0x0
700a0c8e: f040 808b    	bne.w	0x700a0da8 <UART_procLineStatusErr+0x138> @ imm = #0x116
700a0c92: e7ff         	b	0x700a0c94 <UART_procLineStatusErr+0x24> @ imm = #-0x2
;         lineStatus = UART_readLineStatus(hUart->baseAddr);
700a0c94: 9805         	ldr	r0, [sp, #0x14]
700a0c96: 6800         	ldr	r0, [r0]
700a0c98: f00a fc82    	bl	0x700ab5a0 <UART_readLineStatus> @ imm = #0xa904
700a0c9c: 9003         	str	r0, [sp, #0xc]
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a0c9e: 9803         	ldr	r0, [sp, #0xc]
700a0ca0: f000 0080    	and	r0, r0, #0x80
;                 || ((lineStatus & UART_OVERRUN_ERROR) == UART_OVERRUN_ERROR))
700a0ca4: 2880         	cmp	r0, #0x80
700a0ca6: d006         	beq	0x700a0cb6 <UART_procLineStatusErr+0x46> @ imm = #0xc
700a0ca8: e7ff         	b	0x700a0caa <UART_procLineStatusErr+0x3a> @ imm = #-0x2
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a0caa: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a0cae: 0780         	lsls	r0, r0, #0x1e
700a0cb0: 2800         	cmp	r0, #0x0
700a0cb2: d578         	bpl	0x700a0da6 <UART_procLineStatusErr+0x136> @ imm = #0xf0
700a0cb4: e7ff         	b	0x700a0cb6 <UART_procLineStatusErr+0x46> @ imm = #-0x2
;             if (hUart->readTrans.buf != NULL)
700a0cb6: 9805         	ldr	r0, [sp, #0x14]
700a0cb8: 6a80         	ldr	r0, [r0, #0x28]
700a0cba: b120         	cbz	r0, 0x700a0cc6 <UART_procLineStatusErr+0x56> @ imm = #0x8
700a0cbc: e7ff         	b	0x700a0cbe <UART_procLineStatusErr+0x4e> @ imm = #-0x2
;                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
700a0cbe: 9905         	ldr	r1, [sp, #0x14]
700a0cc0: 6988         	ldr	r0, [r1, #0x18]
700a0cc2: 62c8         	str	r0, [r1, #0x2c]
;             }
700a0cc4: e7ff         	b	0x700a0cc6 <UART_procLineStatusErr+0x56> @ imm = #-0x2
700a0cc6: 2040         	movs	r0, #0x40
;             iteration = UART_FIFO_SIZE;
700a0cc8: 9002         	str	r0, [sp, #0x8]
;             do
700a0cca: e7ff         	b	0x700a0ccc <UART_procLineStatusErr+0x5c> @ imm = #-0x2
;                 (void)UART_fifoCharGet(hUart->baseAddr);
700a0ccc: 9805         	ldr	r0, [sp, #0x14]
700a0cce: 6800         	ldr	r0, [r0]
700a0cd0: f00c fa56    	bl	0x700ad180 <UART_fifoCharGet> @ imm = #0xc4ac
;                 iteration--;
700a0cd4: 9802         	ldr	r0, [sp, #0x8]
700a0cd6: 3801         	subs	r0, #0x1
700a0cd8: 9002         	str	r0, [sp, #0x8]
;                 lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a0cda: 9805         	ldr	r0, [sp, #0x14]
700a0cdc: 6800         	ldr	r0, [r0]
700a0cde: f00a fc5f    	bl	0x700ab5a0 <UART_readLineStatus> @ imm = #0xa8be
700a0ce2: 9003         	str	r0, [sp, #0xc]
;                 lineStatus &= (UART_LSR_RX_FIFO_STS_MASK |
700a0ce4: 9803         	ldr	r0, [sp, #0xc]
700a0ce6: f000 009f    	and	r0, r0, #0x9f
700a0cea: 9003         	str	r0, [sp, #0xc]
;             }
700a0cec: e7ff         	b	0x700a0cee <UART_procLineStatusErr+0x7e> @ imm = #-0x2
;             while ((lineStatus != 0U) && (iteration != 0U));
700a0cee: 9903         	ldr	r1, [sp, #0xc]
700a0cf0: 2000         	movs	r0, #0x0
700a0cf2: 9001         	str	r0, [sp, #0x4]
700a0cf4: b131         	cbz	r1, 0x700a0d04 <UART_procLineStatusErr+0x94> @ imm = #0xc
700a0cf6: e7ff         	b	0x700a0cf8 <UART_procLineStatusErr+0x88> @ imm = #-0x2
700a0cf8: 9802         	ldr	r0, [sp, #0x8]
700a0cfa: 2800         	cmp	r0, #0x0
700a0cfc: bf18         	it	ne
700a0cfe: 2001         	movne	r0, #0x1
700a0d00: 9001         	str	r0, [sp, #0x4]
700a0d02: e7ff         	b	0x700a0d04 <UART_procLineStatusErr+0x94> @ imm = #-0x2
700a0d04: 9801         	ldr	r0, [sp, #0x4]
;             }
700a0d06: 07c0         	lsls	r0, r0, #0x1f
700a0d08: 2800         	cmp	r0, #0x0
700a0d0a: d1df         	bne	0x700a0ccc <UART_procLineStatusErr+0x5c> @ imm = #-0x42
700a0d0c: e7ff         	b	0x700a0d0e <UART_procLineStatusErr+0x9e> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a0d0e: 9805         	ldr	r0, [sp, #0x14]
700a0d10: 6800         	ldr	r0, [r0]
700a0d12: 2105         	movs	r1, #0x5
700a0d14: f003 fb34    	bl	0x700a4380 <UART_intrDisable> @ imm = #0x3668
;             hUart->readBuf = (void *)((uint8_t *)hUart->readBuf - hUart->readCount);
700a0d18: 9905         	ldr	r1, [sp, #0x14]
700a0d1a: 6948         	ldr	r0, [r1, #0x14]
700a0d1c: 698a         	ldr	r2, [r1, #0x18]
700a0d1e: 1a80         	subs	r0, r0, r2
700a0d20: 6148         	str	r0, [r1, #0x14]
;             if (hUart->readTrans.buf != NULL)
700a0d22: 9805         	ldr	r0, [sp, #0x14]
700a0d24: 6a80         	ldr	r0, [r0, #0x28]
700a0d26: b3a8         	cbz	r0, 0x700a0d94 <UART_procLineStatusErr+0x124> @ imm = #0x6a
700a0d28: e7ff         	b	0x700a0d2a <UART_procLineStatusErr+0xba> @ imm = #-0x2
;                 if ((lineStatus & UART_BREAK_DETECTED_ERROR) != 0U)
700a0d2a: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a0d2e: 06c0         	lsls	r0, r0, #0x1b
700a0d30: 2800         	cmp	r0, #0x0
700a0d32: d508         	bpl	0x700a0d46 <UART_procLineStatusErr+0xd6> @ imm = #0x10
700a0d34: e7ff         	b	0x700a0d36 <UART_procLineStatusErr+0xc6> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_BI;
700a0d36: 9905         	ldr	r1, [sp, #0x14]
700a0d38: 2002         	movs	r0, #0x2
700a0d3a: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a0d3c: 9905         	ldr	r1, [sp, #0x14]
700a0d3e: 6a48         	ldr	r0, [r1, #0x24]
700a0d40: 3001         	adds	r0, #0x1
700a0d42: 6248         	str	r0, [r1, #0x24]
;                 }
700a0d44: e025         	b	0x700a0d92 <UART_procLineStatusErr+0x122> @ imm = #0x4a
;                 else if ((lineStatus & UART_FRAMING_ERROR) != 0U)
700a0d46: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a0d4a: 0700         	lsls	r0, r0, #0x1c
700a0d4c: 2800         	cmp	r0, #0x0
700a0d4e: d508         	bpl	0x700a0d62 <UART_procLineStatusErr+0xf2> @ imm = #0x10
700a0d50: e7ff         	b	0x700a0d52 <UART_procLineStatusErr+0xe2> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_FE;
700a0d52: 9905         	ldr	r1, [sp, #0x14]
700a0d54: 2003         	movs	r0, #0x3
700a0d56: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a0d58: 9905         	ldr	r1, [sp, #0x14]
700a0d5a: 6a48         	ldr	r0, [r1, #0x24]
700a0d5c: 3001         	adds	r0, #0x1
700a0d5e: 6248         	str	r0, [r1, #0x24]
;                 }
700a0d60: e016         	b	0x700a0d90 <UART_procLineStatusErr+0x120> @ imm = #0x2c
;                 else if ((lineStatus & UART_PARITY_ERROR) != 0U)
700a0d62: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a0d66: 0740         	lsls	r0, r0, #0x1d
700a0d68: 2800         	cmp	r0, #0x0
700a0d6a: d508         	bpl	0x700a0d7e <UART_procLineStatusErr+0x10e> @ imm = #0x10
700a0d6c: e7ff         	b	0x700a0d6e <UART_procLineStatusErr+0xfe> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_PE;
700a0d6e: 9905         	ldr	r1, [sp, #0x14]
700a0d70: 2004         	movs	r0, #0x4
700a0d72: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a0d74: 9905         	ldr	r1, [sp, #0x14]
700a0d76: 6a48         	ldr	r0, [r1, #0x24]
700a0d78: 3001         	adds	r0, #0x1
700a0d7a: 6248         	str	r0, [r1, #0x24]
;                 }
700a0d7c: e007         	b	0x700a0d8e <UART_procLineStatusErr+0x11e> @ imm = #0xe
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OE;
700a0d7e: 9905         	ldr	r1, [sp, #0x14]
700a0d80: 2005         	movs	r0, #0x5
700a0d82: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a0d84: 9905         	ldr	r1, [sp, #0x14]
700a0d86: 6a48         	ldr	r0, [r1, #0x24]
700a0d88: 3001         	adds	r0, #0x1
700a0d8a: 6248         	str	r0, [r1, #0x24]
700a0d8c: e7ff         	b	0x700a0d8e <UART_procLineStatusErr+0x11e> @ imm = #-0x2
700a0d8e: e7ff         	b	0x700a0d90 <UART_procLineStatusErr+0x120> @ imm = #-0x2
700a0d90: e7ff         	b	0x700a0d92 <UART_procLineStatusErr+0x122> @ imm = #-0x2
;             }
700a0d92: e7ff         	b	0x700a0d94 <UART_procLineStatusErr+0x124> @ imm = #-0x2
;             hUart->hUartInit->errorCallbackFxn(hUart);
700a0d94: 9805         	ldr	r0, [sp, #0x14]
700a0d96: 6841         	ldr	r1, [r0, #0x4]
700a0d98: 6e49         	ldr	r1, [r1, #0x64]
700a0d9a: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a0d9c: 9805         	ldr	r0, [sp, #0x14]
700a0d9e: 3028         	adds	r0, #0x28
700a0da0: f00c f93e    	bl	0x700ad020 <UART_lld_Transaction_deInit> @ imm = #0xc27c
;         }
700a0da4: e7ff         	b	0x700a0da6 <UART_procLineStatusErr+0x136> @ imm = #-0x2
;     }
700a0da6: e7ff         	b	0x700a0da8 <UART_procLineStatusErr+0x138> @ imm = #-0x2
;     return status;
700a0da8: 9804         	ldr	r0, [sp, #0x10]
700a0daa: b006         	add	sp, #0x18
700a0dac: bd80         	pop	{r7, pc}
700a0dae: 0000         	movs	r0, r0

700a0db0 <prvProcessReceivedCommands>:
;     {
700a0db0: b580         	push	{r7, lr}
700a0db2: b08c         	sub	sp, #0x30
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a0db4: e7ff         	b	0x700a0db6 <prvProcessReceivedCommands+0x6> @ imm = #-0x2
700a0db6: f240 2014    	movw	r0, #0x214
700a0dba: f2c7 000b    	movt	r0, #0x700b
700a0dbe: 6800         	ldr	r0, [r0]
700a0dc0: a908         	add	r1, sp, #0x20
700a0dc2: 2200         	movs	r2, #0x0
700a0dc4: f000 fd6c    	bl	0x700a18a0 <xQueueReceive> @ imm = #0xad8
700a0dc8: 2800         	cmp	r0, #0x0
700a0dca: f000 808c    	beq.w	0x700a0ee6 <prvProcessReceivedCommands+0x136> @ imm = #0x118
700a0dce: e7ff         	b	0x700a0dd0 <prvProcessReceivedCommands+0x20> @ imm = #-0x2
;                     if( xMessage.xMessageID < ( BaseType_t ) 0 )
700a0dd0: 9808         	ldr	r0, [sp, #0x20]
700a0dd2: f1b0 3fff    	cmp.w	r0, #0xffffffff
700a0dd6: dc09         	bgt	0x700a0dec <prvProcessReceivedCommands+0x3c> @ imm = #0x12
700a0dd8: e7ff         	b	0x700a0dda <prvProcessReceivedCommands+0x2a> @ imm = #-0x2
700a0dda: a808         	add	r0, sp, #0x20
;                         const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
700a0ddc: 3004         	adds	r0, #0x4
700a0dde: 9003         	str	r0, [sp, #0xc]
;                         pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
700a0de0: 9903         	ldr	r1, [sp, #0xc]
700a0de2: 680a         	ldr	r2, [r1]
700a0de4: 6848         	ldr	r0, [r1, #0x4]
700a0de6: 6889         	ldr	r1, [r1, #0x8]
700a0de8: 4790         	blx	r2
;                     }
700a0dea: e000         	b	0x700a0dee <prvProcessReceivedCommands+0x3e> @ imm = #0x0
700a0dec: e7ff         	b	0x700a0dee <prvProcessReceivedCommands+0x3e> @ imm = #-0x2
;             if( xMessage.xMessageID >= ( BaseType_t ) 0 )
700a0dee: 9808         	ldr	r0, [sp, #0x20]
700a0df0: 2800         	cmp	r0, #0x0
700a0df2: f100 8077    	bmi.w	0x700a0ee4 <prvProcessReceivedCommands+0x134> @ imm = #0xee
700a0df6: e7ff         	b	0x700a0df8 <prvProcessReceivedCommands+0x48> @ imm = #-0x2
;                 pxTimer = xMessage.u.xTimerParameters.pxTimer;
700a0df8: 980a         	ldr	r0, [sp, #0x28]
700a0dfa: 9007         	str	r0, [sp, #0x1c]
;                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
700a0dfc: 9807         	ldr	r0, [sp, #0x1c]
700a0dfe: 6940         	ldr	r0, [r0, #0x14]
700a0e00: b128         	cbz	r0, 0x700a0e0e <prvProcessReceivedCommands+0x5e> @ imm = #0xa
700a0e02: e7ff         	b	0x700a0e04 <prvProcessReceivedCommands+0x54> @ imm = #-0x2
;                     ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a0e04: 9807         	ldr	r0, [sp, #0x1c]
700a0e06: 3004         	adds	r0, #0x4
700a0e08: f00a fb2a    	bl	0x700ab460 <uxListRemove> @ imm = #0xa654
;                 }
700a0e0c: e000         	b	0x700a0e10 <prvProcessReceivedCommands+0x60> @ imm = #0x0
700a0e0e: e7ff         	b	0x700a0e10 <prvProcessReceivedCommands+0x60> @ imm = #-0x2
700a0e10: a806         	add	r0, sp, #0x18
;                 xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700a0e12: f00a fc85    	bl	0x700ab720 <prvSampleTimeNow> @ imm = #0xa90a
700a0e16: 9004         	str	r0, [sp, #0x10]
;                 switch( xMessage.xMessageID )
700a0e18: 9808         	ldr	r0, [sp, #0x20]
700a0e1a: 9002         	str	r0, [sp, #0x8]
700a0e1c: 2809         	cmp	r0, #0x9
700a0e1e: d85f         	bhi	0x700a0ee0 <prvProcessReceivedCommands+0x130> @ imm = #0xbe
700a0e20: 9902         	ldr	r1, [sp, #0x8]
700a0e22: e8df f001    	tbb	[pc, r1]
700a0e26: 05 05 05 2f  	.word	0x2f050505
700a0e2a: 37 49 05 05  	.word	0x05054937
700a0e2e: 2f 37        	.short	0x372f
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a0e30: 9907         	ldr	r1, [sp, #0x1c]
700a0e32: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a0e36: f040 0001    	orr	r0, r0, #0x1
700a0e3a: f881 0028    	strb.w	r0, [r1, #0x28]
;                         if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
700a0e3e: 9807         	ldr	r0, [sp, #0x1c]
700a0e40: 9b09         	ldr	r3, [sp, #0x24]
700a0e42: 6981         	ldr	r1, [r0, #0x18]
700a0e44: 4419         	add	r1, r3
700a0e46: 9a04         	ldr	r2, [sp, #0x10]
700a0e48: f007 fb7a    	bl	0x700a8540 <prvInsertTimerInActiveList> @ imm = #0x76f4
700a0e4c: b1c0         	cbz	r0, 0x700a0e80 <prvProcessReceivedCommands+0xd0> @ imm = #0x30
700a0e4e: e7ff         	b	0x700a0e50 <prvProcessReceivedCommands+0xa0> @ imm = #-0x2
;                             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a0e50: 9807         	ldr	r0, [sp, #0x1c]
700a0e52: 6a01         	ldr	r1, [r0, #0x20]
700a0e54: 4788         	blx	r1
;                             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a0e56: 9807         	ldr	r0, [sp, #0x1c]
700a0e58: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a0e5c: 0740         	lsls	r0, r0, #0x1d
700a0e5e: 2800         	cmp	r0, #0x0
700a0e60: d50c         	bpl	0x700a0e7c <prvProcessReceivedCommands+0xcc> @ imm = #0x18
700a0e62: e7ff         	b	0x700a0e64 <prvProcessReceivedCommands+0xb4> @ imm = #-0x2
;                                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
700a0e64: 9807         	ldr	r0, [sp, #0x1c]
700a0e66: 9909         	ldr	r1, [sp, #0x24]
700a0e68: 6982         	ldr	r2, [r0, #0x18]
700a0e6a: 440a         	add	r2, r1
700a0e6c: 4669         	mov	r1, sp
700a0e6e: 2300         	movs	r3, #0x0
700a0e70: 600b         	str	r3, [r1]
700a0e72: 4619         	mov	r1, r3
700a0e74: f006 fde4    	bl	0x700a7a40 <xTimerGenericCommand> @ imm = #0x6bc8
700a0e78: 9005         	str	r0, [sp, #0x14]
;                             }
700a0e7a: e000         	b	0x700a0e7e <prvProcessReceivedCommands+0xce> @ imm = #0x0
700a0e7c: e7ff         	b	0x700a0e7e <prvProcessReceivedCommands+0xce> @ imm = #-0x2
;                         }
700a0e7e: e000         	b	0x700a0e82 <prvProcessReceivedCommands+0xd2> @ imm = #0x0
700a0e80: e7ff         	b	0x700a0e82 <prvProcessReceivedCommands+0xd2> @ imm = #-0x2
;                         break;
700a0e82: e02e         	b	0x700a0ee2 <prvProcessReceivedCommands+0x132> @ imm = #0x5c
;                         pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a0e84: 9907         	ldr	r1, [sp, #0x1c]
700a0e86: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a0e8a: f000 00fe    	and	r0, r0, #0xfe
700a0e8e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         break;
700a0e92: e026         	b	0x700a0ee2 <prvProcessReceivedCommands+0x132> @ imm = #0x4c
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a0e94: 9907         	ldr	r1, [sp, #0x1c]
700a0e96: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a0e9a: f040 0001    	orr	r0, r0, #0x1
700a0e9e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
700a0ea2: 9809         	ldr	r0, [sp, #0x24]
700a0ea4: 9907         	ldr	r1, [sp, #0x1c]
700a0ea6: 6188         	str	r0, [r1, #0x18]
;                         ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
700a0ea8: 9807         	ldr	r0, [sp, #0x1c]
700a0eaa: 9b04         	ldr	r3, [sp, #0x10]
700a0eac: 6981         	ldr	r1, [r0, #0x18]
700a0eae: 4419         	add	r1, r3
700a0eb0: 461a         	mov	r2, r3
700a0eb2: f007 fb45    	bl	0x700a8540 <prvInsertTimerInActiveList> @ imm = #0x768a
;                         break;
700a0eb6: e014         	b	0x700a0ee2 <prvProcessReceivedCommands+0x132> @ imm = #0x28
;                                 if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
700a0eb8: 9807         	ldr	r0, [sp, #0x1c]
700a0eba: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a0ebe: 0780         	lsls	r0, r0, #0x1e
700a0ec0: 2800         	cmp	r0, #0x0
700a0ec2: d404         	bmi	0x700a0ece <prvProcessReceivedCommands+0x11e> @ imm = #0x8
700a0ec4: e7ff         	b	0x700a0ec6 <prvProcessReceivedCommands+0x116> @ imm = #-0x2
;                                     vPortFree( pxTimer );
700a0ec6: 9807         	ldr	r0, [sp, #0x1c]
700a0ec8: f00c f84a    	bl	0x700acf60 <vPortFree>  @ imm = #0xc094
;                                 }
700a0ecc: e007         	b	0x700a0ede <prvProcessReceivedCommands+0x12e> @ imm = #0xe
;                                     pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a0ece: 9907         	ldr	r1, [sp, #0x1c]
700a0ed0: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a0ed4: f000 00fe    	and	r0, r0, #0xfe
700a0ed8: f881 0028    	strb.w	r0, [r1, #0x28]
700a0edc: e7ff         	b	0x700a0ede <prvProcessReceivedCommands+0x12e> @ imm = #-0x2
;                         break;
700a0ede: e000         	b	0x700a0ee2 <prvProcessReceivedCommands+0x132> @ imm = #0x0
;                         break;
700a0ee0: e7ff         	b	0x700a0ee2 <prvProcessReceivedCommands+0x132> @ imm = #-0x2
;             }
700a0ee2: e7ff         	b	0x700a0ee4 <prvProcessReceivedCommands+0x134> @ imm = #-0x2
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a0ee4: e767         	b	0x700a0db6 <prvProcessReceivedCommands+0x6> @ imm = #-0x132
;     }
700a0ee6: b00c         	add	sp, #0x30
700a0ee8: bd80         	pop	{r7, pc}
700a0eea: 0000         	movs	r0, r0
700a0eec: 0000         	movs	r0, r0
700a0eee: 0000         	movs	r0, r0

700a0ef0 <_ntoa_long_long>:
; {
700a0ef0: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a0ef4: b09e         	sub	sp, #0x78
700a0ef6: 469e         	mov	lr, r3
700a0ef8: 4614         	mov	r4, r2
700a0efa: 460d         	mov	r5, r1
700a0efc: 4606         	mov	r6, r0
700a0efe: 9929         	ldr	r1, [sp, #0xa4]
700a0f00: 9828         	ldr	r0, [sp, #0xa0]
700a0f02: f8dd c094    	ldr.w	r12, [sp, #0x94]
700a0f06: 9b24         	ldr	r3, [sp, #0x90]
700a0f08: 9a2c         	ldr	r2, [sp, #0xb0]
700a0f0a: 9a2b         	ldr	r2, [sp, #0xac]
700a0f0c: 9a2a         	ldr	r2, [sp, #0xa8]
700a0f0e: 9a26         	ldr	r2, [sp, #0x98]
700a0f10: 961d         	str	r6, [sp, #0x74]
700a0f12: 951c         	str	r5, [sp, #0x70]
700a0f14: 941b         	str	r4, [sp, #0x6c]
700a0f16: f8cd e068    	str.w	lr, [sp, #0x68]
700a0f1a: f8cd c064    	str.w	r12, [sp, #0x64]
700a0f1e: 9318         	str	r3, [sp, #0x60]
700a0f20: f88d 205f    	strb.w	r2, [sp, #0x5f]
700a0f24: 9115         	str	r1, [sp, #0x54]
700a0f26: 9014         	str	r0, [sp, #0x50]
700a0f28: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a0f2a: 900b         	str	r0, [sp, #0x2c]
;   if (!value) {
700a0f2c: 9818         	ldr	r0, [sp, #0x60]
700a0f2e: 9919         	ldr	r1, [sp, #0x64]
700a0f30: 4308         	orrs	r0, r1
700a0f32: b928         	cbnz	r0, 0x700a0f40 <_ntoa_long_long+0x50> @ imm = #0xa
700a0f34: e7ff         	b	0x700a0f36 <_ntoa_long_long+0x46> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a0f36: 982c         	ldr	r0, [sp, #0xb0]
700a0f38: f020 0010    	bic	r0, r0, #0x10
700a0f3c: 902c         	str	r0, [sp, #0xb0]
;   }
700a0f3e: e7ff         	b	0x700a0f40 <_ntoa_long_long+0x50> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a0f40: f89d 00b1    	ldrb.w	r0, [sp, #0xb1]
700a0f44: 0740         	lsls	r0, r0, #0x1d
700a0f46: 2800         	cmp	r0, #0x0
700a0f48: d506         	bpl	0x700a0f58 <_ntoa_long_long+0x68> @ imm = #0xc
700a0f4a: e7ff         	b	0x700a0f4c <_ntoa_long_long+0x5c> @ imm = #-0x2
700a0f4c: 9818         	ldr	r0, [sp, #0x60]
700a0f4e: 9919         	ldr	r1, [sp, #0x64]
700a0f50: 4308         	orrs	r0, r1
700a0f52: 2800         	cmp	r0, #0x0
700a0f54: d043         	beq	0x700a0fde <_ntoa_long_long+0xee> @ imm = #0x86
700a0f56: e7ff         	b	0x700a0f58 <_ntoa_long_long+0x68> @ imm = #-0x2
;     do {
700a0f58: e7ff         	b	0x700a0f5a <_ntoa_long_long+0x6a> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a0f5a: 9818         	ldr	r0, [sp, #0x60]
700a0f5c: 9919         	ldr	r1, [sp, #0x64]
700a0f5e: 9a14         	ldr	r2, [sp, #0x50]
700a0f60: 9b15         	ldr	r3, [sp, #0x54]
700a0f62: f00b ef30    	blx	0x700acdc4 <__aeabi_uldivmod> @ imm = #0xbe60
700a0f66: f88d 202b    	strb.w	r2, [sp, #0x2b]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a0f6a: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a0f6e: 2809         	cmp	r0, #0x9
700a0f70: dc05         	bgt	0x700a0f7e <_ntoa_long_long+0x8e> @ imm = #0xa
700a0f72: e7ff         	b	0x700a0f74 <_ntoa_long_long+0x84> @ imm = #-0x2
700a0f74: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a0f78: 3030         	adds	r0, #0x30
700a0f7a: 9009         	str	r0, [sp, #0x24]
700a0f7c: e00c         	b	0x700a0f98 <_ntoa_long_long+0xa8> @ imm = #0x18
700a0f7e: f89d 00b0    	ldrb.w	r0, [sp, #0xb0]
700a0f82: 0681         	lsls	r1, r0, #0x1a
700a0f84: 2061         	movs	r0, #0x61
700a0f86: 2900         	cmp	r1, #0x0
700a0f88: bf48         	it	mi
700a0f8a: 2041         	movmi	r0, #0x41
700a0f8c: f89d 102b    	ldrb.w	r1, [sp, #0x2b]
700a0f90: 4408         	add	r0, r1
700a0f92: 380a         	subs	r0, #0xa
700a0f94: 9009         	str	r0, [sp, #0x24]
700a0f96: e7ff         	b	0x700a0f98 <_ntoa_long_long+0xa8> @ imm = #-0x2
700a0f98: 9809         	ldr	r0, [sp, #0x24]
700a0f9a: 9a0b         	ldr	r2, [sp, #0x2c]
700a0f9c: 1c51         	adds	r1, r2, #0x1
700a0f9e: 910b         	str	r1, [sp, #0x2c]
700a0fa0: a90c         	add	r1, sp, #0x30
700a0fa2: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a0fa4: 9a14         	ldr	r2, [sp, #0x50]
700a0fa6: 9b15         	ldr	r3, [sp, #0x54]
700a0fa8: 9818         	ldr	r0, [sp, #0x60]
700a0faa: 9919         	ldr	r1, [sp, #0x64]
700a0fac: f00b ef0a    	blx	0x700acdc4 <__aeabi_uldivmod> @ imm = #0xbe14
700a0fb0: 9119         	str	r1, [sp, #0x64]
700a0fb2: 9018         	str	r0, [sp, #0x60]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a0fb4: e7ff         	b	0x700a0fb6 <_ntoa_long_long+0xc6> @ imm = #-0x2
700a0fb6: 9818         	ldr	r0, [sp, #0x60]
700a0fb8: 9919         	ldr	r1, [sp, #0x64]
700a0fba: 4301         	orrs	r1, r0
700a0fbc: 2000         	movs	r0, #0x0
700a0fbe: 9008         	str	r0, [sp, #0x20]
700a0fc0: b139         	cbz	r1, 0x700a0fd2 <_ntoa_long_long+0xe2> @ imm = #0xe
700a0fc2: e7ff         	b	0x700a0fc4 <_ntoa_long_long+0xd4> @ imm = #-0x2
700a0fc4: 990b         	ldr	r1, [sp, #0x2c]
700a0fc6: 2000         	movs	r0, #0x0
700a0fc8: 2920         	cmp	r1, #0x20
700a0fca: bf38         	it	lo
700a0fcc: 2001         	movlo	r0, #0x1
700a0fce: 9008         	str	r0, [sp, #0x20]
700a0fd0: e7ff         	b	0x700a0fd2 <_ntoa_long_long+0xe2> @ imm = #-0x2
700a0fd2: 9808         	ldr	r0, [sp, #0x20]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a0fd4: 07c0         	lsls	r0, r0, #0x1f
700a0fd6: 2800         	cmp	r0, #0x0
700a0fd8: d1bf         	bne	0x700a0f5a <_ntoa_long_long+0x6a> @ imm = #-0x82
700a0fda: e7ff         	b	0x700a0fdc <_ntoa_long_long+0xec> @ imm = #-0x2
;   }
700a0fdc: e7ff         	b	0x700a0fde <_ntoa_long_long+0xee> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a0fde: 981d         	ldr	r0, [sp, #0x74]
700a0fe0: 991c         	ldr	r1, [sp, #0x70]
700a0fe2: 9a1b         	ldr	r2, [sp, #0x6c]
700a0fe4: 9b1a         	ldr	r3, [sp, #0x68]
700a0fe6: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a0fea: 9d14         	ldr	r5, [sp, #0x50]
700a0fec: 9e2a         	ldr	r6, [sp, #0xa8]
700a0fee: 9f2b         	ldr	r7, [sp, #0xac]
700a0ff0: f8dd 80b0    	ldr.w	r8, [sp, #0xb0]
700a0ff4: f89d 405f    	ldrb.w	r4, [sp, #0x5f]
700a0ff8: 46ee         	mov	lr, sp
700a0ffa: f8ce 8018    	str.w	r8, [lr, #0x18]
700a0ffe: f8ce 7014    	str.w	r7, [lr, #0x14]
700a1002: f8ce 6010    	str.w	r6, [lr, #0x10]
700a1006: f8ce 500c    	str.w	r5, [lr, #0xc]
700a100a: f004 0401    	and	r4, r4, #0x1
700a100e: f8ce 4008    	str.w	r4, [lr, #0x8]
700a1012: f8ce c004    	str.w	r12, [lr, #0x4]
700a1016: f10d 0c30    	add.w	r12, sp, #0x30
700a101a: f8ce c000    	str.w	r12, [lr]
700a101e: f7fc f80f    	bl	0x7009d040 <_ntoa_format> @ imm = #-0x3fe2
700a1022: b01e         	add	sp, #0x78
700a1024: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a1030 <Sciclient_rmIrqVintDelete>:
; {
700a1030: b580         	push	{r7, lr}
700a1032: b08c         	sub	sp, #0x30
700a1034: 900b         	str	r0, [sp, #0x2c]
700a1036: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a1038: 900a         	str	r0, [sp, #0x28]
;     bool del_mapping = false;
700a103a: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool del_whole_route = false;
700a103e: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a1042: 9008         	str	r0, [sp, #0x20]
;     if (r == SystemP_SUCCESS) {
700a1044: 980a         	ldr	r0, [sp, #0x28]
700a1046: b948         	cbnz	r0, 0x700a105c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #0x12
700a1048: e7ff         	b	0x700a104a <Sciclient_rmIrqVintDelete+0x1a> @ imm = #-0x2
;         r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700a104a: 990b         	ldr	r1, [sp, #0x2c]
700a104c: 8a08         	ldrh	r0, [r1, #0x10]
700a104e: 8a49         	ldrh	r1, [r1, #0x12]
700a1050: f10d 0227    	add.w	r2, sp, #0x27
700a1054: f008 fa3c    	bl	0x700a94d0 <Sciclient_rmIaVintGetInfo> @ imm = #0x8478
700a1058: 900a         	str	r0, [sp, #0x28]
;     }
700a105a: e7ff         	b	0x700a105c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a105c: 980a         	ldr	r0, [sp, #0x28]
700a105e: b9e8         	cbnz	r0, 0x700a109c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #0x3a
700a1060: e7ff         	b	0x700a1062 <Sciclient_rmIrqVintDelete+0x32> @ imm = #-0x2
;         if (num_evts == 0u) {
700a1062: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a1066: b920         	cbnz	r0, 0x700a1072 <Sciclient_rmIrqVintDelete+0x42> @ imm = #0x8
700a1068: e7ff         	b	0x700a106a <Sciclient_rmIrqVintDelete+0x3a> @ imm = #-0x2
700a106a: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a106e: 900a         	str	r0, [sp, #0x28]
;         } else if ((num_evts > 1u) ||
700a1070: e013         	b	0x700a109a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #0x26
700a1072: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a1076: 2801         	cmp	r0, #0x1
700a1078: d806         	bhi	0x700a1088 <Sciclient_rmIrqVintDelete+0x58> @ imm = #0xc
700a107a: e7ff         	b	0x700a107c <Sciclient_rmIrqVintDelete+0x4c> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a107c: 980b         	ldr	r0, [sp, #0x2c]
700a107e: 6800         	ldr	r0, [r0]
700a1080: f008 fbae    	bl	0x700a97e0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x875c
;         } else if ((num_evts > 1u) ||
700a1084: b120         	cbz	r0, 0x700a1090 <Sciclient_rmIrqVintDelete+0x60> @ imm = #0x8
700a1086: e7ff         	b	0x700a1088 <Sciclient_rmIrqVintDelete+0x58> @ imm = #-0x2
700a1088: 2001         	movs	r0, #0x1
;             del_mapping = true;
700a108a: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a108e: e003         	b	0x700a1098 <Sciclient_rmIrqVintDelete+0x68> @ imm = #0x6
700a1090: 2001         	movs	r0, #0x1
;             del_whole_route = true;
700a1092: f88d 0025    	strb.w	r0, [sp, #0x25]
700a1096: e7ff         	b	0x700a1098 <Sciclient_rmIrqVintDelete+0x68> @ imm = #-0x2
700a1098: e7ff         	b	0x700a109a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #-0x2
;     }
700a109a: e7ff         	b	0x700a109c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #-0x2
;     if (del_mapping == true) {
700a109c: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a10a0: 07c0         	lsls	r0, r0, #0x1f
700a10a2: 2800         	cmp	r0, #0x0
700a10a4: d049         	beq	0x700a113a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #0x92
700a10a6: e7ff         	b	0x700a10a8 <Sciclient_rmIrqVintDelete+0x78> @ imm = #-0x2
700a10a8: 203c         	movs	r0, #0x3c
700a10aa: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a10ae: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a10b0: 980b         	ldr	r0, [sp, #0x2c]
700a10b2: 7900         	ldrb	r0, [r0, #0x4]
700a10b4: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a10b8: 980b         	ldr	r0, [sp, #0x2c]
700a10ba: 88c0         	ldrh	r0, [r0, #0x6]
700a10bc: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a10c0: 980b         	ldr	r0, [sp, #0x2c]
700a10c2: 8900         	ldrh	r0, [r0, #0x8]
700a10c4: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a10c8: 980b         	ldr	r0, [sp, #0x2c]
700a10ca: 8a00         	ldrh	r0, [r0, #0x10]
700a10cc: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a10d0: 980b         	ldr	r0, [sp, #0x2c]
700a10d2: 8a40         	ldrh	r0, [r0, #0x12]
700a10d4: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a10d8: 980b         	ldr	r0, [sp, #0x2c]
700a10da: 89c0         	ldrh	r0, [r0, #0xe]
700a10dc: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a10e0: 980b         	ldr	r0, [sp, #0x2c]
700a10e2: 7d00         	ldrb	r0, [r0, #0x14]
700a10e4: f88d 001e    	strb.w	r0, [sp, #0x1e]
700a10e8: a801         	add	r0, sp, #0x4
700a10ea: f04f 31ff    	mov.w	r1, #0xffffffff
;         r = Sciclient_rmIrqReleaseRaw(&req,
700a10ee: f009 fc47    	bl	0x700aa980 <Sciclient_rmIrqReleaseRaw> @ imm = #0x988e
700a10f2: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a10f4: 980a         	ldr	r0, [sp, #0x28]
700a10f6: b9f8         	cbnz	r0, 0x700a1138 <Sciclient_rmIrqVintDelete+0x108> @ imm = #0x3e
700a10f8: e7ff         	b	0x700a10fa <Sciclient_rmIrqVintDelete+0xca> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a10fa: 980b         	ldr	r0, [sp, #0x2c]
700a10fc: 8a00         	ldrh	r0, [r0, #0x10]
700a10fe: f009 f96f    	bl	0x700aa3e0 <Sciclient_rmIaGetInst> @ imm = #0x92de
700a1102: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a1104: 9808         	ldr	r0, [sp, #0x20]
700a1106: b1b0         	cbz	r0, 0x700a1136 <Sciclient_rmIrqVintDelete+0x106> @ imm = #0x2c
700a1108: e7ff         	b	0x700a110a <Sciclient_rmIrqVintDelete+0xda> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]--;
700a110a: 9808         	ldr	r0, [sp, #0x20]
700a110c: 6901         	ldr	r1, [r0, #0x10]
700a110e: 980b         	ldr	r0, [sp, #0x2c]
700a1110: 8a42         	ldrh	r2, [r0, #0x12]
700a1112: 5c88         	ldrb	r0, [r1, r2]
700a1114: 3801         	subs	r0, #0x1
700a1116: 5488         	strb	r0, [r1, r2]
;                 if (ia_inst->v0_b0_evt == cfg->global_evt - ia_inst->sevt_offset) {
700a1118: 9a08         	ldr	r2, [sp, #0x20]
700a111a: 8a90         	ldrh	r0, [r2, #0x14]
700a111c: 990b         	ldr	r1, [sp, #0x2c]
700a111e: 89c9         	ldrh	r1, [r1, #0xe]
700a1120: 8912         	ldrh	r2, [r2, #0x8]
700a1122: 1a89         	subs	r1, r1, r2
700a1124: 4288         	cmp	r0, r1
700a1126: d105         	bne	0x700a1134 <Sciclient_rmIrqVintDelete+0x104> @ imm = #0xa
700a1128: e7ff         	b	0x700a112a <Sciclient_rmIrqVintDelete+0xfa> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
700a112a: 9908         	ldr	r1, [sp, #0x20]
700a112c: f64f 70ff    	movw	r0, #0xffff
700a1130: 8288         	strh	r0, [r1, #0x14]
;                 }
700a1132: e7ff         	b	0x700a1134 <Sciclient_rmIrqVintDelete+0x104> @ imm = #-0x2
;             }
700a1134: e7ff         	b	0x700a1136 <Sciclient_rmIrqVintDelete+0x106> @ imm = #-0x2
;         }
700a1136: e7ff         	b	0x700a1138 <Sciclient_rmIrqVintDelete+0x108> @ imm = #-0x2
;     }
700a1138: e7ff         	b	0x700a113a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #-0x2
;     if (del_whole_route == true) {
700a113a: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a113e: 07c0         	lsls	r0, r0, #0x1f
700a1140: b170         	cbz	r0, 0x700a1160 <Sciclient_rmIrqVintDelete+0x130> @ imm = #0x1c
700a1142: e7ff         	b	0x700a1144 <Sciclient_rmIrqVintDelete+0x114> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700a1144: 980b         	ldr	r0, [sp, #0x2c]
700a1146: f7fa fb93    	bl	0x7009b870 <Sciclient_rmIrqGetRoute> @ imm = #-0x58da
700a114a: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a114c: 980a         	ldr	r0, [sp, #0x28]
700a114e: b930         	cbnz	r0, 0x700a115e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #0xc
700a1150: e7ff         	b	0x700a1152 <Sciclient_rmIrqVintDelete+0x122> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, true);
700a1152: 980b         	ldr	r0, [sp, #0x2c]
700a1154: 2101         	movs	r1, #0x1
700a1156: f7fd fc8b    	bl	0x7009ea70 <Sciclient_rmIrqDeleteRoute> @ imm = #-0x26ea
700a115a: 900a         	str	r0, [sp, #0x28]
;         }
700a115c: e7ff         	b	0x700a115e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #-0x2
;     }
700a115e: e7ff         	b	0x700a1160 <Sciclient_rmIrqVintDelete+0x130> @ imm = #-0x2
;     return r;
700a1160: 980a         	ldr	r0, [sp, #0x28]
700a1162: b00c         	add	sp, #0x30
700a1164: bd80         	pop	{r7, pc}
		...
700a116e: 0000         	movs	r0, r0

700a1170 <UART_writePolling>:
; {
700a1170: b580         	push	{r7, lr}
700a1172: b08c         	sub	sp, #0x30
700a1174: 900b         	str	r0, [sp, #0x2c]
700a1176: 910a         	str	r1, [sp, #0x28]
700a1178: 2000         	movs	r0, #0x0
;     int32_t             retVal          = UART_TRANSFER_STATUS_SUCCESS;
700a117a: 9007         	str	r0, [sp, #0x1c]
;     uint32_t            timeoutElapsed  = FALSE;
700a117c: 9006         	str	r0, [sp, #0x18]
;     uint32_t            baseAddr        = hUart->baseAddr;
700a117e: 990b         	ldr	r1, [sp, #0x2c]
700a1180: 6809         	ldr	r1, [r1]
700a1182: 9105         	str	r1, [sp, #0x14]
;     uint32_t            lineStatus      = 0U;
700a1184: 9004         	str	r0, [sp, #0x10]
;     hUartInit = hUart->hUartInit;
700a1186: 980b         	ldr	r0, [sp, #0x2c]
700a1188: 6840         	ldr	r0, [r0, #0x4]
700a118a: 9003         	str	r0, [sp, #0xc]
;     hUart->writeSizeRemaining = trans->count;
700a118c: 980a         	ldr	r0, [sp, #0x28]
700a118e: 6840         	ldr	r0, [r0, #0x4]
700a1190: 990b         	ldr	r1, [sp, #0x2c]
700a1192: 6108         	str	r0, [r1, #0x10]
;     startTicks = hUartInit->clockP_get();
700a1194: 9803         	ldr	r0, [sp, #0xc]
700a1196: 6d40         	ldr	r0, [r0, #0x54]
700a1198: 4780         	blx	r0
700a119a: 9009         	str	r0, [sp, #0x24]
;     while ((FALSE == timeoutElapsed)
700a119c: e7ff         	b	0x700a119e <UART_writePolling+0x2e> @ imm = #-0x2
700a119e: 9906         	ldr	r1, [sp, #0x18]
700a11a0: 2000         	movs	r0, #0x0
;            && (0U != hUart->writeSizeRemaining))
700a11a2: 9002         	str	r0, [sp, #0x8]
700a11a4: b939         	cbnz	r1, 0x700a11b6 <UART_writePolling+0x46> @ imm = #0xe
700a11a6: e7ff         	b	0x700a11a8 <UART_writePolling+0x38> @ imm = #-0x2
700a11a8: 980b         	ldr	r0, [sp, #0x2c]
700a11aa: 6900         	ldr	r0, [r0, #0x10]
700a11ac: 2800         	cmp	r0, #0x0
700a11ae: bf18         	it	ne
700a11b0: 2001         	movne	r0, #0x1
700a11b2: 9002         	str	r0, [sp, #0x8]
700a11b4: e7ff         	b	0x700a11b6 <UART_writePolling+0x46> @ imm = #-0x2
700a11b6: 9802         	ldr	r0, [sp, #0x8]
;     while ((FALSE == timeoutElapsed)
700a11b8: 07c0         	lsls	r0, r0, #0x1f
700a11ba: b198         	cbz	r0, 0x700a11e4 <UART_writePolling+0x74> @ imm = #0x26
700a11bc: e7ff         	b	0x700a11be <UART_writePolling+0x4e> @ imm = #-0x2
;         UART_writeDataPolling(hUart);
700a11be: 980b         	ldr	r0, [sp, #0x2c]
700a11c0: f00a ff3e    	bl	0x700ac040 <UART_writeDataPolling> @ imm = #0xae7c
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700a11c4: 9803         	ldr	r0, [sp, #0xc]
700a11c6: 6d40         	ldr	r0, [r0, #0x54]
700a11c8: 4780         	blx	r0
700a11ca: 9909         	ldr	r1, [sp, #0x24]
700a11cc: 1a40         	subs	r0, r0, r1
700a11ce: 9008         	str	r0, [sp, #0x20]
;         if (elapsedTicks >= trans->timeout)
700a11d0: 9808         	ldr	r0, [sp, #0x20]
700a11d2: 990a         	ldr	r1, [sp, #0x28]
700a11d4: 6889         	ldr	r1, [r1, #0x8]
700a11d6: 4288         	cmp	r0, r1
700a11d8: d303         	blo	0x700a11e2 <UART_writePolling+0x72> @ imm = #0x6
700a11da: e7ff         	b	0x700a11dc <UART_writePolling+0x6c> @ imm = #-0x2
700a11dc: 2001         	movs	r0, #0x1
;             timeoutElapsed = TRUE;
700a11de: 9006         	str	r0, [sp, #0x18]
;         }
700a11e0: e7ff         	b	0x700a11e2 <UART_writePolling+0x72> @ imm = #-0x2
;     while ((FALSE == timeoutElapsed)
700a11e2: e7dc         	b	0x700a119e <UART_writePolling+0x2e> @ imm = #-0x48
;     if (0U == hUart->writeSizeRemaining)
700a11e4: 980b         	ldr	r0, [sp, #0x2c]
700a11e6: 6900         	ldr	r0, [r0, #0x10]
700a11e8: 2800         	cmp	r0, #0x0
700a11ea: d149         	bne	0x700a1280 <UART_writePolling+0x110> @ imm = #0x92
700a11ec: e7ff         	b	0x700a11ee <UART_writePolling+0x7e> @ imm = #-0x2
;         do
700a11ee: e7ff         	b	0x700a11f0 <UART_writePolling+0x80> @ imm = #-0x2
;             lineStatus = UART_readLineStatus(baseAddr);
700a11f0: 9805         	ldr	r0, [sp, #0x14]
700a11f2: f00a f9d5    	bl	0x700ab5a0 <UART_readLineStatus> @ imm = #0xa3aa
700a11f6: 9004         	str	r0, [sp, #0x10]
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700a11f8: 9803         	ldr	r0, [sp, #0xc]
700a11fa: 6d40         	ldr	r0, [r0, #0x54]
700a11fc: 4780         	blx	r0
700a11fe: 9909         	ldr	r1, [sp, #0x24]
700a1200: 1a40         	subs	r0, r0, r1
700a1202: 9008         	str	r0, [sp, #0x20]
;         }
700a1204: e7ff         	b	0x700a1206 <UART_writePolling+0x96> @ imm = #-0x2
;                (lineStatus & (uint32_t) (UART_LSR_TX_FIFO_E_MASK |
700a1206: 9804         	ldr	r0, [sp, #0x10]
700a1208: f000 0160    	and	r1, r0, #0x60
700a120c: 2000         	movs	r0, #0x0
;                 && (elapsedTicks < hUart->lineStatusTimeout));
700a120e: 2960         	cmp	r1, #0x60
700a1210: 9001         	str	r0, [sp, #0x4]
700a1212: d00d         	beq	0x700a1230 <UART_writePolling+0xc0> @ imm = #0x1a
700a1214: e7ff         	b	0x700a1216 <UART_writePolling+0xa6> @ imm = #-0x2
700a1216: 9808         	ldr	r0, [sp, #0x20]
700a1218: 990b         	ldr	r1, [sp, #0x2c]
700a121a: 6e8a         	ldr	r2, [r1, #0x68]
700a121c: 6ec9         	ldr	r1, [r1, #0x6c]
700a121e: 1a80         	subs	r0, r0, r2
700a1220: f04f 0000    	mov.w	r0, #0x0
700a1224: eb70 0101    	sbcs.w	r1, r0, r1
700a1228: bf38         	it	lo
700a122a: 2001         	movlo	r0, #0x1
700a122c: 9001         	str	r0, [sp, #0x4]
700a122e: e7ff         	b	0x700a1230 <UART_writePolling+0xc0> @ imm = #-0x2
700a1230: 9801         	ldr	r0, [sp, #0x4]
;         }
700a1232: 07c0         	lsls	r0, r0, #0x1f
700a1234: 2800         	cmp	r0, #0x0
700a1236: d1db         	bne	0x700a11f0 <UART_writePolling+0x80> @ imm = #-0x4a
700a1238: e7ff         	b	0x700a123a <UART_writePolling+0xca> @ imm = #-0x2
;         if(elapsedTicks >= hUart->lineStatusTimeout)
700a123a: 9808         	ldr	r0, [sp, #0x20]
700a123c: 990b         	ldr	r1, [sp, #0x2c]
700a123e: 6e8a         	ldr	r2, [r1, #0x68]
700a1240: 6ec9         	ldr	r1, [r1, #0x6c]
700a1242: 1a80         	subs	r0, r0, r2
700a1244: f04f 0000    	mov.w	r0, #0x0
700a1248: 4188         	sbcs	r0, r1
700a124a: d30f         	blo	0x700a126c <UART_writePolling+0xfc> @ imm = #0x1e
700a124c: e7ff         	b	0x700a124e <UART_writePolling+0xde> @ imm = #-0x2
700a124e: f06f 0001    	mvn	r0, #0x1
;             retVal             = UART_TRANSFER_TIMEOUT;
700a1252: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a1254: 990a         	ldr	r1, [sp, #0x28]
700a1256: 2001         	movs	r0, #0x1
700a1258: 60c8         	str	r0, [r1, #0xc]
;             trans->count       = hUart->writeCount;
700a125a: 980b         	ldr	r0, [sp, #0x2c]
700a125c: 68c0         	ldr	r0, [r0, #0xc]
700a125e: 990a         	ldr	r1, [sp, #0x28]
700a1260: 6048         	str	r0, [r1, #0x4]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a1262: 980b         	ldr	r0, [sp, #0x2c]
700a1264: 303c         	adds	r0, #0x3c
700a1266: f00b fedb    	bl	0x700ad020 <UART_lld_Transaction_deInit> @ imm = #0xbdb6
;         }
700a126a: e008         	b	0x700a127e <UART_writePolling+0x10e> @ imm = #0x10
700a126c: 2000         	movs	r0, #0x0
;             retVal             = UART_TRANSFER_STATUS_SUCCESS;
700a126e: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_SUCCESS;
700a1270: 990a         	ldr	r1, [sp, #0x28]
700a1272: 60c8         	str	r0, [r1, #0xc]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a1274: 980b         	ldr	r0, [sp, #0x2c]
700a1276: 303c         	adds	r0, #0x3c
700a1278: f00b fed2    	bl	0x700ad020 <UART_lld_Transaction_deInit> @ imm = #0xbda4
700a127c: e7ff         	b	0x700a127e <UART_writePolling+0x10e> @ imm = #-0x2
;     }
700a127e: e00e         	b	0x700a129e <UART_writePolling+0x12e> @ imm = #0x1c
700a1280: f06f 0001    	mvn	r0, #0x1
;         retVal             = UART_TRANSFER_TIMEOUT;
700a1284: 9007         	str	r0, [sp, #0x1c]
;         trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a1286: 990a         	ldr	r1, [sp, #0x28]
700a1288: 2001         	movs	r0, #0x1
700a128a: 60c8         	str	r0, [r1, #0xc]
;         trans->count       = hUart->writeCount;
700a128c: 980b         	ldr	r0, [sp, #0x2c]
700a128e: 68c0         	ldr	r0, [r0, #0xc]
700a1290: 990a         	ldr	r1, [sp, #0x28]
700a1292: 6048         	str	r0, [r1, #0x4]
;         UART_lld_Transaction_deInit(&hUart->writeTrans);
700a1294: 980b         	ldr	r0, [sp, #0x2c]
700a1296: 303c         	adds	r0, #0x3c
700a1298: f00b fec2    	bl	0x700ad020 <UART_lld_Transaction_deInit> @ imm = #0xbd84
700a129c: e7ff         	b	0x700a129e <UART_writePolling+0x12e> @ imm = #-0x2
;     return (retVal);
700a129e: 9807         	ldr	r0, [sp, #0x1c]
700a12a0: b00c         	add	sp, #0x30
700a12a2: bd80         	pop	{r7, pc}
		...

700a12b0 <Sciclient_recvMessage>:
; {
700a12b0: b580         	push	{r7, lr}
700a12b2: b08e         	sub	sp, #0x38
700a12b4: 900d         	str	r0, [sp, #0x34]
700a12b6: 910c         	str	r1, [sp, #0x30]
700a12b8: 920b         	str	r2, [sp, #0x2c]
700a12ba: 2000         	movs	r0, #0x0
;     uint8_t  trailBytes = 0U;
700a12bc: f88d 0023    	strb.w	r0, [sp, #0x23]
;     numWords   = (uint32_t) (rxPayloadSize / 4U);
700a12c0: 990b         	ldr	r1, [sp, #0x2c]
700a12c2: ea4f 0191    	lsr.w	r1, r1, #0x2
700a12c6: 910a         	str	r1, [sp, #0x28]
;     trailBytes = (uint8_t) (rxPayloadSize - (numWords * 4U));
700a12c8: 990b         	ldr	r1, [sp, #0x2c]
700a12ca: 9a0a         	ldr	r2, [sp, #0x28]
700a12cc: eba1 0182    	sub.w	r1, r1, r2, lsl #2
700a12d0: f88d 1023    	strb.w	r1, [sp, #0x23]
;     for (i = 0; i < numWords; i++)
700a12d4: 9009         	str	r0, [sp, #0x24]
700a12d6: e7ff         	b	0x700a12d8 <Sciclient_recvMessage+0x28> @ imm = #-0x2
700a12d8: 9809         	ldr	r0, [sp, #0x24]
700a12da: 990a         	ldr	r1, [sp, #0x28]
700a12dc: 4288         	cmp	r0, r1
700a12de: d22c         	bhs	0x700a133a <Sciclient_recvMessage+0x8a> @ imm = #0x58
700a12e0: e7ff         	b	0x700a12e2 <Sciclient_recvMessage+0x32> @ imm = #-0x2
;             rxThread,
700a12e2: 980d         	ldr	r0, [sp, #0x34]
;             ((uint8_t) i +
700a12e4: 9909         	ldr	r1, [sp, #0x24]
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a12e6: f240 2220    	movw	r2, #0x220
700a12ea: f2c7 020b    	movt	r2, #0x700b
700a12ee: 7812         	ldrb	r2, [r2]
;             ((uint8_t) i +
700a12f0: 4411         	add	r1, r2
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a12f2: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a12f4: b2c9         	uxtb	r1, r1
700a12f6: f00b f963    	bl	0x700ac5c0 <Sciclient_secProxyReadThread32> @ imm = #0xb2c6
700a12fa: 9007         	str	r0, [sp, #0x1c]
700a12fc: a807         	add	r0, sp, #0x1c
;         uint8_t * tempWordPtr = (uint8_t*) & tempWord;
700a12fe: 9006         	str	r0, [sp, #0x18]
700a1300: 2000         	movs	r0, #0x0
;         uint32_t j = 0U;
700a1302: 9005         	str	r0, [sp, #0x14]
;         for (j = 0U; j < 4U; j++)
700a1304: 9005         	str	r0, [sp, #0x14]
700a1306: e7ff         	b	0x700a1308 <Sciclient_recvMessage+0x58> @ imm = #-0x2
700a1308: 9805         	ldr	r0, [sp, #0x14]
700a130a: 2803         	cmp	r0, #0x3
700a130c: d810         	bhi	0x700a1330 <Sciclient_recvMessage+0x80> @ imm = #0x20
700a130e: e7ff         	b	0x700a1310 <Sciclient_recvMessage+0x60> @ imm = #-0x2
;             *(pLocalRespPayload + i * 4 + j) = *tempWordPtr;
700a1310: 9806         	ldr	r0, [sp, #0x18]
700a1312: 7800         	ldrb	r0, [r0]
700a1314: 990c         	ldr	r1, [sp, #0x30]
700a1316: 9a09         	ldr	r2, [sp, #0x24]
700a1318: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a131c: 9a05         	ldr	r2, [sp, #0x14]
700a131e: 5488         	strb	r0, [r1, r2]
;             tempWordPtr++;
700a1320: 9806         	ldr	r0, [sp, #0x18]
700a1322: 3001         	adds	r0, #0x1
700a1324: 9006         	str	r0, [sp, #0x18]
;         }
700a1326: e7ff         	b	0x700a1328 <Sciclient_recvMessage+0x78> @ imm = #-0x2
;         for (j = 0U; j < 4U; j++)
700a1328: 9805         	ldr	r0, [sp, #0x14]
700a132a: 3001         	adds	r0, #0x1
700a132c: 9005         	str	r0, [sp, #0x14]
700a132e: e7eb         	b	0x700a1308 <Sciclient_recvMessage+0x58> @ imm = #-0x2a
;     }
700a1330: e7ff         	b	0x700a1332 <Sciclient_recvMessage+0x82> @ imm = #-0x2
;     for (i = 0; i < numWords; i++)
700a1332: 9809         	ldr	r0, [sp, #0x24]
700a1334: 3001         	adds	r0, #0x1
700a1336: 9009         	str	r0, [sp, #0x24]
700a1338: e7ce         	b	0x700a12d8 <Sciclient_recvMessage+0x28> @ imm = #-0x64
;     if (trailBytes > 0U)
700a133a: f89d 0023    	ldrb.w	r0, [sp, #0x23]
700a133e: b368         	cbz	r0, 0x700a139c <Sciclient_recvMessage+0xec> @ imm = #0x5a
700a1340: e7ff         	b	0x700a1342 <Sciclient_recvMessage+0x92> @ imm = #-0x2
;                 rxThread,
700a1342: 980d         	ldr	r0, [sp, #0x34]
;                 ((uint8_t)i +
700a1344: 9909         	ldr	r1, [sp, #0x24]
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a1346: f240 2220    	movw	r2, #0x220
700a134a: f2c7 020b    	movt	r2, #0x700b
700a134e: 7812         	ldrb	r2, [r2]
;                 ((uint8_t)i +
700a1350: 4411         	add	r1, r2
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a1352: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a1354: b2c9         	uxtb	r1, r1
700a1356: f00b f933    	bl	0x700ac5c0 <Sciclient_secProxyReadThread32> @ imm = #0xb266
700a135a: 9004         	str	r0, [sp, #0x10]
700a135c: a804         	add	r0, sp, #0x10
;         uint8_t * pTempWord = (uint8_t*) &tempWord;
700a135e: 9003         	str	r0, [sp, #0xc]
700a1360: 2000         	movs	r0, #0x0
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a1362: 9002         	str	r0, [sp, #0x8]
700a1364: e7ff         	b	0x700a1366 <Sciclient_recvMessage+0xb6> @ imm = #-0x2
700a1366: 9802         	ldr	r0, [sp, #0x8]
700a1368: f89d 1023    	ldrb.w	r1, [sp, #0x23]
700a136c: 4288         	cmp	r0, r1
700a136e: d214         	bhs	0x700a139a <Sciclient_recvMessage+0xea> @ imm = #0x28
700a1370: e7ff         	b	0x700a1372 <Sciclient_recvMessage+0xc2> @ imm = #-0x2
;             uint8_t * address = (uint8_t*)pLocalRespPayload;
700a1372: 980c         	ldr	r0, [sp, #0x30]
700a1374: 9001         	str	r0, [sp, #0x4]
;             uint8_t value = *(uint8_t*)(pTempWord + bytes);
700a1376: 9803         	ldr	r0, [sp, #0xc]
700a1378: 9902         	ldr	r1, [sp, #0x8]
700a137a: 5c40         	ldrb	r0, [r0, r1]
700a137c: f88d 0003    	strb.w	r0, [sp, #0x3]
;             *(uint8_t*)(address + i*4 + bytes) = value;
700a1380: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a1384: 9901         	ldr	r1, [sp, #0x4]
700a1386: 9a09         	ldr	r2, [sp, #0x24]
700a1388: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a138c: 9a02         	ldr	r2, [sp, #0x8]
700a138e: 5488         	strb	r0, [r1, r2]
;         }
700a1390: e7ff         	b	0x700a1392 <Sciclient_recvMessage+0xe2> @ imm = #-0x2
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a1392: 9802         	ldr	r0, [sp, #0x8]
700a1394: 3001         	adds	r0, #0x1
700a1396: 9002         	str	r0, [sp, #0x8]
700a1398: e7e5         	b	0x700a1366 <Sciclient_recvMessage+0xb6> @ imm = #-0x36
;     }
700a139a: e7ff         	b	0x700a139c <Sciclient_recvMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a139c: f240 2020    	movw	r0, #0x220
700a13a0: f2c7 000b    	movt	r0, #0x700b
700a13a4: 7801         	ldrb	r1, [r0]
;         rxPayloadSize) <=
700a13a6: 980b         	ldr	r0, [sp, #0x2c]
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a13a8: eb00 0081    	add.w	r0, r0, r1, lsl #2
;         (SCICLIENT_HEADER_SIZE_IN_WORDS*4U) +
700a13ac: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a13ae: f240 1138    	movw	r1, #0x138
700a13b2: f2c7 010b    	movt	r1, #0x700b
700a13b6: 6949         	ldr	r1, [r1, #0x14]
700a13b8: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a13ba: 4288         	cmp	r0, r1
700a13bc: d80e         	bhi	0x700a13dc <Sciclient_recvMessage+0x12c> @ imm = #0x1c
700a13be: e7ff         	b	0x700a13c0 <Sciclient_recvMessage+0x110> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a13c0: 980d         	ldr	r0, [sp, #0x34]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a13c2: f240 1138    	movw	r1, #0x138
700a13c6: f2c7 010b    	movt	r1, #0x700b
700a13ca: 694a         	ldr	r2, [r1, #0x14]
700a13cc: f04f 31ff    	mov.w	r1, #0xffffffff
700a13d0: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a13d4: b2c9         	uxtb	r1, r1
700a13d6: f00b f8f3    	bl	0x700ac5c0 <Sciclient_secProxyReadThread32> @ imm = #0xb1e6
;     }
700a13da: e7ff         	b	0x700a13dc <Sciclient_recvMessage+0x12c> @ imm = #-0x2
; }
700a13dc: b00e         	add	sp, #0x38
700a13de: bd80         	pop	{r7, pc}

700a13e0 <Udma_rmAllocIrIntr>:
; {
700a13e0: b580         	push	{r7, lr}
700a13e2: b088         	sub	sp, #0x20
700a13e4: 9007         	str	r0, [sp, #0x1c]
700a13e6: 9106         	str	r1, [sp, #0x18]
700a13e8: 2000         	movs	r0, #0x0
700a13ea: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            irIntrNum = UDMA_INTR_INVALID;
700a13ee: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a13f0: 9806         	ldr	r0, [sp, #0x18]
700a13f2: f500 70ea    	add.w	r0, r0, #0x1d4
700a13f6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a13f8: 9806         	ldr	r0, [sp, #0x18]
700a13fa: f500 609f    	add.w	r0, r0, #0x4f8
700a13fe: f04f 31ff    	mov.w	r1, #0xffffffff
700a1402: f007 f975    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x72ea
;     if(UDMA_CORE_INTR_ANY == preferredIrIntrNum)
700a1406: 9807         	ldr	r0, [sp, #0x1c]
700a1408: 2101         	movs	r1, #0x1
700a140a: f6cf 71ff    	movt	r1, #0xffff
700a140e: 4288         	cmp	r0, r1
700a1410: d138         	bne	0x700a1484 <Udma_rmAllocIrIntr+0xa4> @ imm = #0x70
700a1412: e7ff         	b	0x700a1414 <Udma_rmAllocIrIntr+0x34> @ imm = #-0x2
700a1414: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a1416: 9005         	str	r0, [sp, #0x14]
700a1418: e7ff         	b	0x700a141a <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x2
700a141a: 9805         	ldr	r0, [sp, #0x14]
700a141c: 9900         	ldr	r1, [sp]
700a141e: f8d1 10ec    	ldr.w	r1, [r1, #0xec]
700a1422: 4288         	cmp	r0, r1
700a1424: d22d         	bhs	0x700a1482 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x5a
700a1426: e7ff         	b	0x700a1428 <Udma_rmAllocIrIntr+0x48> @ imm = #-0x2
;             offset = i >> 5U;
700a1428: 9805         	ldr	r0, [sp, #0x14]
700a142a: 0940         	lsrs	r0, r0, #0x5
700a142c: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a142e: 9805         	ldr	r0, [sp, #0x14]
700a1430: 9904         	ldr	r1, [sp, #0x10]
700a1432: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1436: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1438: 9903         	ldr	r1, [sp, #0xc]
700a143a: 2001         	movs	r0, #0x1
700a143c: 4088         	lsls	r0, r1
700a143e: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a1440: 9806         	ldr	r0, [sp, #0x18]
700a1442: 9904         	ldr	r1, [sp, #0x10]
700a1444: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1448: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a144c: 9902         	ldr	r1, [sp, #0x8]
700a144e: 4008         	ands	r0, r1
700a1450: 4288         	cmp	r0, r1
700a1452: d111         	bne	0x700a1478 <Udma_rmAllocIrIntr+0x98> @ imm = #0x22
700a1454: e7ff         	b	0x700a1456 <Udma_rmAllocIrIntr+0x76> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a1456: 9a02         	ldr	r2, [sp, #0x8]
700a1458: 9806         	ldr	r0, [sp, #0x18]
700a145a: 9904         	ldr	r1, [sp, #0x10]
700a145c: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1460: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a1464: 4390         	bics	r0, r2
700a1466: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = i + rmInitPrms->startIrIntr;    /* Add start offset */
700a146a: 9805         	ldr	r0, [sp, #0x14]
700a146c: 9900         	ldr	r1, [sp]
700a146e: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a1472: 4408         	add	r0, r1
700a1474: 9001         	str	r0, [sp, #0x4]
;                 break;
700a1476: e004         	b	0x700a1482 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x8
;         }
700a1478: e7ff         	b	0x700a147a <Udma_rmAllocIrIntr+0x9a> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a147a: 9805         	ldr	r0, [sp, #0x14]
700a147c: 3001         	adds	r0, #0x1
700a147e: 9005         	str	r0, [sp, #0x14]
700a1480: e7cb         	b	0x700a141a <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x6a
;     }
700a1482: e03c         	b	0x700a14fe <Udma_rmAllocIrIntr+0x11e> @ imm = #0x78
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a1484: 9807         	ldr	r0, [sp, #0x1c]
700a1486: 9900         	ldr	r1, [sp]
700a1488: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a148c: 4288         	cmp	r0, r1
700a148e: d335         	blo	0x700a14fc <Udma_rmAllocIrIntr+0x11c> @ imm = #0x6a
700a1490: e7ff         	b	0x700a1492 <Udma_rmAllocIrIntr+0xb2> @ imm = #-0x2
;            (preferredIrIntrNum < (rmInitPrms->startIrIntr + rmInitPrms->numIrIntr)))
700a1492: 9807         	ldr	r0, [sp, #0x1c]
700a1494: 9a00         	ldr	r2, [sp]
700a1496: f8d2 10e8    	ldr.w	r1, [r2, #0xe8]
700a149a: f8d2 20ec    	ldr.w	r2, [r2, #0xec]
700a149e: 4411         	add	r1, r2
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a14a0: 4288         	cmp	r0, r1
700a14a2: d22b         	bhs	0x700a14fc <Udma_rmAllocIrIntr+0x11c> @ imm = #0x56
700a14a4: e7ff         	b	0x700a14a6 <Udma_rmAllocIrIntr+0xc6> @ imm = #-0x2
;             i = preferredIrIntrNum - rmInitPrms->startIrIntr;
700a14a6: 9807         	ldr	r0, [sp, #0x1c]
700a14a8: 9900         	ldr	r1, [sp]
700a14aa: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a14ae: 1a40         	subs	r0, r0, r1
700a14b0: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a14b2: 9805         	ldr	r0, [sp, #0x14]
700a14b4: 0940         	lsrs	r0, r0, #0x5
700a14b6: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a14b8: 9805         	ldr	r0, [sp, #0x14]
700a14ba: 9904         	ldr	r1, [sp, #0x10]
700a14bc: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a14c0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a14c2: 9903         	ldr	r1, [sp, #0xc]
700a14c4: 2001         	movs	r0, #0x1
700a14c6: 4088         	lsls	r0, r1
700a14c8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a14ca: 9806         	ldr	r0, [sp, #0x18]
700a14cc: 9904         	ldr	r1, [sp, #0x10]
700a14ce: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a14d2: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a14d6: 9902         	ldr	r1, [sp, #0x8]
700a14d8: 4008         	ands	r0, r1
700a14da: 4288         	cmp	r0, r1
700a14dc: d10d         	bne	0x700a14fa <Udma_rmAllocIrIntr+0x11a> @ imm = #0x1a
700a14de: e7ff         	b	0x700a14e0 <Udma_rmAllocIrIntr+0x100> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a14e0: 9a02         	ldr	r2, [sp, #0x8]
700a14e2: 9806         	ldr	r0, [sp, #0x18]
700a14e4: 9904         	ldr	r1, [sp, #0x10]
700a14e6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a14ea: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a14ee: 4390         	bics	r0, r2
700a14f0: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = preferredIrIntrNum;
700a14f4: 9807         	ldr	r0, [sp, #0x1c]
700a14f6: 9001         	str	r0, [sp, #0x4]
;             }
700a14f8: e7ff         	b	0x700a14fa <Udma_rmAllocIrIntr+0x11a> @ imm = #-0x2
;         }
700a14fa: e7ff         	b	0x700a14fc <Udma_rmAllocIrIntr+0x11c> @ imm = #-0x2
700a14fc: e7ff         	b	0x700a14fe <Udma_rmAllocIrIntr+0x11e> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a14fe: 9806         	ldr	r0, [sp, #0x18]
700a1500: f500 609f    	add.w	r0, r0, #0x4f8
700a1504: f008 fc44    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x8888
;     return (irIntrNum);
700a1508: 9801         	ldr	r0, [sp, #0x4]
700a150a: b008         	add	sp, #0x20
700a150c: bd80         	pop	{r7, pc}
700a150e: 0000         	movs	r0, r0

700a1510 <xQueueGenericSend>:
; {
700a1510: b580         	push	{r7, lr}
700a1512: b08a         	sub	sp, #0x28
700a1514: 9008         	str	r0, [sp, #0x20]
700a1516: 9107         	str	r1, [sp, #0x1c]
700a1518: 9206         	str	r2, [sp, #0x18]
700a151a: 9305         	str	r3, [sp, #0x14]
700a151c: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
700a151e: 9004         	str	r0, [sp, #0x10]
;     Queue_t * const pxQueue = xQueue;
700a1520: 9808         	ldr	r0, [sp, #0x20]
700a1522: 9000         	str	r0, [sp]
;     for( ; ; )
700a1524: e7ff         	b	0x700a1526 <xQueueGenericSend+0x16> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a1526: f00a ff63    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0xaec6
;             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a152a: 9800         	ldr	r0, [sp]
700a152c: 6b80         	ldr	r0, [r0, #0x38]
700a152e: 9900         	ldr	r1, [sp]
700a1530: 6bc9         	ldr	r1, [r1, #0x3c]
700a1532: 4288         	cmp	r0, r1
700a1534: d304         	blo	0x700a1540 <xQueueGenericSend+0x30> @ imm = #0x8
700a1536: e7ff         	b	0x700a1538 <xQueueGenericSend+0x28> @ imm = #-0x2
700a1538: 9805         	ldr	r0, [sp, #0x14]
700a153a: 2802         	cmp	r0, #0x2
700a153c: d120         	bne	0x700a1580 <xQueueGenericSend+0x70> @ imm = #0x40
700a153e: e7ff         	b	0x700a1540 <xQueueGenericSend+0x30> @ imm = #-0x2
;                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a1540: 9800         	ldr	r0, [sp]
700a1542: 9907         	ldr	r1, [sp, #0x1c]
700a1544: 9a05         	ldr	r2, [sp, #0x14]
700a1546: f003 fa23    	bl	0x700a4990 <prvCopyDataToQueue> @ imm = #0x3446
700a154a: 9003         	str	r0, [sp, #0xc]
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a154c: 9800         	ldr	r0, [sp]
700a154e: 6a40         	ldr	r0, [r0, #0x24]
700a1550: b150         	cbz	r0, 0x700a1568 <xQueueGenericSend+0x58> @ imm = #0x14
700a1552: e7ff         	b	0x700a1554 <xQueueGenericSend+0x44> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a1554: 9800         	ldr	r0, [sp]
700a1556: 3024         	adds	r0, #0x24
700a1558: f004 fe92    	bl	0x700a6280 <xTaskRemoveFromEventList> @ imm = #0x4d24
700a155c: b110         	cbz	r0, 0x700a1564 <xQueueGenericSend+0x54> @ imm = #0x4
700a155e: e7ff         	b	0x700a1560 <xQueueGenericSend+0x50> @ imm = #-0x2
;                                 queueYIELD_IF_USING_PREEMPTION();
700a1560: df00         	svc	#0x0
;                             }
700a1562: e000         	b	0x700a1566 <xQueueGenericSend+0x56> @ imm = #0x0
700a1564: e7ff         	b	0x700a1566 <xQueueGenericSend+0x56> @ imm = #-0x2
;                         }
700a1566: e006         	b	0x700a1576 <xQueueGenericSend+0x66> @ imm = #0xc
;                         else if( xYieldRequired != pdFALSE )
700a1568: 9803         	ldr	r0, [sp, #0xc]
700a156a: b110         	cbz	r0, 0x700a1572 <xQueueGenericSend+0x62> @ imm = #0x4
700a156c: e7ff         	b	0x700a156e <xQueueGenericSend+0x5e> @ imm = #-0x2
;                             queueYIELD_IF_USING_PREEMPTION();
700a156e: df00         	svc	#0x0
;                         }
700a1570: e000         	b	0x700a1574 <xQueueGenericSend+0x64> @ imm = #0x0
700a1572: e7ff         	b	0x700a1574 <xQueueGenericSend+0x64> @ imm = #-0x2
700a1574: e7ff         	b	0x700a1576 <xQueueGenericSend+0x66> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a1576: f00a f83b    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xa076
700a157a: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a157c: 9009         	str	r0, [sp, #0x24]
700a157e: e05b         	b	0x700a1638 <xQueueGenericSend+0x128> @ imm = #0xb6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a1580: 9806         	ldr	r0, [sp, #0x18]
700a1582: b928         	cbnz	r0, 0x700a1590 <xQueueGenericSend+0x80> @ imm = #0xa
700a1584: e7ff         	b	0x700a1586 <xQueueGenericSend+0x76> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a1586: f00a f833    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xa066
700a158a: 2000         	movs	r0, #0x0
;                     return errQUEUE_FULL;
700a158c: 9009         	str	r0, [sp, #0x24]
700a158e: e053         	b	0x700a1638 <xQueueGenericSend+0x128> @ imm = #0xa6
;                 else if( xEntryTimeSet == pdFALSE )
700a1590: 9804         	ldr	r0, [sp, #0x10]
700a1592: b930         	cbnz	r0, 0x700a15a2 <xQueueGenericSend+0x92> @ imm = #0xc
700a1594: e7ff         	b	0x700a1596 <xQueueGenericSend+0x86> @ imm = #-0x2
700a1596: a801         	add	r0, sp, #0x4
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a1598: f00b fc5a    	bl	0x700ace50 <vTaskInternalSetTimeOutState> @ imm = #0xb8b4
700a159c: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a159e: 9004         	str	r0, [sp, #0x10]
;                 }
700a15a0: e000         	b	0x700a15a4 <xQueueGenericSend+0x94> @ imm = #0x0
700a15a2: e7ff         	b	0x700a15a4 <xQueueGenericSend+0x94> @ imm = #-0x2
700a15a4: e7ff         	b	0x700a15a6 <xQueueGenericSend+0x96> @ imm = #-0x2
700a15a6: e7ff         	b	0x700a15a8 <xQueueGenericSend+0x98> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a15a8: f00a f822    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xa044
;         vTaskSuspendAll();
700a15ac: f00c f868    	bl	0x700ad680 <vTaskSuspendAll> @ imm = #0xc0d0
;         prvLockQueue( pxQueue );
700a15b0: f00a ff1e    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0xae3c
700a15b4: 9800         	ldr	r0, [sp]
700a15b6: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a15ba: 3001         	adds	r0, #0x1
700a15bc: b928         	cbnz	r0, 0x700a15ca <xQueueGenericSend+0xba> @ imm = #0xa
700a15be: e7ff         	b	0x700a15c0 <xQueueGenericSend+0xb0> @ imm = #-0x2
700a15c0: 9900         	ldr	r1, [sp]
700a15c2: 2000         	movs	r0, #0x0
700a15c4: f881 0044    	strb.w	r0, [r1, #0x44]
700a15c8: e7ff         	b	0x700a15ca <xQueueGenericSend+0xba> @ imm = #-0x2
700a15ca: 9800         	ldr	r0, [sp]
700a15cc: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a15d0: 3001         	adds	r0, #0x1
700a15d2: b928         	cbnz	r0, 0x700a15e0 <xQueueGenericSend+0xd0> @ imm = #0xa
700a15d4: e7ff         	b	0x700a15d6 <xQueueGenericSend+0xc6> @ imm = #-0x2
700a15d6: 9900         	ldr	r1, [sp]
700a15d8: 2000         	movs	r0, #0x0
700a15da: f881 0045    	strb.w	r0, [r1, #0x45]
700a15de: e7ff         	b	0x700a15e0 <xQueueGenericSend+0xd0> @ imm = #-0x2
700a15e0: f00a f806    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xa00c
700a15e4: a801         	add	r0, sp, #0x4
700a15e6: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a15e8: f005 fd7a    	bl	0x700a70e0 <xTaskCheckForTimeOut> @ imm = #0x5af4
700a15ec: b9d8         	cbnz	r0, 0x700a1626 <xQueueGenericSend+0x116> @ imm = #0x36
700a15ee: e7ff         	b	0x700a15f0 <xQueueGenericSend+0xe0> @ imm = #-0x2
;             if( prvIsQueueFull( pxQueue ) != pdFALSE )
700a15f0: 9800         	ldr	r0, [sp]
700a15f2: f00b f815    	bl	0x700ac620 <prvIsQueueFull> @ imm = #0xb02a
700a15f6: b178         	cbz	r0, 0x700a1618 <xQueueGenericSend+0x108> @ imm = #0x1e
700a15f8: e7ff         	b	0x700a15fa <xQueueGenericSend+0xea> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
700a15fa: 9800         	ldr	r0, [sp]
700a15fc: 3010         	adds	r0, #0x10
700a15fe: 9906         	ldr	r1, [sp, #0x18]
700a1600: f00b fb26    	bl	0x700acc50 <vTaskPlaceOnEventList> @ imm = #0xb64c
;                 prvUnlockQueue( pxQueue );
700a1604: 9800         	ldr	r0, [sp]
700a1606: f004 fb7b    	bl	0x700a5d00 <prvUnlockQueue> @ imm = #0x46f6
;                 if( xTaskResumeAll() == pdFALSE )
700a160a: f7ff fa91    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0xade
700a160e: b910         	cbnz	r0, 0x700a1616 <xQueueGenericSend+0x106> @ imm = #0x4
700a1610: e7ff         	b	0x700a1612 <xQueueGenericSend+0x102> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a1612: df00         	svc	#0x0
;                 }
700a1614: e7ff         	b	0x700a1616 <xQueueGenericSend+0x106> @ imm = #-0x2
;             }
700a1616: e005         	b	0x700a1624 <xQueueGenericSend+0x114> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a1618: 9800         	ldr	r0, [sp]
700a161a: f004 fb71    	bl	0x700a5d00 <prvUnlockQueue> @ imm = #0x46e2
;                 ( void ) xTaskResumeAll();
700a161e: f7ff fa87    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0xaf2
700a1622: e7ff         	b	0x700a1624 <xQueueGenericSend+0x114> @ imm = #-0x2
;         }
700a1624: e007         	b	0x700a1636 <xQueueGenericSend+0x126> @ imm = #0xe
;             prvUnlockQueue( pxQueue );
700a1626: 9800         	ldr	r0, [sp]
700a1628: f004 fb6a    	bl	0x700a5d00 <prvUnlockQueue> @ imm = #0x46d4
;             ( void ) xTaskResumeAll();
700a162c: f7ff fa80    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0xb00
700a1630: 2000         	movs	r0, #0x0
;             return errQUEUE_FULL;
700a1632: 9009         	str	r0, [sp, #0x24]
700a1634: e000         	b	0x700a1638 <xQueueGenericSend+0x128> @ imm = #0x0
;     for( ; ; )
700a1636: e776         	b	0x700a1526 <xQueueGenericSend+0x16> @ imm = #-0x114
; }
700a1638: 9809         	ldr	r0, [sp, #0x24]
700a163a: b00a         	add	sp, #0x28
700a163c: bd80         	pop	{r7, pc}
700a163e: 0000         	movs	r0, r0

700a1640 <UART_lld_init>:
; {
700a1640: b580         	push	{r7, lr}
700a1642: b084         	sub	sp, #0x10
700a1644: 9003         	str	r0, [sp, #0xc]
700a1646: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a1648: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a164a: 9803         	ldr	r0, [sp, #0xc]
700a164c: b168         	cbz	r0, 0x700a166a <UART_lld_init+0x2a> @ imm = #0x1a
700a164e: e7ff         	b	0x700a1650 <UART_lld_init+0x10> @ imm = #-0x2
700a1650: 9803         	ldr	r0, [sp, #0xc]
700a1652: 6840         	ldr	r0, [r0, #0x4]
700a1654: b148         	cbz	r0, 0x700a166a <UART_lld_init+0x2a> @ imm = #0x12
700a1656: e7ff         	b	0x700a1658 <UART_lld_init+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a1658: 9803         	ldr	r0, [sp, #0xc]
700a165a: 6d40         	ldr	r0, [r0, #0x54]
700a165c: b120         	cbz	r0, 0x700a1668 <UART_lld_init+0x28> @ imm = #0x8
700a165e: e7ff         	b	0x700a1660 <UART_lld_init+0x20> @ imm = #-0x2
700a1660: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a1664: 9002         	str	r0, [sp, #0x8]
;         }
700a1666: e7ff         	b	0x700a1668 <UART_lld_init+0x28> @ imm = #-0x2
;     }
700a1668: e003         	b	0x700a1672 <UART_lld_init+0x32> @ imm = #0x6
700a166a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a166e: 9002         	str	r0, [sp, #0x8]
700a1670: e7ff         	b	0x700a1672 <UART_lld_init+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a1672: 9802         	ldr	r0, [sp, #0x8]
700a1674: 2800         	cmp	r0, #0x0
700a1676: d176         	bne	0x700a1766 <UART_lld_init+0x126> @ imm = #0xec
700a1678: e7ff         	b	0x700a167a <UART_lld_init+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a167a: 9903         	ldr	r1, [sp, #0xc]
700a167c: 2002         	movs	r0, #0x2
700a167e: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a1680: 9803         	ldr	r0, [sp, #0xc]
700a1682: 6840         	ldr	r0, [r0, #0x4]
700a1684: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a1686: 9801         	ldr	r0, [sp, #0x4]
700a1688: 6d82         	ldr	r2, [r0, #0x58]
700a168a: f244 2040    	movw	r0, #0x4240
700a168e: f2c0 000f    	movt	r0, #0xf
700a1692: 2100         	movs	r1, #0x0
700a1694: 9100         	str	r1, [sp]
700a1696: 4790         	blx	r2
700a1698: 9a00         	ldr	r2, [sp]
700a169a: 9903         	ldr	r1, [sp, #0xc]
700a169c: 66ca         	str	r2, [r1, #0x6c]
700a169e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a16a0: 9803         	ldr	r0, [sp, #0xc]
700a16a2: 6800         	ldr	r0, [r0]
700a16a4: f005 f854    	bl	0x700a6750 <UART_IsBaseAddrValid> @ imm = #0x50a8
700a16a8: 4601         	mov	r1, r0
700a16aa: 9802         	ldr	r0, [sp, #0x8]
700a16ac: 4408         	add	r0, r1
700a16ae: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a16b0: 9801         	ldr	r0, [sp, #0x4]
700a16b2: 6800         	ldr	r0, [r0]
700a16b4: f00b fd24    	bl	0x700ad100 <UART_IsParameter> @ imm = #0xba48
700a16b8: 4601         	mov	r1, r0
700a16ba: 9802         	ldr	r0, [sp, #0x8]
700a16bc: 4408         	add	r0, r1
700a16be: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a16c0: 9801         	ldr	r0, [sp, #0x4]
700a16c2: 6840         	ldr	r0, [r0, #0x4]
700a16c4: f00b fd1c    	bl	0x700ad100 <UART_IsParameter> @ imm = #0xba38
700a16c8: 4601         	mov	r1, r0
700a16ca: 9802         	ldr	r0, [sp, #0x8]
700a16cc: 4408         	add	r0, r1
700a16ce: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a16d0: 9801         	ldr	r0, [sp, #0x4]
700a16d2: 6880         	ldr	r0, [r0, #0x8]
700a16d4: f00a fd94    	bl	0x700ac200 <UART_IsDataLengthValid> @ imm = #0xab28
700a16d8: 4601         	mov	r1, r0
700a16da: 9802         	ldr	r0, [sp, #0x8]
700a16dc: 4408         	add	r0, r1
700a16de: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a16e0: 9801         	ldr	r0, [sp, #0x4]
700a16e2: 68c0         	ldr	r0, [r0, #0xc]
700a16e4: f00b fb5c    	bl	0x700acda0 <UART_IsStopBitsValid> @ imm = #0xb6b8
700a16e8: 4601         	mov	r1, r0
700a16ea: 9802         	ldr	r0, [sp, #0x8]
700a16ec: 4408         	add	r0, r1
700a16ee: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a16f0: 9801         	ldr	r0, [sp, #0x4]
700a16f2: 6900         	ldr	r0, [r0, #0x10]
700a16f4: f00a fb24    	bl	0x700abd40 <UART_IsParityTypeValid> @ imm = #0xa648
700a16f8: 4601         	mov	r1, r0
700a16fa: 9802         	ldr	r0, [sp, #0x8]
700a16fc: 4408         	add	r0, r1
700a16fe: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a1700: 9801         	ldr	r0, [sp, #0x4]
700a1702: 69c0         	ldr	r0, [r0, #0x1c]
700a1704: f00a f9dc    	bl	0x700abac0 <UART_IsHWFlowCtrlValid> @ imm = #0xa3b8
700a1708: 4601         	mov	r1, r0
700a170a: 9802         	ldr	r0, [sp, #0x8]
700a170c: 4408         	add	r0, r1
700a170e: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a1710: 9801         	ldr	r0, [sp, #0x4]
700a1712: 6ac0         	ldr	r0, [r0, #0x2c]
700a1714: f009 fa84    	bl	0x700aac20 <UART_OperModeValid> @ imm = #0x9508
700a1718: 4601         	mov	r1, r0
700a171a: 9802         	ldr	r0, [sp, #0x8]
700a171c: 4408         	add	r0, r1
700a171e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a1720: 9801         	ldr	r0, [sp, #0x4]
700a1722: 6b80         	ldr	r0, [r0, #0x38]
700a1724: f00a f9ec    	bl	0x700abb00 <UART_IsRxTrigLvlValid> @ imm = #0xa3d8
700a1728: 4601         	mov	r1, r0
700a172a: 9802         	ldr	r0, [sp, #0x8]
700a172c: 4408         	add	r0, r1
700a172e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a1730: 9801         	ldr	r0, [sp, #0x4]
700a1732: 6bc0         	ldr	r0, [r0, #0x3c]
700a1734: f00a fa04    	bl	0x700abb40 <UART_IsTxTrigLvlValid> @ imm = #0xa408
700a1738: 4601         	mov	r1, r0
700a173a: 9802         	ldr	r0, [sp, #0x8]
700a173c: 4408         	add	r0, r1
700a173e: 9002         	str	r0, [sp, #0x8]
;         if(UART_STATUS_SUCCESS == status)
700a1740: 9802         	ldr	r0, [sp, #0x8]
700a1742: b938         	cbnz	r0, 0x700a1754 <UART_lld_init+0x114> @ imm = #0xe
700a1744: e7ff         	b	0x700a1746 <UART_lld_init+0x106> @ imm = #-0x2
;             UART_configInstance(hUart);
700a1746: 9803         	ldr	r0, [sp, #0xc]
700a1748: f001 fef2    	bl	0x700a3530 <UART_configInstance> @ imm = #0x1de4
;             hUart->state = UART_STATE_READY;
700a174c: 9903         	ldr	r1, [sp, #0xc]
700a174e: 2001         	movs	r0, #0x1
700a1750: 6548         	str	r0, [r1, #0x54]
;         }
700a1752: e007         	b	0x700a1764 <UART_lld_init+0x124> @ imm = #0xe
;             status += UART_lld_deInit(hUart);
700a1754: 9803         	ldr	r0, [sp, #0xc]
700a1756: f008 fea3    	bl	0x700aa4a0 <UART_lld_deInit> @ imm = #0x8d46
700a175a: 4601         	mov	r1, r0
700a175c: 9802         	ldr	r0, [sp, #0x8]
700a175e: 4408         	add	r0, r1
700a1760: 9002         	str	r0, [sp, #0x8]
700a1762: e7ff         	b	0x700a1764 <UART_lld_init+0x124> @ imm = #-0x2
;     }
700a1764: e7ff         	b	0x700a1766 <UART_lld_init+0x126> @ imm = #-0x2
;     return status;
700a1766: 9802         	ldr	r0, [sp, #0x8]
700a1768: b004         	add	sp, #0x10
700a176a: bd80         	pop	{r7, pc}
700a176c: 0000         	movs	r0, r0
700a176e: 0000         	movs	r0, r0

700a1770 <Sciclient_pmQueryModuleClkFreq>:
; {
700a1770: b580         	push	{r7, lr}
700a1772: b09e         	sub	sp, #0x78
700a1774: f8dd c084    	ldr.w	r12, [sp, #0x84]
700a1778: f8dd c080    	ldr.w	r12, [sp, #0x80]
700a177c: 901d         	str	r0, [sp, #0x74]
700a177e: 911c         	str	r1, [sp, #0x70]
700a1780: 931b         	str	r3, [sp, #0x6c]
700a1782: 921a         	str	r2, [sp, #0x68]
700a1784: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a1786: 9019         	str	r0, [sp, #0x64]
;     request.device         = (uint32_t) moduleId;
700a1788: 981d         	ldr	r0, [sp, #0x74]
700a178a: 9010         	str	r0, [sp, #0x40]
;     request.min_freq_hz    = (uint64_t) reqFreqHz;
700a178c: 981a         	ldr	r0, [sp, #0x68]
700a178e: 991b         	ldr	r1, [sp, #0x6c]
700a1790: 9112         	str	r1, [sp, #0x48]
700a1792: 9011         	str	r0, [sp, #0x44]
;     request.target_freq_hz = (uint64_t) reqFreqHz;
700a1794: 981a         	ldr	r0, [sp, #0x68]
700a1796: 991b         	ldr	r1, [sp, #0x6c]
700a1798: 9114         	str	r1, [sp, #0x50]
700a179a: 9013         	str	r0, [sp, #0x4c]
;     request.max_freq_hz    = (uint64_t) reqFreqHz;
700a179c: 981a         	ldr	r0, [sp, #0x68]
700a179e: 991b         	ldr	r1, [sp, #0x6c]
700a17a0: 9116         	str	r1, [sp, #0x58]
700a17a2: 9015         	str	r0, [sp, #0x54]
;     if((reqFreqHz%10U) != 0U)
700a17a4: 9b1a         	ldr	r3, [sp, #0x68]
700a17a6: 981b         	ldr	r0, [sp, #0x6c]
700a17a8: f64c 41cd    	movw	r1, #0xcccd
700a17ac: f6cc 41cc    	movt	r1, #0xcccc
700a17b0: fba3 2e01    	umull	r2, lr, r3, r1
700a17b4: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a17b8: fb03 e30c    	mla	r3, r3, r12, lr
700a17bc: fb00 3101    	mla	r1, r0, r1, r3
700a17c0: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a17c4: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a17c8: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a17cc: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a17d0: f649 129a    	movw	r2, #0x999a
700a17d4: f6c9 1299    	movt	r2, #0x9999
700a17d8: 1a89         	subs	r1, r1, r2
700a17da: f649 1199    	movw	r1, #0x9999
700a17de: f6c1 1199    	movt	r1, #0x1999
700a17e2: 4188         	sbcs	r0, r1
700a17e4: d316         	blo	0x700a1814 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #0x2c
700a17e6: e7ff         	b	0x700a17e8 <Sciclient_pmQueryModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(reqFreqHz-(reqFreqHz%10U));
700a17e8: 981a         	ldr	r0, [sp, #0x68]
700a17ea: 9001         	str	r0, [sp, #0x4]
700a17ec: 991b         	ldr	r1, [sp, #0x6c]
700a17ee: 9100         	str	r1, [sp]
700a17f0: 220a         	movs	r2, #0xa
700a17f2: 2300         	movs	r3, #0x0
700a17f4: f00b eae6    	blx	0x700acdc4 <__aeabi_uldivmod> @ imm = #0xb5cc
700a17f8: 9800         	ldr	r0, [sp]
700a17fa: 9901         	ldr	r1, [sp, #0x4]
700a17fc: 1a89         	subs	r1, r1, r2
700a17fe: 4198         	sbcs	r0, r3
700a1800: 9111         	str	r1, [sp, #0x44]
700a1802: 9012         	str	r0, [sp, #0x48]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a1804: 9911         	ldr	r1, [sp, #0x44]
700a1806: 9812         	ldr	r0, [sp, #0x48]
700a1808: 310a         	adds	r1, #0xa
700a180a: f140 0000    	adc	r0, r0, #0x0
700a180e: 9115         	str	r1, [sp, #0x54]
700a1810: 9016         	str	r0, [sp, #0x58]
;     }
700a1812: e7ff         	b	0x700a1814 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a1814: 981c         	ldr	r0, [sp, #0x70]
700a1816: 28ff         	cmp	r0, #0xff
700a1818: d307         	blo	0x700a182a <Sciclient_pmQueryModuleClkFreq+0xba> @ imm = #0xe
700a181a: e7ff         	b	0x700a181c <Sciclient_pmQueryModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a181c: 981c         	ldr	r0, [sp, #0x70]
700a181e: f8cd 005d    	str.w	r0, [sp, #0x5d]
700a1822: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a1824: f88d 005c    	strb.w	r0, [sp, #0x5c]
;     }
700a1828: e003         	b	0x700a1832 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a182a: 981c         	ldr	r0, [sp, #0x70]
700a182c: f88d 005c    	strb.w	r0, [sp, #0x5c]
700a1830: e7ff         	b	0x700a1832 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #-0x2
700a1832: 2000         	movs	r0, #0x0
;     struct tisci_msg_query_freq_resp response = {{0}};
700a1834: 900d         	str	r0, [sp, #0x34]
700a1836: 900c         	str	r0, [sp, #0x30]
700a1838: 900b         	str	r0, [sp, #0x2c]
700a183a: 900a         	str	r0, [sp, #0x28]
700a183c: f240 110d    	movw	r1, #0x10d
;     reqParam.messageType    = (uint16_t) TISCI_MSG_QUERY_FREQ;
700a1840: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a1844: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a1846: 9106         	str	r1, [sp, #0x18]
700a1848: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a184a: 9107         	str	r1, [sp, #0x1c]
700a184c: 2129         	movs	r1, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a184e: 9108         	str	r1, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a1850: 9921         	ldr	r1, [sp, #0x84]
700a1852: 9109         	str	r1, [sp, #0x24]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a1854: 9002         	str	r0, [sp, #0x8]
700a1856: a80a         	add	r0, sp, #0x28
;     respParam.pRespPayload    = (uint8_t *) &response;
700a1858: 9003         	str	r0, [sp, #0xc]
700a185a: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a185c: 9004         	str	r0, [sp, #0x10]
700a185e: a805         	add	r0, sp, #0x14
700a1860: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a1862: f7fa fb0d    	bl	0x7009be80 <Sciclient_service> @ imm = #-0x59e6
700a1866: 9019         	str	r0, [sp, #0x64]
;     if((retVal != SystemP_SUCCESS) ||
700a1868: 9819         	ldr	r0, [sp, #0x64]
700a186a: b930         	cbnz	r0, 0x700a187a <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #0xc
700a186c: e7ff         	b	0x700a186e <Sciclient_pmQueryModuleClkFreq+0xfe> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a186e: 9802         	ldr	r0, [sp, #0x8]
700a1870: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a1874: 2802         	cmp	r0, #0x2
700a1876: d004         	beq	0x700a1882 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #0x8
700a1878: e7ff         	b	0x700a187a <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #-0x2
700a187a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a187e: 9019         	str	r0, [sp, #0x64]
;     }
700a1880: e7ff         	b	0x700a1882 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a1882: 9819         	ldr	r0, [sp, #0x64]
700a1884: b930         	cbnz	r0, 0x700a1894 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #0xc
700a1886: e7ff         	b	0x700a1888 <Sciclient_pmQueryModuleClkFreq+0x118> @ imm = #-0x2
;         *respFreqHz = (uint64_t) response.freq_hz;
700a1888: 980c         	ldr	r0, [sp, #0x30]
700a188a: 9a0d         	ldr	r2, [sp, #0x34]
700a188c: 9920         	ldr	r1, [sp, #0x80]
700a188e: 604a         	str	r2, [r1, #0x4]
700a1890: 6008         	str	r0, [r1]
;     }
700a1892: e7ff         	b	0x700a1894 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #-0x2
;     return retVal;
700a1894: 9819         	ldr	r0, [sp, #0x64]
700a1896: b01e         	add	sp, #0x78
700a1898: bd80         	pop	{r7, pc}
700a189a: 0000         	movs	r0, r0
700a189c: 0000         	movs	r0, r0
700a189e: 0000         	movs	r0, r0

700a18a0 <xQueueReceive>:
; {
700a18a0: b580         	push	{r7, lr}
700a18a2: b08a         	sub	sp, #0x28
700a18a4: 9008         	str	r0, [sp, #0x20]
700a18a6: 9107         	str	r1, [sp, #0x1c]
700a18a8: 9206         	str	r2, [sp, #0x18]
700a18aa: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
700a18ac: 9005         	str	r0, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a18ae: 9808         	ldr	r0, [sp, #0x20]
700a18b0: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
700a18b2: e7ff         	b	0x700a18b4 <xQueueReceive+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a18b4: f00a fd9c    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0xab38
;             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a18b8: 9802         	ldr	r0, [sp, #0x8]
700a18ba: 6b80         	ldr	r0, [r0, #0x38]
700a18bc: 9001         	str	r0, [sp, #0x4]
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a18be: 9801         	ldr	r0, [sp, #0x4]
700a18c0: b1e0         	cbz	r0, 0x700a18fc <xQueueReceive+0x5c> @ imm = #0x38
700a18c2: e7ff         	b	0x700a18c4 <xQueueReceive+0x24> @ imm = #-0x2
;                 prvCopyDataFromQueue( pxQueue, pvBuffer );
700a18c4: 9802         	ldr	r0, [sp, #0x8]
700a18c6: 9907         	ldr	r1, [sp, #0x1c]
700a18c8: f009 fff2    	bl	0x700ab8b0 <prvCopyDataFromQueue> @ imm = #0x9fe4
;                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a18cc: 9801         	ldr	r0, [sp, #0x4]
700a18ce: 3801         	subs	r0, #0x1
700a18d0: 9902         	ldr	r1, [sp, #0x8]
700a18d2: 6388         	str	r0, [r1, #0x38]
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a18d4: 9802         	ldr	r0, [sp, #0x8]
700a18d6: 6900         	ldr	r0, [r0, #0x10]
700a18d8: b150         	cbz	r0, 0x700a18f0 <xQueueReceive+0x50> @ imm = #0x14
700a18da: e7ff         	b	0x700a18dc <xQueueReceive+0x3c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a18dc: 9802         	ldr	r0, [sp, #0x8]
700a18de: 3010         	adds	r0, #0x10
700a18e0: f004 fcce    	bl	0x700a6280 <xTaskRemoveFromEventList> @ imm = #0x499c
700a18e4: b110         	cbz	r0, 0x700a18ec <xQueueReceive+0x4c> @ imm = #0x4
700a18e6: e7ff         	b	0x700a18e8 <xQueueReceive+0x48> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
700a18e8: df00         	svc	#0x0
;                     }
700a18ea: e000         	b	0x700a18ee <xQueueReceive+0x4e> @ imm = #0x0
700a18ec: e7ff         	b	0x700a18ee <xQueueReceive+0x4e> @ imm = #-0x2
;                 }
700a18ee: e000         	b	0x700a18f2 <xQueueReceive+0x52> @ imm = #0x0
700a18f0: e7ff         	b	0x700a18f2 <xQueueReceive+0x52> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a18f2: f009 fe7d    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x9cfa
700a18f6: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a18f8: 9009         	str	r0, [sp, #0x24]
700a18fa: e063         	b	0x700a19c4 <xQueueReceive+0x124> @ imm = #0xc6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a18fc: 9806         	ldr	r0, [sp, #0x18]
700a18fe: b928         	cbnz	r0, 0x700a190c <xQueueReceive+0x6c> @ imm = #0xa
700a1900: e7ff         	b	0x700a1902 <xQueueReceive+0x62> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a1902: f009 fe75    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x9cea
700a1906: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
700a1908: 9009         	str	r0, [sp, #0x24]
700a190a: e05b         	b	0x700a19c4 <xQueueReceive+0x124> @ imm = #0xb6
;                 else if( xEntryTimeSet == pdFALSE )
700a190c: 9805         	ldr	r0, [sp, #0x14]
700a190e: b930         	cbnz	r0, 0x700a191e <xQueueReceive+0x7e> @ imm = #0xc
700a1910: e7ff         	b	0x700a1912 <xQueueReceive+0x72> @ imm = #-0x2
700a1912: a803         	add	r0, sp, #0xc
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a1914: f00b fa9c    	bl	0x700ace50 <vTaskInternalSetTimeOutState> @ imm = #0xb538
700a1918: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a191a: 9005         	str	r0, [sp, #0x14]
;                 }
700a191c: e000         	b	0x700a1920 <xQueueReceive+0x80> @ imm = #0x0
700a191e: e7ff         	b	0x700a1920 <xQueueReceive+0x80> @ imm = #-0x2
700a1920: e7ff         	b	0x700a1922 <xQueueReceive+0x82> @ imm = #-0x2
700a1922: e7ff         	b	0x700a1924 <xQueueReceive+0x84> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a1924: f009 fe64    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x9cc8
;         vTaskSuspendAll();
700a1928: f00b feaa    	bl	0x700ad680 <vTaskSuspendAll> @ imm = #0xbd54
;         prvLockQueue( pxQueue );
700a192c: f00a fd60    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0xaac0
700a1930: 9802         	ldr	r0, [sp, #0x8]
700a1932: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a1936: 3001         	adds	r0, #0x1
700a1938: b928         	cbnz	r0, 0x700a1946 <xQueueReceive+0xa6> @ imm = #0xa
700a193a: e7ff         	b	0x700a193c <xQueueReceive+0x9c> @ imm = #-0x2
700a193c: 9902         	ldr	r1, [sp, #0x8]
700a193e: 2000         	movs	r0, #0x0
700a1940: f881 0044    	strb.w	r0, [r1, #0x44]
700a1944: e7ff         	b	0x700a1946 <xQueueReceive+0xa6> @ imm = #-0x2
700a1946: 9802         	ldr	r0, [sp, #0x8]
700a1948: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a194c: 3001         	adds	r0, #0x1
700a194e: b928         	cbnz	r0, 0x700a195c <xQueueReceive+0xbc> @ imm = #0xa
700a1950: e7ff         	b	0x700a1952 <xQueueReceive+0xb2> @ imm = #-0x2
700a1952: 9902         	ldr	r1, [sp, #0x8]
700a1954: 2000         	movs	r0, #0x0
700a1956: f881 0045    	strb.w	r0, [r1, #0x45]
700a195a: e7ff         	b	0x700a195c <xQueueReceive+0xbc> @ imm = #-0x2
700a195c: f009 fe48    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x9c90
700a1960: a803         	add	r0, sp, #0xc
700a1962: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a1964: f005 fbbc    	bl	0x700a70e0 <xTaskCheckForTimeOut> @ imm = #0x5778
700a1968: b9e0         	cbnz	r0, 0x700a19a4 <xQueueReceive+0x104> @ imm = #0x38
700a196a: e7ff         	b	0x700a196c <xQueueReceive+0xcc> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a196c: 9802         	ldr	r0, [sp, #0x8]
700a196e: f00b f8af    	bl	0x700acad0 <prvIsQueueEmpty> @ imm = #0xb15e
700a1972: b180         	cbz	r0, 0x700a1996 <xQueueReceive+0xf6> @ imm = #0x20
700a1974: e7ff         	b	0x700a1976 <xQueueReceive+0xd6> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
700a1976: 9802         	ldr	r0, [sp, #0x8]
700a1978: 3024         	adds	r0, #0x24
700a197a: 9906         	ldr	r1, [sp, #0x18]
700a197c: f00b f968    	bl	0x700acc50 <vTaskPlaceOnEventList> @ imm = #0xb2d0
;                 prvUnlockQueue( pxQueue );
700a1980: 9802         	ldr	r0, [sp, #0x8]
700a1982: f004 f9bd    	bl	0x700a5d00 <prvUnlockQueue> @ imm = #0x437a
;                 if( xTaskResumeAll() == pdFALSE )
700a1986: f7ff f8d3    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0xe5a
700a198a: b910         	cbnz	r0, 0x700a1992 <xQueueReceive+0xf2> @ imm = #0x4
700a198c: e7ff         	b	0x700a198e <xQueueReceive+0xee> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a198e: df00         	svc	#0x0
;                 }
700a1990: e000         	b	0x700a1994 <xQueueReceive+0xf4> @ imm = #0x0
700a1992: e7ff         	b	0x700a1994 <xQueueReceive+0xf4> @ imm = #-0x2
;             }
700a1994: e005         	b	0x700a19a2 <xQueueReceive+0x102> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a1996: 9802         	ldr	r0, [sp, #0x8]
700a1998: f004 f9b2    	bl	0x700a5d00 <prvUnlockQueue> @ imm = #0x4364
;                 ( void ) xTaskResumeAll();
700a199c: f7ff f8c8    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0xe70
700a19a0: e7ff         	b	0x700a19a2 <xQueueReceive+0x102> @ imm = #-0x2
;         }
700a19a2: e00e         	b	0x700a19c2 <xQueueReceive+0x122> @ imm = #0x1c
;             prvUnlockQueue( pxQueue );
700a19a4: 9802         	ldr	r0, [sp, #0x8]
700a19a6: f004 f9ab    	bl	0x700a5d00 <prvUnlockQueue> @ imm = #0x4356
;             ( void ) xTaskResumeAll();
700a19aa: f7ff f8c1    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0xe7e
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a19ae: 9802         	ldr	r0, [sp, #0x8]
700a19b0: f00b f88e    	bl	0x700acad0 <prvIsQueueEmpty> @ imm = #0xb11c
700a19b4: b118         	cbz	r0, 0x700a19be <xQueueReceive+0x11e> @ imm = #0x6
700a19b6: e7ff         	b	0x700a19b8 <xQueueReceive+0x118> @ imm = #-0x2
700a19b8: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
700a19ba: 9009         	str	r0, [sp, #0x24]
700a19bc: e002         	b	0x700a19c4 <xQueueReceive+0x124> @ imm = #0x4
700a19be: e7ff         	b	0x700a19c0 <xQueueReceive+0x120> @ imm = #-0x2
700a19c0: e7ff         	b	0x700a19c2 <xQueueReceive+0x122> @ imm = #-0x2
;     for( ; ; )
700a19c2: e777         	b	0x700a18b4 <xQueueReceive+0x14> @ imm = #-0x112
; }
700a19c4: 9809         	ldr	r0, [sp, #0x24]
700a19c6: b00a         	add	sp, #0x28
700a19c8: bd80         	pop	{r7, pc}
700a19ca: 0000         	movs	r0, r0
700a19cc: 0000         	movs	r0, r0
700a19ce: 0000         	movs	r0, r0

700a19d0 <pxPortInitialiseStack>:
;                                    TaskFunction_t pxCode, void *pvParameters) {
700a19d0: b083         	sub	sp, #0xc
700a19d2: 9002         	str	r0, [sp, #0x8]
700a19d4: 9101         	str	r1, [sp, #0x4]
700a19d6: 9200         	str	r2, [sp]
;   *pxTopOfStack = (StackType_t)NULL;
700a19d8: 9902         	ldr	r1, [sp, #0x8]
700a19da: 2000         	movs	r0, #0x0
700a19dc: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a19de: 9902         	ldr	r1, [sp, #0x8]
700a19e0: 3904         	subs	r1, #0x4
700a19e2: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a19e4: 9902         	ldr	r1, [sp, #0x8]
700a19e6: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a19e8: 9902         	ldr	r1, [sp, #0x8]
700a19ea: 3904         	subs	r1, #0x4
700a19ec: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a19ee: 9902         	ldr	r1, [sp, #0x8]
700a19f0: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a19f2: 9802         	ldr	r0, [sp, #0x8]
700a19f4: 3804         	subs	r0, #0x4
700a19f6: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portINITIAL_SPSR;
700a19f8: 9902         	ldr	r1, [sp, #0x8]
700a19fa: 201f         	movs	r0, #0x1f
700a19fc: 6008         	str	r0, [r1]
;   if (((uint32_t)pxCode & portTHUMB_MODE_ADDRESS) != 0x00UL) {
700a19fe: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a1a02: 07c0         	lsls	r0, r0, #0x1f
700a1a04: b130         	cbz	r0, 0x700a1a14 <pxPortInitialiseStack+0x44> @ imm = #0xc
700a1a06: e7ff         	b	0x700a1a08 <pxPortInitialiseStack+0x38> @ imm = #-0x2
;     *pxTopOfStack |= portTHUMB_MODE_BIT;
700a1a08: 9902         	ldr	r1, [sp, #0x8]
700a1a0a: 6808         	ldr	r0, [r1]
700a1a0c: f040 0020    	orr	r0, r0, #0x20
700a1a10: 6008         	str	r0, [r1]
;   }
700a1a12: e7ff         	b	0x700a1a14 <pxPortInitialiseStack+0x44> @ imm = #-0x2
;   pxTopOfStack--;
700a1a14: 9802         	ldr	r0, [sp, #0x8]
700a1a16: 3804         	subs	r0, #0x4
700a1a18: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pxCode;
700a1a1a: 9801         	ldr	r0, [sp, #0x4]
700a1a1c: 9902         	ldr	r1, [sp, #0x8]
700a1a1e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a20: 9802         	ldr	r0, [sp, #0x8]
700a1a22: 3804         	subs	r0, #0x4
700a1a24: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* R14 */
700a1a26: 9902         	ldr	r1, [sp, #0x8]
700a1a28: f24d 7081    	movw	r0, #0xd781
700a1a2c: f2c7 000a    	movt	r0, #0x700a
700a1a30: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a32: 9802         	ldr	r0, [sp, #0x8]
700a1a34: 3804         	subs	r0, #0x4
700a1a36: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x12121212; /* R12 */
700a1a38: 9902         	ldr	r1, [sp, #0x8]
700a1a3a: f04f 3012    	mov.w	r0, #0x12121212
700a1a3e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a40: 9802         	ldr	r0, [sp, #0x8]
700a1a42: 3804         	subs	r0, #0x4
700a1a44: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x11111111; /* R11 */
700a1a46: 9902         	ldr	r1, [sp, #0x8]
700a1a48: f04f 3011    	mov.w	r0, #0x11111111
700a1a4c: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a4e: 9802         	ldr	r0, [sp, #0x8]
700a1a50: 3804         	subs	r0, #0x4
700a1a52: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x10101010; /* R10 */
700a1a54: 9902         	ldr	r1, [sp, #0x8]
700a1a56: f04f 3010    	mov.w	r0, #0x10101010
700a1a5a: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a5c: 9802         	ldr	r0, [sp, #0x8]
700a1a5e: 3804         	subs	r0, #0x4
700a1a60: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x09090909; /* R9 */
700a1a62: 9902         	ldr	r1, [sp, #0x8]
700a1a64: f04f 3009    	mov.w	r0, #0x9090909
700a1a68: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a6a: 9802         	ldr	r0, [sp, #0x8]
700a1a6c: 3804         	subs	r0, #0x4
700a1a6e: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x08080808; /* R8 */
700a1a70: 9902         	ldr	r1, [sp, #0x8]
700a1a72: f04f 3008    	mov.w	r0, #0x8080808
700a1a76: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a78: 9802         	ldr	r0, [sp, #0x8]
700a1a7a: 3804         	subs	r0, #0x4
700a1a7c: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x07070707; /* R7 */
700a1a7e: 9902         	ldr	r1, [sp, #0x8]
700a1a80: f04f 3007    	mov.w	r0, #0x7070707
700a1a84: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a86: 9802         	ldr	r0, [sp, #0x8]
700a1a88: 3804         	subs	r0, #0x4
700a1a8a: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x06060606; /* R6 */
700a1a8c: 9902         	ldr	r1, [sp, #0x8]
700a1a8e: f04f 3006    	mov.w	r0, #0x6060606
700a1a92: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1a94: 9802         	ldr	r0, [sp, #0x8]
700a1a96: 3804         	subs	r0, #0x4
700a1a98: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x05050505; /* R5 */
700a1a9a: 9902         	ldr	r1, [sp, #0x8]
700a1a9c: f04f 3005    	mov.w	r0, #0x5050505
700a1aa0: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1aa2: 9802         	ldr	r0, [sp, #0x8]
700a1aa4: 3804         	subs	r0, #0x4
700a1aa6: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x04040404; /* R4 */
700a1aa8: 9902         	ldr	r1, [sp, #0x8]
700a1aaa: f04f 3004    	mov.w	r0, #0x4040404
700a1aae: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1ab0: 9802         	ldr	r0, [sp, #0x8]
700a1ab2: 3804         	subs	r0, #0x4
700a1ab4: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x03030303; /* R3 */
700a1ab6: 9902         	ldr	r1, [sp, #0x8]
700a1ab8: f04f 3003    	mov.w	r0, #0x3030303
700a1abc: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1abe: 9802         	ldr	r0, [sp, #0x8]
700a1ac0: 3804         	subs	r0, #0x4
700a1ac2: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x02020202; /* R2 */
700a1ac4: 9902         	ldr	r1, [sp, #0x8]
700a1ac6: f04f 3002    	mov.w	r0, #0x2020202
700a1aca: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1acc: 9802         	ldr	r0, [sp, #0x8]
700a1ace: 3804         	subs	r0, #0x4
700a1ad0: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x01010101; /* R1 */
700a1ad2: 9902         	ldr	r1, [sp, #0x8]
700a1ad4: f04f 3001    	mov.w	r0, #0x1010101
700a1ad8: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1ada: 9802         	ldr	r0, [sp, #0x8]
700a1adc: 3804         	subs	r0, #0x4
700a1ade: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pvParameters; /* R0 */
700a1ae0: 9800         	ldr	r0, [sp]
700a1ae2: 9902         	ldr	r1, [sp, #0x8]
700a1ae4: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a1ae6: 9802         	ldr	r0, [sp, #0x8]
700a1ae8: 3804         	subs	r0, #0x4
700a1aea: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
700a1aec: 9902         	ldr	r1, [sp, #0x8]
700a1aee: 2000         	movs	r0, #0x0
700a1af0: 6008         	str	r0, [r1]
;   return pxTopOfStack;
700a1af2: 9802         	ldr	r0, [sp, #0x8]
700a1af4: b003         	add	sp, #0xc
700a1af6: 4770         	bx	lr
		...

700a1b00 <Udma_rmAllocBlkCopyCh>:
; {
700a1b00: b580         	push	{r7, lr}
700a1b02: b088         	sub	sp, #0x20
700a1b04: 9007         	str	r0, [sp, #0x1c]
700a1b06: 9106         	str	r1, [sp, #0x18]
700a1b08: 2000         	movs	r0, #0x0
700a1b0a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1b0e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1b10: 9806         	ldr	r0, [sp, #0x18]
700a1b12: f500 70ea    	add.w	r0, r0, #0x1d4
700a1b16: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1b18: 9806         	ldr	r0, [sp, #0x18]
700a1b1a: f500 609f    	add.w	r0, r0, #0x4f8
700a1b1e: f04f 31ff    	mov.w	r1, #0xffffffff
700a1b22: f006 fde5    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x6bca
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1b26: 9807         	ldr	r0, [sp, #0x1c]
700a1b28: 2101         	movs	r1, #0x1
700a1b2a: f6cf 71ff    	movt	r1, #0xffff
700a1b2e: 4288         	cmp	r0, r1
700a1b30: d136         	bne	0x700a1ba0 <Udma_rmAllocBlkCopyCh+0xa0> @ imm = #0x6c
700a1b32: e7ff         	b	0x700a1b34 <Udma_rmAllocBlkCopyCh+0x34> @ imm = #-0x2
700a1b34: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a1b36: 9005         	str	r0, [sp, #0x14]
700a1b38: e7ff         	b	0x700a1b3a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x2
700a1b3a: 9805         	ldr	r0, [sp, #0x14]
700a1b3c: 9900         	ldr	r1, [sp]
700a1b3e: 6949         	ldr	r1, [r1, #0x14]
700a1b40: 4288         	cmp	r0, r1
700a1b42: d22c         	bhs	0x700a1b9e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x58
700a1b44: e7ff         	b	0x700a1b46 <Udma_rmAllocBlkCopyCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a1b46: 9805         	ldr	r0, [sp, #0x14]
700a1b48: 0940         	lsrs	r0, r0, #0x5
700a1b4a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1b4c: 9805         	ldr	r0, [sp, #0x14]
700a1b4e: 9904         	ldr	r1, [sp, #0x10]
700a1b50: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1b54: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1b56: 9903         	ldr	r1, [sp, #0xc]
700a1b58: 2001         	movs	r0, #0x1
700a1b5a: 4088         	lsls	r0, r1
700a1b5c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a1b5e: 9806         	ldr	r0, [sp, #0x18]
700a1b60: 9904         	ldr	r1, [sp, #0x10]
700a1b62: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1b66: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a1b6a: 9902         	ldr	r1, [sp, #0x8]
700a1b6c: 4008         	ands	r0, r1
700a1b6e: 4288         	cmp	r0, r1
700a1b70: d110         	bne	0x700a1b94 <Udma_rmAllocBlkCopyCh+0x94> @ imm = #0x20
700a1b72: e7ff         	b	0x700a1b74 <Udma_rmAllocBlkCopyCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a1b74: 9a02         	ldr	r2, [sp, #0x8]
700a1b76: 9806         	ldr	r0, [sp, #0x18]
700a1b78: 9904         	ldr	r1, [sp, #0x10]
700a1b7a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1b7e: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a1b82: 4390         	bics	r0, r2
700a1b84: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = i + rmInitPrms->startBlkCopyCh;  /* Add start offset */
700a1b88: 9805         	ldr	r0, [sp, #0x14]
700a1b8a: 9900         	ldr	r1, [sp]
700a1b8c: 6909         	ldr	r1, [r1, #0x10]
700a1b8e: 4408         	add	r0, r1
700a1b90: 9001         	str	r0, [sp, #0x4]
;                 break;
700a1b92: e004         	b	0x700a1b9e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x8
;         }
700a1b94: e7ff         	b	0x700a1b96 <Udma_rmAllocBlkCopyCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a1b96: 9805         	ldr	r0, [sp, #0x14]
700a1b98: 3001         	adds	r0, #0x1
700a1b9a: 9005         	str	r0, [sp, #0x14]
700a1b9c: e7cd         	b	0x700a1b3a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x66
;     }
700a1b9e: e038         	b	0x700a1c12 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a1ba0: 9807         	ldr	r0, [sp, #0x1c]
700a1ba2: 9900         	ldr	r1, [sp]
700a1ba4: 6909         	ldr	r1, [r1, #0x10]
700a1ba6: 4288         	cmp	r0, r1
700a1ba8: d332         	blo	0x700a1c10 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x64
700a1baa: e7ff         	b	0x700a1bac <Udma_rmAllocBlkCopyCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyCh + rmInitPrms->numBlkCopyCh)))
700a1bac: 9807         	ldr	r0, [sp, #0x1c]
700a1bae: 9a00         	ldr	r2, [sp]
700a1bb0: 6911         	ldr	r1, [r2, #0x10]
700a1bb2: 6952         	ldr	r2, [r2, #0x14]
700a1bb4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a1bb6: 4288         	cmp	r0, r1
700a1bb8: d22a         	bhs	0x700a1c10 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x54
700a1bba: e7ff         	b	0x700a1bbc <Udma_rmAllocBlkCopyCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyCh;
700a1bbc: 9807         	ldr	r0, [sp, #0x1c]
700a1bbe: 9900         	ldr	r1, [sp]
700a1bc0: 6909         	ldr	r1, [r1, #0x10]
700a1bc2: 1a40         	subs	r0, r0, r1
700a1bc4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1bc6: 9805         	ldr	r0, [sp, #0x14]
700a1bc8: 0940         	lsrs	r0, r0, #0x5
700a1bca: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1bcc: 9805         	ldr	r0, [sp, #0x14]
700a1bce: 9904         	ldr	r1, [sp, #0x10]
700a1bd0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1bd4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1bd6: 9903         	ldr	r1, [sp, #0xc]
700a1bd8: 2001         	movs	r0, #0x1
700a1bda: 4088         	lsls	r0, r1
700a1bdc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a1bde: 9806         	ldr	r0, [sp, #0x18]
700a1be0: 9904         	ldr	r1, [sp, #0x10]
700a1be2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1be6: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a1bea: 9902         	ldr	r1, [sp, #0x8]
700a1bec: 4008         	ands	r0, r1
700a1bee: 4288         	cmp	r0, r1
700a1bf0: d10d         	bne	0x700a1c0e <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #0x1a
700a1bf2: e7ff         	b	0x700a1bf4 <Udma_rmAllocBlkCopyCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a1bf4: 9a02         	ldr	r2, [sp, #0x8]
700a1bf6: 9806         	ldr	r0, [sp, #0x18]
700a1bf8: 9904         	ldr	r1, [sp, #0x10]
700a1bfa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1bfe: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a1c02: 4390         	bics	r0, r2
700a1c04: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = preferredChNum;
700a1c08: 9807         	ldr	r0, [sp, #0x1c]
700a1c0a: 9001         	str	r0, [sp, #0x4]
;             }
700a1c0c: e7ff         	b	0x700a1c0e <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #-0x2
;         }
700a1c0e: e7ff         	b	0x700a1c10 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #-0x2
700a1c10: e7ff         	b	0x700a1c12 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1c12: 9806         	ldr	r0, [sp, #0x18]
700a1c14: f500 609f    	add.w	r0, r0, #0x4f8
700a1c18: f008 f8ba    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x8174
;     return (chNum);
700a1c1c: 9801         	ldr	r0, [sp, #0x4]
700a1c1e: b008         	add	sp, #0x20
700a1c20: bd80         	pop	{r7, pc}
		...
700a1c2e: 0000         	movs	r0, r0

700a1c30 <Udma_rmAllocBlkCopyHcCh>:
; {
700a1c30: b580         	push	{r7, lr}
700a1c32: b088         	sub	sp, #0x20
700a1c34: 9007         	str	r0, [sp, #0x1c]
700a1c36: 9106         	str	r1, [sp, #0x18]
700a1c38: 2000         	movs	r0, #0x0
700a1c3a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1c3e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1c40: 9806         	ldr	r0, [sp, #0x18]
700a1c42: f500 70ea    	add.w	r0, r0, #0x1d4
700a1c46: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1c48: 9806         	ldr	r0, [sp, #0x18]
700a1c4a: f500 609f    	add.w	r0, r0, #0x4f8
700a1c4e: f04f 31ff    	mov.w	r1, #0xffffffff
700a1c52: f006 fd4d    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x6a9a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1c56: 9807         	ldr	r0, [sp, #0x1c]
700a1c58: 2101         	movs	r1, #0x1
700a1c5a: f6cf 71ff    	movt	r1, #0xffff
700a1c5e: 4288         	cmp	r0, r1
700a1c60: d136         	bne	0x700a1cd0 <Udma_rmAllocBlkCopyHcCh+0xa0> @ imm = #0x6c
700a1c62: e7ff         	b	0x700a1c64 <Udma_rmAllocBlkCopyHcCh+0x34> @ imm = #-0x2
700a1c64: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a1c66: 9005         	str	r0, [sp, #0x14]
700a1c68: e7ff         	b	0x700a1c6a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x2
700a1c6a: 9805         	ldr	r0, [sp, #0x14]
700a1c6c: 9900         	ldr	r1, [sp]
700a1c6e: 68c9         	ldr	r1, [r1, #0xc]
700a1c70: 4288         	cmp	r0, r1
700a1c72: d22c         	bhs	0x700a1cce <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x58
700a1c74: e7ff         	b	0x700a1c76 <Udma_rmAllocBlkCopyHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a1c76: 9805         	ldr	r0, [sp, #0x14]
700a1c78: 0940         	lsrs	r0, r0, #0x5
700a1c7a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1c7c: 9805         	ldr	r0, [sp, #0x14]
700a1c7e: 9904         	ldr	r1, [sp, #0x10]
700a1c80: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1c84: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1c86: 9903         	ldr	r1, [sp, #0xc]
700a1c88: 2001         	movs	r0, #0x1
700a1c8a: 4088         	lsls	r0, r1
700a1c8c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a1c8e: 9806         	ldr	r0, [sp, #0x18]
700a1c90: 9904         	ldr	r1, [sp, #0x10]
700a1c92: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c96: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a1c9a: 9902         	ldr	r1, [sp, #0x8]
700a1c9c: 4008         	ands	r0, r1
700a1c9e: 4288         	cmp	r0, r1
700a1ca0: d110         	bne	0x700a1cc4 <Udma_rmAllocBlkCopyHcCh+0x94> @ imm = #0x20
700a1ca2: e7ff         	b	0x700a1ca4 <Udma_rmAllocBlkCopyHcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a1ca4: 9a02         	ldr	r2, [sp, #0x8]
700a1ca6: 9806         	ldr	r0, [sp, #0x18]
700a1ca8: 9904         	ldr	r1, [sp, #0x10]
700a1caa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1cae: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a1cb2: 4390         	bics	r0, r2
700a1cb4: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = i + rmInitPrms->startBlkCopyHcCh;  /* Add start offset */
700a1cb8: 9805         	ldr	r0, [sp, #0x14]
700a1cba: 9900         	ldr	r1, [sp]
700a1cbc: 6889         	ldr	r1, [r1, #0x8]
700a1cbe: 4408         	add	r0, r1
700a1cc0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a1cc2: e004         	b	0x700a1cce <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x8
;         }
700a1cc4: e7ff         	b	0x700a1cc6 <Udma_rmAllocBlkCopyHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a1cc6: 9805         	ldr	r0, [sp, #0x14]
700a1cc8: 3001         	adds	r0, #0x1
700a1cca: 9005         	str	r0, [sp, #0x14]
700a1ccc: e7cd         	b	0x700a1c6a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x66
;     }
700a1cce: e038         	b	0x700a1d42 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a1cd0: 9807         	ldr	r0, [sp, #0x1c]
700a1cd2: 9900         	ldr	r1, [sp]
700a1cd4: 6889         	ldr	r1, [r1, #0x8]
700a1cd6: 4288         	cmp	r0, r1
700a1cd8: d332         	blo	0x700a1d40 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x64
700a1cda: e7ff         	b	0x700a1cdc <Udma_rmAllocBlkCopyHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyHcCh + rmInitPrms->numBlkCopyHcCh)))
700a1cdc: 9807         	ldr	r0, [sp, #0x1c]
700a1cde: 9a00         	ldr	r2, [sp]
700a1ce0: 6891         	ldr	r1, [r2, #0x8]
700a1ce2: 68d2         	ldr	r2, [r2, #0xc]
700a1ce4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a1ce6: 4288         	cmp	r0, r1
700a1ce8: d22a         	bhs	0x700a1d40 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x54
700a1cea: e7ff         	b	0x700a1cec <Udma_rmAllocBlkCopyHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyHcCh;
700a1cec: 9807         	ldr	r0, [sp, #0x1c]
700a1cee: 9900         	ldr	r1, [sp]
700a1cf0: 6889         	ldr	r1, [r1, #0x8]
700a1cf2: 1a40         	subs	r0, r0, r1
700a1cf4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1cf6: 9805         	ldr	r0, [sp, #0x14]
700a1cf8: 0940         	lsrs	r0, r0, #0x5
700a1cfa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1cfc: 9805         	ldr	r0, [sp, #0x14]
700a1cfe: 9904         	ldr	r1, [sp, #0x10]
700a1d00: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1d04: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1d06: 9903         	ldr	r1, [sp, #0xc]
700a1d08: 2001         	movs	r0, #0x1
700a1d0a: 4088         	lsls	r0, r1
700a1d0c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a1d0e: 9806         	ldr	r0, [sp, #0x18]
700a1d10: 9904         	ldr	r1, [sp, #0x10]
700a1d12: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1d16: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a1d1a: 9902         	ldr	r1, [sp, #0x8]
700a1d1c: 4008         	ands	r0, r1
700a1d1e: 4288         	cmp	r0, r1
700a1d20: d10d         	bne	0x700a1d3e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #0x1a
700a1d22: e7ff         	b	0x700a1d24 <Udma_rmAllocBlkCopyHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a1d24: 9a02         	ldr	r2, [sp, #0x8]
700a1d26: 9806         	ldr	r0, [sp, #0x18]
700a1d28: 9904         	ldr	r1, [sp, #0x10]
700a1d2a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1d2e: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a1d32: 4390         	bics	r0, r2
700a1d34: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = preferredChNum;
700a1d38: 9807         	ldr	r0, [sp, #0x1c]
700a1d3a: 9001         	str	r0, [sp, #0x4]
;             }
700a1d3c: e7ff         	b	0x700a1d3e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #-0x2
;         }
700a1d3e: e7ff         	b	0x700a1d40 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #-0x2
700a1d40: e7ff         	b	0x700a1d42 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1d42: 9806         	ldr	r0, [sp, #0x18]
700a1d44: f500 609f    	add.w	r0, r0, #0x4f8
700a1d48: f008 f822    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x8044
;     return (chNum);
700a1d4c: 9801         	ldr	r0, [sp, #0x4]
700a1d4e: b008         	add	sp, #0x20
700a1d50: bd80         	pop	{r7, pc}
		...
700a1d5e: 0000         	movs	r0, r0

700a1d60 <Udma_rmAllocBlkCopyUhcCh>:
; {
700a1d60: b580         	push	{r7, lr}
700a1d62: b088         	sub	sp, #0x20
700a1d64: 9007         	str	r0, [sp, #0x1c]
700a1d66: 9106         	str	r1, [sp, #0x18]
700a1d68: 2000         	movs	r0, #0x0
700a1d6a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1d6e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1d70: 9806         	ldr	r0, [sp, #0x18]
700a1d72: f500 70ea    	add.w	r0, r0, #0x1d4
700a1d76: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1d78: 9806         	ldr	r0, [sp, #0x18]
700a1d7a: f500 609f    	add.w	r0, r0, #0x4f8
700a1d7e: f04f 31ff    	mov.w	r1, #0xffffffff
700a1d82: f006 fcb5    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x696a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1d86: 9807         	ldr	r0, [sp, #0x1c]
700a1d88: 2101         	movs	r1, #0x1
700a1d8a: f6cf 71ff    	movt	r1, #0xffff
700a1d8e: 4288         	cmp	r0, r1
700a1d90: d136         	bne	0x700a1e00 <Udma_rmAllocBlkCopyUhcCh+0xa0> @ imm = #0x6c
700a1d92: e7ff         	b	0x700a1d94 <Udma_rmAllocBlkCopyUhcCh+0x34> @ imm = #-0x2
700a1d94: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a1d96: 9005         	str	r0, [sp, #0x14]
700a1d98: e7ff         	b	0x700a1d9a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x2
700a1d9a: 9805         	ldr	r0, [sp, #0x14]
700a1d9c: 9900         	ldr	r1, [sp]
700a1d9e: 6849         	ldr	r1, [r1, #0x4]
700a1da0: 4288         	cmp	r0, r1
700a1da2: d22c         	bhs	0x700a1dfe <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x58
700a1da4: e7ff         	b	0x700a1da6 <Udma_rmAllocBlkCopyUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a1da6: 9805         	ldr	r0, [sp, #0x14]
700a1da8: 0940         	lsrs	r0, r0, #0x5
700a1daa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1dac: 9805         	ldr	r0, [sp, #0x14]
700a1dae: 9904         	ldr	r1, [sp, #0x10]
700a1db0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1db4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1db6: 9903         	ldr	r1, [sp, #0xc]
700a1db8: 2001         	movs	r0, #0x1
700a1dba: 4088         	lsls	r0, r1
700a1dbc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a1dbe: 9806         	ldr	r0, [sp, #0x18]
700a1dc0: 9904         	ldr	r1, [sp, #0x10]
700a1dc2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1dc6: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a1dca: 9902         	ldr	r1, [sp, #0x8]
700a1dcc: 4008         	ands	r0, r1
700a1dce: 4288         	cmp	r0, r1
700a1dd0: d110         	bne	0x700a1df4 <Udma_rmAllocBlkCopyUhcCh+0x94> @ imm = #0x20
700a1dd2: e7ff         	b	0x700a1dd4 <Udma_rmAllocBlkCopyUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a1dd4: 9a02         	ldr	r2, [sp, #0x8]
700a1dd6: 9806         	ldr	r0, [sp, #0x18]
700a1dd8: 9904         	ldr	r1, [sp, #0x10]
700a1dda: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1dde: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a1de2: 4390         	bics	r0, r2
700a1de4: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = i + rmInitPrms->startBlkCopyUhcCh;  /* Add start offset */
700a1de8: 9805         	ldr	r0, [sp, #0x14]
700a1dea: 9900         	ldr	r1, [sp]
700a1dec: 6809         	ldr	r1, [r1]
700a1dee: 4408         	add	r0, r1
700a1df0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a1df2: e004         	b	0x700a1dfe <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x8
;         }
700a1df4: e7ff         	b	0x700a1df6 <Udma_rmAllocBlkCopyUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a1df6: 9805         	ldr	r0, [sp, #0x14]
700a1df8: 3001         	adds	r0, #0x1
700a1dfa: 9005         	str	r0, [sp, #0x14]
700a1dfc: e7cd         	b	0x700a1d9a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x66
;     }
700a1dfe: e038         	b	0x700a1e72 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a1e00: 9807         	ldr	r0, [sp, #0x1c]
700a1e02: 9900         	ldr	r1, [sp]
700a1e04: 6809         	ldr	r1, [r1]
700a1e06: 4288         	cmp	r0, r1
700a1e08: d332         	blo	0x700a1e70 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x64
700a1e0a: e7ff         	b	0x700a1e0c <Udma_rmAllocBlkCopyUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyUhcCh + rmInitPrms->numBlkCopyUhcCh)))
700a1e0c: 9807         	ldr	r0, [sp, #0x1c]
700a1e0e: 9a00         	ldr	r2, [sp]
700a1e10: 6811         	ldr	r1, [r2]
700a1e12: 6852         	ldr	r2, [r2, #0x4]
700a1e14: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a1e16: 4288         	cmp	r0, r1
700a1e18: d22a         	bhs	0x700a1e70 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x54
700a1e1a: e7ff         	b	0x700a1e1c <Udma_rmAllocBlkCopyUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyUhcCh;
700a1e1c: 9807         	ldr	r0, [sp, #0x1c]
700a1e1e: 9900         	ldr	r1, [sp]
700a1e20: 6809         	ldr	r1, [r1]
700a1e22: 1a40         	subs	r0, r0, r1
700a1e24: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1e26: 9805         	ldr	r0, [sp, #0x14]
700a1e28: 0940         	lsrs	r0, r0, #0x5
700a1e2a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1e2c: 9805         	ldr	r0, [sp, #0x14]
700a1e2e: 9904         	ldr	r1, [sp, #0x10]
700a1e30: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1e34: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1e36: 9903         	ldr	r1, [sp, #0xc]
700a1e38: 2001         	movs	r0, #0x1
700a1e3a: 4088         	lsls	r0, r1
700a1e3c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a1e3e: 9806         	ldr	r0, [sp, #0x18]
700a1e40: 9904         	ldr	r1, [sp, #0x10]
700a1e42: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1e46: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a1e4a: 9902         	ldr	r1, [sp, #0x8]
700a1e4c: 4008         	ands	r0, r1
700a1e4e: 4288         	cmp	r0, r1
700a1e50: d10d         	bne	0x700a1e6e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #0x1a
700a1e52: e7ff         	b	0x700a1e54 <Udma_rmAllocBlkCopyUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a1e54: 9a02         	ldr	r2, [sp, #0x8]
700a1e56: 9806         	ldr	r0, [sp, #0x18]
700a1e58: 9904         	ldr	r1, [sp, #0x10]
700a1e5a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1e5e: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a1e62: 4390         	bics	r0, r2
700a1e64: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = preferredChNum;
700a1e68: 9807         	ldr	r0, [sp, #0x1c]
700a1e6a: 9001         	str	r0, [sp, #0x4]
;             }
700a1e6c: e7ff         	b	0x700a1e6e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #-0x2
;         }
700a1e6e: e7ff         	b	0x700a1e70 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #-0x2
700a1e70: e7ff         	b	0x700a1e72 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1e72: 9806         	ldr	r0, [sp, #0x18]
700a1e74: f500 609f    	add.w	r0, r0, #0x4f8
700a1e78: f007 ff8a    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x7f14
;     return (chNum);
700a1e7c: 9801         	ldr	r0, [sp, #0x4]
700a1e7e: b008         	add	sp, #0x20
700a1e80: bd80         	pop	{r7, pc}
		...
700a1e8e: 0000         	movs	r0, r0

700a1e90 <Udma_rmAllocRxCh>:
; {
700a1e90: b580         	push	{r7, lr}
700a1e92: b088         	sub	sp, #0x20
700a1e94: 9007         	str	r0, [sp, #0x1c]
700a1e96: 9106         	str	r1, [sp, #0x18]
700a1e98: 2000         	movs	r0, #0x0
700a1e9a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1e9e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1ea0: 9806         	ldr	r0, [sp, #0x18]
700a1ea2: f500 70ea    	add.w	r0, r0, #0x1d4
700a1ea6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1ea8: 9806         	ldr	r0, [sp, #0x18]
700a1eaa: f500 609f    	add.w	r0, r0, #0x4f8
700a1eae: f04f 31ff    	mov.w	r1, #0xffffffff
700a1eb2: f006 fc1d    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x683a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1eb6: 9807         	ldr	r0, [sp, #0x1c]
700a1eb8: 2101         	movs	r1, #0x1
700a1eba: f6cf 71ff    	movt	r1, #0xffff
700a1ebe: 4288         	cmp	r0, r1
700a1ec0: d136         	bne	0x700a1f30 <Udma_rmAllocRxCh+0xa0> @ imm = #0x6c
700a1ec2: e7ff         	b	0x700a1ec4 <Udma_rmAllocRxCh+0x34> @ imm = #-0x2
700a1ec4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a1ec6: 9005         	str	r0, [sp, #0x14]
700a1ec8: e7ff         	b	0x700a1eca <Udma_rmAllocRxCh+0x3a> @ imm = #-0x2
700a1eca: 9805         	ldr	r0, [sp, #0x14]
700a1ecc: 9900         	ldr	r1, [sp]
700a1ece: 6c49         	ldr	r1, [r1, #0x44]
700a1ed0: 4288         	cmp	r0, r1
700a1ed2: d22c         	bhs	0x700a1f2e <Udma_rmAllocRxCh+0x9e> @ imm = #0x58
700a1ed4: e7ff         	b	0x700a1ed6 <Udma_rmAllocRxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a1ed6: 9805         	ldr	r0, [sp, #0x14]
700a1ed8: 0940         	lsrs	r0, r0, #0x5
700a1eda: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1edc: 9805         	ldr	r0, [sp, #0x14]
700a1ede: 9904         	ldr	r1, [sp, #0x10]
700a1ee0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1ee4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1ee6: 9903         	ldr	r1, [sp, #0xc]
700a1ee8: 2001         	movs	r0, #0x1
700a1eea: 4088         	lsls	r0, r1
700a1eec: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a1eee: 9806         	ldr	r0, [sp, #0x18]
700a1ef0: 9904         	ldr	r1, [sp, #0x10]
700a1ef2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1ef6: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a1efa: 9902         	ldr	r1, [sp, #0x8]
700a1efc: 4008         	ands	r0, r1
700a1efe: 4288         	cmp	r0, r1
700a1f00: d110         	bne	0x700a1f24 <Udma_rmAllocRxCh+0x94> @ imm = #0x20
700a1f02: e7ff         	b	0x700a1f04 <Udma_rmAllocRxCh+0x74> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a1f04: 9a02         	ldr	r2, [sp, #0x8]
700a1f06: 9806         	ldr	r0, [sp, #0x18]
700a1f08: 9904         	ldr	r1, [sp, #0x10]
700a1f0a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1f0e: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a1f12: 4390         	bics	r0, r2
700a1f14: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = i + rmInitPrms->startRxCh;  /* Add start offset */
700a1f18: 9805         	ldr	r0, [sp, #0x14]
700a1f1a: 9900         	ldr	r1, [sp]
700a1f1c: 6c09         	ldr	r1, [r1, #0x40]
700a1f1e: 4408         	add	r0, r1
700a1f20: 9001         	str	r0, [sp, #0x4]
;                 break;
700a1f22: e004         	b	0x700a1f2e <Udma_rmAllocRxCh+0x9e> @ imm = #0x8
;         }
700a1f24: e7ff         	b	0x700a1f26 <Udma_rmAllocRxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a1f26: 9805         	ldr	r0, [sp, #0x14]
700a1f28: 3001         	adds	r0, #0x1
700a1f2a: 9005         	str	r0, [sp, #0x14]
700a1f2c: e7cd         	b	0x700a1eca <Udma_rmAllocRxCh+0x3a> @ imm = #-0x66
;     }
700a1f2e: e038         	b	0x700a1fa2 <Udma_rmAllocRxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a1f30: 9807         	ldr	r0, [sp, #0x1c]
700a1f32: 9900         	ldr	r1, [sp]
700a1f34: 6c09         	ldr	r1, [r1, #0x40]
700a1f36: 4288         	cmp	r0, r1
700a1f38: d332         	blo	0x700a1fa0 <Udma_rmAllocRxCh+0x110> @ imm = #0x64
700a1f3a: e7ff         	b	0x700a1f3c <Udma_rmAllocRxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxCh + rmInitPrms->numRxCh)))
700a1f3c: 9807         	ldr	r0, [sp, #0x1c]
700a1f3e: 9a00         	ldr	r2, [sp]
700a1f40: 6c11         	ldr	r1, [r2, #0x40]
700a1f42: 6c52         	ldr	r2, [r2, #0x44]
700a1f44: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a1f46: 4288         	cmp	r0, r1
700a1f48: d22a         	bhs	0x700a1fa0 <Udma_rmAllocRxCh+0x110> @ imm = #0x54
700a1f4a: e7ff         	b	0x700a1f4c <Udma_rmAllocRxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxCh;
700a1f4c: 9807         	ldr	r0, [sp, #0x1c]
700a1f4e: 9900         	ldr	r1, [sp]
700a1f50: 6c09         	ldr	r1, [r1, #0x40]
700a1f52: 1a40         	subs	r0, r0, r1
700a1f54: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1f56: 9805         	ldr	r0, [sp, #0x14]
700a1f58: 0940         	lsrs	r0, r0, #0x5
700a1f5a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1f5c: 9805         	ldr	r0, [sp, #0x14]
700a1f5e: 9904         	ldr	r1, [sp, #0x10]
700a1f60: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1f64: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1f66: 9903         	ldr	r1, [sp, #0xc]
700a1f68: 2001         	movs	r0, #0x1
700a1f6a: 4088         	lsls	r0, r1
700a1f6c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a1f6e: 9806         	ldr	r0, [sp, #0x18]
700a1f70: 9904         	ldr	r1, [sp, #0x10]
700a1f72: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1f76: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a1f7a: 9902         	ldr	r1, [sp, #0x8]
700a1f7c: 4008         	ands	r0, r1
700a1f7e: 4288         	cmp	r0, r1
700a1f80: d10d         	bne	0x700a1f9e <Udma_rmAllocRxCh+0x10e> @ imm = #0x1a
700a1f82: e7ff         	b	0x700a1f84 <Udma_rmAllocRxCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a1f84: 9a02         	ldr	r2, [sp, #0x8]
700a1f86: 9806         	ldr	r0, [sp, #0x18]
700a1f88: 9904         	ldr	r1, [sp, #0x10]
700a1f8a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1f8e: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a1f92: 4390         	bics	r0, r2
700a1f94: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = preferredChNum;
700a1f98: 9807         	ldr	r0, [sp, #0x1c]
700a1f9a: 9001         	str	r0, [sp, #0x4]
;             }
700a1f9c: e7ff         	b	0x700a1f9e <Udma_rmAllocRxCh+0x10e> @ imm = #-0x2
;         }
700a1f9e: e7ff         	b	0x700a1fa0 <Udma_rmAllocRxCh+0x110> @ imm = #-0x2
700a1fa0: e7ff         	b	0x700a1fa2 <Udma_rmAllocRxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1fa2: 9806         	ldr	r0, [sp, #0x18]
700a1fa4: f500 609f    	add.w	r0, r0, #0x4f8
700a1fa8: f007 fef2    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x7de4
;     return (chNum);
700a1fac: 9801         	ldr	r0, [sp, #0x4]
700a1fae: b008         	add	sp, #0x20
700a1fb0: bd80         	pop	{r7, pc}
		...
700a1fbe: 0000         	movs	r0, r0

700a1fc0 <Udma_rmAllocRxHcCh>:
; {
700a1fc0: b580         	push	{r7, lr}
700a1fc2: b088         	sub	sp, #0x20
700a1fc4: 9007         	str	r0, [sp, #0x1c]
700a1fc6: 9106         	str	r1, [sp, #0x18]
700a1fc8: 2000         	movs	r0, #0x0
700a1fca: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1fce: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1fd0: 9806         	ldr	r0, [sp, #0x18]
700a1fd2: f500 70ea    	add.w	r0, r0, #0x1d4
700a1fd6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1fd8: 9806         	ldr	r0, [sp, #0x18]
700a1fda: f500 609f    	add.w	r0, r0, #0x4f8
700a1fde: f04f 31ff    	mov.w	r1, #0xffffffff
700a1fe2: f006 fb85    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x670a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1fe6: 9807         	ldr	r0, [sp, #0x1c]
700a1fe8: 2101         	movs	r1, #0x1
700a1fea: f6cf 71ff    	movt	r1, #0xffff
700a1fee: 4288         	cmp	r0, r1
700a1ff0: d136         	bne	0x700a2060 <Udma_rmAllocRxHcCh+0xa0> @ imm = #0x6c
700a1ff2: e7ff         	b	0x700a1ff4 <Udma_rmAllocRxHcCh+0x34> @ imm = #-0x2
700a1ff4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a1ff6: 9005         	str	r0, [sp, #0x14]
700a1ff8: e7ff         	b	0x700a1ffa <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x2
700a1ffa: 9805         	ldr	r0, [sp, #0x14]
700a1ffc: 9900         	ldr	r1, [sp]
700a1ffe: 6bc9         	ldr	r1, [r1, #0x3c]
700a2000: 4288         	cmp	r0, r1
700a2002: d22c         	bhs	0x700a205e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x58
700a2004: e7ff         	b	0x700a2006 <Udma_rmAllocRxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2006: 9805         	ldr	r0, [sp, #0x14]
700a2008: 0940         	lsrs	r0, r0, #0x5
700a200a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a200c: 9805         	ldr	r0, [sp, #0x14]
700a200e: 9904         	ldr	r1, [sp, #0x10]
700a2010: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2014: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2016: 9903         	ldr	r1, [sp, #0xc]
700a2018: 2001         	movs	r0, #0x1
700a201a: 4088         	lsls	r0, r1
700a201c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a201e: 9806         	ldr	r0, [sp, #0x18]
700a2020: 9904         	ldr	r1, [sp, #0x10]
700a2022: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2026: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a202a: 9902         	ldr	r1, [sp, #0x8]
700a202c: 4008         	ands	r0, r1
700a202e: 4288         	cmp	r0, r1
700a2030: d110         	bne	0x700a2054 <Udma_rmAllocRxHcCh+0x94> @ imm = #0x20
700a2032: e7ff         	b	0x700a2034 <Udma_rmAllocRxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a2034: 9a02         	ldr	r2, [sp, #0x8]
700a2036: 9806         	ldr	r0, [sp, #0x18]
700a2038: 9904         	ldr	r1, [sp, #0x10]
700a203a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a203e: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a2042: 4390         	bics	r0, r2
700a2044: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = i + rmInitPrms->startRxHcCh;  /* Add start offset */
700a2048: 9805         	ldr	r0, [sp, #0x14]
700a204a: 9900         	ldr	r1, [sp]
700a204c: 6b89         	ldr	r1, [r1, #0x38]
700a204e: 4408         	add	r0, r1
700a2050: 9001         	str	r0, [sp, #0x4]
;                 break;
700a2052: e004         	b	0x700a205e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x8
;         }
700a2054: e7ff         	b	0x700a2056 <Udma_rmAllocRxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a2056: 9805         	ldr	r0, [sp, #0x14]
700a2058: 3001         	adds	r0, #0x1
700a205a: 9005         	str	r0, [sp, #0x14]
700a205c: e7cd         	b	0x700a1ffa <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x66
;     }
700a205e: e038         	b	0x700a20d2 <Udma_rmAllocRxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a2060: 9807         	ldr	r0, [sp, #0x1c]
700a2062: 9900         	ldr	r1, [sp]
700a2064: 6b89         	ldr	r1, [r1, #0x38]
700a2066: 4288         	cmp	r0, r1
700a2068: d332         	blo	0x700a20d0 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x64
700a206a: e7ff         	b	0x700a206c <Udma_rmAllocRxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxHcCh + rmInitPrms->numRxHcCh)))
700a206c: 9807         	ldr	r0, [sp, #0x1c]
700a206e: 9a00         	ldr	r2, [sp]
700a2070: 6b91         	ldr	r1, [r2, #0x38]
700a2072: 6bd2         	ldr	r2, [r2, #0x3c]
700a2074: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a2076: 4288         	cmp	r0, r1
700a2078: d22a         	bhs	0x700a20d0 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x54
700a207a: e7ff         	b	0x700a207c <Udma_rmAllocRxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxHcCh;
700a207c: 9807         	ldr	r0, [sp, #0x1c]
700a207e: 9900         	ldr	r1, [sp]
700a2080: 6b89         	ldr	r1, [r1, #0x38]
700a2082: 1a40         	subs	r0, r0, r1
700a2084: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2086: 9805         	ldr	r0, [sp, #0x14]
700a2088: 0940         	lsrs	r0, r0, #0x5
700a208a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a208c: 9805         	ldr	r0, [sp, #0x14]
700a208e: 9904         	ldr	r1, [sp, #0x10]
700a2090: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2094: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2096: 9903         	ldr	r1, [sp, #0xc]
700a2098: 2001         	movs	r0, #0x1
700a209a: 4088         	lsls	r0, r1
700a209c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a209e: 9806         	ldr	r0, [sp, #0x18]
700a20a0: 9904         	ldr	r1, [sp, #0x10]
700a20a2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a20a6: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a20aa: 9902         	ldr	r1, [sp, #0x8]
700a20ac: 4008         	ands	r0, r1
700a20ae: 4288         	cmp	r0, r1
700a20b0: d10d         	bne	0x700a20ce <Udma_rmAllocRxHcCh+0x10e> @ imm = #0x1a
700a20b2: e7ff         	b	0x700a20b4 <Udma_rmAllocRxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a20b4: 9a02         	ldr	r2, [sp, #0x8]
700a20b6: 9806         	ldr	r0, [sp, #0x18]
700a20b8: 9904         	ldr	r1, [sp, #0x10]
700a20ba: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a20be: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a20c2: 4390         	bics	r0, r2
700a20c4: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = preferredChNum;
700a20c8: 9807         	ldr	r0, [sp, #0x1c]
700a20ca: 9001         	str	r0, [sp, #0x4]
;             }
700a20cc: e7ff         	b	0x700a20ce <Udma_rmAllocRxHcCh+0x10e> @ imm = #-0x2
;         }
700a20ce: e7ff         	b	0x700a20d0 <Udma_rmAllocRxHcCh+0x110> @ imm = #-0x2
700a20d0: e7ff         	b	0x700a20d2 <Udma_rmAllocRxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a20d2: 9806         	ldr	r0, [sp, #0x18]
700a20d4: f500 609f    	add.w	r0, r0, #0x4f8
700a20d8: f007 fe5a    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x7cb4
;     return (chNum);
700a20dc: 9801         	ldr	r0, [sp, #0x4]
700a20de: b008         	add	sp, #0x20
700a20e0: bd80         	pop	{r7, pc}
		...
700a20ee: 0000         	movs	r0, r0

700a20f0 <Udma_rmAllocRxUhcCh>:
; {
700a20f0: b580         	push	{r7, lr}
700a20f2: b088         	sub	sp, #0x20
700a20f4: 9007         	str	r0, [sp, #0x1c]
700a20f6: 9106         	str	r1, [sp, #0x18]
700a20f8: 2000         	movs	r0, #0x0
700a20fa: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a20fe: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2100: 9806         	ldr	r0, [sp, #0x18]
700a2102: f500 70ea    	add.w	r0, r0, #0x1d4
700a2106: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2108: 9806         	ldr	r0, [sp, #0x18]
700a210a: f500 609f    	add.w	r0, r0, #0x4f8
700a210e: f04f 31ff    	mov.w	r1, #0xffffffff
700a2112: f006 faed    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x65da
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2116: 9807         	ldr	r0, [sp, #0x1c]
700a2118: 2101         	movs	r1, #0x1
700a211a: f6cf 71ff    	movt	r1, #0xffff
700a211e: 4288         	cmp	r0, r1
700a2120: d136         	bne	0x700a2190 <Udma_rmAllocRxUhcCh+0xa0> @ imm = #0x6c
700a2122: e7ff         	b	0x700a2124 <Udma_rmAllocRxUhcCh+0x34> @ imm = #-0x2
700a2124: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a2126: 9005         	str	r0, [sp, #0x14]
700a2128: e7ff         	b	0x700a212a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x2
700a212a: 9805         	ldr	r0, [sp, #0x14]
700a212c: 9900         	ldr	r1, [sp]
700a212e: 6b49         	ldr	r1, [r1, #0x34]
700a2130: 4288         	cmp	r0, r1
700a2132: d22c         	bhs	0x700a218e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x58
700a2134: e7ff         	b	0x700a2136 <Udma_rmAllocRxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2136: 9805         	ldr	r0, [sp, #0x14]
700a2138: 0940         	lsrs	r0, r0, #0x5
700a213a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a213c: 9805         	ldr	r0, [sp, #0x14]
700a213e: 9904         	ldr	r1, [sp, #0x10]
700a2140: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2144: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2146: 9903         	ldr	r1, [sp, #0xc]
700a2148: 2001         	movs	r0, #0x1
700a214a: 4088         	lsls	r0, r1
700a214c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a214e: 9806         	ldr	r0, [sp, #0x18]
700a2150: 9904         	ldr	r1, [sp, #0x10]
700a2152: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2156: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a215a: 9902         	ldr	r1, [sp, #0x8]
700a215c: 4008         	ands	r0, r1
700a215e: 4288         	cmp	r0, r1
700a2160: d110         	bne	0x700a2184 <Udma_rmAllocRxUhcCh+0x94> @ imm = #0x20
700a2162: e7ff         	b	0x700a2164 <Udma_rmAllocRxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a2164: 9a02         	ldr	r2, [sp, #0x8]
700a2166: 9806         	ldr	r0, [sp, #0x18]
700a2168: 9904         	ldr	r1, [sp, #0x10]
700a216a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a216e: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a2172: 4390         	bics	r0, r2
700a2174: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = i + rmInitPrms->startRxUhcCh;  /* Add start offset */
700a2178: 9805         	ldr	r0, [sp, #0x14]
700a217a: 9900         	ldr	r1, [sp]
700a217c: 6b09         	ldr	r1, [r1, #0x30]
700a217e: 4408         	add	r0, r1
700a2180: 9001         	str	r0, [sp, #0x4]
;                 break;
700a2182: e004         	b	0x700a218e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x8
;         }
700a2184: e7ff         	b	0x700a2186 <Udma_rmAllocRxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a2186: 9805         	ldr	r0, [sp, #0x14]
700a2188: 3001         	adds	r0, #0x1
700a218a: 9005         	str	r0, [sp, #0x14]
700a218c: e7cd         	b	0x700a212a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x66
;     }
700a218e: e038         	b	0x700a2202 <Udma_rmAllocRxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a2190: 9807         	ldr	r0, [sp, #0x1c]
700a2192: 9900         	ldr	r1, [sp]
700a2194: 6b09         	ldr	r1, [r1, #0x30]
700a2196: 4288         	cmp	r0, r1
700a2198: d332         	blo	0x700a2200 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x64
700a219a: e7ff         	b	0x700a219c <Udma_rmAllocRxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxUhcCh + rmInitPrms->numRxUhcCh)))
700a219c: 9807         	ldr	r0, [sp, #0x1c]
700a219e: 9a00         	ldr	r2, [sp]
700a21a0: 6b11         	ldr	r1, [r2, #0x30]
700a21a2: 6b52         	ldr	r2, [r2, #0x34]
700a21a4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a21a6: 4288         	cmp	r0, r1
700a21a8: d22a         	bhs	0x700a2200 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x54
700a21aa: e7ff         	b	0x700a21ac <Udma_rmAllocRxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxUhcCh;
700a21ac: 9807         	ldr	r0, [sp, #0x1c]
700a21ae: 9900         	ldr	r1, [sp]
700a21b0: 6b09         	ldr	r1, [r1, #0x30]
700a21b2: 1a40         	subs	r0, r0, r1
700a21b4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a21b6: 9805         	ldr	r0, [sp, #0x14]
700a21b8: 0940         	lsrs	r0, r0, #0x5
700a21ba: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a21bc: 9805         	ldr	r0, [sp, #0x14]
700a21be: 9904         	ldr	r1, [sp, #0x10]
700a21c0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a21c4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a21c6: 9903         	ldr	r1, [sp, #0xc]
700a21c8: 2001         	movs	r0, #0x1
700a21ca: 4088         	lsls	r0, r1
700a21cc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a21ce: 9806         	ldr	r0, [sp, #0x18]
700a21d0: 9904         	ldr	r1, [sp, #0x10]
700a21d2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a21d6: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a21da: 9902         	ldr	r1, [sp, #0x8]
700a21dc: 4008         	ands	r0, r1
700a21de: 4288         	cmp	r0, r1
700a21e0: d10d         	bne	0x700a21fe <Udma_rmAllocRxUhcCh+0x10e> @ imm = #0x1a
700a21e2: e7ff         	b	0x700a21e4 <Udma_rmAllocRxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a21e4: 9a02         	ldr	r2, [sp, #0x8]
700a21e6: 9806         	ldr	r0, [sp, #0x18]
700a21e8: 9904         	ldr	r1, [sp, #0x10]
700a21ea: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a21ee: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a21f2: 4390         	bics	r0, r2
700a21f4: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = preferredChNum;
700a21f8: 9807         	ldr	r0, [sp, #0x1c]
700a21fa: 9001         	str	r0, [sp, #0x4]
;             }
700a21fc: e7ff         	b	0x700a21fe <Udma_rmAllocRxUhcCh+0x10e> @ imm = #-0x2
;         }
700a21fe: e7ff         	b	0x700a2200 <Udma_rmAllocRxUhcCh+0x110> @ imm = #-0x2
700a2200: e7ff         	b	0x700a2202 <Udma_rmAllocRxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2202: 9806         	ldr	r0, [sp, #0x18]
700a2204: f500 609f    	add.w	r0, r0, #0x4f8
700a2208: f007 fdc2    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x7b84
;     return (chNum);
700a220c: 9801         	ldr	r0, [sp, #0x4]
700a220e: b008         	add	sp, #0x20
700a2210: bd80         	pop	{r7, pc}
		...
700a221e: 0000         	movs	r0, r0

700a2220 <Udma_rmAllocTxCh>:
; {
700a2220: b580         	push	{r7, lr}
700a2222: b088         	sub	sp, #0x20
700a2224: 9007         	str	r0, [sp, #0x1c]
700a2226: 9106         	str	r1, [sp, #0x18]
700a2228: 2000         	movs	r0, #0x0
700a222a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a222e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2230: 9806         	ldr	r0, [sp, #0x18]
700a2232: f500 70ea    	add.w	r0, r0, #0x1d4
700a2236: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2238: 9806         	ldr	r0, [sp, #0x18]
700a223a: f500 609f    	add.w	r0, r0, #0x4f8
700a223e: f04f 31ff    	mov.w	r1, #0xffffffff
700a2242: f006 fa55    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x64aa
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2246: 9807         	ldr	r0, [sp, #0x1c]
700a2248: 2101         	movs	r1, #0x1
700a224a: f6cf 71ff    	movt	r1, #0xffff
700a224e: 4288         	cmp	r0, r1
700a2250: d136         	bne	0x700a22c0 <Udma_rmAllocTxCh+0xa0> @ imm = #0x6c
700a2252: e7ff         	b	0x700a2254 <Udma_rmAllocTxCh+0x34> @ imm = #-0x2
700a2254: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a2256: 9005         	str	r0, [sp, #0x14]
700a2258: e7ff         	b	0x700a225a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x2
700a225a: 9805         	ldr	r0, [sp, #0x14]
700a225c: 9900         	ldr	r1, [sp]
700a225e: 6ac9         	ldr	r1, [r1, #0x2c]
700a2260: 4288         	cmp	r0, r1
700a2262: d22c         	bhs	0x700a22be <Udma_rmAllocTxCh+0x9e> @ imm = #0x58
700a2264: e7ff         	b	0x700a2266 <Udma_rmAllocTxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2266: 9805         	ldr	r0, [sp, #0x14]
700a2268: 0940         	lsrs	r0, r0, #0x5
700a226a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a226c: 9805         	ldr	r0, [sp, #0x14]
700a226e: 9904         	ldr	r1, [sp, #0x10]
700a2270: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2274: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2276: 9903         	ldr	r1, [sp, #0xc]
700a2278: 2001         	movs	r0, #0x1
700a227a: 4088         	lsls	r0, r1
700a227c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a227e: 9806         	ldr	r0, [sp, #0x18]
700a2280: 9904         	ldr	r1, [sp, #0x10]
700a2282: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2286: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a228a: 9902         	ldr	r1, [sp, #0x8]
700a228c: 4008         	ands	r0, r1
700a228e: 4288         	cmp	r0, r1
700a2290: d110         	bne	0x700a22b4 <Udma_rmAllocTxCh+0x94> @ imm = #0x20
700a2292: e7ff         	b	0x700a2294 <Udma_rmAllocTxCh+0x74> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a2294: 9a02         	ldr	r2, [sp, #0x8]
700a2296: 9806         	ldr	r0, [sp, #0x18]
700a2298: 9904         	ldr	r1, [sp, #0x10]
700a229a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a229e: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a22a2: 4390         	bics	r0, r2
700a22a4: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = i + rmInitPrms->startTxCh;  /* Add start offset */
700a22a8: 9805         	ldr	r0, [sp, #0x14]
700a22aa: 9900         	ldr	r1, [sp]
700a22ac: 6a89         	ldr	r1, [r1, #0x28]
700a22ae: 4408         	add	r0, r1
700a22b0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a22b2: e004         	b	0x700a22be <Udma_rmAllocTxCh+0x9e> @ imm = #0x8
;         }
700a22b4: e7ff         	b	0x700a22b6 <Udma_rmAllocTxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a22b6: 9805         	ldr	r0, [sp, #0x14]
700a22b8: 3001         	adds	r0, #0x1
700a22ba: 9005         	str	r0, [sp, #0x14]
700a22bc: e7cd         	b	0x700a225a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x66
;     }
700a22be: e038         	b	0x700a2332 <Udma_rmAllocTxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a22c0: 9807         	ldr	r0, [sp, #0x1c]
700a22c2: 9900         	ldr	r1, [sp]
700a22c4: 6a89         	ldr	r1, [r1, #0x28]
700a22c6: 4288         	cmp	r0, r1
700a22c8: d332         	blo	0x700a2330 <Udma_rmAllocTxCh+0x110> @ imm = #0x64
700a22ca: e7ff         	b	0x700a22cc <Udma_rmAllocTxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxCh + rmInitPrms->numTxCh)))
700a22cc: 9807         	ldr	r0, [sp, #0x1c]
700a22ce: 9a00         	ldr	r2, [sp]
700a22d0: 6a91         	ldr	r1, [r2, #0x28]
700a22d2: 6ad2         	ldr	r2, [r2, #0x2c]
700a22d4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a22d6: 4288         	cmp	r0, r1
700a22d8: d22a         	bhs	0x700a2330 <Udma_rmAllocTxCh+0x110> @ imm = #0x54
700a22da: e7ff         	b	0x700a22dc <Udma_rmAllocTxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxCh;
700a22dc: 9807         	ldr	r0, [sp, #0x1c]
700a22de: 9900         	ldr	r1, [sp]
700a22e0: 6a89         	ldr	r1, [r1, #0x28]
700a22e2: 1a40         	subs	r0, r0, r1
700a22e4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a22e6: 9805         	ldr	r0, [sp, #0x14]
700a22e8: 0940         	lsrs	r0, r0, #0x5
700a22ea: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a22ec: 9805         	ldr	r0, [sp, #0x14]
700a22ee: 9904         	ldr	r1, [sp, #0x10]
700a22f0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a22f4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a22f6: 9903         	ldr	r1, [sp, #0xc]
700a22f8: 2001         	movs	r0, #0x1
700a22fa: 4088         	lsls	r0, r1
700a22fc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a22fe: 9806         	ldr	r0, [sp, #0x18]
700a2300: 9904         	ldr	r1, [sp, #0x10]
700a2302: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2306: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a230a: 9902         	ldr	r1, [sp, #0x8]
700a230c: 4008         	ands	r0, r1
700a230e: 4288         	cmp	r0, r1
700a2310: d10d         	bne	0x700a232e <Udma_rmAllocTxCh+0x10e> @ imm = #0x1a
700a2312: e7ff         	b	0x700a2314 <Udma_rmAllocTxCh+0xf4> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a2314: 9a02         	ldr	r2, [sp, #0x8]
700a2316: 9806         	ldr	r0, [sp, #0x18]
700a2318: 9904         	ldr	r1, [sp, #0x10]
700a231a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a231e: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a2322: 4390         	bics	r0, r2
700a2324: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = preferredChNum;
700a2328: 9807         	ldr	r0, [sp, #0x1c]
700a232a: 9001         	str	r0, [sp, #0x4]
;             }
700a232c: e7ff         	b	0x700a232e <Udma_rmAllocTxCh+0x10e> @ imm = #-0x2
;         }
700a232e: e7ff         	b	0x700a2330 <Udma_rmAllocTxCh+0x110> @ imm = #-0x2
700a2330: e7ff         	b	0x700a2332 <Udma_rmAllocTxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2332: 9806         	ldr	r0, [sp, #0x18]
700a2334: f500 609f    	add.w	r0, r0, #0x4f8
700a2338: f007 fd2a    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x7a54
;     return (chNum);
700a233c: 9801         	ldr	r0, [sp, #0x4]
700a233e: b008         	add	sp, #0x20
700a2340: bd80         	pop	{r7, pc}
		...
700a234e: 0000         	movs	r0, r0

700a2350 <Udma_rmAllocTxHcCh>:
; {
700a2350: b580         	push	{r7, lr}
700a2352: b088         	sub	sp, #0x20
700a2354: 9007         	str	r0, [sp, #0x1c]
700a2356: 9106         	str	r1, [sp, #0x18]
700a2358: 2000         	movs	r0, #0x0
700a235a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a235e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2360: 9806         	ldr	r0, [sp, #0x18]
700a2362: f500 70ea    	add.w	r0, r0, #0x1d4
700a2366: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2368: 9806         	ldr	r0, [sp, #0x18]
700a236a: f500 609f    	add.w	r0, r0, #0x4f8
700a236e: f04f 31ff    	mov.w	r1, #0xffffffff
700a2372: f006 f9bd    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x637a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a2376: 9807         	ldr	r0, [sp, #0x1c]
700a2378: 2101         	movs	r1, #0x1
700a237a: f6cf 71ff    	movt	r1, #0xffff
700a237e: 4288         	cmp	r0, r1
700a2380: d136         	bne	0x700a23f0 <Udma_rmAllocTxHcCh+0xa0> @ imm = #0x6c
700a2382: e7ff         	b	0x700a2384 <Udma_rmAllocTxHcCh+0x34> @ imm = #-0x2
700a2384: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a2386: 9005         	str	r0, [sp, #0x14]
700a2388: e7ff         	b	0x700a238a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x2
700a238a: 9805         	ldr	r0, [sp, #0x14]
700a238c: 9900         	ldr	r1, [sp]
700a238e: 6a49         	ldr	r1, [r1, #0x24]
700a2390: 4288         	cmp	r0, r1
700a2392: d22c         	bhs	0x700a23ee <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x58
700a2394: e7ff         	b	0x700a2396 <Udma_rmAllocTxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a2396: 9805         	ldr	r0, [sp, #0x14]
700a2398: 0940         	lsrs	r0, r0, #0x5
700a239a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a239c: 9805         	ldr	r0, [sp, #0x14]
700a239e: 9904         	ldr	r1, [sp, #0x10]
700a23a0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a23a4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a23a6: 9903         	ldr	r1, [sp, #0xc]
700a23a8: 2001         	movs	r0, #0x1
700a23aa: 4088         	lsls	r0, r1
700a23ac: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a23ae: 9806         	ldr	r0, [sp, #0x18]
700a23b0: 9904         	ldr	r1, [sp, #0x10]
700a23b2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a23b6: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a23ba: 9902         	ldr	r1, [sp, #0x8]
700a23bc: 4008         	ands	r0, r1
700a23be: 4288         	cmp	r0, r1
700a23c0: d110         	bne	0x700a23e4 <Udma_rmAllocTxHcCh+0x94> @ imm = #0x20
700a23c2: e7ff         	b	0x700a23c4 <Udma_rmAllocTxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a23c4: 9a02         	ldr	r2, [sp, #0x8]
700a23c6: 9806         	ldr	r0, [sp, #0x18]
700a23c8: 9904         	ldr	r1, [sp, #0x10]
700a23ca: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a23ce: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a23d2: 4390         	bics	r0, r2
700a23d4: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = i + rmInitPrms->startTxHcCh;  /* Add start offset */
700a23d8: 9805         	ldr	r0, [sp, #0x14]
700a23da: 9900         	ldr	r1, [sp]
700a23dc: 6a09         	ldr	r1, [r1, #0x20]
700a23de: 4408         	add	r0, r1
700a23e0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a23e2: e004         	b	0x700a23ee <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x8
;         }
700a23e4: e7ff         	b	0x700a23e6 <Udma_rmAllocTxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a23e6: 9805         	ldr	r0, [sp, #0x14]
700a23e8: 3001         	adds	r0, #0x1
700a23ea: 9005         	str	r0, [sp, #0x14]
700a23ec: e7cd         	b	0x700a238a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x66
;     }
700a23ee: e038         	b	0x700a2462 <Udma_rmAllocTxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a23f0: 9807         	ldr	r0, [sp, #0x1c]
700a23f2: 9900         	ldr	r1, [sp]
700a23f4: 6a09         	ldr	r1, [r1, #0x20]
700a23f6: 4288         	cmp	r0, r1
700a23f8: d332         	blo	0x700a2460 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x64
700a23fa: e7ff         	b	0x700a23fc <Udma_rmAllocTxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxHcCh + rmInitPrms->numTxHcCh)))
700a23fc: 9807         	ldr	r0, [sp, #0x1c]
700a23fe: 9a00         	ldr	r2, [sp]
700a2400: 6a11         	ldr	r1, [r2, #0x20]
700a2402: 6a52         	ldr	r2, [r2, #0x24]
700a2404: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a2406: 4288         	cmp	r0, r1
700a2408: d22a         	bhs	0x700a2460 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x54
700a240a: e7ff         	b	0x700a240c <Udma_rmAllocTxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxHcCh;
700a240c: 9807         	ldr	r0, [sp, #0x1c]
700a240e: 9900         	ldr	r1, [sp]
700a2410: 6a09         	ldr	r1, [r1, #0x20]
700a2412: 1a40         	subs	r0, r0, r1
700a2414: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2416: 9805         	ldr	r0, [sp, #0x14]
700a2418: 0940         	lsrs	r0, r0, #0x5
700a241a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a241c: 9805         	ldr	r0, [sp, #0x14]
700a241e: 9904         	ldr	r1, [sp, #0x10]
700a2420: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2424: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2426: 9903         	ldr	r1, [sp, #0xc]
700a2428: 2001         	movs	r0, #0x1
700a242a: 4088         	lsls	r0, r1
700a242c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a242e: 9806         	ldr	r0, [sp, #0x18]
700a2430: 9904         	ldr	r1, [sp, #0x10]
700a2432: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2436: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a243a: 9902         	ldr	r1, [sp, #0x8]
700a243c: 4008         	ands	r0, r1
700a243e: 4288         	cmp	r0, r1
700a2440: d10d         	bne	0x700a245e <Udma_rmAllocTxHcCh+0x10e> @ imm = #0x1a
700a2442: e7ff         	b	0x700a2444 <Udma_rmAllocTxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a2444: 9a02         	ldr	r2, [sp, #0x8]
700a2446: 9806         	ldr	r0, [sp, #0x18]
700a2448: 9904         	ldr	r1, [sp, #0x10]
700a244a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a244e: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a2452: 4390         	bics	r0, r2
700a2454: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = preferredChNum;
700a2458: 9807         	ldr	r0, [sp, #0x1c]
700a245a: 9001         	str	r0, [sp, #0x4]
;             }
700a245c: e7ff         	b	0x700a245e <Udma_rmAllocTxHcCh+0x10e> @ imm = #-0x2
;         }
700a245e: e7ff         	b	0x700a2460 <Udma_rmAllocTxHcCh+0x110> @ imm = #-0x2
700a2460: e7ff         	b	0x700a2462 <Udma_rmAllocTxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2462: 9806         	ldr	r0, [sp, #0x18]
700a2464: f500 609f    	add.w	r0, r0, #0x4f8
700a2468: f007 fc92    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x7924
;     return (chNum);
700a246c: 9801         	ldr	r0, [sp, #0x4]
700a246e: b008         	add	sp, #0x20
700a2470: bd80         	pop	{r7, pc}
		...
700a247e: 0000         	movs	r0, r0

700a2480 <Udma_rmAllocTxUhcCh>:
; {
700a2480: b580         	push	{r7, lr}
700a2482: b088         	sub	sp, #0x20
700a2484: 9007         	str	r0, [sp, #0x1c]
700a2486: 9106         	str	r1, [sp, #0x18]
700a2488: 2000         	movs	r0, #0x0
700a248a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a248e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a2490: 9806         	ldr	r0, [sp, #0x18]
700a2492: f500 70ea    	add.w	r0, r0, #0x1d4
700a2496: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a2498: 9806         	ldr	r0, [sp, #0x18]
700a249a: f500 609f    	add.w	r0, r0, #0x4f8
700a249e: f04f 31ff    	mov.w	r1, #0xffffffff
700a24a2: f006 f925    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x624a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a24a6: 9807         	ldr	r0, [sp, #0x1c]
700a24a8: 2101         	movs	r1, #0x1
700a24aa: f6cf 71ff    	movt	r1, #0xffff
700a24ae: 4288         	cmp	r0, r1
700a24b0: d136         	bne	0x700a2520 <Udma_rmAllocTxUhcCh+0xa0> @ imm = #0x6c
700a24b2: e7ff         	b	0x700a24b4 <Udma_rmAllocTxUhcCh+0x34> @ imm = #-0x2
700a24b4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a24b6: 9005         	str	r0, [sp, #0x14]
700a24b8: e7ff         	b	0x700a24ba <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x2
700a24ba: 9805         	ldr	r0, [sp, #0x14]
700a24bc: 9900         	ldr	r1, [sp]
700a24be: 69c9         	ldr	r1, [r1, #0x1c]
700a24c0: 4288         	cmp	r0, r1
700a24c2: d22c         	bhs	0x700a251e <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x58
700a24c4: e7ff         	b	0x700a24c6 <Udma_rmAllocTxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a24c6: 9805         	ldr	r0, [sp, #0x14]
700a24c8: 0940         	lsrs	r0, r0, #0x5
700a24ca: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a24cc: 9805         	ldr	r0, [sp, #0x14]
700a24ce: 9904         	ldr	r1, [sp, #0x10]
700a24d0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a24d4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a24d6: 9903         	ldr	r1, [sp, #0xc]
700a24d8: 2001         	movs	r0, #0x1
700a24da: 4088         	lsls	r0, r1
700a24dc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a24de: 9806         	ldr	r0, [sp, #0x18]
700a24e0: 9904         	ldr	r1, [sp, #0x10]
700a24e2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a24e6: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a24ea: 9902         	ldr	r1, [sp, #0x8]
700a24ec: 4008         	ands	r0, r1
700a24ee: 4288         	cmp	r0, r1
700a24f0: d110         	bne	0x700a2514 <Udma_rmAllocTxUhcCh+0x94> @ imm = #0x20
700a24f2: e7ff         	b	0x700a24f4 <Udma_rmAllocTxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a24f4: 9a02         	ldr	r2, [sp, #0x8]
700a24f6: 9806         	ldr	r0, [sp, #0x18]
700a24f8: 9904         	ldr	r1, [sp, #0x10]
700a24fa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a24fe: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a2502: 4390         	bics	r0, r2
700a2504: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = i + rmInitPrms->startTxUhcCh;  /* Add start offset */
700a2508: 9805         	ldr	r0, [sp, #0x14]
700a250a: 9900         	ldr	r1, [sp]
700a250c: 6989         	ldr	r1, [r1, #0x18]
700a250e: 4408         	add	r0, r1
700a2510: 9001         	str	r0, [sp, #0x4]
;                 break;
700a2512: e004         	b	0x700a251e <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x8
;         }
700a2514: e7ff         	b	0x700a2516 <Udma_rmAllocTxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a2516: 9805         	ldr	r0, [sp, #0x14]
700a2518: 3001         	adds	r0, #0x1
700a251a: 9005         	str	r0, [sp, #0x14]
700a251c: e7cd         	b	0x700a24ba <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x66
;     }
700a251e: e038         	b	0x700a2592 <Udma_rmAllocTxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a2520: 9807         	ldr	r0, [sp, #0x1c]
700a2522: 9900         	ldr	r1, [sp]
700a2524: 6989         	ldr	r1, [r1, #0x18]
700a2526: 4288         	cmp	r0, r1
700a2528: d332         	blo	0x700a2590 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x64
700a252a: e7ff         	b	0x700a252c <Udma_rmAllocTxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxUhcCh + rmInitPrms->numTxUhcCh)))
700a252c: 9807         	ldr	r0, [sp, #0x1c]
700a252e: 9a00         	ldr	r2, [sp]
700a2530: 6991         	ldr	r1, [r2, #0x18]
700a2532: 69d2         	ldr	r2, [r2, #0x1c]
700a2534: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a2536: 4288         	cmp	r0, r1
700a2538: d22a         	bhs	0x700a2590 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x54
700a253a: e7ff         	b	0x700a253c <Udma_rmAllocTxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxUhcCh;
700a253c: 9807         	ldr	r0, [sp, #0x1c]
700a253e: 9900         	ldr	r1, [sp]
700a2540: 6989         	ldr	r1, [r1, #0x18]
700a2542: 1a40         	subs	r0, r0, r1
700a2544: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a2546: 9805         	ldr	r0, [sp, #0x14]
700a2548: 0940         	lsrs	r0, r0, #0x5
700a254a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a254c: 9805         	ldr	r0, [sp, #0x14]
700a254e: 9904         	ldr	r1, [sp, #0x10]
700a2550: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a2554: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a2556: 9903         	ldr	r1, [sp, #0xc]
700a2558: 2001         	movs	r0, #0x1
700a255a: 4088         	lsls	r0, r1
700a255c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a255e: 9806         	ldr	r0, [sp, #0x18]
700a2560: 9904         	ldr	r1, [sp, #0x10]
700a2562: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2566: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a256a: 9902         	ldr	r1, [sp, #0x8]
700a256c: 4008         	ands	r0, r1
700a256e: 4288         	cmp	r0, r1
700a2570: d10d         	bne	0x700a258e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #0x1a
700a2572: e7ff         	b	0x700a2574 <Udma_rmAllocTxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a2574: 9a02         	ldr	r2, [sp, #0x8]
700a2576: 9806         	ldr	r0, [sp, #0x18]
700a2578: 9904         	ldr	r1, [sp, #0x10]
700a257a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a257e: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a2582: 4390         	bics	r0, r2
700a2584: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = preferredChNum;
700a2588: 9807         	ldr	r0, [sp, #0x1c]
700a258a: 9001         	str	r0, [sp, #0x4]
;             }
700a258c: e7ff         	b	0x700a258e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #-0x2
;         }
700a258e: e7ff         	b	0x700a2590 <Udma_rmAllocTxUhcCh+0x110> @ imm = #-0x2
700a2590: e7ff         	b	0x700a2592 <Udma_rmAllocTxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a2592: 9806         	ldr	r0, [sp, #0x18]
700a2594: f500 609f    	add.w	r0, r0, #0x4f8
700a2598: f007 fbfa    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x77f4
;     return (chNum);
700a259c: 9801         	ldr	r0, [sp, #0x4]
700a259e: b008         	add	sp, #0x20
700a25a0: bd80         	pop	{r7, pc}
		...
700a25ae: 0000         	movs	r0, r0

700a25b0 <UART_udmaInitRxCh>:
; {
700a25b0: b580         	push	{r7, lr}
700a25b2: b0be         	sub	sp, #0xf8
700a25b4: 903d         	str	r0, [sp, #0xf4]
700a25b6: 913c         	str	r1, [sp, #0xf0]
700a25b8: 200a         	movs	r0, #0xa
;     chType = UDMA_CH_TYPE_PDMA_RX;
700a25ba: 903a         	str	r0, [sp, #0xe8]
;     UdmaChPrms_init(&chPrms, chType);
700a25bc: 993a         	ldr	r1, [sp, #0xe8]
700a25be: a821         	add	r0, sp, #0x84
700a25c0: f006 fff6    	bl	0x700a95b0 <UdmaChPrms_init> @ imm = #0x6fec
;     chPrms.peerChNum                = hUart->hUartInit->rxEvtNum;
700a25c4: 983d         	ldr	r0, [sp, #0xf4]
700a25c6: 6840         	ldr	r0, [r0, #0x4]
700a25c8: 6c00         	ldr	r0, [r0, #0x40]
700a25ca: 9022         	str	r0, [sp, #0x88]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->rxRingMem;
700a25cc: 983c         	ldr	r0, [sp, #0xf0]
700a25ce: 6a80         	ldr	r0, [r0, #0x28]
700a25d0: 9025         	str	r0, [sp, #0x94]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a25d2: 983c         	ldr	r0, [sp, #0xf0]
700a25d4: 6b00         	ldr	r0, [r0, #0x30]
700a25d6: 9026         	str	r0, [sp, #0x98]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a25d8: 983c         	ldr	r0, [sp, #0xf0]
700a25da: 6b40         	ldr	r0, [r0, #0x34]
700a25dc: 9028         	str	r0, [sp, #0xa0]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a25de: 983c         	ldr	r0, [sp, #0xf0]
700a25e0: 6bc0         	ldr	r0, [r0, #0x3c]
700a25e2: 2801         	cmp	r0, #0x1
700a25e4: d10a         	bne	0x700a25fc <UART_udmaInitRxCh+0x4c> @ imm = #0x14
700a25e6: e7ff         	b	0x700a25e8 <UART_udmaInitRxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqRxRingMem;
700a25e8: 983c         	ldr	r0, [sp, #0xf0]
700a25ea: 6ac0         	ldr	r0, [r0, #0x2c]
700a25ec: 902c         	str	r0, [sp, #0xb0]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a25ee: 983c         	ldr	r0, [sp, #0xf0]
700a25f0: 6b00         	ldr	r0, [r0, #0x30]
700a25f2: 902d         	str	r0, [sp, #0xb4]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a25f4: 983c         	ldr	r0, [sp, #0xf0]
700a25f6: 6b40         	ldr	r0, [r0, #0x34]
700a25f8: 902f         	str	r0, [sp, #0xbc]
;     }
700a25fa: e7ff         	b	0x700a25fc <UART_udmaInitRxCh+0x4c> @ imm = #-0x2
;     rxChHandle                      = udmaChCfg->rxChHandle;
700a25fc: 983c         	ldr	r0, [sp, #0xf0]
700a25fe: 6880         	ldr	r0, [r0, #0x8]
700a2600: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a2602: 983c         	ldr	r0, [sp, #0xf0]
700a2604: 6800         	ldr	r0, [r0]
700a2606: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, rxChHandle, chType, &chPrms);
700a2608: 9807         	ldr	r0, [sp, #0x1c]
700a260a: 9906         	ldr	r1, [sp, #0x18]
700a260c: 9a3a         	ldr	r2, [sp, #0xe8]
700a260e: ab21         	add	r3, sp, #0x84
700a2610: f7fd fa7e    	bl	0x7009fb10 <Udma_chOpen> @ imm = #-0x2b04
700a2614: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a2616: 983b         	ldr	r0, [sp, #0xec]
700a2618: fab0 f080    	clz	r0, r0
700a261c: 0940         	lsrs	r0, r0, #0x5
700a261e: f64f 0130    	movw	r1, #0xf830
700a2622: f2c7 010a    	movt	r1, #0x700a
700a2626: 9103         	str	r1, [sp, #0xc]
700a2628: 466a         	mov	r2, sp
700a262a: 6011         	str	r1, [r2]
700a262c: f24f 41b9    	movw	r1, #0xf4b9
700a2630: f2c7 010a    	movt	r1, #0x700a
700a2634: 9104         	str	r1, [sp, #0x10]
700a2636: f64f 02b4    	movw	r2, #0xf8b4
700a263a: f2c7 020a    	movt	r2, #0x700a
700a263e: 9205         	str	r2, [sp, #0x14]
700a2640: 2366         	movs	r3, #0x66
700a2642: f006 faad    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x655a
;     UdmaChRxPrms_init(&rxPrms, chType);
700a2646: 993a         	ldr	r1, [sp, #0xe8]
700a2648: a81a         	add	r0, sp, #0x68
700a264a: 9001         	str	r0, [sp, #0x4]
700a264c: f003 fc60    	bl	0x700a5f10 <UdmaChRxPrms_init> @ imm = #0x38c0
700a2650: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigRx(rxChHandle, &rxPrms);
700a2652: 9806         	ldr	r0, [sp, #0x18]
700a2654: f7fa f974    	bl	0x7009c940 <Udma_chConfigRx> @ imm = #-0x5d18
700a2658: 9b03         	ldr	r3, [sp, #0xc]
700a265a: 9904         	ldr	r1, [sp, #0x10]
700a265c: 9a05         	ldr	r2, [sp, #0x14]
700a265e: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a2660: 983b         	ldr	r0, [sp, #0xec]
700a2662: fab0 f080    	clz	r0, r0
700a2666: 0940         	lsrs	r0, r0, #0x5
700a2668: 46ec         	mov	r12, sp
700a266a: f8cc 3000    	str.w	r3, [r12]
700a266e: 236b         	movs	r3, #0x6b
700a2670: f006 fa96    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x652c
;     eventHandle = udmaChCfg->cqRxEvtHandle;
700a2674: 983c         	ldr	r0, [sp, #0xf0]
700a2676: 6900         	ldr	r0, [r0, #0x10]
700a2678: 9019         	str	r0, [sp, #0x64]
700a267a: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a267c: 9002         	str	r0, [sp, #0x8]
700a267e: f007 fbbf    	bl	0x700a9e00 <UdmaEventPrms_init> @ imm = #0x777e
700a2682: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a2684: 9008         	str	r0, [sp, #0x20]
700a2686: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a2688: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = rxChHandle;
700a268a: 9806         	ldr	r0, [sp, #0x18]
700a268c: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a268e: 9807         	ldr	r0, [sp, #0x1c]
700a2690: f008 fa36    	bl	0x700aab00 <Udma_eventGetGlobalHandle> @ imm = #0x846c
700a2694: 9a02         	ldr	r2, [sp, #0x8]
700a2696: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrRx;
700a2698: f247 50e1    	movw	r0, #0x75e1
700a269c: f2c7 000a    	movt	r0, #0x700a
700a26a0: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a26a2: 983d         	ldr	r0, [sp, #0xf4]
700a26a4: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a26a6: 9807         	ldr	r0, [sp, #0x1c]
700a26a8: 9919         	ldr	r1, [sp, #0x64]
700a26aa: f7fa fde9    	bl	0x7009d280 <Udma_eventRegister> @ imm = #-0x542e
700a26ae: 9b03         	ldr	r3, [sp, #0xc]
700a26b0: 9904         	ldr	r1, [sp, #0x10]
700a26b2: 9a05         	ldr	r2, [sp, #0x14]
700a26b4: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a26b6: 983b         	ldr	r0, [sp, #0xec]
700a26b8: fab0 f080    	clz	r0, r0
700a26bc: 0940         	lsrs	r0, r0, #0x5
700a26be: 46ec         	mov	r12, sp
700a26c0: f8cc 3000    	str.w	r3, [r12]
700a26c4: 2377         	movs	r3, #0x77
700a26c6: f006 fa6b    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x64d6
;     return retVal;
700a26ca: 983b         	ldr	r0, [sp, #0xec]
700a26cc: b03e         	add	sp, #0xf8
700a26ce: bd80         	pop	{r7, pc}

700a26d0 <UART_udmaInitTxCh>:
; {
700a26d0: b580         	push	{r7, lr}
700a26d2: b0bc         	sub	sp, #0xf0
700a26d4: 903b         	str	r0, [sp, #0xec]
700a26d6: 913a         	str	r1, [sp, #0xe8]
700a26d8: 2009         	movs	r0, #0x9
;     chType = UDMA_CH_TYPE_PDMA_TX;
700a26da: 9038         	str	r0, [sp, #0xe0]
;     UdmaChPrms_init(&chPrms, chType);
700a26dc: 9938         	ldr	r1, [sp, #0xe0]
700a26de: a81f         	add	r0, sp, #0x7c
700a26e0: f006 ff66    	bl	0x700a95b0 <UdmaChPrms_init> @ imm = #0x6ecc
;     chPrms.peerChNum                = hUart->hUartInit->txEvtNum;
700a26e4: 983b         	ldr	r0, [sp, #0xec]
700a26e6: 6840         	ldr	r0, [r0, #0x4]
700a26e8: 6c40         	ldr	r0, [r0, #0x44]
700a26ea: 9020         	str	r0, [sp, #0x80]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->txRingMem;
700a26ec: 983a         	ldr	r0, [sp, #0xe8]
700a26ee: 6a00         	ldr	r0, [r0, #0x20]
700a26f0: 9023         	str	r0, [sp, #0x8c]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a26f2: 983a         	ldr	r0, [sp, #0xe8]
700a26f4: 6b00         	ldr	r0, [r0, #0x30]
700a26f6: 9024         	str	r0, [sp, #0x90]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a26f8: 983a         	ldr	r0, [sp, #0xe8]
700a26fa: 6b40         	ldr	r0, [r0, #0x34]
700a26fc: 9026         	str	r0, [sp, #0x98]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a26fe: 983a         	ldr	r0, [sp, #0xe8]
700a2700: 6bc0         	ldr	r0, [r0, #0x3c]
700a2702: 2801         	cmp	r0, #0x1
700a2704: d10a         	bne	0x700a271c <UART_udmaInitTxCh+0x4c> @ imm = #0x14
700a2706: e7ff         	b	0x700a2708 <UART_udmaInitTxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqTxRingMem;
700a2708: 983a         	ldr	r0, [sp, #0xe8]
700a270a: 6a40         	ldr	r0, [r0, #0x24]
700a270c: 902a         	str	r0, [sp, #0xa8]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a270e: 983a         	ldr	r0, [sp, #0xe8]
700a2710: 6b00         	ldr	r0, [r0, #0x30]
700a2712: 902b         	str	r0, [sp, #0xac]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a2714: 983a         	ldr	r0, [sp, #0xe8]
700a2716: 6b40         	ldr	r0, [r0, #0x34]
700a2718: 902d         	str	r0, [sp, #0xb4]
;     }
700a271a: e7ff         	b	0x700a271c <UART_udmaInitTxCh+0x4c> @ imm = #-0x2
;     txChHandle                      = udmaChCfg->txChHandle;
700a271c: 983a         	ldr	r0, [sp, #0xe8]
700a271e: 6840         	ldr	r0, [r0, #0x4]
700a2720: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a2722: 983a         	ldr	r0, [sp, #0xe8]
700a2724: 6800         	ldr	r0, [r0]
700a2726: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, txChHandle, chType, &chPrms);
700a2728: 9807         	ldr	r0, [sp, #0x1c]
700a272a: 9906         	ldr	r1, [sp, #0x18]
700a272c: 9a38         	ldr	r2, [sp, #0xe0]
700a272e: ab1f         	add	r3, sp, #0x7c
700a2730: f7fd f9ee    	bl	0x7009fb10 <Udma_chOpen> @ imm = #-0x2c24
700a2734: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a2736: 9839         	ldr	r0, [sp, #0xe4]
700a2738: fab0 f080    	clz	r0, r0
700a273c: 0940         	lsrs	r0, r0, #0x5
700a273e: f64f 0130    	movw	r1, #0xf830
700a2742: f2c7 010a    	movt	r1, #0x700a
700a2746: 9103         	str	r1, [sp, #0xc]
700a2748: 466a         	mov	r2, sp
700a274a: 6011         	str	r1, [r2]
700a274c: f24f 41b9    	movw	r1, #0xf4b9
700a2750: f2c7 010a    	movt	r1, #0x700a
700a2754: 9104         	str	r1, [sp, #0x10]
700a2756: f64f 02ea    	movw	r2, #0xf8ea
700a275a: f2c7 020a    	movt	r2, #0x700a
700a275e: 9205         	str	r2, [sp, #0x14]
700a2760: 2398         	movs	r3, #0x98
700a2762: f006 fa1d    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x643a
;     UdmaChTxPrms_init(&txPrms, chType);
700a2766: 9938         	ldr	r1, [sp, #0xe0]
700a2768: a81a         	add	r0, sp, #0x68
700a276a: 9001         	str	r0, [sp, #0x4]
700a276c: f003 fc28    	bl	0x700a5fc0 <UdmaChTxPrms_init> @ imm = #0x3850
700a2770: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigTx(txChHandle, &txPrms);
700a2772: 9806         	ldr	r0, [sp, #0x18]
700a2774: f7fb ffe4    	bl	0x7009e740 <Udma_chConfigTx> @ imm = #-0x4038
700a2778: 9b03         	ldr	r3, [sp, #0xc]
700a277a: 9904         	ldr	r1, [sp, #0x10]
700a277c: 9a05         	ldr	r2, [sp, #0x14]
700a277e: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a2780: 9839         	ldr	r0, [sp, #0xe4]
700a2782: fab0 f080    	clz	r0, r0
700a2786: 0940         	lsrs	r0, r0, #0x5
700a2788: 46ec         	mov	r12, sp
700a278a: f8cc 3000    	str.w	r3, [r12]
700a278e: 239d         	movs	r3, #0x9d
700a2790: f006 fa06    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x640c
;     eventHandle = udmaChCfg->cqTxEvtHandle;
700a2794: 983a         	ldr	r0, [sp, #0xe8]
700a2796: 68c0         	ldr	r0, [r0, #0xc]
700a2798: 9019         	str	r0, [sp, #0x64]
700a279a: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a279c: 9002         	str	r0, [sp, #0x8]
700a279e: f007 fb2f    	bl	0x700a9e00 <UdmaEventPrms_init> @ imm = #0x765e
700a27a2: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a27a4: 9008         	str	r0, [sp, #0x20]
700a27a6: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a27a8: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = txChHandle;
700a27aa: 9806         	ldr	r0, [sp, #0x18]
700a27ac: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a27ae: 9807         	ldr	r0, [sp, #0x1c]
700a27b0: f008 f9a6    	bl	0x700aab00 <Udma_eventGetGlobalHandle> @ imm = #0x834c
700a27b4: 9a02         	ldr	r2, [sp, #0x8]
700a27b6: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrTx;
700a27b8: f247 6081    	movw	r0, #0x7681
700a27bc: f2c7 000a    	movt	r0, #0x700a
700a27c0: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a27c2: 983b         	ldr	r0, [sp, #0xec]
700a27c4: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a27c6: 9807         	ldr	r0, [sp, #0x1c]
700a27c8: 9919         	ldr	r1, [sp, #0x64]
700a27ca: f7fa fd59    	bl	0x7009d280 <Udma_eventRegister> @ imm = #-0x554e
700a27ce: 9b03         	ldr	r3, [sp, #0xc]
700a27d0: 9904         	ldr	r1, [sp, #0x10]
700a27d2: 9a05         	ldr	r2, [sp, #0x14]
700a27d4: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a27d6: 9839         	ldr	r0, [sp, #0xe4]
700a27d8: fab0 f080    	clz	r0, r0
700a27dc: 0940         	lsrs	r0, r0, #0x5
700a27de: 46ec         	mov	r12, sp
700a27e0: f8cc 3000    	str.w	r3, [r12]
700a27e4: 23a9         	movs	r3, #0xa9
700a27e6: f006 f9db    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x63b6
;     return retVal;
700a27ea: 9839         	ldr	r0, [sp, #0xe4]
700a27ec: b03c         	add	sp, #0xf0
700a27ee: bd80         	pop	{r7, pc}

700a27f0 <Sciclient_rmIaValidateEvt>:
; {
700a27f0: b580         	push	{r7, lr}
700a27f2: b086         	sub	sp, #0x18
700a27f4: 4684         	mov	r12, r0
700a27f6: 9808         	ldr	r0, [sp, #0x20]
700a27f8: f8cd c014    	str.w	r12, [sp, #0x14]
700a27fc: f8ad 1012    	strh.w	r1, [sp, #0x12]
700a2800: f8ad 2010    	strh.w	r2, [sp, #0x10]
700a2804: f88d 300f    	strb.w	r3, [sp, #0xf]
700a2808: f88d 000e    	strb.w	r0, [sp, #0xe]
700a280c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a280e: 9002         	str	r0, [sp, #0x8]
;     if (evt >= inst->n_sevt) {
700a2810: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a2814: 9905         	ldr	r1, [sp, #0x14]
700a2816: 8949         	ldrh	r1, [r1, #0xa]
700a2818: 4288         	cmp	r0, r1
700a281a: db04         	blt	0x700a2826 <Sciclient_rmIaValidateEvt+0x36> @ imm = #0x8
700a281c: e7ff         	b	0x700a281e <Sciclient_rmIaValidateEvt+0x2e> @ imm = #-0x2
700a281e: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a2822: 9002         	str	r0, [sp, #0x8]
;     }
700a2824: e7ff         	b	0x700a2826 <Sciclient_rmIaValidateEvt+0x36> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a2826: 9802         	ldr	r0, [sp, #0x8]
700a2828: 2800         	cmp	r0, #0x0
700a282a: d16d         	bne	0x700a2908 <Sciclient_rmIaValidateEvt+0x118> @ imm = #0xda
700a282c: e7ff         	b	0x700a282e <Sciclient_rmIaValidateEvt+0x3e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a282e: 9805         	ldr	r0, [sp, #0x14]
700a2830: 6840         	ldr	r0, [r0, #0x4]
700a2832: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a2836: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a283a: 9001         	str	r0, [sp, #0x4]
;         if (in_use == true) {
700a283c: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700a2840: 07c0         	lsls	r0, r0, #0x1f
700a2842: 2800         	cmp	r0, #0x0
700a2844: d047         	beq	0x700a28d6 <Sciclient_rmIaValidateEvt+0xe6> @ imm = #0x8e
700a2846: e7ff         	b	0x700a2848 <Sciclient_rmIaValidateEvt+0x58> @ imm = #-0x2
;             reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a2848: 9801         	ldr	r0, [sp, #0x4]
700a284a: f64f 7100    	movw	r1, #0xff00
700a284e: f2c0 0101    	movt	r1, #0x1
700a2852: 2208         	movs	r2, #0x8
700a2854: f00a fa74    	bl	0x700acd40 <CSL_REG32_FEXT_RAW> @ imm = #0xa4e8
700a2858: f8ad 0002    	strh.w	r0, [sp, #0x2]
;             reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a285c: 9801         	ldr	r0, [sp, #0x4]
700a285e: 213f         	movs	r1, #0x3f
700a2860: 2200         	movs	r2, #0x0
700a2862: f00a fa6d    	bl	0x700acd40 <CSL_REG32_FEXT_RAW> @ imm = #0xa4da
700a2866: f8ad 0000    	strh.w	r0, [sp]
;             if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a286a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a286e: b9f0         	cbnz	r0, 0x700a28ae <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x3c
700a2870: e7ff         	b	0x700a2872 <Sciclient_rmIaValidateEvt+0x82> @ imm = #-0x2
700a2872: f8bd 0000    	ldrh.w	r0, [sp]
700a2876: b9d0         	cbnz	r0, 0x700a28ae <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x34
700a2878: e7ff         	b	0x700a287a <Sciclient_rmIaValidateEvt+0x8a> @ imm = #-0x2
;                 if ((vint != reg_vint) &&
700a287a: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a287e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a2882: 4288         	cmp	r0, r1
700a2884: d012         	beq	0x700a28ac <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x24
700a2886: e7ff         	b	0x700a2888 <Sciclient_rmIaValidateEvt+0x98> @ imm = #-0x2
;                     (vint_sb_index != reg_sb) &&
700a2888: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a288c: f8bd 1000    	ldrh.w	r1, [sp]
700a2890: 4288         	cmp	r0, r1
700a2892: d00b         	beq	0x700a28ac <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x16
700a2894: e7ff         	b	0x700a2896 <Sciclient_rmIaValidateEvt+0xa6> @ imm = #-0x2
;                     (evt != inst->v0_b0_evt)) {
700a2896: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a289a: 9905         	ldr	r1, [sp, #0x14]
700a289c: 8a89         	ldrh	r1, [r1, #0x14]
;                 if ((vint != reg_vint) &&
700a289e: 4288         	cmp	r0, r1
700a28a0: d004         	beq	0x700a28ac <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x8
700a28a2: e7ff         	b	0x700a28a4 <Sciclient_rmIaValidateEvt+0xb4> @ imm = #-0x2
700a28a4: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a28a8: 9002         	str	r0, [sp, #0x8]
;                 }
700a28aa: e7ff         	b	0x700a28ac <Sciclient_rmIaValidateEvt+0xbc> @ imm = #-0x2
;             } else {
700a28ac: e012         	b	0x700a28d4 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #0x24
;                 if ((vint != reg_vint) &&
700a28ae: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a28b2: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a28b6: 4288         	cmp	r0, r1
700a28b8: d00b         	beq	0x700a28d2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x16
700a28ba: e7ff         	b	0x700a28bc <Sciclient_rmIaValidateEvt+0xcc> @ imm = #-0x2
;                     (vint_sb_index != reg_sb)) {
700a28bc: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a28c0: f8bd 1000    	ldrh.w	r1, [sp]
;                 if ((vint != reg_vint) &&
700a28c4: 4288         	cmp	r0, r1
700a28c6: d004         	beq	0x700a28d2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x8
700a28c8: e7ff         	b	0x700a28ca <Sciclient_rmIaValidateEvt+0xda> @ imm = #-0x2
700a28ca: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a28ce: 9002         	str	r0, [sp, #0x8]
;                 }
700a28d0: e7ff         	b	0x700a28d2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #-0x2
700a28d2: e7ff         	b	0x700a28d4 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #-0x2
;         } else {
700a28d4: e017         	b	0x700a2906 <Sciclient_rmIaValidateEvt+0x116> @ imm = #0x2e
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a28d6: 9801         	ldr	r0, [sp, #0x4]
700a28d8: f00a ff12    	bl	0x700ad700 <CSL_REG32_RD_RAW> @ imm = #0xae24
700a28dc: b138         	cbz	r0, 0x700a28ee <Sciclient_rmIaValidateEvt+0xfe> @ imm = #0xe
700a28de: e7ff         	b	0x700a28e0 <Sciclient_rmIaValidateEvt+0xf0> @ imm = #-0x2
;                  (Sciclient_rmIaEvtRomMapped(inst, evt) == false)) ||
700a28e0: 9805         	ldr	r0, [sp, #0x14]
700a28e2: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a28e6: f005 fba3    	bl	0x700a8030 <Sciclient_rmIaEvtRomMapped> @ imm = #0x5746
700a28ea: b138         	cbz	r0, 0x700a28fc <Sciclient_rmIaValidateEvt+0x10c> @ imm = #0xe
700a28ec: e7ff         	b	0x700a28ee <Sciclient_rmIaValidateEvt+0xfe> @ imm = #-0x2
;                 (evt == inst->v0_b0_evt)) {
700a28ee: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a28f2: 9905         	ldr	r1, [sp, #0x14]
700a28f4: 8a89         	ldrh	r1, [r1, #0x14]
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a28f6: 4288         	cmp	r0, r1
700a28f8: d104         	bne	0x700a2904 <Sciclient_rmIaValidateEvt+0x114> @ imm = #0x8
700a28fa: e7ff         	b	0x700a28fc <Sciclient_rmIaValidateEvt+0x10c> @ imm = #-0x2
700a28fc: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a2900: 9002         	str	r0, [sp, #0x8]
;             }
700a2902: e7ff         	b	0x700a2904 <Sciclient_rmIaValidateEvt+0x114> @ imm = #-0x2
700a2904: e7ff         	b	0x700a2906 <Sciclient_rmIaValidateEvt+0x116> @ imm = #-0x2
;     }
700a2906: e7ff         	b	0x700a2908 <Sciclient_rmIaValidateEvt+0x118> @ imm = #-0x2
;     return r;
700a2908: 9802         	ldr	r0, [sp, #0x8]
700a290a: b006         	add	sp, #0x18
700a290c: bd80         	pop	{r7, pc}
700a290e: 0000         	movs	r0, r0

700a2910 <Sciclient_rmIrqVintAdd>:
; {
700a2910: b580         	push	{r7, lr}
700a2912: b08c         	sub	sp, #0x30
700a2914: 900b         	str	r0, [sp, #0x2c]
700a2916: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a2918: 900a         	str	r0, [sp, #0x28]
;     bool cfg_new_mapping = false;
700a291a: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool cfg_whole_route = false;
700a291e: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a2922: 9008         	str	r0, [sp, #0x20]
;     r = Sciclient_rmIrqIsVintRouteSet(cfg, &vint_used);
700a2924: 980b         	ldr	r0, [sp, #0x2c]
700a2926: f10d 0127    	add.w	r1, sp, #0x27
700a292a: f002 fca9    	bl	0x700a5280 <Sciclient_rmIrqIsVintRouteSet> @ imm = #0x2952
700a292e: 900a         	str	r0, [sp, #0x28]
;     if (r == SystemP_SUCCESS) {
700a2930: 980a         	ldr	r0, [sp, #0x28]
700a2932: b9a0         	cbnz	r0, 0x700a295e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #0x28
700a2934: e7ff         	b	0x700a2936 <Sciclient_rmIrqVintAdd+0x26> @ imm = #-0x2
;         if ((vint_used == true) ||
700a2936: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a293a: 07c0         	lsls	r0, r0, #0x1f
700a293c: b930         	cbnz	r0, 0x700a294c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #0xc
700a293e: e7ff         	b	0x700a2940 <Sciclient_rmIrqVintAdd+0x30> @ imm = #-0x2
;             (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a2940: 980b         	ldr	r0, [sp, #0x2c]
700a2942: 6800         	ldr	r0, [r0]
700a2944: f006 ff4c    	bl	0x700a97e0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x6e98
;         if ((vint_used == true) ||
700a2948: b120         	cbz	r0, 0x700a2954 <Sciclient_rmIrqVintAdd+0x44> @ imm = #0x8
700a294a: e7ff         	b	0x700a294c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #-0x2
700a294c: 2001         	movs	r0, #0x1
;             cfg_new_mapping = true;
700a294e: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a2952: e003         	b	0x700a295c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #0x6
700a2954: 2001         	movs	r0, #0x1
;             cfg_whole_route = true;
700a2956: f88d 0025    	strb.w	r0, [sp, #0x25]
700a295a: e7ff         	b	0x700a295c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #-0x2
;     }
700a295c: e7ff         	b	0x700a295e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #-0x2
;     if (cfg_new_mapping == true) {
700a295e: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a2962: 07c0         	lsls	r0, r0, #0x1f
700a2964: 2800         	cmp	r0, #0x0
700a2966: d04c         	beq	0x700a2a02 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #0x98
700a2968: e7ff         	b	0x700a296a <Sciclient_rmIrqVintAdd+0x5a> @ imm = #-0x2
700a296a: 203c         	movs	r0, #0x3c
700a296c: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a2970: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a2972: 980b         	ldr	r0, [sp, #0x2c]
700a2974: 7900         	ldrb	r0, [r0, #0x4]
700a2976: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a297a: 980b         	ldr	r0, [sp, #0x2c]
700a297c: 88c0         	ldrh	r0, [r0, #0x6]
700a297e: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a2982: 980b         	ldr	r0, [sp, #0x2c]
700a2984: 8900         	ldrh	r0, [r0, #0x8]
700a2986: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a298a: 980b         	ldr	r0, [sp, #0x2c]
700a298c: 8a00         	ldrh	r0, [r0, #0x10]
700a298e: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a2992: 980b         	ldr	r0, [sp, #0x2c]
700a2994: 8a40         	ldrh	r0, [r0, #0x12]
700a2996: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a299a: 980b         	ldr	r0, [sp, #0x2c]
700a299c: 89c0         	ldrh	r0, [r0, #0xe]
700a299e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a29a2: 980b         	ldr	r0, [sp, #0x2c]
700a29a4: 7d00         	ldrb	r0, [r0, #0x14]
700a29a6: f88d 001e    	strb.w	r0, [sp, #0x1e]
;                                   cfg->set_resp,
700a29aa: 980b         	ldr	r0, [sp, #0x2c]
700a29ac: 6981         	ldr	r1, [r0, #0x18]
700a29ae: a801         	add	r0, sp, #0x4
700a29b0: f04f 32ff    	mov.w	r2, #0xffffffff
;         r = Sciclient_rmIrqSetRaw(&req,
700a29b4: f007 fe94    	bl	0x700aa6e0 <Sciclient_rmIrqSetRaw> @ imm = #0x7d28
700a29b8: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a29ba: 980a         	ldr	r0, [sp, #0x28]
700a29bc: bb00         	cbnz	r0, 0x700a2a00 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #0x40
700a29be: e7ff         	b	0x700a29c0 <Sciclient_rmIrqVintAdd+0xb0> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a29c0: 980b         	ldr	r0, [sp, #0x2c]
700a29c2: 8a00         	ldrh	r0, [r0, #0x10]
700a29c4: f007 fd0c    	bl	0x700aa3e0 <Sciclient_rmIaGetInst> @ imm = #0x7a18
700a29c8: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a29ca: 9808         	ldr	r0, [sp, #0x20]
700a29cc: b1b8         	cbz	r0, 0x700a29fe <Sciclient_rmIrqVintAdd+0xee> @ imm = #0x2e
700a29ce: e7ff         	b	0x700a29d0 <Sciclient_rmIrqVintAdd+0xc0> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]++;
700a29d0: 9808         	ldr	r0, [sp, #0x20]
700a29d2: 6901         	ldr	r1, [r0, #0x10]
700a29d4: 980b         	ldr	r0, [sp, #0x2c]
700a29d6: 8a42         	ldrh	r2, [r0, #0x12]
700a29d8: 5c88         	ldrb	r0, [r1, r2]
700a29da: 3001         	adds	r0, #0x1
700a29dc: 5488         	strb	r0, [r1, r2]
;                 if ((cfg->vint == 0) && (cfg->vint_sb == 0)) {
700a29de: 980b         	ldr	r0, [sp, #0x2c]
700a29e0: 8a40         	ldrh	r0, [r0, #0x12]
700a29e2: b958         	cbnz	r0, 0x700a29fc <Sciclient_rmIrqVintAdd+0xec> @ imm = #0x16
700a29e4: e7ff         	b	0x700a29e6 <Sciclient_rmIrqVintAdd+0xd6> @ imm = #-0x2
700a29e6: 980b         	ldr	r0, [sp, #0x2c]
700a29e8: 7d00         	ldrb	r0, [r0, #0x14]
700a29ea: b938         	cbnz	r0, 0x700a29fc <Sciclient_rmIrqVintAdd+0xec> @ imm = #0xe
700a29ec: e7ff         	b	0x700a29ee <Sciclient_rmIrqVintAdd+0xde> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = cfg->global_evt - ia_inst->sevt_offset;
700a29ee: 980b         	ldr	r0, [sp, #0x2c]
700a29f0: 89c0         	ldrh	r0, [r0, #0xe]
700a29f2: 9908         	ldr	r1, [sp, #0x20]
700a29f4: 890a         	ldrh	r2, [r1, #0x8]
700a29f6: 1a80         	subs	r0, r0, r2
700a29f8: 8288         	strh	r0, [r1, #0x14]
;                 }
700a29fa: e7ff         	b	0x700a29fc <Sciclient_rmIrqVintAdd+0xec> @ imm = #-0x2
;             }
700a29fc: e7ff         	b	0x700a29fe <Sciclient_rmIrqVintAdd+0xee> @ imm = #-0x2
;         }
700a29fe: e7ff         	b	0x700a2a00 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #-0x2
;     }
700a2a00: e7ff         	b	0x700a2a02 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #-0x2
;     if (cfg_whole_route == true) {
700a2a02: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a2a06: 07c0         	lsls	r0, r0, #0x1f
700a2a08: b170         	cbz	r0, 0x700a2a28 <Sciclient_rmIrqVintAdd+0x118> @ imm = #0x1c
700a2a0a: e7ff         	b	0x700a2a0c <Sciclient_rmIrqVintAdd+0xfc> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700a2a0c: 980b         	ldr	r0, [sp, #0x2c]
700a2a0e: f7fa f8c7    	bl	0x7009cba0 <Sciclient_rmIrqFindRoute> @ imm = #-0x5e72
700a2a12: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2a14: 980a         	ldr	r0, [sp, #0x28]
700a2a16: b930         	cbnz	r0, 0x700a2a26 <Sciclient_rmIrqVintAdd+0x116> @ imm = #0xc
700a2a18: e7ff         	b	0x700a2a1a <Sciclient_rmIrqVintAdd+0x10a> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, true);
700a2a1a: 980b         	ldr	r0, [sp, #0x2c]
700a2a1c: 2101         	movs	r1, #0x1
700a2a1e: f7fc fa7f    	bl	0x7009ef20 <Sciclient_rmIrqProgramRoute> @ imm = #-0x3b02
700a2a22: 900a         	str	r0, [sp, #0x28]
;         }
700a2a24: e7ff         	b	0x700a2a26 <Sciclient_rmIrqVintAdd+0x116> @ imm = #-0x2
;     }
700a2a26: e7ff         	b	0x700a2a28 <Sciclient_rmIrqVintAdd+0x118> @ imm = #-0x2
;     return r;
700a2a28: 980a         	ldr	r0, [sp, #0x28]
700a2a2a: b00c         	add	sp, #0x30
700a2a2c: bd80         	pop	{r7, pc}
700a2a2e: 0000         	movs	r0, r0

700a2a30 <xTaskPriorityInherit>:
; BaseType_t xTaskPriorityInherit(TaskHandle_t const pxMutexHolder) {
700a2a30: b580         	push	{r7, lr}
700a2a32: b084         	sub	sp, #0x10
700a2a34: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxMutexHolderTCB = pxMutexHolder;
700a2a36: 9803         	ldr	r0, [sp, #0xc]
700a2a38: 9002         	str	r0, [sp, #0x8]
700a2a3a: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a2a3c: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a2a3e: 9803         	ldr	r0, [sp, #0xc]
700a2a40: 2800         	cmp	r0, #0x0
700a2a42: d07e         	beq	0x700a2b42 <xTaskPriorityInherit+0x112> @ imm = #0xfc
700a2a44: e7ff         	b	0x700a2a46 <xTaskPriorityInherit+0x16> @ imm = #-0x2
;     if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority) {
700a2a46: 9802         	ldr	r0, [sp, #0x8]
700a2a48: 6ac0         	ldr	r0, [r0, #0x2c]
700a2a4a: f240 11cc    	movw	r1, #0x1cc
700a2a4e: f2c7 010b    	movt	r1, #0x700b
700a2a52: 6809         	ldr	r1, [r1]
700a2a54: 6ac9         	ldr	r1, [r1, #0x2c]
700a2a56: 4288         	cmp	r0, r1
700a2a58: d262         	bhs	0x700a2b20 <xTaskPriorityInherit+0xf0> @ imm = #0xc4
700a2a5a: e7ff         	b	0x700a2a5c <xTaskPriorityInherit+0x2c> @ imm = #-0x2
;       if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) &
700a2a5c: 9802         	ldr	r0, [sp, #0x8]
700a2a5e: 7ec0         	ldrb	r0, [r0, #0x1b]
700a2a60: 0600         	lsls	r0, r0, #0x18
700a2a62: 2800         	cmp	r0, #0x0
700a2a64: d40b         	bmi	0x700a2a7e <xTaskPriorityInherit+0x4e> @ imm = #0x16
700a2a66: e7ff         	b	0x700a2a68 <xTaskPriorityInherit+0x38> @ imm = #-0x2
;         listSET_LIST_ITEM_VALUE(
700a2a68: f240 10cc    	movw	r0, #0x1cc
700a2a6c: f2c7 000b    	movt	r0, #0x700b
700a2a70: 6800         	ldr	r0, [r0]
700a2a72: 6ac0         	ldr	r0, [r0, #0x2c]
700a2a74: f1c0 0020    	rsb.w	r0, r0, #0x20
700a2a78: 9902         	ldr	r1, [sp, #0x8]
700a2a7a: 6188         	str	r0, [r1, #0x18]
;       } else {
700a2a7c: e000         	b	0x700a2a80 <xTaskPriorityInherit+0x50> @ imm = #0x0
700a2a7e: e7ff         	b	0x700a2a80 <xTaskPriorityInherit+0x50> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(
700a2a80: 9902         	ldr	r1, [sp, #0x8]
700a2a82: 6948         	ldr	r0, [r1, #0x14]
700a2a84: 6ac9         	ldr	r1, [r1, #0x2c]
700a2a86: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a2a8a: f244 41f8    	movw	r1, #0x44f8
700a2a8e: f2c7 0108    	movt	r1, #0x7008
700a2a92: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2a96: 4288         	cmp	r0, r1
700a2a98: d136         	bne	0x700a2b08 <xTaskPriorityInherit+0xd8> @ imm = #0x6c
700a2a9a: e7ff         	b	0x700a2a9c <xTaskPriorityInherit+0x6c> @ imm = #-0x2
;         if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) ==
700a2a9c: 9802         	ldr	r0, [sp, #0x8]
700a2a9e: 3004         	adds	r0, #0x4
700a2aa0: f008 fcde    	bl	0x700ab460 <uxListRemove> @ imm = #0x89bc
700a2aa4: b968         	cbnz	r0, 0x700a2ac2 <xTaskPriorityInherit+0x92> @ imm = #0x1a
700a2aa6: e7ff         	b	0x700a2aa8 <xTaskPriorityInherit+0x78> @ imm = #-0x2
;           portRESET_READY_PRIORITY(pxMutexHolderTCB->uxPriority,
700a2aa8: 9802         	ldr	r0, [sp, #0x8]
700a2aaa: 6ac1         	ldr	r1, [r0, #0x2c]
700a2aac: 2001         	movs	r0, #0x1
700a2aae: fa00 f201    	lsl.w	r2, r0, r1
700a2ab2: f240 11f8    	movw	r1, #0x1f8
700a2ab6: f2c7 010b    	movt	r1, #0x700b
700a2aba: 6808         	ldr	r0, [r1]
700a2abc: 4390         	bics	r0, r2
700a2abe: 6008         	str	r0, [r1]
;         } else {
700a2ac0: e000         	b	0x700a2ac4 <xTaskPriorityInherit+0x94> @ imm = #0x0
700a2ac2: e7ff         	b	0x700a2ac4 <xTaskPriorityInherit+0x94> @ imm = #-0x2
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a2ac4: f240 10cc    	movw	r0, #0x1cc
700a2ac8: f2c7 000b    	movt	r0, #0x700b
700a2acc: 6800         	ldr	r0, [r0]
700a2ace: 6ac0         	ldr	r0, [r0, #0x2c]
700a2ad0: 9902         	ldr	r1, [sp, #0x8]
700a2ad2: 62c8         	str	r0, [r1, #0x2c]
;         prvAddTaskToReadyList(pxMutexHolderTCB);
700a2ad4: 9802         	ldr	r0, [sp, #0x8]
700a2ad6: 6ac1         	ldr	r1, [r0, #0x2c]
700a2ad8: 2001         	movs	r0, #0x1
700a2ada: fa00 f201    	lsl.w	r2, r0, r1
700a2ade: f240 11f8    	movw	r1, #0x1f8
700a2ae2: f2c7 010b    	movt	r1, #0x700b
700a2ae6: 6808         	ldr	r0, [r1]
700a2ae8: 4310         	orrs	r0, r2
700a2aea: 6008         	str	r0, [r1]
700a2aec: 9902         	ldr	r1, [sp, #0x8]
700a2aee: 6ac8         	ldr	r0, [r1, #0x2c]
700a2af0: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a2af4: f244 40f8    	movw	r0, #0x44f8
700a2af8: f2c7 0008    	movt	r0, #0x7008
700a2afc: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a2b00: 3104         	adds	r1, #0x4
700a2b02: f009 fa1d    	bl	0x700abf40 <vListInsertEnd> @ imm = #0x943a
;       } else {
700a2b06: e008         	b	0x700a2b1a <xTaskPriorityInherit+0xea> @ imm = #0x10
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a2b08: f240 10cc    	movw	r0, #0x1cc
700a2b0c: f2c7 000b    	movt	r0, #0x700b
700a2b10: 6800         	ldr	r0, [r0]
700a2b12: 6ac0         	ldr	r0, [r0, #0x2c]
700a2b14: 9902         	ldr	r1, [sp, #0x8]
700a2b16: 62c8         	str	r0, [r1, #0x2c]
700a2b18: e7ff         	b	0x700a2b1a <xTaskPriorityInherit+0xea> @ imm = #-0x2
700a2b1a: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a2b1c: 9001         	str	r0, [sp, #0x4]
;     } else {
700a2b1e: e00f         	b	0x700a2b40 <xTaskPriorityInherit+0x110> @ imm = #0x1e
;       if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority) {
700a2b20: 9802         	ldr	r0, [sp, #0x8]
700a2b22: 6e00         	ldr	r0, [r0, #0x60]
700a2b24: f240 11cc    	movw	r1, #0x1cc
700a2b28: f2c7 010b    	movt	r1, #0x700b
700a2b2c: 6809         	ldr	r1, [r1]
700a2b2e: 6ac9         	ldr	r1, [r1, #0x2c]
700a2b30: 4288         	cmp	r0, r1
700a2b32: d203         	bhs	0x700a2b3c <xTaskPriorityInherit+0x10c> @ imm = #0x6
700a2b34: e7ff         	b	0x700a2b36 <xTaskPriorityInherit+0x106> @ imm = #-0x2
700a2b36: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a2b38: 9001         	str	r0, [sp, #0x4]
;       } else {
700a2b3a: e000         	b	0x700a2b3e <xTaskPriorityInherit+0x10e> @ imm = #0x0
700a2b3c: e7ff         	b	0x700a2b3e <xTaskPriorityInherit+0x10e> @ imm = #-0x2
700a2b3e: e7ff         	b	0x700a2b40 <xTaskPriorityInherit+0x110> @ imm = #-0x2
;   } else {
700a2b40: e000         	b	0x700a2b44 <xTaskPriorityInherit+0x114> @ imm = #0x0
700a2b42: e7ff         	b	0x700a2b44 <xTaskPriorityInherit+0x114> @ imm = #-0x2
;   return xReturn;
700a2b44: 9801         	ldr	r0, [sp, #0x4]
700a2b46: b004         	add	sp, #0x10
700a2b48: bd80         	pop	{r7, pc}
700a2b4a: 0000         	movs	r0, r0
700a2b4c: 0000         	movs	r0, r0
700a2b4e: 0000         	movs	r0, r0

700a2b50 <TaskP_loadUpdateAll>:
; {
700a2b50: b580         	push	{r7, lr}
700a2b52: b090         	sub	sp, #0x40
;     vTaskSuspendAll();
700a2b54: f00a fd94    	bl	0x700ad680 <vTaskSuspendAll> @ imm = #0xab28
700a2b58: 2000         	movs	r0, #0x0
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a2b5a: 9005         	str	r0, [sp, #0x14]
700a2b5c: e7ff         	b	0x700a2b5e <TaskP_loadUpdateAll+0xe> @ imm = #-0x2
700a2b5e: 9805         	ldr	r0, [sp, #0x14]
700a2b60: 281f         	cmp	r0, #0x1f
700a2b62: d837         	bhi	0x700a2bd4 <TaskP_loadUpdateAll+0x84> @ imm = #0x6e
700a2b64: e7ff         	b	0x700a2b66 <TaskP_loadUpdateAll+0x16> @ imm = #-0x2
;         if(gTaskP_ctrl.taskRegistry[i]!=NULL)
700a2b66: 9905         	ldr	r1, [sp, #0x14]
700a2b68: f644 3078    	movw	r0, #0x4b78
700a2b6c: f2c7 0008    	movt	r0, #0x7008
700a2b70: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a2b74: b348         	cbz	r0, 0x700a2bca <TaskP_loadUpdateAll+0x7a> @ imm = #0x52
700a2b76: e7ff         	b	0x700a2b78 <TaskP_loadUpdateAll+0x28> @ imm = #-0x2
;             taskObj = gTaskP_ctrl.taskRegistry[i];
700a2b78: 9905         	ldr	r1, [sp, #0x14]
700a2b7a: f644 3078    	movw	r0, #0x4b78
700a2b7e: f2c7 0008    	movt	r0, #0x7008
700a2b82: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a2b86: 900f         	str	r0, [sp, #0x3c]
;             vTaskGetInfo(taskObj->taskHndl, &taskStatus, pdFALSE, eReady);
700a2b88: 980f         	ldr	r0, [sp, #0x3c]
700a2b8a: f8d0 008c    	ldr.w	r0, [r0, #0x8c]
700a2b8e: a906         	add	r1, sp, #0x18
700a2b90: 2200         	movs	r2, #0x0
700a2b92: 2301         	movs	r3, #0x1
700a2b94: f001 fa34    	bl	0x700a4000 <vTaskGetInfo> @ imm = #0x1468
;             delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, taskObj->lastRunTime);
700a2b98: 980c         	ldr	r0, [sp, #0x30]
700a2b9a: 990f         	ldr	r1, [sp, #0x3c]
700a2b9c: f8d1 1090    	ldr.w	r1, [r1, #0x90]
700a2ba0: f009 fe16    	bl	0x700ac7d0 <TaskP_calcCounterDiff> @ imm = #0x9c2c
700a2ba4: 9004         	str	r0, [sp, #0x10]
;             taskObj->accRunTime += delta;
700a2ba6: 9b04         	ldr	r3, [sp, #0x10]
700a2ba8: 990f         	ldr	r1, [sp, #0x3c]
700a2baa: f8d1 2098    	ldr.w	r2, [r1, #0x98]
700a2bae: f8d1 009c    	ldr.w	r0, [r1, #0x9c]
700a2bb2: 18d2         	adds	r2, r2, r3
700a2bb4: f140 0000    	adc	r0, r0, #0x0
700a2bb8: f8c1 2098    	str.w	r2, [r1, #0x98]
700a2bbc: f8c1 009c    	str.w	r0, [r1, #0x9c]
;             taskObj->lastRunTime = taskStatus.ulRunTimeCounter;
700a2bc0: 980c         	ldr	r0, [sp, #0x30]
700a2bc2: 990f         	ldr	r1, [sp, #0x3c]
700a2bc4: f8c1 0090    	str.w	r0, [r1, #0x90]
;         }
700a2bc8: e7ff         	b	0x700a2bca <TaskP_loadUpdateAll+0x7a> @ imm = #-0x2
;     }
700a2bca: e7ff         	b	0x700a2bcc <TaskP_loadUpdateAll+0x7c> @ imm = #-0x2
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a2bcc: 9805         	ldr	r0, [sp, #0x14]
700a2bce: 3001         	adds	r0, #0x1
700a2bd0: 9005         	str	r0, [sp, #0x14]
700a2bd2: e7c4         	b	0x700a2b5e <TaskP_loadUpdateAll+0xe> @ imm = #-0x78
;     idleTskHndl = xTaskGetIdleTaskHandle();
700a2bd4: f00a fdc4    	bl	0x700ad760 <xTaskGetIdleTaskHandle> @ imm = #0xab88
700a2bd8: 9002         	str	r0, [sp, #0x8]
;     if(idleTskHndl != NULL)
700a2bda: 9802         	ldr	r0, [sp, #0x8]
700a2bdc: b310         	cbz	r0, 0x700a2c24 <TaskP_loadUpdateAll+0xd4> @ imm = #0x44
700a2bde: e7ff         	b	0x700a2be0 <TaskP_loadUpdateAll+0x90> @ imm = #-0x2
;         vTaskGetInfo(idleTskHndl, &taskStatus, pdFALSE, eReady);
700a2be0: 9802         	ldr	r0, [sp, #0x8]
700a2be2: a906         	add	r1, sp, #0x18
700a2be4: 2200         	movs	r2, #0x0
700a2be6: 2301         	movs	r3, #0x1
700a2be8: f001 fa0a    	bl	0x700a4000 <vTaskGetInfo> @ imm = #0x1414
;         delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, gTaskP_ctrl.idleTskLastRunTime);
700a2bec: 980c         	ldr	r0, [sp, #0x30]
700a2bee: f644 3178    	movw	r1, #0x4b78
700a2bf2: f2c7 0108    	movt	r1, #0x7008
700a2bf6: 9101         	str	r1, [sp, #0x4]
700a2bf8: f8d1 1090    	ldr.w	r1, [r1, #0x90]
700a2bfc: f009 fde8    	bl	0x700ac7d0 <TaskP_calcCounterDiff> @ imm = #0x9bd0
700a2c00: 9901         	ldr	r1, [sp, #0x4]
700a2c02: 9004         	str	r0, [sp, #0x10]
;         gTaskP_ctrl.idleTskAccRunTime += delta;
700a2c04: 9b04         	ldr	r3, [sp, #0x10]
700a2c06: f8d1 2098    	ldr.w	r2, [r1, #0x98]
700a2c0a: f8d1 009c    	ldr.w	r0, [r1, #0x9c]
700a2c0e: 18d2         	adds	r2, r2, r3
700a2c10: f140 0000    	adc	r0, r0, #0x0
700a2c14: f8c1 2098    	str.w	r2, [r1, #0x98]
700a2c18: f8c1 009c    	str.w	r0, [r1, #0x9c]
;         gTaskP_ctrl.idleTskLastRunTime = taskStatus.ulRunTimeCounter;
700a2c1c: 980c         	ldr	r0, [sp, #0x30]
700a2c1e: f8c1 0090    	str.w	r0, [r1, #0x90]
;     }
700a2c22: e7ff         	b	0x700a2c24 <TaskP_loadUpdateAll+0xd4> @ imm = #-0x2
;     curTotalTime = portGET_RUN_TIME_COUNTER_VALUE();
700a2c24: f00a fc9c    	bl	0x700ad560 <uiPortGetRunTimeCounterValue> @ imm = #0xa938
700a2c28: 9003         	str	r0, [sp, #0xc]
;     delta = TaskP_calcCounterDiff(curTotalTime, gTaskP_ctrl.lastTotalTime);
700a2c2a: 9803         	ldr	r0, [sp, #0xc]
700a2c2c: f644 3178    	movw	r1, #0x4b78
700a2c30: f2c7 0108    	movt	r1, #0x7008
700a2c34: 9100         	str	r1, [sp]
700a2c36: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700a2c3a: f009 fdc9    	bl	0x700ac7d0 <TaskP_calcCounterDiff> @ imm = #0x9b92
700a2c3e: 9900         	ldr	r1, [sp]
700a2c40: 9004         	str	r0, [sp, #0x10]
;     gTaskP_ctrl.accTotalTime += delta;
700a2c42: 9b04         	ldr	r3, [sp, #0x10]
700a2c44: f8d1 2088    	ldr.w	r2, [r1, #0x88]
700a2c48: f8d1 008c    	ldr.w	r0, [r1, #0x8c]
700a2c4c: 18d2         	adds	r2, r2, r3
700a2c4e: f140 0000    	adc	r0, r0, #0x0
700a2c52: f8c1 2088    	str.w	r2, [r1, #0x88]
700a2c56: f8c1 008c    	str.w	r0, [r1, #0x8c]
;     gTaskP_ctrl.lastTotalTime = curTotalTime;
700a2c5a: 9803         	ldr	r0, [sp, #0xc]
700a2c5c: f8c1 0080    	str.w	r0, [r1, #0x80]
;     (void)xTaskResumeAll();
700a2c60: f7fd ff66    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0x2134
; }
700a2c64: b010         	add	sp, #0x40
700a2c66: bd80         	pop	{r7, pc}
		...

700a2c70 <prvInitialiseNewTask>:
;     const MemoryRegion_t *const xRegions) {
700a2c70: b580         	push	{r7, lr}
700a2c72: b088         	sub	sp, #0x20
700a2c74: f8dd c034    	ldr.w	r12, [sp, #0x34]
700a2c78: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a2c7c: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a2c80: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a2c84: 9007         	str	r0, [sp, #0x1c]
700a2c86: 9106         	str	r1, [sp, #0x18]
700a2c88: 9205         	str	r2, [sp, #0x14]
700a2c8a: 9304         	str	r3, [sp, #0x10]
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a2c8c: 980c         	ldr	r0, [sp, #0x30]
700a2c8e: 6b00         	ldr	r0, [r0, #0x30]
;                  (size_t)ulStackDepth * sizeof(StackType_t));
700a2c90: 9905         	ldr	r1, [sp, #0x14]
700a2c92: 0089         	lsls	r1, r1, #0x2
700a2c94: 22a5         	movs	r2, #0xa5
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a2c96: f00a ece4    	blx	0x700ad660 <__aeabi_memset8> @ imm = #0xa9c8
;     pxTopOfStack = &(pxNewTCB->pxStack[ulStackDepth - (uint32_t)1]);
700a2c9a: 980c         	ldr	r0, [sp, #0x30]
700a2c9c: 6b00         	ldr	r0, [r0, #0x30]
700a2c9e: 9905         	ldr	r1, [sp, #0x14]
700a2ca0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2ca4: 3804         	subs	r0, #0x4
700a2ca6: 9003         	str	r0, [sp, #0xc]
;              *)(((portPOINTER_SIZE_TYPE)pxTopOfStack) &
700a2ca8: 9803         	ldr	r0, [sp, #0xc]
700a2caa: f020 0007    	bic	r0, r0, #0x7
;     pxTopOfStack =
700a2cae: 9003         	str	r0, [sp, #0xc]
;   if (pcName != NULL) {
700a2cb0: 9806         	ldr	r0, [sp, #0x18]
700a2cb2: b1f8         	cbz	r0, 0x700a2cf4 <prvInitialiseNewTask+0x84> @ imm = #0x3e
700a2cb4: e7ff         	b	0x700a2cb6 <prvInitialiseNewTask+0x46> @ imm = #-0x2
700a2cb6: 2000         	movs	r0, #0x0
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a2cb8: 9002         	str	r0, [sp, #0x8]
700a2cba: e7ff         	b	0x700a2cbc <prvInitialiseNewTask+0x4c> @ imm = #-0x2
700a2cbc: 9802         	ldr	r0, [sp, #0x8]
700a2cbe: 281f         	cmp	r0, #0x1f
700a2cc0: d813         	bhi	0x700a2cea <prvInitialiseNewTask+0x7a> @ imm = #0x26
700a2cc2: e7ff         	b	0x700a2cc4 <prvInitialiseNewTask+0x54> @ imm = #-0x2
;       pxNewTCB->pcTaskName[x] = pcName[x];
700a2cc4: 9806         	ldr	r0, [sp, #0x18]
700a2cc6: 9a02         	ldr	r2, [sp, #0x8]
700a2cc8: 5c80         	ldrb	r0, [r0, r2]
700a2cca: 990c         	ldr	r1, [sp, #0x30]
700a2ccc: 4411         	add	r1, r2
700a2cce: f881 0034    	strb.w	r0, [r1, #0x34]
;       if (pcName[x] == (char)0x00) {
700a2cd2: 9806         	ldr	r0, [sp, #0x18]
700a2cd4: 9902         	ldr	r1, [sp, #0x8]
700a2cd6: 5c40         	ldrb	r0, [r0, r1]
700a2cd8: b908         	cbnz	r0, 0x700a2cde <prvInitialiseNewTask+0x6e> @ imm = #0x2
700a2cda: e7ff         	b	0x700a2cdc <prvInitialiseNewTask+0x6c> @ imm = #-0x2
;         break;
700a2cdc: e005         	b	0x700a2cea <prvInitialiseNewTask+0x7a> @ imm = #0xa
700a2cde: e7ff         	b	0x700a2ce0 <prvInitialiseNewTask+0x70> @ imm = #-0x2
;     }
700a2ce0: e7ff         	b	0x700a2ce2 <prvInitialiseNewTask+0x72> @ imm = #-0x2
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a2ce2: 9802         	ldr	r0, [sp, #0x8]
700a2ce4: 3001         	adds	r0, #0x1
700a2ce6: 9002         	str	r0, [sp, #0x8]
700a2ce8: e7e8         	b	0x700a2cbc <prvInitialiseNewTask+0x4c> @ imm = #-0x30
;     pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
700a2cea: 990c         	ldr	r1, [sp, #0x30]
700a2cec: 2000         	movs	r0, #0x0
700a2cee: f881 0053    	strb.w	r0, [r1, #0x53]
;   } else {
700a2cf2: e004         	b	0x700a2cfe <prvInitialiseNewTask+0x8e> @ imm = #0x8
;     pxNewTCB->pcTaskName[0] = 0x00;
700a2cf4: 990c         	ldr	r1, [sp, #0x30]
700a2cf6: 2000         	movs	r0, #0x0
700a2cf8: f881 0034    	strb.w	r0, [r1, #0x34]
700a2cfc: e7ff         	b	0x700a2cfe <prvInitialiseNewTask+0x8e> @ imm = #-0x2
;   if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES) {
700a2cfe: 980a         	ldr	r0, [sp, #0x28]
700a2d00: 2820         	cmp	r0, #0x20
700a2d02: d303         	blo	0x700a2d0c <prvInitialiseNewTask+0x9c> @ imm = #0x6
700a2d04: e7ff         	b	0x700a2d06 <prvInitialiseNewTask+0x96> @ imm = #-0x2
700a2d06: 201f         	movs	r0, #0x1f
;     uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
700a2d08: 900a         	str	r0, [sp, #0x28]
;   } else {
700a2d0a: e000         	b	0x700a2d0e <prvInitialiseNewTask+0x9e> @ imm = #0x0
700a2d0c: e7ff         	b	0x700a2d0e <prvInitialiseNewTask+0x9e> @ imm = #-0x2
;   pxNewTCB->uxPriority = uxPriority;
700a2d0e: 980a         	ldr	r0, [sp, #0x28]
700a2d10: 990c         	ldr	r1, [sp, #0x30]
700a2d12: 62c8         	str	r0, [r1, #0x2c]
;     pxNewTCB->uxBasePriority = uxPriority;
700a2d14: 980a         	ldr	r0, [sp, #0x28]
700a2d16: 990c         	ldr	r1, [sp, #0x30]
700a2d18: 6608         	str	r0, [r1, #0x60]
;     pxNewTCB->uxMutexesHeld = 0;
700a2d1a: 990c         	ldr	r1, [sp, #0x30]
700a2d1c: 2000         	movs	r0, #0x0
700a2d1e: 9001         	str	r0, [sp, #0x4]
700a2d20: 6648         	str	r0, [r1, #0x64]
;   vListInitialiseItem(&(pxNewTCB->xStateListItem));
700a2d22: 980c         	ldr	r0, [sp, #0x30]
700a2d24: 3004         	adds	r0, #0x4
700a2d26: f00a fcbb    	bl	0x700ad6a0 <vListInitialiseItem> @ imm = #0xa976
;   vListInitialiseItem(&(pxNewTCB->xEventListItem));
700a2d2a: 980c         	ldr	r0, [sp, #0x30]
700a2d2c: 3018         	adds	r0, #0x18
700a2d2e: f00a fcb7    	bl	0x700ad6a0 <vListInitialiseItem> @ imm = #0xa96e
700a2d32: 9801         	ldr	r0, [sp, #0x4]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
700a2d34: 990c         	ldr	r1, [sp, #0x30]
700a2d36: 6109         	str	r1, [r1, #0x10]
;   listSET_LIST_ITEM_VALUE(
700a2d38: 990a         	ldr	r1, [sp, #0x28]
700a2d3a: f1c1 0120    	rsb.w	r1, r1, #0x20
700a2d3e: 9a0c         	ldr	r2, [sp, #0x30]
700a2d40: 6191         	str	r1, [r2, #0x18]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
700a2d42: 990c         	ldr	r1, [sp, #0x30]
700a2d44: 6249         	str	r1, [r1, #0x24]
;     pxNewTCB->uxCriticalNesting = (UBaseType_t)0U;
700a2d46: 990c         	ldr	r1, [sp, #0x30]
700a2d48: 6548         	str	r0, [r1, #0x54]
;     pxNewTCB->pxTaskTag = NULL;
700a2d4a: 990c         	ldr	r1, [sp, #0x30]
700a2d4c: 6688         	str	r0, [r1, #0x68]
;     memset((void *)&(pxNewTCB->pvThreadLocalStoragePointers[0]), 0x00,
700a2d4e: 990c         	ldr	r1, [sp, #0x30]
700a2d50: 6788         	str	r0, [r1, #0x78]
700a2d52: 6748         	str	r0, [r1, #0x74]
700a2d54: 6708         	str	r0, [r1, #0x70]
700a2d56: 66c8         	str	r0, [r1, #0x6c]
;     memset((void *)&(pxNewTCB->ulNotifiedValue[0]), 0x00,
700a2d58: 990c         	ldr	r1, [sp, #0x30]
700a2d5a: f8c1 0080    	str.w	r0, [r1, #0x80]
700a2d5e: 67c8         	str	r0, [r1, #0x7c]
;     memset((void *)&(pxNewTCB->ucNotifyState[0]), 0x00,
700a2d60: 990c         	ldr	r1, [sp, #0x30]
700a2d62: f8a1 0084    	strh.w	r0, [r1, #0x84]
;           pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
700a2d66: 9803         	ldr	r0, [sp, #0xc]
700a2d68: 9907         	ldr	r1, [sp, #0x1c]
700a2d6a: 9a04         	ldr	r2, [sp, #0x10]
700a2d6c: f7fe fe30    	bl	0x700a19d0 <pxPortInitialiseStack> @ imm = #-0x13a0
;       pxNewTCB->pxTopOfStack =
700a2d70: 990c         	ldr	r1, [sp, #0x30]
700a2d72: 6008         	str	r0, [r1]
;   if (pxCreatedTask != NULL) {
700a2d74: 980b         	ldr	r0, [sp, #0x2c]
700a2d76: b120         	cbz	r0, 0x700a2d82 <prvInitialiseNewTask+0x112> @ imm = #0x8
700a2d78: e7ff         	b	0x700a2d7a <prvInitialiseNewTask+0x10a> @ imm = #-0x2
;     *pxCreatedTask = (TaskHandle_t)pxNewTCB;
700a2d7a: 980c         	ldr	r0, [sp, #0x30]
700a2d7c: 990b         	ldr	r1, [sp, #0x2c]
700a2d7e: 6008         	str	r0, [r1]
;   } else {
700a2d80: e000         	b	0x700a2d84 <prvInitialiseNewTask+0x114> @ imm = #0x0
700a2d82: e7ff         	b	0x700a2d84 <prvInitialiseNewTask+0x114> @ imm = #-0x2
; }
700a2d84: b008         	add	sp, #0x20
700a2d86: bd80         	pop	{r7, pc}

700a2d88 <__udivmoddi4>:
700a2d88: e1530001     	cmp	r3, r1
700a2d8c: 01520000     	cmpeq	r2, r0
700a2d90: 9a000007     	bls	0x700a2db4 <__udivmoddi4+0x2c> @ imm = #0x1c
700a2d94: e59d2000     	ldr	r2, [sp]
700a2d98: e3520000     	cmp	r2, #0
700a2d9c: 0a000001     	beq	0x700a2da8 <__udivmoddi4+0x20> @ imm = #0x4
700a2da0: e5820000     	str	r0, [r2]
700a2da4: e5821004     	str	r1, [r2, #0x4]
700a2da8: e3b01000     	movs	r1, #0
700a2dac: e3b00000     	movs	r0, #0
700a2db0: e12fff1e     	bx	lr
700a2db4: e3530000     	cmp	r3, #0
700a2db8: 03520000     	cmpeq	r2, #0
700a2dbc: 1a00000d     	bne	0x700a2df8 <__udivmoddi4+0x70> @ imm = #0x34
700a2dc0: e59d2000     	ldr	r2, [sp]
700a2dc4: e3520000     	cmp	r2, #0
700a2dc8: 0a000001     	beq	0x700a2dd4 <__udivmoddi4+0x4c> @ imm = #0x4
700a2dcc: e5820000     	str	r0, [r2]
700a2dd0: e5821004     	str	r1, [r2, #0x4]
700a2dd4: e1b02000     	movs	r2, r0
700a2dd8: e1b03001     	movs	r3, r1
700a2ddc: e3b01000     	movs	r1, #0
700a2de0: e3b00000     	movs	r0, #0
700a2de4: e3530000     	cmp	r3, #0
700a2de8: 03520000     	cmpeq	r2, #0
700a2dec: 11e01001     	mvnne	r1, r1
700a2df0: 11e00000     	mvnne	r0, r0
700a2df4: eaffdef7     	b	0x7009a9d8 <__aeabi_ldiv0> @ imm = #-0x8424
700a2df8: e92d40f0     	push	{r4, r5, r6, r7, lr}
700a2dfc: e1a04003     	mov	r4, r3
700a2e00: e1a05002     	mov	r5, r2
700a2e04: e1a03001     	mov	r3, r1
700a2e08: e1a02000     	mov	r2, r0
700a2e0c: e3b00000     	movs	r0, #0
700a2e10: e3b01000     	movs	r1, #0
700a2e14: e16f6f14     	clz	r6, r4
700a2e18: e3560020     	cmp	r6, #32
700a2e1c: 016f6f15     	clzeq	r6, r5
700a2e20: 02866020     	addeq	r6, r6, #32
700a2e24: e16f7f13     	clz	r7, r3
700a2e28: e3570020     	cmp	r7, #32
700a2e2c: 016f7f12     	clzeq	r7, r2
700a2e30: 02877020     	addeq	r7, r7, #32
700a2e34: e0566007     	subs	r6, r6, r7
700a2e38: e2567020     	subs	r7, r6, #32
700a2e3c: 21a04715     	lslhs	r4, r5, r7
700a2e40: 23a05000     	movhs	r5, #0
700a2e44: 32677000     	rsblo	r7, r7, #0
700a2e48: 31a04614     	lsllo	r4, r4, r6
700a2e4c: 31a07735     	lsrlo	r7, r5, r7
700a2e50: 31844007     	orrlo	r4, r4, r7
700a2e54: 31a05615     	lsllo	r5, r5, r6
700a2e58: e1530004     	cmp	r3, r4
700a2e5c: 01520005     	cmpeq	r2, r5
700a2e60: 3a000001     	blo	0x700a2e6c <__udivmoddi4+0xe4> @ imm = #0x4
700a2e64: e0522005     	subs	r2, r2, r5
700a2e68: e0d33004     	sbcs	r3, r3, r4
700a2e6c: e0b00000     	adcs	r0, r0, r0
700a2e70: e0b11001     	adcs	r1, r1, r1
700a2e74: e1b050a5     	lsrs	r5, r5, #1
700a2e78: e1855f84     	orr	r5, r5, r4, lsl #31
700a2e7c: e1b040a4     	lsrs	r4, r4, #1
700a2e80: e2566001     	subs	r6, r6, #1
700a2e84: 5afffff3     	bpl	0x700a2e58 <__udivmoddi4+0xd0> @ imm = #-0x34
700a2e88: e59d7014     	ldr	r7, [sp, #0x14]
700a2e8c: e3570000     	cmp	r7, #0
700a2e90: 0a000001     	beq	0x700a2e9c <__udivmoddi4+0x114> @ imm = #0x4
700a2e94: e5872000     	str	r2, [r7]
700a2e98: e5873004     	str	r3, [r7, #0x4]
700a2e9c: e8bd80f0     	pop	{r4, r5, r6, r7, pc}

700a2ea0 <CSL_bcdmaChanOpDecChanStats>:
; {
700a2ea0: b580         	push	{r7, lr}
700a2ea2: b088         	sub	sp, #0x20
700a2ea4: 9007         	str	r0, [sp, #0x1c]
700a2ea6: 9106         	str	r1, [sp, #0x18]
700a2ea8: 9205         	str	r2, [sp, #0x14]
700a2eaa: 9304         	str	r3, [sp, #0x10]
700a2eac: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a2eae: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a2eb0: 9804         	ldr	r0, [sp, #0x10]
700a2eb2: b920         	cbnz	r0, 0x700a2ebe <CSL_bcdmaChanOpDecChanStats+0x1e> @ imm = #0x8
700a2eb4: e7ff         	b	0x700a2eb6 <CSL_bcdmaChanOpDecChanStats+0x16> @ imm = #-0x2
700a2eb6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a2eba: 9003         	str	r0, [sp, #0xc]
;     }
700a2ebc: e078         	b	0x700a2fb0 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #0xf0
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a2ebe: 9804         	ldr	r0, [sp, #0x10]
700a2ec0: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a2ec2: 9806         	ldr	r0, [sp, #0x18]
700a2ec4: 9001         	str	r0, [sp, #0x4]
700a2ec6: b140         	cbz	r0, 0x700a2eda <CSL_bcdmaChanOpDecChanStats+0x3a> @ imm = #0x10
700a2ec8: e7ff         	b	0x700a2eca <CSL_bcdmaChanOpDecChanStats+0x2a> @ imm = #-0x2
700a2eca: 9801         	ldr	r0, [sp, #0x4]
700a2ecc: 2801         	cmp	r0, #0x1
700a2ece: d026         	beq	0x700a2f1e <CSL_bcdmaChanOpDecChanStats+0x7e> @ imm = #0x4c
700a2ed0: e7ff         	b	0x700a2ed2 <CSL_bcdmaChanOpDecChanStats+0x32> @ imm = #-0x2
700a2ed2: 9801         	ldr	r0, [sp, #0x4]
700a2ed4: 2802         	cmp	r0, #0x2
700a2ed6: d044         	beq	0x700a2f62 <CSL_bcdmaChanOpDecChanStats+0xc2> @ imm = #0x88
700a2ed8: e065         	b	0x700a2fa6 <CSL_bcdmaChanOpDecChanStats+0x106> @ imm = #0xca
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a2eda: 9807         	ldr	r0, [sp, #0x1c]
700a2edc: 6880         	ldr	r0, [r0, #0x8]
700a2ede: 9905         	ldr	r1, [sp, #0x14]
700a2ee0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2ee4: f500 6080    	add.w	r0, r0, #0x400
700a2ee8: 9902         	ldr	r1, [sp, #0x8]
700a2eea: 6809         	ldr	r1, [r1]
700a2eec: f00a fb48    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xa690
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a2ef0: 9807         	ldr	r0, [sp, #0x1c]
700a2ef2: 6880         	ldr	r0, [r0, #0x8]
700a2ef4: 9905         	ldr	r1, [sp, #0x14]
700a2ef6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2efa: f500 6081    	add.w	r0, r0, #0x408
700a2efe: 9902         	ldr	r1, [sp, #0x8]
700a2f00: 6849         	ldr	r1, [r1, #0x4]
700a2f02: f00a fb3d    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xa67a
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a2f06: 9807         	ldr	r0, [sp, #0x1c]
700a2f08: 6880         	ldr	r0, [r0, #0x8]
700a2f0a: 9905         	ldr	r1, [sp, #0x14]
700a2f0c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2f10: f500 6082    	add.w	r0, r0, #0x410
700a2f14: 9902         	ldr	r1, [sp, #0x8]
700a2f16: 6889         	ldr	r1, [r1, #0x8]
700a2f18: f00a fb32    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xa664
;                 break;
700a2f1c: e047         	b	0x700a2fae <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x8e
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a2f1e: 9807         	ldr	r0, [sp, #0x1c]
700a2f20: 6900         	ldr	r0, [r0, #0x10]
700a2f22: 9905         	ldr	r1, [sp, #0x14]
700a2f24: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2f28: f500 6080    	add.w	r0, r0, #0x400
700a2f2c: 9902         	ldr	r1, [sp, #0x8]
700a2f2e: 6809         	ldr	r1, [r1]
700a2f30: f00a fb26    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xa64c
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a2f34: 9807         	ldr	r0, [sp, #0x1c]
700a2f36: 6900         	ldr	r0, [r0, #0x10]
700a2f38: 9905         	ldr	r1, [sp, #0x14]
700a2f3a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2f3e: f500 6081    	add.w	r0, r0, #0x408
700a2f42: 9902         	ldr	r1, [sp, #0x8]
700a2f44: 6849         	ldr	r1, [r1, #0x4]
700a2f46: f00a fb1b    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xa636
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a2f4a: 9807         	ldr	r0, [sp, #0x1c]
700a2f4c: 6900         	ldr	r0, [r0, #0x10]
700a2f4e: 9905         	ldr	r1, [sp, #0x14]
700a2f50: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2f54: f500 6082    	add.w	r0, r0, #0x410
700a2f58: 9902         	ldr	r1, [sp, #0x8]
700a2f5a: 6889         	ldr	r1, [r1, #0x8]
700a2f5c: f00a fb10    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xa620
;                 break;
700a2f60: e025         	b	0x700a2fae <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x4a
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a2f62: 9807         	ldr	r0, [sp, #0x1c]
700a2f64: 6980         	ldr	r0, [r0, #0x18]
700a2f66: 9905         	ldr	r1, [sp, #0x14]
700a2f68: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2f6c: f500 6080    	add.w	r0, r0, #0x400
700a2f70: 9902         	ldr	r1, [sp, #0x8]
700a2f72: 6809         	ldr	r1, [r1]
700a2f74: f00a fb04    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xa608
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->rxPayloadByteCnt );
700a2f78: 9807         	ldr	r0, [sp, #0x1c]
700a2f7a: 6980         	ldr	r0, [r0, #0x18]
700a2f7c: 9905         	ldr	r1, [sp, #0x14]
700a2f7e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2f82: f500 6081    	add.w	r0, r0, #0x408
700a2f86: 9902         	ldr	r1, [sp, #0x8]
700a2f88: 68c9         	ldr	r1, [r1, #0xc]
700a2f8a: f00a faf9    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xa5f2
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->rxStartedByteCnt );
700a2f8e: 9807         	ldr	r0, [sp, #0x1c]
700a2f90: 6980         	ldr	r0, [r0, #0x18]
700a2f92: 9905         	ldr	r1, [sp, #0x14]
700a2f94: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a2f98: f500 6082    	add.w	r0, r0, #0x410
700a2f9c: 9902         	ldr	r1, [sp, #0x8]
700a2f9e: 6909         	ldr	r1, [r1, #0x10]
700a2fa0: f00a faee    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0xa5dc
;                 break;
700a2fa4: e003         	b	0x700a2fae <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x6
700a2fa6: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a2faa: 9003         	str	r0, [sp, #0xc]
;                 break;
700a2fac: e7ff         	b	0x700a2fae <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #-0x2
700a2fae: e7ff         	b	0x700a2fb0 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #-0x2
;     return retVal;
700a2fb0: 9803         	ldr	r0, [sp, #0xc]
700a2fb2: b008         	add	sp, #0x20
700a2fb4: bd80         	pop	{r7, pc}
		...
700a2fbe: 0000         	movs	r0, r0

700a2fc0 <UART_divisorLatchWrite>:
; {
700a2fc0: b580         	push	{r7, lr}
700a2fc2: b08c         	sub	sp, #0x30
700a2fc4: 900b         	str	r0, [sp, #0x2c]
700a2fc6: 910a         	str	r1, [sp, #0x28]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a2fc8: 980b         	ldr	r0, [sp, #0x2c]
700a2fca: 21bf         	movs	r1, #0xbf
700a2fcc: 9102         	str	r1, [sp, #0x8]
700a2fce: f007 fb27    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x764e
700a2fd2: 9007         	str	r0, [sp, #0x1c]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a2fd4: 980b         	ldr	r0, [sp, #0x2c]
700a2fd6: 3008         	adds	r0, #0x8
700a2fd8: 2110         	movs	r1, #0x10
700a2fda: 9103         	str	r1, [sp, #0xc]
700a2fdc: 2204         	movs	r2, #0x4
700a2fde: 9204         	str	r2, [sp, #0x10]
700a2fe0: f009 ff8e    	bl	0x700acf00 <HW_RD_FIELD32_RAW> @ imm = #0x9f1c
700a2fe4: 9903         	ldr	r1, [sp, #0xc]
700a2fe6: 9a04         	ldr	r2, [sp, #0x10]
700a2fe8: 9009         	str	r0, [sp, #0x24]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a2fea: 980b         	ldr	r0, [sp, #0x2c]
700a2fec: 3008         	adds	r0, #0x8
700a2fee: 2301         	movs	r3, #0x1
700a2ff0: f009 f99e    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x933c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a2ff4: 980b         	ldr	r0, [sp, #0x2c]
700a2ff6: 300c         	adds	r0, #0xc
700a2ff8: 9907         	ldr	r1, [sp, #0x1c]
700a2ffa: f00a fb21    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0xa642
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a2ffe: 980b         	ldr	r0, [sp, #0x2c]
700a3000: 217f         	movs	r1, #0x7f
700a3002: 9101         	str	r1, [sp, #0x4]
700a3004: f007 fb0c    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x7618
700a3008: 9903         	ldr	r1, [sp, #0xc]
700a300a: 9a04         	ldr	r2, [sp, #0x10]
700a300c: 9007         	str	r0, [sp, #0x1c]
;     sleepMdBitVal = HW_RD_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE);
700a300e: 980b         	ldr	r0, [sp, #0x2c]
700a3010: 3004         	adds	r0, #0x4
700a3012: f009 ff75    	bl	0x700acf00 <HW_RD_FIELD32_RAW> @ imm = #0x9eea
700a3016: 9903         	ldr	r1, [sp, #0xc]
700a3018: 9a04         	ldr	r2, [sp, #0x10]
700a301a: 9008         	str	r0, [sp, #0x20]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, 0U);
700a301c: 980b         	ldr	r0, [sp, #0x2c]
700a301e: 3004         	adds	r0, #0x4
700a3020: 2300         	movs	r3, #0x0
700a3022: f009 f985    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x930a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a3026: 980b         	ldr	r0, [sp, #0x2c]
700a3028: 300c         	adds	r0, #0xc
700a302a: 9907         	ldr	r1, [sp, #0x1c]
700a302c: f00a fb08    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0xa610
700a3030: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a3032: 980b         	ldr	r0, [sp, #0x2c]
700a3034: f007 faf4    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x75e8
700a3038: 9007         	str	r0, [sp, #0x1c]
;     divRegVal  = HW_RD_REG32(baseAddr + UART_DLL) & 0xFFU;
700a303a: 980b         	ldr	r0, [sp, #0x2c]
700a303c: f00a faf8    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0xa5f0
700a3040: b2c0         	uxtb	r0, r0
700a3042: 9005         	str	r0, [sp, #0x14]
;     divRegVal |= (HW_RD_REG32(baseAddr + UART_DLH) & 0x3FU) << 8;
700a3044: 980b         	ldr	r0, [sp, #0x2c]
700a3046: 3004         	adds	r0, #0x4
700a3048: f00a faf2    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0xa5e4
700a304c: f000 013f    	and	r1, r0, #0x3f
700a3050: 9805         	ldr	r0, [sp, #0x14]
700a3052: ea40 2001    	orr.w	r0, r0, r1, lsl #8
700a3056: 9005         	str	r0, [sp, #0x14]
;     operMode = UART_operatingModeSelect(baseAddr,
700a3058: 980b         	ldr	r0, [sp, #0x2c]
700a305a: 2107         	movs	r1, #0x7
700a305c: f009 fcd8    	bl	0x700aca10 <UART_operatingModeSelect> @ imm = #0x99b0
700a3060: 9006         	str	r0, [sp, #0x18]
;     HW_WR_REG32(baseAddr + UART_DLL, divisorValue & 0x00FFU);
700a3062: 980b         	ldr	r0, [sp, #0x2c]
700a3064: f89d 1028    	ldrb.w	r1, [sp, #0x28]
700a3068: f00a faea    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0xa5d4
;     HW_WR_REG32(baseAddr + UART_DLH, (divisorValue & 0x3F00U) >> 8);
700a306c: 980b         	ldr	r0, [sp, #0x2c]
700a306e: 3004         	adds	r0, #0x4
700a3070: 990a         	ldr	r1, [sp, #0x28]
700a3072: f3c1 2105    	ubfx	r1, r1, #0x8, #0x6
700a3076: f00a fae3    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0xa5c6
;     (void) UART_operatingModeSelect(baseAddr, operMode);
700a307a: 980b         	ldr	r0, [sp, #0x2c]
700a307c: 9906         	ldr	r1, [sp, #0x18]
700a307e: f009 fcc7    	bl	0x700aca10 <UART_operatingModeSelect> @ imm = #0x998e
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a3082: 980b         	ldr	r0, [sp, #0x2c]
700a3084: 300c         	adds	r0, #0xc
700a3086: 9907         	ldr	r1, [sp, #0x1c]
700a3088: f00a fada    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0xa5b4
700a308c: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a308e: 980b         	ldr	r0, [sp, #0x2c]
700a3090: f007 fac6    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x758c
700a3094: 9903         	ldr	r1, [sp, #0xc]
700a3096: 9a04         	ldr	r2, [sp, #0x10]
700a3098: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, sleepMdBitVal);
700a309a: 980b         	ldr	r0, [sp, #0x2c]
700a309c: 3004         	adds	r0, #0x4
700a309e: 9b08         	ldr	r3, [sp, #0x20]
700a30a0: f009 f946    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x928c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a30a4: 980b         	ldr	r0, [sp, #0x2c]
700a30a6: 300c         	adds	r0, #0xc
700a30a8: 9907         	ldr	r1, [sp, #0x1c]
700a30aa: f00a fac9    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0xa592
700a30ae: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a30b0: 980b         	ldr	r0, [sp, #0x2c]
700a30b2: f007 fab5    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x756a
700a30b6: 9903         	ldr	r1, [sp, #0xc]
700a30b8: 9a04         	ldr	r2, [sp, #0x10]
700a30ba: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a30bc: 980b         	ldr	r0, [sp, #0x2c]
700a30be: 3008         	adds	r0, #0x8
700a30c0: 9b09         	ldr	r3, [sp, #0x24]
700a30c2: f009 f935    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x926a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a30c6: 980b         	ldr	r0, [sp, #0x2c]
700a30c8: 300c         	adds	r0, #0xc
700a30ca: 9907         	ldr	r1, [sp, #0x1c]
700a30cc: f00a fab8    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0xa570
;     return divRegVal;
700a30d0: 9805         	ldr	r0, [sp, #0x14]
700a30d2: b00c         	add	sp, #0x30
700a30d4: bd80         	pop	{r7, pc}
		...
700a30de: 0000         	movs	r0, r0

700a30e0 <_ntoa_long>:
; {
700a30e0: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a30e4: b098         	sub	sp, #0x60
700a30e6: 4684         	mov	r12, r0
700a30e8: 9823         	ldr	r0, [sp, #0x8c]
700a30ea: 9822         	ldr	r0, [sp, #0x88]
700a30ec: 9821         	ldr	r0, [sp, #0x84]
700a30ee: 9820         	ldr	r0, [sp, #0x80]
700a30f0: 981f         	ldr	r0, [sp, #0x7c]
700a30f2: f8dd e078    	ldr.w	lr, [sp, #0x78]
700a30f6: f8cd c05c    	str.w	r12, [sp, #0x5c]
700a30fa: 9116         	str	r1, [sp, #0x58]
700a30fc: 9215         	str	r2, [sp, #0x54]
700a30fe: 9314         	str	r3, [sp, #0x50]
700a3100: f88d 004f    	strb.w	r0, [sp, #0x4f]
700a3104: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a3106: 900a         	str	r0, [sp, #0x28]
;   if (!value) {
700a3108: 981e         	ldr	r0, [sp, #0x78]
700a310a: b928         	cbnz	r0, 0x700a3118 <_ntoa_long+0x38> @ imm = #0xa
700a310c: e7ff         	b	0x700a310e <_ntoa_long+0x2e> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a310e: 9823         	ldr	r0, [sp, #0x8c]
700a3110: f020 0010    	bic	r0, r0, #0x10
700a3114: 9023         	str	r0, [sp, #0x8c]
;   }
700a3116: e7ff         	b	0x700a3118 <_ntoa_long+0x38> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a3118: f89d 008d    	ldrb.w	r0, [sp, #0x8d]
700a311c: 0740         	lsls	r0, r0, #0x1d
700a311e: 2800         	cmp	r0, #0x0
700a3120: d504         	bpl	0x700a312c <_ntoa_long+0x4c> @ imm = #0x8
700a3122: e7ff         	b	0x700a3124 <_ntoa_long+0x44> @ imm = #-0x2
700a3124: 981e         	ldr	r0, [sp, #0x78]
700a3126: 2800         	cmp	r0, #0x0
700a3128: d03f         	beq	0x700a31aa <_ntoa_long+0xca> @ imm = #0x7e
700a312a: e7ff         	b	0x700a312c <_ntoa_long+0x4c> @ imm = #-0x2
;     do {
700a312c: e7ff         	b	0x700a312e <_ntoa_long+0x4e> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a312e: 9a1e         	ldr	r2, [sp, #0x78]
700a3130: 9920         	ldr	r1, [sp, #0x80]
700a3132: fbb2 f0f1    	udiv	r0, r2, r1
700a3136: fb00 2011    	mls	r0, r0, r1, r2
700a313a: f88d 0027    	strb.w	r0, [sp, #0x27]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a313e: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a3142: 2809         	cmp	r0, #0x9
700a3144: dc05         	bgt	0x700a3152 <_ntoa_long+0x72> @ imm = #0xa
700a3146: e7ff         	b	0x700a3148 <_ntoa_long+0x68> @ imm = #-0x2
700a3148: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a314c: 3030         	adds	r0, #0x30
700a314e: 9008         	str	r0, [sp, #0x20]
700a3150: e00c         	b	0x700a316c <_ntoa_long+0x8c> @ imm = #0x18
700a3152: f89d 008c    	ldrb.w	r0, [sp, #0x8c]
700a3156: 0681         	lsls	r1, r0, #0x1a
700a3158: 2061         	movs	r0, #0x61
700a315a: 2900         	cmp	r1, #0x0
700a315c: bf48         	it	mi
700a315e: 2041         	movmi	r0, #0x41
700a3160: f89d 1027    	ldrb.w	r1, [sp, #0x27]
700a3164: 4408         	add	r0, r1
700a3166: 380a         	subs	r0, #0xa
700a3168: 9008         	str	r0, [sp, #0x20]
700a316a: e7ff         	b	0x700a316c <_ntoa_long+0x8c> @ imm = #-0x2
700a316c: 9808         	ldr	r0, [sp, #0x20]
700a316e: 9a0a         	ldr	r2, [sp, #0x28]
700a3170: 1c51         	adds	r1, r2, #0x1
700a3172: 910a         	str	r1, [sp, #0x28]
700a3174: f10d 012f    	add.w	r1, sp, #0x2f
700a3178: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a317a: 9920         	ldr	r1, [sp, #0x80]
700a317c: 981e         	ldr	r0, [sp, #0x78]
700a317e: fbb0 f0f1    	udiv	r0, r0, r1
700a3182: 901e         	str	r0, [sp, #0x78]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a3184: e7ff         	b	0x700a3186 <_ntoa_long+0xa6> @ imm = #-0x2
700a3186: 991e         	ldr	r1, [sp, #0x78]
700a3188: 2000         	movs	r0, #0x0
700a318a: 9007         	str	r0, [sp, #0x1c]
700a318c: b139         	cbz	r1, 0x700a319e <_ntoa_long+0xbe> @ imm = #0xe
700a318e: e7ff         	b	0x700a3190 <_ntoa_long+0xb0> @ imm = #-0x2
700a3190: 990a         	ldr	r1, [sp, #0x28]
700a3192: 2000         	movs	r0, #0x0
700a3194: 2920         	cmp	r1, #0x20
700a3196: bf38         	it	lo
700a3198: 2001         	movlo	r0, #0x1
700a319a: 9007         	str	r0, [sp, #0x1c]
700a319c: e7ff         	b	0x700a319e <_ntoa_long+0xbe> @ imm = #-0x2
700a319e: 9807         	ldr	r0, [sp, #0x1c]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a31a0: 07c0         	lsls	r0, r0, #0x1f
700a31a2: 2800         	cmp	r0, #0x0
700a31a4: d1c3         	bne	0x700a312e <_ntoa_long+0x4e> @ imm = #-0x7a
700a31a6: e7ff         	b	0x700a31a8 <_ntoa_long+0xc8> @ imm = #-0x2
;   }
700a31a8: e7ff         	b	0x700a31aa <_ntoa_long+0xca> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a31aa: 9817         	ldr	r0, [sp, #0x5c]
700a31ac: 9916         	ldr	r1, [sp, #0x58]
700a31ae: 9a15         	ldr	r2, [sp, #0x54]
700a31b0: 9b14         	ldr	r3, [sp, #0x50]
700a31b2: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a31b6: 9d20         	ldr	r5, [sp, #0x80]
700a31b8: 9e21         	ldr	r6, [sp, #0x84]
700a31ba: 9f22         	ldr	r7, [sp, #0x88]
700a31bc: f8dd 808c    	ldr.w	r8, [sp, #0x8c]
700a31c0: f89d 404f    	ldrb.w	r4, [sp, #0x4f]
700a31c4: 46ee         	mov	lr, sp
700a31c6: f8ce 8018    	str.w	r8, [lr, #0x18]
700a31ca: f8ce 7014    	str.w	r7, [lr, #0x14]
700a31ce: f8ce 6010    	str.w	r6, [lr, #0x10]
700a31d2: f8ce 500c    	str.w	r5, [lr, #0xc]
700a31d6: f004 0401    	and	r4, r4, #0x1
700a31da: f8ce 4008    	str.w	r4, [lr, #0x8]
700a31de: f8ce c004    	str.w	r12, [lr, #0x4]
700a31e2: f10d 0c2f    	add.w	r12, sp, #0x2f
700a31e6: f8ce c000    	str.w	r12, [lr]
700a31ea: f7f9 ff29    	bl	0x7009d040 <_ntoa_format> @ imm = #-0x61ae
700a31ee: b018         	add	sp, #0x60
700a31f0: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a3200 <Sciclient_pmSetModuleClkFreq>:
; {
700a3200: b580         	push	{r7, lr}
700a3202: b09a         	sub	sp, #0x68
700a3204: f8dd c074    	ldr.w	r12, [sp, #0x74]
700a3208: f8dd c070    	ldr.w	r12, [sp, #0x70]
700a320c: 9019         	str	r0, [sp, #0x64]
700a320e: 9118         	str	r1, [sp, #0x60]
700a3210: 9317         	str	r3, [sp, #0x5c]
700a3212: 9216         	str	r2, [sp, #0x58]
700a3214: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a3216: 9015         	str	r0, [sp, #0x54]
;     request.device         = (uint32_t) moduleId;
700a3218: 9819         	ldr	r0, [sp, #0x64]
700a321a: 900c         	str	r0, [sp, #0x30]
;     request.min_freq_hz    = (uint64_t) freqHz;
700a321c: 9816         	ldr	r0, [sp, #0x58]
700a321e: 9917         	ldr	r1, [sp, #0x5c]
700a3220: 910e         	str	r1, [sp, #0x38]
700a3222: 900d         	str	r0, [sp, #0x34]
;     request.target_freq_hz = (uint64_t) freqHz;
700a3224: 9816         	ldr	r0, [sp, #0x58]
700a3226: 9917         	ldr	r1, [sp, #0x5c]
700a3228: 9110         	str	r1, [sp, #0x40]
700a322a: 900f         	str	r0, [sp, #0x3c]
;     request.max_freq_hz    = (uint64_t) freqHz;
700a322c: 9816         	ldr	r0, [sp, #0x58]
700a322e: 9917         	ldr	r1, [sp, #0x5c]
700a3230: 9112         	str	r1, [sp, #0x48]
700a3232: 9011         	str	r0, [sp, #0x44]
;     if((freqHz%10U) != 0U)
700a3234: 9b16         	ldr	r3, [sp, #0x58]
700a3236: 9817         	ldr	r0, [sp, #0x5c]
700a3238: f64c 41cd    	movw	r1, #0xcccd
700a323c: f6cc 41cc    	movt	r1, #0xcccc
700a3240: fba3 2e01    	umull	r2, lr, r3, r1
700a3244: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a3248: fb03 e30c    	mla	r3, r3, r12, lr
700a324c: fb00 3101    	mla	r1, r0, r1, r3
700a3250: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a3254: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a3258: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a325c: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a3260: f649 129a    	movw	r2, #0x999a
700a3264: f6c9 1299    	movt	r2, #0x9999
700a3268: 1a89         	subs	r1, r1, r2
700a326a: f649 1199    	movw	r1, #0x9999
700a326e: f6c1 1199    	movt	r1, #0x1999
700a3272: 4188         	sbcs	r0, r1
700a3274: d316         	blo	0x700a32a4 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #0x2c
700a3276: e7ff         	b	0x700a3278 <Sciclient_pmSetModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(freqHz-(freqHz%10U));
700a3278: 9816         	ldr	r0, [sp, #0x58]
700a327a: 9001         	str	r0, [sp, #0x4]
700a327c: 9917         	ldr	r1, [sp, #0x5c]
700a327e: 9100         	str	r1, [sp]
700a3280: 220a         	movs	r2, #0xa
700a3282: 2300         	movs	r3, #0x0
700a3284: f009 ed9e    	blx	0x700acdc4 <__aeabi_uldivmod> @ imm = #0x9b3c
700a3288: 9800         	ldr	r0, [sp]
700a328a: 9901         	ldr	r1, [sp, #0x4]
700a328c: 1a89         	subs	r1, r1, r2
700a328e: 4198         	sbcs	r0, r3
700a3290: 910d         	str	r1, [sp, #0x34]
700a3292: 900e         	str	r0, [sp, #0x38]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a3294: 990d         	ldr	r1, [sp, #0x34]
700a3296: 980e         	ldr	r0, [sp, #0x38]
700a3298: 310a         	adds	r1, #0xa
700a329a: f140 0000    	adc	r0, r0, #0x0
700a329e: 9111         	str	r1, [sp, #0x44]
700a32a0: 9012         	str	r0, [sp, #0x48]
;     }
700a32a2: e7ff         	b	0x700a32a4 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a32a4: 9818         	ldr	r0, [sp, #0x60]
700a32a6: 28ff         	cmp	r0, #0xff
700a32a8: d307         	blo	0x700a32ba <Sciclient_pmSetModuleClkFreq+0xba> @ imm = #0xe
700a32aa: e7ff         	b	0x700a32ac <Sciclient_pmSetModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a32ac: 9818         	ldr	r0, [sp, #0x60]
700a32ae: f8cd 004d    	str.w	r0, [sp, #0x4d]
700a32b2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a32b4: f88d 004c    	strb.w	r0, [sp, #0x4c]
;     }
700a32b8: e003         	b	0x700a32c2 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a32ba: 9818         	ldr	r0, [sp, #0x60]
700a32bc: f88d 004c    	strb.w	r0, [sp, #0x4c]
700a32c0: e7ff         	b	0x700a32c2 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #-0x2
700a32c2: f44f 7086    	mov.w	r0, #0x10c
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_FREQ;
700a32c6: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     reqParam.flags          = (uint32_t)(TISCI_MSG_FLAG_AOP | additionalFlag);
700a32ca: 981c         	ldr	r0, [sp, #0x70]
700a32cc: f040 0002    	orr	r0, r0, #0x2
700a32d0: 9006         	str	r0, [sp, #0x18]
700a32d2: a80a         	add	r0, sp, #0x28
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a32d4: 9007         	str	r0, [sp, #0x1c]
700a32d6: 2029         	movs	r0, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a32d8: 9008         	str	r0, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a32da: 981d         	ldr	r0, [sp, #0x74]
700a32dc: 9009         	str	r0, [sp, #0x24]
700a32de: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a32e0: 9002         	str	r0, [sp, #0x8]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a32e2: 9003         	str	r0, [sp, #0xc]
;     respParam.respPayloadSize = (uint32_t) 0;
700a32e4: 9004         	str	r0, [sp, #0x10]
700a32e6: a805         	add	r0, sp, #0x14
700a32e8: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a32ea: f7f8 fdc9    	bl	0x7009be80 <Sciclient_service> @ imm = #-0x746e
700a32ee: 9015         	str	r0, [sp, #0x54]
;     if((retVal != SystemP_SUCCESS) ||
700a32f0: 9815         	ldr	r0, [sp, #0x54]
700a32f2: b930         	cbnz	r0, 0x700a3302 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #0xc
700a32f4: e7ff         	b	0x700a32f6 <Sciclient_pmSetModuleClkFreq+0xf6> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a32f6: 9802         	ldr	r0, [sp, #0x8]
700a32f8: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a32fc: 2802         	cmp	r0, #0x2
700a32fe: d004         	beq	0x700a330a <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #0x8
700a3300: e7ff         	b	0x700a3302 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #-0x2
700a3302: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a3306: 9015         	str	r0, [sp, #0x54]
;     }
700a3308: e7ff         	b	0x700a330a <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #-0x2
;     return retVal;
700a330a: 9815         	ldr	r0, [sp, #0x54]
700a330c: b01a         	add	sp, #0x68
700a330e: bd80         	pop	{r7, pc}

700a3310 <Udma_eventCheckParams>:
; {
700a3310: b084         	sub	sp, #0x10
700a3312: 9003         	str	r0, [sp, #0xc]
700a3314: 9102         	str	r1, [sp, #0x8]
700a3316: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a3318: 9001         	str	r0, [sp, #0x4]
;     if(UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode)
700a331a: 9802         	ldr	r0, [sp, #0x8]
700a331c: 6840         	ldr	r0, [r0, #0x4]
700a331e: 2801         	cmp	r0, #0x1
700a3320: d109         	bne	0x700a3336 <Udma_eventCheckParams+0x26> @ imm = #0x12
700a3322: e7ff         	b	0x700a3324 <Udma_eventCheckParams+0x14> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a3324: 9802         	ldr	r0, [sp, #0x8]
700a3326: 6900         	ldr	r0, [r0, #0x10]
700a3328: b120         	cbz	r0, 0x700a3334 <Udma_eventCheckParams+0x24> @ imm = #0x8
700a332a: e7ff         	b	0x700a332c <Udma_eventCheckParams+0x1c> @ imm = #-0x2
700a332c: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a3330: 9001         	str	r0, [sp, #0x4]
;         }
700a3332: e7ff         	b	0x700a3334 <Udma_eventCheckParams+0x24> @ imm = #-0x2
;     }
700a3334: e7ff         	b	0x700a3336 <Udma_eventCheckParams+0x26> @ imm = #-0x2
;     if(UDMA_EVENT_MODE_SHARED == eventPrms->eventMode)
700a3336: 9802         	ldr	r0, [sp, #0x8]
700a3338: 6840         	ldr	r0, [r0, #0x4]
700a333a: 2802         	cmp	r0, #0x2
700a333c: d126         	bne	0x700a338c <Udma_eventCheckParams+0x7c> @ imm = #0x4c
700a333e: e7ff         	b	0x700a3340 <Udma_eventCheckParams+0x30> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a3340: 9802         	ldr	r0, [sp, #0x8]
700a3342: 6900         	ldr	r0, [r0, #0x10]
700a3344: b308         	cbz	r0, 0x700a338a <Udma_eventCheckParams+0x7a> @ imm = #0x42
700a3346: e7ff         	b	0x700a3348 <Udma_eventCheckParams+0x38> @ imm = #-0x2
;             controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a3348: 9802         	ldr	r0, [sp, #0x8]
700a334a: 6900         	ldr	r0, [r0, #0x10]
700a334c: 9000         	str	r0, [sp]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a334e: 9800         	ldr	r0, [sp]
700a3350: 69c0         	ldr	r0, [r0, #0x1c]
700a3352: b140         	cbz	r0, 0x700a3366 <Udma_eventCheckParams+0x56> @ imm = #0x10
700a3354: e7ff         	b	0x700a3356 <Udma_eventCheckParams+0x46> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR == eventPrms->eventCb))
700a3356: 9802         	ldr	r0, [sp, #0x8]
700a3358: 6940         	ldr	r0, [r0, #0x14]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a335a: b920         	cbnz	r0, 0x700a3366 <Udma_eventCheckParams+0x56> @ imm = #0x8
700a335c: e7ff         	b	0x700a335e <Udma_eventCheckParams+0x4e> @ imm = #-0x2
700a335e: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a3362: 9001         	str	r0, [sp, #0x4]
;             }
700a3364: e7ff         	b	0x700a3366 <Udma_eventCheckParams+0x56> @ imm = #-0x2
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a3366: 9800         	ldr	r0, [sp]
700a3368: 69c0         	ldr	r0, [r0, #0x1c]
700a336a: b968         	cbnz	r0, 0x700a3388 <Udma_eventCheckParams+0x78> @ imm = #0x1a
700a336c: e7ff         	b	0x700a336e <Udma_eventCheckParams+0x5e> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
700a336e: 9802         	ldr	r0, [sp, #0x8]
700a3370: 6940         	ldr	r0, [r0, #0x14]
700a3372: b148         	cbz	r0, 0x700a3388 <Udma_eventCheckParams+0x78> @ imm = #0x12
700a3374: e7ff         	b	0x700a3376 <Udma_eventCheckParams+0x66> @ imm = #-0x2
;                (UDMA_EVENT_TYPE_MASTER != controllerEventHandle->eventPrms.eventType))
700a3376: 9800         	ldr	r0, [sp]
700a3378: 6880         	ldr	r0, [r0, #0x8]
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a337a: 2805         	cmp	r0, #0x5
700a337c: d004         	beq	0x700a3388 <Udma_eventCheckParams+0x78> @ imm = #0x8
700a337e: e7ff         	b	0x700a3380 <Udma_eventCheckParams+0x70> @ imm = #-0x2
700a3380: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a3384: 9001         	str	r0, [sp, #0x4]
;             }
700a3386: e7ff         	b	0x700a3388 <Udma_eventCheckParams+0x78> @ imm = #-0x2
;         }
700a3388: e7ff         	b	0x700a338a <Udma_eventCheckParams+0x7a> @ imm = #-0x2
;     }
700a338a: e7ff         	b	0x700a338c <Udma_eventCheckParams+0x7c> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a338c: 9802         	ldr	r0, [sp, #0x8]
700a338e: 6800         	ldr	r0, [r0]
700a3390: 2801         	cmp	r0, #0x1
700a3392: d00f         	beq	0x700a33b4 <Udma_eventCheckParams+0xa4> @ imm = #0x1e
700a3394: e7ff         	b	0x700a3396 <Udma_eventCheckParams+0x86> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a3396: 9802         	ldr	r0, [sp, #0x8]
700a3398: 6800         	ldr	r0, [r0]
700a339a: 2806         	cmp	r0, #0x6
700a339c: d00a         	beq	0x700a33b4 <Udma_eventCheckParams+0xa4> @ imm = #0x14
700a339e: e7ff         	b	0x700a33a0 <Udma_eventCheckParams+0x90> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
700a33a0: 9802         	ldr	r0, [sp, #0x8]
700a33a2: 6800         	ldr	r0, [r0]
700a33a4: 2802         	cmp	r0, #0x2
700a33a6: d005         	beq	0x700a33b4 <Udma_eventCheckParams+0xa4> @ imm = #0xa
700a33a8: e7ff         	b	0x700a33aa <Udma_eventCheckParams+0x9a> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TR == eventPrms->eventType))
700a33aa: 9802         	ldr	r0, [sp, #0x8]
700a33ac: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a33ae: 2803         	cmp	r0, #0x3
700a33b0: d109         	bne	0x700a33c6 <Udma_eventCheckParams+0xb6> @ imm = #0x12
700a33b2: e7ff         	b	0x700a33b4 <Udma_eventCheckParams+0xa4> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->chHandle)
700a33b4: 9802         	ldr	r0, [sp, #0x8]
700a33b6: 6880         	ldr	r0, [r0, #0x8]
700a33b8: b920         	cbnz	r0, 0x700a33c4 <Udma_eventCheckParams+0xb4> @ imm = #0x8
700a33ba: e7ff         	b	0x700a33bc <Udma_eventCheckParams+0xac> @ imm = #-0x2
700a33bc: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a33c0: 9001         	str	r0, [sp, #0x4]
;         }
700a33c2: e7ff         	b	0x700a33c4 <Udma_eventCheckParams+0xb4> @ imm = #-0x2
;     }
700a33c4: e7ff         	b	0x700a33c6 <Udma_eventCheckParams+0xb6> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
700a33c6: 9802         	ldr	r0, [sp, #0x8]
700a33c8: 6800         	ldr	r0, [r0]
700a33ca: 2804         	cmp	r0, #0x4
700a33cc: d109         	bne	0x700a33e2 <Udma_eventCheckParams+0xd2> @ imm = #0x12
700a33ce: e7ff         	b	0x700a33d0 <Udma_eventCheckParams+0xc0> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->ringHandle)
700a33d0: 9802         	ldr	r0, [sp, #0x8]
700a33d2: 68c0         	ldr	r0, [r0, #0xc]
700a33d4: b920         	cbnz	r0, 0x700a33e0 <Udma_eventCheckParams+0xd0> @ imm = #0x8
700a33d6: e7ff         	b	0x700a33d8 <Udma_eventCheckParams+0xc8> @ imm = #-0x2
700a33d8: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a33dc: 9001         	str	r0, [sp, #0x4]
;         }
700a33de: e7ff         	b	0x700a33e0 <Udma_eventCheckParams+0xd0> @ imm = #-0x2
;     }
700a33e0: e7ff         	b	0x700a33e2 <Udma_eventCheckParams+0xd2> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_MASTER == eventPrms->eventType)
700a33e2: 9802         	ldr	r0, [sp, #0x8]
700a33e4: 6800         	ldr	r0, [r0]
700a33e6: 2805         	cmp	r0, #0x5
700a33e8: d112         	bne	0x700a3410 <Udma_eventCheckParams+0x100> @ imm = #0x24
700a33ea: e7ff         	b	0x700a33ec <Udma_eventCheckParams+0xdc> @ imm = #-0x2
;         if(UDMA_EVENT_MODE_SHARED != eventPrms->eventMode)
700a33ec: 9802         	ldr	r0, [sp, #0x8]
700a33ee: 6840         	ldr	r0, [r0, #0x4]
700a33f0: 2802         	cmp	r0, #0x2
700a33f2: d004         	beq	0x700a33fe <Udma_eventCheckParams+0xee> @ imm = #0x8
700a33f4: e7ff         	b	0x700a33f6 <Udma_eventCheckParams+0xe6> @ imm = #-0x2
700a33f6: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a33fa: 9001         	str	r0, [sp, #0x4]
;         }
700a33fc: e7ff         	b	0x700a33fe <Udma_eventCheckParams+0xee> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a33fe: 9802         	ldr	r0, [sp, #0x8]
700a3400: 6900         	ldr	r0, [r0, #0x10]
700a3402: b120         	cbz	r0, 0x700a340e <Udma_eventCheckParams+0xfe> @ imm = #0x8
700a3404: e7ff         	b	0x700a3406 <Udma_eventCheckParams+0xf6> @ imm = #-0x2
700a3406: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a340a: 9001         	str	r0, [sp, #0x4]
;         }
700a340c: e7ff         	b	0x700a340e <Udma_eventCheckParams+0xfe> @ imm = #-0x2
;     }
700a340e: e7ff         	b	0x700a3410 <Udma_eventCheckParams+0x100> @ imm = #-0x2
;     return (retVal);
700a3410: 9801         	ldr	r0, [sp, #0x4]
700a3412: b004         	add	sp, #0x10
700a3414: 4770         	bx	lr
		...
700a341e: 0000         	movs	r0, r0

700a3420 <CSL_pktdmaTeardownChan>:
; {
700a3420: b580         	push	{r7, lr}
700a3422: b088         	sub	sp, #0x20
700a3424: 4684         	mov	r12, r0
700a3426: 980a         	ldr	r0, [sp, #0x28]
700a3428: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a342c: 9106         	str	r1, [sp, #0x18]
700a342e: 9205         	str	r2, [sp, #0x14]
700a3430: f88d 3013    	strb.w	r3, [sp, #0x13]
700a3434: f88d 0012    	strb.w	r0, [sp, #0x12]
700a3438: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
700a343a: 9003         	str	r0, [sp, #0xc]
;     if( (pCfg == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a343c: 9807         	ldr	r0, [sp, #0x1c]
700a343e: b138         	cbz	r0, 0x700a3450 <CSL_pktdmaTeardownChan+0x30> @ imm = #0xe
700a3440: e7ff         	b	0x700a3442 <CSL_pktdmaTeardownChan+0x22> @ imm = #-0x2
700a3442: 9807         	ldr	r0, [sp, #0x1c]
700a3444: 9906         	ldr	r1, [sp, #0x18]
700a3446: 9a05         	ldr	r2, [sp, #0x14]
700a3448: f007 fb8a    	bl	0x700aab60 <CSL_pktdmaIsValidChanIdx> @ imm = #0x7714
700a344c: b920         	cbnz	r0, 0x700a3458 <CSL_pktdmaTeardownChan+0x38> @ imm = #0x8
700a344e: e7ff         	b	0x700a3450 <CSL_pktdmaTeardownChan+0x30> @ imm = #-0x2
700a3450: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a3454: 9003         	str	r0, [sp, #0xc]
;     }
700a3456: e062         	b	0x700a351e <CSL_pktdmaTeardownChan+0xfe> @ imm = #0xc4
;         if( CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true )
700a3458: 9807         	ldr	r0, [sp, #0x1c]
700a345a: 9906         	ldr	r1, [sp, #0x18]
700a345c: 9a05         	ldr	r2, [sp, #0x14]
700a345e: f007 fda7    	bl	0x700aafb0 <CSL_pktdmaIsChanEnabled> @ imm = #0x7b4e
700a3462: 2800         	cmp	r0, #0x0
700a3464: d056         	beq	0x700a3514 <CSL_pktdmaTeardownChan+0xf4> @ imm = #0xac
700a3466: e7ff         	b	0x700a3468 <CSL_pktdmaTeardownChan+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a3468: 9805         	ldr	r0, [sp, #0x14]
700a346a: b9a8         	cbnz	r0, 0x700a3498 <CSL_pktdmaTeardownChan+0x78> @ imm = #0x2a
700a346c: e7ff         	b	0x700a346e <CSL_pktdmaTeardownChan+0x4e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a346e: 9807         	ldr	r0, [sp, #0x1c]
700a3470: 6900         	ldr	r0, [r0, #0x10]
700a3472: 9906         	ldr	r1, [sp, #0x18]
700a3474: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3478: f00a f932    	bl	0x700ad6e0 <CSL_REG32_RD_RAW> @ imm = #0xa264
700a347c: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a347e: 9802         	ldr	r0, [sp, #0x8]
700a3480: f040 4080    	orr	r0, r0, #0x40000000
700a3484: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a3486: 9807         	ldr	r0, [sp, #0x1c]
700a3488: 6900         	ldr	r0, [r0, #0x10]
700a348a: 9906         	ldr	r1, [sp, #0x18]
700a348c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a3490: 9902         	ldr	r1, [sp, #0x8]
700a3492: f00a f87d    	bl	0x700ad590 <CSL_REG32_WR_RAW> @ imm = #0xa0fa
;             }
700a3496: e014         	b	0x700a34c2 <CSL_pktdmaTeardownChan+0xa2> @ imm = #0x28
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a3498: 9807         	ldr	r0, [sp, #0x1c]
700a349a: 6940         	ldr	r0, [r0, #0x14]
700a349c: 9906         	ldr	r1, [sp, #0x18]
700a349e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a34a2: f00a f91d    	bl	0x700ad6e0 <CSL_REG32_RD_RAW> @ imm = #0xa23a
700a34a6: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a34a8: 9802         	ldr	r0, [sp, #0x8]
700a34aa: f040 4080    	orr	r0, r0, #0x40000000
700a34ae: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a34b0: 9807         	ldr	r0, [sp, #0x1c]
700a34b2: 6940         	ldr	r0, [r0, #0x14]
700a34b4: 9906         	ldr	r1, [sp, #0x18]
700a34b6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a34ba: 9902         	ldr	r1, [sp, #0x8]
700a34bc: f00a f868    	bl	0x700ad590 <CSL_REG32_WR_RAW> @ imm = #0xa0d0
700a34c0: e7ff         	b	0x700a34c2 <CSL_pktdmaTeardownChan+0xa2> @ imm = #-0x2
;             if( bWait == (bool)true )
700a34c2: f89d 0012    	ldrb.w	r0, [sp, #0x12]
700a34c6: 07c0         	lsls	r0, r0, #0x1f
700a34c8: b318         	cbz	r0, 0x700a3512 <CSL_pktdmaTeardownChan+0xf2> @ imm = #0x46
700a34ca: e7ff         	b	0x700a34cc <CSL_pktdmaTeardownChan+0xac> @ imm = #-0x2
700a34cc: 2080         	movs	r0, #0x80
;                 uint32_t retryCnt = CSL_PKTDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
700a34ce: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a34d0: e7ff         	b	0x700a34d2 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x2
700a34d2: 9807         	ldr	r0, [sp, #0x1c]
700a34d4: 9906         	ldr	r1, [sp, #0x18]
700a34d6: 9a05         	ldr	r2, [sp, #0x14]
700a34d8: f007 fd6a    	bl	0x700aafb0 <CSL_pktdmaIsChanEnabled> @ imm = #0x7ad4
700a34dc: 4601         	mov	r1, r0
700a34de: 2000         	movs	r0, #0x0
700a34e0: 9000         	str	r0, [sp]
700a34e2: b131         	cbz	r1, 0x700a34f2 <CSL_pktdmaTeardownChan+0xd2> @ imm = #0xc
700a34e4: e7ff         	b	0x700a34e6 <CSL_pktdmaTeardownChan+0xc6> @ imm = #-0x2
700a34e6: 9801         	ldr	r0, [sp, #0x4]
700a34e8: 2800         	cmp	r0, #0x0
700a34ea: bf18         	it	ne
700a34ec: 2001         	movne	r0, #0x1
700a34ee: 9000         	str	r0, [sp]
700a34f0: e7ff         	b	0x700a34f2 <CSL_pktdmaTeardownChan+0xd2> @ imm = #-0x2
700a34f2: 9800         	ldr	r0, [sp]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a34f4: 07c0         	lsls	r0, r0, #0x1f
700a34f6: b120         	cbz	r0, 0x700a3502 <CSL_pktdmaTeardownChan+0xe2> @ imm = #0x8
700a34f8: e7ff         	b	0x700a34fa <CSL_pktdmaTeardownChan+0xda> @ imm = #-0x2
;                     retryCnt--;
700a34fa: 9801         	ldr	r0, [sp, #0x4]
700a34fc: 3801         	subs	r0, #0x1
700a34fe: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a3500: e7e7         	b	0x700a34d2 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x32
;                 if( retryCnt == (uint32_t)0U ) {
700a3502: 9801         	ldr	r0, [sp, #0x4]
700a3504: b920         	cbnz	r0, 0x700a3510 <CSL_pktdmaTeardownChan+0xf0> @ imm = #0x8
700a3506: e7ff         	b	0x700a3508 <CSL_pktdmaTeardownChan+0xe8> @ imm = #-0x2
700a3508: f04f 30ff    	mov.w	r0, #0xffffffff
;                     retVal = CSL_EFAIL;
700a350c: 9003         	str	r0, [sp, #0xc]
;                 }
700a350e: e7ff         	b	0x700a3510 <CSL_pktdmaTeardownChan+0xf0> @ imm = #-0x2
;             }
700a3510: e7ff         	b	0x700a3512 <CSL_pktdmaTeardownChan+0xf2> @ imm = #-0x2
;         }
700a3512: e003         	b	0x700a351c <CSL_pktdmaTeardownChan+0xfc> @ imm = #0x6
700a3514: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a3518: 9003         	str	r0, [sp, #0xc]
700a351a: e7ff         	b	0x700a351c <CSL_pktdmaTeardownChan+0xfc> @ imm = #-0x2
700a351c: e7ff         	b	0x700a351e <CSL_pktdmaTeardownChan+0xfe> @ imm = #-0x2
;     return retVal;
700a351e: 9803         	ldr	r0, [sp, #0xc]
700a3520: b008         	add	sp, #0x20
700a3522: bd80         	pop	{r7, pc}
		...

700a3530 <UART_configInstance>:
; {
700a3530: b580         	push	{r7, lr}
700a3532: b088         	sub	sp, #0x20
700a3534: 9007         	str	r0, [sp, #0x1c]
;     baseAddr = hUart->baseAddr;
700a3536: 9807         	ldr	r0, [sp, #0x1c]
700a3538: 6800         	ldr	r0, [r0]
700a353a: 9006         	str	r0, [sp, #0x18]
;     hUartInit = hUart->hUartInit;
700a353c: 9807         	ldr	r0, [sp, #0x1c]
700a353e: 6840         	ldr	r0, [r0, #0x4]
700a3540: 9001         	str	r0, [sp, #0x4]
;     UART_resetModule(hUart);
700a3542: 9807         	ldr	r0, [sp, #0x1c]
700a3544: f007 ff3c    	bl	0x700ab3c0 <UART_resetModule> @ imm = #0x7e78
;     if(UART_CONFIG_MODE_DMA == hUartInit->transferMode)
700a3548: 9801         	ldr	r0, [sp, #0x4]
700a354a: 6a00         	ldr	r0, [r0, #0x20]
700a354c: 2803         	cmp	r0, #0x3
700a354e: d10e         	bne	0x700a356e <UART_configInstance+0x3e> @ imm = #0x1c
700a3550: e7ff         	b	0x700a3552 <UART_configInstance+0x22> @ imm = #-0x2
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a3552: 9801         	ldr	r0, [sp, #0x4]
700a3554: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a3558: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a355c: 0380         	lsls	r0, r0, #0xe
700a355e: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a3562: 2131         	movs	r1, #0x31
700a3564: f2c0 4140    	movt	r1, #0x440
700a3568: 4308         	orrs	r0, r1
700a356a: 9005         	str	r0, [sp, #0x14]
;     }
700a356c: e00d         	b	0x700a358a <UART_configInstance+0x5a> @ imm = #0x1a
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a356e: 9801         	ldr	r0, [sp, #0x4]
700a3570: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a3574: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a3578: 0380         	lsls	r0, r0, #0xe
700a357a: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a357e: 2130         	movs	r1, #0x30
700a3580: f2c0 4140    	movt	r1, #0x440
700a3584: 4308         	orrs	r0, r1
700a3586: 9005         	str	r0, [sp, #0x14]
700a3588: e7ff         	b	0x700a358a <UART_configInstance+0x5a> @ imm = #-0x2
;     (void)UART_fifoConfig(baseAddr, regVal);
700a358a: 9806         	ldr	r0, [sp, #0x18]
700a358c: 9905         	ldr	r1, [sp, #0x14]
700a358e: f7f9 fc2f    	bl	0x7009cdf0 <UART_fifoConfig> @ imm = #-0x67a2
;     UART_timeGuardConfig(baseAddr, hUartInit->timeGuardVal);
700a3592: 9806         	ldr	r0, [sp, #0x18]
700a3594: 9901         	ldr	r1, [sp, #0x4]
700a3596: 6d09         	ldr	r1, [r1, #0x50]
700a3598: f009 fe02    	bl	0x700ad1a0 <UART_timeGuardConfig> @ imm = #0x9c04
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a359c: 9a01         	ldr	r2, [sp, #0x4]
700a359e: 6810         	ldr	r0, [r2]
;                                     hUartInit->baudRate,
700a35a0: 6851         	ldr	r1, [r2, #0x4]
;                                     hUartInit->operMode,
700a35a2: 6ad2         	ldr	r2, [r2, #0x2c]
700a35a4: 232a         	movs	r3, #0x2a
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a35a6: f006 f9c3    	bl	0x700a9930 <UART_divisorValCompute> @ imm = #0x6386
700a35aa: 9004         	str	r0, [sp, #0x10]
;     (void)UART_divisorLatchWrite(baseAddr, divisorVal);
700a35ac: 9806         	ldr	r0, [sp, #0x18]
700a35ae: 9904         	ldr	r1, [sp, #0x10]
700a35b0: f7ff fd06    	bl	0x700a2fc0 <UART_divisorLatchWrite> @ imm = #-0x5f4
;     (void)UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a35b4: 9806         	ldr	r0, [sp, #0x18]
700a35b6: 21bf         	movs	r1, #0xbf
700a35b8: f007 f832    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x7064
;     wLenStbFlag = (hUartInit->dataLength << UART_LCR_CHAR_LENGTH_SHIFT);
700a35bc: 9801         	ldr	r0, [sp, #0x4]
700a35be: 6880         	ldr	r0, [r0, #0x8]
700a35c0: 9003         	str	r0, [sp, #0xc]
;     wLenStbFlag |= (hUartInit->stopBits << UART_LCR_NB_STOP_SHIFT);
700a35c2: 9801         	ldr	r0, [sp, #0x4]
700a35c4: 68c1         	ldr	r1, [r0, #0xc]
700a35c6: 9803         	ldr	r0, [sp, #0xc]
700a35c8: ea40 0081    	orr.w	r0, r0, r1, lsl #2
700a35cc: 9003         	str	r0, [sp, #0xc]
;     parityFlag = (hUartInit->parityType << UART_LCR_PARITY_EN_SHIFT);
700a35ce: 9801         	ldr	r0, [sp, #0x4]
700a35d0: 6900         	ldr	r0, [r0, #0x10]
700a35d2: 00c0         	lsls	r0, r0, #0x3
700a35d4: 9002         	str	r0, [sp, #0x8]
;     UART_lineCharConfig(baseAddr, wLenStbFlag, parityFlag);
700a35d6: 9806         	ldr	r0, [sp, #0x18]
700a35d8: 9903         	ldr	r1, [sp, #0xc]
700a35da: 9a02         	ldr	r2, [sp, #0x8]
700a35dc: f007 fe78    	bl	0x700ab2d0 <UART_lineCharConfig> @ imm = #0x7cf0
;     UART_divisorLatchDisable(baseAddr);
700a35e0: 9806         	ldr	r0, [sp, #0x18]
700a35e2: f009 fe3d    	bl	0x700ad260 <UART_divisorLatchDisable> @ imm = #0x9c7a
;     UART_breakCtl(baseAddr, UART_BREAK_COND_DISABLE);
700a35e6: 9806         	ldr	r0, [sp, #0x18]
700a35e8: 2100         	movs	r1, #0x0
700a35ea: f009 fd09    	bl	0x700ad000 <UART_breakCtl> @ imm = #0x9a12
;     (void)UART_operatingModeSelect(baseAddr, hUartInit->operMode);
700a35ee: 9806         	ldr	r0, [sp, #0x18]
700a35f0: 9901         	ldr	r1, [sp, #0x4]
700a35f2: 6ac9         	ldr	r1, [r1, #0x2c]
700a35f4: f009 fa0c    	bl	0x700aca10 <UART_operatingModeSelect> @ imm = #0x9418
;     if (hUartInit->hwFlowControl == (uint32_t)TRUE)
700a35f8: 9801         	ldr	r0, [sp, #0x4]
700a35fa: 6980         	ldr	r0, [r0, #0x18]
700a35fc: 2801         	cmp	r0, #0x1
700a35fe: d112         	bne	0x700a3626 <UART_configInstance+0xf6> @ imm = #0x24
700a3600: e7ff         	b	0x700a3602 <UART_configInstance+0xd2> @ imm = #-0x2
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_RTS_CTS_ENABLE);
700a3602: 9806         	ldr	r0, [sp, #0x18]
700a3604: 2103         	movs	r1, #0x3
700a3606: f008 fed3    	bl	0x700ac3b0 <UART_hardwareFlowCtrlOptSet> @ imm = #0x8da6
;         if (hUartInit->hwFlowControlThr >= hUartInit->rxTrigLvl)
700a360a: 9901         	ldr	r1, [sp, #0x4]
700a360c: 69c8         	ldr	r0, [r1, #0x1c]
700a360e: 6b89         	ldr	r1, [r1, #0x38]
700a3610: 4288         	cmp	r0, r1
700a3612: d307         	blo	0x700a3624 <UART_configInstance+0xf4> @ imm = #0xe
700a3614: e7ff         	b	0x700a3616 <UART_configInstance+0xe6> @ imm = #-0x2
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a3616: 9806         	ldr	r0, [sp, #0x18]
;                                     hUartInit->hwFlowControlThr,
700a3618: 9a01         	ldr	r2, [sp, #0x4]
700a361a: 69d1         	ldr	r1, [r2, #0x1c]
;                                     hUartInit->rxTrigLvl);
700a361c: 6b92         	ldr	r2, [r2, #0x38]
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a361e: f008 ff57    	bl	0x700ac4d0 <UART_flowCtrlTrigLvlConfig> @ imm = #0x8eae
;         }
700a3622: e7ff         	b	0x700a3624 <UART_configInstance+0xf4> @ imm = #-0x2
;     }
700a3624: e004         	b	0x700a3630 <UART_configInstance+0x100> @ imm = #0x8
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_NO_HARDWARE_FLOW_CONTROL);
700a3626: 9806         	ldr	r0, [sp, #0x18]
700a3628: 2100         	movs	r1, #0x0
700a362a: f008 fec1    	bl	0x700ac3b0 <UART_hardwareFlowCtrlOptSet> @ imm = #0x8d82
700a362e: e7ff         	b	0x700a3630 <UART_configInstance+0x100> @ imm = #-0x2
;     return;
700a3630: b008         	add	sp, #0x20
700a3632: bd80         	pop	{r7, pc}
		...

700a3640 <prvAddNewTaskToReadyList>:
; static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB) {
700a3640: b580         	push	{r7, lr}
700a3642: b082         	sub	sp, #0x8
700a3644: 9001         	str	r0, [sp, #0x4]
;   taskENTER_CRITICAL();
700a3646: f008 fed3    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0x8da6
;     uxCurrentNumberOfTasks++;
700a364a: f240 11e8    	movw	r1, #0x1e8
700a364e: f2c7 010b    	movt	r1, #0x700b
700a3652: 6808         	ldr	r0, [r1]
700a3654: 3001         	adds	r0, #0x1
700a3656: 6008         	str	r0, [r1]
;     if (pxCurrentTCB == NULL) {
700a3658: f240 10cc    	movw	r0, #0x1cc
700a365c: f2c7 000b    	movt	r0, #0x700b
700a3660: 6800         	ldr	r0, [r0]
700a3662: b998         	cbnz	r0, 0x700a368c <prvAddNewTaskToReadyList+0x4c> @ imm = #0x26
700a3664: e7ff         	b	0x700a3666 <prvAddNewTaskToReadyList+0x26> @ imm = #-0x2
;       pxCurrentTCB = pxNewTCB;
700a3666: 9801         	ldr	r0, [sp, #0x4]
700a3668: f240 11cc    	movw	r1, #0x1cc
700a366c: f2c7 010b    	movt	r1, #0x700b
700a3670: 6008         	str	r0, [r1]
;       if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
700a3672: f240 10e8    	movw	r0, #0x1e8
700a3676: f2c7 000b    	movt	r0, #0x700b
700a367a: 6800         	ldr	r0, [r0]
700a367c: 2801         	cmp	r0, #0x1
700a367e: d103         	bne	0x700a3688 <prvAddNewTaskToReadyList+0x48> @ imm = #0x6
700a3680: e7ff         	b	0x700a3682 <prvAddNewTaskToReadyList+0x42> @ imm = #-0x2
;         prvInitialiseTaskLists();
700a3682: f004 fbb5    	bl	0x700a7df0 <prvInitialiseTaskLists> @ imm = #0x476a
;       } else {
700a3686: e000         	b	0x700a368a <prvAddNewTaskToReadyList+0x4a> @ imm = #0x0
700a3688: e7ff         	b	0x700a368a <prvAddNewTaskToReadyList+0x4a> @ imm = #-0x2
;     } else {
700a368a: e01c         	b	0x700a36c6 <prvAddNewTaskToReadyList+0x86> @ imm = #0x38
;       if (xSchedulerRunning == pdFALSE) {
700a368c: f240 200c    	movw	r0, #0x20c
700a3690: f2c7 000b    	movt	r0, #0x700b
700a3694: 6800         	ldr	r0, [r0]
700a3696: b9a0         	cbnz	r0, 0x700a36c2 <prvAddNewTaskToReadyList+0x82> @ imm = #0x28
700a3698: e7ff         	b	0x700a369a <prvAddNewTaskToReadyList+0x5a> @ imm = #-0x2
;         if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
700a369a: f240 10cc    	movw	r0, #0x1cc
700a369e: f2c7 000b    	movt	r0, #0x700b
700a36a2: 6800         	ldr	r0, [r0]
700a36a4: 6ac0         	ldr	r0, [r0, #0x2c]
700a36a6: 9901         	ldr	r1, [sp, #0x4]
700a36a8: 6ac9         	ldr	r1, [r1, #0x2c]
700a36aa: 4288         	cmp	r0, r1
700a36ac: d807         	bhi	0x700a36be <prvAddNewTaskToReadyList+0x7e> @ imm = #0xe
700a36ae: e7ff         	b	0x700a36b0 <prvAddNewTaskToReadyList+0x70> @ imm = #-0x2
;           pxCurrentTCB = pxNewTCB;
700a36b0: 9801         	ldr	r0, [sp, #0x4]
700a36b2: f240 11cc    	movw	r1, #0x1cc
700a36b6: f2c7 010b    	movt	r1, #0x700b
700a36ba: 6008         	str	r0, [r1]
;         } else {
700a36bc: e000         	b	0x700a36c0 <prvAddNewTaskToReadyList+0x80> @ imm = #0x0
700a36be: e7ff         	b	0x700a36c0 <prvAddNewTaskToReadyList+0x80> @ imm = #-0x2
;       } else {
700a36c0: e000         	b	0x700a36c4 <prvAddNewTaskToReadyList+0x84> @ imm = #0x0
700a36c2: e7ff         	b	0x700a36c4 <prvAddNewTaskToReadyList+0x84> @ imm = #-0x2
700a36c4: e7ff         	b	0x700a36c6 <prvAddNewTaskToReadyList+0x86> @ imm = #-0x2
;     uxTaskNumber++;
700a36c6: f240 10f4    	movw	r0, #0x1f4
700a36ca: f2c7 000b    	movt	r0, #0x700b
700a36ce: 6801         	ldr	r1, [r0]
700a36d0: 3101         	adds	r1, #0x1
700a36d2: 6001         	str	r1, [r0]
;       pxNewTCB->uxTCBNumber = uxTaskNumber;
700a36d4: 6800         	ldr	r0, [r0]
700a36d6: 9901         	ldr	r1, [sp, #0x4]
700a36d8: 6588         	str	r0, [r1, #0x58]
;     prvAddTaskToReadyList(pxNewTCB);
700a36da: 9801         	ldr	r0, [sp, #0x4]
700a36dc: 6ac1         	ldr	r1, [r0, #0x2c]
700a36de: 2001         	movs	r0, #0x1
700a36e0: fa00 f201    	lsl.w	r2, r0, r1
700a36e4: f240 11f8    	movw	r1, #0x1f8
700a36e8: f2c7 010b    	movt	r1, #0x700b
700a36ec: 6808         	ldr	r0, [r1]
700a36ee: 4310         	orrs	r0, r2
700a36f0: 6008         	str	r0, [r1]
700a36f2: 9901         	ldr	r1, [sp, #0x4]
700a36f4: 6ac8         	ldr	r0, [r1, #0x2c]
700a36f6: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a36fa: f244 40f8    	movw	r0, #0x44f8
700a36fe: f2c7 0008    	movt	r0, #0x7008
700a3702: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a3706: 3104         	adds	r1, #0x4
700a3708: f008 fc1a    	bl	0x700abf40 <vListInsertEnd> @ imm = #0x8834
;   taskEXIT_CRITICAL();
700a370c: f007 ff70    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x7ee0
;   if (xSchedulerRunning != pdFALSE) {
700a3710: f240 200c    	movw	r0, #0x20c
700a3714: f2c7 000b    	movt	r0, #0x700b
700a3718: 6800         	ldr	r0, [r0]
700a371a: b178         	cbz	r0, 0x700a373c <prvAddNewTaskToReadyList+0xfc> @ imm = #0x1e
700a371c: e7ff         	b	0x700a371e <prvAddNewTaskToReadyList+0xde> @ imm = #-0x2
;     if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
700a371e: f240 10cc    	movw	r0, #0x1cc
700a3722: f2c7 000b    	movt	r0, #0x700b
700a3726: 6800         	ldr	r0, [r0]
700a3728: 6ac0         	ldr	r0, [r0, #0x2c]
700a372a: 9901         	ldr	r1, [sp, #0x4]
700a372c: 6ac9         	ldr	r1, [r1, #0x2c]
700a372e: 4288         	cmp	r0, r1
700a3730: d202         	bhs	0x700a3738 <prvAddNewTaskToReadyList+0xf8> @ imm = #0x4
700a3732: e7ff         	b	0x700a3734 <prvAddNewTaskToReadyList+0xf4> @ imm = #-0x2
;       taskYIELD_IF_USING_PREEMPTION();
700a3734: df00         	svc	#0x0
;     } else {
700a3736: e000         	b	0x700a373a <prvAddNewTaskToReadyList+0xfa> @ imm = #0x0
700a3738: e7ff         	b	0x700a373a <prvAddNewTaskToReadyList+0xfa> @ imm = #-0x2
;   } else {
700a373a: e000         	b	0x700a373e <prvAddNewTaskToReadyList+0xfe> @ imm = #0x0
700a373c: e7ff         	b	0x700a373e <prvAddNewTaskToReadyList+0xfe> @ imm = #-0x2
; }
700a373e: b002         	add	sp, #0x8
700a3740: bd80         	pop	{r7, pc}
		...
700a374e: 0000         	movs	r0, r0

700a3750 <Sciclient_rmIrGetOutp>:
; {
700a3750: b580         	push	{r7, lr}
700a3752: b088         	sub	sp, #0x20
700a3754: f8ad 001e    	strh.w	r0, [sp, #0x1e]
700a3758: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a375c: 9206         	str	r2, [sp, #0x18]
700a375e: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a3760: 9005         	str	r0, [sp, #0x14]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a3762: 9004         	str	r0, [sp, #0x10]
;     if (outp == NULL) {
700a3764: 9806         	ldr	r0, [sp, #0x18]
700a3766: b920         	cbnz	r0, 0x700a3772 <Sciclient_rmIrGetOutp+0x22> @ imm = #0x8
700a3768: e7ff         	b	0x700a376a <Sciclient_rmIrGetOutp+0x1a> @ imm = #-0x2
700a376a: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a376e: 9005         	str	r0, [sp, #0x14]
;     } else {
700a3770: e018         	b	0x700a37a4 <Sciclient_rmIrGetOutp+0x54> @ imm = #0x30
;         inst = Sciclient_rmIrGetInst(id);
700a3772: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
700a3776: f006 f94b    	bl	0x700a9a10 <Sciclient_rmIrGetInst> @ imm = #0x6296
700a377a: 9004         	str	r0, [sp, #0x10]
;         if (inst == NULL) {
700a377c: 9804         	ldr	r0, [sp, #0x10]
700a377e: b920         	cbnz	r0, 0x700a378a <Sciclient_rmIrGetOutp+0x3a> @ imm = #0x8
700a3780: e7ff         	b	0x700a3782 <Sciclient_rmIrGetOutp+0x32> @ imm = #-0x2
700a3782: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a3786: 9005         	str	r0, [sp, #0x14]
;         } else {
700a3788: e00b         	b	0x700a37a2 <Sciclient_rmIrGetOutp+0x52> @ imm = #0x16
;             if (inp >= inst->n_inp) {
700a378a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a378e: 9904         	ldr	r1, [sp, #0x10]
700a3790: 8909         	ldrh	r1, [r1, #0x8]
700a3792: 4288         	cmp	r0, r1
700a3794: db04         	blt	0x700a37a0 <Sciclient_rmIrGetOutp+0x50> @ imm = #0x8
700a3796: e7ff         	b	0x700a3798 <Sciclient_rmIrGetOutp+0x48> @ imm = #-0x2
700a3798: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a379c: 9005         	str	r0, [sp, #0x14]
;             }
700a379e: e7ff         	b	0x700a37a0 <Sciclient_rmIrGetOutp+0x50> @ imm = #-0x2
700a37a0: e7ff         	b	0x700a37a2 <Sciclient_rmIrGetOutp+0x52> @ imm = #-0x2
700a37a2: e7ff         	b	0x700a37a4 <Sciclient_rmIrGetOutp+0x54> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp == 0u)) {
700a37a4: 9805         	ldr	r0, [sp, #0x14]
700a37a6: b9a8         	cbnz	r0, 0x700a37d4 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x2a
700a37a8: e7ff         	b	0x700a37aa <Sciclient_rmIrGetOutp+0x5a> @ imm = #-0x2
700a37aa: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a37ae: b988         	cbnz	r0, 0x700a37d4 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x22
700a37b0: e7ff         	b	0x700a37b2 <Sciclient_rmIrGetOutp+0x62> @ imm = #-0x2
;         if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a37b2: 9804         	ldr	r0, [sp, #0x10]
700a37b4: 8980         	ldrh	r0, [r0, #0xc]
700a37b6: f64f 71ff    	movw	r1, #0xffff
700a37ba: 4288         	cmp	r0, r1
700a37bc: d005         	beq	0x700a37ca <Sciclient_rmIrGetOutp+0x7a> @ imm = #0xa
700a37be: e7ff         	b	0x700a37c0 <Sciclient_rmIrGetOutp+0x70> @ imm = #-0x2
;             *outp = inst->inp0_mapping;
700a37c0: 9804         	ldr	r0, [sp, #0x10]
700a37c2: 8980         	ldrh	r0, [r0, #0xc]
700a37c4: 9906         	ldr	r1, [sp, #0x18]
700a37c6: 8008         	strh	r0, [r1]
;         } else {
700a37c8: e003         	b	0x700a37d2 <Sciclient_rmIrGetOutp+0x82> @ imm = #0x6
700a37ca: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a37ce: 9005         	str	r0, [sp, #0x14]
700a37d0: e7ff         	b	0x700a37d2 <Sciclient_rmIrGetOutp+0x82> @ imm = #-0x2
;     }
700a37d2: e7ff         	b	0x700a37d4 <Sciclient_rmIrGetOutp+0x84> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp != 0u)) {
700a37d4: 9805         	ldr	r0, [sp, #0x14]
700a37d6: bbb8         	cbnz	r0, 0x700a3848 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x6e
700a37d8: e7ff         	b	0x700a37da <Sciclient_rmIrGetOutp+0x8a> @ imm = #-0x2
700a37da: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a37de: b398         	cbz	r0, 0x700a3848 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x66
700a37e0: e7ff         	b	0x700a37e2 <Sciclient_rmIrGetOutp+0x92> @ imm = #-0x2
700a37e2: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a37e6: 9005         	str	r0, [sp, #0x14]
700a37e8: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_outp; i++) {
700a37ea: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a37ee: e7ff         	b	0x700a37f0 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x2
700a37f0: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a37f4: 9904         	ldr	r1, [sp, #0x10]
700a37f6: 8949         	ldrh	r1, [r1, #0xa]
700a37f8: 4288         	cmp	r0, r1
700a37fa: da24         	bge	0x700a3846 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0x48
700a37fc: e7ff         	b	0x700a37fe <Sciclient_rmIrGetOutp+0xae> @ imm = #-0x2
;             int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, i);
700a37fe: 9804         	ldr	r0, [sp, #0x10]
700a3800: 6840         	ldr	r0, [r0, #0x4]
700a3802: f8bd 100e    	ldrh.w	r1, [sp, #0xe]
700a3806: f008 ffcb    	bl	0x700ac7a0 <Sciclient_getIrAddr> @ imm = #0x8f96
700a380a: 9002         	str	r0, [sp, #0x8]
;             extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a380c: 9802         	ldr	r0, [sp, #0x8]
700a380e: f240 31ff    	movw	r1, #0x3ff
700a3812: 2200         	movs	r2, #0x0
700a3814: f009 fa94    	bl	0x700acd40 <CSL_REG32_FEXT_RAW> @ imm = #0x9528
700a3818: f8ad 0006    	strh.w	r0, [sp, #0x6]
;             if (inp == extracted_inp) {
700a381c: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a3820: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700a3824: 4288         	cmp	r0, r1
700a3826: d107         	bne	0x700a3838 <Sciclient_rmIrGetOutp+0xe8> @ imm = #0xe
700a3828: e7ff         	b	0x700a382a <Sciclient_rmIrGetOutp+0xda> @ imm = #-0x2
;                 *outp = i;
700a382a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a382e: 9906         	ldr	r1, [sp, #0x18]
700a3830: 8008         	strh	r0, [r1]
700a3832: 2000         	movs	r0, #0x0
;                 r = SystemP_SUCCESS;
700a3834: 9005         	str	r0, [sp, #0x14]
;                 break;
700a3836: e006         	b	0x700a3846 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0xc
;         }
700a3838: e7ff         	b	0x700a383a <Sciclient_rmIrGetOutp+0xea> @ imm = #-0x2
;         for (i = 0u; i < inst->n_outp; i++) {
700a383a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a383e: 3001         	adds	r0, #0x1
700a3840: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a3844: e7d4         	b	0x700a37f0 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x58
;     }
700a3846: e7ff         	b	0x700a3848 <Sciclient_rmIrGetOutp+0xf8> @ imm = #-0x2
;     return r;
700a3848: 9805         	ldr	r0, [sp, #0x14]
700a384a: b008         	add	sp, #0x20
700a384c: bd80         	pop	{r7, pc}
700a384e: 0000         	movs	r0, r0

700a3850 <vTaskPriorityDisinheritAfterTimeout>:
;     UBaseType_t uxHighestPriorityWaitingTask) {
700a3850: b580         	push	{r7, lr}
700a3852: b086         	sub	sp, #0x18
700a3854: 9005         	str	r0, [sp, #0x14]
700a3856: 9104         	str	r1, [sp, #0x10]
;   TCB_t *const pxTCB = pxMutexHolder;
700a3858: 9805         	ldr	r0, [sp, #0x14]
700a385a: 9003         	str	r0, [sp, #0xc]
700a385c: 2001         	movs	r0, #0x1
;   const UBaseType_t uxOnlyOneMutexHeld = (UBaseType_t)1;
700a385e: 9000         	str	r0, [sp]
;   if (pxMutexHolder != NULL) {
700a3860: 9805         	ldr	r0, [sp, #0x14]
700a3862: 2800         	cmp	r0, #0x0
700a3864: d06d         	beq	0x700a3942 <vTaskPriorityDisinheritAfterTimeout+0xf2> @ imm = #0xda
700a3866: e7ff         	b	0x700a3868 <vTaskPriorityDisinheritAfterTimeout+0x18> @ imm = #-0x2
;     if (pxTCB->uxBasePriority < uxHighestPriorityWaitingTask) {
700a3868: 9803         	ldr	r0, [sp, #0xc]
700a386a: 6e00         	ldr	r0, [r0, #0x60]
700a386c: 9904         	ldr	r1, [sp, #0x10]
700a386e: 4288         	cmp	r0, r1
700a3870: d203         	bhs	0x700a387a <vTaskPriorityDisinheritAfterTimeout+0x2a> @ imm = #0x6
700a3872: e7ff         	b	0x700a3874 <vTaskPriorityDisinheritAfterTimeout+0x24> @ imm = #-0x2
;       uxPriorityToUse = uxHighestPriorityWaitingTask;
700a3874: 9804         	ldr	r0, [sp, #0x10]
700a3876: 9001         	str	r0, [sp, #0x4]
;     } else {
700a3878: e003         	b	0x700a3882 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #0x6
;       uxPriorityToUse = pxTCB->uxBasePriority;
700a387a: 9803         	ldr	r0, [sp, #0xc]
700a387c: 6e00         	ldr	r0, [r0, #0x60]
700a387e: 9001         	str	r0, [sp, #0x4]
700a3880: e7ff         	b	0x700a3882 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #-0x2
;     if (pxTCB->uxPriority != uxPriorityToUse) {
700a3882: 9803         	ldr	r0, [sp, #0xc]
700a3884: 6ac0         	ldr	r0, [r0, #0x2c]
700a3886: 9901         	ldr	r1, [sp, #0x4]
700a3888: 4288         	cmp	r0, r1
700a388a: d058         	beq	0x700a393e <vTaskPriorityDisinheritAfterTimeout+0xee> @ imm = #0xb0
700a388c: e7ff         	b	0x700a388e <vTaskPriorityDisinheritAfterTimeout+0x3e> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld) {
700a388e: 9803         	ldr	r0, [sp, #0xc]
700a3890: 6e40         	ldr	r0, [r0, #0x64]
700a3892: 2801         	cmp	r0, #0x1
700a3894: d151         	bne	0x700a393a <vTaskPriorityDisinheritAfterTimeout+0xea> @ imm = #0xa2
700a3896: e7ff         	b	0x700a3898 <vTaskPriorityDisinheritAfterTimeout+0x48> @ imm = #-0x2
;         uxPriorityUsedOnEntry = pxTCB->uxPriority;
700a3898: 9803         	ldr	r0, [sp, #0xc]
700a389a: 6ac0         	ldr	r0, [r0, #0x2c]
700a389c: 9002         	str	r0, [sp, #0x8]
;         pxTCB->uxPriority = uxPriorityToUse;
700a389e: 9801         	ldr	r0, [sp, #0x4]
700a38a0: 9903         	ldr	r1, [sp, #0xc]
700a38a2: 62c8         	str	r0, [r1, #0x2c]
;         if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) &
700a38a4: 9803         	ldr	r0, [sp, #0xc]
700a38a6: 7ec0         	ldrb	r0, [r0, #0x1b]
700a38a8: 0600         	lsls	r0, r0, #0x18
700a38aa: 2800         	cmp	r0, #0x0
700a38ac: d406         	bmi	0x700a38bc <vTaskPriorityDisinheritAfterTimeout+0x6c> @ imm = #0xc
700a38ae: e7ff         	b	0x700a38b0 <vTaskPriorityDisinheritAfterTimeout+0x60> @ imm = #-0x2
;           listSET_LIST_ITEM_VALUE(
700a38b0: 9801         	ldr	r0, [sp, #0x4]
700a38b2: f1c0 0020    	rsb.w	r0, r0, #0x20
700a38b6: 9903         	ldr	r1, [sp, #0xc]
700a38b8: 6188         	str	r0, [r1, #0x18]
;         } else {
700a38ba: e000         	b	0x700a38be <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #0x0
700a38bc: e7ff         	b	0x700a38be <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #-0x2
;         if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]),
700a38be: 9803         	ldr	r0, [sp, #0xc]
700a38c0: 6940         	ldr	r0, [r0, #0x14]
700a38c2: 9902         	ldr	r1, [sp, #0x8]
700a38c4: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a38c8: f244 41f8    	movw	r1, #0x44f8
700a38cc: f2c7 0108    	movt	r1, #0x7008
700a38d0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a38d4: 4288         	cmp	r0, r1
700a38d6: d12e         	bne	0x700a3936 <vTaskPriorityDisinheritAfterTimeout+0xe6> @ imm = #0x5c
700a38d8: e7ff         	b	0x700a38da <vTaskPriorityDisinheritAfterTimeout+0x8a> @ imm = #-0x2
;           if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a38da: 9803         	ldr	r0, [sp, #0xc]
700a38dc: 3004         	adds	r0, #0x4
700a38de: f007 fdbf    	bl	0x700ab460 <uxListRemove> @ imm = #0x7b7e
700a38e2: b968         	cbnz	r0, 0x700a3900 <vTaskPriorityDisinheritAfterTimeout+0xb0> @ imm = #0x1a
700a38e4: e7ff         	b	0x700a38e6 <vTaskPriorityDisinheritAfterTimeout+0x96> @ imm = #-0x2
;             portRESET_READY_PRIORITY(pxTCB->uxPriority, uxTopReadyPriority);
700a38e6: 9803         	ldr	r0, [sp, #0xc]
700a38e8: 6ac1         	ldr	r1, [r0, #0x2c]
700a38ea: 2001         	movs	r0, #0x1
700a38ec: fa00 f201    	lsl.w	r2, r0, r1
700a38f0: f240 11f8    	movw	r1, #0x1f8
700a38f4: f2c7 010b    	movt	r1, #0x700b
700a38f8: 6808         	ldr	r0, [r1]
700a38fa: 4390         	bics	r0, r2
700a38fc: 6008         	str	r0, [r1]
;           } else {
700a38fe: e000         	b	0x700a3902 <vTaskPriorityDisinheritAfterTimeout+0xb2> @ imm = #0x0
700a3900: e7ff         	b	0x700a3902 <vTaskPriorityDisinheritAfterTimeout+0xb2> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
700a3902: 9803         	ldr	r0, [sp, #0xc]
700a3904: 6ac1         	ldr	r1, [r0, #0x2c]
700a3906: 2001         	movs	r0, #0x1
700a3908: fa00 f201    	lsl.w	r2, r0, r1
700a390c: f240 11f8    	movw	r1, #0x1f8
700a3910: f2c7 010b    	movt	r1, #0x700b
700a3914: 6808         	ldr	r0, [r1]
700a3916: 4310         	orrs	r0, r2
700a3918: 6008         	str	r0, [r1]
700a391a: 9903         	ldr	r1, [sp, #0xc]
700a391c: 6ac8         	ldr	r0, [r1, #0x2c]
700a391e: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a3922: f244 40f8    	movw	r0, #0x44f8
700a3926: f2c7 0008    	movt	r0, #0x7008
700a392a: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a392e: 3104         	adds	r1, #0x4
700a3930: f008 fb06    	bl	0x700abf40 <vListInsertEnd> @ imm = #0x860c
;         } else {
700a3934: e000         	b	0x700a3938 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #0x0
700a3936: e7ff         	b	0x700a3938 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #-0x2
;       } else {
700a3938: e000         	b	0x700a393c <vTaskPriorityDisinheritAfterTimeout+0xec> @ imm = #0x0
700a393a: e7ff         	b	0x700a393c <vTaskPriorityDisinheritAfterTimeout+0xec> @ imm = #-0x2
;     } else {
700a393c: e000         	b	0x700a3940 <vTaskPriorityDisinheritAfterTimeout+0xf0> @ imm = #0x0
700a393e: e7ff         	b	0x700a3940 <vTaskPriorityDisinheritAfterTimeout+0xf0> @ imm = #-0x2
;   } else {
700a3940: e000         	b	0x700a3944 <vTaskPriorityDisinheritAfterTimeout+0xf4> @ imm = #0x0
700a3942: e7ff         	b	0x700a3944 <vTaskPriorityDisinheritAfterTimeout+0xf4> @ imm = #-0x2
; }
700a3944: b006         	add	sp, #0x18
700a3946: bd80         	pop	{r7, pc}
		...

700a3950 <eTaskGetState>:
; eTaskState eTaskGetState(TaskHandle_t xTask) {
700a3950: b580         	push	{r7, lr}
700a3952: b088         	sub	sp, #0x20
700a3954: 9007         	str	r0, [sp, #0x1c]
;   const TCB_t *const pxTCB = xTask;
700a3956: 9807         	ldr	r0, [sp, #0x1c]
700a3958: 9002         	str	r0, [sp, #0x8]
;   if (pxTCB == pxCurrentTCB) {
700a395a: 9802         	ldr	r0, [sp, #0x8]
700a395c: f240 11cc    	movw	r1, #0x1cc
700a3960: f2c7 010b    	movt	r1, #0x700b
700a3964: 6809         	ldr	r1, [r1]
700a3966: 4288         	cmp	r0, r1
700a3968: d104         	bne	0x700a3974 <eTaskGetState+0x24> @ imm = #0x8
700a396a: e7ff         	b	0x700a396c <eTaskGetState+0x1c> @ imm = #-0x2
700a396c: 2000         	movs	r0, #0x0
;     eReturn = eRunning;
700a396e: f88d 001b    	strb.w	r0, [sp, #0x1b]
;   } else {
700a3972: e063         	b	0x700a3a3c <eTaskGetState+0xec> @ imm = #0xc6
;     taskENTER_CRITICAL();
700a3974: f008 fd3c    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0x8a78
;       pxStateList = listLIST_ITEM_CONTAINER(&(pxTCB->xStateListItem));
700a3978: 9802         	ldr	r0, [sp, #0x8]
700a397a: 6940         	ldr	r0, [r0, #0x14]
700a397c: 9005         	str	r0, [sp, #0x14]
;       pxDelayedList = pxDelayedTaskList;
700a397e: f644 70b8    	movw	r0, #0x4fb8
700a3982: f2c7 0008    	movt	r0, #0x7008
700a3986: 6800         	ldr	r0, [r0]
700a3988: 9004         	str	r0, [sp, #0x10]
;       pxOverflowedDelayedList = pxOverflowDelayedTaskList;
700a398a: f644 70bc    	movw	r0, #0x4fbc
700a398e: f2c7 0008    	movt	r0, #0x7008
700a3992: 6800         	ldr	r0, [r0]
700a3994: 9003         	str	r0, [sp, #0xc]
;     taskEXIT_CRITICAL();
700a3996: f007 fe2b    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x7c56
;     if ((pxStateList == pxDelayedList) ||
700a399a: 9805         	ldr	r0, [sp, #0x14]
700a399c: 9904         	ldr	r1, [sp, #0x10]
700a399e: 4288         	cmp	r0, r1
700a39a0: d005         	beq	0x700a39ae <eTaskGetState+0x5e> @ imm = #0xa
700a39a2: e7ff         	b	0x700a39a4 <eTaskGetState+0x54> @ imm = #-0x2
;         (pxStateList == pxOverflowedDelayedList)) {
700a39a4: 9805         	ldr	r0, [sp, #0x14]
700a39a6: 9903         	ldr	r1, [sp, #0xc]
;     if ((pxStateList == pxDelayedList) ||
700a39a8: 4288         	cmp	r0, r1
700a39aa: d104         	bne	0x700a39b6 <eTaskGetState+0x66> @ imm = #0x8
700a39ac: e7ff         	b	0x700a39ae <eTaskGetState+0x5e> @ imm = #-0x2
700a39ae: 2002         	movs	r0, #0x2
;       eReturn = eBlocked;
700a39b0: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a39b4: e041         	b	0x700a3a3a <eTaskGetState+0xea> @ imm = #0x82
;     else if (pxStateList == &xSuspendedTaskList) {
700a39b6: 9805         	ldr	r0, [sp, #0x14]
700a39b8: f644 717c    	movw	r1, #0x4f7c
700a39bc: f2c7 0108    	movt	r1, #0x7008
700a39c0: 4288         	cmp	r0, r1
700a39c2: d125         	bne	0x700a3a10 <eTaskGetState+0xc0> @ imm = #0x4a
700a39c4: e7ff         	b	0x700a39c6 <eTaskGetState+0x76> @ imm = #-0x2
;       if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL) {
700a39c6: 9802         	ldr	r0, [sp, #0x8]
700a39c8: 6a80         	ldr	r0, [r0, #0x28]
700a39ca: b9e0         	cbnz	r0, 0x700a3a06 <eTaskGetState+0xb6> @ imm = #0x38
700a39cc: e7ff         	b	0x700a39ce <eTaskGetState+0x7e> @ imm = #-0x2
700a39ce: 2003         	movs	r0, #0x3
;           eReturn = eSuspended;
700a39d0: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a39d4: 2000         	movs	r0, #0x0
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a39d6: 9001         	str	r0, [sp, #0x4]
700a39d8: e7ff         	b	0x700a39da <eTaskGetState+0x8a> @ imm = #-0x2
700a39da: 9801         	ldr	r0, [sp, #0x4]
700a39dc: 2801         	cmp	r0, #0x1
700a39de: dc11         	bgt	0x700a3a04 <eTaskGetState+0xb4> @ imm = #0x22
700a39e0: e7ff         	b	0x700a39e2 <eTaskGetState+0x92> @ imm = #-0x2
;             if (pxTCB->ucNotifyState[x] == taskWAITING_NOTIFICATION) {
700a39e2: 9802         	ldr	r0, [sp, #0x8]
700a39e4: 9901         	ldr	r1, [sp, #0x4]
700a39e6: 4408         	add	r0, r1
700a39e8: f890 0084    	ldrb.w	r0, [r0, #0x84]
700a39ec: 2801         	cmp	r0, #0x1
700a39ee: d104         	bne	0x700a39fa <eTaskGetState+0xaa> @ imm = #0x8
700a39f0: e7ff         	b	0x700a39f2 <eTaskGetState+0xa2> @ imm = #-0x2
700a39f2: 2002         	movs	r0, #0x2
;               eReturn = eBlocked;
700a39f4: f88d 001b    	strb.w	r0, [sp, #0x1b]
;               break;
700a39f8: e004         	b	0x700a3a04 <eTaskGetState+0xb4> @ imm = #0x8
;           }
700a39fa: e7ff         	b	0x700a39fc <eTaskGetState+0xac> @ imm = #-0x2
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a39fc: 9801         	ldr	r0, [sp, #0x4]
700a39fe: 3001         	adds	r0, #0x1
700a3a00: 9001         	str	r0, [sp, #0x4]
700a3a02: e7ea         	b	0x700a39da <eTaskGetState+0x8a> @ imm = #-0x2c
;       } else {
700a3a04: e003         	b	0x700a3a0e <eTaskGetState+0xbe> @ imm = #0x6
700a3a06: 2002         	movs	r0, #0x2
;         eReturn = eBlocked;
700a3a08: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a3a0c: e7ff         	b	0x700a3a0e <eTaskGetState+0xbe> @ imm = #-0x2
;     }
700a3a0e: e013         	b	0x700a3a38 <eTaskGetState+0xe8> @ imm = #0x26
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a3a10: 9805         	ldr	r0, [sp, #0x14]
700a3a12: f644 7190    	movw	r1, #0x4f90
700a3a16: f2c7 0108    	movt	r1, #0x7008
700a3a1a: 4288         	cmp	r0, r1
700a3a1c: d003         	beq	0x700a3a26 <eTaskGetState+0xd6> @ imm = #0x6
700a3a1e: e7ff         	b	0x700a3a20 <eTaskGetState+0xd0> @ imm = #-0x2
;              (pxStateList == NULL)) {
700a3a20: 9805         	ldr	r0, [sp, #0x14]
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a3a22: b920         	cbnz	r0, 0x700a3a2e <eTaskGetState+0xde> @ imm = #0x8
700a3a24: e7ff         	b	0x700a3a26 <eTaskGetState+0xd6> @ imm = #-0x2
700a3a26: 2004         	movs	r0, #0x4
;       eReturn = eDeleted;
700a3a28: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a3a2c: e003         	b	0x700a3a36 <eTaskGetState+0xe6> @ imm = #0x6
700a3a2e: 2001         	movs	r0, #0x1
;       eReturn = eReady;
700a3a30: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a3a34: e7ff         	b	0x700a3a36 <eTaskGetState+0xe6> @ imm = #-0x2
700a3a36: e7ff         	b	0x700a3a38 <eTaskGetState+0xe8> @ imm = #-0x2
700a3a38: e7ff         	b	0x700a3a3a <eTaskGetState+0xea> @ imm = #-0x2
700a3a3a: e7ff         	b	0x700a3a3c <eTaskGetState+0xec> @ imm = #-0x2
;   return eReturn;
700a3a3c: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a3a40: b008         	add	sp, #0x20
700a3a42: bd80         	pop	{r7, pc}
		...

700a3a50 <prvAddCurrentTaskToDelayedList>:
;                                const BaseType_t xCanBlockIndefinitely) {
700a3a50: b580         	push	{r7, lr}
700a3a52: b084         	sub	sp, #0x10
700a3a54: 9003         	str	r0, [sp, #0xc]
700a3a56: 9102         	str	r1, [sp, #0x8]
;   const TickType_t xConstTickCount = xTickCount;
700a3a58: f240 2010    	movw	r0, #0x210
700a3a5c: f2c7 000b    	movt	r0, #0x700b
700a3a60: 6800         	ldr	r0, [r0]
700a3a62: 9000         	str	r0, [sp]
;   if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
700a3a64: f240 10cc    	movw	r0, #0x1cc
700a3a68: f2c7 000b    	movt	r0, #0x700b
700a3a6c: 6800         	ldr	r0, [r0]
700a3a6e: 3004         	adds	r0, #0x4
700a3a70: f007 fcf6    	bl	0x700ab460 <uxListRemove> @ imm = #0x79ec
700a3a74: b988         	cbnz	r0, 0x700a3a9a <prvAddCurrentTaskToDelayedList+0x4a> @ imm = #0x22
700a3a76: e7ff         	b	0x700a3a78 <prvAddCurrentTaskToDelayedList+0x28> @ imm = #-0x2
;     portRESET_READY_PRIORITY(
700a3a78: f240 10cc    	movw	r0, #0x1cc
700a3a7c: f2c7 000b    	movt	r0, #0x700b
700a3a80: 6800         	ldr	r0, [r0]
700a3a82: 6ac1         	ldr	r1, [r0, #0x2c]
700a3a84: 2001         	movs	r0, #0x1
700a3a86: fa00 f201    	lsl.w	r2, r0, r1
700a3a8a: f240 11f8    	movw	r1, #0x1f8
700a3a8e: f2c7 010b    	movt	r1, #0x700b
700a3a92: 6808         	ldr	r0, [r1]
700a3a94: 4390         	bics	r0, r2
700a3a96: 6008         	str	r0, [r1]
;   } else {
700a3a98: e000         	b	0x700a3a9c <prvAddCurrentTaskToDelayedList+0x4c> @ imm = #0x0
700a3a9a: e7ff         	b	0x700a3a9c <prvAddCurrentTaskToDelayedList+0x4c> @ imm = #-0x2
;     if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
700a3a9c: 9803         	ldr	r0, [sp, #0xc]
700a3a9e: 3001         	adds	r0, #0x1
700a3aa0: b980         	cbnz	r0, 0x700a3ac4 <prvAddCurrentTaskToDelayedList+0x74> @ imm = #0x20
700a3aa2: e7ff         	b	0x700a3aa4 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #-0x2
700a3aa4: 9802         	ldr	r0, [sp, #0x8]
700a3aa6: b168         	cbz	r0, 0x700a3ac4 <prvAddCurrentTaskToDelayedList+0x74> @ imm = #0x1a
700a3aa8: e7ff         	b	0x700a3aaa <prvAddCurrentTaskToDelayedList+0x5a> @ imm = #-0x2
;       vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
700a3aaa: f240 10cc    	movw	r0, #0x1cc
700a3aae: f2c7 000b    	movt	r0, #0x700b
700a3ab2: 6800         	ldr	r0, [r0]
700a3ab4: 1d01         	adds	r1, r0, #0x4
700a3ab6: f644 707c    	movw	r0, #0x4f7c
700a3aba: f2c7 0008    	movt	r0, #0x7008
700a3abe: f008 fa3f    	bl	0x700abf40 <vListInsertEnd> @ imm = #0x847e
;     } else {
700a3ac2: e03d         	b	0x700a3b40 <prvAddCurrentTaskToDelayedList+0xf0> @ imm = #0x7a
;       xTimeToWake = xConstTickCount + xTicksToWait;
700a3ac4: 9800         	ldr	r0, [sp]
700a3ac6: 9903         	ldr	r1, [sp, #0xc]
700a3ac8: 4408         	add	r0, r1
700a3aca: 9001         	str	r0, [sp, #0x4]
;       listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
700a3acc: 9801         	ldr	r0, [sp, #0x4]
700a3ace: f240 11cc    	movw	r1, #0x1cc
700a3ad2: f2c7 010b    	movt	r1, #0x700b
700a3ad6: 6809         	ldr	r1, [r1]
700a3ad8: 6048         	str	r0, [r1, #0x4]
;       if (xTimeToWake < xConstTickCount) {
700a3ada: 9801         	ldr	r0, [sp, #0x4]
700a3adc: 9900         	ldr	r1, [sp]
700a3ade: 4288         	cmp	r0, r1
700a3ae0: d20e         	bhs	0x700a3b00 <prvAddCurrentTaskToDelayedList+0xb0> @ imm = #0x1c
700a3ae2: e7ff         	b	0x700a3ae4 <prvAddCurrentTaskToDelayedList+0x94> @ imm = #-0x2
;         vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a3ae4: f644 70bc    	movw	r0, #0x4fbc
700a3ae8: f2c7 0008    	movt	r0, #0x7008
700a3aec: 6800         	ldr	r0, [r0]
700a3aee: f240 11cc    	movw	r1, #0x1cc
700a3af2: f2c7 010b    	movt	r1, #0x700b
700a3af6: 6809         	ldr	r1, [r1]
700a3af8: 3104         	adds	r1, #0x4
700a3afa: f005 fdc9    	bl	0x700a9690 <vListInsert> @ imm = #0x5b92
;       } else {
700a3afe: e01e         	b	0x700a3b3e <prvAddCurrentTaskToDelayedList+0xee> @ imm = #0x3c
;         vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a3b00: f644 70b8    	movw	r0, #0x4fb8
700a3b04: f2c7 0008    	movt	r0, #0x7008
700a3b08: 6800         	ldr	r0, [r0]
700a3b0a: f240 11cc    	movw	r1, #0x1cc
700a3b0e: f2c7 010b    	movt	r1, #0x700b
700a3b12: 6809         	ldr	r1, [r1]
700a3b14: 3104         	adds	r1, #0x4
700a3b16: f005 fdbb    	bl	0x700a9690 <vListInsert> @ imm = #0x5b76
;         if (xTimeToWake < xNextTaskUnblockTime) {
700a3b1a: 9801         	ldr	r0, [sp, #0x4]
700a3b1c: f240 2100    	movw	r1, #0x200
700a3b20: f2c7 010b    	movt	r1, #0x700b
700a3b24: 6809         	ldr	r1, [r1]
700a3b26: 4288         	cmp	r0, r1
700a3b28: d207         	bhs	0x700a3b3a <prvAddCurrentTaskToDelayedList+0xea> @ imm = #0xe
700a3b2a: e7ff         	b	0x700a3b2c <prvAddCurrentTaskToDelayedList+0xdc> @ imm = #-0x2
;           xNextTaskUnblockTime = xTimeToWake;
700a3b2c: 9801         	ldr	r0, [sp, #0x4]
700a3b2e: f240 2100    	movw	r1, #0x200
700a3b32: f2c7 010b    	movt	r1, #0x700b
700a3b36: 6008         	str	r0, [r1]
;         } else {
700a3b38: e000         	b	0x700a3b3c <prvAddCurrentTaskToDelayedList+0xec> @ imm = #0x0
700a3b3a: e7ff         	b	0x700a3b3c <prvAddCurrentTaskToDelayedList+0xec> @ imm = #-0x2
700a3b3c: e7ff         	b	0x700a3b3e <prvAddCurrentTaskToDelayedList+0xee> @ imm = #-0x2
700a3b3e: e7ff         	b	0x700a3b40 <prvAddCurrentTaskToDelayedList+0xf0> @ imm = #-0x2
; }
700a3b40: b004         	add	sp, #0x10
700a3b42: bd80         	pop	{r7, pc}
		...

700a3b50 <Udma_eventIsrFxn>:
; {
700a3b50: b580         	push	{r7, lr}
700a3b52: b088         	sub	sp, #0x20
700a3b54: 9007         	str	r0, [sp, #0x1c]
;     Udma_EventHandleInt eventHandle = (Udma_EventHandleInt) args;
700a3b56: 9807         	ldr	r0, [sp, #0x1c]
700a3b58: 9003         	str	r0, [sp, #0xc]
700a3b5a: 2001         	movs	r0, #0x1
;     teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_NA;
700a3b5c: 9004         	str	r0, [sp, #0x10]
700a3b5e: 2000         	movs	r0, #0x0
;     ringHandle = NULL;
700a3b60: 9000         	str	r0, [sp]
;     drvHandle = eventHandle->drvHandle;
700a3b62: 9803         	ldr	r0, [sp, #0xc]
700a3b64: 6800         	ldr	r0, [r0]
700a3b66: 9002         	str	r0, [sp, #0x8]
;     vintrNum = eventHandle->vintrNum;
700a3b68: 9803         	ldr	r0, [sp, #0xc]
700a3b6a: 6cc0         	ldr	r0, [r0, #0x4c]
700a3b6c: 9005         	str	r0, [sp, #0x14]
;     while(eventHandle != NULL_PTR)
700a3b6e: e7ff         	b	0x700a3b70 <Udma_eventIsrFxn+0x20> @ imm = #-0x2
700a3b70: 9803         	ldr	r0, [sp, #0xc]
700a3b72: 2800         	cmp	r0, #0x0
700a3b74: d060         	beq	0x700a3c38 <Udma_eventIsrFxn+0xe8> @ imm = #0xc0
700a3b76: e7ff         	b	0x700a3b78 <Udma_eventIsrFxn+0x28> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventHandle->eventPrms.eventType)
700a3b78: 9803         	ldr	r0, [sp, #0xc]
700a3b7a: 6880         	ldr	r0, [r0, #0x8]
700a3b7c: 2805         	cmp	r0, #0x5
700a3b7e: d057         	beq	0x700a3c30 <Udma_eventIsrFxn+0xe0> @ imm = #0xae
700a3b80: e7ff         	b	0x700a3b82 <Udma_eventIsrFxn+0x32> @ imm = #-0x2
;             vintrBitNum = vintrNum * UDMA_MAX_EVENTS_PER_VINTR;
700a3b82: 9805         	ldr	r0, [sp, #0x14]
700a3b84: 0180         	lsls	r0, r0, #0x6
700a3b86: 9006         	str	r0, [sp, #0x18]
;             vintrBitNum += eventHandle->vintrBitNum;
700a3b88: 9803         	ldr	r0, [sp, #0xc]
700a3b8a: 6d01         	ldr	r1, [r0, #0x50]
700a3b8c: 9806         	ldr	r0, [sp, #0x18]
700a3b8e: 4408         	add	r0, r1
700a3b90: 9006         	str	r0, [sp, #0x18]
;             if((bool)true == CSL_intaggrIsIntrPending(&drvHandle->iaRegs, vintrBitNum, (bool)true))
700a3b92: 9802         	ldr	r0, [sp, #0x8]
700a3b94: 309c         	adds	r0, #0x9c
700a3b96: 9906         	ldr	r1, [sp, #0x18]
700a3b98: 2201         	movs	r2, #0x1
700a3b9a: f002 fd29    	bl	0x700a65f0 <CSL_intaggrIsIntrPending> @ imm = #0x2a52
700a3b9e: 2800         	cmp	r0, #0x0
700a3ba0: d045         	beq	0x700a3c2e <Udma_eventIsrFxn+0xde> @ imm = #0x8a
700a3ba2: e7ff         	b	0x700a3ba4 <Udma_eventIsrFxn+0x54> @ imm = #-0x2
;                 (void) CSL_intaggrClrIntr(&drvHandle->iaRegs, vintrBitNum);
700a3ba4: 9802         	ldr	r0, [sp, #0x8]
700a3ba6: 309c         	adds	r0, #0x9c
700a3ba8: 9906         	ldr	r1, [sp, #0x18]
700a3baa: f005 fb79    	bl	0x700a92a0 <CSL_intaggrClrIntr> @ imm = #0x56f2
;                 eventPrms = &eventHandle->eventPrms;
700a3bae: 9803         	ldr	r0, [sp, #0xc]
700a3bb0: 3008         	adds	r0, #0x8
700a3bb2: 9001         	str	r0, [sp, #0x4]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a3bb4: 9801         	ldr	r0, [sp, #0x4]
700a3bb6: 6800         	ldr	r0, [r0]
700a3bb8: 2801         	cmp	r0, #0x1
700a3bba: d005         	beq	0x700a3bc8 <Udma_eventIsrFxn+0x78> @ imm = #0xa
700a3bbc: e7ff         	b	0x700a3bbe <Udma_eventIsrFxn+0x6e> @ imm = #-0x2
;                    (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a3bbe: 9801         	ldr	r0, [sp, #0x4]
700a3bc0: 6800         	ldr	r0, [r0]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a3bc2: 2806         	cmp	r0, #0x6
700a3bc4: d114         	bne	0x700a3bf0 <Udma_eventIsrFxn+0xa0> @ imm = #0x28
700a3bc6: e7ff         	b	0x700a3bc8 <Udma_eventIsrFxn+0x78> @ imm = #-0x2
;                     ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a3bc8: 9801         	ldr	r0, [sp, #0x4]
700a3bca: 6880         	ldr	r0, [r0, #0x8]
700a3bcc: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a3bd0: 9000         	str	r0, [sp]
;                     if( CSL_lcdma_ringaccIsTeardownComplete(&ringHandle->drvHandle->lcdmaRaRegs, ringHandle->ringNum) == TRUE )
700a3bd2: 9900         	ldr	r1, [sp]
700a3bd4: 6808         	ldr	r0, [r1]
700a3bd6: 308c         	adds	r0, #0x8c
700a3bd8: 8889         	ldrh	r1, [r1, #0x4]
700a3bda: f007 fe91    	bl	0x700ab900 <CSL_lcdma_ringaccIsTeardownComplete> @ imm = #0x7d22
700a3bde: b118         	cbz	r0, 0x700a3be8 <Udma_eventIsrFxn+0x98> @ imm = #0x6
700a3be0: e7ff         	b	0x700a3be2 <Udma_eventIsrFxn+0x92> @ imm = #-0x2
700a3be2: 2002         	movs	r0, #0x2
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE;
700a3be4: 9004         	str	r0, [sp, #0x10]
;                     }
700a3be6: e002         	b	0x700a3bee <Udma_eventIsrFxn+0x9e> @ imm = #0x4
700a3be8: 2003         	movs	r0, #0x3
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE;
700a3bea: 9004         	str	r0, [sp, #0x10]
700a3bec: e7ff         	b	0x700a3bee <Udma_eventIsrFxn+0x9e> @ imm = #-0x2
;                 }
700a3bee: e7ff         	b	0x700a3bf0 <Udma_eventIsrFxn+0xa0> @ imm = #-0x2
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a3bf0: 9803         	ldr	r0, [sp, #0xc]
700a3bf2: 6880         	ldr	r0, [r0, #0x8]
700a3bf4: 2801         	cmp	r0, #0x1
700a3bf6: d104         	bne	0x700a3c02 <Udma_eventIsrFxn+0xb2> @ imm = #0x8
700a3bf8: e7ff         	b	0x700a3bfa <Udma_eventIsrFxn+0xaa> @ imm = #-0x2
700a3bfa: 9804         	ldr	r0, [sp, #0x10]
700a3bfc: 2802         	cmp	r0, #0x2
700a3bfe: d015         	beq	0x700a3c2c <Udma_eventIsrFxn+0xdc> @ imm = #0x2a
700a3c00: e7ff         	b	0x700a3c02 <Udma_eventIsrFxn+0xb2> @ imm = #-0x2
;                  ((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_TEARDOWN_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE))))
700a3c02: 9803         	ldr	r0, [sp, #0xc]
700a3c04: 6880         	ldr	r0, [r0, #0x8]
700a3c06: 2806         	cmp	r0, #0x6
700a3c08: d104         	bne	0x700a3c14 <Udma_eventIsrFxn+0xc4> @ imm = #0x8
700a3c0a: e7ff         	b	0x700a3c0c <Udma_eventIsrFxn+0xbc> @ imm = #-0x2
700a3c0c: 9804         	ldr	r0, [sp, #0x10]
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a3c0e: 2803         	cmp	r0, #0x3
700a3c10: d00c         	beq	0x700a3c2c <Udma_eventIsrFxn+0xdc> @ imm = #0x18
700a3c12: e7ff         	b	0x700a3c14 <Udma_eventIsrFxn+0xc4> @ imm = #-0x2
;                     if((Udma_EventCallback) NULL_PTR != eventPrms->eventCb)
700a3c14: 9801         	ldr	r0, [sp, #0x4]
700a3c16: 6940         	ldr	r0, [r0, #0x14]
700a3c18: b138         	cbz	r0, 0x700a3c2a <Udma_eventIsrFxn+0xda> @ imm = #0xe
700a3c1a: e7ff         	b	0x700a3c1c <Udma_eventIsrFxn+0xcc> @ imm = #-0x2
;                         eventPrms->eventCb(
700a3c1c: 9a01         	ldr	r2, [sp, #0x4]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a3c1e: 9803         	ldr	r0, [sp, #0xc]
700a3c20: 6811         	ldr	r1, [r2]
;                         eventPrms->eventCb(
700a3c22: 6953         	ldr	r3, [r2, #0x14]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a3c24: 69d2         	ldr	r2, [r2, #0x1c]
;                         eventPrms->eventCb(
700a3c26: 4798         	blx	r3
;                     }
700a3c28: e7ff         	b	0x700a3c2a <Udma_eventIsrFxn+0xda> @ imm = #-0x2
;                 }
700a3c2a: e7ff         	b	0x700a3c2c <Udma_eventIsrFxn+0xdc> @ imm = #-0x2
;             }
700a3c2c: e7ff         	b	0x700a3c2e <Udma_eventIsrFxn+0xde> @ imm = #-0x2
;         }
700a3c2e: e7ff         	b	0x700a3c30 <Udma_eventIsrFxn+0xe0> @ imm = #-0x2
;         eventHandle = eventHandle->nextEvent;
700a3c30: 9803         	ldr	r0, [sp, #0xc]
700a3c32: 6dc0         	ldr	r0, [r0, #0x5c]
700a3c34: 9003         	str	r0, [sp, #0xc]
;     while(eventHandle != NULL_PTR)
700a3c36: e79b         	b	0x700a3b70 <Udma_eventIsrFxn+0x20> @ imm = #-0xca
;     return;
700a3c38: b008         	add	sp, #0x20
700a3c3a: bd80         	pop	{r7, pc}
700a3c3c: 0000         	movs	r0, r0
700a3c3e: 0000         	movs	r0, r0

700a3c40 <AddrTranslateP_getLocalAddr>:
; {
700a3c40: b580         	push	{r7, lr}
700a3c42: b08e         	sub	sp, #0x38
700a3c44: 910d         	str	r1, [sp, #0x34]
700a3c46: 900c         	str	r0, [sp, #0x30]
;     DebugP_assertNoLog(gAddrTranslateConfig.numRegions<AddrTranslateP_MAX_REGIONS);
700a3c48: f240 1064    	movw	r0, #0x164
700a3c4c: f2c7 000b    	movt	r0, #0x700b
700a3c50: 6801         	ldr	r1, [r0]
700a3c52: 2000         	movs	r0, #0x0
700a3c54: 9001         	str	r0, [sp, #0x4]
700a3c56: 2910         	cmp	r1, #0x10
700a3c58: bf38         	it	lo
700a3c5a: 2001         	movlo	r0, #0x1
700a3c5c: f00b f858    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0xb0b0
700a3c60: 9801         	ldr	r0, [sp, #0x4]
;     found = 0;
700a3c62: 900b         	str	r0, [sp, #0x2c]
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a3c64: 900a         	str	r0, [sp, #0x28]
700a3c66: e7ff         	b	0x700a3c68 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x2
700a3c68: 980a         	ldr	r0, [sp, #0x28]
700a3c6a: f240 1164    	movw	r1, #0x164
700a3c6e: f2c7 010b    	movt	r1, #0x700b
700a3c72: 6809         	ldr	r1, [r1]
700a3c74: 4288         	cmp	r0, r1
700a3c76: d23b         	bhs	0x700a3cf0 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x76
700a3c78: e7ff         	b	0x700a3c7a <AddrTranslateP_getLocalAddr+0x3a> @ imm = #-0x2
;         sizeMask = ( (uint32_t)( ((uint64_t)1U << gAddrTranslateConfig.regionConfig[regionId].size) - 1U) );
700a3c7a: f240 1064    	movw	r0, #0x164
700a3c7e: f2c7 000b    	movt	r0, #0x700b
700a3c82: 6881         	ldr	r1, [r0, #0x8]
700a3c84: 9a0a         	ldr	r2, [sp, #0x28]
700a3c86: eb01 1102    	add.w	r1, r1, r2, lsl #4
700a3c8a: 68ca         	ldr	r2, [r1, #0xc]
700a3c8c: 2101         	movs	r1, #0x1
700a3c8e: 4091         	lsls	r1, r2
700a3c90: 3a20         	subs	r2, #0x20
700a3c92: 2a00         	cmp	r2, #0x0
700a3c94: bf58         	it	pl
700a3c96: 2100         	movpl	r1, #0x0
700a3c98: 3901         	subs	r1, #0x1
700a3c9a: 9103         	str	r1, [sp, #0xc]
;         startAddr = gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a3c9c: 6880         	ldr	r0, [r0, #0x8]
700a3c9e: 9a0a         	ldr	r2, [sp, #0x28]
700a3ca0: eb00 1102    	add.w	r1, r0, r2, lsl #4
700a3ca4: ea4f 1202    	lsl.w	r2, r2, #0x4
700a3ca8: 5880         	ldr	r0, [r0, r2]
700a3caa: 6849         	ldr	r1, [r1, #0x4]
700a3cac: 9107         	str	r1, [sp, #0x1c]
700a3cae: 9006         	str	r0, [sp, #0x18]
;         endAddr = startAddr + sizeMask;
700a3cb0: 9906         	ldr	r1, [sp, #0x18]
700a3cb2: 9807         	ldr	r0, [sp, #0x1c]
700a3cb4: 9a03         	ldr	r2, [sp, #0xc]
700a3cb6: 1889         	adds	r1, r1, r2
700a3cb8: f140 0000    	adc	r0, r0, #0x0
700a3cbc: 9104         	str	r1, [sp, #0x10]
700a3cbe: 9005         	str	r0, [sp, #0x14]
;         if((systemAddr >= startAddr) && (systemAddr <= endAddr))
700a3cc0: 9a0c         	ldr	r2, [sp, #0x30]
700a3cc2: 980d         	ldr	r0, [sp, #0x34]
700a3cc4: 9b06         	ldr	r3, [sp, #0x18]
700a3cc6: 9907         	ldr	r1, [sp, #0x1c]
700a3cc8: 1ad2         	subs	r2, r2, r3
700a3cca: 4188         	sbcs	r0, r1
700a3ccc: d30b         	blo	0x700a3ce6 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x16
700a3cce: e7ff         	b	0x700a3cd0 <AddrTranslateP_getLocalAddr+0x90> @ imm = #-0x2
700a3cd0: 9b0c         	ldr	r3, [sp, #0x30]
700a3cd2: 990d         	ldr	r1, [sp, #0x34]
700a3cd4: 9a04         	ldr	r2, [sp, #0x10]
700a3cd6: 9805         	ldr	r0, [sp, #0x14]
700a3cd8: 1ad2         	subs	r2, r2, r3
700a3cda: 4188         	sbcs	r0, r1
700a3cdc: d303         	blo	0x700a3ce6 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x6
700a3cde: e7ff         	b	0x700a3ce0 <AddrTranslateP_getLocalAddr+0xa0> @ imm = #-0x2
700a3ce0: 2001         	movs	r0, #0x1
;             found = 1;
700a3ce2: 900b         	str	r0, [sp, #0x2c]
;             break;
700a3ce4: e004         	b	0x700a3cf0 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x8
;     }
700a3ce6: e7ff         	b	0x700a3ce8 <AddrTranslateP_getLocalAddr+0xa8> @ imm = #-0x2
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a3ce8: 980a         	ldr	r0, [sp, #0x28]
700a3cea: 3001         	adds	r0, #0x1
700a3cec: 900a         	str	r0, [sp, #0x28]
700a3cee: e7bb         	b	0x700a3c68 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x8a
;     if(found != 0U)
700a3cf0: 980b         	ldr	r0, [sp, #0x2c]
700a3cf2: b1a0         	cbz	r0, 0x700a3d1e <AddrTranslateP_getLocalAddr+0xde> @ imm = #0x28
700a3cf4: e7ff         	b	0x700a3cf6 <AddrTranslateP_getLocalAddr+0xb6> @ imm = #-0x2
;         uint32_t offset = systemAddr - gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a3cf6: 990c         	ldr	r1, [sp, #0x30]
700a3cf8: f240 1064    	movw	r0, #0x164
700a3cfc: f2c7 000b    	movt	r0, #0x700b
700a3d00: 6882         	ldr	r2, [r0, #0x8]
700a3d02: 9b0a         	ldr	r3, [sp, #0x28]
700a3d04: 011b         	lsls	r3, r3, #0x4
700a3d06: 58d2         	ldr	r2, [r2, r3]
700a3d08: 1a89         	subs	r1, r1, r2
700a3d0a: 9102         	str	r1, [sp, #0x8]
;         localAddr = (void *) (gAddrTranslateConfig.regionConfig[regionId].localAddr + offset);
700a3d0c: 6880         	ldr	r0, [r0, #0x8]
700a3d0e: 990a         	ldr	r1, [sp, #0x28]
700a3d10: eb00 1001    	add.w	r0, r0, r1, lsl #4
700a3d14: 6880         	ldr	r0, [r0, #0x8]
700a3d16: 9902         	ldr	r1, [sp, #0x8]
700a3d18: 4408         	add	r0, r1
700a3d1a: 9009         	str	r0, [sp, #0x24]
;     }
700a3d1c: e002         	b	0x700a3d24 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #0x4
;         localAddr = (void *) systemAddr;
700a3d1e: 980c         	ldr	r0, [sp, #0x30]
700a3d20: 9009         	str	r0, [sp, #0x24]
700a3d22: e7ff         	b	0x700a3d24 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #-0x2
;     return localAddr;
700a3d24: 9809         	ldr	r0, [sp, #0x24]
700a3d26: b00e         	add	sp, #0x38
700a3d28: bd80         	pop	{r7, pc}
700a3d2a: 0000         	movs	r0, r0
700a3d2c: 0000         	movs	r0, r0
700a3d2e: 0000         	movs	r0, r0

700a3d30 <Udma_eventFreeResource>:
; {
700a3d30: b580         	push	{r7, lr}
700a3d32: b084         	sub	sp, #0x10
700a3d34: 9003         	str	r0, [sp, #0xc]
700a3d36: 9102         	str	r1, [sp, #0x8]
;     cookie = HwiP_disable();
700a3d38: f00a eb2a    	blx	0x700ae390 <HwiP_disable> @ imm = #0xa654
700a3d3c: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventHandle->prevEvent)
700a3d3e: 9802         	ldr	r0, [sp, #0x8]
700a3d40: 6e00         	ldr	r0, [r0, #0x60]
700a3d42: b128         	cbz	r0, 0x700a3d50 <Udma_eventFreeResource+0x20> @ imm = #0xa
700a3d44: e7ff         	b	0x700a3d46 <Udma_eventFreeResource+0x16> @ imm = #-0x2
;         eventHandle->prevEvent->nextEvent = eventHandle->nextEvent;
700a3d46: 9902         	ldr	r1, [sp, #0x8]
700a3d48: 6dc8         	ldr	r0, [r1, #0x5c]
700a3d4a: 6e09         	ldr	r1, [r1, #0x60]
700a3d4c: 65c8         	str	r0, [r1, #0x5c]
;     }
700a3d4e: e7ff         	b	0x700a3d50 <Udma_eventFreeResource+0x20> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->nextEvent)
700a3d50: 9802         	ldr	r0, [sp, #0x8]
700a3d52: 6dc0         	ldr	r0, [r0, #0x5c]
700a3d54: b128         	cbz	r0, 0x700a3d62 <Udma_eventFreeResource+0x32> @ imm = #0xa
700a3d56: e7ff         	b	0x700a3d58 <Udma_eventFreeResource+0x28> @ imm = #-0x2
;         eventHandle->nextEvent->prevEvent = eventHandle->prevEvent;
700a3d58: 9802         	ldr	r0, [sp, #0x8]
700a3d5a: 6dc1         	ldr	r1, [r0, #0x5c]
700a3d5c: 6e00         	ldr	r0, [r0, #0x60]
700a3d5e: 6608         	str	r0, [r1, #0x60]
;     }
700a3d60: e7ff         	b	0x700a3d62 <Udma_eventFreeResource+0x32> @ imm = #-0x2
;     HwiP_restore(cookie);
700a3d62: 9801         	ldr	r0, [sp, #0x4]
700a3d64: f00a eb34    	blx	0x700ae3d0 <HwiP_restore> @ imm = #0xa668
;     if(NULL_PTR != eventHandle->hwiHandle)
700a3d68: 9802         	ldr	r0, [sp, #0x8]
700a3d6a: 6e40         	ldr	r0, [r0, #0x64]
700a3d6c: b140         	cbz	r0, 0x700a3d80 <Udma_eventFreeResource+0x50> @ imm = #0x10
700a3d6e: e7ff         	b	0x700a3d70 <Udma_eventFreeResource+0x40> @ imm = #-0x2
;         HwiP_destruct(&eventHandle->hwiObject);
700a3d70: 9802         	ldr	r0, [sp, #0x8]
700a3d72: 3068         	adds	r0, #0x68
700a3d74: f009 ff1c    	bl	0x700adbb0 <HwiP_destruct> @ imm = #0x9e38
;         eventHandle->hwiHandle = NULL_PTR;
700a3d78: 9902         	ldr	r1, [sp, #0x8]
700a3d7a: 2000         	movs	r0, #0x0
700a3d7c: 6648         	str	r0, [r1, #0x64]
;     }
700a3d7e: e7ff         	b	0x700a3d80 <Udma_eventFreeResource+0x50> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
700a3d80: 9802         	ldr	r0, [sp, #0x8]
700a3d82: 6d40         	ldr	r0, [r0, #0x54]
700a3d84: f510 3f80    	cmn.w	r0, #0x10000
700a3d88: d00d         	beq	0x700a3da6 <Udma_eventFreeResource+0x76> @ imm = #0x1a
700a3d8a: e7ff         	b	0x700a3d8c <Udma_eventFreeResource+0x5c> @ imm = #-0x2
;         Udma_rmFreeIrIntr(eventHandle->irIntrNum, drvHandle);
700a3d8c: 9802         	ldr	r0, [sp, #0x8]
700a3d8e: 6d40         	ldr	r0, [r0, #0x54]
700a3d90: 9903         	ldr	r1, [sp, #0xc]
700a3d92: f005 ff1d    	bl	0x700a9bd0 <Udma_rmFreeIrIntr> @ imm = #0x5e3a
;         eventHandle->irIntrNum = UDMA_INTR_INVALID;
700a3d96: 9902         	ldr	r1, [sp, #0x8]
700a3d98: 2000         	movs	r0, #0x0
700a3d9a: f6cf 70ff    	movt	r0, #0xffff
700a3d9e: 6548         	str	r0, [r1, #0x54]
;         eventHandle->coreIntrNum = UDMA_INTR_INVALID;
700a3da0: 9902         	ldr	r1, [sp, #0x8]
700a3da2: 6588         	str	r0, [r1, #0x58]
;     }
700a3da4: e7ff         	b	0x700a3da6 <Udma_eventFreeResource+0x76> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->globalEvent)
700a3da6: 9802         	ldr	r0, [sp, #0x8]
700a3da8: 6c80         	ldr	r0, [r0, #0x48]
700a3daa: f64f 71ff    	movw	r1, #0xffff
700a3dae: 4288         	cmp	r0, r1
700a3db0: d00e         	beq	0x700a3dd0 <Udma_eventFreeResource+0xa0> @ imm = #0x1c
700a3db2: e7ff         	b	0x700a3db4 <Udma_eventFreeResource+0x84> @ imm = #-0x2
;         Udma_eventResetSteering(drvHandle, eventHandle);
700a3db4: 9803         	ldr	r0, [sp, #0xc]
700a3db6: 9902         	ldr	r1, [sp, #0x8]
700a3db8: f008 fe5a    	bl	0x700aca70 <Udma_eventResetSteering> @ imm = #0x8cb4
;         Udma_rmFreeEvent(eventHandle->globalEvent, drvHandle);
700a3dbc: 9802         	ldr	r0, [sp, #0x8]
700a3dbe: 6c80         	ldr	r0, [r0, #0x48]
700a3dc0: 9903         	ldr	r1, [sp, #0xc]
700a3dc2: f005 fecd    	bl	0x700a9b60 <Udma_rmFreeEvent> @ imm = #0x5d9a
;         eventHandle->globalEvent = UDMA_EVENT_INVALID;
700a3dc6: 9902         	ldr	r1, [sp, #0x8]
700a3dc8: f64f 70ff    	movw	r0, #0xffff
700a3dcc: 6488         	str	r0, [r1, #0x48]
;     }
700a3dce: e7ff         	b	0x700a3dd0 <Udma_eventFreeResource+0xa0> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
700a3dd0: 9802         	ldr	r0, [sp, #0x8]
700a3dd2: 6d00         	ldr	r0, [r0, #0x50]
700a3dd4: f64f 71ff    	movw	r1, #0xffff
700a3dd8: 4288         	cmp	r0, r1
700a3dda: d00a         	beq	0x700a3df2 <Udma_eventFreeResource+0xc2> @ imm = #0x14
700a3ddc: e7ff         	b	0x700a3dde <Udma_eventFreeResource+0xae> @ imm = #-0x2
;         Udma_rmFreeVintrBit(eventHandle->vintrBitNum, drvHandle, eventHandle);
700a3dde: 9a02         	ldr	r2, [sp, #0x8]
700a3de0: 6d10         	ldr	r0, [r2, #0x50]
700a3de2: 9903         	ldr	r1, [sp, #0xc]
700a3de4: f004 fa8c    	bl	0x700a8300 <Udma_rmFreeVintrBit> @ imm = #0x4518
;         eventHandle->vintrBitNum = UDMA_EVENT_INVALID;
700a3de8: 9902         	ldr	r1, [sp, #0x8]
700a3dea: f64f 70ff    	movw	r0, #0xffff
700a3dee: 6508         	str	r0, [r1, #0x50]
;     }
700a3df0: e7ff         	b	0x700a3df2 <Udma_eventFreeResource+0xc2> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrNum)
700a3df2: 9802         	ldr	r0, [sp, #0x8]
700a3df4: 6cc0         	ldr	r0, [r0, #0x4c]
700a3df6: f64f 71ff    	movw	r1, #0xffff
700a3dfa: 4288         	cmp	r0, r1
700a3dfc: d00a         	beq	0x700a3e14 <Udma_eventFreeResource+0xe4> @ imm = #0x14
700a3dfe: e7ff         	b	0x700a3e00 <Udma_eventFreeResource+0xd0> @ imm = #-0x2
;         Udma_rmFreeVintr(eventHandle->vintrNum, drvHandle);
700a3e00: 9802         	ldr	r0, [sp, #0x8]
700a3e02: 6cc0         	ldr	r0, [r0, #0x4c]
700a3e04: 9903         	ldr	r1, [sp, #0xc]
700a3e06: f005 ff1b    	bl	0x700a9c40 <Udma_rmFreeVintr> @ imm = #0x5e36
;         eventHandle->vintrNum = UDMA_EVENT_INVALID;
700a3e0a: 9902         	ldr	r1, [sp, #0x8]
700a3e0c: f64f 70ff    	movw	r0, #0xffff
700a3e10: 64c8         	str	r0, [r1, #0x4c]
;     }
700a3e12: e7ff         	b	0x700a3e14 <Udma_eventFreeResource+0xe4> @ imm = #-0x2
;     return;
700a3e14: b004         	add	sp, #0x10
700a3e16: bd80         	pop	{r7, pc}
		...

700a3e20 <DebugP_memTraceLogWriterPutLine>:
; {
700a3e20: b580         	push	{r7, lr}
700a3e22: b08a         	sub	sp, #0x28
700a3e24: 9009         	str	r0, [sp, #0x24]
700a3e26: f8ad 1022    	strh.w	r1, [sp, #0x22]
700a3e2a: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a3e2c: 9007         	str	r0, [sp, #0x1c]
;     if (gDebugMemLogSize == 0U)
700a3e2e: f240 10a8    	movw	r0, #0x1a8
700a3e32: f2c7 000b    	movt	r0, #0x700b
700a3e36: 6800         	ldr	r0, [r0]
700a3e38: b920         	cbnz	r0, 0x700a3e44 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #0x8
700a3e3a: e7ff         	b	0x700a3e3c <DebugP_memTraceLogWriterPutLine+0x1c> @ imm = #-0x2
700a3e3c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a3e40: 9007         	str	r0, [sp, #0x1c]
;     }
700a3e42: e7ff         	b	0x700a3e44 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a3e44: 9807         	ldr	r0, [sp, #0x1c]
700a3e46: 2800         	cmp	r0, #0x0
700a3e48: d15a         	bne	0x700a3f00 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #0xb4
700a3e4a: e7ff         	b	0x700a3e4c <DebugP_memTraceLogWriterPutLine+0x2c> @ imm = #-0x2
;         wr_idx = gDebugMemLogWriteIndex;
700a3e4c: f240 10ac    	movw	r0, #0x1ac
700a3e50: f2c7 000b    	movt	r0, #0x700b
700a3e54: 6800         	ldr	r0, [r0]
700a3e56: 9006         	str	r0, [sp, #0x18]
;         dst = (uint8_t*)&gDebugMemLog[0];
700a3e58: f241 0080    	movw	r0, #0x1080
700a3e5c: f2c7 0008    	movt	r0, #0x7008
700a3e60: 9003         	str	r0, [sp, #0xc]
700a3e62: 2000         	movs	r0, #0x0
;         idx = 0;
700a3e64: 9004         	str	r0, [sp, #0x10]
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a3e66: 9005         	str	r0, [sp, #0x14]
700a3e68: e7ff         	b	0x700a3e6a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x2
700a3e6a: 9805         	ldr	r0, [sp, #0x14]
700a3e6c: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a3e70: 4288         	cmp	r0, r1
700a3e72: d233         	bhs	0x700a3edc <DebugP_memTraceLogWriterPutLine+0xbc> @ imm = #0x66
700a3e74: e7ff         	b	0x700a3e76 <DebugP_memTraceLogWriterPutLine+0x56> @ imm = #-0x2
;             dst[wr_idx] = buf[idx];
700a3e76: 9809         	ldr	r0, [sp, #0x24]
700a3e78: 9904         	ldr	r1, [sp, #0x10]
700a3e7a: 5c40         	ldrb	r0, [r0, r1]
700a3e7c: 9903         	ldr	r1, [sp, #0xc]
700a3e7e: 9a06         	ldr	r2, [sp, #0x18]
700a3e80: 5488         	strb	r0, [r1, r2]
;             wr_idx = wr_idx + 1U;
700a3e82: 9806         	ldr	r0, [sp, #0x18]
700a3e84: 3001         	adds	r0, #0x1
700a3e86: 9006         	str	r0, [sp, #0x18]
;             if (wr_idx >= gDebugMemLogSize)
700a3e88: 9806         	ldr	r0, [sp, #0x18]
700a3e8a: f240 11a8    	movw	r1, #0x1a8
700a3e8e: f2c7 010b    	movt	r1, #0x700b
700a3e92: 6809         	ldr	r1, [r1]
700a3e94: 4288         	cmp	r0, r1
700a3e96: d319         	blo	0x700a3ecc <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #0x32
700a3e98: e7ff         	b	0x700a3e9a <DebugP_memTraceLogWriterPutLine+0x7a> @ imm = #-0x2
;                         &dst[gDebugMemLogWriteIndex],
700a3e9a: 9803         	ldr	r0, [sp, #0xc]
700a3e9c: f240 12ac    	movw	r2, #0x1ac
700a3ea0: f2c7 020b    	movt	r2, #0x700b
700a3ea4: 9202         	str	r2, [sp, #0x8]
700a3ea6: 6811         	ldr	r1, [r2]
700a3ea8: 4408         	add	r0, r1
;                         (wr_idx - gDebugMemLogWriteIndex),
700a3eaa: 9906         	ldr	r1, [sp, #0x18]
700a3eac: 6812         	ldr	r2, [r2]
700a3eae: 1a89         	subs	r1, r1, r2
700a3eb0: 220f         	movs	r2, #0xf
;                 CacheP_wbInv(
700a3eb2: f00a eb66    	blx	0x700ae580 <CacheP_wbInv> @ imm = #0xa6cc
700a3eb6: 9902         	ldr	r1, [sp, #0x8]
700a3eb8: 2000         	movs	r0, #0x0
;                 wr_idx = 0;
700a3eba: 9006         	str	r0, [sp, #0x18]
;                 gDebugMemLogWriteIndex = 0;
700a3ebc: 6008         	str	r0, [r1]
;                 gDebugMemLogIsWrapAround = 1;
700a3ebe: f240 11a4    	movw	r1, #0x1a4
700a3ec2: f2c7 010b    	movt	r1, #0x700b
700a3ec6: 2001         	movs	r0, #0x1
700a3ec8: 6008         	str	r0, [r1]
;             }
700a3eca: e7ff         	b	0x700a3ecc <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #-0x2
;             idx ++;
700a3ecc: 9804         	ldr	r0, [sp, #0x10]
700a3ece: 3001         	adds	r0, #0x1
700a3ed0: 9004         	str	r0, [sp, #0x10]
;         }
700a3ed2: e7ff         	b	0x700a3ed4 <DebugP_memTraceLogWriterPutLine+0xb4> @ imm = #-0x2
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a3ed4: 9805         	ldr	r0, [sp, #0x14]
700a3ed6: 3001         	adds	r0, #0x1
700a3ed8: 9005         	str	r0, [sp, #0x14]
700a3eda: e7c6         	b	0x700a3e6a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x74
;                 &dst[gDebugMemLogWriteIndex],
700a3edc: 9803         	ldr	r0, [sp, #0xc]
700a3ede: f240 12ac    	movw	r2, #0x1ac
700a3ee2: f2c7 020b    	movt	r2, #0x700b
700a3ee6: 9201         	str	r2, [sp, #0x4]
700a3ee8: 6811         	ldr	r1, [r2]
700a3eea: 4408         	add	r0, r1
;                 (wr_idx - gDebugMemLogWriteIndex),
700a3eec: 9906         	ldr	r1, [sp, #0x18]
700a3eee: 6812         	ldr	r2, [r2]
700a3ef0: 1a89         	subs	r1, r1, r2
700a3ef2: 220f         	movs	r2, #0xf
;         CacheP_wbInv(
700a3ef4: f00a eb44    	blx	0x700ae580 <CacheP_wbInv> @ imm = #0xa688
700a3ef8: 9901         	ldr	r1, [sp, #0x4]
;         gDebugMemLogWriteIndex = wr_idx;
700a3efa: 9806         	ldr	r0, [sp, #0x18]
700a3efc: 6008         	str	r0, [r1]
;     }
700a3efe: e7ff         	b	0x700a3f00 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #-0x2
; }
700a3f00: b00a         	add	sp, #0x28
700a3f02: bd80         	pop	{r7, pc}
		...

700a3f10 <Sciclient_rmIrqGetNode>:
; {
700a3f10: b089         	sub	sp, #0x24
700a3f12: f8ad 0022    	strh.w	r0, [sp, #0x22]
700a3f16: 9107         	str	r1, [sp, #0x1c]
700a3f18: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700a3f1c: 9006         	str	r0, [sp, #0x18]
700a3f1e: 2000         	movs	r0, #0x0
;     lower = 0u;
700a3f20: 9004         	str	r0, [sp, #0x10]
;     upper = gRmIrqTreeCount - 1u;
700a3f22: f64f 6164    	movw	r1, #0xfe64
700a3f26: f2c7 010a    	movt	r1, #0x700a
700a3f2a: 680a         	ldr	r2, [r1]
700a3f2c: 3a01         	subs	r2, #0x1
700a3f2e: 9203         	str	r2, [sp, #0xc]
;     count = gRmIrqTreeCount;
700a3f30: 6809         	ldr	r1, [r1]
700a3f32: f8ad 1006    	strh.w	r1, [sp, #0x6]
;     *found_n = NULL;
700a3f36: 9907         	ldr	r1, [sp, #0x1c]
700a3f38: 6008         	str	r0, [r1]
;     while ((lower <= upper) &&
700a3f3a: e7ff         	b	0x700a3f3c <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0x2
700a3f3c: 9904         	ldr	r1, [sp, #0x10]
700a3f3e: 9a03         	ldr	r2, [sp, #0xc]
700a3f40: 2000         	movs	r0, #0x0
700a3f42: 4291         	cmp	r1, r2
700a3f44: 9000         	str	r0, [sp]
700a3f46: d81d         	bhi	0x700a3f84 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x3a
700a3f48: e7ff         	b	0x700a3f4a <Sciclient_rmIrqGetNode+0x3a> @ imm = #-0x2
;            (lower < gRmIrqTreeCount) &&
700a3f4a: 9904         	ldr	r1, [sp, #0x10]
700a3f4c: f64f 6064    	movw	r0, #0xfe64
700a3f50: f2c7 000a    	movt	r0, #0x700a
700a3f54: 6802         	ldr	r2, [r0]
700a3f56: 2000         	movs	r0, #0x0
700a3f58: 4291         	cmp	r1, r2
700a3f5a: 9000         	str	r0, [sp]
700a3f5c: d212         	bhs	0x700a3f84 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x24
700a3f5e: e7ff         	b	0x700a3f60 <Sciclient_rmIrqGetNode+0x50> @ imm = #-0x2
;            (upper < gRmIrqTreeCount) &&
700a3f60: 9903         	ldr	r1, [sp, #0xc]
700a3f62: f64f 6064    	movw	r0, #0xfe64
700a3f66: f2c7 000a    	movt	r0, #0x700a
700a3f6a: 6802         	ldr	r2, [r0]
700a3f6c: 2000         	movs	r0, #0x0
700a3f6e: 4291         	cmp	r1, r2
700a3f70: 9000         	str	r0, [sp]
700a3f72: d207         	bhs	0x700a3f84 <Sciclient_rmIrqGetNode+0x74> @ imm = #0xe
700a3f74: e7ff         	b	0x700a3f76 <Sciclient_rmIrqGetNode+0x66> @ imm = #-0x2
;            (count > 0u)) {
700a3f76: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a3f7a: 2800         	cmp	r0, #0x0
700a3f7c: bf18         	it	ne
700a3f7e: 2001         	movne	r0, #0x1
700a3f80: 9000         	str	r0, [sp]
700a3f82: e7ff         	b	0x700a3f84 <Sciclient_rmIrqGetNode+0x74> @ imm = #-0x2
700a3f84: 9800         	ldr	r0, [sp]
;     while ((lower <= upper) &&
700a3f86: 07c0         	lsls	r0, r0, #0x1f
700a3f88: b380         	cbz	r0, 0x700a3fec <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x60
700a3f8a: e7ff         	b	0x700a3f8c <Sciclient_rmIrqGetNode+0x7c> @ imm = #-0x2
;         current = (lower + upper) / (2u);
700a3f8c: 9804         	ldr	r0, [sp, #0x10]
700a3f8e: 9903         	ldr	r1, [sp, #0xc]
700a3f90: 4408         	add	r0, r1
700a3f92: 0840         	lsrs	r0, r0, #0x1
700a3f94: 9002         	str	r0, [sp, #0x8]
;         cur_n = (const struct Sciclient_rmIrqNode *) gRmIrqTree[current];
700a3f96: 9902         	ldr	r1, [sp, #0x8]
700a3f98: f24f 10ec    	movw	r0, #0xf1ec
700a3f9c: f2c7 000a    	movt	r0, #0x700a
700a3fa0: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a3fa4: 9005         	str	r0, [sp, #0x14]
;         if (cur_n->id == id) {
700a3fa6: 9805         	ldr	r0, [sp, #0x14]
700a3fa8: 8800         	ldrh	r0, [r0]
700a3faa: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a3fae: 4288         	cmp	r0, r1
700a3fb0: d106         	bne	0x700a3fc0 <Sciclient_rmIrqGetNode+0xb0> @ imm = #0xc
700a3fb2: e7ff         	b	0x700a3fb4 <Sciclient_rmIrqGetNode+0xa4> @ imm = #-0x2
;             *found_n = cur_n;
700a3fb4: 9805         	ldr	r0, [sp, #0x14]
700a3fb6: 9907         	ldr	r1, [sp, #0x1c]
700a3fb8: 6008         	str	r0, [r1]
700a3fba: 2000         	movs	r0, #0x0
;             r = SystemP_SUCCESS;
700a3fbc: 9006         	str	r0, [sp, #0x18]
;             break;
700a3fbe: e015         	b	0x700a3fec <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x2a
;             if (cur_n->id < id) {
700a3fc0: 9805         	ldr	r0, [sp, #0x14]
700a3fc2: 8800         	ldrh	r0, [r0]
700a3fc4: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a3fc8: 4288         	cmp	r0, r1
700a3fca: da04         	bge	0x700a3fd6 <Sciclient_rmIrqGetNode+0xc6> @ imm = #0x8
700a3fcc: e7ff         	b	0x700a3fce <Sciclient_rmIrqGetNode+0xbe> @ imm = #-0x2
;                 lower = current + (1u);
700a3fce: 9802         	ldr	r0, [sp, #0x8]
700a3fd0: 3001         	adds	r0, #0x1
700a3fd2: 9004         	str	r0, [sp, #0x10]
;             } else {
700a3fd4: e003         	b	0x700a3fde <Sciclient_rmIrqGetNode+0xce> @ imm = #0x6
;                 upper = current - (1u);
700a3fd6: 9802         	ldr	r0, [sp, #0x8]
700a3fd8: 3801         	subs	r0, #0x1
700a3fda: 9003         	str	r0, [sp, #0xc]
700a3fdc: e7ff         	b	0x700a3fde <Sciclient_rmIrqGetNode+0xce> @ imm = #-0x2
700a3fde: e7ff         	b	0x700a3fe0 <Sciclient_rmIrqGetNode+0xd0> @ imm = #-0x2
;         count--;
700a3fe0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a3fe4: 3801         	subs	r0, #0x1
700a3fe6: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     while ((lower <= upper) &&
700a3fea: e7a7         	b	0x700a3f3c <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0xb2
;     return r;
700a3fec: 9806         	ldr	r0, [sp, #0x18]
700a3fee: b009         	add	sp, #0x24
700a3ff0: 4770         	bx	lr
		...
700a3ffe: 0000         	movs	r0, r0

700a4000 <vTaskGetInfo>:
;                   BaseType_t xGetFreeStackSpace, eTaskState eState) {
700a4000: b580         	push	{r7, lr}
700a4002: b086         	sub	sp, #0x18
700a4004: 9005         	str	r0, [sp, #0x14]
700a4006: 9104         	str	r1, [sp, #0x10]
700a4008: 9203         	str	r2, [sp, #0xc]
700a400a: f88d 300b    	strb.w	r3, [sp, #0xb]
;   pxTCB = prvGetTCBFromHandle(xTask);
700a400e: 9805         	ldr	r0, [sp, #0x14]
700a4010: b938         	cbnz	r0, 0x700a4022 <vTaskGetInfo+0x22> @ imm = #0xe
700a4012: e7ff         	b	0x700a4014 <vTaskGetInfo+0x14> @ imm = #-0x2
700a4014: f240 10cc    	movw	r0, #0x1cc
700a4018: f2c7 000b    	movt	r0, #0x700b
700a401c: 6800         	ldr	r0, [r0]
700a401e: 9000         	str	r0, [sp]
700a4020: e002         	b	0x700a4028 <vTaskGetInfo+0x28> @ imm = #0x4
700a4022: 9805         	ldr	r0, [sp, #0x14]
700a4024: 9000         	str	r0, [sp]
700a4026: e7ff         	b	0x700a4028 <vTaskGetInfo+0x28> @ imm = #-0x2
700a4028: 9800         	ldr	r0, [sp]
700a402a: 9001         	str	r0, [sp, #0x4]
;   pxTaskStatus->xHandle = (TaskHandle_t)pxTCB;
700a402c: 9801         	ldr	r0, [sp, #0x4]
700a402e: 9904         	ldr	r1, [sp, #0x10]
700a4030: 6008         	str	r0, [r1]
;   pxTaskStatus->pcTaskName = (const char *)&(pxTCB->pcTaskName[0]);
700a4032: 9801         	ldr	r0, [sp, #0x4]
700a4034: 3034         	adds	r0, #0x34
700a4036: 9904         	ldr	r1, [sp, #0x10]
700a4038: 6048         	str	r0, [r1, #0x4]
;   pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
700a403a: 9801         	ldr	r0, [sp, #0x4]
700a403c: 6ac0         	ldr	r0, [r0, #0x2c]
700a403e: 9904         	ldr	r1, [sp, #0x10]
700a4040: 6108         	str	r0, [r1, #0x10]
;   pxTaskStatus->pxStackBase = pxTCB->pxStack;
700a4042: 9801         	ldr	r0, [sp, #0x4]
700a4044: 6b00         	ldr	r0, [r0, #0x30]
700a4046: 9904         	ldr	r1, [sp, #0x10]
700a4048: 61c8         	str	r0, [r1, #0x1c]
;   pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
700a404a: 9801         	ldr	r0, [sp, #0x4]
700a404c: 6d80         	ldr	r0, [r0, #0x58]
700a404e: 9904         	ldr	r1, [sp, #0x10]
700a4050: 6088         	str	r0, [r1, #0x8]
;     pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
700a4052: 9801         	ldr	r0, [sp, #0x4]
700a4054: 6e00         	ldr	r0, [r0, #0x60]
700a4056: 9904         	ldr	r1, [sp, #0x10]
700a4058: 6148         	str	r0, [r1, #0x14]
;     pxTaskStatus->ulRunTimeCounter = 0;
700a405a: 9904         	ldr	r1, [sp, #0x10]
700a405c: 2000         	movs	r0, #0x0
700a405e: 6188         	str	r0, [r1, #0x18]
;   if (eState != eInvalid) {
700a4060: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a4064: 2805         	cmp	r0, #0x5
700a4066: d025         	beq	0x700a40b4 <vTaskGetInfo+0xb4> @ imm = #0x4a
700a4068: e7ff         	b	0x700a406a <vTaskGetInfo+0x6a> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a406a: 9801         	ldr	r0, [sp, #0x4]
700a406c: f240 11cc    	movw	r1, #0x1cc
700a4070: f2c7 010b    	movt	r1, #0x700b
700a4074: 6809         	ldr	r1, [r1]
700a4076: 4288         	cmp	r0, r1
700a4078: d104         	bne	0x700a4084 <vTaskGetInfo+0x84> @ imm = #0x8
700a407a: e7ff         	b	0x700a407c <vTaskGetInfo+0x7c> @ imm = #-0x2
;       pxTaskStatus->eCurrentState = eRunning;
700a407c: 9904         	ldr	r1, [sp, #0x10]
700a407e: 2000         	movs	r0, #0x0
700a4080: 7308         	strb	r0, [r1, #0xc]
;     } else {
700a4082: e016         	b	0x700a40b2 <vTaskGetInfo+0xb2> @ imm = #0x2c
;       pxTaskStatus->eCurrentState = eState;
700a4084: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a4088: 9904         	ldr	r1, [sp, #0x10]
700a408a: 7308         	strb	r0, [r1, #0xc]
;         if (eState == eSuspended) {
700a408c: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a4090: 2803         	cmp	r0, #0x3
700a4092: d10d         	bne	0x700a40b0 <vTaskGetInfo+0xb0> @ imm = #0x1a
700a4094: e7ff         	b	0x700a4096 <vTaskGetInfo+0x96> @ imm = #-0x2
;           vTaskSuspendAll();
700a4096: f009 faf3    	bl	0x700ad680 <vTaskSuspendAll> @ imm = #0x95e6
;             if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a409a: 9801         	ldr	r0, [sp, #0x4]
700a409c: 6a80         	ldr	r0, [r0, #0x28]
700a409e: b120         	cbz	r0, 0x700a40aa <vTaskGetInfo+0xaa> @ imm = #0x8
700a40a0: e7ff         	b	0x700a40a2 <vTaskGetInfo+0xa2> @ imm = #-0x2
;               pxTaskStatus->eCurrentState = eBlocked;
700a40a2: 9904         	ldr	r1, [sp, #0x10]
700a40a4: 2002         	movs	r0, #0x2
700a40a6: 7308         	strb	r0, [r1, #0xc]
;             }
700a40a8: e7ff         	b	0x700a40aa <vTaskGetInfo+0xaa> @ imm = #-0x2
;           (void)xTaskResumeAll();
700a40aa: f7fc fd41    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0x357e
;         }
700a40ae: e7ff         	b	0x700a40b0 <vTaskGetInfo+0xb0> @ imm = #-0x2
700a40b0: e7ff         	b	0x700a40b2 <vTaskGetInfo+0xb2> @ imm = #-0x2
;   } else {
700a40b2: e005         	b	0x700a40c0 <vTaskGetInfo+0xc0> @ imm = #0xa
;     pxTaskStatus->eCurrentState = eTaskGetState(pxTCB);
700a40b4: 9801         	ldr	r0, [sp, #0x4]
700a40b6: f7ff fc4b    	bl	0x700a3950 <eTaskGetState> @ imm = #-0x76a
700a40ba: 9904         	ldr	r1, [sp, #0x10]
700a40bc: 7308         	strb	r0, [r1, #0xc]
700a40be: e7ff         	b	0x700a40c0 <vTaskGetInfo+0xc0> @ imm = #-0x2
;   if (xGetFreeStackSpace != pdFALSE) {
700a40c0: 9803         	ldr	r0, [sp, #0xc]
700a40c2: b138         	cbz	r0, 0x700a40d4 <vTaskGetInfo+0xd4> @ imm = #0xe
700a40c4: e7ff         	b	0x700a40c6 <vTaskGetInfo+0xc6> @ imm = #-0x2
;           prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
700a40c6: 9801         	ldr	r0, [sp, #0x4]
700a40c8: 6b00         	ldr	r0, [r0, #0x30]
700a40ca: f008 fac1    	bl	0x700ac650 <prvTaskCheckFreeStackSpace> @ imm = #0x8582
;       pxTaskStatus->usStackHighWaterMark =
700a40ce: 9904         	ldr	r1, [sp, #0x10]
700a40d0: 6208         	str	r0, [r1, #0x20]
;   } else {
700a40d2: e003         	b	0x700a40dc <vTaskGetInfo+0xdc> @ imm = #0x6
;     pxTaskStatus->usStackHighWaterMark = 0;
700a40d4: 9904         	ldr	r1, [sp, #0x10]
700a40d6: 2000         	movs	r0, #0x0
700a40d8: 6208         	str	r0, [r1, #0x20]
700a40da: e7ff         	b	0x700a40dc <vTaskGetInfo+0xdc> @ imm = #-0x2
; }
700a40dc: b006         	add	sp, #0x18
700a40de: bd80         	pop	{r7, pc}

700a40e0 <Sciclient_waitForMessage>:
; {
700a40e0: b580         	push	{r7, lr}
700a40e2: b088         	sub	sp, #0x20
700a40e4: 9007         	str	r0, [sp, #0x1c]
700a40e6: 9106         	str	r1, [sp, #0x18]
700a40e8: 9205         	str	r2, [sp, #0x14]
700a40ea: f88d 3013    	strb.w	r3, [sp, #0x13]
;     uint32_t timeToWait = timeout;
700a40ee: 9806         	ldr	r0, [sp, #0x18]
700a40f0: 9002         	str	r0, [sp, #0x8]
700a40f2: 2200         	movs	r2, #0x0
;     int32_t status = SystemP_SUCCESS;
700a40f4: 9201         	str	r2, [sp, #0x4]
;                                         &gSciclientSecProxyCfg, rxThread, 0U)
700a40f6: 9907         	ldr	r1, [sp, #0x1c]
;         (struct tisci_header *)(CSL_secProxyGetDataAddr(
700a40f8: f240 00e8    	movw	r0, #0xe8
700a40fc: f2c7 000b    	movt	r0, #0x700b
700a4100: f008 ffee    	bl	0x700ad0e0 <CSL_secProxyGetDataAddr> @ imm = #0x8fdc
;                                 + ((uintptr_t) gSecHeaderSizeWords * (uintptr_t) 4U));
700a4104: f240 2120    	movw	r1, #0x220
700a4108: f2c7 010b    	movt	r1, #0x700b
700a410c: 7809         	ldrb	r1, [r1]
700a410e: eb00 0081    	add.w	r0, r0, r1, lsl #2
;     pLocalRespHdr =
700a4112: 9003         	str	r0, [sp, #0xc]
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a4114: e7ff         	b	0x700a4116 <Sciclient_waitForMessage+0x36> @ imm = #-0x2
700a4116: 9807         	ldr	r0, [sp, #0x1c]
700a4118: f009 f872    	bl	0x700ad200 <Sciclient_secProxyThreadStatusReg> @ imm = #0x90e4
700a411c: f009 fae8    	bl	0x700ad6f0 <CSL_REG32_RD_RAW> @ imm = #0x95d0
700a4120: b2c0         	uxtb	r0, r0
;             CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount) <= 0U)
700a4122: 9905         	ldr	r1, [sp, #0x14]
700a4124: 1a40         	subs	r0, r0, r1
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a4126: b960         	cbnz	r0, 0x700a4142 <Sciclient_waitForMessage+0x62> @ imm = #0x18
700a4128: e7ff         	b	0x700a412a <Sciclient_waitForMessage+0x4a> @ imm = #-0x2
;         if (timeToWait != 0U)
700a412a: 9802         	ldr	r0, [sp, #0x8]
700a412c: b120         	cbz	r0, 0x700a4138 <Sciclient_waitForMessage+0x58> @ imm = #0x8
700a412e: e7ff         	b	0x700a4130 <Sciclient_waitForMessage+0x50> @ imm = #-0x2
;             timeToWait--;
700a4130: 9802         	ldr	r0, [sp, #0x8]
700a4132: 3801         	subs	r0, #0x1
700a4134: 9002         	str	r0, [sp, #0x8]
;         }
700a4136: e003         	b	0x700a4140 <Sciclient_waitForMessage+0x60> @ imm = #0x6
700a4138: f06f 0001    	mvn	r0, #0x1
;             status = SystemP_TIMEOUT;
700a413c: 9001         	str	r0, [sp, #0x4]
;             break;
700a413e: e000         	b	0x700a4142 <Sciclient_waitForMessage+0x62> @ imm = #0x0
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a4140: e7e9         	b	0x700a4116 <Sciclient_waitForMessage+0x36> @ imm = #-0x2e
;     if (status == SystemP_SUCCESS)
700a4142: 9801         	ldr	r0, [sp, #0x4]
700a4144: bbc0         	cbnz	r0, 0x700a41b8 <Sciclient_waitForMessage+0xd8> @ imm = #0x70
700a4146: e7ff         	b	0x700a4148 <Sciclient_waitForMessage+0x68> @ imm = #-0x2
700a4148: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700a414c: 9001         	str	r0, [sp, #0x4]
;         timeToWait =  timeout;
700a414e: 9806         	ldr	r0, [sp, #0x18]
700a4150: 9002         	str	r0, [sp, #0x8]
;         while(1)
700a4152: e7ff         	b	0x700a4154 <Sciclient_waitForMessage+0x74> @ imm = #-0x2
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a4154: 9807         	ldr	r0, [sp, #0x1c]
700a4156: f009 f853    	bl	0x700ad200 <Sciclient_secProxyThreadStatusReg> @ imm = #0x90a6
700a415a: f009 fac9    	bl	0x700ad6f0 <CSL_REG32_RD_RAW> @ imm = #0x9592
700a415e: b2c0         	uxtb	r0, r0
;                     CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount;
700a4160: 9905         	ldr	r1, [sp, #0x14]
700a4162: 1a40         	subs	r0, r0, r1
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a4164: 9000         	str	r0, [sp]
;             if (pLocalRespHdr->seq == (uint32_t)localSeqId)
700a4166: 9803         	ldr	r0, [sp, #0xc]
700a4168: 78c0         	ldrb	r0, [r0, #0x3]
700a416a: f89d 1013    	ldrb.w	r1, [sp, #0x13]
700a416e: 4288         	cmp	r0, r1
700a4170: d103         	bne	0x700a417a <Sciclient_waitForMessage+0x9a> @ imm = #0x6
700a4172: e7ff         	b	0x700a4174 <Sciclient_waitForMessage+0x94> @ imm = #-0x2
700a4174: 2000         	movs	r0, #0x0
;                 status = SystemP_SUCCESS;
700a4176: 9001         	str	r0, [sp, #0x4]
;                 break;
700a4178: e01d         	b	0x700a41b6 <Sciclient_waitForMessage+0xd6> @ imm = #0x3a
;             if (numCurrentMsgs > 1U)
700a417a: 9800         	ldr	r0, [sp]
700a417c: 2802         	cmp	r0, #0x2
700a417e: d30e         	blo	0x700a419e <Sciclient_waitForMessage+0xbe> @ imm = #0x1c
700a4180: e7ff         	b	0x700a4182 <Sciclient_waitForMessage+0xa2> @ imm = #-0x2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a4182: 9807         	ldr	r0, [sp, #0x1c]
;                                             (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a4184: f240 1138    	movw	r1, #0x138
700a4188: f2c7 010b    	movt	r1, #0x700b
700a418c: 694a         	ldr	r2, [r1, #0x14]
700a418e: f04f 31ff    	mov.w	r1, #0xffffffff
700a4192: eb01 0192    	add.w	r1, r1, r2, lsr #2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a4196: b2c9         	uxtb	r1, r1
700a4198: f008 fa12    	bl	0x700ac5c0 <Sciclient_secProxyReadThread32> @ imm = #0x8424
;             }
700a419c: e7ff         	b	0x700a419e <Sciclient_waitForMessage+0xbe> @ imm = #-0x2
;             if (timeToWait != 0U)
700a419e: 9802         	ldr	r0, [sp, #0x8]
700a41a0: b120         	cbz	r0, 0x700a41ac <Sciclient_waitForMessage+0xcc> @ imm = #0x8
700a41a2: e7ff         	b	0x700a41a4 <Sciclient_waitForMessage+0xc4> @ imm = #-0x2
;                 timeToWait--;
700a41a4: 9802         	ldr	r0, [sp, #0x8]
700a41a6: 3801         	subs	r0, #0x1
700a41a8: 9002         	str	r0, [sp, #0x8]
;             }
700a41aa: e003         	b	0x700a41b4 <Sciclient_waitForMessage+0xd4> @ imm = #0x6
700a41ac: f06f 0001    	mvn	r0, #0x1
;                 status = SystemP_TIMEOUT;
700a41b0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a41b2: e000         	b	0x700a41b6 <Sciclient_waitForMessage+0xd6> @ imm = #0x0
;         while(1)
700a41b4: e7ce         	b	0x700a4154 <Sciclient_waitForMessage+0x74> @ imm = #-0x64
;     }
700a41b6: e7ff         	b	0x700a41b8 <Sciclient_waitForMessage+0xd8> @ imm = #-0x2
;     return status;
700a41b8: 9801         	ldr	r0, [sp, #0x4]
700a41ba: b008         	add	sp, #0x20
700a41bc: bd80         	pop	{r7, pc}
700a41be: 0000         	movs	r0, r0

700a41c0 <UART_intrEnable>:
; {
700a41c0: b580         	push	{r7, lr}
700a41c2: b08a         	sub	sp, #0x28
700a41c4: 9009         	str	r0, [sp, #0x24]
700a41c6: 9108         	str	r1, [sp, #0x20]
700a41c8: 2000         	movs	r0, #0x0
;     uint32_t enhanFnBitVal = 0U;
700a41ca: 9007         	str	r0, [sp, #0x1c]
;     uint32_t lcrRegValue   = 0U;
700a41cc: 9006         	str	r0, [sp, #0x18]
;     if ((intrFlag & 0xF0U) > 0U)
700a41ce: f89d 0020    	ldrb.w	r0, [sp, #0x20]
700a41d2: f010 0ff0    	tst.w	r0, #0xf0
700a41d6: d053         	beq	0x700a4280 <UART_intrEnable+0xc0> @ imm = #0xa6
700a41d8: e7ff         	b	0x700a41da <UART_intrEnable+0x1a> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a41da: 9809         	ldr	r0, [sp, #0x24]
700a41dc: 300c         	adds	r0, #0xc
700a41de: f009 fa27    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x944e
700a41e2: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a41e4: 9809         	ldr	r0, [sp, #0x24]
700a41e6: 300c         	adds	r0, #0xc
700a41e8: 21bf         	movs	r1, #0xbf
700a41ea: 9103         	str	r1, [sp, #0xc]
700a41ec: f009 fa28    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x9450
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a41f0: 9809         	ldr	r0, [sp, #0x24]
700a41f2: 3008         	adds	r0, #0x8
700a41f4: 2110         	movs	r1, #0x10
700a41f6: 9104         	str	r1, [sp, #0x10]
700a41f8: 2204         	movs	r2, #0x4
700a41fa: 9205         	str	r2, [sp, #0x14]
700a41fc: f008 fe80    	bl	0x700acf00 <HW_RD_FIELD32_RAW> @ imm = #0x8d00
700a4200: 9904         	ldr	r1, [sp, #0x10]
700a4202: 9a05         	ldr	r2, [sp, #0x14]
700a4204: 9007         	str	r0, [sp, #0x1c]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a4206: 9809         	ldr	r0, [sp, #0x24]
700a4208: 3008         	adds	r0, #0x8
700a420a: 2301         	movs	r3, #0x1
700a420c: f008 f890    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x8120
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4210: 9809         	ldr	r0, [sp, #0x24]
700a4212: 300c         	adds	r0, #0xc
700a4214: 9906         	ldr	r1, [sp, #0x18]
700a4216: f009 fa13    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x9426
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a421a: 9809         	ldr	r0, [sp, #0x24]
700a421c: 300c         	adds	r0, #0xc
700a421e: f009 fa07    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x940e
700a4222: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a4224: 9809         	ldr	r0, [sp, #0x24]
700a4226: 300c         	adds	r0, #0xc
700a4228: 9002         	str	r0, [sp, #0x8]
700a422a: f009 fa01    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x9402
700a422e: 4601         	mov	r1, r0
700a4230: 9802         	ldr	r0, [sp, #0x8]
700a4232: f001 017f    	and	r1, r1, #0x7f
700a4236: f009 fa03    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x9406
;         HW_WR_REG32(baseAddr + UART_IER, intrFlag & 0xF0U);
700a423a: 9809         	ldr	r0, [sp, #0x24]
700a423c: 3004         	adds	r0, #0x4
700a423e: 9908         	ldr	r1, [sp, #0x20]
700a4240: f001 01f0    	and	r1, r1, #0xf0
700a4244: f009 f9fc    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x93f8
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4248: 9809         	ldr	r0, [sp, #0x24]
700a424a: 300c         	adds	r0, #0xc
700a424c: 9906         	ldr	r1, [sp, #0x18]
700a424e: f009 f9f7    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x93ee
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a4252: 9809         	ldr	r0, [sp, #0x24]
700a4254: 300c         	adds	r0, #0xc
700a4256: f009 f9eb    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x93d6
700a425a: 9903         	ldr	r1, [sp, #0xc]
700a425c: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a425e: 9809         	ldr	r0, [sp, #0x24]
700a4260: 300c         	adds	r0, #0xc
700a4262: f009 f9ed    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x93da
700a4266: 9904         	ldr	r1, [sp, #0x10]
700a4268: 9a05         	ldr	r2, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a426a: 9809         	ldr	r0, [sp, #0x24]
700a426c: 3008         	adds	r0, #0x8
700a426e: 9b07         	ldr	r3, [sp, #0x1c]
700a4270: f008 f85e    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x80bc
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4274: 9809         	ldr	r0, [sp, #0x24]
700a4276: 300c         	adds	r0, #0xc
700a4278: 9906         	ldr	r1, [sp, #0x18]
700a427a: f009 f9e1    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x93c2
;     }
700a427e: e7ff         	b	0x700a4280 <UART_intrEnable+0xc0> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) |
700a4280: 9809         	ldr	r0, [sp, #0x24]
700a4282: 3004         	adds	r0, #0x4
700a4284: 9001         	str	r0, [sp, #0x4]
700a4286: f009 f9d3    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x93a6
700a428a: 4601         	mov	r1, r0
700a428c: 9801         	ldr	r0, [sp, #0x4]
700a428e: 9a08         	ldr	r2, [sp, #0x20]
700a4290: f002 020f    	and	r2, r2, #0xf
700a4294: 4311         	orrs	r1, r2
700a4296: f009 f9d3    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x93a6
; }
700a429a: b00a         	add	sp, #0x28
700a429c: bd80         	pop	{r7, pc}
700a429e: 0000         	movs	r0, r0

700a42a0 <Sciclient_rmIrInpIsFree>:
; {
700a42a0: b580         	push	{r7, lr}
700a42a2: b086         	sub	sp, #0x18
700a42a4: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a42a8: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a42ac: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a42ae: 9004         	str	r0, [sp, #0x10]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a42b0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a42b2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a42b6: f005 fbab    	bl	0x700a9a10 <Sciclient_rmIrGetInst> @ imm = #0x5756
700a42ba: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a42bc: 9803         	ldr	r0, [sp, #0xc]
700a42be: b920         	cbnz	r0, 0x700a42ca <Sciclient_rmIrInpIsFree+0x2a> @ imm = #0x8
700a42c0: e7ff         	b	0x700a42c2 <Sciclient_rmIrInpIsFree+0x22> @ imm = #-0x2
700a42c2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a42c6: 9004         	str	r0, [sp, #0x10]
;     } else {
700a42c8: e00b         	b	0x700a42e2 <Sciclient_rmIrInpIsFree+0x42> @ imm = #0x16
;         if (inp >= inst->n_inp) {
700a42ca: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a42ce: 9903         	ldr	r1, [sp, #0xc]
700a42d0: 8909         	ldrh	r1, [r1, #0x8]
700a42d2: 4288         	cmp	r0, r1
700a42d4: db04         	blt	0x700a42e0 <Sciclient_rmIrInpIsFree+0x40> @ imm = #0x8
700a42d6: e7ff         	b	0x700a42d8 <Sciclient_rmIrInpIsFree+0x38> @ imm = #-0x2
700a42d8: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a42dc: 9004         	str	r0, [sp, #0x10]
;         }
700a42de: e7ff         	b	0x700a42e0 <Sciclient_rmIrInpIsFree+0x40> @ imm = #-0x2
700a42e0: e7ff         	b	0x700a42e2 <Sciclient_rmIrInpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a42e2: 9804         	ldr	r0, [sp, #0x10]
700a42e4: 2800         	cmp	r0, #0x0
700a42e6: d145         	bne	0x700a4374 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #0x8a
700a42e8: e7ff         	b	0x700a42ea <Sciclient_rmIrInpIsFree+0x4a> @ imm = #-0x2
;         if (inp == 0u) {
700a42ea: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a42ee: b960         	cbnz	r0, 0x700a430a <Sciclient_rmIrInpIsFree+0x6a> @ imm = #0x18
700a42f0: e7ff         	b	0x700a42f2 <Sciclient_rmIrInpIsFree+0x52> @ imm = #-0x2
;             if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a42f2: 9803         	ldr	r0, [sp, #0xc]
700a42f4: 8980         	ldrh	r0, [r0, #0xc]
700a42f6: f64f 71ff    	movw	r1, #0xffff
700a42fa: 4288         	cmp	r0, r1
700a42fc: d004         	beq	0x700a4308 <Sciclient_rmIrInpIsFree+0x68> @ imm = #0x8
700a42fe: e7ff         	b	0x700a4300 <Sciclient_rmIrInpIsFree+0x60> @ imm = #-0x2
700a4300: f04f 30ff    	mov.w	r0, #0xffffffff
;                 r = SystemP_FAILURE;
700a4304: 9004         	str	r0, [sp, #0x10]
;             }
700a4306: e7ff         	b	0x700a4308 <Sciclient_rmIrInpIsFree+0x68> @ imm = #-0x2
;         } else {
700a4308: e033         	b	0x700a4372 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #0x66
700a430a: 2000         	movs	r0, #0x0
;             for (i = 0u; i < inst->n_outp; i++) {
700a430c: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a4310: e7ff         	b	0x700a4312 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x2
700a4312: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a4316: 9903         	ldr	r1, [sp, #0xc]
700a4318: 8949         	ldrh	r1, [r1, #0xa]
700a431a: 4288         	cmp	r0, r1
700a431c: da28         	bge	0x700a4370 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0x50
700a431e: e7ff         	b	0x700a4320 <Sciclient_rmIrInpIsFree+0x80> @ imm = #-0x2
;                 int_ctrl_reg = (volatile uint32_t *)Sciclient_getIrAddr(inst->cfg, i);
700a4320: 9803         	ldr	r0, [sp, #0xc]
700a4322: 6840         	ldr	r0, [r0, #0x4]
700a4324: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a4328: f008 fa3a    	bl	0x700ac7a0 <Sciclient_getIrAddr> @ imm = #0x8474
700a432c: 9001         	str	r0, [sp, #0x4]
;                 extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a432e: 9801         	ldr	r0, [sp, #0x4]
700a4330: f240 31ff    	movw	r1, #0x3ff
700a4334: 2200         	movs	r2, #0x0
700a4336: f008 fd03    	bl	0x700acd40 <CSL_REG32_FEXT_RAW> @ imm = #0x8a06
700a433a: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 if ((extracted_inp == inp) &&
700a433e: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a4342: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a4346: 4288         	cmp	r0, r1
700a4348: d10b         	bne	0x700a4362 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x16
700a434a: e7ff         	b	0x700a434c <Sciclient_rmIrInpIsFree+0xac> @ imm = #-0x2
;                     (Sciclient_rmIrInpRomMapped(inst, inp) == false)) {
700a434c: 9803         	ldr	r0, [sp, #0xc]
700a434e: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a4352: f001 ffed    	bl	0x700a6330 <Sciclient_rmIrInpRomMapped> @ imm = #0x1fda
;                 if ((extracted_inp == inp) &&
700a4356: b920         	cbnz	r0, 0x700a4362 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x8
700a4358: e7ff         	b	0x700a435a <Sciclient_rmIrInpIsFree+0xba> @ imm = #-0x2
700a435a: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
700a435e: 9004         	str	r0, [sp, #0x10]
;                     break;
700a4360: e006         	b	0x700a4370 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0xc
;             }
700a4362: e7ff         	b	0x700a4364 <Sciclient_rmIrInpIsFree+0xc4> @ imm = #-0x2
;             for (i = 0u; i < inst->n_outp; i++) {
700a4364: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a4368: 3001         	adds	r0, #0x1
700a436a: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a436e: e7d0         	b	0x700a4312 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x60
700a4370: e7ff         	b	0x700a4372 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #-0x2
;     }
700a4372: e7ff         	b	0x700a4374 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #-0x2
;     return r;
700a4374: 9804         	ldr	r0, [sp, #0x10]
700a4376: b006         	add	sp, #0x18
700a4378: bd80         	pop	{r7, pc}
700a437a: 0000         	movs	r0, r0
700a437c: 0000         	movs	r0, r0
700a437e: 0000         	movs	r0, r0

700a4380 <UART_intrDisable>:
; {
700a4380: b580         	push	{r7, lr}
700a4382: b088         	sub	sp, #0x20
700a4384: 9007         	str	r0, [sp, #0x1c]
700a4386: 9106         	str	r1, [sp, #0x18]
;     if((intrFlag & 0xF0U) > 0U)
700a4388: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a438c: f010 0ff0    	tst.w	r0, #0xf0
700a4390: d020         	beq	0x700a43d4 <UART_intrDisable+0x54> @ imm = #0x40
700a4392: e7ff         	b	0x700a4394 <UART_intrDisable+0x14> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a4394: 9807         	ldr	r0, [sp, #0x1c]
700a4396: 300c         	adds	r0, #0xc
700a4398: f009 f94a    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x9294
700a439c: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a439e: 9807         	ldr	r0, [sp, #0x1c]
700a43a0: 300c         	adds	r0, #0xc
700a43a2: 21bf         	movs	r1, #0xbf
700a43a4: f009 f94c    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x9298
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a43a8: 9807         	ldr	r0, [sp, #0x1c]
700a43aa: 3008         	adds	r0, #0x8
700a43ac: 2110         	movs	r1, #0x10
700a43ae: 9102         	str	r1, [sp, #0x8]
700a43b0: 2204         	movs	r2, #0x4
700a43b2: 9203         	str	r2, [sp, #0xc]
700a43b4: f008 fda4    	bl	0x700acf00 <HW_RD_FIELD32_RAW> @ imm = #0x8b48
700a43b8: 9902         	ldr	r1, [sp, #0x8]
700a43ba: 9a03         	ldr	r2, [sp, #0xc]
700a43bc: 9005         	str	r0, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a43be: 9807         	ldr	r0, [sp, #0x1c]
700a43c0: 3008         	adds	r0, #0x8
700a43c2: 2301         	movs	r3, #0x1
700a43c4: f007 ffb4    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x7f68
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a43c8: 9807         	ldr	r0, [sp, #0x1c]
700a43ca: 300c         	adds	r0, #0xc
700a43cc: 9904         	ldr	r1, [sp, #0x10]
700a43ce: f009 f937    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x926e
;     }
700a43d2: e7ff         	b	0x700a43d4 <UART_intrDisable+0x54> @ imm = #-0x2
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a43d4: 9807         	ldr	r0, [sp, #0x1c]
700a43d6: 300c         	adds	r0, #0xc
700a43d8: f009 f92a    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x9254
700a43dc: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a43de: 9807         	ldr	r0, [sp, #0x1c]
700a43e0: 300c         	adds	r0, #0xc
700a43e2: 9000         	str	r0, [sp]
700a43e4: f009 f924    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x9248
700a43e8: 4601         	mov	r1, r0
700a43ea: 9800         	ldr	r0, [sp]
700a43ec: f001 017f    	and	r1, r1, #0x7f
700a43f0: f009 f926    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x924c
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) &
700a43f4: 9807         	ldr	r0, [sp, #0x1c]
700a43f6: 3004         	adds	r0, #0x4
700a43f8: 9001         	str	r0, [sp, #0x4]
700a43fa: f009 f919    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x9232
700a43fe: 4601         	mov	r1, r0
700a4400: 9801         	ldr	r0, [sp, #0x4]
700a4402: 9b06         	ldr	r3, [sp, #0x18]
700a4404: f06f 02ff    	mvn	r2, #0xff
700a4408: ea62 0203    	orn	r2, r2, r3
700a440c: 4011         	ands	r1, r2
700a440e: f009 f917    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x922e
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4412: 9807         	ldr	r0, [sp, #0x1c]
700a4414: 300c         	adds	r0, #0xc
700a4416: 9904         	ldr	r1, [sp, #0x10]
700a4418: f009 f912    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x9224
;     if((intrFlag & 0xF0U) > 0U)
700a441c: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a4420: f010 0ff0    	tst.w	r0, #0xf0
700a4424: d017         	beq	0x700a4456 <UART_intrDisable+0xd6> @ imm = #0x2e
700a4426: e7ff         	b	0x700a4428 <UART_intrDisable+0xa8> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a4428: 9807         	ldr	r0, [sp, #0x1c]
700a442a: 300c         	adds	r0, #0xc
700a442c: f009 f900    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x9200
700a4430: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a4432: 9807         	ldr	r0, [sp, #0x1c]
700a4434: 300c         	adds	r0, #0xc
700a4436: 21bf         	movs	r1, #0xbf
700a4438: f009 f902    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x9204
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a443c: 9807         	ldr	r0, [sp, #0x1c]
700a443e: 3008         	adds	r0, #0x8
700a4440: 9b05         	ldr	r3, [sp, #0x14]
700a4442: 2110         	movs	r1, #0x10
700a4444: 2204         	movs	r2, #0x4
700a4446: f007 ff73    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x7ee6
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a444a: 9807         	ldr	r0, [sp, #0x1c]
700a444c: 300c         	adds	r0, #0xc
700a444e: 9904         	ldr	r1, [sp, #0x10]
700a4450: f009 f8f6    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x91ec
;     }
700a4454: e7ff         	b	0x700a4456 <UART_intrDisable+0xd6> @ imm = #-0x2
; }
700a4456: b008         	add	sp, #0x20
700a4458: bd80         	pop	{r7, pc}
700a445a: 0000         	movs	r0, r0
700a445c: 0000         	movs	r0, r0
700a445e: 0000         	movs	r0, r0

700a4460 <UART_udmaConfigPdmaTx>:
; {
700a4460: b580         	push	{r7, lr}
700a4462: b090         	sub	sp, #0x40
700a4464: 900f         	str	r0, [sp, #0x3c]
700a4466: 910e         	str	r1, [sp, #0x38]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a4468: 980f         	ldr	r0, [sp, #0x3c]
700a446a: 6840         	ldr	r0, [r0, #0x4]
700a446c: 6cc0         	ldr	r0, [r0, #0x4c]
700a446e: 9008         	str	r0, [sp, #0x20]
;     txChHandle  = udmaChCfg->txChHandle;
700a4470: 9808         	ldr	r0, [sp, #0x20]
700a4472: 6840         	ldr	r0, [r0, #0x4]
700a4474: 9009         	str	r0, [sp, #0x24]
700a4476: a80a         	add	r0, sp, #0x28
;     UdmaChPdmaPrms_init(&pdmaPrms);
700a4478: 9002         	str	r0, [sp, #0x8]
700a447a: f008 fdf1    	bl	0x700ad060 <UdmaChPdmaPrms_init> @ imm = #0x8be2
700a447e: 9902         	ldr	r1, [sp, #0x8]
700a4480: 2000         	movs	r0, #0x0
;     pdmaPrms.elemSize = UDMA_PDMA_ES_8BITS;
700a4482: 9003         	str	r0, [sp, #0xc]
700a4484: 900a         	str	r0, [sp, #0x28]
700a4486: 2201         	movs	r2, #0x1
;     pdmaPrms.elemCnt  = 1U;
700a4488: 920b         	str	r2, [sp, #0x2c]
;     pdmaPrms.fifoCnt  = 0U;
700a448a: 900c         	str	r0, [sp, #0x30]
;     retVal = Udma_chConfigPdma(txChHandle, &pdmaPrms);
700a448c: 9809         	ldr	r0, [sp, #0x24]
700a448e: f7fa ff97    	bl	0x7009f3c0 <Udma_chConfigPdma> @ imm = #-0x50d2
700a4492: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a4494: 980d         	ldr	r0, [sp, #0x34]
700a4496: fab0 f080    	clz	r0, r0
700a449a: 0940         	lsrs	r0, r0, #0x5
700a449c: f64f 0130    	movw	r1, #0xf830
700a44a0: f2c7 010a    	movt	r1, #0x700a
700a44a4: 9105         	str	r1, [sp, #0x14]
700a44a6: 466a         	mov	r2, sp
700a44a8: 6011         	str	r1, [r2]
700a44aa: f24f 41b9    	movw	r1, #0xf4b9
700a44ae: f2c7 010a    	movt	r1, #0x700a
700a44b2: 9106         	str	r1, [sp, #0x18]
700a44b4: f64f 0203    	movw	r2, #0xf803
700a44b8: f2c7 020a    	movt	r2, #0x700a
700a44bc: 9207         	str	r2, [sp, #0x1c]
700a44be: 23ee         	movs	r3, #0xee
700a44c0: f004 fb6e    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x46dc
;     retVal = Udma_chEnable(txChHandle);
700a44c4: 9809         	ldr	r0, [sp, #0x24]
700a44c6: f004 fdab    	bl	0x700a9020 <Udma_chEnable> @ imm = #0x4b56
700a44ca: 9b05         	ldr	r3, [sp, #0x14]
700a44cc: 9906         	ldr	r1, [sp, #0x18]
700a44ce: 9a07         	ldr	r2, [sp, #0x1c]
700a44d0: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a44d2: 980d         	ldr	r0, [sp, #0x34]
700a44d4: fab0 f080    	clz	r0, r0
700a44d8: 0940         	lsrs	r0, r0, #0x5
700a44da: 46ec         	mov	r12, sp
700a44dc: f8cc 3000    	str.w	r3, [r12]
700a44e0: 23f1         	movs	r3, #0xf1
700a44e2: f004 fb5d    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x46ba
;     UART_udmaHpdInit(txChHandle, (uint8_t *) udmaChCfg->txHpdMem, hUart->writeBuf, transaction->count);
700a44e6: 9809         	ldr	r0, [sp, #0x24]
700a44e8: 9908         	ldr	r1, [sp, #0x20]
700a44ea: 6949         	ldr	r1, [r1, #0x14]
700a44ec: 9a0f         	ldr	r2, [sp, #0x3c]
700a44ee: 6892         	ldr	r2, [r2, #0x8]
700a44f0: 9b0e         	ldr	r3, [sp, #0x38]
700a44f2: 685b         	ldr	r3, [r3, #0x4]
700a44f4: f000 fc54    	bl	0x700a4da0 <UART_udmaHpdInit> @ imm = #0x8a8
;                  Udma_chGetFqRingHandle(txChHandle),
700a44f8: 9809         	ldr	r0, [sp, #0x24]
700a44fa: f004 fd11    	bl	0x700a8f20 <Udma_chGetFqRingHandle> @ imm = #0x4a22
700a44fe: 9a03         	ldr	r2, [sp, #0xc]
;                  (uint64_t) Udma_defaultVirtToPhyFxn(udmaChCfg->txHpdMem, 0U, NULL));
700a4500: 9004         	str	r0, [sp, #0x10]
700a4502: 9808         	ldr	r0, [sp, #0x20]
700a4504: 6940         	ldr	r0, [r0, #0x14]
700a4506: 4611         	mov	r1, r2
700a4508: f009 f8a2    	bl	0x700ad650 <Udma_defaultVirtToPhyFxn> @ imm = #0x9144
700a450c: 4602         	mov	r2, r0
700a450e: 9804         	ldr	r0, [sp, #0x10]
700a4510: 460b         	mov	r3, r1
;     retVal = Udma_ringQueueRaw(
700a4512: f002 fd95    	bl	0x700a7040 <Udma_ringQueueRaw> @ imm = #0x2b2a
700a4516: 9b05         	ldr	r3, [sp, #0x14]
700a4518: 9906         	ldr	r1, [sp, #0x18]
700a451a: 9a07         	ldr	r2, [sp, #0x1c]
700a451c: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a451e: 980d         	ldr	r0, [sp, #0x34]
700a4520: fab0 f080    	clz	r0, r0
700a4524: 0940         	lsrs	r0, r0, #0x5
700a4526: 46ec         	mov	r12, sp
700a4528: f8cc 3000    	str.w	r3, [r12]
700a452c: 23f9         	movs	r3, #0xf9
700a452e: f004 fb37    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x466e
;     return (retVal);
700a4532: 980d         	ldr	r0, [sp, #0x34]
700a4534: b010         	add	sp, #0x40
700a4536: bd80         	pop	{r7, pc}
		...

700a4540 <CSL_bcdmaChanOpGetChanRT>:
; {
700a4540: b580         	push	{r7, lr}
700a4542: b088         	sub	sp, #0x20
700a4544: 9007         	str	r0, [sp, #0x1c]
700a4546: 9106         	str	r1, [sp, #0x18]
700a4548: 9205         	str	r2, [sp, #0x14]
700a454a: 9304         	str	r3, [sp, #0x10]
700a454c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a454e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a4550: 9804         	ldr	r0, [sp, #0x10]
700a4552: b920         	cbnz	r0, 0x700a455e <CSL_bcdmaChanOpGetChanRT+0x1e> @ imm = #0x8
700a4554: e7ff         	b	0x700a4556 <CSL_bcdmaChanOpGetChanRT+0x16> @ imm = #-0x2
700a4556: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a455a: 9003         	str	r0, [sp, #0xc]
;     }
700a455c: e057         	b	0x700a460e <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #0xae
;         switch( chanType )
700a455e: 9806         	ldr	r0, [sp, #0x18]
700a4560: 9000         	str	r0, [sp]
700a4562: b140         	cbz	r0, 0x700a4576 <CSL_bcdmaChanOpGetChanRT+0x36> @ imm = #0x10
700a4564: e7ff         	b	0x700a4566 <CSL_bcdmaChanOpGetChanRT+0x26> @ imm = #-0x2
700a4566: 9800         	ldr	r0, [sp]
700a4568: 2801         	cmp	r0, #0x1
700a456a: d00d         	beq	0x700a4588 <CSL_bcdmaChanOpGetChanRT+0x48> @ imm = #0x1a
700a456c: e7ff         	b	0x700a456e <CSL_bcdmaChanOpGetChanRT+0x2e> @ imm = #-0x2
700a456e: 9800         	ldr	r0, [sp]
700a4570: 2802         	cmp	r0, #0x2
700a4572: d012         	beq	0x700a459a <CSL_bcdmaChanOpGetChanRT+0x5a> @ imm = #0x24
700a4574: e01a         	b	0x700a45ac <CSL_bcdmaChanOpGetChanRT+0x6c> @ imm = #0x34
;                 val = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
700a4576: 9807         	ldr	r0, [sp, #0x1c]
700a4578: 6880         	ldr	r0, [r0, #0x8]
700a457a: 9905         	ldr	r1, [sp, #0x14]
700a457c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4580: f009 f89e    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0x913c
700a4584: 9002         	str	r0, [sp, #0x8]
;                 break;
700a4586: e015         	b	0x700a45b4 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x2a
;                 val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a4588: 9807         	ldr	r0, [sp, #0x1c]
700a458a: 6900         	ldr	r0, [r0, #0x10]
700a458c: 9905         	ldr	r1, [sp, #0x14]
700a458e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4592: f009 f895    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0x912a
700a4596: 9002         	str	r0, [sp, #0x8]
;                 break;
700a4598: e00c         	b	0x700a45b4 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x18
;                 val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a459a: 9807         	ldr	r0, [sp, #0x1c]
700a459c: 6980         	ldr	r0, [r0, #0x18]
700a459e: 9905         	ldr	r1, [sp, #0x14]
700a45a0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a45a4: f009 f88c    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0x9118
700a45a8: 9002         	str	r0, [sp, #0x8]
;                 break;
700a45aa: e003         	b	0x700a45b4 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x6
700a45ac: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a45b0: 9003         	str	r0, [sp, #0xc]
;                 break;
700a45b2: e7ff         	b	0x700a45b4 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #-0x2
;         if( retVal == CSL_PASS )
700a45b4: 9803         	ldr	r0, [sp, #0xc]
700a45b6: bb48         	cbnz	r0, 0x700a460c <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #0x52
700a45b8: e7ff         	b	0x700a45ba <CSL_bcdmaChanOpGetChanRT+0x7a> @ imm = #-0x2
;             CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a45ba: 9804         	ldr	r0, [sp, #0x10]
700a45bc: 9001         	str	r0, [sp, #0x4]
;             pRT->enable         = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_EN );
700a45be: 9802         	ldr	r0, [sp, #0x8]
700a45c0: 0fc0         	lsrs	r0, r0, #0x1f
700a45c2: 9901         	ldr	r1, [sp, #0x4]
700a45c4: 6008         	str	r0, [r1]
;             pRT->teardown       = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_TDOWN );
700a45c6: 9802         	ldr	r0, [sp, #0x8]
700a45c8: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700a45cc: 9901         	ldr	r1, [sp, #0x4]
700a45ce: 6048         	str	r0, [r1, #0x4]
;             pRT->forcedTeardown = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_FTDOWN );
700a45d0: 9802         	ldr	r0, [sp, #0x8]
700a45d2: f3c0 7000    	ubfx	r0, r0, #0x1c, #0x1
700a45d6: 9901         	ldr	r1, [sp, #0x4]
700a45d8: 6108         	str	r0, [r1, #0x10]
;             pRT->pause          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_PAUSE );
700a45da: 9802         	ldr	r0, [sp, #0x8]
700a45dc: f3c0 7040    	ubfx	r0, r0, #0x1d, #0x1
700a45e0: 9901         	ldr	r1, [sp, #0x4]
700a45e2: 6088         	str	r0, [r1, #0x8]
;             pRT->error          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_ERROR );
700a45e4: 9802         	ldr	r0, [sp, #0x8]
700a45e6: f000 0001    	and	r0, r0, #0x1
700a45ea: 9901         	ldr	r1, [sp, #0x4]
700a45ec: 60c8         	str	r0, [r1, #0xc]
;             if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a45ee: 9806         	ldr	r0, [sp, #0x18]
700a45f0: 2802         	cmp	r0, #0x2
700a45f2: d106         	bne	0x700a4602 <CSL_bcdmaChanOpGetChanRT+0xc2> @ imm = #0xc
700a45f4: e7ff         	b	0x700a45f6 <CSL_bcdmaChanOpGetChanRT+0xb6> @ imm = #-0x2
;                 pRT->starvation = CSL_FEXT( val, BCDMA_RXCRT_CHAN_CTL_STARVATION );
700a45f6: 9802         	ldr	r0, [sp, #0x8]
700a45f8: f3c0 0040    	ubfx	r0, r0, #0x1, #0x1
700a45fc: 9901         	ldr	r1, [sp, #0x4]
700a45fe: 6148         	str	r0, [r1, #0x14]
;             }
700a4600: e003         	b	0x700a460a <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #0x6
;                 pRT->starvation = (uint32_t)0U;
700a4602: 9901         	ldr	r1, [sp, #0x4]
700a4604: 2000         	movs	r0, #0x0
700a4606: 6148         	str	r0, [r1, #0x14]
700a4608: e7ff         	b	0x700a460a <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #-0x2
;         }
700a460a: e7ff         	b	0x700a460c <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #-0x2
700a460c: e7ff         	b	0x700a460e <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #-0x2
;     return retVal;
700a460e: 9803         	ldr	r0, [sp, #0xc]
700a4610: b008         	add	sp, #0x20
700a4612: bd80         	pop	{r7, pc}
		...

700a4620 <Pinmux_unlockMMR>:
; {
700a4620: b580         	push	{r7, lr}
700a4622: b088         	sub	sp, #0x20
700a4624: 9007         	str	r0, [sp, #0x1c]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a4626: 9807         	ldr	r0, [sp, #0x1c]
700a4628: bb78         	cbnz	r0, 0x700a468a <Pinmux_unlockMMR+0x6a> @ imm = #0x5e
700a462a: e7ff         	b	0x700a462c <Pinmux_unlockMMR+0xc> @ imm = #-0x2
700a462c: f44f 2070    	mov.w	r0, #0xf0000
700a4630: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_PADCFG_CTRL0_CFG0_BASE);
700a4632: f7ff fb05    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x9f6
700a4636: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK0_KICK0_OFFSET);
700a4638: 9806         	ldr	r0, [sp, #0x18]
700a463a: f241 0108    	movw	r1, #0x1008
700a463e: 4408         	add	r0, r1
700a4640: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a4642: 9805         	ldr	r0, [sp, #0x14]
700a4644: f243 4190    	movw	r1, #0x3490
700a4648: f6c6 01ef    	movt	r1, #0x68ef
700a464c: 9103         	str	r1, [sp, #0xc]
700a464e: f008 ffa7    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x8f4e
;         kickAddr++;
700a4652: 9805         	ldr	r0, [sp, #0x14]
700a4654: 3004         	adds	r0, #0x4
700a4656: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a4658: 9805         	ldr	r0, [sp, #0x14]
700a465a: f64b 415a    	movw	r1, #0xbc5a
700a465e: f2cd 1172    	movt	r1, #0xd172
700a4662: 9104         	str	r1, [sp, #0x10]
700a4664: f008 ff9c    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x8f38
700a4668: 9903         	ldr	r1, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK1_KICK0_OFFSET);
700a466a: 9806         	ldr	r0, [sp, #0x18]
700a466c: f245 0208    	movw	r2, #0x5008
700a4670: 4410         	add	r0, r2
700a4672: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a4674: 9805         	ldr	r0, [sp, #0x14]
700a4676: f008 ff93    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x8f26
700a467a: 9904         	ldr	r1, [sp, #0x10]
;         kickAddr++;
700a467c: 9805         	ldr	r0, [sp, #0x14]
700a467e: 3004         	adds	r0, #0x4
700a4680: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a4682: 9805         	ldr	r0, [sp, #0x14]
700a4684: f008 ff8c    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x8f18
;     }
700a4688: e7ff         	b	0x700a468a <Pinmux_unlockMMR+0x6a> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700a468a: 9807         	ldr	r0, [sp, #0x1c]
700a468c: 2801         	cmp	r0, #0x1
700a468e: d12f         	bne	0x700a46f0 <Pinmux_unlockMMR+0xd0> @ imm = #0x5e
700a4690: e7ff         	b	0x700a4692 <Pinmux_unlockMMR+0x72> @ imm = #-0x2
700a4692: f04f 6081    	mov.w	r0, #0x4080000
700a4696: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700a4698: f7ff fad2    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0xa5c
700a469c: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700a469e: 9806         	ldr	r0, [sp, #0x18]
700a46a0: f241 0108    	movw	r1, #0x1008
700a46a4: 4408         	add	r0, r1
700a46a6: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a46a8: 9805         	ldr	r0, [sp, #0x14]
700a46aa: f243 4190    	movw	r1, #0x3490
700a46ae: f6c6 01ef    	movt	r1, #0x68ef
700a46b2: 9101         	str	r1, [sp, #0x4]
700a46b4: f008 ff74    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x8ee8
;         kickAddr++;
700a46b8: 9805         	ldr	r0, [sp, #0x14]
700a46ba: 3004         	adds	r0, #0x4
700a46bc: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a46be: 9805         	ldr	r0, [sp, #0x14]
700a46c0: f64b 415a    	movw	r1, #0xbc5a
700a46c4: f2cd 1172    	movt	r1, #0xd172
700a46c8: 9102         	str	r1, [sp, #0x8]
700a46ca: f008 ff69    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x8ed2
700a46ce: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700a46d0: 9806         	ldr	r0, [sp, #0x18]
700a46d2: f245 0208    	movw	r2, #0x5008
700a46d6: 4410         	add	r0, r2
700a46d8: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a46da: 9805         	ldr	r0, [sp, #0x14]
700a46dc: f008 ff60    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x8ec0
700a46e0: 9902         	ldr	r1, [sp, #0x8]
;         kickAddr++;
700a46e2: 9805         	ldr	r0, [sp, #0x14]
700a46e4: 3004         	adds	r0, #0x4
700a46e6: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a46e8: 9805         	ldr	r0, [sp, #0x14]
700a46ea: f008 ff59    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x8eb2
;     }
700a46ee: e7ff         	b	0x700a46f0 <Pinmux_unlockMMR+0xd0> @ imm = #-0x2
;     return;
700a46f0: b008         	add	sp, #0x20
700a46f2: bd80         	pop	{r7, pc}
		...

700a4700 <UART_lld_write>:
; {
700a4700: b580         	push	{r7, lr}
700a4702: b086         	sub	sp, #0x18
700a4704: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a4708: 9005         	str	r0, [sp, #0x14]
700a470a: 9104         	str	r1, [sp, #0x10]
700a470c: 9203         	str	r2, [sp, #0xc]
700a470e: 9302         	str	r3, [sp, #0x8]
700a4710: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a4712: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a4714: 9805         	ldr	r0, [sp, #0x14]
700a4716: 2800         	cmp	r0, #0x0
700a4718: d054         	beq	0x700a47c4 <UART_lld_write+0xc4> @ imm = #0xa8
700a471a: e7ff         	b	0x700a471c <UART_lld_write+0x1c> @ imm = #-0x2
;          trans = &hUart->writeTrans;
700a471c: 9805         	ldr	r0, [sp, #0x14]
700a471e: 303c         	adds	r0, #0x3c
700a4720: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a4722: 9800         	ldr	r0, [sp]
700a4724: 6800         	ldr	r0, [r0]
700a4726: b138         	cbz	r0, 0x700a4738 <UART_lld_write+0x38> @ imm = #0xe
700a4728: e7ff         	b	0x700a472a <UART_lld_write+0x2a> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a472a: 9900         	ldr	r1, [sp]
700a472c: 2009         	movs	r0, #0x9
700a472e: 60c8         	str	r0, [r1, #0xc]
700a4730: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a4734: 9001         	str	r0, [sp, #0x4]
;         }
700a4736: e044         	b	0x700a47c2 <UART_lld_write+0xc2> @ imm = #0x88
;             UART_lld_Transaction_init(trans);
700a4738: 9800         	ldr	r0, [sp]
700a473a: f008 f939    	bl	0x700ac9b0 <UART_lld_Transaction_init> @ imm = #0x8272
;             if(extendedParams != NULL)
700a473e: 9808         	ldr	r0, [sp, #0x20]
700a4740: b128         	cbz	r0, 0x700a474e <UART_lld_write+0x4e> @ imm = #0xa
700a4742: e7ff         	b	0x700a4744 <UART_lld_write+0x44> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a4744: 9808         	ldr	r0, [sp, #0x20]
700a4746: 6800         	ldr	r0, [r0]
700a4748: 9900         	ldr	r1, [sp]
700a474a: 6108         	str	r0, [r1, #0x10]
;             }
700a474c: e003         	b	0x700a4756 <UART_lld_write+0x56> @ imm = #0x6
;                 trans->args = NULL;
700a474e: 9900         	ldr	r1, [sp]
700a4750: 2000         	movs	r0, #0x0
700a4752: 6108         	str	r0, [r1, #0x10]
700a4754: e7ff         	b	0x700a4756 <UART_lld_write+0x56> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a4756: 9804         	ldr	r0, [sp, #0x10]
700a4758: 9900         	ldr	r1, [sp]
700a475a: 6008         	str	r0, [r1]
;             trans->count = size;
700a475c: 9803         	ldr	r0, [sp, #0xc]
700a475e: 9900         	ldr	r1, [sp]
700a4760: 6048         	str	r0, [r1, #0x4]
;             trans->timeout = timeout;
700a4762: 9802         	ldr	r0, [sp, #0x8]
700a4764: 9900         	ldr	r1, [sp]
700a4766: 6088         	str	r0, [r1, #0x8]
;             if(hUart->state == UART_STATE_READY)
700a4768: 9805         	ldr	r0, [sp, #0x14]
700a476a: 6d40         	ldr	r0, [r0, #0x54]
700a476c: 2801         	cmp	r0, #0x1
700a476e: d105         	bne	0x700a477c <UART_lld_write+0x7c> @ imm = #0xa
700a4770: e7ff         	b	0x700a4772 <UART_lld_write+0x72> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a4772: 9800         	ldr	r0, [sp]
700a4774: f007 fd64    	bl	0x700ac240 <UART_checkTransaction> @ imm = #0x7ac8
700a4778: 9001         	str	r0, [sp, #0x4]
;             }
700a477a: e003         	b	0x700a4784 <UART_lld_write+0x84> @ imm = #0x6
700a477c: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a4780: 9001         	str	r0, [sp, #0x4]
700a4782: e7ff         	b	0x700a4784 <UART_lld_write+0x84> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a4784: 9801         	ldr	r0, [sp, #0x4]
700a4786: b980         	cbnz	r0, 0x700a47aa <UART_lld_write+0xaa> @ imm = #0x20
700a4788: e7ff         	b	0x700a478a <UART_lld_write+0x8a> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a478a: 9800         	ldr	r0, [sp]
700a478c: 6800         	ldr	r0, [r0]
700a478e: 9905         	ldr	r1, [sp, #0x14]
700a4790: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a4792: 9800         	ldr	r0, [sp]
700a4794: 6880         	ldr	r0, [r0, #0x8]
700a4796: 9905         	ldr	r1, [sp, #0x14]
700a4798: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a479a: 9905         	ldr	r1, [sp, #0x14]
700a479c: 2000         	movs	r0, #0x0
700a479e: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a47a0: 9800         	ldr	r0, [sp]
700a47a2: 6840         	ldr	r0, [r0, #0x4]
700a47a4: 9905         	ldr	r1, [sp, #0x14]
700a47a6: 6108         	str	r0, [r1, #0x10]
;             }
700a47a8: e7ff         	b	0x700a47aa <UART_lld_write+0xaa> @ imm = #-0x2
;             hUart->state = UART_STATE_BUSY;
700a47aa: 9905         	ldr	r1, [sp, #0x14]
700a47ac: 2002         	movs	r0, #0x2
700a47ae: 6548         	str	r0, [r1, #0x54]
;             status = UART_writePolling(hUart, trans);
700a47b0: 9805         	ldr	r0, [sp, #0x14]
700a47b2: 9900         	ldr	r1, [sp]
700a47b4: f7fc fcdc    	bl	0x700a1170 <UART_writePolling> @ imm = #-0x3648
700a47b8: 9001         	str	r0, [sp, #0x4]
;             hUart->state = UART_STATE_READY;
700a47ba: 9905         	ldr	r1, [sp, #0x14]
700a47bc: 2001         	movs	r0, #0x1
700a47be: 6548         	str	r0, [r1, #0x54]
700a47c0: e7ff         	b	0x700a47c2 <UART_lld_write+0xc2> @ imm = #-0x2
;     }
700a47c2: e003         	b	0x700a47cc <UART_lld_write+0xcc> @ imm = #0x6
700a47c4: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a47c8: 9001         	str	r0, [sp, #0x4]
700a47ca: e7ff         	b	0x700a47cc <UART_lld_write+0xcc> @ imm = #-0x2
;     return status;
700a47cc: 9801         	ldr	r0, [sp, #0x4]
700a47ce: b006         	add	sp, #0x18
700a47d0: bd80         	pop	{r7, pc}
		...
700a47de: 0000         	movs	r0, r0

700a47e0 <UART_udmaDeInitCh>:
; {
700a47e0: b580         	push	{r7, lr}
700a47e2: b08c         	sub	sp, #0x30
700a47e4: 900b         	str	r0, [sp, #0x2c]
700a47e6: 910a         	str	r1, [sp, #0x28]
700a47e8: 2000         	movs	r0, #0x0
;     int32_t status = UDMA_SOK;
700a47ea: 9009         	str	r0, [sp, #0x24]
700a47ec: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a47ee: 9008         	str	r0, [sp, #0x20]
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a47f0: 980b         	ldr	r0, [sp, #0x2c]
700a47f2: 2164         	movs	r1, #0x64
700a47f4: f001 fc3c    	bl	0x700a6070 <Udma_chDisable> @ imm = #0x1878
700a47f8: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a47fa: 9809         	ldr	r0, [sp, #0x24]
700a47fc: fab0 f080    	clz	r0, r0
700a4800: 0940         	lsrs	r0, r0, #0x5
700a4802: f64f 0169    	movw	r1, #0xf869
700a4806: f2c7 010a    	movt	r1, #0x700a
700a480a: 9102         	str	r1, [sp, #0x8]
700a480c: 466a         	mov	r2, sp
700a480e: 6011         	str	r1, [r2]
700a4810: f24f 41b9    	movw	r1, #0xf4b9
700a4814: f2c7 010a    	movt	r1, #0x700a
700a4818: 9103         	str	r1, [sp, #0xc]
700a481a: f64f 02c6    	movw	r2, #0xf8c6
700a481e: f2c7 020a    	movt	r2, #0x700a
700a4822: 9204         	str	r2, [sp, #0x10]
700a4824: f240 134b    	movw	r3, #0x14b
700a4828: f004 f9ba    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x4374
;     status = Udma_eventUnRegister(eventHandle);
700a482c: 980a         	ldr	r0, [sp, #0x28]
700a482e: f000 fcbf    	bl	0x700a51b0 <Udma_eventUnRegister> @ imm = #0x97e
700a4832: 9b02         	ldr	r3, [sp, #0x8]
700a4834: 9903         	ldr	r1, [sp, #0xc]
700a4836: 9a04         	ldr	r2, [sp, #0x10]
700a4838: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a483a: 9809         	ldr	r0, [sp, #0x24]
700a483c: fab0 f080    	clz	r0, r0
700a4840: 0940         	lsrs	r0, r0, #0x5
700a4842: 46ec         	mov	r12, sp
700a4844: f8cc 3000    	str.w	r3, [r12]
700a4848: f240 134f    	movw	r3, #0x14f
700a484c: f004 f9a8    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x4350
;     while(temp == TRUE)
700a4850: e7ff         	b	0x700a4852 <UART_udmaDeInitCh+0x72> @ imm = #-0x2
700a4852: 9808         	ldr	r0, [sp, #0x20]
700a4854: 2801         	cmp	r0, #0x1
700a4856: d10f         	bne	0x700a4878 <UART_udmaDeInitCh+0x98> @ imm = #0x1e
700a4858: e7ff         	b	0x700a485a <UART_udmaDeInitCh+0x7a> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a485a: 980b         	ldr	r0, [sp, #0x2c]
700a485c: f004 fb60    	bl	0x700a8f20 <Udma_chGetFqRingHandle> @ imm = #0x46c0
700a4860: a906         	add	r1, sp, #0x18
;         tempRetVal = Udma_ringFlushRaw(
700a4862: f003 fc75    	bl	0x700a8150 <Udma_ringFlushRaw> @ imm = #0x38ea
700a4866: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a4868: 9805         	ldr	r0, [sp, #0x14]
700a486a: 3004         	adds	r0, #0x4
700a486c: b918         	cbnz	r0, 0x700a4876 <UART_udmaDeInitCh+0x96> @ imm = #0x6
700a486e: e7ff         	b	0x700a4870 <UART_udmaDeInitCh+0x90> @ imm = #-0x2
700a4870: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a4872: 9008         	str	r0, [sp, #0x20]
;         }
700a4874: e7ff         	b	0x700a4876 <UART_udmaDeInitCh+0x96> @ imm = #-0x2
;     while(temp == TRUE)
700a4876: e7ec         	b	0x700a4852 <UART_udmaDeInitCh+0x72> @ imm = #-0x28
;     status = Udma_chClose(chHandle);
700a4878: 980b         	ldr	r0, [sp, #0x2c]
700a487a: f000 fdd1    	bl	0x700a5420 <Udma_chClose> @ imm = #0xba2
700a487e: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a4880: 9809         	ldr	r0, [sp, #0x24]
700a4882: fab0 f080    	clz	r0, r0
700a4886: 0940         	lsrs	r0, r0, #0x5
700a4888: f64f 0169    	movw	r1, #0xf869
700a488c: f2c7 010a    	movt	r1, #0x700a
700a4890: 466a         	mov	r2, sp
700a4892: 6011         	str	r1, [r2]
700a4894: f24f 41b9    	movw	r1, #0xf4b9
700a4898: f2c7 010a    	movt	r1, #0x700a
700a489c: f64f 02c6    	movw	r2, #0xf8c6
700a48a0: f2c7 020a    	movt	r2, #0x700a
700a48a4: f240 1361    	movw	r3, #0x161
700a48a8: f004 f97a    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x42f4
;     return status;
700a48ac: 9809         	ldr	r0, [sp, #0x24]
700a48ae: b00c         	add	sp, #0x30
700a48b0: bd80         	pop	{r7, pc}
		...
700a48be: 0000         	movs	r0, r0

700a48c0 <Udma_rmAllocVintrBit>:
; {
700a48c0: b580         	push	{r7, lr}
700a48c2: b08a         	sub	sp, #0x28
700a48c4: 9009         	str	r0, [sp, #0x24]
700a48c6: f64f 70ff    	movw	r0, #0xffff
;     uint32_t                vintrBitNum = UDMA_EVENT_INVALID;
700a48ca: 9007         	str	r0, [sp, #0x1c]
;     Udma_DrvHandleInt       drvHandle = eventHandle->drvHandle;
700a48cc: 9809         	ldr	r0, [sp, #0x24]
700a48ce: 6800         	ldr	r0, [r0]
700a48d0: 9001         	str	r0, [sp, #0x4]
;     controllerEventHandle = eventHandle;
700a48d2: 9809         	ldr	r0, [sp, #0x24]
700a48d4: 9003         	str	r0, [sp, #0xc]
;     eventPrms = &eventHandle->eventPrms;
700a48d6: 9809         	ldr	r0, [sp, #0x24]
700a48d8: 3008         	adds	r0, #0x8
700a48da: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700a48dc: 9802         	ldr	r0, [sp, #0x8]
700a48de: 6900         	ldr	r0, [r0, #0x10]
700a48e0: b120         	cbz	r0, 0x700a48ec <Udma_rmAllocVintrBit+0x2c> @ imm = #0x8
700a48e2: e7ff         	b	0x700a48e4 <Udma_rmAllocVintrBit+0x24> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a48e4: 9802         	ldr	r0, [sp, #0x8]
700a48e6: 6900         	ldr	r0, [r0, #0x10]
700a48e8: 9003         	str	r0, [sp, #0xc]
;     }
700a48ea: e7ff         	b	0x700a48ec <Udma_rmAllocVintrBit+0x2c> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a48ec: 9801         	ldr	r0, [sp, #0x4]
700a48ee: f500 609f    	add.w	r0, r0, #0x4f8
700a48f2: f04f 31ff    	mov.w	r1, #0xffffffff
700a48f6: f003 fefb    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x3df6
700a48fa: 2000         	movs	r0, #0x0
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a48fc: 9008         	str	r0, [sp, #0x20]
700a48fe: e7ff         	b	0x700a4900 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x2
700a4900: 9808         	ldr	r0, [sp, #0x20]
700a4902: 283f         	cmp	r0, #0x3f
700a4904: d83a         	bhi	0x700a497c <Udma_rmAllocVintrBit+0xbc> @ imm = #0x74
700a4906: e7ff         	b	0x700a4908 <Udma_rmAllocVintrBit+0x48> @ imm = #-0x2
;         bitMask = ((uint64_t) 1U << i);
700a4908: 9b08         	ldr	r3, [sp, #0x20]
700a490a: f1a3 0220    	sub.w	r2, r3, #0x20
700a490e: 2101         	movs	r1, #0x1
700a4910: fa01 fc02    	lsl.w	r12, r1, r2
700a4914: f1c3 0020    	rsb.w	r0, r3, #0x20
700a4918: fa21 f000    	lsr.w	r0, r1, r0
700a491c: 2a00         	cmp	r2, #0x0
700a491e: bf58         	it	pl
700a4920: 4660         	movpl	r0, r12
700a4922: fa01 f103    	lsl.w	r1, r1, r3
700a4926: 2a00         	cmp	r2, #0x0
700a4928: bf58         	it	pl
700a492a: 2100         	movpl	r1, #0x0
700a492c: 9104         	str	r1, [sp, #0x10]
700a492e: 9005         	str	r0, [sp, #0x14]
;         if((controllerEventHandle->vintrBitAllocFlag & bitMask) == 0U)
700a4930: 9903         	ldr	r1, [sp, #0xc]
700a4932: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a4936: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a493a: 9a04         	ldr	r2, [sp, #0x10]
700a493c: 9b05         	ldr	r3, [sp, #0x14]
700a493e: ea01 0103    	and.w	r1, r1, r3
700a4942: ea00 0002    	and.w	r0, r0, r2
700a4946: ea40 0001    	orr.w	r0, r0, r1
700a494a: b990         	cbnz	r0, 0x700a4972 <Udma_rmAllocVintrBit+0xb2> @ imm = #0x24
700a494c: e7ff         	b	0x700a494e <Udma_rmAllocVintrBit+0x8e> @ imm = #-0x2
;             controllerEventHandle->vintrBitAllocFlag |= bitMask;
700a494e: f8dd c010    	ldr.w	r12, [sp, #0x10]
700a4952: 9b05         	ldr	r3, [sp, #0x14]
700a4954: 9903         	ldr	r1, [sp, #0xc]
700a4956: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a495a: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700a495e: ea40 000c    	orr.w	r0, r0, r12
700a4962: 431a         	orrs	r2, r3
700a4964: f8c1 208c    	str.w	r2, [r1, #0x8c]
700a4968: f8c1 0088    	str.w	r0, [r1, #0x88]
;             vintrBitNum = i;
700a496c: 9808         	ldr	r0, [sp, #0x20]
700a496e: 9007         	str	r0, [sp, #0x1c]
;             break;
700a4970: e004         	b	0x700a497c <Udma_rmAllocVintrBit+0xbc> @ imm = #0x8
;     }
700a4972: e7ff         	b	0x700a4974 <Udma_rmAllocVintrBit+0xb4> @ imm = #-0x2
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a4974: 9808         	ldr	r0, [sp, #0x20]
700a4976: 3001         	adds	r0, #0x1
700a4978: 9008         	str	r0, [sp, #0x20]
700a497a: e7c1         	b	0x700a4900 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x7e
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a497c: 9801         	ldr	r0, [sp, #0x4]
700a497e: f500 609f    	add.w	r0, r0, #0x4f8
700a4982: f005 fa05    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x540a
;     return (vintrBitNum);
700a4986: 9807         	ldr	r0, [sp, #0x1c]
700a4988: b00a         	add	sp, #0x28
700a498a: bd80         	pop	{r7, pc}
700a498c: 0000         	movs	r0, r0
700a498e: 0000         	movs	r0, r0

700a4990 <prvCopyDataToQueue>:
; {
700a4990: b580         	push	{r7, lr}
700a4992: b086         	sub	sp, #0x18
700a4994: 9005         	str	r0, [sp, #0x14]
700a4996: 9104         	str	r1, [sp, #0x10]
700a4998: 9203         	str	r2, [sp, #0xc]
700a499a: 2000         	movs	r0, #0x0
;     BaseType_t xReturn = pdFALSE;
700a499c: 9002         	str	r0, [sp, #0x8]
;     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a499e: 9805         	ldr	r0, [sp, #0x14]
700a49a0: 6b80         	ldr	r0, [r0, #0x38]
700a49a2: 9001         	str	r0, [sp, #0x4]
;     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
700a49a4: 9805         	ldr	r0, [sp, #0x14]
700a49a6: 6c00         	ldr	r0, [r0, #0x40]
700a49a8: b978         	cbnz	r0, 0x700a49ca <prvCopyDataToQueue+0x3a> @ imm = #0x1e
700a49aa: e7ff         	b	0x700a49ac <prvCopyDataToQueue+0x1c> @ imm = #-0x2
;                 if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a49ac: 9805         	ldr	r0, [sp, #0x14]
700a49ae: 6800         	ldr	r0, [r0]
700a49b0: b948         	cbnz	r0, 0x700a49c6 <prvCopyDataToQueue+0x36> @ imm = #0x12
700a49b2: e7ff         	b	0x700a49b4 <prvCopyDataToQueue+0x24> @ imm = #-0x2
;                     xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
700a49b4: 9805         	ldr	r0, [sp, #0x14]
700a49b6: 6880         	ldr	r0, [r0, #0x8]
700a49b8: f000 ffda    	bl	0x700a5970 <xTaskPriorityDisinherit> @ imm = #0xfb4
700a49bc: 9002         	str	r0, [sp, #0x8]
;                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
700a49be: 9905         	ldr	r1, [sp, #0x14]
700a49c0: 2000         	movs	r0, #0x0
700a49c2: 6088         	str	r0, [r1, #0x8]
;                 }
700a49c4: e000         	b	0x700a49c8 <prvCopyDataToQueue+0x38> @ imm = #0x0
700a49c6: e7ff         	b	0x700a49c8 <prvCopyDataToQueue+0x38> @ imm = #-0x2
;     }
700a49c8: e041         	b	0x700a4a4e <prvCopyDataToQueue+0xbe> @ imm = #0x82
;     else if( xPosition == queueSEND_TO_BACK )
700a49ca: 9803         	ldr	r0, [sp, #0xc]
700a49cc: b9b8         	cbnz	r0, 0x700a49fe <prvCopyDataToQueue+0x6e> @ imm = #0x2e
700a49ce: e7ff         	b	0x700a49d0 <prvCopyDataToQueue+0x40> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700a49d0: 9a05         	ldr	r2, [sp, #0x14]
700a49d2: 9904         	ldr	r1, [sp, #0x10]
700a49d4: 6850         	ldr	r0, [r2, #0x4]
700a49d6: 6c12         	ldr	r2, [r2, #0x40]
700a49d8: f7f6 e800    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0xa000
;         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700a49dc: 9905         	ldr	r1, [sp, #0x14]
700a49de: 6848         	ldr	r0, [r1, #0x4]
700a49e0: 6c0a         	ldr	r2, [r1, #0x40]
700a49e2: 4410         	add	r0, r2
700a49e4: 6048         	str	r0, [r1, #0x4]
;         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a49e6: 9905         	ldr	r1, [sp, #0x14]
700a49e8: 6848         	ldr	r0, [r1, #0x4]
700a49ea: 6889         	ldr	r1, [r1, #0x8]
700a49ec: 4288         	cmp	r0, r1
700a49ee: d304         	blo	0x700a49fa <prvCopyDataToQueue+0x6a> @ imm = #0x8
700a49f0: e7ff         	b	0x700a49f2 <prvCopyDataToQueue+0x62> @ imm = #-0x2
;             pxQueue->pcWriteTo = pxQueue->pcHead;
700a49f2: 9905         	ldr	r1, [sp, #0x14]
700a49f4: 6808         	ldr	r0, [r1]
700a49f6: 6048         	str	r0, [r1, #0x4]
;         }
700a49f8: e000         	b	0x700a49fc <prvCopyDataToQueue+0x6c> @ imm = #0x0
700a49fa: e7ff         	b	0x700a49fc <prvCopyDataToQueue+0x6c> @ imm = #-0x2
;     }
700a49fc: e026         	b	0x700a4a4c <prvCopyDataToQueue+0xbc> @ imm = #0x4c
;         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
700a49fe: 9a05         	ldr	r2, [sp, #0x14]
700a4a00: 9904         	ldr	r1, [sp, #0x10]
700a4a02: 68d0         	ldr	r0, [r2, #0xc]
700a4a04: 6c12         	ldr	r2, [r2, #0x40]
700a4a06: f7f5 efea    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0xa02c
;         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
700a4a0a: 9905         	ldr	r1, [sp, #0x14]
700a4a0c: 68c8         	ldr	r0, [r1, #0xc]
700a4a0e: 6c0a         	ldr	r2, [r1, #0x40]
700a4a10: 1a80         	subs	r0, r0, r2
700a4a12: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a4a14: 9805         	ldr	r0, [sp, #0x14]
700a4a16: 6801         	ldr	r1, [r0]
700a4a18: 68c0         	ldr	r0, [r0, #0xc]
700a4a1a: 4288         	cmp	r0, r1
700a4a1c: d206         	bhs	0x700a4a2c <prvCopyDataToQueue+0x9c> @ imm = #0xc
700a4a1e: e7ff         	b	0x700a4a20 <prvCopyDataToQueue+0x90> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
700a4a20: 9905         	ldr	r1, [sp, #0x14]
700a4a22: 6888         	ldr	r0, [r1, #0x8]
700a4a24: 6c0a         	ldr	r2, [r1, #0x40]
700a4a26: 1a80         	subs	r0, r0, r2
700a4a28: 60c8         	str	r0, [r1, #0xc]
;         }
700a4a2a: e000         	b	0x700a4a2e <prvCopyDataToQueue+0x9e> @ imm = #0x0
700a4a2c: e7ff         	b	0x700a4a2e <prvCopyDataToQueue+0x9e> @ imm = #-0x2
;         if( xPosition == queueOVERWRITE )
700a4a2e: 9803         	ldr	r0, [sp, #0xc]
700a4a30: 2802         	cmp	r0, #0x2
700a4a32: d109         	bne	0x700a4a48 <prvCopyDataToQueue+0xb8> @ imm = #0x12
700a4a34: e7ff         	b	0x700a4a36 <prvCopyDataToQueue+0xa6> @ imm = #-0x2
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a4a36: 9801         	ldr	r0, [sp, #0x4]
700a4a38: b120         	cbz	r0, 0x700a4a44 <prvCopyDataToQueue+0xb4> @ imm = #0x8
700a4a3a: e7ff         	b	0x700a4a3c <prvCopyDataToQueue+0xac> @ imm = #-0x2
;                 --uxMessagesWaiting;
700a4a3c: 9801         	ldr	r0, [sp, #0x4]
700a4a3e: 3801         	subs	r0, #0x1
700a4a40: 9001         	str	r0, [sp, #0x4]
;             }
700a4a42: e000         	b	0x700a4a46 <prvCopyDataToQueue+0xb6> @ imm = #0x0
700a4a44: e7ff         	b	0x700a4a46 <prvCopyDataToQueue+0xb6> @ imm = #-0x2
;         }
700a4a46: e000         	b	0x700a4a4a <prvCopyDataToQueue+0xba> @ imm = #0x0
700a4a48: e7ff         	b	0x700a4a4a <prvCopyDataToQueue+0xba> @ imm = #-0x2
700a4a4a: e7ff         	b	0x700a4a4c <prvCopyDataToQueue+0xbc> @ imm = #-0x2
700a4a4c: e7ff         	b	0x700a4a4e <prvCopyDataToQueue+0xbe> @ imm = #-0x2
;     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a4a4e: 9801         	ldr	r0, [sp, #0x4]
700a4a50: 3001         	adds	r0, #0x1
700a4a52: 9905         	ldr	r1, [sp, #0x14]
700a4a54: 6388         	str	r0, [r1, #0x38]
;     return xReturn;
700a4a56: 9802         	ldr	r0, [sp, #0x8]
700a4a58: b006         	add	sp, #0x18
700a4a5a: bd80         	pop	{r7, pc}
700a4a5c: 0000         	movs	r0, r0
700a4a5e: 0000         	movs	r0, r0

700a4a60 <rtos_main_freertos>:
700a4a60: b082         	sub	sp, #0x8
700a4a62: f001 f9fd    	bl	0x700a5e60 <System_init> @ imm = #0x13fa
700a4a66: f240 014c    	movw	r1, #0x4c
700a4a6a: f644 75cc    	movw	r5, #0x4fcc
700a4a6e: f2c7 010b    	movt	r1, #0x700b
700a4a72: 2400         	movs	r4, #0x0
700a4a74: f2c7 0508    	movt	r5, #0x7008
700a4a78: 2000         	movs	r0, #0x0
700a4a7a: 602c         	str	r4, [r5]
700a4a7c: f7f5 ffb0    	bl	0x7009a9e0 <UART_open>  @ imm = #-0xa0a0
700a4a80: 6028         	str	r0, [r5]
700a4a82: b990         	cbnz	r0, 0x700a4aaa <rtos_main_freertos+0x4a> @ imm = #0x24
700a4a84: f24f 319a    	movw	r1, #0xf39a
700a4a88: f64f 02fc    	movw	r2, #0xf8fc
700a4a8c: f2c7 010a    	movt	r1, #0x700a
700a4a90: f2c7 020a    	movt	r2, #0x700a
700a4a94: 2002         	movs	r0, #0x2
700a4a96: 236e         	movs	r3, #0x6e
700a4a98: 9400         	str	r4, [sp]
700a4a9a: f003 f8c1    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #0x3182
700a4a9e: 6828         	ldr	r0, [r5]
700a4aa0: b118         	cbz	r0, 0x700a4aaa <rtos_main_freertos+0x4a> @ imm = #0x6
700a4aa2: f7f9 faed    	bl	0x7009e080 <UART_close> @ imm = #-0x6a26
700a4aa6: 2000         	movs	r0, #0x0
700a4aa8: 6028         	str	r0, [r5]
700a4aaa: f24f 5127    	movw	r1, #0xf527
700a4aae: 2001         	movs	r0, #0x1
700a4ab0: f2c7 010a    	movt	r1, #0x700a
700a4ab4: f003 f8b4    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #0x3168
700a4ab8: f249 4061    	movw	r0, #0x9461
700a4abc: f64f 11ac    	movw	r1, #0xf9ac
700a4ac0: f2c7 000a    	movt	r0, #0x700a
700a4ac4: f2c7 010a    	movt	r1, #0x700a
700a4ac8: 251e         	movs	r5, #0x1e
700a4aca: f44f 5200    	mov.w	r2, #0x2000
700a4ace: 2300         	movs	r3, #0x0
700a4ad0: e9cd 5400    	strd	r5, r4, [sp]
700a4ad4: f002 fc44    	bl	0x700a7360 <xTaskCreate> @ imm = #0x2888
700a4ad8: 2801         	cmp	r0, #0x1
700a4ada: d010         	beq	0x700a4afe <rtos_main_freertos+0x9e> @ imm = #0x20
700a4adc: f24f 71ec    	movw	r1, #0xf7ec
700a4ae0: f64f 028f    	movw	r2, #0xf88f
700a4ae4: f64f 150d    	movw	r5, #0xf90d
700a4ae8: f2c7 010a    	movt	r1, #0x700a
700a4aec: f2c7 020a    	movt	r2, #0x700a
700a4af0: f2c7 050a    	movt	r5, #0x700a
700a4af4: 2000         	movs	r0, #0x0
700a4af6: 2381         	movs	r3, #0x81
700a4af8: 9500         	str	r5, [sp]
700a4afa: f004 f851    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x40a2
700a4afe: f000 fdb7    	bl	0x700a5670 <vTaskStartScheduler> @ imm = #0xb6e
700a4b02: f24f 5449    	movw	r4, #0xf549
700a4b06: f2c7 040a    	movt	r4, #0x700a
700a4b0a: bf00         	nop
700a4b0c: bf00         	nop
700a4b0e: bf00         	nop
700a4b10: 4621         	mov	r1, r4
700a4b12: f04f 0001    	mov.w	r0, #0x1
700a4b16: f003 f883    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #0x3106
700a4b1a: 4621         	mov	r1, r4
700a4b1c: 2001         	movs	r0, #0x1
700a4b1e: f003 f87f    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #0x30fe
700a4b22: 4621         	mov	r1, r4
700a4b24: 2001         	movs	r0, #0x1
700a4b26: f003 f87b    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #0x30f6
700a4b2a: e7f1         	b	0x700a4b10 <rtos_main_freertos+0xb0> @ imm = #-0x1e
700a4b2c: 0000         	movs	r0, r0
700a4b2e: 0000         	movs	r0, r0

700a4b30 <CSL_bcdmaChanOpSetBurstSize>:
; {
700a4b30: b580         	push	{r7, lr}
700a4b32: b088         	sub	sp, #0x20
700a4b34: 9007         	str	r0, [sp, #0x1c]
700a4b36: 9106         	str	r1, [sp, #0x18]
700a4b38: 9205         	str	r2, [sp, #0x14]
700a4b3a: 9304         	str	r3, [sp, #0x10]
700a4b3c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a4b3e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a4b40: 9804         	ldr	r0, [sp, #0x10]
700a4b42: b920         	cbnz	r0, 0x700a4b4e <CSL_bcdmaChanOpSetBurstSize+0x1e> @ imm = #0x8
700a4b44: e7ff         	b	0x700a4b46 <CSL_bcdmaChanOpSetBurstSize+0x16> @ imm = #-0x2
700a4b46: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a4b4a: 9003         	str	r0, [sp, #0xc]
;     }
700a4b4c: e052         	b	0x700a4bf4 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #0xa4
;         CSL_BcdmaChanBurstSize burstSize = *(CSL_BcdmaChanBurstSize *)pOpData;
700a4b4e: 9804         	ldr	r0, [sp, #0x10]
700a4b50: 6800         	ldr	r0, [r0]
700a4b52: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a4b54: 9806         	ldr	r0, [sp, #0x18]
700a4b56: 9001         	str	r0, [sp, #0x4]
700a4b58: b140         	cbz	r0, 0x700a4b6c <CSL_bcdmaChanOpSetBurstSize+0x3c> @ imm = #0x10
700a4b5a: e7ff         	b	0x700a4b5c <CSL_bcdmaChanOpSetBurstSize+0x2c> @ imm = #-0x2
700a4b5c: 9801         	ldr	r0, [sp, #0x4]
700a4b5e: 2801         	cmp	r0, #0x1
700a4b60: d019         	beq	0x700a4b96 <CSL_bcdmaChanOpSetBurstSize+0x66> @ imm = #0x32
700a4b62: e7ff         	b	0x700a4b64 <CSL_bcdmaChanOpSetBurstSize+0x34> @ imm = #-0x2
700a4b64: 9801         	ldr	r0, [sp, #0x4]
700a4b66: 2802         	cmp	r0, #0x2
700a4b68: d02a         	beq	0x700a4bc0 <CSL_bcdmaChanOpSetBurstSize+0x90> @ imm = #0x54
700a4b6a: e03e         	b	0x700a4bea <CSL_bcdmaChanOpSetBurstSize+0xba> @ imm = #0x7c
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES )   /* Block-copy supports 32, 64, and 128-byte bursts */
700a4b6c: 9802         	ldr	r0, [sp, #0x8]
700a4b6e: 2803         	cmp	r0, #0x3
700a4b70: d304         	blo	0x700a4b7c <CSL_bcdmaChanOpSetBurstSize+0x4c> @ imm = #0x8
700a4b72: e7ff         	b	0x700a4b74 <CSL_bcdmaChanOpSetBurstSize+0x44> @ imm = #-0x2
700a4b74: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a4b78: 9003         	str	r0, [sp, #0xc]
;                 }
700a4b7a: e00b         	b	0x700a4b94 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, burstSize );
700a4b7c: 9807         	ldr	r0, [sp, #0x1c]
700a4b7e: 6840         	ldr	r0, [r0, #0x4]
700a4b80: 9905         	ldr	r1, [sp, #0x14]
700a4b82: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a4b86: 9b02         	ldr	r3, [sp, #0x8]
700a4b88: f44f 6140    	mov.w	r1, #0xc00
700a4b8c: 220a         	movs	r2, #0xa
700a4b8e: f007 f9f7    	bl	0x700abf80 <CSL_REG32_FINS_RAW> @ imm = #0x73ee
700a4b92: e7ff         	b	0x700a4b94 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #-0x2
;                 break;
700a4b94: e02d         	b	0x700a4bf2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x5a
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-tx supports 32, and 64-byte bursts */
700a4b96: 9802         	ldr	r0, [sp, #0x8]
700a4b98: 2802         	cmp	r0, #0x2
700a4b9a: d304         	blo	0x700a4ba6 <CSL_bcdmaChanOpSetBurstSize+0x76> @ imm = #0x8
700a4b9c: e7ff         	b	0x700a4b9e <CSL_bcdmaChanOpSetBurstSize+0x6e> @ imm = #-0x2
700a4b9e: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a4ba2: 9003         	str	r0, [sp, #0xc]
;                 }
700a4ba4: e00b         	b	0x700a4bbe <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, burstSize );
700a4ba6: 9807         	ldr	r0, [sp, #0x1c]
700a4ba8: 68c0         	ldr	r0, [r0, #0xc]
700a4baa: 9905         	ldr	r1, [sp, #0x14]
700a4bac: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a4bb0: 9b02         	ldr	r3, [sp, #0x8]
700a4bb2: f44f 6140    	mov.w	r1, #0xc00
700a4bb6: 220a         	movs	r2, #0xa
700a4bb8: f007 f9e2    	bl	0x700abf80 <CSL_REG32_FINS_RAW> @ imm = #0x73c4
700a4bbc: e7ff         	b	0x700a4bbe <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #-0x2
;                 break;
700a4bbe: e018         	b	0x700a4bf2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x30
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-rx supports 32, and 64-byte bursts */
700a4bc0: 9802         	ldr	r0, [sp, #0x8]
700a4bc2: 2802         	cmp	r0, #0x2
700a4bc4: d304         	blo	0x700a4bd0 <CSL_bcdmaChanOpSetBurstSize+0xa0> @ imm = #0x8
700a4bc6: e7ff         	b	0x700a4bc8 <CSL_bcdmaChanOpSetBurstSize+0x98> @ imm = #-0x2
700a4bc8: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a4bcc: 9003         	str	r0, [sp, #0xc]
;                 }
700a4bce: e00b         	b	0x700a4be8 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, burstSize );
700a4bd0: 9807         	ldr	r0, [sp, #0x1c]
700a4bd2: 6940         	ldr	r0, [r0, #0x14]
700a4bd4: 9905         	ldr	r1, [sp, #0x14]
700a4bd6: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a4bda: 9b02         	ldr	r3, [sp, #0x8]
700a4bdc: f44f 6140    	mov.w	r1, #0xc00
700a4be0: 220a         	movs	r2, #0xa
700a4be2: f007 f9cd    	bl	0x700abf80 <CSL_REG32_FINS_RAW> @ imm = #0x739a
700a4be6: e7ff         	b	0x700a4be8 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #-0x2
;                 break;
700a4be8: e003         	b	0x700a4bf2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x6
700a4bea: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a4bee: 9003         	str	r0, [sp, #0xc]
;                 break;
700a4bf0: e7ff         	b	0x700a4bf2 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #-0x2
700a4bf2: e7ff         	b	0x700a4bf4 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #-0x2
;     return retVal;
700a4bf4: 9803         	ldr	r0, [sp, #0xc]
700a4bf6: b008         	add	sp, #0x20
700a4bf8: bd80         	pop	{r7, pc}
700a4bfa: 0000         	movs	r0, r0
700a4bfc: 0000         	movs	r0, r0
700a4bfe: 0000         	movs	r0, r0

700a4c00 <Udma_ringCheckParams>:
; {
700a4c00: b580         	push	{r7, lr}
700a4c02: b084         	sub	sp, #0x10
700a4c04: 9003         	str	r0, [sp, #0xc]
700a4c06: 9102         	str	r1, [sp, #0x8]
700a4c08: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a4c0a: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR == ringPrms->ringMem)
700a4c0c: 9802         	ldr	r0, [sp, #0x8]
700a4c0e: 6800         	ldr	r0, [r0]
700a4c10: b920         	cbnz	r0, 0x700a4c1c <Udma_ringCheckParams+0x1c> @ imm = #0x8
700a4c12: e7ff         	b	0x700a4c14 <Udma_ringCheckParams+0x14> @ imm = #-0x2
700a4c14: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a4c18: 9001         	str	r0, [sp, #0x4]
;     }
700a4c1a: e009         	b	0x700a4c30 <Udma_ringCheckParams+0x30> @ imm = #0x12
;         if(((uintptr_t)ringPrms->ringMem & (UDMA_CACHELINE_ALIGNMENT - 1U)) != 0U)
700a4c1c: 9802         	ldr	r0, [sp, #0x8]
700a4c1e: 7800         	ldrb	r0, [r0]
700a4c20: 0640         	lsls	r0, r0, #0x19
700a4c22: b120         	cbz	r0, 0x700a4c2e <Udma_ringCheckParams+0x2e> @ imm = #0x8
700a4c24: e7ff         	b	0x700a4c26 <Udma_ringCheckParams+0x26> @ imm = #-0x2
700a4c26: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a4c2a: 9001         	str	r0, [sp, #0x4]
;         }
700a4c2c: e7ff         	b	0x700a4c2e <Udma_ringCheckParams+0x2e> @ imm = #-0x2
700a4c2e: e7ff         	b	0x700a4c30 <Udma_ringCheckParams+0x30> @ imm = #-0x2
;     if(0U == ringPrms->elemCnt)
700a4c30: 9802         	ldr	r0, [sp, #0x8]
700a4c32: 68c0         	ldr	r0, [r0, #0xc]
700a4c34: b920         	cbnz	r0, 0x700a4c40 <Udma_ringCheckParams+0x40> @ imm = #0x8
700a4c36: e7ff         	b	0x700a4c38 <Udma_ringCheckParams+0x38> @ imm = #-0x2
700a4c38: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a4c3c: 9001         	str	r0, [sp, #0x4]
;     }
700a4c3e: e7ff         	b	0x700a4c40 <Udma_ringCheckParams+0x40> @ imm = #-0x2
;     if(UDMA_INST_TYPE_NORMAL != drvHandle->instType)
700a4c40: 9803         	ldr	r0, [sp, #0xc]
700a4c42: 6800         	ldr	r0, [r0]
700a4c44: b148         	cbz	r0, 0x700a4c5a <Udma_ringCheckParams+0x5a> @ imm = #0x12
700a4c46: e7ff         	b	0x700a4c48 <Udma_ringCheckParams+0x48> @ imm = #-0x2
;         if(TISCI_MSG_VALUE_RM_RING_MODE_RING != ringPrms->mode)
700a4c48: 9802         	ldr	r0, [sp, #0x8]
700a4c4a: 7a00         	ldrb	r0, [r0, #0x8]
700a4c4c: b120         	cbz	r0, 0x700a4c58 <Udma_ringCheckParams+0x58> @ imm = #0x8
700a4c4e: e7ff         	b	0x700a4c50 <Udma_ringCheckParams+0x50> @ imm = #-0x2
700a4c50: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a4c54: 9001         	str	r0, [sp, #0x4]
;         }
700a4c56: e7ff         	b	0x700a4c58 <Udma_ringCheckParams+0x58> @ imm = #-0x2
;     }
700a4c58: e7ff         	b	0x700a4c5a <Udma_ringCheckParams+0x5a> @ imm = #-0x2
;     if(UDMA_RING_SIZE_CHECK_SKIP != ringPrms->ringMemSize)
700a4c5a: 9802         	ldr	r0, [sp, #0x8]
700a4c5c: 6840         	ldr	r0, [r0, #0x4]
700a4c5e: f64a 31cd    	movw	r1, #0xabcd
700a4c62: f6ca 31dc    	movt	r1, #0xabdc
700a4c66: 4288         	cmp	r0, r1
700a4c68: d012         	beq	0x700a4c90 <Udma_ringCheckParams+0x90> @ imm = #0x24
700a4c6a: e7ff         	b	0x700a4c6c <Udma_ringCheckParams+0x6c> @ imm = #-0x2
;                           ringPrms->mode,
700a4c6c: 9a02         	ldr	r2, [sp, #0x8]
700a4c6e: 7a10         	ldrb	r0, [r2, #0x8]
;                           ringPrms->elemCnt,
700a4c70: 68d1         	ldr	r1, [r2, #0xc]
;                           ringPrms->elemSize);
700a4c72: 7c12         	ldrb	r2, [r2, #0x10]
;         ringMemSize = UdmaUtils_getRingMemSize(
700a4c74: f006 fdf4    	bl	0x700ab860 <UdmaUtils_getRingMemSize> @ imm = #0x6be8
700a4c78: 9000         	str	r0, [sp]
;         if(ringPrms->ringMemSize < ringMemSize)
700a4c7a: 9802         	ldr	r0, [sp, #0x8]
700a4c7c: 6840         	ldr	r0, [r0, #0x4]
700a4c7e: 9900         	ldr	r1, [sp]
700a4c80: 4288         	cmp	r0, r1
700a4c82: d204         	bhs	0x700a4c8e <Udma_ringCheckParams+0x8e> @ imm = #0x8
700a4c84: e7ff         	b	0x700a4c86 <Udma_ringCheckParams+0x86> @ imm = #-0x2
700a4c86: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
700a4c8a: 9001         	str	r0, [sp, #0x4]
;         }
700a4c8c: e7ff         	b	0x700a4c8e <Udma_ringCheckParams+0x8e> @ imm = #-0x2
;     }
700a4c8e: e7ff         	b	0x700a4c90 <Udma_ringCheckParams+0x90> @ imm = #-0x2
;     if (UDMA_RING_ORDERID_MAX < ringPrms->orderId)
700a4c90: 9802         	ldr	r0, [sp, #0x8]
700a4c92: 7c40         	ldrb	r0, [r0, #0x11]
700a4c94: 2810         	cmp	r0, #0x10
700a4c96: d304         	blo	0x700a4ca2 <Udma_ringCheckParams+0xa2> @ imm = #0x8
700a4c98: e7ff         	b	0x700a4c9a <Udma_ringCheckParams+0x9a> @ imm = #-0x2
700a4c9a: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a4c9e: 9001         	str	r0, [sp, #0x4]
;     }
700a4ca0: e7ff         	b	0x700a4ca2 <Udma_ringCheckParams+0xa2> @ imm = #-0x2
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a4ca2: 9802         	ldr	r0, [sp, #0x8]
700a4ca4: 6940         	ldr	r0, [r0, #0x14]
700a4ca6: 2104         	movs	r1, #0x4
700a4ca8: f6cf 71ff    	movt	r1, #0xffff
700a4cac: 4288         	cmp	r0, r1
700a4cae: d009         	beq	0x700a4cc4 <Udma_ringCheckParams+0xc4> @ imm = #0x12
700a4cb0: e7ff         	b	0x700a4cb2 <Udma_ringCheckParams+0xb2> @ imm = #-0x2
;        (ringPrms->mappedRingGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a4cb2: 9802         	ldr	r0, [sp, #0x8]
700a4cb4: 6940         	ldr	r0, [r0, #0x14]
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a4cb6: 2808         	cmp	r0, #0x8
700a4cb8: d304         	blo	0x700a4cc4 <Udma_ringCheckParams+0xc4> @ imm = #0x8
700a4cba: e7ff         	b	0x700a4cbc <Udma_ringCheckParams+0xbc> @ imm = #-0x2
700a4cbc: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a4cc0: 9001         	str	r0, [sp, #0x4]
;     }
700a4cc2: e7ff         	b	0x700a4cc4 <Udma_ringCheckParams+0xc4> @ imm = #-0x2
;     return (retVal);
700a4cc4: 9801         	ldr	r0, [sp, #0x4]
700a4cc6: b004         	add	sp, #0x10
700a4cc8: bd80         	pop	{r7, pc}
700a4cca: 0000         	movs	r0, r0
700a4ccc: 0000         	movs	r0, r0
700a4cce: 0000         	movs	r0, r0

700a4cd0 <UART_lld_writeDma>:
; {
700a4cd0: b580         	push	{r7, lr}
700a4cd2: b086         	sub	sp, #0x18
700a4cd4: 9005         	str	r0, [sp, #0x14]
700a4cd6: 9104         	str	r1, [sp, #0x10]
700a4cd8: 9203         	str	r2, [sp, #0xc]
700a4cda: 9302         	str	r3, [sp, #0x8]
700a4cdc: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a4cde: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a4ce0: 9805         	ldr	r0, [sp, #0x14]
700a4ce2: 2800         	cmp	r0, #0x0
700a4ce4: d051         	beq	0x700a4d8a <UART_lld_writeDma+0xba> @ imm = #0xa2
700a4ce6: e7ff         	b	0x700a4ce8 <UART_lld_writeDma+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a4ce8: 9805         	ldr	r0, [sp, #0x14]
700a4cea: 303c         	adds	r0, #0x3c
700a4cec: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a4cee: 9800         	ldr	r0, [sp]
700a4cf0: 6800         	ldr	r0, [r0]
700a4cf2: b138         	cbz	r0, 0x700a4d04 <UART_lld_writeDma+0x34> @ imm = #0xe
700a4cf4: e7ff         	b	0x700a4cf6 <UART_lld_writeDma+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a4cf6: 9900         	ldr	r1, [sp]
700a4cf8: 2009         	movs	r0, #0x9
700a4cfa: 60c8         	str	r0, [r1, #0xc]
700a4cfc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a4d00: 9001         	str	r0, [sp, #0x4]
;         }
700a4d02: e041         	b	0x700a4d88 <UART_lld_writeDma+0xb8> @ imm = #0x82
;             UART_lld_Transaction_init(trans);
700a4d04: 9800         	ldr	r0, [sp]
700a4d06: f007 fe53    	bl	0x700ac9b0 <UART_lld_Transaction_init> @ imm = #0x7ca6
;             if(extendedParams != NULL)
700a4d0a: 9802         	ldr	r0, [sp, #0x8]
700a4d0c: b128         	cbz	r0, 0x700a4d1a <UART_lld_writeDma+0x4a> @ imm = #0xa
700a4d0e: e7ff         	b	0x700a4d10 <UART_lld_writeDma+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a4d10: 9802         	ldr	r0, [sp, #0x8]
700a4d12: 6800         	ldr	r0, [r0]
700a4d14: 9900         	ldr	r1, [sp]
700a4d16: 6108         	str	r0, [r1, #0x10]
;             }
700a4d18: e003         	b	0x700a4d22 <UART_lld_writeDma+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a4d1a: 9900         	ldr	r1, [sp]
700a4d1c: 2000         	movs	r0, #0x0
700a4d1e: 6108         	str	r0, [r1, #0x10]
700a4d20: e7ff         	b	0x700a4d22 <UART_lld_writeDma+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a4d22: 9804         	ldr	r0, [sp, #0x10]
700a4d24: 9900         	ldr	r1, [sp]
700a4d26: 6008         	str	r0, [r1]
;             trans->count = size;
700a4d28: 9803         	ldr	r0, [sp, #0xc]
700a4d2a: 9900         	ldr	r1, [sp]
700a4d2c: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a4d2e: 9805         	ldr	r0, [sp, #0x14]
700a4d30: 6d40         	ldr	r0, [r0, #0x54]
700a4d32: 2801         	cmp	r0, #0x1
700a4d34: d105         	bne	0x700a4d42 <UART_lld_writeDma+0x72> @ imm = #0xa
700a4d36: e7ff         	b	0x700a4d38 <UART_lld_writeDma+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a4d38: 9800         	ldr	r0, [sp]
700a4d3a: f007 fa81    	bl	0x700ac240 <UART_checkTransaction> @ imm = #0x7502
700a4d3e: 9001         	str	r0, [sp, #0x4]
;             }
700a4d40: e003         	b	0x700a4d4a <UART_lld_writeDma+0x7a> @ imm = #0x6
700a4d42: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a4d46: 9001         	str	r0, [sp, #0x4]
700a4d48: e7ff         	b	0x700a4d4a <UART_lld_writeDma+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a4d4a: 9801         	ldr	r0, [sp, #0x4]
700a4d4c: b9d8         	cbnz	r0, 0x700a4d86 <UART_lld_writeDma+0xb6> @ imm = #0x36
700a4d4e: e7ff         	b	0x700a4d50 <UART_lld_writeDma+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a4d50: 9800         	ldr	r0, [sp]
700a4d52: 6800         	ldr	r0, [r0]
700a4d54: 9905         	ldr	r1, [sp, #0x14]
700a4d56: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a4d58: 9800         	ldr	r0, [sp]
700a4d5a: 6880         	ldr	r0, [r0, #0x8]
700a4d5c: 9905         	ldr	r1, [sp, #0x14]
700a4d5e: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a4d60: 9905         	ldr	r1, [sp, #0x14]
700a4d62: 2000         	movs	r0, #0x0
700a4d64: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a4d66: 9800         	ldr	r0, [sp]
700a4d68: 6840         	ldr	r0, [r0, #0x4]
700a4d6a: 9905         	ldr	r1, [sp, #0x14]
700a4d6c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a4d6e: 9905         	ldr	r1, [sp, #0x14]
700a4d70: 2002         	movs	r0, #0x2
700a4d72: 6548         	str	r0, [r1, #0x54]
;                 status = UART_lld_dmaWrite(hUart, trans);
700a4d74: 9805         	ldr	r0, [sp, #0x14]
700a4d76: 9900         	ldr	r1, [sp]
700a4d78: f007 fe32    	bl	0x700ac9e0 <UART_lld_dmaWrite> @ imm = #0x7c64
700a4d7c: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a4d7e: 9905         	ldr	r1, [sp, #0x14]
700a4d80: 2001         	movs	r0, #0x1
700a4d82: 6548         	str	r0, [r1, #0x54]
;             }
700a4d84: e7ff         	b	0x700a4d86 <UART_lld_writeDma+0xb6> @ imm = #-0x2
700a4d86: e7ff         	b	0x700a4d88 <UART_lld_writeDma+0xb8> @ imm = #-0x2
;     }
700a4d88: e003         	b	0x700a4d92 <UART_lld_writeDma+0xc2> @ imm = #0x6
700a4d8a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a4d8e: 9001         	str	r0, [sp, #0x4]
700a4d90: e7ff         	b	0x700a4d92 <UART_lld_writeDma+0xc2> @ imm = #-0x2
;     return status;
700a4d92: 9801         	ldr	r0, [sp, #0x4]
700a4d94: b006         	add	sp, #0x18
700a4d96: bd80         	pop	{r7, pc}
		...

700a4da0 <UART_udmaHpdInit>:
; {
700a4da0: b580         	push	{r7, lr}
700a4da2: b08a         	sub	sp, #0x28
700a4da4: 9009         	str	r0, [sp, #0x24]
700a4da6: 9108         	str	r1, [sp, #0x20]
700a4da8: 9207         	str	r2, [sp, #0x1c]
700a4daa: 9306         	str	r3, [sp, #0x18]
;     CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700a4dac: 9808         	ldr	r0, [sp, #0x20]
700a4dae: 9005         	str	r0, [sp, #0x14]
700a4db0: 2001         	movs	r0, #0x1
;     uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700a4db2: 9004         	str	r0, [sp, #0x10]
;     CSL_udmapCppi5SetDescType(pHpd, descType);
700a4db4: 9805         	ldr	r0, [sp, #0x14]
700a4db6: 9904         	ldr	r1, [sp, #0x10]
700a4db8: f008 f9d2    	bl	0x700ad160 <CSL_udmapCppi5SetDescType> @ imm = #0x83a4
;     CSL_udmapCppi5SetEpiDataPresent(pHpd, FALSE);
700a4dbc: 9805         	ldr	r0, [sp, #0x14]
700a4dbe: 2100         	movs	r1, #0x0
700a4dc0: 9102         	str	r1, [sp, #0x8]
700a4dc2: f008 f8dd    	bl	0x700acf80 <CSL_udmapCppi5SetEpiDataPresent> @ imm = #0x81ba
700a4dc6: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLoc(pHpd, 0U);
700a4dc8: 9805         	ldr	r0, [sp, #0x14]
700a4dca: f008 fac9    	bl	0x700ad360 <CSL_udmapCppi5SetPsDataLoc> @ imm = #0x8592
700a4dce: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLen(pHpd, 0U);
700a4dd0: 9805         	ldr	r0, [sp, #0x14]
700a4dd2: f008 f9f5    	bl	0x700ad1c0 <CSL_udmapCppi5SetPsDataLen> @ imm = #0x83ea
;     CSL_udmapCppi5SetPktLen(pHpd, descType, length);
700a4dd6: 9805         	ldr	r0, [sp, #0x14]
700a4dd8: 9904         	ldr	r1, [sp, #0x10]
700a4dda: 9a06         	ldr	r2, [sp, #0x18]
700a4ddc: f006 fcc8    	bl	0x700ab770 <CSL_udmapCppi5SetPktLen> @ imm = #0x6990
700a4de0: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsFlags(pHpd, 0U);
700a4de2: 9805         	ldr	r0, [sp, #0x14]
700a4de4: f008 facc    	bl	0x700ad380 <CSL_udmapCppi5SetPsFlags> @ imm = #0x8598
;     CSL_udmapCppi5SetIds(pHpd, descType, 0x321, UDMA_DEFAULT_FLOW_ID);
700a4de8: 9805         	ldr	r0, [sp, #0x14]
700a4dea: 9904         	ldr	r1, [sp, #0x10]
700a4dec: f240 3221    	movw	r2, #0x321
700a4df0: f643 73ff    	movw	r3, #0x3fff
700a4df4: f004 fdd4    	bl	0x700a99a0 <CSL_udmapCppi5SetIds> @ imm = #0x4ba8
700a4df8: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetSrcTag(pHpd, 0x0000);     /* Not used */
700a4dfa: 9805         	ldr	r0, [sp, #0x14]
700a4dfc: f008 fb60    	bl	0x700ad4c0 <CSL_udmapCppi5SetSrcTag> @ imm = #0x86c0
700a4e00: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetDstTag(pHpd, 0x0000);     /* Not used */
700a4e02: 9805         	ldr	r0, [sp, #0x14]
700a4e04: f008 fbec    	bl	0x700ad5e0 <CSL_udmapCppi5SetDstTag> @ imm = #0x87d8
;     UART_udmapSetReturnPolicy(chHandle, pHpdMem);
700a4e08: 9809         	ldr	r0, [sp, #0x24]
700a4e0a: 9908         	ldr	r1, [sp, #0x20]
700a4e0c: f007 fea8    	bl	0x700acb60 <UART_udmapSetReturnPolicy> @ imm = #0x7d50
700a4e10: 9b02         	ldr	r3, [sp, #0x8]
;     CSL_udmapCppi5LinkDesc(pHpd, 0U);
700a4e12: 9805         	ldr	r0, [sp, #0x14]
700a4e14: 461a         	mov	r2, r3
700a4e16: f008 fa63    	bl	0x700ad2e0 <CSL_udmapCppi5LinkDesc> @ imm = #0x84c6
700a4e1a: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a4e1c: 9805         	ldr	r0, [sp, #0x14]
700a4e1e: 9001         	str	r0, [sp, #0x4]
700a4e20: 9807         	ldr	r0, [sp, #0x1c]
700a4e22: 4611         	mov	r1, r2
700a4e24: f008 fc14    	bl	0x700ad650 <Udma_defaultVirtToPhyFxn> @ imm = #0x8828
700a4e28: 4602         	mov	r2, r0
700a4e2a: 9801         	ldr	r0, [sp, #0x4]
700a4e2c: 460b         	mov	r3, r1
700a4e2e: f008 fa67    	bl	0x700ad300 <CSL_udmapCppi5SetBufferAddr> @ imm = #0x84ce
;     CSL_udmapCppi5SetBufferLen(pHpd, length);
700a4e32: 9805         	ldr	r0, [sp, #0x14]
700a4e34: 9906         	ldr	r1, [sp, #0x18]
700a4e36: f008 fa73    	bl	0x700ad320 <CSL_udmapCppi5SetBufferLen> @ imm = #0x84e6
700a4e3a: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetOrgBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a4e3c: 9805         	ldr	r0, [sp, #0x14]
700a4e3e: 9003         	str	r0, [sp, #0xc]
700a4e40: 9807         	ldr	r0, [sp, #0x1c]
700a4e42: 4611         	mov	r1, r2
700a4e44: f008 fc04    	bl	0x700ad650 <Udma_defaultVirtToPhyFxn> @ imm = #0x8808
700a4e48: 4602         	mov	r2, r0
700a4e4a: 9803         	ldr	r0, [sp, #0xc]
700a4e4c: 460b         	mov	r3, r1
700a4e4e: f008 fa77    	bl	0x700ad340 <CSL_udmapCppi5SetOrgBufferAddr> @ imm = #0x84ee
;     CSL_udmapCppi5SetOrgBufferLen(pHpd, length);
700a4e52: 9805         	ldr	r0, [sp, #0x14]
700a4e54: 9906         	ldr	r1, [sp, #0x18]
700a4e56: f008 fbcb    	bl	0x700ad5f0 <CSL_udmapCppi5SetOrgBufferLen> @ imm = #0x8796
;     CacheP_wb(pHpdMem, sizeof(CSL_UdmapCppi5HMPD), CacheP_TYPE_ALLD);
700a4e5a: 9808         	ldr	r0, [sp, #0x20]
700a4e5c: 2130         	movs	r1, #0x30
700a4e5e: 220a         	movs	r2, #0xa
700a4e60: f009 eb70    	blx	0x700ae544 <CacheP_wb>  @ imm = #0x96e0
;     return;
700a4e64: b00a         	add	sp, #0x28
700a4e66: bd80         	pop	{r7, pc}
		...

700a4e70 <Udma_eventCheckUnRegister>:
; {
700a4e70: b580         	push	{r7, lr}
700a4e72: b088         	sub	sp, #0x20
700a4e74: 9007         	str	r0, [sp, #0x1c]
700a4e76: 9106         	str	r1, [sp, #0x18]
700a4e78: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a4e7a: 9005         	str	r0, [sp, #0x14]
;     eventPrms = &eventHandle->eventPrms;
700a4e7c: 9806         	ldr	r0, [sp, #0x18]
700a4e7e: 3008         	adds	r0, #0x8
700a4e80: 9004         	str	r0, [sp, #0x10]
;     if(eventHandle->eventInitDone != UDMA_INIT_DONE)
700a4e82: 9806         	ldr	r0, [sp, #0x18]
700a4e84: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700a4e88: f64a 31cd    	movw	r1, #0xabcd
700a4e8c: f6ca 31dc    	movt	r1, #0xabdc
700a4e90: 4288         	cmp	r0, r1
700a4e92: d004         	beq	0x700a4e9e <Udma_eventCheckUnRegister+0x2e> @ imm = #0x8
700a4e94: e7ff         	b	0x700a4e96 <Udma_eventCheckUnRegister+0x26> @ imm = #-0x2
700a4e96: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = UDMA_EFAIL;
700a4e9a: 9005         	str	r0, [sp, #0x14]
;     }
700a4e9c: e7ff         	b	0x700a4e9e <Udma_eventCheckUnRegister+0x2e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a4e9e: 9805         	ldr	r0, [sp, #0x14]
700a4ea0: b968         	cbnz	r0, 0x700a4ebe <Udma_eventCheckUnRegister+0x4e> @ imm = #0x1a
700a4ea2: e7ff         	b	0x700a4ea4 <Udma_eventCheckUnRegister+0x34> @ imm = #-0x2
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a4ea4: 9804         	ldr	r0, [sp, #0x10]
700a4ea6: 6900         	ldr	r0, [r0, #0x10]
700a4ea8: b940         	cbnz	r0, 0x700a4ebc <Udma_eventCheckUnRegister+0x4c> @ imm = #0x10
700a4eaa: e7ff         	b	0x700a4eac <Udma_eventCheckUnRegister+0x3c> @ imm = #-0x2
;            (NULL_PTR != eventHandle->nextEvent))
700a4eac: 9806         	ldr	r0, [sp, #0x18]
700a4eae: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a4eb0: b120         	cbz	r0, 0x700a4ebc <Udma_eventCheckUnRegister+0x4c> @ imm = #0x8
700a4eb2: e7ff         	b	0x700a4eb4 <Udma_eventCheckUnRegister+0x44> @ imm = #-0x2
700a4eb4: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a4eb8: 9005         	str	r0, [sp, #0x14]
;         }
700a4eba: e7ff         	b	0x700a4ebc <Udma_eventCheckUnRegister+0x4c> @ imm = #-0x2
;     }
700a4ebc: e7ff         	b	0x700a4ebe <Udma_eventCheckUnRegister+0x4e> @ imm = #-0x2
;      if(UDMA_SOK == retVal)
700a4ebe: 9805         	ldr	r0, [sp, #0x14]
700a4ec0: bbb8         	cbnz	r0, 0x700a4f32 <Udma_eventCheckUnRegister+0xc2> @ imm = #0x6e
700a4ec2: e7ff         	b	0x700a4ec4 <Udma_eventCheckUnRegister+0x54> @ imm = #-0x2
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a4ec4: 9804         	ldr	r0, [sp, #0x10]
700a4ec6: 6800         	ldr	r0, [r0]
700a4ec8: 2801         	cmp	r0, #0x1
700a4eca: d00a         	beq	0x700a4ee2 <Udma_eventCheckUnRegister+0x72> @ imm = #0x14
700a4ecc: e7ff         	b	0x700a4ece <Udma_eventCheckUnRegister+0x5e> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a4ece: 9804         	ldr	r0, [sp, #0x10]
700a4ed0: 6800         	ldr	r0, [r0]
700a4ed2: 2806         	cmp	r0, #0x6
700a4ed4: d005         	beq	0x700a4ee2 <Udma_eventCheckUnRegister+0x72> @ imm = #0xa
700a4ed6: e7ff         	b	0x700a4ed8 <Udma_eventCheckUnRegister+0x68> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_RING == eventPrms->eventType))
700a4ed8: 9804         	ldr	r0, [sp, #0x10]
700a4eda: 6800         	ldr	r0, [r0]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a4edc: 2804         	cmp	r0, #0x4
700a4ede: d127         	bne	0x700a4f30 <Udma_eventCheckUnRegister+0xc0> @ imm = #0x4e
700a4ee0: e7ff         	b	0x700a4ee2 <Udma_eventCheckUnRegister+0x72> @ imm = #-0x2
;             if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a4ee2: 9804         	ldr	r0, [sp, #0x10]
700a4ee4: 6800         	ldr	r0, [r0]
700a4ee6: 2801         	cmp	r0, #0x1
700a4ee8: d005         	beq	0x700a4ef6 <Udma_eventCheckUnRegister+0x86> @ imm = #0xa
700a4eea: e7ff         	b	0x700a4eec <Udma_eventCheckUnRegister+0x7c> @ imm = #-0x2
700a4eec: 9804         	ldr	r0, [sp, #0x10]
700a4eee: 6800         	ldr	r0, [r0]
700a4ef0: 2806         	cmp	r0, #0x6
700a4ef2: d106         	bne	0x700a4f02 <Udma_eventCheckUnRegister+0x92> @ imm = #0xc
700a4ef4: e7ff         	b	0x700a4ef6 <Udma_eventCheckUnRegister+0x86> @ imm = #-0x2
;                 ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a4ef6: 9804         	ldr	r0, [sp, #0x10]
700a4ef8: 6880         	ldr	r0, [r0, #0x8]
700a4efa: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a4efe: 9003         	str	r0, [sp, #0xc]
;             }
700a4f00: e003         	b	0x700a4f0a <Udma_eventCheckUnRegister+0x9a> @ imm = #0x6
;                 ringHandle = eventPrms->ringHandle;
700a4f02: 9804         	ldr	r0, [sp, #0x10]
700a4f04: 68c0         	ldr	r0, [r0, #0xc]
700a4f06: 9003         	str	r0, [sp, #0xc]
700a4f08: e7ff         	b	0x700a4f0a <Udma_eventCheckUnRegister+0x9a> @ imm = #-0x2
;             fOcc = Udma_ringGetForwardRingOcc(ringHandle);
700a4f0a: 9803         	ldr	r0, [sp, #0xc]
700a4f0c: f007 fe40    	bl	0x700acb90 <Udma_ringGetForwardRingOcc> @ imm = #0x7c80
700a4f10: 9002         	str	r0, [sp, #0x8]
;             rOcc = Udma_ringGetReverseRingOcc(ringHandle);
700a4f12: 9803         	ldr	r0, [sp, #0xc]
700a4f14: f007 fe54    	bl	0x700acbc0 <Udma_ringGetReverseRingOcc> @ imm = #0x7ca8
700a4f18: 9001         	str	r0, [sp, #0x4]
;             if((0U != fOcc) || (0U != rOcc))
700a4f1a: 9802         	ldr	r0, [sp, #0x8]
700a4f1c: b918         	cbnz	r0, 0x700a4f26 <Udma_eventCheckUnRegister+0xb6> @ imm = #0x6
700a4f1e: e7ff         	b	0x700a4f20 <Udma_eventCheckUnRegister+0xb0> @ imm = #-0x2
700a4f20: 9801         	ldr	r0, [sp, #0x4]
700a4f22: b120         	cbz	r0, 0x700a4f2e <Udma_eventCheckUnRegister+0xbe> @ imm = #0x8
700a4f24: e7ff         	b	0x700a4f26 <Udma_eventCheckUnRegister+0xb6> @ imm = #-0x2
700a4f26: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = UDMA_EFAIL;
700a4f2a: 9005         	str	r0, [sp, #0x14]
;             }
700a4f2c: e7ff         	b	0x700a4f2e <Udma_eventCheckUnRegister+0xbe> @ imm = #-0x2
;         }
700a4f2e: e7ff         	b	0x700a4f30 <Udma_eventCheckUnRegister+0xc0> @ imm = #-0x2
;     }
700a4f30: e7ff         	b	0x700a4f32 <Udma_eventCheckUnRegister+0xc2> @ imm = #-0x2
;     return (retVal);
700a4f32: 9805         	ldr	r0, [sp, #0x14]
700a4f34: b008         	add	sp, #0x20
700a4f36: bd80         	pop	{r7, pc}
		...

700a4f40 <Udma_ringFree>:
; {
700a4f40: b580         	push	{r7, lr}
700a4f42: b086         	sub	sp, #0x18
700a4f44: 9005         	str	r0, [sp, #0x14]
700a4f46: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a4f48: 9004         	str	r0, [sp, #0x10]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a4f4a: 9805         	ldr	r0, [sp, #0x14]
700a4f4c: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == ringHandleInt)
700a4f4e: 9802         	ldr	r0, [sp, #0x8]
700a4f50: b920         	cbnz	r0, 0x700a4f5c <Udma_ringFree+0x1c> @ imm = #0x8
700a4f52: e7ff         	b	0x700a4f54 <Udma_ringFree+0x14> @ imm = #-0x2
700a4f54: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a4f58: 9004         	str	r0, [sp, #0x10]
;     }
700a4f5a: e7ff         	b	0x700a4f5c <Udma_ringFree+0x1c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a4f5c: 9804         	ldr	r0, [sp, #0x10]
700a4f5e: b970         	cbnz	r0, 0x700a4f7e <Udma_ringFree+0x3e> @ imm = #0x1c
700a4f60: e7ff         	b	0x700a4f62 <Udma_ringFree+0x22> @ imm = #-0x2
;         if(ringHandleInt->ringInitDone != UDMA_INIT_DONE)
700a4f62: 9802         	ldr	r0, [sp, #0x8]
700a4f64: 6d80         	ldr	r0, [r0, #0x58]
700a4f66: f64a 31cd    	movw	r1, #0xabcd
700a4f6a: f6ca 31dc    	movt	r1, #0xabdc
700a4f6e: 4288         	cmp	r0, r1
700a4f70: d004         	beq	0x700a4f7c <Udma_ringFree+0x3c> @ imm = #0x8
700a4f72: e7ff         	b	0x700a4f74 <Udma_ringFree+0x34> @ imm = #-0x2
700a4f74: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a4f78: 9004         	str	r0, [sp, #0x10]
;         }
700a4f7a: e7ff         	b	0x700a4f7c <Udma_ringFree+0x3c> @ imm = #-0x2
;     }
700a4f7c: e7ff         	b	0x700a4f7e <Udma_ringFree+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a4f7e: 9804         	ldr	r0, [sp, #0x10]
700a4f80: b9a8         	cbnz	r0, 0x700a4fae <Udma_ringFree+0x6e> @ imm = #0x2a
700a4f82: e7ff         	b	0x700a4f84 <Udma_ringFree+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a4f84: 9802         	ldr	r0, [sp, #0x8]
700a4f86: 6800         	ldr	r0, [r0]
700a4f88: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a4f8a: 9803         	ldr	r0, [sp, #0xc]
700a4f8c: b150         	cbz	r0, 0x700a4fa4 <Udma_ringFree+0x64> @ imm = #0x14
700a4f8e: e7ff         	b	0x700a4f90 <Udma_ringFree+0x50> @ imm = #-0x2
700a4f90: 9803         	ldr	r0, [sp, #0xc]
700a4f92: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a4f96: f64a 31cd    	movw	r1, #0xabcd
700a4f9a: f6ca 31dc    	movt	r1, #0xabdc
700a4f9e: 4288         	cmp	r0, r1
700a4fa0: d004         	beq	0x700a4fac <Udma_ringFree+0x6c> @ imm = #0x8
700a4fa2: e7ff         	b	0x700a4fa4 <Udma_ringFree+0x64> @ imm = #-0x2
700a4fa4: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a4fa8: 9004         	str	r0, [sp, #0x10]
;         }
700a4faa: e7ff         	b	0x700a4fac <Udma_ringFree+0x6c> @ imm = #-0x2
;     }
700a4fac: e7ff         	b	0x700a4fae <Udma_ringFree+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a4fae: 9804         	ldr	r0, [sp, #0x10]
700a4fb0: bb38         	cbnz	r0, 0x700a5002 <Udma_ringFree+0xc2> @ imm = #0x4e
700a4fb2: e7ff         	b	0x700a4fb4 <Udma_ringFree+0x74> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == ringHandleInt->mappedRingGrp)
700a4fb4: 9802         	ldr	r0, [sp, #0x8]
700a4fb6: 6dc0         	ldr	r0, [r0, #0x5c]
700a4fb8: 2104         	movs	r1, #0x4
700a4fba: f6cf 71ff    	movt	r1, #0xffff
700a4fbe: 4288         	cmp	r0, r1
700a4fc0: d106         	bne	0x700a4fd0 <Udma_ringFree+0x90> @ imm = #0xc
700a4fc2: e7ff         	b	0x700a4fc4 <Udma_ringFree+0x84> @ imm = #-0x2
;             Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandle);
700a4fc4: 9802         	ldr	r0, [sp, #0x8]
700a4fc6: 8880         	ldrh	r0, [r0, #0x4]
700a4fc8: 9903         	ldr	r1, [sp, #0xc]
700a4fca: f008 fbc1    	bl	0x700ad750 <Udma_rmFreeFreeRing> @ imm = #0x8782
;         }
700a4fce: e007         	b	0x700a4fe0 <Udma_ringFree+0xa0> @ imm = #0xe
;                 ringHandleInt->ringNum,
700a4fd0: 9b02         	ldr	r3, [sp, #0x8]
700a4fd2: 8898         	ldrh	r0, [r3, #0x4]
;                 drvHandle,
700a4fd4: 9903         	ldr	r1, [sp, #0xc]
;                 ringHandleInt->mappedRingGrp,
700a4fd6: 6dda         	ldr	r2, [r3, #0x5c]
;                 ringHandleInt->mappedChNum);
700a4fd8: 6e1b         	ldr	r3, [r3, #0x60]
;             Udma_rmFreeMappedRing(
700a4fda: f002 fec1    	bl	0x700a7d60 <Udma_rmFreeMappedRing> @ imm = #0x2d82
700a4fde: e7ff         	b	0x700a4fe0 <Udma_ringFree+0xa0> @ imm = #-0x2
;         ringHandleInt->ringNum         = UDMA_RING_INVALID;
700a4fe0: 9902         	ldr	r1, [sp, #0x8]
700a4fe2: f64f 70ff    	movw	r0, #0xffff
700a4fe6: 8088         	strh	r0, [r1, #0x4]
;         ringHandleInt->ringInitDone    = UDMA_DEINIT_DONE;
700a4fe8: 9902         	ldr	r1, [sp, #0x8]
700a4fea: 2000         	movs	r0, #0x0
700a4fec: 9001         	str	r0, [sp, #0x4]
700a4fee: 6588         	str	r0, [r1, #0x58]
;         drvHandle->ringHandleClearRegs(ringHandleInt);
700a4ff0: 9803         	ldr	r0, [sp, #0xc]
700a4ff2: f8d0 15c8    	ldr.w	r1, [r0, #0x5c8]
700a4ff6: 9802         	ldr	r0, [sp, #0x8]
700a4ff8: 4788         	blx	r1
700a4ffa: 9801         	ldr	r0, [sp, #0x4]
;         ringHandleInt->drvHandle       = (Udma_DrvHandleInt) NULL_PTR;
700a4ffc: 9902         	ldr	r1, [sp, #0x8]
700a4ffe: 6008         	str	r0, [r1]
;     }
700a5000: e7ff         	b	0x700a5002 <Udma_ringFree+0xc2> @ imm = #-0x2
;     return (retVal);
700a5002: 9804         	ldr	r0, [sp, #0x10]
700a5004: b006         	add	sp, #0x18
700a5006: bd80         	pop	{r7, pc}
		...

700a5010 <vTaskSwitchContext>:
; void vTaskSwitchContext(void) {
700a5010: b082         	sub	sp, #0x8
;   if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
700a5012: f240 10f0    	movw	r0, #0x1f0
700a5016: f2c7 000b    	movt	r0, #0x700b
700a501a: 6800         	ldr	r0, [r0]
700a501c: b138         	cbz	r0, 0x700a502e <vTaskSwitchContext+0x1e> @ imm = #0xe
700a501e: e7ff         	b	0x700a5020 <vTaskSwitchContext+0x10> @ imm = #-0x2
;     xYieldPending = pdTRUE;
700a5020: f240 211c    	movw	r1, #0x21c
700a5024: f2c7 010b    	movt	r1, #0x700b
700a5028: 2001         	movs	r0, #0x1
700a502a: 6008         	str	r0, [r1]
;   } else {
700a502c: e052         	b	0x700a50d4 <vTaskSwitchContext+0xc4> @ imm = #0xa4
;     xYieldPending = pdFALSE;
700a502e: f240 211c    	movw	r1, #0x21c
700a5032: f2c7 010b    	movt	r1, #0x700b
700a5036: 2000         	movs	r0, #0x0
700a5038: 6008         	str	r0, [r1]
;       pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
700a503a: f240 1098    	movw	r0, #0x198
700a503e: f2c7 000b    	movt	r0, #0x700b
700a5042: 6800         	ldr	r0, [r0]
700a5044: f240 11cc    	movw	r1, #0x1cc
700a5048: f2c7 010b    	movt	r1, #0x700b
700a504c: 6809         	ldr	r1, [r1]
700a504e: f8c1 0088    	str.w	r0, [r1, #0x88]
;     taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this
700a5052: e7ff         	b	0x700a5054 <vTaskSwitchContext+0x44> @ imm = #-0x2
700a5054: f240 10f8    	movw	r0, #0x1f8
700a5058: f2c7 000b    	movt	r0, #0x700b
700a505c: 6800         	ldr	r0, [r0]
700a505e: b158         	cbz	r0, 0x700a5078 <vTaskSwitchContext+0x68> @ imm = #0x16
700a5060: e7ff         	b	0x700a5062 <vTaskSwitchContext+0x52> @ imm = #-0x2
700a5062: f240 10f8    	movw	r0, #0x1f8
700a5066: f2c7 000b    	movt	r0, #0x700b
700a506a: 6800         	ldr	r0, [r0]
700a506c: fab0 f080    	clz	r0, r0
700a5070: f1c0 001f    	rsb.w	r0, r0, #0x1f
700a5074: 9001         	str	r0, [sp, #0x4]
700a5076: e002         	b	0x700a507e <vTaskSwitchContext+0x6e> @ imm = #0x4
700a5078: 2000         	movs	r0, #0x0
;     taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this
700a507a: 9001         	str	r0, [sp, #0x4]
700a507c: e7ff         	b	0x700a507e <vTaskSwitchContext+0x6e> @ imm = #-0x2
700a507e: e7ff         	b	0x700a5080 <vTaskSwitchContext+0x70> @ imm = #-0x2
700a5080: 9801         	ldr	r0, [sp, #0x4]
700a5082: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a5086: f244 40f8    	movw	r0, #0x44f8
700a508a: f2c7 0008    	movt	r0, #0x7008
700a508e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5092: 9000         	str	r0, [sp]
700a5094: 9900         	ldr	r1, [sp]
700a5096: 6848         	ldr	r0, [r1, #0x4]
700a5098: 6840         	ldr	r0, [r0, #0x4]
700a509a: 6048         	str	r0, [r1, #0x4]
700a509c: 9900         	ldr	r1, [sp]
700a509e: 6848         	ldr	r0, [r1, #0x4]
700a50a0: 3108         	adds	r1, #0x8
700a50a2: 4288         	cmp	r0, r1
700a50a4: d105         	bne	0x700a50b2 <vTaskSwitchContext+0xa2> @ imm = #0xa
700a50a6: e7ff         	b	0x700a50a8 <vTaskSwitchContext+0x98> @ imm = #-0x2
700a50a8: 9900         	ldr	r1, [sp]
700a50aa: 6848         	ldr	r0, [r1, #0x4]
700a50ac: 6840         	ldr	r0, [r0, #0x4]
700a50ae: 6048         	str	r0, [r1, #0x4]
700a50b0: e7ff         	b	0x700a50b2 <vTaskSwitchContext+0xa2> @ imm = #-0x2
700a50b2: 9800         	ldr	r0, [sp]
700a50b4: 6840         	ldr	r0, [r0, #0x4]
700a50b6: 68c1         	ldr	r1, [r0, #0xc]
700a50b8: f240 10cc    	movw	r0, #0x1cc
700a50bc: f2c7 000b    	movt	r0, #0x700b
700a50c0: 6001         	str	r1, [r0]
;       FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
700a50c2: 6800         	ldr	r0, [r0]
700a50c4: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a50c8: f240 1198    	movw	r1, #0x198
700a50cc: f2c7 010b    	movt	r1, #0x700b
700a50d0: 6008         	str	r0, [r1]
700a50d2: e7ff         	b	0x700a50d4 <vTaskSwitchContext+0xc4> @ imm = #-0x2
; }
700a50d4: b002         	add	sp, #0x8
700a50d6: 4770         	bx	lr
		...

700a50e0 <UART_lld_writeIntr>:
; {
700a50e0: b580         	push	{r7, lr}
700a50e2: b086         	sub	sp, #0x18
700a50e4: 9005         	str	r0, [sp, #0x14]
700a50e6: 9104         	str	r1, [sp, #0x10]
700a50e8: 9203         	str	r2, [sp, #0xc]
700a50ea: 9302         	str	r3, [sp, #0x8]
700a50ec: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a50ee: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a50f0: 9805         	ldr	r0, [sp, #0x14]
700a50f2: 2800         	cmp	r0, #0x0
700a50f4: d050         	beq	0x700a5198 <UART_lld_writeIntr+0xb8> @ imm = #0xa0
700a50f6: e7ff         	b	0x700a50f8 <UART_lld_writeIntr+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a50f8: 9805         	ldr	r0, [sp, #0x14]
700a50fa: 303c         	adds	r0, #0x3c
700a50fc: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a50fe: 9800         	ldr	r0, [sp]
700a5100: 6800         	ldr	r0, [r0]
700a5102: b138         	cbz	r0, 0x700a5114 <UART_lld_writeIntr+0x34> @ imm = #0xe
700a5104: e7ff         	b	0x700a5106 <UART_lld_writeIntr+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a5106: 9900         	ldr	r1, [sp]
700a5108: 2009         	movs	r0, #0x9
700a510a: 60c8         	str	r0, [r1, #0xc]
700a510c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a5110: 9001         	str	r0, [sp, #0x4]
;         }
700a5112: e040         	b	0x700a5196 <UART_lld_writeIntr+0xb6> @ imm = #0x80
;             UART_lld_Transaction_init(trans);
700a5114: 9800         	ldr	r0, [sp]
700a5116: f007 fc4b    	bl	0x700ac9b0 <UART_lld_Transaction_init> @ imm = #0x7896
;             if(extendedParams != NULL)
700a511a: 9802         	ldr	r0, [sp, #0x8]
700a511c: b128         	cbz	r0, 0x700a512a <UART_lld_writeIntr+0x4a> @ imm = #0xa
700a511e: e7ff         	b	0x700a5120 <UART_lld_writeIntr+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a5120: 9802         	ldr	r0, [sp, #0x8]
700a5122: 6800         	ldr	r0, [r0]
700a5124: 9900         	ldr	r1, [sp]
700a5126: 6108         	str	r0, [r1, #0x10]
;             }
700a5128: e003         	b	0x700a5132 <UART_lld_writeIntr+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a512a: 9900         	ldr	r1, [sp]
700a512c: 2000         	movs	r0, #0x0
700a512e: 6108         	str	r0, [r1, #0x10]
700a5130: e7ff         	b	0x700a5132 <UART_lld_writeIntr+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a5132: 9804         	ldr	r0, [sp, #0x10]
700a5134: 9900         	ldr	r1, [sp]
700a5136: 6008         	str	r0, [r1]
;             trans->count = size;
700a5138: 9803         	ldr	r0, [sp, #0xc]
700a513a: 9900         	ldr	r1, [sp]
700a513c: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a513e: 9805         	ldr	r0, [sp, #0x14]
700a5140: 6d40         	ldr	r0, [r0, #0x54]
700a5142: 2801         	cmp	r0, #0x1
700a5144: d105         	bne	0x700a5152 <UART_lld_writeIntr+0x72> @ imm = #0xa
700a5146: e7ff         	b	0x700a5148 <UART_lld_writeIntr+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a5148: 9800         	ldr	r0, [sp]
700a514a: f007 f879    	bl	0x700ac240 <UART_checkTransaction> @ imm = #0x70f2
700a514e: 9001         	str	r0, [sp, #0x4]
;             }
700a5150: e003         	b	0x700a515a <UART_lld_writeIntr+0x7a> @ imm = #0x6
700a5152: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a5156: 9001         	str	r0, [sp, #0x4]
700a5158: e7ff         	b	0x700a515a <UART_lld_writeIntr+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a515a: 9801         	ldr	r0, [sp, #0x4]
700a515c: b9d0         	cbnz	r0, 0x700a5194 <UART_lld_writeIntr+0xb4> @ imm = #0x34
700a515e: e7ff         	b	0x700a5160 <UART_lld_writeIntr+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a5160: 9800         	ldr	r0, [sp]
700a5162: 6800         	ldr	r0, [r0]
700a5164: 9905         	ldr	r1, [sp, #0x14]
700a5166: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a5168: 9800         	ldr	r0, [sp]
700a516a: 6880         	ldr	r0, [r0, #0x8]
700a516c: 9905         	ldr	r1, [sp, #0x14]
700a516e: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a5170: 9905         	ldr	r1, [sp, #0x14]
700a5172: 2000         	movs	r0, #0x0
700a5174: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a5176: 9800         	ldr	r0, [sp]
700a5178: 6840         	ldr	r0, [r0, #0x4]
700a517a: 9905         	ldr	r1, [sp, #0x14]
700a517c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a517e: 9905         	ldr	r1, [sp, #0x14]
700a5180: 2002         	movs	r0, #0x2
700a5182: 6548         	str	r0, [r1, #0x54]
;                 status = UART_writeInterrupt(hUart);
700a5184: 9805         	ldr	r0, [sp, #0x14]
700a5186: f007 ff5b    	bl	0x700ad040 <UART_writeInterrupt> @ imm = #0x7eb6
700a518a: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a518c: 9905         	ldr	r1, [sp, #0x14]
700a518e: 2001         	movs	r0, #0x1
700a5190: 6548         	str	r0, [r1, #0x54]
;             }
700a5192: e7ff         	b	0x700a5194 <UART_lld_writeIntr+0xb4> @ imm = #-0x2
700a5194: e7ff         	b	0x700a5196 <UART_lld_writeIntr+0xb6> @ imm = #-0x2
;     }
700a5196: e003         	b	0x700a51a0 <UART_lld_writeIntr+0xc0> @ imm = #0x6
700a5198: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a519c: 9001         	str	r0, [sp, #0x4]
700a519e: e7ff         	b	0x700a51a0 <UART_lld_writeIntr+0xc0> @ imm = #-0x2
;     return status;
700a51a0: 9801         	ldr	r0, [sp, #0x4]
700a51a2: b006         	add	sp, #0x18
700a51a4: bd80         	pop	{r7, pc}
		...
700a51ae: 0000         	movs	r0, r0

700a51b0 <Udma_eventUnRegister>:
; {
700a51b0: b580         	push	{r7, lr}
700a51b2: b084         	sub	sp, #0x10
700a51b4: 9003         	str	r0, [sp, #0xc]
700a51b6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a51b8: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == eventHandle)
700a51ba: 9803         	ldr	r0, [sp, #0xc]
700a51bc: b920         	cbnz	r0, 0x700a51c8 <Udma_eventUnRegister+0x18> @ imm = #0x8
700a51be: e7ff         	b	0x700a51c0 <Udma_eventUnRegister+0x10> @ imm = #-0x2
700a51c0: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a51c4: 9002         	str	r0, [sp, #0x8]
;     }
700a51c6: e7ff         	b	0x700a51c8 <Udma_eventUnRegister+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a51c8: 9802         	ldr	r0, [sp, #0x8]
700a51ca: b9b8         	cbnz	r0, 0x700a51fc <Udma_eventUnRegister+0x4c> @ imm = #0x2e
700a51cc: e7ff         	b	0x700a51ce <Udma_eventUnRegister+0x1e> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
700a51ce: 9803         	ldr	r0, [sp, #0xc]
700a51d0: 9000         	str	r0, [sp]
;         drvHandle = eventHandleInt->drvHandle;
700a51d2: 9800         	ldr	r0, [sp]
700a51d4: 6800         	ldr	r0, [r0]
700a51d6: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a51d8: 9801         	ldr	r0, [sp, #0x4]
700a51da: b150         	cbz	r0, 0x700a51f2 <Udma_eventUnRegister+0x42> @ imm = #0x14
700a51dc: e7ff         	b	0x700a51de <Udma_eventUnRegister+0x2e> @ imm = #-0x2
700a51de: 9801         	ldr	r0, [sp, #0x4]
700a51e0: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a51e4: f64a 31cd    	movw	r1, #0xabcd
700a51e8: f6ca 31dc    	movt	r1, #0xabdc
700a51ec: 4288         	cmp	r0, r1
700a51ee: d004         	beq	0x700a51fa <Udma_eventUnRegister+0x4a> @ imm = #0x8
700a51f0: e7ff         	b	0x700a51f2 <Udma_eventUnRegister+0x42> @ imm = #-0x2
700a51f2: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a51f6: 9002         	str	r0, [sp, #0x8]
;         }
700a51f8: e7ff         	b	0x700a51fa <Udma_eventUnRegister+0x4a> @ imm = #-0x2
;     }
700a51fa: e7ff         	b	0x700a51fc <Udma_eventUnRegister+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a51fc: 9802         	ldr	r0, [sp, #0x8]
700a51fe: bbb8         	cbnz	r0, 0x700a5270 <Udma_eventUnRegister+0xc0> @ imm = #0x6e
700a5200: e7ff         	b	0x700a5202 <Udma_eventUnRegister+0x52> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a5202: 9801         	ldr	r0, [sp, #0x4]
700a5204: 6800         	ldr	r0, [r0]
700a5206: b130         	cbz	r0, 0x700a5216 <Udma_eventUnRegister+0x66> @ imm = #0xc
700a5208: e7ff         	b	0x700a520a <Udma_eventUnRegister+0x5a> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventHandleInt->eventPrms.eventType))
700a520a: 9800         	ldr	r0, [sp]
700a520c: 6880         	ldr	r0, [r0, #0x8]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a520e: 2802         	cmp	r0, #0x2
700a5210: d101         	bne	0x700a5216 <Udma_eventUnRegister+0x66> @ imm = #0x2
700a5212: e7ff         	b	0x700a5214 <Udma_eventUnRegister+0x64> @ imm = #-0x2
;         }
700a5214: e02b         	b	0x700a526e <Udma_eventUnRegister+0xbe> @ imm = #0x56
;             retVal = Udma_eventCheckUnRegister(drvHandle, eventHandleInt);
700a5216: 9801         	ldr	r0, [sp, #0x4]
700a5218: 9900         	ldr	r1, [sp]
700a521a: f7ff fe29    	bl	0x700a4e70 <Udma_eventCheckUnRegister> @ imm = #-0x3ae
700a521e: 9002         	str	r0, [sp, #0x8]
;             if(UDMA_SOK == retVal)
700a5220: 9802         	ldr	r0, [sp, #0x8]
700a5222: bb18         	cbnz	r0, 0x700a526c <Udma_eventUnRegister+0xbc> @ imm = #0x46
700a5224: e7ff         	b	0x700a5226 <Udma_eventUnRegister+0x76> @ imm = #-0x2
;                 if(NULL_PTR != eventHandleInt->hwiHandle)
700a5226: 9800         	ldr	r0, [sp]
700a5228: 6e40         	ldr	r0, [r0, #0x64]
700a522a: b128         	cbz	r0, 0x700a5238 <Udma_eventUnRegister+0x88> @ imm = #0xa
700a522c: e7ff         	b	0x700a522e <Udma_eventUnRegister+0x7e> @ imm = #-0x2
;                     HwiP_disableInt(eventHandleInt->coreIntrNum);
700a522e: 9800         	ldr	r0, [sp]
700a5230: 6d80         	ldr	r0, [r0, #0x58]
700a5232: f008 fb1d    	bl	0x700ad870 <HwiP_disableInt> @ imm = #0x863a
;                 }
700a5236: e7ff         	b	0x700a5238 <Udma_eventUnRegister+0x88> @ imm = #-0x2
;                 retVal = Udma_eventReset(drvHandle, eventHandleInt);
700a5238: 9801         	ldr	r0, [sp, #0x4]
700a523a: 9900         	ldr	r1, [sp]
700a523c: f7f6 fca0    	bl	0x7009bb80 <Udma_eventReset> @ imm = #-0x96c0
700a5240: 9002         	str	r0, [sp, #0x8]
;                 if(UDMA_SOK != retVal)
700a5242: 9802         	ldr	r0, [sp, #0x8]
700a5244: b108         	cbz	r0, 0x700a524a <Udma_eventUnRegister+0x9a> @ imm = #0x2
700a5246: e7ff         	b	0x700a5248 <Udma_eventUnRegister+0x98> @ imm = #-0x2
;                 }
700a5248: e7ff         	b	0x700a524a <Udma_eventUnRegister+0x9a> @ imm = #-0x2
;                 Udma_eventFreeResource(drvHandle, eventHandleInt);
700a524a: 9801         	ldr	r0, [sp, #0x4]
700a524c: 9900         	ldr	r1, [sp]
700a524e: f7fe fd6f    	bl	0x700a3d30 <Udma_eventFreeResource> @ imm = #-0x1522
;                 eventHandleInt->eventInitDone  = UDMA_DEINIT_DONE;
700a5252: 9900         	ldr	r1, [sp]
700a5254: 2000         	movs	r0, #0x0
700a5256: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 eventHandleInt->pIaGeviRegs    = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
700a525a: 9900         	ldr	r1, [sp]
700a525c: f8c1 0090    	str.w	r0, [r1, #0x90]
;                 eventHandleInt->pIaVintrRegs   = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
700a5260: 9900         	ldr	r1, [sp]
700a5262: f8c1 0094    	str.w	r0, [r1, #0x94]
;                 eventHandleInt->drvHandle      = (Udma_DrvHandleInt) NULL_PTR;
700a5266: 9900         	ldr	r1, [sp]
700a5268: 6008         	str	r0, [r1]
;             }
700a526a: e7ff         	b	0x700a526c <Udma_eventUnRegister+0xbc> @ imm = #-0x2
700a526c: e7ff         	b	0x700a526e <Udma_eventUnRegister+0xbe> @ imm = #-0x2
;     }
700a526e: e7ff         	b	0x700a5270 <Udma_eventUnRegister+0xc0> @ imm = #-0x2
;     return (retVal);
700a5270: 9802         	ldr	r0, [sp, #0x8]
700a5272: b004         	add	sp, #0x10
700a5274: bd80         	pop	{r7, pc}
		...
700a527e: 0000         	movs	r0, r0

700a5280 <Sciclient_rmIrqIsVintRouteSet>:
; {
700a5280: b580         	push	{r7, lr}
700a5282: b088         	sub	sp, #0x20
700a5284: 9007         	str	r0, [sp, #0x1c]
700a5286: 9106         	str	r1, [sp, #0x18]
700a5288: 2000         	movs	r0, #0x0
;     bool found_iface = false;
700a528a: f88d 0007    	strb.w	r0, [sp, #0x7]
;     *vint_used = false;
700a528e: 9906         	ldr	r1, [sp, #0x18]
700a5290: 7008         	strb	r0, [r1]
;     r = Sciclient_rmIrqGetNode(cfg->s_ia, &ia_node);
700a5292: 9807         	ldr	r0, [sp, #0x1c]
700a5294: 8a00         	ldrh	r0, [r0, #0x10]
700a5296: a903         	add	r1, sp, #0xc
700a5298: f7fe fe3a    	bl	0x700a3f10 <Sciclient_rmIrqGetNode> @ imm = #-0x138c
700a529c: 9005         	str	r0, [sp, #0x14]
;     if (r == SystemP_SUCCESS) {
700a529e: 9805         	ldr	r0, [sp, #0x14]
700a52a0: bb90         	cbnz	r0, 0x700a5308 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #0x64
700a52a2: e7ff         	b	0x700a52a4 <Sciclient_rmIrqIsVintRouteSet+0x24> @ imm = #-0x2
700a52a4: 2000         	movs	r0, #0x0
;         for (i = 0U; i < ia_node->n_if; i++) {
700a52a6: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a52aa: e7ff         	b	0x700a52ac <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x2
700a52ac: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a52b0: 9903         	ldr	r1, [sp, #0xc]
700a52b2: 8849         	ldrh	r1, [r1, #0x2]
700a52b4: 4288         	cmp	r0, r1
700a52b6: da26         	bge	0x700a5306 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x4c
700a52b8: e7ff         	b	0x700a52ba <Sciclient_rmIrqIsVintRouteSet+0x3a> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(ia_node, i, &iface);
700a52ba: 9803         	ldr	r0, [sp, #0xc]
700a52bc: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a52c0: aa02         	add	r2, sp, #0x8
700a52c2: f006 fa7d    	bl	0x700ab7c0 <Sciclient_rmIrqGetNodeItf> @ imm = #0x64fa
700a52c6: 9005         	str	r0, [sp, #0x14]
;             if (r != SystemP_SUCCESS) {
700a52c8: 9805         	ldr	r0, [sp, #0x14]
700a52ca: b108         	cbz	r0, 0x700a52d0 <Sciclient_rmIrqIsVintRouteSet+0x50> @ imm = #0x2
700a52cc: e7ff         	b	0x700a52ce <Sciclient_rmIrqIsVintRouteSet+0x4e> @ imm = #-0x2
;                 break;
700a52ce: e01a         	b	0x700a5306 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x34
;             if ((cfg->vint >= iface->lbase) &&
700a52d0: 9807         	ldr	r0, [sp, #0x1c]
700a52d2: 8a40         	ldrh	r0, [r0, #0x12]
700a52d4: 9902         	ldr	r1, [sp, #0x8]
700a52d6: 8809         	ldrh	r1, [r1]
700a52d8: 4288         	cmp	r0, r1
700a52da: db0d         	blt	0x700a52f8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x1a
700a52dc: e7ff         	b	0x700a52de <Sciclient_rmIrqIsVintRouteSet+0x5e> @ imm = #-0x2
;                 (cfg->vint < (iface->lbase + iface->len))) {
700a52de: 9807         	ldr	r0, [sp, #0x1c]
700a52e0: 8a40         	ldrh	r0, [r0, #0x12]
700a52e2: 9a02         	ldr	r2, [sp, #0x8]
700a52e4: 8811         	ldrh	r1, [r2]
700a52e6: 8892         	ldrh	r2, [r2, #0x4]
700a52e8: 4411         	add	r1, r2
;             if ((cfg->vint >= iface->lbase) &&
700a52ea: 4288         	cmp	r0, r1
700a52ec: da04         	bge	0x700a52f8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x8
700a52ee: e7ff         	b	0x700a52f0 <Sciclient_rmIrqIsVintRouteSet+0x70> @ imm = #-0x2
700a52f0: 2001         	movs	r0, #0x1
;                 found_iface = true;
700a52f2: f88d 0007    	strb.w	r0, [sp, #0x7]
;                 break;
700a52f6: e006         	b	0x700a5306 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0xc
;         }
700a52f8: e7ff         	b	0x700a52fa <Sciclient_rmIrqIsVintRouteSet+0x7a> @ imm = #-0x2
;         for (i = 0U; i < ia_node->n_if; i++) {
700a52fa: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a52fe: 3001         	adds	r0, #0x1
700a5300: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a5304: e7d2         	b	0x700a52ac <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x5c
;     }
700a5306: e7ff         	b	0x700a5308 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #-0x2
;     if (found_iface) {
700a5308: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a530c: 07c0         	lsls	r0, r0, #0x1f
700a530e: b1b0         	cbz	r0, 0x700a533e <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #0x2c
700a5310: e7ff         	b	0x700a5312 <Sciclient_rmIrqIsVintRouteSet+0x92> @ imm = #-0x2
;         ir_inp = SCICLIENT_OUTP_TO_INP(cfg->vint, iface->lbase, iface->rbase);
700a5312: 9a02         	ldr	r2, [sp, #0x8]
700a5314: 8850         	ldrh	r0, [r2, #0x2]
700a5316: 9907         	ldr	r1, [sp, #0x1c]
700a5318: 8a49         	ldrh	r1, [r1, #0x12]
700a531a: 8812         	ldrh	r2, [r2]
700a531c: 1a89         	subs	r1, r1, r2
700a531e: 4408         	add	r0, r1
700a5320: f8ad 0004    	strh.w	r0, [sp, #0x4]
;         if (Sciclient_rmIrInpIsFree(iface->rid, ir_inp) != SystemP_SUCCESS) {
700a5324: 9802         	ldr	r0, [sp, #0x8]
700a5326: 88c0         	ldrh	r0, [r0, #0x6]
700a5328: f8bd 1004    	ldrh.w	r1, [sp, #0x4]
700a532c: f7fe ffb8    	bl	0x700a42a0 <Sciclient_rmIrInpIsFree> @ imm = #-0x1090
700a5330: b120         	cbz	r0, 0x700a533c <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #0x8
700a5332: e7ff         	b	0x700a5334 <Sciclient_rmIrqIsVintRouteSet+0xb4> @ imm = #-0x2
;             *vint_used = true;
700a5334: 9906         	ldr	r1, [sp, #0x18]
700a5336: 2001         	movs	r0, #0x1
700a5338: 7008         	strb	r0, [r1]
;         }
700a533a: e7ff         	b	0x700a533c <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #-0x2
;     }
700a533c: e7ff         	b	0x700a533e <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #-0x2
;     return r;
700a533e: 9805         	ldr	r0, [sp, #0x14]
700a5340: b008         	add	sp, #0x20
700a5342: bd80         	pop	{r7, pc}
		...

700a5350 <UART_flushTxFifo>:
; {
700a5350: b580         	push	{r7, lr}
700a5352: b08a         	sub	sp, #0x28
700a5354: 9009         	str	r0, [sp, #0x24]
700a5356: f640 30b8    	movw	r0, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700a535a: 9003         	str	r0, [sp, #0xc]
700a535c: 2000         	movs	r0, #0x0
;     uint32_t            timeoutElapsed  = FALSE;
700a535e: 9002         	str	r0, [sp, #0x8]
;     config = (UART_Config *) handle;
700a5360: 9809         	ldr	r0, [sp, #0x24]
700a5362: 9008         	str	r0, [sp, #0x20]
;     if (NULL != config)
700a5364: 9808         	ldr	r0, [sp, #0x20]
700a5366: 2800         	cmp	r0, #0x0
700a5368: d052         	beq	0x700a5410 <UART_flushTxFifo+0xc0> @ imm = #0xa4
700a536a: e7ff         	b	0x700a536c <UART_flushTxFifo+0x1c> @ imm = #-0x2
;         attrs = config->attrs;
700a536c: 9808         	ldr	r0, [sp, #0x20]
700a536e: 6800         	ldr	r0, [r0]
700a5370: 9007         	str	r0, [sp, #0x1c]
;         DebugP_assert(NULL_PTR != attrs);
700a5372: 9807         	ldr	r0, [sp, #0x1c]
700a5374: 2800         	cmp	r0, #0x0
700a5376: bf18         	it	ne
700a5378: 2001         	movne	r0, #0x1
700a537a: f64f 01d8    	movw	r1, #0xf8d8
700a537e: f2c7 010a    	movt	r1, #0x700a
700a5382: 466a         	mov	r2, sp
700a5384: 6011         	str	r1, [r2]
700a5386: f64f 01a2    	movw	r1, #0xf8a2
700a538a: f2c7 010a    	movt	r1, #0x700a
700a538e: f64f 121e    	movw	r2, #0xf91e
700a5392: f2c7 020a    	movt	r2, #0x700a
700a5396: f240 3355    	movw	r3, #0x355
700a539a: f003 fc01    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x3802
;         startTicks = ClockP_getTicks();
700a539e: f008 f9f7    	bl	0x700ad790 <ClockP_getTicks> @ imm = #0x83ee
700a53a2: 9005         	str	r0, [sp, #0x14]
;         while (FALSE == timeoutElapsed)
700a53a4: e7ff         	b	0x700a53a6 <UART_flushTxFifo+0x56> @ imm = #-0x2
700a53a6: 9802         	ldr	r0, [sp, #0x8]
700a53a8: b9d8         	cbnz	r0, 0x700a53e2 <UART_flushTxFifo+0x92> @ imm = #0x36
700a53aa: e7ff         	b	0x700a53ac <UART_flushTxFifo+0x5c> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(attrs->baseAddr);
700a53ac: 9807         	ldr	r0, [sp, #0x1c]
700a53ae: 6800         	ldr	r0, [r0]
700a53b0: f006 fc06    	bl	0x700abbc0 <UART_spaceAvail> @ imm = #0x680c
700a53b4: 9006         	str	r0, [sp, #0x18]
;             if (TRUE == isTxFifoEmpty)
700a53b6: 9806         	ldr	r0, [sp, #0x18]
700a53b8: 2801         	cmp	r0, #0x1
700a53ba: d101         	bne	0x700a53c0 <UART_flushTxFifo+0x70> @ imm = #0x2
700a53bc: e7ff         	b	0x700a53be <UART_flushTxFifo+0x6e> @ imm = #-0x2
;                 break;
700a53be: e010         	b	0x700a53e2 <UART_flushTxFifo+0x92> @ imm = #0x20
;             elapsedTicks = ClockP_getTicks() - startTicks;
700a53c0: f008 f9e6    	bl	0x700ad790 <ClockP_getTicks> @ imm = #0x83cc
700a53c4: 9905         	ldr	r1, [sp, #0x14]
700a53c6: 1a40         	subs	r0, r0, r1
700a53c8: 9004         	str	r0, [sp, #0x10]
;             if (elapsedTicks >= timeout)
700a53ca: 9804         	ldr	r0, [sp, #0x10]
700a53cc: 9903         	ldr	r1, [sp, #0xc]
700a53ce: 4288         	cmp	r0, r1
700a53d0: d303         	blo	0x700a53da <UART_flushTxFifo+0x8a> @ imm = #0x6
700a53d2: e7ff         	b	0x700a53d4 <UART_flushTxFifo+0x84> @ imm = #-0x2
700a53d4: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700a53d6: 9002         	str	r0, [sp, #0x8]
;             }
700a53d8: e002         	b	0x700a53e0 <UART_flushTxFifo+0x90> @ imm = #0x4
;                 TaskP_yield();
700a53da: f008 fa01    	bl	0x700ad7e0 <TaskP_yield> @ imm = #0x8402
700a53de: e7ff         	b	0x700a53e0 <UART_flushTxFifo+0x90> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700a53e0: e7e1         	b	0x700a53a6 <UART_flushTxFifo+0x56> @ imm = #-0x3e
;         DebugP_assert(FALSE == timeoutElapsed);
700a53e2: 9802         	ldr	r0, [sp, #0x8]
700a53e4: fab0 f080    	clz	r0, r0
700a53e8: 0940         	lsrs	r0, r0, #0x5
700a53ea: f24f 71b9    	movw	r1, #0xf7b9
700a53ee: f2c7 010a    	movt	r1, #0x700a
700a53f2: 466a         	mov	r2, sp
700a53f4: 6011         	str	r1, [r2]
700a53f6: f64f 01a2    	movw	r1, #0xf8a2
700a53fa: f2c7 010a    	movt	r1, #0x700a
700a53fe: f64f 121e    	movw	r2, #0xf91e
700a5402: f2c7 020a    	movt	r2, #0x700a
700a5406: f240 336f    	movw	r3, #0x36f
700a540a: f003 fbc9    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x3792
;     }
700a540e: e7ff         	b	0x700a5410 <UART_flushTxFifo+0xc0> @ imm = #-0x2
;     return;
700a5410: b00a         	add	sp, #0x28
700a5412: bd80         	pop	{r7, pc}
		...

700a5420 <Udma_chClose>:
; {
700a5420: b580         	push	{r7, lr}
700a5422: b084         	sub	sp, #0x10
700a5424: 9003         	str	r0, [sp, #0xc]
700a5426: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a5428: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a542a: 9803         	ldr	r0, [sp, #0xc]
700a542c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a542e: 9800         	ldr	r0, [sp]
700a5430: b150         	cbz	r0, 0x700a5448 <Udma_chClose+0x28> @ imm = #0x14
700a5432: e7ff         	b	0x700a5434 <Udma_chClose+0x14> @ imm = #-0x2
700a5434: 9800         	ldr	r0, [sp]
700a5436: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a543a: f64a 31cd    	movw	r1, #0xabcd
700a543e: f6ca 31dc    	movt	r1, #0xabdc
700a5442: 4288         	cmp	r0, r1
700a5444: d004         	beq	0x700a5450 <Udma_chClose+0x30> @ imm = #0x8
700a5446: e7ff         	b	0x700a5448 <Udma_chClose+0x28> @ imm = #-0x2
700a5448: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a544c: 9002         	str	r0, [sp, #0x8]
;     }
700a544e: e7ff         	b	0x700a5450 <Udma_chClose+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a5450: 9802         	ldr	r0, [sp, #0x8]
700a5452: b9a8         	cbnz	r0, 0x700a5480 <Udma_chClose+0x60> @ imm = #0x2a
700a5454: e7ff         	b	0x700a5456 <Udma_chClose+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a5456: 9800         	ldr	r0, [sp]
700a5458: 6e80         	ldr	r0, [r0, #0x68]
700a545a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a545c: 9801         	ldr	r0, [sp, #0x4]
700a545e: b150         	cbz	r0, 0x700a5476 <Udma_chClose+0x56> @ imm = #0x14
700a5460: e7ff         	b	0x700a5462 <Udma_chClose+0x42> @ imm = #-0x2
700a5462: 9801         	ldr	r0, [sp, #0x4]
700a5464: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a5468: f64a 31cd    	movw	r1, #0xabcd
700a546c: f6ca 31dc    	movt	r1, #0xabdc
700a5470: 4288         	cmp	r0, r1
700a5472: d004         	beq	0x700a547e <Udma_chClose+0x5e> @ imm = #0x8
700a5474: e7ff         	b	0x700a5476 <Udma_chClose+0x56> @ imm = #-0x2
700a5476: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a547a: 9002         	str	r0, [sp, #0x8]
;         }
700a547c: e7ff         	b	0x700a547e <Udma_chClose+0x5e> @ imm = #-0x2
;     }
700a547e: e7ff         	b	0x700a5480 <Udma_chClose+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a5480: 9802         	ldr	r0, [sp, #0x8]
700a5482: b958         	cbnz	r0, 0x700a549c <Udma_chClose+0x7c> @ imm = #0x16
700a5484: e7ff         	b	0x700a5486 <Udma_chClose+0x66> @ imm = #-0x2
;         if(TRUE == chHandleInt->chOesAllocDone)
700a5486: 9800         	ldr	r0, [sp]
700a5488: f8d0 0248    	ldr.w	r0, [r0, #0x248]
700a548c: 2801         	cmp	r0, #0x1
700a548e: d104         	bne	0x700a549a <Udma_chClose+0x7a> @ imm = #0x8
700a5490: e7ff         	b	0x700a5492 <Udma_chClose+0x72> @ imm = #-0x2
700a5492: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a5496: 9002         	str	r0, [sp, #0x8]
;         }
700a5498: e7ff         	b	0x700a549a <Udma_chClose+0x7a> @ imm = #-0x2
;     }
700a549a: e7ff         	b	0x700a549c <Udma_chClose+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a549c: 9802         	ldr	r0, [sp, #0x8]
700a549e: b9e8         	cbnz	r0, 0x700a54dc <Udma_chClose+0xbc> @ imm = #0x3a
700a54a0: e7ff         	b	0x700a54a2 <Udma_chClose+0x82> @ imm = #-0x2
;         retVal = Udma_chUnpair(chHandleInt);
700a54a2: 9800         	ldr	r0, [sp]
700a54a4: f003 f9b4    	bl	0x700a8810 <Udma_chUnpair> @ imm = #0x3368
700a54a8: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a54aa: 9802         	ldr	r0, [sp, #0x8]
700a54ac: b108         	cbz	r0, 0x700a54b2 <Udma_chClose+0x92> @ imm = #0x2
700a54ae: e7ff         	b	0x700a54b0 <Udma_chClose+0x90> @ imm = #-0x2
;         }
700a54b0: e7ff         	b	0x700a54b2 <Udma_chClose+0x92> @ imm = #-0x2
;         retVal += Udma_chFreeResource(chHandleInt);
700a54b2: 9800         	ldr	r0, [sp]
700a54b4: f7f8 f90c    	bl	0x7009d6d0 <Udma_chFreeResource> @ imm = #-0x7de8
700a54b8: 4601         	mov	r1, r0
700a54ba: 9802         	ldr	r0, [sp, #0x8]
700a54bc: 4408         	add	r0, r1
700a54be: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a54c0: 9802         	ldr	r0, [sp, #0x8]
700a54c2: b108         	cbz	r0, 0x700a54c8 <Udma_chClose+0xa8> @ imm = #0x2
700a54c4: e7ff         	b	0x700a54c6 <Udma_chClose+0xa6> @ imm = #-0x2
;         }
700a54c6: e7ff         	b	0x700a54c8 <Udma_chClose+0xa8> @ imm = #-0x2
;         (void) memset(chHandleInt, 0, sizeof(*chHandleInt));
700a54c8: 9800         	ldr	r0, [sp]
700a54ca: f44f 7114    	mov.w	r1, #0x250
700a54ce: f7f4 eab2    	blx	0x70099a34 <__aeabi_memclr8> @ imm = #-0xba9c
;         chHandleInt->chInitDone = UDMA_DEINIT_DONE;
700a54d2: 9900         	ldr	r1, [sp]
700a54d4: 2000         	movs	r0, #0x0
700a54d6: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a54da: e7ff         	b	0x700a54dc <Udma_chClose+0xbc> @ imm = #-0x2
;     return (retVal);
700a54dc: 9802         	ldr	r0, [sp, #0x8]
700a54de: b004         	add	sp, #0x10
700a54e0: bd80         	pop	{r7, pc}
		...
700a54ee: 0000         	movs	r0, r0

700a54f0 <CSL_bcdmaChanOpAccessRemotePeerReg>:
; {
700a54f0: b580         	push	{r7, lr}
700a54f2: b08a         	sub	sp, #0x28
700a54f4: 4684         	mov	r12, r0
700a54f6: 980c         	ldr	r0, [sp, #0x30]
700a54f8: f8cd c024    	str.w	r12, [sp, #0x24]
700a54fc: 9108         	str	r1, [sp, #0x20]
700a54fe: 9207         	str	r2, [sp, #0x1c]
700a5500: 9306         	str	r3, [sp, #0x18]
700a5502: f88d 0017    	strb.w	r0, [sp, #0x17]
700a5506: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a5508: 9004         	str	r0, [sp, #0x10]
;     if( pOpData == NULL )
700a550a: 9806         	ldr	r0, [sp, #0x18]
700a550c: b920         	cbnz	r0, 0x700a5518 <CSL_bcdmaChanOpAccessRemotePeerReg+0x28> @ imm = #0x8
700a550e: e7ff         	b	0x700a5510 <CSL_bcdmaChanOpAccessRemotePeerReg+0x20> @ imm = #-0x2
700a5510: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a5514: 9004         	str	r0, [sp, #0x10]
;     }
700a5516: e048         	b	0x700a55aa <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #0x90
700a5518: 2000         	movs	r0, #0x0
;         uint32_t *pRemotePeerReg = NULL;
700a551a: 9003         	str	r0, [sp, #0xc]
;         switch( chanType )
700a551c: 9808         	ldr	r0, [sp, #0x20]
700a551e: 9001         	str	r0, [sp, #0x4]
700a5520: 2801         	cmp	r0, #0x1
700a5522: d004         	beq	0x700a552e <CSL_bcdmaChanOpAccessRemotePeerReg+0x3e> @ imm = #0x8
700a5524: e7ff         	b	0x700a5526 <CSL_bcdmaChanOpAccessRemotePeerReg+0x36> @ imm = #-0x2
700a5526: 9801         	ldr	r0, [sp, #0x4]
700a5528: 2802         	cmp	r0, #0x2
700a552a: d009         	beq	0x700a5540 <CSL_bcdmaChanOpAccessRemotePeerReg+0x50> @ imm = #0x12
700a552c: e011         	b	0x700a5552 <CSL_bcdmaChanOpAccessRemotePeerReg+0x62> @ imm = #0x22
;                 pRemotePeerReg = (uint32_t *)&pCfg->pTxChanRtRegs->CHAN[chanIdx].PEER0;
700a552e: 9809         	ldr	r0, [sp, #0x24]
700a5530: 6900         	ldr	r0, [r0, #0x10]
700a5532: 9907         	ldr	r1, [sp, #0x1c]
700a5534: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5538: f500 7000    	add.w	r0, r0, #0x200
700a553c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a553e: e00c         	b	0x700a555a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x18
;                 pRemotePeerReg = (uint32_t *)&pCfg->pRxChanRtRegs->CHAN[chanIdx].PEER0;
700a5540: 9809         	ldr	r0, [sp, #0x24]
700a5542: 6980         	ldr	r0, [r0, #0x18]
700a5544: 9907         	ldr	r1, [sp, #0x1c]
700a5546: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a554a: f500 7000    	add.w	r0, r0, #0x200
700a554e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a5550: e003         	b	0x700a555a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x6
700a5552: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a5556: 9004         	str	r0, [sp, #0x10]
;                 break;
700a5558: e7ff         	b	0x700a555a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #-0x2
;         if( pRemotePeerReg != NULL )
700a555a: 9803         	ldr	r0, [sp, #0xc]
700a555c: b320         	cbz	r0, 0x700a55a8 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #0x48
700a555e: e7ff         	b	0x700a5560 <CSL_bcdmaChanOpAccessRemotePeerReg+0x70> @ imm = #-0x2
;             CSL_BcdmaRemotePeerOpts *pPeerOpts = (CSL_BcdmaRemotePeerOpts *)pOpData;
700a5560: 9806         	ldr	r0, [sp, #0x18]
700a5562: 9002         	str	r0, [sp, #0x8]
;             if( pPeerOpts->regIdx >= (uint32_t)16u )
700a5564: 9802         	ldr	r0, [sp, #0x8]
700a5566: 6800         	ldr	r0, [r0]
700a5568: 2810         	cmp	r0, #0x10
700a556a: d304         	blo	0x700a5576 <CSL_bcdmaChanOpAccessRemotePeerReg+0x86> @ imm = #0x8
700a556c: e7ff         	b	0x700a556e <CSL_bcdmaChanOpAccessRemotePeerReg+0x7e> @ imm = #-0x2
700a556e: f06f 0002    	mvn	r0, #0x2
;                 retVal = CSL_EINVALID_PARAMS;
700a5572: 9004         	str	r0, [sp, #0x10]
;             }
700a5574: e017         	b	0x700a55a6 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #0x2e
;                 pRemotePeerReg += pPeerOpts->regIdx;    /* Increment to specified peer register */
700a5576: 9802         	ldr	r0, [sp, #0x8]
700a5578: 6801         	ldr	r1, [r0]
700a557a: 9803         	ldr	r0, [sp, #0xc]
700a557c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5580: 9003         	str	r0, [sp, #0xc]
;                 if( bRead == (bool)true )
700a5582: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a5586: 07c0         	lsls	r0, r0, #0x1f
700a5588: b130         	cbz	r0, 0x700a5598 <CSL_bcdmaChanOpAccessRemotePeerReg+0xa8> @ imm = #0xc
700a558a: e7ff         	b	0x700a558c <CSL_bcdmaChanOpAccessRemotePeerReg+0x9c> @ imm = #-0x2
;                     pPeerOpts->regVal = CSL_REG32_RD( pRemotePeerReg );
700a558c: 9803         	ldr	r0, [sp, #0xc]
700a558e: f008 f897    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0x812e
700a5592: 9902         	ldr	r1, [sp, #0x8]
700a5594: 6048         	str	r0, [r1, #0x4]
;                 }
700a5596: e005         	b	0x700a55a4 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #0xa
;                     CSL_REG32_WR( pRemotePeerReg, pPeerOpts->regVal );
700a5598: 9803         	ldr	r0, [sp, #0xc]
700a559a: 9902         	ldr	r1, [sp, #0x8]
700a559c: 6849         	ldr	r1, [r1, #0x4]
700a559e: f007 ffef    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x7fde
700a55a2: e7ff         	b	0x700a55a4 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #-0x2
700a55a4: e7ff         	b	0x700a55a6 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #-0x2
;         }
700a55a6: e7ff         	b	0x700a55a8 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #-0x2
700a55a8: e7ff         	b	0x700a55aa <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #-0x2
;     return retVal;
700a55aa: 9804         	ldr	r0, [sp, #0x10]
700a55ac: b00a         	add	sp, #0x28
700a55ae: bd80         	pop	{r7, pc}

700a55b0 <_out_rev>:
; {
700a55b0: b580         	push	{r7, lr}
700a55b2: b086         	sub	sp, #0x18
700a55b4: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a55b8: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a55bc: f8dd c024    	ldr.w	r12, [sp, #0x24]
700a55c0: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a55c4: 9005         	str	r0, [sp, #0x14]
700a55c6: 9104         	str	r1, [sp, #0x10]
700a55c8: 9203         	str	r2, [sp, #0xc]
700a55ca: 9302         	str	r3, [sp, #0x8]
;   const size_t start_idx = idx;
700a55cc: 9803         	ldr	r0, [sp, #0xc]
700a55ce: 9001         	str	r0, [sp, #0x4]
;   if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
700a55d0: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a55d4: 0780         	lsls	r0, r0, #0x1e
700a55d6: 2800         	cmp	r0, #0x0
700a55d8: d41c         	bmi	0x700a5614 <_out_rev+0x64> @ imm = #0x38
700a55da: e7ff         	b	0x700a55dc <_out_rev+0x2c> @ imm = #-0x2
700a55dc: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a55e0: 07c0         	lsls	r0, r0, #0x1f
700a55e2: b9b8         	cbnz	r0, 0x700a5614 <_out_rev+0x64> @ imm = #0x2e
700a55e4: e7ff         	b	0x700a55e6 <_out_rev+0x36> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a55e6: 9809         	ldr	r0, [sp, #0x24]
700a55e8: 9000         	str	r0, [sp]
700a55ea: e7ff         	b	0x700a55ec <_out_rev+0x3c> @ imm = #-0x2
700a55ec: 9800         	ldr	r0, [sp]
700a55ee: 990a         	ldr	r1, [sp, #0x28]
700a55f0: 4288         	cmp	r0, r1
700a55f2: d20e         	bhs	0x700a5612 <_out_rev+0x62> @ imm = #0x1c
700a55f4: e7ff         	b	0x700a55f6 <_out_rev+0x46> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a55f6: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a55fa: 9904         	ldr	r1, [sp, #0x10]
700a55fc: 9a03         	ldr	r2, [sp, #0xc]
700a55fe: 1c50         	adds	r0, r2, #0x1
700a5600: 9003         	str	r0, [sp, #0xc]
700a5602: 9b02         	ldr	r3, [sp, #0x8]
700a5604: 2020         	movs	r0, #0x20
700a5606: 47e0         	blx	r12
;     }
700a5608: e7ff         	b	0x700a560a <_out_rev+0x5a> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a560a: 9800         	ldr	r0, [sp]
700a560c: 3001         	adds	r0, #0x1
700a560e: 9000         	str	r0, [sp]
700a5610: e7ec         	b	0x700a55ec <_out_rev+0x3c> @ imm = #-0x28
;   }
700a5612: e7ff         	b	0x700a5614 <_out_rev+0x64> @ imm = #-0x2
;   while (len) {
700a5614: e7ff         	b	0x700a5616 <_out_rev+0x66> @ imm = #-0x2
700a5616: 9809         	ldr	r0, [sp, #0x24]
700a5618: b170         	cbz	r0, 0x700a5638 <_out_rev+0x88> @ imm = #0x1c
700a561a: e7ff         	b	0x700a561c <_out_rev+0x6c> @ imm = #-0x2
;     out(buf[--len], buffer, idx++, maxlen);
700a561c: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a5620: 9808         	ldr	r0, [sp, #0x20]
700a5622: 9909         	ldr	r1, [sp, #0x24]
700a5624: 3901         	subs	r1, #0x1
700a5626: 9109         	str	r1, [sp, #0x24]
700a5628: 5c40         	ldrb	r0, [r0, r1]
700a562a: 9904         	ldr	r1, [sp, #0x10]
700a562c: 9a03         	ldr	r2, [sp, #0xc]
700a562e: 1c53         	adds	r3, r2, #0x1
700a5630: 9303         	str	r3, [sp, #0xc]
700a5632: 9b02         	ldr	r3, [sp, #0x8]
700a5634: 47e0         	blx	r12
;   while (len) {
700a5636: e7ee         	b	0x700a5616 <_out_rev+0x66> @ imm = #-0x24
;   if (flags & FLAGS_LEFT) {
700a5638: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a563c: 0780         	lsls	r0, r0, #0x1e
700a563e: 2800         	cmp	r0, #0x0
700a5640: d513         	bpl	0x700a566a <_out_rev+0xba> @ imm = #0x26
700a5642: e7ff         	b	0x700a5644 <_out_rev+0x94> @ imm = #-0x2
;     while (idx - start_idx < width) {
700a5644: e7ff         	b	0x700a5646 <_out_rev+0x96> @ imm = #-0x2
700a5646: 9803         	ldr	r0, [sp, #0xc]
700a5648: 9901         	ldr	r1, [sp, #0x4]
700a564a: 1a40         	subs	r0, r0, r1
700a564c: 990a         	ldr	r1, [sp, #0x28]
700a564e: 4288         	cmp	r0, r1
700a5650: d20a         	bhs	0x700a5668 <_out_rev+0xb8> @ imm = #0x14
700a5652: e7ff         	b	0x700a5654 <_out_rev+0xa4> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a5654: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a5658: 9904         	ldr	r1, [sp, #0x10]
700a565a: 9a03         	ldr	r2, [sp, #0xc]
700a565c: 1c50         	adds	r0, r2, #0x1
700a565e: 9003         	str	r0, [sp, #0xc]
700a5660: 9b02         	ldr	r3, [sp, #0x8]
700a5662: 2020         	movs	r0, #0x20
700a5664: 47e0         	blx	r12
;     while (idx - start_idx < width) {
700a5666: e7ee         	b	0x700a5646 <_out_rev+0x96> @ imm = #-0x24
;   }
700a5668: e7ff         	b	0x700a566a <_out_rev+0xba> @ imm = #-0x2
;   return idx;
700a566a: 9803         	ldr	r0, [sp, #0xc]
700a566c: b006         	add	sp, #0x18
700a566e: bd80         	pop	{r7, pc}

700a5670 <vTaskStartScheduler>:
; void vTaskStartScheduler(void) {
700a5670: b580         	push	{r7, lr}
700a5672: b088         	sub	sp, #0x20
700a5674: 2000         	movs	r0, #0x0
;     StaticTask_t *pxIdleTaskTCBBuffer = NULL;
700a5676: 9003         	str	r0, [sp, #0xc]
700a5678: 9006         	str	r0, [sp, #0x18]
;     StackType_t *pxIdleTaskStackBuffer = NULL;
700a567a: 9005         	str	r0, [sp, #0x14]
700a567c: a806         	add	r0, sp, #0x18
700a567e: a905         	add	r1, sp, #0x14
700a5680: aa04         	add	r2, sp, #0x10
;     vApplicationGetIdleTaskMemory(&pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer,
700a5682: f007 f905    	bl	0x700ac890 <vApplicationGetIdleTaskMemory> @ imm = #0x720a
700a5686: 9b03         	ldr	r3, [sp, #0xc]
;         prvIdleTask, configIDLE_TASK_NAME, ulIdleTaskStackSize,
700a5688: 9a04         	ldr	r2, [sp, #0x10]
;         pxIdleTaskStackBuffer,
700a568a: 9905         	ldr	r1, [sp, #0x14]
;         pxIdleTaskTCBBuffer); /*lint !e961 MISRA exception, justified as it is
700a568c: f8dd c018    	ldr.w	r12, [sp, #0x18]
;     xIdleTaskHandle = xTaskCreateStatic(
700a5690: 4668         	mov	r0, sp
700a5692: f8c0 c008    	str.w	r12, [r0, #0x8]
700a5696: 6041         	str	r1, [r0, #0x4]
700a5698: 6003         	str	r3, [r0]
700a569a: f64a 40e1    	movw	r0, #0xace1
700a569e: f2c7 000a    	movt	r0, #0x700a
700a56a2: f64f 6158    	movw	r1, #0xfe58
700a56a6: f2c7 010a    	movt	r1, #0x700a
700a56aa: f003 fdb9    	bl	0x700a9220 <xTaskCreateStatic> @ imm = #0x3b72
700a56ae: 4601         	mov	r1, r0
700a56b0: f240 10fc    	movw	r0, #0x1fc
700a56b4: f2c7 000b    	movt	r0, #0x700b
700a56b8: 6001         	str	r1, [r0]
;     if (xIdleTaskHandle != NULL) {
700a56ba: 6800         	ldr	r0, [r0]
700a56bc: b118         	cbz	r0, 0x700a56c6 <vTaskStartScheduler+0x56> @ imm = #0x6
700a56be: e7ff         	b	0x700a56c0 <vTaskStartScheduler+0x50> @ imm = #-0x2
700a56c0: 2001         	movs	r0, #0x1
;       xReturn = pdPASS;
700a56c2: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a56c4: e002         	b	0x700a56cc <vTaskStartScheduler+0x5c> @ imm = #0x4
700a56c6: 2000         	movs	r0, #0x0
;       xReturn = pdFAIL;
700a56c8: 9007         	str	r0, [sp, #0x1c]
700a56ca: e7ff         	b	0x700a56cc <vTaskStartScheduler+0x5c> @ imm = #-0x2
;     if (xReturn == pdPASS) {
700a56cc: 9807         	ldr	r0, [sp, #0x1c]
700a56ce: 2801         	cmp	r0, #0x1
700a56d0: d104         	bne	0x700a56dc <vTaskStartScheduler+0x6c> @ imm = #0x8
700a56d2: e7ff         	b	0x700a56d4 <vTaskStartScheduler+0x64> @ imm = #-0x2
;       xReturn = xTimerCreateTimerTask();
700a56d4: f003 fb24    	bl	0x700a8d20 <xTimerCreateTimerTask> @ imm = #0x3648
700a56d8: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a56da: e000         	b	0x700a56de <vTaskStartScheduler+0x6e> @ imm = #0x0
700a56dc: e7ff         	b	0x700a56de <vTaskStartScheduler+0x6e> @ imm = #-0x2
;   if (xReturn == pdPASS) {
700a56de: 9807         	ldr	r0, [sp, #0x1c]
700a56e0: 2801         	cmp	r0, #0x1
700a56e2: d11d         	bne	0x700a5720 <vTaskStartScheduler+0xb0> @ imm = #0x3a
700a56e4: e7ff         	b	0x700a56e6 <vTaskStartScheduler+0x76> @ imm = #-0x2
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700a56e6: b672         	cpsid i
;     xNextTaskUnblockTime = portMAX_DELAY;
700a56e8: f240 2100    	movw	r1, #0x200
700a56ec: f2c7 010b    	movt	r1, #0x700b
700a56f0: f04f 30ff    	mov.w	r0, #0xffffffff
700a56f4: 6008         	str	r0, [r1]
;     xSchedulerRunning = pdTRUE;
700a56f6: f240 210c    	movw	r1, #0x20c
700a56fa: f2c7 010b    	movt	r1, #0x700b
700a56fe: 2001         	movs	r0, #0x1
700a5700: 6008         	str	r0, [r1]
;     xTickCount = (TickType_t)configINITIAL_TICK_COUNT;
700a5702: f240 2110    	movw	r1, #0x210
700a5706: f2c7 010b    	movt	r1, #0x700b
700a570a: 2000         	movs	r0, #0x0
700a570c: 6008         	str	r0, [r1]
;     portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
700a570e: f008 f887    	bl	0x700ad820 <vPortConfigTimerForRunTimeStats> @ imm = #0x810e
;     if (xPortStartScheduler() != pdFALSE) {
700a5712: f007 fcc5    	bl	0x700ad0a0 <xPortStartScheduler> @ imm = #0x798a
700a5716: b108         	cbz	r0, 0x700a571c <vTaskStartScheduler+0xac> @ imm = #0x2
700a5718: e7ff         	b	0x700a571a <vTaskStartScheduler+0xaa> @ imm = #-0x2
;     } else {
700a571a: e000         	b	0x700a571e <vTaskStartScheduler+0xae> @ imm = #0x0
700a571c: e7ff         	b	0x700a571e <vTaskStartScheduler+0xae> @ imm = #-0x2
;   } else {
700a571e: e000         	b	0x700a5722 <vTaskStartScheduler+0xb2> @ imm = #0x0
700a5720: e7ff         	b	0x700a5722 <vTaskStartScheduler+0xb2> @ imm = #-0x2
;   (void)uxTopUsedPriority;
700a5722: f64f 6094    	movw	r0, #0xfe94
700a5726: f2c7 000a    	movt	r0, #0x700a
700a572a: 6800         	ldr	r0, [r0]
; }
700a572c: b008         	add	sp, #0x20
700a572e: bd80         	pop	{r7, pc}

700a5730 <prvSwitchTimerLists>:
;     {
700a5730: b580         	push	{r7, lr}
700a5732: b086         	sub	sp, #0x18
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a5734: e7ff         	b	0x700a5736 <prvSwitchTimerLists+0x6> @ imm = #-0x2
700a5736: f644 70b4    	movw	r0, #0x4fb4
700a573a: f2c7 0008    	movt	r0, #0x7008
700a573e: 6800         	ldr	r0, [r0]
700a5740: 6800         	ldr	r0, [r0]
700a5742: 2800         	cmp	r0, #0x0
700a5744: d040         	beq	0x700a57c8 <prvSwitchTimerLists+0x98> @ imm = #0x80
700a5746: e7ff         	b	0x700a5748 <prvSwitchTimerLists+0x18> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700a5748: f644 70b4    	movw	r0, #0x4fb4
700a574c: f2c7 0008    	movt	r0, #0x7008
700a5750: 6801         	ldr	r1, [r0]
700a5752: 68c9         	ldr	r1, [r1, #0xc]
700a5754: 6809         	ldr	r1, [r1]
700a5756: 9105         	str	r1, [sp, #0x14]
;             pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700a5758: 6800         	ldr	r0, [r0]
700a575a: 68c0         	ldr	r0, [r0, #0xc]
700a575c: 68c0         	ldr	r0, [r0, #0xc]
700a575e: 9002         	str	r0, [sp, #0x8]
;             ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a5760: 9802         	ldr	r0, [sp, #0x8]
700a5762: 3004         	adds	r0, #0x4
700a5764: f005 fe7c    	bl	0x700ab460 <uxListRemove> @ imm = #0x5cf8
;             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a5768: 9802         	ldr	r0, [sp, #0x8]
700a576a: 6a01         	ldr	r1, [r0, #0x20]
700a576c: 4788         	blx	r1
;             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a576e: 9802         	ldr	r0, [sp, #0x8]
700a5770: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a5774: 0740         	lsls	r0, r0, #0x1d
700a5776: 2800         	cmp	r0, #0x0
700a5778: d524         	bpl	0x700a57c4 <prvSwitchTimerLists+0x94> @ imm = #0x48
700a577a: e7ff         	b	0x700a577c <prvSwitchTimerLists+0x4c> @ imm = #-0x2
;                 xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
700a577c: 9805         	ldr	r0, [sp, #0x14]
700a577e: 9902         	ldr	r1, [sp, #0x8]
700a5780: 6989         	ldr	r1, [r1, #0x18]
700a5782: 4408         	add	r0, r1
700a5784: 9004         	str	r0, [sp, #0x10]
;                 if( xReloadTime > xNextExpireTime )
700a5786: 9804         	ldr	r0, [sp, #0x10]
700a5788: 9905         	ldr	r1, [sp, #0x14]
700a578a: 4288         	cmp	r0, r1
700a578c: d90f         	bls	0x700a57ae <prvSwitchTimerLists+0x7e> @ imm = #0x1e
700a578e: e7ff         	b	0x700a5790 <prvSwitchTimerLists+0x60> @ imm = #-0x2
;                     listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
700a5790: 9804         	ldr	r0, [sp, #0x10]
700a5792: 9902         	ldr	r1, [sp, #0x8]
700a5794: 6048         	str	r0, [r1, #0x4]
;                     listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700a5796: 9802         	ldr	r0, [sp, #0x8]
700a5798: 6100         	str	r0, [r0, #0x10]
;                     vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700a579a: f644 70b4    	movw	r0, #0x4fb4
700a579e: f2c7 0008    	movt	r0, #0x7008
700a57a2: 6800         	ldr	r0, [r0]
700a57a4: 9902         	ldr	r1, [sp, #0x8]
700a57a6: 3104         	adds	r1, #0x4
700a57a8: f003 ff72    	bl	0x700a9690 <vListInsert> @ imm = #0x3ee4
;                 }
700a57ac: e009         	b	0x700a57c2 <prvSwitchTimerLists+0x92> @ imm = #0x12
;                     xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700a57ae: 9802         	ldr	r0, [sp, #0x8]
700a57b0: 9a05         	ldr	r2, [sp, #0x14]
700a57b2: 4669         	mov	r1, sp
700a57b4: 2300         	movs	r3, #0x0
700a57b6: 600b         	str	r3, [r1]
700a57b8: 4619         	mov	r1, r3
700a57ba: f002 f941    	bl	0x700a7a40 <xTimerGenericCommand> @ imm = #0x2282
700a57be: 9001         	str	r0, [sp, #0x4]
700a57c0: e7ff         	b	0x700a57c2 <prvSwitchTimerLists+0x92> @ imm = #-0x2
;             }
700a57c2: e000         	b	0x700a57c6 <prvSwitchTimerLists+0x96> @ imm = #0x0
700a57c4: e7ff         	b	0x700a57c6 <prvSwitchTimerLists+0x96> @ imm = #-0x2
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a57c6: e7b6         	b	0x700a5736 <prvSwitchTimerLists+0x6> @ imm = #-0x94
;         pxTemp = pxCurrentTimerList;
700a57c8: f644 72b4    	movw	r2, #0x4fb4
700a57cc: f2c7 0208    	movt	r2, #0x7008
700a57d0: 6810         	ldr	r0, [r2]
700a57d2: 9003         	str	r0, [sp, #0xc]
;         pxCurrentTimerList = pxOverflowTimerList;
700a57d4: f644 71c0    	movw	r1, #0x4fc0
700a57d8: f2c7 0108    	movt	r1, #0x7008
700a57dc: 6808         	ldr	r0, [r1]
700a57de: 6010         	str	r0, [r2]
;         pxOverflowTimerList = pxTemp;
700a57e0: 9803         	ldr	r0, [sp, #0xc]
700a57e2: 6008         	str	r0, [r1]
;     }
700a57e4: b006         	add	sp, #0x18
700a57e6: bd80         	pop	{r7, pc}
		...

700a57f0 <CSL_pktdmaAccessChanPeerReg>:
; {
700a57f0: b580         	push	{r7, lr}
700a57f2: b088         	sub	sp, #0x20
700a57f4: 4684         	mov	r12, r0
700a57f6: 980b         	ldr	r0, [sp, #0x2c]
700a57f8: f8dd e028    	ldr.w	lr, [sp, #0x28]
700a57fc: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a5800: 9106         	str	r1, [sp, #0x18]
700a5802: 9205         	str	r2, [sp, #0x14]
700a5804: 9304         	str	r3, [sp, #0x10]
700a5806: f88d 000f    	strb.w	r0, [sp, #0xf]
700a580a: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a580c: 9002         	str	r0, [sp, #0x8]
;     if( (pCfg == NULL) || (pVal == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a580e: 9807         	ldr	r0, [sp, #0x1c]
700a5810: b150         	cbz	r0, 0x700a5828 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0x14
700a5812: e7ff         	b	0x700a5814 <CSL_pktdmaAccessChanPeerReg+0x24> @ imm = #-0x2
700a5814: 9804         	ldr	r0, [sp, #0x10]
700a5816: b138         	cbz	r0, 0x700a5828 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0xe
700a5818: e7ff         	b	0x700a581a <CSL_pktdmaAccessChanPeerReg+0x2a> @ imm = #-0x2
700a581a: 9807         	ldr	r0, [sp, #0x1c]
700a581c: 9906         	ldr	r1, [sp, #0x18]
700a581e: 9a0a         	ldr	r2, [sp, #0x28]
700a5820: f005 f99e    	bl	0x700aab60 <CSL_pktdmaIsValidChanIdx> @ imm = #0x533c
700a5824: b920         	cbnz	r0, 0x700a5830 <CSL_pktdmaAccessChanPeerReg+0x40> @ imm = #0x8
700a5826: e7ff         	b	0x700a5828 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #-0x2
700a5828: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a582c: 9002         	str	r0, [sp, #0x8]
;     }
700a582e: e037         	b	0x700a58a0 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #0x6e
;         if( regIdx < CSL_PKTDMA_NUM_PEER_REGS )
700a5830: 9805         	ldr	r0, [sp, #0x14]
700a5832: 280f         	cmp	r0, #0xf
700a5834: d82f         	bhi	0x700a5896 <CSL_pktdmaAccessChanPeerReg+0xa6> @ imm = #0x5e
700a5836: e7ff         	b	0x700a5838 <CSL_pktdmaAccessChanPeerReg+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a5838: 980a         	ldr	r0, [sp, #0x28]
700a583a: b960         	cbnz	r0, 0x700a5856 <CSL_pktdmaAccessChanPeerReg+0x66> @ imm = #0x18
700a583c: e7ff         	b	0x700a583e <CSL_pktdmaAccessChanPeerReg+0x4e> @ imm = #-0x2
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pTxChanRtRegs) + (uintptr_t)CSL_PKTDMA_TXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a583e: 9807         	ldr	r0, [sp, #0x1c]
700a5840: 6900         	ldr	r0, [r0, #0x10]
700a5842: 9906         	ldr	r1, [sp, #0x18]
700a5844: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5848: 9905         	ldr	r1, [sp, #0x14]
700a584a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a584e: f500 7000    	add.w	r0, r0, #0x200
700a5852: 9001         	str	r0, [sp, #0x4]
;             }
700a5854: e00b         	b	0x700a586e <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #0x16
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pRxChanRtRegs) + (uintptr_t)CSL_PKTDMA_RXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a5856: 9807         	ldr	r0, [sp, #0x1c]
700a5858: 6940         	ldr	r0, [r0, #0x14]
700a585a: 9906         	ldr	r1, [sp, #0x18]
700a585c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5860: 9905         	ldr	r1, [sp, #0x14]
700a5862: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5866: f500 7000    	add.w	r0, r0, #0x200
700a586a: 9001         	str	r0, [sp, #0x4]
700a586c: e7ff         	b	0x700a586e <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #-0x2
;             if( bRdAccess == (bool)true )
700a586e: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a5872: 07c0         	lsls	r0, r0, #0x1f
700a5874: b130         	cbz	r0, 0x700a5884 <CSL_pktdmaAccessChanPeerReg+0x94> @ imm = #0xc
700a5876: e7ff         	b	0x700a5878 <CSL_pktdmaAccessChanPeerReg+0x88> @ imm = #-0x2
;                 *pVal = CSL_REG32_RD( pPeerReg );
700a5878: 9801         	ldr	r0, [sp, #0x4]
700a587a: f007 ff31    	bl	0x700ad6e0 <CSL_REG32_RD_RAW> @ imm = #0x7e62
700a587e: 9904         	ldr	r1, [sp, #0x10]
700a5880: 6008         	str	r0, [r1]
;             }
700a5882: e005         	b	0x700a5890 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #0xa
;                 CSL_REG32_WR( pPeerReg, *pVal );
700a5884: 9801         	ldr	r0, [sp, #0x4]
700a5886: 9904         	ldr	r1, [sp, #0x10]
700a5888: 6809         	ldr	r1, [r1]
700a588a: f007 fe81    	bl	0x700ad590 <CSL_REG32_WR_RAW> @ imm = #0x7d02
700a588e: e7ff         	b	0x700a5890 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #-0x2
700a5890: 2000         	movs	r0, #0x0
;             retVal = CSL_PASS;
700a5892: 9002         	str	r0, [sp, #0x8]
;         }
700a5894: e003         	b	0x700a589e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #0x6
700a5896: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a589a: 9002         	str	r0, [sp, #0x8]
700a589c: e7ff         	b	0x700a589e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #-0x2
700a589e: e7ff         	b	0x700a58a0 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #-0x2
;     return retVal;
700a58a0: 9802         	ldr	r0, [sp, #0x8]
700a58a2: b008         	add	sp, #0x20
700a58a4: bd80         	pop	{r7, pc}
		...
700a58ae: 0000         	movs	r0, r0

700a58b0 <UART_fifoWrite>:
; {
700a58b0: b580         	push	{r7, lr}
700a58b2: b08c         	sub	sp, #0x30
700a58b4: 900b         	str	r0, [sp, #0x2c]
700a58b6: 910a         	str	r1, [sp, #0x28]
700a58b8: 9209         	str	r2, [sp, #0x24]
;     uint32_t tempWriteSizeRemaining = writeSizeRemaining;
700a58ba: 9809         	ldr	r0, [sp, #0x24]
700a58bc: 9008         	str	r0, [sp, #0x20]
;     uint32_t size                  = tempWriteSizeRemaining;
700a58be: 9808         	ldr	r0, [sp, #0x20]
700a58c0: 9007         	str	r0, [sp, #0x1c]
;     const uint8_t *tempBuffer = buffer;
700a58c2: 980a         	ldr	r0, [sp, #0x28]
700a58c4: 9006         	str	r0, [sp, #0x18]
700a58c6: 2000         	movs	r0, #0x0
;     uint32_t lineStatus            = 0U;
700a58c8: 9005         	str	r0, [sp, #0x14]
;     uint32_t tempChunksize         = 0U;
700a58ca: 9004         	str	r0, [sp, #0x10]
700a58cc: f640 30b8    	movw	r0, #0xbb8
;     int32_t  maxTrialCount         = (int32_t) UART_TRANSMITEMPTY_TRIALCOUNT;
700a58d0: 9003         	str	r0, [sp, #0xc]
700a58d2: 2040         	movs	r0, #0x40
;     tempChunksize = UART_FIFO_SIZE;
700a58d4: 9004         	str	r0, [sp, #0x10]
;     do
700a58d6: e7ff         	b	0x700a58d8 <UART_fifoWrite+0x28> @ imm = #-0x2
;         lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a58d8: 980b         	ldr	r0, [sp, #0x2c]
700a58da: 6800         	ldr	r0, [r0]
700a58dc: f005 fe60    	bl	0x700ab5a0 <UART_readLineStatus> @ imm = #0x5cc0
700a58e0: 9005         	str	r0, [sp, #0x14]
;         maxTrialCount--;
700a58e2: 9803         	ldr	r0, [sp, #0xc]
700a58e4: 3801         	subs	r0, #0x1
700a58e6: 9003         	str	r0, [sp, #0xc]
;     }
700a58e8: e7ff         	b	0x700a58ea <UART_fifoWrite+0x3a> @ imm = #-0x2
;                        UART_LSR_TX_FIFO_E_MASK) & lineStatus))
700a58ea: 9805         	ldr	r0, [sp, #0x14]
700a58ec: f000 0160    	and	r1, r0, #0x60
700a58f0: 2000         	movs	r0, #0x0
;            && (0 < maxTrialCount));
700a58f2: 2960         	cmp	r1, #0x60
700a58f4: 9002         	str	r0, [sp, #0x8]
700a58f6: d007         	beq	0x700a5908 <UART_fifoWrite+0x58> @ imm = #0xe
700a58f8: e7ff         	b	0x700a58fa <UART_fifoWrite+0x4a> @ imm = #-0x2
700a58fa: 9903         	ldr	r1, [sp, #0xc]
700a58fc: 2000         	movs	r0, #0x0
700a58fe: 2900         	cmp	r1, #0x0
700a5900: bfc8         	it	gt
700a5902: 2001         	movgt	r0, #0x1
700a5904: 9002         	str	r0, [sp, #0x8]
700a5906: e7ff         	b	0x700a5908 <UART_fifoWrite+0x58> @ imm = #-0x2
700a5908: 9802         	ldr	r0, [sp, #0x8]
;     }
700a590a: 07c0         	lsls	r0, r0, #0x1f
700a590c: 2800         	cmp	r0, #0x0
700a590e: d1e3         	bne	0x700a58d8 <UART_fifoWrite+0x28> @ imm = #-0x3a
700a5910: e7ff         	b	0x700a5912 <UART_fifoWrite+0x62> @ imm = #-0x2
;     if (maxTrialCount > 0)
700a5912: 9803         	ldr	r0, [sp, #0xc]
700a5914: 2801         	cmp	r0, #0x1
700a5916: db21         	blt	0x700a595c <UART_fifoWrite+0xac> @ imm = #0x42
700a5918: e7ff         	b	0x700a591a <UART_fifoWrite+0x6a> @ imm = #-0x2
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a591a: e7ff         	b	0x700a591c <UART_fifoWrite+0x6c> @ imm = #-0x2
700a591c: 9904         	ldr	r1, [sp, #0x10]
700a591e: 2000         	movs	r0, #0x0
700a5920: 9001         	str	r0, [sp, #0x4]
700a5922: b131         	cbz	r1, 0x700a5932 <UART_fifoWrite+0x82> @ imm = #0xc
700a5924: e7ff         	b	0x700a5926 <UART_fifoWrite+0x76> @ imm = #-0x2
700a5926: 9808         	ldr	r0, [sp, #0x20]
700a5928: 2800         	cmp	r0, #0x0
700a592a: bf18         	it	ne
700a592c: 2001         	movne	r0, #0x1
700a592e: 9001         	str	r0, [sp, #0x4]
700a5930: e7ff         	b	0x700a5932 <UART_fifoWrite+0x82> @ imm = #-0x2
700a5932: 9801         	ldr	r0, [sp, #0x4]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a5934: 07c0         	lsls	r0, r0, #0x1f
700a5936: b180         	cbz	r0, 0x700a595a <UART_fifoWrite+0xaa> @ imm = #0x20
700a5938: e7ff         	b	0x700a593a <UART_fifoWrite+0x8a> @ imm = #-0x2
;             UART_putChar(hUart->baseAddr, (*tempBuffer));
700a593a: 980b         	ldr	r0, [sp, #0x2c]
700a593c: 6800         	ldr	r0, [r0]
700a593e: 9906         	ldr	r1, [sp, #0x18]
700a5940: 7809         	ldrb	r1, [r1]
700a5942: f007 fcad    	bl	0x700ad2a0 <UART_putChar> @ imm = #0x795a
;             tempBuffer++;
700a5946: 9806         	ldr	r0, [sp, #0x18]
700a5948: 3001         	adds	r0, #0x1
700a594a: 9006         	str	r0, [sp, #0x18]
;             tempWriteSizeRemaining--;
700a594c: 9808         	ldr	r0, [sp, #0x20]
700a594e: 3801         	subs	r0, #0x1
700a5950: 9008         	str	r0, [sp, #0x20]
;             tempChunksize--;
700a5952: 9804         	ldr	r0, [sp, #0x10]
700a5954: 3801         	subs	r0, #0x1
700a5956: 9004         	str	r0, [sp, #0x10]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a5958: e7e0         	b	0x700a591c <UART_fifoWrite+0x6c> @ imm = #-0x40
;     }
700a595a: e7ff         	b	0x700a595c <UART_fifoWrite+0xac> @ imm = #-0x2
;     return (size - tempWriteSizeRemaining);
700a595c: 9807         	ldr	r0, [sp, #0x1c]
700a595e: 9908         	ldr	r1, [sp, #0x20]
700a5960: 1a40         	subs	r0, r0, r1
700a5962: b00c         	add	sp, #0x30
700a5964: bd80         	pop	{r7, pc}
		...
700a596e: 0000         	movs	r0, r0

700a5970 <xTaskPriorityDisinherit>:
; BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder) {
700a5970: b580         	push	{r7, lr}
700a5972: b084         	sub	sp, #0x10
700a5974: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxTCB = pxMutexHolder;
700a5976: 9803         	ldr	r0, [sp, #0xc]
700a5978: 9002         	str	r0, [sp, #0x8]
700a597a: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a597c: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a597e: 9803         	ldr	r0, [sp, #0xc]
700a5980: 2800         	cmp	r0, #0x0
700a5982: d04b         	beq	0x700a5a1c <xTaskPriorityDisinherit+0xac> @ imm = #0x96
700a5984: e7ff         	b	0x700a5986 <xTaskPriorityDisinherit+0x16> @ imm = #-0x2
;     (pxTCB->uxMutexesHeld)--;
700a5986: 9902         	ldr	r1, [sp, #0x8]
700a5988: 6e48         	ldr	r0, [r1, #0x64]
700a598a: 3801         	subs	r0, #0x1
700a598c: 6648         	str	r0, [r1, #0x64]
;     if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
700a598e: 9902         	ldr	r1, [sp, #0x8]
700a5990: 6ac8         	ldr	r0, [r1, #0x2c]
700a5992: 6e09         	ldr	r1, [r1, #0x60]
700a5994: 4288         	cmp	r0, r1
700a5996: d03f         	beq	0x700a5a18 <xTaskPriorityDisinherit+0xa8> @ imm = #0x7e
700a5998: e7ff         	b	0x700a599a <xTaskPriorityDisinherit+0x2a> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
700a599a: 9802         	ldr	r0, [sp, #0x8]
700a599c: 6e40         	ldr	r0, [r0, #0x64]
700a599e: bbc8         	cbnz	r0, 0x700a5a14 <xTaskPriorityDisinherit+0xa4> @ imm = #0x72
700a59a0: e7ff         	b	0x700a59a2 <xTaskPriorityDisinherit+0x32> @ imm = #-0x2
;         if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a59a2: 9802         	ldr	r0, [sp, #0x8]
700a59a4: 3004         	adds	r0, #0x4
700a59a6: f005 fd5b    	bl	0x700ab460 <uxListRemove> @ imm = #0x5ab6
700a59aa: b968         	cbnz	r0, 0x700a59c8 <xTaskPriorityDisinherit+0x58> @ imm = #0x1a
700a59ac: e7ff         	b	0x700a59ae <xTaskPriorityDisinherit+0x3e> @ imm = #-0x2
;           portRESET_READY_PRIORITY(pxTCB->uxPriority, uxTopReadyPriority);
700a59ae: 9802         	ldr	r0, [sp, #0x8]
700a59b0: 6ac1         	ldr	r1, [r0, #0x2c]
700a59b2: 2001         	movs	r0, #0x1
700a59b4: fa00 f201    	lsl.w	r2, r0, r1
700a59b8: f240 11f8    	movw	r1, #0x1f8
700a59bc: f2c7 010b    	movt	r1, #0x700b
700a59c0: 6808         	ldr	r0, [r1]
700a59c2: 4390         	bics	r0, r2
700a59c4: 6008         	str	r0, [r1]
;         } else {
700a59c6: e000         	b	0x700a59ca <xTaskPriorityDisinherit+0x5a> @ imm = #0x0
700a59c8: e7ff         	b	0x700a59ca <xTaskPriorityDisinherit+0x5a> @ imm = #-0x2
;         pxTCB->uxPriority = pxTCB->uxBasePriority;
700a59ca: 9902         	ldr	r1, [sp, #0x8]
700a59cc: 6e08         	ldr	r0, [r1, #0x60]
700a59ce: 62c8         	str	r0, [r1, #0x2c]
;         listSET_LIST_ITEM_VALUE(
700a59d0: 9902         	ldr	r1, [sp, #0x8]
700a59d2: 6ac8         	ldr	r0, [r1, #0x2c]
700a59d4: f1c0 0020    	rsb.w	r0, r0, #0x20
700a59d8: 6188         	str	r0, [r1, #0x18]
;         prvAddTaskToReadyList(pxTCB);
700a59da: 9802         	ldr	r0, [sp, #0x8]
700a59dc: 6ac1         	ldr	r1, [r0, #0x2c]
700a59de: 2001         	movs	r0, #0x1
700a59e0: 9000         	str	r0, [sp]
700a59e2: fa00 f201    	lsl.w	r2, r0, r1
700a59e6: f240 11f8    	movw	r1, #0x1f8
700a59ea: f2c7 010b    	movt	r1, #0x700b
700a59ee: 6808         	ldr	r0, [r1]
700a59f0: 4310         	orrs	r0, r2
700a59f2: 6008         	str	r0, [r1]
700a59f4: 9902         	ldr	r1, [sp, #0x8]
700a59f6: 6ac8         	ldr	r0, [r1, #0x2c]
700a59f8: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a59fc: f244 40f8    	movw	r0, #0x44f8
700a5a00: f2c7 0008    	movt	r0, #0x7008
700a5a04: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a5a08: 3104         	adds	r1, #0x4
700a5a0a: f006 fa99    	bl	0x700abf40 <vListInsertEnd> @ imm = #0x6532
700a5a0e: 9800         	ldr	r0, [sp]
;         xReturn = pdTRUE;
700a5a10: 9001         	str	r0, [sp, #0x4]
;       } else {
700a5a12: e000         	b	0x700a5a16 <xTaskPriorityDisinherit+0xa6> @ imm = #0x0
700a5a14: e7ff         	b	0x700a5a16 <xTaskPriorityDisinherit+0xa6> @ imm = #-0x2
;     } else {
700a5a16: e000         	b	0x700a5a1a <xTaskPriorityDisinherit+0xaa> @ imm = #0x0
700a5a18: e7ff         	b	0x700a5a1a <xTaskPriorityDisinherit+0xaa> @ imm = #-0x2
;   } else {
700a5a1a: e000         	b	0x700a5a1e <xTaskPriorityDisinherit+0xae> @ imm = #0x0
700a5a1c: e7ff         	b	0x700a5a1e <xTaskPriorityDisinherit+0xae> @ imm = #-0x2
;   return xReturn;
700a5a1e: 9801         	ldr	r0, [sp, #0x4]
700a5a20: b004         	add	sp, #0x10
700a5a22: bd80         	pop	{r7, pc}
		...

700a5a30 <Sciclient_getCurrentContext>:
; {
700a5a30: b082         	sub	sp, #0x8
700a5a32: f8ad 0006    	strh.w	r0, [sp, #0x6]
700a5a36: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a5a38: 9000         	str	r0, [sp]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a5a3a: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5a3e: 280a         	cmp	r0, #0xa
700a5a40: d03e         	beq	0x700a5ac0 <Sciclient_getCurrentContext+0x90> @ imm = #0x7c
700a5a42: e7ff         	b	0x700a5a44 <Sciclient_getCurrentContext+0x14> @ imm = #-0x2
;        (TISCI_MSG_SEC_HANDOVER == messageType) ||
700a5a44: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5a48: f249 0130    	movw	r1, #0x9030
700a5a4c: 4288         	cmp	r0, r1
700a5a4e: d037         	beq	0x700a5ac0 <Sciclient_getCurrentContext+0x90> @ imm = #0x6e
700a5a50: e7ff         	b	0x700a5a52 <Sciclient_getCurrentContext+0x22> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG == messageType) ||
700a5a52: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5a56: 280b         	cmp	r0, #0xb
700a5a58: d032         	beq	0x700a5ac0 <Sciclient_getCurrentContext+0x90> @ imm = #0x64
700a5a5a: e7ff         	b	0x700a5a5c <Sciclient_getCurrentContext+0x2c> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_RM == messageType) ||
700a5a5c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5a60: 280c         	cmp	r0, #0xc
700a5a62: d02d         	beq	0x700a5ac0 <Sciclient_getCurrentContext+0x90> @ imm = #0x5a
700a5a64: e7ff         	b	0x700a5a66 <Sciclient_getCurrentContext+0x36> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_SECURITY == messageType) ||
700a5a66: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5a6a: 280d         	cmp	r0, #0xd
700a5a6c: d028         	beq	0x700a5ac0 <Sciclient_getCurrentContext+0x90> @ imm = #0x50
700a5a6e: e7ff         	b	0x700a5a70 <Sciclient_getCurrentContext+0x40> @ imm = #-0x2
;        (TISCI_MSG_KEY_WRITER == messageType) ||
700a5a70: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5a74: f249 0131    	movw	r1, #0x9031
700a5a78: 4288         	cmp	r0, r1
700a5a7a: d021         	beq	0x700a5ac0 <Sciclient_getCurrentContext+0x90> @ imm = #0x42
700a5a7c: e7ff         	b	0x700a5a7e <Sciclient_getCurrentContext+0x4e> @ imm = #-0x2
;        (TISCI_MSG_READ_OTP_MMR == messageType) ||
700a5a7e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5a82: f249 0122    	movw	r1, #0x9022
700a5a86: 4288         	cmp	r0, r1
700a5a88: d01a         	beq	0x700a5ac0 <Sciclient_getCurrentContext+0x90> @ imm = #0x34
700a5a8a: e7ff         	b	0x700a5a8c <Sciclient_getCurrentContext+0x5c> @ imm = #-0x2
;        (TISCI_MSG_WRITE_OTP_ROW == messageType) ||
700a5a8c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5a90: f249 0123    	movw	r1, #0x9023
700a5a94: 4288         	cmp	r0, r1
700a5a96: d013         	beq	0x700a5ac0 <Sciclient_getCurrentContext+0x90> @ imm = #0x26
700a5a98: e7ff         	b	0x700a5a9a <Sciclient_getCurrentContext+0x6a> @ imm = #-0x2
;        (TISCI_MSG_READ_SWREV == messageType) ||
700a5a9a: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5a9e: f249 0133    	movw	r1, #0x9033
700a5aa2: 4288         	cmp	r0, r1
700a5aa4: d00c         	beq	0x700a5ac0 <Sciclient_getCurrentContext+0x90> @ imm = #0x18
700a5aa6: e7ff         	b	0x700a5aa8 <Sciclient_getCurrentContext+0x78> @ imm = #-0x2
;        (TISCI_MSG_WRITE_SWREV == messageType) ||
700a5aa8: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5aac: f249 0132    	movw	r1, #0x9032
700a5ab0: 4288         	cmp	r0, r1
700a5ab2: d005         	beq	0x700a5ac0 <Sciclient_getCurrentContext+0x90> @ imm = #0xa
700a5ab4: e7ff         	b	0x700a5ab6 <Sciclient_getCurrentContext+0x86> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_PM == messageType))
700a5ab6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a5aba: 280e         	cmp	r0, #0xe
700a5abc: d107         	bne	0x700a5ace <Sciclient_getCurrentContext+0x9e> @ imm = #0xe
700a5abe: e7ff         	b	0x700a5ac0 <Sciclient_getCurrentContext+0x90> @ imm = #-0x2
;         retVal = gSciclientHandle.secureContextId;
700a5ac0: f240 1038    	movw	r0, #0x138
700a5ac4: f2c7 000b    	movt	r0, #0x700b
700a5ac8: 68c0         	ldr	r0, [r0, #0xc]
700a5aca: 9000         	str	r0, [sp]
;     }
700a5acc: e006         	b	0x700a5adc <Sciclient_getCurrentContext+0xac> @ imm = #0xc
;         retVal = gSciclientHandle.nonSecureContextId;
700a5ace: f240 1038    	movw	r0, #0x138
700a5ad2: f2c7 000b    	movt	r0, #0x700b
700a5ad6: 6900         	ldr	r0, [r0, #0x10]
700a5ad8: 9000         	str	r0, [sp]
700a5ada: e7ff         	b	0x700a5adc <Sciclient_getCurrentContext+0xac> @ imm = #-0x2
;     return retVal;
700a5adc: 9800         	ldr	r0, [sp]
700a5ade: b002         	add	sp, #0x8
700a5ae0: 4770         	bx	lr
		...
700a5aee: 0000         	movs	r0, r0

700a5af0 <UART_init>:
; {
700a5af0: b580         	push	{r7, lr}
700a5af2: b086         	sub	sp, #0x18
700a5af4: 2000         	movs	r0, #0x0
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a5af6: 9004         	str	r0, [sp, #0x10]
700a5af8: e7ff         	b	0x700a5afa <UART_init+0xa> @ imm = #-0x2
700a5afa: 9804         	ldr	r0, [sp, #0x10]
700a5afc: f240 11bc    	movw	r1, #0x1bc
700a5b00: f2c7 010b    	movt	r1, #0x700b
700a5b04: 6809         	ldr	r1, [r1]
700a5b06: 4288         	cmp	r0, r1
700a5b08: d236         	bhs	0x700a5b78 <UART_init+0x88> @ imm = #0x6c
700a5b0a: e7ff         	b	0x700a5b0c <UART_init+0x1c> @ imm = #-0x2
;         object = gUartConfig[cnt].object;
700a5b0c: 9904         	ldr	r1, [sp, #0x10]
700a5b0e: f240 1080    	movw	r0, #0x180
700a5b12: f2c7 000b    	movt	r0, #0x700b
700a5b16: 9002         	str	r0, [sp, #0x8]
700a5b18: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a5b1c: 6840         	ldr	r0, [r0, #0x4]
700a5b1e: 9003         	str	r0, [sp, #0xc]
;         DebugP_assert(NULL_PTR != object);
700a5b20: 9803         	ldr	r0, [sp, #0xc]
700a5b22: 2800         	cmp	r0, #0x0
700a5b24: bf18         	it	ne
700a5b26: 2001         	movne	r0, #0x1
700a5b28: f64f 017c    	movw	r1, #0xf87c
700a5b2c: f2c7 010a    	movt	r1, #0x700a
700a5b30: 466a         	mov	r2, sp
700a5b32: 6011         	str	r1, [r2]
700a5b34: f64f 01a2    	movw	r1, #0xf8a2
700a5b38: f2c7 010a    	movt	r1, #0x700a
700a5b3c: f64f 1298    	movw	r2, #0xf998
700a5b40: f2c7 020a    	movt	r2, #0x700a
700a5b44: 23bf         	movs	r3, #0xbf
700a5b46: f003 f82b    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x3056
;         (void)memset(object, 0, sizeof(UART_Object));
700a5b4a: 9803         	ldr	r0, [sp, #0xc]
700a5b4c: f44f 715a    	mov.w	r1, #0x368
700a5b50: f7f3 ef70    	blx	0x70099a34 <__aeabi_memclr8> @ imm = #-0xc120
700a5b54: 9802         	ldr	r0, [sp, #0x8]
;         gUartConfig[cnt].attrs->baseAddr = (uint32_t) AddrTranslateP_getLocalAddr((uint64_t)gUartConfig[cnt].attrs->baseAddr);
700a5b56: 9904         	ldr	r1, [sp, #0x10]
700a5b58: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700a5b5c: 6800         	ldr	r0, [r0]
700a5b5e: 2100         	movs	r1, #0x0
700a5b60: f7fe f86e    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x1f24
700a5b64: 9902         	ldr	r1, [sp, #0x8]
700a5b66: 9a04         	ldr	r2, [sp, #0x10]
700a5b68: f851 1032    	ldr.w	r1, [r1, r2, lsl #3]
700a5b6c: 6008         	str	r0, [r1]
;     }
700a5b6e: e7ff         	b	0x700a5b70 <UART_init+0x80> @ imm = #-0x2
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a5b70: 9804         	ldr	r0, [sp, #0x10]
700a5b72: 3001         	adds	r0, #0x1
700a5b74: 9004         	str	r0, [sp, #0x10]
700a5b76: e7c0         	b	0x700a5afa <UART_init+0xa> @ imm = #-0x80
;     status = SemaphoreP_constructMutex(&gUartDrvObj.lockObj);
700a5b78: f64f 7050    	movw	r0, #0xff50
700a5b7c: f2c7 000a    	movt	r0, #0x700a
700a5b80: 3004         	adds	r0, #0x4
700a5b82: f003 fcdd    	bl	0x700a9540 <SemaphoreP_constructMutex> @ imm = #0x39ba
700a5b86: 9005         	str	r0, [sp, #0x14]
;     if(SystemP_SUCCESS == status)
700a5b88: 9805         	ldr	r0, [sp, #0x14]
700a5b8a: b938         	cbnz	r0, 0x700a5b9c <UART_init+0xac> @ imm = #0xe
700a5b8c: e7ff         	b	0x700a5b8e <UART_init+0x9e> @ imm = #-0x2
;         gUartDrvObj.lock = &gUartDrvObj.lockObj;
700a5b8e: f64f 7150    	movw	r1, #0xff50
700a5b92: f2c7 010a    	movt	r1, #0x700a
700a5b96: 1d08         	adds	r0, r1, #0x4
700a5b98: 6008         	str	r0, [r1]
;     }
700a5b9a: e7ff         	b	0x700a5b9c <UART_init+0xac> @ imm = #-0x2
;     return;
700a5b9c: b006         	add	sp, #0x18
700a5b9e: bd80         	pop	{r7, pc}

700a5ba0 <Udma_chCheckParams>:
; {
700a5ba0: b084         	sub	sp, #0x10
700a5ba2: 9003         	str	r0, [sp, #0xc]
700a5ba4: 9102         	str	r1, [sp, #0x8]
700a5ba6: 9201         	str	r2, [sp, #0x4]
700a5ba8: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a5baa: 9000         	str	r0, [sp]
;     if((chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
700a5bac: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a5bb0: 0700         	lsls	r0, r0, #0x1c
700a5bb2: 2800         	cmp	r0, #0x0
700a5bb4: d513         	bpl	0x700a5bde <Udma_chCheckParams+0x3e> @ imm = #0x26
700a5bb6: e7ff         	b	0x700a5bb8 <Udma_chCheckParams+0x18> @ imm = #-0x2
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a5bb8: 9801         	ldr	r0, [sp, #0x4]
700a5bba: 6840         	ldr	r0, [r0, #0x4]
700a5bbc: f510 3f80    	cmn.w	r0, #0x10000
700a5bc0: d008         	beq	0x700a5bd4 <Udma_chCheckParams+0x34> @ imm = #0x10
700a5bc2: e7ff         	b	0x700a5bc4 <Udma_chCheckParams+0x24> @ imm = #-0x2
;            (UDMA_DMA_CH_NA == chPrms->peerChNum))
700a5bc4: 9801         	ldr	r0, [sp, #0x4]
700a5bc6: 6840         	ldr	r0, [r0, #0x4]
700a5bc8: 2102         	movs	r1, #0x2
700a5bca: f6cf 71ff    	movt	r1, #0xffff
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a5bce: 4288         	cmp	r0, r1
700a5bd0: d104         	bne	0x700a5bdc <Udma_chCheckParams+0x3c> @ imm = #0x8
700a5bd2: e7ff         	b	0x700a5bd4 <Udma_chCheckParams+0x34> @ imm = #-0x2
700a5bd4: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5bd8: 9000         	str	r0, [sp]
;         }
700a5bda: e7ff         	b	0x700a5bdc <Udma_chCheckParams+0x3c> @ imm = #-0x2
;     }
700a5bdc: e7ff         	b	0x700a5bde <Udma_chCheckParams+0x3e> @ imm = #-0x2
;     if((chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
700a5bde: f89d 0009    	ldrb.w	r0, [sp, #0x9]
700a5be2: 07c0         	lsls	r0, r0, #0x1f
700a5be4: b388         	cbz	r0, 0x700a5c4a <Udma_chCheckParams+0xaa> @ imm = #0x62
700a5be6: e7ff         	b	0x700a5be8 <Udma_chCheckParams+0x48> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == chPrms->mappedChGrp)
700a5be8: 9801         	ldr	r0, [sp, #0x4]
700a5bea: 6880         	ldr	r0, [r0, #0x8]
700a5bec: 2104         	movs	r1, #0x4
700a5bee: f6cf 71ff    	movt	r1, #0xffff
700a5bf2: 4288         	cmp	r0, r1
700a5bf4: d104         	bne	0x700a5c00 <Udma_chCheckParams+0x60> @ imm = #0x8
700a5bf6: e7ff         	b	0x700a5bf8 <Udma_chCheckParams+0x58> @ imm = #-0x2
700a5bf8: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5bfc: 9000         	str	r0, [sp]
;         }
700a5bfe: e7ff         	b	0x700a5c00 <Udma_chCheckParams+0x60> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a5c00: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a5c04: 07c0         	lsls	r0, r0, #0x1f
700a5c06: b150         	cbz	r0, 0x700a5c1e <Udma_chCheckParams+0x7e> @ imm = #0x14
700a5c08: e7ff         	b	0x700a5c0a <Udma_chCheckParams+0x6a> @ imm = #-0x2
;             if(chPrms->mappedChGrp >= UDMA_NUM_MAPPED_TX_GROUP)
700a5c0a: 9801         	ldr	r0, [sp, #0x4]
700a5c0c: 6880         	ldr	r0, [r0, #0x8]
700a5c0e: 2804         	cmp	r0, #0x4
700a5c10: d304         	blo	0x700a5c1c <Udma_chCheckParams+0x7c> @ imm = #0x8
700a5c12: e7ff         	b	0x700a5c14 <Udma_chCheckParams+0x74> @ imm = #-0x2
700a5c14: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a5c18: 9000         	str	r0, [sp]
;             }
700a5c1a: e7ff         	b	0x700a5c1c <Udma_chCheckParams+0x7c> @ imm = #-0x2
;         }
700a5c1c: e7ff         	b	0x700a5c1e <Udma_chCheckParams+0x7e> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a5c1e: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a5c22: 0780         	lsls	r0, r0, #0x1e
700a5c24: 2800         	cmp	r0, #0x0
700a5c26: d50f         	bpl	0x700a5c48 <Udma_chCheckParams+0xa8> @ imm = #0x1e
700a5c28: e7ff         	b	0x700a5c2a <Udma_chCheckParams+0x8a> @ imm = #-0x2
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a5c2a: 9801         	ldr	r0, [sp, #0x4]
700a5c2c: 6880         	ldr	r0, [r0, #0x8]
700a5c2e: 2804         	cmp	r0, #0x4
700a5c30: d305         	blo	0x700a5c3e <Udma_chCheckParams+0x9e> @ imm = #0xa
700a5c32: e7ff         	b	0x700a5c34 <Udma_chCheckParams+0x94> @ imm = #-0x2
;                (chPrms->mappedChGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a5c34: 9801         	ldr	r0, [sp, #0x4]
700a5c36: 6880         	ldr	r0, [r0, #0x8]
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a5c38: 2808         	cmp	r0, #0x8
700a5c3a: d304         	blo	0x700a5c46 <Udma_chCheckParams+0xa6> @ imm = #0x8
700a5c3c: e7ff         	b	0x700a5c3e <Udma_chCheckParams+0x9e> @ imm = #-0x2
700a5c3e: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a5c42: 9000         	str	r0, [sp]
;             }
700a5c44: e7ff         	b	0x700a5c46 <Udma_chCheckParams+0xa6> @ imm = #-0x2
;         }
700a5c46: e7ff         	b	0x700a5c48 <Udma_chCheckParams+0xa8> @ imm = #-0x2
;     }
700a5c48: e7ff         	b	0x700a5c4a <Udma_chCheckParams+0xaa> @ imm = #-0x2
;     return (retVal);
700a5c4a: 9800         	ldr	r0, [sp]
700a5c4c: b004         	add	sp, #0x10
700a5c4e: 4770         	bx	lr

700a5c50 <Udma_getMappedChRingAttributes>:
; {
700a5c50: b087         	sub	sp, #0x1c
700a5c52: 9006         	str	r0, [sp, #0x18]
700a5c54: 9105         	str	r1, [sp, #0x14]
700a5c56: 9204         	str	r2, [sp, #0x10]
700a5c58: 9303         	str	r3, [sp, #0xc]
700a5c5a: 2000         	movs	r0, #0x0
;     uint32_t index = 0U;
700a5c5c: 9001         	str	r0, [sp, #0x4]
;     int32_t retVal = UDMA_SOK;
700a5c5e: 9000         	str	r0, [sp]
;     if(mappedGrp < UDMA_NUM_MAPPED_TX_GROUP) /* Mapped TX Channel */
700a5c60: 9805         	ldr	r0, [sp, #0x14]
700a5c62: 2803         	cmp	r0, #0x3
700a5c64: d81e         	bhi	0x700a5ca4 <Udma_getMappedChRingAttributes+0x54> @ imm = #0x3c
700a5c66: e7ff         	b	0x700a5c68 <Udma_getMappedChRingAttributes+0x18> @ imm = #-0x2
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a5c68: 9804         	ldr	r0, [sp, #0x10]
700a5c6a: 2810         	cmp	r0, #0x10
700a5c6c: d304         	blo	0x700a5c78 <Udma_getMappedChRingAttributes+0x28> @ imm = #0x8
700a5c6e: e7ff         	b	0x700a5c70 <Udma_getMappedChRingAttributes+0x20> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_TX_CHANS))
700a5c70: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a5c72: 282a         	cmp	r0, #0x2a
700a5c74: d304         	blo	0x700a5c80 <Udma_getMappedChRingAttributes+0x30> @ imm = #0x8
700a5c76: e7ff         	b	0x700a5c78 <Udma_getMappedChRingAttributes+0x28> @ imm = #-0x2
700a5c78: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5c7c: 9000         	str	r0, [sp]
;         }
700a5c7e: e7ff         	b	0x700a5c80 <Udma_getMappedChRingAttributes+0x30> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a5c80: 9800         	ldr	r0, [sp]
700a5c82: b970         	cbnz	r0, 0x700a5ca2 <Udma_getMappedChRingAttributes+0x52> @ imm = #0x1c
700a5c84: e7ff         	b	0x700a5c86 <Udma_getMappedChRingAttributes+0x36> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START;
700a5c86: 9804         	ldr	r0, [sp, #0x10]
700a5c88: 3810         	subs	r0, #0x10
700a5c8a: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaTxMappedChRingAttributes[index];
700a5c8c: 9801         	ldr	r0, [sp, #0x4]
700a5c8e: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a5c92: f64e 60f0    	movw	r0, #0xeef0
700a5c96: f2c7 000a    	movt	r0, #0x700a
700a5c9a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5c9e: 9002         	str	r0, [sp, #0x8]
;         }
700a5ca0: e7ff         	b	0x700a5ca2 <Udma_getMappedChRingAttributes+0x52> @ imm = #-0x2
;     }
700a5ca2: e01d         	b	0x700a5ce0 <Udma_getMappedChRingAttributes+0x90> @ imm = #0x3a
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a5ca4: 9804         	ldr	r0, [sp, #0x10]
700a5ca6: 2810         	cmp	r0, #0x10
700a5ca8: d304         	blo	0x700a5cb4 <Udma_getMappedChRingAttributes+0x64> @ imm = #0x8
700a5caa: e7ff         	b	0x700a5cac <Udma_getMappedChRingAttributes+0x5c> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_RX_CHANS))
700a5cac: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a5cae: 281d         	cmp	r0, #0x1d
700a5cb0: d304         	blo	0x700a5cbc <Udma_getMappedChRingAttributes+0x6c> @ imm = #0x8
700a5cb2: e7ff         	b	0x700a5cb4 <Udma_getMappedChRingAttributes+0x64> @ imm = #-0x2
700a5cb4: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5cb8: 9000         	str	r0, [sp]
;         }
700a5cba: e7ff         	b	0x700a5cbc <Udma_getMappedChRingAttributes+0x6c> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a5cbc: 9800         	ldr	r0, [sp]
700a5cbe: b970         	cbnz	r0, 0x700a5cde <Udma_getMappedChRingAttributes+0x8e> @ imm = #0x1c
700a5cc0: e7ff         	b	0x700a5cc2 <Udma_getMappedChRingAttributes+0x72> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START;
700a5cc2: 9804         	ldr	r0, [sp, #0x10]
700a5cc4: 3810         	subs	r0, #0x10
700a5cc6: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaRxMappedChRingAttributes[index];
700a5cc8: 9801         	ldr	r0, [sp, #0x4]
700a5cca: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a5cce: f24f 0028    	movw	r0, #0xf028
700a5cd2: f2c7 000a    	movt	r0, #0x700a
700a5cd6: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a5cda: 9002         	str	r0, [sp, #0x8]
;         }
700a5cdc: e7ff         	b	0x700a5cde <Udma_getMappedChRingAttributes+0x8e> @ imm = #-0x2
700a5cde: e7ff         	b	0x700a5ce0 <Udma_getMappedChRingAttributes+0x90> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a5ce0: 9800         	ldr	r0, [sp]
700a5ce2: b948         	cbnz	r0, 0x700a5cf8 <Udma_getMappedChRingAttributes+0xa8> @ imm = #0x12
700a5ce4: e7ff         	b	0x700a5ce6 <Udma_getMappedChRingAttributes+0x96> @ imm = #-0x2
;         (void) memcpy(chAttr, mappedChRingAttributes, sizeof (Udma_MappedChRingAttributes));
700a5ce6: 9903         	ldr	r1, [sp, #0xc]
700a5ce8: 9b02         	ldr	r3, [sp, #0x8]
700a5cea: 6818         	ldr	r0, [r3]
700a5cec: 685a         	ldr	r2, [r3, #0x4]
700a5cee: 689b         	ldr	r3, [r3, #0x8]
700a5cf0: 608b         	str	r3, [r1, #0x8]
700a5cf2: 604a         	str	r2, [r1, #0x4]
700a5cf4: 6008         	str	r0, [r1]
;     }
700a5cf6: e7ff         	b	0x700a5cf8 <Udma_getMappedChRingAttributes+0xa8> @ imm = #-0x2
;     return(retVal);
700a5cf8: 9800         	ldr	r0, [sp]
700a5cfa: b007         	add	sp, #0x1c
700a5cfc: 4770         	bx	lr
700a5cfe: 0000         	movs	r0, r0

700a5d00 <prvUnlockQueue>:
; {
700a5d00: b580         	push	{r7, lr}
700a5d02: b082         	sub	sp, #0x8
700a5d04: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700a5d06: f006 fb73    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0x66e6
;         int8_t cTxLock = pxQueue->cTxLock;
700a5d0a: 9801         	ldr	r0, [sp, #0x4]
700a5d0c: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a5d10: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a5d14: e7ff         	b	0x700a5d16 <prvUnlockQueue+0x16> @ imm = #-0x2
700a5d16: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a5d1a: 2801         	cmp	r0, #0x1
700a5d1c: db16         	blt	0x700a5d4c <prvUnlockQueue+0x4c> @ imm = #0x2c
700a5d1e: e7ff         	b	0x700a5d20 <prvUnlockQueue+0x20> @ imm = #-0x2
;                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a5d20: 9801         	ldr	r0, [sp, #0x4]
700a5d22: 6a40         	ldr	r0, [r0, #0x24]
700a5d24: b158         	cbz	r0, 0x700a5d3e <prvUnlockQueue+0x3e> @ imm = #0x16
700a5d26: e7ff         	b	0x700a5d28 <prvUnlockQueue+0x28> @ imm = #-0x2
;                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a5d28: 9801         	ldr	r0, [sp, #0x4]
700a5d2a: 3024         	adds	r0, #0x24
700a5d2c: f000 faa8    	bl	0x700a6280 <xTaskRemoveFromEventList> @ imm = #0x550
700a5d30: b118         	cbz	r0, 0x700a5d3a <prvUnlockQueue+0x3a> @ imm = #0x6
700a5d32: e7ff         	b	0x700a5d34 <prvUnlockQueue+0x34> @ imm = #-0x2
;                             vTaskMissedYield();
700a5d34: f007 fcbc    	bl	0x700ad6b0 <vTaskMissedYield> @ imm = #0x7978
;                         }
700a5d38: e000         	b	0x700a5d3c <prvUnlockQueue+0x3c> @ imm = #0x0
700a5d3a: e7ff         	b	0x700a5d3c <prvUnlockQueue+0x3c> @ imm = #-0x2
;                     }
700a5d3c: e000         	b	0x700a5d40 <prvUnlockQueue+0x40> @ imm = #0x0
;                         break;
700a5d3e: e005         	b	0x700a5d4c <prvUnlockQueue+0x4c> @ imm = #0xa
;             --cTxLock;
700a5d40: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a5d44: 3801         	subs	r0, #0x1
700a5d46: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a5d4a: e7e4         	b	0x700a5d16 <prvUnlockQueue+0x16> @ imm = #-0x38
;         pxQueue->cTxLock = queueUNLOCKED;
700a5d4c: 9901         	ldr	r1, [sp, #0x4]
700a5d4e: 20ff         	movs	r0, #0xff
700a5d50: f881 0045    	strb.w	r0, [r1, #0x45]
;     taskEXIT_CRITICAL();
700a5d54: f005 fc4c    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x5898
;     taskENTER_CRITICAL();
700a5d58: f006 fb4a    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0x6694
;         int8_t cRxLock = pxQueue->cRxLock;
700a5d5c: 9801         	ldr	r0, [sp, #0x4]
700a5d5e: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a5d62: f88d 0002    	strb.w	r0, [sp, #0x2]
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a5d66: e7ff         	b	0x700a5d68 <prvUnlockQueue+0x68> @ imm = #-0x2
700a5d68: f99d 0002    	ldrsb.w	r0, [sp, #0x2]
700a5d6c: 2801         	cmp	r0, #0x1
700a5d6e: db16         	blt	0x700a5d9e <prvUnlockQueue+0x9e> @ imm = #0x2c
700a5d70: e7ff         	b	0x700a5d72 <prvUnlockQueue+0x72> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a5d72: 9801         	ldr	r0, [sp, #0x4]
700a5d74: 6900         	ldr	r0, [r0, #0x10]
700a5d76: b180         	cbz	r0, 0x700a5d9a <prvUnlockQueue+0x9a> @ imm = #0x20
700a5d78: e7ff         	b	0x700a5d7a <prvUnlockQueue+0x7a> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a5d7a: 9801         	ldr	r0, [sp, #0x4]
700a5d7c: 3010         	adds	r0, #0x10
700a5d7e: f000 fa7f    	bl	0x700a6280 <xTaskRemoveFromEventList> @ imm = #0x4fe
700a5d82: b118         	cbz	r0, 0x700a5d8c <prvUnlockQueue+0x8c> @ imm = #0x6
700a5d84: e7ff         	b	0x700a5d86 <prvUnlockQueue+0x86> @ imm = #-0x2
;                     vTaskMissedYield();
700a5d86: f007 fc93    	bl	0x700ad6b0 <vTaskMissedYield> @ imm = #0x7926
;                 }
700a5d8a: e000         	b	0x700a5d8e <prvUnlockQueue+0x8e> @ imm = #0x0
700a5d8c: e7ff         	b	0x700a5d8e <prvUnlockQueue+0x8e> @ imm = #-0x2
;                 --cRxLock;
700a5d8e: f89d 0002    	ldrb.w	r0, [sp, #0x2]
700a5d92: 3801         	subs	r0, #0x1
700a5d94: f88d 0002    	strb.w	r0, [sp, #0x2]
;             }
700a5d98: e000         	b	0x700a5d9c <prvUnlockQueue+0x9c> @ imm = #0x0
;                 break;
700a5d9a: e000         	b	0x700a5d9e <prvUnlockQueue+0x9e> @ imm = #0x0
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a5d9c: e7e4         	b	0x700a5d68 <prvUnlockQueue+0x68> @ imm = #-0x38
;         pxQueue->cRxLock = queueUNLOCKED;
700a5d9e: 9901         	ldr	r1, [sp, #0x4]
700a5da0: 20ff         	movs	r0, #0xff
700a5da2: f881 0044    	strb.w	r0, [r1, #0x44]
;     taskEXIT_CRITICAL();
700a5da6: f005 fc23    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x5846
; }
700a5daa: b002         	add	sp, #0x8
700a5dac: bd80         	pop	{r7, pc}
700a5dae: 0000         	movs	r0, r0

700a5db0 <SemaphoreP_constructBinary>:
; {
700a5db0: b580         	push	{r7, lr}
700a5db2: b086         	sub	sp, #0x18
700a5db4: 9005         	str	r0, [sp, #0x14]
700a5db6: 9104         	str	r1, [sp, #0x10]
700a5db8: 2000         	movs	r0, #0x0
;     SemaphoreP_Struct *pSemaphore = NULL;
700a5dba: 9003         	str	r0, [sp, #0xc]
700a5dbc: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700a5dc0: 9002         	str	r0, [sp, #0x8]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700a5dc2: f24f 3063    	movw	r0, #0xf363
700a5dc6: f2c7 000a    	movt	r0, #0x700a
700a5dca: 4669         	mov	r1, sp
700a5dcc: 6008         	str	r0, [r1]
700a5dce: f24f 51ae    	movw	r1, #0xf5ae
700a5dd2: f2c7 010a    	movt	r1, #0x700a
700a5dd6: f24f 721c    	movw	r2, #0xf71c
700a5dda: f2c7 020a    	movt	r2, #0x700a
700a5dde: 2001         	movs	r0, #0x1
700a5de0: 2332         	movs	r3, #0x32
700a5de2: f002 fedd    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x2dba
;     if(obj != NULL)
700a5de6: 9805         	ldr	r0, [sp, #0x14]
700a5de8: b128         	cbz	r0, 0x700a5df6 <SemaphoreP_constructBinary+0x46> @ imm = #0xa
700a5dea: e7ff         	b	0x700a5dec <SemaphoreP_constructBinary+0x3c> @ imm = #-0x2
;         pSemaphore = (SemaphoreP_Struct *)obj;
700a5dec: 9805         	ldr	r0, [sp, #0x14]
700a5dee: 9003         	str	r0, [sp, #0xc]
700a5df0: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a5df2: 9002         	str	r0, [sp, #0x8]
;     }
700a5df4: e7ff         	b	0x700a5df6 <SemaphoreP_constructBinary+0x46> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a5df6: 9802         	ldr	r0, [sp, #0x8]
700a5df8: bb68         	cbnz	r0, 0x700a5e56 <SemaphoreP_constructBinary+0xa6> @ imm = #0x5a
700a5dfa: e7ff         	b	0x700a5dfc <SemaphoreP_constructBinary+0x4c> @ imm = #-0x2
;         pSemaphore->isRecursiveMutex = 0;
700a5dfc: 9803         	ldr	r0, [sp, #0xc]
700a5dfe: 2200         	movs	r2, #0x0
700a5e00: 6542         	str	r2, [r0, #0x54]
;         pSemaphore->semHndl = xSemaphoreCreateBinaryStatic(&pSemaphore->semObj);
700a5e02: 9b03         	ldr	r3, [sp, #0xc]
700a5e04: 4669         	mov	r1, sp
700a5e06: 2003         	movs	r0, #0x3
700a5e08: 6008         	str	r0, [r1]
700a5e0a: 2001         	movs	r0, #0x1
700a5e0c: 4611         	mov	r1, r2
700a5e0e: f005 faaf    	bl	0x700ab370 <xQueueGenericCreateStatic> @ imm = #0x555e
700a5e12: 9903         	ldr	r1, [sp, #0xc]
700a5e14: 6508         	str	r0, [r1, #0x50]
;         if( pSemaphore->semHndl == NULL )
700a5e16: 9803         	ldr	r0, [sp, #0xc]
700a5e18: 6d00         	ldr	r0, [r0, #0x50]
700a5e1a: b920         	cbnz	r0, 0x700a5e26 <SemaphoreP_constructBinary+0x76> @ imm = #0x8
700a5e1c: e7ff         	b	0x700a5e1e <SemaphoreP_constructBinary+0x6e> @ imm = #-0x2
700a5e1e: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
700a5e22: 9002         	str	r0, [sp, #0x8]
;         }
700a5e24: e016         	b	0x700a5e54 <SemaphoreP_constructBinary+0xa4> @ imm = #0x2c
;             vQueueAddToRegistry(pSemaphore->semHndl, "Binary Sem (DPL)");
700a5e26: 9803         	ldr	r0, [sp, #0xc]
700a5e28: 6d00         	ldr	r0, [r0, #0x50]
700a5e2a: f64f 112f    	movw	r1, #0xf92f
700a5e2e: f2c7 010a    	movt	r1, #0x700a
700a5e32: f005 f80d    	bl	0x700aae50 <vQueueAddToRegistry> @ imm = #0x501a
;             if(initCount == 1U)
700a5e36: 9804         	ldr	r0, [sp, #0x10]
700a5e38: 2801         	cmp	r0, #0x1
700a5e3a: d108         	bne	0x700a5e4e <SemaphoreP_constructBinary+0x9e> @ imm = #0x10
700a5e3c: e7ff         	b	0x700a5e3e <SemaphoreP_constructBinary+0x8e> @ imm = #-0x2
;                 (void)xSemaphoreGive(pSemaphore->semHndl);
700a5e3e: 9803         	ldr	r0, [sp, #0xc]
700a5e40: 6d00         	ldr	r0, [r0, #0x50]
700a5e42: 2300         	movs	r3, #0x0
700a5e44: 4619         	mov	r1, r3
700a5e46: 461a         	mov	r2, r3
700a5e48: f7fb fb62    	bl	0x700a1510 <xQueueGenericSend> @ imm = #-0x493c
;             }
700a5e4c: e7ff         	b	0x700a5e4e <SemaphoreP_constructBinary+0x9e> @ imm = #-0x2
700a5e4e: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700a5e50: 9002         	str	r0, [sp, #0x8]
700a5e52: e7ff         	b	0x700a5e54 <SemaphoreP_constructBinary+0xa4> @ imm = #-0x2
;     }
700a5e54: e7ff         	b	0x700a5e56 <SemaphoreP_constructBinary+0xa6> @ imm = #-0x2
;     return status;
700a5e56: 9802         	ldr	r0, [sp, #0x8]
700a5e58: b006         	add	sp, #0x18
700a5e5a: bd80         	pop	{r7, pc}
700a5e5c: 0000         	movs	r0, r0
700a5e5e: 0000         	movs	r0, r0

700a5e60 <System_init>:
; {
700a5e60: b510         	push	{r4, lr}
;     HwiP_init();
700a5e62: f007 fedd    	bl	0x700adc20 <HwiP_init>  @ imm = #0x7dba
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_ERROR);
700a5e66: 2002         	movs	r0, #0x2
700a5e68: f006 fc82    	bl	0x700ac770 <DebugP_logZoneEnable> @ imm = #0x6904
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_WARN);
700a5e6c: 2004         	movs	r0, #0x4
700a5e6e: f006 fc7f    	bl	0x700ac770 <DebugP_logZoneEnable> @ imm = #0x68fe
;     DebugP_memLogWriterInit(CSL_CORE_ID_R5FSS0_0);
700a5e72: 2001         	movs	r0, #0x1
700a5e74: f007 f894    	bl	0x700acfa0 <DebugP_memLogWriterInit> @ imm = #0x7128
;     DebugP_uartSetDrvIndex(CONFIG_UART_CONSOLE);
700a5e78: 2000         	movs	r0, #0x0
700a5e7a: 2400         	movs	r4, #0x0
700a5e7c: f007 fae0    	bl	0x700ad440 <DebugP_uartSetDrvIndex> @ imm = #0x75c0
;     SOC_controlModuleUnlockMMR(SOC_DOMAIN_ID_MAIN, 2);
700a5e80: 2000         	movs	r0, #0x0
700a5e82: 2102         	movs	r1, #0x2
700a5e84: f000 ff4c    	bl	0x700a6d20 <SOC_controlModuleUnlockMMR> @ imm = #0xe98
700a5e88: f248 10d0    	movw	r0, #0x81d0
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700a5e8c: 2102         	movs	r1, #0x2
700a5e8e: f2c4 3000    	movt	r0, #0x4300
;     *(volatile uint32_t*)(TIMER8_CLOCK_SRC_MUX_ADDR) = TIMER8_CLOCK_SRC_MCU_HFOSC0;
700a5e92: 6004         	str	r4, [r0]
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700a5e94: 2000         	movs	r0, #0x0
700a5e96: f002 fa7b    	bl	0x700a8390 <SOC_controlModuleLockMMR> @ imm = #0x24f6
;     ClockP_init();
700a5e9a: f7f8 fd21    	bl	0x7009e8e0 <ClockP_init> @ imm = #-0x75be
;     HwiP_enable();
700a5e9e: f008 ea88    	blx	0x700ae3b0 <HwiP_enable> @ imm = #0x8510
;         retVal = Sciclient_init(CSL_CORE_ID_R5FSS0_0);
700a5ea2: 2001         	movs	r0, #0x1
700a5ea4: f001 fafc    	bl	0x700a74a0 <Sciclient_init> @ imm = #0x15f8
;         DebugP_assertNoLog(SystemP_SUCCESS == retVal);
700a5ea8: fab0 f080    	clz	r0, r0
700a5eac: 0940         	lsrs	r0, r0, #0x5
700a5eae: f008 ff2f    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x8e5e
;     CycleCounterP_init(SOC_getSelfCpuClk());
700a5eb2: f006 ff5d    	bl	0x700acd70 <SOC_getSelfCpuClk> @ imm = #0x6eba
700a5eb6: f000 faeb    	bl	0x700a6490 <CycleCounterP_init> @ imm = #0x5d6
;         status = SOC_moduleClockEnable(gSocModules[i], 1);
700a5eba: 2092         	movs	r0, #0x92
700a5ebc: 2101         	movs	r1, #0x1
700a5ebe: f001 fe0f    	bl	0x700a7ae0 <SOC_moduleClockEnable> @ imm = #0x1c1e
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700a5ec2: fab0 f080    	clz	r0, r0
700a5ec6: 0940         	lsrs	r0, r0, #0x5
700a5ec8: f008 ff22    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x8e44
700a5ecc: f646 4200    	movw	r2, #0x6c00
;             status = SOC_moduleSetClockFrequency(
700a5ed0: 2092         	movs	r0, #0x92
700a5ed2: f2c0 22dc    	movt	r2, #0x2dc
700a5ed6: 2100         	movs	r1, #0x0
700a5ed8: 2300         	movs	r3, #0x0
700a5eda: f7f7 fff1    	bl	0x7009dec0 <SOC_moduleSetClockFrequency> @ imm = #-0x801e
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700a5ede: fab0 f080    	clz	r0, r0
700a5ee2: 0940         	lsrs	r0, r0, #0x5
700a5ee4: f008 ff14    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x8e28
;     Pinmux_config(gPinMuxMainDomainCfg, PINMUX_DOMAIN_ID_MAIN);
700a5ee8: f240 1020    	movw	r0, #0x120
700a5eec: 2100         	movs	r1, #0x0
700a5eee: f2c7 000b    	movt	r0, #0x700b
700a5ef2: f000 fec5    	bl	0x700a6c80 <Pinmux_config> @ imm = #0xd8a
;     Pinmux_config(gPinMuxMcuDomainCfg, PINMUX_DOMAIN_ID_MCU);
700a5ef6: f240 1070    	movw	r0, #0x170
700a5efa: 2101         	movs	r1, #0x1
700a5efc: f2c7 000b    	movt	r0, #0x700b
700a5f00: f000 febe    	bl	0x700a6c80 <Pinmux_config> @ imm = #0xd7c
;     UART_init();
700a5f04: e8bd 4010    	pop.w	{r4, lr}
700a5f08: f7ff bdf2    	b.w	0x700a5af0 <UART_init>  @ imm = #-0x41c
700a5f0c: 0000         	movs	r0, r0
700a5f0e: 0000         	movs	r0, r0

700a5f10 <UdmaChRxPrms_init>:
; {
700a5f10: b083         	sub	sp, #0xc
700a5f12: 9002         	str	r0, [sp, #0x8]
700a5f14: 9101         	str	r1, [sp, #0x4]
;     if(NULL_PTR != rxPrms)
700a5f16: 9802         	ldr	r0, [sp, #0x8]
700a5f18: 2800         	cmp	r0, #0x0
700a5f1a: d04d         	beq	0x700a5fb8 <UdmaChRxPrms_init+0xa8> @ imm = #0x9a
700a5f1c: e7ff         	b	0x700a5f1e <UdmaChRxPrms_init+0xe> @ imm = #-0x2
;         rxPrms->pauseOnError        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a5f1e: 9902         	ldr	r1, [sp, #0x8]
700a5f20: 2000         	movs	r0, #0x0
700a5f22: 7008         	strb	r0, [r1]
;         rxPrms->addrType            = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a5f24: 9902         	ldr	r1, [sp, #0x8]
700a5f26: 7048         	strb	r0, [r1, #0x1]
;         rxPrms->chanType            = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a5f28: 9902         	ldr	r1, [sp, #0x8]
700a5f2a: 2002         	movs	r0, #0x2
700a5f2c: 7088         	strb	r0, [r1, #0x2]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a5f2e: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a5f32: 0740         	lsls	r0, r0, #0x1d
700a5f34: 2800         	cmp	r0, #0x0
700a5f36: d504         	bpl	0x700a5f42 <UdmaChRxPrms_init+0x32> @ imm = #0x8
700a5f38: e7ff         	b	0x700a5f3a <UdmaChRxPrms_init+0x2a> @ imm = #-0x2
;             rxPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a5f3a: 9902         	ldr	r1, [sp, #0x8]
700a5f3c: 200c         	movs	r0, #0xc
700a5f3e: 7088         	strb	r0, [r1, #0x2]
;         }
700a5f40: e7ff         	b	0x700a5f42 <UdmaChRxPrms_init+0x32> @ imm = #-0x2
;         rxPrms->fetchWordSize       = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a5f42: 9902         	ldr	r1, [sp, #0x8]
700a5f44: 2010         	movs	r0, #0x10
700a5f46: 8088         	strh	r0, [r1, #0x4]
;         rxPrms->busPriority         = UDMA_DEFAULT_RX_CH_BUS_PRIORITY;
700a5f48: 9902         	ldr	r1, [sp, #0x8]
700a5f4a: 2004         	movs	r0, #0x4
700a5f4c: 7188         	strb	r0, [r1, #0x6]
;         rxPrms->busQos              = UDMA_DEFAULT_RX_CH_BUS_QOS;
700a5f4e: 9902         	ldr	r1, [sp, #0x8]
700a5f50: 71c8         	strb	r0, [r1, #0x7]
;         rxPrms->busOrderId          = UDMA_DEFAULT_RX_CH_BUS_ORDERID;
700a5f52: 9802         	ldr	r0, [sp, #0x8]
700a5f54: 2100         	movs	r1, #0x0
700a5f56: 9100         	str	r1, [sp]
700a5f58: 7201         	strb	r1, [r0, #0x8]
;         rxPrms->dmaPriority         = UDMA_DEFAULT_RX_CH_DMA_PRIORITY;
700a5f5a: 9a02         	ldr	r2, [sp, #0x8]
700a5f5c: 2001         	movs	r0, #0x1
700a5f5e: 7250         	strb	r0, [r2, #0x9]
;         rxPrms->flowIdFwRangeStart  = 0U;       /* Reset value - to use default flow */
700a5f60: 9a02         	ldr	r2, [sp, #0x8]
700a5f62: 8151         	strh	r1, [r2, #0xa]
;         rxPrms->flowIdFwRangeCnt    = 0U;       /* Reset value - to use default flow */
700a5f64: 9a02         	ldr	r2, [sp, #0x8]
700a5f66: 8191         	strh	r1, [r2, #0xc]
;         rxPrms->flowEInfoPresent    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;       /* Default no EINFO */
700a5f68: 9a02         	ldr	r2, [sp, #0x8]
700a5f6a: 7391         	strb	r1, [r2, #0xe]
;         rxPrms->flowPsInfoPresent   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;      /* Default no PSINFO */
700a5f6c: 9a02         	ldr	r2, [sp, #0x8]
700a5f6e: 73d1         	strb	r1, [r2, #0xf]
;         rxPrms->flowErrorHandling   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;       /* Default Re-try descriptor allocation operation on starvation error */
700a5f70: 9a02         	ldr	r2, [sp, #0x8]
700a5f72: 7410         	strb	r0, [r2, #0x10]
;         rxPrms->flowSopOffset       = 0U;      /* Default SOP offset is 0 */
700a5f74: 9a02         	ldr	r2, [sp, #0x8]
700a5f76: 7451         	strb	r1, [r2, #0x11]
;         rxPrms->ignoreShortPkts     = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a5f78: 9a02         	ldr	r2, [sp, #0x8]
700a5f7a: 7491         	strb	r1, [r2, #0x12]
;         rxPrms->ignoreLongPkts      = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a5f7c: 9a02         	ldr	r2, [sp, #0x8]
700a5f7e: 74d1         	strb	r1, [r2, #0x13]
;         rxPrms->configDefaultFlow   = TRUE;
700a5f80: 9902         	ldr	r1, [sp, #0x8]
700a5f82: 6148         	str	r0, [r1, #0x14]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a5f84: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a5f88: 0600         	lsls	r0, r0, #0x18
700a5f8a: 2800         	cmp	r0, #0x0
700a5f8c: d504         	bpl	0x700a5f98 <UdmaChRxPrms_init+0x88> @ imm = #0x8
700a5f8e: e7ff         	b	0x700a5f90 <UdmaChRxPrms_init+0x80> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a5f90: 9902         	ldr	r1, [sp, #0x8]
700a5f92: 2003         	movs	r0, #0x3
700a5f94: 7608         	strb	r0, [r1, #0x18]
;         }
700a5f96: e00e         	b	0x700a5fb6 <UdmaChRxPrms_init+0xa6> @ imm = #0x1c
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a5f98: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a5f9c: 0640         	lsls	r0, r0, #0x19
700a5f9e: 2800         	cmp	r0, #0x0
700a5fa0: d504         	bpl	0x700a5fac <UdmaChRxPrms_init+0x9c> @ imm = #0x8
700a5fa2: e7ff         	b	0x700a5fa4 <UdmaChRxPrms_init+0x94> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a5fa4: 9902         	ldr	r1, [sp, #0x8]
700a5fa6: 2003         	movs	r0, #0x3
700a5fa8: 7608         	strb	r0, [r1, #0x18]
;         }
700a5faa: e003         	b	0x700a5fb4 <UdmaChRxPrms_init+0xa4> @ imm = #0x6
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a5fac: 9902         	ldr	r1, [sp, #0x8]
700a5fae: 2001         	movs	r0, #0x1
700a5fb0: 7608         	strb	r0, [r1, #0x18]
700a5fb2: e7ff         	b	0x700a5fb4 <UdmaChRxPrms_init+0xa4> @ imm = #-0x2
700a5fb4: e7ff         	b	0x700a5fb6 <UdmaChRxPrms_init+0xa6> @ imm = #-0x2
;     }
700a5fb6: e7ff         	b	0x700a5fb8 <UdmaChRxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a5fb8: b003         	add	sp, #0xc
700a5fba: 4770         	bx	lr
700a5fbc: 0000         	movs	r0, r0
700a5fbe: 0000         	movs	r0, r0

700a5fc0 <UdmaChTxPrms_init>:
; {
700a5fc0: b082         	sub	sp, #0x8
700a5fc2: 9001         	str	r0, [sp, #0x4]
700a5fc4: 9100         	str	r1, [sp]
;     if(NULL_PTR != txPrms)
700a5fc6: 9801         	ldr	r0, [sp, #0x4]
700a5fc8: 2800         	cmp	r0, #0x0
700a5fca: d04d         	beq	0x700a6068 <UdmaChTxPrms_init+0xa8> @ imm = #0x9a
700a5fcc: e7ff         	b	0x700a5fce <UdmaChTxPrms_init+0xe> @ imm = #-0x2
;         txPrms->pauseOnError    = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a5fce: 9901         	ldr	r1, [sp, #0x4]
700a5fd0: 2000         	movs	r0, #0x0
700a5fd2: 7008         	strb	r0, [r1]
;         txPrms->filterEinfo     = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_EINFO_DISABLED;
700a5fd4: 9901         	ldr	r1, [sp, #0x4]
700a5fd6: 7048         	strb	r0, [r1, #0x1]
;         txPrms->filterPsWords   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_PSWORDS_DISABLED;
700a5fd8: 9901         	ldr	r1, [sp, #0x4]
700a5fda: 7088         	strb	r0, [r1, #0x2]
;         txPrms->addrType        = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a5fdc: 9901         	ldr	r1, [sp, #0x4]
700a5fde: 70c8         	strb	r0, [r1, #0x3]
;         txPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a5fe0: 9901         	ldr	r1, [sp, #0x4]
700a5fe2: 2002         	movs	r0, #0x2
700a5fe4: 7108         	strb	r0, [r1, #0x4]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a5fe6: f89d 0000    	ldrb.w	r0, [sp]
700a5fea: 0740         	lsls	r0, r0, #0x1d
700a5fec: 2800         	cmp	r0, #0x0
700a5fee: d504         	bpl	0x700a5ffa <UdmaChTxPrms_init+0x3a> @ imm = #0x8
700a5ff0: e7ff         	b	0x700a5ff2 <UdmaChTxPrms_init+0x32> @ imm = #-0x2
;             txPrms->chanType    = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a5ff2: 9901         	ldr	r1, [sp, #0x4]
700a5ff4: 200c         	movs	r0, #0xc
700a5ff6: 7108         	strb	r0, [r1, #0x4]
;         }
700a5ff8: e7ff         	b	0x700a5ffa <UdmaChTxPrms_init+0x3a> @ imm = #-0x2
;         txPrms->fetchWordSize   = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a5ffa: 9901         	ldr	r1, [sp, #0x4]
700a5ffc: 2010         	movs	r0, #0x10
700a5ffe: 80c8         	strh	r0, [r1, #0x6]
;         txPrms->busPriority     = UDMA_DEFAULT_TX_CH_BUS_PRIORITY;
700a6000: 9901         	ldr	r1, [sp, #0x4]
700a6002: 2004         	movs	r0, #0x4
700a6004: 7208         	strb	r0, [r1, #0x8]
;         txPrms->busQos          = UDMA_DEFAULT_TX_CH_BUS_QOS;
700a6006: 9901         	ldr	r1, [sp, #0x4]
700a6008: 7248         	strb	r0, [r1, #0x9]
;         txPrms->busOrderId      = UDMA_DEFAULT_TX_CH_BUS_ORDERID;
700a600a: 9901         	ldr	r1, [sp, #0x4]
700a600c: 2000         	movs	r0, #0x0
700a600e: 7288         	strb	r0, [r1, #0xa]
;         txPrms->dmaPriority     = UDMA_DEFAULT_TX_CH_DMA_PRIORITY;
700a6010: 9a01         	ldr	r2, [sp, #0x4]
700a6012: 2101         	movs	r1, #0x1
700a6014: 72d1         	strb	r1, [r2, #0xb]
;         txPrms->txCredit        = 0U;
700a6016: 9901         	ldr	r1, [sp, #0x4]
700a6018: 7308         	strb	r0, [r1, #0xc]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a601a: f89d 0000    	ldrb.w	r0, [sp]
700a601e: ea4f 6000    	lsl.w	r0, r0, #0x18
700a6022: 2800         	cmp	r0, #0x0
700a6024: d507         	bpl	0x700a6036 <UdmaChTxPrms_init+0x76> @ imm = #0xe
700a6026: e7ff         	b	0x700a6028 <UdmaChTxPrms_init+0x68> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_UHC_CHANS_FDEPTH;
700a6028: 9901         	ldr	r1, [sp, #0x4]
700a602a: 2000         	movs	r0, #0x0
700a602c: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a602e: 9901         	ldr	r1, [sp, #0x4]
700a6030: 2003         	movs	r0, #0x3
700a6032: 7408         	strb	r0, [r1, #0x10]
;         }
700a6034: e014         	b	0x700a6060 <UdmaChTxPrms_init+0xa0> @ imm = #0x28
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a6036: f89d 0000    	ldrb.w	r0, [sp]
700a603a: 0640         	lsls	r0, r0, #0x19
700a603c: 2800         	cmp	r0, #0x0
700a603e: d507         	bpl	0x700a6050 <UdmaChTxPrms_init+0x90> @ imm = #0xe
700a6040: e7ff         	b	0x700a6042 <UdmaChTxPrms_init+0x82> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_HC_CHANS_FDEPTH;
700a6042: 9901         	ldr	r1, [sp, #0x4]
700a6044: 2000         	movs	r0, #0x0
700a6046: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a6048: 9901         	ldr	r1, [sp, #0x4]
700a604a: 2003         	movs	r0, #0x3
700a604c: 7408         	strb	r0, [r1, #0x10]
;         }
700a604e: e006         	b	0x700a605e <UdmaChTxPrms_init+0x9e> @ imm = #0xc
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_CHANS_FDEPTH;
700a6050: 9901         	ldr	r1, [sp, #0x4]
700a6052: 20c0         	movs	r0, #0xc0
700a6054: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a6056: 9901         	ldr	r1, [sp, #0x4]
700a6058: 2001         	movs	r0, #0x1
700a605a: 7408         	strb	r0, [r1, #0x10]
700a605c: e7ff         	b	0x700a605e <UdmaChTxPrms_init+0x9e> @ imm = #-0x2
700a605e: e7ff         	b	0x700a6060 <UdmaChTxPrms_init+0xa0> @ imm = #-0x2
;         txPrms->supressTdCqPkt  = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_DISABLED;
700a6060: 9901         	ldr	r1, [sp, #0x4]
700a6062: 2000         	movs	r0, #0x0
700a6064: 7448         	strb	r0, [r1, #0x11]
;     }
700a6066: e7ff         	b	0x700a6068 <UdmaChTxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a6068: b002         	add	sp, #0x8
700a606a: 4770         	bx	lr
700a606c: 0000         	movs	r0, r0
700a606e: 0000         	movs	r0, r0

700a6070 <Udma_chDisable>:
; {
700a6070: b580         	push	{r7, lr}
700a6072: b086         	sub	sp, #0x18
700a6074: 9005         	str	r0, [sp, #0x14]
700a6076: 9104         	str	r1, [sp, #0x10]
700a6078: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a607a: 9003         	str	r0, [sp, #0xc]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a607c: 9805         	ldr	r0, [sp, #0x14]
700a607e: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a6080: 9801         	ldr	r0, [sp, #0x4]
700a6082: b150         	cbz	r0, 0x700a609a <Udma_chDisable+0x2a> @ imm = #0x14
700a6084: e7ff         	b	0x700a6086 <Udma_chDisable+0x16> @ imm = #-0x2
700a6086: 9801         	ldr	r0, [sp, #0x4]
700a6088: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a608c: f64a 31cd    	movw	r1, #0xabcd
700a6090: f6ca 31dc    	movt	r1, #0xabdc
700a6094: 4288         	cmp	r0, r1
700a6096: d004         	beq	0x700a60a2 <Udma_chDisable+0x32> @ imm = #0x8
700a6098: e7ff         	b	0x700a609a <Udma_chDisable+0x2a> @ imm = #-0x2
700a609a: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a609e: 9003         	str	r0, [sp, #0xc]
;     }
700a60a0: e7ff         	b	0x700a60a2 <Udma_chDisable+0x32> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a60a2: 9803         	ldr	r0, [sp, #0xc]
700a60a4: b9a8         	cbnz	r0, 0x700a60d2 <Udma_chDisable+0x62> @ imm = #0x2a
700a60a6: e7ff         	b	0x700a60a8 <Udma_chDisable+0x38> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a60a8: 9801         	ldr	r0, [sp, #0x4]
700a60aa: 6e80         	ldr	r0, [r0, #0x68]
700a60ac: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a60ae: 9802         	ldr	r0, [sp, #0x8]
700a60b0: b150         	cbz	r0, 0x700a60c8 <Udma_chDisable+0x58> @ imm = #0x14
700a60b2: e7ff         	b	0x700a60b4 <Udma_chDisable+0x44> @ imm = #-0x2
700a60b4: 9802         	ldr	r0, [sp, #0x8]
700a60b6: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a60ba: f64a 31cd    	movw	r1, #0xabcd
700a60be: f6ca 31dc    	movt	r1, #0xabdc
700a60c2: 4288         	cmp	r0, r1
700a60c4: d004         	beq	0x700a60d0 <Udma_chDisable+0x60> @ imm = #0x8
700a60c6: e7ff         	b	0x700a60c8 <Udma_chDisable+0x58> @ imm = #-0x2
700a60c8: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a60cc: 9003         	str	r0, [sp, #0xc]
;         }
700a60ce: e7ff         	b	0x700a60d0 <Udma_chDisable+0x60> @ imm = #-0x2
;     }
700a60d0: e7ff         	b	0x700a60d2 <Udma_chDisable+0x62> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a60d2: 9803         	ldr	r0, [sp, #0xc]
700a60d4: b9f8         	cbnz	r0, 0x700a6116 <Udma_chDisable+0xa6> @ imm = #0x3e
700a60d6: e7ff         	b	0x700a60d8 <Udma_chDisable+0x68> @ imm = #-0x2
;         if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a60d8: 9801         	ldr	r0, [sp, #0x4]
700a60da: 7800         	ldrb	r0, [r0]
700a60dc: 0740         	lsls	r0, r0, #0x1d
700a60de: 2800         	cmp	r0, #0x0
700a60e0: d506         	bpl	0x700a60f0 <Udma_chDisable+0x80> @ imm = #0xc
700a60e2: e7ff         	b	0x700a60e4 <Udma_chDisable+0x74> @ imm = #-0x2
;             retVal = Udma_chDisableBlkCpyChan(chHandleInt, timeout);
700a60e4: 9801         	ldr	r0, [sp, #0x4]
700a60e6: 9904         	ldr	r1, [sp, #0x10]
700a60e8: f7f7 fd02    	bl	0x7009daf0 <Udma_chDisableBlkCpyChan> @ imm = #-0x85fc
700a60ec: 9003         	str	r0, [sp, #0xc]
;         }
700a60ee: e011         	b	0x700a6114 <Udma_chDisable+0xa4> @ imm = #0x22
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a60f0: 9801         	ldr	r0, [sp, #0x4]
700a60f2: 7800         	ldrb	r0, [r0]
700a60f4: 07c0         	lsls	r0, r0, #0x1f
700a60f6: b130         	cbz	r0, 0x700a6106 <Udma_chDisable+0x96> @ imm = #0xc
700a60f8: e7ff         	b	0x700a60fa <Udma_chDisable+0x8a> @ imm = #-0x2
;                 retVal = Udma_chDisableTxChan(chHandleInt, timeout);
700a60fa: 9801         	ldr	r0, [sp, #0x4]
700a60fc: 9904         	ldr	r1, [sp, #0x10]
700a60fe: f7f5 f857    	bl	0x7009b1b0 <Udma_chDisableTxChan> @ imm = #-0xaf52
700a6102: 9003         	str	r0, [sp, #0xc]
;             }
700a6104: e005         	b	0x700a6112 <Udma_chDisable+0xa2> @ imm = #0xa
;                 retVal = Udma_chDisableRxChan(chHandleInt, timeout);
700a6106: 9801         	ldr	r0, [sp, #0x4]
700a6108: 9904         	ldr	r1, [sp, #0x10]
700a610a: f7f6 f821    	bl	0x7009c150 <Udma_chDisableRxChan> @ imm = #-0x9fbe
700a610e: 9003         	str	r0, [sp, #0xc]
700a6110: e7ff         	b	0x700a6112 <Udma_chDisable+0xa2> @ imm = #-0x2
700a6112: e7ff         	b	0x700a6114 <Udma_chDisable+0xa4> @ imm = #-0x2
;     }
700a6114: e7ff         	b	0x700a6116 <Udma_chDisable+0xa6> @ imm = #-0x2
;     return (retVal);
700a6116: 9803         	ldr	r0, [sp, #0xc]
700a6118: b006         	add	sp, #0x18
700a611a: bd80         	pop	{r7, pc}
700a611c: 0000         	movs	r0, r0
700a611e: 0000         	movs	r0, r0

700a6120 <CSL_bcdmaChanOpSetChanPause>:
; {
700a6120: b580         	push	{r7, lr}
700a6122: b086         	sub	sp, #0x18
700a6124: 9005         	str	r0, [sp, #0x14]
700a6126: 9104         	str	r1, [sp, #0x10]
700a6128: 9203         	str	r2, [sp, #0xc]
700a612a: f88d 300b    	strb.w	r3, [sp, #0xb]
700a612e: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a6130: 9001         	str	r0, [sp, #0x4]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
700a6132: 9805         	ldr	r0, [sp, #0x14]
700a6134: 9904         	ldr	r1, [sp, #0x10]
700a6136: 9a03         	ldr	r2, [sp, #0xc]
700a6138: f002 fbf2    	bl	0x700a8920 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x27e4
700a613c: b920         	cbnz	r0, 0x700a6148 <CSL_bcdmaChanOpSetChanPause+0x28> @ imm = #0x8
700a613e: e7ff         	b	0x700a6140 <CSL_bcdmaChanOpSetChanPause+0x20> @ imm = #-0x2
700a6140: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a6144: 9001         	str	r0, [sp, #0x4]
;     }
700a6146: e03d         	b	0x700a61c4 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #0x7a
;         switch( chanType )
700a6148: 9804         	ldr	r0, [sp, #0x10]
700a614a: 9000         	str	r0, [sp]
700a614c: b140         	cbz	r0, 0x700a6160 <CSL_bcdmaChanOpSetChanPause+0x40> @ imm = #0x10
700a614e: e7ff         	b	0x700a6150 <CSL_bcdmaChanOpSetChanPause+0x30> @ imm = #-0x2
700a6150: 9800         	ldr	r0, [sp]
700a6152: 2801         	cmp	r0, #0x1
700a6154: d013         	beq	0x700a617e <CSL_bcdmaChanOpSetChanPause+0x5e> @ imm = #0x26
700a6156: e7ff         	b	0x700a6158 <CSL_bcdmaChanOpSetChanPause+0x38> @ imm = #-0x2
700a6158: 9800         	ldr	r0, [sp]
700a615a: 2802         	cmp	r0, #0x2
700a615c: d01e         	beq	0x700a619c <CSL_bcdmaChanOpSetChanPause+0x7c> @ imm = #0x3c
700a615e: e02c         	b	0x700a61ba <CSL_bcdmaChanOpSetChanPause+0x9a> @ imm = #0x58
;                 CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a6160: 9805         	ldr	r0, [sp, #0x14]
700a6162: 6880         	ldr	r0, [r0, #0x8]
700a6164: 9903         	ldr	r1, [sp, #0xc]
700a6166: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a616a: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a616e: f001 0301    	and	r3, r1, #0x1
700a6172: f04f 5100    	mov.w	r1, #0x20000000
700a6176: 221d         	movs	r2, #0x1d
700a6178: f005 ff02    	bl	0x700abf80 <CSL_REG32_FINS_RAW> @ imm = #0x5e04
;                 break;
700a617c: e021         	b	0x700a61c2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x42
;                 CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a617e: 9805         	ldr	r0, [sp, #0x14]
700a6180: 6900         	ldr	r0, [r0, #0x10]
700a6182: 9903         	ldr	r1, [sp, #0xc]
700a6184: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6188: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a618c: f001 0301    	and	r3, r1, #0x1
700a6190: f04f 5100    	mov.w	r1, #0x20000000
700a6194: 221d         	movs	r2, #0x1d
700a6196: f005 fef3    	bl	0x700abf80 <CSL_REG32_FINS_RAW> @ imm = #0x5de6
;                 break;
700a619a: e012         	b	0x700a61c2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x24
;                 CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a619c: 9805         	ldr	r0, [sp, #0x14]
700a619e: 6980         	ldr	r0, [r0, #0x18]
700a61a0: 9903         	ldr	r1, [sp, #0xc]
700a61a2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a61a6: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a61aa: f001 0301    	and	r3, r1, #0x1
700a61ae: f04f 5100    	mov.w	r1, #0x20000000
700a61b2: 221d         	movs	r2, #0x1d
700a61b4: f005 fee4    	bl	0x700abf80 <CSL_REG32_FINS_RAW> @ imm = #0x5dc8
;                 break;
700a61b8: e003         	b	0x700a61c2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x6
700a61ba: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a61be: 9001         	str	r0, [sp, #0x4]
;                 break;
700a61c0: e7ff         	b	0x700a61c2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #-0x2
700a61c2: e7ff         	b	0x700a61c4 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #-0x2
;     return retVal;
700a61c4: 9801         	ldr	r0, [sp, #0x4]
700a61c6: b006         	add	sp, #0x18
700a61c8: bd80         	pop	{r7, pc}
700a61ca: 0000         	movs	r0, r0
700a61cc: 0000         	movs	r0, r0
700a61ce: 0000         	movs	r0, r0

700a61d0 <CSL_bcdmaChanOpSetChanRT>:
; {
700a61d0: b580         	push	{r7, lr}
700a61d2: b088         	sub	sp, #0x20
700a61d4: 9007         	str	r0, [sp, #0x1c]
700a61d6: 9106         	str	r1, [sp, #0x18]
700a61d8: 9205         	str	r2, [sp, #0x14]
700a61da: 9304         	str	r3, [sp, #0x10]
700a61dc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a61de: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a61e0: 9804         	ldr	r0, [sp, #0x10]
700a61e2: b920         	cbnz	r0, 0x700a61ee <CSL_bcdmaChanOpSetChanRT+0x1e> @ imm = #0x8
700a61e4: e7ff         	b	0x700a61e6 <CSL_bcdmaChanOpSetChanRT+0x16> @ imm = #-0x2
700a61e6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a61ea: 9003         	str	r0, [sp, #0xc]
;     }
700a61ec: e042         	b	0x700a6274 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #0x84
;         CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a61ee: 9804         	ldr	r0, [sp, #0x10]
700a61f0: 9001         	str	r0, [sp, #0x4]
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a61f2: 9801         	ldr	r0, [sp, #0x4]
700a61f4: 6803         	ldr	r3, [r0]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a61f6: f8d0 c004    	ldr.w	r12, [r0, #0x4]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a61fa: 6881         	ldr	r1, [r0, #0x8]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a61fc: 6902         	ldr	r2, [r0, #0x10]
700a61fe: f04f 4080    	mov.w	r0, #0x40000000
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a6202: ea00 708c    	and.w	r0, r0, r12, lsl #30
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a6206: ea40 70c3    	orr.w	r0, r0, r3, lsl #31
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a620a: f002 0201    	and	r2, r2, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a620e: ea40 7002    	orr.w	r0, r0, r2, lsl #28
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a6212: f001 0101    	and	r1, r1, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a6216: ea40 7041    	orr.w	r0, r0, r1, lsl #29
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a621a: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a621c: 9806         	ldr	r0, [sp, #0x18]
700a621e: 9000         	str	r0, [sp]
700a6220: b140         	cbz	r0, 0x700a6234 <CSL_bcdmaChanOpSetChanRT+0x64> @ imm = #0x10
700a6222: e7ff         	b	0x700a6224 <CSL_bcdmaChanOpSetChanRT+0x54> @ imm = #-0x2
700a6224: 9800         	ldr	r0, [sp]
700a6226: 2801         	cmp	r0, #0x1
700a6228: d00d         	beq	0x700a6246 <CSL_bcdmaChanOpSetChanRT+0x76> @ imm = #0x1a
700a622a: e7ff         	b	0x700a622c <CSL_bcdmaChanOpSetChanRT+0x5c> @ imm = #-0x2
700a622c: 9800         	ldr	r0, [sp]
700a622e: 2802         	cmp	r0, #0x2
700a6230: d012         	beq	0x700a6258 <CSL_bcdmaChanOpSetChanRT+0x88> @ imm = #0x24
700a6232: e01a         	b	0x700a626a <CSL_bcdmaChanOpSetChanRT+0x9a> @ imm = #0x34
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, val );
700a6234: 9807         	ldr	r0, [sp, #0x1c]
700a6236: 6880         	ldr	r0, [r0, #0x8]
700a6238: 9905         	ldr	r1, [sp, #0x14]
700a623a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a623e: 9902         	ldr	r1, [sp, #0x8]
700a6240: f007 f99e    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x733c
;                 break;
700a6244: e015         	b	0x700a6272 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x2a
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, val );
700a6246: 9807         	ldr	r0, [sp, #0x1c]
700a6248: 6900         	ldr	r0, [r0, #0x10]
700a624a: 9905         	ldr	r1, [sp, #0x14]
700a624c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6250: 9902         	ldr	r1, [sp, #0x8]
700a6252: f007 f995    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x732a
;                 break;
700a6256: e00c         	b	0x700a6272 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x18
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, val );
700a6258: 9807         	ldr	r0, [sp, #0x1c]
700a625a: 6980         	ldr	r0, [r0, #0x18]
700a625c: 9905         	ldr	r1, [sp, #0x14]
700a625e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6262: 9902         	ldr	r1, [sp, #0x8]
700a6264: f007 f98c    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x7318
;                 break;
700a6268: e003         	b	0x700a6272 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x6
700a626a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a626e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a6270: e7ff         	b	0x700a6272 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #-0x2
700a6272: e7ff         	b	0x700a6274 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #-0x2
;     return retVal;
700a6274: 9803         	ldr	r0, [sp, #0xc]
700a6276: b008         	add	sp, #0x20
700a6278: bd80         	pop	{r7, pc}
700a627a: 0000         	movs	r0, r0
700a627c: 0000         	movs	r0, r0
700a627e: 0000         	movs	r0, r0

700a6280 <xTaskRemoveFromEventList>:
; BaseType_t xTaskRemoveFromEventList(const List_t *const pxEventList) {
700a6280: b580         	push	{r7, lr}
700a6282: b084         	sub	sp, #0x10
700a6284: 9003         	str	r0, [sp, #0xc]
;   pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a6286: 9803         	ldr	r0, [sp, #0xc]
700a6288: 68c0         	ldr	r0, [r0, #0xc]
700a628a: 68c0         	ldr	r0, [r0, #0xc]
700a628c: 9002         	str	r0, [sp, #0x8]
;   (void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
700a628e: 9802         	ldr	r0, [sp, #0x8]
700a6290: 3018         	adds	r0, #0x18
700a6292: f005 f8e5    	bl	0x700ab460 <uxListRemove> @ imm = #0x51ca
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a6296: f240 10f0    	movw	r0, #0x1f0
700a629a: f2c7 000b    	movt	r0, #0x700b
700a629e: 6800         	ldr	r0, [r0]
700a62a0: bb00         	cbnz	r0, 0x700a62e4 <xTaskRemoveFromEventList+0x64> @ imm = #0x40
700a62a2: e7ff         	b	0x700a62a4 <xTaskRemoveFromEventList+0x24> @ imm = #-0x2
;     (void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
700a62a4: 9802         	ldr	r0, [sp, #0x8]
700a62a6: 3004         	adds	r0, #0x4
700a62a8: f005 f8da    	bl	0x700ab460 <uxListRemove> @ imm = #0x51b4
;     prvAddTaskToReadyList(pxUnblockedTCB);
700a62ac: 9802         	ldr	r0, [sp, #0x8]
700a62ae: 6ac1         	ldr	r1, [r0, #0x2c]
700a62b0: 2001         	movs	r0, #0x1
700a62b2: fa00 f201    	lsl.w	r2, r0, r1
700a62b6: f240 11f8    	movw	r1, #0x1f8
700a62ba: f2c7 010b    	movt	r1, #0x700b
700a62be: 6808         	ldr	r0, [r1]
700a62c0: 4310         	orrs	r0, r2
700a62c2: 6008         	str	r0, [r1]
700a62c4: 9902         	ldr	r1, [sp, #0x8]
700a62c6: 6ac8         	ldr	r0, [r1, #0x2c]
700a62c8: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a62cc: f244 40f8    	movw	r0, #0x44f8
700a62d0: f2c7 0008    	movt	r0, #0x7008
700a62d4: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a62d8: 3104         	adds	r1, #0x4
700a62da: f005 fe31    	bl	0x700abf40 <vListInsertEnd> @ imm = #0x5c62
;       prvResetNextTaskUnblockTime();
700a62de: f005 fdcf    	bl	0x700abe80 <prvResetNextTaskUnblockTime> @ imm = #0x5b9e
;   } else {
700a62e2: e009         	b	0x700a62f8 <xTaskRemoveFromEventList+0x78> @ imm = #0x12
;     vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
700a62e4: 9802         	ldr	r0, [sp, #0x8]
700a62e6: f100 0118    	add.w	r1, r0, #0x18
700a62ea: f644 7068    	movw	r0, #0x4f68
700a62ee: f2c7 0008    	movt	r0, #0x7008
700a62f2: f005 fe25    	bl	0x700abf40 <vListInsertEnd> @ imm = #0x5c4a
700a62f6: e7ff         	b	0x700a62f8 <xTaskRemoveFromEventList+0x78> @ imm = #-0x2
;   if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
700a62f8: 9802         	ldr	r0, [sp, #0x8]
700a62fa: 6ac0         	ldr	r0, [r0, #0x2c]
700a62fc: f240 11cc    	movw	r1, #0x1cc
700a6300: f2c7 010b    	movt	r1, #0x700b
700a6304: 6809         	ldr	r1, [r1]
700a6306: 6ac9         	ldr	r1, [r1, #0x2c]
700a6308: 4288         	cmp	r0, r1
700a630a: d908         	bls	0x700a631e <xTaskRemoveFromEventList+0x9e> @ imm = #0x10
700a630c: e7ff         	b	0x700a630e <xTaskRemoveFromEventList+0x8e> @ imm = #-0x2
700a630e: 2001         	movs	r0, #0x1
;     xReturn = pdTRUE;
700a6310: 9001         	str	r0, [sp, #0x4]
;     xYieldPending = pdTRUE;
700a6312: f240 211c    	movw	r1, #0x21c
700a6316: f2c7 010b    	movt	r1, #0x700b
700a631a: 6008         	str	r0, [r1]
;   } else {
700a631c: e002         	b	0x700a6324 <xTaskRemoveFromEventList+0xa4> @ imm = #0x4
700a631e: 2000         	movs	r0, #0x0
;     xReturn = pdFALSE;
700a6320: 9001         	str	r0, [sp, #0x4]
700a6322: e7ff         	b	0x700a6324 <xTaskRemoveFromEventList+0xa4> @ imm = #-0x2
;   return xReturn;
700a6324: 9801         	ldr	r0, [sp, #0x4]
700a6326: b004         	add	sp, #0x10
700a6328: bd80         	pop	{r7, pc}
700a632a: 0000         	movs	r0, r0
700a632c: 0000         	movs	r0, r0
700a632e: 0000         	movs	r0, r0

700a6330 <Sciclient_rmIrInpRomMapped>:
; {
700a6330: b082         	sub	sp, #0x8
700a6332: 9001         	str	r0, [sp, #0x4]
700a6334: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a6338: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a633a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a633e: 9801         	ldr	r0, [sp, #0x4]
700a6340: 6900         	ldr	r0, [r0, #0x10]
700a6342: 2800         	cmp	r0, #0x0
700a6344: d042         	beq	0x700a63cc <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #0x84
700a6346: e7ff         	b	0x700a6348 <Sciclient_rmIrInpRomMapped+0x18> @ imm = #-0x2
700a6348: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a634a: f88d 0000    	strb.w	r0, [sp]
700a634e: e7ff         	b	0x700a6350 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x2
700a6350: f89d 0000    	ldrb.w	r0, [sp]
700a6354: 9901         	ldr	r1, [sp, #0x4]
700a6356: 7d09         	ldrb	r1, [r1, #0x14]
700a6358: 4288         	cmp	r0, r1
700a635a: da36         	bge	0x700a63ca <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0x6c
700a635c: e7ff         	b	0x700a635e <Sciclient_rmIrInpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a635e: 9801         	ldr	r0, [sp, #0x4]
700a6360: 6900         	ldr	r0, [r0, #0x10]
700a6362: f89d 1000    	ldrb.w	r1, [sp]
700a6366: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a636a: 7980         	ldrb	r0, [r0, #0x6]
700a636c: 07c0         	lsls	r0, r0, #0x1f
700a636e: bb28         	cbnz	r0, 0x700a63bc <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x4a
700a6370: e7ff         	b	0x700a6372 <Sciclient_rmIrInpRomMapped+0x42> @ imm = #-0x2
;                 (inp >= inst->rom_usage[i].inp_start) &&
700a6372: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a6376: 9901         	ldr	r1, [sp, #0x4]
700a6378: 6909         	ldr	r1, [r1, #0x10]
700a637a: f89d 2000    	ldrb.w	r2, [sp]
700a637e: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700a6382: 4288         	cmp	r0, r1
700a6384: db1a         	blt	0x700a63bc <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x34
700a6386: e7ff         	b	0x700a6388 <Sciclient_rmIrInpRomMapped+0x58> @ imm = #-0x2
;                 (inp < (inst->rom_usage[i].inp_start +
700a6388: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a638c: 9901         	ldr	r1, [sp, #0x4]
700a638e: 6909         	ldr	r1, [r1, #0x10]
700a6390: f89d 3000    	ldrb.w	r3, [sp]
700a6394: eb01 02c3    	add.w	r2, r1, r3, lsl #3
700a6398: f831 1033    	ldrh.w	r1, [r1, r3, lsl #3]
;                         inst->rom_usage[i].length))) {
700a639c: 8892         	ldrh	r2, [r2, #0x4]
;                 (inp < (inst->rom_usage[i].inp_start +
700a639e: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a63a0: 4288         	cmp	r0, r1
700a63a2: da0b         	bge	0x700a63bc <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x16
700a63a4: e7ff         	b	0x700a63a6 <Sciclient_rmIrInpRomMapped+0x76> @ imm = #-0x2
700a63a6: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a63a8: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a63ac: 9901         	ldr	r1, [sp, #0x4]
700a63ae: 6909         	ldr	r1, [r1, #0x10]
700a63b0: f89d 2000    	ldrb.w	r2, [sp]
700a63b4: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a63b8: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a63ba: e006         	b	0x700a63ca <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0xc
;         }
700a63bc: e7ff         	b	0x700a63be <Sciclient_rmIrInpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a63be: f89d 0000    	ldrb.w	r0, [sp]
700a63c2: 3001         	adds	r0, #0x1
700a63c4: f88d 0000    	strb.w	r0, [sp]
700a63c8: e7c2         	b	0x700a6350 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x7c
;     }
700a63ca: e7ff         	b	0x700a63cc <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a63cc: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a63d0: f000 0001    	and	r0, r0, #0x1
700a63d4: b002         	add	sp, #0x8
700a63d6: 4770         	bx	lr
		...

700a63e0 <Sciclient_rmIrOutpRomMapped>:
; {
700a63e0: b082         	sub	sp, #0x8
700a63e2: 9001         	str	r0, [sp, #0x4]
700a63e4: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a63e8: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a63ea: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a63ee: 9801         	ldr	r0, [sp, #0x4]
700a63f0: 6900         	ldr	r0, [r0, #0x10]
700a63f2: 2800         	cmp	r0, #0x0
700a63f4: d042         	beq	0x700a647c <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #0x84
700a63f6: e7ff         	b	0x700a63f8 <Sciclient_rmIrOutpRomMapped+0x18> @ imm = #-0x2
700a63f8: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a63fa: f88d 0000    	strb.w	r0, [sp]
700a63fe: e7ff         	b	0x700a6400 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x2
700a6400: f89d 0000    	ldrb.w	r0, [sp]
700a6404: 9901         	ldr	r1, [sp, #0x4]
700a6406: 7d09         	ldrb	r1, [r1, #0x14]
700a6408: 4288         	cmp	r0, r1
700a640a: da36         	bge	0x700a647a <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0x6c
700a640c: e7ff         	b	0x700a640e <Sciclient_rmIrOutpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a640e: 9801         	ldr	r0, [sp, #0x4]
700a6410: 6900         	ldr	r0, [r0, #0x10]
700a6412: f89d 1000    	ldrb.w	r1, [sp]
700a6416: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a641a: 7980         	ldrb	r0, [r0, #0x6]
700a641c: 07c0         	lsls	r0, r0, #0x1f
700a641e: bb28         	cbnz	r0, 0x700a646c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x4a
700a6420: e7ff         	b	0x700a6422 <Sciclient_rmIrOutpRomMapped+0x42> @ imm = #-0x2
;                 (outp >= inst->rom_usage[i].outp_start) &&
700a6422: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a6426: 9901         	ldr	r1, [sp, #0x4]
700a6428: 6909         	ldr	r1, [r1, #0x10]
700a642a: f89d 2000    	ldrb.w	r2, [sp]
700a642e: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a6432: 8849         	ldrh	r1, [r1, #0x2]
700a6434: 4288         	cmp	r0, r1
700a6436: db19         	blt	0x700a646c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x32
700a6438: e7ff         	b	0x700a643a <Sciclient_rmIrOutpRomMapped+0x5a> @ imm = #-0x2
;                 (outp < (inst->rom_usage[i].outp_start +
700a643a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a643e: 9901         	ldr	r1, [sp, #0x4]
700a6440: 6909         	ldr	r1, [r1, #0x10]
700a6442: f89d 2000    	ldrb.w	r2, [sp]
700a6446: eb01 02c2    	add.w	r2, r1, r2, lsl #3
700a644a: 8851         	ldrh	r1, [r2, #0x2]
;                         inst->rom_usage[i].length))) {
700a644c: 8892         	ldrh	r2, [r2, #0x4]
;                 (outp < (inst->rom_usage[i].outp_start +
700a644e: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a6450: 4288         	cmp	r0, r1
700a6452: da0b         	bge	0x700a646c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x16
700a6454: e7ff         	b	0x700a6456 <Sciclient_rmIrOutpRomMapped+0x76> @ imm = #-0x2
700a6456: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a6458: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a645c: 9901         	ldr	r1, [sp, #0x4]
700a645e: 6909         	ldr	r1, [r1, #0x10]
700a6460: f89d 2000    	ldrb.w	r2, [sp]
700a6464: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a6468: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a646a: e006         	b	0x700a647a <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0xc
;         }
700a646c: e7ff         	b	0x700a646e <Sciclient_rmIrOutpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a646e: f89d 0000    	ldrb.w	r0, [sp]
700a6472: 3001         	adds	r0, #0x1
700a6474: f88d 0000    	strb.w	r0, [sp]
700a6478: e7c2         	b	0x700a6400 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x7c
;     }
700a647a: e7ff         	b	0x700a647c <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a647c: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a6480: f000 0001    	and	r0, r0, #0x1
700a6484: b002         	add	sp, #0x8
700a6486: 4770         	bx	lr
		...

700a6490 <CycleCounterP_init>:
; {
700a6490: b580         	push	{r7, lr}
700a6492: b082         	sub	sp, #0x8
700a6494: 9101         	str	r1, [sp, #0x4]
700a6496: 9000         	str	r0, [sp]
;     gCounterFreqHz = cpuFreqHz/PmuP_SETUP_COUNTER_DIVIDER_VAL;
700a6498: 9800         	ldr	r0, [sp]
700a649a: 9a01         	ldr	r2, [sp, #0x4]
700a649c: f240 1188    	movw	r1, #0x188
700a64a0: f2c7 010b    	movt	r1, #0x700b
700a64a4: 604a         	str	r2, [r1, #0x4]
700a64a6: 6008         	str	r0, [r1]
;     CycleCounterP_reset();
700a64a8: f000 f802    	bl	0x700a64b0 <CycleCounterP_reset> @ imm = #0x4
; }
700a64ac: b002         	add	sp, #0x8
700a64ae: bd80         	pop	{r7, pc}

700a64b0 <CycleCounterP_reset>:
; {
700a64b0: b580         	push	{r7, lr}
700a64b2: b082         	sub	sp, #0x8
700a64b4: 2000         	movs	r0, #0x0
;     uint32_t setupFlags = 0;
700a64b6: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_CYCLE_COUNTER_RESET;
700a64b8: 9801         	ldr	r0, [sp, #0x4]
700a64ba: f040 0004    	orr	r0, r0, #0x4
700a64be: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_EVENT_COUNTER_RESET;
700a64c0: 9801         	ldr	r0, [sp, #0x4]
700a64c2: f040 0002    	orr	r0, r0, #0x2
700a64c6: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_ENABLE_ALL_COUNTERS;
700a64c8: 9801         	ldr	r0, [sp, #0x4]
700a64ca: f040 0001    	orr	r0, r0, #0x1
700a64ce: 9001         	str	r0, [sp, #0x4]
700a64d0: f04f 30ff    	mov.w	r0, #0xffffffff
;     PmuP_disableCounters(PmuP_COUNTER_MASK_ALL_COUNTERS); /* disable all counters */
700a64d4: 9000         	str	r0, [sp]
700a64d6: f006 e820    	blx	0x700ac518 <PmuP_disableCounters> @ imm = #0x6040
700a64da: 9800         	ldr	r0, [sp]
;     PmuP_clearOverflowStatus(PmuP_COUNTER_MASK_ALL_COUNTERS); /* clear all overflow flags */
700a64dc: f006 e824    	blx	0x700ac528 <PmuP_clearOverflowStatus> @ imm = #0x6048
;     PmuP_setup(setupFlags); /* setup counters */
700a64e0: 9801         	ldr	r0, [sp, #0x4]
700a64e2: f006 e812    	blx	0x700ac508 <PmuP_setup> @ imm = #0x6024
700a64e6: f04f 4000    	mov.w	r0, #0x80000000
;     PmuP_enableCounters(PmuP_COUNTER_MASK_CYCLE_COUNTER); /* enable cycle counter only */
700a64ea: f006 e812    	blx	0x700ac510 <PmuP_enableCounters> @ imm = #0x6024
; }
700a64ee: b002         	add	sp, #0x8
700a64f0: bd80         	pop	{r7, pc}
700a64f2: bf00         	nop
700a64f4: bf00         	nop
700a64f6: bf00         	nop
700a64f8: bf00         	nop
700a64fa: bf00         	nop
700a64fc: bf00         	nop
700a64fe: bf00         	nop

700a6500 <CycleCounterP_nsToTicks>:
; {
700a6500: b580         	push	{r7, lr}
700a6502: b082         	sub	sp, #0x8
700a6504: 9101         	str	r1, [sp, #0x4]
700a6506: 9000         	str	r0, [sp]
;     return (((uint64_t)nanosecs*gCounterFreqHz)/PmuP_SEC_TO_NANOSEC);
700a6508: 9b00         	ldr	r3, [sp]
700a650a: 9901         	ldr	r1, [sp, #0x4]
700a650c: f240 1088    	movw	r0, #0x188
700a6510: f2c7 000b    	movt	r0, #0x700b
700a6514: 6802         	ldr	r2, [r0]
700a6516: f8d0 c004    	ldr.w	r12, [r0, #0x4]
700a651a: fba3 0e02    	umull	r0, lr, r3, r2
700a651e: fb03 e30c    	mla	r3, r3, r12, lr
700a6522: fb01 3102    	mla	r1, r1, r2, r3
700a6526: f64c 2200    	movw	r2, #0xca00
700a652a: f6c3 329a    	movt	r2, #0x3b9a
700a652e: 2300         	movs	r3, #0x0
700a6530: f006 ec48    	blx	0x700acdc4 <__aeabi_uldivmod> @ imm = #0x6890
700a6534: b002         	add	sp, #0x8
700a6536: bd80         	pop	{r7, pc}
		...

700a6540 <Sciclient_pmGetModuleClkNumParent>:
; {
700a6540: b580         	push	{r7, lr}
700a6542: b096         	sub	sp, #0x58
700a6544: 9015         	str	r0, [sp, #0x54]
700a6546: 9114         	str	r1, [sp, #0x50]
700a6548: 9213         	str	r2, [sp, #0x4c]
700a654a: 9312         	str	r3, [sp, #0x48]
700a654c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a654e: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_num_clock_parents_req request = {{0}};
700a6550: f88d 0040    	strb.w	r0, [sp, #0x40]
700a6554: 900f         	str	r0, [sp, #0x3c]
700a6556: 900e         	str	r0, [sp, #0x38]
700a6558: 900d         	str	r0, [sp, #0x34]
700a655a: 900c         	str	r0, [sp, #0x30]
;     request.device = (uint32_t) moduleId;
700a655c: 9815         	ldr	r0, [sp, #0x54]
700a655e: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a6560: 9814         	ldr	r0, [sp, #0x50]
700a6562: 28ff         	cmp	r0, #0xff
700a6564: d307         	blo	0x700a6576 <Sciclient_pmGetModuleClkNumParent+0x36> @ imm = #0xe
700a6566: e7ff         	b	0x700a6568 <Sciclient_pmGetModuleClkNumParent+0x28> @ imm = #-0x2
;         request.clk32 = clockId;
700a6568: 9814         	ldr	r0, [sp, #0x50]
700a656a: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a656e: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a6570: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a6574: e003         	b	0x700a657e <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a6576: 9814         	ldr	r0, [sp, #0x50]
700a6578: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a657c: e7ff         	b	0x700a657e <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #-0x2
700a657e: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_num_clock_parents_resp response = {{0}};
700a6580: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a6584: 900a         	str	r0, [sp, #0x28]
700a6586: 9009         	str	r0, [sp, #0x24]
700a6588: 9008         	str	r0, [sp, #0x20]
700a658a: f44f 7182    	mov.w	r1, #0x104
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_NUM_CLOCK_PARENTS;
700a658e: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a6592: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a6594: 9104         	str	r1, [sp, #0x10]
700a6596: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a6598: 9105         	str	r1, [sp, #0x14]
700a659a: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a659c: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a659e: 9912         	ldr	r1, [sp, #0x48]
700a65a0: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a65a2: 9000         	str	r0, [sp]
700a65a4: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a65a6: 9001         	str	r0, [sp, #0x4]
700a65a8: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a65aa: 9002         	str	r0, [sp, #0x8]
700a65ac: a803         	add	r0, sp, #0xc
700a65ae: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a65b0: f7f5 fc66    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xa734
700a65b4: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a65b6: 9811         	ldr	r0, [sp, #0x44]
700a65b8: b930         	cbnz	r0, 0x700a65c8 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #0xc
700a65ba: e7ff         	b	0x700a65bc <Sciclient_pmGetModuleClkNumParent+0x7c> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a65bc: 9800         	ldr	r0, [sp]
700a65be: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a65c2: 2802         	cmp	r0, #0x2
700a65c4: d004         	beq	0x700a65d0 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #0x8
700a65c6: e7ff         	b	0x700a65c8 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #-0x2
700a65c8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a65cc: 9011         	str	r0, [sp, #0x44]
;     }
700a65ce: e7ff         	b	0x700a65d0 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a65d0: 9811         	ldr	r0, [sp, #0x44]
700a65d2: b928         	cbnz	r0, 0x700a65e0 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #0xa
700a65d4: e7ff         	b	0x700a65d6 <Sciclient_pmGetModuleClkNumParent+0x96> @ imm = #-0x2
;         *numParent = (uint32_t) response.num_parents;
700a65d6: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a65da: 9913         	ldr	r1, [sp, #0x4c]
700a65dc: 6008         	str	r0, [r1]
;     }
700a65de: e7ff         	b	0x700a65e0 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #-0x2
;     return retVal;
700a65e0: 9811         	ldr	r0, [sp, #0x44]
700a65e2: b016         	add	sp, #0x58
700a65e4: bd80         	pop	{r7, pc}
		...
700a65ee: 0000         	movs	r0, r0

700a65f0 <CSL_intaggrIsIntrPending>:
; {
700a65f0: b580         	push	{r7, lr}
700a65f2: b088         	sub	sp, #0x20
700a65f4: 9007         	str	r0, [sp, #0x1c]
700a65f6: 9106         	str	r1, [sp, #0x18]
700a65f8: f88d 2017    	strb.w	r2, [sp, #0x17]
700a65fc: 2000         	movs	r0, #0x0
;     bool     retVal = (bool)false;
700a65fe: f88d 0016    	strb.w	r0, [sp, #0x16]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700a6602: 9807         	ldr	r0, [sp, #0x1c]
700a6604: 9906         	ldr	r1, [sp, #0x18]
700a6606: f005 fb1b    	bl	0x700abc40 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x5636
700a660a: b3e8         	cbz	r0, 0x700a6688 <CSL_intaggrIsIntrPending+0x98> @ imm = #0x7a
700a660c: e7ff         	b	0x700a660e <CSL_intaggrIsIntrPending+0x1e> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700a660e: 9806         	ldr	r0, [sp, #0x18]
700a6610: 0980         	lsrs	r0, r0, #0x6
700a6612: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700a6614: 9806         	ldr	r0, [sp, #0x18]
700a6616: f000 003f    	and	r0, r0, #0x3f
700a661a: 9000         	str	r0, [sp]
;         if( bMaskedStatus == (bool)true )
700a661c: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a6620: 07c0         	lsls	r0, r0, #0x1f
700a6622: b158         	cbz	r0, 0x700a663c <CSL_intaggrIsIntrPending+0x4c> @ imm = #0x16
700a6624: e7ff         	b	0x700a6626 <CSL_intaggrIsIntrPending+0x36> @ imm = #-0x2
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUSM );
700a6626: 9807         	ldr	r0, [sp, #0x1c]
700a6628: 6880         	ldr	r0, [r0, #0x8]
700a662a: 9901         	ldr	r1, [sp, #0x4]
700a662c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6630: 3020         	adds	r0, #0x20
700a6632: f007 f82d    	bl	0x700ad690 <CSL_REG64_RD_RAW> @ imm = #0x705a
700a6636: 9103         	str	r1, [sp, #0xc]
700a6638: 9002         	str	r0, [sp, #0x8]
;         }
700a663a: e00a         	b	0x700a6652 <CSL_intaggrIsIntrPending+0x62> @ imm = #0x14
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUS_SET );
700a663c: 9807         	ldr	r0, [sp, #0x1c]
700a663e: 6880         	ldr	r0, [r0, #0x8]
700a6640: 9901         	ldr	r1, [sp, #0x4]
700a6642: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6646: 3010         	adds	r0, #0x10
700a6648: f007 f822    	bl	0x700ad690 <CSL_REG64_RD_RAW> @ imm = #0x7044
700a664c: 9103         	str	r1, [sp, #0xc]
700a664e: 9002         	str	r0, [sp, #0x8]
700a6650: e7ff         	b	0x700a6652 <CSL_intaggrIsIntrPending+0x62> @ imm = #-0x2
;         if( (regVal & (((uint64_t)1U) << bitNum)) == 0U )
700a6652: 9802         	ldr	r0, [sp, #0x8]
700a6654: 9903         	ldr	r1, [sp, #0xc]
700a6656: 9a00         	ldr	r2, [sp]
700a6658: 40d0         	lsrs	r0, r2
700a665a: f1c2 0320    	rsb.w	r3, r2, #0x20
700a665e: fa01 f303    	lsl.w	r3, r1, r3
700a6662: 4318         	orrs	r0, r3
700a6664: 3a20         	subs	r2, #0x20
700a6666: 40d1         	lsrs	r1, r2
700a6668: 2a00         	cmp	r2, #0x0
700a666a: bf58         	it	pl
700a666c: 4608         	movpl	r0, r1
700a666e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
700a6672: b920         	cbnz	r0, 0x700a667e <CSL_intaggrIsIntrPending+0x8e> @ imm = #0x8
700a6674: e7ff         	b	0x700a6676 <CSL_intaggrIsIntrPending+0x86> @ imm = #-0x2
700a6676: 2000         	movs	r0, #0x0
;             retVal = (bool)false; /* Interrupt is not pending */
700a6678: f88d 0016    	strb.w	r0, [sp, #0x16]
;         }
700a667c: e003         	b	0x700a6686 <CSL_intaggrIsIntrPending+0x96> @ imm = #0x6
700a667e: 2001         	movs	r0, #0x1
;             retVal = (bool)true;  /* Interrupt is pending */
700a6680: f88d 0016    	strb.w	r0, [sp, #0x16]
700a6684: e7ff         	b	0x700a6686 <CSL_intaggrIsIntrPending+0x96> @ imm = #-0x2
;     }
700a6686: e7ff         	b	0x700a6688 <CSL_intaggrIsIntrPending+0x98> @ imm = #-0x2
;     return retVal;
700a6688: f89d 0016    	ldrb.w	r0, [sp, #0x16]
700a668c: f000 0001    	and	r0, r0, #0x1
700a6690: b008         	add	sp, #0x20
700a6692: bd80         	pop	{r7, pc}
		...

700a66a0 <Sciclient_rmIrqCheckLoop>:
; {
700a66a0: b580         	push	{r7, lr}
700a66a2: b088         	sub	sp, #0x20
700a66a4: 9007         	str	r0, [sp, #0x1c]
700a66a6: 2000         	movs	r0, #0x0
;     bool loop = false;
700a66a8: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a66ac: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a66b0: e7ff         	b	0x700a66b2 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x2
700a66b2: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a66b6: 9002         	str	r0, [sp, #0x8]
700a66b8: f007 f842    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0x7084
700a66bc: 4601         	mov	r1, r0
700a66be: 9802         	ldr	r0, [sp, #0x8]
700a66c0: 4288         	cmp	r0, r1
700a66c2: da39         	bge	0x700a6738 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0x72
700a66c4: e7ff         	b	0x700a66c6 <Sciclient_rmIrqCheckLoop+0x26> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a66c6: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a66ca: f006 fc79    	bl	0x700acfc0 <Sciclient_rmPsGetIrqNode> @ imm = #0x68f2
700a66ce: 9004         	str	r0, [sp, #0x10]
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a66d0: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a66d4: 3001         	adds	r0, #0x1
700a66d6: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a66da: e7ff         	b	0x700a66dc <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x2
700a66dc: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a66e0: 9001         	str	r0, [sp, #0x4]
700a66e2: f007 f82d    	bl	0x700ad740 <Sciclient_rmPsGetPsp> @ imm = #0x705a
700a66e6: 4601         	mov	r1, r0
700a66e8: 9801         	ldr	r0, [sp, #0x4]
700a66ea: 4288         	cmp	r0, r1
700a66ec: da17         	bge	0x700a671e <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0x2e
700a66ee: e7ff         	b	0x700a66f0 <Sciclient_rmIrqCheckLoop+0x50> @ imm = #-0x2
;             future_n = Sciclient_rmPsGetIrqNode(j);
700a66f0: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a66f4: f006 fc64    	bl	0x700acfc0 <Sciclient_rmPsGetIrqNode> @ imm = #0x68c8
700a66f8: 9003         	str	r0, [sp, #0xc]
;             if (cur_n->id == future_n->id) {
700a66fa: 9804         	ldr	r0, [sp, #0x10]
700a66fc: 8800         	ldrh	r0, [r0]
700a66fe: 9903         	ldr	r1, [sp, #0xc]
700a6700: 8809         	ldrh	r1, [r1]
700a6702: 4288         	cmp	r0, r1
700a6704: d104         	bne	0x700a6710 <Sciclient_rmIrqCheckLoop+0x70> @ imm = #0x8
700a6706: e7ff         	b	0x700a6708 <Sciclient_rmIrqCheckLoop+0x68> @ imm = #-0x2
700a6708: 2001         	movs	r0, #0x1
;                 loop = true;
700a670a: f88d 001b    	strb.w	r0, [sp, #0x1b]
;                 break;
700a670e: e006         	b	0x700a671e <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0xc
;         }
700a6710: e7ff         	b	0x700a6712 <Sciclient_rmIrqCheckLoop+0x72> @ imm = #-0x2
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a6712: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a6716: 3001         	adds	r0, #0x1
700a6718: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a671c: e7de         	b	0x700a66dc <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x44
;         if (loop == true) {
700a671e: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a6722: 07c0         	lsls	r0, r0, #0x1f
700a6724: b108         	cbz	r0, 0x700a672a <Sciclient_rmIrqCheckLoop+0x8a> @ imm = #0x2
700a6726: e7ff         	b	0x700a6728 <Sciclient_rmIrqCheckLoop+0x88> @ imm = #-0x2
;             break;
700a6728: e006         	b	0x700a6738 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0xc
;     }
700a672a: e7ff         	b	0x700a672c <Sciclient_rmIrqCheckLoop+0x8c> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a672c: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a6730: 3001         	adds	r0, #0x1
700a6732: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a6736: e7bc         	b	0x700a66b2 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x88
;     return loop;
700a6738: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a673c: f000 0001    	and	r0, r0, #0x1
700a6740: b008         	add	sp, #0x20
700a6742: bd80         	pop	{r7, pc}
		...

700a6750 <UART_IsBaseAddrValid>:
; {
700a6750: b082         	sub	sp, #0x8
700a6752: 9001         	str	r0, [sp, #0x4]
700a6754: f06f 0002    	mvn	r0, #0x2
;     int32_t status = (int32_t)-3;
700a6758: 9000         	str	r0, [sp]
;     if ((baseAddr == CSL_UART0_BASE) ||
700a675a: 9801         	ldr	r0, [sp, #0x4]
700a675c: f1b0 7f20    	cmp.w	r0, #0x2800000
700a6760: d042         	beq	0x700a67e8 <UART_IsBaseAddrValid+0x98> @ imm = #0x84
700a6762: e7ff         	b	0x700a6764 <UART_IsBaseAddrValid+0x14> @ imm = #-0x2
;         (baseAddr == CSL_UART1_BASE) ||
700a6764: 9801         	ldr	r0, [sp, #0x4]
700a6766: 2100         	movs	r1, #0x0
700a6768: f2c0 2181    	movt	r1, #0x281
700a676c: 4288         	cmp	r0, r1
700a676e: d03b         	beq	0x700a67e8 <UART_IsBaseAddrValid+0x98> @ imm = #0x76
700a6770: e7ff         	b	0x700a6772 <UART_IsBaseAddrValid+0x22> @ imm = #-0x2
;         (baseAddr == CSL_UART2_BASE) ||
700a6772: 9801         	ldr	r0, [sp, #0x4]
700a6774: 2100         	movs	r1, #0x0
700a6776: f2c0 2182    	movt	r1, #0x282
700a677a: 4288         	cmp	r0, r1
700a677c: d034         	beq	0x700a67e8 <UART_IsBaseAddrValid+0x98> @ imm = #0x68
700a677e: e7ff         	b	0x700a6780 <UART_IsBaseAddrValid+0x30> @ imm = #-0x2
;         (baseAddr == CSL_UART3_BASE) ||
700a6780: 9801         	ldr	r0, [sp, #0x4]
700a6782: 2100         	movs	r1, #0x0
700a6784: f2c0 2183    	movt	r1, #0x283
700a6788: 4288         	cmp	r0, r1
700a678a: d02d         	beq	0x700a67e8 <UART_IsBaseAddrValid+0x98> @ imm = #0x5a
700a678c: e7ff         	b	0x700a678e <UART_IsBaseAddrValid+0x3e> @ imm = #-0x2
;         (baseAddr == CSL_UART4_BASE) ||
700a678e: 9801         	ldr	r0, [sp, #0x4]
700a6790: f1b0 7f21    	cmp.w	r0, #0x2840000
700a6794: d028         	beq	0x700a67e8 <UART_IsBaseAddrValid+0x98> @ imm = #0x50
700a6796: e7ff         	b	0x700a6798 <UART_IsBaseAddrValid+0x48> @ imm = #-0x2
;         (baseAddr == CSL_UART5_BASE) ||
700a6798: 9801         	ldr	r0, [sp, #0x4]
700a679a: 2100         	movs	r1, #0x0
700a679c: f2c0 2185    	movt	r1, #0x285
700a67a0: 4288         	cmp	r0, r1
700a67a2: d021         	beq	0x700a67e8 <UART_IsBaseAddrValid+0x98> @ imm = #0x42
700a67a4: e7ff         	b	0x700a67a6 <UART_IsBaseAddrValid+0x56> @ imm = #-0x2
;         (baseAddr == CSL_UART6_BASE) ||
700a67a6: 9801         	ldr	r0, [sp, #0x4]
700a67a8: 2100         	movs	r1, #0x0
700a67aa: f2c0 2186    	movt	r1, #0x286
700a67ae: 4288         	cmp	r0, r1
700a67b0: d01a         	beq	0x700a67e8 <UART_IsBaseAddrValid+0x98> @ imm = #0x34
700a67b2: e7ff         	b	0x700a67b4 <UART_IsBaseAddrValid+0x64> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART0_BASE) ||
700a67b4: 9801         	ldr	r0, [sp, #0x4]
700a67b6: f1b0 6f94    	cmp.w	r0, #0x4a00000
700a67ba: d015         	beq	0x700a67e8 <UART_IsBaseAddrValid+0x98> @ imm = #0x2a
700a67bc: e7ff         	b	0x700a67be <UART_IsBaseAddrValid+0x6e> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART1_BASE) ||
700a67be: 9801         	ldr	r0, [sp, #0x4]
700a67c0: 2100         	movs	r1, #0x0
700a67c2: f2c0 41a1    	movt	r1, #0x4a1
700a67c6: 4288         	cmp	r0, r1
700a67c8: d00e         	beq	0x700a67e8 <UART_IsBaseAddrValid+0x98> @ imm = #0x1c
700a67ca: e7ff         	b	0x700a67cc <UART_IsBaseAddrValid+0x7c> @ imm = #-0x2
;         (baseAddr == MCU_UART0_BASE_AFTER_ADDR_TRANSLATE) ||
700a67cc: 9801         	ldr	r0, [sp, #0x4]
700a67ce: 2100         	movs	r1, #0x0
700a67d0: f2c8 41a0    	movt	r1, #0x84a0
700a67d4: 4288         	cmp	r0, r1
700a67d6: d007         	beq	0x700a67e8 <UART_IsBaseAddrValid+0x98> @ imm = #0xe
700a67d8: e7ff         	b	0x700a67da <UART_IsBaseAddrValid+0x8a> @ imm = #-0x2
;         (baseAddr == MCU_UART1_BASE_AFTER_ADDR_TRANSLATE))
700a67da: 9801         	ldr	r0, [sp, #0x4]
700a67dc: 2100         	movs	r1, #0x0
700a67de: f2c8 41a1    	movt	r1, #0x84a1
;     if ((baseAddr == CSL_UART0_BASE) ||
700a67e2: 4288         	cmp	r0, r1
700a67e4: d103         	bne	0x700a67ee <UART_IsBaseAddrValid+0x9e> @ imm = #0x6
700a67e6: e7ff         	b	0x700a67e8 <UART_IsBaseAddrValid+0x98> @ imm = #-0x2
700a67e8: 2000         	movs	r0, #0x0
;         status = 0;
700a67ea: 9000         	str	r0, [sp]
;     }
700a67ec: e7ff         	b	0x700a67ee <UART_IsBaseAddrValid+0x9e> @ imm = #-0x2
;     return status;
700a67ee: 9800         	ldr	r0, [sp]
700a67f0: b002         	add	sp, #0x8
700a67f2: 4770         	bx	lr

700a67f4 <split>:
700a67f4: e92d48f0     	push	{r4, r5, r6, r7, r11, lr}
700a67f8: e1a04000     	mov	r4, r0
700a67fc: e5900000     	ldr	r0, [r0]
700a6800: e1a05001     	mov	r5, r1
700a6804: e3c01001     	bic	r1, r0, #1
700a6808: e0411005     	sub	r1, r1, r5
700a680c: e3510010     	cmp	r1, #16
700a6810: 3a00001b     	blo	0x700a6884 <split+0x90> @ imm = #0x6c
700a6814: e2410008     	sub	r0, r1, #8
700a6818: e0846005     	add	r6, r4, r5
700a681c: e59f106c     	ldr	r1, [pc, #0x6c]         @ 0x700a6890 <split+0x9c>
700a6820: e59f206c     	ldr	r2, [pc, #0x6c]         @ 0x700a6894 <split+0xa0>
700a6824: e5a60008     	str	r0, [r6, #0x8]!
700a6828: e3c00001     	bic	r0, r0, #1
700a682c: e3510007     	cmp	r1, #7
700a6830: e0860000     	add	r0, r6, r0
700a6834: e2807008     	add	r7, r0, #8
700a6838: e0810002     	add	r0, r1, r2
700a683c: 82402008     	subhi	r2, r0, #8
700a6840: e1570002     	cmp	r7, r2
700a6844: 2a00000b     	bhs	0x700a6878 <split+0x84> @ imm = #0x2c
700a6848: e5d70000     	ldrb	r0, [r7]
700a684c: e3100001     	tst	r0, #1
700a6850: 1a000008     	bne	0x700a6878 <split+0x84> @ imm = #0x20
700a6854: e1a00007     	mov	r0, r7
700a6858: eb001685     	bl	0x700ac274 <free_list_remove> @ imm = #0x5a14
700a685c: e5960000     	ldr	r0, [r6]
700a6860: e5971000     	ldr	r1, [r7]
700a6864: e3c00001     	bic	r0, r0, #1
700a6868: e3c11001     	bic	r1, r1, #1
700a686c: e0800001     	add	r0, r0, r1
700a6870: e2800008     	add	r0, r0, #8
700a6874: e5860000     	str	r0, [r6]
700a6878: e1a00006     	mov	r0, r6
700a687c: eb001394     	bl	0x700ab6d4 <free_list_insert> @ imm = #0x4e50
700a6880: e1a00005     	mov	r0, r5
700a6884: e3800001     	orr	r0, r0, #1
700a6888: e5840000     	str	r0, [r4]
700a688c: e8bd88f0     	pop	{r4, r5, r6, r7, r11, pc}
700a6890: 00 00 01 00  	.word	0x00010000
700a6894: 00 50 08 70  	.word	0x70085000
700a6898: 00 00 00 00  	.word	0x00000000
700a689c: 00 00 00 00  	.word	0x00000000

700a68a0 <xQueueGenericSendFromISR>:
; {
700a68a0: b580         	push	{r7, lr}
700a68a2: b08a         	sub	sp, #0x28
700a68a4: 9009         	str	r0, [sp, #0x24]
700a68a6: 9108         	str	r1, [sp, #0x20]
700a68a8: 9207         	str	r2, [sp, #0x1c]
700a68aa: 9306         	str	r3, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a68ac: 9809         	ldr	r0, [sp, #0x24]
700a68ae: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a68b0: f007 ed6e    	blx	0x700ae390 <HwiP_disable> @ imm = #0x7adc
700a68b4: 9004         	str	r0, [sp, #0x10]
;         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a68b6: 9803         	ldr	r0, [sp, #0xc]
700a68b8: 6b80         	ldr	r0, [r0, #0x38]
700a68ba: 9903         	ldr	r1, [sp, #0xc]
700a68bc: 6bc9         	ldr	r1, [r1, #0x3c]
700a68be: 4288         	cmp	r0, r1
700a68c0: d304         	blo	0x700a68cc <xQueueGenericSendFromISR+0x2c> @ imm = #0x8
700a68c2: e7ff         	b	0x700a68c4 <xQueueGenericSendFromISR+0x24> @ imm = #-0x2
700a68c4: 9806         	ldr	r0, [sp, #0x18]
700a68c6: 2802         	cmp	r0, #0x2
700a68c8: d133         	bne	0x700a6932 <xQueueGenericSendFromISR+0x92> @ imm = #0x66
700a68ca: e7ff         	b	0x700a68cc <xQueueGenericSendFromISR+0x2c> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a68cc: 9803         	ldr	r0, [sp, #0xc]
700a68ce: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a68d2: f88d 000b    	strb.w	r0, [sp, #0xb]
;             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
700a68d6: 9803         	ldr	r0, [sp, #0xc]
700a68d8: 6b80         	ldr	r0, [r0, #0x38]
700a68da: 9001         	str	r0, [sp, #0x4]
;             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a68dc: 9803         	ldr	r0, [sp, #0xc]
700a68de: 9908         	ldr	r1, [sp, #0x20]
700a68e0: 9a06         	ldr	r2, [sp, #0x18]
700a68e2: f7fe f855    	bl	0x700a4990 <prvCopyDataToQueue> @ imm = #-0x1f56
;             if( cTxLock == queueUNLOCKED )
700a68e6: f99d 000b    	ldrsb.w	r0, [sp, #0xb]
700a68ea: 3001         	adds	r0, #0x1
700a68ec: b9b8         	cbnz	r0, 0x700a691e <xQueueGenericSendFromISR+0x7e> @ imm = #0x2e
700a68ee: e7ff         	b	0x700a68f0 <xQueueGenericSendFromISR+0x50> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a68f0: 9803         	ldr	r0, [sp, #0xc]
700a68f2: 6a40         	ldr	r0, [r0, #0x24]
700a68f4: b188         	cbz	r0, 0x700a691a <xQueueGenericSendFromISR+0x7a> @ imm = #0x22
700a68f6: e7ff         	b	0x700a68f8 <xQueueGenericSendFromISR+0x58> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a68f8: 9803         	ldr	r0, [sp, #0xc]
700a68fa: 3024         	adds	r0, #0x24
700a68fc: f7ff fcc0    	bl	0x700a6280 <xTaskRemoveFromEventList> @ imm = #-0x680
700a6900: b148         	cbz	r0, 0x700a6916 <xQueueGenericSendFromISR+0x76> @ imm = #0x12
700a6902: e7ff         	b	0x700a6904 <xQueueGenericSendFromISR+0x64> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a6904: 9807         	ldr	r0, [sp, #0x1c]
700a6906: b120         	cbz	r0, 0x700a6912 <xQueueGenericSendFromISR+0x72> @ imm = #0x8
700a6908: e7ff         	b	0x700a690a <xQueueGenericSendFromISR+0x6a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a690a: 9907         	ldr	r1, [sp, #0x1c]
700a690c: 2001         	movs	r0, #0x1
700a690e: 6008         	str	r0, [r1]
;                                 }
700a6910: e000         	b	0x700a6914 <xQueueGenericSendFromISR+0x74> @ imm = #0x0
700a6912: e7ff         	b	0x700a6914 <xQueueGenericSendFromISR+0x74> @ imm = #-0x2
;                             }
700a6914: e000         	b	0x700a6918 <xQueueGenericSendFromISR+0x78> @ imm = #0x0
700a6916: e7ff         	b	0x700a6918 <xQueueGenericSendFromISR+0x78> @ imm = #-0x2
;                         }
700a6918: e000         	b	0x700a691c <xQueueGenericSendFromISR+0x7c> @ imm = #0x0
700a691a: e7ff         	b	0x700a691c <xQueueGenericSendFromISR+0x7c> @ imm = #-0x2
;             }
700a691c: e006         	b	0x700a692c <xQueueGenericSendFromISR+0x8c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a691e: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a6922: 3001         	adds	r0, #0x1
700a6924: 9903         	ldr	r1, [sp, #0xc]
700a6926: f881 0045    	strb.w	r0, [r1, #0x45]
700a692a: e7ff         	b	0x700a692c <xQueueGenericSendFromISR+0x8c> @ imm = #-0x2
700a692c: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a692e: 9005         	str	r0, [sp, #0x14]
;         }
700a6930: e002         	b	0x700a6938 <xQueueGenericSendFromISR+0x98> @ imm = #0x4
700a6932: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a6934: 9005         	str	r0, [sp, #0x14]
700a6936: e7ff         	b	0x700a6938 <xQueueGenericSendFromISR+0x98> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a6938: 9804         	ldr	r0, [sp, #0x10]
700a693a: f007 ed4a    	blx	0x700ae3d0 <HwiP_restore> @ imm = #0x7a94
;     return xReturn;
700a693e: 9805         	ldr	r0, [sp, #0x14]
700a6940: b00a         	add	sp, #0x28
700a6942: bd80         	pop	{r7, pc}
		...

700a6950 <prvCheckForValidListAndQueue>:
;     {
700a6950: b580         	push	{r7, lr}
700a6952: b084         	sub	sp, #0x10
;         taskENTER_CRITICAL();
700a6954: f005 fd4c    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0x5a98
;             if( xTimerQueue == NULL )
700a6958: f240 2014    	movw	r0, #0x214
700a695c: f2c7 000b    	movt	r0, #0x700b
700a6960: 6800         	ldr	r0, [r0]
700a6962: 2800         	cmp	r0, #0x0
700a6964: d140         	bne	0x700a69e8 <prvCheckForValidListAndQueue+0x98> @ imm = #0x80
700a6966: e7ff         	b	0x700a6968 <prvCheckForValidListAndQueue+0x18> @ imm = #-0x2
;                 vListInitialise( &xActiveTimerList1 );
700a6968: f644 7018    	movw	r0, #0x4f18
700a696c: f2c7 0008    	movt	r0, #0x7008
700a6970: 9002         	str	r0, [sp, #0x8]
700a6972: f005 fe85    	bl	0x700ac680 <vListInitialise> @ imm = #0x5d0a
;                 vListInitialise( &xActiveTimerList2 );
700a6976: f644 702c    	movw	r0, #0x4f2c
700a697a: f2c7 0008    	movt	r0, #0x7008
700a697e: 9003         	str	r0, [sp, #0xc]
700a6980: f005 fe7e    	bl	0x700ac680 <vListInitialise> @ imm = #0x5cfc
700a6984: 9902         	ldr	r1, [sp, #0x8]
700a6986: 9803         	ldr	r0, [sp, #0xc]
;                 pxCurrentTimerList = &xActiveTimerList1;
700a6988: f644 72b4    	movw	r2, #0x4fb4
700a698c: f2c7 0208    	movt	r2, #0x7008
700a6990: 6011         	str	r1, [r2]
;                 pxOverflowTimerList = &xActiveTimerList2;
700a6992: f644 71c0    	movw	r1, #0x4fc0
700a6996: f2c7 0108    	movt	r1, #0x7008
700a699a: 6008         	str	r0, [r1]
;                         xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
700a699c: 4669         	mov	r1, sp
700a699e: 2000         	movs	r0, #0x0
700a69a0: 6008         	str	r0, [r1]
700a69a2: f644 1278    	movw	r2, #0x4978
700a69a6: f2c7 0208    	movt	r2, #0x7008
700a69aa: f241 0308    	movw	r3, #0x1008
700a69ae: f2c7 0308    	movt	r3, #0x7008
700a69b2: 2110         	movs	r1, #0x10
700a69b4: 4608         	mov	r0, r1
700a69b6: f004 fcdb    	bl	0x700ab370 <xQueueGenericCreateStatic> @ imm = #0x49b6
700a69ba: 4601         	mov	r1, r0
700a69bc: f240 2014    	movw	r0, #0x214
700a69c0: f2c7 000b    	movt	r0, #0x700b
700a69c4: 6001         	str	r1, [r0]
;                         if( xTimerQueue != NULL )
700a69c6: 6800         	ldr	r0, [r0]
700a69c8: b160         	cbz	r0, 0x700a69e4 <prvCheckForValidListAndQueue+0x94> @ imm = #0x18
700a69ca: e7ff         	b	0x700a69cc <prvCheckForValidListAndQueue+0x7c> @ imm = #-0x2
;                             vQueueAddToRegistry( xTimerQueue, "TmrQ" );
700a69cc: f240 2014    	movw	r0, #0x214
700a69d0: f2c7 000b    	movt	r0, #0x700b
700a69d4: 6800         	ldr	r0, [r0]
700a69d6: f64f 614e    	movw	r1, #0xfe4e
700a69da: f2c7 010a    	movt	r1, #0x700a
700a69de: f004 fa37    	bl	0x700aae50 <vQueueAddToRegistry> @ imm = #0x446e
;                         }
700a69e2: e000         	b	0x700a69e6 <prvCheckForValidListAndQueue+0x96> @ imm = #0x0
700a69e4: e7ff         	b	0x700a69e6 <prvCheckForValidListAndQueue+0x96> @ imm = #-0x2
;             }
700a69e6: e000         	b	0x700a69ea <prvCheckForValidListAndQueue+0x9a> @ imm = #0x0
700a69e8: e7ff         	b	0x700a69ea <prvCheckForValidListAndQueue+0x9a> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a69ea: f004 fe01    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x4c02
;     }
700a69ee: b004         	add	sp, #0x10
700a69f0: bd80         	pop	{r7, pc}
		...
700a69fe: 0000         	movs	r0, r0

700a6a00 <Udma_rmAllocEvent>:
; {
700a6a00: b580         	push	{r7, lr}
700a6a02: b088         	sub	sp, #0x20
700a6a04: 9007         	str	r0, [sp, #0x1c]
700a6a06: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            globalEvent = UDMA_EVENT_INVALID;
700a6a0a: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a6a0c: 9807         	ldr	r0, [sp, #0x1c]
700a6a0e: f500 70ea    	add.w	r0, r0, #0x1d4
700a6a12: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a6a14: 9807         	ldr	r0, [sp, #0x1c]
700a6a16: f500 609f    	add.w	r0, r0, #0x4f8
700a6a1a: f04f 31ff    	mov.w	r1, #0xffffffff
700a6a1e: f001 fe67    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x1cce
700a6a22: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a6a24: 9005         	str	r0, [sp, #0x14]
700a6a26: e7ff         	b	0x700a6a28 <Udma_rmAllocEvent+0x28> @ imm = #-0x2
700a6a28: 9805         	ldr	r0, [sp, #0x14]
700a6a2a: 9901         	ldr	r1, [sp, #0x4]
700a6a2c: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
700a6a30: 4288         	cmp	r0, r1
700a6a32: d22d         	bhs	0x700a6a90 <Udma_rmAllocEvent+0x90> @ imm = #0x5a
700a6a34: e7ff         	b	0x700a6a36 <Udma_rmAllocEvent+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a6a36: 9805         	ldr	r0, [sp, #0x14]
700a6a38: 0940         	lsrs	r0, r0, #0x5
700a6a3a: 9004         	str	r0, [sp, #0x10]
;         bitPos = i - (offset << 5U);
700a6a3c: 9805         	ldr	r0, [sp, #0x14]
700a6a3e: 9904         	ldr	r1, [sp, #0x10]
700a6a40: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a6a44: 9003         	str	r0, [sp, #0xc]
;         bitMask = (uint32_t) 1U << bitPos;
700a6a46: 9903         	ldr	r1, [sp, #0xc]
700a6a48: 2001         	movs	r0, #0x1
700a6a4a: 4088         	lsls	r0, r1
700a6a4c: 9002         	str	r0, [sp, #0x8]
;         if((drvHandle->globalEventFlag[offset] & bitMask) == bitMask)
700a6a4e: 9807         	ldr	r0, [sp, #0x1c]
700a6a50: 9904         	ldr	r1, [sp, #0x10]
700a6a52: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a6a56: f8d0 0424    	ldr.w	r0, [r0, #0x424]
700a6a5a: 9902         	ldr	r1, [sp, #0x8]
700a6a5c: 4008         	ands	r0, r1
700a6a5e: 4288         	cmp	r0, r1
700a6a60: d111         	bne	0x700a6a86 <Udma_rmAllocEvent+0x86> @ imm = #0x22
700a6a62: e7ff         	b	0x700a6a64 <Udma_rmAllocEvent+0x64> @ imm = #-0x2
;             drvHandle->globalEventFlag[offset] &= ~bitMask;
700a6a64: 9a02         	ldr	r2, [sp, #0x8]
700a6a66: 9807         	ldr	r0, [sp, #0x1c]
700a6a68: 9904         	ldr	r1, [sp, #0x10]
700a6a6a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a6a6e: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700a6a72: 4390         	bics	r0, r2
700a6a74: f8c1 0424    	str.w	r0, [r1, #0x424]
;             globalEvent = i + rmInitPrms->startGlobalEvent;  /* Add start offset */
700a6a78: 9805         	ldr	r0, [sp, #0x14]
700a6a7a: 9901         	ldr	r1, [sp, #0x4]
700a6a7c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a6a80: 4408         	add	r0, r1
700a6a82: 9006         	str	r0, [sp, #0x18]
;             break;
700a6a84: e004         	b	0x700a6a90 <Udma_rmAllocEvent+0x90> @ imm = #0x8
;     }
700a6a86: e7ff         	b	0x700a6a88 <Udma_rmAllocEvent+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a6a88: 9805         	ldr	r0, [sp, #0x14]
700a6a8a: 3001         	adds	r0, #0x1
700a6a8c: 9005         	str	r0, [sp, #0x14]
700a6a8e: e7cb         	b	0x700a6a28 <Udma_rmAllocEvent+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a6a90: 9807         	ldr	r0, [sp, #0x1c]
700a6a92: f500 609f    	add.w	r0, r0, #0x4f8
700a6a96: f003 f97b    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x32f6
;     return (globalEvent);
700a6a9a: 9806         	ldr	r0, [sp, #0x18]
700a6a9c: b008         	add	sp, #0x20
700a6a9e: bd80         	pop	{r7, pc}

700a6aa0 <Udma_rmAllocVintr>:
; {
700a6aa0: b580         	push	{r7, lr}
700a6aa2: b088         	sub	sp, #0x20
700a6aa4: 9007         	str	r0, [sp, #0x1c]
700a6aa6: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            vintrNum = UDMA_EVENT_INVALID;
700a6aaa: 9002         	str	r0, [sp, #0x8]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a6aac: 9807         	ldr	r0, [sp, #0x1c]
700a6aae: f500 70ea    	add.w	r0, r0, #0x1d4
700a6ab2: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a6ab4: 9807         	ldr	r0, [sp, #0x1c]
700a6ab6: f500 609f    	add.w	r0, r0, #0x4f8
700a6aba: f04f 31ff    	mov.w	r1, #0xffffffff
700a6abe: f001 fe17    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x1c2e
700a6ac2: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a6ac4: 9006         	str	r0, [sp, #0x18]
700a6ac6: e7ff         	b	0x700a6ac8 <Udma_rmAllocVintr+0x28> @ imm = #-0x2
700a6ac8: 9806         	ldr	r0, [sp, #0x18]
700a6aca: 9901         	ldr	r1, [sp, #0x4]
700a6acc: f8d1 10e4    	ldr.w	r1, [r1, #0xe4]
700a6ad0: 4288         	cmp	r0, r1
700a6ad2: d22d         	bhs	0x700a6b30 <Udma_rmAllocVintr+0x90> @ imm = #0x5a
700a6ad4: e7ff         	b	0x700a6ad6 <Udma_rmAllocVintr+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a6ad6: 9806         	ldr	r0, [sp, #0x18]
700a6ad8: 0940         	lsrs	r0, r0, #0x5
700a6ada: 9005         	str	r0, [sp, #0x14]
;         bitPos = i - (offset << 5U);
700a6adc: 9806         	ldr	r0, [sp, #0x18]
700a6ade: 9905         	ldr	r1, [sp, #0x14]
700a6ae0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a6ae4: 9004         	str	r0, [sp, #0x10]
;         bitMask = (uint32_t) 1U << bitPos;
700a6ae6: 9904         	ldr	r1, [sp, #0x10]
700a6ae8: 2001         	movs	r0, #0x1
700a6aea: 4088         	lsls	r0, r1
700a6aec: 9003         	str	r0, [sp, #0xc]
;         if((drvHandle->vintrFlag[offset] & bitMask) == bitMask)
700a6aee: 9807         	ldr	r0, [sp, #0x1c]
700a6af0: 9905         	ldr	r1, [sp, #0x14]
700a6af2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a6af6: f8d0 04a4    	ldr.w	r0, [r0, #0x4a4]
700a6afa: 9903         	ldr	r1, [sp, #0xc]
700a6afc: 4008         	ands	r0, r1
700a6afe: 4288         	cmp	r0, r1
700a6b00: d111         	bne	0x700a6b26 <Udma_rmAllocVintr+0x86> @ imm = #0x22
700a6b02: e7ff         	b	0x700a6b04 <Udma_rmAllocVintr+0x64> @ imm = #-0x2
;             drvHandle->vintrFlag[offset] &= ~bitMask;
700a6b04: 9a03         	ldr	r2, [sp, #0xc]
700a6b06: 9807         	ldr	r0, [sp, #0x1c]
700a6b08: 9905         	ldr	r1, [sp, #0x14]
700a6b0a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a6b0e: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700a6b12: 4390         	bics	r0, r2
700a6b14: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;             vintrNum = i + rmInitPrms->startVintr;  /* Add start offset */
700a6b18: 9806         	ldr	r0, [sp, #0x18]
700a6b1a: 9901         	ldr	r1, [sp, #0x4]
700a6b1c: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700a6b20: 4408         	add	r0, r1
700a6b22: 9002         	str	r0, [sp, #0x8]
;             break;
700a6b24: e004         	b	0x700a6b30 <Udma_rmAllocVintr+0x90> @ imm = #0x8
;     }
700a6b26: e7ff         	b	0x700a6b28 <Udma_rmAllocVintr+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a6b28: 9806         	ldr	r0, [sp, #0x18]
700a6b2a: 3001         	adds	r0, #0x1
700a6b2c: 9006         	str	r0, [sp, #0x18]
700a6b2e: e7cb         	b	0x700a6ac8 <Udma_rmAllocVintr+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a6b30: 9807         	ldr	r0, [sp, #0x1c]
700a6b32: f500 609f    	add.w	r0, r0, #0x4f8
700a6b36: f003 f92b    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x3256
;     return (vintrNum);
700a6b3a: 9802         	ldr	r0, [sp, #0x8]
700a6b3c: b008         	add	sp, #0x20
700a6b3e: bd80         	pop	{r7, pc}

700a6b40 <memset>:
700a6b40: e92d4001     	push	{r0, lr}
700a6b44: e3100003     	tst	r0, #3
700a6b48: 0a000007     	beq	0x700a6b6c <_word_aligned> @ imm = #0x1c
700a6b4c: e3520000     	cmp	r2, #0

700a6b50 <_unaligned_loop>:
700a6b50: 84c01001     	strbhi	r1, [r0], #1
700a6b54: 82522001     	subshi	r2, r2, #1
700a6b58: 83100003     	tsthi	r0, #3
700a6b5c: 1afffffb     	bne	0x700a6b50 <_unaligned_loop> @ imm = #-0x14
700a6b60: e3520000     	cmp	r2, #0
700a6b64: 08bd4001     	popeq	{r0, lr}
700a6b68: 012fff1e     	bxeq	lr

700a6b6c <_word_aligned>:
700a6b6c: e20110ff     	and	r1, r1, #255
700a6b70: e1811401     	orr	r1, r1, r1, lsl #8
700a6b74: e3520004     	cmp	r2, #4
700a6b78: 3a000012     	blo	0x700a6bc8 <_memset3>   @ imm = #0x48
700a6b7c: e1811801     	orr	r1, r1, r1, lsl #16
700a6b80: e3520008     	cmp	r2, #8
700a6b84: 3a00000d     	blo	0x700a6bc0 <_memset7>   @ imm = #0x34
700a6b88: e1a0e001     	mov	lr, r1
700a6b8c: e3520010     	cmp	r2, #16
700a6b90: 3a000008     	blo	0x700a6bb8 <_memset15>  @ imm = #0x20
700a6b94: e92d0010     	stmdb	sp!, {r4}
700a6b98: e1a04001     	mov	r4, r1
700a6b9c: e1a0c001     	mov	r12, r1
700a6ba0: e242300f     	sub	r3, r2, #15
700a6ba4: e202200f     	and	r2, r2, #15

700a6ba8 <_memset16_loop>:
700a6ba8: e8a05012     	stm	r0!, {r1, r4, r12, lr}
700a6bac: e2533010     	subs	r3, r3, #16
700a6bb0: 8afffffc     	bhi	0x700a6ba8 <_memset16_loop> @ imm = #-0x10
700a6bb4: e8bd0010     	ldm	sp!, {r4}

700a6bb8 <_memset15>:
700a6bb8: e3120008     	tst	r2, #8
700a6bbc: 18a04002     	stmne	r0!, {r1, lr}

700a6bc0 <_memset7>:
700a6bc0: e3120004     	tst	r2, #4
700a6bc4: 14801004     	strne	r1, [r0], #4

700a6bc8 <_memset3>:
700a6bc8: e3120002     	tst	r2, #2
700a6bcc: 10c010b2     	strhne	r1, [r0], #2
700a6bd0: e3120001     	tst	r2, #1
700a6bd4: 15c01000     	strbne	r1, [r0]
700a6bd8: e8bd4001     	pop	{r0, lr}
700a6bdc: e12fff1e     	bx	lr

700a6be0 <Sciclient_getContext>:
; {
700a6be0: b084         	sub	sp, #0x10
700a6be2: 9003         	str	r0, [sp, #0xc]
700a6be4: 9102         	str	r1, [sp, #0x8]
700a6be6: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a6be8: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700a6bea: 9802         	ldr	r0, [sp, #0x8]
700a6bec: 9000         	str	r0, [sp]
700a6bee: 2805         	cmp	r0, #0x5
700a6bf0: d841         	bhi	0x700a6c76 <Sciclient_getContext+0x96> @ imm = #0x82
700a6bf2: 9900         	ldr	r1, [sp]
700a6bf4: e8df f001    	tbb	[pc, r1]
700a6bf8: 03 0d 17 21  	.word	0x21170d03
700a6bfc: 2b 35        	.short	0x352b
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6bfe: 9803         	ldr	r0, [sp, #0xc]
700a6c00: b918         	cbnz	r0, 0x700a6c0a <Sciclient_getContext+0x2a> @ imm = #0x6
700a6c02: e7ff         	b	0x700a6c04 <Sciclient_getContext+0x24> @ imm = #-0x2
700a6c04: 200e         	movs	r0, #0xe
;             retVal = SCICLIENT_CONTEXT_M4_SEC_0;
700a6c06: 9001         	str	r0, [sp, #0x4]
;         }
700a6c08: e002         	b	0x700a6c10 <Sciclient_getContext+0x30> @ imm = #0x4
700a6c0a: 2008         	movs	r0, #0x8
;             retVal = SCICLIENT_CONTEXT_M4_NONSEC_0;
700a6c0c: 9001         	str	r0, [sp, #0x4]
700a6c0e: e7ff         	b	0x700a6c10 <Sciclient_getContext+0x30> @ imm = #-0x2
;         break;
700a6c10: e032         	b	0x700a6c78 <Sciclient_getContext+0x98> @ imm = #0x64
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6c12: 9803         	ldr	r0, [sp, #0xc]
700a6c14: b918         	cbnz	r0, 0x700a6c1e <Sciclient_getContext+0x3e> @ imm = #0x6
700a6c16: e7ff         	b	0x700a6c18 <Sciclient_getContext+0x38> @ imm = #-0x2
700a6c18: 2000         	movs	r0, #0x0
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_0;
700a6c1a: 9001         	str	r0, [sp, #0x4]
;         }
700a6c1c: e002         	b	0x700a6c24 <Sciclient_getContext+0x44> @ imm = #0x4
700a6c1e: 2001         	movs	r0, #0x1
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_0;
700a6c20: 9001         	str	r0, [sp, #0x4]
700a6c22: e7ff         	b	0x700a6c24 <Sciclient_getContext+0x44> @ imm = #-0x2
;         break;
700a6c24: e028         	b	0x700a6c78 <Sciclient_getContext+0x98> @ imm = #0x50
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6c26: 9803         	ldr	r0, [sp, #0xc]
700a6c28: b918         	cbnz	r0, 0x700a6c32 <Sciclient_getContext+0x52> @ imm = #0x6
700a6c2a: e7ff         	b	0x700a6c2c <Sciclient_getContext+0x4c> @ imm = #-0x2
700a6c2c: 2002         	movs	r0, #0x2
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_1;
700a6c2e: 9001         	str	r0, [sp, #0x4]
;         }
700a6c30: e002         	b	0x700a6c38 <Sciclient_getContext+0x58> @ imm = #0x4
700a6c32: 2003         	movs	r0, #0x3
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_1;
700a6c34: 9001         	str	r0, [sp, #0x4]
700a6c36: e7ff         	b	0x700a6c38 <Sciclient_getContext+0x58> @ imm = #-0x2
;         break;
700a6c38: e01e         	b	0x700a6c78 <Sciclient_getContext+0x98> @ imm = #0x3c
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6c3a: 9803         	ldr	r0, [sp, #0xc]
700a6c3c: b918         	cbnz	r0, 0x700a6c46 <Sciclient_getContext+0x66> @ imm = #0x6
700a6c3e: e7ff         	b	0x700a6c40 <Sciclient_getContext+0x60> @ imm = #-0x2
700a6c40: 2009         	movs	r0, #0x9
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_0;
700a6c42: 9001         	str	r0, [sp, #0x4]
;         }
700a6c44: e002         	b	0x700a6c4c <Sciclient_getContext+0x6c> @ imm = #0x4
700a6c46: 200a         	movs	r0, #0xa
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_0;
700a6c48: 9001         	str	r0, [sp, #0x4]
700a6c4a: e7ff         	b	0x700a6c4c <Sciclient_getContext+0x6c> @ imm = #-0x2
;         break;
700a6c4c: e014         	b	0x700a6c78 <Sciclient_getContext+0x98> @ imm = #0x28
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6c4e: 9803         	ldr	r0, [sp, #0xc]
700a6c50: b918         	cbnz	r0, 0x700a6c5a <Sciclient_getContext+0x7a> @ imm = #0x6
700a6c52: e7ff         	b	0x700a6c54 <Sciclient_getContext+0x74> @ imm = #-0x2
700a6c54: 200b         	movs	r0, #0xb
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_1;
700a6c56: 9001         	str	r0, [sp, #0x4]
;         }
700a6c58: e002         	b	0x700a6c60 <Sciclient_getContext+0x80> @ imm = #0x4
700a6c5a: 200c         	movs	r0, #0xc
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_1;
700a6c5c: 9001         	str	r0, [sp, #0x4]
700a6c5e: e7ff         	b	0x700a6c60 <Sciclient_getContext+0x80> @ imm = #-0x2
;         break;
700a6c60: e00a         	b	0x700a6c78 <Sciclient_getContext+0x98> @ imm = #0x14
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a6c62: 9803         	ldr	r0, [sp, #0xc]
700a6c64: b918         	cbnz	r0, 0x700a6c6e <Sciclient_getContext+0x8e> @ imm = #0x6
700a6c66: e7ff         	b	0x700a6c68 <Sciclient_getContext+0x88> @ imm = #-0x2
700a6c68: 2004         	movs	r0, #0x4
;             retVal = SCICLIENT_CONTEXT_A53_SEC_0;
700a6c6a: 9001         	str	r0, [sp, #0x4]
;         }
700a6c6c: e002         	b	0x700a6c74 <Sciclient_getContext+0x94> @ imm = #0x4
700a6c6e: 2006         	movs	r0, #0x6
;             retVal = SCICLIENT_CONTEXT_A53_NONSEC_1;
700a6c70: 9001         	str	r0, [sp, #0x4]
700a6c72: e7ff         	b	0x700a6c74 <Sciclient_getContext+0x94> @ imm = #-0x2
;         break;
700a6c74: e000         	b	0x700a6c78 <Sciclient_getContext+0x98> @ imm = #0x0
;         break;
700a6c76: e7ff         	b	0x700a6c78 <Sciclient_getContext+0x98> @ imm = #-0x2
;     return retVal;
700a6c78: 9801         	ldr	r0, [sp, #0x4]
700a6c7a: b004         	add	sp, #0x10
700a6c7c: 4770         	bx	lr
700a6c7e: 0000         	movs	r0, r0

700a6c80 <Pinmux_config>:
; {
700a6c80: b580         	push	{r7, lr}
700a6c82: b086         	sub	sp, #0x18
700a6c84: 9005         	str	r0, [sp, #0x14]
700a6c86: 9104         	str	r1, [sp, #0x10]
700a6c88: 2000         	movs	r0, #0x0
;     uint32_t            isUnlocked = 0;
700a6c8a: 9001         	str	r0, [sp, #0x4]
;     if((NULL != pinmuxCfg) && (pinmuxCfg->offset != PINMUX_END))
700a6c8c: 9805         	ldr	r0, [sp, #0x14]
700a6c8e: 2800         	cmp	r0, #0x0
700a6c90: d042         	beq	0x700a6d18 <Pinmux_config+0x98> @ imm = #0x84
700a6c92: e7ff         	b	0x700a6c94 <Pinmux_config+0x14> @ imm = #-0x2
700a6c94: 9805         	ldr	r0, [sp, #0x14]
700a6c96: f9b0 0000    	ldrsh.w	r0, [r0]
700a6c9a: 3001         	adds	r0, #0x1
700a6c9c: b3e0         	cbz	r0, 0x700a6d18 <Pinmux_config+0x98> @ imm = #0x78
700a6c9e: e7ff         	b	0x700a6ca0 <Pinmux_config+0x20> @ imm = #-0x2
;         if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a6ca0: 9804         	ldr	r0, [sp, #0x10]
700a6ca2: b920         	cbnz	r0, 0x700a6cae <Pinmux_config+0x2e> @ imm = #0x8
700a6ca4: e7ff         	b	0x700a6ca6 <Pinmux_config+0x26> @ imm = #-0x2
700a6ca6: f44f 2074    	mov.w	r0, #0xf4000
;             baseAddr = CSL_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a6caa: 9003         	str	r0, [sp, #0xc]
;         }
700a6cac: e005         	b	0x700a6cba <Pinmux_config+0x3a> @ imm = #0xa
700a6cae: f244 0000    	movw	r0, #0x4000
700a6cb2: f2c0 4008    	movt	r0, #0x408
;             baseAddr = CSL_MCU_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a6cb6: 9003         	str	r0, [sp, #0xc]
700a6cb8: e7ff         	b	0x700a6cba <Pinmux_config+0x3a> @ imm = #-0x2
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(baseAddr);
700a6cba: 9803         	ldr	r0, [sp, #0xc]
700a6cbc: 2100         	movs	r1, #0x0
700a6cbe: f7fc ffbf    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x3082
700a6cc2: 9003         	str	r0, [sp, #0xc]
;         if (pinmuxCfg->offset != PINMUX_END)
700a6cc4: 9805         	ldr	r0, [sp, #0x14]
700a6cc6: f9b0 0000    	ldrsh.w	r0, [r0]
700a6cca: 3001         	adds	r0, #0x1
700a6ccc: b130         	cbz	r0, 0x700a6cdc <Pinmux_config+0x5c> @ imm = #0xc
700a6cce: e7ff         	b	0x700a6cd0 <Pinmux_config+0x50> @ imm = #-0x2
700a6cd0: 2001         	movs	r0, #0x1
;             isUnlocked = 1;
700a6cd2: 9001         	str	r0, [sp, #0x4]
;             Pinmux_unlockMMR(domainId);
700a6cd4: 9804         	ldr	r0, [sp, #0x10]
700a6cd6: f7fd fca3    	bl	0x700a4620 <Pinmux_unlockMMR> @ imm = #-0x26ba
;         }
700a6cda: e7ff         	b	0x700a6cdc <Pinmux_config+0x5c> @ imm = #-0x2
;         while( pinmuxCfg->offset != PINMUX_END )
700a6cdc: e7ff         	b	0x700a6cde <Pinmux_config+0x5e> @ imm = #-0x2
700a6cde: 9805         	ldr	r0, [sp, #0x14]
700a6ce0: f9b0 0000    	ldrsh.w	r0, [r0]
700a6ce4: 3001         	adds	r0, #0x1
700a6ce6: b178         	cbz	r0, 0x700a6d08 <Pinmux_config+0x88> @ imm = #0x1e
700a6ce8: e7ff         	b	0x700a6cea <Pinmux_config+0x6a> @ imm = #-0x2
;             regAddr = (volatile uint32_t *)(baseAddr + pinmuxCfg->offset);
700a6cea: 9803         	ldr	r0, [sp, #0xc]
700a6cec: 9905         	ldr	r1, [sp, #0x14]
700a6cee: f9b1 1000    	ldrsh.w	r1, [r1]
700a6cf2: 4408         	add	r0, r1
700a6cf4: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(regAddr, pinmuxCfg->settings);
700a6cf6: 9802         	ldr	r0, [sp, #0x8]
700a6cf8: 9905         	ldr	r1, [sp, #0x14]
700a6cfa: 6849         	ldr	r1, [r1, #0x4]
700a6cfc: f006 fc50    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x68a0
;             pinmuxCfg++;
700a6d00: 9805         	ldr	r0, [sp, #0x14]
700a6d02: 3008         	adds	r0, #0x8
700a6d04: 9005         	str	r0, [sp, #0x14]
;         while( pinmuxCfg->offset != PINMUX_END )
700a6d06: e7ea         	b	0x700a6cde <Pinmux_config+0x5e> @ imm = #-0x2c
;         if (isUnlocked)
700a6d08: 9801         	ldr	r0, [sp, #0x4]
700a6d0a: b120         	cbz	r0, 0x700a6d16 <Pinmux_config+0x96> @ imm = #0x8
700a6d0c: e7ff         	b	0x700a6d0e <Pinmux_config+0x8e> @ imm = #-0x2
;             Pinmux_lockMMR(domainId);
700a6d0e: 9804         	ldr	r0, [sp, #0x10]
700a6d10: f002 fc86    	bl	0x700a9620 <Pinmux_lockMMR> @ imm = #0x290c
;         }
700a6d14: e7ff         	b	0x700a6d16 <Pinmux_config+0x96> @ imm = #-0x2
;     }
700a6d16: e7ff         	b	0x700a6d18 <Pinmux_config+0x98> @ imm = #-0x2
;     return;
700a6d18: b006         	add	sp, #0x18
700a6d1a: bd80         	pop	{r7, pc}
700a6d1c: 0000         	movs	r0, r0
700a6d1e: 0000         	movs	r0, r0

700a6d20 <SOC_controlModuleUnlockMMR>:
; {
700a6d20: b580         	push	{r7, lr}
700a6d22: b084         	sub	sp, #0x10
700a6d24: 9003         	str	r0, [sp, #0xc]
700a6d26: 9102         	str	r1, [sp, #0x8]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700a6d28: 9803         	ldr	r0, [sp, #0xc]
700a6d2a: bb00         	cbnz	r0, 0x700a6d6e <SOC_controlModuleUnlockMMR+0x4e> @ imm = #0x40
700a6d2c: e7ff         	b	0x700a6d2e <SOC_controlModuleUnlockMMR+0xe> @ imm = #-0x2
700a6d2e: f04f 4086    	mov.w	r0, #0x43000000
700a6d32: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700a6d34: f7fc ff84    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x30f8
700a6d38: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a6d3a: 9801         	ldr	r0, [sp, #0x4]
700a6d3c: 9902         	ldr	r1, [sp, #0x8]
700a6d3e: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a6d42: f241 0108    	movw	r1, #0x1008
700a6d46: 4408         	add	r0, r1
700a6d48: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6d4a: 9800         	ldr	r0, [sp]
700a6d4c: f243 4190    	movw	r1, #0x3490
700a6d50: f6c6 01ef    	movt	r1, #0x68ef
700a6d54: f006 fc34    	bl	0x700ad5c0 <CSL_REG32_WR_RAW> @ imm = #0x6868
;         kickAddr++;
700a6d58: 9800         	ldr	r0, [sp]
700a6d5a: 3004         	adds	r0, #0x4
700a6d5c: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6d5e: 9800         	ldr	r0, [sp]
700a6d60: f64b 415a    	movw	r1, #0xbc5a
700a6d64: f2cd 1172    	movt	r1, #0xd172
700a6d68: f006 fc2a    	bl	0x700ad5c0 <CSL_REG32_WR_RAW> @ imm = #0x6854
;     }
700a6d6c: e7ff         	b	0x700a6d6e <SOC_controlModuleUnlockMMR+0x4e> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700a6d6e: 9803         	ldr	r0, [sp, #0xc]
700a6d70: 2801         	cmp	r0, #0x1
700a6d72: d120         	bne	0x700a6db6 <SOC_controlModuleUnlockMMR+0x96> @ imm = #0x40
700a6d74: e7ff         	b	0x700a6d76 <SOC_controlModuleUnlockMMR+0x56> @ imm = #-0x2
700a6d76: f04f 608a    	mov.w	r0, #0x4500000
700a6d7a: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700a6d7c: f7fc ff60    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x3140
700a6d80: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a6d82: 9801         	ldr	r0, [sp, #0x4]
700a6d84: 9902         	ldr	r1, [sp, #0x8]
700a6d86: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a6d8a: f241 0108    	movw	r1, #0x1008
700a6d8e: 4408         	add	r0, r1
700a6d90: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6d92: 9800         	ldr	r0, [sp]
700a6d94: f243 4190    	movw	r1, #0x3490
700a6d98: f6c6 01ef    	movt	r1, #0x68ef
700a6d9c: f006 fc10    	bl	0x700ad5c0 <CSL_REG32_WR_RAW> @ imm = #0x6820
;         kickAddr++;
700a6da0: 9800         	ldr	r0, [sp]
700a6da2: 3004         	adds	r0, #0x4
700a6da4: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6da6: 9800         	ldr	r0, [sp]
700a6da8: f64b 415a    	movw	r1, #0xbc5a
700a6dac: f2cd 1172    	movt	r1, #0xd172
700a6db0: f006 fc06    	bl	0x700ad5c0 <CSL_REG32_WR_RAW> @ imm = #0x680c
;     }
700a6db4: e7ff         	b	0x700a6db6 <SOC_controlModuleUnlockMMR+0x96> @ imm = #-0x2
;     return;
700a6db6: b004         	add	sp, #0x10
700a6db8: bd80         	pop	{r7, pc}
700a6dba: 0000         	movs	r0, r0
700a6dbc: 0000         	movs	r0, r0
700a6dbe: 0000         	movs	r0, r0

700a6dc0 <Sciclient_pmGetModuleClkFreq>:
; {
700a6dc0: b580         	push	{r7, lr}
700a6dc2: b096         	sub	sp, #0x58
700a6dc4: 9015         	str	r0, [sp, #0x54]
700a6dc6: 9114         	str	r1, [sp, #0x50]
700a6dc8: 9213         	str	r2, [sp, #0x4c]
700a6dca: 9312         	str	r3, [sp, #0x48]
700a6dcc: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a6dce: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a6dd0: 9815         	ldr	r0, [sp, #0x54]
700a6dd2: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a6dd4: 9814         	ldr	r0, [sp, #0x50]
700a6dd6: 28ff         	cmp	r0, #0xff
700a6dd8: d307         	blo	0x700a6dea <Sciclient_pmGetModuleClkFreq+0x2a> @ imm = #0xe
700a6dda: e7ff         	b	0x700a6ddc <Sciclient_pmGetModuleClkFreq+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a6ddc: 9814         	ldr	r0, [sp, #0x50]
700a6dde: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a6de2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a6de4: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a6de8: e003         	b	0x700a6df2 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a6dea: 9814         	ldr	r0, [sp, #0x50]
700a6dec: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a6df0: e7ff         	b	0x700a6df2 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #-0x2
700a6df2: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_freq_resp response = {{0}};
700a6df4: 900b         	str	r0, [sp, #0x2c]
700a6df6: 900a         	str	r0, [sp, #0x28]
700a6df8: 9009         	str	r0, [sp, #0x24]
700a6dfa: 9008         	str	r0, [sp, #0x20]
700a6dfc: f44f 7187    	mov.w	r1, #0x10e
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_FREQ;
700a6e00: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a6e04: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a6e06: 9104         	str	r1, [sp, #0x10]
700a6e08: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a6e0a: 9105         	str	r1, [sp, #0x14]
700a6e0c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a6e0e: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a6e10: 9912         	ldr	r1, [sp, #0x48]
700a6e12: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a6e14: 9000         	str	r0, [sp]
700a6e16: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a6e18: 9001         	str	r0, [sp, #0x4]
700a6e1a: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a6e1c: 9002         	str	r0, [sp, #0x8]
700a6e1e: a803         	add	r0, sp, #0xc
700a6e20: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a6e22: f7f5 f82d    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xafa6
700a6e26: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a6e28: 9811         	ldr	r0, [sp, #0x44]
700a6e2a: b930         	cbnz	r0, 0x700a6e3a <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #0xc
700a6e2c: e7ff         	b	0x700a6e2e <Sciclient_pmGetModuleClkFreq+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a6e2e: 9800         	ldr	r0, [sp]
700a6e30: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a6e34: 2802         	cmp	r0, #0x2
700a6e36: d004         	beq	0x700a6e42 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #0x8
700a6e38: e7ff         	b	0x700a6e3a <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #-0x2
700a6e3a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a6e3e: 9011         	str	r0, [sp, #0x44]
;     }
700a6e40: e7ff         	b	0x700a6e42 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a6e42: 9811         	ldr	r0, [sp, #0x44]
700a6e44: b930         	cbnz	r0, 0x700a6e54 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #0xc
700a6e46: e7ff         	b	0x700a6e48 <Sciclient_pmGetModuleClkFreq+0x88> @ imm = #-0x2
;         *freqHz = (uint64_t) response.freq_hz;
700a6e48: 980a         	ldr	r0, [sp, #0x28]
700a6e4a: 9a0b         	ldr	r2, [sp, #0x2c]
700a6e4c: 9913         	ldr	r1, [sp, #0x4c]
700a6e4e: 604a         	str	r2, [r1, #0x4]
700a6e50: 6008         	str	r0, [r1]
;     }
700a6e52: e7ff         	b	0x700a6e54 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #-0x2
;     return retVal;
700a6e54: 9811         	ldr	r0, [sp, #0x44]
700a6e56: b016         	add	sp, #0x58
700a6e58: bd80         	pop	{r7, pc}
700a6e5a: 0000         	movs	r0, r0
700a6e5c: 0000         	movs	r0, r0
700a6e5e: 0000         	movs	r0, r0

700a6e60 <Sciclient_pmGetModuleClkParent>:
; {
700a6e60: b580         	push	{r7, lr}
700a6e62: b096         	sub	sp, #0x58
700a6e64: 9015         	str	r0, [sp, #0x54]
700a6e66: 9114         	str	r1, [sp, #0x50]
700a6e68: 9213         	str	r2, [sp, #0x4c]
700a6e6a: 9312         	str	r3, [sp, #0x48]
700a6e6c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a6e6e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a6e70: 9815         	ldr	r0, [sp, #0x54]
700a6e72: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a6e74: 9814         	ldr	r0, [sp, #0x50]
700a6e76: 28ff         	cmp	r0, #0xff
700a6e78: d307         	blo	0x700a6e8a <Sciclient_pmGetModuleClkParent+0x2a> @ imm = #0xe
700a6e7a: e7ff         	b	0x700a6e7c <Sciclient_pmGetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a6e7c: 9814         	ldr	r0, [sp, #0x50]
700a6e7e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a6e82: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a6e84: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a6e88: e003         	b	0x700a6e92 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a6e8a: 9814         	ldr	r0, [sp, #0x50]
700a6e8c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a6e90: e7ff         	b	0x700a6e92 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #-0x2
700a6e92: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_parent_resp response = {{0}};
700a6e94: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a6e98: 900a         	str	r0, [sp, #0x28]
700a6e9a: 9009         	str	r0, [sp, #0x24]
700a6e9c: 9008         	str	r0, [sp, #0x20]
700a6e9e: f240 1103    	movw	r1, #0x103
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK_PARENT;
700a6ea2: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a6ea6: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a6ea8: 9104         	str	r1, [sp, #0x10]
700a6eaa: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a6eac: 9105         	str	r1, [sp, #0x14]
700a6eae: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a6eb0: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a6eb2: 9912         	ldr	r1, [sp, #0x48]
700a6eb4: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a6eb6: 9000         	str	r0, [sp]
700a6eb8: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a6eba: 9001         	str	r0, [sp, #0x4]
700a6ebc: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a6ebe: 9002         	str	r0, [sp, #0x8]
700a6ec0: a803         	add	r0, sp, #0xc
700a6ec2: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a6ec4: f7f4 ffdc    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xb048
700a6ec8: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a6eca: 9811         	ldr	r0, [sp, #0x44]
700a6ecc: b930         	cbnz	r0, 0x700a6edc <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #0xc
700a6ece: e7ff         	b	0x700a6ed0 <Sciclient_pmGetModuleClkParent+0x70> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a6ed0: 9800         	ldr	r0, [sp]
700a6ed2: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a6ed6: 2802         	cmp	r0, #0x2
700a6ed8: d004         	beq	0x700a6ee4 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #0x8
700a6eda: e7ff         	b	0x700a6edc <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #-0x2
700a6edc: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a6ee0: 9011         	str	r0, [sp, #0x44]
;     }
700a6ee2: e7ff         	b	0x700a6ee4 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a6ee4: 9811         	ldr	r0, [sp, #0x44]
700a6ee6: b928         	cbnz	r0, 0x700a6ef4 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #0xa
700a6ee8: e7ff         	b	0x700a6eea <Sciclient_pmGetModuleClkParent+0x8a> @ imm = #-0x2
;         *parent = (uint32_t) response.parent;
700a6eea: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a6eee: 9913         	ldr	r1, [sp, #0x4c]
700a6ef0: 6008         	str	r0, [r1]
;     }
700a6ef2: e7ff         	b	0x700a6ef4 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a6ef4: 9811         	ldr	r0, [sp, #0x44]
700a6ef6: b016         	add	sp, #0x58
700a6ef8: bd80         	pop	{r7, pc}
700a6efa: 0000         	movs	r0, r0
700a6efc: 0000         	movs	r0, r0
700a6efe: 0000         	movs	r0, r0

700a6f00 <Sciclient_pmSetModuleClkParent>:
; {
700a6f00: b580         	push	{r7, lr}
700a6f02: b094         	sub	sp, #0x50
700a6f04: 9013         	str	r0, [sp, #0x4c]
700a6f06: 9112         	str	r1, [sp, #0x48]
700a6f08: 9211         	str	r2, [sp, #0x44]
700a6f0a: 9310         	str	r3, [sp, #0x40]
700a6f0c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a6f0e: 900f         	str	r0, [sp, #0x3c]
;     request.device = (uint32_t) moduleId;
700a6f10: 9813         	ldr	r0, [sp, #0x4c]
700a6f12: 900b         	str	r0, [sp, #0x2c]
;     if (clockId >= 255U)
700a6f14: 9812         	ldr	r0, [sp, #0x48]
700a6f16: 28ff         	cmp	r0, #0xff
700a6f18: d307         	blo	0x700a6f2a <Sciclient_pmSetModuleClkParent+0x2a> @ imm = #0xe
700a6f1a: e7ff         	b	0x700a6f1c <Sciclient_pmSetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a6f1c: 9812         	ldr	r0, [sp, #0x48]
700a6f1e: f8cd 0032    	str.w	r0, [sp, #0x32]
700a6f22: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a6f24: f88d 0030    	strb.w	r0, [sp, #0x30]
;     }
700a6f28: e003         	b	0x700a6f32 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a6f2a: 9812         	ldr	r0, [sp, #0x48]
700a6f2c: f88d 0030    	strb.w	r0, [sp, #0x30]
700a6f30: e7ff         	b	0x700a6f32 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #-0x2
;     if (parent >= 255U)
700a6f32: 9811         	ldr	r0, [sp, #0x44]
700a6f34: 28ff         	cmp	r0, #0xff
700a6f36: d307         	blo	0x700a6f48 <Sciclient_pmSetModuleClkParent+0x48> @ imm = #0xe
700a6f38: e7ff         	b	0x700a6f3a <Sciclient_pmSetModuleClkParent+0x3a> @ imm = #-0x2
;         request.parent32 = parent;
700a6f3a: 9811         	ldr	r0, [sp, #0x44]
700a6f3c: f8cd 0036    	str.w	r0, [sp, #0x36]
700a6f40: 20ff         	movs	r0, #0xff
;         request.parent   = (uint8_t) 255U;
700a6f42: f88d 0031    	strb.w	r0, [sp, #0x31]
;     }
700a6f46: e003         	b	0x700a6f50 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #0x6
;         request.parent = (uint8_t) parent;
700a6f48: 9811         	ldr	r0, [sp, #0x44]
700a6f4a: f88d 0031    	strb.w	r0, [sp, #0x31]
700a6f4e: e7ff         	b	0x700a6f50 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #-0x2
700a6f50: f44f 7081    	mov.w	r0, #0x102
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK_PARENT;
700a6f54: f8ad 0010    	strh.w	r0, [sp, #0x10]
700a6f58: 2002         	movs	r0, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a6f5a: 9005         	str	r0, [sp, #0x14]
700a6f5c: a809         	add	r0, sp, #0x24
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a6f5e: 9006         	str	r0, [sp, #0x18]
700a6f60: 2016         	movs	r0, #0x16
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a6f62: 9007         	str	r0, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a6f64: 9810         	ldr	r0, [sp, #0x40]
700a6f66: 9008         	str	r0, [sp, #0x20]
700a6f68: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a6f6a: 9001         	str	r0, [sp, #0x4]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a6f6c: 9002         	str	r0, [sp, #0x8]
;     respParam.respPayloadSize = (uint32_t) 0;
700a6f6e: 9003         	str	r0, [sp, #0xc]
700a6f70: a804         	add	r0, sp, #0x10
700a6f72: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a6f74: f7f4 ff84    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xb0f8
700a6f78: 900f         	str	r0, [sp, #0x3c]
;     if((retVal != SystemP_SUCCESS) ||
700a6f7a: 980f         	ldr	r0, [sp, #0x3c]
700a6f7c: b930         	cbnz	r0, 0x700a6f8c <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #0xc
700a6f7e: e7ff         	b	0x700a6f80 <Sciclient_pmSetModuleClkParent+0x80> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a6f80: 9801         	ldr	r0, [sp, #0x4]
700a6f82: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a6f86: 2802         	cmp	r0, #0x2
700a6f88: d004         	beq	0x700a6f94 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #0x8
700a6f8a: e7ff         	b	0x700a6f8c <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #-0x2
700a6f8c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a6f90: 900f         	str	r0, [sp, #0x3c]
;     }
700a6f92: e7ff         	b	0x700a6f94 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a6f94: 980f         	ldr	r0, [sp, #0x3c]
700a6f96: b014         	add	sp, #0x50
700a6f98: bd80         	pop	{r7, pc}
700a6f9a: 0000         	movs	r0, r0
700a6f9c: 0000         	movs	r0, r0
700a6f9e: 0000         	movs	r0, r0

700a6fa0 <Sciclient_rmIrOutpIsFree>:
; {
700a6fa0: b580         	push	{r7, lr}
700a6fa2: b086         	sub	sp, #0x18
700a6fa4: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a6fa8: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a6fac: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a6fae: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIrInst *inst = NULL;
700a6fb0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a6fb2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a6fb6: f002 fd2b    	bl	0x700a9a10 <Sciclient_rmIrGetInst> @ imm = #0x2a56
700a6fba: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a6fbc: 9803         	ldr	r0, [sp, #0xc]
700a6fbe: b920         	cbnz	r0, 0x700a6fca <Sciclient_rmIrOutpIsFree+0x2a> @ imm = #0x8
700a6fc0: e7ff         	b	0x700a6fc2 <Sciclient_rmIrOutpIsFree+0x22> @ imm = #-0x2
700a6fc2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a6fc6: 9004         	str	r0, [sp, #0x10]
;     } else {
700a6fc8: e00b         	b	0x700a6fe2 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #0x16
;         if (outp >= inst->n_outp) {
700a6fca: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a6fce: 9903         	ldr	r1, [sp, #0xc]
700a6fd0: 8949         	ldrh	r1, [r1, #0xa]
700a6fd2: 4288         	cmp	r0, r1
700a6fd4: db04         	blt	0x700a6fe0 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #0x8
700a6fd6: e7ff         	b	0x700a6fd8 <Sciclient_rmIrOutpIsFree+0x38> @ imm = #-0x2
700a6fd8: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a6fdc: 9004         	str	r0, [sp, #0x10]
;         }
700a6fde: e7ff         	b	0x700a6fe0 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #-0x2
700a6fe0: e7ff         	b	0x700a6fe2 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a6fe2: 9804         	ldr	r0, [sp, #0x10]
700a6fe4: bb30         	cbnz	r0, 0x700a7034 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #0x4c
700a6fe6: e7ff         	b	0x700a6fe8 <Sciclient_rmIrOutpIsFree+0x48> @ imm = #-0x2
;         int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, outp);
700a6fe8: 9803         	ldr	r0, [sp, #0xc]
700a6fea: 6840         	ldr	r0, [r0, #0x4]
700a6fec: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a6ff0: f005 fbd6    	bl	0x700ac7a0 <Sciclient_getIrAddr> @ imm = #0x57ac
700a6ff4: 9002         	str	r0, [sp, #0x8]
;         extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a6ff6: 9802         	ldr	r0, [sp, #0x8]
700a6ff8: f240 31ff    	movw	r1, #0x3ff
700a6ffc: 2200         	movs	r2, #0x0
700a6ffe: f005 fe9f    	bl	0x700acd40 <CSL_REG32_FEXT_RAW> @ imm = #0x5d3e
700a7002: f8ad 0006    	strh.w	r0, [sp, #0x6]
;         if (((extracted_inp != 0u) &&
700a7006: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a700a: b138         	cbz	r0, 0x700a701c <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #0xe
700a700c: e7ff         	b	0x700a700e <Sciclient_rmIrOutpIsFree+0x6e> @ imm = #-0x2
;              (Sciclient_rmIrOutpRomMapped(inst, outp) == false)) ||
700a700e: 9803         	ldr	r0, [sp, #0xc]
700a7010: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a7014: f7ff f9e4    	bl	0x700a63e0 <Sciclient_rmIrOutpRomMapped> @ imm = #-0xc38
700a7018: b138         	cbz	r0, 0x700a702a <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #0xe
700a701a: e7ff         	b	0x700a701c <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #-0x2
;             (outp == inst->inp0_mapping)) {
700a701c: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a7020: 9903         	ldr	r1, [sp, #0xc]
700a7022: 8989         	ldrh	r1, [r1, #0xc]
;         if (((extracted_inp != 0u) &&
700a7024: 4288         	cmp	r0, r1
700a7026: d104         	bne	0x700a7032 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #0x8
700a7028: e7ff         	b	0x700a702a <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #-0x2
700a702a: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a702e: 9004         	str	r0, [sp, #0x10]
;         }
700a7030: e7ff         	b	0x700a7032 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #-0x2
;     }
700a7032: e7ff         	b	0x700a7034 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #-0x2
;     return r;
700a7034: 9804         	ldr	r0, [sp, #0x10]
700a7036: b006         	add	sp, #0x18
700a7038: bd80         	pop	{r7, pc}
700a703a: 0000         	movs	r0, r0
700a703c: 0000         	movs	r0, r0
700a703e: 0000         	movs	r0, r0

700a7040 <Udma_ringQueueRaw>:
; {
700a7040: b580         	push	{r7, lr}
700a7042: b088         	sub	sp, #0x20
700a7044: 9007         	str	r0, [sp, #0x1c]
700a7046: 9305         	str	r3, [sp, #0x14]
700a7048: 9204         	str	r2, [sp, #0x10]
700a704a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a704c: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a704e: 9807         	ldr	r0, [sp, #0x1c]
700a7050: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a7052: 9800         	ldr	r0, [sp]
700a7054: b180         	cbz	r0, 0x700a7078 <Udma_ringQueueRaw+0x38> @ imm = #0x20
700a7056: e7ff         	b	0x700a7058 <Udma_ringQueueRaw+0x18> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a7058: 9800         	ldr	r0, [sp]
700a705a: 6d80         	ldr	r0, [r0, #0x58]
700a705c: f64a 31cd    	movw	r1, #0xabcd
700a7060: f6ca 31dc    	movt	r1, #0xabdc
700a7064: 4288         	cmp	r0, r1
700a7066: d107         	bne	0x700a7078 <Udma_ringQueueRaw+0x38> @ imm = #0xe
700a7068: e7ff         	b	0x700a706a <Udma_ringQueueRaw+0x2a> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a706a: 9800         	ldr	r0, [sp]
700a706c: 8880         	ldrh	r0, [r0, #0x4]
700a706e: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a7072: 4288         	cmp	r0, r1
700a7074: d104         	bne	0x700a7080 <Udma_ringQueueRaw+0x40> @ imm = #0x8
700a7076: e7ff         	b	0x700a7078 <Udma_ringQueueRaw+0x38> @ imm = #-0x2
700a7078: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a707c: 9003         	str	r0, [sp, #0xc]
;     }
700a707e: e7ff         	b	0x700a7080 <Udma_ringQueueRaw+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7080: 9803         	ldr	r0, [sp, #0xc]
700a7082: b9a8         	cbnz	r0, 0x700a70b0 <Udma_ringQueueRaw+0x70> @ imm = #0x2a
700a7084: e7ff         	b	0x700a7086 <Udma_ringQueueRaw+0x46> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a7086: 9800         	ldr	r0, [sp]
700a7088: 6800         	ldr	r0, [r0]
700a708a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a708c: 9801         	ldr	r0, [sp, #0x4]
700a708e: b150         	cbz	r0, 0x700a70a6 <Udma_ringQueueRaw+0x66> @ imm = #0x14
700a7090: e7ff         	b	0x700a7092 <Udma_ringQueueRaw+0x52> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a7092: 9801         	ldr	r0, [sp, #0x4]
700a7094: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7098: f64a 31cd    	movw	r1, #0xabcd
700a709c: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a70a0: 4288         	cmp	r0, r1
700a70a2: d004         	beq	0x700a70ae <Udma_ringQueueRaw+0x6e> @ imm = #0x8
700a70a4: e7ff         	b	0x700a70a6 <Udma_ringQueueRaw+0x66> @ imm = #-0x2
700a70a6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a70aa: 9003         	str	r0, [sp, #0xc]
;         }
700a70ac: e7ff         	b	0x700a70ae <Udma_ringQueueRaw+0x6e> @ imm = #-0x2
;     }
700a70ae: e7ff         	b	0x700a70b0 <Udma_ringQueueRaw+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a70b0: 9803         	ldr	r0, [sp, #0xc]
700a70b2: b978         	cbnz	r0, 0x700a70d4 <Udma_ringQueueRaw+0x94> @ imm = #0x1e
700a70b4: e7ff         	b	0x700a70b6 <Udma_ringQueueRaw+0x76> @ imm = #-0x2
;         cookie = HwiP_disable();
700a70b6: f007 e96c    	blx	0x700ae390 <HwiP_disable> @ imm = #0x72d8
700a70ba: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringQueueRaw(drvHandle, ringHandleInt, phyDescMem);
700a70bc: 9801         	ldr	r0, [sp, #0x4]
700a70be: f8d0 c594    	ldr.w	r12, [r0, #0x594]
700a70c2: 9900         	ldr	r1, [sp]
700a70c4: 9a04         	ldr	r2, [sp, #0x10]
700a70c6: 9b05         	ldr	r3, [sp, #0x14]
700a70c8: 47e0         	blx	r12
700a70ca: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a70cc: 9802         	ldr	r0, [sp, #0x8]
700a70ce: f007 e980    	blx	0x700ae3d0 <HwiP_restore> @ imm = #0x7300
;     }
700a70d2: e7ff         	b	0x700a70d4 <Udma_ringQueueRaw+0x94> @ imm = #-0x2
;     return (retVal);
700a70d4: 9803         	ldr	r0, [sp, #0xc]
700a70d6: b008         	add	sp, #0x20
700a70d8: bd80         	pop	{r7, pc}
700a70da: 0000         	movs	r0, r0
700a70dc: 0000         	movs	r0, r0
700a70de: 0000         	movs	r0, r0

700a70e0 <xTaskCheckForTimeOut>:
;                                 TickType_t *const pxTicksToWait) {
700a70e0: b580         	push	{r7, lr}
700a70e2: b086         	sub	sp, #0x18
700a70e4: 9005         	str	r0, [sp, #0x14]
700a70e6: 9104         	str	r1, [sp, #0x10]
;   taskENTER_CRITICAL();
700a70e8: f005 f982    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0x5304
;     const TickType_t xConstTickCount = xTickCount;
700a70ec: f240 2010    	movw	r0, #0x210
700a70f0: f2c7 000b    	movt	r0, #0x700b
700a70f4: 6800         	ldr	r0, [r0]
700a70f6: 9002         	str	r0, [sp, #0x8]
;         xConstTickCount - pxTimeOut->xTimeOnEntering;
700a70f8: 9802         	ldr	r0, [sp, #0x8]
700a70fa: 9905         	ldr	r1, [sp, #0x14]
700a70fc: 6849         	ldr	r1, [r1, #0x4]
700a70fe: 1a40         	subs	r0, r0, r1
;     const TickType_t xElapsedTime =
700a7100: 9001         	str	r0, [sp, #0x4]
;         if (*pxTicksToWait == portMAX_DELAY) {
700a7102: 9804         	ldr	r0, [sp, #0x10]
700a7104: 6800         	ldr	r0, [r0]
700a7106: 3001         	adds	r0, #0x1
700a7108: b918         	cbnz	r0, 0x700a7112 <xTaskCheckForTimeOut+0x32> @ imm = #0x6
700a710a: e7ff         	b	0x700a710c <xTaskCheckForTimeOut+0x2c> @ imm = #-0x2
700a710c: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a710e: 9003         	str	r0, [sp, #0xc]
;     } else
700a7110: e02e         	b	0x700a7170 <xTaskCheckForTimeOut+0x90> @ imm = #0x5c
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a7112: f240 2004    	movw	r0, #0x204
700a7116: f2c7 000b    	movt	r0, #0x700b
700a711a: 6800         	ldr	r0, [r0]
700a711c: 9905         	ldr	r1, [sp, #0x14]
700a711e: 6809         	ldr	r1, [r1]
700a7120: 4288         	cmp	r0, r1
700a7122: d00c         	beq	0x700a713e <xTaskCheckForTimeOut+0x5e> @ imm = #0x18
700a7124: e7ff         	b	0x700a7126 <xTaskCheckForTimeOut+0x46> @ imm = #-0x2
;             (xConstTickCount >=
700a7126: 9802         	ldr	r0, [sp, #0x8]
;              pxTimeOut
700a7128: 9905         	ldr	r1, [sp, #0x14]
;                  ->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to
700a712a: 6849         	ldr	r1, [r1, #0x4]
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a712c: 4288         	cmp	r0, r1
700a712e: d306         	blo	0x700a713e <xTaskCheckForTimeOut+0x5e> @ imm = #0xc
700a7130: e7ff         	b	0x700a7132 <xTaskCheckForTimeOut+0x52> @ imm = #-0x2
700a7132: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a7134: 9003         	str	r0, [sp, #0xc]
;       *pxTicksToWait = (TickType_t)0;
700a7136: 9904         	ldr	r1, [sp, #0x10]
700a7138: 2000         	movs	r0, #0x0
700a713a: 6008         	str	r0, [r1]
;     } else if (xElapsedTime <
700a713c: e017         	b	0x700a716e <xTaskCheckForTimeOut+0x8e> @ imm = #0x2e
700a713e: 9801         	ldr	r0, [sp, #0x4]
;                *pxTicksToWait) /*lint !e961 Explicit casting is only redundant
700a7140: 9904         	ldr	r1, [sp, #0x10]
700a7142: 6809         	ldr	r1, [r1]
;     } else if (xElapsedTime <
700a7144: 4288         	cmp	r0, r1
700a7146: d20b         	bhs	0x700a7160 <xTaskCheckForTimeOut+0x80> @ imm = #0x16
700a7148: e7ff         	b	0x700a714a <xTaskCheckForTimeOut+0x6a> @ imm = #-0x2
;       *pxTicksToWait -= xElapsedTime;
700a714a: 9a01         	ldr	r2, [sp, #0x4]
700a714c: 9904         	ldr	r1, [sp, #0x10]
700a714e: 6808         	ldr	r0, [r1]
700a7150: 1a80         	subs	r0, r0, r2
700a7152: 6008         	str	r0, [r1]
;       vTaskInternalSetTimeOutState(pxTimeOut);
700a7154: 9805         	ldr	r0, [sp, #0x14]
700a7156: f005 fe7b    	bl	0x700ace50 <vTaskInternalSetTimeOutState> @ imm = #0x5cf6
700a715a: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a715c: 9003         	str	r0, [sp, #0xc]
;     } else {
700a715e: e005         	b	0x700a716c <xTaskCheckForTimeOut+0x8c> @ imm = #0xa
;       *pxTicksToWait = (TickType_t)0;
700a7160: 9904         	ldr	r1, [sp, #0x10]
700a7162: 2000         	movs	r0, #0x0
700a7164: 6008         	str	r0, [r1]
700a7166: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a7168: 9003         	str	r0, [sp, #0xc]
700a716a: e7ff         	b	0x700a716c <xTaskCheckForTimeOut+0x8c> @ imm = #-0x2
700a716c: e7ff         	b	0x700a716e <xTaskCheckForTimeOut+0x8e> @ imm = #-0x2
700a716e: e7ff         	b	0x700a7170 <xTaskCheckForTimeOut+0x90> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a7170: f004 fa3e    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x447c
;   return xReturn;
700a7174: 9803         	ldr	r0, [sp, #0xc]
700a7176: b006         	add	sp, #0x18
700a7178: bd80         	pop	{r7, pc}
700a717a: 0000         	movs	r0, r0
700a717c: 0000         	movs	r0, r0
700a717e: 0000         	movs	r0, r0

700a7180 <CSL_bcdmaChanOpSetChanEnable>:
; {
700a7180: b580         	push	{r7, lr}
700a7182: b086         	sub	sp, #0x18
700a7184: 9005         	str	r0, [sp, #0x14]
700a7186: 9104         	str	r1, [sp, #0x10]
700a7188: 9203         	str	r2, [sp, #0xc]
700a718a: f88d 300b    	strb.w	r3, [sp, #0xb]
700a718e: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a7190: 9001         	str	r0, [sp, #0x4]
;     switch( chanType )
700a7192: 9804         	ldr	r0, [sp, #0x10]
700a7194: 9000         	str	r0, [sp]
700a7196: b140         	cbz	r0, 0x700a71aa <CSL_bcdmaChanOpSetChanEnable+0x2a> @ imm = #0x10
700a7198: e7ff         	b	0x700a719a <CSL_bcdmaChanOpSetChanEnable+0x1a> @ imm = #-0x2
700a719a: 9800         	ldr	r0, [sp]
700a719c: 2801         	cmp	r0, #0x1
700a719e: d014         	beq	0x700a71ca <CSL_bcdmaChanOpSetChanEnable+0x4a> @ imm = #0x28
700a71a0: e7ff         	b	0x700a71a2 <CSL_bcdmaChanOpSetChanEnable+0x22> @ imm = #-0x2
700a71a2: 9800         	ldr	r0, [sp]
700a71a4: 2802         	cmp	r0, #0x2
700a71a6: d020         	beq	0x700a71ea <CSL_bcdmaChanOpSetChanEnable+0x6a> @ imm = #0x40
700a71a8: e02f         	b	0x700a720a <CSL_bcdmaChanOpSetChanEnable+0x8a> @ imm = #0x5e
;             CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_BCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a71aa: 9805         	ldr	r0, [sp, #0x14]
700a71ac: 6880         	ldr	r0, [r0, #0x8]
700a71ae: 9903         	ldr	r1, [sp, #0xc]
700a71b0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a71b4: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a71b8: f001 0101    	and	r1, r1, #0x1
700a71bc: 2900         	cmp	r1, #0x0
700a71be: bf18         	it	ne
700a71c0: f04f 4100    	movne.w	r1, #0x80000000
700a71c4: f006 f9dc    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x63b8
;             break;
700a71c8: e023         	b	0x700a7212 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x46
;             CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a71ca: 9805         	ldr	r0, [sp, #0x14]
700a71cc: 6900         	ldr	r0, [r0, #0x10]
700a71ce: 9903         	ldr	r1, [sp, #0xc]
700a71d0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a71d4: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a71d8: f001 0101    	and	r1, r1, #0x1
700a71dc: 2900         	cmp	r1, #0x0
700a71de: bf18         	it	ne
700a71e0: f04f 4100    	movne.w	r1, #0x80000000
700a71e4: f006 f9cc    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x6398
;             break;
700a71e8: e013         	b	0x700a7212 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x26
;             CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_RXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a71ea: 9805         	ldr	r0, [sp, #0x14]
700a71ec: 6980         	ldr	r0, [r0, #0x18]
700a71ee: 9903         	ldr	r1, [sp, #0xc]
700a71f0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a71f4: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a71f8: f001 0101    	and	r1, r1, #0x1
700a71fc: 2900         	cmp	r1, #0x0
700a71fe: bf18         	it	ne
700a7200: f04f 4100    	movne.w	r1, #0x80000000
700a7204: f006 f9bc    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x6378
;             break;
700a7208: e003         	b	0x700a7212 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x6
700a720a: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700a720e: 9001         	str	r0, [sp, #0x4]
;             break;
700a7210: e7ff         	b	0x700a7212 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #-0x2
;     return retVal;
700a7212: 9801         	ldr	r0, [sp, #0x4]
700a7214: b006         	add	sp, #0x18
700a7216: bd80         	pop	{r7, pc}
		...

700a7220 <Sciclient_pmModuleGetClkStatus>:
; {
700a7220: b580         	push	{r7, lr}
700a7222: b096         	sub	sp, #0x58
700a7224: 9015         	str	r0, [sp, #0x54]
700a7226: 9114         	str	r1, [sp, #0x50]
700a7228: 9213         	str	r2, [sp, #0x4c]
700a722a: 9312         	str	r3, [sp, #0x48]
700a722c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a722e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a7230: 9815         	ldr	r0, [sp, #0x54]
700a7232: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a7234: 9814         	ldr	r0, [sp, #0x50]
700a7236: 28ff         	cmp	r0, #0xff
700a7238: d307         	blo	0x700a724a <Sciclient_pmModuleGetClkStatus+0x2a> @ imm = #0xe
700a723a: e7ff         	b	0x700a723c <Sciclient_pmModuleGetClkStatus+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a723c: 9814         	ldr	r0, [sp, #0x50]
700a723e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a7242: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a7244: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a7248: e003         	b	0x700a7252 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a724a: 9814         	ldr	r0, [sp, #0x50]
700a724c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a7250: e7ff         	b	0x700a7252 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #-0x2
700a7252: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_resp response = {{0}};
700a7254: f8ad 002c    	strh.w	r0, [sp, #0x2c]
700a7258: 900a         	str	r0, [sp, #0x28]
700a725a: 9009         	str	r0, [sp, #0x24]
700a725c: f240 1101    	movw	r1, #0x101
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK;
700a7260: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a7264: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a7266: 9105         	str	r1, [sp, #0x14]
700a7268: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a726a: 9106         	str	r1, [sp, #0x18]
700a726c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a726e: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a7270: 9912         	ldr	r1, [sp, #0x48]
700a7272: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a7274: 9001         	str	r0, [sp, #0x4]
700a7276: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a7278: 9002         	str	r0, [sp, #0x8]
700a727a: 200a         	movs	r0, #0xa
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a727c: 9003         	str	r0, [sp, #0xc]
700a727e: a804         	add	r0, sp, #0x10
700a7280: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a7282: f7f4 fdfd    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xb406
700a7286: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a7288: 9811         	ldr	r0, [sp, #0x44]
700a728a: b930         	cbnz	r0, 0x700a729a <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #0xc
700a728c: e7ff         	b	0x700a728e <Sciclient_pmModuleGetClkStatus+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a728e: 9801         	ldr	r0, [sp, #0x4]
700a7290: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a7294: 2802         	cmp	r0, #0x2
700a7296: d004         	beq	0x700a72a2 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #0x8
700a7298: e7ff         	b	0x700a729a <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #-0x2
700a729a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a729e: 9011         	str	r0, [sp, #0x44]
;     }
700a72a0: e7ff         	b	0x700a72a2 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a72a2: 9811         	ldr	r0, [sp, #0x44]
700a72a4: b928         	cbnz	r0, 0x700a72b2 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #0xa
700a72a6: e7ff         	b	0x700a72a8 <Sciclient_pmModuleGetClkStatus+0x88> @ imm = #-0x2
;         *state = (uint32_t) response.current_state;
700a72a8: f89d 002d    	ldrb.w	r0, [sp, #0x2d]
700a72ac: 9913         	ldr	r1, [sp, #0x4c]
700a72ae: 6008         	str	r0, [r1]
;     }
700a72b0: e7ff         	b	0x700a72b2 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #-0x2
;     return retVal;
700a72b2: 9811         	ldr	r0, [sp, #0x44]
700a72b4: b016         	add	sp, #0x58
700a72b6: bd80         	pop	{r7, pc}
		...

700a72c0 <xQueueReceiveFromISR>:
; {
700a72c0: b580         	push	{r7, lr}
700a72c2: b088         	sub	sp, #0x20
700a72c4: 9007         	str	r0, [sp, #0x1c]
700a72c6: 9106         	str	r1, [sp, #0x18]
700a72c8: 9205         	str	r2, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a72ca: 9807         	ldr	r0, [sp, #0x1c]
700a72cc: 9002         	str	r0, [sp, #0x8]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a72ce: f007 e860    	blx	0x700ae390 <HwiP_disable> @ imm = #0x70c0
700a72d2: 9003         	str	r0, [sp, #0xc]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a72d4: 9802         	ldr	r0, [sp, #0x8]
700a72d6: 6b80         	ldr	r0, [r0, #0x38]
700a72d8: 9001         	str	r0, [sp, #0x4]
;         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a72da: 9801         	ldr	r0, [sp, #0x4]
700a72dc: b398         	cbz	r0, 0x700a7346 <xQueueReceiveFromISR+0x86> @ imm = #0x66
700a72de: e7ff         	b	0x700a72e0 <xQueueReceiveFromISR+0x20> @ imm = #-0x2
;             const int8_t cRxLock = pxQueue->cRxLock;
700a72e0: 9802         	ldr	r0, [sp, #0x8]
700a72e2: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a72e6: f88d 0003    	strb.w	r0, [sp, #0x3]
;             prvCopyDataFromQueue( pxQueue, pvBuffer );
700a72ea: 9802         	ldr	r0, [sp, #0x8]
700a72ec: 9906         	ldr	r1, [sp, #0x18]
700a72ee: f004 fadf    	bl	0x700ab8b0 <prvCopyDataFromQueue> @ imm = #0x45be
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a72f2: 9801         	ldr	r0, [sp, #0x4]
700a72f4: 3801         	subs	r0, #0x1
700a72f6: 9902         	ldr	r1, [sp, #0x8]
700a72f8: 6388         	str	r0, [r1, #0x38]
;             if( cRxLock == queueUNLOCKED )
700a72fa: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a72fe: 3001         	adds	r0, #0x1
700a7300: b9b8         	cbnz	r0, 0x700a7332 <xQueueReceiveFromISR+0x72> @ imm = #0x2e
700a7302: e7ff         	b	0x700a7304 <xQueueReceiveFromISR+0x44> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a7304: 9802         	ldr	r0, [sp, #0x8]
700a7306: 6900         	ldr	r0, [r0, #0x10]
700a7308: b188         	cbz	r0, 0x700a732e <xQueueReceiveFromISR+0x6e> @ imm = #0x22
700a730a: e7ff         	b	0x700a730c <xQueueReceiveFromISR+0x4c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a730c: 9802         	ldr	r0, [sp, #0x8]
700a730e: 3010         	adds	r0, #0x10
700a7310: f7fe ffb6    	bl	0x700a6280 <xTaskRemoveFromEventList> @ imm = #-0x1094
700a7314: b148         	cbz	r0, 0x700a732a <xQueueReceiveFromISR+0x6a> @ imm = #0x12
700a7316: e7ff         	b	0x700a7318 <xQueueReceiveFromISR+0x58> @ imm = #-0x2
;                         if( pxHigherPriorityTaskWoken != NULL )
700a7318: 9805         	ldr	r0, [sp, #0x14]
700a731a: b120         	cbz	r0, 0x700a7326 <xQueueReceiveFromISR+0x66> @ imm = #0x8
700a731c: e7ff         	b	0x700a731e <xQueueReceiveFromISR+0x5e> @ imm = #-0x2
;                             *pxHigherPriorityTaskWoken = pdTRUE;
700a731e: 9905         	ldr	r1, [sp, #0x14]
700a7320: 2001         	movs	r0, #0x1
700a7322: 6008         	str	r0, [r1]
;                         }
700a7324: e000         	b	0x700a7328 <xQueueReceiveFromISR+0x68> @ imm = #0x0
700a7326: e7ff         	b	0x700a7328 <xQueueReceiveFromISR+0x68> @ imm = #-0x2
;                     }
700a7328: e000         	b	0x700a732c <xQueueReceiveFromISR+0x6c> @ imm = #0x0
700a732a: e7ff         	b	0x700a732c <xQueueReceiveFromISR+0x6c> @ imm = #-0x2
;                 }
700a732c: e000         	b	0x700a7330 <xQueueReceiveFromISR+0x70> @ imm = #0x0
700a732e: e7ff         	b	0x700a7330 <xQueueReceiveFromISR+0x70> @ imm = #-0x2
;             }
700a7330: e006         	b	0x700a7340 <xQueueReceiveFromISR+0x80> @ imm = #0xc
;                 pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
700a7332: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a7336: 3001         	adds	r0, #0x1
700a7338: 9902         	ldr	r1, [sp, #0x8]
700a733a: f881 0044    	strb.w	r0, [r1, #0x44]
700a733e: e7ff         	b	0x700a7340 <xQueueReceiveFromISR+0x80> @ imm = #-0x2
700a7340: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a7342: 9004         	str	r0, [sp, #0x10]
;         }
700a7344: e002         	b	0x700a734c <xQueueReceiveFromISR+0x8c> @ imm = #0x4
700a7346: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700a7348: 9004         	str	r0, [sp, #0x10]
700a734a: e7ff         	b	0x700a734c <xQueueReceiveFromISR+0x8c> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a734c: 9803         	ldr	r0, [sp, #0xc]
700a734e: f007 e840    	blx	0x700ae3d0 <HwiP_restore> @ imm = #0x7080
;     return xReturn;
700a7352: 9804         	ldr	r0, [sp, #0x10]
700a7354: b008         	add	sp, #0x20
700a7356: bd80         	pop	{r7, pc}
		...

700a7360 <xTaskCreate>:
;     UBaseType_t uxPriority, TaskHandle_t *const pxCreatedTask) {
700a7360: b570         	push	{r4, r5, r6, lr}
700a7362: b08c         	sub	sp, #0x30
700a7364: f8dd c044    	ldr.w	r12, [sp, #0x44]
700a7368: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a736c: 900b         	str	r0, [sp, #0x2c]
700a736e: 910a         	str	r1, [sp, #0x28]
700a7370: 9209         	str	r2, [sp, #0x24]
700a7372: 9308         	str	r3, [sp, #0x20]
;         (((size_t)usStackDepth) *
700a7374: 9809         	ldr	r0, [sp, #0x24]
700a7376: 0080         	lsls	r0, r0, #0x2
;     pxStack = (StackType_t *)pvPortMalloc(
700a7378: f005 fed2    	bl	0x700ad120 <pvPortMalloc> @ imm = #0x5da4
700a737c: 9005         	str	r0, [sp, #0x14]
;     if (pxStack != NULL) {
700a737e: 9805         	ldr	r0, [sp, #0x14]
700a7380: b180         	cbz	r0, 0x700a73a4 <xTaskCreate+0x44> @ imm = #0x20
700a7382: e7ff         	b	0x700a7384 <xTaskCreate+0x24> @ imm = #-0x2
700a7384: 208c         	movs	r0, #0x8c
;       pxNewTCB = (TCB_t *)pvPortMalloc(
700a7386: f005 fecb    	bl	0x700ad120 <pvPortMalloc> @ imm = #0x5d96
700a738a: 9007         	str	r0, [sp, #0x1c]
;       if (pxNewTCB != NULL) {
700a738c: 9807         	ldr	r0, [sp, #0x1c]
700a738e: b120         	cbz	r0, 0x700a739a <xTaskCreate+0x3a> @ imm = #0x8
700a7390: e7ff         	b	0x700a7392 <xTaskCreate+0x32> @ imm = #-0x2
;         pxNewTCB->pxStack = pxStack;
700a7392: 9805         	ldr	r0, [sp, #0x14]
700a7394: 9907         	ldr	r1, [sp, #0x1c]
700a7396: 6308         	str	r0, [r1, #0x30]
;       } else {
700a7398: e003         	b	0x700a73a2 <xTaskCreate+0x42> @ imm = #0x6
;         vPortFree(pxStack);
700a739a: 9805         	ldr	r0, [sp, #0x14]
700a739c: f005 fde0    	bl	0x700acf60 <vPortFree>  @ imm = #0x5bc0
700a73a0: e7ff         	b	0x700a73a2 <xTaskCreate+0x42> @ imm = #-0x2
;     } else {
700a73a2: e002         	b	0x700a73aa <xTaskCreate+0x4a> @ imm = #0x4
700a73a4: 2000         	movs	r0, #0x0
;       pxNewTCB = NULL;
700a73a6: 9007         	str	r0, [sp, #0x1c]
700a73a8: e7ff         	b	0x700a73aa <xTaskCreate+0x4a> @ imm = #-0x2
;   if (pxNewTCB != NULL) {
700a73aa: 9807         	ldr	r0, [sp, #0x1c]
700a73ac: b1e8         	cbz	r0, 0x700a73ea <xTaskCreate+0x8a> @ imm = #0x3a
700a73ae: e7ff         	b	0x700a73b0 <xTaskCreate+0x50> @ imm = #-0x2
;       pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
700a73b0: 9807         	ldr	r0, [sp, #0x1c]
700a73b2: 2600         	movs	r6, #0x0
700a73b4: f880 6086    	strb.w	r6, [r0, #0x86]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a73b8: 980b         	ldr	r0, [sp, #0x2c]
700a73ba: 990a         	ldr	r1, [sp, #0x28]
700a73bc: 9a09         	ldr	r2, [sp, #0x24]
;                          pvParameters, uxPriority, pxCreatedTask, pxNewTCB,
700a73be: 9b08         	ldr	r3, [sp, #0x20]
700a73c0: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a73c4: 9c11         	ldr	r4, [sp, #0x44]
700a73c6: 9d07         	ldr	r5, [sp, #0x1c]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a73c8: 46ee         	mov	lr, sp
700a73ca: f8ce 600c    	str.w	r6, [lr, #0xc]
700a73ce: f8ce 5008    	str.w	r5, [lr, #0x8]
700a73d2: f8ce 4004    	str.w	r4, [lr, #0x4]
700a73d6: f8ce c000    	str.w	r12, [lr]
700a73da: f7fb fc49    	bl	0x700a2c70 <prvInitialiseNewTask> @ imm = #-0x476e
;     prvAddNewTaskToReadyList(pxNewTCB);
700a73de: 9807         	ldr	r0, [sp, #0x1c]
700a73e0: f7fc f92e    	bl	0x700a3640 <prvAddNewTaskToReadyList> @ imm = #-0x3da4
700a73e4: 2001         	movs	r0, #0x1
;     xReturn = pdPASS;
700a73e6: 9006         	str	r0, [sp, #0x18]
;   } else {
700a73e8: e003         	b	0x700a73f2 <xTaskCreate+0x92> @ imm = #0x6
700a73ea: f04f 30ff    	mov.w	r0, #0xffffffff
;     xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
700a73ee: 9006         	str	r0, [sp, #0x18]
700a73f0: e7ff         	b	0x700a73f2 <xTaskCreate+0x92> @ imm = #-0x2
;   return xReturn;
700a73f2: 9806         	ldr	r0, [sp, #0x18]
700a73f4: b00c         	add	sp, #0x30
700a73f6: bd70         	pop	{r4, r5, r6, pc}
		...

700a7400 <PMU_profileStart>:
; int32_t PMU_profileStart(const char *name) {
700a7400: b580         	push	{r7, lr}
700a7402: b088         	sub	sp, #0x20
700a7404: 9006         	str	r0, [sp, #0x18]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a7406: f243 0080    	movw	r0, #0x3080
700a740a: f2c7 0008    	movt	r0, #0x7008
700a740e: 6800         	ldr	r0, [r0]
700a7410: 2840         	cmp	r0, #0x40
700a7412: d304         	blo	0x700a741e <PMU_profileStart+0x1e> @ imm = #0x8
700a7414: e7ff         	b	0x700a7416 <PMU_profileStart+0x16> @ imm = #-0x2
700a7416: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a741a: 9007         	str	r0, [sp, #0x1c]
700a741c: e038         	b	0x700a7490 <PMU_profileStart+0x90> @ imm = #0x70
;   uint32_t i = gProfileObject.logIndex;
700a741e: f243 0280    	movw	r2, #0x3080
700a7422: f2c7 0208    	movt	r2, #0x7008
700a7426: 6810         	ldr	r0, [r2]
700a7428: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a742a: 6890         	ldr	r0, [r2, #0x8]
700a742c: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a742e: 6850         	ldr	r0, [r2, #0x4]
700a7430: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a7432: 9805         	ldr	r0, [sp, #0x14]
700a7434: 2134         	movs	r1, #0x34
700a7436: fb00 2001    	mla	r0, r0, r1, r2
700a743a: 300c         	adds	r0, #0xc
700a743c: 9001         	str	r0, [sp, #0x4]
;   p->name = name;
700a743e: 9806         	ldr	r0, [sp, #0x18]
700a7440: 9901         	ldr	r1, [sp, #0x4]
700a7442: 6308         	str	r0, [r1, #0x30]
;   PMU_resetCounters();
700a7444: f006 f96c    	bl	0x700ad720 <PMU_resetCounters> @ imm = #0x62d8
;   if (bCCnt == TRUE) {
700a7448: 9802         	ldr	r0, [sp, #0x8]
700a744a: 2801         	cmp	r0, #0x1
700a744c: d106         	bne	0x700a745c <PMU_profileStart+0x5c> @ imm = #0xc
700a744e: e7ff         	b	0x700a7450 <PMU_profileStart+0x50> @ imm = #-0x2
700a7450: 201f         	movs	r0, #0x1f
;         CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a7452: f7f8 eff4    	blx	0x700a043c <CSL_armR5PmuReadCntr> @ imm = #-0x7018
;     p->cycleCount.value =
700a7456: 9901         	ldr	r1, [sp, #0x4]
700a7458: 62c8         	str	r0, [r1, #0x2c]
;   }
700a745a: e7ff         	b	0x700a745c <PMU_profileStart+0x5c> @ imm = #-0x2
700a745c: 2000         	movs	r0, #0x0
;   for (j = 0; j < numEvents; j++) {
700a745e: 9004         	str	r0, [sp, #0x10]
700a7460: e7ff         	b	0x700a7462 <PMU_profileStart+0x62> @ imm = #-0x2
700a7462: 9804         	ldr	r0, [sp, #0x10]
700a7464: 9903         	ldr	r1, [sp, #0xc]
700a7466: 4288         	cmp	r0, r1
700a7468: d20f         	bhs	0x700a748a <PMU_profileStart+0x8a> @ imm = #0x1e
700a746a: e7ff         	b	0x700a746c <PMU_profileStart+0x6c> @ imm = #-0x2
;     p->events[j].value = CSL_armR5PmuReadCntr(j);
700a746c: 9804         	ldr	r0, [sp, #0x10]
700a746e: f7f8 efe6    	blx	0x700a043c <CSL_armR5PmuReadCntr> @ imm = #-0x7034
700a7472: 9901         	ldr	r1, [sp, #0x4]
700a7474: 9a04         	ldr	r2, [sp, #0x10]
700a7476: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a747a: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a747e: 6088         	str	r0, [r1, #0x8]
;   }
700a7480: e7ff         	b	0x700a7482 <PMU_profileStart+0x82> @ imm = #-0x2
;   for (j = 0; j < numEvents; j++) {
700a7482: 9804         	ldr	r0, [sp, #0x10]
700a7484: 3001         	adds	r0, #0x1
700a7486: 9004         	str	r0, [sp, #0x10]
700a7488: e7eb         	b	0x700a7462 <PMU_profileStart+0x62> @ imm = #-0x2a
700a748a: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
700a748c: 9007         	str	r0, [sp, #0x1c]
700a748e: e7ff         	b	0x700a7490 <PMU_profileStart+0x90> @ imm = #-0x2
; }
700a7490: 9807         	ldr	r0, [sp, #0x1c]
700a7492: b008         	add	sp, #0x20
700a7494: bd80         	pop	{r7, pc}
		...
700a749e: 0000         	movs	r0, r0

700a74a0 <Sciclient_init>:
; {
700a74a0: b580         	push	{r7, lr}
700a74a2: b086         	sub	sp, #0x18
700a74a4: 9005         	str	r0, [sp, #0x14]
700a74a6: 2100         	movs	r1, #0x0
;     int32_t   status = SystemP_SUCCESS;
700a74a8: 9101         	str	r1, [sp, #0x4]
700a74aa: 9104         	str	r1, [sp, #0x10]
;         = (CSL_sec_proxyRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRegs);
700a74ac: f240 00e8    	movw	r0, #0xe8
700a74b0: f2c7 000b    	movt	r0, #0x700b
700a74b4: 9002         	str	r0, [sp, #0x8]
700a74b6: 6800         	ldr	r0, [r0]
700a74b8: f7fc fbc2    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x387c
700a74bc: 9901         	ldr	r1, [sp, #0x4]
700a74be: 4602         	mov	r2, r0
700a74c0: 9802         	ldr	r0, [sp, #0x8]
700a74c2: 6002         	str	r2, [r0]
;         = (CSL_sec_proxy_scfgRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyScfgRegs);
700a74c4: 6840         	ldr	r0, [r0, #0x4]
700a74c6: f7fc fbbb    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x388a
700a74ca: 9901         	ldr	r1, [sp, #0x4]
700a74cc: 4602         	mov	r2, r0
700a74ce: 9802         	ldr	r0, [sp, #0x8]
700a74d0: 6042         	str	r2, [r0, #0x4]
;         = (CSL_sec_proxy_rtRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRtRegs);
700a74d2: 6880         	ldr	r0, [r0, #0x8]
700a74d4: f7fc fbb4    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x3898
700a74d8: 9902         	ldr	r1, [sp, #0x8]
700a74da: 6088         	str	r0, [r1, #0x8]
;         = (uint64_t)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.proxyTargetAddr);
700a74dc: 6908         	ldr	r0, [r1, #0x10]
700a74de: 6949         	ldr	r1, [r1, #0x14]
700a74e0: f7fc fbae    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x38a4
700a74e4: 9a02         	ldr	r2, [sp, #0x8]
700a74e6: 4601         	mov	r1, r0
700a74e8: 9801         	ldr	r0, [sp, #0x4]
700a74ea: 6150         	str	r0, [r2, #0x14]
700a74ec: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.currSeqId = 0;
700a74ee: f240 1138    	movw	r1, #0x138
700a74f2: f2c7 010b    	movt	r1, #0x700b
700a74f6: 9103         	str	r1, [sp, #0xc]
700a74f8: 6008         	str	r0, [r1]
;     gSciclientHandle.coreId = coreId;
700a74fa: 9805         	ldr	r0, [sp, #0x14]
700a74fc: 6048         	str	r0, [r1, #0x4]
;     gSciclientHandle.devIdCore = Sciclient_getDevId(coreId);
700a74fe: 9805         	ldr	r0, [sp, #0x14]
700a7500: f003 fe96    	bl	0x700ab230 <Sciclient_getDevId> @ imm = #0x3d2c
700a7504: 9a03         	ldr	r2, [sp, #0xc]
700a7506: 4601         	mov	r1, r0
700a7508: 9801         	ldr	r0, [sp, #0x4]
700a750a: 6091         	str	r1, [r2, #0x8]
;     gSciclientHandle.secureContextId = Sciclient_getContext(SCICLIENT_SECURE_CONTEXT, coreId);
700a750c: 9905         	ldr	r1, [sp, #0x14]
700a750e: f7ff fb67    	bl	0x700a6be0 <Sciclient_getContext> @ imm = #-0x932
700a7512: 9903         	ldr	r1, [sp, #0xc]
700a7514: 60c8         	str	r0, [r1, #0xc]
;     gSciclientHandle.nonSecureContextId = Sciclient_getContext(SCICLIENT_NON_SECURE_CONTEXT, coreId);
700a7516: 9905         	ldr	r1, [sp, #0x14]
700a7518: 2001         	movs	r0, #0x1
700a751a: f7ff fb61    	bl	0x700a6be0 <Sciclient_getContext> @ imm = #-0x93e
700a751e: 9a03         	ldr	r2, [sp, #0xc]
700a7520: 4601         	mov	r1, r0
700a7522: 9802         	ldr	r0, [sp, #0x8]
700a7524: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
700a7526: f005 f803    	bl	0x700ac530 <CSL_secProxyGetMaxMsgSize> @ imm = #0x5006
700a752a: 9903         	ldr	r1, [sp, #0xc]
700a752c: 3804         	subs	r0, #0x4
700a752e: 6148         	str	r0, [r1, #0x14]
;     return status;
700a7530: 9804         	ldr	r0, [sp, #0x10]
700a7532: b006         	add	sp, #0x18
700a7534: bd80         	pop	{r7, pc}
		...
700a753e: 0000         	movs	r0, r0

700a7540 <UART_subConfigTCRTLRModeEn>:
; {
700a7540: b580         	push	{r7, lr}
700a7542: b088         	sub	sp, #0x20
700a7544: 9007         	str	r0, [sp, #0x1c]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a7546: 9807         	ldr	r0, [sp, #0x1c]
700a7548: 21bf         	movs	r1, #0xbf
700a754a: 9101         	str	r1, [sp, #0x4]
700a754c: f003 f868    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x30d0
700a7550: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a7552: 9807         	ldr	r0, [sp, #0x1c]
700a7554: 3008         	adds	r0, #0x8
700a7556: 2110         	movs	r1, #0x10
700a7558: 9102         	str	r1, [sp, #0x8]
700a755a: 2204         	movs	r2, #0x4
700a755c: 9203         	str	r2, [sp, #0xc]
700a755e: f005 fccf    	bl	0x700acf00 <HW_RD_FIELD32_RAW> @ imm = #0x599e
700a7562: 9902         	ldr	r1, [sp, #0x8]
700a7564: 9a03         	ldr	r2, [sp, #0xc]
700a7566: 9006         	str	r0, [sp, #0x18]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a7568: 9807         	ldr	r0, [sp, #0x1c]
700a756a: 3008         	adds	r0, #0x8
700a756c: 2301         	movs	r3, #0x1
700a756e: 9300         	str	r3, [sp]
700a7570: f004 fede    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x4dbc
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a7574: 9807         	ldr	r0, [sp, #0x1c]
700a7576: 300c         	adds	r0, #0xc
700a7578: 9904         	ldr	r1, [sp, #0x10]
700a757a: f006 f861    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x60c2
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a757e: 9807         	ldr	r0, [sp, #0x1c]
700a7580: 2180         	movs	r1, #0x80
700a7582: f003 f84d    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x309a
700a7586: 9004         	str	r0, [sp, #0x10]
;     tcrTlrValue = HW_RD_REG32(baseAddr + UART_MCR) & UART_MCR_TCR_TLR_MASK;
700a7588: 9807         	ldr	r0, [sp, #0x1c]
700a758a: 3010         	adds	r0, #0x10
700a758c: f006 f850    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x60a0
700a7590: 9b00         	ldr	r3, [sp]
700a7592: f000 0040    	and	r0, r0, #0x40
700a7596: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR,
700a7598: 9807         	ldr	r0, [sp, #0x1c]
700a759a: 3010         	adds	r0, #0x10
700a759c: 2140         	movs	r1, #0x40
700a759e: 2206         	movs	r2, #0x6
700a75a0: f004 fec6    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x4d8c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a75a4: 9807         	ldr	r0, [sp, #0x1c]
700a75a6: 300c         	adds	r0, #0xc
700a75a8: 9904         	ldr	r1, [sp, #0x10]
700a75aa: f006 f849    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x6092
700a75ae: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a75b0: 9807         	ldr	r0, [sp, #0x1c]
700a75b2: f003 f835    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x306a
700a75b6: 9902         	ldr	r1, [sp, #0x8]
700a75b8: 9a03         	ldr	r2, [sp, #0xc]
700a75ba: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a75bc: 9807         	ldr	r0, [sp, #0x1c]
700a75be: 3008         	adds	r0, #0x8
700a75c0: 9b06         	ldr	r3, [sp, #0x18]
700a75c2: f004 feb5    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x4d6a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a75c6: 9807         	ldr	r0, [sp, #0x1c]
700a75c8: 300c         	adds	r0, #0xc
700a75ca: 9904         	ldr	r1, [sp, #0x10]
700a75cc: f006 f838    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x6070
;     return tcrTlrValue;
700a75d0: 9805         	ldr	r0, [sp, #0x14]
700a75d2: b008         	add	sp, #0x20
700a75d4: bd80         	pop	{r7, pc}
		...
700a75de: 0000         	movs	r0, r0

700a75e0 <UART_udmaIsrRx>:
; {
700a75e0: b580         	push	{r7, lr}
700a75e2: b08a         	sub	sp, #0x28
700a75e4: 9009         	str	r0, [sp, #0x24]
700a75e6: 9108         	str	r1, [sp, #0x20]
700a75e8: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a75ea: 9807         	ldr	r0, [sp, #0x1c]
700a75ec: 2800         	cmp	r0, #0x0
700a75ee: d040         	beq	0x700a7672 <UART_udmaIsrRx+0x92> @ imm = #0x80
700a75f0: e7ff         	b	0x700a75f2 <UART_udmaIsrRx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a75f2: 9807         	ldr	r0, [sp, #0x1c]
700a75f4: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a75f6: 9800         	ldr	r0, [sp]
700a75f8: 6840         	ldr	r0, [r0, #0x4]
700a75fa: 6cc0         	ldr	r0, [r0, #0x4c]
700a75fc: 9001         	str	r0, [sp, #0x4]
;         rxChHandle  = udmaChCfg->rxChHandle;
700a75fe: 9801         	ldr	r0, [sp, #0x4]
700a7600: 6880         	ldr	r0, [r0, #0x8]
700a7602: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a7604: 9808         	ldr	r0, [sp, #0x20]
700a7606: 2801         	cmp	r0, #0x1
700a7608: d12e         	bne	0x700a7668 <UART_udmaIsrRx+0x88> @ imm = #0x5c
700a760a: e7ff         	b	0x700a760c <UART_udmaIsrRx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->rxHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a760c: 9901         	ldr	r1, [sp, #0x4]
700a760e: 6988         	ldr	r0, [r1, #0x18]
700a7610: 69c9         	ldr	r1, [r1, #0x1c]
700a7612: 220a         	movs	r2, #0xa
700a7614: f007 f94c    	bl	0x700ae8b0 <CacheP_inv> @ imm = #0x7298
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a7618: 9802         	ldr	r0, [sp, #0x8]
700a761a: f001 fc41    	bl	0x700a8ea0 <Udma_chGetCqRingHandle> @ imm = #0x1882
700a761e: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a7620: f000 f8ce    	bl	0x700a77c0 <Udma_ringDequeueRaw> @ imm = #0x19c
700a7624: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a7626: 9806         	ldr	r0, [sp, #0x18]
700a7628: b988         	cbnz	r0, 0x700a764e <UART_udmaIsrRx+0x6e> @ imm = #0x22
700a762a: e7ff         	b	0x700a762c <UART_udmaIsrRx+0x4c> @ imm = #-0x2
700a762c: 9804         	ldr	r0, [sp, #0x10]
700a762e: 9905         	ldr	r1, [sp, #0x14]
700a7630: 4308         	orrs	r0, r1
700a7632: b160         	cbz	r0, 0x700a764e <UART_udmaIsrRx+0x6e> @ imm = #0x18
700a7634: e7ff         	b	0x700a7636 <UART_udmaIsrRx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a7636: 9804         	ldr	r0, [sp, #0x10]
700a7638: 9003         	str	r0, [sp, #0xc]
;                 hUart->readTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a763a: 9803         	ldr	r0, [sp, #0xc]
700a763c: 6800         	ldr	r0, [r0]
700a763e: f36f 509f    	bfc	r0, #22, #10
700a7642: 9900         	ldr	r1, [sp]
700a7644: 62c8         	str	r0, [r1, #0x2c]
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a7646: 9900         	ldr	r1, [sp]
700a7648: 2000         	movs	r0, #0x0
700a764a: 6348         	str	r0, [r1, #0x34]
;             }
700a764c: e003         	b	0x700a7656 <UART_udmaIsrRx+0x76> @ imm = #0x6
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a764e: 9900         	ldr	r1, [sp]
700a7650: 200a         	movs	r0, #0xa
700a7652: 6348         	str	r0, [r1, #0x34]
700a7654: e7ff         	b	0x700a7656 <UART_udmaIsrRx+0x76> @ imm = #-0x2
;             hUart->hUartInit->readCompleteCallbackFxn(hUart);
700a7656: 9800         	ldr	r0, [sp]
700a7658: 6841         	ldr	r1, [r0, #0x4]
700a765a: 6dc9         	ldr	r1, [r1, #0x5c]
700a765c: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a765e: 9800         	ldr	r0, [sp]
700a7660: 3028         	adds	r0, #0x28
700a7662: f005 fcdd    	bl	0x700ad020 <UART_lld_Transaction_deInit> @ imm = #0x59ba
;         }
700a7666: e003         	b	0x700a7670 <UART_udmaIsrRx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a7668: 9900         	ldr	r1, [sp]
700a766a: 200a         	movs	r0, #0xa
700a766c: 6488         	str	r0, [r1, #0x48]
700a766e: e7ff         	b	0x700a7670 <UART_udmaIsrRx+0x90> @ imm = #-0x2
;     }
700a7670: e7ff         	b	0x700a7672 <UART_udmaIsrRx+0x92> @ imm = #-0x2
;     return;
700a7672: b00a         	add	sp, #0x28
700a7674: bd80         	pop	{r7, pc}
		...
700a767e: 0000         	movs	r0, r0

700a7680 <UART_udmaIsrTx>:
; {
700a7680: b580         	push	{r7, lr}
700a7682: b08a         	sub	sp, #0x28
700a7684: 9009         	str	r0, [sp, #0x24]
700a7686: 9108         	str	r1, [sp, #0x20]
700a7688: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a768a: 9807         	ldr	r0, [sp, #0x1c]
700a768c: 2800         	cmp	r0, #0x0
700a768e: d040         	beq	0x700a7712 <UART_udmaIsrTx+0x92> @ imm = #0x80
700a7690: e7ff         	b	0x700a7692 <UART_udmaIsrTx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a7692: 9807         	ldr	r0, [sp, #0x1c]
700a7694: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a7696: 9800         	ldr	r0, [sp]
700a7698: 6840         	ldr	r0, [r0, #0x4]
700a769a: 6cc0         	ldr	r0, [r0, #0x4c]
700a769c: 9001         	str	r0, [sp, #0x4]
;         txChHandle  = udmaChCfg->txChHandle;
700a769e: 9801         	ldr	r0, [sp, #0x4]
700a76a0: 6840         	ldr	r0, [r0, #0x4]
700a76a2: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a76a4: 9808         	ldr	r0, [sp, #0x20]
700a76a6: 2801         	cmp	r0, #0x1
700a76a8: d12e         	bne	0x700a7708 <UART_udmaIsrTx+0x88> @ imm = #0x5c
700a76aa: e7ff         	b	0x700a76ac <UART_udmaIsrTx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->txHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a76ac: 9901         	ldr	r1, [sp, #0x4]
700a76ae: 6948         	ldr	r0, [r1, #0x14]
700a76b0: 69c9         	ldr	r1, [r1, #0x1c]
700a76b2: 220a         	movs	r2, #0xa
700a76b4: f007 f8fc    	bl	0x700ae8b0 <CacheP_inv> @ imm = #0x71f8
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a76b8: 9802         	ldr	r0, [sp, #0x8]
700a76ba: f001 fbf1    	bl	0x700a8ea0 <Udma_chGetCqRingHandle> @ imm = #0x17e2
700a76be: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a76c0: f000 f87e    	bl	0x700a77c0 <Udma_ringDequeueRaw> @ imm = #0xfc
700a76c4: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a76c6: 9806         	ldr	r0, [sp, #0x18]
700a76c8: b988         	cbnz	r0, 0x700a76ee <UART_udmaIsrTx+0x6e> @ imm = #0x22
700a76ca: e7ff         	b	0x700a76cc <UART_udmaIsrTx+0x4c> @ imm = #-0x2
700a76cc: 9804         	ldr	r0, [sp, #0x10]
700a76ce: 9905         	ldr	r1, [sp, #0x14]
700a76d0: 4308         	orrs	r0, r1
700a76d2: b160         	cbz	r0, 0x700a76ee <UART_udmaIsrTx+0x6e> @ imm = #0x18
700a76d4: e7ff         	b	0x700a76d6 <UART_udmaIsrTx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a76d6: 9804         	ldr	r0, [sp, #0x10]
700a76d8: 9003         	str	r0, [sp, #0xc]
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a76da: 9900         	ldr	r1, [sp]
700a76dc: 2000         	movs	r0, #0x0
700a76de: 6488         	str	r0, [r1, #0x48]
;                 hUart->writeTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a76e0: 9803         	ldr	r0, [sp, #0xc]
700a76e2: 6800         	ldr	r0, [r0]
700a76e4: f36f 509f    	bfc	r0, #22, #10
700a76e8: 9900         	ldr	r1, [sp]
700a76ea: 6408         	str	r0, [r1, #0x40]
;             }
700a76ec: e003         	b	0x700a76f6 <UART_udmaIsrTx+0x76> @ imm = #0x6
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a76ee: 9900         	ldr	r1, [sp]
700a76f0: 200a         	movs	r0, #0xa
700a76f2: 6488         	str	r0, [r1, #0x48]
700a76f4: e7ff         	b	0x700a76f6 <UART_udmaIsrTx+0x76> @ imm = #-0x2
;             hUart->hUartInit->writeCompleteCallbackFxn(hUart);
700a76f6: 9800         	ldr	r0, [sp]
700a76f8: 6841         	ldr	r1, [r0, #0x4]
700a76fa: 6e09         	ldr	r1, [r1, #0x60]
700a76fc: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a76fe: 9800         	ldr	r0, [sp]
700a7700: 303c         	adds	r0, #0x3c
700a7702: f005 fc8d    	bl	0x700ad020 <UART_lld_Transaction_deInit> @ imm = #0x591a
;         }
700a7706: e003         	b	0x700a7710 <UART_udmaIsrTx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a7708: 9900         	ldr	r1, [sp]
700a770a: 200a         	movs	r0, #0xa
700a770c: 6488         	str	r0, [r1, #0x48]
700a770e: e7ff         	b	0x700a7710 <UART_udmaIsrTx+0x90> @ imm = #-0x2
;     }
700a7710: e7ff         	b	0x700a7712 <UART_udmaIsrTx+0x92> @ imm = #-0x2
;     return;
700a7712: b00a         	add	sp, #0x28
700a7714: bd80         	pop	{r7, pc}
		...
700a771e: 0000         	movs	r0, r0

700a7720 <UdmaFlowPrms_init>:
; {
700a7720: b084         	sub	sp, #0x10
700a7722: 9003         	str	r0, [sp, #0xc]
700a7724: 9102         	str	r1, [sp, #0x8]
;     if(NULL_PTR != flowPrms)
700a7726: 9803         	ldr	r0, [sp, #0xc]
700a7728: 2800         	cmp	r0, #0x0
700a772a: d042         	beq	0x700a77b2 <UdmaFlowPrms_init+0x92> @ imm = #0x84
700a772c: e7ff         	b	0x700a772e <UdmaFlowPrms_init+0xe> @ imm = #-0x2
;         flowPrms->rxChHandle    = (Udma_ChHandle) NULL_PTR;
700a772e: 9803         	ldr	r0, [sp, #0xc]
700a7730: 2100         	movs	r1, #0x0
700a7732: 9100         	str	r1, [sp]
700a7734: 6001         	str	r1, [r0]
;         flowPrms->einfoPresent  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;
700a7736: 9803         	ldr	r0, [sp, #0xc]
700a7738: 7101         	strb	r1, [r0, #0x4]
;         flowPrms->psInfoPresent = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;
700a773a: 9803         	ldr	r0, [sp, #0xc]
700a773c: 7141         	strb	r1, [r0, #0x5]
;         flowPrms->errorHandling = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;
700a773e: 9a03         	ldr	r2, [sp, #0xc]
700a7740: 2001         	movs	r0, #0x1
700a7742: 7190         	strb	r0, [r2, #0x6]
;         flowPrms->descType      = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DESC_HOST;
700a7744: 9803         	ldr	r0, [sp, #0xc]
700a7746: 71c1         	strb	r1, [r0, #0x7]
;         flowPrms->psLocation    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PS_END_PD;
700a7748: 9803         	ldr	r0, [sp, #0xc]
700a774a: 7201         	strb	r1, [r0, #0x8]
;         flowPrms->sopOffset     = 0U;
700a774c: 9803         	ldr	r0, [sp, #0xc]
700a774e: 8141         	strh	r1, [r0, #0xa]
;         flowPrms->defaultRxCQ   = UDMA_RING_INVALID;
700a7750: 9a03         	ldr	r2, [sp, #0xc]
700a7752: f64f 70ff    	movw	r0, #0xffff
700a7756: 9001         	str	r0, [sp, #0x4]
700a7758: 8190         	strh	r0, [r2, #0xc]
;         flowPrms->srcTagLo      = 0U;
700a775a: 9a03         	ldr	r2, [sp, #0xc]
700a775c: 73d1         	strb	r1, [r2, #0xf]
;         flowPrms->srcTagLoSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_SRC_TAG;
700a775e: 9b03         	ldr	r3, [sp, #0xc]
700a7760: 2204         	movs	r2, #0x4
700a7762: 745a         	strb	r2, [r3, #0x11]
;         flowPrms->srcTagHi      = 0U;
700a7764: 9b03         	ldr	r3, [sp, #0xc]
700a7766: 7399         	strb	r1, [r3, #0xe]
;         flowPrms->srcTagHiSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_FLOW_ID;
700a7768: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700a776c: 2302         	movs	r3, #0x2
700a776e: f88c 3010    	strb.w	r3, [r12, #0x10]
;         flowPrms->destTagLo     = 0U;
700a7772: 9b03         	ldr	r3, [sp, #0xc]
700a7774: 74d9         	strb	r1, [r3, #0x13]
;         flowPrms->destTagLoSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_LO;
700a7776: 9b03         	ldr	r3, [sp, #0xc]
700a7778: 755a         	strb	r2, [r3, #0x15]
;         flowPrms->destTagHi     = 0U;
700a777a: 9a03         	ldr	r2, [sp, #0xc]
700a777c: 7491         	strb	r1, [r2, #0x12]
;         flowPrms->destTagHiSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_HI;
700a777e: 9b03         	ldr	r3, [sp, #0xc]
700a7780: 2205         	movs	r2, #0x5
700a7782: 751a         	strb	r2, [r3, #0x14]
;         flowPrms->sizeThreshEn  = 0U;
700a7784: 9a03         	ldr	r2, [sp, #0xc]
700a7786: 7591         	strb	r1, [r2, #0x16]
;         flowPrms->fdq0Sz0Qnum   = UDMA_RING_INVALID;
700a7788: 9a03         	ldr	r2, [sp, #0xc]
700a778a: 8310         	strh	r0, [r2, #0x18]
;         flowPrms->fdq1Qnum      = UDMA_RING_INVALID;
700a778c: 9a03         	ldr	r2, [sp, #0xc]
700a778e: 8350         	strh	r0, [r2, #0x1a]
;         flowPrms->fdq2Qnum      = UDMA_RING_INVALID;
700a7790: 9a03         	ldr	r2, [sp, #0xc]
700a7792: 8390         	strh	r0, [r2, #0x1c]
;         flowPrms->fdq3Qnum      = UDMA_RING_INVALID;
700a7794: 9a03         	ldr	r2, [sp, #0xc]
700a7796: 83d0         	strh	r0, [r2, #0x1e]
;         flowPrms->sizeThresh0   = 0U;
700a7798: 9a03         	ldr	r2, [sp, #0xc]
700a779a: 8411         	strh	r1, [r2, #0x20]
;         flowPrms->sizeThresh1   = 0U;
700a779c: 9a03         	ldr	r2, [sp, #0xc]
700a779e: 8451         	strh	r1, [r2, #0x22]
;         flowPrms->sizeThresh2   = 0U;
700a77a0: 9a03         	ldr	r2, [sp, #0xc]
700a77a2: 8491         	strh	r1, [r2, #0x24]
;         flowPrms->fdq0Sz1Qnum   = UDMA_RING_INVALID;
700a77a4: 9903         	ldr	r1, [sp, #0xc]
700a77a6: 84c8         	strh	r0, [r1, #0x26]
;         flowPrms->fdq0Sz2Qnum   = UDMA_RING_INVALID;
700a77a8: 9903         	ldr	r1, [sp, #0xc]
700a77aa: 8508         	strh	r0, [r1, #0x28]
;         flowPrms->fdq0Sz3Qnum   = UDMA_RING_INVALID;
700a77ac: 9903         	ldr	r1, [sp, #0xc]
700a77ae: 8548         	strh	r0, [r1, #0x2a]
;     }
700a77b0: e7ff         	b	0x700a77b2 <UdmaFlowPrms_init+0x92> @ imm = #-0x2
;     return;
700a77b2: b004         	add	sp, #0x10
700a77b4: 4770         	bx	lr
		...
700a77be: 0000         	movs	r0, r0

700a77c0 <Udma_ringDequeueRaw>:
; {
700a77c0: b580         	push	{r7, lr}
700a77c2: b086         	sub	sp, #0x18
700a77c4: 9005         	str	r0, [sp, #0x14]
700a77c6: 9104         	str	r1, [sp, #0x10]
700a77c8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a77ca: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a77cc: 9805         	ldr	r0, [sp, #0x14]
700a77ce: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a77d0: 9800         	ldr	r0, [sp]
700a77d2: b180         	cbz	r0, 0x700a77f6 <Udma_ringDequeueRaw+0x36> @ imm = #0x20
700a77d4: e7ff         	b	0x700a77d6 <Udma_ringDequeueRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a77d6: 9800         	ldr	r0, [sp]
700a77d8: 6d80         	ldr	r0, [r0, #0x58]
700a77da: f64a 31cd    	movw	r1, #0xabcd
700a77de: f6ca 31dc    	movt	r1, #0xabdc
700a77e2: 4288         	cmp	r0, r1
700a77e4: d107         	bne	0x700a77f6 <Udma_ringDequeueRaw+0x36> @ imm = #0xe
700a77e6: e7ff         	b	0x700a77e8 <Udma_ringDequeueRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a77e8: 9800         	ldr	r0, [sp]
700a77ea: 8880         	ldrh	r0, [r0, #0x4]
700a77ec: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a77f0: 4288         	cmp	r0, r1
700a77f2: d104         	bne	0x700a77fe <Udma_ringDequeueRaw+0x3e> @ imm = #0x8
700a77f4: e7ff         	b	0x700a77f6 <Udma_ringDequeueRaw+0x36> @ imm = #-0x2
700a77f6: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a77fa: 9003         	str	r0, [sp, #0xc]
;     }
700a77fc: e7ff         	b	0x700a77fe <Udma_ringDequeueRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a77fe: 9803         	ldr	r0, [sp, #0xc]
700a7800: b9a8         	cbnz	r0, 0x700a782e <Udma_ringDequeueRaw+0x6e> @ imm = #0x2a
700a7802: e7ff         	b	0x700a7804 <Udma_ringDequeueRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a7804: 9800         	ldr	r0, [sp]
700a7806: 6800         	ldr	r0, [r0]
700a7808: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a780a: 9801         	ldr	r0, [sp, #0x4]
700a780c: b150         	cbz	r0, 0x700a7824 <Udma_ringDequeueRaw+0x64> @ imm = #0x14
700a780e: e7ff         	b	0x700a7810 <Udma_ringDequeueRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a7810: 9801         	ldr	r0, [sp, #0x4]
700a7812: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7816: f64a 31cd    	movw	r1, #0xabcd
700a781a: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a781e: 4288         	cmp	r0, r1
700a7820: d004         	beq	0x700a782c <Udma_ringDequeueRaw+0x6c> @ imm = #0x8
700a7822: e7ff         	b	0x700a7824 <Udma_ringDequeueRaw+0x64> @ imm = #-0x2
700a7824: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7828: 9003         	str	r0, [sp, #0xc]
;         }
700a782a: e7ff         	b	0x700a782c <Udma_ringDequeueRaw+0x6c> @ imm = #-0x2
;     }
700a782c: e7ff         	b	0x700a782e <Udma_ringDequeueRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a782e: 9803         	ldr	r0, [sp, #0xc]
700a7830: b970         	cbnz	r0, 0x700a7850 <Udma_ringDequeueRaw+0x90> @ imm = #0x1c
700a7832: e7ff         	b	0x700a7834 <Udma_ringDequeueRaw+0x74> @ imm = #-0x2
;         cookie = HwiP_disable();
700a7834: f006 edac    	blx	0x700ae390 <HwiP_disable> @ imm = #0x6b58
700a7838: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringDequeueRaw(drvHandle, ringHandleInt, phyDescMem);
700a783a: 9801         	ldr	r0, [sp, #0x4]
700a783c: f8d0 3590    	ldr.w	r3, [r0, #0x590]
700a7840: 9900         	ldr	r1, [sp]
700a7842: 9a04         	ldr	r2, [sp, #0x10]
700a7844: 4798         	blx	r3
700a7846: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a7848: 9802         	ldr	r0, [sp, #0x8]
700a784a: f006 edc2    	blx	0x700ae3d0 <HwiP_restore> @ imm = #0x6b84
;     }
700a784e: e7ff         	b	0x700a7850 <Udma_ringDequeueRaw+0x90> @ imm = #-0x2
;     return (retVal);
700a7850: 9803         	ldr	r0, [sp, #0xc]
700a7852: b006         	add	sp, #0x18
700a7854: bd80         	pop	{r7, pc}
		...
700a785e: 0000         	movs	r0, r0

700a7860 <vTaskResume>:
; void vTaskResume(TaskHandle_t xTaskToResume) {
700a7860: b580         	push	{r7, lr}
700a7862: b082         	sub	sp, #0x8
700a7864: 9001         	str	r0, [sp, #0x4]
;   TCB_t *const pxTCB = xTaskToResume;
700a7866: 9801         	ldr	r0, [sp, #0x4]
700a7868: 9000         	str	r0, [sp]
;   if ((pxTCB != pxCurrentTCB) && (pxTCB != NULL)) {
700a786a: 9800         	ldr	r0, [sp]
700a786c: f240 11cc    	movw	r1, #0x1cc
700a7870: f2c7 010b    	movt	r1, #0x700b
700a7874: 6809         	ldr	r1, [r1]
700a7876: 4288         	cmp	r0, r1
700a7878: d03a         	beq	0x700a78f0 <vTaskResume+0x90> @ imm = #0x74
700a787a: e7ff         	b	0x700a787c <vTaskResume+0x1c> @ imm = #-0x2
700a787c: 9800         	ldr	r0, [sp]
700a787e: b3b8         	cbz	r0, 0x700a78f0 <vTaskResume+0x90> @ imm = #0x6e
700a7880: e7ff         	b	0x700a7882 <vTaskResume+0x22> @ imm = #-0x2
;     taskENTER_CRITICAL();
700a7882: f004 fdb5    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0x4b6a
;       if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE) {
700a7886: 9800         	ldr	r0, [sp]
700a7888: f003 fbe2    	bl	0x700ab050 <prvTaskIsTaskSuspended> @ imm = #0x37c4
700a788c: b360         	cbz	r0, 0x700a78e8 <vTaskResume+0x88> @ imm = #0x58
700a788e: e7ff         	b	0x700a7890 <vTaskResume+0x30> @ imm = #-0x2
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700a7890: 9800         	ldr	r0, [sp]
700a7892: 3004         	adds	r0, #0x4
700a7894: f003 fde4    	bl	0x700ab460 <uxListRemove> @ imm = #0x3bc8
;         prvAddTaskToReadyList(pxTCB);
700a7898: 9800         	ldr	r0, [sp]
700a789a: 6ac1         	ldr	r1, [r0, #0x2c]
700a789c: 2001         	movs	r0, #0x1
700a789e: fa00 f201    	lsl.w	r2, r0, r1
700a78a2: f240 11f8    	movw	r1, #0x1f8
700a78a6: f2c7 010b    	movt	r1, #0x700b
700a78aa: 6808         	ldr	r0, [r1]
700a78ac: 4310         	orrs	r0, r2
700a78ae: 6008         	str	r0, [r1]
700a78b0: 9900         	ldr	r1, [sp]
700a78b2: 6ac8         	ldr	r0, [r1, #0x2c]
700a78b4: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a78b8: f244 40f8    	movw	r0, #0x44f8
700a78bc: f2c7 0008    	movt	r0, #0x7008
700a78c0: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a78c4: 3104         	adds	r1, #0x4
700a78c6: f004 fb3b    	bl	0x700abf40 <vListInsertEnd> @ imm = #0x4676
;         if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a78ca: 9800         	ldr	r0, [sp]
700a78cc: 6ac0         	ldr	r0, [r0, #0x2c]
700a78ce: f240 11cc    	movw	r1, #0x1cc
700a78d2: f2c7 010b    	movt	r1, #0x700b
700a78d6: 6809         	ldr	r1, [r1]
700a78d8: 6ac9         	ldr	r1, [r1, #0x2c]
700a78da: 4288         	cmp	r0, r1
700a78dc: d302         	blo	0x700a78e4 <vTaskResume+0x84> @ imm = #0x4
700a78de: e7ff         	b	0x700a78e0 <vTaskResume+0x80> @ imm = #-0x2
;           taskYIELD_IF_USING_PREEMPTION();
700a78e0: df00         	svc	#0x0
;         } else {
700a78e2: e000         	b	0x700a78e6 <vTaskResume+0x86> @ imm = #0x0
700a78e4: e7ff         	b	0x700a78e6 <vTaskResume+0x86> @ imm = #-0x2
;       } else {
700a78e6: e000         	b	0x700a78ea <vTaskResume+0x8a> @ imm = #0x0
700a78e8: e7ff         	b	0x700a78ea <vTaskResume+0x8a> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700a78ea: f003 fe81    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x3d02
;   } else {
700a78ee: e000         	b	0x700a78f2 <vTaskResume+0x92> @ imm = #0x0
700a78f0: e7ff         	b	0x700a78f2 <vTaskResume+0x92> @ imm = #-0x2
; }
700a78f2: b002         	add	sp, #0x8
700a78f4: bd80         	pop	{r7, pc}
		...
700a78fe: 0000         	movs	r0, r0

700a7900 <UART_lld_dmaDisableChannel>:
; {
700a7900: b580         	push	{r7, lr}
700a7902: b08a         	sub	sp, #0x28
700a7904: 9009         	str	r0, [sp, #0x24]
700a7906: 9108         	str	r1, [sp, #0x20]
700a7908: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a790a: 9007         	str	r0, [sp, #0x1c]
700a790c: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a790e: 9006         	str	r0, [sp, #0x18]
;     udmaChCfg   = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a7910: 9809         	ldr	r0, [sp, #0x24]
700a7912: 6840         	ldr	r0, [r0, #0x4]
700a7914: 6cc0         	ldr	r0, [r0, #0x4c]
700a7916: 9005         	str	r0, [sp, #0x14]
;     if (isChannelTx == TRUE)
700a7918: 9808         	ldr	r0, [sp, #0x20]
700a791a: 2801         	cmp	r0, #0x1
700a791c: d104         	bne	0x700a7928 <UART_lld_dmaDisableChannel+0x28> @ imm = #0x8
700a791e: e7ff         	b	0x700a7920 <UART_lld_dmaDisableChannel+0x20> @ imm = #-0x2
;         chHandle = udmaChCfg->txChHandle;
700a7920: 9805         	ldr	r0, [sp, #0x14]
700a7922: 6840         	ldr	r0, [r0, #0x4]
700a7924: 9004         	str	r0, [sp, #0x10]
;     }
700a7926: e003         	b	0x700a7930 <UART_lld_dmaDisableChannel+0x30> @ imm = #0x6
;         chHandle = udmaChCfg->rxChHandle;
700a7928: 9805         	ldr	r0, [sp, #0x14]
700a792a: 6880         	ldr	r0, [r0, #0x8]
700a792c: 9004         	str	r0, [sp, #0x10]
700a792e: e7ff         	b	0x700a7930 <UART_lld_dmaDisableChannel+0x30> @ imm = #-0x2
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a7930: 9804         	ldr	r0, [sp, #0x10]
700a7932: 2164         	movs	r1, #0x64
700a7934: f7fe fb9c    	bl	0x700a6070 <Udma_chDisable> @ imm = #-0x18c8
700a7938: 9007         	str	r0, [sp, #0x1c]
;     DebugP_assert(UDMA_SOK == status);
700a793a: 9807         	ldr	r0, [sp, #0x1c]
700a793c: fab0 f080    	clz	r0, r0
700a7940: 0940         	lsrs	r0, r0, #0x5
700a7942: f64f 0169    	movw	r1, #0xf869
700a7946: f2c7 010a    	movt	r1, #0x700a
700a794a: 466a         	mov	r2, sp
700a794c: 6011         	str	r1, [r2]
700a794e: f24f 41b9    	movw	r1, #0xf4b9
700a7952: f2c7 010a    	movt	r1, #0x700a
700a7956: f24f 7237    	movw	r2, #0xf737
700a795a: f2c7 020a    	movt	r2, #0x700a
700a795e: f240 137b    	movw	r3, #0x17b
700a7962: f001 f91d    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #0x123a
;     while(temp == TRUE)
700a7966: e7ff         	b	0x700a7968 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x2
700a7968: 9806         	ldr	r0, [sp, #0x18]
700a796a: 2801         	cmp	r0, #0x1
700a796c: d10f         	bne	0x700a798e <UART_lld_dmaDisableChannel+0x8e> @ imm = #0x1e
700a796e: e7ff         	b	0x700a7970 <UART_lld_dmaDisableChannel+0x70> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a7970: 9804         	ldr	r0, [sp, #0x10]
700a7972: f001 fad5    	bl	0x700a8f20 <Udma_chGetFqRingHandle> @ imm = #0x15aa
700a7976: a902         	add	r1, sp, #0x8
;         tempRetVal = Udma_ringFlushRaw(
700a7978: f000 fbea    	bl	0x700a8150 <Udma_ringFlushRaw> @ imm = #0x7d4
700a797c: 9001         	str	r0, [sp, #0x4]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a797e: 9801         	ldr	r0, [sp, #0x4]
700a7980: 3004         	adds	r0, #0x4
700a7982: b918         	cbnz	r0, 0x700a798c <UART_lld_dmaDisableChannel+0x8c> @ imm = #0x6
700a7984: e7ff         	b	0x700a7986 <UART_lld_dmaDisableChannel+0x86> @ imm = #-0x2
700a7986: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a7988: 9006         	str	r0, [sp, #0x18]
;         }
700a798a: e7ff         	b	0x700a798c <UART_lld_dmaDisableChannel+0x8c> @ imm = #-0x2
;     while(temp == TRUE)
700a798c: e7ec         	b	0x700a7968 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x28
;     return status;
700a798e: 9807         	ldr	r0, [sp, #0x1c]
700a7990: b00a         	add	sp, #0x28
700a7992: bd80         	pop	{r7, pc}
		...

700a79a0 <xQueueGiveFromISR>:
; {
700a79a0: b580         	push	{r7, lr}
700a79a2: b088         	sub	sp, #0x20
700a79a4: 9007         	str	r0, [sp, #0x1c]
700a79a6: 9106         	str	r1, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a79a8: 9807         	ldr	r0, [sp, #0x1c]
700a79aa: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a79ac: f006 ecf0    	blx	0x700ae390 <HwiP_disable> @ imm = #0x69e0
700a79b0: 9004         	str	r0, [sp, #0x10]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a79b2: 9803         	ldr	r0, [sp, #0xc]
700a79b4: 6b80         	ldr	r0, [r0, #0x38]
700a79b6: 9002         	str	r0, [sp, #0x8]
;         if( uxMessagesWaiting < pxQueue->uxLength )
700a79b8: 9802         	ldr	r0, [sp, #0x8]
700a79ba: 9903         	ldr	r1, [sp, #0xc]
700a79bc: 6bc9         	ldr	r1, [r1, #0x3c]
700a79be: 4288         	cmp	r0, r1
700a79c0: d22f         	bhs	0x700a7a22 <xQueueGiveFromISR+0x82> @ imm = #0x5e
700a79c2: e7ff         	b	0x700a79c4 <xQueueGiveFromISR+0x24> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a79c4: 9803         	ldr	r0, [sp, #0xc]
700a79c6: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a79ca: f88d 0007    	strb.w	r0, [sp, #0x7]
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a79ce: 9802         	ldr	r0, [sp, #0x8]
700a79d0: 3001         	adds	r0, #0x1
700a79d2: 9903         	ldr	r1, [sp, #0xc]
700a79d4: 6388         	str	r0, [r1, #0x38]
;             if( cTxLock == queueUNLOCKED )
700a79d6: f99d 0007    	ldrsb.w	r0, [sp, #0x7]
700a79da: 3001         	adds	r0, #0x1
700a79dc: b9b8         	cbnz	r0, 0x700a7a0e <xQueueGiveFromISR+0x6e> @ imm = #0x2e
700a79de: e7ff         	b	0x700a79e0 <xQueueGiveFromISR+0x40> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a79e0: 9803         	ldr	r0, [sp, #0xc]
700a79e2: 6a40         	ldr	r0, [r0, #0x24]
700a79e4: b188         	cbz	r0, 0x700a7a0a <xQueueGiveFromISR+0x6a> @ imm = #0x22
700a79e6: e7ff         	b	0x700a79e8 <xQueueGiveFromISR+0x48> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a79e8: 9803         	ldr	r0, [sp, #0xc]
700a79ea: 3024         	adds	r0, #0x24
700a79ec: f7fe fc48    	bl	0x700a6280 <xTaskRemoveFromEventList> @ imm = #-0x1770
700a79f0: b148         	cbz	r0, 0x700a7a06 <xQueueGiveFromISR+0x66> @ imm = #0x12
700a79f2: e7ff         	b	0x700a79f4 <xQueueGiveFromISR+0x54> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a79f4: 9806         	ldr	r0, [sp, #0x18]
700a79f6: b120         	cbz	r0, 0x700a7a02 <xQueueGiveFromISR+0x62> @ imm = #0x8
700a79f8: e7ff         	b	0x700a79fa <xQueueGiveFromISR+0x5a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a79fa: 9906         	ldr	r1, [sp, #0x18]
700a79fc: 2001         	movs	r0, #0x1
700a79fe: 6008         	str	r0, [r1]
;                                 }
700a7a00: e000         	b	0x700a7a04 <xQueueGiveFromISR+0x64> @ imm = #0x0
700a7a02: e7ff         	b	0x700a7a04 <xQueueGiveFromISR+0x64> @ imm = #-0x2
;                             }
700a7a04: e000         	b	0x700a7a08 <xQueueGiveFromISR+0x68> @ imm = #0x0
700a7a06: e7ff         	b	0x700a7a08 <xQueueGiveFromISR+0x68> @ imm = #-0x2
;                         }
700a7a08: e000         	b	0x700a7a0c <xQueueGiveFromISR+0x6c> @ imm = #0x0
700a7a0a: e7ff         	b	0x700a7a0c <xQueueGiveFromISR+0x6c> @ imm = #-0x2
;             }
700a7a0c: e006         	b	0x700a7a1c <xQueueGiveFromISR+0x7c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a7a0e: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a7a12: 3001         	adds	r0, #0x1
700a7a14: 9903         	ldr	r1, [sp, #0xc]
700a7a16: f881 0045    	strb.w	r0, [r1, #0x45]
700a7a1a: e7ff         	b	0x700a7a1c <xQueueGiveFromISR+0x7c> @ imm = #-0x2
700a7a1c: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a7a1e: 9005         	str	r0, [sp, #0x14]
;         }
700a7a20: e002         	b	0x700a7a28 <xQueueGiveFromISR+0x88> @ imm = #0x4
700a7a22: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a7a24: 9005         	str	r0, [sp, #0x14]
700a7a26: e7ff         	b	0x700a7a28 <xQueueGiveFromISR+0x88> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a7a28: 9804         	ldr	r0, [sp, #0x10]
700a7a2a: f006 ecd2    	blx	0x700ae3d0 <HwiP_restore> @ imm = #0x69a4
;     return xReturn;
700a7a2e: 9805         	ldr	r0, [sp, #0x14]
700a7a30: b008         	add	sp, #0x20
700a7a32: bd80         	pop	{r7, pc}
		...

700a7a40 <xTimerGenericCommand>:
;     {
700a7a40: b580         	push	{r7, lr}
700a7a42: b08a         	sub	sp, #0x28
700a7a44: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a7a48: 9009         	str	r0, [sp, #0x24]
700a7a4a: 9108         	str	r1, [sp, #0x20]
700a7a4c: 9207         	str	r2, [sp, #0x1c]
700a7a4e: 9306         	str	r3, [sp, #0x18]
700a7a50: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700a7a52: 9005         	str	r0, [sp, #0x14]
;         if( xTimerQueue != NULL )
700a7a54: f240 2014    	movw	r0, #0x214
700a7a58: f2c7 000b    	movt	r0, #0x700b
700a7a5c: 6800         	ldr	r0, [r0]
700a7a5e: b3a8         	cbz	r0, 0x700a7acc <xTimerGenericCommand+0x8c> @ imm = #0x6a
700a7a60: e7ff         	b	0x700a7a62 <xTimerGenericCommand+0x22> @ imm = #-0x2
;             xMessage.xMessageID = xCommandID;
700a7a62: 9808         	ldr	r0, [sp, #0x20]
700a7a64: 9001         	str	r0, [sp, #0x4]
;             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
700a7a66: 9807         	ldr	r0, [sp, #0x1c]
700a7a68: 9002         	str	r0, [sp, #0x8]
;             xMessage.u.xTimerParameters.pxTimer = xTimer;
700a7a6a: 9809         	ldr	r0, [sp, #0x24]
700a7a6c: 9003         	str	r0, [sp, #0xc]
;             if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
700a7a6e: 9808         	ldr	r0, [sp, #0x20]
700a7a70: 2805         	cmp	r0, #0x5
700a7a72: dc1e         	bgt	0x700a7ab2 <xTimerGenericCommand+0x72> @ imm = #0x3c
700a7a74: e7ff         	b	0x700a7a76 <xTimerGenericCommand+0x36> @ imm = #-0x2
;                 if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
700a7a76: f004 fb03    	bl	0x700ac080 <xTaskGetSchedulerState> @ imm = #0x4606
700a7a7a: 2802         	cmp	r0, #0x2
700a7a7c: d10c         	bne	0x700a7a98 <xTimerGenericCommand+0x58> @ imm = #0x18
700a7a7e: e7ff         	b	0x700a7a80 <xTimerGenericCommand+0x40> @ imm = #-0x2
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
700a7a80: f240 2014    	movw	r0, #0x214
700a7a84: f2c7 000b    	movt	r0, #0x700b
700a7a88: 6800         	ldr	r0, [r0]
700a7a8a: 9a0c         	ldr	r2, [sp, #0x30]
700a7a8c: a901         	add	r1, sp, #0x4
700a7a8e: 2300         	movs	r3, #0x0
700a7a90: f7f9 fd3e    	bl	0x700a1510 <xQueueGenericSend> @ imm = #-0x6584
700a7a94: 9005         	str	r0, [sp, #0x14]
;                 }
700a7a96: e00b         	b	0x700a7ab0 <xTimerGenericCommand+0x70> @ imm = #0x16
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
700a7a98: f240 2014    	movw	r0, #0x214
700a7a9c: f2c7 000b    	movt	r0, #0x700b
700a7aa0: 6800         	ldr	r0, [r0]
700a7aa2: a901         	add	r1, sp, #0x4
700a7aa4: 2300         	movs	r3, #0x0
700a7aa6: 461a         	mov	r2, r3
700a7aa8: f7f9 fd32    	bl	0x700a1510 <xQueueGenericSend> @ imm = #-0x659c
700a7aac: 9005         	str	r0, [sp, #0x14]
700a7aae: e7ff         	b	0x700a7ab0 <xTimerGenericCommand+0x70> @ imm = #-0x2
;             }
700a7ab0: e00b         	b	0x700a7aca <xTimerGenericCommand+0x8a> @ imm = #0x16
;                 xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
700a7ab2: f240 2014    	movw	r0, #0x214
700a7ab6: f2c7 000b    	movt	r0, #0x700b
700a7aba: 6800         	ldr	r0, [r0]
700a7abc: 9a06         	ldr	r2, [sp, #0x18]
700a7abe: a901         	add	r1, sp, #0x4
700a7ac0: 2300         	movs	r3, #0x0
700a7ac2: f7fe feed    	bl	0x700a68a0 <xQueueGenericSendFromISR> @ imm = #-0x1226
700a7ac6: 9005         	str	r0, [sp, #0x14]
700a7ac8: e7ff         	b	0x700a7aca <xTimerGenericCommand+0x8a> @ imm = #-0x2
;         }
700a7aca: e000         	b	0x700a7ace <xTimerGenericCommand+0x8e> @ imm = #0x0
700a7acc: e7ff         	b	0x700a7ace <xTimerGenericCommand+0x8e> @ imm = #-0x2
;         return xReturn;
700a7ace: 9805         	ldr	r0, [sp, #0x14]
700a7ad0: b00a         	add	sp, #0x28
700a7ad2: bd80         	pop	{r7, pc}
		...

700a7ae0 <SOC_moduleClockEnable>:
; {
700a7ae0: b580         	push	{r7, lr}
700a7ae2: b088         	sub	sp, #0x20
700a7ae4: 9007         	str	r0, [sp, #0x1c]
700a7ae6: 9106         	str	r1, [sp, #0x18]
700a7ae8: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a7aea: 9005         	str	r0, [sp, #0x14]
700a7aec: 2102         	movs	r1, #0x2
;     uint32_t moduleState = TISCI_MSG_VALUE_DEVICE_HW_STATE_TRANS;
700a7aee: 9104         	str	r1, [sp, #0x10]
;     uint32_t resetState = 0U;
700a7af0: 9003         	str	r0, [sp, #0xc]
;     uint32_t contextLossState = 0U;
700a7af2: 9002         	str	r0, [sp, #0x8]
;     status = Sciclient_pmGetModuleState(moduleId,
700a7af4: 9807         	ldr	r0, [sp, #0x1c]
700a7af6: 466a         	mov	r2, sp
700a7af8: f04f 31ff    	mov.w	r1, #0xffffffff
700a7afc: 6011         	str	r1, [r2]
700a7afe: a904         	add	r1, sp, #0x10
700a7b00: aa03         	add	r2, sp, #0xc
700a7b02: ab02         	add	r3, sp, #0x8
700a7b04: f000 f9bc    	bl	0x700a7e80 <Sciclient_pmGetModuleState> @ imm = #0x378
700a7b08: 9005         	str	r0, [sp, #0x14]
;     if(status == SystemP_SUCCESS)
700a7b0a: 9805         	ldr	r0, [sp, #0x14]
700a7b0c: bb70         	cbnz	r0, 0x700a7b6c <SOC_moduleClockEnable+0x8c> @ imm = #0x5c
700a7b0e: e7ff         	b	0x700a7b10 <SOC_moduleClockEnable+0x30> @ imm = #-0x2
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_OFF && (enable == 1))
700a7b10: 9804         	ldr	r0, [sp, #0x10]
700a7b12: b9c8         	cbnz	r0, 0x700a7b48 <SOC_moduleClockEnable+0x68> @ imm = #0x32
700a7b14: e7ff         	b	0x700a7b16 <SOC_moduleClockEnable+0x36> @ imm = #-0x2
700a7b16: 9806         	ldr	r0, [sp, #0x18]
700a7b18: 2801         	cmp	r0, #0x1
700a7b1a: d115         	bne	0x700a7b48 <SOC_moduleClockEnable+0x68> @ imm = #0x2a
700a7b1c: e7ff         	b	0x700a7b1e <SOC_moduleClockEnable+0x3e> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a7b1e: 9807         	ldr	r0, [sp, #0x1c]
700a7b20: 2102         	movs	r1, #0x2
700a7b22: f240 2202    	movw	r2, #0x202
700a7b26: f04f 33ff    	mov.w	r3, #0xffffffff
700a7b2a: f000 fa39    	bl	0x700a7fa0 <Sciclient_pmSetModuleState> @ imm = #0x472
700a7b2e: 9005         	str	r0, [sp, #0x14]
;             if (status == SystemP_SUCCESS)
700a7b30: 9805         	ldr	r0, [sp, #0x14]
700a7b32: b940         	cbnz	r0, 0x700a7b46 <SOC_moduleClockEnable+0x66> @ imm = #0x10
700a7b34: e7ff         	b	0x700a7b36 <SOC_moduleClockEnable+0x56> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleRst(moduleId,
700a7b36: 9807         	ldr	r0, [sp, #0x1c]
700a7b38: 2100         	movs	r1, #0x0
700a7b3a: f04f 32ff    	mov.w	r2, #0xffffffff
700a7b3e: f002 fc1f    	bl	0x700aa380 <Sciclient_pmSetModuleRst> @ imm = #0x283e
700a7b42: 9005         	str	r0, [sp, #0x14]
;             }
700a7b44: e7ff         	b	0x700a7b46 <SOC_moduleClockEnable+0x66> @ imm = #-0x2
;         }
700a7b46: e010         	b	0x700a7b6a <SOC_moduleClockEnable+0x8a> @ imm = #0x20
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_ON && (enable == 0))
700a7b48: 9804         	ldr	r0, [sp, #0x10]
700a7b4a: 2801         	cmp	r0, #0x1
700a7b4c: d10c         	bne	0x700a7b68 <SOC_moduleClockEnable+0x88> @ imm = #0x18
700a7b4e: e7ff         	b	0x700a7b50 <SOC_moduleClockEnable+0x70> @ imm = #-0x2
700a7b50: 9806         	ldr	r0, [sp, #0x18]
700a7b52: b948         	cbnz	r0, 0x700a7b68 <SOC_moduleClockEnable+0x88> @ imm = #0x12
700a7b54: e7ff         	b	0x700a7b56 <SOC_moduleClockEnable+0x76> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a7b56: 9807         	ldr	r0, [sp, #0x1c]
700a7b58: 2100         	movs	r1, #0x0
700a7b5a: 2202         	movs	r2, #0x2
700a7b5c: f04f 33ff    	mov.w	r3, #0xffffffff
700a7b60: f000 fa1e    	bl	0x700a7fa0 <Sciclient_pmSetModuleState> @ imm = #0x43c
700a7b64: 9005         	str	r0, [sp, #0x14]
;         }
700a7b66: e7ff         	b	0x700a7b68 <SOC_moduleClockEnable+0x88> @ imm = #-0x2
700a7b68: e7ff         	b	0x700a7b6a <SOC_moduleClockEnable+0x8a> @ imm = #-0x2
;     }
700a7b6a: e7ff         	b	0x700a7b6c <SOC_moduleClockEnable+0x8c> @ imm = #-0x2
;     return status;
700a7b6c: 9805         	ldr	r0, [sp, #0x14]
700a7b6e: b008         	add	sp, #0x20
700a7b70: bd80         	pop	{r7, pc}
		...
700a7b7e: 0000         	movs	r0, r0

700a7b80 <Sciclient_rmPsPop>:
; {
700a7b80: b084         	sub	sp, #0x10
700a7b82: 9003         	str	r0, [sp, #0xc]
700a7b84: 9102         	str	r1, [sp, #0x8]
700a7b86: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a7b88: 9001         	str	r0, [sp, #0x4]
;     if ((gPstack.psp > (0u)) && (n != NULL) && (if_idx != NULL)) {
700a7b8a: f241 0058    	movw	r0, #0x1058
700a7b8e: f2c7 0008    	movt	r0, #0x7008
700a7b92: 8c80         	ldrh	r0, [r0, #0x24]
700a7b94: b3b0         	cbz	r0, 0x700a7c04 <Sciclient_rmPsPop+0x84> @ imm = #0x6c
700a7b96: e7ff         	b	0x700a7b98 <Sciclient_rmPsPop+0x18> @ imm = #-0x2
700a7b98: 9803         	ldr	r0, [sp, #0xc]
700a7b9a: b398         	cbz	r0, 0x700a7c04 <Sciclient_rmPsPop+0x84> @ imm = #0x66
700a7b9c: e7ff         	b	0x700a7b9e <Sciclient_rmPsPop+0x1e> @ imm = #-0x2
700a7b9e: 9802         	ldr	r0, [sp, #0x8]
700a7ba0: b380         	cbz	r0, 0x700a7c04 <Sciclient_rmPsPop+0x84> @ imm = #0x60
700a7ba2: e7ff         	b	0x700a7ba4 <Sciclient_rmPsPop+0x24> @ imm = #-0x2
;         gPstack.psp--;
700a7ba4: f241 0158    	movw	r1, #0x1058
700a7ba8: f2c7 0108    	movt	r1, #0x7008
700a7bac: 9100         	str	r1, [sp]
700a7bae: 8c88         	ldrh	r0, [r1, #0x24]
700a7bb0: 3801         	subs	r0, #0x1
700a7bb2: 8488         	strh	r0, [r1, #0x24]
;         *n = gPstack.ps[gPstack.psp].p_n;
700a7bb4: 8c88         	ldrh	r0, [r1, #0x24]
700a7bb6: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a7bba: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700a7bbe: 9a03         	ldr	r2, [sp, #0xc]
700a7bc0: 6010         	str	r0, [r2]
;         *if_idx = gPstack.ps[gPstack.psp].if_idx;
700a7bc2: 8c88         	ldrh	r0, [r1, #0x24]
700a7bc4: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a7bc8: eb01 0080    	add.w	r0, r1, r0, lsl #2
700a7bcc: 8880         	ldrh	r0, [r0, #0x4]
700a7bce: 9a02         	ldr	r2, [sp, #0x8]
700a7bd0: 8010         	strh	r0, [r2]
;         gPstack.ps[gPstack.psp].p_n = NULL;
700a7bd2: 8c88         	ldrh	r0, [r1, #0x24]
700a7bd4: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a7bd8: 2000         	movs	r0, #0x0
700a7bda: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = 0;
700a7bde: 8c8a         	ldrh	r2, [r1, #0x24]
700a7be0: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a7be4: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a7be8: 8090         	strh	r0, [r2, #0x4]
;         gPstack.ps[gPstack.psp].inp = 0;
700a7bea: 8c8a         	ldrh	r2, [r1, #0x24]
700a7bec: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a7bf0: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a7bf4: 80d0         	strh	r0, [r2, #0x6]
;         gPstack.ps[gPstack.psp].outp = 0;
700a7bf6: 8c8a         	ldrh	r2, [r1, #0x24]
700a7bf8: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a7bfc: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a7c00: 8108         	strh	r0, [r1, #0x8]
;     } else {
700a7c02: e003         	b	0x700a7c0c <Sciclient_rmPsPop+0x8c> @ imm = #0x6
700a7c04: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a7c08: 9001         	str	r0, [sp, #0x4]
700a7c0a: e7ff         	b	0x700a7c0c <Sciclient_rmPsPop+0x8c> @ imm = #-0x2
;     return r;
700a7c0c: 9801         	ldr	r0, [sp, #0x4]
700a7c0e: b004         	add	sp, #0x10
700a7c10: 4770         	bx	lr
		...
700a7c1e: 0000         	movs	r0, r0

700a7c20 <_DebugP_logZone>:
; {
700a7c20: b082         	sub	sp, #0x8
700a7c22: b580         	push	{r7, lr}
700a7c24: b086         	sub	sp, #0x18
700a7c26: 9309         	str	r3, [sp, #0x24]
700a7c28: 9208         	str	r2, [sp, #0x20]
700a7c2a: 9005         	str	r0, [sp, #0x14]
700a7c2c: 9104         	str	r1, [sp, #0x10]
;     if((HwiP_inISR()) == 0U )
700a7c2e: f006 f8cf    	bl	0x700addd0 <HwiP_inISR> @ imm = #0x619e
700a7c32: bbc8         	cbnz	r0, 0x700a7ca8 <_DebugP_logZone+0x88> @ imm = #0x72
700a7c34: e7ff         	b	0x700a7c36 <_DebugP_logZone+0x16> @ imm = #-0x2
;         if(gDebugLogIsInitDone == 0U)
700a7c36: f240 109c    	movw	r0, #0x19c
700a7c3a: f2c7 000b    	movt	r0, #0x700b
700a7c3e: 6800         	ldr	r0, [r0]
700a7c40: b9a0         	cbnz	r0, 0x700a7c6c <_DebugP_logZone+0x4c> @ imm = #0x28
700a7c42: e7ff         	b	0x700a7c44 <_DebugP_logZone+0x24> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&gDebugLogLockObj);
700a7c44: f644 4018    	movw	r0, #0x4c18
700a7c48: f2c7 0008    	movt	r0, #0x7008
700a7c4c: f001 fc78    	bl	0x700a9540 <SemaphoreP_constructMutex> @ imm = #0x18f0
700a7c50: 9003         	str	r0, [sp, #0xc]
;             DebugP_assertNoLog(status == SystemP_SUCCESS);
700a7c52: 9803         	ldr	r0, [sp, #0xc]
700a7c54: fab0 f080    	clz	r0, r0
700a7c58: 0940         	lsrs	r0, r0, #0x5
700a7c5a: f007 f859    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x70b2
;             gDebugLogIsInitDone = 1;
700a7c5e: f240 119c    	movw	r1, #0x19c
700a7c62: f2c7 010b    	movt	r1, #0x700b
700a7c66: 2001         	movs	r0, #0x1
700a7c68: 6008         	str	r0, [r1]
;         }
700a7c6a: e7ff         	b	0x700a7c6c <_DebugP_logZone+0x4c> @ imm = #-0x2
;         if( ( gDebugLogZone & logZone ) == logZone )
700a7c6c: f240 10a0    	movw	r0, #0x1a0
700a7c70: f2c7 000b    	movt	r0, #0x700b
700a7c74: 6800         	ldr	r0, [r0]
700a7c76: 9905         	ldr	r1, [sp, #0x14]
700a7c78: 4008         	ands	r0, r1
700a7c7a: 4288         	cmp	r0, r1
700a7c7c: d113         	bne	0x700a7ca6 <_DebugP_logZone+0x86> @ imm = #0x26
700a7c7e: e7ff         	b	0x700a7c80 <_DebugP_logZone+0x60> @ imm = #-0x2
;             SemaphoreP_pend(&gDebugLogLockObj, SystemP_WAIT_FOREVER);
700a7c80: f644 4018    	movw	r0, #0x4c18
700a7c84: f2c7 0008    	movt	r0, #0x7008
700a7c88: 9001         	str	r0, [sp, #0x4]
700a7c8a: f04f 31ff    	mov.w	r1, #0xffffffff
700a7c8e: f000 fd2f    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0xa5e
700a7c92: a808         	add	r0, sp, #0x20
;             va_start(va, format);
700a7c94: 9002         	str	r0, [sp, #0x8]
;             vprintf_(format, va);
700a7c96: 9804         	ldr	r0, [sp, #0x10]
700a7c98: 9902         	ldr	r1, [sp, #0x8]
700a7c9a: f004 ff49    	bl	0x700acb30 <vprintf_>   @ imm = #0x4e92
;             SemaphoreP_post(&gDebugLogLockObj);
700a7c9e: 9801         	ldr	r0, [sp, #0x4]
700a7ca0: f002 f876    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x20ec
;         }
700a7ca4: e7ff         	b	0x700a7ca6 <_DebugP_logZone+0x86> @ imm = #-0x2
;     }
700a7ca6: e7ff         	b	0x700a7ca8 <_DebugP_logZone+0x88> @ imm = #-0x2
; }
700a7ca8: b006         	add	sp, #0x18
700a7caa: e8bd 4080    	pop.w	{r7, lr}
700a7cae: b002         	add	sp, #0x8
700a7cb0: 4770         	bx	lr
		...
700a7cbe: 0000         	movs	r0, r0

700a7cc0 <tm_memory_allocation_initialize>:
; {
700a7cc0: b082         	sub	sp, #0x8
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700a7cc2: f64c 6021    	movw	r0, #0xce21
700a7cc6: f64f 0143    	movw	r1, #0xf843
700a7cca: f2c7 000a    	movt	r0, #0x700a
700a7cce: f2c7 010a    	movt	r1, #0x700a
700a7cd2: f644 64d0    	movw	r4, #0x4ed0
700a7cd6: 2717         	movs	r7, #0x17
700a7cd8: f44f 6280    	mov.w	r2, #0x400
700a7cdc: 2300         	movs	r3, #0x0
700a7cde: f2c7 0408    	movt	r4, #0x7008
700a7ce2: 2600         	movs	r6, #0x0
700a7ce4: e9cd 7400    	strd	r7, r4, [sp]
700a7ce8: f7ff fb3a    	bl	0x700a7360 <xTaskCreate> @ imm = #-0x98c
;    vTaskResume(tm_thread_array[thread_id]);
700a7cec: 6820         	ldr	r0, [r4]
700a7cee: f7ff fdb7    	bl	0x700a7860 <vTaskResume> @ imm = #-0x492
700a7cf2: f24f 29e1    	movw	r9, #0xf2e1
700a7cf6: f644 75c8    	movw	r5, #0x4fc8
700a7cfa: f24f 2898    	movw	r8, #0xf298
700a7cfe: f24f 776c    	movw	r7, #0xf76c
700a7d02: f2c7 090a    	movt	r9, #0x700a
700a7d06: f2c7 0508    	movt	r5, #0x7008
700a7d0a: f2c7 080a    	movt	r8, #0x700a
700a7d0e: f2c7 070a    	movt	r7, #0x700a
700a7d12: 241e         	movs	r4, #0x1e
700a7d14: e00b         	b	0x700a7d2e <tm_memory_allocation_initialize+0x6e> @ imm = #0x16
700a7d16: bf00         	nop
700a7d18: bf00         	nop
700a7d1a: bf00         	nop
700a7d1c: bf00         	nop
700a7d1e: bf00         	nop
;       printf("Time Period Total:  %lu\r\n", tm_memory_allocation_counter - last_counter);
700a7d20: 1b82         	subs	r2, r0, r6
700a7d22: 4639         	mov	r1, r7
700a7d24: 2001         	movs	r0, #0x1
700a7d26: f7ff ff7b    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #-0x10a
;       last_counter = tm_memory_allocation_counter;
700a7d2a: 682e         	ldr	r6, [r5]
;    while (1)
700a7d2c: 341e         	adds	r4, #0x1e
;    vTaskDelay((seconds * 1000U) / portTICK_RATE_MS);
700a7d2e: f247 5030    	movw	r0, #0x7530
700a7d32: f004 f9c5    	bl	0x700ac0c0 <vTaskDelay> @ imm = #0x438a
;       printf("**** Thread-Metric Memory Allocation Test **** Relative Time: %lu\r\n", relative_time);
700a7d36: 4649         	mov	r1, r9
700a7d38: 4622         	mov	r2, r4
700a7d3a: 2001         	movs	r0, #0x1
700a7d3c: f7ff ff70    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #-0x120
;       if (tm_memory_allocation_counter == last_counter)
700a7d40: 6828         	ldr	r0, [r5]
700a7d42: 42b0         	cmp	r0, r6
700a7d44: d1ec         	bne	0x700a7d20 <tm_memory_allocation_initialize+0x60> @ imm = #-0x28
;          printf("ERROR: Invalid counter value(s). Error allocating/deallocating "
700a7d46: 4641         	mov	r1, r8
700a7d48: 2001         	movs	r0, #0x1
700a7d4a: f7ff ff69    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #-0x12e
;       printf("Time Period Total:  %lu\r\n", tm_memory_allocation_counter - last_counter);
700a7d4e: 6828         	ldr	r0, [r5]
700a7d50: e7e6         	b	0x700a7d20 <tm_memory_allocation_initialize+0x60> @ imm = #-0x34
		...
700a7d5e: 0000         	movs	r0, r0

700a7d60 <Udma_rmFreeMappedRing>:
; {
700a7d60: b580         	push	{r7, lr}
700a7d62: b08e         	sub	sp, #0x38
700a7d64: 900d         	str	r0, [sp, #0x34]
700a7d66: 910c         	str	r1, [sp, #0x30]
700a7d68: 920b         	str	r2, [sp, #0x2c]
700a7d6a: 930a         	str	r3, [sp, #0x28]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a7d6c: 980c         	ldr	r0, [sp, #0x30]
700a7d6e: f500 70ea    	add.w	r0, r0, #0x1d4
700a7d72: 9005         	str	r0, [sp, #0x14]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a7d74: 980c         	ldr	r0, [sp, #0x30]
700a7d76: 990b         	ldr	r1, [sp, #0x2c]
700a7d78: 9a0a         	ldr	r2, [sp, #0x28]
700a7d7a: ab02         	add	r3, sp, #0x8
700a7d7c: f7fd ff68    	bl	0x700a5c50 <Udma_getMappedChRingAttributes> @ imm = #-0x2130
700a7d80: 9001         	str	r0, [sp, #0x4]
;     if(ringNum != chAttr.defaultRing)
700a7d82: 980d         	ldr	r0, [sp, #0x34]
700a7d84: 9902         	ldr	r1, [sp, #0x8]
700a7d86: 4288         	cmp	r0, r1
700a7d88: d02f         	beq	0x700a7dea <Udma_rmFreeMappedRing+0x8a> @ imm = #0x5e
700a7d8a: e7ff         	b	0x700a7d8c <Udma_rmFreeMappedRing+0x2c> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a7d8c: 980c         	ldr	r0, [sp, #0x30]
700a7d8e: f500 609f    	add.w	r0, r0, #0x4f8
700a7d92: f04f 31ff    	mov.w	r1, #0xffffffff
700a7d96: f000 fcab    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x956
;         i = ringNum - rmInitPrms->startMappedRing[mappedRingGrp];
700a7d9a: 980d         	ldr	r0, [sp, #0x34]
700a7d9c: 9905         	ldr	r1, [sp, #0x14]
700a7d9e: 9a0b         	ldr	r2, [sp, #0x2c]
700a7da0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a7da4: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a7da8: 1a40         	subs	r0, r0, r1
700a7daa: 9009         	str	r0, [sp, #0x24]
;         offset = i >> 5U;
700a7dac: 9809         	ldr	r0, [sp, #0x24]
700a7dae: 0940         	lsrs	r0, r0, #0x5
700a7db0: 9008         	str	r0, [sp, #0x20]
;         bitPos = i - (offset << 5U);
700a7db2: 9809         	ldr	r0, [sp, #0x24]
700a7db4: 9908         	ldr	r1, [sp, #0x20]
700a7db6: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a7dba: 9007         	str	r0, [sp, #0x1c]
;         bitMask = (uint32_t) 1U << bitPos;
700a7dbc: 9907         	ldr	r1, [sp, #0x1c]
700a7dbe: 2001         	movs	r0, #0x1
700a7dc0: 4088         	lsls	r0, r1
700a7dc2: 9006         	str	r0, [sp, #0x18]
;         drvHandle->mappedRingFlag[mappedRingGrp][offset] |= bitMask;
700a7dc4: 9a06         	ldr	r2, [sp, #0x18]
700a7dc6: 980c         	ldr	r0, [sp, #0x30]
700a7dc8: 990b         	ldr	r1, [sp, #0x2c]
700a7dca: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a7dce: 9908         	ldr	r1, [sp, #0x20]
700a7dd0: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a7dd4: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a7dd8: 4310         	orrs	r0, r2
700a7dda: f8c1 0344    	str.w	r0, [r1, #0x344]
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a7dde: 980c         	ldr	r0, [sp, #0x30]
700a7de0: f500 609f    	add.w	r0, r0, #0x4f8
700a7de4: f001 ffd4    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x1fa8
;     }
700a7de8: e7ff         	b	0x700a7dea <Udma_rmFreeMappedRing+0x8a> @ imm = #-0x2
;     return;
700a7dea: b00e         	add	sp, #0x38
700a7dec: bd80         	pop	{r7, pc}
700a7dee: 0000         	movs	r0, r0

700a7df0 <prvInitialiseTaskLists>:
; static void prvInitialiseTaskLists(void) {
700a7df0: b580         	push	{r7, lr}
700a7df2: b084         	sub	sp, #0x10
700a7df4: 2000         	movs	r0, #0x0
;   for (uxPriority = (UBaseType_t)0U;
700a7df6: 9003         	str	r0, [sp, #0xc]
700a7df8: e7ff         	b	0x700a7dfa <prvInitialiseTaskLists+0xa> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a7dfa: 9803         	ldr	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a7dfc: 281f         	cmp	r0, #0x1f
700a7dfe: d810         	bhi	0x700a7e22 <prvInitialiseTaskLists+0x32> @ imm = #0x20
700a7e00: e7ff         	b	0x700a7e02 <prvInitialiseTaskLists+0x12> @ imm = #-0x2
;     vListInitialise(&(pxReadyTasksLists[uxPriority]));
700a7e02: 9803         	ldr	r0, [sp, #0xc]
700a7e04: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a7e08: f244 40f8    	movw	r0, #0x44f8
700a7e0c: f2c7 0008    	movt	r0, #0x7008
700a7e10: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7e14: f004 fc34    	bl	0x700ac680 <vListInitialise> @ imm = #0x4868
;   }
700a7e18: e7ff         	b	0x700a7e1a <prvInitialiseTaskLists+0x2a> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a7e1a: 9803         	ldr	r0, [sp, #0xc]
700a7e1c: 3001         	adds	r0, #0x1
700a7e1e: 9003         	str	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a7e20: e7eb         	b	0x700a7dfa <prvInitialiseTaskLists+0xa> @ imm = #-0x2a
;   vListInitialise(&xDelayedTaskList1);
700a7e22: f644 7040    	movw	r0, #0x4f40
700a7e26: f2c7 0008    	movt	r0, #0x7008
700a7e2a: 9001         	str	r0, [sp, #0x4]
700a7e2c: f004 fc28    	bl	0x700ac680 <vListInitialise> @ imm = #0x4850
;   vListInitialise(&xDelayedTaskList2);
700a7e30: f644 7054    	movw	r0, #0x4f54
700a7e34: f2c7 0008    	movt	r0, #0x7008
700a7e38: 9002         	str	r0, [sp, #0x8]
700a7e3a: f004 fc21    	bl	0x700ac680 <vListInitialise> @ imm = #0x4842
;   vListInitialise(&xPendingReadyList);
700a7e3e: f644 7068    	movw	r0, #0x4f68
700a7e42: f2c7 0008    	movt	r0, #0x7008
700a7e46: f004 fc1b    	bl	0x700ac680 <vListInitialise> @ imm = #0x4836
;     vListInitialise(&xTasksWaitingTermination);
700a7e4a: f644 7090    	movw	r0, #0x4f90
700a7e4e: f2c7 0008    	movt	r0, #0x7008
700a7e52: f004 fc15    	bl	0x700ac680 <vListInitialise> @ imm = #0x482a
;     vListInitialise(&xSuspendedTaskList);
700a7e56: f644 707c    	movw	r0, #0x4f7c
700a7e5a: f2c7 0008    	movt	r0, #0x7008
700a7e5e: f004 fc0f    	bl	0x700ac680 <vListInitialise> @ imm = #0x481e
700a7e62: 9901         	ldr	r1, [sp, #0x4]
700a7e64: 9802         	ldr	r0, [sp, #0x8]
;   pxDelayedTaskList = &xDelayedTaskList1;
700a7e66: f644 72b8    	movw	r2, #0x4fb8
700a7e6a: f2c7 0208    	movt	r2, #0x7008
700a7e6e: 6011         	str	r1, [r2]
;   pxOverflowDelayedTaskList = &xDelayedTaskList2;
700a7e70: f644 71bc    	movw	r1, #0x4fbc
700a7e74: f2c7 0108    	movt	r1, #0x7008
700a7e78: 6008         	str	r0, [r1]
; }
700a7e7a: b004         	add	sp, #0x10
700a7e7c: bd80         	pop	{r7, pc}
700a7e7e: 0000         	movs	r0, r0

700a7e80 <Sciclient_pmGetModuleState>:
; {
700a7e80: b580         	push	{r7, lr}
700a7e82: b096         	sub	sp, #0x58
700a7e84: f8dd c060    	ldr.w	r12, [sp, #0x60]
700a7e88: 9015         	str	r0, [sp, #0x54]
700a7e8a: 9114         	str	r1, [sp, #0x50]
700a7e8c: 9213         	str	r2, [sp, #0x4c]
700a7e8e: 9312         	str	r3, [sp, #0x48]
700a7e90: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a7e92: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_device_resp response = {{0}};
700a7e94: f8ad 0034    	strh.w	r0, [sp, #0x34]
700a7e98: 900c         	str	r0, [sp, #0x30]
700a7e9a: 900b         	str	r0, [sp, #0x2c]
700a7e9c: 900a         	str	r0, [sp, #0x28]
700a7e9e: 9009         	str	r0, [sp, #0x24]
;     request.id = (uint32_t) moduleId;
700a7ea0: 9915         	ldr	r1, [sp, #0x54]
700a7ea2: 9110         	str	r1, [sp, #0x40]
700a7ea4: f240 2101    	movw	r1, #0x201
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_DEVICE;
700a7ea8: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a7eac: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a7eae: 9105         	str	r1, [sp, #0x14]
700a7eb0: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a7eb2: 9106         	str	r1, [sp, #0x18]
700a7eb4: 210c         	movs	r1, #0xc
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a7eb6: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a7eb8: 9918         	ldr	r1, [sp, #0x60]
700a7eba: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a7ebc: 9001         	str	r0, [sp, #0x4]
700a7ebe: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a7ec0: 9002         	str	r0, [sp, #0x8]
700a7ec2: 2012         	movs	r0, #0x12
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a7ec4: 9003         	str	r0, [sp, #0xc]
700a7ec6: a804         	add	r0, sp, #0x10
700a7ec8: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a7eca: f7f3 ffd9    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xc04e
700a7ece: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a7ed0: 9811         	ldr	r0, [sp, #0x44]
700a7ed2: b930         	cbnz	r0, 0x700a7ee2 <Sciclient_pmGetModuleState+0x62> @ imm = #0xc
700a7ed4: e7ff         	b	0x700a7ed6 <Sciclient_pmGetModuleState+0x56> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a7ed6: 9801         	ldr	r0, [sp, #0x4]
700a7ed8: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a7edc: 2802         	cmp	r0, #0x2
700a7ede: d004         	beq	0x700a7eea <Sciclient_pmGetModuleState+0x6a> @ imm = #0x8
700a7ee0: e7ff         	b	0x700a7ee2 <Sciclient_pmGetModuleState+0x62> @ imm = #-0x2
700a7ee2: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a7ee6: 9011         	str	r0, [sp, #0x44]
;     }
700a7ee8: e7ff         	b	0x700a7eea <Sciclient_pmGetModuleState+0x6a> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a7eea: 9811         	ldr	r0, [sp, #0x44]
700a7eec: b958         	cbnz	r0, 0x700a7f06 <Sciclient_pmGetModuleState+0x86> @ imm = #0x16
700a7eee: e7ff         	b	0x700a7ef0 <Sciclient_pmGetModuleState+0x70> @ imm = #-0x2
;         *moduleState = (uint32_t) response.current_state;
700a7ef0: f89d 0035    	ldrb.w	r0, [sp, #0x35]
700a7ef4: 9914         	ldr	r1, [sp, #0x50]
700a7ef6: 6008         	str	r0, [r1]
;         *resetState = (uint32_t) response.resets;
700a7ef8: 980c         	ldr	r0, [sp, #0x30]
700a7efa: 9913         	ldr	r1, [sp, #0x4c]
700a7efc: 6008         	str	r0, [r1]
;         *contextLossState = (uint32_t) response.context_loss_count;
700a7efe: 980b         	ldr	r0, [sp, #0x2c]
700a7f00: 9912         	ldr	r1, [sp, #0x48]
700a7f02: 6008         	str	r0, [r1]
;     }
700a7f04: e7ff         	b	0x700a7f06 <Sciclient_pmGetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a7f06: 9811         	ldr	r0, [sp, #0x44]
700a7f08: b016         	add	sp, #0x58
700a7f0a: bd80         	pop	{r7, pc}
700a7f0c: 0000         	movs	r0, r0
700a7f0e: 0000         	movs	r0, r0

700a7f10 <Sciclient_pmModuleClkRequest>:
; {
700a7f10: b580         	push	{r7, lr}
700a7f12: b092         	sub	sp, #0x48
700a7f14: f8dd c050    	ldr.w	r12, [sp, #0x50]
700a7f18: 9011         	str	r0, [sp, #0x44]
700a7f1a: 9110         	str	r1, [sp, #0x40]
700a7f1c: 920f         	str	r2, [sp, #0x3c]
700a7f1e: 930e         	str	r3, [sp, #0x38]
700a7f20: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a7f22: 900d         	str	r0, [sp, #0x34]
;     request.device = (uint32_t) moduleId;
700a7f24: 9811         	ldr	r0, [sp, #0x44]
700a7f26: 900a         	str	r0, [sp, #0x28]
;     if(clockId > (uint32_t)(255U))
700a7f28: 9810         	ldr	r0, [sp, #0x40]
700a7f2a: f5b0 7f80    	cmp.w	r0, #0x100
700a7f2e: d307         	blo	0x700a7f40 <Sciclient_pmModuleClkRequest+0x30> @ imm = #0xe
700a7f30: e7ff         	b	0x700a7f32 <Sciclient_pmModuleClkRequest+0x22> @ imm = #-0x2
700a7f32: 20ff         	movs	r0, #0xff
;         request.clk = (uint8_t)(255U);
700a7f34: f88d 002c    	strb.w	r0, [sp, #0x2c]
;         request.clk32 = clockId;
700a7f38: 9810         	ldr	r0, [sp, #0x40]
700a7f3a: f8cd 002e    	str.w	r0, [sp, #0x2e]
;     }
700a7f3e: e003         	b	0x700a7f48 <Sciclient_pmModuleClkRequest+0x38> @ imm = #0x6
;         request.clk    = (uint8_t)clockId;
700a7f40: 9810         	ldr	r0, [sp, #0x40]
700a7f42: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a7f46: e7ff         	b	0x700a7f48 <Sciclient_pmModuleClkRequest+0x38> @ imm = #-0x2
;     request.state  = (uint8_t) state;
700a7f48: 980f         	ldr	r0, [sp, #0x3c]
700a7f4a: f88d 002d    	strb.w	r0, [sp, #0x2d]
700a7f4e: f44f 7080    	mov.w	r0, #0x100
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK;
700a7f52: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP | additionalFlag;
700a7f56: 980e         	ldr	r0, [sp, #0x38]
700a7f58: f040 0002    	orr	r0, r0, #0x2
700a7f5c: 9004         	str	r0, [sp, #0x10]
700a7f5e: a808         	add	r0, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a7f60: 9005         	str	r0, [sp, #0x14]
700a7f62: 2012         	movs	r0, #0x12
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a7f64: 9006         	str	r0, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a7f66: 9814         	ldr	r0, [sp, #0x50]
700a7f68: 9007         	str	r0, [sp, #0x1c]
700a7f6a: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a7f6c: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a7f6e: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a7f70: 9002         	str	r0, [sp, #0x8]
700a7f72: a803         	add	r0, sp, #0xc
700a7f74: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a7f76: f7f3 ff83    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xc0fa
700a7f7a: 900d         	str	r0, [sp, #0x34]
;     if((retVal != SystemP_SUCCESS) ||
700a7f7c: 980d         	ldr	r0, [sp, #0x34]
700a7f7e: b930         	cbnz	r0, 0x700a7f8e <Sciclient_pmModuleClkRequest+0x7e> @ imm = #0xc
700a7f80: e7ff         	b	0x700a7f82 <Sciclient_pmModuleClkRequest+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a7f82: 9800         	ldr	r0, [sp]
700a7f84: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a7f88: 2802         	cmp	r0, #0x2
700a7f8a: d004         	beq	0x700a7f96 <Sciclient_pmModuleClkRequest+0x86> @ imm = #0x8
700a7f8c: e7ff         	b	0x700a7f8e <Sciclient_pmModuleClkRequest+0x7e> @ imm = #-0x2
700a7f8e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a7f92: 900d         	str	r0, [sp, #0x34]
;     }
700a7f94: e7ff         	b	0x700a7f96 <Sciclient_pmModuleClkRequest+0x86> @ imm = #-0x2
;     return retVal;
700a7f96: 980d         	ldr	r0, [sp, #0x34]
700a7f98: b012         	add	sp, #0x48
700a7f9a: bd80         	pop	{r7, pc}
700a7f9c: 0000         	movs	r0, r0
700a7f9e: 0000         	movs	r0, r0

700a7fa0 <Sciclient_pmSetModuleState>:
; {
700a7fa0: b580         	push	{r7, lr}
700a7fa2: b092         	sub	sp, #0x48
700a7fa4: 9011         	str	r0, [sp, #0x44]
700a7fa6: 9110         	str	r1, [sp, #0x40]
700a7fa8: 920f         	str	r2, [sp, #0x3c]
700a7faa: 930e         	str	r3, [sp, #0x38]
700a7fac: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a7fae: 900d         	str	r0, [sp, #0x34]
;     request.id       = (uint32_t) moduleId;
700a7fb0: 9911         	ldr	r1, [sp, #0x44]
700a7fb2: 910a         	str	r1, [sp, #0x28]
;     request.reserved = (uint32_t) 0;
700a7fb4: 900b         	str	r0, [sp, #0x2c]
;     request.state    = (uint8_t) state;
700a7fb6: 9910         	ldr	r1, [sp, #0x40]
700a7fb8: f88d 1030    	strb.w	r1, [sp, #0x30]
700a7fbc: f44f 7100    	mov.w	r1, #0x200
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE;
700a7fc0: f8ad 100c    	strh.w	r1, [sp, #0xc]
;     reqParam.flags          = (uint32_t) reqFlag;
700a7fc4: 990f         	ldr	r1, [sp, #0x3c]
700a7fc6: 9104         	str	r1, [sp, #0x10]
700a7fc8: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a7fca: 9105         	str	r1, [sp, #0x14]
700a7fcc: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a7fce: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a7fd0: 990e         	ldr	r1, [sp, #0x38]
700a7fd2: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a7fd4: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a7fd6: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a7fd8: 9002         	str	r0, [sp, #0x8]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700a7fda: 980f         	ldr	r0, [sp, #0x3c]
700a7fdc: f000 0002    	and	r0, r0, #0x2
700a7fe0: 2802         	cmp	r0, #0x2
700a7fe2: d007         	beq	0x700a7ff4 <Sciclient_pmSetModuleState+0x54> @ imm = #0xe
700a7fe4: e7ff         	b	0x700a7fe6 <Sciclient_pmSetModuleState+0x46> @ imm = #-0x2
;         (reqFlag != 0U))
700a7fe6: 980f         	ldr	r0, [sp, #0x3c]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700a7fe8: b120         	cbz	r0, 0x700a7ff4 <Sciclient_pmSetModuleState+0x54> @ imm = #0x8
700a7fea: e7ff         	b	0x700a7fec <Sciclient_pmSetModuleState+0x4c> @ imm = #-0x2
700a7fec: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a7ff0: 900d         	str	r0, [sp, #0x34]
;     }
700a7ff2: e7ff         	b	0x700a7ff4 <Sciclient_pmSetModuleState+0x54> @ imm = #-0x2
;     if(retVal == SystemP_SUCCESS)
700a7ff4: 980d         	ldr	r0, [sp, #0x34]
700a7ff6: b930         	cbnz	r0, 0x700a8006 <Sciclient_pmSetModuleState+0x66> @ imm = #0xc
700a7ff8: e7ff         	b	0x700a7ffa <Sciclient_pmSetModuleState+0x5a> @ imm = #-0x2
700a7ffa: a803         	add	r0, sp, #0xc
700a7ffc: 4669         	mov	r1, sp
;         retVal = Sciclient_service(&reqParam, &respParam);
700a7ffe: f7f3 ff3f    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xc182
700a8002: 900d         	str	r0, [sp, #0x34]
;     }
700a8004: e7ff         	b	0x700a8006 <Sciclient_pmSetModuleState+0x66> @ imm = #-0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8006: 980d         	ldr	r0, [sp, #0x34]
700a8008: b948         	cbnz	r0, 0x700a801e <Sciclient_pmSetModuleState+0x7e> @ imm = #0x12
700a800a: e7ff         	b	0x700a800c <Sciclient_pmSetModuleState+0x6c> @ imm = #-0x2
;         ((reqFlag != 0U) &&
700a800c: 980f         	ldr	r0, [sp, #0x3c]
700a800e: b150         	cbz	r0, 0x700a8026 <Sciclient_pmSetModuleState+0x86> @ imm = #0x14
700a8010: e7ff         	b	0x700a8012 <Sciclient_pmSetModuleState+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)))
700a8012: 9800         	ldr	r0, [sp]
700a8014: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8018: 2802         	cmp	r0, #0x2
700a801a: d004         	beq	0x700a8026 <Sciclient_pmSetModuleState+0x86> @ imm = #0x8
700a801c: e7ff         	b	0x700a801e <Sciclient_pmSetModuleState+0x7e> @ imm = #-0x2
700a801e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a8022: 900d         	str	r0, [sp, #0x34]
;     }
700a8024: e7ff         	b	0x700a8026 <Sciclient_pmSetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a8026: 980d         	ldr	r0, [sp, #0x34]
700a8028: b012         	add	sp, #0x48
700a802a: bd80         	pop	{r7, pc}
700a802c: 0000         	movs	r0, r0
700a802e: 0000         	movs	r0, r0

700a8030 <Sciclient_rmIaEvtRomMapped>:
; {
700a8030: b082         	sub	sp, #0x8
700a8032: 9001         	str	r0, [sp, #0x4]
700a8034: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a8038: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a803a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a803e: 9801         	ldr	r0, [sp, #0x4]
700a8040: 6980         	ldr	r0, [r0, #0x18]
700a8042: b3a8         	cbz	r0, 0x700a80b0 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #0x6a
700a8044: e7ff         	b	0x700a8046 <Sciclient_rmIaEvtRomMapped+0x16> @ imm = #-0x2
700a8046: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a8048: f88d 0000    	strb.w	r0, [sp]
700a804c: e7ff         	b	0x700a804e <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x2
700a804e: f89d 0000    	ldrb.w	r0, [sp]
700a8052: 9901         	ldr	r1, [sp, #0x4]
700a8054: 7f09         	ldrb	r1, [r1, #0x1c]
700a8056: 4288         	cmp	r0, r1
700a8058: da29         	bge	0x700a80ae <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0x52
700a805a: e7ff         	b	0x700a805c <Sciclient_rmIaEvtRomMapped+0x2c> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a805c: 9801         	ldr	r0, [sp, #0x4]
700a805e: 6980         	ldr	r0, [r0, #0x18]
700a8060: f89d 1000    	ldrb.w	r1, [sp]
700a8064: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a8068: 7880         	ldrb	r0, [r0, #0x2]
700a806a: 07c0         	lsls	r0, r0, #0x1f
700a806c: b9c0         	cbnz	r0, 0x700a80a0 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x30
700a806e: e7ff         	b	0x700a8070 <Sciclient_rmIaEvtRomMapped+0x40> @ imm = #-0x2
;                 (evt == (inst->rom_usage[i].event - inst->sevt_offset))) {
700a8070: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a8074: 9a01         	ldr	r2, [sp, #0x4]
700a8076: 6991         	ldr	r1, [r2, #0x18]
700a8078: f89d 3000    	ldrb.w	r3, [sp]
700a807c: f831 1023    	ldrh.w	r1, [r1, r3, lsl #2]
700a8080: 8912         	ldrh	r2, [r2, #0x8]
700a8082: 1a89         	subs	r1, r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a8084: 4288         	cmp	r0, r1
700a8086: d10b         	bne	0x700a80a0 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x16
700a8088: e7ff         	b	0x700a808a <Sciclient_rmIaEvtRomMapped+0x5a> @ imm = #-0x2
700a808a: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a808c: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a8090: 9901         	ldr	r1, [sp, #0x4]
700a8092: 6989         	ldr	r1, [r1, #0x18]
700a8094: f89d 2000    	ldrb.w	r2, [sp]
700a8098: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a809c: 7088         	strb	r0, [r1, #0x2]
;                 break;
700a809e: e006         	b	0x700a80ae <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0xc
;         }
700a80a0: e7ff         	b	0x700a80a2 <Sciclient_rmIaEvtRomMapped+0x72> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a80a2: f89d 0000    	ldrb.w	r0, [sp]
700a80a6: 3001         	adds	r0, #0x1
700a80a8: f88d 0000    	strb.w	r0, [sp]
700a80ac: e7cf         	b	0x700a804e <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x62
;     }
700a80ae: e7ff         	b	0x700a80b0 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #-0x2
;     return rom_mapped;
700a80b0: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a80b4: f000 0001    	and	r0, r0, #0x1
700a80b8: b002         	add	sp, #0x8
700a80ba: 4770         	bx	lr
700a80bc: 0000         	movs	r0, r0
700a80be: 0000         	movs	r0, r0

700a80c0 <UART_writeCancelNoCB>:
; {
700a80c0: b580         	push	{r7, lr}
700a80c2: b084         	sub	sp, #0x10
700a80c4: 9003         	str	r0, [sp, #0xc]
700a80c6: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a80c8: 9001         	str	r0, [sp, #0x4]
;     hUartInit = hUart->hUartInit;
700a80ca: 9803         	ldr	r0, [sp, #0xc]
700a80cc: 6840         	ldr	r0, [r0, #0x4]
700a80ce: 9000         	str	r0, [sp]
;     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700a80d0: 9803         	ldr	r0, [sp, #0xc]
700a80d2: 6800         	ldr	r0, [r0]
700a80d4: 2102         	movs	r1, #0x2
700a80d6: f7fc f953    	bl	0x700a4380 <UART_intrDisable> @ imm = #-0x3d5a
;     key = HwiP_disable();
700a80da: f006 e95a    	blx	0x700ae390 <HwiP_disable> @ imm = #0x62b4
700a80de: 9002         	str	r0, [sp, #0x8]
;     if ((hUart->writeSizeRemaining) == 0U)
700a80e0: 9803         	ldr	r0, [sp, #0xc]
700a80e2: 6900         	ldr	r0, [r0, #0x10]
700a80e4: b920         	cbnz	r0, 0x700a80f0 <UART_writeCancelNoCB+0x30> @ imm = #0x8
700a80e6: e7ff         	b	0x700a80e8 <UART_writeCancelNoCB+0x28> @ imm = #-0x2
700a80e8: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700a80ec: 9001         	str	r0, [sp, #0x4]
;     }
700a80ee: e027         	b	0x700a8140 <UART_writeCancelNoCB+0x80> @ imm = #0x4e
;         if (hUartInit->transferMode == UART_CONFIG_MODE_DMA)
700a80f0: 9800         	ldr	r0, [sp]
700a80f2: 6a00         	ldr	r0, [r0, #0x20]
700a80f4: 2803         	cmp	r0, #0x3
700a80f6: d111         	bne	0x700a811c <UART_writeCancelNoCB+0x5c> @ imm = #0x22
700a80f8: e7ff         	b	0x700a80fa <UART_writeCancelNoCB+0x3a> @ imm = #-0x2
;             UART_lld_dmaDisableChannel(hUart, (Bool)TRUE);
700a80fa: 9803         	ldr	r0, [sp, #0xc]
700a80fc: 2101         	movs	r1, #0x1
700a80fe: f7ff fbff    	bl	0x700a7900 <UART_lld_dmaDisableChannel> @ imm = #-0x802
;             if (hUart->writeTrans.buf != NULL)
700a8102: 9803         	ldr	r0, [sp, #0xc]
700a8104: 6bc0         	ldr	r0, [r0, #0x3c]
700a8106: b120         	cbz	r0, 0x700a8112 <UART_writeCancelNoCB+0x52> @ imm = #0x8
700a8108: e7ff         	b	0x700a810a <UART_writeCancelNoCB+0x4a> @ imm = #-0x2
;                 hUart->writeTrans.count = 0;
700a810a: 9903         	ldr	r1, [sp, #0xc]
700a810c: 2000         	movs	r0, #0x0
700a810e: 6408         	str	r0, [r1, #0x40]
;             }
700a8110: e003         	b	0x700a811a <UART_writeCancelNoCB+0x5a> @ imm = #0x6
;                 hUart->writeCount = 0;
700a8112: 9903         	ldr	r1, [sp, #0xc]
700a8114: 2000         	movs	r0, #0x0
700a8116: 60c8         	str	r0, [r1, #0xc]
700a8118: e7ff         	b	0x700a811a <UART_writeCancelNoCB+0x5a> @ imm = #-0x2
;         }
700a811a: e010         	b	0x700a813e <UART_writeCancelNoCB+0x7e> @ imm = #0x20
;             hUart->writeBuf = (const uint8_t *)hUart->writeBuf - hUart->writeCount;
700a811c: 9903         	ldr	r1, [sp, #0xc]
700a811e: 6888         	ldr	r0, [r1, #0x8]
700a8120: 68ca         	ldr	r2, [r1, #0xc]
700a8122: 1a80         	subs	r0, r0, r2
700a8124: 6088         	str	r0, [r1, #0x8]
;             if (hUart->writeTrans.buf != NULL)
700a8126: 9803         	ldr	r0, [sp, #0xc]
700a8128: 6bc0         	ldr	r0, [r0, #0x3c]
700a812a: b120         	cbz	r0, 0x700a8136 <UART_writeCancelNoCB+0x76> @ imm = #0x8
700a812c: e7ff         	b	0x700a812e <UART_writeCancelNoCB+0x6e> @ imm = #-0x2
;                 hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
700a812e: 9903         	ldr	r1, [sp, #0xc]
700a8130: 68c8         	ldr	r0, [r1, #0xc]
700a8132: 6408         	str	r0, [r1, #0x40]
;             }
700a8134: e7ff         	b	0x700a8136 <UART_writeCancelNoCB+0x76> @ imm = #-0x2
;             hUart->writeSizeRemaining = 0;
700a8136: 9903         	ldr	r1, [sp, #0xc]
700a8138: 2000         	movs	r0, #0x0
700a813a: 6108         	str	r0, [r1, #0x10]
700a813c: e7ff         	b	0x700a813e <UART_writeCancelNoCB+0x7e> @ imm = #-0x2
700a813e: e7ff         	b	0x700a8140 <UART_writeCancelNoCB+0x80> @ imm = #-0x2
;     HwiP_restore(key);
700a8140: 9802         	ldr	r0, [sp, #0x8]
700a8142: f006 e946    	blx	0x700ae3d0 <HwiP_restore> @ imm = #0x628c
;     return (status);
700a8146: 9801         	ldr	r0, [sp, #0x4]
700a8148: b004         	add	sp, #0x10
700a814a: bd80         	pop	{r7, pc}
700a814c: 0000         	movs	r0, r0
700a814e: 0000         	movs	r0, r0

700a8150 <Udma_ringFlushRaw>:
; {
700a8150: b580         	push	{r7, lr}
700a8152: b086         	sub	sp, #0x18
700a8154: 9005         	str	r0, [sp, #0x14]
700a8156: 9104         	str	r1, [sp, #0x10]
700a8158: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a815a: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a815c: 9805         	ldr	r0, [sp, #0x14]
700a815e: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == ringHandleInt) ||
700a8160: 9801         	ldr	r0, [sp, #0x4]
700a8162: b180         	cbz	r0, 0x700a8186 <Udma_ringFlushRaw+0x36> @ imm = #0x20
700a8164: e7ff         	b	0x700a8166 <Udma_ringFlushRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a8166: 9801         	ldr	r0, [sp, #0x4]
700a8168: 6d80         	ldr	r0, [r0, #0x58]
700a816a: f64a 31cd    	movw	r1, #0xabcd
700a816e: f6ca 31dc    	movt	r1, #0xabdc
700a8172: 4288         	cmp	r0, r1
700a8174: d107         	bne	0x700a8186 <Udma_ringFlushRaw+0x36> @ imm = #0xe
700a8176: e7ff         	b	0x700a8178 <Udma_ringFlushRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a8178: 9801         	ldr	r0, [sp, #0x4]
700a817a: 8880         	ldrh	r0, [r0, #0x4]
700a817c: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a8180: 4288         	cmp	r0, r1
700a8182: d104         	bne	0x700a818e <Udma_ringFlushRaw+0x3e> @ imm = #0x8
700a8184: e7ff         	b	0x700a8186 <Udma_ringFlushRaw+0x36> @ imm = #-0x2
700a8186: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a818a: 9003         	str	r0, [sp, #0xc]
;     }
700a818c: e7ff         	b	0x700a818e <Udma_ringFlushRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a818e: 9803         	ldr	r0, [sp, #0xc]
700a8190: b9a8         	cbnz	r0, 0x700a81be <Udma_ringFlushRaw+0x6e> @ imm = #0x2a
700a8192: e7ff         	b	0x700a8194 <Udma_ringFlushRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a8194: 9801         	ldr	r0, [sp, #0x4]
700a8196: 6800         	ldr	r0, [r0]
700a8198: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) ||
700a819a: 9802         	ldr	r0, [sp, #0x8]
700a819c: b150         	cbz	r0, 0x700a81b4 <Udma_ringFlushRaw+0x64> @ imm = #0x14
700a819e: e7ff         	b	0x700a81a0 <Udma_ringFlushRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a81a0: 9802         	ldr	r0, [sp, #0x8]
700a81a2: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a81a6: f64a 31cd    	movw	r1, #0xabcd
700a81aa: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a81ae: 4288         	cmp	r0, r1
700a81b0: d004         	beq	0x700a81bc <Udma_ringFlushRaw+0x6c> @ imm = #0x8
700a81b2: e7ff         	b	0x700a81b4 <Udma_ringFlushRaw+0x64> @ imm = #-0x2
700a81b4: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a81b8: 9003         	str	r0, [sp, #0xc]
;         }
700a81ba: e7ff         	b	0x700a81bc <Udma_ringFlushRaw+0x6c> @ imm = #-0x2
;     }
700a81bc: e7ff         	b	0x700a81be <Udma_ringFlushRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a81be: 9803         	ldr	r0, [sp, #0xc]
700a81c0: b940         	cbnz	r0, 0x700a81d4 <Udma_ringFlushRaw+0x84> @ imm = #0x10
700a81c2: e7ff         	b	0x700a81c4 <Udma_ringFlushRaw+0x74> @ imm = #-0x2
;         retVal = drvHandle->ringFlushRaw(drvHandle, ringHandleInt, phyDescMem);
700a81c4: 9802         	ldr	r0, [sp, #0x8]
700a81c6: f8d0 3598    	ldr.w	r3, [r0, #0x598]
700a81ca: 9901         	ldr	r1, [sp, #0x4]
700a81cc: 9a04         	ldr	r2, [sp, #0x10]
700a81ce: 4798         	blx	r3
700a81d0: 9003         	str	r0, [sp, #0xc]
;     }
700a81d2: e7ff         	b	0x700a81d4 <Udma_ringFlushRaw+0x84> @ imm = #-0x2
;     return (retVal);
700a81d4: 9803         	ldr	r0, [sp, #0xc]
700a81d6: b006         	add	sp, #0x18
700a81d8: bd80         	pop	{r7, pc}
700a81da: 0000         	movs	r0, r0
700a81dc: 0000         	movs	r0, r0
700a81de: 0000         	movs	r0, r0

700a81e0 <xQueueGenericReset>:
; {
700a81e0: b580         	push	{r7, lr}
700a81e2: b084         	sub	sp, #0x10
700a81e4: 9003         	str	r0, [sp, #0xc]
700a81e6: 9102         	str	r1, [sp, #0x8]
;     Queue_t * const pxQueue = xQueue;
700a81e8: 9803         	ldr	r0, [sp, #0xc]
700a81ea: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700a81ec: f004 f900    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0x4200
;         pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700a81f0: 9901         	ldr	r1, [sp, #0x4]
700a81f2: 680b         	ldr	r3, [r1]
700a81f4: 6bc8         	ldr	r0, [r1, #0x3c]
700a81f6: 6c0a         	ldr	r2, [r1, #0x40]
700a81f8: fb00 3002    	mla	r0, r0, r2, r3
700a81fc: 6088         	str	r0, [r1, #0x8]
;         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
700a81fe: 9901         	ldr	r1, [sp, #0x4]
700a8200: 2000         	movs	r0, #0x0
700a8202: 6388         	str	r0, [r1, #0x38]
;         pxQueue->pcWriteTo = pxQueue->pcHead;
700a8204: 9901         	ldr	r1, [sp, #0x4]
700a8206: 6808         	ldr	r0, [r1]
700a8208: 6048         	str	r0, [r1, #0x4]
;         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700a820a: 9901         	ldr	r1, [sp, #0x4]
700a820c: 680b         	ldr	r3, [r1]
700a820e: 6bc8         	ldr	r0, [r1, #0x3c]
700a8210: 6c0a         	ldr	r2, [r1, #0x40]
700a8212: 3801         	subs	r0, #0x1
700a8214: fb00 3002    	mla	r0, r0, r2, r3
700a8218: 60c8         	str	r0, [r1, #0xc]
;         pxQueue->cRxLock = queueUNLOCKED;
700a821a: 9901         	ldr	r1, [sp, #0x4]
700a821c: 20ff         	movs	r0, #0xff
700a821e: f881 0044    	strb.w	r0, [r1, #0x44]
;         pxQueue->cTxLock = queueUNLOCKED;
700a8222: 9901         	ldr	r1, [sp, #0x4]
700a8224: f881 0045    	strb.w	r0, [r1, #0x45]
;         if( xNewQueue == pdFALSE )
700a8228: 9802         	ldr	r0, [sp, #0x8]
700a822a: b980         	cbnz	r0, 0x700a824e <xQueueGenericReset+0x6e> @ imm = #0x20
700a822c: e7ff         	b	0x700a822e <xQueueGenericReset+0x4e> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a822e: 9801         	ldr	r0, [sp, #0x4]
700a8230: 6900         	ldr	r0, [r0, #0x10]
700a8232: b150         	cbz	r0, 0x700a824a <xQueueGenericReset+0x6a> @ imm = #0x14
700a8234: e7ff         	b	0x700a8236 <xQueueGenericReset+0x56> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a8236: 9801         	ldr	r0, [sp, #0x4]
700a8238: 3010         	adds	r0, #0x10
700a823a: f7fe f821    	bl	0x700a6280 <xTaskRemoveFromEventList> @ imm = #-0x1fbe
700a823e: b110         	cbz	r0, 0x700a8246 <xQueueGenericReset+0x66> @ imm = #0x4
700a8240: e7ff         	b	0x700a8242 <xQueueGenericReset+0x62> @ imm = #-0x2
;                     queueYIELD_IF_USING_PREEMPTION();
700a8242: df00         	svc	#0x0
;                 }
700a8244: e000         	b	0x700a8248 <xQueueGenericReset+0x68> @ imm = #0x0
700a8246: e7ff         	b	0x700a8248 <xQueueGenericReset+0x68> @ imm = #-0x2
;             }
700a8248: e000         	b	0x700a824c <xQueueGenericReset+0x6c> @ imm = #0x0
700a824a: e7ff         	b	0x700a824c <xQueueGenericReset+0x6c> @ imm = #-0x2
;         }
700a824c: e008         	b	0x700a8260 <xQueueGenericReset+0x80> @ imm = #0x10
;             vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
700a824e: 9801         	ldr	r0, [sp, #0x4]
700a8250: 3010         	adds	r0, #0x10
700a8252: f004 fa15    	bl	0x700ac680 <vListInitialise> @ imm = #0x442a
;             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
700a8256: 9801         	ldr	r0, [sp, #0x4]
700a8258: 3024         	adds	r0, #0x24
700a825a: f004 fa11    	bl	0x700ac680 <vListInitialise> @ imm = #0x4422
700a825e: e7ff         	b	0x700a8260 <xQueueGenericReset+0x80> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700a8260: f003 f9c6    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x338c
700a8264: 2001         	movs	r0, #0x1
;     return pdPASS;
700a8266: b004         	add	sp, #0x10
700a8268: bd80         	pop	{r7, pc}
700a826a: 0000         	movs	r0, r0
700a826c: 0000         	movs	r0, r0
700a826e: 0000         	movs	r0, r0

700a8270 <CSL_bcdmaGetCfg>:
; {
700a8270: b580         	push	{r7, lr}
700a8272: b082         	sub	sp, #0x8
700a8274: 9001         	str	r0, [sp, #0x4]
;     if( ! ((pCfg == NULL) || (pCfg->pGenCfgRegs == NULL)) )
700a8276: 9801         	ldr	r0, [sp, #0x4]
700a8278: b3e0         	cbz	r0, 0x700a82f4 <CSL_bcdmaGetCfg+0x84> @ imm = #0x78
700a827a: e7ff         	b	0x700a827c <CSL_bcdmaGetCfg+0xc> @ imm = #-0x2
700a827c: 9801         	ldr	r0, [sp, #0x4]
700a827e: 6800         	ldr	r0, [r0]
700a8280: b3c0         	cbz	r0, 0x700a82f4 <CSL_bcdmaGetCfg+0x84> @ imm = #0x70
700a8282: e7ff         	b	0x700a8284 <CSL_bcdmaGetCfg+0x14> @ imm = #-0x2
;         pCfg->cap0 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP0 );
700a8284: 9801         	ldr	r0, [sp, #0x4]
700a8286: 6800         	ldr	r0, [r0]
700a8288: 3020         	adds	r0, #0x20
700a828a: f005 fa19    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0x5432
700a828e: 9901         	ldr	r1, [sp, #0x4]
700a8290: 61c8         	str	r0, [r1, #0x1c]
;         pCfg->cap1 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP1 );
700a8292: 9801         	ldr	r0, [sp, #0x4]
700a8294: 6800         	ldr	r0, [r0]
700a8296: 3024         	adds	r0, #0x24
700a8298: f005 fa12    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0x5424
700a829c: 9901         	ldr	r1, [sp, #0x4]
700a829e: 6208         	str	r0, [r1, #0x20]
;         regVal = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP2 );
700a82a0: 9801         	ldr	r0, [sp, #0x4]
700a82a2: 6800         	ldr	r0, [r0]
700a82a4: 3028         	adds	r0, #0x28
700a82a6: f005 fa0b    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0x5416
700a82aa: 9000         	str	r0, [sp]
;         pCfg->bcChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_CHAN_CNT );
700a82ac: 9800         	ldr	r0, [sp]
700a82ae: f36f 205f    	bfc	r0, #9, #23
700a82b2: 9901         	ldr	r1, [sp, #0x4]
700a82b4: 6248         	str	r0, [r1, #0x24]
;         pCfg->splitTxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_TCHAN_CNT );
700a82b6: 9800         	ldr	r0, [sp]
700a82b8: f3c0 2048    	ubfx	r0, r0, #0x9, #0x9
700a82bc: 9901         	ldr	r1, [sp, #0x4]
700a82be: 62c8         	str	r0, [r1, #0x2c]
;         pCfg->splitRxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_RCHAN_CNT );
700a82c0: 9800         	ldr	r0, [sp]
700a82c2: f3c0 4088    	ubfx	r0, r0, #0x12, #0x9
700a82c6: 9901         	ldr	r1, [sp, #0x4]
700a82c8: 6288         	str	r0, [r1, #0x28]
;         pCfg->flowCnt = (uint32_t)0U;
700a82ca: 9901         	ldr	r1, [sp, #0x4]
700a82cc: 2000         	movs	r0, #0x0
700a82ce: 6308         	str	r0, [r1, #0x30]
;         pCfg->txChanCnt                     = pCfg->bcChanCnt + pCfg->splitTxChanCnt;
700a82d0: 9a01         	ldr	r2, [sp, #0x4]
700a82d2: 6a51         	ldr	r1, [r2, #0x24]
700a82d4: 6ad3         	ldr	r3, [r2, #0x2c]
700a82d6: 4419         	add	r1, r3
700a82d8: 6351         	str	r1, [r2, #0x34]
;         pCfg->rxChanCnt                     = pCfg->splitRxChanCnt;
700a82da: 9a01         	ldr	r2, [sp, #0x4]
700a82dc: 6a91         	ldr	r1, [r2, #0x28]
700a82de: 6391         	str	r1, [r2, #0x38]
;         pCfg->rxFlowCnt                     = pCfg->flowCnt;
700a82e0: 9a01         	ldr	r2, [sp, #0x4]
700a82e2: 6b11         	ldr	r1, [r2, #0x30]
700a82e4: 63d1         	str	r1, [r2, #0x3c]
;         pCfg->txExtUtcChanCnt               = (uint32_t)0U;
700a82e6: 9901         	ldr	r1, [sp, #0x4]
700a82e8: 6408         	str	r0, [r1, #0x40]
;         pCfg->txHighCapacityChanCnt         = (uint32_t)0U;
700a82ea: 9901         	ldr	r1, [sp, #0x4]
700a82ec: 6448         	str	r0, [r1, #0x44]
;         pCfg->txUltraHighCapacityChanCnt    = (uint32_t)0U;
700a82ee: 9901         	ldr	r1, [sp, #0x4]
700a82f0: 6488         	str	r0, [r1, #0x48]
;     }
700a82f2: e7ff         	b	0x700a82f4 <CSL_bcdmaGetCfg+0x84> @ imm = #-0x2
; }
700a82f4: b002         	add	sp, #0x8
700a82f6: bd80         	pop	{r7, pc}
		...

700a8300 <Udma_rmFreeVintrBit>:
; {
700a8300: b580         	push	{r7, lr}
700a8302: b088         	sub	sp, #0x20
700a8304: 9007         	str	r0, [sp, #0x1c]
700a8306: 9106         	str	r1, [sp, #0x18]
700a8308: 9205         	str	r2, [sp, #0x14]
;     controllerEventHandle = eventHandle;
700a830a: 9805         	ldr	r0, [sp, #0x14]
700a830c: 9001         	str	r0, [sp, #0x4]
;     eventPrms = &eventHandle->eventPrms;
700a830e: 9805         	ldr	r0, [sp, #0x14]
700a8310: 3008         	adds	r0, #0x8
700a8312: 9000         	str	r0, [sp]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700a8314: 9800         	ldr	r0, [sp]
700a8316: 6900         	ldr	r0, [r0, #0x10]
700a8318: b120         	cbz	r0, 0x700a8324 <Udma_rmFreeVintrBit+0x24> @ imm = #0x8
700a831a: e7ff         	b	0x700a831c <Udma_rmFreeVintrBit+0x1c> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a831c: 9800         	ldr	r0, [sp]
700a831e: 6900         	ldr	r0, [r0, #0x10]
700a8320: 9001         	str	r0, [sp, #0x4]
;     }
700a8322: e7ff         	b	0x700a8324 <Udma_rmFreeVintrBit+0x24> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a8324: 9806         	ldr	r0, [sp, #0x18]
700a8326: f500 609f    	add.w	r0, r0, #0x4f8
700a832a: f04f 31ff    	mov.w	r1, #0xffffffff
700a832e: f000 f9df    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #0x3be
;     bitMask = ((uint64_t) 1U << vintrBitNum);
700a8332: 9b07         	ldr	r3, [sp, #0x1c]
700a8334: f1a3 0220    	sub.w	r2, r3, #0x20
700a8338: 2101         	movs	r1, #0x1
700a833a: fa01 fc02    	lsl.w	r12, r1, r2
700a833e: f1c3 0020    	rsb.w	r0, r3, #0x20
700a8342: fa21 f000    	lsr.w	r0, r1, r0
700a8346: 2a00         	cmp	r2, #0x0
700a8348: bf58         	it	pl
700a834a: 4660         	movpl	r0, r12
700a834c: fa01 f103    	lsl.w	r1, r1, r3
700a8350: 2a00         	cmp	r2, #0x0
700a8352: bf58         	it	pl
700a8354: 2100         	movpl	r1, #0x0
700a8356: 9102         	str	r1, [sp, #0x8]
700a8358: 9003         	str	r0, [sp, #0xc]
;     controllerEventHandle->vintrBitAllocFlag &= ~bitMask;
700a835a: f8dd c008    	ldr.w	r12, [sp, #0x8]
700a835e: 9b03         	ldr	r3, [sp, #0xc]
700a8360: 9901         	ldr	r1, [sp, #0x4]
700a8362: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a8366: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700a836a: ea20 000c    	bic.w	r0, r0, r12
700a836e: ea22 0203    	bic.w	r2, r2, r3
700a8372: f8c1 208c    	str.w	r2, [r1, #0x8c]
700a8376: f8c1 0088    	str.w	r0, [r1, #0x88]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a837a: 9806         	ldr	r0, [sp, #0x18]
700a837c: f500 609f    	add.w	r0, r0, #0x4f8
700a8380: f001 fd06    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x1a0c
;     return;
700a8384: b008         	add	sp, #0x20
700a8386: bd80         	pop	{r7, pc}
		...

700a8390 <SOC_controlModuleLockMMR>:
; {
700a8390: b580         	push	{r7, lr}
700a8392: b086         	sub	sp, #0x18
700a8394: 9005         	str	r0, [sp, #0x14]
700a8396: 9104         	str	r1, [sp, #0x10]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700a8398: 9805         	ldr	r0, [sp, #0x14]
700a839a: b9d8         	cbnz	r0, 0x700a83d4 <SOC_controlModuleLockMMR+0x44> @ imm = #0x36
700a839c: e7ff         	b	0x700a839e <SOC_controlModuleLockMMR+0xe> @ imm = #-0x2
700a839e: f04f 4086    	mov.w	r0, #0x43000000
700a83a2: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700a83a4: 9101         	str	r1, [sp, #0x4]
700a83a6: f7fb fc4b    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x476a
700a83aa: 9901         	ldr	r1, [sp, #0x4]
700a83ac: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a83ae: 9803         	ldr	r0, [sp, #0xc]
700a83b0: 9a04         	ldr	r2, [sp, #0x10]
700a83b2: eb00 3082    	add.w	r0, r0, r2, lsl #14
700a83b6: f241 0208    	movw	r2, #0x1008
700a83ba: 4410         	add	r0, r2
700a83bc: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a83be: 9802         	ldr	r0, [sp, #0x8]
700a83c0: f005 f8fe    	bl	0x700ad5c0 <CSL_REG32_WR_RAW> @ imm = #0x51fc
700a83c4: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr++;
700a83c6: 9802         	ldr	r0, [sp, #0x8]
700a83c8: 3004         	adds	r0, #0x4
700a83ca: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a83cc: 9802         	ldr	r0, [sp, #0x8]
700a83ce: f005 f8f7    	bl	0x700ad5c0 <CSL_REG32_WR_RAW> @ imm = #0x51ee
;     }
700a83d2: e7ff         	b	0x700a83d4 <SOC_controlModuleLockMMR+0x44> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700a83d4: 9805         	ldr	r0, [sp, #0x14]
700a83d6: 2801         	cmp	r0, #0x1
700a83d8: d11b         	bne	0x700a8412 <SOC_controlModuleLockMMR+0x82> @ imm = #0x36
700a83da: e7ff         	b	0x700a83dc <SOC_controlModuleLockMMR+0x4c> @ imm = #-0x2
700a83dc: f04f 608a    	mov.w	r0, #0x4500000
700a83e0: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700a83e2: 9100         	str	r1, [sp]
700a83e4: f7fb fc2c    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x47a8
700a83e8: 9900         	ldr	r1, [sp]
700a83ea: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a83ec: 9803         	ldr	r0, [sp, #0xc]
700a83ee: 9a04         	ldr	r2, [sp, #0x10]
700a83f0: eb00 3082    	add.w	r0, r0, r2, lsl #14
700a83f4: f241 0208    	movw	r2, #0x1008
700a83f8: 4410         	add	r0, r2
700a83fa: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a83fc: 9802         	ldr	r0, [sp, #0x8]
700a83fe: f005 f8df    	bl	0x700ad5c0 <CSL_REG32_WR_RAW> @ imm = #0x51be
700a8402: 9900         	ldr	r1, [sp]
;         kickAddr++;
700a8404: 9802         	ldr	r0, [sp, #0x8]
700a8406: 3004         	adds	r0, #0x4
700a8408: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a840a: 9802         	ldr	r0, [sp, #0x8]
700a840c: f005 f8d8    	bl	0x700ad5c0 <CSL_REG32_WR_RAW> @ imm = #0x51b0
;     }
700a8410: e7ff         	b	0x700a8412 <SOC_controlModuleLockMMR+0x82> @ imm = #-0x2
;     return;
700a8412: b006         	add	sp, #0x18
700a8414: bd80         	pop	{r7, pc}
		...
700a841e: 0000         	movs	r0, r0

700a8420 <UART_lld_flushTxFifo>:
; {
700a8420: b580         	push	{r7, lr}
700a8422: b088         	sub	sp, #0x20
700a8424: 9007         	str	r0, [sp, #0x1c]
700a8426: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700a8428: 9006         	str	r0, [sp, #0x18]
700a842a: f640 31b8    	movw	r1, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700a842e: 9102         	str	r1, [sp, #0x8]
;     uint32_t            timeoutElapsed  = FALSE;
700a8430: 9001         	str	r0, [sp, #0x4]
;     if (NULL_PTR != hUart)
700a8432: 9807         	ldr	r0, [sp, #0x1c]
700a8434: b380         	cbz	r0, 0x700a8498 <UART_lld_flushTxFifo+0x78> @ imm = #0x60
700a8436: e7ff         	b	0x700a8438 <UART_lld_flushTxFifo+0x18> @ imm = #-0x2
;         hUartInit = hUart->hUartInit;
700a8438: 9807         	ldr	r0, [sp, #0x1c]
700a843a: 6840         	ldr	r0, [r0, #0x4]
700a843c: 9000         	str	r0, [sp]
;         startTicks = hUartInit->clockP_get();
700a843e: 9800         	ldr	r0, [sp]
700a8440: 6d40         	ldr	r0, [r0, #0x54]
700a8442: 4780         	blx	r0
700a8444: 9004         	str	r0, [sp, #0x10]
;         while (FALSE == timeoutElapsed)
700a8446: e7ff         	b	0x700a8448 <UART_lld_flushTxFifo+0x28> @ imm = #-0x2
700a8448: 9801         	ldr	r0, [sp, #0x4]
700a844a: b9e0         	cbnz	r0, 0x700a8486 <UART_lld_flushTxFifo+0x66> @ imm = #0x38
700a844c: e7ff         	b	0x700a844e <UART_lld_flushTxFifo+0x2e> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(hUart->baseAddr);
700a844e: 9807         	ldr	r0, [sp, #0x1c]
700a8450: 6800         	ldr	r0, [r0]
700a8452: f003 fbb5    	bl	0x700abbc0 <UART_spaceAvail> @ imm = #0x376a
700a8456: 9005         	str	r0, [sp, #0x14]
;             if ((uint32_t) TRUE == isTxFifoEmpty)
700a8458: 9805         	ldr	r0, [sp, #0x14]
700a845a: 2801         	cmp	r0, #0x1
700a845c: d101         	bne	0x700a8462 <UART_lld_flushTxFifo+0x42> @ imm = #0x2
700a845e: e7ff         	b	0x700a8460 <UART_lld_flushTxFifo+0x40> @ imm = #-0x2
;                 break;
700a8460: e011         	b	0x700a8486 <UART_lld_flushTxFifo+0x66> @ imm = #0x22
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700a8462: 9800         	ldr	r0, [sp]
700a8464: 6d40         	ldr	r0, [r0, #0x54]
700a8466: 4780         	blx	r0
700a8468: 9904         	ldr	r1, [sp, #0x10]
700a846a: 1a40         	subs	r0, r0, r1
700a846c: 9003         	str	r0, [sp, #0xc]
;             if (elapsedTicks >= timeout)
700a846e: 9803         	ldr	r0, [sp, #0xc]
700a8470: 9902         	ldr	r1, [sp, #0x8]
700a8472: 4288         	cmp	r0, r1
700a8474: d303         	blo	0x700a847e <UART_lld_flushTxFifo+0x5e> @ imm = #0x6
700a8476: e7ff         	b	0x700a8478 <UART_lld_flushTxFifo+0x58> @ imm = #-0x2
700a8478: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700a847a: 9001         	str	r0, [sp, #0x4]
;             }
700a847c: e002         	b	0x700a8484 <UART_lld_flushTxFifo+0x64> @ imm = #0x4
;                 TaskP_yield();
700a847e: f005 f9af    	bl	0x700ad7e0 <TaskP_yield> @ imm = #0x535e
700a8482: e7ff         	b	0x700a8484 <UART_lld_flushTxFifo+0x64> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700a8484: e7e0         	b	0x700a8448 <UART_lld_flushTxFifo+0x28> @ imm = #-0x40
;         if(TRUE == timeoutElapsed)
700a8486: 9801         	ldr	r0, [sp, #0x4]
700a8488: 2801         	cmp	r0, #0x1
700a848a: d104         	bne	0x700a8496 <UART_lld_flushTxFifo+0x76> @ imm = #0x8
700a848c: e7ff         	b	0x700a848e <UART_lld_flushTxFifo+0x6e> @ imm = #-0x2
700a848e: f06f 0001    	mvn	r0, #0x1
;             status = UART_TRANSFER_TIMEOUT;
700a8492: 9006         	str	r0, [sp, #0x18]
;         }
700a8494: e7ff         	b	0x700a8496 <UART_lld_flushTxFifo+0x76> @ imm = #-0x2
;     }
700a8496: e003         	b	0x700a84a0 <UART_lld_flushTxFifo+0x80> @ imm = #0x6
700a8498: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a849c: 9006         	str	r0, [sp, #0x18]
700a849e: e7ff         	b	0x700a84a0 <UART_lld_flushTxFifo+0x80> @ imm = #-0x2
;     return status;
700a84a0: 9806         	ldr	r0, [sp, #0x18]
700a84a2: b008         	add	sp, #0x20
700a84a4: bd80         	pop	{r7, pc}
		...
700a84ae: 0000         	movs	r0, r0

700a84b0 <UART_tcrTlrBitValRestore>:
; {
700a84b0: b580         	push	{r7, lr}
700a84b2: b088         	sub	sp, #0x20
700a84b4: 9007         	str	r0, [sp, #0x1c]
700a84b6: 9106         	str	r1, [sp, #0x18]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a84b8: 9807         	ldr	r0, [sp, #0x1c]
700a84ba: 21bf         	movs	r1, #0xbf
700a84bc: 9101         	str	r1, [sp, #0x4]
700a84be: f002 f8af    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x215e
700a84c2: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a84c4: 9807         	ldr	r0, [sp, #0x1c]
700a84c6: 3008         	adds	r0, #0x8
700a84c8: 2110         	movs	r1, #0x10
700a84ca: 9102         	str	r1, [sp, #0x8]
700a84cc: 2204         	movs	r2, #0x4
700a84ce: 9203         	str	r2, [sp, #0xc]
700a84d0: f004 fd16    	bl	0x700acf00 <HW_RD_FIELD32_RAW> @ imm = #0x4a2c
700a84d4: 9902         	ldr	r1, [sp, #0x8]
700a84d6: 9a03         	ldr	r2, [sp, #0xc]
700a84d8: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a84da: 9807         	ldr	r0, [sp, #0x1c]
700a84dc: 3008         	adds	r0, #0x8
700a84de: 2301         	movs	r3, #0x1
700a84e0: f003 ff26    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x3e4c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a84e4: 9807         	ldr	r0, [sp, #0x1c]
700a84e6: 300c         	adds	r0, #0xc
700a84e8: 9904         	ldr	r1, [sp, #0x10]
700a84ea: f005 f8a9    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x5152
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a84ee: 9807         	ldr	r0, [sp, #0x1c]
700a84f0: 2180         	movs	r1, #0x80
700a84f2: f002 f895    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x212a
700a84f6: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR, tcrTlrBitVal);
700a84f8: 9807         	ldr	r0, [sp, #0x1c]
700a84fa: 3010         	adds	r0, #0x10
700a84fc: 9b06         	ldr	r3, [sp, #0x18]
700a84fe: 2140         	movs	r1, #0x40
700a8500: 2206         	movs	r2, #0x6
700a8502: f003 ff15    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x3e2a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a8506: 9807         	ldr	r0, [sp, #0x1c]
700a8508: 300c         	adds	r0, #0xc
700a850a: 9904         	ldr	r1, [sp, #0x10]
700a850c: f005 f898    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x5130
700a8510: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a8512: 9807         	ldr	r0, [sp, #0x1c]
700a8514: f002 f884    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0x2108
700a8518: 9902         	ldr	r1, [sp, #0x8]
700a851a: 9a03         	ldr	r2, [sp, #0xc]
700a851c: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a851e: 9807         	ldr	r0, [sp, #0x1c]
700a8520: 3008         	adds	r0, #0x8
700a8522: 9b05         	ldr	r3, [sp, #0x14]
700a8524: f003 ff04    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x3e08
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a8528: 9807         	ldr	r0, [sp, #0x1c]
700a852a: 300c         	adds	r0, #0xc
700a852c: 9904         	ldr	r1, [sp, #0x10]
700a852e: f005 f887    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x510e
; }
700a8532: b008         	add	sp, #0x20
700a8534: bd80         	pop	{r7, pc}
		...
700a853e: 0000         	movs	r0, r0

700a8540 <prvInsertTimerInActiveList>:
;     {
700a8540: b580         	push	{r7, lr}
700a8542: b086         	sub	sp, #0x18
700a8544: 9005         	str	r0, [sp, #0x14]
700a8546: 9104         	str	r1, [sp, #0x10]
700a8548: 9203         	str	r2, [sp, #0xc]
700a854a: 9302         	str	r3, [sp, #0x8]
700a854c: 2000         	movs	r0, #0x0
;         BaseType_t xProcessTimerNow = pdFALSE;
700a854e: 9001         	str	r0, [sp, #0x4]
;         listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
700a8550: 9804         	ldr	r0, [sp, #0x10]
700a8552: 9905         	ldr	r1, [sp, #0x14]
700a8554: 6048         	str	r0, [r1, #0x4]
;         listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700a8556: 9805         	ldr	r0, [sp, #0x14]
700a8558: 6100         	str	r0, [r0, #0x10]
;         if( xNextExpiryTime <= xTimeNow )
700a855a: 9804         	ldr	r0, [sp, #0x10]
700a855c: 9903         	ldr	r1, [sp, #0xc]
700a855e: 4288         	cmp	r0, r1
700a8560: d816         	bhi	0x700a8590 <prvInsertTimerInActiveList+0x50> @ imm = #0x2c
700a8562: e7ff         	b	0x700a8564 <prvInsertTimerInActiveList+0x24> @ imm = #-0x2
;             if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
700a8564: 9803         	ldr	r0, [sp, #0xc]
700a8566: 9902         	ldr	r1, [sp, #0x8]
700a8568: 1a40         	subs	r0, r0, r1
700a856a: 9905         	ldr	r1, [sp, #0x14]
700a856c: 6989         	ldr	r1, [r1, #0x18]
700a856e: 4288         	cmp	r0, r1
700a8570: d303         	blo	0x700a857a <prvInsertTimerInActiveList+0x3a> @ imm = #0x6
700a8572: e7ff         	b	0x700a8574 <prvInsertTimerInActiveList+0x34> @ imm = #-0x2
700a8574: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700a8576: 9001         	str	r0, [sp, #0x4]
;             }
700a8578: e009         	b	0x700a858e <prvInsertTimerInActiveList+0x4e> @ imm = #0x12
;                 vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
700a857a: f644 70c0    	movw	r0, #0x4fc0
700a857e: f2c7 0008    	movt	r0, #0x7008
700a8582: 6800         	ldr	r0, [r0]
700a8584: 9905         	ldr	r1, [sp, #0x14]
700a8586: 3104         	adds	r1, #0x4
700a8588: f001 f882    	bl	0x700a9690 <vListInsert> @ imm = #0x1104
700a858c: e7ff         	b	0x700a858e <prvInsertTimerInActiveList+0x4e> @ imm = #-0x2
;         }
700a858e: e017         	b	0x700a85c0 <prvInsertTimerInActiveList+0x80> @ imm = #0x2e
;             if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
700a8590: 9803         	ldr	r0, [sp, #0xc]
700a8592: 9902         	ldr	r1, [sp, #0x8]
700a8594: 4288         	cmp	r0, r1
700a8596: d208         	bhs	0x700a85aa <prvInsertTimerInActiveList+0x6a> @ imm = #0x10
700a8598: e7ff         	b	0x700a859a <prvInsertTimerInActiveList+0x5a> @ imm = #-0x2
700a859a: 9804         	ldr	r0, [sp, #0x10]
700a859c: 9902         	ldr	r1, [sp, #0x8]
700a859e: 4288         	cmp	r0, r1
700a85a0: d303         	blo	0x700a85aa <prvInsertTimerInActiveList+0x6a> @ imm = #0x6
700a85a2: e7ff         	b	0x700a85a4 <prvInsertTimerInActiveList+0x64> @ imm = #-0x2
700a85a4: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700a85a6: 9001         	str	r0, [sp, #0x4]
;             }
700a85a8: e009         	b	0x700a85be <prvInsertTimerInActiveList+0x7e> @ imm = #0x12
;                 vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700a85aa: f644 70b4    	movw	r0, #0x4fb4
700a85ae: f2c7 0008    	movt	r0, #0x7008
700a85b2: 6800         	ldr	r0, [r0]
700a85b4: 9905         	ldr	r1, [sp, #0x14]
700a85b6: 3104         	adds	r1, #0x4
700a85b8: f001 f86a    	bl	0x700a9690 <vListInsert> @ imm = #0x10d4
700a85bc: e7ff         	b	0x700a85be <prvInsertTimerInActiveList+0x7e> @ imm = #-0x2
700a85be: e7ff         	b	0x700a85c0 <prvInsertTimerInActiveList+0x80> @ imm = #-0x2
;         return xProcessTimerNow;
700a85c0: 9801         	ldr	r0, [sp, #0x4]
700a85c2: b006         	add	sp, #0x18
700a85c4: bd80         	pop	{r7, pc}
		...
700a85ce: 0000         	movs	r0, r0

700a85d0 <prvProcessTimerOrBlockTask>:
;     {
700a85d0: b580         	push	{r7, lr}
700a85d2: b084         	sub	sp, #0x10
700a85d4: 9003         	str	r0, [sp, #0xc]
700a85d6: 9102         	str	r1, [sp, #0x8]
;         vTaskSuspendAll();
700a85d8: f005 f852    	bl	0x700ad680 <vTaskSuspendAll> @ imm = #0x50a4
700a85dc: 4668         	mov	r0, sp
;             xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700a85de: f003 f89f    	bl	0x700ab720 <prvSampleTimeNow> @ imm = #0x313e
700a85e2: 9001         	str	r0, [sp, #0x4]
;             if( xTimerListsWereSwitched == pdFALSE )
700a85e4: 9800         	ldr	r0, [sp]
700a85e6: bb88         	cbnz	r0, 0x700a864c <prvProcessTimerOrBlockTask+0x7c> @ imm = #0x62
700a85e8: e7ff         	b	0x700a85ea <prvProcessTimerOrBlockTask+0x1a> @ imm = #-0x2
;                 if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
700a85ea: 9802         	ldr	r0, [sp, #0x8]
700a85ec: b960         	cbnz	r0, 0x700a8608 <prvProcessTimerOrBlockTask+0x38> @ imm = #0x18
700a85ee: e7ff         	b	0x700a85f0 <prvProcessTimerOrBlockTask+0x20> @ imm = #-0x2
700a85f0: 9803         	ldr	r0, [sp, #0xc]
700a85f2: 9901         	ldr	r1, [sp, #0x4]
700a85f4: 4288         	cmp	r0, r1
700a85f6: d807         	bhi	0x700a8608 <prvProcessTimerOrBlockTask+0x38> @ imm = #0xe
700a85f8: e7ff         	b	0x700a85fa <prvProcessTimerOrBlockTask+0x2a> @ imm = #-0x2
;                     ( void ) xTaskResumeAll();
700a85fa: f7f8 fa99    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0x7ace
;                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
700a85fe: 9803         	ldr	r0, [sp, #0xc]
700a8600: 9901         	ldr	r1, [sp, #0x4]
700a8602: f000 fd8d    	bl	0x700a9120 <prvProcessExpiredTimer> @ imm = #0xb1a
;                 }
700a8606: e020         	b	0x700a864a <prvProcessTimerOrBlockTask+0x7a> @ imm = #0x40
;                     if( xListWasEmpty != pdFALSE )
700a8608: 9802         	ldr	r0, [sp, #0x8]
700a860a: b158         	cbz	r0, 0x700a8624 <prvProcessTimerOrBlockTask+0x54> @ imm = #0x16
700a860c: e7ff         	b	0x700a860e <prvProcessTimerOrBlockTask+0x3e> @ imm = #-0x2
;                         xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
700a860e: f644 70c0    	movw	r0, #0x4fc0
700a8612: f2c7 0008    	movt	r0, #0x7008
700a8616: 6800         	ldr	r0, [r0]
700a8618: 6800         	ldr	r0, [r0]
700a861a: fab0 f080    	clz	r0, r0
700a861e: 0940         	lsrs	r0, r0, #0x5
700a8620: 9002         	str	r0, [sp, #0x8]
;                     }
700a8622: e7ff         	b	0x700a8624 <prvProcessTimerOrBlockTask+0x54> @ imm = #-0x2
;                     vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
700a8624: f240 2014    	movw	r0, #0x214
700a8628: f2c7 000b    	movt	r0, #0x700b
700a862c: 6800         	ldr	r0, [r0]
700a862e: 9903         	ldr	r1, [sp, #0xc]
700a8630: 9a01         	ldr	r2, [sp, #0x4]
700a8632: 1a89         	subs	r1, r1, r2
700a8634: 9a02         	ldr	r2, [sp, #0x8]
700a8636: f001 fb73    	bl	0x700a9d20 <vQueueWaitForMessageRestricted> @ imm = #0x16e6
;                     if( xTaskResumeAll() == pdFALSE )
700a863a: f7f8 fa79    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0x7b0e
700a863e: b910         	cbnz	r0, 0x700a8646 <prvProcessTimerOrBlockTask+0x76> @ imm = #0x4
700a8640: e7ff         	b	0x700a8642 <prvProcessTimerOrBlockTask+0x72> @ imm = #-0x2
;                         portYIELD_WITHIN_API();
700a8642: df00         	svc	#0x0
;                     }
700a8644: e000         	b	0x700a8648 <prvProcessTimerOrBlockTask+0x78> @ imm = #0x0
700a8646: e7ff         	b	0x700a8648 <prvProcessTimerOrBlockTask+0x78> @ imm = #-0x2
700a8648: e7ff         	b	0x700a864a <prvProcessTimerOrBlockTask+0x7a> @ imm = #-0x2
;             }
700a864a: e002         	b	0x700a8652 <prvProcessTimerOrBlockTask+0x82> @ imm = #0x4
;                 ( void ) xTaskResumeAll();
700a864c: f7f8 fa70    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0x7b20
700a8650: e7ff         	b	0x700a8652 <prvProcessTimerOrBlockTask+0x82> @ imm = #-0x2
;     }
700a8652: b004         	add	sp, #0x10
700a8654: bd80         	pop	{r7, pc}
		...
700a865e: 0000         	movs	r0, r0

700a8660 <CSL_udmapCppi5SetReturnPolicy>:
; {
700a8660: b085         	sub	sp, #0x14
700a8662: f8dd c018    	ldr.w	r12, [sp, #0x18]
700a8666: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a866a: 9004         	str	r0, [sp, #0x10]
700a866c: 9103         	str	r1, [sp, #0xc]
700a866e: 9202         	str	r2, [sp, #0x8]
700a8670: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700a8672: 9803         	ldr	r0, [sp, #0xc]
700a8674: 2803         	cmp	r0, #0x3
700a8676: d108         	bne	0x700a868a <CSL_udmapCppi5SetReturnPolicy+0x2a> @ imm = #0x10
700a8678: e7ff         	b	0x700a867a <CSL_udmapCppi5SetReturnPolicy+0x1a> @ imm = #-0x2
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700a867a: 9905         	ldr	r1, [sp, #0x14]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETQ, retQnum ) ;
700a867c: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700a8680: f361 4010    	bfi	r0, r1, #16, #1
;         ((CSL_UdmapCppi5TRPD *)pDesc)->retInfo =
700a8684: 9904         	ldr	r1, [sp, #0x10]
700a8686: 6088         	str	r0, [r1, #0x8]
;     }
700a8688: e029         	b	0x700a86de <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #0x52
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2;
700a868a: 9804         	ldr	r0, [sp, #0x10]
700a868c: 6880         	ldr	r0, [r0, #0x8]
700a868e: 9000         	str	r0, [sp]
;         if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO )
700a8690: 9803         	ldr	r0, [sp, #0xc]
700a8692: 2802         	cmp	r0, #0x2
700a8694: d105         	bne	0x700a86a2 <CSL_udmapCppi5SetReturnPolicy+0x42> @ imm = #0xa
700a8696: e7ff         	b	0x700a8698 <CSL_udmapCppi5SetReturnPolicy+0x38> @ imm = #-0x2
;             v &= (CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO2_DATA_OFFSET_MASK);
700a8698: 9800         	ldr	r0, [sp]
700a869a: f36f 0011    	bfc	r0, #0, #18
700a869e: 9000         	str	r0, [sp]
;         }
700a86a0: e00b         	b	0x700a86ba <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #0x16
;             v &= CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK;
700a86a2: 9800         	ldr	r0, [sp]
700a86a4: f000 4078    	and	r0, r0, #0xf8000000
700a86a8: 9000         	str	r0, [sp]
;             v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPOLICY, retPolicy );
700a86aa: 9802         	ldr	r0, [sp, #0x8]
700a86ac: f000 0101    	and	r1, r0, #0x1
700a86b0: 9800         	ldr	r0, [sp]
700a86b2: ea40 4081    	orr.w	r0, r0, r1, lsl #18
700a86b6: 9000         	str	r0, [sp]
700a86b8: e7ff         	b	0x700a86ba <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #-0x2
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700a86ba: 9901         	ldr	r1, [sp, #0x4]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700a86bc: 9a05         	ldr	r2, [sp, #0x14]
700a86be: f44f 3080    	mov.w	r0, #0x10000
700a86c2: ea00 4002    	and.w	r0, r0, r2, lsl #16
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700a86c6: f361 4051    	bfi	r0, r1, #17, #1
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETQ, retQnum );
700a86ca: f8bd 1018    	ldrh.w	r1, [sp, #0x18]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700a86ce: 4401         	add	r1, r0
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700a86d0: 9800         	ldr	r0, [sp]
700a86d2: 4308         	orrs	r0, r1
700a86d4: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2 = v;
700a86d6: 9800         	ldr	r0, [sp]
700a86d8: 9904         	ldr	r1, [sp, #0x10]
700a86da: 6088         	str	r0, [r1, #0x8]
700a86dc: e7ff         	b	0x700a86de <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #-0x2
; }
700a86de: b005         	add	sp, #0x14
700a86e0: 4770         	bx	lr
		...
700a86ee: 0000         	movs	r0, r0

700a86f0 <SemaphoreP_pend>:
; {
700a86f0: b580         	push	{r7, lr}
700a86f2: b086         	sub	sp, #0x18
700a86f4: 9005         	str	r0, [sp, #0x14]
700a86f6: 9104         	str	r1, [sp, #0x10]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700a86f8: 9805         	ldr	r0, [sp, #0x14]
700a86fa: 9003         	str	r0, [sp, #0xc]
700a86fc: 2000         	movs	r0, #0x0
;     uint32_t isSemTaken = 0U;
700a86fe: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700a8700: 9803         	ldr	r0, [sp, #0xc]
700a8702: 6d40         	ldr	r0, [r0, #0x54]
700a8704: b180         	cbz	r0, 0x700a8728 <SemaphoreP_pend+0x38> @ imm = #0x20
700a8706: e7ff         	b	0x700a8708 <SemaphoreP_pend+0x18> @ imm = #-0x2
;         if(HwiP_inISR() == 0U )
700a8708: f005 fb62    	bl	0x700addd0 <HwiP_inISR> @ imm = #0x56c4
700a870c: b938         	cbnz	r0, 0x700a871e <SemaphoreP_pend+0x2e> @ imm = #0xe
700a870e: e7ff         	b	0x700a8710 <SemaphoreP_pend+0x20> @ imm = #-0x2
;             isSemTaken =(uint32_t) xSemaphoreTakeRecursive(pSemaphore->semHndl, timeout);
700a8710: 9803         	ldr	r0, [sp, #0xc]
700a8712: 6d00         	ldr	r0, [r0, #0x50]
700a8714: 9904         	ldr	r1, [sp, #0x10]
700a8716: f002 fbcb    	bl	0x700aaeb0 <xQueueTakeMutexRecursive> @ imm = #0x2796
700a871a: 9002         	str	r0, [sp, #0x8]
;         }
700a871c: e003         	b	0x700a8726 <SemaphoreP_pend+0x36> @ imm = #0x6
700a871e: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700a8720: f006 faf6    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x65ec
700a8724: e7ff         	b	0x700a8726 <SemaphoreP_pend+0x36> @ imm = #-0x2
;     }
700a8726: e017         	b	0x700a8758 <SemaphoreP_pend+0x68> @ imm = #0x2e
;         if( HwiP_inISR() != 0U )
700a8728: f005 fb52    	bl	0x700addd0 <HwiP_inISR> @ imm = #0x56a4
700a872c: b160         	cbz	r0, 0x700a8748 <SemaphoreP_pend+0x58> @ imm = #0x18
700a872e: e7ff         	b	0x700a8730 <SemaphoreP_pend+0x40> @ imm = #-0x2
700a8730: 2100         	movs	r1, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700a8732: 9100         	str	r1, [sp]
;             isSemTaken = (uint32_t) xSemaphoreTakeFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700a8734: 9803         	ldr	r0, [sp, #0xc]
700a8736: 6d00         	ldr	r0, [r0, #0x50]
700a8738: 466a         	mov	r2, sp
700a873a: f7fe fdc1    	bl	0x700a72c0 <xQueueReceiveFromISR> @ imm = #-0x147e
700a873e: 9002         	str	r0, [sp, #0x8]
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700a8740: 9800         	ldr	r0, [sp]
700a8742: f004 fcfd    	bl	0x700ad140 <vPortYeildFromISR> @ imm = #0x49fa
;         }
700a8746: e006         	b	0x700a8756 <SemaphoreP_pend+0x66> @ imm = #0xc
;             isSemTaken = (uint32_t) xSemaphoreTake(pSemaphore->semHndl, timeout);
700a8748: 9803         	ldr	r0, [sp, #0xc]
700a874a: 6d00         	ldr	r0, [r0, #0x50]
700a874c: 9904         	ldr	r1, [sp, #0x10]
700a874e: f7f6 fef7    	bl	0x7009f540 <xQueueSemaphoreTake> @ imm = #-0x9212
700a8752: 9002         	str	r0, [sp, #0x8]
700a8754: e7ff         	b	0x700a8756 <SemaphoreP_pend+0x66> @ imm = #-0x2
700a8756: e7ff         	b	0x700a8758 <SemaphoreP_pend+0x68> @ imm = #-0x2
;     if(isSemTaken != 0U)
700a8758: 9802         	ldr	r0, [sp, #0x8]
700a875a: b118         	cbz	r0, 0x700a8764 <SemaphoreP_pend+0x74> @ imm = #0x6
700a875c: e7ff         	b	0x700a875e <SemaphoreP_pend+0x6e> @ imm = #-0x2
700a875e: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a8760: 9001         	str	r0, [sp, #0x4]
;     }
700a8762: e003         	b	0x700a876c <SemaphoreP_pend+0x7c> @ imm = #0x6
700a8764: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700a8768: 9001         	str	r0, [sp, #0x4]
700a876a: e7ff         	b	0x700a876c <SemaphoreP_pend+0x7c> @ imm = #-0x2
;     return status;
700a876c: 9801         	ldr	r0, [sp, #0x4]
700a876e: b006         	add	sp, #0x18
700a8770: bd80         	pop	{r7, pc}
		...
700a877e: 0000         	movs	r0, r0

700a8780 <Udma_chPair>:
; {
700a8780: b580         	push	{r7, lr}
700a8782: b088         	sub	sp, #0x20
700a8784: 9007         	str	r0, [sp, #0x1c]
700a8786: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
700a8788: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700a878a: 9807         	ldr	r0, [sp, #0x1c]
700a878c: 6e80         	ldr	r0, [r0, #0x68]
700a878e: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a8790: 9805         	ldr	r0, [sp, #0x14]
700a8792: 6800         	ldr	r0, [r0]
700a8794: 2801         	cmp	r0, #0x1
700a8796: d107         	bne	0x700a87a8 <Udma_chPair+0x28> @ imm = #0xe
700a8798: e7ff         	b	0x700a879a <Udma_chPair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700a879a: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a879c: 7800         	ldrb	r0, [r0]
700a879e: 0740         	lsls	r0, r0, #0x1d
700a87a0: 2800         	cmp	r0, #0x0
700a87a2: d501         	bpl	0x700a87a8 <Udma_chPair+0x28> @ imm = #0x2
700a87a4: e7ff         	b	0x700a87a6 <Udma_chPair+0x26> @ imm = #-0x2
;     }
700a87a6: e029         	b	0x700a87fc <Udma_chPair+0x7c> @ imm = #0x52
;         rmPairReq.nav_id = drvHandle->devIdPsil;
700a87a8: 9805         	ldr	r0, [sp, #0x14]
700a87aa: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700a87ae: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a87b0: 9807         	ldr	r0, [sp, #0x1c]
700a87b2: 7800         	ldrb	r0, [r0]
700a87b4: 07c0         	lsls	r0, r0, #0x1f
700a87b6: b158         	cbz	r0, 0x700a87d0 <Udma_chPair+0x50> @ imm = #0x16
700a87b8: e7ff         	b	0x700a87ba <Udma_chPair+0x3a> @ imm = #-0x2
;             rmPairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700a87ba: 9807         	ldr	r0, [sp, #0x1c]
700a87bc: 6ec0         	ldr	r0, [r0, #0x6c]
700a87be: 9905         	ldr	r1, [sp, #0x14]
700a87c0: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700a87c4: 4408         	add	r0, r1
700a87c6: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->peerThreadId;
700a87c8: 9807         	ldr	r0, [sp, #0x1c]
700a87ca: 6fc0         	ldr	r0, [r0, #0x7c]
700a87cc: 9004         	str	r0, [sp, #0x10]
;         }
700a87ce: e00a         	b	0x700a87e6 <Udma_chPair+0x66> @ imm = #0x14
;             rmPairReq.src_thread = chHandle->peerThreadId;
700a87d0: 9807         	ldr	r0, [sp, #0x1c]
700a87d2: 6fc0         	ldr	r0, [r0, #0x7c]
700a87d4: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700a87d6: 9807         	ldr	r0, [sp, #0x1c]
700a87d8: 6f00         	ldr	r0, [r0, #0x70]
700a87da: 9905         	ldr	r1, [sp, #0x14]
700a87dc: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a87e0: 4408         	add	r0, r1
700a87e2: 9004         	str	r0, [sp, #0x10]
700a87e4: e7ff         	b	0x700a87e6 <Udma_chPair+0x66> @ imm = #-0x2
700a87e6: 4668         	mov	r0, sp
700a87e8: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilPair(&rmPairReq, UDMA_SCICLIENT_TIMEOUT);
700a87ec: f002 f8f8    	bl	0x700aa9e0 <Sciclient_rmPsilPair> @ imm = #0x21f0
700a87f0: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700a87f2: 9806         	ldr	r0, [sp, #0x18]
700a87f4: b108         	cbz	r0, 0x700a87fa <Udma_chPair+0x7a> @ imm = #0x2
700a87f6: e7ff         	b	0x700a87f8 <Udma_chPair+0x78> @ imm = #-0x2
;         }
700a87f8: e7ff         	b	0x700a87fa <Udma_chPair+0x7a> @ imm = #-0x2
700a87fa: e7ff         	b	0x700a87fc <Udma_chPair+0x7c> @ imm = #-0x2
;     return (retVal);
700a87fc: 9806         	ldr	r0, [sp, #0x18]
700a87fe: b008         	add	sp, #0x20
700a8800: bd80         	pop	{r7, pc}
		...
700a880e: 0000         	movs	r0, r0

700a8810 <Udma_chUnpair>:
; {
700a8810: b580         	push	{r7, lr}
700a8812: b088         	sub	sp, #0x20
700a8814: 9007         	str	r0, [sp, #0x1c]
700a8816: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a8818: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700a881a: 9807         	ldr	r0, [sp, #0x1c]
700a881c: 6e80         	ldr	r0, [r0, #0x68]
700a881e: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a8820: 9805         	ldr	r0, [sp, #0x14]
700a8822: 6800         	ldr	r0, [r0]
700a8824: 2801         	cmp	r0, #0x1
700a8826: d107         	bne	0x700a8838 <Udma_chUnpair+0x28> @ imm = #0xe
700a8828: e7ff         	b	0x700a882a <Udma_chUnpair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700a882a: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700a882c: 7800         	ldrb	r0, [r0]
700a882e: 0740         	lsls	r0, r0, #0x1d
700a8830: 2800         	cmp	r0, #0x0
700a8832: d501         	bpl	0x700a8838 <Udma_chUnpair+0x28> @ imm = #0x2
700a8834: e7ff         	b	0x700a8836 <Udma_chUnpair+0x26> @ imm = #-0x2
;     }
700a8836: e029         	b	0x700a888c <Udma_chUnpair+0x7c> @ imm = #0x52
;         rmUnpairReq.nav_id = drvHandle->devIdPsil;
700a8838: 9805         	ldr	r0, [sp, #0x14]
700a883a: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700a883e: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a8840: 9807         	ldr	r0, [sp, #0x1c]
700a8842: 7800         	ldrb	r0, [r0]
700a8844: 07c0         	lsls	r0, r0, #0x1f
700a8846: b158         	cbz	r0, 0x700a8860 <Udma_chUnpair+0x50> @ imm = #0x16
700a8848: e7ff         	b	0x700a884a <Udma_chUnpair+0x3a> @ imm = #-0x2
;             rmUnpairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700a884a: 9807         	ldr	r0, [sp, #0x1c]
700a884c: 6ec0         	ldr	r0, [r0, #0x6c]
700a884e: 9905         	ldr	r1, [sp, #0x14]
700a8850: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700a8854: 4408         	add	r0, r1
700a8856: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->peerThreadId;
700a8858: 9807         	ldr	r0, [sp, #0x1c]
700a885a: 6fc0         	ldr	r0, [r0, #0x7c]
700a885c: 9004         	str	r0, [sp, #0x10]
;         }
700a885e: e00a         	b	0x700a8876 <Udma_chUnpair+0x66> @ imm = #0x14
;             rmUnpairReq.src_thread = chHandle->peerThreadId;
700a8860: 9807         	ldr	r0, [sp, #0x1c]
700a8862: 6fc0         	ldr	r0, [r0, #0x7c]
700a8864: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700a8866: 9807         	ldr	r0, [sp, #0x1c]
700a8868: 6f00         	ldr	r0, [r0, #0x70]
700a886a: 9905         	ldr	r1, [sp, #0x14]
700a886c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a8870: 4408         	add	r0, r1
700a8872: 9004         	str	r0, [sp, #0x10]
700a8874: e7ff         	b	0x700a8876 <Udma_chUnpair+0x66> @ imm = #-0x2
700a8876: 4668         	mov	r0, sp
700a8878: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilUnpair(&rmUnpairReq, UDMA_SCICLIENT_TIMEOUT);
700a887c: f002 f8e0    	bl	0x700aaa40 <Sciclient_rmPsilUnpair> @ imm = #0x21c0
700a8880: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700a8882: 9806         	ldr	r0, [sp, #0x18]
700a8884: b108         	cbz	r0, 0x700a888a <Udma_chUnpair+0x7a> @ imm = #0x2
700a8886: e7ff         	b	0x700a8888 <Udma_chUnpair+0x78> @ imm = #-0x2
;         }
700a8888: e7ff         	b	0x700a888a <Udma_chUnpair+0x7a> @ imm = #-0x2
700a888a: e7ff         	b	0x700a888c <Udma_chUnpair+0x7c> @ imm = #-0x2
;     return (retVal);
700a888c: 9806         	ldr	r0, [sp, #0x18]
700a888e: b008         	add	sp, #0x20
700a8890: bd80         	pop	{r7, pc}
		...
700a889e: 0000         	movs	r0, r0

700a88a0 <UART_moduleReset>:
; {
700a88a0: b580         	push	{r7, lr}
700a88a2: b088         	sub	sp, #0x20
700a88a4: 9007         	str	r0, [sp, #0x1c]
700a88a6: 2000         	movs	r0, #0x0
;     uint32_t startTicks, elapsedTicks = 0;
700a88a8: 9005         	str	r0, [sp, #0x14]
;     hUartInit = hUart->hUartInit;
700a88aa: 9807         	ldr	r0, [sp, #0x1c]
700a88ac: 6840         	ldr	r0, [r0, #0x4]
700a88ae: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(hUart->baseAddr + UART_SYSC, UART_SYSC_SOFTRESET,
700a88b0: 9807         	ldr	r0, [sp, #0x1c]
700a88b2: 6800         	ldr	r0, [r0]
700a88b4: 3054         	adds	r0, #0x54
700a88b6: 2102         	movs	r1, #0x2
700a88b8: 2301         	movs	r3, #0x1
700a88ba: 461a         	mov	r2, r3
700a88bc: f003 fd38    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x3a70
;     startTicks = hUartInit->clockP_get();
700a88c0: 9804         	ldr	r0, [sp, #0x10]
700a88c2: 6d40         	ldr	r0, [r0, #0x54]
700a88c4: 4780         	blx	r0
700a88c6: 9006         	str	r0, [sp, #0x18]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700a88c8: e7ff         	b	0x700a88ca <UART_moduleReset+0x2a> @ imm = #-0x2
700a88ca: 9807         	ldr	r0, [sp, #0x1c]
700a88cc: 6800         	ldr	r0, [r0]
700a88ce: 3058         	adds	r0, #0x58
700a88d0: 2101         	movs	r1, #0x1
700a88d2: 2200         	movs	r2, #0x0
700a88d4: 9202         	str	r2, [sp, #0x8]
700a88d6: f004 fb13    	bl	0x700acf00 <HW_RD_FIELD32_RAW> @ imm = #0x4626
700a88da: 4601         	mov	r1, r0
700a88dc: 9802         	ldr	r0, [sp, #0x8]
700a88de: 9003         	str	r0, [sp, #0xc]
700a88e0: b989         	cbnz	r1, 0x700a8906 <UART_moduleReset+0x66> @ imm = #0x22
700a88e2: e7ff         	b	0x700a88e4 <UART_moduleReset+0x44> @ imm = #-0x2
700a88e4: 9805         	ldr	r0, [sp, #0x14]
700a88e6: 9000         	str	r0, [sp]
700a88e8: 9804         	ldr	r0, [sp, #0x10]
700a88ea: 6d82         	ldr	r2, [r0, #0x58]
700a88ec: f44f 70fa    	mov.w	r0, #0x1f4
700a88f0: 2100         	movs	r1, #0x0
700a88f2: 9101         	str	r1, [sp, #0x4]
700a88f4: 4790         	blx	r2
700a88f6: 9900         	ldr	r1, [sp]
700a88f8: 4602         	mov	r2, r0
700a88fa: 9801         	ldr	r0, [sp, #0x4]
700a88fc: 4291         	cmp	r1, r2
700a88fe: bf38         	it	lo
700a8900: 2001         	movlo	r0, #0x1
700a8902: 9003         	str	r0, [sp, #0xc]
700a8904: e7ff         	b	0x700a8906 <UART_moduleReset+0x66> @ imm = #-0x2
700a8906: 9803         	ldr	r0, [sp, #0xc]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700a8908: 07c0         	lsls	r0, r0, #0x1f
700a890a: b138         	cbz	r0, 0x700a891c <UART_moduleReset+0x7c> @ imm = #0xe
700a890c: e7ff         	b	0x700a890e <UART_moduleReset+0x6e> @ imm = #-0x2
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700a890e: 9804         	ldr	r0, [sp, #0x10]
700a8910: 6d40         	ldr	r0, [r0, #0x54]
700a8912: 4780         	blx	r0
700a8914: 9906         	ldr	r1, [sp, #0x18]
700a8916: 1a40         	subs	r0, r0, r1
700a8918: 9005         	str	r0, [sp, #0x14]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700a891a: e7d6         	b	0x700a88ca <UART_moduleReset+0x2a> @ imm = #-0x54
; }
700a891c: b008         	add	sp, #0x20
700a891e: bd80         	pop	{r7, pc}

700a8920 <CSL_bcdmaChanOpIsChanEnabled>:
; {
700a8920: b580         	push	{r7, lr}
700a8922: b086         	sub	sp, #0x18
700a8924: 9005         	str	r0, [sp, #0x14]
700a8926: 9104         	str	r1, [sp, #0x10]
700a8928: 9203         	str	r2, [sp, #0xc]
;     switch( chanType )
700a892a: 9804         	ldr	r0, [sp, #0x10]
700a892c: 9001         	str	r0, [sp, #0x4]
700a892e: b140         	cbz	r0, 0x700a8942 <CSL_bcdmaChanOpIsChanEnabled+0x22> @ imm = #0x10
700a8930: e7ff         	b	0x700a8932 <CSL_bcdmaChanOpIsChanEnabled+0x12> @ imm = #-0x2
700a8932: 9801         	ldr	r0, [sp, #0x4]
700a8934: 2801         	cmp	r0, #0x1
700a8936: d010         	beq	0x700a895a <CSL_bcdmaChanOpIsChanEnabled+0x3a> @ imm = #0x20
700a8938: e7ff         	b	0x700a893a <CSL_bcdmaChanOpIsChanEnabled+0x1a> @ imm = #-0x2
700a893a: 9801         	ldr	r0, [sp, #0x4]
700a893c: 2802         	cmp	r0, #0x2
700a893e: d018         	beq	0x700a8972 <CSL_bcdmaChanOpIsChanEnabled+0x52> @ imm = #0x30
700a8940: e023         	b	0x700a898a <CSL_bcdmaChanOpIsChanEnabled+0x6a> @ imm = #0x46
;             regVal = CSL_REG32_FEXT( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_EN );
700a8942: 9805         	ldr	r0, [sp, #0x14]
700a8944: 6880         	ldr	r0, [r0, #0x8]
700a8946: 9903         	ldr	r1, [sp, #0xc]
700a8948: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a894c: f04f 4100    	mov.w	r1, #0x80000000
700a8950: 221f         	movs	r2, #0x1f
700a8952: f004 f995    	bl	0x700acc80 <CSL_REG32_FEXT_RAW> @ imm = #0x432a
700a8956: 9002         	str	r0, [sp, #0x8]
;             break;
700a8958: e01a         	b	0x700a8990 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x34
;             regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_EN );
700a895a: 9805         	ldr	r0, [sp, #0x14]
700a895c: 6900         	ldr	r0, [r0, #0x10]
700a895e: 9903         	ldr	r1, [sp, #0xc]
700a8960: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8964: f04f 4100    	mov.w	r1, #0x80000000
700a8968: 221f         	movs	r2, #0x1f
700a896a: f004 f989    	bl	0x700acc80 <CSL_REG32_FEXT_RAW> @ imm = #0x4312
700a896e: 9002         	str	r0, [sp, #0x8]
;             break;
700a8970: e00e         	b	0x700a8990 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x1c
;             regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_EN );
700a8972: 9805         	ldr	r0, [sp, #0x14]
700a8974: 6980         	ldr	r0, [r0, #0x18]
700a8976: 9903         	ldr	r1, [sp, #0xc]
700a8978: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a897c: f04f 4100    	mov.w	r1, #0x80000000
700a8980: 221f         	movs	r2, #0x1f
700a8982: f004 f97d    	bl	0x700acc80 <CSL_REG32_FEXT_RAW> @ imm = #0x42fa
700a8986: 9002         	str	r0, [sp, #0x8]
;             break;
700a8988: e002         	b	0x700a8990 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x4
700a898a: 2000         	movs	r0, #0x0
;             regVal = 0U;
700a898c: 9002         	str	r0, [sp, #0x8]
;             break;
700a898e: e7ff         	b	0x700a8990 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700a8990: 9802         	ldr	r0, [sp, #0x8]
700a8992: 3801         	subs	r0, #0x1
700a8994: fab0 f080    	clz	r0, r0
700a8998: 0940         	lsrs	r0, r0, #0x5
700a899a: b006         	add	sp, #0x18
700a899c: bd80         	pop	{r7, pc}
700a899e: 0000         	movs	r0, r0

700a89a0 <CSL_bcdmaChanOpIsValidChanIdx>:
; {
700a89a0: b084         	sub	sp, #0x10
700a89a2: 9003         	str	r0, [sp, #0xc]
700a89a4: 9102         	str	r1, [sp, #0x8]
700a89a6: 9201         	str	r2, [sp, #0x4]
700a89a8: 2001         	movs	r0, #0x1
;     bool retVal = (bool)true;
700a89aa: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700a89ae: 9802         	ldr	r0, [sp, #0x8]
700a89b0: b958         	cbnz	r0, 0x700a89ca <CSL_bcdmaChanOpIsValidChanIdx+0x2a> @ imm = #0x16
700a89b2: e7ff         	b	0x700a89b4 <CSL_bcdmaChanOpIsValidChanIdx+0x14> @ imm = #-0x2
;         if( chanIdx > pCfg->bcChanCnt )
700a89b4: 9801         	ldr	r0, [sp, #0x4]
700a89b6: 9903         	ldr	r1, [sp, #0xc]
700a89b8: 6a49         	ldr	r1, [r1, #0x24]
700a89ba: 4288         	cmp	r0, r1
700a89bc: d904         	bls	0x700a89c8 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #0x8
700a89be: e7ff         	b	0x700a89c0 <CSL_bcdmaChanOpIsValidChanIdx+0x20> @ imm = #-0x2
700a89c0: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700a89c2: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700a89c6: e7ff         	b	0x700a89c8 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #-0x2
;     }
700a89c8: e023         	b	0x700a8a12 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #0x46
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a89ca: 9802         	ldr	r0, [sp, #0x8]
700a89cc: 2802         	cmp	r0, #0x2
700a89ce: d10b         	bne	0x700a89e8 <CSL_bcdmaChanOpIsValidChanIdx+0x48> @ imm = #0x16
700a89d0: e7ff         	b	0x700a89d2 <CSL_bcdmaChanOpIsValidChanIdx+0x32> @ imm = #-0x2
;         if( chanIdx > pCfg->splitRxChanCnt )
700a89d2: 9801         	ldr	r0, [sp, #0x4]
700a89d4: 9903         	ldr	r1, [sp, #0xc]
700a89d6: 6a89         	ldr	r1, [r1, #0x28]
700a89d8: 4288         	cmp	r0, r1
700a89da: d904         	bls	0x700a89e6 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #0x8
700a89dc: e7ff         	b	0x700a89de <CSL_bcdmaChanOpIsValidChanIdx+0x3e> @ imm = #-0x2
700a89de: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700a89e0: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700a89e4: e7ff         	b	0x700a89e6 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #-0x2
;     }
700a89e6: e013         	b	0x700a8a10 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #0x26
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700a89e8: 9802         	ldr	r0, [sp, #0x8]
700a89ea: 2801         	cmp	r0, #0x1
700a89ec: d10b         	bne	0x700a8a06 <CSL_bcdmaChanOpIsValidChanIdx+0x66> @ imm = #0x16
700a89ee: e7ff         	b	0x700a89f0 <CSL_bcdmaChanOpIsValidChanIdx+0x50> @ imm = #-0x2
;         if( chanIdx > pCfg->splitTxChanCnt )
700a89f0: 9801         	ldr	r0, [sp, #0x4]
700a89f2: 9903         	ldr	r1, [sp, #0xc]
700a89f4: 6ac9         	ldr	r1, [r1, #0x2c]
700a89f6: 4288         	cmp	r0, r1
700a89f8: d904         	bls	0x700a8a04 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #0x8
700a89fa: e7ff         	b	0x700a89fc <CSL_bcdmaChanOpIsValidChanIdx+0x5c> @ imm = #-0x2
700a89fc: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700a89fe: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700a8a02: e7ff         	b	0x700a8a04 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #-0x2
;     }
700a8a04: e003         	b	0x700a8a0e <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #0x6
700a8a06: 2000         	movs	r0, #0x0
;         retVal = (bool)false;
700a8a08: f88d 0003    	strb.w	r0, [sp, #0x3]
700a8a0c: e7ff         	b	0x700a8a0e <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #-0x2
700a8a0e: e7ff         	b	0x700a8a10 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #-0x2
700a8a10: e7ff         	b	0x700a8a12 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #-0x2
;     return retVal;
700a8a12: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a8a16: f000 0001    	and	r0, r0, #0x1
700a8a1a: b004         	add	sp, #0x10
700a8a1c: 4770         	bx	lr
700a8a1e: 0000         	movs	r0, r0

700a8a20 <CSL_bcdmaMapChanIdx>:
; {
700a8a20: b084         	sub	sp, #0x10
700a8a22: 9003         	str	r0, [sp, #0xc]
700a8a24: 9102         	str	r1, [sp, #0x8]
700a8a26: 9201         	str	r2, [sp, #0x4]
;     if( chanIdx < pCfg->bcChanCnt )
700a8a28: 9802         	ldr	r0, [sp, #0x8]
700a8a2a: 9903         	ldr	r1, [sp, #0xc]
700a8a2c: 6a49         	ldr	r1, [r1, #0x24]
700a8a2e: 4288         	cmp	r0, r1
700a8a30: d206         	bhs	0x700a8a40 <CSL_bcdmaMapChanIdx+0x20> @ imm = #0xc
700a8a32: e7ff         	b	0x700a8a34 <CSL_bcdmaMapChanIdx+0x14> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_BLOCK_COPY;
700a8a34: 9901         	ldr	r1, [sp, #0x4]
700a8a36: 2000         	movs	r0, #0x0
700a8a38: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx;
700a8a3a: 9802         	ldr	r0, [sp, #0x8]
700a8a3c: 9000         	str	r0, [sp]
;     }
700a8a3e: e02b         	b	0x700a8a98 <CSL_bcdmaMapChanIdx+0x78> @ imm = #0x56
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt) )
700a8a40: 9802         	ldr	r0, [sp, #0x8]
700a8a42: 9a03         	ldr	r2, [sp, #0xc]
700a8a44: 6a51         	ldr	r1, [r2, #0x24]
700a8a46: 6ad2         	ldr	r2, [r2, #0x2c]
700a8a48: 4411         	add	r1, r2
700a8a4a: 4288         	cmp	r0, r1
700a8a4c: d209         	bhs	0x700a8a62 <CSL_bcdmaMapChanIdx+0x42> @ imm = #0x12
700a8a4e: e7ff         	b	0x700a8a50 <CSL_bcdmaMapChanIdx+0x30> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_TX;
700a8a50: 9901         	ldr	r1, [sp, #0x4]
700a8a52: 2001         	movs	r0, #0x1
700a8a54: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt;
700a8a56: 9802         	ldr	r0, [sp, #0x8]
700a8a58: 9903         	ldr	r1, [sp, #0xc]
700a8a5a: 6a49         	ldr	r1, [r1, #0x24]
700a8a5c: 1a40         	subs	r0, r0, r1
700a8a5e: 9000         	str	r0, [sp]
;     }
700a8a60: e019         	b	0x700a8a96 <CSL_bcdmaMapChanIdx+0x76> @ imm = #0x32
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt + pCfg->splitRxChanCnt) )
700a8a62: 9802         	ldr	r0, [sp, #0x8]
700a8a64: 9b03         	ldr	r3, [sp, #0xc]
700a8a66: 6a59         	ldr	r1, [r3, #0x24]
700a8a68: 6a9a         	ldr	r2, [r3, #0x28]
700a8a6a: 6adb         	ldr	r3, [r3, #0x2c]
700a8a6c: 4419         	add	r1, r3
700a8a6e: 4411         	add	r1, r2
700a8a70: 4288         	cmp	r0, r1
700a8a72: d20b         	bhs	0x700a8a8c <CSL_bcdmaMapChanIdx+0x6c> @ imm = #0x16
700a8a74: e7ff         	b	0x700a8a76 <CSL_bcdmaMapChanIdx+0x56> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_RX;
700a8a76: 9901         	ldr	r1, [sp, #0x4]
700a8a78: 2002         	movs	r0, #0x2
700a8a7a: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt - pCfg->splitTxChanCnt;
700a8a7c: 9802         	ldr	r0, [sp, #0x8]
700a8a7e: 9903         	ldr	r1, [sp, #0xc]
700a8a80: 6a4a         	ldr	r2, [r1, #0x24]
700a8a82: 6ac9         	ldr	r1, [r1, #0x2c]
700a8a84: 1a80         	subs	r0, r0, r2
700a8a86: 1a40         	subs	r0, r0, r1
700a8a88: 9000         	str	r0, [sp]
;     }
700a8a8a: e003         	b	0x700a8a94 <CSL_bcdmaMapChanIdx+0x74> @ imm = #0x6
700a8a8c: f04f 30ff    	mov.w	r0, #0xffffffff
;         base0chanIdx = CSL_BCDMA_INVALID_CHANNEL_INDEX;
700a8a90: 9000         	str	r0, [sp]
700a8a92: e7ff         	b	0x700a8a94 <CSL_bcdmaMapChanIdx+0x74> @ imm = #-0x2
700a8a94: e7ff         	b	0x700a8a96 <CSL_bcdmaMapChanIdx+0x76> @ imm = #-0x2
700a8a96: e7ff         	b	0x700a8a98 <CSL_bcdmaMapChanIdx+0x78> @ imm = #-0x2
;     return base0chanIdx;
700a8a98: 9800         	ldr	r0, [sp]
700a8a9a: b004         	add	sp, #0x10
700a8a9c: 4770         	bx	lr
700a8a9e: 0000         	movs	r0, r0

700a8aa0 <ClockP_getTimeUsec>:
; {
700a8aa0: b580         	push	{r7, lr}
700a8aa2: b08a         	sub	sp, #0x28
700a8aa4: 2000         	movs	r0, #0x0
;     uint64_t ts = 0U;
700a8aa6: 9009         	str	r0, [sp, #0x24]
700a8aa8: 9008         	str	r0, [sp, #0x20]
;     do {
700a8aaa: e7ff         	b	0x700a8aac <ClockP_getTimeUsec+0xc> @ imm = #-0x2
;         ticks1 = gClockCtrl.ticks;
700a8aac: f644 6098    	movw	r0, #0x4e98
700a8ab0: f2c7 0008    	movt	r0, #0x7008
700a8ab4: 9001         	str	r0, [sp, #0x4]
700a8ab6: 6801         	ldr	r1, [r0]
700a8ab8: 6842         	ldr	r2, [r0, #0x4]
700a8aba: 9205         	str	r2, [sp, #0x14]
700a8abc: 9104         	str	r1, [sp, #0x10]
;         timerCount = ClockP_getTimerCount(gClockCtrl.timerBaseAddr);
700a8abe: 6ac0         	ldr	r0, [r0, #0x2c]
700a8ac0: f004 fd9e    	bl	0x700ad600 <ClockP_getTimerCount> @ imm = #0x4b3c
700a8ac4: 9901         	ldr	r1, [sp, #0x4]
700a8ac6: 9007         	str	r0, [sp, #0x1c]
;         ticks2 = gClockCtrl.ticks;
700a8ac8: 6808         	ldr	r0, [r1]
700a8aca: 6849         	ldr	r1, [r1, #0x4]
700a8acc: 9103         	str	r1, [sp, #0xc]
700a8ace: 9002         	str	r0, [sp, #0x8]
;     } while (ticks1 != ticks2);
700a8ad0: e7ff         	b	0x700a8ad2 <ClockP_getTimeUsec+0x32> @ imm = #-0x2
700a8ad2: 9804         	ldr	r0, [sp, #0x10]
700a8ad4: 9905         	ldr	r1, [sp, #0x14]
700a8ad6: 9a02         	ldr	r2, [sp, #0x8]
700a8ad8: 9b03         	ldr	r3, [sp, #0xc]
700a8ada: 4059         	eors	r1, r3
700a8adc: ea80 0002    	eor.w	r0, r0, r2
700a8ae0: 4308         	orrs	r0, r1
700a8ae2: 2800         	cmp	r0, #0x0
700a8ae4: d1e2         	bne	0x700a8aac <ClockP_getTimeUsec+0xc> @ imm = #-0x3c
700a8ae6: e7ff         	b	0x700a8ae8 <ClockP_getTimeUsec+0x48> @ imm = #-0x2
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700a8ae8: 9a02         	ldr	r2, [sp, #0x8]
700a8aea: 9803         	ldr	r0, [sp, #0xc]
700a8aec: f644 6198    	movw	r1, #0x4e98
700a8af0: f2c7 0108    	movt	r1, #0x7008
700a8af4: 688b         	ldr	r3, [r1, #0x8]
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700a8af6: f8d1 c030    	ldr.w	r12, [r1, #0x30]
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700a8afa: fb00 f103    	mul	r1, r0, r3
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700a8afe: 9807         	ldr	r0, [sp, #0x1c]
700a8b00: eba0 000c    	sub.w	r0, r0, r12
700a8b04: 4358         	muls	r0, r3, r0
700a8b06: ea6f 0c0c    	mvn.w	r12, r12
700a8b0a: fbb0 f0fc    	udiv	r0, r0, r12
;              + (uint64_t) ( /* convert timer count to usecs */
700a8b0e: fbe2 0103    	umlal	r0, r1, r2, r3
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700a8b12: 9109         	str	r1, [sp, #0x24]
700a8b14: 9008         	str	r0, [sp, #0x20]
;     return (ts);
700a8b16: 9808         	ldr	r0, [sp, #0x20]
700a8b18: 9909         	ldr	r1, [sp, #0x24]
700a8b1a: b00a         	add	sp, #0x28
700a8b1c: bd80         	pop	{r7, pc}
700a8b1e: 0000         	movs	r0, r0

700a8b20 <UART_readData>:
; {
700a8b20: b580         	push	{r7, lr}
700a8b22: b086         	sub	sp, #0x18
700a8b24: 9005         	str	r0, [sp, #0x14]
700a8b26: 9104         	str	r1, [sp, #0x10]
700a8b28: 2000         	movs	r0, #0x0
;     uint8_t             readIn = 0;
700a8b2a: f88d 000f    	strb.w	r0, [sp, #0xf]
;     uint32_t             rdSize = size;
700a8b2e: 9804         	ldr	r0, [sp, #0x10]
700a8b30: 9001         	str	r0, [sp, #0x4]
;     readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700a8b32: 9805         	ldr	r0, [sp, #0x14]
700a8b34: 6800         	ldr	r0, [r0]
700a8b36: f10d 010f    	add.w	r1, sp, #0xf
700a8b3a: f001 fb91    	bl	0x700aa260 <UART_getChar> @ imm = #0x1722
700a8b3e: 9002         	str	r0, [sp, #0x8]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700a8b40: e7ff         	b	0x700a8b42 <UART_readData+0x22> @ imm = #-0x2
700a8b42: 9901         	ldr	r1, [sp, #0x4]
700a8b44: 2000         	movs	r0, #0x0
700a8b46: 9000         	str	r0, [sp]
700a8b48: b131         	cbz	r1, 0x700a8b58 <UART_readData+0x38> @ imm = #0xc
700a8b4a: e7ff         	b	0x700a8b4c <UART_readData+0x2c> @ imm = #-0x2
700a8b4c: 9802         	ldr	r0, [sp, #0x8]
700a8b4e: 2800         	cmp	r0, #0x0
700a8b50: bf18         	it	ne
700a8b52: 2001         	movne	r0, #0x1
700a8b54: 9000         	str	r0, [sp]
700a8b56: e7ff         	b	0x700a8b58 <UART_readData+0x38> @ imm = #-0x2
700a8b58: 9800         	ldr	r0, [sp]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700a8b5a: 07c0         	lsls	r0, r0, #0x1f
700a8b5c: b1e0         	cbz	r0, 0x700a8b98 <UART_readData+0x78> @ imm = #0x38
700a8b5e: e7ff         	b	0x700a8b60 <UART_readData+0x40> @ imm = #-0x2
;         *(uint8_t *)hUart->readBuf = readIn;
700a8b60: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a8b64: 9905         	ldr	r1, [sp, #0x14]
700a8b66: 6949         	ldr	r1, [r1, #0x14]
700a8b68: 7008         	strb	r0, [r1]
;         hUart->readBuf = (uint8_t *)hUart->readBuf + 1U;
700a8b6a: 9905         	ldr	r1, [sp, #0x14]
700a8b6c: 6948         	ldr	r0, [r1, #0x14]
700a8b6e: 3001         	adds	r0, #0x1
700a8b70: 6148         	str	r0, [r1, #0x14]
;         hUart->readCount++;
700a8b72: 9905         	ldr	r1, [sp, #0x14]
700a8b74: 6988         	ldr	r0, [r1, #0x18]
700a8b76: 3001         	adds	r0, #0x1
700a8b78: 6188         	str	r0, [r1, #0x18]
;         rdSize--;
700a8b7a: 9801         	ldr	r0, [sp, #0x4]
700a8b7c: 3801         	subs	r0, #0x1
700a8b7e: 9001         	str	r0, [sp, #0x4]
;         if (rdSize != 0U)
700a8b80: 9801         	ldr	r0, [sp, #0x4]
700a8b82: b140         	cbz	r0, 0x700a8b96 <UART_readData+0x76> @ imm = #0x10
700a8b84: e7ff         	b	0x700a8b86 <UART_readData+0x66> @ imm = #-0x2
;             readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700a8b86: 9805         	ldr	r0, [sp, #0x14]
700a8b88: 6800         	ldr	r0, [r0]
700a8b8a: f10d 010f    	add.w	r1, sp, #0xf
700a8b8e: f001 fb67    	bl	0x700aa260 <UART_getChar> @ imm = #0x16ce
700a8b92: 9002         	str	r0, [sp, #0x8]
;         }
700a8b94: e7ff         	b	0x700a8b96 <UART_readData+0x76> @ imm = #-0x2
;     while ((rdSize != 0U) && (readSuccess != 0U))
700a8b96: e7d4         	b	0x700a8b42 <UART_readData+0x22> @ imm = #-0x58
;     return (rdSize);
700a8b98: 9801         	ldr	r0, [sp, #0x4]
700a8b9a: b006         	add	sp, #0x18
700a8b9c: bd80         	pop	{r7, pc}
700a8b9e: 0000         	movs	r0, r0

700a8ba0 <_DebugP_assert>:
; {
700a8ba0: b5b0         	push	{r4, r5, r7, lr}
700a8ba2: b08e         	sub	sp, #0x38
700a8ba4: f8dd c048    	ldr.w	r12, [sp, #0x48]
700a8ba8: 900d         	str	r0, [sp, #0x34]
700a8baa: 910c         	str	r1, [sp, #0x30]
700a8bac: 920b         	str	r2, [sp, #0x2c]
700a8bae: 930a         	str	r3, [sp, #0x28]
;     if(expression==0)
700a8bb0: 980d         	ldr	r0, [sp, #0x34]
700a8bb2: bb88         	cbnz	r0, 0x700a8c18 <_DebugP_assert+0x78> @ imm = #0x62
700a8bb4: e7ff         	b	0x700a8bb6 <_DebugP_assert+0x16> @ imm = #-0x2
700a8bb6: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700a8bb8: 9004         	str	r0, [sp, #0x10]
700a8bba: 9009         	str	r0, [sp, #0x24]
;         uint64_t curTime = ClockP_getTimeUsec();
700a8bbc: f7ff ff70    	bl	0x700a8aa0 <ClockP_getTimeUsec> @ imm = #-0x120
700a8bc0: 9107         	str	r1, [sp, #0x1c]
700a8bc2: 9006         	str	r0, [sp, #0x18]
;         DebugP_log("ASSERT: %d.%ds: %s:%s:%d: %s failed !!!\r\n",
700a8bc4: 9806         	ldr	r0, [sp, #0x18]
700a8bc6: 9907         	ldr	r1, [sp, #0x1c]
700a8bc8: f244 2240    	movw	r2, #0x4240
700a8bcc: f2c0 020f    	movt	r2, #0xf
700a8bd0: 2300         	movs	r3, #0x0
700a8bd2: f004 e8f8    	blx	0x700acdc4 <__aeabi_uldivmod> @ imm = #0x41f0
700a8bd6: 4603         	mov	r3, r0
700a8bd8: 9804         	ldr	r0, [sp, #0x10]
700a8bda: 9305         	str	r3, [sp, #0x14]
700a8bdc: 4613         	mov	r3, r2
700a8bde: 9a05         	ldr	r2, [sp, #0x14]
700a8be0: 990c         	ldr	r1, [sp, #0x30]
700a8be2: f8dd e02c    	ldr.w	lr, [sp, #0x2c]
700a8be6: 9c0a         	ldr	r4, [sp, #0x28]
700a8be8: 9d12         	ldr	r5, [sp, #0x48]
700a8bea: 46ec         	mov	r12, sp
700a8bec: f8cc 500c    	str.w	r5, [r12, #0xc]
700a8bf0: f8cc 4008    	str.w	r4, [r12, #0x8]
700a8bf4: f8cc e004    	str.w	lr, [r12, #0x4]
700a8bf8: f8cc 1000    	str.w	r1, [r12]
700a8bfc: f24f 4168    	movw	r1, #0xf468
700a8c00: f2c7 010a    	movt	r1, #0x700a
700a8c04: f7ff f80c    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #-0xfe8
;         (void) HwiP_disable();
700a8c08: f005 ebc2    	blx	0x700ae390 <HwiP_disable> @ imm = #0x5784
;         while(assert_loop!= 0U)
700a8c0c: e7ff         	b	0x700a8c0e <_DebugP_assert+0x6e> @ imm = #-0x2
700a8c0e: 9809         	ldr	r0, [sp, #0x24]
700a8c10: b108         	cbz	r0, 0x700a8c16 <_DebugP_assert+0x76> @ imm = #0x2
700a8c12: e7ff         	b	0x700a8c14 <_DebugP_assert+0x74> @ imm = #-0x2
700a8c14: e7fb         	b	0x700a8c0e <_DebugP_assert+0x6e> @ imm = #-0xa
;     }
700a8c16: e7ff         	b	0x700a8c18 <_DebugP_assert+0x78> @ imm = #-0x2
; }
700a8c18: b00e         	add	sp, #0x38
700a8c1a: bdb0         	pop	{r4, r5, r7, pc}
700a8c1c: 0000         	movs	r0, r0
700a8c1e: 0000         	movs	r0, r0

700a8c20 <prvGetExpectedIdleTime>:
; static TickType_t prvGetExpectedIdleTime(void) {
700a8c20: b083         	sub	sp, #0xc
700a8c22: 2000         	movs	r0, #0x0
;   UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
700a8c24: 9001         	str	r0, [sp, #0x4]
700a8c26: 2001         	movs	r0, #0x1
;     const UBaseType_t uxLeastSignificantBit = (UBaseType_t)0x01;
700a8c28: 9000         	str	r0, [sp]
;     if (uxTopReadyPriority > uxLeastSignificantBit) {
700a8c2a: f240 10f8    	movw	r0, #0x1f8
700a8c2e: f2c7 000b    	movt	r0, #0x700b
700a8c32: 6800         	ldr	r0, [r0]
700a8c34: 2802         	cmp	r0, #0x2
700a8c36: d303         	blo	0x700a8c40 <prvGetExpectedIdleTime+0x20> @ imm = #0x6
700a8c38: e7ff         	b	0x700a8c3a <prvGetExpectedIdleTime+0x1a> @ imm = #-0x2
700a8c3a: 2001         	movs	r0, #0x1
;       uxHigherPriorityReadyTasks = pdTRUE;
700a8c3c: 9001         	str	r0, [sp, #0x4]
;     }
700a8c3e: e7ff         	b	0x700a8c40 <prvGetExpectedIdleTime+0x20> @ imm = #-0x2
;   if (pxCurrentTCB->uxPriority > tskIDLE_PRIORITY) {
700a8c40: f240 10cc    	movw	r0, #0x1cc
700a8c44: f2c7 000b    	movt	r0, #0x700b
700a8c48: 6800         	ldr	r0, [r0]
700a8c4a: 6ac0         	ldr	r0, [r0, #0x2c]
700a8c4c: b118         	cbz	r0, 0x700a8c56 <prvGetExpectedIdleTime+0x36> @ imm = #0x6
700a8c4e: e7ff         	b	0x700a8c50 <prvGetExpectedIdleTime+0x30> @ imm = #-0x2
700a8c50: 2000         	movs	r0, #0x0
;     xReturn = 0;
700a8c52: 9002         	str	r0, [sp, #0x8]
;   } else if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700a8c54: e01f         	b	0x700a8c96 <prvGetExpectedIdleTime+0x76> @ imm = #0x3e
700a8c56: f244 40f8    	movw	r0, #0x44f8
700a8c5a: f2c7 0008    	movt	r0, #0x7008
700a8c5e: 6800         	ldr	r0, [r0]
700a8c60: 2802         	cmp	r0, #0x2
700a8c62: d303         	blo	0x700a8c6c <prvGetExpectedIdleTime+0x4c> @ imm = #0x6
700a8c64: e7ff         	b	0x700a8c66 <prvGetExpectedIdleTime+0x46> @ imm = #-0x2
700a8c66: 2000         	movs	r0, #0x0
;     xReturn = 0;
700a8c68: 9002         	str	r0, [sp, #0x8]
;   } else if (uxHigherPriorityReadyTasks != pdFALSE) {
700a8c6a: e013         	b	0x700a8c94 <prvGetExpectedIdleTime+0x74> @ imm = #0x26
700a8c6c: 9801         	ldr	r0, [sp, #0x4]
700a8c6e: b118         	cbz	r0, 0x700a8c78 <prvGetExpectedIdleTime+0x58> @ imm = #0x6
700a8c70: e7ff         	b	0x700a8c72 <prvGetExpectedIdleTime+0x52> @ imm = #-0x2
700a8c72: 2000         	movs	r0, #0x0
;     xReturn = 0;
700a8c74: 9002         	str	r0, [sp, #0x8]
;   } else {
700a8c76: e00c         	b	0x700a8c92 <prvGetExpectedIdleTime+0x72> @ imm = #0x18
;     xReturn = xNextTaskUnblockTime - xTickCount;
700a8c78: f240 2000    	movw	r0, #0x200
700a8c7c: f2c7 000b    	movt	r0, #0x700b
700a8c80: 6800         	ldr	r0, [r0]
700a8c82: f240 2110    	movw	r1, #0x210
700a8c86: f2c7 010b    	movt	r1, #0x700b
700a8c8a: 6809         	ldr	r1, [r1]
700a8c8c: 1a40         	subs	r0, r0, r1
700a8c8e: 9002         	str	r0, [sp, #0x8]
700a8c90: e7ff         	b	0x700a8c92 <prvGetExpectedIdleTime+0x72> @ imm = #-0x2
700a8c92: e7ff         	b	0x700a8c94 <prvGetExpectedIdleTime+0x74> @ imm = #-0x2
700a8c94: e7ff         	b	0x700a8c96 <prvGetExpectedIdleTime+0x76> @ imm = #-0x2
;   return xReturn;
700a8c96: 9802         	ldr	r0, [sp, #0x8]
700a8c98: b003         	add	sp, #0xc
700a8c9a: 4770         	bx	lr
700a8c9c: 0000         	movs	r0, r0
700a8c9e: 0000         	movs	r0, r0

700a8ca0 <UART_Params_init>:
; {
700a8ca0: b082         	sub	sp, #0x8
700a8ca2: 9001         	str	r0, [sp, #0x4]
;     if(prms != NULL)
700a8ca4: 9801         	ldr	r0, [sp, #0x4]
700a8ca6: b3b0         	cbz	r0, 0x700a8d16 <UART_Params_init+0x76> @ imm = #0x6c
700a8ca8: e7ff         	b	0x700a8caa <UART_Params_init+0xa> @ imm = #-0x2
;         prms->baudRate           = 115200U;
700a8caa: 9901         	ldr	r1, [sp, #0x4]
700a8cac: f44f 30e1    	mov.w	r0, #0x1c200
700a8cb0: 6008         	str	r0, [r1]
;         prms->dataLength         = UART_LEN_8;
700a8cb2: 9901         	ldr	r1, [sp, #0x4]
700a8cb4: 2003         	movs	r0, #0x3
700a8cb6: 6048         	str	r0, [r1, #0x4]
;         prms->stopBits           = UART_STOPBITS_1;
700a8cb8: 9901         	ldr	r1, [sp, #0x4]
700a8cba: 2000         	movs	r0, #0x0
700a8cbc: 9000         	str	r0, [sp]
700a8cbe: 6088         	str	r0, [r1, #0x8]
;         prms->parityType         = UART_PARITY_NONE;
700a8cc0: 9901         	ldr	r1, [sp, #0x4]
700a8cc2: 60c8         	str	r0, [r1, #0xc]
;         prms->readMode           = UART_TRANSFER_MODE_BLOCKING;
700a8cc4: 9901         	ldr	r1, [sp, #0x4]
700a8cc6: 6108         	str	r0, [r1, #0x10]
;         prms->readReturnMode     = UART_READ_RETURN_MODE_FULL;
700a8cc8: 9901         	ldr	r1, [sp, #0x4]
700a8cca: 6148         	str	r0, [r1, #0x14]
;         prms->writeMode          = UART_TRANSFER_MODE_BLOCKING;
700a8ccc: 9901         	ldr	r1, [sp, #0x4]
700a8cce: 6188         	str	r0, [r1, #0x18]
;         prms->readCallbackFxn    = NULL;
700a8cd0: 9901         	ldr	r1, [sp, #0x4]
700a8cd2: 61c8         	str	r0, [r1, #0x1c]
;         prms->writeCallbackFxn   = NULL;
700a8cd4: 9901         	ldr	r1, [sp, #0x4]
700a8cd6: 6208         	str	r0, [r1, #0x20]
;         prms->hwFlowControl      = FALSE;
700a8cd8: 9901         	ldr	r1, [sp, #0x4]
700a8cda: 6248         	str	r0, [r1, #0x24]
;         prms->hwFlowControlThr   = UART_RXTRIGLVL_16;
700a8cdc: 9a01         	ldr	r2, [sp, #0x4]
700a8cde: 2110         	movs	r1, #0x10
700a8ce0: 6291         	str	r1, [r2, #0x28]
;         prms->intrNum            = 0xFFFF;
700a8ce2: 9a01         	ldr	r2, [sp, #0x4]
700a8ce4: f64f 71ff    	movw	r1, #0xffff
700a8ce8: 6311         	str	r1, [r2, #0x30]
;         prms->transferMode       = UART_CONFIG_MODE_INTERRUPT;
700a8cea: 9a01         	ldr	r2, [sp, #0x4]
700a8cec: 2101         	movs	r1, #0x1
700a8cee: 62d1         	str	r1, [r2, #0x2c]
;         prms->intrPriority       = 4U;
700a8cf0: 9a01         	ldr	r2, [sp, #0x4]
700a8cf2: 2104         	movs	r1, #0x4
700a8cf4: f882 1034    	strb.w	r1, [r2, #0x34]
;         prms->skipIntrReg        = FALSE;
700a8cf8: 9901         	ldr	r1, [sp, #0x4]
700a8cfa: 6388         	str	r0, [r1, #0x38]
;         prms->uartDmaIndex       = -1;
700a8cfc: 9a01         	ldr	r2, [sp, #0x4]
700a8cfe: f04f 31ff    	mov.w	r1, #0xffffffff
700a8d02: 63d1         	str	r1, [r2, #0x3c]
;         prms->operMode           = UART_OPER_MODE_16X;
700a8d04: 9901         	ldr	r1, [sp, #0x4]
700a8d06: 6408         	str	r0, [r1, #0x40]
;         prms->rxTrigLvl          = UART_RXTRIGLVL_8;
700a8d08: 9901         	ldr	r1, [sp, #0x4]
700a8d0a: 2008         	movs	r0, #0x8
700a8d0c: 6448         	str	r0, [r1, #0x44]
;         prms->txTrigLvl          = UART_TXTRIGLVL_32;
700a8d0e: 9901         	ldr	r1, [sp, #0x4]
700a8d10: 2020         	movs	r0, #0x20
700a8d12: 6488         	str	r0, [r1, #0x48]
;     }
700a8d14: e7ff         	b	0x700a8d16 <UART_Params_init+0x76> @ imm = #-0x2
; }
700a8d16: b002         	add	sp, #0x8
700a8d18: 4770         	bx	lr
700a8d1a: 0000         	movs	r0, r0
700a8d1c: 0000         	movs	r0, r0
700a8d1e: 0000         	movs	r0, r0

700a8d20 <xTimerCreateTimerTask>:
;     {
700a8d20: b580         	push	{r7, lr}
700a8d22: b088         	sub	sp, #0x20
700a8d24: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700a8d26: 9007         	str	r0, [sp, #0x1c]
;         prvCheckForValidListAndQueue();
700a8d28: f7fd fe12    	bl	0x700a6950 <prvCheckForValidListAndQueue> @ imm = #-0x23dc
;         if( xTimerQueue != NULL )
700a8d2c: f240 2014    	movw	r0, #0x214
700a8d30: f2c7 000b    	movt	r0, #0x700b
700a8d34: 6800         	ldr	r0, [r0]
700a8d36: b358         	cbz	r0, 0x700a8d90 <xTimerCreateTimerTask+0x70> @ imm = #0x56
700a8d38: e7ff         	b	0x700a8d3a <xTimerCreateTimerTask+0x1a> @ imm = #-0x2
700a8d3a: 2000         	movs	r0, #0x0
;                     StaticTask_t * pxTimerTaskTCBBuffer = NULL;
700a8d3c: 9003         	str	r0, [sp, #0xc]
700a8d3e: 9006         	str	r0, [sp, #0x18]
;                     StackType_t * pxTimerTaskStackBuffer = NULL;
700a8d40: 9005         	str	r0, [sp, #0x14]
700a8d42: a806         	add	r0, sp, #0x18
700a8d44: a905         	add	r1, sp, #0x14
700a8d46: aa04         	add	r2, sp, #0x10
;                     vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
700a8d48: f003 fdba    	bl	0x700ac8c0 <vApplicationGetTimerTaskMemory> @ imm = #0x3b74
700a8d4c: 9b03         	ldr	r3, [sp, #0xc]
;                                                           ulTimerTaskStackSize,
700a8d4e: 9a04         	ldr	r2, [sp, #0x10]
;                                                           pxTimerTaskStackBuffer,
700a8d50: 9805         	ldr	r0, [sp, #0x14]
;                                                           pxTimerTaskTCBBuffer );
700a8d52: f8dd c018    	ldr.w	r12, [sp, #0x18]
;                     xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
700a8d56: 4669         	mov	r1, sp
700a8d58: f8c1 c008    	str.w	r12, [r1, #0x8]
700a8d5c: 6048         	str	r0, [r1, #0x4]
700a8d5e: 201f         	movs	r0, #0x1f
700a8d60: 6008         	str	r0, [r1]
700a8d62: f24d 0081    	movw	r0, #0xd081
700a8d66: f2c7 000a    	movt	r0, #0x700a
700a8d6a: f64f 513e    	movw	r1, #0xfd3e
700a8d6e: f2c7 010a    	movt	r1, #0x700a
700a8d72: f000 fa55    	bl	0x700a9220 <xTaskCreateStatic> @ imm = #0x4aa
700a8d76: 4601         	mov	r1, r0
700a8d78: f240 2018    	movw	r0, #0x218
700a8d7c: f2c7 000b    	movt	r0, #0x700b
700a8d80: 6001         	str	r1, [r0]
;                     if( xTimerTaskHandle != NULL )
700a8d82: 6800         	ldr	r0, [r0]
700a8d84: b118         	cbz	r0, 0x700a8d8e <xTimerCreateTimerTask+0x6e> @ imm = #0x6
700a8d86: e7ff         	b	0x700a8d88 <xTimerCreateTimerTask+0x68> @ imm = #-0x2
700a8d88: 2001         	movs	r0, #0x1
;                         xReturn = pdPASS;
700a8d8a: 9007         	str	r0, [sp, #0x1c]
;                     }
700a8d8c: e7ff         	b	0x700a8d8e <xTimerCreateTimerTask+0x6e> @ imm = #-0x2
;         }
700a8d8e: e000         	b	0x700a8d92 <xTimerCreateTimerTask+0x72> @ imm = #0x0
700a8d90: e7ff         	b	0x700a8d92 <xTimerCreateTimerTask+0x72> @ imm = #-0x2
;         return xReturn;
700a8d92: 9807         	ldr	r0, [sp, #0x1c]
700a8d94: b008         	add	sp, #0x20
700a8d96: bd80         	pop	{r7, pc}
		...

700a8da0 <CSL_bcdmaChanOpClearError>:
; {
700a8da0: b580         	push	{r7, lr}
700a8da2: b086         	sub	sp, #0x18
700a8da4: 9005         	str	r0, [sp, #0x14]
700a8da6: 9104         	str	r1, [sp, #0x10]
700a8da8: 9203         	str	r2, [sp, #0xc]
700a8daa: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a8dac: 9002         	str	r0, [sp, #0x8]
;     switch( chanType )
700a8dae: 9804         	ldr	r0, [sp, #0x10]
700a8db0: 9001         	str	r0, [sp, #0x4]
700a8db2: b140         	cbz	r0, 0x700a8dc6 <CSL_bcdmaChanOpClearError+0x26> @ imm = #0x10
700a8db4: e7ff         	b	0x700a8db6 <CSL_bcdmaChanOpClearError+0x16> @ imm = #-0x2
700a8db6: 9801         	ldr	r0, [sp, #0x4]
700a8db8: 2801         	cmp	r0, #0x1
700a8dba: d00f         	beq	0x700a8ddc <CSL_bcdmaChanOpClearError+0x3c> @ imm = #0x1e
700a8dbc: e7ff         	b	0x700a8dbe <CSL_bcdmaChanOpClearError+0x1e> @ imm = #-0x2
700a8dbe: 9801         	ldr	r0, [sp, #0x4]
700a8dc0: 2802         	cmp	r0, #0x2
700a8dc2: d016         	beq	0x700a8df2 <CSL_bcdmaChanOpClearError+0x52> @ imm = #0x2c
700a8dc4: e020         	b	0x700a8e08 <CSL_bcdmaChanOpClearError+0x68> @ imm = #0x40
;             CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700a8dc6: 9805         	ldr	r0, [sp, #0x14]
700a8dc8: 6880         	ldr	r0, [r0, #0x8]
700a8dca: 9903         	ldr	r1, [sp, #0xc]
700a8dcc: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8dd0: 2101         	movs	r1, #0x1
700a8dd2: 2300         	movs	r3, #0x0
700a8dd4: 461a         	mov	r2, r3
700a8dd6: f003 f8d3    	bl	0x700abf80 <CSL_REG32_FINS_RAW> @ imm = #0x31a6
;             break;
700a8dda: e019         	b	0x700a8e10 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x32
;             CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700a8ddc: 9805         	ldr	r0, [sp, #0x14]
700a8dde: 6900         	ldr	r0, [r0, #0x10]
700a8de0: 9903         	ldr	r1, [sp, #0xc]
700a8de2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8de6: 2101         	movs	r1, #0x1
700a8de8: 2300         	movs	r3, #0x0
700a8dea: 461a         	mov	r2, r3
700a8dec: f003 f8c8    	bl	0x700abf80 <CSL_REG32_FINS_RAW> @ imm = #0x3190
;             break;
700a8df0: e00e         	b	0x700a8e10 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x1c
;             CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700a8df2: 9805         	ldr	r0, [sp, #0x14]
700a8df4: 6980         	ldr	r0, [r0, #0x18]
700a8df6: 9903         	ldr	r1, [sp, #0xc]
700a8df8: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8dfc: 2101         	movs	r1, #0x1
700a8dfe: 2300         	movs	r3, #0x0
700a8e00: 461a         	mov	r2, r3
700a8e02: f003 f8bd    	bl	0x700abf80 <CSL_REG32_FINS_RAW> @ imm = #0x317a
;             break;
700a8e06: e003         	b	0x700a8e10 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x6
700a8e08: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700a8e0c: 9002         	str	r0, [sp, #0x8]
;             break;
700a8e0e: e7ff         	b	0x700a8e10 <CSL_bcdmaChanOpClearError+0x70> @ imm = #-0x2
;     return retVal;
700a8e10: 9802         	ldr	r0, [sp, #0x8]
700a8e12: b006         	add	sp, #0x18
700a8e14: bd80         	pop	{r7, pc}
		...
700a8e1e: 0000         	movs	r0, r0

700a8e20 <CSL_bcdmaDoChanOp>:
; {
700a8e20: b580         	push	{r7, lr}
700a8e22: b088         	sub	sp, #0x20
700a8e24: 9007         	str	r0, [sp, #0x1c]
700a8e26: 9106         	str	r1, [sp, #0x18]
700a8e28: 9205         	str	r2, [sp, #0x14]
700a8e2a: 9304         	str	r3, [sp, #0x10]
700a8e2c: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t retVal = CSL_EFAIL;
700a8e30: 9003         	str	r0, [sp, #0xc]
;     if( pCfg == NULL )
700a8e32: 9807         	ldr	r0, [sp, #0x1c]
700a8e34: b920         	cbnz	r0, 0x700a8e40 <CSL_bcdmaDoChanOp+0x20> @ imm = #0x8
700a8e36: e7ff         	b	0x700a8e38 <CSL_bcdmaDoChanOp+0x18> @ imm = #-0x2
700a8e38: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a8e3c: 9003         	str	r0, [sp, #0xc]
;     }
700a8e3e: e027         	b	0x700a8e90 <CSL_bcdmaDoChanOp+0x70> @ imm = #0x4e
;         if( (pCfg->bcChanCnt == (uint32_t)0U) || (pCfg->splitTxChanCnt == (uint32_t)0U) || (pCfg->splitRxChanCnt == (uint32_t)0U) ) {
700a8e40: 9807         	ldr	r0, [sp, #0x1c]
700a8e42: 6a40         	ldr	r0, [r0, #0x24]
700a8e44: b140         	cbz	r0, 0x700a8e58 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x10
700a8e46: e7ff         	b	0x700a8e48 <CSL_bcdmaDoChanOp+0x28> @ imm = #-0x2
700a8e48: 9807         	ldr	r0, [sp, #0x1c]
700a8e4a: 6ac0         	ldr	r0, [r0, #0x2c]
700a8e4c: b120         	cbz	r0, 0x700a8e58 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x8
700a8e4e: e7ff         	b	0x700a8e50 <CSL_bcdmaDoChanOp+0x30> @ imm = #-0x2
700a8e50: 9807         	ldr	r0, [sp, #0x1c]
700a8e52: 6a80         	ldr	r0, [r0, #0x28]
700a8e54: b920         	cbnz	r0, 0x700a8e60 <CSL_bcdmaDoChanOp+0x40> @ imm = #0x8
700a8e56: e7ff         	b	0x700a8e58 <CSL_bcdmaDoChanOp+0x38> @ imm = #-0x2
;             CSL_bcdmaGetCfg( pCfg );
700a8e58: 9807         	ldr	r0, [sp, #0x1c]
700a8e5a: f7ff fa09    	bl	0x700a8270 <CSL_bcdmaGetCfg> @ imm = #-0xbee
;         }
700a8e5e: e7ff         	b	0x700a8e60 <CSL_bcdmaDoChanOp+0x40> @ imm = #-0x2
;         base0chanIdx = CSL_bcdmaMapChanIdx( pCfg, chanIdx, &chanType );
700a8e60: 9807         	ldr	r0, [sp, #0x1c]
700a8e62: 9905         	ldr	r1, [sp, #0x14]
700a8e64: aa01         	add	r2, sp, #0x4
700a8e66: f7ff fddb    	bl	0x700a8a20 <CSL_bcdmaMapChanIdx> @ imm = #-0x44a
700a8e6a: 9002         	str	r0, [sp, #0x8]
;         if( base0chanIdx != CSL_BCDMA_INVALID_CHANNEL_INDEX )
700a8e6c: 9802         	ldr	r0, [sp, #0x8]
700a8e6e: 3001         	adds	r0, #0x1
700a8e70: b168         	cbz	r0, 0x700a8e8e <CSL_bcdmaDoChanOp+0x6e> @ imm = #0x1a
700a8e72: e7ff         	b	0x700a8e74 <CSL_bcdmaDoChanOp+0x54> @ imm = #-0x2
;             retVal = CSL_bcdmaChanOp( pCfg, chanOp, chanType, base0chanIdx, pOpData );
700a8e74: 9807         	ldr	r0, [sp, #0x1c]
700a8e76: 9906         	ldr	r1, [sp, #0x18]
700a8e78: 9a01         	ldr	r2, [sp, #0x4]
700a8e7a: 9b02         	ldr	r3, [sp, #0x8]
700a8e7c: f8dd c010    	ldr.w	r12, [sp, #0x10]
700a8e80: 46ee         	mov	lr, sp
700a8e82: f8ce c000    	str.w	r12, [lr]
700a8e86: f7f6 fd8b    	bl	0x7009f9a0 <CSL_bcdmaChanOp> @ imm = #-0x94ea
700a8e8a: 9003         	str	r0, [sp, #0xc]
;         }
700a8e8c: e7ff         	b	0x700a8e8e <CSL_bcdmaDoChanOp+0x6e> @ imm = #-0x2
700a8e8e: e7ff         	b	0x700a8e90 <CSL_bcdmaDoChanOp+0x70> @ imm = #-0x2
;     return retVal;
700a8e90: 9803         	ldr	r0, [sp, #0xc]
700a8e92: b008         	add	sp, #0x20
700a8e94: bd80         	pop	{r7, pc}
		...
700a8e9e: 0000         	movs	r0, r0

700a8ea0 <Udma_chGetCqRingHandle>:
; {
700a8ea0: b085         	sub	sp, #0x14
700a8ea2: 9004         	str	r0, [sp, #0x10]
700a8ea4: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a8ea6: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     cqRing = (Udma_RingHandle) NULL_PTR;
700a8ea8: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a8eaa: 9804         	ldr	r0, [sp, #0x10]
700a8eac: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a8eae: 9800         	ldr	r0, [sp]
700a8eb0: b150         	cbz	r0, 0x700a8ec8 <Udma_chGetCqRingHandle+0x28> @ imm = #0x14
700a8eb2: e7ff         	b	0x700a8eb4 <Udma_chGetCqRingHandle+0x14> @ imm = #-0x2
700a8eb4: 9800         	ldr	r0, [sp]
700a8eb6: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a8eba: f64a 31cd    	movw	r1, #0xabcd
700a8ebe: f6ca 31dc    	movt	r1, #0xabdc
700a8ec2: 4288         	cmp	r0, r1
700a8ec4: d004         	beq	0x700a8ed0 <Udma_chGetCqRingHandle+0x30> @ imm = #0x8
700a8ec6: e7ff         	b	0x700a8ec8 <Udma_chGetCqRingHandle+0x28> @ imm = #-0x2
700a8ec8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a8ecc: 9003         	str	r0, [sp, #0xc]
;     }
700a8ece: e7ff         	b	0x700a8ed0 <Udma_chGetCqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a8ed0: 9803         	ldr	r0, [sp, #0xc]
700a8ed2: b9a8         	cbnz	r0, 0x700a8f00 <Udma_chGetCqRingHandle+0x60> @ imm = #0x2a
700a8ed4: e7ff         	b	0x700a8ed6 <Udma_chGetCqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a8ed6: 9800         	ldr	r0, [sp]
700a8ed8: 6e80         	ldr	r0, [r0, #0x68]
700a8eda: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a8edc: 9801         	ldr	r0, [sp, #0x4]
700a8ede: b150         	cbz	r0, 0x700a8ef6 <Udma_chGetCqRingHandle+0x56> @ imm = #0x14
700a8ee0: e7ff         	b	0x700a8ee2 <Udma_chGetCqRingHandle+0x42> @ imm = #-0x2
700a8ee2: 9801         	ldr	r0, [sp, #0x4]
700a8ee4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a8ee8: f64a 31cd    	movw	r1, #0xabcd
700a8eec: f6ca 31dc    	movt	r1, #0xabdc
700a8ef0: 4288         	cmp	r0, r1
700a8ef2: d004         	beq	0x700a8efe <Udma_chGetCqRingHandle+0x5e> @ imm = #0x8
700a8ef4: e7ff         	b	0x700a8ef6 <Udma_chGetCqRingHandle+0x56> @ imm = #-0x2
700a8ef6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a8efa: 9003         	str	r0, [sp, #0xc]
;         }
700a8efc: e7ff         	b	0x700a8efe <Udma_chGetCqRingHandle+0x5e> @ imm = #-0x2
;     }
700a8efe: e7ff         	b	0x700a8f00 <Udma_chGetCqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a8f00: 9803         	ldr	r0, [sp, #0xc]
700a8f02: b928         	cbnz	r0, 0x700a8f10 <Udma_chGetCqRingHandle+0x70> @ imm = #0xa
700a8f04: e7ff         	b	0x700a8f06 <Udma_chGetCqRingHandle+0x66> @ imm = #-0x2
;         cqRing = (Udma_RingHandle) chHandleInt->cqRing;
700a8f06: 9800         	ldr	r0, [sp]
700a8f08: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a8f0c: 9002         	str	r0, [sp, #0x8]
;     }
700a8f0e: e7ff         	b	0x700a8f10 <Udma_chGetCqRingHandle+0x70> @ imm = #-0x2
;     return (cqRing);
700a8f10: 9802         	ldr	r0, [sp, #0x8]
700a8f12: b005         	add	sp, #0x14
700a8f14: 4770         	bx	lr
		...
700a8f1e: 0000         	movs	r0, r0

700a8f20 <Udma_chGetFqRingHandle>:
; {
700a8f20: b085         	sub	sp, #0x14
700a8f22: 9004         	str	r0, [sp, #0x10]
700a8f24: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a8f26: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     fqRing = (Udma_RingHandle) NULL_PTR;
700a8f28: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a8f2a: 9804         	ldr	r0, [sp, #0x10]
700a8f2c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a8f2e: 9800         	ldr	r0, [sp]
700a8f30: b150         	cbz	r0, 0x700a8f48 <Udma_chGetFqRingHandle+0x28> @ imm = #0x14
700a8f32: e7ff         	b	0x700a8f34 <Udma_chGetFqRingHandle+0x14> @ imm = #-0x2
700a8f34: 9800         	ldr	r0, [sp]
700a8f36: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a8f3a: f64a 31cd    	movw	r1, #0xabcd
700a8f3e: f6ca 31dc    	movt	r1, #0xabdc
700a8f42: 4288         	cmp	r0, r1
700a8f44: d004         	beq	0x700a8f50 <Udma_chGetFqRingHandle+0x30> @ imm = #0x8
700a8f46: e7ff         	b	0x700a8f48 <Udma_chGetFqRingHandle+0x28> @ imm = #-0x2
700a8f48: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a8f4c: 9003         	str	r0, [sp, #0xc]
;     }
700a8f4e: e7ff         	b	0x700a8f50 <Udma_chGetFqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a8f50: 9803         	ldr	r0, [sp, #0xc]
700a8f52: b9a8         	cbnz	r0, 0x700a8f80 <Udma_chGetFqRingHandle+0x60> @ imm = #0x2a
700a8f54: e7ff         	b	0x700a8f56 <Udma_chGetFqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a8f56: 9800         	ldr	r0, [sp]
700a8f58: 6e80         	ldr	r0, [r0, #0x68]
700a8f5a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a8f5c: 9801         	ldr	r0, [sp, #0x4]
700a8f5e: b150         	cbz	r0, 0x700a8f76 <Udma_chGetFqRingHandle+0x56> @ imm = #0x14
700a8f60: e7ff         	b	0x700a8f62 <Udma_chGetFqRingHandle+0x42> @ imm = #-0x2
700a8f62: 9801         	ldr	r0, [sp, #0x4]
700a8f64: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a8f68: f64a 31cd    	movw	r1, #0xabcd
700a8f6c: f6ca 31dc    	movt	r1, #0xabdc
700a8f70: 4288         	cmp	r0, r1
700a8f72: d004         	beq	0x700a8f7e <Udma_chGetFqRingHandle+0x5e> @ imm = #0x8
700a8f74: e7ff         	b	0x700a8f76 <Udma_chGetFqRingHandle+0x56> @ imm = #-0x2
700a8f76: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a8f7a: 9003         	str	r0, [sp, #0xc]
;         }
700a8f7c: e7ff         	b	0x700a8f7e <Udma_chGetFqRingHandle+0x5e> @ imm = #-0x2
;     }
700a8f7e: e7ff         	b	0x700a8f80 <Udma_chGetFqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a8f80: 9803         	ldr	r0, [sp, #0xc]
700a8f82: b928         	cbnz	r0, 0x700a8f90 <Udma_chGetFqRingHandle+0x70> @ imm = #0xa
700a8f84: e7ff         	b	0x700a8f86 <Udma_chGetFqRingHandle+0x66> @ imm = #-0x2
;         fqRing = (Udma_RingHandle) chHandleInt->fqRing;
700a8f86: 9800         	ldr	r0, [sp]
700a8f88: f8d0 0080    	ldr.w	r0, [r0, #0x80]
700a8f8c: 9002         	str	r0, [sp, #0x8]
;     }
700a8f8e: e7ff         	b	0x700a8f90 <Udma_chGetFqRingHandle+0x70> @ imm = #-0x2
;     return (fqRing);
700a8f90: 9802         	ldr	r0, [sp, #0x8]
700a8f92: b005         	add	sp, #0x14
700a8f94: 4770         	bx	lr
		...
700a8f9e: 0000         	movs	r0, r0

700a8fa0 <ClockP_usleep>:
; {
700a8fa0: b580         	push	{r7, lr}
700a8fa2: b088         	sub	sp, #0x20
700a8fa4: 9007         	str	r0, [sp, #0x1c]
;     curTime = ClockP_getTimeUsec();
700a8fa6: f7ff fd7b    	bl	0x700a8aa0 <ClockP_getTimeUsec> @ imm = #-0x50a
700a8faa: 9105         	str	r1, [sp, #0x14]
700a8fac: 9004         	str	r0, [sp, #0x10]
;     endTime = curTime + usec;
700a8fae: 9904         	ldr	r1, [sp, #0x10]
700a8fb0: 9805         	ldr	r0, [sp, #0x14]
700a8fb2: 9a07         	ldr	r2, [sp, #0x1c]
700a8fb4: 1889         	adds	r1, r1, r2
700a8fb6: f140 0000    	adc	r0, r0, #0x0
700a8fba: 9102         	str	r1, [sp, #0x8]
700a8fbc: 9003         	str	r0, [sp, #0xc]
;     if (usec >= gClockCtrl.usecPerTick) {
700a8fbe: 9807         	ldr	r0, [sp, #0x1c]
700a8fc0: f644 6198    	movw	r1, #0x4e98
700a8fc4: f2c7 0108    	movt	r1, #0x7008
700a8fc8: 6889         	ldr	r1, [r1, #0x8]
700a8fca: 4288         	cmp	r0, r1
700a8fcc: d30d         	blo	0x700a8fea <ClockP_usleep+0x4a> @ imm = #0x1a
700a8fce: e7ff         	b	0x700a8fd0 <ClockP_usleep+0x30> @ imm = #-0x2
;         ticksToSleep = usec / gClockCtrl.usecPerTick;
700a8fd0: 9807         	ldr	r0, [sp, #0x1c]
700a8fd2: f644 6198    	movw	r1, #0x4e98
700a8fd6: f2c7 0108    	movt	r1, #0x7008
700a8fda: 6889         	ldr	r1, [r1, #0x8]
700a8fdc: fbb0 f0f1    	udiv	r0, r0, r1
700a8fe0: 9001         	str	r0, [sp, #0x4]
;         ClockP_sleepTicks(ticksToSleep);
700a8fe2: 9801         	ldr	r0, [sp, #0x4]
700a8fe4: f004 fb14    	bl	0x700ad610 <ClockP_sleepTicks> @ imm = #0x4628
;     }
700a8fe8: e012         	b	0x700a9010 <ClockP_usleep+0x70> @ imm = #0x24
;         curTime = ClockP_getTimeUsec();
700a8fea: f7ff fd59    	bl	0x700a8aa0 <ClockP_getTimeUsec> @ imm = #-0x54e
700a8fee: 9105         	str	r1, [sp, #0x14]
700a8ff0: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700a8ff2: e7ff         	b	0x700a8ff4 <ClockP_usleep+0x54> @ imm = #-0x2
700a8ff4: 9a04         	ldr	r2, [sp, #0x10]
700a8ff6: 9805         	ldr	r0, [sp, #0x14]
700a8ff8: 9b02         	ldr	r3, [sp, #0x8]
700a8ffa: 9903         	ldr	r1, [sp, #0xc]
700a8ffc: 1ad2         	subs	r2, r2, r3
700a8ffe: 4188         	sbcs	r0, r1
700a9000: d205         	bhs	0x700a900e <ClockP_usleep+0x6e> @ imm = #0xa
700a9002: e7ff         	b	0x700a9004 <ClockP_usleep+0x64> @ imm = #-0x2
;             curTime = ClockP_getTimeUsec();
700a9004: f7ff fd4c    	bl	0x700a8aa0 <ClockP_getTimeUsec> @ imm = #-0x568
700a9008: 9105         	str	r1, [sp, #0x14]
700a900a: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700a900c: e7f2         	b	0x700a8ff4 <ClockP_usleep+0x54> @ imm = #-0x1c
700a900e: e7ff         	b	0x700a9010 <ClockP_usleep+0x70> @ imm = #-0x2
; }
700a9010: b008         	add	sp, #0x20
700a9012: bd80         	pop	{r7, pc}
		...

700a9020 <Udma_chEnable>:
; {
700a9020: b580         	push	{r7, lr}
700a9022: b084         	sub	sp, #0x10
700a9024: 9003         	str	r0, [sp, #0xc]
700a9026: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a9028: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a902a: 9803         	ldr	r0, [sp, #0xc]
700a902c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a902e: 9800         	ldr	r0, [sp]
700a9030: b150         	cbz	r0, 0x700a9048 <Udma_chEnable+0x28> @ imm = #0x14
700a9032: e7ff         	b	0x700a9034 <Udma_chEnable+0x14> @ imm = #-0x2
700a9034: 9800         	ldr	r0, [sp]
700a9036: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a903a: f64a 31cd    	movw	r1, #0xabcd
700a903e: f6ca 31dc    	movt	r1, #0xabdc
700a9042: 4288         	cmp	r0, r1
700a9044: d004         	beq	0x700a9050 <Udma_chEnable+0x30> @ imm = #0x8
700a9046: e7ff         	b	0x700a9048 <Udma_chEnable+0x28> @ imm = #-0x2
700a9048: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a904c: 9002         	str	r0, [sp, #0x8]
;     }
700a904e: e7ff         	b	0x700a9050 <Udma_chEnable+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9050: 9802         	ldr	r0, [sp, #0x8]
700a9052: b9a8         	cbnz	r0, 0x700a9080 <Udma_chEnable+0x60> @ imm = #0x2a
700a9054: e7ff         	b	0x700a9056 <Udma_chEnable+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a9056: 9800         	ldr	r0, [sp]
700a9058: 6e80         	ldr	r0, [r0, #0x68]
700a905a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a905c: 9801         	ldr	r0, [sp, #0x4]
700a905e: b150         	cbz	r0, 0x700a9076 <Udma_chEnable+0x56> @ imm = #0x14
700a9060: e7ff         	b	0x700a9062 <Udma_chEnable+0x42> @ imm = #-0x2
700a9062: 9801         	ldr	r0, [sp, #0x4]
700a9064: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a9068: f64a 31cd    	movw	r1, #0xabcd
700a906c: f6ca 31dc    	movt	r1, #0xabdc
700a9070: 4288         	cmp	r0, r1
700a9072: d004         	beq	0x700a907e <Udma_chEnable+0x5e> @ imm = #0x8
700a9074: e7ff         	b	0x700a9076 <Udma_chEnable+0x56> @ imm = #-0x2
700a9076: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a907a: 9002         	str	r0, [sp, #0x8]
;         }
700a907c: e7ff         	b	0x700a907e <Udma_chEnable+0x5e> @ imm = #-0x2
;     }
700a907e: e7ff         	b	0x700a9080 <Udma_chEnable+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9080: 9802         	ldr	r0, [sp, #0x8]
700a9082: b920         	cbnz	r0, 0x700a908e <Udma_chEnable+0x6e> @ imm = #0x8
700a9084: e7ff         	b	0x700a9086 <Udma_chEnable+0x66> @ imm = #-0x2
;         Udma_chEnableLocal(chHandleInt);
700a9086: 9800         	ldr	r0, [sp]
700a9088: f7f6 f812    	bl	0x7009f0b0 <Udma_chEnableLocal> @ imm = #-0x9fdc
;     }
700a908c: e7ff         	b	0x700a908e <Udma_chEnable+0x6e> @ imm = #-0x2
;     return (retVal);
700a908e: 9802         	ldr	r0, [sp, #0x8]
700a9090: b004         	add	sp, #0x10
700a9092: bd80         	pop	{r7, pc}
		...

700a90a0 <CSL_bcdmaChanOpTriggerChan>:
; {
700a90a0: b580         	push	{r7, lr}
700a90a2: b084         	sub	sp, #0x10
700a90a4: 9003         	str	r0, [sp, #0xc]
700a90a6: 9102         	str	r1, [sp, #0x8]
700a90a8: 9201         	str	r2, [sp, #0x4]
700a90aa: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a90ac: 9000         	str	r0, [sp]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700a90ae: 9802         	ldr	r0, [sp, #0x8]
700a90b0: b950         	cbnz	r0, 0x700a90c8 <CSL_bcdmaChanOpTriggerChan+0x28> @ imm = #0x14
700a90b2: e7ff         	b	0x700a90b4 <CSL_bcdmaChanOpTriggerChan+0x14> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_BCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700a90b4: 9803         	ldr	r0, [sp, #0xc]
700a90b6: 6880         	ldr	r0, [r0, #0x8]
700a90b8: 9901         	ldr	r1, [sp, #0x4]
700a90ba: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a90be: 3008         	adds	r0, #0x8
700a90c0: 2101         	movs	r1, #0x1
700a90c2: f004 fa5d    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x44ba
;     }
700a90c6: e021         	b	0x700a910c <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #0x42
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700a90c8: 9802         	ldr	r0, [sp, #0x8]
700a90ca: 2801         	cmp	r0, #0x1
700a90cc: d10a         	bne	0x700a90e4 <CSL_bcdmaChanOpTriggerChan+0x44> @ imm = #0x14
700a90ce: e7ff         	b	0x700a90d0 <CSL_bcdmaChanOpTriggerChan+0x30> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_TXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700a90d0: 9803         	ldr	r0, [sp, #0xc]
700a90d2: 6900         	ldr	r0, [r0, #0x10]
700a90d4: 9901         	ldr	r1, [sp, #0x4]
700a90d6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a90da: 3008         	adds	r0, #0x8
700a90dc: 2101         	movs	r1, #0x1
700a90de: f004 fa4f    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x449e
;     }
700a90e2: e012         	b	0x700a910a <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #0x24
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a90e4: 9802         	ldr	r0, [sp, #0x8]
700a90e6: 2802         	cmp	r0, #0x2
700a90e8: d10a         	bne	0x700a9100 <CSL_bcdmaChanOpTriggerChan+0x60> @ imm = #0x14
700a90ea: e7ff         	b	0x700a90ec <CSL_bcdmaChanOpTriggerChan+0x4c> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_RXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700a90ec: 9803         	ldr	r0, [sp, #0xc]
700a90ee: 6980         	ldr	r0, [r0, #0x18]
700a90f0: 9901         	ldr	r1, [sp, #0x4]
700a90f2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a90f6: 3008         	adds	r0, #0x8
700a90f8: 2101         	movs	r1, #0x1
700a90fa: f004 fa41    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x4482
;     }
700a90fe: e003         	b	0x700a9108 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #0x6
700a9100: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a9104: 9000         	str	r0, [sp]
700a9106: e7ff         	b	0x700a9108 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #-0x2
700a9108: e7ff         	b	0x700a910a <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #-0x2
700a910a: e7ff         	b	0x700a910c <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #-0x2
;     return retVal;
700a910c: 9800         	ldr	r0, [sp]
700a910e: b004         	add	sp, #0x10
700a9110: bd80         	pop	{r7, pc}
		...
700a911e: 0000         	movs	r0, r0

700a9120 <prvProcessExpiredTimer>:
;     {
700a9120: b580         	push	{r7, lr}
700a9122: b086         	sub	sp, #0x18
700a9124: 9005         	str	r0, [sp, #0x14]
700a9126: 9104         	str	r1, [sp, #0x10]
;         Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700a9128: f644 70b4    	movw	r0, #0x4fb4
700a912c: f2c7 0008    	movt	r0, #0x7008
700a9130: 6800         	ldr	r0, [r0]
700a9132: 68c0         	ldr	r0, [r0, #0xc]
700a9134: 68c0         	ldr	r0, [r0, #0xc]
700a9136: 9002         	str	r0, [sp, #0x8]
;         ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a9138: 9802         	ldr	r0, [sp, #0x8]
700a913a: 3004         	adds	r0, #0x4
700a913c: f002 f990    	bl	0x700ab460 <uxListRemove> @ imm = #0x2320
;         if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a9140: 9802         	ldr	r0, [sp, #0x8]
700a9142: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a9146: 0740         	lsls	r0, r0, #0x1d
700a9148: 2800         	cmp	r0, #0x0
700a914a: d515         	bpl	0x700a9178 <prvProcessExpiredTimer+0x58> @ imm = #0x2a
700a914c: e7ff         	b	0x700a914e <prvProcessExpiredTimer+0x2e> @ imm = #-0x2
;             if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
700a914e: 9802         	ldr	r0, [sp, #0x8]
700a9150: 9b05         	ldr	r3, [sp, #0x14]
700a9152: 6981         	ldr	r1, [r0, #0x18]
700a9154: 4419         	add	r1, r3
700a9156: 9a04         	ldr	r2, [sp, #0x10]
700a9158: f7ff f9f2    	bl	0x700a8540 <prvInsertTimerInActiveList> @ imm = #-0xc1c
700a915c: b150         	cbz	r0, 0x700a9174 <prvProcessExpiredTimer+0x54> @ imm = #0x14
700a915e: e7ff         	b	0x700a9160 <prvProcessExpiredTimer+0x40> @ imm = #-0x2
;                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700a9160: 9802         	ldr	r0, [sp, #0x8]
700a9162: 9a05         	ldr	r2, [sp, #0x14]
700a9164: 4669         	mov	r1, sp
700a9166: 2300         	movs	r3, #0x0
700a9168: 600b         	str	r3, [r1]
700a916a: 4619         	mov	r1, r3
700a916c: f7fe fc68    	bl	0x700a7a40 <xTimerGenericCommand> @ imm = #-0x1730
700a9170: 9003         	str	r0, [sp, #0xc]
;             }
700a9172: e000         	b	0x700a9176 <prvProcessExpiredTimer+0x56> @ imm = #0x0
700a9174: e7ff         	b	0x700a9176 <prvProcessExpiredTimer+0x56> @ imm = #-0x2
;         }
700a9176: e007         	b	0x700a9188 <prvProcessExpiredTimer+0x68> @ imm = #0xe
;             pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a9178: 9902         	ldr	r1, [sp, #0x8]
700a917a: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a917e: f000 00fe    	and	r0, r0, #0xfe
700a9182: f881 0028    	strb.w	r0, [r1, #0x28]
700a9186: e7ff         	b	0x700a9188 <prvProcessExpiredTimer+0x68> @ imm = #-0x2
;         pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a9188: 9802         	ldr	r0, [sp, #0x8]
700a918a: 6a01         	ldr	r1, [r0, #0x20]
700a918c: 4788         	blx	r1
;     }
700a918e: b006         	add	sp, #0x18
700a9190: bd80         	pop	{r7, pc}
		...
700a919e: 0000         	movs	r0, r0

700a91a0 <tm_isr_message_handler>:
; {
700a91a0: b5b0         	push	{r4, r5, r7, lr}
700a91a2: b082         	sub	sp, #0x8
;    tm_isr_counter++;
700a91a4: f240 10d4    	movw	r0, #0x1d4
;    message[1] = isr_message_counter;
700a91a8: f240 15c4    	movw	r5, #0x1c4
;    tm_isr_counter++;
700a91ac: f2c7 000b    	movt	r0, #0x700b
;    message[1] = isr_message_counter;
700a91b0: f2c7 050b    	movt	r5, #0x700b
700a91b4: f240 32ea    	movw	r2, #0x3ea
;    message[0] = 1;
700a91b8: f644 74a4    	movw	r4, #0x4fa4
700a91bc: f2c7 0408    	movt	r4, #0x7008
;    tm_isr_counter++;
700a91c0: 6801         	ldr	r1, [r0]
700a91c2: 3101         	adds	r1, #0x1
700a91c4: 6001         	str	r1, [r0]
;    message[1] = isr_message_counter;
700a91c6: 6828         	ldr	r0, [r5]
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a91c8: 6829         	ldr	r1, [r5]
700a91ca: eb01 0181    	add.w	r1, r1, r1, lsl #2
700a91ce: eb02 0141    	add.w	r1, r2, r1, lsl #1
700a91d2: 2201         	movs	r2, #0x1
;       checksum += msg[i];
700a91d4: 1843         	adds	r3, r0, r1
;    message[0] = 1;
700a91d6: e9c4 2000    	strd	r2, r0, [r4]
;       checksum += msg[i];
700a91da: 3301         	adds	r3, #0x1
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a91dc: e9c4 1302    	strd	r1, r3, [r4, #8]
;    tm_pmu_profile_start(pmu_send_names[isr_message_counter]);
700a91e0: f244 7178    	movw	r1, #0x4778
700a91e4: 6828         	ldr	r0, [r5]
700a91e6: f2c7 0108    	movt	r1, #0x7008
700a91ea: eb01 1000    	add.w	r0, r1, r0, lsl #4
;    PMU_profileStart(name);
700a91ee: f7fe f907    	bl	0x700a7400 <PMU_profileStart> @ imm = #-0x1df2
700a91f2: aa01         	add	r2, sp, #0x4
;    status = xQueueSendToBackFromISR(tm_queue_array[queue_id], (const void*) message_ptr, &xHigherPriorityTaskWoken);
700a91f4: 4621         	mov	r1, r4
700a91f6: 2000         	movs	r0, #0x0
700a91f8: 2300         	movs	r3, #0x0
700a91fa: f7fd fb51    	bl	0x700a68a0 <xQueueGenericSendFromISR> @ imm = #-0x295e
;    if (status != pdTRUE)
700a91fe: 2801         	cmp	r0, #0x1
700a9200: d102         	bne	0x700a9208 <tm_isr_message_handler+0x68> @ imm = #0x4
;    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
700a9202: 9801         	ldr	r0, [sp, #0x4]
700a9204: f003 ff9c    	bl	0x700ad140 <vPortYeildFromISR> @ imm = #0x3f38
;    isr_message_counter++; /* Prepare for next iteration */
700a9208: 6828         	ldr	r0, [r5]
700a920a: 3001         	adds	r0, #0x1
700a920c: 6028         	str	r0, [r5]
; }
700a920e: b002         	add	sp, #0x8
700a9210: bdb0         	pop	{r4, r5, r7, pc}
		...
700a921e: 0000         	movs	r0, r0

700a9220 <xTaskCreateStatic>:
;     StaticTask_t *const pxTaskBuffer) {
700a9220: b5b0         	push	{r4, r5, r7, lr}
700a9222: b08a         	sub	sp, #0x28
700a9224: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a9228: f8dd c03c    	ldr.w	r12, [sp, #0x3c]
700a922c: f8dd c038    	ldr.w	r12, [sp, #0x38]
700a9230: 9009         	str	r0, [sp, #0x24]
700a9232: 9108         	str	r1, [sp, #0x20]
700a9234: 9207         	str	r2, [sp, #0x1c]
700a9236: 9306         	str	r3, [sp, #0x18]
;   if ((pxTaskBuffer != NULL) && (puxStackBuffer != NULL)) {
700a9238: 9810         	ldr	r0, [sp, #0x40]
700a923a: b320         	cbz	r0, 0x700a9286 <xTaskCreateStatic+0x66> @ imm = #0x48
700a923c: e7ff         	b	0x700a923e <xTaskCreateStatic+0x1e> @ imm = #-0x2
700a923e: 980f         	ldr	r0, [sp, #0x3c]
700a9240: b308         	cbz	r0, 0x700a9286 <xTaskCreateStatic+0x66> @ imm = #0x42
700a9242: e7ff         	b	0x700a9244 <xTaskCreateStatic+0x24> @ imm = #-0x2
;         pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures
700a9244: 9810         	ldr	r0, [sp, #0x40]
;     pxNewTCB = (TCB_t *)
700a9246: 9005         	str	r0, [sp, #0x14]
;     pxNewTCB->pxStack = (StackType_t *)puxStackBuffer;
700a9248: 980f         	ldr	r0, [sp, #0x3c]
700a924a: 9905         	ldr	r1, [sp, #0x14]
700a924c: 6308         	str	r0, [r1, #0x30]
;       pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
700a924e: 9905         	ldr	r1, [sp, #0x14]
700a9250: 2002         	movs	r0, #0x2
700a9252: f881 0086    	strb.w	r0, [r1, #0x86]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700a9256: 9809         	ldr	r0, [sp, #0x24]
700a9258: 9908         	ldr	r1, [sp, #0x20]
700a925a: 9a07         	ldr	r2, [sp, #0x1c]
700a925c: 9b06         	ldr	r3, [sp, #0x18]
;                          uxPriority, &xReturn, pxNewTCB, NULL);
700a925e: f8dd c038    	ldr.w	r12, [sp, #0x38]
700a9262: 9c05         	ldr	r4, [sp, #0x14]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700a9264: 46ee         	mov	lr, sp
700a9266: 2500         	movs	r5, #0x0
700a9268: f8ce 500c    	str.w	r5, [lr, #0xc]
700a926c: f8ce 4008    	str.w	r4, [lr, #0x8]
700a9270: ac04         	add	r4, sp, #0x10
700a9272: f8ce 4004    	str.w	r4, [lr, #0x4]
700a9276: f8ce c000    	str.w	r12, [lr]
700a927a: f7f9 fcf9    	bl	0x700a2c70 <prvInitialiseNewTask> @ imm = #-0x660e
;     prvAddNewTaskToReadyList(pxNewTCB);
700a927e: 9805         	ldr	r0, [sp, #0x14]
700a9280: f7fa f9de    	bl	0x700a3640 <prvAddNewTaskToReadyList> @ imm = #-0x5c44
;   } else {
700a9284: e002         	b	0x700a928c <xTaskCreateStatic+0x6c> @ imm = #0x4
700a9286: 2000         	movs	r0, #0x0
;     xReturn = NULL;
700a9288: 9004         	str	r0, [sp, #0x10]
700a928a: e7ff         	b	0x700a928c <xTaskCreateStatic+0x6c> @ imm = #-0x2
;   return xReturn;
700a928c: 9804         	ldr	r0, [sp, #0x10]
700a928e: b00a         	add	sp, #0x28
700a9290: bdb0         	pop	{r4, r5, r7, pc}
		...
700a929e: 0000         	movs	r0, r0

700a92a0 <CSL_intaggrClrIntr>:
; {
700a92a0: b580         	push	{r7, lr}
700a92a2: b088         	sub	sp, #0x20
700a92a4: 9007         	str	r0, [sp, #0x1c]
700a92a6: 9106         	str	r1, [sp, #0x18]
700a92a8: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t  retVal = CSL_EFAIL;
700a92ac: 9005         	str	r0, [sp, #0x14]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700a92ae: 9807         	ldr	r0, [sp, #0x1c]
700a92b0: 9906         	ldr	r1, [sp, #0x18]
700a92b2: f002 fcc5    	bl	0x700abc40 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x298a
700a92b6: b340         	cbz	r0, 0x700a930a <CSL_intaggrClrIntr+0x6a> @ imm = #0x50
700a92b8: e7ff         	b	0x700a92ba <CSL_intaggrClrIntr+0x1a> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700a92ba: 9806         	ldr	r0, [sp, #0x18]
700a92bc: 0980         	lsrs	r0, r0, #0x6
700a92be: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700a92c0: 9806         	ldr	r0, [sp, #0x18]
700a92c2: f000 003f    	and	r0, r0, #0x3f
700a92c6: 9000         	str	r0, [sp]
;         regVal = (((uint64_t)1U) << bitNum);
700a92c8: 9b00         	ldr	r3, [sp]
700a92ca: f1a3 0220    	sub.w	r2, r3, #0x20
700a92ce: 2101         	movs	r1, #0x1
700a92d0: fa01 fc02    	lsl.w	r12, r1, r2
700a92d4: f1c3 0020    	rsb.w	r0, r3, #0x20
700a92d8: fa21 f000    	lsr.w	r0, r1, r0
700a92dc: 2a00         	cmp	r2, #0x0
700a92de: bf58         	it	pl
700a92e0: 4660         	movpl	r0, r12
700a92e2: fa01 f103    	lsl.w	r1, r1, r3
700a92e6: 2a00         	cmp	r2, #0x0
700a92e8: bf58         	it	pl
700a92ea: 2100         	movpl	r1, #0x0
700a92ec: 9102         	str	r1, [sp, #0x8]
700a92ee: 9003         	str	r0, [sp, #0xc]
;         CSL_REG64_WR( &pCfg->pIntrRegs->VINT[regNum].STATUS_CLEAR, regVal );
700a92f0: 9807         	ldr	r0, [sp, #0x1c]
700a92f2: 6880         	ldr	r0, [r0, #0x8]
700a92f4: 9901         	ldr	r1, [sp, #0x4]
700a92f6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a92fa: 3018         	adds	r0, #0x18
700a92fc: 9a02         	ldr	r2, [sp, #0x8]
700a92fe: 9b03         	ldr	r3, [sp, #0xc]
700a9300: f003 ffde    	bl	0x700ad2c0 <CSL_REG64_WR_RAW> @ imm = #0x3fbc
700a9304: 2000         	movs	r0, #0x0
;         retVal = CSL_PASS;
700a9306: 9005         	str	r0, [sp, #0x14]
;     }
700a9308: e7ff         	b	0x700a930a <CSL_intaggrClrIntr+0x6a> @ imm = #-0x2
;     return retVal;
700a930a: 9805         	ldr	r0, [sp, #0x14]
700a930c: b008         	add	sp, #0x20
700a930e: bd80         	pop	{r7, pc}

700a9310 <Sciclient_rmGetResourceRange>:
; {
700a9310: b580         	push	{r7, lr}
700a9312: b090         	sub	sp, #0x40
700a9314: 900f         	str	r0, [sp, #0x3c]
700a9316: 910e         	str	r1, [sp, #0x38]
700a9318: 920d         	str	r2, [sp, #0x34]
700a931a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a931c: 900c         	str	r0, [sp, #0x30]
700a931e: f44f 51a8    	mov.w	r1, #0x1500
;     sciReq.messageType    = TISCI_MSG_RM_GET_RESOURCE_RANGE;
700a9322: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a9326: 2102         	movs	r1, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700a9328: 9108         	str	r1, [sp, #0x20]
700a932a: a904         	add	r1, sp, #0x10
;     sciReq.pReqPayload    = (const uint8_t *) &req_copy;
700a932c: 9109         	str	r1, [sp, #0x24]
700a932e: 210c         	movs	r1, #0xc
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700a9330: 910a         	str	r1, [sp, #0x28]
;     sciReq.timeout        = timeout;
700a9332: 990d         	ldr	r1, [sp, #0x34]
700a9334: 910b         	str	r1, [sp, #0x2c]
;     sciResp.flags           = 0;
700a9336: 9001         	str	r0, [sp, #0x4]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700a9338: 980e         	ldr	r0, [sp, #0x38]
700a933a: 9002         	str	r0, [sp, #0x8]
700a933c: 2010         	movs	r0, #0x10
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700a933e: 9003         	str	r0, [sp, #0xc]
;     memcpy(&req_copy, req, sizeof(struct tisci_msg_rm_get_resource_range_req));
700a9340: 9a0f         	ldr	r2, [sp, #0x3c]
700a9342: 6810         	ldr	r0, [r2]
700a9344: 6851         	ldr	r1, [r2, #0x4]
700a9346: 6892         	ldr	r2, [r2, #0x8]
700a9348: 9206         	str	r2, [sp, #0x18]
700a934a: 9105         	str	r1, [sp, #0x14]
700a934c: 9004         	str	r0, [sp, #0x10]
;     if (SystemP_SUCCESS == r)
700a934e: 980c         	ldr	r0, [sp, #0x30]
700a9350: b930         	cbnz	r0, 0x700a9360 <Sciclient_rmGetResourceRange+0x50> @ imm = #0xc
700a9352: e7ff         	b	0x700a9354 <Sciclient_rmGetResourceRange+0x44> @ imm = #-0x2
700a9354: a807         	add	r0, sp, #0x1c
700a9356: a901         	add	r1, sp, #0x4
;         r = Sciclient_service(&sciReq, &sciResp);
700a9358: f7f2 fd92    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xd4dc
700a935c: 900c         	str	r0, [sp, #0x30]
;     }
700a935e: e7ff         	b	0x700a9360 <Sciclient_rmGetResourceRange+0x50> @ imm = #-0x2
;     if ((r != SystemP_SUCCESS) ||
700a9360: 980c         	ldr	r0, [sp, #0x30]
700a9362: b930         	cbnz	r0, 0x700a9372 <Sciclient_rmGetResourceRange+0x62> @ imm = #0xc
700a9364: e7ff         	b	0x700a9366 <Sciclient_rmGetResourceRange+0x56> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700a9366: 9801         	ldr	r0, [sp, #0x4]
700a9368: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700a936c: 2802         	cmp	r0, #0x2
700a936e: d004         	beq	0x700a937a <Sciclient_rmGetResourceRange+0x6a> @ imm = #0x8
700a9370: e7ff         	b	0x700a9372 <Sciclient_rmGetResourceRange+0x62> @ imm = #-0x2
700a9372: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a9376: 900c         	str	r0, [sp, #0x30]
;     }
700a9378: e7ff         	b	0x700a937a <Sciclient_rmGetResourceRange+0x6a> @ imm = #-0x2
;     return r;
700a937a: 980c         	ldr	r0, [sp, #0x30]
700a937c: b010         	add	sp, #0x40
700a937e: bd80         	pop	{r7, pc}

700a9380 <Udma_rmFreeMappedRxCh>:
; {
700a9380: b580         	push	{r7, lr}
700a9382: b088         	sub	sp, #0x20
700a9384: 9007         	str	r0, [sp, #0x1c]
700a9386: 9106         	str	r1, [sp, #0x18]
700a9388: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a938a: 9806         	ldr	r0, [sp, #0x18]
700a938c: f500 70ea    	add.w	r0, r0, #0x1d4
700a9390: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9392: 9806         	ldr	r0, [sp, #0x18]
700a9394: f500 609f    	add.w	r0, r0, #0x4f8
700a9398: f04f 31ff    	mov.w	r1, #0xffffffff
700a939c: f7ff f9a8    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0xcb0
;     i = chNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700a93a0: 9807         	ldr	r0, [sp, #0x1c]
700a93a2: 9900         	ldr	r1, [sp]
700a93a4: 9a05         	ldr	r2, [sp, #0x14]
700a93a6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a93aa: 6e89         	ldr	r1, [r1, #0x68]
700a93ac: 1a40         	subs	r0, r0, r1
700a93ae: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700a93b0: 9804         	ldr	r0, [sp, #0x10]
700a93b2: 0940         	lsrs	r0, r0, #0x5
700a93b4: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700a93b6: 9804         	ldr	r0, [sp, #0x10]
700a93b8: 9903         	ldr	r1, [sp, #0xc]
700a93ba: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a93be: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700a93c0: 9902         	ldr	r1, [sp, #0x8]
700a93c2: 2001         	movs	r0, #0x1
700a93c4: 4088         	lsls	r0, r1
700a93c6: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedRxChFlag[mappedChGrp][offset] |= bitMask;
700a93c8: 9a01         	ldr	r2, [sp, #0x4]
700a93ca: 9806         	ldr	r0, [sp, #0x18]
700a93cc: 9905         	ldr	r1, [sp, #0x14]
700a93ce: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a93d2: 9903         	ldr	r1, [sp, #0xc]
700a93d4: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a93d8: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a93dc: 4310         	orrs	r0, r2
700a93de: f8c1 0334    	str.w	r0, [r1, #0x334]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a93e2: 9806         	ldr	r0, [sp, #0x18]
700a93e4: f500 609f    	add.w	r0, r0, #0x4f8
700a93e8: f000 fcd2    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x9a4
;     return;
700a93ec: b008         	add	sp, #0x20
700a93ee: bd80         	pop	{r7, pc}

700a93f0 <Udma_rmFreeMappedTxCh>:
; {
700a93f0: b580         	push	{r7, lr}
700a93f2: b088         	sub	sp, #0x20
700a93f4: 9007         	str	r0, [sp, #0x1c]
700a93f6: 9106         	str	r1, [sp, #0x18]
700a93f8: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a93fa: 9806         	ldr	r0, [sp, #0x18]
700a93fc: f500 70ea    	add.w	r0, r0, #0x1d4
700a9400: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9402: 9806         	ldr	r0, [sp, #0x18]
700a9404: f500 609f    	add.w	r0, r0, #0x4f8
700a9408: f04f 31ff    	mov.w	r1, #0xffffffff
700a940c: f7ff f970    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0xd20
;     i = chNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700a9410: 9807         	ldr	r0, [sp, #0x1c]
700a9412: 9900         	ldr	r1, [sp]
700a9414: 9a05         	ldr	r2, [sp, #0x14]
700a9416: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a941a: 6c89         	ldr	r1, [r1, #0x48]
700a941c: 1a40         	subs	r0, r0, r1
700a941e: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700a9420: 9804         	ldr	r0, [sp, #0x10]
700a9422: 0940         	lsrs	r0, r0, #0x5
700a9424: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700a9426: 9804         	ldr	r0, [sp, #0x10]
700a9428: 9903         	ldr	r1, [sp, #0xc]
700a942a: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a942e: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700a9430: 9902         	ldr	r1, [sp, #0x8]
700a9432: 2001         	movs	r0, #0x1
700a9434: 4088         	lsls	r0, r1
700a9436: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedTxChFlag[mappedChGrp][offset] |= bitMask;
700a9438: 9a01         	ldr	r2, [sp, #0x4]
700a943a: 9806         	ldr	r0, [sp, #0x18]
700a943c: 9905         	ldr	r1, [sp, #0x14]
700a943e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a9442: 9903         	ldr	r1, [sp, #0xc]
700a9444: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9448: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a944c: 4310         	orrs	r0, r2
700a944e: f8c1 0324    	str.w	r0, [r1, #0x324]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9452: 9806         	ldr	r0, [sp, #0x18]
700a9454: f500 609f    	add.w	r0, r0, #0x4f8
700a9458: f000 fc9a    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x934
;     return;
700a945c: b008         	add	sp, #0x20
700a945e: bd80         	pop	{r7, pc}

700a9460 <main_task>:
; {
700a9460: b086         	sub	sp, #0x18
;    printf("Starting Thread-Metric tests...\r\n");
700a9462: f24f 516b    	movw	r1, #0xf56b
700a9466: 2001         	movs	r0, #0x1
700a9468: f2c7 010a    	movt	r1, #0x700a
700a946c: 2501         	movs	r5, #0x1
700a946e: f7fe fbd7    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #-0x1852
;    test_interrupt_handler = tm_isr_message_handler;
700a9472: f249 10a1    	movw	r0, #0x91a1
700a9476: f240 11d0    	movw	r1, #0x1d0
700a947a: f2c7 000a    	movt	r0, #0x700a
700a947e: ac01         	add	r4, sp, #0x4
700a9480: f2c7 010b    	movt	r1, #0x700b
700a9484: 6008         	str	r0, [r1]
;    HwiP_Params_init(&hwiParams);
700a9486: 4620         	mov	r0, r4
700a9488: f004 fa7a    	bl	0x700ad980 <HwiP_Params_init> @ imm = #0x44f4
;    hwiParams.callback = tm_interrupt_handler; /* Interrupt handler */
700a948c: f24d 5141    	movw	r1, #0xd541
700a9490: 200a         	movs	r0, #0xa
700a9492: f2c7 010a    	movt	r1, #0x700a
;    hwiParams.priority = 1;                    /* Set a valid priority (lower is higher priority) */
700a9496: f8ad 5012    	strh.w	r5, [sp, #0x12]
;    hwiParams.intNum = SOFTWARE_INTERRUPT_ID;  /* Chosen interrupt ID */
700a949a: e9cd 0101    	strd	r0, r1, [sp, #4]
;    if (HwiP_construct(&hwiObj, &hwiParams) != SystemP_SUCCESS)
700a949e: f644 60f8    	movw	r0, #0x4ef8
700a94a2: f2c7 0008    	movt	r0, #0x7008
700a94a6: 4621         	mov	r1, r4
700a94a8: f004 fa82    	bl	0x700ad9b0 <HwiP_construct> @ imm = #0x4504
700a94ac: b148         	cbz	r0, 0x700a94c2 <main_task+0x62> @ imm = #0x12
;       printf("Failed to register interrupt\r\n");
700a94ae: f24f 614e    	movw	r1, #0xf64e
700a94b2: 2001         	movs	r0, #0x1
700a94b4: f2c7 010a    	movt	r1, #0x700a
700a94b8: f7fe fbb2    	bl	0x700a7c20 <_DebugP_logZone> @ imm = #-0x189c
700a94bc: bf00         	nop
700a94be: bf00         	nop
;       while (1)
700a94c0: e7fe         	b	0x700a94c0 <main_task+0x60> @ imm = #-0x4
;    HwiP_enableInt(SOFTWARE_INTERRUPT_ID);
700a94c2: 200a         	movs	r0, #0xa
700a94c4: f004 f9b4    	bl	0x700ad830 <HwiP_enableInt> @ imm = #0x4368
;    HwiP_enable();
700a94c8: f004 ef72    	blx	0x700ae3b0 <HwiP_enable> @ imm = #0x4ee4
;    tm_main_four();
700a94cc: f004 f9a0    	bl	0x700ad810 <tm_main_four> @ imm = #0x4340

700a94d0 <Sciclient_rmIaVintGetInfo>:
; {
700a94d0: b580         	push	{r7, lr}
700a94d2: b084         	sub	sp, #0x10
700a94d4: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a94d8: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a94dc: 9202         	str	r2, [sp, #0x8]
700a94de: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a94e0: 9001         	str	r0, [sp, #0x4]
;     if (n_evts == NULL) {
700a94e2: 9802         	ldr	r0, [sp, #0x8]
700a94e4: b920         	cbnz	r0, 0x700a94f0 <Sciclient_rmIaVintGetInfo+0x20> @ imm = #0x8
700a94e6: e7ff         	b	0x700a94e8 <Sciclient_rmIaVintGetInfo+0x18> @ imm = #-0x2
700a94e8: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a94ec: 9001         	str	r0, [sp, #0x4]
;     } else {
700a94ee: e018         	b	0x700a9522 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #0x30
;         inst = Sciclient_rmIaGetInst(id);
700a94f0: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a94f4: f000 ff74    	bl	0x700aa3e0 <Sciclient_rmIaGetInst> @ imm = #0xee8
700a94f8: 9000         	str	r0, [sp]
;         if (inst == NULL) {
700a94fa: 9800         	ldr	r0, [sp]
700a94fc: b920         	cbnz	r0, 0x700a9508 <Sciclient_rmIaVintGetInfo+0x38> @ imm = #0x8
700a94fe: e7ff         	b	0x700a9500 <Sciclient_rmIaVintGetInfo+0x30> @ imm = #-0x2
700a9500: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a9504: 9001         	str	r0, [sp, #0x4]
;         } else {
700a9506: e00b         	b	0x700a9520 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #0x16
;             if (vint >= inst->n_vint) {
700a9508: f8bd 000c    	ldrh.w	r0, [sp, #0xc]
700a950c: 9900         	ldr	r1, [sp]
700a950e: 8989         	ldrh	r1, [r1, #0xc]
700a9510: 4288         	cmp	r0, r1
700a9512: db04         	blt	0x700a951e <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #0x8
700a9514: e7ff         	b	0x700a9516 <Sciclient_rmIaVintGetInfo+0x46> @ imm = #-0x2
700a9516: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a951a: 9001         	str	r0, [sp, #0x4]
;             }
700a951c: e7ff         	b	0x700a951e <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #-0x2
700a951e: e7ff         	b	0x700a9520 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #-0x2
700a9520: e7ff         	b	0x700a9522 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a9522: 9801         	ldr	r0, [sp, #0x4]
700a9524: b940         	cbnz	r0, 0x700a9538 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #0x10
700a9526: e7ff         	b	0x700a9528 <Sciclient_rmIaVintGetInfo+0x58> @ imm = #-0x2
;         *n_evts = inst->vint_usage_count[vint];
700a9528: 9800         	ldr	r0, [sp]
700a952a: 6900         	ldr	r0, [r0, #0x10]
700a952c: f8bd 100c    	ldrh.w	r1, [sp, #0xc]
700a9530: 5c40         	ldrb	r0, [r0, r1]
700a9532: 9902         	ldr	r1, [sp, #0x8]
700a9534: 7008         	strb	r0, [r1]
;     }
700a9536: e7ff         	b	0x700a9538 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #-0x2
;     return r;
700a9538: 9801         	ldr	r0, [sp, #0x4]
700a953a: b004         	add	sp, #0x10
700a953c: bd80         	pop	{r7, pc}
700a953e: 0000         	movs	r0, r0

700a9540 <SemaphoreP_constructMutex>:
; {
700a9540: b580         	push	{r7, lr}
700a9542: b086         	sub	sp, #0x18
700a9544: 9005         	str	r0, [sp, #0x14]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700a9546: 9805         	ldr	r0, [sp, #0x14]
700a9548: 9004         	str	r0, [sp, #0x10]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700a954a: f24f 3063    	movw	r0, #0xf363
700a954e: f2c7 000a    	movt	r0, #0x700a
700a9552: 4669         	mov	r1, sp
700a9554: 6008         	str	r0, [r1]
700a9556: f24f 51ae    	movw	r1, #0xf5ae
700a955a: f2c7 010a    	movt	r1, #0x700a
700a955e: f24f 7252    	movw	r2, #0xf752
700a9562: f2c7 020a    	movt	r2, #0x700a
700a9566: 2001         	movs	r0, #0x1
700a9568: 9002         	str	r0, [sp, #0x8]
700a956a: 2370         	movs	r3, #0x70
700a956c: f7ff fb18    	bl	0x700a8ba0 <_DebugP_assert> @ imm = #-0x9d0
700a9570: 9802         	ldr	r0, [sp, #0x8]
;     pSemaphore->isRecursiveMutex = 1;
700a9572: 9904         	ldr	r1, [sp, #0x10]
700a9574: 6548         	str	r0, [r1, #0x54]
;     pSemaphore->semHndl = xSemaphoreCreateRecursiveMutexStatic(&pSemaphore->semObj);
700a9576: 9904         	ldr	r1, [sp, #0x10]
700a9578: 2004         	movs	r0, #0x4
700a957a: f002 ff59    	bl	0x700ac430 <xQueueCreateMutexStatic> @ imm = #0x2eb2
700a957e: 9904         	ldr	r1, [sp, #0x10]
700a9580: 6508         	str	r0, [r1, #0x50]
;     if( pSemaphore->semHndl == NULL )
700a9582: 9804         	ldr	r0, [sp, #0x10]
700a9584: 6d00         	ldr	r0, [r0, #0x50]
700a9586: b920         	cbnz	r0, 0x700a9592 <SemaphoreP_constructMutex+0x52> @ imm = #0x8
700a9588: e7ff         	b	0x700a958a <SemaphoreP_constructMutex+0x4a> @ imm = #-0x2
700a958a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a958e: 9003         	str	r0, [sp, #0xc]
;     }
700a9590: e00a         	b	0x700a95a8 <SemaphoreP_constructMutex+0x68> @ imm = #0x14
;         vQueueAddToRegistry(pSemaphore->semHndl, "Mutex (DPL)");
700a9592: 9804         	ldr	r0, [sp, #0x10]
700a9594: 6d00         	ldr	r0, [r0, #0x50]
700a9596: f64f 1176    	movw	r1, #0xf976
700a959a: f2c7 010a    	movt	r1, #0x700a
700a959e: f001 fc57    	bl	0x700aae50 <vQueueAddToRegistry> @ imm = #0x18ae
700a95a2: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a95a4: 9003         	str	r0, [sp, #0xc]
700a95a6: e7ff         	b	0x700a95a8 <SemaphoreP_constructMutex+0x68> @ imm = #-0x2
;     return status;
700a95a8: 9803         	ldr	r0, [sp, #0xc]
700a95aa: b006         	add	sp, #0x18
700a95ac: bd80         	pop	{r7, pc}
700a95ae: 0000         	movs	r0, r0

700a95b0 <UdmaChPrms_init>:
; {
700a95b0: b580         	push	{r7, lr}
700a95b2: b082         	sub	sp, #0x8
700a95b4: 9001         	str	r0, [sp, #0x4]
700a95b6: 9100         	str	r1, [sp]
;     if(NULL_PTR != chPrms)
700a95b8: 9801         	ldr	r0, [sp, #0x4]
700a95ba: b368         	cbz	r0, 0x700a9618 <UdmaChPrms_init+0x68> @ imm = #0x5a
700a95bc: e7ff         	b	0x700a95be <UdmaChPrms_init+0xe> @ imm = #-0x2
;         chPrms->chNum       = UDMA_DMA_CH_ANY;
700a95be: 9901         	ldr	r1, [sp, #0x4]
700a95c0: 2001         	movs	r0, #0x1
700a95c2: f6cf 70ff    	movt	r0, #0xffff
700a95c6: 6008         	str	r0, [r1]
;         chPrms->peerChNum   = UDMA_DMA_CH_INVALID;
700a95c8: 9901         	ldr	r1, [sp, #0x4]
700a95ca: 2000         	movs	r0, #0x0
700a95cc: f6cf 70ff    	movt	r0, #0xffff
700a95d0: 6048         	str	r0, [r1, #0x4]
;         if(UDMA_CH_TYPE_TR_BLK_COPY == chType)
700a95d2: 9800         	ldr	r0, [sp]
700a95d4: 2807         	cmp	r0, #0x7
700a95d6: d106         	bne	0x700a95e6 <UdmaChPrms_init+0x36> @ imm = #0xc
700a95d8: e7ff         	b	0x700a95da <UdmaChPrms_init+0x2a> @ imm = #-0x2
;             chPrms->peerChNum   = UDMA_DMA_CH_NA;
700a95da: 9901         	ldr	r1, [sp, #0x4]
700a95dc: 2002         	movs	r0, #0x2
700a95de: f6cf 70ff    	movt	r0, #0xffff
700a95e2: 6048         	str	r0, [r1, #0x4]
;         }
700a95e4: e7ff         	b	0x700a95e6 <UdmaChPrms_init+0x36> @ imm = #-0x2
;         chPrms->mappedChGrp = UDMA_MAPPED_GROUP_INVALID;
700a95e6: 9901         	ldr	r1, [sp, #0x4]
700a95e8: 2004         	movs	r0, #0x4
700a95ea: f6cf 70ff    	movt	r0, #0xffff
700a95ee: 6088         	str	r0, [r1, #0x8]
;         chPrms->appData     = NULL_PTR;
700a95f0: 9901         	ldr	r1, [sp, #0x4]
700a95f2: 2000         	movs	r0, #0x0
700a95f4: 60c8         	str	r0, [r1, #0xc]
;         UdmaRingPrms_init(&chPrms->fqRingPrms);
700a95f6: 9801         	ldr	r0, [sp, #0x4]
700a95f8: 3010         	adds	r0, #0x10
700a95fa: f001 fb41    	bl	0x700aac80 <UdmaRingPrms_init> @ imm = #0x1682
;         UdmaRingPrms_init(&chPrms->cqRingPrms);
700a95fe: 9801         	ldr	r0, [sp, #0x4]
700a9600: 302c         	adds	r0, #0x2c
700a9602: f001 fb3d    	bl	0x700aac80 <UdmaRingPrms_init> @ imm = #0x167a
;         UdmaRingPrms_init(&chPrms->tdCqRingPrms);
700a9606: 9801         	ldr	r0, [sp, #0x4]
700a9608: 3048         	adds	r0, #0x48
700a960a: f001 fb39    	bl	0x700aac80 <UdmaRingPrms_init> @ imm = #0x1672
;         chPrms->tdCqRingPrms.elemSize = UDMA_RING_ES_8BYTES;
700a960e: 9901         	ldr	r1, [sp, #0x4]
700a9610: 2001         	movs	r0, #0x1
700a9612: f881 0058    	strb.w	r0, [r1, #0x58]
;     }
700a9616: e7ff         	b	0x700a9618 <UdmaChPrms_init+0x68> @ imm = #-0x2
;     return;
700a9618: b002         	add	sp, #0x8
700a961a: bd80         	pop	{r7, pc}
700a961c: 0000         	movs	r0, r0
700a961e: 0000         	movs	r0, r0

700a9620 <Pinmux_lockMMR>:
; {
700a9620: b580         	push	{r7, lr}
700a9622: b084         	sub	sp, #0x10
700a9624: 9003         	str	r0, [sp, #0xc]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a9626: 9803         	ldr	r0, [sp, #0xc]
700a9628: b908         	cbnz	r0, 0x700a962e <Pinmux_lockMMR+0xe> @ imm = #0x2
700a962a: e7ff         	b	0x700a962c <Pinmux_lockMMR+0xc> @ imm = #-0x2
;     }
700a962c: e7ff         	b	0x700a962e <Pinmux_lockMMR+0xe> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700a962e: 9803         	ldr	r0, [sp, #0xc]
700a9630: 2801         	cmp	r0, #0x1
700a9632: d128         	bne	0x700a9686 <Pinmux_lockMMR+0x66> @ imm = #0x50
700a9634: e7ff         	b	0x700a9636 <Pinmux_lockMMR+0x16> @ imm = #-0x2
700a9636: f04f 6081    	mov.w	r0, #0x4080000
700a963a: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700a963c: 9100         	str	r1, [sp]
700a963e: f7fa faff    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x5a02
700a9642: 9900         	ldr	r1, [sp]
700a9644: 9002         	str	r0, [sp, #0x8]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700a9646: 9802         	ldr	r0, [sp, #0x8]
700a9648: f241 0208    	movw	r2, #0x1008
700a964c: 4410         	add	r0, r2
700a964e: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a9650: 9801         	ldr	r0, [sp, #0x4]
700a9652: f003 ffa5    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x3f4a
700a9656: 9900         	ldr	r1, [sp]
;         kickAddr++;
700a9658: 9801         	ldr	r0, [sp, #0x4]
700a965a: 3004         	adds	r0, #0x4
700a965c: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a965e: 9801         	ldr	r0, [sp, #0x4]
700a9660: f003 ff9e    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x3f3c
700a9664: 9900         	ldr	r1, [sp]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700a9666: 9802         	ldr	r0, [sp, #0x8]
700a9668: f245 0208    	movw	r2, #0x5008
700a966c: 4410         	add	r0, r2
700a966e: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700a9670: 9801         	ldr	r0, [sp, #0x4]
700a9672: f003 ff95    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x3f2a
700a9676: 9900         	ldr	r1, [sp]
;         kickAddr++;
700a9678: 9801         	ldr	r0, [sp, #0x4]
700a967a: 3004         	adds	r0, #0x4
700a967c: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700a967e: 9801         	ldr	r0, [sp, #0x4]
700a9680: f003 ff8e    	bl	0x700ad5a0 <CSL_REG32_WR_RAW> @ imm = #0x3f1c
;     }
700a9684: e7ff         	b	0x700a9686 <Pinmux_lockMMR+0x66> @ imm = #-0x2
;     return;
700a9686: b004         	add	sp, #0x10
700a9688: bd80         	pop	{r7, pc}
700a968a: 0000         	movs	r0, r0
700a968c: 0000         	movs	r0, r0
700a968e: 0000         	movs	r0, r0

700a9690 <vListInsert>:
; {
700a9690: b084         	sub	sp, #0x10
700a9692: 9003         	str	r0, [sp, #0xc]
700a9694: 9102         	str	r1, [sp, #0x8]
;     const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
700a9696: 9802         	ldr	r0, [sp, #0x8]
700a9698: 6800         	ldr	r0, [r0]
700a969a: 9000         	str	r0, [sp]
;     if( xValueOfInsertion == portMAX_DELAY )
700a969c: 9800         	ldr	r0, [sp]
700a969e: 3001         	adds	r0, #0x1
700a96a0: b920         	cbnz	r0, 0x700a96ac <vListInsert+0x1c> @ imm = #0x8
700a96a2: e7ff         	b	0x700a96a4 <vListInsert+0x14> @ imm = #-0x2
;         pxIterator = pxList->xListEnd.pxPrevious;
700a96a4: 9803         	ldr	r0, [sp, #0xc]
700a96a6: 6900         	ldr	r0, [r0, #0x10]
700a96a8: 9001         	str	r0, [sp, #0x4]
;     }
700a96aa: e010         	b	0x700a96ce <vListInsert+0x3e> @ imm = #0x20
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700a96ac: 9803         	ldr	r0, [sp, #0xc]
700a96ae: 3008         	adds	r0, #0x8
700a96b0: 9001         	str	r0, [sp, #0x4]
700a96b2: e7ff         	b	0x700a96b4 <vListInsert+0x24> @ imm = #-0x2
700a96b4: 9801         	ldr	r0, [sp, #0x4]
700a96b6: 6840         	ldr	r0, [r0, #0x4]
700a96b8: 6800         	ldr	r0, [r0]
700a96ba: 9900         	ldr	r1, [sp]
700a96bc: 4288         	cmp	r0, r1
700a96be: d805         	bhi	0x700a96cc <vListInsert+0x3c> @ imm = #0xa
700a96c0: e7ff         	b	0x700a96c2 <vListInsert+0x32> @ imm = #-0x2
;         }
700a96c2: e7ff         	b	0x700a96c4 <vListInsert+0x34> @ imm = #-0x2
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700a96c4: 9801         	ldr	r0, [sp, #0x4]
700a96c6: 6840         	ldr	r0, [r0, #0x4]
700a96c8: 9001         	str	r0, [sp, #0x4]
700a96ca: e7f3         	b	0x700a96b4 <vListInsert+0x24> @ imm = #-0x1a
700a96cc: e7ff         	b	0x700a96ce <vListInsert+0x3e> @ imm = #-0x2
;     pxNewListItem->pxNext = pxIterator->pxNext;
700a96ce: 9801         	ldr	r0, [sp, #0x4]
700a96d0: 6840         	ldr	r0, [r0, #0x4]
700a96d2: 9902         	ldr	r1, [sp, #0x8]
700a96d4: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxNext->pxPrevious = pxNewListItem;
700a96d6: 9802         	ldr	r0, [sp, #0x8]
700a96d8: 6841         	ldr	r1, [r0, #0x4]
700a96da: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxPrevious = pxIterator;
700a96dc: 9801         	ldr	r0, [sp, #0x4]
700a96de: 9902         	ldr	r1, [sp, #0x8]
700a96e0: 6088         	str	r0, [r1, #0x8]
;     pxIterator->pxNext = pxNewListItem;
700a96e2: 9802         	ldr	r0, [sp, #0x8]
700a96e4: 9901         	ldr	r1, [sp, #0x4]
700a96e6: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxContainer = pxList;
700a96e8: 9803         	ldr	r0, [sp, #0xc]
700a96ea: 9902         	ldr	r1, [sp, #0x8]
700a96ec: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700a96ee: 9903         	ldr	r1, [sp, #0xc]
700a96f0: 6808         	ldr	r0, [r1]
700a96f2: 3001         	adds	r0, #0x1
700a96f4: 6008         	str	r0, [r1]
; }
700a96f6: b004         	add	sp, #0x10
700a96f8: 4770         	bx	lr
700a96fa: 0000         	movs	r0, r0
700a96fc: 0000         	movs	r0, r0
700a96fe: 0000         	movs	r0, r0

700a9700 <Sciclient_rmIrqCfgIsDirectEvent>:
; {
700a9700: b580         	push	{r7, lr}
700a9702: b082         	sub	sp, #0x8
700a9704: 9001         	str	r0, [sp, #0x4]
700a9706: 2000         	movs	r0, #0x0
;     bool r = false;
700a9708: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a970c: 9801         	ldr	r0, [sp, #0x4]
700a970e: 2101         	movs	r1, #0x1
700a9710: f003 f8ee    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x31dc
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700a9714: b310         	cbz	r0, 0x700a975c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x44
700a9716: e7ff         	b	0x700a9718 <Sciclient_rmIrqCfgIsDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9718: 9801         	ldr	r0, [sp, #0x4]
700a971a: 2102         	movs	r1, #0x2
700a971c: f003 f8e8    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x31d0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700a9720: b1e0         	cbz	r0, 0x700a975c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x38
700a9722: e7ff         	b	0x700a9724 <Sciclient_rmIrqCfgIsDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9724: 9801         	ldr	r0, [sp, #0x4]
700a9726: 2104         	movs	r1, #0x4
700a9728: f003 f8e2    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x31c4
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700a972c: b1b0         	cbz	r0, 0x700a975c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x2c
700a972e: e7ff         	b	0x700a9730 <Sciclient_rmIrqCfgIsDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9730: 9801         	ldr	r0, [sp, #0x4]
700a9732: 2108         	movs	r1, #0x8
700a9734: f003 f8dc    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x31b8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700a9738: b180         	cbz	r0, 0x700a975c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x20
700a973a: e7ff         	b	0x700a973c <Sciclient_rmIrqCfgIsDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a973c: 9801         	ldr	r0, [sp, #0x4]
700a973e: 2110         	movs	r1, #0x10
700a9740: f003 f8d6    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x31ac
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700a9744: b150         	cbz	r0, 0x700a975c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x14
700a9746: e7ff         	b	0x700a9748 <Sciclient_rmIrqCfgIsDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9748: 9801         	ldr	r0, [sp, #0x4]
700a974a: 2120         	movs	r1, #0x20
700a974c: f003 f8d0    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x31a0
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9750: b120         	cbz	r0, 0x700a975c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x8
700a9752: e7ff         	b	0x700a9754 <Sciclient_rmIrqCfgIsDirectEvent+0x54> @ imm = #-0x2
700a9754: 2001         	movs	r0, #0x1
;         r = true;
700a9756: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a975a: e7ff         	b	0x700a975c <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700a975c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9760: f000 0001    	and	r0, r0, #0x1
700a9764: b002         	add	sp, #0x8
700a9766: bd80         	pop	{r7, pc}
		...

700a9770 <Sciclient_rmIrqCfgIsDirectNonEvent>:
; {
700a9770: b580         	push	{r7, lr}
700a9772: b082         	sub	sp, #0x8
700a9774: 9001         	str	r0, [sp, #0x4]
700a9776: 2000         	movs	r0, #0x0
;     bool r = false;
700a9778: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a977c: 9801         	ldr	r0, [sp, #0x4]
700a977e: 2101         	movs	r1, #0x1
700a9780: f003 f8b6    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x316c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700a9784: b310         	cbz	r0, 0x700a97cc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x44
700a9786: e7ff         	b	0x700a9788 <Sciclient_rmIrqCfgIsDirectNonEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9788: 9801         	ldr	r0, [sp, #0x4]
700a978a: 2102         	movs	r1, #0x2
700a978c: f003 f8b0    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x3160
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700a9790: b1e0         	cbz	r0, 0x700a97cc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x38
700a9792: e7ff         	b	0x700a9794 <Sciclient_rmIrqCfgIsDirectNonEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9794: 9801         	ldr	r0, [sp, #0x4]
700a9796: 2104         	movs	r1, #0x4
700a9798: f003 f8aa    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x3154
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700a979c: b9b0         	cbnz	r0, 0x700a97cc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x2c
700a979e: e7ff         	b	0x700a97a0 <Sciclient_rmIrqCfgIsDirectNonEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a97a0: 9801         	ldr	r0, [sp, #0x4]
700a97a2: 2108         	movs	r1, #0x8
700a97a4: f003 f8a4    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x3148
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700a97a8: b980         	cbnz	r0, 0x700a97cc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x20
700a97aa: e7ff         	b	0x700a97ac <Sciclient_rmIrqCfgIsDirectNonEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a97ac: 9801         	ldr	r0, [sp, #0x4]
700a97ae: 2110         	movs	r1, #0x10
700a97b0: f003 f89e    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x313c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700a97b4: b950         	cbnz	r0, 0x700a97cc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x14
700a97b6: e7ff         	b	0x700a97b8 <Sciclient_rmIrqCfgIsDirectNonEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a97b8: 9801         	ldr	r0, [sp, #0x4]
700a97ba: 2120         	movs	r1, #0x20
700a97bc: f003 f898    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x3130
;     if ((Sciclient_rmParamIsValid(valid_params,
700a97c0: b920         	cbnz	r0, 0x700a97cc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x8
700a97c2: e7ff         	b	0x700a97c4 <Sciclient_rmIrqCfgIsDirectNonEvent+0x54> @ imm = #-0x2
700a97c4: 2001         	movs	r0, #0x1
;         r = true;
700a97c6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a97ca: e7ff         	b	0x700a97cc <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #-0x2
;     return r;
700a97cc: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a97d0: f000 0001    	and	r0, r0, #0x1
700a97d4: b002         	add	sp, #0x8
700a97d6: bd80         	pop	{r7, pc}
		...

700a97e0 <Sciclient_rmIrqCfgIsEventToVintMappingOnly>:
; {
700a97e0: b580         	push	{r7, lr}
700a97e2: b082         	sub	sp, #0x8
700a97e4: 9001         	str	r0, [sp, #0x4]
700a97e6: 2000         	movs	r0, #0x0
;     bool r = false;
700a97e8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a97ec: 9801         	ldr	r0, [sp, #0x4]
700a97ee: 2101         	movs	r1, #0x1
700a97f0: f003 f87e    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x30fc
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700a97f4: bb10         	cbnz	r0, 0x700a983c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x44
700a97f6: e7ff         	b	0x700a97f8 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a97f8: 9801         	ldr	r0, [sp, #0x4]
700a97fa: 2102         	movs	r1, #0x2
700a97fc: f003 f878    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x30f0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700a9800: b9e0         	cbnz	r0, 0x700a983c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x38
700a9802: e7ff         	b	0x700a9804 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9804: 9801         	ldr	r0, [sp, #0x4]
700a9806: 2104         	movs	r1, #0x4
700a9808: f003 f872    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x30e4
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700a980c: b1b0         	cbz	r0, 0x700a983c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x2c
700a980e: e7ff         	b	0x700a9810 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9810: 9801         	ldr	r0, [sp, #0x4]
700a9812: 2108         	movs	r1, #0x8
700a9814: f003 f86c    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x30d8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700a9818: b180         	cbz	r0, 0x700a983c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x20
700a981a: e7ff         	b	0x700a981c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a981c: 9801         	ldr	r0, [sp, #0x4]
700a981e: 2110         	movs	r1, #0x10
700a9820: f003 f866    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x30cc
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700a9824: b150         	cbz	r0, 0x700a983c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x14
700a9826: e7ff         	b	0x700a9828 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9828: 9801         	ldr	r0, [sp, #0x4]
700a982a: 2120         	movs	r1, #0x20
700a982c: f003 f860    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x30c0
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9830: b120         	cbz	r0, 0x700a983c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x8
700a9832: e7ff         	b	0x700a9834 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x54> @ imm = #-0x2
700a9834: 2001         	movs	r0, #0x1
;         r = true;
700a9836: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a983a: e7ff         	b	0x700a983c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #-0x2
;     return r;
700a983c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9840: f000 0001    	and	r0, r0, #0x1
700a9844: b002         	add	sp, #0x8
700a9846: bd80         	pop	{r7, pc}
		...

700a9850 <Sciclient_rmIrqCfgIsOesOnly>:
; {
700a9850: b580         	push	{r7, lr}
700a9852: b082         	sub	sp, #0x8
700a9854: 9001         	str	r0, [sp, #0x4]
700a9856: 2000         	movs	r0, #0x0
;     bool r = false;
700a9858: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a985c: 9801         	ldr	r0, [sp, #0x4]
700a985e: 2101         	movs	r1, #0x1
700a9860: f003 f846    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x308c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700a9864: bb10         	cbnz	r0, 0x700a98ac <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x44
700a9866: e7ff         	b	0x700a9868 <Sciclient_rmIrqCfgIsOesOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9868: 9801         	ldr	r0, [sp, #0x4]
700a986a: 2102         	movs	r1, #0x2
700a986c: f003 f840    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x3080
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700a9870: b9e0         	cbnz	r0, 0x700a98ac <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x38
700a9872: e7ff         	b	0x700a9874 <Sciclient_rmIrqCfgIsOesOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9874: 9801         	ldr	r0, [sp, #0x4]
700a9876: 2104         	movs	r1, #0x4
700a9878: f003 f83a    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x3074
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700a987c: b9b0         	cbnz	r0, 0x700a98ac <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x2c
700a987e: e7ff         	b	0x700a9880 <Sciclient_rmIrqCfgIsOesOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9880: 9801         	ldr	r0, [sp, #0x4]
700a9882: 2108         	movs	r1, #0x8
700a9884: f003 f834    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x3068
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700a9888: b980         	cbnz	r0, 0x700a98ac <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x20
700a988a: e7ff         	b	0x700a988c <Sciclient_rmIrqCfgIsOesOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a988c: 9801         	ldr	r0, [sp, #0x4]
700a988e: 2110         	movs	r1, #0x10
700a9890: f003 f82e    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x305c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700a9894: b150         	cbz	r0, 0x700a98ac <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x14
700a9896: e7ff         	b	0x700a9898 <Sciclient_rmIrqCfgIsOesOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9898: 9801         	ldr	r0, [sp, #0x4]
700a989a: 2120         	movs	r1, #0x20
700a989c: f003 f828    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x3050
;     if ((Sciclient_rmParamIsValid(valid_params,
700a98a0: b920         	cbnz	r0, 0x700a98ac <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x8
700a98a2: e7ff         	b	0x700a98a4 <Sciclient_rmIrqCfgIsOesOnly+0x54> @ imm = #-0x2
700a98a4: 2001         	movs	r0, #0x1
;         r = true;
700a98a6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a98aa: e7ff         	b	0x700a98ac <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #-0x2
;     return r;
700a98ac: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a98b0: f000 0001    	and	r0, r0, #0x1
700a98b4: b002         	add	sp, #0x8
700a98b6: bd80         	pop	{r7, pc}
		...

700a98c0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent>:
; {
700a98c0: b580         	push	{r7, lr}
700a98c2: b082         	sub	sp, #0x8
700a98c4: 9001         	str	r0, [sp, #0x4]
700a98c6: 2000         	movs	r0, #0x0
;     bool r = false;
700a98c8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700a98cc: 9801         	ldr	r0, [sp, #0x4]
700a98ce: 2101         	movs	r1, #0x1
700a98d0: f003 f80e    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x301c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700a98d4: b310         	cbz	r0, 0x700a991c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x44
700a98d6: e7ff         	b	0x700a98d8 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a98d8: 9801         	ldr	r0, [sp, #0x4]
700a98da: 2102         	movs	r1, #0x2
700a98dc: f003 f808    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x3010
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700a98e0: b1e0         	cbz	r0, 0x700a991c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x38
700a98e2: e7ff         	b	0x700a98e4 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a98e4: 9801         	ldr	r0, [sp, #0x4]
700a98e6: 2104         	movs	r1, #0x4
700a98e8: f003 f802    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x3004
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700a98ec: b1b0         	cbz	r0, 0x700a991c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x2c
700a98ee: e7ff         	b	0x700a98f0 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a98f0: 9801         	ldr	r0, [sp, #0x4]
700a98f2: 2108         	movs	r1, #0x8
700a98f4: f002 fffc    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x2ff8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700a98f8: b180         	cbz	r0, 0x700a991c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x20
700a98fa: e7ff         	b	0x700a98fc <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a98fc: 9801         	ldr	r0, [sp, #0x4]
700a98fe: 2110         	movs	r1, #0x10
700a9900: f002 fff6    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x2fec
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700a9904: b950         	cbnz	r0, 0x700a991c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x14
700a9906: e7ff         	b	0x700a9908 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700a9908: 9801         	ldr	r0, [sp, #0x4]
700a990a: 2120         	movs	r1, #0x20
700a990c: f002 fff0    	bl	0x700ac8f0 <Sciclient_rmParamIsValid> @ imm = #0x2fe0
;     if ((Sciclient_rmParamIsValid(valid_params,
700a9910: b920         	cbnz	r0, 0x700a991c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x8
700a9912: e7ff         	b	0x700a9914 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x54> @ imm = #-0x2
700a9914: 2001         	movs	r0, #0x1
;         r = true;
700a9916: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700a991a: e7ff         	b	0x700a991c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700a991c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a9920: f000 0001    	and	r0, r0, #0x1
700a9924: b002         	add	sp, #0x8
700a9926: bd80         	pop	{r7, pc}
		...

700a9930 <UART_divisorValCompute>:
; {
700a9930: b580         	push	{r7, lr}
700a9932: b088         	sub	sp, #0x20
700a9934: 9007         	str	r0, [sp, #0x1c]
700a9936: 9106         	str	r1, [sp, #0x18]
700a9938: 9205         	str	r2, [sp, #0x14]
700a993a: 9304         	str	r3, [sp, #0x10]
700a993c: 2000         	movs	r0, #0x0
;     uint32_t divisorValue = 0U;
700a993e: 9003         	str	r0, [sp, #0xc]
;     uint32_t tempModeFlag = modeFlag & UART_MDR1_MODE_SELECT_MASK;
700a9940: 9805         	ldr	r0, [sp, #0x14]
700a9942: f000 0007    	and	r0, r0, #0x7
700a9946: 9002         	str	r0, [sp, #0x8]
;     switch (tempModeFlag)
700a9948: 9802         	ldr	r0, [sp, #0x8]
700a994a: 9001         	str	r0, [sp, #0x4]
700a994c: 2805         	cmp	r0, #0x5
700a994e: d81f         	bhi	0x700a9990 <UART_divisorValCompute+0x60> @ imm = #0x3e
700a9950: 9901         	ldr	r1, [sp, #0x4]
700a9952: e8df f001    	tbb	[pc, r1]
700a9956: 03 03 1d 0a  	.word	0x0a1d0303
700a995a: 12 1a        	.short	0x1a12
;             divisorValue = UART_divideRoundCloset(moduleClk, 16U * baudRate);
700a995c: 9807         	ldr	r0, [sp, #0x1c]
700a995e: 9906         	ldr	r1, [sp, #0x18]
700a9960: 0109         	lsls	r1, r1, #0x4
700a9962: f003 fd4d    	bl	0x700ad400 <UART_divideRoundCloset> @ imm = #0x3a9a
700a9966: 9003         	str	r0, [sp, #0xc]
;             break;
700a9968: e013         	b	0x700a9992 <UART_divisorValCompute+0x62> @ imm = #0x26
;             divisorValue = UART_divideRoundCloset(moduleClk, 13U * baudRate);
700a996a: 9807         	ldr	r0, [sp, #0x1c]
700a996c: 9906         	ldr	r1, [sp, #0x18]
700a996e: 220d         	movs	r2, #0xd
700a9970: 4351         	muls	r1, r2, r1
700a9972: f003 fd45    	bl	0x700ad400 <UART_divideRoundCloset> @ imm = #0x3a8a
700a9976: 9003         	str	r0, [sp, #0xc]
;             break;
700a9978: e00b         	b	0x700a9992 <UART_divisorValCompute+0x62> @ imm = #0x16
;             divisorValue = UART_divideRoundCloset(moduleClk, mirOverSampRate * baudRate);
700a997a: 9807         	ldr	r0, [sp, #0x1c]
700a997c: 9904         	ldr	r1, [sp, #0x10]
700a997e: 9a06         	ldr	r2, [sp, #0x18]
700a9980: 4351         	muls	r1, r2, r1
700a9982: f003 fd3d    	bl	0x700ad400 <UART_divideRoundCloset> @ imm = #0x3a7a
700a9986: 9003         	str	r0, [sp, #0xc]
;             break;
700a9988: e003         	b	0x700a9992 <UART_divisorValCompute+0x62> @ imm = #0x6
700a998a: 2000         	movs	r0, #0x0
;             divisorValue = 0U;
700a998c: 9003         	str	r0, [sp, #0xc]
;             break;
700a998e: e000         	b	0x700a9992 <UART_divisorValCompute+0x62> @ imm = #0x0
;             break;
700a9990: e7ff         	b	0x700a9992 <UART_divisorValCompute+0x62> @ imm = #-0x2
;     return divisorValue;
700a9992: 9803         	ldr	r0, [sp, #0xc]
700a9994: b008         	add	sp, #0x20
700a9996: bd80         	pop	{r7, pc}
		...

700a99a0 <CSL_udmapCppi5SetIds>:
; {
700a99a0: b085         	sub	sp, #0x14
700a99a2: 9004         	str	r0, [sp, #0x10]
700a99a4: 9103         	str	r1, [sp, #0xc]
700a99a6: 9202         	str	r2, [sp, #0x8]
700a99a8: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700a99aa: 9803         	ldr	r0, [sp, #0xc]
700a99ac: 2803         	cmp	r0, #0x3
700a99ae: d114         	bne	0x700a99da <CSL_udmapCppi5SetIds+0x3a> @ imm = #0x28
700a99b0: e7ff         	b	0x700a99b2 <CSL_udmapCppi5SetIds+0x12> @ imm = #-0x2
;         v = ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo;
700a99b2: 9804         	ldr	r0, [sp, #0x10]
700a99b4: 6840         	ldr	r0, [r0, #0x4]
700a99b6: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_TRPD_PKTINFO_PKTID_MASK | CSL_UDMAP_CPPI5_TRPD_PKTINFO_FLOWID_MASK);
700a99b8: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a99bc: 0600         	lsls	r0, r0, #0x18
700a99be: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700a99c0: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_FLOWID, flowId );
700a99c2: 9901         	ldr	r1, [sp, #0x4]
700a99c4: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700a99c8: f360 3197    	bfi	r1, r0, #14, #10
700a99cc: 9800         	ldr	r0, [sp]
700a99ce: 4308         	orrs	r0, r1
700a99d0: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo = v;
700a99d2: 9800         	ldr	r0, [sp]
700a99d4: 9904         	ldr	r1, [sp, #0x10]
700a99d6: 6048         	str	r0, [r1, #0x4]
;     }
700a99d8: e013         	b	0x700a9a02 <CSL_udmapCppi5SetIds+0x62> @ imm = #0x26
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1;
700a99da: 9804         	ldr	r0, [sp, #0x10]
700a99dc: 6840         	ldr	r0, [r0, #0x4]
700a99de: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_PD_PKTINFO1_PKTID_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO1_FLOWID_MASK);
700a99e0: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a99e4: 0600         	lsls	r0, r0, #0x18
700a99e6: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700a99e8: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_FLOWID, flowId );
700a99ea: 9901         	ldr	r1, [sp, #0x4]
700a99ec: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700a99f0: f360 3197    	bfi	r1, r0, #14, #10
700a99f4: 9800         	ldr	r0, [sp]
700a99f6: 4308         	orrs	r0, r1
700a99f8: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1 = v;
700a99fa: 9800         	ldr	r0, [sp]
700a99fc: 9904         	ldr	r1, [sp, #0x10]
700a99fe: 6048         	str	r0, [r1, #0x4]
700a9a00: e7ff         	b	0x700a9a02 <CSL_udmapCppi5SetIds+0x62> @ imm = #-0x2
; }
700a9a02: b005         	add	sp, #0x14
700a9a04: 4770         	bx	lr
		...
700a9a0e: 0000         	movs	r0, r0

700a9a10 <Sciclient_rmIrGetInst>:
; {
700a9a10: b083         	sub	sp, #0xc
700a9a12: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a9a16: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIrInst *inst = NULL;
700a9a18: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700a9a1a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700a9a1e: e7ff         	b	0x700a9a20 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x2
700a9a20: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a9a24: 2803         	cmp	r0, #0x3
700a9a26: dc22         	bgt	0x700a9a6e <Sciclient_rmIrGetInst+0x5e> @ imm = #0x44
700a9a28: e7ff         	b	0x700a9a2a <Sciclient_rmIrGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIrInstances[i].dev_id) {
700a9a2a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a9a2e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a9a32: eb01 0241    	add.w	r2, r1, r1, lsl #1
700a9a36: f64f 71ec    	movw	r1, #0xffec
700a9a3a: f2c7 010a    	movt	r1, #0x700a
700a9a3e: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700a9a42: 4288         	cmp	r0, r1
700a9a44: d10c         	bne	0x700a9a60 <Sciclient_rmIrGetInst+0x50> @ imm = #0x18
700a9a46: e7ff         	b	0x700a9a48 <Sciclient_rmIrGetInst+0x38> @ imm = #-0x2
;             inst = &gRmIrInstances[i];
700a9a48: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a9a4c: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a9a50: f64f 70ec    	movw	r0, #0xffec
700a9a54: f2c7 000a    	movt	r0, #0x700a
700a9a58: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a9a5c: 9001         	str	r0, [sp, #0x4]
;             break;
700a9a5e: e006         	b	0x700a9a6e <Sciclient_rmIrGetInst+0x5e> @ imm = #0xc
;     }
700a9a60: e7ff         	b	0x700a9a62 <Sciclient_rmIrGetInst+0x52> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700a9a62: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a9a66: 3001         	adds	r0, #0x1
700a9a68: f8ad 0002    	strh.w	r0, [sp, #0x2]
700a9a6c: e7d8         	b	0x700a9a20 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x50
;     return inst;
700a9a6e: 9801         	ldr	r0, [sp, #0x4]
700a9a70: b003         	add	sp, #0xc
700a9a72: 4770         	bx	lr
		...

700a9a80 <UART_fifoRegisterWrite>:
; {
700a9a80: b580         	push	{r7, lr}
700a9a82: b088         	sub	sp, #0x20
700a9a84: 9007         	str	r0, [sp, #0x1c]
700a9a86: 9106         	str	r1, [sp, #0x18]
700a9a88: 2000         	movs	r0, #0x0
;     uint32_t isTxRxFifoEmpty = FALSE;
700a9a8a: 9001         	str	r0, [sp, #0x4]
700a9a8c: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a9a8e: 9807         	ldr	r0, [sp, #0x1c]
700a9a90: 2180         	movs	r1, #0x80
700a9a92: f000 fdc5    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #0xb8a
700a9a96: 9901         	ldr	r1, [sp, #0x4]
700a9a98: 9003         	str	r0, [sp, #0xc]
;     divLatchRegVal = UART_divisorLatchWrite(baseAddr, 0x0000U);
700a9a9a: 9807         	ldr	r0, [sp, #0x1c]
700a9a9c: f7f9 fa90    	bl	0x700a2fc0 <UART_divisorLatchWrite> @ imm = #-0x6ae0
700a9aa0: 9005         	str	r0, [sp, #0x14]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
700a9aa2: 9807         	ldr	r0, [sp, #0x1c]
700a9aa4: f002 f98c    	bl	0x700abdc0 <UART_enhanFuncEnable> @ imm = #0x2318
700a9aa8: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_FCR, fcrValue);
700a9aaa: 9807         	ldr	r0, [sp, #0x1c]
700a9aac: 3008         	adds	r0, #0x8
700a9aae: 9906         	ldr	r1, [sp, #0x18]
700a9ab0: f003 fdc6    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x3b8c
;     while(isTxRxFifoEmpty == FALSE)
700a9ab4: e7ff         	b	0x700a9ab6 <UART_fifoRegisterWrite+0x36> @ imm = #-0x2
700a9ab6: 9802         	ldr	r0, [sp, #0x8]
700a9ab8: b928         	cbnz	r0, 0x700a9ac6 <UART_fifoRegisterWrite+0x46> @ imm = #0xa
700a9aba: e7ff         	b	0x700a9abc <UART_fifoRegisterWrite+0x3c> @ imm = #-0x2
;         isTxRxFifoEmpty = UART_IsTxRxFifoEmpty(baseAddr);
700a9abc: 9807         	ldr	r0, [sp, #0x1c]
700a9abe: f002 f95f    	bl	0x700abd80 <UART_IsTxRxFifoEmpty> @ imm = #0x22be
700a9ac2: 9002         	str	r0, [sp, #0x8]
;     while(isTxRxFifoEmpty == FALSE)
700a9ac4: e7f7         	b	0x700a9ab6 <UART_fifoRegisterWrite+0x36> @ imm = #-0x12
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
700a9ac6: 9807         	ldr	r0, [sp, #0x1c]
700a9ac8: 9904         	ldr	r1, [sp, #0x10]
700a9aca: f002 fc51    	bl	0x700ac370 <UART_enhanFuncBitValRestore> @ imm = #0x28a2
;     (void) UART_divisorLatchWrite(baseAddr, divLatchRegVal);
700a9ace: 9807         	ldr	r0, [sp, #0x1c]
700a9ad0: 9905         	ldr	r1, [sp, #0x14]
700a9ad2: f7f9 fa75    	bl	0x700a2fc0 <UART_divisorLatchWrite> @ imm = #-0x6b16
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9ad6: 9807         	ldr	r0, [sp, #0x1c]
700a9ad8: 300c         	adds	r0, #0xc
700a9ada: 9903         	ldr	r1, [sp, #0xc]
700a9adc: f003 fdb0    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x3b60
; }
700a9ae0: b008         	add	sp, #0x20
700a9ae2: bd80         	pop	{r7, pc}
		...

700a9af0 <UART_lld_deInitDma>:
; {
700a9af0: b580         	push	{r7, lr}
700a9af2: b084         	sub	sp, #0x10
700a9af4: 9003         	str	r0, [sp, #0xc]
700a9af6: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700a9af8: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700a9afa: 9803         	ldr	r0, [sp, #0xc]
700a9afc: b318         	cbz	r0, 0x700a9b46 <UART_lld_deInitDma+0x56> @ imm = #0x46
700a9afe: e7ff         	b	0x700a9b00 <UART_lld_deInitDma+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a9b00: 9903         	ldr	r1, [sp, #0xc]
700a9b02: 2002         	movs	r0, #0x2
700a9b04: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700a9b06: 9803         	ldr	r0, [sp, #0xc]
700a9b08: f7fe fc8a    	bl	0x700a8420 <UART_lld_flushTxFifo> @ imm = #-0x16ec
700a9b0c: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700a9b0e: 9802         	ldr	r0, [sp, #0x8]
700a9b10: b9a0         	cbnz	r0, 0x700a9b3c <UART_lld_deInitDma+0x4c> @ imm = #0x28
700a9b12: e7ff         	b	0x700a9b14 <UART_lld_deInitDma+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700a9b14: 9803         	ldr	r0, [sp, #0xc]
700a9b16: 6800         	ldr	r0, [r0]
700a9b18: 2107         	movs	r1, #0x7
700a9b1a: 9101         	str	r1, [sp, #0x4]
700a9b1c: f7fa fc30    	bl	0x700a4380 <UART_intrDisable> @ imm = #-0x57a0
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700a9b20: 9803         	ldr	r0, [sp, #0xc]
700a9b22: 6800         	ldr	r0, [r0]
700a9b24: 2102         	movs	r1, #0x2
700a9b26: f002 ff2b    	bl	0x700ac980 <UART_intr2Disable> @ imm = #0x2e56
700a9b2a: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700a9b2c: 9803         	ldr	r0, [sp, #0xc]
700a9b2e: 6800         	ldr	r0, [r0]
700a9b30: f002 ff6e    	bl	0x700aca10 <UART_operatingModeSelect> @ imm = #0x2edc
;             hUart->state = UART_STATE_RESET;
700a9b34: 9903         	ldr	r1, [sp, #0xc]
700a9b36: 2000         	movs	r0, #0x0
700a9b38: 6548         	str	r0, [r1, #0x54]
;         }
700a9b3a: e7ff         	b	0x700a9b3c <UART_lld_deInitDma+0x4c> @ imm = #-0x2
;         status = UART_lld_dmaDeInit(hUart);
700a9b3c: 9803         	ldr	r0, [sp, #0xc]
700a9b3e: f002 f95f    	bl	0x700abe00 <UART_lld_dmaDeInit> @ imm = #0x22be
700a9b42: 9002         	str	r0, [sp, #0x8]
;     }
700a9b44: e003         	b	0x700a9b4e <UART_lld_deInitDma+0x5e> @ imm = #0x6
700a9b46: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a9b4a: 9002         	str	r0, [sp, #0x8]
700a9b4c: e7ff         	b	0x700a9b4e <UART_lld_deInitDma+0x5e> @ imm = #-0x2
;     return status;
700a9b4e: 9802         	ldr	r0, [sp, #0x8]
700a9b50: b004         	add	sp, #0x10
700a9b52: bd80         	pop	{r7, pc}
		...

700a9b60 <Udma_rmFreeEvent>:
; {
700a9b60: b580         	push	{r7, lr}
700a9b62: b088         	sub	sp, #0x20
700a9b64: 9007         	str	r0, [sp, #0x1c]
700a9b66: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9b68: 9806         	ldr	r0, [sp, #0x18]
700a9b6a: f500 70ea    	add.w	r0, r0, #0x1d4
700a9b6e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9b70: 9806         	ldr	r0, [sp, #0x18]
700a9b72: f500 609f    	add.w	r0, r0, #0x4f8
700a9b76: f04f 31ff    	mov.w	r1, #0xffffffff
700a9b7a: f7fe fdb9    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x148e
;     i = globalEvent - rmInitPrms->startGlobalEvent;
700a9b7e: 9807         	ldr	r0, [sp, #0x1c]
700a9b80: 9901         	ldr	r1, [sp, #0x4]
700a9b82: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a9b86: 1a40         	subs	r0, r0, r1
700a9b88: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9b8a: 9805         	ldr	r0, [sp, #0x14]
700a9b8c: 0940         	lsrs	r0, r0, #0x5
700a9b8e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9b90: 9805         	ldr	r0, [sp, #0x14]
700a9b92: 9904         	ldr	r1, [sp, #0x10]
700a9b94: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9b98: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9b9a: 9903         	ldr	r1, [sp, #0xc]
700a9b9c: 2001         	movs	r0, #0x1
700a9b9e: 4088         	lsls	r0, r1
700a9ba0: 9002         	str	r0, [sp, #0x8]
;     drvHandle->globalEventFlag[offset] |= bitMask;
700a9ba2: 9a02         	ldr	r2, [sp, #0x8]
700a9ba4: 9806         	ldr	r0, [sp, #0x18]
700a9ba6: 9904         	ldr	r1, [sp, #0x10]
700a9ba8: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9bac: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700a9bb0: 4310         	orrs	r0, r2
700a9bb2: f8c1 0424    	str.w	r0, [r1, #0x424]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9bb6: 9806         	ldr	r0, [sp, #0x18]
700a9bb8: f500 609f    	add.w	r0, r0, #0x4f8
700a9bbc: f000 f8e8    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x1d0
;     return;
700a9bc0: b008         	add	sp, #0x20
700a9bc2: bd80         	pop	{r7, pc}
		...

700a9bd0 <Udma_rmFreeIrIntr>:
; {
700a9bd0: b580         	push	{r7, lr}
700a9bd2: b088         	sub	sp, #0x20
700a9bd4: 9007         	str	r0, [sp, #0x1c]
700a9bd6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9bd8: 9806         	ldr	r0, [sp, #0x18]
700a9bda: f500 70ea    	add.w	r0, r0, #0x1d4
700a9bde: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9be0: 9806         	ldr	r0, [sp, #0x18]
700a9be2: f500 609f    	add.w	r0, r0, #0x4f8
700a9be6: f04f 31ff    	mov.w	r1, #0xffffffff
700a9bea: f7fe fd81    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x14fe
;     i = irIntrNum - rmInitPrms->startIrIntr;
700a9bee: 9807         	ldr	r0, [sp, #0x1c]
700a9bf0: 9901         	ldr	r1, [sp, #0x4]
700a9bf2: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a9bf6: 1a40         	subs	r0, r0, r1
700a9bf8: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9bfa: 9805         	ldr	r0, [sp, #0x14]
700a9bfc: 0940         	lsrs	r0, r0, #0x5
700a9bfe: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9c00: 9805         	ldr	r0, [sp, #0x14]
700a9c02: 9904         	ldr	r1, [sp, #0x10]
700a9c04: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9c08: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9c0a: 9903         	ldr	r1, [sp, #0xc]
700a9c0c: 2001         	movs	r0, #0x1
700a9c0e: 4088         	lsls	r0, r1
700a9c10: 9002         	str	r0, [sp, #0x8]
;     drvHandle->irIntrFlag[offset] |= bitMask;
700a9c12: 9a02         	ldr	r2, [sp, #0x8]
700a9c14: 9806         	ldr	r0, [sp, #0x18]
700a9c16: 9904         	ldr	r1, [sp, #0x10]
700a9c18: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9c1c: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a9c20: 4310         	orrs	r0, r2
700a9c22: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9c26: 9806         	ldr	r0, [sp, #0x18]
700a9c28: f500 609f    	add.w	r0, r0, #0x4f8
700a9c2c: f000 f8b0    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0x160
;     return;
700a9c30: b008         	add	sp, #0x20
700a9c32: bd80         	pop	{r7, pc}
		...

700a9c40 <Udma_rmFreeVintr>:
; {
700a9c40: b580         	push	{r7, lr}
700a9c42: b088         	sub	sp, #0x20
700a9c44: 9007         	str	r0, [sp, #0x1c]
700a9c46: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9c48: 9806         	ldr	r0, [sp, #0x18]
700a9c4a: f500 70ea    	add.w	r0, r0, #0x1d4
700a9c4e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9c50: 9806         	ldr	r0, [sp, #0x18]
700a9c52: f500 609f    	add.w	r0, r0, #0x4f8
700a9c56: f04f 31ff    	mov.w	r1, #0xffffffff
700a9c5a: f7fe fd49    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x156e
;     i = vintrNum - rmInitPrms->startVintr;
700a9c5e: 9807         	ldr	r0, [sp, #0x1c]
700a9c60: 9901         	ldr	r1, [sp, #0x4]
700a9c62: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700a9c66: 1a40         	subs	r0, r0, r1
700a9c68: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9c6a: 9805         	ldr	r0, [sp, #0x14]
700a9c6c: 0940         	lsrs	r0, r0, #0x5
700a9c6e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9c70: 9805         	ldr	r0, [sp, #0x14]
700a9c72: 9904         	ldr	r1, [sp, #0x10]
700a9c74: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9c78: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9c7a: 9903         	ldr	r1, [sp, #0xc]
700a9c7c: 2001         	movs	r0, #0x1
700a9c7e: 4088         	lsls	r0, r1
700a9c80: 9002         	str	r0, [sp, #0x8]
;     drvHandle->vintrFlag[offset] |= bitMask;
700a9c82: 9a02         	ldr	r2, [sp, #0x8]
700a9c84: 9806         	ldr	r0, [sp, #0x18]
700a9c86: 9904         	ldr	r1, [sp, #0x10]
700a9c88: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9c8c: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700a9c90: 4310         	orrs	r0, r2
700a9c92: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9c96: 9806         	ldr	r0, [sp, #0x18]
700a9c98: f500 609f    	add.w	r0, r0, #0x4f8
700a9c9c: f000 f878    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #0xf0
;     return;
700a9ca0: b008         	add	sp, #0x20
700a9ca2: bd80         	pop	{r7, pc}
		...

700a9cb0 <vApplicationLoadHook>:
; {
700a9cb0: b580         	push	{r7, lr}
700a9cb2: b082         	sub	sp, #0x8
;     uint64_t curUpdateTime = ClockP_getTimeUsec();
700a9cb4: f7fe fef4    	bl	0x700a8aa0 <ClockP_getTimeUsec> @ imm = #-0x1218
700a9cb8: 9101         	str	r1, [sp, #0x4]
700a9cba: 9000         	str	r0, [sp]
;     if( (curUpdateTime > lastUpdateTime) && ((curUpdateTime - lastUpdateTime) > (TaskP_LOAD_UPDATE_WINDOW_MSEC*1000u )) )
700a9cbc: 9b00         	ldr	r3, [sp]
700a9cbe: 9901         	ldr	r1, [sp, #0x4]
700a9cc0: f240 1090    	movw	r0, #0x190
700a9cc4: f2c7 000b    	movt	r0, #0x700b
700a9cc8: 6802         	ldr	r2, [r0]
700a9cca: 6840         	ldr	r0, [r0, #0x4]
700a9ccc: 1ad2         	subs	r2, r2, r3
700a9cce: 4188         	sbcs	r0, r1
700a9cd0: d21e         	bhs	0x700a9d10 <vApplicationLoadHook+0x60> @ imm = #0x3c
700a9cd2: e7ff         	b	0x700a9cd4 <vApplicationLoadHook+0x24> @ imm = #-0x2
700a9cd4: 9900         	ldr	r1, [sp]
700a9cd6: 9801         	ldr	r0, [sp, #0x4]
700a9cd8: f240 1290    	movw	r2, #0x190
700a9cdc: f2c7 020b    	movt	r2, #0x700b
700a9ce0: 6813         	ldr	r3, [r2]
700a9ce2: 6852         	ldr	r2, [r2, #0x4]
700a9ce4: 1ac9         	subs	r1, r1, r3
700a9ce6: 4190         	sbcs	r0, r2
700a9ce8: f24a 1221    	movw	r2, #0xa121
700a9cec: f2c0 0207    	movt	r2, #0x7
700a9cf0: 1a89         	subs	r1, r1, r2
700a9cf2: f170 0000    	sbcs	r0, r0, #0x0
700a9cf6: d30b         	blo	0x700a9d10 <vApplicationLoadHook+0x60> @ imm = #0x16
700a9cf8: e7ff         	b	0x700a9cfa <vApplicationLoadHook+0x4a> @ imm = #-0x2
;         TaskP_loadUpdateAll();
700a9cfa: f7f8 ff29    	bl	0x700a2b50 <TaskP_loadUpdateAll> @ imm = #-0x71ae
;         lastUpdateTime = curUpdateTime;
700a9cfe: 9800         	ldr	r0, [sp]
700a9d00: 9a01         	ldr	r2, [sp, #0x4]
700a9d02: f240 1190    	movw	r1, #0x190
700a9d06: f2c7 010b    	movt	r1, #0x700b
700a9d0a: 604a         	str	r2, [r1, #0x4]
700a9d0c: 6008         	str	r0, [r1]
;     }
700a9d0e: e7ff         	b	0x700a9d10 <vApplicationLoadHook+0x60> @ imm = #-0x2
; }
700a9d10: b002         	add	sp, #0x8
700a9d12: bd80         	pop	{r7, pc}
		...

700a9d20 <vQueueWaitForMessageRestricted>:
;     {
700a9d20: b580         	push	{r7, lr}
700a9d22: b084         	sub	sp, #0x10
700a9d24: 9003         	str	r0, [sp, #0xc]
700a9d26: 9102         	str	r1, [sp, #0x8]
700a9d28: 9201         	str	r2, [sp, #0x4]
;         Queue_t * const pxQueue = xQueue;
700a9d2a: 9803         	ldr	r0, [sp, #0xc]
700a9d2c: 9000         	str	r0, [sp]
;         prvLockQueue( pxQueue );
700a9d2e: f002 fb5f    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0x26be
700a9d32: 9800         	ldr	r0, [sp]
700a9d34: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a9d38: 3001         	adds	r0, #0x1
700a9d3a: b928         	cbnz	r0, 0x700a9d48 <vQueueWaitForMessageRestricted+0x28> @ imm = #0xa
700a9d3c: e7ff         	b	0x700a9d3e <vQueueWaitForMessageRestricted+0x1e> @ imm = #-0x2
700a9d3e: 9900         	ldr	r1, [sp]
700a9d40: 2000         	movs	r0, #0x0
700a9d42: f881 0044    	strb.w	r0, [r1, #0x44]
700a9d46: e7ff         	b	0x700a9d48 <vQueueWaitForMessageRestricted+0x28> @ imm = #-0x2
700a9d48: 9800         	ldr	r0, [sp]
700a9d4a: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a9d4e: 3001         	adds	r0, #0x1
700a9d50: b928         	cbnz	r0, 0x700a9d5e <vQueueWaitForMessageRestricted+0x3e> @ imm = #0xa
700a9d52: e7ff         	b	0x700a9d54 <vQueueWaitForMessageRestricted+0x34> @ imm = #-0x2
700a9d54: 9900         	ldr	r1, [sp]
700a9d56: 2000         	movs	r0, #0x0
700a9d58: f881 0045    	strb.w	r0, [r1, #0x45]
700a9d5c: e7ff         	b	0x700a9d5e <vQueueWaitForMessageRestricted+0x3e> @ imm = #-0x2
700a9d5e: f001 fc47    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0x188e
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
700a9d62: 9800         	ldr	r0, [sp]
700a9d64: 6b80         	ldr	r0, [r0, #0x38]
700a9d66: b938         	cbnz	r0, 0x700a9d78 <vQueueWaitForMessageRestricted+0x58> @ imm = #0xe
700a9d68: e7ff         	b	0x700a9d6a <vQueueWaitForMessageRestricted+0x4a> @ imm = #-0x2
;             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
700a9d6a: 9800         	ldr	r0, [sp]
700a9d6c: 3024         	adds	r0, #0x24
700a9d6e: 9902         	ldr	r1, [sp, #0x8]
700a9d70: 9a01         	ldr	r2, [sp, #0x4]
700a9d72: f002 f9c5    	bl	0x700ac100 <vTaskPlaceOnEventListRestricted> @ imm = #0x238a
;         }
700a9d76: e000         	b	0x700a9d7a <vQueueWaitForMessageRestricted+0x5a> @ imm = #0x0
700a9d78: e7ff         	b	0x700a9d7a <vQueueWaitForMessageRestricted+0x5a> @ imm = #-0x2
;         prvUnlockQueue( pxQueue );
700a9d7a: 9800         	ldr	r0, [sp]
700a9d7c: f7fb ffc0    	bl	0x700a5d00 <prvUnlockQueue> @ imm = #-0x4080
;     }
700a9d80: b004         	add	sp, #0x10
700a9d82: bd80         	pop	{r7, pc}
		...

700a9d90 <SemaphoreP_post>:
; {
700a9d90: b580         	push	{r7, lr}
700a9d92: b084         	sub	sp, #0x10
700a9d94: 9003         	str	r0, [sp, #0xc]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700a9d96: 9803         	ldr	r0, [sp, #0xc]
700a9d98: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700a9d9a: 9802         	ldr	r0, [sp, #0x8]
700a9d9c: 6d40         	ldr	r0, [r0, #0x54]
700a9d9e: b170         	cbz	r0, 0x700a9dbe <SemaphoreP_post+0x2e> @ imm = #0x1c
700a9da0: e7ff         	b	0x700a9da2 <SemaphoreP_post+0x12> @ imm = #-0x2
;         if( HwiP_inISR() == 0U)
700a9da2: f004 f815    	bl	0x700addd0 <HwiP_inISR> @ imm = #0x402a
700a9da6: b928         	cbnz	r0, 0x700a9db4 <SemaphoreP_post+0x24> @ imm = #0xa
700a9da8: e7ff         	b	0x700a9daa <SemaphoreP_post+0x1a> @ imm = #-0x2
;             (void)xSemaphoreGiveRecursive(pSemaphore->semHndl);
700a9daa: 9802         	ldr	r0, [sp, #0x8]
700a9dac: 6d00         	ldr	r0, [r0, #0x50]
700a9dae: f001 f8d7    	bl	0x700aaf60 <xQueueGiveMutexRecursive> @ imm = #0x11ae
;         }
700a9db2: e003         	b	0x700a9dbc <SemaphoreP_post+0x2c> @ imm = #0x6
700a9db4: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700a9db6: f004 ffab    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x4f56
700a9dba: e7ff         	b	0x700a9dbc <SemaphoreP_post+0x2c> @ imm = #-0x2
;     }
700a9dbc: e017         	b	0x700a9dee <SemaphoreP_post+0x5e> @ imm = #0x2e
;         if( HwiP_inISR() != 0U)
700a9dbe: f004 f807    	bl	0x700addd0 <HwiP_inISR> @ imm = #0x400e
700a9dc2: b158         	cbz	r0, 0x700a9ddc <SemaphoreP_post+0x4c> @ imm = #0x16
700a9dc4: e7ff         	b	0x700a9dc6 <SemaphoreP_post+0x36> @ imm = #-0x2
700a9dc6: 2000         	movs	r0, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700a9dc8: 9001         	str	r0, [sp, #0x4]
;             (void)xSemaphoreGiveFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700a9dca: 9802         	ldr	r0, [sp, #0x8]
700a9dcc: 6d00         	ldr	r0, [r0, #0x50]
700a9dce: a901         	add	r1, sp, #0x4
700a9dd0: f7fd fde6    	bl	0x700a79a0 <xQueueGiveFromISR> @ imm = #-0x2434
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700a9dd4: 9801         	ldr	r0, [sp, #0x4]
700a9dd6: f003 f9b3    	bl	0x700ad140 <vPortYeildFromISR> @ imm = #0x3366
;         }
700a9dda: e007         	b	0x700a9dec <SemaphoreP_post+0x5c> @ imm = #0xe
;             (void)xSemaphoreGive(pSemaphore->semHndl);
700a9ddc: 9802         	ldr	r0, [sp, #0x8]
700a9dde: 6d00         	ldr	r0, [r0, #0x50]
700a9de0: 2300         	movs	r3, #0x0
700a9de2: 4619         	mov	r1, r3
700a9de4: 461a         	mov	r2, r3
700a9de6: f7f7 fb93    	bl	0x700a1510 <xQueueGenericSend> @ imm = #-0x88da
700a9dea: e7ff         	b	0x700a9dec <SemaphoreP_post+0x5c> @ imm = #-0x2
700a9dec: e7ff         	b	0x700a9dee <SemaphoreP_post+0x5e> @ imm = #-0x2
; }
700a9dee: b004         	add	sp, #0x10
700a9df0: bd80         	pop	{r7, pc}
		...
700a9dfe: 0000         	movs	r0, r0

700a9e00 <UdmaEventPrms_init>:
; {
700a9e00: b082         	sub	sp, #0x8
700a9e02: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventPrms)
700a9e04: 9801         	ldr	r0, [sp, #0x4]
700a9e06: b350         	cbz	r0, 0x700a9e5e <UdmaEventPrms_init+0x5e> @ imm = #0x54
700a9e08: e7ff         	b	0x700a9e0a <UdmaEventPrms_init+0xa> @ imm = #-0x2
;         eventPrms->eventType            = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a9e0a: 9801         	ldr	r0, [sp, #0x4]
700a9e0c: 2101         	movs	r1, #0x1
700a9e0e: 6001         	str	r1, [r0]
;         eventPrms->eventMode            = UDMA_EVENT_MODE_SHARED;
700a9e10: 9a01         	ldr	r2, [sp, #0x4]
700a9e12: 2002         	movs	r0, #0x2
700a9e14: 6050         	str	r0, [r2, #0x4]
;         eventPrms->chHandle             = (Udma_ChHandle) NULL_PTR;
700a9e16: 9a01         	ldr	r2, [sp, #0x4]
700a9e18: 2000         	movs	r0, #0x0
700a9e1a: 9000         	str	r0, [sp]
700a9e1c: 6090         	str	r0, [r2, #0x8]
;         eventPrms->ringHandle           = (Udma_RingHandle) NULL_PTR;
700a9e1e: 9a01         	ldr	r2, [sp, #0x4]
700a9e20: 60d0         	str	r0, [r2, #0xc]
;         eventPrms->controllerEventHandle    = (Udma_EventHandle) NULL_PTR;
700a9e22: 9a01         	ldr	r2, [sp, #0x4]
700a9e24: 6110         	str	r0, [r2, #0x10]
;         eventPrms->eventCb              = (Udma_EventCallback) NULL_PTR;
700a9e26: 9a01         	ldr	r2, [sp, #0x4]
700a9e28: 6150         	str	r0, [r2, #0x14]
;         eventPrms->intrPriority         = 1U;
700a9e2a: 9a01         	ldr	r2, [sp, #0x4]
700a9e2c: 6191         	str	r1, [r2, #0x18]
;         eventPrms->appData              = NULL_PTR;
700a9e2e: 9901         	ldr	r1, [sp, #0x4]
700a9e30: 61c8         	str	r0, [r1, #0x1c]
;         eventPrms->preferredCoreIntrNum = UDMA_CORE_INTR_ANY;
700a9e32: 9a01         	ldr	r2, [sp, #0x4]
700a9e34: 2101         	movs	r1, #0x1
700a9e36: f6cf 71ff    	movt	r1, #0xffff
700a9e3a: 6211         	str	r1, [r2, #0x20]
;         eventPrms->intrStatusReg        = (volatile uint64_t *) NULL_PTR;
700a9e3c: 9901         	ldr	r1, [sp, #0x4]
700a9e3e: 6248         	str	r0, [r1, #0x24]
;         eventPrms->intrClearReg         = (volatile uint64_t *) NULL_PTR;
700a9e40: 9901         	ldr	r1, [sp, #0x4]
700a9e42: 6288         	str	r0, [r1, #0x28]
;         eventPrms->intrMask             = 0U;
700a9e44: 9901         	ldr	r1, [sp, #0x4]
700a9e46: 6348         	str	r0, [r1, #0x34]
700a9e48: 6308         	str	r0, [r1, #0x30]
;         eventPrms->vintrNum             = UDMA_EVENT_INVALID;
700a9e4a: 9901         	ldr	r1, [sp, #0x4]
700a9e4c: f64f 70ff    	movw	r0, #0xffff
700a9e50: 6388         	str	r0, [r1, #0x38]
;         eventPrms->coreIntrNum          = UDMA_INTR_INVALID;
700a9e52: 9901         	ldr	r1, [sp, #0x4]
700a9e54: 2000         	movs	r0, #0x0
700a9e56: f6cf 70ff    	movt	r0, #0xffff
700a9e5a: 63c8         	str	r0, [r1, #0x3c]
;     }
700a9e5c: e7ff         	b	0x700a9e5e <UdmaEventPrms_init+0x5e> @ imm = #-0x2
;     return;
700a9e5e: b002         	add	sp, #0x8
700a9e60: 4770         	bx	lr
		...
700a9e6e: 0000         	movs	r0, r0

700a9e70 <Udma_rmFreeBlkCopyCh>:
; {
700a9e70: b580         	push	{r7, lr}
700a9e72: b088         	sub	sp, #0x20
700a9e74: 9007         	str	r0, [sp, #0x1c]
700a9e76: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9e78: 9806         	ldr	r0, [sp, #0x18]
700a9e7a: f500 70ea    	add.w	r0, r0, #0x1d4
700a9e7e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9e80: 9806         	ldr	r0, [sp, #0x18]
700a9e82: f500 609f    	add.w	r0, r0, #0x4f8
700a9e86: f04f 31ff    	mov.w	r1, #0xffffffff
700a9e8a: f7fe fc31    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x179e
;     i = chNum - rmInitPrms->startBlkCopyCh;
700a9e8e: 9807         	ldr	r0, [sp, #0x1c]
700a9e90: 9901         	ldr	r1, [sp, #0x4]
700a9e92: 6909         	ldr	r1, [r1, #0x10]
700a9e94: 1a40         	subs	r0, r0, r1
700a9e96: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9e98: 9805         	ldr	r0, [sp, #0x14]
700a9e9a: 0940         	lsrs	r0, r0, #0x5
700a9e9c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9e9e: 9805         	ldr	r0, [sp, #0x14]
700a9ea0: 9904         	ldr	r1, [sp, #0x10]
700a9ea2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9ea6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9ea8: 9903         	ldr	r1, [sp, #0xc]
700a9eaa: 2001         	movs	r0, #0x1
700a9eac: 4088         	lsls	r0, r1
700a9eae: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyChFlag[offset] |= bitMask;
700a9eb0: 9a02         	ldr	r2, [sp, #0x8]
700a9eb2: 9806         	ldr	r0, [sp, #0x18]
700a9eb4: 9904         	ldr	r1, [sp, #0x10]
700a9eb6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9eba: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a9ebe: 4310         	orrs	r0, r2
700a9ec0: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9ec4: 9806         	ldr	r0, [sp, #0x18]
700a9ec6: f500 609f    	add.w	r0, r0, #0x4f8
700a9eca: f7ff ff61    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #-0x13e
;     return;
700a9ece: b008         	add	sp, #0x20
700a9ed0: bd80         	pop	{r7, pc}
		...
700a9ede: 0000         	movs	r0, r0

700a9ee0 <Udma_rmFreeBlkCopyHcCh>:
; {
700a9ee0: b580         	push	{r7, lr}
700a9ee2: b088         	sub	sp, #0x20
700a9ee4: 9007         	str	r0, [sp, #0x1c]
700a9ee6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9ee8: 9806         	ldr	r0, [sp, #0x18]
700a9eea: f500 70ea    	add.w	r0, r0, #0x1d4
700a9eee: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9ef0: 9806         	ldr	r0, [sp, #0x18]
700a9ef2: f500 609f    	add.w	r0, r0, #0x4f8
700a9ef6: f04f 31ff    	mov.w	r1, #0xffffffff
700a9efa: f7fe fbf9    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x180e
;     i = chNum - rmInitPrms->startBlkCopyHcCh;
700a9efe: 9807         	ldr	r0, [sp, #0x1c]
700a9f00: 9901         	ldr	r1, [sp, #0x4]
700a9f02: 6889         	ldr	r1, [r1, #0x8]
700a9f04: 1a40         	subs	r0, r0, r1
700a9f06: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9f08: 9805         	ldr	r0, [sp, #0x14]
700a9f0a: 0940         	lsrs	r0, r0, #0x5
700a9f0c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9f0e: 9805         	ldr	r0, [sp, #0x14]
700a9f10: 9904         	ldr	r1, [sp, #0x10]
700a9f12: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9f16: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9f18: 9903         	ldr	r1, [sp, #0xc]
700a9f1a: 2001         	movs	r0, #0x1
700a9f1c: 4088         	lsls	r0, r1
700a9f1e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyHcChFlag[offset] |= bitMask;
700a9f20: 9a02         	ldr	r2, [sp, #0x8]
700a9f22: 9806         	ldr	r0, [sp, #0x18]
700a9f24: 9904         	ldr	r1, [sp, #0x10]
700a9f26: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9f2a: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a9f2e: 4310         	orrs	r0, r2
700a9f30: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9f34: 9806         	ldr	r0, [sp, #0x18]
700a9f36: f500 609f    	add.w	r0, r0, #0x4f8
700a9f3a: f7ff ff29    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #-0x1ae
;     return;
700a9f3e: b008         	add	sp, #0x20
700a9f40: bd80         	pop	{r7, pc}
		...
700a9f4e: 0000         	movs	r0, r0

700a9f50 <Udma_rmFreeBlkCopyUhcCh>:
; {
700a9f50: b580         	push	{r7, lr}
700a9f52: b088         	sub	sp, #0x20
700a9f54: 9007         	str	r0, [sp, #0x1c]
700a9f56: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9f58: 9806         	ldr	r0, [sp, #0x18]
700a9f5a: f500 70ea    	add.w	r0, r0, #0x1d4
700a9f5e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9f60: 9806         	ldr	r0, [sp, #0x18]
700a9f62: f500 609f    	add.w	r0, r0, #0x4f8
700a9f66: f04f 31ff    	mov.w	r1, #0xffffffff
700a9f6a: f7fe fbc1    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x187e
;     i = chNum - rmInitPrms->startBlkCopyUhcCh;
700a9f6e: 9807         	ldr	r0, [sp, #0x1c]
700a9f70: 9901         	ldr	r1, [sp, #0x4]
700a9f72: 6809         	ldr	r1, [r1]
700a9f74: 1a40         	subs	r0, r0, r1
700a9f76: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9f78: 9805         	ldr	r0, [sp, #0x14]
700a9f7a: 0940         	lsrs	r0, r0, #0x5
700a9f7c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9f7e: 9805         	ldr	r0, [sp, #0x14]
700a9f80: 9904         	ldr	r1, [sp, #0x10]
700a9f82: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9f86: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9f88: 9903         	ldr	r1, [sp, #0xc]
700a9f8a: 2001         	movs	r0, #0x1
700a9f8c: 4088         	lsls	r0, r1
700a9f8e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyUhcChFlag[offset] |= bitMask;
700a9f90: 9a02         	ldr	r2, [sp, #0x8]
700a9f92: 9806         	ldr	r0, [sp, #0x18]
700a9f94: 9904         	ldr	r1, [sp, #0x10]
700a9f96: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9f9a: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a9f9e: 4310         	orrs	r0, r2
700a9fa0: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a9fa4: 9806         	ldr	r0, [sp, #0x18]
700a9fa6: f500 609f    	add.w	r0, r0, #0x4f8
700a9faa: f7ff fef1    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #-0x21e
;     return;
700a9fae: b008         	add	sp, #0x20
700a9fb0: bd80         	pop	{r7, pc}
		...
700a9fbe: 0000         	movs	r0, r0

700a9fc0 <Udma_rmFreeRxCh>:
; {
700a9fc0: b580         	push	{r7, lr}
700a9fc2: b088         	sub	sp, #0x20
700a9fc4: 9007         	str	r0, [sp, #0x1c]
700a9fc6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9fc8: 9806         	ldr	r0, [sp, #0x18]
700a9fca: f500 70ea    	add.w	r0, r0, #0x1d4
700a9fce: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9fd0: 9806         	ldr	r0, [sp, #0x18]
700a9fd2: f500 609f    	add.w	r0, r0, #0x4f8
700a9fd6: f04f 31ff    	mov.w	r1, #0xffffffff
700a9fda: f7fe fb89    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x18ee
;     i = chNum - rmInitPrms->startRxCh;
700a9fde: 9807         	ldr	r0, [sp, #0x1c]
700a9fe0: 9901         	ldr	r1, [sp, #0x4]
700a9fe2: 6c09         	ldr	r1, [r1, #0x40]
700a9fe4: 1a40         	subs	r0, r0, r1
700a9fe6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700a9fe8: 9805         	ldr	r0, [sp, #0x14]
700a9fea: 0940         	lsrs	r0, r0, #0x5
700a9fec: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700a9fee: 9805         	ldr	r0, [sp, #0x14]
700a9ff0: 9904         	ldr	r1, [sp, #0x10]
700a9ff2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9ff6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700a9ff8: 9903         	ldr	r1, [sp, #0xc]
700a9ffa: 2001         	movs	r0, #0x1
700a9ffc: 4088         	lsls	r0, r1
700a9ffe: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxChFlag[offset] |= bitMask;
700aa000: 9a02         	ldr	r2, [sp, #0x8]
700aa002: 9806         	ldr	r0, [sp, #0x18]
700aa004: 9904         	ldr	r1, [sp, #0x10]
700aa006: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa00a: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700aa00e: 4310         	orrs	r0, r2
700aa010: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa014: 9806         	ldr	r0, [sp, #0x18]
700aa016: f500 609f    	add.w	r0, r0, #0x4f8
700aa01a: f7ff feb9    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #-0x28e
;     return;
700aa01e: b008         	add	sp, #0x20
700aa020: bd80         	pop	{r7, pc}
		...
700aa02e: 0000         	movs	r0, r0

700aa030 <Udma_rmFreeRxHcCh>:
; {
700aa030: b580         	push	{r7, lr}
700aa032: b088         	sub	sp, #0x20
700aa034: 9007         	str	r0, [sp, #0x1c]
700aa036: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa038: 9806         	ldr	r0, [sp, #0x18]
700aa03a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa03e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa040: 9806         	ldr	r0, [sp, #0x18]
700aa042: f500 609f    	add.w	r0, r0, #0x4f8
700aa046: f04f 31ff    	mov.w	r1, #0xffffffff
700aa04a: f7fe fb51    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x195e
;     i = chNum - rmInitPrms->startRxHcCh;
700aa04e: 9807         	ldr	r0, [sp, #0x1c]
700aa050: 9901         	ldr	r1, [sp, #0x4]
700aa052: 6b89         	ldr	r1, [r1, #0x38]
700aa054: 1a40         	subs	r0, r0, r1
700aa056: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa058: 9805         	ldr	r0, [sp, #0x14]
700aa05a: 0940         	lsrs	r0, r0, #0x5
700aa05c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa05e: 9805         	ldr	r0, [sp, #0x14]
700aa060: 9904         	ldr	r1, [sp, #0x10]
700aa062: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa066: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa068: 9903         	ldr	r1, [sp, #0xc]
700aa06a: 2001         	movs	r0, #0x1
700aa06c: 4088         	lsls	r0, r1
700aa06e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxHcChFlag[offset] |= bitMask;
700aa070: 9a02         	ldr	r2, [sp, #0x8]
700aa072: 9806         	ldr	r0, [sp, #0x18]
700aa074: 9904         	ldr	r1, [sp, #0x10]
700aa076: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa07a: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700aa07e: 4310         	orrs	r0, r2
700aa080: f8c1 031c    	str.w	r0, [r1, #0x31c]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa084: 9806         	ldr	r0, [sp, #0x18]
700aa086: f500 609f    	add.w	r0, r0, #0x4f8
700aa08a: f7ff fe81    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #-0x2fe
;     return;
700aa08e: b008         	add	sp, #0x20
700aa090: bd80         	pop	{r7, pc}
		...
700aa09e: 0000         	movs	r0, r0

700aa0a0 <Udma_rmFreeRxUhcCh>:
; {
700aa0a0: b580         	push	{r7, lr}
700aa0a2: b088         	sub	sp, #0x20
700aa0a4: 9007         	str	r0, [sp, #0x1c]
700aa0a6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa0a8: 9806         	ldr	r0, [sp, #0x18]
700aa0aa: f500 70ea    	add.w	r0, r0, #0x1d4
700aa0ae: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa0b0: 9806         	ldr	r0, [sp, #0x18]
700aa0b2: f500 609f    	add.w	r0, r0, #0x4f8
700aa0b6: f04f 31ff    	mov.w	r1, #0xffffffff
700aa0ba: f7fe fb19    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x19ce
;     i = chNum - rmInitPrms->startRxUhcCh;
700aa0be: 9807         	ldr	r0, [sp, #0x1c]
700aa0c0: 9901         	ldr	r1, [sp, #0x4]
700aa0c2: 6b09         	ldr	r1, [r1, #0x30]
700aa0c4: 1a40         	subs	r0, r0, r1
700aa0c6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa0c8: 9805         	ldr	r0, [sp, #0x14]
700aa0ca: 0940         	lsrs	r0, r0, #0x5
700aa0cc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa0ce: 9805         	ldr	r0, [sp, #0x14]
700aa0d0: 9904         	ldr	r1, [sp, #0x10]
700aa0d2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa0d6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa0d8: 9903         	ldr	r1, [sp, #0xc]
700aa0da: 2001         	movs	r0, #0x1
700aa0dc: 4088         	lsls	r0, r1
700aa0de: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxUhcChFlag[offset] |= bitMask;
700aa0e0: 9a02         	ldr	r2, [sp, #0x8]
700aa0e2: 9806         	ldr	r0, [sp, #0x18]
700aa0e4: 9904         	ldr	r1, [sp, #0x10]
700aa0e6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa0ea: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700aa0ee: 4310         	orrs	r0, r2
700aa0f0: f8c1 0320    	str.w	r0, [r1, #0x320]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa0f4: 9806         	ldr	r0, [sp, #0x18]
700aa0f6: f500 609f    	add.w	r0, r0, #0x4f8
700aa0fa: f7ff fe49    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #-0x36e
;     return;
700aa0fe: b008         	add	sp, #0x20
700aa100: bd80         	pop	{r7, pc}
		...
700aa10e: 0000         	movs	r0, r0

700aa110 <Udma_rmFreeTxCh>:
; {
700aa110: b580         	push	{r7, lr}
700aa112: b088         	sub	sp, #0x20
700aa114: 9007         	str	r0, [sp, #0x1c]
700aa116: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa118: 9806         	ldr	r0, [sp, #0x18]
700aa11a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa11e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa120: 9806         	ldr	r0, [sp, #0x18]
700aa122: f500 609f    	add.w	r0, r0, #0x4f8
700aa126: f04f 31ff    	mov.w	r1, #0xffffffff
700aa12a: f7fe fae1    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x1a3e
;     i = chNum - rmInitPrms->startTxCh;
700aa12e: 9807         	ldr	r0, [sp, #0x1c]
700aa130: 9901         	ldr	r1, [sp, #0x4]
700aa132: 6a89         	ldr	r1, [r1, #0x28]
700aa134: 1a40         	subs	r0, r0, r1
700aa136: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa138: 9805         	ldr	r0, [sp, #0x14]
700aa13a: 0940         	lsrs	r0, r0, #0x5
700aa13c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa13e: 9805         	ldr	r0, [sp, #0x14]
700aa140: 9904         	ldr	r1, [sp, #0x10]
700aa142: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa146: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa148: 9903         	ldr	r1, [sp, #0xc]
700aa14a: 2001         	movs	r0, #0x1
700aa14c: 4088         	lsls	r0, r1
700aa14e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txChFlag[offset] |= bitMask;
700aa150: 9a02         	ldr	r2, [sp, #0x8]
700aa152: 9806         	ldr	r0, [sp, #0x18]
700aa154: 9904         	ldr	r1, [sp, #0x10]
700aa156: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa15a: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700aa15e: 4310         	orrs	r0, r2
700aa160: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa164: 9806         	ldr	r0, [sp, #0x18]
700aa166: f500 609f    	add.w	r0, r0, #0x4f8
700aa16a: f7ff fe11    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #-0x3de
;     return;
700aa16e: b008         	add	sp, #0x20
700aa170: bd80         	pop	{r7, pc}
		...
700aa17e: 0000         	movs	r0, r0

700aa180 <Udma_rmFreeTxHcCh>:
; {
700aa180: b580         	push	{r7, lr}
700aa182: b088         	sub	sp, #0x20
700aa184: 9007         	str	r0, [sp, #0x1c]
700aa186: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa188: 9806         	ldr	r0, [sp, #0x18]
700aa18a: f500 70ea    	add.w	r0, r0, #0x1d4
700aa18e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa190: 9806         	ldr	r0, [sp, #0x18]
700aa192: f500 609f    	add.w	r0, r0, #0x4f8
700aa196: f04f 31ff    	mov.w	r1, #0xffffffff
700aa19a: f7fe faa9    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x1aae
;     i = chNum - rmInitPrms->startTxHcCh;
700aa19e: 9807         	ldr	r0, [sp, #0x1c]
700aa1a0: 9901         	ldr	r1, [sp, #0x4]
700aa1a2: 6a09         	ldr	r1, [r1, #0x20]
700aa1a4: 1a40         	subs	r0, r0, r1
700aa1a6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa1a8: 9805         	ldr	r0, [sp, #0x14]
700aa1aa: 0940         	lsrs	r0, r0, #0x5
700aa1ac: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa1ae: 9805         	ldr	r0, [sp, #0x14]
700aa1b0: 9904         	ldr	r1, [sp, #0x10]
700aa1b2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa1b6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa1b8: 9903         	ldr	r1, [sp, #0xc]
700aa1ba: 2001         	movs	r0, #0x1
700aa1bc: 4088         	lsls	r0, r1
700aa1be: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txHcChFlag[offset] |= bitMask;
700aa1c0: 9a02         	ldr	r2, [sp, #0x8]
700aa1c2: 9806         	ldr	r0, [sp, #0x18]
700aa1c4: 9904         	ldr	r1, [sp, #0x10]
700aa1c6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa1ca: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700aa1ce: 4310         	orrs	r0, r2
700aa1d0: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa1d4: 9806         	ldr	r0, [sp, #0x18]
700aa1d6: f500 609f    	add.w	r0, r0, #0x4f8
700aa1da: f7ff fdd9    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #-0x44e
;     return;
700aa1de: b008         	add	sp, #0x20
700aa1e0: bd80         	pop	{r7, pc}
		...
700aa1ee: 0000         	movs	r0, r0

700aa1f0 <Udma_rmFreeTxUhcCh>:
; {
700aa1f0: b580         	push	{r7, lr}
700aa1f2: b088         	sub	sp, #0x20
700aa1f4: 9007         	str	r0, [sp, #0x1c]
700aa1f6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700aa1f8: 9806         	ldr	r0, [sp, #0x18]
700aa1fa: f500 70ea    	add.w	r0, r0, #0x1d4
700aa1fe: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa200: 9806         	ldr	r0, [sp, #0x18]
700aa202: f500 609f    	add.w	r0, r0, #0x4f8
700aa206: f04f 31ff    	mov.w	r1, #0xffffffff
700aa20a: f7fe fa71    	bl	0x700a86f0 <SemaphoreP_pend> @ imm = #-0x1b1e
;     i = chNum - rmInitPrms->startTxUhcCh;
700aa20e: 9807         	ldr	r0, [sp, #0x1c]
700aa210: 9901         	ldr	r1, [sp, #0x4]
700aa212: 6989         	ldr	r1, [r1, #0x18]
700aa214: 1a40         	subs	r0, r0, r1
700aa216: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700aa218: 9805         	ldr	r0, [sp, #0x14]
700aa21a: 0940         	lsrs	r0, r0, #0x5
700aa21c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700aa21e: 9805         	ldr	r0, [sp, #0x14]
700aa220: 9904         	ldr	r1, [sp, #0x10]
700aa222: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700aa226: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700aa228: 9903         	ldr	r1, [sp, #0xc]
700aa22a: 2001         	movs	r0, #0x1
700aa22c: 4088         	lsls	r0, r1
700aa22e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txUhcChFlag[offset] |= bitMask;
700aa230: 9a02         	ldr	r2, [sp, #0x8]
700aa232: 9806         	ldr	r0, [sp, #0x18]
700aa234: 9904         	ldr	r1, [sp, #0x10]
700aa236: eb00 0181    	add.w	r1, r0, r1, lsl #2
700aa23a: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700aa23e: 4310         	orrs	r0, r2
700aa240: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa244: 9806         	ldr	r0, [sp, #0x18]
700aa246: f500 609f    	add.w	r0, r0, #0x4f8
700aa24a: f7ff fda1    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #-0x4be
;     return;
700aa24e: b008         	add	sp, #0x20
700aa250: bd80         	pop	{r7, pc}
		...
700aa25e: 0000         	movs	r0, r0

700aa260 <UART_getChar>:
; {
700aa260: b580         	push	{r7, lr}
700aa262: b086         	sub	sp, #0x18
700aa264: 9005         	str	r0, [sp, #0x14]
700aa266: 9104         	str	r1, [sp, #0x10]
700aa268: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700aa26a: 9003         	str	r0, [sp, #0xc]
;     uint32_t retVal      = FALSE;
700aa26c: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700aa26e: 9805         	ldr	r0, [sp, #0x14]
700aa270: 300c         	adds	r0, #0xc
700aa272: f003 f9dd    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x33ba
700aa276: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700aa278: 9805         	ldr	r0, [sp, #0x14]
700aa27a: 300c         	adds	r0, #0xc
700aa27c: 9000         	str	r0, [sp]
700aa27e: f003 f9d7    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x33ae
700aa282: 4601         	mov	r1, r0
700aa284: 9800         	ldr	r0, [sp]
700aa286: f001 017f    	and	r1, r1, #0x7f
700aa28a: f003 f9d9    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x33b2
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700aa28e: 9805         	ldr	r0, [sp, #0x14]
700aa290: 3014         	adds	r0, #0x14
700aa292: f003 f9cd    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x339a
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700aa296: 07c0         	lsls	r0, r0, #0x1f
700aa298: b150         	cbz	r0, 0x700aa2b0 <UART_getChar+0x50> @ imm = #0x14
700aa29a: e7ff         	b	0x700aa29c <UART_getChar+0x3c> @ imm = #-0x2
;         uint32_t tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700aa29c: 9805         	ldr	r0, [sp, #0x14]
700aa29e: f003 f9c7    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x338e
700aa2a2: 9001         	str	r0, [sp, #0x4]
;         *pChar = (uint8_t)tempRetVal;
700aa2a4: 9801         	ldr	r0, [sp, #0x4]
700aa2a6: 9904         	ldr	r1, [sp, #0x10]
700aa2a8: 7008         	strb	r0, [r1]
700aa2aa: 2001         	movs	r0, #0x1
;         retVal = TRUE;
700aa2ac: 9002         	str	r0, [sp, #0x8]
;     }
700aa2ae: e7ff         	b	0x700aa2b0 <UART_getChar+0x50> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa2b0: 9805         	ldr	r0, [sp, #0x14]
700aa2b2: 300c         	adds	r0, #0xc
700aa2b4: 9903         	ldr	r1, [sp, #0xc]
700aa2b6: f003 f9c3    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x3386
;     return retVal;
700aa2ba: 9802         	ldr	r0, [sp, #0x8]
700aa2bc: b006         	add	sp, #0x18
700aa2be: bd80         	pop	{r7, pc}

700aa2c0 <UART_writeData>:
; {
700aa2c0: b580         	push	{r7, lr}
700aa2c2: b086         	sub	sp, #0x18
700aa2c4: 9005         	str	r0, [sp, #0x14]
700aa2c6: 9104         	str	r1, [sp, #0x10]
;     UARTLLD_InitHandle hUartInit = hUart->hUartInit;
700aa2c8: 9805         	ldr	r0, [sp, #0x14]
700aa2ca: 6840         	ldr	r0, [r0, #0x4]
700aa2cc: 9001         	str	r0, [sp, #0x4]
;     numBytesToTransfer = writeSizeRemaining;
700aa2ce: 9804         	ldr	r0, [sp, #0x10]
700aa2d0: 9003         	str	r0, [sp, #0xc]
;     if (numBytesToTransfer >= hUartInit->txTrigLvl)
700aa2d2: 9803         	ldr	r0, [sp, #0xc]
700aa2d4: 9901         	ldr	r1, [sp, #0x4]
700aa2d6: 6bc9         	ldr	r1, [r1, #0x3c]
700aa2d8: 4288         	cmp	r0, r1
700aa2da: d304         	blo	0x700aa2e6 <UART_writeData+0x26> @ imm = #0x8
700aa2dc: e7ff         	b	0x700aa2de <UART_writeData+0x1e> @ imm = #-0x2
;         numBytesToTransfer = hUartInit->txTrigLvl;
700aa2de: 9801         	ldr	r0, [sp, #0x4]
700aa2e0: 6bc0         	ldr	r0, [r0, #0x3c]
700aa2e2: 9003         	str	r0, [sp, #0xc]
;     }
700aa2e4: e7ff         	b	0x700aa2e6 <UART_writeData+0x26> @ imm = #-0x2
;     numBytesToTransferred = numBytesToTransfer;
700aa2e6: 9803         	ldr	r0, [sp, #0xc]
700aa2e8: 9002         	str	r0, [sp, #0x8]
;     while (numBytesToTransfer != 0U)
700aa2ea: e7ff         	b	0x700aa2ec <UART_writeData+0x2c> @ imm = #-0x2
700aa2ec: 9803         	ldr	r0, [sp, #0xc]
700aa2ee: b190         	cbz	r0, 0x700aa316 <UART_writeData+0x56> @ imm = #0x24
700aa2f0: e7ff         	b	0x700aa2f2 <UART_writeData+0x32> @ imm = #-0x2
;         UART_putChar(hUart->baseAddr, *(const uint8_t *)hUart->writeBuf);
700aa2f2: 9905         	ldr	r1, [sp, #0x14]
700aa2f4: 6808         	ldr	r0, [r1]
700aa2f6: 6889         	ldr	r1, [r1, #0x8]
700aa2f8: 7809         	ldrb	r1, [r1]
700aa2fa: f002 ffd1    	bl	0x700ad2a0 <UART_putChar> @ imm = #0x2fa2
;         hUart->writeBuf = (const uint8_t *)hUart->writeBuf + 1U;
700aa2fe: 9905         	ldr	r1, [sp, #0x14]
700aa300: 6888         	ldr	r0, [r1, #0x8]
700aa302: 3001         	adds	r0, #0x1
700aa304: 6088         	str	r0, [r1, #0x8]
;         numBytesToTransfer--;
700aa306: 9803         	ldr	r0, [sp, #0xc]
700aa308: 3801         	subs	r0, #0x1
700aa30a: 9003         	str	r0, [sp, #0xc]
;         hUart->writeCount++;
700aa30c: 9905         	ldr	r1, [sp, #0x14]
700aa30e: 68c8         	ldr	r0, [r1, #0xc]
700aa310: 3001         	adds	r0, #0x1
700aa312: 60c8         	str	r0, [r1, #0xc]
;     while (numBytesToTransfer != 0U)
700aa314: e7ea         	b	0x700aa2ec <UART_writeData+0x2c> @ imm = #-0x2c
;     return (writeSizeRemaining - numBytesToTransferred);
700aa316: 9804         	ldr	r0, [sp, #0x10]
700aa318: 9902         	ldr	r1, [sp, #0x8]
700aa31a: 1a40         	subs	r0, r0, r1
700aa31c: b006         	add	sp, #0x18
700aa31e: bd80         	pop	{r7, pc}

700aa320 <Udma_virtToPhyFxn>:
; {
700aa320: b580         	push	{r7, lr}
700aa322: b088         	sub	sp, #0x20
700aa324: 9007         	str	r0, [sp, #0x1c]
700aa326: 9106         	str	r1, [sp, #0x18]
700aa328: 9205         	str	r2, [sp, #0x14]
700aa32a: 2000         	movs	r0, #0x0
700aa32c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700aa330: 9004         	str	r0, [sp, #0x10]
700aa332: 2000         	movs	r0, #0x0
;     void               *appData = NULL_PTR;
700aa334: 9003         	str	r0, [sp, #0xc]
;     if(NULL_PTR != chHandle)
700aa336: 9805         	ldr	r0, [sp, #0x14]
700aa338: b138         	cbz	r0, 0x700aa34a <Udma_virtToPhyFxn+0x2a> @ imm = #0xe
700aa33a: e7ff         	b	0x700aa33c <Udma_virtToPhyFxn+0x1c> @ imm = #-0x2
;         chNum   = chHandle->chPrms.chNum;
700aa33c: 9805         	ldr	r0, [sp, #0x14]
700aa33e: 6840         	ldr	r0, [r0, #0x4]
700aa340: 9004         	str	r0, [sp, #0x10]
;         appData = chHandle->chPrms.appData;
700aa342: 9805         	ldr	r0, [sp, #0x14]
700aa344: 6900         	ldr	r0, [r0, #0x10]
700aa346: 9003         	str	r0, [sp, #0xc]
;     }
700aa348: e7ff         	b	0x700aa34a <Udma_virtToPhyFxn+0x2a> @ imm = #-0x2
;     if((Udma_VirtToPhyFxn) NULL_PTR != drvHandle->initPrms.virtToPhyFxn)
700aa34a: 9806         	ldr	r0, [sp, #0x18]
700aa34c: f8d0 01cc    	ldr.w	r0, [r0, #0x1cc]
700aa350: b150         	cbz	r0, 0x700aa368 <Udma_virtToPhyFxn+0x48> @ imm = #0x14
700aa352: e7ff         	b	0x700aa354 <Udma_virtToPhyFxn+0x34> @ imm = #-0x2
;         phyAddr = drvHandle->initPrms.virtToPhyFxn(virtAddr, chNum, appData);
700aa354: 9806         	ldr	r0, [sp, #0x18]
700aa356: f8d0 31cc    	ldr.w	r3, [r0, #0x1cc]
700aa35a: 9807         	ldr	r0, [sp, #0x1c]
700aa35c: 9904         	ldr	r1, [sp, #0x10]
700aa35e: 9a03         	ldr	r2, [sp, #0xc]
700aa360: 4798         	blx	r3
700aa362: 9101         	str	r1, [sp, #0x4]
700aa364: 9000         	str	r0, [sp]
;     }
700aa366: e007         	b	0x700aa378 <Udma_virtToPhyFxn+0x58> @ imm = #0xe
;         phyAddr = Udma_defaultVirtToPhyFxn(virtAddr, chNum, appData);
700aa368: 9807         	ldr	r0, [sp, #0x1c]
700aa36a: 9904         	ldr	r1, [sp, #0x10]
700aa36c: 9a03         	ldr	r2, [sp, #0xc]
700aa36e: f003 f96f    	bl	0x700ad650 <Udma_defaultVirtToPhyFxn> @ imm = #0x32de
700aa372: 9101         	str	r1, [sp, #0x4]
700aa374: 9000         	str	r0, [sp]
700aa376: e7ff         	b	0x700aa378 <Udma_virtToPhyFxn+0x58> @ imm = #-0x2
;     return (phyAddr);
700aa378: 9800         	ldr	r0, [sp]
700aa37a: 9901         	ldr	r1, [sp, #0x4]
700aa37c: b008         	add	sp, #0x20
700aa37e: bd80         	pop	{r7, pc}

700aa380 <Sciclient_pmSetModuleRst>:
; {
700aa380: b580         	push	{r7, lr}
700aa382: b090         	sub	sp, #0x40
700aa384: 900f         	str	r0, [sp, #0x3c]
700aa386: 910e         	str	r1, [sp, #0x38]
700aa388: 920d         	str	r2, [sp, #0x34]
700aa38a: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700aa38c: 900c         	str	r0, [sp, #0x30]
;     request.id     = (uint32_t) moduleId;
700aa38e: 990f         	ldr	r1, [sp, #0x3c]
700aa390: 910a         	str	r1, [sp, #0x28]
;     request.resets = (uint32_t) resetBit;
700aa392: 990e         	ldr	r1, [sp, #0x38]
700aa394: 910b         	str	r1, [sp, #0x2c]
700aa396: f240 2102    	movw	r1, #0x202
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE_RESETS;
700aa39a: f8ad 100c    	strh.w	r1, [sp, #0xc]
700aa39e: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700aa3a0: 9104         	str	r1, [sp, #0x10]
700aa3a2: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700aa3a4: 9105         	str	r1, [sp, #0x14]
700aa3a6: 2110         	movs	r1, #0x10
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700aa3a8: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700aa3aa: 990d         	ldr	r1, [sp, #0x34]
700aa3ac: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700aa3ae: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700aa3b0: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700aa3b2: 9002         	str	r0, [sp, #0x8]
700aa3b4: a803         	add	r0, sp, #0xc
700aa3b6: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700aa3b8: f7f1 fd62    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xe53c
700aa3bc: 900c         	str	r0, [sp, #0x30]
;     if((retVal != SystemP_SUCCESS) ||
700aa3be: 980c         	ldr	r0, [sp, #0x30]
700aa3c0: b930         	cbnz	r0, 0x700aa3d0 <Sciclient_pmSetModuleRst+0x50> @ imm = #0xc
700aa3c2: e7ff         	b	0x700aa3c4 <Sciclient_pmSetModuleRst+0x44> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700aa3c4: 9800         	ldr	r0, [sp]
700aa3c6: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700aa3ca: 2802         	cmp	r0, #0x2
700aa3cc: d004         	beq	0x700aa3d8 <Sciclient_pmSetModuleRst+0x58> @ imm = #0x8
700aa3ce: e7ff         	b	0x700aa3d0 <Sciclient_pmSetModuleRst+0x50> @ imm = #-0x2
700aa3d0: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700aa3d4: 900c         	str	r0, [sp, #0x30]
;     }
700aa3d6: e7ff         	b	0x700aa3d8 <Sciclient_pmSetModuleRst+0x58> @ imm = #-0x2
;     return retVal;
700aa3d8: 980c         	ldr	r0, [sp, #0x30]
700aa3da: b010         	add	sp, #0x40
700aa3dc: bd80         	pop	{r7, pc}
700aa3de: 0000         	movs	r0, r0

700aa3e0 <Sciclient_rmIaGetInst>:
; {
700aa3e0: b083         	sub	sp, #0xc
700aa3e2: f8ad 000a    	strh.w	r0, [sp, #0xa]
700aa3e6: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIaInst *inst = NULL;
700aa3e8: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700aa3ea: f8ad 0002    	strh.w	r0, [sp, #0x2]
700aa3ee: e7ff         	b	0x700aa3f0 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x2
700aa3f0: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700aa3f4: 2800         	cmp	r0, #0x0
700aa3f6: dc1e         	bgt	0x700aa436 <Sciclient_rmIaGetInst+0x56> @ imm = #0x3c
700aa3f8: e7ff         	b	0x700aa3fa <Sciclient_rmIaGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIaInstances[i].dev_id) {
700aa3fa: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700aa3fe: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700aa402: 014a         	lsls	r2, r1, #0x5
700aa404: f240 01c4    	movw	r1, #0xc4
700aa408: f2c7 010b    	movt	r1, #0x700b
700aa40c: 5a89         	ldrh	r1, [r1, r2]
700aa40e: 4288         	cmp	r0, r1
700aa410: d10a         	bne	0x700aa428 <Sciclient_rmIaGetInst+0x48> @ imm = #0x14
700aa412: e7ff         	b	0x700aa414 <Sciclient_rmIaGetInst+0x34> @ imm = #-0x2
;             inst = &gRmIaInstances[i];
700aa414: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700aa418: f240 00c4    	movw	r0, #0xc4
700aa41c: f2c7 000b    	movt	r0, #0x700b
700aa420: eb00 1041    	add.w	r0, r0, r1, lsl #5
700aa424: 9001         	str	r0, [sp, #0x4]
;             break;
700aa426: e006         	b	0x700aa436 <Sciclient_rmIaGetInst+0x56> @ imm = #0xc
;     }
700aa428: e7ff         	b	0x700aa42a <Sciclient_rmIaGetInst+0x4a> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700aa42a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700aa42e: 3001         	adds	r0, #0x1
700aa430: f8ad 0002    	strh.w	r0, [sp, #0x2]
700aa434: e7dc         	b	0x700aa3f0 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x48
;     return inst;
700aa436: 9801         	ldr	r0, [sp, #0x4]
700aa438: b003         	add	sp, #0xc
700aa43a: 4770         	bx	lr
700aa43c: 0000         	movs	r0, r0
700aa43e: 0000         	movs	r0, r0

700aa440 <Sciclient_rmPsPush>:
; {
700aa440: b083         	sub	sp, #0xc
700aa442: 9002         	str	r0, [sp, #0x8]
700aa444: f8ad 1006    	strh.w	r1, [sp, #0x6]
700aa448: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700aa44a: 9000         	str	r0, [sp]
;     if ((gPstack.psp < SCICLIENT_PS_MAX_DEPTH) && (n != NULL)) {
700aa44c: f241 0058    	movw	r0, #0x1058
700aa450: f2c7 0008    	movt	r0, #0x7008
700aa454: 8c80         	ldrh	r0, [r0, #0x24]
700aa456: 2802         	cmp	r0, #0x2
700aa458: dc19         	bgt	0x700aa48e <Sciclient_rmPsPush+0x4e> @ imm = #0x32
700aa45a: e7ff         	b	0x700aa45c <Sciclient_rmPsPush+0x1c> @ imm = #-0x2
700aa45c: 9802         	ldr	r0, [sp, #0x8]
700aa45e: b1b0         	cbz	r0, 0x700aa48e <Sciclient_rmPsPush+0x4e> @ imm = #0x2c
700aa460: e7ff         	b	0x700aa462 <Sciclient_rmPsPush+0x22> @ imm = #-0x2
;         gPstack.ps[gPstack.psp].p_n = n;
700aa462: 9802         	ldr	r0, [sp, #0x8]
700aa464: f241 0158    	movw	r1, #0x1058
700aa468: f2c7 0108    	movt	r1, #0x7008
700aa46c: 8c8a         	ldrh	r2, [r1, #0x24]
700aa46e: eb02 0242    	add.w	r2, r2, r2, lsl #1
700aa472: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = if_idx;
700aa476: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700aa47a: 8c8a         	ldrh	r2, [r1, #0x24]
700aa47c: eb02 0242    	add.w	r2, r2, r2, lsl #1
700aa480: eb01 0282    	add.w	r2, r1, r2, lsl #2
700aa484: 8090         	strh	r0, [r2, #0x4]
;         gPstack.psp++;
700aa486: 8c88         	ldrh	r0, [r1, #0x24]
700aa488: 3001         	adds	r0, #0x1
700aa48a: 8488         	strh	r0, [r1, #0x24]
;     } else {
700aa48c: e003         	b	0x700aa496 <Sciclient_rmPsPush+0x56> @ imm = #0x6
700aa48e: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa492: 9000         	str	r0, [sp]
700aa494: e7ff         	b	0x700aa496 <Sciclient_rmPsPush+0x56> @ imm = #-0x2
;     return r;
700aa496: 9800         	ldr	r0, [sp]
700aa498: b003         	add	sp, #0xc
700aa49a: 4770         	bx	lr
700aa49c: 0000         	movs	r0, r0
700aa49e: 0000         	movs	r0, r0

700aa4a0 <UART_lld_deInit>:
; {
700aa4a0: b580         	push	{r7, lr}
700aa4a2: b084         	sub	sp, #0x10
700aa4a4: 9003         	str	r0, [sp, #0xc]
700aa4a6: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700aa4a8: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700aa4aa: 9803         	ldr	r0, [sp, #0xc]
700aa4ac: b1f8         	cbz	r0, 0x700aa4ee <UART_lld_deInit+0x4e> @ imm = #0x3e
700aa4ae: e7ff         	b	0x700aa4b0 <UART_lld_deInit+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700aa4b0: 9903         	ldr	r1, [sp, #0xc]
700aa4b2: 2002         	movs	r0, #0x2
700aa4b4: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700aa4b6: 9803         	ldr	r0, [sp, #0xc]
700aa4b8: f7fd ffb2    	bl	0x700a8420 <UART_lld_flushTxFifo> @ imm = #-0x209c
700aa4bc: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700aa4be: 9802         	ldr	r0, [sp, #0x8]
700aa4c0: b988         	cbnz	r0, 0x700aa4e6 <UART_lld_deInit+0x46> @ imm = #0x22
700aa4c2: e7ff         	b	0x700aa4c4 <UART_lld_deInit+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700aa4c4: 9803         	ldr	r0, [sp, #0xc]
700aa4c6: 6800         	ldr	r0, [r0]
700aa4c8: 2107         	movs	r1, #0x7
700aa4ca: 9101         	str	r1, [sp, #0x4]
700aa4cc: f7f9 ff58    	bl	0x700a4380 <UART_intrDisable> @ imm = #-0x6150
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700aa4d0: 9803         	ldr	r0, [sp, #0xc]
700aa4d2: 6800         	ldr	r0, [r0]
700aa4d4: 2102         	movs	r1, #0x2
700aa4d6: f002 fa53    	bl	0x700ac980 <UART_intr2Disable> @ imm = #0x24a6
700aa4da: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700aa4dc: 9803         	ldr	r0, [sp, #0xc]
700aa4de: 6800         	ldr	r0, [r0]
700aa4e0: f002 fa96    	bl	0x700aca10 <UART_operatingModeSelect> @ imm = #0x252c
;         }
700aa4e4: e7ff         	b	0x700aa4e6 <UART_lld_deInit+0x46> @ imm = #-0x2
;         hUart->state = UART_STATE_RESET;
700aa4e6: 9903         	ldr	r1, [sp, #0xc]
700aa4e8: 2000         	movs	r0, #0x0
700aa4ea: 6548         	str	r0, [r1, #0x54]
;     }
700aa4ec: e003         	b	0x700aa4f6 <UART_lld_deInit+0x56> @ imm = #0x6
700aa4ee: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700aa4f2: 9002         	str	r0, [sp, #0x8]
700aa4f4: e7ff         	b	0x700aa4f6 <UART_lld_deInit+0x56> @ imm = #-0x2
;     return status;
700aa4f6: 9802         	ldr	r0, [sp, #0x8]
700aa4f8: b004         	add	sp, #0x10
700aa4fa: bd80         	pop	{r7, pc}
700aa4fc: 0000         	movs	r0, r0
700aa4fe: 0000         	movs	r0, r0

700aa500 <UART_lld_writeCompleteCallback>:
; {
700aa500: b580         	push	{r7, lr}
700aa502: b086         	sub	sp, #0x18
700aa504: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700aa506: 9805         	ldr	r0, [sp, #0x14]
700aa508: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700aa50a: 9802         	ldr	r0, [sp, #0x8]
700aa50c: b320         	cbz	r0, 0x700aa558 <UART_lld_writeCompleteCallback+0x58> @ imm = #0x48
700aa50e: e7ff         	b	0x700aa510 <UART_lld_writeCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700aa510: 9802         	ldr	r0, [sp, #0x8]
700aa512: 6e00         	ldr	r0, [r0, #0x60]
700aa514: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700aa516: 9801         	ldr	r0, [sp, #0x4]
700aa518: b1e8         	cbz	r0, 0x700aa556 <UART_lld_writeCompleteCallback+0x56> @ imm = #0x3a
700aa51a: e7ff         	b	0x700aa51c <UART_lld_writeCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700aa51c: 9801         	ldr	r0, [sp, #0x4]
700aa51e: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700aa520: 9804         	ldr	r0, [sp, #0x10]
700aa522: 6840         	ldr	r0, [r0, #0x4]
700aa524: 9003         	str	r0, [sp, #0xc]
;             obj->writeTrans->count = hUart->writeTrans.count;
700aa526: 9802         	ldr	r0, [sp, #0x8]
700aa528: 6c00         	ldr	r0, [r0, #0x40]
700aa52a: 9903         	ldr	r1, [sp, #0xc]
700aa52c: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700aa530: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.writeMode == UART_TRANSFER_MODE_CALLBACK)
700aa532: 9803         	ldr	r0, [sp, #0xc]
700aa534: 69c0         	ldr	r0, [r0, #0x1c]
700aa536: 2801         	cmp	r0, #0x1
700aa538: d107         	bne	0x700aa54a <UART_lld_writeCompleteCallback+0x4a> @ imm = #0xe
700aa53a: e7ff         	b	0x700aa53c <UART_lld_writeCompleteCallback+0x3c> @ imm = #-0x2
;                 obj->prms.writeCallbackFxn(hUart, &hUart->writeTrans);
700aa53c: 9803         	ldr	r0, [sp, #0xc]
700aa53e: 6a42         	ldr	r2, [r0, #0x24]
700aa540: 9802         	ldr	r0, [sp, #0x8]
700aa542: f100 013c    	add.w	r1, r0, #0x3c
700aa546: 4790         	blx	r2
;             }
700aa548: e004         	b	0x700aa554 <UART_lld_writeCompleteCallback+0x54> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->writeTransferMutex);
700aa54a: 9802         	ldr	r0, [sp, #0x8]
700aa54c: 6dc0         	ldr	r0, [r0, #0x5c]
700aa54e: f7ff fc1f    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #-0x7c2
700aa552: e7ff         	b	0x700aa554 <UART_lld_writeCompleteCallback+0x54> @ imm = #-0x2
;         }
700aa554: e7ff         	b	0x700aa556 <UART_lld_writeCompleteCallback+0x56> @ imm = #-0x2
;     }
700aa556: e7ff         	b	0x700aa558 <UART_lld_writeCompleteCallback+0x58> @ imm = #-0x2
; }
700aa558: b006         	add	sp, #0x18
700aa55a: bd80         	pop	{r7, pc}
700aa55c: 0000         	movs	r0, r0
700aa55e: 0000         	movs	r0, r0

700aa560 <Sciclient_rmIaValidateGlobalEvt>:
; {
700aa560: b580         	push	{r7, lr}
700aa562: b086         	sub	sp, #0x18
700aa564: f8ad 0016    	strh.w	r0, [sp, #0x16]
700aa568: f8ad 1014    	strh.w	r1, [sp, #0x14]
700aa56c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700aa56e: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700aa570: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700aa572: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700aa576: f7ff ff33    	bl	0x700aa3e0 <Sciclient_rmIaGetInst> @ imm = #-0x19a
700aa57a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700aa57c: 9803         	ldr	r0, [sp, #0xc]
700aa57e: b920         	cbnz	r0, 0x700aa58a <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #0x8
700aa580: e7ff         	b	0x700aa582 <Sciclient_rmIaValidateGlobalEvt+0x22> @ imm = #-0x2
700aa582: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700aa586: 9004         	str	r0, [sp, #0x10]
;     }
700aa588: e7ff         	b	0x700aa58a <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700aa58a: 9804         	ldr	r0, [sp, #0x10]
700aa58c: b990         	cbnz	r0, 0x700aa5b4 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #0x24
700aa58e: e7ff         	b	0x700aa590 <Sciclient_rmIaValidateGlobalEvt+0x30> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700aa590: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700aa594: 9903         	ldr	r1, [sp, #0xc]
700aa596: 8909         	ldrh	r1, [r1, #0x8]
700aa598: 1a40         	subs	r0, r0, r1
700aa59a: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         r = Sciclient_rmIaValidateEvt(inst, evt, 0u, 0u, false);
700aa59e: 9803         	ldr	r0, [sp, #0xc]
700aa5a0: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700aa5a4: 466a         	mov	r2, sp
700aa5a6: 2300         	movs	r3, #0x0
700aa5a8: 6013         	str	r3, [r2]
700aa5aa: 461a         	mov	r2, r3
700aa5ac: f7f8 f920    	bl	0x700a27f0 <Sciclient_rmIaValidateEvt> @ imm = #-0x7dc0
700aa5b0: 9004         	str	r0, [sp, #0x10]
;     }
700aa5b2: e7ff         	b	0x700aa5b4 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #-0x2
;     return r;
700aa5b4: 9804         	ldr	r0, [sp, #0x10]
700aa5b6: b006         	add	sp, #0x18
700aa5b8: bd80         	pop	{r7, pc}
700aa5ba: 0000         	movs	r0, r0
700aa5bc: 0000         	movs	r0, r0
700aa5be: 0000         	movs	r0, r0

700aa5c0 <UART_lld_readCompleteCallback>:
; {
700aa5c0: b580         	push	{r7, lr}
700aa5c2: b086         	sub	sp, #0x18
700aa5c4: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700aa5c6: 9805         	ldr	r0, [sp, #0x14]
700aa5c8: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700aa5ca: 9802         	ldr	r0, [sp, #0x8]
700aa5cc: b318         	cbz	r0, 0x700aa616 <UART_lld_readCompleteCallback+0x56> @ imm = #0x46
700aa5ce: e7ff         	b	0x700aa5d0 <UART_lld_readCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700aa5d0: 9802         	ldr	r0, [sp, #0x8]
700aa5d2: 6e00         	ldr	r0, [r0, #0x60]
700aa5d4: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700aa5d6: 9801         	ldr	r0, [sp, #0x4]
700aa5d8: b1e0         	cbz	r0, 0x700aa614 <UART_lld_readCompleteCallback+0x54> @ imm = #0x38
700aa5da: e7ff         	b	0x700aa5dc <UART_lld_readCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700aa5dc: 9801         	ldr	r0, [sp, #0x4]
700aa5de: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700aa5e0: 9804         	ldr	r0, [sp, #0x10]
700aa5e2: 6840         	ldr	r0, [r0, #0x4]
700aa5e4: 9003         	str	r0, [sp, #0xc]
;             obj->readTrans->count = hUart->readTrans.count;
700aa5e6: 9802         	ldr	r0, [sp, #0x8]
700aa5e8: 6ac0         	ldr	r0, [r0, #0x2c]
700aa5ea: 9903         	ldr	r1, [sp, #0xc]
700aa5ec: 6fc9         	ldr	r1, [r1, #0x7c]
700aa5ee: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.readMode == UART_TRANSFER_MODE_CALLBACK)
700aa5f0: 9803         	ldr	r0, [sp, #0xc]
700aa5f2: 6940         	ldr	r0, [r0, #0x14]
700aa5f4: 2801         	cmp	r0, #0x1
700aa5f6: d107         	bne	0x700aa608 <UART_lld_readCompleteCallback+0x48> @ imm = #0xe
700aa5f8: e7ff         	b	0x700aa5fa <UART_lld_readCompleteCallback+0x3a> @ imm = #-0x2
;                 obj->prms.readCallbackFxn(hUart, &hUart->readTrans);
700aa5fa: 9803         	ldr	r0, [sp, #0xc]
700aa5fc: 6a02         	ldr	r2, [r0, #0x20]
700aa5fe: 9802         	ldr	r0, [sp, #0x8]
700aa600: f100 0128    	add.w	r1, r0, #0x28
700aa604: 4790         	blx	r2
;             }
700aa606: e004         	b	0x700aa612 <UART_lld_readCompleteCallback+0x52> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->readTransferMutex);
700aa608: 9802         	ldr	r0, [sp, #0x8]
700aa60a: 6d80         	ldr	r0, [r0, #0x58]
700aa60c: f7ff fbc0    	bl	0x700a9d90 <SemaphoreP_post> @ imm = #-0x880
700aa610: e7ff         	b	0x700aa612 <UART_lld_readCompleteCallback+0x52> @ imm = #-0x2
;         }
700aa612: e7ff         	b	0x700aa614 <UART_lld_readCompleteCallback+0x54> @ imm = #-0x2
;     }
700aa614: e7ff         	b	0x700aa616 <UART_lld_readCompleteCallback+0x56> @ imm = #-0x2
; }
700aa616: b006         	add	sp, #0x18
700aa618: bd80         	pop	{r7, pc}
700aa61a: 0000         	movs	r0, r0
700aa61c: 0000         	movs	r0, r0
700aa61e: 0000         	movs	r0, r0

700aa620 <UART_regConfigModeEnable>:
; {
700aa620: b580         	push	{r7, lr}
700aa622: b086         	sub	sp, #0x18
700aa624: 9005         	str	r0, [sp, #0x14]
700aa626: 9104         	str	r1, [sp, #0x10]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700aa628: 9805         	ldr	r0, [sp, #0x14]
700aa62a: 300c         	adds	r0, #0xc
700aa62c: f003 f800    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x3000
700aa630: 9003         	str	r0, [sp, #0xc]
;     switch (modeFlag)
700aa632: 9804         	ldr	r0, [sp, #0x10]
700aa634: 9002         	str	r0, [sp, #0x8]
700aa636: 287f         	cmp	r0, #0x7f
700aa638: d00f         	beq	0x700aa65a <UART_regConfigModeEnable+0x3a> @ imm = #0x1e
700aa63a: e7ff         	b	0x700aa63c <UART_regConfigModeEnable+0x1c> @ imm = #-0x2
700aa63c: 9802         	ldr	r0, [sp, #0x8]
700aa63e: 2880         	cmp	r0, #0x80
700aa640: d004         	beq	0x700aa64c <UART_regConfigModeEnable+0x2c> @ imm = #0x8
700aa642: e7ff         	b	0x700aa644 <UART_regConfigModeEnable+0x24> @ imm = #-0x2
700aa644: 9802         	ldr	r0, [sp, #0x8]
700aa646: 28bf         	cmp	r0, #0xbf
700aa648: d113         	bne	0x700aa672 <UART_regConfigModeEnable+0x52> @ imm = #0x26
700aa64a: e7ff         	b	0x700aa64c <UART_regConfigModeEnable+0x2c> @ imm = #-0x2
;             HW_WR_REG32(baseAddr + UART_LCR, modeFlag & 0xFFU);
700aa64c: 9805         	ldr	r0, [sp, #0x14]
700aa64e: 300c         	adds	r0, #0xc
700aa650: f89d 1010    	ldrb.w	r1, [sp, #0x10]
700aa654: f002 fff4    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x2fe8
;             break;
700aa658: e00c         	b	0x700aa674 <UART_regConfigModeEnable+0x54> @ imm = #0x18
;             HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700aa65a: 9805         	ldr	r0, [sp, #0x14]
700aa65c: 300c         	adds	r0, #0xc
700aa65e: 9001         	str	r0, [sp, #0x4]
700aa660: f002 ffe6    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x2fcc
700aa664: 4601         	mov	r1, r0
700aa666: 9801         	ldr	r0, [sp, #0x4]
700aa668: f001 017f    	and	r1, r1, #0x7f
700aa66c: f002 ffe8    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x2fd0
;             break;
700aa670: e000         	b	0x700aa674 <UART_regConfigModeEnable+0x54> @ imm = #0x0
;             break;
700aa672: e7ff         	b	0x700aa674 <UART_regConfigModeEnable+0x54> @ imm = #-0x2
;     return lcrRegValue;
700aa674: 9803         	ldr	r0, [sp, #0xc]
700aa676: b006         	add	sp, #0x18
700aa678: bd80         	pop	{r7, pc}
700aa67a: 0000         	movs	r0, r0
700aa67c: 0000         	movs	r0, r0
700aa67e: 0000         	movs	r0, r0

700aa680 <prvCheckTasksWaitingTermination>:
; static void prvCheckTasksWaitingTermination(void) {
700aa680: b580         	push	{r7, lr}
700aa682: b082         	sub	sp, #0x8
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700aa684: e7ff         	b	0x700aa686 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x2
700aa686: f240 10ec    	movw	r0, #0x1ec
700aa68a: f2c7 000b    	movt	r0, #0x700b
700aa68e: 6800         	ldr	r0, [r0]
700aa690: b308         	cbz	r0, 0x700aa6d6 <prvCheckTasksWaitingTermination+0x56> @ imm = #0x42
700aa692: e7ff         	b	0x700aa694 <prvCheckTasksWaitingTermination+0x14> @ imm = #-0x2
;       taskENTER_CRITICAL();
700aa694: f001 feac    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0x1d58
;         pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700aa698: f644 7090    	movw	r0, #0x4f90
700aa69c: f2c7 0008    	movt	r0, #0x7008
700aa6a0: 68c0         	ldr	r0, [r0, #0xc]
700aa6a2: 68c0         	ldr	r0, [r0, #0xc]
700aa6a4: 9001         	str	r0, [sp, #0x4]
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700aa6a6: 9801         	ldr	r0, [sp, #0x4]
700aa6a8: 3004         	adds	r0, #0x4
700aa6aa: f000 fed9    	bl	0x700ab460 <uxListRemove> @ imm = #0xdb2
;         --uxCurrentNumberOfTasks;
700aa6ae: f240 11e8    	movw	r1, #0x1e8
700aa6b2: f2c7 010b    	movt	r1, #0x700b
700aa6b6: 6808         	ldr	r0, [r1]
700aa6b8: 3801         	subs	r0, #0x1
700aa6ba: 6008         	str	r0, [r1]
;         --uxDeletedTasksWaitingCleanUp;
700aa6bc: f240 11ec    	movw	r1, #0x1ec
700aa6c0: f2c7 010b    	movt	r1, #0x700b
700aa6c4: 6808         	ldr	r0, [r1]
700aa6c6: 3801         	subs	r0, #0x1
700aa6c8: 6008         	str	r0, [r1]
;       taskEXIT_CRITICAL();
700aa6ca: f000 ff91    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #0xf22
;       prvDeleteTCB(pxTCB);
700aa6ce: 9801         	ldr	r0, [sp, #0x4]
700aa6d0: f001 fbb6    	bl	0x700abe40 <prvDeleteTCB> @ imm = #0x176c
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700aa6d4: e7d7         	b	0x700aa686 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x52
; }
700aa6d6: b002         	add	sp, #0x8
700aa6d8: bd80         	pop	{r7, pc}
700aa6da: 0000         	movs	r0, r0
700aa6dc: 0000         	movs	r0, r0
700aa6de: 0000         	movs	r0, r0

700aa6e0 <Sciclient_rmIrqSetRaw>:
; {
700aa6e0: b580         	push	{r7, lr}
700aa6e2: b08c         	sub	sp, #0x30
700aa6e4: 900b         	str	r0, [sp, #0x2c]
700aa6e6: 910a         	str	r1, [sp, #0x28]
700aa6e8: 9209         	str	r2, [sp, #0x24]
700aa6ea: f44f 5080    	mov.w	r0, #0x1000
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_SET;
700aa6ee: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa6f2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa6f4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa6f6: 980b         	ldr	r0, [sp, #0x2c]
700aa6f8: 9005         	str	r0, [sp, #0x14]
700aa6fa: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa6fc: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa6fe: 9809         	ldr	r0, [sp, #0x24]
700aa700: 9007         	str	r0, [sp, #0x1c]
700aa702: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa704: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa706: 980a         	ldr	r0, [sp, #0x28]
700aa708: 9001         	str	r0, [sp, #0x4]
700aa70a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa70c: 9002         	str	r0, [sp, #0x8]
700aa70e: a803         	add	r0, sp, #0xc
700aa710: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa712: f7f1 fbb5    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xe896
700aa716: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa718: 9808         	ldr	r0, [sp, #0x20]
700aa71a: b930         	cbnz	r0, 0x700aa72a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #0xc
700aa71c: e7ff         	b	0x700aa71e <Sciclient_rmIrqSetRaw+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa71e: 9800         	ldr	r0, [sp]
700aa720: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa724: 2802         	cmp	r0, #0x2
700aa726: d004         	beq	0x700aa732 <Sciclient_rmIrqSetRaw+0x52> @ imm = #0x8
700aa728: e7ff         	b	0x700aa72a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #-0x2
700aa72a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa72e: 9008         	str	r0, [sp, #0x20]
;     }
700aa730: e7ff         	b	0x700aa732 <Sciclient_rmIrqSetRaw+0x52> @ imm = #-0x2
;     return r;
700aa732: 9808         	ldr	r0, [sp, #0x20]
700aa734: b00c         	add	sp, #0x30
700aa736: bd80         	pop	{r7, pc}
		...

700aa740 <Sciclient_rmIrqUnmappedVintRouteDelete>:
; {
700aa740: b580         	push	{r7, lr}
700aa742: b084         	sub	sp, #0x10
700aa744: 9003         	str	r0, [sp, #0xc]
700aa746: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700aa748: 9002         	str	r0, [sp, #0x8]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700aa74a: 9903         	ldr	r1, [sp, #0xc]
700aa74c: 8a08         	ldrh	r0, [r1, #0x10]
700aa74e: 8a49         	ldrh	r1, [r1, #0x12]
700aa750: f10d 0207    	add.w	r2, sp, #0x7
700aa754: f7fe febc    	bl	0x700a94d0 <Sciclient_rmIaVintGetInfo> @ imm = #-0x1288
700aa758: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700aa75a: 9802         	ldr	r0, [sp, #0x8]
700aa75c: b940         	cbnz	r0, 0x700aa770 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x10
700aa75e: e7ff         	b	0x700aa760 <Sciclient_rmIrqUnmappedVintRouteDelete+0x20> @ imm = #-0x2
700aa760: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700aa764: b120         	cbz	r0, 0x700aa770 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x8
700aa766: e7ff         	b	0x700aa768 <Sciclient_rmIrqUnmappedVintRouteDelete+0x28> @ imm = #-0x2
700aa768: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700aa76c: 9002         	str	r0, [sp, #0x8]
;     }
700aa76e: e7ff         	b	0x700aa770 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700aa770: 9802         	ldr	r0, [sp, #0x8]
700aa772: b970         	cbnz	r0, 0x700aa792 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #0x1c
700aa774: e7ff         	b	0x700aa776 <Sciclient_rmIrqUnmappedVintRouteDelete+0x36> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700aa776: 9803         	ldr	r0, [sp, #0xc]
700aa778: f7f1 f87a    	bl	0x7009b870 <Sciclient_rmIrqGetRoute> @ imm = #-0xef0c
700aa77c: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700aa77e: 9802         	ldr	r0, [sp, #0x8]
700aa780: b930         	cbnz	r0, 0x700aa790 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #0xc
700aa782: e7ff         	b	0x700aa784 <Sciclient_rmIrqUnmappedVintRouteDelete+0x44> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, false);
700aa784: 9803         	ldr	r0, [sp, #0xc]
700aa786: 2100         	movs	r1, #0x0
700aa788: f7f4 f972    	bl	0x7009ea70 <Sciclient_rmIrqDeleteRoute> @ imm = #-0xbd1c
700aa78c: 9002         	str	r0, [sp, #0x8]
;         }
700aa78e: e7ff         	b	0x700aa790 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #-0x2
;     }
700aa790: e7ff         	b	0x700aa792 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #-0x2
;     return r;
700aa792: 9802         	ldr	r0, [sp, #0x8]
700aa794: b004         	add	sp, #0x10
700aa796: bd80         	pop	{r7, pc}
		...

700aa7a0 <Sciclient_rmRingCfg>:
; {
700aa7a0: b580         	push	{r7, lr}
700aa7a2: b08c         	sub	sp, #0x30
700aa7a4: 900b         	str	r0, [sp, #0x2c]
700aa7a6: 910a         	str	r1, [sp, #0x28]
700aa7a8: 9209         	str	r2, [sp, #0x24]
700aa7aa: f241 1010    	movw	r0, #0x1110
;     sciReq.messageType    = TISCI_MSG_RM_RING_CFG;
700aa7ae: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa7b2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa7b4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa7b6: 980b         	ldr	r0, [sp, #0x2c]
700aa7b8: 9005         	str	r0, [sp, #0x14]
700aa7ba: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa7bc: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa7be: 9809         	ldr	r0, [sp, #0x24]
700aa7c0: 9007         	str	r0, [sp, #0x1c]
700aa7c2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa7c4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa7c6: 980a         	ldr	r0, [sp, #0x28]
700aa7c8: 9001         	str	r0, [sp, #0x4]
700aa7ca: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa7cc: 9002         	str	r0, [sp, #0x8]
700aa7ce: a803         	add	r0, sp, #0xc
700aa7d0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa7d2: f7f1 fb55    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xe956
700aa7d6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa7d8: 9808         	ldr	r0, [sp, #0x20]
700aa7da: b930         	cbnz	r0, 0x700aa7ea <Sciclient_rmRingCfg+0x4a> @ imm = #0xc
700aa7dc: e7ff         	b	0x700aa7de <Sciclient_rmRingCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa7de: 9800         	ldr	r0, [sp]
700aa7e0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa7e4: 2802         	cmp	r0, #0x2
700aa7e6: d004         	beq	0x700aa7f2 <Sciclient_rmRingCfg+0x52> @ imm = #0x8
700aa7e8: e7ff         	b	0x700aa7ea <Sciclient_rmRingCfg+0x4a> @ imm = #-0x2
700aa7ea: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa7ee: 9008         	str	r0, [sp, #0x20]
;     }
700aa7f0: e7ff         	b	0x700aa7f2 <Sciclient_rmRingCfg+0x52> @ imm = #-0x2
;     return r;
700aa7f2: 9808         	ldr	r0, [sp, #0x20]
700aa7f4: b00c         	add	sp, #0x30
700aa7f6: bd80         	pop	{r7, pc}
		...

700aa800 <Sciclient_rmUdmapFlowCfg>:
; {
700aa800: b580         	push	{r7, lr}
700aa802: b08c         	sub	sp, #0x30
700aa804: 900b         	str	r0, [sp, #0x2c]
700aa806: 910a         	str	r1, [sp, #0x28]
700aa808: 9209         	str	r2, [sp, #0x24]
700aa80a: f241 2030    	movw	r0, #0x1230
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_CFG;
700aa80e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa812: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa814: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa816: 980b         	ldr	r0, [sp, #0x2c]
700aa818: 9005         	str	r0, [sp, #0x14]
700aa81a: 2029         	movs	r0, #0x29
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa81c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa81e: 9809         	ldr	r0, [sp, #0x24]
700aa820: 9007         	str	r0, [sp, #0x1c]
700aa822: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa824: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa826: 980a         	ldr	r0, [sp, #0x28]
700aa828: 9001         	str	r0, [sp, #0x4]
700aa82a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa82c: 9002         	str	r0, [sp, #0x8]
700aa82e: a803         	add	r0, sp, #0xc
700aa830: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa832: f7f1 fb25    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xe9b6
700aa836: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa838: 9808         	ldr	r0, [sp, #0x20]
700aa83a: b930         	cbnz	r0, 0x700aa84a <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #0xc
700aa83c: e7ff         	b	0x700aa83e <Sciclient_rmUdmapFlowCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa83e: 9800         	ldr	r0, [sp]
700aa840: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa844: 2802         	cmp	r0, #0x2
700aa846: d004         	beq	0x700aa852 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #0x8
700aa848: e7ff         	b	0x700aa84a <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #-0x2
700aa84a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa84e: 9008         	str	r0, [sp, #0x20]
;     }
700aa850: e7ff         	b	0x700aa852 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #-0x2
;     return r;
700aa852: 9808         	ldr	r0, [sp, #0x20]
700aa854: b00c         	add	sp, #0x30
700aa856: bd80         	pop	{r7, pc}
		...

700aa860 <Sciclient_rmUdmapFlowSizeThreshCfg>:
; {
700aa860: b580         	push	{r7, lr}
700aa862: b08c         	sub	sp, #0x30
700aa864: 900b         	str	r0, [sp, #0x2c]
700aa866: 910a         	str	r1, [sp, #0x28]
700aa868: 9209         	str	r2, [sp, #0x24]
700aa86a: f241 2031    	movw	r0, #0x1231
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_SIZE_THRESH_CFG;
700aa86e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa872: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa874: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa876: 980b         	ldr	r0, [sp, #0x2c]
700aa878: 9005         	str	r0, [sp, #0x14]
700aa87a: 201d         	movs	r0, #0x1d
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa87c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa87e: 9809         	ldr	r0, [sp, #0x24]
700aa880: 9007         	str	r0, [sp, #0x1c]
700aa882: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa884: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa886: 980a         	ldr	r0, [sp, #0x28]
700aa888: 9001         	str	r0, [sp, #0x4]
700aa88a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa88c: 9002         	str	r0, [sp, #0x8]
700aa88e: a803         	add	r0, sp, #0xc
700aa890: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa892: f7f1 faf5    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xea16
700aa896: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa898: 9808         	ldr	r0, [sp, #0x20]
700aa89a: b930         	cbnz	r0, 0x700aa8aa <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #0xc
700aa89c: e7ff         	b	0x700aa89e <Sciclient_rmUdmapFlowSizeThreshCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa89e: 9800         	ldr	r0, [sp]
700aa8a0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa8a4: 2802         	cmp	r0, #0x2
700aa8a6: d004         	beq	0x700aa8b2 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #0x8
700aa8a8: e7ff         	b	0x700aa8aa <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #-0x2
700aa8aa: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa8ae: 9008         	str	r0, [sp, #0x20]
;     }
700aa8b0: e7ff         	b	0x700aa8b2 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #-0x2
;     return r;
700aa8b2: 9808         	ldr	r0, [sp, #0x20]
700aa8b4: b00c         	add	sp, #0x30
700aa8b6: bd80         	pop	{r7, pc}
		...

700aa8c0 <Sciclient_rmUdmapRxChCfg>:
; {
700aa8c0: b580         	push	{r7, lr}
700aa8c2: b08c         	sub	sp, #0x30
700aa8c4: 900b         	str	r0, [sp, #0x2c]
700aa8c6: 910a         	str	r1, [sp, #0x28]
700aa8c8: 9209         	str	r2, [sp, #0x24]
700aa8ca: f241 2015    	movw	r0, #0x1215
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_RX_CH_CFG;
700aa8ce: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa8d2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa8d4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa8d6: 980b         	ldr	r0, [sp, #0x2c]
700aa8d8: 9005         	str	r0, [sp, #0x14]
700aa8da: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa8dc: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa8de: 9809         	ldr	r0, [sp, #0x24]
700aa8e0: 9007         	str	r0, [sp, #0x1c]
700aa8e2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa8e4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa8e6: 980a         	ldr	r0, [sp, #0x28]
700aa8e8: 9001         	str	r0, [sp, #0x4]
700aa8ea: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa8ec: 9002         	str	r0, [sp, #0x8]
700aa8ee: a803         	add	r0, sp, #0xc
700aa8f0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa8f2: f7f1 fac5    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xea76
700aa8f6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa8f8: 9808         	ldr	r0, [sp, #0x20]
700aa8fa: b930         	cbnz	r0, 0x700aa90a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #0xc
700aa8fc: e7ff         	b	0x700aa8fe <Sciclient_rmUdmapRxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa8fe: 9800         	ldr	r0, [sp]
700aa900: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa904: 2802         	cmp	r0, #0x2
700aa906: d004         	beq	0x700aa912 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #0x8
700aa908: e7ff         	b	0x700aa90a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #-0x2
700aa90a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa90e: 9008         	str	r0, [sp, #0x20]
;     }
700aa910: e7ff         	b	0x700aa912 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #-0x2
;     return r;
700aa912: 9808         	ldr	r0, [sp, #0x20]
700aa914: b00c         	add	sp, #0x30
700aa916: bd80         	pop	{r7, pc}
		...

700aa920 <Sciclient_rmUdmapTxChCfg>:
; {
700aa920: b580         	push	{r7, lr}
700aa922: b08c         	sub	sp, #0x30
700aa924: 900b         	str	r0, [sp, #0x2c]
700aa926: 910a         	str	r1, [sp, #0x28]
700aa928: 9209         	str	r2, [sp, #0x24]
700aa92a: f241 2005    	movw	r0, #0x1205
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_TX_CH_CFG;
700aa92e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aa932: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa934: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa936: 980b         	ldr	r0, [sp, #0x2c]
700aa938: 9005         	str	r0, [sp, #0x14]
700aa93a: 2024         	movs	r0, #0x24
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa93c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aa93e: 9809         	ldr	r0, [sp, #0x24]
700aa940: 9007         	str	r0, [sp, #0x1c]
700aa942: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa944: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aa946: 980a         	ldr	r0, [sp, #0x28]
700aa948: 9001         	str	r0, [sp, #0x4]
700aa94a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aa94c: 9002         	str	r0, [sp, #0x8]
700aa94e: a803         	add	r0, sp, #0xc
700aa950: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aa952: f7f1 fa95    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xead6
700aa956: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aa958: 9808         	ldr	r0, [sp, #0x20]
700aa95a: b930         	cbnz	r0, 0x700aa96a <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #0xc
700aa95c: e7ff         	b	0x700aa95e <Sciclient_rmUdmapTxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa95e: 9800         	ldr	r0, [sp]
700aa960: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa964: 2802         	cmp	r0, #0x2
700aa966: d004         	beq	0x700aa972 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #0x8
700aa968: e7ff         	b	0x700aa96a <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #-0x2
700aa96a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa96e: 9008         	str	r0, [sp, #0x20]
;     }
700aa970: e7ff         	b	0x700aa972 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #-0x2
;     return r;
700aa972: 9808         	ldr	r0, [sp, #0x20]
700aa974: b00c         	add	sp, #0x30
700aa976: bd80         	pop	{r7, pc}
		...

700aa980 <Sciclient_rmIrqReleaseRaw>:
; {
700aa980: b580         	push	{r7, lr}
700aa982: b08e         	sub	sp, #0x38
700aa984: 900d         	str	r0, [sp, #0x34]
700aa986: 910c         	str	r1, [sp, #0x30]
700aa988: f241 0001    	movw	r0, #0x1001
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_RELEASE;
700aa98c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700aa990: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa992: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa994: 980d         	ldr	r0, [sp, #0x34]
700aa996: 9008         	str	r0, [sp, #0x20]
700aa998: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa99a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700aa99c: 980c         	ldr	r0, [sp, #0x30]
700aa99e: 900a         	str	r0, [sp, #0x28]
700aa9a0: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aa9a2: 9003         	str	r0, [sp, #0xc]
700aa9a4: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700aa9a6: 9004         	str	r0, [sp, #0x10]
700aa9a8: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700aa9aa: 9005         	str	r0, [sp, #0x14]
700aa9ac: a806         	add	r0, sp, #0x18
700aa9ae: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700aa9b0: f7f1 fa66    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xeb34
700aa9b4: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700aa9b6: 980b         	ldr	r0, [sp, #0x2c]
700aa9b8: b930         	cbnz	r0, 0x700aa9c8 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #0xc
700aa9ba: e7ff         	b	0x700aa9bc <Sciclient_rmIrqReleaseRaw+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aa9bc: 9803         	ldr	r0, [sp, #0xc]
700aa9be: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aa9c2: 2802         	cmp	r0, #0x2
700aa9c4: d004         	beq	0x700aa9d0 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #0x8
700aa9c6: e7ff         	b	0x700aa9c8 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #-0x2
700aa9c8: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aa9cc: 900b         	str	r0, [sp, #0x2c]
;     }
700aa9ce: e7ff         	b	0x700aa9d0 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #-0x2
;     return r;
700aa9d0: 980b         	ldr	r0, [sp, #0x2c]
700aa9d2: b00e         	add	sp, #0x38
700aa9d4: bd80         	pop	{r7, pc}
		...
700aa9de: 0000         	movs	r0, r0

700aa9e0 <Sciclient_rmPsilPair>:
; {
700aa9e0: b580         	push	{r7, lr}
700aa9e2: b08e         	sub	sp, #0x38
700aa9e4: 900d         	str	r0, [sp, #0x34]
700aa9e6: 910c         	str	r1, [sp, #0x30]
700aa9e8: f44f 5094    	mov.w	r0, #0x1280
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_PAIR;
700aa9ec: f8ad 0018    	strh.w	r0, [sp, #0x18]
700aa9f0: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aa9f2: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aa9f4: 980d         	ldr	r0, [sp, #0x34]
700aa9f6: 9008         	str	r0, [sp, #0x20]
700aa9f8: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aa9fa: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700aa9fc: 980c         	ldr	r0, [sp, #0x30]
700aa9fe: 900a         	str	r0, [sp, #0x28]
700aaa00: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aaa02: 9003         	str	r0, [sp, #0xc]
700aaa04: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t*)&resp;
700aaa06: 9004         	str	r0, [sp, #0x10]
700aaa08: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700aaa0a: 9005         	str	r0, [sp, #0x14]
700aaa0c: a806         	add	r0, sp, #0x18
700aaa0e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700aaa10: f7f1 fa36    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xeb94
700aaa14: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700aaa16: 980b         	ldr	r0, [sp, #0x2c]
700aaa18: b930         	cbnz	r0, 0x700aaa28 <Sciclient_rmPsilPair+0x48> @ imm = #0xc
700aaa1a: e7ff         	b	0x700aaa1c <Sciclient_rmPsilPair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aaa1c: 9803         	ldr	r0, [sp, #0xc]
700aaa1e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aaa22: 2802         	cmp	r0, #0x2
700aaa24: d004         	beq	0x700aaa30 <Sciclient_rmPsilPair+0x50> @ imm = #0x8
700aaa26: e7ff         	b	0x700aaa28 <Sciclient_rmPsilPair+0x48> @ imm = #-0x2
700aaa28: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aaa2c: 900b         	str	r0, [sp, #0x2c]
;     }
700aaa2e: e7ff         	b	0x700aaa30 <Sciclient_rmPsilPair+0x50> @ imm = #-0x2
;     return r;
700aaa30: 980b         	ldr	r0, [sp, #0x2c]
700aaa32: b00e         	add	sp, #0x38
700aaa34: bd80         	pop	{r7, pc}
		...
700aaa3e: 0000         	movs	r0, r0

700aaa40 <Sciclient_rmPsilUnpair>:
; {
700aaa40: b580         	push	{r7, lr}
700aaa42: b08e         	sub	sp, #0x38
700aaa44: 900d         	str	r0, [sp, #0x34]
700aaa46: 910c         	str	r1, [sp, #0x30]
700aaa48: f241 2081    	movw	r0, #0x1281
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_UNPAIR;
700aaa4c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700aaa50: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aaa52: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aaa54: 980d         	ldr	r0, [sp, #0x34]
700aaa56: 9008         	str	r0, [sp, #0x20]
700aaa58: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aaa5a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700aaa5c: 980c         	ldr	r0, [sp, #0x30]
700aaa5e: 900a         	str	r0, [sp, #0x28]
700aaa60: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aaa62: 9003         	str	r0, [sp, #0xc]
700aaa64: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700aaa66: 9004         	str	r0, [sp, #0x10]
700aaa68: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700aaa6a: 9005         	str	r0, [sp, #0x14]
700aaa6c: a806         	add	r0, sp, #0x18
700aaa6e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700aaa70: f7f1 fa06    	bl	0x7009be80 <Sciclient_service> @ imm = #-0xebf4
700aaa74: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700aaa76: 980b         	ldr	r0, [sp, #0x2c]
700aaa78: b930         	cbnz	r0, 0x700aaa88 <Sciclient_rmPsilUnpair+0x48> @ imm = #0xc
700aaa7a: e7ff         	b	0x700aaa7c <Sciclient_rmPsilUnpair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aaa7c: 9803         	ldr	r0, [sp, #0xc]
700aaa7e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aaa82: 2802         	cmp	r0, #0x2
700aaa84: d004         	beq	0x700aaa90 <Sciclient_rmPsilUnpair+0x50> @ imm = #0x8
700aaa86: e7ff         	b	0x700aaa88 <Sciclient_rmPsilUnpair+0x48> @ imm = #-0x2
700aaa88: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aaa8c: 900b         	str	r0, [sp, #0x2c]
;     }
700aaa8e: e7ff         	b	0x700aaa90 <Sciclient_rmPsilUnpair+0x50> @ imm = #-0x2
;     return r;
700aaa90: 980b         	ldr	r0, [sp, #0x2c]
700aaa92: b00e         	add	sp, #0x38
700aaa94: bd80         	pop	{r7, pc}
		...
700aaa9e: 0000         	movs	r0, r0

700aaaa0 <Udma_chSetPeerReg>:
; {
700aaaa0: b580         	push	{r7, lr}
700aaaa2: b086         	sub	sp, #0x18
700aaaa4: f8dd c020    	ldr.w	r12, [sp, #0x20]
700aaaa8: 9005         	str	r0, [sp, #0x14]
700aaaaa: 9104         	str	r1, [sp, #0x10]
700aaaac: 9203         	str	r2, [sp, #0xc]
700aaaae: 9302         	str	r3, [sp, #0x8]
;     regVal = CSL_REG32_RD(PEER8);
700aaab0: 9803         	ldr	r0, [sp, #0xc]
700aaab2: f002 fe2d    	bl	0x700ad710 <CSL_REG32_RD_RAW> @ imm = #0x2c5a
700aaab6: 9001         	str	r0, [sp, #0x4]
;     CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 0U);
700aaab8: 9801         	ldr	r0, [sp, #0x4]
700aaaba: f020 4000    	bic	r0, r0, #0x80000000
700aaabe: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER8, regVal);
700aaac0: 9803         	ldr	r0, [sp, #0xc]
700aaac2: 9901         	ldr	r1, [sp, #0x4]
700aaac4: f002 fd84    	bl	0x700ad5d0 <CSL_REG32_WR_RAW> @ imm = #0x2b08
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700aaac8: 9804         	ldr	r0, [sp, #0x10]
700aaaca: 6801         	ldr	r1, [r0]
;                 CSL_FMK(PSILCFG_REG_STATIC_TR_Y, pdmaPrms->elemCnt);
700aaacc: 6840         	ldr	r0, [r0, #0x4]
700aaace: f36f 301f    	bfc	r0, #12, #20
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700aaad2: f361 601a    	bfi	r0, r1, #24, #3
700aaad6: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER0, regVal);
700aaad8: 9808         	ldr	r0, [sp, #0x20]
700aaada: 9901         	ldr	r1, [sp, #0x4]
700aaadc: f002 fd78    	bl	0x700ad5d0 <CSL_REG32_WR_RAW> @ imm = #0x2af0
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_Z, pdmaPrms->fifoCnt);
700aaae0: 9804         	ldr	r0, [sp, #0x10]
700aaae2: 6880         	ldr	r0, [r0, #0x8]
700aaae4: f36f 301f    	bfc	r0, #12, #20
700aaae8: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER1, regVal);
700aaaea: 9802         	ldr	r0, [sp, #0x8]
700aaaec: 9901         	ldr	r1, [sp, #0x4]
700aaaee: f002 fd6f    	bl	0x700ad5d0 <CSL_REG32_WR_RAW> @ imm = #0x2ade
; }
700aaaf2: b006         	add	sp, #0x18
700aaaf4: bd80         	pop	{r7, pc}
		...
700aaafe: 0000         	movs	r0, r0

700aab00 <Udma_eventGetGlobalHandle>:
; {
700aab00: b084         	sub	sp, #0x10
700aab02: 9003         	str	r0, [sp, #0xc]
700aab04: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aab06: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandle    eventHandle = (Udma_EventHandle) NULL_PTR;
700aab08: 9000         	str	r0, [sp]
;     if(NULL_PTR == drvHandle)
700aab0a: 9803         	ldr	r0, [sp, #0xc]
700aab0c: b920         	cbnz	r0, 0x700aab18 <Udma_eventGetGlobalHandle+0x18> @ imm = #0x8
700aab0e: e7ff         	b	0x700aab10 <Udma_eventGetGlobalHandle+0x10> @ imm = #-0x2
700aab10: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700aab14: 9002         	str	r0, [sp, #0x8]
;     }
700aab16: e7ff         	b	0x700aab18 <Udma_eventGetGlobalHandle+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aab18: 9802         	ldr	r0, [sp, #0x8]
700aab1a: b988         	cbnz	r0, 0x700aab40 <Udma_eventGetGlobalHandle+0x40> @ imm = #0x22
700aab1c: e7ff         	b	0x700aab1e <Udma_eventGetGlobalHandle+0x1e> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700aab1e: 9803         	ldr	r0, [sp, #0xc]
700aab20: 9001         	str	r0, [sp, #0x4]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700aab22: 9801         	ldr	r0, [sp, #0x4]
700aab24: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700aab28: f64a 31cd    	movw	r1, #0xabcd
700aab2c: f6ca 31dc    	movt	r1, #0xabdc
700aab30: 4288         	cmp	r0, r1
700aab32: d004         	beq	0x700aab3e <Udma_eventGetGlobalHandle+0x3e> @ imm = #0x8
700aab34: e7ff         	b	0x700aab36 <Udma_eventGetGlobalHandle+0x36> @ imm = #-0x2
700aab36: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700aab3a: 9002         	str	r0, [sp, #0x8]
;         }
700aab3c: e7ff         	b	0x700aab3e <Udma_eventGetGlobalHandle+0x3e> @ imm = #-0x2
;     }
700aab3e: e7ff         	b	0x700aab40 <Udma_eventGetGlobalHandle+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aab40: 9802         	ldr	r0, [sp, #0x8]
700aab42: b928         	cbnz	r0, 0x700aab50 <Udma_eventGetGlobalHandle+0x50> @ imm = #0xa
700aab44: e7ff         	b	0x700aab46 <Udma_eventGetGlobalHandle+0x46> @ imm = #-0x2
;         eventHandle = (Udma_EventHandle) drvHandleInt->globalEventHandle;
700aab46: 9801         	ldr	r0, [sp, #0x4]
700aab48: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
700aab4c: 9000         	str	r0, [sp]
;     }
700aab4e: e7ff         	b	0x700aab50 <Udma_eventGetGlobalHandle+0x50> @ imm = #-0x2
;     return (eventHandle);
700aab50: 9800         	ldr	r0, [sp]
700aab52: b004         	add	sp, #0x10
700aab54: 4770         	bx	lr
		...
700aab5e: 0000         	movs	r0, r0

700aab60 <CSL_pktdmaIsValidChanIdx>:
; {
700aab60: b084         	sub	sp, #0x10
700aab62: 9003         	str	r0, [sp, #0xc]
700aab64: 9102         	str	r1, [sp, #0x8]
700aab66: 9201         	str	r2, [sp, #0x4]
;     if( (chanDir == CSL_PKTDMA_CHAN_DIR_TX) && (chanIdx < pCfg->txChanCnt) )
700aab68: 9801         	ldr	r0, [sp, #0x4]
700aab6a: b950         	cbnz	r0, 0x700aab82 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x14
700aab6c: e7ff         	b	0x700aab6e <CSL_pktdmaIsValidChanIdx+0xe> @ imm = #-0x2
700aab6e: 9802         	ldr	r0, [sp, #0x8]
700aab70: 9903         	ldr	r1, [sp, #0xc]
700aab72: 6a09         	ldr	r1, [r1, #0x20]
700aab74: 4288         	cmp	r0, r1
700aab76: d204         	bhs	0x700aab82 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x8
700aab78: e7ff         	b	0x700aab7a <CSL_pktdmaIsValidChanIdx+0x1a> @ imm = #-0x2
700aab7a: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700aab7c: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aab80: e012         	b	0x700aaba8 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #0x24
;     else if( (chanDir == CSL_PKTDMA_CHAN_DIR_RX) && (chanIdx < pCfg->rxChanCnt) )
700aab82: 9801         	ldr	r0, [sp, #0x4]
700aab84: 2801         	cmp	r0, #0x1
700aab86: d10a         	bne	0x700aab9e <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x14
700aab88: e7ff         	b	0x700aab8a <CSL_pktdmaIsValidChanIdx+0x2a> @ imm = #-0x2
700aab8a: 9802         	ldr	r0, [sp, #0x8]
700aab8c: 9903         	ldr	r1, [sp, #0xc]
700aab8e: 6a49         	ldr	r1, [r1, #0x24]
700aab90: 4288         	cmp	r0, r1
700aab92: d204         	bhs	0x700aab9e <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x8
700aab94: e7ff         	b	0x700aab96 <CSL_pktdmaIsValidChanIdx+0x36> @ imm = #-0x2
700aab96: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700aab98: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aab9c: e003         	b	0x700aaba6 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #0x6
700aab9e: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700aaba0: f88d 0003    	strb.w	r0, [sp, #0x3]
700aaba4: e7ff         	b	0x700aaba6 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #-0x2
700aaba6: e7ff         	b	0x700aaba8 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #-0x2
;     return bRetVal;
700aaba8: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aabac: f000 0001    	and	r0, r0, #0x1
700aabb0: b004         	add	sp, #0x10
700aabb2: 4770         	bx	lr
		...

700aabc0 <Sciclient_rmUnmappedVintRouteCreate>:
; {
700aabc0: b580         	push	{r7, lr}
700aabc2: b084         	sub	sp, #0x10
700aabc4: 9003         	str	r0, [sp, #0xc]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700aabc6: 9903         	ldr	r1, [sp, #0xc]
700aabc8: 8a08         	ldrh	r0, [r1, #0x10]
700aabca: 8a49         	ldrh	r1, [r1, #0x12]
700aabcc: f10d 0207    	add.w	r2, sp, #0x7
700aabd0: f7fe fc7e    	bl	0x700a94d0 <Sciclient_rmIaVintGetInfo> @ imm = #-0x1704
700aabd4: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700aabd6: 9802         	ldr	r0, [sp, #0x8]
700aabd8: b940         	cbnz	r0, 0x700aabec <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x10
700aabda: e7ff         	b	0x700aabdc <Sciclient_rmUnmappedVintRouteCreate+0x1c> @ imm = #-0x2
700aabdc: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700aabe0: b120         	cbz	r0, 0x700aabec <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x8
700aabe2: e7ff         	b	0x700aabe4 <Sciclient_rmUnmappedVintRouteCreate+0x24> @ imm = #-0x2
700aabe4: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700aabe8: 9002         	str	r0, [sp, #0x8]
;     }
700aabea: e7ff         	b	0x700aabec <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700aabec: 9802         	ldr	r0, [sp, #0x8]
700aabee: b970         	cbnz	r0, 0x700aac0e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #0x1c
700aabf0: e7ff         	b	0x700aabf2 <Sciclient_rmUnmappedVintRouteCreate+0x32> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700aabf2: 9803         	ldr	r0, [sp, #0xc]
700aabf4: f7f1 ffd4    	bl	0x7009cba0 <Sciclient_rmIrqFindRoute> @ imm = #-0xe058
700aabf8: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700aabfa: 9802         	ldr	r0, [sp, #0x8]
700aabfc: b930         	cbnz	r0, 0x700aac0c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #0xc
700aabfe: e7ff         	b	0x700aac00 <Sciclient_rmUnmappedVintRouteCreate+0x40> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, false);
700aac00: 9803         	ldr	r0, [sp, #0xc]
700aac02: 2100         	movs	r1, #0x0
700aac04: f7f4 f98c    	bl	0x7009ef20 <Sciclient_rmIrqProgramRoute> @ imm = #-0xbce8
700aac08: 9002         	str	r0, [sp, #0x8]
;         }
700aac0a: e7ff         	b	0x700aac0c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #-0x2
;     }
700aac0c: e7ff         	b	0x700aac0e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #-0x2
;     return r;
700aac0e: 9802         	ldr	r0, [sp, #0x8]
700aac10: b004         	add	sp, #0x10
700aac12: bd80         	pop	{r7, pc}
		...

700aac20 <UART_OperModeValid>:
; {
700aac20: b082         	sub	sp, #0x8
700aac22: 9001         	str	r0, [sp, #0x4]
700aac24: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700aac28: 9000         	str	r0, [sp]
;     if(((operMode == UART_OPER_MODE_16X) ||
700aac2a: 9801         	ldr	r0, [sp, #0x4]
700aac2c: b1e0         	cbz	r0, 0x700aac68 <UART_OperModeValid+0x48> @ imm = #0x38
700aac2e: e7ff         	b	0x700aac30 <UART_OperModeValid+0x10> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_SIR) ||
700aac30: 9801         	ldr	r0, [sp, #0x4]
700aac32: 2801         	cmp	r0, #0x1
700aac34: d018         	beq	0x700aac68 <UART_OperModeValid+0x48> @ imm = #0x30
700aac36: e7ff         	b	0x700aac38 <UART_OperModeValid+0x18> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_16X_AUTO_BAUD) ||
700aac38: 9801         	ldr	r0, [sp, #0x4]
700aac3a: 2802         	cmp	r0, #0x2
700aac3c: d014         	beq	0x700aac68 <UART_OperModeValid+0x48> @ imm = #0x28
700aac3e: e7ff         	b	0x700aac40 <UART_OperModeValid+0x20> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_13X) ||
700aac40: 9801         	ldr	r0, [sp, #0x4]
700aac42: 2803         	cmp	r0, #0x3
700aac44: d010         	beq	0x700aac68 <UART_OperModeValid+0x48> @ imm = #0x20
700aac46: e7ff         	b	0x700aac48 <UART_OperModeValid+0x28> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_MIR) ||
700aac48: 9801         	ldr	r0, [sp, #0x4]
700aac4a: 2804         	cmp	r0, #0x4
700aac4c: d00c         	beq	0x700aac68 <UART_OperModeValid+0x48> @ imm = #0x18
700aac4e: e7ff         	b	0x700aac50 <UART_OperModeValid+0x30> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_FIR) ||
700aac50: 9801         	ldr	r0, [sp, #0x4]
700aac52: 2805         	cmp	r0, #0x5
700aac54: d008         	beq	0x700aac68 <UART_OperModeValid+0x48> @ imm = #0x10
700aac56: e7ff         	b	0x700aac58 <UART_OperModeValid+0x38> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_CIR) ||
700aac58: 9801         	ldr	r0, [sp, #0x4]
700aac5a: 2806         	cmp	r0, #0x6
700aac5c: d004         	beq	0x700aac68 <UART_OperModeValid+0x48> @ imm = #0x8
700aac5e: e7ff         	b	0x700aac60 <UART_OperModeValid+0x40> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_DISABLED)))
700aac60: 9801         	ldr	r0, [sp, #0x4]
;     if(((operMode == UART_OPER_MODE_16X) ||
700aac62: 2807         	cmp	r0, #0x7
700aac64: d103         	bne	0x700aac6e <UART_OperModeValid+0x4e> @ imm = #0x6
700aac66: e7ff         	b	0x700aac68 <UART_OperModeValid+0x48> @ imm = #-0x2
700aac68: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700aac6a: 9000         	str	r0, [sp]
;     }
700aac6c: e7ff         	b	0x700aac6e <UART_OperModeValid+0x4e> @ imm = #-0x2
;     return status;
700aac6e: 9800         	ldr	r0, [sp]
700aac70: b002         	add	sp, #0x8
700aac72: 4770         	bx	lr
		...

700aac80 <UdmaRingPrms_init>:
; {
700aac80: b081         	sub	sp, #0x4
700aac82: 9000         	str	r0, [sp]
;     if(NULL_PTR != ringPrms)
700aac84: 9800         	ldr	r0, [sp]
700aac86: b318         	cbz	r0, 0x700aacd0 <UdmaRingPrms_init+0x50> @ imm = #0x46
700aac88: e7ff         	b	0x700aac8a <UdmaRingPrms_init+0xa> @ imm = #-0x2
;         ringPrms->ringMem       = NULL_PTR;
700aac8a: 9900         	ldr	r1, [sp]
700aac8c: 2000         	movs	r0, #0x0
700aac8e: 6008         	str	r0, [r1]
;         ringPrms->ringMemSize   = UDMA_RING_SIZE_CHECK_SKIP;
700aac90: 9a00         	ldr	r2, [sp]
700aac92: f64a 31cd    	movw	r1, #0xabcd
700aac96: f6ca 31dc    	movt	r1, #0xabdc
700aac9a: 6051         	str	r1, [r2, #0x4]
;         ringPrms->mode          = TISCI_MSG_VALUE_RM_RING_MODE_RING;
700aac9c: 9900         	ldr	r1, [sp]
700aac9e: 7208         	strb	r0, [r1, #0x8]
;         ringPrms->virtId        = UDMA_RING_VIRTID_INVALID;
700aaca0: 9a00         	ldr	r2, [sp]
700aaca2: f64f 71ff    	movw	r1, #0xffff
700aaca6: 8151         	strh	r1, [r2, #0xa]
;         ringPrms->elemCnt       = 0U;
700aaca8: 9900         	ldr	r1, [sp]
700aacaa: 60c8         	str	r0, [r1, #0xc]
;         ringPrms->elemSize      = UDMA_RING_ES_8BYTES;
700aacac: 9a00         	ldr	r2, [sp]
700aacae: 2101         	movs	r1, #0x1
700aacb0: 7411         	strb	r1, [r2, #0x10]
;         ringPrms->orderId       = UDMA_DEFAULT_RING_ORDER_ID;
700aacb2: 9900         	ldr	r1, [sp]
700aacb4: 7448         	strb	r0, [r1, #0x11]
;         ringPrms->asel          = UDMA_RINGACC_ASEL_ENDPOINT_PHYSADDR;
700aacb6: 9900         	ldr	r1, [sp]
700aacb8: 7488         	strb	r0, [r1, #0x12]
;         ringPrms->mappedRingGrp = UDMA_MAPPED_GROUP_INVALID;
700aacba: 9900         	ldr	r1, [sp]
700aacbc: 2004         	movs	r0, #0x4
700aacbe: f6cf 70ff    	movt	r0, #0xffff
700aacc2: 6148         	str	r0, [r1, #0x14]
;         ringPrms->mappedChNum   = UDMA_DMA_CH_INVALID;
700aacc4: 9900         	ldr	r1, [sp]
700aacc6: 2000         	movs	r0, #0x0
700aacc8: f6cf 70ff    	movt	r0, #0xffff
700aaccc: 6188         	str	r0, [r1, #0x18]
;     }
700aacce: e7ff         	b	0x700aacd0 <UdmaRingPrms_init+0x50> @ imm = #-0x2
;     return;
700aacd0: b001         	add	sp, #0x4
700aacd2: 4770         	bx	lr
		...

700aace0 <prvIdleTask>:
; static portTASK_FUNCTION(prvIdleTask, pvParameters) {
700aace0: b580         	push	{r7, lr}
700aace2: b082         	sub	sp, #0x8
700aace4: 9001         	str	r0, [sp, #0x4]
;   for (;;) {
700aace6: e7ff         	b	0x700aace8 <prvIdleTask+0x8> @ imm = #-0x2
;     prvCheckTasksWaitingTermination();
700aace8: f7ff fcca    	bl	0x700aa680 <prvCheckTasksWaitingTermination> @ imm = #-0x66c
;       if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700aacec: f244 40f8    	movw	r0, #0x44f8
700aacf0: f2c7 0008    	movt	r0, #0x7008
700aacf4: 6800         	ldr	r0, [r0]
700aacf6: 2802         	cmp	r0, #0x2
700aacf8: d302         	blo	0x700aad00 <prvIdleTask+0x20> @ imm = #0x4
700aacfa: e7ff         	b	0x700aacfc <prvIdleTask+0x1c> @ imm = #-0x2
;         taskYIELD();
700aacfc: df00         	svc	#0x0
;       } else {
700aacfe: e000         	b	0x700aad02 <prvIdleTask+0x22> @ imm = #0x0
700aad00: e7ff         	b	0x700aad02 <prvIdleTask+0x22> @ imm = #-0x2
;       vApplicationIdleHook();
700aad02: f002 fd5d    	bl	0x700ad7c0 <vApplicationIdleHook> @ imm = #0x2aba
;       xExpectedIdleTime = prvGetExpectedIdleTime();
700aad06: f7fd ff8b    	bl	0x700a8c20 <prvGetExpectedIdleTime> @ imm = #-0x20ea
700aad0a: 9000         	str	r0, [sp]
;       if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700aad0c: 9800         	ldr	r0, [sp]
700aad0e: 2802         	cmp	r0, #0x2
700aad10: d30e         	blo	0x700aad30 <prvIdleTask+0x50> @ imm = #0x1c
700aad12: e7ff         	b	0x700aad14 <prvIdleTask+0x34> @ imm = #-0x2
;         vTaskSuspendAll();
700aad14: f002 fcb4    	bl	0x700ad680 <vTaskSuspendAll> @ imm = #0x2968
;           xExpectedIdleTime = prvGetExpectedIdleTime();
700aad18: f7fd ff82    	bl	0x700a8c20 <prvGetExpectedIdleTime> @ imm = #-0x20fc
700aad1c: 9000         	str	r0, [sp]
;           if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700aad1e: 9800         	ldr	r0, [sp]
700aad20: 2802         	cmp	r0, #0x2
700aad22: d301         	blo	0x700aad28 <prvIdleTask+0x48> @ imm = #0x2
700aad24: e7ff         	b	0x700aad26 <prvIdleTask+0x46> @ imm = #-0x2
;           } else {
700aad26: e000         	b	0x700aad2a <prvIdleTask+0x4a> @ imm = #0x0
700aad28: e7ff         	b	0x700aad2a <prvIdleTask+0x4a> @ imm = #-0x2
;         (void)xTaskResumeAll();
700aad2a: f7f5 ff01    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0xa1fe
;       } else {
700aad2e: e000         	b	0x700aad32 <prvIdleTask+0x52> @ imm = #0x0
700aad30: e7ff         	b	0x700aad32 <prvIdleTask+0x52> @ imm = #-0x2
;   for (;;) {
700aad32: e7d9         	b	0x700aace8 <prvIdleTask+0x8> @ imm = #-0x4e
		...

700aad40 <vQueueUnregisterQueue>:
;     {
700aad40: b082         	sub	sp, #0x8
700aad42: 9001         	str	r0, [sp, #0x4]
700aad44: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700aad46: 9000         	str	r0, [sp]
700aad48: e7ff         	b	0x700aad4a <vQueueUnregisterQueue+0xa> @ imm = #-0x2
700aad4a: 9800         	ldr	r0, [sp]
700aad4c: 281f         	cmp	r0, #0x1f
700aad4e: d81f         	bhi	0x700aad90 <vQueueUnregisterQueue+0x50> @ imm = #0x3e
700aad50: e7ff         	b	0x700aad52 <vQueueUnregisterQueue+0x12> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].xHandle == xQueue )
700aad52: 9900         	ldr	r1, [sp]
700aad54: f644 2078    	movw	r0, #0x4a78
700aad58: f2c7 0008    	movt	r0, #0x7008
700aad5c: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700aad60: 6840         	ldr	r0, [r0, #0x4]
700aad62: 9901         	ldr	r1, [sp, #0x4]
700aad64: 4288         	cmp	r0, r1
700aad66: d10d         	bne	0x700aad84 <vQueueUnregisterQueue+0x44> @ imm = #0x1a
700aad68: e7ff         	b	0x700aad6a <vQueueUnregisterQueue+0x2a> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = NULL;
700aad6a: 9a00         	ldr	r2, [sp]
700aad6c: f644 2178    	movw	r1, #0x4a78
700aad70: f2c7 0108    	movt	r1, #0x7008
700aad74: 2000         	movs	r0, #0x0
700aad76: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
700aad7a: 9a00         	ldr	r2, [sp]
700aad7c: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700aad80: 6048         	str	r0, [r1, #0x4]
;                 break;
700aad82: e005         	b	0x700aad90 <vQueueUnregisterQueue+0x50> @ imm = #0xa
700aad84: e7ff         	b	0x700aad86 <vQueueUnregisterQueue+0x46> @ imm = #-0x2
;         }
700aad86: e7ff         	b	0x700aad88 <vQueueUnregisterQueue+0x48> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700aad88: 9800         	ldr	r0, [sp]
700aad8a: 3001         	adds	r0, #0x1
700aad8c: 9000         	str	r0, [sp]
700aad8e: e7dc         	b	0x700aad4a <vQueueUnregisterQueue+0xa> @ imm = #-0x48
;     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
700aad90: b002         	add	sp, #0x8
700aad92: 4770         	bx	lr

700aad94 <__TI_auto_init_nobinit_nopinit>:
700aad94: e92d4070     	push	{r4, r5, r6, lr}
700aad98: e59f403c     	ldr	r4, [pc, #0x3c]         @ 0x700aaddc <__TI_auto_init_nobinit_nopinit+0x48>
700aad9c: e59f0034     	ldr	r0, [pc, #0x34]         @ 0x700aadd8 <__TI_auto_init_nobinit_nopinit+0x44>
700aada0: e1540000     	cmp	r4, r0
700aada4: 0a000009     	beq	0x700aadd0 <__TI_auto_init_nobinit_nopinit+0x3c> @ imm = #0x24
700aada8: e59f5030     	ldr	r5, [pc, #0x30]         @ 0x700aade0 <__TI_auto_init_nobinit_nopinit+0x4c>
700aadac: e59f6030     	ldr	r6, [pc, #0x30]         @ 0x700aade4 <__TI_auto_init_nobinit_nopinit+0x50>
700aadb0: e1550006     	cmp	r5, r6
700aadb4: 0a000005     	beq	0x700aadd0 <__TI_auto_init_nobinit_nopinit+0x3c> @ imm = #0x14
700aadb8: e1c500d0     	ldrd	r0, r1, [r5]
700aadbc: e4d02001     	ldrb	r2, [r0], #1
700aadc0: e7942102     	ldr	r2, [r4, r2, lsl #2]
700aadc4: e12fff32     	blx	r2
700aadc8: e2855008     	add	r5, r5, #8
700aadcc: eafffff7     	b	0x700aadb0 <__TI_auto_init_nobinit_nopinit+0x1c> @ imm = #-0x24
700aadd0: e1a00000     	mov	r0, r0
700aadd4: e8bd8070     	pop	{r4, r5, r6, pc}
700aadd8: 00 00 00 00  	.word	0x00000000
700aaddc: 00 00 00 00  	.word	0x00000000
700aade0: 00 00 00 00  	.word	0x00000000
700aade4: 00 00 00 00  	.word	0x00000000
700aade8: 00 00 00 00  	.word	0x00000000
700aadec: 00 00 00 00  	.word	0x00000000

700aadf0 <Udma_chInitRegs>:
; {
700aadf0: b081         	sub	sp, #0x4
700aadf2: 9000         	str	r0, [sp]
;     chHandle->pBcdmaBcCfgRegs    = (volatile CSL_bcdma_bccfgRegs_chan *) NULL_PTR;
700aadf4: 9900         	ldr	r1, [sp]
700aadf6: 2000         	movs	r0, #0x0
700aadf8: f8c1 0214    	str.w	r0, [r1, #0x214]
;     chHandle->pBcdmaBcRtRegs     = (volatile CSL_bcdma_bcrtRegs_chan *) NULL_PTR;
700aadfc: 9900         	ldr	r1, [sp]
700aadfe: f8c1 0218    	str.w	r0, [r1, #0x218]
;     chHandle->pBcdmaTxCfgRegs   = (volatile CSL_bcdma_txccfgRegs_chan *) NULL_PTR;
700aae02: 9900         	ldr	r1, [sp]
700aae04: f8c1 021c    	str.w	r0, [r1, #0x21c]
;     chHandle->pBcdmaTxRtRegs    = (volatile CSL_bcdma_txcrtRegs_chan *) NULL_PTR;
700aae08: 9900         	ldr	r1, [sp]
700aae0a: f8c1 0220    	str.w	r0, [r1, #0x220]
;     chHandle->pBcdmaRxCfgRegs   = (volatile CSL_bcdma_rxccfgRegs_chan *) NULL_PTR;
700aae0e: 9900         	ldr	r1, [sp]
700aae10: f8c1 0224    	str.w	r0, [r1, #0x224]
;     chHandle->pBcdmaRxRtRegs    = (volatile CSL_bcdma_rxcrtRegs_chan *) NULL_PTR;
700aae14: 9900         	ldr	r1, [sp]
700aae16: f8c1 0228    	str.w	r0, [r1, #0x228]
;     chHandle->pPktdmaTxCfgRegs  = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700aae1a: 9900         	ldr	r1, [sp]
700aae1c: f8c1 022c    	str.w	r0, [r1, #0x22c]
;     chHandle->pPktdmaTxRtRegs   = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700aae20: 9900         	ldr	r1, [sp]
700aae22: f8c1 0230    	str.w	r0, [r1, #0x230]
;     chHandle->pPktdmaRxCfgRegs  = (volatile CSL_pktdma_rxccfgRegs_chan *) NULL_PTR;
700aae26: 9900         	ldr	r1, [sp]
700aae28: f8c1 0234    	str.w	r0, [r1, #0x234]
;     chHandle->pPktdmaRxRtRegs   = (volatile CSL_pktdma_rxcrtRegs_chan *) NULL_PTR;
700aae2c: 9900         	ldr	r1, [sp]
700aae2e: f8c1 0238    	str.w	r0, [r1, #0x238]
;     chHandle->pPktdmaExtCfgRegs = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700aae32: 9900         	ldr	r1, [sp]
700aae34: f8c1 023c    	str.w	r0, [r1, #0x23c]
;     chHandle->pPktdmaExtRtRegs  = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700aae38: 9900         	ldr	r1, [sp]
700aae3a: f8c1 0240    	str.w	r0, [r1, #0x240]
; }
700aae3e: b001         	add	sp, #0x4
700aae40: 4770         	bx	lr
		...
700aae4e: 0000         	movs	r0, r0

700aae50 <vQueueAddToRegistry>:
;     {
700aae50: b083         	sub	sp, #0xc
700aae52: 9002         	str	r0, [sp, #0x8]
700aae54: 9101         	str	r1, [sp, #0x4]
700aae56: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700aae58: 9000         	str	r0, [sp]
700aae5a: e7ff         	b	0x700aae5c <vQueueAddToRegistry+0xc> @ imm = #-0x2
700aae5c: 9800         	ldr	r0, [sp]
700aae5e: 281f         	cmp	r0, #0x1f
700aae60: d81d         	bhi	0x700aae9e <vQueueAddToRegistry+0x4e> @ imm = #0x3a
700aae62: e7ff         	b	0x700aae64 <vQueueAddToRegistry+0x14> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].pcQueueName == NULL )
700aae64: 9900         	ldr	r1, [sp]
700aae66: f644 2078    	movw	r0, #0x4a78
700aae6a: f2c7 0008    	movt	r0, #0x7008
700aae6e: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700aae72: b970         	cbnz	r0, 0x700aae92 <vQueueAddToRegistry+0x42> @ imm = #0x1c
700aae74: e7ff         	b	0x700aae76 <vQueueAddToRegistry+0x26> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = pcQueueName;
700aae76: 9801         	ldr	r0, [sp, #0x4]
700aae78: 9a00         	ldr	r2, [sp]
700aae7a: f644 2178    	movw	r1, #0x4a78
700aae7e: f2c7 0108    	movt	r1, #0x7008
700aae82: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = xQueue;
700aae86: 9802         	ldr	r0, [sp, #0x8]
700aae88: 9a00         	ldr	r2, [sp]
700aae8a: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700aae8e: 6048         	str	r0, [r1, #0x4]
;                 break;
700aae90: e005         	b	0x700aae9e <vQueueAddToRegistry+0x4e> @ imm = #0xa
700aae92: e7ff         	b	0x700aae94 <vQueueAddToRegistry+0x44> @ imm = #-0x2
;         }
700aae94: e7ff         	b	0x700aae96 <vQueueAddToRegistry+0x46> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700aae96: 9800         	ldr	r0, [sp]
700aae98: 3001         	adds	r0, #0x1
700aae9a: 9000         	str	r0, [sp]
700aae9c: e7de         	b	0x700aae5c <vQueueAddToRegistry+0xc> @ imm = #-0x44
;     }
700aae9e: b003         	add	sp, #0xc
700aaea0: 4770         	bx	lr
		...
700aaeae: 0000         	movs	r0, r0

700aaeb0 <xQueueTakeMutexRecursive>:
;     {
700aaeb0: b580         	push	{r7, lr}
700aaeb2: b086         	sub	sp, #0x18
700aaeb4: 9005         	str	r0, [sp, #0x14]
700aaeb6: 9104         	str	r1, [sp, #0x10]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700aaeb8: 9805         	ldr	r0, [sp, #0x14]
700aaeba: 9002         	str	r0, [sp, #0x8]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700aaebc: 9802         	ldr	r0, [sp, #0x8]
700aaebe: 6880         	ldr	r0, [r0, #0x8]
700aaec0: 9001         	str	r0, [sp, #0x4]
700aaec2: f002 faed    	bl	0x700ad4a0 <xTaskGetCurrentTaskHandle> @ imm = #0x25da
700aaec6: 4601         	mov	r1, r0
700aaec8: 9801         	ldr	r0, [sp, #0x4]
700aaeca: 4288         	cmp	r0, r1
700aaecc: d107         	bne	0x700aaede <xQueueTakeMutexRecursive+0x2e> @ imm = #0xe
700aaece: e7ff         	b	0x700aaed0 <xQueueTakeMutexRecursive+0x20> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700aaed0: 9902         	ldr	r1, [sp, #0x8]
700aaed2: 68c8         	ldr	r0, [r1, #0xc]
700aaed4: 3001         	adds	r0, #0x1
700aaed6: 60c8         	str	r0, [r1, #0xc]
700aaed8: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700aaeda: 9003         	str	r0, [sp, #0xc]
;         }
700aaedc: e00e         	b	0x700aaefc <xQueueTakeMutexRecursive+0x4c> @ imm = #0x1c
;             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
700aaede: 9802         	ldr	r0, [sp, #0x8]
700aaee0: 9904         	ldr	r1, [sp, #0x10]
700aaee2: f7f4 fb2d    	bl	0x7009f540 <xQueueSemaphoreTake> @ imm = #-0xb9a6
700aaee6: 9003         	str	r0, [sp, #0xc]
;             if( xReturn != pdFAIL )
700aaee8: 9803         	ldr	r0, [sp, #0xc]
700aaeea: b128         	cbz	r0, 0x700aaef8 <xQueueTakeMutexRecursive+0x48> @ imm = #0xa
700aaeec: e7ff         	b	0x700aaeee <xQueueTakeMutexRecursive+0x3e> @ imm = #-0x2
;                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700aaeee: 9902         	ldr	r1, [sp, #0x8]
700aaef0: 68c8         	ldr	r0, [r1, #0xc]
700aaef2: 3001         	adds	r0, #0x1
700aaef4: 60c8         	str	r0, [r1, #0xc]
;             }
700aaef6: e000         	b	0x700aaefa <xQueueTakeMutexRecursive+0x4a> @ imm = #0x0
700aaef8: e7ff         	b	0x700aaefa <xQueueTakeMutexRecursive+0x4a> @ imm = #-0x2
700aaefa: e7ff         	b	0x700aaefc <xQueueTakeMutexRecursive+0x4c> @ imm = #-0x2
;         return xReturn;
700aaefc: 9803         	ldr	r0, [sp, #0xc]
700aaefe: b006         	add	sp, #0x18
700aaf00: bd80         	pop	{r7, pc}
		...
700aaf0e: 0000         	movs	r0, r0

700aaf10 <UART_checkCharsAvailInFifo>:
; {
700aaf10: b580         	push	{r7, lr}
700aaf12: b084         	sub	sp, #0x10
700aaf14: 9003         	str	r0, [sp, #0xc]
700aaf16: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700aaf18: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700aaf1a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700aaf1c: 9803         	ldr	r0, [sp, #0xc]
700aaf1e: 300c         	adds	r0, #0xc
700aaf20: f002 fb86    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x270c
700aaf24: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700aaf26: 9803         	ldr	r0, [sp, #0xc]
700aaf28: 300c         	adds	r0, #0xc
700aaf2a: 9000         	str	r0, [sp]
700aaf2c: f002 fb80    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x2700
700aaf30: 4601         	mov	r1, r0
700aaf32: 9800         	ldr	r0, [sp]
700aaf34: f001 017f    	and	r1, r1, #0x7f
700aaf38: f002 fb82    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x2704
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700aaf3c: 9803         	ldr	r0, [sp, #0xc]
700aaf3e: 3014         	adds	r0, #0x14
700aaf40: f002 fb76    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x26ec
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700aaf44: 07c0         	lsls	r0, r0, #0x1f
700aaf46: b118         	cbz	r0, 0x700aaf50 <UART_checkCharsAvailInFifo+0x40> @ imm = #0x6
700aaf48: e7ff         	b	0x700aaf4a <UART_checkCharsAvailInFifo+0x3a> @ imm = #-0x2
700aaf4a: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700aaf4c: 9001         	str	r0, [sp, #0x4]
;     }
700aaf4e: e7ff         	b	0x700aaf50 <UART_checkCharsAvailInFifo+0x40> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aaf50: 9803         	ldr	r0, [sp, #0xc]
700aaf52: 300c         	adds	r0, #0xc
700aaf54: 9902         	ldr	r1, [sp, #0x8]
700aaf56: f002 fb73    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x26e6
;     return retVal;
700aaf5a: 9801         	ldr	r0, [sp, #0x4]
700aaf5c: b004         	add	sp, #0x10
700aaf5e: bd80         	pop	{r7, pc}

700aaf60 <xQueueGiveMutexRecursive>:
;     {
700aaf60: b580         	push	{r7, lr}
700aaf62: b084         	sub	sp, #0x10
700aaf64: 9003         	str	r0, [sp, #0xc]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700aaf66: 9803         	ldr	r0, [sp, #0xc]
700aaf68: 9001         	str	r0, [sp, #0x4]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700aaf6a: 9801         	ldr	r0, [sp, #0x4]
700aaf6c: 6880         	ldr	r0, [r0, #0x8]
700aaf6e: 9000         	str	r0, [sp]
700aaf70: f002 fa96    	bl	0x700ad4a0 <xTaskGetCurrentTaskHandle> @ imm = #0x252c
700aaf74: 4601         	mov	r1, r0
700aaf76: 9800         	ldr	r0, [sp]
700aaf78: 4288         	cmp	r0, r1
700aaf7a: d113         	bne	0x700aafa4 <xQueueGiveMutexRecursive+0x44> @ imm = #0x26
700aaf7c: e7ff         	b	0x700aaf7e <xQueueGiveMutexRecursive+0x1e> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
700aaf7e: 9901         	ldr	r1, [sp, #0x4]
700aaf80: 68c8         	ldr	r0, [r1, #0xc]
700aaf82: 3801         	subs	r0, #0x1
700aaf84: 60c8         	str	r0, [r1, #0xc]
;             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
700aaf86: 9801         	ldr	r0, [sp, #0x4]
700aaf88: 68c0         	ldr	r0, [r0, #0xc]
700aaf8a: b938         	cbnz	r0, 0x700aaf9c <xQueueGiveMutexRecursive+0x3c> @ imm = #0xe
700aaf8c: e7ff         	b	0x700aaf8e <xQueueGiveMutexRecursive+0x2e> @ imm = #-0x2
;                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
700aaf8e: 9801         	ldr	r0, [sp, #0x4]
700aaf90: 2300         	movs	r3, #0x0
700aaf92: 4619         	mov	r1, r3
700aaf94: 461a         	mov	r2, r3
700aaf96: f7f6 fabb    	bl	0x700a1510 <xQueueGenericSend> @ imm = #-0x9a8a
;             }
700aaf9a: e000         	b	0x700aaf9e <xQueueGiveMutexRecursive+0x3e> @ imm = #0x0
700aaf9c: e7ff         	b	0x700aaf9e <xQueueGiveMutexRecursive+0x3e> @ imm = #-0x2
700aaf9e: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700aafa0: 9002         	str	r0, [sp, #0x8]
;         }
700aafa2: e002         	b	0x700aafaa <xQueueGiveMutexRecursive+0x4a> @ imm = #0x4
700aafa4: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700aafa6: 9002         	str	r0, [sp, #0x8]
700aafa8: e7ff         	b	0x700aafaa <xQueueGiveMutexRecursive+0x4a> @ imm = #-0x2
;         return xReturn;
700aafaa: 9802         	ldr	r0, [sp, #0x8]
700aafac: b004         	add	sp, #0x10
700aafae: bd80         	pop	{r7, pc}

700aafb0 <CSL_pktdmaIsChanEnabled>:
; {
700aafb0: b580         	push	{r7, lr}
700aafb2: b084         	sub	sp, #0x10
700aafb4: 9003         	str	r0, [sp, #0xc]
700aafb6: 9102         	str	r1, [sp, #0x8]
700aafb8: 9201         	str	r2, [sp, #0x4]
;     if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700aafba: 9801         	ldr	r0, [sp, #0x4]
700aafbc: b960         	cbnz	r0, 0x700aafd8 <CSL_pktdmaIsChanEnabled+0x28> @ imm = #0x18
700aafbe: e7ff         	b	0x700aafc0 <CSL_pktdmaIsChanEnabled+0x10> @ imm = #-0x2
;         regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_TXCRT_CHAN_CTL_EN );
700aafc0: 9803         	ldr	r0, [sp, #0xc]
700aafc2: 6900         	ldr	r0, [r0, #0x10]
700aafc4: 9902         	ldr	r1, [sp, #0x8]
700aafc6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aafca: f04f 4100    	mov.w	r1, #0x80000000
700aafce: 221f         	movs	r2, #0x1f
700aafd0: f001 fe86    	bl	0x700acce0 <CSL_REG32_FEXT_RAW> @ imm = #0x1d0c
700aafd4: 9000         	str	r0, [sp]
;     }
700aafd6: e00b         	b	0x700aaff0 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #0x16
;         regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_RXCRT_CHAN_CTL_EN );
700aafd8: 9803         	ldr	r0, [sp, #0xc]
700aafda: 6940         	ldr	r0, [r0, #0x14]
700aafdc: 9902         	ldr	r1, [sp, #0x8]
700aafde: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aafe2: f04f 4100    	mov.w	r1, #0x80000000
700aafe6: 221f         	movs	r2, #0x1f
700aafe8: f001 fe7a    	bl	0x700acce0 <CSL_REG32_FEXT_RAW> @ imm = #0x1cf4
700aafec: 9000         	str	r0, [sp]
700aafee: e7ff         	b	0x700aaff0 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700aaff0: 9800         	ldr	r0, [sp]
700aaff2: 3801         	subs	r0, #0x1
700aaff4: fab0 f080    	clz	r0, r0
700aaff8: 0940         	lsrs	r0, r0, #0x5
700aaffa: b004         	add	sp, #0x10
700aaffc: bd80         	pop	{r7, pc}
700aaffe: 0000         	movs	r0, r0

700ab000 <UART_getHandle>:
; {
700ab000: b083         	sub	sp, #0xc
700ab002: 9002         	str	r0, [sp, #0x8]
700ab004: 2000         	movs	r0, #0x0
;     UART_Handle         handle = NULL;
700ab006: 9001         	str	r0, [sp, #0x4]
;     if(index < gUartConfigNum)
700ab008: 9802         	ldr	r0, [sp, #0x8]
700ab00a: f240 11bc    	movw	r1, #0x1bc
700ab00e: f2c7 010b    	movt	r1, #0x700b
700ab012: 6809         	ldr	r1, [r1]
700ab014: 4288         	cmp	r0, r1
700ab016: d217         	bhs	0x700ab048 <UART_getHandle+0x48> @ imm = #0x2e
700ab018: e7ff         	b	0x700ab01a <UART_getHandle+0x1a> @ imm = #-0x2
;         object = gUartConfig[index].object;
700ab01a: 9902         	ldr	r1, [sp, #0x8]
700ab01c: f240 1080    	movw	r0, #0x180
700ab020: f2c7 000b    	movt	r0, #0x700b
700ab024: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ab028: 6840         	ldr	r0, [r0, #0x4]
700ab02a: 9000         	str	r0, [sp]
;         if(object && (TRUE == object->isOpen))
700ab02c: 9800         	ldr	r0, [sp]
700ab02e: b150         	cbz	r0, 0x700ab046 <UART_getHandle+0x46> @ imm = #0x14
700ab030: e7ff         	b	0x700ab032 <UART_getHandle+0x32> @ imm = #-0x2
700ab032: 9800         	ldr	r0, [sp]
700ab034: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700ab038: 2801         	cmp	r0, #0x1
700ab03a: d104         	bne	0x700ab046 <UART_getHandle+0x46> @ imm = #0x8
700ab03c: e7ff         	b	0x700ab03e <UART_getHandle+0x3e> @ imm = #-0x2
;             handle = object->handle;
700ab03e: 9800         	ldr	r0, [sp]
700ab040: 6800         	ldr	r0, [r0]
700ab042: 9001         	str	r0, [sp, #0x4]
;         }
700ab044: e7ff         	b	0x700ab046 <UART_getHandle+0x46> @ imm = #-0x2
;     }
700ab046: e7ff         	b	0x700ab048 <UART_getHandle+0x48> @ imm = #-0x2
;     return handle;
700ab048: 9801         	ldr	r0, [sp, #0x4]
700ab04a: b003         	add	sp, #0xc
700ab04c: 4770         	bx	lr
700ab04e: 0000         	movs	r0, r0

700ab050 <prvTaskIsTaskSuspended>:
; static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask) {
700ab050: b083         	sub	sp, #0xc
700ab052: 9002         	str	r0, [sp, #0x8]
700ab054: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700ab056: 9001         	str	r0, [sp, #0x4]
;   const TCB_t *const pxTCB = xTask;
700ab058: 9802         	ldr	r0, [sp, #0x8]
700ab05a: 9000         	str	r0, [sp]
;   if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) !=
700ab05c: 9800         	ldr	r0, [sp]
700ab05e: 6940         	ldr	r0, [r0, #0x14]
700ab060: f644 717c    	movw	r1, #0x4f7c
700ab064: f2c7 0108    	movt	r1, #0x7008
700ab068: 4288         	cmp	r0, r1
700ab06a: d114         	bne	0x700ab096 <prvTaskIsTaskSuspended+0x46> @ imm = #0x28
700ab06c: e7ff         	b	0x700ab06e <prvTaskIsTaskSuspended+0x1e> @ imm = #-0x2
;     if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) ==
700ab06e: 9800         	ldr	r0, [sp]
700ab070: 6a80         	ldr	r0, [r0, #0x28]
700ab072: f644 7168    	movw	r1, #0x4f68
700ab076: f2c7 0108    	movt	r1, #0x7008
700ab07a: 4288         	cmp	r0, r1
700ab07c: d009         	beq	0x700ab092 <prvTaskIsTaskSuspended+0x42> @ imm = #0x12
700ab07e: e7ff         	b	0x700ab080 <prvTaskIsTaskSuspended+0x30> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(NULL, &(pxTCB->xEventListItem)) !=
700ab080: 9800         	ldr	r0, [sp]
700ab082: 6a80         	ldr	r0, [r0, #0x28]
700ab084: b918         	cbnz	r0, 0x700ab08e <prvTaskIsTaskSuspended+0x3e> @ imm = #0x6
700ab086: e7ff         	b	0x700ab088 <prvTaskIsTaskSuspended+0x38> @ imm = #-0x2
700ab088: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700ab08a: 9001         	str	r0, [sp, #0x4]
;       } else {
700ab08c: e000         	b	0x700ab090 <prvTaskIsTaskSuspended+0x40> @ imm = #0x0
700ab08e: e7ff         	b	0x700ab090 <prvTaskIsTaskSuspended+0x40> @ imm = #-0x2
;     } else {
700ab090: e000         	b	0x700ab094 <prvTaskIsTaskSuspended+0x44> @ imm = #0x0
700ab092: e7ff         	b	0x700ab094 <prvTaskIsTaskSuspended+0x44> @ imm = #-0x2
;   } else {
700ab094: e000         	b	0x700ab098 <prvTaskIsTaskSuspended+0x48> @ imm = #0x0
700ab096: e7ff         	b	0x700ab098 <prvTaskIsTaskSuspended+0x48> @ imm = #-0x2
;   return xReturn;
700ab098: 9801         	ldr	r0, [sp, #0x4]
700ab09a: b003         	add	sp, #0xc
700ab09c: 4770         	bx	lr
700ab09e: 0000         	movs	r0, r0

700ab0a0 <Sciclient_rmPsSetInp>:
; {
700ab0a0: b082         	sub	sp, #0x8
700ab0a2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ab0a6: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ab0aa: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab0ac: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ab0ae: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ab0b2: f241 0158    	movw	r1, #0x1058
700ab0b6: f2c7 0108    	movt	r1, #0x7008
700ab0ba: 8c89         	ldrh	r1, [r1, #0x24]
700ab0bc: 4288         	cmp	r0, r1
700ab0be: da0e         	bge	0x700ab0de <Sciclient_rmPsSetInp+0x3e> @ imm = #0x1c
700ab0c0: e7ff         	b	0x700ab0c2 <Sciclient_rmPsSetInp+0x22> @ imm = #-0x2
;         gPstack.ps[index].inp = inp;
700ab0c2: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ab0c6: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ab0ca: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ab0ce: f241 0158    	movw	r1, #0x1058
700ab0d2: f2c7 0108    	movt	r1, #0x7008
700ab0d6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab0da: 80c8         	strh	r0, [r1, #0x6]
;     } else {
700ab0dc: e003         	b	0x700ab0e6 <Sciclient_rmPsSetInp+0x46> @ imm = #0x6
700ab0de: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab0e2: 9000         	str	r0, [sp]
700ab0e4: e7ff         	b	0x700ab0e6 <Sciclient_rmPsSetInp+0x46> @ imm = #-0x2
;     return r;
700ab0e6: 9800         	ldr	r0, [sp]
700ab0e8: b002         	add	sp, #0x8
700ab0ea: 4770         	bx	lr
700ab0ec: 0000         	movs	r0, r0
700ab0ee: 0000         	movs	r0, r0

700ab0f0 <Sciclient_rmPsSetOutp>:
; {
700ab0f0: b082         	sub	sp, #0x8
700ab0f2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ab0f6: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ab0fa: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab0fc: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ab0fe: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ab102: f241 0158    	movw	r1, #0x1058
700ab106: f2c7 0108    	movt	r1, #0x7008
700ab10a: 8c89         	ldrh	r1, [r1, #0x24]
700ab10c: 4288         	cmp	r0, r1
700ab10e: da0e         	bge	0x700ab12e <Sciclient_rmPsSetOutp+0x3e> @ imm = #0x1c
700ab110: e7ff         	b	0x700ab112 <Sciclient_rmPsSetOutp+0x22> @ imm = #-0x2
;         gPstack.ps[index].outp = outp;
700ab112: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ab116: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ab11a: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ab11e: f241 0158    	movw	r1, #0x1058
700ab122: f2c7 0108    	movt	r1, #0x7008
700ab126: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab12a: 8108         	strh	r0, [r1, #0x8]
;     } else {
700ab12c: e003         	b	0x700ab136 <Sciclient_rmPsSetOutp+0x46> @ imm = #0x6
700ab12e: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab132: 9000         	str	r0, [sp]
700ab134: e7ff         	b	0x700ab136 <Sciclient_rmPsSetOutp+0x46> @ imm = #-0x2
;     return r;
700ab136: 9800         	ldr	r0, [sp]
700ab138: b002         	add	sp, #0x8
700ab13a: 4770         	bx	lr
700ab13c: 0000         	movs	r0, r0
700ab13e: 0000         	movs	r0, r0

700ab140 <Udma_eventGetId>:
; {
700ab140: b084         	sub	sp, #0x10
700ab142: 9003         	str	r0, [sp, #0xc]
700ab144: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            evtNum = UDMA_EVENT_INVALID;
700ab148: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandleInt eventHandleInt = (Udma_EventHandleInt) eventHandle;
700ab14a: 9803         	ldr	r0, [sp, #0xc]
700ab14c: 9000         	str	r0, [sp]
;     if((NULL_PTR != eventHandleInt) &&
700ab14e: 9800         	ldr	r0, [sp]
700ab150: b1c8         	cbz	r0, 0x700ab186 <Udma_eventGetId+0x46> @ imm = #0x32
700ab152: e7ff         	b	0x700ab154 <Udma_eventGetId+0x14> @ imm = #-0x2
;        (UDMA_INIT_DONE == eventHandleInt->eventInitDone))
700ab154: 9800         	ldr	r0, [sp]
700ab156: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700ab15a: f64a 31cd    	movw	r1, #0xabcd
700ab15e: f6ca 31dc    	movt	r1, #0xabdc
;     if((NULL_PTR != eventHandleInt) &&
700ab162: 4288         	cmp	r0, r1
700ab164: d10f         	bne	0x700ab186 <Udma_eventGetId+0x46> @ imm = #0x1e
700ab166: e7ff         	b	0x700ab168 <Udma_eventGetId+0x28> @ imm = #-0x2
;         drvHandle = eventHandleInt->drvHandle;
700ab168: 9800         	ldr	r0, [sp]
700ab16a: 6800         	ldr	r0, [r0]
700ab16c: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != drvHandle)
700ab16e: 9801         	ldr	r0, [sp, #0x4]
700ab170: b140         	cbz	r0, 0x700ab184 <Udma_eventGetId+0x44> @ imm = #0x10
700ab172: e7ff         	b	0x700ab174 <Udma_eventGetId+0x34> @ imm = #-0x2
;             evtNum = drvHandle->iaGemOffset + eventHandleInt->globalEvent;
700ab174: 9801         	ldr	r0, [sp, #0x4]
700ab176: f8d0 0118    	ldr.w	r0, [r0, #0x118]
700ab17a: 9900         	ldr	r1, [sp]
700ab17c: 6c89         	ldr	r1, [r1, #0x48]
700ab17e: 4408         	add	r0, r1
700ab180: 9002         	str	r0, [sp, #0x8]
;         }
700ab182: e7ff         	b	0x700ab184 <Udma_eventGetId+0x44> @ imm = #-0x2
;     }
700ab184: e7ff         	b	0x700ab186 <Udma_eventGetId+0x46> @ imm = #-0x2
;     return (evtNum);
700ab186: 9802         	ldr	r0, [sp, #0x8]
700ab188: b004         	add	sp, #0x10
700ab18a: 4770         	bx	lr
700ab18c: 0000         	movs	r0, r0
700ab18e: 0000         	movs	r0, r0

700ab190 <CSL_pktdmaGetRxRT>:
; {
700ab190: b580         	push	{r7, lr}
700ab192: b084         	sub	sp, #0x10
700ab194: 9003         	str	r0, [sp, #0xc]
700ab196: 9102         	str	r1, [sp, #0x8]
700ab198: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700ab19a: 9803         	ldr	r0, [sp, #0xc]
700ab19c: 6940         	ldr	r0, [r0, #0x14]
700ab19e: 9902         	ldr	r1, [sp, #0x8]
700ab1a0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab1a4: f002 fa9c    	bl	0x700ad6e0 <CSL_REG32_RD_RAW> @ imm = #0x2538
700ab1a8: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_EN );
700ab1aa: 9800         	ldr	r0, [sp]
700ab1ac: 0fc0         	lsrs	r0, r0, #0x1f
700ab1ae: 9901         	ldr	r1, [sp, #0x4]
700ab1b0: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_TDOWN );
700ab1b2: 9800         	ldr	r0, [sp]
700ab1b4: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ab1b8: 9901         	ldr	r1, [sp, #0x4]
700ab1ba: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ab1bc: 9901         	ldr	r1, [sp, #0x4]
700ab1be: 2000         	movs	r0, #0x0
700ab1c0: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_PAUSE );
700ab1c2: 9900         	ldr	r1, [sp]
700ab1c4: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ab1c8: 9a01         	ldr	r2, [sp, #0x4]
700ab1ca: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_ERROR );
700ab1cc: 9900         	ldr	r1, [sp]
700ab1ce: f001 0101    	and	r1, r1, #0x1
700ab1d2: 9a01         	ldr	r2, [sp, #0x4]
700ab1d4: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ab1d6: b004         	add	sp, #0x10
700ab1d8: bd80         	pop	{r7, pc}
700ab1da: 0000         	movs	r0, r0
700ab1dc: 0000         	movs	r0, r0
700ab1de: 0000         	movs	r0, r0

700ab1e0 <CSL_pktdmaGetTxRT>:
; {
700ab1e0: b580         	push	{r7, lr}
700ab1e2: b084         	sub	sp, #0x10
700ab1e4: 9003         	str	r0, [sp, #0xc]
700ab1e6: 9102         	str	r1, [sp, #0x8]
700ab1e8: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700ab1ea: 9803         	ldr	r0, [sp, #0xc]
700ab1ec: 6900         	ldr	r0, [r0, #0x10]
700ab1ee: 9902         	ldr	r1, [sp, #0x8]
700ab1f0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab1f4: f002 fa74    	bl	0x700ad6e0 <CSL_REG32_RD_RAW> @ imm = #0x24e8
700ab1f8: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_EN );
700ab1fa: 9800         	ldr	r0, [sp]
700ab1fc: 0fc0         	lsrs	r0, r0, #0x1f
700ab1fe: 9901         	ldr	r1, [sp, #0x4]
700ab200: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_TDOWN );
700ab202: 9800         	ldr	r0, [sp]
700ab204: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ab208: 9901         	ldr	r1, [sp, #0x4]
700ab20a: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ab20c: 9901         	ldr	r1, [sp, #0x4]
700ab20e: 2000         	movs	r0, #0x0
700ab210: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_PAUSE );
700ab212: 9900         	ldr	r1, [sp]
700ab214: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ab218: 9a01         	ldr	r2, [sp, #0x4]
700ab21a: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_ERROR );
700ab21c: 9900         	ldr	r1, [sp]
700ab21e: f001 0101    	and	r1, r1, #0x1
700ab222: 9a01         	ldr	r2, [sp, #0x4]
700ab224: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ab226: b004         	add	sp, #0x10
700ab228: bd80         	pop	{r7, pc}
700ab22a: 0000         	movs	r0, r0
700ab22c: 0000         	movs	r0, r0
700ab22e: 0000         	movs	r0, r0

700ab230 <Sciclient_getDevId>:
; {
700ab230: b083         	sub	sp, #0xc
700ab232: 9002         	str	r0, [sp, #0x8]
700ab234: f04f 30ff    	mov.w	r0, #0xffffffff
;     uint32_t retVal = UINT32_MAX;
700ab238: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700ab23a: 9802         	ldr	r0, [sp, #0x8]
700ab23c: 9000         	str	r0, [sp]
700ab23e: 2805         	cmp	r0, #0x5
700ab240: d817         	bhi	0x700ab272 <Sciclient_getDevId+0x42> @ imm = #0x2e
700ab242: 9900         	ldr	r1, [sp]
700ab244: e8df f001    	tbb	[pc, r1]
700ab248: 03 06 09 0c  	.word	0x0c090603
700ab24c: 0f 12        	.short	0x120f
700ab24e: 2009         	movs	r0, #0x9
;         retVal = TISCI_DEV_MCU_M4FSS0_CORE0;
700ab250: 9001         	str	r0, [sp, #0x4]
;         break;
700ab252: e00f         	b	0x700ab274 <Sciclient_getDevId+0x44> @ imm = #0x1e
700ab254: 2079         	movs	r0, #0x79
;         retVal = TISCI_DEV_R5FSS0_CORE0;
700ab256: 9001         	str	r0, [sp, #0x4]
;         break;
700ab258: e00c         	b	0x700ab274 <Sciclient_getDevId+0x44> @ imm = #0x18
700ab25a: 207a         	movs	r0, #0x7a
;         retVal = TISCI_DEV_R5FSS0_CORE1;
700ab25c: 9001         	str	r0, [sp, #0x4]
;         break;
700ab25e: e009         	b	0x700ab274 <Sciclient_getDevId+0x44> @ imm = #0x12
700ab260: 207b         	movs	r0, #0x7b
;         retVal = TISCI_DEV_R5FSS1_CORE0;
700ab262: 9001         	str	r0, [sp, #0x4]
;         break;
700ab264: e006         	b	0x700ab274 <Sciclient_getDevId+0x44> @ imm = #0xc
700ab266: 207c         	movs	r0, #0x7c
;         retVal = TISCI_DEV_R5FSS1_CORE1;
700ab268: 9001         	str	r0, [sp, #0x4]
;         break;
700ab26a: e003         	b	0x700ab274 <Sciclient_getDevId+0x44> @ imm = #0x6
700ab26c: 2087         	movs	r0, #0x87
;         retVal = TISCI_DEV_A53SS0_CORE_0;
700ab26e: 9001         	str	r0, [sp, #0x4]
;         break;
700ab270: e000         	b	0x700ab274 <Sciclient_getDevId+0x44> @ imm = #0x0
;         break;
700ab272: e7ff         	b	0x700ab274 <Sciclient_getDevId+0x44> @ imm = #-0x2
;     return retVal;
700ab274: 9801         	ldr	r0, [sp, #0x4]
700ab276: b003         	add	sp, #0xc
700ab278: 4770         	bx	lr
700ab27a: 0000         	movs	r0, r0
700ab27c: 0000         	movs	r0, r0
700ab27e: 0000         	movs	r0, r0

700ab280 <UART_getIntrIdentityStatus>:
; {
700ab280: b580         	push	{r7, lr}
700ab282: b084         	sub	sp, #0x10
700ab284: 9003         	str	r0, [sp, #0xc]
700ab286: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ab288: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ab28a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ab28c: 9803         	ldr	r0, [sp, #0xc]
700ab28e: 300c         	adds	r0, #0xc
700ab290: f002 f9ce    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x239c
700ab294: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ab296: 9803         	ldr	r0, [sp, #0xc]
700ab298: 300c         	adds	r0, #0xc
700ab29a: 9000         	str	r0, [sp]
700ab29c: f002 f9c8    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x2390
700ab2a0: 4601         	mov	r1, r0
700ab2a2: 9800         	ldr	r0, [sp]
700ab2a4: f001 017f    	and	r1, r1, #0x7f
700ab2a8: f002 f9ca    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x2394
;     retVal = HW_RD_REG32(baseAddr + UART_IIR) & UART_IIR_IT_TYPE_MASK;
700ab2ac: 9803         	ldr	r0, [sp, #0xc]
700ab2ae: 3008         	adds	r0, #0x8
700ab2b0: f002 f9be    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x237c
700ab2b4: f000 003e    	and	r0, r0, #0x3e
700ab2b8: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ab2ba: 9803         	ldr	r0, [sp, #0xc]
700ab2bc: 300c         	adds	r0, #0xc
700ab2be: 9902         	ldr	r1, [sp, #0x8]
700ab2c0: f002 f9be    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x237c
;     return retVal;
700ab2c4: 9801         	ldr	r0, [sp, #0x4]
700ab2c6: b004         	add	sp, #0x10
700ab2c8: bd80         	pop	{r7, pc}
700ab2ca: 0000         	movs	r0, r0
700ab2cc: 0000         	movs	r0, r0
700ab2ce: 0000         	movs	r0, r0

700ab2d0 <UART_lineCharConfig>:
; {
700ab2d0: b580         	push	{r7, lr}
700ab2d2: b084         	sub	sp, #0x10
700ab2d4: 9003         	str	r0, [sp, #0xc]
700ab2d6: 9102         	str	r1, [sp, #0x8]
700ab2d8: 9201         	str	r2, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ab2da: 9803         	ldr	r0, [sp, #0xc]
700ab2dc: 300c         	adds	r0, #0xc
700ab2de: f002 f9a7    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x234e
700ab2e2: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_NB_STOP_MASK | (uint32_t) UART_LCR_CHAR_LENGTH_MASK);
700ab2e4: 9800         	ldr	r0, [sp]
700ab2e6: f020 0007    	bic	r0, r0, #0x7
700ab2ea: 9000         	str	r0, [sp]
;     lcrRegValue |= wLenStbFlag & (UART_LCR_NB_STOP_MASK |
700ab2ec: 9802         	ldr	r0, [sp, #0x8]
700ab2ee: f000 0107    	and	r1, r0, #0x7
700ab2f2: 9800         	ldr	r0, [sp]
700ab2f4: 4308         	orrs	r0, r1
700ab2f6: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_PARITY_TYPE2_MASK |
700ab2f8: 9800         	ldr	r0, [sp]
700ab2fa: f020 0038    	bic	r0, r0, #0x38
700ab2fe: 9000         	str	r0, [sp]
;     lcrRegValue |= parityFlag & (UART_LCR_PARITY_TYPE2_MASK |
700ab300: 9801         	ldr	r0, [sp, #0x4]
700ab302: f000 0138    	and	r1, r0, #0x38
700ab306: 9800         	ldr	r0, [sp]
700ab308: 4308         	orrs	r0, r1
700ab30a: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ab30c: 9803         	ldr	r0, [sp, #0xc]
700ab30e: 300c         	adds	r0, #0xc
700ab310: 9900         	ldr	r1, [sp]
700ab312: f002 f995    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x232a
; }
700ab316: b004         	add	sp, #0x10
700ab318: bd80         	pop	{r7, pc}
700ab31a: 0000         	movs	r0, r0
700ab31c: 0000         	movs	r0, r0
700ab31e: 0000         	movs	r0, r0

700ab320 <UART_lld_dmaInit>:
; {
700ab320: b580         	push	{r7, lr}
700ab322: b084         	sub	sp, #0x10
700ab324: 9003         	str	r0, [sp, #0xc]
700ab326: 9102         	str	r1, [sp, #0x8]
700ab328: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ab32a: 9001         	str	r0, [sp, #0x4]
;     UART_UdmaChConfig *udmaChCfg = (UART_UdmaChConfig *)dmaChCfg;
700ab32c: 9802         	ldr	r0, [sp, #0x8]
700ab32e: 9000         	str	r0, [sp]
;     status  = UART_udmaInitRxCh(hUart, udmaChCfg);
700ab330: 9803         	ldr	r0, [sp, #0xc]
700ab332: 9900         	ldr	r1, [sp]
700ab334: f7f7 f93c    	bl	0x700a25b0 <UART_udmaInitRxCh> @ imm = #-0x8d88
700ab338: 9001         	str	r0, [sp, #0x4]
;     status += UART_udmaInitTxCh(hUart, udmaChCfg);
700ab33a: 9803         	ldr	r0, [sp, #0xc]
700ab33c: 9900         	ldr	r1, [sp]
700ab33e: f7f7 f9c7    	bl	0x700a26d0 <UART_udmaInitTxCh> @ imm = #-0x8c72
700ab342: 4601         	mov	r1, r0
700ab344: 9801         	ldr	r0, [sp, #0x4]
700ab346: 4408         	add	r0, r1
700ab348: 9001         	str	r0, [sp, #0x4]
;     if (status == UDMA_SOK)
700ab34a: 9801         	ldr	r0, [sp, #0x4]
700ab34c: b930         	cbnz	r0, 0x700ab35c <UART_lld_dmaInit+0x3c> @ imm = #0xc
700ab34e: e7ff         	b	0x700ab350 <UART_lld_dmaInit+0x30> @ imm = #-0x2
;         udmaChCfg->isOpen = TRUE;
700ab350: 9900         	ldr	r1, [sp]
700ab352: 2001         	movs	r0, #0x1
700ab354: 6388         	str	r0, [r1, #0x38]
700ab356: 2000         	movs	r0, #0x0
;         status = UART_TRANSFER_STATUS_SUCCESS;
700ab358: 9001         	str	r0, [sp, #0x4]
;     }
700ab35a: e003         	b	0x700ab364 <UART_lld_dmaInit+0x44> @ imm = #0x6
700ab35c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ab360: 9001         	str	r0, [sp, #0x4]
700ab362: e7ff         	b	0x700ab364 <UART_lld_dmaInit+0x44> @ imm = #-0x2
;     return status;
700ab364: 9801         	ldr	r0, [sp, #0x4]
700ab366: b004         	add	sp, #0x10
700ab368: bd80         	pop	{r7, pc}
700ab36a: 0000         	movs	r0, r0
700ab36c: 0000         	movs	r0, r0
700ab36e: 0000         	movs	r0, r0

700ab370 <xQueueGenericCreateStatic>:
;     {
700ab370: b580         	push	{r7, lr}
700ab372: b088         	sub	sp, #0x20
700ab374: 4684         	mov	r12, r0
700ab376: 980a         	ldr	r0, [sp, #0x28]
700ab378: f8cd c01c    	str.w	r12, [sp, #0x1c]
700ab37c: 9106         	str	r1, [sp, #0x18]
700ab37e: 9205         	str	r2, [sp, #0x14]
700ab380: 9304         	str	r3, [sp, #0x10]
700ab382: f88d 000f    	strb.w	r0, [sp, #0xf]
;         pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
700ab386: 9804         	ldr	r0, [sp, #0x10]
700ab388: 9002         	str	r0, [sp, #0x8]
;         if( pxNewQueue != NULL )
700ab38a: 9802         	ldr	r0, [sp, #0x8]
700ab38c: b188         	cbz	r0, 0x700ab3b2 <xQueueGenericCreateStatic+0x42> @ imm = #0x22
700ab38e: e7ff         	b	0x700ab390 <xQueueGenericCreateStatic+0x20> @ imm = #-0x2
;                     pxNewQueue->ucStaticallyAllocated = pdTRUE;
700ab390: 9902         	ldr	r1, [sp, #0x8]
700ab392: 2001         	movs	r0, #0x1
700ab394: f881 0046    	strb.w	r0, [r1, #0x46]
;             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
700ab398: 9807         	ldr	r0, [sp, #0x1c]
700ab39a: 9906         	ldr	r1, [sp, #0x18]
700ab39c: 9a05         	ldr	r2, [sp, #0x14]
700ab39e: f89d 300f    	ldrb.w	r3, [sp, #0xf]
700ab3a2: f8dd c008    	ldr.w	r12, [sp, #0x8]
700ab3a6: 46ee         	mov	lr, sp
700ab3a8: f8ce c000    	str.w	r12, [lr]
700ab3ac: f000 f830    	bl	0x700ab410 <prvInitialiseNewQueue> @ imm = #0x60
;         }
700ab3b0: e000         	b	0x700ab3b4 <xQueueGenericCreateStatic+0x44> @ imm = #0x0
700ab3b2: e7ff         	b	0x700ab3b4 <xQueueGenericCreateStatic+0x44> @ imm = #-0x2
;         return pxNewQueue;
700ab3b4: 9802         	ldr	r0, [sp, #0x8]
700ab3b6: b008         	add	sp, #0x20
700ab3b8: bd80         	pop	{r7, pc}
700ab3ba: 0000         	movs	r0, r0
700ab3bc: 0000         	movs	r0, r0
700ab3be: 0000         	movs	r0, r0

700ab3c0 <UART_resetModule>:
; {
700ab3c0: b580         	push	{r7, lr}
700ab3c2: b082         	sub	sp, #0x8
700ab3c4: 9001         	str	r0, [sp, #0x4]
;     (void)UART_enhanFuncEnable(hUart->baseAddr);
700ab3c6: 9801         	ldr	r0, [sp, #0x4]
700ab3c8: 6800         	ldr	r0, [r0]
700ab3ca: f000 fcf9    	bl	0x700abdc0 <UART_enhanFuncEnable> @ imm = #0x9f2
;     UART_regConfModeRestore(hUart->baseAddr, 0x00U);
700ab3ce: 9801         	ldr	r0, [sp, #0x4]
700ab3d0: 6800         	ldr	r0, [r0]
700ab3d2: 2100         	movs	r1, #0x0
700ab3d4: f002 f824    	bl	0x700ad420 <UART_regConfModeRestore> @ imm = #0x2048
;     UART_modemControlReset(hUart->baseAddr);
700ab3d8: 9801         	ldr	r0, [sp, #0x4]
700ab3da: 6800         	ldr	r0, [r0]
700ab3dc: f001 ff50    	bl	0x700ad280 <UART_modemControlReset> @ imm = #0x1ea0
;     UART_intrDisable(hUart->baseAddr, 0xFFU);
700ab3e0: 9801         	ldr	r0, [sp, #0x4]
700ab3e2: 6800         	ldr	r0, [r0]
700ab3e4: 21ff         	movs	r1, #0xff
700ab3e6: f7f8 ffcb    	bl	0x700a4380 <UART_intrDisable> @ imm = #-0x706a
;     UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700ab3ea: 9801         	ldr	r0, [sp, #0x4]
700ab3ec: 6800         	ldr	r0, [r0]
700ab3ee: 2102         	movs	r1, #0x2
700ab3f0: f001 fac6    	bl	0x700ac980 <UART_intr2Disable> @ imm = #0x158c
;     (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700ab3f4: 9801         	ldr	r0, [sp, #0x4]
700ab3f6: 6800         	ldr	r0, [r0]
700ab3f8: 2107         	movs	r1, #0x7
700ab3fa: f001 fb09    	bl	0x700aca10 <UART_operatingModeSelect> @ imm = #0x1612
;     UART_moduleReset(hUart);
700ab3fe: 9801         	ldr	r0, [sp, #0x4]
700ab400: f7fd fa4e    	bl	0x700a88a0 <UART_moduleReset> @ imm = #-0x2b64
;     return;
700ab404: b002         	add	sp, #0x8
700ab406: bd80         	pop	{r7, pc}
		...

700ab410 <prvInitialiseNewQueue>:
; {
700ab410: b580         	push	{r7, lr}
700ab412: b084         	sub	sp, #0x10
700ab414: f8dd c018    	ldr.w	r12, [sp, #0x18]
700ab418: 9003         	str	r0, [sp, #0xc]
700ab41a: 9102         	str	r1, [sp, #0x8]
700ab41c: 9201         	str	r2, [sp, #0x4]
700ab41e: f88d 3003    	strb.w	r3, [sp, #0x3]
;     if( uxItemSize == ( UBaseType_t ) 0 )
700ab422: 9802         	ldr	r0, [sp, #0x8]
700ab424: b918         	cbnz	r0, 0x700ab42e <prvInitialiseNewQueue+0x1e> @ imm = #0x6
700ab426: e7ff         	b	0x700ab428 <prvInitialiseNewQueue+0x18> @ imm = #-0x2
;         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
700ab428: 9806         	ldr	r0, [sp, #0x18]
700ab42a: 6000         	str	r0, [r0]
;     }
700ab42c: e003         	b	0x700ab436 <prvInitialiseNewQueue+0x26> @ imm = #0x6
;         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
700ab42e: 9801         	ldr	r0, [sp, #0x4]
700ab430: 9906         	ldr	r1, [sp, #0x18]
700ab432: 6008         	str	r0, [r1]
700ab434: e7ff         	b	0x700ab436 <prvInitialiseNewQueue+0x26> @ imm = #-0x2
;     pxNewQueue->uxLength = uxQueueLength;
700ab436: 9803         	ldr	r0, [sp, #0xc]
700ab438: 9906         	ldr	r1, [sp, #0x18]
700ab43a: 63c8         	str	r0, [r1, #0x3c]
;     pxNewQueue->uxItemSize = uxItemSize;
700ab43c: 9802         	ldr	r0, [sp, #0x8]
700ab43e: 9906         	ldr	r1, [sp, #0x18]
700ab440: 6408         	str	r0, [r1, #0x40]
;     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
700ab442: 9806         	ldr	r0, [sp, #0x18]
700ab444: 2101         	movs	r1, #0x1
700ab446: f7fc fecb    	bl	0x700a81e0 <xQueueGenericReset> @ imm = #-0x326a
;             pxNewQueue->ucQueueType = ucQueueType;
700ab44a: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab44e: 9906         	ldr	r1, [sp, #0x18]
700ab450: f881 004c    	strb.w	r0, [r1, #0x4c]
; }
700ab454: b004         	add	sp, #0x10
700ab456: bd80         	pop	{r7, pc}
		...

700ab460 <uxListRemove>:
; {
700ab460: b082         	sub	sp, #0x8
700ab462: 9001         	str	r0, [sp, #0x4]
;     List_t * const pxList = pxItemToRemove->pxContainer;
700ab464: 9801         	ldr	r0, [sp, #0x4]
700ab466: 6900         	ldr	r0, [r0, #0x10]
700ab468: 9000         	str	r0, [sp]
;     pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
700ab46a: 9801         	ldr	r0, [sp, #0x4]
700ab46c: 6841         	ldr	r1, [r0, #0x4]
700ab46e: 6880         	ldr	r0, [r0, #0x8]
700ab470: 6088         	str	r0, [r1, #0x8]
;     pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
700ab472: 9901         	ldr	r1, [sp, #0x4]
700ab474: 6848         	ldr	r0, [r1, #0x4]
700ab476: 6889         	ldr	r1, [r1, #0x8]
700ab478: 6048         	str	r0, [r1, #0x4]
;     if( pxList->pxIndex == pxItemToRemove )
700ab47a: 9800         	ldr	r0, [sp]
700ab47c: 6840         	ldr	r0, [r0, #0x4]
700ab47e: 9901         	ldr	r1, [sp, #0x4]
700ab480: 4288         	cmp	r0, r1
700ab482: d105         	bne	0x700ab490 <uxListRemove+0x30> @ imm = #0xa
700ab484: e7ff         	b	0x700ab486 <uxListRemove+0x26> @ imm = #-0x2
;         pxList->pxIndex = pxItemToRemove->pxPrevious;
700ab486: 9801         	ldr	r0, [sp, #0x4]
700ab488: 6880         	ldr	r0, [r0, #0x8]
700ab48a: 9900         	ldr	r1, [sp]
700ab48c: 6048         	str	r0, [r1, #0x4]
;     }
700ab48e: e000         	b	0x700ab492 <uxListRemove+0x32> @ imm = #0x0
700ab490: e7ff         	b	0x700ab492 <uxListRemove+0x32> @ imm = #-0x2
;     pxItemToRemove->pxContainer = NULL;
700ab492: 9901         	ldr	r1, [sp, #0x4]
700ab494: 2000         	movs	r0, #0x0
700ab496: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )--;
700ab498: 9900         	ldr	r1, [sp]
700ab49a: 6808         	ldr	r0, [r1]
700ab49c: 3801         	subs	r0, #0x1
700ab49e: 6008         	str	r0, [r1]
;     return pxList->uxNumberOfItems;
700ab4a0: 9800         	ldr	r0, [sp]
700ab4a2: 6800         	ldr	r0, [r0]
700ab4a4: b002         	add	sp, #0x8
700ab4a6: 4770         	bx	lr
		...

700ab4b0 <CSL_bcdmaTeardownRxChan>:
; {
700ab4b0: b580         	push	{r7, lr}
700ab4b2: b086         	sub	sp, #0x18
700ab4b4: 9005         	str	r0, [sp, #0x14]
700ab4b6: 9104         	str	r1, [sp, #0x10]
700ab4b8: f88d 200f    	strb.w	r2, [sp, #0xf]
700ab4bc: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ab4c0: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ab4c4: f000 0001    	and	r0, r0, #0x1
700ab4c8: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ab4ca: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ab4ce: f000 0001    	and	r0, r0, #0x1
700ab4d2: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ab4d4: 9805         	ldr	r0, [sp, #0x14]
700ab4d6: 9a04         	ldr	r2, [sp, #0x10]
700ab4d8: 2105         	movs	r1, #0x5
700ab4da: 466b         	mov	r3, sp
700ab4dc: f7fd fca0    	bl	0x700a8e20 <CSL_bcdmaDoChanOp> @ imm = #-0x26c0
700ab4e0: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ab4e2: 9802         	ldr	r0, [sp, #0x8]
700ab4e4: b120         	cbz	r0, 0x700ab4f0 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #0x8
700ab4e6: e7ff         	b	0x700ab4e8 <CSL_bcdmaTeardownRxChan+0x38> @ imm = #-0x2
700ab4e8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ab4ec: 9002         	str	r0, [sp, #0x8]
;     }
700ab4ee: e7ff         	b	0x700ab4f0 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #-0x2
;     return retVal;
700ab4f0: 9802         	ldr	r0, [sp, #0x8]
700ab4f2: b006         	add	sp, #0x18
700ab4f4: bd80         	pop	{r7, pc}
		...
700ab4fe: 0000         	movs	r0, r0

700ab500 <CSL_bcdmaTeardownTxChan>:
; {
700ab500: b580         	push	{r7, lr}
700ab502: b086         	sub	sp, #0x18
700ab504: 9005         	str	r0, [sp, #0x14]
700ab506: 9104         	str	r1, [sp, #0x10]
700ab508: f88d 200f    	strb.w	r2, [sp, #0xf]
700ab50c: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ab510: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ab514: f000 0001    	and	r0, r0, #0x1
700ab518: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ab51a: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ab51e: f000 0001    	and	r0, r0, #0x1
700ab522: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ab524: 9805         	ldr	r0, [sp, #0x14]
700ab526: 9a04         	ldr	r2, [sp, #0x10]
700ab528: 2105         	movs	r1, #0x5
700ab52a: 466b         	mov	r3, sp
700ab52c: f7fd fc78    	bl	0x700a8e20 <CSL_bcdmaDoChanOp> @ imm = #-0x2710
700ab530: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ab532: 9802         	ldr	r0, [sp, #0x8]
700ab534: b120         	cbz	r0, 0x700ab540 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #0x8
700ab536: e7ff         	b	0x700ab538 <CSL_bcdmaTeardownTxChan+0x38> @ imm = #-0x2
700ab538: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ab53c: 9002         	str	r0, [sp, #0x8]
;     }
700ab53e: e7ff         	b	0x700ab540 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #-0x2
;     return retVal;
700ab540: 9802         	ldr	r0, [sp, #0x8]
700ab542: b006         	add	sp, #0x18
700ab544: bd80         	pop	{r7, pc}
		...
700ab54e: 0000         	movs	r0, r0

700ab550 <DebugP_uartLogWriterPutChar>:
; {
700ab550: b580         	push	{r7, lr}
700ab552: b088         	sub	sp, #0x20
700ab554: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     char value = character;
700ab558: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700ab55c: f88d 001e    	strb.w	r0, [sp, #0x1e]
;     UART_Handle uartHandle = UART_getHandle(gDebugP_uartDrvIndex);
700ab560: f240 10b4    	movw	r0, #0x1b4
700ab564: f2c7 000b    	movt	r0, #0x700b
700ab568: 6800         	ldr	r0, [r0]
700ab56a: f7ff fd49    	bl	0x700ab000 <UART_getHandle> @ imm = #-0x56e
700ab56e: 9006         	str	r0, [sp, #0x18]
;     if(uartHandle!=NULL)
700ab570: 9806         	ldr	r0, [sp, #0x18]
700ab572: b170         	cbz	r0, 0x700ab592 <DebugP_uartLogWriterPutChar+0x42> @ imm = #0x1c
700ab574: e7ff         	b	0x700ab576 <DebugP_uartLogWriterPutChar+0x26> @ imm = #-0x2
700ab576: a801         	add	r0, sp, #0x4
;         UART_Transaction_init(&trans);
700ab578: 9000         	str	r0, [sp]
700ab57a: f001 f9e9    	bl	0x700ac950 <UART_Transaction_init> @ imm = #0x13d2
700ab57e: 9900         	ldr	r1, [sp]
700ab580: f10d 001e    	add.w	r0, sp, #0x1e
;         trans.buf   = &value;
700ab584: 9001         	str	r0, [sp, #0x4]
700ab586: 2001         	movs	r0, #0x1
;         trans.count = 1;
700ab588: 9002         	str	r0, [sp, #0x8]
;         (void) UART_write(uartHandle, &trans);
700ab58a: 9806         	ldr	r0, [sp, #0x18]
700ab58c: f7f2 ff30    	bl	0x7009e3f0 <UART_write> @ imm = #-0xd1a0
;     }
700ab590: e7ff         	b	0x700ab592 <DebugP_uartLogWriterPutChar+0x42> @ imm = #-0x2
; }
700ab592: b008         	add	sp, #0x20
700ab594: bd80         	pop	{r7, pc}
		...
700ab59e: 0000         	movs	r0, r0

700ab5a0 <UART_readLineStatus>:
; {
700ab5a0: b580         	push	{r7, lr}
700ab5a2: b084         	sub	sp, #0x10
700ab5a4: 9003         	str	r0, [sp, #0xc]
700ab5a6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ab5a8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ab5aa: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ab5ac: 9803         	ldr	r0, [sp, #0xc]
700ab5ae: 300c         	adds	r0, #0xc
700ab5b0: f002 f83e    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x207c
700ab5b4: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ab5b6: 9803         	ldr	r0, [sp, #0xc]
700ab5b8: 300c         	adds	r0, #0xc
700ab5ba: 9000         	str	r0, [sp]
700ab5bc: f002 f838    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x2070
700ab5c0: 4601         	mov	r1, r0
700ab5c2: 9800         	ldr	r0, [sp]
700ab5c4: f001 017f    	and	r1, r1, #0x7f
700ab5c8: f002 f83a    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x2074
;     retVal = HW_RD_REG32(baseAddr + UART_LSR);
700ab5cc: 9803         	ldr	r0, [sp, #0xc]
700ab5ce: 3014         	adds	r0, #0x14
700ab5d0: f002 f82e    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x205c
700ab5d4: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ab5d6: 9803         	ldr	r0, [sp, #0xc]
700ab5d8: 300c         	adds	r0, #0xc
700ab5da: 9902         	ldr	r1, [sp, #0x8]
700ab5dc: f002 f830    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x2060
;     return retVal;
700ab5e0: 9801         	ldr	r0, [sp, #0x4]
700ab5e2: b004         	add	sp, #0x10
700ab5e4: bd80         	pop	{r7, pc}
		...
700ab5ee: 0000         	movs	r0, r0

700ab5f0 <vTaskExitCritical>:
;   if (xSchedulerRunning != pdFALSE) {
700ab5f0: f240 200c    	movw	r0, #0x20c
700ab5f4: f2c7 000b    	movt	r0, #0x700b
700ab5f8: 6800         	ldr	r0, [r0]
700ab5fa: b1d0         	cbz	r0, 0x700ab632 <vTaskExitCritical+0x42> @ imm = #0x34
700ab5fc: e7ff         	b	0x700ab5fe <vTaskExitCritical+0xe> @ imm = #-0x2
;     if (pxCurrentTCB->uxCriticalNesting > 0U) {
700ab5fe: f240 10cc    	movw	r0, #0x1cc
700ab602: f2c7 000b    	movt	r0, #0x700b
700ab606: 6800         	ldr	r0, [r0]
700ab608: 6d40         	ldr	r0, [r0, #0x54]
700ab60a: b180         	cbz	r0, 0x700ab62e <vTaskExitCritical+0x3e> @ imm = #0x20
700ab60c: e7ff         	b	0x700ab60e <vTaskExitCritical+0x1e> @ imm = #-0x2
;       (pxCurrentTCB->uxCriticalNesting)--;
700ab60e: f240 10cc    	movw	r0, #0x1cc
700ab612: f2c7 000b    	movt	r0, #0x700b
700ab616: 6802         	ldr	r2, [r0]
700ab618: 6d51         	ldr	r1, [r2, #0x54]
700ab61a: 3901         	subs	r1, #0x1
700ab61c: 6551         	str	r1, [r2, #0x54]
;       if (pxCurrentTCB->uxCriticalNesting == 0U) {
700ab61e: 6800         	ldr	r0, [r0]
700ab620: 6d40         	ldr	r0, [r0, #0x54]
700ab622: b910         	cbnz	r0, 0x700ab62a <vTaskExitCritical+0x3a> @ imm = #0x4
700ab624: e7ff         	b	0x700ab626 <vTaskExitCritical+0x36> @ imm = #-0x2
;     __asm__ volatile ( "CPSIE	i" ::: "cc" );
700ab626: b662         	cpsie i
;       } else {
700ab628: e000         	b	0x700ab62c <vTaskExitCritical+0x3c> @ imm = #0x0
700ab62a: e7ff         	b	0x700ab62c <vTaskExitCritical+0x3c> @ imm = #-0x2
;     } else {
700ab62c: e000         	b	0x700ab630 <vTaskExitCritical+0x40> @ imm = #0x0
700ab62e: e7ff         	b	0x700ab630 <vTaskExitCritical+0x40> @ imm = #-0x2
;   } else {
700ab630: e000         	b	0x700ab634 <vTaskExitCritical+0x44> @ imm = #0x0
700ab632: e7ff         	b	0x700ab634 <vTaskExitCritical+0x44> @ imm = #-0x2
; }
700ab634: 4770         	bx	lr
		...
700ab63e: 0000         	movs	r0, r0

700ab640 <CSL_bcdmaGetChanPeerReg>:
; {
700ab640: b580         	push	{r7, lr}
700ab642: b088         	sub	sp, #0x20
700ab644: f8dd c028    	ldr.w	r12, [sp, #0x28]
700ab648: 9007         	str	r0, [sp, #0x1c]
700ab64a: 9106         	str	r1, [sp, #0x18]
700ab64c: 9205         	str	r2, [sp, #0x14]
700ab64e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700ab650: 9804         	ldr	r0, [sp, #0x10]
700ab652: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700ab654: 9807         	ldr	r0, [sp, #0x1c]
700ab656: 9a06         	ldr	r2, [sp, #0x18]
700ab658: 210b         	movs	r1, #0xb
700ab65a: ab01         	add	r3, sp, #0x4
700ab65c: f7fd fbe0    	bl	0x700a8e20 <CSL_bcdmaDoChanOp> @ imm = #-0x2840
700ab660: 9003         	str	r0, [sp, #0xc]
;     if( retVal == CSL_PASS )
700ab662: 9803         	ldr	r0, [sp, #0xc]
700ab664: b920         	cbnz	r0, 0x700ab670 <CSL_bcdmaGetChanPeerReg+0x30> @ imm = #0x8
700ab666: e7ff         	b	0x700ab668 <CSL_bcdmaGetChanPeerReg+0x28> @ imm = #-0x2
;         *pVal = remotePeerOpts.regVal;
700ab668: 9802         	ldr	r0, [sp, #0x8]
700ab66a: 990a         	ldr	r1, [sp, #0x28]
700ab66c: 6008         	str	r0, [r1]
;     }
700ab66e: e006         	b	0x700ab67e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #0xc
;         *pVal = (uint32_t)0U;
700ab670: 990a         	ldr	r1, [sp, #0x28]
700ab672: 2000         	movs	r0, #0x0
700ab674: 6008         	str	r0, [r1]
700ab676: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ab67a: 9003         	str	r0, [sp, #0xc]
700ab67c: e7ff         	b	0x700ab67e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #-0x2
;     return retVal;
700ab67e: 9803         	ldr	r0, [sp, #0xc]
700ab680: b008         	add	sp, #0x20
700ab682: bd80         	pop	{r7, pc}
		...

700ab690 <_strnlen_s>:
; {
700ab690: b084         	sub	sp, #0x10
700ab692: 9003         	str	r0, [sp, #0xc]
700ab694: 9102         	str	r1, [sp, #0x8]
;   for (s = str; *s && maxsize--; ++s);
700ab696: 9803         	ldr	r0, [sp, #0xc]
700ab698: 9001         	str	r0, [sp, #0x4]
700ab69a: e7ff         	b	0x700ab69c <_strnlen_s+0xc> @ imm = #-0x2
700ab69c: 9801         	ldr	r0, [sp, #0x4]
700ab69e: 7801         	ldrb	r1, [r0]
700ab6a0: 2000         	movs	r0, #0x0
700ab6a2: 9000         	str	r0, [sp]
700ab6a4: b141         	cbz	r1, 0x700ab6b8 <_strnlen_s+0x28> @ imm = #0x10
700ab6a6: e7ff         	b	0x700ab6a8 <_strnlen_s+0x18> @ imm = #-0x2
700ab6a8: 9802         	ldr	r0, [sp, #0x8]
700ab6aa: 1e41         	subs	r1, r0, #0x1
700ab6ac: 9102         	str	r1, [sp, #0x8]
700ab6ae: 2800         	cmp	r0, #0x0
700ab6b0: bf18         	it	ne
700ab6b2: 2001         	movne	r0, #0x1
700ab6b4: 9000         	str	r0, [sp]
700ab6b6: e7ff         	b	0x700ab6b8 <_strnlen_s+0x28> @ imm = #-0x2
700ab6b8: 9800         	ldr	r0, [sp]
;   for (s = str; *s && maxsize--; ++s);
700ab6ba: 07c0         	lsls	r0, r0, #0x1f
700ab6bc: b128         	cbz	r0, 0x700ab6ca <_strnlen_s+0x3a> @ imm = #0xa
700ab6be: e7ff         	b	0x700ab6c0 <_strnlen_s+0x30> @ imm = #-0x2
700ab6c0: e7ff         	b	0x700ab6c2 <_strnlen_s+0x32> @ imm = #-0x2
700ab6c2: 9801         	ldr	r0, [sp, #0x4]
700ab6c4: 3001         	adds	r0, #0x1
700ab6c6: 9001         	str	r0, [sp, #0x4]
700ab6c8: e7e8         	b	0x700ab69c <_strnlen_s+0xc> @ imm = #-0x30
;   return (unsigned int)(s - str);
700ab6ca: 9801         	ldr	r0, [sp, #0x4]
700ab6cc: 9903         	ldr	r1, [sp, #0xc]
700ab6ce: 1a40         	subs	r0, r0, r1
700ab6d0: b004         	add	sp, #0x10
700ab6d2: 4770         	bx	lr

700ab6d4 <free_list_insert>:
700ab6d4: e5902000     	ldr	r2, [r0]
700ab6d8: e59f1034     	ldr	r1, [pc, #0x34]         @ 0x700ab714 <free_list_insert+0x40>
700ab6dc: e3c2c001     	bic	r12, r2, #1
700ab6e0: e5912000     	ldr	r2, [r1]
700ab6e4: e3520000     	cmp	r2, #0
700ab6e8: 0a000005     	beq	0x700ab704 <free_list_insert+0x30> @ imm = #0x14
700ab6ec: e5923000     	ldr	r3, [r2]
700ab6f0: e3c33001     	bic	r3, r3, #1
700ab6f4: e153000c     	cmp	r3, r12
700ab6f8: 2a000002     	bhs	0x700ab708 <free_list_insert+0x34> @ imm = #0x8
700ab6fc: e2821008     	add	r1, r2, #8
700ab700: eafffff6     	b	0x700ab6e0 <free_list_insert+0xc> @ imm = #-0x28
700ab704: e3a02000     	mov	r2, #0
700ab708: e5802008     	str	r2, [r0, #0x8]
700ab70c: e5810000     	str	r0, [r1]
700ab710: e12fff1e     	bx	lr
700ab714: c4 4f 08 70  	.word	0x70084fc4
700ab718: 00 00 00 00  	.word	0x00000000
700ab71c: 00 00 00 00  	.word	0x00000000

700ab720 <prvSampleTimeNow>:
;     {
700ab720: b580         	push	{r7, lr}
700ab722: b082         	sub	sp, #0x8
700ab724: 9001         	str	r0, [sp, #0x4]
;         xTimeNow = xTaskGetTickCount();
700ab726: f001 fccb    	bl	0x700ad0c0 <xTaskGetTickCount> @ imm = #0x1996
700ab72a: 9000         	str	r0, [sp]
;         if( xTimeNow < xLastTime )
700ab72c: 9800         	ldr	r0, [sp]
700ab72e: f240 11c8    	movw	r1, #0x1c8
700ab732: f2c7 010b    	movt	r1, #0x700b
700ab736: 6809         	ldr	r1, [r1]
700ab738: 4288         	cmp	r0, r1
700ab73a: d206         	bhs	0x700ab74a <prvSampleTimeNow+0x2a> @ imm = #0xc
700ab73c: e7ff         	b	0x700ab73e <prvSampleTimeNow+0x1e> @ imm = #-0x2
;             prvSwitchTimerLists();
700ab73e: f7f9 fff7    	bl	0x700a5730 <prvSwitchTimerLists> @ imm = #-0x6012
;             *pxTimerListsWereSwitched = pdTRUE;
700ab742: 9901         	ldr	r1, [sp, #0x4]
700ab744: 2001         	movs	r0, #0x1
700ab746: 6008         	str	r0, [r1]
;         }
700ab748: e003         	b	0x700ab752 <prvSampleTimeNow+0x32> @ imm = #0x6
;             *pxTimerListsWereSwitched = pdFALSE;
700ab74a: 9901         	ldr	r1, [sp, #0x4]
700ab74c: 2000         	movs	r0, #0x0
700ab74e: 6008         	str	r0, [r1]
700ab750: e7ff         	b	0x700ab752 <prvSampleTimeNow+0x32> @ imm = #-0x2
;         xLastTime = xTimeNow;
700ab752: 9800         	ldr	r0, [sp]
700ab754: f240 11c8    	movw	r1, #0x1c8
700ab758: f2c7 010b    	movt	r1, #0x700b
700ab75c: 6008         	str	r0, [r1]
;         return xTimeNow;
700ab75e: 9800         	ldr	r0, [sp]
700ab760: b002         	add	sp, #0x8
700ab762: bd80         	pop	{r7, pc}
		...

700ab770 <CSL_udmapCppi5SetPktLen>:
; {
700ab770: b083         	sub	sp, #0xc
700ab772: 9002         	str	r0, [sp, #0x8]
700ab774: 9101         	str	r1, [sp, #0x4]
700ab776: 9200         	str	r2, [sp]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ab778: 9801         	ldr	r0, [sp, #0x4]
700ab77a: 2801         	cmp	r0, #0x1
700ab77c: d004         	beq	0x700ab788 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #0x8
700ab77e: e7ff         	b	0x700ab780 <CSL_udmapCppi5SetPktLen+0x10> @ imm = #-0x2
;         (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO) )
700ab780: 9801         	ldr	r0, [sp, #0x4]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ab782: 2802         	cmp	r0, #0x2
700ab784: d107         	bne	0x700ab796 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #0xe
700ab786: e7ff         	b	0x700ab788 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PKTLEN, pktLen );
700ab788: 9902         	ldr	r1, [sp, #0x8]
700ab78a: 6808         	ldr	r0, [r1]
700ab78c: 9a00         	ldr	r2, [sp]
700ab78e: f362 0015    	bfi	r0, r2, #0, #22
700ab792: 6008         	str	r0, [r1]
;     }
700ab794: e7ff         	b	0x700ab796 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #-0x2
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700ab796: 9801         	ldr	r0, [sp, #0x4]
700ab798: 2803         	cmp	r0, #0x3
700ab79a: d108         	bne	0x700ab7ae <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #0x10
700ab79c: e7ff         	b	0x700ab79e <CSL_udmapCppi5SetPktLen+0x2e> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5TRPD *)pDesc)->descInfo, UDMAP_CPPI5_TRPD_DESCINFO_LASTIDX, pktLen-1U );
700ab79e: 9902         	ldr	r1, [sp, #0x8]
700ab7a0: 6808         	ldr	r0, [r1]
700ab7a2: 9a00         	ldr	r2, [sp]
700ab7a4: 3a01         	subs	r2, #0x1
700ab7a6: f362 000d    	bfi	r0, r2, #0, #14
700ab7aa: 6008         	str	r0, [r1]
;     }
700ab7ac: e7ff         	b	0x700ab7ae <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #-0x2
; }
700ab7ae: b003         	add	sp, #0xc
700ab7b0: 4770         	bx	lr
		...
700ab7be: 0000         	movs	r0, r0

700ab7c0 <Sciclient_rmIrqGetNodeItf>:
; {
700ab7c0: b084         	sub	sp, #0x10
700ab7c2: 9003         	str	r0, [sp, #0xc]
700ab7c4: f8ad 100a    	strh.w	r1, [sp, #0xa]
700ab7c8: 9201         	str	r2, [sp, #0x4]
700ab7ca: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab7cc: 9000         	str	r0, [sp]
;     if (n_itf < n->n_if) {
700ab7ce: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700ab7d2: 9903         	ldr	r1, [sp, #0xc]
700ab7d4: 8849         	ldrh	r1, [r1, #0x2]
700ab7d6: 4288         	cmp	r0, r1
700ab7d8: da09         	bge	0x700ab7ee <Sciclient_rmIrqGetNodeItf+0x2e> @ imm = #0x12
700ab7da: e7ff         	b	0x700ab7dc <Sciclient_rmIrqGetNodeItf+0x1c> @ imm = #-0x2
;         *itf = n->p_if[n_itf];
700ab7dc: 9803         	ldr	r0, [sp, #0xc]
700ab7de: 6840         	ldr	r0, [r0, #0x4]
700ab7e0: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700ab7e4: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ab7e8: 9901         	ldr	r1, [sp, #0x4]
700ab7ea: 6008         	str	r0, [r1]
;     } else {
700ab7ec: e006         	b	0x700ab7fc <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #0xc
;         *itf = NULL;
700ab7ee: 9901         	ldr	r1, [sp, #0x4]
700ab7f0: 2000         	movs	r0, #0x0
700ab7f2: 6008         	str	r0, [r1]
700ab7f4: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab7f8: 9000         	str	r0, [sp]
700ab7fa: e7ff         	b	0x700ab7fc <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #-0x2
;     return r;
700ab7fc: 9800         	ldr	r0, [sp]
700ab7fe: b004         	add	sp, #0x10
700ab800: 4770         	bx	lr
		...
700ab80e: 0000         	movs	r0, r0

700ab810 <UART_checkOpenParams>:
; {
700ab810: b082         	sub	sp, #0x8
700ab812: 9001         	str	r0, [sp, #0x4]
700ab814: 2000         	movs	r0, #0x0
;     int32_t     status = SystemP_SUCCESS;
700ab816: 9000         	str	r0, [sp]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700ab818: 9801         	ldr	r0, [sp, #0x4]
700ab81a: 6900         	ldr	r0, [r0, #0x10]
700ab81c: 2801         	cmp	r0, #0x1
700ab81e: d108         	bne	0x700ab832 <UART_checkOpenParams+0x22> @ imm = #0x10
700ab820: e7ff         	b	0x700ab822 <UART_checkOpenParams+0x12> @ imm = #-0x2
;        (NULL_PTR == prms->readCallbackFxn))
700ab822: 9801         	ldr	r0, [sp, #0x4]
700ab824: 69c0         	ldr	r0, [r0, #0x1c]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700ab826: b920         	cbnz	r0, 0x700ab832 <UART_checkOpenParams+0x22> @ imm = #0x8
700ab828: e7ff         	b	0x700ab82a <UART_checkOpenParams+0x1a> @ imm = #-0x2
700ab82a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ab82e: 9000         	str	r0, [sp]
;     }
700ab830: e7ff         	b	0x700ab832 <UART_checkOpenParams+0x22> @ imm = #-0x2
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700ab832: 9801         	ldr	r0, [sp, #0x4]
700ab834: 6980         	ldr	r0, [r0, #0x18]
700ab836: 2801         	cmp	r0, #0x1
700ab838: d108         	bne	0x700ab84c <UART_checkOpenParams+0x3c> @ imm = #0x10
700ab83a: e7ff         	b	0x700ab83c <UART_checkOpenParams+0x2c> @ imm = #-0x2
;        (NULL_PTR == prms->writeCallbackFxn))
700ab83c: 9801         	ldr	r0, [sp, #0x4]
700ab83e: 6a00         	ldr	r0, [r0, #0x20]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700ab840: b920         	cbnz	r0, 0x700ab84c <UART_checkOpenParams+0x3c> @ imm = #0x8
700ab842: e7ff         	b	0x700ab844 <UART_checkOpenParams+0x34> @ imm = #-0x2
700ab844: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ab848: 9000         	str	r0, [sp]
;     }
700ab84a: e7ff         	b	0x700ab84c <UART_checkOpenParams+0x3c> @ imm = #-0x2
;     return (status);
700ab84c: 9800         	ldr	r0, [sp]
700ab84e: b002         	add	sp, #0x8
700ab850: 4770         	bx	lr
		...
700ab85e: 0000         	movs	r0, r0

700ab860 <UdmaUtils_getRingMemSize>:
; {
700ab860: b084         	sub	sp, #0x10
700ab862: f88d 000f    	strb.w	r0, [sp, #0xf]
700ab866: 9102         	str	r1, [sp, #0x8]
700ab868: f88d 2007    	strb.w	r2, [sp, #0x7]
;     ringMemSize = ((uint32_t) 1U << (elemSize + 2U));   /* Element size in bytes */
700ab86c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ab870: 1c81         	adds	r1, r0, #0x2
700ab872: 2001         	movs	r0, #0x1
700ab874: 4088         	lsls	r0, r1
700ab876: 9000         	str	r0, [sp]
;     ringMemSize *= elemCnt;
700ab878: 9902         	ldr	r1, [sp, #0x8]
700ab87a: 9800         	ldr	r0, [sp]
700ab87c: 4348         	muls	r0, r1, r0
700ab87e: 9000         	str	r0, [sp]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700ab880: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ab884: 2802         	cmp	r0, #0x2
700ab886: d005         	beq	0x700ab894 <UdmaUtils_getRingMemSize+0x34> @ imm = #0xa
700ab888: e7ff         	b	0x700ab88a <UdmaUtils_getRingMemSize+0x2a> @ imm = #-0x2
;        (TISCI_MSG_VALUE_RM_RING_MODE_QM == mode))
700ab88a: f89d 000f    	ldrb.w	r0, [sp, #0xf]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700ab88e: 2803         	cmp	r0, #0x3
700ab890: d104         	bne	0x700ab89c <UdmaUtils_getRingMemSize+0x3c> @ imm = #0x8
700ab892: e7ff         	b	0x700ab894 <UdmaUtils_getRingMemSize+0x34> @ imm = #-0x2
;         ringMemSize <<= 1U;
700ab894: 9800         	ldr	r0, [sp]
700ab896: 0040         	lsls	r0, r0, #0x1
700ab898: 9000         	str	r0, [sp]
;     }
700ab89a: e7ff         	b	0x700ab89c <UdmaUtils_getRingMemSize+0x3c> @ imm = #-0x2
;     return (ringMemSize);
700ab89c: 9800         	ldr	r0, [sp]
700ab89e: b004         	add	sp, #0x10
700ab8a0: 4770         	bx	lr
		...
700ab8ae: 0000         	movs	r0, r0

700ab8b0 <prvCopyDataFromQueue>:
; {
700ab8b0: b580         	push	{r7, lr}
700ab8b2: b082         	sub	sp, #0x8
700ab8b4: 9001         	str	r0, [sp, #0x4]
700ab8b6: 9100         	str	r1, [sp]
;     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
700ab8b8: 9801         	ldr	r0, [sp, #0x4]
700ab8ba: 6c00         	ldr	r0, [r0, #0x40]
700ab8bc: b1b8         	cbz	r0, 0x700ab8ee <prvCopyDataFromQueue+0x3e> @ imm = #0x2e
700ab8be: e7ff         	b	0x700ab8c0 <prvCopyDataFromQueue+0x10> @ imm = #-0x2
;         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700ab8c0: 9901         	ldr	r1, [sp, #0x4]
700ab8c2: 68c8         	ldr	r0, [r1, #0xc]
700ab8c4: 6c0a         	ldr	r2, [r1, #0x40]
700ab8c6: 4410         	add	r0, r2
700ab8c8: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
700ab8ca: 9801         	ldr	r0, [sp, #0x4]
700ab8cc: 6881         	ldr	r1, [r0, #0x8]
700ab8ce: 68c0         	ldr	r0, [r0, #0xc]
700ab8d0: 4288         	cmp	r0, r1
700ab8d2: d304         	blo	0x700ab8de <prvCopyDataFromQueue+0x2e> @ imm = #0x8
700ab8d4: e7ff         	b	0x700ab8d6 <prvCopyDataFromQueue+0x26> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
700ab8d6: 9901         	ldr	r1, [sp, #0x4]
700ab8d8: 6808         	ldr	r0, [r1]
700ab8da: 60c8         	str	r0, [r1, #0xc]
;         }
700ab8dc: e000         	b	0x700ab8e0 <prvCopyDataFromQueue+0x30> @ imm = #0x0
700ab8de: e7ff         	b	0x700ab8e0 <prvCopyDataFromQueue+0x30> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700ab8e0: 9800         	ldr	r0, [sp]
700ab8e2: 9a01         	ldr	r2, [sp, #0x4]
700ab8e4: 68d1         	ldr	r1, [r2, #0xc]
700ab8e6: 6c12         	ldr	r2, [r2, #0x40]
700ab8e8: f7ef e878    	blx	0x7009a9dc <__aeabi_memcpy8> @ imm = #-0x10f10
;     }
700ab8ec: e7ff         	b	0x700ab8ee <prvCopyDataFromQueue+0x3e> @ imm = #-0x2
; }
700ab8ee: b002         	add	sp, #0x8
700ab8f0: bd80         	pop	{r7, pc}
		...
700ab8fe: 0000         	movs	r0, r0

700ab900 <CSL_lcdma_ringaccIsTeardownComplete>:
; {
700ab900: b580         	push	{r7, lr}
700ab902: b084         	sub	sp, #0x10
700ab904: 9003         	str	r0, [sp, #0xc]
700ab906: 9102         	str	r1, [sp, #0x8]
700ab908: 2000         	movs	r0, #0x0
;     bool bRetVal = (bool)false;
700ab90a: f88d 0007    	strb.w	r0, [sp, #0x7]
;     if( CSL_REG32_FEXT( &pCfg->pRingRtRegs->RING[ringNum].ROCC, LCDMA_RINGACC_RINGRT_RING_ROCC_COMP ) != (uint32_t)0U )
700ab90e: 9803         	ldr	r0, [sp, #0xc]
700ab910: 6840         	ldr	r0, [r0, #0x4]
700ab912: 9902         	ldr	r1, [sp, #0x8]
700ab914: eb00 3041    	add.w	r0, r0, r1, lsl #13
700ab918: f241 0118    	movw	r1, #0x1018
700ab91c: 4408         	add	r0, r1
700ab91e: f04f 4100    	mov.w	r1, #0x80000000
700ab922: 221f         	movs	r2, #0x1f
700ab924: f001 f9c4    	bl	0x700accb0 <CSL_REG32_FEXT_RAW> @ imm = #0x1388
700ab928: b120         	cbz	r0, 0x700ab934 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #0x8
700ab92a: e7ff         	b	0x700ab92c <CSL_lcdma_ringaccIsTeardownComplete+0x2c> @ imm = #-0x2
700ab92c: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700ab92e: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700ab932: e7ff         	b	0x700ab934 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #-0x2
;     return bRetVal;
700ab934: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ab938: f000 0001    	and	r0, r0, #0x1
700ab93c: b004         	add	sp, #0x10
700ab93e: bd80         	pop	{r7, pc}

700ab940 <Sciclient_rmIrqProgramOesRegister>:
; {
700ab940: b580         	push	{r7, lr}
700ab942: b088         	sub	sp, #0x20
700ab944: 9007         	str	r0, [sp, #0x1c]
700ab946: 2010         	movs	r0, #0x10
700ab948: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700ab94c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700ab94e: 9807         	ldr	r0, [sp, #0x1c]
700ab950: 7900         	ldrb	r0, [r0, #0x4]
700ab952: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700ab956: 9807         	ldr	r0, [sp, #0x1c]
700ab958: 88c0         	ldrh	r0, [r0, #0x6]
700ab95a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700ab95e: 9807         	ldr	r0, [sp, #0x1c]
700ab960: 8900         	ldrh	r0, [r0, #0x8]
700ab962: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700ab966: 9807         	ldr	r0, [sp, #0x1c]
700ab968: 89c0         	ldrh	r0, [r0, #0xe]
700ab96a: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                                  cfg->set_resp,
700ab96e: 9807         	ldr	r0, [sp, #0x1c]
700ab970: 6981         	ldr	r1, [r0, #0x18]
700ab972: 4668         	mov	r0, sp
700ab974: f04f 32ff    	mov.w	r2, #0xffffffff
;     return Sciclient_rmIrqSetRaw(&req,
700ab978: f7fe feb2    	bl	0x700aa6e0 <Sciclient_rmIrqSetRaw> @ imm = #-0x129c
700ab97c: b008         	add	sp, #0x20
700ab97e: bd80         	pop	{r7, pc}

700ab980 <Sciclient_rmPsGetIfIdx>:
; {
700ab980: b082         	sub	sp, #0x8
700ab982: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ab986: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700ab98a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ab98c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ab990: f241 0158    	movw	r1, #0x1058
700ab994: f2c7 0108    	movt	r1, #0x7008
700ab998: 8c89         	ldrh	r1, [r1, #0x24]
700ab99a: 4288         	cmp	r0, r1
700ab99c: da0d         	bge	0x700ab9ba <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #0x1a
700ab99e: e7ff         	b	0x700ab9a0 <Sciclient_rmPsGetIfIdx+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].if_idx;
700ab9a0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ab9a4: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ab9a8: f241 0058    	movw	r0, #0x1058
700ab9ac: f2c7 0008    	movt	r0, #0x7008
700ab9b0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ab9b4: 8880         	ldrh	r0, [r0, #0x4]
700ab9b6: 9000         	str	r0, [sp]
;     }
700ab9b8: e7ff         	b	0x700ab9ba <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #-0x2
;     return r;
700ab9ba: 9800         	ldr	r0, [sp]
700ab9bc: b002         	add	sp, #0x8
700ab9be: 4770         	bx	lr

700ab9c0 <Sciclient_rmPsGetInp>:
; {
700ab9c0: b082         	sub	sp, #0x8
700ab9c2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ab9c6: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700ab9ca: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ab9cc: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ab9d0: f241 0158    	movw	r1, #0x1058
700ab9d4: f2c7 0108    	movt	r1, #0x7008
700ab9d8: 8c89         	ldrh	r1, [r1, #0x24]
700ab9da: 4288         	cmp	r0, r1
700ab9dc: da0d         	bge	0x700ab9fa <Sciclient_rmPsGetInp+0x3a> @ imm = #0x1a
700ab9de: e7ff         	b	0x700ab9e0 <Sciclient_rmPsGetInp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].inp;
700ab9e0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ab9e4: eb00 0140    	add.w	r1, r0, r0, lsl #1
700ab9e8: f241 0058    	movw	r0, #0x1058
700ab9ec: f2c7 0008    	movt	r0, #0x7008
700ab9f0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ab9f4: 88c0         	ldrh	r0, [r0, #0x6]
700ab9f6: 9000         	str	r0, [sp]
;     }
700ab9f8: e7ff         	b	0x700ab9fa <Sciclient_rmPsGetInp+0x3a> @ imm = #-0x2
;     return r;
700ab9fa: 9800         	ldr	r0, [sp]
700ab9fc: b002         	add	sp, #0x8
700ab9fe: 4770         	bx	lr

700aba00 <Sciclient_rmPsGetOutp>:
; {
700aba00: b082         	sub	sp, #0x8
700aba02: f8ad 0006    	strh.w	r0, [sp, #0x6]
700aba06: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700aba0a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700aba0c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700aba10: f241 0158    	movw	r1, #0x1058
700aba14: f2c7 0108    	movt	r1, #0x7008
700aba18: 8c89         	ldrh	r1, [r1, #0x24]
700aba1a: 4288         	cmp	r0, r1
700aba1c: da0d         	bge	0x700aba3a <Sciclient_rmPsGetOutp+0x3a> @ imm = #0x1a
700aba1e: e7ff         	b	0x700aba20 <Sciclient_rmPsGetOutp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].outp;
700aba20: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700aba24: eb00 0140    	add.w	r1, r0, r0, lsl #1
700aba28: f241 0058    	movw	r0, #0x1058
700aba2c: f2c7 0008    	movt	r0, #0x7008
700aba30: eb00 0081    	add.w	r0, r0, r1, lsl #2
700aba34: 8900         	ldrh	r0, [r0, #0x8]
700aba36: 9000         	str	r0, [sp]
;     }
700aba38: e7ff         	b	0x700aba3a <Sciclient_rmPsGetOutp+0x3a> @ imm = #-0x2
;     return r;
700aba3a: 9800         	ldr	r0, [sp]
700aba3c: b002         	add	sp, #0x8
700aba3e: 4770         	bx	lr

700aba40 <prvGetNextExpireTime>:
;     {
700aba40: b082         	sub	sp, #0x8
700aba42: 9001         	str	r0, [sp, #0x4]
;         *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
700aba44: f644 70b4    	movw	r0, #0x4fb4
700aba48: f2c7 0008    	movt	r0, #0x7008
700aba4c: 6800         	ldr	r0, [r0]
700aba4e: 6800         	ldr	r0, [r0]
700aba50: fab0 f080    	clz	r0, r0
700aba54: 0940         	lsrs	r0, r0, #0x5
700aba56: 9901         	ldr	r1, [sp, #0x4]
700aba58: 6008         	str	r0, [r1]
;         if( *pxListWasEmpty == pdFALSE )
700aba5a: 9801         	ldr	r0, [sp, #0x4]
700aba5c: 6800         	ldr	r0, [r0]
700aba5e: b948         	cbnz	r0, 0x700aba74 <prvGetNextExpireTime+0x34> @ imm = #0x12
700aba60: e7ff         	b	0x700aba62 <prvGetNextExpireTime+0x22> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700aba62: f644 70b4    	movw	r0, #0x4fb4
700aba66: f2c7 0008    	movt	r0, #0x7008
700aba6a: 6800         	ldr	r0, [r0]
700aba6c: 68c0         	ldr	r0, [r0, #0xc]
700aba6e: 6800         	ldr	r0, [r0]
700aba70: 9000         	str	r0, [sp]
;         }
700aba72: e002         	b	0x700aba7a <prvGetNextExpireTime+0x3a> @ imm = #0x4
700aba74: 2000         	movs	r0, #0x0
;             xNextExpireTime = ( TickType_t ) 0U;
700aba76: 9000         	str	r0, [sp]
700aba78: e7ff         	b	0x700aba7a <prvGetNextExpireTime+0x3a> @ imm = #-0x2
;         return xNextExpireTime;
700aba7a: 9800         	ldr	r0, [sp]
700aba7c: b002         	add	sp, #0x8
700aba7e: 4770         	bx	lr

700aba80 <Sciclient_secProxyWaitThread>:
; {
700aba80: b580         	push	{r7, lr}
700aba82: b084         	sub	sp, #0x10
700aba84: 9003         	str	r0, [sp, #0xc]
700aba86: 9102         	str	r1, [sp, #0x8]
700aba88: f06f 0003    	mvn	r0, #0x3
;     int32_t  status     = CSL_ETIMEOUT;
700aba8c: 9001         	str	r0, [sp, #0x4]
;     uint32_t timeToWait = timeout;
700aba8e: 9802         	ldr	r0, [sp, #0x8]
700aba90: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700aba92: e7ff         	b	0x700aba94 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x2
700aba94: 9800         	ldr	r0, [sp]
700aba96: b178         	cbz	r0, 0x700abab8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x1e
700aba98: e7ff         	b	0x700aba9a <Sciclient_secProxyWaitThread+0x1a> @ imm = #-0x2
;         if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700aba9a: 9803         	ldr	r0, [sp, #0xc]
700aba9c: f001 fbb0    	bl	0x700ad200 <Sciclient_secProxyThreadStatusReg> @ imm = #0x1760
700abaa0: f001 fe26    	bl	0x700ad6f0 <CSL_REG32_RD_RAW> @ imm = #0x1c4c
700abaa4: 0600         	lsls	r0, r0, #0x18
700abaa6: b118         	cbz	r0, 0x700abab0 <Sciclient_secProxyWaitThread+0x30> @ imm = #0x6
700abaa8: e7ff         	b	0x700abaaa <Sciclient_secProxyWaitThread+0x2a> @ imm = #-0x2
700abaaa: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700abaac: 9001         	str	r0, [sp, #0x4]
;             break;
700abaae: e003         	b	0x700abab8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x6
;         timeToWait--;
700abab0: 9800         	ldr	r0, [sp]
700abab2: 3801         	subs	r0, #0x1
700abab4: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700abab6: e7ed         	b	0x700aba94 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x26
;     return status;
700abab8: 9801         	ldr	r0, [sp, #0x4]
700ababa: b004         	add	sp, #0x10
700ababc: bd80         	pop	{r7, pc}
700ababe: 0000         	movs	r0, r0

700abac0 <UART_IsHWFlowCtrlValid>:
; {
700abac0: b082         	sub	sp, #0x8
700abac2: 9001         	str	r0, [sp, #0x4]
700abac4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700abac8: 9000         	str	r0, [sp]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700abaca: 9801         	ldr	r0, [sp, #0x4]
700abacc: 2801         	cmp	r0, #0x1
700abace: d010         	beq	0x700abaf2 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x20
700abad0: e7ff         	b	0x700abad2 <UART_IsHWFlowCtrlValid+0x12> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_8)  ||
700abad2: 9801         	ldr	r0, [sp, #0x4]
700abad4: 2808         	cmp	r0, #0x8
700abad6: d00c         	beq	0x700abaf2 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x18
700abad8: e7ff         	b	0x700abada <UART_IsHWFlowCtrlValid+0x1a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_16) ||
700abada: 9801         	ldr	r0, [sp, #0x4]
700abadc: 2810         	cmp	r0, #0x10
700abade: d008         	beq	0x700abaf2 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x10
700abae0: e7ff         	b	0x700abae2 <UART_IsHWFlowCtrlValid+0x22> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_56) ||
700abae2: 9801         	ldr	r0, [sp, #0x4]
700abae4: 2838         	cmp	r0, #0x38
700abae6: d004         	beq	0x700abaf2 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x8
700abae8: e7ff         	b	0x700abaea <UART_IsHWFlowCtrlValid+0x2a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_60)))
700abaea: 9801         	ldr	r0, [sp, #0x4]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700abaec: 283c         	cmp	r0, #0x3c
700abaee: d103         	bne	0x700abaf8 <UART_IsHWFlowCtrlValid+0x38> @ imm = #0x6
700abaf0: e7ff         	b	0x700abaf2 <UART_IsHWFlowCtrlValid+0x32> @ imm = #-0x2
700abaf2: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700abaf4: 9000         	str	r0, [sp]
;     }
700abaf6: e7ff         	b	0x700abaf8 <UART_IsHWFlowCtrlValid+0x38> @ imm = #-0x2
;     return status;
700abaf8: 9800         	ldr	r0, [sp]
700abafa: b002         	add	sp, #0x8
700abafc: 4770         	bx	lr
700abafe: 0000         	movs	r0, r0

700abb00 <UART_IsRxTrigLvlValid>:
; {
700abb00: b082         	sub	sp, #0x8
700abb02: 9001         	str	r0, [sp, #0x4]
700abb04: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700abb08: 9000         	str	r0, [sp]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700abb0a: 9801         	ldr	r0, [sp, #0x4]
700abb0c: 2801         	cmp	r0, #0x1
700abb0e: d010         	beq	0x700abb32 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x20
700abb10: e7ff         	b	0x700abb12 <UART_IsRxTrigLvlValid+0x12> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_8)  ||
700abb12: 9801         	ldr	r0, [sp, #0x4]
700abb14: 2808         	cmp	r0, #0x8
700abb16: d00c         	beq	0x700abb32 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x18
700abb18: e7ff         	b	0x700abb1a <UART_IsRxTrigLvlValid+0x1a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_16) ||
700abb1a: 9801         	ldr	r0, [sp, #0x4]
700abb1c: 2810         	cmp	r0, #0x10
700abb1e: d008         	beq	0x700abb32 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x10
700abb20: e7ff         	b	0x700abb22 <UART_IsRxTrigLvlValid+0x22> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_56) ||
700abb22: 9801         	ldr	r0, [sp, #0x4]
700abb24: 2838         	cmp	r0, #0x38
700abb26: d004         	beq	0x700abb32 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x8
700abb28: e7ff         	b	0x700abb2a <UART_IsRxTrigLvlValid+0x2a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_60)))
700abb2a: 9801         	ldr	r0, [sp, #0x4]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700abb2c: 283c         	cmp	r0, #0x3c
700abb2e: d103         	bne	0x700abb38 <UART_IsRxTrigLvlValid+0x38> @ imm = #0x6
700abb30: e7ff         	b	0x700abb32 <UART_IsRxTrigLvlValid+0x32> @ imm = #-0x2
700abb32: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700abb34: 9000         	str	r0, [sp]
;     }
700abb36: e7ff         	b	0x700abb38 <UART_IsRxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700abb38: 9800         	ldr	r0, [sp]
700abb3a: b002         	add	sp, #0x8
700abb3c: 4770         	bx	lr
700abb3e: 0000         	movs	r0, r0

700abb40 <UART_IsTxTrigLvlValid>:
; {
700abb40: b082         	sub	sp, #0x8
700abb42: 9001         	str	r0, [sp, #0x4]
700abb44: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700abb48: 9000         	str	r0, [sp]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700abb4a: 9801         	ldr	r0, [sp, #0x4]
700abb4c: 2801         	cmp	r0, #0x1
700abb4e: d010         	beq	0x700abb72 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x20
700abb50: e7ff         	b	0x700abb52 <UART_IsTxTrigLvlValid+0x12> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_8)  ||
700abb52: 9801         	ldr	r0, [sp, #0x4]
700abb54: 2808         	cmp	r0, #0x8
700abb56: d00c         	beq	0x700abb72 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x18
700abb58: e7ff         	b	0x700abb5a <UART_IsTxTrigLvlValid+0x1a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_16) ||
700abb5a: 9801         	ldr	r0, [sp, #0x4]
700abb5c: 2810         	cmp	r0, #0x10
700abb5e: d008         	beq	0x700abb72 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x10
700abb60: e7ff         	b	0x700abb62 <UART_IsTxTrigLvlValid+0x22> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_32) ||
700abb62: 9801         	ldr	r0, [sp, #0x4]
700abb64: 2820         	cmp	r0, #0x20
700abb66: d004         	beq	0x700abb72 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x8
700abb68: e7ff         	b	0x700abb6a <UART_IsTxTrigLvlValid+0x2a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_56)))
700abb6a: 9801         	ldr	r0, [sp, #0x4]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700abb6c: 2838         	cmp	r0, #0x38
700abb6e: d103         	bne	0x700abb78 <UART_IsTxTrigLvlValid+0x38> @ imm = #0x6
700abb70: e7ff         	b	0x700abb72 <UART_IsTxTrigLvlValid+0x32> @ imm = #-0x2
700abb72: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700abb74: 9000         	str	r0, [sp]
;     }
700abb76: e7ff         	b	0x700abb78 <UART_IsTxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700abb78: 9800         	ldr	r0, [sp]
700abb7a: b002         	add	sp, #0x8
700abb7c: 4770         	bx	lr
700abb7e: 0000         	movs	r0, r0

700abb80 <UART_i2310WA>:
; {
700abb80: b580         	push	{r7, lr}
700abb82: b084         	sub	sp, #0x10
700abb84: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTL, 0xFF);
700abb86: 9803         	ldr	r0, [sp, #0xc]
700abb88: 3098         	adds	r0, #0x98
700abb8a: 21ff         	movs	r1, #0xff
700abb8c: 9101         	str	r1, [sp, #0x4]
700abb8e: f001 fd57    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x1aae
700abb92: 9901         	ldr	r1, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTH, 0xFF);
700abb94: 9803         	ldr	r0, [sp, #0xc]
700abb96: 309c         	adds	r0, #0x9c
700abb98: f001 fd52    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x1aa4
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 1);
700abb9c: 9803         	ldr	r0, [sp, #0xc]
700abb9e: 308c         	adds	r0, #0x8c
700abba0: 2206         	movs	r2, #0x6
700abba2: 9202         	str	r2, [sp, #0x8]
700abba4: 2301         	movs	r3, #0x1
700abba6: 4611         	mov	r1, r2
700abba8: f000 fbc2    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x784
700abbac: 9a02         	ldr	r2, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 0);
700abbae: 9803         	ldr	r0, [sp, #0xc]
700abbb0: 308c         	adds	r0, #0x8c
700abbb2: 2300         	movs	r3, #0x0
700abbb4: 4611         	mov	r1, r2
700abbb6: f000 fbbb    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x776
; }
700abbba: b004         	add	sp, #0x10
700abbbc: bd80         	pop	{r7, pc}
700abbbe: 0000         	movs	r0, r0

700abbc0 <UART_spaceAvail>:
; {
700abbc0: b580         	push	{r7, lr}
700abbc2: b084         	sub	sp, #0x10
700abbc4: 9003         	str	r0, [sp, #0xc]
700abbc6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700abbc8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700abbca: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700abbcc: 9803         	ldr	r0, [sp, #0xc]
700abbce: 217f         	movs	r1, #0x7f
700abbd0: f7fe fd26    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #-0x15b4
700abbd4: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700abbd6: 9803         	ldr	r0, [sp, #0xc]
700abbd8: 3014         	adds	r0, #0x14
700abbda: f001 fd29    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x1a52
700abbde: f000 0060    	and	r0, r0, #0x60
;     if ((UART_LSR_TX_SR_E_MASK | UART_LSR_TX_FIFO_E_MASK) ==
700abbe2: 2860         	cmp	r0, #0x60
700abbe4: d103         	bne	0x700abbee <UART_spaceAvail+0x2e> @ imm = #0x6
700abbe6: e7ff         	b	0x700abbe8 <UART_spaceAvail+0x28> @ imm = #-0x2
700abbe8: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700abbea: 9001         	str	r0, [sp, #0x4]
;     }
700abbec: e7ff         	b	0x700abbee <UART_spaceAvail+0x2e> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700abbee: 9803         	ldr	r0, [sp, #0xc]
700abbf0: 300c         	adds	r0, #0xc
700abbf2: 9902         	ldr	r1, [sp, #0x8]
700abbf4: f001 fd24    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x1a48
;     return retVal;
700abbf8: 9801         	ldr	r0, [sp, #0x4]
700abbfa: b004         	add	sp, #0x10
700abbfc: bd80         	pop	{r7, pc}
700abbfe: 0000         	movs	r0, r0

700abc00 <CSL_bcdmaSetChanPeerReg>:
; {
700abc00: b580         	push	{r7, lr}
700abc02: b088         	sub	sp, #0x20
700abc04: f8dd c028    	ldr.w	r12, [sp, #0x28]
700abc08: 9007         	str	r0, [sp, #0x1c]
700abc0a: 9106         	str	r1, [sp, #0x18]
700abc0c: 9205         	str	r2, [sp, #0x14]
700abc0e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700abc10: 9804         	ldr	r0, [sp, #0x10]
700abc12: 9001         	str	r0, [sp, #0x4]
;     remotePeerOpts.regVal = *pVal;
700abc14: 980a         	ldr	r0, [sp, #0x28]
700abc16: 6800         	ldr	r0, [r0]
700abc18: 9002         	str	r0, [sp, #0x8]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700abc1a: 9807         	ldr	r0, [sp, #0x1c]
700abc1c: 9a06         	ldr	r2, [sp, #0x18]
700abc1e: 210c         	movs	r1, #0xc
700abc20: ab01         	add	r3, sp, #0x4
700abc22: f7fd f8fd    	bl	0x700a8e20 <CSL_bcdmaDoChanOp> @ imm = #-0x2e06
700abc26: 9003         	str	r0, [sp, #0xc]
;     if( retVal != CSL_PASS )
700abc28: 9803         	ldr	r0, [sp, #0xc]
700abc2a: b120         	cbz	r0, 0x700abc36 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #0x8
700abc2c: e7ff         	b	0x700abc2e <CSL_bcdmaSetChanPeerReg+0x2e> @ imm = #-0x2
700abc2e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700abc32: 9003         	str	r0, [sp, #0xc]
;     }
700abc34: e7ff         	b	0x700abc36 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #-0x2
;     return retVal;
700abc36: 9803         	ldr	r0, [sp, #0xc]
700abc38: b008         	add	sp, #0x20
700abc3a: bd80         	pop	{r7, pc}
700abc3c: 0000         	movs	r0, r0
700abc3e: 0000         	movs	r0, r0

700abc40 <CSL_intaggrIsValidStatusBitNum>:
; {
700abc40: b084         	sub	sp, #0x10
700abc42: 9003         	str	r0, [sp, #0xc]
700abc44: 9102         	str	r1, [sp, #0x8]
;     uint32_t localStatusBitNum = statusBitNum;
700abc46: 9802         	ldr	r0, [sp, #0x8]
700abc48: 9000         	str	r0, [sp]
;     localStatusBitNum &= ~CSL_INTAGGR_INTR_MODE_FLAG;   /* Remove intr mode flag */
700abc4a: 9800         	ldr	r0, [sp]
700abc4c: f020 4000    	bic	r0, r0, #0x80000000
700abc50: 9000         	str	r0, [sp]
;     if( localStatusBitNum < (pCfg->virtIntrCnt << 6U) )
700abc52: 9800         	ldr	r0, [sp]
700abc54: 9903         	ldr	r1, [sp, #0xc]
700abc56: 6a49         	ldr	r1, [r1, #0x24]
700abc58: ebb0 1f81    	cmp.w	r0, r1, lsl #6
700abc5c: d204         	bhs	0x700abc68 <CSL_intaggrIsValidStatusBitNum+0x28> @ imm = #0x8
700abc5e: e7ff         	b	0x700abc60 <CSL_intaggrIsValidStatusBitNum+0x20> @ imm = #-0x2
700abc60: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700abc62: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700abc66: e003         	b	0x700abc70 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #0x6
700abc68: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700abc6a: f88d 0007    	strb.w	r0, [sp, #0x7]
700abc6e: e7ff         	b	0x700abc70 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #-0x2
;     return bRetVal;
700abc70: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700abc74: f000 0001    	and	r0, r0, #0x1
700abc78: b004         	add	sp, #0x10
700abc7a: 4770         	bx	lr
700abc7c: 0000         	movs	r0, r0
700abc7e: 0000         	movs	r0, r0

700abc80 <CSL_pktdmaSetRxRT>:
; {
700abc80: b580         	push	{r7, lr}
700abc82: b084         	sub	sp, #0x10
700abc84: 9003         	str	r0, [sp, #0xc]
700abc86: 9102         	str	r1, [sp, #0x8]
700abc88: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL,
700abc8a: 9803         	ldr	r0, [sp, #0xc]
700abc8c: 6940         	ldr	r0, [r0, #0x14]
700abc8e: 9902         	ldr	r1, [sp, #0x8]
700abc90: eb00 3001    	add.w	r0, r0, r1, lsl #12
700abc94: 9901         	ldr	r1, [sp, #0x4]
700abc96: 680b         	ldr	r3, [r1]
700abc98: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700abc9c: 688a         	ldr	r2, [r1, #0x8]
700abc9e: f04f 4180    	mov.w	r1, #0x40000000
700abca2: ea01 718c    	and.w	r1, r1, r12, lsl #30
700abca6: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700abcaa: f002 0201    	and	r2, r2, #0x1
700abcae: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700abcb2: f001 fc6d    	bl	0x700ad590 <CSL_REG32_WR_RAW> @ imm = #0x18da
700abcb6: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700abcb8: b004         	add	sp, #0x10
700abcba: bd80         	pop	{r7, pc}
700abcbc: 0000         	movs	r0, r0
700abcbe: 0000         	movs	r0, r0

700abcc0 <CSL_pktdmaSetTxRT>:
; {
700abcc0: b580         	push	{r7, lr}
700abcc2: b084         	sub	sp, #0x10
700abcc4: 9003         	str	r0, [sp, #0xc]
700abcc6: 9102         	str	r1, [sp, #0x8]
700abcc8: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL,
700abcca: 9803         	ldr	r0, [sp, #0xc]
700abccc: 6900         	ldr	r0, [r0, #0x10]
700abcce: 9902         	ldr	r1, [sp, #0x8]
700abcd0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700abcd4: 9901         	ldr	r1, [sp, #0x4]
700abcd6: 680b         	ldr	r3, [r1]
700abcd8: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700abcdc: 688a         	ldr	r2, [r1, #0x8]
700abcde: f04f 4180    	mov.w	r1, #0x40000000
700abce2: ea01 718c    	and.w	r1, r1, r12, lsl #30
700abce6: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700abcea: f002 0201    	and	r2, r2, #0x1
700abcee: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700abcf2: f001 fc4d    	bl	0x700ad590 <CSL_REG32_WR_RAW> @ imm = #0x189a
700abcf6: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700abcf8: b004         	add	sp, #0x10
700abcfa: bd80         	pop	{r7, pc}
700abcfc: 0000         	movs	r0, r0
700abcfe: 0000         	movs	r0, r0

700abd00 <Sciclient_rmIrqClearOesRegister>:
; {
700abd00: b580         	push	{r7, lr}
700abd02: b088         	sub	sp, #0x20
700abd04: 9007         	str	r0, [sp, #0x1c]
700abd06: 2010         	movs	r0, #0x10
700abd08: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700abd0c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700abd0e: 9807         	ldr	r0, [sp, #0x1c]
700abd10: 7900         	ldrb	r0, [r0, #0x4]
700abd12: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700abd16: 9807         	ldr	r0, [sp, #0x1c]
700abd18: 88c0         	ldrh	r0, [r0, #0x6]
700abd1a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700abd1e: 9807         	ldr	r0, [sp, #0x1c]
700abd20: 8900         	ldrh	r0, [r0, #0x8]
700abd22: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700abd26: 9807         	ldr	r0, [sp, #0x1c]
700abd28: 89c0         	ldrh	r0, [r0, #0xe]
700abd2a: f8ad 0018    	strh.w	r0, [sp, #0x18]
700abd2e: 4668         	mov	r0, sp
700abd30: f04f 31ff    	mov.w	r1, #0xffffffff
;     return Sciclient_rmIrqReleaseRaw(&req,
700abd34: f7fe fe24    	bl	0x700aa980 <Sciclient_rmIrqReleaseRaw> @ imm = #-0x13b8
700abd38: b008         	add	sp, #0x20
700abd3a: bd80         	pop	{r7, pc}
700abd3c: 0000         	movs	r0, r0
700abd3e: 0000         	movs	r0, r0

700abd40 <UART_IsParityTypeValid>:
; {
700abd40: b082         	sub	sp, #0x8
700abd42: 9001         	str	r0, [sp, #0x4]
700abd44: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700abd48: 9000         	str	r0, [sp]
;     if(((parityType == UART_PARITY_NONE)    ||
700abd4a: 9801         	ldr	r0, [sp, #0x4]
700abd4c: b180         	cbz	r0, 0x700abd70 <UART_IsParityTypeValid+0x30> @ imm = #0x20
700abd4e: e7ff         	b	0x700abd50 <UART_IsParityTypeValid+0x10> @ imm = #-0x2
;         (parityType == UART_PARITY_ODD)     ||
700abd50: 9801         	ldr	r0, [sp, #0x4]
700abd52: 2801         	cmp	r0, #0x1
700abd54: d00c         	beq	0x700abd70 <UART_IsParityTypeValid+0x30> @ imm = #0x18
700abd56: e7ff         	b	0x700abd58 <UART_IsParityTypeValid+0x18> @ imm = #-0x2
;         (parityType == UART_PARITY_EVEN)    ||
700abd58: 9801         	ldr	r0, [sp, #0x4]
700abd5a: 2803         	cmp	r0, #0x3
700abd5c: d008         	beq	0x700abd70 <UART_IsParityTypeValid+0x30> @ imm = #0x10
700abd5e: e7ff         	b	0x700abd60 <UART_IsParityTypeValid+0x20> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED0) ||
700abd60: 9801         	ldr	r0, [sp, #0x4]
700abd62: 2807         	cmp	r0, #0x7
700abd64: d004         	beq	0x700abd70 <UART_IsParityTypeValid+0x30> @ imm = #0x8
700abd66: e7ff         	b	0x700abd68 <UART_IsParityTypeValid+0x28> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED1)))
700abd68: 9801         	ldr	r0, [sp, #0x4]
;     if(((parityType == UART_PARITY_NONE)    ||
700abd6a: 2805         	cmp	r0, #0x5
700abd6c: d103         	bne	0x700abd76 <UART_IsParityTypeValid+0x36> @ imm = #0x6
700abd6e: e7ff         	b	0x700abd70 <UART_IsParityTypeValid+0x30> @ imm = #-0x2
700abd70: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700abd72: 9000         	str	r0, [sp]
;     }
700abd74: e7ff         	b	0x700abd76 <UART_IsParityTypeValid+0x36> @ imm = #-0x2
;     return status;
700abd76: 9800         	ldr	r0, [sp]
700abd78: b002         	add	sp, #0x8
700abd7a: 4770         	bx	lr
700abd7c: 0000         	movs	r0, r0
700abd7e: 0000         	movs	r0, r0

700abd80 <UART_IsTxRxFifoEmpty>:
; {
700abd80: b580         	push	{r7, lr}
700abd82: b084         	sub	sp, #0x10
700abd84: 9003         	str	r0, [sp, #0xc]
700abd86: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700abd88: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700abd8a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700abd8c: 9803         	ldr	r0, [sp, #0xc]
700abd8e: 217f         	movs	r1, #0x7f
700abd90: f7fe fc46    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #-0x1774
700abd94: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700abd96: 9803         	ldr	r0, [sp, #0xc]
700abd98: 3014         	adds	r0, #0x14
700abd9a: f001 fc49    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x1892
;     if (((UART_LSR_TX_FIFO_E_TX_FIFO_E_VALUE_1 << UART_LSR_TX_FIFO_E_SHIFT) |
700abd9e: 0680         	lsls	r0, r0, #0x1a
700abda0: 2800         	cmp	r0, #0x0
700abda2: d503         	bpl	0x700abdac <UART_IsTxRxFifoEmpty+0x2c> @ imm = #0x6
700abda4: e7ff         	b	0x700abda6 <UART_IsTxRxFifoEmpty+0x26> @ imm = #-0x2
700abda6: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700abda8: 9001         	str	r0, [sp, #0x4]
;     }
700abdaa: e7ff         	b	0x700abdac <UART_IsTxRxFifoEmpty+0x2c> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700abdac: 9803         	ldr	r0, [sp, #0xc]
700abdae: 300c         	adds	r0, #0xc
700abdb0: 9902         	ldr	r1, [sp, #0x8]
700abdb2: f001 fc45    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x188a
;     return retVal;
700abdb6: 9801         	ldr	r0, [sp, #0x4]
700abdb8: b004         	add	sp, #0x10
700abdba: bd80         	pop	{r7, pc}
700abdbc: 0000         	movs	r0, r0
700abdbe: 0000         	movs	r0, r0

700abdc0 <UART_enhanFuncEnable>:
; {
700abdc0: b580         	push	{r7, lr}
700abdc2: b084         	sub	sp, #0x10
700abdc4: 9003         	str	r0, [sp, #0xc]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700abdc6: 9803         	ldr	r0, [sp, #0xc]
700abdc8: 21bf         	movs	r1, #0xbf
700abdca: f7fe fc29    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #-0x17ae
700abdce: 9001         	str	r0, [sp, #0x4]
;     enhanFnBitVal = HW_RD_REG32(baseAddr + UART_EFR) & UART_EFR_ENHANCED_EN_MASK;
700abdd0: 9803         	ldr	r0, [sp, #0xc]
700abdd2: 3008         	adds	r0, #0x8
700abdd4: f001 fc2c    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x1858
700abdd8: f000 0010    	and	r0, r0, #0x10
700abddc: 9002         	str	r0, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700abdde: 9803         	ldr	r0, [sp, #0xc]
700abde0: 3008         	adds	r0, #0x8
700abde2: 2110         	movs	r1, #0x10
700abde4: 2204         	movs	r2, #0x4
700abde6: 2301         	movs	r3, #0x1
700abde8: f000 faa2    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #0x544
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700abdec: 9803         	ldr	r0, [sp, #0xc]
700abdee: 300c         	adds	r0, #0xc
700abdf0: 9901         	ldr	r1, [sp, #0x4]
700abdf2: f001 fc25    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x184a
;     return enhanFnBitVal;
700abdf6: 9802         	ldr	r0, [sp, #0x8]
700abdf8: b004         	add	sp, #0x10
700abdfa: bd80         	pop	{r7, pc}
700abdfc: 0000         	movs	r0, r0
700abdfe: 0000         	movs	r0, r0

700abe00 <UART_lld_dmaDeInit>:
; {
700abe00: b580         	push	{r7, lr}
700abe02: b084         	sub	sp, #0x10
700abe04: 9003         	str	r0, [sp, #0xc]
700abe06: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700abe08: 9002         	str	r0, [sp, #0x8]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700abe0a: 9803         	ldr	r0, [sp, #0xc]
700abe0c: 6840         	ldr	r0, [r0, #0x4]
700abe0e: 6cc0         	ldr	r0, [r0, #0x4c]
700abe10: 9001         	str	r0, [sp, #0x4]
;     if (udmaChCfg->isOpen != FALSE)
700abe12: 9801         	ldr	r0, [sp, #0x4]
700abe14: 6b80         	ldr	r0, [r0, #0x38]
700abe16: b170         	cbz	r0, 0x700abe36 <UART_lld_dmaDeInit+0x36> @ imm = #0x1c
700abe18: e7ff         	b	0x700abe1a <UART_lld_dmaDeInit+0x1a> @ imm = #-0x2
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700abe1a: 9901         	ldr	r1, [sp, #0x4]
700abe1c: 6888         	ldr	r0, [r1, #0x8]
;                           udmaChCfg->cqRxEvtHandle);
700abe1e: 6909         	ldr	r1, [r1, #0x10]
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700abe20: f7f8 fcde    	bl	0x700a47e0 <UART_udmaDeInitCh> @ imm = #-0x7644
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700abe24: 9901         	ldr	r1, [sp, #0x4]
700abe26: 6848         	ldr	r0, [r1, #0x4]
;                           udmaChCfg->cqTxEvtHandle);
700abe28: 68c9         	ldr	r1, [r1, #0xc]
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700abe2a: f7f8 fcd9    	bl	0x700a47e0 <UART_udmaDeInitCh> @ imm = #-0x764e
;         udmaChCfg->isOpen = FALSE;
700abe2e: 9901         	ldr	r1, [sp, #0x4]
700abe30: 2000         	movs	r0, #0x0
700abe32: 6388         	str	r0, [r1, #0x38]
;     }
700abe34: e7ff         	b	0x700abe36 <UART_lld_dmaDeInit+0x36> @ imm = #-0x2
;     return status;
700abe36: 9802         	ldr	r0, [sp, #0x8]
700abe38: b004         	add	sp, #0x10
700abe3a: bd80         	pop	{r7, pc}
700abe3c: 0000         	movs	r0, r0
700abe3e: 0000         	movs	r0, r0

700abe40 <prvDeleteTCB>:
; static void prvDeleteTCB(TCB_t *pxTCB) {
700abe40: b580         	push	{r7, lr}
700abe42: b082         	sub	sp, #0x8
700abe44: 9001         	str	r0, [sp, #0x4]
;   portCLEAN_UP_TCB(pxTCB);
700abe46: 9801         	ldr	r0, [sp, #0x4]
;     if (pxTCB->ucStaticallyAllocated ==
700abe48: f890 0086    	ldrb.w	r0, [r0, #0x86]
700abe4c: b940         	cbnz	r0, 0x700abe60 <prvDeleteTCB+0x20> @ imm = #0x10
700abe4e: e7ff         	b	0x700abe50 <prvDeleteTCB+0x10> @ imm = #-0x2
;       vPortFree(pxTCB->pxStack);
700abe50: 9801         	ldr	r0, [sp, #0x4]
700abe52: 6b00         	ldr	r0, [r0, #0x30]
700abe54: f001 f884    	bl	0x700acf60 <vPortFree>  @ imm = #0x1108
;       vPortFree(pxTCB);
700abe58: 9801         	ldr	r0, [sp, #0x4]
700abe5a: f001 f881    	bl	0x700acf60 <vPortFree>  @ imm = #0x1102
;     } else if (pxTCB->ucStaticallyAllocated ==
700abe5e: e00b         	b	0x700abe78 <prvDeleteTCB+0x38> @ imm = #0x16
700abe60: 9801         	ldr	r0, [sp, #0x4]
700abe62: f890 0086    	ldrb.w	r0, [r0, #0x86]
700abe66: 2801         	cmp	r0, #0x1
700abe68: d104         	bne	0x700abe74 <prvDeleteTCB+0x34> @ imm = #0x8
700abe6a: e7ff         	b	0x700abe6c <prvDeleteTCB+0x2c> @ imm = #-0x2
;       vPortFree(pxTCB);
700abe6c: 9801         	ldr	r0, [sp, #0x4]
700abe6e: f001 f877    	bl	0x700acf60 <vPortFree>  @ imm = #0x10ee
;     } else {
700abe72: e000         	b	0x700abe76 <prvDeleteTCB+0x36> @ imm = #0x0
700abe74: e7ff         	b	0x700abe76 <prvDeleteTCB+0x36> @ imm = #-0x2
700abe76: e7ff         	b	0x700abe78 <prvDeleteTCB+0x38> @ imm = #-0x2
; }
700abe78: b002         	add	sp, #0x8
700abe7a: bd80         	pop	{r7, pc}
700abe7c: 0000         	movs	r0, r0
700abe7e: 0000         	movs	r0, r0

700abe80 <prvResetNextTaskUnblockTime>:
;   if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
700abe80: f644 70b8    	movw	r0, #0x4fb8
700abe84: f2c7 0008    	movt	r0, #0x7008
700abe88: 6800         	ldr	r0, [r0]
700abe8a: 6800         	ldr	r0, [r0]
700abe8c: b940         	cbnz	r0, 0x700abea0 <prvResetNextTaskUnblockTime+0x20> @ imm = #0x10
700abe8e: e7ff         	b	0x700abe90 <prvResetNextTaskUnblockTime+0x10> @ imm = #-0x2
;     xNextTaskUnblockTime = portMAX_DELAY;
700abe90: f240 2100    	movw	r1, #0x200
700abe94: f2c7 010b    	movt	r1, #0x700b
700abe98: f04f 30ff    	mov.w	r0, #0xffffffff
700abe9c: 6008         	str	r0, [r1]
;   } else {
700abe9e: e00c         	b	0x700abeba <prvResetNextTaskUnblockTime+0x3a> @ imm = #0x18
;     xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxDelayedTaskList);
700abea0: f644 70b8    	movw	r0, #0x4fb8
700abea4: f2c7 0008    	movt	r0, #0x7008
700abea8: 6800         	ldr	r0, [r0]
700abeaa: 68c0         	ldr	r0, [r0, #0xc]
700abeac: 6800         	ldr	r0, [r0]
700abeae: f240 2100    	movw	r1, #0x200
700abeb2: f2c7 010b    	movt	r1, #0x700b
700abeb6: 6008         	str	r0, [r1]
700abeb8: e7ff         	b	0x700abeba <prvResetNextTaskUnblockTime+0x3a> @ imm = #-0x2
; }
700abeba: 4770         	bx	lr
700abebc: 0000         	movs	r0, r0
700abebe: 0000         	movs	r0, r0

700abec0 <_atoi>:
; {
700abec0: b580         	push	{r7, lr}
700abec2: b082         	sub	sp, #0x8
700abec4: 9001         	str	r0, [sp, #0x4]
700abec6: 2000         	movs	r0, #0x0
;   unsigned int i = 0U;
700abec8: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700abeca: e7ff         	b	0x700abecc <_atoi+0xc>  @ imm = #-0x2
700abecc: 9801         	ldr	r0, [sp, #0x4]
700abece: 6800         	ldr	r0, [r0]
700abed0: 7800         	ldrb	r0, [r0]
700abed2: f000 fb8d    	bl	0x700ac5f0 <_is_digit>  @ imm = #0x71a
700abed6: b168         	cbz	r0, 0x700abef4 <_atoi+0x34> @ imm = #0x1a
700abed8: e7ff         	b	0x700abeda <_atoi+0x1a> @ imm = #-0x2
;     i = i * 10U + (unsigned int)(*((*str)++) - '0');
700abeda: 9800         	ldr	r0, [sp]
700abedc: eb00 0180    	add.w	r1, r0, r0, lsl #2
700abee0: 9b01         	ldr	r3, [sp, #0x4]
700abee2: 6818         	ldr	r0, [r3]
700abee4: 1c42         	adds	r2, r0, #0x1
700abee6: 601a         	str	r2, [r3]
700abee8: 7800         	ldrb	r0, [r0]
700abeea: eb00 0041    	add.w	r0, r0, r1, lsl #1
700abeee: 3830         	subs	r0, #0x30
700abef0: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700abef2: e7eb         	b	0x700abecc <_atoi+0xc>  @ imm = #-0x2a
;   return i;
700abef4: 9800         	ldr	r0, [sp]
700abef6: b002         	add	sp, #0x8
700abef8: bd80         	pop	{r7, pc}
700abefa: 0000         	movs	r0, r0
700abefc: 0000         	movs	r0, r0
700abefe: 0000         	movs	r0, r0

700abf00 <snprintf_>:
; {
700abf00: b081         	sub	sp, #0x4
700abf02: b580         	push	{r7, lr}
700abf04: b087         	sub	sp, #0x1c
700abf06: 9309         	str	r3, [sp, #0x24]
700abf08: 9006         	str	r0, [sp, #0x18]
700abf0a: 9105         	str	r1, [sp, #0x14]
700abf0c: 9204         	str	r2, [sp, #0x10]
700abf0e: a809         	add	r0, sp, #0x24
;   va_start(va, format);
700abf10: 9003         	str	r0, [sp, #0xc]
;   const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
700abf12: 9906         	ldr	r1, [sp, #0x18]
700abf14: 9a05         	ldr	r2, [sp, #0x14]
700abf16: 9b04         	ldr	r3, [sp, #0x10]
700abf18: 9803         	ldr	r0, [sp, #0xc]
700abf1a: 46ec         	mov	r12, sp
700abf1c: f8cc 0000    	str.w	r0, [r12]
700abf20: f64c 30f1    	movw	r0, #0xcbf1
700abf24: f2c7 000a    	movt	r0, #0x700a
700abf28: f7ed f86a    	bl	0x70099000 <_vsnprintf> @ imm = #-0x12f2c
700abf2c: 9002         	str	r0, [sp, #0x8]
;   return ret;
700abf2e: 9802         	ldr	r0, [sp, #0x8]
700abf30: b007         	add	sp, #0x1c
700abf32: e8bd 4080    	pop.w	{r7, lr}
700abf36: b001         	add	sp, #0x4
700abf38: 4770         	bx	lr
700abf3a: 0000         	movs	r0, r0
700abf3c: 0000         	movs	r0, r0
700abf3e: 0000         	movs	r0, r0

700abf40 <vListInsertEnd>:
; {
700abf40: b083         	sub	sp, #0xc
700abf42: 9002         	str	r0, [sp, #0x8]
700abf44: 9101         	str	r1, [sp, #0x4]
;     ListItem_t * const pxIndex = pxList->pxIndex;
700abf46: 9802         	ldr	r0, [sp, #0x8]
700abf48: 6840         	ldr	r0, [r0, #0x4]
700abf4a: 9000         	str	r0, [sp]
;     pxNewListItem->pxNext = pxIndex;
700abf4c: 9800         	ldr	r0, [sp]
700abf4e: 9901         	ldr	r1, [sp, #0x4]
700abf50: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxPrevious = pxIndex->pxPrevious;
700abf52: 9800         	ldr	r0, [sp]
700abf54: 6880         	ldr	r0, [r0, #0x8]
700abf56: 9901         	ldr	r1, [sp, #0x4]
700abf58: 6088         	str	r0, [r1, #0x8]
;     pxIndex->pxPrevious->pxNext = pxNewListItem;
700abf5a: 9801         	ldr	r0, [sp, #0x4]
700abf5c: 9900         	ldr	r1, [sp]
700abf5e: 6889         	ldr	r1, [r1, #0x8]
700abf60: 6048         	str	r0, [r1, #0x4]
;     pxIndex->pxPrevious = pxNewListItem;
700abf62: 9801         	ldr	r0, [sp, #0x4]
700abf64: 9900         	ldr	r1, [sp]
700abf66: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxContainer = pxList;
700abf68: 9802         	ldr	r0, [sp, #0x8]
700abf6a: 9901         	ldr	r1, [sp, #0x4]
700abf6c: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700abf6e: 9902         	ldr	r1, [sp, #0x8]
700abf70: 6808         	ldr	r0, [r1]
700abf72: 3001         	adds	r0, #0x1
700abf74: 6008         	str	r0, [r1]
; }
700abf76: b003         	add	sp, #0xc
700abf78: 4770         	bx	lr
700abf7a: 0000         	movs	r0, r0
700abf7c: 0000         	movs	r0, r0
700abf7e: 0000         	movs	r0, r0

700abf80 <CSL_REG32_FINS_RAW>:
; {
700abf80: b580         	push	{r7, lr}
700abf82: b086         	sub	sp, #0x18
700abf84: 9005         	str	r0, [sp, #0x14]
700abf86: 9104         	str	r1, [sp, #0x10]
700abf88: 9203         	str	r2, [sp, #0xc]
700abf8a: 9302         	str	r3, [sp, #0x8]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700abf8c: 9805         	ldr	r0, [sp, #0x14]
700abf8e: f001 fb97    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0x172e
700abf92: 9001         	str	r0, [sp, #0x4]
;     regVal = (regVal & ~(mask));
700abf94: 9801         	ldr	r0, [sp, #0x4]
700abf96: 9904         	ldr	r1, [sp, #0x10]
700abf98: 4388         	bics	r0, r1
700abf9a: 9001         	str	r0, [sp, #0x4]
;     regVal |= (v << shift) & mask;
700abf9c: 9802         	ldr	r0, [sp, #0x8]
700abf9e: 9903         	ldr	r1, [sp, #0xc]
700abfa0: 4088         	lsls	r0, r1
700abfa2: 9904         	ldr	r1, [sp, #0x10]
700abfa4: 4001         	ands	r1, r0
700abfa6: 9801         	ldr	r0, [sp, #0x4]
700abfa8: 4308         	orrs	r0, r1
700abfaa: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR_RAW(p, regVal);
700abfac: 9805         	ldr	r0, [sp, #0x14]
700abfae: 9901         	ldr	r1, [sp, #0x4]
700abfb0: f001 fae6    	bl	0x700ad580 <CSL_REG32_WR_RAW> @ imm = #0x15cc
;     return;
700abfb4: b006         	add	sp, #0x18
700abfb6: bd80         	pop	{r7, pc}
		...

700abfc0 <SOC_getCoreName>:
; {
700abfc0: b082         	sub	sp, #0x8
700abfc2: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     if(coreId < CSL_CORE_ID_MAX)
700abfc6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700abfca: 2806         	cmp	r0, #0x6
700abfcc: d80a         	bhi	0x700abfe4 <SOC_getCoreName+0x24> @ imm = #0x14
700abfce: e7ff         	b	0x700abfd0 <SOC_getCoreName+0x10> @ imm = #-0x2
;         name = coreIdNames[coreId];
700abfd0: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700abfd4: f240 00a4    	movw	r0, #0xa4
700abfd8: f2c7 000b    	movt	r0, #0x700b
700abfdc: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700abfe0: 9000         	str	r0, [sp]
;     }
700abfe2: e006         	b	0x700abff2 <SOC_getCoreName+0x32> @ imm = #0xc
;         name = coreIdNames[CSL_CORE_ID_MAX];
700abfe4: f240 00a4    	movw	r0, #0xa4
700abfe8: f2c7 000b    	movt	r0, #0x700b
700abfec: 69c0         	ldr	r0, [r0, #0x1c]
700abfee: 9000         	str	r0, [sp]
700abff0: e7ff         	b	0x700abff2 <SOC_getCoreName+0x32> @ imm = #-0x2
;     return name;
700abff2: 9800         	ldr	r0, [sp]
700abff4: b002         	add	sp, #0x8
700abff6: 4770         	bx	lr
		...

700ac000 <Sciclient_secProxyFlush>:
; {
700ac000: b580         	push	{r7, lr}
700ac002: b082         	sub	sp, #0x8
700ac004: 9001         	str	r0, [sp, #0x4]
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ac006: e7ff         	b	0x700ac008 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2
700ac008: 9801         	ldr	r0, [sp, #0x4]
700ac00a: f001 f8f9    	bl	0x700ad200 <Sciclient_secProxyThreadStatusReg> @ imm = #0x11f2
700ac00e: f001 fb6f    	bl	0x700ad6f0 <CSL_REG32_RD_RAW> @ imm = #0x16de
700ac012: 0600         	lsls	r0, r0, #0x18
700ac014: b170         	cbz	r0, 0x700ac034 <Sciclient_secProxyFlush+0x34> @ imm = #0x1c
700ac016: e7ff         	b	0x700ac018 <Sciclient_secProxyFlush+0x18> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(thread,
700ac018: 9801         	ldr	r0, [sp, #0x4]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U)-1U));
700ac01a: f240 1138    	movw	r1, #0x138
700ac01e: f2c7 010b    	movt	r1, #0x700b
700ac022: 694a         	ldr	r2, [r1, #0x14]
700ac024: f04f 31ff    	mov.w	r1, #0xffffffff
700ac028: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(thread,
700ac02c: b2c9         	uxtb	r1, r1
700ac02e: f000 fac7    	bl	0x700ac5c0 <Sciclient_secProxyReadThread32> @ imm = #0x58e
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ac032: e7e9         	b	0x700ac008 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2e
;     return ;
700ac034: b002         	add	sp, #0x8
700ac036: bd80         	pop	{r7, pc}
		...

700ac040 <UART_writeDataPolling>:
; {
700ac040: b580         	push	{r7, lr}
700ac042: b082         	sub	sp, #0x8
700ac044: 9001         	str	r0, [sp, #0x4]
700ac046: 2000         	movs	r0, #0x0
;     uint32_t numBytesWritten = 0U;
700ac048: 9000         	str	r0, [sp]
;     numBytesWritten = UART_fifoWrite(hUart,
700ac04a: 9801         	ldr	r0, [sp, #0x4]
;                                      (const uint8_t *) hUart->writeBuf,
700ac04c: 6881         	ldr	r1, [r0, #0x8]
;                                      hUart->writeSizeRemaining);
700ac04e: 6902         	ldr	r2, [r0, #0x10]
;     numBytesWritten = UART_fifoWrite(hUart,
700ac050: f7f9 fc2e    	bl	0x700a58b0 <UART_fifoWrite> @ imm = #-0x67a4
700ac054: 9000         	str	r0, [sp]
;     hUart->writeSizeRemaining -= numBytesWritten;
700ac056: 9a00         	ldr	r2, [sp]
700ac058: 9901         	ldr	r1, [sp, #0x4]
700ac05a: 6908         	ldr	r0, [r1, #0x10]
700ac05c: 1a80         	subs	r0, r0, r2
700ac05e: 6108         	str	r0, [r1, #0x10]
;     hUart->writeBuf           = (const void *)((uint8_t *)hUart->writeBuf + numBytesWritten);
700ac060: 9901         	ldr	r1, [sp, #0x4]
700ac062: 6888         	ldr	r0, [r1, #0x8]
700ac064: 9a00         	ldr	r2, [sp]
700ac066: 4410         	add	r0, r2
700ac068: 6088         	str	r0, [r1, #0x8]
;     hUart->writeCount         += numBytesWritten;
700ac06a: 9a00         	ldr	r2, [sp]
700ac06c: 9901         	ldr	r1, [sp, #0x4]
700ac06e: 68c8         	ldr	r0, [r1, #0xc]
700ac070: 4410         	add	r0, r2
700ac072: 60c8         	str	r0, [r1, #0xc]
;     return;
700ac074: b002         	add	sp, #0x8
700ac076: bd80         	pop	{r7, pc}
		...

700ac080 <xTaskGetSchedulerState>:
; BaseType_t xTaskGetSchedulerState(void) {
700ac080: b081         	sub	sp, #0x4
;   if (xSchedulerRunning == pdFALSE) {
700ac082: f240 200c    	movw	r0, #0x20c
700ac086: f2c7 000b    	movt	r0, #0x700b
700ac08a: 6800         	ldr	r0, [r0]
700ac08c: b918         	cbnz	r0, 0x700ac096 <xTaskGetSchedulerState+0x16> @ imm = #0x6
700ac08e: e7ff         	b	0x700ac090 <xTaskGetSchedulerState+0x10> @ imm = #-0x2
700ac090: 2001         	movs	r0, #0x1
;     xReturn = taskSCHEDULER_NOT_STARTED;
700ac092: 9000         	str	r0, [sp]
;   } else {
700ac094: e00d         	b	0x700ac0b2 <xTaskGetSchedulerState+0x32> @ imm = #0x1a
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700ac096: f240 10f0    	movw	r0, #0x1f0
700ac09a: f2c7 000b    	movt	r0, #0x700b
700ac09e: 6800         	ldr	r0, [r0]
700ac0a0: b918         	cbnz	r0, 0x700ac0aa <xTaskGetSchedulerState+0x2a> @ imm = #0x6
700ac0a2: e7ff         	b	0x700ac0a4 <xTaskGetSchedulerState+0x24> @ imm = #-0x2
700ac0a4: 2002         	movs	r0, #0x2
;       xReturn = taskSCHEDULER_RUNNING;
700ac0a6: 9000         	str	r0, [sp]
;     } else {
700ac0a8: e002         	b	0x700ac0b0 <xTaskGetSchedulerState+0x30> @ imm = #0x4
700ac0aa: 2000         	movs	r0, #0x0
;       xReturn = taskSCHEDULER_SUSPENDED;
700ac0ac: 9000         	str	r0, [sp]
700ac0ae: e7ff         	b	0x700ac0b0 <xTaskGetSchedulerState+0x30> @ imm = #-0x2
700ac0b0: e7ff         	b	0x700ac0b2 <xTaskGetSchedulerState+0x32> @ imm = #-0x2
;   return xReturn;
700ac0b2: 9800         	ldr	r0, [sp]
700ac0b4: b001         	add	sp, #0x4
700ac0b6: 4770         	bx	lr
		...

700ac0c0 <vTaskDelay>:
; void vTaskDelay(const TickType_t xTicksToDelay) {
700ac0c0: b580         	push	{r7, lr}
700ac0c2: b082         	sub	sp, #0x8
700ac0c4: 9001         	str	r0, [sp, #0x4]
700ac0c6: 2000         	movs	r0, #0x0
;   BaseType_t xAlreadyYielded = pdFALSE;
700ac0c8: 9000         	str	r0, [sp]
;   if (xTicksToDelay > (TickType_t)0U) {
700ac0ca: 9801         	ldr	r0, [sp, #0x4]
700ac0cc: b150         	cbz	r0, 0x700ac0e4 <vTaskDelay+0x24> @ imm = #0x14
700ac0ce: e7ff         	b	0x700ac0d0 <vTaskDelay+0x10> @ imm = #-0x2
;     vTaskSuspendAll();
700ac0d0: f001 fad6    	bl	0x700ad680 <vTaskSuspendAll> @ imm = #0x15ac
;       prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
700ac0d4: 9801         	ldr	r0, [sp, #0x4]
700ac0d6: 2100         	movs	r1, #0x0
700ac0d8: f7f7 fcba    	bl	0x700a3a50 <prvAddCurrentTaskToDelayedList> @ imm = #-0x868c
;     xAlreadyYielded = xTaskResumeAll();
700ac0dc: f7f4 fd28    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0xb5b0
700ac0e0: 9000         	str	r0, [sp]
;   } else {
700ac0e2: e000         	b	0x700ac0e6 <vTaskDelay+0x26> @ imm = #0x0
700ac0e4: e7ff         	b	0x700ac0e6 <vTaskDelay+0x26> @ imm = #-0x2
;   if (xAlreadyYielded == pdFALSE) {
700ac0e6: 9800         	ldr	r0, [sp]
700ac0e8: b910         	cbnz	r0, 0x700ac0f0 <vTaskDelay+0x30> @ imm = #0x4
700ac0ea: e7ff         	b	0x700ac0ec <vTaskDelay+0x2c> @ imm = #-0x2
;     portYIELD_WITHIN_API();
700ac0ec: df00         	svc	#0x0
;   } else {
700ac0ee: e000         	b	0x700ac0f2 <vTaskDelay+0x32> @ imm = #0x0
700ac0f0: e7ff         	b	0x700ac0f2 <vTaskDelay+0x32> @ imm = #-0x2
; }
700ac0f2: b002         	add	sp, #0x8
700ac0f4: bd80         	pop	{r7, pc}
		...
700ac0fe: 0000         	movs	r0, r0

700ac100 <vTaskPlaceOnEventListRestricted>:
;                                      const BaseType_t xWaitIndefinitely) {
700ac100: b580         	push	{r7, lr}
700ac102: b084         	sub	sp, #0x10
700ac104: 9003         	str	r0, [sp, #0xc]
700ac106: 9102         	str	r1, [sp, #0x8]
700ac108: 9201         	str	r2, [sp, #0x4]
;   vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
700ac10a: 9803         	ldr	r0, [sp, #0xc]
700ac10c: f240 11cc    	movw	r1, #0x1cc
700ac110: f2c7 010b    	movt	r1, #0x700b
700ac114: 6809         	ldr	r1, [r1]
700ac116: 3118         	adds	r1, #0x18
700ac118: f7ff ff12    	bl	0x700abf40 <vListInsertEnd> @ imm = #-0x1dc
;   if (xWaitIndefinitely != pdFALSE) {
700ac11c: 9801         	ldr	r0, [sp, #0x4]
700ac11e: b120         	cbz	r0, 0x700ac12a <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #0x8
700ac120: e7ff         	b	0x700ac122 <vTaskPlaceOnEventListRestricted+0x22> @ imm = #-0x2
700ac122: f04f 30ff    	mov.w	r0, #0xffffffff
;     xTicksToWait = portMAX_DELAY;
700ac126: 9002         	str	r0, [sp, #0x8]
;   }
700ac128: e7ff         	b	0x700ac12a <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #-0x2
;   prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
700ac12a: 9802         	ldr	r0, [sp, #0x8]
700ac12c: 9901         	ldr	r1, [sp, #0x4]
700ac12e: f7f7 fc8f    	bl	0x700a3a50 <prvAddCurrentTaskToDelayedList> @ imm = #-0x86e2
; }
700ac132: b004         	add	sp, #0x10
700ac134: bd80         	pop	{r7, pc}
		...
700ac13e: 0000         	movs	r0, r0

700ac140 <CSL_pktdmaTeardownRxChan>:
; {
700ac140: b580         	push	{r7, lr}
700ac142: b084         	sub	sp, #0x10
700ac144: 9003         	str	r0, [sp, #0xc]
700ac146: 9102         	str	r1, [sp, #0x8]
700ac148: f88d 2007    	strb.w	r2, [sp, #0x7]
700ac14c: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_RX, bForce, bWait );
700ac150: 9803         	ldr	r0, [sp, #0xc]
700ac152: 9902         	ldr	r1, [sp, #0x8]
700ac154: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ac158: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ac15c: f003 0301    	and	r3, r3, #0x1
700ac160: 46ec         	mov	r12, sp
700ac162: f8cc 3000    	str.w	r3, [r12]
700ac166: f002 0301    	and	r3, r2, #0x1
700ac16a: 2201         	movs	r2, #0x1
700ac16c: f7f7 f958    	bl	0x700a3420 <CSL_pktdmaTeardownChan> @ imm = #-0x8d50
700ac170: b004         	add	sp, #0x10
700ac172: bd80         	pop	{r7, pc}
		...

700ac180 <CSL_pktdmaTeardownTxChan>:
; {
700ac180: b580         	push	{r7, lr}
700ac182: b084         	sub	sp, #0x10
700ac184: 9003         	str	r0, [sp, #0xc]
700ac186: 9102         	str	r1, [sp, #0x8]
700ac188: f88d 2007    	strb.w	r2, [sp, #0x7]
700ac18c: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_TX, bForce, bWait );
700ac190: 9803         	ldr	r0, [sp, #0xc]
700ac192: 9902         	ldr	r1, [sp, #0x8]
700ac194: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ac198: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ac19c: f003 0301    	and	r3, r3, #0x1
700ac1a0: 46ec         	mov	r12, sp
700ac1a2: f8cc 3000    	str.w	r3, [r12]
700ac1a6: f002 0301    	and	r3, r2, #0x1
700ac1aa: 2200         	movs	r2, #0x0
700ac1ac: f7f7 f938    	bl	0x700a3420 <CSL_pktdmaTeardownChan> @ imm = #-0x8d90
700ac1b0: b004         	add	sp, #0x10
700ac1b2: bd80         	pop	{r7, pc}
		...

700ac1c0 <TimerP_Params_init>:
; {
700ac1c0: b081         	sub	sp, #0x4
700ac1c2: 9000         	str	r0, [sp]
;     params->inputPreScaler = 1;
700ac1c4: 9800         	ldr	r0, [sp]
700ac1c6: 2101         	movs	r1, #0x1
700ac1c8: 6001         	str	r1, [r0]
;     params->inputClkHz = 25*1000000;
700ac1ca: 9a00         	ldr	r2, [sp]
700ac1cc: f647 0040    	movw	r0, #0x7840
700ac1d0: f2c0 107d    	movt	r0, #0x17d
700ac1d4: 6050         	str	r0, [r2, #0x4]
;     params->periodInUsec = 1000;
700ac1d6: 9a00         	ldr	r2, [sp]
700ac1d8: f44f 707a    	mov.w	r0, #0x3e8
700ac1dc: 6090         	str	r0, [r2, #0x8]
;     params->periodInNsec = 0; /* periodInUsec is used when periodInNsec is 0 */
700ac1de: 9a00         	ldr	r2, [sp]
700ac1e0: 2000         	movs	r0, #0x0
700ac1e2: 60d0         	str	r0, [r2, #0xc]
;     params->oneshotMode = 0;
700ac1e4: 9a00         	ldr	r2, [sp]
700ac1e6: 6110         	str	r0, [r2, #0x10]
;     params->enableOverflowInt = 1;
700ac1e8: 9a00         	ldr	r2, [sp]
700ac1ea: 6151         	str	r1, [r2, #0x14]
;     params->enableDmaTrigger = 0; /* NOT USED */
700ac1ec: 9900         	ldr	r1, [sp]
700ac1ee: 6188         	str	r0, [r1, #0x18]
; }
700ac1f0: b001         	add	sp, #0x4
700ac1f2: 4770         	bx	lr
		...

700ac200 <UART_IsDataLengthValid>:
; {
700ac200: b082         	sub	sp, #0x8
700ac202: 9001         	str	r0, [sp, #0x4]
700ac204: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ac208: 9000         	str	r0, [sp]
;     if(((dataLength == UART_LEN_5) ||
700ac20a: 9801         	ldr	r0, [sp, #0x4]
700ac20c: b160         	cbz	r0, 0x700ac228 <UART_IsDataLengthValid+0x28> @ imm = #0x18
700ac20e: e7ff         	b	0x700ac210 <UART_IsDataLengthValid+0x10> @ imm = #-0x2
;         (dataLength == UART_LEN_6) ||
700ac210: 9801         	ldr	r0, [sp, #0x4]
700ac212: 2801         	cmp	r0, #0x1
700ac214: d008         	beq	0x700ac228 <UART_IsDataLengthValid+0x28> @ imm = #0x10
700ac216: e7ff         	b	0x700ac218 <UART_IsDataLengthValid+0x18> @ imm = #-0x2
;         (dataLength == UART_LEN_7) ||
700ac218: 9801         	ldr	r0, [sp, #0x4]
700ac21a: 2802         	cmp	r0, #0x2
700ac21c: d004         	beq	0x700ac228 <UART_IsDataLengthValid+0x28> @ imm = #0x8
700ac21e: e7ff         	b	0x700ac220 <UART_IsDataLengthValid+0x20> @ imm = #-0x2
;         (dataLength == UART_LEN_8)))
700ac220: 9801         	ldr	r0, [sp, #0x4]
;     if(((dataLength == UART_LEN_5) ||
700ac222: 2803         	cmp	r0, #0x3
700ac224: d103         	bne	0x700ac22e <UART_IsDataLengthValid+0x2e> @ imm = #0x6
700ac226: e7ff         	b	0x700ac228 <UART_IsDataLengthValid+0x28> @ imm = #-0x2
700ac228: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ac22a: 9000         	str	r0, [sp]
;     }
700ac22c: e7ff         	b	0x700ac22e <UART_IsDataLengthValid+0x2e> @ imm = #-0x2
;     return status;
700ac22e: 9800         	ldr	r0, [sp]
700ac230: b002         	add	sp, #0x8
700ac232: 4770         	bx	lr
		...

700ac240 <UART_checkTransaction>:
; {
700ac240: b082         	sub	sp, #0x8
700ac242: 9001         	str	r0, [sp, #0x4]
700ac244: 2000         	movs	r0, #0x0
;     int32_t     status = UART_TRANSFER_STATUS_SUCCESS;
700ac246: 9000         	str	r0, [sp]
;     if(0U == trans->count)
700ac248: 9801         	ldr	r0, [sp, #0x4]
700ac24a: 6840         	ldr	r0, [r0, #0x4]
700ac24c: b938         	cbnz	r0, 0x700ac25e <UART_checkTransaction+0x1e> @ imm = #0xe
700ac24e: e7ff         	b	0x700ac250 <UART_checkTransaction+0x10> @ imm = #-0x2
;         trans->status = UART_TRANSFER_STATUS_ERROR_OTH;
700ac250: 9901         	ldr	r1, [sp, #0x4]
700ac252: 200a         	movs	r0, #0xa
700ac254: 60c8         	str	r0, [r1, #0xc]
700ac256: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ac25a: 9000         	str	r0, [sp]
;     }
700ac25c: e7ff         	b	0x700ac25e <UART_checkTransaction+0x1e> @ imm = #-0x2
;     if(NULL == trans->buf)
700ac25e: 9801         	ldr	r0, [sp, #0x4]
700ac260: 6800         	ldr	r0, [r0]
700ac262: b920         	cbnz	r0, 0x700ac26e <UART_checkTransaction+0x2e> @ imm = #0x8
700ac264: e7ff         	b	0x700ac266 <UART_checkTransaction+0x26> @ imm = #-0x2
700ac266: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ac26a: 9000         	str	r0, [sp]
;     }
700ac26c: e7ff         	b	0x700ac26e <UART_checkTransaction+0x2e> @ imm = #-0x2
;     return (status);
700ac26e: 9800         	ldr	r0, [sp]
700ac270: b002         	add	sp, #0x8
700ac272: 4770         	bx	lr

700ac274 <free_list_remove>:
700ac274: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700ac2a4 <free_list_remove+0x30>
700ac278: e5932000     	ldr	r2, [r3]
700ac27c: e1a01003     	mov	r1, r3
700ac280: e3520000     	cmp	r2, #0
700ac284: 12823008     	addne	r3, r2, #8
700ac288: 11520000     	cmpne	r2, r0
700ac28c: 1afffff9     	bne	0x700ac278 <free_list_remove+0x4> @ imm = #-0x1c
700ac290: e3520000     	cmp	r2, #0
700ac294: 012fff1e     	bxeq	lr
700ac298: e5900008     	ldr	r0, [r0, #0x8]
700ac29c: e5810000     	str	r0, [r1]
700ac2a0: e12fff1e     	bx	lr
700ac2a4: c4 4f 08 70  	.word	0x70084fc4
700ac2a8: 00 00 00 00  	.word	0x00000000
700ac2ac: 00 00 00 00  	.word	0x00000000

700ac2b0 <vPortTimerTickHandler>:
; void vPortTimerTickHandler() {
700ac2b0: b580         	push	{r7, lr}
;   portENTER_CRITICAL();
700ac2b2: f000 f89d    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #0x13a
;   if (ulPortSchedularRunning == pdTRUE) {
700ac2b6: f240 10dc    	movw	r0, #0x1dc
700ac2ba: f2c7 000b    	movt	r0, #0x700b
700ac2be: 6800         	ldr	r0, [r0]
700ac2c0: 2801         	cmp	r0, #0x1
700ac2c2: d10c         	bne	0x700ac2de <vPortTimerTickHandler+0x2e> @ imm = #0x18
700ac2c4: e7ff         	b	0x700ac2c6 <vPortTimerTickHandler+0x16> @ imm = #-0x2
;     if (xTaskIncrementTick() != pdFALSE) {
700ac2c6: f7f3 fcdb    	bl	0x7009fc80 <xTaskIncrementTick> @ imm = #-0xc64a
700ac2ca: b138         	cbz	r0, 0x700ac2dc <vPortTimerTickHandler+0x2c> @ imm = #0xe
700ac2cc: e7ff         	b	0x700ac2ce <vPortTimerTickHandler+0x1e> @ imm = #-0x2
;       ulPortYieldRequired = pdTRUE;
700ac2ce: f240 11e4    	movw	r1, #0x1e4
700ac2d2: f2c7 010b    	movt	r1, #0x700b
700ac2d6: 2001         	movs	r0, #0x1
700ac2d8: 6008         	str	r0, [r1]
;     }
700ac2da: e7ff         	b	0x700ac2dc <vPortTimerTickHandler+0x2c> @ imm = #-0x2
;   }
700ac2dc: e7ff         	b	0x700ac2de <vPortTimerTickHandler+0x2e> @ imm = #-0x2
;   portEXIT_CRITICAL();
700ac2de: f7ff f987    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #-0xcf2
; }
700ac2e2: bd80         	pop	{r7, pc}
		...

700ac2f0 <ClockP_timerTickIsr>:
; {
700ac2f0: b580         	push	{r7, lr}
700ac2f2: b082         	sub	sp, #0x8
700ac2f4: 9001         	str	r0, [sp, #0x4]
;     gClockCtrl.ticks++;
700ac2f6: f644 6198    	movw	r1, #0x4e98
700ac2fa: f2c7 0108    	movt	r1, #0x7008
700ac2fe: 680a         	ldr	r2, [r1]
700ac300: 6848         	ldr	r0, [r1, #0x4]
700ac302: 3201         	adds	r2, #0x1
700ac304: f140 0000    	adc	r0, r0, #0x0
700ac308: 600a         	str	r2, [r1]
700ac30a: 6048         	str	r0, [r1, #0x4]
;     vPortTimerTickHandler();
700ac30c: f7ff ffd0    	bl	0x700ac2b0 <vPortTimerTickHandler> @ imm = #-0x60
;     ClockP_timerClearOverflowInt(gClockConfig.timerBaseAddr);
700ac310: f240 1008    	movw	r0, #0x108
700ac314: f2c7 000b    	movt	r0, #0x700b
700ac318: 6800         	ldr	r0, [r0]
700ac31a: f001 f981    	bl	0x700ad620 <ClockP_timerClearOverflowInt> @ imm = #0x1302
; }
700ac31e: b002         	add	sp, #0x8
700ac320: bd80         	pop	{r7, pc}
		...
700ac32e: 0000         	movs	r0, r0

700ac330 <HW_WR_FIELD32_RAW>:
; {
700ac330: b085         	sub	sp, #0x14
700ac332: 9004         	str	r0, [sp, #0x10]
700ac334: 9103         	str	r1, [sp, #0xc]
700ac336: 9202         	str	r2, [sp, #0x8]
700ac338: 9301         	str	r3, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700ac33a: 9804         	ldr	r0, [sp, #0x10]
700ac33c: 6800         	ldr	r0, [r0]
700ac33e: 9000         	str	r0, [sp]
;     regVal &= (~mask);
700ac340: 9903         	ldr	r1, [sp, #0xc]
700ac342: 9800         	ldr	r0, [sp]
700ac344: 4388         	bics	r0, r1
700ac346: 9000         	str	r0, [sp]
;     regVal |= (value << shift) & mask;
700ac348: 9801         	ldr	r0, [sp, #0x4]
700ac34a: 9902         	ldr	r1, [sp, #0x8]
700ac34c: 4088         	lsls	r0, r1
700ac34e: 9903         	ldr	r1, [sp, #0xc]
700ac350: 4001         	ands	r1, r0
700ac352: 9800         	ldr	r0, [sp]
700ac354: 4308         	orrs	r0, r1
700ac356: 9000         	str	r0, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = regVal;
700ac358: 9800         	ldr	r0, [sp]
700ac35a: 9904         	ldr	r1, [sp, #0x10]
700ac35c: 6008         	str	r0, [r1]
;     return;
700ac35e: b005         	add	sp, #0x14
700ac360: 4770         	bx	lr
		...
700ac36e: 0000         	movs	r0, r0

700ac370 <UART_enhanFuncBitValRestore>:
; {
700ac370: b580         	push	{r7, lr}
700ac372: b084         	sub	sp, #0x10
700ac374: 9003         	str	r0, [sp, #0xc]
700ac376: 9102         	str	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ac378: 9803         	ldr	r0, [sp, #0xc]
700ac37a: 21bf         	movs	r1, #0xbf
700ac37c: f7fe f950    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #-0x1d60
700ac380: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700ac382: 9803         	ldr	r0, [sp, #0xc]
700ac384: 3008         	adds	r0, #0x8
700ac386: 9902         	ldr	r1, [sp, #0x8]
700ac388: ea4f 1311    	lsr.w	r3, r1, #0x4
700ac38c: 2110         	movs	r1, #0x10
700ac38e: 2204         	movs	r2, #0x4
700ac390: f7ff ffce    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #-0x64
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ac394: 9803         	ldr	r0, [sp, #0xc]
700ac396: 300c         	adds	r0, #0xc
700ac398: 9901         	ldr	r1, [sp, #0x4]
700ac39a: f001 f951    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x12a2
; }
700ac39e: b004         	add	sp, #0x10
700ac3a0: bd80         	pop	{r7, pc}
		...
700ac3ae: 0000         	movs	r0, r0

700ac3b0 <UART_hardwareFlowCtrlOptSet>:
; {
700ac3b0: b580         	push	{r7, lr}
700ac3b2: b084         	sub	sp, #0x10
700ac3b4: 9003         	str	r0, [sp, #0xc]
700ac3b6: 9102         	str	r1, [sp, #0x8]
700ac3b8: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ac3ba: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ac3bc: 9803         	ldr	r0, [sp, #0xc]
700ac3be: 21bf         	movs	r1, #0xbf
700ac3c0: f7fe f92e    	bl	0x700aa620 <UART_regConfigModeEnable> @ imm = #-0x1da4
700ac3c4: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_HW_FLOW_CONTROL, hwFlowCtrl);
700ac3c6: 9803         	ldr	r0, [sp, #0xc]
700ac3c8: 3008         	adds	r0, #0x8
700ac3ca: 9b02         	ldr	r3, [sp, #0x8]
700ac3cc: 21c0         	movs	r1, #0xc0
700ac3ce: 2206         	movs	r2, #0x6
700ac3d0: f7ff ffae    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #-0xa4
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ac3d4: 9803         	ldr	r0, [sp, #0xc]
700ac3d6: 300c         	adds	r0, #0xc
700ac3d8: 9901         	ldr	r1, [sp, #0x4]
700ac3da: f001 f931    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x1262
; }
700ac3de: b004         	add	sp, #0x10
700ac3e0: bd80         	pop	{r7, pc}
		...
700ac3ee: 0000         	movs	r0, r0

700ac3f0 <vTaskEnterCritical>:
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700ac3f0: b672         	cpsid i
;   if (xSchedulerRunning != pdFALSE) {
700ac3f2: f240 200c    	movw	r0, #0x20c
700ac3f6: f2c7 000b    	movt	r0, #0x700b
700ac3fa: 6800         	ldr	r0, [r0]
700ac3fc: b178         	cbz	r0, 0x700ac41e <vTaskEnterCritical+0x2e> @ imm = #0x1e
700ac3fe: e7ff         	b	0x700ac400 <vTaskEnterCritical+0x10> @ imm = #-0x2
;     (pxCurrentTCB->uxCriticalNesting)++;
700ac400: f240 10cc    	movw	r0, #0x1cc
700ac404: f2c7 000b    	movt	r0, #0x700b
700ac408: 6802         	ldr	r2, [r0]
700ac40a: 6d51         	ldr	r1, [r2, #0x54]
700ac40c: 3101         	adds	r1, #0x1
700ac40e: 6551         	str	r1, [r2, #0x54]
;     if (pxCurrentTCB->uxCriticalNesting == 1) {
700ac410: 6800         	ldr	r0, [r0]
700ac412: 6d40         	ldr	r0, [r0, #0x54]
700ac414: 2801         	cmp	r0, #0x1
700ac416: d101         	bne	0x700ac41c <vTaskEnterCritical+0x2c> @ imm = #0x2
700ac418: e7ff         	b	0x700ac41a <vTaskEnterCritical+0x2a> @ imm = #-0x2
;     }
700ac41a: e7ff         	b	0x700ac41c <vTaskEnterCritical+0x2c> @ imm = #-0x2
;   } else {
700ac41c: e000         	b	0x700ac420 <vTaskEnterCritical+0x30> @ imm = #0x0
700ac41e: e7ff         	b	0x700ac420 <vTaskEnterCritical+0x30> @ imm = #-0x2
; }
700ac420: 4770         	bx	lr
		...
700ac42e: 0000         	movs	r0, r0

700ac430 <xQueueCreateMutexStatic>:
;     {
700ac430: b580         	push	{r7, lr}
700ac432: b086         	sub	sp, #0x18
700ac434: f88d 0017    	strb.w	r0, [sp, #0x17]
700ac438: 9104         	str	r1, [sp, #0x10]
700ac43a: 2001         	movs	r0, #0x1
;         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
700ac43c: 9002         	str	r0, [sp, #0x8]
700ac43e: 2200         	movs	r2, #0x0
700ac440: 9201         	str	r2, [sp, #0x4]
;         ( void ) ucQueueType;
700ac442: f89d 1017    	ldrb.w	r1, [sp, #0x17]
;         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
700ac446: 9b04         	ldr	r3, [sp, #0x10]
700ac448: 46ec         	mov	r12, sp
700ac44a: f8cc 1000    	str.w	r1, [r12]
700ac44e: 4611         	mov	r1, r2
700ac450: f7fe ff8e    	bl	0x700ab370 <xQueueGenericCreateStatic> @ imm = #-0x10e4
700ac454: 9003         	str	r0, [sp, #0xc]
;         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
700ac456: 9803         	ldr	r0, [sp, #0xc]
700ac458: f000 f9ea    	bl	0x700ac830 <prvInitialiseMutex> @ imm = #0x3d4
;         return xNewQueue;
700ac45c: 9803         	ldr	r0, [sp, #0xc]
700ac45e: b006         	add	sp, #0x18
700ac460: bd80         	pop	{r7, pc}
		...
700ac46e: 0000         	movs	r0, r0

700ac470 <CSL_pktdmaGetChanPeerReg>:
; {
700ac470: b510         	push	{r4, lr}
700ac472: b086         	sub	sp, #0x18
700ac474: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ac478: 9005         	str	r0, [sp, #0x14]
700ac47a: 9104         	str	r1, [sp, #0x10]
700ac47c: 9203         	str	r2, [sp, #0xc]
700ac47e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)true );
700ac480: 9805         	ldr	r0, [sp, #0x14]
700ac482: 9904         	ldr	r1, [sp, #0x10]
700ac484: 9a02         	ldr	r2, [sp, #0x8]
700ac486: 9b08         	ldr	r3, [sp, #0x20]
700ac488: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ac48c: 46ee         	mov	lr, sp
700ac48e: 2401         	movs	r4, #0x1
700ac490: f8ce 4004    	str.w	r4, [lr, #0x4]
700ac494: f8ce c000    	str.w	r12, [lr]
700ac498: f7f9 f9aa    	bl	0x700a57f0 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6cac
700ac49c: b006         	add	sp, #0x18
700ac49e: bd10         	pop	{r4, pc}

700ac4a0 <CSL_pktdmaSetChanPeerReg>:
; {
700ac4a0: b510         	push	{r4, lr}
700ac4a2: b086         	sub	sp, #0x18
700ac4a4: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ac4a8: 9005         	str	r0, [sp, #0x14]
700ac4aa: 9104         	str	r1, [sp, #0x10]
700ac4ac: 9203         	str	r2, [sp, #0xc]
700ac4ae: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)false );
700ac4b0: 9805         	ldr	r0, [sp, #0x14]
700ac4b2: 9904         	ldr	r1, [sp, #0x10]
700ac4b4: 9a02         	ldr	r2, [sp, #0x8]
700ac4b6: 9b08         	ldr	r3, [sp, #0x20]
700ac4b8: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ac4bc: 46ee         	mov	lr, sp
700ac4be: 2400         	movs	r4, #0x0
700ac4c0: f8ce 4004    	str.w	r4, [lr, #0x4]
700ac4c4: f8ce c000    	str.w	r12, [lr]
700ac4c8: f7f9 f992    	bl	0x700a57f0 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6cdc
700ac4cc: b006         	add	sp, #0x18
700ac4ce: bd10         	pop	{r4, pc}

700ac4d0 <UART_flowCtrlTrigLvlConfig>:
; {
700ac4d0: b580         	push	{r7, lr}
700ac4d2: b084         	sub	sp, #0x10
700ac4d4: 9003         	str	r0, [sp, #0xc]
700ac4d6: 9102         	str	r1, [sp, #0x8]
700ac4d8: 9201         	str	r2, [sp, #0x4]
700ac4da: 2000         	movs	r0, #0x0
;     uint32_t tcrValue = 0;
700ac4dc: 9000         	str	r0, [sp]
;     tcrValue = rtsHaltFlag & UART_TCR_RX_FIFO_TRIG_HALT_MASK;
700ac4de: 9802         	ldr	r0, [sp, #0x8]
700ac4e0: f000 000f    	and	r0, r0, #0xf
700ac4e4: 9000         	str	r0, [sp]
;     tcrValue |= (rtsStartFlag <<
700ac4e6: 9801         	ldr	r0, [sp, #0x4]
700ac4e8: 0100         	lsls	r0, r0, #0x4
;                  UART_TCR_RX_FIFO_TRIG_START_SHIFT) &
700ac4ea: b2c1         	uxtb	r1, r0
;     tcrValue |= (rtsStartFlag <<
700ac4ec: 9800         	ldr	r0, [sp]
700ac4ee: 4308         	orrs	r0, r1
700ac4f0: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_TCR, tcrValue);
700ac4f2: 9803         	ldr	r0, [sp, #0xc]
700ac4f4: 3018         	adds	r0, #0x18
700ac4f6: 9900         	ldr	r1, [sp]
700ac4f8: f001 f8a2    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x1144
; }
700ac4fc: b004         	add	sp, #0x10
700ac4fe: bd80         	pop	{r7, pc}

700ac500 <CycleCounterP_getCount32>:
;         MRC     p15, #0, r0, c9, c13, 0  // read PMCCNTR
700ac500: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0
;         bx      LR
700ac504: e12fff1e     	bx	lr

700ac508 <PmuP_setup>:
;         MCR     p15, #0, r0, c9, c12, 0 // write PMCR
700ac508: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;         bx      LR
700ac50c: e12fff1e     	bx	lr

700ac510 <PmuP_enableCounters>:
;         MCR     p15, #0, r0, c9, c12, 1  // write PMCNTENSET
700ac510: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;         bx      LR
700ac514: e12fff1e     	bx	lr

700ac518 <PmuP_disableCounters>:
;         MCR     p15, #0, r0, c9, c12, 2  // write PMCNTENCLR
700ac518: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2
;         bx      LR
700ac51c: e12fff1e     	bx	lr

700ac520 <PmuP_getOverflowStatus>:
;         MRC     p15, 0, r0, c9, c12, 3  // read PMOVSR
700ac520: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ac524: e12fff1e     	bx	lr

700ac528 <PmuP_clearOverflowStatus>:
;         MCR     p15, 0, r0, c9, c12, 3  // write PMOVSR
700ac528: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ac52c: e12fff1e     	bx	lr

700ac530 <CSL_secProxyGetMaxMsgSize>:
; {
700ac530: b580         	push	{r7, lr}
700ac532: b082         	sub	sp, #0x8
700ac534: 9001         	str	r0, [sp, #0x4]
;     if( pSecProxyCfg->maxMsgSize == (uint32_t)0U )
700ac536: 9801         	ldr	r0, [sp, #0x4]
700ac538: 6980         	ldr	r0, [r0, #0x18]
700ac53a: b960         	cbnz	r0, 0x700ac556 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #0x18
700ac53c: e7ff         	b	0x700ac53e <CSL_secProxyGetMaxMsgSize+0xe> @ imm = #-0x2
;         pSecProxyCfg->maxMsgSize = (uint32_t)CSL_REG32_FEXT( &pSecProxyCfg->pSecProxyRegs->CONFIG, SEC_PROXY_CONFIG_MSG_SIZE );
700ac53e: 9801         	ldr	r0, [sp, #0x4]
700ac540: 6800         	ldr	r0, [r0]
700ac542: 3004         	adds	r0, #0x4
700ac544: 2100         	movs	r1, #0x0
700ac546: f6cf 71ff    	movt	r1, #0xffff
700ac54a: 2210         	movs	r2, #0x10
700ac54c: f000 fbe0    	bl	0x700acd10 <CSL_REG32_FEXT_RAW> @ imm = #0x7c0
700ac550: 9901         	ldr	r1, [sp, #0x4]
700ac552: 6188         	str	r0, [r1, #0x18]
;     }
700ac554: e7ff         	b	0x700ac556 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #-0x2
;     return pSecProxyCfg->maxMsgSize;
700ac556: 9801         	ldr	r0, [sp, #0x4]
700ac558: 6980         	ldr	r0, [r0, #0x18]
700ac55a: b002         	add	sp, #0x8
700ac55c: bd80         	pop	{r7, pc}
700ac55e: 0000         	movs	r0, r0

700ac560 <Sciclient_rmIaIsIa>:
; {
700ac560: b580         	push	{r7, lr}
700ac562: b082         	sub	sp, #0x8
700ac564: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ac568: 2000         	movs	r0, #0x0
;     bool r = false;
700ac56a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIaGetInst(id) != NULL) {
700ac56e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac572: f7fd ff35    	bl	0x700aa3e0 <Sciclient_rmIaGetInst> @ imm = #-0x2196
700ac576: b120         	cbz	r0, 0x700ac582 <Sciclient_rmIaIsIa+0x22> @ imm = #0x8
700ac578: e7ff         	b	0x700ac57a <Sciclient_rmIaIsIa+0x1a> @ imm = #-0x2
700ac57a: 2001         	movs	r0, #0x1
;         r = true;
700ac57c: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ac580: e7ff         	b	0x700ac582 <Sciclient_rmIaIsIa+0x22> @ imm = #-0x2
;     return r;
700ac582: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ac586: f000 0001    	and	r0, r0, #0x1
700ac58a: b002         	add	sp, #0x8
700ac58c: bd80         	pop	{r7, pc}
700ac58e: 0000         	movs	r0, r0

700ac590 <Sciclient_rmIrIsIr>:
; {
700ac590: b580         	push	{r7, lr}
700ac592: b082         	sub	sp, #0x8
700ac594: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ac598: 2000         	movs	r0, #0x0
;     bool r = false;
700ac59a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIrGetInst(id) != NULL) {
700ac59e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac5a2: f7fd fa35    	bl	0x700a9a10 <Sciclient_rmIrGetInst> @ imm = #-0x2b96
700ac5a6: b120         	cbz	r0, 0x700ac5b2 <Sciclient_rmIrIsIr+0x22> @ imm = #0x8
700ac5a8: e7ff         	b	0x700ac5aa <Sciclient_rmIrIsIr+0x1a> @ imm = #-0x2
700ac5aa: 2001         	movs	r0, #0x1
;         r = true;
700ac5ac: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ac5b0: e7ff         	b	0x700ac5b2 <Sciclient_rmIrIsIr+0x22> @ imm = #-0x2
;     return r;
700ac5b2: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ac5b6: f000 0001    	and	r0, r0, #0x1
700ac5ba: b002         	add	sp, #0x8
700ac5bc: bd80         	pop	{r7, pc}
700ac5be: 0000         	movs	r0, r0

700ac5c0 <Sciclient_secProxyReadThread32>:
; {
700ac5c0: b580         	push	{r7, lr}
700ac5c2: b084         	sub	sp, #0x10
700ac5c4: 9003         	str	r0, [sp, #0xc]
700ac5c6: f88d 100b    	strb.w	r1, [sp, #0xb]
;     ret = CSL_REG32_RD(CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg,thread,0U) +
700ac5ca: 9903         	ldr	r1, [sp, #0xc]
700ac5cc: f240 00e8    	movw	r0, #0xe8
700ac5d0: f2c7 000b    	movt	r0, #0x700b
700ac5d4: 2200         	movs	r2, #0x0
700ac5d6: f000 fd83    	bl	0x700ad0e0 <CSL_secProxyGetDataAddr> @ imm = #0xb06
700ac5da: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700ac5de: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ac5e2: f001 f885    	bl	0x700ad6f0 <CSL_REG32_RD_RAW> @ imm = #0x110a
700ac5e6: 9001         	str	r0, [sp, #0x4]
;     return ret;
700ac5e8: 9801         	ldr	r0, [sp, #0x4]
700ac5ea: b004         	add	sp, #0x10
700ac5ec: bd80         	pop	{r7, pc}
700ac5ee: 0000         	movs	r0, r0

700ac5f0 <_is_digit>:
; {
700ac5f0: b082         	sub	sp, #0x8
700ac5f2: f88d 0007    	strb.w	r0, [sp, #0x7]
;   return (ch >= '0') && (ch <= '9');
700ac5f6: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ac5fa: 2000         	movs	r0, #0x0
700ac5fc: 2930         	cmp	r1, #0x30
700ac5fe: 9000         	str	r0, [sp]
700ac600: db08         	blt	0x700ac614 <_is_digit+0x24> @ imm = #0x10
700ac602: e7ff         	b	0x700ac604 <_is_digit+0x14> @ imm = #-0x2
700ac604: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ac608: 2000         	movs	r0, #0x0
700ac60a: 293a         	cmp	r1, #0x3a
700ac60c: bfb8         	it	lt
700ac60e: 2001         	movlt	r0, #0x1
700ac610: 9000         	str	r0, [sp]
700ac612: e7ff         	b	0x700ac614 <_is_digit+0x24> @ imm = #-0x2
700ac614: 9800         	ldr	r0, [sp]
;   return (ch >= '0') && (ch <= '9');
700ac616: f000 0001    	and	r0, r0, #0x1
700ac61a: b002         	add	sp, #0x8
700ac61c: 4770         	bx	lr
700ac61e: 0000         	movs	r0, r0

700ac620 <prvIsQueueFull>:
; {
700ac620: b580         	push	{r7, lr}
700ac622: b082         	sub	sp, #0x8
700ac624: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700ac626: f7ff fee3    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #-0x23a
;         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
700ac62a: 9801         	ldr	r0, [sp, #0x4]
700ac62c: 6b80         	ldr	r0, [r0, #0x38]
700ac62e: 9901         	ldr	r1, [sp, #0x4]
700ac630: 6bc9         	ldr	r1, [r1, #0x3c]
700ac632: 4288         	cmp	r0, r1
700ac634: d103         	bne	0x700ac63e <prvIsQueueFull+0x1e> @ imm = #0x6
700ac636: e7ff         	b	0x700ac638 <prvIsQueueFull+0x18> @ imm = #-0x2
700ac638: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700ac63a: 9000         	str	r0, [sp]
;         }
700ac63c: e002         	b	0x700ac644 <prvIsQueueFull+0x24> @ imm = #0x4
700ac63e: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700ac640: 9000         	str	r0, [sp]
700ac642: e7ff         	b	0x700ac644 <prvIsQueueFull+0x24> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700ac644: f7fe ffd4    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #-0x1058
;     return xReturn;
700ac648: 9800         	ldr	r0, [sp]
700ac64a: b002         	add	sp, #0x8
700ac64c: bd80         	pop	{r7, pc}
700ac64e: 0000         	movs	r0, r0

700ac650 <prvTaskCheckFreeStackSpace>:
; prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte) {
700ac650: b082         	sub	sp, #0x8
700ac652: 9001         	str	r0, [sp, #0x4]
700ac654: 2000         	movs	r0, #0x0
;   uint32_t ulCount = 0U;
700ac656: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700ac658: e7ff         	b	0x700ac65a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x2
700ac65a: 9801         	ldr	r0, [sp, #0x4]
700ac65c: 7800         	ldrb	r0, [r0]
700ac65e: 28a5         	cmp	r0, #0xa5
700ac660: d107         	bne	0x700ac672 <prvTaskCheckFreeStackSpace+0x22> @ imm = #0xe
700ac662: e7ff         	b	0x700ac664 <prvTaskCheckFreeStackSpace+0x14> @ imm = #-0x2
;     pucStackByte -= portSTACK_GROWTH;
700ac664: 9801         	ldr	r0, [sp, #0x4]
700ac666: 3001         	adds	r0, #0x1
700ac668: 9001         	str	r0, [sp, #0x4]
;     ulCount++;
700ac66a: 9800         	ldr	r0, [sp]
700ac66c: 3001         	adds	r0, #0x1
700ac66e: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700ac670: e7f3         	b	0x700ac65a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x1a
;   ulCount /=
700ac672: 9800         	ldr	r0, [sp]
700ac674: 0880         	lsrs	r0, r0, #0x2
700ac676: 9000         	str	r0, [sp]
;   return (configSTACK_DEPTH_TYPE)ulCount;
700ac678: 9800         	ldr	r0, [sp]
700ac67a: b002         	add	sp, #0x8
700ac67c: 4770         	bx	lr
700ac67e: 0000         	movs	r0, r0

700ac680 <vListInitialise>:
; {
700ac680: b081         	sub	sp, #0x4
700ac682: 9000         	str	r0, [sp]
;     pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ac684: 9900         	ldr	r1, [sp]
700ac686: f101 0008    	add.w	r0, r1, #0x8
700ac68a: 6048         	str	r0, [r1, #0x4]
;     pxList->xListEnd.xItemValue = portMAX_DELAY;
700ac68c: 9900         	ldr	r1, [sp]
700ac68e: f04f 30ff    	mov.w	r0, #0xffffffff
700ac692: 6088         	str	r0, [r1, #0x8]
;     pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ac694: 9900         	ldr	r1, [sp]
700ac696: f101 0008    	add.w	r0, r1, #0x8
700ac69a: 60c8         	str	r0, [r1, #0xc]
;     pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700ac69c: 9900         	ldr	r1, [sp]
700ac69e: f101 0008    	add.w	r0, r1, #0x8
700ac6a2: 6108         	str	r0, [r1, #0x10]
;     pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
700ac6a4: 9900         	ldr	r1, [sp]
700ac6a6: 2000         	movs	r0, #0x0
700ac6a8: 6008         	str	r0, [r1]
; }
700ac6aa: b001         	add	sp, #0x4
700ac6ac: 4770         	bx	lr
700ac6ae: 0000         	movs	r0, r0

700ac6b0 <CSL_bcdmaGetRxRT>:
; {
700ac6b0: b580         	push	{r7, lr}
700ac6b2: b084         	sub	sp, #0x10
700ac6b4: 9003         	str	r0, [sp, #0xc]
700ac6b6: 9102         	str	r1, [sp, #0x8]
700ac6b8: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700ac6ba: 9803         	ldr	r0, [sp, #0xc]
700ac6bc: 9a02         	ldr	r2, [sp, #0x8]
700ac6be: 9b01         	ldr	r3, [sp, #0x4]
700ac6c0: 2107         	movs	r1, #0x7
700ac6c2: f7fc fbad    	bl	0x700a8e20 <CSL_bcdmaDoChanOp> @ imm = #-0x38a6
700ac6c6: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ac6c8: 9800         	ldr	r0, [sp]
700ac6ca: b120         	cbz	r0, 0x700ac6d6 <CSL_bcdmaGetRxRT+0x26> @ imm = #0x8
700ac6cc: e7ff         	b	0x700ac6ce <CSL_bcdmaGetRxRT+0x1e> @ imm = #-0x2
700ac6ce: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ac6d2: 9000         	str	r0, [sp]
;     }
700ac6d4: e7ff         	b	0x700ac6d6 <CSL_bcdmaGetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700ac6d6: 9800         	ldr	r0, [sp]
700ac6d8: b004         	add	sp, #0x10
700ac6da: bd80         	pop	{r7, pc}
700ac6dc: 0000         	movs	r0, r0
700ac6de: 0000         	movs	r0, r0

700ac6e0 <CSL_bcdmaGetTxRT>:
; {
700ac6e0: b580         	push	{r7, lr}
700ac6e2: b084         	sub	sp, #0x10
700ac6e4: 9003         	str	r0, [sp, #0xc]
700ac6e6: 9102         	str	r1, [sp, #0x8]
700ac6e8: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700ac6ea: 9803         	ldr	r0, [sp, #0xc]
700ac6ec: 9a02         	ldr	r2, [sp, #0x8]
700ac6ee: 9b01         	ldr	r3, [sp, #0x4]
700ac6f0: 2107         	movs	r1, #0x7
700ac6f2: f7fc fb95    	bl	0x700a8e20 <CSL_bcdmaDoChanOp> @ imm = #-0x38d6
700ac6f6: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ac6f8: 9800         	ldr	r0, [sp]
700ac6fa: b120         	cbz	r0, 0x700ac706 <CSL_bcdmaGetTxRT+0x26> @ imm = #0x8
700ac6fc: e7ff         	b	0x700ac6fe <CSL_bcdmaGetTxRT+0x1e> @ imm = #-0x2
700ac6fe: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ac702: 9000         	str	r0, [sp]
;     }
700ac704: e7ff         	b	0x700ac706 <CSL_bcdmaGetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700ac706: 9800         	ldr	r0, [sp]
700ac708: b004         	add	sp, #0x10
700ac70a: bd80         	pop	{r7, pc}
700ac70c: 0000         	movs	r0, r0
700ac70e: 0000         	movs	r0, r0

700ac710 <CSL_bcdmaSetRxRT>:
; {
700ac710: b580         	push	{r7, lr}
700ac712: b084         	sub	sp, #0x10
700ac714: 9003         	str	r0, [sp, #0xc]
700ac716: 9102         	str	r1, [sp, #0x8]
700ac718: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700ac71a: 9803         	ldr	r0, [sp, #0xc]
700ac71c: 9a02         	ldr	r2, [sp, #0x8]
700ac71e: 9b01         	ldr	r3, [sp, #0x4]
700ac720: 2108         	movs	r1, #0x8
700ac722: f7fc fb7d    	bl	0x700a8e20 <CSL_bcdmaDoChanOp> @ imm = #-0x3906
700ac726: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ac728: 9800         	ldr	r0, [sp]
700ac72a: b120         	cbz	r0, 0x700ac736 <CSL_bcdmaSetRxRT+0x26> @ imm = #0x8
700ac72c: e7ff         	b	0x700ac72e <CSL_bcdmaSetRxRT+0x1e> @ imm = #-0x2
700ac72e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ac732: 9000         	str	r0, [sp]
;     }
700ac734: e7ff         	b	0x700ac736 <CSL_bcdmaSetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700ac736: 9800         	ldr	r0, [sp]
700ac738: b004         	add	sp, #0x10
700ac73a: bd80         	pop	{r7, pc}
700ac73c: 0000         	movs	r0, r0
700ac73e: 0000         	movs	r0, r0

700ac740 <CSL_bcdmaSetTxRT>:
; {
700ac740: b580         	push	{r7, lr}
700ac742: b084         	sub	sp, #0x10
700ac744: 9003         	str	r0, [sp, #0xc]
700ac746: 9102         	str	r1, [sp, #0x8]
700ac748: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700ac74a: 9803         	ldr	r0, [sp, #0xc]
700ac74c: 9a02         	ldr	r2, [sp, #0x8]
700ac74e: 9b01         	ldr	r3, [sp, #0x4]
700ac750: 2108         	movs	r1, #0x8
700ac752: f7fc fb65    	bl	0x700a8e20 <CSL_bcdmaDoChanOp> @ imm = #-0x3936
700ac756: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700ac758: 9800         	ldr	r0, [sp]
700ac75a: b120         	cbz	r0, 0x700ac766 <CSL_bcdmaSetTxRT+0x26> @ imm = #0x8
700ac75c: e7ff         	b	0x700ac75e <CSL_bcdmaSetTxRT+0x1e> @ imm = #-0x2
700ac75e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ac762: 9000         	str	r0, [sp]
;     }
700ac764: e7ff         	b	0x700ac766 <CSL_bcdmaSetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700ac766: 9800         	ldr	r0, [sp]
700ac768: b004         	add	sp, #0x10
700ac76a: bd80         	pop	{r7, pc}
700ac76c: 0000         	movs	r0, r0
700ac76e: 0000         	movs	r0, r0

700ac770 <DebugP_logZoneEnable>:
; {
700ac770: b580         	push	{r7, lr}
700ac772: b084         	sub	sp, #0x10
700ac774: 9003         	str	r0, [sp, #0xc]
;     oldIntState = HwiP_disable();
700ac776: f001 ee0c    	blx	0x700ae390 <HwiP_disable> @ imm = #0x1c18
700ac77a: 9001         	str	r0, [sp, #0x4]
;     oldZoneMask = gDebugLogZone;
700ac77c: f240 11a0    	movw	r1, #0x1a0
700ac780: f2c7 010b    	movt	r1, #0x700b
700ac784: 6808         	ldr	r0, [r1]
700ac786: 9002         	str	r0, [sp, #0x8]
;     gDebugLogZone = gDebugLogZone | (logZoneMask);
700ac788: 6808         	ldr	r0, [r1]
700ac78a: 9a03         	ldr	r2, [sp, #0xc]
700ac78c: 4310         	orrs	r0, r2
700ac78e: 6008         	str	r0, [r1]
;     HwiP_restore(oldIntState);
700ac790: 9801         	ldr	r0, [sp, #0x4]
700ac792: f001 ee1e    	blx	0x700ae3d0 <HwiP_restore> @ imm = #0x1c3c
;     return oldZoneMask;
700ac796: 9802         	ldr	r0, [sp, #0x8]
700ac798: b004         	add	sp, #0x10
700ac79a: bd80         	pop	{r7, pc}
700ac79c: 0000         	movs	r0, r0
700ac79e: 0000         	movs	r0, r0

700ac7a0 <Sciclient_getIrAddr>:
; {
700ac7a0: b580         	push	{r7, lr}
700ac7a2: b084         	sub	sp, #0x10
700ac7a4: 9003         	str	r0, [sp, #0xc]
700ac7a6: 9102         	str	r1, [sp, #0x8]
;     int_ctrl_reg = (uint32_t *)(addr + Sciclient_rmIrIntControlReg(i));
700ac7a8: 9803         	ldr	r0, [sp, #0xc]
700ac7aa: 9000         	str	r0, [sp]
700ac7ac: f8bd 0008    	ldrh.w	r0, [sp, #0x8]
700ac7b0: f000 fe56    	bl	0x700ad460 <Sciclient_rmIrIntControlReg> @ imm = #0xcac
700ac7b4: 4601         	mov	r1, r0
700ac7b6: 9800         	ldr	r0, [sp]
700ac7b8: 4408         	add	r0, r1
700ac7ba: 9001         	str	r0, [sp, #0x4]
;     int_ctrl_reg = (uint32_t *)AddrTranslateP_getLocalAddr( (uint64_t)int_ctrl_reg);
700ac7bc: 9801         	ldr	r0, [sp, #0x4]
700ac7be: 2100         	movs	r1, #0x0
700ac7c0: f7f7 fa3e    	bl	0x700a3c40 <AddrTranslateP_getLocalAddr> @ imm = #-0x8b84
700ac7c4: 9001         	str	r0, [sp, #0x4]
;     return int_ctrl_reg;
700ac7c6: 9801         	ldr	r0, [sp, #0x4]
700ac7c8: b004         	add	sp, #0x10
700ac7ca: bd80         	pop	{r7, pc}
700ac7cc: 0000         	movs	r0, r0
700ac7ce: 0000         	movs	r0, r0

700ac7d0 <TaskP_calcCounterDiff>:
; {
700ac7d0: b083         	sub	sp, #0xc
700ac7d2: 9002         	str	r0, [sp, #0x8]
700ac7d4: 9101         	str	r1, [sp, #0x4]
;     if(cur >= last)
700ac7d6: 9802         	ldr	r0, [sp, #0x8]
700ac7d8: 9901         	ldr	r1, [sp, #0x4]
700ac7da: 4288         	cmp	r0, r1
700ac7dc: d305         	blo	0x700ac7ea <TaskP_calcCounterDiff+0x1a> @ imm = #0xa
700ac7de: e7ff         	b	0x700ac7e0 <TaskP_calcCounterDiff+0x10> @ imm = #-0x2
;         delta = cur - last;
700ac7e0: 9802         	ldr	r0, [sp, #0x8]
700ac7e2: 9901         	ldr	r1, [sp, #0x4]
700ac7e4: 1a40         	subs	r0, r0, r1
700ac7e6: 9000         	str	r0, [sp]
;     }
700ac7e8: e005         	b	0x700ac7f6 <TaskP_calcCounterDiff+0x26> @ imm = #0xa
;         delta = (  0xFFFFFFFFU - last ) + cur;
700ac7ea: 9801         	ldr	r0, [sp, #0x4]
700ac7ec: 9902         	ldr	r1, [sp, #0x8]
700ac7ee: 43c0         	mvns	r0, r0
700ac7f0: 4408         	add	r0, r1
700ac7f2: 9000         	str	r0, [sp]
700ac7f4: e7ff         	b	0x700ac7f6 <TaskP_calcCounterDiff+0x26> @ imm = #-0x2
;     return delta;
700ac7f6: 9800         	ldr	r0, [sp]
700ac7f8: b003         	add	sp, #0xc
700ac7fa: 4770         	bx	lr
700ac7fc: 0000         	movs	r0, r0
700ac7fe: 0000         	movs	r0, r0

700ac800 <TimerP_clearOverflowInt>:
; {
700ac800: b083         	sub	sp, #0xc
700ac802: 9002         	str	r0, [sp, #0x8]
700ac804: 2002         	movs	r0, #0x2
;     uint32_t value = (0x1U << TIMER_OVF_INT_SHIFT);
700ac806: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_STATUS);
700ac808: 9802         	ldr	r0, [sp, #0x8]
700ac80a: 3028         	adds	r0, #0x28
700ac80c: 9001         	str	r0, [sp, #0x4]
;     *addr = value;
700ac80e: 9800         	ldr	r0, [sp]
700ac810: 9901         	ldr	r1, [sp, #0x4]
700ac812: 6008         	str	r0, [r1]
;     if((*addr & value) != 0U)
700ac814: 9801         	ldr	r0, [sp, #0x4]
700ac816: 6800         	ldr	r0, [r0]
700ac818: 9900         	ldr	r1, [sp]
700ac81a: 4208         	tst	r0, r1
700ac81c: d004         	beq	0x700ac828 <TimerP_clearOverflowInt+0x28> @ imm = #0x8
700ac81e: e7ff         	b	0x700ac820 <TimerP_clearOverflowInt+0x20> @ imm = #-0x2
;         *addr = value;
700ac820: 9800         	ldr	r0, [sp]
700ac822: 9901         	ldr	r1, [sp, #0x4]
700ac824: 6008         	str	r0, [r1]
;     }
700ac826: e7ff         	b	0x700ac828 <TimerP_clearOverflowInt+0x28> @ imm = #-0x2
; }
700ac828: b003         	add	sp, #0xc
700ac82a: 4770         	bx	lr
700ac82c: 0000         	movs	r0, r0
700ac82e: 0000         	movs	r0, r0

700ac830 <prvInitialiseMutex>:
;     {
700ac830: b580         	push	{r7, lr}
700ac832: b082         	sub	sp, #0x8
700ac834: 9001         	str	r0, [sp, #0x4]
;         if( pxNewQueue != NULL )
700ac836: 9801         	ldr	r0, [sp, #0x4]
700ac838: b168         	cbz	r0, 0x700ac856 <prvInitialiseMutex+0x26> @ imm = #0x1a
700ac83a: e7ff         	b	0x700ac83c <prvInitialiseMutex+0xc> @ imm = #-0x2
;             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
700ac83c: 9801         	ldr	r0, [sp, #0x4]
700ac83e: 2300         	movs	r3, #0x0
700ac840: 6083         	str	r3, [r0, #0x8]
;             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
700ac842: 9801         	ldr	r0, [sp, #0x4]
700ac844: 6003         	str	r3, [r0]
;             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
700ac846: 9801         	ldr	r0, [sp, #0x4]
700ac848: 60c3         	str	r3, [r0, #0xc]
;             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
700ac84a: 9801         	ldr	r0, [sp, #0x4]
700ac84c: 4619         	mov	r1, r3
700ac84e: 461a         	mov	r2, r3
700ac850: f7f4 fe5e    	bl	0x700a1510 <xQueueGenericSend> @ imm = #-0xb344
;         }
700ac854: e000         	b	0x700ac858 <prvInitialiseMutex+0x28> @ imm = #0x0
700ac856: e7ff         	b	0x700ac858 <prvInitialiseMutex+0x28> @ imm = #-0x2
;     }
700ac858: b002         	add	sp, #0x8
700ac85a: bd80         	pop	{r7, pc}
700ac85c: 0000         	movs	r0, r0
700ac85e: 0000         	movs	r0, r0

700ac860 <pvTaskIncrementMutexHeldCount>:
;   if (pxCurrentTCB != NULL) {
700ac860: f240 10cc    	movw	r0, #0x1cc
700ac864: f2c7 000b    	movt	r0, #0x700b
700ac868: 6800         	ldr	r0, [r0]
700ac86a: b148         	cbz	r0, 0x700ac880 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #0x12
700ac86c: e7ff         	b	0x700ac86e <pvTaskIncrementMutexHeldCount+0xe> @ imm = #-0x2
;     (pxCurrentTCB->uxMutexesHeld)++;
700ac86e: f240 10cc    	movw	r0, #0x1cc
700ac872: f2c7 000b    	movt	r0, #0x700b
700ac876: 6801         	ldr	r1, [r0]
700ac878: 6e48         	ldr	r0, [r1, #0x64]
700ac87a: 3001         	adds	r0, #0x1
700ac87c: 6648         	str	r0, [r1, #0x64]
;   }
700ac87e: e7ff         	b	0x700ac880 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #-0x2
;   return pxCurrentTCB;
700ac880: f240 10cc    	movw	r0, #0x1cc
700ac884: f2c7 000b    	movt	r0, #0x700b
700ac888: 6800         	ldr	r0, [r0]
700ac88a: 4770         	bx	lr
700ac88c: 0000         	movs	r0, r0
700ac88e: 0000         	movs	r0, r0

700ac890 <vApplicationGetIdleTaskMemory>:
;                                    uint32_t *pulIdleTaskStackSize) {
700ac890: b083         	sub	sp, #0xc
700ac892: 9002         	str	r0, [sp, #0x8]
700ac894: 9101         	str	r1, [sp, #0x4]
700ac896: 9200         	str	r2, [sp]
;   *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
700ac898: 9902         	ldr	r1, [sp, #0x8]
700ac89a: f644 40b0    	movw	r0, #0x4cb0
700ac89e: f2c7 0008    	movt	r0, #0x7008
700ac8a2: 6008         	str	r0, [r1]
;   *ppxIdleTaskStackBuffer = uxIdleTaskStack;
700ac8a4: 9901         	ldr	r1, [sp, #0x4]
700ac8a6: f242 0080    	movw	r0, #0x2080
700ac8aa: f2c7 0008    	movt	r0, #0x7008
700ac8ae: 6008         	str	r0, [r1]
;   *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
700ac8b0: 9900         	ldr	r1, [sp]
700ac8b2: f44f 6080    	mov.w	r0, #0x400
700ac8b6: 6008         	str	r0, [r1]
; }
700ac8b8: b003         	add	sp, #0xc
700ac8ba: 4770         	bx	lr
700ac8bc: 0000         	movs	r0, r0
700ac8be: 0000         	movs	r0, r0

700ac8c0 <vApplicationGetTimerTaskMemory>:
;                                     uint32_t *pulTimerTaskStackSize) {
700ac8c0: b083         	sub	sp, #0xc
700ac8c2: 9002         	str	r0, [sp, #0x8]
700ac8c4: 9101         	str	r1, [sp, #0x4]
700ac8c6: 9200         	str	r2, [sp]
;   *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
700ac8c8: 9902         	ldr	r1, [sp, #0x8]
700ac8ca: f644 503c    	movw	r0, #0x4d3c
700ac8ce: f2c7 0008    	movt	r0, #0x7008
700ac8d2: 6008         	str	r0, [r1]
;   *ppxTimerTaskStackBuffer = uxTimerTaskStack;
700ac8d4: 9901         	ldr	r1, [sp, #0x4]
700ac8d6: f643 508c    	movw	r0, #0x3d8c
700ac8da: f2c7 0008    	movt	r0, #0x7008
700ac8de: 6008         	str	r0, [r1]
;   *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
700ac8e0: 9900         	ldr	r1, [sp]
700ac8e2: f44f 7080    	mov.w	r0, #0x100
700ac8e6: 6008         	str	r0, [r1]
; }
700ac8e8: b003         	add	sp, #0xc
700ac8ea: 4770         	bx	lr
700ac8ec: 0000         	movs	r0, r0
700ac8ee: 0000         	movs	r0, r0

700ac8f0 <Sciclient_rmParamIsValid>:
; {
700ac8f0: b083         	sub	sp, #0xc
700ac8f2: 9002         	str	r0, [sp, #0x8]
700ac8f4: 9101         	str	r1, [sp, #0x4]
700ac8f6: 2000         	movs	r0, #0x0
;     bool r = false;
700ac8f8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((valid_params & param_mask) != 0) {
700ac8fc: 9802         	ldr	r0, [sp, #0x8]
700ac8fe: 9901         	ldr	r1, [sp, #0x4]
700ac900: 4208         	tst	r0, r1
700ac902: d004         	beq	0x700ac90e <Sciclient_rmParamIsValid+0x1e> @ imm = #0x8
700ac904: e7ff         	b	0x700ac906 <Sciclient_rmParamIsValid+0x16> @ imm = #-0x2
700ac906: 2001         	movs	r0, #0x1
;         r = true;
700ac908: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ac90c: e7ff         	b	0x700ac90e <Sciclient_rmParamIsValid+0x1e> @ imm = #-0x2
;     return r;
700ac90e: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ac912: f000 0001    	and	r0, r0, #0x1
700ac916: b003         	add	sp, #0xc
700ac918: 4770         	bx	lr
700ac91a: 0000         	movs	r0, r0
700ac91c: 0000         	movs	r0, r0
700ac91e: 0000         	movs	r0, r0

700ac920 <Sciclient_rmPsIsEmpty>:
; {
700ac920: b081         	sub	sp, #0x4
700ac922: 2001         	movs	r0, #0x1
;     bool e = true;
700ac924: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if (gPstack.psp != 0) {
700ac928: f241 0058    	movw	r0, #0x1058
700ac92c: f2c7 0008    	movt	r0, #0x7008
700ac930: 8c80         	ldrh	r0, [r0, #0x24]
700ac932: b120         	cbz	r0, 0x700ac93e <Sciclient_rmPsIsEmpty+0x1e> @ imm = #0x8
700ac934: e7ff         	b	0x700ac936 <Sciclient_rmPsIsEmpty+0x16> @ imm = #-0x2
700ac936: 2000         	movs	r0, #0x0
;         e = false;
700ac938: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ac93c: e7ff         	b	0x700ac93e <Sciclient_rmPsIsEmpty+0x1e> @ imm = #-0x2
;     return e;
700ac93e: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ac942: f000 0001    	and	r0, r0, #0x1
700ac946: b001         	add	sp, #0x4
700ac948: 4770         	bx	lr
700ac94a: 0000         	movs	r0, r0
700ac94c: 0000         	movs	r0, r0
700ac94e: 0000         	movs	r0, r0

700ac950 <UART_Transaction_init>:
; {
700ac950: b081         	sub	sp, #0x4
700ac952: 9000         	str	r0, [sp]
;     if(trans != NULL)
700ac954: 9800         	ldr	r0, [sp]
700ac956: b170         	cbz	r0, 0x700ac976 <UART_Transaction_init+0x26> @ imm = #0x1c
700ac958: e7ff         	b	0x700ac95a <UART_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700ac95a: 9900         	ldr	r1, [sp]
700ac95c: 2000         	movs	r0, #0x0
700ac95e: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700ac960: 9900         	ldr	r1, [sp]
700ac962: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = SystemP_WAIT_FOREVER;
700ac964: 9a00         	ldr	r2, [sp]
700ac966: f04f 31ff    	mov.w	r1, #0xffffffff
700ac96a: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700ac96c: 9900         	ldr	r1, [sp]
700ac96e: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700ac970: 9900         	ldr	r1, [sp]
700ac972: 6108         	str	r0, [r1, #0x10]
;     }
700ac974: e7ff         	b	0x700ac976 <UART_Transaction_init+0x26> @ imm = #-0x2
; }
700ac976: b001         	add	sp, #0x4
700ac978: 4770         	bx	lr
700ac97a: 0000         	movs	r0, r0
700ac97c: 0000         	movs	r0, r0
700ac97e: 0000         	movs	r0, r0

700ac980 <UART_intr2Disable>:
; {
700ac980: b580         	push	{r7, lr}
700ac982: b084         	sub	sp, #0x10
700ac984: 9003         	str	r0, [sp, #0xc]
700ac986: 9102         	str	r1, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_IER2, HW_RD_REG32(baseAddr + UART_IER2) &
700ac988: 9803         	ldr	r0, [sp, #0xc]
700ac98a: 306c         	adds	r0, #0x6c
700ac98c: 9001         	str	r0, [sp, #0x4]
700ac98e: f000 fe4f    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0xc9e
700ac992: 4601         	mov	r1, r0
700ac994: 9801         	ldr	r0, [sp, #0x4]
700ac996: 9b02         	ldr	r3, [sp, #0x8]
700ac998: f06f 0203    	mvn	r2, #0x3
700ac99c: ea62 0203    	orn	r2, r2, r3
700ac9a0: 4011         	ands	r1, r2
700ac9a2: f000 fe4d    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0xc9a
; }
700ac9a6: b004         	add	sp, #0x10
700ac9a8: bd80         	pop	{r7, pc}
700ac9aa: 0000         	movs	r0, r0
700ac9ac: 0000         	movs	r0, r0
700ac9ae: 0000         	movs	r0, r0

700ac9b0 <UART_lld_Transaction_init>:
; {
700ac9b0: b081         	sub	sp, #0x4
700ac9b2: 9000         	str	r0, [sp]
;     if(trans != NULL)
700ac9b4: 9800         	ldr	r0, [sp]
700ac9b6: b170         	cbz	r0, 0x700ac9d6 <UART_lld_Transaction_init+0x26> @ imm = #0x1c
700ac9b8: e7ff         	b	0x700ac9ba <UART_lld_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700ac9ba: 9900         	ldr	r1, [sp]
700ac9bc: 2000         	movs	r0, #0x0
700ac9be: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700ac9c0: 9900         	ldr	r1, [sp]
700ac9c2: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = UART_WAIT_FOREVER;
700ac9c4: 9a00         	ldr	r2, [sp]
700ac9c6: f04f 31ff    	mov.w	r1, #0xffffffff
700ac9ca: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700ac9cc: 9900         	ldr	r1, [sp]
700ac9ce: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700ac9d0: 9900         	ldr	r1, [sp]
700ac9d2: 6108         	str	r0, [r1, #0x10]
;     }
700ac9d4: e7ff         	b	0x700ac9d6 <UART_lld_Transaction_init+0x26> @ imm = #-0x2
; }
700ac9d6: b001         	add	sp, #0x4
700ac9d8: 4770         	bx	lr
700ac9da: 0000         	movs	r0, r0
700ac9dc: 0000         	movs	r0, r0
700ac9de: 0000         	movs	r0, r0

700ac9e0 <UART_lld_dmaWrite>:
; {
700ac9e0: b580         	push	{r7, lr}
700ac9e2: b084         	sub	sp, #0x10
700ac9e4: 9003         	str	r0, [sp, #0xc]
700ac9e6: 9102         	str	r1, [sp, #0x8]
700ac9e8: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ac9ea: 9001         	str	r0, [sp, #0x4]
;     status = UART_udmaConfigPdmaTx(hUart, transaction);
700ac9ec: 9803         	ldr	r0, [sp, #0xc]
700ac9ee: 9902         	ldr	r1, [sp, #0x8]
700ac9f0: f7f7 fd36    	bl	0x700a4460 <UART_udmaConfigPdmaTx> @ imm = #-0x8594
700ac9f4: 9001         	str	r0, [sp, #0x4]
;     if (status != UDMA_SOK)
700ac9f6: 9801         	ldr	r0, [sp, #0x4]
700ac9f8: b120         	cbz	r0, 0x700aca04 <UART_lld_dmaWrite+0x24> @ imm = #0x8
700ac9fa: e7ff         	b	0x700ac9fc <UART_lld_dmaWrite+0x1c> @ imm = #-0x2
700ac9fc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700aca00: 9001         	str	r0, [sp, #0x4]
;     }
700aca02: e7ff         	b	0x700aca04 <UART_lld_dmaWrite+0x24> @ imm = #-0x2
;     return status;
700aca04: 9801         	ldr	r0, [sp, #0x4]
700aca06: b004         	add	sp, #0x10
700aca08: bd80         	pop	{r7, pc}
700aca0a: 0000         	movs	r0, r0
700aca0c: 0000         	movs	r0, r0
700aca0e: 0000         	movs	r0, r0

700aca10 <UART_operatingModeSelect>:
; {
700aca10: b580         	push	{r7, lr}
700aca12: b084         	sub	sp, #0x10
700aca14: 9003         	str	r0, [sp, #0xc]
700aca16: 9102         	str	r1, [sp, #0x8]
;     operMode = HW_RD_REG32(baseAddr + UART_MDR1) & UART_MDR1_MODE_SELECT_MASK;
700aca18: 9803         	ldr	r0, [sp, #0xc]
700aca1a: 3020         	adds	r0, #0x20
700aca1c: f000 fe08    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0xc10
700aca20: f000 0007    	and	r0, r0, #0x7
700aca24: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_MDR1, UART_MDR1_MODE_SELECT,
700aca26: 9803         	ldr	r0, [sp, #0xc]
700aca28: 3020         	adds	r0, #0x20
700aca2a: 9b02         	ldr	r3, [sp, #0x8]
700aca2c: 2107         	movs	r1, #0x7
700aca2e: 2200         	movs	r2, #0x0
700aca30: f7ff fc7e    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #-0x704
;     return operMode;
700aca34: 9801         	ldr	r0, [sp, #0x4]
700aca36: b004         	add	sp, #0x10
700aca38: bd80         	pop	{r7, pc}
700aca3a: 0000         	movs	r0, r0
700aca3c: 0000         	movs	r0, r0
700aca3e: 0000         	movs	r0, r0

700aca40 <Udma_eventProgramSteering>:
; {
700aca40: b084         	sub	sp, #0x10
700aca42: 9003         	str	r0, [sp, #0xc]
700aca44: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700aca46: 9802         	ldr	r0, [sp, #0x8]
700aca48: 3008         	adds	r0, #0x8
700aca4a: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700aca4c: 9800         	ldr	r0, [sp]
700aca4e: 6800         	ldr	r0, [r0]
700aca50: 2803         	cmp	r0, #0x3
700aca52: d108         	bne	0x700aca66 <Udma_eventProgramSteering+0x26> @ imm = #0x10
700aca54: e7ff         	b	0x700aca56 <Udma_eventProgramSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700aca56: 9800         	ldr	r0, [sp]
700aca58: 6880         	ldr	r0, [r0, #0x8]
700aca5a: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = TRUE;
700aca5c: 9901         	ldr	r1, [sp, #0x4]
700aca5e: 2001         	movs	r0, #0x1
700aca60: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700aca64: e7ff         	b	0x700aca66 <Udma_eventProgramSteering+0x26> @ imm = #-0x2
;     return;
700aca66: b004         	add	sp, #0x10
700aca68: 4770         	bx	lr
700aca6a: 0000         	movs	r0, r0
700aca6c: 0000         	movs	r0, r0
700aca6e: 0000         	movs	r0, r0

700aca70 <Udma_eventResetSteering>:
; {
700aca70: b084         	sub	sp, #0x10
700aca72: 9003         	str	r0, [sp, #0xc]
700aca74: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700aca76: 9802         	ldr	r0, [sp, #0x8]
700aca78: 3008         	adds	r0, #0x8
700aca7a: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700aca7c: 9800         	ldr	r0, [sp]
700aca7e: 6800         	ldr	r0, [r0]
700aca80: 2803         	cmp	r0, #0x3
700aca82: d108         	bne	0x700aca96 <Udma_eventResetSteering+0x26> @ imm = #0x10
700aca84: e7ff         	b	0x700aca86 <Udma_eventResetSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700aca86: 9800         	ldr	r0, [sp]
700aca88: 6880         	ldr	r0, [r0, #0x8]
700aca8a: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = FALSE;
700aca8c: 9901         	ldr	r1, [sp, #0x4]
700aca8e: 2000         	movs	r0, #0x0
700aca90: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700aca94: e7ff         	b	0x700aca96 <Udma_eventResetSteering+0x26> @ imm = #-0x2
;     return;
700aca96: b004         	add	sp, #0x10
700aca98: 4770         	bx	lr
700aca9a: 0000         	movs	r0, r0
700aca9c: 0000         	movs	r0, r0
700aca9e: 0000         	movs	r0, r0

700acaa0 <Sciclient_secProxyVerifyThread>:
; {
700acaa0: b580         	push	{r7, lr}
700acaa2: b082         	sub	sp, #0x8
700acaa4: 9001         	str	r0, [sp, #0x4]
700acaa6: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700acaa8: 9000         	str	r0, [sp]
;     if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700acaaa: 9801         	ldr	r0, [sp, #0x4]
700acaac: f000 fba8    	bl	0x700ad200 <Sciclient_secProxyThreadStatusReg> @ imm = #0x750
700acab0: f000 fe1e    	bl	0x700ad6f0 <CSL_REG32_RD_RAW> @ imm = #0xc3c
700acab4: 0fc0         	lsrs	r0, r0, #0x1f
700acab6: b120         	cbz	r0, 0x700acac2 <Sciclient_secProxyVerifyThread+0x22> @ imm = #0x8
700acab8: e7ff         	b	0x700acaba <Sciclient_secProxyVerifyThread+0x1a> @ imm = #-0x2
700acaba: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700acabe: 9000         	str	r0, [sp]
;     }
700acac0: e7ff         	b	0x700acac2 <Sciclient_secProxyVerifyThread+0x22> @ imm = #-0x2
;     return status;
700acac2: 9800         	ldr	r0, [sp]
700acac4: b002         	add	sp, #0x8
700acac6: bd80         	pop	{r7, pc}
		...

700acad0 <prvIsQueueEmpty>:
; {
700acad0: b580         	push	{r7, lr}
700acad2: b082         	sub	sp, #0x8
700acad4: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700acad6: f7ff fc8b    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #-0x6ea
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
700acada: 9801         	ldr	r0, [sp, #0x4]
700acadc: 6b80         	ldr	r0, [r0, #0x38]
700acade: b918         	cbnz	r0, 0x700acae8 <prvIsQueueEmpty+0x18> @ imm = #0x6
700acae0: e7ff         	b	0x700acae2 <prvIsQueueEmpty+0x12> @ imm = #-0x2
700acae2: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700acae4: 9000         	str	r0, [sp]
;         }
700acae6: e002         	b	0x700acaee <prvIsQueueEmpty+0x1e> @ imm = #0x4
700acae8: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700acaea: 9000         	str	r0, [sp]
700acaec: e7ff         	b	0x700acaee <prvIsQueueEmpty+0x1e> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700acaee: f7fe fd7f    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #-0x1502
;     return xReturn;
700acaf2: 9800         	ldr	r0, [sp]
700acaf4: b002         	add	sp, #0x8
700acaf6: bd80         	pop	{r7, pc}
		...

700acb00 <vQueueDelete>:
; {
700acb00: b580         	push	{r7, lr}
700acb02: b082         	sub	sp, #0x8
700acb04: 9001         	str	r0, [sp, #0x4]
;     Queue_t * const pxQueue = xQueue;
700acb06: 9801         	ldr	r0, [sp, #0x4]
700acb08: 9000         	str	r0, [sp]
;             vQueueUnregisterQueue( pxQueue );
700acb0a: 9800         	ldr	r0, [sp]
700acb0c: f7fe f918    	bl	0x700aad40 <vQueueUnregisterQueue> @ imm = #-0x1dd0
;             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
700acb10: 9800         	ldr	r0, [sp]
700acb12: f890 0046    	ldrb.w	r0, [r0, #0x46]
700acb16: b920         	cbnz	r0, 0x700acb22 <vQueueDelete+0x22> @ imm = #0x8
700acb18: e7ff         	b	0x700acb1a <vQueueDelete+0x1a> @ imm = #-0x2
;                 vPortFree( pxQueue );
700acb1a: 9800         	ldr	r0, [sp]
700acb1c: f000 fa20    	bl	0x700acf60 <vPortFree>  @ imm = #0x440
;             }
700acb20: e000         	b	0x700acb24 <vQueueDelete+0x24> @ imm = #0x0
700acb22: e7ff         	b	0x700acb24 <vQueueDelete+0x24> @ imm = #-0x2
; }
700acb24: b002         	add	sp, #0x8
700acb26: bd80         	pop	{r7, pc}
		...

700acb30 <vprintf_>:
; {
700acb30: b580         	push	{r7, lr}
700acb32: b084         	sub	sp, #0x10
700acb34: 9103         	str	r1, [sp, #0xc]
700acb36: 9002         	str	r0, [sp, #0x8]
;   return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
700acb38: 9b02         	ldr	r3, [sp, #0x8]
700acb3a: 9803         	ldr	r0, [sp, #0xc]
700acb3c: 4669         	mov	r1, sp
700acb3e: 6008         	str	r0, [r1]
700acb40: f64c 50f1    	movw	r0, #0xcdf1
700acb44: f2c7 000a    	movt	r0, #0x700a
700acb48: f10d 0107    	add.w	r1, sp, #0x7
700acb4c: f04f 32ff    	mov.w	r2, #0xffffffff
700acb50: f7ec fa56    	bl	0x70099000 <_vsnprintf> @ imm = #-0x13b54
700acb54: b004         	add	sp, #0x10
700acb56: bd80         	pop	{r7, pc}
		...

700acb60 <UART_udmapSetReturnPolicy>:
; {
700acb60: b580         	push	{r7, lr}
700acb62: b086         	sub	sp, #0x18
700acb64: 9005         	str	r0, [sp, #0x14]
700acb66: 9104         	str	r1, [sp, #0x10]
700acb68: 2001         	movs	r0, #0x1
;         uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700acb6a: 9003         	str	r0, [sp, #0xc]
;         CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700acb6c: 9804         	ldr	r0, [sp, #0x10]
700acb6e: 9002         	str	r0, [sp, #0x8]
;         pHpd,
700acb70: 9802         	ldr	r0, [sp, #0x8]
;         descType,
700acb72: 9903         	ldr	r1, [sp, #0xc]
;         CSL_udmapCppi5SetReturnPolicy(
700acb74: 466a         	mov	r2, sp
700acb76: 2300         	movs	r3, #0x0
700acb78: 6053         	str	r3, [r2, #0x4]
700acb7a: 6013         	str	r3, [r2]
700acb7c: 461a         	mov	r2, r3
700acb7e: f7fb fd6f    	bl	0x700a8660 <CSL_udmapCppi5SetReturnPolicy> @ imm = #-0x4522
;         return;
700acb82: b006         	add	sp, #0x18
700acb84: bd80         	pop	{r7, pc}
		...
700acb8e: 0000         	movs	r0, r0

700acb90 <Udma_ringGetForwardRingOcc>:
; {
700acb90: b580         	push	{r7, lr}
700acb92: b084         	sub	sp, #0x10
700acb94: 9003         	str	r0, [sp, #0xc]
700acb96: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700acb98: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700acb9a: 9803         	ldr	r0, [sp, #0xc]
700acb9c: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700acb9e: 9801         	ldr	r0, [sp, #0x4]
700acba0: 6800         	ldr	r0, [r0]
700acba2: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetForwardRingOcc(ringHandleInt);
700acba4: 9800         	ldr	r0, [sp]
700acba6: f8d0 15a8    	ldr.w	r1, [r0, #0x5a8]
700acbaa: 9801         	ldr	r0, [sp, #0x4]
700acbac: 4788         	blx	r1
700acbae: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700acbb0: 9802         	ldr	r0, [sp, #0x8]
700acbb2: b004         	add	sp, #0x10
700acbb4: bd80         	pop	{r7, pc}
		...
700acbbe: 0000         	movs	r0, r0

700acbc0 <Udma_ringGetReverseRingOcc>:
; {
700acbc0: b580         	push	{r7, lr}
700acbc2: b084         	sub	sp, #0x10
700acbc4: 9003         	str	r0, [sp, #0xc]
700acbc6: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700acbc8: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700acbca: 9803         	ldr	r0, [sp, #0xc]
700acbcc: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700acbce: 9801         	ldr	r0, [sp, #0x4]
700acbd0: 6800         	ldr	r0, [r0]
700acbd2: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetReverseRingOcc(ringHandleInt);
700acbd4: 9800         	ldr	r0, [sp]
700acbd6: f8d0 15ac    	ldr.w	r1, [r0, #0x5ac]
700acbda: 9801         	ldr	r0, [sp, #0x4]
700acbdc: 4788         	blx	r1
700acbde: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700acbe0: 9802         	ldr	r0, [sp, #0x8]
700acbe2: b004         	add	sp, #0x10
700acbe4: bd80         	pop	{r7, pc}
		...
700acbee: 0000         	movs	r0, r0

700acbf0 <_out_buffer>:
; {
700acbf0: b084         	sub	sp, #0x10
700acbf2: f88d 000f    	strb.w	r0, [sp, #0xf]
700acbf6: 9102         	str	r1, [sp, #0x8]
700acbf8: 9201         	str	r2, [sp, #0x4]
700acbfa: 9300         	str	r3, [sp]
;   if (idx < maxlen) {
700acbfc: 9801         	ldr	r0, [sp, #0x4]
700acbfe: 9900         	ldr	r1, [sp]
700acc00: 4288         	cmp	r0, r1
700acc02: d206         	bhs	0x700acc12 <_out_buffer+0x22> @ imm = #0xc
700acc04: e7ff         	b	0x700acc06 <_out_buffer+0x16> @ imm = #-0x2
;     ((char*)buffer)[idx] = character;
700acc06: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700acc0a: 9902         	ldr	r1, [sp, #0x8]
700acc0c: 9a01         	ldr	r2, [sp, #0x4]
700acc0e: 5488         	strb	r0, [r1, r2]
;   }
700acc10: e7ff         	b	0x700acc12 <_out_buffer+0x22> @ imm = #-0x2
; }
700acc12: b004         	add	sp, #0x10
700acc14: 4770         	bx	lr
		...
700acc1e: 0000         	movs	r0, r0

700acc20 <prvGetDisinheritPriorityAfterTimeout>:
;     {
700acc20: b082         	sub	sp, #0x8
700acc22: 9001         	str	r0, [sp, #0x4]
;         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
700acc24: 9801         	ldr	r0, [sp, #0x4]
700acc26: 6a40         	ldr	r0, [r0, #0x24]
700acc28: b138         	cbz	r0, 0x700acc3a <prvGetDisinheritPriorityAfterTimeout+0x1a> @ imm = #0xe
700acc2a: e7ff         	b	0x700acc2c <prvGetDisinheritPriorityAfterTimeout+0xc> @ imm = #-0x2
;             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
700acc2c: 9801         	ldr	r0, [sp, #0x4]
700acc2e: 6b00         	ldr	r0, [r0, #0x30]
700acc30: 6800         	ldr	r0, [r0]
700acc32: f1c0 0020    	rsb.w	r0, r0, #0x20
700acc36: 9000         	str	r0, [sp]
;         }
700acc38: e002         	b	0x700acc40 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #0x4
700acc3a: 2000         	movs	r0, #0x0
;             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
700acc3c: 9000         	str	r0, [sp]
700acc3e: e7ff         	b	0x700acc40 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #-0x2
;         return uxHighestPriorityOfWaitingTasks;
700acc40: 9800         	ldr	r0, [sp]
700acc42: b002         	add	sp, #0x8
700acc44: 4770         	bx	lr
		...
700acc4e: 0000         	movs	r0, r0

700acc50 <vTaskPlaceOnEventList>:
;                            const TickType_t xTicksToWait) {
700acc50: b580         	push	{r7, lr}
700acc52: b082         	sub	sp, #0x8
700acc54: 9001         	str	r0, [sp, #0x4]
700acc56: 9100         	str	r1, [sp]
;   vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
700acc58: 9801         	ldr	r0, [sp, #0x4]
700acc5a: f240 11cc    	movw	r1, #0x1cc
700acc5e: f2c7 010b    	movt	r1, #0x700b
700acc62: 6809         	ldr	r1, [r1]
700acc64: 3118         	adds	r1, #0x18
700acc66: f7fc fd13    	bl	0x700a9690 <vListInsert> @ imm = #-0x35da
;   prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
700acc6a: 9800         	ldr	r0, [sp]
700acc6c: 2101         	movs	r1, #0x1
700acc6e: f7f6 feef    	bl	0x700a3a50 <prvAddCurrentTaskToDelayedList> @ imm = #-0x9222
; }
700acc72: b002         	add	sp, #0x8
700acc74: bd80         	pop	{r7, pc}
		...
700acc7e: 0000         	movs	r0, r0

700acc80 <CSL_REG32_FEXT_RAW>:
; {
700acc80: b580         	push	{r7, lr}
700acc82: b084         	sub	sp, #0x10
700acc84: 9003         	str	r0, [sp, #0xc]
700acc86: 9102         	str	r1, [sp, #0x8]
700acc88: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700acc8a: 9803         	ldr	r0, [sp, #0xc]
700acc8c: f000 fd18    	bl	0x700ad6c0 <CSL_REG32_RD_RAW> @ imm = #0xa30
700acc90: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700acc92: 9800         	ldr	r0, [sp]
700acc94: 9902         	ldr	r1, [sp, #0x8]
700acc96: 4008         	ands	r0, r1
700acc98: 9901         	ldr	r1, [sp, #0x4]
700acc9a: 40c8         	lsrs	r0, r1
700acc9c: 9000         	str	r0, [sp]
;     return (regVal);
700acc9e: 9800         	ldr	r0, [sp]
700acca0: b004         	add	sp, #0x10
700acca2: bd80         	pop	{r7, pc}
		...

700accb0 <CSL_REG32_FEXT_RAW>:
; {
700accb0: b580         	push	{r7, lr}
700accb2: b084         	sub	sp, #0x10
700accb4: 9003         	str	r0, [sp, #0xc]
700accb6: 9102         	str	r1, [sp, #0x8]
700accb8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700accba: 9803         	ldr	r0, [sp, #0xc]
700accbc: f000 fd08    	bl	0x700ad6d0 <CSL_REG32_RD_RAW> @ imm = #0xa10
700accc0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700accc2: 9800         	ldr	r0, [sp]
700accc4: 9902         	ldr	r1, [sp, #0x8]
700accc6: 4008         	ands	r0, r1
700accc8: 9901         	ldr	r1, [sp, #0x4]
700accca: 40c8         	lsrs	r0, r1
700acccc: 9000         	str	r0, [sp]
;     return (regVal);
700accce: 9800         	ldr	r0, [sp]
700accd0: b004         	add	sp, #0x10
700accd2: bd80         	pop	{r7, pc}
		...

700acce0 <CSL_REG32_FEXT_RAW>:
; {
700acce0: b580         	push	{r7, lr}
700acce2: b084         	sub	sp, #0x10
700acce4: 9003         	str	r0, [sp, #0xc]
700acce6: 9102         	str	r1, [sp, #0x8]
700acce8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700accea: 9803         	ldr	r0, [sp, #0xc]
700accec: f000 fcf8    	bl	0x700ad6e0 <CSL_REG32_RD_RAW> @ imm = #0x9f0
700accf0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700accf2: 9800         	ldr	r0, [sp]
700accf4: 9902         	ldr	r1, [sp, #0x8]
700accf6: 4008         	ands	r0, r1
700accf8: 9901         	ldr	r1, [sp, #0x4]
700accfa: 40c8         	lsrs	r0, r1
700accfc: 9000         	str	r0, [sp]
;     return (regVal);
700accfe: 9800         	ldr	r0, [sp]
700acd00: b004         	add	sp, #0x10
700acd02: bd80         	pop	{r7, pc}
		...

700acd10 <CSL_REG32_FEXT_RAW>:
; {
700acd10: b580         	push	{r7, lr}
700acd12: b084         	sub	sp, #0x10
700acd14: 9003         	str	r0, [sp, #0xc]
700acd16: 9102         	str	r1, [sp, #0x8]
700acd18: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700acd1a: 9803         	ldr	r0, [sp, #0xc]
700acd1c: f000 fce8    	bl	0x700ad6f0 <CSL_REG32_RD_RAW> @ imm = #0x9d0
700acd20: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700acd22: 9800         	ldr	r0, [sp]
700acd24: 9902         	ldr	r1, [sp, #0x8]
700acd26: 4008         	ands	r0, r1
700acd28: 9901         	ldr	r1, [sp, #0x4]
700acd2a: 40c8         	lsrs	r0, r1
700acd2c: 9000         	str	r0, [sp]
;     return (regVal);
700acd2e: 9800         	ldr	r0, [sp]
700acd30: b004         	add	sp, #0x10
700acd32: bd80         	pop	{r7, pc}
		...

700acd40 <CSL_REG32_FEXT_RAW>:
; {
700acd40: b580         	push	{r7, lr}
700acd42: b084         	sub	sp, #0x10
700acd44: 9003         	str	r0, [sp, #0xc]
700acd46: 9102         	str	r1, [sp, #0x8]
700acd48: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700acd4a: 9803         	ldr	r0, [sp, #0xc]
700acd4c: f000 fcd8    	bl	0x700ad700 <CSL_REG32_RD_RAW> @ imm = #0x9b0
700acd50: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700acd52: 9800         	ldr	r0, [sp]
700acd54: 9902         	ldr	r1, [sp, #0x8]
700acd56: 4008         	ands	r0, r1
700acd58: 9901         	ldr	r1, [sp, #0x4]
700acd5a: 40c8         	lsrs	r0, r1
700acd5c: 9000         	str	r0, [sp]
;     return (regVal);
700acd5e: 9800         	ldr	r0, [sp]
700acd60: b004         	add	sp, #0x10
700acd62: bd80         	pop	{r7, pc}
		...

700acd70 <SOC_getSelfCpuClk>:
; {
700acd70: b580         	push	{r7, lr}
700acd72: b084         	sub	sp, #0x10
700acd74: 2000         	movs	r0, #0x0
;     uint64_t cpuClockRate = 0U;
700acd76: 9001         	str	r0, [sp, #0x4]
700acd78: 9003         	str	r0, [sp, #0xc]
700acd7a: 9002         	str	r0, [sp, #0x8]
;                     Sciclient_getSelfDevIdCore(),
700acd7c: f000 fcd8    	bl	0x700ad730 <Sciclient_getSelfDevIdCore> @ imm = #0x9b0
700acd80: 9901         	ldr	r1, [sp, #0x4]
700acd82: aa02         	add	r2, sp, #0x8
700acd84: f04f 33ff    	mov.w	r3, #0xffffffff
;     Sciclient_pmGetModuleClkFreq(
700acd88: f7fa f81a    	bl	0x700a6dc0 <Sciclient_pmGetModuleClkFreq> @ imm = #-0x5fcc
;     return cpuClockRate;
700acd8c: 9802         	ldr	r0, [sp, #0x8]
700acd8e: 9903         	ldr	r1, [sp, #0xc]
700acd90: b004         	add	sp, #0x10
700acd92: bd80         	pop	{r7, pc}
		...

700acda0 <UART_IsStopBitsValid>:
; {
700acda0: b082         	sub	sp, #0x8
700acda2: 9001         	str	r0, [sp, #0x4]
700acda4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700acda8: 9000         	str	r0, [sp]
;     if((stopBits == UART_STOPBITS_1) ||
700acdaa: 9801         	ldr	r0, [sp, #0x4]
700acdac: b120         	cbz	r0, 0x700acdb8 <UART_IsStopBitsValid+0x18> @ imm = #0x8
700acdae: e7ff         	b	0x700acdb0 <UART_IsStopBitsValid+0x10> @ imm = #-0x2
;         (stopBits == UART_STOPBITS_2))
700acdb0: 9801         	ldr	r0, [sp, #0x4]
;     if((stopBits == UART_STOPBITS_1) ||
700acdb2: 2801         	cmp	r0, #0x1
700acdb4: d103         	bne	0x700acdbe <UART_IsStopBitsValid+0x1e> @ imm = #0x6
700acdb6: e7ff         	b	0x700acdb8 <UART_IsStopBitsValid+0x18> @ imm = #-0x2
700acdb8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700acdba: 9000         	str	r0, [sp]
;     }
700acdbc: e7ff         	b	0x700acdbe <UART_IsStopBitsValid+0x1e> @ imm = #-0x2
;     return status;
700acdbe: 9800         	ldr	r0, [sp]
700acdc0: b002         	add	sp, #0x8
700acdc2: 4770         	bx	lr

700acdc4 <__aeabi_uldivmod>:
700acdc4: e92d4040     	push	{r6, lr}
700acdc8: e24dd010     	sub	sp, sp, #16
700acdcc: e28d6008     	add	r6, sp, #8
700acdd0: e58d6000     	str	r6, [sp]
700acdd4: ebffd7eb     	bl	0x700a2d88 <__udivmoddi4> @ imm = #-0xa054
700acdd8: e59d2008     	ldr	r2, [sp, #0x8]
700acddc: e59d300c     	ldr	r3, [sp, #0xc]
700acde0: e28dd010     	add	sp, sp, #16
700acde4: e8bd8040     	pop	{r6, pc}
		...

700acdf0 <_out_char>:
; {
700acdf0: b580         	push	{r7, lr}
700acdf2: b084         	sub	sp, #0x10
700acdf4: f88d 000f    	strb.w	r0, [sp, #0xf]
700acdf8: 9102         	str	r1, [sp, #0x8]
700acdfa: 9201         	str	r2, [sp, #0x4]
700acdfc: 9300         	str	r3, [sp]
;   if (character) {
700acdfe: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ace02: b128         	cbz	r0, 0x700ace10 <_out_char+0x20> @ imm = #0xa
700ace04: e7ff         	b	0x700ace06 <_out_char+0x16> @ imm = #-0x2
;     putchar_(character);
700ace06: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ace0a: f000 fb89    	bl	0x700ad520 <putchar_>   @ imm = #0x712
;   }
700ace0e: e7ff         	b	0x700ace10 <_out_char+0x20> @ imm = #-0x2
; }
700ace10: b004         	add	sp, #0x10
700ace12: bd80         	pop	{r7, pc}
		...

700ace20 <tm_memory_allocation_thread_0_entry>:
; {
700ace20: f644 74c8    	movw	r4, #0x4fc8
700ace24: f2c7 0408    	movt	r4, #0x7008
700ace28: bf00         	nop
700ace2a: bf00         	nop
700ace2c: bf00         	nop
700ace2e: bf00         	nop
;    *memory_ptr = pvPortMalloc(128);
700ace30: f04f 0080    	mov.w	r0, #0x80
700ace34: f000 f974    	bl	0x700ad120 <pvPortMalloc> @ imm = #0x2e8
;    vPortFree(memory_ptr);
700ace38: f000 f892    	bl	0x700acf60 <vPortFree>  @ imm = #0x124
;       tm_memory_allocation_counter++;
700ace3c: 6820         	ldr	r0, [r4]
700ace3e: 3001         	adds	r0, #0x1
700ace40: 6020         	str	r0, [r4]
;    while (1)
700ace42: e7f5         	b	0x700ace30 <tm_memory_allocation_thread_0_entry+0x10> @ imm = #-0x16
		...

700ace50 <vTaskInternalSetTimeOutState>:
; void vTaskInternalSetTimeOutState(TimeOut_t *const pxTimeOut) {
700ace50: b081         	sub	sp, #0x4
700ace52: 9000         	str	r0, [sp]
;   pxTimeOut->xOverflowCount = xNumOfOverflows;
700ace54: f240 2004    	movw	r0, #0x204
700ace58: f2c7 000b    	movt	r0, #0x700b
700ace5c: 6800         	ldr	r0, [r0]
700ace5e: 9900         	ldr	r1, [sp]
700ace60: 6008         	str	r0, [r1]
;   pxTimeOut->xTimeOnEntering = xTickCount;
700ace62: f240 2010    	movw	r0, #0x210
700ace66: f2c7 000b    	movt	r0, #0x700b
700ace6a: 6800         	ldr	r0, [r0]
700ace6c: 9900         	ldr	r1, [sp]
700ace6e: 6048         	str	r0, [r1, #0x4]
; }
700ace70: b001         	add	sp, #0x4
700ace72: 4770         	bx	lr
		...

700ace80 <Udma_rmTranslateCoreIntrInput>:
; {
700ace80: b083         	sub	sp, #0xc
700ace82: 9002         	str	r0, [sp, #0x8]
700ace84: 9101         	str	r1, [sp, #0x4]
700ace86: 2000         	movs	r0, #0x0
700ace88: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    irIntrNum = UDMA_INTR_INVALID;
700ace8c: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700ace8e: 9802         	ldr	r0, [sp, #0x8]
700ace90: 6800         	ldr	r0, [r0]
700ace92: b118         	cbz	r0, 0x700ace9c <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #0x6
700ace94: e7ff         	b	0x700ace96 <Udma_rmTranslateCoreIntrInput+0x16> @ imm = #-0x2
;         irIntrNum = coreIntrNum;
700ace96: 9801         	ldr	r0, [sp, #0x4]
700ace98: 9000         	str	r0, [sp]
;     }
700ace9a: e7ff         	b	0x700ace9c <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #-0x2
;     return (irIntrNum);
700ace9c: 9800         	ldr	r0, [sp]
700ace9e: b003         	add	sp, #0xc
700acea0: 4770         	bx	lr
		...
700aceae: 0000         	movs	r0, r0

700aceb0 <Udma_rmTranslateIrOutput>:
; {
700aceb0: b083         	sub	sp, #0xc
700aceb2: 9002         	str	r0, [sp, #0x8]
700aceb4: 9101         	str	r1, [sp, #0x4]
700aceb6: 2000         	movs	r0, #0x0
700aceb8: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    coreIntrNum = UDMA_INTR_INVALID;
700acebc: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700acebe: 9802         	ldr	r0, [sp, #0x8]
700acec0: 6800         	ldr	r0, [r0]
700acec2: b118         	cbz	r0, 0x700acecc <Udma_rmTranslateIrOutput+0x1c> @ imm = #0x6
700acec4: e7ff         	b	0x700acec6 <Udma_rmTranslateIrOutput+0x16> @ imm = #-0x2
;         coreIntrNum = irIntrNum;
700acec6: 9801         	ldr	r0, [sp, #0x4]
700acec8: 9000         	str	r0, [sp]
;     }
700aceca: e7ff         	b	0x700acecc <Udma_rmTranslateIrOutput+0x1c> @ imm = #-0x2
;     return (coreIntrNum);
700acecc: 9800         	ldr	r0, [sp]
700acece: b003         	add	sp, #0xc
700aced0: 4770         	bx	lr
		...
700acede: 0000         	movs	r0, r0

700acee0 <ClockP_usecToTicks>:
; {
700acee0: b580         	push	{r7, lr}
700acee2: b082         	sub	sp, #0x8
700acee4: 9101         	str	r1, [sp, #0x4]
700acee6: 9000         	str	r0, [sp]
;     return (uint32_t)(usecs / gClockCtrl.usecPerTick);
700acee8: 9800         	ldr	r0, [sp]
700aceea: 9901         	ldr	r1, [sp, #0x4]
700aceec: f644 6298    	movw	r2, #0x4e98
700acef0: f2c7 0208    	movt	r2, #0x7008
700acef4: 6892         	ldr	r2, [r2, #0x8]
700acef6: 2300         	movs	r3, #0x0
700acef8: f7ff ef64    	blx	0x700acdc4 <__aeabi_uldivmod> @ imm = #-0x138
700acefc: b002         	add	sp, #0x8
700acefe: bd80         	pop	{r7, pc}

700acf00 <HW_RD_FIELD32_RAW>:
; {
700acf00: b084         	sub	sp, #0x10
700acf02: 9003         	str	r0, [sp, #0xc]
700acf04: 9102         	str	r1, [sp, #0x8]
700acf06: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700acf08: 9803         	ldr	r0, [sp, #0xc]
700acf0a: 6800         	ldr	r0, [r0]
700acf0c: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700acf0e: 9800         	ldr	r0, [sp]
700acf10: 9902         	ldr	r1, [sp, #0x8]
700acf12: 4008         	ands	r0, r1
700acf14: 9901         	ldr	r1, [sp, #0x4]
700acf16: 40c8         	lsrs	r0, r1
700acf18: 9000         	str	r0, [sp]
;     return (regVal);
700acf1a: 9800         	ldr	r0, [sp]
700acf1c: b004         	add	sp, #0x10
700acf1e: 4770         	bx	lr

700acf20 <Sciclient_getRxThreadId>:
; {
700acf20: b082         	sub	sp, #0x8
700acf22: 9001         	str	r0, [sp, #0x4]
;     rxThread = gSciclientMap[contextId].respThreadId;
700acf24: 9801         	ldr	r0, [sp, #0x4]
700acf26: eb00 0140    	add.w	r1, r0, r0, lsl #1
700acf2a: f64e 5088    	movw	r0, #0xed88
700acf2e: f2c7 000a    	movt	r0, #0x700a
700acf32: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700acf36: 68c0         	ldr	r0, [r0, #0xc]
700acf38: 9000         	str	r0, [sp]
;     return rxThread;
700acf3a: 9800         	ldr	r0, [sp]
700acf3c: b002         	add	sp, #0x8
700acf3e: 4770         	bx	lr

700acf40 <Sciclient_getTxThreadId>:
; {
700acf40: b082         	sub	sp, #0x8
700acf42: 9001         	str	r0, [sp, #0x4]
;     txThread = gSciclientMap[contextId].reqLowPrioThreadId;
700acf44: 9801         	ldr	r0, [sp, #0x4]
700acf46: eb00 0140    	add.w	r1, r0, r0, lsl #1
700acf4a: f64e 5088    	movw	r0, #0xed88
700acf4e: f2c7 000a    	movt	r0, #0x700a
700acf52: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700acf56: 6880         	ldr	r0, [r0, #0x8]
700acf58: 9000         	str	r0, [sp]
;     return txThread;
700acf5a: 9800         	ldr	r0, [sp]
700acf5c: b002         	add	sp, #0x8
700acf5e: 4770         	bx	lr

700acf60 <vPortFree>:
; {
700acf60: b580         	push	{r7, lr}
700acf62: b082         	sub	sp, #0x8
700acf64: 9001         	str	r0, [sp, #0x4]
;     if( pv )
700acf66: 9801         	ldr	r0, [sp, #0x4]
700acf68: b140         	cbz	r0, 0x700acf7c <vPortFree+0x1c> @ imm = #0x10
700acf6a: e7ff         	b	0x700acf6c <vPortFree+0xc> @ imm = #-0x2
;         vTaskSuspendAll();
700acf6c: f000 fb88    	bl	0x700ad680 <vTaskSuspendAll> @ imm = #0x710
;             free( pv );
700acf70: 9801         	ldr	r0, [sp, #0x4]
700acf72: f7f1 ef0c    	blx	0x7009ed8c <free>       @ imm = #-0xe1e8
;         ( void ) xTaskResumeAll();
700acf76: f7f3 fddb    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0xc44a
;     }
700acf7a: e7ff         	b	0x700acf7c <vPortFree+0x1c> @ imm = #-0x2
; }
700acf7c: b002         	add	sp, #0x8
700acf7e: bd80         	pop	{r7, pc}

700acf80 <CSL_udmapCppi5SetEpiDataPresent>:
; {
700acf80: b082         	sub	sp, #0x8
700acf82: 9001         	str	r0, [sp, #0x4]
700acf84: f88d 1003    	strb.w	r1, [sp, #0x3]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_EINFO, (bEpiDataPresent==(bool)true) ? (uint32_t)1U : (uint32_t)0U );
700acf88: 9901         	ldr	r1, [sp, #0x4]
700acf8a: 6808         	ldr	r0, [r1]
700acf8c: f020 5000    	bic	r0, r0, #0x20000000
700acf90: f89d 2003    	ldrb.w	r2, [sp, #0x3]
700acf94: f362 705d    	bfi	r0, r2, #29, #1
700acf98: 6008         	str	r0, [r1]
; }
700acf9a: b002         	add	sp, #0x8
700acf9c: 4770         	bx	lr
700acf9e: 0000         	movs	r0, r0

700acfa0 <DebugP_memLogWriterInit>:
; {
700acfa0: b580         	push	{r7, lr}
700acfa2: b082         	sub	sp, #0x8
700acfa4: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     gDebugP_memTraceLogWriterSelfCoreName = SOC_getCoreName(selfCoreId);
700acfa8: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700acfac: f7ff f808    	bl	0x700abfc0 <SOC_getCoreName> @ imm = #-0xff0
700acfb0: f240 11b0    	movw	r1, #0x1b0
700acfb4: f2c7 010b    	movt	r1, #0x700b
700acfb8: 6008         	str	r0, [r1]
; }
700acfba: b002         	add	sp, #0x8
700acfbc: bd80         	pop	{r7, pc}
700acfbe: 0000         	movs	r0, r0

700acfc0 <Sciclient_rmPsGetIrqNode>:
; {
700acfc0: b081         	sub	sp, #0x4
700acfc2: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return gPstack.ps[index].p_n;
700acfc6: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700acfca: eb00 0140    	add.w	r1, r0, r0, lsl #1
700acfce: f241 0058    	movw	r0, #0x1058
700acfd2: f2c7 0008    	movt	r0, #0x7008
700acfd6: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700acfda: b001         	add	sp, #0x4
700acfdc: 4770         	bx	lr
700acfde: 0000         	movs	r0, r0

700acfe0 <Sciclient_rmPsInit>:
; {
700acfe0: b580         	push	{r7, lr}
700acfe2: b082         	sub	sp, #0x8
;     memset(&gPstack.ps[0], 0, sizeof(gPstack.ps));
700acfe4: f241 0058    	movw	r0, #0x1058
700acfe8: f2c7 0008    	movt	r0, #0x7008
700acfec: 9001         	str	r0, [sp, #0x4]
700acfee: 2124         	movs	r1, #0x24
700acff0: f7ec ed20    	blx	0x70099a34 <__aeabi_memclr8> @ imm = #-0x135c0
700acff4: 9901         	ldr	r1, [sp, #0x4]
700acff6: 2000         	movs	r0, #0x0
;     gPstack.psp = 0;
700acff8: 8488         	strh	r0, [r1, #0x24]
; }
700acffa: b002         	add	sp, #0x8
700acffc: bd80         	pop	{r7, pc}
700acffe: 0000         	movs	r0, r0

700ad000 <UART_breakCtl>:
; {
700ad000: b580         	push	{r7, lr}
700ad002: b082         	sub	sp, #0x8
700ad004: 9001         	str	r0, [sp, #0x4]
700ad006: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_BREAK_EN,
700ad008: 9801         	ldr	r0, [sp, #0x4]
700ad00a: 300c         	adds	r0, #0xc
700ad00c: 9900         	ldr	r1, [sp]
700ad00e: ea4f 1391    	lsr.w	r3, r1, #0x6
700ad012: 2140         	movs	r1, #0x40
700ad014: 2206         	movs	r2, #0x6
700ad016: f7ff f98b    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #-0xcea
; }
700ad01a: b002         	add	sp, #0x8
700ad01c: bd80         	pop	{r7, pc}
700ad01e: 0000         	movs	r0, r0

700ad020 <UART_lld_Transaction_deInit>:
; {
700ad020: b081         	sub	sp, #0x4
700ad022: 9000         	str	r0, [sp]
;     trans->buf              = NULL;
700ad024: 9900         	ldr	r1, [sp]
700ad026: 2000         	movs	r0, #0x0
700ad028: 6008         	str	r0, [r1]
;     trans->count            = 0U;
700ad02a: 9900         	ldr	r1, [sp]
700ad02c: 6048         	str	r0, [r1, #0x4]
;     trans->timeout          = 0U;
700ad02e: 9900         	ldr	r1, [sp]
700ad030: 6088         	str	r0, [r1, #0x8]
;     trans->status           = UART_STATUS_SUCCESS;
700ad032: 9900         	ldr	r1, [sp]
700ad034: 60c8         	str	r0, [r1, #0xc]
;     trans->args             = NULL;
700ad036: 9900         	ldr	r1, [sp]
700ad038: 6108         	str	r0, [r1, #0x10]
; }
700ad03a: b001         	add	sp, #0x4
700ad03c: 4770         	bx	lr
700ad03e: 0000         	movs	r0, r0

700ad040 <UART_writeInterrupt>:
; {
700ad040: b580         	push	{r7, lr}
700ad042: b084         	sub	sp, #0x10
700ad044: 9003         	str	r0, [sp, #0xc]
700ad046: 2000         	movs	r0, #0x0
;     int32_t     status = UART_STATUS_SUCCESS;
700ad048: 9002         	str	r0, [sp, #0x8]
;     baseAddr = hUart->baseAddr;
700ad04a: 9803         	ldr	r0, [sp, #0xc]
700ad04c: 6800         	ldr	r0, [r0]
700ad04e: 9001         	str	r0, [sp, #0x4]
;     UART_intrEnable(baseAddr, UART_INTR_THR);
700ad050: 9801         	ldr	r0, [sp, #0x4]
700ad052: 2102         	movs	r1, #0x2
700ad054: f7f7 f8b4    	bl	0x700a41c0 <UART_intrEnable> @ imm = #-0x8e98
;     return status;
700ad058: 9802         	ldr	r0, [sp, #0x8]
700ad05a: b004         	add	sp, #0x10
700ad05c: bd80         	pop	{r7, pc}
700ad05e: 0000         	movs	r0, r0

700ad060 <UdmaChPdmaPrms_init>:
; {
700ad060: b081         	sub	sp, #0x4
700ad062: 9000         	str	r0, [sp]
;     if(NULL_PTR != pdmaPrms)
700ad064: 9800         	ldr	r0, [sp]
700ad066: b140         	cbz	r0, 0x700ad07a <UdmaChPdmaPrms_init+0x1a> @ imm = #0x10
700ad068: e7ff         	b	0x700ad06a <UdmaChPdmaPrms_init+0xa> @ imm = #-0x2
;         pdmaPrms->elemSize  = UDMA_PDMA_ES_8BITS;
700ad06a: 9900         	ldr	r1, [sp]
700ad06c: 2000         	movs	r0, #0x0
700ad06e: 6008         	str	r0, [r1]
;         pdmaPrms->elemCnt   = 0U;
700ad070: 9900         	ldr	r1, [sp]
700ad072: 6048         	str	r0, [r1, #0x4]
;         pdmaPrms->fifoCnt   = 0U;
700ad074: 9900         	ldr	r1, [sp]
700ad076: 6088         	str	r0, [r1, #0x8]
;     }
700ad078: e7ff         	b	0x700ad07a <UdmaChPdmaPrms_init+0x1a> @ imm = #-0x2
;     return;
700ad07a: b001         	add	sp, #0x4
700ad07c: 4770         	bx	lr
700ad07e: 0000         	movs	r0, r0

700ad080 <prvTimerTask>:
;     {
700ad080: b580         	push	{r7, lr}
700ad082: b084         	sub	sp, #0x10
700ad084: 9003         	str	r0, [sp, #0xc]
;         for( ; ; )
700ad086: e7ff         	b	0x700ad088 <prvTimerTask+0x8> @ imm = #-0x2
700ad088: a801         	add	r0, sp, #0x4
;             xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
700ad08a: f7fe fcd9    	bl	0x700aba40 <prvGetNextExpireTime> @ imm = #-0x164e
700ad08e: 9002         	str	r0, [sp, #0x8]
;             prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
700ad090: 9802         	ldr	r0, [sp, #0x8]
700ad092: 9901         	ldr	r1, [sp, #0x4]
700ad094: f7fb fa9c    	bl	0x700a85d0 <prvProcessTimerOrBlockTask> @ imm = #-0x4ac8
;             prvProcessReceivedCommands();
700ad098: f7f3 fe8a    	bl	0x700a0db0 <prvProcessReceivedCommands> @ imm = #-0xc2ec
;         for( ; ; )
700ad09c: e7f4         	b	0x700ad088 <prvTimerTask+0x8> @ imm = #-0x18
700ad09e: 0000         	movs	r0, r0

700ad0a0 <xPortStartScheduler>:
; BaseType_t xPortStartScheduler(void) {
700ad0a0: b580         	push	{r7, lr}
700ad0a2: b082         	sub	sp, #0x8
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700ad0a4: b672         	cpsid i
;   ulPortSchedularRunning = pdTRUE;
700ad0a6: f240 11dc    	movw	r1, #0x1dc
700ad0aa: f2c7 010b    	movt	r1, #0x700b
700ad0ae: 2001         	movs	r0, #0x1
700ad0b0: 9001         	str	r0, [sp, #0x4]
700ad0b2: 6008         	str	r0, [r1]
;   vPortRestoreTaskContext();
700ad0b4: f001 e876    	blx	0x700ae1a4 <vPortRestoreTaskContext> @ imm = #0x10ec
700ad0b8: 9801         	ldr	r0, [sp, #0x4]
;   return pdTRUE;
700ad0ba: b002         	add	sp, #0x8
700ad0bc: bd80         	pop	{r7, pc}
700ad0be: 0000         	movs	r0, r0

700ad0c0 <xTaskGetTickCount>:
; TickType_t xTaskGetTickCount(void) {
700ad0c0: b580         	push	{r7, lr}
700ad0c2: b082         	sub	sp, #0x8
;   portTICK_TYPE_ENTER_CRITICAL();
700ad0c4: f7ff f994    	bl	0x700ac3f0 <vTaskEnterCritical> @ imm = #-0xcd8
;     xTicks = xTickCount;
700ad0c8: f240 2010    	movw	r0, #0x210
700ad0cc: f2c7 000b    	movt	r0, #0x700b
700ad0d0: 6800         	ldr	r0, [r0]
700ad0d2: 9001         	str	r0, [sp, #0x4]
;   portTICK_TYPE_EXIT_CRITICAL();
700ad0d4: f7fe fa8c    	bl	0x700ab5f0 <vTaskExitCritical> @ imm = #-0x1ae8
;   return xTicks;
700ad0d8: 9801         	ldr	r0, [sp, #0x4]
700ad0da: b002         	add	sp, #0x8
700ad0dc: bd80         	pop	{r7, pc}
700ad0de: 0000         	movs	r0, r0

700ad0e0 <CSL_secProxyGetDataAddr>:
; {
700ad0e0: b084         	sub	sp, #0x10
700ad0e2: 9003         	str	r0, [sp, #0xc]
700ad0e4: 9102         	str	r1, [sp, #0x8]
700ad0e6: 9201         	str	r2, [sp, #0x4]
;     dataAddr = (uintptr_t)pSecProxyCfg->proxyTargetAddr + ((uintptr_t)threadNum * CSL_SEC_PROXY_TARGET_CHAN_SIZE) + (uintptr_t)CSL_SEC_PROXY_RSVD_MSG_BYTES;
700ad0e8: 9803         	ldr	r0, [sp, #0xc]
700ad0ea: 6900         	ldr	r0, [r0, #0x10]
700ad0ec: 9902         	ldr	r1, [sp, #0x8]
700ad0ee: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad0f2: 3004         	adds	r0, #0x4
700ad0f4: 9000         	str	r0, [sp]
;     return dataAddr;
700ad0f6: 9800         	ldr	r0, [sp]
700ad0f8: b004         	add	sp, #0x10
700ad0fa: 4770         	bx	lr
700ad0fc: 0000         	movs	r0, r0
700ad0fe: 0000         	movs	r0, r0

700ad100 <UART_IsParameter>:
; {
700ad100: b082         	sub	sp, #0x8
700ad102: 9001         	str	r0, [sp, #0x4]
700ad104: 2000         	movs	r0, #0x0
;     int32_t status = UART_STATUS_SUCCESS;
700ad106: 9000         	str	r0, [sp]
;     if(InuptParameter == 0U)
700ad108: 9801         	ldr	r0, [sp, #0x4]
700ad10a: b920         	cbnz	r0, 0x700ad116 <UART_IsParameter+0x16> @ imm = #0x8
700ad10c: e7ff         	b	0x700ad10e <UART_IsParameter+0xe> @ imm = #-0x2
700ad10e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700ad112: 9000         	str	r0, [sp]
;     }
700ad114: e7ff         	b	0x700ad116 <UART_IsParameter+0x16> @ imm = #-0x2
;     return status;
700ad116: 9800         	ldr	r0, [sp]
700ad118: b002         	add	sp, #0x8
700ad11a: 4770         	bx	lr
700ad11c: 0000         	movs	r0, r0
700ad11e: 0000         	movs	r0, r0

700ad120 <pvPortMalloc>:
; {
700ad120: b580         	push	{r7, lr}
700ad122: b082         	sub	sp, #0x8
700ad124: 9001         	str	r0, [sp, #0x4]
;     vTaskSuspendAll();
700ad126: f000 faab    	bl	0x700ad680 <vTaskSuspendAll> @ imm = #0x556
;         pvReturn = malloc( xWantedSize );
700ad12a: 9801         	ldr	r0, [sp, #0x4]
700ad12c: f7ec ef82    	blx	0x7009a034 <malloc>     @ imm = #-0x130fc
700ad130: 9000         	str	r0, [sp]
;     ( void ) xTaskResumeAll();
700ad132: f7f3 fcfd    	bl	0x700a0b30 <xTaskResumeAll> @ imm = #-0xc606
;     return pvReturn;
700ad136: 9800         	ldr	r0, [sp]
700ad138: b002         	add	sp, #0x8
700ad13a: bd80         	pop	{r7, pc}
700ad13c: 0000         	movs	r0, r0
700ad13e: 0000         	movs	r0, r0

700ad140 <vPortYeildFromISR>:
; void vPortYeildFromISR(uint32_t xSwitchRequired) {
700ad140: b081         	sub	sp, #0x4
700ad142: 9000         	str	r0, [sp]
;   if (xSwitchRequired != pdFALSE) {
700ad144: 9800         	ldr	r0, [sp]
700ad146: b138         	cbz	r0, 0x700ad158 <vPortYeildFromISR+0x18> @ imm = #0xe
700ad148: e7ff         	b	0x700ad14a <vPortYeildFromISR+0xa> @ imm = #-0x2
;     ulPortYieldRequired = pdTRUE;
700ad14a: f240 11e4    	movw	r1, #0x1e4
700ad14e: f2c7 010b    	movt	r1, #0x700b
700ad152: 2001         	movs	r0, #0x1
700ad154: 6008         	str	r0, [r1]
;   }
700ad156: e7ff         	b	0x700ad158 <vPortYeildFromISR+0x18> @ imm = #-0x2
; }
700ad158: b001         	add	sp, #0x4
700ad15a: 4770         	bx	lr
700ad15c: 0000         	movs	r0, r0
700ad15e: 0000         	movs	r0, r0

700ad160 <CSL_udmapCppi5SetDescType>:
; {
700ad160: b082         	sub	sp, #0x8
700ad162: 9001         	str	r0, [sp, #0x4]
700ad164: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_DTYPE, descType );
700ad166: 9901         	ldr	r1, [sp, #0x4]
700ad168: 6808         	ldr	r0, [r1]
700ad16a: f020 4040    	bic	r0, r0, #0xc0000000
700ad16e: 9a00         	ldr	r2, [sp]
700ad170: ea40 7082    	orr.w	r0, r0, r2, lsl #30
700ad174: 6008         	str	r0, [r1]
; }
700ad176: b002         	add	sp, #0x8
700ad178: 4770         	bx	lr
700ad17a: 0000         	movs	r0, r0
700ad17c: 0000         	movs	r0, r0
700ad17e: 0000         	movs	r0, r0

700ad180 <UART_fifoCharGet>:
; {
700ad180: b580         	push	{r7, lr}
700ad182: b082         	sub	sp, #0x8
700ad184: 9001         	str	r0, [sp, #0x4]
700ad186: 2000         	movs	r0, #0x0
;     uint32_t tempRetVal = 0U;
700ad188: 9000         	str	r0, [sp]
;     tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700ad18a: 9801         	ldr	r0, [sp, #0x4]
700ad18c: f000 fa50    	bl	0x700ad630 <HW_RD_REG32_RAW> @ imm = #0x4a0
700ad190: 9000         	str	r0, [sp]
;     return ((uint8_t) tempRetVal);
700ad192: f89d 0000    	ldrb.w	r0, [sp]
700ad196: b002         	add	sp, #0x8
700ad198: bd80         	pop	{r7, pc}
700ad19a: 0000         	movs	r0, r0
700ad19c: 0000         	movs	r0, r0
700ad19e: 0000         	movs	r0, r0

700ad1a0 <UART_timeGuardConfig>:
; {
700ad1a0: b580         	push	{r7, lr}
700ad1a2: b082         	sub	sp, #0x8
700ad1a4: 9001         	str	r0, [sp, #0x4]
700ad1a6: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_TIMEGUARD, UART_TIMEGUARD_TIMEGUARD,
700ad1a8: 9801         	ldr	r0, [sp, #0x4]
700ad1aa: 3094         	adds	r0, #0x94
700ad1ac: 9b00         	ldr	r3, [sp]
700ad1ae: 21ff         	movs	r1, #0xff
700ad1b0: 2200         	movs	r2, #0x0
700ad1b2: f7ff f8bd    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #-0xe86
; }
700ad1b6: b002         	add	sp, #0x8
700ad1b8: bd80         	pop	{r7, pc}
700ad1ba: 0000         	movs	r0, r0
700ad1bc: 0000         	movs	r0, r0
700ad1be: 0000         	movs	r0, r0

700ad1c0 <CSL_udmapCppi5SetPsDataLen>:
; {
700ad1c0: b082         	sub	sp, #0x8
700ad1c2: 9001         	str	r0, [sp, #0x4]
700ad1c4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSWCNT, (psDataLen/4U) );
700ad1c6: 9901         	ldr	r1, [sp, #0x4]
700ad1c8: 6808         	ldr	r0, [r1]
700ad1ca: 9a00         	ldr	r2, [sp]
700ad1cc: 0892         	lsrs	r2, r2, #0x2
700ad1ce: f362 509b    	bfi	r0, r2, #22, #6
700ad1d2: 6008         	str	r0, [r1]
; }
700ad1d4: b002         	add	sp, #0x8
700ad1d6: 4770         	bx	lr
		...

700ad1e0 <Sciclient_rmIrqSet>:
; {
700ad1e0: b580         	push	{r7, lr}
700ad1e2: b084         	sub	sp, #0x10
700ad1e4: 9003         	str	r0, [sp, #0xc]
700ad1e6: 9102         	str	r1, [sp, #0x8]
700ad1e8: 9201         	str	r2, [sp, #0x4]
;     return Sciclient_rmProgramInterruptRoute(req, resp, timeout);
700ad1ea: 9803         	ldr	r0, [sp, #0xc]
700ad1ec: 9902         	ldr	r1, [sp, #0x8]
700ad1ee: 9a01         	ldr	r2, [sp, #0x4]
700ad1f0: f7f1 fd06    	bl	0x7009ec00 <Sciclient_rmProgramInterruptRoute> @ imm = #-0xe5f4
700ad1f4: b004         	add	sp, #0x10
700ad1f6: bd80         	pop	{r7, pc}
		...

700ad200 <Sciclient_secProxyThreadStatusReg>:
; {
700ad200: b081         	sub	sp, #0x4
700ad202: 9000         	str	r0, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700ad204: f240 00e8    	movw	r0, #0xe8
700ad208: f2c7 000b    	movt	r0, #0x700b
700ad20c: 6880         	ldr	r0, [r0, #0x8]
;         CSL_SEC_PROXY_RT_THREAD_STATUS(thread));
700ad20e: 9900         	ldr	r1, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700ad210: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad214: b001         	add	sp, #0x4
700ad216: 4770         	bx	lr
		...

700ad220 <TimerP_start>:
; {
700ad220: b082         	sub	sp, #0x8
700ad222: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (uint32_t *)(baseAddr + TIMER_TCLR);
700ad224: 9801         	ldr	r0, [sp, #0x4]
700ad226: 3038         	adds	r0, #0x38
700ad228: 9000         	str	r0, [sp]
;     *addr |= (0x1U << 0);
700ad22a: 9900         	ldr	r1, [sp]
700ad22c: 6808         	ldr	r0, [r1]
700ad22e: f040 0001    	orr	r0, r0, #0x1
700ad232: 6008         	str	r0, [r1]
; }
700ad234: b002         	add	sp, #0x8
700ad236: 4770         	bx	lr
		...

700ad240 <TimerP_stop>:
; {
700ad240: b082         	sub	sp, #0x8
700ad242: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
700ad244: 9801         	ldr	r0, [sp, #0x4]
700ad246: 3038         	adds	r0, #0x38
700ad248: 9000         	str	r0, [sp]
;     *addr &= ~(0x1U << 0);
700ad24a: 9900         	ldr	r1, [sp]
700ad24c: 6808         	ldr	r0, [r1]
700ad24e: f020 0001    	bic	r0, r0, #0x1
700ad252: 6008         	str	r0, [r1]
; }
700ad254: b002         	add	sp, #0x8
700ad256: 4770         	bx	lr
		...

700ad260 <UART_divisorLatchDisable>:
; {
700ad260: b580         	push	{r7, lr}
700ad262: b082         	sub	sp, #0x8
700ad264: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_DIV_EN,
700ad266: 9801         	ldr	r0, [sp, #0x4]
700ad268: 300c         	adds	r0, #0xc
700ad26a: 2180         	movs	r1, #0x80
700ad26c: 2207         	movs	r2, #0x7
700ad26e: 2300         	movs	r3, #0x0
700ad270: f7ff f85e    	bl	0x700ac330 <HW_WR_FIELD32_RAW> @ imm = #-0xf44
; }
700ad274: b002         	add	sp, #0x8
700ad276: bd80         	pop	{r7, pc}
		...

700ad280 <UART_modemControlReset>:
; {
700ad280: b580         	push	{r7, lr}
700ad282: b082         	sub	sp, #0x8
700ad284: 9001         	str	r0, [sp, #0x4]
700ad286: 2000         	movs	r0, #0x0
;     uint32_t mcrResetVal = 0U;
700ad288: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_MCR, mcrResetVal);
700ad28a: 9801         	ldr	r0, [sp, #0x4]
700ad28c: 3010         	adds	r0, #0x10
700ad28e: 9900         	ldr	r1, [sp]
700ad290: f000 f9d6    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x3ac
; }
700ad294: b002         	add	sp, #0x8
700ad296: bd80         	pop	{r7, pc}
		...

700ad2a0 <UART_putChar>:
; {
700ad2a0: b580         	push	{r7, lr}
700ad2a2: b082         	sub	sp, #0x8
700ad2a4: 9001         	str	r0, [sp, #0x4]
700ad2a6: f88d 1003    	strb.w	r1, [sp, #0x3]
;     HW_WR_REG32(baseAddr + UART_THR, (uint32_t) byteTx);
700ad2aa: 9801         	ldr	r0, [sp, #0x4]
700ad2ac: f89d 1003    	ldrb.w	r1, [sp, #0x3]
700ad2b0: f000 f9c6    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x38c
; }
700ad2b4: b002         	add	sp, #0x8
700ad2b6: bd80         	pop	{r7, pc}
		...

700ad2c0 <CSL_REG64_WR_RAW>:
; {
700ad2c0: b084         	sub	sp, #0x10
700ad2c2: 9003         	str	r0, [sp, #0xc]
700ad2c4: 9301         	str	r3, [sp, #0x4]
700ad2c6: 9200         	str	r2, [sp]
;     *p = v;
700ad2c8: 9800         	ldr	r0, [sp]
700ad2ca: 9901         	ldr	r1, [sp, #0x4]
700ad2cc: 9a03         	ldr	r2, [sp, #0xc]
700ad2ce: e9c2 0100    	strd	r0, r1, [r2]
;     return;
700ad2d2: b004         	add	sp, #0x10
700ad2d4: 4770         	bx	lr
		...
700ad2de: 0000         	movs	r0, r0

700ad2e0 <CSL_udmapCppi5LinkDesc>:
; {
700ad2e0: b084         	sub	sp, #0x10
700ad2e2: 9003         	str	r0, [sp, #0xc]
700ad2e4: 9301         	str	r3, [sp, #0x4]
700ad2e6: 9200         	str	r2, [sp]
;     pDesc->nextDescPtr = physBufferDescAddr;
700ad2e8: 9800         	ldr	r0, [sp]
700ad2ea: 9a01         	ldr	r2, [sp, #0x4]
700ad2ec: 9903         	ldr	r1, [sp, #0xc]
700ad2ee: 614a         	str	r2, [r1, #0x14]
700ad2f0: 6108         	str	r0, [r1, #0x10]
; }
700ad2f2: b004         	add	sp, #0x10
700ad2f4: 4770         	bx	lr
		...
700ad2fe: 0000         	movs	r0, r0

700ad300 <CSL_udmapCppi5SetBufferAddr>:
; {
700ad300: b084         	sub	sp, #0x10
700ad302: 9003         	str	r0, [sp, #0xc]
700ad304: 9301         	str	r3, [sp, #0x4]
700ad306: 9200         	str	r2, [sp]
;     pDesc->bufPtr    = physBufferAddr;
700ad308: 9800         	ldr	r0, [sp]
700ad30a: 9a01         	ldr	r2, [sp, #0x4]
700ad30c: 9903         	ldr	r1, [sp, #0xc]
700ad30e: 61ca         	str	r2, [r1, #0x1c]
700ad310: 6188         	str	r0, [r1, #0x18]
; }
700ad312: b004         	add	sp, #0x10
700ad314: 4770         	bx	lr
		...
700ad31e: 0000         	movs	r0, r0

700ad320 <CSL_udmapCppi5SetBufferLen>:
; {
700ad320: b082         	sub	sp, #0x8
700ad322: 9001         	str	r0, [sp, #0x4]
700ad324: 9100         	str	r1, [sp]
;     CSL_FINS( pDesc->bufInfo1, UDMAP_CPPI5_PD_BUFINFO1_LEN, bufferLenBytes );
700ad326: 9901         	ldr	r1, [sp, #0x4]
700ad328: 6a08         	ldr	r0, [r1, #0x20]
700ad32a: 9a00         	ldr	r2, [sp]
700ad32c: f362 0015    	bfi	r0, r2, #0, #22
700ad330: 6208         	str	r0, [r1, #0x20]
; }
700ad332: b002         	add	sp, #0x8
700ad334: 4770         	bx	lr
		...
700ad33e: 0000         	movs	r0, r0

700ad340 <CSL_udmapCppi5SetOrgBufferAddr>:
; {
700ad340: b084         	sub	sp, #0x10
700ad342: 9003         	str	r0, [sp, #0xc]
700ad344: 9301         	str	r3, [sp, #0x4]
700ad346: 9200         	str	r2, [sp]
;     pDesc->orgBufPtr = physBufferAddr;
700ad348: 9800         	ldr	r0, [sp]
700ad34a: 9a01         	ldr	r2, [sp, #0x4]
700ad34c: 9903         	ldr	r1, [sp, #0xc]
700ad34e: 62ca         	str	r2, [r1, #0x2c]
700ad350: 6288         	str	r0, [r1, #0x28]
; }
700ad352: b004         	add	sp, #0x10
700ad354: 4770         	bx	lr
		...
700ad35e: 0000         	movs	r0, r0

700ad360 <CSL_udmapCppi5SetPsDataLoc>:
; {
700ad360: b082         	sub	sp, #0x8
700ad362: 9001         	str	r0, [sp, #0x4]
700ad364: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSINFO, psLoc );
700ad366: 9901         	ldr	r1, [sp, #0x4]
700ad368: 6808         	ldr	r0, [r1]
700ad36a: 9a00         	ldr	r2, [sp]
700ad36c: f362 701c    	bfi	r0, r2, #28, #1
700ad370: 6008         	str	r0, [r1]
; }
700ad372: b002         	add	sp, #0x8
700ad374: 4770         	bx	lr
		...
700ad37e: 0000         	movs	r0, r0

700ad380 <CSL_udmapCppi5SetPsFlags>:
; {
700ad380: b082         	sub	sp, #0x8
700ad382: 9001         	str	r0, [sp, #0x4]
700ad384: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1, UDMAP_CPPI5_PD_PKTINFO1_PSFLGS, psFlags );
700ad386: 9901         	ldr	r1, [sp, #0x4]
700ad388: 6848         	ldr	r0, [r1, #0x4]
700ad38a: 9a00         	ldr	r2, [sp]
700ad38c: f362 601b    	bfi	r0, r2, #24, #4
700ad390: 6048         	str	r0, [r1, #0x4]
; }
700ad392: b002         	add	sp, #0x8
700ad394: 4770         	bx	lr
		...
700ad39e: 0000         	movs	r0, r0

700ad3a0 <Sciclient_rmIrqRelease>:
; {
700ad3a0: b580         	push	{r7, lr}
700ad3a2: b084         	sub	sp, #0x10
700ad3a4: 9003         	str	r0, [sp, #0xc]
700ad3a6: 9102         	str	r1, [sp, #0x8]
;     return Sciclient_rmClearInterruptRoute(req, &resp, timeout);
700ad3a8: 9803         	ldr	r0, [sp, #0xc]
700ad3aa: 9a02         	ldr	r2, [sp, #0x8]
700ad3ac: 4669         	mov	r1, sp
700ad3ae: f7f1 f8f7    	bl	0x7009e5a0 <Sciclient_rmClearInterruptRoute> @ imm = #-0xee12
700ad3b2: b004         	add	sp, #0x10
700ad3b4: bd80         	pop	{r7, pc}
		...
700ad3be: 0000         	movs	r0, r0

700ad3c0 <Sciclient_secProxyReadThreadCount>:
; {
700ad3c0: b580         	push	{r7, lr}
700ad3c2: b082         	sub	sp, #0x8
700ad3c4: 9001         	str	r0, [sp, #0x4]
;     return (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ad3c6: 9801         	ldr	r0, [sp, #0x4]
700ad3c8: f7ff ff1a    	bl	0x700ad200 <Sciclient_secProxyThreadStatusReg> @ imm = #-0x1cc
700ad3cc: f000 f990    	bl	0x700ad6f0 <CSL_REG32_RD_RAW> @ imm = #0x320
700ad3d0: b2c0         	uxtb	r0, r0
700ad3d2: b002         	add	sp, #0x8
700ad3d4: bd80         	pop	{r7, pc}
		...
700ad3de: 0000         	movs	r0, r0

700ad3e0 <SemaphoreP_destruct>:
; {
700ad3e0: b580         	push	{r7, lr}
700ad3e2: b082         	sub	sp, #0x8
700ad3e4: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700ad3e6: 9801         	ldr	r0, [sp, #0x4]
700ad3e8: 9000         	str	r0, [sp]
;     vSemaphoreDelete(pSemaphore->semHndl);
700ad3ea: 9800         	ldr	r0, [sp]
700ad3ec: 6d00         	ldr	r0, [r0, #0x50]
700ad3ee: f7ff fb87    	bl	0x700acb00 <vQueueDelete> @ imm = #-0x8f2
; }
700ad3f2: b002         	add	sp, #0x8
700ad3f4: bd80         	pop	{r7, pc}
		...
700ad3fe: 0000         	movs	r0, r0

700ad400 <UART_divideRoundCloset>:
; {
700ad400: b082         	sub	sp, #0x8
700ad402: 9001         	str	r0, [sp, #0x4]
700ad404: 9100         	str	r1, [sp]
;     return ((divident + (divisor/2U))/divisor);
700ad406: 9801         	ldr	r0, [sp, #0x4]
700ad408: 9900         	ldr	r1, [sp]
700ad40a: eb00 0051    	add.w	r0, r0, r1, lsr #1
700ad40e: fbb0 f0f1    	udiv	r0, r0, r1
700ad412: b002         	add	sp, #0x8
700ad414: 4770         	bx	lr
		...
700ad41e: 0000         	movs	r0, r0

700ad420 <UART_regConfModeRestore>:
; {
700ad420: b580         	push	{r7, lr}
700ad422: b082         	sub	sp, #0x8
700ad424: 9001         	str	r0, [sp, #0x4]
700ad426: 9100         	str	r1, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad428: 9801         	ldr	r0, [sp, #0x4]
700ad42a: 300c         	adds	r0, #0xc
700ad42c: 9900         	ldr	r1, [sp]
700ad42e: f000 f907    	bl	0x700ad640 <HW_WR_REG32_RAW> @ imm = #0x20e
; }
700ad432: b002         	add	sp, #0x8
700ad434: bd80         	pop	{r7, pc}
		...
700ad43e: 0000         	movs	r0, r0

700ad440 <DebugP_uartSetDrvIndex>:
; {
700ad440: b081         	sub	sp, #0x4
700ad442: 9000         	str	r0, [sp]
;     gDebugP_uartDrvIndex = uartDrvIndex;
700ad444: 9800         	ldr	r0, [sp]
700ad446: f240 11b4    	movw	r1, #0x1b4
700ad44a: f2c7 010b    	movt	r1, #0x700b
700ad44e: 6008         	str	r0, [r1]
; }
700ad450: b001         	add	sp, #0x4
700ad452: 4770         	bx	lr
		...

700ad460 <Sciclient_rmIrIntControlReg>:
; {
700ad460: b081         	sub	sp, #0x4
700ad462: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (outp * SCICLIENT_IR_INT_CONTROL_REG_STEP) +
700ad466: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700ad46a: 2004         	movs	r0, #0x4
700ad46c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ad470: b001         	add	sp, #0x4
700ad472: 4770         	bx	lr
		...

700ad480 <Udma_rmAllocFreeRing>:
; {
700ad480: b082         	sub	sp, #0x8
700ad482: 9001         	str	r0, [sp, #0x4]
700ad484: f64f 70ff    	movw	r0, #0xffff
;     uint16_t            ringNum = UDMA_RING_INVALID;
700ad488: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (ringNum);
700ad48c: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ad490: b002         	add	sp, #0x8
700ad492: 4770         	bx	lr
		...

700ad4a0 <xTaskGetCurrentTaskHandle>:
; TaskHandle_t xTaskGetCurrentTaskHandle(void) {
700ad4a0: b081         	sub	sp, #0x4
;   xReturn = pxCurrentTCB;
700ad4a2: f240 10cc    	movw	r0, #0x1cc
700ad4a6: f2c7 000b    	movt	r0, #0x700b
700ad4aa: 6800         	ldr	r0, [r0]
700ad4ac: 9000         	str	r0, [sp]
;   return xReturn;
700ad4ae: 9800         	ldr	r0, [sp]
700ad4b0: b001         	add	sp, #0x4
700ad4b2: 4770         	bx	lr
		...

700ad4c0 <CSL_udmapCppi5SetSrcTag>:
; {
700ad4c0: b082         	sub	sp, #0x8
700ad4c2: 9001         	str	r0, [sp, #0x4]
700ad4c4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_SRCTAG, srcTag );
700ad4c6: 9901         	ldr	r1, [sp, #0x4]
700ad4c8: f8bd 0000    	ldrh.w	r0, [sp]
700ad4cc: 81c8         	strh	r0, [r1, #0xe]
; }
700ad4ce: b002         	add	sp, #0x8
700ad4d0: 4770         	bx	lr
		...
700ad4de: 0000         	movs	r0, r0

700ad4e0 <TimerP_getCount>:
; {
700ad4e0: b082         	sub	sp, #0x8
700ad4e2: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
700ad4e4: 9801         	ldr	r0, [sp, #0x4]
700ad4e6: 303c         	adds	r0, #0x3c
700ad4e8: 9000         	str	r0, [sp]
;     return *addr;
700ad4ea: 9800         	ldr	r0, [sp]
700ad4ec: 6800         	ldr	r0, [r0]
700ad4ee: b002         	add	sp, #0x8
700ad4f0: 4770         	bx	lr
		...
700ad4fe: 0000         	movs	r0, r0

700ad500 <TimerP_getReloadCount>:
; {
700ad500: b082         	sub	sp, #0x8
700ad502: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
700ad504: 9801         	ldr	r0, [sp, #0x4]
700ad506: 3040         	adds	r0, #0x40
700ad508: 9000         	str	r0, [sp]
;     return *addr;
700ad50a: 9800         	ldr	r0, [sp]
700ad50c: 6800         	ldr	r0, [r0]
700ad50e: b002         	add	sp, #0x8
700ad510: 4770         	bx	lr
		...
700ad51e: 0000         	movs	r0, r0

700ad520 <putchar_>:
; {
700ad520: b510         	push	{r4, lr}
700ad522: 4604         	mov	r4, r0
;     DebugP_memLogWriterPutChar(character);
700ad524: f7f3 f874    	bl	0x700a0610 <DebugP_memLogWriterPutChar> @ imm = #-0xcf18
;     DebugP_uartLogWriterPutChar(character);
700ad528: 4620         	mov	r0, r4
700ad52a: e8bd 4010    	pop.w	{r4, lr}
700ad52e: f7fe b80f    	b.w	0x700ab550 <DebugP_uartLogWriterPutChar> @ imm = #-0x1fe2
		...
700ad53e: 0000         	movs	r0, r0

700ad540 <tm_interrupt_handler>:
;    if (test_interrupt_handler != NULL)
700ad540: f240 10d0    	movw	r0, #0x1d0
700ad544: f2c7 000b    	movt	r0, #0x700b
700ad548: 6800         	ldr	r0, [r0]
700ad54a: 2800         	cmp	r0, #0x0
; }
700ad54c: bf08         	it	eq
700ad54e: 4770         	bxeq	lr
;       ((void (*)(void)) test_interrupt_handler)();
700ad550: 4700         	bx	r0
		...
700ad55e: 0000         	movs	r0, r0

700ad560 <uiPortGetRunTimeCounterValue>:
; uint32_t uiPortGetRunTimeCounterValue() {
700ad560: b580         	push	{r7, lr}
700ad562: b082         	sub	sp, #0x8
;   uint64_t timeInUsecs = ClockP_getTimeUsec();
700ad564: f7fb fa9c    	bl	0x700a8aa0 <ClockP_getTimeUsec> @ imm = #-0x4ac8
700ad568: 9101         	str	r1, [sp, #0x4]
700ad56a: 9000         	str	r0, [sp]
;   return (uint32_t)(timeInUsecs);
700ad56c: 9800         	ldr	r0, [sp]
700ad56e: b002         	add	sp, #0x8
700ad570: bd80         	pop	{r7, pc}
		...
700ad57e: 0000         	movs	r0, r0

700ad580 <CSL_REG32_WR_RAW>:
; {
700ad580: b082         	sub	sp, #0x8
700ad582: 9001         	str	r0, [sp, #0x4]
700ad584: 9100         	str	r1, [sp]
;     *p = v;
700ad586: 9800         	ldr	r0, [sp]
700ad588: 9901         	ldr	r1, [sp, #0x4]
700ad58a: 6008         	str	r0, [r1]
;     return;
700ad58c: b002         	add	sp, #0x8
700ad58e: 4770         	bx	lr

700ad590 <CSL_REG32_WR_RAW>:
; {
700ad590: b082         	sub	sp, #0x8
700ad592: 9001         	str	r0, [sp, #0x4]
700ad594: 9100         	str	r1, [sp]
;     *p = v;
700ad596: 9800         	ldr	r0, [sp]
700ad598: 9901         	ldr	r1, [sp, #0x4]
700ad59a: 6008         	str	r0, [r1]
;     return;
700ad59c: b002         	add	sp, #0x8
700ad59e: 4770         	bx	lr

700ad5a0 <CSL_REG32_WR_RAW>:
; {
700ad5a0: b082         	sub	sp, #0x8
700ad5a2: 9001         	str	r0, [sp, #0x4]
700ad5a4: 9100         	str	r1, [sp]
;     *p = v;
700ad5a6: 9800         	ldr	r0, [sp]
700ad5a8: 9901         	ldr	r1, [sp, #0x4]
700ad5aa: 6008         	str	r0, [r1]
;     return;
700ad5ac: b002         	add	sp, #0x8
700ad5ae: 4770         	bx	lr

700ad5b0 <CSL_REG32_WR_RAW>:
; {
700ad5b0: b082         	sub	sp, #0x8
700ad5b2: 9001         	str	r0, [sp, #0x4]
700ad5b4: 9100         	str	r1, [sp]
;     *p = v;
700ad5b6: 9800         	ldr	r0, [sp]
700ad5b8: 9901         	ldr	r1, [sp, #0x4]
700ad5ba: 6008         	str	r0, [r1]
;     return;
700ad5bc: b002         	add	sp, #0x8
700ad5be: 4770         	bx	lr

700ad5c0 <CSL_REG32_WR_RAW>:
; {
700ad5c0: b082         	sub	sp, #0x8
700ad5c2: 9001         	str	r0, [sp, #0x4]
700ad5c4: 9100         	str	r1, [sp]
;     *p = v;
700ad5c6: 9800         	ldr	r0, [sp]
700ad5c8: 9901         	ldr	r1, [sp, #0x4]
700ad5ca: 6008         	str	r0, [r1]
;     return;
700ad5cc: b002         	add	sp, #0x8
700ad5ce: 4770         	bx	lr

700ad5d0 <CSL_REG32_WR_RAW>:
; {
700ad5d0: b082         	sub	sp, #0x8
700ad5d2: 9001         	str	r0, [sp, #0x4]
700ad5d4: 9100         	str	r1, [sp]
;     *p = v;
700ad5d6: 9800         	ldr	r0, [sp]
700ad5d8: 9901         	ldr	r1, [sp, #0x4]
700ad5da: 6008         	str	r0, [r1]
;     return;
700ad5dc: b002         	add	sp, #0x8
700ad5de: 4770         	bx	lr

700ad5e0 <CSL_udmapCppi5SetDstTag>:
; {
700ad5e0: b082         	sub	sp, #0x8
700ad5e2: 9001         	str	r0, [sp, #0x4]
700ad5e4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_DSTTAG, dstTag );
700ad5e6: 9901         	ldr	r1, [sp, #0x4]
700ad5e8: 9800         	ldr	r0, [sp]
700ad5ea: 8188         	strh	r0, [r1, #0xc]
; }
700ad5ec: b002         	add	sp, #0x8
700ad5ee: 4770         	bx	lr

700ad5f0 <CSL_udmapCppi5SetOrgBufferLen>:
; {
700ad5f0: b082         	sub	sp, #0x8
700ad5f2: 9001         	str	r0, [sp, #0x4]
700ad5f4: 9100         	str	r1, [sp]
;     pDesc->orgBufLen = bufferLenBytes;
700ad5f6: 9800         	ldr	r0, [sp]
700ad5f8: 9901         	ldr	r1, [sp, #0x4]
700ad5fa: 6248         	str	r0, [r1, #0x24]
; }
700ad5fc: b002         	add	sp, #0x8
700ad5fe: 4770         	bx	lr

700ad600 <ClockP_getTimerCount>:
; {
700ad600: b580         	push	{r7, lr}
700ad602: b082         	sub	sp, #0x8
700ad604: 9001         	str	r0, [sp, #0x4]
;     return TimerP_getCount(timerBaseAddr);
700ad606: 9801         	ldr	r0, [sp, #0x4]
700ad608: f7ff ff6a    	bl	0x700ad4e0 <TimerP_getCount> @ imm = #-0x12c
700ad60c: b002         	add	sp, #0x8
700ad60e: bd80         	pop	{r7, pc}

700ad610 <ClockP_sleepTicks>:
; {
700ad610: b580         	push	{r7, lr}
700ad612: b082         	sub	sp, #0x8
700ad614: 9001         	str	r0, [sp, #0x4]
;     vTaskDelay(ticks);
700ad616: 9801         	ldr	r0, [sp, #0x4]
700ad618: f7fe fd52    	bl	0x700ac0c0 <vTaskDelay> @ imm = #-0x155c
; }
700ad61c: b002         	add	sp, #0x8
700ad61e: bd80         	pop	{r7, pc}

700ad620 <ClockP_timerClearOverflowInt>:
; {
700ad620: b580         	push	{r7, lr}
700ad622: b082         	sub	sp, #0x8
700ad624: 9001         	str	r0, [sp, #0x4]
;     TimerP_clearOverflowInt(timerBaseAddr);
700ad626: 9801         	ldr	r0, [sp, #0x4]
700ad628: f7ff f8ea    	bl	0x700ac800 <TimerP_clearOverflowInt> @ imm = #-0xe2c
; }
700ad62c: b002         	add	sp, #0x8
700ad62e: bd80         	pop	{r7, pc}

700ad630 <HW_RD_REG32_RAW>:
; {
700ad630: b082         	sub	sp, #0x8
700ad632: 9001         	str	r0, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700ad634: 9801         	ldr	r0, [sp, #0x4]
700ad636: 6800         	ldr	r0, [r0]
700ad638: 9000         	str	r0, [sp]
;     return (regVal);
700ad63a: 9800         	ldr	r0, [sp]
700ad63c: b002         	add	sp, #0x8
700ad63e: 4770         	bx	lr

700ad640 <HW_WR_REG32_RAW>:
; {
700ad640: b082         	sub	sp, #0x8
700ad642: 9001         	str	r0, [sp, #0x4]
700ad644: 9100         	str	r1, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = value;
700ad646: 9800         	ldr	r0, [sp]
700ad648: 9901         	ldr	r1, [sp, #0x4]
700ad64a: 6008         	str	r0, [r1]
;     return;
700ad64c: b002         	add	sp, #0x8
700ad64e: 4770         	bx	lr

700ad650 <Udma_defaultVirtToPhyFxn>:
; {
700ad650: b083         	sub	sp, #0xc
700ad652: 9002         	str	r0, [sp, #0x8]
700ad654: 9101         	str	r1, [sp, #0x4]
700ad656: 9200         	str	r2, [sp]
;     return ((uint64_t) virtAddr);
700ad658: 9802         	ldr	r0, [sp, #0x8]
700ad65a: 2100         	movs	r1, #0x0
700ad65c: b003         	add	sp, #0xc
700ad65e: 4770         	bx	lr

700ad660 <__aeabi_memset8>:
700ad660: e1a03001     	mov	r3, r1
700ad664: e1a01002     	mov	r1, r2
700ad668: e1a02003     	mov	r2, r3
700ad66c: eaffe533     	b	0x700a6b40 <memset>     @ imm = #-0x6b34

700ad670 <_out_null>:
; {
700ad670: b084         	sub	sp, #0x10
700ad672: f88d 000f    	strb.w	r0, [sp, #0xf]
700ad676: 9102         	str	r1, [sp, #0x8]
700ad678: 9201         	str	r2, [sp, #0x4]
700ad67a: 9300         	str	r3, [sp]
; }
700ad67c: b004         	add	sp, #0x10
700ad67e: 4770         	bx	lr

700ad680 <vTaskSuspendAll>:
;   ++uxSchedulerSuspended;
700ad680: f240 11f0    	movw	r1, #0x1f0
700ad684: f2c7 010b    	movt	r1, #0x700b
700ad688: 6808         	ldr	r0, [r1]
700ad68a: 3001         	adds	r0, #0x1
700ad68c: 6008         	str	r0, [r1]
; }
700ad68e: 4770         	bx	lr

700ad690 <CSL_REG64_RD_RAW>:
; {
700ad690: b081         	sub	sp, #0x4
700ad692: 9000         	str	r0, [sp]
;     return (*p);
700ad694: 9800         	ldr	r0, [sp]
700ad696: e9d0 0100    	ldrd	r0, r1, [r0]
700ad69a: b001         	add	sp, #0x4
700ad69c: 4770         	bx	lr
700ad69e: 0000         	movs	r0, r0

700ad6a0 <vListInitialiseItem>:
; {
700ad6a0: b081         	sub	sp, #0x4
700ad6a2: 9000         	str	r0, [sp]
;     pxItem->pxContainer = NULL;
700ad6a4: 9900         	ldr	r1, [sp]
700ad6a6: 2000         	movs	r0, #0x0
700ad6a8: 6108         	str	r0, [r1, #0x10]
; }
700ad6aa: b001         	add	sp, #0x4
700ad6ac: 4770         	bx	lr
700ad6ae: 0000         	movs	r0, r0

700ad6b0 <vTaskMissedYield>:
; void vTaskMissedYield(void) { xYieldPending = pdTRUE; }
700ad6b0: f240 211c    	movw	r1, #0x21c
700ad6b4: f2c7 010b    	movt	r1, #0x700b
700ad6b8: 2001         	movs	r0, #0x1
700ad6ba: 6008         	str	r0, [r1]
700ad6bc: 4770         	bx	lr
700ad6be: 0000         	movs	r0, r0

700ad6c0 <CSL_REG32_RD_RAW>:
; {
700ad6c0: b081         	sub	sp, #0x4
700ad6c2: 9000         	str	r0, [sp]
;     return (*p);
700ad6c4: 9800         	ldr	r0, [sp]
700ad6c6: 6800         	ldr	r0, [r0]
700ad6c8: b001         	add	sp, #0x4
700ad6ca: 4770         	bx	lr
700ad6cc: 0000         	movs	r0, r0
700ad6ce: 0000         	movs	r0, r0

700ad6d0 <CSL_REG32_RD_RAW>:
; {
700ad6d0: b081         	sub	sp, #0x4
700ad6d2: 9000         	str	r0, [sp]
;     return (*p);
700ad6d4: 9800         	ldr	r0, [sp]
700ad6d6: 6800         	ldr	r0, [r0]
700ad6d8: b001         	add	sp, #0x4
700ad6da: 4770         	bx	lr
700ad6dc: 0000         	movs	r0, r0
700ad6de: 0000         	movs	r0, r0

700ad6e0 <CSL_REG32_RD_RAW>:
; {
700ad6e0: b081         	sub	sp, #0x4
700ad6e2: 9000         	str	r0, [sp]
;     return (*p);
700ad6e4: 9800         	ldr	r0, [sp]
700ad6e6: 6800         	ldr	r0, [r0]
700ad6e8: b001         	add	sp, #0x4
700ad6ea: 4770         	bx	lr
700ad6ec: 0000         	movs	r0, r0
700ad6ee: 0000         	movs	r0, r0

700ad6f0 <CSL_REG32_RD_RAW>:
; {
700ad6f0: b081         	sub	sp, #0x4
700ad6f2: 9000         	str	r0, [sp]
;     return (*p);
700ad6f4: 9800         	ldr	r0, [sp]
700ad6f6: 6800         	ldr	r0, [r0]
700ad6f8: b001         	add	sp, #0x4
700ad6fa: 4770         	bx	lr
700ad6fc: 0000         	movs	r0, r0
700ad6fe: 0000         	movs	r0, r0

700ad700 <CSL_REG32_RD_RAW>:
; {
700ad700: b081         	sub	sp, #0x4
700ad702: 9000         	str	r0, [sp]
;     return (*p);
700ad704: 9800         	ldr	r0, [sp]
700ad706: 6800         	ldr	r0, [r0]
700ad708: b001         	add	sp, #0x4
700ad70a: 4770         	bx	lr
700ad70c: 0000         	movs	r0, r0
700ad70e: 0000         	movs	r0, r0

700ad710 <CSL_REG32_RD_RAW>:
; {
700ad710: b081         	sub	sp, #0x4
700ad712: 9000         	str	r0, [sp]
;     return (*p);
700ad714: 9800         	ldr	r0, [sp]
700ad716: 6800         	ldr	r0, [r0]
700ad718: b001         	add	sp, #0x4
700ad71a: 4770         	bx	lr
700ad71c: 0000         	movs	r0, r0
700ad71e: 0000         	movs	r0, r0

700ad720 <PMU_resetCounters>:
; static void PMU_resetCounters(void) {
700ad720: b580         	push	{r7, lr}
;   CSL_armR5PmuResetCycleCnt();
700ad722: f7f2 eeb8    	blx	0x700a0494 <CSL_armR5PmuResetCycleCnt> @ imm = #-0xd290
;   CSL_armR5PmuResetCntrs();
700ad726: f7f2 eebe    	blx	0x700a04a4 <CSL_armR5PmuResetCntrs> @ imm = #-0xd284
; }
700ad72a: bd80         	pop	{r7, pc}
700ad72c: 0000         	movs	r0, r0
700ad72e: 0000         	movs	r0, r0

700ad730 <Sciclient_getSelfDevIdCore>:
;     return gSciclientHandle.devIdCore;
700ad730: f240 1038    	movw	r0, #0x138
700ad734: f2c7 000b    	movt	r0, #0x700b
700ad738: 6880         	ldr	r0, [r0, #0x8]
700ad73a: 4770         	bx	lr
700ad73c: 0000         	movs	r0, r0
700ad73e: 0000         	movs	r0, r0

700ad740 <Sciclient_rmPsGetPsp>:
;     return gPstack.psp;
700ad740: f241 0058    	movw	r0, #0x1058
700ad744: f2c7 0008    	movt	r0, #0x7008
700ad748: 8c80         	ldrh	r0, [r0, #0x24]
700ad74a: 4770         	bx	lr
700ad74c: 0000         	movs	r0, r0
700ad74e: 0000         	movs	r0, r0

700ad750 <Udma_rmFreeFreeRing>:
; {
700ad750: b082         	sub	sp, #0x8
700ad752: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad756: 9100         	str	r1, [sp]
;     return;
700ad758: b002         	add	sp, #0x8
700ad75a: 4770         	bx	lr
700ad75c: 0000         	movs	r0, r0
700ad75e: 0000         	movs	r0, r0

700ad760 <xTaskGetIdleTaskHandle>:
;   return xIdleTaskHandle;
700ad760: f240 10fc    	movw	r0, #0x1fc
700ad764: f2c7 000b    	movt	r0, #0x700b
700ad768: 6800         	ldr	r0, [r0]
700ad76a: 4770         	bx	lr
700ad76c: 0000         	movs	r0, r0
700ad76e: 0000         	movs	r0, r0

700ad770 <Hwip_dataAndInstructionBarrier>:
;     __asm__ __volatile__ (" isb"   "\n\t": : : "memory");
700ad770: f3bf 8f6f    	isb	sy
;     __asm__ __volatile__ (" dsb"   "\n\t": : : "memory");
700ad774: f3bf 8f4f    	dsb	sy
; }
700ad778: 4770         	bx	lr
700ad77a: 0000         	movs	r0, r0
700ad77c: 0000         	movs	r0, r0
700ad77e: 0000         	movs	r0, r0

700ad780 <prvTaskExitError>:
; static void prvTaskExitError(void) {
700ad780: b580         	push	{r7, lr}
700ad782: 2000         	movs	r0, #0x0
;   DebugP_assertNoLog(0);
700ad784: f001 fac4    	bl	0x700aed10 <_DebugP_assertNoLog> @ imm = #0x1588
; }
700ad788: bd80         	pop	{r7, pc}
700ad78a: 0000         	movs	r0, r0
700ad78c: 0000         	movs	r0, r0
700ad78e: 0000         	movs	r0, r0

700ad790 <ClockP_getTicks>:
; {
700ad790: b580         	push	{r7, lr}
;     return ((uint32_t)xTaskGetTickCount());
700ad792: f7ff fc95    	bl	0x700ad0c0 <xTaskGetTickCount> @ imm = #-0x6d6
700ad796: bd80         	pop	{r7, pc}
		...

700ad7a0 <UART_lld_errorCallback>:
; {
700ad7a0: b081         	sub	sp, #0x4
700ad7a2: 9000         	str	r0, [sp]
; }
700ad7a4: b001         	add	sp, #0x4
700ad7a6: 4770         	bx	lr
		...

700ad7b0 <Udma_ringAssertFnPointers>:
; {
700ad7b0: b081         	sub	sp, #0x4
700ad7b2: 9000         	str	r0, [sp]
;     return;
700ad7b4: b001         	add	sp, #0x4
700ad7b6: 4770         	bx	lr
		...

700ad7c0 <vApplicationIdleHook>:
; void vApplicationIdleHook(void) {
700ad7c0: b580         	push	{r7, lr}
;   vApplicationLoadHook();
700ad7c2: f7fc fa75    	bl	0x700a9cb0 <vApplicationLoadHook> @ imm = #-0x3b16
; }
700ad7c6: bd80         	pop	{r7, pc}
		...

700ad7d0 <Sciclient_rmPsGetMaxPsp>:
; {
700ad7d0: 2003         	movs	r0, #0x3
;     return SCICLIENT_PS_MAX_DEPTH;
700ad7d2: 4770         	bx	lr
		...

700ad7e0 <TaskP_yield>:
;     taskYIELD();
700ad7e0: df00         	svc	#0x0
; }
700ad7e2: 4770         	bx	lr
		...

700ad7f0 <main>:
;    return rtos_main_freertos();
700ad7f0: f7f7 f936    	bl	0x700a4a60 <rtos_main_freertos> @ imm = #-0x8d94
		...

700ad800 <tm_initialize>:
;    test_initialization_function();
700ad800: f7fa fa5e    	bl	0x700a7cc0 <tm_memory_allocation_initialize> @ imm = #-0x5b44
		...

700ad810 <tm_main_four>:
700ad810: f7ff fff6    	bl	0x700ad800 <tm_initialize> @ imm = #-0x14
		...

700ad820 <vPortConfigTimerForRunTimeStats>:
; }
700ad820: 4770         	bx	lr
		...
700ad82e: 0000         	movs	r0, r0
