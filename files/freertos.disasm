
.\files\freertos.out:	file format elf32-littlearm

Disassembly of section .vectors:

00000000 <_vectors>:
;         LDR pc, reset_addr          // Reset
       0: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x20 <reset_addr>
;         LDR pc, undefined_addr      // Undefined Instruction
       4: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x24 <undefined_addr>
;         LDR pc, svc_addr            // Software interrupt
       8: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x28 <svc_addr>
;         LDR pc, prefetch_abort_addr // Abort (prefetch)
       c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x2c <prefetch_abort_addr>
;         LDR pc, data_abort_addr     // Abort (data)
      10: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x30 <data_abort_addr>
;         LDR pc, reserved_addr       // rsvd
      14: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x34 <reserved_addr>
;         LDR pc, irq_addr            // IRQ
      18: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x38 <irq_addr>
;         LDR pc, fiq_addr            // FIQ
      1c: e59ff018     	ldr	pc, [pc, #0x18]         @ 0x3c <fiq_addr>

00000020 <reset_addr>:
      20: b4 11 0b 70  	.word	0x700b11b4

00000024 <undefined_addr>:
      24: c1 06 0b 70  	.word	0x700b06c1

00000028 <svc_addr>:
      28: ac 07 0b 70  	.word	0x700b07ac

0000002c <prefetch_abort_addr>:
      2c: 01 07 0b 70  	.word	0x700b0701

00000030 <data_abort_addr>:
      30: d0 09 0b 70  	.word	0x700b09d0

00000034 <reserved_addr>:
      34: 81 06 0b 70  	.word	0x700b0681

00000038 <irq_addr>:
      38: 1c 08 0b 70  	.word	0x700b081c

0000003c <fiq_addr>:
      3c: 11 05 0b 70  	.word	0x700b0511

Disassembly of section .text.hwi:

700afe00 <HwiP_enableInt>:
; {
700afe00: b580         	push	{r7, lr}
700afe02: b084         	sub	sp, #0x10
700afe04: 9003         	str	r0, [sp, #0xc]
;     Hwip_dataAndInstructionBarrier();
700afe06: f7ff ff53    	bl	0x700afcb0 <Hwip_dataAndInstructionBarrier> @ imm = #-0x15a
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_EN(intNum));
700afe0a: f642 10e8    	movw	r0, #0x29e8
700afe0e: f2c7 000b    	movt	r0, #0x700b
700afe12: 6801         	ldr	r1, [r0]
700afe14: 9803         	ldr	r0, [sp, #0xc]
700afe16: f400 70f0    	and	r0, r0, #0x1e0
700afe1a: 4408         	add	r0, r1
700afe1c: f500 6081    	add.w	r0, r0, #0x408
700afe20: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700afe22: 9803         	ldr	r0, [sp, #0xc]
700afe24: f000 001f    	and	r0, r0, #0x1f
700afe28: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700afe2a: 9901         	ldr	r1, [sp, #0x4]
700afe2c: 2001         	movs	r0, #0x1
700afe2e: 4088         	lsls	r0, r1
700afe30: 9902         	ldr	r1, [sp, #0x8]
700afe32: 6008         	str	r0, [r1]
; }
700afe34: b004         	add	sp, #0x10
700afe36: bd80         	pop	{r7, pc}
700afe38: bf00         	nop
700afe3a: bf00         	nop
700afe3c: bf00         	nop
700afe3e: bf00         	nop

700afe40 <HwiP_disableInt>:
; {
700afe40: b580         	push	{r7, lr}
700afe42: b084         	sub	sp, #0x10
700afe44: 9003         	str	r0, [sp, #0xc]
700afe46: 2000         	movs	r0, #0x0
;     uint32_t isEnable = 0;
700afe48: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(intNum));
700afe4a: f642 10e8    	movw	r0, #0x29e8
700afe4e: f2c7 000b    	movt	r0, #0x700b
700afe52: 6801         	ldr	r1, [r0]
700afe54: 9803         	ldr	r0, [sp, #0xc]
700afe56: f400 70f0    	and	r0, r0, #0x1e0
700afe5a: 4408         	add	r0, r1
700afe5c: f200 400c    	addw	r0, r0, #0x40c
700afe60: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700afe62: 9803         	ldr	r0, [sp, #0xc]
700afe64: f000 001f    	and	r0, r0, #0x1f
700afe68: 9001         	str	r0, [sp, #0x4]
;     if( (*addr & ((uint32_t)0x1 << bitPos))!=0U)
700afe6a: 9802         	ldr	r0, [sp, #0x8]
700afe6c: 6800         	ldr	r0, [r0]
700afe6e: 9901         	ldr	r1, [sp, #0x4]
700afe70: 40c8         	lsrs	r0, r1
700afe72: 07c0         	lsls	r0, r0, #0x1f
700afe74: b118         	cbz	r0, 0x700afe7e <HwiP_disableInt+0x3e> @ imm = #0x6
700afe76: e7ff         	b	0x700afe78 <HwiP_disableInt+0x38> @ imm = #-0x2
700afe78: 2001         	movs	r0, #0x1
;         isEnable = 1;
700afe7a: 9000         	str	r0, [sp]
;     }
700afe7c: e7ff         	b	0x700afe7e <HwiP_disableInt+0x3e> @ imm = #-0x2
;     *addr = ((uint32_t)0x1 << bitPos);
700afe7e: 9901         	ldr	r1, [sp, #0x4]
700afe80: 2001         	movs	r0, #0x1
700afe82: 4088         	lsls	r0, r1
700afe84: 9902         	ldr	r1, [sp, #0x8]
700afe86: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700afe88: f7ff ff12    	bl	0x700afcb0 <Hwip_dataAndInstructionBarrier> @ imm = #-0x1dc
;     return isEnable;
700afe8c: 9800         	ldr	r0, [sp]
700afe8e: b004         	add	sp, #0x10
700afe90: bd80         	pop	{r7, pc}
700afe92: bf00         	nop
700afe94: bf00         	nop
700afe96: bf00         	nop
700afe98: bf00         	nop
700afe9a: bf00         	nop
700afe9c: bf00         	nop
700afe9e: bf00         	nop

700afea0 <HwiP_restoreInt>:
; {
700afea0: b580         	push	{r7, lr}
700afea2: b082         	sub	sp, #0x8
700afea4: 9001         	str	r0, [sp, #0x4]
700afea6: 9100         	str	r1, [sp]
;     if(oldIntState!=0U)
700afea8: 9800         	ldr	r0, [sp]
700afeaa: b120         	cbz	r0, 0x700afeb6 <HwiP_restoreInt+0x16> @ imm = #0x8
700afeac: e7ff         	b	0x700afeae <HwiP_restoreInt+0xe> @ imm = #-0x2
;         HwiP_enableInt(intNum);
700afeae: 9801         	ldr	r0, [sp, #0x4]
700afeb0: f7ff ffa6    	bl	0x700afe00 <HwiP_enableInt> @ imm = #-0xb4
;     }
700afeb4: e003         	b	0x700afebe <HwiP_restoreInt+0x1e> @ imm = #0x6
;        (void) HwiP_disableInt(intNum);
700afeb6: 9801         	ldr	r0, [sp, #0x4]
700afeb8: f7ff ffc2    	bl	0x700afe40 <HwiP_disableInt> @ imm = #-0x7c
700afebc: e7ff         	b	0x700afebe <HwiP_restoreInt+0x1e> @ imm = #-0x2
; }
700afebe: b002         	add	sp, #0x8
700afec0: bd80         	pop	{r7, pc}
700afec2: bf00         	nop
700afec4: bf00         	nop
700afec6: bf00         	nop
700afec8: bf00         	nop
700afeca: bf00         	nop
700afecc: bf00         	nop
700afece: bf00         	nop

700afed0 <HwiP_clearInt>:
; {
700afed0: b083         	sub	sp, #0xc
700afed2: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_STS(intNum));
700afed4: f642 10e8    	movw	r0, #0x29e8
700afed8: f2c7 000b    	movt	r0, #0x700b
700afedc: 6801         	ldr	r1, [r0]
700afede: 9802         	ldr	r0, [sp, #0x8]
700afee0: f400 70f0    	and	r0, r0, #0x1e0
700afee4: 4408         	add	r0, r1
700afee6: f200 4004    	addw	r0, r0, #0x404
700afeea: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700afeec: 9802         	ldr	r0, [sp, #0x8]
700afeee: f000 001f    	and	r0, r0, #0x1f
700afef2: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)0x1 << bitPos);
700afef4: 9900         	ldr	r1, [sp]
700afef6: 2001         	movs	r0, #0x1
700afef8: 4088         	lsls	r0, r1
700afefa: 9901         	ldr	r1, [sp, #0x4]
700afefc: 6008         	str	r0, [r1]
; }
700afefe: b003         	add	sp, #0xc
700aff00: 4770         	bx	lr
700aff02: bf00         	nop
700aff04: bf00         	nop
700aff06: bf00         	nop
700aff08: bf00         	nop
700aff0a: bf00         	nop
700aff0c: bf00         	nop
700aff0e: bf00         	nop

700aff10 <HwiP_post>:
; {
700aff10: b580         	push	{r7, lr}
700aff12: b084         	sub	sp, #0x10
700aff14: 9003         	str	r0, [sp, #0xc]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_RAW(intNum));
700aff16: f642 10e8    	movw	r0, #0x29e8
700aff1a: f2c7 000b    	movt	r0, #0x700b
700aff1e: 6801         	ldr	r1, [r0]
700aff20: 9803         	ldr	r0, [sp, #0xc]
700aff22: f400 70f0    	and	r0, r0, #0x1e0
700aff26: 4408         	add	r0, r1
700aff28: f500 6080    	add.w	r0, r0, #0x400
700aff2c: 9002         	str	r0, [sp, #0x8]
;     bitPos = VIM_BIT_POS(intNum);
700aff2e: 9803         	ldr	r0, [sp, #0xc]
700aff30: f000 001f    	and	r0, r0, #0x1f
700aff34: 9001         	str	r0, [sp, #0x4]
;     *addr = ((uint32_t)0x1 << bitPos);
700aff36: 9901         	ldr	r1, [sp, #0x4]
700aff38: 2001         	movs	r0, #0x1
700aff3a: 4088         	lsls	r0, r1
700aff3c: 9902         	ldr	r1, [sp, #0x8]
700aff3e: 6008         	str	r0, [r1]
;     Hwip_dataAndInstructionBarrier();
700aff40: f7ff feb6    	bl	0x700afcb0 <Hwip_dataAndInstructionBarrier> @ imm = #-0x294
; }
700aff44: b004         	add	sp, #0x10
700aff46: bd80         	pop	{r7, pc}
700aff48: bf00         	nop
700aff4a: bf00         	nop
700aff4c: bf00         	nop
700aff4e: bf00         	nop

700aff50 <HwiP_Params_init>:
; {
700aff50: b081         	sub	sp, #0x4
700aff52: 9000         	str	r0, [sp]
;     params->intNum = 0;
700aff54: 9900         	ldr	r1, [sp]
700aff56: 2000         	movs	r0, #0x0
700aff58: 6008         	str	r0, [r1]
;     params->callback = NULL;
700aff5a: 9900         	ldr	r1, [sp]
700aff5c: 6048         	str	r0, [r1, #0x4]
;     params->args = NULL;
700aff5e: 9900         	ldr	r1, [sp]
700aff60: 6088         	str	r0, [r1, #0x8]
;     params->eventId = 0; /* NOT USED */
700aff62: 9900         	ldr	r1, [sp]
700aff64: 8188         	strh	r0, [r1, #0xc]
;     params->priority = (HwiP_MAX_PRIORITY-1U);
700aff66: 9a00         	ldr	r2, [sp]
700aff68: 210f         	movs	r1, #0xf
700aff6a: 7391         	strb	r1, [r2, #0xe]
;     params->isFIQ = 0;
700aff6c: 9900         	ldr	r1, [sp]
700aff6e: 73c8         	strb	r0, [r1, #0xf]
;     params->isPulse = 0;
700aff70: 9900         	ldr	r1, [sp]
700aff72: 7408         	strb	r0, [r1, #0x10]
; }
700aff74: b001         	add	sp, #0x4
700aff76: 4770         	bx	lr
700aff78: bf00         	nop
700aff7a: bf00         	nop
700aff7c: bf00         	nop
700aff7e: bf00         	nop

700aff80 <HwiP_construct>:
; {
700aff80: b580         	push	{r7, lr}
700aff82: b084         	sub	sp, #0x10
700aff84: 9003         	str	r0, [sp, #0xc]
700aff86: 9102         	str	r1, [sp, #0x8]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700aff88: 9803         	ldr	r0, [sp, #0xc]
700aff8a: 9001         	str	r0, [sp, #0x4]
700aff8c: 2001         	movs	r0, #0x1
;     DebugP_assertNoLog( sizeof(HwiP_Struct) <= sizeof(HwiP_Object) );
700aff8e: f001 f9a7    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x134e
;     DebugP_assertNoLog( params->callback != NULL );
700aff92: 9802         	ldr	r0, [sp, #0x8]
700aff94: 6840         	ldr	r0, [r0, #0x4]
700aff96: 2800         	cmp	r0, #0x0
700aff98: bf18         	it	ne
700aff9a: 2001         	movne	r0, #0x1
700aff9c: f001 f9a0    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x1340
;     DebugP_assertNoLog( params->intNum < HwiP_MAX_INTERRUPTS );
700affa0: 9802         	ldr	r0, [sp, #0x8]
700affa2: 6801         	ldr	r1, [r0]
700affa4: 2000         	movs	r0, #0x0
700affa6: 9000         	str	r0, [sp]
700affa8: f5b1 7f00    	cmp.w	r1, #0x200
700affac: bf38         	it	lo
700affae: 2001         	movlo	r0, #0x1
700affb0: f001 f996    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x132c
700affb4: 9800         	ldr	r0, [sp]
;     DebugP_assertNoLog( params->priority < HwiP_MAX_PRIORITY );
700affb6: 9902         	ldr	r1, [sp, #0x8]
700affb8: 7b89         	ldrb	r1, [r1, #0xe]
700affba: 2910         	cmp	r1, #0x10
700affbc: bf38         	it	lo
700affbe: 2001         	movlo	r0, #0x1
700affc0: f001 f98e    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x131c
;     (void) HwiP_disableInt(params->intNum);
700affc4: 9802         	ldr	r0, [sp, #0x8]
700affc6: 6800         	ldr	r0, [r0]
700affc8: f7ff ff3a    	bl	0x700afe40 <HwiP_disableInt> @ imm = #-0x18c
;     HwiP_clearInt(params->intNum);
700affcc: 9802         	ldr	r0, [sp, #0x8]
700affce: 6800         	ldr	r0, [r0]
700affd0: f7ff ff7e    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x104
;     HwiP_setAsFIQ(params->intNum, params->isFIQ);
700affd4: 9902         	ldr	r1, [sp, #0x8]
700affd6: 6808         	ldr	r0, [r1]
700affd8: 7bc9         	ldrb	r1, [r1, #0xf]
700affda: f000 f841    	bl	0x700b0060 <HwiP_setAsFIQ> @ imm = #0x82
;     HwiP_setPri(params->intNum, params->priority);
700affde: 9902         	ldr	r1, [sp, #0x8]
700affe0: 6808         	ldr	r0, [r1]
700affe2: 7b89         	ldrb	r1, [r1, #0xe]
700affe4: f000 f86c    	bl	0x700b00c0 <HwiP_setPri> @ imm = #0xd8
;     HwiP_setAsPulse(params->intNum, params->isPulse);
700affe8: 9902         	ldr	r1, [sp, #0x8]
700affea: 6808         	ldr	r0, [r1]
700affec: 7c09         	ldrb	r1, [r1, #0x10]
700affee: f000 f87f    	bl	0x700b00f0 <HwiP_setAsPulse> @ imm = #0xfe
;     if(params->isFIQ != 0U)
700afff2: 9802         	ldr	r0, [sp, #0x8]
700afff4: 7bc0         	ldrb	r0, [r0, #0xf]
700afff6: b148         	cbz	r0, 0x700b000c <HwiP_construct+0x8c> @ imm = #0x12
700afff8: e7ff         	b	0x700afffa <HwiP_construct+0x7a> @ imm = #-0x2
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_fiq_handler);
700afffa: 9802         	ldr	r0, [sp, #0x8]
700afffc: 6800         	ldr	r0, [r0]
700afffe: f240 5111    	movw	r1, #0x511
700b0002: f2c7 010b    	movt	r1, #0x700b
700b0006: f000 f8a3    	bl	0x700b0150 <HwiP_setVecAddr> @ imm = #0x146
;     }
700b000a: e008         	b	0x700b001e <HwiP_construct+0x9e> @ imm = #0x10
;         HwiP_setVecAddr(params->intNum, (uintptr_t)HwiP_irq_handler);
700b000c: 9802         	ldr	r0, [sp, #0x8]
700b000e: 6800         	ldr	r0, [r0]
700b0010: f640 011c    	movw	r1, #0x81c
700b0014: f2c7 010b    	movt	r1, #0x700b
700b0018: f000 f89a    	bl	0x700b0150 <HwiP_setVecAddr> @ imm = #0x134
700b001c: e7ff         	b	0x700b001e <HwiP_construct+0x9e> @ imm = #-0x2
;     gHwiCtrl.isr[params->intNum] = params->callback;
700b001e: 9802         	ldr	r0, [sp, #0x8]
700b0020: 6802         	ldr	r2, [r0]
700b0022: 6840         	ldr	r0, [r0, #0x4]
700b0024: f240 0100    	movw	r1, #0x0
700b0028: f2c7 0108    	movt	r1, #0x7008
700b002c: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[params->intNum] = params->args;
700b0030: 9802         	ldr	r0, [sp, #0x8]
700b0032: 6802         	ldr	r2, [r0]
700b0034: 6880         	ldr	r0, [r0, #0x8]
700b0036: eb01 0182    	add.w	r1, r1, r2, lsl #2
700b003a: f8c1 0800    	str.w	r0, [r1, #0x800]
;     obj->intNum = params->intNum;
700b003e: 9802         	ldr	r0, [sp, #0x8]
700b0040: 6800         	ldr	r0, [r0]
700b0042: 9901         	ldr	r1, [sp, #0x4]
700b0044: 6008         	str	r0, [r1]
;     HwiP_enableInt(params->intNum);
700b0046: 9802         	ldr	r0, [sp, #0x8]
700b0048: 6800         	ldr	r0, [r0]
700b004a: f7ff fed9    	bl	0x700afe00 <HwiP_enableInt> @ imm = #-0x24e
700b004e: 2000         	movs	r0, #0x0
;     return SystemP_SUCCESS;
700b0050: b004         	add	sp, #0x10
700b0052: bd80         	pop	{r7, pc}
700b0054: bf00         	nop
700b0056: bf00         	nop
700b0058: bf00         	nop
700b005a: bf00         	nop
700b005c: bf00         	nop
700b005e: bf00         	nop

700b0060 <HwiP_setAsFIQ>:
; {
700b0060: b084         	sub	sp, #0x10
700b0062: 9003         	str	r0, [sp, #0xc]
700b0064: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(intNum));
700b0066: f642 10e8    	movw	r0, #0x29e8
700b006a: f2c7 000b    	movt	r0, #0x700b
700b006e: 6801         	ldr	r1, [r0]
700b0070: 9803         	ldr	r0, [sp, #0xc]
700b0072: f400 70f0    	and	r0, r0, #0x1e0
700b0076: 4408         	add	r0, r1
700b0078: f500 6083    	add.w	r0, r0, #0x418
700b007c: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700b007e: 9803         	ldr	r0, [sp, #0xc]
700b0080: f000 001f    	and	r0, r0, #0x1f
700b0084: 9000         	str	r0, [sp]
;     if(isFIQ != 0U)
700b0086: 9802         	ldr	r0, [sp, #0x8]
700b0088: b148         	cbz	r0, 0x700b009e <HwiP_setAsFIQ+0x3e> @ imm = #0x12
700b008a: e7ff         	b	0x700b008c <HwiP_setAsFIQ+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700b008c: 9900         	ldr	r1, [sp]
700b008e: 2001         	movs	r0, #0x1
700b0090: fa00 f201    	lsl.w	r2, r0, r1
700b0094: 9901         	ldr	r1, [sp, #0x4]
700b0096: 6808         	ldr	r0, [r1]
700b0098: 4310         	orrs	r0, r2
700b009a: 6008         	str	r0, [r1]
;     }
700b009c: e008         	b	0x700b00b0 <HwiP_setAsFIQ+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700b009e: 9900         	ldr	r1, [sp]
700b00a0: 2001         	movs	r0, #0x1
700b00a2: fa00 f201    	lsl.w	r2, r0, r1
700b00a6: 9901         	ldr	r1, [sp, #0x4]
700b00a8: 6808         	ldr	r0, [r1]
700b00aa: 4390         	bics	r0, r2
700b00ac: 6008         	str	r0, [r1]
700b00ae: e7ff         	b	0x700b00b0 <HwiP_setAsFIQ+0x50> @ imm = #-0x2
; }
700b00b0: b004         	add	sp, #0x10
700b00b2: 4770         	bx	lr
700b00b4: bf00         	nop
700b00b6: bf00         	nop
700b00b8: bf00         	nop
700b00ba: bf00         	nop
700b00bc: bf00         	nop
700b00be: bf00         	nop

700b00c0 <HwiP_setPri>:
; {
700b00c0: b083         	sub	sp, #0xc
700b00c2: 9002         	str	r0, [sp, #0x8]
700b00c4: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_PRI(intNum));
700b00c6: f642 10e8    	movw	r0, #0x29e8
700b00ca: f2c7 000b    	movt	r0, #0x700b
700b00ce: 6800         	ldr	r0, [r0]
700b00d0: 9902         	ldr	r1, [sp, #0x8]
700b00d2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700b00d6: f500 5080    	add.w	r0, r0, #0x1000
700b00da: 9000         	str	r0, [sp]
;     *addr = (priority & 0xFu);
700b00dc: 9801         	ldr	r0, [sp, #0x4]
700b00de: f000 000f    	and	r0, r0, #0xf
700b00e2: 9900         	ldr	r1, [sp]
700b00e4: 6008         	str	r0, [r1]
; }
700b00e6: b003         	add	sp, #0xc
700b00e8: 4770         	bx	lr
700b00ea: bf00         	nop
700b00ec: bf00         	nop
700b00ee: bf00         	nop

700b00f0 <HwiP_setAsPulse>:
; {
700b00f0: b084         	sub	sp, #0x10
700b00f2: 9003         	str	r0, [sp, #0xc]
700b00f4: 9102         	str	r1, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700b00f6: f642 10e8    	movw	r0, #0x29e8
700b00fa: f2c7 000b    	movt	r0, #0x700b
700b00fe: 6801         	ldr	r1, [r0]
700b0100: 9803         	ldr	r0, [sp, #0xc]
700b0102: f400 70f0    	and	r0, r0, #0x1e0
700b0106: 4408         	add	r0, r1
700b0108: f200 401c    	addw	r0, r0, #0x41c
700b010c: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700b010e: 9803         	ldr	r0, [sp, #0xc]
700b0110: f000 001f    	and	r0, r0, #0x1f
700b0114: 9000         	str	r0, [sp]
;     if(isPulse != 0U)
700b0116: 9802         	ldr	r0, [sp, #0x8]
700b0118: b148         	cbz	r0, 0x700b012e <HwiP_setAsPulse+0x3e> @ imm = #0x12
700b011a: e7ff         	b	0x700b011c <HwiP_setAsPulse+0x2c> @ imm = #-0x2
;         *addr |= ((uint32_t)0x1u << bitPos);
700b011c: 9900         	ldr	r1, [sp]
700b011e: 2001         	movs	r0, #0x1
700b0120: fa00 f201    	lsl.w	r2, r0, r1
700b0124: 9901         	ldr	r1, [sp, #0x4]
700b0126: 6808         	ldr	r0, [r1]
700b0128: 4310         	orrs	r0, r2
700b012a: 6008         	str	r0, [r1]
;     }
700b012c: e008         	b	0x700b0140 <HwiP_setAsPulse+0x50> @ imm = #0x10
;         *addr &= ~(0x1u << bitPos);
700b012e: 9900         	ldr	r1, [sp]
700b0130: 2001         	movs	r0, #0x1
700b0132: fa00 f201    	lsl.w	r2, r0, r1
700b0136: 9901         	ldr	r1, [sp, #0x4]
700b0138: 6808         	ldr	r0, [r1]
700b013a: 4390         	bics	r0, r2
700b013c: 6008         	str	r0, [r1]
700b013e: e7ff         	b	0x700b0140 <HwiP_setAsPulse+0x50> @ imm = #-0x2
; }
700b0140: b004         	add	sp, #0x10
700b0142: 4770         	bx	lr
700b0144: bf00         	nop
700b0146: bf00         	nop
700b0148: bf00         	nop
700b014a: bf00         	nop
700b014c: bf00         	nop
700b014e: bf00         	nop

700b0150 <HwiP_setVecAddr>:
; {
700b0150: b083         	sub	sp, #0xc
700b0152: 9002         	str	r0, [sp, #0x8]
700b0154: 9101         	str	r1, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_VEC(intNum));
700b0156: f642 10e8    	movw	r0, #0x29e8
700b015a: f2c7 000b    	movt	r0, #0x700b
700b015e: 6800         	ldr	r0, [r0]
700b0160: 9902         	ldr	r1, [sp, #0x8]
700b0162: eb00 0081    	add.w	r0, r0, r1, lsl #2
700b0166: f500 5000    	add.w	r0, r0, #0x2000
700b016a: 9000         	str	r0, [sp]
;     *addr = ((uint32_t)vecAddr & 0xFFFFFFFCU);
700b016c: 9801         	ldr	r0, [sp, #0x4]
700b016e: f020 0003    	bic	r0, r0, #0x3
700b0172: 9900         	ldr	r1, [sp]
700b0174: 6008         	str	r0, [r1]
; }
700b0176: b003         	add	sp, #0xc
700b0178: 4770         	bx	lr
700b017a: bf00         	nop
700b017c: bf00         	nop
700b017e: bf00         	nop

700b0180 <HwiP_destruct>:
; {
700b0180: b580         	push	{r7, lr}
700b0182: b084         	sub	sp, #0x10
700b0184: 9003         	str	r0, [sp, #0xc]
;     HwiP_Struct *obj = (HwiP_Struct *)handle;
700b0186: 9803         	ldr	r0, [sp, #0xc]
700b0188: 9002         	str	r0, [sp, #0x8]
;    (void) HwiP_disableInt(obj->intNum);
700b018a: 9802         	ldr	r0, [sp, #0x8]
700b018c: 6800         	ldr	r0, [r0]
700b018e: f7ff fe57    	bl	0x700afe40 <HwiP_disableInt> @ imm = #-0x352
;     HwiP_clearInt(obj->intNum);
700b0192: 9802         	ldr	r0, [sp, #0x8]
700b0194: 6800         	ldr	r0, [r0]
700b0196: f7ff fe9b    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x2ca
;     HwiP_setAsFIQ(obj->intNum, 0);
700b019a: 9802         	ldr	r0, [sp, #0x8]
700b019c: 6800         	ldr	r0, [r0]
700b019e: 2100         	movs	r1, #0x0
700b01a0: 9101         	str	r1, [sp, #0x4]
700b01a2: f7ff ff5d    	bl	0x700b0060 <HwiP_setAsFIQ> @ imm = #-0x146
;     HwiP_setPri(obj->intNum, HwiP_MAX_PRIORITY-1U);
700b01a6: 9802         	ldr	r0, [sp, #0x8]
700b01a8: 6800         	ldr	r0, [r0]
700b01aa: 210f         	movs	r1, #0xf
700b01ac: f7ff ff88    	bl	0x700b00c0 <HwiP_setPri> @ imm = #-0xf0
700b01b0: 9901         	ldr	r1, [sp, #0x4]
;     HwiP_setAsPulse(obj->intNum, 0);
700b01b2: 9802         	ldr	r0, [sp, #0x8]
700b01b4: 6800         	ldr	r0, [r0]
700b01b6: f7ff ff9b    	bl	0x700b00f0 <HwiP_setAsPulse> @ imm = #-0xca
;     HwiP_setVecAddr(obj->intNum, (uintptr_t)HwiP_irq_handler);
700b01ba: 9802         	ldr	r0, [sp, #0x8]
700b01bc: 6800         	ldr	r0, [r0]
700b01be: f640 011c    	movw	r1, #0x81c
700b01c2: f2c7 010b    	movt	r1, #0x700b
700b01c6: f7ff ffc3    	bl	0x700b0150 <HwiP_setVecAddr> @ imm = #-0x7a
700b01ca: 9801         	ldr	r0, [sp, #0x4]
;     gHwiCtrl.isr[obj->intNum] = NULL;
700b01cc: 9902         	ldr	r1, [sp, #0x8]
700b01ce: 680a         	ldr	r2, [r1]
700b01d0: f240 0100    	movw	r1, #0x0
700b01d4: f2c7 0108    	movt	r1, #0x7008
700b01d8: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     gHwiCtrl.isrArgs[obj->intNum] = NULL;
700b01dc: 9a02         	ldr	r2, [sp, #0x8]
700b01de: 6812         	ldr	r2, [r2]
700b01e0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700b01e4: f8c1 0800    	str.w	r0, [r1, #0x800]
; }
700b01e8: b004         	add	sp, #0x10
700b01ea: bd80         	pop	{r7, pc}
700b01ec: bf00         	nop
700b01ee: bf00         	nop

700b01f0 <HwiP_init>:
; {
700b01f0: b580         	push	{r7, lr}
700b01f2: b084         	sub	sp, #0x10
;     (void) HwiP_disable();
700b01f4: f000 ebb4    	blx	0x700b0960 <HwiP_disable> @ imm = #0x768
;     (void) HwiP_disableFIQ();
700b01f8: f000 ebba    	blx	0x700b0970 <HwiP_disableFIQ> @ imm = #0x774
;     DebugP_assertNoLog(gHwiConfig.intcBaseAddr != 0U);
700b01fc: f642 10e8    	movw	r0, #0x29e8
700b0200: f2c7 000b    	movt	r0, #0x700b
700b0204: 6800         	ldr	r0, [r0]
700b0206: 2800         	cmp	r0, #0x0
700b0208: bf18         	it	ne
700b020a: 2001         	movne	r0, #0x1
700b020c: f001 f868    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x10d0
;     gHwiCtrl.spuriousIRQCount = 0;
700b0210: f240 0100    	movw	r1, #0x0
700b0214: f2c7 0108    	movt	r1, #0x7008
700b0218: f44f 5280    	mov.w	r2, #0x1000
700b021c: 2000         	movs	r0, #0x0
700b021e: 5088         	str	r0, [r1, r2]
700b0220: f241 0204    	movw	r2, #0x1004
;     gHwiCtrl.spuriousFIQCount = 0;
700b0224: 5088         	str	r0, [r1, r2]
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700b0226: 9003         	str	r0, [sp, #0xc]
700b0228: e7ff         	b	0x700b022a <HwiP_init+0x3a> @ imm = #-0x2
700b022a: 9903         	ldr	r1, [sp, #0xc]
700b022c: 2000         	movs	r0, #0x0
700b022e: ebb0 2f51    	cmp.w	r0, r1, lsr #9
700b0232: d11d         	bne	0x700b0270 <HwiP_init+0x80> @ imm = #0x3a
700b0234: e7ff         	b	0x700b0236 <HwiP_init+0x46> @ imm = #-0x2
;         gHwiCtrl.isr[i] = NULL;
700b0236: 9a03         	ldr	r2, [sp, #0xc]
700b0238: f240 0100    	movw	r1, #0x0
700b023c: f2c7 0108    	movt	r1, #0x7008
700b0240: 2000         	movs	r0, #0x0
700b0242: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gHwiCtrl.isrArgs[i] = NULL;
700b0246: 9a03         	ldr	r2, [sp, #0xc]
700b0248: eb01 0182    	add.w	r1, r1, r2, lsl #2
700b024c: f8c1 0800    	str.w	r0, [r1, #0x800]
;         HwiP_setPri(i, 0xF);
700b0250: 9803         	ldr	r0, [sp, #0xc]
700b0252: 210f         	movs	r1, #0xf
700b0254: f7ff ff34    	bl	0x700b00c0 <HwiP_setPri> @ imm = #-0x198
;         HwiP_setVecAddr(i, (uintptr_t)HwiP_irq_handler);
700b0258: 9803         	ldr	r0, [sp, #0xc]
700b025a: f640 011c    	movw	r1, #0x81c
700b025e: f2c7 010b    	movt	r1, #0x700b
700b0262: f7ff ff75    	bl	0x700b0150 <HwiP_setVecAddr> @ imm = #-0x116
;     }
700b0266: e7ff         	b	0x700b0268 <HwiP_init+0x78> @ imm = #-0x2
;     for(i=0; i<HwiP_MAX_INTERRUPTS; i++)
700b0268: 9803         	ldr	r0, [sp, #0xc]
700b026a: 3001         	adds	r0, #0x1
700b026c: 9003         	str	r0, [sp, #0xc]
700b026e: e7dc         	b	0x700b022a <HwiP_init+0x3a> @ imm = #-0x48
700b0270: 2000         	movs	r0, #0x0
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700b0272: 9003         	str	r0, [sp, #0xc]
700b0274: e7ff         	b	0x700b0276 <HwiP_init+0x86> @ imm = #-0x2
700b0276: 9803         	ldr	r0, [sp, #0xc]
700b0278: 280f         	cmp	r0, #0xf
700b027a: d838         	bhi	0x700b02ee <HwiP_init+0xfe> @ imm = #0x70
700b027c: e7ff         	b	0x700b027e <HwiP_init+0x8e> @ imm = #-0x2
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_DIS(i*INTERRUPT_VALUE));
700b027e: f642 11e8    	movw	r1, #0x29e8
700b0282: f2c7 010b    	movt	r1, #0x700b
700b0286: 6808         	ldr	r0, [r1]
700b0288: 9a03         	ldr	r2, [sp, #0xc]
700b028a: f002 020f    	and	r2, r2, #0xf
700b028e: eb00 1042    	add.w	r0, r0, r2, lsl #5
700b0292: f200 400c    	addw	r0, r0, #0x40c
700b0296: 9002         	str	r0, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700b0298: 9a02         	ldr	r2, [sp, #0x8]
700b029a: f04f 30ff    	mov.w	r0, #0xffffffff
700b029e: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_STS(i*INTERRUPT_VALUE));
700b02a0: 680a         	ldr	r2, [r1]
700b02a2: 9b03         	ldr	r3, [sp, #0xc]
700b02a4: f003 030f    	and	r3, r3, #0xf
700b02a8: eb02 1243    	add.w	r2, r2, r3, lsl #5
700b02ac: f202 4204    	addw	r2, r2, #0x404
700b02b0: 9202         	str	r2, [sp, #0x8]
;         *addr = 0xFFFFFFFFu;
700b02b2: 9a02         	ldr	r2, [sp, #0x8]
700b02b4: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(i*INTERRUPT_VALUE));
700b02b6: 6808         	ldr	r0, [r1]
700b02b8: 9a03         	ldr	r2, [sp, #0xc]
700b02ba: f002 020f    	and	r2, r2, #0xf
700b02be: eb00 1042    	add.w	r0, r0, r2, lsl #5
700b02c2: f200 401c    	addw	r0, r0, #0x41c
700b02c6: 9002         	str	r0, [sp, #0x8]
;         *addr = 0x0u;
700b02c8: 9a02         	ldr	r2, [sp, #0x8]
700b02ca: 2000         	movs	r0, #0x0
700b02cc: 6010         	str	r0, [r2]
;         addr = (uint32_t*)(gHwiConfig.intcBaseAddr + VIM_INT_MAP(i*INTERRUPT_VALUE));
700b02ce: 6809         	ldr	r1, [r1]
700b02d0: 9a03         	ldr	r2, [sp, #0xc]
700b02d2: f002 020f    	and	r2, r2, #0xf
700b02d6: eb01 1142    	add.w	r1, r1, r2, lsl #5
700b02da: f501 6183    	add.w	r1, r1, #0x418
700b02de: 9102         	str	r1, [sp, #0x8]
;         *addr = 0x0u;
700b02e0: 9902         	ldr	r1, [sp, #0x8]
700b02e2: 6008         	str	r0, [r1]
;     }
700b02e4: e7ff         	b	0x700b02e6 <HwiP_init+0xf6> @ imm = #-0x2
;     for(i=0; i<(HwiP_MAX_INTERRUPTS/INTERRUPT_VALUE); i++)
700b02e6: 9803         	ldr	r0, [sp, #0xc]
700b02e8: 3001         	adds	r0, #0x1
700b02ea: 9003         	str	r0, [sp, #0xc]
700b02ec: e7c3         	b	0x700b0276 <HwiP_init+0x86> @ imm = #-0x7a
;         gdummy = HwiP_getIRQVecAddr();
700b02ee: f000 f817    	bl	0x700b0320 <HwiP_getIRQVecAddr> @ imm = #0x2e
700b02f2: f245 118c    	movw	r1, #0x518c
700b02f6: f2c7 0108    	movt	r1, #0x7008
700b02fa: 9100         	str	r1, [sp]
700b02fc: 6008         	str	r0, [r1]
;         gdummy = HwiP_getFIQVecAddr();
700b02fe: f000 f81f    	bl	0x700b0340 <HwiP_getFIQVecAddr> @ imm = #0x3e
700b0302: 9900         	ldr	r1, [sp]
700b0304: 6008         	str	r0, [r1]
700b0306: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700b0308: 9001         	str	r0, [sp, #0x4]
700b030a: f000 f829    	bl	0x700b0360 <HwiP_ackIRQ> @ imm = #0x52
700b030e: 9801         	ldr	r0, [sp, #0x4]
;         HwiP_ackFIQ(0);
700b0310: f000 f836    	bl	0x700b0380 <HwiP_ackFIQ> @ imm = #0x6c
;     HwiP_enableVIC();
700b0314: f000 eb48    	blx	0x700b09a8 <HwiP_enableVIC> @ imm = #0x690
;     HwiP_enableFIQ();
700b0318: f000 eb3a    	blx	0x700b0990 <HwiP_enableFIQ> @ imm = #0x674
; }
700b031c: b004         	add	sp, #0x10
700b031e: bd80         	pop	{r7, pc}

700b0320 <HwiP_getIRQVecAddr>:
; {
700b0320: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b0322: f642 10e8    	movw	r0, #0x29e8
700b0326: f2c7 000b    	movt	r0, #0x700b
700b032a: 6800         	ldr	r0, [r0]
700b032c: 3018         	adds	r0, #0x18
700b032e: 9000         	str	r0, [sp]
;     return *addr;
700b0330: 9800         	ldr	r0, [sp]
700b0332: 6800         	ldr	r0, [r0]
700b0334: b001         	add	sp, #0x4
700b0336: 4770         	bx	lr
700b0338: bf00         	nop
700b033a: bf00         	nop
700b033c: bf00         	nop
700b033e: bf00         	nop

700b0340 <HwiP_getFIQVecAddr>:
; {
700b0340: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0342: f642 10e8    	movw	r0, #0x29e8
700b0346: f2c7 000b    	movt	r0, #0x700b
700b034a: 6800         	ldr	r0, [r0]
700b034c: 301c         	adds	r0, #0x1c
700b034e: 9000         	str	r0, [sp]
;     return *addr;
700b0350: 9800         	ldr	r0, [sp]
700b0352: 6800         	ldr	r0, [r0]
700b0354: b001         	add	sp, #0x4
700b0356: 4770         	bx	lr
700b0358: bf00         	nop
700b035a: bf00         	nop
700b035c: bf00         	nop
700b035e: bf00         	nop

700b0360 <HwiP_ackIRQ>:
; {
700b0360: b082         	sub	sp, #0x8
700b0362: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b0364: f642 10e8    	movw	r0, #0x29e8
700b0368: f2c7 000b    	movt	r0, #0x700b
700b036c: 6800         	ldr	r0, [r0]
700b036e: 3018         	adds	r0, #0x18
700b0370: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0372: 9801         	ldr	r0, [sp, #0x4]
700b0374: 9900         	ldr	r1, [sp]
700b0376: 6008         	str	r0, [r1]
; }
700b0378: b002         	add	sp, #0x8
700b037a: 4770         	bx	lr
700b037c: bf00         	nop
700b037e: bf00         	nop

700b0380 <HwiP_ackFIQ>:
; {
700b0380: b082         	sub	sp, #0x8
700b0382: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0384: f642 10e8    	movw	r0, #0x29e8
700b0388: f2c7 000b    	movt	r0, #0x700b
700b038c: 6800         	ldr	r0, [r0]
700b038e: 301c         	adds	r0, #0x1c
700b0390: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0392: 9801         	ldr	r0, [sp, #0x4]
700b0394: 9900         	ldr	r1, [sp]
700b0396: 6008         	str	r0, [r1]
; }
700b0398: b002         	add	sp, #0x8
700b039a: 4770         	bx	lr
700b039c: bf00         	nop
700b039e: bf00         	nop

700b03a0 <HwiP_inISR>:
; {
700b03a0: b580         	push	{r7, lr}
700b03a2: b082         	sub	sp, #0x8
;     uint32_t mode = (HwiP_getCPSR() & 0x1FU);
700b03a4: f000 eb10    	blx	0x700b09c8 <HwiP_getCPSR> @ imm = #0x620
700b03a8: f000 001f    	and	r0, r0, #0x1f
700b03ac: 9001         	str	r0, [sp, #0x4]
700b03ae: 2000         	movs	r0, #0x0
;     uint32_t result =0;
700b03b0: 9000         	str	r0, [sp]
;     if(mode != ARMV7R_SYSTEM_MODE)
700b03b2: 9801         	ldr	r0, [sp, #0x4]
700b03b4: 281f         	cmp	r0, #0x1f
700b03b6: d003         	beq	0x700b03c0 <HwiP_inISR+0x20> @ imm = #0x6
700b03b8: e7ff         	b	0x700b03ba <HwiP_inISR+0x1a> @ imm = #-0x2
700b03ba: 2001         	movs	r0, #0x1
;          result= 1;
700b03bc: 9000         	str	r0, [sp]
;     }
700b03be: e7ff         	b	0x700b03c0 <HwiP_inISR+0x20> @ imm = #-0x2
;     return result;
700b03c0: 9800         	ldr	r0, [sp]
700b03c2: b002         	add	sp, #0x8
700b03c4: bd80         	pop	{r7, pc}
		...
700b03ce: 0000         	movs	r0, r0

700b03d0 <HwiP_irq_handler_c>:
; {
700b03d0: b580         	push	{r7, lr}
700b03d2: b086         	sub	sp, #0x18
700b03d4: a804         	add	r0, sp, #0x10
;     status = HwiP_getIRQ(&intNum);
700b03d6: f000 f843    	bl	0x700b0460 <HwiP_getIRQ> @ imm = #0x86
700b03da: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700b03dc: 9805         	ldr	r0, [sp, #0x14]
700b03de: bb78         	cbnz	r0, 0x700b0440 <HwiP_irq_handler_c+0x70> @ imm = #0x5e
700b03e0: e7ff         	b	0x700b03e2 <HwiP_irq_handler_c+0x12> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700b03e2: 9804         	ldr	r0, [sp, #0x10]
700b03e4: f000 f864    	bl	0x700b04b0 <HwiP_isPulse> @ imm = #0xc8
700b03e8: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700b03ea: 9803         	ldr	r0, [sp, #0xc]
700b03ec: b120         	cbz	r0, 0x700b03f8 <HwiP_irq_handler_c+0x28> @ imm = #0x8
700b03ee: e7ff         	b	0x700b03f0 <HwiP_irq_handler_c+0x20> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b03f0: 9804         	ldr	r0, [sp, #0x10]
700b03f2: f7ff fd6d    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x526
;         }
700b03f6: e7ff         	b	0x700b03f8 <HwiP_irq_handler_c+0x28> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700b03f8: 9904         	ldr	r1, [sp, #0x10]
700b03fa: f240 0000    	movw	r0, #0x0
700b03fe: f2c7 0008    	movt	r0, #0x7008
700b0402: f850 1021    	ldr.w	r1, [r0, r1, lsl #2]
700b0406: 9102         	str	r1, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700b0408: 9904         	ldr	r1, [sp, #0x10]
700b040a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700b040e: f8d0 0800    	ldr.w	r0, [r0, #0x800]
700b0412: 9001         	str	r0, [sp, #0x4]
;         HwiP_enable();
700b0414: f000 eab4    	blx	0x700b0980 <HwiP_enable> @ imm = #0x568
;         if(isr!=NULL)
700b0418: 9802         	ldr	r0, [sp, #0x8]
700b041a: b120         	cbz	r0, 0x700b0426 <HwiP_irq_handler_c+0x56> @ imm = #0x8
700b041c: e7ff         	b	0x700b041e <HwiP_irq_handler_c+0x4e> @ imm = #-0x2
;             isr(args);
700b041e: 9902         	ldr	r1, [sp, #0x8]
700b0420: 9801         	ldr	r0, [sp, #0x4]
700b0422: 4788         	blx	r1
;         }
700b0424: e7ff         	b	0x700b0426 <HwiP_irq_handler_c+0x56> @ imm = #-0x2
;         (void)HwiP_disable();
700b0426: f000 ea9c    	blx	0x700b0960 <HwiP_disable> @ imm = #0x538
;         if(isPulse == 0U)
700b042a: 9803         	ldr	r0, [sp, #0xc]
700b042c: b920         	cbnz	r0, 0x700b0438 <HwiP_irq_handler_c+0x68> @ imm = #0x8
700b042e: e7ff         	b	0x700b0430 <HwiP_irq_handler_c+0x60> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b0430: 9804         	ldr	r0, [sp, #0x10]
700b0432: f7ff fd4d    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x566
;         }
700b0436: e7ff         	b	0x700b0438 <HwiP_irq_handler_c+0x68> @ imm = #-0x2
;         HwiP_ackIRQ(intNum);
700b0438: 9804         	ldr	r0, [sp, #0x10]
700b043a: f000 f859    	bl	0x700b04f0 <HwiP_ackIRQ> @ imm = #0xb2
;     }
700b043e: e00c         	b	0x700b045a <HwiP_irq_handler_c+0x8a> @ imm = #0x18
;         gHwiCtrl.spuriousIRQCount++;
700b0440: f240 0100    	movw	r1, #0x0
700b0444: f2c7 0108    	movt	r1, #0x7008
700b0448: f44f 5280    	mov.w	r2, #0x1000
700b044c: 5888         	ldr	r0, [r1, r2]
700b044e: 3001         	adds	r0, #0x1
700b0450: 5088         	str	r0, [r1, r2]
700b0452: 2000         	movs	r0, #0x0
;         HwiP_ackIRQ(0);
700b0454: f000 f84c    	bl	0x700b04f0 <HwiP_ackIRQ> @ imm = #0x98
700b0458: e7ff         	b	0x700b045a <HwiP_irq_handler_c+0x8a> @ imm = #-0x2
; }
700b045a: b006         	add	sp, #0x18
700b045c: bd80         	pop	{r7, pc}
700b045e: bf00         	nop

700b0460 <HwiP_getIRQ>:
; {
700b0460: b084         	sub	sp, #0x10
700b0462: 9003         	str	r0, [sp, #0xc]
700b0464: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700b0468: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700b046a: 9903         	ldr	r1, [sp, #0xc]
700b046c: 2000         	movs	r0, #0x0
700b046e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTIRQ);
700b0470: f642 10e8    	movw	r0, #0x29e8
700b0474: f2c7 000b    	movt	r0, #0x700b
700b0478: 6800         	ldr	r0, [r0]
700b047a: 3020         	adds	r0, #0x20
700b047c: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700b047e: 9802         	ldr	r0, [sp, #0x8]
700b0480: 6800         	ldr	r0, [r0]
700b0482: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700b0484: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700b0488: 0600         	lsls	r0, r0, #0x18
700b048a: 2800         	cmp	r0, #0x0
700b048c: d508         	bpl	0x700b04a0 <HwiP_getIRQ+0x40> @ imm = #0x10
700b048e: e7ff         	b	0x700b0490 <HwiP_getIRQ+0x30> @ imm = #-0x2
;         *intNum = (value & (HwiP_MAX_INTERRUPTS-1U));
700b0490: 9800         	ldr	r0, [sp]
700b0492: f36f 205f    	bfc	r0, #9, #23
700b0496: 9903         	ldr	r1, [sp, #0xc]
700b0498: 6008         	str	r0, [r1]
700b049a: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700b049c: 9001         	str	r0, [sp, #0x4]
;     }
700b049e: e7ff         	b	0x700b04a0 <HwiP_getIRQ+0x40> @ imm = #-0x2
;     return status;
700b04a0: 9801         	ldr	r0, [sp, #0x4]
700b04a2: b004         	add	sp, #0x10
700b04a4: 4770         	bx	lr
700b04a6: bf00         	nop
700b04a8: bf00         	nop
700b04aa: bf00         	nop
700b04ac: bf00         	nop
700b04ae: bf00         	nop

700b04b0 <HwiP_isPulse>:
; {
700b04b0: b083         	sub	sp, #0xc
700b04b2: 9002         	str	r0, [sp, #0x8]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_INT_TYPE(intNum));
700b04b4: f642 10e8    	movw	r0, #0x29e8
700b04b8: f2c7 000b    	movt	r0, #0x700b
700b04bc: 6801         	ldr	r1, [r0]
700b04be: 9802         	ldr	r0, [sp, #0x8]
700b04c0: f400 70f0    	and	r0, r0, #0x1e0
700b04c4: 4408         	add	r0, r1
700b04c6: f200 401c    	addw	r0, r0, #0x41c
700b04ca: 9001         	str	r0, [sp, #0x4]
;     bitPos = VIM_BIT_POS(intNum);
700b04cc: 9802         	ldr	r0, [sp, #0x8]
700b04ce: f000 001f    	and	r0, r0, #0x1f
700b04d2: 9000         	str	r0, [sp]
;     return ((*addr >> bitPos) & 0x1u );
700b04d4: 9801         	ldr	r0, [sp, #0x4]
700b04d6: 6800         	ldr	r0, [r0]
700b04d8: 9900         	ldr	r1, [sp]
700b04da: 40c8         	lsrs	r0, r1
700b04dc: f000 0001    	and	r0, r0, #0x1
700b04e0: b003         	add	sp, #0xc
700b04e2: 4770         	bx	lr
700b04e4: bf00         	nop
700b04e6: bf00         	nop
700b04e8: bf00         	nop
700b04ea: bf00         	nop
700b04ec: bf00         	nop
700b04ee: bf00         	nop

700b04f0 <HwiP_ackIRQ>:
; {
700b04f0: b082         	sub	sp, #0x8
700b04f2: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_IRQVEC);
700b04f4: f642 10e8    	movw	r0, #0x29e8
700b04f8: f2c7 000b    	movt	r0, #0x700b
700b04fc: 6800         	ldr	r0, [r0]
700b04fe: 3018         	adds	r0, #0x18
700b0500: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0502: 9801         	ldr	r0, [sp, #0x4]
700b0504: 9900         	ldr	r1, [sp]
700b0506: 6008         	str	r0, [r1]
; }
700b0508: b002         	add	sp, #0x8
700b050a: 4770         	bx	lr
700b050c: bf00         	nop
700b050e: bf00         	nop

700b0510 <HwiP_fiq_handler>:
; {
700b0510: b5df         	push	{r0, r1, r2, r3, r4, r6, r7, lr}
700b0512: af06         	add	r7, sp, #0x18
700b0514: b086         	sub	sp, #0x18
700b0516: 466c         	mov	r4, sp
700b0518: f36f 0402    	bfc	r4, #0, #3
700b051c: 46a5         	mov	sp, r4
;     gdummy = HwiP_getFIQVecAddr();
700b051e: f000 f867    	bl	0x700b05f0 <HwiP_getFIQVecAddr> @ imm = #0xce
700b0522: f244 188c    	movw	r8, #0x418c
700b0526: f2c7 0808    	movt	r8, #0x7008
700b052a: f8c8 0000    	str.w	r0, [r8]
700b052e: a804         	add	r0, sp, #0x10
;     status = HwiP_getFIQ(&intNum);
700b0530: f000 f86e    	bl	0x700b0610 <HwiP_getFIQ> @ imm = #0xdc
700b0534: 9005         	str	r0, [sp, #0x14]
;     if(status==SystemP_SUCCESS)
700b0536: f8dd 8014    	ldr.w	r8, [sp, #0x14]
700b053a: f1b8 0f00    	cmp.w	r8, #0x0
700b053e: d13b         	bne	0x700b05b8 <HwiP_fiq_handler+0xa8> @ imm = #0x76
700b0540: e7ff         	b	0x700b0542 <HwiP_fiq_handler+0x32> @ imm = #-0x2
;         uint32_t isPulse = HwiP_isPulse(intNum);
700b0542: 9804         	ldr	r0, [sp, #0x10]
700b0544: f7ff ffb4    	bl	0x700b04b0 <HwiP_isPulse> @ imm = #-0x98
700b0548: 9003         	str	r0, [sp, #0xc]
;         if(isPulse != 0U)
700b054a: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700b054e: f1b8 0f00    	cmp.w	r8, #0x0
700b0552: d004         	beq	0x700b055e <HwiP_fiq_handler+0x4e> @ imm = #0x8
700b0554: e7ff         	b	0x700b0556 <HwiP_fiq_handler+0x46> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b0556: 9804         	ldr	r0, [sp, #0x10]
700b0558: f7ff fcba    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x68c
;         }
700b055c: e7ff         	b	0x700b055e <HwiP_fiq_handler+0x4e> @ imm = #-0x2
;         isr = gHwiCtrl.isr[intNum];
700b055e: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700b0562: f240 0800    	movw	r8, #0x0
700b0566: f2c7 0808    	movt	r8, #0x7008
700b056a: f858 9029    	ldr.w	r9, [r8, r9, lsl #2]
700b056e: f8cd 9008    	str.w	r9, [sp, #0x8]
;         args = gHwiCtrl.isrArgs[intNum];
700b0572: f8dd 9010    	ldr.w	r9, [sp, #0x10]
700b0576: eb08 0889    	add.w	r8, r8, r9, lsl #2
700b057a: f8d8 8800    	ldr.w	r8, [r8, #0x800]
700b057e: f8cd 8004    	str.w	r8, [sp, #0x4]
;         if(isr!=NULL)
700b0582: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700b0586: f1b8 0f00    	cmp.w	r8, #0x0
700b058a: d005         	beq	0x700b0598 <HwiP_fiq_handler+0x88> @ imm = #0xa
700b058c: e7ff         	b	0x700b058e <HwiP_fiq_handler+0x7e> @ imm = #-0x2
;             isr(args);
700b058e: f8dd 8008    	ldr.w	r8, [sp, #0x8]
700b0592: 9801         	ldr	r0, [sp, #0x4]
700b0594: 47c0         	blx	r8
;         }
700b0596: e7ff         	b	0x700b0598 <HwiP_fiq_handler+0x88> @ imm = #-0x2
;         (void)HwiP_disableFIQ();
700b0598: f000 e9ea    	blx	0x700b0970 <HwiP_disableFIQ> @ imm = #0x3d4
;         if(isPulse == 0U)
700b059c: f8dd 800c    	ldr.w	r8, [sp, #0xc]
700b05a0: f1b8 0f00    	cmp.w	r8, #0x0
700b05a4: d104         	bne	0x700b05b0 <HwiP_fiq_handler+0xa0> @ imm = #0x8
700b05a6: e7ff         	b	0x700b05a8 <HwiP_fiq_handler+0x98> @ imm = #-0x2
;             HwiP_clearInt(intNum);
700b05a8: 9804         	ldr	r0, [sp, #0x10]
700b05aa: f7ff fc91    	bl	0x700afed0 <HwiP_clearInt> @ imm = #-0x6de
;         }
700b05ae: e7ff         	b	0x700b05b0 <HwiP_fiq_handler+0xa0> @ imm = #-0x2
;         HwiP_ackFIQ(intNum);
700b05b0: 9804         	ldr	r0, [sp, #0x10]
700b05b2: f000 f855    	bl	0x700b0660 <HwiP_ackFIQ> @ imm = #0xaa
;     }
700b05b6: e00f         	b	0x700b05d8 <HwiP_fiq_handler+0xc8> @ imm = #0x1e
;         gHwiCtrl.spuriousFIQCount++;
700b05b8: f240 0900    	movw	r9, #0x0
700b05bc: f2c7 0908    	movt	r9, #0x7008
700b05c0: f241 0a04    	movw	r10, #0x1004
700b05c4: f859 800a    	ldr.w	r8, [r9, r10]
700b05c8: f108 0801    	add.w	r8, r8, #0x1
700b05cc: f849 800a    	str.w	r8, [r9, r10]
700b05d0: 2000         	movs	r0, #0x0
;         HwiP_ackFIQ(0);
700b05d2: f000 f845    	bl	0x700b0660 <HwiP_ackFIQ> @ imm = #0x8a
700b05d6: e7ff         	b	0x700b05d8 <HwiP_fiq_handler+0xc8> @ imm = #-0x2
; }
700b05d8: f1a7 0418    	sub.w	r4, r7, #0x18
700b05dc: 46a5         	mov	sp, r4
700b05de: e8bd 40df    	pop.w	{r0, r1, r2, r3, r4, r6, r7, lr}
700b05e2: f3de 8f04    	subs	pc, lr, #0x4
700b05e6: bf00         	nop
700b05e8: bf00         	nop
700b05ea: bf00         	nop
700b05ec: bf00         	nop
700b05ee: bf00         	nop

700b05f0 <HwiP_getFIQVecAddr>:
; {
700b05f0: b081         	sub	sp, #0x4
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b05f2: f642 10e8    	movw	r0, #0x29e8
700b05f6: f2c7 000b    	movt	r0, #0x700b
700b05fa: 6800         	ldr	r0, [r0]
700b05fc: 301c         	adds	r0, #0x1c
700b05fe: 9000         	str	r0, [sp]
;     return *addr;
700b0600: 9800         	ldr	r0, [sp]
700b0602: 6800         	ldr	r0, [r0]
700b0604: b001         	add	sp, #0x4
700b0606: 4770         	bx	lr
700b0608: bf00         	nop
700b060a: bf00         	nop
700b060c: bf00         	nop
700b060e: bf00         	nop

700b0610 <HwiP_getFIQ>:
; {
700b0610: b084         	sub	sp, #0x10
700b0612: 9003         	str	r0, [sp, #0xc]
700b0614: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700b0618: 9001         	str	r0, [sp, #0x4]
;     *intNum = 0;
700b061a: 9903         	ldr	r1, [sp, #0xc]
700b061c: 2000         	movs	r0, #0x0
700b061e: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_ACTFIQ);
700b0620: f642 10e8    	movw	r0, #0x29e8
700b0624: f2c7 000b    	movt	r0, #0x700b
700b0628: 6800         	ldr	r0, [r0]
700b062a: 3024         	adds	r0, #0x24
700b062c: 9002         	str	r0, [sp, #0x8]
;     value = *addr;
700b062e: 9802         	ldr	r0, [sp, #0x8]
700b0630: 6800         	ldr	r0, [r0]
700b0632: 9000         	str	r0, [sp]
;     if((value & 0x80000000U) != 0U)
700b0634: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700b0638: 0600         	lsls	r0, r0, #0x18
700b063a: 2800         	cmp	r0, #0x0
700b063c: d508         	bpl	0x700b0650 <HwiP_getFIQ+0x40> @ imm = #0x10
700b063e: e7ff         	b	0x700b0640 <HwiP_getFIQ+0x30> @ imm = #-0x2
;         *intNum = (value & 0x3FFU);
700b0640: 9800         	ldr	r0, [sp]
700b0642: f36f 209f    	bfc	r0, #10, #22
700b0646: 9903         	ldr	r1, [sp, #0xc]
700b0648: 6008         	str	r0, [r1]
700b064a: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700b064c: 9001         	str	r0, [sp, #0x4]
;     }
700b064e: e7ff         	b	0x700b0650 <HwiP_getFIQ+0x40> @ imm = #-0x2
;     return status;
700b0650: 9801         	ldr	r0, [sp, #0x4]
700b0652: b004         	add	sp, #0x10
700b0654: 4770         	bx	lr
700b0656: bf00         	nop
700b0658: bf00         	nop
700b065a: bf00         	nop
700b065c: bf00         	nop
700b065e: bf00         	nop

700b0660 <HwiP_ackFIQ>:
; {
700b0660: b082         	sub	sp, #0x8
700b0662: 9001         	str	r0, [sp, #0x4]
;     addr = (volatile uint32_t *)(gHwiConfig.intcBaseAddr + VIM_FIQVEC);
700b0664: f642 10e8    	movw	r0, #0x29e8
700b0668: f2c7 000b    	movt	r0, #0x700b
700b066c: 6800         	ldr	r0, [r0]
700b066e: 301c         	adds	r0, #0x1c
700b0670: 9000         	str	r0, [sp]
;     *addr= intNum;
700b0672: 9801         	ldr	r0, [sp, #0x4]
700b0674: 9900         	ldr	r1, [sp]
700b0676: 6008         	str	r0, [r1]
; }
700b0678: b002         	add	sp, #0x8
700b067a: 4770         	bx	lr
700b067c: bf00         	nop
700b067e: bf00         	nop

700b0680 <HwiP_reserved_handler>:
; {
700b0680: b5d0         	push	{r4, r6, r7, lr}
700b0682: af02         	add	r7, sp, #0x8
700b0684: b082         	sub	sp, #0x8
700b0686: 466c         	mov	r4, sp
700b0688: f36f 0402    	bfc	r4, #0, #3
700b068c: 46a5         	mov	sp, r4
700b068e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0692: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U) { ; }
700b0696: e7ff         	b	0x700b0698 <HwiP_reserved_handler+0x18> @ imm = #-0x2
700b0698: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b069c: f1be 0f00    	cmp.w	lr, #0x0
700b06a0: d001         	beq	0x700b06a6 <HwiP_reserved_handler+0x26> @ imm = #0x2
700b06a2: e7ff         	b	0x700b06a4 <HwiP_reserved_handler+0x24> @ imm = #-0x2
700b06a4: e7f8         	b	0x700b0698 <HwiP_reserved_handler+0x18> @ imm = #-0x10
; }
700b06a6: f1a7 0408    	sub.w	r4, r7, #0x8
700b06aa: 46a5         	mov	sp, r4
700b06ac: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b06b0: f3de 8f00    	subs	pc, lr, #0x0
700b06b4: bf00         	nop
700b06b6: bf00         	nop
700b06b8: bf00         	nop
700b06ba: bf00         	nop
700b06bc: bf00         	nop
700b06be: bf00         	nop

700b06c0 <HwiP_undefined_handler>:
; {
700b06c0: b5d0         	push	{r4, r6, r7, lr}
700b06c2: af02         	add	r7, sp, #0x8
700b06c4: b082         	sub	sp, #0x8
700b06c6: 466c         	mov	r4, sp
700b06c8: f36f 0402    	bfc	r4, #0, #3
700b06cc: 46a5         	mov	sp, r4
700b06ce: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b06d2: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){  ; }
700b06d6: e7ff         	b	0x700b06d8 <HwiP_undefined_handler+0x18> @ imm = #-0x2
700b06d8: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b06dc: f1be 0f00    	cmp.w	lr, #0x0
700b06e0: d001         	beq	0x700b06e6 <HwiP_undefined_handler+0x26> @ imm = #0x2
700b06e2: e7ff         	b	0x700b06e4 <HwiP_undefined_handler+0x24> @ imm = #-0x2
700b06e4: e7f8         	b	0x700b06d8 <HwiP_undefined_handler+0x18> @ imm = #-0x10
; }
700b06e6: f1a7 0408    	sub.w	r4, r7, #0x8
700b06ea: 46a5         	mov	sp, r4
700b06ec: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b06f0: f3de 8f00    	subs	pc, lr, #0x0
700b06f4: bf00         	nop
700b06f6: bf00         	nop
700b06f8: bf00         	nop
700b06fa: bf00         	nop
700b06fc: bf00         	nop
700b06fe: bf00         	nop

700b0700 <HwiP_prefetch_abort_handler>:
; {
700b0700: b5d0         	push	{r4, r6, r7, lr}
700b0702: af02         	add	r7, sp, #0x8
700b0704: b082         	sub	sp, #0x8
700b0706: 466c         	mov	r4, sp
700b0708: f36f 0402    	bfc	r4, #0, #3
700b070c: 46a5         	mov	sp, r4
700b070e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0712: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U)  { ;}
700b0716: e7ff         	b	0x700b0718 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x2
700b0718: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b071c: f1be 0f00    	cmp.w	lr, #0x0
700b0720: d001         	beq	0x700b0726 <HwiP_prefetch_abort_handler+0x26> @ imm = #0x2
700b0722: e7ff         	b	0x700b0724 <HwiP_prefetch_abort_handler+0x24> @ imm = #-0x2
700b0724: e7f8         	b	0x700b0718 <HwiP_prefetch_abort_handler+0x18> @ imm = #-0x10
; }
700b0726: f1a7 0408    	sub.w	r4, r7, #0x8
700b072a: 46a5         	mov	sp, r4
700b072c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b0730: f3de 8f04    	subs	pc, lr, #0x4
700b0734: bf00         	nop
700b0736: bf00         	nop
700b0738: bf00         	nop
700b073a: bf00         	nop
700b073c: bf00         	nop
700b073e: bf00         	nop

700b0740 <HwiP_data_abort_handler_c>:
; {
700b0740: b5d0         	push	{r4, r6, r7, lr}
700b0742: af02         	add	r7, sp, #0x8
700b0744: b082         	sub	sp, #0x8
700b0746: 466c         	mov	r4, sp
700b0748: f36f 0402    	bfc	r4, #0, #3
700b074c: 46a5         	mov	sp, r4
700b074e: f04f 0e01    	mov.w	lr, #0x1
;     volatile uint32_t loop = 1;
700b0752: f8cd e004    	str.w	lr, [sp, #0x4]
;     while(loop != 0U){ ; }
700b0756: e7ff         	b	0x700b0758 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x2
700b0758: f8dd e004    	ldr.w	lr, [sp, #0x4]
700b075c: f1be 0f00    	cmp.w	lr, #0x0
700b0760: d001         	beq	0x700b0766 <HwiP_data_abort_handler_c+0x26> @ imm = #0x2
700b0762: e7ff         	b	0x700b0764 <HwiP_data_abort_handler_c+0x24> @ imm = #-0x2
700b0764: e7f8         	b	0x700b0758 <HwiP_data_abort_handler_c+0x18> @ imm = #-0x10
; }
700b0766: f1a7 0408    	sub.w	r4, r7, #0x8
700b076a: 46a5         	mov	sp, r4
700b076c: e8bd 40d0    	pop.w	{r4, r6, r7, lr}
700b0770: f3de 8f04    	subs	pc, lr, #0x4

700b0774 <vPortRestoreTaskContext>:
;         CPS     #SYS_MODE
700b0774: f102001f     	cps	#0x1f
;         portRESTORE_CONTEXT
700b0778: e59f01c8     	ldr	r0, [pc, #0x1c8]        @ 0x700b0948 <pxCurrentTCBConst>
700b077c: e5901000     	ldr	r1, [r0]
700b0780: e591d000     	ldr	sp, [r1]
700b0784: e59f01c0     	ldr	r0, [pc, #0x1c0]        @ 0x700b094c <ulPortTaskHasFPUContextConst>
700b0788: e49d1004     	ldr	r1, [sp], #4
700b078c: e5801000     	str	r1, [r0]
700b0790: e3510000     	cmp	r1, #0
700b0794: 149d0004     	ldrne	r0, [sp], #4
700b0798: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b079c: 1ee10a10     	vmsrne	fpscr, r0
700b07a0: f57ff01f     	clrex
700b07a4: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b07a8: f8bd0a00     	rfeia	sp!

700b07ac <HwiP_svc_handler>:
;         portSAVE_CONTEXT
700b07ac: f96d051f     	srsdb	sp!, #0x1f
700b07b0: f102001f     	cps	#0x1f
700b07b4: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b07b8: e59f218c     	ldr	r2, [pc, #0x18c]        @ 0x700b094c <ulPortTaskHasFPUContextConst>
700b07bc: e5923000     	ldr	r3, [r2]
700b07c0: e3530000     	cmp	r3, #0
700b07c4: 1ef11a10     	vmrsne	r1, fpscr
700b07c8: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b07cc: 152d1004     	strne	r1, [sp, #-0x4]!
700b07d0: e52d3004     	str	r3, [sp, #-0x4]!
700b07d4: e59f016c     	ldr	r0, [pc, #0x16c]        @ 0x700b0948 <pxCurrentTCBConst>
700b07d8: e5901000     	ldr	r1, [r0]
700b07dc: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700b07e0: e59f0168     	ldr	r0, [pc, #0x168]        @ 0x700b0950 <vTaskSwitchContextConst>
;         BLX     R0
700b07e4: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700b07e8: e59f0158     	ldr	r0, [pc, #0x158]        @ 0x700b0948 <pxCurrentTCBConst>
700b07ec: e5901000     	ldr	r1, [r0]
700b07f0: e591d000     	ldr	sp, [r1]
700b07f4: e59f0150     	ldr	r0, [pc, #0x150]        @ 0x700b094c <ulPortTaskHasFPUContextConst>
700b07f8: e49d1004     	ldr	r1, [sp], #4
700b07fc: e5801000     	str	r1, [r0]
700b0800: e3510000     	cmp	r1, #0
700b0804: 149d0004     	ldrne	r0, [sp], #4
700b0808: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b080c: 1ee10a10     	vmsrne	fpscr, r0
700b0810: f57ff01f     	clrex
700b0814: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b0818: f8bd0a00     	rfeia	sp!

700b081c <HwiP_irq_handler>:
;         SUB             lr, lr, #4
700b081c: e24ee004     	sub	lr, lr, #4
;         PUSH    {lr}
700b0820: e52de004     	str	lr, [sp, #-0x4]!
;         MRS     lr, SPSR
700b0824: e14fe000     	mrs	lr, spsr
;         PUSH    {lr}
700b0828: e52de004     	str	lr, [sp, #-0x4]!
;         CPS  #SVC_MODE
700b082c: f1020013     	cps	#0x13
;         PUSH    {r0-r4, r12}
700b0830: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         LDR     r3, ulPortInterruptNestingConst
700b0834: e59f3118     	ldr	r3, [pc, #0x118]        @ 0x700b0954 <ulPortInterruptNestingConst>
;         LDR     r1, [r3]
700b0838: e5931000     	ldr	r1, [r3]
;         ADD     r4, r1, #1
700b083c: e2814001     	add	r4, r1, #1
;         STR     r4, [r3]
700b0840: e5834000     	str	r4, [r3]
;         FMRX  R0, FPSCR
700b0844: eef10a10     	vmrs	r0, fpscr
;         VPUSH {D0-D15}
700b0848: ed2d0b20     	vpush	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         PUSH  {R0}
700b084c: e52d0004     	str	r0, [sp, #-0x4]!
;         MOV     r2, sp
700b0850: e1a0200d     	mov	r2, sp
;         AND     r2, r2, #4
700b0854: e2022004     	and	r2, r2, #4
;         SUB     sp, sp, r2
700b0858: e04dd002     	sub	sp, sp, r2
;         PUSH    {r0-r4, lr}
700b085c: e92d401f     	push	{r0, r1, r2, r3, r4, lr}
;         LDR     r1, vApplicationIRQHandlerConst
700b0860: e59f10f0     	ldr	r1, [pc, #0xf0]         @ 0x700b0958 <vApplicationIRQHandlerConst>
;         BLX     r1
700b0864: e12fff31     	blx	r1
;         POP     {r0-r4, lr}
700b0868: e8bd401f     	pop	{r0, r1, r2, r3, r4, lr}
;         ADD     sp, sp, r2
700b086c: e08dd002     	add	sp, sp, r2
;         CPSID   i
700b0870: f10c0080     	cpsid	i
;         DSB
700b0874: f57ff04f     	dsb	sy
;         ISB
700b0878: f57ff06f     	isb	sy
;         POP   {R0}
700b087c: e49d0004     	ldr	r0, [sp], #4
;         VPOP  {D0-D15}
700b0880: ecbd0b20     	vpop	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
;         VMSR  FPSCR, R0
700b0884: eee10a10     	vmsr	fpscr, r0
;         STR     r1, [r3]
700b0888: e5831000     	str	r1, [r3]
;         CMP     r1, #0
700b088c: e3510000     	cmp	r1, #0
;         BNE     exit_without_switch
700b0890: 1a000003     	bne	0x700b08a4 <exit_without_switch> @ imm = #0xc
;         LDR     r1, =ulPortYieldRequired
700b0894: e59f10c0     	ldr	r1, [pc, #0xc0]         @ 0x700b095c <vApplicationIRQHandlerConst+0x4>
;         LDR     r0, [r1]
700b0898: e5910000     	ldr	r0, [r1]
;         CMP     r0, #0
700b089c: e3500000     	cmp	r0, #0
;         BNE     switch_before_exit
700b08a0: 1a000005     	bne	0x700b08bc <switch_before_exit> @ imm = #0x14

700b08a4 <exit_without_switch>:
;         POP     {r0-r4, r12}
700b08a4: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700b08a8: f1020012     	cps	#0x12
;         POP     {LR}
700b08ac: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700b08b0: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700b08b4: e49de004     	ldr	lr, [sp], #4
;         MOVS    PC, LR
700b08b8: e1b0f00e     	movs	pc, lr

700b08bc <switch_before_exit>:
;         MOV     r0, #0
700b08bc: e3a00000     	mov	r0, #0
;         STR     r0, [r1]
700b08c0: e5810000     	str	r0, [r1]
;         POP     {r0-r4, r12}
700b08c4: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         CPS  #IRQ_MODE
700b08c8: f1020012     	cps	#0x12
;         POP     {LR}
700b08cc: e49de004     	ldr	lr, [sp], #4
;         MSR     SPSR_cxsf, LR
700b08d0: e16ff00e     	msr	SPSR_fsxc, lr
;         POP     {LR}
700b08d4: e49de004     	ldr	lr, [sp], #4
;         portSAVE_CONTEXT
700b08d8: f96d051f     	srsdb	sp!, #0x1f
700b08dc: f102001f     	cps	#0x1f
700b08e0: e92d5fff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b08e4: e59f2060     	ldr	r2, [pc, #0x60]         @ 0x700b094c <ulPortTaskHasFPUContextConst>
700b08e8: e5923000     	ldr	r3, [r2]
700b08ec: e3530000     	cmp	r3, #0
700b08f0: 1ef11a10     	vmrsne	r1, fpscr
700b08f4: 1d2d0b20     	vpushne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b08f8: 152d1004     	strne	r1, [sp, #-0x4]!
700b08fc: e52d3004     	str	r3, [sp, #-0x4]!
700b0900: e59f0040     	ldr	r0, [pc, #0x40]         @ 0x700b0948 <pxCurrentTCBConst>
700b0904: e5901000     	ldr	r1, [r0]
700b0908: e581d000     	str	sp, [r1]
;         LDR     R0, vTaskSwitchContextConst
700b090c: e59f003c     	ldr	r0, [pc, #0x3c]         @ 0x700b0950 <vTaskSwitchContextConst>
;         BLX     R0
700b0910: e12fff30     	blx	r0
;         portRESTORE_CONTEXT
700b0914: e59f002c     	ldr	r0, [pc, #0x2c]         @ 0x700b0948 <pxCurrentTCBConst>
700b0918: e5901000     	ldr	r1, [r0]
700b091c: e591d000     	ldr	sp, [r1]
700b0920: e59f0024     	ldr	r0, [pc, #0x24]         @ 0x700b094c <ulPortTaskHasFPUContextConst>
700b0924: e49d1004     	ldr	r1, [sp], #4
700b0928: e5801000     	str	r1, [r0]
700b092c: e3510000     	cmp	r1, #0
700b0930: 149d0004     	ldrne	r0, [sp], #4
700b0934: 1cbd0b20     	vpopne	{d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15}
700b0938: 1ee10a10     	vmsrne	fpscr, r0
700b093c: f57ff01f     	clrex
700b0940: e8bd5fff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}
700b0944: f8bd0a00     	rfeia	sp!

700b0948 <pxCurrentTCBConst>:
700b0948: fc 29 0b 70  	.word	0x700b29fc

700b094c <ulPortTaskHasFPUContextConst>:
700b094c: 14 2a 0b 70  	.word	0x700b2a14

700b0950 <vTaskSwitchContextConst>:
700b0950: 51 6a 0a 70  	.word	0x700a6a51

700b0954 <ulPortInterruptNestingConst>:
700b0954: 0c 2a 0b 70  	.word	0x700b2a0c

700b0958 <vApplicationIRQHandlerConst>:
700b0958: d1 03 0b 70  	.word	0x700b03d1
700b095c: 18 2a 0b 70  	.word	0x700b2a18

700b0960 <HwiP_disable>:
;         mrs     r0, cpsr
700b0960: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x80
700b0964: e380c080     	orr	r12, r0, #128
;         msr     cpsr_cf, r12
700b0968: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b096c: e12fff1e     	bx	lr

700b0970 <HwiP_disableFIQ>:
;         mrs     r0, cpsr
700b0970: e10f0000     	mrs	r0, apsr
;         orr     r12, r0, #0x40
700b0974: e380c040     	orr	r12, r0, #64
;         msr     cpsr_cf, r12
700b0978: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b097c: e12fff1e     	bx	lr

700b0980 <HwiP_enable>:
;         mrs     r0, cpsr
700b0980: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x80
700b0984: e3c0c080     	bic	r12, r0, #128
;         msr     cpsr_cf, r12
700b0988: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b098c: e12fff1e     	bx	lr

700b0990 <HwiP_enableFIQ>:
;         mrs     r0, cpsr
700b0990: e10f0000     	mrs	r0, apsr
;         bic     r12, r0, #0x40
700b0994: e3c0c040     	bic	r12, r0, #64
;         msr     cpsr_cf, r12
700b0998: e129f00c     	msr	CPSR_fc, r12
;         bx      LR
700b099c: e12fff1e     	bx	lr

700b09a0 <HwiP_restore>:
;         msr     cpsr_cf, r0
700b09a0: e129f000     	msr	CPSR_fc, r0
;         bx      LR
700b09a4: e12fff1e     	bx	lr

700b09a8 <HwiP_enableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700b09a8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR     r0, r0, #(1<<24)         /* Set VE mask (VIC controller provides handler address for IRQ) */
700b09ac: e3800401     	orr	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700b09b0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b09b4: e12fff1e     	bx	lr

700b09b8 <HwiP_disableVIC>:
;         MRC     p15, #0, r0, c1, c0, #0  /* Read SCTLR */
700b09b8: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC     r0, r0, #(1<<24)         /* Clear VE mask (VIC controller provides handler address for IRQ) */
700b09bc: e3c00401     	bic	r0, r0, #16777216
;         MCR     p15, #0, r0, c1, c0, #0  /* Write modified SCTLR */
700b09c0: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b09c4: e12fff1e     	bx	lr

700b09c8 <HwiP_getCPSR>:
;         mrs     r0, cpsr
700b09c8: e10f0000     	mrs	r0, apsr
;         bx      LR
700b09cc: e12fff1e     	bx	lr

700b09d0 <HwiP_data_abort_handler>:
;         PUSH	{r0-r4, r12}
700b09d0: e92d101f     	push	{r0, r1, r2, r3, r4, r12}
;         MRS r0, SPSR
700b09d4: e14f0000     	mrs	r0, spsr
;         AND r1, r0, #0x20
700b09d8: e2001020     	and	r1, r0, #32
;         CMP R1, #0
700b09dc: e3510000     	cmp	r1, #0
;         BEQ ARM_STATE
700b09e0: 0a000000     	beq	0x700b09e8 <ARM_STATE>  @ imm = #0x0
;         SUB lr, lr, #2
700b09e4: e24ee002     	sub	lr, lr, #2

700b09e8 <ARM_STATE>:
;         SUB lr, lr, #4
700b09e8: e24ee004     	sub	lr, lr, #4

700b09ec <END>:
;         PUSH	{lr}
700b09ec: e52de004     	str	lr, [sp, #-0x4]!
;         MRS	lr, SPSR
700b09f0: e14fe000     	mrs	lr, spsr
;         PUSH	{lr}
700b09f4: e52de004     	str	lr, [sp, #-0x4]!
;         LDR	r1, HwiP_data_abort_handler_const
700b09f8: e59f1014     	ldr	r1, [pc, #0x14]         @ 0x700b0a14 <HwiP_data_abort_handler_const>
;         BLX	r1
700b09fc: e12fff31     	blx	r1
;         POP	{LR}
700b0a00: e49de004     	ldr	lr, [sp], #4
;         MSR	SPSR_cxsf, LR
700b0a04: e16ff00e     	msr	SPSR_fsxc, lr
;         POP	{LR}
700b0a08: e49de004     	ldr	lr, [sp], #4
;         POP	{r0-r4, r12}
700b0a0c: e8bd101f     	pop	{r0, r1, r2, r3, r4, r12}
;         MOVS	PC, LR
700b0a10: e1b0f00e     	movs	pc, lr

700b0a14 <HwiP_data_abort_handler_const>:
700b0a14: 41 07 0b 70  	.word	0x700b0741
700b0a18: 00 00 00 00  	.word	0x00000000
700b0a1c: 00 00 00 00  	.word	0x00000000

Disassembly of section .text.cache:

700b0a20 <CacheP_disableL1d>:
;         push    {r0-r7, r9-r11, lr}
700b0a20: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b0a24: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x0004         // clear C bit
700b0a28: e3c00004     	bic	r0, r0, #4
;         dsb
700b0a2c: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0 // L1D cache disabled
700b0a30: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700b0a34: e3000c4c     	movw	r0, #0xc4c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700b0a38: e347000b     	movt	r0, #0x700b
;         blx     r0
700b0a3c: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700b0a40: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0a44: e12fff1e     	bx	lr

700b0a48 <CacheP_disableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b0a48: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1000         // clear I bit
700b0a4c: e3c00a01     	bic	r0, r0, #4096
;         mcr     p15, #0, r0, c1, c0, #0 // L1P cache disabled
700b0a50: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700b0a54: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         isb
700b0a58: f57ff06f     	isb	sy
;         bx      lr
700b0a5c: e12fff1e     	bx	lr

700b0a60 <CacheP_enableL1d>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCR register
700b0a60: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x0004          // set C bit (bit 2) to 1
700b0a64: e3800004     	orr	r0, r0, #4
;         dsb
700b0a68: f57ff04f     	dsb	sy
;         mcr     p15, #0, r1, c15, c5, #0 // Invalidate entire data cache
700b0a6c: ee0f1f15     	mcr	p15, #0x0, r1, c15, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0  // L1D cache enabled
700b0a70: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      lr
700b0a74: e12fff1e     	bx	lr

700b0a78 <CacheP_enableL1p>:
;         mrc     p15, #0, r0, c1, c0, #0 // read SCR register
700b0a78: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1000         // set I bit (bit 12) to 1
700b0a7c: e3800a01     	orr	r0, r0, #4096
;         mcr     p15, #0, r1, c7, c5, #0 // Invalidate entire instruction cache
700b0a80: ee071f15     	mcr	p15, #0x0, r1, c7, c5, #0x0
;         mcr     p15, #0, r0, c1, c0, #0 // ICache enabled
700b0a84: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb
700b0a88: f57ff06f     	isb	sy
;         bx      lr
700b0a8c: e12fff1e     	bx	lr

700b0a90 <CacheP_invL1d>:
;         push    {r4}
700b0a90: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700b0a94: e0801001     	add	r1, r0, r1
;         ldr     r3, l1dCacheLineSizeInvL1dAddr
700b0a98: e59f3024     	ldr	r3, [pc, #0x24]         @ 0x700b0ac4 <l1dCacheLineSizeInvL1dAddr>
;         ldr     r3, [r3]
700b0a9c: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700b0aa0: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700b0aa4: e1c00004     	bic	r0, r0, r4

700b0aa8 <invL1dCache_loop>:
;         mcr     p15, #0, r0, c7, c6, #1 // invalidate single entry in L1D cache
700b0aa8: ee070f36     	mcr	p15, #0x0, r0, c7, c6, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700b0aac: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700b0ab0: e1500001     	cmp	r0, r1
;         blo     invL1dCache_loop        // loop if > 0
700b0ab4: 3afffffb     	blo	0x700b0aa8 <invL1dCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700b0ab8: f57ff04f     	dsb	sy
;         pop     {r4}
700b0abc: e49d4004     	ldr	r4, [sp], #4
;         bx      lr                      // return
700b0ac0: e12fff1e     	bx	lr

700b0ac4 <l1dCacheLineSizeInvL1dAddr>:
700b0ac4: 28 26 0b 70  	.word	0x700b2628

700b0ac8 <CacheP_invL1p>:
;         push    {r4}
700b0ac8: e52d4004     	str	r4, [sp, #-0x4]!
;         add     r1, r0, r1              // calculate last address
700b0acc: e0801001     	add	r1, r0, r1
;         ldr     r3, l1pCacheLineSizeAddr
700b0ad0: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700b0b00 <l1pCacheLineSizeAddr>
;         ldr     r3, [r3]
700b0ad4: e5933000     	ldr	r3, [r3]
;         sub     r4, r3, #1
700b0ad8: e2434001     	sub	r4, r3, #1
;         bic     r0, r0, r4              // align blockPtr to cache line
700b0adc: e1c00004     	bic	r0, r0, r4

700b0ae0 <invL1pCache_loop>:
;         mcr     p15, #0, r0, c7, c5, #1 // invalidate single entry in ICache
700b0ae0: ee070f35     	mcr	p15, #0x0, r0, c7, c5, #0x1
;         add     r0, r0, r3              // increment address by cache line size
700b0ae4: e0800003     	add	r0, r0, r3
;         cmp     r0, r1                  // compare to last address
700b0ae8: e1500001     	cmp	r0, r1
;         blo     invL1pCache_loop        // loop if > 0
700b0aec: 3afffffb     	blo	0x700b0ae0 <invL1pCache_loop> @ imm = #-0x14
;         dsb                             // drain write buffer
700b0af0: f57ff04f     	dsb	sy
;         isb                             // flush instruction pipeline
700b0af4: f57ff06f     	isb	sy
;         pop     {r4}
700b0af8: e49d4004     	ldr	r4, [sp], #4
;         bx      lr
700b0afc: e12fff1e     	bx	lr

700b0b00 <l1pCacheLineSizeAddr>:
700b0b00: 2c 26 0b 70  	.word	0x700b262c

700b0b04 <CacheP_invL1dAll>:
;         mcr     p15, #0, r0, c15, c5, #0 // Invalidate entire data cache
700b0b04: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         bx      lr                       // return
700b0b08: e12fff1e     	bx	lr

700b0b0c <CacheP_invL1pAll>:
;         mcr     p15, #0, r0, c7, c5, #0 // invalidate all entries in ICache
700b0b0c: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         bx      lr                      // return
700b0b10: e12fff1e     	bx	lr

700b0b14 <CacheP_wb>:
;         push    {r4, r5}
700b0b14: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700b0b18: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700b0b1c: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbAddr
700b0b20: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700b0b4c <l1dCacheLineSizeWbAddr>
;         ldr     r4, [r4]
700b0b24: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700b0b28: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align address to cache line
700b0b2c: e1c00005     	bic	r0, r0, r5

700b0b30 <writeback>:
;         mcr     p15, #0, r0, c7, c10, #1 // write back a cache line
700b0b30: ee070f3a     	mcr	p15, #0x0, r0, c7, c10, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700b0b34: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700b0b38: e1500001     	cmp	r0, r1
;         blo     writeback                // loop if count > 0
700b0b3c: 3afffffb     	blo	0x700b0b30 <writeback>  @ imm = #-0x14
;         dsb                              // drain write buffer
700b0b40: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700b0b44: e8bd0030     	pop	{r4, r5}
;         bx      lr
700b0b48: e12fff1e     	bx	lr

700b0b4c <l1dCacheLineSizeWbAddr>:
700b0b4c: 28 26 0b 70  	.word	0x700b2628

700b0b50 <CacheP_wbInv>:
;         push    {r4, r5}
700b0b50: e92d0030     	push	{r4, r5}
;         dmb                              // Ensure all previous memory accesses
700b0b54: f57ff05f     	dmb	sy
;         add     r1, r0, r1               // calculate last address
700b0b58: e0801001     	add	r1, r0, r1
;         ldr     r4, l1dCacheLineSizeWbInvAddr
700b0b5c: e59f4024     	ldr	r4, [pc, #0x24]         @ 0x700b0b88 <l1dCacheLineSizeWbInvAddr>
;         ldr     r4, [r4]
700b0b60: e5944000     	ldr	r4, [r4]
;         sub     r5, r4, #1
700b0b64: e2445001     	sub	r5, r4, #1
;         bic     r0, r0, r5               // align blockPtr to cache line
700b0b68: e1c00005     	bic	r0, r0, r5

700b0b6c <writebackInv>:
;         mcr     p15, #0, r0, c7, c14, #1 // writeback inv a cache line
700b0b6c: ee070f3e     	mcr	p15, #0x0, r0, c7, c14, #0x1
;         add     r0, r0, r4               // increment address by cache line size
700b0b70: e0800004     	add	r0, r0, r4
;         cmp     r0, r1                   // compare to last address
700b0b74: e1500001     	cmp	r0, r1
;         blo     writebackInv             // loop if count > 0
700b0b78: 3afffffb     	blo	0x700b0b6c <writebackInv> @ imm = #-0x14
;         dsb                              // drain write buffer
700b0b7c: f57ff04f     	dsb	sy
;         pop     {r4, r5}
700b0b80: e8bd0030     	pop	{r4, r5}
;         bx      lr
700b0b84: e12fff1e     	bx	lr

700b0b88 <l1dCacheLineSizeWbInvAddr>:
700b0b88: 28 26 0b 70  	.word	0x700b2628

700b0b8c <CacheP_wbAll>:
;         stmfd   sp!, {r0-r7, r9-r11, lr}
700b0b8c: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         dmb                             // Ensure all previous memory accesses
700b0b90: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700b0b94: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700b0b98: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700b0b9c: e1a03ba3     	lsr	r3, r3, #23
;         beq     wbafinished             // if loc is 0, then no need to clean
700b0ba0: 0a00001d     	beq	0x700b0c1c <wbafinished> @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700b0ba4: e3a0a000     	mov	r10, #0

700b0ba8 <wbaloop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700b0ba8: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700b0bac: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700b0bb0: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700b0bb4: e3510002     	cmp	r1, #2
;         blt     wbaskip                 // skip if no cache, or just i-cache
700b0bb8: ba000014     	blt	0x700b0c10 <wbaskip>    @ imm = #0x50
;         mrs     r6, cpsr
700b0bbc: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700b0bc0: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0bc4: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700b0bc8: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700b0bcc: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700b0bd0: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700b0bd4: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700b0bd8: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700b0bdc: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700b0be0: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700b0be4: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700b0be8: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700b0bec: e01776a1     	ands	r7, r7, r1, lsr #13

700b0bf0 <wbaloop2>:
;         mov     r9, r4                  // create working copy of max way size
700b0bf0: e1a09004     	mov	r9, r4

700b0bf4 <wbaloop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700b0bf4: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700b0bf8: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c10, #2 // clean line by set/way
700b0bfc: ee07bf5a     	mcr	p15, #0x0, r11, c7, c10, #0x2
;         subs    r9, r9, #1              // decrement the way
700b0c00: e2599001     	subs	r9, r9, #1
;         bge     wbaloop3
700b0c04: aafffffa     	bge	0x700b0bf4 <wbaloop3>   @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700b0c08: e2577001     	subs	r7, r7, #1
;         bge     wbaloop2
700b0c0c: aafffff7     	bge	0x700b0bf0 <wbaloop2>   @ imm = #-0x24

700b0c10 <wbaskip>:
;         add     r10, r10, #2            // increment cache number
700b0c10: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700b0c14: e153000a     	cmp	r3, r10
;         bgt     wbaloop1
700b0c18: caffffe2     	bgt	0x700b0ba8 <wbaloop1>   @ imm = #-0x78

700b0c1c <wbafinished>:
;         mov     r10, #0                 // switch back to cache level 0
700b0c1c: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0c20: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700b0c24: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700b0c28: f57ff06f     	isb	sy
;         ldmfd   sp!, {r0-r7, r9-r11, lr}
700b0c2c: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0c30: e12fff1e     	bx	lr

700b0c34 <CacheP_wbInvAll>:
;         push    {r0-r7, r9-r11, lr}
700b0c34: e92d4eff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         movw    r0, :lower16:CacheP_wbInvAllAsm
700b0c38: e3000c4c     	movw	r0, #0xc4c
;         movt    r0, :upper16:CacheP_wbInvAllAsm
700b0c3c: e347000b     	movt	r0, #0x700b
;         blx     r0
700b0c40: e12fff30     	blx	r0
;         pop     {r0-r7, r9-r11, lr}
700b0c44: e8bd4eff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, r10, r11, lr}
;         bx      lr
700b0c48: e12fff1e     	bx	lr

700b0c4c <CacheP_wbInvAllAsm>:
;         dmb                             // Ensure all previous memory accesses
700b0c4c: f57ff05f     	dmb	sy
;         mrc     p15, #1, r0, c0, c0, #1 // read clidr
700b0c50: ee300f30     	mrc	p15, #0x1, r0, c0, c0, #0x1
;         ands    r3, r0, #0x7000000      // extract loc from clidr
700b0c54: e2103407     	ands	r3, r0, #117440512
;         mov     r3, r3, lsr #23         // left align loc bit field
700b0c58: e1a03ba3     	lsr	r3, r3, #23
;         beq     finished                // if loc is 0, then no need to clean
700b0c5c: 0a00001d     	beq	0x700b0cd8 <finished>   @ imm = #0x74
;         mov     r10, #0                 // start clean at cache level 0
700b0c60: e3a0a000     	mov	r10, #0

700b0c64 <loop1>:
;         add     r2, r10, r10, lsr #1    // work out 3x current cache level
700b0c64: e08a20aa     	add	r2, r10, r10, lsr #1
;         mov     r1, r0, lsr r2          // extract cache type bits from clidr
700b0c68: e1a01230     	lsr	r1, r0, r2
;         and     r1, r1, #7              // mask of bits for current cache only
700b0c6c: e2011007     	and	r1, r1, #7
;         cmp     r1, #2                  // see what cache we have at this level
700b0c70: e3510002     	cmp	r1, #2
;         blt     skip                    // skip if no cache, or just i-cache
700b0c74: ba000014     	blt	0x700b0ccc <skip>       @ imm = #0x50
;         mrs     r6, cpsr
700b0c78: e10f6000     	mrs	r6, apsr
;         cpsid   i                       // disable interrupts
700b0c7c: f10c0080     	cpsid	i
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0c80: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         isb                             // flush prefetch buffer
700b0c84: f57ff06f     	isb	sy
;         mrc     p15, #1, r1, c0, c0, #0 // read the new csidr
700b0c88: ee301f10     	mrc	p15, #0x1, r1, c0, c0, #0x0
;         msr     cpsr_c, r6              // restore interrupts
700b0c8c: e121f006     	msr	CPSR_c, r6
;         and     r2, r1, #7              // extract the length of the cache lines
700b0c90: e2012007     	and	r2, r1, #7
;         add     r2, r2, #4              // add 4 (line length offset)
700b0c94: e2822004     	add	r2, r2, #4
;         mov     r4, #0x3ff
700b0c98: e30043ff     	movw	r4, #0x3ff
;         ands    r4, r4, r1, lsr #3      // find maximum number on the way size
700b0c9c: e01441a1     	ands	r4, r4, r1, lsr #3
;         clz     r5, r4                  // find bit position of way size inc.
700b0ca0: e16f5f14     	clz	r5, r4
;         mov     r7, #0x7fff
700b0ca4: e3077fff     	movw	r7, #0x7fff
;         ands    r7, r7, r1, lsr #13     // extract max number of the index size
700b0ca8: e01776a1     	ands	r7, r7, r1, lsr #13

700b0cac <loop2>:
;         mov     r9, r4                  // create working copy of max way size
700b0cac: e1a09004     	mov	r9, r4

700b0cb0 <loop3>:
;         orr     r11, r10, r9, lsl r5    // factor way and cache number into r11
700b0cb0: e18ab519     	orr	r11, r10, r9, lsl r5
;         orr     r11, r11, r7, lsl r2    // factor index number into r11
700b0cb4: e18bb217     	orr	r11, r11, r7, lsl r2
;         mcr     p15, #0, r11, c7, c14, #2 // clean & invalidate by set/way
700b0cb8: ee07bf5e     	mcr	p15, #0x0, r11, c7, c14, #0x2
;         subs    r9, r9, #1              // decrement the way
700b0cbc: e2599001     	subs	r9, r9, #1
;         bge     loop3
700b0cc0: aafffffa     	bge	0x700b0cb0 <loop3>      @ imm = #-0x18
;         subs    r7, r7, #1              // decrement the index
700b0cc4: e2577001     	subs	r7, r7, #1
;         bge     loop2
700b0cc8: aafffff7     	bge	0x700b0cac <loop2>      @ imm = #-0x24

700b0ccc <skip>:
;         add     r10, r10, #2            // increment cache number
700b0ccc: e28aa002     	add	r10, r10, #2
;         cmp     r3, r10
700b0cd0: e153000a     	cmp	r3, r10
;         bgt     loop1
700b0cd4: caffffe2     	bgt	0x700b0c64 <loop1>      @ imm = #-0x78

700b0cd8 <finished>:
;         mov     r10, #0                 // swith back to cache level 0
700b0cd8: e3a0a000     	mov	r10, #0
;         mcr     p15, #2, r10, c0, c0, #0// select current cache level in cssr
700b0cdc: ee40af10     	mcr	p15, #0x2, r10, c0, c0, #0x0
;         dsb
700b0ce0: f57ff04f     	dsb	sy
;         isb                             // flush prefetch buffer
700b0ce4: f57ff06f     	isb	sy
;         bx      lr
700b0ce8: e12fff1e     	bx	lr

700b0cec <CacheP_getEnabled>:
;         mov     r0, #0
700b0cec: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0 // fetch Control Register into r1
700b0cf0: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1000             // test I bit (bit 12) for L1P
700b0cf4: e3110a01     	tst	r1, #4096
;         addne   r0, r0, #1              // if I is true, L1P is enabled
700b0cf8: 12800001     	addne	r0, r0, #1
;         tst     r1, #0x0004             // test C bit (bit 2) for L1D
700b0cfc: e3110004     	tst	r1, #4
;         addne   r0, r0, #2              // if C bit is true, L1D is enabled
700b0d00: 12800002     	addne	r0, r0, #2
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0d04: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         tst     r1, #0x0002             // test L2EN bit (bit 1) for L2EN
700b0d08: e3110002     	tst	r1, #2
;         beq     getEnabledDone
700b0d0c: 0a000003     	beq	0x700b0d20 <getEnabledDone> @ imm = #0xc
;         tst     r0, #0x0001
700b0d10: e3100001     	tst	r0, #1
;         addne   r0, r0, #4              // If L2EN and L1P then L2P
700b0d14: 12800004     	addne	r0, r0, #4
;         tst     r0, #0x0002
700b0d18: e3100002     	tst	r0, #2
;         addne   r0, r0, #8              // If L2EN and L1D then L2D
700b0d1c: 12800008     	addne	r0, r0, #8

700b0d20 <getEnabledDone>:
;         bx      lr
700b0d20: e12fff1e     	bx	lr

700b0d24 <CacheP_getCacheLevelInfo>:
;         mcr     p15, #2, r0, c0, c0, #0 // write to Cache Size Selection Reg
700b0d24: ee400f10     	mcr	p15, #0x2, r0, c0, c0, #0x0
;         mrc     p15, #1, r0, c0, c0, #0 // read Cache Size Id Reg
700b0d28: ee300f10     	mrc	p15, #0x1, r0, c0, c0, #0x0
;         bx      lr
700b0d2c: e12fff1e     	bx	lr

700b0d30 <CacheP_configForceWrThru>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0d30: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         cmp     r0, #0
700b0d34: e3500000     	cmp	r0, #0
;         beq     FWT_disable
700b0d38: 0a000001     	beq	0x700b0d44 <FWT_disable> @ imm = #0x4
;         orr     r1, r1, #(1 << 9)       // set (enable) force write-thru bit
700b0d3c: e3811c02     	orr	r1, r1, #512
;         b       FWT_exit
700b0d40: ea000000     	b	0x700b0d48 <FWT_exit>   @ imm = #0x0

700b0d44 <FWT_disable>:
;         bic     r1, r1, #(1 << 9)       // clear (disable) force write-thru bit
700b0d44: e3c11c02     	bic	r1, r1, #512

700b0d48 <FWT_exit>:
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700b0d48: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700b0d4c: e12fff1e     	bx	lr

700b0d50 <CacheP_setDLFO>:
;         mrc     p15, #0, r1, c1, c0, #1 // fetch Auxiliary Ctrl Register into r1
700b0d50: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         orr     r1, r1, #(1 << 13)      // set DLFO to disable LF optimization
700b0d54: e3811a02     	orr	r1, r1, #8192
;         mcr     p15, #0, r1, c1, c0, #1 // write Auxiliary Ctrl Register
700b0d58: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         bx      lr
700b0d5c: e12fff1e     	bx	lr

700b0d60 <CacheP_init>:
; {
700b0d60: b580         	push	{r7, lr}
700b0d62: b084         	sub	sp, #0x10
700b0d64: 2000         	movs	r0, #0x0
;     info = CacheP_getCacheLevelInfo(0);
700b0d66: f7ff efde    	blx	0x700b0d24 <CacheP_getCacheLevelInfo> @ imm = #-0x44
700b0d6a: 9003         	str	r0, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1dCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700b0d6c: 9803         	ldr	r0, [sp, #0xc]
700b0d6e: f000 0007    	and	r0, r0, #0x7
700b0d72: 1c81         	adds	r1, r0, #0x2
700b0d74: 2004         	movs	r0, #0x4
700b0d76: 9001         	str	r0, [sp, #0x4]
700b0d78: 4088         	lsls	r0, r1
700b0d7a: 3820         	subs	r0, #0x20
700b0d7c: fab0 f080    	clz	r0, r0
700b0d80: 0940         	lsrs	r0, r0, #0x5
700b0d82: f000 faad    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x55a
700b0d86: 2001         	movs	r0, #0x1
;     info = CacheP_getCacheLevelInfo(1);
700b0d88: f7ff efcc    	blx	0x700b0d24 <CacheP_getCacheLevelInfo> @ imm = #-0x68
700b0d8c: 4601         	mov	r1, r0
700b0d8e: 9801         	ldr	r0, [sp, #0x4]
700b0d90: 9103         	str	r1, [sp, #0xc]
;     DebugP_assertNoLog (gCacheL1pCacheLineSize == (4U << ((info & 0x7U) + 2U)));
700b0d92: 9903         	ldr	r1, [sp, #0xc]
700b0d94: f001 0107    	and	r1, r1, #0x7
700b0d98: 3102         	adds	r1, #0x2
700b0d9a: 4088         	lsls	r0, r1
700b0d9c: 3820         	subs	r0, #0x20
700b0d9e: fab0 f080    	clz	r0, r0
700b0da2: 0940         	lsrs	r0, r0, #0x5
700b0da4: f000 fa9c    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x538
;     enabled = CacheP_getEnabled();
700b0da8: f7ff efa0    	blx	0x700b0cec <CacheP_getEnabled> @ imm = #-0xc0
700b0dac: 9002         	str	r0, [sp, #0x8]
;     if (enabled!=0U) {
700b0dae: 9802         	ldr	r0, [sp, #0x8]
700b0db0: b120         	cbz	r0, 0x700b0dbc <CacheP_init+0x5c> @ imm = #0x8
700b0db2: e7ff         	b	0x700b0db4 <CacheP_init+0x54> @ imm = #-0x2
700b0db4: 200f         	movs	r0, #0xf
;         CacheP_disable((uint32_t)CacheP_TYPE_ALL);
700b0db6: f000 f81b    	bl	0x700b0df0 <CacheP_disable> @ imm = #0x36
;     }
700b0dba: e7ff         	b	0x700b0dbc <CacheP_init+0x5c> @ imm = #-0x2
;     if (gCacheConfig.enable!=0U) {
700b0dbc: f641 0008    	movw	r0, #0x1808
700b0dc0: f2c7 000b    	movt	r0, #0x700b
700b0dc4: 6800         	ldr	r0, [r0]
700b0dc6: b158         	cbz	r0, 0x700b0de0 <CacheP_init+0x80> @ imm = #0x16
700b0dc8: e7ff         	b	0x700b0dca <CacheP_init+0x6a> @ imm = #-0x2
;          CacheP_configForceWrThru(gCacheConfig.enableForceWrThru);
700b0dca: f641 0008    	movw	r0, #0x1808
700b0dce: f2c7 000b    	movt	r0, #0x700b
700b0dd2: 6840         	ldr	r0, [r0, #0x4]
700b0dd4: f7ff efac    	blx	0x700b0d30 <CacheP_configForceWrThru> @ imm = #-0xa8
700b0dd8: 200f         	movs	r0, #0xf
;         CacheP_enable((uint32_t)CacheP_TYPE_ALL);
700b0dda: f000 f831    	bl	0x700b0e40 <CacheP_enable> @ imm = #0x62
;     }
700b0dde: e7ff         	b	0x700b0de0 <CacheP_init+0x80> @ imm = #-0x2
; }
700b0de0: b004         	add	sp, #0x10
700b0de2: bd80         	pop	{r7, pc}
700b0de4: bf00         	nop
700b0de6: bf00         	nop
700b0de8: bf00         	nop
700b0dea: bf00         	nop
700b0dec: bf00         	nop
700b0dee: bf00         	nop

700b0df0 <CacheP_disable>:
; {
700b0df0: b580         	push	{r7, lr}
700b0df2: b084         	sub	sp, #0x10
700b0df4: 9003         	str	r0, [sp, #0xc]
;     enabled = CacheP_getEnabled();
700b0df6: f7ff ef7a    	blx	0x700b0cec <CacheP_getEnabled> @ imm = #-0x10c
700b0dfa: 9002         	str	r0, [sp, #0x8]
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700b0dfc: 9902         	ldr	r1, [sp, #0x8]
700b0dfe: 9803         	ldr	r0, [sp, #0xc]
700b0e00: 4008         	ands	r0, r1
700b0e02: 0780         	lsls	r0, r0, #0x1e
700b0e04: 2800         	cmp	r0, #0x0
700b0e06: d509         	bpl	0x700b0e1c <CacheP_disable+0x2c> @ imm = #0x12
700b0e08: e7ff         	b	0x700b0e0a <CacheP_disable+0x1a> @ imm = #-0x2
;         key = HwiP_disable();
700b0e0a: f7ff edaa    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x4ac
700b0e0e: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1d();             /* Disable L1D Cache */
700b0e10: f7ff ee06    	blx	0x700b0a20 <CacheP_disableL1d> @ imm = #-0x3f4
;         HwiP_restore(key);
700b0e14: 9801         	ldr	r0, [sp, #0x4]
700b0e16: f7ff edc4    	blx	0x700b09a0 <HwiP_restore> @ imm = #-0x478
;     }
700b0e1a: e7ff         	b	0x700b0e1c <CacheP_disable+0x2c> @ imm = #-0x2
;     if ((enabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700b0e1c: 9902         	ldr	r1, [sp, #0x8]
700b0e1e: 9803         	ldr	r0, [sp, #0xc]
700b0e20: 4008         	ands	r0, r1
700b0e22: 07c0         	lsls	r0, r0, #0x1f
700b0e24: b148         	cbz	r0, 0x700b0e3a <CacheP_disable+0x4a> @ imm = #0x12
700b0e26: e7ff         	b	0x700b0e28 <CacheP_disable+0x38> @ imm = #-0x2
;         key = HwiP_disable();
700b0e28: f7ff ed9a    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x4cc
700b0e2c: 9001         	str	r0, [sp, #0x4]
;         CacheP_disableL1p();             /* Disable L1P Cache */
700b0e2e: f7ff ee0c    	blx	0x700b0a48 <CacheP_disableL1p> @ imm = #-0x3e8
;         HwiP_restore(key);
700b0e32: 9801         	ldr	r0, [sp, #0x4]
700b0e34: f7ff edb4    	blx	0x700b09a0 <HwiP_restore> @ imm = #-0x498
;     }
700b0e38: e7ff         	b	0x700b0e3a <CacheP_disable+0x4a> @ imm = #-0x2
; }
700b0e3a: b004         	add	sp, #0x10
700b0e3c: bd80         	pop	{r7, pc}
700b0e3e: bf00         	nop

700b0e40 <CacheP_enable>:
; {
700b0e40: b580         	push	{r7, lr}
700b0e42: b082         	sub	sp, #0x8
700b0e44: 9001         	str	r0, [sp, #0x4]
;     disabled = ~(CacheP_getEnabled());
700b0e46: f7ff ef52    	blx	0x700b0cec <CacheP_getEnabled> @ imm = #-0x15c
700b0e4a: 43c0         	mvns	r0, r0
700b0e4c: 9000         	str	r0, [sp]
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1D)))!=0U) {
700b0e4e: 9900         	ldr	r1, [sp]
700b0e50: 9801         	ldr	r0, [sp, #0x4]
700b0e52: 4008         	ands	r0, r1
700b0e54: 0780         	lsls	r0, r0, #0x1e
700b0e56: 2800         	cmp	r0, #0x0
700b0e58: d503         	bpl	0x700b0e62 <CacheP_enable+0x22> @ imm = #0x6
700b0e5a: e7ff         	b	0x700b0e5c <CacheP_enable+0x1c> @ imm = #-0x2
;         CacheP_enableL1d();              /* Enable L1D Cache */
700b0e5c: f7ff ee00    	blx	0x700b0a60 <CacheP_enableL1d> @ imm = #-0x400
;     }
700b0e60: e7ff         	b	0x700b0e62 <CacheP_enable+0x22> @ imm = #-0x2
;     if ((disabled & ((type) & ((uint32_t)CacheP_TYPE_L1P)))!=0U) {
700b0e62: 9900         	ldr	r1, [sp]
700b0e64: 9801         	ldr	r0, [sp, #0x4]
700b0e66: 4008         	ands	r0, r1
700b0e68: 07c0         	lsls	r0, r0, #0x1f
700b0e6a: b118         	cbz	r0, 0x700b0e74 <CacheP_enable+0x34> @ imm = #0x6
700b0e6c: e7ff         	b	0x700b0e6e <CacheP_enable+0x2e> @ imm = #-0x2
;         CacheP_enableL1p();              /* Enable L1P Cache */
700b0e6e: f7ff ee04    	blx	0x700b0a78 <CacheP_enableL1p> @ imm = #-0x3f8
;     }
700b0e72: e7ff         	b	0x700b0e74 <CacheP_enable+0x34> @ imm = #-0x2
; }
700b0e74: b002         	add	sp, #0x8
700b0e76: bd80         	pop	{r7, pc}
700b0e78: bf00         	nop
700b0e7a: bf00         	nop
700b0e7c: bf00         	nop
700b0e7e: bf00         	nop

700b0e80 <CacheP_inv>:
; {
700b0e80: b580         	push	{r7, lr}
700b0e82: b084         	sub	sp, #0x10
700b0e84: 9003         	str	r0, [sp, #0xc]
700b0e86: 9102         	str	r1, [sp, #0x8]
700b0e88: 9201         	str	r2, [sp, #0x4]
;     if (((type) & ((uint32_t)CacheP_TYPE_L1P))!=0U) {
700b0e8a: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b0e8e: 07c0         	lsls	r0, r0, #0x1f
700b0e90: b128         	cbz	r0, 0x700b0e9e <CacheP_inv+0x1e> @ imm = #0xa
700b0e92: e7ff         	b	0x700b0e94 <CacheP_inv+0x14> @ imm = #-0x2
;         CacheP_invL1p((uint32_t)blockPtr, byteCnt);
700b0e94: 9803         	ldr	r0, [sp, #0xc]
700b0e96: 9902         	ldr	r1, [sp, #0x8]
700b0e98: f7ff ee16    	blx	0x700b0ac8 <CacheP_invL1p> @ imm = #-0x3d4
;     }
700b0e9c: e7ff         	b	0x700b0e9e <CacheP_inv+0x1e> @ imm = #-0x2
;     if (((type) & ((uint32_t)CacheP_TYPE_L1D))!=0U) {
700b0e9e: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b0ea2: 0780         	lsls	r0, r0, #0x1e
700b0ea4: 2800         	cmp	r0, #0x0
700b0ea6: d505         	bpl	0x700b0eb4 <CacheP_inv+0x34> @ imm = #0xa
700b0ea8: e7ff         	b	0x700b0eaa <CacheP_inv+0x2a> @ imm = #-0x2
;         CacheP_invL1d((uint32_t)blockPtr, byteCnt);
700b0eaa: 9803         	ldr	r0, [sp, #0xc]
700b0eac: 9902         	ldr	r1, [sp, #0x8]
700b0eae: f7ff edf0    	blx	0x700b0a90 <CacheP_invL1d> @ imm = #-0x420
;     }
700b0eb2: e7ff         	b	0x700b0eb4 <CacheP_inv+0x34> @ imm = #-0x2
; }
700b0eb4: b004         	add	sp, #0x10
700b0eb6: bd80         	pop	{r7, pc}
		...

Disassembly of section .text.mpu:

700b0ec0 <MpuP_RegionAttrs_init>:
; {
700b0ec0: b081         	sub	sp, #0x4
700b0ec2: 9000         	str	r0, [sp]
;     region->isExecuteNever = 0;
700b0ec4: 9900         	ldr	r1, [sp]
700b0ec6: 2000         	movs	r0, #0x0
700b0ec8: 7108         	strb	r0, [r1, #0x4]
;     region->accessPerm     = (uint8_t)MpuP_AP_S_RW_U_R;
700b0eca: 9a00         	ldr	r2, [sp]
700b0ecc: 2102         	movs	r1, #0x2
700b0ece: 7191         	strb	r1, [r2, #0x6]
;     region->tex            = 0;
700b0ed0: 9900         	ldr	r1, [sp]
700b0ed2: 7148         	strb	r0, [r1, #0x5]
;     region->isSharable     = 1;
700b0ed4: 9a00         	ldr	r2, [sp]
700b0ed6: 2101         	movs	r1, #0x1
700b0ed8: 70d1         	strb	r1, [r2, #0x3]
;     region->isCacheable    = 0;
700b0eda: 9900         	ldr	r1, [sp]
700b0edc: 7048         	strb	r0, [r1, #0x1]
;     region->isBufferable   = 0;
700b0ede: 9900         	ldr	r1, [sp]
700b0ee0: 7088         	strb	r0, [r1, #0x2]
;     region->isEnable       = 0;
700b0ee2: 9900         	ldr	r1, [sp]
700b0ee4: 7008         	strb	r0, [r1]
;     region->subregionDisableMask = 0;
700b0ee6: 9900         	ldr	r1, [sp]
700b0ee8: 71c8         	strb	r0, [r1, #0x7]
; }
700b0eea: b001         	add	sp, #0x4
700b0eec: 4770         	bx	lr
700b0eee: bf00         	nop

700b0ef0 <MpuP_setRegion>:
; {
700b0ef0: b580         	push	{r7, lr}
700b0ef2: b08a         	sub	sp, #0x28
700b0ef4: 9009         	str	r0, [sp, #0x24]
700b0ef6: 9108         	str	r1, [sp, #0x20]
700b0ef8: 9207         	str	r2, [sp, #0x1c]
700b0efa: 9306         	str	r3, [sp, #0x18]
;     uint32_t value = size;
700b0efc: 9807         	ldr	r0, [sp, #0x1c]
700b0efe: 9000         	str	r0, [sp]
;     DebugP_assertNoLog( regionNum < MpuP_MAX_REGIONS);
700b0f00: 9909         	ldr	r1, [sp, #0x24]
700b0f02: 2000         	movs	r0, #0x0
700b0f04: 2910         	cmp	r1, #0x10
700b0f06: bf38         	it	lo
700b0f08: 2001         	movlo	r0, #0x1
700b0f0a: f000 f9e9    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x3d2
;     value = (value & (uint32_t)0x1F);
700b0f0e: 9800         	ldr	r0, [sp]
700b0f10: f000 001f    	and	r0, r0, #0x1f
700b0f14: 9000         	str	r0, [sp]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0f16: 9806         	ldr	r0, [sp, #0x18]
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700b0f18: 7801         	ldrb	r1, [r0]
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0f1a: 79c0         	ldrb	r0, [r0, #0x7]
700b0f1c: 0200         	lsls	r0, r0, #0x8
;                   | ((uint32_t)(value            & (uint32_t)0x1F) << (uint32_t)1)
700b0f1e: 9a00         	ldr	r2, [sp]
700b0f20: f002 021f    	and	r2, r2, #0x1f
700b0f24: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;                   | ((uint32_t)(attrs->isEnable &  (uint32_t)0x1) << (uint32_t)0);
700b0f28: f001 0101    	and	r1, r1, #0x1
700b0f2c: 4408         	add	r0, r1
;     sizeAndEnable = ((uint32_t)(attrs->subregionDisableMask & (uint32_t)0xFF) << (uint32_t)8)
700b0f2e: 9004         	str	r0, [sp, #0x10]
;     baseAddress = ((uint32_t)addr & ~( (1U <<((uint64_t)value+1U))-1U ));
700b0f30: 9808         	ldr	r0, [sp, #0x20]
700b0f32: 9900         	ldr	r1, [sp]
700b0f34: 1c4a         	adds	r2, r1, #0x1
700b0f36: 2101         	movs	r1, #0x1
700b0f38: 4091         	lsls	r1, r2
700b0f3a: 4249         	rsbs	r1, r1, #0
700b0f3c: 4008         	ands	r0, r1
700b0f3e: 9005         	str	r0, [sp, #0x14]
;     regionAttrs = MpuP_getAttrs(attrs);
700b0f40: 9806         	ldr	r0, [sp, #0x18]
700b0f42: f000 f81d    	bl	0x700b0f80 <MpuP_getAttrs> @ imm = #0x3a
700b0f46: 9003         	str	r0, [sp, #0xc]
;     enabled = MpuP_isEnable();
700b0f48: f000 f84a    	bl	0x700b0fe0 <MpuP_isEnable> @ imm = #0x94
700b0f4c: 9002         	str	r0, [sp, #0x8]
;     MpuP_disable();
700b0f4e: f000 f84f    	bl	0x700b0ff0 <MpuP_disable> @ imm = #0x9e
;     key = HwiP_disable();
700b0f52: f7ff ed06    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x5f4
700b0f56: 9001         	str	r0, [sp, #0x4]
;     MpuP_setRegionAsm(regionNum, baseAddress, sizeAndEnable, regionAttrs);
700b0f58: 9809         	ldr	r0, [sp, #0x24]
700b0f5a: 9905         	ldr	r1, [sp, #0x14]
700b0f5c: 9a04         	ldr	r2, [sp, #0x10]
700b0f5e: 9b03         	ldr	r3, [sp, #0xc]
700b0f60: f000 e90c    	blx	0x700b117c <MpuP_setRegionAsm> @ imm = #0x218
;     HwiP_restore(key);
700b0f64: 9801         	ldr	r0, [sp, #0x4]
700b0f66: f7ff ed1c    	blx	0x700b09a0 <HwiP_restore> @ imm = #-0x5c8
;     if (enabled != 0U) {
700b0f6a: 9802         	ldr	r0, [sp, #0x8]
700b0f6c: b118         	cbz	r0, 0x700b0f76 <MpuP_setRegion+0x86> @ imm = #0x6
700b0f6e: e7ff         	b	0x700b0f70 <MpuP_setRegion+0x80> @ imm = #-0x2
;         MpuP_enable();
700b0f70: f000 f85e    	bl	0x700b1030 <MpuP_enable> @ imm = #0xbc
;     }
700b0f74: e7ff         	b	0x700b0f76 <MpuP_setRegion+0x86> @ imm = #-0x2
; }
700b0f76: b00a         	add	sp, #0x28
700b0f78: bd80         	pop	{r7, pc}
700b0f7a: bf00         	nop
700b0f7c: bf00         	nop
700b0f7e: bf00         	nop

700b0f80 <MpuP_getAttrs>:
; {
700b0f80: b580         	push	{r7, lr}
700b0f82: b082         	sub	sp, #0x8
700b0f84: 9001         	str	r0, [sp, #0x4]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700b0f86: f8dd c004    	ldr.w	r12, [sp, #0x4]
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700b0f8a: f89c 2001    	ldrb.w	r2, [r12, #0x1]
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700b0f8e: f89c 1002    	ldrb.w	r1, [r12, #0x2]
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700b0f92: f89c 3003    	ldrb.w	r3, [r12, #0x3]
;           ((uint32_t)(region->isExecuteNever & (uint32_t)0x1) << (uint32_t)12)
700b0f96: f89c 0004    	ldrb.w	r0, [r12, #0x4]
700b0f9a: f000 0001    	and	r0, r0, #0x1
700b0f9e: 0300         	lsls	r0, r0, #0xc
;         | ((uint32_t)(region->accessPerm     & (uint32_t)0x7) << (uint32_t)8)
700b0fa0: f89c e006    	ldrb.w	lr, [r12, #0x6]
700b0fa4: f00e 0e07    	and	lr, lr, #0x7
700b0fa8: ea40 200e    	orr.w	r0, r0, lr, lsl #8
;         | ((uint32_t)(region->tex            & (uint32_t)0x7) << (uint32_t)3)
700b0fac: f89c c005    	ldrb.w	r12, [r12, #0x5]
700b0fb0: f00c 0c07    	and	r12, r12, #0x7
700b0fb4: ea40 00cc    	orr.w	r0, r0, r12, lsl #3
;         | ((uint32_t)(region->isSharable     & (uint32_t)0x1) << (uint32_t)2)
700b0fb8: f003 0301    	and	r3, r3, #0x1
700b0fbc: ea40 0083    	orr.w	r0, r0, r3, lsl #2
;         | ((uint32_t)(region->isCacheable    & (uint32_t)0x1) << (uint32_t)1)
700b0fc0: f002 0201    	and	r2, r2, #0x1
700b0fc4: ea40 0042    	orr.w	r0, r0, r2, lsl #1
;         | ((uint32_t)(region->isBufferable   & (uint32_t)0x1) << (uint32_t)0);
700b0fc8: f001 0101    	and	r1, r1, #0x1
700b0fcc: 4408         	add	r0, r1
;     uint32_t regionAttrs =
700b0fce: 9000         	str	r0, [sp]
;     return regionAttrs;
700b0fd0: 9800         	ldr	r0, [sp]
700b0fd2: b002         	add	sp, #0x8
700b0fd4: bd80         	pop	{r7, pc}
700b0fd6: bf00         	nop
700b0fd8: bf00         	nop
700b0fda: bf00         	nop
700b0fdc: bf00         	nop
700b0fde: bf00         	nop

700b0fe0 <MpuP_isEnable>:
; {
700b0fe0: b580         	push	{r7, lr}
;     return MpuP_isEnableAsm();
700b0fe2: f000 e8c2    	blx	0x700b1168 <MpuP_isEnableAsm> @ imm = #0x184
700b0fe6: bd80         	pop	{r7, pc}
700b0fe8: bf00         	nop
700b0fea: bf00         	nop
700b0fec: bf00         	nop
700b0fee: bf00         	nop

700b0ff0 <MpuP_disable>:
; {
700b0ff0: b580         	push	{r7, lr}
700b0ff2: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()!=0U)
700b0ff4: f7ff fff4    	bl	0x700b0fe0 <MpuP_isEnable> @ imm = #-0x18
700b0ff8: b1a0         	cbz	r0, 0x700b1024 <MpuP_disable+0x34> @ imm = #0x28
700b0ffa: e7ff         	b	0x700b0ffc <MpuP_disable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700b0ffc: f7ff ecb0    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x6a0
700b1000: 9000         	str	r0, [sp]
;         type = CacheP_getEnabled();
700b1002: f7ff ee74    	blx	0x700b0cec <CacheP_getEnabled> @ imm = #-0x318
700b1006: 9001         	str	r0, [sp, #0x4]
;         CacheP_disable(type);
700b1008: 9801         	ldr	r0, [sp, #0x4]
700b100a: f7ff fef1    	bl	0x700b0df0 <CacheP_disable> @ imm = #-0x21e
;         __asm__ __volatile__ (" dsb" "\n\t": : : "memory");
700b100e: f3bf 8f4f    	dsb	sy
;         MpuP_disableAsm();
700b1012: f000 e882    	blx	0x700b1118 <MpuP_disableAsm> @ imm = #0x104
;         CacheP_enable(type);
700b1016: 9801         	ldr	r0, [sp, #0x4]
700b1018: f7ff ff12    	bl	0x700b0e40 <CacheP_enable> @ imm = #-0x1dc
;         HwiP_restore(key);
700b101c: 9800         	ldr	r0, [sp]
700b101e: f7ff ecc0    	blx	0x700b09a0 <HwiP_restore> @ imm = #-0x680
;     }
700b1022: e7ff         	b	0x700b1024 <MpuP_disable+0x34> @ imm = #-0x2
; }
700b1024: b002         	add	sp, #0x8
700b1026: bd80         	pop	{r7, pc}
700b1028: bf00         	nop
700b102a: bf00         	nop
700b102c: bf00         	nop
700b102e: bf00         	nop

700b1030 <MpuP_enable>:
; {
700b1030: b580         	push	{r7, lr}
700b1032: b082         	sub	sp, #0x8
;     if(MpuP_isEnable()==(uint32_t) 0U)
700b1034: f7ff ffd4    	bl	0x700b0fe0 <MpuP_isEnable> @ imm = #-0x58
700b1038: b9e0         	cbnz	r0, 0x700b1074 <MpuP_enable+0x44> @ imm = #0x38
700b103a: e7ff         	b	0x700b103c <MpuP_enable+0xc> @ imm = #-0x2
;         key = HwiP_disable();
700b103c: f7ff ec90    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x6e0
700b1040: 9000         	str	r0, [sp]
;         type = (uint32_t)CacheP_getEnabled();
700b1042: f7ff ee54    	blx	0x700b0cec <CacheP_getEnabled> @ imm = #-0x358
700b1046: 9001         	str	r0, [sp, #0x4]
;         if (type & CacheP_TYPE_L1) {
700b1048: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700b104c: 0780         	lsls	r0, r0, #0x1e
700b104e: b120         	cbz	r0, 0x700b105a <MpuP_enable+0x2a> @ imm = #0x8
700b1050: e7ff         	b	0x700b1052 <MpuP_enable+0x22> @ imm = #-0x2
700b1052: 2003         	movs	r0, #0x3
;             CacheP_disable(CacheP_TYPE_L1);
700b1054: f7ff fecc    	bl	0x700b0df0 <CacheP_disable> @ imm = #-0x268
;         }
700b1058: e7ff         	b	0x700b105a <MpuP_enable+0x2a> @ imm = #-0x2
;         MpuP_enableAsm();
700b105a: f000 e872    	blx	0x700b1140 <MpuP_enableAsm> @ imm = #0xe4
;         CacheP_enable(type);
700b105e: 9801         	ldr	r0, [sp, #0x4]
700b1060: f7ff feee    	bl	0x700b0e40 <CacheP_enable> @ imm = #-0x224
;         __asm__  __volatile__ (" dsb" "\n\t": : : "memory");
700b1064: f3bf 8f4f    	dsb	sy
;         __asm__  __volatile__ (" isb" "\n\t": : : "memory");
700b1068: f3bf 8f6f    	isb	sy
;         HwiP_restore(key);
700b106c: 9800         	ldr	r0, [sp]
700b106e: f7ff ec98    	blx	0x700b09a0 <HwiP_restore> @ imm = #-0x6d0
;     }
700b1072: e7ff         	b	0x700b1074 <MpuP_enable+0x44> @ imm = #-0x2
; }
700b1074: b002         	add	sp, #0x8
700b1076: bd80         	pop	{r7, pc}
700b1078: bf00         	nop
700b107a: bf00         	nop
700b107c: bf00         	nop
700b107e: bf00         	nop

700b1080 <MpuP_init>:
; {
700b1080: b580         	push	{r7, lr}
700b1082: b082         	sub	sp, #0x8
;     if (MpuP_isEnable()!=0U) {
700b1084: f7ff ffac    	bl	0x700b0fe0 <MpuP_isEnable> @ imm = #-0xa8
700b1088: b118         	cbz	r0, 0x700b1092 <MpuP_init+0x12> @ imm = #0x6
700b108a: e7ff         	b	0x700b108c <MpuP_init+0xc> @ imm = #-0x2
;         MpuP_disable();
700b108c: f7ff ffb0    	bl	0x700b0ff0 <MpuP_disable> @ imm = #-0xa0
;     }
700b1090: e7ff         	b	0x700b1092 <MpuP_init+0x12> @ imm = #-0x2
;     MpuP_disableBRAsm();
700b1092: f000 e84e    	blx	0x700b1130 <MpuP_disableBRAsm> @ imm = #0x9c
;     DebugP_assertNoLog( gMpuConfig.numRegions < MpuP_MAX_REGIONS);
700b1096: f641 0010    	movw	r0, #0x1810
700b109a: f2c7 000b    	movt	r0, #0x700b
700b109e: 6801         	ldr	r1, [r0]
700b10a0: 2000         	movs	r0, #0x0
700b10a2: 9000         	str	r0, [sp]
700b10a4: 2910         	cmp	r1, #0x10
700b10a6: bf38         	it	lo
700b10a8: 2001         	movlo	r0, #0x1
700b10aa: f000 f919    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x232
700b10ae: 9800         	ldr	r0, [sp]
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700b10b0: 9001         	str	r0, [sp, #0x4]
700b10b2: e7ff         	b	0x700b10b4 <MpuP_init+0x34> @ imm = #-0x2
700b10b4: 9801         	ldr	r0, [sp, #0x4]
700b10b6: f641 0110    	movw	r1, #0x1810
700b10ba: f2c7 010b    	movt	r1, #0x700b
700b10be: 6809         	ldr	r1, [r1]
700b10c0: 4288         	cmp	r0, r1
700b10c2: d212         	bhs	0x700b10ea <MpuP_init+0x6a> @ imm = #0x24
700b10c4: e7ff         	b	0x700b10c6 <MpuP_init+0x46> @ imm = #-0x2
;         MpuP_setRegion(i,
700b10c6: 9801         	ldr	r0, [sp, #0x4]
;                 (void*)gMpuRegionConfig[i].baseAddr,
700b10c8: f641 011c    	movw	r1, #0x181c
700b10cc: f2c7 010b    	movt	r1, #0x700b
700b10d0: eb01 1300    	add.w	r3, r1, r0, lsl #4
700b10d4: 0102         	lsls	r2, r0, #0x4
700b10d6: 5889         	ldr	r1, [r1, r2]
;                 gMpuRegionConfig[i].size,
700b10d8: 685a         	ldr	r2, [r3, #0x4]
;                 &gMpuRegionConfig[i].attrs
700b10da: 3308         	adds	r3, #0x8
;         MpuP_setRegion(i,
700b10dc: f7ff ff08    	bl	0x700b0ef0 <MpuP_setRegion> @ imm = #-0x1f0
;     }
700b10e0: e7ff         	b	0x700b10e2 <MpuP_init+0x62> @ imm = #-0x2
;     for (i = 0; i < gMpuConfig.numRegions; i++)
700b10e2: 9801         	ldr	r0, [sp, #0x4]
700b10e4: 3001         	adds	r0, #0x1
700b10e6: 9001         	str	r0, [sp, #0x4]
700b10e8: e7e4         	b	0x700b10b4 <MpuP_init+0x34> @ imm = #-0x38
;     if (gMpuConfig.enableBackgroundRegion!=0U) {
700b10ea: f641 0010    	movw	r0, #0x1810
700b10ee: f2c7 000b    	movt	r0, #0x700b
700b10f2: 6840         	ldr	r0, [r0, #0x4]
700b10f4: b118         	cbz	r0, 0x700b10fe <MpuP_init+0x7e> @ imm = #0x6
700b10f6: e7ff         	b	0x700b10f8 <MpuP_init+0x78> @ imm = #-0x2
;         MpuP_enableBRAsm();
700b10f8: f000 e82e    	blx	0x700b1158 <MpuP_enableBRAsm> @ imm = #0x5c
;     }
700b10fc: e7ff         	b	0x700b10fe <MpuP_init+0x7e> @ imm = #-0x2
;     if (gMpuConfig.enableMpu!=0U) {
700b10fe: f641 0010    	movw	r0, #0x1810
700b1102: f2c7 000b    	movt	r0, #0x700b
700b1106: 6880         	ldr	r0, [r0, #0x8]
700b1108: b118         	cbz	r0, 0x700b1112 <MpuP_init+0x92> @ imm = #0x6
700b110a: e7ff         	b	0x700b110c <MpuP_init+0x8c> @ imm = #-0x2
;         MpuP_enable();
700b110c: f7ff ff90    	bl	0x700b1030 <MpuP_enable> @ imm = #-0xe0
;     }
700b1110: e7ff         	b	0x700b1112 <MpuP_init+0x92> @ imm = #-0x2
; }
700b1112: b002         	add	sp, #0x8
700b1114: bd80         	pop	{r7, pc}
700b1116: 0000         	movs	r0, r0

700b1118 <MpuP_disableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b1118: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x1             // clear bit 0 in r0
700b111c: e3c00001     	bic	r0, r0, #1
;         dsb
700b1120: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU disabled (bit 0 = 0)
700b1124: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700b1128: f57ff06f     	isb	sy
;         bx      LR
700b112c: e12fff1e     	bx	lr

700b1130 <MpuP_disableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b1130: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         bic     r0, r0, #0x20000         // clear bit 17 in r0
700b1134: e3c00802     	bic	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // disable background region
700b1138: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b113c: e12fff1e     	bx	lr

700b1140 <MpuP_enableAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b1140: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x1             // set bit 0 in r0
700b1144: e3800001     	orr	r0, r0, #1
;         dsb
700b1148: f57ff04f     	dsb	sy
;         mcr     p15, #0, r0, c1, c0, #0  // MPU enabled (bit 0 = 1)
700b114c: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         isb                              // flush instruction pipeline
700b1150: f57ff06f     	isb	sy
;         bx      LR
700b1154: e12fff1e     	bx	lr

700b1158 <MpuP_enableBRAsm>:
;         mrc     p15, #0, r0, c1, c0, #0  // read SCTLR register
700b1158: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         orr     r0, r0, #0x20000         // set bit 17 in r0
700b115c: e3800802     	orr	r0, r0, #131072
;         mcr     p15, #0, r0, c1, c0, #0  // background region enabled
700b1160: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         bx      LR
700b1164: e12fff1e     	bx	lr

700b1168 <MpuP_isEnableAsm>:
;         mov     r0, #0
700b1168: e3a00000     	mov	r0, #0
;         mrc     p15, #0, r1, c1, c0, #0  // read SCTLR register to r1
700b116c: ee111f10     	mrc	p15, #0x0, r1, c1, c0, #0x0
;         tst     r1, #0x1                 // test bit 0
700b1170: e3110001     	tst	r1, #1
;         movne   r0, #1                   // if not 0, MPU is enabled
700b1174: 13a00001     	movne	r0, #1
;         bx      LR
700b1178: e12fff1e     	bx	lr

700b117c <MpuP_setRegionAsm>:
;         mcr     p15, #0, r0, c6, c2, #0  // select MPU region
700b117c: ee060f12     	mcr	p15, #0x0, r0, c6, c2, #0x0
;         mcr     p15, #0, r1, c6, c1, #0  // set region base address
700b1180: ee061f11     	mcr	p15, #0x0, r1, c6, c1, #0x0
;         mcr     p15, #0, r2, c6, c1, #2  // set region size and enable it
700b1184: ee062f51     	mcr	p15, #0x0, r2, c6, c1, #0x2
;         mcr     p15, #0, r3, c6, c1, #4  // set protection attributes
700b1188: ee063f91     	mcr	p15, #0x0, r3, c6, c1, #0x4
;         bx      LR
700b118c: e12fff1e     	bx	lr

Disassembly of section .text.boot:

700b1190 <_c_int00_sbl>:
;         MRC     p15, #0, r1, c0, c0, #5
700b1190: ee101fb0     	mrc	p15, #0x0, r1, c0, c0, #0x5
;         BFC     r1, #8, #24
700b1194: e7df141f     	bfc	r1, #8, #24
;         CMP     r1, #0
700b1198: e3510000     	cmp	r1, #0
;         BNE     _sblLoopForever
700b119c: 1a000001     	bne	0x700b11a8 <_sblLoopForever> @ imm = #0x4
;         LDR     r1, _c_int00_addr
700b11a0: e59f1008     	ldr	r1, [pc, #0x8]          @ 0x700b11b0 <_c_int00_addr>
;         BLX     r1
700b11a4: e12fff31     	blx	r1

700b11a8 <_sblLoopForever>:
;         WFI
700b11a8: e320f003     	wfi
;         B       _sblLoopForever
700b11ac: eafffffd     	b	0x700b11a8 <_sblLoopForever> @ imm = #-0xc

700b11b0 <_c_int00_addr>:
700b11b0: b4 11 0b 70  	.word	0x700b11b4

700b11b4 <_c_int00>:
;         mrs     r0, cpsr
700b11b4: e10f0000     	mrs	r0, apsr
;         orr     r0, r0, #0xC0
700b11b8: e38000c0     	orr	r0, r0, #192
;         msr     cpsr_cf, r0
700b11bc: e129f000     	msr	CPSR_fc, r0
;         MRC      p15,#0x0,r0,c1,c0,#2
700b11c0: ee110f50     	mrc	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r3,#0xf00000
700b11c4: e3a0360f     	mov	r3, #15728640
;         ORR      r0,r0,r3
700b11c8: e1800003     	orr	r0, r0, r3
;         MCR      p15,#0x0,r0,c1,c0,#2
700b11cc: ee010f50     	mcr	p15, #0x0, r0, c1, c0, #0x2
;         MOV      r0,#0x40000000
700b11d0: e3a00101     	mov	r0, #1073741824
;         FMXR     FPEXC,r0
700b11d4: eee80a10     	vmsr	fpexc, r0
;         MRS     r0, cpsr
700b11d8: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b11dc: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x11  // SET FIQ MODE
700b11e0: e3800011     	orr	r0, r0, #17
;         MSR     cpsr_cf, r0
700b11e4: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_FIQ_STACK_END
700b11e8: e59fd0d4     	ldr	sp, [pc, #0xd4]         @ 0x700b12c4 <c_FIQ_STACK_END>
;         MRS     r0, cpsr
700b11ec: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b11f0: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x12  // SET IRQ MODE
700b11f4: e3800012     	orr	r0, r0, #18
;         MSR     cpsr_cf, r0
700b11f8: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_IRQ_STACK_END
700b11fc: e59fd0bc     	ldr	sp, [pc, #0xbc]         @ 0x700b12c0 <c_IRQ_STACK_END>
;         MRS     r0, cpsr
700b1200: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b1204: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x13  // SET SVC MODE
700b1208: e3800013     	orr	r0, r0, #19
;         MSR     cpsr_cf, r0
700b120c: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_SVC_STACK_END
700b1210: e59fd0b0     	ldr	sp, [pc, #0xb0]         @ 0x700b12c8 <c_SVC_STACK_END>
;         MRS     r0, cpsr
700b1214: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b1218: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x17  // SET ABORT MODE
700b121c: e3800017     	orr	r0, r0, #23
;         MSR     cpsr_cf, r0
700b1220: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_ABORT_STACK_END
700b1224: e59fd0a0     	ldr	sp, [pc, #0xa0]         @ 0x700b12cc <c_ABORT_STACK_END>
;         MRS     r0, cpsr
700b1228: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b122c: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1B  // SET ABORT MODE
700b1230: e380001b     	orr	r0, r0, #27
;         MSR     cpsr_cf, r0
700b1234: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_UNDEFINED_STACK_END
700b1238: e59fd090     	ldr	sp, [pc, #0x90]         @ 0x700b12d0 <c_UNDEFINED_STACK_END>
;         MRS     r0, cpsr
700b123c: e10f0000     	mrs	r0, apsr
;         BIC     r0, r0, #0x1F  // CLEAR MODES
700b1240: e3c0001f     	bic	r0, r0, #31
;         ORR     r0, r0, #0x1F  // SET SYSTEM MODE
700b1244: e380001f     	orr	r0, r0, #31
;         MSR     cpsr_cf, r0
700b1248: e129f000     	msr	CPSR_fc, r0
;         LDR     sp, c_STACK_END
700b124c: e59fd068     	ldr	sp, [pc, #0x68]         @ 0x700b12bc <c_STACK_END>
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700b1250: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         BIC r0, r0, #0x1 << 2      // Disable data cache bit
700b1254: e3c00004     	bic	r0, r0, #4
;         BIC r0, r0, #0x1 << 12     // Disable instruction cache bit
700b1258: e3c00a01     	bic	r0, r0, #4096
;         DSB
700b125c: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700b1260: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB                        // Ensures following instructions are not executed from cache
700b1264: f57ff06f     	isb	sy
;         MRC p15, 0, r1, c1, c0, 1  // Read Auxiliary Control Register
700b1268: ee111f30     	mrc	p15, #0x0, r1, c1, c0, #0x1
;         ORR r1, r1, #(0x1 << 3)    //Enable ECC for Cache
700b126c: e3811008     	orr	r1, r1, #8
;         ORR r1,r1,#(0x1 << 5)
700b1270: e3811020     	orr	r1, r1, #32
;         MCR p15, 0, r1, c1, c0, 1  // Write Auxiliary Control Register
700b1274: ee011f30     	mcr	p15, #0x0, r1, c1, c0, #0x1
;         MCR p15, 0, r0, c15, c5, 0 // Invalidate entire data cache
700b1278: ee0f0f15     	mcr	p15, #0x0, r0, c15, c5, #0x0
;         MCR p15, 0, r0, c7, c5, 0  // Invalidate entire instruction cache
700b127c: ee070f15     	mcr	p15, #0x0, r0, c7, c5, #0x0
;         MRC p15, 0, r0, c1, c0, 0  // Read System Control Register
700b1280: ee110f10     	mrc	p15, #0x0, r0, c1, c0, #0x0
;         ORR r0, r0, #0x1 << 2      // Enable data cache bit
700b1284: e3800004     	orr	r0, r0, #4
;         ORR r0, r0, #0x1 << 12     // Enable instruction cache bit
700b1288: e3800a01     	orr	r0, r0, #4096
;         DSB
700b128c: f57ff04f     	dsb	sy
;         MCR p15, 0, r0, c1, c0, 0  // Write System Control Register
700b1290: ee010f10     	mcr	p15, #0x0, r0, c1, c0, #0x0
;         ISB
700b1294: f57ff06f     	isb	sy
;         BL      __mpu_init
700b1298: fa000028     	blx	0x700b1340 <__mpu_init> @ imm = #0xa0
;         BL      _system_pre_init
700b129c: fa00001b     	blx	0x700b1310 <_system_pre_init> @ imm = #0x6c
;         CMP     R0, #0
700b12a0: e3500000     	cmp	r0, #0
;         BEQ     bypass_auto_init
700b12a4: 0a000000     	beq	0x700b12ac <bypass_auto_init> @ imm = #0x0
;         BL      __TI_auto_init
700b12a8: ebffee36     	bl	0x700acb88 <__TI_auto_init_nobinit_nopinit> @ imm = #-0x4728

700b12ac <bypass_auto_init>:
;         BL      main
700b12ac: fafffab3     	blx	0x700afd80 <main>       @ imm = #-0x1534
;         MOV     R0, #1
700b12b0: e3a00001     	mov	r0, #1
;         BL      exit
700b12b4: eb000025     	bl	0x700b1350 <abort>      @ imm = #0x94

700b12b8 <L1>:
; L1:     B       L1
700b12b8: eafffffe     	b	0x700b12b8 <L1>         @ imm = #-0x8

700b12bc <c_STACK_END>:
700b12bc: 00 93 09 70  	.word	0x70099300

700b12c0 <c_IRQ_STACK_END>:
700b12c0: 60 2b 0b 70  	.word	0x700b2b60

700b12c4 <c_FIQ_STACK_END>:
700b12c4: 60 2c 0b 70  	.word	0x700b2c60

700b12c8 <c_SVC_STACK_END>:
700b12c8: 60 3c 0b 70  	.word	0x700b3c60

700b12cc <c_ABORT_STACK_END>:
700b12cc: 60 3d 0b 70  	.word	0x700b3d60

700b12d0 <c_UNDEFINED_STACK_END>:
700b12d0: 60 3e 0b 70  	.word	0x700b3e60
700b12d4: 00 00 00 00  	.word	0x00000000
700b12d8: 00 00 00 00  	.word	0x00000000
700b12dc: 00 00 00 00  	.word	0x00000000

700b12e0 <_DebugP_assertNoLog>:
; {
700b12e0: b580         	push	{r7, lr}
700b12e2: b082         	sub	sp, #0x8
700b12e4: 9001         	str	r0, [sp, #0x4]
;     if(expression==0)
700b12e6: 9801         	ldr	r0, [sp, #0x4]
700b12e8: b950         	cbnz	r0, 0x700b1300 <_DebugP_assertNoLog+0x20> @ imm = #0x14
700b12ea: e7ff         	b	0x700b12ec <_DebugP_assertNoLog+0xc> @ imm = #-0x2
700b12ec: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700b12ee: 9000         	str	r0, [sp]
;         (void) HwiP_disable();
700b12f0: f7ff eb36    	blx	0x700b0960 <HwiP_disable> @ imm = #-0x994
;         while(assert_loop!= 0U)
700b12f4: e7ff         	b	0x700b12f6 <_DebugP_assertNoLog+0x16> @ imm = #-0x2
700b12f6: 9800         	ldr	r0, [sp]
700b12f8: b108         	cbz	r0, 0x700b12fe <_DebugP_assertNoLog+0x1e> @ imm = #0x2
700b12fa: e7ff         	b	0x700b12fc <_DebugP_assertNoLog+0x1c> @ imm = #-0x2
700b12fc: e7fb         	b	0x700b12f6 <_DebugP_assertNoLog+0x16> @ imm = #-0xa
;     }
700b12fe: e7ff         	b	0x700b1300 <_DebugP_assertNoLog+0x20> @ imm = #-0x2
; }
700b1300: b002         	add	sp, #0x8
700b1302: bd80         	pop	{r7, pc}
		...

700b1310 <_system_pre_init>:
; {
700b1310: b580         	push	{r7, lr}
700b1312: b082         	sub	sp, #0x8
;     uint32_t bss_size = ((uintptr_t)&__BSS_END - (uintptr_t)&__BSS_START);
700b1314: f240 0000    	movw	r0, #0x0
700b1318: f2c7 0008    	movt	r0, #0x7008
700b131c: f245 3100    	movw	r1, #0x5300
700b1320: f2c7 0108    	movt	r1, #0x7008
700b1324: 1a09         	subs	r1, r1, r0
700b1326: 9101         	str	r1, [sp, #0x4]
;     (void) memset((void*)&__BSS_START, 0x00, bss_size);
700b1328: 9901         	ldr	r1, [sp, #0x4]
700b132a: f7e9 eef4    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0x16218
700b132e: 2001         	movs	r0, #0x1
;     return 1;
700b1330: b002         	add	sp, #0x8
700b1332: bd80         	pop	{r7, pc}
		...

700b1340 <__mpu_init>:
; {
700b1340: b580         	push	{r7, lr}
;     MpuP_init();
700b1342: f7ff fe9d    	bl	0x700b1080 <MpuP_init>  @ imm = #-0x2c6
;     CacheP_init();
700b1346: e8bd 4080    	pop.w	{r7, lr}
700b134a: f7ff bd09    	b.w	0x700b0d60 <CacheP_init> @ imm = #-0x5ee
700b134e: 0000         	movs	r0, r0

Disassembly of section .text:abort:

700b1350 <abort>:
700b1350: e320f000     	nop
700b1354: eafffffe     	b	0x700b1354 <abort+0x4>  @ imm = #-0x8

Disassembly of section .text:

70099300 <__TI_printfi_nofloat>:
70099300: e92d4ff0     	push	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099304: e24ddf89     	sub	sp, sp, #548
70099308: e5907000     	ldr	r7, [r0]
7009930c: e1a08000     	mov	r8, r0
70099310: e1a05003     	mov	r5, r3
70099314: e1a06002     	mov	r6, r2
70099318: e58d1220     	str	r1, [sp, #0x220]
7009931c: e1a00007     	mov	r0, r7
70099320: eb0058a5     	bl	0x700af5bc <strlen>     @ imm = #0x16294
70099324: e0879000     	add	r9, r7, r0
70099328: e3a0a000     	mov	r10, #0
7009932c: e28dbf83     	add	r11, sp, #524
70099330: e3a04000     	mov	r4, #0
70099334: e3e00000     	mvn	r0, #0
70099338: e58da21c     	str	r10, [sp, #0x21c]
7009933c: e1570009     	cmp	r7, r9
70099340: 2a0000a4     	bhs	0x700995d8 <__TI_printfi_nofloat+0x2d8> @ imm = #0x290
70099344: e2877001     	add	r7, r7, #1
70099348: e58da20c     	str	r10, [sp, #0x20c]
7009934c: e5cda218     	strb	r10, [sp, #0x218]
70099350: e58da210     	str	r10, [sp, #0x210]
70099354: e58d0214     	str	r0, [sp, #0x214]
70099358: e5570001     	ldrb	r0, [r7, #-0x1]
7009935c: e3500000     	cmp	r0, #0
70099360: 0a00009c     	beq	0x700995d8 <__TI_printfi_nofloat+0x2d8> @ imm = #0x270
70099364: e3500025     	cmp	r0, #37
70099368: 0a000005     	beq	0x70099384 <__TI_printfi_nofloat+0x84> @ imm = #0x14
7009936c: e1a01006     	mov	r1, r6
70099370: e5887000     	str	r7, [r8]
70099374: e12fff35     	blx	r5
70099378: e2844001     	add	r4, r4, #1
7009937c: e2877001     	add	r7, r7, #1
70099380: eafffff4     	b	0x70099358 <__TI_printfi_nofloat+0x58> @ imm = #-0x30
70099384: e1a0000b     	mov	r0, r11
70099388: e1a01008     	mov	r1, r8
7009938c: e58d421c     	str	r4, [sp, #0x21c]
70099390: e5887000     	str	r7, [r8]
70099394: eb000092     	bl	0x700995e4 <pproc_fflags___TI_printfi_nofloat> @ imm = #0x248
70099398: e1a0000b     	mov	r0, r11
7009939c: e1a01008     	mov	r1, r8
700993a0: e28d2e22     	add	r2, sp, #544
700993a4: eb0000a8     	bl	0x7009964c <_pproc_fwp___TI_printfi_nofloat> @ imm = #0x2a0
700993a8: e5980000     	ldr	r0, [r8]
700993ac: e5d02000     	ldrb	r2, [r0]
700993b0: e2421068     	sub	r1, r2, #104
700993b4: e1a010e1     	ror	r1, r1, #1
700993b8: e3510009     	cmp	r1, #9
700993bc: 8a000026     	bhi	0x7009945c <__TI_printfi_nofloat+0x15c> @ imm = #0x98
700993c0: e28f3000     	add	r3, pc, #0
700993c4: e793f101     	ldr	pc, [r3, r1, lsl #2]
700993c8: f0 93 09 70  	.word	0x700993f0
700993cc: 0c 94 09 70  	.word	0x7009940c
700993d0: 18 94 09 70  	.word	0x70099418
700993d4: 5c 94 09 70  	.word	0x7009945c
700993d8: 5c 94 09 70  	.word	0x7009945c
700993dc: 5c 94 09 70  	.word	0x7009945c
700993e0: 38 94 09 70  	.word	0x70099438
700993e4: 5c 94 09 70  	.word	0x7009945c
700993e8: 5c 94 09 70  	.word	0x7009945c
700993ec: 44 94 09 70  	.word	0x70099444
700993f0: e1a01000     	mov	r1, r0
700993f4: e59d220c     	ldr	r2, [sp, #0x20c]
700993f8: e5f13001     	ldrb	r3, [r1, #0x1]!
700993fc: e3530068     	cmp	r3, #104
70099400: 1a00005b     	bne	0x70099574 <__TI_printfi_nofloat+0x274> @ imm = #0x16c
70099404: e3822c02     	orr	r2, r2, #512
70099408: ea000008     	b	0x70099430 <__TI_printfi_nofloat+0x130> @ imm = #0x20
7009940c: e59d120c     	ldr	r1, [sp, #0x20c]
70099410: e3812b02     	orr	r2, r1, #2048
70099414: ea00000c     	b	0x7009944c <__TI_printfi_nofloat+0x14c> @ imm = #0x30
70099418: e1a01000     	mov	r1, r0
7009941c: e59d220c     	ldr	r2, [sp, #0x20c]
70099420: e5f13001     	ldrb	r3, [r1, #0x1]!
70099424: e353006c     	cmp	r3, #108
70099428: 1a000053     	bne	0x7009957c <__TI_printfi_nofloat+0x27c> @ imm = #0x14c
7009942c: e3822c01     	orr	r2, r2, #256
70099430: e2801002     	add	r1, r0, #2
70099434: ea000005     	b	0x70099450 <__TI_printfi_nofloat+0x150> @ imm = #0x14
70099438: e59d120c     	ldr	r1, [sp, #0x20c]
7009943c: e3812a02     	orr	r2, r1, #8192
70099440: ea000001     	b	0x7009944c <__TI_printfi_nofloat+0x14c> @ imm = #0x4
70099444: e59d120c     	ldr	r1, [sp, #0x20c]
70099448: e3812a01     	orr	r2, r1, #4096
7009944c: e2801001     	add	r1, r0, #1
70099450: e58d220c     	str	r2, [sp, #0x20c]
70099454: e5d12000     	ldrb	r2, [r1]
70099458: e1a00001     	mov	r0, r1
7009945c: e2807001     	add	r7, r0, #1
70099460: e5cd2218     	strb	r2, [sp, #0x218]
70099464: e3520073     	cmp	r2, #115
70099468: e5887000     	str	r7, [r8]
7009946c: 0a00001a     	beq	0x700994dc <__TI_printfi_nofloat+0x1dc> @ imm = #0x68
70099470: e352006e     	cmp	r2, #110
70099474: 1a000022     	bne	0x70099504 <__TI_printfi_nofloat+0x204> @ imm = #0x88
70099478: e59d020c     	ldr	r0, [sp, #0x20c]
7009947c: e3031f60     	movw	r1, #0x3f60
70099480: e0000001     	and	r0, r0, r1
70099484: e3500020     	cmp	r0, #32
70099488: 0a00003e     	beq	0x70099588 <__TI_printfi_nofloat+0x288> @ imm = #0xf8
7009948c: e3500040     	cmp	r0, #64
70099490: 0a000041     	beq	0x7009959c <__TI_printfi_nofloat+0x29c> @ imm = #0x104
70099494: e3a0a000     	mov	r10, #0
70099498: e3500a02     	cmp	r0, #8192
7009949c: 0a00002f     	beq	0x70099560 <__TI_printfi_nofloat+0x260> @ imm = #0xbc
700994a0: e3500c02     	cmp	r0, #512
700994a4: 0a000042     	beq	0x700995b4 <__TI_printfi_nofloat+0x2b4> @ imm = #0x108
700994a8: e3500b02     	cmp	r0, #2048
700994ac: 0a000003     	beq	0x700994c0 <__TI_printfi_nofloat+0x1c0> @ imm = #0xc
700994b0: e3500a01     	cmp	r0, #4096
700994b4: 0a000029     	beq	0x70099560 <__TI_printfi_nofloat+0x260> @ imm = #0xa4
700994b8: e3500c01     	cmp	r0, #256
700994bc: 1a000027     	bne	0x70099560 <__TI_printfi_nofloat+0x260> @ imm = #0x9c
700994c0: e59d0220     	ldr	r0, [sp, #0x220]
700994c4: e1a03fc4     	asr	r3, r4, #31
700994c8: e4901004     	ldr	r1, [r0], #4
700994cc: e58d0220     	str	r0, [sp, #0x220]
700994d0: e5814000     	str	r4, [r1]
700994d4: e5813004     	str	r3, [r1, #0x4]
700994d8: ea000039     	b	0x700995c4 <__TI_printfi_nofloat+0x2c4> @ imm = #0xe4
700994dc: e5dd020c     	ldrb	r0, [sp, #0x20c]
700994e0: e3100040     	tst	r0, #64
700994e4: 1a000016     	bne	0x70099544 <__TI_printfi_nofloat+0x244> @ imm = #0x58
700994e8: e1a0000b     	mov	r0, r11
700994ec: e1a01006     	mov	r1, r6
700994f0: e28d2e22     	add	r2, sp, #544
700994f4: e28d3f87     	add	r3, sp, #540
700994f8: e58d5000     	str	r5, [sp]
700994fc: eb0000f9     	bl	0x700998e8 <_pproc_str___TI_printfi_nofloat> @ imm = #0x3e4
70099500: ea00002f     	b	0x700995c4 <__TI_printfi_nofloat+0x2c4> @ imm = #0xbc
70099504: e28da00e     	add	r10, sp, #14
70099508: e1a0100b     	mov	r1, r11
7009950c: e28d2e22     	add	r2, sp, #544
70099510: e1a0000a     	mov	r0, r10
70099514: eb000138     	bl	0x700999fc <_setfield___TI_printfi_nofloat> @ imm = #0x4e0
70099518: e59d3248     	ldr	r3, [sp, #0x248]
7009951c: e1a02000     	mov	r2, r0
70099520: e1a0000a     	mov	r0, r10
70099524: e1a01006     	mov	r1, r6
70099528: e12fff33     	blx	r3
7009952c: e3700001     	cmn	r0, #1
70099530: 10800004     	addne	r0, r0, r4
70099534: e3a0a000     	mov	r10, #0
70099538: e1a04000     	mov	r4, r0
7009953c: e58d021c     	str	r0, [sp, #0x21c]
70099540: ea000020     	b	0x700995c8 <__TI_printfi_nofloat+0x2c8> @ imm = #0x80
70099544: e1a0000b     	mov	r0, r11
70099548: e1a01006     	mov	r1, r6
7009954c: e28d2e22     	add	r2, sp, #544
70099550: e28d3f87     	add	r3, sp, #540
70099554: e58d5000     	str	r5, [sp]
70099558: eb000092     	bl	0x700997a8 <_pproc_wstr___TI_printfi_nofloat> @ imm = #0x248
7009955c: ea000018     	b	0x700995c4 <__TI_printfi_nofloat+0x2c4> @ imm = #0x60
70099560: e59d0220     	ldr	r0, [sp, #0x220]
70099564: e4901004     	ldr	r1, [r0], #4
70099568: e58d0220     	str	r0, [sp, #0x220]
7009956c: e5814000     	str	r4, [r1]
70099570: ea000013     	b	0x700995c4 <__TI_printfi_nofloat+0x2c4> @ imm = #0x4c
70099574: e3820020     	orr	r0, r2, #32
70099578: ea000000     	b	0x70099580 <__TI_printfi_nofloat+0x280> @ imm = #0x0
7009957c: e3820040     	orr	r0, r2, #64
70099580: e58d020c     	str	r0, [sp, #0x20c]
70099584: eaffffb2     	b	0x70099454 <__TI_printfi_nofloat+0x154> @ imm = #-0x138
70099588: e59d0220     	ldr	r0, [sp, #0x220]
7009958c: e4901004     	ldr	r1, [r0], #4
70099590: e58d0220     	str	r0, [sp, #0x220]
70099594: e1c140b0     	strh	r4, [r1]
70099598: ea000003     	b	0x700995ac <__TI_printfi_nofloat+0x2ac> @ imm = #0xc
7009959c: e59d0220     	ldr	r0, [sp, #0x220]
700995a0: e4901004     	ldr	r1, [r0], #4
700995a4: e58d0220     	str	r0, [sp, #0x220]
700995a8: e5814000     	str	r4, [r1]
700995ac: e3a0a000     	mov	r10, #0
700995b0: ea000003     	b	0x700995c4 <__TI_printfi_nofloat+0x2c4> @ imm = #0xc
700995b4: e59d0220     	ldr	r0, [sp, #0x220]
700995b8: e4901004     	ldr	r1, [r0], #4
700995bc: e58d0220     	str	r0, [sp, #0x220]
700995c0: e5c14000     	strb	r4, [r1]
700995c4: e59d421c     	ldr	r4, [sp, #0x21c]
700995c8: e3e00000     	mvn	r0, #0
700995cc: e3740001     	cmn	r4, #1
700995d0: 1affff59     	bne	0x7009933c <__TI_printfi_nofloat+0x3c> @ imm = #-0x29c
700995d4: e3e04000     	mvn	r4, #0
700995d8: e1a00004     	mov	r0, r4
700995dc: e28ddf89     	add	sp, sp, #548
700995e0: e8bd8ff0     	pop	{r4, r5, r6, r7, r8, r9, r10, r11, pc}

700995e4 <pproc_fflags___TI_printfi_nofloat>:
700995e4: e591c000     	ldr	r12, [r1]
700995e8: e5dc3000     	ldrb	r3, [r12]
700995ec: e3530020     	cmp	r3, #32
700995f0: 0a00000a     	beq	0x70099620 <pproc_fflags___TI_printfi_nofloat+0x3c> @ imm = #0x28
700995f4: e3530023     	cmp	r3, #35
700995f8: 0a00000a     	beq	0x70099628 <pproc_fflags___TI_printfi_nofloat+0x44> @ imm = #0x28
700995fc: e3530030     	cmp	r3, #48
70099600: 0a00000a     	beq	0x70099630 <pproc_fflags___TI_printfi_nofloat+0x4c> @ imm = #0x28
70099604: e3a02001     	mov	r2, #1
70099608: e353002d     	cmp	r3, #45
7009960c: 0a000008     	beq	0x70099634 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x20
70099610: e353002b     	cmp	r3, #43
70099614: 112fff1e     	bxne	lr
70099618: e3a02002     	mov	r2, #2
7009961c: ea000004     	b	0x70099634 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x10
70099620: e3a02004     	mov	r2, #4
70099624: ea000002     	b	0x70099634 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x8
70099628: e3a02008     	mov	r2, #8
7009962c: ea000000     	b	0x70099634 <pproc_fflags___TI_printfi_nofloat+0x50> @ imm = #0x0
70099630: e3a02010     	mov	r2, #16
70099634: e5903000     	ldr	r3, [r0]
70099638: e1832002     	orr	r2, r3, r2
7009963c: e28c3001     	add	r3, r12, #1
70099640: e5802000     	str	r2, [r0]
70099644: e5813000     	str	r3, [r1]
70099648: eaffffe5     	b	0x700995e4 <pproc_fflags___TI_printfi_nofloat> @ imm = #-0x6c

7009964c <_pproc_fwp___TI_printfi_nofloat>:
7009964c: e92d48ff     	push	{r0, r1, r2, r3, r4, r5, r6, r7, r11, lr}
70099650: e1a05001     	mov	r5, r1
70099654: e5911000     	ldr	r1, [r1]
70099658: e1a06002     	mov	r6, r2
7009965c: e1a04000     	mov	r4, r0
70099660: e5d13000     	ldrb	r3, [r1]
70099664: e353002a     	cmp	r3, #42
70099668: 1a00000f     	bne	0x700996ac <_pproc_fwp___TI_printfi_nofloat+0x60> @ imm = #0x3c
7009966c: e5960000     	ldr	r0, [r6]
70099670: e2801004     	add	r1, r0, #4
70099674: e5861000     	str	r1, [r6]
70099678: e5900000     	ldr	r0, [r0]
7009967c: e3700001     	cmn	r0, #1
70099680: e5840004     	str	r0, [r4, #0x4]
70099684: ca000004     	bgt	0x7009969c <_pproc_fwp___TI_printfi_nofloat+0x50> @ imm = #0x10
70099688: e5941000     	ldr	r1, [r4]
7009968c: e2600000     	rsb	r0, r0, #0
70099690: e3811001     	orr	r1, r1, #1
70099694: e5840004     	str	r0, [r4, #0x4]
70099698: e5841000     	str	r1, [r4]
7009969c: e5950000     	ldr	r0, [r5]
700996a0: e2807001     	add	r7, r0, #1
700996a4: e5857000     	str	r7, [r5]
700996a8: ea000015     	b	0x70099704 <_pproc_fwp___TI_printfi_nofloat+0xb8> @ imm = #0x54
700996ac: e3a00000     	mov	r0, #0
700996b0: e28d2006     	add	r2, sp, #6
700996b4: e2433030     	sub	r3, r3, #48
700996b8: e3530009     	cmp	r3, #9
700996bc: 8a000007     	bhi	0x700996e0 <_pproc_fwp___TI_printfi_nofloat+0x94> @ imm = #0x1c
700996c0: e0813000     	add	r3, r1, r0
700996c4: e2837001     	add	r7, r3, #1
700996c8: e5857000     	str	r7, [r5]
700996cc: e7d17000     	ldrb	r7, [r1, r0]
700996d0: e5d33001     	ldrb	r3, [r3, #0x1]
700996d4: e7c27000     	strb	r7, [r2, r0]
700996d8: e2800001     	add	r0, r0, #1
700996dc: eafffff4     	b	0x700996b4 <_pproc_fwp___TI_printfi_nofloat+0x68> @ imm = #-0x30
700996e0: e3a03000     	mov	r3, #0
700996e4: e0817000     	add	r7, r1, r0
700996e8: e7c23000     	strb	r3, [r2, r0]
700996ec: e5dd2006     	ldrb	r2, [sp, #0x6]
700996f0: e3520000     	cmp	r2, #0
700996f4: 0a000002     	beq	0x70099704 <_pproc_fwp___TI_printfi_nofloat+0xb8> @ imm = #0x8
700996f8: e28d0006     	add	r0, sp, #6
700996fc: eb004802     	bl	0x700ab70c <atoi>       @ imm = #0x12008
70099700: e5840004     	str	r0, [r4, #0x4]
70099704: e5d70000     	ldrb	r0, [r7]
70099708: e350002e     	cmp	r0, #46
7009970c: 18bd88ff     	popne	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
70099710: e2870001     	add	r0, r7, #1
70099714: e5850000     	str	r0, [r5]
70099718: e5d72001     	ldrb	r2, [r7, #0x1]
7009971c: e352002a     	cmp	r2, #42
70099720: 1a000008     	bne	0x70099748 <_pproc_fwp___TI_printfi_nofloat+0xfc> @ imm = #0x20
70099724: e5960000     	ldr	r0, [r6]
70099728: e2801004     	add	r1, r0, #4
7009972c: e5861000     	str	r1, [r6]
70099730: e5951000     	ldr	r1, [r5]
70099734: e5900000     	ldr	r0, [r0]
70099738: e2811001     	add	r1, r1, #1
7009973c: e5840008     	str	r0, [r4, #0x8]
70099740: e5851000     	str	r1, [r5]
70099744: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
70099748: e3a00000     	mov	r0, #0
7009974c: e28d1006     	add	r1, sp, #6
70099750: e2422030     	sub	r2, r2, #48
70099754: e3520009     	cmp	r2, #9
70099758: 8a000007     	bhi	0x7009977c <_pproc_fwp___TI_printfi_nofloat+0x130> @ imm = #0x1c
7009975c: e0872000     	add	r2, r7, r0
70099760: e2823002     	add	r3, r2, #2
70099764: e5853000     	str	r3, [r5]
70099768: e5d23001     	ldrb	r3, [r2, #0x1]
7009976c: e5d22002     	ldrb	r2, [r2, #0x2]
70099770: e7c13000     	strb	r3, [r1, r0]
70099774: e2800001     	add	r0, r0, #1
70099778: eafffff4     	b	0x70099750 <_pproc_fwp___TI_printfi_nofloat+0x104> @ imm = #-0x30
7009977c: e3a02000     	mov	r2, #0
70099780: e7c12000     	strb	r2, [r1, r0]
70099784: e5dd0006     	ldrb	r0, [sp, #0x6]
70099788: e3500000     	cmp	r0, #0
7009978c: 0a000003     	beq	0x700997a0 <_pproc_fwp___TI_printfi_nofloat+0x154> @ imm = #0xc
70099790: e28d0006     	add	r0, sp, #6
70099794: eb0047dc     	bl	0x700ab70c <atoi>       @ imm = #0x11f70
70099798: e5840008     	str	r0, [r4, #0x8]
7009979c: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}
700997a0: e5842008     	str	r2, [r4, #0x8]
700997a4: e8bd88ff     	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r11, pc}

700997a8 <_pproc_wstr___TI_printfi_nofloat>:
700997a8: e92d4ff8     	push	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
700997ac: e5927000     	ldr	r7, [r2]
700997b0: e1a04001     	mov	r4, r1
700997b4: e59dc028     	ldr	r12, [sp, #0x28]
700997b8: e2876004     	add	r6, r7, #4
700997bc: e5826000     	str	r6, [r2]
700997c0: e5976000     	ldr	r6, [r7]
700997c4: e3560000     	cmp	r6, #0
700997c8: 0a00002d     	beq	0x70099884 <_pproc_wstr___TI_printfi_nofloat+0xdc> @ imm = #0xb4
700997cc: e5907008     	ldr	r7, [r0, #0x8]
700997d0: e1a05003     	mov	r5, r3
700997d4: e1a09000     	mov	r9, r0
700997d8: e1a0800c     	mov	r8, r12
700997dc: e3570000     	cmp	r7, #0
700997e0: 4a000003     	bmi	0x700997f4 <_pproc_wstr___TI_printfi_nofloat+0x4c> @ imm = #0xc
700997e4: e1a00006     	mov	r0, r6
700997e8: eb0056f4     	bl	0x700af3c0 <wcslen>     @ imm = #0x15bd0
700997ec: e1570000     	cmp	r7, r0
700997f0: 3a000002     	blo	0x70099800 <_pproc_wstr___TI_printfi_nofloat+0x58> @ imm = #0x8
700997f4: e1a00006     	mov	r0, r6
700997f8: eb0056f0     	bl	0x700af3c0 <wcslen>     @ imm = #0x15bc0
700997fc: e1a07000     	mov	r7, r0
70099800: e599a004     	ldr	r10, [r9, #0x4]
70099804: e1a0b007     	mov	r11, r7
70099808: e5950000     	ldr	r0, [r5]
7009980c: e58d5000     	str	r5, [sp]
70099810: e15a0007     	cmp	r10, r7
70099814: c1a0b00a     	movgt	r11, r10
70099818: e080000b     	add	r0, r0, r11
7009981c: e5850000     	str	r0, [r5]
70099820: da00000b     	ble	0x70099854 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x2c
70099824: e5d90000     	ldrb	r0, [r9]
70099828: e3100001     	tst	r0, #1
7009982c: 1a000008     	bne	0x70099854 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x20
70099830: e04b0007     	sub	r0, r11, r7
70099834: e1c05fc0     	bic	r5, r0, r0, asr #31
70099838: e3550000     	cmp	r5, #0
7009983c: 0a000004     	beq	0x70099854 <_pproc_wstr___TI_printfi_nofloat+0xac> @ imm = #0x10
70099840: e3a00020     	mov	r0, #32
70099844: e1a01004     	mov	r1, r4
70099848: e12fff38     	blx	r8
7009984c: e2455001     	sub	r5, r5, #1
70099850: eafffff8     	b	0x70099838 <_pproc_wstr___TI_printfi_nofloat+0x90> @ imm = #-0x20
70099854: e1c75fc7     	bic	r5, r7, r7, asr #31
70099858: e3550000     	cmp	r5, #0
7009985c: 0a00000c     	beq	0x70099894 <_pproc_wstr___TI_printfi_nofloat+0xec> @ imm = #0x30
70099860: e5960000     	ldr	r0, [r6]
70099864: e3500c01     	cmp	r0, #256
70099868: 2a000017     	bhs	0x700998cc <_pproc_wstr___TI_printfi_nofloat+0x124> @ imm = #0x5c
7009986c: e6ef0070     	uxtb	r0, r0
70099870: e1a01004     	mov	r1, r4
70099874: e2866004     	add	r6, r6, #4
70099878: e12fff38     	blx	r8
7009987c: e2455001     	sub	r5, r5, #1
70099880: eafffff4     	b	0x70099858 <_pproc_wstr___TI_printfi_nofloat+0xb0> @ imm = #-0x30
70099884: e3a00000     	mov	r0, #0
70099888: e1a01004     	mov	r1, r4
7009988c: e8bd4ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099890: e12fff1c     	bx	r12
70099894: e15a0007     	cmp	r10, r7
70099898: da000011     	ble	0x700998e4 <_pproc_wstr___TI_printfi_nofloat+0x13c> @ imm = #0x44
7009989c: e5d90000     	ldrb	r0, [r9]
700998a0: e3100001     	tst	r0, #1
700998a4: 08bd8ff8     	popeq	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
700998a8: e04b0007     	sub	r0, r11, r7
700998ac: e1c05fc0     	bic	r5, r0, r0, asr #31
700998b0: e3550000     	cmp	r5, #0
700998b4: 0a00000a     	beq	0x700998e4 <_pproc_wstr___TI_printfi_nofloat+0x13c> @ imm = #0x28
700998b8: e3a00020     	mov	r0, #32
700998bc: e1a01004     	mov	r1, r4
700998c0: e12fff38     	blx	r8
700998c4: e2455001     	sub	r5, r5, #1
700998c8: eafffff8     	b	0x700998b0 <_pproc_wstr___TI_printfi_nofloat+0x108> @ imm = #-0x20
700998cc: e3e00000     	mvn	r0, #0
700998d0: e59d1000     	ldr	r1, [sp]
700998d4: e5810000     	str	r0, [r1]
700998d8: eb00048d     	bl	0x7009ab14 <__aeabi_errno_addr> @ imm = #0x1234
700998dc: e3a01058     	mov	r1, #88
700998e0: e5801000     	str	r1, [r0]
700998e4: e8bd8ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}

700998e8 <_pproc_str___TI_printfi_nofloat>:
700998e8: e92d4ff8     	push	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
700998ec: e5927000     	ldr	r7, [r2]
700998f0: e1a04001     	mov	r4, r1
700998f4: e59dc028     	ldr	r12, [sp, #0x28]
700998f8: e2876004     	add	r6, r7, #4
700998fc: e5826000     	str	r6, [r2]
70099900: e5977000     	ldr	r7, [r7]
70099904: e3570000     	cmp	r7, #0
70099908: 0a000037     	beq	0x700999ec <_pproc_str___TI_printfi_nofloat+0x104> @ imm = #0xdc
7009990c: e590b008     	ldr	r11, [r0, #0x8]
70099910: e1a05003     	mov	r5, r3
70099914: e1a08000     	mov	r8, r0
70099918: e1a0600c     	mov	r6, r12
7009991c: e35b0000     	cmp	r11, #0
70099920: 4a000003     	bmi	0x70099934 <_pproc_str___TI_printfi_nofloat+0x4c> @ imm = #0xc
70099924: e1a00007     	mov	r0, r7
70099928: eb005723     	bl	0x700af5bc <strlen>     @ imm = #0x15c8c
7009992c: e15b0000     	cmp	r11, r0
70099930: 3a000002     	blo	0x70099940 <_pproc_str___TI_printfi_nofloat+0x58> @ imm = #0x8
70099934: e1a00007     	mov	r0, r7
70099938: eb00571f     	bl	0x700af5bc <strlen>     @ imm = #0x15c7c
7009993c: e1a0b000     	mov	r11, r0
70099940: e598a004     	ldr	r10, [r8, #0x4]
70099944: e1a0900b     	mov	r9, r11
70099948: e5950000     	ldr	r0, [r5]
7009994c: e15a000b     	cmp	r10, r11
70099950: c1a0900a     	movgt	r9, r10
70099954: e0800009     	add	r0, r0, r9
70099958: e5850000     	str	r0, [r5]
7009995c: da00000b     	ble	0x70099990 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x2c
70099960: e5d80000     	ldrb	r0, [r8]
70099964: e3100001     	tst	r0, #1
70099968: 1a000008     	bne	0x70099990 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x20
7009996c: e049000b     	sub	r0, r9, r11
70099970: e1c05fc0     	bic	r5, r0, r0, asr #31
70099974: e3550000     	cmp	r5, #0
70099978: 0a000004     	beq	0x70099990 <_pproc_str___TI_printfi_nofloat+0xa8> @ imm = #0x10
7009997c: e3a00020     	mov	r0, #32
70099980: e1a01004     	mov	r1, r4
70099984: e12fff36     	blx	r6
70099988: e2455001     	sub	r5, r5, #1
7009998c: eafffff8     	b	0x70099974 <_pproc_str___TI_printfi_nofloat+0x8c> @ imm = #-0x20
70099990: e1cb5fcb     	bic	r5, r11, r11, asr #31
70099994: e3550000     	cmp	r5, #0
70099998: 0a000004     	beq	0x700999b0 <_pproc_str___TI_printfi_nofloat+0xc8> @ imm = #0x10
7009999c: e4d70001     	ldrb	r0, [r7], #1
700999a0: e1a01004     	mov	r1, r4
700999a4: e12fff36     	blx	r6
700999a8: e2455001     	sub	r5, r5, #1
700999ac: eafffff8     	b	0x70099994 <_pproc_str___TI_printfi_nofloat+0xac> @ imm = #-0x20
700999b0: e15a000b     	cmp	r10, r11
700999b4: da00000b     	ble	0x700999e8 <_pproc_str___TI_printfi_nofloat+0x100> @ imm = #0x2c
700999b8: e5d80000     	ldrb	r0, [r8]
700999bc: e3100001     	tst	r0, #1
700999c0: 08bd8ff8     	popeq	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
700999c4: e049000b     	sub	r0, r9, r11
700999c8: e1c05fc0     	bic	r5, r0, r0, asr #31
700999cc: e3550000     	cmp	r5, #0
700999d0: 0a000004     	beq	0x700999e8 <_pproc_str___TI_printfi_nofloat+0x100> @ imm = #0x10
700999d4: e3a00020     	mov	r0, #32
700999d8: e1a01004     	mov	r1, r4
700999dc: e12fff36     	blx	r6
700999e0: e2455001     	sub	r5, r5, #1
700999e4: eafffff8     	b	0x700999cc <_pproc_str___TI_printfi_nofloat+0xe4> @ imm = #-0x20
700999e8: e8bd8ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
700999ec: e3a00000     	mov	r0, #0
700999f0: e1a01004     	mov	r1, r4
700999f4: e8bd4ff8     	pop	{r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
700999f8: e12fff1c     	bx	r12

700999fc <_setfield___TI_printfi_nofloat>:
700999fc: e92d4ffe     	push	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, lr}
70099a00: e1a05001     	mov	r5, r1
70099a04: e5918004     	ldr	r8, [r1, #0x4]
70099a08: e3a09000     	mov	r9, #0
70099a0c: e1a06002     	mov	r6, r2
70099a10: e30011fd     	movw	r1, #0x1fd
70099a14: e3a02020     	mov	r2, #32
70099a18: e1a04000     	mov	r4, r0
70099a1c: e58d9004     	str	r9, [sp, #0x4]
70099a20: eb00585e     	bl	0x700afba0 <__aeabi_memset8> @ imm = #0x16178
70099a24: e1a0b004     	mov	r11, r4
70099a28: e2842f7f     	add	r2, r4, #508
70099a2c: e5eb91fd     	strb	r9, [r11, #0x1fd]!
70099a30: e5d5000c     	ldrb	r0, [r5, #0xc]
70099a34: e58d2008     	str	r2, [sp, #0x8]
70099a38: e2401063     	sub	r1, r0, #99
70099a3c: e3510015     	cmp	r1, #21
70099a40: 8a000080     	bhi	0x70099c48 <_setfield___TI_printfi_nofloat+0x24c> @ imm = #0x200
70099a44: e59f2258     	ldr	r2, [pc, #0x258]        @ 0x70099ca4 <_setfield___TI_printfi_nofloat+0x2a8>
70099a48: e3a03001     	mov	r3, #1
70099a4c: e1120113     	tst	r2, r3, lsl r1
70099a50: 0a00006b     	beq	0x70099c04 <_setfield___TI_printfi_nofloat+0x208> @ imm = #0x1ac
70099a54: e28d1004     	add	r1, sp, #4
70099a58: e28d2008     	add	r2, sp, #8
70099a5c: e1a00005     	mov	r0, r5
70099a60: e1a03006     	mov	r3, r6
70099a64: eb00008f     	bl	0x70099ca8 <_pproc_diouxp___TI_printfi_nofloat> @ imm = #0x23c
70099a68: e3a09000     	mov	r9, #0
70099a6c: e5d5000c     	ldrb	r0, [r5, #0xc]
70099a70: e240106f     	sub	r1, r0, #111
70099a74: e3510009     	cmp	r1, #9
70099a78: 8a00003c     	bhi	0x70099b70 <_setfield___TI_printfi_nofloat+0x174> @ imm = #0xf0
70099a7c: e3a02001     	mov	r2, #1
70099a80: e3003243     	movw	r3, #0x243
70099a84: e1130112     	tst	r3, r2, lsl r1
70099a88: 0a000038     	beq	0x70099b70 <_setfield___TI_printfi_nofloat+0x174> @ imm = #0xe0
70099a8c: e3a0a000     	mov	r10, #0
70099a90: e5d51000     	ldrb	r1, [r5]
70099a94: e0847008     	add	r7, r4, r8
70099a98: e59d0008     	ldr	r0, [sp, #0x8]
70099a9c: e1a06004     	mov	r6, r4
70099aa0: e3110001     	tst	r1, #1
70099aa4: 1a000006     	bne	0x70099ac4 <_setfield___TI_printfi_nofloat+0xc8> @ imm = #0x18
70099aa8: e5952004     	ldr	r2, [r5, #0x4]
70099aac: e04b1000     	sub	r1, r11, r0
70099ab0: e1a06004     	mov	r6, r4
70099ab4: e1510002     	cmp	r1, r2
70099ab8: ca000001     	bgt	0x70099ac4 <_setfield___TI_printfi_nofloat+0xc8> @ imm = #0x4
70099abc: e0471001     	sub	r1, r7, r1
70099ac0: e2816001     	add	r6, r1, #1
70099ac4: e2801001     	add	r1, r0, #1
70099ac8: e1a00006     	mov	r0, r6
70099acc: e3a02000     	mov	r2, #0
70099ad0: e30031fe     	movw	r3, #0x1fe
70099ad4: e3a08000     	mov	r8, #0
70099ad8: eb004ee6     	bl	0x700ad678 <memccpy>    @ imm = #0x13b98
70099adc: e58d0008     	str	r0, [sp, #0x8]
70099ae0: e3590000     	cmp	r9, #0
70099ae4: 0a000001     	beq	0x70099af0 <_setfield___TI_printfi_nofloat+0xf4> @ imm = #0x4
70099ae8: e4c08001     	strb	r8, [r0], #1
70099aec: e58d0008     	str	r0, [sp, #0x8]
70099af0: e1500007     	cmp	r0, r7
70099af4: 8a000006     	bhi	0x70099b14 <_setfield___TI_printfi_nofloat+0x118> @ imm = #0x18
70099af8: e0471000     	sub	r1, r7, r0
70099afc: e2400001     	sub	r0, r0, #1
70099b00: e3a02020     	mov	r2, #32
70099b04: e2811001     	add	r1, r1, #1
70099b08: eb005824     	bl	0x700afba0 <__aeabi_memset8> @ imm = #0x16090
70099b0c: e3a00000     	mov	r0, #0
70099b10: e5c70000     	strb	r0, [r7]
70099b14: e5d50000     	ldrb	r0, [r5]
70099b18: e3100010     	tst	r0, #16
70099b1c: 1a000004     	bne	0x70099b34 <_setfield___TI_printfi_nofloat+0x138> @ imm = #0x10
70099b20: e0461004     	sub	r1, r6, r4
70099b24: e1a00004     	mov	r0, r4
70099b28: e3a02020     	mov	r2, #32
70099b2c: eb00581b     	bl	0x700afba0 <__aeabi_memset8> @ imm = #0x1606c
70099b30: ea00002f     	b	0x70099bf4 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xbc
70099b34: e1560004     	cmp	r6, r4
70099b38: 0a00002d     	beq	0x70099bf4 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xb4
70099b3c: e0461004     	sub	r1, r6, r4
70099b40: e1a00004     	mov	r0, r4
70099b44: e3a02030     	mov	r2, #48
70099b48: e3a07030     	mov	r7, #48
70099b4c: eb005813     	bl	0x700afba0 <__aeabi_memset8> @ imm = #0x1604c
70099b50: e59d0004     	ldr	r0, [sp, #0x4]
70099b54: e190000a     	orrs	r0, r0, r10
70099b58: 1a00000e     	bne	0x70099b98 <_setfield___TI_printfi_nofloat+0x19c> @ imm = #0x38
70099b5c: e5d50000     	ldrb	r0, [r5]
70099b60: e3100004     	tst	r0, #4
70099b64: 1a00000b     	bne	0x70099b98 <_setfield___TI_printfi_nofloat+0x19c> @ imm = #0x2c
70099b68: e1a00004     	mov	r0, r4
70099b6c: ea00000d     	b	0x70099ba8 <_setfield___TI_printfi_nofloat+0x1ac> @ imm = #0x34
70099b70: e3500058     	cmp	r0, #88
70099b74: 0affffc4     	beq	0x70099a8c <_setfield___TI_printfi_nofloat+0x90> @ imm = #-0xf0
70099b78: e5950000     	ldr	r0, [r5]
70099b7c: e59d1004     	ldr	r1, [sp, #0x4]
70099b80: e200a002     	and	r10, r0, #2
70099b84: e3510000     	cmp	r1, #0
70099b88: 0a000037     	beq	0x70099c6c <_setfield___TI_printfi_nofloat+0x270> @ imm = #0xdc
70099b8c: e3a0002d     	mov	r0, #45
70099b90: e59d1008     	ldr	r1, [sp, #0x8]
70099b94: ea00003f     	b	0x70099c98 <_setfield___TI_printfi_nofloat+0x29c> @ imm = #0xfc
70099b98: e5d61000     	ldrb	r1, [r6]
70099b9c: e1a00004     	mov	r0, r4
70099ba0: e4c01001     	strb	r1, [r0], #1
70099ba4: e4c67001     	strb	r7, [r6], #1
70099ba8: e5d5100c     	ldrb	r1, [r5, #0xc]
70099bac: e3510041     	cmp	r1, #65
70099bb0: 0a00000b     	beq	0x70099be4 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x2c
70099bb4: e3510058     	cmp	r1, #88
70099bb8: 0a000004     	beq	0x70099bd0 <_setfield___TI_printfi_nofloat+0x1d4> @ imm = #0x10
70099bbc: e3510061     	cmp	r1, #97
70099bc0: 0a000007     	beq	0x70099be4 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x1c
70099bc4: e3510078     	cmp	r1, #120
70099bc8: 13510070     	cmpne	r1, #112
70099bcc: 1a000008     	bne	0x70099bf4 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0x20
70099bd0: e5d52000     	ldrb	r2, [r5]
70099bd4: e3120008     	tst	r2, #8
70099bd8: 1a000001     	bne	0x70099be4 <_setfield___TI_printfi_nofloat+0x1e8> @ imm = #0x4
70099bdc: e3510061     	cmp	r1, #97
70099be0: 1a000003     	bne	0x70099bf4 <_setfield___TI_printfi_nofloat+0x1f8> @ imm = #0xc
70099be4: e5d61001     	ldrb	r1, [r6, #0x1]
70099be8: e3a02030     	mov	r2, #48
70099bec: e5c01001     	strb	r1, [r0, #0x1]
70099bf0: e5c62001     	strb	r2, [r6, #0x1]
70099bf4: e1a00004     	mov	r0, r4
70099bf8: eb00566f     	bl	0x700af5bc <strlen>     @ imm = #0x159bc
70099bfc: e0800009     	add	r0, r0, r9
70099c00: e8bd8ffe     	pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099c04: e3510000     	cmp	r1, #0
70099c08: 1a00000e     	bne	0x70099c48 <_setfield___TI_printfi_nofloat+0x24c> @ imm = #0x38
70099c0c: e5960000     	ldr	r0, [r6]
70099c10: e2801004     	add	r1, r0, #4
70099c14: e5861000     	str	r1, [r6]
70099c18: e5900000     	ldr	r0, [r0]
70099c1c: e6ef1070     	uxtb	r1, r0
70099c20: e5c401fc     	strb	r0, [r4, #0x1fc]
70099c24: e30001fb     	movw	r0, #0x1fb
70099c28: e5952000     	ldr	r2, [r5]
70099c2c: e16f1f11     	clz	r1, r1
70099c30: e0840000     	add	r0, r4, r0
70099c34: e3c22002     	bic	r2, r2, #2
70099c38: e1a092a1     	lsr	r9, r1, #5
70099c3c: e58d0008     	str	r0, [sp, #0x8]
70099c40: e5852000     	str	r2, [r5]
70099c44: eaffff88     	b	0x70099a6c <_setfield___TI_printfi_nofloat+0x70> @ imm = #-0x1e0
70099c48: e3500025     	cmp	r0, #37
70099c4c: 0a000002     	beq	0x70099c5c <_setfield___TI_printfi_nofloat+0x260> @ imm = #0x8
70099c50: e3500058     	cmp	r0, #88
70099c54: 0affff7e     	beq	0x70099a54 <_setfield___TI_printfi_nofloat+0x58> @ imm = #-0x208
70099c58: eaffff84     	b	0x70099a70 <_setfield___TI_printfi_nofloat+0x74> @ imm = #-0x1f0
70099c5c: e3a01025     	mov	r1, #37
70099c60: e3a00001     	mov	r0, #1
70099c64: e1c410b0     	strh	r1, [r4]
70099c68: e8bd8ffe     	pop	{r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, pc}
70099c6c: e35a0000     	cmp	r10, #0
70099c70: 1a000005     	bne	0x70099c8c <_setfield___TI_printfi_nofloat+0x290> @ imm = #0x14
70099c74: e3100004     	tst	r0, #4
70099c78: 0affff83     	beq	0x70099a8c <_setfield___TI_printfi_nofloat+0x90> @ imm = #-0x1f4
70099c7c: e3a00020     	mov	r0, #32
70099c80: e59d1008     	ldr	r1, [sp, #0x8]
70099c84: e3a0a000     	mov	r10, #0
70099c88: ea000002     	b	0x70099c98 <_setfield___TI_printfi_nofloat+0x29c> @ imm = #0x8
70099c8c: e3a0002b     	mov	r0, #43
70099c90: e59d1008     	ldr	r1, [sp, #0x8]
70099c94: e3a0a001     	mov	r10, #1
70099c98: e4410001     	strb	r0, [r1], #-1
70099c9c: e58d1008     	str	r1, [sp, #0x8]
70099ca0: eaffff7a     	b	0x70099a90 <_setfield___TI_printfi_nofloat+0x94> @ imm = #-0x218
70099ca4: 42 30 24 00  	.word	0x00243042

70099ca8 <_pproc_diouxp___TI_printfi_nofloat>:
70099ca8: e92d48fc     	push	{r2, r3, r4, r5, r6, r7, r11, lr}
70099cac: e1a05000     	mov	r5, r0
70099cb0: e5900008     	ldr	r0, [r0, #0x8]
70099cb4: e1a04002     	mov	r4, r2
70099cb8: e1a07001     	mov	r7, r1
70099cbc: e3a06010     	mov	r6, #16
70099cc0: e3700001     	cmn	r0, #1
70099cc4: c5950000     	ldrgt	r0, [r5]
70099cc8: c3c00010     	bicgt	r0, r0, #16
70099ccc: c5850000     	strgt	r0, [r5]
70099cd0: d3a00001     	movle	r0, #1
70099cd4: d5850008     	strle	r0, [r5, #0x8]
70099cd8: e5d5000c     	ldrb	r0, [r5, #0xc]
70099cdc: e3500058     	cmp	r0, #88
70099ce0: 0a000005     	beq	0x70099cfc <_pproc_diouxp___TI_printfi_nofloat+0x54> @ imm = #0x14
70099ce4: e3500078     	cmp	r0, #120
70099ce8: 13500070     	cmpne	r0, #112
70099cec: 0a000002     	beq	0x70099cfc <_pproc_diouxp___TI_printfi_nofloat+0x54> @ imm = #0x8
70099cf0: e350006f     	cmp	r0, #111
70099cf4: 13a0600a     	movne	r6, #10
70099cf8: 03a06008     	moveq	r6, #8
70099cfc: e1a00005     	mov	r0, r5
70099d00: e1a01003     	mov	r1, r3
70099d04: eb00004d     	bl	0x70099e40 <_getarg_diouxp___TI_printfi_nofloat> @ imm = #0x134
70099d08: e5952008     	ldr	r2, [r5, #0x8]
70099d0c: e3520000     	cmp	r2, #0
70099d10: 01902001     	orrseq	r2, r0, r1
70099d14: 0a000007     	beq	0x70099d38 <_pproc_diouxp___TI_printfi_nofloat+0x90> @ imm = #0x1c
70099d18: e5d5300c     	ldrb	r3, [r5, #0xc]
70099d1c: e3530064     	cmp	r3, #100
70099d20: 1a00000b     	bne	0x70099d54 <_pproc_diouxp___TI_printfi_nofloat+0xac> @ imm = #0x2c
70099d24: e3a02064     	mov	r2, #100
70099d28: e3a03064     	mov	r3, #100
70099d2c: e3710001     	cmn	r1, #1
70099d30: ca000011     	bgt	0x70099d7c <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x44
70099d34: ea00000b     	b	0x70099d68 <_pproc_diouxp___TI_printfi_nofloat+0xc0> @ imm = #0x2c
70099d38: e5d50000     	ldrb	r0, [r5]
70099d3c: e3100008     	tst	r0, #8
70099d40: 0a00003d     	beq	0x70099e3c <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0xf4
70099d44: e5d5300c     	ldrb	r3, [r5, #0xc]
70099d48: e3a00000     	mov	r0, #0
70099d4c: e3a01000     	mov	r1, #0
70099d50: ea000009     	b	0x70099d7c <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x24
70099d54: e3530069     	cmp	r3, #105
70099d58: 1a000007     	bne	0x70099d7c <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x1c
70099d5c: e3a02069     	mov	r2, #105
70099d60: e3510000     	cmp	r1, #0
70099d64: 5a000004     	bpl	0x70099d7c <_pproc_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x10
70099d68: e2700000     	rsbs	r0, r0, #0
70099d6c: e3a0c001     	mov	r12, #1
70099d70: e2e11000     	rsc	r1, r1, #0
70099d74: e1a03002     	mov	r3, r2
70099d78: e587c000     	str	r12, [r7]
70099d7c: e1a02006     	mov	r2, r6
70099d80: e58d4000     	str	r4, [sp]
70099d84: eb00009c     	bl	0x70099ffc <_ltostr___TI_printfi_nofloat> @ imm = #0x270
70099d88: e3a01030     	mov	r1, #48
70099d8c: e5952008     	ldr	r2, [r5, #0x8]
70099d90: e1500002     	cmp	r0, r2
70099d94: aa000005     	bge	0x70099db0 <_pproc_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x14
70099d98: e5942000     	ldr	r2, [r4]
70099d9c: e2800001     	add	r0, r0, #1
70099da0: e2423001     	sub	r3, r2, #1
70099da4: e5843000     	str	r3, [r4]
70099da8: e5c21000     	strb	r1, [r2]
70099dac: eafffff6     	b	0x70099d8c <_pproc_diouxp___TI_printfi_nofloat+0xe4> @ imm = #-0x28
70099db0: e5d5000c     	ldrb	r0, [r5, #0xc]
70099db4: e3500058     	cmp	r0, #88
70099db8: 13500078     	cmpne	r0, #120
70099dbc: 1a00000f     	bne	0x70099e00 <_pproc_diouxp___TI_printfi_nofloat+0x158> @ imm = #0x3c
70099dc0: e5d51000     	ldrb	r1, [r5]
70099dc4: e3110008     	tst	r1, #8
70099dc8: 0a00000e     	beq	0x70099e08 <_pproc_diouxp___TI_printfi_nofloat+0x160> @ imm = #0x38
70099dcc: e5941000     	ldr	r1, [r4]
70099dd0: e3500070     	cmp	r0, #112
70099dd4: 03000078     	movweq	r0, #0x78
70099dd8: e2412001     	sub	r2, r1, #1
70099ddc: e5842000     	str	r2, [r4]
70099de0: e3a02030     	mov	r2, #48
70099de4: e5c10000     	strb	r0, [r1]
70099de8: e5940000     	ldr	r0, [r4]
70099dec: e2401001     	sub	r1, r0, #1
70099df0: e5841000     	str	r1, [r4]
70099df4: e5c02000     	strb	r2, [r0]
70099df8: e5d5000c     	ldrb	r0, [r5, #0xc]
70099dfc: ea000001     	b	0x70099e08 <_pproc_diouxp___TI_printfi_nofloat+0x160> @ imm = #0x4
70099e00: e3500070     	cmp	r0, #112
70099e04: 0affffed     	beq	0x70099dc0 <_pproc_diouxp___TI_printfi_nofloat+0x118> @ imm = #-0x4c
70099e08: e350006f     	cmp	r0, #111
70099e0c: 1a00000a     	bne	0x70099e3c <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0x28
70099e10: e5d50000     	ldrb	r0, [r5]
70099e14: e3100008     	tst	r0, #8
70099e18: 0a000007     	beq	0x70099e3c <_pproc_diouxp___TI_printfi_nofloat+0x194> @ imm = #0x1c
70099e1c: e5940000     	ldr	r0, [r4]
70099e20: e5d01001     	ldrb	r1, [r0, #0x1]
70099e24: e3510030     	cmp	r1, #48
70099e28: 08bd88fc     	popeq	{r2, r3, r4, r5, r6, r7, r11, pc}
70099e2c: e2401001     	sub	r1, r0, #1
70099e30: e3a02030     	mov	r2, #48
70099e34: e5841000     	str	r1, [r4]
70099e38: e5c02000     	strb	r2, [r0]
70099e3c: e8bd88fc     	pop	{r2, r3, r4, r5, r6, r7, r11, pc}

70099e40 <_getarg_diouxp___TI_printfi_nofloat>:
70099e40: e92d4800     	push	{r11, lr}
70099e44: e5d0200c     	ldrb	r2, [r0, #0xc]
70099e48: e3520070     	cmp	r2, #112
70099e4c: 1a000002     	bne	0x70099e5c <_getarg_diouxp___TI_printfi_nofloat+0x1c> @ imm = #0x8
70099e50: e5910000     	ldr	r0, [r1]
70099e54: e3a03000     	mov	r3, #0
70099e58: ea000037     	b	0x70099f3c <_getarg_diouxp___TI_printfi_nofloat+0xfc> @ imm = #0xdc
70099e5c: e5900000     	ldr	r0, [r0]
70099e60: e3033f60     	movw	r3, #0x3f60
70099e64: e0000003     	and	r0, r0, r3
70099e68: e3500a02     	cmp	r0, #8192
70099e6c: 13500040     	cmpne	r0, #64
70099e70: 1a000011     	bne	0x70099ebc <_getarg_diouxp___TI_printfi_nofloat+0x7c> @ imm = #0x44
70099e74: e3a03000     	mov	r3, #0
70099e78: e242e064     	sub	lr, r2, #100
70099e7c: e35e0014     	cmp	lr, #20
70099e80: 8a00002a     	bhi	0x70099f30 <_getarg_diouxp___TI_printfi_nofloat+0xf0> @ imm = #0xa8
70099e84: e3000800     	movw	r0, #0x800
70099e88: e3a0c001     	mov	r12, #1
70099e8c: e3400012     	movt	r0, #0x12
70099e90: e1100e1c     	tst	r0, r12, lsl lr
70099e94: 1a000027     	bne	0x70099f38 <_getarg_diouxp___TI_printfi_nofloat+0xf8> @ imm = #0x9c
70099e98: e3a00021     	mov	r0, #33
70099e9c: e1100e1c     	tst	r0, r12, lsl lr
70099ea0: 0a000022     	beq	0x70099f30 <_getarg_diouxp___TI_printfi_nofloat+0xf0> @ imm = #0x88
70099ea4: e5910000     	ldr	r0, [r1]
70099ea8: e2802004     	add	r2, r0, #4
70099eac: e5812000     	str	r2, [r1]
70099eb0: e5900000     	ldr	r0, [r0]
70099eb4: e1a03fc0     	asr	r3, r0, #31
70099eb8: ea000022     	b	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x88
70099ebc: e3500c01     	cmp	r0, #256
70099ec0: 0a000022     	beq	0x70099f50 <_getarg_diouxp___TI_printfi_nofloat+0x110> @ imm = #0x88
70099ec4: e3500c02     	cmp	r0, #512
70099ec8: 0a000036     	beq	0x70099fa8 <_getarg_diouxp___TI_printfi_nofloat+0x168> @ imm = #0xd8
70099ecc: e3500b02     	cmp	r0, #2048
70099ed0: 0a00001e     	beq	0x70099f50 <_getarg_diouxp___TI_printfi_nofloat+0x110> @ imm = #0x78
70099ed4: e3a03000     	mov	r3, #0
70099ed8: e242e064     	sub	lr, r2, #100
70099edc: e3500a01     	cmp	r0, #4096
70099ee0: 0affffe5     	beq	0x70099e7c <_getarg_diouxp___TI_printfi_nofloat+0x3c> @ imm = #-0x6c
70099ee4: e3500020     	cmp	r0, #32
70099ee8: 1affffe3     	bne	0x70099e7c <_getarg_diouxp___TI_printfi_nofloat+0x3c> @ imm = #-0x74
70099eec: e35e0014     	cmp	lr, #20
70099ef0: 8a000007     	bhi	0x70099f14 <_getarg_diouxp___TI_printfi_nofloat+0xd4> @ imm = #0x1c
70099ef4: e3000800     	movw	r0, #0x800
70099ef8: e3a0c001     	mov	r12, #1
70099efc: e3400012     	movt	r0, #0x12
70099f00: e1100e1c     	tst	r0, r12, lsl lr
70099f04: 1a000004     	bne	0x70099f1c <_getarg_diouxp___TI_printfi_nofloat+0xdc> @ imm = #0x10
70099f08: e3a00021     	mov	r0, #33
70099f0c: e1100e1c     	tst	r0, r12, lsl lr
70099f10: 1affffe3     	bne	0x70099ea4 <_getarg_diouxp___TI_printfi_nofloat+0x64> @ imm = #-0x74
70099f14: e3520058     	cmp	r2, #88
70099f18: 1a000035     	bne	0x70099ff4 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0xd4
70099f1c: e5910000     	ldr	r0, [r1]
70099f20: e2802004     	add	r2, r0, #4
70099f24: e5812000     	str	r2, [r1]
70099f28: e1d000b0     	ldrh	r0, [r0]
70099f2c: ea000005     	b	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #0x14
70099f30: e3520058     	cmp	r2, #88
70099f34: 1a00002e     	bne	0x70099ff4 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0xb8
70099f38: e5910000     	ldr	r0, [r1]
70099f3c: e2802004     	add	r2, r0, #4
70099f40: e5812000     	str	r2, [r1]
70099f44: e5900000     	ldr	r0, [r0]
70099f48: e1a01003     	mov	r1, r3
70099f4c: e8bd8800     	pop	{r11, pc}
70099f50: e2420064     	sub	r0, r2, #100
70099f54: e3500014     	cmp	r0, #20
70099f58: 8a000007     	bhi	0x70099f7c <_getarg_diouxp___TI_printfi_nofloat+0x13c> @ imm = #0x1c
70099f5c: e3003800     	movw	r3, #0x800
70099f60: e3a0c001     	mov	r12, #1
70099f64: e3403012     	movt	r3, #0x12
70099f68: e113001c     	tst	r3, r12, lsl r0
70099f6c: 1a000006     	bne	0x70099f8c <_getarg_diouxp___TI_printfi_nofloat+0x14c> @ imm = #0x18
70099f70: e3a03021     	mov	r3, #33
70099f74: e113001c     	tst	r3, r12, lsl r0
70099f78: 1a000003     	bne	0x70099f8c <_getarg_diouxp___TI_printfi_nofloat+0x14c> @ imm = #0xc
70099f7c: e3a00000     	mov	r0, #0
70099f80: e3a03000     	mov	r3, #0
70099f84: e3520058     	cmp	r2, #88
70099f88: 1affffee     	bne	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0x48
70099f8c: e5910000     	ldr	r0, [r1]
70099f90: e2800007     	add	r0, r0, #7
70099f94: e3c00007     	bic	r0, r0, #7
70099f98: e2802008     	add	r2, r0, #8
70099f9c: e5812000     	str	r2, [r1]
70099fa0: e8900009     	ldm	r0, {r0, r3}
70099fa4: eaffffe7     	b	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0x64
70099fa8: e3a03000     	mov	r3, #0
70099fac: e242e064     	sub	lr, r2, #100
70099fb0: e35e0014     	cmp	lr, #20
70099fb4: 8a000007     	bhi	0x70099fd8 <_getarg_diouxp___TI_printfi_nofloat+0x198> @ imm = #0x1c
70099fb8: e3000800     	movw	r0, #0x800
70099fbc: e3a0c001     	mov	r12, #1
70099fc0: e3400012     	movt	r0, #0x12
70099fc4: e1100e1c     	tst	r0, r12, lsl lr
70099fc8: 1a000004     	bne	0x70099fe0 <_getarg_diouxp___TI_printfi_nofloat+0x1a0> @ imm = #0x10
70099fcc: e3a00021     	mov	r0, #33
70099fd0: e1100e1c     	tst	r0, r12, lsl lr
70099fd4: 1affffb2     	bne	0x70099ea4 <_getarg_diouxp___TI_printfi_nofloat+0x64> @ imm = #-0x138
70099fd8: e3520058     	cmp	r2, #88
70099fdc: 1a000004     	bne	0x70099ff4 <_getarg_diouxp___TI_printfi_nofloat+0x1b4> @ imm = #0x10
70099fe0: e5910000     	ldr	r0, [r1]
70099fe4: e2802004     	add	r2, r0, #4
70099fe8: e5812000     	str	r2, [r1]
70099fec: e5d00000     	ldrb	r0, [r0]
70099ff0: eaffffd4     	b	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0xb0
70099ff4: e3a00000     	mov	r0, #0
70099ff8: eaffffd2     	b	0x70099f48 <_getarg_diouxp___TI_printfi_nofloat+0x108> @ imm = #-0xb8

70099ffc <_ltostr___TI_printfi_nofloat>:
70099ffc: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
7009a000: e59fc074     	ldr	r12, [pc, #0x74]        @ 0x7009a07c <_ltostr___TI_printfi_nofloat+0x80>
7009a004: e1a04002     	mov	r4, r2
7009a008: e59f6070     	ldr	r6, [pc, #0x70]         @ 0x7009a080 <_ltostr___TI_printfi_nofloat+0x84>
7009a00c: e1a05000     	mov	r5, r0
7009a010: e59d8018     	ldr	r8, [sp, #0x18]
7009a014: e3530058     	cmp	r3, #88
7009a018: 01a0600c     	moveq	r6, r12
7009a01c: e1900001     	orrs	r0, r0, r1
7009a020: 1a00000f     	bne	0x7009a064 <_ltostr___TI_printfi_nofloat+0x68> @ imm = #0x3c
7009a024: e5980000     	ldr	r0, [r8]
7009a028: e3a03030     	mov	r3, #48
7009a02c: e2402001     	sub	r2, r0, #1
7009a030: e5882000     	str	r2, [r8]
7009a034: e5c03000     	strb	r3, [r0]
7009a038: ea000009     	b	0x7009a064 <_ltostr___TI_printfi_nofloat+0x68> @ imm = #0x24
7009a03c: e1a00005     	mov	r0, r5
7009a040: e1a02004     	mov	r2, r4
7009a044: eb00000e     	bl	0x7009a084 <_div___TI_printfi_nofloat> @ imm = #0x38
7009a048: e0625490     	mls	r2, r0, r4, r5
7009a04c: e5983000     	ldr	r3, [r8]
7009a050: e1a05000     	mov	r5, r0
7009a054: e2437001     	sub	r7, r3, #1
7009a058: e7d62002     	ldrb	r2, [r6, r2]
7009a05c: e5887000     	str	r7, [r8]
7009a060: e5c32000     	strb	r2, [r3]
7009a064: e1950001     	orrs	r0, r5, r1
7009a068: 1afffff3     	bne	0x7009a03c <_ltostr___TI_printfi_nofloat+0x40> @ imm = #-0x34
7009a06c: e5980000     	ldr	r0, [r8]
7009a070: eb005551     	bl	0x700af5bc <strlen>     @ imm = #0x15544
7009a074: e2400001     	sub	r0, r0, #1
7009a078: e8bd81f0     	pop	{r4, r5, r6, r7, r8, pc}
7009a07c: 3b 20 0b 70  	.word	0x700b203b
7009a080: 4c 20 0b 70  	.word	0x700b204c

7009a084 <_div___TI_printfi_nofloat>:
7009a084: e92d4800     	push	{r11, lr}
7009a088: e3520010     	cmp	r2, #16
7009a08c: 0a000005     	beq	0x7009a0a8 <_div___TI_printfi_nofloat+0x24> @ imm = #0x14
7009a090: e3520008     	cmp	r2, #8
7009a094: 1a000007     	bne	0x7009a0b8 <_div___TI_printfi_nofloat+0x34> @ imm = #0x1c
7009a098: e1a001a0     	lsr	r0, r0, #3
7009a09c: e1800e81     	orr	r0, r0, r1, lsl #29
7009a0a0: e1a011a1     	lsr	r1, r1, #3
7009a0a4: e8bd8800     	pop	{r11, pc}
7009a0a8: e1a00220     	lsr	r0, r0, #4
7009a0ac: e1800e01     	orr	r0, r0, r1, lsl #28
7009a0b0: e1a01221     	lsr	r1, r1, #4
7009a0b4: e8bd8800     	pop	{r11, pc}
7009a0b8: e3510000     	cmp	r1, #0
7009a0bc: 1a000003     	bne	0x7009a0d0 <_div___TI_printfi_nofloat+0x4c> @ imm = #0xc
7009a0c0: e1a01002     	mov	r1, r2
7009a0c4: eb0015eb     	bl	0x7009f878 <__udivsi3>  @ imm = #0x57ac
7009a0c8: e3a01000     	mov	r1, #0
7009a0cc: e8bd8800     	pop	{r11, pc}
7009a0d0: e3a03000     	mov	r3, #0
7009a0d4: eb00543e     	bl	0x700af1d4 <__aeabi_uldivmod> @ imm = #0x150f8
7009a0d8: e8bd8800     	pop	{r11, pc}

7009a0dc <__aeabi_memcpy8>:
7009a0dc: ea005546     	b	0x700af5fc <TI_memcpy_small> @ imm = #0x15518

7009a0e0 <_vsnprintf>:
; {
7009a0e0: e92d 43f0    	push.w	{r4, r5, r6, r7, r8, r9, lr}
7009a0e4: b0c1         	sub	sp, #0x104
7009a0e6: f8dd c120    	ldr.w	r12, [sp, #0x120]
7009a0ea: f8cd c100    	str.w	r12, [sp, #0x100]
7009a0ee: 903f         	str	r0, [sp, #0xfc]
7009a0f0: 913e         	str	r1, [sp, #0xf8]
7009a0f2: 923d         	str	r2, [sp, #0xf4]
7009a0f4: 933c         	str	r3, [sp, #0xf0]
7009a0f6: 2000         	movs	r0, #0x0
;   size_t idx = 0U;
7009a0f8: 9037         	str	r0, [sp, #0xdc]
;   if (!buffer) {
7009a0fa: 983e         	ldr	r0, [sp, #0xf8]
7009a0fc: b930         	cbnz	r0, 0x7009a10c <_vsnprintf+0x2c> @ imm = #0xc
7009a0fe: e7ff         	b	0x7009a100 <_vsnprintf+0x20> @ imm = #-0x2
;     out = _out_null;
7009a100: f64f 30b1    	movw	r0, #0xfbb1
7009a104: f2c7 000a    	movt	r0, #0x700a
7009a108: 903f         	str	r0, [sp, #0xfc]
;   }
7009a10a: e7ff         	b	0x7009a10c <_vsnprintf+0x2c> @ imm = #-0x2
;   while (*format)
7009a10c: e7ff         	b	0x7009a10e <_vsnprintf+0x2e> @ imm = #-0x2
7009a10e: 983c         	ldr	r0, [sp, #0xf0]
7009a110: 7800         	ldrb	r0, [r0]
7009a112: 2800         	cmp	r0, #0x0
7009a114: f000 84e3    	beq.w	0x7009aade <_vsnprintf+0x9fe> @ imm = #0x9c6
7009a118: e7ff         	b	0x7009a11a <_vsnprintf+0x3a> @ imm = #-0x2
;     if (*format != '%') {
7009a11a: 983c         	ldr	r0, [sp, #0xf0]
7009a11c: 7800         	ldrb	r0, [r0]
7009a11e: 2825         	cmp	r0, #0x25
7009a120: d00e         	beq	0x7009a140 <_vsnprintf+0x60> @ imm = #0x1c
7009a122: e7ff         	b	0x7009a124 <_vsnprintf+0x44> @ imm = #-0x2
;       out(*format, buffer, idx++, maxlen);
7009a124: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a128: 983c         	ldr	r0, [sp, #0xf0]
7009a12a: 7800         	ldrb	r0, [r0]
7009a12c: 993e         	ldr	r1, [sp, #0xf8]
7009a12e: 9a37         	ldr	r2, [sp, #0xdc]
7009a130: 1c53         	adds	r3, r2, #0x1
7009a132: 9337         	str	r3, [sp, #0xdc]
7009a134: 9b3d         	ldr	r3, [sp, #0xf4]
7009a136: 47e0         	blx	r12
;       format++;
7009a138: 983c         	ldr	r0, [sp, #0xf0]
7009a13a: 3001         	adds	r0, #0x1
7009a13c: 903c         	str	r0, [sp, #0xf0]
;       continue;
7009a13e: e7e6         	b	0x7009a10e <_vsnprintf+0x2e> @ imm = #-0x34
;       format++;
7009a140: 983c         	ldr	r0, [sp, #0xf0]
7009a142: 3001         	adds	r0, #0x1
7009a144: 903c         	str	r0, [sp, #0xf0]
7009a146: e7ff         	b	0x7009a148 <_vsnprintf+0x68> @ imm = #-0x2
7009a148: 2000         	movs	r0, #0x0
;     flags = 0U;
7009a14a: 903b         	str	r0, [sp, #0xec]
;     do {
7009a14c: e7ff         	b	0x7009a14e <_vsnprintf+0x6e> @ imm = #-0x2
;       switch (*format) {
7009a14e: 983c         	ldr	r0, [sp, #0xf0]
7009a150: 7800         	ldrb	r0, [r0]
7009a152: 3820         	subs	r0, #0x20
7009a154: 4601         	mov	r1, r0
7009a156: 912a         	str	r1, [sp, #0xa8]
7009a158: 2810         	cmp	r0, #0x10
7009a15a: d83d         	bhi	0x7009a1d8 <_vsnprintf+0xf8> @ imm = #0x7a
7009a15c: 992a         	ldr	r1, [sp, #0xa8]
7009a15e: e8df f001    	tbb	[pc, r1]
7009a162: 27 3b 3b 31  	.word	0x313b3b27
7009a166: 3b 3b 3b 3b  	.word	0x3b3b3b3b
7009a16a: 3b 3b 3b 1d  	.word	0x1d3b3b3b
7009a16e: 3b 13 3b 3b  	.word	0x3b3b133b
7009a172: 09 00        	.short	0x0009
;         case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
7009a174: 983b         	ldr	r0, [sp, #0xec]
7009a176: f040 0001    	orr	r0, r0, #0x1
7009a17a: 903b         	str	r0, [sp, #0xec]
7009a17c: 983c         	ldr	r0, [sp, #0xf0]
7009a17e: 3001         	adds	r0, #0x1
7009a180: 903c         	str	r0, [sp, #0xf0]
7009a182: 2001         	movs	r0, #0x1
7009a184: 9038         	str	r0, [sp, #0xe0]
7009a186: e02a         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #0x54
;         case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
7009a188: 983b         	ldr	r0, [sp, #0xec]
7009a18a: f040 0002    	orr	r0, r0, #0x2
7009a18e: 903b         	str	r0, [sp, #0xec]
7009a190: 983c         	ldr	r0, [sp, #0xf0]
7009a192: 3001         	adds	r0, #0x1
7009a194: 903c         	str	r0, [sp, #0xf0]
7009a196: 2001         	movs	r0, #0x1
7009a198: 9038         	str	r0, [sp, #0xe0]
7009a19a: e020         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #0x40
;         case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
7009a19c: 983b         	ldr	r0, [sp, #0xec]
7009a19e: f040 0004    	orr	r0, r0, #0x4
7009a1a2: 903b         	str	r0, [sp, #0xec]
7009a1a4: 983c         	ldr	r0, [sp, #0xf0]
7009a1a6: 3001         	adds	r0, #0x1
7009a1a8: 903c         	str	r0, [sp, #0xf0]
7009a1aa: 2001         	movs	r0, #0x1
7009a1ac: 9038         	str	r0, [sp, #0xe0]
7009a1ae: e016         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #0x2c
;         case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
7009a1b0: 983b         	ldr	r0, [sp, #0xec]
7009a1b2: f040 0008    	orr	r0, r0, #0x8
7009a1b6: 903b         	str	r0, [sp, #0xec]
7009a1b8: 983c         	ldr	r0, [sp, #0xf0]
7009a1ba: 3001         	adds	r0, #0x1
7009a1bc: 903c         	str	r0, [sp, #0xf0]
7009a1be: 2001         	movs	r0, #0x1
7009a1c0: 9038         	str	r0, [sp, #0xe0]
7009a1c2: e00c         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #0x18
;         case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
7009a1c4: 983b         	ldr	r0, [sp, #0xec]
7009a1c6: f040 0010    	orr	r0, r0, #0x10
7009a1ca: 903b         	str	r0, [sp, #0xec]
7009a1cc: 983c         	ldr	r0, [sp, #0xf0]
7009a1ce: 3001         	adds	r0, #0x1
7009a1d0: 903c         	str	r0, [sp, #0xf0]
7009a1d2: 2001         	movs	r0, #0x1
7009a1d4: 9038         	str	r0, [sp, #0xe0]
7009a1d6: e002         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #0x4
7009a1d8: 2000         	movs	r0, #0x0
;         default :                                   n = 0U; break;
7009a1da: 9038         	str	r0, [sp, #0xe0]
7009a1dc: e7ff         	b	0x7009a1de <_vsnprintf+0xfe> @ imm = #-0x2
;     } while (n);
7009a1de: e7ff         	b	0x7009a1e0 <_vsnprintf+0x100> @ imm = #-0x2
7009a1e0: 9838         	ldr	r0, [sp, #0xe0]
7009a1e2: 2800         	cmp	r0, #0x0
7009a1e4: d1b3         	bne	0x7009a14e <_vsnprintf+0x6e> @ imm = #-0x9a
7009a1e6: e7ff         	b	0x7009a1e8 <_vsnprintf+0x108> @ imm = #-0x2
7009a1e8: 2000         	movs	r0, #0x0
;     width = 0U;
7009a1ea: 903a         	str	r0, [sp, #0xe8]
;     if (_is_digit(*format)) {
7009a1ec: 983c         	ldr	r0, [sp, #0xf0]
7009a1ee: 7800         	ldrb	r0, [r0]
7009a1f0: f014 fbee    	bl	0x700ae9d0 <_is_digit>  @ imm = #0x147dc
7009a1f4: b128         	cbz	r0, 0x7009a202 <_vsnprintf+0x122> @ imm = #0xa
7009a1f6: e7ff         	b	0x7009a1f8 <_vsnprintf+0x118> @ imm = #-0x2
7009a1f8: a83c         	add	r0, sp, #0xf0
;       width = _atoi(&format);
7009a1fa: f014 f801    	bl	0x700ae200 <_atoi>      @ imm = #0x14002
7009a1fe: 903a         	str	r0, [sp, #0xe8]
;     }
7009a200: e01e         	b	0x7009a240 <_vsnprintf+0x160> @ imm = #0x3c
;     else if (*format == '*') {
7009a202: 983c         	ldr	r0, [sp, #0xf0]
7009a204: 7800         	ldrb	r0, [r0]
7009a206: 282a         	cmp	r0, #0x2a
7009a208: d119         	bne	0x7009a23e <_vsnprintf+0x15e> @ imm = #0x32
7009a20a: e7ff         	b	0x7009a20c <_vsnprintf+0x12c> @ imm = #-0x2
;       const int w = va_arg(va, int);
7009a20c: 9840         	ldr	r0, [sp, #0x100]
7009a20e: 1d01         	adds	r1, r0, #0x4
7009a210: 9140         	str	r1, [sp, #0x100]
7009a212: 6800         	ldr	r0, [r0]
7009a214: 9036         	str	r0, [sp, #0xd8]
;       if (w < 0) {
7009a216: 9836         	ldr	r0, [sp, #0xd8]
7009a218: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009a21c: dc08         	bgt	0x7009a230 <_vsnprintf+0x150> @ imm = #0x10
7009a21e: e7ff         	b	0x7009a220 <_vsnprintf+0x140> @ imm = #-0x2
;         flags |= FLAGS_LEFT;    // reverse padding
7009a220: 983b         	ldr	r0, [sp, #0xec]
7009a222: f040 0002    	orr	r0, r0, #0x2
7009a226: 903b         	str	r0, [sp, #0xec]
;         width = (unsigned int)-w;
7009a228: 9836         	ldr	r0, [sp, #0xd8]
7009a22a: 4240         	rsbs	r0, r0, #0
7009a22c: 903a         	str	r0, [sp, #0xe8]
;       }
7009a22e: e002         	b	0x7009a236 <_vsnprintf+0x156> @ imm = #0x4
;         width = (unsigned int)w;
7009a230: 9836         	ldr	r0, [sp, #0xd8]
7009a232: 903a         	str	r0, [sp, #0xe8]
7009a234: e7ff         	b	0x7009a236 <_vsnprintf+0x156> @ imm = #-0x2
;       format++;
7009a236: 983c         	ldr	r0, [sp, #0xf0]
7009a238: 3001         	adds	r0, #0x1
7009a23a: 903c         	str	r0, [sp, #0xf0]
;     }
7009a23c: e7ff         	b	0x7009a23e <_vsnprintf+0x15e> @ imm = #-0x2
7009a23e: e7ff         	b	0x7009a240 <_vsnprintf+0x160> @ imm = #-0x2
7009a240: 2000         	movs	r0, #0x0
;     precision = 0U;
7009a242: 9039         	str	r0, [sp, #0xe4]
;     if (*format == '.') {
7009a244: 983c         	ldr	r0, [sp, #0xf0]
7009a246: 7800         	ldrb	r0, [r0]
7009a248: 282e         	cmp	r0, #0x2e
7009a24a: d12e         	bne	0x7009a2aa <_vsnprintf+0x1ca> @ imm = #0x5c
7009a24c: e7ff         	b	0x7009a24e <_vsnprintf+0x16e> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;
7009a24e: 983b         	ldr	r0, [sp, #0xec]
7009a250: f440 6080    	orr	r0, r0, #0x400
7009a254: 903b         	str	r0, [sp, #0xec]
;       format++;
7009a256: 983c         	ldr	r0, [sp, #0xf0]
7009a258: 3001         	adds	r0, #0x1
7009a25a: 903c         	str	r0, [sp, #0xf0]
;       if (_is_digit(*format)) {
7009a25c: 983c         	ldr	r0, [sp, #0xf0]
7009a25e: 7800         	ldrb	r0, [r0]
7009a260: f014 fbb6    	bl	0x700ae9d0 <_is_digit>  @ imm = #0x1476c
7009a264: b128         	cbz	r0, 0x7009a272 <_vsnprintf+0x192> @ imm = #0xa
7009a266: e7ff         	b	0x7009a268 <_vsnprintf+0x188> @ imm = #-0x2
7009a268: a83c         	add	r0, sp, #0xf0
;         precision = _atoi(&format);
7009a26a: f013 ffc9    	bl	0x700ae200 <_atoi>      @ imm = #0x13f92
7009a26e: 9039         	str	r0, [sp, #0xe4]
;       }
7009a270: e01a         	b	0x7009a2a8 <_vsnprintf+0x1c8> @ imm = #0x34
;       else if (*format == '*') {
7009a272: 983c         	ldr	r0, [sp, #0xf0]
7009a274: 7800         	ldrb	r0, [r0]
7009a276: 282a         	cmp	r0, #0x2a
7009a278: d115         	bne	0x7009a2a6 <_vsnprintf+0x1c6> @ imm = #0x2a
7009a27a: e7ff         	b	0x7009a27c <_vsnprintf+0x19c> @ imm = #-0x2
;         const int prec = (int)va_arg(va, int);
7009a27c: 9840         	ldr	r0, [sp, #0x100]
7009a27e: 1d01         	adds	r1, r0, #0x4
7009a280: 9140         	str	r1, [sp, #0x100]
7009a282: 6800         	ldr	r0, [r0]
7009a284: 9035         	str	r0, [sp, #0xd4]
;         precision = prec > 0 ? (unsigned int)prec : 0U;
7009a286: 9835         	ldr	r0, [sp, #0xd4]
7009a288: 2801         	cmp	r0, #0x1
7009a28a: db03         	blt	0x7009a294 <_vsnprintf+0x1b4> @ imm = #0x6
7009a28c: e7ff         	b	0x7009a28e <_vsnprintf+0x1ae> @ imm = #-0x2
7009a28e: 9835         	ldr	r0, [sp, #0xd4]
7009a290: 9029         	str	r0, [sp, #0xa4]
7009a292: e002         	b	0x7009a29a <_vsnprintf+0x1ba> @ imm = #0x4
7009a294: 2000         	movs	r0, #0x0
;         precision = prec > 0 ? (unsigned int)prec : 0U;
7009a296: 9029         	str	r0, [sp, #0xa4]
7009a298: e7ff         	b	0x7009a29a <_vsnprintf+0x1ba> @ imm = #-0x2
7009a29a: 9829         	ldr	r0, [sp, #0xa4]
7009a29c: 9039         	str	r0, [sp, #0xe4]
;         format++;
7009a29e: 983c         	ldr	r0, [sp, #0xf0]
7009a2a0: 3001         	adds	r0, #0x1
7009a2a2: 903c         	str	r0, [sp, #0xf0]
;       }
7009a2a4: e7ff         	b	0x7009a2a6 <_vsnprintf+0x1c6> @ imm = #-0x2
7009a2a6: e7ff         	b	0x7009a2a8 <_vsnprintf+0x1c8> @ imm = #-0x2
;     }
7009a2a8: e7ff         	b	0x7009a2aa <_vsnprintf+0x1ca> @ imm = #-0x2
;     switch (*format) {
7009a2aa: 983c         	ldr	r0, [sp, #0xf0]
7009a2ac: 7800         	ldrb	r0, [r0]
7009a2ae: 3868         	subs	r0, #0x68
7009a2b0: 4601         	mov	r1, r0
7009a2b2: 9128         	str	r1, [sp, #0xa0]
7009a2b4: 2812         	cmp	r0, #0x12
7009a2b6: d84e         	bhi	0x7009a356 <_vsnprintf+0x276> @ imm = #0x9c
7009a2b8: 9928         	ldr	r1, [sp, #0xa0]
7009a2ba: e8df f001    	tbb	[pc, r1]
7009a2be: 1f 4c 3c 4c  	.word	0x4c3c4c1f
7009a2c2: 0a 4c 4c 4c  	.word	0x4c4c4c0a
7009a2c6: 4c 4c 4c 4c  	.word	0x4c4c4c4c
7009a2ca: 34 4c 4c 4c  	.word	0x4c4c4c34
7009a2ce: 4c 4c 44 00  	.word	0x00444c4c
;         flags |= FLAGS_LONG;
7009a2d2: 983b         	ldr	r0, [sp, #0xec]
7009a2d4: f440 7080    	orr	r0, r0, #0x100
7009a2d8: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a2da: 983c         	ldr	r0, [sp, #0xf0]
7009a2dc: 3001         	adds	r0, #0x1
7009a2de: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'l') {
7009a2e0: 983c         	ldr	r0, [sp, #0xf0]
7009a2e2: 7800         	ldrb	r0, [r0]
7009a2e4: 286c         	cmp	r0, #0x6c
7009a2e6: d108         	bne	0x7009a2fa <_vsnprintf+0x21a> @ imm = #0x10
7009a2e8: e7ff         	b	0x7009a2ea <_vsnprintf+0x20a> @ imm = #-0x2
;           flags |= FLAGS_LONG_LONG;
7009a2ea: 983b         	ldr	r0, [sp, #0xec]
7009a2ec: f440 7000    	orr	r0, r0, #0x200
7009a2f0: 903b         	str	r0, [sp, #0xec]
;           format++;
7009a2f2: 983c         	ldr	r0, [sp, #0xf0]
7009a2f4: 3001         	adds	r0, #0x1
7009a2f6: 903c         	str	r0, [sp, #0xf0]
;         }
7009a2f8: e7ff         	b	0x7009a2fa <_vsnprintf+0x21a> @ imm = #-0x2
;         break;
7009a2fa: e02d         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #0x5a
;         flags |= FLAGS_SHORT;
7009a2fc: 983b         	ldr	r0, [sp, #0xec]
7009a2fe: f040 0080    	orr	r0, r0, #0x80
7009a302: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a304: 983c         	ldr	r0, [sp, #0xf0]
7009a306: 3001         	adds	r0, #0x1
7009a308: 903c         	str	r0, [sp, #0xf0]
;         if (*format == 'h') {
7009a30a: 983c         	ldr	r0, [sp, #0xf0]
7009a30c: 7800         	ldrb	r0, [r0]
7009a30e: 2868         	cmp	r0, #0x68
7009a310: d108         	bne	0x7009a324 <_vsnprintf+0x244> @ imm = #0x10
7009a312: e7ff         	b	0x7009a314 <_vsnprintf+0x234> @ imm = #-0x2
;           flags |= FLAGS_CHAR;
7009a314: 983b         	ldr	r0, [sp, #0xec]
7009a316: f040 0040    	orr	r0, r0, #0x40
7009a31a: 903b         	str	r0, [sp, #0xec]
;           format++;
7009a31c: 983c         	ldr	r0, [sp, #0xf0]
7009a31e: 3001         	adds	r0, #0x1
7009a320: 903c         	str	r0, [sp, #0xf0]
;         }
7009a322: e7ff         	b	0x7009a324 <_vsnprintf+0x244> @ imm = #-0x2
;         break;
7009a324: e018         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #0x30
;         flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a326: 983b         	ldr	r0, [sp, #0xec]
7009a328: f440 7080    	orr	r0, r0, #0x100
7009a32c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a32e: 983c         	ldr	r0, [sp, #0xf0]
7009a330: 3001         	adds	r0, #0x1
7009a332: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a334: e010         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #0x20
;         flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a336: 983b         	ldr	r0, [sp, #0xec]
7009a338: f440 7000    	orr	r0, r0, #0x200
7009a33c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a33e: 983c         	ldr	r0, [sp, #0xf0]
7009a340: 3001         	adds	r0, #0x1
7009a342: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a344: e008         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #0x10
;         flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
7009a346: 983b         	ldr	r0, [sp, #0xec]
7009a348: f440 7080    	orr	r0, r0, #0x100
7009a34c: 903b         	str	r0, [sp, #0xec]
;         format++;
7009a34e: 983c         	ldr	r0, [sp, #0xf0]
7009a350: 3001         	adds	r0, #0x1
7009a352: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a354: e000         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #0x0
;         break;
7009a356: e7ff         	b	0x7009a358 <_vsnprintf+0x278> @ imm = #-0x2
;     switch (*format) {
7009a358: 983c         	ldr	r0, [sp, #0xf0]
7009a35a: 7800         	ldrb	r0, [r0]
7009a35c: 3825         	subs	r0, #0x25
7009a35e: 4601         	mov	r1, r0
7009a360: 9127         	str	r1, [sp, #0x9c]
7009a362: 2853         	cmp	r0, #0x53
7009a364: f200 83ab    	bhi.w	0x7009aabe <_vsnprintf+0x9de> @ imm = #0x756
7009a368: 9927         	ldr	r1, [sp, #0x9c]
7009a36a: e8df f011    	tbh	[pc, r1, lsl #1]
7009a36e: 9b 03 a8 03  	.word	0x03a8039b
7009a372: a8 03 a8 03  	.word	0x03a803a8
7009a376: a8 03 a8 03  	.word	0x03a803a8
7009a37a: a8 03 a8 03  	.word	0x03a803a8
7009a37e: a8 03 a8 03  	.word	0x03a803a8
7009a382: a8 03 a8 03  	.word	0x03a803a8
7009a386: a8 03 a8 03  	.word	0x03a803a8
7009a38a: a8 03 a8 03  	.word	0x03a803a8
7009a38e: a8 03 a8 03  	.word	0x03a803a8
7009a392: a8 03 a8 03  	.word	0x03a803a8
7009a396: a8 03 a8 03  	.word	0x03a803a8
7009a39a: a8 03 a8 03  	.word	0x03a803a8
7009a39e: a8 03 a8 03  	.word	0x03a803a8
7009a3a2: a8 03 a8 03  	.word	0x03a803a8
7009a3a6: a8 03 a8 03  	.word	0x03a803a8
7009a3aa: a8 03 a8 03  	.word	0x03a803a8
7009a3ae: 5e 02 32 02  	.word	0x0232025e
7009a3b2: 5e 02 a8 03  	.word	0x03a8025e
7009a3b6: a8 03 a8 03  	.word	0x03a803a8
7009a3ba: a8 03 a8 03  	.word	0x03a803a8
7009a3be: a8 03 a8 03  	.word	0x03a803a8
7009a3c2: a8 03 a8 03  	.word	0x03a803a8
7009a3c6: a8 03 a8 03  	.word	0x03a803a8
7009a3ca: a8 03 a8 03  	.word	0x03a803a8
7009a3ce: a8 03 a8 03  	.word	0x03a803a8
7009a3d2: a8 03 54 00  	.word	0x005403a8
7009a3d6: a8 03 a8 03  	.word	0x03a803a8
7009a3da: a8 03 a8 03  	.word	0x03a803a8
7009a3de: a8 03 a8 03  	.word	0x03a803a8
7009a3e2: a8 03 a8 03  	.word	0x03a803a8
7009a3e6: a8 03 54 00  	.word	0x005403a8
7009a3ea: 9e 02 54 00  	.word	0x0054029e
7009a3ee: 5e 02 32 02  	.word	0x0232025e
7009a3f2: 5e 02 a8 03  	.word	0x03a8025e
7009a3f6: 54 00 a8 03  	.word	0x03a80054
7009a3fa: a8 03 a8 03  	.word	0x03a803a8
7009a3fe: a8 03 a8 03  	.word	0x03a803a8
7009a402: 54 00 6e 03  	.word	0x036e0054
7009a406: a8 03 a8 03  	.word	0x03a803a8
7009a40a: e2 02 a8 03  	.word	0x03a802e2
7009a40e: 54 00 a8 03  	.word	0x03a80054
7009a412: a8 03 54 00  	.word	0x005403a8
;         if (*format == 'x' || *format == 'X') {
7009a416: 983c         	ldr	r0, [sp, #0xf0]
7009a418: 7800         	ldrb	r0, [r0]
7009a41a: 2878         	cmp	r0, #0x78
7009a41c: d005         	beq	0x7009a42a <_vsnprintf+0x34a> @ imm = #0xa
7009a41e: e7ff         	b	0x7009a420 <_vsnprintf+0x340> @ imm = #-0x2
7009a420: 983c         	ldr	r0, [sp, #0xf0]
7009a422: 7800         	ldrb	r0, [r0]
7009a424: 2858         	cmp	r0, #0x58
7009a426: d103         	bne	0x7009a430 <_vsnprintf+0x350> @ imm = #0x6
7009a428: e7ff         	b	0x7009a42a <_vsnprintf+0x34a> @ imm = #-0x2
7009a42a: 2010         	movs	r0, #0x10
;           base = 16U;
7009a42c: 9034         	str	r0, [sp, #0xd0]
;         }
7009a42e: e018         	b	0x7009a462 <_vsnprintf+0x382> @ imm = #0x30
;         else if (*format == 'o') {
7009a430: 983c         	ldr	r0, [sp, #0xf0]
7009a432: 7800         	ldrb	r0, [r0]
7009a434: 286f         	cmp	r0, #0x6f
7009a436: d103         	bne	0x7009a440 <_vsnprintf+0x360> @ imm = #0x6
7009a438: e7ff         	b	0x7009a43a <_vsnprintf+0x35a> @ imm = #-0x2
7009a43a: 2008         	movs	r0, #0x8
;           base =  8U;
7009a43c: 9034         	str	r0, [sp, #0xd0]
;         }
7009a43e: e00f         	b	0x7009a460 <_vsnprintf+0x380> @ imm = #0x1e
;         else if (*format == 'b') {
7009a440: 983c         	ldr	r0, [sp, #0xf0]
7009a442: 7800         	ldrb	r0, [r0]
7009a444: 2862         	cmp	r0, #0x62
7009a446: d103         	bne	0x7009a450 <_vsnprintf+0x370> @ imm = #0x6
7009a448: e7ff         	b	0x7009a44a <_vsnprintf+0x36a> @ imm = #-0x2
7009a44a: 2002         	movs	r0, #0x2
;           base =  2U;
7009a44c: 9034         	str	r0, [sp, #0xd0]
;         }
7009a44e: e006         	b	0x7009a45e <_vsnprintf+0x37e> @ imm = #0xc
7009a450: 200a         	movs	r0, #0xa
;           base = 10U;
7009a452: 9034         	str	r0, [sp, #0xd0]
;           flags &= ~FLAGS_HASH;   // no hash for dec format
7009a454: 983b         	ldr	r0, [sp, #0xec]
7009a456: f020 0010    	bic	r0, r0, #0x10
7009a45a: 903b         	str	r0, [sp, #0xec]
7009a45c: e7ff         	b	0x7009a45e <_vsnprintf+0x37e> @ imm = #-0x2
7009a45e: e7ff         	b	0x7009a460 <_vsnprintf+0x380> @ imm = #-0x2
7009a460: e7ff         	b	0x7009a462 <_vsnprintf+0x382> @ imm = #-0x2
;         if (*format == 'X') {
7009a462: 983c         	ldr	r0, [sp, #0xf0]
7009a464: 7800         	ldrb	r0, [r0]
7009a466: 2858         	cmp	r0, #0x58
7009a468: d105         	bne	0x7009a476 <_vsnprintf+0x396> @ imm = #0xa
7009a46a: e7ff         	b	0x7009a46c <_vsnprintf+0x38c> @ imm = #-0x2
;           flags |= FLAGS_UPPERCASE;
7009a46c: 983b         	ldr	r0, [sp, #0xec]
7009a46e: f040 0020    	orr	r0, r0, #0x20
7009a472: 903b         	str	r0, [sp, #0xec]
;         }
7009a474: e7ff         	b	0x7009a476 <_vsnprintf+0x396> @ imm = #-0x2
;         if ((*format != 'i') && (*format != 'd')) {
7009a476: 983c         	ldr	r0, [sp, #0xf0]
7009a478: 7800         	ldrb	r0, [r0]
7009a47a: 2869         	cmp	r0, #0x69
7009a47c: d00a         	beq	0x7009a494 <_vsnprintf+0x3b4> @ imm = #0x14
7009a47e: e7ff         	b	0x7009a480 <_vsnprintf+0x3a0> @ imm = #-0x2
7009a480: 983c         	ldr	r0, [sp, #0xf0]
7009a482: 7800         	ldrb	r0, [r0]
7009a484: 2864         	cmp	r0, #0x64
7009a486: d005         	beq	0x7009a494 <_vsnprintf+0x3b4> @ imm = #0xa
7009a488: e7ff         	b	0x7009a48a <_vsnprintf+0x3aa> @ imm = #-0x2
;           flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
7009a48a: 983b         	ldr	r0, [sp, #0xec]
7009a48c: f020 000c    	bic	r0, r0, #0xc
7009a490: 903b         	str	r0, [sp, #0xec]
;         }
7009a492: e7ff         	b	0x7009a494 <_vsnprintf+0x3b4> @ imm = #-0x2
;         if (flags & FLAGS_PRECISION) {
7009a494: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a498: 0740         	lsls	r0, r0, #0x1d
7009a49a: 2800         	cmp	r0, #0x0
7009a49c: d505         	bpl	0x7009a4aa <_vsnprintf+0x3ca> @ imm = #0xa
7009a49e: e7ff         	b	0x7009a4a0 <_vsnprintf+0x3c0> @ imm = #-0x2
;           flags &= ~FLAGS_ZEROPAD;
7009a4a0: 983b         	ldr	r0, [sp, #0xec]
7009a4a2: f020 0001    	bic	r0, r0, #0x1
7009a4a6: 903b         	str	r0, [sp, #0xec]
;         }
7009a4a8: e7ff         	b	0x7009a4aa <_vsnprintf+0x3ca> @ imm = #-0x2
;         if ((*format == 'i') || (*format == 'd')) {
7009a4aa: 983c         	ldr	r0, [sp, #0xf0]
7009a4ac: 7800         	ldrb	r0, [r0]
7009a4ae: 2869         	cmp	r0, #0x69
7009a4b0: d006         	beq	0x7009a4c0 <_vsnprintf+0x3e0> @ imm = #0xc
7009a4b2: e7ff         	b	0x7009a4b4 <_vsnprintf+0x3d4> @ imm = #-0x2
7009a4b4: 983c         	ldr	r0, [sp, #0xf0]
7009a4b6: 7800         	ldrb	r0, [r0]
7009a4b8: 2864         	cmp	r0, #0x64
7009a4ba: f040 80e9    	bne.w	0x7009a690 <_vsnprintf+0x5b0> @ imm = #0x1d2
7009a4be: e7ff         	b	0x7009a4c0 <_vsnprintf+0x3e0> @ imm = #-0x2
;           if (flags & FLAGS_LONG_LONG) {
7009a4c0: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a4c4: 0780         	lsls	r0, r0, #0x1e
7009a4c6: 2800         	cmp	r0, #0x0
7009a4c8: d550         	bpl	0x7009a56c <_vsnprintf+0x48c> @ imm = #0xa0
7009a4ca: e7ff         	b	0x7009a4cc <_vsnprintf+0x3ec> @ imm = #-0x2
;             const long long value = va_arg(va, long long);
7009a4cc: 9840         	ldr	r0, [sp, #0x100]
7009a4ce: 3007         	adds	r0, #0x7
7009a4d0: f020 0107    	bic	r1, r0, #0x7
7009a4d4: f101 0008    	add.w	r0, r1, #0x8
7009a4d8: 9040         	str	r0, [sp, #0x100]
7009a4da: 6808         	ldr	r0, [r1]
7009a4dc: 6849         	ldr	r1, [r1, #0x4]
7009a4de: 9133         	str	r1, [sp, #0xcc]
7009a4e0: 9032         	str	r0, [sp, #0xc8]
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a4e2: 983f         	ldr	r0, [sp, #0xfc]
7009a4e4: 9023         	str	r0, [sp, #0x8c]
7009a4e6: 983e         	ldr	r0, [sp, #0xf8]
7009a4e8: 9024         	str	r0, [sp, #0x90]
7009a4ea: 9837         	ldr	r0, [sp, #0xdc]
7009a4ec: 9025         	str	r0, [sp, #0x94]
7009a4ee: 983d         	ldr	r0, [sp, #0xf4]
7009a4f0: 9026         	str	r0, [sp, #0x98]
7009a4f2: 9932         	ldr	r1, [sp, #0xc8]
7009a4f4: 9833         	ldr	r0, [sp, #0xcc]
7009a4f6: 3901         	subs	r1, #0x1
7009a4f8: f170 0000    	sbcs	r0, r0, #0x0
7009a4fc: db05         	blt	0x7009a50a <_vsnprintf+0x42a> @ imm = #0xa
7009a4fe: e7ff         	b	0x7009a500 <_vsnprintf+0x420> @ imm = #-0x2
7009a500: 9932         	ldr	r1, [sp, #0xc8]
7009a502: 9833         	ldr	r0, [sp, #0xcc]
7009a504: 9121         	str	r1, [sp, #0x84]
7009a506: 9022         	str	r0, [sp, #0x88]
7009a508: e008         	b	0x7009a51c <_vsnprintf+0x43c> @ imm = #0x10
7009a50a: 9832         	ldr	r0, [sp, #0xc8]
7009a50c: 9a33         	ldr	r2, [sp, #0xcc]
7009a50e: 4241         	rsbs	r1, r0, #0
7009a510: f04f 0000    	mov.w	r0, #0x0
7009a514: 4190         	sbcs	r0, r2
7009a516: 9121         	str	r1, [sp, #0x84]
7009a518: 9022         	str	r0, [sp, #0x88]
7009a51a: e7ff         	b	0x7009a51c <_vsnprintf+0x43c> @ imm = #-0x2
7009a51c: 9b26         	ldr	r3, [sp, #0x98]
7009a51e: 9a25         	ldr	r2, [sp, #0x94]
7009a520: 9924         	ldr	r1, [sp, #0x90]
7009a522: 9823         	ldr	r0, [sp, #0x8c]
7009a524: f8dd c084    	ldr.w	r12, [sp, #0x84]
7009a528: 9c22         	ldr	r4, [sp, #0x88]
7009a52a: 9d33         	ldr	r5, [sp, #0xcc]
7009a52c: 9e34         	ldr	r6, [sp, #0xd0]
7009a52e: 9f39         	ldr	r7, [sp, #0xe4]
7009a530: f8dd 80e8    	ldr.w	r8, [sp, #0xe8]
7009a534: f8dd 90ec    	ldr.w	r9, [sp, #0xec]
7009a538: 46ee         	mov	lr, sp
7009a53a: f8cd e080    	str.w	lr, [sp, #0x80]
7009a53e: f8ce 9020    	str.w	r9, [lr, #0x20]
7009a542: f8ce 801c    	str.w	r8, [lr, #0x1c]
7009a546: f8ce 7018    	str.w	r7, [lr, #0x18]
7009a54a: 2700         	movs	r7, #0x0
7009a54c: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a550: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a554: ea4f 75d5    	lsr.w	r5, r5, #0x1f
7009a558: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a55c: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a560: f8ce c000    	str.w	r12, [lr]
7009a564: f008 fbb4    	bl	0x700a2cd0 <_ntoa_long_long> @ imm = #0x8768
7009a568: 9037         	str	r0, [sp, #0xdc]
;           }
7009a56a: e090         	b	0x7009a68e <_vsnprintf+0x5ae> @ imm = #0x120
;           else if (flags & FLAGS_LONG) {
7009a56c: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a570: 07c0         	lsls	r0, r0, #0x1f
7009a572: b3b0         	cbz	r0, 0x7009a5e2 <_vsnprintf+0x502> @ imm = #0x6c
7009a574: e7ff         	b	0x7009a576 <_vsnprintf+0x496> @ imm = #-0x2
;             const long value = va_arg(va, long);
7009a576: 9840         	ldr	r0, [sp, #0x100]
7009a578: 1d01         	adds	r1, r0, #0x4
7009a57a: 9140         	str	r1, [sp, #0x100]
7009a57c: 6800         	ldr	r0, [r0]
7009a57e: 9031         	str	r0, [sp, #0xc4]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a580: 983f         	ldr	r0, [sp, #0xfc]
7009a582: 901c         	str	r0, [sp, #0x70]
7009a584: 983e         	ldr	r0, [sp, #0xf8]
7009a586: 901d         	str	r0, [sp, #0x74]
7009a588: 9837         	ldr	r0, [sp, #0xdc]
7009a58a: 901e         	str	r0, [sp, #0x78]
7009a58c: 983d         	ldr	r0, [sp, #0xf4]
7009a58e: 901f         	str	r0, [sp, #0x7c]
7009a590: 9831         	ldr	r0, [sp, #0xc4]
7009a592: 2801         	cmp	r0, #0x1
7009a594: db03         	blt	0x7009a59e <_vsnprintf+0x4be> @ imm = #0x6
7009a596: e7ff         	b	0x7009a598 <_vsnprintf+0x4b8> @ imm = #-0x2
7009a598: 9831         	ldr	r0, [sp, #0xc4]
7009a59a: 901b         	str	r0, [sp, #0x6c]
7009a59c: e003         	b	0x7009a5a6 <_vsnprintf+0x4c6> @ imm = #0x6
7009a59e: 9831         	ldr	r0, [sp, #0xc4]
7009a5a0: 4240         	rsbs	r0, r0, #0
7009a5a2: 901b         	str	r0, [sp, #0x6c]
7009a5a4: e7ff         	b	0x7009a5a6 <_vsnprintf+0x4c6> @ imm = #-0x2
7009a5a6: 9b1f         	ldr	r3, [sp, #0x7c]
7009a5a8: 9a1e         	ldr	r2, [sp, #0x78]
7009a5aa: 991d         	ldr	r1, [sp, #0x74]
7009a5ac: 981c         	ldr	r0, [sp, #0x70]
7009a5ae: f8dd c06c    	ldr.w	r12, [sp, #0x6c]
7009a5b2: 9c31         	ldr	r4, [sp, #0xc4]
7009a5b4: 9d34         	ldr	r5, [sp, #0xd0]
7009a5b6: 9e39         	ldr	r6, [sp, #0xe4]
7009a5b8: 9f3a         	ldr	r7, [sp, #0xe8]
7009a5ba: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a5be: 46ee         	mov	lr, sp
7009a5c0: f8ce 8014    	str.w	r8, [lr, #0x14]
7009a5c4: f8ce 7010    	str.w	r7, [lr, #0x10]
7009a5c8: f8ce 600c    	str.w	r6, [lr, #0xc]
7009a5cc: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a5d0: 0fe4         	lsrs	r4, r4, #0x1f
7009a5d2: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a5d6: f8ce c000    	str.w	r12, [lr]
7009a5da: f00a fb51    	bl	0x700a4c80 <_ntoa_long> @ imm = #0xa6a2
7009a5de: 9037         	str	r0, [sp, #0xdc]
;           }
7009a5e0: e054         	b	0x7009a68c <_vsnprintf+0x5ac> @ imm = #0xa8
;             const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
7009a5e2: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a5e6: 0640         	lsls	r0, r0, #0x19
7009a5e8: 2800         	cmp	r0, #0x0
7009a5ea: d506         	bpl	0x7009a5fa <_vsnprintf+0x51a> @ imm = #0xc
7009a5ec: e7ff         	b	0x7009a5ee <_vsnprintf+0x50e> @ imm = #-0x2
7009a5ee: 9840         	ldr	r0, [sp, #0x100]
7009a5f0: 1d01         	adds	r1, r0, #0x4
7009a5f2: 9140         	str	r1, [sp, #0x100]
7009a5f4: 7800         	ldrb	r0, [r0]
7009a5f6: 901a         	str	r0, [sp, #0x68]
7009a5f8: e015         	b	0x7009a626 <_vsnprintf+0x546> @ imm = #0x2a
7009a5fa: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a5fe: 0600         	lsls	r0, r0, #0x18
7009a600: 2800         	cmp	r0, #0x0
7009a602: d507         	bpl	0x7009a614 <_vsnprintf+0x534> @ imm = #0xe
7009a604: e7ff         	b	0x7009a606 <_vsnprintf+0x526> @ imm = #-0x2
7009a606: 9840         	ldr	r0, [sp, #0x100]
7009a608: 1d01         	adds	r1, r0, #0x4
7009a60a: 9140         	str	r1, [sp, #0x100]
7009a60c: f9b0 0000    	ldrsh.w	r0, [r0]
7009a610: 9019         	str	r0, [sp, #0x64]
7009a612: e005         	b	0x7009a620 <_vsnprintf+0x540> @ imm = #0xa
7009a614: 9840         	ldr	r0, [sp, #0x100]
7009a616: 1d01         	adds	r1, r0, #0x4
7009a618: 9140         	str	r1, [sp, #0x100]
7009a61a: 6800         	ldr	r0, [r0]
7009a61c: 9019         	str	r0, [sp, #0x64]
7009a61e: e7ff         	b	0x7009a620 <_vsnprintf+0x540> @ imm = #-0x2
7009a620: 9819         	ldr	r0, [sp, #0x64]
7009a622: 901a         	str	r0, [sp, #0x68]
7009a624: e7ff         	b	0x7009a626 <_vsnprintf+0x546> @ imm = #-0x2
7009a626: 981a         	ldr	r0, [sp, #0x68]
7009a628: 9030         	str	r0, [sp, #0xc0]
;             idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
7009a62a: 983f         	ldr	r0, [sp, #0xfc]
7009a62c: 9015         	str	r0, [sp, #0x54]
7009a62e: 983e         	ldr	r0, [sp, #0xf8]
7009a630: 9016         	str	r0, [sp, #0x58]
7009a632: 9837         	ldr	r0, [sp, #0xdc]
7009a634: 9017         	str	r0, [sp, #0x5c]
7009a636: 983d         	ldr	r0, [sp, #0xf4]
7009a638: 9018         	str	r0, [sp, #0x60]
7009a63a: 9830         	ldr	r0, [sp, #0xc0]
7009a63c: 2801         	cmp	r0, #0x1
7009a63e: db03         	blt	0x7009a648 <_vsnprintf+0x568> @ imm = #0x6
7009a640: e7ff         	b	0x7009a642 <_vsnprintf+0x562> @ imm = #-0x2
7009a642: 9830         	ldr	r0, [sp, #0xc0]
7009a644: 9014         	str	r0, [sp, #0x50]
7009a646: e003         	b	0x7009a650 <_vsnprintf+0x570> @ imm = #0x6
7009a648: 9830         	ldr	r0, [sp, #0xc0]
7009a64a: 4240         	rsbs	r0, r0, #0
7009a64c: 9014         	str	r0, [sp, #0x50]
7009a64e: e7ff         	b	0x7009a650 <_vsnprintf+0x570> @ imm = #-0x2
7009a650: 9b18         	ldr	r3, [sp, #0x60]
7009a652: 9a17         	ldr	r2, [sp, #0x5c]
7009a654: 9916         	ldr	r1, [sp, #0x58]
7009a656: 9815         	ldr	r0, [sp, #0x54]
7009a658: f8dd c050    	ldr.w	r12, [sp, #0x50]
7009a65c: 9c30         	ldr	r4, [sp, #0xc0]
7009a65e: 9d34         	ldr	r5, [sp, #0xd0]
7009a660: 9e39         	ldr	r6, [sp, #0xe4]
7009a662: 9f3a         	ldr	r7, [sp, #0xe8]
7009a664: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a668: 46ee         	mov	lr, sp
7009a66a: f8ce 8014    	str.w	r8, [lr, #0x14]
7009a66e: f8ce 7010    	str.w	r7, [lr, #0x10]
7009a672: f8ce 600c    	str.w	r6, [lr, #0xc]
7009a676: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a67a: 0fe4         	lsrs	r4, r4, #0x1f
7009a67c: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a680: f8ce c000    	str.w	r12, [lr]
7009a684: f00a fafc    	bl	0x700a4c80 <_ntoa_long> @ imm = #0xa5f8
7009a688: 9037         	str	r0, [sp, #0xdc]
7009a68a: e7ff         	b	0x7009a68c <_vsnprintf+0x5ac> @ imm = #-0x2
7009a68c: e7ff         	b	0x7009a68e <_vsnprintf+0x5ae> @ imm = #-0x2
;         }
7009a68e: e09c         	b	0x7009a7ca <_vsnprintf+0x6ea> @ imm = #0x138
;           if (flags & FLAGS_LONG_LONG) {
7009a690: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a694: 0780         	lsls	r0, r0, #0x1e
7009a696: 2800         	cmp	r0, #0x0
7009a698: d52f         	bpl	0x7009a6fa <_vsnprintf+0x61a> @ imm = #0x5e
7009a69a: e7ff         	b	0x7009a69c <_vsnprintf+0x5bc> @ imm = #-0x2
;             idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
7009a69c: 983f         	ldr	r0, [sp, #0xfc]
7009a69e: 993e         	ldr	r1, [sp, #0xf8]
7009a6a0: 9a37         	ldr	r2, [sp, #0xdc]
7009a6a2: 9b3d         	ldr	r3, [sp, #0xf4]
7009a6a4: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a6a8: f10c 0c07    	add.w	r12, r12, #0x7
7009a6ac: f02c 0e07    	bic	lr, r12, #0x7
7009a6b0: f10e 0c08    	add.w	r12, lr, #0x8
7009a6b4: f8cd c100    	str.w	r12, [sp, #0x100]
7009a6b8: f8de c000    	ldr.w	r12, [lr]
7009a6bc: f8de 4004    	ldr.w	r4, [lr, #0x4]
7009a6c0: 9e34         	ldr	r6, [sp, #0xd0]
7009a6c2: 9d39         	ldr	r5, [sp, #0xe4]
7009a6c4: 9f3a         	ldr	r7, [sp, #0xe8]
7009a6c6: f8dd 80ec    	ldr.w	r8, [sp, #0xec]
7009a6ca: 46ee         	mov	lr, sp
7009a6cc: f8cd e04c    	str.w	lr, [sp, #0x4c]
7009a6d0: f8ce 8020    	str.w	r8, [lr, #0x20]
7009a6d4: f8ce 701c    	str.w	r7, [lr, #0x1c]
7009a6d8: f8ce 5018    	str.w	r5, [lr, #0x18]
7009a6dc: 2500         	movs	r5, #0x0
7009a6de: f8ce 5014    	str.w	r5, [lr, #0x14]
7009a6e2: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a6e6: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a6ea: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a6ee: f8ce c000    	str.w	r12, [lr]
7009a6f2: f008 faed    	bl	0x700a2cd0 <_ntoa_long_long> @ imm = #0x85da
7009a6f6: 9037         	str	r0, [sp, #0xdc]
;           }
7009a6f8: e066         	b	0x7009a7c8 <_vsnprintf+0x6e8> @ imm = #0xcc
;           else if (flags & FLAGS_LONG) {
7009a6fa: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a6fe: 07c0         	lsls	r0, r0, #0x1f
7009a700: b310         	cbz	r0, 0x7009a748 <_vsnprintf+0x668> @ imm = #0x44
7009a702: e7ff         	b	0x7009a704 <_vsnprintf+0x624> @ imm = #-0x2
;             idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
7009a704: 983f         	ldr	r0, [sp, #0xfc]
7009a706: 993e         	ldr	r1, [sp, #0xf8]
7009a708: 9a37         	ldr	r2, [sp, #0xdc]
7009a70a: 9b3d         	ldr	r3, [sp, #0xf4]
7009a70c: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a710: f10c 0e04    	add.w	lr, r12, #0x4
7009a714: f8cd e100    	str.w	lr, [sp, #0x100]
7009a718: f8dc c000    	ldr.w	r12, [r12]
7009a71c: 9c34         	ldr	r4, [sp, #0xd0]
7009a71e: 9d39         	ldr	r5, [sp, #0xe4]
7009a720: 9e3a         	ldr	r6, [sp, #0xe8]
7009a722: 9f3b         	ldr	r7, [sp, #0xec]
7009a724: 46ee         	mov	lr, sp
7009a726: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a72a: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a72e: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a732: f8ce 4008    	str.w	r4, [lr, #0x8]
7009a736: 2400         	movs	r4, #0x0
7009a738: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a73c: f8ce c000    	str.w	r12, [lr]
7009a740: f00a fa9e    	bl	0x700a4c80 <_ntoa_long> @ imm = #0xa53c
7009a744: 9037         	str	r0, [sp, #0xdc]
;           }
7009a746: e03e         	b	0x7009a7c6 <_vsnprintf+0x6e6> @ imm = #0x7c
;             const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
7009a748: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a74c: 0640         	lsls	r0, r0, #0x19
7009a74e: 2800         	cmp	r0, #0x0
7009a750: d506         	bpl	0x7009a760 <_vsnprintf+0x680> @ imm = #0xc
7009a752: e7ff         	b	0x7009a754 <_vsnprintf+0x674> @ imm = #-0x2
7009a754: 9840         	ldr	r0, [sp, #0x100]
7009a756: 1d01         	adds	r1, r0, #0x4
7009a758: 9140         	str	r1, [sp, #0x100]
7009a75a: 7800         	ldrb	r0, [r0]
7009a75c: 9012         	str	r0, [sp, #0x48]
7009a75e: e014         	b	0x7009a78a <_vsnprintf+0x6aa> @ imm = #0x28
7009a760: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a764: 0600         	lsls	r0, r0, #0x18
7009a766: 2800         	cmp	r0, #0x0
7009a768: d506         	bpl	0x7009a778 <_vsnprintf+0x698> @ imm = #0xc
7009a76a: e7ff         	b	0x7009a76c <_vsnprintf+0x68c> @ imm = #-0x2
7009a76c: 9840         	ldr	r0, [sp, #0x100]
7009a76e: 1d01         	adds	r1, r0, #0x4
7009a770: 9140         	str	r1, [sp, #0x100]
7009a772: 8800         	ldrh	r0, [r0]
7009a774: 9011         	str	r0, [sp, #0x44]
7009a776: e005         	b	0x7009a784 <_vsnprintf+0x6a4> @ imm = #0xa
7009a778: 9840         	ldr	r0, [sp, #0x100]
7009a77a: 1d01         	adds	r1, r0, #0x4
7009a77c: 9140         	str	r1, [sp, #0x100]
7009a77e: 6800         	ldr	r0, [r0]
7009a780: 9011         	str	r0, [sp, #0x44]
7009a782: e7ff         	b	0x7009a784 <_vsnprintf+0x6a4> @ imm = #-0x2
7009a784: 9811         	ldr	r0, [sp, #0x44]
7009a786: 9012         	str	r0, [sp, #0x48]
7009a788: e7ff         	b	0x7009a78a <_vsnprintf+0x6aa> @ imm = #-0x2
7009a78a: 9812         	ldr	r0, [sp, #0x48]
7009a78c: 902f         	str	r0, [sp, #0xbc]
;             idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
7009a78e: 983f         	ldr	r0, [sp, #0xfc]
7009a790: 993e         	ldr	r1, [sp, #0xf8]
7009a792: 9a37         	ldr	r2, [sp, #0xdc]
7009a794: 9b3d         	ldr	r3, [sp, #0xf4]
7009a796: f8dd c0bc    	ldr.w	r12, [sp, #0xbc]
7009a79a: 9c34         	ldr	r4, [sp, #0xd0]
7009a79c: 9d39         	ldr	r5, [sp, #0xe4]
7009a79e: 9e3a         	ldr	r6, [sp, #0xe8]
7009a7a0: 9f3b         	ldr	r7, [sp, #0xec]
7009a7a2: 46ee         	mov	lr, sp
7009a7a4: f8ce 7014    	str.w	r7, [lr, #0x14]
7009a7a8: f8ce 6010    	str.w	r6, [lr, #0x10]
7009a7ac: f8ce 500c    	str.w	r5, [lr, #0xc]
7009a7b0: f8ce 4008    	str.w	r4, [lr, #0x8]
7009a7b4: 2400         	movs	r4, #0x0
7009a7b6: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a7ba: f8ce c000    	str.w	r12, [lr]
7009a7be: f00a fa5f    	bl	0x700a4c80 <_ntoa_long> @ imm = #0xa4be
7009a7c2: 9037         	str	r0, [sp, #0xdc]
7009a7c4: e7ff         	b	0x7009a7c6 <_vsnprintf+0x6e6> @ imm = #-0x2
7009a7c6: e7ff         	b	0x7009a7c8 <_vsnprintf+0x6e8> @ imm = #-0x2
7009a7c8: e7ff         	b	0x7009a7ca <_vsnprintf+0x6ea> @ imm = #-0x2
;         format++;
7009a7ca: 983c         	ldr	r0, [sp, #0xf0]
7009a7cc: 3001         	adds	r0, #0x1
7009a7ce: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a7d0: e183         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x306
;         if (*format == 'F') flags |= FLAGS_UPPERCASE;
7009a7d2: 983c         	ldr	r0, [sp, #0xf0]
7009a7d4: 7800         	ldrb	r0, [r0]
7009a7d6: 2846         	cmp	r0, #0x46
7009a7d8: d105         	bne	0x7009a7e6 <_vsnprintf+0x706> @ imm = #0xa
7009a7da: e7ff         	b	0x7009a7dc <_vsnprintf+0x6fc> @ imm = #-0x2
7009a7dc: 983b         	ldr	r0, [sp, #0xec]
7009a7de: f040 0020    	orr	r0, r0, #0x20
7009a7e2: 903b         	str	r0, [sp, #0xec]
7009a7e4: e7ff         	b	0x7009a7e6 <_vsnprintf+0x706> @ imm = #-0x2
;         idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
7009a7e6: 983f         	ldr	r0, [sp, #0xfc]
7009a7e8: 993e         	ldr	r1, [sp, #0xf8]
7009a7ea: 9a37         	ldr	r2, [sp, #0xdc]
7009a7ec: 9b3d         	ldr	r3, [sp, #0xf4]
7009a7ee: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a7f2: f10c 0c07    	add.w	r12, r12, #0x7
7009a7f6: f02c 0c07    	bic	r12, r12, #0x7
7009a7fa: f10c 0e08    	add.w	lr, r12, #0x8
7009a7fe: f8cd e100    	str.w	lr, [sp, #0x100]
7009a802: ed9c 0b00    	vldr	d0, [r12]
7009a806: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
7009a80a: 9c3a         	ldr	r4, [sp, #0xe8]
7009a80c: 9d3b         	ldr	r5, [sp, #0xec]
7009a80e: 46ee         	mov	lr, sp
7009a810: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a814: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a818: f8ce c000    	str.w	r12, [lr]
7009a81c: f000 fc80    	bl	0x7009b120 <_ftoa>      @ imm = #0x900
7009a820: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009a822: 983c         	ldr	r0, [sp, #0xf0]
7009a824: 3001         	adds	r0, #0x1
7009a826: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a828: e157         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x2ae
;         if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
7009a82a: 983c         	ldr	r0, [sp, #0xf0]
7009a82c: 7800         	ldrb	r0, [r0]
7009a82e: 2867         	cmp	r0, #0x67
7009a830: d005         	beq	0x7009a83e <_vsnprintf+0x75e> @ imm = #0xa
7009a832: e7ff         	b	0x7009a834 <_vsnprintf+0x754> @ imm = #-0x2
7009a834: 983c         	ldr	r0, [sp, #0xf0]
7009a836: 7800         	ldrb	r0, [r0]
7009a838: 2847         	cmp	r0, #0x47
7009a83a: d105         	bne	0x7009a848 <_vsnprintf+0x768> @ imm = #0xa
7009a83c: e7ff         	b	0x7009a83e <_vsnprintf+0x75e> @ imm = #-0x2
7009a83e: 983b         	ldr	r0, [sp, #0xec]
7009a840: f440 6000    	orr	r0, r0, #0x800
7009a844: 903b         	str	r0, [sp, #0xec]
7009a846: e7ff         	b	0x7009a848 <_vsnprintf+0x768> @ imm = #-0x2
;         if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
7009a848: 983c         	ldr	r0, [sp, #0xf0]
7009a84a: 7800         	ldrb	r0, [r0]
7009a84c: 2845         	cmp	r0, #0x45
7009a84e: d005         	beq	0x7009a85c <_vsnprintf+0x77c> @ imm = #0xa
7009a850: e7ff         	b	0x7009a852 <_vsnprintf+0x772> @ imm = #-0x2
7009a852: 983c         	ldr	r0, [sp, #0xf0]
7009a854: 7800         	ldrb	r0, [r0]
7009a856: 2847         	cmp	r0, #0x47
7009a858: d105         	bne	0x7009a866 <_vsnprintf+0x786> @ imm = #0xa
7009a85a: e7ff         	b	0x7009a85c <_vsnprintf+0x77c> @ imm = #-0x2
7009a85c: 983b         	ldr	r0, [sp, #0xec]
7009a85e: f040 0020    	orr	r0, r0, #0x20
7009a862: 903b         	str	r0, [sp, #0xec]
7009a864: e7ff         	b	0x7009a866 <_vsnprintf+0x786> @ imm = #-0x2
;         idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
7009a866: 983f         	ldr	r0, [sp, #0xfc]
7009a868: 993e         	ldr	r1, [sp, #0xf8]
7009a86a: 9a37         	ldr	r2, [sp, #0xdc]
7009a86c: 9b3d         	ldr	r3, [sp, #0xf4]
7009a86e: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009a872: f10c 0c07    	add.w	r12, r12, #0x7
7009a876: f02c 0c07    	bic	r12, r12, #0x7
7009a87a: f10c 0e08    	add.w	lr, r12, #0x8
7009a87e: f8cd e100    	str.w	lr, [sp, #0x100]
7009a882: ed9c 0b00    	vldr	d0, [r12]
7009a886: f8dd c0e4    	ldr.w	r12, [sp, #0xe4]
7009a88a: 9c3a         	ldr	r4, [sp, #0xe8]
7009a88c: 9d3b         	ldr	r5, [sp, #0xec]
7009a88e: 46ee         	mov	lr, sp
7009a890: f8ce 5008    	str.w	r5, [lr, #0x8]
7009a894: f8ce 4004    	str.w	r4, [lr, #0x4]
7009a898: f8ce c000    	str.w	r12, [lr]
7009a89c: f000 fed0    	bl	0x7009b640 <_etoa>      @ imm = #0xda0
7009a8a0: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009a8a2: 983c         	ldr	r0, [sp, #0xf0]
7009a8a4: 3001         	adds	r0, #0x1
7009a8a6: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a8a8: e117         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x22e
7009a8aa: 2001         	movs	r0, #0x1
;         unsigned int l = 1U;
7009a8ac: 902e         	str	r0, [sp, #0xb8]
;         if (!(flags & FLAGS_LEFT)) {
7009a8ae: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a8b2: 0780         	lsls	r0, r0, #0x1e
7009a8b4: 2800         	cmp	r0, #0x0
7009a8b6: d413         	bmi	0x7009a8e0 <_vsnprintf+0x800> @ imm = #0x26
7009a8b8: e7ff         	b	0x7009a8ba <_vsnprintf+0x7da> @ imm = #-0x2
;           while (l++ < width) {
7009a8ba: e7ff         	b	0x7009a8bc <_vsnprintf+0x7dc> @ imm = #-0x2
7009a8bc: 982e         	ldr	r0, [sp, #0xb8]
7009a8be: 1c41         	adds	r1, r0, #0x1
7009a8c0: 912e         	str	r1, [sp, #0xb8]
7009a8c2: 993a         	ldr	r1, [sp, #0xe8]
7009a8c4: 4288         	cmp	r0, r1
7009a8c6: d20a         	bhs	0x7009a8de <_vsnprintf+0x7fe> @ imm = #0x14
7009a8c8: e7ff         	b	0x7009a8ca <_vsnprintf+0x7ea> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a8ca: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a8ce: 993e         	ldr	r1, [sp, #0xf8]
7009a8d0: 9a37         	ldr	r2, [sp, #0xdc]
7009a8d2: 1c50         	adds	r0, r2, #0x1
7009a8d4: 9037         	str	r0, [sp, #0xdc]
7009a8d6: 9b3d         	ldr	r3, [sp, #0xf4]
7009a8d8: 2020         	movs	r0, #0x20
7009a8da: 47e0         	blx	r12
;           while (l++ < width) {
7009a8dc: e7ee         	b	0x7009a8bc <_vsnprintf+0x7dc> @ imm = #-0x24
;         }
7009a8de: e7ff         	b	0x7009a8e0 <_vsnprintf+0x800> @ imm = #-0x2
;         out((char)va_arg(va, int), buffer, idx++, maxlen);
7009a8e0: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a8e4: 9840         	ldr	r0, [sp, #0x100]
7009a8e6: 1d01         	adds	r1, r0, #0x4
7009a8e8: 9140         	str	r1, [sp, #0x100]
7009a8ea: 7800         	ldrb	r0, [r0]
7009a8ec: 993e         	ldr	r1, [sp, #0xf8]
7009a8ee: 9a37         	ldr	r2, [sp, #0xdc]
7009a8f0: 1c53         	adds	r3, r2, #0x1
7009a8f2: 9337         	str	r3, [sp, #0xdc]
7009a8f4: 9b3d         	ldr	r3, [sp, #0xf4]
7009a8f6: 47e0         	blx	r12
;         if (flags & FLAGS_LEFT) {
7009a8f8: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a8fc: 0780         	lsls	r0, r0, #0x1e
7009a8fe: 2800         	cmp	r0, #0x0
7009a900: d513         	bpl	0x7009a92a <_vsnprintf+0x84a> @ imm = #0x26
7009a902: e7ff         	b	0x7009a904 <_vsnprintf+0x824> @ imm = #-0x2
;           while (l++ < width) {
7009a904: e7ff         	b	0x7009a906 <_vsnprintf+0x826> @ imm = #-0x2
7009a906: 982e         	ldr	r0, [sp, #0xb8]
7009a908: 1c41         	adds	r1, r0, #0x1
7009a90a: 912e         	str	r1, [sp, #0xb8]
7009a90c: 993a         	ldr	r1, [sp, #0xe8]
7009a90e: 4288         	cmp	r0, r1
7009a910: d20a         	bhs	0x7009a928 <_vsnprintf+0x848> @ imm = #0x14
7009a912: e7ff         	b	0x7009a914 <_vsnprintf+0x834> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a914: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a918: 993e         	ldr	r1, [sp, #0xf8]
7009a91a: 9a37         	ldr	r2, [sp, #0xdc]
7009a91c: 1c50         	adds	r0, r2, #0x1
7009a91e: 9037         	str	r0, [sp, #0xdc]
7009a920: 9b3d         	ldr	r3, [sp, #0xf4]
7009a922: 2020         	movs	r0, #0x20
7009a924: 47e0         	blx	r12
;           while (l++ < width) {
7009a926: e7ee         	b	0x7009a906 <_vsnprintf+0x826> @ imm = #-0x24
;         }
7009a928: e7ff         	b	0x7009a92a <_vsnprintf+0x84a> @ imm = #-0x2
;         format++;
7009a92a: 983c         	ldr	r0, [sp, #0xf0]
7009a92c: 3001         	adds	r0, #0x1
7009a92e: 903c         	str	r0, [sp, #0xf0]
;         break;
7009a930: e0d3         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x1a6
;         const char* p = va_arg(va, char*);
7009a932: 9840         	ldr	r0, [sp, #0x100]
7009a934: 1d01         	adds	r1, r0, #0x4
7009a936: 9140         	str	r1, [sp, #0x100]
7009a938: 6800         	ldr	r0, [r0]
7009a93a: 902d         	str	r0, [sp, #0xb4]
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
7009a93c: 982d         	ldr	r0, [sp, #0xb4]
7009a93e: 9010         	str	r0, [sp, #0x40]
7009a940: 9839         	ldr	r0, [sp, #0xe4]
7009a942: b118         	cbz	r0, 0x7009a94c <_vsnprintf+0x86c> @ imm = #0x6
7009a944: e7ff         	b	0x7009a946 <_vsnprintf+0x866> @ imm = #-0x2
7009a946: 9839         	ldr	r0, [sp, #0xe4]
7009a948: 900f         	str	r0, [sp, #0x3c]
7009a94a: e003         	b	0x7009a954 <_vsnprintf+0x874> @ imm = #0x6
7009a94c: f04f 30ff    	mov.w	r0, #0xffffffff
;         unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
7009a950: 900f         	str	r0, [sp, #0x3c]
7009a952: e7ff         	b	0x7009a954 <_vsnprintf+0x874> @ imm = #-0x2
7009a954: 9810         	ldr	r0, [sp, #0x40]
7009a956: 990f         	ldr	r1, [sp, #0x3c]
7009a958: f013 f81a    	bl	0x700ad990 <_strnlen_s> @ imm = #0x13034
7009a95c: 902c         	str	r0, [sp, #0xb0]
;         if (flags & FLAGS_PRECISION) {
7009a95e: f89d 00ed    	ldrb.w	r0, [sp, #0xed]
7009a962: 0740         	lsls	r0, r0, #0x1d
7009a964: 2800         	cmp	r0, #0x0
7009a966: d50e         	bpl	0x7009a986 <_vsnprintf+0x8a6> @ imm = #0x1c
7009a968: e7ff         	b	0x7009a96a <_vsnprintf+0x88a> @ imm = #-0x2
;           l = (l < precision ? l : precision);
7009a96a: 982c         	ldr	r0, [sp, #0xb0]
7009a96c: 9939         	ldr	r1, [sp, #0xe4]
7009a96e: 4288         	cmp	r0, r1
7009a970: d203         	bhs	0x7009a97a <_vsnprintf+0x89a> @ imm = #0x6
7009a972: e7ff         	b	0x7009a974 <_vsnprintf+0x894> @ imm = #-0x2
7009a974: 982c         	ldr	r0, [sp, #0xb0]
7009a976: 900e         	str	r0, [sp, #0x38]
7009a978: e002         	b	0x7009a980 <_vsnprintf+0x8a0> @ imm = #0x4
7009a97a: 9839         	ldr	r0, [sp, #0xe4]
7009a97c: 900e         	str	r0, [sp, #0x38]
7009a97e: e7ff         	b	0x7009a980 <_vsnprintf+0x8a0> @ imm = #-0x2
7009a980: 980e         	ldr	r0, [sp, #0x38]
7009a982: 902c         	str	r0, [sp, #0xb0]
;         }
7009a984: e7ff         	b	0x7009a986 <_vsnprintf+0x8a6> @ imm = #-0x2
;         if (!(flags & FLAGS_LEFT)) {
7009a986: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009a98a: 0780         	lsls	r0, r0, #0x1e
7009a98c: 2800         	cmp	r0, #0x0
7009a98e: d413         	bmi	0x7009a9b8 <_vsnprintf+0x8d8> @ imm = #0x26
7009a990: e7ff         	b	0x7009a992 <_vsnprintf+0x8b2> @ imm = #-0x2
;           while (l++ < width) {
7009a992: e7ff         	b	0x7009a994 <_vsnprintf+0x8b4> @ imm = #-0x2
7009a994: 982c         	ldr	r0, [sp, #0xb0]
7009a996: 1c41         	adds	r1, r0, #0x1
7009a998: 912c         	str	r1, [sp, #0xb0]
7009a99a: 993a         	ldr	r1, [sp, #0xe8]
7009a99c: 4288         	cmp	r0, r1
7009a99e: d20a         	bhs	0x7009a9b6 <_vsnprintf+0x8d6> @ imm = #0x14
7009a9a0: e7ff         	b	0x7009a9a2 <_vsnprintf+0x8c2> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009a9a2: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a9a6: 993e         	ldr	r1, [sp, #0xf8]
7009a9a8: 9a37         	ldr	r2, [sp, #0xdc]
7009a9aa: 1c50         	adds	r0, r2, #0x1
7009a9ac: 9037         	str	r0, [sp, #0xdc]
7009a9ae: 9b3d         	ldr	r3, [sp, #0xf4]
7009a9b0: 2020         	movs	r0, #0x20
7009a9b2: 47e0         	blx	r12
;           while (l++ < width) {
7009a9b4: e7ee         	b	0x7009a994 <_vsnprintf+0x8b4> @ imm = #-0x24
;         }
7009a9b6: e7ff         	b	0x7009a9b8 <_vsnprintf+0x8d8> @ imm = #-0x2
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a9b8: e7ff         	b	0x7009a9ba <_vsnprintf+0x8da> @ imm = #-0x2
7009a9ba: 982d         	ldr	r0, [sp, #0xb4]
7009a9bc: 7801         	ldrb	r1, [r0]
7009a9be: 2000         	movs	r0, #0x0
7009a9c0: 900d         	str	r0, [sp, #0x34]
7009a9c2: b1a1         	cbz	r1, 0x7009a9ee <_vsnprintf+0x90e> @ imm = #0x28
7009a9c4: e7ff         	b	0x7009a9c6 <_vsnprintf+0x8e6> @ imm = #-0x2
7009a9c6: 2001         	movs	r0, #0x1
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a9c8: f89d 10ed    	ldrb.w	r1, [sp, #0xed]
7009a9cc: ea4f 7141    	lsl.w	r1, r1, #0x1d
7009a9d0: 2900         	cmp	r1, #0x0
7009a9d2: 900c         	str	r0, [sp, #0x30]
7009a9d4: d508         	bpl	0x7009a9e8 <_vsnprintf+0x908> @ imm = #0x10
7009a9d6: e7ff         	b	0x7009a9d8 <_vsnprintf+0x8f8> @ imm = #-0x2
7009a9d8: 9839         	ldr	r0, [sp, #0xe4]
7009a9da: 1e41         	subs	r1, r0, #0x1
7009a9dc: 9139         	str	r1, [sp, #0xe4]
7009a9de: 2800         	cmp	r0, #0x0
7009a9e0: bf18         	it	ne
7009a9e2: 2001         	movne	r0, #0x1
7009a9e4: 900c         	str	r0, [sp, #0x30]
7009a9e6: e7ff         	b	0x7009a9e8 <_vsnprintf+0x908> @ imm = #-0x2
7009a9e8: 980c         	ldr	r0, [sp, #0x30]
7009a9ea: 900d         	str	r0, [sp, #0x34]
7009a9ec: e7ff         	b	0x7009a9ee <_vsnprintf+0x90e> @ imm = #-0x2
7009a9ee: 980d         	ldr	r0, [sp, #0x34]
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009a9f0: 07c0         	lsls	r0, r0, #0x1f
7009a9f2: b168         	cbz	r0, 0x7009aa10 <_vsnprintf+0x930> @ imm = #0x1a
7009a9f4: e7ff         	b	0x7009a9f6 <_vsnprintf+0x916> @ imm = #-0x2
;           out(*(p++), buffer, idx++, maxlen);
7009a9f6: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009a9fa: 982d         	ldr	r0, [sp, #0xb4]
7009a9fc: 1c41         	adds	r1, r0, #0x1
7009a9fe: 912d         	str	r1, [sp, #0xb4]
7009aa00: 7800         	ldrb	r0, [r0]
7009aa02: 993e         	ldr	r1, [sp, #0xf8]
7009aa04: 9a37         	ldr	r2, [sp, #0xdc]
7009aa06: 1c53         	adds	r3, r2, #0x1
7009aa08: 9337         	str	r3, [sp, #0xdc]
7009aa0a: 9b3d         	ldr	r3, [sp, #0xf4]
7009aa0c: 47e0         	blx	r12
;         while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
7009aa0e: e7d4         	b	0x7009a9ba <_vsnprintf+0x8da> @ imm = #-0x58
;         if (flags & FLAGS_LEFT) {
7009aa10: f89d 00ec    	ldrb.w	r0, [sp, #0xec]
7009aa14: 0780         	lsls	r0, r0, #0x1e
7009aa16: 2800         	cmp	r0, #0x0
7009aa18: d513         	bpl	0x7009aa42 <_vsnprintf+0x962> @ imm = #0x26
7009aa1a: e7ff         	b	0x7009aa1c <_vsnprintf+0x93c> @ imm = #-0x2
;           while (l++ < width) {
7009aa1c: e7ff         	b	0x7009aa1e <_vsnprintf+0x93e> @ imm = #-0x2
7009aa1e: 982c         	ldr	r0, [sp, #0xb0]
7009aa20: 1c41         	adds	r1, r0, #0x1
7009aa22: 912c         	str	r1, [sp, #0xb0]
7009aa24: 993a         	ldr	r1, [sp, #0xe8]
7009aa26: 4288         	cmp	r0, r1
7009aa28: d20a         	bhs	0x7009aa40 <_vsnprintf+0x960> @ imm = #0x14
7009aa2a: e7ff         	b	0x7009aa2c <_vsnprintf+0x94c> @ imm = #-0x2
;             out(' ', buffer, idx++, maxlen);
7009aa2c: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009aa30: 993e         	ldr	r1, [sp, #0xf8]
7009aa32: 9a37         	ldr	r2, [sp, #0xdc]
7009aa34: 1c50         	adds	r0, r2, #0x1
7009aa36: 9037         	str	r0, [sp, #0xdc]
7009aa38: 9b3d         	ldr	r3, [sp, #0xf4]
7009aa3a: 2020         	movs	r0, #0x20
7009aa3c: 47e0         	blx	r12
;           while (l++ < width) {
7009aa3e: e7ee         	b	0x7009aa1e <_vsnprintf+0x93e> @ imm = #-0x24
;         }
7009aa40: e7ff         	b	0x7009aa42 <_vsnprintf+0x962> @ imm = #-0x2
;         format++;
7009aa42: 983c         	ldr	r0, [sp, #0xf0]
7009aa44: 3001         	adds	r0, #0x1
7009aa46: 903c         	str	r0, [sp, #0xf0]
;         break;
7009aa48: e047         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x8e
7009aa4a: 2008         	movs	r0, #0x8
;         width = sizeof(void*) * 2U;
7009aa4c: 903a         	str	r0, [sp, #0xe8]
;         flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
7009aa4e: 983b         	ldr	r0, [sp, #0xec]
7009aa50: f040 0021    	orr	r0, r0, #0x21
7009aa54: 903b         	str	r0, [sp, #0xec]
7009aa56: 2400         	movs	r4, #0x0
;         const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
7009aa58: f88d 40af    	strb.w	r4, [sp, #0xaf]
;           idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);
7009aa5c: 983f         	ldr	r0, [sp, #0xfc]
7009aa5e: 993e         	ldr	r1, [sp, #0xf8]
7009aa60: 9a37         	ldr	r2, [sp, #0xdc]
7009aa62: 9b3d         	ldr	r3, [sp, #0xf4]
7009aa64: f8dd c100    	ldr.w	r12, [sp, #0x100]
7009aa68: f10c 0e04    	add.w	lr, r12, #0x4
7009aa6c: f8cd e100    	str.w	lr, [sp, #0x100]
7009aa70: f8dc c000    	ldr.w	r12, [r12]
7009aa74: 9d39         	ldr	r5, [sp, #0xe4]
7009aa76: 9e3a         	ldr	r6, [sp, #0xe8]
7009aa78: 9f3b         	ldr	r7, [sp, #0xec]
7009aa7a: 46ee         	mov	lr, sp
7009aa7c: f8ce 7014    	str.w	r7, [lr, #0x14]
7009aa80: f8ce 6010    	str.w	r6, [lr, #0x10]
7009aa84: f8ce 500c    	str.w	r5, [lr, #0xc]
7009aa88: 2510         	movs	r5, #0x10
7009aa8a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009aa8e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009aa92: f8ce c000    	str.w	r12, [lr]
7009aa96: f00a f8f3    	bl	0x700a4c80 <_ntoa_long> @ imm = #0xa1e6
7009aa9a: 9037         	str	r0, [sp, #0xdc]
;         format++;
7009aa9c: 983c         	ldr	r0, [sp, #0xf0]
7009aa9e: 3001         	adds	r0, #0x1
7009aaa0: 903c         	str	r0, [sp, #0xf0]
;         break;
7009aaa2: e01a         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x34
;         out('%', buffer, idx++, maxlen);
7009aaa4: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009aaa8: 993e         	ldr	r1, [sp, #0xf8]
7009aaaa: 9a37         	ldr	r2, [sp, #0xdc]
7009aaac: 1c50         	adds	r0, r2, #0x1
7009aaae: 9037         	str	r0, [sp, #0xdc]
7009aab0: 9b3d         	ldr	r3, [sp, #0xf4]
7009aab2: 2025         	movs	r0, #0x25
7009aab4: 47e0         	blx	r12
;         format++;
7009aab6: 983c         	ldr	r0, [sp, #0xf0]
7009aab8: 3001         	adds	r0, #0x1
7009aaba: 903c         	str	r0, [sp, #0xf0]
;         break;
7009aabc: e00d         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #0x1a
;         out(*format, buffer, idx++, maxlen);
7009aabe: f8dd c0fc    	ldr.w	r12, [sp, #0xfc]
7009aac2: 983c         	ldr	r0, [sp, #0xf0]
7009aac4: 7800         	ldrb	r0, [r0]
7009aac6: 993e         	ldr	r1, [sp, #0xf8]
7009aac8: 9a37         	ldr	r2, [sp, #0xdc]
7009aaca: 1c53         	adds	r3, r2, #0x1
7009aacc: 9337         	str	r3, [sp, #0xdc]
7009aace: 9b3d         	ldr	r3, [sp, #0xf4]
7009aad0: 47e0         	blx	r12
;         format++;
7009aad2: 983c         	ldr	r0, [sp, #0xf0]
7009aad4: 3001         	adds	r0, #0x1
7009aad6: 903c         	str	r0, [sp, #0xf0]
;         break;
7009aad8: e7ff         	b	0x7009aada <_vsnprintf+0x9fa> @ imm = #-0x2
;   while (*format)
7009aada: f7ff bb18    	b.w	0x7009a10e <_vsnprintf+0x2e> @ imm = #-0x9d0
;   out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
7009aade: 983f         	ldr	r0, [sp, #0xfc]
7009aae0: 900a         	str	r0, [sp, #0x28]
7009aae2: 983e         	ldr	r0, [sp, #0xf8]
7009aae4: 900b         	str	r0, [sp, #0x2c]
7009aae6: 9837         	ldr	r0, [sp, #0xdc]
7009aae8: 993d         	ldr	r1, [sp, #0xf4]
7009aaea: 4288         	cmp	r0, r1
7009aaec: d203         	bhs	0x7009aaf6 <_vsnprintf+0xa16> @ imm = #0x6
7009aaee: e7ff         	b	0x7009aaf0 <_vsnprintf+0xa10> @ imm = #-0x2
7009aaf0: 9837         	ldr	r0, [sp, #0xdc]
7009aaf2: 9009         	str	r0, [sp, #0x24]
7009aaf4: e003         	b	0x7009aafe <_vsnprintf+0xa1e> @ imm = #0x6
7009aaf6: 983d         	ldr	r0, [sp, #0xf4]
7009aaf8: 3801         	subs	r0, #0x1
7009aafa: 9009         	str	r0, [sp, #0x24]
7009aafc: e7ff         	b	0x7009aafe <_vsnprintf+0xa1e> @ imm = #-0x2
7009aafe: f8dd c028    	ldr.w	r12, [sp, #0x28]
7009ab02: 990b         	ldr	r1, [sp, #0x2c]
7009ab04: 9a09         	ldr	r2, [sp, #0x24]
7009ab06: 9b3d         	ldr	r3, [sp, #0xf4]
7009ab08: 2000         	movs	r0, #0x0
7009ab0a: 47e0         	blx	r12
;   return (int)idx;
7009ab0c: 9837         	ldr	r0, [sp, #0xdc]
7009ab0e: b041         	add	sp, #0x104
7009ab10: e8bd 83f0    	pop.w	{r4, r5, r6, r7, r8, r9, pc}

7009ab14 <__aeabi_errno_addr>:
7009ab14: e59f0000     	ldr	r0, [pc]                @ 0x7009ab1c <__aeabi_errno_addr+0x8>
7009ab18: e12fff1e     	bx	lr
7009ab1c: c0 29 0b 70  	.word	0x700b29c0

7009ab20 <Sciclient_rmIrqRouteValidate>:
; {
7009ab20: b580         	push	{r7, lr}
7009ab22: b09e         	sub	sp, #0x78
7009ab24: 901d         	str	r0, [sp, #0x74]
7009ab26: 2001         	movs	r0, #0x1
;     bool valid = true;
7009ab28: f88d 0073    	strb.w	r0, [sp, #0x73]
7009ab2c: 2000         	movs	r0, #0x0
;     const struct Sciclient_rmIrqNode *cur_n, *next_n = NULL;
7009ab2e: 9009         	str	r0, [sp, #0x24]
7009ab30: 9019         	str	r0, [sp, #0x64]
;     bool cur_outp_valid = false, next_inp_valid = false;
7009ab32: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009ab36: f88d 005e    	strb.w	r0, [sp, #0x5e]
;     uint16_t cur_outp = 0, next_inp = 0;
7009ab3a: f8ad 0056    	strh.w	r0, [sp, #0x56]
7009ab3e: f8ad 0054    	strh.w	r0, [sp, #0x54]
;     struct tisci_msg_rm_get_resource_range_req req = {{0}};
7009ab42: 9014         	str	r0, [sp, #0x50]
7009ab44: 9013         	str	r0, [sp, #0x4c]
7009ab46: 9012         	str	r0, [sp, #0x48]
;     struct tisci_msg_rm_get_resource_range_resp host_resp = {{0}};
7009ab48: 9011         	str	r0, [sp, #0x44]
7009ab4a: 9010         	str	r0, [sp, #0x40]
7009ab4c: 900f         	str	r0, [sp, #0x3c]
7009ab4e: 900e         	str	r0, [sp, #0x38]
;     struct tisci_msg_rm_get_resource_range_resp all_resp = {{0}};
7009ab50: 900d         	str	r0, [sp, #0x34]
7009ab52: 900c         	str	r0, [sp, #0x30]
7009ab54: 900b         	str	r0, [sp, #0x2c]
7009ab56: 900a         	str	r0, [sp, #0x28]
;     if (cfg->s_ia == SCICLIENT_RM_DEV_NONE) {
7009ab58: 981d         	ldr	r0, [sp, #0x74]
7009ab5a: 8a00         	ldrh	r0, [r0, #0x10]
7009ab5c: 28ff         	cmp	r0, #0xff
7009ab5e: d12c         	bne	0x7009abba <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #0x58
7009ab60: e7ff         	b	0x7009ab62 <Sciclient_rmIrqRouteValidate+0x42> @ imm = #-0x2
7009ab62: 2000         	movs	r0, #0x0
;         cur_n = Sciclient_rmPsGetIrqNode(0u);
7009ab64: f014 fc5c    	bl	0x700af420 <Sciclient_rmPsGetIrqNode> @ imm = #0x148b8
7009ab68: 901a         	str	r0, [sp, #0x68]
;         if (cur_n == NULL) {
7009ab6a: 981a         	ldr	r0, [sp, #0x68]
7009ab6c: b920         	cbnz	r0, 0x7009ab78 <Sciclient_rmIrqRouteValidate+0x58> @ imm = #0x8
7009ab6e: e7ff         	b	0x7009ab70 <Sciclient_rmIrqRouteValidate+0x50> @ imm = #-0x2
7009ab70: 2000         	movs	r0, #0x0
;             valid = false;
7009ab72: f88d 0073    	strb.w	r0, [sp, #0x73]
;         } else {
7009ab76: e01f         	b	0x7009abb8 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #0x3e
;             cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(0u)];
7009ab78: 981a         	ldr	r0, [sp, #0x68]
7009ab7a: 6840         	ldr	r0, [r0, #0x4]
7009ab7c: 9008         	str	r0, [sp, #0x20]
7009ab7e: 2000         	movs	r0, #0x0
7009ab80: f013 f85e    	bl	0x700adc40 <Sciclient_rmPsGetIfIdx> @ imm = #0x130bc
7009ab84: 4601         	mov	r1, r0
7009ab86: 9808         	ldr	r0, [sp, #0x20]
7009ab88: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009ab8c: 9018         	str	r0, [sp, #0x60]
;             if ((cfg->s_idx < cur_if->lbase) ||
7009ab8e: 981d         	ldr	r0, [sp, #0x74]
7009ab90: 8900         	ldrh	r0, [r0, #0x8]
7009ab92: 9918         	ldr	r1, [sp, #0x60]
7009ab94: 8809         	ldrh	r1, [r1]
7009ab96: 4288         	cmp	r0, r1
7009ab98: db09         	blt	0x7009abae <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #0x12
7009ab9a: e7ff         	b	0x7009ab9c <Sciclient_rmIrqRouteValidate+0x7c> @ imm = #-0x2
;                 (cfg->s_idx >= (cur_if->lbase + cur_if->len))) {
7009ab9c: 981d         	ldr	r0, [sp, #0x74]
7009ab9e: 8900         	ldrh	r0, [r0, #0x8]
7009aba0: 9a18         	ldr	r2, [sp, #0x60]
7009aba2: 8811         	ldrh	r1, [r2]
7009aba4: 8892         	ldrh	r2, [r2, #0x4]
7009aba6: 4411         	add	r1, r2
;             if ((cfg->s_idx < cur_if->lbase) ||
7009aba8: 4288         	cmp	r0, r1
7009abaa: db04         	blt	0x7009abb6 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #0x8
7009abac: e7ff         	b	0x7009abae <Sciclient_rmIrqRouteValidate+0x8e> @ imm = #-0x2
7009abae: 2000         	movs	r0, #0x0
;                 valid = false;
7009abb0: f88d 0073    	strb.w	r0, [sp, #0x73]
;             }
7009abb4: e7ff         	b	0x7009abb6 <Sciclient_rmIrqRouteValidate+0x96> @ imm = #-0x2
7009abb6: e7ff         	b	0x7009abb8 <Sciclient_rmIrqRouteValidate+0x98> @ imm = #-0x2
;     }
7009abb8: e7ff         	b	0x7009abba <Sciclient_rmIrqRouteValidate+0x9a> @ imm = #-0x2
;     if ((valid == true) &&
7009abba: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009abbe: 07c0         	lsls	r0, r0, #0x1f
7009abc0: b148         	cbz	r0, 0x7009abd6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x12
7009abc2: e7ff         	b	0x7009abc4 <Sciclient_rmIrqRouteValidate+0xa4> @ imm = #-0x2
;         (Sciclient_rmPsGetPsp() <= 1U)) {
7009abc4: f015 f85c    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0x150b8
;     if ((valid == true) &&
7009abc8: 2801         	cmp	r0, #0x1
7009abca: d804         	bhi	0x7009abd6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #0x8
7009abcc: e7ff         	b	0x7009abce <Sciclient_rmIrqRouteValidate+0xae> @ imm = #-0x2
7009abce: 2000         	movs	r0, #0x0
;         valid = false;
7009abd0: f88d 0073    	strb.w	r0, [sp, #0x73]
;     }
7009abd4: e7ff         	b	0x7009abd6 <Sciclient_rmIrqRouteValidate+0xb6> @ imm = #-0x2
;     if (valid == true) {
7009abd6: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009abda: 07c0         	lsls	r0, r0, #0x1f
7009abdc: b150         	cbz	r0, 0x7009abf4 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #0x14
7009abde: e7ff         	b	0x7009abe0 <Sciclient_rmIrqRouteValidate+0xc0> @ imm = #-0x2
;         if (Sciclient_rmIrqCheckLoop(cfg) == true) {
7009abe0: 981d         	ldr	r0, [sp, #0x74]
7009abe2: f00d fdcd    	bl	0x700a8780 <Sciclient_rmIrqCheckLoop> @ imm = #0xdb9a
7009abe6: b120         	cbz	r0, 0x7009abf2 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #0x8
7009abe8: e7ff         	b	0x7009abea <Sciclient_rmIrqRouteValidate+0xca> @ imm = #-0x2
7009abea: 2000         	movs	r0, #0x0
;             valid = false;
7009abec: f88d 0073    	strb.w	r0, [sp, #0x73]
;         }
7009abf0: e7ff         	b	0x7009abf2 <Sciclient_rmIrqRouteValidate+0xd2> @ imm = #-0x2
;     }
7009abf2: e7ff         	b	0x7009abf4 <Sciclient_rmIrqRouteValidate+0xd4> @ imm = #-0x2
7009abf4: 2000         	movs	r0, #0x0
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009abf6: f8ad 0070    	strh.w	r0, [sp, #0x70]
7009abfa: e7ff         	b	0x7009abfc <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x2
7009abfc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac00: 9006         	str	r0, [sp, #0x18]
7009ac02: f015 f83d    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0x1507a
7009ac06: 9906         	ldr	r1, [sp, #0x18]
7009ac08: 4602         	mov	r2, r0
7009ac0a: 2000         	movs	r0, #0x0
7009ac0c: 4291         	cmp	r1, r2
7009ac0e: 9007         	str	r0, [sp, #0x1c]
7009ac10: da06         	bge	0x7009ac20 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #0xc
7009ac12: e7ff         	b	0x7009ac14 <Sciclient_rmIrqRouteValidate+0xf4> @ imm = #-0x2
7009ac14: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009ac18: f000 0001    	and	r0, r0, #0x1
7009ac1c: 9007         	str	r0, [sp, #0x1c]
7009ac1e: e7ff         	b	0x7009ac20 <Sciclient_rmIrqRouteValidate+0x100> @ imm = #-0x2
7009ac20: 9807         	ldr	r0, [sp, #0x1c]
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009ac22: 07c0         	lsls	r0, r0, #0x1f
7009ac24: 2800         	cmp	r0, #0x0
7009ac26: f000 826f    	beq.w	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x4de
7009ac2a: e7ff         	b	0x7009ac2c <Sciclient_rmIrqRouteValidate+0x10c> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
7009ac2c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac30: f014 fbf6    	bl	0x700af420 <Sciclient_rmPsGetIrqNode> @ imm = #0x147ec
7009ac34: 901a         	str	r0, [sp, #0x68]
;         cur_if = cur_n->p_if[Sciclient_rmPsGetIfIdx(i)];
7009ac36: 981a         	ldr	r0, [sp, #0x68]
7009ac38: 6840         	ldr	r0, [r0, #0x4]
7009ac3a: 9004         	str	r0, [sp, #0x10]
7009ac3c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac40: f012 fffe    	bl	0x700adc40 <Sciclient_rmPsGetIfIdx> @ imm = #0x12ffc
7009ac44: 4601         	mov	r1, r0
7009ac46: 9804         	ldr	r0, [sp, #0x10]
7009ac48: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009ac4c: 9018         	str	r0, [sp, #0x60]
;         if (i < (Sciclient_rmPsGetPsp() - 1u)) {
7009ac4e: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac52: 9005         	str	r0, [sp, #0x14]
7009ac54: f015 f814    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0x15028
7009ac58: 4601         	mov	r1, r0
7009ac5a: 9805         	ldr	r0, [sp, #0x14]
7009ac5c: 3901         	subs	r1, #0x1
7009ac5e: 4288         	cmp	r0, r1
7009ac60: d20f         	bhs	0x7009ac82 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #0x1e
7009ac62: e7ff         	b	0x7009ac64 <Sciclient_rmIrqRouteValidate+0x144> @ imm = #-0x2
;             next_n = Sciclient_rmPsGetIrqNode(i + 1u);
7009ac64: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac68: 3001         	adds	r0, #0x1
7009ac6a: b280         	uxth	r0, r0
7009ac6c: f014 fbd8    	bl	0x700af420 <Sciclient_rmPsGetIrqNode> @ imm = #0x147b0
7009ac70: 9019         	str	r0, [sp, #0x64]
;             if (next_n == NULL) {
7009ac72: 9819         	ldr	r0, [sp, #0x64]
7009ac74: b920         	cbnz	r0, 0x7009ac80 <Sciclient_rmIrqRouteValidate+0x160> @ imm = #0x8
7009ac76: e7ff         	b	0x7009ac78 <Sciclient_rmIrqRouteValidate+0x158> @ imm = #-0x2
7009ac78: 2000         	movs	r0, #0x0
;                 valid = false;
7009ac7a: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ac7e: e243         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x486
;         }
7009ac80: e7ff         	b	0x7009ac82 <Sciclient_rmIrqRouteValidate+0x162> @ imm = #-0x2
;         if (i > 0u) {
7009ac82: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ac86: b158         	cbz	r0, 0x7009aca0 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #0x16
7009ac88: e7ff         	b	0x7009ac8a <Sciclient_rmIrqRouteValidate+0x16a> @ imm = #-0x2
;             if (Sciclient_rmIrIsIr(cur_n->id) != true) {
7009ac8a: 981a         	ldr	r0, [sp, #0x68]
7009ac8c: 8800         	ldrh	r0, [r0]
7009ac8e: f013 fe57    	bl	0x700ae940 <Sciclient_rmIrIsIr> @ imm = #0x13cae
7009ac92: b920         	cbnz	r0, 0x7009ac9e <Sciclient_rmIrqRouteValidate+0x17e> @ imm = #0x8
7009ac94: e7ff         	b	0x7009ac96 <Sciclient_rmIrqRouteValidate+0x176> @ imm = #-0x2
7009ac96: 2000         	movs	r0, #0x0
;                 valid = false;
7009ac98: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ac9c: e234         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x468
;         }
7009ac9e: e7ff         	b	0x7009aca0 <Sciclient_rmIrqRouteValidate+0x180> @ imm = #-0x2
;         if ((i == 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
7009aca0: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009aca4: 2800         	cmp	r0, #0x0
7009aca6: f040 8080    	bne.w	0x7009adaa <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0x100
7009acaa: e7ff         	b	0x7009acac <Sciclient_rmIrqRouteValidate+0x18c> @ imm = #-0x2
7009acac: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009acb0: 9003         	str	r0, [sp, #0xc]
7009acb2: f014 ffe5    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0x14fca
7009acb6: 4601         	mov	r1, r0
7009acb8: 9803         	ldr	r0, [sp, #0xc]
7009acba: 3901         	subs	r1, #0x1
7009acbc: 4288         	cmp	r0, r1
7009acbe: d274         	bhs	0x7009adaa <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #0xe8
7009acc0: e7ff         	b	0x7009acc2 <Sciclient_rmIrqRouteValidate+0x1a2> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cur_n->id) == true) {
7009acc2: 981a         	ldr	r0, [sp, #0x68]
7009acc4: 8800         	ldrh	r0, [r0]
7009acc6: f013 fe23    	bl	0x700ae910 <Sciclient_rmIaIsIa> @ imm = #0x13c46
7009acca: 2800         	cmp	r0, #0x0
7009accc: d049         	beq	0x7009ad62 <Sciclient_rmIrqRouteValidate+0x242> @ imm = #0x92
7009acce: e7ff         	b	0x7009acd0 <Sciclient_rmIrqRouteValidate+0x1b0> @ imm = #-0x2
7009acd0: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
7009acd2: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
7009acd6: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cfg->vint,
7009acda: 9a18         	ldr	r2, [sp, #0x60]
7009acdc: 8850         	ldrh	r0, [r2, #0x2]
7009acde: 991d         	ldr	r1, [sp, #0x74]
7009ace0: 8a49         	ldrh	r1, [r1, #0x12]
7009ace2: 8812         	ldrh	r2, [r2]
7009ace4: 1a89         	subs	r1, r1, r2
7009ace6: 4408         	add	r0, r1
7009ace8: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 cur_outp = cfg->vint;
7009acec: 981d         	ldr	r0, [sp, #0x74]
7009acee: 8a40         	ldrh	r0, [r0, #0x12]
7009acf0: f8ad 0056    	strh.w	r0, [sp, #0x56]
7009acf4: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
7009acf6: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009acfa: 9819         	ldr	r0, [sp, #0x64]
7009acfc: b160         	cbz	r0, 0x7009ad18 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x18
7009acfe: e7ff         	b	0x7009ad00 <Sciclient_rmIrqRouteValidate+0x1e0> @ imm = #-0x2
7009ad00: 9819         	ldr	r0, [sp, #0x64]
7009ad02: 8800         	ldrh	r0, [r0]
7009ad04: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009ad08: f00b fab2    	bl	0x700a6270 <Sciclient_rmIrInpIsFree> @ imm = #0xb564
7009ad0c: b920         	cbnz	r0, 0x7009ad18 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #0x8
7009ad0e: e7ff         	b	0x7009ad10 <Sciclient_rmIrqRouteValidate+0x1f0> @ imm = #-0x2
7009ad10: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
7009ad12: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
7009ad16: e7ff         	b	0x7009ad18 <Sciclient_rmIrqRouteValidate+0x1f8> @ imm = #-0x2
;                 if (Sciclient_rmParamIsValid(cfg->valid_params,
7009ad18: 981d         	ldr	r0, [sp, #0x74]
7009ad1a: 6800         	ldr	r0, [r0]
7009ad1c: 2110         	movs	r1, #0x10
7009ad1e: f013 ffef    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x13fde
7009ad22: b1e8         	cbz	r0, 0x7009ad60 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #0x3a
7009ad24: e7ff         	b	0x7009ad26 <Sciclient_rmIrqRouteValidate+0x206> @ imm = #-0x2
;                     cur_inp = cfg->global_evt;
7009ad26: 981d         	ldr	r0, [sp, #0x74]
7009ad28: 89c0         	ldrh	r0, [r0, #0xe]
7009ad2a: 9016         	str	r0, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
7009ad2c: 981a         	ldr	r0, [sp, #0x68]
7009ad2e: 8800         	ldrh	r0, [r0]
;                                       cur_inp) ==
7009ad30: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
;                     if (Sciclient_rmIaValidateGlobalEvt(cur_n->id,
7009ad34: f011 fcc4    	bl	0x700ac6c0 <Sciclient_rmIaValidateGlobalEvt> @ imm = #0x11988
7009ad38: b968         	cbnz	r0, 0x7009ad56 <Sciclient_rmIrqRouteValidate+0x236> @ imm = #0x1a
7009ad3a: e7ff         	b	0x7009ad3c <Sciclient_rmIrqRouteValidate+0x21c> @ imm = #-0x2
;                         if (Sciclient_rmPsSetInp(i, cur_inp) != SystemP_SUCCESS) {
7009ad3c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009ad40: f8bd 1058    	ldrh.w	r1, [sp, #0x58]
7009ad44: f012 fae4    	bl	0x700ad310 <Sciclient_rmPsSetInp> @ imm = #0x125c8
7009ad48: b120         	cbz	r0, 0x7009ad54 <Sciclient_rmIrqRouteValidate+0x234> @ imm = #0x8
7009ad4a: e7ff         	b	0x7009ad4c <Sciclient_rmIrqRouteValidate+0x22c> @ imm = #-0x2
7009ad4c: 2000         	movs	r0, #0x0
;                             valid = false;
7009ad4e: f88d 0073    	strb.w	r0, [sp, #0x73]
;                             break;
7009ad52: e1d9         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3b2
;                     } else {
7009ad54: e003         	b	0x7009ad5e <Sciclient_rmIrqRouteValidate+0x23e> @ imm = #0x6
7009ad56: 2000         	movs	r0, #0x0
;                         valid = false;
7009ad58: f88d 0073    	strb.w	r0, [sp, #0x73]
;                         break;
7009ad5c: e1d4         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x3a8
;                 }
7009ad5e: e7ff         	b	0x7009ad60 <Sciclient_rmIrqRouteValidate+0x240> @ imm = #-0x2
;             } else {
7009ad60: e022         	b	0x7009ada8 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #0x44
7009ad62: 2001         	movs	r0, #0x1
;                 cur_outp_valid = true;
7009ad64: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009ad68: 2000         	movs	r0, #0x0
;                 next_inp_valid = false;
7009ad6a: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = cfg->s_idx;
7009ad6e: 981d         	ldr	r0, [sp, #0x74]
7009ad70: 8900         	ldrh	r0, [r0, #0x8]
7009ad72: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
7009ad76: 9a18         	ldr	r2, [sp, #0x60]
7009ad78: 8850         	ldrh	r0, [r2, #0x2]
7009ad7a: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009ad7e: 8812         	ldrh	r2, [r2]
7009ad80: 1a89         	subs	r1, r1, r2
7009ad82: 4408         	add	r0, r1
7009ad84: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((next_n != NULL) && (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009ad88: 9819         	ldr	r0, [sp, #0x64]
7009ad8a: b160         	cbz	r0, 0x7009ada6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x18
7009ad8c: e7ff         	b	0x7009ad8e <Sciclient_rmIrqRouteValidate+0x26e> @ imm = #-0x2
7009ad8e: 9819         	ldr	r0, [sp, #0x64]
7009ad90: 8800         	ldrh	r0, [r0]
7009ad92: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009ad96: f00b fa6b    	bl	0x700a6270 <Sciclient_rmIrInpIsFree> @ imm = #0xb4d6
7009ad9a: b920         	cbnz	r0, 0x7009ada6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #0x8
7009ad9c: e7ff         	b	0x7009ad9e <Sciclient_rmIrqRouteValidate+0x27e> @ imm = #-0x2
7009ad9e: 2001         	movs	r0, #0x1
;                     next_inp_valid = true;
7009ada0: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 }
7009ada4: e7ff         	b	0x7009ada6 <Sciclient_rmIrqRouteValidate+0x286> @ imm = #-0x2
7009ada6: e7ff         	b	0x7009ada8 <Sciclient_rmIrqRouteValidate+0x288> @ imm = #-0x2
;         }
7009ada8: e7ff         	b	0x7009adaa <Sciclient_rmIrqRouteValidate+0x28a> @ imm = #-0x2
;         if ((i > 0u) && (i < (Sciclient_rmPsGetPsp() - 1u))) {
7009adaa: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009adae: 2800         	cmp	r0, #0x0
7009adb0: f000 80c4    	beq.w	0x7009af3c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x188
7009adb4: e7ff         	b	0x7009adb6 <Sciclient_rmIrqRouteValidate+0x296> @ imm = #-0x2
7009adb6: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009adba: 9002         	str	r0, [sp, #0x8]
7009adbc: f014 ff60    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0x14ec0
7009adc0: 4601         	mov	r1, r0
7009adc2: 9802         	ldr	r0, [sp, #0x8]
7009adc4: 3901         	subs	r1, #0x1
7009adc6: 4288         	cmp	r0, r1
7009adc8: f080 80b8    	bhs.w	0x7009af3c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #0x170
7009adcc: e7ff         	b	0x7009adce <Sciclient_rmIrqRouteValidate+0x2ae> @ imm = #-0x2
;             req.secondary_host = cfg->host;
7009adce: 981d         	ldr	r0, [sp, #0x74]
7009add0: 7900         	ldrb	r0, [r0, #0x4]
7009add2: f88d 0053    	strb.w	r0, [sp, #0x53]
;             req.type = cur_n->id;
7009add6: 981a         	ldr	r0, [sp, #0x68]
7009add8: 8800         	ldrh	r0, [r0]
7009adda: f8ad 0050    	strh.w	r0, [sp, #0x50]
7009adde: 2000         	movs	r0, #0x0
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
7009ade0: f88d 0052    	strb.w	r0, [sp, #0x52]
7009ade4: a812         	add	r0, sp, #0x48
7009ade6: a90e         	add	r1, sp, #0x38
7009ade8: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
7009adec: f010 fb40    	bl	0x700ab470 <Sciclient_rmGetResourceRange> @ imm = #0x10680
7009adf0: b120         	cbz	r0, 0x7009adfc <Sciclient_rmIrqRouteValidate+0x2dc> @ imm = #0x8
7009adf2: e7ff         	b	0x7009adf4 <Sciclient_rmIrqRouteValidate+0x2d4> @ imm = #-0x2
7009adf4: 2000         	movs	r0, #0x0
;                 valid = false;
7009adf6: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009adfa: e185         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30a
7009adfc: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
7009adfe: f88d 0053    	strb.w	r0, [sp, #0x53]
7009ae02: a812         	add	r0, sp, #0x48
7009ae04: a90a         	add	r1, sp, #0x28
7009ae06: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
7009ae0a: f010 fb31    	bl	0x700ab470 <Sciclient_rmGetResourceRange> @ imm = #0x10662
7009ae0e: b120         	cbz	r0, 0x7009ae1a <Sciclient_rmIrqRouteValidate+0x2fa> @ imm = #0x8
7009ae10: e7ff         	b	0x7009ae12 <Sciclient_rmIrqRouteValidate+0x2f2> @ imm = #-0x2
7009ae12: 2000         	movs	r0, #0x0
;                 valid = false;
7009ae14: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009ae18: e176         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x2ec
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
7009ae1a: 9818         	ldr	r0, [sp, #0x60]
7009ae1c: 8800         	ldrh	r0, [r0]
7009ae1e: f8ad 006e    	strh.w	r0, [sp, #0x6e]
7009ae22: e7ff         	b	0x7009ae24 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x2
7009ae24: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009ae28: 9a18         	ldr	r2, [sp, #0x60]
7009ae2a: 8811         	ldrh	r1, [r2]
7009ae2c: 8892         	ldrh	r2, [r2, #0x4]
7009ae2e: 4411         	add	r1, r2
7009ae30: 4288         	cmp	r0, r1
7009ae32: f280 8082    	bge.w	0x7009af3a <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0x104
7009ae36: e7ff         	b	0x7009ae38 <Sciclient_rmIrqRouteValidate+0x318> @ imm = #-0x2
7009ae38: 2000         	movs	r0, #0x0
;                 cur_outp_valid = false;
7009ae3a: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                 next_inp_valid = false;
7009ae3e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                 cur_outp = j;
7009ae42: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009ae46: f8ad 0056    	strh.w	r0, [sp, #0x56]
;                 next_inp = SCICLIENT_OUTP_TO_INP(cur_outp, cur_if->lbase,
7009ae4a: 9a18         	ldr	r2, [sp, #0x60]
7009ae4c: 8850         	ldrh	r0, [r2, #0x2]
7009ae4e: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009ae52: 8812         	ldrh	r2, [r2]
7009ae54: 1a89         	subs	r1, r1, r2
7009ae56: 4408         	add	r0, r1
7009ae58: f8ad 0054    	strh.w	r0, [sp, #0x54]
;                 if ((((cur_outp >= host_resp.range_start) &&
7009ae5c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae60: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009ae64: 4288         	cmp	r0, r1
7009ae66: db0a         	blt	0x7009ae7e <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #0x14
7009ae68: e7ff         	b	0x7009ae6a <Sciclient_rmIrqRouteValidate+0x34a> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start + host_resp.range_num)) ||
7009ae6a: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae6e: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009ae72: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
7009ae76: 4411         	add	r1, r2
7009ae78: 4288         	cmp	r0, r1
7009ae7a: db33         	blt	0x7009aee4 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x66
7009ae7c: e7ff         	b	0x7009ae7e <Sciclient_rmIrqRouteValidate+0x35e> @ imm = #-0x2
;                      ((cur_outp >= host_resp.range_start_sec) &&
7009ae7e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae82: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
7009ae86: 4288         	cmp	r0, r1
7009ae88: db0a         	blt	0x7009aea0 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #0x14
7009ae8a: e7ff         	b	0x7009ae8c <Sciclient_rmIrqRouteValidate+0x36c> @ imm = #-0x2
;                       (cur_outp < host_resp.range_start_sec +
7009ae8c: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009ae90: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                                   host_resp.range_num_sec))) ||
7009ae94: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                       (cur_outp < host_resp.range_start_sec +
7009ae98: 4411         	add	r1, r2
;                                   host_resp.range_num_sec))) ||
7009ae9a: 4288         	cmp	r0, r1
7009ae9c: db22         	blt	0x7009aee4 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x44
7009ae9e: e7ff         	b	0x7009aea0 <Sciclient_rmIrqRouteValidate+0x380> @ imm = #-0x2
;                     (((cur_outp >= all_resp.range_start) &&
7009aea0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aea4: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009aea8: 4288         	cmp	r0, r1
7009aeaa: db0a         	blt	0x7009aec2 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #0x14
7009aeac: e7ff         	b	0x7009aeae <Sciclient_rmIrqRouteValidate+0x38e> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start + all_resp.range_num)) ||
7009aeae: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aeb2: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009aeb6: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
7009aeba: 4411         	add	r1, r2
7009aebc: 4288         	cmp	r0, r1
7009aebe: db11         	blt	0x7009aee4 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #0x22
7009aec0: e7ff         	b	0x7009aec2 <Sciclient_rmIrqRouteValidate+0x3a2> @ imm = #-0x2
;                      ((cur_outp >= all_resp.range_start_sec) &&
7009aec2: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aec6: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
7009aeca: 4288         	cmp	r0, r1
7009aecc: db2e         	blt	0x7009af2c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x5c
7009aece: e7ff         	b	0x7009aed0 <Sciclient_rmIrqRouteValidate+0x3b0> @ imm = #-0x2
;                       (cur_outp < all_resp.range_start_sec +
7009aed0: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aed4: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                                   all_resp.range_num_sec)))) {
7009aed8: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                       (cur_outp < all_resp.range_start_sec +
7009aedc: 4411         	add	r1, r2
;                 if ((((cur_outp >= host_resp.range_start) &&
7009aede: 4288         	cmp	r0, r1
7009aee0: da24         	bge	0x7009af2c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #0x48
7009aee2: e7ff         	b	0x7009aee4 <Sciclient_rmIrqRouteValidate+0x3c4> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
7009aee4: 981a         	ldr	r0, [sp, #0x68]
7009aee6: 8800         	ldrh	r0, [r0]
7009aee8: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009aeec: f00e f920    	bl	0x700a9130 <Sciclient_rmIrOutpIsFree> @ imm = #0xe240
7009aef0: b920         	cbnz	r0, 0x7009aefc <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #0x8
7009aef2: e7ff         	b	0x7009aef4 <Sciclient_rmIrqRouteValidate+0x3d4> @ imm = #-0x2
7009aef4: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
7009aef6: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
7009aefa: e7ff         	b	0x7009aefc <Sciclient_rmIrqRouteValidate+0x3dc> @ imm = #-0x2
;                     if (Sciclient_rmIrInpIsFree(next_n->id, next_inp) ==
7009aefc: 9819         	ldr	r0, [sp, #0x64]
7009aefe: 8800         	ldrh	r0, [r0]
7009af00: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009af04: f00b f9b4    	bl	0x700a6270 <Sciclient_rmIrInpIsFree> @ imm = #0xb368
7009af08: b920         	cbnz	r0, 0x7009af14 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #0x8
7009af0a: e7ff         	b	0x7009af0c <Sciclient_rmIrqRouteValidate+0x3ec> @ imm = #-0x2
7009af0c: 2001         	movs	r0, #0x1
;                         next_inp_valid = true;
7009af0e: f88d 005e    	strb.w	r0, [sp, #0x5e]
;                     }
7009af12: e7ff         	b	0x7009af14 <Sciclient_rmIrqRouteValidate+0x3f4> @ imm = #-0x2
;                     if ((cur_outp_valid == true) &&
7009af14: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
7009af18: 07c0         	lsls	r0, r0, #0x1f
7009af1a: b130         	cbz	r0, 0x7009af2a <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0xc
7009af1c: e7ff         	b	0x7009af1e <Sciclient_rmIrqRouteValidate+0x3fe> @ imm = #-0x2
;                         (next_inp_valid == true)) {
7009af1e: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
;                     if ((cur_outp_valid == true) &&
7009af22: 07c0         	lsls	r0, r0, #0x1f
7009af24: b108         	cbz	r0, 0x7009af2a <Sciclient_rmIrqRouteValidate+0x40a> @ imm = #0x2
7009af26: e7ff         	b	0x7009af28 <Sciclient_rmIrqRouteValidate+0x408> @ imm = #-0x2
;                         break;
7009af28: e007         	b	0x7009af3a <Sciclient_rmIrqRouteValidate+0x41a> @ imm = #0xe
;                 }
7009af2a: e7ff         	b	0x7009af2c <Sciclient_rmIrqRouteValidate+0x40c> @ imm = #-0x2
;             }
7009af2c: e7ff         	b	0x7009af2e <Sciclient_rmIrqRouteValidate+0x40e> @ imm = #-0x2
;                  j++) {
7009af2e: f8bd 006e    	ldrh.w	r0, [sp, #0x6e]
7009af32: 3001         	adds	r0, #0x1
7009af34: f8ad 006e    	strh.w	r0, [sp, #0x6e]
;             for (j = cur_if->lbase; j < cur_if->lbase + cur_if->len;
7009af38: e774         	b	0x7009ae24 <Sciclient_rmIrqRouteValidate+0x304> @ imm = #-0x118
;         }
7009af3a: e7ff         	b	0x7009af3c <Sciclient_rmIrqRouteValidate+0x41c> @ imm = #-0x2
;         if (i == (Sciclient_rmPsGetPsp() - 1u)) {
7009af3c: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009af40: 9001         	str	r0, [sp, #0x4]
7009af42: f014 fe9d    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0x14d3a
7009af46: 4601         	mov	r1, r0
7009af48: 9801         	ldr	r0, [sp, #0x4]
7009af4a: 3901         	subs	r1, #0x1
7009af4c: 4288         	cmp	r0, r1
7009af4e: f040 809f    	bne.w	0x7009b090 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #0x13e
7009af52: e7ff         	b	0x7009af54 <Sciclient_rmIrqRouteValidate+0x434> @ imm = #-0x2
7009af54: 2000         	movs	r0, #0x0
;             cur_outp_valid = false;
7009af56: f88d 005f    	strb.w	r0, [sp, #0x5f]
7009af5a: 2101         	movs	r1, #0x1
;             next_inp_valid = true;
7009af5c: f88d 105e    	strb.w	r1, [sp, #0x5e]
;             req.secondary_host = cfg->host;
7009af60: 991d         	ldr	r1, [sp, #0x74]
7009af62: 7909         	ldrb	r1, [r1, #0x4]
7009af64: f88d 1053    	strb.w	r1, [sp, #0x53]
;             req.type = cur_n->id;
7009af68: 991a         	ldr	r1, [sp, #0x68]
7009af6a: 8809         	ldrh	r1, [r1]
7009af6c: f8ad 1050    	strh.w	r1, [sp, #0x50]
;             req.subtype = TISCI_RESASG_SUBTYPE_IR_OUTPUT;
7009af70: f88d 0052    	strb.w	r0, [sp, #0x52]
7009af74: a812         	add	r0, sp, #0x48
7009af76: a90e         	add	r1, sp, #0x38
7009af78: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &host_resp,
7009af7c: f010 fa78    	bl	0x700ab470 <Sciclient_rmGetResourceRange> @ imm = #0x104f0
7009af80: b120         	cbz	r0, 0x7009af8c <Sciclient_rmIrqRouteValidate+0x46c> @ imm = #0x8
7009af82: e7ff         	b	0x7009af84 <Sciclient_rmIrqRouteValidate+0x464> @ imm = #-0x2
7009af84: 2000         	movs	r0, #0x0
;                 valid = false;
7009af86: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009af8a: e0bd         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x17a
7009af8c: 2080         	movs	r0, #0x80
;             req.secondary_host = TISCI_HOST_ID_ALL;
7009af8e: f88d 0053    	strb.w	r0, [sp, #0x53]
7009af92: a812         	add	r0, sp, #0x48
7009af94: a90a         	add	r1, sp, #0x28
7009af96: f04f 32ff    	mov.w	r2, #0xffffffff
;             if (Sciclient_rmGetResourceRange(&req, &all_resp,
7009af9a: f010 fa69    	bl	0x700ab470 <Sciclient_rmGetResourceRange> @ imm = #0x104d2
7009af9e: b120         	cbz	r0, 0x7009afaa <Sciclient_rmIrqRouteValidate+0x48a> @ imm = #0x8
7009afa0: e7ff         	b	0x7009afa2 <Sciclient_rmIrqRouteValidate+0x482> @ imm = #-0x2
7009afa2: 2000         	movs	r0, #0x0
;                 valid = false;
7009afa4: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009afa8: e0ae         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x15c
;             cur_outp = SCICLIENT_INP_TO_OUTP(cfg->d_irq,
7009afaa: 9a18         	ldr	r2, [sp, #0x60]
7009afac: 8810         	ldrh	r0, [r2]
7009afae: 991d         	ldr	r1, [sp, #0x74]
7009afb0: 8989         	ldrh	r1, [r1, #0xc]
7009afb2: 8852         	ldrh	r2, [r2, #0x2]
7009afb4: 1a89         	subs	r1, r1, r2
7009afb6: 4408         	add	r0, r1
7009afb8: f8ad 0056    	strh.w	r0, [sp, #0x56]
;             if ((((cur_outp >= host_resp.range_start) &&
7009afbc: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009afc0: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009afc4: 4288         	cmp	r0, r1
7009afc6: db0a         	blt	0x7009afde <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #0x14
7009afc8: e7ff         	b	0x7009afca <Sciclient_rmIrqRouteValidate+0x4aa> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start + host_resp.range_num)) ||
7009afca: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009afce: f8bd 1040    	ldrh.w	r1, [sp, #0x40]
7009afd2: f8bd 2042    	ldrh.w	r2, [sp, #0x42]
7009afd6: 4411         	add	r1, r2
7009afd8: 4288         	cmp	r0, r1
7009afda: db33         	blt	0x7009b044 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x66
7009afdc: e7ff         	b	0x7009afde <Sciclient_rmIrqRouteValidate+0x4be> @ imm = #-0x2
;                  ((cur_outp >= host_resp.range_start_sec) &&
7009afde: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009afe2: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
7009afe6: 4288         	cmp	r0, r1
7009afe8: db0a         	blt	0x7009b000 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #0x14
7009afea: e7ff         	b	0x7009afec <Sciclient_rmIrqRouteValidate+0x4cc> @ imm = #-0x2
;                   (cur_outp < host_resp.range_start_sec +
7009afec: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009aff0: f8bd 1044    	ldrh.w	r1, [sp, #0x44]
;                               host_resp.range_num_sec))) ||
7009aff4: f8bd 2046    	ldrh.w	r2, [sp, #0x46]
;                   (cur_outp < host_resp.range_start_sec +
7009aff8: 4411         	add	r1, r2
;                               host_resp.range_num_sec))) ||
7009affa: 4288         	cmp	r0, r1
7009affc: db22         	blt	0x7009b044 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x44
7009affe: e7ff         	b	0x7009b000 <Sciclient_rmIrqRouteValidate+0x4e0> @ imm = #-0x2
;                 (((cur_outp >= all_resp.range_start) &&
7009b000: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009b004: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009b008: 4288         	cmp	r0, r1
7009b00a: db0a         	blt	0x7009b022 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #0x14
7009b00c: e7ff         	b	0x7009b00e <Sciclient_rmIrqRouteValidate+0x4ee> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start + all_resp.range_num)) ||
7009b00e: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009b012: f8bd 1030    	ldrh.w	r1, [sp, #0x30]
7009b016: f8bd 2032    	ldrh.w	r2, [sp, #0x32]
7009b01a: 4411         	add	r1, r2
7009b01c: 4288         	cmp	r0, r1
7009b01e: db11         	blt	0x7009b044 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #0x22
7009b020: e7ff         	b	0x7009b022 <Sciclient_rmIrqRouteValidate+0x502> @ imm = #-0x2
;                  ((cur_outp >= all_resp.range_start_sec) &&
7009b022: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009b026: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
7009b02a: 4288         	cmp	r0, r1
7009b02c: db2f         	blt	0x7009b08e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x5e
7009b02e: e7ff         	b	0x7009b030 <Sciclient_rmIrqRouteValidate+0x510> @ imm = #-0x2
;                   (cur_outp < all_resp.range_start_sec +
7009b030: f8bd 0056    	ldrh.w	r0, [sp, #0x56]
7009b034: f8bd 1034    	ldrh.w	r1, [sp, #0x34]
;                               all_resp.range_num_sec)))) {
7009b038: f8bd 2036    	ldrh.w	r2, [sp, #0x36]
;                   (cur_outp < all_resp.range_start_sec +
7009b03c: 4411         	add	r1, r2
;             if ((((cur_outp >= host_resp.range_start) &&
7009b03e: 4288         	cmp	r0, r1
7009b040: da25         	bge	0x7009b08e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #0x4a
7009b042: e7ff         	b	0x7009b044 <Sciclient_rmIrqRouteValidate+0x524> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
7009b044: 9818         	ldr	r0, [sp, #0x60]
7009b046: 88c0         	ldrh	r0, [r0, #0x6]
7009b048: 991d         	ldr	r1, [sp, #0x74]
7009b04a: 8949         	ldrh	r1, [r1, #0xa]
7009b04c: 4288         	cmp	r0, r1
7009b04e: d11d         	bne	0x7009b08c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x3a
7009b050: e7ff         	b	0x7009b052 <Sciclient_rmIrqRouteValidate+0x532> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
7009b052: 981d         	ldr	r0, [sp, #0x74]
7009b054: 8980         	ldrh	r0, [r0, #0xc]
7009b056: 9918         	ldr	r1, [sp, #0x60]
7009b058: 8849         	ldrh	r1, [r1, #0x2]
7009b05a: 4288         	cmp	r0, r1
7009b05c: db16         	blt	0x7009b08c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x2c
7009b05e: e7ff         	b	0x7009b060 <Sciclient_rmIrqRouteValidate+0x540> @ imm = #-0x2
;                     (cfg->d_irq < (cur_if->rbase + cur_if->len))) {
7009b060: 981d         	ldr	r0, [sp, #0x74]
7009b062: 8980         	ldrh	r0, [r0, #0xc]
7009b064: 9a18         	ldr	r2, [sp, #0x60]
7009b066: 8851         	ldrh	r1, [r2, #0x2]
7009b068: 8892         	ldrh	r2, [r2, #0x4]
7009b06a: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
7009b06c: 4288         	cmp	r0, r1
7009b06e: da0d         	bge	0x7009b08c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #0x1a
7009b070: e7ff         	b	0x7009b072 <Sciclient_rmIrqRouteValidate+0x552> @ imm = #-0x2
;                     if (Sciclient_rmIrOutpIsFree(cur_n->id, cur_outp) ==
7009b072: 981a         	ldr	r0, [sp, #0x68]
7009b074: 8800         	ldrh	r0, [r0]
7009b076: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009b07a: f00e f859    	bl	0x700a9130 <Sciclient_rmIrOutpIsFree> @ imm = #0xe0b2
7009b07e: b920         	cbnz	r0, 0x7009b08a <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #0x8
7009b080: e7ff         	b	0x7009b082 <Sciclient_rmIrqRouteValidate+0x562> @ imm = #-0x2
7009b082: 2001         	movs	r0, #0x1
;                         cur_outp_valid = true;
7009b084: f88d 005f    	strb.w	r0, [sp, #0x5f]
;                     }
7009b088: e7ff         	b	0x7009b08a <Sciclient_rmIrqRouteValidate+0x56a> @ imm = #-0x2
;                 }
7009b08a: e7ff         	b	0x7009b08c <Sciclient_rmIrqRouteValidate+0x56c> @ imm = #-0x2
; 	    }
7009b08c: e7ff         	b	0x7009b08e <Sciclient_rmIrqRouteValidate+0x56e> @ imm = #-0x2
;         }
7009b08e: e7ff         	b	0x7009b090 <Sciclient_rmIrqRouteValidate+0x570> @ imm = #-0x2
;         if ((cur_outp_valid == true) && (next_inp_valid == true)) {
7009b090: f89d 005f    	ldrb.w	r0, [sp, #0x5f]
7009b094: 07c0         	lsls	r0, r0, #0x1f
7009b096: b360         	cbz	r0, 0x7009b0f2 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x58
7009b098: e7ff         	b	0x7009b09a <Sciclient_rmIrqRouteValidate+0x57a> @ imm = #-0x2
7009b09a: f89d 005e    	ldrb.w	r0, [sp, #0x5e]
7009b09e: 07c0         	lsls	r0, r0, #0x1f
7009b0a0: b338         	cbz	r0, 0x7009b0f2 <Sciclient_rmIrqRouteValidate+0x5d2> @ imm = #0x4e
7009b0a2: e7ff         	b	0x7009b0a4 <Sciclient_rmIrqRouteValidate+0x584> @ imm = #-0x2
;             if (i < (Sciclient_rmPsGetPsp() - (1u))) {
7009b0a4: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b0a8: 9000         	str	r0, [sp]
7009b0aa: f014 fde9    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0x14bd2
7009b0ae: 4601         	mov	r1, r0
7009b0b0: 9800         	ldr	r0, [sp]
7009b0b2: 3901         	subs	r1, #0x1
7009b0b4: 4288         	cmp	r0, r1
7009b0b6: d20f         	bhs	0x7009b0d8 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #0x1e
7009b0b8: e7ff         	b	0x7009b0ba <Sciclient_rmIrqRouteValidate+0x59a> @ imm = #-0x2
;                 if (Sciclient_rmPsSetInp(i + (1u), next_inp) != SystemP_SUCCESS) {
7009b0ba: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b0be: 3001         	adds	r0, #0x1
7009b0c0: f8bd 1054    	ldrh.w	r1, [sp, #0x54]
7009b0c4: b280         	uxth	r0, r0
7009b0c6: f012 f923    	bl	0x700ad310 <Sciclient_rmPsSetInp> @ imm = #0x12246
7009b0ca: b120         	cbz	r0, 0x7009b0d6 <Sciclient_rmIrqRouteValidate+0x5b6> @ imm = #0x8
7009b0cc: e7ff         	b	0x7009b0ce <Sciclient_rmIrqRouteValidate+0x5ae> @ imm = #-0x2
7009b0ce: 2000         	movs	r0, #0x0
;                     valid = false;
7009b0d0: f88d 0073    	strb.w	r0, [sp, #0x73]
;                     break;
7009b0d4: e018         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x30
;             }
7009b0d6: e7ff         	b	0x7009b0d8 <Sciclient_rmIrqRouteValidate+0x5b8> @ imm = #-0x2
;             if (Sciclient_rmPsSetOutp(i, cur_outp) != SystemP_SUCCESS) {
7009b0d8: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b0dc: f8bd 1056    	ldrh.w	r1, [sp, #0x56]
7009b0e0: f012 f93e    	bl	0x700ad360 <Sciclient_rmPsSetOutp> @ imm = #0x1227c
7009b0e4: b120         	cbz	r0, 0x7009b0f0 <Sciclient_rmIrqRouteValidate+0x5d0> @ imm = #0x8
7009b0e6: e7ff         	b	0x7009b0e8 <Sciclient_rmIrqRouteValidate+0x5c8> @ imm = #-0x2
7009b0e8: 2000         	movs	r0, #0x0
;                 valid = false;
7009b0ea: f88d 0073    	strb.w	r0, [sp, #0x73]
;                 break;
7009b0ee: e00b         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0x16
;         } else {
7009b0f0: e003         	b	0x7009b0fa <Sciclient_rmIrqRouteValidate+0x5da> @ imm = #0x6
7009b0f2: 2000         	movs	r0, #0x0
;             valid = false;
7009b0f4: f88d 0073    	strb.w	r0, [sp, #0x73]
;             break;
7009b0f8: e006         	b	0x7009b108 <Sciclient_rmIrqRouteValidate+0x5e8> @ imm = #0xc
;     }
7009b0fa: e7ff         	b	0x7009b0fc <Sciclient_rmIrqRouteValidate+0x5dc> @ imm = #-0x2
;     for (i = 0u; (i < Sciclient_rmPsGetPsp()) && (valid == true); i++) {
7009b0fc: f8bd 0070    	ldrh.w	r0, [sp, #0x70]
7009b100: 3001         	adds	r0, #0x1
7009b102: f8ad 0070    	strh.w	r0, [sp, #0x70]
7009b106: e579         	b	0x7009abfc <Sciclient_rmIrqRouteValidate+0xdc> @ imm = #-0x50e
;     return valid;
7009b108: f89d 0073    	ldrb.w	r0, [sp, #0x73]
7009b10c: f000 0001    	and	r0, r0, #0x1
7009b110: b01e         	add	sp, #0x78
7009b112: bd80         	pop	{r7, pc}

7009b114 <__aeabi_memclr8>:
7009b114: e1a02001     	mov	r2, r1
7009b118: e3b01000     	movs	r1, #0
7009b11c: ea005195     	b	0x700af778 <TI_memset_small> @ imm = #0x14654

7009b120 <_ftoa>:
; {
7009b120: b570         	push	{r4, r5, r6, lr}
7009b122: b0a2         	sub	sp, #0x88
7009b124: f8dd c0a0    	ldr.w	r12, [sp, #0xa0]
7009b128: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009b12c: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b130: 9020         	str	r0, [sp, #0x80]
7009b132: 911f         	str	r1, [sp, #0x7c]
7009b134: 921e         	str	r2, [sp, #0x78]
7009b136: 931d         	str	r3, [sp, #0x74]
7009b138: ed8d 0b1a    	vstr	d0, [sp, #104]
7009b13c: 2000         	movs	r0, #0x0
;   size_t len  = 0U;
7009b13e: 9011         	str	r0, [sp, #0x44]
;   double diff = 0.0;
7009b140: 900f         	str	r0, [sp, #0x3c]
7009b142: 900e         	str	r0, [sp, #0x38]
;   if (value != value)
7009b144: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b148: eeb4 0b40    	vcmp.f64	d0, d0
7009b14c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b150: d71a         	bvc	0x7009b188 <_ftoa+0x68> @ imm = #0x34
7009b152: e7ff         	b	0x7009b154 <_ftoa+0x34> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
7009b154: 9820         	ldr	r0, [sp, #0x80]
7009b156: 991f         	ldr	r1, [sp, #0x7c]
7009b158: 9a1e         	ldr	r2, [sp, #0x78]
7009b15a: 9b1d         	ldr	r3, [sp, #0x74]
7009b15c: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009b160: 9c28         	ldr	r4, [sp, #0xa0]
7009b162: 46ee         	mov	lr, sp
7009b164: f8ce 400c    	str.w	r4, [lr, #0xc]
7009b168: f8ce c008    	str.w	r12, [lr, #0x8]
7009b16c: f04f 0c03    	mov.w	r12, #0x3
7009b170: f8ce c004    	str.w	r12, [lr, #0x4]
7009b174: f242 6c38    	movw	r12, #0x2638
7009b178: f2c7 0c0b    	movt	r12, #0x700b
7009b17c: f8ce c000    	str.w	r12, [lr]
7009b180: f00c fa7e    	bl	0x700a7680 <_out_rev>   @ imm = #0xc4fc
7009b184: 9021         	str	r0, [sp, #0x84]
7009b186: e257         	b	0x7009b638 <_ftoa+0x518> @ imm = #0x4ae
;   if (value < -DBL_MAX)
7009b188: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b18c: ed9f 1bd2    	vldr	d1, [pc, #840]          @ 0x7009b4d8 <_ftoa+0x3b8>
7009b190: eeb4 0b41    	vcmp.f64	d0, d1
7009b194: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b198: d51a         	bpl	0x7009b1d0 <_ftoa+0xb0> @ imm = #0x34
7009b19a: e7ff         	b	0x7009b19c <_ftoa+0x7c> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
7009b19c: 9820         	ldr	r0, [sp, #0x80]
7009b19e: 991f         	ldr	r1, [sp, #0x7c]
7009b1a0: 9a1e         	ldr	r2, [sp, #0x78]
7009b1a2: 9b1d         	ldr	r3, [sp, #0x74]
7009b1a4: f8dd c09c    	ldr.w	r12, [sp, #0x9c]
7009b1a8: 9c28         	ldr	r4, [sp, #0xa0]
7009b1aa: 46ee         	mov	lr, sp
7009b1ac: f8ce 400c    	str.w	r4, [lr, #0xc]
7009b1b0: f8ce c008    	str.w	r12, [lr, #0x8]
7009b1b4: f04f 0c04    	mov.w	r12, #0x4
7009b1b8: f8ce c004    	str.w	r12, [lr, #0x4]
7009b1bc: f242 6c11    	movw	r12, #0x2611
7009b1c0: f2c7 0c0b    	movt	r12, #0x700b
7009b1c4: f8ce c000    	str.w	r12, [lr]
7009b1c8: f00c fa5a    	bl	0x700a7680 <_out_rev>   @ imm = #0xc4b4
7009b1cc: 9021         	str	r0, [sp, #0x84]
7009b1ce: e233         	b	0x7009b638 <_ftoa+0x518> @ imm = #0x466
;   if (value > DBL_MAX)
7009b1d0: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b1d4: ed9f 1bc2    	vldr	d1, [pc, #776]          @ 0x7009b4e0 <_ftoa+0x3c0>
7009b1d8: eeb4 0b41    	vcmp.f64	d0, d1
7009b1dc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b1e0: dd26         	ble	0x7009b230 <_ftoa+0x110> @ imm = #0x4c
7009b1e2: e7ff         	b	0x7009b1e4 <_ftoa+0xc4> @ imm = #-0x2
;     return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
7009b1e4: 9820         	ldr	r0, [sp, #0x80]
7009b1e6: 991f         	ldr	r1, [sp, #0x7c]
7009b1e8: 9a1e         	ldr	r2, [sp, #0x78]
7009b1ea: 9b1d         	ldr	r3, [sp, #0x74]
7009b1ec: 9e28         	ldr	r6, [sp, #0xa0]
7009b1ee: f006 0e04    	and	lr, r6, #0x4
7009b1f2: f242 641b    	movw	r4, #0x261b
7009b1f6: f2c7 040b    	movt	r4, #0x700b
7009b1fa: f242 6c34    	movw	r12, #0x2634
7009b1fe: f2c7 0c0b    	movt	r12, #0x700b
7009b202: f1be 0f00    	cmp.w	lr, #0x0
7009b206: bf18         	it	ne
7009b208: 46a4         	movne	r12, r4
7009b20a: 2403         	movs	r4, #0x3
7009b20c: f1be 0f00    	cmp.w	lr, #0x0
7009b210: bf18         	it	ne
7009b212: 2404         	movne	r4, #0x4
7009b214: 9d27         	ldr	r5, [sp, #0x9c]
7009b216: 46ee         	mov	lr, sp
7009b218: f8ce 600c    	str.w	r6, [lr, #0xc]
7009b21c: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b220: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b224: f8ce c000    	str.w	r12, [lr]
7009b228: f00c fa2a    	bl	0x700a7680 <_out_rev>   @ imm = #0xc454
7009b22c: 9021         	str	r0, [sp, #0x84]
7009b22e: e203         	b	0x7009b638 <_ftoa+0x518> @ imm = #0x406
;   if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
7009b230: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b234: ed9f 1bac    	vldr	d1, [pc, #688]          @ 0x7009b4e8 <_ftoa+0x3c8>
7009b238: eeb4 0b41    	vcmp.f64	d0, d1
7009b23c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b240: dc0a         	bgt	0x7009b258 <_ftoa+0x138> @ imm = #0x14
7009b242: e7ff         	b	0x7009b244 <_ftoa+0x124> @ imm = #-0x2
7009b244: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b248: ed9f 1ba9    	vldr	d1, [pc, #676]          @ 0x7009b4f0 <_ftoa+0x3d0>
7009b24c: eeb4 0b41    	vcmp.f64	d0, d1
7009b250: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b254: d515         	bpl	0x7009b282 <_ftoa+0x162> @ imm = #0x2a
7009b256: e7ff         	b	0x7009b258 <_ftoa+0x138> @ imm = #-0x2
;     return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009b258: 9820         	ldr	r0, [sp, #0x80]
7009b25a: 991f         	ldr	r1, [sp, #0x7c]
7009b25c: 9a1e         	ldr	r2, [sp, #0x78]
7009b25e: 9b1d         	ldr	r3, [sp, #0x74]
7009b260: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b264: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b268: 9c27         	ldr	r4, [sp, #0x9c]
7009b26a: 9d28         	ldr	r5, [sp, #0xa0]
7009b26c: 46ee         	mov	lr, sp
7009b26e: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b272: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b276: f8ce c000    	str.w	r12, [lr]
7009b27a: f000 f9e1    	bl	0x7009b640 <_etoa>      @ imm = #0x3c2
7009b27e: 9021         	str	r0, [sp, #0x84]
7009b280: e1da         	b	0x7009b638 <_ftoa+0x518> @ imm = #0x3b4
7009b282: f04f 0000    	mov.w	r0, #0x0
;   bool negative = false;
7009b286: f88d 0037    	strb.w	r0, [sp, #0x37]
;   if (value < 0) {
7009b28a: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b28e: eeb5 0b40    	vcmp.f64	d0, #0
7009b292: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b296: d50d         	bpl	0x7009b2b4 <_ftoa+0x194> @ imm = #0x1a
7009b298: e7ff         	b	0x7009b29a <_ftoa+0x17a> @ imm = #-0x2
7009b29a: f04f 0001    	mov.w	r0, #0x1
;     negative = true;
7009b29e: f88d 0037    	strb.w	r0, [sp, #0x37]
;     value = 0 - value;
7009b2a2: ed9d 1b1a    	vldr	d1, [sp, #104]
7009b2a6: ed9f 0b94    	vldr	d0, [pc, #592]          @ 0x7009b4f8 <_ftoa+0x3d8>
7009b2aa: ee30 0b41    	vsub.f64	d0, d0, d1
7009b2ae: ed8d 0b1a    	vstr	d0, [sp, #104]
;   }
7009b2b2: e7ff         	b	0x7009b2b4 <_ftoa+0x194> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009b2b4: f89d 00a1    	ldrb.w	r0, [sp, #0xa1]
7009b2b8: ea4f 7040    	lsl.w	r0, r0, #0x1d
7009b2bc: 2800         	cmp	r0, #0x0
7009b2be: d403         	bmi	0x7009b2c8 <_ftoa+0x1a8> @ imm = #0x6
7009b2c0: e7ff         	b	0x7009b2c2 <_ftoa+0x1a2> @ imm = #-0x2
7009b2c2: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009b2c4: 9026         	str	r0, [sp, #0x98]
;   }
7009b2c6: e7ff         	b	0x7009b2c8 <_ftoa+0x1a8> @ imm = #-0x2
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b2c8: e7ff         	b	0x7009b2ca <_ftoa+0x1aa> @ imm = #-0x2
7009b2ca: 9911         	ldr	r1, [sp, #0x44]
7009b2cc: 2000         	movs	r0, #0x0
7009b2ce: 291f         	cmp	r1, #0x1f
7009b2d0: 9007         	str	r0, [sp, #0x1c]
7009b2d2: d807         	bhi	0x7009b2e4 <_ftoa+0x1c4> @ imm = #0xe
7009b2d4: e7ff         	b	0x7009b2d6 <_ftoa+0x1b6> @ imm = #-0x2
7009b2d6: 9926         	ldr	r1, [sp, #0x98]
7009b2d8: 2000         	movs	r0, #0x0
7009b2da: 2909         	cmp	r1, #0x9
7009b2dc: bf88         	it	hi
7009b2de: 2001         	movhi	r0, #0x1
7009b2e0: 9007         	str	r0, [sp, #0x1c]
7009b2e2: e7ff         	b	0x7009b2e4 <_ftoa+0x1c4> @ imm = #-0x2
7009b2e4: 9807         	ldr	r0, [sp, #0x1c]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b2e6: 07c0         	lsls	r0, r0, #0x1f
7009b2e8: b150         	cbz	r0, 0x7009b300 <_ftoa+0x1e0> @ imm = #0x14
7009b2ea: e7ff         	b	0x7009b2ec <_ftoa+0x1cc> @ imm = #-0x2
;     buf[len++] = '0';
7009b2ec: 9a11         	ldr	r2, [sp, #0x44]
7009b2ee: 1c50         	adds	r0, r2, #0x1
7009b2f0: 9011         	str	r0, [sp, #0x44]
7009b2f2: a912         	add	r1, sp, #0x48
7009b2f4: 2030         	movs	r0, #0x30
7009b2f6: 5488         	strb	r0, [r1, r2]
;     prec--;
7009b2f8: 9826         	ldr	r0, [sp, #0x98]
7009b2fa: 3801         	subs	r0, #0x1
7009b2fc: 9026         	str	r0, [sp, #0x98]
;   while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
7009b2fe: e7e4         	b	0x7009b2ca <_ftoa+0x1aa> @ imm = #-0x38
;   int whole = (int)value;
7009b300: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b304: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b308: ed8d 0a0c    	vstr	s0, [sp, #48]
;   double tmp = (value - whole) * pow10[prec];
7009b30c: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b310: ed9d 1a0c    	vldr	s2, [sp, #48]
7009b314: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b318: ee30 0b41    	vsub.f64	d0, d0, d1
7009b31c: 9926         	ldr	r1, [sp, #0x98]
7009b31e: f641 1020    	movw	r0, #0x1920
7009b322: f2c7 000b    	movt	r0, #0x700b
7009b326: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009b32a: ed90 1b00    	vldr	d1, [r0]
7009b32e: ee20 0b01    	vmul.f64	d0, d0, d1
7009b332: ed8d 0b0a    	vstr	d0, [sp, #40]
;   unsigned long frac = (unsigned long)tmp;
7009b336: ed9d 0b0a    	vldr	d0, [sp, #40]
7009b33a: eebc 0bc0    	vcvt.u32.f64	s0, d0
7009b33e: ed8d 0a09    	vstr	s0, [sp, #36]
;   diff = tmp - frac;
7009b342: ed9d 0b0a    	vldr	d0, [sp, #40]
7009b346: ed9d 1a09    	vldr	s2, [sp, #36]
7009b34a: eeb8 1b41    	vcvt.f64.u32	d1, s2
7009b34e: ee30 0b41    	vsub.f64	d0, d0, d1
7009b352: ed8d 0b0e    	vstr	d0, [sp, #56]
;   if (diff > 0.5) {
7009b356: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b35a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b35e: eeb4 0b41    	vcmp.f64	d0, d1
7009b362: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b366: dd1e         	ble	0x7009b3a6 <_ftoa+0x286> @ imm = #0x3c
7009b368: e7ff         	b	0x7009b36a <_ftoa+0x24a> @ imm = #-0x2
;     ++frac;
7009b36a: 9809         	ldr	r0, [sp, #0x24]
7009b36c: 3001         	adds	r0, #0x1
7009b36e: 9009         	str	r0, [sp, #0x24]
;     if (frac >= pow10[prec]) {
7009b370: ed9d 0a09    	vldr	s0, [sp, #36]
7009b374: eeb8 0b40    	vcvt.f64.u32	d0, s0
7009b378: 9926         	ldr	r1, [sp, #0x98]
7009b37a: f641 1020    	movw	r0, #0x1920
7009b37e: f2c7 000b    	movt	r0, #0x700b
7009b382: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009b386: ed90 1b00    	vldr	d1, [r0]
7009b38a: eeb4 0b41    	vcmp.f64	d0, d1
7009b38e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b392: db07         	blt	0x7009b3a4 <_ftoa+0x284> @ imm = #0xe
7009b394: e7ff         	b	0x7009b396 <_ftoa+0x276> @ imm = #-0x2
7009b396: f04f 0000    	mov.w	r0, #0x0
;       frac = 0;
7009b39a: 9009         	str	r0, [sp, #0x24]
;       ++whole;
7009b39c: 980c         	ldr	r0, [sp, #0x30]
7009b39e: 3001         	adds	r0, #0x1
7009b3a0: 900c         	str	r0, [sp, #0x30]
;     }
7009b3a2: e7ff         	b	0x7009b3a4 <_ftoa+0x284> @ imm = #-0x2
;   }
7009b3a4: e018         	b	0x7009b3d8 <_ftoa+0x2b8> @ imm = #0x30
;   else if (diff < 0.5) {
7009b3a6: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b3aa: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b3ae: eeb4 0b41    	vcmp.f64	d0, d1
7009b3b2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b3b6: d501         	bpl	0x7009b3bc <_ftoa+0x29c> @ imm = #0x2
7009b3b8: e7ff         	b	0x7009b3ba <_ftoa+0x29a> @ imm = #-0x2
;   }
7009b3ba: e00c         	b	0x7009b3d6 <_ftoa+0x2b6> @ imm = #0x18
;   else if ((frac == 0U) || (frac & 1U)) {
7009b3bc: 9809         	ldr	r0, [sp, #0x24]
7009b3be: b128         	cbz	r0, 0x7009b3cc <_ftoa+0x2ac> @ imm = #0xa
7009b3c0: e7ff         	b	0x7009b3c2 <_ftoa+0x2a2> @ imm = #-0x2
7009b3c2: f89d 0024    	ldrb.w	r0, [sp, #0x24]
7009b3c6: 07c0         	lsls	r0, r0, #0x1f
7009b3c8: b120         	cbz	r0, 0x7009b3d4 <_ftoa+0x2b4> @ imm = #0x8
7009b3ca: e7ff         	b	0x7009b3cc <_ftoa+0x2ac> @ imm = #-0x2
;     ++frac;
7009b3cc: 9809         	ldr	r0, [sp, #0x24]
7009b3ce: 3001         	adds	r0, #0x1
7009b3d0: 9009         	str	r0, [sp, #0x24]
;   }
7009b3d2: e7ff         	b	0x7009b3d4 <_ftoa+0x2b4> @ imm = #-0x2
7009b3d4: e7ff         	b	0x7009b3d6 <_ftoa+0x2b6> @ imm = #-0x2
7009b3d6: e7ff         	b	0x7009b3d8 <_ftoa+0x2b8> @ imm = #-0x2
;   if (prec == 0U) {
7009b3d8: 9826         	ldr	r0, [sp, #0x98]
7009b3da: bb48         	cbnz	r0, 0x7009b430 <_ftoa+0x310> @ imm = #0x52
7009b3dc: e7ff         	b	0x7009b3de <_ftoa+0x2be> @ imm = #-0x2
;     diff = value - (double)whole;
7009b3de: ed9d 0b1a    	vldr	d0, [sp, #104]
7009b3e2: ed9d 1a0c    	vldr	s2, [sp, #48]
7009b3e6: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b3ea: ee30 0b41    	vsub.f64	d0, d0, d1
7009b3ee: ed8d 0b0e    	vstr	d0, [sp, #56]
;     if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
7009b3f2: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b3f6: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b3fa: eeb4 0b41    	vcmp.f64	d0, d1
7009b3fe: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b402: d50a         	bpl	0x7009b41a <_ftoa+0x2fa> @ imm = #0x14
7009b404: e7ff         	b	0x7009b406 <_ftoa+0x2e6> @ imm = #-0x2
7009b406: ed9d 0b0e    	vldr	d0, [sp, #56]
7009b40a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b40e: eeb4 0b41    	vcmp.f64	d0, d1
7009b412: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b416: dd0a         	ble	0x7009b42e <_ftoa+0x30e> @ imm = #0x14
7009b418: e7ff         	b	0x7009b41a <_ftoa+0x2fa> @ imm = #-0x2
7009b41a: f89d 0030    	ldrb.w	r0, [sp, #0x30]
7009b41e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009b422: b120         	cbz	r0, 0x7009b42e <_ftoa+0x30e> @ imm = #0x8
7009b424: e7ff         	b	0x7009b426 <_ftoa+0x306> @ imm = #-0x2
;       ++whole;
7009b426: 980c         	ldr	r0, [sp, #0x30]
7009b428: 3001         	adds	r0, #0x1
7009b42a: 900c         	str	r0, [sp, #0x30]
;     }
7009b42c: e7ff         	b	0x7009b42e <_ftoa+0x30e> @ imm = #-0x2
;   }
7009b42e: e04d         	b	0x7009b4cc <_ftoa+0x3ac> @ imm = #0x9a
;     unsigned int count = prec;
7009b430: 9826         	ldr	r0, [sp, #0x98]
7009b432: 9008         	str	r0, [sp, #0x20]
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b434: e7ff         	b	0x7009b436 <_ftoa+0x316> @ imm = #-0x2
7009b436: 9811         	ldr	r0, [sp, #0x44]
7009b438: 281f         	cmp	r0, #0x1f
7009b43a: d821         	bhi	0x7009b480 <_ftoa+0x360> @ imm = #0x42
7009b43c: e7ff         	b	0x7009b43e <_ftoa+0x31e> @ imm = #-0x2
;       --count;
7009b43e: 9808         	ldr	r0, [sp, #0x20]
7009b440: 3801         	subs	r0, #0x1
7009b442: 9008         	str	r0, [sp, #0x20]
;       buf[len++] = (char)(48U + (frac % 10U));
7009b444: 9809         	ldr	r0, [sp, #0x24]
7009b446: f64c 41cd    	movw	r1, #0xcccd
7009b44a: f6cc 41cc    	movt	r1, #0xcccc
7009b44e: fba0 3201    	umull	r3, r2, r0, r1
7009b452: ea4f 02d2    	lsr.w	r2, r2, #0x3
7009b456: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009b45a: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009b45e: f040 0030    	orr	r0, r0, #0x30
7009b462: 9b11         	ldr	r3, [sp, #0x44]
7009b464: 1c5a         	adds	r2, r3, #0x1
7009b466: 9211         	str	r2, [sp, #0x44]
7009b468: aa12         	add	r2, sp, #0x48
7009b46a: 54d0         	strb	r0, [r2, r3]
;       if (!(frac /= 10U)) {
7009b46c: 9809         	ldr	r0, [sp, #0x24]
7009b46e: fba0 1001    	umull	r1, r0, r0, r1
7009b472: ea4f 00d0    	lsr.w	r0, r0, #0x3
7009b476: 9009         	str	r0, [sp, #0x24]
7009b478: b908         	cbnz	r0, 0x7009b47e <_ftoa+0x35e> @ imm = #0x2
7009b47a: e7ff         	b	0x7009b47c <_ftoa+0x35c> @ imm = #-0x2
;         break;
7009b47c: e000         	b	0x7009b480 <_ftoa+0x360> @ imm = #0x0
;     while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b47e: e7da         	b	0x7009b436 <_ftoa+0x316> @ imm = #-0x4c
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b480: e7ff         	b	0x7009b482 <_ftoa+0x362> @ imm = #-0x2
7009b482: 9911         	ldr	r1, [sp, #0x44]
7009b484: 2000         	movs	r0, #0x0
7009b486: 291f         	cmp	r1, #0x1f
7009b488: 9006         	str	r0, [sp, #0x18]
7009b48a: d808         	bhi	0x7009b49e <_ftoa+0x37e> @ imm = #0x10
7009b48c: e7ff         	b	0x7009b48e <_ftoa+0x36e> @ imm = #-0x2
7009b48e: 9808         	ldr	r0, [sp, #0x20]
7009b490: 1e41         	subs	r1, r0, #0x1
7009b492: 9108         	str	r1, [sp, #0x20]
7009b494: 2800         	cmp	r0, #0x0
7009b496: bf18         	it	ne
7009b498: 2001         	movne	r0, #0x1
7009b49a: 9006         	str	r0, [sp, #0x18]
7009b49c: e7ff         	b	0x7009b49e <_ftoa+0x37e> @ imm = #-0x2
7009b49e: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b4a0: 07c0         	lsls	r0, r0, #0x1f
7009b4a2: b138         	cbz	r0, 0x7009b4b4 <_ftoa+0x394> @ imm = #0xe
7009b4a4: e7ff         	b	0x7009b4a6 <_ftoa+0x386> @ imm = #-0x2
;       buf[len++] = '0';
7009b4a6: 9a11         	ldr	r2, [sp, #0x44]
7009b4a8: 1c50         	adds	r0, r2, #0x1
7009b4aa: 9011         	str	r0, [sp, #0x44]
7009b4ac: a912         	add	r1, sp, #0x48
7009b4ae: 2030         	movs	r0, #0x30
7009b4b0: 5488         	strb	r0, [r1, r2]
;     while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
7009b4b2: e7e6         	b	0x7009b482 <_ftoa+0x362> @ imm = #-0x34
;     if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b4b4: 9811         	ldr	r0, [sp, #0x44]
7009b4b6: 281f         	cmp	r0, #0x1f
7009b4b8: d807         	bhi	0x7009b4ca <_ftoa+0x3aa> @ imm = #0xe
7009b4ba: e7ff         	b	0x7009b4bc <_ftoa+0x39c> @ imm = #-0x2
;       buf[len++] = '.';
7009b4bc: 9a11         	ldr	r2, [sp, #0x44]
7009b4be: 1c50         	adds	r0, r2, #0x1
7009b4c0: 9011         	str	r0, [sp, #0x44]
7009b4c2: a912         	add	r1, sp, #0x48
7009b4c4: 202e         	movs	r0, #0x2e
7009b4c6: 5488         	strb	r0, [r1, r2]
;     }
7009b4c8: e7ff         	b	0x7009b4ca <_ftoa+0x3aa> @ imm = #-0x2
7009b4ca: e7ff         	b	0x7009b4cc <_ftoa+0x3ac> @ imm = #-0x2
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b4cc: e7ff         	b	0x7009b4ce <_ftoa+0x3ae> @ imm = #-0x2
7009b4ce: 9811         	ldr	r0, [sp, #0x44]
7009b4d0: 281f         	cmp	r0, #0x1f
7009b4d2: d835         	bhi	0x7009b540 <_ftoa+0x420> @ imm = #0x6a
7009b4d4: e014         	b	0x7009b500 <_ftoa+0x3e0> @ imm = #0x28
7009b4d6: bf00         	nop
7009b4d8: ff ff ff ff  	.word	0xffffffff
7009b4dc: ff ff ef ff  	.word	0xffefffff
7009b4e0: ff ff ff ff  	.word	0xffffffff
7009b4e4: ff ff ef 7f  	.word	0x7fefffff
7009b4e8: 00 00 00 00  	.word	0x00000000
7009b4ec: 65 cd cd 41  	.word	0x41cdcd65
7009b4f0: 00 00 00 00  	.word	0x00000000
7009b4f4: 65 cd cd c1  	.word	0xc1cdcd65
7009b4f8: 00 00 00 00  	.word	0x00000000
7009b4fc: 00 00 00 00  	.word	0x00000000
;     buf[len++] = (char)(48 + (whole % 10));
7009b500: 980c         	ldr	r0, [sp, #0x30]
7009b502: f246 6167    	movw	r1, #0x6667
7009b506: f2c6 6166    	movt	r1, #0x6666
7009b50a: fb50 f301    	smmul	r3, r0, r1
7009b50e: 089a         	lsrs	r2, r3, #0x2
7009b510: eb02 72d3    	add.w	r2, r2, r3, lsr #31
7009b514: eb02 0282    	add.w	r2, r2, r2, lsl #2
7009b518: eba0 0042    	sub.w	r0, r0, r2, lsl #1
7009b51c: 3030         	adds	r0, #0x30
7009b51e: 9b11         	ldr	r3, [sp, #0x44]
7009b520: 1c5a         	adds	r2, r3, #0x1
7009b522: 9211         	str	r2, [sp, #0x44]
7009b524: aa12         	add	r2, sp, #0x48
7009b526: 54d0         	strb	r0, [r2, r3]
;     if (!(whole /= 10)) {
7009b528: 980c         	ldr	r0, [sp, #0x30]
7009b52a: fb50 f101    	smmul	r1, r0, r1
7009b52e: ea4f 00a1    	asr.w	r0, r1, #0x2
7009b532: eb00 70d1    	add.w	r0, r0, r1, lsr #31
7009b536: 900c         	str	r0, [sp, #0x30]
7009b538: b908         	cbnz	r0, 0x7009b53e <_ftoa+0x41e> @ imm = #0x2
7009b53a: e7ff         	b	0x7009b53c <_ftoa+0x41c> @ imm = #-0x2
;       break;
7009b53c: e000         	b	0x7009b540 <_ftoa+0x420> @ imm = #0x0
;   while (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b53e: e7c6         	b	0x7009b4ce <_ftoa+0x3ae> @ imm = #-0x74
;   if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
7009b540: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b544: 0780         	lsls	r0, r0, #0x1e
7009b546: 2800         	cmp	r0, #0x0
7009b548: d432         	bmi	0x7009b5b0 <_ftoa+0x490> @ imm = #0x64
7009b54a: e7ff         	b	0x7009b54c <_ftoa+0x42c> @ imm = #-0x2
7009b54c: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b550: 07c0         	lsls	r0, r0, #0x1f
7009b552: b368         	cbz	r0, 0x7009b5b0 <_ftoa+0x490> @ imm = #0x5a
7009b554: e7ff         	b	0x7009b556 <_ftoa+0x436> @ imm = #-0x2
;     if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009b556: 9827         	ldr	r0, [sp, #0x9c]
7009b558: b178         	cbz	r0, 0x7009b57a <_ftoa+0x45a> @ imm = #0x1e
7009b55a: e7ff         	b	0x7009b55c <_ftoa+0x43c> @ imm = #-0x2
7009b55c: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009b560: 07c0         	lsls	r0, r0, #0x1f
7009b562: b930         	cbnz	r0, 0x7009b572 <_ftoa+0x452> @ imm = #0xc
7009b564: e7ff         	b	0x7009b566 <_ftoa+0x446> @ imm = #-0x2
7009b566: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b56a: f010 0f0c    	tst.w	r0, #0xc
7009b56e: d004         	beq	0x7009b57a <_ftoa+0x45a> @ imm = #0x8
7009b570: e7ff         	b	0x7009b572 <_ftoa+0x452> @ imm = #-0x2
;       width--;
7009b572: 9827         	ldr	r0, [sp, #0x9c]
7009b574: 3801         	subs	r0, #0x1
7009b576: 9027         	str	r0, [sp, #0x9c]
;     }
7009b578: e7ff         	b	0x7009b57a <_ftoa+0x45a> @ imm = #-0x2
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b57a: e7ff         	b	0x7009b57c <_ftoa+0x45c> @ imm = #-0x2
7009b57c: 9911         	ldr	r1, [sp, #0x44]
7009b57e: 9a27         	ldr	r2, [sp, #0x9c]
7009b580: 2000         	movs	r0, #0x0
7009b582: 4291         	cmp	r1, r2
7009b584: 9005         	str	r0, [sp, #0x14]
7009b586: d207         	bhs	0x7009b598 <_ftoa+0x478> @ imm = #0xe
7009b588: e7ff         	b	0x7009b58a <_ftoa+0x46a> @ imm = #-0x2
7009b58a: 9911         	ldr	r1, [sp, #0x44]
7009b58c: 2000         	movs	r0, #0x0
7009b58e: 2920         	cmp	r1, #0x20
7009b590: bf38         	it	lo
7009b592: 2001         	movlo	r0, #0x1
7009b594: 9005         	str	r0, [sp, #0x14]
7009b596: e7ff         	b	0x7009b598 <_ftoa+0x478> @ imm = #-0x2
7009b598: 9805         	ldr	r0, [sp, #0x14]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b59a: 07c0         	lsls	r0, r0, #0x1f
7009b59c: b138         	cbz	r0, 0x7009b5ae <_ftoa+0x48e> @ imm = #0xe
7009b59e: e7ff         	b	0x7009b5a0 <_ftoa+0x480> @ imm = #-0x2
;       buf[len++] = '0';
7009b5a0: 9a11         	ldr	r2, [sp, #0x44]
7009b5a2: 1c50         	adds	r0, r2, #0x1
7009b5a4: 9011         	str	r0, [sp, #0x44]
7009b5a6: a912         	add	r1, sp, #0x48
7009b5a8: 2030         	movs	r0, #0x30
7009b5aa: 5488         	strb	r0, [r1, r2]
;     while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
7009b5ac: e7e6         	b	0x7009b57c <_ftoa+0x45c> @ imm = #-0x34
;   }
7009b5ae: e7ff         	b	0x7009b5b0 <_ftoa+0x490> @ imm = #-0x2
;   if (len < PRINTF_FTOA_BUFFER_SIZE) {
7009b5b0: 9811         	ldr	r0, [sp, #0x44]
7009b5b2: 281f         	cmp	r0, #0x1f
7009b5b4: d829         	bhi	0x7009b60a <_ftoa+0x4ea> @ imm = #0x52
7009b5b6: e7ff         	b	0x7009b5b8 <_ftoa+0x498> @ imm = #-0x2
;     if (negative) {
7009b5b8: f89d 0037    	ldrb.w	r0, [sp, #0x37]
7009b5bc: 07c0         	lsls	r0, r0, #0x1f
7009b5be: b138         	cbz	r0, 0x7009b5d0 <_ftoa+0x4b0> @ imm = #0xe
7009b5c0: e7ff         	b	0x7009b5c2 <_ftoa+0x4a2> @ imm = #-0x2
;       buf[len++] = '-';
7009b5c2: 9a11         	ldr	r2, [sp, #0x44]
7009b5c4: 1c50         	adds	r0, r2, #0x1
7009b5c6: 9011         	str	r0, [sp, #0x44]
7009b5c8: a912         	add	r1, sp, #0x48
7009b5ca: 202d         	movs	r0, #0x2d
7009b5cc: 5488         	strb	r0, [r1, r2]
;     }
7009b5ce: e01b         	b	0x7009b608 <_ftoa+0x4e8> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009b5d0: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b5d4: 0740         	lsls	r0, r0, #0x1d
7009b5d6: 2800         	cmp	r0, #0x0
7009b5d8: d507         	bpl	0x7009b5ea <_ftoa+0x4ca> @ imm = #0xe
7009b5da: e7ff         	b	0x7009b5dc <_ftoa+0x4bc> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009b5dc: 9a11         	ldr	r2, [sp, #0x44]
7009b5de: 1c50         	adds	r0, r2, #0x1
7009b5e0: 9011         	str	r0, [sp, #0x44]
7009b5e2: a912         	add	r1, sp, #0x48
7009b5e4: 202b         	movs	r0, #0x2b
7009b5e6: 5488         	strb	r0, [r1, r2]
;     }
7009b5e8: e00d         	b	0x7009b606 <_ftoa+0x4e6> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009b5ea: f89d 00a0    	ldrb.w	r0, [sp, #0xa0]
7009b5ee: 0700         	lsls	r0, r0, #0x1c
7009b5f0: 2800         	cmp	r0, #0x0
7009b5f2: d507         	bpl	0x7009b604 <_ftoa+0x4e4> @ imm = #0xe
7009b5f4: e7ff         	b	0x7009b5f6 <_ftoa+0x4d6> @ imm = #-0x2
;       buf[len++] = ' ';
7009b5f6: 9a11         	ldr	r2, [sp, #0x44]
7009b5f8: 1c50         	adds	r0, r2, #0x1
7009b5fa: 9011         	str	r0, [sp, #0x44]
7009b5fc: a912         	add	r1, sp, #0x48
7009b5fe: 2020         	movs	r0, #0x20
7009b600: 5488         	strb	r0, [r1, r2]
;     }
7009b602: e7ff         	b	0x7009b604 <_ftoa+0x4e4> @ imm = #-0x2
7009b604: e7ff         	b	0x7009b606 <_ftoa+0x4e6> @ imm = #-0x2
7009b606: e7ff         	b	0x7009b608 <_ftoa+0x4e8> @ imm = #-0x2
;   }
7009b608: e7ff         	b	0x7009b60a <_ftoa+0x4ea> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009b60a: 9820         	ldr	r0, [sp, #0x80]
7009b60c: 991f         	ldr	r1, [sp, #0x7c]
7009b60e: 9a1e         	ldr	r2, [sp, #0x78]
7009b610: 9b1d         	ldr	r3, [sp, #0x74]
7009b612: f8dd c044    	ldr.w	r12, [sp, #0x44]
7009b616: 9c27         	ldr	r4, [sp, #0x9c]
7009b618: 9d28         	ldr	r5, [sp, #0xa0]
7009b61a: 46ee         	mov	lr, sp
7009b61c: f8ce 500c    	str.w	r5, [lr, #0xc]
7009b620: f8ce 4008    	str.w	r4, [lr, #0x8]
7009b624: f8ce c004    	str.w	r12, [lr, #0x4]
7009b628: f10d 0c48    	add.w	r12, sp, #0x48
7009b62c: f8ce c000    	str.w	r12, [lr]
7009b630: f00c f826    	bl	0x700a7680 <_out_rev>   @ imm = #0xc04c
7009b634: 9021         	str	r0, [sp, #0x84]
7009b636: e7ff         	b	0x7009b638 <_ftoa+0x518> @ imm = #-0x2
; }
7009b638: 9821         	ldr	r0, [sp, #0x84]
7009b63a: b022         	add	sp, #0x88
7009b63c: bd70         	pop	{r4, r5, r6, pc}
7009b63e: 0000         	movs	r0, r0

7009b640 <_etoa>:
; {
7009b640: b570         	push	{r4, r5, r6, lr}
7009b642: b0a8         	sub	sp, #0xa0
7009b644: f8dd c0b8    	ldr.w	r12, [sp, #0xb8]
7009b648: f8dd c0b4    	ldr.w	r12, [sp, #0xb4]
7009b64c: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b650: 9026         	str	r0, [sp, #0x98]
7009b652: 9125         	str	r1, [sp, #0x94]
7009b654: 9224         	str	r2, [sp, #0x90]
7009b656: 9323         	str	r3, [sp, #0x8c]
7009b658: ed8d 0b20    	vstr	d0, [sp, #128]
;   if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
7009b65c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b660: eeb4 0b40    	vcmp.f64	d0, d0
7009b664: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b668: d614         	bvs	0x7009b694 <_etoa+0x54> @ imm = #0x28
7009b66a: e7ff         	b	0x7009b66c <_etoa+0x2c> @ imm = #-0x2
7009b66c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b670: ed9f 1bdb    	vldr	d1, [pc, #876]          @ 0x7009b9e0 <_etoa+0x3a0>
7009b674: eeb4 0b41    	vcmp.f64	d0, d1
7009b678: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b67c: dc0a         	bgt	0x7009b694 <_etoa+0x54> @ imm = #0x14
7009b67e: e7ff         	b	0x7009b680 <_etoa+0x40> @ imm = #-0x2
7009b680: ed9d 0b20    	vldr	d0, [sp, #128]
7009b684: ed9f 1bd8    	vldr	d1, [pc, #864]          @ 0x7009b9e8 <_etoa+0x3a8>
7009b688: eeb4 0b41    	vcmp.f64	d0, d1
7009b68c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b690: d515         	bpl	0x7009b6be <_etoa+0x7e> @ imm = #0x2a
7009b692: e7ff         	b	0x7009b694 <_etoa+0x54> @ imm = #-0x2
;     return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
7009b694: 9826         	ldr	r0, [sp, #0x98]
7009b696: 9925         	ldr	r1, [sp, #0x94]
7009b698: 9a24         	ldr	r2, [sp, #0x90]
7009b69a: 9b23         	ldr	r3, [sp, #0x8c]
7009b69c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b6a0: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b6a4: 9c2d         	ldr	r4, [sp, #0xb4]
7009b6a6: 9d2e         	ldr	r5, [sp, #0xb8]
7009b6a8: 46ee         	mov	lr, sp
7009b6aa: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b6ae: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b6b2: f8ce c000    	str.w	r12, [lr]
7009b6b6: f7ff fd33    	bl	0x7009b120 <_ftoa>      @ imm = #-0x59a
7009b6ba: 9027         	str	r0, [sp, #0x9c]
7009b6bc: e1d8         	b	0x7009ba70 <_etoa+0x430> @ imm = #0x3b0
;   const bool negative = value < 0;
7009b6be: ed9d 0b20    	vldr	d0, [sp, #128]
7009b6c2: f04f 0000    	mov.w	r0, #0x0
7009b6c6: eeb5 0b40    	vcmp.f64	d0, #0
7009b6ca: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b6ce: bf48         	it	mi
7009b6d0: 2001         	movmi	r0, #0x1
7009b6d2: f88d 007f    	strb.w	r0, [sp, #0x7f]
;   if (negative) {
7009b6d6: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009b6da: ea4f 70c0    	lsl.w	r0, r0, #0x1f
7009b6de: b138         	cbz	r0, 0x7009b6f0 <_etoa+0xb0> @ imm = #0xe
7009b6e0: e7ff         	b	0x7009b6e2 <_etoa+0xa2> @ imm = #-0x2
;     value = -value;
7009b6e2: ed9d 0b20    	vldr	d0, [sp, #128]
7009b6e6: eeb1 0b40    	vneg.f64	d0, d0
7009b6ea: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009b6ee: e7ff         	b	0x7009b6f0 <_etoa+0xb0> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION)) {
7009b6f0: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b6f4: 0740         	lsls	r0, r0, #0x1d
7009b6f6: 2800         	cmp	r0, #0x0
7009b6f8: d403         	bmi	0x7009b702 <_etoa+0xc2> @ imm = #0x6
7009b6fa: e7ff         	b	0x7009b6fc <_etoa+0xbc> @ imm = #-0x2
7009b6fc: 2006         	movs	r0, #0x6
;     prec = PRINTF_DEFAULT_FLOAT_PRECISION;
7009b6fe: 902c         	str	r0, [sp, #0xb0]
;   }
7009b700: e7ff         	b	0x7009b702 <_etoa+0xc2> @ imm = #-0x2
;   conv.F = value;
7009b702: ed9d 0b20    	vldr	d0, [sp, #128]
7009b706: ed8d 0b1c    	vstr	d0, [sp, #112]
;   int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
7009b70a: 981d         	ldr	r0, [sp, #0x74]
7009b70c: f3c0 500a    	ubfx	r0, r0, #0x14, #0xb
7009b710: f2a0 30ff    	subw	r0, r0, #0x3ff
7009b714: 901b         	str	r0, [sp, #0x6c]
;   conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
7009b716: 981d         	ldr	r0, [sp, #0x74]
7009b718: f240 31ff    	movw	r1, #0x3ff
7009b71c: f361 501f    	bfi	r0, r1, #20, #12
7009b720: 901d         	str	r0, [sp, #0x74]
;   int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
7009b722: ed9d 0a1b    	vldr	s0, [sp, #108]
7009b726: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b72a: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009ba78 <_etoa+0x438>
7009b72e: ee20 0b01    	vmul.f64	d0, d0, d1
7009b732: ed9f 1bd3    	vldr	d1, [pc, #844]          @ 0x7009ba80 <_etoa+0x440>
7009b736: ee30 1b01    	vadd.f64	d1, d0, d1
7009b73a: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b73e: eebf 2b08    	vmov.f64	d2, #-1.500000e+00
7009b742: ee30 0b02    	vadd.f64	d0, d0, d2
7009b746: ed9f 2bd0    	vldr	d2, [pc, #832]          @ 0x7009ba88 <_etoa+0x448>
7009b74a: ee20 0b02    	vmul.f64	d0, d0, d2
7009b74e: ee30 0b01    	vadd.f64	d0, d0, d1
7009b752: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b756: ed8d 0a1a    	vstr	s0, [sp, #104]
;   exp2 = (int)(expval * 3.321928094887362 + 0.5);
7009b75a: ed9d 0a1a    	vldr	s0, [sp, #104]
7009b75e: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b762: ed9f 1bcb    	vldr	d1, [pc, #812]          @ 0x7009ba90 <_etoa+0x450>
7009b766: ee20 0b01    	vmul.f64	d0, d0, d1
7009b76a: eeb6 1b00    	vmov.f64	d1, #5.000000e-01
7009b76e: ee30 0b01    	vadd.f64	d0, d0, d1
7009b772: eebd 0bc0    	vcvt.s32.f64	s0, d0
7009b776: ed8d 0a1b    	vstr	s0, [sp, #108]
;   const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
7009b77a: ed9d 0a1a    	vldr	s0, [sp, #104]
7009b77e: eeb8 0bc0    	vcvt.f64.s32	d0, s0
7009b782: ed9d 1a1b    	vldr	s2, [sp, #108]
7009b786: eeb8 1bc1    	vcvt.f64.s32	d1, s2
7009b78a: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009ba98 <_etoa+0x458>
7009b78e: ee21 1b02    	vmul.f64	d1, d1, d2
7009b792: ed9f 2bc3    	vldr	d2, [pc, #780]          @ 0x7009baa0 <_etoa+0x460>
7009b796: ee20 0b02    	vmul.f64	d0, d0, d2
7009b79a: ee30 0b01    	vadd.f64	d0, d0, d1
7009b79e: ed8d 0b18    	vstr	d0, [sp, #96]
;   const double z2 = z * z;
7009b7a2: ed9d 0b18    	vldr	d0, [sp, #96]
7009b7a6: ee20 0b00    	vmul.f64	d0, d0, d0
7009b7aa: ed8d 0b16    	vstr	d0, [sp, #88]
;   conv.U = (uint64_t)(exp2 + 1023) << 52U;
7009b7ae: 981b         	ldr	r0, [sp, #0x6c]
7009b7b0: f200 30ff    	addw	r0, r0, #0x3ff
7009b7b4: 0500         	lsls	r0, r0, #0x14
7009b7b6: 2100         	movs	r1, #0x0
7009b7b8: 911c         	str	r1, [sp, #0x70]
7009b7ba: 901d         	str	r0, [sp, #0x74]
;   conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
7009b7bc: ed9d 2b18    	vldr	d2, [sp, #96]
7009b7c0: ee32 0b02    	vadd.f64	d0, d2, d2
7009b7c4: eeb0 1b00    	vmov.f64	d1, #2.000000e+00
7009b7c8: ee31 1b42    	vsub.f64	d1, d1, d2
7009b7cc: ed9d 2b16    	vldr	d2, [sp, #88]
7009b7d0: eeb2 3b0c    	vmov.f64	d3, #1.400000e+01
7009b7d4: ee82 3b03    	vdiv.f64	d3, d2, d3
7009b7d8: eeb2 4b04    	vmov.f64	d4, #1.000000e+01
7009b7dc: ee33 3b04    	vadd.f64	d3, d3, d4
7009b7e0: ee82 3b03    	vdiv.f64	d3, d2, d3
7009b7e4: eeb1 4b08    	vmov.f64	d4, #6.000000e+00
7009b7e8: ee33 3b04    	vadd.f64	d3, d3, d4
7009b7ec: ee82 2b03    	vdiv.f64	d2, d2, d3
7009b7f0: ee31 1b02    	vadd.f64	d1, d1, d2
7009b7f4: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b7f8: eeb7 1b00    	vmov.f64	d1, #1.000000e+00
7009b7fc: ee30 1b01    	vadd.f64	d1, d0, d1
7009b800: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b804: ee20 0b01    	vmul.f64	d0, d0, d1
7009b808: ed8d 0b1c    	vstr	d0, [sp, #112]
;   if (value < conv.F) {
7009b80c: ed9d 0b20    	vldr	d0, [sp, #128]
7009b810: ed9d 1b1c    	vldr	d1, [sp, #112]
7009b814: eeb4 0b41    	vcmp.f64	d0, d1
7009b818: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b81c: d50c         	bpl	0x7009b838 <_etoa+0x1f8> @ imm = #0x18
7009b81e: e7ff         	b	0x7009b820 <_etoa+0x1e0> @ imm = #-0x2
;     expval--;
7009b820: 981a         	ldr	r0, [sp, #0x68]
7009b822: 3801         	subs	r0, #0x1
7009b824: 901a         	str	r0, [sp, #0x68]
;     conv.F /= 10;
7009b826: ed9d 0b1c    	vldr	d0, [sp, #112]
7009b82a: eeb2 1b04    	vmov.f64	d1, #1.000000e+01
7009b82e: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b832: ed8d 0b1c    	vstr	d0, [sp, #112]
;   }
7009b836: e7ff         	b	0x7009b838 <_etoa+0x1f8> @ imm = #-0x2
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009b838: 991a         	ldr	r1, [sp, #0x68]
7009b83a: f04f 0000    	mov.w	r0, #0x0
7009b83e: 2963         	cmp	r1, #0x63
7009b840: 9012         	str	r0, [sp, #0x48]
7009b842: dc08         	bgt	0x7009b856 <_etoa+0x216> @ imm = #0x10
7009b844: e7ff         	b	0x7009b846 <_etoa+0x206> @ imm = #-0x2
7009b846: 991a         	ldr	r1, [sp, #0x68]
7009b848: 2000         	movs	r0, #0x0
7009b84a: f111 0f64    	cmn.w	r1, #0x64
7009b84e: bfc8         	it	gt
7009b850: 2001         	movgt	r0, #0x1
7009b852: 9012         	str	r0, [sp, #0x48]
7009b854: e7ff         	b	0x7009b856 <_etoa+0x216> @ imm = #-0x2
7009b856: 9812         	ldr	r0, [sp, #0x48]
;   unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
7009b858: 07c1         	lsls	r1, r0, #0x1f
7009b85a: 2005         	movs	r0, #0x5
7009b85c: 2900         	cmp	r1, #0x0
7009b85e: bf18         	it	ne
7009b860: 2004         	movne	r0, #0x4
7009b862: 9015         	str	r0, [sp, #0x54]
;   if (flags & FLAGS_ADAPT_EXP) {
7009b864: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b868: ea4f 7000    	lsl.w	r0, r0, #0x1c
7009b86c: 2800         	cmp	r0, #0x0
7009b86e: d539         	bpl	0x7009b8e4 <_etoa+0x2a4> @ imm = #0x72
7009b870: e7ff         	b	0x7009b872 <_etoa+0x232> @ imm = #-0x2
;     if ((value >= 1e-4) && (value < 1e6)) {
7009b872: ed9d 0b20    	vldr	d0, [sp, #128]
7009b876: ed9f 1b8c    	vldr	d1, [pc, #560]          @ 0x7009baa8 <_etoa+0x468>
7009b87a: eeb4 0b41    	vcmp.f64	d0, d1
7009b87e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b882: db20         	blt	0x7009b8c6 <_etoa+0x286> @ imm = #0x40
7009b884: e7ff         	b	0x7009b886 <_etoa+0x246> @ imm = #-0x2
7009b886: ed9d 0b20    	vldr	d0, [sp, #128]
7009b88a: ed9f 1b89    	vldr	d1, [pc, #548]          @ 0x7009bab0 <_etoa+0x470>
7009b88e: eeb4 0b41    	vcmp.f64	d0, d1
7009b892: eef1 fa10    	vmrs	APSR_nzcv, fpscr
7009b896: d516         	bpl	0x7009b8c6 <_etoa+0x286> @ imm = #0x2c
7009b898: e7ff         	b	0x7009b89a <_etoa+0x25a> @ imm = #-0x2
;       if ((int)prec > expval) {
7009b89a: 982c         	ldr	r0, [sp, #0xb0]
7009b89c: 991a         	ldr	r1, [sp, #0x68]
7009b89e: 4288         	cmp	r0, r1
7009b8a0: dd06         	ble	0x7009b8b0 <_etoa+0x270> @ imm = #0xc
7009b8a2: e7ff         	b	0x7009b8a4 <_etoa+0x264> @ imm = #-0x2
;         prec = (unsigned)((int)prec - expval - 1);
7009b8a4: 992c         	ldr	r1, [sp, #0xb0]
7009b8a6: 981a         	ldr	r0, [sp, #0x68]
7009b8a8: 43c0         	mvns	r0, r0
7009b8aa: 4408         	add	r0, r1
7009b8ac: 902c         	str	r0, [sp, #0xb0]
;       }
7009b8ae: e002         	b	0x7009b8b6 <_etoa+0x276> @ imm = #0x4
7009b8b0: 2000         	movs	r0, #0x0
;         prec = 0;
7009b8b2: 902c         	str	r0, [sp, #0xb0]
7009b8b4: e7ff         	b	0x7009b8b6 <_etoa+0x276> @ imm = #-0x2
;       flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
7009b8b6: 982e         	ldr	r0, [sp, #0xb8]
7009b8b8: f440 6080    	orr	r0, r0, #0x400
7009b8bc: 902e         	str	r0, [sp, #0xb8]
7009b8be: 2000         	movs	r0, #0x0
;       minwidth = 0U;
7009b8c0: 9015         	str	r0, [sp, #0x54]
;       expval   = 0;
7009b8c2: 901a         	str	r0, [sp, #0x68]
;     }
7009b8c4: e00d         	b	0x7009b8e2 <_etoa+0x2a2> @ imm = #0x1a
;       if ((prec > 0) && (flags & FLAGS_PRECISION)) {
7009b8c6: 982c         	ldr	r0, [sp, #0xb0]
7009b8c8: b150         	cbz	r0, 0x7009b8e0 <_etoa+0x2a0> @ imm = #0x14
7009b8ca: e7ff         	b	0x7009b8cc <_etoa+0x28c> @ imm = #-0x2
7009b8cc: f89d 00b9    	ldrb.w	r0, [sp, #0xb9]
7009b8d0: 0740         	lsls	r0, r0, #0x1d
7009b8d2: 2800         	cmp	r0, #0x0
7009b8d4: d504         	bpl	0x7009b8e0 <_etoa+0x2a0> @ imm = #0x8
7009b8d6: e7ff         	b	0x7009b8d8 <_etoa+0x298> @ imm = #-0x2
;         --prec;
7009b8d8: 982c         	ldr	r0, [sp, #0xb0]
7009b8da: 3801         	subs	r0, #0x1
7009b8dc: 902c         	str	r0, [sp, #0xb0]
;       }
7009b8de: e7ff         	b	0x7009b8e0 <_etoa+0x2a0> @ imm = #-0x2
7009b8e0: e7ff         	b	0x7009b8e2 <_etoa+0x2a2> @ imm = #-0x2
;   }
7009b8e2: e7ff         	b	0x7009b8e4 <_etoa+0x2a4> @ imm = #-0x2
;   unsigned int fwidth = width;
7009b8e4: 982d         	ldr	r0, [sp, #0xb4]
7009b8e6: 9014         	str	r0, [sp, #0x50]
;   if (width > minwidth) {
7009b8e8: 982d         	ldr	r0, [sp, #0xb4]
7009b8ea: 9915         	ldr	r1, [sp, #0x54]
7009b8ec: 4288         	cmp	r0, r1
7009b8ee: d905         	bls	0x7009b8fc <_etoa+0x2bc> @ imm = #0xa
7009b8f0: e7ff         	b	0x7009b8f2 <_etoa+0x2b2> @ imm = #-0x2
;     fwidth -= minwidth;
7009b8f2: 9915         	ldr	r1, [sp, #0x54]
7009b8f4: 9814         	ldr	r0, [sp, #0x50]
7009b8f6: 1a40         	subs	r0, r0, r1
7009b8f8: 9014         	str	r0, [sp, #0x50]
;   } else {
7009b8fa: e002         	b	0x7009b902 <_etoa+0x2c2> @ imm = #0x4
7009b8fc: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009b8fe: 9014         	str	r0, [sp, #0x50]
7009b900: e7ff         	b	0x7009b902 <_etoa+0x2c2> @ imm = #-0x2
;   if ((flags & FLAGS_LEFT) && minwidth) {
7009b902: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009b906: 0780         	lsls	r0, r0, #0x1e
7009b908: 2800         	cmp	r0, #0x0
7009b90a: d506         	bpl	0x7009b91a <_etoa+0x2da> @ imm = #0xc
7009b90c: e7ff         	b	0x7009b90e <_etoa+0x2ce> @ imm = #-0x2
7009b90e: 9815         	ldr	r0, [sp, #0x54]
7009b910: b118         	cbz	r0, 0x7009b91a <_etoa+0x2da> @ imm = #0x6
7009b912: e7ff         	b	0x7009b914 <_etoa+0x2d4> @ imm = #-0x2
7009b914: 2000         	movs	r0, #0x0
;     fwidth = 0U;
7009b916: 9014         	str	r0, [sp, #0x50]
;   }
7009b918: e7ff         	b	0x7009b91a <_etoa+0x2da> @ imm = #-0x2
;   if (expval) {
7009b91a: 981a         	ldr	r0, [sp, #0x68]
7009b91c: b148         	cbz	r0, 0x7009b932 <_etoa+0x2f2> @ imm = #0x12
7009b91e: e7ff         	b	0x7009b920 <_etoa+0x2e0> @ imm = #-0x2
;     value /= conv.F;
7009b920: ed9d 1b1c    	vldr	d1, [sp, #112]
7009b924: ed9d 0b20    	vldr	d0, [sp, #128]
7009b928: ee80 0b01    	vdiv.f64	d0, d0, d1
7009b92c: ed8d 0b20    	vstr	d0, [sp, #128]
;   }
7009b930: e7ff         	b	0x7009b932 <_etoa+0x2f2> @ imm = #-0x2
;   const size_t start_idx = idx;
7009b932: 9824         	ldr	r0, [sp, #0x90]
7009b934: 9013         	str	r0, [sp, #0x4c]
;   idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
7009b936: 9826         	ldr	r0, [sp, #0x98]
7009b938: 900e         	str	r0, [sp, #0x38]
7009b93a: 9825         	ldr	r0, [sp, #0x94]
7009b93c: 900f         	str	r0, [sp, #0x3c]
7009b93e: 9824         	ldr	r0, [sp, #0x90]
7009b940: 9010         	str	r0, [sp, #0x40]
7009b942: 9823         	ldr	r0, [sp, #0x8c]
7009b944: 9011         	str	r0, [sp, #0x44]
7009b946: f89d 007f    	ldrb.w	r0, [sp, #0x7f]
7009b94a: 07c0         	lsls	r0, r0, #0x1f
7009b94c: b138         	cbz	r0, 0x7009b95e <_etoa+0x31e> @ imm = #0xe
7009b94e: e7ff         	b	0x7009b950 <_etoa+0x310> @ imm = #-0x2
7009b950: ed9d 0b20    	vldr	d0, [sp, #128]
7009b954: eeb1 0b40    	vneg.f64	d0, d0
7009b958: ed8d 0b0c    	vstr	d0, [sp, #48]
7009b95c: e004         	b	0x7009b968 <_etoa+0x328> @ imm = #0x8
7009b95e: ed9d 0b20    	vldr	d0, [sp, #128]
7009b962: ed8d 0b0c    	vstr	d0, [sp, #48]
7009b966: e7ff         	b	0x7009b968 <_etoa+0x328> @ imm = #-0x2
7009b968: 9b11         	ldr	r3, [sp, #0x44]
7009b96a: 9a10         	ldr	r2, [sp, #0x40]
7009b96c: 990f         	ldr	r1, [sp, #0x3c]
7009b96e: 980e         	ldr	r0, [sp, #0x38]
7009b970: ed9d 0b0c    	vldr	d0, [sp, #48]
7009b974: f8dd c0b0    	ldr.w	r12, [sp, #0xb0]
7009b978: 9c14         	ldr	r4, [sp, #0x50]
7009b97a: f8dd e0b8    	ldr.w	lr, [sp, #0xb8]
7009b97e: f42e 6500    	bic	r5, lr, #0x800
7009b982: 46ee         	mov	lr, sp
7009b984: f8ce 5008    	str.w	r5, [lr, #0x8]
7009b988: f8ce 4004    	str.w	r4, [lr, #0x4]
7009b98c: f8ce c000    	str.w	r12, [lr]
7009b990: f7ff fbc6    	bl	0x7009b120 <_ftoa>      @ imm = #-0x874
7009b994: 9024         	str	r0, [sp, #0x90]
;   if (minwidth) {
7009b996: 9815         	ldr	r0, [sp, #0x54]
7009b998: 2800         	cmp	r0, #0x0
7009b99a: d066         	beq	0x7009ba6a <_etoa+0x42a> @ imm = #0xcc
7009b99c: e7ff         	b	0x7009b99e <_etoa+0x35e> @ imm = #-0x2
;     out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
7009b99e: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009b9a2: 982e         	ldr	r0, [sp, #0xb8]
7009b9a4: 0681         	lsls	r1, r0, #0x1a
7009b9a6: 2065         	movs	r0, #0x65
7009b9a8: 2900         	cmp	r1, #0x0
7009b9aa: bf48         	it	mi
7009b9ac: 2045         	movmi	r0, #0x45
7009b9ae: 9925         	ldr	r1, [sp, #0x94]
7009b9b0: 9a24         	ldr	r2, [sp, #0x90]
7009b9b2: 1c53         	adds	r3, r2, #0x1
7009b9b4: 9324         	str	r3, [sp, #0x90]
7009b9b6: 9b23         	ldr	r3, [sp, #0x8c]
7009b9b8: 47e0         	blx	r12
;     idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
7009b9ba: 9826         	ldr	r0, [sp, #0x98]
7009b9bc: 9008         	str	r0, [sp, #0x20]
7009b9be: 9825         	ldr	r0, [sp, #0x94]
7009b9c0: 9009         	str	r0, [sp, #0x24]
7009b9c2: 9824         	ldr	r0, [sp, #0x90]
7009b9c4: 900a         	str	r0, [sp, #0x28]
7009b9c6: 9823         	ldr	r0, [sp, #0x8c]
7009b9c8: 900b         	str	r0, [sp, #0x2c]
7009b9ca: 981a         	ldr	r0, [sp, #0x68]
7009b9cc: f1b0 3fff    	cmp.w	r0, #0xffffffff
7009b9d0: dc0e         	bgt	0x7009b9f0 <_etoa+0x3b0> @ imm = #0x1c
7009b9d2: e7ff         	b	0x7009b9d4 <_etoa+0x394> @ imm = #-0x2
7009b9d4: 981a         	ldr	r0, [sp, #0x68]
7009b9d6: 4240         	rsbs	r0, r0, #0
7009b9d8: 9007         	str	r0, [sp, #0x1c]
7009b9da: e00c         	b	0x7009b9f6 <_etoa+0x3b6> @ imm = #0x18
7009b9dc: bf00         	nop
7009b9de: bf00         	nop
7009b9e0: ff ff ff ff  	.word	0xffffffff
7009b9e4: ff ff ef 7f  	.word	0x7fefffff
7009b9e8: ff ff ff ff  	.word	0xffffffff
7009b9ec: ff ff ef ff  	.word	0xffefffff
7009b9f0: 981a         	ldr	r0, [sp, #0x68]
7009b9f2: 9007         	str	r0, [sp, #0x1c]
7009b9f4: e7ff         	b	0x7009b9f6 <_etoa+0x3b6> @ imm = #-0x2
7009b9f6: 9b0b         	ldr	r3, [sp, #0x2c]
7009b9f8: 9a0a         	ldr	r2, [sp, #0x28]
7009b9fa: 9909         	ldr	r1, [sp, #0x24]
7009b9fc: 9808         	ldr	r0, [sp, #0x20]
7009b9fe: f8dd c01c    	ldr.w	r12, [sp, #0x1c]
7009ba02: 9c1a         	ldr	r4, [sp, #0x68]
7009ba04: f8dd e054    	ldr.w	lr, [sp, #0x54]
7009ba08: f1ae 0501    	sub.w	r5, lr, #0x1
7009ba0c: 46ee         	mov	lr, sp
7009ba0e: 2605         	movs	r6, #0x5
7009ba10: f8ce 6014    	str.w	r6, [lr, #0x14]
7009ba14: f8ce 5010    	str.w	r5, [lr, #0x10]
7009ba18: 2500         	movs	r5, #0x0
7009ba1a: f8ce 500c    	str.w	r5, [lr, #0xc]
7009ba1e: 250a         	movs	r5, #0xa
7009ba20: f8ce 5008    	str.w	r5, [lr, #0x8]
7009ba24: ea4f 74d4    	lsr.w	r4, r4, #0x1f
7009ba28: f8ce 4004    	str.w	r4, [lr, #0x4]
7009ba2c: f8ce c000    	str.w	r12, [lr]
7009ba30: f009 f926    	bl	0x700a4c80 <_ntoa_long> @ imm = #0x924c
7009ba34: 9024         	str	r0, [sp, #0x90]
;     if (flags & FLAGS_LEFT) {
7009ba36: f89d 00b8    	ldrb.w	r0, [sp, #0xb8]
7009ba3a: 0780         	lsls	r0, r0, #0x1e
7009ba3c: 2800         	cmp	r0, #0x0
7009ba3e: d513         	bpl	0x7009ba68 <_etoa+0x428> @ imm = #0x26
7009ba40: e7ff         	b	0x7009ba42 <_etoa+0x402> @ imm = #-0x2
;       while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
7009ba42: e7ff         	b	0x7009ba44 <_etoa+0x404> @ imm = #-0x2
7009ba44: 9824         	ldr	r0, [sp, #0x90]
7009ba46: 9913         	ldr	r1, [sp, #0x4c]
7009ba48: 1a40         	subs	r0, r0, r1
7009ba4a: 992d         	ldr	r1, [sp, #0xb4]
7009ba4c: 4288         	cmp	r0, r1
7009ba4e: d20a         	bhs	0x7009ba66 <_etoa+0x426> @ imm = #0x14
7009ba50: e7ff         	b	0x7009ba52 <_etoa+0x412> @ imm = #-0x2
7009ba52: f8dd c098    	ldr.w	r12, [sp, #0x98]
7009ba56: 9925         	ldr	r1, [sp, #0x94]
7009ba58: 9a24         	ldr	r2, [sp, #0x90]
7009ba5a: 1c50         	adds	r0, r2, #0x1
7009ba5c: 9024         	str	r0, [sp, #0x90]
7009ba5e: 9b23         	ldr	r3, [sp, #0x8c]
7009ba60: 2020         	movs	r0, #0x20
7009ba62: 47e0         	blx	r12
7009ba64: e7ee         	b	0x7009ba44 <_etoa+0x404> @ imm = #-0x24
;     }
7009ba66: e7ff         	b	0x7009ba68 <_etoa+0x428> @ imm = #-0x2
;   }
7009ba68: e7ff         	b	0x7009ba6a <_etoa+0x42a> @ imm = #-0x2
;   return idx;
7009ba6a: 9824         	ldr	r0, [sp, #0x90]
7009ba6c: 9027         	str	r0, [sp, #0x9c]
7009ba6e: e7ff         	b	0x7009ba70 <_etoa+0x430> @ imm = #-0x2
; }
7009ba70: 9827         	ldr	r0, [sp, #0x9c]
7009ba72: b028         	add	sp, #0xa0
7009ba74: bd70         	pop	{r4, r5, r6, pc}
7009ba76: bf00         	nop
7009ba78: fb 79 9f 50  	.word	0x509f79fb
7009ba7c: 13 44 d3 3f  	.word	0x3fd34413
7009ba80: b3 c8 60 8b  	.word	0x8b60c8b3
7009ba84: 28 8a c6 3f  	.word	0x3fc68a28
7009ba88: 61 43 6f 63  	.word	0x636f4361
7009ba8c: a7 87 d2 3f  	.word	0x3fd287a7
7009ba90: 71 a3 79 09  	.word	0x0979a371
7009ba94: 4f 93 0a 40  	.word	0x400a934f
7009ba98: ef 39 fa fe  	.word	0xfefa39ef
7009ba9c: 42 2e e6 bf  	.word	0xbfe62e42
7009baa0: 16 55 b5 bb  	.word	0xbbb55516
7009baa4: b1 6b 02 40  	.word	0x40026bb1
7009baa8: 2d 43 1c eb  	.word	0xeb1c432d
7009baac: e2 36 1a 3f  	.word	0x3f1a36e2
7009bab0: 00 00 00 00  	.word	0x00000000
7009bab4: 80 84 2e 41  	.word	0x412e8480

7009bab8 <_nop>:
7009bab8: e12fff1e     	bx	lr
7009babc: 00000000     	andeq	r0, r0, r0

7009bac0 <UART_open>:
; {
7009bac0: b580         	push	{r7, lr}
7009bac2: b092         	sub	sp, #0x48
7009bac4: 9011         	str	r0, [sp, #0x44]
7009bac6: 9110         	str	r1, [sp, #0x40]
7009bac8: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS;
7009baca: 900f         	str	r0, [sp, #0x3c]
;     UART_Handle         handle = NULL;
7009bacc: 900e         	str	r0, [sp, #0x38]
;     UART_Config        *config = NULL;
7009bace: 900d         	str	r0, [sp, #0x34]
;     UART_Object        *object    = NULL;
7009bad0: 900c         	str	r0, [sp, #0x30]
;     if(index >= gUartConfigNum)
7009bad2: 9811         	ldr	r0, [sp, #0x44]
7009bad4: f642 11ec    	movw	r1, #0x29ec
7009bad8: f2c7 010b    	movt	r1, #0x700b
7009badc: 6809         	ldr	r1, [r1]
7009bade: 4288         	cmp	r0, r1
7009bae0: d304         	blo	0x7009baec <UART_open+0x2c> @ imm = #0x8
7009bae2: e7ff         	b	0x7009bae4 <UART_open+0x24> @ imm = #-0x2
7009bae4: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009bae8: 900f         	str	r0, [sp, #0x3c]
;     }
7009baea: e008         	b	0x7009bafe <UART_open+0x3e> @ imm = #0x10
;         config = &gUartConfig[index];
7009baec: 9911         	ldr	r1, [sp, #0x44]
7009baee: f642 10a4    	movw	r0, #0x29a4
7009baf2: f2c7 000b    	movt	r0, #0x700b
7009baf6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009bafa: 900d         	str	r0, [sp, #0x34]
7009bafc: e7ff         	b	0x7009bafe <UART_open+0x3e> @ imm = #-0x2
;     DebugP_assert(NULL_PTR != gUartDrvObj.lock);
7009bafe: f242 7128    	movw	r1, #0x2728
7009bb02: f2c7 010b    	movt	r1, #0x700b
7009bb06: f851 0b04    	ldr	r0, [r1], #4
7009bb0a: 9103         	str	r1, [sp, #0xc]
7009bb0c: 2800         	cmp	r0, #0x0
7009bb0e: bf18         	it	ne
7009bb10: 2001         	movne	r0, #0x1
7009bb12: f641 51c0    	movw	r1, #0x1dc0
7009bb16: f2c7 010b    	movt	r1, #0x700b
7009bb1a: 466a         	mov	r2, sp
7009bb1c: 6011         	str	r1, [r2]
7009bb1e: f641 71e1    	movw	r1, #0x1fe1
7009bb22: f2c7 010b    	movt	r1, #0x700b
7009bb26: f242 124b    	movw	r2, #0x214b
7009bb2a: f2c7 020b    	movt	r2, #0x700b
7009bb2e: f240 1301    	movw	r3, #0x101
7009bb32: f00f f8a5    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xf14a
7009bb36: 9803         	ldr	r0, [sp, #0xc]
7009bb38: f04f 31ff    	mov.w	r1, #0xffffffff
;     (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
7009bb3c: f00e fe48    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0xec90
;     if(SystemP_SUCCESS  == status)
7009bb40: 980f         	ldr	r0, [sp, #0x3c]
7009bb42: bb38         	cbnz	r0, 0x7009bb94 <UART_open+0xd4> @ imm = #0x4e
7009bb44: e7ff         	b	0x7009bb46 <UART_open+0x86> @ imm = #-0x2
;         object = config->object;
7009bb46: 980d         	ldr	r0, [sp, #0x34]
7009bb48: 6840         	ldr	r0, [r0, #0x4]
7009bb4a: 900c         	str	r0, [sp, #0x30]
;         attrs  = config->attrs;
7009bb4c: 980d         	ldr	r0, [sp, #0x34]
7009bb4e: 6800         	ldr	r0, [r0]
7009bb50: 900b         	str	r0, [sp, #0x2c]
;         DebugP_assert(NULL_PTR != object);
7009bb52: 980c         	ldr	r0, [sp, #0x30]
7009bb54: 2800         	cmp	r0, #0x0
7009bb56: bf18         	it	ne
7009bb58: 2001         	movne	r0, #0x1
7009bb5a: f641 71ce    	movw	r1, #0x1fce
7009bb5e: f2c7 010b    	movt	r1, #0x700b
7009bb62: 466a         	mov	r2, sp
7009bb64: 6011         	str	r1, [r2]
7009bb66: f641 71e1    	movw	r1, #0x1fe1
7009bb6a: f2c7 010b    	movt	r1, #0x700b
7009bb6e: f242 124b    	movw	r2, #0x214b
7009bb72: f2c7 020b    	movt	r2, #0x700b
7009bb76: f44f 7384    	mov.w	r3, #0x108
7009bb7a: f00f f881    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xf102
;         if(TRUE == object->isOpen)
7009bb7e: 980c         	ldr	r0, [sp, #0x30]
7009bb80: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009bb84: 2801         	cmp	r0, #0x1
7009bb86: d104         	bne	0x7009bb92 <UART_open+0xd2> @ imm = #0x8
7009bb88: e7ff         	b	0x7009bb8a <UART_open+0xca> @ imm = #-0x2
7009bb8a: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009bb8e: 900f         	str	r0, [sp, #0x3c]
;         }
7009bb90: e7ff         	b	0x7009bb92 <UART_open+0xd2> @ imm = #-0x2
;     }
7009bb92: e7ff         	b	0x7009bb94 <UART_open+0xd4> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009bb94: 980f         	ldr	r0, [sp, #0x3c]
7009bb96: 2800         	cmp	r0, #0x0
7009bb98: f040 80cd    	bne.w	0x7009bd36 <UART_open+0x276> @ imm = #0x19a
7009bb9c: e7ff         	b	0x7009bb9e <UART_open+0xde> @ imm = #-0x2
;         object->handle = (UART_Handle) config;
7009bb9e: 980d         	ldr	r0, [sp, #0x34]
7009bba0: 990c         	ldr	r1, [sp, #0x30]
7009bba2: 6008         	str	r0, [r1]
;         if(NULL != prms)
7009bba4: 9810         	ldr	r0, [sp, #0x40]
7009bba6: b138         	cbz	r0, 0x7009bbb8 <UART_open+0xf8> @ imm = #0xe
7009bba8: e7ff         	b	0x7009bbaa <UART_open+0xea> @ imm = #-0x2
;             ( void )memcpy(&object->prms, prms, sizeof(UART_Params));
7009bbaa: 980c         	ldr	r0, [sp, #0x30]
7009bbac: 3004         	adds	r0, #0x4
7009bbae: 9910         	ldr	r1, [sp, #0x40]
7009bbb0: 2258         	movs	r2, #0x58
7009bbb2: f7fe ea94    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0x1ad8
;         }
7009bbb6: e004         	b	0x7009bbc2 <UART_open+0x102> @ imm = #0x8
;             UART_Params_init(&object->prms);
7009bbb8: 980c         	ldr	r0, [sp, #0x30]
7009bbba: 3004         	adds	r0, #0x4
7009bbbc: f00f f8a0    	bl	0x700aad00 <UART_Params_init> @ imm = #0xf140
7009bbc0: e7ff         	b	0x7009bbc2 <UART_open+0x102> @ imm = #-0x2
;         object->uartLld_handle             = &object->uartLld_object;
7009bbc2: 990c         	ldr	r1, [sp, #0x30]
7009bbc4: f501 7022    	add.w	r0, r1, #0x288
7009bbc8: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle                     = object->uartLld_handle;
7009bbcc: 980c         	ldr	r0, [sp, #0x30]
7009bbce: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009bbd2: 9005         	str	r0, [sp, #0x14]
;         object->uartLld_initHandle         = &object->uartLld_initObject;
7009bbd4: 990c         	ldr	r1, [sp, #0x30]
7009bbd6: f501 7040    	add.w	r0, r1, #0x300
7009bbda: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;         uartLldInit_handle                 = object->uartLld_initHandle;
7009bbde: 980c         	ldr	r0, [sp, #0x30]
7009bbe0: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
7009bbe4: 9004         	str	r0, [sp, #0x10]
;         uartLld_handle->hUartInit          = uartLldInit_handle;
7009bbe6: 9804         	ldr	r0, [sp, #0x10]
7009bbe8: 9905         	ldr	r1, [sp, #0x14]
7009bbea: 6048         	str	r0, [r1, #0x4]
;         uartLld_handle->baseAddr           = attrs->baseAddr;
7009bbec: 980b         	ldr	r0, [sp, #0x2c]
7009bbee: 6800         	ldr	r0, [r0]
7009bbf0: 9905         	ldr	r1, [sp, #0x14]
7009bbf2: 6008         	str	r0, [r1]
;         uartLld_handle->args               = (void *)object->handle;
7009bbf4: 980c         	ldr	r0, [sp, #0x30]
7009bbf6: 6800         	ldr	r0, [r0]
7009bbf8: 9905         	ldr	r1, [sp, #0x14]
7009bbfa: 6608         	str	r0, [r1, #0x60]
;         uartLld_handle->writeBuf           = object->writeBuf;
7009bbfc: 980c         	ldr	r0, [sp, #0x30]
7009bbfe: 6dc0         	ldr	r0, [r0, #0x5c]
7009bc00: 9905         	ldr	r1, [sp, #0x14]
7009bc02: 6088         	str	r0, [r1, #0x8]
;         uartLld_handle->writeCount         = object->writeCount;
7009bc04: 980c         	ldr	r0, [sp, #0x30]
7009bc06: 6e00         	ldr	r0, [r0, #0x60]
7009bc08: 9905         	ldr	r1, [sp, #0x14]
7009bc0a: 60c8         	str	r0, [r1, #0xc]
;         uartLld_handle->writeSizeRemaining = object->writeSizeRemaining;
7009bc0c: 980c         	ldr	r0, [sp, #0x30]
7009bc0e: 6e40         	ldr	r0, [r0, #0x64]
7009bc10: 9905         	ldr	r1, [sp, #0x14]
7009bc12: 6108         	str	r0, [r1, #0x10]
;         uartLld_handle->readBuf            = object->readBuf;
7009bc14: 980c         	ldr	r0, [sp, #0x30]
7009bc16: 6e80         	ldr	r0, [r0, #0x68]
7009bc18: 9905         	ldr	r1, [sp, #0x14]
7009bc1a: 6148         	str	r0, [r1, #0x14]
;         uartLld_handle->readCount          = object->readCount;
7009bc1c: 980c         	ldr	r0, [sp, #0x30]
7009bc1e: 6ec0         	ldr	r0, [r0, #0x6c]
7009bc20: 9905         	ldr	r1, [sp, #0x14]
7009bc22: 6188         	str	r0, [r1, #0x18]
;         uartLld_handle->readSizeRemaining  = object->readSizeRemaining;
7009bc24: 980c         	ldr	r0, [sp, #0x30]
7009bc26: 6f00         	ldr	r0, [r0, #0x70]
7009bc28: 9905         	ldr	r1, [sp, #0x14]
7009bc2a: 61c8         	str	r0, [r1, #0x1c]
;         uartLld_handle->rxTimeoutCnt       = object->rxTimeoutCnt;
7009bc2c: 980c         	ldr	r0, [sp, #0x30]
7009bc2e: 6f40         	ldr	r0, [r0, #0x74]
7009bc30: 9905         	ldr	r1, [sp, #0x14]
7009bc32: 6208         	str	r0, [r1, #0x20]
;         uartLld_handle->readErrorCnt       = object->readErrorCnt;
7009bc34: 980c         	ldr	r0, [sp, #0x30]
7009bc36: 6f80         	ldr	r0, [r0, #0x78]
7009bc38: 9905         	ldr	r1, [sp, #0x14]
7009bc3a: 6248         	str	r0, [r1, #0x24]
;         uartLld_handle->state              = UART_STATE_RESET;
7009bc3c: 9905         	ldr	r1, [sp, #0x14]
7009bc3e: 2000         	movs	r0, #0x0
7009bc40: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->inputClkFreq      = attrs->inputClkFreq;
7009bc42: 990b         	ldr	r1, [sp, #0x2c]
7009bc44: 6849         	ldr	r1, [r1, #0x4]
7009bc46: 9a04         	ldr	r2, [sp, #0x10]
7009bc48: 6011         	str	r1, [r2]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009bc4a: 990c         	ldr	r1, [sp, #0x30]
7009bc4c: 6849         	ldr	r1, [r1, #0x4]
7009bc4e: 9a04         	ldr	r2, [sp, #0x10]
7009bc50: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->baudRate          = object->prms.baudRate;
7009bc52: 990c         	ldr	r1, [sp, #0x30]
7009bc54: 6849         	ldr	r1, [r1, #0x4]
7009bc56: 9a04         	ldr	r2, [sp, #0x10]
7009bc58: 6051         	str	r1, [r2, #0x4]
;         uartLldInit_handle->dataLength        = object->prms.dataLength;
7009bc5a: 990c         	ldr	r1, [sp, #0x30]
7009bc5c: 6889         	ldr	r1, [r1, #0x8]
7009bc5e: 9a04         	ldr	r2, [sp, #0x10]
7009bc60: 6091         	str	r1, [r2, #0x8]
;         uartLldInit_handle->stopBits          = object->prms.stopBits;
7009bc62: 990c         	ldr	r1, [sp, #0x30]
7009bc64: 68c9         	ldr	r1, [r1, #0xc]
7009bc66: 9a04         	ldr	r2, [sp, #0x10]
7009bc68: 60d1         	str	r1, [r2, #0xc]
;         uartLldInit_handle->parityType        = object->prms.parityType;
7009bc6a: 990c         	ldr	r1, [sp, #0x30]
7009bc6c: 6909         	ldr	r1, [r1, #0x10]
7009bc6e: 9a04         	ldr	r2, [sp, #0x10]
7009bc70: 6111         	str	r1, [r2, #0x10]
;         uartLldInit_handle->readReturnMode    = object->prms.readReturnMode;
7009bc72: 990c         	ldr	r1, [sp, #0x30]
7009bc74: 6989         	ldr	r1, [r1, #0x18]
7009bc76: 9a04         	ldr	r2, [sp, #0x10]
7009bc78: 6151         	str	r1, [r2, #0x14]
;         uartLldInit_handle->hwFlowControl     = object->prms.hwFlowControl;
7009bc7a: 990c         	ldr	r1, [sp, #0x30]
7009bc7c: 6a89         	ldr	r1, [r1, #0x28]
7009bc7e: 9a04         	ldr	r2, [sp, #0x10]
7009bc80: 6191         	str	r1, [r2, #0x18]
;         uartLldInit_handle->hwFlowControlThr  = object->prms.hwFlowControlThr;
7009bc82: 990c         	ldr	r1, [sp, #0x30]
7009bc84: 6ac9         	ldr	r1, [r1, #0x2c]
7009bc86: 9a04         	ldr	r2, [sp, #0x10]
7009bc88: 61d1         	str	r1, [r2, #0x1c]
;         uartLldInit_handle->intrNum           = object->prms.intrNum;
7009bc8a: 990c         	ldr	r1, [sp, #0x30]
7009bc8c: 6b49         	ldr	r1, [r1, #0x34]
7009bc8e: 9a04         	ldr	r2, [sp, #0x10]
7009bc90: 6251         	str	r1, [r2, #0x24]
;         uartLldInit_handle->transferMode      = object->prms.transferMode;
7009bc92: 990c         	ldr	r1, [sp, #0x30]
7009bc94: 6b09         	ldr	r1, [r1, #0x30]
7009bc96: 9a04         	ldr	r2, [sp, #0x10]
7009bc98: 6211         	str	r1, [r2, #0x20]
;         uartLldInit_handle->intrPriority      = object->prms.intrPriority;
7009bc9a: 990c         	ldr	r1, [sp, #0x30]
7009bc9c: f891 1038    	ldrb.w	r1, [r1, #0x38]
7009bca0: 9a04         	ldr	r2, [sp, #0x10]
7009bca2: f882 1028    	strb.w	r1, [r2, #0x28]
;         uartLldInit_handle->operMode          = object->prms.operMode;
7009bca6: 990c         	ldr	r1, [sp, #0x30]
7009bca8: 6c49         	ldr	r1, [r1, #0x44]
7009bcaa: 9a04         	ldr	r2, [sp, #0x10]
7009bcac: 62d1         	str	r1, [r2, #0x2c]
;         uartLldInit_handle->rxTrigLvl         = object->prms.rxTrigLvl;
7009bcae: 990c         	ldr	r1, [sp, #0x30]
7009bcb0: 6c89         	ldr	r1, [r1, #0x48]
7009bcb2: 9a04         	ldr	r2, [sp, #0x10]
7009bcb4: 6391         	str	r1, [r2, #0x38]
;         uartLldInit_handle->txTrigLvl         = object->prms.txTrigLvl;
7009bcb6: 990c         	ldr	r1, [sp, #0x30]
7009bcb8: 6cc9         	ldr	r1, [r1, #0x4c]
7009bcba: 9a04         	ldr	r2, [sp, #0x10]
7009bcbc: 63d1         	str	r1, [r2, #0x3c]
;         uartLldInit_handle->uartDmaHandle     = NULL;
7009bcbe: 9904         	ldr	r1, [sp, #0x10]
7009bcc0: 6488         	str	r0, [r1, #0x48]
;         uartLldInit_handle->dmaChCfg          = NULL;
7009bcc2: 9904         	ldr	r1, [sp, #0x10]
7009bcc4: 64c8         	str	r0, [r1, #0x4c]
;         uartLldInit_handle->rxEvtNum          = object->prms.rxEvtNum;
7009bcc6: 980c         	ldr	r0, [sp, #0x30]
7009bcc8: 6d00         	ldr	r0, [r0, #0x50]
7009bcca: 9904         	ldr	r1, [sp, #0x10]
7009bccc: 6408         	str	r0, [r1, #0x40]
;         uartLldInit_handle->txEvtNum          = object->prms.txEvtNum;
7009bcce: 980c         	ldr	r0, [sp, #0x30]
7009bcd0: 6d40         	ldr	r0, [r0, #0x54]
7009bcd2: 9904         	ldr	r1, [sp, #0x10]
7009bcd4: 6448         	str	r0, [r1, #0x44]
;         uartLldInit_handle->writeMode         = object->prms.writeMode;
7009bcd6: 980c         	ldr	r0, [sp, #0x30]
7009bcd8: 69c0         	ldr	r0, [r0, #0x1c]
7009bcda: 9904         	ldr	r1, [sp, #0x10]
7009bcdc: 6348         	str	r0, [r1, #0x34]
;         uartLldInit_handle->readMode          = object->prms.readMode;
7009bcde: 980c         	ldr	r0, [sp, #0x30]
7009bce0: 6940         	ldr	r0, [r0, #0x14]
7009bce2: 9904         	ldr	r1, [sp, #0x10]
7009bce4: 6308         	str	r0, [r1, #0x30]
;         uartLldInit_handle->timeGuardVal      = object->prms.timeGuardVal;
7009bce6: 980c         	ldr	r0, [sp, #0x30]
7009bce8: 6d80         	ldr	r0, [r0, #0x58]
7009bcea: 9904         	ldr	r1, [sp, #0x10]
7009bcec: 6508         	str	r0, [r1, #0x50]
;         uartLldInit_handle->clockP_get        = ClockP_getTicks;
7009bcee: 9904         	ldr	r1, [sp, #0x10]
7009bcf0: f64f 40e1    	movw	r0, #0xfce1
7009bcf4: f2c7 000a    	movt	r0, #0x700a
7009bcf8: 6548         	str	r0, [r1, #0x54]
;         uartLldInit_handle->clockP_usecToTick = ClockP_usecToTicks;
7009bcfa: 9904         	ldr	r1, [sp, #0x10]
7009bcfc: f24f 3021    	movw	r0, #0xf321
7009bd00: f2c7 000a    	movt	r0, #0x700a
7009bd04: 6588         	str	r0, [r1, #0x58]
;         uartLldInit_handle->readCompleteCallbackFxn =  UART_lld_readCompleteCallback;
7009bd06: 9904         	ldr	r1, [sp, #0x10]
7009bd08: f24c 7021    	movw	r0, #0xc721
7009bd0c: f2c7 000a    	movt	r0, #0x700a
7009bd10: 65c8         	str	r0, [r1, #0x5c]
;         uartLldInit_handle->writeCompleteCallbackFxn = UART_lld_writeCompleteCallback;
7009bd12: 9904         	ldr	r1, [sp, #0x10]
7009bd14: f24c 6061    	movw	r0, #0xc661
7009bd18: f2c7 000a    	movt	r0, #0x700a
7009bd1c: 6608         	str	r0, [r1, #0x60]
;         uartLldInit_handle->errorCallbackFxn =         UART_lld_errorCallback;
7009bd1e: 9904         	ldr	r1, [sp, #0x10]
7009bd20: f64f 40f1    	movw	r0, #0xfcf1
7009bd24: f2c7 000a    	movt	r0, #0x700a
7009bd28: 6648         	str	r0, [r1, #0x64]
;         status = UART_checkOpenParams(&object->prms);
7009bd2a: 980c         	ldr	r0, [sp, #0x30]
7009bd2c: 3004         	adds	r0, #0x4
7009bd2e: f011 fecf    	bl	0x700adad0 <UART_checkOpenParams> @ imm = #0x11d9e
7009bd32: 900f         	str	r0, [sp, #0x3c]
;     }
7009bd34: e7ff         	b	0x7009bd36 <UART_open+0x276> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009bd36: 980f         	ldr	r0, [sp, #0x3c]
7009bd38: 2800         	cmp	r0, #0x0
7009bd3a: f040 80b8    	bne.w	0x7009beae <UART_open+0x3ee> @ imm = #0x170
7009bd3e: e7ff         	b	0x7009bd40 <UART_open+0x280> @ imm = #-0x2
;         uartLld_handle->state = UART_STATE_RESET;
7009bd40: 9905         	ldr	r1, [sp, #0x14]
7009bd42: 2000         	movs	r0, #0x0
7009bd44: 6548         	str	r0, [r1, #0x54]
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
7009bd46: 980c         	ldr	r0, [sp, #0x30]
7009bd48: 6b00         	ldr	r0, [r0, #0x30]
7009bd4a: 2803         	cmp	r0, #0x3
7009bd4c: d117         	bne	0x7009bd7e <UART_open+0x2be> @ imm = #0x2e
7009bd4e: e7ff         	b	0x7009bd50 <UART_open+0x290> @ imm = #-0x2
;             uartLldInit_handle->uartDmaHandle = (UART_DmaHandle) gUartDmaHandle[index];
7009bd50: 9911         	ldr	r1, [sp, #0x44]
7009bd52: f242 6070    	movw	r0, #0x2670
7009bd56: f2c7 000b    	movt	r0, #0x700b
7009bd5a: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009bd5e: 9904         	ldr	r1, [sp, #0x10]
7009bd60: 6488         	str	r0, [r1, #0x48]
;             uartLldInit_handle->dmaChCfg      = gUartDmaChConfig[index];
7009bd62: 9911         	ldr	r1, [sp, #0x44]
7009bd64: f642 10f0    	movw	r0, #0x29f0
7009bd68: f2c7 000b    	movt	r0, #0x700b
7009bd6c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
7009bd70: 9904         	ldr	r1, [sp, #0x10]
7009bd72: 64c8         	str	r0, [r1, #0x4c]
;             status = UART_lld_initDma(uartLld_handle);
7009bd74: 9805         	ldr	r0, [sp, #0x14]
7009bd76: f006 f933    	bl	0x700a1fe0 <UART_lld_initDma> @ imm = #0x6266
7009bd7a: 900f         	str	r0, [sp, #0x3c]
;         }
7009bd7c: e008         	b	0x7009bd90 <UART_open+0x2d0> @ imm = #0x10
;             status = UART_lld_init(uartLld_handle);
7009bd7e: 9805         	ldr	r0, [sp, #0x14]
7009bd80: f007 fb4e    	bl	0x700a3420 <UART_lld_init> @ imm = #0x769c
7009bd84: 900f         	str	r0, [sp, #0x3c]
;             object->uartDmaHandle = NULL;
7009bd86: 990c         	ldr	r1, [sp, #0x30]
7009bd88: 2000         	movs	r0, #0x0
7009bd8a: f8c1 0280    	str.w	r0, [r1, #0x280]
7009bd8e: e7ff         	b	0x7009bd90 <UART_open+0x2d0> @ imm = #-0x2
;         if(SystemP_SUCCESS == status)
7009bd90: 980f         	ldr	r0, [sp, #0x3c]
7009bd92: 2800         	cmp	r0, #0x0
7009bd94: f040 808a    	bne.w	0x7009beac <UART_open+0x3ec> @ imm = #0x114
7009bd98: e7ff         	b	0x7009bd9a <UART_open+0x2da> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&object->lockObj);
7009bd9a: 980c         	ldr	r0, [sp, #0x30]
7009bd9c: 308c         	adds	r0, #0x8c
7009bd9e: f00f fc47    	bl	0x700ab630 <SemaphoreP_constructMutex> @ imm = #0xf88e
7009bda2: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bda4: 980f         	ldr	r0, [sp, #0x3c]
7009bda6: b930         	cbnz	r0, 0x7009bdb6 <UART_open+0x2f6> @ imm = #0xc
7009bda8: e7ff         	b	0x7009bdaa <UART_open+0x2ea> @ imm = #-0x2
;                 object->lock = &object->lockObj;
7009bdaa: 990c         	ldr	r1, [sp, #0x30]
7009bdac: f101 008c    	add.w	r0, r1, #0x8c
7009bdb0: f8c1 0088    	str.w	r0, [r1, #0x88]
;             }
7009bdb4: e7ff         	b	0x7009bdb6 <UART_open+0x2f6> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->readTransferSemObj, 0U);
7009bdb6: 980c         	ldr	r0, [sp, #0x30]
7009bdb8: f500 7094    	add.w	r0, r0, #0x128
7009bdbc: 2100         	movs	r1, #0x0
7009bdbe: f00c f8bf    	bl	0x700a7f40 <SemaphoreP_constructBinary> @ imm = #0xc17e
7009bdc2: 4601         	mov	r1, r0
7009bdc4: 980f         	ldr	r0, [sp, #0x3c]
7009bdc6: 4408         	add	r0, r1
7009bdc8: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bdca: 980f         	ldr	r0, [sp, #0x3c]
7009bdcc: b958         	cbnz	r0, 0x7009bde6 <UART_open+0x326> @ imm = #0x16
7009bdce: e7ff         	b	0x7009bdd0 <UART_open+0x310> @ imm = #-0x2
;                 object->readTransferSem = &object->readTransferSemObj;
7009bdd0: 990c         	ldr	r1, [sp, #0x30]
7009bdd2: f501 7094    	add.w	r0, r1, #0x128
7009bdd6: f8c1 0124    	str.w	r0, [r1, #0x124]
;                 uartLld_handle->readTransferMutex = object->readTransferSem;
7009bdda: 980c         	ldr	r0, [sp, #0x30]
7009bddc: f8d0 0124    	ldr.w	r0, [r0, #0x124]
7009bde0: 9905         	ldr	r1, [sp, #0x14]
7009bde2: 6588         	str	r0, [r1, #0x58]
;             }
7009bde4: e7ff         	b	0x7009bde6 <UART_open+0x326> @ imm = #-0x2
;             status += SemaphoreP_constructBinary(&object->writeTransferSemObj, 0U);
7009bde6: 980c         	ldr	r0, [sp, #0x30]
7009bde8: f500 70e2    	add.w	r0, r0, #0x1c4
7009bdec: 2100         	movs	r1, #0x0
7009bdee: f00c f8a7    	bl	0x700a7f40 <SemaphoreP_constructBinary> @ imm = #0xc14e
7009bdf2: 4601         	mov	r1, r0
7009bdf4: 980f         	ldr	r0, [sp, #0x3c]
7009bdf6: 4408         	add	r0, r1
7009bdf8: 900f         	str	r0, [sp, #0x3c]
;             if(SystemP_SUCCESS == status)
7009bdfa: 980f         	ldr	r0, [sp, #0x3c]
7009bdfc: b958         	cbnz	r0, 0x7009be16 <UART_open+0x356> @ imm = #0x16
7009bdfe: e7ff         	b	0x7009be00 <UART_open+0x340> @ imm = #-0x2
;                 object->writeTransferSem = &object->writeTransferSemObj;
7009be00: 990c         	ldr	r1, [sp, #0x30]
7009be02: f501 70e2    	add.w	r0, r1, #0x1c4
7009be06: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;                 uartLld_handle->writeTransferMutex = object->writeTransferSem;
7009be0a: 980c         	ldr	r0, [sp, #0x30]
7009be0c: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
7009be10: 9905         	ldr	r1, [sp, #0x14]
7009be12: 65c8         	str	r0, [r1, #0x5c]
;             }
7009be14: e7ff         	b	0x7009be16 <UART_open+0x356> @ imm = #-0x2
;             if((UART_CONFIG_MODE_INTERRUPT == object->prms.transferMode) && (TRUE != object->prms.skipIntrReg))
7009be16: 980c         	ldr	r0, [sp, #0x30]
7009be18: 6b00         	ldr	r0, [r0, #0x30]
7009be1a: 2801         	cmp	r0, #0x1
7009be1c: d145         	bne	0x7009beaa <UART_open+0x3ea> @ imm = #0x8a
7009be1e: e7ff         	b	0x7009be20 <UART_open+0x360> @ imm = #-0x2
7009be20: 980c         	ldr	r0, [sp, #0x30]
7009be22: 6bc0         	ldr	r0, [r0, #0x3c]
7009be24: 2801         	cmp	r0, #0x1
7009be26: d040         	beq	0x7009beaa <UART_open+0x3ea> @ imm = #0x80
7009be28: e7ff         	b	0x7009be2a <UART_open+0x36a> @ imm = #-0x2
;                 DebugP_assert(object->prms.intrNum != 0xFFFFU);
7009be2a: 980c         	ldr	r0, [sp, #0x30]
7009be2c: 6b40         	ldr	r0, [r0, #0x34]
7009be2e: f64f 71ff    	movw	r1, #0xffff
7009be32: 1a40         	subs	r0, r0, r1
7009be34: bf18         	it	ne
7009be36: 2001         	movne	r0, #0x1
7009be38: f641 41e7    	movw	r1, #0x1ce7
7009be3c: f2c7 010b    	movt	r1, #0x700b
7009be40: 466a         	mov	r2, sp
7009be42: 6011         	str	r1, [r2]
7009be44: f641 71e1    	movw	r1, #0x1fe1
7009be48: f2c7 010b    	movt	r1, #0x700b
7009be4c: f242 124b    	movw	r2, #0x214b
7009be50: f2c7 020b    	movt	r2, #0x700b
7009be54: f44f 73bf    	mov.w	r3, #0x17e
7009be58: f00e ff12    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xee24
7009be5c: a806         	add	r0, sp, #0x18
;                 HwiP_Params_init(&hwiPrms);
7009be5e: 9002         	str	r0, [sp, #0x8]
7009be60: f014 f876    	bl	0x700aff50 <HwiP_Params_init> @ imm = #0x140ec
7009be64: 9902         	ldr	r1, [sp, #0x8]
;                 hwiPrms.intNum      = object->prms.intrNum;
7009be66: 980c         	ldr	r0, [sp, #0x30]
7009be68: 6b40         	ldr	r0, [r0, #0x34]
7009be6a: 9006         	str	r0, [sp, #0x18]
;                 hwiPrms.callback    = &UART_lld_controllerIsr;
7009be6c: f240 20f1    	movw	r0, #0x2f1
7009be70: f2c7 000a    	movt	r0, #0x700a
7009be74: 9007         	str	r0, [sp, #0x1c]
;                 hwiPrms.priority    = object->prms.intrPriority;
7009be76: 980c         	ldr	r0, [sp, #0x30]
7009be78: f890 0038    	ldrb.w	r0, [r0, #0x38]
7009be7c: f88d 0026    	strb.w	r0, [sp, #0x26]
;                 hwiPrms.args        = (void *) uartLld_handle;
7009be80: 9805         	ldr	r0, [sp, #0x14]
7009be82: 9008         	str	r0, [sp, #0x20]
;                 status += HwiP_construct(&object->hwiObj, &hwiPrms);
7009be84: 980c         	ldr	r0, [sp, #0x30]
7009be86: f500 7018    	add.w	r0, r0, #0x260
7009be8a: f014 f879    	bl	0x700aff80 <HwiP_construct> @ imm = #0x140f2
7009be8e: 4601         	mov	r1, r0
7009be90: 980f         	ldr	r0, [sp, #0x3c]
7009be92: 4408         	add	r0, r1
7009be94: 900f         	str	r0, [sp, #0x3c]
;                 if(SystemP_SUCCESS == status)
7009be96: 980f         	ldr	r0, [sp, #0x3c]
7009be98: b930         	cbnz	r0, 0x7009bea8 <UART_open+0x3e8> @ imm = #0xc
7009be9a: e7ff         	b	0x7009be9c <UART_open+0x3dc> @ imm = #-0x2
;                     object->hwiHandle = &object->hwiObj;
7009be9c: 990c         	ldr	r1, [sp, #0x30]
7009be9e: f501 7018    	add.w	r0, r1, #0x260
7009bea2: f8c1 025c    	str.w	r0, [r1, #0x25c]
;                 }
7009bea6: e7ff         	b	0x7009bea8 <UART_open+0x3e8> @ imm = #-0x2
;             }
7009bea8: e7ff         	b	0x7009beaa <UART_open+0x3ea> @ imm = #-0x2
;         }
7009beaa: e7ff         	b	0x7009beac <UART_open+0x3ec> @ imm = #-0x2
;     }
7009beac: e7ff         	b	0x7009beae <UART_open+0x3ee> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
7009beae: 980f         	ldr	r0, [sp, #0x3c]
7009beb0: b938         	cbnz	r0, 0x7009bec2 <UART_open+0x402> @ imm = #0xe
7009beb2: e7ff         	b	0x7009beb4 <UART_open+0x3f4> @ imm = #-0x2
;         object->isOpen = TRUE;
7009beb4: 990c         	ldr	r1, [sp, #0x30]
7009beb6: 2001         	movs	r0, #0x1
7009beb8: f8c1 0084    	str.w	r0, [r1, #0x84]
;         handle = (UART_Handle) config;
7009bebc: 980d         	ldr	r0, [sp, #0x34]
7009bebe: 900e         	str	r0, [sp, #0x38]
;     }
7009bec0: e7ff         	b	0x7009bec2 <UART_open+0x402> @ imm = #-0x2
;     SemaphoreP_post(&gUartDrvObj.lockObj);
7009bec2: f242 7028    	movw	r0, #0x2728
7009bec6: f2c7 000b    	movt	r0, #0x700b
7009beca: 3004         	adds	r0, #0x4
7009becc: f010 f810    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x10020
;     if(SystemP_SUCCESS != status)
7009bed0: 980f         	ldr	r0, [sp, #0x3c]
7009bed2: b140         	cbz	r0, 0x7009bee6 <UART_open+0x426> @ imm = #0x10
7009bed4: e7ff         	b	0x7009bed6 <UART_open+0x416> @ imm = #-0x2
;         if(NULL != config)
7009bed6: 980d         	ldr	r0, [sp, #0x34]
7009bed8: b120         	cbz	r0, 0x7009bee4 <UART_open+0x424> @ imm = #0x8
7009beda: e7ff         	b	0x7009bedc <UART_open+0x41c> @ imm = #-0x2
;             UART_close((UART_Handle) config);
7009bedc: 980d         	ldr	r0, [sp, #0x34]
7009bede: f004 f84f    	bl	0x7009ff80 <UART_close> @ imm = #0x409e
;         }
7009bee2: e7ff         	b	0x7009bee4 <UART_open+0x424> @ imm = #-0x2
;     }
7009bee4: e7ff         	b	0x7009bee6 <UART_open+0x426> @ imm = #-0x2
;     return (handle);
7009bee6: 980e         	ldr	r0, [sp, #0x38]
7009bee8: b012         	add	sp, #0x48
7009beea: bd80         	pop	{r7, pc}
7009beec: 0000         	movs	r0, r0
7009beee: 0000         	movs	r0, r0

7009bef0 <Udma_chAllocResource>:
; {
7009bef0: b580         	push	{r7, lr}
7009bef2: b088         	sub	sp, #0x20
7009bef4: 9007         	str	r0, [sp, #0x1c]
7009bef6: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK, tempRetVal;
7009bef8: 9006         	str	r0, [sp, #0x18]
7009befa: f64f 70ff    	movw	r0, #0xffff
;     uint16_t                ringNum = UDMA_RING_INVALID;
7009befe: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     drvHandle = chHandle->drvHandle;
7009bf02: 9807         	ldr	r0, [sp, #0x1c]
7009bf04: 6e80         	ldr	r0, [r0, #0x68]
7009bf06: 9004         	str	r0, [sp, #0x10]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009bf08: 9807         	ldr	r0, [sp, #0x1c]
7009bf0a: 7800         	ldrb	r0, [r0]
7009bf0c: 0740         	lsls	r0, r0, #0x1d
7009bf0e: 2800         	cmp	r0, #0x0
7009bf10: d54d         	bpl	0x7009bfae <Udma_chAllocResource+0xbe> @ imm = #0x9a
7009bf12: e7ff         	b	0x7009bf14 <Udma_chAllocResource+0x24> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009bf14: 9807         	ldr	r0, [sp, #0x1c]
7009bf16: 7800         	ldrb	r0, [r0]
7009bf18: 0640         	lsls	r0, r0, #0x19
7009bf1a: 2800         	cmp	r0, #0x0
7009bf1c: d508         	bpl	0x7009bf30 <Udma_chAllocResource+0x40> @ imm = #0x10
7009bf1e: e7ff         	b	0x7009bf20 <Udma_chAllocResource+0x30> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyHcCh(chHandle->chPrms.chNum, drvHandle);
7009bf20: 9807         	ldr	r0, [sp, #0x1c]
7009bf22: 6840         	ldr	r0, [r0, #0x4]
7009bf24: 9904         	ldr	r1, [sp, #0x10]
7009bf26: f007 fd73    	bl	0x700a3a10 <Udma_rmAllocBlkCopyHcCh> @ imm = #0x7ae6
;             chHandle->txChNum =
7009bf2a: 9907         	ldr	r1, [sp, #0x1c]
7009bf2c: 66c8         	str	r0, [r1, #0x6c]
;         }
7009bf2e: e016         	b	0x7009bf5e <Udma_chAllocResource+0x6e> @ imm = #0x2c
;         else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009bf30: 9807         	ldr	r0, [sp, #0x1c]
7009bf32: 7800         	ldrb	r0, [r0]
7009bf34: 0600         	lsls	r0, r0, #0x18
7009bf36: 2800         	cmp	r0, #0x0
7009bf38: d508         	bpl	0x7009bf4c <Udma_chAllocResource+0x5c> @ imm = #0x10
7009bf3a: e7ff         	b	0x7009bf3c <Udma_chAllocResource+0x4c> @ imm = #-0x2
;                 Udma_rmAllocBlkCopyUhcCh(chHandle->chPrms.chNum, drvHandle);
7009bf3c: 9807         	ldr	r0, [sp, #0x1c]
7009bf3e: 6840         	ldr	r0, [r0, #0x4]
7009bf40: 9904         	ldr	r1, [sp, #0x10]
7009bf42: f007 fdfd    	bl	0x700a3b40 <Udma_rmAllocBlkCopyUhcCh> @ imm = #0x7bfa
;             chHandle->txChNum =
7009bf46: 9907         	ldr	r1, [sp, #0x1c]
7009bf48: 66c8         	str	r0, [r1, #0x6c]
;         }
7009bf4a: e007         	b	0x7009bf5c <Udma_chAllocResource+0x6c> @ imm = #0xe
;                 Udma_rmAllocBlkCopyCh(chHandle->chPrms.chNum, drvHandle);
7009bf4c: 9807         	ldr	r0, [sp, #0x1c]
7009bf4e: 6840         	ldr	r0, [r0, #0x4]
7009bf50: 9904         	ldr	r1, [sp, #0x10]
7009bf52: f007 fcc5    	bl	0x700a38e0 <Udma_rmAllocBlkCopyCh> @ imm = #0x798a
;             chHandle->txChNum =
7009bf56: 9907         	ldr	r1, [sp, #0x1c]
7009bf58: 66c8         	str	r0, [r1, #0x6c]
7009bf5a: e7ff         	b	0x7009bf5c <Udma_chAllocResource+0x6c> @ imm = #-0x2
7009bf5c: e7ff         	b	0x7009bf5e <Udma_chAllocResource+0x6e> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009bf5e: 9807         	ldr	r0, [sp, #0x1c]
7009bf60: 6ec0         	ldr	r0, [r0, #0x6c]
7009bf62: f510 3f80    	cmn.w	r0, #0x10000
7009bf66: d104         	bne	0x7009bf72 <Udma_chAllocResource+0x82> @ imm = #0x8
7009bf68: e7ff         	b	0x7009bf6a <Udma_chAllocResource+0x7a> @ imm = #-0x2
7009bf6a: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009bf6e: 9006         	str	r0, [sp, #0x18]
;         }
7009bf70: e01c         	b	0x7009bfac <Udma_chAllocResource+0xbc> @ imm = #0x38
;             if (UDMA_INST_TYPE_LCDMA_BCDMA == chHandle->drvHandle->instType)
7009bf72: 9807         	ldr	r0, [sp, #0x1c]
7009bf74: 6e80         	ldr	r0, [r0, #0x68]
7009bf76: 6800         	ldr	r0, [r0]
7009bf78: 2801         	cmp	r0, #0x1
7009bf7a: d10b         	bne	0x7009bf94 <Udma_chAllocResource+0xa4> @ imm = #0x16
7009bf7c: e7ff         	b	0x7009bf7e <Udma_chAllocResource+0x8e> @ imm = #-0x2
;                 chHandle->rxChNum     = UDMA_DMA_CH_INVALID;
7009bf7e: 9907         	ldr	r1, [sp, #0x1c]
7009bf80: 2000         	movs	r0, #0x0
7009bf82: f6cf 70ff    	movt	r0, #0xffff
7009bf86: 6708         	str	r0, [r1, #0x70]
;                 chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009bf88: 9907         	ldr	r1, [sp, #0x1c]
7009bf8a: 2004         	movs	r0, #0x4
7009bf8c: f6cf 70ff    	movt	r0, #0xffff
7009bf90: 67c8         	str	r0, [r1, #0x7c]
;             }
7009bf92: e00a         	b	0x7009bfaa <Udma_chAllocResource+0xba> @ imm = #0x14
;                 chHandle->rxChNum = chHandle->txChNum;
7009bf94: 9907         	ldr	r1, [sp, #0x1c]
7009bf96: 6ec8         	ldr	r0, [r1, #0x6c]
7009bf98: 6708         	str	r0, [r1, #0x70]
;                     chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
7009bf9a: 9907         	ldr	r1, [sp, #0x1c]
7009bf9c: 6f08         	ldr	r0, [r1, #0x70]
7009bf9e: 9a04         	ldr	r2, [sp, #0x10]
7009bfa0: f8d2 20d8    	ldr.w	r2, [r2, #0xd8]
7009bfa4: 4410         	add	r0, r2
;                 chHandle->peerThreadId =
7009bfa6: 67c8         	str	r0, [r1, #0x7c]
7009bfa8: e7ff         	b	0x7009bfaa <Udma_chAllocResource+0xba> @ imm = #-0x2
7009bfaa: e7ff         	b	0x7009bfac <Udma_chAllocResource+0xbc> @ imm = #-0x2
;     }
7009bfac: e0bd         	b	0x7009c12a <Udma_chAllocResource+0x23a> @ imm = #0x17a
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009bfae: 9807         	ldr	r0, [sp, #0x1c]
7009bfb0: 7800         	ldrb	r0, [r0]
7009bfb2: 07c0         	lsls	r0, r0, #0x1f
7009bfb4: 2800         	cmp	r0, #0x0
7009bfb6: d03f         	beq	0x7009c038 <Udma_chAllocResource+0x148> @ imm = #0x7e
7009bfb8: e7ff         	b	0x7009bfba <Udma_chAllocResource+0xca> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009bfba: 9807         	ldr	r0, [sp, #0x1c]
7009bfbc: 7800         	ldrb	r0, [r0]
7009bfbe: 0640         	lsls	r0, r0, #0x19
7009bfc0: 2800         	cmp	r0, #0x0
7009bfc2: d508         	bpl	0x7009bfd6 <Udma_chAllocResource+0xe6> @ imm = #0x10
7009bfc4: e7ff         	b	0x7009bfc6 <Udma_chAllocResource+0xd6> @ imm = #-0x2
;                     Udma_rmAllocTxHcCh(chHandle->chPrms.chNum, drvHandle);
7009bfc6: 9807         	ldr	r0, [sp, #0x1c]
7009bfc8: 6840         	ldr	r0, [r0, #0x4]
7009bfca: 9904         	ldr	r1, [sp, #0x10]
7009bfcc: f008 f8b0    	bl	0x700a4130 <Udma_rmAllocTxHcCh> @ imm = #0x8160
;                 chHandle->txChNum =
7009bfd0: 9907         	ldr	r1, [sp, #0x1c]
7009bfd2: 66c8         	str	r0, [r1, #0x6c]
;             }
7009bfd4: e025         	b	0x7009c022 <Udma_chAllocResource+0x132> @ imm = #0x4a
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009bfd6: 9807         	ldr	r0, [sp, #0x1c]
7009bfd8: 7840         	ldrb	r0, [r0, #0x1]
7009bfda: 07c0         	lsls	r0, r0, #0x1f
7009bfdc: b148         	cbz	r0, 0x7009bff2 <Udma_chAllocResource+0x102> @ imm = #0x12
7009bfde: e7ff         	b	0x7009bfe0 <Udma_chAllocResource+0xf0> @ imm = #-0x2
;                     Udma_rmAllocMappedTxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009bfe0: 9a07         	ldr	r2, [sp, #0x1c]
7009bfe2: 9904         	ldr	r1, [sp, #0x10]
7009bfe4: 6850         	ldr	r0, [r2, #0x4]
7009bfe6: 68d2         	ldr	r2, [r2, #0xc]
7009bfe8: f005 fe9a    	bl	0x700a1d20 <Udma_rmAllocMappedTxCh> @ imm = #0x5d34
;                 chHandle->txChNum =
7009bfec: 9907         	ldr	r1, [sp, #0x1c]
7009bfee: 66c8         	str	r0, [r1, #0x6c]
;             }
7009bff0: e016         	b	0x7009c020 <Udma_chAllocResource+0x130> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009bff2: 9807         	ldr	r0, [sp, #0x1c]
7009bff4: 7800         	ldrb	r0, [r0]
7009bff6: 0600         	lsls	r0, r0, #0x18
7009bff8: 2800         	cmp	r0, #0x0
7009bffa: d508         	bpl	0x7009c00e <Udma_chAllocResource+0x11e> @ imm = #0x10
7009bffc: e7ff         	b	0x7009bffe <Udma_chAllocResource+0x10e> @ imm = #-0x2
;                     Udma_rmAllocTxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009bffe: 9807         	ldr	r0, [sp, #0x1c]
7009c000: 6840         	ldr	r0, [r0, #0x4]
7009c002: 9904         	ldr	r1, [sp, #0x10]
7009c004: f008 f92c    	bl	0x700a4260 <Udma_rmAllocTxUhcCh> @ imm = #0x8258
;                 chHandle->txChNum =
7009c008: 9907         	ldr	r1, [sp, #0x1c]
7009c00a: 66c8         	str	r0, [r1, #0x6c]
;             }
7009c00c: e007         	b	0x7009c01e <Udma_chAllocResource+0x12e> @ imm = #0xe
;                     Udma_rmAllocTxCh(chHandle->chPrms.chNum, drvHandle);
7009c00e: 9807         	ldr	r0, [sp, #0x1c]
7009c010: 6840         	ldr	r0, [r0, #0x4]
7009c012: 9904         	ldr	r1, [sp, #0x10]
7009c014: f007 fff4    	bl	0x700a4000 <Udma_rmAllocTxCh> @ imm = #0x7fe8
;                 chHandle->txChNum =
7009c018: 9907         	ldr	r1, [sp, #0x1c]
7009c01a: 66c8         	str	r0, [r1, #0x6c]
7009c01c: e7ff         	b	0x7009c01e <Udma_chAllocResource+0x12e> @ imm = #-0x2
7009c01e: e7ff         	b	0x7009c020 <Udma_chAllocResource+0x130> @ imm = #-0x2
7009c020: e7ff         	b	0x7009c022 <Udma_chAllocResource+0x132> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->txChNum)
7009c022: 9807         	ldr	r0, [sp, #0x1c]
7009c024: 6ec0         	ldr	r0, [r0, #0x6c]
7009c026: f510 3f80    	cmn.w	r0, #0x10000
7009c02a: d104         	bne	0x7009c036 <Udma_chAllocResource+0x146> @ imm = #0x8
7009c02c: e7ff         	b	0x7009c02e <Udma_chAllocResource+0x13e> @ imm = #-0x2
7009c02e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009c032: 9006         	str	r0, [sp, #0x18]
;             }
7009c034: e7ff         	b	0x7009c036 <Udma_chAllocResource+0x146> @ imm = #-0x2
;         }
7009c036: e05c         	b	0x7009c0f2 <Udma_chAllocResource+0x202> @ imm = #0xb8
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009c038: 9807         	ldr	r0, [sp, #0x1c]
7009c03a: 7800         	ldrb	r0, [r0]
7009c03c: 0640         	lsls	r0, r0, #0x19
7009c03e: 2800         	cmp	r0, #0x0
7009c040: d508         	bpl	0x7009c054 <Udma_chAllocResource+0x164> @ imm = #0x10
7009c042: e7ff         	b	0x7009c044 <Udma_chAllocResource+0x154> @ imm = #-0x2
;                     Udma_rmAllocRxHcCh(chHandle->chPrms.chNum, drvHandle);
7009c044: 9807         	ldr	r0, [sp, #0x1c]
7009c046: 6840         	ldr	r0, [r0, #0x4]
7009c048: 9904         	ldr	r1, [sp, #0x10]
7009c04a: f007 fea9    	bl	0x700a3da0 <Udma_rmAllocRxHcCh> @ imm = #0x7d52
;                 chHandle->rxChNum =
7009c04e: 9907         	ldr	r1, [sp, #0x1c]
7009c050: 6708         	str	r0, [r1, #0x70]
;             }
7009c052: e026         	b	0x7009c0a2 <Udma_chAllocResource+0x1b2> @ imm = #0x4c
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009c054: 9807         	ldr	r0, [sp, #0x1c]
7009c056: 7840         	ldrb	r0, [r0, #0x1]
7009c058: 07c0         	lsls	r0, r0, #0x1f
7009c05a: b150         	cbz	r0, 0x7009c072 <Udma_chAllocResource+0x182> @ imm = #0x14
7009c05c: e7ff         	b	0x7009c05e <Udma_chAllocResource+0x16e> @ imm = #-0x2
;                     Udma_rmAllocMappedRxCh(chHandle->chPrms.chNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009c05e: 9a07         	ldr	r2, [sp, #0x1c]
7009c060: 9904         	ldr	r1, [sp, #0x10]
7009c062: 6850         	ldr	r0, [r2, #0x4]
7009c064: 68d2         	ldr	r2, [r2, #0xc]
7009c066: 3a04         	subs	r2, #0x4
7009c068: f005 fdaa    	bl	0x700a1bc0 <Udma_rmAllocMappedRxCh> @ imm = #0x5b54
;                 chHandle->rxChNum =
7009c06c: 9907         	ldr	r1, [sp, #0x1c]
7009c06e: 6708         	str	r0, [r1, #0x70]
;             }
7009c070: e016         	b	0x7009c0a0 <Udma_chAllocResource+0x1b0> @ imm = #0x2c
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009c072: 9807         	ldr	r0, [sp, #0x1c]
7009c074: 7800         	ldrb	r0, [r0]
7009c076: 0600         	lsls	r0, r0, #0x18
7009c078: 2800         	cmp	r0, #0x0
7009c07a: d508         	bpl	0x7009c08e <Udma_chAllocResource+0x19e> @ imm = #0x10
7009c07c: e7ff         	b	0x7009c07e <Udma_chAllocResource+0x18e> @ imm = #-0x2
;                     Udma_rmAllocRxUhcCh(chHandle->chPrms.chNum, drvHandle);
7009c07e: 9807         	ldr	r0, [sp, #0x1c]
7009c080: 6840         	ldr	r0, [r0, #0x4]
7009c082: 9904         	ldr	r1, [sp, #0x10]
7009c084: f007 ff24    	bl	0x700a3ed0 <Udma_rmAllocRxUhcCh> @ imm = #0x7e48
;                 chHandle->rxChNum =
7009c088: 9907         	ldr	r1, [sp, #0x1c]
7009c08a: 6708         	str	r0, [r1, #0x70]
;             }
7009c08c: e007         	b	0x7009c09e <Udma_chAllocResource+0x1ae> @ imm = #0xe
;                     Udma_rmAllocRxCh(chHandle->chPrms.chNum, drvHandle);
7009c08e: 9807         	ldr	r0, [sp, #0x1c]
7009c090: 6840         	ldr	r0, [r0, #0x4]
7009c092: 9904         	ldr	r1, [sp, #0x10]
7009c094: f007 fdec    	bl	0x700a3c70 <Udma_rmAllocRxCh> @ imm = #0x7bd8
;                 chHandle->rxChNum =
7009c098: 9907         	ldr	r1, [sp, #0x1c]
7009c09a: 6708         	str	r0, [r1, #0x70]
7009c09c: e7ff         	b	0x7009c09e <Udma_chAllocResource+0x1ae> @ imm = #-0x2
7009c09e: e7ff         	b	0x7009c0a0 <Udma_chAllocResource+0x1b0> @ imm = #-0x2
7009c0a0: e7ff         	b	0x7009c0a2 <Udma_chAllocResource+0x1b2> @ imm = #-0x2
;             if(UDMA_DMA_CH_INVALID == chHandle->rxChNum)
7009c0a2: 9807         	ldr	r0, [sp, #0x1c]
7009c0a4: 6f00         	ldr	r0, [r0, #0x70]
7009c0a6: f510 3f80    	cmn.w	r0, #0x10000
7009c0aa: d104         	bne	0x7009c0b6 <Udma_chAllocResource+0x1c6> @ imm = #0x8
7009c0ac: e7ff         	b	0x7009c0ae <Udma_chAllocResource+0x1be> @ imm = #-0x2
7009c0ae: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009c0b2: 9006         	str	r0, [sp, #0x18]
;             }
7009c0b4: e01c         	b	0x7009c0f0 <Udma_chAllocResource+0x200> @ imm = #0x38
;                 chHandle->defaultFlow               = &chHandle->defaultFlowObj;
7009c0b6: 9907         	ldr	r1, [sp, #0x1c]
7009c0b8: f501 70e6    	add.w	r0, r1, #0x1cc
7009c0bc: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
;                 chHandle->defaultFlow->drvHandle    = drvHandle;
7009c0c0: 9804         	ldr	r0, [sp, #0x10]
7009c0c2: 9907         	ldr	r1, [sp, #0x1c]
7009c0c4: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009c0c8: 6008         	str	r0, [r1]
;                 chHandle->defaultFlow->flowStart    = chHandle->rxChNum;
7009c0ca: 9907         	ldr	r1, [sp, #0x1c]
7009c0cc: 6f08         	ldr	r0, [r1, #0x70]
7009c0ce: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009c0d2: 6048         	str	r0, [r1, #0x4]
;                 chHandle->defaultFlow->flowCnt      = 1U;
7009c0d4: 9807         	ldr	r0, [sp, #0x1c]
7009c0d6: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009c0da: 2001         	movs	r0, #0x1
7009c0dc: 6088         	str	r0, [r1, #0x8]
;                 chHandle->defaultFlow->flowInitDone = UDMA_INIT_DONE;
7009c0de: 9807         	ldr	r0, [sp, #0x1c]
7009c0e0: f8d0 11c8    	ldr.w	r1, [r0, #0x1c8]
7009c0e4: f64a 30cd    	movw	r0, #0xabcd
7009c0e8: f6ca 30dc    	movt	r0, #0xabdc
7009c0ec: 60c8         	str	r0, [r1, #0xc]
7009c0ee: e7ff         	b	0x7009c0f0 <Udma_chAllocResource+0x200> @ imm = #-0x2
7009c0f0: e7ff         	b	0x7009c0f2 <Udma_chAllocResource+0x202> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
7009c0f2: 9806         	ldr	r0, [sp, #0x18]
7009c0f4: b9c0         	cbnz	r0, 0x7009c128 <Udma_chAllocResource+0x238> @ imm = #0x30
7009c0f6: e7ff         	b	0x7009c0f8 <Udma_chAllocResource+0x208> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
7009c0f8: 9807         	ldr	r0, [sp, #0x1c]
7009c0fa: 7800         	ldrb	r0, [r0]
7009c0fc: 0700         	lsls	r0, r0, #0x1c
7009c0fe: 2800         	cmp	r0, #0x0
7009c100: d507         	bpl	0x7009c112 <Udma_chAllocResource+0x222> @ imm = #0xe
7009c102: e7ff         	b	0x7009c104 <Udma_chAllocResource+0x214> @ imm = #-0x2
;                 chHandle->pdmaChNum = chHandle->chPrms.peerChNum;
7009c104: 9907         	ldr	r1, [sp, #0x1c]
7009c106: 6888         	ldr	r0, [r1, #0x8]
7009c108: 6788         	str	r0, [r1, #0x78]
;                 chHandle->peerThreadId = chHandle->pdmaChNum;
7009c10a: 9907         	ldr	r1, [sp, #0x1c]
7009c10c: 6f88         	ldr	r0, [r1, #0x78]
7009c10e: 67c8         	str	r0, [r1, #0x7c]
;             }
7009c110: e7ff         	b	0x7009c112 <Udma_chAllocResource+0x222> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)
7009c112: 9807         	ldr	r0, [sp, #0x1c]
7009c114: 7800         	ldrb	r0, [r0]
7009c116: 06c0         	lsls	r0, r0, #0x1b
7009c118: 2800         	cmp	r0, #0x0
7009c11a: d504         	bpl	0x7009c126 <Udma_chAllocResource+0x236> @ imm = #0x8
7009c11c: e7ff         	b	0x7009c11e <Udma_chAllocResource+0x22e> @ imm = #-0x2
;                 chHandle->peerThreadId = chHandle->chPrms.peerChNum;
7009c11e: 9907         	ldr	r1, [sp, #0x1c]
7009c120: 6888         	ldr	r0, [r1, #0x8]
7009c122: 67c8         	str	r0, [r1, #0x7c]
;             }
7009c124: e7ff         	b	0x7009c126 <Udma_chAllocResource+0x236> @ imm = #-0x2
;         }
7009c126: e7ff         	b	0x7009c128 <Udma_chAllocResource+0x238> @ imm = #-0x2
7009c128: e7ff         	b	0x7009c12a <Udma_chAllocResource+0x23a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c12a: 9806         	ldr	r0, [sp, #0x18]
7009c12c: 2800         	cmp	r0, #0x0
7009c12e: f040 8088    	bne.w	0x7009c242 <Udma_chAllocResource+0x352> @ imm = #0x110
7009c132: e7ff         	b	0x7009c134 <Udma_chAllocResource+0x244> @ imm = #-0x2
;         if(NULL_PTR != chHandle->chPrms.fqRingPrms.ringMem)
7009c134: 9807         	ldr	r0, [sp, #0x1c]
7009c136: 6940         	ldr	r0, [r0, #0x14]
7009c138: 2800         	cmp	r0, #0x0
7009c13a: f000 8081    	beq.w	0x7009c240 <Udma_chAllocResource+0x350> @ imm = #0x102
7009c13e: e7ff         	b	0x7009c140 <Udma_chAllocResource+0x250> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) ==
7009c140: 9807         	ldr	r0, [sp, #0x1c]
7009c142: 7800         	ldrb	r0, [r0]
7009c144: 0740         	lsls	r0, r0, #0x1d
7009c146: 2800         	cmp	r0, #0x0
7009c148: d505         	bpl	0x7009c156 <Udma_chAllocResource+0x266> @ imm = #0xa
7009c14a: e7ff         	b	0x7009c14c <Udma_chAllocResource+0x25c> @ imm = #-0x2
;                 ringNum = (uint16_t)chHandle->txChNum;
7009c14c: 9807         	ldr	r0, [sp, #0x1c]
7009c14e: 6ec0         	ldr	r0, [r0, #0x6c]
7009c150: f8ad 000e    	strh.w	r0, [sp, #0xe]
;             }
7009c154: e044         	b	0x7009c1e0 <Udma_chAllocResource+0x2f0> @ imm = #0x88
;                 if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009c156: 9807         	ldr	r0, [sp, #0x1c]
7009c158: 7840         	ldrb	r0, [r0, #0x1]
7009c15a: 07c0         	lsls	r0, r0, #0x1f
7009c15c: b338         	cbz	r0, 0x7009c1ae <Udma_chAllocResource+0x2be> @ imm = #0x4e
7009c15e: e7ff         	b	0x7009c160 <Udma_chAllocResource+0x270> @ imm = #-0x2
;                     chHandle->chPrms.fqRingPrms.mappedRingGrp  = chHandle->chPrms.mappedChGrp;
7009c160: 9907         	ldr	r1, [sp, #0x1c]
7009c162: 68c8         	ldr	r0, [r1, #0xc]
7009c164: 6288         	str	r0, [r1, #0x28]
;                     if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009c166: 9807         	ldr	r0, [sp, #0x1c]
7009c168: 7800         	ldrb	r0, [r0]
7009c16a: 07c0         	lsls	r0, r0, #0x1f
7009c16c: b178         	cbz	r0, 0x7009c18e <Udma_chAllocResource+0x29e> @ imm = #0x1e
7009c16e: e7ff         	b	0x7009c170 <Udma_chAllocResource+0x280> @ imm = #-0x2
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->txChNum;
7009c170: 9907         	ldr	r1, [sp, #0x1c]
7009c172: 6ec8         	ldr	r0, [r1, #0x6c]
7009c174: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->txChNum, &chAttr);
7009c176: 9804         	ldr	r0, [sp, #0x10]
7009c178: 9a07         	ldr	r2, [sp, #0x1c]
7009c17a: 68d1         	ldr	r1, [r2, #0xc]
7009c17c: 6ed2         	ldr	r2, [r2, #0x6c]
7009c17e: 466b         	mov	r3, sp
7009c180: f00b fe2e    	bl	0x700a7de0 <Udma_getMappedChRingAttributes> @ imm = #0xbc5c
7009c184: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009c186: 9800         	ldr	r0, [sp]
7009c188: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                     }
7009c18c: e00e         	b	0x7009c1ac <Udma_chAllocResource+0x2bc> @ imm = #0x1c
;                         chHandle->chPrms.fqRingPrms.mappedChNum    = chHandle->rxChNum;
7009c18e: 9907         	ldr	r1, [sp, #0x1c]
7009c190: 6f08         	ldr	r0, [r1, #0x70]
7009c192: 62c8         	str	r0, [r1, #0x2c]
;                         retVal = Udma_getMappedChRingAttributes(drvHandle, chHandle->chPrms.mappedChGrp, chHandle->rxChNum, &chAttr);
7009c194: 9804         	ldr	r0, [sp, #0x10]
7009c196: 9a07         	ldr	r2, [sp, #0x1c]
7009c198: 68d1         	ldr	r1, [r2, #0xc]
7009c19a: 6f12         	ldr	r2, [r2, #0x70]
7009c19c: 466b         	mov	r3, sp
7009c19e: f00b fe1f    	bl	0x700a7de0 <Udma_getMappedChRingAttributes> @ imm = #0xbc3e
7009c1a2: 9006         	str	r0, [sp, #0x18]
;                         ringNum = chAttr.defaultRing;
7009c1a4: 9800         	ldr	r0, [sp]
7009c1a6: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009c1aa: e7ff         	b	0x7009c1ac <Udma_chAllocResource+0x2bc> @ imm = #-0x2
;                 }
7009c1ac: e017         	b	0x7009c1de <Udma_chAllocResource+0x2ee> @ imm = #0x2e
;                 else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009c1ae: 9807         	ldr	r0, [sp, #0x1c]
7009c1b0: 7800         	ldrb	r0, [r0]
7009c1b2: 07c0         	lsls	r0, r0, #0x1f
7009c1b4: b148         	cbz	r0, 0x7009c1ca <Udma_chAllocResource+0x2da> @ imm = #0x12
7009c1b6: e7ff         	b	0x7009c1b8 <Udma_chAllocResource+0x2c8> @ imm = #-0x2
;                     ringNum = (uint16_t)(chHandle->txChNum + drvHandle->txChOffset);
7009c1b8: 9807         	ldr	r0, [sp, #0x1c]
7009c1ba: 6ec0         	ldr	r0, [r0, #0x6c]
7009c1bc: 9904         	ldr	r1, [sp, #0x10]
7009c1be: f8d1 110c    	ldr.w	r1, [r1, #0x10c]
7009c1c2: 4408         	add	r0, r1
7009c1c4: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 }
7009c1c8: e008         	b	0x7009c1dc <Udma_chAllocResource+0x2ec> @ imm = #0x10
;                     ringNum = (uint16_t)(chHandle->rxChNum + drvHandle->rxChOffset);
7009c1ca: 9807         	ldr	r0, [sp, #0x1c]
7009c1cc: 6f00         	ldr	r0, [r0, #0x70]
7009c1ce: 9904         	ldr	r1, [sp, #0x10]
7009c1d0: f8d1 1114    	ldr.w	r1, [r1, #0x114]
7009c1d4: 4408         	add	r0, r1
7009c1d6: f8ad 000e    	strh.w	r0, [sp, #0xe]
7009c1da: e7ff         	b	0x7009c1dc <Udma_chAllocResource+0x2ec> @ imm = #-0x2
7009c1dc: e7ff         	b	0x7009c1de <Udma_chAllocResource+0x2ee> @ imm = #-0x2
7009c1de: e7ff         	b	0x7009c1e0 <Udma_chAllocResource+0x2f0> @ imm = #-0x2
;             chHandle->fqRing = &chHandle->fqRingObj;
7009c1e0: 9907         	ldr	r1, [sp, #0x1c]
7009c1e2: f101 0090    	add.w	r0, r1, #0x90
7009c1e6: f8c1 0080    	str.w	r0, [r1, #0x80]
;                          drvHandle,
7009c1ea: 9804         	ldr	r0, [sp, #0x10]
;                          chHandle->fqRing,
7009c1ec: 9b07         	ldr	r3, [sp, #0x1c]
7009c1ee: f8d3 1080    	ldr.w	r1, [r3, #0x80]
;                          ringNum,
7009c1f2: f8bd 200e    	ldrh.w	r2, [sp, #0xe]
;                          &chHandle->chPrms.fqRingPrms);
7009c1f6: 3314         	adds	r3, #0x14
;             retVal = Udma_ringAlloc(
7009c1f8: f003 f852    	bl	0x7009f2a0 <Udma_ringAlloc> @ imm = #0x30a4
7009c1fc: 9006         	str	r0, [sp, #0x18]
;             if(UDMA_SOK != retVal)
7009c1fe: 9806         	ldr	r0, [sp, #0x18]
7009c200: b128         	cbz	r0, 0x7009c20e <Udma_chAllocResource+0x31e> @ imm = #0xa
7009c202: e7ff         	b	0x7009c204 <Udma_chAllocResource+0x314> @ imm = #-0x2
;                 chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009c204: 9907         	ldr	r1, [sp, #0x1c]
7009c206: 2000         	movs	r0, #0x0
7009c208: f8c1 0080    	str.w	r0, [r1, #0x80]
;             }
7009c20c: e017         	b	0x7009c23e <Udma_chAllocResource+0x34e> @ imm = #0x2e
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009c20e: 9807         	ldr	r0, [sp, #0x1c]
7009c210: 7840         	ldrb	r0, [r0, #0x1]
7009c212: 07c0         	lsls	r0, r0, #0x1f
7009c214: b190         	cbz	r0, 0x7009c23c <Udma_chAllocResource+0x34c> @ imm = #0x24
7009c216: e7ff         	b	0x7009c218 <Udma_chAllocResource+0x328> @ imm = #-0x2
;                     ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX))
7009c218: 9807         	ldr	r0, [sp, #0x1c]
;             else if(((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED) &&
7009c21a: 7800         	ldrb	r0, [r0]
7009c21c: 0780         	lsls	r0, r0, #0x1e
7009c21e: 2800         	cmp	r0, #0x0
7009c220: d50c         	bpl	0x7009c23c <Udma_chAllocResource+0x34c> @ imm = #0x18
7009c222: e7ff         	b	0x7009c224 <Udma_chAllocResource+0x334> @ imm = #-0x2
;                 chHandle->defaultFlow->flowStart    = chHandle->fqRing->ringNum - drvHandle->rxChOffset;
7009c224: 9907         	ldr	r1, [sp, #0x1c]
7009c226: f8d1 0080    	ldr.w	r0, [r1, #0x80]
7009c22a: f8d1 11c8    	ldr.w	r1, [r1, #0x1c8]
7009c22e: 8880         	ldrh	r0, [r0, #0x4]
7009c230: 9a04         	ldr	r2, [sp, #0x10]
7009c232: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009c236: 1a80         	subs	r0, r0, r2
7009c238: 6048         	str	r0, [r1, #0x4]
;             }
7009c23a: e7ff         	b	0x7009c23c <Udma_chAllocResource+0x34c> @ imm = #-0x2
7009c23c: e7ff         	b	0x7009c23e <Udma_chAllocResource+0x34e> @ imm = #-0x2
;         }
7009c23e: e7ff         	b	0x7009c240 <Udma_chAllocResource+0x350> @ imm = #-0x2
;     }
7009c240: e7ff         	b	0x7009c242 <Udma_chAllocResource+0x352> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c242: 9806         	ldr	r0, [sp, #0x18]
7009c244: b930         	cbnz	r0, 0x7009c254 <Udma_chAllocResource+0x364> @ imm = #0xc
7009c246: e7ff         	b	0x7009c248 <Udma_chAllocResource+0x358> @ imm = #-0x2
;         chHandle->cqRing = &chHandle->fqRingObj;
7009c248: 9907         	ldr	r1, [sp, #0x1c]
7009c24a: f101 0090    	add.w	r0, r1, #0x90
7009c24e: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009c252: e7ff         	b	0x7009c254 <Udma_chAllocResource+0x364> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c254: 9806         	ldr	r0, [sp, #0x18]
7009c256: b928         	cbnz	r0, 0x7009c264 <Udma_chAllocResource+0x374> @ imm = #0xa
7009c258: e7ff         	b	0x7009c25a <Udma_chAllocResource+0x36a> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009c25a: 9907         	ldr	r1, [sp, #0x1c]
7009c25c: 2000         	movs	r0, #0x0
7009c25e: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009c262: e7ff         	b	0x7009c264 <Udma_chAllocResource+0x374> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009c264: 9806         	ldr	r0, [sp, #0x18]
7009c266: b148         	cbz	r0, 0x7009c27c <Udma_chAllocResource+0x38c> @ imm = #0x12
7009c268: e7ff         	b	0x7009c26a <Udma_chAllocResource+0x37a> @ imm = #-0x2
;         tempRetVal = Udma_chFreeResource(chHandle);
7009c26a: 9807         	ldr	r0, [sp, #0x1c]
7009c26c: f002 ff10    	bl	0x7009f090 <Udma_chFreeResource> @ imm = #0x2e20
7009c270: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != tempRetVal)
7009c272: 9805         	ldr	r0, [sp, #0x14]
7009c274: b108         	cbz	r0, 0x7009c27a <Udma_chAllocResource+0x38a> @ imm = #0x2
7009c276: e7ff         	b	0x7009c278 <Udma_chAllocResource+0x388> @ imm = #-0x2
;         }
7009c278: e7ff         	b	0x7009c27a <Udma_chAllocResource+0x38a> @ imm = #-0x2
;     }
7009c27a: e004         	b	0x7009c286 <Udma_chAllocResource+0x396> @ imm = #0x8
;         Udma_chAssignRegOverlay(drvHandle, chHandle);
7009c27c: 9804         	ldr	r0, [sp, #0x10]
7009c27e: 9907         	ldr	r1, [sp, #0x1c]
7009c280: f006 f8ae    	bl	0x700a23e0 <Udma_chAssignRegOverlay> @ imm = #0x615c
7009c284: e7ff         	b	0x7009c286 <Udma_chAllocResource+0x396> @ imm = #-0x2
;     return (retVal);
7009c286: 9806         	ldr	r0, [sp, #0x18]
7009c288: b008         	add	sp, #0x20
7009c28a: bd80         	pop	{r7, pc}
7009c28c: 0000         	movs	r0, r0
7009c28e: 0000         	movs	r0, r0

7009c290 <CSL_REG32_WR_RAW>:
; {
7009c290: b082         	sub	sp, #0x8
7009c292: 9001         	str	r0, [sp, #0x4]
7009c294: 9100         	str	r1, [sp]
;     *p = v;
7009c296: 9800         	ldr	r0, [sp]
7009c298: 9901         	ldr	r1, [sp, #0x4]
7009c29a: 6008         	str	r0, [r1]
;     return;
7009c29c: b002         	add	sp, #0x8
7009c29e: 4770         	bx	lr

7009c2a0 <strcmp>:
7009c2a0: e5d02000     	ldrb	r2, [r0]
7009c2a4: e5d13000     	ldrb	r3, [r1]
7009c2a8: e3520001     	cmp	r2, #1
7009c2ac: 21520003     	cmphs	r2, r3
7009c2b0: 1a004e82     	bne	0x700afcc0 <.Lfastpath_exit> @ imm = #0x13a08
7009c2b4: e16d41f0     	strd	r4, r5, [sp, #-16]!
7009c2b8: e1804001     	orr	r4, r0, r1
7009c2bc: e1cd60f8     	strd	r6, r7, [sp, #8]
7009c2c0: e3e0c000     	mvn	r12, #0
7009c2c4: e1a02e84     	lsl	r2, r4, #29
7009c2c8: e3520000     	cmp	r2, #0
7009c2cc: 0a000013     	beq	0x7009c320 <strcmp+0x80> @ imm = #0x4c
7009c2d0: e0204001     	eor	r4, r0, r1
7009c2d4: e3140007     	tst	r4, #7
7009c2d8: 1a00003e     	bne	0x7009c3d8 <strcmp+0x138> @ imm = #0xf8
7009c2dc: e2004007     	and	r4, r0, #7
7009c2e0: e3c00007     	bic	r0, r0, #7
7009c2e4: e2045003     	and	r5, r4, #3
7009c2e8: e3c11007     	bic	r1, r1, #7
7009c2ec: e1a05185     	lsl	r5, r5, #3
7009c2f0: e0c021d0     	ldrd	r2, r3, [r0], #16
7009c2f4: e3140004     	tst	r4, #4
7009c2f8: e0c161d0     	ldrd	r6, r7, [r1], #16
7009c2fc: e1e0451c     	mvn	r4, r12, lsl r5
7009c300: e1822004     	orr	r2, r2, r4
7009c304: e1866004     	orr	r6, r6, r4
7009c308: 0a000006     	beq	0x7009c328 <strcmp+0x88> @ imm = #0x18
7009c30c: e1833004     	orr	r3, r3, r4
7009c310: e1a0200c     	mov	r2, r12
7009c314: e1877004     	orr	r7, r7, r4
7009c318: e1a0600c     	mov	r6, r12
7009c31c: ea000001     	b	0x7009c328 <strcmp+0x88> @ imm = #0x4
7009c320: e0c021d0     	ldrd	r2, r3, [r0], #16
7009c324: e0c161d0     	ldrd	r6, r7, [r1], #16
7009c328: e6525f9c     	uadd8	r5, r2, r12
7009c32c: e0224006     	eor	r4, r2, r6
7009c330: e6844fbc     	sel	r4, r4, r12
7009c334: e3540000     	cmp	r4, #0
7009c338: 1a00001b     	bne	0x7009c3ac <strcmp+0x10c> @ imm = #0x6c
7009c33c: e6535f9c     	uadd8	r5, r3, r12
7009c340: e0235007     	eor	r5, r3, r7
7009c344: e6855fbc     	sel	r5, r5, r12
7009c348: e3550000     	cmp	r5, #0
7009c34c: 1a00000b     	bne	0x7009c380 <strcmp+0xe0> @ imm = #0x2c
7009c350: e14020d8     	ldrd	r2, r3, [r0, #-8]
7009c354: e14160d8     	ldrd	r6, r7, [r1, #-8]
7009c358: e6525f9c     	uadd8	r5, r2, r12
7009c35c: e0224006     	eor	r4, r2, r6
7009c360: e6844fbc     	sel	r4, r4, r12
7009c364: e6535f9c     	uadd8	r5, r3, r12
7009c368: e0235007     	eor	r5, r3, r7
7009c36c: e6855fbc     	sel	r5, r5, r12
7009c370: e1955004     	orrs	r5, r5, r4
7009c374: 0affffe9     	beq	0x7009c320 <strcmp+0x80> @ imm = #-0x5c
7009c378: e3540000     	cmp	r4, #0
7009c37c: 1a00000a     	bne	0x7009c3ac <strcmp+0x10c> @ imm = #0x28
7009c380: e6bf5f35     	rev	r5, r5
7009c384: e16f4f15     	clz	r4, r5
7009c388: e3c44007     	bic	r4, r4, #7
7009c38c: e1a01437     	lsr	r1, r7, r4
7009c390: e1cd60d8     	ldrd	r6, r7, [sp, #8]
7009c394: e1a03433     	lsr	r3, r3, r4
7009c398: e20300ff     	and	r0, r3, #255
7009c39c: e20110ff     	and	r1, r1, #255
7009c3a0: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c3a4: e0400001     	sub	r0, r0, r1
7009c3a8: e12fff1e     	bx	lr
7009c3ac: e6bf4f34     	rev	r4, r4
7009c3b0: e16f4f14     	clz	r4, r4
7009c3b4: e3c44007     	bic	r4, r4, #7
7009c3b8: e1a01436     	lsr	r1, r6, r4
7009c3bc: e1cd60d8     	ldrd	r6, r7, [sp, #8]
7009c3c0: e1a02432     	lsr	r2, r2, r4
7009c3c4: e20200ff     	and	r0, r2, #255
7009c3c8: e20110ff     	and	r1, r1, #255
7009c3cc: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c3d0: e0400001     	sub	r0, r0, r1
7009c3d4: e12fff1e     	bx	lr
7009c3d8: e3140003     	tst	r4, #3
7009c3dc: 1a000022     	bne	0x7009c46c <strcmp+0x1cc> @ imm = #0x88
7009c3e0: e2104003     	ands	r4, r0, #3
7009c3e4: 1a000017     	bne	0x7009c448 <strcmp+0x1a8> @ imm = #0x5c
7009c3e8: e4902008     	ldr	r2, [r0], #8
7009c3ec: e4913008     	ldr	r3, [r1], #8
7009c3f0: e6525f9c     	uadd8	r5, r2, r12
7009c3f4: e0225003     	eor	r5, r2, r3
7009c3f8: e6855fbc     	sel	r5, r5, r12
7009c3fc: e3550000     	cmp	r5, #0
7009c400: 1a000006     	bne	0x7009c420 <strcmp+0x180> @ imm = #0x18
7009c404: e5102004     	ldr	r2, [r0, #-0x4]
7009c408: e5113004     	ldr	r3, [r1, #-0x4]
7009c40c: e6525f9c     	uadd8	r5, r2, r12
7009c410: e0225003     	eor	r5, r2, r3
7009c414: e6855fbc     	sel	r5, r5, r12
7009c418: e3550000     	cmp	r5, #0
7009c41c: 0afffff1     	beq	0x7009c3e8 <strcmp+0x148> @ imm = #-0x3c
7009c420: e6bf5f35     	rev	r5, r5
7009c424: e16f4f15     	clz	r4, r5
7009c428: e3c44007     	bic	r4, r4, #7
7009c42c: e1a01433     	lsr	r1, r3, r4
7009c430: e1a02432     	lsr	r2, r2, r4
7009c434: e20200ff     	and	r0, r2, #255
7009c438: e20110ff     	and	r1, r1, #255
7009c43c: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c440: e0400001     	sub	r0, r0, r1
7009c444: e12fff1e     	bx	lr
7009c448: e1a04184     	lsl	r4, r4, #3
7009c44c: e3c00003     	bic	r0, r0, #3
7009c450: e4902008     	ldr	r2, [r0], #8
7009c454: e3c11003     	bic	r1, r1, #3
7009c458: e4913008     	ldr	r3, [r1], #8
7009c45c: e1e0441c     	mvn	r4, r12, lsl r4
7009c460: e1822004     	orr	r2, r2, r4
7009c464: e1833004     	orr	r3, r3, r4
7009c468: eaffffe0     	b	0x7009c3f0 <strcmp+0x150> @ imm = #-0x80
7009c46c: e2104003     	ands	r4, r0, #3
7009c470: 0a000015     	beq	0x7009c4cc <strcmp+0x22c> @ imm = #0x54
7009c474: e0411004     	sub	r1, r1, r4
7009c478: e3c00003     	bic	r0, r0, #3
7009c47c: e1b04f84     	lsls	r4, r4, #31
7009c480: e4902004     	ldr	r2, [r0], #4
7009c484: 0a000006     	beq	0x7009c4a4 <strcmp+0x204> @ imm = #0x18
7009c488: 2a00000e     	bhs	0x7009c4c8 <strcmp+0x228> @ imm = #0x38
7009c48c: e5d13002     	ldrb	r3, [r1, #0x2]
7009c490: e6ef4872     	uxtb	r4, r2, ror #16
7009c494: e0544003     	subs	r4, r4, r3
7009c498: 1a000007     	bne	0x7009c4bc <strcmp+0x21c> @ imm = #0x1c
7009c49c: e3530000     	cmp	r3, #0
7009c4a0: 0a000005     	beq	0x7009c4bc <strcmp+0x21c> @ imm = #0x14
7009c4a4: e5d13003     	ldrb	r3, [r1, #0x3]
7009c4a8: e6ef4c72     	uxtb	r4, r2, ror #24
7009c4ac: e0544003     	subs	r4, r4, r3
7009c4b0: 1a000001     	bne	0x7009c4bc <strcmp+0x21c> @ imm = #0x4
7009c4b4: e3530000     	cmp	r3, #0
7009c4b8: 1a000002     	bne	0x7009c4c8 <strcmp+0x228> @ imm = #0x8
7009c4bc: e1a00004     	mov	r0, r4
7009c4c0: e49d4010     	ldr	r4, [sp], #16
7009c4c4: e12fff1e     	bx	lr
7009c4c8: e2811004     	add	r1, r1, #4
7009c4cc: e4902004     	ldr	r2, [r0], #4
7009c4d0: e1b04f81     	lsls	r4, r1, #31
7009c4d4: e3c11003     	bic	r1, r1, #3
7009c4d8: e4913004     	ldr	r3, [r1], #4
7009c4dc: 8a00002f     	bhi	0x7009c5a0 <strcmp+0x300> @ imm = #0xbc
7009c4e0: 2a000017     	bhs	0x7009c544 <strcmp+0x2a4> @ imm = #0x5c
7009c4e4: e3c244ff     	bic	r4, r2, #-16777216
7009c4e8: e6525f9c     	uadd8	r5, r2, r12
7009c4ec: e0345423     	eors	r5, r4, r3, lsr #8
7009c4f0: e6855fbc     	sel	r5, r5, r12
7009c4f4: 1a000007     	bne	0x7009c518 <strcmp+0x278> @ imm = #0x1c
7009c4f8: e3550000     	cmp	r5, #0
7009c4fc: 1a000007     	bne	0x7009c520 <strcmp+0x280> @ imm = #0x1c
7009c500: e4913004     	ldr	r3, [r1], #4
7009c504: e0244002     	eor	r4, r4, r2
7009c508: e1540c03     	cmp	r4, r3, lsl #24
7009c50c: 1a000009     	bne	0x7009c538 <strcmp+0x298> @ imm = #0x24
7009c510: e4902004     	ldr	r2, [r0], #4
7009c514: eafffff2     	b	0x7009c4e4 <strcmp+0x244> @ imm = #-0x38
7009c518: e1a03423     	lsr	r3, r3, #8
7009c51c: ea000037     	b	0x7009c600 <strcmp+0x360> @ imm = #0xdc
7009c520: e3d554ff     	bics	r5, r5, #-16777216
7009c524: 1a000032     	bne	0x7009c5f4 <strcmp+0x354> @ imm = #0xc8
7009c528: e5d10000     	ldrb	r0, [r1]
7009c52c: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c530: e2600000     	rsb	r0, r0, #0
7009c534: e12fff1e     	bx	lr
7009c538: e1a02c22     	lsr	r2, r2, #24
7009c53c: e20330ff     	and	r3, r3, #255
7009c540: ea00002e     	b	0x7009c600 <strcmp+0x360> @ imm = #0xb8
7009c544: e002482c     	and	r4, r2, r12, lsr #16
7009c548: e6525f9c     	uadd8	r5, r2, r12
7009c54c: e0345823     	eors	r5, r4, r3, lsr #16
7009c550: e6855fbc     	sel	r5, r5, r12
7009c554: 1a000007     	bne	0x7009c578 <strcmp+0x2d8> @ imm = #0x1c
7009c558: e3550000     	cmp	r5, #0
7009c55c: 1a000007     	bne	0x7009c580 <strcmp+0x2e0> @ imm = #0x1c
7009c560: e4913004     	ldr	r3, [r1], #4
7009c564: e0244002     	eor	r4, r4, r2
7009c568: e1540803     	cmp	r4, r3, lsl #16
7009c56c: 1a000008     	bne	0x7009c594 <strcmp+0x2f4> @ imm = #0x20
7009c570: e4902004     	ldr	r2, [r0], #4
7009c574: eafffff2     	b	0x7009c544 <strcmp+0x2a4> @ imm = #-0x38
7009c578: e1a03823     	lsr	r3, r3, #16
7009c57c: ea00001f     	b	0x7009c600 <strcmp+0x360> @ imm = #0x7c
7009c580: e015582c     	ands	r5, r5, r12, lsr #16
7009c584: 1a00001a     	bne	0x7009c5f4 <strcmp+0x354> @ imm = #0x68
7009c588: e1d130b0     	ldrh	r3, [r1]
7009c58c: e1a02822     	lsr	r2, r2, #16
7009c590: ea00001a     	b	0x7009c600 <strcmp+0x360> @ imm = #0x68
7009c594: e1a02822     	lsr	r2, r2, #16
7009c598: e003382c     	and	r3, r3, r12, lsr #16
7009c59c: ea000017     	b	0x7009c600 <strcmp+0x360> @ imm = #0x5c
7009c5a0: e20240ff     	and	r4, r2, #255
7009c5a4: e6525f9c     	uadd8	r5, r2, r12
7009c5a8: e0345c23     	eors	r5, r4, r3, lsr #24
7009c5ac: e6855fbc     	sel	r5, r5, r12
7009c5b0: 1a000007     	bne	0x7009c5d4 <strcmp+0x334> @ imm = #0x1c
7009c5b4: e3550000     	cmp	r5, #0
7009c5b8: 1a000007     	bne	0x7009c5dc <strcmp+0x33c> @ imm = #0x1c
7009c5bc: e4913004     	ldr	r3, [r1], #4
7009c5c0: e0244002     	eor	r4, r4, r2
7009c5c4: e1540403     	cmp	r4, r3, lsl #8
7009c5c8: 1a000006     	bne	0x7009c5e8 <strcmp+0x348> @ imm = #0x18
7009c5cc: e4902004     	ldr	r2, [r0], #4
7009c5d0: eafffff2     	b	0x7009c5a0 <strcmp+0x300> @ imm = #-0x38
7009c5d4: e1a03c23     	lsr	r3, r3, #24
7009c5d8: ea000008     	b	0x7009c600 <strcmp+0x360> @ imm = #0x20
7009c5dc: e31500ff     	tst	r5, #255
7009c5e0: 1a000003     	bne	0x7009c5f4 <strcmp+0x354> @ imm = #0xc
7009c5e4: e5913000     	ldr	r3, [r1]
7009c5e8: e1a02422     	lsr	r2, r2, #8
7009c5ec: e3c334ff     	bic	r3, r3, #-16777216
7009c5f0: ea000002     	b	0x7009c600 <strcmp+0x360> @ imm = #0x8
7009c5f4: e3a00000     	mov	r0, #0
7009c5f8: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c5fc: e12fff1e     	bx	lr
7009c600: e6bf2f32     	rev	r2, r2
7009c604: e6bf3f33     	rev	r3, r3
7009c608: e6524f9c     	uadd8	r4, r2, r12
7009c60c: e0224003     	eor	r4, r2, r3
7009c610: e6845fbc     	sel	r5, r4, r12
7009c614: e16f4f15     	clz	r4, r5
7009c618: e1a02412     	lsl	r2, r2, r4
7009c61c: e1a03413     	lsl	r3, r3, r4
7009c620: e1a00c22     	lsr	r0, r2, #24
7009c624: e0cd41d0     	ldrd	r4, r5, [sp], #16
7009c628: e0400c23     	sub	r0, r0, r3, lsr #24
7009c62c: e12fff1e     	bx	lr

7009c630 <Udma_chDisableTxChan>:
; {
7009c630: b580         	push	{r7, lr}
7009c632: b09a         	sub	sp, #0x68
7009c634: 9019         	str	r0, [sp, #0x64]
7009c636: 9118         	str	r1, [sp, #0x60]
7009c638: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009c63a: 9017         	str	r0, [sp, #0x5c]
;     uint32_t            peerRtEnable = 0U, currTimeout = 0U;
7009c63c: 9016         	str	r0, [sp, #0x58]
7009c63e: 9015         	str	r0, [sp, #0x54]
;     drvHandle = chHandle->drvHandle;
7009c640: 9819         	ldr	r0, [sp, #0x64]
7009c642: 6e80         	ldr	r0, [r0, #0x68]
7009c644: 9014         	str	r0, [sp, #0x50]
7009c646: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009c648: 9008         	str	r0, [sp, #0x20]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c64a: 9814         	ldr	r0, [sp, #0x50]
7009c64c: 6800         	ldr	r0, [r0]
7009c64e: 2801         	cmp	r0, #0x1
7009c650: d10e         	bne	0x7009c670 <Udma_chDisableTxChan+0x40> @ imm = #0x1c
7009c652: e7ff         	b	0x7009c654 <Udma_chDisableTxChan+0x24> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)false, (bool)false);
7009c654: 9a14         	ldr	r2, [sp, #0x50]
7009c656: f102 0008    	add.w	r0, r2, #0x8
7009c65a: 9919         	ldr	r1, [sp, #0x64]
7009c65c: 6ec9         	ldr	r1, [r1, #0x6c]
7009c65e: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c662: 4411         	add	r1, r2
7009c664: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009c666: 461a         	mov	r2, r3
7009c668: f011 f8a2    	bl	0x700ad7b0 <CSL_bcdmaTeardownTxChan> @ imm = #0x11144
7009c66c: 9017         	str	r0, [sp, #0x5c]
;     }
7009c66e: e00f         	b	0x7009c690 <Udma_chDisableTxChan+0x60> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c670: 9814         	ldr	r0, [sp, #0x50]
7009c672: 6800         	ldr	r0, [r0]
7009c674: 2802         	cmp	r0, #0x2
7009c676: d10a         	bne	0x7009c68e <Udma_chDisableTxChan+0x5e> @ imm = #0x14
7009c678: e7ff         	b	0x7009c67a <Udma_chDisableTxChan+0x4a> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009c67a: 9814         	ldr	r0, [sp, #0x50]
7009c67c: 3054         	adds	r0, #0x54
7009c67e: 9919         	ldr	r1, [sp, #0x64]
7009c680: 6ec9         	ldr	r1, [r1, #0x6c]
7009c682: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009c684: 461a         	mov	r2, r3
7009c686: f011 ff3b    	bl	0x700ae500 <CSL_pktdmaTeardownTxChan> @ imm = #0x11e76
7009c68a: 9017         	str	r0, [sp, #0x5c]
;     }
7009c68c: e7ff         	b	0x7009c68e <Udma_chDisableTxChan+0x5e> @ imm = #-0x2
7009c68e: e7ff         	b	0x7009c690 <Udma_chDisableTxChan+0x60> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009c690: 9817         	ldr	r0, [sp, #0x5c]
7009c692: b108         	cbz	r0, 0x7009c698 <Udma_chDisableTxChan+0x68> @ imm = #0x2
7009c694: e7ff         	b	0x7009c696 <Udma_chDisableTxChan+0x66> @ imm = #-0x2
;     }
7009c696: e7ff         	b	0x7009c698 <Udma_chDisableTxChan+0x68> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c698: e7ff         	b	0x7009c69a <Udma_chDisableTxChan+0x6a> @ imm = #-0x2
7009c69a: 9817         	ldr	r0, [sp, #0x5c]
7009c69c: bbc8         	cbnz	r0, 0x7009c712 <Udma_chDisableTxChan+0xe2> @ imm = #0x72
7009c69e: e7ff         	b	0x7009c6a0 <Udma_chDisableTxChan+0x70> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c6a0: 9814         	ldr	r0, [sp, #0x50]
7009c6a2: 6800         	ldr	r0, [r0]
7009c6a4: 2801         	cmp	r0, #0x1
7009c6a6: d110         	bne	0x7009c6ca <Udma_chDisableTxChan+0x9a> @ imm = #0x20
7009c6a8: e7ff         	b	0x7009c6aa <Udma_chDisableTxChan+0x7a> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c6aa: 9a14         	ldr	r2, [sp, #0x50]
7009c6ac: f102 0008    	add.w	r0, r2, #0x8
7009c6b0: 9919         	ldr	r1, [sp, #0x64]
7009c6b2: 6ec9         	ldr	r1, [r1, #0x6c]
7009c6b4: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c6b8: 4411         	add	r1, r2
7009c6ba: aa0e         	add	r2, sp, #0x38
7009c6bc: f012 fa18    	bl	0x700aeaf0 <CSL_bcdmaGetTxRT> @ imm = #0x12430
;             if(FALSE == bcdmaRtStatus.enable)
7009c6c0: 980e         	ldr	r0, [sp, #0x38]
7009c6c2: b908         	cbnz	r0, 0x7009c6c8 <Udma_chDisableTxChan+0x98> @ imm = #0x2
7009c6c4: e7ff         	b	0x7009c6c6 <Udma_chDisableTxChan+0x96> @ imm = #-0x2
;                 break;
7009c6c6: e024         	b	0x7009c712 <Udma_chDisableTxChan+0xe2> @ imm = #0x48
;         }
7009c6c8: e011         	b	0x7009c6ee <Udma_chDisableTxChan+0xbe> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c6ca: 9814         	ldr	r0, [sp, #0x50]
7009c6cc: 6800         	ldr	r0, [r0]
7009c6ce: 2802         	cmp	r0, #0x2
7009c6d0: d10c         	bne	0x7009c6ec <Udma_chDisableTxChan+0xbc> @ imm = #0x18
7009c6d2: e7ff         	b	0x7009c6d4 <Udma_chDisableTxChan+0xa4> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c6d4: 9814         	ldr	r0, [sp, #0x50]
7009c6d6: 3054         	adds	r0, #0x54
7009c6d8: 9919         	ldr	r1, [sp, #0x64]
7009c6da: 6ec9         	ldr	r1, [r1, #0x6c]
7009c6dc: aa09         	add	r2, sp, #0x24
7009c6de: f010 feb7    	bl	0x700ad450 <CSL_pktdmaGetTxRT> @ imm = #0x10d6e
;             if(FALSE == pktdmaRtStatus.enable)
7009c6e2: 9809         	ldr	r0, [sp, #0x24]
7009c6e4: b908         	cbnz	r0, 0x7009c6ea <Udma_chDisableTxChan+0xba> @ imm = #0x2
7009c6e6: e7ff         	b	0x7009c6e8 <Udma_chDisableTxChan+0xb8> @ imm = #-0x2
;                 break;
7009c6e8: e013         	b	0x7009c712 <Udma_chDisableTxChan+0xe2> @ imm = #0x26
;         }
7009c6ea: e7ff         	b	0x7009c6ec <Udma_chDisableTxChan+0xbc> @ imm = #-0x2
7009c6ec: e7ff         	b	0x7009c6ee <Udma_chDisableTxChan+0xbe> @ imm = #-0x2
;         if(currTimeout > timeout)
7009c6ee: 9815         	ldr	r0, [sp, #0x54]
7009c6f0: 9918         	ldr	r1, [sp, #0x60]
7009c6f2: 4288         	cmp	r0, r1
7009c6f4: d904         	bls	0x7009c700 <Udma_chDisableTxChan+0xd0> @ imm = #0x8
7009c6f6: e7ff         	b	0x7009c6f8 <Udma_chDisableTxChan+0xc8> @ imm = #-0x2
7009c6f8: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009c6fc: 9017         	str	r0, [sp, #0x5c]
;         }
7009c6fe: e007         	b	0x7009c710 <Udma_chDisableTxChan+0xe0> @ imm = #0xe
7009c700: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009c704: f00e fd3c    	bl	0x700ab180 <ClockP_usleep> @ imm = #0xea78
;             currTimeout++;
7009c708: 9815         	ldr	r0, [sp, #0x54]
7009c70a: 3001         	adds	r0, #0x1
7009c70c: 9015         	str	r0, [sp, #0x54]
7009c70e: e7ff         	b	0x7009c710 <Udma_chDisableTxChan+0xe0> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009c710: e7c3         	b	0x7009c69a <Udma_chDisableTxChan+0x6a> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009c712: 9817         	ldr	r0, [sp, #0x5c]
7009c714: 2800         	cmp	r0, #0x0
7009c716: f000 80e4    	beq.w	0x7009c8e2 <Udma_chDisableTxChan+0x2b2> @ imm = #0x1c8
7009c71a: e7ff         	b	0x7009c71c <Udma_chDisableTxChan+0xec> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c71c: 9814         	ldr	r0, [sp, #0x50]
7009c71e: 6800         	ldr	r0, [r0]
7009c720: 2801         	cmp	r0, #0x1
7009c722: d10e         	bne	0x7009c742 <Udma_chDisableTxChan+0x112> @ imm = #0x1c
7009c724: e7ff         	b	0x7009c726 <Udma_chDisableTxChan+0xf6> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, (bool)true, (bool)false);
7009c726: 9a14         	ldr	r2, [sp, #0x50]
7009c728: f102 0008    	add.w	r0, r2, #0x8
7009c72c: 9919         	ldr	r1, [sp, #0x64]
7009c72e: 6ec9         	ldr	r1, [r1, #0x6c]
7009c730: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c734: 4411         	add	r1, r2
7009c736: 2201         	movs	r2, #0x1
7009c738: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009c73a: f011 f839    	bl	0x700ad7b0 <CSL_bcdmaTeardownTxChan> @ imm = #0x11072
7009c73e: 9017         	str	r0, [sp, #0x5c]
;         }
7009c740: e00f         	b	0x7009c762 <Udma_chDisableTxChan+0x132> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c742: 9814         	ldr	r0, [sp, #0x50]
7009c744: 6800         	ldr	r0, [r0]
7009c746: 2802         	cmp	r0, #0x2
7009c748: d10a         	bne	0x7009c760 <Udma_chDisableTxChan+0x130> @ imm = #0x14
7009c74a: e7ff         	b	0x7009c74c <Udma_chDisableTxChan+0x11c> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009c74c: 9814         	ldr	r0, [sp, #0x50]
7009c74e: 3054         	adds	r0, #0x54
7009c750: 9919         	ldr	r1, [sp, #0x64]
7009c752: 6ec9         	ldr	r1, [r1, #0x6c]
7009c754: 2201         	movs	r2, #0x1
7009c756: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009c758: f011 fed2    	bl	0x700ae500 <CSL_pktdmaTeardownTxChan> @ imm = #0x11da4
7009c75c: 9017         	str	r0, [sp, #0x5c]
;         }
7009c75e: e7ff         	b	0x7009c760 <Udma_chDisableTxChan+0x130> @ imm = #-0x2
7009c760: e7ff         	b	0x7009c762 <Udma_chDisableTxChan+0x132> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009c762: 9817         	ldr	r0, [sp, #0x5c]
7009c764: b108         	cbz	r0, 0x7009c76a <Udma_chDisableTxChan+0x13a> @ imm = #0x2
7009c766: e7ff         	b	0x7009c768 <Udma_chDisableTxChan+0x138> @ imm = #-0x2
;         }
7009c768: e7ff         	b	0x7009c76a <Udma_chDisableTxChan+0x13a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c76a: 9814         	ldr	r0, [sp, #0x50]
7009c76c: 6800         	ldr	r0, [r0]
7009c76e: 2801         	cmp	r0, #0x1
7009c770: d128         	bne	0x7009c7c4 <Udma_chDisableTxChan+0x194> @ imm = #0x50
7009c772: e7ff         	b	0x7009c774 <Udma_chDisableTxChan+0x144> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs,
7009c774: 9a14         	ldr	r2, [sp, #0x50]
7009c776: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c77a: 9919         	ldr	r1, [sp, #0x64]
7009c77c: 6ec9         	ldr	r1, [r1, #0x6c]
7009c77e: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c782: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009c784: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaGetChanPeerReg(
7009c786: 46ec         	mov	r12, sp
7009c788: aa16         	add	r2, sp, #0x58
7009c78a: 9206         	str	r2, [sp, #0x18]
7009c78c: f8cc 2000    	str.w	r2, [r12]
7009c790: 2200         	movs	r2, #0x0
7009c792: 9207         	str	r2, [sp, #0x1c]
7009c794: f011 f8d4    	bl	0x700ad940 <CSL_bcdmaGetChanPeerReg> @ imm = #0x111a8
7009c798: f8dd c018    	ldr.w	r12, [sp, #0x18]
7009c79c: 9a07         	ldr	r2, [sp, #0x1c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009c79e: 9816         	ldr	r0, [sp, #0x58]
7009c7a0: f040 5080    	orr	r0, r0, #0x10000000
7009c7a4: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->bcdmaRegs,
7009c7a6: 9b14         	ldr	r3, [sp, #0x50]
7009c7a8: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c7ac: 9919         	ldr	r1, [sp, #0x64]
7009c7ae: 6ec9         	ldr	r1, [r1, #0x6c]
7009c7b0: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009c7b4: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009c7b6: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009c7b8: 46ee         	mov	lr, sp
7009c7ba: f8ce c000    	str.w	r12, [lr]
7009c7be: f011 fb9f    	bl	0x700adf00 <CSL_bcdmaSetChanPeerReg> @ imm = #0x1173e
;         }
7009c7c2: e025         	b	0x7009c810 <Udma_chDisableTxChan+0x1e0> @ imm = #0x4a
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c7c4: 9814         	ldr	r0, [sp, #0x50]
7009c7c6: 6800         	ldr	r0, [r0]
7009c7c8: 2802         	cmp	r0, #0x2
7009c7ca: d120         	bne	0x7009c80e <Udma_chDisableTxChan+0x1de> @ imm = #0x40
7009c7cc: e7ff         	b	0x7009c7ce <Udma_chDisableTxChan+0x19e> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs,
7009c7ce: 9814         	ldr	r0, [sp, #0x50]
7009c7d0: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c7d2: 9919         	ldr	r1, [sp, #0x64]
7009c7d4: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c7d6: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaGetChanPeerReg(
7009c7d8: 46ec         	mov	r12, sp
7009c7da: aa16         	add	r2, sp, #0x58
7009c7dc: 9204         	str	r2, [sp, #0x10]
7009c7de: f8cc 2000    	str.w	r2, [r12]
7009c7e2: 2200         	movs	r2, #0x0
7009c7e4: 9205         	str	r2, [sp, #0x14]
7009c7e6: f012 f803    	bl	0x700ae7f0 <CSL_pktdmaGetChanPeerReg> @ imm = #0x12006
7009c7ea: f8dd c010    	ldr.w	r12, [sp, #0x10]
7009c7ee: 9a05         	ldr	r2, [sp, #0x14]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_FLUSH, (uint32_t) 1U);
7009c7f0: 9816         	ldr	r0, [sp, #0x58]
7009c7f2: f040 5080    	orr	r0, r0, #0x10000000
7009c7f6: 9016         	str	r0, [sp, #0x58]
;                 &drvHandle->pktdmaRegs,
7009c7f8: 9814         	ldr	r0, [sp, #0x50]
7009c7fa: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c7fc: 9919         	ldr	r1, [sp, #0x64]
7009c7fe: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c800: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009c802: 46ee         	mov	lr, sp
7009c804: f8ce c000    	str.w	r12, [lr]
7009c808: f012 f80a    	bl	0x700ae820 <CSL_pktdmaSetChanPeerReg> @ imm = #0x12014
;         }
7009c80c: e7ff         	b	0x7009c80e <Udma_chDisableTxChan+0x1de> @ imm = #-0x2
7009c80e: e7ff         	b	0x7009c810 <Udma_chDisableTxChan+0x1e0> @ imm = #-0x2
7009c810: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009c812: 9015         	str	r0, [sp, #0x54]
;         while(UDMA_SOK == retVal)
7009c814: e7ff         	b	0x7009c816 <Udma_chDisableTxChan+0x1e6> @ imm = #-0x2
7009c816: 9817         	ldr	r0, [sp, #0x5c]
7009c818: 2800         	cmp	r0, #0x0
7009c81a: d161         	bne	0x7009c8e0 <Udma_chDisableTxChan+0x2b0> @ imm = #0xc2
7009c81c: e7ff         	b	0x7009c81e <Udma_chDisableTxChan+0x1ee> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c81e: 9814         	ldr	r0, [sp, #0x50]
7009c820: 6800         	ldr	r0, [r0]
7009c822: 2801         	cmp	r0, #0x1
7009c824: d126         	bne	0x7009c874 <Udma_chDisableTxChan+0x244> @ imm = #0x4c
7009c826: e7ff         	b	0x7009c828 <Udma_chDisableTxChan+0x1f8> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c828: 9a14         	ldr	r2, [sp, #0x50]
7009c82a: f102 0008    	add.w	r0, r2, #0x8
7009c82e: 9919         	ldr	r1, [sp, #0x64]
7009c830: 6ec9         	ldr	r1, [r1, #0x6c]
7009c832: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c836: 4411         	add	r1, r2
7009c838: aa0e         	add	r2, sp, #0x38
7009c83a: f012 f959    	bl	0x700aeaf0 <CSL_bcdmaGetTxRT> @ imm = #0x122b2
;                     &drvHandle->bcdmaRegs,
7009c83e: 9a14         	ldr	r2, [sp, #0x50]
7009c840: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->txChNum + drvHandle->txChOffset,
7009c844: 9919         	ldr	r1, [sp, #0x64]
7009c846: 6ec9         	ldr	r1, [r1, #0x6c]
7009c848: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c84c: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009c84e: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009c850: 46ec         	mov	r12, sp
7009c852: aa16         	add	r2, sp, #0x58
7009c854: f8cc 2000    	str.w	r2, [r12]
7009c858: 2200         	movs	r2, #0x0
7009c85a: f011 f871    	bl	0x700ad940 <CSL_bcdmaGetChanPeerReg> @ imm = #0x110e2
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009c85e: 980e         	ldr	r0, [sp, #0x38]
7009c860: b938         	cbnz	r0, 0x7009c872 <Udma_chDisableTxChan+0x242> @ imm = #0xe
7009c862: e7ff         	b	0x7009c864 <Udma_chDisableTxChan+0x234> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009c864: 9916         	ldr	r1, [sp, #0x58]
7009c866: 2000         	movs	r0, #0x0
;                 if((FALSE == bcdmaRtStatus.enable) &&
7009c868: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009c86c: d101         	bne	0x7009c872 <Udma_chDisableTxChan+0x242> @ imm = #0x2
7009c86e: e7ff         	b	0x7009c870 <Udma_chDisableTxChan+0x240> @ imm = #-0x2
;                     break;
7009c870: e036         	b	0x7009c8e0 <Udma_chDisableTxChan+0x2b0> @ imm = #0x6c
;             }
7009c872: e023         	b	0x7009c8bc <Udma_chDisableTxChan+0x28c> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c874: 9814         	ldr	r0, [sp, #0x50]
7009c876: 6800         	ldr	r0, [r0]
7009c878: 2802         	cmp	r0, #0x2
7009c87a: d11e         	bne	0x7009c8ba <Udma_chDisableTxChan+0x28a> @ imm = #0x3c
7009c87c: e7ff         	b	0x7009c87e <Udma_chDisableTxChan+0x24e> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c87e: 9814         	ldr	r0, [sp, #0x50]
7009c880: 3054         	adds	r0, #0x54
7009c882: 9919         	ldr	r1, [sp, #0x64]
7009c884: 6ec9         	ldr	r1, [r1, #0x6c]
7009c886: aa09         	add	r2, sp, #0x24
7009c888: f010 fde2    	bl	0x700ad450 <CSL_pktdmaGetTxRT> @ imm = #0x10bc4
;                     &drvHandle->pktdmaRegs,
7009c88c: 9814         	ldr	r0, [sp, #0x50]
7009c88e: 3054         	adds	r0, #0x54
;                     chHandle->txChNum,
7009c890: 9919         	ldr	r1, [sp, #0x64]
7009c892: 6ec9         	ldr	r1, [r1, #0x6c]
;                     rtEnableRegOffset, &peerRtEnable);
7009c894: 9b08         	ldr	r3, [sp, #0x20]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009c896: 46ec         	mov	r12, sp
7009c898: aa16         	add	r2, sp, #0x58
7009c89a: f8cc 2000    	str.w	r2, [r12]
7009c89e: 2200         	movs	r2, #0x0
7009c8a0: f011 ffa6    	bl	0x700ae7f0 <CSL_pktdmaGetChanPeerReg> @ imm = #0x11f4c
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009c8a4: 9809         	ldr	r0, [sp, #0x24]
7009c8a6: b938         	cbnz	r0, 0x7009c8b8 <Udma_chDisableTxChan+0x288> @ imm = #0xe
7009c8a8: e7ff         	b	0x7009c8aa <Udma_chDisableTxChan+0x27a> @ imm = #-0x2
;                 (CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE) == FALSE))
7009c8aa: 9916         	ldr	r1, [sp, #0x58]
7009c8ac: 2000         	movs	r0, #0x0
;                 if((FALSE == pktdmaRtStatus.enable) &&
7009c8ae: ebb0 7fd1    	cmp.w	r0, r1, lsr #31
7009c8b2: d101         	bne	0x7009c8b8 <Udma_chDisableTxChan+0x288> @ imm = #0x2
7009c8b4: e7ff         	b	0x7009c8b6 <Udma_chDisableTxChan+0x286> @ imm = #-0x2
;                     break;
7009c8b6: e013         	b	0x7009c8e0 <Udma_chDisableTxChan+0x2b0> @ imm = #0x26
;             }
7009c8b8: e7ff         	b	0x7009c8ba <Udma_chDisableTxChan+0x28a> @ imm = #-0x2
7009c8ba: e7ff         	b	0x7009c8bc <Udma_chDisableTxChan+0x28c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009c8bc: 9815         	ldr	r0, [sp, #0x54]
7009c8be: 9918         	ldr	r1, [sp, #0x60]
7009c8c0: 4288         	cmp	r0, r1
7009c8c2: d904         	bls	0x7009c8ce <Udma_chDisableTxChan+0x29e> @ imm = #0x8
7009c8c4: e7ff         	b	0x7009c8c6 <Udma_chDisableTxChan+0x296> @ imm = #-0x2
7009c8c6: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009c8ca: 9017         	str	r0, [sp, #0x5c]
;             }
7009c8cc: e007         	b	0x7009c8de <Udma_chDisableTxChan+0x2ae> @ imm = #0xe
7009c8ce: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009c8d2: f00e fc55    	bl	0x700ab180 <ClockP_usleep> @ imm = #0xe8aa
;                 currTimeout++;
7009c8d6: 9815         	ldr	r0, [sp, #0x54]
7009c8d8: 3001         	adds	r0, #0x1
7009c8da: 9015         	str	r0, [sp, #0x54]
7009c8dc: e7ff         	b	0x7009c8de <Udma_chDisableTxChan+0x2ae> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009c8de: e79a         	b	0x7009c816 <Udma_chDisableTxChan+0x1e6> @ imm = #-0xcc
;     }
7009c8e0: e7ff         	b	0x7009c8e2 <Udma_chDisableTxChan+0x2b2> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009c8e2: 9817         	ldr	r0, [sp, #0x5c]
7009c8e4: 2800         	cmp	r0, #0x0
7009c8e6: d150         	bne	0x7009c98a <Udma_chDisableTxChan+0x35a> @ imm = #0xa0
7009c8e8: e7ff         	b	0x7009c8ea <Udma_chDisableTxChan+0x2ba> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009c8ea: 9814         	ldr	r0, [sp, #0x50]
7009c8ec: 6800         	ldr	r0, [r0]
7009c8ee: 2801         	cmp	r0, #0x1
7009c8f0: d126         	bne	0x7009c940 <Udma_chDisableTxChan+0x310> @ imm = #0x4c
7009c8f2: e7ff         	b	0x7009c8f4 <Udma_chDisableTxChan+0x2c4> @ imm = #-0x2
7009c8f4: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009c8f6: 9003         	str	r0, [sp, #0xc]
7009c8f8: 900e         	str	r0, [sp, #0x38]
;             bcdmaRtStatus.teardown = FALSE;
7009c8fa: 900f         	str	r0, [sp, #0x3c]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009c8fc: 9012         	str	r0, [sp, #0x48]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009c8fe: 9816         	ldr	r0, [sp, #0x58]
7009c900: f020 4080    	bic	r0, r0, #0x40000000
7009c904: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtStatus);
7009c906: 9a14         	ldr	r2, [sp, #0x50]
7009c908: f102 0008    	add.w	r0, r2, #0x8
7009c90c: 9919         	ldr	r1, [sp, #0x64]
7009c90e: 6ec9         	ldr	r1, [r1, #0x6c]
7009c910: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
7009c914: 4411         	add	r1, r2
7009c916: aa0e         	add	r2, sp, #0x38
7009c918: f012 f91a    	bl	0x700aeb50 <CSL_bcdmaSetTxRT> @ imm = #0x12234
7009c91c: 9a03         	ldr	r2, [sp, #0xc]
;                 &drvHandle->bcdmaRegs,
7009c91e: 9b14         	ldr	r3, [sp, #0x50]
7009c920: f103 0008    	add.w	r0, r3, #0x8
;                 chHandle->txChNum + drvHandle->txChOffset,
7009c924: 9919         	ldr	r1, [sp, #0x64]
7009c926: 6ec9         	ldr	r1, [r1, #0x6c]
7009c928: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
7009c92c: 4419         	add	r1, r3
;                 rtEnableRegOffset,
7009c92e: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_bcdmaSetChanPeerReg(
7009c930: 46ee         	mov	lr, sp
7009c932: f10d 0c58    	add.w	r12, sp, #0x58
7009c936: f8ce c000    	str.w	r12, [lr]
7009c93a: f011 fae1    	bl	0x700adf00 <CSL_bcdmaSetChanPeerReg> @ imm = #0x115c2
;         }
7009c93e: e023         	b	0x7009c988 <Udma_chDisableTxChan+0x358> @ imm = #0x46
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009c940: 9814         	ldr	r0, [sp, #0x50]
7009c942: 6800         	ldr	r0, [r0]
7009c944: 2802         	cmp	r0, #0x2
7009c946: d11e         	bne	0x7009c986 <Udma_chDisableTxChan+0x356> @ imm = #0x3c
7009c948: e7ff         	b	0x7009c94a <Udma_chDisableTxChan+0x31a> @ imm = #-0x2
7009c94a: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009c94c: 9002         	str	r0, [sp, #0x8]
7009c94e: 9009         	str	r0, [sp, #0x24]
;             pktdmaRtStatus.teardown = FALSE;
7009c950: 900a         	str	r0, [sp, #0x28]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009c952: 900d         	str	r0, [sp, #0x34]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 0U);
7009c954: 9816         	ldr	r0, [sp, #0x58]
7009c956: f020 4080    	bic	r0, r0, #0x40000000
7009c95a: 9016         	str	r0, [sp, #0x58]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009c95c: 9814         	ldr	r0, [sp, #0x50]
7009c95e: 3054         	adds	r0, #0x54
7009c960: 9919         	ldr	r1, [sp, #0x64]
7009c962: 6ec9         	ldr	r1, [r1, #0x6c]
7009c964: aa09         	add	r2, sp, #0x24
7009c966: f011 fb2b    	bl	0x700adfc0 <CSL_pktdmaSetTxRT> @ imm = #0x11656
7009c96a: 9a02         	ldr	r2, [sp, #0x8]
;                 &drvHandle->pktdmaRegs,
7009c96c: 9814         	ldr	r0, [sp, #0x50]
7009c96e: 3054         	adds	r0, #0x54
;                 chHandle->txChNum,
7009c970: 9919         	ldr	r1, [sp, #0x64]
7009c972: 6ec9         	ldr	r1, [r1, #0x6c]
;                 rtEnableRegOffset,
7009c974: 9b08         	ldr	r3, [sp, #0x20]
;             (void) CSL_pktdmaSetChanPeerReg(
7009c976: 46ee         	mov	lr, sp
7009c978: f10d 0c58    	add.w	r12, sp, #0x58
7009c97c: f8ce c000    	str.w	r12, [lr]
7009c980: f011 ff4e    	bl	0x700ae820 <CSL_pktdmaSetChanPeerReg> @ imm = #0x11e9c
;         }
7009c984: e7ff         	b	0x7009c986 <Udma_chDisableTxChan+0x356> @ imm = #-0x2
7009c986: e7ff         	b	0x7009c988 <Udma_chDisableTxChan+0x358> @ imm = #-0x2
;     }
7009c988: e7ff         	b	0x7009c98a <Udma_chDisableTxChan+0x35a> @ imm = #-0x2
;     return (retVal);
7009c98a: 9817         	ldr	r0, [sp, #0x5c]
7009c98c: b01a         	add	sp, #0x68
7009c98e: bd80         	pop	{r7, pc}

7009c990 <Udma_eventConfig>:
; {
7009c990: b580         	push	{r7, lr}
7009c992: b098         	sub	sp, #0x60
7009c994: 9017         	str	r0, [sp, #0x5c]
7009c996: 9116         	str	r1, [sp, #0x58]
7009c998: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009c99a: 9001         	str	r0, [sp, #0x4]
7009c99c: 9015         	str	r0, [sp, #0x54]
;     eventPrms = &eventHandle->eventPrms;
7009c99e: 9916         	ldr	r1, [sp, #0x58]
7009c9a0: 3108         	adds	r1, #0x8
7009c9a2: 9110         	str	r1, [sp, #0x40]
;     rmIrqReq.valid_params           = 0U;
7009c9a4: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.global_event           = 0U;
7009c9a6: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     rmIrqReq.src_id                 = 0U;
7009c9aa: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.src_index              = 0U;
7009c9ae: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.dst_id                 = 0U;
7009c9b2: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.dst_host_irq           = 0U;
7009c9b6: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     rmIrqReq.ia_id                  = 0U;
7009c9ba: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint                   = 0U;
7009c9be: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009c9c2: f88d 002a    	strb.w	r0, [sp, #0x2a]
7009c9c6: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009c9c8: f88d 002b    	strb.w	r0, [sp, #0x2b]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009c9cc: 9810         	ldr	r0, [sp, #0x40]
7009c9ce: 6800         	ldr	r0, [r0]
7009c9d0: 2805         	cmp	r0, #0x5
7009c9d2: d00a         	beq	0x7009c9ea <Udma_eventConfig+0x5a> @ imm = #0x14
7009c9d4: e7ff         	b	0x7009c9d6 <Udma_eventConfig+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009c9d6: 9806         	ldr	r0, [sp, #0x18]
7009c9d8: f040 0010    	orr	r0, r0, #0x10
7009c9dc: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009c9de: 9816         	ldr	r0, [sp, #0x58]
7009c9e0: f010 fce6    	bl	0x700ad3b0 <Udma_eventGetId> @ imm = #0x109cc
7009c9e4: f8ad 0028    	strh.w	r0, [sp, #0x28]
;     }
7009c9e8: e7ff         	b	0x7009c9ea <Udma_eventConfig+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009c9ea: 9816         	ldr	r0, [sp, #0x58]
7009c9ec: 6d80         	ldr	r0, [r0, #0x58]
7009c9ee: f510 3f80    	cmn.w	r0, #0x10000
7009c9f2: d012         	beq	0x7009ca1a <Udma_eventConfig+0x8a> @ imm = #0x24
7009c9f4: e7ff         	b	0x7009c9f6 <Udma_eventConfig+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009c9f6: 9806         	ldr	r0, [sp, #0x18]
7009c9f8: f040 0001    	orr	r0, r0, #0x1
7009c9fc: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009c9fe: 9806         	ldr	r0, [sp, #0x18]
7009ca00: f040 0002    	orr	r0, r0, #0x2
7009ca04: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.dst_id        = drvHandle->devIdCore;
7009ca06: 9817         	ldr	r0, [sp, #0x5c]
7009ca08: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009ca0c: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmIrqReq.dst_host_irq  = (uint16_t)eventHandle->coreIntrNum;
7009ca10: 9816         	ldr	r0, [sp, #0x58]
7009ca12: 6d80         	ldr	r0, [r0, #0x58]
7009ca14: f8ad 0022    	strh.w	r0, [sp, #0x22]
;     }
7009ca18: e7ff         	b	0x7009ca1a <Udma_eventConfig+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009ca1a: 9816         	ldr	r0, [sp, #0x58]
7009ca1c: 6980         	ldr	r0, [r0, #0x18]
7009ca1e: b128         	cbz	r0, 0x7009ca2c <Udma_eventConfig+0x9c> @ imm = #0xa
7009ca20: e7ff         	b	0x7009ca22 <Udma_eventConfig+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009ca22: 9816         	ldr	r0, [sp, #0x58]
7009ca24: 6980         	ldr	r0, [r0, #0x18]
7009ca26: 6cc0         	ldr	r0, [r0, #0x4c]
7009ca28: 9014         	str	r0, [sp, #0x50]
;     }
7009ca2a: e003         	b	0x7009ca34 <Udma_eventConfig+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009ca2c: 9816         	ldr	r0, [sp, #0x58]
7009ca2e: 6cc0         	ldr	r0, [r0, #0x4c]
7009ca30: 9014         	str	r0, [sp, #0x50]
7009ca32: e7ff         	b	0x7009ca34 <Udma_eventConfig+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009ca34: 9806         	ldr	r0, [sp, #0x18]
7009ca36: f040 0004    	orr	r0, r0, #0x4
7009ca3a: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009ca3c: 9806         	ldr	r0, [sp, #0x18]
7009ca3e: f040 0008    	orr	r0, r0, #0x8
7009ca42: 9006         	str	r0, [sp, #0x18]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009ca44: 9817         	ldr	r0, [sp, #0x5c]
7009ca46: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009ca4a: f8ad 0024    	strh.w	r0, [sp, #0x24]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009ca4e: 9814         	ldr	r0, [sp, #0x50]
7009ca50: f8ad 0026    	strh.w	r0, [sp, #0x26]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009ca54: 9816         	ldr	r0, [sp, #0x58]
7009ca56: 6d00         	ldr	r0, [r0, #0x50]
7009ca58: f64f 71ff    	movw	r1, #0xffff
7009ca5c: 4288         	cmp	r0, r1
7009ca5e: d009         	beq	0x7009ca74 <Udma_eventConfig+0xe4> @ imm = #0x12
7009ca60: e7ff         	b	0x7009ca62 <Udma_eventConfig+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009ca62: 9806         	ldr	r0, [sp, #0x18]
7009ca64: f040 0020    	orr	r0, r0, #0x20
7009ca68: 9006         	str	r0, [sp, #0x18]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009ca6a: 9816         	ldr	r0, [sp, #0x58]
7009ca6c: 6d00         	ldr	r0, [r0, #0x50]
7009ca6e: f88d 002a    	strb.w	r0, [sp, #0x2a]
;     }
7009ca72: e7ff         	b	0x7009ca74 <Udma_eventConfig+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009ca74: 9810         	ldr	r0, [sp, #0x40]
7009ca76: 6800         	ldr	r0, [r0]
7009ca78: 2801         	cmp	r0, #0x1
7009ca7a: d00a         	beq	0x7009ca92 <Udma_eventConfig+0x102> @ imm = #0x14
7009ca7c: e7ff         	b	0x7009ca7e <Udma_eventConfig+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
7009ca7e: 9810         	ldr	r0, [sp, #0x40]
7009ca80: 6800         	ldr	r0, [r0]
7009ca82: 2802         	cmp	r0, #0x2
7009ca84: d005         	beq	0x7009ca92 <Udma_eventConfig+0x102> @ imm = #0xa
7009ca86: e7ff         	b	0x7009ca88 <Udma_eventConfig+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009ca88: 9810         	ldr	r0, [sp, #0x40]
7009ca8a: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009ca8c: 2806         	cmp	r0, #0x6
7009ca8e: d14d         	bne	0x7009cb2c <Udma_eventConfig+0x19c> @ imm = #0x9a
7009ca90: e7ff         	b	0x7009ca92 <Udma_eventConfig+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009ca92: 9810         	ldr	r0, [sp, #0x40]
7009ca94: 6880         	ldr	r0, [r0, #0x8]
7009ca96: 9012         	str	r0, [sp, #0x48]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009ca98: 9817         	ldr	r0, [sp, #0x5c]
7009ca9a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009ca9e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009caa2: 9810         	ldr	r0, [sp, #0x40]
7009caa4: 6800         	ldr	r0, [r0]
7009caa6: 2801         	cmp	r0, #0x1
7009caa8: d005         	beq	0x7009cab6 <Udma_eventConfig+0x126> @ imm = #0xa
7009caaa: e7ff         	b	0x7009caac <Udma_eventConfig+0x11c> @ imm = #-0x2
7009caac: 9810         	ldr	r0, [sp, #0x40]
7009caae: 6800         	ldr	r0, [r0]
7009cab0: 2806         	cmp	r0, #0x6
7009cab2: d12e         	bne	0x7009cb12 <Udma_eventConfig+0x182> @ imm = #0x5c
7009cab4: e7ff         	b	0x7009cab6 <Udma_eventConfig+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009cab6: 9812         	ldr	r0, [sp, #0x48]
7009cab8: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009cabc: 8880         	ldrh	r0, [r0, #0x4]
7009cabe: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009cac2: 9812         	ldr	r0, [sp, #0x48]
7009cac4: 7800         	ldrb	r0, [r0]
7009cac6: 0740         	lsls	r0, r0, #0x1d
7009cac8: 2800         	cmp	r0, #0x0
7009caca: d509         	bpl	0x7009cae0 <Udma_eventConfig+0x150> @ imm = #0x12
7009cacc: e7ff         	b	0x7009cace <Udma_eventConfig+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009cace: 9817         	ldr	r0, [sp, #0x5c]
7009cad0: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009cad4: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cad8: 4408         	add	r0, r1
7009cada: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cade: e017         	b	0x7009cb10 <Udma_eventConfig+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009cae0: 9812         	ldr	r0, [sp, #0x48]
7009cae2: 7800         	ldrb	r0, [r0]
7009cae4: 07c0         	lsls	r0, r0, #0x1f
7009cae6: b148         	cbz	r0, 0x7009cafc <Udma_eventConfig+0x16c> @ imm = #0x12
7009cae8: e7ff         	b	0x7009caea <Udma_eventConfig+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009caea: 9817         	ldr	r0, [sp, #0x5c]
7009caec: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009caf0: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009caf4: 4408         	add	r0, r1
7009caf6: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cafa: e008         	b	0x7009cb0e <Udma_eventConfig+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009cafc: 9817         	ldr	r0, [sp, #0x5c]
7009cafe: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009cb02: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cb06: 4408         	add	r0, r1
7009cb08: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009cb0c: e7ff         	b	0x7009cb0e <Udma_eventConfig+0x17e> @ imm = #-0x2
7009cb0e: e7ff         	b	0x7009cb10 <Udma_eventConfig+0x180> @ imm = #-0x2
;         }
7009cb10: e00b         	b	0x7009cb2a <Udma_eventConfig+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009cb12: 9812         	ldr	r0, [sp, #0x48]
7009cb14: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009cb18: 8880         	ldrh	r0, [r0, #0x4]
7009cb1a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009cb1e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cb22: 3014         	adds	r0, #0x14
7009cb24: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009cb28: e7ff         	b	0x7009cb2a <Udma_eventConfig+0x19a> @ imm = #-0x2
;     }
7009cb2a: e7ff         	b	0x7009cb2c <Udma_eventConfig+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009cb2c: 9810         	ldr	r0, [sp, #0x40]
7009cb2e: 6800         	ldr	r0, [r0]
7009cb30: 2803         	cmp	r0, #0x3
7009cb32: d156         	bne	0x7009cbe2 <Udma_eventConfig+0x252> @ imm = #0xac
7009cb34: e7ff         	b	0x7009cb36 <Udma_eventConfig+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009cb36: 9817         	ldr	r0, [sp, #0x5c]
7009cb38: 6800         	ldr	r0, [r0]
7009cb3a: 2802         	cmp	r0, #0x2
7009cb3c: d104         	bne	0x7009cb48 <Udma_eventConfig+0x1b8> @ imm = #0x8
7009cb3e: e7ff         	b	0x7009cb40 <Udma_eventConfig+0x1b0> @ imm = #-0x2
7009cb40: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009cb44: 9015         	str	r0, [sp, #0x54]
;         }
7009cb46: e04b         	b	0x7009cbe0 <Udma_eventConfig+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009cb48: 9810         	ldr	r0, [sp, #0x40]
7009cb4a: 6880         	ldr	r0, [r0, #0x8]
7009cb4c: 9012         	str	r0, [sp, #0x48]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009cb4e: 9817         	ldr	r0, [sp, #0x5c]
7009cb50: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009cb54: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009cb58: 9812         	ldr	r0, [sp, #0x48]
7009cb5a: 7800         	ldrb	r0, [r0]
7009cb5c: 0740         	lsls	r0, r0, #0x1d
7009cb5e: 2800         	cmp	r0, #0x0
7009cb60: d50d         	bpl	0x7009cb7e <Udma_eventConfig+0x1ee> @ imm = #0x1a
7009cb62: e7ff         	b	0x7009cb64 <Udma_eventConfig+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009cb64: 9812         	ldr	r0, [sp, #0x48]
7009cb66: 6ec0         	ldr	r0, [r0, #0x6c]
7009cb68: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009cb6c: 9817         	ldr	r0, [sp, #0x5c]
7009cb6e: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009cb72: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cb76: 4408         	add	r0, r1
7009cb78: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cb7c: e02f         	b	0x7009cbde <Udma_eventConfig+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009cb7e: 9812         	ldr	r0, [sp, #0x48]
7009cb80: 7800         	ldrb	r0, [r0]
7009cb82: 0780         	lsls	r0, r0, #0x1e
7009cb84: 2800         	cmp	r0, #0x0
7009cb86: d50d         	bpl	0x7009cba4 <Udma_eventConfig+0x214> @ imm = #0x1a
7009cb88: e7ff         	b	0x7009cb8a <Udma_eventConfig+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009cb8a: 9812         	ldr	r0, [sp, #0x48]
7009cb8c: 6f00         	ldr	r0, [r0, #0x70]
7009cb8e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009cb92: 9817         	ldr	r0, [sp, #0x5c]
7009cb94: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009cb98: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cb9c: 4408         	add	r0, r1
7009cb9e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cba2: e01b         	b	0x7009cbdc <Udma_eventConfig+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009cba4: 9812         	ldr	r0, [sp, #0x48]
7009cba6: 7800         	ldrb	r0, [r0]
7009cba8: 07c0         	lsls	r0, r0, #0x1f
7009cbaa: b168         	cbz	r0, 0x7009cbc8 <Udma_eventConfig+0x238> @ imm = #0x1a
7009cbac: e7ff         	b	0x7009cbae <Udma_eventConfig+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009cbae: 9812         	ldr	r0, [sp, #0x48]
7009cbb0: 6ec0         	ldr	r0, [r0, #0x6c]
7009cbb2: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009cbb6: 9817         	ldr	r0, [sp, #0x5c]
7009cbb8: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009cbbc: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cbc0: 4408         	add	r0, r1
7009cbc2: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             }
7009cbc6: e008         	b	0x7009cbda <Udma_eventConfig+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009cbc8: 9817         	ldr	r0, [sp, #0x5c]
7009cbca: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009cbce: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009cbd2: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009cbd4: f8ad 001e    	strh.w	r0, [sp, #0x1e]
7009cbd8: e7ff         	b	0x7009cbda <Udma_eventConfig+0x24a> @ imm = #-0x2
7009cbda: e7ff         	b	0x7009cbdc <Udma_eventConfig+0x24c> @ imm = #-0x2
7009cbdc: e7ff         	b	0x7009cbde <Udma_eventConfig+0x24e> @ imm = #-0x2
7009cbde: e7ff         	b	0x7009cbe0 <Udma_eventConfig+0x250> @ imm = #-0x2
;     }
7009cbe0: e7ff         	b	0x7009cbe2 <Udma_eventConfig+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009cbe2: 9810         	ldr	r0, [sp, #0x40]
7009cbe4: 6800         	ldr	r0, [r0]
7009cbe6: 2804         	cmp	r0, #0x4
7009cbe8: d130         	bne	0x7009cc4c <Udma_eventConfig+0x2bc> @ imm = #0x60
7009cbea: e7ff         	b	0x7009cbec <Udma_eventConfig+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009cbec: 9810         	ldr	r0, [sp, #0x40]
7009cbee: 68c0         	ldr	r0, [r0, #0xc]
7009cbf0: 9011         	str	r0, [sp, #0x44]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009cbf2: 9817         	ldr	r0, [sp, #0x5c]
7009cbf4: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009cbf8: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009cbfc: 9811         	ldr	r0, [sp, #0x44]
7009cbfe: 8880         	ldrh	r0, [r0, #0x4]
7009cc00: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009cc04: 9817         	ldr	r0, [sp, #0x5c]
7009cc06: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009cc0a: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cc0e: 4408         	add	r0, r1
7009cc10: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009cc14: 9811         	ldr	r0, [sp, #0x44]
7009cc16: 6dc0         	ldr	r0, [r0, #0x5c]
7009cc18: 2804         	cmp	r0, #0x4
7009cc1a: d316         	blo	0x7009cc4a <Udma_eventConfig+0x2ba> @ imm = #0x2c
7009cc1c: e7ff         	b	0x7009cc1e <Udma_eventConfig+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009cc1e: 9811         	ldr	r0, [sp, #0x44]
7009cc20: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009cc22: 2807         	cmp	r0, #0x7
7009cc24: d811         	bhi	0x7009cc4a <Udma_eventConfig+0x2ba> @ imm = #0x22
7009cc26: e7ff         	b	0x7009cc28 <Udma_eventConfig+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009cc28: 9817         	ldr	r0, [sp, #0x5c]
7009cc2a: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009cc2e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cc32: 1a40         	subs	r0, r0, r1
7009cc34: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009cc38: 9817         	ldr	r0, [sp, #0x5c]
7009cc3a: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009cc3e: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
7009cc42: 4408         	add	r0, r1
7009cc44: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         }
7009cc48: e7ff         	b	0x7009cc4a <Udma_eventConfig+0x2ba> @ imm = #-0x2
;     }
7009cc4a: e7ff         	b	0x7009cc4c <Udma_eventConfig+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009cc4c: 9815         	ldr	r0, [sp, #0x54]
7009cc4e: b9d8         	cbnz	r0, 0x7009cc88 <Udma_eventConfig+0x2f8> @ imm = #0x36
7009cc50: e7ff         	b	0x7009cc52 <Udma_eventConfig+0x2c2> @ imm = #-0x2
;         Udma_eventProgramSteering(drvHandle, eventHandle);
7009cc52: 9817         	ldr	r0, [sp, #0x5c]
7009cc54: 9916         	ldr	r1, [sp, #0x58]
7009cc56: f012 f8fb    	bl	0x700aee50 <Udma_eventProgramSteering> @ imm = #0x121f6
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009cc5a: 9817         	ldr	r0, [sp, #0x5c]
7009cc5c: 6800         	ldr	r0, [r0]
7009cc5e: b130         	cbz	r0, 0x7009cc6e <Udma_eventConfig+0x2de> @ imm = #0xc
7009cc60: e7ff         	b	0x7009cc62 <Udma_eventConfig+0x2d2> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009cc62: 9810         	ldr	r0, [sp, #0x40]
7009cc64: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009cc66: 2805         	cmp	r0, #0x5
7009cc68: d101         	bne	0x7009cc6e <Udma_eventConfig+0x2de> @ imm = #0x2
7009cc6a: e7ff         	b	0x7009cc6c <Udma_eventConfig+0x2dc> @ imm = #-0x2
;         }
7009cc6c: e00b         	b	0x7009cc86 <Udma_eventConfig+0x2f6> @ imm = #0x16
7009cc6e: a804         	add	r0, sp, #0x10
7009cc70: a902         	add	r1, sp, #0x8
7009cc72: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmIrqSet(
7009cc76: f012 fd13    	bl	0x700af6a0 <Sciclient_rmIrqSet> @ imm = #0x12a26
7009cc7a: 9015         	str	r0, [sp, #0x54]
;             if(CSL_PASS != retVal)
7009cc7c: 9815         	ldr	r0, [sp, #0x54]
7009cc7e: b108         	cbz	r0, 0x7009cc84 <Udma_eventConfig+0x2f4> @ imm = #0x2
7009cc80: e7ff         	b	0x7009cc82 <Udma_eventConfig+0x2f2> @ imm = #-0x2
;             }
7009cc82: e7ff         	b	0x7009cc84 <Udma_eventConfig+0x2f4> @ imm = #-0x2
7009cc84: e7ff         	b	0x7009cc86 <Udma_eventConfig+0x2f6> @ imm = #-0x2
;     }
7009cc86: e7ff         	b	0x7009cc88 <Udma_eventConfig+0x2f8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009cc88: 9815         	ldr	r0, [sp, #0x54]
7009cc8a: bb58         	cbnz	r0, 0x7009cce4 <Udma_eventConfig+0x354> @ imm = #0x56
7009cc8c: e7ff         	b	0x7009cc8e <Udma_eventConfig+0x2fe> @ imm = #-0x2
;         if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009cc8e: 9816         	ldr	r0, [sp, #0x58]
7009cc90: 6d80         	ldr	r0, [r0, #0x58]
7009cc92: f510 3f80    	cmn.w	r0, #0x10000
7009cc96: d024         	beq	0x7009cce2 <Udma_eventConfig+0x352> @ imm = #0x48
7009cc98: e7ff         	b	0x7009cc9a <Udma_eventConfig+0x30a> @ imm = #-0x2
;             coreIntrNum = eventHandle->coreIntrNum;
7009cc9a: 9816         	ldr	r0, [sp, #0x58]
7009cc9c: 6d80         	ldr	r0, [r0, #0x58]
7009cc9e: 9013         	str	r0, [sp, #0x4c]
7009cca0: a80b         	add	r0, sp, #0x2c
;             HwiP_Params_init(&hwiPrms);
7009cca2: 9000         	str	r0, [sp]
7009cca4: f013 f954    	bl	0x700aff50 <HwiP_Params_init> @ imm = #0x132a8
7009cca8: 9900         	ldr	r1, [sp]
;             hwiPrms.intNum = coreIntrNum;
7009ccaa: 9813         	ldr	r0, [sp, #0x4c]
7009ccac: 900b         	str	r0, [sp, #0x2c]
;             hwiPrms.callback = &Udma_eventIsrFxn;
7009ccae: f645 2031    	movw	r0, #0x5a31
7009ccb2: f2c7 000a    	movt	r0, #0x700a
7009ccb6: 900c         	str	r0, [sp, #0x30]
;             hwiPrms.args = eventHandle;
7009ccb8: 9816         	ldr	r0, [sp, #0x58]
7009ccba: 900d         	str	r0, [sp, #0x34]
;             hwiPrms.priority = eventHandle->eventPrms.intrPriority;
7009ccbc: 9816         	ldr	r0, [sp, #0x58]
7009ccbe: 6a00         	ldr	r0, [r0, #0x20]
7009ccc0: f88d 003a    	strb.w	r0, [sp, #0x3a]
;             retVal = HwiP_construct(&eventHandle->hwiObject, &hwiPrms);
7009ccc4: 9816         	ldr	r0, [sp, #0x58]
7009ccc6: 3068         	adds	r0, #0x68
7009ccc8: f013 f95a    	bl	0x700aff80 <HwiP_construct> @ imm = #0x132b4
7009cccc: 9015         	str	r0, [sp, #0x54]
;             if(SystemP_SUCCESS != retVal)
7009ccce: 9815         	ldr	r0, [sp, #0x54]
7009ccd0: b108         	cbz	r0, 0x7009ccd6 <Udma_eventConfig+0x346> @ imm = #0x2
7009ccd2: e7ff         	b	0x7009ccd4 <Udma_eventConfig+0x344> @ imm = #-0x2
;             }
7009ccd4: e004         	b	0x7009cce0 <Udma_eventConfig+0x350> @ imm = #0x8
;                 eventHandle->hwiHandle = &eventHandle->hwiObject;
7009ccd6: 9916         	ldr	r1, [sp, #0x58]
7009ccd8: f101 0068    	add.w	r0, r1, #0x68
7009ccdc: 6648         	str	r0, [r1, #0x64]
7009ccde: e7ff         	b	0x7009cce0 <Udma_eventConfig+0x350> @ imm = #-0x2
;         }
7009cce0: e7ff         	b	0x7009cce2 <Udma_eventConfig+0x352> @ imm = #-0x2
;     }
7009cce2: e7ff         	b	0x7009cce4 <Udma_eventConfig+0x354> @ imm = #-0x2
;     return (retVal);
7009cce4: 9815         	ldr	r0, [sp, #0x54]
7009cce6: b018         	add	sp, #0x60
7009cce8: bd80         	pop	{r7, pc}
7009ccea: 0000         	movs	r0, r0
7009ccec: 0000         	movs	r0, r0
7009ccee: 0000         	movs	r0, r0

7009ccf0 <Sciclient_rmIrqGetRoute>:
; {
7009ccf0: b580         	push	{r7, lr}
7009ccf2: b08e         	sub	sp, #0x38
7009ccf4: 900d         	str	r0, [sp, #0x34]
7009ccf6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009ccf8: 900c         	str	r0, [sp, #0x30]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009ccfa: 980d         	ldr	r0, [sp, #0x34]
7009ccfc: 88c0         	ldrh	r0, [r0, #0x6]
7009ccfe: f011 fe1f    	bl	0x700ae940 <Sciclient_rmIrIsIr> @ imm = #0x11c3e
7009cd02: b930         	cbnz	r0, 0x7009cd12 <Sciclient_rmIrqGetRoute+0x22> @ imm = #0xc
7009cd04: e7ff         	b	0x7009cd06 <Sciclient_rmIrqGetRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009cd06: 980d         	ldr	r0, [sp, #0x34]
7009cd08: 8940         	ldrh	r0, [r0, #0xa]
7009cd0a: f011 fe19    	bl	0x700ae940 <Sciclient_rmIrIsIr> @ imm = #0x11c32
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009cd0e: b120         	cbz	r0, 0x7009cd1a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #0x8
7009cd10: e7ff         	b	0x7009cd12 <Sciclient_rmIrqGetRoute+0x22> @ imm = #-0x2
7009cd12: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009cd16: 900c         	str	r0, [sp, #0x30]
;     }
7009cd18: e7ff         	b	0x7009cd1a <Sciclient_rmIrqGetRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cd1a: 980c         	ldr	r0, [sp, #0x30]
7009cd1c: 2800         	cmp	r0, #0x0
7009cd1e: d156         	bne	0x7009cdce <Sciclient_rmIrqGetRoute+0xde> @ imm = #0xac
7009cd20: e7ff         	b	0x7009cd22 <Sciclient_rmIrqGetRoute+0x32> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cd22: 980d         	ldr	r0, [sp, #0x34]
7009cd24: 8a00         	ldrh	r0, [r0, #0x10]
7009cd26: 28ff         	cmp	r0, #0xff
7009cd28: d042         	beq	0x7009cdb0 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x84
7009cd2a: e7ff         	b	0x7009cd2c <Sciclient_rmIrqGetRoute+0x3c> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cd2c: 980d         	ldr	r0, [sp, #0x34]
7009cd2e: 6800         	ldr	r0, [r0]
7009cd30: 2104         	movs	r1, #0x4
7009cd32: f011 ffe5    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x11fca
;              true) &&
7009cd36: b3d8         	cbz	r0, 0x7009cdb0 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x76
7009cd38: e7ff         	b	0x7009cd3a <Sciclient_rmIrqGetRoute+0x4a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009cd3a: 980d         	ldr	r0, [sp, #0x34]
7009cd3c: 6800         	ldr	r0, [r0]
7009cd3e: 2108         	movs	r1, #0x8
7009cd40: f011 ffde    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x11fbc
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009cd44: b3a0         	cbz	r0, 0x7009cdb0 <Sciclient_rmIrqGetRoute+0xc0> @ imm = #0x68
7009cd46: e7ff         	b	0x7009cd48 <Sciclient_rmIrqGetRoute+0x58> @ imm = #-0x2
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009cd48: 980d         	ldr	r0, [sp, #0x34]
7009cd4a: 6800         	ldr	r0, [r0]
7009cd4c: 2110         	movs	r1, #0x10
7009cd4e: f011 ffd7    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x11fae
;                  true) &&
7009cd52: b1d0         	cbz	r0, 0x7009cd8a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x34
7009cd54: e7ff         	b	0x7009cd56 <Sciclient_rmIrqGetRoute+0x66> @ imm = #-0x2
;                 (Sciclient_rmParamIsValid(cfg->valid_params,
7009cd56: 980d         	ldr	r0, [sp, #0x34]
7009cd58: 6800         	ldr	r0, [r0]
7009cd5a: 2120         	movs	r1, #0x20
7009cd5c: f011 ffd0    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x11fa0
;             if ((Sciclient_rmParamIsValid(cfg->valid_params,
7009cd60: b198         	cbz	r0, 0x7009cd8a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #0x26
7009cd62: e7ff         	b	0x7009cd64 <Sciclient_rmIrqGetRoute+0x74> @ imm = #-0x2
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009cd64: f8dd c034    	ldr.w	r12, [sp, #0x34]
7009cd68: f8bc 1010    	ldrh.w	r1, [r12, #0x10]
;                                cfg->vint, cfg->global_evt,
7009cd6c: f8bc 2012    	ldrh.w	r2, [r12, #0x12]
7009cd70: f8bc 300e    	ldrh.w	r3, [r12, #0xe]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009cd74: f89c 0004    	ldrb.w	r0, [r12, #0x4]
;                                cfg->vint_sb);
7009cd78: f89c c014    	ldrb.w	r12, [r12, #0x14]
;                 r = Sciclient_rmIaValidateMapping(cfg->host, cfg->s_ia,
7009cd7c: 46ee         	mov	lr, sp
7009cd7e: f8ce c000    	str.w	r12, [lr]
7009cd82: f005 fd25    	bl	0x700a27d0 <Sciclient_rmIaValidateMapping> @ imm = #0x5a4a
7009cd86: 900c         	str	r0, [sp, #0x30]
;             }
7009cd88: e7ff         	b	0x7009cd8a <Sciclient_rmIrqGetRoute+0x9a> @ imm = #-0x2
;             if (r == SystemP_SUCCESS) {
7009cd8a: 980c         	ldr	r0, [sp, #0x30]
7009cd8c: b978         	cbnz	r0, 0x7009cdae <Sciclient_rmIrqGetRoute+0xbe> @ imm = #0x1e
7009cd8e: e7ff         	b	0x7009cd90 <Sciclient_rmIrqGetRoute+0xa0> @ imm = #-0x2
;                 inp = cfg->global_evt;
7009cd90: 980d         	ldr	r0, [sp, #0x34]
7009cd92: 89c0         	ldrh	r0, [r0, #0xe]
7009cd94: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = cfg->vint;
7009cd98: 980d         	ldr	r0, [sp, #0x34]
7009cd9a: 8a40         	ldrh	r0, [r0, #0x12]
7009cd9c: f8ad 0024    	strh.w	r0, [sp, #0x24]
;                 r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009cda0: 980d         	ldr	r0, [sp, #0x34]
7009cda2: 8a00         	ldrh	r0, [r0, #0x10]
7009cda4: a906         	add	r1, sp, #0x18
7009cda6: f009 f89b    	bl	0x700a5ee0 <Sciclient_rmIrqGetNode> @ imm = #0x9136
7009cdaa: 900c         	str	r0, [sp, #0x30]
;             }
7009cdac: e7ff         	b	0x7009cdae <Sciclient_rmIrqGetRoute+0xbe> @ imm = #-0x2
;         } else {
7009cdae: e00d         	b	0x7009cdcc <Sciclient_rmIrqGetRoute+0xdc> @ imm = #0x1a
7009cdb0: 2000         	movs	r0, #0x0
;             inp = 0u;
7009cdb2: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             outp = cfg->s_idx;
7009cdb6: 980d         	ldr	r0, [sp, #0x34]
7009cdb8: 8900         	ldrh	r0, [r0, #0x8]
7009cdba: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009cdbe: 980d         	ldr	r0, [sp, #0x34]
7009cdc0: 88c0         	ldrh	r0, [r0, #0x6]
7009cdc2: a906         	add	r1, sp, #0x18
7009cdc4: f009 f88c    	bl	0x700a5ee0 <Sciclient_rmIrqGetNode> @ imm = #0x9118
7009cdc8: 900c         	str	r0, [sp, #0x30]
7009cdca: e7ff         	b	0x7009cdcc <Sciclient_rmIrqGetRoute+0xdc> @ imm = #-0x2
;     }
7009cdcc: e7ff         	b	0x7009cdce <Sciclient_rmIrqGetRoute+0xde> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009cdce: 980c         	ldr	r0, [sp, #0x30]
7009cdd0: b948         	cbnz	r0, 0x7009cde6 <Sciclient_rmIrqGetRoute+0xf6> @ imm = #0x12
7009cdd2: e7ff         	b	0x7009cdd4 <Sciclient_rmIrqGetRoute+0xe4> @ imm = #-0x2
7009cdd4: 2001         	movs	r0, #0x1
;         search = true;
7009cdd6: f88d 0021    	strb.w	r0, [sp, #0x21]
7009cdda: 2000         	movs	r0, #0x0
;         rt_complete = false;
7009cddc: f88d 0020    	strb.w	r0, [sp, #0x20]
;         Sciclient_rmPsInit();
7009cde0: f012 fb2e    	bl	0x700af440 <Sciclient_rmPsInit> @ imm = #0x1265c
;     } else {
7009cde4: e003         	b	0x7009cdee <Sciclient_rmIrqGetRoute+0xfe> @ imm = #0x6
7009cde6: 2000         	movs	r0, #0x0
;         search = false;
7009cde8: f88d 0021    	strb.w	r0, [sp, #0x21]
7009cdec: e7ff         	b	0x7009cdee <Sciclient_rmIrqGetRoute+0xfe> @ imm = #-0x2
7009cdee: 2000         	movs	r0, #0x0
;     for (search_depth = 0u;
7009cdf0: f8ad 002e    	strh.w	r0, [sp, #0x2e]
7009cdf4: e7ff         	b	0x7009cdf6 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x2
;          (search_depth < Sciclient_rmPsGetMaxPsp()) && (search == true);
7009cdf6: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cdfa: 9002         	str	r0, [sp, #0x8]
7009cdfc: f012 ffa0    	bl	0x700afd40 <Sciclient_rmPsGetMaxPsp> @ imm = #0x12f40
7009ce00: 9902         	ldr	r1, [sp, #0x8]
7009ce02: 4602         	mov	r2, r0
7009ce04: 2000         	movs	r0, #0x0
7009ce06: 4291         	cmp	r1, r2
7009ce08: 9003         	str	r0, [sp, #0xc]
7009ce0a: da06         	bge	0x7009ce1a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #0xc
7009ce0c: e7ff         	b	0x7009ce0e <Sciclient_rmIrqGetRoute+0x11e> @ imm = #-0x2
7009ce0e: f89d 0021    	ldrb.w	r0, [sp, #0x21]
7009ce12: f000 0001    	and	r0, r0, #0x1
7009ce16: 9003         	str	r0, [sp, #0xc]
7009ce18: e7ff         	b	0x7009ce1a <Sciclient_rmIrqGetRoute+0x12a> @ imm = #-0x2
7009ce1a: 9803         	ldr	r0, [sp, #0xc]
;     for (search_depth = 0u;
7009ce1c: 07c0         	lsls	r0, r0, #0x1f
7009ce1e: 2800         	cmp	r0, #0x0
7009ce20: f000 80d8    	beq.w	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x1b0
7009ce24: e7ff         	b	0x7009ce26 <Sciclient_rmIrqGetRoute+0x136> @ imm = #-0x2
7009ce26: 2000         	movs	r0, #0x0
;         push_node = false;
7009ce28: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009ce2c: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009ce30: e7ff         	b	0x7009ce32 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0x2
7009ce32: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009ce36: 9906         	ldr	r1, [sp, #0x18]
7009ce38: 8849         	ldrh	r1, [r1, #0x2]
7009ce3a: 4288         	cmp	r0, r1
7009ce3c: da6b         	bge	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xd6
7009ce3e: e7ff         	b	0x7009ce40 <Sciclient_rmIrqGetRoute+0x150> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009ce40: 9806         	ldr	r0, [sp, #0x18]
7009ce42: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009ce46: aa04         	add	r2, sp, #0x10
7009ce48: f010 fe1a    	bl	0x700ada80 <Sciclient_rmIrqGetNodeItf> @ imm = #0x10c34
7009ce4c: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009ce4e: 980c         	ldr	r0, [sp, #0x30]
7009ce50: b108         	cbz	r0, 0x7009ce56 <Sciclient_rmIrqGetRoute+0x166> @ imm = #0x2
7009ce52: e7ff         	b	0x7009ce54 <Sciclient_rmIrqGetRoute+0x164> @ imm = #-0x2
;                 break;
7009ce54: e05f         	b	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0xbe
;             if ((outp >= cur_if->lbase) &&
7009ce56: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009ce5a: 9904         	ldr	r1, [sp, #0x10]
7009ce5c: 8809         	ldrh	r1, [r1]
7009ce5e: 4288         	cmp	r0, r1
7009ce60: db52         	blt	0x7009cf08 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0xa4
7009ce62: e7ff         	b	0x7009ce64 <Sciclient_rmIrqGetRoute+0x174> @ imm = #-0x2
;                 (outp < (cur_if->lbase + cur_if->len))) {
7009ce64: f8bd 0024    	ldrh.w	r0, [sp, #0x24]
7009ce68: 9a04         	ldr	r2, [sp, #0x10]
7009ce6a: 8811         	ldrh	r1, [r2]
7009ce6c: 8892         	ldrh	r2, [r2, #0x4]
7009ce6e: 4411         	add	r1, r2
;             if ((outp >= cur_if->lbase) &&
7009ce70: 4288         	cmp	r0, r1
7009ce72: da49         	bge	0x7009cf08 <Sciclient_rmIrqGetRoute+0x218> @ imm = #0x92
7009ce74: e7ff         	b	0x7009ce76 <Sciclient_rmIrqGetRoute+0x186> @ imm = #-0x2
;                 if ((cur_if->rid == cfg->d_id) &&
7009ce76: 9804         	ldr	r0, [sp, #0x10]
7009ce78: 88c0         	ldrh	r0, [r0, #0x6]
7009ce7a: 990d         	ldr	r1, [sp, #0x34]
7009ce7c: 8949         	ldrh	r1, [r1, #0xa]
7009ce7e: 4288         	cmp	r0, r1
7009ce80: d110         	bne	0x7009cea4 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x20
7009ce82: e7ff         	b	0x7009ce84 <Sciclient_rmIrqGetRoute+0x194> @ imm = #-0x2
;                     (SCICLIENT_OUTP_TO_INP(outp, cur_if->lbase,
7009ce84: 9a04         	ldr	r2, [sp, #0x10]
7009ce86: 8850         	ldrh	r0, [r2, #0x2]
7009ce88: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009ce8c: 8812         	ldrh	r2, [r2]
7009ce8e: 1a89         	subs	r1, r1, r2
7009ce90: 4408         	add	r0, r1
;                      cfg->d_irq)) {
7009ce92: 990d         	ldr	r1, [sp, #0x34]
7009ce94: 8989         	ldrh	r1, [r1, #0xc]
;                 if ((cur_if->rid == cfg->d_id) &&
7009ce96: 4288         	cmp	r0, r1
7009ce98: d104         	bne	0x7009cea4 <Sciclient_rmIrqGetRoute+0x1b4> @ imm = #0x8
7009ce9a: e7ff         	b	0x7009ce9c <Sciclient_rmIrqGetRoute+0x1ac> @ imm = #-0x2
7009ce9c: 2001         	movs	r0, #0x1
;                     rt_complete = true;
7009ce9e: f88d 0020    	strb.w	r0, [sp, #0x20]
;                     break;
7009cea2: e038         	b	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x70
;                 if (Sciclient_rmIrIsIr(cur_if->rid) == true) {
7009cea4: 9804         	ldr	r0, [sp, #0x10]
7009cea6: 88c0         	ldrh	r0, [r0, #0x6]
7009cea8: f011 fd4a    	bl	0x700ae940 <Sciclient_rmIrIsIr> @ imm = #0x11a94
7009ceac: b358         	cbz	r0, 0x7009cf06 <Sciclient_rmIrqGetRoute+0x216> @ imm = #0x56
7009ceae: e7ff         	b	0x7009ceb0 <Sciclient_rmIrqGetRoute+0x1c0> @ imm = #-0x2
;                     r = Sciclient_rmIrqGetNode(cur_if->rid, &next_n);
7009ceb0: 9804         	ldr	r0, [sp, #0x10]
7009ceb2: 88c0         	ldrh	r0, [r0, #0x6]
7009ceb4: a905         	add	r1, sp, #0x14
7009ceb6: f009 f813    	bl	0x700a5ee0 <Sciclient_rmIrqGetNode> @ imm = #0x9026
7009ceba: 900c         	str	r0, [sp, #0x30]
;                     if (r != SystemP_SUCCESS) {
7009cebc: 980c         	ldr	r0, [sp, #0x30]
7009cebe: b108         	cbz	r0, 0x7009cec4 <Sciclient_rmIrqGetRoute+0x1d4> @ imm = #0x2
7009cec0: e7ff         	b	0x7009cec2 <Sciclient_rmIrqGetRoute+0x1d2> @ imm = #-0x2
;                         break;
7009cec2: e028         	b	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x50
;                     next_inp = SCICLIENT_OUTP_TO_INP(outp,
7009cec4: 9a04         	ldr	r2, [sp, #0x10]
7009cec6: 8850         	ldrh	r0, [r2, #0x2]
7009cec8: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
7009cecc: 8812         	ldrh	r2, [r2]
7009cece: 1a89         	subs	r1, r1, r2
7009ced0: 4408         	add	r0, r1
7009ced2: f8ad 0026    	strh.w	r0, [sp, #0x26]
;                     r = Sciclient_rmIrGetOutp(next_n->id, next_inp,
7009ced6: 9805         	ldr	r0, [sp, #0x14]
7009ced8: 8800         	ldrh	r0, [r0]
7009ceda: f8bd 1026    	ldrh.w	r1, [sp, #0x26]
7009cede: f10d 0222    	add.w	r2, sp, #0x22
7009cee2: f008 fc2d    	bl	0x700a5740 <Sciclient_rmIrGetOutp> @ imm = #0x885a
7009cee6: 900c         	str	r0, [sp, #0x30]
;                     if (r == SystemP_SUCCESS) {
7009cee8: 980c         	ldr	r0, [sp, #0x30]
7009ceea: b930         	cbnz	r0, 0x7009cefa <Sciclient_rmIrqGetRoute+0x20a> @ imm = #0xc
7009ceec: e7ff         	b	0x7009ceee <Sciclient_rmIrqGetRoute+0x1fe> @ imm = #-0x2
7009ceee: 2001         	movs	r0, #0x1
;                         push_node = true;
7009cef0: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009cef4: 2000         	movs	r0, #0x0
;                         r = SystemP_SUCCESS;
7009cef6: 900c         	str	r0, [sp, #0x30]
;                         break;
7009cef8: e00d         	b	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x1a
;                     if (r != SystemP_FAILURE) {
7009cefa: 980c         	ldr	r0, [sp, #0x30]
7009cefc: 3001         	adds	r0, #0x1
7009cefe: b108         	cbz	r0, 0x7009cf04 <Sciclient_rmIrqGetRoute+0x214> @ imm = #0x2
7009cf00: e7ff         	b	0x7009cf02 <Sciclient_rmIrqGetRoute+0x212> @ imm = #-0x2
;                         break;
7009cf02: e008         	b	0x7009cf16 <Sciclient_rmIrqGetRoute+0x226> @ imm = #0x10
;                 }
7009cf04: e7ff         	b	0x7009cf06 <Sciclient_rmIrqGetRoute+0x216> @ imm = #-0x2
;             }
7009cf06: e7ff         	b	0x7009cf08 <Sciclient_rmIrqGetRoute+0x218> @ imm = #-0x2
;         }
7009cf08: e7ff         	b	0x7009cf0a <Sciclient_rmIrqGetRoute+0x21a> @ imm = #-0x2
;         for (if_idx = 0u; if_idx < cur_n->n_if; if_idx++) {
7009cf0a: f8bd 002c    	ldrh.w	r0, [sp, #0x2c]
7009cf0e: 3001         	adds	r0, #0x1
7009cf10: f8ad 002c    	strh.w	r0, [sp, #0x2c]
7009cf14: e78d         	b	0x7009ce32 <Sciclient_rmIrqGetRoute+0x142> @ imm = #-0xe6
;         if (r != SystemP_SUCCESS) {
7009cf16: 980c         	ldr	r0, [sp, #0x30]
7009cf18: b108         	cbz	r0, 0x7009cf1e <Sciclient_rmIrqGetRoute+0x22e> @ imm = #0x2
7009cf1a: e7ff         	b	0x7009cf1c <Sciclient_rmIrqGetRoute+0x22c> @ imm = #-0x2
;             break;
7009cf1c: e05a         	b	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0xb4
;         if ((rt_complete == true) || (push_node == true)) {
7009cf1e: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009cf22: 07c0         	lsls	r0, r0, #0x1f
7009cf24: b930         	cbnz	r0, 0x7009cf34 <Sciclient_rmIrqGetRoute+0x244> @ imm = #0xc
7009cf26: e7ff         	b	0x7009cf28 <Sciclient_rmIrqGetRoute+0x238> @ imm = #-0x2
7009cf28: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009cf2c: 07c0         	lsls	r0, r0, #0x1f
7009cf2e: 2800         	cmp	r0, #0x0
7009cf30: d049         	beq	0x7009cfc6 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #0x92
7009cf32: e7ff         	b	0x7009cf34 <Sciclient_rmIrqGetRoute+0x244> @ imm = #-0x2
;             r = Sciclient_rmPsPush(cur_n, if_idx);
7009cf34: 9806         	ldr	r0, [sp, #0x18]
7009cf36: f8bd 102c    	ldrh.w	r1, [sp, #0x2c]
7009cf3a: f00f fb31    	bl	0x700ac5a0 <Sciclient_rmPsPush> @ imm = #0xf662
7009cf3e: 900c         	str	r0, [sp, #0x30]
;             if (r != SystemP_SUCCESS) {
7009cf40: 980c         	ldr	r0, [sp, #0x30]
7009cf42: b108         	cbz	r0, 0x7009cf48 <Sciclient_rmIrqGetRoute+0x258> @ imm = #0x2
7009cf44: e7ff         	b	0x7009cf46 <Sciclient_rmIrqGetRoute+0x256> @ imm = #-0x2
;                 break;
7009cf46: e045         	b	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x8a
;             if ((search_depth > 0u) ||
7009cf48: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cf4c: b950         	cbnz	r0, 0x7009cf64 <Sciclient_rmIrqGetRoute+0x274> @ imm = #0x14
7009cf4e: e7ff         	b	0x7009cf50 <Sciclient_rmIrqGetRoute+0x260> @ imm = #-0x2
;                 ((search_depth == 0u) &&
7009cf50: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cf54: bb28         	cbnz	r0, 0x7009cfa2 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x4a
7009cf56: e7ff         	b	0x7009cf58 <Sciclient_rmIrqGetRoute+0x268> @ imm = #-0x2
;                  (Sciclient_rmIaIsIa(cur_n->id) == true))) {
7009cf58: 9806         	ldr	r0, [sp, #0x18]
7009cf5a: 8800         	ldrh	r0, [r0]
7009cf5c: f011 fcd8    	bl	0x700ae910 <Sciclient_rmIaIsIa> @ imm = #0x119b0
;             if ((search_depth > 0u) ||
7009cf60: b1f8         	cbz	r0, 0x7009cfa2 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #0x3e
7009cf62: e7ff         	b	0x7009cf64 <Sciclient_rmIrqGetRoute+0x274> @ imm = #-0x2
;                 cur_psp = Sciclient_rmPsGetPsp();
7009cf64: f012 fe8c    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0x12d18
7009cf68: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 r = Sciclient_rmPsSetInp(cur_psp - (1u), inp);
7009cf6c: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009cf70: 3801         	subs	r0, #0x1
7009cf72: f8bd 1028    	ldrh.w	r1, [sp, #0x28]
7009cf76: b280         	uxth	r0, r0
7009cf78: f010 f9ca    	bl	0x700ad310 <Sciclient_rmPsSetInp> @ imm = #0x10394
7009cf7c: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009cf7e: 980c         	ldr	r0, [sp, #0x30]
7009cf80: b108         	cbz	r0, 0x7009cf86 <Sciclient_rmIrqGetRoute+0x296> @ imm = #0x2
7009cf82: e7ff         	b	0x7009cf84 <Sciclient_rmIrqGetRoute+0x294> @ imm = #-0x2
;                     break;
7009cf84: e026         	b	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x4c
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009cf86: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
7009cf8a: 3801         	subs	r0, #0x1
;                         outp);
7009cf8c: f8bd 1024    	ldrh.w	r1, [sp, #0x24]
;                 r = Sciclient_rmPsSetOutp(cur_psp - (1u),
7009cf90: b280         	uxth	r0, r0
7009cf92: f010 f9e5    	bl	0x700ad360 <Sciclient_rmPsSetOutp> @ imm = #0x103ca
7009cf96: 900c         	str	r0, [sp, #0x30]
;                 if (r != SystemP_SUCCESS) {
7009cf98: 980c         	ldr	r0, [sp, #0x30]
7009cf9a: b108         	cbz	r0, 0x7009cfa0 <Sciclient_rmIrqGetRoute+0x2b0> @ imm = #0x2
7009cf9c: e7ff         	b	0x7009cf9e <Sciclient_rmIrqGetRoute+0x2ae> @ imm = #-0x2
;                     break;
7009cf9e: e019         	b	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x32
;             }
7009cfa0: e7ff         	b	0x7009cfa2 <Sciclient_rmIrqGetRoute+0x2b2> @ imm = #-0x2
;             if (rt_complete == true) {
7009cfa2: f89d 0020    	ldrb.w	r0, [sp, #0x20]
7009cfa6: 07c0         	lsls	r0, r0, #0x1f
7009cfa8: b108         	cbz	r0, 0x7009cfae <Sciclient_rmIrqGetRoute+0x2be> @ imm = #0x2
7009cfaa: e7ff         	b	0x7009cfac <Sciclient_rmIrqGetRoute+0x2bc> @ imm = #-0x2
;                 break;
7009cfac: e012         	b	0x7009cfd4 <Sciclient_rmIrqGetRoute+0x2e4> @ imm = #0x24
;                 cur_n = next_n;
7009cfae: 9805         	ldr	r0, [sp, #0x14]
7009cfb0: 9006         	str	r0, [sp, #0x18]
;                 inp = next_inp;
7009cfb2: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
7009cfb6: f8ad 0028    	strh.w	r0, [sp, #0x28]
;                 outp = next_outp;
7009cfba: f8bd 0022    	ldrh.w	r0, [sp, #0x22]
7009cfbe: f8ad 0024    	strh.w	r0, [sp, #0x24]
7009cfc2: e7ff         	b	0x7009cfc4 <Sciclient_rmIrqGetRoute+0x2d4> @ imm = #-0x2
;         }
7009cfc4: e7ff         	b	0x7009cfc6 <Sciclient_rmIrqGetRoute+0x2d6> @ imm = #-0x2
;     }
7009cfc6: e7ff         	b	0x7009cfc8 <Sciclient_rmIrqGetRoute+0x2d8> @ imm = #-0x2
;          search_depth++) {
7009cfc8: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cfcc: 3001         	adds	r0, #0x1
7009cfce: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;     for (search_depth = 0u;
7009cfd2: e710         	b	0x7009cdf6 <Sciclient_rmIrqGetRoute+0x106> @ imm = #-0x1e0
;     if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009cfd4: f8bd 002e    	ldrh.w	r0, [sp, #0x2e]
7009cfd8: 9001         	str	r0, [sp, #0x4]
7009cfda: f012 feb1    	bl	0x700afd40 <Sciclient_rmPsGetMaxPsp> @ imm = #0x12d62
7009cfde: 4601         	mov	r1, r0
7009cfe0: 9801         	ldr	r0, [sp, #0x4]
7009cfe2: 4288         	cmp	r0, r1
7009cfe4: db04         	blt	0x7009cff0 <Sciclient_rmIrqGetRoute+0x300> @ imm = #0x8
7009cfe6: e7ff         	b	0x7009cfe8 <Sciclient_rmIrqGetRoute+0x2f8> @ imm = #-0x2
7009cfe8: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
7009cfec: 900c         	str	r0, [sp, #0x30]
;     }
7009cfee: e7ff         	b	0x7009cff0 <Sciclient_rmIrqGetRoute+0x300> @ imm = #-0x2
;     return r;
7009cff0: 980c         	ldr	r0, [sp, #0x30]
7009cff2: b00e         	add	sp, #0x38
7009cff4: bd80         	pop	{r7, pc}
7009cff6: 0000         	movs	r0, r0

7009cff8 <$Ven$TA$L$PI$$HwiP_enable>:
7009cff8: f8df f000    	ldr.w	pc, [pc, #0x0]          @ 0x7009cffc <$Ven$TA$L$PI$$HwiP_enable+0x4>
7009cffc: 80 09 0b 70  	.word	0x700b0980

7009d000 <Udma_eventReset>:
; {
7009d000: b580         	push	{r7, lr}
7009d002: b090         	sub	sp, #0x40
7009d004: 900f         	str	r0, [sp, #0x3c]
7009d006: 910e         	str	r1, [sp, #0x38]
7009d008: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d00a: 9001         	str	r0, [sp, #0x4]
7009d00c: 900d         	str	r0, [sp, #0x34]
;     eventPrms = &eventHandle->eventPrms;
7009d00e: 990e         	ldr	r1, [sp, #0x38]
7009d010: 3108         	adds	r1, #0x8
7009d012: 9109         	str	r1, [sp, #0x24]
;     rmIrqReq.valid_params           = 0U;
7009d014: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.global_event           = 0U;
7009d016: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     rmIrqReq.src_id                 = 0U;
7009d01a: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     rmIrqReq.src_index              = 0U;
7009d01e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;     rmIrqReq.dst_id                 = 0U;
7009d022: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     rmIrqReq.dst_host_irq           = 0U;
7009d026: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     rmIrqReq.ia_id                  = 0U;
7009d02a: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint                   = 0U;
7009d02e: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     rmIrqReq.vint_status_bit_index  = 0U;
7009d032: f88d 0022    	strb.w	r0, [sp, #0x22]
7009d036: 20ff         	movs	r0, #0xff
;     rmIrqReq.secondary_host         = TISCI_MSG_VALUE_RM_UNUSED_SECONDARY_HOST;
7009d038: f88d 0023    	strb.w	r0, [sp, #0x23]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009d03c: 9809         	ldr	r0, [sp, #0x24]
7009d03e: 6800         	ldr	r0, [r0]
7009d040: 2805         	cmp	r0, #0x5
7009d042: d00a         	beq	0x7009d05a <Udma_eventReset+0x5a> @ imm = #0x14
7009d044: e7ff         	b	0x7009d046 <Udma_eventReset+0x46> @ imm = #-0x2
;         rmIrqReq.valid_params  |= TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID;
7009d046: 9804         	ldr	r0, [sp, #0x10]
7009d048: f040 0010    	orr	r0, r0, #0x10
7009d04c: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.global_event   = (uint16_t)Udma_eventGetId(eventHandle);
7009d04e: 980e         	ldr	r0, [sp, #0x38]
7009d050: f010 f9ae    	bl	0x700ad3b0 <Udma_eventGetId> @ imm = #0x1035c
7009d054: f8ad 0020    	strh.w	r0, [sp, #0x20]
;     }
7009d058: e7ff         	b	0x7009d05a <Udma_eventReset+0x5a> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->coreIntrNum)
7009d05a: 980e         	ldr	r0, [sp, #0x38]
7009d05c: 6d80         	ldr	r0, [r0, #0x58]
7009d05e: f510 3f80    	cmn.w	r0, #0x10000
7009d062: d012         	beq	0x7009d08a <Udma_eventReset+0x8a> @ imm = #0x24
7009d064: e7ff         	b	0x7009d066 <Udma_eventReset+0x66> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_ID_VALID;
7009d066: 9804         	ldr	r0, [sp, #0x10]
7009d068: f040 0001    	orr	r0, r0, #0x1
7009d06c: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID;
7009d06e: 9804         	ldr	r0, [sp, #0x10]
7009d070: f040 0002    	orr	r0, r0, #0x2
7009d074: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.dst_id       = drvHandle->devIdCore;
7009d076: 980f         	ldr	r0, [sp, #0x3c]
7009d078: f8b0 00ea    	ldrh.w	r0, [r0, #0xea]
7009d07c: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmIrqReq.dst_host_irq = (uint16_t)eventHandle->coreIntrNum;
7009d080: 980e         	ldr	r0, [sp, #0x38]
7009d082: 6d80         	ldr	r0, [r0, #0x58]
7009d084: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     }
7009d088: e7ff         	b	0x7009d08a <Udma_eventReset+0x8a> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->eventPrms.controllerEventHandle)
7009d08a: 980e         	ldr	r0, [sp, #0x38]
7009d08c: 6980         	ldr	r0, [r0, #0x18]
7009d08e: b128         	cbz	r0, 0x7009d09c <Udma_eventReset+0x9c> @ imm = #0xa
7009d090: e7ff         	b	0x7009d092 <Udma_eventReset+0x92> @ imm = #-0x2
;         vintrNum = ((Udma_EventHandleInt) (eventHandle->eventPrms.controllerEventHandle))->vintrNum;
7009d092: 980e         	ldr	r0, [sp, #0x38]
7009d094: 6980         	ldr	r0, [r0, #0x18]
7009d096: 6cc0         	ldr	r0, [r0, #0x4c]
7009d098: 900c         	str	r0, [sp, #0x30]
;     }
7009d09a: e003         	b	0x7009d0a4 <Udma_eventReset+0xa4> @ imm = #0x6
;         vintrNum = eventHandle->vintrNum;
7009d09c: 980e         	ldr	r0, [sp, #0x38]
7009d09e: 6cc0         	ldr	r0, [r0, #0x4c]
7009d0a0: 900c         	str	r0, [sp, #0x30]
7009d0a2: e7ff         	b	0x7009d0a4 <Udma_eventReset+0xa4> @ imm = #-0x2
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_IA_ID_VALID;
7009d0a4: 9804         	ldr	r0, [sp, #0x10]
7009d0a6: f040 0004    	orr	r0, r0, #0x4
7009d0aa: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_VALID;
7009d0ac: 9804         	ldr	r0, [sp, #0x10]
7009d0ae: f040 0008    	orr	r0, r0, #0x8
7009d0b2: 9004         	str	r0, [sp, #0x10]
;     rmIrqReq.ia_id         = drvHandle->devIdIa;
7009d0b4: 980f         	ldr	r0, [sp, #0x3c]
7009d0b6: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009d0ba: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;     rmIrqReq.vint          = (uint16_t)vintrNum;
7009d0be: 980c         	ldr	r0, [sp, #0x30]
7009d0c0: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
7009d0c4: 980e         	ldr	r0, [sp, #0x38]
7009d0c6: 6d00         	ldr	r0, [r0, #0x50]
7009d0c8: f64f 71ff    	movw	r1, #0xffff
7009d0cc: 4288         	cmp	r0, r1
7009d0ce: d009         	beq	0x7009d0e4 <Udma_eventReset+0xe4> @ imm = #0x12
7009d0d0: e7ff         	b	0x7009d0d2 <Udma_eventReset+0xd2> @ imm = #-0x2
;         rmIrqReq.valid_params |= TISCI_MSG_VALUE_RM_VINT_STATUS_BIT_INDEX_VALID;
7009d0d2: 9804         	ldr	r0, [sp, #0x10]
7009d0d4: f040 0020    	orr	r0, r0, #0x20
7009d0d8: 9004         	str	r0, [sp, #0x10]
;         rmIrqReq.vint_status_bit_index  = (uint8_t)eventHandle->vintrBitNum;
7009d0da: 980e         	ldr	r0, [sp, #0x38]
7009d0dc: 6d00         	ldr	r0, [r0, #0x50]
7009d0de: f88d 0022    	strb.w	r0, [sp, #0x22]
;     }
7009d0e2: e7ff         	b	0x7009d0e4 <Udma_eventReset+0xe4> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009d0e4: 9809         	ldr	r0, [sp, #0x24]
7009d0e6: 6800         	ldr	r0, [r0]
7009d0e8: 2801         	cmp	r0, #0x1
7009d0ea: d00a         	beq	0x7009d102 <Udma_eventReset+0x102> @ imm = #0x14
7009d0ec: e7ff         	b	0x7009d0ee <Udma_eventReset+0xee> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType)||
7009d0ee: 9809         	ldr	r0, [sp, #0x24]
7009d0f0: 6800         	ldr	r0, [r0]
7009d0f2: 2806         	cmp	r0, #0x6
7009d0f4: d005         	beq	0x7009d102 <Udma_eventReset+0x102> @ imm = #0xa
7009d0f6: e7ff         	b	0x7009d0f8 <Udma_eventReset+0xf8> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009d0f8: 9809         	ldr	r0, [sp, #0x24]
7009d0fa: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
7009d0fc: 2802         	cmp	r0, #0x2
7009d0fe: d14d         	bne	0x7009d19c <Udma_eventReset+0x19c> @ imm = #0x9a
7009d100: e7ff         	b	0x7009d102 <Udma_eventReset+0x102> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009d102: 9809         	ldr	r0, [sp, #0x24]
7009d104: 6880         	ldr	r0, [r0, #0x8]
7009d106: 900b         	str	r0, [sp, #0x2c]
;         rmIrqReq.src_id = drvHandle->srcIdRingIrq;
7009d108: 980f         	ldr	r0, [sp, #0x3c]
7009d10a: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009d10e: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
7009d112: 9809         	ldr	r0, [sp, #0x24]
7009d114: 6800         	ldr	r0, [r0]
7009d116: 2801         	cmp	r0, #0x1
7009d118: d005         	beq	0x7009d126 <Udma_eventReset+0x126> @ imm = #0xa
7009d11a: e7ff         	b	0x7009d11c <Udma_eventReset+0x11c> @ imm = #-0x2
7009d11c: 9809         	ldr	r0, [sp, #0x24]
7009d11e: 6800         	ldr	r0, [r0]
7009d120: 2806         	cmp	r0, #0x6
7009d122: d12e         	bne	0x7009d182 <Udma_eventReset+0x182> @ imm = #0x5c
7009d124: e7ff         	b	0x7009d126 <Udma_eventReset+0x126> @ imm = #-0x2
;             rmIrqReq.src_index = chHandle->cqRing->ringNum;
7009d126: 980b         	ldr	r0, [sp, #0x2c]
7009d128: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009d12c: 8880         	ldrh	r0, [r0, #0x4]
7009d12e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009d132: 980b         	ldr	r0, [sp, #0x2c]
7009d134: 7800         	ldrb	r0, [r0]
7009d136: 0740         	lsls	r0, r0, #0x1d
7009d138: 2800         	cmp	r0, #0x0
7009d13a: d509         	bpl	0x7009d150 <Udma_eventReset+0x150> @ imm = #0x12
7009d13c: e7ff         	b	0x7009d13e <Udma_eventReset+0x13e> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->blkCopyRingIrqOffset;
7009d13e: 980f         	ldr	r0, [sp, #0x3c]
7009d140: f8d0 10f0    	ldr.w	r1, [r0, #0xf0]
7009d144: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d148: 4408         	add	r0, r1
7009d14a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d14e: e017         	b	0x7009d180 <Udma_eventReset+0x180> @ imm = #0x2e
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009d150: 980b         	ldr	r0, [sp, #0x2c]
7009d152: 7800         	ldrb	r0, [r0]
7009d154: 07c0         	lsls	r0, r0, #0x1f
7009d156: b148         	cbz	r0, 0x7009d16c <Udma_eventReset+0x16c> @ imm = #0x12
7009d158: e7ff         	b	0x7009d15a <Udma_eventReset+0x15a> @ imm = #-0x2
;                 rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009d15a: 980f         	ldr	r0, [sp, #0x3c]
7009d15c: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009d160: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d164: 4408         	add	r0, r1
7009d166: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d16a: e008         	b	0x7009d17e <Udma_eventReset+0x17e> @ imm = #0x10
;                 rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009d16c: 980f         	ldr	r0, [sp, #0x3c]
7009d16e: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009d172: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d176: 4408         	add	r0, r1
7009d178: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d17c: e7ff         	b	0x7009d17e <Udma_eventReset+0x17e> @ imm = #-0x2
7009d17e: e7ff         	b	0x7009d180 <Udma_eventReset+0x180> @ imm = #-0x2
;         }
7009d180: e00b         	b	0x7009d19a <Udma_eventReset+0x19a> @ imm = #0x16
;             rmIrqReq.src_index = chHandle->tdCqRing->ringNum;
7009d182: 980b         	ldr	r0, [sp, #0x2c]
7009d184: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009d188: 8880         	ldrh	r0, [r0, #0x4]
7009d18a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += TISCI_RINGACC0_OES_IRQ_SRC_IDX_START;
7009d18e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d192: 3014         	adds	r0, #0x14
7009d194: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d198: e7ff         	b	0x7009d19a <Udma_eventReset+0x19a> @ imm = #-0x2
;     }
7009d19a: e7ff         	b	0x7009d19c <Udma_eventReset+0x19c> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009d19c: 9809         	ldr	r0, [sp, #0x24]
7009d19e: 6800         	ldr	r0, [r0]
7009d1a0: 2803         	cmp	r0, #0x3
7009d1a2: d156         	bne	0x7009d252 <Udma_eventReset+0x252> @ imm = #0xac
7009d1a4: e7ff         	b	0x7009d1a6 <Udma_eventReset+0x1a6> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d1a6: 980f         	ldr	r0, [sp, #0x3c]
7009d1a8: 6800         	ldr	r0, [r0]
7009d1aa: 2802         	cmp	r0, #0x2
7009d1ac: d104         	bne	0x7009d1b8 <Udma_eventReset+0x1b8> @ imm = #0x8
7009d1ae: e7ff         	b	0x7009d1b0 <Udma_eventReset+0x1b0> @ imm = #-0x2
7009d1b0: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009d1b4: 900d         	str	r0, [sp, #0x34]
;         }
7009d1b6: e04b         	b	0x7009d250 <Udma_eventReset+0x250> @ imm = #0x96
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009d1b8: 9809         	ldr	r0, [sp, #0x24]
7009d1ba: 6880         	ldr	r0, [r0, #0x8]
7009d1bc: 900b         	str	r0, [sp, #0x2c]
;             rmIrqReq.src_id = drvHandle->srcIdTrIrq;
7009d1be: 980f         	ldr	r0, [sp, #0x3c]
7009d1c0: f8b0 00fc    	ldrh.w	r0, [r0, #0xfc]
7009d1c4: f8ad 0014    	strh.w	r0, [sp, #0x14]
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009d1c8: 980b         	ldr	r0, [sp, #0x2c]
7009d1ca: 7800         	ldrb	r0, [r0]
7009d1cc: 0740         	lsls	r0, r0, #0x1d
7009d1ce: 2800         	cmp	r0, #0x0
7009d1d0: d50d         	bpl	0x7009d1ee <Udma_eventReset+0x1ee> @ imm = #0x1a
7009d1d2: e7ff         	b	0x7009d1d4 <Udma_eventReset+0x1d4> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009d1d4: 980b         	ldr	r0, [sp, #0x2c]
7009d1d6: 6ec0         	ldr	r0, [r0, #0x6c]
7009d1d8: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->blkCopyTrIrqOffset;
7009d1dc: 980f         	ldr	r0, [sp, #0x3c]
7009d1de: f8d0 1100    	ldr.w	r1, [r0, #0x100]
7009d1e2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d1e6: 4408         	add	r0, r1
7009d1e8: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d1ec: e02f         	b	0x7009d24e <Udma_eventReset+0x24e> @ imm = #0x5e
;             else if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
7009d1ee: 980b         	ldr	r0, [sp, #0x2c]
7009d1f0: 7800         	ldrb	r0, [r0]
7009d1f2: 0780         	lsls	r0, r0, #0x1e
7009d1f4: 2800         	cmp	r0, #0x0
7009d1f6: d50d         	bpl	0x7009d214 <Udma_eventReset+0x214> @ imm = #0x1a
7009d1f8: e7ff         	b	0x7009d1fa <Udma_eventReset+0x1fa> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->rxChNum;
7009d1fa: 980b         	ldr	r0, [sp, #0x2c]
7009d1fc: 6f00         	ldr	r0, [r0, #0x70]
7009d1fe: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->rxTrIrqOffset;
7009d202: 980f         	ldr	r0, [sp, #0x3c]
7009d204: f8d0 1108    	ldr.w	r1, [r0, #0x108]
7009d208: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d20c: 4408         	add	r0, r1
7009d20e: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d212: e01b         	b	0x7009d24c <Udma_eventReset+0x24c> @ imm = #0x36
;             else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
7009d214: 980b         	ldr	r0, [sp, #0x2c]
7009d216: 7800         	ldrb	r0, [r0]
7009d218: 07c0         	lsls	r0, r0, #0x1f
7009d21a: b168         	cbz	r0, 0x7009d238 <Udma_eventReset+0x238> @ imm = #0x1a
7009d21c: e7ff         	b	0x7009d21e <Udma_eventReset+0x21e> @ imm = #-0x2
;                 rmIrqReq.src_index = (uint16_t)chHandle->txChNum;
7009d21e: 980b         	ldr	r0, [sp, #0x2c]
7009d220: 6ec0         	ldr	r0, [r0, #0x6c]
7009d222: f8ad 0016    	strh.w	r0, [sp, #0x16]
;                 rmIrqReq.src_index += drvHandle->txTrIrqOffset;
7009d226: 980f         	ldr	r0, [sp, #0x3c]
7009d228: f8d0 1104    	ldr.w	r1, [r0, #0x104]
7009d22c: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d230: 4408         	add	r0, r1
7009d232: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             }
7009d236: e008         	b	0x7009d24a <Udma_eventReset+0x24a> @ imm = #0x10
;                 rmIrqReq.src_id = drvHandle->devIdIa;
7009d238: 980f         	ldr	r0, [sp, #0x3c]
7009d23a: f8b0 00e6    	ldrh.w	r0, [r0, #0xe6]
7009d23e: f8ad 0014    	strh.w	r0, [sp, #0x14]
7009d242: 2000         	movs	r0, #0x0
;                 rmIrqReq.src_index = 0U;                /* Not used by DMSC RM */
7009d244: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d248: e7ff         	b	0x7009d24a <Udma_eventReset+0x24a> @ imm = #-0x2
7009d24a: e7ff         	b	0x7009d24c <Udma_eventReset+0x24c> @ imm = #-0x2
7009d24c: e7ff         	b	0x7009d24e <Udma_eventReset+0x24e> @ imm = #-0x2
7009d24e: e7ff         	b	0x7009d250 <Udma_eventReset+0x250> @ imm = #-0x2
;     }
7009d250: e7ff         	b	0x7009d252 <Udma_eventReset+0x252> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
7009d252: 9809         	ldr	r0, [sp, #0x24]
7009d254: 6800         	ldr	r0, [r0]
7009d256: 2804         	cmp	r0, #0x4
7009d258: d130         	bne	0x7009d2bc <Udma_eventReset+0x2bc> @ imm = #0x60
7009d25a: e7ff         	b	0x7009d25c <Udma_eventReset+0x25c> @ imm = #-0x2
;         ringHandle = (Udma_RingHandleInt) eventPrms->ringHandle;
7009d25c: 9809         	ldr	r0, [sp, #0x24]
7009d25e: 68c0         	ldr	r0, [r0, #0xc]
7009d260: 900a         	str	r0, [sp, #0x28]
;         rmIrqReq.src_id     = drvHandle->srcIdRingIrq;
7009d262: 980f         	ldr	r0, [sp, #0x3c]
7009d264: f8b0 00ec    	ldrh.w	r0, [r0, #0xec]
7009d268: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmIrqReq.src_index  = ringHandle->ringNum;
7009d26c: 980a         	ldr	r0, [sp, #0x28]
7009d26e: 8880         	ldrh	r0, [r0, #0x4]
7009d270: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmIrqReq.src_index += drvHandle->txRingIrqOffset;
7009d274: 980f         	ldr	r0, [sp, #0x3c]
7009d276: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009d27a: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d27e: 4408         	add	r0, r1
7009d280: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009d284: 980a         	ldr	r0, [sp, #0x28]
7009d286: 6dc0         	ldr	r0, [r0, #0x5c]
7009d288: 2804         	cmp	r0, #0x4
7009d28a: d316         	blo	0x7009d2ba <Udma_eventReset+0x2ba> @ imm = #0x2c
7009d28c: e7ff         	b	0x7009d28e <Udma_eventReset+0x28e> @ imm = #-0x2
;            (ringHandle->mappedRingGrp < (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
7009d28e: 980a         	ldr	r0, [sp, #0x28]
7009d290: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((ringHandle->mappedRingGrp >= UDMA_NUM_MAPPED_TX_GROUP) &&
7009d292: 2807         	cmp	r0, #0x7
7009d294: d811         	bhi	0x7009d2ba <Udma_eventReset+0x2ba> @ imm = #0x22
7009d296: e7ff         	b	0x7009d298 <Udma_eventReset+0x298> @ imm = #-0x2
;             rmIrqReq.src_index -= drvHandle->txRingIrqOffset;
7009d298: 980f         	ldr	r0, [sp, #0x3c]
7009d29a: f8d0 10f4    	ldr.w	r1, [r0, #0xf4]
7009d29e: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d2a2: 1a40         	subs	r0, r0, r1
7009d2a4: f8ad 0016    	strh.w	r0, [sp, #0x16]
;             rmIrqReq.src_index += drvHandle->rxRingIrqOffset;
7009d2a8: 980f         	ldr	r0, [sp, #0x3c]
7009d2aa: f8d0 10f8    	ldr.w	r1, [r0, #0xf8]
7009d2ae: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
7009d2b2: 4408         	add	r0, r1
7009d2b4: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         }
7009d2b8: e7ff         	b	0x7009d2ba <Udma_eventReset+0x2ba> @ imm = #-0x2
;     }
7009d2ba: e7ff         	b	0x7009d2bc <Udma_eventReset+0x2bc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009d2bc: 980d         	ldr	r0, [sp, #0x34]
7009d2be: b9b0         	cbnz	r0, 0x7009d2ee <Udma_eventReset+0x2ee> @ imm = #0x2c
7009d2c0: e7ff         	b	0x7009d2c2 <Udma_eventReset+0x2c2> @ imm = #-0x2
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009d2c2: 980f         	ldr	r0, [sp, #0x3c]
7009d2c4: 6800         	ldr	r0, [r0]
7009d2c6: b130         	cbz	r0, 0x7009d2d6 <Udma_eventReset+0x2d6> @ imm = #0xc
7009d2c8: e7ff         	b	0x7009d2ca <Udma_eventReset+0x2ca> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009d2ca: 9809         	ldr	r0, [sp, #0x24]
7009d2cc: 6800         	ldr	r0, [r0]
;         if((drvHandle->instType    != UDMA_INST_TYPE_NORMAL) &&
7009d2ce: 2805         	cmp	r0, #0x5
7009d2d0: d101         	bne	0x7009d2d6 <Udma_eventReset+0x2d6> @ imm = #0x2
7009d2d2: e7ff         	b	0x7009d2d4 <Udma_eventReset+0x2d4> @ imm = #-0x2
;         }
7009d2d4: e00a         	b	0x7009d2ec <Udma_eventReset+0x2ec> @ imm = #0x14
7009d2d6: a802         	add	r0, sp, #0x8
7009d2d8: f04f 31ff    	mov.w	r1, #0xffffffff
;             retVal = Sciclient_rmIrqRelease(&rmIrqReq, UDMA_SCICLIENT_TIMEOUT);
7009d2dc: f012 fac8    	bl	0x700af870 <Sciclient_rmIrqRelease> @ imm = #0x12590
7009d2e0: 900d         	str	r0, [sp, #0x34]
;             if(CSL_PASS != retVal)
7009d2e2: 980d         	ldr	r0, [sp, #0x34]
7009d2e4: b108         	cbz	r0, 0x7009d2ea <Udma_eventReset+0x2ea> @ imm = #0x2
7009d2e6: e7ff         	b	0x7009d2e8 <Udma_eventReset+0x2e8> @ imm = #-0x2
;             }
7009d2e8: e7ff         	b	0x7009d2ea <Udma_eventReset+0x2ea> @ imm = #-0x2
7009d2ea: e7ff         	b	0x7009d2ec <Udma_eventReset+0x2ec> @ imm = #-0x2
;     }
7009d2ec: e7ff         	b	0x7009d2ee <Udma_eventReset+0x2ee> @ imm = #-0x2
;     return (retVal);
7009d2ee: 980d         	ldr	r0, [sp, #0x34]
7009d2f0: b010         	add	sp, #0x40
7009d2f2: bd80         	pop	{r7, pc}

7009d2f4 <malloc>:
7009d2f4: e1a01000     	mov	r1, r0
7009d2f8: e3a00008     	mov	r0, #8
7009d2fc: ea000ab0     	b	0x7009fdc4 <memalign>   @ imm = #0x2ac0

7009d300 <tm_receiver_thread_entry>:
; {
7009d300: e92d 43f0    	push.w	{r4, r5, r6, r7, r8, r9, lr}
7009d304: b081         	sub	sp, #0x4
7009d306: f644 1878    	movw	r8, #0x4978
7009d30a: f245 0540    	movw	r5, #0x5040
7009d30e: f2c7 0808    	movt	r8, #0x7008
7009d312: f642 2708    	movw	r7, #0x2a08
7009d316: f641 19ae    	movw	r9, #0x19ae
7009d31a: f2c7 0508    	movt	r5, #0x7008
7009d31e: f2c7 070b    	movt	r7, #0x700b
7009d322: f2c7 090b    	movt	r9, #0x700b
7009d326: 2400         	movs	r4, #0x0
7009d328: 4646         	mov	r6, r8
7009d32a: e006         	b	0x7009d33a <tm_receiver_thread_entry+0x3a> @ imm = #0xc
7009d32c: bf00         	nop
7009d32e: bf00         	nop
;    for (i = 0; i < ITERATION_COUNT; i++)
7009d330: 3402         	adds	r4, #0x2
7009d332: 3620         	adds	r6, #0x20
7009d334: 2c20         	cmp	r4, #0x20
7009d336: f000 80a3    	beq.w	0x7009d480 <tm_receiver_thread_entry+0x180> @ imm = #0x146
;       tm_interrupt_raise();
7009d33a: f012 fcf1    	bl	0x700afd20 <tm_interrupt_raise> @ imm = #0x129e2
;       tm_queue_receive(0, message_received_arr);
7009d33e: 4629         	mov	r1, r5
7009d340: 2000         	movs	r0, #0x0
7009d342: f012 f8dd    	bl	0x700af500 <tm_queue_receive> @ imm = #0x121ba
;       tm_pmu_profile_end(pmu_send_names[i]);
7009d346: 4630         	mov	r0, r6
7009d348: f012 fd22    	bl	0x700afd90 <tm_pmu_profile_end> @ imm = #0x12a44
;       tm_isr_to_task_counter++;
7009d34c: 6838         	ldr	r0, [r7]
7009d34e: 3001         	adds	r0, #0x1
7009d350: 6038         	str	r0, [r7]
;       checksum += msg[i];
7009d352: e895 0007    	ldm.w	r5, {r0, r1, r2}
7009d356: 4408         	add	r0, r1
7009d358: 68e9         	ldr	r1, [r5, #0xc]
7009d35a: 4410         	add	r0, r2
7009d35c: 692a         	ldr	r2, [r5, #0x10]
7009d35e: 4408         	add	r0, r1
7009d360: 6969         	ldr	r1, [r5, #0x14]
7009d362: 4410         	add	r0, r2
7009d364: 69aa         	ldr	r2, [r5, #0x18]
7009d366: 4408         	add	r0, r1
7009d368: 69e9         	ldr	r1, [r5, #0x1c]
7009d36a: 4410         	add	r0, r2
7009d36c: 6a2a         	ldr	r2, [r5, #0x20]
7009d36e: 4408         	add	r0, r1
7009d370: 6a69         	ldr	r1, [r5, #0x24]
7009d372: 4410         	add	r0, r2
7009d374: 6aaa         	ldr	r2, [r5, #0x28]
7009d376: 4408         	add	r0, r1
7009d378: 6ae9         	ldr	r1, [r5, #0x2c]
7009d37a: 4410         	add	r0, r2
7009d37c: 6b2a         	ldr	r2, [r5, #0x30]
7009d37e: 4408         	add	r0, r1
7009d380: 6b69         	ldr	r1, [r5, #0x34]
7009d382: 4410         	add	r0, r2
7009d384: 6baa         	ldr	r2, [r5, #0x38]
7009d386: 4408         	add	r0, r1
7009d388: 6be9         	ldr	r1, [r5, #0x3c]
7009d38a: 4410         	add	r0, r2
7009d38c: 6c2a         	ldr	r2, [r5, #0x40]
7009d38e: 4408         	add	r0, r1
7009d390: 6c69         	ldr	r1, [r5, #0x44]
7009d392: 4410         	add	r0, r2
7009d394: 6caa         	ldr	r2, [r5, #0x48]
7009d396: 4408         	add	r0, r1
7009d398: 6ce9         	ldr	r1, [r5, #0x4c]
7009d39a: 4410         	add	r0, r2
7009d39c: 6d2a         	ldr	r2, [r5, #0x50]
7009d39e: 4408         	add	r0, r1
7009d3a0: 6d69         	ldr	r1, [r5, #0x54]
7009d3a2: 4410         	add	r0, r2
7009d3a4: 6daa         	ldr	r2, [r5, #0x58]
7009d3a6: 4408         	add	r0, r1
7009d3a8: 6de9         	ldr	r1, [r5, #0x5c]
7009d3aa: 4410         	add	r0, r2
7009d3ac: 6e2a         	ldr	r2, [r5, #0x60]
7009d3ae: 4408         	add	r0, r1
7009d3b0: 6e69         	ldr	r1, [r5, #0x64]
7009d3b2: 4410         	add	r0, r2
7009d3b4: 6eaa         	ldr	r2, [r5, #0x68]
7009d3b6: 4408         	add	r0, r1
7009d3b8: 6ee9         	ldr	r1, [r5, #0x6c]
7009d3ba: 4410         	add	r0, r2
7009d3bc: 6f2a         	ldr	r2, [r5, #0x70]
7009d3be: 4408         	add	r0, r1
7009d3c0: 6f69         	ldr	r1, [r5, #0x74]
7009d3c2: 4410         	add	r0, r2
7009d3c4: 6faa         	ldr	r2, [r5, #0x78]
7009d3c6: 4408         	add	r0, r1
;       if (compute_checksum(message_received_arr, MESSAGE_SIZE - 1) != message_received_arr[MESSAGE_SIZE - 1])
7009d3c8: 6fe9         	ldr	r1, [r5, #0x7c]
;       checksum += msg[i];
7009d3ca: 4410         	add	r0, r2
;       if (compute_checksum(message_received_arr, MESSAGE_SIZE - 1) != message_received_arr[MESSAGE_SIZE - 1])
7009d3cc: 4288         	cmp	r0, r1
7009d3ce: d004         	beq	0x7009d3da <tm_receiver_thread_entry+0xda> @ imm = #0x8
;          printf("Message integrity error in iteration %d: checksum mismatch\r\n", i);
7009d3d0: 4649         	mov	r1, r9
7009d3d2: 4622         	mov	r2, r4
7009d3d4: 2001         	movs	r0, #0x1
7009d3d6: f00c fc9b    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc936
;       tm_interrupt_raise();
7009d3da: f012 fca1    	bl	0x700afd20 <tm_interrupt_raise> @ imm = #0x12942
;       tm_queue_receive(0, message_received_arr);
7009d3de: 4629         	mov	r1, r5
7009d3e0: 2000         	movs	r0, #0x0
7009d3e2: f012 f88d    	bl	0x700af500 <tm_queue_receive> @ imm = #0x1211a
;       tm_pmu_profile_end(pmu_send_names[i]);
7009d3e6: f106 0010    	add.w	r0, r6, #0x10
7009d3ea: f012 fcd1    	bl	0x700afd90 <tm_pmu_profile_end> @ imm = #0x129a2
;       tm_isr_to_task_counter++;
7009d3ee: 6838         	ldr	r0, [r7]
7009d3f0: 3001         	adds	r0, #0x1
7009d3f2: 6038         	str	r0, [r7]
;       checksum += msg[i];
7009d3f4: e895 0007    	ldm.w	r5, {r0, r1, r2}
7009d3f8: 4408         	add	r0, r1
7009d3fa: 68e9         	ldr	r1, [r5, #0xc]
7009d3fc: 4410         	add	r0, r2
7009d3fe: 692a         	ldr	r2, [r5, #0x10]
7009d400: 4408         	add	r0, r1
7009d402: 6969         	ldr	r1, [r5, #0x14]
7009d404: 4410         	add	r0, r2
7009d406: 69aa         	ldr	r2, [r5, #0x18]
7009d408: 4408         	add	r0, r1
7009d40a: 69e9         	ldr	r1, [r5, #0x1c]
7009d40c: 4410         	add	r0, r2
7009d40e: 6a2a         	ldr	r2, [r5, #0x20]
7009d410: 4408         	add	r0, r1
7009d412: 6a69         	ldr	r1, [r5, #0x24]
7009d414: 4410         	add	r0, r2
7009d416: 6aaa         	ldr	r2, [r5, #0x28]
7009d418: 4408         	add	r0, r1
7009d41a: 6ae9         	ldr	r1, [r5, #0x2c]
7009d41c: 4410         	add	r0, r2
7009d41e: 6b2a         	ldr	r2, [r5, #0x30]
7009d420: 4408         	add	r0, r1
7009d422: 6b69         	ldr	r1, [r5, #0x34]
7009d424: 4410         	add	r0, r2
7009d426: 6baa         	ldr	r2, [r5, #0x38]
7009d428: 4408         	add	r0, r1
7009d42a: 6be9         	ldr	r1, [r5, #0x3c]
7009d42c: 4410         	add	r0, r2
7009d42e: 6c2a         	ldr	r2, [r5, #0x40]
7009d430: 4408         	add	r0, r1
7009d432: 6c69         	ldr	r1, [r5, #0x44]
7009d434: 4410         	add	r0, r2
7009d436: 6caa         	ldr	r2, [r5, #0x48]
7009d438: 4408         	add	r0, r1
7009d43a: 6ce9         	ldr	r1, [r5, #0x4c]
7009d43c: 4410         	add	r0, r2
7009d43e: 6d2a         	ldr	r2, [r5, #0x50]
7009d440: 4408         	add	r0, r1
7009d442: 6d69         	ldr	r1, [r5, #0x54]
7009d444: 4410         	add	r0, r2
7009d446: 6daa         	ldr	r2, [r5, #0x58]
7009d448: 4408         	add	r0, r1
7009d44a: 6de9         	ldr	r1, [r5, #0x5c]
7009d44c: 4410         	add	r0, r2
7009d44e: 6e2a         	ldr	r2, [r5, #0x60]
7009d450: 4408         	add	r0, r1
7009d452: 6e69         	ldr	r1, [r5, #0x64]
7009d454: 4410         	add	r0, r2
7009d456: 6eaa         	ldr	r2, [r5, #0x68]
7009d458: 4408         	add	r0, r1
7009d45a: 6ee9         	ldr	r1, [r5, #0x6c]
7009d45c: 4410         	add	r0, r2
7009d45e: 6f2a         	ldr	r2, [r5, #0x70]
7009d460: 4408         	add	r0, r1
7009d462: 6f69         	ldr	r1, [r5, #0x74]
7009d464: 4410         	add	r0, r2
7009d466: 6faa         	ldr	r2, [r5, #0x78]
7009d468: 4408         	add	r0, r1
;       if (compute_checksum(message_received_arr, MESSAGE_SIZE - 1) != message_received_arr[MESSAGE_SIZE - 1])
7009d46a: 6fe9         	ldr	r1, [r5, #0x7c]
;       checksum += msg[i];
7009d46c: 4410         	add	r0, r2
;       if (compute_checksum(message_received_arr, MESSAGE_SIZE - 1) != message_received_arr[MESSAGE_SIZE - 1])
7009d46e: 4288         	cmp	r0, r1
7009d470: f43f af5e    	beq.w	0x7009d330 <tm_receiver_thread_entry+0x30> @ imm = #-0x144
7009d474: 1c62         	adds	r2, r4, #0x1
;          printf("Message integrity error in iteration %d: checksum mismatch\r\n", i);
7009d476: 4649         	mov	r1, r9
7009d478: 2001         	movs	r0, #0x1
7009d47a: f00c fc49    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc892
7009d47e: e757         	b	0x7009d330 <tm_receiver_thread_entry+0x30> @ imm = #-0x152
;    printf("==== ISR-to-Task Benchmark Complete ====\r\n");
7009d480: f641 21f0    	movw	r1, #0x1af0
7009d484: 2001         	movs	r0, #0x1
7009d486: f2c7 010b    	movt	r1, #0x700b
7009d48a: f00c fc41    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc882
;    printf("Total messages processed: %lu\r\n", tm_isr_to_task_counter);
7009d48e: f641 41c7    	movw	r1, #0x1cc7
7009d492: 683a         	ldr	r2, [r7]
7009d494: f2c7 010b    	movt	r1, #0x700b
7009d498: 2001         	movs	r0, #0x1
7009d49a: f00c fc39    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc872
;    printf("Total interrupts processed: %lu\r\n", tm_isr_counter);
7009d49e: f642 2004    	movw	r0, #0x2a04
7009d4a2: f641 411f    	movw	r1, #0x1c1f
7009d4a6: f2c7 000b    	movt	r0, #0x700b
7009d4aa: f2c7 010b    	movt	r1, #0x700b
7009d4ae: 6802         	ldr	r2, [r0]
7009d4b0: 2001         	movs	r0, #0x1
7009d4b2: f00c fc2d    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc85a
7009d4b6: f242 04c4    	movw	r4, #0x20c4
7009d4ba: 2600         	movs	r6, #0x0
7009d4bc: f2c7 040b    	movt	r4, #0x700b
;       printf("Send Latency: ");
7009d4c0: 4621         	mov	r1, r4
7009d4c2: f04f 0001    	mov.w	r0, #0x1
7009d4c6: f00c fc23    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc846
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d4ca: eb08 0506    	add.w	r5, r8, r6
7009d4ce: 4628         	mov	r0, r5
7009d4d0: f012 fc66    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x128cc
;       printf("Send Latency: ");
7009d4d4: 4621         	mov	r1, r4
7009d4d6: 2001         	movs	r0, #0x1
7009d4d8: f00c fc1a    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc834
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d4dc: f105 0010    	add.w	r0, r5, #0x10
7009d4e0: f012 fc5e    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x128bc
;       printf("Send Latency: ");
7009d4e4: 4621         	mov	r1, r4
7009d4e6: 2001         	movs	r0, #0x1
7009d4e8: f00c fc12    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc824
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d4ec: f105 0020    	add.w	r0, r5, #0x20
7009d4f0: f012 fc56    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x128ac
;       printf("Send Latency: ");
7009d4f4: 4621         	mov	r1, r4
7009d4f6: 2001         	movs	r0, #0x1
7009d4f8: f00c fc0a    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc814
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d4fc: f105 0030    	add.w	r0, r5, #0x30
7009d500: f012 fc4e    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x1289c
;       printf("Send Latency: ");
7009d504: 4621         	mov	r1, r4
7009d506: 2001         	movs	r0, #0x1
7009d508: f00c fc02    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc804
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d50c: f105 0040    	add.w	r0, r5, #0x40
7009d510: f012 fc46    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x1288c
;       printf("Send Latency: ");
7009d514: 4621         	mov	r1, r4
7009d516: 2001         	movs	r0, #0x1
7009d518: f00c fbfa    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc7f4
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d51c: f105 0050    	add.w	r0, r5, #0x50
7009d520: f012 fc3e    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x1287c
;       printf("Send Latency: ");
7009d524: 4621         	mov	r1, r4
7009d526: 2001         	movs	r0, #0x1
7009d528: f00c fbf2    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc7e4
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d52c: f105 0060    	add.w	r0, r5, #0x60
7009d530: f012 fc36    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x1286c
;       printf("Send Latency: ");
7009d534: 4621         	mov	r1, r4
7009d536: 2001         	movs	r0, #0x1
7009d538: f00c fbea    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc7d4
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d53c: f105 0070    	add.w	r0, r5, #0x70
7009d540: f012 fc2e    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x1285c
;       printf("Send Latency: ");
7009d544: 4621         	mov	r1, r4
7009d546: 2001         	movs	r0, #0x1
7009d548: f00c fbe2    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc7c4
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d54c: f105 0080    	add.w	r0, r5, #0x80
7009d550: f012 fc26    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x1284c
;       printf("Send Latency: ");
7009d554: 4621         	mov	r1, r4
7009d556: 2001         	movs	r0, #0x1
7009d558: f00c fbda    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc7b4
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d55c: f105 0090    	add.w	r0, r5, #0x90
7009d560: f012 fc1e    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x1283c
;       printf("Send Latency: ");
7009d564: 4621         	mov	r1, r4
7009d566: 2001         	movs	r0, #0x1
7009d568: f00c fbd2    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc7a4
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d56c: f105 00a0    	add.w	r0, r5, #0xa0
7009d570: f012 fc16    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x1282c
;       printf("Send Latency: ");
7009d574: 4621         	mov	r1, r4
7009d576: 2001         	movs	r0, #0x1
7009d578: f00c fbca    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc794
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d57c: f105 00b0    	add.w	r0, r5, #0xb0
7009d580: f012 fc0e    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x1281c
;       printf("Send Latency: ");
7009d584: 4621         	mov	r1, r4
7009d586: 2001         	movs	r0, #0x1
7009d588: f00c fbc2    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc784
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d58c: f105 00c0    	add.w	r0, r5, #0xc0
7009d590: f012 fc06    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x1280c
;       printf("Send Latency: ");
7009d594: 4621         	mov	r1, r4
7009d596: 2001         	movs	r0, #0x1
7009d598: f00c fbba    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc774
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d59c: f105 00d0    	add.w	r0, r5, #0xd0
7009d5a0: f012 fbfe    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x127fc
;       printf("Send Latency: ");
7009d5a4: 4621         	mov	r1, r4
7009d5a6: 2001         	movs	r0, #0x1
7009d5a8: f00c fbb2    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc764
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d5ac: f105 00e0    	add.w	r0, r5, #0xe0
7009d5b0: f012 fbf6    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x127ec
;       printf("Send Latency: ");
7009d5b4: 4621         	mov	r1, r4
7009d5b6: 2001         	movs	r0, #0x1
7009d5b8: f00c fbaa    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xc754
;       tm_pmu_profile_print(pmu_send_names[i]);
7009d5bc: f105 00f0    	add.w	r0, r5, #0xf0
7009d5c0: f012 fbee    	bl	0x700afda0 <tm_pmu_profile_print> @ imm = #0x127dc
;    for (i = 0; i < ITERATION_COUNT; i++)
7009d5c4: f506 7680    	add.w	r6, r6, #0x100
7009d5c8: f5b6 7f00    	cmp.w	r6, #0x200
7009d5cc: f47f af78    	bne.w	0x7009d4c0 <tm_receiver_thread_entry+0x1c0> @ imm = #-0x110
;    tm_thread_suspend(0);
7009d5d0: 2000         	movs	r0, #0x0
7009d5d2: b001         	add	sp, #0x4
7009d5d4: e8bd 43f0    	pop.w	{r4, r5, r6, r7, r8, r9, lr}
7009d5d8: f012 b9aa    	b.w	0x700af930 <tm_thread_suspend> @ imm = #0x12354
7009d5dc: 0000         	movs	r0, r0
7009d5de: 0000         	movs	r0, r0

7009d5e0 <Sciclient_service>:
; {
7009d5e0: b580         	push	{r7, lr}
7009d5e2: b094         	sub	sp, #0x50
7009d5e4: 9013         	str	r0, [sp, #0x4c]
7009d5e6: 9112         	str	r1, [sp, #0x48]
7009d5e8: 2000         	movs	r0, #0x0
;     int32_t   status        = SystemP_SUCCESS;
7009d5ea: 9011         	str	r0, [sp, #0x44]
7009d5ec: 210f         	movs	r1, #0xf
;     uint32_t  contextId     = SCICLIENT_CONTEXT_MAX_NUM;
7009d5ee: 9110         	str	r1, [sp, #0x40]
;     uint32_t  initialCount  = 0U;
7009d5f0: 900f         	str	r0, [sp, #0x3c]
;     uint8_t   localSeqId    = gSciclientHandle.currSeqId;
7009d5f2: f642 1148    	movw	r1, #0x2948
7009d5f6: f2c7 010b    	movt	r1, #0x700b
7009d5fa: 6809         	ldr	r1, [r1]
7009d5fc: f88d 103b    	strb.w	r1, [sp, #0x3b]
;     uint32_t  txPayloadSize = 0U;
7009d600: 900d         	str	r0, [sp, #0x34]
;     uint32_t  rxPayloadSize = 0U;
7009d602: 900c         	str	r0, [sp, #0x30]
;     uint8_t  *pLocalRespPayload = NULL;
7009d604: 900b         	str	r0, [sp, #0x2c]
;     uint8_t  *pSecHeader = NULL;
7009d606: 9007         	str	r0, [sp, #0x1c]
;     if((pReqPrm == NULL) || (pRespPrm == NULL) || (pReqPrm->pReqPayload == NULL))
7009d608: 9813         	ldr	r0, [sp, #0x4c]
7009d60a: b138         	cbz	r0, 0x7009d61c <Sciclient_service+0x3c> @ imm = #0xe
7009d60c: e7ff         	b	0x7009d60e <Sciclient_service+0x2e> @ imm = #-0x2
7009d60e: 9812         	ldr	r0, [sp, #0x48]
7009d610: b120         	cbz	r0, 0x7009d61c <Sciclient_service+0x3c> @ imm = #0x8
7009d612: e7ff         	b	0x7009d614 <Sciclient_service+0x34> @ imm = #-0x2
7009d614: 9813         	ldr	r0, [sp, #0x4c]
7009d616: 6880         	ldr	r0, [r0, #0x8]
7009d618: b920         	cbnz	r0, 0x7009d624 <Sciclient_service+0x44> @ imm = #0x8
7009d61a: e7ff         	b	0x7009d61c <Sciclient_service+0x3c> @ imm = #-0x2
7009d61c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
7009d620: 9011         	str	r0, [sp, #0x44]
;     }
7009d622: e09e         	b	0x7009d762 <Sciclient_service+0x182> @ imm = #0x13c
;         contextId = Sciclient_getCurrentContext(pReqPrm->messageType);
7009d624: 9813         	ldr	r0, [sp, #0x4c]
7009d626: 8800         	ldrh	r0, [r0]
7009d628: f00a faca    	bl	0x700a7bc0 <Sciclient_getCurrentContext> @ imm = #0xa594
7009d62c: 9010         	str	r0, [sp, #0x40]
;         if(contextId < SCICLIENT_CONTEXT_MAX_NUM)
7009d62e: 9810         	ldr	r0, [sp, #0x40]
7009d630: 280e         	cmp	r0, #0xe
7009d632: f200 8091    	bhi.w	0x7009d758 <Sciclient_service+0x178> @ imm = #0x122
7009d636: e7ff         	b	0x7009d638 <Sciclient_service+0x58> @ imm = #-0x2
;             txThread = Sciclient_getTxThreadId(contextId);
7009d638: 9810         	ldr	r0, [sp, #0x40]
7009d63a: f011 fea1    	bl	0x700af380 <Sciclient_getTxThreadId> @ imm = #0x11d42
7009d63e: 900a         	str	r0, [sp, #0x28]
;             rxThread = Sciclient_getRxThreadId(contextId);
7009d640: 9810         	ldr	r0, [sp, #0x40]
7009d642: f011 fe8d    	bl	0x700af360 <Sciclient_getRxThreadId> @ imm = #0x11d1a
7009d646: 9009         	str	r0, [sp, #0x24]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009d648: 9810         	ldr	r0, [sp, #0x40]
7009d64a: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d64e: f241 3060    	movw	r0, #0x1360
7009d652: f2c7 000b    	movt	r0, #0x700b
7009d656: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009d65a: b938         	cbnz	r0, 0x7009d66c <Sciclient_service+0x8c> @ imm = #0xe
7009d65c: e7ff         	b	0x7009d65e <Sciclient_service+0x7e> @ imm = #-0x2
;                 gSecHeaderSizeWords = sizeof(struct tisci_sec_header)/sizeof(uint32_t);
7009d65e: f642 2154    	movw	r1, #0x2a54
7009d662: f2c7 010b    	movt	r1, #0x700b
7009d666: 2001         	movs	r0, #0x1
7009d668: 7008         	strb	r0, [r1]
;             }
7009d66a: e006         	b	0x7009d67a <Sciclient_service+0x9a> @ imm = #0xc
;                 gSecHeaderSizeWords = 0;
7009d66c: f642 2154    	movw	r1, #0x2a54
7009d670: f2c7 010b    	movt	r1, #0x700b
7009d674: 2000         	movs	r0, #0x0
7009d676: 7008         	strb	r0, [r1]
7009d678: e7ff         	b	0x7009d67a <Sciclient_service+0x9a> @ imm = #-0x2
;             gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
7009d67a: f642 00c0    	movw	r0, #0x28c0
7009d67e: f2c7 000b    	movt	r0, #0x700b
7009d682: f011 f92d    	bl	0x700ae8e0 <CSL_secProxyGetMaxMsgSize> @ imm = #0x1125a
7009d686: 3804         	subs	r0, #0x4
7009d688: f642 1148    	movw	r1, #0x2948
7009d68c: f2c7 010b    	movt	r1, #0x700b
7009d690: 6148         	str	r0, [r1, #0x14]
;             if(gSciclientMap[contextId].context == SCICLIENT_SECURE_CONTEXT)
7009d692: 9810         	ldr	r0, [sp, #0x40]
7009d694: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d698: f241 3060    	movw	r0, #0x1360
7009d69c: f2c7 000b    	movt	r0, #0x700b
7009d6a0: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
7009d6a4: b940         	cbnz	r0, 0x7009d6b8 <Sciclient_service+0xd8> @ imm = #0x10
7009d6a6: e7ff         	b	0x7009d6a8 <Sciclient_service+0xc8> @ imm = #-0x2
7009d6a8: 2000         	movs	r0, #0x0
;                 secHeader.integ_check = (uint16_t)0;
7009d6aa: f8ad 0014    	strh.w	r0, [sp, #0x14]
;                 secHeader.rsvd = (uint16_t)0;
7009d6ae: f8ad 0016    	strh.w	r0, [sp, #0x16]
7009d6b2: a805         	add	r0, sp, #0x14
;                 pSecHeader = (uint8_t * )(&secHeader);
7009d6b4: 9007         	str	r0, [sp, #0x1c]
;             }
7009d6b6: e7ff         	b	0x7009d6b8 <Sciclient_service+0xd8> @ imm = #-0x2
;             if (pReqPrm->reqPayloadSize > 0U)
7009d6b8: 9813         	ldr	r0, [sp, #0x4c]
7009d6ba: 68c0         	ldr	r0, [r0, #0xc]
7009d6bc: b128         	cbz	r0, 0x7009d6ca <Sciclient_service+0xea> @ imm = #0xa
7009d6be: e7ff         	b	0x7009d6c0 <Sciclient_service+0xe0> @ imm = #-0x2
;                 txPayloadSize = pReqPrm->reqPayloadSize - sizeof(struct tisci_header);
7009d6c0: 9813         	ldr	r0, [sp, #0x4c]
7009d6c2: 68c0         	ldr	r0, [r0, #0xc]
7009d6c4: 3808         	subs	r0, #0x8
7009d6c6: 900d         	str	r0, [sp, #0x34]
;             }
7009d6c8: e002         	b	0x7009d6d0 <Sciclient_service+0xf0> @ imm = #0x4
7009d6ca: 2000         	movs	r0, #0x0
;                 txPayloadSize = 0U;
7009d6cc: 900d         	str	r0, [sp, #0x34]
7009d6ce: e7ff         	b	0x7009d6d0 <Sciclient_service+0xf0> @ imm = #-0x2
;             if (txPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009d6d0: 980d         	ldr	r0, [sp, #0x34]
7009d6d2: f642 1148    	movw	r1, #0x2948
7009d6d6: f2c7 010b    	movt	r1, #0x700b
7009d6da: 6949         	ldr	r1, [r1, #0x14]
7009d6dc: 3908         	subs	r1, #0x8
7009d6de: 4288         	cmp	r0, r1
7009d6e0: d904         	bls	0x7009d6ec <Sciclient_service+0x10c> @ imm = #0x8
7009d6e2: e7ff         	b	0x7009d6e4 <Sciclient_service+0x104> @ imm = #-0x2
7009d6e4: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d6e8: 9011         	str	r0, [sp, #0x44]
;             }
7009d6ea: e7ff         	b	0x7009d6ec <Sciclient_service+0x10c> @ imm = #-0x2
;             if ((txPayloadSize > 0U) && (pReqPrm->pReqPayload == NULL))
7009d6ec: 980d         	ldr	r0, [sp, #0x34]
7009d6ee: b140         	cbz	r0, 0x7009d702 <Sciclient_service+0x122> @ imm = #0x10
7009d6f0: e7ff         	b	0x7009d6f2 <Sciclient_service+0x112> @ imm = #-0x2
7009d6f2: 9813         	ldr	r0, [sp, #0x4c]
7009d6f4: 6880         	ldr	r0, [r0, #0x8]
7009d6f6: b920         	cbnz	r0, 0x7009d702 <Sciclient_service+0x122> @ imm = #0x8
7009d6f8: e7ff         	b	0x7009d6fa <Sciclient_service+0x11a> @ imm = #-0x2
7009d6fa: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d6fe: 9011         	str	r0, [sp, #0x44]
;             }
7009d700: e7ff         	b	0x7009d702 <Sciclient_service+0x122> @ imm = #-0x2
;             if (pRespPrm->respPayloadSize > 0U)
7009d702: 9812         	ldr	r0, [sp, #0x48]
7009d704: 6880         	ldr	r0, [r0, #0x8]
7009d706: b128         	cbz	r0, 0x7009d714 <Sciclient_service+0x134> @ imm = #0xa
7009d708: e7ff         	b	0x7009d70a <Sciclient_service+0x12a> @ imm = #-0x2
;                 rxPayloadSize = pRespPrm->respPayloadSize - sizeof(struct tisci_header);
7009d70a: 9812         	ldr	r0, [sp, #0x48]
7009d70c: 6880         	ldr	r0, [r0, #0x8]
7009d70e: 3808         	subs	r0, #0x8
7009d710: 900c         	str	r0, [sp, #0x30]
;             }
7009d712: e002         	b	0x7009d71a <Sciclient_service+0x13a> @ imm = #0x4
7009d714: 2000         	movs	r0, #0x0
;                 rxPayloadSize = 0U;
7009d716: 900c         	str	r0, [sp, #0x30]
7009d718: e7ff         	b	0x7009d71a <Sciclient_service+0x13a> @ imm = #-0x2
;             if (rxPayloadSize > (gSciclientHandle.maxMsgSizeBytes - sizeof(struct tisci_header)))
7009d71a: 980c         	ldr	r0, [sp, #0x30]
7009d71c: f642 1148    	movw	r1, #0x2948
7009d720: f2c7 010b    	movt	r1, #0x700b
7009d724: 6949         	ldr	r1, [r1, #0x14]
7009d726: 3908         	subs	r1, #0x8
7009d728: 4288         	cmp	r0, r1
7009d72a: d904         	bls	0x7009d736 <Sciclient_service+0x156> @ imm = #0x8
7009d72c: e7ff         	b	0x7009d72e <Sciclient_service+0x14e> @ imm = #-0x2
7009d72e: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d732: 9011         	str	r0, [sp, #0x44]
;             }
7009d734: e7ff         	b	0x7009d736 <Sciclient_service+0x156> @ imm = #-0x2
;             if ((rxPayloadSize > 0U) && (pRespPrm->pRespPayload == NULL))
7009d736: 980c         	ldr	r0, [sp, #0x30]
7009d738: b140         	cbz	r0, 0x7009d74c <Sciclient_service+0x16c> @ imm = #0x10
7009d73a: e7ff         	b	0x7009d73c <Sciclient_service+0x15c> @ imm = #-0x2
7009d73c: 9812         	ldr	r0, [sp, #0x48]
7009d73e: 6840         	ldr	r0, [r0, #0x4]
7009d740: b920         	cbnz	r0, 0x7009d74c <Sciclient_service+0x16c> @ imm = #0x8
7009d742: e7ff         	b	0x7009d744 <Sciclient_service+0x164> @ imm = #-0x2
7009d744: f04f 30ff    	mov.w	r0, #0xffffffff
;                 status = SystemP_FAILURE;
7009d748: 9011         	str	r0, [sp, #0x44]
;             }
7009d74a: e004         	b	0x7009d756 <Sciclient_service+0x176> @ imm = #0x8
;                 pLocalRespPayload = (uint8_t *)(pRespPrm->pRespPayload + sizeof(struct tisci_header));
7009d74c: 9812         	ldr	r0, [sp, #0x48]
7009d74e: 6840         	ldr	r0, [r0, #0x4]
7009d750: 3008         	adds	r0, #0x8
7009d752: 900b         	str	r0, [sp, #0x2c]
7009d754: e7ff         	b	0x7009d756 <Sciclient_service+0x176> @ imm = #-0x2
;         }
7009d756: e003         	b	0x7009d760 <Sciclient_service+0x180> @ imm = #0x6
7009d758: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009d75c: 9011         	str	r0, [sp, #0x44]
7009d75e: e7ff         	b	0x7009d760 <Sciclient_service+0x180> @ imm = #-0x2
7009d760: e7ff         	b	0x7009d762 <Sciclient_service+0x182> @ imm = #-0x2
;     key = HwiP_disable();
7009d762: f013 e8fe    	blx	0x700b0960 <HwiP_disable> @ imm = #0x131fc
7009d766: 9008         	str	r0, [sp, #0x20]
;     if (SystemP_SUCCESS == status)
7009d768: 9811         	ldr	r0, [sp, #0x44]
7009d76a: 2800         	cmp	r0, #0x0
7009d76c: d159         	bne	0x7009d822 <Sciclient_service+0x242> @ imm = #0xb2
7009d76e: e7ff         	b	0x7009d770 <Sciclient_service+0x190> @ imm = #-0x2
;         Sciclient_secProxyFlush(rxThread);
7009d770: 9809         	ldr	r0, [sp, #0x24]
7009d772: f010 fde5    	bl	0x700ae340 <Sciclient_secProxyFlush> @ imm = #0x10bca
;         header = (struct tisci_header*)pReqPrm->pReqPayload;
7009d776: 9813         	ldr	r0, [sp, #0x4c]
7009d778: 6880         	ldr	r0, [r0, #0x8]
7009d77a: 9006         	str	r0, [sp, #0x18]
;         header->type = pReqPrm->messageType;
7009d77c: 9813         	ldr	r0, [sp, #0x4c]
7009d77e: 8800         	ldrh	r0, [r0]
7009d780: 9906         	ldr	r1, [sp, #0x18]
7009d782: 8008         	strh	r0, [r1]
;         header->host = (uint8_t) gSciclientMap[contextId].hostId;
7009d784: 9810         	ldr	r0, [sp, #0x40]
7009d786: eb00 0140    	add.w	r1, r0, r0, lsl #1
7009d78a: f241 3060    	movw	r0, #0x1360
7009d78e: f2c7 000b    	movt	r0, #0x700b
7009d792: eb00 00c1    	add.w	r0, r0, r1, lsl #3
7009d796: 6840         	ldr	r0, [r0, #0x4]
7009d798: 9906         	ldr	r1, [sp, #0x18]
7009d79a: 7088         	strb	r0, [r1, #0x2]
;         header->seq = localSeqId;
7009d79c: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
7009d7a0: 9906         	ldr	r1, [sp, #0x18]
7009d7a2: 70c8         	strb	r0, [r1, #0x3]
;         pFlags = (uint8_t*)&pReqPrm->flags;
7009d7a4: 9813         	ldr	r0, [sp, #0x4c]
7009d7a6: 3004         	adds	r0, #0x4
7009d7a8: 9004         	str	r0, [sp, #0x10]
7009d7aa: 2000         	movs	r0, #0x0
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009d7ac: 9003         	str	r0, [sp, #0xc]
7009d7ae: e7ff         	b	0x7009d7b0 <Sciclient_service+0x1d0> @ imm = #-0x2
7009d7b0: 9803         	ldr	r0, [sp, #0xc]
7009d7b2: 2803         	cmp	r0, #0x3
7009d7b4: d811         	bhi	0x7009d7da <Sciclient_service+0x1fa> @ imm = #0x22
7009d7b6: e7ff         	b	0x7009d7b8 <Sciclient_service+0x1d8> @ imm = #-0x2
;             uint8_t *pDestFlags = ((uint8_t*)&header->flags) + numBytes;
7009d7b8: 9806         	ldr	r0, [sp, #0x18]
7009d7ba: 9903         	ldr	r1, [sp, #0xc]
7009d7bc: 4408         	add	r0, r1
7009d7be: 3004         	adds	r0, #0x4
7009d7c0: 9002         	str	r0, [sp, #0x8]
;             *pDestFlags = *pFlags;
7009d7c2: 9804         	ldr	r0, [sp, #0x10]
7009d7c4: 7800         	ldrb	r0, [r0]
7009d7c6: 9902         	ldr	r1, [sp, #0x8]
7009d7c8: 7008         	strb	r0, [r1]
;             pFlags++;
7009d7ca: 9804         	ldr	r0, [sp, #0x10]
7009d7cc: 3001         	adds	r0, #0x1
7009d7ce: 9004         	str	r0, [sp, #0x10]
;         }
7009d7d0: e7ff         	b	0x7009d7d2 <Sciclient_service+0x1f2> @ imm = #-0x2
;         for (numBytes = 0; numBytes < sizeof(pReqPrm->flags); numBytes++)
7009d7d2: 9803         	ldr	r0, [sp, #0xc]
7009d7d4: 3001         	adds	r0, #0x1
7009d7d6: 9003         	str	r0, [sp, #0xc]
7009d7d8: e7ea         	b	0x7009d7b0 <Sciclient_service+0x1d0> @ imm = #-0x2c
;         gSciclientHandle.currSeqId = (gSciclientHandle.currSeqId + 1U) %
7009d7da: f642 1148    	movw	r1, #0x2948
7009d7de: f2c7 010b    	movt	r1, #0x700b
7009d7e2: 6808         	ldr	r0, [r1]
7009d7e4: 3001         	adds	r0, #0x1
7009d7e6: f644 1225    	movw	r2, #0x4925
7009d7ea: f2c2 4292    	movt	r2, #0x2492
7009d7ee: fba0 3202    	umull	r3, r2, r0, r2
7009d7f2: 1a83         	subs	r3, r0, r2
7009d7f4: eb02 0353    	add.w	r3, r2, r3, lsr #1
7009d7f8: 089a         	lsrs	r2, r3, #0x2
7009d7fa: 00d2         	lsls	r2, r2, #0x3
7009d7fc: eba2 0293    	sub.w	r2, r2, r3, lsr #2
7009d800: 1a80         	subs	r0, r0, r2
7009d802: 6008         	str	r0, [r1]
;         status = Sciclient_secProxyVerifyThread(txThread);
7009d804: 980a         	ldr	r0, [sp, #0x28]
7009d806: f011 fb53    	bl	0x700aeeb0 <Sciclient_secProxyVerifyThread> @ imm = #0x116a6
7009d80a: 9011         	str	r0, [sp, #0x44]
;         if (SystemP_SUCCESS == status)
7009d80c: 9811         	ldr	r0, [sp, #0x44]
7009d80e: b938         	cbnz	r0, 0x7009d820 <Sciclient_service+0x240> @ imm = #0xe
7009d810: e7ff         	b	0x7009d812 <Sciclient_service+0x232> @ imm = #-0x2
;             status = Sciclient_secProxyWaitThread(txThread, pReqPrm->timeout);
7009d812: 980a         	ldr	r0, [sp, #0x28]
7009d814: 9913         	ldr	r1, [sp, #0x4c]
7009d816: 6909         	ldr	r1, [r1, #0x10]
7009d818: f010 fab2    	bl	0x700add80 <Sciclient_secProxyWaitThread> @ imm = #0x10564
7009d81c: 9011         	str	r0, [sp, #0x44]
;         }
7009d81e: e7ff         	b	0x7009d820 <Sciclient_service+0x240> @ imm = #-0x2
;     }
7009d820: e7ff         	b	0x7009d822 <Sciclient_service+0x242> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
7009d822: 9811         	ldr	r0, [sp, #0x44]
7009d824: b9b0         	cbnz	r0, 0x7009d854 <Sciclient_service+0x274> @ imm = #0x2c
7009d826: e7ff         	b	0x7009d828 <Sciclient_service+0x248> @ imm = #-0x2
;         initialCount = Sciclient_secProxyReadThreadCount(rxThread);
7009d828: 9809         	ldr	r0, [sp, #0x24]
7009d82a: f012 f831    	bl	0x700af890 <Sciclient_secProxyReadThreadCount> @ imm = #0x12062
7009d82e: 900f         	str	r0, [sp, #0x3c]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009d830: 980a         	ldr	r0, [sp, #0x28]
7009d832: 9907         	ldr	r1, [sp, #0x1c]
7009d834: 9a06         	ldr	r2, [sp, #0x18]
;                               (pReqPrm->pReqPayload + sizeof(struct tisci_header)),
7009d836: 9b13         	ldr	r3, [sp, #0x4c]
7009d838: 689b         	ldr	r3, [r3, #0x8]
7009d83a: 3308         	adds	r3, #0x8
;                               txPayloadSize);
7009d83c: f8dd c034    	ldr.w	r12, [sp, #0x34]
;         Sciclient_sendMessage(txThread, pSecHeader ,(uint8_t *) header,
7009d840: 46ee         	mov	lr, sp
7009d842: f8ce c000    	str.w	r12, [lr]
7009d846: f004 ff1b    	bl	0x700a2680 <Sciclient_sendMessage> @ imm = #0x4e36
;         status = Sciclient_secProxyVerifyThread(rxThread);
7009d84a: 9809         	ldr	r0, [sp, #0x24]
7009d84c: f011 fb30    	bl	0x700aeeb0 <Sciclient_secProxyVerifyThread> @ imm = #0x11660
7009d850: 9011         	str	r0, [sp, #0x44]
;     }
7009d852: e7ff         	b	0x7009d854 <Sciclient_service+0x274> @ imm = #-0x2
;     if ((status == SystemP_SUCCESS) &&
7009d854: 9811         	ldr	r0, [sp, #0x44]
7009d856: b978         	cbnz	r0, 0x7009d878 <Sciclient_service+0x298> @ imm = #0x1e
7009d858: e7ff         	b	0x7009d85a <Sciclient_service+0x27a> @ imm = #-0x2
;         ((pReqPrm->flags & TISCI_MSG_FLAG_MASK) != 0U))
7009d85a: 9813         	ldr	r0, [sp, #0x4c]
;     if ((status == SystemP_SUCCESS) &&
7009d85c: 7900         	ldrb	r0, [r0, #0x4]
7009d85e: 0780         	lsls	r0, r0, #0x1e
7009d860: b150         	cbz	r0, 0x7009d878 <Sciclient_service+0x298> @ imm = #0x14
7009d862: e7ff         	b	0x7009d864 <Sciclient_service+0x284> @ imm = #-0x2
;         status = Sciclient_waitForMessage(rxThread, pReqPrm->timeout, initialCount, localSeqId);
7009d864: 9809         	ldr	r0, [sp, #0x24]
7009d866: 9913         	ldr	r1, [sp, #0x4c]
7009d868: 6909         	ldr	r1, [r1, #0x10]
7009d86a: 9a0f         	ldr	r2, [sp, #0x3c]
7009d86c: f89d 303b    	ldrb.w	r3, [sp, #0x3b]
7009d870: f008 fc1e    	bl	0x700a60b0 <Sciclient_waitForMessage> @ imm = #0x883c
7009d874: 9011         	str	r0, [sp, #0x44]
;     }
7009d876: e7ff         	b	0x7009d878 <Sciclient_service+0x298> @ imm = #-0x2
;     if(status == SystemP_SUCCESS)
7009d878: 9811         	ldr	r0, [sp, #0x44]
7009d87a: b990         	cbnz	r0, 0x7009d8a2 <Sciclient_service+0x2c2> @ imm = #0x24
7009d87c: e7ff         	b	0x7009d87e <Sciclient_service+0x29e> @ imm = #-0x2
;         pRespPrm->flags = Sciclient_secProxyReadThread32(rxThread, 1U+gSecHeaderSizeWords);
7009d87e: 9809         	ldr	r0, [sp, #0x24]
7009d880: f642 2154    	movw	r1, #0x2a54
7009d884: f2c7 010b    	movt	r1, #0x700b
7009d888: 7809         	ldrb	r1, [r1]
7009d88a: 3101         	adds	r1, #0x1
7009d88c: b2c9         	uxtb	r1, r1
7009d88e: f011 f86f    	bl	0x700ae970 <Sciclient_secProxyReadThread32> @ imm = #0x110de
7009d892: 9912         	ldr	r1, [sp, #0x48]
7009d894: 6008         	str	r0, [r1]
;         Sciclient_recvMessage(rxThread, pLocalRespPayload, rxPayloadSize);
7009d896: 9809         	ldr	r0, [sp, #0x24]
7009d898: 990b         	ldr	r1, [sp, #0x2c]
7009d89a: 9a0c         	ldr	r2, [sp, #0x30]
7009d89c: f005 fbf8    	bl	0x700a3090 <Sciclient_recvMessage> @ imm = #0x57f0
;     }
7009d8a0: e7ff         	b	0x7009d8a2 <Sciclient_service+0x2c2> @ imm = #-0x2
;     HwiP_restore(key);
7009d8a2: 9808         	ldr	r0, [sp, #0x20]
7009d8a4: f013 e87c    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x130f8
;     return status;
7009d8a8: 9811         	ldr	r0, [sp, #0x44]
7009d8aa: b014         	add	sp, #0x50
7009d8ac: bd80         	pop	{r7, pc}
7009d8ae: 0000         	movs	r0, r0

7009d8b0 <Udma_chDisableRxChan>:
; {
7009d8b0: b580         	push	{r7, lr}
7009d8b2: b096         	sub	sp, #0x58
7009d8b4: 9015         	str	r0, [sp, #0x54]
7009d8b6: 9114         	str	r1, [sp, #0x50]
7009d8b8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009d8ba: 9013         	str	r0, [sp, #0x4c]
;     uint32_t            currTimeout = 0U, regVal;
7009d8bc: 9012         	str	r0, [sp, #0x48]
;     uint32_t            peerRtEnable = 0U, peerRtEnableBit = 0U;
7009d8be: 9004         	str	r0, [sp, #0x10]
7009d8c0: 9003         	str	r0, [sp, #0xc]
;     drvHandle = chHandle->drvHandle;
7009d8c2: 9815         	ldr	r0, [sp, #0x54]
7009d8c4: 6e80         	ldr	r0, [r0, #0x68]
7009d8c6: 9010         	str	r0, [sp, #0x40]
7009d8c8: 2008         	movs	r0, #0x8
;     rtEnableRegOffset = CSL_PSILCFG_REG_RT_ENABLE - CSL_PSILCFG_REG_STATIC_TR;
7009d8ca: 9002         	str	r0, [sp, #0x8]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d8cc: 9810         	ldr	r0, [sp, #0x40]
7009d8ce: 6800         	ldr	r0, [r0]
7009d8d0: 2801         	cmp	r0, #0x1
7009d8d2: d115         	bne	0x7009d900 <Udma_chDisableRxChan+0x50> @ imm = #0x2a
7009d8d4: e7ff         	b	0x7009d8d6 <Udma_chDisableRxChan+0x26> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
7009d8d6: 9815         	ldr	r0, [sp, #0x54]
7009d8d8: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009d8dc: f500 7008    	add.w	r0, r0, #0x220
7009d8e0: f012 f9b6    	bl	0x700afc50 <CSL_REG32_RD_RAW> @ imm = #0x1236c
7009d8e4: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009d8e6: 9811         	ldr	r0, [sp, #0x44]
7009d8e8: f040 4080    	orr	r0, r0, #0x40000000
7009d8ec: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
7009d8ee: 9815         	ldr	r0, [sp, #0x54]
7009d8f0: f8d0 0228    	ldr.w	r0, [r0, #0x228]
7009d8f4: f500 7008    	add.w	r0, r0, #0x220
7009d8f8: 9911         	ldr	r1, [sp, #0x44]
7009d8fa: f012 f909    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x12212
;     }
7009d8fe: e01a         	b	0x7009d936 <Udma_chDisableRxChan+0x86> @ imm = #0x34
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d900: 9810         	ldr	r0, [sp, #0x40]
7009d902: 6800         	ldr	r0, [r0]
7009d904: 2802         	cmp	r0, #0x2
7009d906: d115         	bne	0x7009d934 <Udma_chDisableRxChan+0x84> @ imm = #0x2a
7009d908: e7ff         	b	0x7009d90a <Udma_chDisableRxChan+0x5a> @ imm = #-0x2
;         regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
7009d90a: 9815         	ldr	r0, [sp, #0x54]
7009d90c: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009d910: f500 7008    	add.w	r0, r0, #0x220
7009d914: f012 f99c    	bl	0x700afc50 <CSL_REG32_RD_RAW> @ imm = #0x12338
7009d918: 9011         	str	r0, [sp, #0x44]
;         CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) 1U);
7009d91a: 9811         	ldr	r0, [sp, #0x44]
7009d91c: f040 4080    	orr	r0, r0, #0x40000000
7009d920: 9011         	str	r0, [sp, #0x44]
;         CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
7009d922: 9815         	ldr	r0, [sp, #0x54]
7009d924: f8d0 0238    	ldr.w	r0, [r0, #0x238]
7009d928: f500 7008    	add.w	r0, r0, #0x220
7009d92c: 9911         	ldr	r1, [sp, #0x44]
7009d92e: f012 f8ef    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x121de
;     }
7009d932: e7ff         	b	0x7009d934 <Udma_chDisableRxChan+0x84> @ imm = #-0x2
7009d934: e7ff         	b	0x7009d936 <Udma_chDisableRxChan+0x86> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009d936: e7ff         	b	0x7009d938 <Udma_chDisableRxChan+0x88> @ imm = #-0x2
7009d938: 9813         	ldr	r0, [sp, #0x4c]
7009d93a: bbc8         	cbnz	r0, 0x7009d9b0 <Udma_chDisableRxChan+0x100> @ imm = #0x72
7009d93c: e7ff         	b	0x7009d93e <Udma_chDisableRxChan+0x8e> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d93e: 9810         	ldr	r0, [sp, #0x40]
7009d940: 6800         	ldr	r0, [r0]
7009d942: 2801         	cmp	r0, #0x1
7009d944: d110         	bne	0x7009d968 <Udma_chDisableRxChan+0xb8> @ imm = #0x20
7009d946: e7ff         	b	0x7009d948 <Udma_chDisableRxChan+0x98> @ imm = #-0x2
;             (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009d948: 9a10         	ldr	r2, [sp, #0x40]
7009d94a: f102 0008    	add.w	r0, r2, #0x8
7009d94e: 9915         	ldr	r1, [sp, #0x54]
7009d950: 6f09         	ldr	r1, [r1, #0x70]
7009d952: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d956: 4411         	add	r1, r2
7009d958: aa0a         	add	r2, sp, #0x28
7009d95a: f011 f8b1    	bl	0x700aeac0 <CSL_bcdmaGetRxRT> @ imm = #0x11162
;             if(FALSE == bcdmaRtStatus.enable)
7009d95e: 980a         	ldr	r0, [sp, #0x28]
7009d960: b908         	cbnz	r0, 0x7009d966 <Udma_chDisableRxChan+0xb6> @ imm = #0x2
7009d962: e7ff         	b	0x7009d964 <Udma_chDisableRxChan+0xb4> @ imm = #-0x2
;                 break;
7009d964: e024         	b	0x7009d9b0 <Udma_chDisableRxChan+0x100> @ imm = #0x48
;         }
7009d966: e011         	b	0x7009d98c <Udma_chDisableRxChan+0xdc> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d968: 9810         	ldr	r0, [sp, #0x40]
7009d96a: 6800         	ldr	r0, [r0]
7009d96c: 2802         	cmp	r0, #0x2
7009d96e: d10c         	bne	0x7009d98a <Udma_chDisableRxChan+0xda> @ imm = #0x18
7009d970: e7ff         	b	0x7009d972 <Udma_chDisableRxChan+0xc2> @ imm = #-0x2
;             (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009d972: 9810         	ldr	r0, [sp, #0x40]
7009d974: 3054         	adds	r0, #0x54
7009d976: 9915         	ldr	r1, [sp, #0x54]
7009d978: 6f09         	ldr	r1, [r1, #0x70]
7009d97a: aa05         	add	r2, sp, #0x14
7009d97c: f00f fd40    	bl	0x700ad400 <CSL_pktdmaGetRxRT> @ imm = #0xfa80
;             if(FALSE == pktdmaRtStatus.enable)
7009d980: 9805         	ldr	r0, [sp, #0x14]
7009d982: b908         	cbnz	r0, 0x7009d988 <Udma_chDisableRxChan+0xd8> @ imm = #0x2
7009d984: e7ff         	b	0x7009d986 <Udma_chDisableRxChan+0xd6> @ imm = #-0x2
;                 break;
7009d986: e013         	b	0x7009d9b0 <Udma_chDisableRxChan+0x100> @ imm = #0x26
;         }
7009d988: e7ff         	b	0x7009d98a <Udma_chDisableRxChan+0xda> @ imm = #-0x2
7009d98a: e7ff         	b	0x7009d98c <Udma_chDisableRxChan+0xdc> @ imm = #-0x2
;         if(currTimeout > timeout)
7009d98c: 9812         	ldr	r0, [sp, #0x48]
7009d98e: 9914         	ldr	r1, [sp, #0x50]
7009d990: 4288         	cmp	r0, r1
7009d992: d904         	bls	0x7009d99e <Udma_chDisableRxChan+0xee> @ imm = #0x8
7009d994: e7ff         	b	0x7009d996 <Udma_chDisableRxChan+0xe6> @ imm = #-0x2
7009d996: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009d99a: 9013         	str	r0, [sp, #0x4c]
;         }
7009d99c: e007         	b	0x7009d9ae <Udma_chDisableRxChan+0xfe> @ imm = #0xe
7009d99e: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009d9a2: f00d fbed    	bl	0x700ab180 <ClockP_usleep> @ imm = #0xd7da
;             currTimeout++;
7009d9a6: 9812         	ldr	r0, [sp, #0x48]
7009d9a8: 3001         	adds	r0, #0x1
7009d9aa: 9012         	str	r0, [sp, #0x48]
7009d9ac: e7ff         	b	0x7009d9ae <Udma_chDisableRxChan+0xfe> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009d9ae: e7c3         	b	0x7009d938 <Udma_chDisableRxChan+0x88> @ imm = #-0x7a
;     if(UDMA_SOK != retVal)
7009d9b0: 9813         	ldr	r0, [sp, #0x4c]
7009d9b2: 2800         	cmp	r0, #0x0
7009d9b4: f000 8091    	beq.w	0x7009dada <Udma_chDisableRxChan+0x22a> @ imm = #0x122
7009d9b8: e7ff         	b	0x7009d9ba <Udma_chDisableRxChan+0x10a> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009d9ba: 9810         	ldr	r0, [sp, #0x40]
7009d9bc: 6800         	ldr	r0, [r0]
7009d9be: 2801         	cmp	r0, #0x1
7009d9c0: d10e         	bne	0x7009d9e0 <Udma_chDisableRxChan+0x130> @ imm = #0x1c
7009d9c2: e7ff         	b	0x7009d9c4 <Udma_chDisableRxChan+0x114> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, (bool)true, (bool)false);
7009d9c4: 9a10         	ldr	r2, [sp, #0x40]
7009d9c6: f102 0008    	add.w	r0, r2, #0x8
7009d9ca: 9915         	ldr	r1, [sp, #0x54]
7009d9cc: 6f09         	ldr	r1, [r1, #0x70]
7009d9ce: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009d9d2: 4411         	add	r1, r2
7009d9d4: 2201         	movs	r2, #0x1
7009d9d6: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownRxChan(
7009d9d8: f00f fec2    	bl	0x700ad760 <CSL_bcdmaTeardownRxChan> @ imm = #0xfd84
7009d9dc: 9013         	str	r0, [sp, #0x4c]
;         }
7009d9de: e00f         	b	0x7009da00 <Udma_chDisableRxChan+0x150> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009d9e0: 9810         	ldr	r0, [sp, #0x40]
7009d9e2: 6800         	ldr	r0, [r0]
7009d9e4: 2802         	cmp	r0, #0x2
7009d9e6: d10a         	bne	0x7009d9fe <Udma_chDisableRxChan+0x14e> @ imm = #0x14
7009d9e8: e7ff         	b	0x7009d9ea <Udma_chDisableRxChan+0x13a> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->rxChNum, (bool)true, (bool)false);
7009d9ea: 9810         	ldr	r0, [sp, #0x40]
7009d9ec: 3054         	adds	r0, #0x54
7009d9ee: 9915         	ldr	r1, [sp, #0x54]
7009d9f0: 6f09         	ldr	r1, [r1, #0x70]
7009d9f2: 2201         	movs	r2, #0x1
7009d9f4: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownRxChan(
7009d9f6: f010 fd63    	bl	0x700ae4c0 <CSL_pktdmaTeardownRxChan> @ imm = #0x10ac6
7009d9fa: 9013         	str	r0, [sp, #0x4c]
;         }
7009d9fc: e7ff         	b	0x7009d9fe <Udma_chDisableRxChan+0x14e> @ imm = #-0x2
7009d9fe: e7ff         	b	0x7009da00 <Udma_chDisableRxChan+0x150> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009da00: 9813         	ldr	r0, [sp, #0x4c]
7009da02: b108         	cbz	r0, 0x7009da08 <Udma_chDisableRxChan+0x158> @ imm = #0x2
7009da04: e7ff         	b	0x7009da06 <Udma_chDisableRxChan+0x156> @ imm = #-0x2
;         }
7009da06: e7ff         	b	0x7009da08 <Udma_chDisableRxChan+0x158> @ imm = #-0x2
7009da08: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009da0a: 9012         	str	r0, [sp, #0x48]
;         while(UDMA_SOK == retVal)
7009da0c: e7ff         	b	0x7009da0e <Udma_chDisableRxChan+0x15e> @ imm = #-0x2
7009da0e: 9813         	ldr	r0, [sp, #0x4c]
7009da10: 2800         	cmp	r0, #0x0
7009da12: d161         	bne	0x7009dad8 <Udma_chDisableRxChan+0x228> @ imm = #0xc2
7009da14: e7ff         	b	0x7009da16 <Udma_chDisableRxChan+0x166> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009da16: 9810         	ldr	r0, [sp, #0x40]
7009da18: 6800         	ldr	r0, [r0]
7009da1a: 2801         	cmp	r0, #0x1
7009da1c: d126         	bne	0x7009da6c <Udma_chDisableRxChan+0x1bc> @ imm = #0x4c
7009da1e: e7ff         	b	0x7009da20 <Udma_chDisableRxChan+0x170> @ imm = #-0x2
;                 (void) CSL_bcdmaGetRxRT(&drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009da20: 9a10         	ldr	r2, [sp, #0x40]
7009da22: f102 0008    	add.w	r0, r2, #0x8
7009da26: 9915         	ldr	r1, [sp, #0x54]
7009da28: 6f09         	ldr	r1, [r1, #0x70]
7009da2a: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009da2e: 4411         	add	r1, r2
7009da30: aa0a         	add	r2, sp, #0x28
7009da32: f011 f845    	bl	0x700aeac0 <CSL_bcdmaGetRxRT> @ imm = #0x1108a
;                     &drvHandle->bcdmaRegs,
7009da36: 9a10         	ldr	r2, [sp, #0x40]
7009da38: f102 0008    	add.w	r0, r2, #0x8
;                     chHandle->rxChNum + drvHandle->rxChOffset,
7009da3c: 9915         	ldr	r1, [sp, #0x54]
7009da3e: 6f09         	ldr	r1, [r1, #0x70]
7009da40: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009da44: 4411         	add	r1, r2
;                     rtEnableRegOffset, &peerRtEnable);
7009da46: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_bcdmaGetChanPeerReg(
7009da48: 46ec         	mov	r12, sp
7009da4a: aa04         	add	r2, sp, #0x10
7009da4c: f8cc 2000    	str.w	r2, [r12]
7009da50: 2201         	movs	r2, #0x1
7009da52: f00f ff75    	bl	0x700ad940 <CSL_bcdmaGetChanPeerReg> @ imm = #0xfeea
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009da56: 9804         	ldr	r0, [sp, #0x10]
7009da58: 0fc0         	lsrs	r0, r0, #0x1f
7009da5a: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == bcdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009da5c: 980a         	ldr	r0, [sp, #0x28]
7009da5e: b920         	cbnz	r0, 0x7009da6a <Udma_chDisableRxChan+0x1ba> @ imm = #0x8
7009da60: e7ff         	b	0x7009da62 <Udma_chDisableRxChan+0x1b2> @ imm = #-0x2
7009da62: 9803         	ldr	r0, [sp, #0xc]
7009da64: b908         	cbnz	r0, 0x7009da6a <Udma_chDisableRxChan+0x1ba> @ imm = #0x2
7009da66: e7ff         	b	0x7009da68 <Udma_chDisableRxChan+0x1b8> @ imm = #-0x2
;                     break;
7009da68: e036         	b	0x7009dad8 <Udma_chDisableRxChan+0x228> @ imm = #0x6c
;             }
7009da6a: e023         	b	0x7009dab4 <Udma_chDisableRxChan+0x204> @ imm = #0x46
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009da6c: 9810         	ldr	r0, [sp, #0x40]
7009da6e: 6800         	ldr	r0, [r0]
7009da70: 2802         	cmp	r0, #0x2
7009da72: d11e         	bne	0x7009dab2 <Udma_chDisableRxChan+0x202> @ imm = #0x3c
7009da74: e7ff         	b	0x7009da76 <Udma_chDisableRxChan+0x1c6> @ imm = #-0x2
;                 (void) CSL_pktdmaGetRxRT(&drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009da76: 9810         	ldr	r0, [sp, #0x40]
7009da78: 3054         	adds	r0, #0x54
7009da7a: 9915         	ldr	r1, [sp, #0x54]
7009da7c: 6f09         	ldr	r1, [r1, #0x70]
7009da7e: aa05         	add	r2, sp, #0x14
7009da80: f00f fcbe    	bl	0x700ad400 <CSL_pktdmaGetRxRT> @ imm = #0xf97c
;                     &drvHandle->pktdmaRegs,
7009da84: 9810         	ldr	r0, [sp, #0x40]
7009da86: 3054         	adds	r0, #0x54
;                     chHandle->rxChNum,
7009da88: 9915         	ldr	r1, [sp, #0x54]
7009da8a: 6f09         	ldr	r1, [r1, #0x70]
;                     rtEnableRegOffset, &peerRtEnable);
7009da8c: 9b02         	ldr	r3, [sp, #0x8]
;                 (void) CSL_pktdmaGetChanPeerReg(
7009da8e: 46ec         	mov	r12, sp
7009da90: aa04         	add	r2, sp, #0x10
7009da92: f8cc 2000    	str.w	r2, [r12]
7009da96: 2201         	movs	r2, #0x1
7009da98: f010 feaa    	bl	0x700ae7f0 <CSL_pktdmaGetChanPeerReg> @ imm = #0x10d54
;                 peerRtEnableBit = CSL_FEXT(peerRtEnable, PSILCFG_REG_RT_ENABLE_ENABLE);
7009da9c: 9804         	ldr	r0, [sp, #0x10]
7009da9e: 0fc0         	lsrs	r0, r0, #0x1f
7009daa0: 9003         	str	r0, [sp, #0xc]
;                 if((FALSE == pktdmaRtStatus.enable) && (FALSE == peerRtEnableBit))
7009daa2: 9805         	ldr	r0, [sp, #0x14]
7009daa4: b920         	cbnz	r0, 0x7009dab0 <Udma_chDisableRxChan+0x200> @ imm = #0x8
7009daa6: e7ff         	b	0x7009daa8 <Udma_chDisableRxChan+0x1f8> @ imm = #-0x2
7009daa8: 9803         	ldr	r0, [sp, #0xc]
7009daaa: b908         	cbnz	r0, 0x7009dab0 <Udma_chDisableRxChan+0x200> @ imm = #0x2
7009daac: e7ff         	b	0x7009daae <Udma_chDisableRxChan+0x1fe> @ imm = #-0x2
;                     break;
7009daae: e013         	b	0x7009dad8 <Udma_chDisableRxChan+0x228> @ imm = #0x26
;             }
7009dab0: e7ff         	b	0x7009dab2 <Udma_chDisableRxChan+0x202> @ imm = #-0x2
7009dab2: e7ff         	b	0x7009dab4 <Udma_chDisableRxChan+0x204> @ imm = #-0x2
;             if(currTimeout > timeout)
7009dab4: 9812         	ldr	r0, [sp, #0x48]
7009dab6: 9914         	ldr	r1, [sp, #0x50]
7009dab8: 4288         	cmp	r0, r1
7009daba: d904         	bls	0x7009dac6 <Udma_chDisableRxChan+0x216> @ imm = #0x8
7009dabc: e7ff         	b	0x7009dabe <Udma_chDisableRxChan+0x20e> @ imm = #-0x2
7009dabe: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009dac2: 9013         	str	r0, [sp, #0x4c]
;             }
7009dac4: e007         	b	0x7009dad6 <Udma_chDisableRxChan+0x226> @ imm = #0xe
7009dac6: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009daca: f00d fb59    	bl	0x700ab180 <ClockP_usleep> @ imm = #0xd6b2
;                 currTimeout++;
7009dace: 9812         	ldr	r0, [sp, #0x48]
7009dad0: 3001         	adds	r0, #0x1
7009dad2: 9012         	str	r0, [sp, #0x48]
7009dad4: e7ff         	b	0x7009dad6 <Udma_chDisableRxChan+0x226> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009dad6: e79a         	b	0x7009da0e <Udma_chDisableRxChan+0x15e> @ imm = #-0xcc
;     }
7009dad8: e7ff         	b	0x7009dada <Udma_chDisableRxChan+0x22a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009dada: 9813         	ldr	r0, [sp, #0x4c]
7009dadc: 2800         	cmp	r0, #0x0
7009dade: d148         	bne	0x7009db72 <Udma_chDisableRxChan+0x2c2> @ imm = #0x90
7009dae0: e7ff         	b	0x7009dae2 <Udma_chDisableRxChan+0x232> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009dae2: 9810         	ldr	r0, [sp, #0x40]
7009dae4: 6800         	ldr	r0, [r0]
7009dae6: 2801         	cmp	r0, #0x1
7009dae8: d122         	bne	0x7009db30 <Udma_chDisableRxChan+0x280> @ imm = #0x44
7009daea: e7ff         	b	0x7009daec <Udma_chDisableRxChan+0x23c> @ imm = #-0x2
7009daec: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009daee: 900b         	str	r0, [sp, #0x2c]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009daf0: 9804         	ldr	r0, [sp, #0x10]
7009daf2: f020 4080    	bic	r0, r0, #0x40000000
7009daf6: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtStatus);
7009daf8: 9a10         	ldr	r2, [sp, #0x40]
7009dafa: f102 0008    	add.w	r0, r2, #0x8
7009dafe: 9915         	ldr	r1, [sp, #0x54]
7009db00: 6f09         	ldr	r1, [r1, #0x70]
7009db02: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009db06: 4411         	add	r1, r2
7009db08: aa0a         	add	r2, sp, #0x28
;             (void) CSL_bcdmaSetRxRT(
7009db0a: f011 f809    	bl	0x700aeb20 <CSL_bcdmaSetRxRT> @ imm = #0x11012
;                 &drvHandle->bcdmaRegs,
7009db0e: 9a10         	ldr	r2, [sp, #0x40]
7009db10: f102 0008    	add.w	r0, r2, #0x8
;                 chHandle->rxChNum + drvHandle->rxChOffset,
7009db14: 9915         	ldr	r1, [sp, #0x54]
7009db16: 6f09         	ldr	r1, [r1, #0x70]
7009db18: f8d2 2114    	ldr.w	r2, [r2, #0x114]
7009db1c: 4411         	add	r1, r2
;                 rtEnableRegOffset,
7009db1e: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_bcdmaSetChanPeerReg(
7009db20: 46ec         	mov	r12, sp
7009db22: aa04         	add	r2, sp, #0x10
7009db24: f8cc 2000    	str.w	r2, [r12]
7009db28: 2201         	movs	r2, #0x1
7009db2a: f010 f9e9    	bl	0x700adf00 <CSL_bcdmaSetChanPeerReg> @ imm = #0x103d2
;         }
7009db2e: e01f         	b	0x7009db70 <Udma_chDisableRxChan+0x2c0> @ imm = #0x3e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009db30: 9810         	ldr	r0, [sp, #0x40]
7009db32: 6800         	ldr	r0, [r0]
7009db34: 2802         	cmp	r0, #0x2
7009db36: d11a         	bne	0x7009db6e <Udma_chDisableRxChan+0x2be> @ imm = #0x34
7009db38: e7ff         	b	0x7009db3a <Udma_chDisableRxChan+0x28a> @ imm = #-0x2
7009db3a: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.teardown = FALSE;   /* Note that other bits are cleared from previous call */
7009db3c: 9006         	str	r0, [sp, #0x18]
;             CSL_FINS(peerRtEnable, PSILCFG_REG_RT_ENABLE_TDOWN, (uint32_t) FALSE);
7009db3e: 9804         	ldr	r0, [sp, #0x10]
7009db40: f020 4080    	bic	r0, r0, #0x40000000
7009db44: 9004         	str	r0, [sp, #0x10]
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtStatus);
7009db46: 9810         	ldr	r0, [sp, #0x40]
7009db48: 3054         	adds	r0, #0x54
7009db4a: 9915         	ldr	r1, [sp, #0x54]
7009db4c: 6f09         	ldr	r1, [r1, #0x70]
7009db4e: aa05         	add	r2, sp, #0x14
;             (void) CSL_pktdmaSetRxRT(
7009db50: f010 fa16    	bl	0x700adf80 <CSL_pktdmaSetRxRT> @ imm = #0x1042c
;                 &drvHandle->pktdmaRegs,
7009db54: 9810         	ldr	r0, [sp, #0x40]
7009db56: 3054         	adds	r0, #0x54
;                 chHandle->rxChNum,
7009db58: 9915         	ldr	r1, [sp, #0x54]
7009db5a: 6f09         	ldr	r1, [r1, #0x70]
;                 rtEnableRegOffset,
7009db5c: 9b02         	ldr	r3, [sp, #0x8]
;             (void) CSL_pktdmaSetChanPeerReg(
7009db5e: 46ec         	mov	r12, sp
7009db60: aa04         	add	r2, sp, #0x10
7009db62: f8cc 2000    	str.w	r2, [r12]
7009db66: 2201         	movs	r2, #0x1
7009db68: f010 fe5a    	bl	0x700ae820 <CSL_pktdmaSetChanPeerReg> @ imm = #0x10cb4
;         }
7009db6c: e7ff         	b	0x7009db6e <Udma_chDisableRxChan+0x2be> @ imm = #-0x2
7009db6e: e7ff         	b	0x7009db70 <Udma_chDisableRxChan+0x2c0> @ imm = #-0x2
;     }
7009db70: e7ff         	b	0x7009db72 <Udma_chDisableRxChan+0x2c2> @ imm = #-0x2
;     return (retVal);
7009db72: 9813         	ldr	r0, [sp, #0x4c]
7009db74: b016         	add	sp, #0x58
7009db76: bd80         	pop	{r7, pc}
		...

7009db80 <CSL_bcdmaChanOpCfgChan>:
; {
7009db80: b580         	push	{r7, lr}
7009db82: b08a         	sub	sp, #0x28
7009db84: 9009         	str	r0, [sp, #0x24]
7009db86: 9108         	str	r1, [sp, #0x20]
7009db88: 9207         	str	r2, [sp, #0x1c]
7009db8a: 9306         	str	r3, [sp, #0x18]
7009db8c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
7009db8e: 9005         	str	r0, [sp, #0x14]
;     if( pOpData == NULL )
7009db90: 9806         	ldr	r0, [sp, #0x18]
7009db92: b920         	cbnz	r0, 0x7009db9e <CSL_bcdmaChanOpCfgChan+0x1e> @ imm = #0x8
7009db94: e7ff         	b	0x7009db96 <CSL_bcdmaChanOpCfgChan+0x16> @ imm = #-0x2
7009db96: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
7009db9a: 9005         	str	r0, [sp, #0x14]
;     }
7009db9c: e137         	b	0x7009de0e <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #0x26e
;         switch( chanType )
7009db9e: 9808         	ldr	r0, [sp, #0x20]
7009dba0: 9000         	str	r0, [sp]
7009dba2: b148         	cbz	r0, 0x7009dbb8 <CSL_bcdmaChanOpCfgChan+0x38> @ imm = #0x12
7009dba4: e7ff         	b	0x7009dba6 <CSL_bcdmaChanOpCfgChan+0x26> @ imm = #-0x2
7009dba6: 9800         	ldr	r0, [sp]
7009dba8: 2801         	cmp	r0, #0x1
7009dbaa: d057         	beq	0x7009dc5c <CSL_bcdmaChanOpCfgChan+0xdc> @ imm = #0xae
7009dbac: e7ff         	b	0x7009dbae <CSL_bcdmaChanOpCfgChan+0x2e> @ imm = #-0x2
7009dbae: 9800         	ldr	r0, [sp]
7009dbb0: 2802         	cmp	r0, #0x2
7009dbb2: f000 80c1    	beq.w	0x7009dd38 <CSL_bcdmaChanOpCfgChan+0x1b8> @ imm = #0x182
7009dbb6: e125         	b	0x7009de04 <CSL_bcdmaChanOpCfgChan+0x284> @ imm = #0x24a
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009dbb8: 9806         	ldr	r0, [sp, #0x18]
7009dbba: 9003         	str	r0, [sp, #0xc]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009dbbc: 9803         	ldr	r0, [sp, #0xc]
7009dbbe: 6c40         	ldr	r0, [r0, #0x44]
7009dbc0: 2802         	cmp	r0, #0x2
7009dbc2: d80a         	bhi	0x7009dbda <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0x14
7009dbc4: e7ff         	b	0x7009dbc6 <CSL_bcdmaChanOpCfgChan+0x46> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009dbc6: 9803         	ldr	r0, [sp, #0xc]
7009dbc8: 6a00         	ldr	r0, [r0, #0x20]
7009dbca: 2807         	cmp	r0, #0x7
7009dbcc: d805         	bhi	0x7009dbda <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #0xa
7009dbce: e7ff         	b	0x7009dbd0 <CSL_bcdmaChanOpCfgChan+0x50> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009dbd0: 9803         	ldr	r0, [sp, #0xc]
7009dbd2: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES)   ||    /* Block-copy supports 32, 64, and 128-byte bursts */
7009dbd4: 2804         	cmp	r0, #0x4
7009dbd6: d304         	blo	0x7009dbe2 <CSL_bcdmaChanOpCfgChan+0x62> @ imm = #0x8
7009dbd8: e7ff         	b	0x7009dbda <CSL_bcdmaChanOpCfgChan+0x5a> @ imm = #-0x2
7009dbda: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009dbde: 9005         	str	r0, [sp, #0x14]
;                     }
7009dbe0: e03b         	b	0x7009dc5a <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #0x76
;                         regVal = CSL_REG32_RD( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG );
7009dbe2: 9809         	ldr	r0, [sp, #0x24]
7009dbe4: 6840         	ldr	r0, [r0, #0x4]
7009dbe6: 9907         	ldr	r1, [sp, #0x1c]
7009dbe8: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dbec: f012 f808    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0x12010
7009dbf0: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_PAUSE_ON_ERR, pChanCfg->pauseOnError );
7009dbf2: 9804         	ldr	r0, [sp, #0x10]
7009dbf4: f020 4000    	bic	r0, r0, #0x80000000
7009dbf8: 9903         	ldr	r1, [sp, #0xc]
7009dbfa: 6809         	ldr	r1, [r1]
7009dbfc: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009dc00: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, pChanCfg->burstSize );
7009dc02: 9804         	ldr	r0, [sp, #0x10]
7009dc04: 9903         	ldr	r1, [sp, #0xc]
7009dc06: 6c49         	ldr	r1, [r1, #0x44]
7009dc08: f361 208b    	bfi	r0, r1, #10, #2
7009dc0c: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, regVal );
7009dc0e: 9809         	ldr	r0, [sp, #0x24]
7009dc10: 6840         	ldr	r0, [r0, #0x4]
7009dc12: 9907         	ldr	r1, [sp, #0x1c]
7009dc14: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dc18: 9904         	ldr	r1, [sp, #0x10]
7009dc1a: f7fe fb39    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x198e
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009dc1e: 9803         	ldr	r0, [sp, #0xc]
7009dc20: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009dc22: 6a80         	ldr	r0, [r0, #0x28]
7009dc24: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_BCCFG_CHAN_PRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009dc28: f361 701e    	bfi	r0, r1, #28, #3
7009dc2c: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].PRI_CTRL, regVal );
7009dc2e: 9809         	ldr	r0, [sp, #0x24]
7009dc30: 6840         	ldr	r0, [r0, #0x4]
7009dc32: 9907         	ldr	r1, [sp, #0x1c]
7009dc34: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dc38: 3064         	adds	r0, #0x64
7009dc3a: 9904         	ldr	r1, [sp, #0x10]
7009dc3c: f7fe fb28    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x19b0
;                         CSL_REG32_WR( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_BCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009dc40: 9809         	ldr	r0, [sp, #0x24]
7009dc42: 6840         	ldr	r0, [r0, #0x4]
7009dc44: 9907         	ldr	r1, [sp, #0x1c]
7009dc46: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dc4a: 3080         	adds	r0, #0x80
7009dc4c: 9903         	ldr	r1, [sp, #0xc]
7009dc4e: 6ac9         	ldr	r1, [r1, #0x2c]
7009dc50: f001 0103    	and	r1, r1, #0x3
7009dc54: f7fe fb1c    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x19c8
7009dc58: e7ff         	b	0x7009dc5a <CSL_bcdmaChanOpCfgChan+0xda> @ imm = #-0x2
;                 break;
7009dc5a: e0d7         	b	0x7009de0c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x1ae
;                     CSL_BcdmaTxChanCfg *pChanCfg = (CSL_BcdmaTxChanCfg *)pOpData;
7009dc5c: 9806         	ldr	r0, [sp, #0x18]
7009dc5e: 9002         	str	r0, [sp, #0x8]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009dc60: 9802         	ldr	r0, [sp, #0x8]
7009dc62: 6c40         	ldr	r0, [r0, #0x44]
7009dc64: 2801         	cmp	r0, #0x1
7009dc66: d80a         	bhi	0x7009dc7e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0x14
7009dc68: e7ff         	b	0x7009dc6a <CSL_bcdmaChanOpCfgChan+0xea> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009dc6a: 9802         	ldr	r0, [sp, #0x8]
7009dc6c: 6a00         	ldr	r0, [r0, #0x20]
7009dc6e: 2807         	cmp	r0, #0x7
7009dc70: d805         	bhi	0x7009dc7e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #0xa
7009dc72: e7ff         	b	0x7009dc74 <CSL_bcdmaChanOpCfgChan+0xf4> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009dc74: 9802         	ldr	r0, [sp, #0x8]
7009dc76: 6ac0         	ldr	r0, [r0, #0x2c]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||    /* Split-tx supports 32, and 64-byte bursts */
7009dc78: 2804         	cmp	r0, #0x4
7009dc7a: d304         	blo	0x7009dc86 <CSL_bcdmaChanOpCfgChan+0x106> @ imm = #0x8
7009dc7c: e7ff         	b	0x7009dc7e <CSL_bcdmaChanOpCfgChan+0xfe> @ imm = #-0x2
7009dc7e: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009dc82: 9005         	str	r0, [sp, #0x14]
;                     }
7009dc84: e057         	b	0x7009dd36 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #0xae
;                         regVal = CSL_REG32_RD( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG );
7009dc86: 9809         	ldr	r0, [sp, #0x24]
7009dc88: 68c0         	ldr	r0, [r0, #0xc]
7009dc8a: 9907         	ldr	r1, [sp, #0x1c]
7009dc8c: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dc90: f011 ffb6    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0x11f6c
7009dc94: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009dc96: 9804         	ldr	r0, [sp, #0x10]
7009dc98: f020 4000    	bic	r0, r0, #0x80000000
7009dc9c: 9902         	ldr	r1, [sp, #0x8]
7009dc9e: 6809         	ldr	r1, [r1]
7009dca0: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009dca4: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, pChanCfg->burstSize );
7009dca6: 9804         	ldr	r0, [sp, #0x10]
7009dca8: 9902         	ldr	r1, [sp, #0x8]
7009dcaa: 6c49         	ldr	r1, [r1, #0x44]
7009dcac: f361 208b    	bfi	r0, r1, #10, #2
7009dcb0: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_TDTYPE, pChanCfg->tdType );
7009dcb2: 9804         	ldr	r0, [sp, #0x10]
7009dcb4: 9902         	ldr	r1, [sp, #0x8]
7009dcb6: 6c09         	ldr	r1, [r1, #0x40]
7009dcb8: f361 2049    	bfi	r0, r1, #9, #1
7009dcbc: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_TXCCFG_CHAN_TCFG_NOTDPKT, pChanCfg->bNoTeardownCompletePkt );
7009dcbe: 9804         	ldr	r0, [sp, #0x10]
7009dcc0: f420 7080    	bic	r0, r0, #0x100
7009dcc4: 9902         	ldr	r1, [sp, #0x8]
7009dcc6: f891 103c    	ldrb.w	r1, [r1, #0x3c]
7009dcca: f001 0101    	and	r1, r1, #0x1
7009dcce: ea40 2001    	orr.w	r0, r0, r1, lsl #8
7009dcd2: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, regVal );
7009dcd4: 9809         	ldr	r0, [sp, #0x24]
7009dcd6: 68c0         	ldr	r0, [r0, #0xc]
7009dcd8: 9907         	ldr	r1, [sp, #0x1c]
7009dcda: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dcde: 9904         	ldr	r1, [sp, #0x10]
7009dce0: f7fe fad6    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1a54
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009dce4: 9802         	ldr	r0, [sp, #0x8]
7009dce6: 6a01         	ldr	r1, [r0, #0x20]
;                                  CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009dce8: 6a80         	ldr	r0, [r0, #0x28]
7009dcea: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_TXCCFG_CHAN_TPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009dcee: f361 701e    	bfi	r0, r1, #28, #3
7009dcf2: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TPRI_CTRL, regVal );
7009dcf4: 9809         	ldr	r0, [sp, #0x24]
7009dcf6: 68c0         	ldr	r0, [r0, #0xc]
7009dcf8: 9907         	ldr	r1, [sp, #0x1c]
7009dcfa: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dcfe: 3064         	adds	r0, #0x64
7009dd00: 9904         	ldr	r1, [sp, #0x10]
7009dd02: f7fe fac5    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1a76
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_TXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009dd06: 9809         	ldr	r0, [sp, #0x24]
7009dd08: 68c0         	ldr	r0, [r0, #0xc]
7009dd0a: 9907         	ldr	r1, [sp, #0x1c]
7009dd0c: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dd10: 3068         	adds	r0, #0x68
7009dd12: 9902         	ldr	r1, [sp, #0x8]
7009dd14: f8b1 1048    	ldrh.w	r1, [r1, #0x48]
7009dd18: f7fe faba    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1a8c
;                         CSL_REG32_WR( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TST_SCHED, CSL_FMK(BCDMA_TXCCFG_CHAN_TST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009dd1c: 9809         	ldr	r0, [sp, #0x24]
7009dd1e: 68c0         	ldr	r0, [r0, #0xc]
7009dd20: 9907         	ldr	r1, [sp, #0x1c]
7009dd22: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dd26: 3080         	adds	r0, #0x80
7009dd28: 9902         	ldr	r1, [sp, #0x8]
7009dd2a: 6ac9         	ldr	r1, [r1, #0x2c]
7009dd2c: f001 0103    	and	r1, r1, #0x3
7009dd30: f7fe faae    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1aa4
7009dd34: e7ff         	b	0x7009dd36 <CSL_bcdmaChanOpCfgChan+0x1b6> @ imm = #-0x2
;                 break;
7009dd36: e069         	b	0x7009de0c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0xd2
;                     CSL_BcdmaRxChanCfg *pChanCfg = (CSL_BcdmaRxChanCfg *)pOpData;
7009dd38: 9806         	ldr	r0, [sp, #0x18]
7009dd3a: 9001         	str	r0, [sp, #0x4]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009dd3c: 9801         	ldr	r0, [sp, #0x4]
7009dd3e: 6bc0         	ldr	r0, [r0, #0x3c]
7009dd40: 2801         	cmp	r0, #0x1
7009dd42: d80a         	bhi	0x7009dd5a <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0x14
7009dd44: e7ff         	b	0x7009dd46 <CSL_bcdmaChanOpCfgChan+0x1c6> @ imm = #-0x2
;                         (pChanCfg->busPriority > ((uint32_t)7U) )                     ||
7009dd46: 9801         	ldr	r0, [sp, #0x4]
7009dd48: 6980         	ldr	r0, [r0, #0x18]
7009dd4a: 2807         	cmp	r0, #0x7
7009dd4c: d805         	bhi	0x7009dd5a <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #0xa
7009dd4e: e7ff         	b	0x7009dd50 <CSL_bcdmaChanOpCfgChan+0x1d0> @ imm = #-0x2
;                         (pChanCfg->dmaPriority > ((uint32_t)3U) )
7009dd50: 9801         	ldr	r0, [sp, #0x4]
7009dd52: 6b80         	ldr	r0, [r0, #0x38]
;                     if( (pChanCfg->burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES)    ||     /* Split-rx supports 32, and 64-byte bursts */
7009dd54: 2804         	cmp	r0, #0x4
7009dd56: d304         	blo	0x7009dd62 <CSL_bcdmaChanOpCfgChan+0x1e2> @ imm = #0x8
7009dd58: e7ff         	b	0x7009dd5a <CSL_bcdmaChanOpCfgChan+0x1da> @ imm = #-0x2
7009dd5a: f06f 0002    	mvn	r0, #0x2
;                         retVal = CSL_EINVALID_PARAMS;
7009dd5e: 9005         	str	r0, [sp, #0x14]
;                     }
7009dd60: e04f         	b	0x7009de02 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #0x9e
;                         regVal = CSL_REG32_RD( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG );
7009dd62: 9809         	ldr	r0, [sp, #0x24]
7009dd64: 6940         	ldr	r0, [r0, #0x14]
7009dd66: 9907         	ldr	r1, [sp, #0x1c]
7009dd68: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dd6c: f011 ff48    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0x11e90
7009dd70: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_PAUSE_ON_ERR, pChanCfg->pauseOnError);
7009dd72: 9804         	ldr	r0, [sp, #0x10]
7009dd74: f020 4000    	bic	r0, r0, #0x80000000
7009dd78: 9901         	ldr	r1, [sp, #0x4]
7009dd7a: 6809         	ldr	r1, [r1]
7009dd7c: ea40 70c1    	orr.w	r0, r0, r1, lsl #31
7009dd80: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, pChanCfg->burstSize );
7009dd82: 9804         	ldr	r0, [sp, #0x10]
7009dd84: 9901         	ldr	r1, [sp, #0x4]
7009dd86: 6bc9         	ldr	r1, [r1, #0x3c]
7009dd88: f361 208b    	bfi	r0, r1, #10, #2
7009dd8c: 9004         	str	r0, [sp, #0x10]
;                         CSL_FINS( regVal, BCDMA_RXCCFG_CHAN_RCFG_IGNORE_LONG, pChanCfg->bIgnoreLongPkts ? (uint32_t)1U : (uint32_t)0U );
7009dd8e: 9804         	ldr	r0, [sp, #0x10]
7009dd90: f420 4080    	bic	r0, r0, #0x4000
7009dd94: 9901         	ldr	r1, [sp, #0x4]
7009dd96: f891 1035    	ldrb.w	r1, [r1, #0x35]
7009dd9a: f361 308e    	bfi	r0, r1, #14, #1
7009dd9e: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, regVal );
7009dda0: 9809         	ldr	r0, [sp, #0x24]
7009dda2: 6940         	ldr	r0, [r0, #0x14]
7009dda4: 9907         	ldr	r1, [sp, #0x1c]
7009dda6: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009ddaa: 9904         	ldr	r1, [sp, #0x10]
7009ddac: f7fe fa70    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1b20
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009ddb0: 9801         	ldr	r0, [sp, #0x4]
7009ddb2: 6981         	ldr	r1, [r0, #0x18]
;                                  CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_ORDERID, pChanCfg->busOrderId );
7009ddb4: 6a00         	ldr	r0, [r0, #0x20]
7009ddb6: f000 000f    	and	r0, r0, #0xf
;                         regVal = CSL_FMK( BCDMA_RXCCFG_CHAN_RPRI_CTRL_PRIORITY, pChanCfg->busPriority )    |
7009ddba: f361 701e    	bfi	r0, r1, #28, #3
7009ddbe: 9004         	str	r0, [sp, #0x10]
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RPRI_CTRL, regVal );
7009ddc0: 9809         	ldr	r0, [sp, #0x24]
7009ddc2: 6940         	ldr	r0, [r0, #0x14]
7009ddc4: 9907         	ldr	r1, [sp, #0x1c]
7009ddc6: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009ddca: 3064         	adds	r0, #0x64
7009ddcc: 9904         	ldr	r1, [sp, #0x10]
7009ddce: f7fe fa5f    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1b42
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].THREAD, CSL_FMK(BCDMA_RXCCFG_CHAN_THREAD_ID, pChanCfg->threadId) );
7009ddd2: 9809         	ldr	r0, [sp, #0x24]
7009ddd4: 6940         	ldr	r0, [r0, #0x14]
7009ddd6: 9907         	ldr	r1, [sp, #0x1c]
7009ddd8: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009dddc: 3068         	adds	r0, #0x68
7009ddde: 9901         	ldr	r1, [sp, #0x4]
7009dde0: f8b1 1040    	ldrh.w	r1, [r1, #0x40]
7009dde4: f7fe fa54    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1b58
;                         CSL_REG32_WR( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RST_SCHED, CSL_FMK(BCDMA_RXCCFG_CHAN_RST_SCHED_PRIORITY, pChanCfg->dmaPriority) );
7009dde8: 9809         	ldr	r0, [sp, #0x24]
7009ddea: 6940         	ldr	r0, [r0, #0x14]
7009ddec: 9907         	ldr	r1, [sp, #0x1c]
7009ddee: eb00 2001    	add.w	r0, r0, r1, lsl #8
7009ddf2: 3080         	adds	r0, #0x80
7009ddf4: 9901         	ldr	r1, [sp, #0x4]
7009ddf6: 6b89         	ldr	r1, [r1, #0x38]
7009ddf8: f001 0103    	and	r1, r1, #0x3
7009ddfc: f7fe fa48    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x1b70
7009de00: e7ff         	b	0x7009de02 <CSL_bcdmaChanOpCfgChan+0x282> @ imm = #-0x2
;                 break;
7009de02: e003         	b	0x7009de0c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #0x6
7009de04: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
7009de08: 9005         	str	r0, [sp, #0x14]
;                 break;
7009de0a: e7ff         	b	0x7009de0c <CSL_bcdmaChanOpCfgChan+0x28c> @ imm = #-0x2
7009de0c: e7ff         	b	0x7009de0e <CSL_bcdmaChanOpCfgChan+0x28e> @ imm = #-0x2
;     return retVal;
7009de0e: 9805         	ldr	r0, [sp, #0x14]
7009de10: b00a         	add	sp, #0x28
7009de12: bd80         	pop	{r7, pc}
		...

7009de20 <TimerP_setup>:
; {
7009de20: b510         	push	{r4, lr}
7009de22: b096         	sub	sp, #0x58
7009de24: 9015         	str	r0, [sp, #0x54]
7009de26: 9114         	str	r1, [sp, #0x50]
;     DebugP_assert( baseAddr!=0U);
7009de28: 9815         	ldr	r0, [sp, #0x54]
7009de2a: 2800         	cmp	r0, #0x0
7009de2c: bf18         	it	ne
7009de2e: 2001         	movne	r0, #0x1
7009de30: f242 01e1    	movw	r1, #0x20e1
7009de34: f2c7 010b    	movt	r1, #0x700b
7009de38: 466a         	mov	r2, sp
7009de3a: 6011         	str	r1, [r2]
7009de3c: f641 5185    	movw	r1, #0x1d85
7009de40: f2c7 010b    	movt	r1, #0x700b
7009de44: 9106         	str	r1, [sp, #0x18]
7009de46: f242 02ee    	movw	r2, #0x20ee
7009de4a: f2c7 020b    	movt	r2, #0x700b
7009de4e: 9207         	str	r2, [sp, #0x1c]
7009de50: 2342         	movs	r3, #0x42
7009de52: f00c ff15    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xce2a
7009de56: 9906         	ldr	r1, [sp, #0x18]
7009de58: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputPreScaler != 0U);
7009de5a: 9814         	ldr	r0, [sp, #0x50]
7009de5c: 6800         	ldr	r0, [r0]
7009de5e: 2800         	cmp	r0, #0x0
7009de60: bf18         	it	ne
7009de62: 2001         	movne	r0, #0x1
7009de64: f641 53a3    	movw	r3, #0x1da3
7009de68: f2c7 030b    	movt	r3, #0x700b
7009de6c: 46ec         	mov	r12, sp
7009de6e: f8cc 3000    	str.w	r3, [r12]
7009de72: 2343         	movs	r3, #0x43
7009de74: f00c ff04    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xce08
7009de78: 9906         	ldr	r1, [sp, #0x18]
7009de7a: 9a07         	ldr	r2, [sp, #0x1c]
;     DebugP_assert( params->inputClkHz != 0U);
7009de7c: 9814         	ldr	r0, [sp, #0x50]
7009de7e: 6840         	ldr	r0, [r0, #0x4]
7009de80: 2800         	cmp	r0, #0x0
7009de82: bf18         	it	ne
7009de84: 2001         	movne	r0, #0x1
7009de86: f641 63ba    	movw	r3, #0x1eba
7009de8a: f2c7 030b    	movt	r3, #0x700b
7009de8e: 46ec         	mov	r12, sp
7009de90: f8cc 3000    	str.w	r3, [r12]
7009de94: 2344         	movs	r3, #0x44
7009de96: f00c fef3    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xcde6
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009de9a: 9814         	ldr	r0, [sp, #0x50]
7009de9c: 6881         	ldr	r1, [r0, #0x8]
7009de9e: 2001         	movs	r0, #0x1
7009dea0: 9008         	str	r0, [sp, #0x20]
7009dea2: b939         	cbnz	r1, 0x7009deb4 <TimerP_setup+0x94> @ imm = #0xe
7009dea4: e7ff         	b	0x7009dea6 <TimerP_setup+0x86> @ imm = #-0x2
7009dea6: 9814         	ldr	r0, [sp, #0x50]
7009dea8: 68c0         	ldr	r0, [r0, #0xc]
7009deaa: 2800         	cmp	r0, #0x0
7009deac: bf18         	it	ne
7009deae: 2001         	movne	r0, #0x1
7009deb0: 9008         	str	r0, [sp, #0x20]
7009deb2: e7ff         	b	0x7009deb4 <TimerP_setup+0x94> @ imm = #-0x2
7009deb4: 9808         	ldr	r0, [sp, #0x20]
;     DebugP_assert(( params->periodInUsec != 0U) || (params->periodInNsec != 0U) );
7009deb6: f000 0001    	and	r0, r0, #0x1
7009deba: f641 1170    	movw	r1, #0x1970
7009debe: f2c7 010b    	movt	r1, #0x700b
7009dec2: 466a         	mov	r2, sp
7009dec4: 6011         	str	r1, [r2]
7009dec6: f641 5185    	movw	r1, #0x1d85
7009deca: f2c7 010b    	movt	r1, #0x700b
7009dece: 9103         	str	r1, [sp, #0xc]
7009ded0: f242 02ee    	movw	r2, #0x20ee
7009ded4: f2c7 020b    	movt	r2, #0x700b
7009ded8: 9204         	str	r2, [sp, #0x10]
7009deda: 2345         	movs	r3, #0x45
7009dedc: f00c fed0    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xcda0
7009dee0: 9903         	ldr	r1, [sp, #0xc]
7009dee2: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( params->inputPreScaler <= 256U);
7009dee4: 9814         	ldr	r0, [sp, #0x50]
7009dee6: 6803         	ldr	r3, [r0]
7009dee8: 2000         	movs	r0, #0x0
7009deea: 9005         	str	r0, [sp, #0x14]
7009deec: f5b3 7f80    	cmp.w	r3, #0x100
7009def0: bf98         	it	ls
7009def2: 2001         	movls	r0, #0x1
7009def4: f641 5347    	movw	r3, #0x1d47
7009def8: f2c7 030b    	movt	r3, #0x700b
7009defc: 46ec         	mov	r12, sp
7009defe: f8cc 3000    	str.w	r3, [r12]
7009df02: 2347         	movs	r3, #0x47
7009df04: f00c febc    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xcd78
7009df08: 9903         	ldr	r1, [sp, #0xc]
7009df0a: 9a04         	ldr	r2, [sp, #0x10]
;     DebugP_assert( (params->inputClkHz % params->inputPreScaler) == 0U);
7009df0c: 9814         	ldr	r0, [sp, #0x50]
7009df0e: 6803         	ldr	r3, [r0]
7009df10: f8d0 c004    	ldr.w	r12, [r0, #0x4]
7009df14: fbbc f0f3    	udiv	r0, r12, r3
7009df18: fb00 c013    	mls	r0, r0, r3, r12
7009df1c: fab0 f080    	clz	r0, r0
7009df20: 0940         	lsrs	r0, r0, #0x5
7009df22: f641 2357    	movw	r3, #0x1a57
7009df26: f2c7 030b    	movt	r3, #0x700b
7009df2a: 46ec         	mov	r12, sp
7009df2c: f8cc 3000    	str.w	r3, [r12]
7009df30: 2349         	movs	r3, #0x49
7009df32: f00c fea5    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xcd4a
;     TimerP_stop(baseAddr);
7009df36: 9815         	ldr	r0, [sp, #0x54]
7009df38: f011 fbe2    	bl	0x700af700 <TimerP_stop> @ imm = #0x117c4
;     TimerP_clearOverflowInt(baseAddr);
7009df3c: 9815         	ldr	r0, [sp, #0x54]
7009df3e: f010 fe67    	bl	0x700aec10 <TimerP_clearOverflowInt> @ imm = #0x10cce
7009df42: 9905         	ldr	r1, [sp, #0x14]
;     timeInNsec = (uint64_t)params->periodInNsec;
7009df44: 9814         	ldr	r0, [sp, #0x50]
7009df46: 68c0         	ldr	r0, [r0, #0xc]
7009df48: 910f         	str	r1, [sp, #0x3c]
7009df4a: 900e         	str	r0, [sp, #0x38]
;     if(timeInNsec == 0U)
7009df4c: 980e         	ldr	r0, [sp, #0x38]
7009df4e: 990f         	ldr	r1, [sp, #0x3c]
7009df50: 4308         	orrs	r0, r1
7009df52: b948         	cbnz	r0, 0x7009df68 <TimerP_setup+0x148> @ imm = #0x12
7009df54: e7ff         	b	0x7009df56 <TimerP_setup+0x136> @ imm = #-0x2
;         timeInNsec = (uint64_t)params->periodInUsec*1000U;
7009df56: 9814         	ldr	r0, [sp, #0x50]
7009df58: 6880         	ldr	r0, [r0, #0x8]
7009df5a: f44f 717a    	mov.w	r1, #0x3e8
7009df5e: fba0 0101    	umull	r0, r1, r0, r1
7009df62: 910f         	str	r1, [sp, #0x3c]
7009df64: 900e         	str	r0, [sp, #0x38]
;     }
7009df66: e7ff         	b	0x7009df68 <TimerP_setup+0x148> @ imm = #-0x2
;     inputClkHz = (uint64_t)params->inputClkHz / (uint64_t)params->inputPreScaler;
7009df68: 9814         	ldr	r0, [sp, #0x50]
7009df6a: 6802         	ldr	r2, [r0]
7009df6c: 6840         	ldr	r0, [r0, #0x4]
7009df6e: 2300         	movs	r3, #0x0
7009df70: 9302         	str	r3, [sp, #0x8]
7009df72: 4619         	mov	r1, r3
7009df74: f011 e92e    	blx	0x700af1d4 <__aeabi_uldivmod> @ imm = #0x1125c
7009df78: 9b02         	ldr	r3, [sp, #0x8]
7009df7a: 910d         	str	r1, [sp, #0x34]
7009df7c: 900c         	str	r0, [sp, #0x30]
;     timerCycles =  ( inputClkHz * timeInNsec ) / 1000000000U;
7009df7e: f8dd c030    	ldr.w	r12, [sp, #0x30]
7009df82: 990d         	ldr	r1, [sp, #0x34]
7009df84: 9a0e         	ldr	r2, [sp, #0x38]
7009df86: f8dd e03c    	ldr.w	lr, [sp, #0x3c]
7009df8a: fbac 0402    	umull	r0, r4, r12, r2
7009df8e: fb0c 4c0e    	mla	r12, r12, lr, r4
7009df92: fb01 c102    	mla	r1, r1, r2, r12
7009df96: f64c 2200    	movw	r2, #0xca00
7009df9a: f6c3 329a    	movt	r2, #0x3b9a
7009df9e: f011 e91a    	blx	0x700af1d4 <__aeabi_uldivmod> @ imm = #0x11234
7009dfa2: 4602         	mov	r2, r0
7009dfa4: 9802         	ldr	r0, [sp, #0x8]
7009dfa6: 9201         	str	r2, [sp, #0x4]
7009dfa8: 460a         	mov	r2, r1
7009dfaa: 9901         	ldr	r1, [sp, #0x4]
7009dfac: 920b         	str	r2, [sp, #0x2c]
7009dfae: 910a         	str	r1, [sp, #0x28]
;     DebugP_assert( timerCycles < 0xFFFFFFFFU );
7009dfb0: 9a0a         	ldr	r2, [sp, #0x28]
7009dfb2: 990b         	ldr	r1, [sp, #0x2c]
7009dfb4: f1b2 32ff    	subs.w	r2, r2, #0xffffffff
7009dfb8: f171 0100    	sbcs	r1, r1, #0x0
7009dfbc: bf38         	it	lo
7009dfbe: 2001         	movlo	r0, #0x1
7009dfc0: f641 61a0    	movw	r1, #0x1ea0
7009dfc4: f2c7 010b    	movt	r1, #0x700b
7009dfc8: 466a         	mov	r2, sp
7009dfca: 6011         	str	r1, [r2]
7009dfcc: f641 5185    	movw	r1, #0x1d85
7009dfd0: f2c7 010b    	movt	r1, #0x700b
7009dfd4: f242 02ee    	movw	r2, #0x20ee
7009dfd8: f2c7 020b    	movt	r2, #0x700b
7009dfdc: 2359         	movs	r3, #0x59
7009dfde: f00c fe4f    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xcc9e
7009dfe2: 9802         	ldr	r0, [sp, #0x8]
;     countVal = 0xFFFFFFFFu - (timerCycles - 1U);
7009dfe4: 990a         	ldr	r1, [sp, #0x28]
7009dfe6: 4249         	rsbs	r1, r1, #0
7009dfe8: 9111         	str	r1, [sp, #0x44]
;     reloadVal = 0;
7009dfea: 9010         	str	r0, [sp, #0x40]
;     ctrlVal = 0;
7009dfec: 9012         	str	r0, [sp, #0x48]
;     if(params->inputPreScaler>1U)
7009dfee: 9814         	ldr	r0, [sp, #0x50]
7009dff0: 6800         	ldr	r0, [r0]
7009dff2: 2802         	cmp	r0, #0x2
7009dff4: d320         	blo	0x7009e038 <TimerP_setup+0x218> @ imm = #0x40
7009dff6: e7ff         	b	0x7009dff8 <TimerP_setup+0x1d8> @ imm = #-0x2
7009dff8: 2008         	movs	r0, #0x8
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009dffa: 9009         	str	r0, [sp, #0x24]
7009dffc: e7ff         	b	0x7009dffe <TimerP_setup+0x1de> @ imm = #-0x2
7009dffe: 9809         	ldr	r0, [sp, #0x24]
7009e000: b168         	cbz	r0, 0x7009e01e <TimerP_setup+0x1fe> @ imm = #0x1a
7009e002: e7ff         	b	0x7009e004 <TimerP_setup+0x1e4> @ imm = #-0x2
;             if( (params->inputPreScaler & (0x1U << preScaleVal)) != 0U )
7009e004: 9814         	ldr	r0, [sp, #0x50]
7009e006: 6800         	ldr	r0, [r0]
7009e008: 9909         	ldr	r1, [sp, #0x24]
7009e00a: 40c8         	lsrs	r0, r1
7009e00c: 07c0         	lsls	r0, r0, #0x1f
7009e00e: b108         	cbz	r0, 0x7009e014 <TimerP_setup+0x1f4> @ imm = #0x2
7009e010: e7ff         	b	0x7009e012 <TimerP_setup+0x1f2> @ imm = #-0x2
;                 break;
7009e012: e004         	b	0x7009e01e <TimerP_setup+0x1fe> @ imm = #0x8
;         }
7009e014: e7ff         	b	0x7009e016 <TimerP_setup+0x1f6> @ imm = #-0x2
;         for(preScaleVal=8U; preScaleVal>=1U; preScaleVal--)
7009e016: 9809         	ldr	r0, [sp, #0x24]
7009e018: 3801         	subs	r0, #0x1
7009e01a: 9009         	str	r0, [sp, #0x24]
7009e01c: e7ef         	b	0x7009dffe <TimerP_setup+0x1de> @ imm = #-0x22
;         ctrlVal |= (0x1U << 5);
7009e01e: 9812         	ldr	r0, [sp, #0x48]
7009e020: f040 0020    	orr	r0, r0, #0x20
7009e024: 9012         	str	r0, [sp, #0x48]
;         ctrlVal |= ( ((preScaleVal - 1U) & 0x7U) << 2);
7009e026: 9809         	ldr	r0, [sp, #0x24]
7009e028: 3801         	subs	r0, #0x1
7009e02a: f000 0107    	and	r1, r0, #0x7
7009e02e: 9812         	ldr	r0, [sp, #0x48]
7009e030: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009e034: 9012         	str	r0, [sp, #0x48]
;     }
7009e036: e7ff         	b	0x7009e038 <TimerP_setup+0x218> @ imm = #-0x2
;     if(params->oneshotMode==0U)
7009e038: 9814         	ldr	r0, [sp, #0x50]
7009e03a: 6900         	ldr	r0, [r0, #0x10]
7009e03c: b938         	cbnz	r0, 0x7009e04e <TimerP_setup+0x22e> @ imm = #0xe
7009e03e: e7ff         	b	0x7009e040 <TimerP_setup+0x220> @ imm = #-0x2
;         ctrlVal |= (0x1U << 1);
7009e040: 9812         	ldr	r0, [sp, #0x48]
7009e042: f040 0002    	orr	r0, r0, #0x2
7009e046: 9012         	str	r0, [sp, #0x48]
;         reloadVal = countVal;
7009e048: 9811         	ldr	r0, [sp, #0x44]
7009e04a: 9010         	str	r0, [sp, #0x40]
;     }
7009e04c: e7ff         	b	0x7009e04e <TimerP_setup+0x22e> @ imm = #-0x2
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
7009e04e: 9815         	ldr	r0, [sp, #0x54]
7009e050: 3038         	adds	r0, #0x38
7009e052: 9013         	str	r0, [sp, #0x4c]
;     *addr = ctrlVal;
7009e054: 9812         	ldr	r0, [sp, #0x48]
7009e056: 9913         	ldr	r1, [sp, #0x4c]
7009e058: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
7009e05a: 9815         	ldr	r0, [sp, #0x54]
7009e05c: 303c         	adds	r0, #0x3c
7009e05e: 9013         	str	r0, [sp, #0x4c]
;     *addr = countVal;
7009e060: 9811         	ldr	r0, [sp, #0x44]
7009e062: 9913         	ldr	r1, [sp, #0x4c]
7009e064: 6008         	str	r0, [r1]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
7009e066: 9815         	ldr	r0, [sp, #0x54]
7009e068: 3040         	adds	r0, #0x40
7009e06a: 9013         	str	r0, [sp, #0x4c]
;     *addr = reloadVal;
7009e06c: 9810         	ldr	r0, [sp, #0x40]
7009e06e: 9913         	ldr	r1, [sp, #0x4c]
7009e070: 6008         	str	r0, [r1]
;     if((params->enableOverflowInt) != 0U)
7009e072: 9814         	ldr	r0, [sp, #0x50]
7009e074: 6940         	ldr	r0, [r0, #0x14]
7009e076: b138         	cbz	r0, 0x7009e088 <TimerP_setup+0x268> @ imm = #0xe
7009e078: e7ff         	b	0x7009e07a <TimerP_setup+0x25a> @ imm = #-0x2
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_ENABLE);
7009e07a: 9815         	ldr	r0, [sp, #0x54]
7009e07c: 302c         	adds	r0, #0x2c
7009e07e: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009e080: 9913         	ldr	r1, [sp, #0x4c]
7009e082: 2002         	movs	r0, #0x2
7009e084: 6008         	str	r0, [r1]
;     }
7009e086: e006         	b	0x7009e096 <TimerP_setup+0x276> @ imm = #0xc
;         addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_INT_DISABLE);
7009e088: 9815         	ldr	r0, [sp, #0x54]
7009e08a: 3030         	adds	r0, #0x30
7009e08c: 9013         	str	r0, [sp, #0x4c]
;         *addr = (0x1U << TIMER_OVF_INT_SHIFT);
7009e08e: 9913         	ldr	r1, [sp, #0x4c]
7009e090: 2002         	movs	r0, #0x2
7009e092: 6008         	str	r0, [r1]
7009e094: e7ff         	b	0x7009e096 <TimerP_setup+0x276> @ imm = #-0x2
; }
7009e096: b016         	add	sp, #0x58
7009e098: bd10         	pop	{r4, pc}
7009e09a: 0000         	movs	r0, r0
7009e09c: 0000         	movs	r0, r0
7009e09e: 0000         	movs	r0, r0

7009e0a0 <Udma_chConfigRx>:
; {
7009e0a0: b580         	push	{r7, lr}
7009e0a2: b09c         	sub	sp, #0x70
7009e0a4: 901b         	str	r0, [sp, #0x6c]
7009e0a6: 911a         	str	r1, [sp, #0x68]
7009e0a8: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009e0aa: 9019         	str	r0, [sp, #0x64]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
7009e0ac: 981b         	ldr	r0, [sp, #0x6c]
7009e0ae: 9017         	str	r0, [sp, #0x5c]
;     if((NULL_PTR == chHandleInt) ||
7009e0b0: 9817         	ldr	r0, [sp, #0x5c]
7009e0b2: b188         	cbz	r0, 0x7009e0d8 <Udma_chConfigRx+0x38> @ imm = #0x22
7009e0b4: e7ff         	b	0x7009e0b6 <Udma_chConfigRx+0x16> @ imm = #-0x2
;         (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
7009e0b6: 9817         	ldr	r0, [sp, #0x5c]
7009e0b8: f8d0 0244    	ldr.w	r0, [r0, #0x244]
7009e0bc: f64a 31cd    	movw	r1, #0xabcd
7009e0c0: f6ca 31dc    	movt	r1, #0xabdc
7009e0c4: 4288         	cmp	r0, r1
7009e0c6: d107         	bne	0x7009e0d8 <Udma_chConfigRx+0x38> @ imm = #0xe
7009e0c8: e7ff         	b	0x7009e0ca <Udma_chConfigRx+0x2a> @ imm = #-0x2
;         ((chHandleInt->chType & UDMA_CH_FLAG_RX) != UDMA_CH_FLAG_RX))
7009e0ca: 9817         	ldr	r0, [sp, #0x5c]
7009e0cc: 6800         	ldr	r0, [r0]
7009e0ce: f000 0002    	and	r0, r0, #0x2
;     if((NULL_PTR == chHandleInt) ||
7009e0d2: 2802         	cmp	r0, #0x2
7009e0d4: d004         	beq	0x7009e0e0 <Udma_chConfigRx+0x40> @ imm = #0x8
7009e0d6: e7ff         	b	0x7009e0d8 <Udma_chConfigRx+0x38> @ imm = #-0x2
7009e0d8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009e0dc: 9019         	str	r0, [sp, #0x64]
;     }
7009e0de: e7ff         	b	0x7009e0e0 <Udma_chConfigRx+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e0e0: 9819         	ldr	r0, [sp, #0x64]
7009e0e2: b9a8         	cbnz	r0, 0x7009e110 <Udma_chConfigRx+0x70> @ imm = #0x2a
7009e0e4: e7ff         	b	0x7009e0e6 <Udma_chConfigRx+0x46> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
7009e0e6: 9817         	ldr	r0, [sp, #0x5c]
7009e0e8: 6e80         	ldr	r0, [r0, #0x68]
7009e0ea: 9018         	str	r0, [sp, #0x60]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009e0ec: 9818         	ldr	r0, [sp, #0x60]
7009e0ee: b150         	cbz	r0, 0x7009e106 <Udma_chConfigRx+0x66> @ imm = #0x14
7009e0f0: e7ff         	b	0x7009e0f2 <Udma_chConfigRx+0x52> @ imm = #-0x2
7009e0f2: 9818         	ldr	r0, [sp, #0x60]
7009e0f4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009e0f8: f64a 31cd    	movw	r1, #0xabcd
7009e0fc: f6ca 31dc    	movt	r1, #0xabdc
7009e100: 4288         	cmp	r0, r1
7009e102: d004         	beq	0x7009e10e <Udma_chConfigRx+0x6e> @ imm = #0x8
7009e104: e7ff         	b	0x7009e106 <Udma_chConfigRx+0x66> @ imm = #-0x2
7009e106: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009e10a: 9019         	str	r0, [sp, #0x64]
;         }
7009e10c: e7ff         	b	0x7009e10e <Udma_chConfigRx+0x6e> @ imm = #-0x2
;     }
7009e10e: e7ff         	b	0x7009e110 <Udma_chConfigRx+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009e110: 9819         	ldr	r0, [sp, #0x64]
7009e112: 2800         	cmp	r0, #0x0
7009e114: f040 80f1    	bne.w	0x7009e2fa <Udma_chConfigRx+0x25a> @ imm = #0x1e2
7009e118: e7ff         	b	0x7009e11a <Udma_chConfigRx+0x7a> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009e11a: 9818         	ldr	r0, [sp, #0x60]
7009e11c: 6800         	ldr	r0, [r0]
7009e11e: 2801         	cmp	r0, #0x1
7009e120: d107         	bne	0x7009e132 <Udma_chConfigRx+0x92> @ imm = #0xe
7009e122: e7ff         	b	0x7009e124 <Udma_chConfigRx+0x84> @ imm = #-0x2
;             ((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
7009e124: 9817         	ldr	r0, [sp, #0x5c]
;         if ((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
7009e126: 7800         	ldrb	r0, [r0]
7009e128: 0740         	lsls	r0, r0, #0x1d
7009e12a: 2800         	cmp	r0, #0x0
7009e12c: d501         	bpl	0x7009e132 <Udma_chConfigRx+0x92> @ imm = #0x2
7009e12e: e7ff         	b	0x7009e130 <Udma_chConfigRx+0x90> @ imm = #-0x2
;         }
7009e130: e0e2         	b	0x7009e2f8 <Udma_chConfigRx+0x258> @ imm = #0x1c4
7009e132: f645 70ff    	movw	r0, #0x5fff
;             rmUdmaRxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
7009e136: 9010         	str	r0, [sp, #0x40]
;             rmUdmaRxReq.nav_id              = drvHandle->devIdUdma;
7009e138: 9818         	ldr	r0, [sp, #0x60]
7009e13a: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009e13e: f8ad 0044    	strh.w	r0, [sp, #0x44]
;             rmUdmaRxReq.index               = (uint16_t)chHandleInt->rxChNum;
7009e142: 9817         	ldr	r0, [sp, #0x5c]
7009e144: 6f00         	ldr	r0, [r0, #0x70]
7009e146: f8ad 0046    	strh.w	r0, [sp, #0x46]
;             rmUdmaRxReq.rx_pause_on_err     = rxPrms->pauseOnError;
7009e14a: 981a         	ldr	r0, [sp, #0x68]
7009e14c: 7800         	ldrb	r0, [r0]
7009e14e: f88d 0054    	strb.w	r0, [sp, #0x54]
;             rmUdmaRxReq.rx_atype            = rxPrms->addrType;
7009e152: 981a         	ldr	r0, [sp, #0x68]
7009e154: 7840         	ldrb	r0, [r0, #0x1]
7009e156: f88d 0055    	strb.w	r0, [sp, #0x55]
;             rmUdmaRxReq.rx_chan_type        = rxPrms->chanType;
7009e15a: 981a         	ldr	r0, [sp, #0x68]
7009e15c: 7880         	ldrb	r0, [r0, #0x2]
7009e15e: f88d 0056    	strb.w	r0, [sp, #0x56]
;             rmUdmaRxReq.rx_fetch_size       = rxPrms->fetchWordSize;
7009e162: 981a         	ldr	r0, [sp, #0x68]
7009e164: 8880         	ldrh	r0, [r0, #0x4]
7009e166: f8ad 0048    	strh.w	r0, [sp, #0x48]
;             rmUdmaRxReq.rx_priority         = rxPrms->busPriority;
7009e16a: 981a         	ldr	r0, [sp, #0x68]
7009e16c: 7980         	ldrb	r0, [r0, #0x6]
7009e16e: f88d 004c    	strb.w	r0, [sp, #0x4c]
;             rmUdmaRxReq.rx_qos              = rxPrms->busQos;
7009e172: 981a         	ldr	r0, [sp, #0x68]
7009e174: 79c0         	ldrb	r0, [r0, #0x7]
7009e176: f88d 004d    	strb.w	r0, [sp, #0x4d]
;             rmUdmaRxReq.rx_orderid          = rxPrms->busOrderId;
7009e17a: 981a         	ldr	r0, [sp, #0x68]
7009e17c: 7a00         	ldrb	r0, [r0, #0x8]
7009e17e: f88d 004e    	strb.w	r0, [sp, #0x4e]
;             rmUdmaRxReq.rx_sched_priority   = rxPrms->dmaPriority;
7009e182: 981a         	ldr	r0, [sp, #0x68]
7009e184: 7a40         	ldrb	r0, [r0, #0x9]
7009e186: f88d 004f    	strb.w	r0, [sp, #0x4f]
;             rmUdmaRxReq.flowid_start        = rxPrms->flowIdFwRangeStart;
7009e18a: 981a         	ldr	r0, [sp, #0x68]
7009e18c: 8940         	ldrh	r0, [r0, #0xa]
7009e18e: f8ad 0050    	strh.w	r0, [sp, #0x50]
;             rmUdmaRxReq.flowid_cnt          = rxPrms->flowIdFwRangeCnt;
7009e192: 981a         	ldr	r0, [sp, #0x68]
7009e194: 8980         	ldrh	r0, [r0, #0xc]
7009e196: f8ad 0052    	strh.w	r0, [sp, #0x52]
;             rmUdmaRxReq.rx_ignore_short     = rxPrms->ignoreShortPkts;
7009e19a: 981a         	ldr	r0, [sp, #0x68]
7009e19c: 7c80         	ldrb	r0, [r0, #0x12]
7009e19e: f88d 0057    	strb.w	r0, [sp, #0x57]
;             rmUdmaRxReq.rx_ignore_long      = rxPrms->ignoreLongPkts;
7009e1a2: 981a         	ldr	r0, [sp, #0x68]
7009e1a4: 7cc0         	ldrb	r0, [r0, #0x13]
7009e1a6: f88d 0058    	strb.w	r0, [sp, #0x58]
;             rmUdmaRxReq.rx_burst_size       = rxPrms->burstSize;
7009e1aa: 981a         	ldr	r0, [sp, #0x68]
7009e1ac: 7e00         	ldrb	r0, [r0, #0x18]
7009e1ae: f88d 0059    	strb.w	r0, [sp, #0x59]
;             if(NULL_PTR != chHandleInt->tdCqRing)
7009e1b2: 9817         	ldr	r0, [sp, #0x5c]
7009e1b4: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009e1b8: b138         	cbz	r0, 0x7009e1ca <Udma_chConfigRx+0x12a> @ imm = #0xe
7009e1ba: e7ff         	b	0x7009e1bc <Udma_chConfigRx+0x11c> @ imm = #-0x2
;                 rmUdmaRxReq.rxcq_qnum          = chHandleInt->tdCqRing->ringNum;
7009e1bc: 9817         	ldr	r0, [sp, #0x5c]
7009e1be: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009e1c2: 8880         	ldrh	r0, [r0, #0x4]
7009e1c4: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;             }
7009e1c8: e004         	b	0x7009e1d4 <Udma_chConfigRx+0x134> @ imm = #0x8
7009e1ca: f64f 70ff    	movw	r0, #0xffff
;                 rmUdmaRxReq.rxcq_qnum          = UDMA_RING_INVALID;
7009e1ce: f8ad 004a    	strh.w	r0, [sp, #0x4a]
7009e1d2: e7ff         	b	0x7009e1d4 <Udma_chConfigRx+0x134> @ imm = #-0x2
7009e1d4: a80e         	add	r0, sp, #0x38
7009e1d6: a90c         	add	r1, sp, #0x30
7009e1d8: f04f 32ff    	mov.w	r2, #0xffffffff
;             retVal = Sciclient_rmUdmapRxChCfg(
7009e1dc: f00e fc20    	bl	0x700aca20 <Sciclient_rmUdmapRxChCfg> @ imm = #0xe840
7009e1e0: 9019         	str	r0, [sp, #0x64]
;             if(CSL_PASS != retVal)
7009e1e2: 9819         	ldr	r0, [sp, #0x64]
7009e1e4: b108         	cbz	r0, 0x7009e1ea <Udma_chConfigRx+0x14a> @ imm = #0x2
7009e1e6: e7ff         	b	0x7009e1e8 <Udma_chConfigRx+0x148> @ imm = #-0x2
;             }
7009e1e8: e7ff         	b	0x7009e1ea <Udma_chConfigRx+0x14a> @ imm = #-0x2
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009e1ea: 9817         	ldr	r0, [sp, #0x5c]
7009e1ec: 6800         	ldr	r0, [r0]
7009e1ee: f000 0008    	and	r0, r0, #0x8
7009e1f2: 2808         	cmp	r0, #0x8
7009e1f4: d006         	beq	0x7009e204 <Udma_chConfigRx+0x164> @ imm = #0xc
7009e1f6: e7ff         	b	0x7009e1f8 <Udma_chConfigRx+0x158> @ imm = #-0x2
;                     ((chHandleInt->chType & UDMA_CH_FLAG_PSIL) == UDMA_CH_FLAG_PSIL)) &&
7009e1f8: 9817         	ldr	r0, [sp, #0x5c]
7009e1fa: 7800         	ldrb	r0, [r0]
7009e1fc: 06c0         	lsls	r0, r0, #0x1b
7009e1fe: 2800         	cmp	r0, #0x0
7009e200: d569         	bpl	0x7009e2d6 <Udma_chConfigRx+0x236> @ imm = #0xd2
7009e202: e7ff         	b	0x7009e204 <Udma_chConfigRx+0x164> @ imm = #-0x2
;                (TRUE == rxPrms->configDefaultFlow))
7009e204: 981a         	ldr	r0, [sp, #0x68]
7009e206: 6940         	ldr	r0, [r0, #0x14]
;             if((((chHandleInt->chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA) ||
7009e208: 2801         	cmp	r0, #0x1
7009e20a: d164         	bne	0x7009e2d6 <Udma_chConfigRx+0x236> @ imm = #0xc8
7009e20c: e7ff         	b	0x7009e20e <Udma_chConfigRx+0x16e> @ imm = #-0x2
;                 UdmaFlowPrms_init(&flowPrms, chHandleInt->chType);
7009e20e: 9817         	ldr	r0, [sp, #0x5c]
7009e210: 6801         	ldr	r1, [r0]
7009e212: a801         	add	r0, sp, #0x4
7009e214: f00b fb4c    	bl	0x700a98b0 <UdmaFlowPrms_init> @ imm = #0xb698
;                 flowPrms.psInfoPresent = rxPrms->flowPsInfoPresent;
7009e218: 981a         	ldr	r0, [sp, #0x68]
7009e21a: 7bc0         	ldrb	r0, [r0, #0xf]
7009e21c: f88d 0009    	strb.w	r0, [sp, #0x9]
;                 flowPrms.einfoPresent  = rxPrms->flowEInfoPresent;
7009e220: 981a         	ldr	r0, [sp, #0x68]
7009e222: 7b80         	ldrb	r0, [r0, #0xe]
7009e224: f88d 0008    	strb.w	r0, [sp, #0x8]
;                 flowPrms.errorHandling = rxPrms->flowErrorHandling;
7009e228: 981a         	ldr	r0, [sp, #0x68]
7009e22a: 7c00         	ldrb	r0, [r0, #0x10]
7009e22c: f88d 000a    	strb.w	r0, [sp, #0xa]
;                 flowPrms.sopOffset     = rxPrms->flowSopOffset;
7009e230: 981a         	ldr	r0, [sp, #0x68]
7009e232: 7c40         	ldrb	r0, [r0, #0x11]
7009e234: f8ad 000e    	strh.w	r0, [sp, #0xe]
;                 if(NULL_PTR == chHandleInt->cqRing)
7009e238: 9817         	ldr	r0, [sp, #0x5c]
7009e23a: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009e23e: b928         	cbnz	r0, 0x7009e24c <Udma_chConfigRx+0x1ac> @ imm = #0xa
7009e240: e7ff         	b	0x7009e242 <Udma_chConfigRx+0x1a2> @ imm = #-0x2
7009e242: f64f 70ff    	movw	r0, #0xffff
;                     cqRing = UDMA_RING_INVALID;
7009e246: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 }
7009e24a: e006         	b	0x7009e25a <Udma_chConfigRx+0x1ba> @ imm = #0xc
;                     cqRing = chHandleInt->cqRing->ringNum;
7009e24c: 9817         	ldr	r0, [sp, #0x5c]
7009e24e: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009e252: 8880         	ldrh	r0, [r0, #0x4]
7009e254: f8ad 0002    	strh.w	r0, [sp, #0x2]
7009e258: e7ff         	b	0x7009e25a <Udma_chConfigRx+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == chHandleInt->fqRing)
7009e25a: 9817         	ldr	r0, [sp, #0x5c]
7009e25c: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009e260: b928         	cbnz	r0, 0x7009e26e <Udma_chConfigRx+0x1ce> @ imm = #0xa
7009e262: e7ff         	b	0x7009e264 <Udma_chConfigRx+0x1c4> @ imm = #-0x2
7009e264: f64f 70ff    	movw	r0, #0xffff
;                     fqRing = UDMA_RING_INVALID;
7009e268: f8ad 0000    	strh.w	r0, [sp]
;                 }
7009e26c: e006         	b	0x7009e27c <Udma_chConfigRx+0x1dc> @ imm = #0xc
;                     fqRing = chHandleInt->fqRing->ringNum;
7009e26e: 9817         	ldr	r0, [sp, #0x5c]
7009e270: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009e274: 8880         	ldrh	r0, [r0, #0x4]
7009e276: f8ad 0000    	strh.w	r0, [sp]
7009e27a: e7ff         	b	0x7009e27c <Udma_chConfigRx+0x1dc> @ imm = #-0x2
;                 flowPrms.defaultRxCQ    = cqRing;
7009e27c: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
7009e280: f8ad 0010    	strh.w	r0, [sp, #0x10]
;                 flowPrms.fdq0Sz0Qnum    = fqRing;
7009e284: f8bd 0000    	ldrh.w	r0, [sp]
7009e288: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 flowPrms.fdq0Sz1Qnum    = fqRing;
7009e28c: f8bd 0000    	ldrh.w	r0, [sp]
7009e290: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;                 flowPrms.fdq0Sz2Qnum    = fqRing;
7009e294: f8bd 0000    	ldrh.w	r0, [sp]
7009e298: f8ad 002c    	strh.w	r0, [sp, #0x2c]
;                 flowPrms.fdq0Sz3Qnum    = fqRing;
7009e29c: f8bd 0000    	ldrh.w	r0, [sp]
7009e2a0: f8ad 002e    	strh.w	r0, [sp, #0x2e]
;                 flowPrms.fdq1Qnum       = fqRing;
7009e2a4: f8bd 0000    	ldrh.w	r0, [sp]
7009e2a8: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;                 flowPrms.fdq2Qnum       = fqRing;
7009e2ac: f8bd 0000    	ldrh.w	r0, [sp]
7009e2b0: f8ad 0020    	strh.w	r0, [sp, #0x20]
;                 flowPrms.fdq3Qnum       = fqRing;
7009e2b4: f8bd 0000    	ldrh.w	r0, [sp]
7009e2b8: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                 retVal = Udma_flowConfig(chHandleInt->defaultFlow, 0U, &flowPrms);
7009e2bc: 9817         	ldr	r0, [sp, #0x5c]
7009e2be: f8d0 01c8    	ldr.w	r0, [r0, #0x1c8]
7009e2c2: 2100         	movs	r1, #0x0
7009e2c4: aa01         	add	r2, sp, #0x4
7009e2c6: f001 f9eb    	bl	0x7009f6a0 <Udma_flowConfig> @ imm = #0x13d6
7009e2ca: 9019         	str	r0, [sp, #0x64]
;                 if(UDMA_SOK != retVal)
7009e2cc: 9819         	ldr	r0, [sp, #0x64]
7009e2ce: b108         	cbz	r0, 0x7009e2d4 <Udma_chConfigRx+0x234> @ imm = #0x2
7009e2d0: e7ff         	b	0x7009e2d2 <Udma_chConfigRx+0x232> @ imm = #-0x2
;                 }
7009e2d2: e7ff         	b	0x7009e2d4 <Udma_chConfigRx+0x234> @ imm = #-0x2
;             }
7009e2d4: e7ff         	b	0x7009e2d6 <Udma_chConfigRx+0x236> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009e2d6: 9819         	ldr	r0, [sp, #0x64]
7009e2d8: b968         	cbnz	r0, 0x7009e2f6 <Udma_chConfigRx+0x256> @ imm = #0x1a
7009e2da: e7ff         	b	0x7009e2dc <Udma_chConfigRx+0x23c> @ imm = #-0x2
;                 (void) memcpy(&chHandleInt->rxPrms, rxPrms, sizeof(chHandleInt->rxPrms));
7009e2dc: 9817         	ldr	r0, [sp, #0x5c]
7009e2de: f500 70fc    	add.w	r0, r0, #0x1f8
7009e2e2: 991a         	ldr	r1, [sp, #0x68]
7009e2e4: e8b1 100c    	ldm.w	r1!, {r2, r3, r12}
7009e2e8: e8a0 100c    	stm.w	r0!, {r2, r3, r12}
7009e2ec: e891 500c    	ldm.w	r1, {r2, r3, r12, lr}
7009e2f0: e880 500c    	stm.w	r0, {r2, r3, r12, lr}
;             }
7009e2f4: e7ff         	b	0x7009e2f6 <Udma_chConfigRx+0x256> @ imm = #-0x2
7009e2f6: e7ff         	b	0x7009e2f8 <Udma_chConfigRx+0x258> @ imm = #-0x2
;     }
7009e2f8: e7ff         	b	0x7009e2fa <Udma_chConfigRx+0x25a> @ imm = #-0x2
;     return (retVal);
7009e2fa: 9819         	ldr	r0, [sp, #0x64]
7009e2fc: b01c         	add	sp, #0x70
7009e2fe: bd80         	pop	{r7, pc}

7009e300 <tm_message_isr_to_task_initialize>:
; {
7009e300: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
7009e304: b081         	sub	sp, #0x4
;    tm_setup_pmu();
7009e306: f011 fbc3    	bl	0x700afa90 <tm_setup_pmu> @ imm = #0x11786
;    tm_queue_create(0);
7009e30a: 2000         	movs	r0, #0x0
7009e30c: f04f 0a00    	mov.w	r10, #0x0
7009e310: f010 ff8e    	bl	0x700af230 <tm_queue_create> @ imm = #0x10f1c
7009e314: f242 680b    	movw	r8, #0x260b
7009e318: f244 7b78    	movw	r11, #0x4778
7009e31c: f242 6905    	movw	r9, #0x2605
7009e320: f2c7 080b    	movt	r8, #0x700b
7009e324: f2c7 0b08    	movt	r11, #0x7008
7009e328: f2c7 090b    	movt	r9, #0x700b
7009e32c: 2600         	movs	r6, #0x0
7009e32e: bf00         	nop
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e330: f644 1078    	movw	r0, #0x4978
7009e334: 4642         	mov	r2, r8
7009e336: f2c7 0008    	movt	r0, #0x7008
7009e33a: 4633         	mov	r3, r6
7009e33c: f04f 0110    	mov.w	r1, #0x10
7009e340: eb00 040a    	add.w	r4, r0, r10
7009e344: 4620         	mov	r0, r4
7009e346: f00c ed5a    	blx	0x700aadfc <snprintf>   @ imm = #0xcab4
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e34a: eb0b 070a    	add.w	r7, r11, r10
7009e34e: 464a         	mov	r2, r9
7009e350: 4633         	mov	r3, r6
7009e352: 2110         	movs	r1, #0x10
7009e354: 4638         	mov	r0, r7
7009e356: f00c ed52    	blx	0x700aadfc <snprintf>   @ imm = #0xcaa4
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e35a: 1c75         	adds	r5, r6, #0x1
7009e35c: f104 0010    	add.w	r0, r4, #0x10
7009e360: 4642         	mov	r2, r8
7009e362: 2110         	movs	r1, #0x10
7009e364: 462b         	mov	r3, r5
7009e366: f00c ed4a    	blx	0x700aadfc <snprintf>   @ imm = #0xca94
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e36a: f107 0010    	add.w	r0, r7, #0x10
7009e36e: 464a         	mov	r2, r9
7009e370: 462b         	mov	r3, r5
7009e372: 2110         	movs	r1, #0x10
7009e374: f00c ed42    	blx	0x700aadfc <snprintf>   @ imm = #0xca84
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e378: 1cb5         	adds	r5, r6, #0x2
7009e37a: f104 0020    	add.w	r0, r4, #0x20
7009e37e: 4642         	mov	r2, r8
7009e380: 2110         	movs	r1, #0x10
7009e382: 462b         	mov	r3, r5
7009e384: f00c ed3a    	blx	0x700aadfc <snprintf>   @ imm = #0xca74
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e388: f107 0020    	add.w	r0, r7, #0x20
7009e38c: 464a         	mov	r2, r9
7009e38e: 462b         	mov	r3, r5
7009e390: 2110         	movs	r1, #0x10
7009e392: f00c ed34    	blx	0x700aadfc <snprintf>   @ imm = #0xca68
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e396: 1cf5         	adds	r5, r6, #0x3
7009e398: f104 0030    	add.w	r0, r4, #0x30
7009e39c: 4642         	mov	r2, r8
7009e39e: 2110         	movs	r1, #0x10
7009e3a0: 462b         	mov	r3, r5
7009e3a2: f00c ed2c    	blx	0x700aadfc <snprintf>   @ imm = #0xca58
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e3a6: f107 0030    	add.w	r0, r7, #0x30
7009e3aa: 464a         	mov	r2, r9
7009e3ac: 462b         	mov	r3, r5
7009e3ae: 2110         	movs	r1, #0x10
7009e3b0: f00c ed24    	blx	0x700aadfc <snprintf>   @ imm = #0xca48
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e3b4: 1d35         	adds	r5, r6, #0x4
7009e3b6: f104 0040    	add.w	r0, r4, #0x40
7009e3ba: 4642         	mov	r2, r8
7009e3bc: 2110         	movs	r1, #0x10
7009e3be: 462b         	mov	r3, r5
7009e3c0: f00c ed1c    	blx	0x700aadfc <snprintf>   @ imm = #0xca38
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e3c4: f107 0040    	add.w	r0, r7, #0x40
7009e3c8: 464a         	mov	r2, r9
7009e3ca: 462b         	mov	r3, r5
7009e3cc: 2110         	movs	r1, #0x10
7009e3ce: f00c ed16    	blx	0x700aadfc <snprintf>   @ imm = #0xca2c
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e3d2: 1d75         	adds	r5, r6, #0x5
7009e3d4: f104 0050    	add.w	r0, r4, #0x50
7009e3d8: 4642         	mov	r2, r8
7009e3da: 2110         	movs	r1, #0x10
7009e3dc: 462b         	mov	r3, r5
7009e3de: f00c ed0e    	blx	0x700aadfc <snprintf>   @ imm = #0xca1c
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e3e2: f107 0050    	add.w	r0, r7, #0x50
7009e3e6: 464a         	mov	r2, r9
7009e3e8: 462b         	mov	r3, r5
7009e3ea: 2110         	movs	r1, #0x10
7009e3ec: f00c ed06    	blx	0x700aadfc <snprintf>   @ imm = #0xca0c
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e3f0: 1db5         	adds	r5, r6, #0x6
7009e3f2: f104 0060    	add.w	r0, r4, #0x60
7009e3f6: 4642         	mov	r2, r8
7009e3f8: 2110         	movs	r1, #0x10
7009e3fa: 462b         	mov	r3, r5
7009e3fc: f00c ecfe    	blx	0x700aadfc <snprintf>   @ imm = #0xc9fc
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e400: f107 0060    	add.w	r0, r7, #0x60
7009e404: 464a         	mov	r2, r9
7009e406: 462b         	mov	r3, r5
7009e408: 2110         	movs	r1, #0x10
7009e40a: f00c ecf8    	blx	0x700aadfc <snprintf>   @ imm = #0xc9f0
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e40e: 1df5         	adds	r5, r6, #0x7
7009e410: f104 0070    	add.w	r0, r4, #0x70
7009e414: 4642         	mov	r2, r8
7009e416: 2110         	movs	r1, #0x10
7009e418: 462b         	mov	r3, r5
7009e41a: f00c ecf0    	blx	0x700aadfc <snprintf>   @ imm = #0xc9e0
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e41e: f107 0070    	add.w	r0, r7, #0x70
7009e422: 464a         	mov	r2, r9
7009e424: 462b         	mov	r3, r5
7009e426: 2110         	movs	r1, #0x10
7009e428: f00c ece8    	blx	0x700aadfc <snprintf>   @ imm = #0xc9d0
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e42c: f106 0508    	add.w	r5, r6, #0x8
7009e430: f104 0080    	add.w	r0, r4, #0x80
7009e434: 4642         	mov	r2, r8
7009e436: 2110         	movs	r1, #0x10
7009e438: 462b         	mov	r3, r5
7009e43a: f00c ece0    	blx	0x700aadfc <snprintf>   @ imm = #0xc9c0
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e43e: f107 0080    	add.w	r0, r7, #0x80
7009e442: 464a         	mov	r2, r9
7009e444: 462b         	mov	r3, r5
7009e446: 2110         	movs	r1, #0x10
7009e448: f00c ecd8    	blx	0x700aadfc <snprintf>   @ imm = #0xc9b0
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e44c: f106 0509    	add.w	r5, r6, #0x9
7009e450: f104 0090    	add.w	r0, r4, #0x90
7009e454: 4642         	mov	r2, r8
7009e456: 2110         	movs	r1, #0x10
7009e458: 462b         	mov	r3, r5
7009e45a: f00c ecd0    	blx	0x700aadfc <snprintf>   @ imm = #0xc9a0
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e45e: f107 0090    	add.w	r0, r7, #0x90
7009e462: 464a         	mov	r2, r9
7009e464: 462b         	mov	r3, r5
7009e466: 2110         	movs	r1, #0x10
7009e468: f00c ecc8    	blx	0x700aadfc <snprintf>   @ imm = #0xc990
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e46c: f106 050a    	add.w	r5, r6, #0xa
7009e470: f104 00a0    	add.w	r0, r4, #0xa0
7009e474: 4642         	mov	r2, r8
7009e476: 2110         	movs	r1, #0x10
7009e478: 462b         	mov	r3, r5
7009e47a: f00c ecc0    	blx	0x700aadfc <snprintf>   @ imm = #0xc980
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e47e: f107 00a0    	add.w	r0, r7, #0xa0
7009e482: 464a         	mov	r2, r9
7009e484: 462b         	mov	r3, r5
7009e486: 2110         	movs	r1, #0x10
7009e488: f00c ecb8    	blx	0x700aadfc <snprintf>   @ imm = #0xc970
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e48c: f106 050b    	add.w	r5, r6, #0xb
7009e490: f104 00b0    	add.w	r0, r4, #0xb0
7009e494: 4642         	mov	r2, r8
7009e496: 2110         	movs	r1, #0x10
7009e498: 462b         	mov	r3, r5
7009e49a: f00c ecb0    	blx	0x700aadfc <snprintf>   @ imm = #0xc960
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e49e: f107 00b0    	add.w	r0, r7, #0xb0
7009e4a2: 464a         	mov	r2, r9
7009e4a4: 462b         	mov	r3, r5
7009e4a6: 2110         	movs	r1, #0x10
7009e4a8: f00c eca8    	blx	0x700aadfc <snprintf>   @ imm = #0xc950
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e4ac: f106 050c    	add.w	r5, r6, #0xc
7009e4b0: f104 00c0    	add.w	r0, r4, #0xc0
7009e4b4: 4642         	mov	r2, r8
7009e4b6: 2110         	movs	r1, #0x10
7009e4b8: 462b         	mov	r3, r5
7009e4ba: f00c eca0    	blx	0x700aadfc <snprintf>   @ imm = #0xc940
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e4be: f107 00c0    	add.w	r0, r7, #0xc0
7009e4c2: 464a         	mov	r2, r9
7009e4c4: 462b         	mov	r3, r5
7009e4c6: 2110         	movs	r1, #0x10
7009e4c8: f00c ec98    	blx	0x700aadfc <snprintf>   @ imm = #0xc930
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e4cc: f106 050d    	add.w	r5, r6, #0xd
7009e4d0: f104 00d0    	add.w	r0, r4, #0xd0
7009e4d4: 4642         	mov	r2, r8
7009e4d6: 2110         	movs	r1, #0x10
7009e4d8: 462b         	mov	r3, r5
7009e4da: f00c ec90    	blx	0x700aadfc <snprintf>   @ imm = #0xc920
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e4de: f107 00d0    	add.w	r0, r7, #0xd0
7009e4e2: 464a         	mov	r2, r9
7009e4e4: 462b         	mov	r3, r5
7009e4e6: 2110         	movs	r1, #0x10
7009e4e8: f00c ec88    	blx	0x700aadfc <snprintf>   @ imm = #0xc910
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e4ec: f106 050e    	add.w	r5, r6, #0xe
7009e4f0: f104 00e0    	add.w	r0, r4, #0xe0
7009e4f4: 4642         	mov	r2, r8
7009e4f6: 2110         	movs	r1, #0x10
7009e4f8: 462b         	mov	r3, r5
7009e4fa: f00c ec80    	blx	0x700aadfc <snprintf>   @ imm = #0xc900
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e4fe: f107 00e0    	add.w	r0, r7, #0xe0
7009e502: 464a         	mov	r2, r9
7009e504: 462b         	mov	r3, r5
7009e506: 2110         	movs	r1, #0x10
7009e508: f00c ec78    	blx	0x700aadfc <snprintf>   @ imm = #0xc8f0
;       snprintf(pmu_send_names[i], sizeof(pmu_send_names[i]), "S%02d", i);
7009e50c: f104 00f0    	add.w	r0, r4, #0xf0
7009e510: f106 040f    	add.w	r4, r6, #0xf
7009e514: 4642         	mov	r2, r8
7009e516: 2110         	movs	r1, #0x10
7009e518: 4623         	mov	r3, r4
7009e51a: f00c ec70    	blx	0x700aadfc <snprintf>   @ imm = #0xc8e0
;       snprintf(pmu_recv_names[i], sizeof(pmu_recv_names[i]), "R%02d", i);
7009e51e: f107 00f0    	add.w	r0, r7, #0xf0
7009e522: 464a         	mov	r2, r9
7009e524: 4623         	mov	r3, r4
7009e526: 2110         	movs	r1, #0x10
7009e528: f00c ec68    	blx	0x700aadfc <snprintf>   @ imm = #0xc8d0
;    for (i = 0; i < ITERATION_COUNT; i++)
7009e52c: 3610         	adds	r6, #0x10
7009e52e: f50a 7a80    	add.w	r10, r10, #0x100
7009e532: 2e20         	cmp	r6, #0x20
7009e534: f47f aefc    	bne.w	0x7009e330 <tm_message_isr_to_task_initialize+0x30> @ imm = #-0x208
;    tm_thread_create(0, 5, tm_receiver_thread_entry);
7009e538: f24d 3201    	movw	r2, #0xd301
7009e53c: 2000         	movs	r0, #0x0
7009e53e: f2c7 0209    	movt	r2, #0x7009
7009e542: 2105         	movs	r1, #0x5
7009e544: f00f ff5c    	bl	0x700ae400 <tm_thread_create> @ imm = #0xfeb8
;    tm_thread_resume(0);
7009e548: 2000         	movs	r0, #0x0
7009e54a: b001         	add	sp, #0x4
7009e54c: e8bd 4ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
7009e550: f011 b9de    	b.w	0x700af910 <tm_thread_resume> @ imm = #0x113bc
		...

7009e560 <Sciclient_rmIrqFindRoute>:
; {
7009e560: b580         	push	{r7, lr}
7009e562: b08a         	sub	sp, #0x28
7009e564: 9009         	str	r0, [sp, #0x24]
7009e566: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
7009e568: 9008         	str	r0, [sp, #0x20]
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009e56a: 9809         	ldr	r0, [sp, #0x24]
7009e56c: 88c0         	ldrh	r0, [r0, #0x6]
7009e56e: f010 f9e7    	bl	0x700ae940 <Sciclient_rmIrIsIr> @ imm = #0x103ce
7009e572: b930         	cbnz	r0, 0x7009e582 <Sciclient_rmIrqFindRoute+0x22> @ imm = #0xc
7009e574: e7ff         	b	0x7009e576 <Sciclient_rmIrqFindRoute+0x16> @ imm = #-0x2
;         (Sciclient_rmIrIsIr(cfg->d_id) == true)) {
7009e576: 9809         	ldr	r0, [sp, #0x24]
7009e578: 8940         	ldrh	r0, [r0, #0xa]
7009e57a: f010 f9e1    	bl	0x700ae940 <Sciclient_rmIrIsIr> @ imm = #0x103c2
;     if ((Sciclient_rmIrIsIr(cfg->s_id) == true) ||
7009e57e: b120         	cbz	r0, 0x7009e58a <Sciclient_rmIrqFindRoute+0x2a> @ imm = #0x8
7009e580: e7ff         	b	0x7009e582 <Sciclient_rmIrqFindRoute+0x22> @ imm = #-0x2
7009e582: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
7009e586: 9008         	str	r0, [sp, #0x20]
;     }
7009e588: e7ff         	b	0x7009e58a <Sciclient_rmIrqFindRoute+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009e58a: 9808         	ldr	r0, [sp, #0x20]
7009e58c: bb20         	cbnz	r0, 0x7009e5d8 <Sciclient_rmIrqFindRoute+0x78> @ imm = #0x48
7009e58e: e7ff         	b	0x7009e590 <Sciclient_rmIrqFindRoute+0x30> @ imm = #-0x2
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009e590: 9809         	ldr	r0, [sp, #0x24]
7009e592: 8a00         	ldrh	r0, [r0, #0x10]
7009e594: 28ff         	cmp	r0, #0xff
7009e596: d015         	beq	0x7009e5c4 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x2a
7009e598: e7ff         	b	0x7009e59a <Sciclient_rmIrqFindRoute+0x3a> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009e59a: 9809         	ldr	r0, [sp, #0x24]
7009e59c: 6800         	ldr	r0, [r0]
7009e59e: 2104         	movs	r1, #0x4
7009e5a0: f010 fbae    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x1075c
;              true) &&
7009e5a4: b170         	cbz	r0, 0x7009e5c4 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0x1c
7009e5a6: e7ff         	b	0x7009e5a8 <Sciclient_rmIrqFindRoute+0x48> @ imm = #-0x2
;             (Sciclient_rmParamIsValid(cfg->valid_params,
7009e5a8: 9809         	ldr	r0, [sp, #0x24]
7009e5aa: 6800         	ldr	r0, [r0]
7009e5ac: 2108         	movs	r1, #0x8
7009e5ae: f010 fba7    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x1074e
;         if ((cfg->s_ia != SCICLIENT_RM_DEV_NONE) &&
7009e5b2: b138         	cbz	r0, 0x7009e5c4 <Sciclient_rmIrqFindRoute+0x64> @ imm = #0xe
7009e5b4: e7ff         	b	0x7009e5b6 <Sciclient_rmIrqFindRoute+0x56> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNode(cfg->s_ia, &cur_n);
7009e5b6: 9809         	ldr	r0, [sp, #0x24]
7009e5b8: 8a00         	ldrh	r0, [r0, #0x10]
7009e5ba: a905         	add	r1, sp, #0x14
7009e5bc: f007 fc90    	bl	0x700a5ee0 <Sciclient_rmIrqGetNode> @ imm = #0x7920
7009e5c0: 9008         	str	r0, [sp, #0x20]
;         } else {
7009e5c2: e006         	b	0x7009e5d2 <Sciclient_rmIrqFindRoute+0x72> @ imm = #0xc
;             r = Sciclient_rmIrqGetNode(cfg->s_id, &cur_n);
7009e5c4: 9809         	ldr	r0, [sp, #0x24]
7009e5c6: 88c0         	ldrh	r0, [r0, #0x6]
7009e5c8: a905         	add	r1, sp, #0x14
7009e5ca: f007 fc89    	bl	0x700a5ee0 <Sciclient_rmIrqGetNode> @ imm = #0x7912
7009e5ce: 9008         	str	r0, [sp, #0x20]
7009e5d0: e7ff         	b	0x7009e5d2 <Sciclient_rmIrqFindRoute+0x72> @ imm = #-0x2
;         root_n = cur_n;
7009e5d2: 9805         	ldr	r0, [sp, #0x14]
7009e5d4: 9004         	str	r0, [sp, #0x10]
;     }
7009e5d6: e7ff         	b	0x7009e5d8 <Sciclient_rmIrqFindRoute+0x78> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
7009e5d8: 9808         	ldr	r0, [sp, #0x20]
7009e5da: b968         	cbnz	r0, 0x7009e5f8 <Sciclient_rmIrqFindRoute+0x98> @ imm = #0x1a
7009e5dc: e7ff         	b	0x7009e5de <Sciclient_rmIrqFindRoute+0x7e> @ imm = #-0x2
7009e5de: 2001         	movs	r0, #0x1
;         search = true;
7009e5e0: 9002         	str	r0, [sp, #0x8]
7009e5e2: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         Sciclient_rmPsInit();
7009e5e6: f010 ff2b    	bl	0x700af440 <Sciclient_rmPsInit> @ imm = #0x10e56
7009e5ea: 9802         	ldr	r0, [sp, #0x8]
;         search_depth = 1u;
7009e5ec: f8ad 001c    	strh.w	r0, [sp, #0x1c]
7009e5f0: 2000         	movs	r0, #0x0
;         if_idx = 0u;
7009e5f2: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;     } else {
7009e5f6: e003         	b	0x7009e600 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #0x6
7009e5f8: 2000         	movs	r0, #0x0
;         search = false;
7009e5fa: f88d 001f    	strb.w	r0, [sp, #0x1f]
7009e5fe: e7ff         	b	0x7009e600 <Sciclient_rmIrqFindRoute+0xa0> @ imm = #-0x2
;     while (search == true) {
7009e600: e7ff         	b	0x7009e602 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x2
7009e602: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009e606: 07c0         	lsls	r0, r0, #0x1f
7009e608: 2800         	cmp	r0, #0x0
7009e60a: f000 80ca    	beq.w	0x7009e7a2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x194
7009e60e: e7ff         	b	0x7009e610 <Sciclient_rmIrqFindRoute+0xb0> @ imm = #-0x2
7009e610: 2000         	movs	r0, #0x0
;         node_clear = false;
7009e612: f88d 0019    	strb.w	r0, [sp, #0x19]
;         if (if_idx < cur_n->n_if) {
7009e616: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e61a: 9905         	ldr	r1, [sp, #0x14]
7009e61c: 8849         	ldrh	r1, [r1, #0x2]
7009e61e: 4288         	cmp	r0, r1
7009e620: f280 8087    	bge.w	0x7009e732 <Sciclient_rmIrqFindRoute+0x1d2> @ imm = #0x10e
7009e624: e7ff         	b	0x7009e626 <Sciclient_rmIrqFindRoute+0xc6> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(cur_n, if_idx, &cur_if);
7009e626: 9805         	ldr	r0, [sp, #0x14]
7009e628: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009e62c: aa03         	add	r2, sp, #0xc
7009e62e: f00f fa27    	bl	0x700ada80 <Sciclient_rmIrqGetNodeItf> @ imm = #0xf44e
7009e632: 9008         	str	r0, [sp, #0x20]
;             if (r != SystemP_SUCCESS) {
7009e634: 9808         	ldr	r0, [sp, #0x20]
7009e636: b108         	cbz	r0, 0x7009e63c <Sciclient_rmIrqFindRoute+0xdc> @ imm = #0x2
7009e638: e7ff         	b	0x7009e63a <Sciclient_rmIrqFindRoute+0xda> @ imm = #-0x2
;                 break;
7009e63a: e0b2         	b	0x7009e7a2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x164
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009e63c: 9805         	ldr	r0, [sp, #0x14]
7009e63e: 8800         	ldrh	r0, [r0]
7009e640: f010 f966    	bl	0x700ae910 <Sciclient_rmIaIsIa> @ imm = #0x102cc
7009e644: b9d0         	cbnz	r0, 0x7009e67c <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x34
7009e646: e7ff         	b	0x7009e648 <Sciclient_rmIrqFindRoute+0xe8> @ imm = #-0x2
;                 (Sciclient_rmPsIsEmpty() == true) &&
7009e648: f010 fb72    	bl	0x700aed30 <Sciclient_rmPsIsEmpty> @ imm = #0x106e4
7009e64c: b1b0         	cbz	r0, 0x7009e67c <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0x2c
7009e64e: e7ff         	b	0x7009e650 <Sciclient_rmIrqFindRoute+0xf0> @ imm = #-0x2
;                 ((cfg->s_idx < cur_if->lbase) ||
7009e650: 9809         	ldr	r0, [sp, #0x24]
7009e652: 8900         	ldrh	r0, [r0, #0x8]
7009e654: 9903         	ldr	r1, [sp, #0xc]
7009e656: 8809         	ldrh	r1, [r1]
7009e658: 4288         	cmp	r0, r1
7009e65a: db09         	blt	0x7009e670 <Sciclient_rmIrqFindRoute+0x110> @ imm = #0x12
7009e65c: e7ff         	b	0x7009e65e <Sciclient_rmIrqFindRoute+0xfe> @ imm = #-0x2
;                  (cfg->s_idx >= (cur_if->lbase + cur_if->len)))) {
7009e65e: 9809         	ldr	r0, [sp, #0x24]
7009e660: 8900         	ldrh	r0, [r0, #0x8]
7009e662: 9a03         	ldr	r2, [sp, #0xc]
7009e664: 8811         	ldrh	r1, [r2]
7009e666: 8892         	ldrh	r2, [r2, #0x4]
7009e668: 4411         	add	r1, r2
;             if ((Sciclient_rmIaIsIa(cur_n->id) == false) &&
7009e66a: 4288         	cmp	r0, r1
7009e66c: db06         	blt	0x7009e67c <Sciclient_rmIrqFindRoute+0x11c> @ imm = #0xc
7009e66e: e7ff         	b	0x7009e670 <Sciclient_rmIrqFindRoute+0x110> @ imm = #-0x2
;                 if_idx++;
7009e670: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e674: 3001         	adds	r0, #0x1
7009e676: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             } else if (Sciclient_rmPsGetPsp() < search_depth) {
7009e67a: e059         	b	0x7009e730 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #0xb2
7009e67c: f011 fb00    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0x11600
7009e680: f8bd 101c    	ldrh.w	r1, [sp, #0x1c]
7009e684: 4288         	cmp	r0, r1
7009e686: da1e         	bge	0x7009e6c6 <Sciclient_rmIrqFindRoute+0x166> @ imm = #0x3c
7009e688: e7ff         	b	0x7009e68a <Sciclient_rmIrqFindRoute+0x12a> @ imm = #-0x2
;                 r = Sciclient_rmPsPush(cur_n, if_idx);
7009e68a: 9805         	ldr	r0, [sp, #0x14]
7009e68c: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009e690: f00d ff86    	bl	0x700ac5a0 <Sciclient_rmPsPush> @ imm = #0xdf0c
7009e694: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009e696: 9808         	ldr	r0, [sp, #0x20]
7009e698: b108         	cbz	r0, 0x7009e69e <Sciclient_rmIrqFindRoute+0x13e> @ imm = #0x2
7009e69a: e7ff         	b	0x7009e69c <Sciclient_rmIrqFindRoute+0x13c> @ imm = #-0x2
;                     break;
7009e69c: e081         	b	0x7009e7a2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x102
;                 r = Sciclient_rmIrqGetNode(cur_if->rid, &cur_n);
7009e69e: 9803         	ldr	r0, [sp, #0xc]
7009e6a0: 88c0         	ldrh	r0, [r0, #0x6]
7009e6a2: a905         	add	r1, sp, #0x14
7009e6a4: f007 fc1c    	bl	0x700a5ee0 <Sciclient_rmIrqGetNode> @ imm = #0x7838
7009e6a8: 9008         	str	r0, [sp, #0x20]
;                 if (cur_n == NULL) {
7009e6aa: 9805         	ldr	r0, [sp, #0x14]
7009e6ac: b930         	cbnz	r0, 0x7009e6bc <Sciclient_rmIrqFindRoute+0x15c> @ imm = #0xc
7009e6ae: e7ff         	b	0x7009e6b0 <Sciclient_rmIrqFindRoute+0x150> @ imm = #-0x2
7009e6b0: 2001         	movs	r0, #0x1
;                     node_clear = true;
7009e6b2: f88d 0019    	strb.w	r0, [sp, #0x19]
7009e6b6: 2000         	movs	r0, #0x0
;                     r = SystemP_SUCCESS;
7009e6b8: 9008         	str	r0, [sp, #0x20]
;                 } else {
7009e6ba: e003         	b	0x7009e6c4 <Sciclient_rmIrqFindRoute+0x164> @ imm = #0x6
7009e6bc: 2000         	movs	r0, #0x0
;                     if_idx = 0u;
7009e6be: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e6c2: e7ff         	b	0x7009e6c4 <Sciclient_rmIrqFindRoute+0x164> @ imm = #-0x2
;             } else {
7009e6c4: e033         	b	0x7009e72e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #0x66
;                 if ((cur_if->rid == cfg->d_id) &&
7009e6c6: 9803         	ldr	r0, [sp, #0xc]
7009e6c8: 88c0         	ldrh	r0, [r0, #0x6]
7009e6ca: 9909         	ldr	r1, [sp, #0x24]
7009e6cc: 8949         	ldrh	r1, [r1, #0xa]
7009e6ce: 4288         	cmp	r0, r1
7009e6d0: d127         	bne	0x7009e722 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x4e
7009e6d2: e7ff         	b	0x7009e6d4 <Sciclient_rmIrqFindRoute+0x174> @ imm = #-0x2
;                     (cfg->d_irq >= (cur_if->rbase)) &&
7009e6d4: 9809         	ldr	r0, [sp, #0x24]
7009e6d6: 8980         	ldrh	r0, [r0, #0xc]
7009e6d8: 9903         	ldr	r1, [sp, #0xc]
7009e6da: 8849         	ldrh	r1, [r1, #0x2]
7009e6dc: 4288         	cmp	r0, r1
7009e6de: db20         	blt	0x7009e722 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x40
7009e6e0: e7ff         	b	0x7009e6e2 <Sciclient_rmIrqFindRoute+0x182> @ imm = #-0x2
;                     (cfg->d_irq <
7009e6e2: 9809         	ldr	r0, [sp, #0x24]
7009e6e4: 8980         	ldrh	r0, [r0, #0xc]
;                      (cur_if->rbase + cur_if->len))) {
7009e6e6: 9a03         	ldr	r2, [sp, #0xc]
7009e6e8: 8851         	ldrh	r1, [r2, #0x2]
7009e6ea: 8892         	ldrh	r2, [r2, #0x4]
7009e6ec: 4411         	add	r1, r2
;                 if ((cur_if->rid == cfg->d_id) &&
7009e6ee: 4288         	cmp	r0, r1
7009e6f0: da17         	bge	0x7009e722 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #0x2e
7009e6f2: e7ff         	b	0x7009e6f4 <Sciclient_rmIrqFindRoute+0x194> @ imm = #-0x2
;                     r = Sciclient_rmPsPush(cur_n, if_idx);
7009e6f4: 9805         	ldr	r0, [sp, #0x14]
7009e6f6: f8bd 101a    	ldrh.w	r1, [sp, #0x1a]
7009e6fa: f00d ff51    	bl	0x700ac5a0 <Sciclient_rmPsPush> @ imm = #0xdea2
7009e6fe: 9008         	str	r0, [sp, #0x20]
;                     if (r != SystemP_SUCCESS) {
7009e700: 9808         	ldr	r0, [sp, #0x20]
7009e702: b108         	cbz	r0, 0x7009e708 <Sciclient_rmIrqFindRoute+0x1a8> @ imm = #0x2
7009e704: e7ff         	b	0x7009e706 <Sciclient_rmIrqFindRoute+0x1a6> @ imm = #-0x2
;                         break;
7009e706: e04c         	b	0x7009e7a2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x98
;                     if (Sciclient_rmIrqRouteValidate(cfg) == true) {
7009e708: 9809         	ldr	r0, [sp, #0x24]
7009e70a: f7fc fa09    	bl	0x7009ab20 <Sciclient_rmIrqRouteValidate> @ imm = #-0x3bee
7009e70e: b108         	cbz	r0, 0x7009e714 <Sciclient_rmIrqFindRoute+0x1b4> @ imm = #0x2
7009e710: e7ff         	b	0x7009e712 <Sciclient_rmIrqFindRoute+0x1b2> @ imm = #-0x2
;                         break;
7009e712: e046         	b	0x7009e7a2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x8c
7009e714: a805         	add	r0, sp, #0x14
7009e716: f10d 011a    	add.w	r1, sp, #0x1a
;                         Sciclient_rmPsPop(&cur_n, &if_idx);
7009e71a: f00b faa9    	bl	0x700a9c70 <Sciclient_rmPsPop> @ imm = #0xb552
7009e71e: e7ff         	b	0x7009e720 <Sciclient_rmIrqFindRoute+0x1c0> @ imm = #-0x2
;                 }
7009e720: e7ff         	b	0x7009e722 <Sciclient_rmIrqFindRoute+0x1c2> @ imm = #-0x2
;                 if_idx++;
7009e722: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e726: 3001         	adds	r0, #0x1
7009e728: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e72c: e7ff         	b	0x7009e72e <Sciclient_rmIrqFindRoute+0x1ce> @ imm = #-0x2
7009e72e: e7ff         	b	0x7009e730 <Sciclient_rmIrqFindRoute+0x1d0> @ imm = #-0x2
;         } else {
7009e730: e003         	b	0x7009e73a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #0x6
7009e732: 2001         	movs	r0, #0x1
;             node_clear = true;
7009e734: f88d 0019    	strb.w	r0, [sp, #0x19]
7009e738: e7ff         	b	0x7009e73a <Sciclient_rmIrqFindRoute+0x1da> @ imm = #-0x2
;         if (node_clear == true) {
7009e73a: f89d 0019    	ldrb.w	r0, [sp, #0x19]
7009e73e: 07c0         	lsls	r0, r0, #0x1f
7009e740: b370         	cbz	r0, 0x7009e7a0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #0x5c
7009e742: e7ff         	b	0x7009e744 <Sciclient_rmIrqFindRoute+0x1e4> @ imm = #-0x2
;             if (Sciclient_rmPsIsEmpty() == true) {
7009e744: f010 faf4    	bl	0x700aed30 <Sciclient_rmPsIsEmpty> @ imm = #0x105e8
7009e748: b1c8         	cbz	r0, 0x7009e77e <Sciclient_rmIrqFindRoute+0x21e> @ imm = #0x32
7009e74a: e7ff         	b	0x7009e74c <Sciclient_rmIrqFindRoute+0x1ec> @ imm = #-0x2
;                 search_depth++;
7009e74c: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009e750: 3001         	adds	r0, #0x1
7009e752: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;                 cur_n = root_n;
7009e756: 9804         	ldr	r0, [sp, #0x10]
7009e758: 9005         	str	r0, [sp, #0x14]
7009e75a: 2000         	movs	r0, #0x0
;                 if_idx = 0u;
7009e75c: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;                 if (search_depth >= Sciclient_rmPsGetMaxPsp()) {
7009e760: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
7009e764: 9001         	str	r0, [sp, #0x4]
7009e766: f011 faeb    	bl	0x700afd40 <Sciclient_rmPsGetMaxPsp> @ imm = #0x115d6
7009e76a: 4601         	mov	r1, r0
7009e76c: 9801         	ldr	r0, [sp, #0x4]
7009e76e: 4288         	cmp	r0, r1
7009e770: db04         	blt	0x7009e77c <Sciclient_rmIrqFindRoute+0x21c> @ imm = #0x8
7009e772: e7ff         	b	0x7009e774 <Sciclient_rmIrqFindRoute+0x214> @ imm = #-0x2
7009e774: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
7009e778: 9008         	str	r0, [sp, #0x20]
;                     break;
7009e77a: e012         	b	0x7009e7a2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0x24
;             } else {
7009e77c: e00f         	b	0x7009e79e <Sciclient_rmIrqFindRoute+0x23e> @ imm = #0x1e
7009e77e: a805         	add	r0, sp, #0x14
7009e780: f10d 011a    	add.w	r1, sp, #0x1a
;                 r = Sciclient_rmPsPop(&cur_n, &if_idx);
7009e784: f00b fa74    	bl	0x700a9c70 <Sciclient_rmPsPop> @ imm = #0xb4e8
7009e788: 9008         	str	r0, [sp, #0x20]
;                 if (r != SystemP_SUCCESS) {
7009e78a: 9808         	ldr	r0, [sp, #0x20]
7009e78c: b108         	cbz	r0, 0x7009e792 <Sciclient_rmIrqFindRoute+0x232> @ imm = #0x2
7009e78e: e7ff         	b	0x7009e790 <Sciclient_rmIrqFindRoute+0x230> @ imm = #-0x2
;                     break;
7009e790: e007         	b	0x7009e7a2 <Sciclient_rmIrqFindRoute+0x242> @ imm = #0xe
;                 if_idx++;
7009e792: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
7009e796: 3001         	adds	r0, #0x1
7009e798: f8ad 001a    	strh.w	r0, [sp, #0x1a]
7009e79c: e7ff         	b	0x7009e79e <Sciclient_rmIrqFindRoute+0x23e> @ imm = #-0x2
;         }
7009e79e: e7ff         	b	0x7009e7a0 <Sciclient_rmIrqFindRoute+0x240> @ imm = #-0x2
;     while (search == true) {
7009e7a0: e72f         	b	0x7009e602 <Sciclient_rmIrqFindRoute+0xa2> @ imm = #-0x1a2
;     return r;
7009e7a2: 9808         	ldr	r0, [sp, #0x20]
7009e7a4: b00a         	add	sp, #0x28
7009e7a6: bd80         	pop	{r7, pc}
		...

7009e7b0 <UART_fifoConfig>:
; {
7009e7b0: b580         	push	{r7, lr}
7009e7b2: b092         	sub	sp, #0x48
7009e7b4: 9011         	str	r0, [sp, #0x44]
7009e7b6: 9110         	str	r1, [sp, #0x40]
7009e7b8: 2000         	movs	r0, #0x0
;     uint32_t fcrValue = 0U;
7009e7ba: 900c         	str	r0, [sp, #0x30]
;     uint32_t txGra = (fifoConfig & UART_FIFO_CONFIG_TXGRA) >> 26;
7009e7bc: 9810         	ldr	r0, [sp, #0x40]
7009e7be: f3c0 6083    	ubfx	r0, r0, #0x1a, #0x4
7009e7c2: 900b         	str	r0, [sp, #0x2c]
;     uint32_t rxGra = (fifoConfig & UART_FIFO_CONFIG_RXGRA) >> 22;
7009e7c4: 9810         	ldr	r0, [sp, #0x40]
7009e7c6: f3c0 5083    	ubfx	r0, r0, #0x16, #0x4
7009e7ca: 900a         	str	r0, [sp, #0x28]
;     uint32_t txTrig = (fifoConfig & UART_FIFO_CONFIG_TXTRIG) >> 14;
7009e7cc: 9810         	ldr	r0, [sp, #0x40]
7009e7ce: f3c0 3087    	ubfx	r0, r0, #0xe, #0x8
7009e7d2: 9009         	str	r0, [sp, #0x24]
;     uint32_t rxTrig = (fifoConfig & UART_FIFO_CONFIG_RXTRIG) >> 6;
7009e7d4: 9810         	ldr	r0, [sp, #0x40]
7009e7d6: f3c0 1087    	ubfx	r0, r0, #0x6, #0x8
7009e7da: 9008         	str	r0, [sp, #0x20]
;     uint32_t txClr = (fifoConfig & UART_FIFO_CONFIG_TXCLR) >> 5;
7009e7dc: 9810         	ldr	r0, [sp, #0x40]
7009e7de: f3c0 1040    	ubfx	r0, r0, #0x5, #0x1
7009e7e2: 9007         	str	r0, [sp, #0x1c]
;     uint32_t rxClr = (fifoConfig & UART_FIFO_CONFIG_RXCLR) >> 4;
7009e7e4: 9810         	ldr	r0, [sp, #0x40]
7009e7e6: f3c0 1000    	ubfx	r0, r0, #0x4, #0x1
7009e7ea: 9006         	str	r0, [sp, #0x18]
;     uint32_t dmaEnPath = (fifoConfig & UART_FIFO_CONFIG_DMAENPATH) >> 3;
7009e7ec: 9810         	ldr	r0, [sp, #0x40]
7009e7ee: f3c0 00c0    	ubfx	r0, r0, #0x3, #0x1
7009e7f2: 9005         	str	r0, [sp, #0x14]
;     uint32_t dmaMode   = (fifoConfig & UART_FIFO_CONFIG_DMAMODE);
7009e7f4: 9810         	ldr	r0, [sp, #0x40]
7009e7f6: f000 0007    	and	r0, r0, #0x7
7009e7fa: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
7009e7fc: 9811         	ldr	r0, [sp, #0x44]
7009e7fe: f00f fc5f    	bl	0x700ae0c0 <UART_enhanFuncEnable> @ imm = #0xf8be
7009e802: 900f         	str	r0, [sp, #0x3c]
;     tcrTlrBitVal = UART_subConfigTCRTLRModeEn(baseAddr);
7009e804: 9811         	ldr	r0, [sp, #0x44]
7009e806: f00a ff63    	bl	0x700a96d0 <UART_subConfigTCRTLRModeEn> @ imm = #0xaec6
7009e80a: 900e         	str	r0, [sp, #0x38]
;     fcrValue |= UART_FCR_FIFO_EN_MASK;
7009e80c: 980c         	ldr	r0, [sp, #0x30]
7009e80e: f040 0001    	orr	r0, r0, #0x1
7009e812: 900c         	str	r0, [sp, #0x30]
;     if(UART_TRIG_LVL_GRANULARITY_1 != rxGra)
7009e814: 980a         	ldr	r0, [sp, #0x28]
7009e816: 2801         	cmp	r0, #0x1
7009e818: d033         	beq	0x7009e882 <UART_fifoConfig+0xd2> @ imm = #0x66
7009e81a: e7ff         	b	0x7009e81c <UART_fifoConfig+0x6c> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009e81c: 9811         	ldr	r0, [sp, #0x44]
7009e81e: 3040         	adds	r0, #0x40
7009e820: 2180         	movs	r1, #0x80
7009e822: 2207         	movs	r2, #0x7
7009e824: 2300         	movs	r3, #0x0
7009e826: 9303         	str	r3, [sp, #0xc]
7009e828: f00f ff42    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfe84
7009e82c: 9b03         	ldr	r3, [sp, #0xc]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009e82e: 9811         	ldr	r0, [sp, #0x44]
7009e830: 301c         	adds	r0, #0x1c
7009e832: 21f0         	movs	r1, #0xf0
7009e834: 2204         	movs	r2, #0x4
7009e836: f00f ff3b    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfe76
;         fcrValue &= ~((uint32_t) UART_FCR_RX_FIFO_TRIG_MASK);
7009e83a: 980c         	ldr	r0, [sp, #0x30]
7009e83c: f020 00c0    	bic	r0, r0, #0xc0
7009e840: 900c         	str	r0, [sp, #0x30]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009e842: 9808         	ldr	r0, [sp, #0x20]
7009e844: 2808         	cmp	r0, #0x8
7009e846: d00c         	beq	0x7009e862 <UART_fifoConfig+0xb2> @ imm = #0x18
7009e848: e7ff         	b	0x7009e84a <UART_fifoConfig+0x9a> @ imm = #-0x2
;            (UART_RXTRIGLVL_16 == rxTrig) ||
7009e84a: 9808         	ldr	r0, [sp, #0x20]
7009e84c: 2810         	cmp	r0, #0x10
7009e84e: d008         	beq	0x7009e862 <UART_fifoConfig+0xb2> @ imm = #0x10
7009e850: e7ff         	b	0x7009e852 <UART_fifoConfig+0xa2> @ imm = #-0x2
;            (UART_RXTRIGLVL_56 == rxTrig) ||
7009e852: 9808         	ldr	r0, [sp, #0x20]
7009e854: 2838         	cmp	r0, #0x38
7009e856: d004         	beq	0x7009e862 <UART_fifoConfig+0xb2> @ imm = #0x8
7009e858: e7ff         	b	0x7009e85a <UART_fifoConfig+0xaa> @ imm = #-0x2
;            (UART_RXTRIGLVL_60 == rxTrig))
7009e85a: 9808         	ldr	r0, [sp, #0x20]
;         if((UART_RXTRIGLVL_8 == rxTrig) ||
7009e85c: 283c         	cmp	r0, #0x3c
7009e85e: d107         	bne	0x7009e870 <UART_fifoConfig+0xc0> @ imm = #0xe
7009e860: e7ff         	b	0x7009e862 <UART_fifoConfig+0xb2> @ imm = #-0x2
;             fcrValue |= rxTrig & UART_FCR_RX_FIFO_TRIG_MASK;
7009e862: 9808         	ldr	r0, [sp, #0x20]
7009e864: f000 01c0    	and	r1, r0, #0xc0
7009e868: 980c         	ldr	r0, [sp, #0x30]
7009e86a: 4308         	orrs	r0, r1
7009e86c: 900c         	str	r0, [sp, #0x30]
;         }
7009e86e: e007         	b	0x7009e880 <UART_fifoConfig+0xd0> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA,
7009e870: 9811         	ldr	r0, [sp, #0x44]
7009e872: 301c         	adds	r0, #0x1c
7009e874: 9b08         	ldr	r3, [sp, #0x20]
7009e876: 21f0         	movs	r1, #0xf0
7009e878: 2204         	movs	r2, #0x4
7009e87a: f00f ff19    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfe32
7009e87e: e7ff         	b	0x7009e880 <UART_fifoConfig+0xd0> @ imm = #-0x2
;     }
7009e880: e01d         	b	0x7009e8be <UART_fifoConfig+0x10e> @ imm = #0x3a
;         rxTrig &= 0x003FU;
7009e882: 9808         	ldr	r0, [sp, #0x20]
7009e884: f000 003f    	and	r0, r0, #0x3f
7009e888: 9008         	str	r0, [sp, #0x20]
;         tlrValue = (rxTrig & 0x003CU) >> 2;
7009e88a: 9808         	ldr	r0, [sp, #0x20]
7009e88c: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009e890: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (rxTrig & 0x0003U) << UART_FCR_RX_FIFO_TRIG_SHIFT;
7009e892: 9808         	ldr	r0, [sp, #0x20]
7009e894: f000 0103    	and	r1, r0, #0x3
7009e898: 980c         	ldr	r0, [sp, #0x30]
7009e89a: ea40 1081    	orr.w	r0, r0, r1, lsl #6
7009e89e: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_RX_TRIG_GRANU1,
7009e8a0: 9811         	ldr	r0, [sp, #0x44]
7009e8a2: 3040         	adds	r0, #0x40
7009e8a4: 2180         	movs	r1, #0x80
7009e8a6: 2207         	movs	r2, #0x7
7009e8a8: 2301         	movs	r3, #0x1
7009e8aa: f00f ff01    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfe02
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_RX_FIFO_TRIG_DMA, tlrValue);
7009e8ae: 9811         	ldr	r0, [sp, #0x44]
7009e8b0: 301c         	adds	r0, #0x1c
7009e8b2: 9b0d         	ldr	r3, [sp, #0x34]
7009e8b4: 21f0         	movs	r1, #0xf0
7009e8b6: 2204         	movs	r2, #0x4
7009e8b8: f00f fefa    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfdf4
7009e8bc: e7ff         	b	0x7009e8be <UART_fifoConfig+0x10e> @ imm = #-0x2
;     if(UART_TRIG_LVL_GRANULARITY_1 != txGra)
7009e8be: 980b         	ldr	r0, [sp, #0x2c]
7009e8c0: 2801         	cmp	r0, #0x1
7009e8c2: d033         	beq	0x7009e92c <UART_fifoConfig+0x17c> @ imm = #0x66
7009e8c4: e7ff         	b	0x7009e8c6 <UART_fifoConfig+0x116> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009e8c6: 9811         	ldr	r0, [sp, #0x44]
7009e8c8: 3040         	adds	r0, #0x40
7009e8ca: 2140         	movs	r1, #0x40
7009e8cc: 2206         	movs	r2, #0x6
7009e8ce: 2300         	movs	r3, #0x0
7009e8d0: 9302         	str	r3, [sp, #0x8]
7009e8d2: f00f feed    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfdda
7009e8d6: 9b02         	ldr	r3, [sp, #0x8]
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009e8d8: 9811         	ldr	r0, [sp, #0x44]
7009e8da: 301c         	adds	r0, #0x1c
7009e8dc: 210f         	movs	r1, #0xf
7009e8de: 461a         	mov	r2, r3
7009e8e0: f00f fee6    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfdcc
;         fcrValue &= ~((uint32_t) UART_FCR_TX_FIFO_TRIG_MASK);
7009e8e4: 980c         	ldr	r0, [sp, #0x30]
7009e8e6: f020 0030    	bic	r0, r0, #0x30
7009e8ea: 900c         	str	r0, [sp, #0x30]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009e8ec: 9809         	ldr	r0, [sp, #0x24]
7009e8ee: 2808         	cmp	r0, #0x8
7009e8f0: d00c         	beq	0x7009e90c <UART_fifoConfig+0x15c> @ imm = #0x18
7009e8f2: e7ff         	b	0x7009e8f4 <UART_fifoConfig+0x144> @ imm = #-0x2
;            (UART_TXTRIGLVL_16 == (txTrig)) ||
7009e8f4: 9809         	ldr	r0, [sp, #0x24]
7009e8f6: 2810         	cmp	r0, #0x10
7009e8f8: d008         	beq	0x7009e90c <UART_fifoConfig+0x15c> @ imm = #0x10
7009e8fa: e7ff         	b	0x7009e8fc <UART_fifoConfig+0x14c> @ imm = #-0x2
;            (UART_TXTRIGLVL_32 == (txTrig)) ||
7009e8fc: 9809         	ldr	r0, [sp, #0x24]
7009e8fe: 2820         	cmp	r0, #0x20
7009e900: d004         	beq	0x7009e90c <UART_fifoConfig+0x15c> @ imm = #0x8
7009e902: e7ff         	b	0x7009e904 <UART_fifoConfig+0x154> @ imm = #-0x2
;            (UART_TXTRIGLVL_56 == (txTrig)))
7009e904: 9809         	ldr	r0, [sp, #0x24]
;         if((UART_TXTRIGLVL_8 == (txTrig)) ||
7009e906: 2838         	cmp	r0, #0x38
7009e908: d107         	bne	0x7009e91a <UART_fifoConfig+0x16a> @ imm = #0xe
7009e90a: e7ff         	b	0x7009e90c <UART_fifoConfig+0x15c> @ imm = #-0x2
;             fcrValue |= txTrig & UART_FCR_TX_FIFO_TRIG_MASK;
7009e90c: 9809         	ldr	r0, [sp, #0x24]
7009e90e: f000 0130    	and	r1, r0, #0x30
7009e912: 980c         	ldr	r0, [sp, #0x30]
7009e914: 4308         	orrs	r0, r1
7009e916: 900c         	str	r0, [sp, #0x30]
;         }
7009e918: e007         	b	0x7009e92a <UART_fifoConfig+0x17a> @ imm = #0xe
;             HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA,
7009e91a: 9811         	ldr	r0, [sp, #0x44]
7009e91c: 301c         	adds	r0, #0x1c
7009e91e: 9b09         	ldr	r3, [sp, #0x24]
7009e920: 210f         	movs	r1, #0xf
7009e922: 2200         	movs	r2, #0x0
7009e924: f00f fec4    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfd88
7009e928: e7ff         	b	0x7009e92a <UART_fifoConfig+0x17a> @ imm = #-0x2
;     }
7009e92a: e01d         	b	0x7009e968 <UART_fifoConfig+0x1b8> @ imm = #0x3a
;         txTrig &= 0x003FU;
7009e92c: 9809         	ldr	r0, [sp, #0x24]
7009e92e: f000 003f    	and	r0, r0, #0x3f
7009e932: 9009         	str	r0, [sp, #0x24]
;         tlrValue = (txTrig & 0x003CU) >> 2;
7009e934: 9809         	ldr	r0, [sp, #0x24]
7009e936: f3c0 0083    	ubfx	r0, r0, #0x2, #0x4
7009e93a: 900d         	str	r0, [sp, #0x34]
;         fcrValue |= (txTrig & 0x0003U) << UART_FCR_TX_FIFO_TRIG_SHIFT;
7009e93c: 9809         	ldr	r0, [sp, #0x24]
7009e93e: f000 0103    	and	r1, r0, #0x3
7009e942: 980c         	ldr	r0, [sp, #0x30]
7009e944: ea40 1001    	orr.w	r0, r0, r1, lsl #4
7009e948: 900c         	str	r0, [sp, #0x30]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_TX_TRIG_GRANU1,
7009e94a: 9811         	ldr	r0, [sp, #0x44]
7009e94c: 3040         	adds	r0, #0x40
7009e94e: 2140         	movs	r1, #0x40
7009e950: 2206         	movs	r2, #0x6
7009e952: 2301         	movs	r3, #0x1
7009e954: f00f feac    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfd58
;         HW_WR_FIELD32(baseAddr + UART_TLR, UART_TLR_TX_FIFO_TRIG_DMA, tlrValue);
7009e958: 9811         	ldr	r0, [sp, #0x44]
7009e95a: 301c         	adds	r0, #0x1c
7009e95c: 9b0d         	ldr	r3, [sp, #0x34]
7009e95e: 210f         	movs	r1, #0xf
7009e960: 2200         	movs	r2, #0x0
7009e962: f00f fea5    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfd4a
7009e966: e7ff         	b	0x7009e968 <UART_fifoConfig+0x1b8> @ imm = #-0x2
;     if(UART_DMA_EN_PATH_FCR == dmaEnPath)
7009e968: 9805         	ldr	r0, [sp, #0x14]
7009e96a: b9a8         	cbnz	r0, 0x7009e998 <UART_fifoConfig+0x1e8> @ imm = #0x2a
7009e96c: e7ff         	b	0x7009e96e <UART_fifoConfig+0x1be> @ imm = #-0x2
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009e96e: 9811         	ldr	r0, [sp, #0x44]
7009e970: 3040         	adds	r0, #0x40
7009e972: 2101         	movs	r1, #0x1
7009e974: 2300         	movs	r3, #0x0
7009e976: 461a         	mov	r2, r3
7009e978: f00f fe9a    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfd34
;         dmaMode &= 0x1U;
7009e97c: 9804         	ldr	r0, [sp, #0x10]
7009e97e: f000 0001    	and	r0, r0, #0x1
7009e982: 9004         	str	r0, [sp, #0x10]
;         fcrValue &= ~((uint32_t) UART_FCR_DMA_MODE_MASK);
7009e984: 980c         	ldr	r0, [sp, #0x30]
7009e986: f020 0008    	bic	r0, r0, #0x8
7009e98a: 900c         	str	r0, [sp, #0x30]
;         fcrValue |= dmaMode << UART_FCR_DMA_MODE_SHIFT;
7009e98c: 9904         	ldr	r1, [sp, #0x10]
7009e98e: 980c         	ldr	r0, [sp, #0x30]
7009e990: ea40 00c1    	orr.w	r0, r0, r1, lsl #3
7009e994: 900c         	str	r0, [sp, #0x30]
;     }
7009e996: e013         	b	0x7009e9c0 <UART_fifoConfig+0x210> @ imm = #0x26
;         dmaMode &= 0x3U;
7009e998: 9804         	ldr	r0, [sp, #0x10]
7009e99a: f000 0003    	and	r0, r0, #0x3
7009e99e: 9004         	str	r0, [sp, #0x10]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_CTL,
7009e9a0: 9811         	ldr	r0, [sp, #0x44]
7009e9a2: 3040         	adds	r0, #0x40
7009e9a4: 2200         	movs	r2, #0x0
7009e9a6: 2301         	movs	r3, #0x1
7009e9a8: 9301         	str	r3, [sp, #0x4]
7009e9aa: 4619         	mov	r1, r3
7009e9ac: f00f fe80    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfd00
7009e9b0: 9a01         	ldr	r2, [sp, #0x4]
;         HW_WR_FIELD32(baseAddr + UART_SCR, UART_SCR_DMA_MODE_2, dmaMode);
7009e9b2: 9811         	ldr	r0, [sp, #0x44]
7009e9b4: 3040         	adds	r0, #0x40
7009e9b6: 9b04         	ldr	r3, [sp, #0x10]
7009e9b8: 2106         	movs	r1, #0x6
7009e9ba: f00f fe79    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0xfcf2
7009e9be: e7ff         	b	0x7009e9c0 <UART_fifoConfig+0x210> @ imm = #-0x2
;     fcrValue |= rxClr << UART_FCR_RX_FIFO_CLEAR_SHIFT;
7009e9c0: 9906         	ldr	r1, [sp, #0x18]
7009e9c2: 980c         	ldr	r0, [sp, #0x30]
7009e9c4: ea40 0041    	orr.w	r0, r0, r1, lsl #1
7009e9c8: 900c         	str	r0, [sp, #0x30]
;     fcrValue |= txClr << UART_FCR_TX_FIFO_CLEAR_SHIFT;
7009e9ca: 9907         	ldr	r1, [sp, #0x1c]
7009e9cc: 980c         	ldr	r0, [sp, #0x30]
7009e9ce: ea40 0081    	orr.w	r0, r0, r1, lsl #2
7009e9d2: 900c         	str	r0, [sp, #0x30]
;     UART_fifoRegisterWrite(baseAddr, fcrValue);
7009e9d4: 9811         	ldr	r0, [sp, #0x44]
7009e9d6: 990c         	ldr	r1, [sp, #0x30]
7009e9d8: f00d f902    	bl	0x700abbe0 <UART_fifoRegisterWrite> @ imm = #0xd204
;     UART_tcrTlrBitValRestore(baseAddr, tcrTlrBitVal);
7009e9dc: 9811         	ldr	r0, [sp, #0x44]
7009e9de: 990e         	ldr	r1, [sp, #0x38]
7009e9e0: f00b fd8e    	bl	0x700aa500 <UART_tcrTlrBitValRestore> @ imm = #0xbb1c
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
7009e9e4: 9811         	ldr	r0, [sp, #0x44]
7009e9e6: 990f         	ldr	r1, [sp, #0x3c]
7009e9e8: f00f fe82    	bl	0x700ae6f0 <UART_enhanFuncBitValRestore> @ imm = #0xfd04
;     return fcrValue;
7009e9ec: 980c         	ldr	r0, [sp, #0x30]
7009e9ee: b012         	add	sp, #0x48
7009e9f0: bd80         	pop	{r7, pc}
		...
7009e9fe: 0000         	movs	r0, r0

7009ea00 <_ntoa_format>:
; {
7009ea00: b570         	push	{r4, r5, r6, lr}
7009ea02: b08c         	sub	sp, #0x30
7009ea04: 4684         	mov	r12, r0
7009ea06: 9816         	ldr	r0, [sp, #0x58]
7009ea08: 9815         	ldr	r0, [sp, #0x54]
7009ea0a: 9814         	ldr	r0, [sp, #0x50]
7009ea0c: 9813         	ldr	r0, [sp, #0x4c]
7009ea0e: 9812         	ldr	r0, [sp, #0x48]
7009ea10: f8dd e044    	ldr.w	lr, [sp, #0x44]
7009ea14: f8dd e040    	ldr.w	lr, [sp, #0x40]
7009ea18: f8cd c02c    	str.w	r12, [sp, #0x2c]
7009ea1c: 910a         	str	r1, [sp, #0x28]
7009ea1e: 9209         	str	r2, [sp, #0x24]
7009ea20: 9308         	str	r3, [sp, #0x20]
7009ea22: f88d 001f    	strb.w	r0, [sp, #0x1f]
;   if (!(flags & FLAGS_LEFT)) {
7009ea26: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009ea2a: 0780         	lsls	r0, r0, #0x1e
7009ea2c: 2800         	cmp	r0, #0x0
7009ea2e: d454         	bmi	0x7009eada <_ntoa_format+0xda> @ imm = #0xa8
7009ea30: e7ff         	b	0x7009ea32 <_ntoa_format+0x32> @ imm = #-0x2
;     if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
7009ea32: 9815         	ldr	r0, [sp, #0x54]
7009ea34: b1a0         	cbz	r0, 0x7009ea60 <_ntoa_format+0x60> @ imm = #0x28
7009ea36: e7ff         	b	0x7009ea38 <_ntoa_format+0x38> @ imm = #-0x2
7009ea38: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009ea3c: 07c0         	lsls	r0, r0, #0x1f
7009ea3e: b178         	cbz	r0, 0x7009ea60 <_ntoa_format+0x60> @ imm = #0x1e
7009ea40: e7ff         	b	0x7009ea42 <_ntoa_format+0x42> @ imm = #-0x2
7009ea42: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009ea46: 07c0         	lsls	r0, r0, #0x1f
7009ea48: b930         	cbnz	r0, 0x7009ea58 <_ntoa_format+0x58> @ imm = #0xc
7009ea4a: e7ff         	b	0x7009ea4c <_ntoa_format+0x4c> @ imm = #-0x2
7009ea4c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009ea50: f010 0f0c    	tst.w	r0, #0xc
7009ea54: d004         	beq	0x7009ea60 <_ntoa_format+0x60> @ imm = #0x8
7009ea56: e7ff         	b	0x7009ea58 <_ntoa_format+0x58> @ imm = #-0x2
;       width--;
7009ea58: 9815         	ldr	r0, [sp, #0x54]
7009ea5a: 3801         	subs	r0, #0x1
7009ea5c: 9015         	str	r0, [sp, #0x54]
;     }
7009ea5e: e7ff         	b	0x7009ea60 <_ntoa_format+0x60> @ imm = #-0x2
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009ea60: e7ff         	b	0x7009ea62 <_ntoa_format+0x62> @ imm = #-0x2
7009ea62: 9911         	ldr	r1, [sp, #0x44]
7009ea64: 9a14         	ldr	r2, [sp, #0x50]
7009ea66: 2000         	movs	r0, #0x0
7009ea68: 4291         	cmp	r1, r2
7009ea6a: 9006         	str	r0, [sp, #0x18]
7009ea6c: d207         	bhs	0x7009ea7e <_ntoa_format+0x7e> @ imm = #0xe
7009ea6e: e7ff         	b	0x7009ea70 <_ntoa_format+0x70> @ imm = #-0x2
7009ea70: 9911         	ldr	r1, [sp, #0x44]
7009ea72: 2000         	movs	r0, #0x0
7009ea74: 2920         	cmp	r1, #0x20
7009ea76: bf38         	it	lo
7009ea78: 2001         	movlo	r0, #0x1
7009ea7a: 9006         	str	r0, [sp, #0x18]
7009ea7c: e7ff         	b	0x7009ea7e <_ntoa_format+0x7e> @ imm = #-0x2
7009ea7e: 9806         	ldr	r0, [sp, #0x18]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009ea80: 07c0         	lsls	r0, r0, #0x1f
7009ea82: b138         	cbz	r0, 0x7009ea94 <_ntoa_format+0x94> @ imm = #0xe
7009ea84: e7ff         	b	0x7009ea86 <_ntoa_format+0x86> @ imm = #-0x2
;       buf[len++] = '0';
7009ea86: 9910         	ldr	r1, [sp, #0x40]
7009ea88: 9a11         	ldr	r2, [sp, #0x44]
7009ea8a: 1c50         	adds	r0, r2, #0x1
7009ea8c: 9011         	str	r0, [sp, #0x44]
7009ea8e: 2030         	movs	r0, #0x30
7009ea90: 5488         	strb	r0, [r1, r2]
;     while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009ea92: e7e6         	b	0x7009ea62 <_ntoa_format+0x62> @ imm = #-0x34
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009ea94: e7ff         	b	0x7009ea96 <_ntoa_format+0x96> @ imm = #-0x2
7009ea96: 2000         	movs	r0, #0x0
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009ea98: f89d 1058    	ldrb.w	r1, [sp, #0x58]
7009ea9c: ea4f 71c1    	lsl.w	r1, r1, #0x1f
7009eaa0: 9005         	str	r0, [sp, #0x14]
7009eaa2: b171         	cbz	r1, 0x7009eac2 <_ntoa_format+0xc2> @ imm = #0x1c
7009eaa4: e7ff         	b	0x7009eaa6 <_ntoa_format+0xa6> @ imm = #-0x2
7009eaa6: 9911         	ldr	r1, [sp, #0x44]
7009eaa8: 9a15         	ldr	r2, [sp, #0x54]
7009eaaa: 2000         	movs	r0, #0x0
7009eaac: 4291         	cmp	r1, r2
7009eaae: 9005         	str	r0, [sp, #0x14]
7009eab0: d207         	bhs	0x7009eac2 <_ntoa_format+0xc2> @ imm = #0xe
7009eab2: e7ff         	b	0x7009eab4 <_ntoa_format+0xb4> @ imm = #-0x2
7009eab4: 9911         	ldr	r1, [sp, #0x44]
7009eab6: 2000         	movs	r0, #0x0
7009eab8: 2920         	cmp	r1, #0x20
7009eaba: bf38         	it	lo
7009eabc: 2001         	movlo	r0, #0x1
7009eabe: 9005         	str	r0, [sp, #0x14]
7009eac0: e7ff         	b	0x7009eac2 <_ntoa_format+0xc2> @ imm = #-0x2
7009eac2: 9805         	ldr	r0, [sp, #0x14]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009eac4: 07c0         	lsls	r0, r0, #0x1f
7009eac6: b138         	cbz	r0, 0x7009ead8 <_ntoa_format+0xd8> @ imm = #0xe
7009eac8: e7ff         	b	0x7009eaca <_ntoa_format+0xca> @ imm = #-0x2
;       buf[len++] = '0';
7009eaca: 9910         	ldr	r1, [sp, #0x40]
7009eacc: 9a11         	ldr	r2, [sp, #0x44]
7009eace: 1c50         	adds	r0, r2, #0x1
7009ead0: 9011         	str	r0, [sp, #0x44]
7009ead2: 2030         	movs	r0, #0x30
7009ead4: 5488         	strb	r0, [r1, r2]
;     while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009ead6: e7de         	b	0x7009ea96 <_ntoa_format+0x96> @ imm = #-0x44
;   }
7009ead8: e7ff         	b	0x7009eada <_ntoa_format+0xda> @ imm = #-0x2
;   if (flags & FLAGS_HASH) {
7009eada: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009eade: 06c0         	lsls	r0, r0, #0x1b
7009eae0: 2800         	cmp	r0, #0x0
7009eae2: d569         	bpl	0x7009ebb8 <_ntoa_format+0x1b8> @ imm = #0xd2
7009eae4: e7ff         	b	0x7009eae6 <_ntoa_format+0xe6> @ imm = #-0x2
;     if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
7009eae6: f89d 0059    	ldrb.w	r0, [sp, #0x59]
7009eaea: 0740         	lsls	r0, r0, #0x1d
7009eaec: 2800         	cmp	r0, #0x0
7009eaee: d41c         	bmi	0x7009eb2a <_ntoa_format+0x12a> @ imm = #0x38
7009eaf0: e7ff         	b	0x7009eaf2 <_ntoa_format+0xf2> @ imm = #-0x2
7009eaf2: 9811         	ldr	r0, [sp, #0x44]
7009eaf4: b1c8         	cbz	r0, 0x7009eb2a <_ntoa_format+0x12a> @ imm = #0x32
7009eaf6: e7ff         	b	0x7009eaf8 <_ntoa_format+0xf8> @ imm = #-0x2
7009eaf8: 9811         	ldr	r0, [sp, #0x44]
7009eafa: 9914         	ldr	r1, [sp, #0x50]
7009eafc: 4288         	cmp	r0, r1
7009eafe: d005         	beq	0x7009eb0c <_ntoa_format+0x10c> @ imm = #0xa
7009eb00: e7ff         	b	0x7009eb02 <_ntoa_format+0x102> @ imm = #-0x2
7009eb02: 9811         	ldr	r0, [sp, #0x44]
7009eb04: 9915         	ldr	r1, [sp, #0x54]
7009eb06: 4288         	cmp	r0, r1
7009eb08: d10f         	bne	0x7009eb2a <_ntoa_format+0x12a> @ imm = #0x1e
7009eb0a: e7ff         	b	0x7009eb0c <_ntoa_format+0x10c> @ imm = #-0x2
;       len--;
7009eb0c: 9811         	ldr	r0, [sp, #0x44]
7009eb0e: 3801         	subs	r0, #0x1
7009eb10: 9011         	str	r0, [sp, #0x44]
;       if (len && (base == 16U)) {
7009eb12: 9811         	ldr	r0, [sp, #0x44]
7009eb14: b140         	cbz	r0, 0x7009eb28 <_ntoa_format+0x128> @ imm = #0x10
7009eb16: e7ff         	b	0x7009eb18 <_ntoa_format+0x118> @ imm = #-0x2
7009eb18: 9813         	ldr	r0, [sp, #0x4c]
7009eb1a: 2810         	cmp	r0, #0x10
7009eb1c: d104         	bne	0x7009eb28 <_ntoa_format+0x128> @ imm = #0x8
7009eb1e: e7ff         	b	0x7009eb20 <_ntoa_format+0x120> @ imm = #-0x2
;         len--;
7009eb20: 9811         	ldr	r0, [sp, #0x44]
7009eb22: 3801         	subs	r0, #0x1
7009eb24: 9011         	str	r0, [sp, #0x44]
;       }
7009eb26: e7ff         	b	0x7009eb28 <_ntoa_format+0x128> @ imm = #-0x2
;     }
7009eb28: e7ff         	b	0x7009eb2a <_ntoa_format+0x12a> @ imm = #-0x2
;     if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009eb2a: 9813         	ldr	r0, [sp, #0x4c]
7009eb2c: 2810         	cmp	r0, #0x10
7009eb2e: d111         	bne	0x7009eb54 <_ntoa_format+0x154> @ imm = #0x22
7009eb30: e7ff         	b	0x7009eb32 <_ntoa_format+0x132> @ imm = #-0x2
7009eb32: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009eb36: 0680         	lsls	r0, r0, #0x1a
7009eb38: 2800         	cmp	r0, #0x0
7009eb3a: d40b         	bmi	0x7009eb54 <_ntoa_format+0x154> @ imm = #0x16
7009eb3c: e7ff         	b	0x7009eb3e <_ntoa_format+0x13e> @ imm = #-0x2
7009eb3e: 9811         	ldr	r0, [sp, #0x44]
7009eb40: 281f         	cmp	r0, #0x1f
7009eb42: d807         	bhi	0x7009eb54 <_ntoa_format+0x154> @ imm = #0xe
7009eb44: e7ff         	b	0x7009eb46 <_ntoa_format+0x146> @ imm = #-0x2
;       buf[len++] = 'x';
7009eb46: 9910         	ldr	r1, [sp, #0x40]
7009eb48: 9a11         	ldr	r2, [sp, #0x44]
7009eb4a: 1c50         	adds	r0, r2, #0x1
7009eb4c: 9011         	str	r0, [sp, #0x44]
7009eb4e: 2078         	movs	r0, #0x78
7009eb50: 5488         	strb	r0, [r1, r2]
;     }
7009eb52: e025         	b	0x7009eba0 <_ntoa_format+0x1a0> @ imm = #0x4a
;     else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009eb54: 9813         	ldr	r0, [sp, #0x4c]
7009eb56: 2810         	cmp	r0, #0x10
7009eb58: d111         	bne	0x7009eb7e <_ntoa_format+0x17e> @ imm = #0x22
7009eb5a: e7ff         	b	0x7009eb5c <_ntoa_format+0x15c> @ imm = #-0x2
7009eb5c: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009eb60: 0680         	lsls	r0, r0, #0x1a
7009eb62: 2800         	cmp	r0, #0x0
7009eb64: d50b         	bpl	0x7009eb7e <_ntoa_format+0x17e> @ imm = #0x16
7009eb66: e7ff         	b	0x7009eb68 <_ntoa_format+0x168> @ imm = #-0x2
7009eb68: 9811         	ldr	r0, [sp, #0x44]
7009eb6a: 281f         	cmp	r0, #0x1f
7009eb6c: d807         	bhi	0x7009eb7e <_ntoa_format+0x17e> @ imm = #0xe
7009eb6e: e7ff         	b	0x7009eb70 <_ntoa_format+0x170> @ imm = #-0x2
;       buf[len++] = 'X';
7009eb70: 9910         	ldr	r1, [sp, #0x40]
7009eb72: 9a11         	ldr	r2, [sp, #0x44]
7009eb74: 1c50         	adds	r0, r2, #0x1
7009eb76: 9011         	str	r0, [sp, #0x44]
7009eb78: 2058         	movs	r0, #0x58
7009eb7a: 5488         	strb	r0, [r1, r2]
;     }
7009eb7c: e00f         	b	0x7009eb9e <_ntoa_format+0x19e> @ imm = #0x1e
;     else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
7009eb7e: 9813         	ldr	r0, [sp, #0x4c]
7009eb80: 2802         	cmp	r0, #0x2
7009eb82: d10b         	bne	0x7009eb9c <_ntoa_format+0x19c> @ imm = #0x16
7009eb84: e7ff         	b	0x7009eb86 <_ntoa_format+0x186> @ imm = #-0x2
7009eb86: 9811         	ldr	r0, [sp, #0x44]
7009eb88: 281f         	cmp	r0, #0x1f
7009eb8a: d807         	bhi	0x7009eb9c <_ntoa_format+0x19c> @ imm = #0xe
7009eb8c: e7ff         	b	0x7009eb8e <_ntoa_format+0x18e> @ imm = #-0x2
;       buf[len++] = 'b';
7009eb8e: 9910         	ldr	r1, [sp, #0x40]
7009eb90: 9a11         	ldr	r2, [sp, #0x44]
7009eb92: 1c50         	adds	r0, r2, #0x1
7009eb94: 9011         	str	r0, [sp, #0x44]
7009eb96: 2062         	movs	r0, #0x62
7009eb98: 5488         	strb	r0, [r1, r2]
;     }
7009eb9a: e7ff         	b	0x7009eb9c <_ntoa_format+0x19c> @ imm = #-0x2
7009eb9c: e7ff         	b	0x7009eb9e <_ntoa_format+0x19e> @ imm = #-0x2
7009eb9e: e7ff         	b	0x7009eba0 <_ntoa_format+0x1a0> @ imm = #-0x2
;     if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009eba0: 9811         	ldr	r0, [sp, #0x44]
7009eba2: 281f         	cmp	r0, #0x1f
7009eba4: d807         	bhi	0x7009ebb6 <_ntoa_format+0x1b6> @ imm = #0xe
7009eba6: e7ff         	b	0x7009eba8 <_ntoa_format+0x1a8> @ imm = #-0x2
;       buf[len++] = '0';
7009eba8: 9910         	ldr	r1, [sp, #0x40]
7009ebaa: 9a11         	ldr	r2, [sp, #0x44]
7009ebac: 1c50         	adds	r0, r2, #0x1
7009ebae: 9011         	str	r0, [sp, #0x44]
7009ebb0: 2030         	movs	r0, #0x30
7009ebb2: 5488         	strb	r0, [r1, r2]
;     }
7009ebb4: e7ff         	b	0x7009ebb6 <_ntoa_format+0x1b6> @ imm = #-0x2
;   }
7009ebb6: e7ff         	b	0x7009ebb8 <_ntoa_format+0x1b8> @ imm = #-0x2
;   if (len < PRINTF_NTOA_BUFFER_SIZE) {
7009ebb8: 9811         	ldr	r0, [sp, #0x44]
7009ebba: 281f         	cmp	r0, #0x1f
7009ebbc: d829         	bhi	0x7009ec12 <_ntoa_format+0x212> @ imm = #0x52
7009ebbe: e7ff         	b	0x7009ebc0 <_ntoa_format+0x1c0> @ imm = #-0x2
;     if (negative) {
7009ebc0: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
7009ebc4: 07c0         	lsls	r0, r0, #0x1f
7009ebc6: b138         	cbz	r0, 0x7009ebd8 <_ntoa_format+0x1d8> @ imm = #0xe
7009ebc8: e7ff         	b	0x7009ebca <_ntoa_format+0x1ca> @ imm = #-0x2
;       buf[len++] = '-';
7009ebca: 9910         	ldr	r1, [sp, #0x40]
7009ebcc: 9a11         	ldr	r2, [sp, #0x44]
7009ebce: 1c50         	adds	r0, r2, #0x1
7009ebd0: 9011         	str	r0, [sp, #0x44]
7009ebd2: 202d         	movs	r0, #0x2d
7009ebd4: 5488         	strb	r0, [r1, r2]
;     }
7009ebd6: e01b         	b	0x7009ec10 <_ntoa_format+0x210> @ imm = #0x36
;     else if (flags & FLAGS_PLUS) {
7009ebd8: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009ebdc: 0740         	lsls	r0, r0, #0x1d
7009ebde: 2800         	cmp	r0, #0x0
7009ebe0: d507         	bpl	0x7009ebf2 <_ntoa_format+0x1f2> @ imm = #0xe
7009ebe2: e7ff         	b	0x7009ebe4 <_ntoa_format+0x1e4> @ imm = #-0x2
;       buf[len++] = '+';  // ignore the space if the '+' exists
7009ebe4: 9910         	ldr	r1, [sp, #0x40]
7009ebe6: 9a11         	ldr	r2, [sp, #0x44]
7009ebe8: 1c50         	adds	r0, r2, #0x1
7009ebea: 9011         	str	r0, [sp, #0x44]
7009ebec: 202b         	movs	r0, #0x2b
7009ebee: 5488         	strb	r0, [r1, r2]
;     }
7009ebf0: e00d         	b	0x7009ec0e <_ntoa_format+0x20e> @ imm = #0x1a
;     else if (flags & FLAGS_SPACE) {
7009ebf2: f89d 0058    	ldrb.w	r0, [sp, #0x58]
7009ebf6: 0700         	lsls	r0, r0, #0x1c
7009ebf8: 2800         	cmp	r0, #0x0
7009ebfa: d507         	bpl	0x7009ec0c <_ntoa_format+0x20c> @ imm = #0xe
7009ebfc: e7ff         	b	0x7009ebfe <_ntoa_format+0x1fe> @ imm = #-0x2
;       buf[len++] = ' ';
7009ebfe: 9910         	ldr	r1, [sp, #0x40]
7009ec00: 9a11         	ldr	r2, [sp, #0x44]
7009ec02: 1c50         	adds	r0, r2, #0x1
7009ec04: 9011         	str	r0, [sp, #0x44]
7009ec06: 2020         	movs	r0, #0x20
7009ec08: 5488         	strb	r0, [r1, r2]
;     }
7009ec0a: e7ff         	b	0x7009ec0c <_ntoa_format+0x20c> @ imm = #-0x2
7009ec0c: e7ff         	b	0x7009ec0e <_ntoa_format+0x20e> @ imm = #-0x2
7009ec0e: e7ff         	b	0x7009ec10 <_ntoa_format+0x210> @ imm = #-0x2
;   }
7009ec10: e7ff         	b	0x7009ec12 <_ntoa_format+0x212> @ imm = #-0x2
;   return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
7009ec12: 980b         	ldr	r0, [sp, #0x2c]
7009ec14: 990a         	ldr	r1, [sp, #0x28]
7009ec16: 9a09         	ldr	r2, [sp, #0x24]
7009ec18: 9b08         	ldr	r3, [sp, #0x20]
7009ec1a: f8dd c040    	ldr.w	r12, [sp, #0x40]
7009ec1e: 9c11         	ldr	r4, [sp, #0x44]
7009ec20: 9d15         	ldr	r5, [sp, #0x54]
7009ec22: 9e16         	ldr	r6, [sp, #0x58]
7009ec24: 46ee         	mov	lr, sp
7009ec26: f8ce 600c    	str.w	r6, [lr, #0xc]
7009ec2a: f8ce 5008    	str.w	r5, [lr, #0x8]
7009ec2e: f8ce 4004    	str.w	r4, [lr, #0x4]
7009ec32: f8ce c000    	str.w	r12, [lr]
7009ec36: f008 fd23    	bl	0x700a7680 <_out_rev>   @ imm = #0x8a46
7009ec3a: b00c         	add	sp, #0x30
7009ec3c: bd70         	pop	{r4, r5, r6, pc}
7009ec3e: 0000         	movs	r0, r0

7009ec40 <Udma_eventRegister>:
; {
7009ec40: b5b0         	push	{r4, r5, r7, lr}
7009ec42: b088         	sub	sp, #0x20
7009ec44: 9007         	str	r0, [sp, #0x1c]
7009ec46: 9106         	str	r1, [sp, #0x18]
7009ec48: 9205         	str	r2, [sp, #0x14]
7009ec4a: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009ec4c: 9004         	str	r0, [sp, #0x10]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009ec4e: 9003         	str	r0, [sp, #0xc]
;     if((NULL_PTR == drvHandle) || (NULL_PTR == eventHandle) || (NULL_PTR == eventPrms))
7009ec50: 9807         	ldr	r0, [sp, #0x1c]
7009ec52: b130         	cbz	r0, 0x7009ec62 <Udma_eventRegister+0x22> @ imm = #0xc
7009ec54: e7ff         	b	0x7009ec56 <Udma_eventRegister+0x16> @ imm = #-0x2
7009ec56: 9806         	ldr	r0, [sp, #0x18]
7009ec58: b118         	cbz	r0, 0x7009ec62 <Udma_eventRegister+0x22> @ imm = #0x6
7009ec5a: e7ff         	b	0x7009ec5c <Udma_eventRegister+0x1c> @ imm = #-0x2
7009ec5c: 9805         	ldr	r0, [sp, #0x14]
7009ec5e: b920         	cbnz	r0, 0x7009ec6a <Udma_eventRegister+0x2a> @ imm = #0x8
7009ec60: e7ff         	b	0x7009ec62 <Udma_eventRegister+0x22> @ imm = #-0x2
7009ec62: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009ec66: 9004         	str	r0, [sp, #0x10]
;     }
7009ec68: e7ff         	b	0x7009ec6a <Udma_eventRegister+0x2a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ec6a: 9804         	ldr	r0, [sp, #0x10]
7009ec6c: b988         	cbnz	r0, 0x7009ec92 <Udma_eventRegister+0x52> @ imm = #0x22
7009ec6e: e7ff         	b	0x7009ec70 <Udma_eventRegister+0x30> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009ec70: 9807         	ldr	r0, [sp, #0x1c]
7009ec72: 9002         	str	r0, [sp, #0x8]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009ec74: 9802         	ldr	r0, [sp, #0x8]
7009ec76: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009ec7a: f64a 31cd    	movw	r1, #0xabcd
7009ec7e: f6ca 31dc    	movt	r1, #0xabdc
7009ec82: 4288         	cmp	r0, r1
7009ec84: d004         	beq	0x7009ec90 <Udma_eventRegister+0x50> @ imm = #0x8
7009ec86: e7ff         	b	0x7009ec88 <Udma_eventRegister+0x48> @ imm = #-0x2
7009ec88: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009ec8c: 9004         	str	r0, [sp, #0x10]
;         }
7009ec8e: e7ff         	b	0x7009ec90 <Udma_eventRegister+0x50> @ imm = #-0x2
;     }
7009ec90: e7ff         	b	0x7009ec92 <Udma_eventRegister+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ec92: 9804         	ldr	r0, [sp, #0x10]
7009ec94: b930         	cbnz	r0, 0x7009eca4 <Udma_eventRegister+0x64> @ imm = #0xc
7009ec96: e7ff         	b	0x7009ec98 <Udma_eventRegister+0x58> @ imm = #-0x2
;         retVal = Udma_eventCheckParams(drvHandleInt, eventPrms);
7009ec98: 9802         	ldr	r0, [sp, #0x8]
7009ec9a: 9905         	ldr	r1, [sp, #0x14]
7009ec9c: f006 fbb8    	bl	0x700a5410 <Udma_eventCheckParams> @ imm = #0x6770
7009eca0: 9004         	str	r0, [sp, #0x10]
;     }
7009eca2: e7ff         	b	0x7009eca4 <Udma_eventRegister+0x64> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009eca4: 9804         	ldr	r0, [sp, #0x10]
7009eca6: bbb0         	cbnz	r0, 0x7009ed16 <Udma_eventRegister+0xd6> @ imm = #0x6c
7009eca8: e7ff         	b	0x7009ecaa <Udma_eventRegister+0x6a> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
7009ecaa: 9806         	ldr	r0, [sp, #0x18]
7009ecac: 9001         	str	r0, [sp, #0x4]
;             &eventHandleInt->eventPrms, eventPrms, sizeof(eventHandleInt->eventPrms));
7009ecae: 9801         	ldr	r0, [sp, #0x4]
7009ecb0: 3008         	adds	r0, #0x8
7009ecb2: 9905         	ldr	r1, [sp, #0x14]
;         (void) memcpy(
7009ecb4: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009ecb8: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009ecbc: e8b1 501c    	ldm.w	r1!, {r2, r3, r4, r12, lr}
7009ecc0: e8a0 501c    	stm.w	r0!, {r2, r3, r4, r12, lr}
7009ecc4: e891 503c    	ldm.w	r1, {r2, r3, r4, r5, r12, lr}
7009ecc8: e880 503c    	stm.w	r0, {r2, r3, r4, r5, r12, lr}
;         eventHandleInt->drvHandle       = drvHandleInt;
7009eccc: 9802         	ldr	r0, [sp, #0x8]
7009ecce: 9901         	ldr	r1, [sp, #0x4]
7009ecd0: 6008         	str	r0, [r1]
;         eventHandleInt->globalEvent     = UDMA_EVENT_INVALID;
7009ecd2: 9901         	ldr	r1, [sp, #0x4]
7009ecd4: f64f 70ff    	movw	r0, #0xffff
7009ecd8: 6488         	str	r0, [r1, #0x48]
;         eventHandleInt->vintrNum        = UDMA_EVENT_INVALID;
7009ecda: 9901         	ldr	r1, [sp, #0x4]
7009ecdc: 64c8         	str	r0, [r1, #0x4c]
;         eventHandleInt->vintrBitNum     = UDMA_EVENT_INVALID;
7009ecde: 9901         	ldr	r1, [sp, #0x4]
7009ece0: 6508         	str	r0, [r1, #0x50]
;         eventHandleInt->irIntrNum       = UDMA_INTR_INVALID;
7009ece2: 9901         	ldr	r1, [sp, #0x4]
7009ece4: 2000         	movs	r0, #0x0
7009ece6: f6cf 70ff    	movt	r0, #0xffff
7009ecea: 6548         	str	r0, [r1, #0x54]
;         eventHandleInt->coreIntrNum     = UDMA_INTR_INVALID;
7009ecec: 9901         	ldr	r1, [sp, #0x4]
7009ecee: 6588         	str	r0, [r1, #0x58]
;         eventHandleInt->nextEvent       = (Udma_EventHandleInt) NULL_PTR;
7009ecf0: 9901         	ldr	r1, [sp, #0x4]
7009ecf2: 2000         	movs	r0, #0x0
7009ecf4: 65c8         	str	r0, [r1, #0x5c]
;         eventHandleInt->prevEvent       = (Udma_EventHandleInt) NULL_PTR;
7009ecf6: 9901         	ldr	r1, [sp, #0x4]
7009ecf8: 6608         	str	r0, [r1, #0x60]
;         eventHandleInt->hwiHandle       = NULL_PTR;
7009ecfa: 9901         	ldr	r1, [sp, #0x4]
7009ecfc: 6648         	str	r0, [r1, #0x64]
;         eventHandleInt->vintrBitAllocFlag = 0U;
7009ecfe: 9901         	ldr	r1, [sp, #0x4]
7009ed00: f8c1 008c    	str.w	r0, [r1, #0x8c]
7009ed04: f8c1 0088    	str.w	r0, [r1, #0x88]
;         eventHandleInt->pIaGeviRegs     = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
7009ed08: 9901         	ldr	r1, [sp, #0x4]
7009ed0a: f8c1 0090    	str.w	r0, [r1, #0x90]
;         eventHandleInt->pIaVintrRegs    = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
7009ed0e: 9901         	ldr	r1, [sp, #0x4]
7009ed10: f8c1 0094    	str.w	r0, [r1, #0x94]
;     }
7009ed14: e7ff         	b	0x7009ed16 <Udma_eventRegister+0xd6> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ed16: 9804         	ldr	r0, [sp, #0x10]
7009ed18: 2800         	cmp	r0, #0x0
7009ed1a: f040 809f    	bne.w	0x7009ee5c <Udma_eventRegister+0x21c> @ imm = #0x13e
7009ed1e: e7ff         	b	0x7009ed20 <Udma_eventRegister+0xe0> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009ed20: 9802         	ldr	r0, [sp, #0x8]
7009ed22: 6800         	ldr	r0, [r0]
7009ed24: b130         	cbz	r0, 0x7009ed34 <Udma_eventRegister+0xf4> @ imm = #0xc
7009ed26: e7ff         	b	0x7009ed28 <Udma_eventRegister+0xe8> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType))
7009ed28: 9805         	ldr	r0, [sp, #0x14]
7009ed2a: 6800         	ldr	r0, [r0]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandleInt->instType) &&
7009ed2c: 2802         	cmp	r0, #0x2
7009ed2e: d101         	bne	0x7009ed34 <Udma_eventRegister+0xf4> @ imm = #0x2
7009ed30: e7ff         	b	0x7009ed32 <Udma_eventRegister+0xf2> @ imm = #-0x2
;         }
7009ed32: e092         	b	0x7009ee5a <Udma_eventRegister+0x21a> @ imm = #0x124
;             retVal = Udma_eventAllocResource(drvHandleInt, eventHandleInt);
7009ed34: 9802         	ldr	r0, [sp, #0x8]
7009ed36: 9901         	ldr	r1, [sp, #0x4]
7009ed38: f000 f89a    	bl	0x7009ee70 <Udma_eventAllocResource> @ imm = #0x134
7009ed3c: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK == retVal)
7009ed3e: 9804         	ldr	r0, [sp, #0x10]
7009ed40: b918         	cbnz	r0, 0x7009ed4a <Udma_eventRegister+0x10a> @ imm = #0x6
7009ed42: e7ff         	b	0x7009ed44 <Udma_eventRegister+0x104> @ imm = #-0x2
7009ed44: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009ed46: 9003         	str	r0, [sp, #0xc]
;             }
7009ed48: e000         	b	0x7009ed4c <Udma_eventRegister+0x10c> @ imm = #0x0
7009ed4a: e7ff         	b	0x7009ed4c <Udma_eventRegister+0x10c> @ imm = #-0x2
;             if(UDMA_SOK == retVal)
7009ed4c: 9804         	ldr	r0, [sp, #0x10]
7009ed4e: b9a0         	cbnz	r0, 0x7009ed7a <Udma_eventRegister+0x13a> @ imm = #0x28
7009ed50: e7ff         	b	0x7009ed52 <Udma_eventRegister+0x112> @ imm = #-0x2
;                 eventHandleInt->eventInitDone = UDMA_INIT_DONE;
7009ed52: 9901         	ldr	r1, [sp, #0x4]
7009ed54: f64a 30cd    	movw	r0, #0xabcd
7009ed58: f6ca 30dc    	movt	r0, #0xabdc
7009ed5c: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 retVal = Udma_eventConfig(drvHandleInt, eventHandleInt);
7009ed60: 9802         	ldr	r0, [sp, #0x8]
7009ed62: 9901         	ldr	r1, [sp, #0x4]
7009ed64: f7fd fe14    	bl	0x7009c990 <Udma_eventConfig> @ imm = #-0x23d8
7009ed68: 9004         	str	r0, [sp, #0x10]
;                 if(UDMA_SOK == retVal)
7009ed6a: 9804         	ldr	r0, [sp, #0x10]
7009ed6c: b918         	cbnz	r0, 0x7009ed76 <Udma_eventRegister+0x136> @ imm = #0x6
7009ed6e: e7ff         	b	0x7009ed70 <Udma_eventRegister+0x130> @ imm = #-0x2
7009ed70: 2001         	movs	r0, #0x1
;                     allocDone = (uint32_t) TRUE;
7009ed72: 9003         	str	r0, [sp, #0xc]
;                 }
7009ed74: e000         	b	0x7009ed78 <Udma_eventRegister+0x138> @ imm = #0x0
7009ed76: e7ff         	b	0x7009ed78 <Udma_eventRegister+0x138> @ imm = #-0x2
;             }
7009ed78: e7ff         	b	0x7009ed7a <Udma_eventRegister+0x13a> @ imm = #-0x2
;             if(UDMA_SOK != retVal)
7009ed7a: 9804         	ldr	r0, [sp, #0x10]
7009ed7c: b170         	cbz	r0, 0x7009ed9c <Udma_eventRegister+0x15c> @ imm = #0x1c
7009ed7e: e7ff         	b	0x7009ed80 <Udma_eventRegister+0x140> @ imm = #-0x2
;                 if(((uint32_t) TRUE) == allocDone)
7009ed80: 9803         	ldr	r0, [sp, #0xc]
7009ed82: 2801         	cmp	r0, #0x1
7009ed84: d109         	bne	0x7009ed9a <Udma_eventRegister+0x15a> @ imm = #0x12
7009ed86: e7ff         	b	0x7009ed88 <Udma_eventRegister+0x148> @ imm = #-0x2
;                     Udma_eventFreeResource(drvHandleInt, eventHandleInt);
7009ed88: 9802         	ldr	r0, [sp, #0x8]
7009ed8a: 9901         	ldr	r1, [sp, #0x4]
7009ed8c: f006 ffb8    	bl	0x700a5d00 <Udma_eventFreeResource> @ imm = #0x6f70
;                     eventHandleInt->eventInitDone = UDMA_DEINIT_DONE;
7009ed90: 9901         	ldr	r1, [sp, #0x4]
7009ed92: 2000         	movs	r0, #0x0
7009ed94: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 }
7009ed98: e7ff         	b	0x7009ed9a <Udma_eventRegister+0x15a> @ imm = #-0x2
;             }
7009ed9a: e05d         	b	0x7009ee58 <Udma_eventRegister+0x218> @ imm = #0xba
;                 eventPrms->intrStatusReg    = &eventHandleInt->pIaVintrRegs->STATUSM;
7009ed9c: 9801         	ldr	r0, [sp, #0x4]
7009ed9e: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009eda2: 3020         	adds	r0, #0x20
7009eda4: 9905         	ldr	r1, [sp, #0x14]
7009eda6: 6248         	str	r0, [r1, #0x24]
;                 eventPrms->intrClearReg     = &eventHandleInt->pIaVintrRegs->STATUS_CLEAR;
7009eda8: 9801         	ldr	r0, [sp, #0x4]
7009edaa: f8d0 0094    	ldr.w	r0, [r0, #0x94]
7009edae: 3018         	adds	r0, #0x18
7009edb0: 9905         	ldr	r1, [sp, #0x14]
7009edb2: 6288         	str	r0, [r1, #0x28]
;                 if(eventHandleInt->vintrBitNum != UDMA_EVENT_INVALID)
7009edb4: 9801         	ldr	r0, [sp, #0x4]
7009edb6: 6d00         	ldr	r0, [r0, #0x50]
7009edb8: f64f 71ff    	movw	r1, #0xffff
7009edbc: 4288         	cmp	r0, r1
7009edbe: d017         	beq	0x7009edf0 <Udma_eventRegister+0x1b0> @ imm = #0x2e
7009edc0: e7ff         	b	0x7009edc2 <Udma_eventRegister+0x182> @ imm = #-0x2
;                     eventPrms->intrMask     = ((uint64_t)1U << eventHandleInt->vintrBitNum);
7009edc2: 9801         	ldr	r0, [sp, #0x4]
7009edc4: 6d03         	ldr	r3, [r0, #0x50]
7009edc6: f1a3 0120    	sub.w	r1, r3, #0x20
7009edca: 2201         	movs	r2, #0x1
7009edcc: fa02 fc01    	lsl.w	r12, r2, r1
7009edd0: f1c3 0020    	rsb.w	r0, r3, #0x20
7009edd4: fa22 f000    	lsr.w	r0, r2, r0
7009edd8: 2900         	cmp	r1, #0x0
7009edda: bf58         	it	pl
7009eddc: 4660         	movpl	r0, r12
7009edde: fa02 f203    	lsl.w	r2, r2, r3
7009ede2: 2900         	cmp	r1, #0x0
7009ede4: bf58         	it	pl
7009ede6: 2200         	movpl	r2, #0x0
7009ede8: 9905         	ldr	r1, [sp, #0x14]
7009edea: 630a         	str	r2, [r1, #0x30]
7009edec: 6348         	str	r0, [r1, #0x34]
;                 }
7009edee: e004         	b	0x7009edfa <Udma_eventRegister+0x1ba> @ imm = #0x8
;                     eventPrms->intrMask     = 0U;
7009edf0: 9905         	ldr	r1, [sp, #0x14]
7009edf2: 2000         	movs	r0, #0x0
7009edf4: 6348         	str	r0, [r1, #0x34]
7009edf6: 6308         	str	r0, [r1, #0x30]
7009edf8: e7ff         	b	0x7009edfa <Udma_eventRegister+0x1ba> @ imm = #-0x2
;                 if(NULL_PTR == eventHandleInt->eventPrms.controllerEventHandle)
7009edfa: 9801         	ldr	r0, [sp, #0x4]
7009edfc: 6980         	ldr	r0, [r0, #0x18]
7009edfe: b948         	cbnz	r0, 0x7009ee14 <Udma_eventRegister+0x1d4> @ imm = #0x12
7009ee00: e7ff         	b	0x7009ee02 <Udma_eventRegister+0x1c2> @ imm = #-0x2
;                     eventPrms->vintrNum     = eventHandleInt->vintrNum;
7009ee02: 9801         	ldr	r0, [sp, #0x4]
7009ee04: 6cc0         	ldr	r0, [r0, #0x4c]
7009ee06: 9905         	ldr	r1, [sp, #0x14]
7009ee08: 6388         	str	r0, [r1, #0x38]
;                     eventPrms->coreIntrNum  = eventHandleInt->coreIntrNum;
7009ee0a: 9801         	ldr	r0, [sp, #0x4]
7009ee0c: 6d80         	ldr	r0, [r0, #0x58]
7009ee0e: 9905         	ldr	r1, [sp, #0x14]
7009ee10: 63c8         	str	r0, [r1, #0x3c]
;                 }
7009ee12: e00a         	b	0x7009ee2a <Udma_eventRegister+0x1ea> @ imm = #0x14
;                        ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->vintrNum;
7009ee14: 9801         	ldr	r0, [sp, #0x4]
7009ee16: 6980         	ldr	r0, [r0, #0x18]
7009ee18: 6cc0         	ldr	r0, [r0, #0x4c]
;                     eventPrms->vintrNum       =
7009ee1a: 9905         	ldr	r1, [sp, #0x14]
7009ee1c: 6388         	str	r0, [r1, #0x38]
;                         ((Udma_EventHandleInt) (eventHandleInt->eventPrms.controllerEventHandle))->coreIntrNum;
7009ee1e: 9801         	ldr	r0, [sp, #0x4]
7009ee20: 6980         	ldr	r0, [r0, #0x18]
7009ee22: 6d80         	ldr	r0, [r0, #0x58]
;                     eventPrms->coreIntrNum    =
7009ee24: 9905         	ldr	r1, [sp, #0x14]
7009ee26: 63c8         	str	r0, [r1, #0x3c]
7009ee28: e7ff         	b	0x7009ee2a <Udma_eventRegister+0x1ea> @ imm = #-0x2
;                 eventHandleInt->eventPrms.intrStatusReg   = eventPrms->intrStatusReg;
7009ee2a: 9805         	ldr	r0, [sp, #0x14]
7009ee2c: 6a40         	ldr	r0, [r0, #0x24]
7009ee2e: 9901         	ldr	r1, [sp, #0x4]
7009ee30: 62c8         	str	r0, [r1, #0x2c]
;                 eventHandleInt->eventPrms.intrClearReg    = eventPrms->intrClearReg;
7009ee32: 9805         	ldr	r0, [sp, #0x14]
7009ee34: 6a80         	ldr	r0, [r0, #0x28]
7009ee36: 9901         	ldr	r1, [sp, #0x4]
7009ee38: 6308         	str	r0, [r1, #0x30]
;                 eventHandleInt->eventPrms.intrMask        = eventPrms->intrMask;
7009ee3a: 9905         	ldr	r1, [sp, #0x14]
7009ee3c: 6b08         	ldr	r0, [r1, #0x30]
7009ee3e: 6b4a         	ldr	r2, [r1, #0x34]
7009ee40: 9901         	ldr	r1, [sp, #0x4]
7009ee42: 63ca         	str	r2, [r1, #0x3c]
7009ee44: 6388         	str	r0, [r1, #0x38]
;                 eventHandleInt->eventPrms.vintrNum        = eventPrms->vintrNum;
7009ee46: 9805         	ldr	r0, [sp, #0x14]
7009ee48: 6b80         	ldr	r0, [r0, #0x38]
7009ee4a: 9901         	ldr	r1, [sp, #0x4]
7009ee4c: 6408         	str	r0, [r1, #0x40]
;                 eventHandleInt->eventPrms.coreIntrNum     = eventPrms->coreIntrNum;
7009ee4e: 9805         	ldr	r0, [sp, #0x14]
7009ee50: 6bc0         	ldr	r0, [r0, #0x3c]
7009ee52: 9901         	ldr	r1, [sp, #0x4]
7009ee54: 6448         	str	r0, [r1, #0x44]
7009ee56: e7ff         	b	0x7009ee58 <Udma_eventRegister+0x218> @ imm = #-0x2
7009ee58: e7ff         	b	0x7009ee5a <Udma_eventRegister+0x21a> @ imm = #-0x2
;     }
7009ee5a: e7ff         	b	0x7009ee5c <Udma_eventRegister+0x21c> @ imm = #-0x2
;     return (retVal);
7009ee5c: 9804         	ldr	r0, [sp, #0x10]
7009ee5e: b008         	add	sp, #0x20
7009ee60: bdb0         	pop	{r4, r5, r7, pc}
		...
7009ee6e: 0000         	movs	r0, r0

7009ee70 <Udma_eventAllocResource>:
; {
7009ee70: b580         	push	{r7, lr}
7009ee72: b08a         	sub	sp, #0x28
7009ee74: 9009         	str	r0, [sp, #0x24]
7009ee76: 9108         	str	r1, [sp, #0x20]
7009ee78: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
7009ee7a: 9007         	str	r0, [sp, #0x1c]
;     eventPrms = &eventHandle->eventPrms;
7009ee7c: 9808         	ldr	r0, [sp, #0x20]
7009ee7e: 3008         	adds	r0, #0x8
7009ee80: 9004         	str	r0, [sp, #0x10]
;     if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009ee82: 9804         	ldr	r0, [sp, #0x10]
7009ee84: 6800         	ldr	r0, [r0]
7009ee86: 2805         	cmp	r0, #0x5
7009ee88: d01b         	beq	0x7009eec2 <Udma_eventAllocResource+0x52> @ imm = #0x36
7009ee8a: e7ff         	b	0x7009ee8c <Udma_eventAllocResource+0x1c> @ imm = #-0x2
;         eventHandle->globalEvent = Udma_rmAllocEvent(drvHandle);
7009ee8c: 9809         	ldr	r0, [sp, #0x24]
7009ee8e: f009 fe7f    	bl	0x700a8b90 <Udma_rmAllocEvent> @ imm = #0x9cfe
7009ee92: 9908         	ldr	r1, [sp, #0x20]
7009ee94: 6488         	str	r0, [r1, #0x48]
;         if(UDMA_EVENT_INVALID == eventHandle->globalEvent)
7009ee96: 9808         	ldr	r0, [sp, #0x20]
7009ee98: 6c80         	ldr	r0, [r0, #0x48]
7009ee9a: f64f 71ff    	movw	r1, #0xffff
7009ee9e: 4288         	cmp	r0, r1
7009eea0: d104         	bne	0x7009eeac <Udma_eventAllocResource+0x3c> @ imm = #0x8
7009eea2: e7ff         	b	0x7009eea4 <Udma_eventAllocResource+0x34> @ imm = #-0x2
7009eea4: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
7009eea8: 9007         	str	r0, [sp, #0x1c]
;         }
7009eeaa: e009         	b	0x7009eec0 <Udma_eventAllocResource+0x50> @ imm = #0x12
;                 &drvHandle->iaRegs.pImapRegs->GEVI[eventHandle->globalEvent];
7009eeac: 9809         	ldr	r0, [sp, #0x24]
7009eeae: f8d0 00a0    	ldr.w	r0, [r0, #0xa0]
7009eeb2: 9908         	ldr	r1, [sp, #0x20]
7009eeb4: 6c8a         	ldr	r2, [r1, #0x48]
7009eeb6: eb00 00c2    	add.w	r0, r0, r2, lsl #3
;             eventHandle->pIaGeviRegs =
7009eeba: f8c1 0090    	str.w	r0, [r1, #0x90]
7009eebe: e7ff         	b	0x7009eec0 <Udma_eventAllocResource+0x50> @ imm = #-0x2
;     }
7009eec0: e7ff         	b	0x7009eec2 <Udma_eventAllocResource+0x52> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009eec2: 9807         	ldr	r0, [sp, #0x1c]
7009eec4: bb00         	cbnz	r0, 0x7009ef08 <Udma_eventAllocResource+0x98> @ imm = #0x40
7009eec6: e7ff         	b	0x7009eec8 <Udma_eventAllocResource+0x58> @ imm = #-0x2
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009eec8: 9804         	ldr	r0, [sp, #0x10]
7009eeca: 6840         	ldr	r0, [r0, #0x4]
7009eecc: 2801         	cmp	r0, #0x1
7009eece: d009         	beq	0x7009eee4 <Udma_eventAllocResource+0x74> @ imm = #0x12
7009eed0: e7ff         	b	0x7009eed2 <Udma_eventAllocResource+0x62> @ imm = #-0x2
;             ((UDMA_EVENT_MODE_SHARED == eventPrms->eventMode) &&
7009eed2: 9804         	ldr	r0, [sp, #0x10]
7009eed4: 6840         	ldr	r0, [r0, #0x4]
7009eed6: 2802         	cmp	r0, #0x2
7009eed8: d115         	bne	0x7009ef06 <Udma_eventAllocResource+0x96> @ imm = #0x2a
7009eeda: e7ff         	b	0x7009eedc <Udma_eventAllocResource+0x6c> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)))
7009eedc: 9804         	ldr	r0, [sp, #0x10]
7009eede: 6900         	ldr	r0, [r0, #0x10]
;         if((UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode) ||
7009eee0: b988         	cbnz	r0, 0x7009ef06 <Udma_eventAllocResource+0x96> @ imm = #0x22
7009eee2: e7ff         	b	0x7009eee4 <Udma_eventAllocResource+0x74> @ imm = #-0x2
;             eventHandle->vintrNum = Udma_rmAllocVintr(drvHandle);
7009eee4: 9809         	ldr	r0, [sp, #0x24]
7009eee6: f009 fea3    	bl	0x700a8c30 <Udma_rmAllocVintr> @ imm = #0x9d46
7009eeea: 9908         	ldr	r1, [sp, #0x20]
7009eeec: 64c8         	str	r0, [r1, #0x4c]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrNum)
7009eeee: 9808         	ldr	r0, [sp, #0x20]
7009eef0: 6cc0         	ldr	r0, [r0, #0x4c]
7009eef2: f64f 71ff    	movw	r1, #0xffff
7009eef6: 4288         	cmp	r0, r1
7009eef8: d104         	bne	0x7009ef04 <Udma_eventAllocResource+0x94> @ imm = #0x8
7009eefa: e7ff         	b	0x7009eefc <Udma_eventAllocResource+0x8c> @ imm = #-0x2
7009eefc: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009ef00: 9007         	str	r0, [sp, #0x1c]
;             }
7009ef02: e7ff         	b	0x7009ef04 <Udma_eventAllocResource+0x94> @ imm = #-0x2
;         }
7009ef04: e7ff         	b	0x7009ef06 <Udma_eventAllocResource+0x96> @ imm = #-0x2
;     }
7009ef06: e7ff         	b	0x7009ef08 <Udma_eventAllocResource+0x98> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ef08: 9807         	ldr	r0, [sp, #0x1c]
7009ef0a: b9b8         	cbnz	r0, 0x7009ef3c <Udma_eventAllocResource+0xcc> @ imm = #0x2e
7009ef0c: e7ff         	b	0x7009ef0e <Udma_eventAllocResource+0x9e> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventPrms->eventType)
7009ef0e: 9804         	ldr	r0, [sp, #0x10]
7009ef10: 6800         	ldr	r0, [r0]
7009ef12: 2805         	cmp	r0, #0x5
7009ef14: d011         	beq	0x7009ef3a <Udma_eventAllocResource+0xca> @ imm = #0x22
7009ef16: e7ff         	b	0x7009ef18 <Udma_eventAllocResource+0xa8> @ imm = #-0x2
;             eventHandle->vintrBitNum = Udma_rmAllocVintrBit(eventHandle);
7009ef18: 9808         	ldr	r0, [sp, #0x20]
7009ef1a: f007 fe09    	bl	0x700a6b30 <Udma_rmAllocVintrBit> @ imm = #0x7c12
7009ef1e: 9908         	ldr	r1, [sp, #0x20]
7009ef20: 6508         	str	r0, [r1, #0x50]
;             if(UDMA_EVENT_INVALID == eventHandle->vintrBitNum)
7009ef22: 9808         	ldr	r0, [sp, #0x20]
7009ef24: 6d00         	ldr	r0, [r0, #0x50]
7009ef26: f64f 71ff    	movw	r1, #0xffff
7009ef2a: 4288         	cmp	r0, r1
7009ef2c: d104         	bne	0x7009ef38 <Udma_eventAllocResource+0xc8> @ imm = #0x8
7009ef2e: e7ff         	b	0x7009ef30 <Udma_eventAllocResource+0xc0> @ imm = #-0x2
7009ef30: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009ef34: 9007         	str	r0, [sp, #0x1c]
;             }
7009ef36: e7ff         	b	0x7009ef38 <Udma_eventAllocResource+0xc8> @ imm = #-0x2
;         }
7009ef38: e7ff         	b	0x7009ef3a <Udma_eventAllocResource+0xca> @ imm = #-0x2
;     }
7009ef3a: e7ff         	b	0x7009ef3c <Udma_eventAllocResource+0xcc> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009ef3c: 9807         	ldr	r0, [sp, #0x1c]
7009ef3e: 2800         	cmp	r0, #0x0
7009ef40: d146         	bne	0x7009efd0 <Udma_eventAllocResource+0x160> @ imm = #0x8c
7009ef42: e7ff         	b	0x7009ef44 <Udma_eventAllocResource+0xd4> @ imm = #-0x2
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009ef44: 9804         	ldr	r0, [sp, #0x10]
7009ef46: 6940         	ldr	r0, [r0, #0x14]
7009ef48: b120         	cbz	r0, 0x7009ef54 <Udma_eventAllocResource+0xe4> @ imm = #0x8
7009ef4a: e7ff         	b	0x7009ef4c <Udma_eventAllocResource+0xdc> @ imm = #-0x2
;                 (NULL_PTR == eventPrms->controllerEventHandle)) ||
7009ef4c: 9804         	ldr	r0, [sp, #0x10]
7009ef4e: 6900         	ldr	r0, [r0, #0x10]
7009ef50: b128         	cbz	r0, 0x7009ef5e <Udma_eventAllocResource+0xee> @ imm = #0xa
7009ef52: e7ff         	b	0x7009ef54 <Udma_eventAllocResource+0xe4> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_MASTER == eventPrms->eventType))
7009ef54: 9804         	ldr	r0, [sp, #0x10]
7009ef56: 6800         	ldr	r0, [r0]
;         if((((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
7009ef58: 2805         	cmp	r0, #0x5
7009ef5a: d138         	bne	0x7009efce <Udma_eventAllocResource+0x15e> @ imm = #0x70
7009ef5c: e7ff         	b	0x7009ef5e <Udma_eventAllocResource+0xee> @ imm = #-0x2
;             if(UDMA_CORE_INTR_ANY != eventPrms->preferredCoreIntrNum)
7009ef5e: 9804         	ldr	r0, [sp, #0x10]
7009ef60: 6a00         	ldr	r0, [r0, #0x20]
7009ef62: 2101         	movs	r1, #0x1
7009ef64: f6cf 71ff    	movt	r1, #0xffff
7009ef68: 4288         	cmp	r0, r1
7009ef6a: d007         	beq	0x7009ef7c <Udma_eventAllocResource+0x10c> @ imm = #0xe
7009ef6c: e7ff         	b	0x7009ef6e <Udma_eventAllocResource+0xfe> @ imm = #-0x2
;                 preferredIrIntrNum = Udma_rmTranslateCoreIntrInput(drvHandle, eventPrms->preferredCoreIntrNum);
7009ef6e: 9809         	ldr	r0, [sp, #0x24]
7009ef70: 9904         	ldr	r1, [sp, #0x10]
7009ef72: 6a09         	ldr	r1, [r1, #0x20]
7009ef74: f010 f9a4    	bl	0x700af2c0 <Udma_rmTranslateCoreIntrInput> @ imm = #0x10348
7009ef78: 9005         	str	r0, [sp, #0x14]
;             }
7009ef7a: e003         	b	0x7009ef84 <Udma_eventAllocResource+0x114> @ imm = #0x6
;                 preferredIrIntrNum = eventPrms->preferredCoreIntrNum;
7009ef7c: 9804         	ldr	r0, [sp, #0x10]
7009ef7e: 6a00         	ldr	r0, [r0, #0x20]
7009ef80: 9005         	str	r0, [sp, #0x14]
7009ef82: e7ff         	b	0x7009ef84 <Udma_eventAllocResource+0x114> @ imm = #-0x2
;             if(UDMA_INTR_INVALID != preferredIrIntrNum)
7009ef84: 9805         	ldr	r0, [sp, #0x14]
7009ef86: f510 3f80    	cmn.w	r0, #0x10000
7009ef8a: d015         	beq	0x7009efb8 <Udma_eventAllocResource+0x148> @ imm = #0x2a
7009ef8c: e7ff         	b	0x7009ef8e <Udma_eventAllocResource+0x11e> @ imm = #-0x2
;                     Udma_rmAllocIrIntr(preferredIrIntrNum, drvHandle);
7009ef8e: 9805         	ldr	r0, [sp, #0x14]
7009ef90: 9909         	ldr	r1, [sp, #0x24]
7009ef92: f004 f915    	bl	0x700a31c0 <Udma_rmAllocIrIntr> @ imm = #0x422a
;                 eventHandle->irIntrNum =
7009ef96: 9908         	ldr	r1, [sp, #0x20]
7009ef98: 6548         	str	r0, [r1, #0x54]
;                 if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
7009ef9a: 9808         	ldr	r0, [sp, #0x20]
7009ef9c: 6d40         	ldr	r0, [r0, #0x54]
7009ef9e: f510 3f80    	cmn.w	r0, #0x10000
7009efa2: d008         	beq	0x7009efb6 <Udma_eventAllocResource+0x146> @ imm = #0x10
7009efa4: e7ff         	b	0x7009efa6 <Udma_eventAllocResource+0x136> @ imm = #-0x2
;                     eventHandle->coreIntrNum = Udma_rmTranslateIrOutput(drvHandle, eventHandle->irIntrNum);
7009efa6: 9809         	ldr	r0, [sp, #0x24]
7009efa8: 9908         	ldr	r1, [sp, #0x20]
7009efaa: 6d49         	ldr	r1, [r1, #0x54]
7009efac: f010 f9a0    	bl	0x700af2f0 <Udma_rmTranslateIrOutput> @ imm = #0x10340
7009efb0: 9908         	ldr	r1, [sp, #0x20]
7009efb2: 6588         	str	r0, [r1, #0x58]
;                 }
7009efb4: e7ff         	b	0x7009efb6 <Udma_eventAllocResource+0x146> @ imm = #-0x2
;             }
7009efb6: e7ff         	b	0x7009efb8 <Udma_eventAllocResource+0x148> @ imm = #-0x2
;             if(UDMA_INTR_INVALID == eventHandle->coreIntrNum)
7009efb8: 9808         	ldr	r0, [sp, #0x20]
7009efba: 6d80         	ldr	r0, [r0, #0x58]
7009efbc: f510 3f80    	cmn.w	r0, #0x10000
7009efc0: d104         	bne	0x7009efcc <Udma_eventAllocResource+0x15c> @ imm = #0x8
7009efc2: e7ff         	b	0x7009efc4 <Udma_eventAllocResource+0x154> @ imm = #-0x2
7009efc4: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009efc8: 9007         	str	r0, [sp, #0x1c]
;             }
7009efca: e7ff         	b	0x7009efcc <Udma_eventAllocResource+0x15c> @ imm = #-0x2
;         }
7009efcc: e7ff         	b	0x7009efce <Udma_eventAllocResource+0x15e> @ imm = #-0x2
;     }
7009efce: e7ff         	b	0x7009efd0 <Udma_eventAllocResource+0x160> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009efd0: 9807         	ldr	r0, [sp, #0x1c]
7009efd2: bb18         	cbnz	r0, 0x7009f01c <Udma_eventAllocResource+0x1ac> @ imm = #0x46
7009efd4: e7ff         	b	0x7009efd6 <Udma_eventAllocResource+0x166> @ imm = #-0x2
;         cookie = HwiP_disable();
7009efd6: f011 ecc4    	blx	0x700b0960 <HwiP_disable> @ imm = #0x11988
7009efda: 9002         	str	r0, [sp, #0x8]
;         eventHandle->prevEvent = (Udma_EventHandleInt) NULL_PTR;
7009efdc: 9908         	ldr	r1, [sp, #0x20]
7009efde: 2000         	movs	r0, #0x0
7009efe0: 6608         	str	r0, [r1, #0x60]
;         eventHandle->nextEvent = (Udma_EventHandleInt) NULL_PTR;
7009efe2: 9908         	ldr	r1, [sp, #0x20]
7009efe4: 65c8         	str	r0, [r1, #0x5c]
;         if(NULL_PTR != eventPrms->controllerEventHandle)
7009efe6: 9804         	ldr	r0, [sp, #0x10]
7009efe8: 6900         	ldr	r0, [r0, #0x10]
7009efea: b198         	cbz	r0, 0x7009f014 <Udma_eventAllocResource+0x1a4> @ imm = #0x26
7009efec: e7ff         	b	0x7009efee <Udma_eventAllocResource+0x17e> @ imm = #-0x2
;             lastEvent = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
7009efee: 9804         	ldr	r0, [sp, #0x10]
7009eff0: 6900         	ldr	r0, [r0, #0x10]
7009eff2: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009eff4: e7ff         	b	0x7009eff6 <Udma_eventAllocResource+0x186> @ imm = #-0x2
7009eff6: 9803         	ldr	r0, [sp, #0xc]
7009eff8: 6dc0         	ldr	r0, [r0, #0x5c]
7009effa: b120         	cbz	r0, 0x7009f006 <Udma_eventAllocResource+0x196> @ imm = #0x8
7009effc: e7ff         	b	0x7009effe <Udma_eventAllocResource+0x18e> @ imm = #-0x2
;                 lastEvent = lastEvent->nextEvent;
7009effe: 9803         	ldr	r0, [sp, #0xc]
7009f000: 6dc0         	ldr	r0, [r0, #0x5c]
7009f002: 9003         	str	r0, [sp, #0xc]
;             while(NULL_PTR != lastEvent->nextEvent)
7009f004: e7f7         	b	0x7009eff6 <Udma_eventAllocResource+0x186> @ imm = #-0x12
;             eventHandle->prevEvent = lastEvent;
7009f006: 9803         	ldr	r0, [sp, #0xc]
7009f008: 9908         	ldr	r1, [sp, #0x20]
7009f00a: 6608         	str	r0, [r1, #0x60]
;             lastEvent->nextEvent   = eventHandle;
7009f00c: 9808         	ldr	r0, [sp, #0x20]
7009f00e: 9903         	ldr	r1, [sp, #0xc]
7009f010: 65c8         	str	r0, [r1, #0x5c]
;         }
7009f012: e7ff         	b	0x7009f014 <Udma_eventAllocResource+0x1a4> @ imm = #-0x2
;         HwiP_restore(cookie);
7009f014: 9802         	ldr	r0, [sp, #0x8]
7009f016: f011 ecc4    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x11988
;     }
7009f01a: e7ff         	b	0x7009f01c <Udma_eventAllocResource+0x1ac> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f01c: 9807         	ldr	r0, [sp, #0x1c]
7009f01e: b9a0         	cbnz	r0, 0x7009f04a <Udma_eventAllocResource+0x1da> @ imm = #0x28
7009f020: e7ff         	b	0x7009f022 <Udma_eventAllocResource+0x1b2> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
7009f022: 9804         	ldr	r0, [sp, #0x10]
7009f024: 6800         	ldr	r0, [r0]
7009f026: 2803         	cmp	r0, #0x3
7009f028: d10e         	bne	0x7009f048 <Udma_eventAllocResource+0x1d8> @ imm = #0x1c
7009f02a: e7ff         	b	0x7009f02c <Udma_eventAllocResource+0x1bc> @ imm = #-0x2
;             chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
7009f02c: 9804         	ldr	r0, [sp, #0x10]
7009f02e: 6880         	ldr	r0, [r0, #0x8]
7009f030: 9001         	str	r0, [sp, #0x4]
;             if(TRUE == chHandle->chOesAllocDone)
7009f032: 9801         	ldr	r0, [sp, #0x4]
7009f034: f8d0 0248    	ldr.w	r0, [r0, #0x248]
7009f038: 2801         	cmp	r0, #0x1
7009f03a: d104         	bne	0x7009f046 <Udma_eventAllocResource+0x1d6> @ imm = #0x8
7009f03c: e7ff         	b	0x7009f03e <Udma_eventAllocResource+0x1ce> @ imm = #-0x2
7009f03e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009f042: 9007         	str	r0, [sp, #0x1c]
;             }
7009f044: e7ff         	b	0x7009f046 <Udma_eventAllocResource+0x1d6> @ imm = #-0x2
;         }
7009f046: e7ff         	b	0x7009f048 <Udma_eventAllocResource+0x1d8> @ imm = #-0x2
;     }
7009f048: e7ff         	b	0x7009f04a <Udma_eventAllocResource+0x1da> @ imm = #-0x2
;     if(UDMA_SOK != retVal)
7009f04a: 9807         	ldr	r0, [sp, #0x1c]
7009f04c: b128         	cbz	r0, 0x7009f05a <Udma_eventAllocResource+0x1ea> @ imm = #0xa
7009f04e: e7ff         	b	0x7009f050 <Udma_eventAllocResource+0x1e0> @ imm = #-0x2
;         Udma_eventFreeResource(drvHandle, eventHandle);
7009f050: 9809         	ldr	r0, [sp, #0x24]
7009f052: 9908         	ldr	r1, [sp, #0x20]
7009f054: f006 fe54    	bl	0x700a5d00 <Udma_eventFreeResource> @ imm = #0x6ca8
;     }
7009f058: e016         	b	0x7009f088 <Udma_eventAllocResource+0x218> @ imm = #0x2c
;         if(NULL_PTR == eventPrms->controllerEventHandle)
7009f05a: 9804         	ldr	r0, [sp, #0x10]
7009f05c: 6900         	ldr	r0, [r0, #0x10]
7009f05e: b920         	cbnz	r0, 0x7009f06a <Udma_eventAllocResource+0x1fa> @ imm = #0x8
7009f060: e7ff         	b	0x7009f062 <Udma_eventAllocResource+0x1f2> @ imm = #-0x2
;             vintrNum = eventHandle->vintrNum;
7009f062: 9808         	ldr	r0, [sp, #0x20]
7009f064: 6cc0         	ldr	r0, [r0, #0x4c]
7009f066: 9006         	str	r0, [sp, #0x18]
;         }
7009f068: e004         	b	0x7009f074 <Udma_eventAllocResource+0x204> @ imm = #0x8
;             vintrNum = ((Udma_EventHandleInt) (eventPrms->controllerEventHandle))->vintrNum;
7009f06a: 9804         	ldr	r0, [sp, #0x10]
7009f06c: 6900         	ldr	r0, [r0, #0x10]
7009f06e: 6cc0         	ldr	r0, [r0, #0x4c]
7009f070: 9006         	str	r0, [sp, #0x18]
7009f072: e7ff         	b	0x7009f074 <Udma_eventAllocResource+0x204> @ imm = #-0x2
;         eventHandle->pIaVintrRegs = &drvHandle->iaRegs.pIntrRegs->VINT[vintrNum];
7009f074: 9809         	ldr	r0, [sp, #0x24]
7009f076: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
7009f07a: 9906         	ldr	r1, [sp, #0x18]
7009f07c: eb00 3001    	add.w	r0, r0, r1, lsl #12
7009f080: 9908         	ldr	r1, [sp, #0x20]
7009f082: f8c1 0094    	str.w	r0, [r1, #0x94]
7009f086: e7ff         	b	0x7009f088 <Udma_eventAllocResource+0x218> @ imm = #-0x2
;     return (retVal);
7009f088: 9807         	ldr	r0, [sp, #0x1c]
7009f08a: b00a         	add	sp, #0x28
7009f08c: bd80         	pop	{r7, pc}
7009f08e: 0000         	movs	r0, r0

7009f090 <Udma_chFreeResource>:
; {
7009f090: b580         	push	{r7, lr}
7009f092: b084         	sub	sp, #0x10
7009f094: 9003         	str	r0, [sp, #0xc]
7009f096: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f098: 9002         	str	r0, [sp, #0x8]
;     drvHandle = chHandle->drvHandle;
7009f09a: 9803         	ldr	r0, [sp, #0xc]
7009f09c: 6e80         	ldr	r0, [r0, #0x68]
7009f09e: 9001         	str	r0, [sp, #0x4]
;     if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
7009f0a0: 9803         	ldr	r0, [sp, #0xc]
7009f0a2: 7800         	ldrb	r0, [r0]
7009f0a4: 0740         	lsls	r0, r0, #0x1d
7009f0a6: 2800         	cmp	r0, #0x0
7009f0a8: d52e         	bpl	0x7009f108 <Udma_chFreeResource+0x78> @ imm = #0x5c
7009f0aa: e7ff         	b	0x7009f0ac <Udma_chFreeResource+0x1c> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009f0ac: 9803         	ldr	r0, [sp, #0xc]
7009f0ae: 6ec0         	ldr	r0, [r0, #0x6c]
7009f0b0: f510 3f80    	cmn.w	r0, #0x10000
7009f0b4: d027         	beq	0x7009f106 <Udma_chFreeResource+0x76> @ imm = #0x4e
7009f0b6: e7ff         	b	0x7009f0b8 <Udma_chFreeResource+0x28> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009f0b8: 9803         	ldr	r0, [sp, #0xc]
7009f0ba: 7800         	ldrb	r0, [r0]
7009f0bc: 0640         	lsls	r0, r0, #0x19
7009f0be: 2800         	cmp	r0, #0x0
7009f0c0: d506         	bpl	0x7009f0d0 <Udma_chFreeResource+0x40> @ imm = #0xc
7009f0c2: e7ff         	b	0x7009f0c4 <Udma_chFreeResource+0x34> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyHcCh(chHandle->txChNum, drvHandle);
7009f0c4: 9803         	ldr	r0, [sp, #0xc]
7009f0c6: 6ec0         	ldr	r0, [r0, #0x6c]
7009f0c8: 9901         	ldr	r1, [sp, #0x4]
7009f0ca: f00c ffb9    	bl	0x700ac040 <Udma_rmFreeBlkCopyHcCh> @ imm = #0xcf72
;             }
7009f0ce: e012         	b	0x7009f0f6 <Udma_chFreeResource+0x66> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009f0d0: 9803         	ldr	r0, [sp, #0xc]
7009f0d2: 7800         	ldrb	r0, [r0]
7009f0d4: 0600         	lsls	r0, r0, #0x18
7009f0d6: 2800         	cmp	r0, #0x0
7009f0d8: d506         	bpl	0x7009f0e8 <Udma_chFreeResource+0x58> @ imm = #0xc
7009f0da: e7ff         	b	0x7009f0dc <Udma_chFreeResource+0x4c> @ imm = #-0x2
;                 Udma_rmFreeBlkCopyUhcCh(chHandle->txChNum, drvHandle);
7009f0dc: 9803         	ldr	r0, [sp, #0xc]
7009f0de: 6ec0         	ldr	r0, [r0, #0x6c]
7009f0e0: 9901         	ldr	r1, [sp, #0x4]
7009f0e2: f00c ffe5    	bl	0x700ac0b0 <Udma_rmFreeBlkCopyUhcCh> @ imm = #0xcfca
;             }
7009f0e6: e005         	b	0x7009f0f4 <Udma_chFreeResource+0x64> @ imm = #0xa
;                 Udma_rmFreeBlkCopyCh(chHandle->txChNum, drvHandle);
7009f0e8: 9803         	ldr	r0, [sp, #0xc]
7009f0ea: 6ec0         	ldr	r0, [r0, #0x6c]
7009f0ec: 9901         	ldr	r1, [sp, #0x4]
7009f0ee: f00c ff6f    	bl	0x700abfd0 <Udma_rmFreeBlkCopyCh> @ imm = #0xcede
7009f0f2: e7ff         	b	0x7009f0f4 <Udma_chFreeResource+0x64> @ imm = #-0x2
7009f0f4: e7ff         	b	0x7009f0f6 <Udma_chFreeResource+0x66> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009f0f6: 9903         	ldr	r1, [sp, #0xc]
7009f0f8: 2000         	movs	r0, #0x0
7009f0fa: f6cf 70ff    	movt	r0, #0xffff
7009f0fe: 66c8         	str	r0, [r1, #0x6c]
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009f100: 9903         	ldr	r1, [sp, #0xc]
7009f102: 6708         	str	r0, [r1, #0x70]
;         }
7009f104: e7ff         	b	0x7009f106 <Udma_chFreeResource+0x76> @ imm = #-0x2
;     }
7009f106: e084         	b	0x7009f212 <Udma_chFreeResource+0x182> @ imm = #0x108
;         if(UDMA_DMA_CH_INVALID != chHandle->txChNum)
7009f108: 9803         	ldr	r0, [sp, #0xc]
7009f10a: 6ec0         	ldr	r0, [r0, #0x6c]
7009f10c: f510 3f80    	cmn.w	r0, #0x10000
7009f110: d032         	beq	0x7009f178 <Udma_chFreeResource+0xe8> @ imm = #0x64
7009f112: e7ff         	b	0x7009f114 <Udma_chFreeResource+0x84> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009f114: 9803         	ldr	r0, [sp, #0xc]
7009f116: 7800         	ldrb	r0, [r0]
7009f118: 0640         	lsls	r0, r0, #0x19
7009f11a: 2800         	cmp	r0, #0x0
7009f11c: d506         	bpl	0x7009f12c <Udma_chFreeResource+0x9c> @ imm = #0xc
7009f11e: e7ff         	b	0x7009f120 <Udma_chFreeResource+0x90> @ imm = #-0x2
;                 Udma_rmFreeTxHcCh(chHandle->txChNum, drvHandle);
7009f120: 9803         	ldr	r0, [sp, #0xc]
7009f122: 6ec0         	ldr	r0, [r0, #0x6c]
7009f124: 9901         	ldr	r1, [sp, #0x4]
7009f126: f00d f8db    	bl	0x700ac2e0 <Udma_rmFreeTxHcCh> @ imm = #0xd1b6
;             }
7009f12a: e01f         	b	0x7009f16c <Udma_chFreeResource+0xdc> @ imm = #0x3e
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009f12c: 9803         	ldr	r0, [sp, #0xc]
7009f12e: 7840         	ldrb	r0, [r0, #0x1]
7009f130: 07c0         	lsls	r0, r0, #0x1f
7009f132: b138         	cbz	r0, 0x7009f144 <Udma_chFreeResource+0xb4> @ imm = #0xe
7009f134: e7ff         	b	0x7009f136 <Udma_chFreeResource+0xa6> @ imm = #-0x2
;                 Udma_rmFreeMappedTxCh(chHandle->txChNum, drvHandle, chHandle->chPrms.mappedChGrp);
7009f136: 9803         	ldr	r0, [sp, #0xc]
7009f138: 68c2         	ldr	r2, [r0, #0xc]
7009f13a: 6ec0         	ldr	r0, [r0, #0x6c]
7009f13c: 9901         	ldr	r1, [sp, #0x4]
7009f13e: f00c fa07    	bl	0x700ab550 <Udma_rmFreeMappedTxCh> @ imm = #0xc40e
;             }
7009f142: e012         	b	0x7009f16a <Udma_chFreeResource+0xda> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009f144: 9803         	ldr	r0, [sp, #0xc]
7009f146: 7800         	ldrb	r0, [r0]
7009f148: 0600         	lsls	r0, r0, #0x18
7009f14a: 2800         	cmp	r0, #0x0
7009f14c: d506         	bpl	0x7009f15c <Udma_chFreeResource+0xcc> @ imm = #0xc
7009f14e: e7ff         	b	0x7009f150 <Udma_chFreeResource+0xc0> @ imm = #-0x2
;                 Udma_rmFreeTxUhcCh(chHandle->txChNum, drvHandle);
7009f150: 9803         	ldr	r0, [sp, #0xc]
7009f152: 6ec0         	ldr	r0, [r0, #0x6c]
7009f154: 9901         	ldr	r1, [sp, #0x4]
7009f156: f00d f8fb    	bl	0x700ac350 <Udma_rmFreeTxUhcCh> @ imm = #0xd1f6
;             }
7009f15a: e005         	b	0x7009f168 <Udma_chFreeResource+0xd8> @ imm = #0xa
;                 Udma_rmFreeTxCh(chHandle->txChNum, drvHandle);
7009f15c: 9803         	ldr	r0, [sp, #0xc]
7009f15e: 6ec0         	ldr	r0, [r0, #0x6c]
7009f160: 9901         	ldr	r1, [sp, #0x4]
7009f162: f00d f885    	bl	0x700ac270 <Udma_rmFreeTxCh> @ imm = #0xd10a
7009f166: e7ff         	b	0x7009f168 <Udma_chFreeResource+0xd8> @ imm = #-0x2
7009f168: e7ff         	b	0x7009f16a <Udma_chFreeResource+0xda> @ imm = #-0x2
7009f16a: e7ff         	b	0x7009f16c <Udma_chFreeResource+0xdc> @ imm = #-0x2
;             chHandle->txChNum = UDMA_DMA_CH_INVALID;
7009f16c: 9903         	ldr	r1, [sp, #0xc]
7009f16e: 2000         	movs	r0, #0x0
7009f170: f6cf 70ff    	movt	r0, #0xffff
7009f174: 66c8         	str	r0, [r1, #0x6c]
;         }
7009f176: e7ff         	b	0x7009f178 <Udma_chFreeResource+0xe8> @ imm = #-0x2
;         if(UDMA_DMA_CH_INVALID != chHandle->rxChNum)
7009f178: 9803         	ldr	r0, [sp, #0xc]
7009f17a: 6f00         	ldr	r0, [r0, #0x70]
7009f17c: f510 3f80    	cmn.w	r0, #0x10000
7009f180: d033         	beq	0x7009f1ea <Udma_chFreeResource+0x15a> @ imm = #0x66
7009f182: e7ff         	b	0x7009f184 <Udma_chFreeResource+0xf4> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
7009f184: 9803         	ldr	r0, [sp, #0xc]
7009f186: 7800         	ldrb	r0, [r0]
7009f188: 0640         	lsls	r0, r0, #0x19
7009f18a: 2800         	cmp	r0, #0x0
7009f18c: d506         	bpl	0x7009f19c <Udma_chFreeResource+0x10c> @ imm = #0xc
7009f18e: e7ff         	b	0x7009f190 <Udma_chFreeResource+0x100> @ imm = #-0x2
;                 Udma_rmFreeRxHcCh(chHandle->rxChNum, drvHandle);
7009f190: 9803         	ldr	r0, [sp, #0xc]
7009f192: 6f00         	ldr	r0, [r0, #0x70]
7009f194: 9901         	ldr	r1, [sp, #0x4]
7009f196: f00c fffb    	bl	0x700ac190 <Udma_rmFreeRxHcCh> @ imm = #0xcff6
;             }
7009f19a: e020         	b	0x7009f1de <Udma_chFreeResource+0x14e> @ imm = #0x40
;             else if((chHandle->chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
7009f19c: 9803         	ldr	r0, [sp, #0xc]
7009f19e: 7840         	ldrb	r0, [r0, #0x1]
7009f1a0: 07c0         	lsls	r0, r0, #0x1f
7009f1a2: b140         	cbz	r0, 0x7009f1b6 <Udma_chFreeResource+0x126> @ imm = #0x10
7009f1a4: e7ff         	b	0x7009f1a6 <Udma_chFreeResource+0x116> @ imm = #-0x2
;                 Udma_rmFreeMappedRxCh(chHandle->rxChNum, drvHandle, chHandle->chPrms.mappedChGrp - UDMA_NUM_MAPPED_TX_GROUP);
7009f1a6: 9803         	ldr	r0, [sp, #0xc]
7009f1a8: 68c2         	ldr	r2, [r0, #0xc]
7009f1aa: 6f00         	ldr	r0, [r0, #0x70]
7009f1ac: 9901         	ldr	r1, [sp, #0x4]
7009f1ae: 3a04         	subs	r2, #0x4
7009f1b0: f00c f996    	bl	0x700ab4e0 <Udma_rmFreeMappedRxCh> @ imm = #0xc32c
;             }
7009f1b4: e012         	b	0x7009f1dc <Udma_chFreeResource+0x14c> @ imm = #0x24
;             else if((chHandle->chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
7009f1b6: 9803         	ldr	r0, [sp, #0xc]
7009f1b8: 7800         	ldrb	r0, [r0]
7009f1ba: 0600         	lsls	r0, r0, #0x18
7009f1bc: 2800         	cmp	r0, #0x0
7009f1be: d506         	bpl	0x7009f1ce <Udma_chFreeResource+0x13e> @ imm = #0xc
7009f1c0: e7ff         	b	0x7009f1c2 <Udma_chFreeResource+0x132> @ imm = #-0x2
;                 Udma_rmFreeRxUhcCh(chHandle->rxChNum, drvHandle);
7009f1c2: 9803         	ldr	r0, [sp, #0xc]
7009f1c4: 6f00         	ldr	r0, [r0, #0x70]
7009f1c6: 9901         	ldr	r1, [sp, #0x4]
7009f1c8: f00d f81a    	bl	0x700ac200 <Udma_rmFreeRxUhcCh> @ imm = #0xd034
;             }
7009f1cc: e005         	b	0x7009f1da <Udma_chFreeResource+0x14a> @ imm = #0xa
;                 Udma_rmFreeRxCh(chHandle->rxChNum, drvHandle);
7009f1ce: 9803         	ldr	r0, [sp, #0xc]
7009f1d0: 6f00         	ldr	r0, [r0, #0x70]
7009f1d2: 9901         	ldr	r1, [sp, #0x4]
7009f1d4: f00c ffa4    	bl	0x700ac120 <Udma_rmFreeRxCh> @ imm = #0xcf48
7009f1d8: e7ff         	b	0x7009f1da <Udma_chFreeResource+0x14a> @ imm = #-0x2
7009f1da: e7ff         	b	0x7009f1dc <Udma_chFreeResource+0x14c> @ imm = #-0x2
7009f1dc: e7ff         	b	0x7009f1de <Udma_chFreeResource+0x14e> @ imm = #-0x2
;             chHandle->rxChNum = UDMA_DMA_CH_INVALID;
7009f1de: 9903         	ldr	r1, [sp, #0xc]
7009f1e0: 2000         	movs	r0, #0x0
7009f1e2: f6cf 70ff    	movt	r0, #0xffff
7009f1e6: 6708         	str	r0, [r1, #0x70]
;         }
7009f1e8: e7ff         	b	0x7009f1ea <Udma_chFreeResource+0x15a> @ imm = #-0x2
;         chHandle->defaultFlowObj.drvHandle    = (Udma_DrvHandleInt) NULL_PTR;
7009f1ea: 9903         	ldr	r1, [sp, #0xc]
7009f1ec: 2000         	movs	r0, #0x0
7009f1ee: f8c1 01cc    	str.w	r0, [r1, #0x1cc]
;         chHandle->defaultFlowObj.flowStart    = UDMA_FLOW_INVALID;
7009f1f2: 9a03         	ldr	r2, [sp, #0xc]
7009f1f4: 2100         	movs	r1, #0x0
7009f1f6: f6cf 71ff    	movt	r1, #0xffff
7009f1fa: f8c2 11d0    	str.w	r1, [r2, #0x1d0]
;         chHandle->defaultFlowObj.flowCnt      = 0U;
7009f1fe: 9903         	ldr	r1, [sp, #0xc]
7009f200: f8c1 01d4    	str.w	r0, [r1, #0x1d4]
;         chHandle->defaultFlowObj.flowInitDone = UDMA_DEINIT_DONE;
7009f204: 9903         	ldr	r1, [sp, #0xc]
7009f206: f8c1 01d8    	str.w	r0, [r1, #0x1d8]
;         chHandle->defaultFlow                 = (Udma_FlowHandleInt) NULL_PTR;
7009f20a: 9903         	ldr	r1, [sp, #0xc]
7009f20c: f8c1 01c8    	str.w	r0, [r1, #0x1c8]
7009f210: e7ff         	b	0x7009f212 <Udma_chFreeResource+0x182> @ imm = #-0x2
;     chHandle->pdmaChNum = UDMA_DMA_CH_INVALID;
7009f212: 9903         	ldr	r1, [sp, #0xc]
7009f214: 2000         	movs	r0, #0x0
7009f216: f6cf 70ff    	movt	r0, #0xffff
7009f21a: 6788         	str	r0, [r1, #0x78]
;     chHandle->peerThreadId = UDMA_THREAD_ID_INVALID;
7009f21c: 9903         	ldr	r1, [sp, #0xc]
7009f21e: 2004         	movs	r0, #0x4
7009f220: f6cf 70ff    	movt	r0, #0xffff
7009f224: 67c8         	str	r0, [r1, #0x7c]
;     if(NULL_PTR != chHandle->fqRing)
7009f226: 9803         	ldr	r0, [sp, #0xc]
7009f228: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009f22c: b190         	cbz	r0, 0x7009f254 <Udma_chFreeResource+0x1c4> @ imm = #0x24
7009f22e: e7ff         	b	0x7009f230 <Udma_chFreeResource+0x1a0> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->fqRing);
7009f230: 9803         	ldr	r0, [sp, #0xc]
7009f232: f8d0 0080    	ldr.w	r0, [r0, #0x80]
7009f236: f007 ff53    	bl	0x700a70e0 <Udma_ringFree> @ imm = #0x7ea6
7009f23a: 4601         	mov	r1, r0
7009f23c: 9802         	ldr	r0, [sp, #0x8]
7009f23e: 4408         	add	r0, r1
7009f240: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009f242: 9802         	ldr	r0, [sp, #0x8]
7009f244: b108         	cbz	r0, 0x7009f24a <Udma_chFreeResource+0x1ba> @ imm = #0x2
7009f246: e7ff         	b	0x7009f248 <Udma_chFreeResource+0x1b8> @ imm = #-0x2
;         }
7009f248: e7ff         	b	0x7009f24a <Udma_chFreeResource+0x1ba> @ imm = #-0x2
;         chHandle->fqRing = (Udma_RingHandleInt) NULL_PTR;
7009f24a: 9903         	ldr	r1, [sp, #0xc]
7009f24c: 2000         	movs	r0, #0x0
7009f24e: f8c1 0080    	str.w	r0, [r1, #0x80]
;     }
7009f252: e7ff         	b	0x7009f254 <Udma_chFreeResource+0x1c4> @ imm = #-0x2
;     if(NULL_PTR != chHandle->cqRing)
7009f254: 9803         	ldr	r0, [sp, #0xc]
7009f256: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009f25a: b128         	cbz	r0, 0x7009f268 <Udma_chFreeResource+0x1d8> @ imm = #0xa
7009f25c: e7ff         	b	0x7009f25e <Udma_chFreeResource+0x1ce> @ imm = #-0x2
;         chHandle->cqRing = (Udma_RingHandleInt) NULL_PTR;
7009f25e: 9903         	ldr	r1, [sp, #0xc]
7009f260: 2000         	movs	r0, #0x0
7009f262: f8c1 0084    	str.w	r0, [r1, #0x84]
;     }
7009f266: e7ff         	b	0x7009f268 <Udma_chFreeResource+0x1d8> @ imm = #-0x2
;     if(NULL_PTR != chHandle->tdCqRing)
7009f268: 9803         	ldr	r0, [sp, #0xc]
7009f26a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009f26e: b190         	cbz	r0, 0x7009f296 <Udma_chFreeResource+0x206> @ imm = #0x24
7009f270: e7ff         	b	0x7009f272 <Udma_chFreeResource+0x1e2> @ imm = #-0x2
;         retVal += Udma_ringFree(chHandle->tdCqRing);
7009f272: 9803         	ldr	r0, [sp, #0xc]
7009f274: f8d0 0088    	ldr.w	r0, [r0, #0x88]
7009f278: f007 ff32    	bl	0x700a70e0 <Udma_ringFree> @ imm = #0x7e64
7009f27c: 4601         	mov	r1, r0
7009f27e: 9802         	ldr	r0, [sp, #0x8]
7009f280: 4408         	add	r0, r1
7009f282: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
7009f284: 9802         	ldr	r0, [sp, #0x8]
7009f286: b108         	cbz	r0, 0x7009f28c <Udma_chFreeResource+0x1fc> @ imm = #0x2
7009f288: e7ff         	b	0x7009f28a <Udma_chFreeResource+0x1fa> @ imm = #-0x2
;         }
7009f28a: e7ff         	b	0x7009f28c <Udma_chFreeResource+0x1fc> @ imm = #-0x2
;         chHandle->tdCqRing = (Udma_RingHandleInt) NULL_PTR;
7009f28c: 9903         	ldr	r1, [sp, #0xc]
7009f28e: 2000         	movs	r0, #0x0
7009f290: f8c1 0088    	str.w	r0, [r1, #0x88]
;     }
7009f294: e7ff         	b	0x7009f296 <Udma_chFreeResource+0x206> @ imm = #-0x2
;     return (retVal);
7009f296: 9802         	ldr	r0, [sp, #0x8]
7009f298: b004         	add	sp, #0x10
7009f29a: bd80         	pop	{r7, pc}
7009f29c: 0000         	movs	r0, r0
7009f29e: 0000         	movs	r0, r0

7009f2a0 <Udma_ringAlloc>:
; {
7009f2a0: b580         	push	{r7, lr}
7009f2a2: b096         	sub	sp, #0x58
7009f2a4: 9015         	str	r0, [sp, #0x54]
7009f2a6: 9114         	str	r1, [sp, #0x50]
7009f2a8: f8ad 204e    	strh.w	r2, [sp, #0x4e]
7009f2ac: 9312         	str	r3, [sp, #0x48]
7009f2ae: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f2b0: 9011         	str	r0, [sp, #0x44]
;     uint32_t            allocDone = (uint32_t) FALSE;
7009f2b2: 900d         	str	r0, [sp, #0x34]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
7009f2b4: 9815         	ldr	r0, [sp, #0x54]
7009f2b6: 900c         	str	r0, [sp, #0x30]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
7009f2b8: 9814         	ldr	r0, [sp, #0x50]
7009f2ba: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == drvHandleInt) ||
7009f2bc: 980c         	ldr	r0, [sp, #0x30]
7009f2be: b130         	cbz	r0, 0x7009f2ce <Udma_ringAlloc+0x2e> @ imm = #0xc
7009f2c0: e7ff         	b	0x7009f2c2 <Udma_ringAlloc+0x22> @ imm = #-0x2
;        (NULL_PTR == ringHandleInt) ||
7009f2c2: 980b         	ldr	r0, [sp, #0x2c]
7009f2c4: b118         	cbz	r0, 0x7009f2ce <Udma_ringAlloc+0x2e> @ imm = #0x6
7009f2c6: e7ff         	b	0x7009f2c8 <Udma_ringAlloc+0x28> @ imm = #-0x2
;        (NULL_PTR == ringPrms))
7009f2c8: 9812         	ldr	r0, [sp, #0x48]
;     if((NULL_PTR == drvHandleInt) ||
7009f2ca: b920         	cbnz	r0, 0x7009f2d6 <Udma_ringAlloc+0x36> @ imm = #0x8
7009f2cc: e7ff         	b	0x7009f2ce <Udma_ringAlloc+0x2e> @ imm = #-0x2
7009f2ce: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009f2d2: 9011         	str	r0, [sp, #0x44]
;     }
7009f2d4: e7ff         	b	0x7009f2d6 <Udma_ringAlloc+0x36> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f2d6: 9811         	ldr	r0, [sp, #0x44]
7009f2d8: b978         	cbnz	r0, 0x7009f2fa <Udma_ringAlloc+0x5a> @ imm = #0x1e
7009f2da: e7ff         	b	0x7009f2dc <Udma_ringAlloc+0x3c> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
7009f2dc: 980c         	ldr	r0, [sp, #0x30]
7009f2de: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009f2e2: f64a 31cd    	movw	r1, #0xabcd
7009f2e6: f6ca 31dc    	movt	r1, #0xabdc
7009f2ea: 4288         	cmp	r0, r1
7009f2ec: d004         	beq	0x7009f2f8 <Udma_ringAlloc+0x58> @ imm = #0x8
7009f2ee: e7ff         	b	0x7009f2f0 <Udma_ringAlloc+0x50> @ imm = #-0x2
7009f2f0: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009f2f4: 9011         	str	r0, [sp, #0x44]
;         }
7009f2f6: e7ff         	b	0x7009f2f8 <Udma_ringAlloc+0x58> @ imm = #-0x2
;     }
7009f2f8: e7ff         	b	0x7009f2fa <Udma_ringAlloc+0x5a> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f2fa: 9811         	ldr	r0, [sp, #0x44]
7009f2fc: b930         	cbnz	r0, 0x7009f30c <Udma_ringAlloc+0x6c> @ imm = #0xc
7009f2fe: e7ff         	b	0x7009f300 <Udma_ringAlloc+0x60> @ imm = #-0x2
;         retVal = Udma_ringCheckParams(drvHandleInt, ringPrms);
7009f300: 980c         	ldr	r0, [sp, #0x30]
7009f302: 9912         	ldr	r1, [sp, #0x48]
7009f304: f007 fd4c    	bl	0x700a6da0 <Udma_ringCheckParams> @ imm = #0x7a98
7009f308: 9011         	str	r0, [sp, #0x44]
;     }
7009f30a: e7ff         	b	0x7009f30c <Udma_ringAlloc+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f30c: 9811         	ldr	r0, [sp, #0x44]
7009f30e: 2800         	cmp	r0, #0x0
7009f310: d140         	bne	0x7009f394 <Udma_ringAlloc+0xf4> @ imm = #0x80
7009f312: e7ff         	b	0x7009f314 <Udma_ringAlloc+0x74> @ imm = #-0x2
;         if(UDMA_RING_ANY == ringNum)
7009f314: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009f318: f64f 71fe    	movw	r1, #0xfffe
7009f31c: 4288         	cmp	r0, r1
7009f31e: d126         	bne	0x7009f36e <Udma_ringAlloc+0xce> @ imm = #0x4c
7009f320: e7ff         	b	0x7009f322 <Udma_ringAlloc+0x82> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009f322: 9812         	ldr	r0, [sp, #0x48]
7009f324: 6940         	ldr	r0, [r0, #0x14]
7009f326: 2104         	movs	r1, #0x4
7009f328: f6cf 71ff    	movt	r1, #0xffff
7009f32c: 4288         	cmp	r0, r1
7009f32e: d106         	bne	0x7009f33e <Udma_ringAlloc+0x9e> @ imm = #0xc
7009f330: e7ff         	b	0x7009f332 <Udma_ringAlloc+0x92> @ imm = #-0x2
;                 ringHandleInt->ringNum = Udma_rmAllocFreeRing(drvHandleInt);
7009f332: 980c         	ldr	r0, [sp, #0x30]
7009f334: f010 fb2c    	bl	0x700af990 <Udma_rmAllocFreeRing> @ imm = #0x10658
7009f338: 990b         	ldr	r1, [sp, #0x2c]
7009f33a: 8088         	strh	r0, [r1, #0x4]
;             }
7009f33c: e008         	b	0x7009f350 <Udma_ringAlloc+0xb0> @ imm = #0x10
;                 ringHandleInt->ringNum = Udma_rmAllocMappedRing(drvHandleInt, ringPrms->mappedRingGrp, ringPrms->mappedChNum);
7009f33e: 980c         	ldr	r0, [sp, #0x30]
7009f340: 9a12         	ldr	r2, [sp, #0x48]
7009f342: 6951         	ldr	r1, [r2, #0x14]
7009f344: 6992         	ldr	r2, [r2, #0x18]
7009f346: f003 fae3    	bl	0x700a2910 <Udma_rmAllocMappedRing> @ imm = #0x35c6
7009f34a: 990b         	ldr	r1, [sp, #0x2c]
7009f34c: 8088         	strh	r0, [r1, #0x4]
7009f34e: e7ff         	b	0x7009f350 <Udma_ringAlloc+0xb0> @ imm = #-0x2
;             if(UDMA_RING_INVALID == ringHandleInt->ringNum)
7009f350: 980b         	ldr	r0, [sp, #0x2c]
7009f352: 8880         	ldrh	r0, [r0, #0x4]
7009f354: f64f 71ff    	movw	r1, #0xffff
7009f358: 4288         	cmp	r0, r1
7009f35a: d104         	bne	0x7009f366 <Udma_ringAlloc+0xc6> @ imm = #0x8
7009f35c: e7ff         	b	0x7009f35e <Udma_ringAlloc+0xbe> @ imm = #-0x2
7009f35e: f06f 0004    	mvn	r0, #0x4
;                 retVal = UDMA_EALLOC;
7009f362: 9011         	str	r0, [sp, #0x44]
;             }
7009f364: e002         	b	0x7009f36c <Udma_ringAlloc+0xcc> @ imm = #0x4
7009f366: 2001         	movs	r0, #0x1
;                 allocDone = (uint32_t) TRUE;
7009f368: 900d         	str	r0, [sp, #0x34]
7009f36a: e7ff         	b	0x7009f36c <Udma_ringAlloc+0xcc> @ imm = #-0x2
;         }
7009f36c: e011         	b	0x7009f392 <Udma_ringAlloc+0xf2> @ imm = #0x22
;             if(ringNum >= drvHandleInt->maxRings)
7009f36e: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009f372: 990c         	ldr	r1, [sp, #0x30]
7009f374: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
7009f378: 4288         	cmp	r0, r1
7009f37a: d304         	blo	0x7009f386 <Udma_ringAlloc+0xe6> @ imm = #0x8
7009f37c: e7ff         	b	0x7009f37e <Udma_ringAlloc+0xde> @ imm = #-0x2
7009f37e: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
7009f382: 9011         	str	r0, [sp, #0x44]
;             }
7009f384: e004         	b	0x7009f390 <Udma_ringAlloc+0xf0> @ imm = #0x8
;                 ringHandleInt->ringNum = ringNum;
7009f386: f8bd 004e    	ldrh.w	r0, [sp, #0x4e]
7009f38a: 990b         	ldr	r1, [sp, #0x2c]
7009f38c: 8088         	strh	r0, [r1, #0x4]
7009f38e: e7ff         	b	0x7009f390 <Udma_ringAlloc+0xf0> @ imm = #-0x2
7009f390: e7ff         	b	0x7009f392 <Udma_ringAlloc+0xf2> @ imm = #-0x2
;     }
7009f392: e7ff         	b	0x7009f394 <Udma_ringAlloc+0xf4> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f394: 9811         	ldr	r0, [sp, #0x44]
7009f396: b9a8         	cbnz	r0, 0x7009f3c4 <Udma_ringAlloc+0x124> @ imm = #0x2a
7009f398: e7ff         	b	0x7009f39a <Udma_ringAlloc+0xfa> @ imm = #-0x2
;         Udma_ringAssertFnPointers(drvHandleInt);
7009f39a: 980c         	ldr	r0, [sp, #0x30]
7009f39c: f010 fcb0    	bl	0x700afd00 <Udma_ringAssertFnPointers> @ imm = #0x10960
;         ringHandleInt->drvHandle = drvHandleInt;
7009f3a0: 980c         	ldr	r0, [sp, #0x30]
7009f3a2: 990b         	ldr	r1, [sp, #0x2c]
7009f3a4: 6008         	str	r0, [r1]
;         ringHandleInt->mappedRingGrp   = ringPrms->mappedRingGrp;
7009f3a6: 9812         	ldr	r0, [sp, #0x48]
7009f3a8: 6940         	ldr	r0, [r0, #0x14]
7009f3aa: 990b         	ldr	r1, [sp, #0x2c]
7009f3ac: 65c8         	str	r0, [r1, #0x5c]
;         ringHandleInt->mappedChNum     = ringPrms->mappedChNum;
7009f3ae: 9812         	ldr	r0, [sp, #0x48]
7009f3b0: 6980         	ldr	r0, [r0, #0x18]
7009f3b2: 990b         	ldr	r1, [sp, #0x2c]
7009f3b4: 6608         	str	r0, [r1, #0x60]
;         drvHandleInt->ringSetCfg(drvHandleInt, ringHandleInt, ringPrms);
7009f3b6: 980c         	ldr	r0, [sp, #0x30]
7009f3b8: f8d0 35c4    	ldr.w	r3, [r0, #0x5c4]
7009f3bc: 990b         	ldr	r1, [sp, #0x2c]
7009f3be: 9a12         	ldr	r2, [sp, #0x48]
7009f3c0: 4798         	blx	r3
;     }
7009f3c2: e7ff         	b	0x7009f3c4 <Udma_ringAlloc+0x124> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f3c4: 9811         	ldr	r0, [sp, #0x44]
7009f3c6: 2800         	cmp	r0, #0x0
7009f3c8: d146         	bne	0x7009f458 <Udma_ringAlloc+0x1b8> @ imm = #0x8c
7009f3ca: e7ff         	b	0x7009f3cc <Udma_ringAlloc+0x12c> @ imm = #-0x2
7009f3cc: 20bf         	movs	r0, #0xbf
;         rmRingReq.valid_params  = TISCI_MSG_VALUE_RM_RING_ADDR_LO_VALID |
7009f3ce: 9004         	str	r0, [sp, #0x10]
;         rmRingReq.nav_id        = drvHandleInt->devIdRing;
7009f3d0: 980c         	ldr	r0, [sp, #0x30]
7009f3d2: f8b0 00e0    	ldrh.w	r0, [r0, #0xe0]
7009f3d6: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmRingReq.index         = ringHandleInt->ringNum;
7009f3da: 980b         	ldr	r0, [sp, #0x2c]
7009f3dc: 8880         	ldrh	r0, [r0, #0x4]
7009f3de: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         physBase = Udma_virtToPhyFxn(ringPrms->ringMem, drvHandleInt, (Udma_ChHandleInt) NULL_PTR);
7009f3e2: 9812         	ldr	r0, [sp, #0x48]
7009f3e4: 6800         	ldr	r0, [r0]
7009f3e6: 990c         	ldr	r1, [sp, #0x30]
7009f3e8: 2200         	movs	r2, #0x0
7009f3ea: f00d f849    	bl	0x700ac480 <Udma_virtToPhyFxn> @ imm = #0xd092
7009f3ee: 910f         	str	r1, [sp, #0x3c]
7009f3f0: 900e         	str	r0, [sp, #0x38]
;         rmRingReq.addr_lo       = (uint32_t)physBase;
7009f3f2: 980e         	ldr	r0, [sp, #0x38]
7009f3f4: 9006         	str	r0, [sp, #0x18]
;         rmRingReq.addr_hi       = (uint32_t)(physBase >> 32UL);
7009f3f6: 980f         	ldr	r0, [sp, #0x3c]
7009f3f8: 9007         	str	r0, [sp, #0x1c]
;         rmRingReq.count         = ringPrms->elemCnt;
7009f3fa: 9812         	ldr	r0, [sp, #0x48]
7009f3fc: 68c0         	ldr	r0, [r0, #0xc]
7009f3fe: 9008         	str	r0, [sp, #0x20]
;         rmRingReq.mode          = ringPrms->mode;
7009f400: 9812         	ldr	r0, [sp, #0x48]
7009f402: 7a00         	ldrb	r0, [r0, #0x8]
7009f404: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmRingReq.size          = ringPrms->elemSize;
7009f408: 9812         	ldr	r0, [sp, #0x48]
7009f40a: 7c00         	ldrb	r0, [r0, #0x10]
7009f40c: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmRingReq.order_id      = ringPrms->orderId;
7009f410: 9812         	ldr	r0, [sp, #0x48]
7009f412: 7c40         	ldrb	r0, [r0, #0x11]
7009f414: f88d 0026    	strb.w	r0, [sp, #0x26]
;         rmRingReq.asel          = ringPrms->asel;
7009f418: 9812         	ldr	r0, [sp, #0x48]
7009f41a: 7c80         	ldrb	r0, [r0, #0x12]
7009f41c: f88d 0029    	strb.w	r0, [sp, #0x29]
;         if(UDMA_RING_VIRTID_INVALID != ringPrms->virtId)
7009f420: 9812         	ldr	r0, [sp, #0x48]
7009f422: 8940         	ldrh	r0, [r0, #0xa]
7009f424: f64f 71ff    	movw	r1, #0xffff
7009f428: 4288         	cmp	r0, r1
7009f42a: d009         	beq	0x7009f440 <Udma_ringAlloc+0x1a0> @ imm = #0x12
7009f42c: e7ff         	b	0x7009f42e <Udma_ringAlloc+0x18e> @ imm = #-0x2
;             rmRingReq.valid_params |= TISCI_MSG_VALUE_RM_RING_VIRTID_VALID;
7009f42e: 9804         	ldr	r0, [sp, #0x10]
7009f430: f040 0040    	orr	r0, r0, #0x40
7009f434: 9004         	str	r0, [sp, #0x10]
;             rmRingReq.virtid        = ringPrms->virtId;
7009f436: 9812         	ldr	r0, [sp, #0x48]
7009f438: 8940         	ldrh	r0, [r0, #0xa]
7009f43a: f8ad 0027    	strh.w	r0, [sp, #0x27]
;         }
7009f43e: e7ff         	b	0x7009f440 <Udma_ringAlloc+0x1a0> @ imm = #-0x2
7009f440: a802         	add	r0, sp, #0x8
7009f442: 4669         	mov	r1, sp
7009f444: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmRingCfg(
7009f448: f00d fa5a    	bl	0x700ac900 <Sciclient_rmRingCfg> @ imm = #0xd4b4
7009f44c: 9011         	str	r0, [sp, #0x44]
;         if(CSL_PASS != retVal)
7009f44e: 9811         	ldr	r0, [sp, #0x44]
7009f450: b108         	cbz	r0, 0x7009f456 <Udma_ringAlloc+0x1b6> @ imm = #0x2
7009f452: e7ff         	b	0x7009f454 <Udma_ringAlloc+0x1b4> @ imm = #-0x2
;         }
7009f454: e7ff         	b	0x7009f456 <Udma_ringAlloc+0x1b6> @ imm = #-0x2
;     }
7009f456: e7ff         	b	0x7009f458 <Udma_ringAlloc+0x1b8> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f458: 9811         	ldr	r0, [sp, #0x44]
7009f45a: b938         	cbnz	r0, 0x7009f46c <Udma_ringAlloc+0x1cc> @ imm = #0xe
7009f45c: e7ff         	b	0x7009f45e <Udma_ringAlloc+0x1be> @ imm = #-0x2
;         ringHandleInt->ringInitDone = UDMA_INIT_DONE;
7009f45e: 990b         	ldr	r1, [sp, #0x2c]
7009f460: f64a 30cd    	movw	r0, #0xabcd
7009f464: f6ca 30dc    	movt	r0, #0xabdc
7009f468: 6588         	str	r0, [r1, #0x58]
;     }
7009f46a: e01b         	b	0x7009f4a4 <Udma_ringAlloc+0x204> @ imm = #0x36
;         if(((uint32_t) TRUE) == allocDone)
7009f46c: 980d         	ldr	r0, [sp, #0x34]
7009f46e: 2801         	cmp	r0, #0x1
7009f470: d117         	bne	0x7009f4a2 <Udma_ringAlloc+0x202> @ imm = #0x2e
7009f472: e7ff         	b	0x7009f474 <Udma_ringAlloc+0x1d4> @ imm = #-0x2
;             if(UDMA_MAPPED_GROUP_INVALID == ringPrms->mappedRingGrp)
7009f474: 9812         	ldr	r0, [sp, #0x48]
7009f476: 6940         	ldr	r0, [r0, #0x14]
7009f478: 2104         	movs	r1, #0x4
7009f47a: f6cf 71ff    	movt	r1, #0xffff
7009f47e: 4288         	cmp	r0, r1
7009f480: d106         	bne	0x7009f490 <Udma_ringAlloc+0x1f0> @ imm = #0xc
7009f482: e7ff         	b	0x7009f484 <Udma_ringAlloc+0x1e4> @ imm = #-0x2
;                 Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandleInt);
7009f484: 980b         	ldr	r0, [sp, #0x2c]
7009f486: 8880         	ldrh	r0, [r0, #0x4]
7009f488: 990c         	ldr	r1, [sp, #0x30]
7009f48a: f010 fc01    	bl	0x700afc90 <Udma_rmFreeFreeRing> @ imm = #0x10802
;             }
7009f48e: e007         	b	0x7009f4a0 <Udma_ringAlloc+0x200> @ imm = #0xe
;                 Udma_rmFreeMappedRing(ringHandleInt->ringNum, drvHandleInt, ringHandleInt->mappedRingGrp, ringHandleInt->mappedChNum);
7009f490: 9b0b         	ldr	r3, [sp, #0x2c]
7009f492: 8898         	ldrh	r0, [r3, #0x4]
7009f494: 990c         	ldr	r1, [sp, #0x30]
7009f496: 6dda         	ldr	r2, [r3, #0x5c]
7009f498: 6e1b         	ldr	r3, [r3, #0x60]
7009f49a: f00a fc89    	bl	0x700a9db0 <Udma_rmFreeMappedRing> @ imm = #0xa912
7009f49e: e7ff         	b	0x7009f4a0 <Udma_ringAlloc+0x200> @ imm = #-0x2
;         }
7009f4a0: e7ff         	b	0x7009f4a2 <Udma_ringAlloc+0x202> @ imm = #-0x2
7009f4a2: e7ff         	b	0x7009f4a4 <Udma_ringAlloc+0x204> @ imm = #-0x2
;     return (retVal);
7009f4a4: 9811         	ldr	r0, [sp, #0x44]
7009f4a6: b016         	add	sp, #0x58
7009f4a8: bd80         	pop	{r7, pc}
7009f4aa: 0000         	movs	r0, r0
7009f4ac: 0000         	movs	r0, r0
7009f4ae: 0000         	movs	r0, r0

7009f4b0 <Udma_chDisableBlkCpyChan>:
; {
7009f4b0: b580         	push	{r7, lr}
7009f4b2: b090         	sub	sp, #0x40
7009f4b4: 900f         	str	r0, [sp, #0x3c]
7009f4b6: 910e         	str	r1, [sp, #0x38]
7009f4b8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f4ba: 900d         	str	r0, [sp, #0x34]
;     uint32_t            currTimeout = 0U;
7009f4bc: 900c         	str	r0, [sp, #0x30]
;     drvHandle = chHandle->drvHandle;
7009f4be: 980f         	ldr	r0, [sp, #0x3c]
7009f4c0: 6e80         	ldr	r0, [r0, #0x68]
7009f4c2: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f4c4: 980b         	ldr	r0, [sp, #0x2c]
7009f4c6: 6800         	ldr	r0, [r0]
7009f4c8: 2801         	cmp	r0, #0x1
7009f4ca: d10a         	bne	0x7009f4e2 <Udma_chDisableBlkCpyChan+0x32> @ imm = #0x14
7009f4cc: e7ff         	b	0x7009f4ce <Udma_chDisableBlkCpyChan+0x1e> @ imm = #-0x2
;                  &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009f4ce: 980b         	ldr	r0, [sp, #0x2c]
7009f4d0: 3008         	adds	r0, #0x8
7009f4d2: 990f         	ldr	r1, [sp, #0x3c]
7009f4d4: 6ec9         	ldr	r1, [r1, #0x6c]
7009f4d6: 2300         	movs	r3, #0x0
;         retVal = CSL_bcdmaTeardownTxChan(
7009f4d8: 461a         	mov	r2, r3
7009f4da: f00e f969    	bl	0x700ad7b0 <CSL_bcdmaTeardownTxChan> @ imm = #0xe2d2
7009f4de: 900d         	str	r0, [sp, #0x34]
;     }
7009f4e0: e00f         	b	0x7009f502 <Udma_chDisableBlkCpyChan+0x52> @ imm = #0x1e
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f4e2: 980b         	ldr	r0, [sp, #0x2c]
7009f4e4: 6800         	ldr	r0, [r0]
7009f4e6: 2802         	cmp	r0, #0x2
7009f4e8: d10a         	bne	0x7009f500 <Udma_chDisableBlkCpyChan+0x50> @ imm = #0x14
7009f4ea: e7ff         	b	0x7009f4ec <Udma_chDisableBlkCpyChan+0x3c> @ imm = #-0x2
;                  &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)false, (bool)false);
7009f4ec: 980b         	ldr	r0, [sp, #0x2c]
7009f4ee: 3054         	adds	r0, #0x54
7009f4f0: 990f         	ldr	r1, [sp, #0x3c]
7009f4f2: 6ec9         	ldr	r1, [r1, #0x6c]
7009f4f4: 2300         	movs	r3, #0x0
;         retVal = CSL_pktdmaTeardownTxChan(
7009f4f6: 461a         	mov	r2, r3
7009f4f8: f00f f802    	bl	0x700ae500 <CSL_pktdmaTeardownTxChan> @ imm = #0xf004
7009f4fc: 900d         	str	r0, [sp, #0x34]
;     }
7009f4fe: e7ff         	b	0x7009f500 <Udma_chDisableBlkCpyChan+0x50> @ imm = #-0x2
7009f500: e7ff         	b	0x7009f502 <Udma_chDisableBlkCpyChan+0x52> @ imm = #-0x2
;     if(CSL_PASS != retVal)
7009f502: 980d         	ldr	r0, [sp, #0x34]
7009f504: b108         	cbz	r0, 0x7009f50a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #0x2
7009f506: e7ff         	b	0x7009f508 <Udma_chDisableBlkCpyChan+0x58> @ imm = #-0x2
;     }
7009f508: e7ff         	b	0x7009f50a <Udma_chDisableBlkCpyChan+0x5a> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009f50a: e7ff         	b	0x7009f50c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x2
7009f50c: 980d         	ldr	r0, [sp, #0x34]
7009f50e: bba8         	cbnz	r0, 0x7009f57c <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x6a
7009f510: e7ff         	b	0x7009f512 <Udma_chDisableBlkCpyChan+0x62> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f512: 980b         	ldr	r0, [sp, #0x2c]
7009f514: 6800         	ldr	r0, [r0]
7009f516: 2801         	cmp	r0, #0x1
7009f518: d10c         	bne	0x7009f534 <Udma_chDisableBlkCpyChan+0x84> @ imm = #0x18
7009f51a: e7ff         	b	0x7009f51c <Udma_chDisableBlkCpyChan+0x6c> @ imm = #-0x2
;             (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f51c: 980b         	ldr	r0, [sp, #0x2c]
7009f51e: 3008         	adds	r0, #0x8
7009f520: 990f         	ldr	r1, [sp, #0x3c]
7009f522: 6ec9         	ldr	r1, [r1, #0x6c]
7009f524: aa05         	add	r2, sp, #0x14
7009f526: f00f fae3    	bl	0x700aeaf0 <CSL_bcdmaGetTxRT> @ imm = #0xf5c6
;             if(FALSE == bcdmaRtStatus.enable)
7009f52a: 9805         	ldr	r0, [sp, #0x14]
7009f52c: b908         	cbnz	r0, 0x7009f532 <Udma_chDisableBlkCpyChan+0x82> @ imm = #0x2
7009f52e: e7ff         	b	0x7009f530 <Udma_chDisableBlkCpyChan+0x80> @ imm = #-0x2
;                 break;
7009f530: e024         	b	0x7009f57c <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x48
;         }
7009f532: e011         	b	0x7009f558 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f534: 980b         	ldr	r0, [sp, #0x2c]
7009f536: 6800         	ldr	r0, [r0]
7009f538: 2802         	cmp	r0, #0x2
7009f53a: d10c         	bne	0x7009f556 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #0x18
7009f53c: e7ff         	b	0x7009f53e <Udma_chDisableBlkCpyChan+0x8e> @ imm = #-0x2
;             (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f53e: 980b         	ldr	r0, [sp, #0x2c]
7009f540: 3054         	adds	r0, #0x54
7009f542: 990f         	ldr	r1, [sp, #0x3c]
7009f544: 6ec9         	ldr	r1, [r1, #0x6c]
7009f546: 466a         	mov	r2, sp
7009f548: f00d ff82    	bl	0x700ad450 <CSL_pktdmaGetTxRT> @ imm = #0xdf04
;             if(FALSE == pktdmaRtStatus.enable)
7009f54c: 9800         	ldr	r0, [sp]
7009f54e: b908         	cbnz	r0, 0x7009f554 <Udma_chDisableBlkCpyChan+0xa4> @ imm = #0x2
7009f550: e7ff         	b	0x7009f552 <Udma_chDisableBlkCpyChan+0xa2> @ imm = #-0x2
;                 break;
7009f552: e013         	b	0x7009f57c <Udma_chDisableBlkCpyChan+0xcc> @ imm = #0x26
;         }
7009f554: e7ff         	b	0x7009f556 <Udma_chDisableBlkCpyChan+0xa6> @ imm = #-0x2
7009f556: e7ff         	b	0x7009f558 <Udma_chDisableBlkCpyChan+0xa8> @ imm = #-0x2
;         if(currTimeout > timeout)
7009f558: 980c         	ldr	r0, [sp, #0x30]
7009f55a: 990e         	ldr	r1, [sp, #0x38]
7009f55c: 4288         	cmp	r0, r1
7009f55e: d904         	bls	0x7009f56a <Udma_chDisableBlkCpyChan+0xba> @ imm = #0x8
7009f560: e7ff         	b	0x7009f562 <Udma_chDisableBlkCpyChan+0xb2> @ imm = #-0x2
7009f562: f06f 0003    	mvn	r0, #0x3
;             retVal = UDMA_ETIMEOUT;
7009f566: 900d         	str	r0, [sp, #0x34]
;         }
7009f568: e007         	b	0x7009f57a <Udma_chDisableBlkCpyChan+0xca> @ imm = #0xe
7009f56a: f44f 707a    	mov.w	r0, #0x3e8
;             (void) ClockP_usleep(1000U);
7009f56e: f00b fe07    	bl	0x700ab180 <ClockP_usleep> @ imm = #0xbc0e
;             currTimeout++;
7009f572: 980c         	ldr	r0, [sp, #0x30]
7009f574: 3001         	adds	r0, #0x1
7009f576: 900c         	str	r0, [sp, #0x30]
7009f578: e7ff         	b	0x7009f57a <Udma_chDisableBlkCpyChan+0xca> @ imm = #-0x2
;     while(UDMA_SOK == retVal)
7009f57a: e7c7         	b	0x7009f50c <Udma_chDisableBlkCpyChan+0x5c> @ imm = #-0x72
;     if(UDMA_SOK != retVal)
7009f57c: 980d         	ldr	r0, [sp, #0x34]
7009f57e: 2800         	cmp	r0, #0x0
7009f580: d05f         	beq	0x7009f642 <Udma_chDisableBlkCpyChan+0x192> @ imm = #0xbe
7009f582: e7ff         	b	0x7009f584 <Udma_chDisableBlkCpyChan+0xd4> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f584: 980b         	ldr	r0, [sp, #0x2c]
7009f586: 6800         	ldr	r0, [r0]
7009f588: 2801         	cmp	r0, #0x1
7009f58a: d10a         	bne	0x7009f5a2 <Udma_chDisableBlkCpyChan+0xf2> @ imm = #0x14
7009f58c: e7ff         	b	0x7009f58e <Udma_chDisableBlkCpyChan+0xde> @ imm = #-0x2
;                         &drvHandle->bcdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009f58e: 980b         	ldr	r0, [sp, #0x2c]
7009f590: 3008         	adds	r0, #0x8
7009f592: 990f         	ldr	r1, [sp, #0x3c]
7009f594: 6ec9         	ldr	r1, [r1, #0x6c]
7009f596: 2201         	movs	r2, #0x1
7009f598: 2300         	movs	r3, #0x0
;             retVal = CSL_bcdmaTeardownTxChan(
7009f59a: f00e f909    	bl	0x700ad7b0 <CSL_bcdmaTeardownTxChan> @ imm = #0xe212
7009f59e: 900d         	str	r0, [sp, #0x34]
;         }
7009f5a0: e00f         	b	0x7009f5c2 <Udma_chDisableBlkCpyChan+0x112> @ imm = #0x1e
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f5a2: 980b         	ldr	r0, [sp, #0x2c]
7009f5a4: 6800         	ldr	r0, [r0]
7009f5a6: 2802         	cmp	r0, #0x2
7009f5a8: d10a         	bne	0x7009f5c0 <Udma_chDisableBlkCpyChan+0x110> @ imm = #0x14
7009f5aa: e7ff         	b	0x7009f5ac <Udma_chDisableBlkCpyChan+0xfc> @ imm = #-0x2
;                         &drvHandle->pktdmaRegs, chHandle->txChNum, (bool)true, (bool)false);
7009f5ac: 980b         	ldr	r0, [sp, #0x2c]
7009f5ae: 3054         	adds	r0, #0x54
7009f5b0: 990f         	ldr	r1, [sp, #0x3c]
7009f5b2: 6ec9         	ldr	r1, [r1, #0x6c]
7009f5b4: 2201         	movs	r2, #0x1
7009f5b6: 2300         	movs	r3, #0x0
;             retVal = CSL_pktdmaTeardownTxChan(
7009f5b8: f00e ffa2    	bl	0x700ae500 <CSL_pktdmaTeardownTxChan> @ imm = #0xef44
7009f5bc: 900d         	str	r0, [sp, #0x34]
;         }
7009f5be: e7ff         	b	0x7009f5c0 <Udma_chDisableBlkCpyChan+0x110> @ imm = #-0x2
7009f5c0: e7ff         	b	0x7009f5c2 <Udma_chDisableBlkCpyChan+0x112> @ imm = #-0x2
;         if(CSL_PASS != retVal)
7009f5c2: 980d         	ldr	r0, [sp, #0x34]
7009f5c4: b108         	cbz	r0, 0x7009f5ca <Udma_chDisableBlkCpyChan+0x11a> @ imm = #0x2
7009f5c6: e7ff         	b	0x7009f5c8 <Udma_chDisableBlkCpyChan+0x118> @ imm = #-0x2
;         }
7009f5c8: e7ff         	b	0x7009f5ca <Udma_chDisableBlkCpyChan+0x11a> @ imm = #-0x2
7009f5ca: 2000         	movs	r0, #0x0
;         currTimeout = 0U;
7009f5cc: 900c         	str	r0, [sp, #0x30]
;         while(UDMA_SOK == retVal)
7009f5ce: e7ff         	b	0x7009f5d0 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x2
7009f5d0: 980d         	ldr	r0, [sp, #0x34]
7009f5d2: bba8         	cbnz	r0, 0x7009f640 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x6a
7009f5d4: e7ff         	b	0x7009f5d6 <Udma_chDisableBlkCpyChan+0x126> @ imm = #-0x2
;             if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f5d6: 980b         	ldr	r0, [sp, #0x2c]
7009f5d8: 6800         	ldr	r0, [r0]
7009f5da: 2801         	cmp	r0, #0x1
7009f5dc: d10c         	bne	0x7009f5f8 <Udma_chDisableBlkCpyChan+0x148> @ imm = #0x18
7009f5de: e7ff         	b	0x7009f5e0 <Udma_chDisableBlkCpyChan+0x130> @ imm = #-0x2
;                 (void) CSL_bcdmaGetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f5e0: 980b         	ldr	r0, [sp, #0x2c]
7009f5e2: 3008         	adds	r0, #0x8
7009f5e4: 990f         	ldr	r1, [sp, #0x3c]
7009f5e6: 6ec9         	ldr	r1, [r1, #0x6c]
7009f5e8: aa05         	add	r2, sp, #0x14
7009f5ea: f00f fa81    	bl	0x700aeaf0 <CSL_bcdmaGetTxRT> @ imm = #0xf502
;                 if(FALSE == bcdmaRtStatus.enable)
7009f5ee: 9805         	ldr	r0, [sp, #0x14]
7009f5f0: b908         	cbnz	r0, 0x7009f5f6 <Udma_chDisableBlkCpyChan+0x146> @ imm = #0x2
7009f5f2: e7ff         	b	0x7009f5f4 <Udma_chDisableBlkCpyChan+0x144> @ imm = #-0x2
;                     break;
7009f5f4: e024         	b	0x7009f640 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x48
;             }
7009f5f6: e011         	b	0x7009f61c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #0x22
;             else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f5f8: 980b         	ldr	r0, [sp, #0x2c]
7009f5fa: 6800         	ldr	r0, [r0]
7009f5fc: 2802         	cmp	r0, #0x2
7009f5fe: d10c         	bne	0x7009f61a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #0x18
7009f600: e7ff         	b	0x7009f602 <Udma_chDisableBlkCpyChan+0x152> @ imm = #-0x2
;                 (void) CSL_pktdmaGetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f602: 980b         	ldr	r0, [sp, #0x2c]
7009f604: 3054         	adds	r0, #0x54
7009f606: 990f         	ldr	r1, [sp, #0x3c]
7009f608: 6ec9         	ldr	r1, [r1, #0x6c]
7009f60a: 466a         	mov	r2, sp
7009f60c: f00d ff20    	bl	0x700ad450 <CSL_pktdmaGetTxRT> @ imm = #0xde40
;                 if(FALSE == pktdmaRtStatus.enable)
7009f610: 9800         	ldr	r0, [sp]
7009f612: b908         	cbnz	r0, 0x7009f618 <Udma_chDisableBlkCpyChan+0x168> @ imm = #0x2
7009f614: e7ff         	b	0x7009f616 <Udma_chDisableBlkCpyChan+0x166> @ imm = #-0x2
;                     break;
7009f616: e013         	b	0x7009f640 <Udma_chDisableBlkCpyChan+0x190> @ imm = #0x26
;             }
7009f618: e7ff         	b	0x7009f61a <Udma_chDisableBlkCpyChan+0x16a> @ imm = #-0x2
7009f61a: e7ff         	b	0x7009f61c <Udma_chDisableBlkCpyChan+0x16c> @ imm = #-0x2
;             if(currTimeout > timeout)
7009f61c: 980c         	ldr	r0, [sp, #0x30]
7009f61e: 990e         	ldr	r1, [sp, #0x38]
7009f620: 4288         	cmp	r0, r1
7009f622: d904         	bls	0x7009f62e <Udma_chDisableBlkCpyChan+0x17e> @ imm = #0x8
7009f624: e7ff         	b	0x7009f626 <Udma_chDisableBlkCpyChan+0x176> @ imm = #-0x2
7009f626: f06f 0003    	mvn	r0, #0x3
;                 retVal = UDMA_ETIMEOUT;
7009f62a: 900d         	str	r0, [sp, #0x34]
;             }
7009f62c: e007         	b	0x7009f63e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #0xe
7009f62e: f44f 707a    	mov.w	r0, #0x3e8
;                 (void) ClockP_usleep(1000U);
7009f632: f00b fda5    	bl	0x700ab180 <ClockP_usleep> @ imm = #0xbb4a
;                 currTimeout++;
7009f636: 980c         	ldr	r0, [sp, #0x30]
7009f638: 3001         	adds	r0, #0x1
7009f63a: 900c         	str	r0, [sp, #0x30]
7009f63c: e7ff         	b	0x7009f63e <Udma_chDisableBlkCpyChan+0x18e> @ imm = #-0x2
;         while(UDMA_SOK == retVal)
7009f63e: e7c7         	b	0x7009f5d0 <Udma_chDisableBlkCpyChan+0x120> @ imm = #-0x72
;     }
7009f640: e7ff         	b	0x7009f642 <Udma_chDisableBlkCpyChan+0x192> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f642: 980d         	ldr	r0, [sp, #0x34]
7009f644: bb20         	cbnz	r0, 0x7009f690 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #0x48
7009f646: e7ff         	b	0x7009f648 <Udma_chDisableBlkCpyChan+0x198> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
7009f648: 980b         	ldr	r0, [sp, #0x2c]
7009f64a: 6800         	ldr	r0, [r0]
7009f64c: 2801         	cmp	r0, #0x1
7009f64e: d10c         	bne	0x7009f66a <Udma_chDisableBlkCpyChan+0x1ba> @ imm = #0x18
7009f650: e7ff         	b	0x7009f652 <Udma_chDisableBlkCpyChan+0x1a2> @ imm = #-0x2
7009f652: 2000         	movs	r0, #0x0
;             bcdmaRtStatus.enable   = FALSE;
7009f654: 9005         	str	r0, [sp, #0x14]
;             bcdmaRtStatus.teardown = FALSE;
7009f656: 9006         	str	r0, [sp, #0x18]
;             bcdmaRtStatus.forcedTeardown = FALSE;
7009f658: 9009         	str	r0, [sp, #0x24]
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum, &bcdmaRtStatus);
7009f65a: 980b         	ldr	r0, [sp, #0x2c]
7009f65c: 3008         	adds	r0, #0x8
7009f65e: 990f         	ldr	r1, [sp, #0x3c]
7009f660: 6ec9         	ldr	r1, [r1, #0x6c]
7009f662: aa05         	add	r2, sp, #0x14
7009f664: f00f fa74    	bl	0x700aeb50 <CSL_bcdmaSetTxRT> @ imm = #0xf4e8
;         }
7009f668: e011         	b	0x7009f68e <Udma_chDisableBlkCpyChan+0x1de> @ imm = #0x22
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
7009f66a: 980b         	ldr	r0, [sp, #0x2c]
7009f66c: 6800         	ldr	r0, [r0]
7009f66e: 2802         	cmp	r0, #0x2
7009f670: d10c         	bne	0x7009f68c <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #0x18
7009f672: e7ff         	b	0x7009f674 <Udma_chDisableBlkCpyChan+0x1c4> @ imm = #-0x2
7009f674: 2000         	movs	r0, #0x0
;             pktdmaRtStatus.enable   = FALSE;
7009f676: 9000         	str	r0, [sp]
;             pktdmaRtStatus.teardown = FALSE;
7009f678: 9001         	str	r0, [sp, #0x4]
;             pktdmaRtStatus.forcedTeardown = FALSE;
7009f67a: 9004         	str	r0, [sp, #0x10]
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtStatus);
7009f67c: 980b         	ldr	r0, [sp, #0x2c]
7009f67e: 3054         	adds	r0, #0x54
7009f680: 990f         	ldr	r1, [sp, #0x3c]
7009f682: 6ec9         	ldr	r1, [r1, #0x6c]
7009f684: 466a         	mov	r2, sp
7009f686: f00e fc9b    	bl	0x700adfc0 <CSL_pktdmaSetTxRT> @ imm = #0xe936
;         }
7009f68a: e7ff         	b	0x7009f68c <Udma_chDisableBlkCpyChan+0x1dc> @ imm = #-0x2
7009f68c: e7ff         	b	0x7009f68e <Udma_chDisableBlkCpyChan+0x1de> @ imm = #-0x2
;     }
7009f68e: e7ff         	b	0x7009f690 <Udma_chDisableBlkCpyChan+0x1e0> @ imm = #-0x2
;     return (retVal);
7009f690: 980d         	ldr	r0, [sp, #0x34]
7009f692: b010         	add	sp, #0x40
7009f694: bd80         	pop	{r7, pc}
		...
7009f69e: 0000         	movs	r0, r0

7009f6a0 <Udma_flowConfig>:
; {
7009f6a0: b580         	push	{r7, lr}
7009f6a2: b09e         	sub	sp, #0x78
7009f6a4: 901d         	str	r0, [sp, #0x74]
7009f6a6: 911c         	str	r1, [sp, #0x70]
7009f6a8: 921b         	str	r2, [sp, #0x6c]
7009f6aa: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
7009f6ac: 901a         	str	r0, [sp, #0x68]
;     Udma_FlowHandleInt  flowHandleInt = (Udma_FlowHandleInt) flowHandle;
7009f6ae: 981d         	ldr	r0, [sp, #0x74]
7009f6b0: 9018         	str	r0, [sp, #0x60]
;     if((NULL_PTR == flowHandleInt) ||
7009f6b2: 9818         	ldr	r0, [sp, #0x60]
7009f6b4: b160         	cbz	r0, 0x7009f6d0 <Udma_flowConfig+0x30> @ imm = #0x18
7009f6b6: e7ff         	b	0x7009f6b8 <Udma_flowConfig+0x18> @ imm = #-0x2
;        (flowHandleInt->flowInitDone != UDMA_INIT_DONE) ||
7009f6b8: 9818         	ldr	r0, [sp, #0x60]
7009f6ba: 68c0         	ldr	r0, [r0, #0xc]
7009f6bc: f64a 31cd    	movw	r1, #0xabcd
7009f6c0: f6ca 31dc    	movt	r1, #0xabdc
7009f6c4: 4288         	cmp	r0, r1
7009f6c6: d103         	bne	0x7009f6d0 <Udma_flowConfig+0x30> @ imm = #0x6
7009f6c8: e7ff         	b	0x7009f6ca <Udma_flowConfig+0x2a> @ imm = #-0x2
;        (NULL_PTR == flowPrms))
7009f6ca: 981b         	ldr	r0, [sp, #0x6c]
;     if((NULL_PTR == flowHandleInt) ||
7009f6cc: b920         	cbnz	r0, 0x7009f6d8 <Udma_flowConfig+0x38> @ imm = #0x8
7009f6ce: e7ff         	b	0x7009f6d0 <Udma_flowConfig+0x30> @ imm = #-0x2
7009f6d0: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
7009f6d4: 901a         	str	r0, [sp, #0x68]
;     }
7009f6d6: e7ff         	b	0x7009f6d8 <Udma_flowConfig+0x38> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f6d8: 981a         	ldr	r0, [sp, #0x68]
7009f6da: b9a8         	cbnz	r0, 0x7009f708 <Udma_flowConfig+0x68> @ imm = #0x2a
7009f6dc: e7ff         	b	0x7009f6de <Udma_flowConfig+0x3e> @ imm = #-0x2
;         drvHandle = flowHandleInt->drvHandle;
7009f6de: 9818         	ldr	r0, [sp, #0x60]
7009f6e0: 6800         	ldr	r0, [r0]
7009f6e2: 9019         	str	r0, [sp, #0x64]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
7009f6e4: 9819         	ldr	r0, [sp, #0x64]
7009f6e6: b150         	cbz	r0, 0x7009f6fe <Udma_flowConfig+0x5e> @ imm = #0x14
7009f6e8: e7ff         	b	0x7009f6ea <Udma_flowConfig+0x4a> @ imm = #-0x2
7009f6ea: 9819         	ldr	r0, [sp, #0x64]
7009f6ec: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
7009f6f0: f64a 31cd    	movw	r1, #0xabcd
7009f6f4: f6ca 31dc    	movt	r1, #0xabdc
7009f6f8: 4288         	cmp	r0, r1
7009f6fa: d004         	beq	0x7009f706 <Udma_flowConfig+0x66> @ imm = #0x8
7009f6fc: e7ff         	b	0x7009f6fe <Udma_flowConfig+0x5e> @ imm = #-0x2
7009f6fe: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
7009f702: 901a         	str	r0, [sp, #0x68]
;         }
7009f704: e7ff         	b	0x7009f706 <Udma_flowConfig+0x66> @ imm = #-0x2
;     }
7009f706: e7ff         	b	0x7009f708 <Udma_flowConfig+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f708: 981a         	ldr	r0, [sp, #0x68]
7009f70a: b958         	cbnz	r0, 0x7009f724 <Udma_flowConfig+0x84> @ imm = #0x16
7009f70c: e7ff         	b	0x7009f70e <Udma_flowConfig+0x6e> @ imm = #-0x2
;         if(flowIdx >= flowHandleInt->flowCnt)
7009f70e: 981c         	ldr	r0, [sp, #0x70]
7009f710: 9918         	ldr	r1, [sp, #0x60]
7009f712: 6889         	ldr	r1, [r1, #0x8]
7009f714: 4288         	cmp	r0, r1
7009f716: d304         	blo	0x7009f722 <Udma_flowConfig+0x82> @ imm = #0x8
7009f718: e7ff         	b	0x7009f71a <Udma_flowConfig+0x7a> @ imm = #-0x2
7009f71a: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
7009f71e: 901a         	str	r0, [sp, #0x68]
;         }
7009f720: e7ff         	b	0x7009f722 <Udma_flowConfig+0x82> @ imm = #-0x2
;     }
7009f722: e7ff         	b	0x7009f724 <Udma_flowConfig+0x84> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
7009f724: 981a         	ldr	r0, [sp, #0x68]
7009f726: 2800         	cmp	r0, #0x0
7009f728: f040 80a3    	bne.w	0x7009f872 <Udma_flowConfig+0x1d2> @ imm = #0x146
7009f72c: e7ff         	b	0x7009f72e <Udma_flowConfig+0x8e> @ imm = #-0x2
7009f72e: f64f 70ff    	movw	r0, #0xffff
7009f732: f2c0 0007    	movt	r0, #0x7
;         rmFlowReq.valid_params          = TISCI_MSG_VALUE_RM_UDMAP_FLOW_EINFO_PRESENT_VALID |
7009f736: 900f         	str	r0, [sp, #0x3c]
;         rmFlowReq.nav_id                = drvHandle->devIdUdma;
7009f738: 9819         	ldr	r0, [sp, #0x64]
7009f73a: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009f73e: f8ad 0040    	strh.w	r0, [sp, #0x40]
;         rmFlowReq.flow_index            = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009f742: 9818         	ldr	r0, [sp, #0x60]
7009f744: 6840         	ldr	r0, [r0, #0x4]
7009f746: 991c         	ldr	r1, [sp, #0x70]
7009f748: 4408         	add	r0, r1
7009f74a: f8ad 0042    	strh.w	r0, [sp, #0x42]
;         rmFlowReq.rx_einfo_present      = flowPrms->einfoPresent;
7009f74e: 981b         	ldr	r0, [sp, #0x6c]
7009f750: 7900         	ldrb	r0, [r0, #0x4]
7009f752: f88d 0044    	strb.w	r0, [sp, #0x44]
;         rmFlowReq.rx_psinfo_present     = flowPrms->psInfoPresent;
7009f756: 981b         	ldr	r0, [sp, #0x6c]
7009f758: 7940         	ldrb	r0, [r0, #0x5]
7009f75a: f88d 0045    	strb.w	r0, [sp, #0x45]
;         rmFlowReq.rx_error_handling     = flowPrms->errorHandling;
7009f75e: 981b         	ldr	r0, [sp, #0x6c]
7009f760: 7980         	ldrb	r0, [r0, #0x6]
7009f762: f88d 0046    	strb.w	r0, [sp, #0x46]
;         rmFlowReq.rx_desc_type          = flowPrms->descType;
7009f766: 981b         	ldr	r0, [sp, #0x6c]
7009f768: 79c0         	ldrb	r0, [r0, #0x7]
7009f76a: f88d 0047    	strb.w	r0, [sp, #0x47]
;         rmFlowReq.rx_ps_location        = flowPrms->psLocation;
7009f76e: 981b         	ldr	r0, [sp, #0x6c]
7009f770: 7a00         	ldrb	r0, [r0, #0x8]
7009f772: f88d 005c    	strb.w	r0, [sp, #0x5c]
;         rmFlowReq.rx_sop_offset         = flowPrms->sopOffset;
7009f776: 981b         	ldr	r0, [sp, #0x6c]
7009f778: 8940         	ldrh	r0, [r0, #0xa]
7009f77a: f8ad 0048    	strh.w	r0, [sp, #0x48]
;         rmFlowReq.rx_dest_qnum          = flowPrms->defaultRxCQ;
7009f77e: 981b         	ldr	r0, [sp, #0x6c]
7009f780: 8980         	ldrh	r0, [r0, #0xc]
7009f782: f8ad 004a    	strh.w	r0, [sp, #0x4a]
;         rmFlowReq.rx_src_tag_hi         = flowPrms->srcTagHi;
7009f786: 981b         	ldr	r0, [sp, #0x6c]
7009f788: 7b80         	ldrb	r0, [r0, #0xe]
7009f78a: f88d 004c    	strb.w	r0, [sp, #0x4c]
;         rmFlowReq.rx_src_tag_lo         = flowPrms->srcTagLo;
7009f78e: 981b         	ldr	r0, [sp, #0x6c]
7009f790: 7bc0         	ldrb	r0, [r0, #0xf]
7009f792: f88d 004d    	strb.w	r0, [sp, #0x4d]
;         rmFlowReq.rx_src_tag_hi_sel     = flowPrms->srcTagHiSel;
7009f796: 981b         	ldr	r0, [sp, #0x6c]
7009f798: 7c00         	ldrb	r0, [r0, #0x10]
7009f79a: f88d 0050    	strb.w	r0, [sp, #0x50]
;         rmFlowReq.rx_src_tag_lo_sel     = flowPrms->srcTagLoSel;
7009f79e: 981b         	ldr	r0, [sp, #0x6c]
7009f7a0: 7c40         	ldrb	r0, [r0, #0x11]
7009f7a2: f88d 0051    	strb.w	r0, [sp, #0x51]
;         rmFlowReq.rx_dest_tag_hi        = flowPrms->destTagHi;
7009f7a6: 981b         	ldr	r0, [sp, #0x6c]
7009f7a8: 7c80         	ldrb	r0, [r0, #0x12]
7009f7aa: f88d 004e    	strb.w	r0, [sp, #0x4e]
;         rmFlowReq.rx_dest_tag_lo        = flowPrms->destTagLo;
7009f7ae: 981b         	ldr	r0, [sp, #0x6c]
7009f7b0: 7cc0         	ldrb	r0, [r0, #0x13]
7009f7b2: f88d 004f    	strb.w	r0, [sp, #0x4f]
;         rmFlowReq.rx_dest_tag_hi_sel    = flowPrms->destTagHiSel;
7009f7b6: 981b         	ldr	r0, [sp, #0x6c]
7009f7b8: 7d00         	ldrb	r0, [r0, #0x14]
7009f7ba: f88d 0052    	strb.w	r0, [sp, #0x52]
;         rmFlowReq.rx_dest_tag_lo_sel    = flowPrms->destTagLoSel;
7009f7be: 981b         	ldr	r0, [sp, #0x6c]
7009f7c0: 7d40         	ldrb	r0, [r0, #0x15]
7009f7c2: f88d 0053    	strb.w	r0, [sp, #0x53]
;         rmFlowReq.rx_fdq0_sz0_qnum      = flowPrms->fdq0Sz0Qnum;
7009f7c6: 981b         	ldr	r0, [sp, #0x6c]
7009f7c8: 8b00         	ldrh	r0, [r0, #0x18]
7009f7ca: f8ad 0054    	strh.w	r0, [sp, #0x54]
;         rmFlowReq.rx_fdq1_qnum          = flowPrms->fdq1Qnum;
7009f7ce: 981b         	ldr	r0, [sp, #0x6c]
7009f7d0: 8b40         	ldrh	r0, [r0, #0x1a]
7009f7d2: f8ad 0056    	strh.w	r0, [sp, #0x56]
;         rmFlowReq.rx_fdq2_qnum          = flowPrms->fdq2Qnum;
7009f7d6: 981b         	ldr	r0, [sp, #0x6c]
7009f7d8: 8b80         	ldrh	r0, [r0, #0x1c]
7009f7da: f8ad 0058    	strh.w	r0, [sp, #0x58]
;         rmFlowReq.rx_fdq3_qnum          = flowPrms->fdq3Qnum;
7009f7de: 981b         	ldr	r0, [sp, #0x6c]
7009f7e0: 8bc0         	ldrh	r0, [r0, #0x1e]
7009f7e2: f8ad 005a    	strh.w	r0, [sp, #0x5a]
7009f7e6: a80d         	add	r0, sp, #0x34
7009f7e8: a90b         	add	r1, sp, #0x2c
7009f7ea: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapFlowCfg(
7009f7ee: f00d f8b7    	bl	0x700ac960 <Sciclient_rmUdmapFlowCfg> @ imm = #0xd16e
7009f7f2: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009f7f4: 981a         	ldr	r0, [sp, #0x68]
7009f7f6: b108         	cbz	r0, 0x7009f7fc <Udma_flowConfig+0x15c> @ imm = #0x2
7009f7f8: e7ff         	b	0x7009f7fa <Udma_flowConfig+0x15a> @ imm = #-0x2
;         }
7009f7fa: e7ff         	b	0x7009f7fc <Udma_flowConfig+0x15c> @ imm = #-0x2
7009f7fc: 207f         	movs	r0, #0x7f
;         rmOptFlowReq.valid_params       = TISCI_MSG_VALUE_RM_UDMAP_FLOW_SIZE_THRESH0_VALID |
7009f7fe: 9005         	str	r0, [sp, #0x14]
;         rmOptFlowReq.nav_id             = drvHandle->devIdUdma;
7009f800: 9819         	ldr	r0, [sp, #0x64]
7009f802: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
7009f806: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         rmOptFlowReq.flow_index         = (uint16_t)(flowHandleInt->flowStart + flowIdx);
7009f80a: 9818         	ldr	r0, [sp, #0x60]
7009f80c: 6840         	ldr	r0, [r0, #0x4]
7009f80e: 991c         	ldr	r1, [sp, #0x70]
7009f810: 4408         	add	r0, r1
7009f812: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         rmOptFlowReq.rx_size_thresh0    = (flowPrms->sizeThresh0 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f816: 981b         	ldr	r0, [sp, #0x6c]
7009f818: 8c00         	ldrh	r0, [r0, #0x20]
7009f81a: 0940         	lsrs	r0, r0, #0x5
7009f81c: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         rmOptFlowReq.rx_size_thresh1    = (flowPrms->sizeThresh1 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f820: 981b         	ldr	r0, [sp, #0x6c]
7009f822: 8c40         	ldrh	r0, [r0, #0x22]
7009f824: 0940         	lsrs	r0, r0, #0x5
7009f826: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmOptFlowReq.rx_size_thresh2    = (flowPrms->sizeThresh2 >> UDMA_RFLOW_RX_SIZE_THRESH_VAL_SHIFT);
7009f82a: 981b         	ldr	r0, [sp, #0x6c]
7009f82c: 8c80         	ldrh	r0, [r0, #0x24]
7009f82e: 0940         	lsrs	r0, r0, #0x5
7009f830: f8ad 0020    	strh.w	r0, [sp, #0x20]
;         rmOptFlowReq.rx_fdq0_sz1_qnum   = flowPrms->fdq0Sz1Qnum;
7009f834: 981b         	ldr	r0, [sp, #0x6c]
7009f836: 8cc0         	ldrh	r0, [r0, #0x26]
7009f838: f8ad 0022    	strh.w	r0, [sp, #0x22]
;         rmOptFlowReq.rx_fdq0_sz2_qnum   = flowPrms->fdq0Sz2Qnum;
7009f83c: 981b         	ldr	r0, [sp, #0x6c]
7009f83e: 8d00         	ldrh	r0, [r0, #0x28]
7009f840: f8ad 0024    	strh.w	r0, [sp, #0x24]
;         rmOptFlowReq.rx_fdq0_sz3_qnum   = flowPrms->fdq0Sz3Qnum;
7009f844: 981b         	ldr	r0, [sp, #0x6c]
7009f846: 8d40         	ldrh	r0, [r0, #0x2a]
7009f848: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmOptFlowReq.rx_size_thresh_en  = flowPrms->sizeThreshEn;
7009f84c: 981b         	ldr	r0, [sp, #0x6c]
7009f84e: 7d80         	ldrb	r0, [r0, #0x16]
7009f850: f88d 0028    	strb.w	r0, [sp, #0x28]
7009f854: a803         	add	r0, sp, #0xc
7009f856: a901         	add	r1, sp, #0x4
7009f858: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal += Sciclient_rmUdmapFlowSizeThreshCfg(
7009f85c: f00d f8b0    	bl	0x700ac9c0 <Sciclient_rmUdmapFlowSizeThreshCfg> @ imm = #0xd160
7009f860: 4601         	mov	r1, r0
7009f862: 981a         	ldr	r0, [sp, #0x68]
7009f864: 4408         	add	r0, r1
7009f866: 901a         	str	r0, [sp, #0x68]
;         if(CSL_PASS != retVal)
7009f868: 981a         	ldr	r0, [sp, #0x68]
7009f86a: b108         	cbz	r0, 0x7009f870 <Udma_flowConfig+0x1d0> @ imm = #0x2
7009f86c: e7ff         	b	0x7009f86e <Udma_flowConfig+0x1ce> @ imm = #-0x2
;         }
7009f86e: e7ff         	b	0x7009f870 <Udma_flowConfig+0x1d0> @ imm = #-0x2
;     }
7009f870: e7ff         	b	0x7009f872 <Udma_flowConfig+0x1d2> @ imm = #-0x2
;     return (retVal);
7009f872: 981a         	ldr	r0, [sp, #0x68]
7009f874: b01e         	add	sp, #0x78
7009f876: bd80         	pop	{r7, pc}

7009f878 <__udivsi3>:
7009f878: e3510001     	cmp	r1, #1
7009f87c: 3a00000b     	blo	0x7009f8b0 <__udivsi3+0x38> @ imm = #0x2c
7009f880: 012fff1e     	bxeq	lr
7009f884: e1500001     	cmp	r0, r1
7009f888: 33a00000     	movlo	r0, #0
7009f88c: 312fff1e     	bxlo	lr
7009f890: e16fcf10     	clz	r12, r0
7009f894: e16f3f11     	clz	r3, r1
7009f898: e043300c     	sub	r3, r3, r12
7009f89c: e28fce19     	add	r12, pc, #400
7009f8a0: e04cc103     	sub	r12, r12, r3, lsl #2
7009f8a4: e04cc183     	sub	r12, r12, r3, lsl #3
7009f8a8: e3a03000     	mov	r3, #0
7009f8ac: e12fff1c     	bx	r12
7009f8b0: e3b00000     	movs	r0, #0
7009f8b4: e92d4080     	push	{r7, lr}
7009f8b8: eb004128     	bl	0x700afd60 <__aeabi_idiv0> @ imm = #0x104a0
7009f8bc: e8bd8080     	pop	{r7, pc}
7009f8c0: e1500f81     	cmp	r0, r1, lsl #31
7009f8c4: 22833102     	addhs	r3, r3, #-2147483648
7009f8c8: 20400f81     	subhs	r0, r0, r1, lsl #31
7009f8cc: e1500f01     	cmp	r0, r1, lsl #30
7009f8d0: 22833101     	addhs	r3, r3, #1073741824
7009f8d4: 20400f01     	subhs	r0, r0, r1, lsl #30
7009f8d8: e1500e81     	cmp	r0, r1, lsl #29
7009f8dc: 22833202     	addhs	r3, r3, #536870912
7009f8e0: 20400e81     	subhs	r0, r0, r1, lsl #29
7009f8e4: e1500e01     	cmp	r0, r1, lsl #28
7009f8e8: 22833201     	addhs	r3, r3, #268435456
7009f8ec: 20400e01     	subhs	r0, r0, r1, lsl #28
7009f8f0: e1500d81     	cmp	r0, r1, lsl #27
7009f8f4: 22833302     	addhs	r3, r3, #134217728
7009f8f8: 20400d81     	subhs	r0, r0, r1, lsl #27
7009f8fc: e1500d01     	cmp	r0, r1, lsl #26
7009f900: 22833301     	addhs	r3, r3, #67108864
7009f904: 20400d01     	subhs	r0, r0, r1, lsl #26
7009f908: e1500c81     	cmp	r0, r1, lsl #25
7009f90c: 22833402     	addhs	r3, r3, #33554432
7009f910: 20400c81     	subhs	r0, r0, r1, lsl #25
7009f914: e1500c01     	cmp	r0, r1, lsl #24
7009f918: 22833401     	addhs	r3, r3, #16777216
7009f91c: 20400c01     	subhs	r0, r0, r1, lsl #24
7009f920: e1500b81     	cmp	r0, r1, lsl #23
7009f924: 22833502     	addhs	r3, r3, #8388608
7009f928: 20400b81     	subhs	r0, r0, r1, lsl #23
7009f92c: e1500b01     	cmp	r0, r1, lsl #22
7009f930: 22833501     	addhs	r3, r3, #4194304
7009f934: 20400b01     	subhs	r0, r0, r1, lsl #22
7009f938: e1500a81     	cmp	r0, r1, lsl #21
7009f93c: 22833602     	addhs	r3, r3, #2097152
7009f940: 20400a81     	subhs	r0, r0, r1, lsl #21
7009f944: e1500a01     	cmp	r0, r1, lsl #20
7009f948: 22833601     	addhs	r3, r3, #1048576
7009f94c: 20400a01     	subhs	r0, r0, r1, lsl #20
7009f950: e1500981     	cmp	r0, r1, lsl #19
7009f954: 22833702     	addhs	r3, r3, #524288
7009f958: 20400981     	subhs	r0, r0, r1, lsl #19
7009f95c: e1500901     	cmp	r0, r1, lsl #18
7009f960: 22833701     	addhs	r3, r3, #262144
7009f964: 20400901     	subhs	r0, r0, r1, lsl #18
7009f968: e1500881     	cmp	r0, r1, lsl #17
7009f96c: 22833802     	addhs	r3, r3, #131072
7009f970: 20400881     	subhs	r0, r0, r1, lsl #17
7009f974: e1500801     	cmp	r0, r1, lsl #16
7009f978: 22833801     	addhs	r3, r3, #65536
7009f97c: 20400801     	subhs	r0, r0, r1, lsl #16
7009f980: e1500781     	cmp	r0, r1, lsl #15
7009f984: 22833902     	addhs	r3, r3, #32768
7009f988: 20400781     	subhs	r0, r0, r1, lsl #15
7009f98c: e1500701     	cmp	r0, r1, lsl #14
7009f990: 22833901     	addhs	r3, r3, #16384
7009f994: 20400701     	subhs	r0, r0, r1, lsl #14
7009f998: e1500681     	cmp	r0, r1, lsl #13
7009f99c: 22833a02     	addhs	r3, r3, #8192
7009f9a0: 20400681     	subhs	r0, r0, r1, lsl #13
7009f9a4: e1500601     	cmp	r0, r1, lsl #12
7009f9a8: 22833a01     	addhs	r3, r3, #4096
7009f9ac: 20400601     	subhs	r0, r0, r1, lsl #12
7009f9b0: e1500581     	cmp	r0, r1, lsl #11
7009f9b4: 22833b02     	addhs	r3, r3, #2048
7009f9b8: 20400581     	subhs	r0, r0, r1, lsl #11
7009f9bc: e1500501     	cmp	r0, r1, lsl #10
7009f9c0: 22833b01     	addhs	r3, r3, #1024
7009f9c4: 20400501     	subhs	r0, r0, r1, lsl #10
7009f9c8: e1500481     	cmp	r0, r1, lsl #9
7009f9cc: 22833c02     	addhs	r3, r3, #512
7009f9d0: 20400481     	subhs	r0, r0, r1, lsl #9
7009f9d4: e1500401     	cmp	r0, r1, lsl #8
7009f9d8: 22833c01     	addhs	r3, r3, #256
7009f9dc: 20400401     	subhs	r0, r0, r1, lsl #8
7009f9e0: e1500381     	cmp	r0, r1, lsl #7
7009f9e4: 22833080     	addhs	r3, r3, #128
7009f9e8: 20400381     	subhs	r0, r0, r1, lsl #7
7009f9ec: e1500301     	cmp	r0, r1, lsl #6
7009f9f0: 22833040     	addhs	r3, r3, #64
7009f9f4: 20400301     	subhs	r0, r0, r1, lsl #6
7009f9f8: e1500281     	cmp	r0, r1, lsl #5
7009f9fc: 22833020     	addhs	r3, r3, #32
7009fa00: 20400281     	subhs	r0, r0, r1, lsl #5
7009fa04: e1500201     	cmp	r0, r1, lsl #4
7009fa08: 22833010     	addhs	r3, r3, #16
7009fa0c: 20400201     	subhs	r0, r0, r1, lsl #4
7009fa10: e1500181     	cmp	r0, r1, lsl #3
7009fa14: 22833008     	addhs	r3, r3, #8
7009fa18: 20400181     	subhs	r0, r0, r1, lsl #3
7009fa1c: e1500101     	cmp	r0, r1, lsl #2
7009fa20: 22833004     	addhs	r3, r3, #4
7009fa24: 20400101     	subhs	r0, r0, r1, lsl #2
7009fa28: e1500081     	cmp	r0, r1, lsl #1
7009fa2c: 22833002     	addhs	r3, r3, #2
7009fa30: 20400081     	subhs	r0, r0, r1, lsl #1
7009fa34: e1500001     	cmp	r0, r1
7009fa38: 22833001     	addhs	r3, r3, #1
7009fa3c: 20400001     	subhs	r0, r0, r1
7009fa40: e1a00003     	mov	r0, r3
7009fa44: e12fff1e     	bx	lr
		...

7009fa50 <SOC_moduleSetClockFrequency>:
; {
7009fa50: b580         	push	{r7, lr}
7009fa52: b090         	sub	sp, #0x40
7009fa54: 900f         	str	r0, [sp, #0x3c]
7009fa56: 910e         	str	r1, [sp, #0x38]
7009fa58: 930d         	str	r3, [sp, #0x34]
7009fa5a: 920c         	str	r2, [sp, #0x30]
7009fa5c: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009fa5e: 9002         	str	r0, [sp, #0x8]
7009fa60: 900b         	str	r0, [sp, #0x2c]
;     uint32_t i = 0U;
7009fa62: 900a         	str	r0, [sp, #0x28]
;     uint64_t respClkRate = 0;
7009fa64: 9009         	str	r0, [sp, #0x24]
7009fa66: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009fa68: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009fa6a: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009fa6c: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009fa6e: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009fa70: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009fa72: 980f         	ldr	r0, [sp, #0x3c]
;                                             clkId,
7009fa74: 990e         	ldr	r1, [sp, #0x38]
7009fa76: aa05         	add	r2, sp, #0x14
7009fa78: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009fa7c: f009 fc98    	bl	0x700a93b0 <Sciclient_pmModuleGetClkStatus> @ imm = #0x9930
7009fa80: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009fa82: 980b         	ldr	r0, [sp, #0x2c]
7009fa84: b948         	cbnz	r0, 0x7009fa9a <SOC_moduleSetClockFrequency+0x4a> @ imm = #0x12
7009fa86: e7ff         	b	0x7009fa88 <SOC_moduleSetClockFrequency+0x38> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009fa88: 980f         	ldr	r0, [sp, #0x3c]
;                                                    clkId,
7009fa8a: 990e         	ldr	r1, [sp, #0x38]
7009fa8c: aa07         	add	r2, sp, #0x1c
7009fa8e: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009fa92: f008 fd6d    	bl	0x700a8570 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x8ada
7009fa96: 900b         	str	r0, [sp, #0x2c]
;     }
7009fa98: e7ff         	b	0x7009fa9a <SOC_moduleSetClockFrequency+0x4a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fa9a: 980b         	ldr	r0, [sp, #0x2c]
7009fa9c: b970         	cbnz	r0, 0x7009fabc <SOC_moduleSetClockFrequency+0x6c> @ imm = #0x1c
7009fa9e: e7ff         	b	0x7009faa0 <SOC_moduleSetClockFrequency+0x50> @ imm = #-0x2
;         if(numParents > 1U)
7009faa0: 9807         	ldr	r0, [sp, #0x1c]
7009faa2: 2802         	cmp	r0, #0x2
7009faa4: d309         	blo	0x7009faba <SOC_moduleSetClockFrequency+0x6a> @ imm = #0x12
7009faa6: e7ff         	b	0x7009faa8 <SOC_moduleSetClockFrequency+0x58> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009faa8: 980f         	ldr	r0, [sp, #0x3c]
;                                                     clkId,
7009faaa: 990e         	ldr	r1, [sp, #0x38]
7009faac: aa04         	add	r2, sp, #0x10
7009faae: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009fab2: f009 fa9d    	bl	0x700a8ff0 <Sciclient_pmGetModuleClkParent> @ imm = #0x953a
7009fab6: 900b         	str	r0, [sp, #0x2c]
;         }
7009fab8: e7ff         	b	0x7009faba <SOC_moduleSetClockFrequency+0x6a> @ imm = #-0x2
;     }
7009faba: e7ff         	b	0x7009fabc <SOC_moduleSetClockFrequency+0x6c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fabc: 980b         	ldr	r0, [sp, #0x2c]
7009fabe: b960         	cbnz	r0, 0x7009fada <SOC_moduleSetClockFrequency+0x8a> @ imm = #0x18
7009fac0: e7ff         	b	0x7009fac2 <SOC_moduleSetClockFrequency+0x72> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009fac2: 980f         	ldr	r0, [sp, #0x3c]
;                                               clkId,
7009fac4: 990e         	ldr	r1, [sp, #0x38]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009fac6: 466b         	mov	r3, sp
7009fac8: f04f 32ff    	mov.w	r2, #0xffffffff
7009facc: 601a         	str	r2, [r3]
7009face: 2300         	movs	r3, #0x0
7009fad0: 461a         	mov	r2, r3
7009fad2: f00a fa45    	bl	0x700a9f60 <Sciclient_pmModuleClkRequest> @ imm = #0xa48a
7009fad6: 900b         	str	r0, [sp, #0x2c]
;     }
7009fad8: e7ff         	b	0x7009fada <SOC_moduleSetClockFrequency+0x8a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fada: 980b         	ldr	r0, [sp, #0x2c]
7009fadc: 2800         	cmp	r0, #0x0
7009fade: d14d         	bne	0x7009fb7c <SOC_moduleSetClockFrequency+0x12c> @ imm = #0x9a
7009fae0: e7ff         	b	0x7009fae2 <SOC_moduleSetClockFrequency+0x92> @ imm = #-0x2
7009fae2: 2000         	movs	r0, #0x0
;         foundParent = 0U;
7009fae4: 9003         	str	r0, [sp, #0xc]
;         for(i=0U;i<numParents;i++)
7009fae6: 900a         	str	r0, [sp, #0x28]
7009fae8: e7ff         	b	0x7009faea <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x2
7009faea: 980a         	ldr	r0, [sp, #0x28]
7009faec: 9907         	ldr	r1, [sp, #0x1c]
7009faee: 4288         	cmp	r0, r1
7009faf0: d243         	bhs	0x7009fb7a <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x86
7009faf2: e7ff         	b	0x7009faf4 <SOC_moduleSetClockFrequency+0xa4> @ imm = #-0x2
;             if (numParents > 1U)
7009faf4: 9807         	ldr	r0, [sp, #0x1c]
7009faf6: 2802         	cmp	r0, #0x2
7009faf8: d311         	blo	0x7009fb1e <SOC_moduleSetClockFrequency+0xce> @ imm = #0x22
7009fafa: e7ff         	b	0x7009fafc <SOC_moduleSetClockFrequency+0xac> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009fafc: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009fafe: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkId+i+1,
7009fb00: 9a0a         	ldr	r2, [sp, #0x28]
7009fb02: 440a         	add	r2, r1
7009fb04: 3201         	adds	r2, #0x1
7009fb06: f04f 33ff    	mov.w	r3, #0xffffffff
;                 status = Sciclient_pmSetModuleClkParent(moduleId,
7009fb0a: f009 fac1    	bl	0x700a9090 <Sciclient_pmSetModuleClkParent> @ imm = #0x9582
7009fb0e: 900b         	str	r0, [sp, #0x2c]
;                 if (status == SystemP_SUCCESS)
7009fb10: 980b         	ldr	r0, [sp, #0x2c]
7009fb12: b918         	cbnz	r0, 0x7009fb1c <SOC_moduleSetClockFrequency+0xcc> @ imm = #0x6
7009fb14: e7ff         	b	0x7009fb16 <SOC_moduleSetClockFrequency+0xc6> @ imm = #-0x2
7009fb16: 2001         	movs	r0, #0x1
;                     moduleClockParentChanged = 1U;
7009fb18: 9006         	str	r0, [sp, #0x18]
;                 }
7009fb1a: e7ff         	b	0x7009fb1c <SOC_moduleSetClockFrequency+0xcc> @ imm = #-0x2
;             }
7009fb1c: e7ff         	b	0x7009fb1e <SOC_moduleSetClockFrequency+0xce> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009fb1e: 980b         	ldr	r0, [sp, #0x2c]
7009fb20: b988         	cbnz	r0, 0x7009fb46 <SOC_moduleSetClockFrequency+0xf6> @ imm = #0x22
7009fb22: e7ff         	b	0x7009fb24 <SOC_moduleSetClockFrequency+0xd4> @ imm = #-0x2
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009fb24: 980f         	ldr	r0, [sp, #0x3c]
;                                                         clkId,
7009fb26: 990e         	ldr	r1, [sp, #0x38]
;                                                         clkRate,
7009fb28: 9a0c         	ldr	r2, [sp, #0x30]
7009fb2a: 9b0d         	ldr	r3, [sp, #0x34]
;                 status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009fb2c: 46ee         	mov	lr, sp
7009fb2e: f04f 3cff    	mov.w	r12, #0xffffffff
7009fb32: f8ce c004    	str.w	r12, [lr, #0x4]
7009fb36: f10d 0c20    	add.w	r12, sp, #0x20
7009fb3a: f8ce c000    	str.w	r12, [lr]
7009fb3e: f003 fd07    	bl	0x700a3550 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x3a0e
7009fb42: 900b         	str	r0, [sp, #0x2c]
;             }
7009fb44: e7ff         	b	0x7009fb46 <SOC_moduleSetClockFrequency+0xf6> @ imm = #-0x2
;             if (status == SystemP_SUCCESS)
7009fb46: 980b         	ldr	r0, [sp, #0x2c]
7009fb48: b970         	cbnz	r0, 0x7009fb68 <SOC_moduleSetClockFrequency+0x118> @ imm = #0x1c
7009fb4a: e7ff         	b	0x7009fb4c <SOC_moduleSetClockFrequency+0xfc> @ imm = #-0x2
;                 if(respClkRate == clkRate)
7009fb4c: 9808         	ldr	r0, [sp, #0x20]
7009fb4e: 9909         	ldr	r1, [sp, #0x24]
7009fb50: 9a0c         	ldr	r2, [sp, #0x30]
7009fb52: 9b0d         	ldr	r3, [sp, #0x34]
7009fb54: 4059         	eors	r1, r3
7009fb56: ea80 0002    	eor.w	r0, r0, r2
7009fb5a: 4308         	orrs	r0, r1
7009fb5c: b918         	cbnz	r0, 0x7009fb66 <SOC_moduleSetClockFrequency+0x116> @ imm = #0x6
7009fb5e: e7ff         	b	0x7009fb60 <SOC_moduleSetClockFrequency+0x110> @ imm = #-0x2
7009fb60: 2001         	movs	r0, #0x1
;                     foundParent = 1U;
7009fb62: 9003         	str	r0, [sp, #0xc]
;                 }
7009fb64: e7ff         	b	0x7009fb66 <SOC_moduleSetClockFrequency+0x116> @ imm = #-0x2
;             }
7009fb66: e7ff         	b	0x7009fb68 <SOC_moduleSetClockFrequency+0x118> @ imm = #-0x2
;             if(foundParent)
7009fb68: 9803         	ldr	r0, [sp, #0xc]
7009fb6a: b108         	cbz	r0, 0x7009fb70 <SOC_moduleSetClockFrequency+0x120> @ imm = #0x2
7009fb6c: e7ff         	b	0x7009fb6e <SOC_moduleSetClockFrequency+0x11e> @ imm = #-0x2
;                 break; /* found a parent to set clock frequency, rebak form the loop */
7009fb6e: e004         	b	0x7009fb7a <SOC_moduleSetClockFrequency+0x12a> @ imm = #0x8
;         }
7009fb70: e7ff         	b	0x7009fb72 <SOC_moduleSetClockFrequency+0x122> @ imm = #-0x2
;         for(i=0U;i<numParents;i++)
7009fb72: 980a         	ldr	r0, [sp, #0x28]
7009fb74: 3001         	adds	r0, #0x1
7009fb76: 900a         	str	r0, [sp, #0x28]
7009fb78: e7b7         	b	0x7009faea <SOC_moduleSetClockFrequency+0x9a> @ imm = #-0x92
;     }
7009fb7a: e7ff         	b	0x7009fb7c <SOC_moduleSetClockFrequency+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fb7c: 980b         	ldr	r0, [sp, #0x2c]
7009fb7e: b9d0         	cbnz	r0, 0x7009fbb6 <SOC_moduleSetClockFrequency+0x166> @ imm = #0x34
7009fb80: e7ff         	b	0x7009fb82 <SOC_moduleSetClockFrequency+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009fb82: 9803         	ldr	r0, [sp, #0xc]
7009fb84: 2801         	cmp	r0, #0x1
7009fb86: d111         	bne	0x7009fbac <SOC_moduleSetClockFrequency+0x15c> @ imm = #0x22
7009fb88: e7ff         	b	0x7009fb8a <SOC_moduleSetClockFrequency+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009fb8a: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009fb8c: 990e         	ldr	r1, [sp, #0x38]
;                                                   clkRate,
7009fb8e: 9a0c         	ldr	r2, [sp, #0x30]
7009fb90: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009fb92: 46ee         	mov	lr, sp
7009fb94: f04f 3cff    	mov.w	r12, #0xffffffff
7009fb98: f8ce c004    	str.w	r12, [lr, #0x4]
7009fb9c: f44f 7c00    	mov.w	r12, #0x200
7009fba0: f8ce c000    	str.w	r12, [lr]
7009fba4: f005 f98c    	bl	0x700a4ec0 <Sciclient_pmSetModuleClkFreq> @ imm = #0x5318
7009fba8: 900b         	str	r0, [sp, #0x2c]
;         }
7009fbaa: e003         	b	0x7009fbb4 <SOC_moduleSetClockFrequency+0x164> @ imm = #0x6
7009fbac: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009fbb0: 900b         	str	r0, [sp, #0x2c]
7009fbb2: e7ff         	b	0x7009fbb4 <SOC_moduleSetClockFrequency+0x164> @ imm = #-0x2
;     }
7009fbb4: e7ff         	b	0x7009fbb6 <SOC_moduleSetClockFrequency+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fbb6: 980b         	ldr	r0, [sp, #0x2c]
7009fbb8: b988         	cbnz	r0, 0x7009fbde <SOC_moduleSetClockFrequency+0x18e> @ imm = #0x22
7009fbba: e7ff         	b	0x7009fbbc <SOC_moduleSetClockFrequency+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009fbbc: 9805         	ldr	r0, [sp, #0x14]
7009fbbe: b968         	cbnz	r0, 0x7009fbdc <SOC_moduleSetClockFrequency+0x18c> @ imm = #0x1a
7009fbc0: e7ff         	b	0x7009fbc2 <SOC_moduleSetClockFrequency+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009fbc2: 980f         	ldr	r0, [sp, #0x3c]
;                                                   clkId,
7009fbc4: 990e         	ldr	r1, [sp, #0x38]
;                                                   clockStatus,
7009fbc6: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009fbc8: 46ec         	mov	r12, sp
7009fbca: f04f 33ff    	mov.w	r3, #0xffffffff
7009fbce: f8cc 3000    	str.w	r3, [r12]
7009fbd2: 2300         	movs	r3, #0x0
7009fbd4: f00a f9c4    	bl	0x700a9f60 <Sciclient_pmModuleClkRequest> @ imm = #0xa388
7009fbd8: 900b         	str	r0, [sp, #0x2c]
;         }
7009fbda: e7ff         	b	0x7009fbdc <SOC_moduleSetClockFrequency+0x18c> @ imm = #-0x2
;     }
7009fbdc: e7ff         	b	0x7009fbde <SOC_moduleSetClockFrequency+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009fbde: 980b         	ldr	r0, [sp, #0x2c]
7009fbe0: b168         	cbz	r0, 0x7009fbfe <SOC_moduleSetClockFrequency+0x1ae> @ imm = #0x1a
7009fbe2: e7ff         	b	0x7009fbe4 <SOC_moduleSetClockFrequency+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009fbe4: 9806         	ldr	r0, [sp, #0x18]
7009fbe6: 2801         	cmp	r0, #0x1
7009fbe8: d108         	bne	0x7009fbfc <SOC_moduleSetClockFrequency+0x1ac> @ imm = #0x10
7009fbea: e7ff         	b	0x7009fbec <SOC_moduleSetClockFrequency+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009fbec: 980f         	ldr	r0, [sp, #0x3c]
;                                            clkId,
7009fbee: 990e         	ldr	r1, [sp, #0x38]
;                                            origParent,
7009fbf0: 9a04         	ldr	r2, [sp, #0x10]
7009fbf2: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009fbf6: f009 fa4b    	bl	0x700a9090 <Sciclient_pmSetModuleClkParent> @ imm = #0x9496
;         }
7009fbfa: e7ff         	b	0x7009fbfc <SOC_moduleSetClockFrequency+0x1ac> @ imm = #-0x2
;     }
7009fbfc: e7ff         	b	0x7009fbfe <SOC_moduleSetClockFrequency+0x1ae> @ imm = #-0x2
;     return status;
7009fbfe: 980b         	ldr	r0, [sp, #0x2c]
7009fc00: b010         	add	sp, #0x40
7009fc02: bd80         	pop	{r7, pc}
		...

7009fc10 <SOC_moduleSetClockFrequencyWithParent>:
; {
7009fc10: b580         	push	{r7, lr}
7009fc12: b092         	sub	sp, #0x48
7009fc14: 460b         	mov	r3, r1
7009fc16: 4684         	mov	r12, r0
7009fc18: 9915         	ldr	r1, [sp, #0x54]
7009fc1a: 9814         	ldr	r0, [sp, #0x50]
7009fc1c: f8cd c044    	str.w	r12, [sp, #0x44]
7009fc20: 9310         	str	r3, [sp, #0x40]
7009fc22: 920f         	str	r2, [sp, #0x3c]
7009fc24: 910d         	str	r1, [sp, #0x34]
7009fc26: 900c         	str	r0, [sp, #0x30]
7009fc28: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
7009fc2a: 9002         	str	r0, [sp, #0x8]
7009fc2c: 900b         	str	r0, [sp, #0x2c]
;     uint64_t respClkRate = 0;
7009fc2e: 9009         	str	r0, [sp, #0x24]
7009fc30: 9008         	str	r0, [sp, #0x20]
;     uint32_t numParents = 0U;
7009fc32: 9007         	str	r0, [sp, #0x1c]
;     uint32_t moduleClockParentChanged = 0U;
7009fc34: 9006         	str	r0, [sp, #0x18]
;     uint32_t clockStatus = 0U;
7009fc36: 9005         	str	r0, [sp, #0x14]
;     uint32_t origParent = 0U;
7009fc38: 9004         	str	r0, [sp, #0x10]
;     uint32_t foundParent = 0U;
7009fc3a: 9003         	str	r0, [sp, #0xc]
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009fc3c: 9811         	ldr	r0, [sp, #0x44]
;                                             clkId,
7009fc3e: 9910         	ldr	r1, [sp, #0x40]
7009fc40: aa05         	add	r2, sp, #0x14
7009fc42: f04f 33ff    	mov.w	r3, #0xffffffff
;     status = Sciclient_pmModuleGetClkStatus(moduleId,
7009fc46: f009 fbb3    	bl	0x700a93b0 <Sciclient_pmModuleGetClkStatus> @ imm = #0x9766
7009fc4a: 900b         	str	r0, [sp, #0x2c]
;     if (status == SystemP_SUCCESS)
7009fc4c: 980b         	ldr	r0, [sp, #0x2c]
7009fc4e: b948         	cbnz	r0, 0x7009fc64 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #0x12
7009fc50: e7ff         	b	0x7009fc52 <SOC_moduleSetClockFrequencyWithParent+0x42> @ imm = #-0x2
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009fc52: 9811         	ldr	r0, [sp, #0x44]
;                                                    clkId,
7009fc54: 9910         	ldr	r1, [sp, #0x40]
7009fc56: aa07         	add	r2, sp, #0x1c
7009fc58: f04f 33ff    	mov.w	r3, #0xffffffff
;         status = Sciclient_pmGetModuleClkNumParent(moduleId,
7009fc5c: f008 fc88    	bl	0x700a8570 <Sciclient_pmGetModuleClkNumParent> @ imm = #0x8910
7009fc60: 900b         	str	r0, [sp, #0x2c]
;     }
7009fc62: e7ff         	b	0x7009fc64 <SOC_moduleSetClockFrequencyWithParent+0x54> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fc64: 980b         	ldr	r0, [sp, #0x2c]
7009fc66: b970         	cbnz	r0, 0x7009fc86 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #0x1c
7009fc68: e7ff         	b	0x7009fc6a <SOC_moduleSetClockFrequencyWithParent+0x5a> @ imm = #-0x2
;         if(numParents > 1U)
7009fc6a: 9807         	ldr	r0, [sp, #0x1c]
7009fc6c: 2802         	cmp	r0, #0x2
7009fc6e: d309         	blo	0x7009fc84 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #0x12
7009fc70: e7ff         	b	0x7009fc72 <SOC_moduleSetClockFrequencyWithParent+0x62> @ imm = #-0x2
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009fc72: 9811         	ldr	r0, [sp, #0x44]
;                                                     clkId,
7009fc74: 9910         	ldr	r1, [sp, #0x40]
7009fc76: aa04         	add	r2, sp, #0x10
7009fc78: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmGetModuleClkParent(moduleId,
7009fc7c: f009 f9b8    	bl	0x700a8ff0 <Sciclient_pmGetModuleClkParent> @ imm = #0x9370
7009fc80: 900b         	str	r0, [sp, #0x2c]
;         }
7009fc82: e7ff         	b	0x7009fc84 <SOC_moduleSetClockFrequencyWithParent+0x74> @ imm = #-0x2
;     }
7009fc84: e7ff         	b	0x7009fc86 <SOC_moduleSetClockFrequencyWithParent+0x76> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fc86: 980b         	ldr	r0, [sp, #0x2c]
7009fc88: b960         	cbnz	r0, 0x7009fca4 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #0x18
7009fc8a: e7ff         	b	0x7009fc8c <SOC_moduleSetClockFrequencyWithParent+0x7c> @ imm = #-0x2
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009fc8c: 9811         	ldr	r0, [sp, #0x44]
;                                               clkId,
7009fc8e: 9910         	ldr	r1, [sp, #0x40]
;         status = Sciclient_pmModuleClkRequest(moduleId,
7009fc90: 466b         	mov	r3, sp
7009fc92: f04f 32ff    	mov.w	r2, #0xffffffff
7009fc96: 601a         	str	r2, [r3]
7009fc98: 2300         	movs	r3, #0x0
7009fc9a: 461a         	mov	r2, r3
7009fc9c: f00a f960    	bl	0x700a9f60 <Sciclient_pmModuleClkRequest> @ imm = #0xa2c0
7009fca0: 900b         	str	r0, [sp, #0x2c]
;     }
7009fca2: e7ff         	b	0x7009fca4 <SOC_moduleSetClockFrequencyWithParent+0x94> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fca4: 980b         	ldr	r0, [sp, #0x2c]
7009fca6: b960         	cbnz	r0, 0x7009fcc2 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #0x18
7009fca8: e7ff         	b	0x7009fcaa <SOC_moduleSetClockFrequencyWithParent+0x9a> @ imm = #-0x2
;         if (clkParent > (clkId + numParents))
7009fcaa: 980f         	ldr	r0, [sp, #0x3c]
7009fcac: 9910         	ldr	r1, [sp, #0x40]
7009fcae: 9a07         	ldr	r2, [sp, #0x1c]
7009fcb0: 4411         	add	r1, r2
7009fcb2: 4288         	cmp	r0, r1
7009fcb4: d904         	bls	0x7009fcc0 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #0x8
7009fcb6: e7ff         	b	0x7009fcb8 <SOC_moduleSetClockFrequencyWithParent+0xa8> @ imm = #-0x2
7009fcb8: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009fcbc: 900b         	str	r0, [sp, #0x2c]
;         }
7009fcbe: e7ff         	b	0x7009fcc0 <SOC_moduleSetClockFrequencyWithParent+0xb0> @ imm = #-0x2
;     }
7009fcc0: e7ff         	b	0x7009fcc2 <SOC_moduleSetClockFrequencyWithParent+0xb2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fcc2: 980b         	ldr	r0, [sp, #0x2c]
7009fcc4: b9a8         	cbnz	r0, 0x7009fcf2 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #0x2a
7009fcc6: e7ff         	b	0x7009fcc8 <SOC_moduleSetClockFrequencyWithParent+0xb8> @ imm = #-0x2
;         if (clkParent != origParent)
7009fcc8: 980f         	ldr	r0, [sp, #0x3c]
7009fcca: 9904         	ldr	r1, [sp, #0x10]
7009fccc: 4288         	cmp	r0, r1
7009fcce: d00f         	beq	0x7009fcf0 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #0x1e
7009fcd0: e7ff         	b	0x7009fcd2 <SOC_moduleSetClockFrequencyWithParent+0xc2> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009fcd2: 9811         	ldr	r0, [sp, #0x44]
;                                                         clkId,
7009fcd4: 9910         	ldr	r1, [sp, #0x40]
;                                                         clkParent,
7009fcd6: 9a0f         	ldr	r2, [sp, #0x3c]
7009fcd8: f04f 33ff    	mov.w	r3, #0xffffffff
;             status = Sciclient_pmSetModuleClkParent(moduleId,
7009fcdc: f009 f9d8    	bl	0x700a9090 <Sciclient_pmSetModuleClkParent> @ imm = #0x93b0
7009fce0: 900b         	str	r0, [sp, #0x2c]
;             if (status == SystemP_SUCCESS)
7009fce2: 980b         	ldr	r0, [sp, #0x2c]
7009fce4: b918         	cbnz	r0, 0x7009fcee <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #0x6
7009fce6: e7ff         	b	0x7009fce8 <SOC_moduleSetClockFrequencyWithParent+0xd8> @ imm = #-0x2
7009fce8: 2001         	movs	r0, #0x1
;                 moduleClockParentChanged = 1U;
7009fcea: 9006         	str	r0, [sp, #0x18]
;             }
7009fcec: e7ff         	b	0x7009fcee <SOC_moduleSetClockFrequencyWithParent+0xde> @ imm = #-0x2
;         }
7009fcee: e7ff         	b	0x7009fcf0 <SOC_moduleSetClockFrequencyWithParent+0xe0> @ imm = #-0x2
;     }
7009fcf0: e7ff         	b	0x7009fcf2 <SOC_moduleSetClockFrequencyWithParent+0xe2> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fcf2: 980b         	ldr	r0, [sp, #0x2c]
7009fcf4: b988         	cbnz	r0, 0x7009fd1a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #0x22
7009fcf6: e7ff         	b	0x7009fcf8 <SOC_moduleSetClockFrequencyWithParent+0xe8> @ imm = #-0x2
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009fcf8: 9811         	ldr	r0, [sp, #0x44]
;                                                 clkId,
7009fcfa: 9910         	ldr	r1, [sp, #0x40]
;                                                 clkRate,
7009fcfc: 9a0c         	ldr	r2, [sp, #0x30]
7009fcfe: 9b0d         	ldr	r3, [sp, #0x34]
;         status = Sciclient_pmQueryModuleClkFreq(moduleId,
7009fd00: 46ee         	mov	lr, sp
7009fd02: f04f 3cff    	mov.w	r12, #0xffffffff
7009fd06: f8ce c004    	str.w	r12, [lr, #0x4]
7009fd0a: f10d 0c20    	add.w	r12, sp, #0x20
7009fd0e: f8ce c000    	str.w	r12, [lr]
7009fd12: f003 fc1d    	bl	0x700a3550 <Sciclient_pmQueryModuleClkFreq> @ imm = #0x383a
7009fd16: 900b         	str	r0, [sp, #0x2c]
;     }
7009fd18: e7ff         	b	0x7009fd1a <SOC_moduleSetClockFrequencyWithParent+0x10a> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fd1a: 980b         	ldr	r0, [sp, #0x2c]
7009fd1c: b970         	cbnz	r0, 0x7009fd3c <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #0x1c
7009fd1e: e7ff         	b	0x7009fd20 <SOC_moduleSetClockFrequencyWithParent+0x110> @ imm = #-0x2
;         if(respClkRate == clkRate)
7009fd20: 9808         	ldr	r0, [sp, #0x20]
7009fd22: 9909         	ldr	r1, [sp, #0x24]
7009fd24: 9a0c         	ldr	r2, [sp, #0x30]
7009fd26: 9b0d         	ldr	r3, [sp, #0x34]
7009fd28: 4059         	eors	r1, r3
7009fd2a: ea80 0002    	eor.w	r0, r0, r2
7009fd2e: 4308         	orrs	r0, r1
7009fd30: b918         	cbnz	r0, 0x7009fd3a <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #0x6
7009fd32: e7ff         	b	0x7009fd34 <SOC_moduleSetClockFrequencyWithParent+0x124> @ imm = #-0x2
7009fd34: 2001         	movs	r0, #0x1
;             foundParent = 1U;
7009fd36: 9003         	str	r0, [sp, #0xc]
;         }
7009fd38: e7ff         	b	0x7009fd3a <SOC_moduleSetClockFrequencyWithParent+0x12a> @ imm = #-0x2
;     }
7009fd3a: e7ff         	b	0x7009fd3c <SOC_moduleSetClockFrequencyWithParent+0x12c> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fd3c: 980b         	ldr	r0, [sp, #0x2c]
7009fd3e: b9d0         	cbnz	r0, 0x7009fd76 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #0x34
7009fd40: e7ff         	b	0x7009fd42 <SOC_moduleSetClockFrequencyWithParent+0x132> @ imm = #-0x2
;         if(foundParent == 1U)
7009fd42: 9803         	ldr	r0, [sp, #0xc]
7009fd44: 2801         	cmp	r0, #0x1
7009fd46: d111         	bne	0x7009fd6c <SOC_moduleSetClockFrequencyWithParent+0x15c> @ imm = #0x22
7009fd48: e7ff         	b	0x7009fd4a <SOC_moduleSetClockFrequencyWithParent+0x13a> @ imm = #-0x2
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009fd4a: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009fd4c: 9910         	ldr	r1, [sp, #0x40]
;                                                   clkRate,
7009fd4e: 9a0c         	ldr	r2, [sp, #0x30]
7009fd50: 9b0d         	ldr	r3, [sp, #0x34]
;             status = Sciclient_pmSetModuleClkFreq(moduleId,
7009fd52: 46ee         	mov	lr, sp
7009fd54: f04f 3cff    	mov.w	r12, #0xffffffff
7009fd58: f8ce c004    	str.w	r12, [lr, #0x4]
7009fd5c: f44f 7c00    	mov.w	r12, #0x200
7009fd60: f8ce c000    	str.w	r12, [lr]
7009fd64: f005 f8ac    	bl	0x700a4ec0 <Sciclient_pmSetModuleClkFreq> @ imm = #0x5158
7009fd68: 900b         	str	r0, [sp, #0x2c]
;         }
7009fd6a: e003         	b	0x7009fd74 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #0x6
7009fd6c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
7009fd70: 900b         	str	r0, [sp, #0x2c]
7009fd72: e7ff         	b	0x7009fd74 <SOC_moduleSetClockFrequencyWithParent+0x164> @ imm = #-0x2
;     }
7009fd74: e7ff         	b	0x7009fd76 <SOC_moduleSetClockFrequencyWithParent+0x166> @ imm = #-0x2
;     if (status == SystemP_SUCCESS)
7009fd76: 980b         	ldr	r0, [sp, #0x2c]
7009fd78: b988         	cbnz	r0, 0x7009fd9e <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #0x22
7009fd7a: e7ff         	b	0x7009fd7c <SOC_moduleSetClockFrequencyWithParent+0x16c> @ imm = #-0x2
;         if (clockStatus == TISCI_MSG_VALUE_CLOCK_HW_STATE_NOT_READY)
7009fd7c: 9805         	ldr	r0, [sp, #0x14]
7009fd7e: b968         	cbnz	r0, 0x7009fd9c <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #0x1a
7009fd80: e7ff         	b	0x7009fd82 <SOC_moduleSetClockFrequencyWithParent+0x172> @ imm = #-0x2
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009fd82: 9811         	ldr	r0, [sp, #0x44]
;                                                   clkId,
7009fd84: 9910         	ldr	r1, [sp, #0x40]
;                                                   clockStatus,
7009fd86: 9a05         	ldr	r2, [sp, #0x14]
;             status = Sciclient_pmModuleClkRequest(moduleId,
7009fd88: 46ec         	mov	r12, sp
7009fd8a: f04f 33ff    	mov.w	r3, #0xffffffff
7009fd8e: f8cc 3000    	str.w	r3, [r12]
7009fd92: 2300         	movs	r3, #0x0
7009fd94: f00a f8e4    	bl	0x700a9f60 <Sciclient_pmModuleClkRequest> @ imm = #0xa1c8
7009fd98: 900b         	str	r0, [sp, #0x2c]
;         }
7009fd9a: e7ff         	b	0x7009fd9c <SOC_moduleSetClockFrequencyWithParent+0x18c> @ imm = #-0x2
;     }
7009fd9c: e7ff         	b	0x7009fd9e <SOC_moduleSetClockFrequencyWithParent+0x18e> @ imm = #-0x2
;     if (status != SystemP_SUCCESS)
7009fd9e: 980b         	ldr	r0, [sp, #0x2c]
7009fda0: b168         	cbz	r0, 0x7009fdbe <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #0x1a
7009fda2: e7ff         	b	0x7009fda4 <SOC_moduleSetClockFrequencyWithParent+0x194> @ imm = #-0x2
;         if (moduleClockParentChanged == 1U)
7009fda4: 9806         	ldr	r0, [sp, #0x18]
7009fda6: 2801         	cmp	r0, #0x1
7009fda8: d108         	bne	0x7009fdbc <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #0x10
7009fdaa: e7ff         	b	0x7009fdac <SOC_moduleSetClockFrequencyWithParent+0x19c> @ imm = #-0x2
;             Sciclient_pmSetModuleClkParent(moduleId,
7009fdac: 9811         	ldr	r0, [sp, #0x44]
;                                            clkId,
7009fdae: 9910         	ldr	r1, [sp, #0x40]
;                                            origParent,
7009fdb0: 9a04         	ldr	r2, [sp, #0x10]
7009fdb2: f04f 33ff    	mov.w	r3, #0xffffffff
;             Sciclient_pmSetModuleClkParent(moduleId,
7009fdb6: f009 f96b    	bl	0x700a9090 <Sciclient_pmSetModuleClkParent> @ imm = #0x92d6
;         }
7009fdba: e7ff         	b	0x7009fdbc <SOC_moduleSetClockFrequencyWithParent+0x1ac> @ imm = #-0x2
;     }
7009fdbc: e7ff         	b	0x7009fdbe <SOC_moduleSetClockFrequencyWithParent+0x1ae> @ imm = #-0x2
;     return status;
7009fdbe: 980b         	ldr	r0, [sp, #0x2c]
7009fdc0: b012         	add	sp, #0x48
7009fdc2: bd80         	pop	{r7, pc}

7009fdc4 <memalign>:
7009fdc4: e92d4bf0     	push	{r4, r5, r6, r7, r8, r9, r11, lr}
7009fdc8: e59f5190     	ldr	r5, [pc, #0x190]        @ 0x7009ff60 <memalign+0x19c>
7009fdcc: e3a02000     	mov	r2, #0
7009fdd0: e3a08000     	mov	r8, #0
7009fdd4: e2413001     	sub	r3, r1, #1
7009fdd8: e2454008     	sub	r4, r5, #8
7009fddc: e3550007     	cmp	r5, #7
7009fde0: 81a02004     	movhi	r2, r4
7009fde4: e1530002     	cmp	r3, r2
7009fde8: 2a00005a     	bhs	0x7009ff58 <memalign+0x194> @ imm = #0x168
7009fdec: e2402001     	sub	r2, r0, #1
7009fdf0: e59f316c     	ldr	r3, [pc, #0x16c]        @ 0x7009ff64 <memalign+0x1a0>
7009fdf4: e3a07008     	mov	r7, #8
7009fdf8: e2816007     	add	r6, r1, #7
7009fdfc: e1100002     	tst	r0, r2
7009fe00: 01a07000     	moveq	r7, r0
7009fe04: e3500007     	cmp	r0, #7
7009fe08: e5930000     	ldr	r0, [r3]
7009fe0c: e3a02008     	mov	r2, #8
7009fe10: 91a07002     	movls	r7, r2
7009fe14: e12fff30     	blx	r0
7009fe18: e59f0148     	ldr	r0, [pc, #0x148]        @ 0x7009ff68 <memalign+0x1a4>
7009fe1c: e5d01000     	ldrb	r1, [r0]
7009fe20: e3510000     	cmp	r1, #0
7009fe24: 1a000011     	bne	0x7009fe70 <memalign+0xac> @ imm = #0x44
7009fe28: e3a02000     	mov	r2, #0
7009fe2c: e3a01000     	mov	r1, #0
7009fe30: e3550007     	cmp	r5, #7
7009fe34: 81a02004     	movhi	r2, r4
7009fe38: e3520000     	cmp	r2, #0
7009fe3c: 1a000002     	bne	0x7009fe4c <memalign+0x88> @ imm = #0x8
7009fe40: e59f2124     	ldr	r2, [pc, #0x124]        @ 0x7009ff6c <memalign+0x1a8>
7009fe44: e5821000     	str	r1, [r2]
7009fe48: ea000006     	b	0x7009fe68 <memalign+0xa4> @ imm = #0x18
7009fe4c: e59f211c     	ldr	r2, [pc, #0x11c]        @ 0x7009ff70 <memalign+0x1ac>
7009fe50: e3550007     	cmp	r5, #7
7009fe54: 91a04001     	movls	r4, r1
7009fe58: e59f310c     	ldr	r3, [pc, #0x10c]        @ 0x7009ff6c <memalign+0x1a8>
7009fe5c: e5821008     	str	r1, [r2, #0x8]
7009fe60: e5832000     	str	r2, [r3]
7009fe64: e5824000     	str	r4, [r2]
7009fe68: e3a01001     	mov	r1, #1
7009fe6c: e5c01000     	strb	r1, [r0]
7009fe70: e59f50f4     	ldr	r5, [pc, #0xf4]         @ 0x7009ff6c <memalign+0x1a8>
7009fe74: e3c69007     	bic	r9, r6, #7
7009fe78: e2470001     	sub	r0, r7, #1
7009fe7c: e2671000     	rsb	r1, r7, #0
7009fe80: e5956000     	ldr	r6, [r5]
7009fe84: e3560000     	cmp	r6, #0
7009fe88: 0a00002f     	beq	0x7009ff4c <memalign+0x188> @ imm = #0xbc
7009fe8c: e2865008     	add	r5, r6, #8
7009fe90: e0802005     	add	r2, r0, r5
7009fe94: e0024001     	and	r4, r2, r1
7009fe98: e1550004     	cmp	r5, r4
7009fe9c: 0a00000c     	beq	0x7009fed4 <memalign+0x110> @ imm = #0x30
7009fea0: e2862010     	add	r2, r6, #16
7009fea4: e2443008     	sub	r3, r4, #8
7009fea8: e1520003     	cmp	r2, r3
7009feac: 9a000001     	bls	0x7009feb8 <memalign+0xf4> @ imm = #0x4
7009feb0: e0844007     	add	r4, r4, r7
7009feb4: eafffffa     	b	0x7009fea4 <memalign+0xe0> @ imm = #-0x18
7009feb8: e5962000     	ldr	r2, [r6]
7009febc: e0843009     	add	r3, r4, r9
7009fec0: e3c22001     	bic	r2, r2, #1
7009fec4: e0852002     	add	r2, r5, r2
7009fec8: e1520003     	cmp	r2, r3
7009fecc: 3affffeb     	blo	0x7009fe80 <memalign+0xbc> @ imm = #-0x54
7009fed0: ea000004     	b	0x7009fee8 <memalign+0x124> @ imm = #0x10
7009fed4: e5962000     	ldr	r2, [r6]
7009fed8: e3c22001     	bic	r2, r2, #1
7009fedc: e1520009     	cmp	r2, r9
7009fee0: baffffe6     	blt	0x7009fe80 <memalign+0xbc> @ imm = #-0x68
7009fee4: e1a04005     	mov	r4, r5
7009fee8: e1a00006     	mov	r0, r6
7009feec: eb0039c0     	bl	0x700ae5f4 <free_list_remove> @ imm = #0xe700
7009fef0: e1540005     	cmp	r4, r5
7009fef4: 0a00000c     	beq	0x7009ff2c <memalign+0x168> @ imm = #0x30
7009fef8: e5960000     	ldr	r0, [r6]
7009fefc: e0441005     	sub	r1, r4, r5
7009ff00: e2412008     	sub	r2, r1, #8
7009ff04: e1a04006     	mov	r4, r6
7009ff08: e3c00001     	bic	r0, r0, #1
7009ff0c: e0400001     	sub	r0, r0, r1
7009ff10: e3c21001     	bic	r1, r2, #1
7009ff14: e3800001     	orr	r0, r0, #1
7009ff18: e6842001     	str	r2, [r4], r1
7009ff1c: e5a40008     	str	r0, [r4, #0x8]!
7009ff20: e1a00006     	mov	r0, r6
7009ff24: eb003775     	bl	0x700add00 <free_list_insert> @ imm = #0xddd4
7009ff28: e1a06004     	mov	r6, r4
7009ff2c: e1a00006     	mov	r0, r6
7009ff30: e1a01009     	mov	r1, r9
7009ff34: eb002266     	bl	0x700a88d4 <split>      @ imm = #0x8998
7009ff38: e59f0034     	ldr	r0, [pc, #0x34]         @ 0x7009ff74 <memalign+0x1b0>
7009ff3c: e5900000     	ldr	r0, [r0]
7009ff40: e12fff30     	blx	r0
7009ff44: e2868008     	add	r8, r6, #8
7009ff48: ea000002     	b	0x7009ff58 <memalign+0x194> @ imm = #0x8
7009ff4c: e59f0020     	ldr	r0, [pc, #0x20]         @ 0x7009ff74 <memalign+0x1b0>
7009ff50: e5900000     	ldr	r0, [r0]
7009ff54: e12fff30     	blx	r0
7009ff58: e1a00008     	mov	r0, r8
7009ff5c: e8bd8bf0     	pop	{r4, r5, r6, r7, r8, r9, r11, pc}
7009ff60: 00 00 01 00  	.word	0x00010000
7009ff64: c4 29 0b 70  	.word	0x700b29c4
7009ff68: 58 2a 0b 70  	.word	0x700b2a58
7009ff6c: ac 52 08 70  	.word	0x700852ac
7009ff70: 00 53 08 70  	.word	0x70085300
7009ff74: c8 29 0b 70  	.word	0x700b29c8
7009ff78: 00 00 00 00  	.word	0x00000000
7009ff7c: 00 00 00 00  	.word	0x00000000

7009ff80 <UART_close>:
; {
7009ff80: b580         	push	{r7, lr}
7009ff82: b08a         	sub	sp, #0x28
7009ff84: 9009         	str	r0, [sp, #0x24]
;     config = (UART_Config *) handle;
7009ff86: 9809         	ldr	r0, [sp, #0x24]
7009ff88: 9008         	str	r0, [sp, #0x20]
;     if ((NULL != config) && (config->object != NULL) && (config->object->isOpen != FALSE))
7009ff8a: 9808         	ldr	r0, [sp, #0x20]
7009ff8c: 2800         	cmp	r0, #0x0
7009ff8e: f000 80ce    	beq.w	0x700a012e <UART_close+0x1ae> @ imm = #0x19c
7009ff92: e7ff         	b	0x7009ff94 <UART_close+0x14> @ imm = #-0x2
7009ff94: 9808         	ldr	r0, [sp, #0x20]
7009ff96: 6840         	ldr	r0, [r0, #0x4]
7009ff98: 2800         	cmp	r0, #0x0
7009ff9a: f000 80c8    	beq.w	0x700a012e <UART_close+0x1ae> @ imm = #0x190
7009ff9e: e7ff         	b	0x7009ffa0 <UART_close+0x20> @ imm = #-0x2
7009ffa0: 9808         	ldr	r0, [sp, #0x20]
7009ffa2: 6840         	ldr	r0, [r0, #0x4]
7009ffa4: f8d0 0084    	ldr.w	r0, [r0, #0x84]
7009ffa8: 2800         	cmp	r0, #0x0
7009ffaa: f000 80c0    	beq.w	0x700a012e <UART_close+0x1ae> @ imm = #0x180
7009ffae: e7ff         	b	0x7009ffb0 <UART_close+0x30> @ imm = #-0x2
;         object = config->object;
7009ffb0: 9808         	ldr	r0, [sp, #0x20]
7009ffb2: 6840         	ldr	r0, [r0, #0x4]
7009ffb4: 9007         	str	r0, [sp, #0x1c]
;         attrs = config->attrs;
7009ffb6: 9808         	ldr	r0, [sp, #0x20]
7009ffb8: 6800         	ldr	r0, [r0]
7009ffba: 9006         	str	r0, [sp, #0x18]
;         object->uartLld_handle = &object->uartLld_object;
7009ffbc: 9907         	ldr	r1, [sp, #0x1c]
7009ffbe: f501 7022    	add.w	r0, r1, #0x288
7009ffc2: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;         uartLld_handle = object->uartLld_handle;
7009ffc6: 9807         	ldr	r0, [sp, #0x1c]
7009ffc8: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
7009ffcc: 9005         	str	r0, [sp, #0x14]
;         DebugP_assert(NULL_PTR != object);
7009ffce: 9807         	ldr	r0, [sp, #0x1c]
7009ffd0: 2800         	cmp	r0, #0x0
7009ffd2: bf18         	it	ne
7009ffd4: 2001         	movne	r0, #0x1
7009ffd6: f641 71ce    	movw	r1, #0x1fce
7009ffda: f2c7 010b    	movt	r1, #0x700b
7009ffde: 466a         	mov	r2, sp
7009ffe0: 6011         	str	r1, [r2]
7009ffe2: f641 71e1    	movw	r1, #0x1fe1
7009ffe6: f2c7 010b    	movt	r1, #0x700b
7009ffea: 9101         	str	r1, [sp, #0x4]
7009ffec: f242 1236    	movw	r2, #0x2136
7009fff0: f2c7 020b    	movt	r2, #0x700b
7009fff4: 9202         	str	r2, [sp, #0x8]
7009fff6: f240 13c5    	movw	r3, #0x1c5
7009fffa: f00a fe41    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xac82
7009fffe: 9901         	ldr	r1, [sp, #0x4]
700a0000: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
700a0002: 9806         	ldr	r0, [sp, #0x18]
700a0004: 2800         	cmp	r0, #0x0
700a0006: bf18         	it	ne
700a0008: 2001         	movne	r0, #0x1
700a000a: f242 0317    	movw	r3, #0x2017
700a000e: f2c7 030b    	movt	r3, #0x700b
700a0012: 46ec         	mov	r12, sp
700a0014: f8cc 3000    	str.w	r3, [r12]
700a0018: f44f 73e3    	mov.w	r3, #0x1c6
700a001c: f00a fe30    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xac60
700a0020: 9901         	ldr	r1, [sp, #0x4]
700a0022: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != gUartDrvObj.lock);
700a0024: f242 7328    	movw	r3, #0x2728
700a0028: f2c7 030b    	movt	r3, #0x700b
700a002c: f853 0b04    	ldr	r0, [r3], #4
700a0030: 9303         	str	r3, [sp, #0xc]
700a0032: 2800         	cmp	r0, #0x0
700a0034: bf18         	it	ne
700a0036: 2001         	movne	r0, #0x1
700a0038: f641 53c0    	movw	r3, #0x1dc0
700a003c: f2c7 030b    	movt	r3, #0x700b
700a0040: 46ec         	mov	r12, sp
700a0042: f8cc 3000    	str.w	r3, [r12]
700a0046: f44f 73e4    	mov.w	r3, #0x1c8
700a004a: f00a fe19    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xac32
700a004e: 9803         	ldr	r0, [sp, #0xc]
700a0050: f04f 31ff    	mov.w	r1, #0xffffffff
;         (void)SemaphoreP_pend(&gUartDrvObj.lockObj, SystemP_WAIT_FOREVER);
700a0054: f00a fbbc    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0xa778
;         UART_flushTxFifo(handle);
700a0058: 9809         	ldr	r0, [sp, #0x24]
700a005a: f007 f9e1    	bl	0x700a7420 <UART_flushTxFifo> @ imm = #0x73c2
;         UART_intrDisable(attrs->baseAddr,
700a005e: 9806         	ldr	r0, [sp, #0x18]
700a0060: 6800         	ldr	r0, [r0]
700a0062: 2107         	movs	r1, #0x7
700a0064: 9104         	str	r1, [sp, #0x10]
700a0066: f006 f973    	bl	0x700a6350 <UART_intrDisable> @ imm = #0x62e6
;         UART_intr2Disable(attrs->baseAddr, UART_INT2_TX_EMPTY);
700a006a: 9806         	ldr	r0, [sp, #0x18]
700a006c: 6800         	ldr	r0, [r0]
700a006e: 2102         	movs	r1, #0x2
700a0070: f00e fe8e    	bl	0x700aed90 <UART_intr2Disable> @ imm = #0xed1c
700a0074: 9904         	ldr	r1, [sp, #0x10]
;         (void)UART_operatingModeSelect(attrs->baseAddr, UART_OPER_MODE_DISABLED);
700a0076: 9806         	ldr	r0, [sp, #0x18]
700a0078: 6800         	ldr	r0, [r0]
700a007a: f00e fed1    	bl	0x700aee20 <UART_operatingModeSelect> @ imm = #0xeda2
;         if(UART_CONFIG_MODE_DMA == object->prms.transferMode)
700a007e: 9807         	ldr	r0, [sp, #0x1c]
700a0080: 6b00         	ldr	r0, [r0, #0x30]
700a0082: 2803         	cmp	r0, #0x3
700a0084: d104         	bne	0x700a0090 <UART_close+0x110> @ imm = #0x8
700a0086: e7ff         	b	0x700a0088 <UART_close+0x108> @ imm = #-0x2
;             (void)UART_lld_deInitDma(uartLld_handle);
700a0088: 9805         	ldr	r0, [sp, #0x14]
700a008a: f00b fde1    	bl	0x700abc50 <UART_lld_deInitDma> @ imm = #0xbbc2
;         }
700a008e: e003         	b	0x700a0098 <UART_close+0x118> @ imm = #0x6
;             (void)UART_lld_deInit(uartLld_handle);
700a0090: 9805         	ldr	r0, [sp, #0x14]
700a0092: f00c fab5    	bl	0x700ac600 <UART_lld_deInit> @ imm = #0xc56a
700a0096: e7ff         	b	0x700a0098 <UART_close+0x118> @ imm = #-0x2
;         if(NULL != object->lock)
700a0098: 9807         	ldr	r0, [sp, #0x1c]
700a009a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a009e: b148         	cbz	r0, 0x700a00b4 <UART_close+0x134> @ imm = #0x12
700a00a0: e7ff         	b	0x700a00a2 <UART_close+0x122> @ imm = #-0x2
;             SemaphoreP_destruct(&object->lockObj);
700a00a2: 9807         	ldr	r0, [sp, #0x1c]
700a00a4: 308c         	adds	r0, #0x8c
700a00a6: f00f fc03    	bl	0x700af8b0 <SemaphoreP_destruct> @ imm = #0xf806
;             object->lock = NULL;
700a00aa: 9907         	ldr	r1, [sp, #0x1c]
700a00ac: 2000         	movs	r0, #0x0
700a00ae: f8c1 0088    	str.w	r0, [r1, #0x88]
;         }
700a00b2: e7ff         	b	0x700a00b4 <UART_close+0x134> @ imm = #-0x2
;         if(NULL != object->readTransferSem)
700a00b4: 9807         	ldr	r0, [sp, #0x1c]
700a00b6: f8d0 0124    	ldr.w	r0, [r0, #0x124]
700a00ba: b160         	cbz	r0, 0x700a00d6 <UART_close+0x156> @ imm = #0x18
700a00bc: e7ff         	b	0x700a00be <UART_close+0x13e> @ imm = #-0x2
;             SemaphoreP_destruct(&object->readTransferSemObj);
700a00be: 9807         	ldr	r0, [sp, #0x1c]
700a00c0: f500 7094    	add.w	r0, r0, #0x128
700a00c4: f00f fbf4    	bl	0x700af8b0 <SemaphoreP_destruct> @ imm = #0xf7e8
;             object->readTransferSem = NULL;
700a00c8: 9907         	ldr	r1, [sp, #0x1c]
700a00ca: 2000         	movs	r0, #0x0
700a00cc: f8c1 0124    	str.w	r0, [r1, #0x124]
;             uartLld_handle->readTransferMutex = NULL;
700a00d0: 9905         	ldr	r1, [sp, #0x14]
700a00d2: 6588         	str	r0, [r1, #0x58]
;         }
700a00d4: e7ff         	b	0x700a00d6 <UART_close+0x156> @ imm = #-0x2
;         if(NULL != object->writeTransferSem)
700a00d6: 9807         	ldr	r0, [sp, #0x1c]
700a00d8: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
700a00dc: b160         	cbz	r0, 0x700a00f8 <UART_close+0x178> @ imm = #0x18
700a00de: e7ff         	b	0x700a00e0 <UART_close+0x160> @ imm = #-0x2
;             SemaphoreP_destruct(&object->writeTransferSemObj);
700a00e0: 9807         	ldr	r0, [sp, #0x1c]
700a00e2: f500 70e2    	add.w	r0, r0, #0x1c4
700a00e6: f00f fbe3    	bl	0x700af8b0 <SemaphoreP_destruct> @ imm = #0xf7c6
;             object->writeTransferSem = NULL;
700a00ea: 9907         	ldr	r1, [sp, #0x1c]
700a00ec: 2000         	movs	r0, #0x0
700a00ee: f8c1 01c0    	str.w	r0, [r1, #0x1c0]
;             uartLld_handle->writeTransferMutex = NULL;
700a00f2: 9905         	ldr	r1, [sp, #0x14]
700a00f4: 65c8         	str	r0, [r1, #0x5c]
;         }
700a00f6: e7ff         	b	0x700a00f8 <UART_close+0x178> @ imm = #-0x2
;         if(NULL != object->hwiHandle)
700a00f8: 9807         	ldr	r0, [sp, #0x1c]
700a00fa: f8d0 025c    	ldr.w	r0, [r0, #0x25c]
700a00fe: b150         	cbz	r0, 0x700a0116 <UART_close+0x196> @ imm = #0x14
700a0100: e7ff         	b	0x700a0102 <UART_close+0x182> @ imm = #-0x2
;             HwiP_destruct(&object->hwiObj);
700a0102: 9807         	ldr	r0, [sp, #0x1c]
700a0104: f500 7018    	add.w	r0, r0, #0x260
700a0108: f010 f83a    	bl	0x700b0180 <HwiP_destruct> @ imm = #0x10074
;             object->hwiHandle = NULL;
700a010c: 9907         	ldr	r1, [sp, #0x1c]
700a010e: 2000         	movs	r0, #0x0
700a0110: f8c1 025c    	str.w	r0, [r1, #0x25c]
;         }
700a0114: e7ff         	b	0x700a0116 <UART_close+0x196> @ imm = #-0x2
;         object->isOpen = FALSE;
700a0116: 9907         	ldr	r1, [sp, #0x1c]
700a0118: 2000         	movs	r0, #0x0
700a011a: f8c1 0084    	str.w	r0, [r1, #0x84]
;         SemaphoreP_post(&gUartDrvObj.lockObj);
700a011e: f242 7028    	movw	r0, #0x2728
700a0122: f2c7 000b    	movt	r0, #0x700b
700a0126: 3004         	adds	r0, #0x4
700a0128: f00b fee2    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0xbdc4
;     }
700a012c: e7ff         	b	0x700a012e <UART_close+0x1ae> @ imm = #-0x2
;     return;
700a012e: b00a         	add	sp, #0x28
700a0130: bd80         	pop	{r7, pc}
700a0132: 0000         	movs	r0, r0

700a0134 <free>:
700a0134: e3500000     	cmp	r0, #0
700a0138: 012fff1e     	bxeq	lr
700a013c: e92d41f0     	push	{r4, r5, r6, r7, r8, lr}
700a0140: e1a04000     	mov	r4, r0
700a0144: e59f0188     	ldr	r0, [pc, #0x188]        @ 0x700a02d4 <free+0x1a0>
700a0148: e5900000     	ldr	r0, [r0]
700a014c: e12fff30     	blx	r0
700a0150: e59f0180     	ldr	r0, [pc, #0x180]        @ 0x700a02d8 <free+0x1a4>
700a0154: e2444008     	sub	r4, r4, #8
700a0158: e3a05000     	mov	r5, #0
700a015c: e5901000     	ldr	r1, [r0]
700a0160: e1500004     	cmp	r0, r4
700a0164: e3c12001     	bic	r2, r1, #1
700a0168: 2a000004     	bhs	0x700a0180 <free+0x4c>  @ imm = #0x10
700a016c: e0801002     	add	r1, r0, r2
700a0170: e1a05000     	mov	r5, r0
700a0174: e2811008     	add	r1, r1, #8
700a0178: e1a00001     	mov	r0, r1
700a017c: eafffff6     	b	0x700a015c <free+0x28>  @ imm = #-0x28
700a0180: e59f3150     	ldr	r3, [pc, #0x150]        @ 0x700a02d8 <free+0x1a4>
700a0184: e0802002     	add	r2, r0, r2
700a0188: e59f714c     	ldr	r7, [pc, #0x14c]        @ 0x700a02dc <free+0x1a8>
700a018c: e2826008     	add	r6, r2, #8
700a0190: e0872003     	add	r2, r7, r3
700a0194: e3570007     	cmp	r7, #7
700a0198: 82423008     	subhi	r3, r2, #8
700a019c: e1560003     	cmp	r6, r3
700a01a0: 83006000     	movwhi	r6, #0x0
700a01a4: e1500004     	cmp	r0, r4
700a01a8: 1a000045     	bne	0x700a02c4 <free+0x190> @ imm = #0x114
700a01ac: e2110001     	ands	r0, r1, #1
700a01b0: 0a000043     	beq	0x700a02c4 <free+0x190> @ imm = #0x10c
700a01b4: e3550000     	cmp	r5, #0
700a01b8: 0a000009     	beq	0x700a01e4 <free+0xb0>  @ imm = #0x24
700a01bc: e5951000     	ldr	r1, [r5]
700a01c0: e3a00000     	mov	r0, #0
700a01c4: e3a07000     	mov	r7, #0
700a01c8: e2111001     	ands	r1, r1, #1
700a01cc: 01a00005     	moveq	r0, r5
700a01d0: e3560000     	cmp	r6, #0
700a01d4: 1a000005     	bne	0x700a01f0 <free+0xbc>  @ imm = #0x14
700a01d8: e3510000     	cmp	r1, #0
700a01dc: 0a00000b     	beq	0x700a0210 <free+0xdc>  @ imm = #0x2c
700a01e0: ea000022     	b	0x700a0270 <free+0x13c> @ imm = #0x88
700a01e4: e3a00000     	mov	r0, #0
700a01e8: e3560000     	cmp	r6, #0
700a01ec: 0a00001f     	beq	0x700a0270 <free+0x13c> @ imm = #0x7c
700a01f0: e5d61000     	ldrb	r1, [r6]
700a01f4: e3a07000     	mov	r7, #0
700a01f8: e3a08000     	mov	r8, #0
700a01fc: e3110001     	tst	r1, #1
700a0200: 01a07006     	moveq	r7, r6
700a0204: e3500000     	cmp	r0, #0
700a0208: 0a000007     	beq	0x700a022c <free+0xf8>  @ imm = #0x1c
700a020c: e1a05000     	mov	r5, r0
700a0210: e1a00005     	mov	r0, r5
700a0214: eb0038f6     	bl	0x700ae5f4 <free_list_remove> @ imm = #0xe3d8
700a0218: e3a08001     	mov	r8, #1
700a021c: e3570000     	cmp	r7, #0
700a0220: 0a00001d     	beq	0x700a029c <free+0x168> @ imm = #0x74
700a0224: e1a06007     	mov	r6, r7
700a0228: ea000002     	b	0x700a0238 <free+0x104> @ imm = #0x8
700a022c: e3a05000     	mov	r5, #0
700a0230: e3570000     	cmp	r7, #0
700a0234: 0a00000d     	beq	0x700a0270 <free+0x13c> @ imm = #0x34
700a0238: e1a00006     	mov	r0, r6
700a023c: eb0038ec     	bl	0x700ae5f4 <free_list_remove> @ imm = #0xe3b0
700a0240: e3580000     	cmp	r8, #0
700a0244: 0a00000c     	beq	0x700a027c <free+0x148> @ imm = #0x30
700a0248: e5950000     	ldr	r0, [r5]
700a024c: e5941000     	ldr	r1, [r4]
700a0250: e5962000     	ldr	r2, [r6]
700a0254: e2800010     	add	r0, r0, #16
700a0258: e3c11001     	bic	r1, r1, #1
700a025c: e3c00001     	bic	r0, r0, #1
700a0260: e3c22001     	bic	r2, r2, #1
700a0264: e0800001     	add	r0, r0, r1
700a0268: e0800002     	add	r0, r0, r2
700a026c: ea000010     	b	0x700a02b4 <free+0x180> @ imm = #0x40
700a0270: e5940000     	ldr	r0, [r4]
700a0274: e3c00001     	bic	r0, r0, #1
700a0278: ea000005     	b	0x700a0294 <free+0x160> @ imm = #0x14
700a027c: e5940000     	ldr	r0, [r4]
700a0280: e5961000     	ldr	r1, [r6]
700a0284: e2800008     	add	r0, r0, #8
700a0288: e3c11001     	bic	r1, r1, #1
700a028c: e3c00001     	bic	r0, r0, #1
700a0290: e0800001     	add	r0, r0, r1
700a0294: e5840000     	str	r0, [r4]
700a0298: ea000007     	b	0x700a02bc <free+0x188> @ imm = #0x1c
700a029c: e5950000     	ldr	r0, [r5]
700a02a0: e5941000     	ldr	r1, [r4]
700a02a4: e2800008     	add	r0, r0, #8
700a02a8: e3c11001     	bic	r1, r1, #1
700a02ac: e3c00001     	bic	r0, r0, #1
700a02b0: e0800001     	add	r0, r0, r1
700a02b4: e1a04005     	mov	r4, r5
700a02b8: e5850000     	str	r0, [r5]
700a02bc: e1a00004     	mov	r0, r4
700a02c0: eb00368e     	bl	0x700add00 <free_list_insert> @ imm = #0xda38
700a02c4: e59f0014     	ldr	r0, [pc, #0x14]         @ 0x700a02e0 <free+0x1ac>
700a02c8: e5900000     	ldr	r0, [r0]
700a02cc: e8bd41f0     	pop	{r4, r5, r6, r7, r8, lr}
700a02d0: e12fff10     	bx	r0
700a02d4: c4 29 0b 70  	.word	0x700b29c4
700a02d8: 00 53 08 70  	.word	0x70085300
700a02dc: 00 00 01 00  	.word	0x00010000
700a02e0: c8 29 0b 70  	.word	0x700b29c8
700a02e4: 00 00 00 00  	.word	0x00000000
700a02e8: 00 00 00 00  	.word	0x00000000
700a02ec: 00 00 00 00  	.word	0x00000000

700a02f0 <UART_lld_controllerIsr>:
; {
700a02f0: b580         	push	{r7, lr}
700a02f2: b086         	sub	sp, #0x18
700a02f4: 9005         	str	r0, [sp, #0x14]
700a02f6: 2001         	movs	r0, #0x1
;     uint32_t            retVal = TRUE;
700a02f8: 9001         	str	r0, [sp, #0x4]
;     if(NULL != args)
700a02fa: 9805         	ldr	r0, [sp, #0x14]
700a02fc: 2800         	cmp	r0, #0x0
700a02fe: f000 80c8    	beq.w	0x700a0492 <UART_lld_controllerIsr+0x1a2> @ imm = #0x190
700a0302: e7ff         	b	0x700a0304 <UART_lld_controllerIsr+0x14> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a0304: 9805         	ldr	r0, [sp, #0x14]
700a0306: 9002         	str	r0, [sp, #0x8]
;         while (retVal == TRUE)
700a0308: e7ff         	b	0x700a030a <UART_lld_controllerIsr+0x1a> @ imm = #-0x2
700a030a: 9801         	ldr	r0, [sp, #0x4]
700a030c: 2801         	cmp	r0, #0x1
700a030e: f040 80bf    	bne.w	0x700a0490 <UART_lld_controllerIsr+0x1a0> @ imm = #0x17e
700a0312: e7ff         	b	0x700a0314 <UART_lld_controllerIsr+0x24> @ imm = #-0x2
;             intType = UART_getIntrIdentityStatus(hUart->baseAddr);
700a0314: 9802         	ldr	r0, [sp, #0x8]
700a0316: 6800         	ldr	r0, [r0]
700a0318: f00d f8ea    	bl	0x700ad4f0 <UART_getIntrIdentityStatus> @ imm = #0xd1d4
700a031c: 9004         	str	r0, [sp, #0x10]
;             if ((intType & UART_INTID_RX_THRES_REACH) == UART_INTID_RX_THRES_REACH)
700a031e: f89d 0010    	ldrb.w	r0, [sp, #0x10]
700a0322: 0740         	lsls	r0, r0, #0x1d
700a0324: 2800         	cmp	r0, #0x0
700a0326: d561         	bpl	0x700a03ec <UART_lld_controllerIsr+0xfc> @ imm = #0xc2
700a0328: e7ff         	b	0x700a032a <UART_lld_controllerIsr+0x3a> @ imm = #-0x2
;                 if ((intType & UART_INTID_RX_LINE_STAT_ERROR) ==
700a032a: 9804         	ldr	r0, [sp, #0x10]
700a032c: f000 0006    	and	r0, r0, #0x6
700a0330: 2806         	cmp	r0, #0x6
700a0332: d104         	bne	0x700a033e <UART_lld_controllerIsr+0x4e> @ imm = #0x8
700a0334: e7ff         	b	0x700a0336 <UART_lld_controllerIsr+0x46> @ imm = #-0x2
;                     (void)UART_procLineStatusErr(hUart);
700a0336: 9802         	ldr	r0, [sp, #0x8]
700a0338: f002 fb8a    	bl	0x700a2a50 <UART_procLineStatusErr> @ imm = #0x2714
;                 }
700a033c: e055         	b	0x700a03ea <UART_lld_controllerIsr+0xfa> @ imm = #0xaa
;                     if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
700a033e: 9804         	ldr	r0, [sp, #0x10]
700a0340: f000 000c    	and	r0, r0, #0xc
700a0344: 280c         	cmp	r0, #0xc
700a0346: d10a         	bne	0x700a035e <UART_lld_controllerIsr+0x6e> @ imm = #0x14
700a0348: e7ff         	b	0x700a034a <UART_lld_controllerIsr+0x5a> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a034a: 9802         	ldr	r0, [sp, #0x8]
700a034c: 6800         	ldr	r0, [r0]
700a034e: 2105         	movs	r1, #0x5
700a0350: f005 fffe    	bl	0x700a6350 <UART_intrDisable> @ imm = #0x5ffc
;                         hUart->rxTimeoutCnt++;
700a0354: 9902         	ldr	r1, [sp, #0x8]
700a0356: 6a08         	ldr	r0, [r1, #0x20]
700a0358: 3001         	adds	r0, #0x1
700a035a: 6208         	str	r0, [r1, #0x20]
;                     }
700a035c: e7ff         	b	0x700a035e <UART_lld_controllerIsr+0x6e> @ imm = #-0x2
;                     if (hUart->readSizeRemaining > 0U)
700a035e: 9802         	ldr	r0, [sp, #0x8]
700a0360: 69c0         	ldr	r0, [r0, #0x1c]
700a0362: b3a8         	cbz	r0, 0x700a03d0 <UART_lld_controllerIsr+0xe0> @ imm = #0x6a
700a0364: e7ff         	b	0x700a0366 <UART_lld_controllerIsr+0x76> @ imm = #-0x2
;                         hUart->readSizeRemaining = UART_readData(hUart, hUart->readSizeRemaining);
700a0366: 9802         	ldr	r0, [sp, #0x8]
700a0368: 69c1         	ldr	r1, [r0, #0x1c]
700a036a: f00a fc49    	bl	0x700aac00 <UART_readData> @ imm = #0xa892
700a036e: 9902         	ldr	r1, [sp, #0x8]
700a0370: 61c8         	str	r0, [r1, #0x1c]
;                         if ((hUart->readSizeRemaining == 0U) ||
700a0372: 9802         	ldr	r0, [sp, #0x8]
700a0374: 69c0         	ldr	r0, [r0, #0x1c]
700a0376: b130         	cbz	r0, 0x700a0386 <UART_lld_controllerIsr+0x96> @ imm = #0xc
700a0378: e7ff         	b	0x700a037a <UART_lld_controllerIsr+0x8a> @ imm = #-0x2
;                             (hUart->hUartInit->readReturnMode == UART_READ_RETURN_MODE_PARTIAL))
700a037a: 9802         	ldr	r0, [sp, #0x8]
700a037c: 6840         	ldr	r0, [r0, #0x4]
700a037e: 6940         	ldr	r0, [r0, #0x14]
;                         if ((hUart->readSizeRemaining == 0U) ||
700a0380: 2801         	cmp	r0, #0x1
700a0382: d11e         	bne	0x700a03c2 <UART_lld_controllerIsr+0xd2> @ imm = #0x3c
700a0384: e7ff         	b	0x700a0386 <UART_lld_controllerIsr+0x96> @ imm = #-0x2
;                             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a0386: 9802         	ldr	r0, [sp, #0x8]
700a0388: 6800         	ldr	r0, [r0]
700a038a: 2105         	movs	r1, #0x5
700a038c: f005 ffe0    	bl	0x700a6350 <UART_intrDisable> @ imm = #0x5fc0
;                             hUart->readBuf = (uint8_t *)hUart->readBuf - hUart->readCount;
700a0390: 9902         	ldr	r1, [sp, #0x8]
700a0392: 6948         	ldr	r0, [r1, #0x14]
700a0394: 698a         	ldr	r2, [r1, #0x18]
700a0396: 1a80         	subs	r0, r0, r2
700a0398: 6148         	str	r0, [r1, #0x14]
;                             if (hUart->readTrans.buf != NULL)
700a039a: 9802         	ldr	r0, [sp, #0x8]
700a039c: 6a80         	ldr	r0, [r0, #0x28]
700a039e: b138         	cbz	r0, 0x700a03b0 <UART_lld_controllerIsr+0xc0> @ imm = #0xe
700a03a0: e7ff         	b	0x700a03a2 <UART_lld_controllerIsr+0xb2> @ imm = #-0x2
;                                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
700a03a2: 9902         	ldr	r1, [sp, #0x8]
700a03a4: 6988         	ldr	r0, [r1, #0x18]
700a03a6: 62c8         	str	r0, [r1, #0x2c]
;                                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a03a8: 9902         	ldr	r1, [sp, #0x8]
700a03aa: 2000         	movs	r0, #0x0
700a03ac: 6348         	str	r0, [r1, #0x34]
;                             }
700a03ae: e7ff         	b	0x700a03b0 <UART_lld_controllerIsr+0xc0> @ imm = #-0x2
;                             hUart->hUartInit->readCompleteCallbackFxn(hUart);
700a03b0: 9802         	ldr	r0, [sp, #0x8]
700a03b2: 6841         	ldr	r1, [r0, #0x4]
700a03b4: 6dc9         	ldr	r1, [r1, #0x5c]
700a03b6: 4788         	blx	r1
;                             UART_lld_Transaction_deInit(&hUart->readTrans);
700a03b8: 9802         	ldr	r0, [sp, #0x8]
700a03ba: 3028         	adds	r0, #0x28
700a03bc: f00f f860    	bl	0x700af480 <UART_lld_Transaction_deInit> @ imm = #0xf0c0
;                         }
700a03c0: e005         	b	0x700a03ce <UART_lld_controllerIsr+0xde> @ imm = #0xa
;                             UART_intrEnable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a03c2: 9802         	ldr	r0, [sp, #0x8]
700a03c4: 6800         	ldr	r0, [r0]
700a03c6: 2105         	movs	r1, #0x5
700a03c8: f005 fee2    	bl	0x700a6190 <UART_intrEnable> @ imm = #0x5dc4
700a03cc: e7ff         	b	0x700a03ce <UART_lld_controllerIsr+0xde> @ imm = #-0x2
;                     }
700a03ce: e00b         	b	0x700a03e8 <UART_lld_controllerIsr+0xf8> @ imm = #0x16
;                         (void)UART_getChar(hUart->baseAddr, &rdData);
700a03d0: 9802         	ldr	r0, [sp, #0x8]
700a03d2: 6800         	ldr	r0, [r0]
700a03d4: f10d 010f    	add.w	r1, sp, #0xf
700a03d8: f00b fff2    	bl	0x700ac3c0 <UART_getChar> @ imm = #0xbfe4
;                         UART_intrDisable(hUart->baseAddr, (uint32_t) UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a03dc: 9802         	ldr	r0, [sp, #0x8]
700a03de: 6800         	ldr	r0, [r0]
700a03e0: 2105         	movs	r1, #0x5
700a03e2: f005 ffb5    	bl	0x700a6350 <UART_intrDisable> @ imm = #0x5f6a
700a03e6: e7ff         	b	0x700a03e8 <UART_lld_controllerIsr+0xf8> @ imm = #-0x2
700a03e8: e7ff         	b	0x700a03ea <UART_lld_controllerIsr+0xfa> @ imm = #-0x2
;             }
700a03ea: e050         	b	0x700a048e <UART_lld_controllerIsr+0x19e> @ imm = #0xa0
;             else if ((intType & UART_INTID_TX_THRES_REACH) == UART_INTID_TX_THRES_REACH)
700a03ec: f89d 0010    	ldrb.w	r0, [sp, #0x10]
700a03f0: 0780         	lsls	r0, r0, #0x1e
700a03f2: 2800         	cmp	r0, #0x0
700a03f4: d534         	bpl	0x700a0460 <UART_lld_controllerIsr+0x170> @ imm = #0x68
700a03f6: e7ff         	b	0x700a03f8 <UART_lld_controllerIsr+0x108> @ imm = #-0x2
;                 if (hUart->writeSizeRemaining > 0U)
700a03f8: 9802         	ldr	r0, [sp, #0x8]
700a03fa: 6900         	ldr	r0, [r0, #0x10]
700a03fc: b348         	cbz	r0, 0x700a0452 <UART_lld_controllerIsr+0x162> @ imm = #0x52
700a03fe: e7ff         	b	0x700a0400 <UART_lld_controllerIsr+0x110> @ imm = #-0x2
;                     hUart->writeSizeRemaining = (uint32_t)UART_writeData(hUart, (hUart->writeSizeRemaining));
700a0400: 9802         	ldr	r0, [sp, #0x8]
700a0402: 6901         	ldr	r1, [r0, #0x10]
700a0404: f00c f80c    	bl	0x700ac420 <UART_writeData> @ imm = #0xc018
700a0408: 9902         	ldr	r1, [sp, #0x8]
700a040a: 6108         	str	r0, [r1, #0x10]
;                     if ((hUart->writeSizeRemaining) == 0U)
700a040c: 9802         	ldr	r0, [sp, #0x8]
700a040e: 6900         	ldr	r0, [r0, #0x10]
700a0410: b9f0         	cbnz	r0, 0x700a0450 <UART_lld_controllerIsr+0x160> @ imm = #0x3c
700a0412: e7ff         	b	0x700a0414 <UART_lld_controllerIsr+0x124> @ imm = #-0x2
;                         UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700a0414: 9802         	ldr	r0, [sp, #0x8]
700a0416: 6800         	ldr	r0, [r0]
700a0418: 2102         	movs	r1, #0x2
700a041a: f005 ff99    	bl	0x700a6350 <UART_intrDisable> @ imm = #0x5f32
;                         hUart->writeBuf = (const void *)((uint8_t *)hUart->writeBuf - hUart->writeCount);
700a041e: 9902         	ldr	r1, [sp, #0x8]
700a0420: 6888         	ldr	r0, [r1, #0x8]
700a0422: 68ca         	ldr	r2, [r1, #0xc]
700a0424: 1a80         	subs	r0, r0, r2
700a0426: 6088         	str	r0, [r1, #0x8]
;                         if (hUart->writeTrans.buf != NULL)
700a0428: 9802         	ldr	r0, [sp, #0x8]
700a042a: 6bc0         	ldr	r0, [r0, #0x3c]
700a042c: b138         	cbz	r0, 0x700a043e <UART_lld_controllerIsr+0x14e> @ imm = #0xe
700a042e: e7ff         	b	0x700a0430 <UART_lld_controllerIsr+0x140> @ imm = #-0x2
;                             hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
700a0430: 9902         	ldr	r1, [sp, #0x8]
700a0432: 68c8         	ldr	r0, [r1, #0xc]
700a0434: 6408         	str	r0, [r1, #0x40]
;                             hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a0436: 9902         	ldr	r1, [sp, #0x8]
700a0438: 2000         	movs	r0, #0x0
700a043a: 6488         	str	r0, [r1, #0x48]
;                         }
700a043c: e7ff         	b	0x700a043e <UART_lld_controllerIsr+0x14e> @ imm = #-0x2
;                         hUart->hUartInit->writeCompleteCallbackFxn(hUart);
700a043e: 9802         	ldr	r0, [sp, #0x8]
700a0440: 6841         	ldr	r1, [r0, #0x4]
700a0442: 6e09         	ldr	r1, [r1, #0x60]
700a0444: 4788         	blx	r1
;                         UART_lld_Transaction_deInit(&hUart->writeTrans);
700a0446: 9802         	ldr	r0, [sp, #0x8]
700a0448: 303c         	adds	r0, #0x3c
700a044a: f00f f819    	bl	0x700af480 <UART_lld_Transaction_deInit> @ imm = #0xf032
;                     }
700a044e: e7ff         	b	0x700a0450 <UART_lld_controllerIsr+0x160> @ imm = #-0x2
;                 }
700a0450: e005         	b	0x700a045e <UART_lld_controllerIsr+0x16e> @ imm = #0xa
;                     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700a0452: 9802         	ldr	r0, [sp, #0x8]
700a0454: 6800         	ldr	r0, [r0]
700a0456: 2102         	movs	r1, #0x2
700a0458: f005 ff7a    	bl	0x700a6350 <UART_intrDisable> @ imm = #0x5ef4
700a045c: e7ff         	b	0x700a045e <UART_lld_controllerIsr+0x16e> @ imm = #-0x2
;             }
700a045e: e015         	b	0x700a048c <UART_lld_controllerIsr+0x19c> @ imm = #0x2a
;             else if ((intType & UART_INTID_CHAR_TIMEOUT) == UART_INTID_CHAR_TIMEOUT)
700a0460: 9804         	ldr	r0, [sp, #0x10]
700a0462: f000 000c    	and	r0, r0, #0xc
700a0466: 280c         	cmp	r0, #0xc
700a0468: d10c         	bne	0x700a0484 <UART_lld_controllerIsr+0x194> @ imm = #0x18
700a046a: e7ff         	b	0x700a046c <UART_lld_controllerIsr+0x17c> @ imm = #-0x2
;                 if (FALSE == UART_checkCharsAvailInFifo(hUart->baseAddr))
700a046c: 9802         	ldr	r0, [sp, #0x8]
700a046e: 6800         	ldr	r0, [r0]
700a0470: f00c fe86    	bl	0x700ad180 <UART_checkCharsAvailInFifo> @ imm = #0xcd0c
700a0474: b928         	cbnz	r0, 0x700a0482 <UART_lld_controllerIsr+0x192> @ imm = #0xa
700a0476: e7ff         	b	0x700a0478 <UART_lld_controllerIsr+0x188> @ imm = #-0x2
;                     UART_i2310WA(hUart->baseAddr);
700a0478: 9802         	ldr	r0, [sp, #0x8]
700a047a: 6800         	ldr	r0, [r0]
700a047c: f00d fd00    	bl	0x700ade80 <UART_i2310WA> @ imm = #0xda00
;                 }
700a0480: e7ff         	b	0x700a0482 <UART_lld_controllerIsr+0x192> @ imm = #-0x2
;             }
700a0482: e002         	b	0x700a048a <UART_lld_controllerIsr+0x19a> @ imm = #0x4
700a0484: 2000         	movs	r0, #0x0
;                 retVal = FALSE;
700a0486: 9001         	str	r0, [sp, #0x4]
700a0488: e7ff         	b	0x700a048a <UART_lld_controllerIsr+0x19a> @ imm = #-0x2
700a048a: e7ff         	b	0x700a048c <UART_lld_controllerIsr+0x19c> @ imm = #-0x2
700a048c: e7ff         	b	0x700a048e <UART_lld_controllerIsr+0x19e> @ imm = #-0x2
;         while (retVal == TRUE)
700a048e: e73c         	b	0x700a030a <UART_lld_controllerIsr+0x1a> @ imm = #-0x188
;     }
700a0490: e000         	b	0x700a0494 <UART_lld_controllerIsr+0x1a4> @ imm = #0x0
700a0492: e7ff         	b	0x700a0494 <UART_lld_controllerIsr+0x1a4> @ imm = #-0x2
; }
700a0494: b006         	add	sp, #0x18
700a0496: bd80         	pop	{r7, pc}
		...

700a04a0 <UART_write>:
; {
700a04a0: b580         	push	{r7, lr}
700a04a2: b08e         	sub	sp, #0x38
700a04a4: 900d         	str	r0, [sp, #0x34]
700a04a6: 910c         	str	r1, [sp, #0x30]
700a04a8: 2000         	movs	r0, #0x0
;     int32_t             status = SystemP_SUCCESS, semStatus = SystemP_SUCCESS;
700a04aa: 900b         	str	r0, [sp, #0x2c]
700a04ac: 900a         	str	r0, [sp, #0x28]
;     if ((NULL_PTR == handle) || (NULL_PTR == trans))
700a04ae: 980d         	ldr	r0, [sp, #0x34]
700a04b0: b118         	cbz	r0, 0x700a04ba <UART_write+0x1a> @ imm = #0x6
700a04b2: e7ff         	b	0x700a04b4 <UART_write+0x14> @ imm = #-0x2
700a04b4: 980c         	ldr	r0, [sp, #0x30]
700a04b6: b920         	cbnz	r0, 0x700a04c2 <UART_write+0x22> @ imm = #0x8
700a04b8: e7ff         	b	0x700a04ba <UART_write+0x1a> @ imm = #-0x2
700a04ba: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a04be: 900b         	str	r0, [sp, #0x2c]
;     }
700a04c0: e7ff         	b	0x700a04c2 <UART_write+0x22> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a04c2: 980b         	ldr	r0, [sp, #0x2c]
700a04c4: 2800         	cmp	r0, #0x0
700a04c6: d141         	bne	0x700a054c <UART_write+0xac> @ imm = #0x82
700a04c8: e7ff         	b	0x700a04ca <UART_write+0x2a> @ imm = #-0x2
;         config  = (UART_Config *) handle;
700a04ca: 980d         	ldr	r0, [sp, #0x34]
700a04cc: 9009         	str	r0, [sp, #0x24]
;         object  = config->object;
700a04ce: 9809         	ldr	r0, [sp, #0x24]
700a04d0: 6840         	ldr	r0, [r0, #0x4]
700a04d2: 9008         	str	r0, [sp, #0x20]
;         attrs   = config->attrs;
700a04d4: 9809         	ldr	r0, [sp, #0x24]
700a04d6: 6800         	ldr	r0, [r0]
700a04d8: 9007         	str	r0, [sp, #0x1c]
;         prms    = &config->object->prms;
700a04da: 9809         	ldr	r0, [sp, #0x24]
700a04dc: 6840         	ldr	r0, [r0, #0x4]
700a04de: 3004         	adds	r0, #0x4
700a04e0: 9006         	str	r0, [sp, #0x18]
;         uartLld_handle = object->uartLld_handle;
700a04e2: 9808         	ldr	r0, [sp, #0x20]
700a04e4: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a04e8: 9004         	str	r0, [sp, #0x10]
;         object->writeTrans = trans;
700a04ea: 980c         	ldr	r0, [sp, #0x30]
700a04ec: 9908         	ldr	r1, [sp, #0x20]
700a04ee: f8c1 0080    	str.w	r0, [r1, #0x80]
;         DebugP_assert(NULL_PTR != object);
700a04f2: 9808         	ldr	r0, [sp, #0x20]
700a04f4: 2800         	cmp	r0, #0x0
700a04f6: bf18         	it	ne
700a04f8: 2001         	movne	r0, #0x1
700a04fa: f641 71ce    	movw	r1, #0x1fce
700a04fe: f2c7 010b    	movt	r1, #0x700b
700a0502: 466a         	mov	r2, sp
700a0504: 6011         	str	r1, [r2]
700a0506: f641 71e1    	movw	r1, #0x1fe1
700a050a: f2c7 010b    	movt	r1, #0x700b
700a050e: 9101         	str	r1, [sp, #0x4]
700a0510: f242 122b    	movw	r2, #0x212b
700a0514: f2c7 020b    	movt	r2, #0x700b
700a0518: 9202         	str	r2, [sp, #0x8]
700a051a: f44f 7305    	mov.w	r3, #0x214
700a051e: f00a fbaf    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xa75e
700a0522: 9901         	ldr	r1, [sp, #0x4]
700a0524: 9a02         	ldr	r2, [sp, #0x8]
;         DebugP_assert(NULL_PTR != attrs);
700a0526: 9807         	ldr	r0, [sp, #0x1c]
700a0528: 2800         	cmp	r0, #0x0
700a052a: bf18         	it	ne
700a052c: 2001         	movne	r0, #0x1
700a052e: f242 0317    	movw	r3, #0x2017
700a0532: f2c7 030b    	movt	r3, #0x700b
700a0536: 46ec         	mov	r12, sp
700a0538: f8cc 3000    	str.w	r3, [r12]
700a053c: f240 2315    	movw	r3, #0x215
700a0540: f00a fb9e    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xa73c
;         extendedParams.args = trans->args;
700a0544: 980c         	ldr	r0, [sp, #0x30]
700a0546: 6900         	ldr	r0, [r0, #0x10]
700a0548: 9003         	str	r0, [sp, #0xc]
;     }
700a054a: e7ff         	b	0x700a054c <UART_write+0xac> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a054c: 980b         	ldr	r0, [sp, #0x2c]
700a054e: b950         	cbnz	r0, 0x700a0566 <UART_write+0xc6> @ imm = #0x14
700a0550: e7ff         	b	0x700a0552 <UART_write+0xb2> @ imm = #-0x2
;         if (TRUE == prms->skipIntrReg)
700a0552: 9806         	ldr	r0, [sp, #0x18]
700a0554: 6b80         	ldr	r0, [r0, #0x38]
700a0556: 2801         	cmp	r0, #0x1
700a0558: d104         	bne	0x700a0564 <UART_write+0xc4> @ imm = #0x8
700a055a: e7ff         	b	0x700a055c <UART_write+0xbc> @ imm = #-0x2
700a055c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
700a0560: 900b         	str	r0, [sp, #0x2c]
;         }
700a0562: e7ff         	b	0x700a0564 <UART_write+0xc4> @ imm = #-0x2
;     }
700a0564: e7ff         	b	0x700a0566 <UART_write+0xc6> @ imm = #-0x2
;     if(SystemP_SUCCESS == status)
700a0566: 980b         	ldr	r0, [sp, #0x2c]
700a0568: 2800         	cmp	r0, #0x0
700a056a: d168         	bne	0x700a063e <UART_write+0x19e> @ imm = #0xd0
700a056c: e7ff         	b	0x700a056e <UART_write+0xce> @ imm = #-0x2
;         key = HwiP_disable();
700a056e: f010 e9f8    	blx	0x700b0960 <HwiP_disable> @ imm = #0x103f0
700a0572: 9005         	str	r0, [sp, #0x14]
;         HwiP_restore(key);
700a0574: 9805         	ldr	r0, [sp, #0x14]
700a0576: f010 ea14    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x10428
;         uartLld_handle->state = UART_STATE_READY;
700a057a: 9904         	ldr	r1, [sp, #0x10]
700a057c: 2001         	movs	r0, #0x1
700a057e: 6548         	str	r0, [r1, #0x54]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
700a0580: 9806         	ldr	r0, [sp, #0x18]
700a0582: 6ac0         	ldr	r0, [r0, #0x2c]
700a0584: 2801         	cmp	r0, #0x1
700a0586: d005         	beq	0x700a0594 <UART_write+0xf4> @ imm = #0xa
700a0588: e7ff         	b	0x700a058a <UART_write+0xea> @ imm = #-0x2
;             (UART_CONFIG_MODE_DMA == prms->transferMode))
700a058a: 9806         	ldr	r0, [sp, #0x18]
700a058c: 6ac0         	ldr	r0, [r0, #0x2c]
;         if ((UART_CONFIG_MODE_INTERRUPT == prms->transferMode) ||
700a058e: 2803         	cmp	r0, #0x3
700a0590: d146         	bne	0x700a0620 <UART_write+0x180> @ imm = #0x8c
700a0592: e7ff         	b	0x700a0594 <UART_write+0xf4> @ imm = #-0x2
;             if (UART_CONFIG_MODE_INTERRUPT == prms->transferMode)
700a0594: 9806         	ldr	r0, [sp, #0x18]
700a0596: 6ac0         	ldr	r0, [r0, #0x2c]
700a0598: 2801         	cmp	r0, #0x1
700a059a: d109         	bne	0x700a05b0 <UART_write+0x110> @ imm = #0x12
700a059c: e7ff         	b	0x700a059e <UART_write+0xfe> @ imm = #-0x2
;                 status = UART_lld_writeIntr(uartLld_handle, trans->buf, trans->count, &extendedParams);
700a059e: 9804         	ldr	r0, [sp, #0x10]
700a05a0: 9a0c         	ldr	r2, [sp, #0x30]
700a05a2: 6811         	ldr	r1, [r2]
700a05a4: 6852         	ldr	r2, [r2, #0x4]
700a05a6: ab03         	add	r3, sp, #0xc
700a05a8: f006 fe02    	bl	0x700a71b0 <UART_lld_writeIntr> @ imm = #0x6c04
700a05ac: 900b         	str	r0, [sp, #0x2c]
;             }
700a05ae: e008         	b	0x700a05c2 <UART_write+0x122> @ imm = #0x10
;                 status = UART_lld_writeDma(uartLld_handle, trans->buf, trans->count, &extendedParams);
700a05b0: 9804         	ldr	r0, [sp, #0x10]
700a05b2: 9a0c         	ldr	r2, [sp, #0x30]
700a05b4: 6811         	ldr	r1, [r2]
700a05b6: 6852         	ldr	r2, [r2, #0x4]
700a05b8: ab03         	add	r3, sp, #0xc
700a05ba: f006 fc59    	bl	0x700a6e70 <UART_lld_writeDma> @ imm = #0x68b2
700a05be: 900b         	str	r0, [sp, #0x2c]
700a05c0: e7ff         	b	0x700a05c2 <UART_write+0x122> @ imm = #-0x2
;             if (SystemP_SUCCESS == status)
700a05c2: 980b         	ldr	r0, [sp, #0x2c]
700a05c4: bb58         	cbnz	r0, 0x700a061e <UART_write+0x17e> @ imm = #0x56
700a05c6: e7ff         	b	0x700a05c8 <UART_write+0x128> @ imm = #-0x2
;                 if(object->prms.writeMode == UART_TRANSFER_MODE_BLOCKING)
700a05c8: 9808         	ldr	r0, [sp, #0x20]
700a05ca: 69c0         	ldr	r0, [r0, #0x1c]
700a05cc: bb18         	cbnz	r0, 0x700a0616 <UART_write+0x176> @ imm = #0x46
700a05ce: e7ff         	b	0x700a05d0 <UART_write+0x130> @ imm = #-0x2
;                     semStatus = SemaphoreP_pend(&object->writeTransferSemObj, trans->timeout);
700a05d0: 9808         	ldr	r0, [sp, #0x20]
700a05d2: f500 70e2    	add.w	r0, r0, #0x1c4
700a05d6: 990c         	ldr	r1, [sp, #0x30]
700a05d8: 6889         	ldr	r1, [r1, #0x8]
700a05da: f00a f8f9    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0xa1f2
700a05de: 900a         	str	r0, [sp, #0x28]
;                     if (semStatus == SystemP_SUCCESS)
700a05e0: 980a         	ldr	r0, [sp, #0x28]
700a05e2: b960         	cbnz	r0, 0x700a05fe <UART_write+0x15e> @ imm = #0x18
700a05e4: e7ff         	b	0x700a05e6 <UART_write+0x146> @ imm = #-0x2
;                         if (trans->status == (uint32_t)UART_STATUS_SUCCESS)
700a05e6: 980c         	ldr	r0, [sp, #0x30]
700a05e8: 68c0         	ldr	r0, [r0, #0xc]
700a05ea: b918         	cbnz	r0, 0x700a05f4 <UART_write+0x154> @ imm = #0x6
700a05ec: e7ff         	b	0x700a05ee <UART_write+0x14e> @ imm = #-0x2
700a05ee: 2000         	movs	r0, #0x0
;                             status = SystemP_SUCCESS;
700a05f0: 900b         	str	r0, [sp, #0x2c]
;                         }
700a05f2: e003         	b	0x700a05fc <UART_write+0x15c> @ imm = #0x6
700a05f4: f04f 30ff    	mov.w	r0, #0xffffffff
;                             status = SystemP_FAILURE;
700a05f8: 900b         	str	r0, [sp, #0x2c]
700a05fa: e7ff         	b	0x700a05fc <UART_write+0x15c> @ imm = #-0x2
;                     }
700a05fc: e00a         	b	0x700a0614 <UART_write+0x174> @ imm = #0x14
;                         trans->status = UART_TRANSFER_TIMEOUT;
700a05fe: 990c         	ldr	r1, [sp, #0x30]
700a0600: f06f 0001    	mvn	r0, #0x1
700a0604: 60c8         	str	r0, [r1, #0xc]
;                         (void)UART_writeCancelNoCB(uartLld_handle);
700a0606: 9804         	ldr	r0, [sp, #0x10]
700a0608: f009 fd82    	bl	0x700aa110 <UART_writeCancelNoCB> @ imm = #0x9b04
700a060c: f04f 30ff    	mov.w	r0, #0xffffffff
;                         status = SystemP_FAILURE;
700a0610: 900b         	str	r0, [sp, #0x2c]
700a0612: e7ff         	b	0x700a0614 <UART_write+0x174> @ imm = #-0x2
;                 }
700a0614: e002         	b	0x700a061c <UART_write+0x17c> @ imm = #0x4
700a0616: 2000         	movs	r0, #0x0
;                     status = SystemP_SUCCESS;
700a0618: 900b         	str	r0, [sp, #0x2c]
700a061a: e7ff         	b	0x700a061c <UART_write+0x17c> @ imm = #-0x2
;             }
700a061c: e7ff         	b	0x700a061e <UART_write+0x17e> @ imm = #-0x2
;         }
700a061e: e00d         	b	0x700a063c <UART_write+0x19c> @ imm = #0x1a
;             status = UART_lld_write(uartLld_handle, trans->buf, trans->count, trans->timeout, &extendedParams);
700a0620: 9804         	ldr	r0, [sp, #0x10]
700a0622: 9b0c         	ldr	r3, [sp, #0x30]
700a0624: 6819         	ldr	r1, [r3]
700a0626: 685a         	ldr	r2, [r3, #0x4]
700a0628: 689b         	ldr	r3, [r3, #0x8]
700a062a: 46ee         	mov	lr, sp
700a062c: f10d 0c0c    	add.w	r12, sp, #0xc
700a0630: f8ce c000    	str.w	r12, [lr]
700a0634: f006 f92c    	bl	0x700a6890 <UART_lld_write> @ imm = #0x6258
700a0638: 900b         	str	r0, [sp, #0x2c]
700a063a: e7ff         	b	0x700a063c <UART_write+0x19c> @ imm = #-0x2
;     }
700a063c: e7ff         	b	0x700a063e <UART_write+0x19e> @ imm = #-0x2
;     return (status);
700a063e: 980b         	ldr	r0, [sp, #0x2c]
700a0640: b00e         	add	sp, #0x38
700a0642: bd80         	pop	{r7, pc}
		...

700a0650 <Sciclient_rmClearInterruptRoute>:
; {
700a0650: b580         	push	{r7, lr}
700a0652: b08e         	sub	sp, #0x38
700a0654: 900d         	str	r0, [sp, #0x34]
700a0656: 910c         	str	r1, [sp, #0x30]
700a0658: 920b         	str	r2, [sp, #0x2c]
700a065a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a065c: 9001         	str	r0, [sp, #0x4]
700a065e: 900a         	str	r0, [sp, #0x28]
700a0660: f241 0101    	movw	r1, #0x1001
;     uint16_t messageType = TISCI_MSG_RM_IRQ_RELEASE;
700a0664: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
700a0668: 9008         	str	r0, [sp, #0x20]
700a066a: 9007         	str	r0, [sp, #0x1c]
700a066c: 9006         	str	r0, [sp, #0x18]
700a066e: 9005         	str	r0, [sp, #0x14]
700a0670: 9004         	str	r0, [sp, #0x10]
700a0672: 9003         	str	r0, [sp, #0xc]
700a0674: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
700a0676: 980d         	ldr	r0, [sp, #0x34]
700a0678: b118         	cbz	r0, 0x700a0682 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #0x6
700a067a: e7ff         	b	0x700a067c <Sciclient_rmClearInterruptRoute+0x2c> @ imm = #-0x2
700a067c: 980c         	ldr	r0, [sp, #0x30]
700a067e: b920         	cbnz	r0, 0x700a068a <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #0x8
700a0680: e7ff         	b	0x700a0682 <Sciclient_rmClearInterruptRoute+0x32> @ imm = #-0x2
700a0682: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0686: 900a         	str	r0, [sp, #0x28]
;     }
700a0688: e7ff         	b	0x700a068a <Sciclient_rmClearInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a068a: 980a         	ldr	r0, [sp, #0x28]
700a068c: b968         	cbnz	r0, 0x700a06aa <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0x1a
700a068e: e7ff         	b	0x700a0690 <Sciclient_rmClearInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a0690: 980d         	ldr	r0, [sp, #0x34]
700a0692: 6880         	ldr	r0, [r0, #0x8]
700a0694: f04f 4100    	mov.w	r1, #0x80000000
700a0698: f00e fb32    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0xe664
;     if (r == SystemP_SUCCESS &&
700a069c: b128         	cbz	r0, 0x700a06aa <Sciclient_rmClearInterruptRoute+0x5a> @ imm = #0xa
700a069e: e7ff         	b	0x700a06a0 <Sciclient_rmClearInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
700a06a0: 980d         	ldr	r0, [sp, #0x34]
700a06a2: 7ec0         	ldrb	r0, [r0, #0x1b]
700a06a4: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
700a06a8: e00f         	b	0x700a06ca <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
700a06aa: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
700a06ae: f007 fa87    	bl	0x700a7bc0 <Sciclient_getCurrentContext> @ imm = #0x750e
700a06b2: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a06b6: f241 3060    	movw	r0, #0x1360
700a06ba: f2c7 000b    	movt	r0, #0x700b
700a06be: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a06c2: 6840         	ldr	r0, [r0, #0x4]
700a06c4: f88d 0025    	strb.w	r0, [sp, #0x25]
700a06c8: e7ff         	b	0x700a06ca <Sciclient_rmClearInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a06ca: 980a         	ldr	r0, [sp, #0x28]
700a06cc: b960         	cbnz	r0, 0x700a06e8 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0x18
700a06ce: e7ff         	b	0x700a06d0 <Sciclient_rmClearInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a06d0: 980d         	ldr	r0, [sp, #0x34]
700a06d2: 6880         	ldr	r0, [r0, #0x8]
700a06d4: 2104         	movs	r1, #0x4
700a06d6: f00e fb13    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0xe626
;     if (r == SystemP_SUCCESS &&
700a06da: b128         	cbz	r0, 0x700a06e8 <Sciclient_rmClearInterruptRoute+0x98> @ imm = #0xa
700a06dc: e7ff         	b	0x700a06de <Sciclient_rmClearInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
700a06de: 980d         	ldr	r0, [sp, #0x34]
700a06e0: 8a80         	ldrh	r0, [r0, #0x14]
700a06e2: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
700a06e6: e003         	b	0x700a06f0 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #0x6
700a06e8: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
700a06ea: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a06ee: e7ff         	b	0x700a06f0 <Sciclient_rmClearInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a06f0: 980a         	ldr	r0, [sp, #0x28]
700a06f2: 2800         	cmp	r0, #0x0
700a06f4: d175         	bne	0x700a07e2 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #0xea
700a06f6: e7ff         	b	0x700a06f8 <Sciclient_rmClearInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
700a06f8: 980d         	ldr	r0, [sp, #0x34]
700a06fa: 6880         	ldr	r0, [r0, #0x8]
700a06fc: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
700a06fe: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a0702: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
700a0706: 980d         	ldr	r0, [sp, #0x34]
700a0708: 8980         	ldrh	r0, [r0, #0xc]
700a070a: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
700a070e: 980d         	ldr	r0, [sp, #0x34]
700a0710: 89c0         	ldrh	r0, [r0, #0xe]
700a0712: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
700a0716: 980d         	ldr	r0, [sp, #0x34]
700a0718: 8a00         	ldrh	r0, [r0, #0x10]
700a071a: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
700a071e: 980d         	ldr	r0, [sp, #0x34]
700a0720: 8a40         	ldrh	r0, [r0, #0x12]
700a0722: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
700a0726: 980d         	ldr	r0, [sp, #0x34]
700a0728: 8b00         	ldrh	r0, [r0, #0x18]
700a072a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
700a072e: 980d         	ldr	r0, [sp, #0x34]
700a0730: 8ac0         	ldrh	r0, [r0, #0x16]
700a0732: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
700a0736: 980d         	ldr	r0, [sp, #0x34]
700a0738: 7e80         	ldrb	r0, [r0, #0x1a]
700a073a: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
700a073e: 9802         	ldr	r0, [sp, #0x8]
700a0740: f00b f8c6    	bl	0x700ab8d0 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xb18c
700a0744: b310         	cbz	r0, 0x700a078c <Sciclient_rmClearInterruptRoute+0x13c> @ imm = #0x44
700a0746: e7ff         	b	0x700a0748 <Sciclient_rmClearInterruptRoute+0xf8> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
700a0748: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a074c: f00e f8e0    	bl	0x700ae910 <Sciclient_rmIaIsIa> @ imm = #0xe1c0
700a0750: b168         	cbz	r0, 0x700a076e <Sciclient_rmClearInterruptRoute+0x11e> @ imm = #0x1a
700a0752: e7ff         	b	0x700a0754 <Sciclient_rmClearInterruptRoute+0x104> @ imm = #-0x2
;                 cfg.s_ia = cfg.s_id;
700a0754: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a0758: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                 cfg.vint = cfg.s_idx;
700a075c: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a0760: f8ad 001a    	strh.w	r0, [sp, #0x1a]
700a0764: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
700a0766: f00c f89b    	bl	0x700ac8a0 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xc136
700a076a: 900a         	str	r0, [sp, #0x28]
;             } else {
700a076c: e00d         	b	0x700a078a <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #0x1a
700a076e: a802         	add	r0, sp, #0x8
;                 r = Sciclient_rmIrqGetRoute(&cfg);
700a0770: f7fc fabe    	bl	0x7009ccf0 <Sciclient_rmIrqGetRoute> @ imm = #-0x3a84
700a0774: 900a         	str	r0, [sp, #0x28]
;                 if (r == SystemP_SUCCESS) {
700a0776: 980a         	ldr	r0, [sp, #0x28]
700a0778: b930         	cbnz	r0, 0x700a0788 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #0xc
700a077a: e7ff         	b	0x700a077c <Sciclient_rmClearInterruptRoute+0x12c> @ imm = #-0x2
700a077c: a802         	add	r0, sp, #0x8
700a077e: 2100         	movs	r1, #0x0
;                     r = Sciclient_rmIrqDeleteRoute(&cfg, false);
700a0780: f000 f9ce    	bl	0x700a0b20 <Sciclient_rmIrqDeleteRoute> @ imm = #0x39c
700a0784: 900a         	str	r0, [sp, #0x28]
;                 }
700a0786: e7ff         	b	0x700a0788 <Sciclient_rmClearInterruptRoute+0x138> @ imm = #-0x2
700a0788: e7ff         	b	0x700a078a <Sciclient_rmClearInterruptRoute+0x13a> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a078a: e029         	b	0x700a07e0 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #0x52
700a078c: 9802         	ldr	r0, [sp, #0x8]
700a078e: f00b f867    	bl	0x700ab860 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xb0ce
;                 true) ||
700a0792: b928         	cbnz	r0, 0x700a07a0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #0xa
700a0794: e7ff         	b	0x700a0796 <Sciclient_rmClearInterruptRoute+0x146> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
700a0796: 9802         	ldr	r0, [sp, #0x8]
700a0798: f00b f8d2    	bl	0x700ab940 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xb1a4
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a079c: b128         	cbz	r0, 0x700a07aa <Sciclient_rmClearInterruptRoute+0x15a> @ imm = #0xa
700a079e: e7ff         	b	0x700a07a0 <Sciclient_rmClearInterruptRoute+0x150> @ imm = #-0x2
700a07a0: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintDelete(&cfg);
700a07a2: f002 fb35    	bl	0x700a2e10 <Sciclient_rmIrqVintDelete> @ imm = #0x266a
700a07a6: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
700a07a8: e019         	b	0x700a07de <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #0x32
700a07aa: 9802         	ldr	r0, [sp, #0x8]
700a07ac: f00b f938    	bl	0x700aba20 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xb270
700a07b0: b128         	cbz	r0, 0x700a07be <Sciclient_rmClearInterruptRoute+0x16e> @ imm = #0xa
700a07b2: e7ff         	b	0x700a07b4 <Sciclient_rmClearInterruptRoute+0x164> @ imm = #-0x2
700a07b4: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqUnmappedVintRouteDelete(&cfg);
700a07b6: f00c f873    	bl	0x700ac8a0 <Sciclient_rmIrqUnmappedVintRouteDelete> @ imm = #0xc0e6
700a07ba: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
700a07bc: e00e         	b	0x700a07dc <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #0x1c
700a07be: 9802         	ldr	r0, [sp, #0x8]
700a07c0: f00b f8f6    	bl	0x700ab9b0 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xb1ec
700a07c4: b128         	cbz	r0, 0x700a07d2 <Sciclient_rmClearInterruptRoute+0x182> @ imm = #0xa
700a07c6: e7ff         	b	0x700a07c8 <Sciclient_rmClearInterruptRoute+0x178> @ imm = #-0x2
700a07c8: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqClearOesRegister(&cfg);
700a07ca: f00d fc19    	bl	0x700ae000 <Sciclient_rmIrqClearOesRegister> @ imm = #0xd832
700a07ce: 900a         	str	r0, [sp, #0x28]
;         } else {
700a07d0: e003         	b	0x700a07da <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #0x6
700a07d2: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a07d6: 900a         	str	r0, [sp, #0x28]
700a07d8: e7ff         	b	0x700a07da <Sciclient_rmClearInterruptRoute+0x18a> @ imm = #-0x2
700a07da: e7ff         	b	0x700a07dc <Sciclient_rmClearInterruptRoute+0x18c> @ imm = #-0x2
700a07dc: e7ff         	b	0x700a07de <Sciclient_rmClearInterruptRoute+0x18e> @ imm = #-0x2
700a07de: e7ff         	b	0x700a07e0 <Sciclient_rmClearInterruptRoute+0x190> @ imm = #-0x2
;     }
700a07e0: e7ff         	b	0x700a07e2 <Sciclient_rmClearInterruptRoute+0x192> @ imm = #-0x2
;     return r;
700a07e2: 980a         	ldr	r0, [sp, #0x28]
700a07e4: b00e         	add	sp, #0x38
700a07e6: bd80         	pop	{r7, pc}
		...

700a07f0 <Udma_chConfigTx>:
; {
700a07f0: b580         	push	{r7, lr}
700a07f2: b090         	sub	sp, #0x40
700a07f4: 900f         	str	r0, [sp, #0x3c]
700a07f6: 910e         	str	r1, [sp, #0x38]
700a07f8: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
700a07fa: 900d         	str	r0, [sp, #0x34]
;     Udma_ChHandleInt        chHandleInt = (Udma_ChHandleInt) chHandle;
700a07fc: 980f         	ldr	r0, [sp, #0x3c]
700a07fe: 900b         	str	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
700a0800: 980b         	ldr	r0, [sp, #0x2c]
700a0802: b178         	cbz	r0, 0x700a0824 <Udma_chConfigTx+0x34> @ imm = #0x1e
700a0804: e7ff         	b	0x700a0806 <Udma_chConfigTx+0x16> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
700a0806: 980b         	ldr	r0, [sp, #0x2c]
700a0808: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a080c: f64a 31cd    	movw	r1, #0xabcd
700a0810: f6ca 31dc    	movt	r1, #0xabdc
700a0814: 4288         	cmp	r0, r1
700a0816: d105         	bne	0x700a0824 <Udma_chConfigTx+0x34> @ imm = #0xa
700a0818: e7ff         	b	0x700a081a <Udma_chConfigTx+0x2a> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_TX) != UDMA_CH_FLAG_TX))
700a081a: 980b         	ldr	r0, [sp, #0x2c]
;     if((NULL_PTR == chHandleInt) ||
700a081c: 7800         	ldrb	r0, [r0]
700a081e: 07c0         	lsls	r0, r0, #0x1f
700a0820: b920         	cbnz	r0, 0x700a082c <Udma_chConfigTx+0x3c> @ imm = #0x8
700a0822: e7ff         	b	0x700a0824 <Udma_chConfigTx+0x34> @ imm = #-0x2
700a0824: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a0828: 900d         	str	r0, [sp, #0x34]
;     }
700a082a: e7ff         	b	0x700a082c <Udma_chConfigTx+0x3c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a082c: 980d         	ldr	r0, [sp, #0x34]
700a082e: b9a8         	cbnz	r0, 0x700a085c <Udma_chConfigTx+0x6c> @ imm = #0x2a
700a0830: e7ff         	b	0x700a0832 <Udma_chConfigTx+0x42> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a0832: 980b         	ldr	r0, [sp, #0x2c]
700a0834: 6e80         	ldr	r0, [r0, #0x68]
700a0836: 900c         	str	r0, [sp, #0x30]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a0838: 980c         	ldr	r0, [sp, #0x30]
700a083a: b150         	cbz	r0, 0x700a0852 <Udma_chConfigTx+0x62> @ imm = #0x14
700a083c: e7ff         	b	0x700a083e <Udma_chConfigTx+0x4e> @ imm = #-0x2
700a083e: 980c         	ldr	r0, [sp, #0x30]
700a0840: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a0844: f64a 31cd    	movw	r1, #0xabcd
700a0848: f6ca 31dc    	movt	r1, #0xabdc
700a084c: 4288         	cmp	r0, r1
700a084e: d004         	beq	0x700a085a <Udma_chConfigTx+0x6a> @ imm = #0x8
700a0850: e7ff         	b	0x700a0852 <Udma_chConfigTx+0x62> @ imm = #-0x2
700a0852: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a0856: 900d         	str	r0, [sp, #0x34]
;         }
700a0858: e7ff         	b	0x700a085a <Udma_chConfigTx+0x6a> @ imm = #-0x2
;     }
700a085a: e7ff         	b	0x700a085c <Udma_chConfigTx+0x6c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a085c: 980d         	ldr	r0, [sp, #0x34]
700a085e: 2800         	cmp	r0, #0x0
700a0860: f040 808e    	bne.w	0x700a0980 <Udma_chConfigTx+0x190> @ imm = #0x11c
700a0864: e7ff         	b	0x700a0866 <Udma_chConfigTx+0x76> @ imm = #-0x2
700a0866: f647 70ff    	movw	r0, #0x7fff
;         rmUdmaTxReq.valid_params        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERR_VALID |
700a086a: 9004         	str	r0, [sp, #0x10]
;         rmUdmaTxReq.nav_id              = drvHandle->devIdUdma;
700a086c: 980c         	ldr	r0, [sp, #0x30]
700a086e: f8b0 00e2    	ldrh.w	r0, [r0, #0xe2]
700a0872: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         rmUdmaTxReq.index               = (uint16_t)chHandleInt->txChNum;
700a0876: 980b         	ldr	r0, [sp, #0x2c]
700a0878: 6ec0         	ldr	r0, [r0, #0x6c]
700a087a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         rmUdmaTxReq.tx_pause_on_err     = txPrms->pauseOnError;
700a087e: 980e         	ldr	r0, [sp, #0x38]
700a0880: 7800         	ldrb	r0, [r0]
700a0882: f88d 0018    	strb.w	r0, [sp, #0x18]
;         rmUdmaTxReq.tx_filt_einfo       = txPrms->filterEinfo;
700a0886: 980e         	ldr	r0, [sp, #0x38]
700a0888: 7840         	ldrb	r0, [r0, #0x1]
700a088a: f88d 0019    	strb.w	r0, [sp, #0x19]
;         rmUdmaTxReq.tx_filt_pswords     = txPrms->filterPsWords;
700a088e: 980e         	ldr	r0, [sp, #0x38]
700a0890: 7880         	ldrb	r0, [r0, #0x2]
700a0892: f88d 001a    	strb.w	r0, [sp, #0x1a]
;         rmUdmaTxReq.tx_atype            = txPrms->addrType;
700a0896: 980e         	ldr	r0, [sp, #0x38]
700a0898: 78c0         	ldrb	r0, [r0, #0x3]
700a089a: f88d 001b    	strb.w	r0, [sp, #0x1b]
;         rmUdmaTxReq.tx_chan_type        = txPrms->chanType;
700a089e: 980e         	ldr	r0, [sp, #0x38]
700a08a0: 7900         	ldrb	r0, [r0, #0x4]
700a08a2: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         rmUdmaTxReq.tx_fetch_size       = txPrms->fetchWordSize;
700a08a6: 980e         	ldr	r0, [sp, #0x38]
700a08a8: 88c0         	ldrh	r0, [r0, #0x6]
700a08aa: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;         rmUdmaTxReq.tx_priority         = txPrms->busPriority;
700a08ae: 980e         	ldr	r0, [sp, #0x38]
700a08b0: 7a00         	ldrb	r0, [r0, #0x8]
700a08b2: f88d 0023    	strb.w	r0, [sp, #0x23]
;         rmUdmaTxReq.tx_qos              = txPrms->busQos;
700a08b6: 980e         	ldr	r0, [sp, #0x38]
700a08b8: 7a40         	ldrb	r0, [r0, #0x9]
700a08ba: f88d 0024    	strb.w	r0, [sp, #0x24]
;         rmUdmaTxReq.tx_orderid          = txPrms->busOrderId;
700a08be: 980e         	ldr	r0, [sp, #0x38]
700a08c0: 7a80         	ldrb	r0, [r0, #0xa]
700a08c2: f88d 0025    	strb.w	r0, [sp, #0x25]
;         rmUdmaTxReq.fdepth              = txPrms->fifoDepth;
700a08c6: 980e         	ldr	r0, [sp, #0x38]
700a08c8: 89c0         	ldrh	r0, [r0, #0xe]
700a08ca: f8ad 0026    	strh.w	r0, [sp, #0x26]
;         rmUdmaTxReq.tx_burst_size       = txPrms->burstSize;
700a08ce: 980e         	ldr	r0, [sp, #0x38]
700a08d0: 7c00         	ldrb	r0, [r0, #0x10]
700a08d2: f88d 0029    	strb.w	r0, [sp, #0x29]
;         rmUdmaTxReq.tx_sched_priority   = txPrms->dmaPriority;
700a08d6: 980e         	ldr	r0, [sp, #0x38]
700a08d8: 7ac0         	ldrb	r0, [r0, #0xb]
700a08da: f88d 0028    	strb.w	r0, [sp, #0x28]
;         rmUdmaTxReq.tx_credit_count     = txPrms->txCredit;
700a08de: 980e         	ldr	r0, [sp, #0x38]
700a08e0: 7b00         	ldrb	r0, [r0, #0xc]
700a08e2: f88d 0020    	strb.w	r0, [sp, #0x20]
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a08e6: 980c         	ldr	r0, [sp, #0x30]
700a08e8: 6800         	ldr	r0, [r0]
700a08ea: 2801         	cmp	r0, #0x1
700a08ec: d11d         	bne	0x700a092a <Udma_chConfigTx+0x13a> @ imm = #0x3a
700a08ee: e7ff         	b	0x700a08f0 <Udma_chConfigTx+0x100> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a08f0: 980b         	ldr	r0, [sp, #0x2c]
700a08f2: 7800         	ldrb	r0, [r0]
700a08f4: 0740         	lsls	r0, r0, #0x1d
700a08f6: 2800         	cmp	r0, #0x0
700a08f8: d508         	bpl	0x700a090c <Udma_chConfigTx+0x11c> @ imm = #0x10
700a08fa: e7ff         	b	0x700a08fc <Udma_chConfigTx+0x10c> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
700a08fc: 9804         	ldr	r0, [sp, #0x10]
700a08fe: f440 3080    	orr	r0, r0, #0x10000
700a0902: 9004         	str	r0, [sp, #0x10]
700a0904: 2001         	movs	r0, #0x1
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_BLK_CPY;
700a0906: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
700a090a: e00d         	b	0x700a0928 <Udma_chConfigTx+0x138> @ imm = #0x1a
;             else if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a090c: 980b         	ldr	r0, [sp, #0x2c]
700a090e: 7800         	ldrb	r0, [r0]
700a0910: 07c0         	lsls	r0, r0, #0x1f
700a0912: b140         	cbz	r0, 0x700a0926 <Udma_chConfigTx+0x136> @ imm = #0x10
700a0914: e7ff         	b	0x700a0916 <Udma_chConfigTx+0x126> @ imm = #-0x2
;                 rmUdmaTxReq.valid_params    |= TISCI_MSG_VALUE_RM_UDMAP_EXTENDED_CH_TYPE_VALID;
700a0916: 9804         	ldr	r0, [sp, #0x10]
700a0918: f440 3080    	orr	r0, r0, #0x10000
700a091c: 9004         	str	r0, [sp, #0x10]
700a091e: 2000         	movs	r0, #0x0
;                 rmUdmaTxReq.extended_ch_type = UDMA_DMSC_EXTENDED_CH_TYPE_BCDMA_SPLIT_TR_TX;
700a0920: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             }
700a0924: e7ff         	b	0x700a0926 <Udma_chConfigTx+0x136> @ imm = #-0x2
700a0926: e7ff         	b	0x700a0928 <Udma_chConfigTx+0x138> @ imm = #-0x2
;         }
700a0928: e7ff         	b	0x700a092a <Udma_chConfigTx+0x13a> @ imm = #-0x2
;         if(NULL_PTR != chHandleInt->tdCqRing)
700a092a: 980b         	ldr	r0, [sp, #0x2c]
700a092c: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a0930: b158         	cbz	r0, 0x700a094a <Udma_chConfigTx+0x15a> @ imm = #0x16
700a0932: e7ff         	b	0x700a0934 <Udma_chConfigTx+0x144> @ imm = #-0x2
;             rmUdmaTxReq.txcq_qnum       = chHandleInt->tdCqRing->ringNum;
700a0934: 980b         	ldr	r0, [sp, #0x2c]
700a0936: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a093a: 8880         	ldrh	r0, [r0, #0x4]
700a093c: f8ad 0021    	strh.w	r0, [sp, #0x21]
;             rmUdmaTxReq.tx_supr_tdpkt   = txPrms->supressTdCqPkt;
700a0940: 980e         	ldr	r0, [sp, #0x38]
700a0942: 7c40         	ldrb	r0, [r0, #0x11]
700a0944: f88d 001d    	strb.w	r0, [sp, #0x1d]
;         }
700a0948: e007         	b	0x700a095a <Udma_chConfigTx+0x16a> @ imm = #0xe
700a094a: f64f 70ff    	movw	r0, #0xffff
;             rmUdmaTxReq.txcq_qnum       = UDMA_RING_INVALID;
700a094e: f8ad 0021    	strh.w	r0, [sp, #0x21]
700a0952: 2001         	movs	r0, #0x1
;             rmUdmaTxReq.tx_supr_tdpkt   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_ENABLED;
700a0954: f88d 001d    	strb.w	r0, [sp, #0x1d]
700a0958: e7ff         	b	0x700a095a <Udma_chConfigTx+0x16a> @ imm = #-0x2
700a095a: a802         	add	r0, sp, #0x8
700a095c: 4669         	mov	r1, sp
700a095e: f04f 32ff    	mov.w	r2, #0xffffffff
;         retVal = Sciclient_rmUdmapTxChCfg(
700a0962: f00c f88d    	bl	0x700aca80 <Sciclient_rmUdmapTxChCfg> @ imm = #0xc11a
700a0966: 900d         	str	r0, [sp, #0x34]
;         if(CSL_PASS != retVal)
700a0968: 980d         	ldr	r0, [sp, #0x34]
700a096a: b108         	cbz	r0, 0x700a0970 <Udma_chConfigTx+0x180> @ imm = #0x2
700a096c: e7ff         	b	0x700a096e <Udma_chConfigTx+0x17e> @ imm = #-0x2
;         }
700a096e: e7ff         	b	0x700a0970 <Udma_chConfigTx+0x180> @ imm = #-0x2
;         (void) memcpy(&chHandleInt->txPrms, txPrms, sizeof(chHandleInt->txPrms));
700a0970: 980b         	ldr	r0, [sp, #0x2c]
700a0972: f500 70f2    	add.w	r0, r0, #0x1e4
700a0976: 990e         	ldr	r1, [sp, #0x38]
700a0978: 2212         	movs	r2, #0x12
700a097a: f7f9 ebb0    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0x68a0
;     }
700a097e: e7ff         	b	0x700a0980 <Udma_chConfigTx+0x190> @ imm = #-0x2
;     return (retVal);
700a0980: 980d         	ldr	r0, [sp, #0x34]
700a0982: b010         	add	sp, #0x40
700a0984: bd80         	pop	{r7, pc}
		...
700a098e: 0000         	movs	r0, r0

700a0990 <ClockP_init>:
; {
700a0990: b580         	push	{r7, lr}
700a0992: b096         	sub	sp, #0x58
;     DebugP_assert( gClockConfig.timerInputPreScaler != 0U);
700a0994: f642 1000    	movw	r0, #0x2900
700a0998: f2c7 000b    	movt	r0, #0x700b
700a099c: 9009         	str	r0, [sp, #0x24]
700a099e: 68c0         	ldr	r0, [r0, #0xc]
700a09a0: 2800         	cmp	r0, #0x0
700a09a2: bf18         	it	ne
700a09a4: 2001         	movne	r0, #0x1
700a09a6: f641 3145    	movw	r1, #0x1b45
700a09aa: f2c7 010b    	movt	r1, #0x700b
700a09ae: 466a         	mov	r2, sp
700a09b0: 6011         	str	r1, [r2]
700a09b2: f641 51f9    	movw	r1, #0x1df9
700a09b6: f2c7 010b    	movt	r1, #0x700b
700a09ba: 9107         	str	r1, [sp, #0x1c]
700a09bc: f242 02fb    	movw	r2, #0x20fb
700a09c0: f2c7 020b    	movt	r2, #0x700b
700a09c4: 9208         	str	r2, [sp, #0x20]
700a09c6: 2334         	movs	r3, #0x34
700a09c8: f00a f95a    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xa2b4
700a09cc: 9907         	ldr	r1, [sp, #0x1c]
700a09ce: 9a08         	ldr	r2, [sp, #0x20]
700a09d0: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerInputClkHz != 0U);
700a09d2: 6880         	ldr	r0, [r0, #0x8]
700a09d4: 2800         	cmp	r0, #0x0
700a09d6: bf18         	it	ne
700a09d8: 2001         	movne	r0, #0x1
700a09da: f641 33b8    	movw	r3, #0x1bb8
700a09de: f2c7 030b    	movt	r3, #0x700b
700a09e2: 46ec         	mov	r12, sp
700a09e4: f8cc 3000    	str.w	r3, [r12]
700a09e8: 2335         	movs	r3, #0x35
700a09ea: f00a f949    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xa292
700a09ee: 9907         	ldr	r1, [sp, #0x1c]
700a09f0: 9a08         	ldr	r2, [sp, #0x20]
700a09f2: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.usecPerTick != 0U);
700a09f4: 6900         	ldr	r0, [r0, #0x10]
700a09f6: 2800         	cmp	r0, #0x0
700a09f8: bf18         	it	ne
700a09fa: 2001         	movne	r0, #0x1
700a09fc: f641 5328    	movw	r3, #0x1d28
700a0a00: f2c7 030b    	movt	r3, #0x700b
700a0a04: 46ec         	mov	r12, sp
700a0a06: f8cc 3000    	str.w	r3, [r12]
700a0a0a: 2336         	movs	r3, #0x36
700a0a0c: f00a f938    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xa270
700a0a10: 9907         	ldr	r1, [sp, #0x1c]
700a0a12: 9a08         	ldr	r2, [sp, #0x20]
700a0a14: 9809         	ldr	r0, [sp, #0x24]
;     DebugP_assert( gClockConfig.timerBaseAddr != 0U);
700a0a16: 6800         	ldr	r0, [r0]
700a0a18: 2800         	cmp	r0, #0x0
700a0a1a: bf18         	it	ne
700a0a1c: 2001         	movne	r0, #0x1
700a0a1e: f641 4385    	movw	r3, #0x1c85
700a0a22: f2c7 030b    	movt	r3, #0x700b
700a0a26: 46ec         	mov	r12, sp
700a0a28: f8cc 3000    	str.w	r3, [r12]
700a0a2c: 2337         	movs	r3, #0x37
700a0a2e: f00a f927    	bl	0x700aac80 <_DebugP_assert> @ imm = #0xa24e
700a0a32: 9809         	ldr	r0, [sp, #0x24]
;     gClockCtrl.ticks = 0;
700a0a34: f245 1290    	movw	r2, #0x5190
700a0a38: f2c7 0208    	movt	r2, #0x7008
700a0a3c: 2100         	movs	r1, #0x0
700a0a3e: 6051         	str	r1, [r2, #0x4]
700a0a40: 6011         	str	r1, [r2]
;     gClockCtrl.usecPerTick = gClockConfig.usecPerTick;
700a0a42: 6903         	ldr	r3, [r0, #0x10]
700a0a44: 6093         	str	r3, [r2, #0x8]
;     gClockCtrl.timerBaseAddr = gClockConfig.timerBaseAddr;
700a0a46: 6800         	ldr	r0, [r0]
700a0a48: 62d0         	str	r0, [r2, #0x2c]
700a0a4a: f244 2040    	movw	r0, #0x4240
700a0a4e: f2c0 000f    	movt	r0, #0xf
;     if( pdMS_TO_TICKS( TIME_IN_MILLI_SECONDS ) != ClockP_usecToTicks( TIME_IN_MICRO_SECONDS ) )
700a0a52: f00e fc65    	bl	0x700af320 <ClockP_usecToTicks> @ imm = #0xe8ca
700a0a56: f5b0 7f7a    	cmp.w	r0, #0x3e8
700a0a5a: d01d         	beq	0x700a0a98 <ClockP_init+0x108> @ imm = #0x3a
700a0a5c: e7ff         	b	0x700a0a5e <ClockP_init+0xce> @ imm = #-0x2
;         DebugP_logWarn("FreeRTOS configTICK_RATE_HZ (%d), does not match ClockP tick rate Hz (%d)\r\n",
700a0a5e: f642 1000    	movw	r0, #0x2900
700a0a62: f2c7 000b    	movt	r0, #0x700b
700a0a66: 6901         	ldr	r1, [r0, #0x10]
700a0a68: f244 2040    	movw	r0, #0x4240
700a0a6c: f2c0 000f    	movt	r0, #0xf
700a0a70: fbb0 f0f1    	udiv	r0, r0, r1
700a0a74: 4669         	mov	r1, sp
700a0a76: 6048         	str	r0, [r1, #0x4]
700a0a78: f44f 707a    	mov.w	r0, #0x3e8
700a0a7c: 6008         	str	r0, [r1]
700a0a7e: f641 016c    	movw	r1, #0x186c
700a0a82: f2c7 010b    	movt	r1, #0x700b
700a0a86: f242 02fb    	movw	r2, #0x20fb
700a0a8a: f2c7 020b    	movt	r2, #0x700b
700a0a8e: 2004         	movs	r0, #0x4
700a0a90: 2346         	movs	r3, #0x46
700a0a92: f009 f93d    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0x927a
;     }
700a0a96: e7ff         	b	0x700a0a98 <ClockP_init+0x108> @ imm = #-0x2
700a0a98: a80f         	add	r0, sp, #0x3c
;     TimerP_Params_init(&timerParams);
700a0a9a: 9002         	str	r0, [sp, #0x8]
700a0a9c: f00d fd50    	bl	0x700ae540 <TimerP_Params_init> @ imm = #0xdaa0
700a0aa0: 9902         	ldr	r1, [sp, #0x8]
;     timerParams.inputPreScaler    = gClockConfig.timerInputPreScaler;
700a0aa2: f642 1000    	movw	r0, #0x2900
700a0aa6: f2c7 000b    	movt	r0, #0x700b
700a0aaa: 9004         	str	r0, [sp, #0x10]
700a0aac: 68c2         	ldr	r2, [r0, #0xc]
700a0aae: 920f         	str	r2, [sp, #0x3c]
;     timerParams.inputClkHz        = gClockConfig.timerInputClkHz;
700a0ab0: 6882         	ldr	r2, [r0, #0x8]
700a0ab2: 9210         	str	r2, [sp, #0x40]
;     timerParams.periodInUsec      = gClockConfig.usecPerTick;
700a0ab4: 6900         	ldr	r0, [r0, #0x10]
700a0ab6: 9011         	str	r0, [sp, #0x44]
700a0ab8: 2000         	movs	r0, #0x0
;     timerParams.oneshotMode       = 0;
700a0aba: 9003         	str	r0, [sp, #0xc]
700a0abc: 9013         	str	r0, [sp, #0x4c]
700a0abe: 2001         	movs	r0, #0x1
;     timerParams.enableOverflowInt = 1;
700a0ac0: 9014         	str	r0, [sp, #0x50]
;     TimerP_setup(gClockCtrl.timerBaseAddr, &timerParams);
700a0ac2: f245 1090    	movw	r0, #0x5190
700a0ac6: f2c7 0008    	movt	r0, #0x7008
700a0aca: 9006         	str	r0, [sp, #0x18]
700a0acc: 6ac0         	ldr	r0, [r0, #0x2c]
700a0ace: f7fd f9a7    	bl	0x7009de20 <TimerP_setup> @ imm = #-0x2cb2
700a0ad2: 9806         	ldr	r0, [sp, #0x18]
;     gClockCtrl.timerReloadCount = TimerP_getReloadCount(gClockCtrl.timerBaseAddr);
700a0ad4: 6ac0         	ldr	r0, [r0, #0x2c]
700a0ad6: f00e ff9b    	bl	0x700afa10 <TimerP_getReloadCount> @ imm = #0xef36
700a0ada: 9906         	ldr	r1, [sp, #0x18]
700a0adc: 6308         	str	r0, [r1, #0x30]
700a0ade: a80a         	add	r0, sp, #0x28
;     HwiP_Params_init(&timerHwiParams);
700a0ae0: 9005         	str	r0, [sp, #0x14]
700a0ae2: f00f fa35    	bl	0x700aff50 <HwiP_Params_init> @ imm = #0xf46a
700a0ae6: 9b03         	ldr	r3, [sp, #0xc]
700a0ae8: 9a04         	ldr	r2, [sp, #0x10]
700a0aea: 9905         	ldr	r1, [sp, #0x14]
700a0aec: 9806         	ldr	r0, [sp, #0x18]
;     timerHwiParams.intNum = gClockConfig.timerHwiIntNum;
700a0aee: f8d2 c004    	ldr.w	r12, [r2, #0x4]
700a0af2: f8cd c028    	str.w	r12, [sp, #0x28]
;     timerHwiParams.callback = ClockP_timerTickIsr;
700a0af6: f24e 6c71    	movw	r12, #0xe671
700a0afa: f2c7 0c0a    	movt	r12, #0x700a
700a0afe: f8cd c02c    	str.w	r12, [sp, #0x2c]
;     timerHwiParams.isPulse = 0;
700a0b02: f88d 3038    	strb.w	r3, [sp, #0x38]
;     timerHwiParams.priority = gClockConfig.intrPriority;
700a0b06: 7d12         	ldrb	r2, [r2, #0x14]
700a0b08: f88d 2036    	strb.w	r2, [sp, #0x36]
;     (void)HwiP_construct(&gClockCtrl.timerHwiObj, &timerHwiParams);
700a0b0c: 300c         	adds	r0, #0xc
700a0b0e: f00f fa37    	bl	0x700aff80 <HwiP_construct> @ imm = #0xf46e
;     TimerP_start(gClockCtrl.timerBaseAddr);
700a0b12: 9806         	ldr	r0, [sp, #0x18]
700a0b14: 6ac0         	ldr	r0, [r0, #0x2c]
700a0b16: f00e fde3    	bl	0x700af6e0 <TimerP_start> @ imm = #0xebc6
; }
700a0b1a: b016         	add	sp, #0x58
700a0b1c: bd80         	pop	{r7, pc}
700a0b1e: 0000         	movs	r0, r0

700a0b20 <Sciclient_rmIrqDeleteRoute>:
; {
700a0b20: b580         	push	{r7, lr}
700a0b22: b090         	sub	sp, #0x40
700a0b24: 900f         	str	r0, [sp, #0x3c]
700a0b26: f88d 103b    	strb.w	r1, [sp, #0x3b]
700a0b2a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a0b2c: 900d         	str	r0, [sp, #0x34]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a0b2e: 9002         	str	r0, [sp, #0x8]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
700a0b30: 9001         	str	r0, [sp, #0x4]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0b32: f8ad 0032    	strh.w	r0, [sp, #0x32]
700a0b36: e7ff         	b	0x700a0b38 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x2
700a0b38: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0b3c: 9000         	str	r0, [sp]
700a0b3e: f00f f89f    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0xf13e
700a0b42: 4601         	mov	r1, r0
700a0b44: 9800         	ldr	r0, [sp]
700a0b46: 4288         	cmp	r0, r1
700a0b48: f280 80ac    	bge.w	0x700a0ca4 <Sciclient_rmIrqDeleteRoute+0x184> @ imm = #0x158
700a0b4c: e7ff         	b	0x700a0b4e <Sciclient_rmIrqDeleteRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a0b4e: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0b52: f00e fc65    	bl	0x700af420 <Sciclient_rmPsGetIrqNode> @ imm = #0xe8ca
700a0b56: 900b         	str	r0, [sp, #0x2c]
;         cur_inp = Sciclient_rmPsGetInp(i);
700a0b58: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0b5c: f00d f890    	bl	0x700adc80 <Sciclient_rmPsGetInp> @ imm = #0xd120
700a0b60: f8ad 002a    	strh.w	r0, [sp, #0x2a]
;         cur_outp = Sciclient_rmPsGetOutp(i);
700a0b64: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0b68: f00d f8aa    	bl	0x700adcc0 <Sciclient_rmPsGetOutp> @ imm = #0xd154
700a0b6c: f8ad 0028    	strh.w	r0, [sp, #0x28]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a0b70: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0b74: 2800         	cmp	r0, #0x0
700a0b76: d156         	bne	0x700a0c26 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0xac
700a0b78: e7ff         	b	0x700a0b7a <Sciclient_rmIrqDeleteRoute+0x5a> @ imm = #-0x2
700a0b7a: 980b         	ldr	r0, [sp, #0x2c]
700a0b7c: 8800         	ldrh	r0, [r0]
700a0b7e: f00d fec7    	bl	0x700ae910 <Sciclient_rmIaIsIa> @ imm = #0xdd8e
700a0b82: 2800         	cmp	r0, #0x0
700a0b84: d04f         	beq	0x700a0c26 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x9e
700a0b86: e7ff         	b	0x700a0b88 <Sciclient_rmIrqDeleteRoute+0x68> @ imm = #-0x2
;             (unmap_vint == true)) {
700a0b88: f89d 003b    	ldrb.w	r0, [sp, #0x3b]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a0b8c: 07c0         	lsls	r0, r0, #0x1f
700a0b8e: 2800         	cmp	r0, #0x0
700a0b90: d049         	beq	0x700a0c26 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #0x92
700a0b92: e7ff         	b	0x700a0b94 <Sciclient_rmIrqDeleteRoute+0x74> @ imm = #-0x2
700a0b94: 203c         	movs	r0, #0x3c
700a0b96: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a0b9a: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
700a0b9c: 980f         	ldr	r0, [sp, #0x3c]
700a0b9e: 7900         	ldrb	r0, [r0, #0x4]
700a0ba0: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cfg->s_id;
700a0ba4: 980f         	ldr	r0, [sp, #0x3c]
700a0ba6: 88c0         	ldrh	r0, [r0, #0x6]
700a0ba8: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cfg->s_idx;
700a0bac: 980f         	ldr	r0, [sp, #0x3c]
700a0bae: 8900         	ldrh	r0, [r0, #0x8]
700a0bb0: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.ia_id = cfg->s_ia;
700a0bb4: 980f         	ldr	r0, [sp, #0x3c]
700a0bb6: 8a00         	ldrh	r0, [r0, #0x10]
700a0bb8: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.vint = cur_outp;
700a0bbc: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a0bc0: f8ad 0022    	strh.w	r0, [sp, #0x22]
;             req.global_event = cur_inp;
700a0bc4: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
700a0bc8: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint_status_bit_index = cfg->vint_sb;
700a0bcc: 980f         	ldr	r0, [sp, #0x3c]
700a0bce: 7d00         	ldrb	r0, [r0, #0x14]
700a0bd0: f88d 0026    	strb.w	r0, [sp, #0x26]
700a0bd4: a803         	add	r0, sp, #0xc
700a0bd6: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
700a0bda: f00c f801    	bl	0x700acbe0 <Sciclient_rmIrqReleaseRaw> @ imm = #0xc002
700a0bde: 900d         	str	r0, [sp, #0x34]
;             if (r == SystemP_SUCCESS) {
700a0be0: 980d         	ldr	r0, [sp, #0x34]
700a0be2: b9f8         	cbnz	r0, 0x700a0c24 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #0x3e
700a0be4: e7ff         	b	0x700a0be6 <Sciclient_rmIrqDeleteRoute+0xc6> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
700a0be6: 980b         	ldr	r0, [sp, #0x2c]
700a0be8: 8800         	ldrh	r0, [r0]
700a0bea: f00b fca9    	bl	0x700ac540 <Sciclient_rmIaGetInst> @ imm = #0xb952
700a0bee: 9002         	str	r0, [sp, #0x8]
;                 if (ia_inst != NULL) {
700a0bf0: 9802         	ldr	r0, [sp, #0x8]
700a0bf2: b1b0         	cbz	r0, 0x700a0c22 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #0x2c
700a0bf4: e7ff         	b	0x700a0bf6 <Sciclient_rmIrqDeleteRoute+0xd6> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]--;
700a0bf6: 9802         	ldr	r0, [sp, #0x8]
700a0bf8: 6901         	ldr	r1, [r0, #0x10]
700a0bfa: f8bd 2028    	ldrh.w	r2, [sp, #0x28]
700a0bfe: 5c88         	ldrb	r0, [r1, r2]
700a0c00: 3801         	subs	r0, #0x1
700a0c02: 5488         	strb	r0, [r1, r2]
;                     if (ia_inst->v0_b0_evt == cur_inp - ia_inst->sevt_offset) {
700a0c04: 9a02         	ldr	r2, [sp, #0x8]
700a0c06: 8a90         	ldrh	r0, [r2, #0x14]
700a0c08: f8bd 102a    	ldrh.w	r1, [sp, #0x2a]
700a0c0c: 8912         	ldrh	r2, [r2, #0x8]
700a0c0e: 1a89         	subs	r1, r1, r2
700a0c10: 4288         	cmp	r0, r1
700a0c12: d105         	bne	0x700a0c20 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #0xa
700a0c14: e7ff         	b	0x700a0c16 <Sciclient_rmIrqDeleteRoute+0xf6> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
700a0c16: 9902         	ldr	r1, [sp, #0x8]
700a0c18: f64f 70ff    	movw	r0, #0xffff
700a0c1c: 8288         	strh	r0, [r1, #0x14]
;                     }
700a0c1e: e7ff         	b	0x700a0c20 <Sciclient_rmIrqDeleteRoute+0x100> @ imm = #-0x2
;                 }
700a0c20: e7ff         	b	0x700a0c22 <Sciclient_rmIrqDeleteRoute+0x102> @ imm = #-0x2
;             }
700a0c22: e7ff         	b	0x700a0c24 <Sciclient_rmIrqDeleteRoute+0x104> @ imm = #-0x2
;         }
700a0c24: e7ff         	b	0x700a0c26 <Sciclient_rmIrqDeleteRoute+0x106> @ imm = #-0x2
;         if (i > 0u) {
700a0c26: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0c2a: b3a0         	cbz	r0, 0x700a0c96 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #0x68
700a0c2c: e7ff         	b	0x700a0c2e <Sciclient_rmIrqDeleteRoute+0x10e> @ imm = #-0x2
700a0c2e: 2003         	movs	r0, #0x3
700a0c30: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
700a0c34: 9005         	str	r0, [sp, #0x14]
;             req.secondary_host = cfg->host;
700a0c36: 980f         	ldr	r0, [sp, #0x3c]
700a0c38: 7900         	ldrb	r0, [r0, #0x4]
700a0c3a: f88d 0027    	strb.w	r0, [sp, #0x27]
;             req.src_id = cur_n->id;
700a0c3e: 980b         	ldr	r0, [sp, #0x2c]
700a0c40: 8800         	ldrh	r0, [r0]
700a0c42: f8ad 0018    	strh.w	r0, [sp, #0x18]
;             req.src_index = cur_inp;
700a0c46: f8bd 002a    	ldrh.w	r0, [sp, #0x2a]
700a0c4a: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             req.dst_id = cur_n->id;
700a0c4e: 980b         	ldr	r0, [sp, #0x2c]
700a0c50: 8800         	ldrh	r0, [r0]
700a0c52: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.dst_host_irq = cur_outp;
700a0c56: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a0c5a: f8ad 001e    	strh.w	r0, [sp, #0x1e]
700a0c5e: a803         	add	r0, sp, #0xc
700a0c60: f04f 31ff    	mov.w	r1, #0xffffffff
;             r = Sciclient_rmIrqReleaseRaw(&req,
700a0c64: f00b ffbc    	bl	0x700acbe0 <Sciclient_rmIrqReleaseRaw> @ imm = #0xbf78
700a0c68: 900d         	str	r0, [sp, #0x34]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
700a0c6a: 980d         	ldr	r0, [sp, #0x34]
700a0c6c: b990         	cbnz	r0, 0x700a0c94 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x24
700a0c6e: e7ff         	b	0x700a0c70 <Sciclient_rmIrqDeleteRoute+0x150> @ imm = #-0x2
700a0c70: f8bd 0028    	ldrh.w	r0, [sp, #0x28]
700a0c74: b970         	cbnz	r0, 0x700a0c94 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #0x1c
700a0c76: e7ff         	b	0x700a0c78 <Sciclient_rmIrqDeleteRoute+0x158> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
700a0c78: 980b         	ldr	r0, [sp, #0x2c]
700a0c7a: 8800         	ldrh	r0, [r0]
700a0c7c: f00a ff78    	bl	0x700abb70 <Sciclient_rmIrGetInst> @ imm = #0xaef0
700a0c80: 9001         	str	r0, [sp, #0x4]
;                 if (ir_inst != NULL) {
700a0c82: 9801         	ldr	r0, [sp, #0x4]
700a0c84: b128         	cbz	r0, 0x700a0c92 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #0xa
700a0c86: e7ff         	b	0x700a0c88 <Sciclient_rmIrqDeleteRoute+0x168> @ imm = #-0x2
;                     ir_inst->inp0_mapping = SCICLIENT_RM_IR_MAPPING_FREE;
700a0c88: 9901         	ldr	r1, [sp, #0x4]
700a0c8a: f64f 70ff    	movw	r0, #0xffff
700a0c8e: 8188         	strh	r0, [r1, #0xc]
;                 }
700a0c90: e7ff         	b	0x700a0c92 <Sciclient_rmIrqDeleteRoute+0x172> @ imm = #-0x2
;             }
700a0c92: e7ff         	b	0x700a0c94 <Sciclient_rmIrqDeleteRoute+0x174> @ imm = #-0x2
;         }
700a0c94: e7ff         	b	0x700a0c96 <Sciclient_rmIrqDeleteRoute+0x176> @ imm = #-0x2
;     }
700a0c96: e7ff         	b	0x700a0c98 <Sciclient_rmIrqDeleteRoute+0x178> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0c98: f8bd 0032    	ldrh.w	r0, [sp, #0x32]
700a0c9c: 3001         	adds	r0, #0x1
700a0c9e: f8ad 0032    	strh.w	r0, [sp, #0x32]
700a0ca2: e749         	b	0x700a0b38 <Sciclient_rmIrqDeleteRoute+0x18> @ imm = #-0x16e
;     return r;
700a0ca4: 980d         	ldr	r0, [sp, #0x34]
700a0ca6: b010         	add	sp, #0x40
700a0ca8: bd80         	pop	{r7, pc}
700a0caa: 0000         	movs	r0, r0
700a0cac: 0000         	movs	r0, r0
700a0cae: 0000         	movs	r0, r0

700a0cb0 <Sciclient_rmProgramInterruptRoute>:
; {
700a0cb0: b580         	push	{r7, lr}
700a0cb2: b08e         	sub	sp, #0x38
700a0cb4: 900d         	str	r0, [sp, #0x34]
700a0cb6: 910c         	str	r1, [sp, #0x30]
700a0cb8: 920b         	str	r2, [sp, #0x2c]
700a0cba: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a0cbc: 9001         	str	r0, [sp, #0x4]
700a0cbe: 900a         	str	r0, [sp, #0x28]
700a0cc0: f44f 5180    	mov.w	r1, #0x1000
;     uint16_t messageType = TISCI_MSG_RM_IRQ_SET;
700a0cc4: f8ad 1026    	strh.w	r1, [sp, #0x26]
;     memset(&cfg, 0, sizeof(cfg));
700a0cc8: 9008         	str	r0, [sp, #0x20]
700a0cca: 9007         	str	r0, [sp, #0x1c]
700a0ccc: 9006         	str	r0, [sp, #0x18]
700a0cce: 9005         	str	r0, [sp, #0x14]
700a0cd0: 9004         	str	r0, [sp, #0x10]
700a0cd2: 9003         	str	r0, [sp, #0xc]
700a0cd4: 9002         	str	r0, [sp, #0x8]
;     if((req == NULL) || (resp == NULL)) {
700a0cd6: 980d         	ldr	r0, [sp, #0x34]
700a0cd8: b118         	cbz	r0, 0x700a0ce2 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #0x6
700a0cda: e7ff         	b	0x700a0cdc <Sciclient_rmProgramInterruptRoute+0x2c> @ imm = #-0x2
700a0cdc: 980c         	ldr	r0, [sp, #0x30]
700a0cde: b920         	cbnz	r0, 0x700a0cea <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #0x8
700a0ce0: e7ff         	b	0x700a0ce2 <Sciclient_rmProgramInterruptRoute+0x32> @ imm = #-0x2
700a0ce2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a0ce6: 900a         	str	r0, [sp, #0x28]
;     }
700a0ce8: e7ff         	b	0x700a0cea <Sciclient_rmProgramInterruptRoute+0x3a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a0cea: 980a         	ldr	r0, [sp, #0x28]
700a0cec: b968         	cbnz	r0, 0x700a0d0a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0x1a
700a0cee: e7ff         	b	0x700a0cf0 <Sciclient_rmProgramInterruptRoute+0x40> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a0cf0: 980d         	ldr	r0, [sp, #0x34]
700a0cf2: 6880         	ldr	r0, [r0, #0x8]
700a0cf4: f04f 4100    	mov.w	r1, #0x80000000
700a0cf8: f00e f802    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0xe004
;     if (r == SystemP_SUCCESS &&
700a0cfc: b128         	cbz	r0, 0x700a0d0a <Sciclient_rmProgramInterruptRoute+0x5a> @ imm = #0xa
700a0cfe: e7ff         	b	0x700a0d00 <Sciclient_rmProgramInterruptRoute+0x50> @ imm = #-0x2
;         dst_host = req->secondary_host;
700a0d00: 980d         	ldr	r0, [sp, #0x34]
700a0d02: 7ec0         	ldrb	r0, [r0, #0x1b]
700a0d04: f88d 0025    	strb.w	r0, [sp, #0x25]
;     } else {
700a0d08: e00f         	b	0x700a0d2a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #0x1e
;         dst_host = (uint8_t) gSciclientMap[Sciclient_getCurrentContext(messageType)].hostId;
700a0d0a: f8bd 0026    	ldrh.w	r0, [sp, #0x26]
700a0d0e: f006 ff57    	bl	0x700a7bc0 <Sciclient_getCurrentContext> @ imm = #0x6eae
700a0d12: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a0d16: f241 3060    	movw	r0, #0x1360
700a0d1a: f2c7 000b    	movt	r0, #0x700b
700a0d1e: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a0d22: 6840         	ldr	r0, [r0, #0x4]
700a0d24: f88d 0025    	strb.w	r0, [sp, #0x25]
700a0d28: e7ff         	b	0x700a0d2a <Sciclient_rmProgramInterruptRoute+0x7a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS &&
700a0d2a: 980a         	ldr	r0, [sp, #0x28]
700a0d2c: b960         	cbnz	r0, 0x700a0d48 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0x18
700a0d2e: e7ff         	b	0x700a0d30 <Sciclient_rmProgramInterruptRoute+0x80> @ imm = #-0x2
;         Sciclient_rmParamIsValid(req->valid_params,
700a0d30: 980d         	ldr	r0, [sp, #0x34]
700a0d32: 6880         	ldr	r0, [r0, #0x8]
700a0d34: 2104         	movs	r1, #0x4
700a0d36: f00d ffe3    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0xdfc6
;     if (r == SystemP_SUCCESS &&
700a0d3a: b128         	cbz	r0, 0x700a0d48 <Sciclient_rmProgramInterruptRoute+0x98> @ imm = #0xa
700a0d3c: e7ff         	b	0x700a0d3e <Sciclient_rmProgramInterruptRoute+0x8e> @ imm = #-0x2
;         cfg.s_ia = req->ia_id;
700a0d3e: 980d         	ldr	r0, [sp, #0x34]
700a0d40: 8a80         	ldrh	r0, [r0, #0x14]
700a0d42: f8ad 0018    	strh.w	r0, [sp, #0x18]
;     } else {
700a0d46: e003         	b	0x700a0d50 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #0x6
700a0d48: 20ff         	movs	r0, #0xff
;         cfg.s_ia = SCICLIENT_RM_DEV_NONE;
700a0d4a: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a0d4e: e7ff         	b	0x700a0d50 <Sciclient_rmProgramInterruptRoute+0xa0> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a0d50: 980a         	ldr	r0, [sp, #0x28]
700a0d52: 2800         	cmp	r0, #0x0
700a0d54: d16e         	bne	0x700a0e34 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #0xdc
700a0d56: e7ff         	b	0x700a0d58 <Sciclient_rmProgramInterruptRoute+0xa8> @ imm = #-0x2
;         cfg.valid_params = req->valid_params;
700a0d58: 980d         	ldr	r0, [sp, #0x34]
700a0d5a: 6880         	ldr	r0, [r0, #0x8]
700a0d5c: 9002         	str	r0, [sp, #0x8]
;         cfg.host = dst_host;
700a0d5e: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a0d62: f88d 000c    	strb.w	r0, [sp, #0xc]
;         cfg.s_id = req->src_id;
700a0d66: 980d         	ldr	r0, [sp, #0x34]
700a0d68: 8980         	ldrh	r0, [r0, #0xc]
700a0d6a: f8ad 000e    	strh.w	r0, [sp, #0xe]
;         cfg.s_idx = req->src_index;
700a0d6e: 980d         	ldr	r0, [sp, #0x34]
700a0d70: 89c0         	ldrh	r0, [r0, #0xe]
700a0d72: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         cfg.d_id = req->dst_id;
700a0d76: 980d         	ldr	r0, [sp, #0x34]
700a0d78: 8a00         	ldrh	r0, [r0, #0x10]
700a0d7a: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         cfg.d_irq = req->dst_host_irq;
700a0d7e: 980d         	ldr	r0, [sp, #0x34]
700a0d80: 8a40         	ldrh	r0, [r0, #0x12]
700a0d82: f8ad 0014    	strh.w	r0, [sp, #0x14]
;         cfg.global_evt = req->global_event;
700a0d86: 980d         	ldr	r0, [sp, #0x34]
700a0d88: 8b00         	ldrh	r0, [r0, #0x18]
700a0d8a: f8ad 0016    	strh.w	r0, [sp, #0x16]
;         cfg.vint = req->vint;
700a0d8e: 980d         	ldr	r0, [sp, #0x34]
700a0d90: 8ac0         	ldrh	r0, [r0, #0x16]
700a0d92: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         cfg.vint_sb = req->vint_status_bit_index;
700a0d96: 980d         	ldr	r0, [sp, #0x34]
700a0d98: 7e80         	ldrb	r0, [r0, #0x1a]
700a0d9a: f88d 001c    	strb.w	r0, [sp, #0x1c]
;         cfg.set_resp = resp;
700a0d9e: 980c         	ldr	r0, [sp, #0x30]
700a0da0: 9008         	str	r0, [sp, #0x20]
;         if (Sciclient_rmIrqCfgIsDirectNonEvent(cfg.valid_params) == true) {
700a0da2: 9802         	ldr	r0, [sp, #0x8]
700a0da4: f00a fd94    	bl	0x700ab8d0 <Sciclient_rmIrqCfgIsDirectNonEvent> @ imm = #0xab28
700a0da8: b1c8         	cbz	r0, 0x700a0dde <Sciclient_rmProgramInterruptRoute+0x12e> @ imm = #0x32
700a0daa: e7ff         	b	0x700a0dac <Sciclient_rmProgramInterruptRoute+0xfc> @ imm = #-0x2
;             if (Sciclient_rmIaIsIa(cfg.s_id) == true) {
700a0dac: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a0db0: f00d fdae    	bl	0x700ae910 <Sciclient_rmIaIsIa> @ imm = #0xdb5c
700a0db4: b128         	cbz	r0, 0x700a0dc2 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #0xa
700a0db6: e7ff         	b	0x700a0db8 <Sciclient_rmProgramInterruptRoute+0x108> @ imm = #-0x2
;                 cfg.vint = cfg.s_idx;
700a0db8: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a0dbc: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;             }
700a0dc0: e7ff         	b	0x700a0dc2 <Sciclient_rmProgramInterruptRoute+0x112> @ imm = #-0x2
700a0dc2: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqFindRoute(&cfg);
700a0dc4: f7fd fbcc    	bl	0x7009e560 <Sciclient_rmIrqFindRoute> @ imm = #-0x2868
700a0dc8: 900a         	str	r0, [sp, #0x28]
;             if (r == SystemP_SUCCESS) {
700a0dca: 980a         	ldr	r0, [sp, #0x28]
700a0dcc: b930         	cbnz	r0, 0x700a0ddc <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #0xc
700a0dce: e7ff         	b	0x700a0dd0 <Sciclient_rmProgramInterruptRoute+0x120> @ imm = #-0x2
700a0dd0: a802         	add	r0, sp, #0x8
700a0dd2: 2100         	movs	r1, #0x0
;                 r = Sciclient_rmIrqProgramRoute(&cfg, false);
700a0dd4: f000 f8fc    	bl	0x700a0fd0 <Sciclient_rmIrqProgramRoute> @ imm = #0x1f8
700a0dd8: 900a         	str	r0, [sp, #0x28]
;             }
700a0dda: e7ff         	b	0x700a0ddc <Sciclient_rmProgramInterruptRoute+0x12c> @ imm = #-0x2
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a0ddc: e029         	b	0x700a0e32 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #0x52
700a0dde: 9802         	ldr	r0, [sp, #0x8]
700a0de0: f00a fd3e    	bl	0x700ab860 <Sciclient_rmIrqCfgIsDirectEvent> @ imm = #0xaa7c
;                 true) ||
700a0de4: b928         	cbnz	r0, 0x700a0df2 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #0xa
700a0de6: e7ff         	b	0x700a0de8 <Sciclient_rmProgramInterruptRoute+0x138> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg.valid_params) ==
700a0de8: 9802         	ldr	r0, [sp, #0x8]
700a0dea: f00a fda9    	bl	0x700ab940 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0xab52
;         } else if ((Sciclient_rmIrqCfgIsDirectEvent(cfg.valid_params) ==
700a0dee: b128         	cbz	r0, 0x700a0dfc <Sciclient_rmProgramInterruptRoute+0x14c> @ imm = #0xa
700a0df0: e7ff         	b	0x700a0df2 <Sciclient_rmProgramInterruptRoute+0x142> @ imm = #-0x2
700a0df2: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqVintAdd(&cfg);
700a0df4: f003 fc7c    	bl	0x700a46f0 <Sciclient_rmIrqVintAdd> @ imm = #0x38f8
700a0df8: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsUnmappedVintDirectEvent(cfg.valid_params) ==
700a0dfa: e019         	b	0x700a0e30 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #0x32
700a0dfc: 9802         	ldr	r0, [sp, #0x8]
700a0dfe: f00a fe0f    	bl	0x700aba20 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent> @ imm = #0xac1e
700a0e02: b128         	cbz	r0, 0x700a0e10 <Sciclient_rmProgramInterruptRoute+0x160> @ imm = #0xa
700a0e04: e7ff         	b	0x700a0e06 <Sciclient_rmProgramInterruptRoute+0x156> @ imm = #-0x2
700a0e06: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmUnmappedVintRouteCreate(&cfg);
700a0e08: f00c f80a    	bl	0x700ace20 <Sciclient_rmUnmappedVintRouteCreate> @ imm = #0xc014
700a0e0c: 900a         	str	r0, [sp, #0x28]
;         } else if (Sciclient_rmIrqCfgIsOesOnly(cfg.valid_params) == true) {
700a0e0e: e00e         	b	0x700a0e2e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #0x1c
700a0e10: 9802         	ldr	r0, [sp, #0x8]
700a0e12: f00a fdcd    	bl	0x700ab9b0 <Sciclient_rmIrqCfgIsOesOnly> @ imm = #0xab9a
700a0e16: b128         	cbz	r0, 0x700a0e24 <Sciclient_rmProgramInterruptRoute+0x174> @ imm = #0xa
700a0e18: e7ff         	b	0x700a0e1a <Sciclient_rmProgramInterruptRoute+0x16a> @ imm = #-0x2
700a0e1a: a802         	add	r0, sp, #0x8
;             r = Sciclient_rmIrqProgramOesRegister(&cfg);
700a0e1c: f00c fef0    	bl	0x700adc00 <Sciclient_rmIrqProgramOesRegister> @ imm = #0xcde0
700a0e20: 900a         	str	r0, [sp, #0x28]
;         } else {
700a0e22: e003         	b	0x700a0e2c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #0x6
700a0e24: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a0e28: 900a         	str	r0, [sp, #0x28]
700a0e2a: e7ff         	b	0x700a0e2c <Sciclient_rmProgramInterruptRoute+0x17c> @ imm = #-0x2
700a0e2c: e7ff         	b	0x700a0e2e <Sciclient_rmProgramInterruptRoute+0x17e> @ imm = #-0x2
700a0e2e: e7ff         	b	0x700a0e30 <Sciclient_rmProgramInterruptRoute+0x180> @ imm = #-0x2
700a0e30: e7ff         	b	0x700a0e32 <Sciclient_rmProgramInterruptRoute+0x182> @ imm = #-0x2
;     }
700a0e32: e7ff         	b	0x700a0e34 <Sciclient_rmProgramInterruptRoute+0x184> @ imm = #-0x2
;     return r;
700a0e34: 980a         	ldr	r0, [sp, #0x28]
700a0e36: b00e         	add	sp, #0x38
700a0e38: bd80         	pop	{r7, pc}
700a0e3a: 0000         	movs	r0, r0
700a0e3c: 0000         	movs	r0, r0
700a0e3e: 0000         	movs	r0, r0

700a0e40 <PMU_init>:
; int32_t PMU_init(PMU_Config *cfg) {
700a0e40: b580         	push	{r7, lr}
700a0e42: b08a         	sub	sp, #0x28
700a0e44: 9009         	str	r0, [sp, #0x24]
;   memset((void *)&gProfileObject, 0U, sizeof(gProfileObject));
700a0e46: f243 0080    	movw	r0, #0x3080
700a0e4a: f2c7 0008    	movt	r0, #0x7008
700a0e4e: 9003         	str	r0, [sp, #0xc]
700a0e50: f640 510c    	movw	r1, #0xd0c
700a0e54: f7fa e95e    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0x5d44
700a0e58: 9a03         	ldr	r2, [sp, #0xc]
700a0e5a: 2000         	movs	r0, #0x0
;   gProfileObject.logIndex = 0U;
700a0e5c: 9004         	str	r0, [sp, #0x10]
700a0e5e: 6010         	str	r0, [r2]
;   gProfileObject.bCycleCounter = cfg->bCycleCounter;
700a0e60: 9909         	ldr	r1, [sp, #0x24]
700a0e62: 6809         	ldr	r1, [r1]
700a0e64: 6051         	str	r1, [r2, #0x4]
;   DebugP_assert(cfg->numEventCounters <= 3U);
700a0e66: 9909         	ldr	r1, [sp, #0x24]
700a0e68: 6849         	ldr	r1, [r1, #0x4]
700a0e6a: 2904         	cmp	r1, #0x4
700a0e6c: bf38         	it	lo
700a0e6e: 2001         	movlo	r0, #0x1
700a0e70: f641 51dd    	movw	r1, #0x1ddd
700a0e74: f2c7 010b    	movt	r1, #0x700b
700a0e78: 466a         	mov	r2, sp
700a0e7a: 6011         	str	r1, [r2]
700a0e7c: f242 1155    	movw	r1, #0x2155
700a0e80: f2c7 010b    	movt	r1, #0x700b
700a0e84: f242 125f    	movw	r2, #0x215f
700a0e88: f2c7 020b    	movt	r2, #0x700b
700a0e8c: 236e         	movs	r3, #0x6e
700a0e8e: f009 fef7    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x9dee
700a0e92: 9a03         	ldr	r2, [sp, #0xc]
700a0e94: 9804         	ldr	r0, [sp, #0x10]
;   gProfileObject.numEvents = cfg->numEventCounters;
700a0e96: 9909         	ldr	r1, [sp, #0x24]
700a0e98: 6849         	ldr	r1, [r1, #0x4]
700a0e9a: 6091         	str	r1, [r2, #0x8]
;   for (i = 0; i < PMU_MAX_LOG_ENTRIES; i++) {
700a0e9c: 9008         	str	r0, [sp, #0x20]
700a0e9e: e7ff         	b	0x700a0ea0 <PMU_init+0x60> @ imm = #-0x2
700a0ea0: 9808         	ldr	r0, [sp, #0x20]
700a0ea2: 283f         	cmp	r0, #0x3f
700a0ea4: d833         	bhi	0x700a0f0e <PMU_init+0xce> @ imm = #0x66
700a0ea6: e7ff         	b	0x700a0ea8 <PMU_init+0x68> @ imm = #-0x2
;     PMU_ProfilePoint *p = &gProfileObject.point[i];
700a0ea8: 9808         	ldr	r0, [sp, #0x20]
700a0eaa: f243 0280    	movw	r2, #0x3080
700a0eae: f2c7 0208    	movt	r2, #0x7008
700a0eb2: 2134         	movs	r1, #0x34
700a0eb4: fb00 2001    	mla	r0, r0, r1, r2
700a0eb8: 300c         	adds	r0, #0xc
700a0eba: 9006         	str	r0, [sp, #0x18]
700a0ebc: 2000         	movs	r0, #0x0
;     for (j = 0; j < cfg->numEventCounters; j++) {
700a0ebe: 9007         	str	r0, [sp, #0x1c]
700a0ec0: e7ff         	b	0x700a0ec2 <PMU_init+0x82> @ imm = #-0x2
700a0ec2: 9807         	ldr	r0, [sp, #0x1c]
700a0ec4: 9909         	ldr	r1, [sp, #0x24]
700a0ec6: 6849         	ldr	r1, [r1, #0x4]
700a0ec8: 4288         	cmp	r0, r1
700a0eca: d21b         	bhs	0x700a0f04 <PMU_init+0xc4> @ imm = #0x36
700a0ecc: e7ff         	b	0x700a0ece <PMU_init+0x8e> @ imm = #-0x2
;       p->events[j].name = cfg->eventCounters[j].name;
700a0ece: 9809         	ldr	r0, [sp, #0x24]
700a0ed0: 6880         	ldr	r0, [r0, #0x8]
700a0ed2: 9a07         	ldr	r2, [sp, #0x1c]
700a0ed4: eb00 00c2    	add.w	r0, r0, r2, lsl #3
700a0ed8: 6840         	ldr	r0, [r0, #0x4]
700a0eda: 9906         	ldr	r1, [sp, #0x18]
700a0edc: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a0ee0: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;       p->events[j].type = cfg->eventCounters[j].type;
700a0ee4: 9809         	ldr	r0, [sp, #0x24]
700a0ee6: 6880         	ldr	r0, [r0, #0x8]
700a0ee8: 9a07         	ldr	r2, [sp, #0x1c]
700a0eea: f850 0032    	ldr.w	r0, [r0, r2, lsl #3]
700a0eee: 9906         	ldr	r1, [sp, #0x18]
700a0ef0: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a0ef4: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a0ef8: 6048         	str	r0, [r1, #0x4]
;     }
700a0efa: e7ff         	b	0x700a0efc <PMU_init+0xbc> @ imm = #-0x2
;     for (j = 0; j < cfg->numEventCounters; j++) {
700a0efc: 9807         	ldr	r0, [sp, #0x1c]
700a0efe: 3001         	adds	r0, #0x1
700a0f00: 9007         	str	r0, [sp, #0x1c]
700a0f02: e7de         	b	0x700a0ec2 <PMU_init+0x82> @ imm = #-0x44
;   }
700a0f04: e7ff         	b	0x700a0f06 <PMU_init+0xc6> @ imm = #-0x2
;   for (i = 0; i < PMU_MAX_LOG_ENTRIES; i++) {
700a0f06: 9808         	ldr	r0, [sp, #0x20]
700a0f08: 3001         	adds	r0, #0x1
700a0f0a: 9008         	str	r0, [sp, #0x20]
700a0f0c: e7c8         	b	0x700a0ea0 <PMU_init+0x60> @ imm = #-0x70
;   int32_t numCount = CSL_armR5PmuGetNumCntrs();
700a0f0e: f001 e946    	blx	0x700a219c <CSL_armR5PmuGetNumCntrs> @ imm = #0x128c
700a0f12: 9005         	str	r0, [sp, #0x14]
;   DebugP_assert(numCount == cfg->numEventCounters);
700a0f14: 9805         	ldr	r0, [sp, #0x14]
700a0f16: 9909         	ldr	r1, [sp, #0x24]
700a0f18: 6849         	ldr	r1, [r1, #0x4]
700a0f1a: 1a40         	subs	r0, r0, r1
700a0f1c: fab0 f080    	clz	r0, r0
700a0f20: 0940         	lsrs	r0, r0, #0x5
700a0f22: f641 31db    	movw	r1, #0x1bdb
700a0f26: f2c7 010b    	movt	r1, #0x700b
700a0f2a: 466a         	mov	r2, sp
700a0f2c: 6011         	str	r1, [r2]
700a0f2e: f242 1155    	movw	r1, #0x2155
700a0f32: f2c7 010b    	movt	r1, #0x700b
700a0f36: f242 125f    	movw	r2, #0x215f
700a0f3a: f2c7 020b    	movt	r2, #0x700b
700a0f3e: 237d         	movs	r3, #0x7d
700a0f40: f009 fe9e    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x9d3c
700a0f44: 2100         	movs	r1, #0x0
700a0f46: 9102         	str	r1, [sp, #0x8]
700a0f48: 2201         	movs	r2, #0x1
;   CSL_armR5PmuCfg(0, 0, 1);
700a0f4a: 4608         	mov	r0, r1
700a0f4c: f001 e8f8    	blx	0x700a2140 <CSL_armR5PmuCfg> @ imm = #0x11f0
700a0f50: 9802         	ldr	r0, [sp, #0x8]
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0f52: 9008         	str	r0, [sp, #0x20]
700a0f54: e7ff         	b	0x700a0f56 <PMU_init+0x116> @ imm = #-0x2
700a0f56: 9808         	ldr	r0, [sp, #0x20]
700a0f58: 9909         	ldr	r1, [sp, #0x24]
700a0f5a: 6849         	ldr	r1, [r1, #0x4]
700a0f5c: 4288         	cmp	r0, r1
700a0f5e: d20c         	bhs	0x700a0f7a <PMU_init+0x13a> @ imm = #0x18
700a0f60: e7ff         	b	0x700a0f62 <PMU_init+0x122> @ imm = #-0x2
;     CSL_armR5PmuCfgCntr(i, (cfg->eventCounters[i].type & 0xFF));
700a0f62: 9808         	ldr	r0, [sp, #0x20]
700a0f64: 9909         	ldr	r1, [sp, #0x24]
700a0f66: 6889         	ldr	r1, [r1, #0x8]
700a0f68: f811 1030    	ldrb.w	r1, [r1, r0, lsl #3]
700a0f6c: f001 e91e    	blx	0x700a21ac <CSL_armR5PmuCfgCntr> @ imm = #0x123c
;   }
700a0f70: e7ff         	b	0x700a0f72 <PMU_init+0x132> @ imm = #-0x2
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0f72: 9808         	ldr	r0, [sp, #0x20]
700a0f74: 3001         	adds	r0, #0x1
700a0f76: 9008         	str	r0, [sp, #0x20]
700a0f78: e7ed         	b	0x700a0f56 <PMU_init+0x116> @ imm = #-0x26
700a0f7a: 2000         	movs	r0, #0x0
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0f7c: 9008         	str	r0, [sp, #0x20]
700a0f7e: e7ff         	b	0x700a0f80 <PMU_init+0x140> @ imm = #-0x2
700a0f80: 9808         	ldr	r0, [sp, #0x20]
700a0f82: 9909         	ldr	r1, [sp, #0x24]
700a0f84: 6849         	ldr	r1, [r1, #0x4]
700a0f86: 4288         	cmp	r0, r1
700a0f88: d209         	bhs	0x700a0f9e <PMU_init+0x15e> @ imm = #0x12
700a0f8a: e7ff         	b	0x700a0f8c <PMU_init+0x14c> @ imm = #-0x2
;     CSL_armR5PmuEnableCntrOverflowIntr(i, 0);
700a0f8c: 9808         	ldr	r0, [sp, #0x20]
700a0f8e: 2100         	movs	r1, #0x0
700a0f90: f001 e918    	blx	0x700a21c4 <CSL_armR5PmuEnableCntrOverflowIntr> @ imm = #0x1230
;   }
700a0f94: e7ff         	b	0x700a0f96 <PMU_init+0x156> @ imm = #-0x2
;   for (i = 0; i < cfg->numEventCounters; i++) {
700a0f96: 9808         	ldr	r0, [sp, #0x20]
700a0f98: 3001         	adds	r0, #0x1
700a0f9a: 9008         	str	r0, [sp, #0x20]
700a0f9c: e7f0         	b	0x700a0f80 <PMU_init+0x140> @ imm = #-0x20
;   if (cfg->bCycleCounter == TRUE) {
700a0f9e: 9809         	ldr	r0, [sp, #0x24]
700a0fa0: 6800         	ldr	r0, [r0]
700a0fa2: 2801         	cmp	r0, #0x1
700a0fa4: d105         	bne	0x700a0fb2 <PMU_init+0x172> @ imm = #0xa
700a0fa6: e7ff         	b	0x700a0fa8 <PMU_init+0x168> @ imm = #-0x2
700a0fa8: 201f         	movs	r0, #0x1f
700a0faa: 2100         	movs	r1, #0x0
;     CSL_armR5PmuEnableCntrOverflowIntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM, 0);
700a0fac: f001 e90a    	blx	0x700a21c4 <CSL_armR5PmuEnableCntrOverflowIntr> @ imm = #0x1214
;   }
700a0fb0: e7ff         	b	0x700a0fb2 <PMU_init+0x172> @ imm = #-0x2
;   CSL_armR5PmuResetCntrs();
700a0fb2: f001 e960    	blx	0x700a2274 <CSL_armR5PmuResetCntrs> @ imm = #0x12c0
;   CSL_armR5PmuResetCycleCnt();
700a0fb6: f001 e956    	blx	0x700a2264 <CSL_armR5PmuResetCycleCnt> @ imm = #0x12ac
;   PMU_enableAllCounters(cfg->numEventCounters);
700a0fba: 9809         	ldr	r0, [sp, #0x24]
700a0fbc: 6840         	ldr	r0, [r0, #0x4]
700a0fbe: f00d f8ff    	bl	0x700ae1c0 <PMU_enableAllCounters> @ imm = #0xd1fe
700a0fc2: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
700a0fc4: b00a         	add	sp, #0x28
700a0fc6: bd80         	pop	{r7, pc}
		...

700a0fd0 <Sciclient_rmIrqProgramRoute>:
; {
700a0fd0: b580         	push	{r7, lr}
700a0fd2: b092         	sub	sp, #0x48
700a0fd4: 9011         	str	r0, [sp, #0x44]
700a0fd6: f88d 1043    	strb.w	r1, [sp, #0x43]
700a0fda: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a0fdc: 900f         	str	r0, [sp, #0x3c]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a0fde: 9003         	str	r0, [sp, #0xc]
;     struct Sciclient_rmIrInst *ir_inst = NULL;
700a0fe0: 9002         	str	r0, [sp, #0x8]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a0fe2: f8ad 003a    	strh.w	r0, [sp, #0x3a]
700a0fe6: e7ff         	b	0x700a0fe8 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x2
700a0fe8: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a0fec: 9001         	str	r0, [sp, #0x4]
700a0fee: f00e fe47    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0xec8e
700a0ff2: 4601         	mov	r1, r0
700a0ff4: 9801         	ldr	r0, [sp, #0x4]
700a0ff6: 4288         	cmp	r0, r1
700a0ff8: f280 80aa    	bge.w	0x700a1150 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0x154
700a0ffc: e7ff         	b	0x700a0ffe <Sciclient_rmIrqProgramRoute+0x2e> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a0ffe: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a1002: f00e fa0d    	bl	0x700af420 <Sciclient_rmPsGetIrqNode> @ imm = #0xe41a
700a1006: 900d         	str	r0, [sp, #0x34]
;         cur_inp = Sciclient_rmPsGetInp(i);
700a1008: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a100c: f00c fe38    	bl	0x700adc80 <Sciclient_rmPsGetInp> @ imm = #0xcc70
700a1010: 900c         	str	r0, [sp, #0x30]
;         cur_outp = Sciclient_rmPsGetOutp(i);
700a1012: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a1016: f00c fe53    	bl	0x700adcc0 <Sciclient_rmPsGetOutp> @ imm = #0xcca6
700a101a: 900b         	str	r0, [sp, #0x2c]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a101c: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a1020: 2800         	cmp	r0, #0x0
700a1022: d154         	bne	0x700a10ce <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0xa8
700a1024: e7ff         	b	0x700a1026 <Sciclient_rmIrqProgramRoute+0x56> @ imm = #-0x2
700a1026: 980d         	ldr	r0, [sp, #0x34]
700a1028: 8800         	ldrh	r0, [r0]
700a102a: f00d fc71    	bl	0x700ae910 <Sciclient_rmIaIsIa> @ imm = #0xd8e2
700a102e: 2800         	cmp	r0, #0x0
700a1030: d04d         	beq	0x700a10ce <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x9a
700a1032: e7ff         	b	0x700a1034 <Sciclient_rmIrqProgramRoute+0x64> @ imm = #-0x2
;             (map_vint == true)) {
700a1034: f89d 0043    	ldrb.w	r0, [sp, #0x43]
;         if ((i == 0u) && (Sciclient_rmIaIsIa(cur_n->id) == true) &&
700a1038: 07c0         	lsls	r0, r0, #0x1f
700a103a: 2800         	cmp	r0, #0x0
700a103c: d047         	beq	0x700a10ce <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #0x8e
700a103e: e7ff         	b	0x700a1040 <Sciclient_rmIrqProgramRoute+0x70> @ imm = #-0x2
700a1040: 203c         	movs	r0, #0x3c
700a1042: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a1046: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
700a1048: 9811         	ldr	r0, [sp, #0x44]
700a104a: 7900         	ldrb	r0, [r0, #0x4]
700a104c: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cfg->s_id;
700a1050: 9811         	ldr	r0, [sp, #0x44]
700a1052: 88c0         	ldrh	r0, [r0, #0x6]
700a1054: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cfg->s_idx;
700a1058: 9811         	ldr	r0, [sp, #0x44]
700a105a: 8900         	ldrh	r0, [r0, #0x8]
700a105c: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.ia_id = cfg->s_ia;
700a1060: 9811         	ldr	r0, [sp, #0x44]
700a1062: 8a00         	ldrh	r0, [r0, #0x10]
700a1064: f8ad 0024    	strh.w	r0, [sp, #0x24]
;             req.vint = cur_outp;
700a1068: 980b         	ldr	r0, [sp, #0x2c]
700a106a: f8ad 0026    	strh.w	r0, [sp, #0x26]
;             req.global_event = cur_inp;
700a106e: 980c         	ldr	r0, [sp, #0x30]
700a1070: f8ad 0028    	strh.w	r0, [sp, #0x28]
;             req.vint_status_bit_index = cfg->vint_sb;
700a1074: 9811         	ldr	r0, [sp, #0x44]
700a1076: 7d00         	ldrb	r0, [r0, #0x14]
700a1078: f88d 002a    	strb.w	r0, [sp, #0x2a]
;                                       cfg->set_resp,
700a107c: 9811         	ldr	r0, [sp, #0x44]
700a107e: 6981         	ldr	r1, [r0, #0x18]
700a1080: a804         	add	r0, sp, #0x10
700a1082: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
700a1086: f00b fbdb    	bl	0x700ac840 <Sciclient_rmIrqSetRaw> @ imm = #0xb7b6
700a108a: 900f         	str	r0, [sp, #0x3c]
;             if (r == SystemP_SUCCESS) {
700a108c: 980f         	ldr	r0, [sp, #0x3c]
700a108e: b9e8         	cbnz	r0, 0x700a10cc <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #0x3a
700a1090: e7ff         	b	0x700a1092 <Sciclient_rmIrqProgramRoute+0xc2> @ imm = #-0x2
;                 ia_inst = Sciclient_rmIaGetInst(cur_n->id);
700a1092: 980d         	ldr	r0, [sp, #0x34]
700a1094: 8800         	ldrh	r0, [r0]
700a1096: f00b fa53    	bl	0x700ac540 <Sciclient_rmIaGetInst> @ imm = #0xb4a6
700a109a: 9003         	str	r0, [sp, #0xc]
;                 if (ia_inst != NULL) {
700a109c: 9803         	ldr	r0, [sp, #0xc]
700a109e: b1a0         	cbz	r0, 0x700a10ca <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #0x28
700a10a0: e7ff         	b	0x700a10a2 <Sciclient_rmIrqProgramRoute+0xd2> @ imm = #-0x2
;                     ia_inst->vint_usage_count[cur_outp]++;
700a10a2: 9803         	ldr	r0, [sp, #0xc]
700a10a4: 6901         	ldr	r1, [r0, #0x10]
700a10a6: 9a0b         	ldr	r2, [sp, #0x2c]
700a10a8: 5c88         	ldrb	r0, [r1, r2]
700a10aa: 3001         	adds	r0, #0x1
700a10ac: 5488         	strb	r0, [r1, r2]
;                     if ((cur_outp == 0) && (cfg->vint_sb == 0)) {
700a10ae: 980b         	ldr	r0, [sp, #0x2c]
700a10b0: b950         	cbnz	r0, 0x700a10c8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0x14
700a10b2: e7ff         	b	0x700a10b4 <Sciclient_rmIrqProgramRoute+0xe4> @ imm = #-0x2
700a10b4: 9811         	ldr	r0, [sp, #0x44]
700a10b6: 7d00         	ldrb	r0, [r0, #0x14]
700a10b8: b930         	cbnz	r0, 0x700a10c8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #0xc
700a10ba: e7ff         	b	0x700a10bc <Sciclient_rmIrqProgramRoute+0xec> @ imm = #-0x2
;                         ia_inst->v0_b0_evt = cur_inp - ia_inst->sevt_offset;
700a10bc: 980c         	ldr	r0, [sp, #0x30]
700a10be: 9903         	ldr	r1, [sp, #0xc]
700a10c0: 890a         	ldrh	r2, [r1, #0x8]
700a10c2: 1a80         	subs	r0, r0, r2
700a10c4: 8288         	strh	r0, [r1, #0x14]
;                     }
700a10c6: e7ff         	b	0x700a10c8 <Sciclient_rmIrqProgramRoute+0xf8> @ imm = #-0x2
;                 }
700a10c8: e7ff         	b	0x700a10ca <Sciclient_rmIrqProgramRoute+0xfa> @ imm = #-0x2
;             }
700a10ca: e7ff         	b	0x700a10cc <Sciclient_rmIrqProgramRoute+0xfc> @ imm = #-0x2
;         }
700a10cc: e7ff         	b	0x700a10ce <Sciclient_rmIrqProgramRoute+0xfe> @ imm = #-0x2
;         if (i > 0u) {
700a10ce: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a10d2: b390         	cbz	r0, 0x700a113a <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #0x64
700a10d4: e7ff         	b	0x700a10d6 <Sciclient_rmIrqProgramRoute+0x106> @ imm = #-0x2
700a10d6: 2003         	movs	r0, #0x3
700a10d8: f2c8 0000    	movt	r0, #0x8000
;             req.valid_params = (TISCI_MSG_VALUE_RM_DST_ID_VALID |
700a10dc: 9006         	str	r0, [sp, #0x18]
;             req.secondary_host = cfg->host;
700a10de: 9811         	ldr	r0, [sp, #0x44]
700a10e0: 7900         	ldrb	r0, [r0, #0x4]
700a10e2: f88d 002b    	strb.w	r0, [sp, #0x2b]
;             req.src_id = cur_n->id;
700a10e6: 980d         	ldr	r0, [sp, #0x34]
700a10e8: 8800         	ldrh	r0, [r0]
700a10ea: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;             req.src_index = cur_inp;
700a10ee: 980c         	ldr	r0, [sp, #0x30]
700a10f0: f8ad 001e    	strh.w	r0, [sp, #0x1e]
;             req.dst_id = cur_n->id;
700a10f4: 980d         	ldr	r0, [sp, #0x34]
700a10f6: 8800         	ldrh	r0, [r0]
700a10f8: f8ad 0020    	strh.w	r0, [sp, #0x20]
;             req.dst_host_irq = cur_outp;
700a10fc: 980b         	ldr	r0, [sp, #0x2c]
700a10fe: f8ad 0022    	strh.w	r0, [sp, #0x22]
;                                       cfg->set_resp,
700a1102: 9811         	ldr	r0, [sp, #0x44]
700a1104: 6981         	ldr	r1, [r0, #0x18]
700a1106: a804         	add	r0, sp, #0x10
700a1108: f04f 32ff    	mov.w	r2, #0xffffffff
;             r = Sciclient_rmIrqSetRaw(&req,
700a110c: f00b fb98    	bl	0x700ac840 <Sciclient_rmIrqSetRaw> @ imm = #0xb730
700a1110: 900f         	str	r0, [sp, #0x3c]
;             if ((r == SystemP_SUCCESS) && (cur_outp == 0)) {
700a1112: 980f         	ldr	r0, [sp, #0x3c]
700a1114: b980         	cbnz	r0, 0x700a1138 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x20
700a1116: e7ff         	b	0x700a1118 <Sciclient_rmIrqProgramRoute+0x148> @ imm = #-0x2
700a1118: 980b         	ldr	r0, [sp, #0x2c]
700a111a: b968         	cbnz	r0, 0x700a1138 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #0x1a
700a111c: e7ff         	b	0x700a111e <Sciclient_rmIrqProgramRoute+0x14e> @ imm = #-0x2
;                 ir_inst = Sciclient_rmIrGetInst(cur_n->id);
700a111e: 980d         	ldr	r0, [sp, #0x34]
700a1120: 8800         	ldrh	r0, [r0]
700a1122: f00a fd25    	bl	0x700abb70 <Sciclient_rmIrGetInst> @ imm = #0xaa4a
700a1126: 9002         	str	r0, [sp, #0x8]
;                 if (ir_inst != NULL) {
700a1128: 9802         	ldr	r0, [sp, #0x8]
700a112a: b120         	cbz	r0, 0x700a1136 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #0x8
700a112c: e7ff         	b	0x700a112e <Sciclient_rmIrqProgramRoute+0x15e> @ imm = #-0x2
;                     ir_inst->inp0_mapping = cur_outp;
700a112e: 980b         	ldr	r0, [sp, #0x2c]
700a1130: 9902         	ldr	r1, [sp, #0x8]
700a1132: 8188         	strh	r0, [r1, #0xc]
;                 }
700a1134: e7ff         	b	0x700a1136 <Sciclient_rmIrqProgramRoute+0x166> @ imm = #-0x2
;             }
700a1136: e7ff         	b	0x700a1138 <Sciclient_rmIrqProgramRoute+0x168> @ imm = #-0x2
;         }
700a1138: e7ff         	b	0x700a113a <Sciclient_rmIrqProgramRoute+0x16a> @ imm = #-0x2
;         if (r != SystemP_SUCCESS) {
700a113a: 980f         	ldr	r0, [sp, #0x3c]
700a113c: b108         	cbz	r0, 0x700a1142 <Sciclient_rmIrqProgramRoute+0x172> @ imm = #0x2
700a113e: e7ff         	b	0x700a1140 <Sciclient_rmIrqProgramRoute+0x170> @ imm = #-0x2
;             break;
700a1140: e006         	b	0x700a1150 <Sciclient_rmIrqProgramRoute+0x180> @ imm = #0xc
;     }
700a1142: e7ff         	b	0x700a1144 <Sciclient_rmIrqProgramRoute+0x174> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a1144: f8bd 003a    	ldrh.w	r0, [sp, #0x3a]
700a1148: 3001         	adds	r0, #0x1
700a114a: f8ad 003a    	strh.w	r0, [sp, #0x3a]
700a114e: e74b         	b	0x700a0fe8 <Sciclient_rmIrqProgramRoute+0x18> @ imm = #-0x16a
;     return r;
700a1150: 980f         	ldr	r0, [sp, #0x3c]
700a1152: b012         	add	sp, #0x48
700a1154: bd80         	pop	{r7, pc}
		...
700a115e: 0000         	movs	r0, r0

700a1160 <Udma_chEnableLocal>:
; {
700a1160: b580         	push	{r7, lr}
700a1162: b08e         	sub	sp, #0x38
700a1164: 900d         	str	r0, [sp, #0x34]
;     drvHandle = chHandle->drvHandle;
700a1166: 980d         	ldr	r0, [sp, #0x34]
700a1168: 6e80         	ldr	r0, [r0, #0x68]
700a116a: 900b         	str	r0, [sp, #0x2c]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a116c: 980b         	ldr	r0, [sp, #0x2c]
700a116e: 6800         	ldr	r0, [r0]
700a1170: 2801         	cmp	r0, #0x1
700a1172: d163         	bne	0x700a123c <Udma_chEnableLocal+0xdc> @ imm = #0xc6
700a1174: e7ff         	b	0x700a1176 <Udma_chEnableLocal+0x16> @ imm = #-0x2
700a1176: 2001         	movs	r0, #0x1
;         bcdmaRtEnable.enable         = TRUE;
700a1178: 9005         	str	r0, [sp, #0x14]
700a117a: 2000         	movs	r0, #0x0
;         bcdmaRtEnable.teardown       = FALSE;
700a117c: 9006         	str	r0, [sp, #0x18]
;         bcdmaRtEnable.forcedTeardown = FALSE;
700a117e: 9009         	str	r0, [sp, #0x24]
;         bcdmaRtEnable.pause          = FALSE;
700a1180: 9007         	str	r0, [sp, #0x1c]
;         bcdmaRtEnable.error          = FALSE;
700a1182: 9008         	str	r0, [sp, #0x20]
;         if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a1184: 980d         	ldr	r0, [sp, #0x34]
700a1186: 7800         	ldrb	r0, [r0]
700a1188: 0740         	lsls	r0, r0, #0x1d
700a118a: 2800         	cmp	r0, #0x0
700a118c: d508         	bpl	0x700a11a0 <Udma_chEnableLocal+0x40> @ imm = #0x10
700a118e: e7ff         	b	0x700a1190 <Udma_chEnableLocal+0x30> @ imm = #-0x2
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum , &bcdmaRtEnable);
700a1190: 980b         	ldr	r0, [sp, #0x2c]
700a1192: 3008         	adds	r0, #0x8
700a1194: 990d         	ldr	r1, [sp, #0x34]
700a1196: 6ec9         	ldr	r1, [r1, #0x6c]
700a1198: aa05         	add	r2, sp, #0x14
700a119a: f00d fcd9    	bl	0x700aeb50 <CSL_bcdmaSetTxRT> @ imm = #0xd9b2
;         }
700a119e: e04c         	b	0x700a123a <Udma_chEnableLocal+0xda> @ imm = #0x98
;         else if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a11a0: 980d         	ldr	r0, [sp, #0x34]
700a11a2: 7800         	ldrb	r0, [r0]
700a11a4: 07c0         	lsls	r0, r0, #0x1f
700a11a6: b300         	cbz	r0, 0x700a11ea <Udma_chEnableLocal+0x8a> @ imm = #0x40
700a11a8: e7ff         	b	0x700a11aa <Udma_chEnableLocal+0x4a> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaTxRtRegs->PEER8);
700a11aa: 980d         	ldr	r0, [sp, #0x34]
700a11ac: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a11b0: f500 7008    	add.w	r0, r0, #0x220
700a11b4: f00e fd4c    	bl	0x700afc50 <CSL_REG32_RD_RAW> @ imm = #0xea98
700a11b8: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a11ba: 980c         	ldr	r0, [sp, #0x30]
700a11bc: f040 4000    	orr	r0, r0, #0x80000000
700a11c0: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaTxRtRegs->PEER8, regVal);
700a11c2: 980d         	ldr	r0, [sp, #0x34]
700a11c4: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a11c8: f500 7008    	add.w	r0, r0, #0x220
700a11cc: 990c         	ldr	r1, [sp, #0x30]
700a11ce: f00e fc9f    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0xe93e
;             (void) CSL_bcdmaSetTxRT(&drvHandle->bcdmaRegs, chHandle->txChNum + drvHandle->txChOffset, &bcdmaRtEnable);
700a11d2: 9a0b         	ldr	r2, [sp, #0x2c]
700a11d4: f102 0008    	add.w	r0, r2, #0x8
700a11d8: 990d         	ldr	r1, [sp, #0x34]
700a11da: 6ec9         	ldr	r1, [r1, #0x6c]
700a11dc: f8d2 210c    	ldr.w	r2, [r2, #0x10c]
700a11e0: 4411         	add	r1, r2
700a11e2: aa05         	add	r2, sp, #0x14
700a11e4: f00d fcb4    	bl	0x700aeb50 <CSL_bcdmaSetTxRT> @ imm = #0xd968
;         }
700a11e8: e026         	b	0x700a1238 <Udma_chEnableLocal+0xd8> @ imm = #0x4c
;         else if ((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a11ea: 980d         	ldr	r0, [sp, #0x34]
700a11ec: 7800         	ldrb	r0, [r0]
700a11ee: 0780         	lsls	r0, r0, #0x1e
700a11f0: 2800         	cmp	r0, #0x0
700a11f2: d520         	bpl	0x700a1236 <Udma_chEnableLocal+0xd6> @ imm = #0x40
700a11f4: e7ff         	b	0x700a11f6 <Udma_chEnableLocal+0x96> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs, chHandle->rxChNum + drvHandle->rxChOffset, &bcdmaRtEnable);
700a11f6: 9a0b         	ldr	r2, [sp, #0x2c]
700a11f8: f102 0008    	add.w	r0, r2, #0x8
700a11fc: 990d         	ldr	r1, [sp, #0x34]
700a11fe: 6f09         	ldr	r1, [r1, #0x70]
700a1200: f8d2 2114    	ldr.w	r2, [r2, #0x114]
700a1204: 4411         	add	r1, r2
700a1206: aa05         	add	r2, sp, #0x14
;             (void) CSL_bcdmaSetRxRT(
700a1208: f00d fc8a    	bl	0x700aeb20 <CSL_bcdmaSetRxRT> @ imm = #0xd914
;             regVal = CSL_REG32_RD(&chHandle->pBcdmaRxRtRegs->PEER8);
700a120c: 980d         	ldr	r0, [sp, #0x34]
700a120e: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a1212: f500 7008    	add.w	r0, r0, #0x220
700a1216: f00e fd1b    	bl	0x700afc50 <CSL_REG32_RD_RAW> @ imm = #0xea36
700a121a: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a121c: 980c         	ldr	r0, [sp, #0x30]
700a121e: f040 4000    	orr	r0, r0, #0x80000000
700a1222: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pBcdmaRxRtRegs->PEER8, regVal);
700a1224: 980d         	ldr	r0, [sp, #0x34]
700a1226: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a122a: f500 7008    	add.w	r0, r0, #0x220
700a122e: 990c         	ldr	r1, [sp, #0x30]
700a1230: f00e fc6e    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0xe8dc
;         }
700a1234: e7ff         	b	0x700a1236 <Udma_chEnableLocal+0xd6> @ imm = #-0x2
700a1236: e7ff         	b	0x700a1238 <Udma_chEnableLocal+0xd8> @ imm = #-0x2
700a1238: e7ff         	b	0x700a123a <Udma_chEnableLocal+0xda> @ imm = #-0x2
;     }
700a123a: e050         	b	0x700a12de <Udma_chEnableLocal+0x17e> @ imm = #0xa0
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a123c: 980b         	ldr	r0, [sp, #0x2c]
700a123e: 6800         	ldr	r0, [r0]
700a1240: 2802         	cmp	r0, #0x2
700a1242: d14b         	bne	0x700a12dc <Udma_chEnableLocal+0x17c> @ imm = #0x96
700a1244: e7ff         	b	0x700a1246 <Udma_chEnableLocal+0xe6> @ imm = #-0x2
700a1246: 2001         	movs	r0, #0x1
;         pktdmaRtEnable.enable         = TRUE;
700a1248: 9000         	str	r0, [sp]
700a124a: 2000         	movs	r0, #0x0
;         pktdmaRtEnable.teardown       = FALSE;
700a124c: 9001         	str	r0, [sp, #0x4]
;         pktdmaRtEnable.forcedTeardown = FALSE;
700a124e: 9004         	str	r0, [sp, #0x10]
;         pktdmaRtEnable.pause          = FALSE;
700a1250: 9002         	str	r0, [sp, #0x8]
;         pktdmaRtEnable.error          = FALSE;
700a1252: 9003         	str	r0, [sp, #0xc]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a1254: 980d         	ldr	r0, [sp, #0x34]
700a1256: 7800         	ldrb	r0, [r0]
700a1258: 07c0         	lsls	r0, r0, #0x1f
700a125a: b1e0         	cbz	r0, 0x700a1296 <Udma_chEnableLocal+0x136> @ imm = #0x38
700a125c: e7ff         	b	0x700a125e <Udma_chEnableLocal+0xfe> @ imm = #-0x2
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaTxRtRegs->PEER8);
700a125e: 980d         	ldr	r0, [sp, #0x34]
700a1260: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a1264: f500 7008    	add.w	r0, r0, #0x220
700a1268: f00e fcf2    	bl	0x700afc50 <CSL_REG32_RD_RAW> @ imm = #0xe9e4
700a126c: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a126e: 980c         	ldr	r0, [sp, #0x30]
700a1270: f040 4000    	orr	r0, r0, #0x80000000
700a1274: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaTxRtRegs->PEER8, regVal);
700a1276: 980d         	ldr	r0, [sp, #0x34]
700a1278: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a127c: f500 7008    	add.w	r0, r0, #0x220
700a1280: 990c         	ldr	r1, [sp, #0x30]
700a1282: f00e fc45    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0xe88a
;             (void) CSL_pktdmaSetTxRT(&drvHandle->pktdmaRegs, chHandle->txChNum, &pktdmaRtEnable);
700a1286: 980b         	ldr	r0, [sp, #0x2c]
700a1288: 3054         	adds	r0, #0x54
700a128a: 990d         	ldr	r1, [sp, #0x34]
700a128c: 6ec9         	ldr	r1, [r1, #0x6c]
700a128e: 466a         	mov	r2, sp
700a1290: f00c fe96    	bl	0x700adfc0 <CSL_pktdmaSetTxRT> @ imm = #0xcd2c
;         }
700a1294: e7ff         	b	0x700a1296 <Udma_chEnableLocal+0x136> @ imm = #-0x2
;         if((chHandle->chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a1296: 980d         	ldr	r0, [sp, #0x34]
700a1298: 7800         	ldrb	r0, [r0]
700a129a: 0780         	lsls	r0, r0, #0x1e
700a129c: 2800         	cmp	r0, #0x0
700a129e: d51c         	bpl	0x700a12da <Udma_chEnableLocal+0x17a> @ imm = #0x38
700a12a0: e7ff         	b	0x700a12a2 <Udma_chEnableLocal+0x142> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs, chHandle->rxChNum, &pktdmaRtEnable);
700a12a2: 980b         	ldr	r0, [sp, #0x2c]
700a12a4: 3054         	adds	r0, #0x54
700a12a6: 990d         	ldr	r1, [sp, #0x34]
700a12a8: 6f09         	ldr	r1, [r1, #0x70]
700a12aa: 466a         	mov	r2, sp
;             (void) CSL_pktdmaSetRxRT(
700a12ac: f00c fe68    	bl	0x700adf80 <CSL_pktdmaSetRxRT> @ imm = #0xccd0
;             regVal = CSL_REG32_RD(&chHandle->pPktdmaRxRtRegs->PEER8);
700a12b0: 980d         	ldr	r0, [sp, #0x34]
700a12b2: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a12b6: f500 7008    	add.w	r0, r0, #0x220
700a12ba: f00e fcc9    	bl	0x700afc50 <CSL_REG32_RD_RAW> @ imm = #0xe992
700a12be: 900c         	str	r0, [sp, #0x30]
;             CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 1U);
700a12c0: 980c         	ldr	r0, [sp, #0x30]
700a12c2: f040 4000    	orr	r0, r0, #0x80000000
700a12c6: 900c         	str	r0, [sp, #0x30]
;             CSL_REG32_WR(&chHandle->pPktdmaRxRtRegs->PEER8, regVal);
700a12c8: 980d         	ldr	r0, [sp, #0x34]
700a12ca: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a12ce: f500 7008    	add.w	r0, r0, #0x220
700a12d2: 990c         	ldr	r1, [sp, #0x30]
700a12d4: f00e fc1c    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0xe838
;         }
700a12d8: e7ff         	b	0x700a12da <Udma_chEnableLocal+0x17a> @ imm = #-0x2
;     }
700a12da: e7ff         	b	0x700a12dc <Udma_chEnableLocal+0x17c> @ imm = #-0x2
700a12dc: e7ff         	b	0x700a12de <Udma_chEnableLocal+0x17e> @ imm = #-0x2
;     return;
700a12de: b00e         	add	sp, #0x38
700a12e0: bd80         	pop	{r7, pc}
		...
700a12ee: 0000         	movs	r0, r0

700a12f0 <Udma_chConfigPdma>:
; {
700a12f0: b580         	push	{r7, lr}
700a12f2: b08a         	sub	sp, #0x28
700a12f4: 9009         	str	r0, [sp, #0x24]
700a12f6: 9108         	str	r1, [sp, #0x20]
700a12f8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a12fa: 9007         	str	r0, [sp, #0x1c]
;     volatile uint32_t  *PEER8=NULL, *PEER0=NULL, *PEER1=NULL;
700a12fc: 9006         	str	r0, [sp, #0x18]
700a12fe: 9005         	str	r0, [sp, #0x14]
700a1300: 9004         	str	r0, [sp, #0x10]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a1302: 9809         	ldr	r0, [sp, #0x24]
700a1304: 9002         	str	r0, [sp, #0x8]
;     if((NULL_PTR == chHandleInt) ||
700a1306: 9802         	ldr	r0, [sp, #0x8]
700a1308: b1a0         	cbz	r0, 0x700a1334 <Udma_chConfigPdma+0x44> @ imm = #0x28
700a130a: e7ff         	b	0x700a130c <Udma_chConfigPdma+0x1c> @ imm = #-0x2
;        (NULL_PTR == pdmaPrms) ||
700a130c: 9808         	ldr	r0, [sp, #0x20]
700a130e: b188         	cbz	r0, 0x700a1334 <Udma_chConfigPdma+0x44> @ imm = #0x22
700a1310: e7ff         	b	0x700a1312 <Udma_chConfigPdma+0x22> @ imm = #-0x2
;        (chHandleInt->chInitDone != UDMA_INIT_DONE) ||
700a1312: 9802         	ldr	r0, [sp, #0x8]
700a1314: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a1318: f64a 31cd    	movw	r1, #0xabcd
700a131c: f6ca 31dc    	movt	r1, #0xabdc
700a1320: 4288         	cmp	r0, r1
700a1322: d107         	bne	0x700a1334 <Udma_chConfigPdma+0x44> @ imm = #0xe
700a1324: e7ff         	b	0x700a1326 <Udma_chConfigPdma+0x36> @ imm = #-0x2
;        ((chHandleInt->chType & UDMA_CH_FLAG_PDMA) != UDMA_CH_FLAG_PDMA))
700a1326: 9802         	ldr	r0, [sp, #0x8]
700a1328: 6800         	ldr	r0, [r0]
700a132a: f000 0008    	and	r0, r0, #0x8
;     if((NULL_PTR == chHandleInt) ||
700a132e: 2808         	cmp	r0, #0x8
700a1330: d004         	beq	0x700a133c <Udma_chConfigPdma+0x4c> @ imm = #0x8
700a1332: e7ff         	b	0x700a1334 <Udma_chConfigPdma+0x44> @ imm = #-0x2
700a1334: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a1338: 9007         	str	r0, [sp, #0x1c]
;     }
700a133a: e7ff         	b	0x700a133c <Udma_chConfigPdma+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a133c: 9807         	ldr	r0, [sp, #0x1c]
700a133e: b9a8         	cbnz	r0, 0x700a136c <Udma_chConfigPdma+0x7c> @ imm = #0x2a
700a1340: e7ff         	b	0x700a1342 <Udma_chConfigPdma+0x52> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a1342: 9802         	ldr	r0, [sp, #0x8]
700a1344: 6e80         	ldr	r0, [r0, #0x68]
700a1346: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a1348: 9803         	ldr	r0, [sp, #0xc]
700a134a: b150         	cbz	r0, 0x700a1362 <Udma_chConfigPdma+0x72> @ imm = #0x14
700a134c: e7ff         	b	0x700a134e <Udma_chConfigPdma+0x5e> @ imm = #-0x2
700a134e: 9803         	ldr	r0, [sp, #0xc]
700a1350: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a1354: f64a 31cd    	movw	r1, #0xabcd
700a1358: f6ca 31dc    	movt	r1, #0xabdc
700a135c: 4288         	cmp	r0, r1
700a135e: d004         	beq	0x700a136a <Udma_chConfigPdma+0x7a> @ imm = #0x8
700a1360: e7ff         	b	0x700a1362 <Udma_chConfigPdma+0x72> @ imm = #-0x2
700a1362: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a1366: 9007         	str	r0, [sp, #0x1c]
;         }
700a1368: e7ff         	b	0x700a136a <Udma_chConfigPdma+0x7a> @ imm = #-0x2
;     }
700a136a: e7ff         	b	0x700a136c <Udma_chConfigPdma+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a136c: 9807         	ldr	r0, [sp, #0x1c]
700a136e: 2800         	cmp	r0, #0x0
700a1370: d17a         	bne	0x700a1468 <Udma_chConfigPdma+0x178> @ imm = #0xf4
700a1372: e7ff         	b	0x700a1374 <Udma_chConfigPdma+0x84> @ imm = #-0x2
;         if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a1374: 9803         	ldr	r0, [sp, #0xc]
700a1376: 6800         	ldr	r0, [r0]
700a1378: 2801         	cmp	r0, #0x1
700a137a: d137         	bne	0x700a13ec <Udma_chConfigPdma+0xfc> @ imm = #0x6e
700a137c: e7ff         	b	0x700a137e <Udma_chConfigPdma+0x8e> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a137e: 9802         	ldr	r0, [sp, #0x8]
700a1380: 7800         	ldrb	r0, [r0]
700a1382: 07c0         	lsls	r0, r0, #0x1f
700a1384: b198         	cbz	r0, 0x700a13ae <Udma_chConfigPdma+0xbe> @ imm = #0x26
700a1386: e7ff         	b	0x700a1388 <Udma_chConfigPdma+0x98> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pBcdmaTxRtRegs->PEER8;
700a1388: 9802         	ldr	r0, [sp, #0x8]
700a138a: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a138e: f500 7008    	add.w	r0, r0, #0x220
700a1392: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaTxRtRegs->PEER1;
700a1394: 9802         	ldr	r0, [sp, #0x8]
700a1396: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a139a: f500 7001    	add.w	r0, r0, #0x204
700a139e: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaTxRtRegs->PEER0;
700a13a0: 9802         	ldr	r0, [sp, #0x8]
700a13a2: f8d0 0220    	ldr.w	r0, [r0, #0x220]
700a13a6: f500 7000    	add.w	r0, r0, #0x200
700a13aa: 9005         	str	r0, [sp, #0x14]
;             }
700a13ac: e012         	b	0x700a13d4 <Udma_chConfigPdma+0xe4> @ imm = #0x24
;                 PEER8 = &chHandleInt->pBcdmaRxRtRegs->PEER8;
700a13ae: 9802         	ldr	r0, [sp, #0x8]
700a13b0: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a13b4: f500 7008    	add.w	r0, r0, #0x220
700a13b8: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pBcdmaRxRtRegs->PEER1;
700a13ba: 9802         	ldr	r0, [sp, #0x8]
700a13bc: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a13c0: f500 7001    	add.w	r0, r0, #0x204
700a13c4: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pBcdmaRxRtRegs->PEER0;
700a13c6: 9802         	ldr	r0, [sp, #0x8]
700a13c8: f8d0 0228    	ldr.w	r0, [r0, #0x228]
700a13cc: f500 7000    	add.w	r0, r0, #0x200
700a13d0: 9005         	str	r0, [sp, #0x14]
700a13d2: e7ff         	b	0x700a13d4 <Udma_chConfigPdma+0xe4> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
700a13d4: 9803         	ldr	r0, [sp, #0xc]
700a13d6: 9908         	ldr	r1, [sp, #0x20]
700a13d8: 9a06         	ldr	r2, [sp, #0x18]
700a13da: 9b04         	ldr	r3, [sp, #0x10]
700a13dc: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a13e0: 46ee         	mov	lr, sp
700a13e2: f8ce c000    	str.w	r12, [lr]
700a13e6: f00b fc8b    	bl	0x700acd00 <Udma_chSetPeerReg> @ imm = #0xb916
;         }
700a13ea: e03c         	b	0x700a1466 <Udma_chConfigPdma+0x176> @ imm = #0x78
;         else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a13ec: 9803         	ldr	r0, [sp, #0xc]
700a13ee: 6800         	ldr	r0, [r0]
700a13f0: 2802         	cmp	r0, #0x2
700a13f2: d137         	bne	0x700a1464 <Udma_chConfigPdma+0x174> @ imm = #0x6e
700a13f4: e7ff         	b	0x700a13f6 <Udma_chConfigPdma+0x106> @ imm = #-0x2
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a13f6: 9802         	ldr	r0, [sp, #0x8]
700a13f8: 7800         	ldrb	r0, [r0]
700a13fa: 07c0         	lsls	r0, r0, #0x1f
700a13fc: b198         	cbz	r0, 0x700a1426 <Udma_chConfigPdma+0x136> @ imm = #0x26
700a13fe: e7ff         	b	0x700a1400 <Udma_chConfigPdma+0x110> @ imm = #-0x2
;                 PEER8 = &chHandleInt->pPktdmaTxRtRegs->PEER8;
700a1400: 9802         	ldr	r0, [sp, #0x8]
700a1402: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a1406: f500 7008    	add.w	r0, r0, #0x220
700a140a: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaTxRtRegs->PEER1;
700a140c: 9802         	ldr	r0, [sp, #0x8]
700a140e: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a1412: f500 7001    	add.w	r0, r0, #0x204
700a1416: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaTxRtRegs->PEER0;
700a1418: 9802         	ldr	r0, [sp, #0x8]
700a141a: f8d0 0230    	ldr.w	r0, [r0, #0x230]
700a141e: f500 7000    	add.w	r0, r0, #0x200
700a1422: 9005         	str	r0, [sp, #0x14]
;             }
700a1424: e012         	b	0x700a144c <Udma_chConfigPdma+0x15c> @ imm = #0x24
;                 PEER8 = &chHandleInt->pPktdmaRxRtRegs->PEER8;
700a1426: 9802         	ldr	r0, [sp, #0x8]
700a1428: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a142c: f500 7008    	add.w	r0, r0, #0x220
700a1430: 9006         	str	r0, [sp, #0x18]
;                 PEER1 = &chHandleInt->pPktdmaRxRtRegs->PEER1;
700a1432: 9802         	ldr	r0, [sp, #0x8]
700a1434: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a1438: f500 7001    	add.w	r0, r0, #0x204
700a143c: 9004         	str	r0, [sp, #0x10]
;                 PEER0 = &chHandleInt->pPktdmaRxRtRegs->PEER0;
700a143e: 9802         	ldr	r0, [sp, #0x8]
700a1440: f8d0 0238    	ldr.w	r0, [r0, #0x238]
700a1444: f500 7000    	add.w	r0, r0, #0x200
700a1448: 9005         	str	r0, [sp, #0x14]
700a144a: e7ff         	b	0x700a144c <Udma_chConfigPdma+0x15c> @ imm = #-0x2
;             Udma_chSetPeerReg(drvHandle, pdmaPrms, PEER8, PEER1, PEER0);
700a144c: 9803         	ldr	r0, [sp, #0xc]
700a144e: 9908         	ldr	r1, [sp, #0x20]
700a1450: 9a06         	ldr	r2, [sp, #0x18]
700a1452: 9b04         	ldr	r3, [sp, #0x10]
700a1454: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a1458: 46ee         	mov	lr, sp
700a145a: f8ce c000    	str.w	r12, [lr]
700a145e: f00b fc4f    	bl	0x700acd00 <Udma_chSetPeerReg> @ imm = #0xb89e
;         }
700a1462: e7ff         	b	0x700a1464 <Udma_chConfigPdma+0x174> @ imm = #-0x2
700a1464: e7ff         	b	0x700a1466 <Udma_chConfigPdma+0x176> @ imm = #-0x2
;     }
700a1466: e7ff         	b	0x700a1468 <Udma_chConfigPdma+0x178> @ imm = #-0x2
;     return (retVal);
700a1468: 9807         	ldr	r0, [sp, #0x1c]
700a146a: b00a         	add	sp, #0x28
700a146c: bd80         	pop	{r7, pc}
700a146e: 0000         	movs	r0, r0

700a1470 <xQueueSemaphoreTake>:
; {
700a1470: b580         	push	{r7, lr}
700a1472: b08a         	sub	sp, #0x28
700a1474: 9008         	str	r0, [sp, #0x20]
700a1476: 9107         	str	r1, [sp, #0x1c]
700a1478: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
700a147a: 9006         	str	r0, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a147c: 9908         	ldr	r1, [sp, #0x20]
700a147e: 9103         	str	r1, [sp, #0xc]
;         BaseType_t xInheritanceOccurred = pdFALSE;
700a1480: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
700a1482: e7ff         	b	0x700a1484 <xQueueSemaphoreTake+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a1484: f00d f974    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0xd2e8
;             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
700a1488: 9803         	ldr	r0, [sp, #0xc]
700a148a: 6b80         	ldr	r0, [r0, #0x38]
700a148c: 9001         	str	r0, [sp, #0x4]
;             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
700a148e: 9801         	ldr	r0, [sp, #0x4]
700a1490: b310         	cbz	r0, 0x700a14d8 <xQueueSemaphoreTake+0x68> @ imm = #0x44
700a1492: e7ff         	b	0x700a1494 <xQueueSemaphoreTake+0x24> @ imm = #-0x2
;                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
700a1494: 9801         	ldr	r0, [sp, #0x4]
700a1496: 3801         	subs	r0, #0x1
700a1498: 9903         	ldr	r1, [sp, #0xc]
700a149a: 6388         	str	r0, [r1, #0x38]
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a149c: 9803         	ldr	r0, [sp, #0xc]
700a149e: 6800         	ldr	r0, [r0]
700a14a0: b928         	cbnz	r0, 0x700a14ae <xQueueSemaphoreTake+0x3e> @ imm = #0xa
700a14a2: e7ff         	b	0x700a14a4 <xQueueSemaphoreTake+0x34> @ imm = #-0x2
;                             pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
700a14a4: f00d fbe4    	bl	0x700aec70 <pvTaskIncrementMutexHeldCount> @ imm = #0xd7c8
700a14a8: 9903         	ldr	r1, [sp, #0xc]
700a14aa: 6088         	str	r0, [r1, #0x8]
;                         }
700a14ac: e000         	b	0x700a14b0 <xQueueSemaphoreTake+0x40> @ imm = #0x0
700a14ae: e7ff         	b	0x700a14b0 <xQueueSemaphoreTake+0x40> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a14b0: 9803         	ldr	r0, [sp, #0xc]
700a14b2: 6900         	ldr	r0, [r0, #0x10]
700a14b4: b150         	cbz	r0, 0x700a14cc <xQueueSemaphoreTake+0x5c> @ imm = #0x14
700a14b6: e7ff         	b	0x700a14b8 <xQueueSemaphoreTake+0x48> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a14b8: 9803         	ldr	r0, [sp, #0xc]
700a14ba: 3010         	adds	r0, #0x10
700a14bc: f006 fb20    	bl	0x700a7b00 <xTaskRemoveFromEventList> @ imm = #0x6640
700a14c0: b110         	cbz	r0, 0x700a14c8 <xQueueSemaphoreTake+0x58> @ imm = #0x4
700a14c2: e7ff         	b	0x700a14c4 <xQueueSemaphoreTake+0x54> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
700a14c4: df00         	svc	#0x0
;                     }
700a14c6: e000         	b	0x700a14ca <xQueueSemaphoreTake+0x5a> @ imm = #0x0
700a14c8: e7ff         	b	0x700a14ca <xQueueSemaphoreTake+0x5a> @ imm = #-0x2
;                 }
700a14ca: e000         	b	0x700a14ce <xQueueSemaphoreTake+0x5e> @ imm = #0x0
700a14cc: e7ff         	b	0x700a14ce <xQueueSemaphoreTake+0x5e> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a14ce: f00c fa0f    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xc41e
700a14d2: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a14d4: 9009         	str	r0, [sp, #0x24]
700a14d6: e083         	b	0x700a15e0 <xQueueSemaphoreTake+0x170> @ imm = #0x106
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a14d8: 9807         	ldr	r0, [sp, #0x1c]
700a14da: b928         	cbnz	r0, 0x700a14e8 <xQueueSemaphoreTake+0x78> @ imm = #0xa
700a14dc: e7ff         	b	0x700a14de <xQueueSemaphoreTake+0x6e> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a14de: f00c fa07    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xc40e
700a14e2: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
700a14e4: 9009         	str	r0, [sp, #0x24]
700a14e6: e07b         	b	0x700a15e0 <xQueueSemaphoreTake+0x170> @ imm = #0xf6
;                 else if( xEntryTimeSet == pdFALSE )
700a14e8: 9806         	ldr	r0, [sp, #0x18]
700a14ea: b930         	cbnz	r0, 0x700a14fa <xQueueSemaphoreTake+0x8a> @ imm = #0xc
700a14ec: e7ff         	b	0x700a14ee <xQueueSemaphoreTake+0x7e> @ imm = #-0x2
700a14ee: a804         	add	r0, sp, #0x10
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a14f0: f00d feb6    	bl	0x700af260 <vTaskInternalSetTimeOutState> @ imm = #0xdd6c
700a14f4: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a14f6: 9006         	str	r0, [sp, #0x18]
;                 }
700a14f8: e000         	b	0x700a14fc <xQueueSemaphoreTake+0x8c> @ imm = #0x0
700a14fa: e7ff         	b	0x700a14fc <xQueueSemaphoreTake+0x8c> @ imm = #-0x2
700a14fc: e7ff         	b	0x700a14fe <xQueueSemaphoreTake+0x8e> @ imm = #-0x2
700a14fe: e7ff         	b	0x700a1500 <xQueueSemaphoreTake+0x90> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a1500: f00c f9f6    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xc3ec
;         vTaskSuspendAll();
700a1504: f00e fb5c    	bl	0x700afbc0 <vTaskSuspendAll> @ imm = #0xe6b8
;         prvLockQueue( pxQueue );
700a1508: f00d f932    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0xd264
700a150c: 9803         	ldr	r0, [sp, #0xc]
700a150e: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a1512: 3001         	adds	r0, #0x1
700a1514: b928         	cbnz	r0, 0x700a1522 <xQueueSemaphoreTake+0xb2> @ imm = #0xa
700a1516: e7ff         	b	0x700a1518 <xQueueSemaphoreTake+0xa8> @ imm = #-0x2
700a1518: 9903         	ldr	r1, [sp, #0xc]
700a151a: 2000         	movs	r0, #0x0
700a151c: f881 0044    	strb.w	r0, [r1, #0x44]
700a1520: e7ff         	b	0x700a1522 <xQueueSemaphoreTake+0xb2> @ imm = #-0x2
700a1522: 9803         	ldr	r0, [sp, #0xc]
700a1524: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a1528: 3001         	adds	r0, #0x1
700a152a: b928         	cbnz	r0, 0x700a1538 <xQueueSemaphoreTake+0xc8> @ imm = #0xa
700a152c: e7ff         	b	0x700a152e <xQueueSemaphoreTake+0xbe> @ imm = #-0x2
700a152e: 9903         	ldr	r1, [sp, #0xc]
700a1530: 2000         	movs	r0, #0x0
700a1532: f881 0045    	strb.w	r0, [r1, #0x45]
700a1536: e7ff         	b	0x700a1538 <xQueueSemaphoreTake+0xc8> @ imm = #-0x2
700a1538: f00c f9da    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xc3b4
700a153c: a804         	add	r0, sp, #0x10
700a153e: a907         	add	r1, sp, #0x1c
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a1540: f007 fe96    	bl	0x700a9270 <xTaskCheckForTimeOut> @ imm = #0x7d2c
700a1544: bb58         	cbnz	r0, 0x700a159e <xQueueSemaphoreTake+0x12e> @ imm = #0x56
700a1546: e7ff         	b	0x700a1548 <xQueueSemaphoreTake+0xd8> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a1548: 9803         	ldr	r0, [sp, #0xc]
700a154a: f00d fcc9    	bl	0x700aeee0 <prvIsQueueEmpty> @ imm = #0xd992
700a154e: b1f8         	cbz	r0, 0x700a1590 <xQueueSemaphoreTake+0x120> @ imm = #0x3e
700a1550: e7ff         	b	0x700a1552 <xQueueSemaphoreTake+0xe2> @ imm = #-0x2
;                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a1552: 9803         	ldr	r0, [sp, #0xc]
700a1554: 6800         	ldr	r0, [r0]
700a1556: b950         	cbnz	r0, 0x700a156e <xQueueSemaphoreTake+0xfe> @ imm = #0x14
700a1558: e7ff         	b	0x700a155a <xQueueSemaphoreTake+0xea> @ imm = #-0x2
;                             taskENTER_CRITICAL();
700a155a: f00d f909    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0xd212
;                                 xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
700a155e: 9803         	ldr	r0, [sp, #0xc]
700a1560: 6880         	ldr	r0, [r0, #0x8]
700a1562: f003 fe45    	bl	0x700a51f0 <xTaskPriorityInherit> @ imm = #0x3c8a
700a1566: 9002         	str	r0, [sp, #0x8]
;                             taskEXIT_CRITICAL();
700a1568: f00c f9c2    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xc384
;                         }
700a156c: e000         	b	0x700a1570 <xQueueSemaphoreTake+0x100> @ imm = #0x0
700a156e: e7ff         	b	0x700a1570 <xQueueSemaphoreTake+0x100> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
700a1570: 9803         	ldr	r0, [sp, #0xc]
700a1572: 3024         	adds	r0, #0x24
700a1574: 9907         	ldr	r1, [sp, #0x1c]
700a1576: f00d fd73    	bl	0x700af060 <vTaskPlaceOnEventList> @ imm = #0xdae6
;                 prvUnlockQueue( pxQueue );
700a157a: 9803         	ldr	r0, [sp, #0xc]
700a157c: f006 fc88    	bl	0x700a7e90 <prvUnlockQueue> @ imm = #0x6910
;                 if( xTaskResumeAll() == pdFALSE )
700a1580: f000 fe86    	bl	0x700a2290 <xTaskResumeAll> @ imm = #0xd0c
700a1584: b910         	cbnz	r0, 0x700a158c <xQueueSemaphoreTake+0x11c> @ imm = #0x4
700a1586: e7ff         	b	0x700a1588 <xQueueSemaphoreTake+0x118> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a1588: df00         	svc	#0x0
;                 }
700a158a: e000         	b	0x700a158e <xQueueSemaphoreTake+0x11e> @ imm = #0x0
700a158c: e7ff         	b	0x700a158e <xQueueSemaphoreTake+0x11e> @ imm = #-0x2
;             }
700a158e: e005         	b	0x700a159c <xQueueSemaphoreTake+0x12c> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a1590: 9803         	ldr	r0, [sp, #0xc]
700a1592: f006 fc7d    	bl	0x700a7e90 <prvUnlockQueue> @ imm = #0x68fa
;                 ( void ) xTaskResumeAll();
700a1596: f000 fe7b    	bl	0x700a2290 <xTaskResumeAll> @ imm = #0xcf6
700a159a: e7ff         	b	0x700a159c <xQueueSemaphoreTake+0x12c> @ imm = #-0x2
;         }
700a159c: e01f         	b	0x700a15de <xQueueSemaphoreTake+0x16e> @ imm = #0x3e
;             prvUnlockQueue( pxQueue );
700a159e: 9803         	ldr	r0, [sp, #0xc]
700a15a0: f006 fc76    	bl	0x700a7e90 <prvUnlockQueue> @ imm = #0x68ec
;             ( void ) xTaskResumeAll();
700a15a4: f000 fe74    	bl	0x700a2290 <xTaskResumeAll> @ imm = #0xce8
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a15a8: 9803         	ldr	r0, [sp, #0xc]
700a15aa: f00d fc99    	bl	0x700aeee0 <prvIsQueueEmpty> @ imm = #0xd932
700a15ae: b1a0         	cbz	r0, 0x700a15da <xQueueSemaphoreTake+0x16a> @ imm = #0x28
700a15b0: e7ff         	b	0x700a15b2 <xQueueSemaphoreTake+0x142> @ imm = #-0x2
;                         if( xInheritanceOccurred != pdFALSE )
700a15b2: 9802         	ldr	r0, [sp, #0x8]
700a15b4: b170         	cbz	r0, 0x700a15d4 <xQueueSemaphoreTake+0x164> @ imm = #0x1c
700a15b6: e7ff         	b	0x700a15b8 <xQueueSemaphoreTake+0x148> @ imm = #-0x2
;                             taskENTER_CRITICAL();
700a15b8: f00d f8da    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0xd1b4
;                                 uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
700a15bc: 9803         	ldr	r0, [sp, #0xc]
700a15be: f00d fd37    	bl	0x700af030 <prvGetDisinheritPriorityAfterTimeout> @ imm = #0xda6e
700a15c2: 9000         	str	r0, [sp]
;                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
700a15c4: 9803         	ldr	r0, [sp, #0xc]
700a15c6: 6880         	ldr	r0, [r0, #0x8]
700a15c8: 9900         	ldr	r1, [sp]
700a15ca: f004 faa9    	bl	0x700a5b20 <vTaskPriorityDisinheritAfterTimeout> @ imm = #0x4552
;                             taskEXIT_CRITICAL();
700a15ce: f00c f98f    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xc31e
;                         }
700a15d2: e7ff         	b	0x700a15d4 <xQueueSemaphoreTake+0x164> @ imm = #-0x2
700a15d4: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
700a15d6: 9009         	str	r0, [sp, #0x24]
700a15d8: e002         	b	0x700a15e0 <xQueueSemaphoreTake+0x170> @ imm = #0x4
700a15da: e7ff         	b	0x700a15dc <xQueueSemaphoreTake+0x16c> @ imm = #-0x2
700a15dc: e7ff         	b	0x700a15de <xQueueSemaphoreTake+0x16e> @ imm = #-0x2
;     for( ; ; )
700a15de: e751         	b	0x700a1484 <xQueueSemaphoreTake+0x14> @ imm = #-0x15e
; }
700a15e0: 9809         	ldr	r0, [sp, #0x24]
700a15e2: b00a         	add	sp, #0x28
700a15e4: bd80         	pop	{r7, pc}
		...
700a15ee: 0000         	movs	r0, r0

700a15f0 <xTaskIncrementTick>:
; BaseType_t xTaskIncrementTick(void) {
700a15f0: b580         	push	{r7, lr}
700a15f2: b086         	sub	sp, #0x18
700a15f4: 2000         	movs	r0, #0x0
;   BaseType_t xSwitchRequired = pdFALSE;
700a15f6: 9003         	str	r0, [sp, #0xc]
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a15f8: f642 2024    	movw	r0, #0x2a24
700a15fc: f2c7 000b    	movt	r0, #0x700b
700a1600: 6800         	ldr	r0, [r0]
700a1602: 2800         	cmp	r0, #0x0
700a1604: f040 80a3    	bne.w	0x700a174e <xTaskIncrementTick+0x15e> @ imm = #0x146
700a1608: e7ff         	b	0x700a160a <xTaskIncrementTick+0x1a> @ imm = #-0x2
;     const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
700a160a: f642 2144    	movw	r1, #0x2a44
700a160e: f2c7 010b    	movt	r1, #0x700b
700a1612: 6808         	ldr	r0, [r1]
700a1614: 3001         	adds	r0, #0x1
700a1616: 9002         	str	r0, [sp, #0x8]
;     xTickCount = xConstTickCount;
700a1618: 9802         	ldr	r0, [sp, #0x8]
700a161a: 6008         	str	r0, [r1]
;     if (xConstTickCount ==
700a161c: 9802         	ldr	r0, [sp, #0x8]
700a161e: b9c0         	cbnz	r0, 0x700a1652 <xTaskIncrementTick+0x62> @ imm = #0x30
700a1620: e7ff         	b	0x700a1622 <xTaskIncrementTick+0x32> @ imm = #-0x2
;       taskSWITCH_DELAYED_LISTS();
700a1622: f245 22a0    	movw	r2, #0x52a0
700a1626: f2c7 0208    	movt	r2, #0x7008
700a162a: 6810         	ldr	r0, [r2]
700a162c: 9001         	str	r0, [sp, #0x4]
700a162e: f245 21a4    	movw	r1, #0x52a4
700a1632: f2c7 0108    	movt	r1, #0x7008
700a1636: 6808         	ldr	r0, [r1]
700a1638: 6010         	str	r0, [r2]
700a163a: 9801         	ldr	r0, [sp, #0x4]
700a163c: 6008         	str	r0, [r1]
700a163e: f642 2138    	movw	r1, #0x2a38
700a1642: f2c7 010b    	movt	r1, #0x700b
700a1646: 6808         	ldr	r0, [r1]
700a1648: 3001         	adds	r0, #0x1
700a164a: 6008         	str	r0, [r1]
700a164c: f00c fd98    	bl	0x700ae180 <prvResetNextTaskUnblockTime> @ imm = #0xcb30
;     } else {
700a1650: e000         	b	0x700a1654 <xTaskIncrementTick+0x64> @ imm = #0x0
700a1652: e7ff         	b	0x700a1654 <xTaskIncrementTick+0x64> @ imm = #-0x2
;     if (xConstTickCount >= xNextTaskUnblockTime) {
700a1654: 9802         	ldr	r0, [sp, #0x8]
700a1656: f642 2134    	movw	r1, #0x2a34
700a165a: f2c7 010b    	movt	r1, #0x700b
700a165e: 6809         	ldr	r1, [r1]
700a1660: 4288         	cmp	r0, r1
700a1662: d368         	blo	0x700a1736 <xTaskIncrementTick+0x146> @ imm = #0xd0
700a1664: e7ff         	b	0x700a1666 <xTaskIncrementTick+0x76> @ imm = #-0x2
;       for (;;) {
700a1666: e7ff         	b	0x700a1668 <xTaskIncrementTick+0x78> @ imm = #-0x2
;         if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
700a1668: f245 20a0    	movw	r0, #0x52a0
700a166c: f2c7 0008    	movt	r0, #0x7008
700a1670: 6800         	ldr	r0, [r0]
700a1672: 6800         	ldr	r0, [r0]
700a1674: b940         	cbnz	r0, 0x700a1688 <xTaskIncrementTick+0x98> @ imm = #0x10
700a1676: e7ff         	b	0x700a1678 <xTaskIncrementTick+0x88> @ imm = #-0x2
;           xNextTaskUnblockTime =
700a1678: f642 2134    	movw	r1, #0x2a34
700a167c: f2c7 010b    	movt	r1, #0x700b
700a1680: f04f 30ff    	mov.w	r0, #0xffffffff
700a1684: 6008         	str	r0, [r1]
;           break;
700a1686: e055         	b	0x700a1734 <xTaskIncrementTick+0x144> @ imm = #0xaa
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a1688: f245 20a0    	movw	r0, #0x52a0
700a168c: f2c7 0008    	movt	r0, #0x7008
700a1690: 6800         	ldr	r0, [r0]
700a1692: 68c0         	ldr	r0, [r0, #0xc]
700a1694: 68c0         	ldr	r0, [r0, #0xc]
700a1696: 9005         	str	r0, [sp, #0x14]
;           xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
700a1698: 9805         	ldr	r0, [sp, #0x14]
700a169a: 6840         	ldr	r0, [r0, #0x4]
700a169c: 9004         	str	r0, [sp, #0x10]
;           if (xConstTickCount < xItemValue) {
700a169e: 9802         	ldr	r0, [sp, #0x8]
700a16a0: 9904         	ldr	r1, [sp, #0x10]
700a16a2: 4288         	cmp	r0, r1
700a16a4: d207         	bhs	0x700a16b6 <xTaskIncrementTick+0xc6> @ imm = #0xe
700a16a6: e7ff         	b	0x700a16a8 <xTaskIncrementTick+0xb8> @ imm = #-0x2
;             xNextTaskUnblockTime = xItemValue;
700a16a8: 9804         	ldr	r0, [sp, #0x10]
700a16aa: f642 2134    	movw	r1, #0x2a34
700a16ae: f2c7 010b    	movt	r1, #0x700b
700a16b2: 6008         	str	r0, [r1]
;             break; /*lint !e9011 Code structure here is deedmed easier to
700a16b4: e03e         	b	0x700a1734 <xTaskIncrementTick+0x144> @ imm = #0x7c
700a16b6: e7ff         	b	0x700a16b8 <xTaskIncrementTick+0xc8> @ imm = #-0x2
;           (void)uxListRemove(&(pxTCB->xStateListItem));
700a16b8: 9805         	ldr	r0, [sp, #0x14]
700a16ba: 3004         	adds	r0, #0x4
700a16bc: f00c f828    	bl	0x700ad710 <uxListRemove> @ imm = #0xc050
;           if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a16c0: 9805         	ldr	r0, [sp, #0x14]
700a16c2: 6a80         	ldr	r0, [r0, #0x28]
700a16c4: b128         	cbz	r0, 0x700a16d2 <xTaskIncrementTick+0xe2> @ imm = #0xa
700a16c6: e7ff         	b	0x700a16c8 <xTaskIncrementTick+0xd8> @ imm = #-0x2
;             (void)uxListRemove(&(pxTCB->xEventListItem));
700a16c8: 9805         	ldr	r0, [sp, #0x14]
700a16ca: 3018         	adds	r0, #0x18
700a16cc: f00c f820    	bl	0x700ad710 <uxListRemove> @ imm = #0xc040
;           } else {
700a16d0: e000         	b	0x700a16d4 <xTaskIncrementTick+0xe4> @ imm = #0x0
700a16d2: e7ff         	b	0x700a16d4 <xTaskIncrementTick+0xe4> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
700a16d4: 9805         	ldr	r0, [sp, #0x14]
700a16d6: 6ac0         	ldr	r0, [r0, #0x2c]
700a16d8: f642 212c    	movw	r1, #0x2a2c
700a16dc: f2c7 010b    	movt	r1, #0x700b
700a16e0: 6809         	ldr	r1, [r1]
700a16e2: 4288         	cmp	r0, r1
700a16e4: d908         	bls	0x700a16f8 <xTaskIncrementTick+0x108> @ imm = #0x10
700a16e6: e7ff         	b	0x700a16e8 <xTaskIncrementTick+0xf8> @ imm = #-0x2
700a16e8: 9805         	ldr	r0, [sp, #0x14]
700a16ea: 6ac0         	ldr	r0, [r0, #0x2c]
700a16ec: f642 212c    	movw	r1, #0x2a2c
700a16f0: f2c7 010b    	movt	r1, #0x700b
700a16f4: 6008         	str	r0, [r1]
700a16f6: e7ff         	b	0x700a16f8 <xTaskIncrementTick+0x108> @ imm = #-0x2
700a16f8: 9905         	ldr	r1, [sp, #0x14]
700a16fa: 6ac8         	ldr	r0, [r1, #0x2c]
700a16fc: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a1700: f244 40f8    	movw	r0, #0x44f8
700a1704: f2c7 0008    	movt	r0, #0x7008
700a1708: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a170c: 3104         	adds	r1, #0x4
700a170e: f00c fdb7    	bl	0x700ae280 <vListInsertEnd> @ imm = #0xcb6e
;             if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a1712: 9805         	ldr	r0, [sp, #0x14]
700a1714: 6ac0         	ldr	r0, [r0, #0x2c]
700a1716: f642 11fc    	movw	r1, #0x29fc
700a171a: f2c7 010b    	movt	r1, #0x700b
700a171e: 6809         	ldr	r1, [r1]
700a1720: 6ac9         	ldr	r1, [r1, #0x2c]
700a1722: 4288         	cmp	r0, r1
700a1724: d303         	blo	0x700a172e <xTaskIncrementTick+0x13e> @ imm = #0x6
700a1726: e7ff         	b	0x700a1728 <xTaskIncrementTick+0x138> @ imm = #-0x2
700a1728: 2001         	movs	r0, #0x1
;               xSwitchRequired = pdTRUE;
700a172a: 9003         	str	r0, [sp, #0xc]
;             } else {
700a172c: e000         	b	0x700a1730 <xTaskIncrementTick+0x140> @ imm = #0x0
700a172e: e7ff         	b	0x700a1730 <xTaskIncrementTick+0x140> @ imm = #-0x2
700a1730: e7ff         	b	0x700a1732 <xTaskIncrementTick+0x142> @ imm = #-0x2
;       for (;;) {
700a1732: e799         	b	0x700a1668 <xTaskIncrementTick+0x78> @ imm = #-0xce
;     }
700a1734: e7ff         	b	0x700a1736 <xTaskIncrementTick+0x146> @ imm = #-0x2
;       if (xYieldPending != pdFALSE) {
700a1736: f642 2050    	movw	r0, #0x2a50
700a173a: f2c7 000b    	movt	r0, #0x700b
700a173e: 6800         	ldr	r0, [r0]
700a1740: b118         	cbz	r0, 0x700a174a <xTaskIncrementTick+0x15a> @ imm = #0x6
700a1742: e7ff         	b	0x700a1744 <xTaskIncrementTick+0x154> @ imm = #-0x2
700a1744: 2001         	movs	r0, #0x1
;         xSwitchRequired = pdTRUE;
700a1746: 9003         	str	r0, [sp, #0xc]
;       } else {
700a1748: e000         	b	0x700a174c <xTaskIncrementTick+0x15c> @ imm = #0x0
700a174a: e7ff         	b	0x700a174c <xTaskIncrementTick+0x15c> @ imm = #-0x2
;   } else {
700a174c: e007         	b	0x700a175e <xTaskIncrementTick+0x16e> @ imm = #0xe
;     ++xPendedTicks;
700a174e: f642 213c    	movw	r1, #0x2a3c
700a1752: f2c7 010b    	movt	r1, #0x700b
700a1756: 6808         	ldr	r0, [r1]
700a1758: 3001         	adds	r0, #0x1
700a175a: 6008         	str	r0, [r1]
700a175c: e7ff         	b	0x700a175e <xTaskIncrementTick+0x16e> @ imm = #-0x2
;   return xSwitchRequired;
700a175e: 9803         	ldr	r0, [sp, #0xc]
700a1760: b006         	add	sp, #0x18
700a1762: bd80         	pop	{r7, pc}
		...

700a1770 <CSL_bcdmaChanOpTeardownChan>:
; {
700a1770: b580         	push	{r7, lr}
700a1772: b08c         	sub	sp, #0x30
700a1774: 900b         	str	r0, [sp, #0x2c]
700a1776: 910a         	str	r1, [sp, #0x28]
700a1778: 9209         	str	r2, [sp, #0x24]
700a177a: 9308         	str	r3, [sp, #0x20]
700a177c: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
700a177e: 9007         	str	r0, [sp, #0x1c]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
700a1780: 980b         	ldr	r0, [sp, #0x2c]
700a1782: 990a         	ldr	r1, [sp, #0x28]
700a1784: 9a09         	ldr	r2, [sp, #0x24]
700a1786: f009 f93b    	bl	0x700aaa00 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x9276
700a178a: b920         	cbnz	r0, 0x700a1796 <CSL_bcdmaChanOpTeardownChan+0x26> @ imm = #0x8
700a178c: e7ff         	b	0x700a178e <CSL_bcdmaChanOpTeardownChan+0x1e> @ imm = #-0x2
700a178e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a1792: 9007         	str	r0, [sp, #0x1c]
;     }
700a1794: e09f         	b	0x700a18d6 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #0x13e
700a1796: 2000         	movs	r0, #0x0
;         uint32_t force = (uint32_t)0U, wait = (uint32_t)0U;
700a1798: 9005         	str	r0, [sp, #0x14]
700a179a: 9004         	str	r0, [sp, #0x10]
;         if( pOpData != NULL )
700a179c: 9808         	ldr	r0, [sp, #0x20]
700a179e: b148         	cbz	r0, 0x700a17b4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #0x12
700a17a0: e7ff         	b	0x700a17a2 <CSL_bcdmaChanOpTeardownChan+0x32> @ imm = #-0x2
;             CSL_BcdmaTeardownOpts *pTdOpts = (CSL_BcdmaTeardownOpts *)pOpData;
700a17a2: 9808         	ldr	r0, [sp, #0x20]
700a17a4: 9003         	str	r0, [sp, #0xc]
;             force = pTdOpts->force;
700a17a6: 9803         	ldr	r0, [sp, #0xc]
700a17a8: 6800         	ldr	r0, [r0]
700a17aa: 9005         	str	r0, [sp, #0x14]
;             wait  = pTdOpts->wait;
700a17ac: 9803         	ldr	r0, [sp, #0xc]
700a17ae: 6840         	ldr	r0, [r0, #0x4]
700a17b0: 9004         	str	r0, [sp, #0x10]
;         }
700a17b2: e7ff         	b	0x700a17b4 <CSL_bcdmaChanOpTeardownChan+0x44> @ imm = #-0x2
;         switch( chanType )
700a17b4: 980a         	ldr	r0, [sp, #0x28]
700a17b6: 9001         	str	r0, [sp, #0x4]
700a17b8: b148         	cbz	r0, 0x700a17ce <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #0x12
700a17ba: e7ff         	b	0x700a17bc <CSL_bcdmaChanOpTeardownChan+0x4c> @ imm = #-0x2
700a17bc: 9801         	ldr	r0, [sp, #0x4]
700a17be: 2801         	cmp	r0, #0x1
700a17c0: d024         	beq	0x700a180c <CSL_bcdmaChanOpTeardownChan+0x9c> @ imm = #0x48
700a17c2: e7ff         	b	0x700a17c4 <CSL_bcdmaChanOpTeardownChan+0x54> @ imm = #-0x2
700a17c4: 9801         	ldr	r0, [sp, #0x4]
700a17c6: 2802         	cmp	r0, #0x2
700a17c8: d03f         	beq	0x700a184a <CSL_bcdmaChanOpTeardownChan+0xda> @ imm = #0x7e
700a17ca: e7ff         	b	0x700a17cc <CSL_bcdmaChanOpTeardownChan+0x5c> @ imm = #-0x2
;         {
700a17cc: e7ff         	b	0x700a17ce <CSL_bcdmaChanOpTeardownChan+0x5e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
700a17ce: 980b         	ldr	r0, [sp, #0x2c]
700a17d0: 6880         	ldr	r0, [r0, #0x8]
700a17d2: 9909         	ldr	r1, [sp, #0x24]
700a17d4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a17d8: f00e fa12    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xe424
700a17dc: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a17de: 9806         	ldr	r0, [sp, #0x18]
700a17e0: f040 4080    	orr	r0, r0, #0x40000000
700a17e4: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_BCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a17e6: 9806         	ldr	r0, [sp, #0x18]
700a17e8: f020 5180    	bic	r1, r0, #0x10000000
700a17ec: 9a05         	ldr	r2, [sp, #0x14]
700a17ee: f101 5080    	add.w	r0, r1, #0x10000000
700a17f2: 2a00         	cmp	r2, #0x0
700a17f4: bf08         	it	eq
700a17f6: 4608         	moveq	r0, r1
700a17f8: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a17fa: 980b         	ldr	r0, [sp, #0x2c]
700a17fc: 6880         	ldr	r0, [r0, #0x8]
700a17fe: 9909         	ldr	r1, [sp, #0x24]
700a1800: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1804: 9906         	ldr	r1, [sp, #0x18]
700a1806: f7fa fd43    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x557a
;                 break;
700a180a: e03d         	b	0x700a1888 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x7a
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a180c: 980b         	ldr	r0, [sp, #0x2c]
700a180e: 6900         	ldr	r0, [r0, #0x10]
700a1810: 9909         	ldr	r1, [sp, #0x24]
700a1812: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1816: f00e f9f3    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xe3e6
700a181a: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a181c: 9806         	ldr	r0, [sp, #0x18]
700a181e: f040 4080    	orr	r0, r0, #0x40000000
700a1822: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_TXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a1824: 9806         	ldr	r0, [sp, #0x18]
700a1826: f020 5180    	bic	r1, r0, #0x10000000
700a182a: 9a05         	ldr	r2, [sp, #0x14]
700a182c: f101 5080    	add.w	r0, r1, #0x10000000
700a1830: 2a00         	cmp	r2, #0x0
700a1832: bf08         	it	eq
700a1834: 4608         	moveq	r0, r1
700a1836: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a1838: 980b         	ldr	r0, [sp, #0x2c]
700a183a: 6900         	ldr	r0, [r0, #0x10]
700a183c: 9909         	ldr	r1, [sp, #0x24]
700a183e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1842: 9906         	ldr	r1, [sp, #0x18]
700a1844: f7fa fd24    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x55b8
;                 break;
700a1848: e01e         	b	0x700a1888 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #0x3c
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a184a: 980b         	ldr	r0, [sp, #0x2c]
700a184c: 6980         	ldr	r0, [r0, #0x18]
700a184e: 9909         	ldr	r1, [sp, #0x24]
700a1850: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1854: f00e f9d4    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xe3a8
700a1858: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a185a: 9806         	ldr	r0, [sp, #0x18]
700a185c: f040 4080    	orr	r0, r0, #0x40000000
700a1860: 9006         	str	r0, [sp, #0x18]
;                 CSL_FINS( regVal, BCDMA_RXCRT_CHAN_CTL_FTDOWN, (force==0U) ? (uint32_t)0U : (uint32_t)1U  );
700a1862: 9806         	ldr	r0, [sp, #0x18]
700a1864: f020 5180    	bic	r1, r0, #0x10000000
700a1868: 9a05         	ldr	r2, [sp, #0x14]
700a186a: f101 5080    	add.w	r0, r1, #0x10000000
700a186e: 2a00         	cmp	r2, #0x0
700a1870: bf08         	it	eq
700a1872: 4608         	moveq	r0, r1
700a1874: 9006         	str	r0, [sp, #0x18]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a1876: 980b         	ldr	r0, [sp, #0x2c]
700a1878: 6980         	ldr	r0, [r0, #0x18]
700a187a: 9909         	ldr	r1, [sp, #0x24]
700a187c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1880: 9906         	ldr	r1, [sp, #0x18]
700a1882: f7fa fd05    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x55f6
;                 break;
700a1886: e7ff         	b	0x700a1888 <CSL_bcdmaChanOpTeardownChan+0x118> @ imm = #-0x2
;         if(wait != 0U)
700a1888: 9804         	ldr	r0, [sp, #0x10]
700a188a: b318         	cbz	r0, 0x700a18d4 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #0x46
700a188c: e7ff         	b	0x700a188e <CSL_bcdmaChanOpTeardownChan+0x11e> @ imm = #-0x2
700a188e: 2080         	movs	r0, #0x80
;             uint32_t retryCnt = CSL_BCDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
700a1890: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a1892: e7ff         	b	0x700a1894 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x2
700a1894: 980b         	ldr	r0, [sp, #0x2c]
700a1896: 990a         	ldr	r1, [sp, #0x28]
700a1898: 9a09         	ldr	r2, [sp, #0x24]
700a189a: f009 f8b1    	bl	0x700aaa00 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x9162
700a189e: 4601         	mov	r1, r0
700a18a0: 2000         	movs	r0, #0x0
700a18a2: 9000         	str	r0, [sp]
700a18a4: b131         	cbz	r1, 0x700a18b4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #0xc
700a18a6: e7ff         	b	0x700a18a8 <CSL_bcdmaChanOpTeardownChan+0x138> @ imm = #-0x2
700a18a8: 9802         	ldr	r0, [sp, #0x8]
700a18aa: 2800         	cmp	r0, #0x0
700a18ac: bf18         	it	ne
700a18ae: 2001         	movne	r0, #0x1
700a18b0: 9000         	str	r0, [sp]
700a18b2: e7ff         	b	0x700a18b4 <CSL_bcdmaChanOpTeardownChan+0x144> @ imm = #-0x2
700a18b4: 9800         	ldr	r0, [sp]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a18b6: 07c0         	lsls	r0, r0, #0x1f
700a18b8: b120         	cbz	r0, 0x700a18c4 <CSL_bcdmaChanOpTeardownChan+0x154> @ imm = #0x8
700a18ba: e7ff         	b	0x700a18bc <CSL_bcdmaChanOpTeardownChan+0x14c> @ imm = #-0x2
;                 retryCnt--;
700a18bc: 9802         	ldr	r0, [sp, #0x8]
700a18be: 3801         	subs	r0, #0x1
700a18c0: 9002         	str	r0, [sp, #0x8]
;             while( (CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a18c2: e7e7         	b	0x700a1894 <CSL_bcdmaChanOpTeardownChan+0x124> @ imm = #-0x32
;             if( retryCnt == (uint32_t)0U ) {
700a18c4: 9802         	ldr	r0, [sp, #0x8]
700a18c6: b920         	cbnz	r0, 0x700a18d2 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #0x8
700a18c8: e7ff         	b	0x700a18ca <CSL_bcdmaChanOpTeardownChan+0x15a> @ imm = #-0x2
700a18ca: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = CSL_EFAIL;
700a18ce: 9007         	str	r0, [sp, #0x1c]
;             }
700a18d0: e7ff         	b	0x700a18d2 <CSL_bcdmaChanOpTeardownChan+0x162> @ imm = #-0x2
;         }
700a18d2: e7ff         	b	0x700a18d4 <CSL_bcdmaChanOpTeardownChan+0x164> @ imm = #-0x2
700a18d4: e7ff         	b	0x700a18d6 <CSL_bcdmaChanOpTeardownChan+0x166> @ imm = #-0x2
;     return retVal;
700a18d6: 9807         	ldr	r0, [sp, #0x1c]
700a18d8: b00c         	add	sp, #0x30
700a18da: bd80         	pop	{r7, pc}
700a18dc: 0000         	movs	r0, r0
700a18de: 0000         	movs	r0, r0

700a18e0 <CSL_bcdmaChanOp>:
; {
700a18e0: b580         	push	{r7, lr}
700a18e2: b088         	sub	sp, #0x20
700a18e4: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a18e8: 9007         	str	r0, [sp, #0x1c]
700a18ea: 9106         	str	r1, [sp, #0x18]
700a18ec: 9205         	str	r2, [sp, #0x14]
700a18ee: 9304         	str	r3, [sp, #0x10]
700a18f0: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a18f2: 9003         	str	r0, [sp, #0xc]
;     if( ( pCfg == NULL )                                    ||
700a18f4: 9807         	ldr	r0, [sp, #0x1c]
700a18f6: b158         	cbz	r0, 0x700a1910 <CSL_bcdmaChanOp+0x30> @ imm = #0x16
700a18f8: e7ff         	b	0x700a18fa <CSL_bcdmaChanOp+0x1a> @ imm = #-0x2
;         ( chanType > CSL_BCDMA_CHAN_TYPE_SPLIT_RX )         ||
700a18fa: 9805         	ldr	r0, [sp, #0x14]
700a18fc: 2802         	cmp	r0, #0x2
700a18fe: d807         	bhi	0x700a1910 <CSL_bcdmaChanOp+0x30> @ imm = #0xe
700a1900: e7ff         	b	0x700a1902 <CSL_bcdmaChanOp+0x22> @ imm = #-0x2
;         ( !CSL_bcdmaChanOpIsValidChanIdx( pCfg, chanType, chanIdx ) )
700a1902: 9807         	ldr	r0, [sp, #0x1c]
700a1904: 9905         	ldr	r1, [sp, #0x14]
700a1906: 9a04         	ldr	r2, [sp, #0x10]
700a1908: f009 f8ba    	bl	0x700aaa80 <CSL_bcdmaChanOpIsValidChanIdx> @ imm = #0x9174
;     if( ( pCfg == NULL )                                    ||
700a190c: b920         	cbnz	r0, 0x700a1918 <CSL_bcdmaChanOp+0x38> @ imm = #0x8
700a190e: e7ff         	b	0x700a1910 <CSL_bcdmaChanOp+0x30> @ imm = #-0x2
700a1910: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a1914: 9003         	str	r0, [sp, #0xc]
;     }
700a1916: e094         	b	0x700a1a42 <CSL_bcdmaChanOp+0x162> @ imm = #0x128
;         switch(chanOp )
700a1918: 9806         	ldr	r0, [sp, #0x18]
700a191a: 9002         	str	r0, [sp, #0x8]
700a191c: 280e         	cmp	r0, #0xe
700a191e: f200 808b    	bhi.w	0x700a1a38 <CSL_bcdmaChanOp+0x158> @ imm = #0x116
700a1922: 9902         	ldr	r1, [sp, #0x8]
700a1924: e8df f001    	tbb	[pc, r1]
700a1928: 08 10 18 20  	.word	0x20181008
700a192c: 28 30 38 3f  	.word	0x3f383028
700a1930: 47 4f 57 5f  	.word	0x5f574f47
700a1934: 6c 79 81 00  	.word	0x0081796c
;                 retVal = CSL_bcdmaChanOpCfgChan( pCfg, chanType, chanIdx, pOpData );
700a1938: 9807         	ldr	r0, [sp, #0x1c]
700a193a: 9905         	ldr	r1, [sp, #0x14]
700a193c: 9a04         	ldr	r2, [sp, #0x10]
700a193e: 9b0a         	ldr	r3, [sp, #0x28]
700a1940: f7fc f91e    	bl	0x7009db80 <CSL_bcdmaChanOpCfgChan> @ imm = #-0x3dc4
700a1944: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1946: e07b         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0xf6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)true );
700a1948: 9807         	ldr	r0, [sp, #0x1c]
700a194a: 9905         	ldr	r1, [sp, #0x14]
700a194c: 9a04         	ldr	r2, [sp, #0x10]
700a194e: 2301         	movs	r3, #0x1
700a1950: f007 fcde    	bl	0x700a9310 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x79bc
700a1954: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1956: e073         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0xe6
;                 retVal = CSL_bcdmaChanOpSetChanEnable( pCfg, chanType, chanIdx, (bool)false );
700a1958: 9807         	ldr	r0, [sp, #0x1c]
700a195a: 9905         	ldr	r1, [sp, #0x14]
700a195c: 9a04         	ldr	r2, [sp, #0x10]
700a195e: 2300         	movs	r3, #0x0
700a1960: f007 fcd6    	bl	0x700a9310 <CSL_bcdmaChanOpSetChanEnable> @ imm = #0x79ac
700a1964: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1966: e06b         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0xd6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)true );
700a1968: 9807         	ldr	r0, [sp, #0x1c]
700a196a: 9905         	ldr	r1, [sp, #0x14]
700a196c: 9a04         	ldr	r2, [sp, #0x10]
700a196e: 2301         	movs	r3, #0x1
700a1970: f006 fc46    	bl	0x700a8200 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x688c
700a1974: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1976: e063         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0xc6
;                 retVal = CSL_bcdmaChanOpSetChanPause( pCfg, chanType, chanIdx, (bool)false );
700a1978: 9807         	ldr	r0, [sp, #0x1c]
700a197a: 9905         	ldr	r1, [sp, #0x14]
700a197c: 9a04         	ldr	r2, [sp, #0x10]
700a197e: 2300         	movs	r3, #0x0
700a1980: f006 fc3e    	bl	0x700a8200 <CSL_bcdmaChanOpSetChanPause> @ imm = #0x687c
700a1984: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1986: e05b         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0xb6
;                 retVal = CSL_bcdmaChanOpTeardownChan( pCfg, chanType, chanIdx, pOpData );
700a1988: 9807         	ldr	r0, [sp, #0x1c]
700a198a: 9905         	ldr	r1, [sp, #0x14]
700a198c: 9a04         	ldr	r2, [sp, #0x10]
700a198e: 9b0a         	ldr	r3, [sp, #0x28]
700a1990: f7ff feee    	bl	0x700a1770 <CSL_bcdmaChanOpTeardownChan> @ imm = #-0x224
700a1994: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1996: e053         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0xa6
;                 retVal = CSL_bcdmaChanOpTriggerChan( pCfg, chanType, chanIdx );
700a1998: 9807         	ldr	r0, [sp, #0x1c]
700a199a: 9905         	ldr	r1, [sp, #0x14]
700a199c: 9a04         	ldr	r2, [sp, #0x10]
700a199e: f009 fc6f    	bl	0x700ab280 <CSL_bcdmaChanOpTriggerChan> @ imm = #0x98de
700a19a2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19a4: e04c         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0x98
;                 retVal = CSL_bcdmaChanOpGetChanRT( pCfg, chanType, chanIdx, pOpData );
700a19a6: 9807         	ldr	r0, [sp, #0x1c]
700a19a8: 9905         	ldr	r1, [sp, #0x14]
700a19aa: 9a04         	ldr	r2, [sp, #0x10]
700a19ac: 9b0a         	ldr	r3, [sp, #0x28]
700a19ae: f004 fe1f    	bl	0x700a65f0 <CSL_bcdmaChanOpGetChanRT> @ imm = #0x4c3e
700a19b2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19b4: e044         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0x88
;                 retVal = CSL_bcdmaChanOpSetChanRT( pCfg, chanType, chanIdx, pOpData );
700a19b6: 9807         	ldr	r0, [sp, #0x1c]
700a19b8: 9905         	ldr	r1, [sp, #0x14]
700a19ba: 9a04         	ldr	r2, [sp, #0x10]
700a19bc: 9b0a         	ldr	r3, [sp, #0x28]
700a19be: f006 fc77    	bl	0x700a82b0 <CSL_bcdmaChanOpSetChanRT> @ imm = #0x68ee
700a19c2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19c4: e03c         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0x78
;                 retVal = CSL_bcdmaChanOpGetChanStats( pCfg, chanType, chanIdx, pOpData );
700a19c6: 9807         	ldr	r0, [sp, #0x1c]
700a19c8: 9905         	ldr	r1, [sp, #0x14]
700a19ca: 9a04         	ldr	r2, [sp, #0x10]
700a19cc: 9b0a         	ldr	r3, [sp, #0x28]
700a19ce: f000 fa57    	bl	0x700a1e80 <CSL_bcdmaChanOpGetChanStats> @ imm = #0x4ae
700a19d2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19d4: e034         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0x68
;                 retVal = CSL_bcdmaChanOpDecChanStats( pCfg, chanType, chanIdx, pOpData );
700a19d6: 9807         	ldr	r0, [sp, #0x1c]
700a19d8: 9905         	ldr	r1, [sp, #0x14]
700a19da: 9a04         	ldr	r2, [sp, #0x10]
700a19dc: 9b0a         	ldr	r3, [sp, #0x28]
700a19de: f003 f82f    	bl	0x700a4a40 <CSL_bcdmaChanOpDecChanStats> @ imm = #0x305e
700a19e2: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19e4: e02c         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0x58
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)true );
700a19e6: 9807         	ldr	r0, [sp, #0x1c]
700a19e8: 9905         	ldr	r1, [sp, #0x14]
700a19ea: 9a04         	ldr	r2, [sp, #0x10]
700a19ec: 9b0a         	ldr	r3, [sp, #0x28]
700a19ee: 46ee         	mov	lr, sp
700a19f0: f04f 0c01    	mov.w	r12, #0x1
700a19f4: f8ce c000    	str.w	r12, [lr]
700a19f8: f005 fde2    	bl	0x700a75c0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5bc4
700a19fc: 9003         	str	r0, [sp, #0xc]
;                 break;
700a19fe: e01f         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0x3e
;                 retVal = CSL_bcdmaChanOpAccessRemotePeerReg( pCfg, chanType, chanIdx, pOpData, (bool)false );
700a1a00: 9807         	ldr	r0, [sp, #0x1c]
700a1a02: 9905         	ldr	r1, [sp, #0x14]
700a1a04: 9a04         	ldr	r2, [sp, #0x10]
700a1a06: 9b0a         	ldr	r3, [sp, #0x28]
700a1a08: 46ee         	mov	lr, sp
700a1a0a: f04f 0c00    	mov.w	r12, #0x0
700a1a0e: f8ce c000    	str.w	r12, [lr]
700a1a12: f005 fdd5    	bl	0x700a75c0 <CSL_bcdmaChanOpAccessRemotePeerReg> @ imm = #0x5baa
700a1a16: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1a18: e012         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0x24
;                 retVal = CSL_bcdmaChanOpSetBurstSize( pCfg, chanType, chanIdx, pOpData );
700a1a1a: 9807         	ldr	r0, [sp, #0x1c]
700a1a1c: 9905         	ldr	r1, [sp, #0x14]
700a1a1e: 9a04         	ldr	r2, [sp, #0x10]
700a1a20: 9b0a         	ldr	r3, [sp, #0x28]
700a1a22: f005 f955    	bl	0x700a6cd0 <CSL_bcdmaChanOpSetBurstSize> @ imm = #0x52aa
700a1a26: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1a28: e00a         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0x14
;                 retVal = CSL_bcdmaChanOpClearError( pCfg, chanType, chanIdx );
700a1a2a: 9807         	ldr	r0, [sp, #0x1c]
700a1a2c: 9905         	ldr	r1, [sp, #0x14]
700a1a2e: 9a04         	ldr	r2, [sp, #0x10]
700a1a30: f009 fa66    	bl	0x700aaf00 <CSL_bcdmaChanOpClearError> @ imm = #0x94cc
700a1a34: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1a36: e003         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #0x6
700a1a38: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a1a3c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1a3e: e7ff         	b	0x700a1a40 <CSL_bcdmaChanOp+0x160> @ imm = #-0x2
700a1a40: e7ff         	b	0x700a1a42 <CSL_bcdmaChanOp+0x162> @ imm = #-0x2
;     return retVal;
700a1a42: 9803         	ldr	r0, [sp, #0xc]
700a1a44: b008         	add	sp, #0x20
700a1a46: bd80         	pop	{r7, pc}
		...

700a1a50 <Udma_chOpen>:
; {
700a1a50: b580         	push	{r7, lr}
700a1a52: b08a         	sub	sp, #0x28
700a1a54: 9009         	str	r0, [sp, #0x24]
700a1a56: 9108         	str	r1, [sp, #0x20]
700a1a58: 9207         	str	r2, [sp, #0x1c]
700a1a5a: 9306         	str	r3, [sp, #0x18]
700a1a5c: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK, tempRetVal;
700a1a5e: 9005         	str	r0, [sp, #0x14]
;     uint32_t            allocDone = (uint32_t) FALSE;
700a1a60: 9003         	str	r0, [sp, #0xc]
;     Udma_DrvHandleInt   drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700a1a62: 9809         	ldr	r0, [sp, #0x24]
700a1a64: 9001         	str	r0, [sp, #0x4]
;     if((drvHandleInt == NULL_PTR) || (NULL_PTR == chHandle) || (NULL_PTR == chPrms))
700a1a66: 9801         	ldr	r0, [sp, #0x4]
700a1a68: b130         	cbz	r0, 0x700a1a78 <Udma_chOpen+0x28> @ imm = #0xc
700a1a6a: e7ff         	b	0x700a1a6c <Udma_chOpen+0x1c> @ imm = #-0x2
700a1a6c: 9808         	ldr	r0, [sp, #0x20]
700a1a6e: b118         	cbz	r0, 0x700a1a78 <Udma_chOpen+0x28> @ imm = #0x6
700a1a70: e7ff         	b	0x700a1a72 <Udma_chOpen+0x22> @ imm = #-0x2
700a1a72: 9806         	ldr	r0, [sp, #0x18]
700a1a74: b920         	cbnz	r0, 0x700a1a80 <Udma_chOpen+0x30> @ imm = #0x8
700a1a76: e7ff         	b	0x700a1a78 <Udma_chOpen+0x28> @ imm = #-0x2
700a1a78: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a1a7c: 9005         	str	r0, [sp, #0x14]
;     }
700a1a7e: e7ff         	b	0x700a1a80 <Udma_chOpen+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1a80: 9805         	ldr	r0, [sp, #0x14]
700a1a82: b978         	cbnz	r0, 0x700a1aa4 <Udma_chOpen+0x54> @ imm = #0x1e
700a1a84: e7ff         	b	0x700a1a86 <Udma_chOpen+0x36> @ imm = #-0x2
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700a1a86: 9801         	ldr	r0, [sp, #0x4]
700a1a88: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a1a8c: f64a 31cd    	movw	r1, #0xabcd
700a1a90: f6ca 31dc    	movt	r1, #0xabdc
700a1a94: 4288         	cmp	r0, r1
700a1a96: d004         	beq	0x700a1aa2 <Udma_chOpen+0x52> @ imm = #0x8
700a1a98: e7ff         	b	0x700a1a9a <Udma_chOpen+0x4a> @ imm = #-0x2
700a1a9a: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a1a9e: 9005         	str	r0, [sp, #0x14]
;         }
700a1aa0: e7ff         	b	0x700a1aa2 <Udma_chOpen+0x52> @ imm = #-0x2
;     }
700a1aa2: e7ff         	b	0x700a1aa4 <Udma_chOpen+0x54> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1aa4: 9805         	ldr	r0, [sp, #0x14]
700a1aa6: b938         	cbnz	r0, 0x700a1ab8 <Udma_chOpen+0x68> @ imm = #0xe
700a1aa8: e7ff         	b	0x700a1aaa <Udma_chOpen+0x5a> @ imm = #-0x2
;         retVal = Udma_chCheckParams(drvHandleInt, chType, chPrms);
700a1aaa: 9801         	ldr	r0, [sp, #0x4]
700a1aac: 9907         	ldr	r1, [sp, #0x1c]
700a1aae: 9a06         	ldr	r2, [sp, #0x18]
700a1ab0: f006 f93e    	bl	0x700a7d30 <Udma_chCheckParams> @ imm = #0x627c
700a1ab4: 9005         	str	r0, [sp, #0x14]
;     }
700a1ab6: e7ff         	b	0x700a1ab8 <Udma_chOpen+0x68> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1ab8: 9805         	ldr	r0, [sp, #0x14]
700a1aba: 2800         	cmp	r0, #0x0
700a1abc: d145         	bne	0x700a1b4a <Udma_chOpen+0xfa> @ imm = #0x8a
700a1abe: e7ff         	b	0x700a1ac0 <Udma_chOpen+0x70> @ imm = #-0x2
;         chHandleInt = (Udma_ChHandleInt) chHandle;
700a1ac0: 9808         	ldr	r0, [sp, #0x20]
700a1ac2: 9002         	str	r0, [sp, #0x8]
;         (void) memset(chHandleInt, 0, sizeof(Udma_ChObject));
700a1ac4: 9802         	ldr	r0, [sp, #0x8]
700a1ac6: f44f 7116    	mov.w	r1, #0x258
700a1aca: f7f9 eb24    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0x69b8
;         (void) memcpy(&chHandleInt->chPrms, chPrms, sizeof(Udma_ChPrms));
700a1ace: 9802         	ldr	r0, [sp, #0x8]
700a1ad0: 3004         	adds	r0, #0x4
700a1ad2: 9906         	ldr	r1, [sp, #0x18]
700a1ad4: 2264         	movs	r2, #0x64
700a1ad6: f7f8 eb02    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0x79fc
;         chHandleInt->chType            = chType;
700a1ada: 9807         	ldr	r0, [sp, #0x1c]
700a1adc: 9902         	ldr	r1, [sp, #0x8]
700a1ade: 6008         	str	r0, [r1]
;         chHandleInt->drvHandle         = drvHandleInt;
700a1ae0: 9801         	ldr	r0, [sp, #0x4]
700a1ae2: 9902         	ldr	r1, [sp, #0x8]
700a1ae4: 6688         	str	r0, [r1, #0x68]
;         chHandleInt->txChNum           = UDMA_DMA_CH_INVALID;
700a1ae6: 9902         	ldr	r1, [sp, #0x8]
700a1ae8: 2000         	movs	r0, #0x0
700a1aea: f6cf 70ff    	movt	r0, #0xffff
700a1aee: 66c8         	str	r0, [r1, #0x6c]
;         chHandleInt->rxChNum           = UDMA_DMA_CH_INVALID;
700a1af0: 9902         	ldr	r1, [sp, #0x8]
700a1af2: 6708         	str	r0, [r1, #0x70]
;         chHandleInt->extChNum          = UDMA_DMA_CH_INVALID;
700a1af4: 9902         	ldr	r1, [sp, #0x8]
700a1af6: 6748         	str	r0, [r1, #0x74]
;         chHandleInt->pdmaChNum         = UDMA_DMA_CH_INVALID;
700a1af8: 9902         	ldr	r1, [sp, #0x8]
700a1afa: 6788         	str	r0, [r1, #0x78]
;         chHandleInt->peerThreadId      = UDMA_THREAD_ID_INVALID;
700a1afc: 9902         	ldr	r1, [sp, #0x8]
700a1afe: 2004         	movs	r0, #0x4
700a1b00: f6cf 70ff    	movt	r0, #0xffff
700a1b04: 67c8         	str	r0, [r1, #0x7c]
;         chHandleInt->fqRing            = (Udma_RingHandleInt) NULL_PTR;
700a1b06: 9902         	ldr	r1, [sp, #0x8]
700a1b08: 2000         	movs	r0, #0x0
700a1b0a: 9000         	str	r0, [sp]
700a1b0c: f8c1 0080    	str.w	r0, [r1, #0x80]
;         chHandleInt->cqRing            = (Udma_RingHandleInt) NULL_PTR;
700a1b10: 9902         	ldr	r1, [sp, #0x8]
700a1b12: f8c1 0084    	str.w	r0, [r1, #0x84]
;         chHandleInt->tdCqRing          = (Udma_RingHandleInt) NULL_PTR;
700a1b16: 9902         	ldr	r1, [sp, #0x8]
700a1b18: f8c1 0088    	str.w	r0, [r1, #0x88]
;         UdmaChTxPrms_init(&chHandleInt->txPrms, chType);
700a1b1c: 9802         	ldr	r0, [sp, #0x8]
700a1b1e: f500 70f2    	add.w	r0, r0, #0x1e4
700a1b22: 9907         	ldr	r1, [sp, #0x1c]
700a1b24: f006 fabc    	bl	0x700a80a0 <UdmaChTxPrms_init> @ imm = #0x6578
;         UdmaChRxPrms_init(&chHandleInt->rxPrms, chType);
700a1b28: 9802         	ldr	r0, [sp, #0x8]
700a1b2a: f500 70fc    	add.w	r0, r0, #0x1f8
700a1b2e: 9907         	ldr	r1, [sp, #0x1c]
700a1b30: f006 fa5e    	bl	0x700a7ff0 <UdmaChRxPrms_init> @ imm = #0x64bc
;         Udma_chInitRegs(chHandleInt);
700a1b34: 9802         	ldr	r0, [sp, #0x8]
700a1b36: f00b fa93    	bl	0x700ad060 <Udma_chInitRegs> @ imm = #0xb526
700a1b3a: 9800         	ldr	r0, [sp]
;         chHandleInt->chOesAllocDone    = FALSE;
700a1b3c: 9902         	ldr	r1, [sp, #0x8]
700a1b3e: f8c1 0248    	str.w	r0, [r1, #0x248]
;         chHandleInt->trigger           = CSL_UDMAP_TR_FLAGS_TRIGGER_NONE;
700a1b42: 9902         	ldr	r1, [sp, #0x8]
700a1b44: f8c1 024c    	str.w	r0, [r1, #0x24c]
;     }
700a1b48: e7ff         	b	0x700a1b4a <Udma_chOpen+0xfa> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1b4a: 9805         	ldr	r0, [sp, #0x14]
700a1b4c: b960         	cbnz	r0, 0x700a1b68 <Udma_chOpen+0x118> @ imm = #0x18
700a1b4e: e7ff         	b	0x700a1b50 <Udma_chOpen+0x100> @ imm = #-0x2
;         retVal = Udma_chAllocResource(chHandleInt);
700a1b50: 9802         	ldr	r0, [sp, #0x8]
700a1b52: f7fa f9cd    	bl	0x7009bef0 <Udma_chAllocResource> @ imm = #-0x5c66
700a1b56: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK == retVal)
700a1b58: 9805         	ldr	r0, [sp, #0x14]
700a1b5a: b918         	cbnz	r0, 0x700a1b64 <Udma_chOpen+0x114> @ imm = #0x6
700a1b5c: e7ff         	b	0x700a1b5e <Udma_chOpen+0x10e> @ imm = #-0x2
700a1b5e: 2001         	movs	r0, #0x1
;             allocDone = (uint32_t) TRUE;
700a1b60: 9003         	str	r0, [sp, #0xc]
;         }
700a1b62: e000         	b	0x700a1b66 <Udma_chOpen+0x116> @ imm = #0x0
700a1b64: e7ff         	b	0x700a1b66 <Udma_chOpen+0x116> @ imm = #-0x2
;     }
700a1b66: e7ff         	b	0x700a1b68 <Udma_chOpen+0x118> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1b68: 9805         	ldr	r0, [sp, #0x14]
700a1b6a: b948         	cbnz	r0, 0x700a1b80 <Udma_chOpen+0x130> @ imm = #0x12
700a1b6c: e7ff         	b	0x700a1b6e <Udma_chOpen+0x11e> @ imm = #-0x2
;         retVal = Udma_chPair(chHandleInt);
700a1b6e: 9802         	ldr	r0, [sp, #0x8]
700a1b70: f008 fe76    	bl	0x700aa860 <Udma_chPair> @ imm = #0x8cec
700a1b74: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_SOK != retVal)
700a1b76: 9805         	ldr	r0, [sp, #0x14]
700a1b78: b108         	cbz	r0, 0x700a1b7e <Udma_chOpen+0x12e> @ imm = #0x2
700a1b7a: e7ff         	b	0x700a1b7c <Udma_chOpen+0x12c> @ imm = #-0x2
;         }
700a1b7c: e7ff         	b	0x700a1b7e <Udma_chOpen+0x12e> @ imm = #-0x2
;     }
700a1b7e: e7ff         	b	0x700a1b80 <Udma_chOpen+0x130> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a1b80: 9805         	ldr	r0, [sp, #0x14]
700a1b82: b940         	cbnz	r0, 0x700a1b96 <Udma_chOpen+0x146> @ imm = #0x10
700a1b84: e7ff         	b	0x700a1b86 <Udma_chOpen+0x136> @ imm = #-0x2
;         chHandleInt->chInitDone = UDMA_INIT_DONE;
700a1b86: 9902         	ldr	r1, [sp, #0x8]
700a1b88: f64a 30cd    	movw	r0, #0xabcd
700a1b8c: f6ca 30dc    	movt	r0, #0xabdc
700a1b90: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a1b94: e00d         	b	0x700a1bb2 <Udma_chOpen+0x162> @ imm = #0x1a
;         if(((uint32_t) TRUE) == allocDone)
700a1b96: 9803         	ldr	r0, [sp, #0xc]
700a1b98: 2801         	cmp	r0, #0x1
700a1b9a: d109         	bne	0x700a1bb0 <Udma_chOpen+0x160> @ imm = #0x12
700a1b9c: e7ff         	b	0x700a1b9e <Udma_chOpen+0x14e> @ imm = #-0x2
;             tempRetVal = Udma_chFreeResource(chHandleInt);
700a1b9e: 9802         	ldr	r0, [sp, #0x8]
700a1ba0: f7fd fa76    	bl	0x7009f090 <Udma_chFreeResource> @ imm = #-0x2b14
700a1ba4: 9004         	str	r0, [sp, #0x10]
;             if(UDMA_SOK != tempRetVal)
700a1ba6: 9804         	ldr	r0, [sp, #0x10]
700a1ba8: b108         	cbz	r0, 0x700a1bae <Udma_chOpen+0x15e> @ imm = #0x2
700a1baa: e7ff         	b	0x700a1bac <Udma_chOpen+0x15c> @ imm = #-0x2
;             }
700a1bac: e7ff         	b	0x700a1bae <Udma_chOpen+0x15e> @ imm = #-0x2
;         }
700a1bae: e7ff         	b	0x700a1bb0 <Udma_chOpen+0x160> @ imm = #-0x2
700a1bb0: e7ff         	b	0x700a1bb2 <Udma_chOpen+0x162> @ imm = #-0x2
;     return (retVal);
700a1bb2: 9805         	ldr	r0, [sp, #0x14]
700a1bb4: b00a         	add	sp, #0x28
700a1bb6: bd80         	pop	{r7, pc}
		...

700a1bc0 <Udma_rmAllocMappedRxCh>:
; {
700a1bc0: b580         	push	{r7, lr}
700a1bc2: b08a         	sub	sp, #0x28
700a1bc4: 9009         	str	r0, [sp, #0x24]
700a1bc6: 9108         	str	r1, [sp, #0x20]
700a1bc8: 9207         	str	r2, [sp, #0x1c]
700a1bca: 2000         	movs	r0, #0x0
700a1bcc: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1bd0: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1bd2: 9808         	ldr	r0, [sp, #0x20]
700a1bd4: f500 70ea    	add.w	r0, r0, #0x1d4
700a1bd8: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1bda: 9808         	ldr	r0, [sp, #0x20]
700a1bdc: f500 609f    	add.w	r0, r0, #0x4f8
700a1be0: f04f 31ff    	mov.w	r1, #0xffffffff
700a1be4: f008 fdf4    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x8be8
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1be8: 9809         	ldr	r0, [sp, #0x24]
700a1bea: 2101         	movs	r1, #0x1
700a1bec: f6cf 71ff    	movt	r1, #0xffff
700a1bf0: 4288         	cmp	r0, r1
700a1bf2: d142         	bne	0x700a1c7a <Udma_rmAllocMappedRxCh+0xba> @ imm = #0x84
700a1bf4: e7ff         	b	0x700a1bf6 <Udma_rmAllocMappedRxCh+0x36> @ imm = #-0x2
700a1bf6: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
700a1bf8: 9005         	str	r0, [sp, #0x14]
700a1bfa: e7ff         	b	0x700a1bfc <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x2
700a1bfc: 9805         	ldr	r0, [sp, #0x14]
700a1bfe: 9901         	ldr	r1, [sp, #0x4]
700a1c00: 9a07         	ldr	r2, [sp, #0x1c]
700a1c02: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1c06: 6f89         	ldr	r1, [r1, #0x78]
700a1c08: 4288         	cmp	r0, r1
700a1c0a: d235         	bhs	0x700a1c78 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x6a
700a1c0c: e7ff         	b	0x700a1c0e <Udma_rmAllocMappedRxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
700a1c0e: 9805         	ldr	r0, [sp, #0x14]
700a1c10: 0940         	lsrs	r0, r0, #0x5
700a1c12: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1c14: 9805         	ldr	r0, [sp, #0x14]
700a1c16: 9904         	ldr	r1, [sp, #0x10]
700a1c18: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1c1c: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1c1e: 9903         	ldr	r1, [sp, #0xc]
700a1c20: 2001         	movs	r0, #0x1
700a1c22: 4088         	lsls	r0, r1
700a1c24: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1c26: 9808         	ldr	r0, [sp, #0x20]
700a1c28: 9907         	ldr	r1, [sp, #0x1c]
700a1c2a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c2e: 9904         	ldr	r1, [sp, #0x10]
700a1c30: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c34: f8d0 0334    	ldr.w	r0, [r0, #0x334]
700a1c38: 9902         	ldr	r1, [sp, #0x8]
700a1c3a: 4008         	ands	r0, r1
700a1c3c: 4288         	cmp	r0, r1
700a1c3e: d116         	bne	0x700a1c6e <Udma_rmAllocMappedRxCh+0xae> @ imm = #0x2c
700a1c40: e7ff         	b	0x700a1c42 <Udma_rmAllocMappedRxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1c42: 9a02         	ldr	r2, [sp, #0x8]
700a1c44: 9808         	ldr	r0, [sp, #0x20]
700a1c46: 9907         	ldr	r1, [sp, #0x1c]
700a1c48: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1c4c: 9904         	ldr	r1, [sp, #0x10]
700a1c4e: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1c52: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a1c56: 4390         	bics	r0, r2
700a1c58: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = i + rmInitPrms->startMappedRxCh[mappedChGrp];  /* Add start offset */
700a1c5c: 9805         	ldr	r0, [sp, #0x14]
700a1c5e: 9901         	ldr	r1, [sp, #0x4]
700a1c60: 9a07         	ldr	r2, [sp, #0x1c]
700a1c62: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1c66: 6e89         	ldr	r1, [r1, #0x68]
700a1c68: 4408         	add	r0, r1
700a1c6a: 9006         	str	r0, [sp, #0x18]
;                 break;
700a1c6c: e004         	b	0x700a1c78 <Udma_rmAllocMappedRxCh+0xb8> @ imm = #0x8
;         }
700a1c6e: e7ff         	b	0x700a1c70 <Udma_rmAllocMappedRxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedRxCh[mappedChGrp]; i++)
700a1c70: 9805         	ldr	r0, [sp, #0x14]
700a1c72: 3001         	adds	r0, #0x1
700a1c74: 9005         	str	r0, [sp, #0x14]
700a1c76: e7c1         	b	0x700a1bfc <Udma_rmAllocMappedRxCh+0x3c> @ imm = #-0x7e
;     }
700a1c78: e047         	b	0x700a1d0a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
700a1c7a: 9809         	ldr	r0, [sp, #0x24]
700a1c7c: 9901         	ldr	r1, [sp, #0x4]
700a1c7e: 9a07         	ldr	r2, [sp, #0x1c]
700a1c80: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1c84: 6e89         	ldr	r1, [r1, #0x68]
700a1c86: 4288         	cmp	r0, r1
700a1c88: d33e         	blo	0x700a1d08 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x7c
700a1c8a: e7ff         	b	0x700a1c8c <Udma_rmAllocMappedRxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedRxCh[mappedChGrp] + rmInitPrms->numMappedRxCh[mappedChGrp])))
700a1c8c: 9809         	ldr	r0, [sp, #0x24]
700a1c8e: 9901         	ldr	r1, [sp, #0x4]
700a1c90: 9a07         	ldr	r2, [sp, #0x1c]
700a1c92: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a1c96: 6e91         	ldr	r1, [r2, #0x68]
700a1c98: 6f92         	ldr	r2, [r2, #0x78]
700a1c9a: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedRxCh[mappedChGrp]) &&
700a1c9c: 4288         	cmp	r0, r1
700a1c9e: d233         	bhs	0x700a1d08 <Udma_rmAllocMappedRxCh+0x148> @ imm = #0x66
700a1ca0: e7ff         	b	0x700a1ca2 <Udma_rmAllocMappedRxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700a1ca2: 9809         	ldr	r0, [sp, #0x24]
700a1ca4: 9901         	ldr	r1, [sp, #0x4]
700a1ca6: 9a07         	ldr	r2, [sp, #0x1c]
700a1ca8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1cac: 6e89         	ldr	r1, [r1, #0x68]
700a1cae: 1a40         	subs	r0, r0, r1
700a1cb0: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1cb2: 9805         	ldr	r0, [sp, #0x14]
700a1cb4: 0940         	lsrs	r0, r0, #0x5
700a1cb6: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1cb8: 9805         	ldr	r0, [sp, #0x14]
700a1cba: 9904         	ldr	r1, [sp, #0x10]
700a1cbc: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1cc0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1cc2: 9903         	ldr	r1, [sp, #0xc]
700a1cc4: 2001         	movs	r0, #0x1
700a1cc6: 4088         	lsls	r0, r1
700a1cc8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedRxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1cca: 9808         	ldr	r0, [sp, #0x20]
700a1ccc: 9907         	ldr	r1, [sp, #0x1c]
700a1cce: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1cd2: 9904         	ldr	r1, [sp, #0x10]
700a1cd4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1cd8: f8d0 0334    	ldr.w	r0, [r0, #0x334]
700a1cdc: 9902         	ldr	r1, [sp, #0x8]
700a1cde: 4008         	ands	r0, r1
700a1ce0: 4288         	cmp	r0, r1
700a1ce2: d110         	bne	0x700a1d06 <Udma_rmAllocMappedRxCh+0x146> @ imm = #0x20
700a1ce4: e7ff         	b	0x700a1ce6 <Udma_rmAllocMappedRxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedRxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1ce6: 9a02         	ldr	r2, [sp, #0x8]
700a1ce8: 9808         	ldr	r0, [sp, #0x20]
700a1cea: 9907         	ldr	r1, [sp, #0x1c]
700a1cec: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1cf0: 9904         	ldr	r1, [sp, #0x10]
700a1cf2: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1cf6: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700a1cfa: 4390         	bics	r0, r2
700a1cfc: f8c1 0334    	str.w	r0, [r1, #0x334]
;                 chNum = preferredChNum;
700a1d00: 9809         	ldr	r0, [sp, #0x24]
700a1d02: 9006         	str	r0, [sp, #0x18]
;             }
700a1d04: e7ff         	b	0x700a1d06 <Udma_rmAllocMappedRxCh+0x146> @ imm = #-0x2
;         }
700a1d06: e7ff         	b	0x700a1d08 <Udma_rmAllocMappedRxCh+0x148> @ imm = #-0x2
700a1d08: e7ff         	b	0x700a1d0a <Udma_rmAllocMappedRxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1d0a: 9808         	ldr	r0, [sp, #0x20]
700a1d0c: f500 609f    	add.w	r0, r0, #0x4f8
700a1d10: f00a f8ee    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0xa1dc
;     return (chNum);
700a1d14: 9806         	ldr	r0, [sp, #0x18]
700a1d16: b00a         	add	sp, #0x28
700a1d18: bd80         	pop	{r7, pc}
700a1d1a: 0000         	movs	r0, r0
700a1d1c: 0000         	movs	r0, r0
700a1d1e: 0000         	movs	r0, r0

700a1d20 <Udma_rmAllocMappedTxCh>:
; {
700a1d20: b580         	push	{r7, lr}
700a1d22: b08a         	sub	sp, #0x28
700a1d24: 9009         	str	r0, [sp, #0x24]
700a1d26: 9108         	str	r1, [sp, #0x20]
700a1d28: 9207         	str	r2, [sp, #0x1c]
700a1d2a: 2000         	movs	r0, #0x0
700a1d2c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a1d30: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a1d32: 9808         	ldr	r0, [sp, #0x20]
700a1d34: f500 70ea    	add.w	r0, r0, #0x1d4
700a1d38: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a1d3a: 9808         	ldr	r0, [sp, #0x20]
700a1d3c: f500 609f    	add.w	r0, r0, #0x4f8
700a1d40: f04f 31ff    	mov.w	r1, #0xffffffff
700a1d44: f008 fd44    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x8a88
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a1d48: 9809         	ldr	r0, [sp, #0x24]
700a1d4a: 2101         	movs	r1, #0x1
700a1d4c: f6cf 71ff    	movt	r1, #0xffff
700a1d50: 4288         	cmp	r0, r1
700a1d52: d142         	bne	0x700a1dda <Udma_rmAllocMappedTxCh+0xba> @ imm = #0x84
700a1d54: e7ff         	b	0x700a1d56 <Udma_rmAllocMappedTxCh+0x36> @ imm = #-0x2
700a1d56: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a1d58: 9005         	str	r0, [sp, #0x14]
700a1d5a: e7ff         	b	0x700a1d5c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x2
700a1d5c: 9805         	ldr	r0, [sp, #0x14]
700a1d5e: 9901         	ldr	r1, [sp, #0x4]
700a1d60: 9a07         	ldr	r2, [sp, #0x1c]
700a1d62: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1d66: 6d89         	ldr	r1, [r1, #0x58]
700a1d68: 4288         	cmp	r0, r1
700a1d6a: d235         	bhs	0x700a1dd8 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x6a
700a1d6c: e7ff         	b	0x700a1d6e <Udma_rmAllocMappedTxCh+0x4e> @ imm = #-0x2
;             offset = i >> 5U;
700a1d6e: 9805         	ldr	r0, [sp, #0x14]
700a1d70: 0940         	lsrs	r0, r0, #0x5
700a1d72: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1d74: 9805         	ldr	r0, [sp, #0x14]
700a1d76: 9904         	ldr	r1, [sp, #0x10]
700a1d78: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1d7c: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1d7e: 9903         	ldr	r1, [sp, #0xc]
700a1d80: 2001         	movs	r0, #0x1
700a1d82: 4088         	lsls	r0, r1
700a1d84: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1d86: 9808         	ldr	r0, [sp, #0x20]
700a1d88: 9907         	ldr	r1, [sp, #0x1c]
700a1d8a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1d8e: 9904         	ldr	r1, [sp, #0x10]
700a1d90: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1d94: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a1d98: 9902         	ldr	r1, [sp, #0x8]
700a1d9a: 4008         	ands	r0, r1
700a1d9c: 4288         	cmp	r0, r1
700a1d9e: d116         	bne	0x700a1dce <Udma_rmAllocMappedTxCh+0xae> @ imm = #0x2c
700a1da0: e7ff         	b	0x700a1da2 <Udma_rmAllocMappedTxCh+0x82> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1da2: 9a02         	ldr	r2, [sp, #0x8]
700a1da4: 9808         	ldr	r0, [sp, #0x20]
700a1da6: 9907         	ldr	r1, [sp, #0x1c]
700a1da8: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1dac: 9904         	ldr	r1, [sp, #0x10]
700a1dae: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1db2: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a1db6: 4390         	bics	r0, r2
700a1db8: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = i + rmInitPrms->startMappedTxCh[mappedChGrp];  /* Add start offset */
700a1dbc: 9805         	ldr	r0, [sp, #0x14]
700a1dbe: 9901         	ldr	r1, [sp, #0x4]
700a1dc0: 9a07         	ldr	r2, [sp, #0x1c]
700a1dc2: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1dc6: 6c89         	ldr	r1, [r1, #0x48]
700a1dc8: 4408         	add	r0, r1
700a1dca: 9006         	str	r0, [sp, #0x18]
;                 break;
700a1dcc: e004         	b	0x700a1dd8 <Udma_rmAllocMappedTxCh+0xb8> @ imm = #0x8
;         }
700a1dce: e7ff         	b	0x700a1dd0 <Udma_rmAllocMappedTxCh+0xb0> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numMappedTxCh[mappedChGrp]; i++)
700a1dd0: 9805         	ldr	r0, [sp, #0x14]
700a1dd2: 3001         	adds	r0, #0x1
700a1dd4: 9005         	str	r0, [sp, #0x14]
700a1dd6: e7c1         	b	0x700a1d5c <Udma_rmAllocMappedTxCh+0x3c> @ imm = #-0x7e
;     }
700a1dd8: e047         	b	0x700a1e6a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #0x8e
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a1dda: 9809         	ldr	r0, [sp, #0x24]
700a1ddc: 9901         	ldr	r1, [sp, #0x4]
700a1dde: 9a07         	ldr	r2, [sp, #0x1c]
700a1de0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1de4: 6c89         	ldr	r1, [r1, #0x48]
700a1de6: 4288         	cmp	r0, r1
700a1de8: d33e         	blo	0x700a1e68 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x7c
700a1dea: e7ff         	b	0x700a1dec <Udma_rmAllocMappedTxCh+0xcc> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startMappedTxCh[mappedChGrp] + rmInitPrms->numMappedTxCh[mappedChGrp])))
700a1dec: 9809         	ldr	r0, [sp, #0x24]
700a1dee: 9901         	ldr	r1, [sp, #0x4]
700a1df0: 9a07         	ldr	r2, [sp, #0x1c]
700a1df2: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a1df6: 6c91         	ldr	r1, [r2, #0x48]
700a1df8: 6d92         	ldr	r2, [r2, #0x58]
700a1dfa: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startMappedTxCh[mappedChGrp]) &&
700a1dfc: 4288         	cmp	r0, r1
700a1dfe: d233         	bhs	0x700a1e68 <Udma_rmAllocMappedTxCh+0x148> @ imm = #0x66
700a1e00: e7ff         	b	0x700a1e02 <Udma_rmAllocMappedTxCh+0xe2> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700a1e02: 9809         	ldr	r0, [sp, #0x24]
700a1e04: 9901         	ldr	r1, [sp, #0x4]
700a1e06: 9a07         	ldr	r2, [sp, #0x1c]
700a1e08: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a1e0c: 6c89         	ldr	r1, [r1, #0x48]
700a1e0e: 1a40         	subs	r0, r0, r1
700a1e10: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a1e12: 9805         	ldr	r0, [sp, #0x14]
700a1e14: 0940         	lsrs	r0, r0, #0x5
700a1e16: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a1e18: 9805         	ldr	r0, [sp, #0x14]
700a1e1a: 9904         	ldr	r1, [sp, #0x10]
700a1e1c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a1e20: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a1e22: 9903         	ldr	r1, [sp, #0xc]
700a1e24: 2001         	movs	r0, #0x1
700a1e26: 4088         	lsls	r0, r1
700a1e28: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->mappedTxChFlag[mappedChGrp][offset] & bitMask) == bitMask)
700a1e2a: 9808         	ldr	r0, [sp, #0x20]
700a1e2c: 9907         	ldr	r1, [sp, #0x1c]
700a1e2e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1e32: 9904         	ldr	r1, [sp, #0x10]
700a1e34: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1e38: f8d0 0324    	ldr.w	r0, [r0, #0x324]
700a1e3c: 9902         	ldr	r1, [sp, #0x8]
700a1e3e: 4008         	ands	r0, r1
700a1e40: 4288         	cmp	r0, r1
700a1e42: d110         	bne	0x700a1e66 <Udma_rmAllocMappedTxCh+0x146> @ imm = #0x20
700a1e44: e7ff         	b	0x700a1e46 <Udma_rmAllocMappedTxCh+0x126> @ imm = #-0x2
;                 drvHandle->mappedTxChFlag[mappedChGrp][offset] &= ~bitMask;
700a1e46: 9a02         	ldr	r2, [sp, #0x8]
700a1e48: 9808         	ldr	r0, [sp, #0x20]
700a1e4a: 9907         	ldr	r1, [sp, #0x1c]
700a1e4c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a1e50: 9904         	ldr	r1, [sp, #0x10]
700a1e52: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a1e56: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700a1e5a: 4390         	bics	r0, r2
700a1e5c: f8c1 0324    	str.w	r0, [r1, #0x324]
;                 chNum = preferredChNum;
700a1e60: 9809         	ldr	r0, [sp, #0x24]
700a1e62: 9006         	str	r0, [sp, #0x18]
;             }
700a1e64: e7ff         	b	0x700a1e66 <Udma_rmAllocMappedTxCh+0x146> @ imm = #-0x2
;         }
700a1e66: e7ff         	b	0x700a1e68 <Udma_rmAllocMappedTxCh+0x148> @ imm = #-0x2
700a1e68: e7ff         	b	0x700a1e6a <Udma_rmAllocMappedTxCh+0x14a> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a1e6a: 9808         	ldr	r0, [sp, #0x20]
700a1e6c: f500 609f    	add.w	r0, r0, #0x4f8
700a1e70: f00a f83e    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0xa07c
;     return (chNum);
700a1e74: 9806         	ldr	r0, [sp, #0x18]
700a1e76: b00a         	add	sp, #0x28
700a1e78: bd80         	pop	{r7, pc}
700a1e7a: 0000         	movs	r0, r0
700a1e7c: 0000         	movs	r0, r0
700a1e7e: 0000         	movs	r0, r0

700a1e80 <CSL_bcdmaChanOpGetChanStats>:
; {
700a1e80: b580         	push	{r7, lr}
700a1e82: b088         	sub	sp, #0x20
700a1e84: 9007         	str	r0, [sp, #0x1c]
700a1e86: 9106         	str	r1, [sp, #0x18]
700a1e88: 9205         	str	r2, [sp, #0x14]
700a1e8a: 9304         	str	r3, [sp, #0x10]
700a1e8c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a1e8e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a1e90: 9804         	ldr	r0, [sp, #0x10]
700a1e92: b920         	cbnz	r0, 0x700a1e9e <CSL_bcdmaChanOpGetChanStats+0x1e> @ imm = #0x8
700a1e94: e7ff         	b	0x700a1e96 <CSL_bcdmaChanOpGetChanStats+0x16> @ imm = #-0x2
700a1e96: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a1e9a: 9003         	str	r0, [sp, #0xc]
;     }
700a1e9c: e099         	b	0x700a1fd2 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #0x132
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a1e9e: 9804         	ldr	r0, [sp, #0x10]
700a1ea0: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a1ea2: 9806         	ldr	r0, [sp, #0x18]
700a1ea4: 9001         	str	r0, [sp, #0x4]
700a1ea6: b140         	cbz	r0, 0x700a1eba <CSL_bcdmaChanOpGetChanStats+0x3a> @ imm = #0x10
700a1ea8: e7ff         	b	0x700a1eaa <CSL_bcdmaChanOpGetChanStats+0x2a> @ imm = #-0x2
700a1eaa: 9801         	ldr	r0, [sp, #0x4]
700a1eac: 2801         	cmp	r0, #0x1
700a1eae: d031         	beq	0x700a1f14 <CSL_bcdmaChanOpGetChanStats+0x94> @ imm = #0x62
700a1eb0: e7ff         	b	0x700a1eb2 <CSL_bcdmaChanOpGetChanStats+0x32> @ imm = #-0x2
700a1eb2: 9801         	ldr	r0, [sp, #0x4]
700a1eb4: 2802         	cmp	r0, #0x2
700a1eb6: d05a         	beq	0x700a1f6e <CSL_bcdmaChanOpGetChanStats+0xee> @ imm = #0xb4
700a1eb8: e086         	b	0x700a1fc8 <CSL_bcdmaChanOpGetChanStats+0x148> @ imm = #0x10c
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT );
700a1eba: 9807         	ldr	r0, [sp, #0x1c]
700a1ebc: 6880         	ldr	r0, [r0, #0x8]
700a1ebe: 9905         	ldr	r1, [sp, #0x14]
700a1ec0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1ec4: f500 6080    	add.w	r0, r0, #0x400
700a1ec8: f00d fe9a    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xdd34
700a1ecc: 9902         	ldr	r1, [sp, #0x8]
700a1ece: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT );
700a1ed0: 9807         	ldr	r0, [sp, #0x1c]
700a1ed2: 6880         	ldr	r0, [r0, #0x8]
700a1ed4: 9905         	ldr	r1, [sp, #0x14]
700a1ed6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1eda: f500 6081    	add.w	r0, r0, #0x408
700a1ede: f00d fe8f    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xdd1e
700a1ee2: 9902         	ldr	r1, [sp, #0x8]
700a1ee4: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT );
700a1ee6: 9807         	ldr	r0, [sp, #0x1c]
700a1ee8: 6880         	ldr	r0, [r0, #0x8]
700a1eea: 9905         	ldr	r1, [sp, #0x14]
700a1eec: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1ef0: f500 6082    	add.w	r0, r0, #0x410
700a1ef4: f00d fe84    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xdd08
700a1ef8: 9902         	ldr	r1, [sp, #0x8]
700a1efa: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a1efc: 9902         	ldr	r1, [sp, #0x8]
700a1efe: 2000         	movs	r0, #0x0
700a1f00: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a1f02: 9902         	ldr	r1, [sp, #0x8]
700a1f04: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a1f06: 9902         	ldr	r1, [sp, #0x8]
700a1f08: 6848         	ldr	r0, [r1, #0x4]
700a1f0a: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a1f0c: 9902         	ldr	r1, [sp, #0x8]
700a1f0e: 6888         	ldr	r0, [r1, #0x8]
700a1f10: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1f12: e05d         	b	0x700a1fd0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0xba
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT );
700a1f14: 9807         	ldr	r0, [sp, #0x1c]
700a1f16: 6900         	ldr	r0, [r0, #0x10]
700a1f18: 9905         	ldr	r1, [sp, #0x14]
700a1f1a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1f1e: f500 6080    	add.w	r0, r0, #0x400
700a1f22: f00d fe6d    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xdcda
700a1f26: 9902         	ldr	r1, [sp, #0x8]
700a1f28: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT );
700a1f2a: 9807         	ldr	r0, [sp, #0x1c]
700a1f2c: 6900         	ldr	r0, [r0, #0x10]
700a1f2e: 9905         	ldr	r1, [sp, #0x14]
700a1f30: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1f34: f500 6081    	add.w	r0, r0, #0x408
700a1f38: f00d fe62    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xdcc4
700a1f3c: 9902         	ldr	r1, [sp, #0x8]
700a1f3e: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT );
700a1f40: 9807         	ldr	r0, [sp, #0x1c]
700a1f42: 6900         	ldr	r0, [r0, #0x10]
700a1f44: 9905         	ldr	r1, [sp, #0x14]
700a1f46: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1f4a: f500 6082    	add.w	r0, r0, #0x410
700a1f4e: f00d fe57    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xdcae
700a1f52: 9902         	ldr	r1, [sp, #0x8]
700a1f54: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = (uint32_t)0U;
700a1f56: 9902         	ldr	r1, [sp, #0x8]
700a1f58: 2000         	movs	r0, #0x0
700a1f5a: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = (uint32_t)0U;
700a1f5c: 9902         	ldr	r1, [sp, #0x8]
700a1f5e: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->txPayloadByteCnt;
700a1f60: 9902         	ldr	r1, [sp, #0x8]
700a1f62: 6848         	ldr	r0, [r1, #0x4]
700a1f64: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->txStartedByteCnt;
700a1f66: 9902         	ldr	r1, [sp, #0x8]
700a1f68: 6888         	ldr	r0, [r1, #0x8]
700a1f6a: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1f6c: e030         	b	0x700a1fd0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x60
;                 pChanStats->packetCnt        = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT );
700a1f6e: 9807         	ldr	r0, [sp, #0x1c]
700a1f70: 6980         	ldr	r0, [r0, #0x18]
700a1f72: 9905         	ldr	r1, [sp, #0x14]
700a1f74: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1f78: f500 6080    	add.w	r0, r0, #0x400
700a1f7c: f00d fe40    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xdc80
700a1f80: 9902         	ldr	r1, [sp, #0x8]
700a1f82: 6008         	str	r0, [r1]
;                 pChanStats->txPayloadByteCnt = (uint32_t)0U;
700a1f84: 9902         	ldr	r1, [sp, #0x8]
700a1f86: 2000         	movs	r0, #0x0
700a1f88: 6048         	str	r0, [r1, #0x4]
;                 pChanStats->txStartedByteCnt = (uint32_t)0U;
700a1f8a: 9902         	ldr	r1, [sp, #0x8]
700a1f8c: 6088         	str	r0, [r1, #0x8]
;                 pChanStats->rxPayloadByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT );
700a1f8e: 9807         	ldr	r0, [sp, #0x1c]
700a1f90: 6980         	ldr	r0, [r0, #0x18]
700a1f92: 9905         	ldr	r1, [sp, #0x14]
700a1f94: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1f98: f500 6081    	add.w	r0, r0, #0x408
700a1f9c: f00d fe30    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xdc60
700a1fa0: 9902         	ldr	r1, [sp, #0x8]
700a1fa2: 60c8         	str	r0, [r1, #0xc]
;                 pChanStats->rxStartedByteCnt = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT );
700a1fa4: 9807         	ldr	r0, [sp, #0x1c]
700a1fa6: 6980         	ldr	r0, [r0, #0x18]
700a1fa8: 9905         	ldr	r1, [sp, #0x14]
700a1faa: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a1fae: f500 6082    	add.w	r0, r0, #0x410
700a1fb2: f00d fe25    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xdc4a
700a1fb6: 9902         	ldr	r1, [sp, #0x8]
700a1fb8: 6108         	str	r0, [r1, #0x10]
;                 pChanStats->completedByteCnt = pChanStats->rxPayloadByteCnt;
700a1fba: 9902         	ldr	r1, [sp, #0x8]
700a1fbc: 68c8         	ldr	r0, [r1, #0xc]
700a1fbe: 6148         	str	r0, [r1, #0x14]
;                 pChanStats->startedByteCnt   = pChanStats->rxStartedByteCnt;
700a1fc0: 9902         	ldr	r1, [sp, #0x8]
700a1fc2: 6908         	ldr	r0, [r1, #0x10]
700a1fc4: 6188         	str	r0, [r1, #0x18]
;                 break;
700a1fc6: e003         	b	0x700a1fd0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #0x6
700a1fc8: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a1fcc: 9003         	str	r0, [sp, #0xc]
;                 break;
700a1fce: e7ff         	b	0x700a1fd0 <CSL_bcdmaChanOpGetChanStats+0x150> @ imm = #-0x2
700a1fd0: e7ff         	b	0x700a1fd2 <CSL_bcdmaChanOpGetChanStats+0x152> @ imm = #-0x2
;     return retVal;
700a1fd2: 9803         	ldr	r0, [sp, #0xc]
700a1fd4: b008         	add	sp, #0x20
700a1fd6: bd80         	pop	{r7, pc}
		...

700a1fe0 <UART_lld_initDma>:
; {
700a1fe0: b580         	push	{r7, lr}
700a1fe2: b084         	sub	sp, #0x10
700a1fe4: 9003         	str	r0, [sp, #0xc]
700a1fe6: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a1fe8: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a1fea: 9803         	ldr	r0, [sp, #0xc]
700a1fec: b168         	cbz	r0, 0x700a200a <UART_lld_initDma+0x2a> @ imm = #0x1a
700a1fee: e7ff         	b	0x700a1ff0 <UART_lld_initDma+0x10> @ imm = #-0x2
700a1ff0: 9803         	ldr	r0, [sp, #0xc]
700a1ff2: 6840         	ldr	r0, [r0, #0x4]
700a1ff4: b148         	cbz	r0, 0x700a200a <UART_lld_initDma+0x2a> @ imm = #0x12
700a1ff6: e7ff         	b	0x700a1ff8 <UART_lld_initDma+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a1ff8: 9803         	ldr	r0, [sp, #0xc]
700a1ffa: 6d40         	ldr	r0, [r0, #0x54]
700a1ffc: b120         	cbz	r0, 0x700a2008 <UART_lld_initDma+0x28> @ imm = #0x8
700a1ffe: e7ff         	b	0x700a2000 <UART_lld_initDma+0x20> @ imm = #-0x2
700a2000: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a2004: 9002         	str	r0, [sp, #0x8]
;         }
700a2006: e7ff         	b	0x700a2008 <UART_lld_initDma+0x28> @ imm = #-0x2
;     }
700a2008: e003         	b	0x700a2012 <UART_lld_initDma+0x32> @ imm = #0x6
700a200a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a200e: 9002         	str	r0, [sp, #0x8]
700a2010: e7ff         	b	0x700a2012 <UART_lld_initDma+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a2012: 9802         	ldr	r0, [sp, #0x8]
700a2014: 2800         	cmp	r0, #0x0
700a2016: d170         	bne	0x700a20fa <UART_lld_initDma+0x11a> @ imm = #0xe0
700a2018: e7ff         	b	0x700a201a <UART_lld_initDma+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a201a: 9903         	ldr	r1, [sp, #0xc]
700a201c: 2002         	movs	r0, #0x2
700a201e: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a2020: 9803         	ldr	r0, [sp, #0xc]
700a2022: 6840         	ldr	r0, [r0, #0x4]
700a2024: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a2026: 9801         	ldr	r0, [sp, #0x4]
700a2028: 6d82         	ldr	r2, [r0, #0x58]
700a202a: f244 2040    	movw	r0, #0x4240
700a202e: f2c0 000f    	movt	r0, #0xf
700a2032: 2100         	movs	r1, #0x0
700a2034: 9100         	str	r1, [sp]
700a2036: 4790         	blx	r2
700a2038: 9a00         	ldr	r2, [sp]
700a203a: 9903         	ldr	r1, [sp, #0xc]
700a203c: 66ca         	str	r2, [r1, #0x6c]
700a203e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a2040: 9803         	ldr	r0, [sp, #0xc]
700a2042: 6800         	ldr	r0, [r0]
700a2044: f006 fbf4    	bl	0x700a8830 <UART_IsBaseAddrValid> @ imm = #0x67e8
700a2048: 4601         	mov	r1, r0
700a204a: 9802         	ldr	r0, [sp, #0x8]
700a204c: 4408         	add	r0, r1
700a204e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a2050: 9801         	ldr	r0, [sp, #0x4]
700a2052: 6800         	ldr	r0, [r0]
700a2054: f00d fa94    	bl	0x700af580 <UART_IsParameter> @ imm = #0xd528
700a2058: 4601         	mov	r1, r0
700a205a: 9802         	ldr	r0, [sp, #0x8]
700a205c: 4408         	add	r0, r1
700a205e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a2060: 9801         	ldr	r0, [sp, #0x4]
700a2062: 6840         	ldr	r0, [r0, #0x4]
700a2064: f00d fa8c    	bl	0x700af580 <UART_IsParameter> @ imm = #0xd518
700a2068: 4601         	mov	r1, r0
700a206a: 9802         	ldr	r0, [sp, #0x8]
700a206c: 4408         	add	r0, r1
700a206e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a2070: 9801         	ldr	r0, [sp, #0x4]
700a2072: 6880         	ldr	r0, [r0, #0x8]
700a2074: f00c fa84    	bl	0x700ae580 <UART_IsDataLengthValid> @ imm = #0xc508
700a2078: 4601         	mov	r1, r0
700a207a: 9802         	ldr	r0, [sp, #0x8]
700a207c: 4408         	add	r0, r1
700a207e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a2080: 9801         	ldr	r0, [sp, #0x4]
700a2082: 68c0         	ldr	r0, [r0, #0xc]
700a2084: f00d f894    	bl	0x700af1b0 <UART_IsStopBitsValid> @ imm = #0xd128
700a2088: 4601         	mov	r1, r0
700a208a: 9802         	ldr	r0, [sp, #0x8]
700a208c: 4408         	add	r0, r1
700a208e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a2090: 9801         	ldr	r0, [sp, #0x4]
700a2092: 6900         	ldr	r0, [r0, #0x10]
700a2094: f00b ffd4    	bl	0x700ae040 <UART_IsParityTypeValid> @ imm = #0xbfa8
700a2098: 4601         	mov	r1, r0
700a209a: 9802         	ldr	r0, [sp, #0x8]
700a209c: 4408         	add	r0, r1
700a209e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a20a0: 9801         	ldr	r0, [sp, #0x4]
700a20a2: 69c0         	ldr	r0, [r0, #0x1c]
700a20a4: f00b fe8c    	bl	0x700addc0 <UART_IsHWFlowCtrlValid> @ imm = #0xbd18
700a20a8: 4601         	mov	r1, r0
700a20aa: 9802         	ldr	r0, [sp, #0x8]
700a20ac: 4408         	add	r0, r1
700a20ae: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a20b0: 9801         	ldr	r0, [sp, #0x4]
700a20b2: 6ac0         	ldr	r0, [r0, #0x2c]
700a20b4: f00a fee4    	bl	0x700ace80 <UART_OperModeValid> @ imm = #0xadc8
700a20b8: 4601         	mov	r1, r0
700a20ba: 9802         	ldr	r0, [sp, #0x8]
700a20bc: 4408         	add	r0, r1
700a20be: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a20c0: 9801         	ldr	r0, [sp, #0x4]
700a20c2: 6b80         	ldr	r0, [r0, #0x38]
700a20c4: f00b fe9c    	bl	0x700ade00 <UART_IsRxTrigLvlValid> @ imm = #0xbd38
700a20c8: 4601         	mov	r1, r0
700a20ca: 9802         	ldr	r0, [sp, #0x8]
700a20cc: 4408         	add	r0, r1
700a20ce: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a20d0: 9801         	ldr	r0, [sp, #0x4]
700a20d2: 6bc0         	ldr	r0, [r0, #0x3c]
700a20d4: f00b feb4    	bl	0x700ade40 <UART_IsTxTrigLvlValid> @ imm = #0xbd68
700a20d8: 4601         	mov	r1, r0
700a20da: 9802         	ldr	r0, [sp, #0x8]
700a20dc: 4408         	add	r0, r1
700a20de: 9002         	str	r0, [sp, #0x8]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a20e0: 9801         	ldr	r0, [sp, #0x4]
700a20e2: 6c80         	ldr	r0, [r0, #0x48]
;             || (hUartInit->dmaChCfg == NULL_PTR))
700a20e4: b120         	cbz	r0, 0x700a20f0 <UART_lld_initDma+0x110> @ imm = #0x8
700a20e6: e7ff         	b	0x700a20e8 <UART_lld_initDma+0x108> @ imm = #-0x2
700a20e8: 9801         	ldr	r0, [sp, #0x4]
700a20ea: 6cc0         	ldr	r0, [r0, #0x4c]
;         if((hUartInit->uartDmaHandle == NULL_PTR)
700a20ec: b920         	cbnz	r0, 0x700a20f8 <UART_lld_initDma+0x118> @ imm = #0x8
700a20ee: e7ff         	b	0x700a20f0 <UART_lld_initDma+0x110> @ imm = #-0x2
;             status += UART_INVALID_PARAM;
700a20f0: 9802         	ldr	r0, [sp, #0x8]
700a20f2: 3803         	subs	r0, #0x3
700a20f4: 9002         	str	r0, [sp, #0x8]
;         }
700a20f6: e7ff         	b	0x700a20f8 <UART_lld_initDma+0x118> @ imm = #-0x2
;     }
700a20f8: e7ff         	b	0x700a20fa <UART_lld_initDma+0x11a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a20fa: 9802         	ldr	r0, [sp, #0x8]
700a20fc: b950         	cbnz	r0, 0x700a2114 <UART_lld_initDma+0x134> @ imm = #0x14
700a20fe: e7ff         	b	0x700a2100 <UART_lld_initDma+0x120> @ imm = #-0x2
;         UART_configInstance(hUart);
700a2100: 9803         	ldr	r0, [sp, #0xc]
700a2102: f003 fa95    	bl	0x700a5630 <UART_configInstance> @ imm = #0x352a
;         status = UART_lld_dmaInit(hUart, hUart->hUartInit->dmaChCfg);
700a2106: 9803         	ldr	r0, [sp, #0xc]
700a2108: 6841         	ldr	r1, [r0, #0x4]
700a210a: 6cc9         	ldr	r1, [r1, #0x4c]
700a210c: f00b fa40    	bl	0x700ad590 <UART_lld_dmaInit> @ imm = #0xb480
700a2110: 9002         	str	r0, [sp, #0x8]
;     }
700a2112: e7ff         	b	0x700a2114 <UART_lld_initDma+0x134> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a2114: 9802         	ldr	r0, [sp, #0x8]
700a2116: b920         	cbnz	r0, 0x700a2122 <UART_lld_initDma+0x142> @ imm = #0x8
700a2118: e7ff         	b	0x700a211a <UART_lld_initDma+0x13a> @ imm = #-0x2
;         hUart->state = UART_STATE_READY;
700a211a: 9903         	ldr	r1, [sp, #0xc]
700a211c: 2001         	movs	r0, #0x1
700a211e: 6548         	str	r0, [r1, #0x54]
;     }
700a2120: e004         	b	0x700a212c <UART_lld_initDma+0x14c> @ imm = #0x8
;        status = UART_lld_deInitDma(hUart);
700a2122: 9803         	ldr	r0, [sp, #0xc]
700a2124: f009 fd94    	bl	0x700abc50 <UART_lld_deInitDma> @ imm = #0x9b28
700a2128: 9002         	str	r0, [sp, #0x8]
700a212a: e7ff         	b	0x700a212c <UART_lld_initDma+0x14c> @ imm = #-0x2
;     return status;
700a212c: 9802         	ldr	r0, [sp, #0x8]
700a212e: b004         	add	sp, #0x10
700a2130: bd80         	pop	{r7, pc}
700a2132: 0000         	movs	r0, r0

700a2134 <CSL_armR5PmuSelectCntr>:
;     AND     r0, r0, #0x1F
700a2134: e200001f     	and	r0, r0, #31
;     MCR     p15, #0, r0, c9, c12, #5        /* Write PMSELR Register */
700a2138: ee090fbc     	mcr	p15, #0x0, r0, c9, c12, #0x5
;     BX      lr
700a213c: e12fff1e     	bx	lr

700a2140 <CSL_armR5PmuCfg>:
;     MRC     p15, #0, r3, c9, c12, #0        /* Read PMCR Register */
700a2140: ee193f1c     	mrc	p15, #0x0, r3, c9, c12, #0x0
;     BIC     r3, r3, #((1<<3) | (1<<4))      /* Clear D and X bits */
700a2144: e3c33018     	bic	r3, r3, #24
;     CMP     r0, #0
700a2148: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuCfg_00
700a214c: 0a000000     	beq	0x700a2154 <armR5PmuCfg_00> @ imm = #0x0
;     ORR     r3, r3, #(1<<3)                 /* Set D bit */
700a2150: e3833008     	orr	r3, r3, #8

700a2154 <armR5PmuCfg_00>:
;     CMP     r1, #0
700a2154: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuCfg_01
700a2158: 0a000000     	beq	0x700a2160 <armR5PmuCfg_01> @ imm = #0x0
;     ORR     r3, r3, #(1<<4)                 /* Set X bit */
700a215c: e3833010     	orr	r3, r3, #16

700a2160 <armR5PmuCfg_01>:
;     MCR     p15, #0, r3, c9, c12, #0        /* Write PMCR Register */
700a2160: ee093f1c     	mcr	p15, #0x0, r3, c9, c12, #0x0
;     EOR     r3, r3, r3                      /* Clear r3 */
700a2164: e0233003     	eor	r3, r3, r3
;     CMP     r2, #0
700a2168: e3520000     	cmp	r2, #0
;     BEQ     armR5PmuCfg_02
700a216c: 0a000000     	beq	0x700a2174 <armR5PmuCfg_02> @ imm = #0x0
;     ORR     r3, r3, #1
700a2170: e3833001     	orr	r3, r3, #1

700a2174 <armR5PmuCfg_02>:
;     MCR     p15, #0, r3, c9, c14, #0        /* Write PMUSERENR Register */
700a2174: ee093f1e     	mcr	p15, #0x0, r3, c9, c14, #0x0
;     BX      lr
700a2178: e12fff1e     	bx	lr

700a217c <CSL_armR5PmuEnableAllCntrs>:
;     MRC     p15, #0, r1, c9, c12, #0        /* Read PMCR */
700a217c: ee191f1c     	mrc	p15, #0x0, r1, c9, c12, #0x0
;     CMP     r0, #0
700a2180: e3500000     	cmp	r0, #0
;     BEQ     armR5PmuEnableAllCntrs_disable
700a2184: 0a000001     	beq	0x700a2190 <armR5PmuEnableAllCntrs_disable> @ imm = #0x4
;     ORR     r1, r1, #0x1                    /* Set E bit to enable all counters */
700a2188: e3811001     	orr	r1, r1, #1
;     B       armR5PmuEnableAllCntrs_00
700a218c: ea000000     	b	0x700a2194 <armR5PmuEnableAllCntrs_00> @ imm = #0x0

700a2190 <armR5PmuEnableAllCntrs_disable>:
;     BIC     r1, r1, #0x1                    /* Clr E bit to disable all counters */
700a2190: e3c11001     	bic	r1, r1, #1

700a2194 <armR5PmuEnableAllCntrs_00>:
;     MCR     p15, #0, r1, c9, c12, #0        /* Write modified PMCR */
700a2194: ee091f1c     	mcr	p15, #0x0, r1, c9, c12, #0x0
;     BX      lr
700a2198: e12fff1e     	bx	lr

700a219c <CSL_armR5PmuGetNumCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR (Performance Monitor Control Register) */
700a219c: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     LSR     r0, r0, #11                     /* Shift and */
700a21a0: e1a005a0     	lsr	r0, r0, #11
;     AND     r0, r0, #0x1F                   /*   mask to get N */
700a21a4: e200001f     	and	r0, r0, #31
;     BX      lr
700a21a8: e12fff1e     	bx	lr

700a21ac <CSL_armR5PmuCfgCntr>:
;     PUSH    {lr}
700a21ac: e52de004     	str	lr, [sp, #-0x4]!
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a21b0: ebffffdf     	bl	0x700a2134 <CSL_armR5PmuSelectCntr> @ imm = #-0x84
;     AND     r1, r1, #0xFF
700a21b4: e20110ff     	and	r1, r1, #255
;     MCR     p15, #0, r1, c9, c13, #1        /* Write PMXEVTYPERx Register */
700a21b8: ee091f3d     	mcr	p15, #0x0, r1, c9, c13, #0x1
;     POP     {lr}
700a21bc: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a21c0: e12fff1e     	bx	lr

700a21c4 <CSL_armR5PmuEnableCntrOverflowIntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a21c4: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a21c8: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a21cc: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a21d0: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrOverflowIntr_clear
700a21d4: 0a000001     	beq	0x700a21e0 <armR5PmuEnableCntrOverflowIntr_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c14, #1        /* Write PMINTENSET Register (writes of 0 have no effect) */
700a21d8: ee090f3e     	mcr	p15, #0x0, r0, c9, c14, #0x1
;     B       armR5PmuEnableCntrOverflowIntr_00
700a21dc: ea000000     	b	0x700a21e4 <armR5PmuEnableCntrOverflowIntr_00> @ imm = #0x0

700a21e0 <armR5PmuEnableCntrOverflowIntr_clear>:
;     MCR     p15, #0, r0, c9, c14, #2        /* Write PMINTENCLR Register (writes of 0 have no effect) */
700a21e0: ee090f5e     	mcr	p15, #0x0, r0, c9, c14, #0x2

700a21e4 <armR5PmuEnableCntrOverflowIntr_00>:
;     BX      lr
700a21e4: e12fff1e     	bx	lr

700a21e8 <CSL_armR5PmuEnableCntr>:
;     AND     r0, r0, #0x1F                   /* cntrNum must be <= 31 */
700a21e8: e200001f     	and	r0, r0, #31
;     MOV     r2, #1
700a21ec: e3a02001     	mov	r2, #1
;     LSL     r0, r2, r0                      /* r0 is bit-mask corresponding to cntrNum */
700a21f0: e1a00012     	lsl	r0, r2, r0
;     CMP     r1, #0
700a21f4: e3510000     	cmp	r1, #0
;     BEQ     armR5PmuEnableCntrs_clear
700a21f8: 0a000001     	beq	0x700a2204 <armR5PmuEnableCntrs_clear> @ imm = #0x4
;     MCR     p15, #0, r0, c9, c12, #1        /* Write PMCNTENSET Register (writes of 0 have no effect) */
700a21fc: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;     B       armR5PmuEnableCntrs_00
700a2200: ea000000     	b	0x700a2208 <armR5PmuEnableCntrs_00> @ imm = #0x0

700a2204 <armR5PmuEnableCntrs_clear>:
;     MCR     p15, #0, r0, c9, c12, #2        /* Write PMCNTENCLR Register (writes of 0 have no effect) */
700a2204: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2

700a2208 <armR5PmuEnableCntrs_00>:
;     BX      lr
700a2208: e12fff1e     	bx	lr

700a220c <CSL_armR5PmuReadCntr>:
;     PUSH    {lr}
700a220c: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a2210: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuReadCntr_cycles
700a2214: 0a000002     	beq	0x700a2224 <armR5PmuReadCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a2218: ebffffc5     	bl	0x700a2134 <CSL_armR5PmuSelectCntr> @ imm = #-0xec
;     MRC     p15, #0, r0, c9, c13, #2        /* Read current PMNx Register */
700a221c: ee190f5d     	mrc	p15, #0x0, r0, c9, c13, #0x2
;     B       armR5PmuReadCntr_00
700a2220: ea000000     	b	0x700a2228 <armR5PmuReadCntr_00> @ imm = #0x0

700a2224 <armR5PmuReadCntr_cycles>:
;     MRC     p15, #0, r0, c9, c13, #0        /* Read PMCCNTR Register */
700a2224: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0

700a2228 <armR5PmuReadCntr_00>:
;     POP     {lr}
700a2228: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a222c: e12fff1e     	bx	lr

700a2230 <CSL_armR5PmuSetCntr>:
;     PUSH    {lr}
700a2230: e52de004     	str	lr, [sp, #-0x4]!
;     CMP     r0, #CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM
700a2234: e350001f     	cmp	r0, #31
;     BEQ     armR5PmuSetCntr_cycles
700a2238: 0a000002     	beq	0x700a2248 <armR5PmuSetCntr_cycles> @ imm = #0x8
;     BL      CSL_armR5PmuSelectCntr          /* Select register */
700a223c: ebffffbc     	bl	0x700a2134 <CSL_armR5PmuSelectCntr> @ imm = #-0x110
;     MCR     p15, #0, r1, c9, c13, #2        /* Write current PMNx Register */
700a2240: ee091f5d     	mcr	p15, #0x0, r1, c9, c13, #0x2
;     B       armR5PmuSetCntr_00
700a2244: ea000000     	b	0x700a224c <armR5PmuSetCntr_00> @ imm = #0x0

700a2248 <armR5PmuSetCntr_cycles>:
;     MCR     p15, #0, r1, c9, c13, #0        /* Write PMCCNTR Register */
700a2248: ee091f1d     	mcr	p15, #0x0, r1, c9, c13, #0x0

700a224c <armR5PmuSetCntr_00>:
;     POP     {lr}
700a224c: e49de004     	ldr	lr, [sp], #4
;     BX      lr
700a2250: e12fff1e     	bx	lr

700a2254 <CSL_armR5PmuReadCntrOverflowStatus>:
;     MRC     p15, #0, r0, c9, c12, #3        /* Read PMOVSR Register */
700a2254: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a2258: e12fff1e     	bx	lr

700a225c <CSL_armR5PmuClearCntrOverflowStatus>:
;     MCR     p15, #0, r0, c9, c12, #3        /* Write PMOVSR Register */
700a225c: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;     BX      lr
700a2260: e12fff1e     	bx	lr

700a2264 <CSL_armR5PmuResetCycleCnt>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a2264: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<2)                 /* Set C bit to reset the cycle counter, PMCCNTR, to zero */
700a2268: e3800004     	orr	r0, r0, #4
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR*/
700a226c: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a2270: e12fff1e     	bx	lr

700a2274 <CSL_armR5PmuResetCntrs>:
;     MRC     p15, #0, r0, c9, c12, #0        /* Read PMCR */
700a2274: ee190f1c     	mrc	p15, #0x0, r0, c9, c12, #0x0
;     ORR     r0, r0, #(1<<1)                 /* Set P bit to reset all event counters to zero */
700a2278: e3800002     	orr	r0, r0, #2
;     MCR     p15, #0, r0, c9, c12, #0        /* Write modified PMCR */
700a227c: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;     BX      lr
700a2280: e12fff1e     	bx	lr
		...

700a2290 <xTaskResumeAll>:
; BaseType_t xTaskResumeAll(void) {
700a2290: b580         	push	{r7, lr}
700a2292: b084         	sub	sp, #0x10
700a2294: 2000         	movs	r0, #0x0
;   TCB_t *pxTCB = NULL;
700a2296: 9003         	str	r0, [sp, #0xc]
;   BaseType_t xAlreadyYielded = pdFALSE;
700a2298: 9002         	str	r0, [sp, #0x8]
;   taskENTER_CRITICAL();
700a229a: f00c fa69    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0xc4d2
;     --uxSchedulerSuspended;
700a229e: f642 2024    	movw	r0, #0x2a24
700a22a2: f2c7 000b    	movt	r0, #0x700b
700a22a6: 6801         	ldr	r1, [r0]
700a22a8: 3901         	subs	r1, #0x1
700a22aa: 6001         	str	r1, [r0]
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a22ac: 6800         	ldr	r0, [r0]
700a22ae: 2800         	cmp	r0, #0x0
700a22b0: f040 808f    	bne.w	0x700a23d2 <xTaskResumeAll+0x142> @ imm = #0x11e
700a22b4: e7ff         	b	0x700a22b6 <xTaskResumeAll+0x26> @ imm = #-0x2
;       if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
700a22b6: f642 201c    	movw	r0, #0x2a1c
700a22ba: f2c7 000b    	movt	r0, #0x700b
700a22be: 6800         	ldr	r0, [r0]
700a22c0: 2800         	cmp	r0, #0x0
700a22c2: f000 8085    	beq.w	0x700a23d0 <xTaskResumeAll+0x140> @ imm = #0x10a
700a22c6: e7ff         	b	0x700a22c8 <xTaskResumeAll+0x38> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a22c8: e7ff         	b	0x700a22ca <xTaskResumeAll+0x3a> @ imm = #-0x2
700a22ca: f245 2060    	movw	r0, #0x5260
700a22ce: f2c7 0008    	movt	r0, #0x7008
700a22d2: 6800         	ldr	r0, [r0]
700a22d4: 2800         	cmp	r0, #0x0
700a22d6: d042         	beq	0x700a235e <xTaskResumeAll+0xce> @ imm = #0x84
700a22d8: e7ff         	b	0x700a22da <xTaskResumeAll+0x4a> @ imm = #-0x2
;           pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a22da: f245 2060    	movw	r0, #0x5260
700a22de: f2c7 0008    	movt	r0, #0x7008
700a22e2: 68c0         	ldr	r0, [r0, #0xc]
700a22e4: 68c0         	ldr	r0, [r0, #0xc]
700a22e6: 9003         	str	r0, [sp, #0xc]
;           (void)uxListRemove(&(pxTCB->xEventListItem));
700a22e8: 9803         	ldr	r0, [sp, #0xc]
700a22ea: 3018         	adds	r0, #0x18
700a22ec: f00b fa10    	bl	0x700ad710 <uxListRemove> @ imm = #0xb420
;           (void)uxListRemove(&(pxTCB->xStateListItem));
700a22f0: 9803         	ldr	r0, [sp, #0xc]
700a22f2: 3004         	adds	r0, #0x4
700a22f4: f00b fa0c    	bl	0x700ad710 <uxListRemove> @ imm = #0xb418
;           prvAddTaskToReadyList(pxTCB);
700a22f8: 9803         	ldr	r0, [sp, #0xc]
700a22fa: 6ac0         	ldr	r0, [r0, #0x2c]
700a22fc: f642 212c    	movw	r1, #0x2a2c
700a2300: f2c7 010b    	movt	r1, #0x700b
700a2304: 6809         	ldr	r1, [r1]
700a2306: 4288         	cmp	r0, r1
700a2308: d908         	bls	0x700a231c <xTaskResumeAll+0x8c> @ imm = #0x10
700a230a: e7ff         	b	0x700a230c <xTaskResumeAll+0x7c> @ imm = #-0x2
700a230c: 9803         	ldr	r0, [sp, #0xc]
700a230e: 6ac0         	ldr	r0, [r0, #0x2c]
700a2310: f642 212c    	movw	r1, #0x2a2c
700a2314: f2c7 010b    	movt	r1, #0x700b
700a2318: 6008         	str	r0, [r1]
700a231a: e7ff         	b	0x700a231c <xTaskResumeAll+0x8c> @ imm = #-0x2
700a231c: 9903         	ldr	r1, [sp, #0xc]
700a231e: 6ac8         	ldr	r0, [r1, #0x2c]
700a2320: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a2324: f244 40f8    	movw	r0, #0x44f8
700a2328: f2c7 0008    	movt	r0, #0x7008
700a232c: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a2330: 3104         	adds	r1, #0x4
700a2332: f00b ffa5    	bl	0x700ae280 <vListInsertEnd> @ imm = #0xbf4a
;           if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a2336: 9803         	ldr	r0, [sp, #0xc]
700a2338: 6ac0         	ldr	r0, [r0, #0x2c]
700a233a: f642 11fc    	movw	r1, #0x29fc
700a233e: f2c7 010b    	movt	r1, #0x700b
700a2342: 6809         	ldr	r1, [r1]
700a2344: 6ac9         	ldr	r1, [r1, #0x2c]
700a2346: 4288         	cmp	r0, r1
700a2348: d307         	blo	0x700a235a <xTaskResumeAll+0xca> @ imm = #0xe
700a234a: e7ff         	b	0x700a234c <xTaskResumeAll+0xbc> @ imm = #-0x2
;             xYieldPending = pdTRUE;
700a234c: f642 2150    	movw	r1, #0x2a50
700a2350: f2c7 010b    	movt	r1, #0x700b
700a2354: 2001         	movs	r0, #0x1
700a2356: 6008         	str	r0, [r1]
;           } else {
700a2358: e000         	b	0x700a235c <xTaskResumeAll+0xcc> @ imm = #0x0
700a235a: e7ff         	b	0x700a235c <xTaskResumeAll+0xcc> @ imm = #-0x2
;         while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
700a235c: e7b5         	b	0x700a22ca <xTaskResumeAll+0x3a> @ imm = #-0x96
;         if (pxTCB != NULL) {
700a235e: 9803         	ldr	r0, [sp, #0xc]
700a2360: b118         	cbz	r0, 0x700a236a <xTaskResumeAll+0xda> @ imm = #0x6
700a2362: e7ff         	b	0x700a2364 <xTaskResumeAll+0xd4> @ imm = #-0x2
;           prvResetNextTaskUnblockTime();
700a2364: f00b ff0c    	bl	0x700ae180 <prvResetNextTaskUnblockTime> @ imm = #0xbe18
;         }
700a2368: e7ff         	b	0x700a236a <xTaskResumeAll+0xda> @ imm = #-0x2
;           TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
700a236a: f642 203c    	movw	r0, #0x2a3c
700a236e: f2c7 000b    	movt	r0, #0x700b
700a2372: 6800         	ldr	r0, [r0]
700a2374: 9001         	str	r0, [sp, #0x4]
;           if (xPendedCounts > (TickType_t)0U) {
700a2376: 9801         	ldr	r0, [sp, #0x4]
700a2378: b1e0         	cbz	r0, 0x700a23b4 <xTaskResumeAll+0x124> @ imm = #0x38
700a237a: e7ff         	b	0x700a237c <xTaskResumeAll+0xec> @ imm = #-0x2
;             do {
700a237c: e7ff         	b	0x700a237e <xTaskResumeAll+0xee> @ imm = #-0x2
;               if (xTaskIncrementTick() != pdFALSE) {
700a237e: f7ff f937    	bl	0x700a15f0 <xTaskIncrementTick> @ imm = #-0xd92
700a2382: b138         	cbz	r0, 0x700a2394 <xTaskResumeAll+0x104> @ imm = #0xe
700a2384: e7ff         	b	0x700a2386 <xTaskResumeAll+0xf6> @ imm = #-0x2
;                 xYieldPending = pdTRUE;
700a2386: f642 2150    	movw	r1, #0x2a50
700a238a: f2c7 010b    	movt	r1, #0x700b
700a238e: 2001         	movs	r0, #0x1
700a2390: 6008         	str	r0, [r1]
;               } else {
700a2392: e000         	b	0x700a2396 <xTaskResumeAll+0x106> @ imm = #0x0
700a2394: e7ff         	b	0x700a2396 <xTaskResumeAll+0x106> @ imm = #-0x2
;               --xPendedCounts;
700a2396: 9801         	ldr	r0, [sp, #0x4]
700a2398: 3801         	subs	r0, #0x1
700a239a: 9001         	str	r0, [sp, #0x4]
;             } while (xPendedCounts > (TickType_t)0U);
700a239c: e7ff         	b	0x700a239e <xTaskResumeAll+0x10e> @ imm = #-0x2
700a239e: 9801         	ldr	r0, [sp, #0x4]
700a23a0: 2800         	cmp	r0, #0x0
700a23a2: d1ec         	bne	0x700a237e <xTaskResumeAll+0xee> @ imm = #-0x28
700a23a4: e7ff         	b	0x700a23a6 <xTaskResumeAll+0x116> @ imm = #-0x2
;             xPendedTicks = 0;
700a23a6: f642 213c    	movw	r1, #0x2a3c
700a23aa: f2c7 010b    	movt	r1, #0x700b
700a23ae: 2000         	movs	r0, #0x0
700a23b0: 6008         	str	r0, [r1]
;           } else {
700a23b2: e000         	b	0x700a23b6 <xTaskResumeAll+0x126> @ imm = #0x0
700a23b4: e7ff         	b	0x700a23b6 <xTaskResumeAll+0x126> @ imm = #-0x2
;         if (xYieldPending != pdFALSE) {
700a23b6: f642 2050    	movw	r0, #0x2a50
700a23ba: f2c7 000b    	movt	r0, #0x700b
700a23be: 6800         	ldr	r0, [r0]
700a23c0: b120         	cbz	r0, 0x700a23cc <xTaskResumeAll+0x13c> @ imm = #0x8
700a23c2: e7ff         	b	0x700a23c4 <xTaskResumeAll+0x134> @ imm = #-0x2
700a23c4: 2001         	movs	r0, #0x1
;             xAlreadyYielded = pdTRUE;
700a23c6: 9002         	str	r0, [sp, #0x8]
;           taskYIELD_IF_USING_PREEMPTION();
700a23c8: df00         	svc	#0x0
;         } else {
700a23ca: e000         	b	0x700a23ce <xTaskResumeAll+0x13e> @ imm = #0x0
700a23cc: e7ff         	b	0x700a23ce <xTaskResumeAll+0x13e> @ imm = #-0x2
;       }
700a23ce: e7ff         	b	0x700a23d0 <xTaskResumeAll+0x140> @ imm = #-0x2
;     } else {
700a23d0: e000         	b	0x700a23d4 <xTaskResumeAll+0x144> @ imm = #0x0
700a23d2: e7ff         	b	0x700a23d4 <xTaskResumeAll+0x144> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a23d4: f00b fa8c    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xb518
;   return xAlreadyYielded;
700a23d8: 9802         	ldr	r0, [sp, #0x8]
700a23da: b004         	add	sp, #0x10
700a23dc: bd80         	pop	{r7, pc}
700a23de: 0000         	movs	r0, r0

700a23e0 <Udma_chAssignRegOverlay>:
; {
700a23e0: b082         	sub	sp, #0x8
700a23e2: 9001         	str	r0, [sp, #0x4]
700a23e4: 9100         	str	r1, [sp]
;     if(UDMA_INST_TYPE_LCDMA_BCDMA == drvHandle->instType)
700a23e6: 9801         	ldr	r0, [sp, #0x4]
700a23e8: 6800         	ldr	r0, [r0]
700a23ea: 2801         	cmp	r0, #0x1
700a23ec: d147         	bne	0x700a247e <Udma_chAssignRegOverlay+0x9e> @ imm = #0x8e
700a23ee: e7ff         	b	0x700a23f0 <Udma_chAssignRegOverlay+0x10> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a23f0: 9800         	ldr	r0, [sp]
700a23f2: 6ec0         	ldr	r0, [r0, #0x6c]
700a23f4: f510 3f80    	cmn.w	r0, #0x10000
700a23f8: d029         	beq	0x700a244e <Udma_chAssignRegOverlay+0x6e> @ imm = #0x52
700a23fa: e7ff         	b	0x700a23fc <Udma_chAssignRegOverlay+0x1c> @ imm = #-0x2
;             if((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a23fc: 9800         	ldr	r0, [sp]
700a23fe: 7800         	ldrb	r0, [r0]
700a2400: 0740         	lsls	r0, r0, #0x1d
700a2402: 2800         	cmp	r0, #0x0
700a2404: d511         	bpl	0x700a242a <Udma_chAssignRegOverlay+0x4a> @ imm = #0x22
700a2406: e7ff         	b	0x700a2408 <Udma_chAssignRegOverlay+0x28> @ imm = #-0x2
;                     &drvHandle->bcdmaRegs.pBcChanCfgRegs->CHAN[chHandle->txChNum];
700a2408: 9801         	ldr	r0, [sp, #0x4]
700a240a: 68c0         	ldr	r0, [r0, #0xc]
700a240c: 9900         	ldr	r1, [sp]
700a240e: 6eca         	ldr	r2, [r1, #0x6c]
700a2410: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaBcCfgRegs =
700a2414: f8c1 0214    	str.w	r0, [r1, #0x214]
;                     &drvHandle->bcdmaRegs.pBcChanRtRegs->CHAN[chHandle->txChNum];
700a2418: 9801         	ldr	r0, [sp, #0x4]
700a241a: 6900         	ldr	r0, [r0, #0x10]
700a241c: 9900         	ldr	r1, [sp]
700a241e: 6eca         	ldr	r2, [r1, #0x6c]
700a2420: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaBcRtRegs  =
700a2424: f8c1 0218    	str.w	r0, [r1, #0x218]
;             }
700a2428: e010         	b	0x700a244c <Udma_chAssignRegOverlay+0x6c> @ imm = #0x20
;                     &drvHandle->bcdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a242a: 9801         	ldr	r0, [sp, #0x4]
700a242c: 6940         	ldr	r0, [r0, #0x14]
700a242e: 9900         	ldr	r1, [sp]
700a2430: 6eca         	ldr	r2, [r1, #0x6c]
700a2432: eb00 2002    	add.w	r0, r0, r2, lsl #8
;                 chHandle->pBcdmaTxCfgRegs =
700a2436: f8c1 021c    	str.w	r0, [r1, #0x21c]
;                     &drvHandle->bcdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a243a: 9801         	ldr	r0, [sp, #0x4]
700a243c: 6980         	ldr	r0, [r0, #0x18]
700a243e: 9900         	ldr	r1, [sp]
700a2440: 6eca         	ldr	r2, [r1, #0x6c]
700a2442: eb00 3002    	add.w	r0, r0, r2, lsl #12
;                 chHandle->pBcdmaTxRtRegs  =
700a2446: f8c1 0220    	str.w	r0, [r1, #0x220]
700a244a: e7ff         	b	0x700a244c <Udma_chAssignRegOverlay+0x6c> @ imm = #-0x2
;         }
700a244c: e7ff         	b	0x700a244e <Udma_chAssignRegOverlay+0x6e> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a244e: 9800         	ldr	r0, [sp]
700a2450: 6f00         	ldr	r0, [r0, #0x70]
700a2452: f510 3f80    	cmn.w	r0, #0x10000
700a2456: d011         	beq	0x700a247c <Udma_chAssignRegOverlay+0x9c> @ imm = #0x22
700a2458: e7ff         	b	0x700a245a <Udma_chAssignRegOverlay+0x7a> @ imm = #-0x2
;                 &drvHandle->bcdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a245a: 9801         	ldr	r0, [sp, #0x4]
700a245c: 69c0         	ldr	r0, [r0, #0x1c]
700a245e: 9900         	ldr	r1, [sp]
700a2460: 6f0a         	ldr	r2, [r1, #0x70]
700a2462: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pBcdmaRxCfgRegs =
700a2466: f8c1 0224    	str.w	r0, [r1, #0x224]
;                 &drvHandle->bcdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a246a: 9801         	ldr	r0, [sp, #0x4]
700a246c: 6a00         	ldr	r0, [r0, #0x20]
700a246e: 9900         	ldr	r1, [sp]
700a2470: 6f0a         	ldr	r2, [r1, #0x70]
700a2472: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pBcdmaRxRtRegs  =
700a2476: f8c1 0228    	str.w	r0, [r1, #0x228]
;         }
700a247a: e7ff         	b	0x700a247c <Udma_chAssignRegOverlay+0x9c> @ imm = #-0x2
;     }
700a247c: e051         	b	0x700a2522 <Udma_chAssignRegOverlay+0x142> @ imm = #0xa2
;     else if(UDMA_INST_TYPE_LCDMA_PKTDMA == drvHandle->instType)
700a247e: 9801         	ldr	r0, [sp, #0x4]
700a2480: 6800         	ldr	r0, [r0]
700a2482: 2802         	cmp	r0, #0x2
700a2484: d14c         	bne	0x700a2520 <Udma_chAssignRegOverlay+0x140> @ imm = #0x98
700a2486: e7ff         	b	0x700a2488 <Udma_chAssignRegOverlay+0xa8> @ imm = #-0x2
;         if(chHandle->txChNum != UDMA_DMA_CH_INVALID)
700a2488: 9800         	ldr	r0, [sp]
700a248a: 6ec0         	ldr	r0, [r0, #0x6c]
700a248c: f510 3f80    	cmn.w	r0, #0x10000
700a2490: d011         	beq	0x700a24b6 <Udma_chAssignRegOverlay+0xd6> @ imm = #0x22
700a2492: e7ff         	b	0x700a2494 <Udma_chAssignRegOverlay+0xb4> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[chHandle->txChNum];
700a2494: 9801         	ldr	r0, [sp, #0x4]
700a2496: 6dc0         	ldr	r0, [r0, #0x5c]
700a2498: 9900         	ldr	r1, [sp]
700a249a: 6eca         	ldr	r2, [r1, #0x6c]
700a249c: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaTxCfgRegs =
700a24a0: f8c1 022c    	str.w	r0, [r1, #0x22c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[chHandle->txChNum];
700a24a4: 9801         	ldr	r0, [sp, #0x4]
700a24a6: 6e40         	ldr	r0, [r0, #0x64]
700a24a8: 9900         	ldr	r1, [sp]
700a24aa: 6eca         	ldr	r2, [r1, #0x6c]
700a24ac: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaTxRtRegs  =
700a24b0: f8c1 0230    	str.w	r0, [r1, #0x230]
;         }
700a24b4: e7ff         	b	0x700a24b6 <Udma_chAssignRegOverlay+0xd6> @ imm = #-0x2
;         if(chHandle->rxChNum != UDMA_DMA_CH_INVALID)
700a24b6: 9800         	ldr	r0, [sp]
700a24b8: 6f00         	ldr	r0, [r0, #0x70]
700a24ba: f510 3f80    	cmn.w	r0, #0x10000
700a24be: d011         	beq	0x700a24e4 <Udma_chAssignRegOverlay+0x104> @ imm = #0x22
700a24c0: e7ff         	b	0x700a24c2 <Udma_chAssignRegOverlay+0xe2> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pRxChanCfgRegs->CHAN[chHandle->rxChNum];
700a24c2: 9801         	ldr	r0, [sp, #0x4]
700a24c4: 6e00         	ldr	r0, [r0, #0x60]
700a24c6: 9900         	ldr	r1, [sp]
700a24c8: 6f0a         	ldr	r2, [r1, #0x70]
700a24ca: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaRxCfgRegs =
700a24ce: f8c1 0234    	str.w	r0, [r1, #0x234]
;                 &drvHandle->pktdmaRegs.pRxChanRtRegs->CHAN[chHandle->rxChNum];
700a24d2: 9801         	ldr	r0, [sp, #0x4]
700a24d4: 6e80         	ldr	r0, [r0, #0x68]
700a24d6: 9900         	ldr	r1, [sp]
700a24d8: 6f0a         	ldr	r2, [r1, #0x70]
700a24da: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaRxRtRegs  =
700a24de: f8c1 0238    	str.w	r0, [r1, #0x238]
;         }
700a24e2: e7ff         	b	0x700a24e4 <Udma_chAssignRegOverlay+0x104> @ imm = #-0x2
;         if(chHandle->extChNum != UDMA_DMA_CH_INVALID)
700a24e4: 9800         	ldr	r0, [sp]
700a24e6: 6f40         	ldr	r0, [r0, #0x74]
700a24e8: f510 3f80    	cmn.w	r0, #0x10000
700a24ec: d017         	beq	0x700a251e <Udma_chAssignRegOverlay+0x13e> @ imm = #0x2e
700a24ee: e7ff         	b	0x700a24f0 <Udma_chAssignRegOverlay+0x110> @ imm = #-0x2
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a24f0: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a24f2: 9900         	ldr	r1, [sp]
700a24f4: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a24f6: 6dd8         	ldr	r0, [r3, #0x5c]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a24f8: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a24fc: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanCfgRegs->CHAN[
700a24fe: eb00 2002    	add.w	r0, r0, r2, lsl #8
;             chHandle->pPktdmaExtCfgRegs =
700a2502: f8c1 023c    	str.w	r0, [r1, #0x23c]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a2506: 9b01         	ldr	r3, [sp, #0x4]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a2508: 9900         	ldr	r1, [sp]
700a250a: 6f4a         	ldr	r2, [r1, #0x74]
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a250c: 6e58         	ldr	r0, [r3, #0x64]
;                                 chHandle->extChNum + drvHandle->extChOffset];
700a250e: f8d3 3110    	ldr.w	r3, [r3, #0x110]
700a2512: 441a         	add	r2, r3
;                 &drvHandle->pktdmaRegs.pTxChanRtRegs->CHAN[
700a2514: eb00 3002    	add.w	r0, r0, r2, lsl #12
;             chHandle->pPktdmaExtRtRegs  =
700a2518: f8c1 0240    	str.w	r0, [r1, #0x240]
;         }
700a251c: e7ff         	b	0x700a251e <Udma_chAssignRegOverlay+0x13e> @ imm = #-0x2
;     }
700a251e: e7ff         	b	0x700a2520 <Udma_chAssignRegOverlay+0x140> @ imm = #-0x2
700a2520: e7ff         	b	0x700a2522 <Udma_chAssignRegOverlay+0x142> @ imm = #-0x2
; }
700a2522: b002         	add	sp, #0x8
700a2524: 4770         	bx	lr
		...
700a252e: 0000         	movs	r0, r0

700a2530 <DebugP_memLogWriterPutChar>:
; {
700a2530: b580         	push	{r7, lr}
700a2532: b088         	sub	sp, #0x20
700a2534: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     if(lineBufIndex==0U)
700a2538: f642 00bc    	movw	r0, #0x28bc
700a253c: f2c7 000b    	movt	r0, #0x700b
700a2540: 6800         	ldr	r0, [r0]
700a2542: bb40         	cbnz	r0, 0x700a2596 <DebugP_memLogWriterPutChar+0x66> @ imm = #0x50
700a2544: e7ff         	b	0x700a2546 <DebugP_memLogWriterPutChar+0x16> @ imm = #-0x2
;         uint64_t curTime = ClockP_getTimeUsec();
700a2546: f008 fb1b    	bl	0x700aab80 <ClockP_getTimeUsec> @ imm = #0x8636
700a254a: 9105         	str	r1, [sp, #0x14]
700a254c: 9004         	str	r0, [sp, #0x10]
;                             gDebugP_memTraceLogWriterSelfCoreName,
700a254e: f642 10e0    	movw	r0, #0x29e0
700a2552: f2c7 000b    	movt	r0, #0x700b
700a2556: 6800         	ldr	r0, [r0]
;                             (uint32_t)(curTime/TIME_IN_MICRO_SECONDS),
700a2558: 9003         	str	r0, [sp, #0xc]
700a255a: 9804         	ldr	r0, [sp, #0x10]
700a255c: 9905         	ldr	r1, [sp, #0x14]
700a255e: f244 2240    	movw	r2, #0x4240
700a2562: f2c0 020f    	movt	r2, #0xf
700a2566: 2300         	movs	r3, #0x0
;                             (uint32_t)(curTime%TIME_IN_MICRO_SECONDS)
700a2568: f00c ee34    	blx	0x700af1d4 <__aeabi_uldivmod> @ imm = #0xcc68
700a256c: 9b03         	ldr	r3, [sp, #0xc]
;         lineBufIndex = (uint32_t)snprintf_((char*)lineBuf, DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE, "[%6s] %5d.%06ds : ",
700a256e: 4669         	mov	r1, sp
700a2570: 604a         	str	r2, [r1, #0x4]
700a2572: 6008         	str	r0, [r1]
700a2574: f245 00c0    	movw	r0, #0x50c0
700a2578: f2c7 0008    	movt	r0, #0x7008
700a257c: f641 72a8    	movw	r2, #0x1fa8
700a2580: f2c7 020b    	movt	r2, #0x700b
700a2584: 2178         	movs	r1, #0x78
700a2586: f00b fe5b    	bl	0x700ae240 <snprintf_>  @ imm = #0xbcb6
700a258a: f642 01bc    	movw	r1, #0x28bc
700a258e: f2c7 010b    	movt	r1, #0x700b
700a2592: 6008         	str	r0, [r1]
;     }
700a2594: e7ff         	b	0x700a2596 <DebugP_memLogWriterPutChar+0x66> @ imm = #-0x2
;     lineBuf[lineBufIndex]=(uint8_t)character;
700a2596: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a259a: f642 01bc    	movw	r1, #0x28bc
700a259e: f2c7 010b    	movt	r1, #0x700b
700a25a2: 680b         	ldr	r3, [r1]
700a25a4: f245 02c0    	movw	r2, #0x50c0
700a25a8: f2c7 0208    	movt	r2, #0x7008
700a25ac: 54d0         	strb	r0, [r2, r3]
; 	lineBufIndex = lineBufIndex + 1U;
700a25ae: 6808         	ldr	r0, [r1]
700a25b0: 3001         	adds	r0, #0x1
700a25b2: 6008         	str	r0, [r1]
;     if( (character == '\n') ||
700a25b4: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700a25b8: 280a         	cmp	r0, #0xa
700a25ba: d008         	beq	0x700a25ce <DebugP_memLogWriterPutChar+0x9e> @ imm = #0x10
700a25bc: e7ff         	b	0x700a25be <DebugP_memLogWriterPutChar+0x8e> @ imm = #-0x2
;         (lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE)))
700a25be: f642 00bc    	movw	r0, #0x28bc
700a25c2: f2c7 000b    	movt	r0, #0x700b
700a25c6: 6800         	ldr	r0, [r0]
;     if( (character == '\n') ||
700a25c8: 2878         	cmp	r0, #0x78
700a25ca: d350         	blo	0x700a266e <DebugP_memLogWriterPutChar+0x13e> @ imm = #0xa0
700a25cc: e7ff         	b	0x700a25ce <DebugP_memLogWriterPutChar+0x9e> @ imm = #-0x2
;         if(lineBufIndex >= (DEBUGP_MEM_TRACE_LOG_WRITER_LINE_BUF_SIZE))
700a25ce: f642 00bc    	movw	r0, #0x28bc
700a25d2: f2c7 000b    	movt	r0, #0x700b
700a25d6: 6800         	ldr	r0, [r0]
700a25d8: 2878         	cmp	r0, #0x78
700a25da: d315         	blo	0x700a2608 <DebugP_memLogWriterPutChar+0xd8> @ imm = #0x2a
700a25dc: e7ff         	b	0x700a25de <DebugP_memLogWriterPutChar+0xae> @ imm = #-0x2
;             lineBuf[lineBufIndex]=(uint8_t)'\r';
700a25de: f642 01bc    	movw	r1, #0x28bc
700a25e2: f2c7 010b    	movt	r1, #0x700b
700a25e6: 680b         	ldr	r3, [r1]
700a25e8: f245 02c0    	movw	r2, #0x50c0
700a25ec: f2c7 0208    	movt	r2, #0x7008
700a25f0: 200d         	movs	r0, #0xd
700a25f2: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a25f4: 6808         	ldr	r0, [r1]
700a25f6: 3001         	adds	r0, #0x1
700a25f8: 6008         	str	r0, [r1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a25fa: 680b         	ldr	r3, [r1]
700a25fc: 200a         	movs	r0, #0xa
700a25fe: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a2600: 6808         	ldr	r0, [r1]
700a2602: 3001         	adds	r0, #0x1
700a2604: 6008         	str	r0, [r1]
;         }
700a2606: e7ff         	b	0x700a2608 <DebugP_memLogWriterPutChar+0xd8> @ imm = #-0x2
;         if(lineBuf[lineBufIndex-UNSIGNED_INTEGERVAL_TWO]!=(uint8_t)'\r')
700a2608: f642 00bc    	movw	r0, #0x28bc
700a260c: f2c7 000b    	movt	r0, #0x700b
700a2610: 6800         	ldr	r0, [r0]
700a2612: f245 01c0    	movw	r1, #0x50c0
700a2616: f2c7 0108    	movt	r1, #0x7008
700a261a: 4408         	add	r0, r1
700a261c: f810 0c02    	ldrb	r0, [r0, #-2]
700a2620: 280d         	cmp	r0, #0xd
700a2622: d014         	beq	0x700a264e <DebugP_memLogWriterPutChar+0x11e> @ imm = #0x28
700a2624: e7ff         	b	0x700a2626 <DebugP_memLogWriterPutChar+0xf6> @ imm = #-0x2
;             lineBuf[lineBufIndex-1U]=(uint8_t)'\r';
700a2626: f642 01bc    	movw	r1, #0x28bc
700a262a: f2c7 010b    	movt	r1, #0x700b
700a262e: 6808         	ldr	r0, [r1]
700a2630: f245 02c0    	movw	r2, #0x50c0
700a2634: f2c7 0208    	movt	r2, #0x7008
700a2638: 1883         	adds	r3, r0, r2
700a263a: 200d         	movs	r0, #0xd
700a263c: f803 0c01    	strb	r0, [r3, #-1]
;             lineBuf[lineBufIndex]=(uint8_t)'\n';
700a2640: 680b         	ldr	r3, [r1]
700a2642: 200a         	movs	r0, #0xa
700a2644: 54d0         	strb	r0, [r2, r3]
; 			lineBufIndex = lineBufIndex + 1U;
700a2646: 6808         	ldr	r0, [r1]
700a2648: 3001         	adds	r0, #0x1
700a264a: 6008         	str	r0, [r1]
;         }
700a264c: e7ff         	b	0x700a264e <DebugP_memLogWriterPutChar+0x11e> @ imm = #-0x2
;         DebugP_memTraceLogWriterPutLine(lineBuf, (uint16_t)lineBufIndex);
700a264e: f642 00bc    	movw	r0, #0x28bc
700a2652: f2c7 000b    	movt	r0, #0x700b
700a2656: 9002         	str	r0, [sp, #0x8]
700a2658: 8801         	ldrh	r1, [r0]
700a265a: f245 00c0    	movw	r0, #0x50c0
700a265e: f2c7 0008    	movt	r0, #0x7008
700a2662: f003 fbc5    	bl	0x700a5df0 <DebugP_memTraceLogWriterPutLine> @ imm = #0x378a
700a2666: 9902         	ldr	r1, [sp, #0x8]
700a2668: 2000         	movs	r0, #0x0
;         lineBufIndex = 0;
700a266a: 6008         	str	r0, [r1]
;     }
700a266c: e7ff         	b	0x700a266e <DebugP_memLogWriterPutChar+0x13e> @ imm = #-0x2
; }
700a266e: b008         	add	sp, #0x20
700a2670: bd80         	pop	{r7, pc}
		...
700a267e: 0000         	movs	r0, r0

700a2680 <Sciclient_sendMessage>:
; {
700a2680: b580         	push	{r7, lr}
700a2682: b08a         	sub	sp, #0x28
700a2684: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a2688: 9009         	str	r0, [sp, #0x24]
700a268a: 9108         	str	r1, [sp, #0x20]
700a268c: 9207         	str	r2, [sp, #0x1c]
700a268e: 9306         	str	r3, [sp, #0x18]
700a2690: 2200         	movs	r2, #0x0
;     uint32_t        i   = 0U;
700a2692: 9205         	str	r2, [sp, #0x14]
;     const uint8_t *msg = pSecHeader;
700a2694: 9808         	ldr	r0, [sp, #0x20]
700a2696: 9004         	str	r0, [sp, #0x10]
;     uint32_t numWords   = 0U;
700a2698: 9203         	str	r2, [sp, #0xc]
;     uint32_t test = 0U;
700a269a: 9202         	str	r2, [sp, #0x8]
;     uintptr_t threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U);
700a269c: 9909         	ldr	r1, [sp, #0x24]
700a269e: f642 00c0    	movw	r0, #0x28c0
700a26a2: f2c7 000b    	movt	r0, #0x700b
700a26a6: f00c ff5b    	bl	0x700af560 <CSL_secProxyGetDataAddr> @ imm = #0xceb6
700a26aa: 9001         	str	r0, [sp, #0x4]
;     if(pSecHeader != NULL)
700a26ac: 9808         	ldr	r0, [sp, #0x20]
700a26ae: b1f8         	cbz	r0, 0x700a26f0 <Sciclient_sendMessage+0x70> @ imm = #0x3e
700a26b0: e7ff         	b	0x700a26b2 <Sciclient_sendMessage+0x32> @ imm = #-0x2
700a26b2: 2000         	movs	r0, #0x0
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a26b4: 9005         	str	r0, [sp, #0x14]
700a26b6: e7ff         	b	0x700a26b8 <Sciclient_sendMessage+0x38> @ imm = #-0x2
700a26b8: 9805         	ldr	r0, [sp, #0x14]
700a26ba: f642 2154    	movw	r1, #0x2a54
700a26be: f2c7 010b    	movt	r1, #0x700b
700a26c2: 7809         	ldrb	r1, [r1]
700a26c4: 4288         	cmp	r0, r1
700a26c6: d212         	bhs	0x700a26ee <Sciclient_sendMessage+0x6e> @ imm = #0x24
700a26c8: e7ff         	b	0x700a26ca <Sciclient_sendMessage+0x4a> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a26ca: 9804         	ldr	r0, [sp, #0x10]
700a26cc: 6800         	ldr	r0, [r0]
700a26ce: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a26d0: 9801         	ldr	r0, [sp, #0x4]
700a26d2: 9902         	ldr	r1, [sp, #0x8]
700a26d4: f00d fa0c    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0xd418
;             msg += 4;
700a26d8: 9804         	ldr	r0, [sp, #0x10]
700a26da: 3004         	adds	r0, #0x4
700a26dc: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a26de: 9801         	ldr	r0, [sp, #0x4]
700a26e0: 3004         	adds	r0, #0x4
700a26e2: 9001         	str	r0, [sp, #0x4]
;         }
700a26e4: e7ff         	b	0x700a26e6 <Sciclient_sendMessage+0x66> @ imm = #-0x2
;         for (i = 0U; i < gSecHeaderSizeWords; i++)
700a26e6: 9805         	ldr	r0, [sp, #0x14]
700a26e8: 3001         	adds	r0, #0x1
700a26ea: 9005         	str	r0, [sp, #0x14]
700a26ec: e7e4         	b	0x700a26b8 <Sciclient_sendMessage+0x38> @ imm = #-0x38
;     }
700a26ee: e7ff         	b	0x700a26f0 <Sciclient_sendMessage+0x70> @ imm = #-0x2
;     msg = pHeader;
700a26f0: 9807         	ldr	r0, [sp, #0x1c]
700a26f2: 9004         	str	r0, [sp, #0x10]
700a26f4: 2000         	movs	r0, #0x0
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a26f6: 9005         	str	r0, [sp, #0x14]
700a26f8: e7ff         	b	0x700a26fa <Sciclient_sendMessage+0x7a> @ imm = #-0x2
700a26fa: 9805         	ldr	r0, [sp, #0x14]
700a26fc: 2801         	cmp	r0, #0x1
700a26fe: d812         	bhi	0x700a2726 <Sciclient_sendMessage+0xa6> @ imm = #0x24
700a2700: e7ff         	b	0x700a2702 <Sciclient_sendMessage+0x82> @ imm = #-0x2
;         (void) memcpy((void *)&test, (const void *)msg, 4);
700a2702: 9804         	ldr	r0, [sp, #0x10]
700a2704: 6800         	ldr	r0, [r0]
700a2706: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(threadAddr, test);
700a2708: 9801         	ldr	r0, [sp, #0x4]
700a270a: 9902         	ldr	r1, [sp, #0x8]
700a270c: f00d f9f0    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0xd3e0
;         msg += 4;
700a2710: 9804         	ldr	r0, [sp, #0x10]
700a2712: 3004         	adds	r0, #0x4
700a2714: 9004         	str	r0, [sp, #0x10]
;         threadAddr+=sizeof(uint32_t);
700a2716: 9801         	ldr	r0, [sp, #0x4]
700a2718: 3004         	adds	r0, #0x4
700a271a: 9001         	str	r0, [sp, #0x4]
;     }
700a271c: e7ff         	b	0x700a271e <Sciclient_sendMessage+0x9e> @ imm = #-0x2
;     for (i = 0U; i < SCICLIENT_HEADER_SIZE_IN_WORDS; i++)
700a271e: 9805         	ldr	r0, [sp, #0x14]
700a2720: 3001         	adds	r0, #0x1
700a2722: 9005         	str	r0, [sp, #0x14]
700a2724: e7e9         	b	0x700a26fa <Sciclient_sendMessage+0x7a> @ imm = #-0x2e
;     if (payloadSize > 0U)
700a2726: 980c         	ldr	r0, [sp, #0x30]
700a2728: b300         	cbz	r0, 0x700a276c <Sciclient_sendMessage+0xec> @ imm = #0x40
700a272a: e7ff         	b	0x700a272c <Sciclient_sendMessage+0xac> @ imm = #-0x2
;         numWords   = (payloadSize+3U)/4U;
700a272c: 980c         	ldr	r0, [sp, #0x30]
700a272e: 3003         	adds	r0, #0x3
700a2730: 0880         	lsrs	r0, r0, #0x2
700a2732: 9003         	str	r0, [sp, #0xc]
;         msg = pPayload;
700a2734: 9806         	ldr	r0, [sp, #0x18]
700a2736: 9004         	str	r0, [sp, #0x10]
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a2738: e7ff         	b	0x700a273a <Sciclient_sendMessage+0xba> @ imm = #-0x2
700a273a: 9805         	ldr	r0, [sp, #0x14]
700a273c: 9903         	ldr	r1, [sp, #0xc]
700a273e: 3102         	adds	r1, #0x2
700a2740: 4288         	cmp	r0, r1
700a2742: d212         	bhs	0x700a276a <Sciclient_sendMessage+0xea> @ imm = #0x24
700a2744: e7ff         	b	0x700a2746 <Sciclient_sendMessage+0xc6> @ imm = #-0x2
;             (void) memcpy((void *)&test, (const void *)msg, 4);
700a2746: 9804         	ldr	r0, [sp, #0x10]
700a2748: 6800         	ldr	r0, [r0]
700a274a: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(threadAddr, test);
700a274c: 9801         	ldr	r0, [sp, #0x4]
700a274e: 9902         	ldr	r1, [sp, #0x8]
700a2750: f00d f9ce    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0xd39c
;             msg += 4;
700a2754: 9804         	ldr	r0, [sp, #0x10]
700a2756: 3004         	adds	r0, #0x4
700a2758: 9004         	str	r0, [sp, #0x10]
;             threadAddr+=sizeof(uint32_t);
700a275a: 9801         	ldr	r0, [sp, #0x4]
700a275c: 3004         	adds	r0, #0x4
700a275e: 9001         	str	r0, [sp, #0x4]
;         }
700a2760: e7ff         	b	0x700a2762 <Sciclient_sendMessage+0xe2> @ imm = #-0x2
;         for (; i < (SCICLIENT_HEADER_SIZE_IN_WORDS + numWords); i++)
700a2762: 9805         	ldr	r0, [sp, #0x14]
700a2764: 3001         	adds	r0, #0x1
700a2766: 9005         	str	r0, [sp, #0x14]
700a2768: e7e7         	b	0x700a273a <Sciclient_sendMessage+0xba> @ imm = #-0x32
;     }
700a276a: e7ff         	b	0x700a276c <Sciclient_sendMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a276c: f642 2054    	movw	r0, #0x2a54
700a2770: f2c7 000b    	movt	r0, #0x700b
700a2774: 7801         	ldrb	r1, [r0]
700a2776: 980c         	ldr	r0, [sp, #0x30]
700a2778: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a277c: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a277e: f642 1148    	movw	r1, #0x2948
700a2782: f2c7 010b    	movt	r1, #0x700b
700a2786: 6949         	ldr	r1, [r1, #0x14]
700a2788: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U)+(SCICLIENT_HEADER_SIZE_IN_WORDS*4U)+payloadSize) <=
700a278a: 4288         	cmp	r0, r1
700a278c: d817         	bhi	0x700a27be <Sciclient_sendMessage+0x13e> @ imm = #0x2e
700a278e: e7ff         	b	0x700a2790 <Sciclient_sendMessage+0x110> @ imm = #-0x2
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a2790: 9909         	ldr	r1, [sp, #0x24]
700a2792: f642 00c0    	movw	r0, #0x28c0
700a2796: f2c7 000b    	movt	r0, #0x700b
700a279a: 2200         	movs	r2, #0x0
700a279c: 9200         	str	r2, [sp]
700a279e: f00c fedf    	bl	0x700af560 <CSL_secProxyGetDataAddr> @ imm = #0xcdbe
700a27a2: 9900         	ldr	r1, [sp]
700a27a4: 4602         	mov	r2, r0
;         ((uintptr_t) gSciclientHandle.maxMsgSizeBytes  - (uintptr_t) 4U) ;
700a27a6: f642 1048    	movw	r0, #0x2948
700a27aa: f2c7 000b    	movt	r0, #0x700b
700a27ae: 6940         	ldr	r0, [r0, #0x14]
;         threadAddr = CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg, thread, 0U) +
700a27b0: 4410         	add	r0, r2
700a27b2: 3804         	subs	r0, #0x4
700a27b4: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(threadAddr,0U);
700a27b6: 9801         	ldr	r0, [sp, #0x4]
700a27b8: f00d f99a    	bl	0x700afaf0 <CSL_REG32_WR_RAW> @ imm = #0xd334
;     }
700a27bc: e7ff         	b	0x700a27be <Sciclient_sendMessage+0x13e> @ imm = #-0x2
; }
700a27be: b00a         	add	sp, #0x28
700a27c0: bd80         	pop	{r7, pc}
		...
700a27ce: 0000         	movs	r0, r0

700a27d0 <Sciclient_rmIaValidateMapping>:
; {
700a27d0: b580         	push	{r7, lr}
700a27d2: b088         	sub	sp, #0x20
700a27d4: 4684         	mov	r12, r0
700a27d6: 980a         	ldr	r0, [sp, #0x28]
700a27d8: f88d c01f    	strb.w	r12, [sp, #0x1f]
700a27dc: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a27e0: f8ad 201a    	strh.w	r2, [sp, #0x1a]
700a27e4: f8ad 3018    	strh.w	r3, [sp, #0x18]
700a27e8: f88d 0017    	strb.w	r0, [sp, #0x17]
700a27ec: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a27ee: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700a27f0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700a27f2: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a27f6: f009 fea3    	bl	0x700ac540 <Sciclient_rmIaGetInst> @ imm = #0x9d46
700a27fa: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a27fc: 9803         	ldr	r0, [sp, #0xc]
700a27fe: b920         	cbnz	r0, 0x700a280a <Sciclient_rmIaValidateMapping+0x3a> @ imm = #0x8
700a2800: e7ff         	b	0x700a2802 <Sciclient_rmIaValidateMapping+0x32> @ imm = #-0x2
700a2802: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a2806: 9004         	str	r0, [sp, #0x10]
;     } else {
700a2808: e00b         	b	0x700a2822 <Sciclient_rmIaValidateMapping+0x52> @ imm = #0x16
;         if (vint >= inst->n_vint) {
700a280a: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a280e: 9903         	ldr	r1, [sp, #0xc]
700a2810: 8989         	ldrh	r1, [r1, #0xc]
700a2812: 4288         	cmp	r0, r1
700a2814: db04         	blt	0x700a2820 <Sciclient_rmIaValidateMapping+0x50> @ imm = #0x8
700a2816: e7ff         	b	0x700a2818 <Sciclient_rmIaValidateMapping+0x48> @ imm = #-0x2
700a2818: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a281c: 9004         	str	r0, [sp, #0x10]
;         }
700a281e: e7ff         	b	0x700a2820 <Sciclient_rmIaValidateMapping+0x50> @ imm = #-0x2
700a2820: e7ff         	b	0x700a2822 <Sciclient_rmIaValidateMapping+0x52> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (vint_sb_index >= SCICLIENT_IA_VINT_MAX_BITS)) {
700a2822: 9804         	ldr	r0, [sp, #0x10]
700a2824: b948         	cbnz	r0, 0x700a283a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x12
700a2826: e7ff         	b	0x700a2828 <Sciclient_rmIaValidateMapping+0x58> @ imm = #-0x2
700a2828: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a282c: 2840         	cmp	r0, #0x40
700a282e: d304         	blo	0x700a283a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #0x8
700a2830: e7ff         	b	0x700a2832 <Sciclient_rmIaValidateMapping+0x62> @ imm = #-0x2
700a2832: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a2836: 9004         	str	r0, [sp, #0x10]
;     }
700a2838: e7ff         	b	0x700a283a <Sciclient_rmIaValidateMapping+0x6a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a283a: 9804         	ldr	r0, [sp, #0x10]
700a283c: b998         	cbnz	r0, 0x700a2866 <Sciclient_rmIaValidateMapping+0x96> @ imm = #0x26
700a283e: e7ff         	b	0x700a2840 <Sciclient_rmIaValidateMapping+0x70> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700a2840: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a2844: 9903         	ldr	r1, [sp, #0xc]
700a2846: 8909         	ldrh	r1, [r1, #0x8]
700a2848: 1a40         	subs	r0, r0, r1
700a284a: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         if (evt >= inst->n_sevt) {
700a284e: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a2852: 9903         	ldr	r1, [sp, #0xc]
700a2854: 8949         	ldrh	r1, [r1, #0xa]
700a2856: 4288         	cmp	r0, r1
700a2858: db04         	blt	0x700a2864 <Sciclient_rmIaValidateMapping+0x94> @ imm = #0x8
700a285a: e7ff         	b	0x700a285c <Sciclient_rmIaValidateMapping+0x8c> @ imm = #-0x2
700a285c: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a2860: 9004         	str	r0, [sp, #0x10]
;         }
700a2862: e7ff         	b	0x700a2864 <Sciclient_rmIaValidateMapping+0x94> @ imm = #-0x2
;     }
700a2864: e7ff         	b	0x700a2866 <Sciclient_rmIaValidateMapping+0x96> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a2866: 9804         	ldr	r0, [sp, #0x10]
700a2868: 2800         	cmp	r0, #0x0
700a286a: d14e         	bne	0x700a290a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #0x9c
700a286c: e7ff         	b	0x700a286e <Sciclient_rmIaValidateMapping+0x9e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a286e: 9803         	ldr	r0, [sp, #0xc]
700a2870: 6840         	ldr	r0, [r0, #0x4]
700a2872: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a2876: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a287a: 9001         	str	r0, [sp, #0x4]
;         reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a287c: 9801         	ldr	r0, [sp, #0x4]
700a287e: f64f 7100    	movw	r1, #0xff00
700a2882: f2c0 0101    	movt	r1, #0x1
700a2886: 2208         	movs	r2, #0x8
700a2888: f00c fc62    	bl	0x700af150 <CSL_REG32_FEXT_RAW> @ imm = #0xc8c4
700a288c: f8ad 0002    	strh.w	r0, [sp, #0x2]
;         reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a2890: 9801         	ldr	r0, [sp, #0x4]
700a2892: 213f         	movs	r1, #0x3f
700a2894: 2200         	movs	r2, #0x0
700a2896: f00c fc5b    	bl	0x700af150 <CSL_REG32_FEXT_RAW> @ imm = #0xc8b6
700a289a: f8ad 0000    	strh.w	r0, [sp]
;         if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a289e: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a28a2: b9f0         	cbnz	r0, 0x700a28e2 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x3c
700a28a4: e7ff         	b	0x700a28a6 <Sciclient_rmIaValidateMapping+0xd6> @ imm = #-0x2
700a28a6: f8bd 0000    	ldrh.w	r0, [sp]
700a28aa: b9d0         	cbnz	r0, 0x700a28e2 <Sciclient_rmIaValidateMapping+0x112> @ imm = #0x34
700a28ac: e7ff         	b	0x700a28ae <Sciclient_rmIaValidateMapping+0xde> @ imm = #-0x2
;             if ((vint != reg_vint) &&
700a28ae: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a28b2: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a28b6: 4288         	cmp	r0, r1
700a28b8: d012         	beq	0x700a28e0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x24
700a28ba: e7ff         	b	0x700a28bc <Sciclient_rmIaValidateMapping+0xec> @ imm = #-0x2
;                 (vint_sb_index != reg_sb) &&
700a28bc: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a28c0: f8bd 1000    	ldrh.w	r1, [sp]
700a28c4: 4288         	cmp	r0, r1
700a28c6: d00b         	beq	0x700a28e0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x16
700a28c8: e7ff         	b	0x700a28ca <Sciclient_rmIaValidateMapping+0xfa> @ imm = #-0x2
;                 (evt != inst->v0_b0_evt)) {
700a28ca: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a28ce: 9903         	ldr	r1, [sp, #0xc]
700a28d0: 8a89         	ldrh	r1, [r1, #0x14]
;             if ((vint != reg_vint) &&
700a28d2: 4288         	cmp	r0, r1
700a28d4: d004         	beq	0x700a28e0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #0x8
700a28d6: e7ff         	b	0x700a28d8 <Sciclient_rmIaValidateMapping+0x108> @ imm = #-0x2
700a28d8: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a28dc: 9004         	str	r0, [sp, #0x10]
;             }
700a28de: e7ff         	b	0x700a28e0 <Sciclient_rmIaValidateMapping+0x110> @ imm = #-0x2
;         } else {
700a28e0: e012         	b	0x700a2908 <Sciclient_rmIaValidateMapping+0x138> @ imm = #0x24
;             if ((vint != reg_vint) &&
700a28e2: f8bd 001a    	ldrh.w	r0, [sp, #0x1a]
700a28e6: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a28ea: 4288         	cmp	r0, r1
700a28ec: d00b         	beq	0x700a2906 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x16
700a28ee: e7ff         	b	0x700a28f0 <Sciclient_rmIaValidateMapping+0x120> @ imm = #-0x2
;                 (vint_sb_index != reg_sb)) {
700a28f0: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a28f4: f8bd 1000    	ldrh.w	r1, [sp]
;             if ((vint != reg_vint) &&
700a28f8: 4288         	cmp	r0, r1
700a28fa: d004         	beq	0x700a2906 <Sciclient_rmIaValidateMapping+0x136> @ imm = #0x8
700a28fc: e7ff         	b	0x700a28fe <Sciclient_rmIaValidateMapping+0x12e> @ imm = #-0x2
700a28fe: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a2902: 9004         	str	r0, [sp, #0x10]
;             }
700a2904: e7ff         	b	0x700a2906 <Sciclient_rmIaValidateMapping+0x136> @ imm = #-0x2
700a2906: e7ff         	b	0x700a2908 <Sciclient_rmIaValidateMapping+0x138> @ imm = #-0x2
;     }
700a2908: e7ff         	b	0x700a290a <Sciclient_rmIaValidateMapping+0x13a> @ imm = #-0x2
;     return r;
700a290a: 9804         	ldr	r0, [sp, #0x10]
700a290c: b008         	add	sp, #0x20
700a290e: bd80         	pop	{r7, pc}

700a2910 <Udma_rmAllocMappedRing>:
; {
700a2910: b580         	push	{r7, lr}
700a2912: b090         	sub	sp, #0x40
700a2914: 900f         	str	r0, [sp, #0x3c]
700a2916: 910e         	str	r1, [sp, #0x38]
700a2918: 920d         	str	r2, [sp, #0x34]
700a291a: f64f 70ff    	movw	r0, #0xffff
;     uint32_t    ringNum = UDMA_RING_INVALID;
700a291e: 900c         	str	r0, [sp, #0x30]
700a2920: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a2922: 9005         	str	r0, [sp, #0x14]
;     Udma_RmInitPrms             *rmInitPrms = &drvHandle->rmInitPrms;
700a2924: 980f         	ldr	r0, [sp, #0x3c]
700a2926: f500 70ea    	add.w	r0, r0, #0x1d4
700a292a: 9004         	str	r0, [sp, #0x10]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a292c: 980f         	ldr	r0, [sp, #0x3c]
700a292e: 990e         	ldr	r1, [sp, #0x38]
700a2930: 9a0d         	ldr	r2, [sp, #0x34]
700a2932: ab01         	add	r3, sp, #0x4
700a2934: f005 fa54    	bl	0x700a7de0 <Udma_getMappedChRingAttributes> @ imm = #0x54a8
700a2938: 9005         	str	r0, [sp, #0x14]
;     if(UDMA_SOK == retVal)
700a293a: 9805         	ldr	r0, [sp, #0x14]
700a293c: 2800         	cmp	r0, #0x0
700a293e: f040 8084    	bne.w	0x700a2a4a <Udma_rmAllocMappedRing+0x13a> @ imm = #0x108
700a2942: e7ff         	b	0x700a2944 <Udma_rmAllocMappedRing+0x34> @ imm = #-0x2
700a2944: 2000         	movs	r0, #0x0
;         loopStart = 0;
700a2946: 9007         	str	r0, [sp, #0x1c]
;         loopMax   = rmInitPrms->numMappedRing[mappedRingGrp];
700a2948: 9804         	ldr	r0, [sp, #0x10]
700a294a: 990e         	ldr	r1, [sp, #0x38]
700a294c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a2950: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
700a2954: 9006         	str	r0, [sp, #0x18]
;         if(chAttr.startFreeRing > rmInitPrms->startMappedRing[mappedRingGrp])
700a2956: 9802         	ldr	r0, [sp, #0x8]
700a2958: 9904         	ldr	r1, [sp, #0x10]
700a295a: 9a0e         	ldr	r2, [sp, #0x38]
700a295c: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2960: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a2964: 4288         	cmp	r0, r1
700a2966: d90a         	bls	0x700a297e <Udma_rmAllocMappedRing+0x6e> @ imm = #0x14
700a2968: e7ff         	b	0x700a296a <Udma_rmAllocMappedRing+0x5a> @ imm = #-0x2
;             loopStart = chAttr.startFreeRing - rmInitPrms->startMappedRing[mappedRingGrp];
700a296a: 9802         	ldr	r0, [sp, #0x8]
700a296c: 9904         	ldr	r1, [sp, #0x10]
700a296e: 9a0e         	ldr	r2, [sp, #0x38]
700a2970: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2974: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a2978: 1a40         	subs	r0, r0, r1
700a297a: 9007         	str	r0, [sp, #0x1c]
;         }
700a297c: e7ff         	b	0x700a297e <Udma_rmAllocMappedRing+0x6e> @ imm = #-0x2
;         if((chAttr.startFreeRing + chAttr.numFreeRing) < (rmInitPrms->startMappedRing[mappedRingGrp] + rmInitPrms->numMappedRing[mappedRingGrp]))
700a297e: 9802         	ldr	r0, [sp, #0x8]
700a2980: 9903         	ldr	r1, [sp, #0xc]
700a2982: 4408         	add	r0, r1
700a2984: 9904         	ldr	r1, [sp, #0x10]
700a2986: 9a0e         	ldr	r2, [sp, #0x38]
700a2988: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a298c: f8d2 1088    	ldr.w	r1, [r2, #0x88]
700a2990: f8d2 20a8    	ldr.w	r2, [r2, #0xa8]
700a2994: 4411         	add	r1, r2
700a2996: 4288         	cmp	r0, r1
700a2998: d20c         	bhs	0x700a29b4 <Udma_rmAllocMappedRing+0xa4> @ imm = #0x18
700a299a: e7ff         	b	0x700a299c <Udma_rmAllocMappedRing+0x8c> @ imm = #-0x2
;             loopMax = (chAttr.startFreeRing + chAttr.numFreeRing) - rmInitPrms->startMappedRing[mappedRingGrp];
700a299c: 9802         	ldr	r0, [sp, #0x8]
700a299e: 9903         	ldr	r1, [sp, #0xc]
700a29a0: 4408         	add	r0, r1
700a29a2: 9904         	ldr	r1, [sp, #0x10]
700a29a4: 9a0e         	ldr	r2, [sp, #0x38]
700a29a6: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a29aa: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a29ae: 1a40         	subs	r0, r0, r1
700a29b0: 9006         	str	r0, [sp, #0x18]
;         }
700a29b2: e7ff         	b	0x700a29b4 <Udma_rmAllocMappedRing+0xa4> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a29b4: 980f         	ldr	r0, [sp, #0x3c]
700a29b6: f500 609f    	add.w	r0, r0, #0x4f8
700a29ba: f04f 31ff    	mov.w	r1, #0xffffffff
700a29be: f007 ff07    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x7e0e
;         for(i = loopStart; i < loopMax; i++)
700a29c2: 9807         	ldr	r0, [sp, #0x1c]
700a29c4: 900b         	str	r0, [sp, #0x2c]
700a29c6: e7ff         	b	0x700a29c8 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x2
700a29c8: 980b         	ldr	r0, [sp, #0x2c]
700a29ca: 9906         	ldr	r1, [sp, #0x18]
700a29cc: 4288         	cmp	r0, r1
700a29ce: d236         	bhs	0x700a2a3e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x6c
700a29d0: e7ff         	b	0x700a29d2 <Udma_rmAllocMappedRing+0xc2> @ imm = #-0x2
;             offset = i >> 5U;
700a29d2: 980b         	ldr	r0, [sp, #0x2c]
700a29d4: 0940         	lsrs	r0, r0, #0x5
700a29d6: 900a         	str	r0, [sp, #0x28]
;             bitPos = i - (offset << 5U);
700a29d8: 980b         	ldr	r0, [sp, #0x2c]
700a29da: 990a         	ldr	r1, [sp, #0x28]
700a29dc: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a29e0: 9009         	str	r0, [sp, #0x24]
;             bitMask = (uint32_t) 1U << bitPos;
700a29e2: 9909         	ldr	r1, [sp, #0x24]
700a29e4: 2001         	movs	r0, #0x1
700a29e6: 4088         	lsls	r0, r1
700a29e8: 9008         	str	r0, [sp, #0x20]
;             if((drvHandle->mappedRingFlag[mappedRingGrp][offset] & bitMask) == bitMask)
700a29ea: 980f         	ldr	r0, [sp, #0x3c]
700a29ec: 990e         	ldr	r1, [sp, #0x38]
700a29ee: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a29f2: 990a         	ldr	r1, [sp, #0x28]
700a29f4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a29f8: f8d0 0344    	ldr.w	r0, [r0, #0x344]
700a29fc: 9908         	ldr	r1, [sp, #0x20]
700a29fe: 4008         	ands	r0, r1
700a2a00: 4288         	cmp	r0, r1
700a2a02: d117         	bne	0x700a2a34 <Udma_rmAllocMappedRing+0x124> @ imm = #0x2e
700a2a04: e7ff         	b	0x700a2a06 <Udma_rmAllocMappedRing+0xf6> @ imm = #-0x2
;                 drvHandle->mappedRingFlag[mappedRingGrp][offset] &= ~bitMask;
700a2a06: 9a08         	ldr	r2, [sp, #0x20]
700a2a08: 980f         	ldr	r0, [sp, #0x3c]
700a2a0a: 990e         	ldr	r1, [sp, #0x38]
700a2a0c: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a2a10: 990a         	ldr	r1, [sp, #0x28]
700a2a12: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a2a16: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a2a1a: 4390         	bics	r0, r2
700a2a1c: f8c1 0344    	str.w	r0, [r1, #0x344]
;                 ringNum = i + rmInitPrms->startMappedRing[mappedRingGrp];  /* Add start offset */
700a2a20: 980b         	ldr	r0, [sp, #0x2c]
700a2a22: 9904         	ldr	r1, [sp, #0x10]
700a2a24: 9a0e         	ldr	r2, [sp, #0x38]
700a2a26: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a2a2a: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a2a2e: 4408         	add	r0, r1
700a2a30: 900c         	str	r0, [sp, #0x30]
;                 break;
700a2a32: e004         	b	0x700a2a3e <Udma_rmAllocMappedRing+0x12e> @ imm = #0x8
;         }
700a2a34: e7ff         	b	0x700a2a36 <Udma_rmAllocMappedRing+0x126> @ imm = #-0x2
;         for(i = loopStart; i < loopMax; i++)
700a2a36: 980b         	ldr	r0, [sp, #0x2c]
700a2a38: 3001         	adds	r0, #0x1
700a2a3a: 900b         	str	r0, [sp, #0x2c]
700a2a3c: e7c4         	b	0x700a29c8 <Udma_rmAllocMappedRing+0xb8> @ imm = #-0x78
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a2a3e: 980f         	ldr	r0, [sp, #0x3c]
700a2a40: f500 609f    	add.w	r0, r0, #0x4f8
700a2a44: f009 fa54    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x94a8
;     }
700a2a48: e7ff         	b	0x700a2a4a <Udma_rmAllocMappedRing+0x13a> @ imm = #-0x2
;     return (ringNum);
700a2a4a: 980c         	ldr	r0, [sp, #0x30]
700a2a4c: b010         	add	sp, #0x40
700a2a4e: bd80         	pop	{r7, pc}

700a2a50 <UART_procLineStatusErr>:
; {
700a2a50: b580         	push	{r7, lr}
700a2a52: b086         	sub	sp, #0x18
700a2a54: 9005         	str	r0, [sp, #0x14]
700a2a56: 2000         	movs	r0, #0x0
;     int32_t            status = UART_STATUS_SUCCESS;
700a2a58: 9004         	str	r0, [sp, #0x10]
;     uint32_t           lineStatus, iteration = 0U;
700a2a5a: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == hUart)
700a2a5c: 9805         	ldr	r0, [sp, #0x14]
700a2a5e: b920         	cbnz	r0, 0x700a2a6a <UART_procLineStatusErr+0x1a> @ imm = #0x8
700a2a60: e7ff         	b	0x700a2a62 <UART_procLineStatusErr+0x12> @ imm = #-0x2
700a2a62: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a2a66: 9004         	str	r0, [sp, #0x10]
;     }
700a2a68: e7ff         	b	0x700a2a6a <UART_procLineStatusErr+0x1a> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a2a6a: 9804         	ldr	r0, [sp, #0x10]
700a2a6c: 2800         	cmp	r0, #0x0
700a2a6e: f040 808b    	bne.w	0x700a2b88 <UART_procLineStatusErr+0x138> @ imm = #0x116
700a2a72: e7ff         	b	0x700a2a74 <UART_procLineStatusErr+0x24> @ imm = #-0x2
;         lineStatus = UART_readLineStatus(hUart->baseAddr);
700a2a74: 9805         	ldr	r0, [sp, #0x14]
700a2a76: 6800         	ldr	r0, [r0]
700a2a78: f00a ff12    	bl	0x700ad8a0 <UART_readLineStatus> @ imm = #0xae24
700a2a7c: 9003         	str	r0, [sp, #0xc]
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a2a7e: 9803         	ldr	r0, [sp, #0xc]
700a2a80: f000 0080    	and	r0, r0, #0x80
;                 || ((lineStatus & UART_OVERRUN_ERROR) == UART_OVERRUN_ERROR))
700a2a84: 2880         	cmp	r0, #0x80
700a2a86: d006         	beq	0x700a2a96 <UART_procLineStatusErr+0x46> @ imm = #0xc
700a2a88: e7ff         	b	0x700a2a8a <UART_procLineStatusErr+0x3a> @ imm = #-0x2
;         if(((lineStatus & UART_FIFO_PE_FE_BI_DETECTED) == UART_FIFO_PE_FE_BI_DETECTED)
700a2a8a: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a2a8e: 0780         	lsls	r0, r0, #0x1e
700a2a90: 2800         	cmp	r0, #0x0
700a2a92: d578         	bpl	0x700a2b86 <UART_procLineStatusErr+0x136> @ imm = #0xf0
700a2a94: e7ff         	b	0x700a2a96 <UART_procLineStatusErr+0x46> @ imm = #-0x2
;             if (hUart->readTrans.buf != NULL)
700a2a96: 9805         	ldr	r0, [sp, #0x14]
700a2a98: 6a80         	ldr	r0, [r0, #0x28]
700a2a9a: b120         	cbz	r0, 0x700a2aa6 <UART_procLineStatusErr+0x56> @ imm = #0x8
700a2a9c: e7ff         	b	0x700a2a9e <UART_procLineStatusErr+0x4e> @ imm = #-0x2
;                 hUart->readTrans.count = (uint32_t)(hUart->readCount);
700a2a9e: 9905         	ldr	r1, [sp, #0x14]
700a2aa0: 6988         	ldr	r0, [r1, #0x18]
700a2aa2: 62c8         	str	r0, [r1, #0x2c]
;             }
700a2aa4: e7ff         	b	0x700a2aa6 <UART_procLineStatusErr+0x56> @ imm = #-0x2
700a2aa6: 2040         	movs	r0, #0x40
;             iteration = UART_FIFO_SIZE;
700a2aa8: 9002         	str	r0, [sp, #0x8]
;             do
700a2aaa: e7ff         	b	0x700a2aac <UART_procLineStatusErr+0x5c> @ imm = #-0x2
;                 (void)UART_fifoCharGet(hUart->baseAddr);
700a2aac: 9805         	ldr	r0, [sp, #0x14]
700a2aae: 6800         	ldr	r0, [r0]
700a2ab0: f00c fdc6    	bl	0x700af640 <UART_fifoCharGet> @ imm = #0xcb8c
;                 iteration--;
700a2ab4: 9802         	ldr	r0, [sp, #0x8]
700a2ab6: 3801         	subs	r0, #0x1
700a2ab8: 9002         	str	r0, [sp, #0x8]
;                 lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a2aba: 9805         	ldr	r0, [sp, #0x14]
700a2abc: 6800         	ldr	r0, [r0]
700a2abe: f00a feef    	bl	0x700ad8a0 <UART_readLineStatus> @ imm = #0xadde
700a2ac2: 9003         	str	r0, [sp, #0xc]
;                 lineStatus &= (UART_LSR_RX_FIFO_STS_MASK |
700a2ac4: 9803         	ldr	r0, [sp, #0xc]
700a2ac6: f000 009f    	and	r0, r0, #0x9f
700a2aca: 9003         	str	r0, [sp, #0xc]
;             }
700a2acc: e7ff         	b	0x700a2ace <UART_procLineStatusErr+0x7e> @ imm = #-0x2
;             while ((lineStatus != 0U) && (iteration != 0U));
700a2ace: 9903         	ldr	r1, [sp, #0xc]
700a2ad0: 2000         	movs	r0, #0x0
700a2ad2: 9001         	str	r0, [sp, #0x4]
700a2ad4: b131         	cbz	r1, 0x700a2ae4 <UART_procLineStatusErr+0x94> @ imm = #0xc
700a2ad6: e7ff         	b	0x700a2ad8 <UART_procLineStatusErr+0x88> @ imm = #-0x2
700a2ad8: 9802         	ldr	r0, [sp, #0x8]
700a2ada: 2800         	cmp	r0, #0x0
700a2adc: bf18         	it	ne
700a2ade: 2001         	movne	r0, #0x1
700a2ae0: 9001         	str	r0, [sp, #0x4]
700a2ae2: e7ff         	b	0x700a2ae4 <UART_procLineStatusErr+0x94> @ imm = #-0x2
700a2ae4: 9801         	ldr	r0, [sp, #0x4]
;             }
700a2ae6: 07c0         	lsls	r0, r0, #0x1f
700a2ae8: 2800         	cmp	r0, #0x0
700a2aea: d1df         	bne	0x700a2aac <UART_procLineStatusErr+0x5c> @ imm = #-0x42
700a2aec: e7ff         	b	0x700a2aee <UART_procLineStatusErr+0x9e> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr, UART_INTR_RHR_CTI | UART_INTR_LINE_STAT);
700a2aee: 9805         	ldr	r0, [sp, #0x14]
700a2af0: 6800         	ldr	r0, [r0]
700a2af2: 2105         	movs	r1, #0x5
700a2af4: f003 fc2c    	bl	0x700a6350 <UART_intrDisable> @ imm = #0x3858
;             hUart->readBuf = (void *)((uint8_t *)hUart->readBuf - hUart->readCount);
700a2af8: 9905         	ldr	r1, [sp, #0x14]
700a2afa: 6948         	ldr	r0, [r1, #0x14]
700a2afc: 698a         	ldr	r2, [r1, #0x18]
700a2afe: 1a80         	subs	r0, r0, r2
700a2b00: 6148         	str	r0, [r1, #0x14]
;             if (hUart->readTrans.buf != NULL)
700a2b02: 9805         	ldr	r0, [sp, #0x14]
700a2b04: 6a80         	ldr	r0, [r0, #0x28]
700a2b06: b3a8         	cbz	r0, 0x700a2b74 <UART_procLineStatusErr+0x124> @ imm = #0x6a
700a2b08: e7ff         	b	0x700a2b0a <UART_procLineStatusErr+0xba> @ imm = #-0x2
;                 if ((lineStatus & UART_BREAK_DETECTED_ERROR) != 0U)
700a2b0a: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a2b0e: 06c0         	lsls	r0, r0, #0x1b
700a2b10: 2800         	cmp	r0, #0x0
700a2b12: d508         	bpl	0x700a2b26 <UART_procLineStatusErr+0xd6> @ imm = #0x10
700a2b14: e7ff         	b	0x700a2b16 <UART_procLineStatusErr+0xc6> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_BI;
700a2b16: 9905         	ldr	r1, [sp, #0x14]
700a2b18: 2002         	movs	r0, #0x2
700a2b1a: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2b1c: 9905         	ldr	r1, [sp, #0x14]
700a2b1e: 6a48         	ldr	r0, [r1, #0x24]
700a2b20: 3001         	adds	r0, #0x1
700a2b22: 6248         	str	r0, [r1, #0x24]
;                 }
700a2b24: e025         	b	0x700a2b72 <UART_procLineStatusErr+0x122> @ imm = #0x4a
;                 else if ((lineStatus & UART_FRAMING_ERROR) != 0U)
700a2b26: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a2b2a: 0700         	lsls	r0, r0, #0x1c
700a2b2c: 2800         	cmp	r0, #0x0
700a2b2e: d508         	bpl	0x700a2b42 <UART_procLineStatusErr+0xf2> @ imm = #0x10
700a2b30: e7ff         	b	0x700a2b32 <UART_procLineStatusErr+0xe2> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_FE;
700a2b32: 9905         	ldr	r1, [sp, #0x14]
700a2b34: 2003         	movs	r0, #0x3
700a2b36: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2b38: 9905         	ldr	r1, [sp, #0x14]
700a2b3a: 6a48         	ldr	r0, [r1, #0x24]
700a2b3c: 3001         	adds	r0, #0x1
700a2b3e: 6248         	str	r0, [r1, #0x24]
;                 }
700a2b40: e016         	b	0x700a2b70 <UART_procLineStatusErr+0x120> @ imm = #0x2c
;                 else if ((lineStatus & UART_PARITY_ERROR) != 0U)
700a2b42: f89d 000c    	ldrb.w	r0, [sp, #0xc]
700a2b46: 0740         	lsls	r0, r0, #0x1d
700a2b48: 2800         	cmp	r0, #0x0
700a2b4a: d508         	bpl	0x700a2b5e <UART_procLineStatusErr+0x10e> @ imm = #0x10
700a2b4c: e7ff         	b	0x700a2b4e <UART_procLineStatusErr+0xfe> @ imm = #-0x2
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_PE;
700a2b4e: 9905         	ldr	r1, [sp, #0x14]
700a2b50: 2004         	movs	r0, #0x4
700a2b52: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2b54: 9905         	ldr	r1, [sp, #0x14]
700a2b56: 6a48         	ldr	r0, [r1, #0x24]
700a2b58: 3001         	adds	r0, #0x1
700a2b5a: 6248         	str	r0, [r1, #0x24]
;                 }
700a2b5c: e007         	b	0x700a2b6e <UART_procLineStatusErr+0x11e> @ imm = #0xe
;                     hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OE;
700a2b5e: 9905         	ldr	r1, [sp, #0x14]
700a2b60: 2005         	movs	r0, #0x5
700a2b62: 6348         	str	r0, [r1, #0x34]
;                     hUart->readErrorCnt++;
700a2b64: 9905         	ldr	r1, [sp, #0x14]
700a2b66: 6a48         	ldr	r0, [r1, #0x24]
700a2b68: 3001         	adds	r0, #0x1
700a2b6a: 6248         	str	r0, [r1, #0x24]
700a2b6c: e7ff         	b	0x700a2b6e <UART_procLineStatusErr+0x11e> @ imm = #-0x2
700a2b6e: e7ff         	b	0x700a2b70 <UART_procLineStatusErr+0x120> @ imm = #-0x2
700a2b70: e7ff         	b	0x700a2b72 <UART_procLineStatusErr+0x122> @ imm = #-0x2
;             }
700a2b72: e7ff         	b	0x700a2b74 <UART_procLineStatusErr+0x124> @ imm = #-0x2
;             hUart->hUartInit->errorCallbackFxn(hUart);
700a2b74: 9805         	ldr	r0, [sp, #0x14]
700a2b76: 6841         	ldr	r1, [r0, #0x4]
700a2b78: 6e49         	ldr	r1, [r1, #0x64]
700a2b7a: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a2b7c: 9805         	ldr	r0, [sp, #0x14]
700a2b7e: 3028         	adds	r0, #0x28
700a2b80: f00c fc7e    	bl	0x700af480 <UART_lld_Transaction_deInit> @ imm = #0xc8fc
;         }
700a2b84: e7ff         	b	0x700a2b86 <UART_procLineStatusErr+0x136> @ imm = #-0x2
;     }
700a2b86: e7ff         	b	0x700a2b88 <UART_procLineStatusErr+0x138> @ imm = #-0x2
;     return status;
700a2b88: 9804         	ldr	r0, [sp, #0x10]
700a2b8a: b006         	add	sp, #0x18
700a2b8c: bd80         	pop	{r7, pc}
700a2b8e: 0000         	movs	r0, r0

700a2b90 <prvProcessReceivedCommands>:
;     {
700a2b90: b580         	push	{r7, lr}
700a2b92: b08c         	sub	sp, #0x30
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a2b94: e7ff         	b	0x700a2b96 <prvProcessReceivedCommands+0x6> @ imm = #-0x2
700a2b96: f642 2048    	movw	r0, #0x2a48
700a2b9a: f2c7 000b    	movt	r0, #0x700b
700a2b9e: 6800         	ldr	r0, [r0]
700a2ba0: a908         	add	r1, sp, #0x20
700a2ba2: 2200         	movs	r2, #0x0
700a2ba4: f000 fd6c    	bl	0x700a3680 <xQueueReceive> @ imm = #0xad8
700a2ba8: 2800         	cmp	r0, #0x0
700a2baa: f000 808c    	beq.w	0x700a2cc6 <prvProcessReceivedCommands+0x136> @ imm = #0x118
700a2bae: e7ff         	b	0x700a2bb0 <prvProcessReceivedCommands+0x20> @ imm = #-0x2
;                     if( xMessage.xMessageID < ( BaseType_t ) 0 )
700a2bb0: 9808         	ldr	r0, [sp, #0x20]
700a2bb2: f1b0 3fff    	cmp.w	r0, #0xffffffff
700a2bb6: dc09         	bgt	0x700a2bcc <prvProcessReceivedCommands+0x3c> @ imm = #0x12
700a2bb8: e7ff         	b	0x700a2bba <prvProcessReceivedCommands+0x2a> @ imm = #-0x2
700a2bba: a808         	add	r0, sp, #0x20
;                         const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
700a2bbc: 3004         	adds	r0, #0x4
700a2bbe: 9003         	str	r0, [sp, #0xc]
;                         pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
700a2bc0: 9903         	ldr	r1, [sp, #0xc]
700a2bc2: 680a         	ldr	r2, [r1]
700a2bc4: 6848         	ldr	r0, [r1, #0x4]
700a2bc6: 6889         	ldr	r1, [r1, #0x8]
700a2bc8: 4790         	blx	r2
;                     }
700a2bca: e000         	b	0x700a2bce <prvProcessReceivedCommands+0x3e> @ imm = #0x0
700a2bcc: e7ff         	b	0x700a2bce <prvProcessReceivedCommands+0x3e> @ imm = #-0x2
;             if( xMessage.xMessageID >= ( BaseType_t ) 0 )
700a2bce: 9808         	ldr	r0, [sp, #0x20]
700a2bd0: 2800         	cmp	r0, #0x0
700a2bd2: f100 8077    	bmi.w	0x700a2cc4 <prvProcessReceivedCommands+0x134> @ imm = #0xee
700a2bd6: e7ff         	b	0x700a2bd8 <prvProcessReceivedCommands+0x48> @ imm = #-0x2
;                 pxTimer = xMessage.u.xTimerParameters.pxTimer;
700a2bd8: 980a         	ldr	r0, [sp, #0x28]
700a2bda: 9007         	str	r0, [sp, #0x1c]
;                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
700a2bdc: 9807         	ldr	r0, [sp, #0x1c]
700a2bde: 6940         	ldr	r0, [r0, #0x14]
700a2be0: b128         	cbz	r0, 0x700a2bee <prvProcessReceivedCommands+0x5e> @ imm = #0xa
700a2be2: e7ff         	b	0x700a2be4 <prvProcessReceivedCommands+0x54> @ imm = #-0x2
;                     ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a2be4: 9807         	ldr	r0, [sp, #0x1c]
700a2be6: 3004         	adds	r0, #0x4
700a2be8: f00a fd92    	bl	0x700ad710 <uxListRemove> @ imm = #0xab24
;                 }
700a2bec: e000         	b	0x700a2bf0 <prvProcessReceivedCommands+0x60> @ imm = #0x0
700a2bee: e7ff         	b	0x700a2bf0 <prvProcessReceivedCommands+0x60> @ imm = #-0x2
700a2bf0: a806         	add	r0, sp, #0x18
;                 xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700a2bf2: f00a fef5    	bl	0x700ad9e0 <prvSampleTimeNow> @ imm = #0xadea
700a2bf6: 9004         	str	r0, [sp, #0x10]
;                 switch( xMessage.xMessageID )
700a2bf8: 9808         	ldr	r0, [sp, #0x20]
700a2bfa: 9002         	str	r0, [sp, #0x8]
700a2bfc: 2809         	cmp	r0, #0x9
700a2bfe: d85f         	bhi	0x700a2cc0 <prvProcessReceivedCommands+0x130> @ imm = #0xbe
700a2c00: 9902         	ldr	r1, [sp, #0x8]
700a2c02: e8df f001    	tbb	[pc, r1]
700a2c06: 05 05 05 2f  	.word	0x2f050505
700a2c0a: 37 49 05 05  	.word	0x05054937
700a2c0e: 2f 37        	.short	0x372f
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a2c10: 9907         	ldr	r1, [sp, #0x1c]
700a2c12: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2c16: f040 0001    	orr	r0, r0, #0x1
700a2c1a: f881 0028    	strb.w	r0, [r1, #0x28]
;                         if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
700a2c1e: 9807         	ldr	r0, [sp, #0x1c]
700a2c20: 9b09         	ldr	r3, [sp, #0x24]
700a2c22: 6981         	ldr	r1, [r0, #0x18]
700a2c24: 4419         	add	r1, r3
700a2c26: 9a04         	ldr	r2, [sp, #0x10]
700a2c28: f007 fcb2    	bl	0x700aa590 <prvInsertTimerInActiveList> @ imm = #0x7964
700a2c2c: b1c0         	cbz	r0, 0x700a2c60 <prvProcessReceivedCommands+0xd0> @ imm = #0x30
700a2c2e: e7ff         	b	0x700a2c30 <prvProcessReceivedCommands+0xa0> @ imm = #-0x2
;                             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a2c30: 9807         	ldr	r0, [sp, #0x1c]
700a2c32: 6a01         	ldr	r1, [r0, #0x20]
700a2c34: 4788         	blx	r1
;                             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a2c36: 9807         	ldr	r0, [sp, #0x1c]
700a2c38: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a2c3c: 0740         	lsls	r0, r0, #0x1d
700a2c3e: 2800         	cmp	r0, #0x0
700a2c40: d50c         	bpl	0x700a2c5c <prvProcessReceivedCommands+0xcc> @ imm = #0x18
700a2c42: e7ff         	b	0x700a2c44 <prvProcessReceivedCommands+0xb4> @ imm = #-0x2
;                                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
700a2c44: 9807         	ldr	r0, [sp, #0x1c]
700a2c46: 9909         	ldr	r1, [sp, #0x24]
700a2c48: 6982         	ldr	r2, [r0, #0x18]
700a2c4a: 440a         	add	r2, r1
700a2c4c: 4669         	mov	r1, sp
700a2c4e: 2300         	movs	r3, #0x0
700a2c50: 600b         	str	r3, [r1]
700a2c52: 4619         	mov	r1, r3
700a2c54: f006 ff6c    	bl	0x700a9b30 <xTimerGenericCommand> @ imm = #0x6ed8
700a2c58: 9005         	str	r0, [sp, #0x14]
;                             }
700a2c5a: e000         	b	0x700a2c5e <prvProcessReceivedCommands+0xce> @ imm = #0x0
700a2c5c: e7ff         	b	0x700a2c5e <prvProcessReceivedCommands+0xce> @ imm = #-0x2
;                         }
700a2c5e: e000         	b	0x700a2c62 <prvProcessReceivedCommands+0xd2> @ imm = #0x0
700a2c60: e7ff         	b	0x700a2c62 <prvProcessReceivedCommands+0xd2> @ imm = #-0x2
;                         break;
700a2c62: e02e         	b	0x700a2cc2 <prvProcessReceivedCommands+0x132> @ imm = #0x5c
;                         pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a2c64: 9907         	ldr	r1, [sp, #0x1c]
700a2c66: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2c6a: f000 00fe    	and	r0, r0, #0xfe
700a2c6e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         break;
700a2c72: e026         	b	0x700a2cc2 <prvProcessReceivedCommands+0x132> @ imm = #0x4c
;                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
700a2c74: 9907         	ldr	r1, [sp, #0x1c]
700a2c76: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2c7a: f040 0001    	orr	r0, r0, #0x1
700a2c7e: f881 0028    	strb.w	r0, [r1, #0x28]
;                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
700a2c82: 9809         	ldr	r0, [sp, #0x24]
700a2c84: 9907         	ldr	r1, [sp, #0x1c]
700a2c86: 6188         	str	r0, [r1, #0x18]
;                         ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
700a2c88: 9807         	ldr	r0, [sp, #0x1c]
700a2c8a: 9b04         	ldr	r3, [sp, #0x10]
700a2c8c: 6981         	ldr	r1, [r0, #0x18]
700a2c8e: 4419         	add	r1, r3
700a2c90: 461a         	mov	r2, r3
700a2c92: f007 fc7d    	bl	0x700aa590 <prvInsertTimerInActiveList> @ imm = #0x78fa
;                         break;
700a2c96: e014         	b	0x700a2cc2 <prvProcessReceivedCommands+0x132> @ imm = #0x28
;                                 if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
700a2c98: 9807         	ldr	r0, [sp, #0x1c]
700a2c9a: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a2c9e: 0780         	lsls	r0, r0, #0x1e
700a2ca0: 2800         	cmp	r0, #0x0
700a2ca2: d404         	bmi	0x700a2cae <prvProcessReceivedCommands+0x11e> @ imm = #0x8
700a2ca4: e7ff         	b	0x700a2ca6 <prvProcessReceivedCommands+0x116> @ imm = #-0x2
;                                     vPortFree( pxTimer );
700a2ca6: 9807         	ldr	r0, [sp, #0x1c]
700a2ca8: f00c fb7a    	bl	0x700af3a0 <vPortFree>  @ imm = #0xc6f4
;                                 }
700a2cac: e007         	b	0x700a2cbe <prvProcessReceivedCommands+0x12e> @ imm = #0xe
;                                     pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700a2cae: 9907         	ldr	r1, [sp, #0x1c]
700a2cb0: f891 0028    	ldrb.w	r0, [r1, #0x28]
700a2cb4: f000 00fe    	and	r0, r0, #0xfe
700a2cb8: f881 0028    	strb.w	r0, [r1, #0x28]
700a2cbc: e7ff         	b	0x700a2cbe <prvProcessReceivedCommands+0x12e> @ imm = #-0x2
;                         break;
700a2cbe: e000         	b	0x700a2cc2 <prvProcessReceivedCommands+0x132> @ imm = #0x0
;                         break;
700a2cc0: e7ff         	b	0x700a2cc2 <prvProcessReceivedCommands+0x132> @ imm = #-0x2
;             }
700a2cc2: e7ff         	b	0x700a2cc4 <prvProcessReceivedCommands+0x134> @ imm = #-0x2
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
700a2cc4: e767         	b	0x700a2b96 <prvProcessReceivedCommands+0x6> @ imm = #-0x132
;     }
700a2cc6: b00c         	add	sp, #0x30
700a2cc8: bd80         	pop	{r7, pc}
700a2cca: 0000         	movs	r0, r0
700a2ccc: 0000         	movs	r0, r0
700a2cce: 0000         	movs	r0, r0

700a2cd0 <_ntoa_long_long>:
; {
700a2cd0: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a2cd4: b09e         	sub	sp, #0x78
700a2cd6: 469e         	mov	lr, r3
700a2cd8: 4614         	mov	r4, r2
700a2cda: 460d         	mov	r5, r1
700a2cdc: 4606         	mov	r6, r0
700a2cde: 9929         	ldr	r1, [sp, #0xa4]
700a2ce0: 9828         	ldr	r0, [sp, #0xa0]
700a2ce2: f8dd c094    	ldr.w	r12, [sp, #0x94]
700a2ce6: 9b24         	ldr	r3, [sp, #0x90]
700a2ce8: 9a2c         	ldr	r2, [sp, #0xb0]
700a2cea: 9a2b         	ldr	r2, [sp, #0xac]
700a2cec: 9a2a         	ldr	r2, [sp, #0xa8]
700a2cee: 9a26         	ldr	r2, [sp, #0x98]
700a2cf0: 961d         	str	r6, [sp, #0x74]
700a2cf2: 951c         	str	r5, [sp, #0x70]
700a2cf4: 941b         	str	r4, [sp, #0x6c]
700a2cf6: f8cd e068    	str.w	lr, [sp, #0x68]
700a2cfa: f8cd c064    	str.w	r12, [sp, #0x64]
700a2cfe: 9318         	str	r3, [sp, #0x60]
700a2d00: f88d 205f    	strb.w	r2, [sp, #0x5f]
700a2d04: 9115         	str	r1, [sp, #0x54]
700a2d06: 9014         	str	r0, [sp, #0x50]
700a2d08: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a2d0a: 900b         	str	r0, [sp, #0x2c]
;   if (!value) {
700a2d0c: 9818         	ldr	r0, [sp, #0x60]
700a2d0e: 9919         	ldr	r1, [sp, #0x64]
700a2d10: 4308         	orrs	r0, r1
700a2d12: b928         	cbnz	r0, 0x700a2d20 <_ntoa_long_long+0x50> @ imm = #0xa
700a2d14: e7ff         	b	0x700a2d16 <_ntoa_long_long+0x46> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a2d16: 982c         	ldr	r0, [sp, #0xb0]
700a2d18: f020 0010    	bic	r0, r0, #0x10
700a2d1c: 902c         	str	r0, [sp, #0xb0]
;   }
700a2d1e: e7ff         	b	0x700a2d20 <_ntoa_long_long+0x50> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a2d20: f89d 00b1    	ldrb.w	r0, [sp, #0xb1]
700a2d24: 0740         	lsls	r0, r0, #0x1d
700a2d26: 2800         	cmp	r0, #0x0
700a2d28: d506         	bpl	0x700a2d38 <_ntoa_long_long+0x68> @ imm = #0xc
700a2d2a: e7ff         	b	0x700a2d2c <_ntoa_long_long+0x5c> @ imm = #-0x2
700a2d2c: 9818         	ldr	r0, [sp, #0x60]
700a2d2e: 9919         	ldr	r1, [sp, #0x64]
700a2d30: 4308         	orrs	r0, r1
700a2d32: 2800         	cmp	r0, #0x0
700a2d34: d043         	beq	0x700a2dbe <_ntoa_long_long+0xee> @ imm = #0x86
700a2d36: e7ff         	b	0x700a2d38 <_ntoa_long_long+0x68> @ imm = #-0x2
;     do {
700a2d38: e7ff         	b	0x700a2d3a <_ntoa_long_long+0x6a> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a2d3a: 9818         	ldr	r0, [sp, #0x60]
700a2d3c: 9919         	ldr	r1, [sp, #0x64]
700a2d3e: 9a14         	ldr	r2, [sp, #0x50]
700a2d40: 9b15         	ldr	r3, [sp, #0x54]
700a2d42: f00c ea48    	blx	0x700af1d4 <__aeabi_uldivmod> @ imm = #0xc490
700a2d46: f88d 202b    	strb.w	r2, [sp, #0x2b]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a2d4a: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a2d4e: 2809         	cmp	r0, #0x9
700a2d50: dc05         	bgt	0x700a2d5e <_ntoa_long_long+0x8e> @ imm = #0xa
700a2d52: e7ff         	b	0x700a2d54 <_ntoa_long_long+0x84> @ imm = #-0x2
700a2d54: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
700a2d58: 3030         	adds	r0, #0x30
700a2d5a: 9009         	str	r0, [sp, #0x24]
700a2d5c: e00c         	b	0x700a2d78 <_ntoa_long_long+0xa8> @ imm = #0x18
700a2d5e: f89d 00b0    	ldrb.w	r0, [sp, #0xb0]
700a2d62: 0681         	lsls	r1, r0, #0x1a
700a2d64: 2061         	movs	r0, #0x61
700a2d66: 2900         	cmp	r1, #0x0
700a2d68: bf48         	it	mi
700a2d6a: 2041         	movmi	r0, #0x41
700a2d6c: f89d 102b    	ldrb.w	r1, [sp, #0x2b]
700a2d70: 4408         	add	r0, r1
700a2d72: 380a         	subs	r0, #0xa
700a2d74: 9009         	str	r0, [sp, #0x24]
700a2d76: e7ff         	b	0x700a2d78 <_ntoa_long_long+0xa8> @ imm = #-0x2
700a2d78: 9809         	ldr	r0, [sp, #0x24]
700a2d7a: 9a0b         	ldr	r2, [sp, #0x2c]
700a2d7c: 1c51         	adds	r1, r2, #0x1
700a2d7e: 910b         	str	r1, [sp, #0x2c]
700a2d80: a90c         	add	r1, sp, #0x30
700a2d82: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a2d84: 9a14         	ldr	r2, [sp, #0x50]
700a2d86: 9b15         	ldr	r3, [sp, #0x54]
700a2d88: 9818         	ldr	r0, [sp, #0x60]
700a2d8a: 9919         	ldr	r1, [sp, #0x64]
700a2d8c: f00c ea22    	blx	0x700af1d4 <__aeabi_uldivmod> @ imm = #0xc444
700a2d90: 9119         	str	r1, [sp, #0x64]
700a2d92: 9018         	str	r0, [sp, #0x60]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a2d94: e7ff         	b	0x700a2d96 <_ntoa_long_long+0xc6> @ imm = #-0x2
700a2d96: 9818         	ldr	r0, [sp, #0x60]
700a2d98: 9919         	ldr	r1, [sp, #0x64]
700a2d9a: 4301         	orrs	r1, r0
700a2d9c: 2000         	movs	r0, #0x0
700a2d9e: 9008         	str	r0, [sp, #0x20]
700a2da0: b139         	cbz	r1, 0x700a2db2 <_ntoa_long_long+0xe2> @ imm = #0xe
700a2da2: e7ff         	b	0x700a2da4 <_ntoa_long_long+0xd4> @ imm = #-0x2
700a2da4: 990b         	ldr	r1, [sp, #0x2c]
700a2da6: 2000         	movs	r0, #0x0
700a2da8: 2920         	cmp	r1, #0x20
700a2daa: bf38         	it	lo
700a2dac: 2001         	movlo	r0, #0x1
700a2dae: 9008         	str	r0, [sp, #0x20]
700a2db0: e7ff         	b	0x700a2db2 <_ntoa_long_long+0xe2> @ imm = #-0x2
700a2db2: 9808         	ldr	r0, [sp, #0x20]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a2db4: 07c0         	lsls	r0, r0, #0x1f
700a2db6: 2800         	cmp	r0, #0x0
700a2db8: d1bf         	bne	0x700a2d3a <_ntoa_long_long+0x6a> @ imm = #-0x82
700a2dba: e7ff         	b	0x700a2dbc <_ntoa_long_long+0xec> @ imm = #-0x2
;   }
700a2dbc: e7ff         	b	0x700a2dbe <_ntoa_long_long+0xee> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a2dbe: 981d         	ldr	r0, [sp, #0x74]
700a2dc0: 991c         	ldr	r1, [sp, #0x70]
700a2dc2: 9a1b         	ldr	r2, [sp, #0x6c]
700a2dc4: 9b1a         	ldr	r3, [sp, #0x68]
700a2dc6: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a2dca: 9d14         	ldr	r5, [sp, #0x50]
700a2dcc: 9e2a         	ldr	r6, [sp, #0xa8]
700a2dce: 9f2b         	ldr	r7, [sp, #0xac]
700a2dd0: f8dd 80b0    	ldr.w	r8, [sp, #0xb0]
700a2dd4: f89d 405f    	ldrb.w	r4, [sp, #0x5f]
700a2dd8: 46ee         	mov	lr, sp
700a2dda: f8ce 8018    	str.w	r8, [lr, #0x18]
700a2dde: f8ce 7014    	str.w	r7, [lr, #0x14]
700a2de2: f8ce 6010    	str.w	r6, [lr, #0x10]
700a2de6: f8ce 500c    	str.w	r5, [lr, #0xc]
700a2dea: f004 0401    	and	r4, r4, #0x1
700a2dee: f8ce 4008    	str.w	r4, [lr, #0x8]
700a2df2: f8ce c004    	str.w	r12, [lr, #0x4]
700a2df6: f10d 0c30    	add.w	r12, sp, #0x30
700a2dfa: f8ce c000    	str.w	r12, [lr]
700a2dfe: f7fb fdff    	bl	0x7009ea00 <_ntoa_format> @ imm = #-0x4402
700a2e02: b01e         	add	sp, #0x78
700a2e04: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a2e10 <Sciclient_rmIrqVintDelete>:
; {
700a2e10: b580         	push	{r7, lr}
700a2e12: b08c         	sub	sp, #0x30
700a2e14: 900b         	str	r0, [sp, #0x2c]
700a2e16: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a2e18: 900a         	str	r0, [sp, #0x28]
;     bool del_mapping = false;
700a2e1a: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool del_whole_route = false;
700a2e1e: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a2e22: 9008         	str	r0, [sp, #0x20]
;     if (r == SystemP_SUCCESS) {
700a2e24: 980a         	ldr	r0, [sp, #0x28]
700a2e26: b948         	cbnz	r0, 0x700a2e3c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #0x12
700a2e28: e7ff         	b	0x700a2e2a <Sciclient_rmIrqVintDelete+0x1a> @ imm = #-0x2
;         r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700a2e2a: 990b         	ldr	r1, [sp, #0x2c]
700a2e2c: 8a08         	ldrh	r0, [r1, #0x10]
700a2e2e: 8a49         	ldrh	r1, [r1, #0x12]
700a2e30: f10d 0227    	add.w	r2, sp, #0x27
700a2e34: f008 fbc4    	bl	0x700ab5c0 <Sciclient_rmIaVintGetInfo> @ imm = #0x8788
700a2e38: 900a         	str	r0, [sp, #0x28]
;     }
700a2e3a: e7ff         	b	0x700a2e3c <Sciclient_rmIrqVintDelete+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a2e3c: 980a         	ldr	r0, [sp, #0x28]
700a2e3e: b9e8         	cbnz	r0, 0x700a2e7c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #0x3a
700a2e40: e7ff         	b	0x700a2e42 <Sciclient_rmIrqVintDelete+0x32> @ imm = #-0x2
;         if (num_evts == 0u) {
700a2e42: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a2e46: b920         	cbnz	r0, 0x700a2e52 <Sciclient_rmIrqVintDelete+0x42> @ imm = #0x8
700a2e48: e7ff         	b	0x700a2e4a <Sciclient_rmIrqVintDelete+0x3a> @ imm = #-0x2
700a2e4a: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a2e4e: 900a         	str	r0, [sp, #0x28]
;         } else if ((num_evts > 1u) ||
700a2e50: e013         	b	0x700a2e7a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #0x26
700a2e52: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a2e56: 2801         	cmp	r0, #0x1
700a2e58: d806         	bhi	0x700a2e68 <Sciclient_rmIrqVintDelete+0x58> @ imm = #0xc
700a2e5a: e7ff         	b	0x700a2e5c <Sciclient_rmIrqVintDelete+0x4c> @ imm = #-0x2
;                (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a2e5c: 980b         	ldr	r0, [sp, #0x2c]
700a2e5e: 6800         	ldr	r0, [r0]
700a2e60: f008 fd6e    	bl	0x700ab940 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x8adc
;         } else if ((num_evts > 1u) ||
700a2e64: b120         	cbz	r0, 0x700a2e70 <Sciclient_rmIrqVintDelete+0x60> @ imm = #0x8
700a2e66: e7ff         	b	0x700a2e68 <Sciclient_rmIrqVintDelete+0x58> @ imm = #-0x2
700a2e68: 2001         	movs	r0, #0x1
;             del_mapping = true;
700a2e6a: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a2e6e: e003         	b	0x700a2e78 <Sciclient_rmIrqVintDelete+0x68> @ imm = #0x6
700a2e70: 2001         	movs	r0, #0x1
;             del_whole_route = true;
700a2e72: f88d 0025    	strb.w	r0, [sp, #0x25]
700a2e76: e7ff         	b	0x700a2e78 <Sciclient_rmIrqVintDelete+0x68> @ imm = #-0x2
700a2e78: e7ff         	b	0x700a2e7a <Sciclient_rmIrqVintDelete+0x6a> @ imm = #-0x2
;     }
700a2e7a: e7ff         	b	0x700a2e7c <Sciclient_rmIrqVintDelete+0x6c> @ imm = #-0x2
;     if (del_mapping == true) {
700a2e7c: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a2e80: 07c0         	lsls	r0, r0, #0x1f
700a2e82: 2800         	cmp	r0, #0x0
700a2e84: d049         	beq	0x700a2f1a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #0x92
700a2e86: e7ff         	b	0x700a2e88 <Sciclient_rmIrqVintDelete+0x78> @ imm = #-0x2
700a2e88: 203c         	movs	r0, #0x3c
700a2e8a: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a2e8e: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a2e90: 980b         	ldr	r0, [sp, #0x2c]
700a2e92: 7900         	ldrb	r0, [r0, #0x4]
700a2e94: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a2e98: 980b         	ldr	r0, [sp, #0x2c]
700a2e9a: 88c0         	ldrh	r0, [r0, #0x6]
700a2e9c: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a2ea0: 980b         	ldr	r0, [sp, #0x2c]
700a2ea2: 8900         	ldrh	r0, [r0, #0x8]
700a2ea4: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a2ea8: 980b         	ldr	r0, [sp, #0x2c]
700a2eaa: 8a00         	ldrh	r0, [r0, #0x10]
700a2eac: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a2eb0: 980b         	ldr	r0, [sp, #0x2c]
700a2eb2: 8a40         	ldrh	r0, [r0, #0x12]
700a2eb4: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a2eb8: 980b         	ldr	r0, [sp, #0x2c]
700a2eba: 89c0         	ldrh	r0, [r0, #0xe]
700a2ebc: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a2ec0: 980b         	ldr	r0, [sp, #0x2c]
700a2ec2: 7d00         	ldrb	r0, [r0, #0x14]
700a2ec4: f88d 001e    	strb.w	r0, [sp, #0x1e]
700a2ec8: a801         	add	r0, sp, #0x4
700a2eca: f04f 31ff    	mov.w	r1, #0xffffffff
;         r = Sciclient_rmIrqReleaseRaw(&req,
700a2ece: f009 fe87    	bl	0x700acbe0 <Sciclient_rmIrqReleaseRaw> @ imm = #0x9d0e
700a2ed2: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2ed4: 980a         	ldr	r0, [sp, #0x28]
700a2ed6: b9f8         	cbnz	r0, 0x700a2f18 <Sciclient_rmIrqVintDelete+0x108> @ imm = #0x3e
700a2ed8: e7ff         	b	0x700a2eda <Sciclient_rmIrqVintDelete+0xca> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a2eda: 980b         	ldr	r0, [sp, #0x2c]
700a2edc: 8a00         	ldrh	r0, [r0, #0x10]
700a2ede: f009 fb2f    	bl	0x700ac540 <Sciclient_rmIaGetInst> @ imm = #0x965e
700a2ee2: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a2ee4: 9808         	ldr	r0, [sp, #0x20]
700a2ee6: b1b0         	cbz	r0, 0x700a2f16 <Sciclient_rmIrqVintDelete+0x106> @ imm = #0x2c
700a2ee8: e7ff         	b	0x700a2eea <Sciclient_rmIrqVintDelete+0xda> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]--;
700a2eea: 9808         	ldr	r0, [sp, #0x20]
700a2eec: 6901         	ldr	r1, [r0, #0x10]
700a2eee: 980b         	ldr	r0, [sp, #0x2c]
700a2ef0: 8a42         	ldrh	r2, [r0, #0x12]
700a2ef2: 5c88         	ldrb	r0, [r1, r2]
700a2ef4: 3801         	subs	r0, #0x1
700a2ef6: 5488         	strb	r0, [r1, r2]
;                 if (ia_inst->v0_b0_evt == cfg->global_evt - ia_inst->sevt_offset) {
700a2ef8: 9a08         	ldr	r2, [sp, #0x20]
700a2efa: 8a90         	ldrh	r0, [r2, #0x14]
700a2efc: 990b         	ldr	r1, [sp, #0x2c]
700a2efe: 89c9         	ldrh	r1, [r1, #0xe]
700a2f00: 8912         	ldrh	r2, [r2, #0x8]
700a2f02: 1a89         	subs	r1, r1, r2
700a2f04: 4288         	cmp	r0, r1
700a2f06: d105         	bne	0x700a2f14 <Sciclient_rmIrqVintDelete+0x104> @ imm = #0xa
700a2f08: e7ff         	b	0x700a2f0a <Sciclient_rmIrqVintDelete+0xfa> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = SCICLIENT_RM_IA_GENERIC_EVT_RESETVAL;
700a2f0a: 9908         	ldr	r1, [sp, #0x20]
700a2f0c: f64f 70ff    	movw	r0, #0xffff
700a2f10: 8288         	strh	r0, [r1, #0x14]
;                 }
700a2f12: e7ff         	b	0x700a2f14 <Sciclient_rmIrqVintDelete+0x104> @ imm = #-0x2
;             }
700a2f14: e7ff         	b	0x700a2f16 <Sciclient_rmIrqVintDelete+0x106> @ imm = #-0x2
;         }
700a2f16: e7ff         	b	0x700a2f18 <Sciclient_rmIrqVintDelete+0x108> @ imm = #-0x2
;     }
700a2f18: e7ff         	b	0x700a2f1a <Sciclient_rmIrqVintDelete+0x10a> @ imm = #-0x2
;     if (del_whole_route == true) {
700a2f1a: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a2f1e: 07c0         	lsls	r0, r0, #0x1f
700a2f20: b170         	cbz	r0, 0x700a2f40 <Sciclient_rmIrqVintDelete+0x130> @ imm = #0x1c
700a2f22: e7ff         	b	0x700a2f24 <Sciclient_rmIrqVintDelete+0x114> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700a2f24: 980b         	ldr	r0, [sp, #0x2c]
700a2f26: f7f9 fee3    	bl	0x7009ccf0 <Sciclient_rmIrqGetRoute> @ imm = #-0x623a
700a2f2a: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a2f2c: 980a         	ldr	r0, [sp, #0x28]
700a2f2e: b930         	cbnz	r0, 0x700a2f3e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #0xc
700a2f30: e7ff         	b	0x700a2f32 <Sciclient_rmIrqVintDelete+0x122> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, true);
700a2f32: 980b         	ldr	r0, [sp, #0x2c]
700a2f34: 2101         	movs	r1, #0x1
700a2f36: f7fd fdf3    	bl	0x700a0b20 <Sciclient_rmIrqDeleteRoute> @ imm = #-0x241a
700a2f3a: 900a         	str	r0, [sp, #0x28]
;         }
700a2f3c: e7ff         	b	0x700a2f3e <Sciclient_rmIrqVintDelete+0x12e> @ imm = #-0x2
;     }
700a2f3e: e7ff         	b	0x700a2f40 <Sciclient_rmIrqVintDelete+0x130> @ imm = #-0x2
;     return r;
700a2f40: 980a         	ldr	r0, [sp, #0x28]
700a2f42: b00c         	add	sp, #0x30
700a2f44: bd80         	pop	{r7, pc}
		...
700a2f4e: 0000         	movs	r0, r0

700a2f50 <UART_writePolling>:
; {
700a2f50: b580         	push	{r7, lr}
700a2f52: b08c         	sub	sp, #0x30
700a2f54: 900b         	str	r0, [sp, #0x2c]
700a2f56: 910a         	str	r1, [sp, #0x28]
700a2f58: 2000         	movs	r0, #0x0
;     int32_t             retVal          = UART_TRANSFER_STATUS_SUCCESS;
700a2f5a: 9007         	str	r0, [sp, #0x1c]
;     uint32_t            timeoutElapsed  = FALSE;
700a2f5c: 9006         	str	r0, [sp, #0x18]
;     uint32_t            baseAddr        = hUart->baseAddr;
700a2f5e: 990b         	ldr	r1, [sp, #0x2c]
700a2f60: 6809         	ldr	r1, [r1]
700a2f62: 9105         	str	r1, [sp, #0x14]
;     uint32_t            lineStatus      = 0U;
700a2f64: 9004         	str	r0, [sp, #0x10]
;     hUartInit = hUart->hUartInit;
700a2f66: 980b         	ldr	r0, [sp, #0x2c]
700a2f68: 6840         	ldr	r0, [r0, #0x4]
700a2f6a: 9003         	str	r0, [sp, #0xc]
;     hUart->writeSizeRemaining = trans->count;
700a2f6c: 980a         	ldr	r0, [sp, #0x28]
700a2f6e: 6840         	ldr	r0, [r0, #0x4]
700a2f70: 990b         	ldr	r1, [sp, #0x2c]
700a2f72: 6108         	str	r0, [r1, #0x10]
;     startTicks = hUartInit->clockP_get();
700a2f74: 9803         	ldr	r0, [sp, #0xc]
700a2f76: 6d40         	ldr	r0, [r0, #0x54]
700a2f78: 4780         	blx	r0
700a2f7a: 9009         	str	r0, [sp, #0x24]
;     while ((FALSE == timeoutElapsed)
700a2f7c: e7ff         	b	0x700a2f7e <UART_writePolling+0x2e> @ imm = #-0x2
700a2f7e: 9906         	ldr	r1, [sp, #0x18]
700a2f80: 2000         	movs	r0, #0x0
;            && (0U != hUart->writeSizeRemaining))
700a2f82: 9002         	str	r0, [sp, #0x8]
700a2f84: b939         	cbnz	r1, 0x700a2f96 <UART_writePolling+0x46> @ imm = #0xe
700a2f86: e7ff         	b	0x700a2f88 <UART_writePolling+0x38> @ imm = #-0x2
700a2f88: 980b         	ldr	r0, [sp, #0x2c]
700a2f8a: 6900         	ldr	r0, [r0, #0x10]
700a2f8c: 2800         	cmp	r0, #0x0
700a2f8e: bf18         	it	ne
700a2f90: 2001         	movne	r0, #0x1
700a2f92: 9002         	str	r0, [sp, #0x8]
700a2f94: e7ff         	b	0x700a2f96 <UART_writePolling+0x46> @ imm = #-0x2
700a2f96: 9802         	ldr	r0, [sp, #0x8]
;     while ((FALSE == timeoutElapsed)
700a2f98: 07c0         	lsls	r0, r0, #0x1f
700a2f9a: b198         	cbz	r0, 0x700a2fc4 <UART_writePolling+0x74> @ imm = #0x26
700a2f9c: e7ff         	b	0x700a2f9e <UART_writePolling+0x4e> @ imm = #-0x2
;         UART_writeDataPolling(hUart);
700a2f9e: 980b         	ldr	r0, [sp, #0x2c]
700a2fa0: f00b f9ee    	bl	0x700ae380 <UART_writeDataPolling> @ imm = #0xb3dc
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700a2fa4: 9803         	ldr	r0, [sp, #0xc]
700a2fa6: 6d40         	ldr	r0, [r0, #0x54]
700a2fa8: 4780         	blx	r0
700a2faa: 9909         	ldr	r1, [sp, #0x24]
700a2fac: 1a40         	subs	r0, r0, r1
700a2fae: 9008         	str	r0, [sp, #0x20]
;         if (elapsedTicks >= trans->timeout)
700a2fb0: 9808         	ldr	r0, [sp, #0x20]
700a2fb2: 990a         	ldr	r1, [sp, #0x28]
700a2fb4: 6889         	ldr	r1, [r1, #0x8]
700a2fb6: 4288         	cmp	r0, r1
700a2fb8: d303         	blo	0x700a2fc2 <UART_writePolling+0x72> @ imm = #0x6
700a2fba: e7ff         	b	0x700a2fbc <UART_writePolling+0x6c> @ imm = #-0x2
700a2fbc: 2001         	movs	r0, #0x1
;             timeoutElapsed = TRUE;
700a2fbe: 9006         	str	r0, [sp, #0x18]
;         }
700a2fc0: e7ff         	b	0x700a2fc2 <UART_writePolling+0x72> @ imm = #-0x2
;     while ((FALSE == timeoutElapsed)
700a2fc2: e7dc         	b	0x700a2f7e <UART_writePolling+0x2e> @ imm = #-0x48
;     if (0U == hUart->writeSizeRemaining)
700a2fc4: 980b         	ldr	r0, [sp, #0x2c]
700a2fc6: 6900         	ldr	r0, [r0, #0x10]
700a2fc8: 2800         	cmp	r0, #0x0
700a2fca: d149         	bne	0x700a3060 <UART_writePolling+0x110> @ imm = #0x92
700a2fcc: e7ff         	b	0x700a2fce <UART_writePolling+0x7e> @ imm = #-0x2
;         do
700a2fce: e7ff         	b	0x700a2fd0 <UART_writePolling+0x80> @ imm = #-0x2
;             lineStatus = UART_readLineStatus(baseAddr);
700a2fd0: 9805         	ldr	r0, [sp, #0x14]
700a2fd2: f00a fc65    	bl	0x700ad8a0 <UART_readLineStatus> @ imm = #0xa8ca
700a2fd6: 9004         	str	r0, [sp, #0x10]
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700a2fd8: 9803         	ldr	r0, [sp, #0xc]
700a2fda: 6d40         	ldr	r0, [r0, #0x54]
700a2fdc: 4780         	blx	r0
700a2fde: 9909         	ldr	r1, [sp, #0x24]
700a2fe0: 1a40         	subs	r0, r0, r1
700a2fe2: 9008         	str	r0, [sp, #0x20]
;         }
700a2fe4: e7ff         	b	0x700a2fe6 <UART_writePolling+0x96> @ imm = #-0x2
;                (lineStatus & (uint32_t) (UART_LSR_TX_FIFO_E_MASK |
700a2fe6: 9804         	ldr	r0, [sp, #0x10]
700a2fe8: f000 0160    	and	r1, r0, #0x60
700a2fec: 2000         	movs	r0, #0x0
;                 && (elapsedTicks < hUart->lineStatusTimeout));
700a2fee: 2960         	cmp	r1, #0x60
700a2ff0: 9001         	str	r0, [sp, #0x4]
700a2ff2: d00d         	beq	0x700a3010 <UART_writePolling+0xc0> @ imm = #0x1a
700a2ff4: e7ff         	b	0x700a2ff6 <UART_writePolling+0xa6> @ imm = #-0x2
700a2ff6: 9808         	ldr	r0, [sp, #0x20]
700a2ff8: 990b         	ldr	r1, [sp, #0x2c]
700a2ffa: 6e8a         	ldr	r2, [r1, #0x68]
700a2ffc: 6ec9         	ldr	r1, [r1, #0x6c]
700a2ffe: 1a80         	subs	r0, r0, r2
700a3000: f04f 0000    	mov.w	r0, #0x0
700a3004: eb70 0101    	sbcs.w	r1, r0, r1
700a3008: bf38         	it	lo
700a300a: 2001         	movlo	r0, #0x1
700a300c: 9001         	str	r0, [sp, #0x4]
700a300e: e7ff         	b	0x700a3010 <UART_writePolling+0xc0> @ imm = #-0x2
700a3010: 9801         	ldr	r0, [sp, #0x4]
;         }
700a3012: 07c0         	lsls	r0, r0, #0x1f
700a3014: 2800         	cmp	r0, #0x0
700a3016: d1db         	bne	0x700a2fd0 <UART_writePolling+0x80> @ imm = #-0x4a
700a3018: e7ff         	b	0x700a301a <UART_writePolling+0xca> @ imm = #-0x2
;         if(elapsedTicks >= hUart->lineStatusTimeout)
700a301a: 9808         	ldr	r0, [sp, #0x20]
700a301c: 990b         	ldr	r1, [sp, #0x2c]
700a301e: 6e8a         	ldr	r2, [r1, #0x68]
700a3020: 6ec9         	ldr	r1, [r1, #0x6c]
700a3022: 1a80         	subs	r0, r0, r2
700a3024: f04f 0000    	mov.w	r0, #0x0
700a3028: 4188         	sbcs	r0, r1
700a302a: d30f         	blo	0x700a304c <UART_writePolling+0xfc> @ imm = #0x1e
700a302c: e7ff         	b	0x700a302e <UART_writePolling+0xde> @ imm = #-0x2
700a302e: f06f 0001    	mvn	r0, #0x1
;             retVal             = UART_TRANSFER_TIMEOUT;
700a3032: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a3034: 990a         	ldr	r1, [sp, #0x28]
700a3036: 2001         	movs	r0, #0x1
700a3038: 60c8         	str	r0, [r1, #0xc]
;             trans->count       = hUart->writeCount;
700a303a: 980b         	ldr	r0, [sp, #0x2c]
700a303c: 68c0         	ldr	r0, [r0, #0xc]
700a303e: 990a         	ldr	r1, [sp, #0x28]
700a3040: 6048         	str	r0, [r1, #0x4]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a3042: 980b         	ldr	r0, [sp, #0x2c]
700a3044: 303c         	adds	r0, #0x3c
700a3046: f00c fa1b    	bl	0x700af480 <UART_lld_Transaction_deInit> @ imm = #0xc436
;         }
700a304a: e008         	b	0x700a305e <UART_writePolling+0x10e> @ imm = #0x10
700a304c: 2000         	movs	r0, #0x0
;             retVal             = UART_TRANSFER_STATUS_SUCCESS;
700a304e: 9007         	str	r0, [sp, #0x1c]
;             trans->status      = UART_TRANSFER_STATUS_SUCCESS;
700a3050: 990a         	ldr	r1, [sp, #0x28]
700a3052: 60c8         	str	r0, [r1, #0xc]
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a3054: 980b         	ldr	r0, [sp, #0x2c]
700a3056: 303c         	adds	r0, #0x3c
700a3058: f00c fa12    	bl	0x700af480 <UART_lld_Transaction_deInit> @ imm = #0xc424
700a305c: e7ff         	b	0x700a305e <UART_writePolling+0x10e> @ imm = #-0x2
;     }
700a305e: e00e         	b	0x700a307e <UART_writePolling+0x12e> @ imm = #0x1c
700a3060: f06f 0001    	mvn	r0, #0x1
;         retVal             = UART_TRANSFER_TIMEOUT;
700a3064: 9007         	str	r0, [sp, #0x1c]
;         trans->status      = UART_TRANSFER_STATUS_TIMEOUT;
700a3066: 990a         	ldr	r1, [sp, #0x28]
700a3068: 2001         	movs	r0, #0x1
700a306a: 60c8         	str	r0, [r1, #0xc]
;         trans->count       = hUart->writeCount;
700a306c: 980b         	ldr	r0, [sp, #0x2c]
700a306e: 68c0         	ldr	r0, [r0, #0xc]
700a3070: 990a         	ldr	r1, [sp, #0x28]
700a3072: 6048         	str	r0, [r1, #0x4]
;         UART_lld_Transaction_deInit(&hUart->writeTrans);
700a3074: 980b         	ldr	r0, [sp, #0x2c]
700a3076: 303c         	adds	r0, #0x3c
700a3078: f00c fa02    	bl	0x700af480 <UART_lld_Transaction_deInit> @ imm = #0xc404
700a307c: e7ff         	b	0x700a307e <UART_writePolling+0x12e> @ imm = #-0x2
;     return (retVal);
700a307e: 9807         	ldr	r0, [sp, #0x1c]
700a3080: b00c         	add	sp, #0x30
700a3082: bd80         	pop	{r7, pc}
		...

700a3090 <Sciclient_recvMessage>:
; {
700a3090: b580         	push	{r7, lr}
700a3092: b08e         	sub	sp, #0x38
700a3094: 900d         	str	r0, [sp, #0x34]
700a3096: 910c         	str	r1, [sp, #0x30]
700a3098: 920b         	str	r2, [sp, #0x2c]
700a309a: 2000         	movs	r0, #0x0
;     uint8_t  trailBytes = 0U;
700a309c: f88d 0023    	strb.w	r0, [sp, #0x23]
;     numWords   = (uint32_t) (rxPayloadSize / 4U);
700a30a0: 990b         	ldr	r1, [sp, #0x2c]
700a30a2: ea4f 0191    	lsr.w	r1, r1, #0x2
700a30a6: 910a         	str	r1, [sp, #0x28]
;     trailBytes = (uint8_t) (rxPayloadSize - (numWords * 4U));
700a30a8: 990b         	ldr	r1, [sp, #0x2c]
700a30aa: 9a0a         	ldr	r2, [sp, #0x28]
700a30ac: eba1 0182    	sub.w	r1, r1, r2, lsl #2
700a30b0: f88d 1023    	strb.w	r1, [sp, #0x23]
;     for (i = 0; i < numWords; i++)
700a30b4: 9009         	str	r0, [sp, #0x24]
700a30b6: e7ff         	b	0x700a30b8 <Sciclient_recvMessage+0x28> @ imm = #-0x2
700a30b8: 9809         	ldr	r0, [sp, #0x24]
700a30ba: 990a         	ldr	r1, [sp, #0x28]
700a30bc: 4288         	cmp	r0, r1
700a30be: d22c         	bhs	0x700a311a <Sciclient_recvMessage+0x8a> @ imm = #0x58
700a30c0: e7ff         	b	0x700a30c2 <Sciclient_recvMessage+0x32> @ imm = #-0x2
;             rxThread,
700a30c2: 980d         	ldr	r0, [sp, #0x34]
;             ((uint8_t) i +
700a30c4: 9909         	ldr	r1, [sp, #0x24]
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a30c6: f642 2254    	movw	r2, #0x2a54
700a30ca: f2c7 020b    	movt	r2, #0x700b
700a30ce: 7812         	ldrb	r2, [r2]
;             ((uint8_t) i +
700a30d0: 4411         	add	r1, r2
;                 SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a30d2: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a30d4: b2c9         	uxtb	r1, r1
700a30d6: f00b fc4b    	bl	0x700ae970 <Sciclient_secProxyReadThread32> @ imm = #0xb896
700a30da: 9007         	str	r0, [sp, #0x1c]
700a30dc: a807         	add	r0, sp, #0x1c
;         uint8_t * tempWordPtr = (uint8_t*) & tempWord;
700a30de: 9006         	str	r0, [sp, #0x18]
700a30e0: 2000         	movs	r0, #0x0
;         uint32_t j = 0U;
700a30e2: 9005         	str	r0, [sp, #0x14]
;         for (j = 0U; j < 4U; j++)
700a30e4: 9005         	str	r0, [sp, #0x14]
700a30e6: e7ff         	b	0x700a30e8 <Sciclient_recvMessage+0x58> @ imm = #-0x2
700a30e8: 9805         	ldr	r0, [sp, #0x14]
700a30ea: 2803         	cmp	r0, #0x3
700a30ec: d810         	bhi	0x700a3110 <Sciclient_recvMessage+0x80> @ imm = #0x20
700a30ee: e7ff         	b	0x700a30f0 <Sciclient_recvMessage+0x60> @ imm = #-0x2
;             *(pLocalRespPayload + i * 4 + j) = *tempWordPtr;
700a30f0: 9806         	ldr	r0, [sp, #0x18]
700a30f2: 7800         	ldrb	r0, [r0]
700a30f4: 990c         	ldr	r1, [sp, #0x30]
700a30f6: 9a09         	ldr	r2, [sp, #0x24]
700a30f8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a30fc: 9a05         	ldr	r2, [sp, #0x14]
700a30fe: 5488         	strb	r0, [r1, r2]
;             tempWordPtr++;
700a3100: 9806         	ldr	r0, [sp, #0x18]
700a3102: 3001         	adds	r0, #0x1
700a3104: 9006         	str	r0, [sp, #0x18]
;         }
700a3106: e7ff         	b	0x700a3108 <Sciclient_recvMessage+0x78> @ imm = #-0x2
;         for (j = 0U; j < 4U; j++)
700a3108: 9805         	ldr	r0, [sp, #0x14]
700a310a: 3001         	adds	r0, #0x1
700a310c: 9005         	str	r0, [sp, #0x14]
700a310e: e7eb         	b	0x700a30e8 <Sciclient_recvMessage+0x58> @ imm = #-0x2a
;     }
700a3110: e7ff         	b	0x700a3112 <Sciclient_recvMessage+0x82> @ imm = #-0x2
;     for (i = 0; i < numWords; i++)
700a3112: 9809         	ldr	r0, [sp, #0x24]
700a3114: 3001         	adds	r0, #0x1
700a3116: 9009         	str	r0, [sp, #0x24]
700a3118: e7ce         	b	0x700a30b8 <Sciclient_recvMessage+0x28> @ imm = #-0x64
;     if (trailBytes > 0U)
700a311a: f89d 0023    	ldrb.w	r0, [sp, #0x23]
700a311e: b368         	cbz	r0, 0x700a317c <Sciclient_recvMessage+0xec> @ imm = #0x5a
700a3120: e7ff         	b	0x700a3122 <Sciclient_recvMessage+0x92> @ imm = #-0x2
;                 rxThread,
700a3122: 980d         	ldr	r0, [sp, #0x34]
;                 ((uint8_t)i +
700a3124: 9909         	ldr	r1, [sp, #0x24]
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a3126: f642 2254    	movw	r2, #0x2a54
700a312a: f2c7 020b    	movt	r2, #0x700b
700a312e: 7812         	ldrb	r2, [r2]
;                 ((uint8_t)i +
700a3130: 4411         	add	r1, r2
;                     SCICLIENT_HEADER_SIZE_IN_WORDS+gSecHeaderSizeWords));
700a3132: 3102         	adds	r1, #0x2
;         uint32_t tempWord = Sciclient_secProxyReadThread32(
700a3134: b2c9         	uxtb	r1, r1
700a3136: f00b fc1b    	bl	0x700ae970 <Sciclient_secProxyReadThread32> @ imm = #0xb836
700a313a: 9004         	str	r0, [sp, #0x10]
700a313c: a804         	add	r0, sp, #0x10
;         uint8_t * pTempWord = (uint8_t*) &tempWord;
700a313e: 9003         	str	r0, [sp, #0xc]
700a3140: 2000         	movs	r0, #0x0
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a3142: 9002         	str	r0, [sp, #0x8]
700a3144: e7ff         	b	0x700a3146 <Sciclient_recvMessage+0xb6> @ imm = #-0x2
700a3146: 9802         	ldr	r0, [sp, #0x8]
700a3148: f89d 1023    	ldrb.w	r1, [sp, #0x23]
700a314c: 4288         	cmp	r0, r1
700a314e: d214         	bhs	0x700a317a <Sciclient_recvMessage+0xea> @ imm = #0x28
700a3150: e7ff         	b	0x700a3152 <Sciclient_recvMessage+0xc2> @ imm = #-0x2
;             uint8_t * address = (uint8_t*)pLocalRespPayload;
700a3152: 980c         	ldr	r0, [sp, #0x30]
700a3154: 9001         	str	r0, [sp, #0x4]
;             uint8_t value = *(uint8_t*)(pTempWord + bytes);
700a3156: 9803         	ldr	r0, [sp, #0xc]
700a3158: 9902         	ldr	r1, [sp, #0x8]
700a315a: 5c40         	ldrb	r0, [r0, r1]
700a315c: f88d 0003    	strb.w	r0, [sp, #0x3]
;             *(uint8_t*)(address + i*4 + bytes) = value;
700a3160: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a3164: 9901         	ldr	r1, [sp, #0x4]
700a3166: 9a09         	ldr	r2, [sp, #0x24]
700a3168: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a316c: 9a02         	ldr	r2, [sp, #0x8]
700a316e: 5488         	strb	r0, [r1, r2]
;         }
700a3170: e7ff         	b	0x700a3172 <Sciclient_recvMessage+0xe2> @ imm = #-0x2
;         for (bytes = 0U; bytes < trailBytes; bytes++)
700a3172: 9802         	ldr	r0, [sp, #0x8]
700a3174: 3001         	adds	r0, #0x1
700a3176: 9002         	str	r0, [sp, #0x8]
700a3178: e7e5         	b	0x700a3146 <Sciclient_recvMessage+0xb6> @ imm = #-0x36
;     }
700a317a: e7ff         	b	0x700a317c <Sciclient_recvMessage+0xec> @ imm = #-0x2
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a317c: f642 2054    	movw	r0, #0x2a54
700a3180: f2c7 000b    	movt	r0, #0x700b
700a3184: 7801         	ldrb	r1, [r0]
;         rxPayloadSize) <=
700a3186: 980b         	ldr	r0, [sp, #0x2c]
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a3188: eb00 0081    	add.w	r0, r0, r1, lsl #2
;         (SCICLIENT_HEADER_SIZE_IN_WORDS*4U) +
700a318c: 3008         	adds	r0, #0x8
;         (gSciclientHandle.maxMsgSizeBytes - 4U))
700a318e: f642 1148    	movw	r1, #0x2948
700a3192: f2c7 010b    	movt	r1, #0x700b
700a3196: 6949         	ldr	r1, [r1, #0x14]
700a3198: 3904         	subs	r1, #0x4
;     if ((((uint32_t) gSecHeaderSizeWords*4U) +
700a319a: 4288         	cmp	r0, r1
700a319c: d80e         	bhi	0x700a31bc <Sciclient_recvMessage+0x12c> @ imm = #0x1c
700a319e: e7ff         	b	0x700a31a0 <Sciclient_recvMessage+0x110> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a31a0: 980d         	ldr	r0, [sp, #0x34]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a31a2: f642 1148    	movw	r1, #0x2948
700a31a6: f2c7 010b    	movt	r1, #0x700b
700a31aa: 694a         	ldr	r2, [r1, #0x14]
700a31ac: f04f 31ff    	mov.w	r1, #0xffffffff
700a31b0: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(rxThread,
700a31b4: b2c9         	uxtb	r1, r1
700a31b6: f00b fbdb    	bl	0x700ae970 <Sciclient_secProxyReadThread32> @ imm = #0xb7b6
;     }
700a31ba: e7ff         	b	0x700a31bc <Sciclient_recvMessage+0x12c> @ imm = #-0x2
; }
700a31bc: b00e         	add	sp, #0x38
700a31be: bd80         	pop	{r7, pc}

700a31c0 <Udma_rmAllocIrIntr>:
; {
700a31c0: b580         	push	{r7, lr}
700a31c2: b088         	sub	sp, #0x20
700a31c4: 9007         	str	r0, [sp, #0x1c]
700a31c6: 9106         	str	r1, [sp, #0x18]
700a31c8: 2000         	movs	r0, #0x0
700a31ca: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            irIntrNum = UDMA_INTR_INVALID;
700a31ce: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a31d0: 9806         	ldr	r0, [sp, #0x18]
700a31d2: f500 70ea    	add.w	r0, r0, #0x1d4
700a31d6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a31d8: 9806         	ldr	r0, [sp, #0x18]
700a31da: f500 609f    	add.w	r0, r0, #0x4f8
700a31de: f04f 31ff    	mov.w	r1, #0xffffffff
700a31e2: f007 faf5    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x75ea
;     if(UDMA_CORE_INTR_ANY == preferredIrIntrNum)
700a31e6: 9807         	ldr	r0, [sp, #0x1c]
700a31e8: 2101         	movs	r1, #0x1
700a31ea: f6cf 71ff    	movt	r1, #0xffff
700a31ee: 4288         	cmp	r0, r1
700a31f0: d138         	bne	0x700a3264 <Udma_rmAllocIrIntr+0xa4> @ imm = #0x70
700a31f2: e7ff         	b	0x700a31f4 <Udma_rmAllocIrIntr+0x34> @ imm = #-0x2
700a31f4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a31f6: 9005         	str	r0, [sp, #0x14]
700a31f8: e7ff         	b	0x700a31fa <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x2
700a31fa: 9805         	ldr	r0, [sp, #0x14]
700a31fc: 9900         	ldr	r1, [sp]
700a31fe: f8d1 10ec    	ldr.w	r1, [r1, #0xec]
700a3202: 4288         	cmp	r0, r1
700a3204: d22d         	bhs	0x700a3262 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x5a
700a3206: e7ff         	b	0x700a3208 <Udma_rmAllocIrIntr+0x48> @ imm = #-0x2
;             offset = i >> 5U;
700a3208: 9805         	ldr	r0, [sp, #0x14]
700a320a: 0940         	lsrs	r0, r0, #0x5
700a320c: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a320e: 9805         	ldr	r0, [sp, #0x14]
700a3210: 9904         	ldr	r1, [sp, #0x10]
700a3212: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3216: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3218: 9903         	ldr	r1, [sp, #0xc]
700a321a: 2001         	movs	r0, #0x1
700a321c: 4088         	lsls	r0, r1
700a321e: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a3220: 9806         	ldr	r0, [sp, #0x18]
700a3222: 9904         	ldr	r1, [sp, #0x10]
700a3224: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3228: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a322c: 9902         	ldr	r1, [sp, #0x8]
700a322e: 4008         	ands	r0, r1
700a3230: 4288         	cmp	r0, r1
700a3232: d111         	bne	0x700a3258 <Udma_rmAllocIrIntr+0x98> @ imm = #0x22
700a3234: e7ff         	b	0x700a3236 <Udma_rmAllocIrIntr+0x76> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a3236: 9a02         	ldr	r2, [sp, #0x8]
700a3238: 9806         	ldr	r0, [sp, #0x18]
700a323a: 9904         	ldr	r1, [sp, #0x10]
700a323c: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3240: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a3244: 4390         	bics	r0, r2
700a3246: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = i + rmInitPrms->startIrIntr;    /* Add start offset */
700a324a: 9805         	ldr	r0, [sp, #0x14]
700a324c: 9900         	ldr	r1, [sp]
700a324e: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a3252: 4408         	add	r0, r1
700a3254: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3256: e004         	b	0x700a3262 <Udma_rmAllocIrIntr+0xa2> @ imm = #0x8
;         }
700a3258: e7ff         	b	0x700a325a <Udma_rmAllocIrIntr+0x9a> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numIrIntr; i++)
700a325a: 9805         	ldr	r0, [sp, #0x14]
700a325c: 3001         	adds	r0, #0x1
700a325e: 9005         	str	r0, [sp, #0x14]
700a3260: e7cb         	b	0x700a31fa <Udma_rmAllocIrIntr+0x3a> @ imm = #-0x6a
;     }
700a3262: e03c         	b	0x700a32de <Udma_rmAllocIrIntr+0x11e> @ imm = #0x78
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a3264: 9807         	ldr	r0, [sp, #0x1c]
700a3266: 9900         	ldr	r1, [sp]
700a3268: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a326c: 4288         	cmp	r0, r1
700a326e: d335         	blo	0x700a32dc <Udma_rmAllocIrIntr+0x11c> @ imm = #0x6a
700a3270: e7ff         	b	0x700a3272 <Udma_rmAllocIrIntr+0xb2> @ imm = #-0x2
;            (preferredIrIntrNum < (rmInitPrms->startIrIntr + rmInitPrms->numIrIntr)))
700a3272: 9807         	ldr	r0, [sp, #0x1c]
700a3274: 9a00         	ldr	r2, [sp]
700a3276: f8d2 10e8    	ldr.w	r1, [r2, #0xe8]
700a327a: f8d2 20ec    	ldr.w	r2, [r2, #0xec]
700a327e: 4411         	add	r1, r2
;         if((preferredIrIntrNum >= rmInitPrms->startIrIntr) &&
700a3280: 4288         	cmp	r0, r1
700a3282: d22b         	bhs	0x700a32dc <Udma_rmAllocIrIntr+0x11c> @ imm = #0x56
700a3284: e7ff         	b	0x700a3286 <Udma_rmAllocIrIntr+0xc6> @ imm = #-0x2
;             i = preferredIrIntrNum - rmInitPrms->startIrIntr;
700a3286: 9807         	ldr	r0, [sp, #0x1c]
700a3288: 9900         	ldr	r1, [sp]
700a328a: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700a328e: 1a40         	subs	r0, r0, r1
700a3290: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3292: 9805         	ldr	r0, [sp, #0x14]
700a3294: 0940         	lsrs	r0, r0, #0x5
700a3296: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3298: 9805         	ldr	r0, [sp, #0x14]
700a329a: 9904         	ldr	r1, [sp, #0x10]
700a329c: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a32a0: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a32a2: 9903         	ldr	r1, [sp, #0xc]
700a32a4: 2001         	movs	r0, #0x1
700a32a6: 4088         	lsls	r0, r1
700a32a8: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->irIntrFlag[offset] & bitMask) == bitMask)
700a32aa: 9806         	ldr	r0, [sp, #0x18]
700a32ac: 9904         	ldr	r1, [sp, #0x10]
700a32ae: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a32b2: f8d0 04e4    	ldr.w	r0, [r0, #0x4e4]
700a32b6: 9902         	ldr	r1, [sp, #0x8]
700a32b8: 4008         	ands	r0, r1
700a32ba: 4288         	cmp	r0, r1
700a32bc: d10d         	bne	0x700a32da <Udma_rmAllocIrIntr+0x11a> @ imm = #0x1a
700a32be: e7ff         	b	0x700a32c0 <Udma_rmAllocIrIntr+0x100> @ imm = #-0x2
;                 drvHandle->irIntrFlag[offset] &= ~bitMask;
700a32c0: 9a02         	ldr	r2, [sp, #0x8]
700a32c2: 9806         	ldr	r0, [sp, #0x18]
700a32c4: 9904         	ldr	r1, [sp, #0x10]
700a32c6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a32ca: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700a32ce: 4390         	bics	r0, r2
700a32d0: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;                 irIntrNum = preferredIrIntrNum;
700a32d4: 9807         	ldr	r0, [sp, #0x1c]
700a32d6: 9001         	str	r0, [sp, #0x4]
;             }
700a32d8: e7ff         	b	0x700a32da <Udma_rmAllocIrIntr+0x11a> @ imm = #-0x2
;         }
700a32da: e7ff         	b	0x700a32dc <Udma_rmAllocIrIntr+0x11c> @ imm = #-0x2
700a32dc: e7ff         	b	0x700a32de <Udma_rmAllocIrIntr+0x11e> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a32de: 9806         	ldr	r0, [sp, #0x18]
700a32e0: f500 609f    	add.w	r0, r0, #0x4f8
700a32e4: f008 fe04    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x8c08
;     return (irIntrNum);
700a32e8: 9801         	ldr	r0, [sp, #0x4]
700a32ea: b008         	add	sp, #0x20
700a32ec: bd80         	pop	{r7, pc}
700a32ee: 0000         	movs	r0, r0

700a32f0 <xQueueGenericSend>:
; {
700a32f0: b580         	push	{r7, lr}
700a32f2: b08a         	sub	sp, #0x28
700a32f4: 9008         	str	r0, [sp, #0x20]
700a32f6: 9107         	str	r1, [sp, #0x1c]
700a32f8: 9206         	str	r2, [sp, #0x18]
700a32fa: 9305         	str	r3, [sp, #0x14]
700a32fc: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
700a32fe: 9004         	str	r0, [sp, #0x10]
;     Queue_t * const pxQueue = xQueue;
700a3300: 9808         	ldr	r0, [sp, #0x20]
700a3302: 9000         	str	r0, [sp]
;     for( ; ; )
700a3304: e7ff         	b	0x700a3306 <xQueueGenericSend+0x16> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a3306: f00b fa33    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0xb466
;             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a330a: 9800         	ldr	r0, [sp]
700a330c: 6b80         	ldr	r0, [r0, #0x38]
700a330e: 9900         	ldr	r1, [sp]
700a3310: 6bc9         	ldr	r1, [r1, #0x3c]
700a3312: 4288         	cmp	r0, r1
700a3314: d304         	blo	0x700a3320 <xQueueGenericSend+0x30> @ imm = #0x8
700a3316: e7ff         	b	0x700a3318 <xQueueGenericSend+0x28> @ imm = #-0x2
700a3318: 9805         	ldr	r0, [sp, #0x14]
700a331a: 2802         	cmp	r0, #0x2
700a331c: d120         	bne	0x700a3360 <xQueueGenericSend+0x70> @ imm = #0x40
700a331e: e7ff         	b	0x700a3320 <xQueueGenericSend+0x30> @ imm = #-0x2
;                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a3320: 9800         	ldr	r0, [sp]
700a3322: 9907         	ldr	r1, [sp, #0x1c]
700a3324: 9a05         	ldr	r2, [sp, #0x14]
700a3326: f003 fc6b    	bl	0x700a6c00 <prvCopyDataToQueue> @ imm = #0x38d6
700a332a: 9003         	str	r0, [sp, #0xc]
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a332c: 9800         	ldr	r0, [sp]
700a332e: 6a40         	ldr	r0, [r0, #0x24]
700a3330: b150         	cbz	r0, 0x700a3348 <xQueueGenericSend+0x58> @ imm = #0x14
700a3332: e7ff         	b	0x700a3334 <xQueueGenericSend+0x44> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a3334: 9800         	ldr	r0, [sp]
700a3336: 3024         	adds	r0, #0x24
700a3338: f004 fbe2    	bl	0x700a7b00 <xTaskRemoveFromEventList> @ imm = #0x47c4
700a333c: b110         	cbz	r0, 0x700a3344 <xQueueGenericSend+0x54> @ imm = #0x4
700a333e: e7ff         	b	0x700a3340 <xQueueGenericSend+0x50> @ imm = #-0x2
;                                 queueYIELD_IF_USING_PREEMPTION();
700a3340: df00         	svc	#0x0
;                             }
700a3342: e000         	b	0x700a3346 <xQueueGenericSend+0x56> @ imm = #0x0
700a3344: e7ff         	b	0x700a3346 <xQueueGenericSend+0x56> @ imm = #-0x2
;                         }
700a3346: e006         	b	0x700a3356 <xQueueGenericSend+0x66> @ imm = #0xc
;                         else if( xYieldRequired != pdFALSE )
700a3348: 9803         	ldr	r0, [sp, #0xc]
700a334a: b110         	cbz	r0, 0x700a3352 <xQueueGenericSend+0x62> @ imm = #0x4
700a334c: e7ff         	b	0x700a334e <xQueueGenericSend+0x5e> @ imm = #-0x2
;                             queueYIELD_IF_USING_PREEMPTION();
700a334e: df00         	svc	#0x0
;                         }
700a3350: e000         	b	0x700a3354 <xQueueGenericSend+0x64> @ imm = #0x0
700a3352: e7ff         	b	0x700a3354 <xQueueGenericSend+0x64> @ imm = #-0x2
700a3354: e7ff         	b	0x700a3356 <xQueueGenericSend+0x66> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a3356: f00a facb    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xa596
700a335a: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a335c: 9009         	str	r0, [sp, #0x24]
700a335e: e05b         	b	0x700a3418 <xQueueGenericSend+0x128> @ imm = #0xb6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a3360: 9806         	ldr	r0, [sp, #0x18]
700a3362: b928         	cbnz	r0, 0x700a3370 <xQueueGenericSend+0x80> @ imm = #0xa
700a3364: e7ff         	b	0x700a3366 <xQueueGenericSend+0x76> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a3366: f00a fac3    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xa586
700a336a: 2000         	movs	r0, #0x0
;                     return errQUEUE_FULL;
700a336c: 9009         	str	r0, [sp, #0x24]
700a336e: e053         	b	0x700a3418 <xQueueGenericSend+0x128> @ imm = #0xa6
;                 else if( xEntryTimeSet == pdFALSE )
700a3370: 9804         	ldr	r0, [sp, #0x10]
700a3372: b930         	cbnz	r0, 0x700a3382 <xQueueGenericSend+0x92> @ imm = #0xc
700a3374: e7ff         	b	0x700a3376 <xQueueGenericSend+0x86> @ imm = #-0x2
700a3376: a801         	add	r0, sp, #0x4
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a3378: f00b ff72    	bl	0x700af260 <vTaskInternalSetTimeOutState> @ imm = #0xbee4
700a337c: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a337e: 9004         	str	r0, [sp, #0x10]
;                 }
700a3380: e000         	b	0x700a3384 <xQueueGenericSend+0x94> @ imm = #0x0
700a3382: e7ff         	b	0x700a3384 <xQueueGenericSend+0x94> @ imm = #-0x2
700a3384: e7ff         	b	0x700a3386 <xQueueGenericSend+0x96> @ imm = #-0x2
700a3386: e7ff         	b	0x700a3388 <xQueueGenericSend+0x98> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a3388: f00a fab2    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xa564
;         vTaskSuspendAll();
700a338c: f00c fc18    	bl	0x700afbc0 <vTaskSuspendAll> @ imm = #0xc830
;         prvLockQueue( pxQueue );
700a3390: f00b f9ee    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0xb3dc
700a3394: 9800         	ldr	r0, [sp]
700a3396: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a339a: 3001         	adds	r0, #0x1
700a339c: b928         	cbnz	r0, 0x700a33aa <xQueueGenericSend+0xba> @ imm = #0xa
700a339e: e7ff         	b	0x700a33a0 <xQueueGenericSend+0xb0> @ imm = #-0x2
700a33a0: 9900         	ldr	r1, [sp]
700a33a2: 2000         	movs	r0, #0x0
700a33a4: f881 0044    	strb.w	r0, [r1, #0x44]
700a33a8: e7ff         	b	0x700a33aa <xQueueGenericSend+0xba> @ imm = #-0x2
700a33aa: 9800         	ldr	r0, [sp]
700a33ac: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a33b0: 3001         	adds	r0, #0x1
700a33b2: b928         	cbnz	r0, 0x700a33c0 <xQueueGenericSend+0xd0> @ imm = #0xa
700a33b4: e7ff         	b	0x700a33b6 <xQueueGenericSend+0xc6> @ imm = #-0x2
700a33b6: 9900         	ldr	r1, [sp]
700a33b8: 2000         	movs	r0, #0x0
700a33ba: f881 0045    	strb.w	r0, [r1, #0x45]
700a33be: e7ff         	b	0x700a33c0 <xQueueGenericSend+0xd0> @ imm = #-0x2
700a33c0: f00a fa96    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xa52c
700a33c4: a801         	add	r0, sp, #0x4
700a33c6: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a33c8: f005 ff52    	bl	0x700a9270 <xTaskCheckForTimeOut> @ imm = #0x5ea4
700a33cc: b9d8         	cbnz	r0, 0x700a3406 <xQueueGenericSend+0x116> @ imm = #0x36
700a33ce: e7ff         	b	0x700a33d0 <xQueueGenericSend+0xe0> @ imm = #-0x2
;             if( prvIsQueueFull( pxQueue ) != pdFALSE )
700a33d0: 9800         	ldr	r0, [sp]
700a33d2: f00b fb15    	bl	0x700aea00 <prvIsQueueFull> @ imm = #0xb62a
700a33d6: b178         	cbz	r0, 0x700a33f8 <xQueueGenericSend+0x108> @ imm = #0x1e
700a33d8: e7ff         	b	0x700a33da <xQueueGenericSend+0xea> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
700a33da: 9800         	ldr	r0, [sp]
700a33dc: 3010         	adds	r0, #0x10
700a33de: 9906         	ldr	r1, [sp, #0x18]
700a33e0: f00b fe3e    	bl	0x700af060 <vTaskPlaceOnEventList> @ imm = #0xbc7c
;                 prvUnlockQueue( pxQueue );
700a33e4: 9800         	ldr	r0, [sp]
700a33e6: f004 fd53    	bl	0x700a7e90 <prvUnlockQueue> @ imm = #0x4aa6
;                 if( xTaskResumeAll() == pdFALSE )
700a33ea: f7fe ff51    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0x115e
700a33ee: b910         	cbnz	r0, 0x700a33f6 <xQueueGenericSend+0x106> @ imm = #0x4
700a33f0: e7ff         	b	0x700a33f2 <xQueueGenericSend+0x102> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a33f2: df00         	svc	#0x0
;                 }
700a33f4: e7ff         	b	0x700a33f6 <xQueueGenericSend+0x106> @ imm = #-0x2
;             }
700a33f6: e005         	b	0x700a3404 <xQueueGenericSend+0x114> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a33f8: 9800         	ldr	r0, [sp]
700a33fa: f004 fd49    	bl	0x700a7e90 <prvUnlockQueue> @ imm = #0x4a92
;                 ( void ) xTaskResumeAll();
700a33fe: f7fe ff47    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0x1172
700a3402: e7ff         	b	0x700a3404 <xQueueGenericSend+0x114> @ imm = #-0x2
;         }
700a3404: e007         	b	0x700a3416 <xQueueGenericSend+0x126> @ imm = #0xe
;             prvUnlockQueue( pxQueue );
700a3406: 9800         	ldr	r0, [sp]
700a3408: f004 fd42    	bl	0x700a7e90 <prvUnlockQueue> @ imm = #0x4a84
;             ( void ) xTaskResumeAll();
700a340c: f7fe ff40    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0x1180
700a3410: 2000         	movs	r0, #0x0
;             return errQUEUE_FULL;
700a3412: 9009         	str	r0, [sp, #0x24]
700a3414: e000         	b	0x700a3418 <xQueueGenericSend+0x128> @ imm = #0x0
;     for( ; ; )
700a3416: e776         	b	0x700a3306 <xQueueGenericSend+0x16> @ imm = #-0x114
; }
700a3418: 9809         	ldr	r0, [sp, #0x24]
700a341a: b00a         	add	sp, #0x28
700a341c: bd80         	pop	{r7, pc}
700a341e: 0000         	movs	r0, r0

700a3420 <UART_lld_init>:
; {
700a3420: b580         	push	{r7, lr}
700a3422: b084         	sub	sp, #0x10
700a3424: 9003         	str	r0, [sp, #0xc]
700a3426: 2000         	movs	r0, #0x0
;     int32_t                status = UART_STATUS_SUCCESS;
700a3428: 9002         	str	r0, [sp, #0x8]
;     if((hUart != NULL_PTR) && (hUart->hUartInit != NULL_PTR))
700a342a: 9803         	ldr	r0, [sp, #0xc]
700a342c: b168         	cbz	r0, 0x700a344a <UART_lld_init+0x2a> @ imm = #0x1a
700a342e: e7ff         	b	0x700a3430 <UART_lld_init+0x10> @ imm = #-0x2
700a3430: 9803         	ldr	r0, [sp, #0xc]
700a3432: 6840         	ldr	r0, [r0, #0x4]
700a3434: b148         	cbz	r0, 0x700a344a <UART_lld_init+0x2a> @ imm = #0x12
700a3436: e7ff         	b	0x700a3438 <UART_lld_init+0x18> @ imm = #-0x2
;         if(hUart->state != UART_STATE_RESET)
700a3438: 9803         	ldr	r0, [sp, #0xc]
700a343a: 6d40         	ldr	r0, [r0, #0x54]
700a343c: b120         	cbz	r0, 0x700a3448 <UART_lld_init+0x28> @ imm = #0x8
700a343e: e7ff         	b	0x700a3440 <UART_lld_init+0x20> @ imm = #-0x2
700a3440: f06f 0004    	mvn	r0, #0x4
;             status = UART_TRANSFER_INVALID_STATE;
700a3444: 9002         	str	r0, [sp, #0x8]
;         }
700a3446: e7ff         	b	0x700a3448 <UART_lld_init+0x28> @ imm = #-0x2
;     }
700a3448: e003         	b	0x700a3452 <UART_lld_init+0x32> @ imm = #0x6
700a344a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a344e: 9002         	str	r0, [sp, #0x8]
700a3450: e7ff         	b	0x700a3452 <UART_lld_init+0x32> @ imm = #-0x2
;     if(UART_STATUS_SUCCESS == status)
700a3452: 9802         	ldr	r0, [sp, #0x8]
700a3454: 2800         	cmp	r0, #0x0
700a3456: d176         	bne	0x700a3546 <UART_lld_init+0x126> @ imm = #0xec
700a3458: e7ff         	b	0x700a345a <UART_lld_init+0x3a> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700a345a: 9903         	ldr	r1, [sp, #0xc]
700a345c: 2002         	movs	r0, #0x2
700a345e: 6548         	str	r0, [r1, #0x54]
;         hUartInit = hUart->hUartInit;
700a3460: 9803         	ldr	r0, [sp, #0xc]
700a3462: 6840         	ldr	r0, [r0, #0x4]
700a3464: 9001         	str	r0, [sp, #0x4]
;         hUart->lineStatusTimeout = hUartInit->clockP_usecToTick(UART_READ_LINE_STATUS_TIMEOUT_IN_US);
700a3466: 9801         	ldr	r0, [sp, #0x4]
700a3468: 6d82         	ldr	r2, [r0, #0x58]
700a346a: f244 2040    	movw	r0, #0x4240
700a346e: f2c0 000f    	movt	r0, #0xf
700a3472: 2100         	movs	r1, #0x0
700a3474: 9100         	str	r1, [sp]
700a3476: 4790         	blx	r2
700a3478: 9a00         	ldr	r2, [sp]
700a347a: 9903         	ldr	r1, [sp, #0xc]
700a347c: 66ca         	str	r2, [r1, #0x6c]
700a347e: 6688         	str	r0, [r1, #0x68]
;         status += UART_IsBaseAddrValid(hUart->baseAddr);
700a3480: 9803         	ldr	r0, [sp, #0xc]
700a3482: 6800         	ldr	r0, [r0]
700a3484: f005 f9d4    	bl	0x700a8830 <UART_IsBaseAddrValid> @ imm = #0x53a8
700a3488: 4601         	mov	r1, r0
700a348a: 9802         	ldr	r0, [sp, #0x8]
700a348c: 4408         	add	r0, r1
700a348e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->inputClkFreq);
700a3490: 9801         	ldr	r0, [sp, #0x4]
700a3492: 6800         	ldr	r0, [r0]
700a3494: f00c f874    	bl	0x700af580 <UART_IsParameter> @ imm = #0xc0e8
700a3498: 4601         	mov	r1, r0
700a349a: 9802         	ldr	r0, [sp, #0x8]
700a349c: 4408         	add	r0, r1
700a349e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParameter(hUartInit->baudRate);
700a34a0: 9801         	ldr	r0, [sp, #0x4]
700a34a2: 6840         	ldr	r0, [r0, #0x4]
700a34a4: f00c f86c    	bl	0x700af580 <UART_IsParameter> @ imm = #0xc0d8
700a34a8: 4601         	mov	r1, r0
700a34aa: 9802         	ldr	r0, [sp, #0x8]
700a34ac: 4408         	add	r0, r1
700a34ae: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsDataLengthValid(hUartInit->dataLength);
700a34b0: 9801         	ldr	r0, [sp, #0x4]
700a34b2: 6880         	ldr	r0, [r0, #0x8]
700a34b4: f00b f864    	bl	0x700ae580 <UART_IsDataLengthValid> @ imm = #0xb0c8
700a34b8: 4601         	mov	r1, r0
700a34ba: 9802         	ldr	r0, [sp, #0x8]
700a34bc: 4408         	add	r0, r1
700a34be: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsStopBitsValid(hUartInit->stopBits);
700a34c0: 9801         	ldr	r0, [sp, #0x4]
700a34c2: 68c0         	ldr	r0, [r0, #0xc]
700a34c4: f00b fe74    	bl	0x700af1b0 <UART_IsStopBitsValid> @ imm = #0xbce8
700a34c8: 4601         	mov	r1, r0
700a34ca: 9802         	ldr	r0, [sp, #0x8]
700a34cc: 4408         	add	r0, r1
700a34ce: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsParityTypeValid(hUartInit->parityType);
700a34d0: 9801         	ldr	r0, [sp, #0x4]
700a34d2: 6900         	ldr	r0, [r0, #0x10]
700a34d4: f00a fdb4    	bl	0x700ae040 <UART_IsParityTypeValid> @ imm = #0xab68
700a34d8: 4601         	mov	r1, r0
700a34da: 9802         	ldr	r0, [sp, #0x8]
700a34dc: 4408         	add	r0, r1
700a34de: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsHWFlowCtrlValid(hUartInit->hwFlowControlThr);
700a34e0: 9801         	ldr	r0, [sp, #0x4]
700a34e2: 69c0         	ldr	r0, [r0, #0x1c]
700a34e4: f00a fc6c    	bl	0x700addc0 <UART_IsHWFlowCtrlValid> @ imm = #0xa8d8
700a34e8: 4601         	mov	r1, r0
700a34ea: 9802         	ldr	r0, [sp, #0x8]
700a34ec: 4408         	add	r0, r1
700a34ee: 9002         	str	r0, [sp, #0x8]
;         status += UART_OperModeValid(hUartInit->operMode);
700a34f0: 9801         	ldr	r0, [sp, #0x4]
700a34f2: 6ac0         	ldr	r0, [r0, #0x2c]
700a34f4: f009 fcc4    	bl	0x700ace80 <UART_OperModeValid> @ imm = #0x9988
700a34f8: 4601         	mov	r1, r0
700a34fa: 9802         	ldr	r0, [sp, #0x8]
700a34fc: 4408         	add	r0, r1
700a34fe: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsRxTrigLvlValid(hUartInit->rxTrigLvl);
700a3500: 9801         	ldr	r0, [sp, #0x4]
700a3502: 6b80         	ldr	r0, [r0, #0x38]
700a3504: f00a fc7c    	bl	0x700ade00 <UART_IsRxTrigLvlValid> @ imm = #0xa8f8
700a3508: 4601         	mov	r1, r0
700a350a: 9802         	ldr	r0, [sp, #0x8]
700a350c: 4408         	add	r0, r1
700a350e: 9002         	str	r0, [sp, #0x8]
;         status += UART_IsTxTrigLvlValid(hUartInit->txTrigLvl);
700a3510: 9801         	ldr	r0, [sp, #0x4]
700a3512: 6bc0         	ldr	r0, [r0, #0x3c]
700a3514: f00a fc94    	bl	0x700ade40 <UART_IsTxTrigLvlValid> @ imm = #0xa928
700a3518: 4601         	mov	r1, r0
700a351a: 9802         	ldr	r0, [sp, #0x8]
700a351c: 4408         	add	r0, r1
700a351e: 9002         	str	r0, [sp, #0x8]
;         if(UART_STATUS_SUCCESS == status)
700a3520: 9802         	ldr	r0, [sp, #0x8]
700a3522: b938         	cbnz	r0, 0x700a3534 <UART_lld_init+0x114> @ imm = #0xe
700a3524: e7ff         	b	0x700a3526 <UART_lld_init+0x106> @ imm = #-0x2
;             UART_configInstance(hUart);
700a3526: 9803         	ldr	r0, [sp, #0xc]
700a3528: f002 f882    	bl	0x700a5630 <UART_configInstance> @ imm = #0x2104
;             hUart->state = UART_STATE_READY;
700a352c: 9903         	ldr	r1, [sp, #0xc]
700a352e: 2001         	movs	r0, #0x1
700a3530: 6548         	str	r0, [r1, #0x54]
;         }
700a3532: e007         	b	0x700a3544 <UART_lld_init+0x124> @ imm = #0xe
;             status += UART_lld_deInit(hUart);
700a3534: 9803         	ldr	r0, [sp, #0xc]
700a3536: f009 f863    	bl	0x700ac600 <UART_lld_deInit> @ imm = #0x90c6
700a353a: 4601         	mov	r1, r0
700a353c: 9802         	ldr	r0, [sp, #0x8]
700a353e: 4408         	add	r0, r1
700a3540: 9002         	str	r0, [sp, #0x8]
700a3542: e7ff         	b	0x700a3544 <UART_lld_init+0x124> @ imm = #-0x2
;     }
700a3544: e7ff         	b	0x700a3546 <UART_lld_init+0x126> @ imm = #-0x2
;     return status;
700a3546: 9802         	ldr	r0, [sp, #0x8]
700a3548: b004         	add	sp, #0x10
700a354a: bd80         	pop	{r7, pc}
700a354c: 0000         	movs	r0, r0
700a354e: 0000         	movs	r0, r0

700a3550 <Sciclient_pmQueryModuleClkFreq>:
; {
700a3550: b580         	push	{r7, lr}
700a3552: b09e         	sub	sp, #0x78
700a3554: f8dd c084    	ldr.w	r12, [sp, #0x84]
700a3558: f8dd c080    	ldr.w	r12, [sp, #0x80]
700a355c: 901d         	str	r0, [sp, #0x74]
700a355e: 911c         	str	r1, [sp, #0x70]
700a3560: 931b         	str	r3, [sp, #0x6c]
700a3562: 921a         	str	r2, [sp, #0x68]
700a3564: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a3566: 9019         	str	r0, [sp, #0x64]
;     request.device         = (uint32_t) moduleId;
700a3568: 981d         	ldr	r0, [sp, #0x74]
700a356a: 9010         	str	r0, [sp, #0x40]
;     request.min_freq_hz    = (uint64_t) reqFreqHz;
700a356c: 981a         	ldr	r0, [sp, #0x68]
700a356e: 991b         	ldr	r1, [sp, #0x6c]
700a3570: 9112         	str	r1, [sp, #0x48]
700a3572: 9011         	str	r0, [sp, #0x44]
;     request.target_freq_hz = (uint64_t) reqFreqHz;
700a3574: 981a         	ldr	r0, [sp, #0x68]
700a3576: 991b         	ldr	r1, [sp, #0x6c]
700a3578: 9114         	str	r1, [sp, #0x50]
700a357a: 9013         	str	r0, [sp, #0x4c]
;     request.max_freq_hz    = (uint64_t) reqFreqHz;
700a357c: 981a         	ldr	r0, [sp, #0x68]
700a357e: 991b         	ldr	r1, [sp, #0x6c]
700a3580: 9116         	str	r1, [sp, #0x58]
700a3582: 9015         	str	r0, [sp, #0x54]
;     if((reqFreqHz%10U) != 0U)
700a3584: 9b1a         	ldr	r3, [sp, #0x68]
700a3586: 981b         	ldr	r0, [sp, #0x6c]
700a3588: f64c 41cd    	movw	r1, #0xcccd
700a358c: f6cc 41cc    	movt	r1, #0xcccc
700a3590: fba3 2e01    	umull	r2, lr, r3, r1
700a3594: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a3598: fb03 e30c    	mla	r3, r3, r12, lr
700a359c: fb00 3101    	mla	r1, r0, r1, r3
700a35a0: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a35a4: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a35a8: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a35ac: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a35b0: f649 129a    	movw	r2, #0x999a
700a35b4: f6c9 1299    	movt	r2, #0x9999
700a35b8: 1a89         	subs	r1, r1, r2
700a35ba: f649 1199    	movw	r1, #0x9999
700a35be: f6c1 1199    	movt	r1, #0x1999
700a35c2: 4188         	sbcs	r0, r1
700a35c4: d316         	blo	0x700a35f4 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #0x2c
700a35c6: e7ff         	b	0x700a35c8 <Sciclient_pmQueryModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(reqFreqHz-(reqFreqHz%10U));
700a35c8: 981a         	ldr	r0, [sp, #0x68]
700a35ca: 9001         	str	r0, [sp, #0x4]
700a35cc: 991b         	ldr	r1, [sp, #0x6c]
700a35ce: 9100         	str	r1, [sp]
700a35d0: 220a         	movs	r2, #0xa
700a35d2: 2300         	movs	r3, #0x0
700a35d4: f00b edfe    	blx	0x700af1d4 <__aeabi_uldivmod> @ imm = #0xbbfc
700a35d8: 9800         	ldr	r0, [sp]
700a35da: 9901         	ldr	r1, [sp, #0x4]
700a35dc: 1a89         	subs	r1, r1, r2
700a35de: 4198         	sbcs	r0, r3
700a35e0: 9111         	str	r1, [sp, #0x44]
700a35e2: 9012         	str	r0, [sp, #0x48]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a35e4: 9911         	ldr	r1, [sp, #0x44]
700a35e6: 9812         	ldr	r0, [sp, #0x48]
700a35e8: 310a         	adds	r1, #0xa
700a35ea: f140 0000    	adc	r0, r0, #0x0
700a35ee: 9115         	str	r1, [sp, #0x54]
700a35f0: 9016         	str	r0, [sp, #0x58]
;     }
700a35f2: e7ff         	b	0x700a35f4 <Sciclient_pmQueryModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a35f4: 981c         	ldr	r0, [sp, #0x70]
700a35f6: 28ff         	cmp	r0, #0xff
700a35f8: d307         	blo	0x700a360a <Sciclient_pmQueryModuleClkFreq+0xba> @ imm = #0xe
700a35fa: e7ff         	b	0x700a35fc <Sciclient_pmQueryModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a35fc: 981c         	ldr	r0, [sp, #0x70]
700a35fe: f8cd 005d    	str.w	r0, [sp, #0x5d]
700a3602: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a3604: f88d 005c    	strb.w	r0, [sp, #0x5c]
;     }
700a3608: e003         	b	0x700a3612 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a360a: 981c         	ldr	r0, [sp, #0x70]
700a360c: f88d 005c    	strb.w	r0, [sp, #0x5c]
700a3610: e7ff         	b	0x700a3612 <Sciclient_pmQueryModuleClkFreq+0xc2> @ imm = #-0x2
700a3612: 2000         	movs	r0, #0x0
;     struct tisci_msg_query_freq_resp response = {{0}};
700a3614: 900d         	str	r0, [sp, #0x34]
700a3616: 900c         	str	r0, [sp, #0x30]
700a3618: 900b         	str	r0, [sp, #0x2c]
700a361a: 900a         	str	r0, [sp, #0x28]
700a361c: f240 110d    	movw	r1, #0x10d
;     reqParam.messageType    = (uint16_t) TISCI_MSG_QUERY_FREQ;
700a3620: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a3624: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a3626: 9106         	str	r1, [sp, #0x18]
700a3628: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a362a: 9107         	str	r1, [sp, #0x1c]
700a362c: 2129         	movs	r1, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a362e: 9108         	str	r1, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a3630: 9921         	ldr	r1, [sp, #0x84]
700a3632: 9109         	str	r1, [sp, #0x24]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a3634: 9002         	str	r0, [sp, #0x8]
700a3636: a80a         	add	r0, sp, #0x28
;     respParam.pRespPayload    = (uint8_t *) &response;
700a3638: 9003         	str	r0, [sp, #0xc]
700a363a: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a363c: 9004         	str	r0, [sp, #0x10]
700a363e: a805         	add	r0, sp, #0x14
700a3640: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a3642: f7f9 ffcd    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0x6066
700a3646: 9019         	str	r0, [sp, #0x64]
;     if((retVal != SystemP_SUCCESS) ||
700a3648: 9819         	ldr	r0, [sp, #0x64]
700a364a: b930         	cbnz	r0, 0x700a365a <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #0xc
700a364c: e7ff         	b	0x700a364e <Sciclient_pmQueryModuleClkFreq+0xfe> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a364e: 9802         	ldr	r0, [sp, #0x8]
700a3650: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a3654: 2802         	cmp	r0, #0x2
700a3656: d004         	beq	0x700a3662 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #0x8
700a3658: e7ff         	b	0x700a365a <Sciclient_pmQueryModuleClkFreq+0x10a> @ imm = #-0x2
700a365a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a365e: 9019         	str	r0, [sp, #0x64]
;     }
700a3660: e7ff         	b	0x700a3662 <Sciclient_pmQueryModuleClkFreq+0x112> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a3662: 9819         	ldr	r0, [sp, #0x64]
700a3664: b930         	cbnz	r0, 0x700a3674 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #0xc
700a3666: e7ff         	b	0x700a3668 <Sciclient_pmQueryModuleClkFreq+0x118> @ imm = #-0x2
;         *respFreqHz = (uint64_t) response.freq_hz;
700a3668: 980c         	ldr	r0, [sp, #0x30]
700a366a: 9a0d         	ldr	r2, [sp, #0x34]
700a366c: 9920         	ldr	r1, [sp, #0x80]
700a366e: 604a         	str	r2, [r1, #0x4]
700a3670: 6008         	str	r0, [r1]
;     }
700a3672: e7ff         	b	0x700a3674 <Sciclient_pmQueryModuleClkFreq+0x124> @ imm = #-0x2
;     return retVal;
700a3674: 9819         	ldr	r0, [sp, #0x64]
700a3676: b01e         	add	sp, #0x78
700a3678: bd80         	pop	{r7, pc}
700a367a: 0000         	movs	r0, r0
700a367c: 0000         	movs	r0, r0
700a367e: 0000         	movs	r0, r0

700a3680 <xQueueReceive>:
; {
700a3680: b580         	push	{r7, lr}
700a3682: b08a         	sub	sp, #0x28
700a3684: 9008         	str	r0, [sp, #0x20]
700a3686: 9107         	str	r1, [sp, #0x1c]
700a3688: 9206         	str	r2, [sp, #0x18]
700a368a: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
700a368c: 9005         	str	r0, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a368e: 9808         	ldr	r0, [sp, #0x20]
700a3690: 9002         	str	r0, [sp, #0x8]
;     for( ; ; )
700a3692: e7ff         	b	0x700a3694 <xQueueReceive+0x14> @ imm = #-0x2
;         taskENTER_CRITICAL();
700a3694: f00b f86c    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0xb0d8
;             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a3698: 9802         	ldr	r0, [sp, #0x8]
700a369a: 6b80         	ldr	r0, [r0, #0x38]
700a369c: 9001         	str	r0, [sp, #0x4]
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a369e: 9801         	ldr	r0, [sp, #0x4]
700a36a0: b1e0         	cbz	r0, 0x700a36dc <xQueueReceive+0x5c> @ imm = #0x38
700a36a2: e7ff         	b	0x700a36a4 <xQueueReceive+0x24> @ imm = #-0x2
;                 prvCopyDataFromQueue( pxQueue, pvBuffer );
700a36a4: 9802         	ldr	r0, [sp, #0x8]
700a36a6: 9907         	ldr	r1, [sp, #0x1c]
700a36a8: f00a fa62    	bl	0x700adb70 <prvCopyDataFromQueue> @ imm = #0xa4c4
;                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a36ac: 9801         	ldr	r0, [sp, #0x4]
700a36ae: 3801         	subs	r0, #0x1
700a36b0: 9902         	ldr	r1, [sp, #0x8]
700a36b2: 6388         	str	r0, [r1, #0x38]
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a36b4: 9802         	ldr	r0, [sp, #0x8]
700a36b6: 6900         	ldr	r0, [r0, #0x10]
700a36b8: b150         	cbz	r0, 0x700a36d0 <xQueueReceive+0x50> @ imm = #0x14
700a36ba: e7ff         	b	0x700a36bc <xQueueReceive+0x3c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a36bc: 9802         	ldr	r0, [sp, #0x8]
700a36be: 3010         	adds	r0, #0x10
700a36c0: f004 fa1e    	bl	0x700a7b00 <xTaskRemoveFromEventList> @ imm = #0x443c
700a36c4: b110         	cbz	r0, 0x700a36cc <xQueueReceive+0x4c> @ imm = #0x4
700a36c6: e7ff         	b	0x700a36c8 <xQueueReceive+0x48> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
700a36c8: df00         	svc	#0x0
;                     }
700a36ca: e000         	b	0x700a36ce <xQueueReceive+0x4e> @ imm = #0x0
700a36cc: e7ff         	b	0x700a36ce <xQueueReceive+0x4e> @ imm = #-0x2
;                 }
700a36ce: e000         	b	0x700a36d2 <xQueueReceive+0x52> @ imm = #0x0
700a36d0: e7ff         	b	0x700a36d2 <xQueueReceive+0x52> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
700a36d2: f00a f90d    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xa21a
700a36d6: 2001         	movs	r0, #0x1
;                 return pdPASS;
700a36d8: 9009         	str	r0, [sp, #0x24]
700a36da: e063         	b	0x700a37a4 <xQueueReceive+0x124> @ imm = #0xc6
;                 if( xTicksToWait == ( TickType_t ) 0 )
700a36dc: 9806         	ldr	r0, [sp, #0x18]
700a36de: b928         	cbnz	r0, 0x700a36ec <xQueueReceive+0x6c> @ imm = #0xa
700a36e0: e7ff         	b	0x700a36e2 <xQueueReceive+0x62> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
700a36e2: f00a f905    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xa20a
700a36e6: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
700a36e8: 9009         	str	r0, [sp, #0x24]
700a36ea: e05b         	b	0x700a37a4 <xQueueReceive+0x124> @ imm = #0xb6
;                 else if( xEntryTimeSet == pdFALSE )
700a36ec: 9805         	ldr	r0, [sp, #0x14]
700a36ee: b930         	cbnz	r0, 0x700a36fe <xQueueReceive+0x7e> @ imm = #0xc
700a36f0: e7ff         	b	0x700a36f2 <xQueueReceive+0x72> @ imm = #-0x2
700a36f2: a803         	add	r0, sp, #0xc
;                     vTaskInternalSetTimeOutState( &xTimeOut );
700a36f4: f00b fdb4    	bl	0x700af260 <vTaskInternalSetTimeOutState> @ imm = #0xbb68
700a36f8: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
700a36fa: 9005         	str	r0, [sp, #0x14]
;                 }
700a36fc: e000         	b	0x700a3700 <xQueueReceive+0x80> @ imm = #0x0
700a36fe: e7ff         	b	0x700a3700 <xQueueReceive+0x80> @ imm = #-0x2
700a3700: e7ff         	b	0x700a3702 <xQueueReceive+0x82> @ imm = #-0x2
700a3702: e7ff         	b	0x700a3704 <xQueueReceive+0x84> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a3704: f00a f8f4    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xa1e8
;         vTaskSuspendAll();
700a3708: f00c fa5a    	bl	0x700afbc0 <vTaskSuspendAll> @ imm = #0xc4b4
;         prvLockQueue( pxQueue );
700a370c: f00b f830    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0xb060
700a3710: 9802         	ldr	r0, [sp, #0x8]
700a3712: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700a3716: 3001         	adds	r0, #0x1
700a3718: b928         	cbnz	r0, 0x700a3726 <xQueueReceive+0xa6> @ imm = #0xa
700a371a: e7ff         	b	0x700a371c <xQueueReceive+0x9c> @ imm = #-0x2
700a371c: 9902         	ldr	r1, [sp, #0x8]
700a371e: 2000         	movs	r0, #0x0
700a3720: f881 0044    	strb.w	r0, [r1, #0x44]
700a3724: e7ff         	b	0x700a3726 <xQueueReceive+0xa6> @ imm = #-0x2
700a3726: 9802         	ldr	r0, [sp, #0x8]
700a3728: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700a372c: 3001         	adds	r0, #0x1
700a372e: b928         	cbnz	r0, 0x700a373c <xQueueReceive+0xbc> @ imm = #0xa
700a3730: e7ff         	b	0x700a3732 <xQueueReceive+0xb2> @ imm = #-0x2
700a3732: 9902         	ldr	r1, [sp, #0x8]
700a3734: 2000         	movs	r0, #0x0
700a3736: f881 0045    	strb.w	r0, [r1, #0x45]
700a373a: e7ff         	b	0x700a373c <xQueueReceive+0xbc> @ imm = #-0x2
700a373c: f00a f8d8    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0xa1b0
700a3740: a803         	add	r0, sp, #0xc
700a3742: a906         	add	r1, sp, #0x18
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
700a3744: f005 fd94    	bl	0x700a9270 <xTaskCheckForTimeOut> @ imm = #0x5b28
700a3748: b9e0         	cbnz	r0, 0x700a3784 <xQueueReceive+0x104> @ imm = #0x38
700a374a: e7ff         	b	0x700a374c <xQueueReceive+0xcc> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a374c: 9802         	ldr	r0, [sp, #0x8]
700a374e: f00b fbc7    	bl	0x700aeee0 <prvIsQueueEmpty> @ imm = #0xb78e
700a3752: b180         	cbz	r0, 0x700a3776 <xQueueReceive+0xf6> @ imm = #0x20
700a3754: e7ff         	b	0x700a3756 <xQueueReceive+0xd6> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
700a3756: 9802         	ldr	r0, [sp, #0x8]
700a3758: 3024         	adds	r0, #0x24
700a375a: 9906         	ldr	r1, [sp, #0x18]
700a375c: f00b fc80    	bl	0x700af060 <vTaskPlaceOnEventList> @ imm = #0xb900
;                 prvUnlockQueue( pxQueue );
700a3760: 9802         	ldr	r0, [sp, #0x8]
700a3762: f004 fb95    	bl	0x700a7e90 <prvUnlockQueue> @ imm = #0x472a
;                 if( xTaskResumeAll() == pdFALSE )
700a3766: f7fe fd93    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0x14da
700a376a: b910         	cbnz	r0, 0x700a3772 <xQueueReceive+0xf2> @ imm = #0x4
700a376c: e7ff         	b	0x700a376e <xQueueReceive+0xee> @ imm = #-0x2
;                     portYIELD_WITHIN_API();
700a376e: df00         	svc	#0x0
;                 }
700a3770: e000         	b	0x700a3774 <xQueueReceive+0xf4> @ imm = #0x0
700a3772: e7ff         	b	0x700a3774 <xQueueReceive+0xf4> @ imm = #-0x2
;             }
700a3774: e005         	b	0x700a3782 <xQueueReceive+0x102> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
700a3776: 9802         	ldr	r0, [sp, #0x8]
700a3778: f004 fb8a    	bl	0x700a7e90 <prvUnlockQueue> @ imm = #0x4714
;                 ( void ) xTaskResumeAll();
700a377c: f7fe fd88    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0x14f0
700a3780: e7ff         	b	0x700a3782 <xQueueReceive+0x102> @ imm = #-0x2
;         }
700a3782: e00e         	b	0x700a37a2 <xQueueReceive+0x122> @ imm = #0x1c
;             prvUnlockQueue( pxQueue );
700a3784: 9802         	ldr	r0, [sp, #0x8]
700a3786: f004 fb83    	bl	0x700a7e90 <prvUnlockQueue> @ imm = #0x4706
;             ( void ) xTaskResumeAll();
700a378a: f7fe fd81    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0x14fe
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
700a378e: 9802         	ldr	r0, [sp, #0x8]
700a3790: f00b fba6    	bl	0x700aeee0 <prvIsQueueEmpty> @ imm = #0xb74c
700a3794: b118         	cbz	r0, 0x700a379e <xQueueReceive+0x11e> @ imm = #0x6
700a3796: e7ff         	b	0x700a3798 <xQueueReceive+0x118> @ imm = #-0x2
700a3798: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
700a379a: 9009         	str	r0, [sp, #0x24]
700a379c: e002         	b	0x700a37a4 <xQueueReceive+0x124> @ imm = #0x4
700a379e: e7ff         	b	0x700a37a0 <xQueueReceive+0x120> @ imm = #-0x2
700a37a0: e7ff         	b	0x700a37a2 <xQueueReceive+0x122> @ imm = #-0x2
;     for( ; ; )
700a37a2: e777         	b	0x700a3694 <xQueueReceive+0x14> @ imm = #-0x112
; }
700a37a4: 9809         	ldr	r0, [sp, #0x24]
700a37a6: b00a         	add	sp, #0x28
700a37a8: bd80         	pop	{r7, pc}
700a37aa: 0000         	movs	r0, r0
700a37ac: 0000         	movs	r0, r0
700a37ae: 0000         	movs	r0, r0

700a37b0 <pxPortInitialiseStack>:
;                                    TaskFunction_t pxCode, void *pvParameters) {
700a37b0: b083         	sub	sp, #0xc
700a37b2: 9002         	str	r0, [sp, #0x8]
700a37b4: 9101         	str	r1, [sp, #0x4]
700a37b6: 9200         	str	r2, [sp]
;   *pxTopOfStack = (StackType_t)NULL;
700a37b8: 9902         	ldr	r1, [sp, #0x8]
700a37ba: 2000         	movs	r0, #0x0
700a37bc: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a37be: 9902         	ldr	r1, [sp, #0x8]
700a37c0: 3904         	subs	r1, #0x4
700a37c2: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a37c4: 9902         	ldr	r1, [sp, #0x8]
700a37c6: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a37c8: 9902         	ldr	r1, [sp, #0x8]
700a37ca: 3904         	subs	r1, #0x4
700a37cc: 9102         	str	r1, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)NULL;
700a37ce: 9902         	ldr	r1, [sp, #0x8]
700a37d0: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a37d2: 9802         	ldr	r0, [sp, #0x8]
700a37d4: 3804         	subs	r0, #0x4
700a37d6: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portINITIAL_SPSR;
700a37d8: 9902         	ldr	r1, [sp, #0x8]
700a37da: 201f         	movs	r0, #0x1f
700a37dc: 6008         	str	r0, [r1]
;   if (((uint32_t)pxCode & portTHUMB_MODE_ADDRESS) != 0x00UL) {
700a37de: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a37e2: 07c0         	lsls	r0, r0, #0x1f
700a37e4: b130         	cbz	r0, 0x700a37f4 <pxPortInitialiseStack+0x44> @ imm = #0xc
700a37e6: e7ff         	b	0x700a37e8 <pxPortInitialiseStack+0x38> @ imm = #-0x2
;     *pxTopOfStack |= portTHUMB_MODE_BIT;
700a37e8: 9902         	ldr	r1, [sp, #0x8]
700a37ea: 6808         	ldr	r0, [r1]
700a37ec: f040 0020    	orr	r0, r0, #0x20
700a37f0: 6008         	str	r0, [r1]
;   }
700a37f2: e7ff         	b	0x700a37f4 <pxPortInitialiseStack+0x44> @ imm = #-0x2
;   pxTopOfStack--;
700a37f4: 9802         	ldr	r0, [sp, #0x8]
700a37f6: 3804         	subs	r0, #0x4
700a37f8: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pxCode;
700a37fa: 9801         	ldr	r0, [sp, #0x4]
700a37fc: 9902         	ldr	r1, [sp, #0x8]
700a37fe: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3800: 9802         	ldr	r0, [sp, #0x8]
700a3802: 3804         	subs	r0, #0x4
700a3804: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* R14 */
700a3806: 9902         	ldr	r1, [sp, #0x8]
700a3808: f64f 40d1    	movw	r0, #0xfcd1
700a380c: f2c7 000a    	movt	r0, #0x700a
700a3810: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3812: 9802         	ldr	r0, [sp, #0x8]
700a3814: 3804         	subs	r0, #0x4
700a3816: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x12121212; /* R12 */
700a3818: 9902         	ldr	r1, [sp, #0x8]
700a381a: f04f 3012    	mov.w	r0, #0x12121212
700a381e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3820: 9802         	ldr	r0, [sp, #0x8]
700a3822: 3804         	subs	r0, #0x4
700a3824: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x11111111; /* R11 */
700a3826: 9902         	ldr	r1, [sp, #0x8]
700a3828: f04f 3011    	mov.w	r0, #0x11111111
700a382c: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a382e: 9802         	ldr	r0, [sp, #0x8]
700a3830: 3804         	subs	r0, #0x4
700a3832: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x10101010; /* R10 */
700a3834: 9902         	ldr	r1, [sp, #0x8]
700a3836: f04f 3010    	mov.w	r0, #0x10101010
700a383a: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a383c: 9802         	ldr	r0, [sp, #0x8]
700a383e: 3804         	subs	r0, #0x4
700a3840: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x09090909; /* R9 */
700a3842: 9902         	ldr	r1, [sp, #0x8]
700a3844: f04f 3009    	mov.w	r0, #0x9090909
700a3848: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a384a: 9802         	ldr	r0, [sp, #0x8]
700a384c: 3804         	subs	r0, #0x4
700a384e: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x08080808; /* R8 */
700a3850: 9902         	ldr	r1, [sp, #0x8]
700a3852: f04f 3008    	mov.w	r0, #0x8080808
700a3856: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3858: 9802         	ldr	r0, [sp, #0x8]
700a385a: 3804         	subs	r0, #0x4
700a385c: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x07070707; /* R7 */
700a385e: 9902         	ldr	r1, [sp, #0x8]
700a3860: f04f 3007    	mov.w	r0, #0x7070707
700a3864: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3866: 9802         	ldr	r0, [sp, #0x8]
700a3868: 3804         	subs	r0, #0x4
700a386a: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x06060606; /* R6 */
700a386c: 9902         	ldr	r1, [sp, #0x8]
700a386e: f04f 3006    	mov.w	r0, #0x6060606
700a3872: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3874: 9802         	ldr	r0, [sp, #0x8]
700a3876: 3804         	subs	r0, #0x4
700a3878: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x05050505; /* R5 */
700a387a: 9902         	ldr	r1, [sp, #0x8]
700a387c: f04f 3005    	mov.w	r0, #0x5050505
700a3880: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3882: 9802         	ldr	r0, [sp, #0x8]
700a3884: 3804         	subs	r0, #0x4
700a3886: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x04040404; /* R4 */
700a3888: 9902         	ldr	r1, [sp, #0x8]
700a388a: f04f 3004    	mov.w	r0, #0x4040404
700a388e: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a3890: 9802         	ldr	r0, [sp, #0x8]
700a3892: 3804         	subs	r0, #0x4
700a3894: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x03030303; /* R3 */
700a3896: 9902         	ldr	r1, [sp, #0x8]
700a3898: f04f 3003    	mov.w	r0, #0x3030303
700a389c: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a389e: 9802         	ldr	r0, [sp, #0x8]
700a38a0: 3804         	subs	r0, #0x4
700a38a2: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x02020202; /* R2 */
700a38a4: 9902         	ldr	r1, [sp, #0x8]
700a38a6: f04f 3002    	mov.w	r0, #0x2020202
700a38aa: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a38ac: 9802         	ldr	r0, [sp, #0x8]
700a38ae: 3804         	subs	r0, #0x4
700a38b0: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)0x01010101; /* R1 */
700a38b2: 9902         	ldr	r1, [sp, #0x8]
700a38b4: f04f 3001    	mov.w	r0, #0x1010101
700a38b8: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a38ba: 9802         	ldr	r0, [sp, #0x8]
700a38bc: 3804         	subs	r0, #0x4
700a38be: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = (StackType_t)pvParameters; /* R0 */
700a38c0: 9800         	ldr	r0, [sp]
700a38c2: 9902         	ldr	r1, [sp, #0x8]
700a38c4: 6008         	str	r0, [r1]
;   pxTopOfStack--;
700a38c6: 9802         	ldr	r0, [sp, #0x8]
700a38c8: 3804         	subs	r0, #0x4
700a38ca: 9002         	str	r0, [sp, #0x8]
;   *pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
700a38cc: 9902         	ldr	r1, [sp, #0x8]
700a38ce: 2000         	movs	r0, #0x0
700a38d0: 6008         	str	r0, [r1]
;   return pxTopOfStack;
700a38d2: 9802         	ldr	r0, [sp, #0x8]
700a38d4: b003         	add	sp, #0xc
700a38d6: 4770         	bx	lr
		...

700a38e0 <Udma_rmAllocBlkCopyCh>:
; {
700a38e0: b580         	push	{r7, lr}
700a38e2: b088         	sub	sp, #0x20
700a38e4: 9007         	str	r0, [sp, #0x1c]
700a38e6: 9106         	str	r1, [sp, #0x18]
700a38e8: 2000         	movs	r0, #0x0
700a38ea: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a38ee: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a38f0: 9806         	ldr	r0, [sp, #0x18]
700a38f2: f500 70ea    	add.w	r0, r0, #0x1d4
700a38f6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a38f8: 9806         	ldr	r0, [sp, #0x18]
700a38fa: f500 609f    	add.w	r0, r0, #0x4f8
700a38fe: f04f 31ff    	mov.w	r1, #0xffffffff
700a3902: f006 ff65    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x6eca
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3906: 9807         	ldr	r0, [sp, #0x1c]
700a3908: 2101         	movs	r1, #0x1
700a390a: f6cf 71ff    	movt	r1, #0xffff
700a390e: 4288         	cmp	r0, r1
700a3910: d136         	bne	0x700a3980 <Udma_rmAllocBlkCopyCh+0xa0> @ imm = #0x6c
700a3912: e7ff         	b	0x700a3914 <Udma_rmAllocBlkCopyCh+0x34> @ imm = #-0x2
700a3914: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a3916: 9005         	str	r0, [sp, #0x14]
700a3918: e7ff         	b	0x700a391a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x2
700a391a: 9805         	ldr	r0, [sp, #0x14]
700a391c: 9900         	ldr	r1, [sp]
700a391e: 6949         	ldr	r1, [r1, #0x14]
700a3920: 4288         	cmp	r0, r1
700a3922: d22c         	bhs	0x700a397e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x58
700a3924: e7ff         	b	0x700a3926 <Udma_rmAllocBlkCopyCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3926: 9805         	ldr	r0, [sp, #0x14]
700a3928: 0940         	lsrs	r0, r0, #0x5
700a392a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a392c: 9805         	ldr	r0, [sp, #0x14]
700a392e: 9904         	ldr	r1, [sp, #0x10]
700a3930: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3934: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3936: 9903         	ldr	r1, [sp, #0xc]
700a3938: 2001         	movs	r0, #0x1
700a393a: 4088         	lsls	r0, r1
700a393c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a393e: 9806         	ldr	r0, [sp, #0x18]
700a3940: 9904         	ldr	r1, [sp, #0x10]
700a3942: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3946: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a394a: 9902         	ldr	r1, [sp, #0x8]
700a394c: 4008         	ands	r0, r1
700a394e: 4288         	cmp	r0, r1
700a3950: d110         	bne	0x700a3974 <Udma_rmAllocBlkCopyCh+0x94> @ imm = #0x20
700a3952: e7ff         	b	0x700a3954 <Udma_rmAllocBlkCopyCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a3954: 9a02         	ldr	r2, [sp, #0x8]
700a3956: 9806         	ldr	r0, [sp, #0x18]
700a3958: 9904         	ldr	r1, [sp, #0x10]
700a395a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a395e: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a3962: 4390         	bics	r0, r2
700a3964: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = i + rmInitPrms->startBlkCopyCh;  /* Add start offset */
700a3968: 9805         	ldr	r0, [sp, #0x14]
700a396a: 9900         	ldr	r1, [sp]
700a396c: 6909         	ldr	r1, [r1, #0x10]
700a396e: 4408         	add	r0, r1
700a3970: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3972: e004         	b	0x700a397e <Udma_rmAllocBlkCopyCh+0x9e> @ imm = #0x8
;         }
700a3974: e7ff         	b	0x700a3976 <Udma_rmAllocBlkCopyCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyCh; i++)
700a3976: 9805         	ldr	r0, [sp, #0x14]
700a3978: 3001         	adds	r0, #0x1
700a397a: 9005         	str	r0, [sp, #0x14]
700a397c: e7cd         	b	0x700a391a <Udma_rmAllocBlkCopyCh+0x3a> @ imm = #-0x66
;     }
700a397e: e038         	b	0x700a39f2 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a3980: 9807         	ldr	r0, [sp, #0x1c]
700a3982: 9900         	ldr	r1, [sp]
700a3984: 6909         	ldr	r1, [r1, #0x10]
700a3986: 4288         	cmp	r0, r1
700a3988: d332         	blo	0x700a39f0 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x64
700a398a: e7ff         	b	0x700a398c <Udma_rmAllocBlkCopyCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyCh + rmInitPrms->numBlkCopyCh)))
700a398c: 9807         	ldr	r0, [sp, #0x1c]
700a398e: 9a00         	ldr	r2, [sp]
700a3990: 6911         	ldr	r1, [r2, #0x10]
700a3992: 6952         	ldr	r2, [r2, #0x14]
700a3994: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyCh) &&
700a3996: 4288         	cmp	r0, r1
700a3998: d22a         	bhs	0x700a39f0 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #0x54
700a399a: e7ff         	b	0x700a399c <Udma_rmAllocBlkCopyCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyCh;
700a399c: 9807         	ldr	r0, [sp, #0x1c]
700a399e: 9900         	ldr	r1, [sp]
700a39a0: 6909         	ldr	r1, [r1, #0x10]
700a39a2: 1a40         	subs	r0, r0, r1
700a39a4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a39a6: 9805         	ldr	r0, [sp, #0x14]
700a39a8: 0940         	lsrs	r0, r0, #0x5
700a39aa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a39ac: 9805         	ldr	r0, [sp, #0x14]
700a39ae: 9904         	ldr	r1, [sp, #0x10]
700a39b0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a39b4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a39b6: 9903         	ldr	r1, [sp, #0xc]
700a39b8: 2001         	movs	r0, #0x1
700a39ba: 4088         	lsls	r0, r1
700a39bc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyChFlag[offset] & bitMask) == bitMask)
700a39be: 9806         	ldr	r0, [sp, #0x18]
700a39c0: 9904         	ldr	r1, [sp, #0x10]
700a39c2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a39c6: f8d0 02c8    	ldr.w	r0, [r0, #0x2c8]
700a39ca: 9902         	ldr	r1, [sp, #0x8]
700a39cc: 4008         	ands	r0, r1
700a39ce: 4288         	cmp	r0, r1
700a39d0: d10d         	bne	0x700a39ee <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #0x1a
700a39d2: e7ff         	b	0x700a39d4 <Udma_rmAllocBlkCopyCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyChFlag[offset] &= ~bitMask;
700a39d4: 9a02         	ldr	r2, [sp, #0x8]
700a39d6: 9806         	ldr	r0, [sp, #0x18]
700a39d8: 9904         	ldr	r1, [sp, #0x10]
700a39da: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a39de: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700a39e2: 4390         	bics	r0, r2
700a39e4: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;                 chNum = preferredChNum;
700a39e8: 9807         	ldr	r0, [sp, #0x1c]
700a39ea: 9001         	str	r0, [sp, #0x4]
;             }
700a39ec: e7ff         	b	0x700a39ee <Udma_rmAllocBlkCopyCh+0x10e> @ imm = #-0x2
;         }
700a39ee: e7ff         	b	0x700a39f0 <Udma_rmAllocBlkCopyCh+0x110> @ imm = #-0x2
700a39f0: e7ff         	b	0x700a39f2 <Udma_rmAllocBlkCopyCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a39f2: 9806         	ldr	r0, [sp, #0x18]
700a39f4: f500 609f    	add.w	r0, r0, #0x4f8
700a39f8: f008 fa7a    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x84f4
;     return (chNum);
700a39fc: 9801         	ldr	r0, [sp, #0x4]
700a39fe: b008         	add	sp, #0x20
700a3a00: bd80         	pop	{r7, pc}
		...
700a3a0e: 0000         	movs	r0, r0

700a3a10 <Udma_rmAllocBlkCopyHcCh>:
; {
700a3a10: b580         	push	{r7, lr}
700a3a12: b088         	sub	sp, #0x20
700a3a14: 9007         	str	r0, [sp, #0x1c]
700a3a16: 9106         	str	r1, [sp, #0x18]
700a3a18: 2000         	movs	r0, #0x0
700a3a1a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3a1e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3a20: 9806         	ldr	r0, [sp, #0x18]
700a3a22: f500 70ea    	add.w	r0, r0, #0x1d4
700a3a26: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3a28: 9806         	ldr	r0, [sp, #0x18]
700a3a2a: f500 609f    	add.w	r0, r0, #0x4f8
700a3a2e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3a32: f006 fecd    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x6d9a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3a36: 9807         	ldr	r0, [sp, #0x1c]
700a3a38: 2101         	movs	r1, #0x1
700a3a3a: f6cf 71ff    	movt	r1, #0xffff
700a3a3e: 4288         	cmp	r0, r1
700a3a40: d136         	bne	0x700a3ab0 <Udma_rmAllocBlkCopyHcCh+0xa0> @ imm = #0x6c
700a3a42: e7ff         	b	0x700a3a44 <Udma_rmAllocBlkCopyHcCh+0x34> @ imm = #-0x2
700a3a44: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a3a46: 9005         	str	r0, [sp, #0x14]
700a3a48: e7ff         	b	0x700a3a4a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x2
700a3a4a: 9805         	ldr	r0, [sp, #0x14]
700a3a4c: 9900         	ldr	r1, [sp]
700a3a4e: 68c9         	ldr	r1, [r1, #0xc]
700a3a50: 4288         	cmp	r0, r1
700a3a52: d22c         	bhs	0x700a3aae <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x58
700a3a54: e7ff         	b	0x700a3a56 <Udma_rmAllocBlkCopyHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3a56: 9805         	ldr	r0, [sp, #0x14]
700a3a58: 0940         	lsrs	r0, r0, #0x5
700a3a5a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3a5c: 9805         	ldr	r0, [sp, #0x14]
700a3a5e: 9904         	ldr	r1, [sp, #0x10]
700a3a60: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3a64: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3a66: 9903         	ldr	r1, [sp, #0xc]
700a3a68: 2001         	movs	r0, #0x1
700a3a6a: 4088         	lsls	r0, r1
700a3a6c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a3a6e: 9806         	ldr	r0, [sp, #0x18]
700a3a70: 9904         	ldr	r1, [sp, #0x10]
700a3a72: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3a76: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a3a7a: 9902         	ldr	r1, [sp, #0x8]
700a3a7c: 4008         	ands	r0, r1
700a3a7e: 4288         	cmp	r0, r1
700a3a80: d110         	bne	0x700a3aa4 <Udma_rmAllocBlkCopyHcCh+0x94> @ imm = #0x20
700a3a82: e7ff         	b	0x700a3a84 <Udma_rmAllocBlkCopyHcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a3a84: 9a02         	ldr	r2, [sp, #0x8]
700a3a86: 9806         	ldr	r0, [sp, #0x18]
700a3a88: 9904         	ldr	r1, [sp, #0x10]
700a3a8a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3a8e: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a3a92: 4390         	bics	r0, r2
700a3a94: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = i + rmInitPrms->startBlkCopyHcCh;  /* Add start offset */
700a3a98: 9805         	ldr	r0, [sp, #0x14]
700a3a9a: 9900         	ldr	r1, [sp]
700a3a9c: 6889         	ldr	r1, [r1, #0x8]
700a3a9e: 4408         	add	r0, r1
700a3aa0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3aa2: e004         	b	0x700a3aae <Udma_rmAllocBlkCopyHcCh+0x9e> @ imm = #0x8
;         }
700a3aa4: e7ff         	b	0x700a3aa6 <Udma_rmAllocBlkCopyHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyHcCh; i++)
700a3aa6: 9805         	ldr	r0, [sp, #0x14]
700a3aa8: 3001         	adds	r0, #0x1
700a3aaa: 9005         	str	r0, [sp, #0x14]
700a3aac: e7cd         	b	0x700a3a4a <Udma_rmAllocBlkCopyHcCh+0x3a> @ imm = #-0x66
;     }
700a3aae: e038         	b	0x700a3b22 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a3ab0: 9807         	ldr	r0, [sp, #0x1c]
700a3ab2: 9900         	ldr	r1, [sp]
700a3ab4: 6889         	ldr	r1, [r1, #0x8]
700a3ab6: 4288         	cmp	r0, r1
700a3ab8: d332         	blo	0x700a3b20 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x64
700a3aba: e7ff         	b	0x700a3abc <Udma_rmAllocBlkCopyHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyHcCh + rmInitPrms->numBlkCopyHcCh)))
700a3abc: 9807         	ldr	r0, [sp, #0x1c]
700a3abe: 9a00         	ldr	r2, [sp]
700a3ac0: 6891         	ldr	r1, [r2, #0x8]
700a3ac2: 68d2         	ldr	r2, [r2, #0xc]
700a3ac4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyHcCh) &&
700a3ac6: 4288         	cmp	r0, r1
700a3ac8: d22a         	bhs	0x700a3b20 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #0x54
700a3aca: e7ff         	b	0x700a3acc <Udma_rmAllocBlkCopyHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyHcCh;
700a3acc: 9807         	ldr	r0, [sp, #0x1c]
700a3ace: 9900         	ldr	r1, [sp]
700a3ad0: 6889         	ldr	r1, [r1, #0x8]
700a3ad2: 1a40         	subs	r0, r0, r1
700a3ad4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3ad6: 9805         	ldr	r0, [sp, #0x14]
700a3ad8: 0940         	lsrs	r0, r0, #0x5
700a3ada: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3adc: 9805         	ldr	r0, [sp, #0x14]
700a3ade: 9904         	ldr	r1, [sp, #0x10]
700a3ae0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3ae4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3ae6: 9903         	ldr	r1, [sp, #0xc]
700a3ae8: 2001         	movs	r0, #0x1
700a3aea: 4088         	lsls	r0, r1
700a3aec: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyHcChFlag[offset] & bitMask) == bitMask)
700a3aee: 9806         	ldr	r0, [sp, #0x18]
700a3af0: 9904         	ldr	r1, [sp, #0x10]
700a3af2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3af6: f8d0 02cc    	ldr.w	r0, [r0, #0x2cc]
700a3afa: 9902         	ldr	r1, [sp, #0x8]
700a3afc: 4008         	ands	r0, r1
700a3afe: 4288         	cmp	r0, r1
700a3b00: d10d         	bne	0x700a3b1e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #0x1a
700a3b02: e7ff         	b	0x700a3b04 <Udma_rmAllocBlkCopyHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyHcChFlag[offset] &= ~bitMask;
700a3b04: 9a02         	ldr	r2, [sp, #0x8]
700a3b06: 9806         	ldr	r0, [sp, #0x18]
700a3b08: 9904         	ldr	r1, [sp, #0x10]
700a3b0a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3b0e: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700a3b12: 4390         	bics	r0, r2
700a3b14: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;                 chNum = preferredChNum;
700a3b18: 9807         	ldr	r0, [sp, #0x1c]
700a3b1a: 9001         	str	r0, [sp, #0x4]
;             }
700a3b1c: e7ff         	b	0x700a3b1e <Udma_rmAllocBlkCopyHcCh+0x10e> @ imm = #-0x2
;         }
700a3b1e: e7ff         	b	0x700a3b20 <Udma_rmAllocBlkCopyHcCh+0x110> @ imm = #-0x2
700a3b20: e7ff         	b	0x700a3b22 <Udma_rmAllocBlkCopyHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3b22: 9806         	ldr	r0, [sp, #0x18]
700a3b24: f500 609f    	add.w	r0, r0, #0x4f8
700a3b28: f008 f9e2    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x83c4
;     return (chNum);
700a3b2c: 9801         	ldr	r0, [sp, #0x4]
700a3b2e: b008         	add	sp, #0x20
700a3b30: bd80         	pop	{r7, pc}
		...
700a3b3e: 0000         	movs	r0, r0

700a3b40 <Udma_rmAllocBlkCopyUhcCh>:
; {
700a3b40: b580         	push	{r7, lr}
700a3b42: b088         	sub	sp, #0x20
700a3b44: 9007         	str	r0, [sp, #0x1c]
700a3b46: 9106         	str	r1, [sp, #0x18]
700a3b48: 2000         	movs	r0, #0x0
700a3b4a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3b4e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3b50: 9806         	ldr	r0, [sp, #0x18]
700a3b52: f500 70ea    	add.w	r0, r0, #0x1d4
700a3b56: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3b58: 9806         	ldr	r0, [sp, #0x18]
700a3b5a: f500 609f    	add.w	r0, r0, #0x4f8
700a3b5e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3b62: f006 fe35    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x6c6a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3b66: 9807         	ldr	r0, [sp, #0x1c]
700a3b68: 2101         	movs	r1, #0x1
700a3b6a: f6cf 71ff    	movt	r1, #0xffff
700a3b6e: 4288         	cmp	r0, r1
700a3b70: d136         	bne	0x700a3be0 <Udma_rmAllocBlkCopyUhcCh+0xa0> @ imm = #0x6c
700a3b72: e7ff         	b	0x700a3b74 <Udma_rmAllocBlkCopyUhcCh+0x34> @ imm = #-0x2
700a3b74: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a3b76: 9005         	str	r0, [sp, #0x14]
700a3b78: e7ff         	b	0x700a3b7a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x2
700a3b7a: 9805         	ldr	r0, [sp, #0x14]
700a3b7c: 9900         	ldr	r1, [sp]
700a3b7e: 6849         	ldr	r1, [r1, #0x4]
700a3b80: 4288         	cmp	r0, r1
700a3b82: d22c         	bhs	0x700a3bde <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x58
700a3b84: e7ff         	b	0x700a3b86 <Udma_rmAllocBlkCopyUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3b86: 9805         	ldr	r0, [sp, #0x14]
700a3b88: 0940         	lsrs	r0, r0, #0x5
700a3b8a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3b8c: 9805         	ldr	r0, [sp, #0x14]
700a3b8e: 9904         	ldr	r1, [sp, #0x10]
700a3b90: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3b94: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3b96: 9903         	ldr	r1, [sp, #0xc]
700a3b98: 2001         	movs	r0, #0x1
700a3b9a: 4088         	lsls	r0, r1
700a3b9c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a3b9e: 9806         	ldr	r0, [sp, #0x18]
700a3ba0: 9904         	ldr	r1, [sp, #0x10]
700a3ba2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3ba6: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a3baa: 9902         	ldr	r1, [sp, #0x8]
700a3bac: 4008         	ands	r0, r1
700a3bae: 4288         	cmp	r0, r1
700a3bb0: d110         	bne	0x700a3bd4 <Udma_rmAllocBlkCopyUhcCh+0x94> @ imm = #0x20
700a3bb2: e7ff         	b	0x700a3bb4 <Udma_rmAllocBlkCopyUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a3bb4: 9a02         	ldr	r2, [sp, #0x8]
700a3bb6: 9806         	ldr	r0, [sp, #0x18]
700a3bb8: 9904         	ldr	r1, [sp, #0x10]
700a3bba: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3bbe: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a3bc2: 4390         	bics	r0, r2
700a3bc4: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = i + rmInitPrms->startBlkCopyUhcCh;  /* Add start offset */
700a3bc8: 9805         	ldr	r0, [sp, #0x14]
700a3bca: 9900         	ldr	r1, [sp]
700a3bcc: 6809         	ldr	r1, [r1]
700a3bce: 4408         	add	r0, r1
700a3bd0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3bd2: e004         	b	0x700a3bde <Udma_rmAllocBlkCopyUhcCh+0x9e> @ imm = #0x8
;         }
700a3bd4: e7ff         	b	0x700a3bd6 <Udma_rmAllocBlkCopyUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numBlkCopyUhcCh; i++)
700a3bd6: 9805         	ldr	r0, [sp, #0x14]
700a3bd8: 3001         	adds	r0, #0x1
700a3bda: 9005         	str	r0, [sp, #0x14]
700a3bdc: e7cd         	b	0x700a3b7a <Udma_rmAllocBlkCopyUhcCh+0x3a> @ imm = #-0x66
;     }
700a3bde: e038         	b	0x700a3c52 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a3be0: 9807         	ldr	r0, [sp, #0x1c]
700a3be2: 9900         	ldr	r1, [sp]
700a3be4: 6809         	ldr	r1, [r1]
700a3be6: 4288         	cmp	r0, r1
700a3be8: d332         	blo	0x700a3c50 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x64
700a3bea: e7ff         	b	0x700a3bec <Udma_rmAllocBlkCopyUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startBlkCopyUhcCh + rmInitPrms->numBlkCopyUhcCh)))
700a3bec: 9807         	ldr	r0, [sp, #0x1c]
700a3bee: 9a00         	ldr	r2, [sp]
700a3bf0: 6811         	ldr	r1, [r2]
700a3bf2: 6852         	ldr	r2, [r2, #0x4]
700a3bf4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startBlkCopyUhcCh) &&
700a3bf6: 4288         	cmp	r0, r1
700a3bf8: d22a         	bhs	0x700a3c50 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #0x54
700a3bfa: e7ff         	b	0x700a3bfc <Udma_rmAllocBlkCopyUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startBlkCopyUhcCh;
700a3bfc: 9807         	ldr	r0, [sp, #0x1c]
700a3bfe: 9900         	ldr	r1, [sp]
700a3c00: 6809         	ldr	r1, [r1]
700a3c02: 1a40         	subs	r0, r0, r1
700a3c04: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3c06: 9805         	ldr	r0, [sp, #0x14]
700a3c08: 0940         	lsrs	r0, r0, #0x5
700a3c0a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3c0c: 9805         	ldr	r0, [sp, #0x14]
700a3c0e: 9904         	ldr	r1, [sp, #0x10]
700a3c10: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3c14: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3c16: 9903         	ldr	r1, [sp, #0xc]
700a3c18: 2001         	movs	r0, #0x1
700a3c1a: 4088         	lsls	r0, r1
700a3c1c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->blkCopyUhcChFlag[offset] & bitMask) == bitMask)
700a3c1e: 9806         	ldr	r0, [sp, #0x18]
700a3c20: 9904         	ldr	r1, [sp, #0x10]
700a3c22: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3c26: f8d0 02d0    	ldr.w	r0, [r0, #0x2d0]
700a3c2a: 9902         	ldr	r1, [sp, #0x8]
700a3c2c: 4008         	ands	r0, r1
700a3c2e: 4288         	cmp	r0, r1
700a3c30: d10d         	bne	0x700a3c4e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #0x1a
700a3c32: e7ff         	b	0x700a3c34 <Udma_rmAllocBlkCopyUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->blkCopyUhcChFlag[offset] &= ~bitMask;
700a3c34: 9a02         	ldr	r2, [sp, #0x8]
700a3c36: 9806         	ldr	r0, [sp, #0x18]
700a3c38: 9904         	ldr	r1, [sp, #0x10]
700a3c3a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3c3e: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700a3c42: 4390         	bics	r0, r2
700a3c44: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;                 chNum = preferredChNum;
700a3c48: 9807         	ldr	r0, [sp, #0x1c]
700a3c4a: 9001         	str	r0, [sp, #0x4]
;             }
700a3c4c: e7ff         	b	0x700a3c4e <Udma_rmAllocBlkCopyUhcCh+0x10e> @ imm = #-0x2
;         }
700a3c4e: e7ff         	b	0x700a3c50 <Udma_rmAllocBlkCopyUhcCh+0x110> @ imm = #-0x2
700a3c50: e7ff         	b	0x700a3c52 <Udma_rmAllocBlkCopyUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3c52: 9806         	ldr	r0, [sp, #0x18]
700a3c54: f500 609f    	add.w	r0, r0, #0x4f8
700a3c58: f008 f94a    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x8294
;     return (chNum);
700a3c5c: 9801         	ldr	r0, [sp, #0x4]
700a3c5e: b008         	add	sp, #0x20
700a3c60: bd80         	pop	{r7, pc}
		...
700a3c6e: 0000         	movs	r0, r0

700a3c70 <Udma_rmAllocRxCh>:
; {
700a3c70: b580         	push	{r7, lr}
700a3c72: b088         	sub	sp, #0x20
700a3c74: 9007         	str	r0, [sp, #0x1c]
700a3c76: 9106         	str	r1, [sp, #0x18]
700a3c78: 2000         	movs	r0, #0x0
700a3c7a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3c7e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3c80: 9806         	ldr	r0, [sp, #0x18]
700a3c82: f500 70ea    	add.w	r0, r0, #0x1d4
700a3c86: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3c88: 9806         	ldr	r0, [sp, #0x18]
700a3c8a: f500 609f    	add.w	r0, r0, #0x4f8
700a3c8e: f04f 31ff    	mov.w	r1, #0xffffffff
700a3c92: f006 fd9d    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x6b3a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3c96: 9807         	ldr	r0, [sp, #0x1c]
700a3c98: 2101         	movs	r1, #0x1
700a3c9a: f6cf 71ff    	movt	r1, #0xffff
700a3c9e: 4288         	cmp	r0, r1
700a3ca0: d136         	bne	0x700a3d10 <Udma_rmAllocRxCh+0xa0> @ imm = #0x6c
700a3ca2: e7ff         	b	0x700a3ca4 <Udma_rmAllocRxCh+0x34> @ imm = #-0x2
700a3ca4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a3ca6: 9005         	str	r0, [sp, #0x14]
700a3ca8: e7ff         	b	0x700a3caa <Udma_rmAllocRxCh+0x3a> @ imm = #-0x2
700a3caa: 9805         	ldr	r0, [sp, #0x14]
700a3cac: 9900         	ldr	r1, [sp]
700a3cae: 6c49         	ldr	r1, [r1, #0x44]
700a3cb0: 4288         	cmp	r0, r1
700a3cb2: d22c         	bhs	0x700a3d0e <Udma_rmAllocRxCh+0x9e> @ imm = #0x58
700a3cb4: e7ff         	b	0x700a3cb6 <Udma_rmAllocRxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3cb6: 9805         	ldr	r0, [sp, #0x14]
700a3cb8: 0940         	lsrs	r0, r0, #0x5
700a3cba: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3cbc: 9805         	ldr	r0, [sp, #0x14]
700a3cbe: 9904         	ldr	r1, [sp, #0x10]
700a3cc0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3cc4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3cc6: 9903         	ldr	r1, [sp, #0xc]
700a3cc8: 2001         	movs	r0, #0x1
700a3cca: 4088         	lsls	r0, r1
700a3ccc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a3cce: 9806         	ldr	r0, [sp, #0x18]
700a3cd0: 9904         	ldr	r1, [sp, #0x10]
700a3cd2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3cd6: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a3cda: 9902         	ldr	r1, [sp, #0x8]
700a3cdc: 4008         	ands	r0, r1
700a3cde: 4288         	cmp	r0, r1
700a3ce0: d110         	bne	0x700a3d04 <Udma_rmAllocRxCh+0x94> @ imm = #0x20
700a3ce2: e7ff         	b	0x700a3ce4 <Udma_rmAllocRxCh+0x74> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a3ce4: 9a02         	ldr	r2, [sp, #0x8]
700a3ce6: 9806         	ldr	r0, [sp, #0x18]
700a3ce8: 9904         	ldr	r1, [sp, #0x10]
700a3cea: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3cee: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a3cf2: 4390         	bics	r0, r2
700a3cf4: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = i + rmInitPrms->startRxCh;  /* Add start offset */
700a3cf8: 9805         	ldr	r0, [sp, #0x14]
700a3cfa: 9900         	ldr	r1, [sp]
700a3cfc: 6c09         	ldr	r1, [r1, #0x40]
700a3cfe: 4408         	add	r0, r1
700a3d00: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3d02: e004         	b	0x700a3d0e <Udma_rmAllocRxCh+0x9e> @ imm = #0x8
;         }
700a3d04: e7ff         	b	0x700a3d06 <Udma_rmAllocRxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxCh; i++)
700a3d06: 9805         	ldr	r0, [sp, #0x14]
700a3d08: 3001         	adds	r0, #0x1
700a3d0a: 9005         	str	r0, [sp, #0x14]
700a3d0c: e7cd         	b	0x700a3caa <Udma_rmAllocRxCh+0x3a> @ imm = #-0x66
;     }
700a3d0e: e038         	b	0x700a3d82 <Udma_rmAllocRxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a3d10: 9807         	ldr	r0, [sp, #0x1c]
700a3d12: 9900         	ldr	r1, [sp]
700a3d14: 6c09         	ldr	r1, [r1, #0x40]
700a3d16: 4288         	cmp	r0, r1
700a3d18: d332         	blo	0x700a3d80 <Udma_rmAllocRxCh+0x110> @ imm = #0x64
700a3d1a: e7ff         	b	0x700a3d1c <Udma_rmAllocRxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxCh + rmInitPrms->numRxCh)))
700a3d1c: 9807         	ldr	r0, [sp, #0x1c]
700a3d1e: 9a00         	ldr	r2, [sp]
700a3d20: 6c11         	ldr	r1, [r2, #0x40]
700a3d22: 6c52         	ldr	r2, [r2, #0x44]
700a3d24: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxCh) &&
700a3d26: 4288         	cmp	r0, r1
700a3d28: d22a         	bhs	0x700a3d80 <Udma_rmAllocRxCh+0x110> @ imm = #0x54
700a3d2a: e7ff         	b	0x700a3d2c <Udma_rmAllocRxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxCh;
700a3d2c: 9807         	ldr	r0, [sp, #0x1c]
700a3d2e: 9900         	ldr	r1, [sp]
700a3d30: 6c09         	ldr	r1, [r1, #0x40]
700a3d32: 1a40         	subs	r0, r0, r1
700a3d34: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3d36: 9805         	ldr	r0, [sp, #0x14]
700a3d38: 0940         	lsrs	r0, r0, #0x5
700a3d3a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3d3c: 9805         	ldr	r0, [sp, #0x14]
700a3d3e: 9904         	ldr	r1, [sp, #0x10]
700a3d40: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3d44: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3d46: 9903         	ldr	r1, [sp, #0xc]
700a3d48: 2001         	movs	r0, #0x1
700a3d4a: 4088         	lsls	r0, r1
700a3d4c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxChFlag[offset] & bitMask) == bitMask)
700a3d4e: 9806         	ldr	r0, [sp, #0x18]
700a3d50: 9904         	ldr	r1, [sp, #0x10]
700a3d52: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3d56: f8d0 02fc    	ldr.w	r0, [r0, #0x2fc]
700a3d5a: 9902         	ldr	r1, [sp, #0x8]
700a3d5c: 4008         	ands	r0, r1
700a3d5e: 4288         	cmp	r0, r1
700a3d60: d10d         	bne	0x700a3d7e <Udma_rmAllocRxCh+0x10e> @ imm = #0x1a
700a3d62: e7ff         	b	0x700a3d64 <Udma_rmAllocRxCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxChFlag[offset] &= ~bitMask;
700a3d64: 9a02         	ldr	r2, [sp, #0x8]
700a3d66: 9806         	ldr	r0, [sp, #0x18]
700a3d68: 9904         	ldr	r1, [sp, #0x10]
700a3d6a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3d6e: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700a3d72: 4390         	bics	r0, r2
700a3d74: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;                 chNum = preferredChNum;
700a3d78: 9807         	ldr	r0, [sp, #0x1c]
700a3d7a: 9001         	str	r0, [sp, #0x4]
;             }
700a3d7c: e7ff         	b	0x700a3d7e <Udma_rmAllocRxCh+0x10e> @ imm = #-0x2
;         }
700a3d7e: e7ff         	b	0x700a3d80 <Udma_rmAllocRxCh+0x110> @ imm = #-0x2
700a3d80: e7ff         	b	0x700a3d82 <Udma_rmAllocRxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3d82: 9806         	ldr	r0, [sp, #0x18]
700a3d84: f500 609f    	add.w	r0, r0, #0x4f8
700a3d88: f008 f8b2    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x8164
;     return (chNum);
700a3d8c: 9801         	ldr	r0, [sp, #0x4]
700a3d8e: b008         	add	sp, #0x20
700a3d90: bd80         	pop	{r7, pc}
		...
700a3d9e: 0000         	movs	r0, r0

700a3da0 <Udma_rmAllocRxHcCh>:
; {
700a3da0: b580         	push	{r7, lr}
700a3da2: b088         	sub	sp, #0x20
700a3da4: 9007         	str	r0, [sp, #0x1c]
700a3da6: 9106         	str	r1, [sp, #0x18]
700a3da8: 2000         	movs	r0, #0x0
700a3daa: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3dae: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3db0: 9806         	ldr	r0, [sp, #0x18]
700a3db2: f500 70ea    	add.w	r0, r0, #0x1d4
700a3db6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3db8: 9806         	ldr	r0, [sp, #0x18]
700a3dba: f500 609f    	add.w	r0, r0, #0x4f8
700a3dbe: f04f 31ff    	mov.w	r1, #0xffffffff
700a3dc2: f006 fd05    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x6a0a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3dc6: 9807         	ldr	r0, [sp, #0x1c]
700a3dc8: 2101         	movs	r1, #0x1
700a3dca: f6cf 71ff    	movt	r1, #0xffff
700a3dce: 4288         	cmp	r0, r1
700a3dd0: d136         	bne	0x700a3e40 <Udma_rmAllocRxHcCh+0xa0> @ imm = #0x6c
700a3dd2: e7ff         	b	0x700a3dd4 <Udma_rmAllocRxHcCh+0x34> @ imm = #-0x2
700a3dd4: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a3dd6: 9005         	str	r0, [sp, #0x14]
700a3dd8: e7ff         	b	0x700a3dda <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x2
700a3dda: 9805         	ldr	r0, [sp, #0x14]
700a3ddc: 9900         	ldr	r1, [sp]
700a3dde: 6bc9         	ldr	r1, [r1, #0x3c]
700a3de0: 4288         	cmp	r0, r1
700a3de2: d22c         	bhs	0x700a3e3e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x58
700a3de4: e7ff         	b	0x700a3de6 <Udma_rmAllocRxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3de6: 9805         	ldr	r0, [sp, #0x14]
700a3de8: 0940         	lsrs	r0, r0, #0x5
700a3dea: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3dec: 9805         	ldr	r0, [sp, #0x14]
700a3dee: 9904         	ldr	r1, [sp, #0x10]
700a3df0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3df4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3df6: 9903         	ldr	r1, [sp, #0xc]
700a3df8: 2001         	movs	r0, #0x1
700a3dfa: 4088         	lsls	r0, r1
700a3dfc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a3dfe: 9806         	ldr	r0, [sp, #0x18]
700a3e00: 9904         	ldr	r1, [sp, #0x10]
700a3e02: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3e06: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a3e0a: 9902         	ldr	r1, [sp, #0x8]
700a3e0c: 4008         	ands	r0, r1
700a3e0e: 4288         	cmp	r0, r1
700a3e10: d110         	bne	0x700a3e34 <Udma_rmAllocRxHcCh+0x94> @ imm = #0x20
700a3e12: e7ff         	b	0x700a3e14 <Udma_rmAllocRxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a3e14: 9a02         	ldr	r2, [sp, #0x8]
700a3e16: 9806         	ldr	r0, [sp, #0x18]
700a3e18: 9904         	ldr	r1, [sp, #0x10]
700a3e1a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3e1e: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a3e22: 4390         	bics	r0, r2
700a3e24: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = i + rmInitPrms->startRxHcCh;  /* Add start offset */
700a3e28: 9805         	ldr	r0, [sp, #0x14]
700a3e2a: 9900         	ldr	r1, [sp]
700a3e2c: 6b89         	ldr	r1, [r1, #0x38]
700a3e2e: 4408         	add	r0, r1
700a3e30: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3e32: e004         	b	0x700a3e3e <Udma_rmAllocRxHcCh+0x9e> @ imm = #0x8
;         }
700a3e34: e7ff         	b	0x700a3e36 <Udma_rmAllocRxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxHcCh; i++)
700a3e36: 9805         	ldr	r0, [sp, #0x14]
700a3e38: 3001         	adds	r0, #0x1
700a3e3a: 9005         	str	r0, [sp, #0x14]
700a3e3c: e7cd         	b	0x700a3dda <Udma_rmAllocRxHcCh+0x3a> @ imm = #-0x66
;     }
700a3e3e: e038         	b	0x700a3eb2 <Udma_rmAllocRxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a3e40: 9807         	ldr	r0, [sp, #0x1c]
700a3e42: 9900         	ldr	r1, [sp]
700a3e44: 6b89         	ldr	r1, [r1, #0x38]
700a3e46: 4288         	cmp	r0, r1
700a3e48: d332         	blo	0x700a3eb0 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x64
700a3e4a: e7ff         	b	0x700a3e4c <Udma_rmAllocRxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxHcCh + rmInitPrms->numRxHcCh)))
700a3e4c: 9807         	ldr	r0, [sp, #0x1c]
700a3e4e: 9a00         	ldr	r2, [sp]
700a3e50: 6b91         	ldr	r1, [r2, #0x38]
700a3e52: 6bd2         	ldr	r2, [r2, #0x3c]
700a3e54: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxHcCh) &&
700a3e56: 4288         	cmp	r0, r1
700a3e58: d22a         	bhs	0x700a3eb0 <Udma_rmAllocRxHcCh+0x110> @ imm = #0x54
700a3e5a: e7ff         	b	0x700a3e5c <Udma_rmAllocRxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxHcCh;
700a3e5c: 9807         	ldr	r0, [sp, #0x1c]
700a3e5e: 9900         	ldr	r1, [sp]
700a3e60: 6b89         	ldr	r1, [r1, #0x38]
700a3e62: 1a40         	subs	r0, r0, r1
700a3e64: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3e66: 9805         	ldr	r0, [sp, #0x14]
700a3e68: 0940         	lsrs	r0, r0, #0x5
700a3e6a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3e6c: 9805         	ldr	r0, [sp, #0x14]
700a3e6e: 9904         	ldr	r1, [sp, #0x10]
700a3e70: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3e74: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3e76: 9903         	ldr	r1, [sp, #0xc]
700a3e78: 2001         	movs	r0, #0x1
700a3e7a: 4088         	lsls	r0, r1
700a3e7c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxHcChFlag[offset] & bitMask) == bitMask)
700a3e7e: 9806         	ldr	r0, [sp, #0x18]
700a3e80: 9904         	ldr	r1, [sp, #0x10]
700a3e82: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3e86: f8d0 031c    	ldr.w	r0, [r0, #0x31c]
700a3e8a: 9902         	ldr	r1, [sp, #0x8]
700a3e8c: 4008         	ands	r0, r1
700a3e8e: 4288         	cmp	r0, r1
700a3e90: d10d         	bne	0x700a3eae <Udma_rmAllocRxHcCh+0x10e> @ imm = #0x1a
700a3e92: e7ff         	b	0x700a3e94 <Udma_rmAllocRxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxHcChFlag[offset] &= ~bitMask;
700a3e94: 9a02         	ldr	r2, [sp, #0x8]
700a3e96: 9806         	ldr	r0, [sp, #0x18]
700a3e98: 9904         	ldr	r1, [sp, #0x10]
700a3e9a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3e9e: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700a3ea2: 4390         	bics	r0, r2
700a3ea4: f8c1 031c    	str.w	r0, [r1, #0x31c]
;                 chNum = preferredChNum;
700a3ea8: 9807         	ldr	r0, [sp, #0x1c]
700a3eaa: 9001         	str	r0, [sp, #0x4]
;             }
700a3eac: e7ff         	b	0x700a3eae <Udma_rmAllocRxHcCh+0x10e> @ imm = #-0x2
;         }
700a3eae: e7ff         	b	0x700a3eb0 <Udma_rmAllocRxHcCh+0x110> @ imm = #-0x2
700a3eb0: e7ff         	b	0x700a3eb2 <Udma_rmAllocRxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3eb2: 9806         	ldr	r0, [sp, #0x18]
700a3eb4: f500 609f    	add.w	r0, r0, #0x4f8
700a3eb8: f008 f81a    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x8034
;     return (chNum);
700a3ebc: 9801         	ldr	r0, [sp, #0x4]
700a3ebe: b008         	add	sp, #0x20
700a3ec0: bd80         	pop	{r7, pc}
		...
700a3ece: 0000         	movs	r0, r0

700a3ed0 <Udma_rmAllocRxUhcCh>:
; {
700a3ed0: b580         	push	{r7, lr}
700a3ed2: b088         	sub	sp, #0x20
700a3ed4: 9007         	str	r0, [sp, #0x1c]
700a3ed6: 9106         	str	r1, [sp, #0x18]
700a3ed8: 2000         	movs	r0, #0x0
700a3eda: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a3ede: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a3ee0: 9806         	ldr	r0, [sp, #0x18]
700a3ee2: f500 70ea    	add.w	r0, r0, #0x1d4
700a3ee6: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a3ee8: 9806         	ldr	r0, [sp, #0x18]
700a3eea: f500 609f    	add.w	r0, r0, #0x4f8
700a3eee: f04f 31ff    	mov.w	r1, #0xffffffff
700a3ef2: f006 fc6d    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x68da
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a3ef6: 9807         	ldr	r0, [sp, #0x1c]
700a3ef8: 2101         	movs	r1, #0x1
700a3efa: f6cf 71ff    	movt	r1, #0xffff
700a3efe: 4288         	cmp	r0, r1
700a3f00: d136         	bne	0x700a3f70 <Udma_rmAllocRxUhcCh+0xa0> @ imm = #0x6c
700a3f02: e7ff         	b	0x700a3f04 <Udma_rmAllocRxUhcCh+0x34> @ imm = #-0x2
700a3f04: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a3f06: 9005         	str	r0, [sp, #0x14]
700a3f08: e7ff         	b	0x700a3f0a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x2
700a3f0a: 9805         	ldr	r0, [sp, #0x14]
700a3f0c: 9900         	ldr	r1, [sp]
700a3f0e: 6b49         	ldr	r1, [r1, #0x34]
700a3f10: 4288         	cmp	r0, r1
700a3f12: d22c         	bhs	0x700a3f6e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x58
700a3f14: e7ff         	b	0x700a3f16 <Udma_rmAllocRxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a3f16: 9805         	ldr	r0, [sp, #0x14]
700a3f18: 0940         	lsrs	r0, r0, #0x5
700a3f1a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3f1c: 9805         	ldr	r0, [sp, #0x14]
700a3f1e: 9904         	ldr	r1, [sp, #0x10]
700a3f20: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3f24: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3f26: 9903         	ldr	r1, [sp, #0xc]
700a3f28: 2001         	movs	r0, #0x1
700a3f2a: 4088         	lsls	r0, r1
700a3f2c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a3f2e: 9806         	ldr	r0, [sp, #0x18]
700a3f30: 9904         	ldr	r1, [sp, #0x10]
700a3f32: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3f36: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a3f3a: 9902         	ldr	r1, [sp, #0x8]
700a3f3c: 4008         	ands	r0, r1
700a3f3e: 4288         	cmp	r0, r1
700a3f40: d110         	bne	0x700a3f64 <Udma_rmAllocRxUhcCh+0x94> @ imm = #0x20
700a3f42: e7ff         	b	0x700a3f44 <Udma_rmAllocRxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a3f44: 9a02         	ldr	r2, [sp, #0x8]
700a3f46: 9806         	ldr	r0, [sp, #0x18]
700a3f48: 9904         	ldr	r1, [sp, #0x10]
700a3f4a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3f4e: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a3f52: 4390         	bics	r0, r2
700a3f54: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = i + rmInitPrms->startRxUhcCh;  /* Add start offset */
700a3f58: 9805         	ldr	r0, [sp, #0x14]
700a3f5a: 9900         	ldr	r1, [sp]
700a3f5c: 6b09         	ldr	r1, [r1, #0x30]
700a3f5e: 4408         	add	r0, r1
700a3f60: 9001         	str	r0, [sp, #0x4]
;                 break;
700a3f62: e004         	b	0x700a3f6e <Udma_rmAllocRxUhcCh+0x9e> @ imm = #0x8
;         }
700a3f64: e7ff         	b	0x700a3f66 <Udma_rmAllocRxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numRxUhcCh; i++)
700a3f66: 9805         	ldr	r0, [sp, #0x14]
700a3f68: 3001         	adds	r0, #0x1
700a3f6a: 9005         	str	r0, [sp, #0x14]
700a3f6c: e7cd         	b	0x700a3f0a <Udma_rmAllocRxUhcCh+0x3a> @ imm = #-0x66
;     }
700a3f6e: e038         	b	0x700a3fe2 <Udma_rmAllocRxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a3f70: 9807         	ldr	r0, [sp, #0x1c]
700a3f72: 9900         	ldr	r1, [sp]
700a3f74: 6b09         	ldr	r1, [r1, #0x30]
700a3f76: 4288         	cmp	r0, r1
700a3f78: d332         	blo	0x700a3fe0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x64
700a3f7a: e7ff         	b	0x700a3f7c <Udma_rmAllocRxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startRxUhcCh + rmInitPrms->numRxUhcCh)))
700a3f7c: 9807         	ldr	r0, [sp, #0x1c]
700a3f7e: 9a00         	ldr	r2, [sp]
700a3f80: 6b11         	ldr	r1, [r2, #0x30]
700a3f82: 6b52         	ldr	r2, [r2, #0x34]
700a3f84: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startRxUhcCh) &&
700a3f86: 4288         	cmp	r0, r1
700a3f88: d22a         	bhs	0x700a3fe0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #0x54
700a3f8a: e7ff         	b	0x700a3f8c <Udma_rmAllocRxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startRxUhcCh;
700a3f8c: 9807         	ldr	r0, [sp, #0x1c]
700a3f8e: 9900         	ldr	r1, [sp]
700a3f90: 6b09         	ldr	r1, [r1, #0x30]
700a3f92: 1a40         	subs	r0, r0, r1
700a3f94: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a3f96: 9805         	ldr	r0, [sp, #0x14]
700a3f98: 0940         	lsrs	r0, r0, #0x5
700a3f9a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a3f9c: 9805         	ldr	r0, [sp, #0x14]
700a3f9e: 9904         	ldr	r1, [sp, #0x10]
700a3fa0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a3fa4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a3fa6: 9903         	ldr	r1, [sp, #0xc]
700a3fa8: 2001         	movs	r0, #0x1
700a3faa: 4088         	lsls	r0, r1
700a3fac: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->rxUhcChFlag[offset] & bitMask) == bitMask)
700a3fae: 9806         	ldr	r0, [sp, #0x18]
700a3fb0: 9904         	ldr	r1, [sp, #0x10]
700a3fb2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a3fb6: f8d0 0320    	ldr.w	r0, [r0, #0x320]
700a3fba: 9902         	ldr	r1, [sp, #0x8]
700a3fbc: 4008         	ands	r0, r1
700a3fbe: 4288         	cmp	r0, r1
700a3fc0: d10d         	bne	0x700a3fde <Udma_rmAllocRxUhcCh+0x10e> @ imm = #0x1a
700a3fc2: e7ff         	b	0x700a3fc4 <Udma_rmAllocRxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->rxUhcChFlag[offset] &= ~bitMask;
700a3fc4: 9a02         	ldr	r2, [sp, #0x8]
700a3fc6: 9806         	ldr	r0, [sp, #0x18]
700a3fc8: 9904         	ldr	r1, [sp, #0x10]
700a3fca: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a3fce: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700a3fd2: 4390         	bics	r0, r2
700a3fd4: f8c1 0320    	str.w	r0, [r1, #0x320]
;                 chNum = preferredChNum;
700a3fd8: 9807         	ldr	r0, [sp, #0x1c]
700a3fda: 9001         	str	r0, [sp, #0x4]
;             }
700a3fdc: e7ff         	b	0x700a3fde <Udma_rmAllocRxUhcCh+0x10e> @ imm = #-0x2
;         }
700a3fde: e7ff         	b	0x700a3fe0 <Udma_rmAllocRxUhcCh+0x110> @ imm = #-0x2
700a3fe0: e7ff         	b	0x700a3fe2 <Udma_rmAllocRxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a3fe2: 9806         	ldr	r0, [sp, #0x18]
700a3fe4: f500 609f    	add.w	r0, r0, #0x4f8
700a3fe8: f007 ff82    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x7f04
;     return (chNum);
700a3fec: 9801         	ldr	r0, [sp, #0x4]
700a3fee: b008         	add	sp, #0x20
700a3ff0: bd80         	pop	{r7, pc}
		...
700a3ffe: 0000         	movs	r0, r0

700a4000 <Udma_rmAllocTxCh>:
; {
700a4000: b580         	push	{r7, lr}
700a4002: b088         	sub	sp, #0x20
700a4004: 9007         	str	r0, [sp, #0x1c]
700a4006: 9106         	str	r1, [sp, #0x18]
700a4008: 2000         	movs	r0, #0x0
700a400a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a400e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a4010: 9806         	ldr	r0, [sp, #0x18]
700a4012: f500 70ea    	add.w	r0, r0, #0x1d4
700a4016: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a4018: 9806         	ldr	r0, [sp, #0x18]
700a401a: f500 609f    	add.w	r0, r0, #0x4f8
700a401e: f04f 31ff    	mov.w	r1, #0xffffffff
700a4022: f006 fbd5    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x67aa
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a4026: 9807         	ldr	r0, [sp, #0x1c]
700a4028: 2101         	movs	r1, #0x1
700a402a: f6cf 71ff    	movt	r1, #0xffff
700a402e: 4288         	cmp	r0, r1
700a4030: d136         	bne	0x700a40a0 <Udma_rmAllocTxCh+0xa0> @ imm = #0x6c
700a4032: e7ff         	b	0x700a4034 <Udma_rmAllocTxCh+0x34> @ imm = #-0x2
700a4034: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a4036: 9005         	str	r0, [sp, #0x14]
700a4038: e7ff         	b	0x700a403a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x2
700a403a: 9805         	ldr	r0, [sp, #0x14]
700a403c: 9900         	ldr	r1, [sp]
700a403e: 6ac9         	ldr	r1, [r1, #0x2c]
700a4040: 4288         	cmp	r0, r1
700a4042: d22c         	bhs	0x700a409e <Udma_rmAllocTxCh+0x9e> @ imm = #0x58
700a4044: e7ff         	b	0x700a4046 <Udma_rmAllocTxCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a4046: 9805         	ldr	r0, [sp, #0x14]
700a4048: 0940         	lsrs	r0, r0, #0x5
700a404a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a404c: 9805         	ldr	r0, [sp, #0x14]
700a404e: 9904         	ldr	r1, [sp, #0x10]
700a4050: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4054: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4056: 9903         	ldr	r1, [sp, #0xc]
700a4058: 2001         	movs	r0, #0x1
700a405a: 4088         	lsls	r0, r1
700a405c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a405e: 9806         	ldr	r0, [sp, #0x18]
700a4060: 9904         	ldr	r1, [sp, #0x10]
700a4062: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4066: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a406a: 9902         	ldr	r1, [sp, #0x8]
700a406c: 4008         	ands	r0, r1
700a406e: 4288         	cmp	r0, r1
700a4070: d110         	bne	0x700a4094 <Udma_rmAllocTxCh+0x94> @ imm = #0x20
700a4072: e7ff         	b	0x700a4074 <Udma_rmAllocTxCh+0x74> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a4074: 9a02         	ldr	r2, [sp, #0x8]
700a4076: 9806         	ldr	r0, [sp, #0x18]
700a4078: 9904         	ldr	r1, [sp, #0x10]
700a407a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a407e: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a4082: 4390         	bics	r0, r2
700a4084: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = i + rmInitPrms->startTxCh;  /* Add start offset */
700a4088: 9805         	ldr	r0, [sp, #0x14]
700a408a: 9900         	ldr	r1, [sp]
700a408c: 6a89         	ldr	r1, [r1, #0x28]
700a408e: 4408         	add	r0, r1
700a4090: 9001         	str	r0, [sp, #0x4]
;                 break;
700a4092: e004         	b	0x700a409e <Udma_rmAllocTxCh+0x9e> @ imm = #0x8
;         }
700a4094: e7ff         	b	0x700a4096 <Udma_rmAllocTxCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxCh; i++)
700a4096: 9805         	ldr	r0, [sp, #0x14]
700a4098: 3001         	adds	r0, #0x1
700a409a: 9005         	str	r0, [sp, #0x14]
700a409c: e7cd         	b	0x700a403a <Udma_rmAllocTxCh+0x3a> @ imm = #-0x66
;     }
700a409e: e038         	b	0x700a4112 <Udma_rmAllocTxCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a40a0: 9807         	ldr	r0, [sp, #0x1c]
700a40a2: 9900         	ldr	r1, [sp]
700a40a4: 6a89         	ldr	r1, [r1, #0x28]
700a40a6: 4288         	cmp	r0, r1
700a40a8: d332         	blo	0x700a4110 <Udma_rmAllocTxCh+0x110> @ imm = #0x64
700a40aa: e7ff         	b	0x700a40ac <Udma_rmAllocTxCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxCh + rmInitPrms->numTxCh)))
700a40ac: 9807         	ldr	r0, [sp, #0x1c]
700a40ae: 9a00         	ldr	r2, [sp]
700a40b0: 6a91         	ldr	r1, [r2, #0x28]
700a40b2: 6ad2         	ldr	r2, [r2, #0x2c]
700a40b4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxCh) &&
700a40b6: 4288         	cmp	r0, r1
700a40b8: d22a         	bhs	0x700a4110 <Udma_rmAllocTxCh+0x110> @ imm = #0x54
700a40ba: e7ff         	b	0x700a40bc <Udma_rmAllocTxCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxCh;
700a40bc: 9807         	ldr	r0, [sp, #0x1c]
700a40be: 9900         	ldr	r1, [sp]
700a40c0: 6a89         	ldr	r1, [r1, #0x28]
700a40c2: 1a40         	subs	r0, r0, r1
700a40c4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a40c6: 9805         	ldr	r0, [sp, #0x14]
700a40c8: 0940         	lsrs	r0, r0, #0x5
700a40ca: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a40cc: 9805         	ldr	r0, [sp, #0x14]
700a40ce: 9904         	ldr	r1, [sp, #0x10]
700a40d0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a40d4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a40d6: 9903         	ldr	r1, [sp, #0xc]
700a40d8: 2001         	movs	r0, #0x1
700a40da: 4088         	lsls	r0, r1
700a40dc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txChFlag[offset] & bitMask) == bitMask)
700a40de: 9806         	ldr	r0, [sp, #0x18]
700a40e0: 9904         	ldr	r1, [sp, #0x10]
700a40e2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a40e6: f8d0 02d4    	ldr.w	r0, [r0, #0x2d4]
700a40ea: 9902         	ldr	r1, [sp, #0x8]
700a40ec: 4008         	ands	r0, r1
700a40ee: 4288         	cmp	r0, r1
700a40f0: d10d         	bne	0x700a410e <Udma_rmAllocTxCh+0x10e> @ imm = #0x1a
700a40f2: e7ff         	b	0x700a40f4 <Udma_rmAllocTxCh+0xf4> @ imm = #-0x2
;                 drvHandle->txChFlag[offset] &= ~bitMask;
700a40f4: 9a02         	ldr	r2, [sp, #0x8]
700a40f6: 9806         	ldr	r0, [sp, #0x18]
700a40f8: 9904         	ldr	r1, [sp, #0x10]
700a40fa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a40fe: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700a4102: 4390         	bics	r0, r2
700a4104: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;                 chNum = preferredChNum;
700a4108: 9807         	ldr	r0, [sp, #0x1c]
700a410a: 9001         	str	r0, [sp, #0x4]
;             }
700a410c: e7ff         	b	0x700a410e <Udma_rmAllocTxCh+0x10e> @ imm = #-0x2
;         }
700a410e: e7ff         	b	0x700a4110 <Udma_rmAllocTxCh+0x110> @ imm = #-0x2
700a4110: e7ff         	b	0x700a4112 <Udma_rmAllocTxCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a4112: 9806         	ldr	r0, [sp, #0x18]
700a4114: f500 609f    	add.w	r0, r0, #0x4f8
700a4118: f007 feea    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x7dd4
;     return (chNum);
700a411c: 9801         	ldr	r0, [sp, #0x4]
700a411e: b008         	add	sp, #0x20
700a4120: bd80         	pop	{r7, pc}
		...
700a412e: 0000         	movs	r0, r0

700a4130 <Udma_rmAllocTxHcCh>:
; {
700a4130: b580         	push	{r7, lr}
700a4132: b088         	sub	sp, #0x20
700a4134: 9007         	str	r0, [sp, #0x1c]
700a4136: 9106         	str	r1, [sp, #0x18]
700a4138: 2000         	movs	r0, #0x0
700a413a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a413e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a4140: 9806         	ldr	r0, [sp, #0x18]
700a4142: f500 70ea    	add.w	r0, r0, #0x1d4
700a4146: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a4148: 9806         	ldr	r0, [sp, #0x18]
700a414a: f500 609f    	add.w	r0, r0, #0x4f8
700a414e: f04f 31ff    	mov.w	r1, #0xffffffff
700a4152: f006 fb3d    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x667a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a4156: 9807         	ldr	r0, [sp, #0x1c]
700a4158: 2101         	movs	r1, #0x1
700a415a: f6cf 71ff    	movt	r1, #0xffff
700a415e: 4288         	cmp	r0, r1
700a4160: d136         	bne	0x700a41d0 <Udma_rmAllocTxHcCh+0xa0> @ imm = #0x6c
700a4162: e7ff         	b	0x700a4164 <Udma_rmAllocTxHcCh+0x34> @ imm = #-0x2
700a4164: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a4166: 9005         	str	r0, [sp, #0x14]
700a4168: e7ff         	b	0x700a416a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x2
700a416a: 9805         	ldr	r0, [sp, #0x14]
700a416c: 9900         	ldr	r1, [sp]
700a416e: 6a49         	ldr	r1, [r1, #0x24]
700a4170: 4288         	cmp	r0, r1
700a4172: d22c         	bhs	0x700a41ce <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x58
700a4174: e7ff         	b	0x700a4176 <Udma_rmAllocTxHcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a4176: 9805         	ldr	r0, [sp, #0x14]
700a4178: 0940         	lsrs	r0, r0, #0x5
700a417a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a417c: 9805         	ldr	r0, [sp, #0x14]
700a417e: 9904         	ldr	r1, [sp, #0x10]
700a4180: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4184: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4186: 9903         	ldr	r1, [sp, #0xc]
700a4188: 2001         	movs	r0, #0x1
700a418a: 4088         	lsls	r0, r1
700a418c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a418e: 9806         	ldr	r0, [sp, #0x18]
700a4190: 9904         	ldr	r1, [sp, #0x10]
700a4192: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4196: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a419a: 9902         	ldr	r1, [sp, #0x8]
700a419c: 4008         	ands	r0, r1
700a419e: 4288         	cmp	r0, r1
700a41a0: d110         	bne	0x700a41c4 <Udma_rmAllocTxHcCh+0x94> @ imm = #0x20
700a41a2: e7ff         	b	0x700a41a4 <Udma_rmAllocTxHcCh+0x74> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a41a4: 9a02         	ldr	r2, [sp, #0x8]
700a41a6: 9806         	ldr	r0, [sp, #0x18]
700a41a8: 9904         	ldr	r1, [sp, #0x10]
700a41aa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a41ae: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a41b2: 4390         	bics	r0, r2
700a41b4: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = i + rmInitPrms->startTxHcCh;  /* Add start offset */
700a41b8: 9805         	ldr	r0, [sp, #0x14]
700a41ba: 9900         	ldr	r1, [sp]
700a41bc: 6a09         	ldr	r1, [r1, #0x20]
700a41be: 4408         	add	r0, r1
700a41c0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a41c2: e004         	b	0x700a41ce <Udma_rmAllocTxHcCh+0x9e> @ imm = #0x8
;         }
700a41c4: e7ff         	b	0x700a41c6 <Udma_rmAllocTxHcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxHcCh; i++)
700a41c6: 9805         	ldr	r0, [sp, #0x14]
700a41c8: 3001         	adds	r0, #0x1
700a41ca: 9005         	str	r0, [sp, #0x14]
700a41cc: e7cd         	b	0x700a416a <Udma_rmAllocTxHcCh+0x3a> @ imm = #-0x66
;     }
700a41ce: e038         	b	0x700a4242 <Udma_rmAllocTxHcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a41d0: 9807         	ldr	r0, [sp, #0x1c]
700a41d2: 9900         	ldr	r1, [sp]
700a41d4: 6a09         	ldr	r1, [r1, #0x20]
700a41d6: 4288         	cmp	r0, r1
700a41d8: d332         	blo	0x700a4240 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x64
700a41da: e7ff         	b	0x700a41dc <Udma_rmAllocTxHcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxHcCh + rmInitPrms->numTxHcCh)))
700a41dc: 9807         	ldr	r0, [sp, #0x1c]
700a41de: 9a00         	ldr	r2, [sp]
700a41e0: 6a11         	ldr	r1, [r2, #0x20]
700a41e2: 6a52         	ldr	r2, [r2, #0x24]
700a41e4: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxHcCh) &&
700a41e6: 4288         	cmp	r0, r1
700a41e8: d22a         	bhs	0x700a4240 <Udma_rmAllocTxHcCh+0x110> @ imm = #0x54
700a41ea: e7ff         	b	0x700a41ec <Udma_rmAllocTxHcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxHcCh;
700a41ec: 9807         	ldr	r0, [sp, #0x1c]
700a41ee: 9900         	ldr	r1, [sp]
700a41f0: 6a09         	ldr	r1, [r1, #0x20]
700a41f2: 1a40         	subs	r0, r0, r1
700a41f4: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a41f6: 9805         	ldr	r0, [sp, #0x14]
700a41f8: 0940         	lsrs	r0, r0, #0x5
700a41fa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a41fc: 9805         	ldr	r0, [sp, #0x14]
700a41fe: 9904         	ldr	r1, [sp, #0x10]
700a4200: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4204: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4206: 9903         	ldr	r1, [sp, #0xc]
700a4208: 2001         	movs	r0, #0x1
700a420a: 4088         	lsls	r0, r1
700a420c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txHcChFlag[offset] & bitMask) == bitMask)
700a420e: 9806         	ldr	r0, [sp, #0x18]
700a4210: 9904         	ldr	r1, [sp, #0x10]
700a4212: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4216: f8d0 02f4    	ldr.w	r0, [r0, #0x2f4]
700a421a: 9902         	ldr	r1, [sp, #0x8]
700a421c: 4008         	ands	r0, r1
700a421e: 4288         	cmp	r0, r1
700a4220: d10d         	bne	0x700a423e <Udma_rmAllocTxHcCh+0x10e> @ imm = #0x1a
700a4222: e7ff         	b	0x700a4224 <Udma_rmAllocTxHcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txHcChFlag[offset] &= ~bitMask;
700a4224: 9a02         	ldr	r2, [sp, #0x8]
700a4226: 9806         	ldr	r0, [sp, #0x18]
700a4228: 9904         	ldr	r1, [sp, #0x10]
700a422a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a422e: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700a4232: 4390         	bics	r0, r2
700a4234: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;                 chNum = preferredChNum;
700a4238: 9807         	ldr	r0, [sp, #0x1c]
700a423a: 9001         	str	r0, [sp, #0x4]
;             }
700a423c: e7ff         	b	0x700a423e <Udma_rmAllocTxHcCh+0x10e> @ imm = #-0x2
;         }
700a423e: e7ff         	b	0x700a4240 <Udma_rmAllocTxHcCh+0x110> @ imm = #-0x2
700a4240: e7ff         	b	0x700a4242 <Udma_rmAllocTxHcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a4242: 9806         	ldr	r0, [sp, #0x18]
700a4244: f500 609f    	add.w	r0, r0, #0x4f8
700a4248: f007 fe52    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x7ca4
;     return (chNum);
700a424c: 9801         	ldr	r0, [sp, #0x4]
700a424e: b008         	add	sp, #0x20
700a4250: bd80         	pop	{r7, pc}
		...
700a425e: 0000         	movs	r0, r0

700a4260 <Udma_rmAllocTxUhcCh>:
; {
700a4260: b580         	push	{r7, lr}
700a4262: b088         	sub	sp, #0x20
700a4264: 9007         	str	r0, [sp, #0x1c]
700a4266: 9106         	str	r1, [sp, #0x18]
700a4268: 2000         	movs	r0, #0x0
700a426a: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700a426e: 9001         	str	r0, [sp, #0x4]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a4270: 9806         	ldr	r0, [sp, #0x18]
700a4272: f500 70ea    	add.w	r0, r0, #0x1d4
700a4276: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a4278: 9806         	ldr	r0, [sp, #0x18]
700a427a: f500 609f    	add.w	r0, r0, #0x4f8
700a427e: f04f 31ff    	mov.w	r1, #0xffffffff
700a4282: f006 faa5    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x654a
;     if(UDMA_DMA_CH_ANY == preferredChNum)
700a4286: 9807         	ldr	r0, [sp, #0x1c]
700a4288: 2101         	movs	r1, #0x1
700a428a: f6cf 71ff    	movt	r1, #0xffff
700a428e: 4288         	cmp	r0, r1
700a4290: d136         	bne	0x700a4300 <Udma_rmAllocTxUhcCh+0xa0> @ imm = #0x6c
700a4292: e7ff         	b	0x700a4294 <Udma_rmAllocTxUhcCh+0x34> @ imm = #-0x2
700a4294: 2000         	movs	r0, #0x0
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a4296: 9005         	str	r0, [sp, #0x14]
700a4298: e7ff         	b	0x700a429a <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x2
700a429a: 9805         	ldr	r0, [sp, #0x14]
700a429c: 9900         	ldr	r1, [sp]
700a429e: 69c9         	ldr	r1, [r1, #0x1c]
700a42a0: 4288         	cmp	r0, r1
700a42a2: d22c         	bhs	0x700a42fe <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x58
700a42a4: e7ff         	b	0x700a42a6 <Udma_rmAllocTxUhcCh+0x46> @ imm = #-0x2
;             offset = i >> 5U;
700a42a6: 9805         	ldr	r0, [sp, #0x14]
700a42a8: 0940         	lsrs	r0, r0, #0x5
700a42aa: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a42ac: 9805         	ldr	r0, [sp, #0x14]
700a42ae: 9904         	ldr	r1, [sp, #0x10]
700a42b0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a42b4: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a42b6: 9903         	ldr	r1, [sp, #0xc]
700a42b8: 2001         	movs	r0, #0x1
700a42ba: 4088         	lsls	r0, r1
700a42bc: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a42be: 9806         	ldr	r0, [sp, #0x18]
700a42c0: 9904         	ldr	r1, [sp, #0x10]
700a42c2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a42c6: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a42ca: 9902         	ldr	r1, [sp, #0x8]
700a42cc: 4008         	ands	r0, r1
700a42ce: 4288         	cmp	r0, r1
700a42d0: d110         	bne	0x700a42f4 <Udma_rmAllocTxUhcCh+0x94> @ imm = #0x20
700a42d2: e7ff         	b	0x700a42d4 <Udma_rmAllocTxUhcCh+0x74> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a42d4: 9a02         	ldr	r2, [sp, #0x8]
700a42d6: 9806         	ldr	r0, [sp, #0x18]
700a42d8: 9904         	ldr	r1, [sp, #0x10]
700a42da: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a42de: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a42e2: 4390         	bics	r0, r2
700a42e4: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = i + rmInitPrms->startTxUhcCh;  /* Add start offset */
700a42e8: 9805         	ldr	r0, [sp, #0x14]
700a42ea: 9900         	ldr	r1, [sp]
700a42ec: 6989         	ldr	r1, [r1, #0x18]
700a42ee: 4408         	add	r0, r1
700a42f0: 9001         	str	r0, [sp, #0x4]
;                 break;
700a42f2: e004         	b	0x700a42fe <Udma_rmAllocTxUhcCh+0x9e> @ imm = #0x8
;         }
700a42f4: e7ff         	b	0x700a42f6 <Udma_rmAllocTxUhcCh+0x96> @ imm = #-0x2
;         for(i = 0U; i < rmInitPrms->numTxUhcCh; i++)
700a42f6: 9805         	ldr	r0, [sp, #0x14]
700a42f8: 3001         	adds	r0, #0x1
700a42fa: 9005         	str	r0, [sp, #0x14]
700a42fc: e7cd         	b	0x700a429a <Udma_rmAllocTxUhcCh+0x3a> @ imm = #-0x66
;     }
700a42fe: e038         	b	0x700a4372 <Udma_rmAllocTxUhcCh+0x112> @ imm = #0x70
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a4300: 9807         	ldr	r0, [sp, #0x1c]
700a4302: 9900         	ldr	r1, [sp]
700a4304: 6989         	ldr	r1, [r1, #0x18]
700a4306: 4288         	cmp	r0, r1
700a4308: d332         	blo	0x700a4370 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x64
700a430a: e7ff         	b	0x700a430c <Udma_rmAllocTxUhcCh+0xac> @ imm = #-0x2
;            (preferredChNum < (rmInitPrms->startTxUhcCh + rmInitPrms->numTxUhcCh)))
700a430c: 9807         	ldr	r0, [sp, #0x1c]
700a430e: 9a00         	ldr	r2, [sp]
700a4310: 6991         	ldr	r1, [r2, #0x18]
700a4312: 69d2         	ldr	r2, [r2, #0x1c]
700a4314: 4411         	add	r1, r2
;         if((preferredChNum >= rmInitPrms->startTxUhcCh) &&
700a4316: 4288         	cmp	r0, r1
700a4318: d22a         	bhs	0x700a4370 <Udma_rmAllocTxUhcCh+0x110> @ imm = #0x54
700a431a: e7ff         	b	0x700a431c <Udma_rmAllocTxUhcCh+0xbc> @ imm = #-0x2
;             i = preferredChNum - rmInitPrms->startTxUhcCh;
700a431c: 9807         	ldr	r0, [sp, #0x1c]
700a431e: 9900         	ldr	r1, [sp]
700a4320: 6989         	ldr	r1, [r1, #0x18]
700a4322: 1a40         	subs	r0, r0, r1
700a4324: 9005         	str	r0, [sp, #0x14]
;             offset = i >> 5U;
700a4326: 9805         	ldr	r0, [sp, #0x14]
700a4328: 0940         	lsrs	r0, r0, #0x5
700a432a: 9004         	str	r0, [sp, #0x10]
;             bitPos = i - (offset << 5U);
700a432c: 9805         	ldr	r0, [sp, #0x14]
700a432e: 9904         	ldr	r1, [sp, #0x10]
700a4330: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a4334: 9003         	str	r0, [sp, #0xc]
;             bitMask = (uint32_t) 1U << bitPos;
700a4336: 9903         	ldr	r1, [sp, #0xc]
700a4338: 2001         	movs	r0, #0x1
700a433a: 4088         	lsls	r0, r1
700a433c: 9002         	str	r0, [sp, #0x8]
;             if((drvHandle->txUhcChFlag[offset] & bitMask) == bitMask)
700a433e: 9806         	ldr	r0, [sp, #0x18]
700a4340: 9904         	ldr	r1, [sp, #0x10]
700a4342: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4346: f8d0 02f8    	ldr.w	r0, [r0, #0x2f8]
700a434a: 9902         	ldr	r1, [sp, #0x8]
700a434c: 4008         	ands	r0, r1
700a434e: 4288         	cmp	r0, r1
700a4350: d10d         	bne	0x700a436e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #0x1a
700a4352: e7ff         	b	0x700a4354 <Udma_rmAllocTxUhcCh+0xf4> @ imm = #-0x2
;                 drvHandle->txUhcChFlag[offset] &= ~bitMask;
700a4354: 9a02         	ldr	r2, [sp, #0x8]
700a4356: 9806         	ldr	r0, [sp, #0x18]
700a4358: 9904         	ldr	r1, [sp, #0x10]
700a435a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a435e: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700a4362: 4390         	bics	r0, r2
700a4364: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;                 chNum = preferredChNum;
700a4368: 9807         	ldr	r0, [sp, #0x1c]
700a436a: 9001         	str	r0, [sp, #0x4]
;             }
700a436c: e7ff         	b	0x700a436e <Udma_rmAllocTxUhcCh+0x10e> @ imm = #-0x2
;         }
700a436e: e7ff         	b	0x700a4370 <Udma_rmAllocTxUhcCh+0x110> @ imm = #-0x2
700a4370: e7ff         	b	0x700a4372 <Udma_rmAllocTxUhcCh+0x112> @ imm = #-0x2
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a4372: 9806         	ldr	r0, [sp, #0x18]
700a4374: f500 609f    	add.w	r0, r0, #0x4f8
700a4378: f007 fdba    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x7b74
;     return (chNum);
700a437c: 9801         	ldr	r0, [sp, #0x4]
700a437e: b008         	add	sp, #0x20
700a4380: bd80         	pop	{r7, pc}
		...
700a438e: 0000         	movs	r0, r0

700a4390 <UART_udmaInitRxCh>:
; {
700a4390: b580         	push	{r7, lr}
700a4392: b0be         	sub	sp, #0xf8
700a4394: 903d         	str	r0, [sp, #0xf4]
700a4396: 913c         	str	r1, [sp, #0xf0]
700a4398: 200a         	movs	r0, #0xa
;     chType = UDMA_CH_TYPE_PDMA_RX;
700a439a: 903a         	str	r0, [sp, #0xe8]
;     UdmaChPrms_init(&chPrms, chType);
700a439c: 993a         	ldr	r1, [sp, #0xe8]
700a439e: a821         	add	r0, sp, #0x84
700a43a0: f007 f97e    	bl	0x700ab6a0 <UdmaChPrms_init> @ imm = #0x72fc
;     chPrms.peerChNum                = hUart->hUartInit->rxEvtNum;
700a43a4: 983d         	ldr	r0, [sp, #0xf4]
700a43a6: 6840         	ldr	r0, [r0, #0x4]
700a43a8: 6c00         	ldr	r0, [r0, #0x40]
700a43aa: 9022         	str	r0, [sp, #0x88]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->rxRingMem;
700a43ac: 983c         	ldr	r0, [sp, #0xf0]
700a43ae: 6a80         	ldr	r0, [r0, #0x28]
700a43b0: 9025         	str	r0, [sp, #0x94]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a43b2: 983c         	ldr	r0, [sp, #0xf0]
700a43b4: 6b00         	ldr	r0, [r0, #0x30]
700a43b6: 9026         	str	r0, [sp, #0x98]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a43b8: 983c         	ldr	r0, [sp, #0xf0]
700a43ba: 6b40         	ldr	r0, [r0, #0x34]
700a43bc: 9028         	str	r0, [sp, #0xa0]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a43be: 983c         	ldr	r0, [sp, #0xf0]
700a43c0: 6bc0         	ldr	r0, [r0, #0x3c]
700a43c2: 2801         	cmp	r0, #0x1
700a43c4: d10a         	bne	0x700a43dc <UART_udmaInitRxCh+0x4c> @ imm = #0x14
700a43c6: e7ff         	b	0x700a43c8 <UART_udmaInitRxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqRxRingMem;
700a43c8: 983c         	ldr	r0, [sp, #0xf0]
700a43ca: 6ac0         	ldr	r0, [r0, #0x2c]
700a43cc: 902c         	str	r0, [sp, #0xb0]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a43ce: 983c         	ldr	r0, [sp, #0xf0]
700a43d0: 6b00         	ldr	r0, [r0, #0x30]
700a43d2: 902d         	str	r0, [sp, #0xb4]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a43d4: 983c         	ldr	r0, [sp, #0xf0]
700a43d6: 6b40         	ldr	r0, [r0, #0x34]
700a43d8: 902f         	str	r0, [sp, #0xbc]
;     }
700a43da: e7ff         	b	0x700a43dc <UART_udmaInitRxCh+0x4c> @ imm = #-0x2
;     rxChHandle                      = udmaChCfg->rxChHandle;
700a43dc: 983c         	ldr	r0, [sp, #0xf0]
700a43de: 6880         	ldr	r0, [r0, #0x8]
700a43e0: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a43e2: 983c         	ldr	r0, [sp, #0xf0]
700a43e4: 6800         	ldr	r0, [r0]
700a43e6: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, rxChHandle, chType, &chPrms);
700a43e8: 9807         	ldr	r0, [sp, #0x1c]
700a43ea: 9906         	ldr	r1, [sp, #0x18]
700a43ec: 9a3a         	ldr	r2, [sp, #0xe8]
700a43ee: ab21         	add	r3, sp, #0x84
700a43f0: f7fd fb2e    	bl	0x700a1a50 <Udma_chOpen> @ imm = #-0x29a4
700a43f4: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a43f6: 983b         	ldr	r0, [sp, #0xec]
700a43f8: fab0 f080    	clz	r0, r0
700a43fc: 0940         	lsrs	r0, r0, #0x5
700a43fe: f641 716f    	movw	r1, #0x1f6f
700a4402: f2c7 010b    	movt	r1, #0x700b
700a4406: 9103         	str	r1, [sp, #0xc]
700a4408: 466a         	mov	r2, sp
700a440a: 6011         	str	r1, [r2]
700a440c: f641 316c    	movw	r1, #0x1b6c
700a4410: f2c7 010b    	movt	r1, #0x700b
700a4414: 9104         	str	r1, [sp, #0x10]
700a4416: f641 72f3    	movw	r2, #0x1ff3
700a441a: f2c7 020b    	movt	r2, #0x700b
700a441e: 9205         	str	r2, [sp, #0x14]
700a4420: 2366         	movs	r3, #0x66
700a4422: f006 fc2d    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x685a
;     UdmaChRxPrms_init(&rxPrms, chType);
700a4426: 993a         	ldr	r1, [sp, #0xe8]
700a4428: a81a         	add	r0, sp, #0x68
700a442a: 9001         	str	r0, [sp, #0x4]
700a442c: f003 fde0    	bl	0x700a7ff0 <UdmaChRxPrms_init> @ imm = #0x3bc0
700a4430: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigRx(rxChHandle, &rxPrms);
700a4432: 9806         	ldr	r0, [sp, #0x18]
700a4434: f7f9 fe34    	bl	0x7009e0a0 <Udma_chConfigRx> @ imm = #-0x6398
700a4438: 9b03         	ldr	r3, [sp, #0xc]
700a443a: 9904         	ldr	r1, [sp, #0x10]
700a443c: 9a05         	ldr	r2, [sp, #0x14]
700a443e: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a4440: 983b         	ldr	r0, [sp, #0xec]
700a4442: fab0 f080    	clz	r0, r0
700a4446: 0940         	lsrs	r0, r0, #0x5
700a4448: 46ec         	mov	r12, sp
700a444a: f8cc 3000    	str.w	r3, [r12]
700a444e: 236b         	movs	r3, #0x6b
700a4450: f006 fc16    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x682c
;     eventHandle = udmaChCfg->cqRxEvtHandle;
700a4454: 983c         	ldr	r0, [sp, #0xf0]
700a4456: 6900         	ldr	r0, [r0, #0x10]
700a4458: 9019         	str	r0, [sp, #0x64]
700a445a: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a445c: 9002         	str	r0, [sp, #0x8]
700a445e: f007 fd7f    	bl	0x700abf60 <UdmaEventPrms_init> @ imm = #0x7afe
700a4462: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a4464: 9008         	str	r0, [sp, #0x20]
700a4466: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a4468: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = rxChHandle;
700a446a: 9806         	ldr	r0, [sp, #0x18]
700a446c: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a446e: 9807         	ldr	r0, [sp, #0x1c]
700a4470: f008 fc76    	bl	0x700acd60 <Udma_eventGetGlobalHandle> @ imm = #0x88ec
700a4474: 9a02         	ldr	r2, [sp, #0x8]
700a4476: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrRx;
700a4478: f249 7071    	movw	r0, #0x9771
700a447c: f2c7 000a    	movt	r0, #0x700a
700a4480: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a4482: 983d         	ldr	r0, [sp, #0xf4]
700a4484: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a4486: 9807         	ldr	r0, [sp, #0x1c]
700a4488: 9919         	ldr	r1, [sp, #0x64]
700a448a: f7fa fbd9    	bl	0x7009ec40 <Udma_eventRegister> @ imm = #-0x584e
700a448e: 9b03         	ldr	r3, [sp, #0xc]
700a4490: 9904         	ldr	r1, [sp, #0x10]
700a4492: 9a05         	ldr	r2, [sp, #0x14]
700a4494: 903b         	str	r0, [sp, #0xec]
;     DebugP_assert(UDMA_SOK == retVal);
700a4496: 983b         	ldr	r0, [sp, #0xec]
700a4498: fab0 f080    	clz	r0, r0
700a449c: 0940         	lsrs	r0, r0, #0x5
700a449e: 46ec         	mov	r12, sp
700a44a0: f8cc 3000    	str.w	r3, [r12]
700a44a4: 2377         	movs	r3, #0x77
700a44a6: f006 fbeb    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x67d6
;     return retVal;
700a44aa: 983b         	ldr	r0, [sp, #0xec]
700a44ac: b03e         	add	sp, #0xf8
700a44ae: bd80         	pop	{r7, pc}

700a44b0 <UART_udmaInitTxCh>:
; {
700a44b0: b580         	push	{r7, lr}
700a44b2: b0bc         	sub	sp, #0xf0
700a44b4: 903b         	str	r0, [sp, #0xec]
700a44b6: 913a         	str	r1, [sp, #0xe8]
700a44b8: 2009         	movs	r0, #0x9
;     chType = UDMA_CH_TYPE_PDMA_TX;
700a44ba: 9038         	str	r0, [sp, #0xe0]
;     UdmaChPrms_init(&chPrms, chType);
700a44bc: 9938         	ldr	r1, [sp, #0xe0]
700a44be: a81f         	add	r0, sp, #0x7c
700a44c0: f007 f8ee    	bl	0x700ab6a0 <UdmaChPrms_init> @ imm = #0x71dc
;     chPrms.peerChNum                = hUart->hUartInit->txEvtNum;
700a44c4: 983b         	ldr	r0, [sp, #0xec]
700a44c6: 6840         	ldr	r0, [r0, #0x4]
700a44c8: 6c40         	ldr	r0, [r0, #0x44]
700a44ca: 9020         	str	r0, [sp, #0x80]
;     chPrms.fqRingPrms.ringMem       = udmaChCfg->txRingMem;
700a44cc: 983a         	ldr	r0, [sp, #0xe8]
700a44ce: 6a00         	ldr	r0, [r0, #0x20]
700a44d0: 9023         	str	r0, [sp, #0x8c]
;     chPrms.fqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a44d2: 983a         	ldr	r0, [sp, #0xe8]
700a44d4: 6b00         	ldr	r0, [r0, #0x30]
700a44d6: 9024         	str	r0, [sp, #0x90]
;     chPrms.fqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a44d8: 983a         	ldr	r0, [sp, #0xe8]
700a44da: 6b40         	ldr	r0, [r0, #0x34]
700a44dc: 9026         	str	r0, [sp, #0x98]
;     if(udmaChCfg->isCqRingMem == UDMA_COMP_QUEUE_RING_MEM_ENABLED){
700a44de: 983a         	ldr	r0, [sp, #0xe8]
700a44e0: 6bc0         	ldr	r0, [r0, #0x3c]
700a44e2: 2801         	cmp	r0, #0x1
700a44e4: d10a         	bne	0x700a44fc <UART_udmaInitTxCh+0x4c> @ imm = #0x14
700a44e6: e7ff         	b	0x700a44e8 <UART_udmaInitTxCh+0x38> @ imm = #-0x2
;         chPrms.cqRingPrms.ringMem       = udmaChCfg->cqTxRingMem;
700a44e8: 983a         	ldr	r0, [sp, #0xe8]
700a44ea: 6a40         	ldr	r0, [r0, #0x24]
700a44ec: 902a         	str	r0, [sp, #0xa8]
;         chPrms.cqRingPrms.ringMemSize   = udmaChCfg->ringMemSize;
700a44ee: 983a         	ldr	r0, [sp, #0xe8]
700a44f0: 6b00         	ldr	r0, [r0, #0x30]
700a44f2: 902b         	str	r0, [sp, #0xac]
;         chPrms.cqRingPrms.elemCnt       = udmaChCfg->ringElemCnt;
700a44f4: 983a         	ldr	r0, [sp, #0xe8]
700a44f6: 6b40         	ldr	r0, [r0, #0x34]
700a44f8: 902d         	str	r0, [sp, #0xb4]
;     }
700a44fa: e7ff         	b	0x700a44fc <UART_udmaInitTxCh+0x4c> @ imm = #-0x2
;     txChHandle                      = udmaChCfg->txChHandle;
700a44fc: 983a         	ldr	r0, [sp, #0xe8]
700a44fe: 6840         	ldr	r0, [r0, #0x4]
700a4500: 9006         	str	r0, [sp, #0x18]
;     drvHandle                       = udmaChCfg->drvHandle;
700a4502: 983a         	ldr	r0, [sp, #0xe8]
700a4504: 6800         	ldr	r0, [r0]
700a4506: 9007         	str	r0, [sp, #0x1c]
;     retVal = Udma_chOpen(drvHandle, txChHandle, chType, &chPrms);
700a4508: 9807         	ldr	r0, [sp, #0x1c]
700a450a: 9906         	ldr	r1, [sp, #0x18]
700a450c: 9a38         	ldr	r2, [sp, #0xe0]
700a450e: ab1f         	add	r3, sp, #0x7c
700a4510: f7fd fa9e    	bl	0x700a1a50 <Udma_chOpen> @ imm = #-0x2ac4
700a4514: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a4516: 9839         	ldr	r0, [sp, #0xe4]
700a4518: fab0 f080    	clz	r0, r0
700a451c: 0940         	lsrs	r0, r0, #0x5
700a451e: f641 716f    	movw	r1, #0x1f6f
700a4522: f2c7 010b    	movt	r1, #0x700b
700a4526: 9103         	str	r1, [sp, #0xc]
700a4528: 466a         	mov	r2, sp
700a452a: 6011         	str	r1, [r2]
700a452c: f641 316c    	movw	r1, #0x1b6c
700a4530: f2c7 010b    	movt	r1, #0x700b
700a4534: 9104         	str	r1, [sp, #0x10]
700a4536: f242 0229    	movw	r2, #0x2029
700a453a: f2c7 020b    	movt	r2, #0x700b
700a453e: 9205         	str	r2, [sp, #0x14]
700a4540: 2398         	movs	r3, #0x98
700a4542: f006 fb9d    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x673a
;     UdmaChTxPrms_init(&txPrms, chType);
700a4546: 9938         	ldr	r1, [sp, #0xe0]
700a4548: a81a         	add	r0, sp, #0x68
700a454a: 9001         	str	r0, [sp, #0x4]
700a454c: f003 fda8    	bl	0x700a80a0 <UdmaChTxPrms_init> @ imm = #0x3b50
700a4550: 9901         	ldr	r1, [sp, #0x4]
;     retVal = Udma_chConfigTx(txChHandle, &txPrms);
700a4552: 9806         	ldr	r0, [sp, #0x18]
700a4554: f7fc f94c    	bl	0x700a07f0 <Udma_chConfigTx> @ imm = #-0x3d68
700a4558: 9b03         	ldr	r3, [sp, #0xc]
700a455a: 9904         	ldr	r1, [sp, #0x10]
700a455c: 9a05         	ldr	r2, [sp, #0x14]
700a455e: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a4560: 9839         	ldr	r0, [sp, #0xe4]
700a4562: fab0 f080    	clz	r0, r0
700a4566: 0940         	lsrs	r0, r0, #0x5
700a4568: 46ec         	mov	r12, sp
700a456a: f8cc 3000    	str.w	r3, [r12]
700a456e: 239d         	movs	r3, #0x9d
700a4570: f006 fb86    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x670c
;     eventHandle = udmaChCfg->cqTxEvtHandle;
700a4574: 983a         	ldr	r0, [sp, #0xe8]
700a4576: 68c0         	ldr	r0, [r0, #0xc]
700a4578: 9019         	str	r0, [sp, #0x64]
700a457a: a808         	add	r0, sp, #0x20
;     UdmaEventPrms_init(&eventPrms);
700a457c: 9002         	str	r0, [sp, #0x8]
700a457e: f007 fcef    	bl	0x700abf60 <UdmaEventPrms_init> @ imm = #0x79de
700a4582: 2001         	movs	r0, #0x1
;     eventPrms.eventType         = UDMA_EVENT_TYPE_DMA_COMPLETION;
700a4584: 9008         	str	r0, [sp, #0x20]
700a4586: 2002         	movs	r0, #0x2
;     eventPrms.eventMode         = UDMA_EVENT_MODE_SHARED;
700a4588: 9009         	str	r0, [sp, #0x24]
;     eventPrms.chHandle          = txChHandle;
700a458a: 9806         	ldr	r0, [sp, #0x18]
700a458c: 900a         	str	r0, [sp, #0x28]
;     eventPrms.controllerEventHandle = Udma_eventGetGlobalHandle(drvHandle);
700a458e: 9807         	ldr	r0, [sp, #0x1c]
700a4590: f008 fbe6    	bl	0x700acd60 <Udma_eventGetGlobalHandle> @ imm = #0x87cc
700a4594: 9a02         	ldr	r2, [sp, #0x8]
700a4596: 900c         	str	r0, [sp, #0x30]
;     eventPrms.eventCb           = &UART_udmaIsrTx;
700a4598: f649 0011    	movw	r0, #0x9811
700a459c: f2c7 000a    	movt	r0, #0x700a
700a45a0: 900d         	str	r0, [sp, #0x34]
;     eventPrms.appData           = (void *) hUart;
700a45a2: 983b         	ldr	r0, [sp, #0xec]
700a45a4: 900f         	str	r0, [sp, #0x3c]
;     retVal = Udma_eventRegister(drvHandle, eventHandle, &eventPrms);
700a45a6: 9807         	ldr	r0, [sp, #0x1c]
700a45a8: 9919         	ldr	r1, [sp, #0x64]
700a45aa: f7fa fb49    	bl	0x7009ec40 <Udma_eventRegister> @ imm = #-0x596e
700a45ae: 9b03         	ldr	r3, [sp, #0xc]
700a45b0: 9904         	ldr	r1, [sp, #0x10]
700a45b2: 9a05         	ldr	r2, [sp, #0x14]
700a45b4: 9039         	str	r0, [sp, #0xe4]
;     DebugP_assert(UDMA_SOK == retVal);
700a45b6: 9839         	ldr	r0, [sp, #0xe4]
700a45b8: fab0 f080    	clz	r0, r0
700a45bc: 0940         	lsrs	r0, r0, #0x5
700a45be: 46ec         	mov	r12, sp
700a45c0: f8cc 3000    	str.w	r3, [r12]
700a45c4: 23a9         	movs	r3, #0xa9
700a45c6: f006 fb5b    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x66b6
;     return retVal;
700a45ca: 9839         	ldr	r0, [sp, #0xe4]
700a45cc: b03c         	add	sp, #0xf0
700a45ce: bd80         	pop	{r7, pc}

700a45d0 <Sciclient_rmIaValidateEvt>:
; {
700a45d0: b580         	push	{r7, lr}
700a45d2: b086         	sub	sp, #0x18
700a45d4: 4684         	mov	r12, r0
700a45d6: 9808         	ldr	r0, [sp, #0x20]
700a45d8: f8cd c014    	str.w	r12, [sp, #0x14]
700a45dc: f8ad 1012    	strh.w	r1, [sp, #0x12]
700a45e0: f8ad 2010    	strh.w	r2, [sp, #0x10]
700a45e4: f88d 300f    	strb.w	r3, [sp, #0xf]
700a45e8: f88d 000e    	strb.w	r0, [sp, #0xe]
700a45ec: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a45ee: 9002         	str	r0, [sp, #0x8]
;     if (evt >= inst->n_sevt) {
700a45f0: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a45f4: 9905         	ldr	r1, [sp, #0x14]
700a45f6: 8949         	ldrh	r1, [r1, #0xa]
700a45f8: 4288         	cmp	r0, r1
700a45fa: db04         	blt	0x700a4606 <Sciclient_rmIaValidateEvt+0x36> @ imm = #0x8
700a45fc: e7ff         	b	0x700a45fe <Sciclient_rmIaValidateEvt+0x2e> @ imm = #-0x2
700a45fe: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a4602: 9002         	str	r0, [sp, #0x8]
;     }
700a4604: e7ff         	b	0x700a4606 <Sciclient_rmIaValidateEvt+0x36> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a4606: 9802         	ldr	r0, [sp, #0x8]
700a4608: 2800         	cmp	r0, #0x0
700a460a: d16d         	bne	0x700a46e8 <Sciclient_rmIaValidateEvt+0x118> @ imm = #0xda
700a460c: e7ff         	b	0x700a460e <Sciclient_rmIaValidateEvt+0x3e> @ imm = #-0x2
;         entry_int_map_lo = (volatile uint32_t *)(inst->imap + SCICLIENT_IA_ENTRY_INTMAP_LO(evt));
700a460e: 9805         	ldr	r0, [sp, #0x14]
700a4610: 6840         	ldr	r0, [r0, #0x4]
700a4612: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a4616: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a461a: 9001         	str	r0, [sp, #0x4]
;         if (in_use == true) {
700a461c: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700a4620: 07c0         	lsls	r0, r0, #0x1f
700a4622: 2800         	cmp	r0, #0x0
700a4624: d047         	beq	0x700a46b6 <Sciclient_rmIaValidateEvt+0xe6> @ imm = #0x8e
700a4626: e7ff         	b	0x700a4628 <Sciclient_rmIaValidateEvt+0x58> @ imm = #-0x2
;             reg_vint = CSL_REG32_FEXT(entry_int_map_lo,
700a4628: 9801         	ldr	r0, [sp, #0x4]
700a462a: f64f 7100    	movw	r1, #0xff00
700a462e: f2c0 0101    	movt	r1, #0x1
700a4632: 2208         	movs	r2, #0x8
700a4634: f00a fd8c    	bl	0x700af150 <CSL_REG32_FEXT_RAW> @ imm = #0xab18
700a4638: f8ad 0002    	strh.w	r0, [sp, #0x2]
;             reg_sb = CSL_REG32_FEXT(entry_int_map_lo,
700a463c: 9801         	ldr	r0, [sp, #0x4]
700a463e: 213f         	movs	r1, #0x3f
700a4640: 2200         	movs	r2, #0x0
700a4642: f00a fd85    	bl	0x700af150 <CSL_REG32_FEXT_RAW> @ imm = #0xab0a
700a4646: f8ad 0000    	strh.w	r0, [sp]
;             if ((reg_vint == 0u) && (reg_sb == 0u)) {
700a464a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a464e: b9f0         	cbnz	r0, 0x700a468e <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x3c
700a4650: e7ff         	b	0x700a4652 <Sciclient_rmIaValidateEvt+0x82> @ imm = #-0x2
700a4652: f8bd 0000    	ldrh.w	r0, [sp]
700a4656: b9d0         	cbnz	r0, 0x700a468e <Sciclient_rmIaValidateEvt+0xbe> @ imm = #0x34
700a4658: e7ff         	b	0x700a465a <Sciclient_rmIaValidateEvt+0x8a> @ imm = #-0x2
;                 if ((vint != reg_vint) &&
700a465a: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a465e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a4662: 4288         	cmp	r0, r1
700a4664: d012         	beq	0x700a468c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x24
700a4666: e7ff         	b	0x700a4668 <Sciclient_rmIaValidateEvt+0x98> @ imm = #-0x2
;                     (vint_sb_index != reg_sb) &&
700a4668: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a466c: f8bd 1000    	ldrh.w	r1, [sp]
700a4670: 4288         	cmp	r0, r1
700a4672: d00b         	beq	0x700a468c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x16
700a4674: e7ff         	b	0x700a4676 <Sciclient_rmIaValidateEvt+0xa6> @ imm = #-0x2
;                     (evt != inst->v0_b0_evt)) {
700a4676: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a467a: 9905         	ldr	r1, [sp, #0x14]
700a467c: 8a89         	ldrh	r1, [r1, #0x14]
;                 if ((vint != reg_vint) &&
700a467e: 4288         	cmp	r0, r1
700a4680: d004         	beq	0x700a468c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #0x8
700a4682: e7ff         	b	0x700a4684 <Sciclient_rmIaValidateEvt+0xb4> @ imm = #-0x2
700a4684: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a4688: 9002         	str	r0, [sp, #0x8]
;                 }
700a468a: e7ff         	b	0x700a468c <Sciclient_rmIaValidateEvt+0xbc> @ imm = #-0x2
;             } else {
700a468c: e012         	b	0x700a46b4 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #0x24
;                 if ((vint != reg_vint) &&
700a468e: f8bd 0010    	ldrh.w	r0, [sp, #0x10]
700a4692: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700a4696: 4288         	cmp	r0, r1
700a4698: d00b         	beq	0x700a46b2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x16
700a469a: e7ff         	b	0x700a469c <Sciclient_rmIaValidateEvt+0xcc> @ imm = #-0x2
;                     (vint_sb_index != reg_sb)) {
700a469c: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a46a0: f8bd 1000    	ldrh.w	r1, [sp]
;                 if ((vint != reg_vint) &&
700a46a4: 4288         	cmp	r0, r1
700a46a6: d004         	beq	0x700a46b2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #0x8
700a46a8: e7ff         	b	0x700a46aa <Sciclient_rmIaValidateEvt+0xda> @ imm = #-0x2
700a46aa: f06f 0001    	mvn	r0, #0x1
;                     r = CSL_EBADARGS;
700a46ae: 9002         	str	r0, [sp, #0x8]
;                 }
700a46b0: e7ff         	b	0x700a46b2 <Sciclient_rmIaValidateEvt+0xe2> @ imm = #-0x2
700a46b2: e7ff         	b	0x700a46b4 <Sciclient_rmIaValidateEvt+0xe4> @ imm = #-0x2
;         } else {
700a46b4: e017         	b	0x700a46e6 <Sciclient_rmIaValidateEvt+0x116> @ imm = #0x2e
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a46b6: 9801         	ldr	r0, [sp, #0x4]
700a46b8: f00b fac2    	bl	0x700afc40 <CSL_REG32_RD_RAW> @ imm = #0xb584
700a46bc: b138         	cbz	r0, 0x700a46ce <Sciclient_rmIaValidateEvt+0xfe> @ imm = #0xe
700a46be: e7ff         	b	0x700a46c0 <Sciclient_rmIaValidateEvt+0xf0> @ imm = #-0x2
;                  (Sciclient_rmIaEvtRomMapped(inst, evt) == false)) ||
700a46c0: 9805         	ldr	r0, [sp, #0x14]
700a46c2: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a46c6: f005 fcdb    	bl	0x700aa080 <Sciclient_rmIaEvtRomMapped> @ imm = #0x59b6
700a46ca: b138         	cbz	r0, 0x700a46dc <Sciclient_rmIaValidateEvt+0x10c> @ imm = #0xe
700a46cc: e7ff         	b	0x700a46ce <Sciclient_rmIaValidateEvt+0xfe> @ imm = #-0x2
;                 (evt == inst->v0_b0_evt)) {
700a46ce: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a46d2: 9905         	ldr	r1, [sp, #0x14]
700a46d4: 8a89         	ldrh	r1, [r1, #0x14]
;             if (((CSL_REG32_RD(entry_int_map_lo) != 0u) &&
700a46d6: 4288         	cmp	r0, r1
700a46d8: d104         	bne	0x700a46e4 <Sciclient_rmIaValidateEvt+0x114> @ imm = #0x8
700a46da: e7ff         	b	0x700a46dc <Sciclient_rmIaValidateEvt+0x10c> @ imm = #-0x2
700a46dc: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a46e0: 9002         	str	r0, [sp, #0x8]
;             }
700a46e2: e7ff         	b	0x700a46e4 <Sciclient_rmIaValidateEvt+0x114> @ imm = #-0x2
700a46e4: e7ff         	b	0x700a46e6 <Sciclient_rmIaValidateEvt+0x116> @ imm = #-0x2
;     }
700a46e6: e7ff         	b	0x700a46e8 <Sciclient_rmIaValidateEvt+0x118> @ imm = #-0x2
;     return r;
700a46e8: 9802         	ldr	r0, [sp, #0x8]
700a46ea: b006         	add	sp, #0x18
700a46ec: bd80         	pop	{r7, pc}
700a46ee: 0000         	movs	r0, r0

700a46f0 <Sciclient_rmIrqVintAdd>:
; {
700a46f0: b580         	push	{r7, lr}
700a46f2: b08c         	sub	sp, #0x30
700a46f4: 900b         	str	r0, [sp, #0x2c]
700a46f6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a46f8: 900a         	str	r0, [sp, #0x28]
;     bool cfg_new_mapping = false;
700a46fa: f88d 0026    	strb.w	r0, [sp, #0x26]
;     bool cfg_whole_route = false;
700a46fe: f88d 0025    	strb.w	r0, [sp, #0x25]
;     struct Sciclient_rmIaInst *ia_inst = NULL;
700a4702: 9008         	str	r0, [sp, #0x20]
;     r = Sciclient_rmIrqIsVintRouteSet(cfg, &vint_used);
700a4704: 980b         	ldr	r0, [sp, #0x2c]
700a4706: f10d 0127    	add.w	r1, sp, #0x27
700a470a: f002 fe21    	bl	0x700a7350 <Sciclient_rmIrqIsVintRouteSet> @ imm = #0x2c42
700a470e: 900a         	str	r0, [sp, #0x28]
;     if (r == SystemP_SUCCESS) {
700a4710: 980a         	ldr	r0, [sp, #0x28]
700a4712: b9a0         	cbnz	r0, 0x700a473e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #0x28
700a4714: e7ff         	b	0x700a4716 <Sciclient_rmIrqVintAdd+0x26> @ imm = #-0x2
;         if ((vint_used == true) ||
700a4716: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a471a: 07c0         	lsls	r0, r0, #0x1f
700a471c: b930         	cbnz	r0, 0x700a472c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #0xc
700a471e: e7ff         	b	0x700a4720 <Sciclient_rmIrqVintAdd+0x30> @ imm = #-0x2
;             (Sciclient_rmIrqCfgIsEventToVintMappingOnly(cfg->valid_params) ==
700a4720: 980b         	ldr	r0, [sp, #0x2c]
700a4722: 6800         	ldr	r0, [r0]
700a4724: f007 f90c    	bl	0x700ab940 <Sciclient_rmIrqCfgIsEventToVintMappingOnly> @ imm = #0x7218
;         if ((vint_used == true) ||
700a4728: b120         	cbz	r0, 0x700a4734 <Sciclient_rmIrqVintAdd+0x44> @ imm = #0x8
700a472a: e7ff         	b	0x700a472c <Sciclient_rmIrqVintAdd+0x3c> @ imm = #-0x2
700a472c: 2001         	movs	r0, #0x1
;             cfg_new_mapping = true;
700a472e: f88d 0026    	strb.w	r0, [sp, #0x26]
;         } else {
700a4732: e003         	b	0x700a473c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #0x6
700a4734: 2001         	movs	r0, #0x1
;             cfg_whole_route = true;
700a4736: f88d 0025    	strb.w	r0, [sp, #0x25]
700a473a: e7ff         	b	0x700a473c <Sciclient_rmIrqVintAdd+0x4c> @ imm = #-0x2
;     }
700a473c: e7ff         	b	0x700a473e <Sciclient_rmIrqVintAdd+0x4e> @ imm = #-0x2
;     if (cfg_new_mapping == true) {
700a473e: f89d 0026    	ldrb.w	r0, [sp, #0x26]
700a4742: 07c0         	lsls	r0, r0, #0x1f
700a4744: 2800         	cmp	r0, #0x0
700a4746: d04c         	beq	0x700a47e2 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #0x98
700a4748: e7ff         	b	0x700a474a <Sciclient_rmIrqVintAdd+0x5a> @ imm = #-0x2
700a474a: 203c         	movs	r0, #0x3c
700a474c: f2c8 0000    	movt	r0, #0x8000
;         req.valid_params = (TISCI_MSG_VALUE_RM_IA_ID_VALID |
700a4750: 9003         	str	r0, [sp, #0xc]
;         req.secondary_host = cfg->host;
700a4752: 980b         	ldr	r0, [sp, #0x2c]
700a4754: 7900         	ldrb	r0, [r0, #0x4]
700a4756: f88d 001f    	strb.w	r0, [sp, #0x1f]
;         req.src_id = cfg->s_id;
700a475a: 980b         	ldr	r0, [sp, #0x2c]
700a475c: 88c0         	ldrh	r0, [r0, #0x6]
700a475e: f8ad 0010    	strh.w	r0, [sp, #0x10]
;         req.src_index = cfg->s_idx;
700a4762: 980b         	ldr	r0, [sp, #0x2c]
700a4764: 8900         	ldrh	r0, [r0, #0x8]
700a4766: f8ad 0012    	strh.w	r0, [sp, #0x12]
;         req.ia_id = cfg->s_ia;
700a476a: 980b         	ldr	r0, [sp, #0x2c]
700a476c: 8a00         	ldrh	r0, [r0, #0x10]
700a476e: f8ad 0018    	strh.w	r0, [sp, #0x18]
;         req.vint = cfg->vint;
700a4772: 980b         	ldr	r0, [sp, #0x2c]
700a4774: 8a40         	ldrh	r0, [r0, #0x12]
700a4776: f8ad 001a    	strh.w	r0, [sp, #0x1a]
;         req.global_event = cfg->global_evt;
700a477a: 980b         	ldr	r0, [sp, #0x2c]
700a477c: 89c0         	ldrh	r0, [r0, #0xe]
700a477e: f8ad 001c    	strh.w	r0, [sp, #0x1c]
;         req.vint_status_bit_index = cfg->vint_sb;
700a4782: 980b         	ldr	r0, [sp, #0x2c]
700a4784: 7d00         	ldrb	r0, [r0, #0x14]
700a4786: f88d 001e    	strb.w	r0, [sp, #0x1e]
;                                   cfg->set_resp,
700a478a: 980b         	ldr	r0, [sp, #0x2c]
700a478c: 6981         	ldr	r1, [r0, #0x18]
700a478e: a801         	add	r0, sp, #0x4
700a4790: f04f 32ff    	mov.w	r2, #0xffffffff
;         r = Sciclient_rmIrqSetRaw(&req,
700a4794: f008 f854    	bl	0x700ac840 <Sciclient_rmIrqSetRaw> @ imm = #0x80a8
700a4798: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a479a: 980a         	ldr	r0, [sp, #0x28]
700a479c: bb00         	cbnz	r0, 0x700a47e0 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #0x40
700a479e: e7ff         	b	0x700a47a0 <Sciclient_rmIrqVintAdd+0xb0> @ imm = #-0x2
;             ia_inst = Sciclient_rmIaGetInst(cfg->s_ia);
700a47a0: 980b         	ldr	r0, [sp, #0x2c]
700a47a2: 8a00         	ldrh	r0, [r0, #0x10]
700a47a4: f007 fecc    	bl	0x700ac540 <Sciclient_rmIaGetInst> @ imm = #0x7d98
700a47a8: 9008         	str	r0, [sp, #0x20]
;             if (ia_inst != NULL) {
700a47aa: 9808         	ldr	r0, [sp, #0x20]
700a47ac: b1b8         	cbz	r0, 0x700a47de <Sciclient_rmIrqVintAdd+0xee> @ imm = #0x2e
700a47ae: e7ff         	b	0x700a47b0 <Sciclient_rmIrqVintAdd+0xc0> @ imm = #-0x2
;                 ia_inst->vint_usage_count[cfg->vint]++;
700a47b0: 9808         	ldr	r0, [sp, #0x20]
700a47b2: 6901         	ldr	r1, [r0, #0x10]
700a47b4: 980b         	ldr	r0, [sp, #0x2c]
700a47b6: 8a42         	ldrh	r2, [r0, #0x12]
700a47b8: 5c88         	ldrb	r0, [r1, r2]
700a47ba: 3001         	adds	r0, #0x1
700a47bc: 5488         	strb	r0, [r1, r2]
;                 if ((cfg->vint == 0) && (cfg->vint_sb == 0)) {
700a47be: 980b         	ldr	r0, [sp, #0x2c]
700a47c0: 8a40         	ldrh	r0, [r0, #0x12]
700a47c2: b958         	cbnz	r0, 0x700a47dc <Sciclient_rmIrqVintAdd+0xec> @ imm = #0x16
700a47c4: e7ff         	b	0x700a47c6 <Sciclient_rmIrqVintAdd+0xd6> @ imm = #-0x2
700a47c6: 980b         	ldr	r0, [sp, #0x2c]
700a47c8: 7d00         	ldrb	r0, [r0, #0x14]
700a47ca: b938         	cbnz	r0, 0x700a47dc <Sciclient_rmIrqVintAdd+0xec> @ imm = #0xe
700a47cc: e7ff         	b	0x700a47ce <Sciclient_rmIrqVintAdd+0xde> @ imm = #-0x2
;                     ia_inst->v0_b0_evt = cfg->global_evt - ia_inst->sevt_offset;
700a47ce: 980b         	ldr	r0, [sp, #0x2c]
700a47d0: 89c0         	ldrh	r0, [r0, #0xe]
700a47d2: 9908         	ldr	r1, [sp, #0x20]
700a47d4: 890a         	ldrh	r2, [r1, #0x8]
700a47d6: 1a80         	subs	r0, r0, r2
700a47d8: 8288         	strh	r0, [r1, #0x14]
;                 }
700a47da: e7ff         	b	0x700a47dc <Sciclient_rmIrqVintAdd+0xec> @ imm = #-0x2
;             }
700a47dc: e7ff         	b	0x700a47de <Sciclient_rmIrqVintAdd+0xee> @ imm = #-0x2
;         }
700a47de: e7ff         	b	0x700a47e0 <Sciclient_rmIrqVintAdd+0xf0> @ imm = #-0x2
;     }
700a47e0: e7ff         	b	0x700a47e2 <Sciclient_rmIrqVintAdd+0xf2> @ imm = #-0x2
;     if (cfg_whole_route == true) {
700a47e2: f89d 0025    	ldrb.w	r0, [sp, #0x25]
700a47e6: 07c0         	lsls	r0, r0, #0x1f
700a47e8: b170         	cbz	r0, 0x700a4808 <Sciclient_rmIrqVintAdd+0x118> @ imm = #0x1c
700a47ea: e7ff         	b	0x700a47ec <Sciclient_rmIrqVintAdd+0xfc> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700a47ec: 980b         	ldr	r0, [sp, #0x2c]
700a47ee: f7f9 feb7    	bl	0x7009e560 <Sciclient_rmIrqFindRoute> @ imm = #-0x6292
700a47f2: 900a         	str	r0, [sp, #0x28]
;         if (r == SystemP_SUCCESS) {
700a47f4: 980a         	ldr	r0, [sp, #0x28]
700a47f6: b930         	cbnz	r0, 0x700a4806 <Sciclient_rmIrqVintAdd+0x116> @ imm = #0xc
700a47f8: e7ff         	b	0x700a47fa <Sciclient_rmIrqVintAdd+0x10a> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, true);
700a47fa: 980b         	ldr	r0, [sp, #0x2c]
700a47fc: 2101         	movs	r1, #0x1
700a47fe: f7fc fbe7    	bl	0x700a0fd0 <Sciclient_rmIrqProgramRoute> @ imm = #-0x3832
700a4802: 900a         	str	r0, [sp, #0x28]
;         }
700a4804: e7ff         	b	0x700a4806 <Sciclient_rmIrqVintAdd+0x116> @ imm = #-0x2
;     }
700a4806: e7ff         	b	0x700a4808 <Sciclient_rmIrqVintAdd+0x118> @ imm = #-0x2
;     return r;
700a4808: 980a         	ldr	r0, [sp, #0x28]
700a480a: b00c         	add	sp, #0x30
700a480c: bd80         	pop	{r7, pc}
700a480e: 0000         	movs	r0, r0

700a4810 <TaskP_loadUpdateAll>:
; {
700a4810: b580         	push	{r7, lr}
700a4812: b090         	sub	sp, #0x40
;     vTaskSuspendAll();
700a4814: f00b f9d4    	bl	0x700afbc0 <vTaskSuspendAll> @ imm = #0xb3a8
700a4818: 2000         	movs	r0, #0x0
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a481a: 9005         	str	r0, [sp, #0x14]
700a481c: e7ff         	b	0x700a481e <TaskP_loadUpdateAll+0xe> @ imm = #-0x2
700a481e: 9805         	ldr	r0, [sp, #0x14]
700a4820: 281f         	cmp	r0, #0x1f
700a4822: d837         	bhi	0x700a4894 <TaskP_loadUpdateAll+0x84> @ imm = #0x6e
700a4824: e7ff         	b	0x700a4826 <TaskP_loadUpdateAll+0x16> @ imm = #-0x2
;         if(gTaskP_ctrl.taskRegistry[i]!=NULL)
700a4826: 9905         	ldr	r1, [sp, #0x14]
700a4828: f644 5078    	movw	r0, #0x4d78
700a482c: f2c7 0008    	movt	r0, #0x7008
700a4830: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a4834: b348         	cbz	r0, 0x700a488a <TaskP_loadUpdateAll+0x7a> @ imm = #0x52
700a4836: e7ff         	b	0x700a4838 <TaskP_loadUpdateAll+0x28> @ imm = #-0x2
;             taskObj = gTaskP_ctrl.taskRegistry[i];
700a4838: 9905         	ldr	r1, [sp, #0x14]
700a483a: f644 5078    	movw	r0, #0x4d78
700a483e: f2c7 0008    	movt	r0, #0x7008
700a4842: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a4846: 900f         	str	r0, [sp, #0x3c]
;             vTaskGetInfo(taskObj->taskHndl, &taskStatus, pdFALSE, eReady);
700a4848: 980f         	ldr	r0, [sp, #0x3c]
700a484a: f8d0 0088    	ldr.w	r0, [r0, #0x88]
700a484e: a906         	add	r1, sp, #0x18
700a4850: 2200         	movs	r2, #0x0
700a4852: 2301         	movs	r3, #0x1
700a4854: f001 fbbc    	bl	0x700a5fd0 <vTaskGetInfo> @ imm = #0x1778
;             delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, taskObj->lastRunTime);
700a4858: 980c         	ldr	r0, [sp, #0x30]
700a485a: 990f         	ldr	r1, [sp, #0x3c]
700a485c: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a4860: f00a f9be    	bl	0x700aebe0 <TaskP_calcCounterDiff> @ imm = #0xa37c
700a4864: 9004         	str	r0, [sp, #0x10]
;             taskObj->accRunTime += delta;
700a4866: 9b04         	ldr	r3, [sp, #0x10]
700a4868: 990f         	ldr	r1, [sp, #0x3c]
700a486a: f8d1 2090    	ldr.w	r2, [r1, #0x90]
700a486e: f8d1 0094    	ldr.w	r0, [r1, #0x94]
700a4872: 18d2         	adds	r2, r2, r3
700a4874: f140 0000    	adc	r0, r0, #0x0
700a4878: f8c1 2090    	str.w	r2, [r1, #0x90]
700a487c: f8c1 0094    	str.w	r0, [r1, #0x94]
;             taskObj->lastRunTime = taskStatus.ulRunTimeCounter;
700a4880: 980c         	ldr	r0, [sp, #0x30]
700a4882: 990f         	ldr	r1, [sp, #0x3c]
700a4884: f8c1 008c    	str.w	r0, [r1, #0x8c]
;         }
700a4888: e7ff         	b	0x700a488a <TaskP_loadUpdateAll+0x7a> @ imm = #-0x2
;     }
700a488a: e7ff         	b	0x700a488c <TaskP_loadUpdateAll+0x7c> @ imm = #-0x2
;     for(i=0; i<TaskP_REGISTRY_MAX_ENTRIES; i++)
700a488c: 9805         	ldr	r0, [sp, #0x14]
700a488e: 3001         	adds	r0, #0x1
700a4890: 9005         	str	r0, [sp, #0x14]
700a4892: e7c4         	b	0x700a481e <TaskP_loadUpdateAll+0xe> @ imm = #-0x78
;     idleTskHndl = xTaskGetIdleTaskHandle();
700a4894: f00b fa04    	bl	0x700afca0 <xTaskGetIdleTaskHandle> @ imm = #0xb408
700a4898: 9002         	str	r0, [sp, #0x8]
;     if(idleTskHndl != NULL)
700a489a: 9802         	ldr	r0, [sp, #0x8]
700a489c: b310         	cbz	r0, 0x700a48e4 <TaskP_loadUpdateAll+0xd4> @ imm = #0x44
700a489e: e7ff         	b	0x700a48a0 <TaskP_loadUpdateAll+0x90> @ imm = #-0x2
;         vTaskGetInfo(idleTskHndl, &taskStatus, pdFALSE, eReady);
700a48a0: 9802         	ldr	r0, [sp, #0x8]
700a48a2: a906         	add	r1, sp, #0x18
700a48a4: 2200         	movs	r2, #0x0
700a48a6: 2301         	movs	r3, #0x1
700a48a8: f001 fb92    	bl	0x700a5fd0 <vTaskGetInfo> @ imm = #0x1724
;         delta = TaskP_calcCounterDiff(taskStatus.ulRunTimeCounter, gTaskP_ctrl.idleTskLastRunTime);
700a48ac: 980c         	ldr	r0, [sp, #0x30]
700a48ae: f644 5178    	movw	r1, #0x4d78
700a48b2: f2c7 0108    	movt	r1, #0x7008
700a48b6: 9101         	str	r1, [sp, #0x4]
700a48b8: f8d1 1090    	ldr.w	r1, [r1, #0x90]
700a48bc: f00a f990    	bl	0x700aebe0 <TaskP_calcCounterDiff> @ imm = #0xa320
700a48c0: 9901         	ldr	r1, [sp, #0x4]
700a48c2: 9004         	str	r0, [sp, #0x10]
;         gTaskP_ctrl.idleTskAccRunTime += delta;
700a48c4: 9b04         	ldr	r3, [sp, #0x10]
700a48c6: f8d1 2098    	ldr.w	r2, [r1, #0x98]
700a48ca: f8d1 009c    	ldr.w	r0, [r1, #0x9c]
700a48ce: 18d2         	adds	r2, r2, r3
700a48d0: f140 0000    	adc	r0, r0, #0x0
700a48d4: f8c1 2098    	str.w	r2, [r1, #0x98]
700a48d8: f8c1 009c    	str.w	r0, [r1, #0x9c]
;         gTaskP_ctrl.idleTskLastRunTime = taskStatus.ulRunTimeCounter;
700a48dc: 980c         	ldr	r0, [sp, #0x30]
700a48de: f8c1 0090    	str.w	r0, [r1, #0x90]
;     }
700a48e2: e7ff         	b	0x700a48e4 <TaskP_loadUpdateAll+0xd4> @ imm = #-0x2
;     curTotalTime = portGET_RUN_TIME_COUNTER_VALUE();
700a48e4: f00b f8e4    	bl	0x700afab0 <uiPortGetRunTimeCounterValue> @ imm = #0xb1c8
700a48e8: 9003         	str	r0, [sp, #0xc]
;     delta = TaskP_calcCounterDiff(curTotalTime, gTaskP_ctrl.lastTotalTime);
700a48ea: 9803         	ldr	r0, [sp, #0xc]
700a48ec: f644 5178    	movw	r1, #0x4d78
700a48f0: f2c7 0108    	movt	r1, #0x7008
700a48f4: 9100         	str	r1, [sp]
700a48f6: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700a48fa: f00a f971    	bl	0x700aebe0 <TaskP_calcCounterDiff> @ imm = #0xa2e2
700a48fe: 9900         	ldr	r1, [sp]
700a4900: 9004         	str	r0, [sp, #0x10]
;     gTaskP_ctrl.accTotalTime += delta;
700a4902: 9b04         	ldr	r3, [sp, #0x10]
700a4904: f8d1 2088    	ldr.w	r2, [r1, #0x88]
700a4908: f8d1 008c    	ldr.w	r0, [r1, #0x8c]
700a490c: 18d2         	adds	r2, r2, r3
700a490e: f140 0000    	adc	r0, r0, #0x0
700a4912: f8c1 2088    	str.w	r2, [r1, #0x88]
700a4916: f8c1 008c    	str.w	r0, [r1, #0x8c]
;     gTaskP_ctrl.lastTotalTime = curTotalTime;
700a491a: 9803         	ldr	r0, [sp, #0xc]
700a491c: f8c1 0080    	str.w	r0, [r1, #0x80]
;     (void)xTaskResumeAll();
700a4920: f7fd fcb6    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0x2694
; }
700a4924: b010         	add	sp, #0x40
700a4926: bd80         	pop	{r7, pc}

700a4928 <__udivmoddi4>:
700a4928: e1530001     	cmp	r3, r1
700a492c: 01520000     	cmpeq	r2, r0
700a4930: 9a000007     	bls	0x700a4954 <__udivmoddi4+0x2c> @ imm = #0x1c
700a4934: e59d2000     	ldr	r2, [sp]
700a4938: e3520000     	cmp	r2, #0
700a493c: 0a000001     	beq	0x700a4948 <__udivmoddi4+0x20> @ imm = #0x4
700a4940: e5820000     	str	r0, [r2]
700a4944: e5821004     	str	r1, [r2, #0x4]
700a4948: e3b01000     	movs	r1, #0
700a494c: e3b00000     	movs	r0, #0
700a4950: e12fff1e     	bx	lr
700a4954: e3530000     	cmp	r3, #0
700a4958: 03520000     	cmpeq	r2, #0
700a495c: 1a00000d     	bne	0x700a4998 <__udivmoddi4+0x70> @ imm = #0x34
700a4960: e59d2000     	ldr	r2, [sp]
700a4964: e3520000     	cmp	r2, #0
700a4968: 0a000001     	beq	0x700a4974 <__udivmoddi4+0x4c> @ imm = #0x4
700a496c: e5820000     	str	r0, [r2]
700a4970: e5821004     	str	r1, [r2, #0x4]
700a4974: e1b02000     	movs	r2, r0
700a4978: e1b03001     	movs	r3, r1
700a497c: e3b01000     	movs	r1, #0
700a4980: e3b00000     	movs	r0, #0
700a4984: e3530000     	cmp	r3, #0
700a4988: 03520000     	cmpeq	r2, #0
700a498c: 11e01001     	mvnne	r1, r1
700a4990: 11e00000     	mvnne	r0, r0
700a4994: ea002cf5     	b	0x700afd70 <__aeabi_ldiv0> @ imm = #0xb3d4
700a4998: e92d40f0     	push	{r4, r5, r6, r7, lr}
700a499c: e1a04003     	mov	r4, r3
700a49a0: e1a05002     	mov	r5, r2
700a49a4: e1a03001     	mov	r3, r1
700a49a8: e1a02000     	mov	r2, r0
700a49ac: e3b00000     	movs	r0, #0
700a49b0: e3b01000     	movs	r1, #0
700a49b4: e16f6f14     	clz	r6, r4
700a49b8: e3560020     	cmp	r6, #32
700a49bc: 016f6f15     	clzeq	r6, r5
700a49c0: 02866020     	addeq	r6, r6, #32
700a49c4: e16f7f13     	clz	r7, r3
700a49c8: e3570020     	cmp	r7, #32
700a49cc: 016f7f12     	clzeq	r7, r2
700a49d0: 02877020     	addeq	r7, r7, #32
700a49d4: e0566007     	subs	r6, r6, r7
700a49d8: e2567020     	subs	r7, r6, #32
700a49dc: 21a04715     	lslhs	r4, r5, r7
700a49e0: 23a05000     	movhs	r5, #0
700a49e4: 32677000     	rsblo	r7, r7, #0
700a49e8: 31a04614     	lsllo	r4, r4, r6
700a49ec: 31a07735     	lsrlo	r7, r5, r7
700a49f0: 31844007     	orrlo	r4, r4, r7
700a49f4: 31a05615     	lsllo	r5, r5, r6
700a49f8: e1530004     	cmp	r3, r4
700a49fc: 01520005     	cmpeq	r2, r5
700a4a00: 3a000001     	blo	0x700a4a0c <__udivmoddi4+0xe4> @ imm = #0x4
700a4a04: e0522005     	subs	r2, r2, r5
700a4a08: e0d33004     	sbcs	r3, r3, r4
700a4a0c: e0b00000     	adcs	r0, r0, r0
700a4a10: e0b11001     	adcs	r1, r1, r1
700a4a14: e1b050a5     	lsrs	r5, r5, #1
700a4a18: e1855f84     	orr	r5, r5, r4, lsl #31
700a4a1c: e1b040a4     	lsrs	r4, r4, #1
700a4a20: e2566001     	subs	r6, r6, #1
700a4a24: 5afffff3     	bpl	0x700a49f8 <__udivmoddi4+0xd0> @ imm = #-0x34
700a4a28: e59d7014     	ldr	r7, [sp, #0x14]
700a4a2c: e3570000     	cmp	r7, #0
700a4a30: 0a000001     	beq	0x700a4a3c <__udivmoddi4+0x114> @ imm = #0x4
700a4a34: e5872000     	str	r2, [r7]
700a4a38: e5873004     	str	r3, [r7, #0x4]
700a4a3c: e8bd80f0     	pop	{r4, r5, r6, r7, pc}

700a4a40 <CSL_bcdmaChanOpDecChanStats>:
; {
700a4a40: b580         	push	{r7, lr}
700a4a42: b088         	sub	sp, #0x20
700a4a44: 9007         	str	r0, [sp, #0x1c]
700a4a46: 9106         	str	r1, [sp, #0x18]
700a4a48: 9205         	str	r2, [sp, #0x14]
700a4a4a: 9304         	str	r3, [sp, #0x10]
700a4a4c: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a4a4e: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a4a50: 9804         	ldr	r0, [sp, #0x10]
700a4a52: b920         	cbnz	r0, 0x700a4a5e <CSL_bcdmaChanOpDecChanStats+0x1e> @ imm = #0x8
700a4a54: e7ff         	b	0x700a4a56 <CSL_bcdmaChanOpDecChanStats+0x16> @ imm = #-0x2
700a4a56: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a4a5a: 9003         	str	r0, [sp, #0xc]
;     }
700a4a5c: e078         	b	0x700a4b50 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #0xf0
;         CSL_BcdmaChanStats *pChanStats = (CSL_BcdmaChanStats *)pOpData;
700a4a5e: 9804         	ldr	r0, [sp, #0x10]
700a4a60: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a4a62: 9806         	ldr	r0, [sp, #0x18]
700a4a64: 9001         	str	r0, [sp, #0x4]
700a4a66: b140         	cbz	r0, 0x700a4a7a <CSL_bcdmaChanOpDecChanStats+0x3a> @ imm = #0x10
700a4a68: e7ff         	b	0x700a4a6a <CSL_bcdmaChanOpDecChanStats+0x2a> @ imm = #-0x2
700a4a6a: 9801         	ldr	r0, [sp, #0x4]
700a4a6c: 2801         	cmp	r0, #0x1
700a4a6e: d026         	beq	0x700a4abe <CSL_bcdmaChanOpDecChanStats+0x7e> @ imm = #0x4c
700a4a70: e7ff         	b	0x700a4a72 <CSL_bcdmaChanOpDecChanStats+0x32> @ imm = #-0x2
700a4a72: 9801         	ldr	r0, [sp, #0x4]
700a4a74: 2802         	cmp	r0, #0x2
700a4a76: d044         	beq	0x700a4b02 <CSL_bcdmaChanOpDecChanStats+0xc2> @ imm = #0x88
700a4a78: e065         	b	0x700a4b46 <CSL_bcdmaChanOpDecChanStats+0x106> @ imm = #0xca
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a4a7a: 9807         	ldr	r0, [sp, #0x1c]
700a4a7c: 6880         	ldr	r0, [r0, #0x8]
700a4a7e: 9905         	ldr	r1, [sp, #0x14]
700a4a80: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4a84: f500 6080    	add.w	r0, r0, #0x400
700a4a88: 9902         	ldr	r1, [sp, #0x8]
700a4a8a: 6809         	ldr	r1, [r1]
700a4a8c: f7f7 fc00    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x8800
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a4a90: 9807         	ldr	r0, [sp, #0x1c]
700a4a92: 6880         	ldr	r0, [r0, #0x8]
700a4a94: 9905         	ldr	r1, [sp, #0x14]
700a4a96: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4a9a: f500 6081    	add.w	r0, r0, #0x408
700a4a9e: 9902         	ldr	r1, [sp, #0x8]
700a4aa0: 6849         	ldr	r1, [r1, #0x4]
700a4aa2: f7f7 fbf5    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x8816
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a4aa6: 9807         	ldr	r0, [sp, #0x1c]
700a4aa8: 6880         	ldr	r0, [r0, #0x8]
700a4aaa: 9905         	ldr	r1, [sp, #0x14]
700a4aac: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4ab0: f500 6082    	add.w	r0, r0, #0x410
700a4ab4: 9902         	ldr	r1, [sp, #0x8]
700a4ab6: 6889         	ldr	r1, [r1, #0x8]
700a4ab8: f7f7 fbea    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x882c
;                 break;
700a4abc: e047         	b	0x700a4b4e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x8e
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a4abe: 9807         	ldr	r0, [sp, #0x1c]
700a4ac0: 6900         	ldr	r0, [r0, #0x10]
700a4ac2: 9905         	ldr	r1, [sp, #0x14]
700a4ac4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4ac8: f500 6080    	add.w	r0, r0, #0x400
700a4acc: 9902         	ldr	r1, [sp, #0x8]
700a4ace: 6809         	ldr	r1, [r1]
700a4ad0: f7f7 fbde    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x8844
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->txPayloadByteCnt );
700a4ad4: 9807         	ldr	r0, [sp, #0x1c]
700a4ad6: 6900         	ldr	r0, [r0, #0x10]
700a4ad8: 9905         	ldr	r1, [sp, #0x14]
700a4ada: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4ade: f500 6081    	add.w	r0, r0, #0x408
700a4ae2: 9902         	ldr	r1, [sp, #0x8]
700a4ae4: 6849         	ldr	r1, [r1, #0x4]
700a4ae6: f7f7 fbd3    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x885a
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->txStartedByteCnt );
700a4aea: 9807         	ldr	r0, [sp, #0x1c]
700a4aec: 6900         	ldr	r0, [r0, #0x10]
700a4aee: 9905         	ldr	r1, [sp, #0x14]
700a4af0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4af4: f500 6082    	add.w	r0, r0, #0x410
700a4af8: 9902         	ldr	r1, [sp, #0x8]
700a4afa: 6889         	ldr	r1, [r1, #0x8]
700a4afc: f7f7 fbc8    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x8870
;                 break;
700a4b00: e025         	b	0x700a4b4e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x4a
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].PCNT,   pChanStats->packetCnt );
700a4b02: 9807         	ldr	r0, [sp, #0x1c]
700a4b04: 6980         	ldr	r0, [r0, #0x18]
700a4b06: 9905         	ldr	r1, [sp, #0x14]
700a4b08: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4b0c: f500 6080    	add.w	r0, r0, #0x400
700a4b10: 9902         	ldr	r1, [sp, #0x8]
700a4b12: 6809         	ldr	r1, [r1]
700a4b14: f7f7 fbbc    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x8888
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].BCNT,   pChanStats->rxPayloadByteCnt );
700a4b18: 9807         	ldr	r0, [sp, #0x1c]
700a4b1a: 6980         	ldr	r0, [r0, #0x18]
700a4b1c: 9905         	ldr	r1, [sp, #0x14]
700a4b1e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4b22: f500 6081    	add.w	r0, r0, #0x408
700a4b26: 9902         	ldr	r1, [sp, #0x8]
700a4b28: 68c9         	ldr	r1, [r1, #0xc]
700a4b2a: f7f7 fbb1    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x889e
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].SBCNT,  pChanStats->rxStartedByteCnt );
700a4b2e: 9807         	ldr	r0, [sp, #0x1c]
700a4b30: 6980         	ldr	r0, [r0, #0x18]
700a4b32: 9905         	ldr	r1, [sp, #0x14]
700a4b34: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a4b38: f500 6082    	add.w	r0, r0, #0x410
700a4b3c: 9902         	ldr	r1, [sp, #0x8]
700a4b3e: 6909         	ldr	r1, [r1, #0x10]
700a4b40: f7f7 fba6    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x88b4
;                 break;
700a4b44: e003         	b	0x700a4b4e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #0x6
700a4b46: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a4b4a: 9003         	str	r0, [sp, #0xc]
;                 break;
700a4b4c: e7ff         	b	0x700a4b4e <CSL_bcdmaChanOpDecChanStats+0x10e> @ imm = #-0x2
700a4b4e: e7ff         	b	0x700a4b50 <CSL_bcdmaChanOpDecChanStats+0x110> @ imm = #-0x2
;     return retVal;
700a4b50: 9803         	ldr	r0, [sp, #0xc]
700a4b52: b008         	add	sp, #0x20
700a4b54: bd80         	pop	{r7, pc}
		...
700a4b5e: 0000         	movs	r0, r0

700a4b60 <UART_divisorLatchWrite>:
; {
700a4b60: b580         	push	{r7, lr}
700a4b62: b08c         	sub	sp, #0x30
700a4b64: 900b         	str	r0, [sp, #0x2c]
700a4b66: 910a         	str	r1, [sp, #0x28]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a4b68: 980b         	ldr	r0, [sp, #0x2c]
700a4b6a: 21bf         	movs	r1, #0xbf
700a4b6c: 9102         	str	r1, [sp, #0x8]
700a4b6e: f007 fe07    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x7c0e
700a4b72: 9007         	str	r0, [sp, #0x1c]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a4b74: 980b         	ldr	r0, [sp, #0x2c]
700a4b76: 3008         	adds	r0, #0x8
700a4b78: 2110         	movs	r1, #0x10
700a4b7a: 9103         	str	r1, [sp, #0xc]
700a4b7c: 2204         	movs	r2, #0x4
700a4b7e: 9204         	str	r2, [sp, #0x10]
700a4b80: f00a fbde    	bl	0x700af340 <HW_RD_FIELD32_RAW> @ imm = #0xa7bc
700a4b84: 9903         	ldr	r1, [sp, #0xc]
700a4b86: 9a04         	ldr	r2, [sp, #0x10]
700a4b88: 9009         	str	r0, [sp, #0x24]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a4b8a: 980b         	ldr	r0, [sp, #0x2c]
700a4b8c: 3008         	adds	r0, #0x8
700a4b8e: 2301         	movs	r3, #0x1
700a4b90: f009 fd8e    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x9b1c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4b94: 980b         	ldr	r0, [sp, #0x2c]
700a4b96: 300c         	adds	r0, #0xc
700a4b98: 9907         	ldr	r1, [sp, #0x1c]
700a4b9a: f00a fff1    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0xafe2
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a4b9e: 980b         	ldr	r0, [sp, #0x2c]
700a4ba0: 217f         	movs	r1, #0x7f
700a4ba2: 9101         	str	r1, [sp, #0x4]
700a4ba4: f007 fdec    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x7bd8
700a4ba8: 9903         	ldr	r1, [sp, #0xc]
700a4baa: 9a04         	ldr	r2, [sp, #0x10]
700a4bac: 9007         	str	r0, [sp, #0x1c]
;     sleepMdBitVal = HW_RD_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE);
700a4bae: 980b         	ldr	r0, [sp, #0x2c]
700a4bb0: 3004         	adds	r0, #0x4
700a4bb2: f00a fbc5    	bl	0x700af340 <HW_RD_FIELD32_RAW> @ imm = #0xa78a
700a4bb6: 9903         	ldr	r1, [sp, #0xc]
700a4bb8: 9a04         	ldr	r2, [sp, #0x10]
700a4bba: 9008         	str	r0, [sp, #0x20]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, 0U);
700a4bbc: 980b         	ldr	r0, [sp, #0x2c]
700a4bbe: 3004         	adds	r0, #0x4
700a4bc0: 2300         	movs	r3, #0x0
700a4bc2: f009 fd75    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x9aea
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4bc6: 980b         	ldr	r0, [sp, #0x2c]
700a4bc8: 300c         	adds	r0, #0xc
700a4bca: 9907         	ldr	r1, [sp, #0x1c]
700a4bcc: f00a ffd8    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0xafb0
700a4bd0: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a4bd2: 980b         	ldr	r0, [sp, #0x2c]
700a4bd4: f007 fdd4    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x7ba8
700a4bd8: 9007         	str	r0, [sp, #0x1c]
;     divRegVal  = HW_RD_REG32(baseAddr + UART_DLL) & 0xFFU;
700a4bda: 980b         	ldr	r0, [sp, #0x2c]
700a4bdc: f00a ffc8    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0xaf90
700a4be0: b2c0         	uxtb	r0, r0
700a4be2: 9005         	str	r0, [sp, #0x14]
;     divRegVal |= (HW_RD_REG32(baseAddr + UART_DLH) & 0x3FU) << 8;
700a4be4: 980b         	ldr	r0, [sp, #0x2c]
700a4be6: 3004         	adds	r0, #0x4
700a4be8: f00a ffc2    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0xaf84
700a4bec: f000 013f    	and	r1, r0, #0x3f
700a4bf0: 9805         	ldr	r0, [sp, #0x14]
700a4bf2: ea40 2001    	orr.w	r0, r0, r1, lsl #8
700a4bf6: 9005         	str	r0, [sp, #0x14]
;     operMode = UART_operatingModeSelect(baseAddr,
700a4bf8: 980b         	ldr	r0, [sp, #0x2c]
700a4bfa: 2107         	movs	r1, #0x7
700a4bfc: f00a f910    	bl	0x700aee20 <UART_operatingModeSelect> @ imm = #0xa220
700a4c00: 9006         	str	r0, [sp, #0x18]
;     HW_WR_REG32(baseAddr + UART_DLL, divisorValue & 0x00FFU);
700a4c02: 980b         	ldr	r0, [sp, #0x2c]
700a4c04: f89d 1028    	ldrb.w	r1, [sp, #0x28]
700a4c08: f00a ffba    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0xaf74
;     HW_WR_REG32(baseAddr + UART_DLH, (divisorValue & 0x3F00U) >> 8);
700a4c0c: 980b         	ldr	r0, [sp, #0x2c]
700a4c0e: 3004         	adds	r0, #0x4
700a4c10: 990a         	ldr	r1, [sp, #0x28]
700a4c12: f3c1 2105    	ubfx	r1, r1, #0x8, #0x6
700a4c16: f00a ffb3    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0xaf66
;     (void) UART_operatingModeSelect(baseAddr, operMode);
700a4c1a: 980b         	ldr	r0, [sp, #0x2c]
700a4c1c: 9906         	ldr	r1, [sp, #0x18]
700a4c1e: f00a f8ff    	bl	0x700aee20 <UART_operatingModeSelect> @ imm = #0xa1fe
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4c22: 980b         	ldr	r0, [sp, #0x2c]
700a4c24: 300c         	adds	r0, #0xc
700a4c26: 9907         	ldr	r1, [sp, #0x1c]
700a4c28: f00a ffaa    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0xaf54
700a4c2c: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700a4c2e: 980b         	ldr	r0, [sp, #0x2c]
700a4c30: f007 fda6    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x7b4c
700a4c34: 9903         	ldr	r1, [sp, #0xc]
700a4c36: 9a04         	ldr	r2, [sp, #0x10]
700a4c38: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_IER, UART_IER_SLEEP_MODE, sleepMdBitVal);
700a4c3a: 980b         	ldr	r0, [sp, #0x2c]
700a4c3c: 3004         	adds	r0, #0x4
700a4c3e: 9b08         	ldr	r3, [sp, #0x20]
700a4c40: f009 fd36    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x9a6c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4c44: 980b         	ldr	r0, [sp, #0x2c]
700a4c46: 300c         	adds	r0, #0xc
700a4c48: 9907         	ldr	r1, [sp, #0x1c]
700a4c4a: f00a ff99    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0xaf32
700a4c4e: 9902         	ldr	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a4c50: 980b         	ldr	r0, [sp, #0x2c]
700a4c52: f007 fd95    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x7b2a
700a4c56: 9903         	ldr	r1, [sp, #0xc]
700a4c58: 9a04         	ldr	r2, [sp, #0x10]
700a4c5a: 9007         	str	r0, [sp, #0x1c]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a4c5c: 980b         	ldr	r0, [sp, #0x2c]
700a4c5e: 3008         	adds	r0, #0x8
700a4c60: 9b09         	ldr	r3, [sp, #0x24]
700a4c62: f009 fd25    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x9a4a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a4c66: 980b         	ldr	r0, [sp, #0x2c]
700a4c68: 300c         	adds	r0, #0xc
700a4c6a: 9907         	ldr	r1, [sp, #0x1c]
700a4c6c: f00a ff88    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0xaf10
;     return divRegVal;
700a4c70: 9805         	ldr	r0, [sp, #0x14]
700a4c72: b00c         	add	sp, #0x30
700a4c74: bd80         	pop	{r7, pc}
		...
700a4c7e: 0000         	movs	r0, r0

700a4c80 <_ntoa_long>:
; {
700a4c80: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
700a4c84: b098         	sub	sp, #0x60
700a4c86: 4684         	mov	r12, r0
700a4c88: 9823         	ldr	r0, [sp, #0x8c]
700a4c8a: 9822         	ldr	r0, [sp, #0x88]
700a4c8c: 9821         	ldr	r0, [sp, #0x84]
700a4c8e: 9820         	ldr	r0, [sp, #0x80]
700a4c90: 981f         	ldr	r0, [sp, #0x7c]
700a4c92: f8dd e078    	ldr.w	lr, [sp, #0x78]
700a4c96: f8cd c05c    	str.w	r12, [sp, #0x5c]
700a4c9a: 9116         	str	r1, [sp, #0x58]
700a4c9c: 9215         	str	r2, [sp, #0x54]
700a4c9e: 9314         	str	r3, [sp, #0x50]
700a4ca0: f88d 004f    	strb.w	r0, [sp, #0x4f]
700a4ca4: 2000         	movs	r0, #0x0
;   size_t len = 0U;
700a4ca6: 900a         	str	r0, [sp, #0x28]
;   if (!value) {
700a4ca8: 981e         	ldr	r0, [sp, #0x78]
700a4caa: b928         	cbnz	r0, 0x700a4cb8 <_ntoa_long+0x38> @ imm = #0xa
700a4cac: e7ff         	b	0x700a4cae <_ntoa_long+0x2e> @ imm = #-0x2
;     flags &= ~FLAGS_HASH;
700a4cae: 9823         	ldr	r0, [sp, #0x8c]
700a4cb0: f020 0010    	bic	r0, r0, #0x10
700a4cb4: 9023         	str	r0, [sp, #0x8c]
;   }
700a4cb6: e7ff         	b	0x700a4cb8 <_ntoa_long+0x38> @ imm = #-0x2
;   if (!(flags & FLAGS_PRECISION) || value) {
700a4cb8: f89d 008d    	ldrb.w	r0, [sp, #0x8d]
700a4cbc: 0740         	lsls	r0, r0, #0x1d
700a4cbe: 2800         	cmp	r0, #0x0
700a4cc0: d504         	bpl	0x700a4ccc <_ntoa_long+0x4c> @ imm = #0x8
700a4cc2: e7ff         	b	0x700a4cc4 <_ntoa_long+0x44> @ imm = #-0x2
700a4cc4: 981e         	ldr	r0, [sp, #0x78]
700a4cc6: 2800         	cmp	r0, #0x0
700a4cc8: d03f         	beq	0x700a4d4a <_ntoa_long+0xca> @ imm = #0x7e
700a4cca: e7ff         	b	0x700a4ccc <_ntoa_long+0x4c> @ imm = #-0x2
;     do {
700a4ccc: e7ff         	b	0x700a4cce <_ntoa_long+0x4e> @ imm = #-0x2
;       const char digit = (char)(value % base);
700a4cce: 9a1e         	ldr	r2, [sp, #0x78]
700a4cd0: 9920         	ldr	r1, [sp, #0x80]
700a4cd2: fbb2 f0f1    	udiv	r0, r2, r1
700a4cd6: fb00 2011    	mls	r0, r0, r1, r2
700a4cda: f88d 0027    	strb.w	r0, [sp, #0x27]
;       buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
700a4cde: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a4ce2: 2809         	cmp	r0, #0x9
700a4ce4: dc05         	bgt	0x700a4cf2 <_ntoa_long+0x72> @ imm = #0xa
700a4ce6: e7ff         	b	0x700a4ce8 <_ntoa_long+0x68> @ imm = #-0x2
700a4ce8: f89d 0027    	ldrb.w	r0, [sp, #0x27]
700a4cec: 3030         	adds	r0, #0x30
700a4cee: 9008         	str	r0, [sp, #0x20]
700a4cf0: e00c         	b	0x700a4d0c <_ntoa_long+0x8c> @ imm = #0x18
700a4cf2: f89d 008c    	ldrb.w	r0, [sp, #0x8c]
700a4cf6: 0681         	lsls	r1, r0, #0x1a
700a4cf8: 2061         	movs	r0, #0x61
700a4cfa: 2900         	cmp	r1, #0x0
700a4cfc: bf48         	it	mi
700a4cfe: 2041         	movmi	r0, #0x41
700a4d00: f89d 1027    	ldrb.w	r1, [sp, #0x27]
700a4d04: 4408         	add	r0, r1
700a4d06: 380a         	subs	r0, #0xa
700a4d08: 9008         	str	r0, [sp, #0x20]
700a4d0a: e7ff         	b	0x700a4d0c <_ntoa_long+0x8c> @ imm = #-0x2
700a4d0c: 9808         	ldr	r0, [sp, #0x20]
700a4d0e: 9a0a         	ldr	r2, [sp, #0x28]
700a4d10: 1c51         	adds	r1, r2, #0x1
700a4d12: 910a         	str	r1, [sp, #0x28]
700a4d14: f10d 012f    	add.w	r1, sp, #0x2f
700a4d18: 5488         	strb	r0, [r1, r2]
;       value /= base;
700a4d1a: 9920         	ldr	r1, [sp, #0x80]
700a4d1c: 981e         	ldr	r0, [sp, #0x78]
700a4d1e: fbb0 f0f1    	udiv	r0, r0, r1
700a4d22: 901e         	str	r0, [sp, #0x78]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a4d24: e7ff         	b	0x700a4d26 <_ntoa_long+0xa6> @ imm = #-0x2
700a4d26: 991e         	ldr	r1, [sp, #0x78]
700a4d28: 2000         	movs	r0, #0x0
700a4d2a: 9007         	str	r0, [sp, #0x1c]
700a4d2c: b139         	cbz	r1, 0x700a4d3e <_ntoa_long+0xbe> @ imm = #0xe
700a4d2e: e7ff         	b	0x700a4d30 <_ntoa_long+0xb0> @ imm = #-0x2
700a4d30: 990a         	ldr	r1, [sp, #0x28]
700a4d32: 2000         	movs	r0, #0x0
700a4d34: 2920         	cmp	r1, #0x20
700a4d36: bf38         	it	lo
700a4d38: 2001         	movlo	r0, #0x1
700a4d3a: 9007         	str	r0, [sp, #0x1c]
700a4d3c: e7ff         	b	0x700a4d3e <_ntoa_long+0xbe> @ imm = #-0x2
700a4d3e: 9807         	ldr	r0, [sp, #0x1c]
;     } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
700a4d40: 07c0         	lsls	r0, r0, #0x1f
700a4d42: 2800         	cmp	r0, #0x0
700a4d44: d1c3         	bne	0x700a4cce <_ntoa_long+0x4e> @ imm = #-0x7a
700a4d46: e7ff         	b	0x700a4d48 <_ntoa_long+0xc8> @ imm = #-0x2
;   }
700a4d48: e7ff         	b	0x700a4d4a <_ntoa_long+0xca> @ imm = #-0x2
;   return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
700a4d4a: 9817         	ldr	r0, [sp, #0x5c]
700a4d4c: 9916         	ldr	r1, [sp, #0x58]
700a4d4e: 9a15         	ldr	r2, [sp, #0x54]
700a4d50: 9b14         	ldr	r3, [sp, #0x50]
700a4d52: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a4d56: 9d20         	ldr	r5, [sp, #0x80]
700a4d58: 9e21         	ldr	r6, [sp, #0x84]
700a4d5a: 9f22         	ldr	r7, [sp, #0x88]
700a4d5c: f8dd 808c    	ldr.w	r8, [sp, #0x8c]
700a4d60: f89d 404f    	ldrb.w	r4, [sp, #0x4f]
700a4d64: 46ee         	mov	lr, sp
700a4d66: f8ce 8018    	str.w	r8, [lr, #0x18]
700a4d6a: f8ce 7014    	str.w	r7, [lr, #0x14]
700a4d6e: f8ce 6010    	str.w	r6, [lr, #0x10]
700a4d72: f8ce 500c    	str.w	r5, [lr, #0xc]
700a4d76: f004 0401    	and	r4, r4, #0x1
700a4d7a: f8ce 4008    	str.w	r4, [lr, #0x8]
700a4d7e: f8ce c004    	str.w	r12, [lr, #0x4]
700a4d82: f10d 0c2f    	add.w	r12, sp, #0x2f
700a4d86: f8ce c000    	str.w	r12, [lr]
700a4d8a: f7f9 fe39    	bl	0x7009ea00 <_ntoa_format> @ imm = #-0x638e
700a4d8e: b018         	add	sp, #0x60
700a4d90: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
		...

700a4da0 <prvInitialiseNewTask>:
;     const MemoryRegion_t *const xRegions) {
700a4da0: b580         	push	{r7, lr}
700a4da2: b088         	sub	sp, #0x20
700a4da4: f8dd c034    	ldr.w	r12, [sp, #0x34]
700a4da8: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a4dac: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a4db0: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a4db4: 9007         	str	r0, [sp, #0x1c]
700a4db6: 9106         	str	r1, [sp, #0x18]
700a4db8: 9205         	str	r2, [sp, #0x14]
700a4dba: 9304         	str	r3, [sp, #0x10]
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a4dbc: 980c         	ldr	r0, [sp, #0x30]
700a4dbe: 6b00         	ldr	r0, [r0, #0x30]
;                  (size_t)ulStackDepth * sizeof(StackType_t));
700a4dc0: 9905         	ldr	r1, [sp, #0x14]
700a4dc2: 0089         	lsls	r1, r1, #0x2
700a4dc4: 22a5         	movs	r2, #0xa5
;     (void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE,
700a4dc6: f00a eeec    	blx	0x700afba0 <__aeabi_memset8> @ imm = #0xadd8
;     pxTopOfStack = &(pxNewTCB->pxStack[ulStackDepth - (uint32_t)1]);
700a4dca: 980c         	ldr	r0, [sp, #0x30]
700a4dcc: 6b00         	ldr	r0, [r0, #0x30]
700a4dce: 9905         	ldr	r1, [sp, #0x14]
700a4dd0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a4dd4: 3804         	subs	r0, #0x4
700a4dd6: 9003         	str	r0, [sp, #0xc]
;              *)(((portPOINTER_SIZE_TYPE)pxTopOfStack) &
700a4dd8: 9803         	ldr	r0, [sp, #0xc]
700a4dda: f020 0007    	bic	r0, r0, #0x7
;     pxTopOfStack =
700a4dde: 9003         	str	r0, [sp, #0xc]
;   if (pcName != NULL) {
700a4de0: 9806         	ldr	r0, [sp, #0x18]
700a4de2: b1f8         	cbz	r0, 0x700a4e24 <prvInitialiseNewTask+0x84> @ imm = #0x3e
700a4de4: e7ff         	b	0x700a4de6 <prvInitialiseNewTask+0x46> @ imm = #-0x2
700a4de6: 2000         	movs	r0, #0x0
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a4de8: 9002         	str	r0, [sp, #0x8]
700a4dea: e7ff         	b	0x700a4dec <prvInitialiseNewTask+0x4c> @ imm = #-0x2
700a4dec: 9802         	ldr	r0, [sp, #0x8]
700a4dee: 281f         	cmp	r0, #0x1f
700a4df0: d813         	bhi	0x700a4e1a <prvInitialiseNewTask+0x7a> @ imm = #0x26
700a4df2: e7ff         	b	0x700a4df4 <prvInitialiseNewTask+0x54> @ imm = #-0x2
;       pxNewTCB->pcTaskName[x] = pcName[x];
700a4df4: 9806         	ldr	r0, [sp, #0x18]
700a4df6: 9a02         	ldr	r2, [sp, #0x8]
700a4df8: 5c80         	ldrb	r0, [r0, r2]
700a4dfa: 990c         	ldr	r1, [sp, #0x30]
700a4dfc: 4411         	add	r1, r2
700a4dfe: f881 0034    	strb.w	r0, [r1, #0x34]
;       if (pcName[x] == (char)0x00) {
700a4e02: 9806         	ldr	r0, [sp, #0x18]
700a4e04: 9902         	ldr	r1, [sp, #0x8]
700a4e06: 5c40         	ldrb	r0, [r0, r1]
700a4e08: b908         	cbnz	r0, 0x700a4e0e <prvInitialiseNewTask+0x6e> @ imm = #0x2
700a4e0a: e7ff         	b	0x700a4e0c <prvInitialiseNewTask+0x6c> @ imm = #-0x2
;         break;
700a4e0c: e005         	b	0x700a4e1a <prvInitialiseNewTask+0x7a> @ imm = #0xa
700a4e0e: e7ff         	b	0x700a4e10 <prvInitialiseNewTask+0x70> @ imm = #-0x2
;     }
700a4e10: e7ff         	b	0x700a4e12 <prvInitialiseNewTask+0x72> @ imm = #-0x2
;     for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
700a4e12: 9802         	ldr	r0, [sp, #0x8]
700a4e14: 3001         	adds	r0, #0x1
700a4e16: 9002         	str	r0, [sp, #0x8]
700a4e18: e7e8         	b	0x700a4dec <prvInitialiseNewTask+0x4c> @ imm = #-0x30
;     pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
700a4e1a: 990c         	ldr	r1, [sp, #0x30]
700a4e1c: 2000         	movs	r0, #0x0
700a4e1e: f881 0053    	strb.w	r0, [r1, #0x53]
;   } else {
700a4e22: e004         	b	0x700a4e2e <prvInitialiseNewTask+0x8e> @ imm = #0x8
;     pxNewTCB->pcTaskName[0] = 0x00;
700a4e24: 990c         	ldr	r1, [sp, #0x30]
700a4e26: 2000         	movs	r0, #0x0
700a4e28: f881 0034    	strb.w	r0, [r1, #0x34]
700a4e2c: e7ff         	b	0x700a4e2e <prvInitialiseNewTask+0x8e> @ imm = #-0x2
;   if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES) {
700a4e2e: 980a         	ldr	r0, [sp, #0x28]
700a4e30: 2820         	cmp	r0, #0x20
700a4e32: d303         	blo	0x700a4e3c <prvInitialiseNewTask+0x9c> @ imm = #0x6
700a4e34: e7ff         	b	0x700a4e36 <prvInitialiseNewTask+0x96> @ imm = #-0x2
700a4e36: 201f         	movs	r0, #0x1f
;     uxPriority = (UBaseType_t)configMAX_PRIORITIES - (UBaseType_t)1U;
700a4e38: 900a         	str	r0, [sp, #0x28]
;   } else {
700a4e3a: e000         	b	0x700a4e3e <prvInitialiseNewTask+0x9e> @ imm = #0x0
700a4e3c: e7ff         	b	0x700a4e3e <prvInitialiseNewTask+0x9e> @ imm = #-0x2
;   pxNewTCB->uxPriority = uxPriority;
700a4e3e: 980a         	ldr	r0, [sp, #0x28]
700a4e40: 990c         	ldr	r1, [sp, #0x30]
700a4e42: 62c8         	str	r0, [r1, #0x2c]
;     pxNewTCB->uxBasePriority = uxPriority;
700a4e44: 980a         	ldr	r0, [sp, #0x28]
700a4e46: 990c         	ldr	r1, [sp, #0x30]
700a4e48: 6608         	str	r0, [r1, #0x60]
;     pxNewTCB->uxMutexesHeld = 0;
700a4e4a: 990c         	ldr	r1, [sp, #0x30]
700a4e4c: 2000         	movs	r0, #0x0
700a4e4e: 9001         	str	r0, [sp, #0x4]
700a4e50: 6648         	str	r0, [r1, #0x64]
;   vListInitialiseItem(&(pxNewTCB->xStateListItem));
700a4e52: 980c         	ldr	r0, [sp, #0x30]
700a4e54: 3004         	adds	r0, #0x4
700a4e56: f00a fec3    	bl	0x700afbe0 <vListInitialiseItem> @ imm = #0xad86
;   vListInitialiseItem(&(pxNewTCB->xEventListItem));
700a4e5a: 980c         	ldr	r0, [sp, #0x30]
700a4e5c: 3018         	adds	r0, #0x18
700a4e5e: f00a febf    	bl	0x700afbe0 <vListInitialiseItem> @ imm = #0xad7e
700a4e62: 9801         	ldr	r0, [sp, #0x4]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
700a4e64: 990c         	ldr	r1, [sp, #0x30]
700a4e66: 6109         	str	r1, [r1, #0x10]
;   listSET_LIST_ITEM_VALUE(
700a4e68: 990a         	ldr	r1, [sp, #0x28]
700a4e6a: f1c1 0120    	rsb.w	r1, r1, #0x20
700a4e6e: 9a0c         	ldr	r2, [sp, #0x30]
700a4e70: 6191         	str	r1, [r2, #0x18]
;   listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
700a4e72: 990c         	ldr	r1, [sp, #0x30]
700a4e74: 6249         	str	r1, [r1, #0x24]
;     pxNewTCB->uxCriticalNesting = (UBaseType_t)0U;
700a4e76: 990c         	ldr	r1, [sp, #0x30]
700a4e78: 6548         	str	r0, [r1, #0x54]
;     pxNewTCB->pxTaskTag = NULL;
700a4e7a: 990c         	ldr	r1, [sp, #0x30]
700a4e7c: 6688         	str	r0, [r1, #0x68]
;     memset((void *)&(pxNewTCB->pvThreadLocalStoragePointers[0]), 0x00,
700a4e7e: 990c         	ldr	r1, [sp, #0x30]
700a4e80: 6788         	str	r0, [r1, #0x78]
700a4e82: 6748         	str	r0, [r1, #0x74]
700a4e84: 6708         	str	r0, [r1, #0x70]
700a4e86: 66c8         	str	r0, [r1, #0x6c]
;     memset((void *)&(pxNewTCB->ulNotifiedValue[0]), 0x00,
700a4e88: 990c         	ldr	r1, [sp, #0x30]
700a4e8a: 67c8         	str	r0, [r1, #0x7c]
;     memset((void *)&(pxNewTCB->ucNotifyState[0]), 0x00,
700a4e8c: 990c         	ldr	r1, [sp, #0x30]
700a4e8e: f881 0080    	strb.w	r0, [r1, #0x80]
;           pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
700a4e92: 9803         	ldr	r0, [sp, #0xc]
700a4e94: 9907         	ldr	r1, [sp, #0x1c]
700a4e96: 9a04         	ldr	r2, [sp, #0x10]
700a4e98: f7fe fc8a    	bl	0x700a37b0 <pxPortInitialiseStack> @ imm = #-0x16ec
;       pxNewTCB->pxTopOfStack =
700a4e9c: 990c         	ldr	r1, [sp, #0x30]
700a4e9e: 6008         	str	r0, [r1]
;   if (pxCreatedTask != NULL) {
700a4ea0: 980b         	ldr	r0, [sp, #0x2c]
700a4ea2: b120         	cbz	r0, 0x700a4eae <prvInitialiseNewTask+0x10e> @ imm = #0x8
700a4ea4: e7ff         	b	0x700a4ea6 <prvInitialiseNewTask+0x106> @ imm = #-0x2
;     *pxCreatedTask = (TaskHandle_t)pxNewTCB;
700a4ea6: 980c         	ldr	r0, [sp, #0x30]
700a4ea8: 990b         	ldr	r1, [sp, #0x2c]
700a4eaa: 6008         	str	r0, [r1]
;   } else {
700a4eac: e000         	b	0x700a4eb0 <prvInitialiseNewTask+0x110> @ imm = #0x0
700a4eae: e7ff         	b	0x700a4eb0 <prvInitialiseNewTask+0x110> @ imm = #-0x2
; }
700a4eb0: b008         	add	sp, #0x20
700a4eb2: bd80         	pop	{r7, pc}
		...

700a4ec0 <Sciclient_pmSetModuleClkFreq>:
; {
700a4ec0: b580         	push	{r7, lr}
700a4ec2: b09a         	sub	sp, #0x68
700a4ec4: f8dd c074    	ldr.w	r12, [sp, #0x74]
700a4ec8: f8dd c070    	ldr.w	r12, [sp, #0x70]
700a4ecc: 9019         	str	r0, [sp, #0x64]
700a4ece: 9118         	str	r1, [sp, #0x60]
700a4ed0: 9317         	str	r3, [sp, #0x5c]
700a4ed2: 9216         	str	r2, [sp, #0x58]
700a4ed4: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a4ed6: 9015         	str	r0, [sp, #0x54]
;     request.device         = (uint32_t) moduleId;
700a4ed8: 9819         	ldr	r0, [sp, #0x64]
700a4eda: 900c         	str	r0, [sp, #0x30]
;     request.min_freq_hz    = (uint64_t) freqHz;
700a4edc: 9816         	ldr	r0, [sp, #0x58]
700a4ede: 9917         	ldr	r1, [sp, #0x5c]
700a4ee0: 910e         	str	r1, [sp, #0x38]
700a4ee2: 900d         	str	r0, [sp, #0x34]
;     request.target_freq_hz = (uint64_t) freqHz;
700a4ee4: 9816         	ldr	r0, [sp, #0x58]
700a4ee6: 9917         	ldr	r1, [sp, #0x5c]
700a4ee8: 9110         	str	r1, [sp, #0x40]
700a4eea: 900f         	str	r0, [sp, #0x3c]
;     request.max_freq_hz    = (uint64_t) freqHz;
700a4eec: 9816         	ldr	r0, [sp, #0x58]
700a4eee: 9917         	ldr	r1, [sp, #0x5c]
700a4ef0: 9112         	str	r1, [sp, #0x48]
700a4ef2: 9011         	str	r0, [sp, #0x44]
;     if((freqHz%10U) != 0U)
700a4ef4: 9b16         	ldr	r3, [sp, #0x58]
700a4ef6: 9817         	ldr	r0, [sp, #0x5c]
700a4ef8: f64c 41cd    	movw	r1, #0xcccd
700a4efc: f6cc 41cc    	movt	r1, #0xcccc
700a4f00: fba3 2e01    	umull	r2, lr, r3, r1
700a4f04: f04f 3ccc    	mov.w	r12, #0xcccccccc
700a4f08: fb03 e30c    	mla	r3, r3, r12, lr
700a4f0c: fb00 3101    	mla	r1, r0, r1, r3
700a4f10: ea4f 70c2    	lsl.w	r0, r2, #0x1f
700a4f14: ea40 0051    	orr.w	r0, r0, r1, lsr #1
700a4f18: ea4f 71c1    	lsl.w	r1, r1, #0x1f
700a4f1c: ea41 0152    	orr.w	r1, r1, r2, lsr #1
700a4f20: f649 129a    	movw	r2, #0x999a
700a4f24: f6c9 1299    	movt	r2, #0x9999
700a4f28: 1a89         	subs	r1, r1, r2
700a4f2a: f649 1199    	movw	r1, #0x9999
700a4f2e: f6c1 1199    	movt	r1, #0x1999
700a4f32: 4188         	sbcs	r0, r1
700a4f34: d316         	blo	0x700a4f64 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #0x2c
700a4f36: e7ff         	b	0x700a4f38 <Sciclient_pmSetModuleClkFreq+0x78> @ imm = #-0x2
;         request.min_freq_hz = (uint64_t)(freqHz-(freqHz%10U));
700a4f38: 9816         	ldr	r0, [sp, #0x58]
700a4f3a: 9001         	str	r0, [sp, #0x4]
700a4f3c: 9917         	ldr	r1, [sp, #0x5c]
700a4f3e: 9100         	str	r1, [sp]
700a4f40: 220a         	movs	r2, #0xa
700a4f42: 2300         	movs	r3, #0x0
700a4f44: f00a e946    	blx	0x700af1d4 <__aeabi_uldivmod> @ imm = #0xa28c
700a4f48: 9800         	ldr	r0, [sp]
700a4f4a: 9901         	ldr	r1, [sp, #0x4]
700a4f4c: 1a89         	subs	r1, r1, r2
700a4f4e: 4198         	sbcs	r0, r3
700a4f50: 910d         	str	r1, [sp, #0x34]
700a4f52: 900e         	str	r0, [sp, #0x38]
;         request.max_freq_hz = (uint64_t)(request.min_freq_hz + 10UL);
700a4f54: 990d         	ldr	r1, [sp, #0x34]
700a4f56: 980e         	ldr	r0, [sp, #0x38]
700a4f58: 310a         	adds	r1, #0xa
700a4f5a: f140 0000    	adc	r0, r0, #0x0
700a4f5e: 9111         	str	r1, [sp, #0x44]
700a4f60: 9012         	str	r0, [sp, #0x48]
;     }
700a4f62: e7ff         	b	0x700a4f64 <Sciclient_pmSetModuleClkFreq+0xa4> @ imm = #-0x2
;     if (clockId >= 255U)
700a4f64: 9818         	ldr	r0, [sp, #0x60]
700a4f66: 28ff         	cmp	r0, #0xff
700a4f68: d307         	blo	0x700a4f7a <Sciclient_pmSetModuleClkFreq+0xba> @ imm = #0xe
700a4f6a: e7ff         	b	0x700a4f6c <Sciclient_pmSetModuleClkFreq+0xac> @ imm = #-0x2
;         request.clk32 = clockId;
700a4f6c: 9818         	ldr	r0, [sp, #0x60]
700a4f6e: f8cd 004d    	str.w	r0, [sp, #0x4d]
700a4f72: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a4f74: f88d 004c    	strb.w	r0, [sp, #0x4c]
;     }
700a4f78: e003         	b	0x700a4f82 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a4f7a: 9818         	ldr	r0, [sp, #0x60]
700a4f7c: f88d 004c    	strb.w	r0, [sp, #0x4c]
700a4f80: e7ff         	b	0x700a4f82 <Sciclient_pmSetModuleClkFreq+0xc2> @ imm = #-0x2
700a4f82: f44f 7086    	mov.w	r0, #0x10c
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_FREQ;
700a4f86: f8ad 0014    	strh.w	r0, [sp, #0x14]
;     reqParam.flags          = (uint32_t)(TISCI_MSG_FLAG_AOP | additionalFlag);
700a4f8a: 981c         	ldr	r0, [sp, #0x70]
700a4f8c: f040 0002    	orr	r0, r0, #0x2
700a4f90: 9006         	str	r0, [sp, #0x18]
700a4f92: a80a         	add	r0, sp, #0x28
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a4f94: 9007         	str	r0, [sp, #0x1c]
700a4f96: 2029         	movs	r0, #0x29
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a4f98: 9008         	str	r0, [sp, #0x20]
;     reqParam.timeout        = (uint32_t) timeout;
700a4f9a: 981d         	ldr	r0, [sp, #0x74]
700a4f9c: 9009         	str	r0, [sp, #0x24]
700a4f9e: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a4fa0: 9002         	str	r0, [sp, #0x8]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a4fa2: 9003         	str	r0, [sp, #0xc]
;     respParam.respPayloadSize = (uint32_t) 0;
700a4fa4: 9004         	str	r0, [sp, #0x10]
700a4fa6: a805         	add	r0, sp, #0x14
700a4fa8: a902         	add	r1, sp, #0x8
;     retVal = Sciclient_service(&reqParam, &respParam);
700a4faa: f7f8 fb19    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0x79ce
700a4fae: 9015         	str	r0, [sp, #0x54]
;     if((retVal != SystemP_SUCCESS) ||
700a4fb0: 9815         	ldr	r0, [sp, #0x54]
700a4fb2: b930         	cbnz	r0, 0x700a4fc2 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #0xc
700a4fb4: e7ff         	b	0x700a4fb6 <Sciclient_pmSetModuleClkFreq+0xf6> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a4fb6: 9802         	ldr	r0, [sp, #0x8]
700a4fb8: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a4fbc: 2802         	cmp	r0, #0x2
700a4fbe: d004         	beq	0x700a4fca <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #0x8
700a4fc0: e7ff         	b	0x700a4fc2 <Sciclient_pmSetModuleClkFreq+0x102> @ imm = #-0x2
700a4fc2: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a4fc6: 9015         	str	r0, [sp, #0x54]
;     }
700a4fc8: e7ff         	b	0x700a4fca <Sciclient_pmSetModuleClkFreq+0x10a> @ imm = #-0x2
;     return retVal;
700a4fca: 9815         	ldr	r0, [sp, #0x54]
700a4fcc: b01a         	add	sp, #0x68
700a4fce: bd80         	pop	{r7, pc}

700a4fd0 <vTaskSuspend>:
; void vTaskSuspend(TaskHandle_t xTaskToSuspend) {
700a4fd0: b580         	push	{r7, lr}
700a4fd2: b084         	sub	sp, #0x10
700a4fd4: 9003         	str	r0, [sp, #0xc]
;   taskENTER_CRITICAL();
700a4fd6: f009 fbcb    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x9796
;     pxTCB = prvGetTCBFromHandle(xTaskToSuspend);
700a4fda: 9803         	ldr	r0, [sp, #0xc]
700a4fdc: b938         	cbnz	r0, 0x700a4fee <vTaskSuspend+0x1e> @ imm = #0xe
700a4fde: e7ff         	b	0x700a4fe0 <vTaskSuspend+0x10> @ imm = #-0x2
700a4fe0: f642 10fc    	movw	r0, #0x29fc
700a4fe4: f2c7 000b    	movt	r0, #0x700b
700a4fe8: 6800         	ldr	r0, [r0]
700a4fea: 9000         	str	r0, [sp]
700a4fec: e002         	b	0x700a4ff4 <vTaskSuspend+0x24> @ imm = #0x4
700a4fee: 9803         	ldr	r0, [sp, #0xc]
700a4ff0: 9000         	str	r0, [sp]
700a4ff2: e7ff         	b	0x700a4ff4 <vTaskSuspend+0x24> @ imm = #-0x2
700a4ff4: 9800         	ldr	r0, [sp]
700a4ff6: 9002         	str	r0, [sp, #0x8]
;     if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a4ff8: 9802         	ldr	r0, [sp, #0x8]
700a4ffa: 3004         	adds	r0, #0x4
700a4ffc: f008 fb88    	bl	0x700ad710 <uxListRemove> @ imm = #0x8710
700a5000: b908         	cbnz	r0, 0x700a5006 <vTaskSuspend+0x36> @ imm = #0x2
700a5002: e7ff         	b	0x700a5004 <vTaskSuspend+0x34> @ imm = #-0x2
;     } else {
700a5004: e000         	b	0x700a5008 <vTaskSuspend+0x38> @ imm = #0x0
700a5006: e7ff         	b	0x700a5008 <vTaskSuspend+0x38> @ imm = #-0x2
;     if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a5008: 9802         	ldr	r0, [sp, #0x8]
700a500a: 6a80         	ldr	r0, [r0, #0x28]
700a500c: b128         	cbz	r0, 0x700a501a <vTaskSuspend+0x4a> @ imm = #0xa
700a500e: e7ff         	b	0x700a5010 <vTaskSuspend+0x40> @ imm = #-0x2
;       (void)uxListRemove(&(pxTCB->xEventListItem));
700a5010: 9802         	ldr	r0, [sp, #0x8]
700a5012: 3018         	adds	r0, #0x18
700a5014: f008 fb7c    	bl	0x700ad710 <uxListRemove> @ imm = #0x86f8
;     } else {
700a5018: e000         	b	0x700a501c <vTaskSuspend+0x4c> @ imm = #0x0
700a501a: e7ff         	b	0x700a501c <vTaskSuspend+0x4c> @ imm = #-0x2
;     vListInsertEnd(&xSuspendedTaskList, &(pxTCB->xStateListItem));
700a501c: 9802         	ldr	r0, [sp, #0x8]
700a501e: 1d01         	adds	r1, r0, #0x4
700a5020: f245 2074    	movw	r0, #0x5274
700a5024: f2c7 0008    	movt	r0, #0x7008
700a5028: f009 f92a    	bl	0x700ae280 <vListInsertEnd> @ imm = #0x9254
700a502c: 2000         	movs	r0, #0x0
;       for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a502e: 9001         	str	r0, [sp, #0x4]
700a5030: e7ff         	b	0x700a5032 <vTaskSuspend+0x62> @ imm = #-0x2
700a5032: 9801         	ldr	r0, [sp, #0x4]
700a5034: 2800         	cmp	r0, #0x0
700a5036: dc14         	bgt	0x700a5062 <vTaskSuspend+0x92> @ imm = #0x28
700a5038: e7ff         	b	0x700a503a <vTaskSuspend+0x6a> @ imm = #-0x2
;         if (pxTCB->ucNotifyState[x] == taskWAITING_NOTIFICATION) {
700a503a: 9802         	ldr	r0, [sp, #0x8]
700a503c: 9901         	ldr	r1, [sp, #0x4]
700a503e: 4408         	add	r0, r1
700a5040: f890 0080    	ldrb.w	r0, [r0, #0x80]
700a5044: 2801         	cmp	r0, #0x1
700a5046: d107         	bne	0x700a5058 <vTaskSuspend+0x88> @ imm = #0xe
700a5048: e7ff         	b	0x700a504a <vTaskSuspend+0x7a> @ imm = #-0x2
;           pxTCB->ucNotifyState[x] = taskNOT_WAITING_NOTIFICATION;
700a504a: 9802         	ldr	r0, [sp, #0x8]
700a504c: 9901         	ldr	r1, [sp, #0x4]
700a504e: 4401         	add	r1, r0
700a5050: 2000         	movs	r0, #0x0
700a5052: f881 0080    	strb.w	r0, [r1, #0x80]
;         }
700a5056: e7ff         	b	0x700a5058 <vTaskSuspend+0x88> @ imm = #-0x2
;       }
700a5058: e7ff         	b	0x700a505a <vTaskSuspend+0x8a> @ imm = #-0x2
;       for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a505a: 9801         	ldr	r0, [sp, #0x4]
700a505c: 3001         	adds	r0, #0x1
700a505e: 9001         	str	r0, [sp, #0x4]
700a5060: e7e7         	b	0x700a5032 <vTaskSuspend+0x62> @ imm = #-0x32
;   taskEXIT_CRITICAL();
700a5062: f008 fc45    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x888a
;   if (xSchedulerRunning != pdFALSE) {
700a5066: f642 2040    	movw	r0, #0x2a40
700a506a: f2c7 000b    	movt	r0, #0x700b
700a506e: 6800         	ldr	r0, [r0]
700a5070: b138         	cbz	r0, 0x700a5082 <vTaskSuspend+0xb2> @ imm = #0xe
700a5072: e7ff         	b	0x700a5074 <vTaskSuspend+0xa4> @ imm = #-0x2
;     taskENTER_CRITICAL();
700a5074: f009 fb7c    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x96f8
;       prvResetNextTaskUnblockTime();
700a5078: f009 f882    	bl	0x700ae180 <prvResetNextTaskUnblockTime> @ imm = #0x9104
;     taskEXIT_CRITICAL();
700a507c: f008 fc38    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x8870
;   } else {
700a5080: e000         	b	0x700a5084 <vTaskSuspend+0xb4> @ imm = #0x0
700a5082: e7ff         	b	0x700a5084 <vTaskSuspend+0xb4> @ imm = #-0x2
;   if (pxTCB == pxCurrentTCB) {
700a5084: 9802         	ldr	r0, [sp, #0x8]
700a5086: f642 11fc    	movw	r1, #0x29fc
700a508a: f2c7 010b    	movt	r1, #0x700b
700a508e: 6809         	ldr	r1, [r1]
700a5090: 4288         	cmp	r0, r1
700a5092: d122         	bne	0x700a50da <vTaskSuspend+0x10a> @ imm = #0x44
700a5094: e7ff         	b	0x700a5096 <vTaskSuspend+0xc6> @ imm = #-0x2
;     if (xSchedulerRunning != pdFALSE) {
700a5096: f642 2040    	movw	r0, #0x2a40
700a509a: f2c7 000b    	movt	r0, #0x700b
700a509e: 6800         	ldr	r0, [r0]
700a50a0: b110         	cbz	r0, 0x700a50a8 <vTaskSuspend+0xd8> @ imm = #0x4
700a50a2: e7ff         	b	0x700a50a4 <vTaskSuspend+0xd4> @ imm = #-0x2
;       portYIELD_WITHIN_API();
700a50a4: df00         	svc	#0x0
;     } else {
700a50a6: e017         	b	0x700a50d8 <vTaskSuspend+0x108> @ imm = #0x2e
;       if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) ==
700a50a8: f245 2074    	movw	r0, #0x5274
700a50ac: f2c7 0008    	movt	r0, #0x7008
700a50b0: 6800         	ldr	r0, [r0]
;           uxCurrentNumberOfTasks) /*lint !e931 Right has no side effect, just
700a50b2: f642 211c    	movw	r1, #0x2a1c
700a50b6: f2c7 010b    	movt	r1, #0x700b
700a50ba: 6809         	ldr	r1, [r1]
;       if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) ==
700a50bc: 4288         	cmp	r0, r1
700a50be: d107         	bne	0x700a50d0 <vTaskSuspend+0x100> @ imm = #0xe
700a50c0: e7ff         	b	0x700a50c2 <vTaskSuspend+0xf2> @ imm = #-0x2
;         pxCurrentTCB = NULL;
700a50c2: f642 11fc    	movw	r1, #0x29fc
700a50c6: f2c7 010b    	movt	r1, #0x700b
700a50ca: 2000         	movs	r0, #0x0
700a50cc: 6008         	str	r0, [r1]
;       } else {
700a50ce: e002         	b	0x700a50d6 <vTaskSuspend+0x106> @ imm = #0x4
;         vTaskSwitchContext();
700a50d0: f001 fcbe    	bl	0x700a6a50 <vTaskSwitchContext> @ imm = #0x197c
700a50d4: e7ff         	b	0x700a50d6 <vTaskSuspend+0x106> @ imm = #-0x2
700a50d6: e7ff         	b	0x700a50d8 <vTaskSuspend+0x108> @ imm = #-0x2
;   } else {
700a50d8: e000         	b	0x700a50dc <vTaskSuspend+0x10c> @ imm = #0x0
700a50da: e7ff         	b	0x700a50dc <vTaskSuspend+0x10c> @ imm = #-0x2
; }
700a50dc: b004         	add	sp, #0x10
700a50de: bd80         	pop	{r7, pc}

700a50e0 <prvAddNewTaskToReadyList>:
; static void prvAddNewTaskToReadyList(TCB_t *pxNewTCB) {
700a50e0: b580         	push	{r7, lr}
700a50e2: b082         	sub	sp, #0x8
700a50e4: 9001         	str	r0, [sp, #0x4]
;   taskENTER_CRITICAL();
700a50e6: f009 fb43    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x9686
;     uxCurrentNumberOfTasks++;
700a50ea: f642 211c    	movw	r1, #0x2a1c
700a50ee: f2c7 010b    	movt	r1, #0x700b
700a50f2: 6808         	ldr	r0, [r1]
700a50f4: 3001         	adds	r0, #0x1
700a50f6: 6008         	str	r0, [r1]
;     if (pxCurrentTCB == NULL) {
700a50f8: f642 10fc    	movw	r0, #0x29fc
700a50fc: f2c7 000b    	movt	r0, #0x700b
700a5100: 6800         	ldr	r0, [r0]
700a5102: b998         	cbnz	r0, 0x700a512c <prvAddNewTaskToReadyList+0x4c> @ imm = #0x26
700a5104: e7ff         	b	0x700a5106 <prvAddNewTaskToReadyList+0x26> @ imm = #-0x2
;       pxCurrentTCB = pxNewTCB;
700a5106: 9801         	ldr	r0, [sp, #0x4]
700a5108: f642 11fc    	movw	r1, #0x29fc
700a510c: f2c7 010b    	movt	r1, #0x700b
700a5110: 6008         	str	r0, [r1]
;       if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
700a5112: f642 201c    	movw	r0, #0x2a1c
700a5116: f2c7 000b    	movt	r0, #0x700b
700a511a: 6800         	ldr	r0, [r0]
700a511c: 2801         	cmp	r0, #0x1
700a511e: d103         	bne	0x700a5128 <prvAddNewTaskToReadyList+0x48> @ imm = #0x6
700a5120: e7ff         	b	0x700a5122 <prvAddNewTaskToReadyList+0x42> @ imm = #-0x2
;         prvInitialiseTaskLists();
700a5122: f004 fe8d    	bl	0x700a9e40 <prvInitialiseTaskLists> @ imm = #0x4d1a
;       } else {
700a5126: e000         	b	0x700a512a <prvAddNewTaskToReadyList+0x4a> @ imm = #0x0
700a5128: e7ff         	b	0x700a512a <prvAddNewTaskToReadyList+0x4a> @ imm = #-0x2
;     } else {
700a512a: e01c         	b	0x700a5166 <prvAddNewTaskToReadyList+0x86> @ imm = #0x38
;       if (xSchedulerRunning == pdFALSE) {
700a512c: f642 2040    	movw	r0, #0x2a40
700a5130: f2c7 000b    	movt	r0, #0x700b
700a5134: 6800         	ldr	r0, [r0]
700a5136: b9a0         	cbnz	r0, 0x700a5162 <prvAddNewTaskToReadyList+0x82> @ imm = #0x28
700a5138: e7ff         	b	0x700a513a <prvAddNewTaskToReadyList+0x5a> @ imm = #-0x2
;         if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
700a513a: f642 10fc    	movw	r0, #0x29fc
700a513e: f2c7 000b    	movt	r0, #0x700b
700a5142: 6800         	ldr	r0, [r0]
700a5144: 6ac0         	ldr	r0, [r0, #0x2c]
700a5146: 9901         	ldr	r1, [sp, #0x4]
700a5148: 6ac9         	ldr	r1, [r1, #0x2c]
700a514a: 4288         	cmp	r0, r1
700a514c: d807         	bhi	0x700a515e <prvAddNewTaskToReadyList+0x7e> @ imm = #0xe
700a514e: e7ff         	b	0x700a5150 <prvAddNewTaskToReadyList+0x70> @ imm = #-0x2
;           pxCurrentTCB = pxNewTCB;
700a5150: 9801         	ldr	r0, [sp, #0x4]
700a5152: f642 11fc    	movw	r1, #0x29fc
700a5156: f2c7 010b    	movt	r1, #0x700b
700a515a: 6008         	str	r0, [r1]
;         } else {
700a515c: e000         	b	0x700a5160 <prvAddNewTaskToReadyList+0x80> @ imm = #0x0
700a515e: e7ff         	b	0x700a5160 <prvAddNewTaskToReadyList+0x80> @ imm = #-0x2
;       } else {
700a5160: e000         	b	0x700a5164 <prvAddNewTaskToReadyList+0x84> @ imm = #0x0
700a5162: e7ff         	b	0x700a5164 <prvAddNewTaskToReadyList+0x84> @ imm = #-0x2
700a5164: e7ff         	b	0x700a5166 <prvAddNewTaskToReadyList+0x86> @ imm = #-0x2
;     uxTaskNumber++;
700a5166: f642 2028    	movw	r0, #0x2a28
700a516a: f2c7 000b    	movt	r0, #0x700b
700a516e: 6801         	ldr	r1, [r0]
700a5170: 3101         	adds	r1, #0x1
700a5172: 6001         	str	r1, [r0]
;       pxNewTCB->uxTCBNumber = uxTaskNumber;
700a5174: 6800         	ldr	r0, [r0]
700a5176: 9901         	ldr	r1, [sp, #0x4]
700a5178: 6588         	str	r0, [r1, #0x58]
;     prvAddTaskToReadyList(pxNewTCB);
700a517a: 9801         	ldr	r0, [sp, #0x4]
700a517c: 6ac0         	ldr	r0, [r0, #0x2c]
700a517e: f642 212c    	movw	r1, #0x2a2c
700a5182: f2c7 010b    	movt	r1, #0x700b
700a5186: 6809         	ldr	r1, [r1]
700a5188: 4288         	cmp	r0, r1
700a518a: d908         	bls	0x700a519e <prvAddNewTaskToReadyList+0xbe> @ imm = #0x10
700a518c: e7ff         	b	0x700a518e <prvAddNewTaskToReadyList+0xae> @ imm = #-0x2
700a518e: 9801         	ldr	r0, [sp, #0x4]
700a5190: 6ac0         	ldr	r0, [r0, #0x2c]
700a5192: f642 212c    	movw	r1, #0x2a2c
700a5196: f2c7 010b    	movt	r1, #0x700b
700a519a: 6008         	str	r0, [r1]
700a519c: e7ff         	b	0x700a519e <prvAddNewTaskToReadyList+0xbe> @ imm = #-0x2
700a519e: 9901         	ldr	r1, [sp, #0x4]
700a51a0: 6ac8         	ldr	r0, [r1, #0x2c]
700a51a2: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a51a6: f244 40f8    	movw	r0, #0x44f8
700a51aa: f2c7 0008    	movt	r0, #0x7008
700a51ae: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a51b2: 3104         	adds	r1, #0x4
700a51b4: f009 f864    	bl	0x700ae280 <vListInsertEnd> @ imm = #0x90c8
;   taskEXIT_CRITICAL();
700a51b8: f008 fb9a    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x8734
;   if (xSchedulerRunning != pdFALSE) {
700a51bc: f642 2040    	movw	r0, #0x2a40
700a51c0: f2c7 000b    	movt	r0, #0x700b
700a51c4: 6800         	ldr	r0, [r0]
700a51c6: b178         	cbz	r0, 0x700a51e8 <prvAddNewTaskToReadyList+0x108> @ imm = #0x1e
700a51c8: e7ff         	b	0x700a51ca <prvAddNewTaskToReadyList+0xea> @ imm = #-0x2
;     if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
700a51ca: f642 10fc    	movw	r0, #0x29fc
700a51ce: f2c7 000b    	movt	r0, #0x700b
700a51d2: 6800         	ldr	r0, [r0]
700a51d4: 6ac0         	ldr	r0, [r0, #0x2c]
700a51d6: 9901         	ldr	r1, [sp, #0x4]
700a51d8: 6ac9         	ldr	r1, [r1, #0x2c]
700a51da: 4288         	cmp	r0, r1
700a51dc: d202         	bhs	0x700a51e4 <prvAddNewTaskToReadyList+0x104> @ imm = #0x4
700a51de: e7ff         	b	0x700a51e0 <prvAddNewTaskToReadyList+0x100> @ imm = #-0x2
;       taskYIELD_IF_USING_PREEMPTION();
700a51e0: df00         	svc	#0x0
;     } else {
700a51e2: e000         	b	0x700a51e6 <prvAddNewTaskToReadyList+0x106> @ imm = #0x0
700a51e4: e7ff         	b	0x700a51e6 <prvAddNewTaskToReadyList+0x106> @ imm = #-0x2
;   } else {
700a51e6: e000         	b	0x700a51ea <prvAddNewTaskToReadyList+0x10a> @ imm = #0x0
700a51e8: e7ff         	b	0x700a51ea <prvAddNewTaskToReadyList+0x10a> @ imm = #-0x2
; }
700a51ea: b002         	add	sp, #0x8
700a51ec: bd80         	pop	{r7, pc}
700a51ee: 0000         	movs	r0, r0

700a51f0 <xTaskPriorityInherit>:
; BaseType_t xTaskPriorityInherit(TaskHandle_t const pxMutexHolder) {
700a51f0: b580         	push	{r7, lr}
700a51f2: b084         	sub	sp, #0x10
700a51f4: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxMutexHolderTCB = pxMutexHolder;
700a51f6: 9803         	ldr	r0, [sp, #0xc]
700a51f8: 9002         	str	r0, [sp, #0x8]
700a51fa: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a51fc: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a51fe: 9803         	ldr	r0, [sp, #0xc]
700a5200: 2800         	cmp	r0, #0x0
700a5202: d078         	beq	0x700a52f6 <xTaskPriorityInherit+0x106> @ imm = #0xf0
700a5204: e7ff         	b	0x700a5206 <xTaskPriorityInherit+0x16> @ imm = #-0x2
;     if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority) {
700a5206: 9802         	ldr	r0, [sp, #0x8]
700a5208: 6ac0         	ldr	r0, [r0, #0x2c]
700a520a: f642 11fc    	movw	r1, #0x29fc
700a520e: f2c7 010b    	movt	r1, #0x700b
700a5212: 6809         	ldr	r1, [r1]
700a5214: 6ac9         	ldr	r1, [r1, #0x2c]
700a5216: 4288         	cmp	r0, r1
700a5218: d25c         	bhs	0x700a52d4 <xTaskPriorityInherit+0xe4> @ imm = #0xb8
700a521a: e7ff         	b	0x700a521c <xTaskPriorityInherit+0x2c> @ imm = #-0x2
;       if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) &
700a521c: 9802         	ldr	r0, [sp, #0x8]
700a521e: 7ec0         	ldrb	r0, [r0, #0x1b]
700a5220: 0600         	lsls	r0, r0, #0x18
700a5222: 2800         	cmp	r0, #0x0
700a5224: d40b         	bmi	0x700a523e <xTaskPriorityInherit+0x4e> @ imm = #0x16
700a5226: e7ff         	b	0x700a5228 <xTaskPriorityInherit+0x38> @ imm = #-0x2
;         listSET_LIST_ITEM_VALUE(
700a5228: f642 10fc    	movw	r0, #0x29fc
700a522c: f2c7 000b    	movt	r0, #0x700b
700a5230: 6800         	ldr	r0, [r0]
700a5232: 6ac0         	ldr	r0, [r0, #0x2c]
700a5234: f1c0 0020    	rsb.w	r0, r0, #0x20
700a5238: 9902         	ldr	r1, [sp, #0x8]
700a523a: 6188         	str	r0, [r1, #0x18]
;       } else {
700a523c: e000         	b	0x700a5240 <xTaskPriorityInherit+0x50> @ imm = #0x0
700a523e: e7ff         	b	0x700a5240 <xTaskPriorityInherit+0x50> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(
700a5240: 9902         	ldr	r1, [sp, #0x8]
700a5242: 6948         	ldr	r0, [r1, #0x14]
700a5244: 6ac9         	ldr	r1, [r1, #0x2c]
700a5246: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a524a: f244 41f8    	movw	r1, #0x44f8
700a524e: f2c7 0108    	movt	r1, #0x7008
700a5252: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a5256: 4288         	cmp	r0, r1
700a5258: d130         	bne	0x700a52bc <xTaskPriorityInherit+0xcc> @ imm = #0x60
700a525a: e7ff         	b	0x700a525c <xTaskPriorityInherit+0x6c> @ imm = #-0x2
;         if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) ==
700a525c: 9802         	ldr	r0, [sp, #0x8]
700a525e: 3004         	adds	r0, #0x4
700a5260: f008 fa56    	bl	0x700ad710 <uxListRemove> @ imm = #0x84ac
700a5264: b908         	cbnz	r0, 0x700a526a <xTaskPriorityInherit+0x7a> @ imm = #0x2
700a5266: e7ff         	b	0x700a5268 <xTaskPriorityInherit+0x78> @ imm = #-0x2
;         } else {
700a5268: e000         	b	0x700a526c <xTaskPriorityInherit+0x7c> @ imm = #0x0
700a526a: e7ff         	b	0x700a526c <xTaskPriorityInherit+0x7c> @ imm = #-0x2
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a526c: f642 10fc    	movw	r0, #0x29fc
700a5270: f2c7 000b    	movt	r0, #0x700b
700a5274: 6800         	ldr	r0, [r0]
700a5276: 6ac0         	ldr	r0, [r0, #0x2c]
700a5278: 9902         	ldr	r1, [sp, #0x8]
700a527a: 62c8         	str	r0, [r1, #0x2c]
;         prvAddTaskToReadyList(pxMutexHolderTCB);
700a527c: 9802         	ldr	r0, [sp, #0x8]
700a527e: 6ac0         	ldr	r0, [r0, #0x2c]
700a5280: f642 212c    	movw	r1, #0x2a2c
700a5284: f2c7 010b    	movt	r1, #0x700b
700a5288: 6809         	ldr	r1, [r1]
700a528a: 4288         	cmp	r0, r1
700a528c: d908         	bls	0x700a52a0 <xTaskPriorityInherit+0xb0> @ imm = #0x10
700a528e: e7ff         	b	0x700a5290 <xTaskPriorityInherit+0xa0> @ imm = #-0x2
700a5290: 9802         	ldr	r0, [sp, #0x8]
700a5292: 6ac0         	ldr	r0, [r0, #0x2c]
700a5294: f642 212c    	movw	r1, #0x2a2c
700a5298: f2c7 010b    	movt	r1, #0x700b
700a529c: 6008         	str	r0, [r1]
700a529e: e7ff         	b	0x700a52a0 <xTaskPriorityInherit+0xb0> @ imm = #-0x2
700a52a0: 9902         	ldr	r1, [sp, #0x8]
700a52a2: 6ac8         	ldr	r0, [r1, #0x2c]
700a52a4: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a52a8: f244 40f8    	movw	r0, #0x44f8
700a52ac: f2c7 0008    	movt	r0, #0x7008
700a52b0: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a52b4: 3104         	adds	r1, #0x4
700a52b6: f008 ffe3    	bl	0x700ae280 <vListInsertEnd> @ imm = #0x8fc6
;       } else {
700a52ba: e008         	b	0x700a52ce <xTaskPriorityInherit+0xde> @ imm = #0x10
;         pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
700a52bc: f642 10fc    	movw	r0, #0x29fc
700a52c0: f2c7 000b    	movt	r0, #0x700b
700a52c4: 6800         	ldr	r0, [r0]
700a52c6: 6ac0         	ldr	r0, [r0, #0x2c]
700a52c8: 9902         	ldr	r1, [sp, #0x8]
700a52ca: 62c8         	str	r0, [r1, #0x2c]
700a52cc: e7ff         	b	0x700a52ce <xTaskPriorityInherit+0xde> @ imm = #-0x2
700a52ce: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a52d0: 9001         	str	r0, [sp, #0x4]
;     } else {
700a52d2: e00f         	b	0x700a52f4 <xTaskPriorityInherit+0x104> @ imm = #0x1e
;       if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority) {
700a52d4: 9802         	ldr	r0, [sp, #0x8]
700a52d6: 6e00         	ldr	r0, [r0, #0x60]
700a52d8: f642 11fc    	movw	r1, #0x29fc
700a52dc: f2c7 010b    	movt	r1, #0x700b
700a52e0: 6809         	ldr	r1, [r1]
700a52e2: 6ac9         	ldr	r1, [r1, #0x2c]
700a52e4: 4288         	cmp	r0, r1
700a52e6: d203         	bhs	0x700a52f0 <xTaskPriorityInherit+0x100> @ imm = #0x6
700a52e8: e7ff         	b	0x700a52ea <xTaskPriorityInherit+0xfa> @ imm = #-0x2
700a52ea: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a52ec: 9001         	str	r0, [sp, #0x4]
;       } else {
700a52ee: e000         	b	0x700a52f2 <xTaskPriorityInherit+0x102> @ imm = #0x0
700a52f0: e7ff         	b	0x700a52f2 <xTaskPriorityInherit+0x102> @ imm = #-0x2
700a52f2: e7ff         	b	0x700a52f4 <xTaskPriorityInherit+0x104> @ imm = #-0x2
;   } else {
700a52f4: e000         	b	0x700a52f8 <xTaskPriorityInherit+0x108> @ imm = #0x0
700a52f6: e7ff         	b	0x700a52f8 <xTaskPriorityInherit+0x108> @ imm = #-0x2
;   return xReturn;
700a52f8: 9801         	ldr	r0, [sp, #0x4]
700a52fa: b004         	add	sp, #0x10
700a52fc: bd80         	pop	{r7, pc}
700a52fe: 0000         	movs	r0, r0

700a5300 <tm_isr_message_handler>:
; {
700a5300: b570         	push	{r4, r5, r6, lr}
;    tm_isr_counter++;
700a5302: f642 2004    	movw	r0, #0x2a04
;    message[1] = isr_message_counter;
700a5306: f642 15f4    	movw	r5, #0x29f4
;    tm_isr_counter++;
700a530a: f2c7 000b    	movt	r0, #0x700b
;    message[1] = isr_message_counter;
700a530e: f2c7 050b    	movt	r5, #0x700b
;    message[0] = 1;
700a5312: f644 76c0    	movw	r6, #0x4fc0
700a5316: f2c7 0608    	movt	r6, #0x7008
;    tm_isr_counter++;
700a531a: 6801         	ldr	r1, [r0]
700a531c: 3101         	adds	r1, #0x1
700a531e: 6001         	str	r1, [r0]
700a5320: 2001         	movs	r0, #0x1
;    message[1] = isr_message_counter;
700a5322: 6829         	ldr	r1, [r5]
;    message[0] = 1;
700a5324: 6030         	str	r0, [r6]
700a5326: 2000         	movs	r0, #0x0
;    message[1] = isr_message_counter;
700a5328: 6071         	str	r1, [r6, #0x4]
700a532a: bf00         	nop
700a532c: bf00         	nop
700a532e: bf00         	nop
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a5330: 6829         	ldr	r1, [r5]
700a5332: f200 33eb    	addw	r3, r0, #0x3eb
700a5336: 682a         	ldr	r2, [r5]
;    for (i = 2; i < MESSAGE_SIZE - 1; i++)
700a5338: 281b         	cmp	r0, #0x1b
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a533a: eb01 0181    	add.w	r1, r1, r1, lsl #2
700a533e: eb02 0282    	add.w	r2, r2, r2, lsl #2
700a5342: eb03 0141    	add.w	r1, r3, r1, lsl #1
700a5346: f1a1 0401    	sub.w	r4, r1, #0x1
700a534a: eb06 0180    	add.w	r1, r6, r0, lsl #2
700a534e: eb03 0242    	add.w	r2, r3, r2, lsl #1
700a5352: e9c1 4202    	strd	r4, r2, [r1, #8]
;    for (i = 2; i < MESSAGE_SIZE - 1; i++)
700a5356: d009         	beq	0x700a536c <tm_isr_message_handler+0x6c> @ imm = #0x12
;       message[i] = 1000 + (isr_message_counter * 10) + i;
700a5358: 682a         	ldr	r2, [r5]
700a535a: eb02 0282    	add.w	r2, r2, r2, lsl #2
700a535e: eb00 0242    	add.w	r2, r0, r2, lsl #1
700a5362: 3003         	adds	r0, #0x3
700a5364: f502 727b    	add.w	r2, r2, #0x3ec
700a5368: 610a         	str	r2, [r1, #0x10]
700a536a: e7e1         	b	0x700a5330 <tm_isr_message_handler+0x30> @ imm = #-0x3e
;       checksum += msg[i];
700a536c: e896 0007    	ldm.w	r6, {r0, r1, r2}
700a5370: 4408         	add	r0, r1
700a5372: 68f1         	ldr	r1, [r6, #0xc]
700a5374: 4410         	add	r0, r2
700a5376: 6932         	ldr	r2, [r6, #0x10]
700a5378: 4408         	add	r0, r1
700a537a: 6971         	ldr	r1, [r6, #0x14]
700a537c: 4410         	add	r0, r2
700a537e: 69b2         	ldr	r2, [r6, #0x18]
700a5380: 4408         	add	r0, r1
700a5382: 69f1         	ldr	r1, [r6, #0x1c]
700a5384: 4410         	add	r0, r2
700a5386: 6a32         	ldr	r2, [r6, #0x20]
700a5388: 4408         	add	r0, r1
700a538a: 6a71         	ldr	r1, [r6, #0x24]
700a538c: 4410         	add	r0, r2
700a538e: 6ab2         	ldr	r2, [r6, #0x28]
700a5390: 4408         	add	r0, r1
700a5392: 6af1         	ldr	r1, [r6, #0x2c]
700a5394: 4410         	add	r0, r2
700a5396: 6b32         	ldr	r2, [r6, #0x30]
700a5398: 4408         	add	r0, r1
700a539a: 6b71         	ldr	r1, [r6, #0x34]
700a539c: 4410         	add	r0, r2
700a539e: 6bb2         	ldr	r2, [r6, #0x38]
700a53a0: 4408         	add	r0, r1
700a53a2: 6bf1         	ldr	r1, [r6, #0x3c]
700a53a4: 4410         	add	r0, r2
700a53a6: 6c32         	ldr	r2, [r6, #0x40]
700a53a8: 4408         	add	r0, r1
700a53aa: 6c71         	ldr	r1, [r6, #0x44]
700a53ac: 4410         	add	r0, r2
700a53ae: 6cb2         	ldr	r2, [r6, #0x48]
700a53b0: 4408         	add	r0, r1
700a53b2: 6cf1         	ldr	r1, [r6, #0x4c]
700a53b4: 4410         	add	r0, r2
700a53b6: 6d32         	ldr	r2, [r6, #0x50]
700a53b8: 4408         	add	r0, r1
700a53ba: 6d71         	ldr	r1, [r6, #0x54]
700a53bc: 4410         	add	r0, r2
700a53be: 6db2         	ldr	r2, [r6, #0x58]
700a53c0: 4408         	add	r0, r1
700a53c2: 6df1         	ldr	r1, [r6, #0x5c]
700a53c4: 4410         	add	r0, r2
700a53c6: 6e32         	ldr	r2, [r6, #0x60]
700a53c8: 4408         	add	r0, r1
700a53ca: 6e71         	ldr	r1, [r6, #0x64]
700a53cc: 4410         	add	r0, r2
700a53ce: 6eb2         	ldr	r2, [r6, #0x68]
700a53d0: 4408         	add	r0, r1
700a53d2: 6ef1         	ldr	r1, [r6, #0x6c]
700a53d4: 4410         	add	r0, r2
700a53d6: 6f32         	ldr	r2, [r6, #0x70]
700a53d8: 4408         	add	r0, r1
700a53da: 6f71         	ldr	r1, [r6, #0x74]
700a53dc: 4410         	add	r0, r2
700a53de: 6fb2         	ldr	r2, [r6, #0x78]
700a53e0: 4408         	add	r0, r1
;    tm_pmu_profile_start(pmu_send_names[isr_message_counter]);
700a53e2: f644 1178    	movw	r1, #0x4978
700a53e6: f2c7 0108    	movt	r1, #0x7008
;       checksum += msg[i];
700a53ea: 4410         	add	r0, r2
;    message[MESSAGE_SIZE - 1] = compute_checksum(message, MESSAGE_SIZE - 1);
700a53ec: 67f0         	str	r0, [r6, #0x7c]
;    tm_pmu_profile_start(pmu_send_names[isr_message_counter]);
700a53ee: 6828         	ldr	r0, [r5]
700a53f0: eb01 1000    	add.w	r0, r1, r0, lsl #4
700a53f4: f00a fcdc    	bl	0x700afdb0 <tm_pmu_profile_start> @ imm = #0xa9b8
;    tm_queue_send_from_isr(0, message);
700a53f8: 4631         	mov	r1, r6
700a53fa: 2000         	movs	r0, #0x0
700a53fc: f009 fb30    	bl	0x700aea60 <tm_queue_send_from_isr> @ imm = #0x9660
;    isr_message_counter++; /* Prepare for next iteration */
700a5400: 6828         	ldr	r0, [r5]
700a5402: 3001         	adds	r0, #0x1
700a5404: 6028         	str	r0, [r5]
; }
700a5406: bd70         	pop	{r4, r5, r6, pc}
		...

700a5410 <Udma_eventCheckParams>:
; {
700a5410: b084         	sub	sp, #0x10
700a5412: 9003         	str	r0, [sp, #0xc]
700a5414: 9102         	str	r1, [sp, #0x8]
700a5416: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a5418: 9001         	str	r0, [sp, #0x4]
;     if(UDMA_EVENT_MODE_EXCLUSIVE == eventPrms->eventMode)
700a541a: 9802         	ldr	r0, [sp, #0x8]
700a541c: 6840         	ldr	r0, [r0, #0x4]
700a541e: 2801         	cmp	r0, #0x1
700a5420: d109         	bne	0x700a5436 <Udma_eventCheckParams+0x26> @ imm = #0x12
700a5422: e7ff         	b	0x700a5424 <Udma_eventCheckParams+0x14> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a5424: 9802         	ldr	r0, [sp, #0x8]
700a5426: 6900         	ldr	r0, [r0, #0x10]
700a5428: b120         	cbz	r0, 0x700a5434 <Udma_eventCheckParams+0x24> @ imm = #0x8
700a542a: e7ff         	b	0x700a542c <Udma_eventCheckParams+0x1c> @ imm = #-0x2
700a542c: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a5430: 9001         	str	r0, [sp, #0x4]
;         }
700a5432: e7ff         	b	0x700a5434 <Udma_eventCheckParams+0x24> @ imm = #-0x2
;     }
700a5434: e7ff         	b	0x700a5436 <Udma_eventCheckParams+0x26> @ imm = #-0x2
;     if(UDMA_EVENT_MODE_SHARED == eventPrms->eventMode)
700a5436: 9802         	ldr	r0, [sp, #0x8]
700a5438: 6840         	ldr	r0, [r0, #0x4]
700a543a: 2802         	cmp	r0, #0x2
700a543c: d126         	bne	0x700a548c <Udma_eventCheckParams+0x7c> @ imm = #0x4c
700a543e: e7ff         	b	0x700a5440 <Udma_eventCheckParams+0x30> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a5440: 9802         	ldr	r0, [sp, #0x8]
700a5442: 6900         	ldr	r0, [r0, #0x10]
700a5444: b308         	cbz	r0, 0x700a548a <Udma_eventCheckParams+0x7a> @ imm = #0x42
700a5446: e7ff         	b	0x700a5448 <Udma_eventCheckParams+0x38> @ imm = #-0x2
;             controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a5448: 9802         	ldr	r0, [sp, #0x8]
700a544a: 6900         	ldr	r0, [r0, #0x10]
700a544c: 9000         	str	r0, [sp]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a544e: 9800         	ldr	r0, [sp]
700a5450: 69c0         	ldr	r0, [r0, #0x1c]
700a5452: b140         	cbz	r0, 0x700a5466 <Udma_eventCheckParams+0x56> @ imm = #0x10
700a5454: e7ff         	b	0x700a5456 <Udma_eventCheckParams+0x46> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR == eventPrms->eventCb))
700a5456: 9802         	ldr	r0, [sp, #0x8]
700a5458: 6940         	ldr	r0, [r0, #0x14]
;             if(((Udma_EventCallback) NULL_PTR != controllerEventHandle->eventPrms.eventCb) &&
700a545a: b920         	cbnz	r0, 0x700a5466 <Udma_eventCheckParams+0x56> @ imm = #0x8
700a545c: e7ff         	b	0x700a545e <Udma_eventCheckParams+0x4e> @ imm = #-0x2
700a545e: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a5462: 9001         	str	r0, [sp, #0x4]
;             }
700a5464: e7ff         	b	0x700a5466 <Udma_eventCheckParams+0x56> @ imm = #-0x2
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a5466: 9800         	ldr	r0, [sp]
700a5468: 69c0         	ldr	r0, [r0, #0x1c]
700a546a: b968         	cbnz	r0, 0x700a5488 <Udma_eventCheckParams+0x78> @ imm = #0x1a
700a546c: e7ff         	b	0x700a546e <Udma_eventCheckParams+0x5e> @ imm = #-0x2
;                ((Udma_EventCallback) NULL_PTR != eventPrms->eventCb) &&
700a546e: 9802         	ldr	r0, [sp, #0x8]
700a5470: 6940         	ldr	r0, [r0, #0x14]
700a5472: b148         	cbz	r0, 0x700a5488 <Udma_eventCheckParams+0x78> @ imm = #0x12
700a5474: e7ff         	b	0x700a5476 <Udma_eventCheckParams+0x66> @ imm = #-0x2
;                (UDMA_EVENT_TYPE_MASTER != controllerEventHandle->eventPrms.eventType))
700a5476: 9800         	ldr	r0, [sp]
700a5478: 6880         	ldr	r0, [r0, #0x8]
;             if(((Udma_EventCallback) NULL_PTR == controllerEventHandle->eventPrms.eventCb) &&
700a547a: 2805         	cmp	r0, #0x5
700a547c: d004         	beq	0x700a5488 <Udma_eventCheckParams+0x78> @ imm = #0x8
700a547e: e7ff         	b	0x700a5480 <Udma_eventCheckParams+0x70> @ imm = #-0x2
700a5480: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a5484: 9001         	str	r0, [sp, #0x4]
;             }
700a5486: e7ff         	b	0x700a5488 <Udma_eventCheckParams+0x78> @ imm = #-0x2
;         }
700a5488: e7ff         	b	0x700a548a <Udma_eventCheckParams+0x7a> @ imm = #-0x2
;     }
700a548a: e7ff         	b	0x700a548c <Udma_eventCheckParams+0x7c> @ imm = #-0x2
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a548c: 9802         	ldr	r0, [sp, #0x8]
700a548e: 6800         	ldr	r0, [r0]
700a5490: 2801         	cmp	r0, #0x1
700a5492: d00f         	beq	0x700a54b4 <Udma_eventCheckParams+0xa4> @ imm = #0x1e
700a5494: e7ff         	b	0x700a5496 <Udma_eventCheckParams+0x86> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a5496: 9802         	ldr	r0, [sp, #0x8]
700a5498: 6800         	ldr	r0, [r0]
700a549a: 2806         	cmp	r0, #0x6
700a549c: d00a         	beq	0x700a54b4 <Udma_eventCheckParams+0xa4> @ imm = #0x14
700a549e: e7ff         	b	0x700a54a0 <Udma_eventCheckParams+0x90> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventPrms->eventType) ||
700a54a0: 9802         	ldr	r0, [sp, #0x8]
700a54a2: 6800         	ldr	r0, [r0]
700a54a4: 2802         	cmp	r0, #0x2
700a54a6: d005         	beq	0x700a54b4 <Udma_eventCheckParams+0xa4> @ imm = #0xa
700a54a8: e7ff         	b	0x700a54aa <Udma_eventCheckParams+0x9a> @ imm = #-0x2
;        (UDMA_EVENT_TYPE_TR == eventPrms->eventType))
700a54aa: 9802         	ldr	r0, [sp, #0x8]
700a54ac: 6800         	ldr	r0, [r0]
;     if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a54ae: 2803         	cmp	r0, #0x3
700a54b0: d109         	bne	0x700a54c6 <Udma_eventCheckParams+0xb6> @ imm = #0x12
700a54b2: e7ff         	b	0x700a54b4 <Udma_eventCheckParams+0xa4> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->chHandle)
700a54b4: 9802         	ldr	r0, [sp, #0x8]
700a54b6: 6880         	ldr	r0, [r0, #0x8]
700a54b8: b920         	cbnz	r0, 0x700a54c4 <Udma_eventCheckParams+0xb4> @ imm = #0x8
700a54ba: e7ff         	b	0x700a54bc <Udma_eventCheckParams+0xac> @ imm = #-0x2
700a54bc: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a54c0: 9001         	str	r0, [sp, #0x4]
;         }
700a54c2: e7ff         	b	0x700a54c4 <Udma_eventCheckParams+0xb4> @ imm = #-0x2
;     }
700a54c4: e7ff         	b	0x700a54c6 <Udma_eventCheckParams+0xb6> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_RING == eventPrms->eventType)
700a54c6: 9802         	ldr	r0, [sp, #0x8]
700a54c8: 6800         	ldr	r0, [r0]
700a54ca: 2804         	cmp	r0, #0x4
700a54cc: d109         	bne	0x700a54e2 <Udma_eventCheckParams+0xd2> @ imm = #0x12
700a54ce: e7ff         	b	0x700a54d0 <Udma_eventCheckParams+0xc0> @ imm = #-0x2
;         if(NULL_PTR == eventPrms->ringHandle)
700a54d0: 9802         	ldr	r0, [sp, #0x8]
700a54d2: 68c0         	ldr	r0, [r0, #0xc]
700a54d4: b920         	cbnz	r0, 0x700a54e0 <Udma_eventCheckParams+0xd0> @ imm = #0x8
700a54d6: e7ff         	b	0x700a54d8 <Udma_eventCheckParams+0xc8> @ imm = #-0x2
700a54d8: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a54dc: 9001         	str	r0, [sp, #0x4]
;         }
700a54de: e7ff         	b	0x700a54e0 <Udma_eventCheckParams+0xd0> @ imm = #-0x2
;     }
700a54e0: e7ff         	b	0x700a54e2 <Udma_eventCheckParams+0xd2> @ imm = #-0x2
;     if(UDMA_EVENT_TYPE_MASTER == eventPrms->eventType)
700a54e2: 9802         	ldr	r0, [sp, #0x8]
700a54e4: 6800         	ldr	r0, [r0]
700a54e6: 2805         	cmp	r0, #0x5
700a54e8: d112         	bne	0x700a5510 <Udma_eventCheckParams+0x100> @ imm = #0x24
700a54ea: e7ff         	b	0x700a54ec <Udma_eventCheckParams+0xdc> @ imm = #-0x2
;         if(UDMA_EVENT_MODE_SHARED != eventPrms->eventMode)
700a54ec: 9802         	ldr	r0, [sp, #0x8]
700a54ee: 6840         	ldr	r0, [r0, #0x4]
700a54f0: 2802         	cmp	r0, #0x2
700a54f2: d004         	beq	0x700a54fe <Udma_eventCheckParams+0xee> @ imm = #0x8
700a54f4: e7ff         	b	0x700a54f6 <Udma_eventCheckParams+0xe6> @ imm = #-0x2
700a54f6: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a54fa: 9001         	str	r0, [sp, #0x4]
;         }
700a54fc: e7ff         	b	0x700a54fe <Udma_eventCheckParams+0xee> @ imm = #-0x2
;         if(NULL_PTR != eventPrms->controllerEventHandle)
700a54fe: 9802         	ldr	r0, [sp, #0x8]
700a5500: 6900         	ldr	r0, [r0, #0x10]
700a5502: b120         	cbz	r0, 0x700a550e <Udma_eventCheckParams+0xfe> @ imm = #0x8
700a5504: e7ff         	b	0x700a5506 <Udma_eventCheckParams+0xf6> @ imm = #-0x2
700a5506: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a550a: 9001         	str	r0, [sp, #0x4]
;         }
700a550c: e7ff         	b	0x700a550e <Udma_eventCheckParams+0xfe> @ imm = #-0x2
;     }
700a550e: e7ff         	b	0x700a5510 <Udma_eventCheckParams+0x100> @ imm = #-0x2
;     return (retVal);
700a5510: 9801         	ldr	r0, [sp, #0x4]
700a5512: b004         	add	sp, #0x10
700a5514: 4770         	bx	lr
		...
700a551e: 0000         	movs	r0, r0

700a5520 <CSL_pktdmaTeardownChan>:
; {
700a5520: b580         	push	{r7, lr}
700a5522: b088         	sub	sp, #0x20
700a5524: 4684         	mov	r12, r0
700a5526: 980a         	ldr	r0, [sp, #0x28]
700a5528: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a552c: 9106         	str	r1, [sp, #0x18]
700a552e: 9205         	str	r2, [sp, #0x14]
700a5530: f88d 3013    	strb.w	r3, [sp, #0x13]
700a5534: f88d 0012    	strb.w	r0, [sp, #0x12]
700a5538: 2000         	movs	r0, #0x0
;     int32_t  retVal = CSL_PASS;
700a553a: 9003         	str	r0, [sp, #0xc]
;     if( (pCfg == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a553c: 9807         	ldr	r0, [sp, #0x1c]
700a553e: b138         	cbz	r0, 0x700a5550 <CSL_pktdmaTeardownChan+0x30> @ imm = #0xe
700a5540: e7ff         	b	0x700a5542 <CSL_pktdmaTeardownChan+0x22> @ imm = #-0x2
700a5542: 9807         	ldr	r0, [sp, #0x1c]
700a5544: 9906         	ldr	r1, [sp, #0x18]
700a5546: 9a05         	ldr	r2, [sp, #0x14]
700a5548: f007 fc3a    	bl	0x700acdc0 <CSL_pktdmaIsValidChanIdx> @ imm = #0x7874
700a554c: b920         	cbnz	r0, 0x700a5558 <CSL_pktdmaTeardownChan+0x38> @ imm = #0x8
700a554e: e7ff         	b	0x700a5550 <CSL_pktdmaTeardownChan+0x30> @ imm = #-0x2
700a5550: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a5554: 9003         	str	r0, [sp, #0xc]
;     }
700a5556: e062         	b	0x700a561e <CSL_pktdmaTeardownChan+0xfe> @ imm = #0xc4
;         if( CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true )
700a5558: 9807         	ldr	r0, [sp, #0x1c]
700a555a: 9906         	ldr	r1, [sp, #0x18]
700a555c: 9a05         	ldr	r2, [sp, #0x14]
700a555e: f007 fe5f    	bl	0x700ad220 <CSL_pktdmaIsChanEnabled> @ imm = #0x7cbe
700a5562: 2800         	cmp	r0, #0x0
700a5564: d056         	beq	0x700a5614 <CSL_pktdmaTeardownChan+0xf4> @ imm = #0xac
700a5566: e7ff         	b	0x700a5568 <CSL_pktdmaTeardownChan+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a5568: 9805         	ldr	r0, [sp, #0x14]
700a556a: b9a8         	cbnz	r0, 0x700a5598 <CSL_pktdmaTeardownChan+0x78> @ imm = #0x2a
700a556c: e7ff         	b	0x700a556e <CSL_pktdmaTeardownChan+0x4e> @ imm = #-0x2
;                 regVal = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a556e: 9807         	ldr	r0, [sp, #0x1c]
700a5570: 6900         	ldr	r0, [r0, #0x10]
700a5572: 9906         	ldr	r1, [sp, #0x18]
700a5574: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5578: f00a fb52    	bl	0x700afc20 <CSL_REG32_RD_RAW> @ imm = #0xa6a4
700a557c: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_TXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a557e: 9802         	ldr	r0, [sp, #0x8]
700a5580: f040 4080    	orr	r0, r0, #0x40000000
700a5584: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a5586: 9807         	ldr	r0, [sp, #0x1c]
700a5588: 6900         	ldr	r0, [r0, #0x10]
700a558a: 9906         	ldr	r1, [sp, #0x18]
700a558c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a5590: 9902         	ldr	r1, [sp, #0x8]
700a5592: f00a fa9d    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0xa53a
;             }
700a5596: e014         	b	0x700a55c2 <CSL_pktdmaTeardownChan+0xa2> @ imm = #0x28
;                 regVal = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a5598: 9807         	ldr	r0, [sp, #0x1c]
700a559a: 6940         	ldr	r0, [r0, #0x14]
700a559c: 9906         	ldr	r1, [sp, #0x18]
700a559e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a55a2: f00a fb3d    	bl	0x700afc20 <CSL_REG32_RD_RAW> @ imm = #0xa67a
700a55a6: 9002         	str	r0, [sp, #0x8]
;                 CSL_FINS( regVal, PKTDMA_RXCRT_CHAN_CTL_TDOWN, (uint32_t)1U );
700a55a8: 9802         	ldr	r0, [sp, #0x8]
700a55aa: f040 4080    	orr	r0, r0, #0x40000000
700a55ae: 9002         	str	r0, [sp, #0x8]
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, regVal );
700a55b0: 9807         	ldr	r0, [sp, #0x1c]
700a55b2: 6940         	ldr	r0, [r0, #0x14]
700a55b4: 9906         	ldr	r1, [sp, #0x18]
700a55b6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a55ba: 9902         	ldr	r1, [sp, #0x8]
700a55bc: f00a fa88    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0xa510
700a55c0: e7ff         	b	0x700a55c2 <CSL_pktdmaTeardownChan+0xa2> @ imm = #-0x2
;             if( bWait == (bool)true )
700a55c2: f89d 0012    	ldrb.w	r0, [sp, #0x12]
700a55c6: 07c0         	lsls	r0, r0, #0x1f
700a55c8: b318         	cbz	r0, 0x700a5612 <CSL_pktdmaTeardownChan+0xf2> @ imm = #0x46
700a55ca: e7ff         	b	0x700a55cc <CSL_pktdmaTeardownChan+0xac> @ imm = #-0x2
700a55cc: 2080         	movs	r0, #0x80
;                 uint32_t retryCnt = CSL_PKTDMA_TEARDOWN_COMPLETE_WAIT_MAX_CNT;
700a55ce: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a55d0: e7ff         	b	0x700a55d2 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x2
700a55d2: 9807         	ldr	r0, [sp, #0x1c]
700a55d4: 9906         	ldr	r1, [sp, #0x18]
700a55d6: 9a05         	ldr	r2, [sp, #0x14]
700a55d8: f007 fe22    	bl	0x700ad220 <CSL_pktdmaIsChanEnabled> @ imm = #0x7c44
700a55dc: 4601         	mov	r1, r0
700a55de: 2000         	movs	r0, #0x0
700a55e0: 9000         	str	r0, [sp]
700a55e2: b131         	cbz	r1, 0x700a55f2 <CSL_pktdmaTeardownChan+0xd2> @ imm = #0xc
700a55e4: e7ff         	b	0x700a55e6 <CSL_pktdmaTeardownChan+0xc6> @ imm = #-0x2
700a55e6: 9801         	ldr	r0, [sp, #0x4]
700a55e8: 2800         	cmp	r0, #0x0
700a55ea: bf18         	it	ne
700a55ec: 2001         	movne	r0, #0x1
700a55ee: 9000         	str	r0, [sp]
700a55f0: e7ff         	b	0x700a55f2 <CSL_pktdmaTeardownChan+0xd2> @ imm = #-0x2
700a55f2: 9800         	ldr	r0, [sp]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a55f4: 07c0         	lsls	r0, r0, #0x1f
700a55f6: b120         	cbz	r0, 0x700a5602 <CSL_pktdmaTeardownChan+0xe2> @ imm = #0x8
700a55f8: e7ff         	b	0x700a55fa <CSL_pktdmaTeardownChan+0xda> @ imm = #-0x2
;                     retryCnt--;
700a55fa: 9801         	ldr	r0, [sp, #0x4]
700a55fc: 3801         	subs	r0, #0x1
700a55fe: 9001         	str	r0, [sp, #0x4]
;                 while( (CSL_pktdmaIsChanEnabled( pCfg, chanIdx, chanDir ) == (bool)true) && (retryCnt != (uint32_t)0U) )
700a5600: e7e7         	b	0x700a55d2 <CSL_pktdmaTeardownChan+0xb2> @ imm = #-0x32
;                 if( retryCnt == (uint32_t)0U ) {
700a5602: 9801         	ldr	r0, [sp, #0x4]
700a5604: b920         	cbnz	r0, 0x700a5610 <CSL_pktdmaTeardownChan+0xf0> @ imm = #0x8
700a5606: e7ff         	b	0x700a5608 <CSL_pktdmaTeardownChan+0xe8> @ imm = #-0x2
700a5608: f04f 30ff    	mov.w	r0, #0xffffffff
;                     retVal = CSL_EFAIL;
700a560c: 9003         	str	r0, [sp, #0xc]
;                 }
700a560e: e7ff         	b	0x700a5610 <CSL_pktdmaTeardownChan+0xf0> @ imm = #-0x2
;             }
700a5610: e7ff         	b	0x700a5612 <CSL_pktdmaTeardownChan+0xf2> @ imm = #-0x2
;         }
700a5612: e003         	b	0x700a561c <CSL_pktdmaTeardownChan+0xfc> @ imm = #0x6
700a5614: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a5618: 9003         	str	r0, [sp, #0xc]
700a561a: e7ff         	b	0x700a561c <CSL_pktdmaTeardownChan+0xfc> @ imm = #-0x2
700a561c: e7ff         	b	0x700a561e <CSL_pktdmaTeardownChan+0xfe> @ imm = #-0x2
;     return retVal;
700a561e: 9803         	ldr	r0, [sp, #0xc]
700a5620: b008         	add	sp, #0x20
700a5622: bd80         	pop	{r7, pc}
		...

700a5630 <UART_configInstance>:
; {
700a5630: b580         	push	{r7, lr}
700a5632: b088         	sub	sp, #0x20
700a5634: 9007         	str	r0, [sp, #0x1c]
;     baseAddr = hUart->baseAddr;
700a5636: 9807         	ldr	r0, [sp, #0x1c]
700a5638: 6800         	ldr	r0, [r0]
700a563a: 9006         	str	r0, [sp, #0x18]
;     hUartInit = hUart->hUartInit;
700a563c: 9807         	ldr	r0, [sp, #0x1c]
700a563e: 6840         	ldr	r0, [r0, #0x4]
700a5640: 9001         	str	r0, [sp, #0x4]
;     UART_resetModule(hUart);
700a5642: 9807         	ldr	r0, [sp, #0x1c]
700a5644: f007 fff4    	bl	0x700ad630 <UART_resetModule> @ imm = #0x7fe8
;     if(UART_CONFIG_MODE_DMA == hUartInit->transferMode)
700a5648: 9801         	ldr	r0, [sp, #0x4]
700a564a: 6a00         	ldr	r0, [r0, #0x20]
700a564c: 2803         	cmp	r0, #0x3
700a564e: d10e         	bne	0x700a566e <UART_configInstance+0x3e> @ imm = #0x1c
700a5650: e7ff         	b	0x700a5652 <UART_configInstance+0x22> @ imm = #-0x2
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a5652: 9801         	ldr	r0, [sp, #0x4]
700a5654: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a5658: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a565c: 0380         	lsls	r0, r0, #0xe
700a565e: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a5662: 2131         	movs	r1, #0x31
700a5664: f2c0 4140    	movt	r1, #0x440
700a5668: 4308         	orrs	r0, r1
700a566a: 9005         	str	r0, [sp, #0x14]
;     }
700a566c: e00d         	b	0x700a568a <UART_configInstance+0x5a> @ imm = #0x1a
;         regVal = UART_FIFO_CONFIG(UART_TRIG_LVL_GRANULARITY_1,
700a566e: 9801         	ldr	r0, [sp, #0x4]
700a5670: f890 1038    	ldrb.w	r1, [r0, #0x38]
700a5674: f890 003c    	ldrb.w	r0, [r0, #0x3c]
700a5678: 0380         	lsls	r0, r0, #0xe
700a567a: ea40 1081    	orr.w	r0, r0, r1, lsl #6
700a567e: 2130         	movs	r1, #0x30
700a5680: f2c0 4140    	movt	r1, #0x440
700a5684: 4308         	orrs	r0, r1
700a5686: 9005         	str	r0, [sp, #0x14]
700a5688: e7ff         	b	0x700a568a <UART_configInstance+0x5a> @ imm = #-0x2
;     (void)UART_fifoConfig(baseAddr, regVal);
700a568a: 9806         	ldr	r0, [sp, #0x18]
700a568c: 9905         	ldr	r1, [sp, #0x14]
700a568e: f7f9 f88f    	bl	0x7009e7b0 <UART_fifoConfig> @ imm = #-0x6ee2
;     UART_timeGuardConfig(baseAddr, hUartInit->timeGuardVal);
700a5692: 9806         	ldr	r0, [sp, #0x18]
700a5694: 9901         	ldr	r1, [sp, #0x4]
700a5696: 6d09         	ldr	r1, [r1, #0x50]
700a5698: f009 ffe2    	bl	0x700af660 <UART_timeGuardConfig> @ imm = #0x9fc4
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a569c: 9a01         	ldr	r2, [sp, #0x4]
700a569e: 6810         	ldr	r0, [r2]
;                                     hUartInit->baudRate,
700a56a0: 6851         	ldr	r1, [r2, #0x4]
;                                     hUartInit->operMode,
700a56a2: 6ad2         	ldr	r2, [r2, #0x2c]
700a56a4: 232a         	movs	r3, #0x2a
;     divisorVal = UART_divisorValCompute(hUartInit->inputClkFreq,
700a56a6: f006 f9f3    	bl	0x700aba90 <UART_divisorValCompute> @ imm = #0x63e6
700a56aa: 9004         	str	r0, [sp, #0x10]
;     (void)UART_divisorLatchWrite(baseAddr, divisorVal);
700a56ac: 9806         	ldr	r0, [sp, #0x18]
700a56ae: 9904         	ldr	r1, [sp, #0x10]
700a56b0: f7ff fa56    	bl	0x700a4b60 <UART_divisorLatchWrite> @ imm = #-0xb54
;     (void)UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a56b4: 9806         	ldr	r0, [sp, #0x18]
700a56b6: 21bf         	movs	r1, #0xbf
700a56b8: f007 f862    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x70c4
;     wLenStbFlag = (hUartInit->dataLength << UART_LCR_CHAR_LENGTH_SHIFT);
700a56bc: 9801         	ldr	r0, [sp, #0x4]
700a56be: 6880         	ldr	r0, [r0, #0x8]
700a56c0: 9003         	str	r0, [sp, #0xc]
;     wLenStbFlag |= (hUartInit->stopBits << UART_LCR_NB_STOP_SHIFT);
700a56c2: 9801         	ldr	r0, [sp, #0x4]
700a56c4: 68c1         	ldr	r1, [r0, #0xc]
700a56c6: 9803         	ldr	r0, [sp, #0xc]
700a56c8: ea40 0081    	orr.w	r0, r0, r1, lsl #2
700a56cc: 9003         	str	r0, [sp, #0xc]
;     parityFlag = (hUartInit->parityType << UART_LCR_PARITY_EN_SHIFT);
700a56ce: 9801         	ldr	r0, [sp, #0x4]
700a56d0: 6900         	ldr	r0, [r0, #0x10]
700a56d2: 00c0         	lsls	r0, r0, #0x3
700a56d4: 9002         	str	r0, [sp, #0x8]
;     UART_lineCharConfig(baseAddr, wLenStbFlag, parityFlag);
700a56d6: 9806         	ldr	r0, [sp, #0x18]
700a56d8: 9903         	ldr	r1, [sp, #0xc]
700a56da: 9a02         	ldr	r2, [sp, #0x8]
700a56dc: f007 ff30    	bl	0x700ad540 <UART_lineCharConfig> @ imm = #0x7e60
;     UART_divisorLatchDisable(baseAddr);
700a56e0: 9806         	ldr	r0, [sp, #0x18]
700a56e2: f00a f81d    	bl	0x700af720 <UART_divisorLatchDisable> @ imm = #0xa03a
;     UART_breakCtl(baseAddr, UART_BREAK_COND_DISABLE);
700a56e6: 9806         	ldr	r0, [sp, #0x18]
700a56e8: 2100         	movs	r1, #0x0
700a56ea: f009 feb9    	bl	0x700af460 <UART_breakCtl> @ imm = #0x9d72
;     (void)UART_operatingModeSelect(baseAddr, hUartInit->operMode);
700a56ee: 9806         	ldr	r0, [sp, #0x18]
700a56f0: 9901         	ldr	r1, [sp, #0x4]
700a56f2: 6ac9         	ldr	r1, [r1, #0x2c]
700a56f4: f009 fb94    	bl	0x700aee20 <UART_operatingModeSelect> @ imm = #0x9728
;     if (hUartInit->hwFlowControl == (uint32_t)TRUE)
700a56f8: 9801         	ldr	r0, [sp, #0x4]
700a56fa: 6980         	ldr	r0, [r0, #0x18]
700a56fc: 2801         	cmp	r0, #0x1
700a56fe: d112         	bne	0x700a5726 <UART_configInstance+0xf6> @ imm = #0x24
700a5700: e7ff         	b	0x700a5702 <UART_configInstance+0xd2> @ imm = #-0x2
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_RTS_CTS_ENABLE);
700a5702: 9806         	ldr	r0, [sp, #0x18]
700a5704: 2103         	movs	r1, #0x3
700a5706: f009 f813    	bl	0x700ae730 <UART_hardwareFlowCtrlOptSet> @ imm = #0x9026
;         if (hUartInit->hwFlowControlThr >= hUartInit->rxTrigLvl)
700a570a: 9901         	ldr	r1, [sp, #0x4]
700a570c: 69c8         	ldr	r0, [r1, #0x1c]
700a570e: 6b89         	ldr	r1, [r1, #0x38]
700a5710: 4288         	cmp	r0, r1
700a5712: d307         	blo	0x700a5724 <UART_configInstance+0xf4> @ imm = #0xe
700a5714: e7ff         	b	0x700a5716 <UART_configInstance+0xe6> @ imm = #-0x2
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a5716: 9806         	ldr	r0, [sp, #0x18]
;                                     hUartInit->hwFlowControlThr,
700a5718: 9a01         	ldr	r2, [sp, #0x4]
700a571a: 69d1         	ldr	r1, [r2, #0x1c]
;                                     hUartInit->rxTrigLvl);
700a571c: 6b92         	ldr	r2, [r2, #0x38]
;             UART_flowCtrlTrigLvlConfig(baseAddr,
700a571e: f009 f897    	bl	0x700ae850 <UART_flowCtrlTrigLvlConfig> @ imm = #0x912e
;         }
700a5722: e7ff         	b	0x700a5724 <UART_configInstance+0xf4> @ imm = #-0x2
;     }
700a5724: e004         	b	0x700a5730 <UART_configInstance+0x100> @ imm = #0x8
;         UART_hardwareFlowCtrlOptSet(baseAddr, UART_NO_HARDWARE_FLOW_CONTROL);
700a5726: 9806         	ldr	r0, [sp, #0x18]
700a5728: 2100         	movs	r1, #0x0
700a572a: f009 f801    	bl	0x700ae730 <UART_hardwareFlowCtrlOptSet> @ imm = #0x9002
700a572e: e7ff         	b	0x700a5730 <UART_configInstance+0x100> @ imm = #-0x2
;     return;
700a5730: b008         	add	sp, #0x20
700a5732: bd80         	pop	{r7, pc}
		...

700a5740 <Sciclient_rmIrGetOutp>:
; {
700a5740: b580         	push	{r7, lr}
700a5742: b088         	sub	sp, #0x20
700a5744: f8ad 001e    	strh.w	r0, [sp, #0x1e]
700a5748: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700a574c: 9206         	str	r2, [sp, #0x18]
700a574e: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a5750: 9005         	str	r0, [sp, #0x14]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a5752: 9004         	str	r0, [sp, #0x10]
;     if (outp == NULL) {
700a5754: 9806         	ldr	r0, [sp, #0x18]
700a5756: b920         	cbnz	r0, 0x700a5762 <Sciclient_rmIrGetOutp+0x22> @ imm = #0x8
700a5758: e7ff         	b	0x700a575a <Sciclient_rmIrGetOutp+0x1a> @ imm = #-0x2
700a575a: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a575e: 9005         	str	r0, [sp, #0x14]
;     } else {
700a5760: e018         	b	0x700a5794 <Sciclient_rmIrGetOutp+0x54> @ imm = #0x30
;         inst = Sciclient_rmIrGetInst(id);
700a5762: f8bd 001e    	ldrh.w	r0, [sp, #0x1e]
700a5766: f006 fa03    	bl	0x700abb70 <Sciclient_rmIrGetInst> @ imm = #0x6406
700a576a: 9004         	str	r0, [sp, #0x10]
;         if (inst == NULL) {
700a576c: 9804         	ldr	r0, [sp, #0x10]
700a576e: b920         	cbnz	r0, 0x700a577a <Sciclient_rmIrGetOutp+0x3a> @ imm = #0x8
700a5770: e7ff         	b	0x700a5772 <Sciclient_rmIrGetOutp+0x32> @ imm = #-0x2
700a5772: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a5776: 9005         	str	r0, [sp, #0x14]
;         } else {
700a5778: e00b         	b	0x700a5792 <Sciclient_rmIrGetOutp+0x52> @ imm = #0x16
;             if (inp >= inst->n_inp) {
700a577a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a577e: 9904         	ldr	r1, [sp, #0x10]
700a5780: 8909         	ldrh	r1, [r1, #0x8]
700a5782: 4288         	cmp	r0, r1
700a5784: db04         	blt	0x700a5790 <Sciclient_rmIrGetOutp+0x50> @ imm = #0x8
700a5786: e7ff         	b	0x700a5788 <Sciclient_rmIrGetOutp+0x48> @ imm = #-0x2
700a5788: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700a578c: 9005         	str	r0, [sp, #0x14]
;             }
700a578e: e7ff         	b	0x700a5790 <Sciclient_rmIrGetOutp+0x50> @ imm = #-0x2
700a5790: e7ff         	b	0x700a5792 <Sciclient_rmIrGetOutp+0x52> @ imm = #-0x2
700a5792: e7ff         	b	0x700a5794 <Sciclient_rmIrGetOutp+0x54> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp == 0u)) {
700a5794: 9805         	ldr	r0, [sp, #0x14]
700a5796: b9a8         	cbnz	r0, 0x700a57c4 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x2a
700a5798: e7ff         	b	0x700a579a <Sciclient_rmIrGetOutp+0x5a> @ imm = #-0x2
700a579a: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a579e: b988         	cbnz	r0, 0x700a57c4 <Sciclient_rmIrGetOutp+0x84> @ imm = #0x22
700a57a0: e7ff         	b	0x700a57a2 <Sciclient_rmIrGetOutp+0x62> @ imm = #-0x2
;         if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a57a2: 9804         	ldr	r0, [sp, #0x10]
700a57a4: 8980         	ldrh	r0, [r0, #0xc]
700a57a6: f64f 71ff    	movw	r1, #0xffff
700a57aa: 4288         	cmp	r0, r1
700a57ac: d005         	beq	0x700a57ba <Sciclient_rmIrGetOutp+0x7a> @ imm = #0xa
700a57ae: e7ff         	b	0x700a57b0 <Sciclient_rmIrGetOutp+0x70> @ imm = #-0x2
;             *outp = inst->inp0_mapping;
700a57b0: 9804         	ldr	r0, [sp, #0x10]
700a57b2: 8980         	ldrh	r0, [r0, #0xc]
700a57b4: 9906         	ldr	r1, [sp, #0x18]
700a57b6: 8008         	strh	r0, [r1]
;         } else {
700a57b8: e003         	b	0x700a57c2 <Sciclient_rmIrGetOutp+0x82> @ imm = #0x6
700a57ba: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a57be: 9005         	str	r0, [sp, #0x14]
700a57c0: e7ff         	b	0x700a57c2 <Sciclient_rmIrGetOutp+0x82> @ imm = #-0x2
;     }
700a57c2: e7ff         	b	0x700a57c4 <Sciclient_rmIrGetOutp+0x84> @ imm = #-0x2
;     if ((r == SystemP_SUCCESS) && (inp != 0u)) {
700a57c4: 9805         	ldr	r0, [sp, #0x14]
700a57c6: bbb8         	cbnz	r0, 0x700a5838 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x6e
700a57c8: e7ff         	b	0x700a57ca <Sciclient_rmIrGetOutp+0x8a> @ imm = #-0x2
700a57ca: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a57ce: b398         	cbz	r0, 0x700a5838 <Sciclient_rmIrGetOutp+0xf8> @ imm = #0x66
700a57d0: e7ff         	b	0x700a57d2 <Sciclient_rmIrGetOutp+0x92> @ imm = #-0x2
700a57d2: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a57d6: 9005         	str	r0, [sp, #0x14]
700a57d8: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_outp; i++) {
700a57da: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a57de: e7ff         	b	0x700a57e0 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x2
700a57e0: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a57e4: 9904         	ldr	r1, [sp, #0x10]
700a57e6: 8949         	ldrh	r1, [r1, #0xa]
700a57e8: 4288         	cmp	r0, r1
700a57ea: da24         	bge	0x700a5836 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0x48
700a57ec: e7ff         	b	0x700a57ee <Sciclient_rmIrGetOutp+0xae> @ imm = #-0x2
;             int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, i);
700a57ee: 9804         	ldr	r0, [sp, #0x10]
700a57f0: 6840         	ldr	r0, [r0, #0x4]
700a57f2: f8bd 100e    	ldrh.w	r1, [sp, #0xe]
700a57f6: f009 f9db    	bl	0x700aebb0 <Sciclient_getIrAddr> @ imm = #0x93b6
700a57fa: 9002         	str	r0, [sp, #0x8]
;             extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a57fc: 9802         	ldr	r0, [sp, #0x8]
700a57fe: f240 31ff    	movw	r1, #0x3ff
700a5802: 2200         	movs	r2, #0x0
700a5804: f009 fca4    	bl	0x700af150 <CSL_REG32_FEXT_RAW> @ imm = #0x9948
700a5808: f8ad 0006    	strh.w	r0, [sp, #0x6]
;             if (inp == extracted_inp) {
700a580c: f8bd 001c    	ldrh.w	r0, [sp, #0x1c]
700a5810: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700a5814: 4288         	cmp	r0, r1
700a5816: d107         	bne	0x700a5828 <Sciclient_rmIrGetOutp+0xe8> @ imm = #0xe
700a5818: e7ff         	b	0x700a581a <Sciclient_rmIrGetOutp+0xda> @ imm = #-0x2
;                 *outp = i;
700a581a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a581e: 9906         	ldr	r1, [sp, #0x18]
700a5820: 8008         	strh	r0, [r1]
700a5822: 2000         	movs	r0, #0x0
;                 r = SystemP_SUCCESS;
700a5824: 9005         	str	r0, [sp, #0x14]
;                 break;
700a5826: e006         	b	0x700a5836 <Sciclient_rmIrGetOutp+0xf6> @ imm = #0xc
;         }
700a5828: e7ff         	b	0x700a582a <Sciclient_rmIrGetOutp+0xea> @ imm = #-0x2
;         for (i = 0u; i < inst->n_outp; i++) {
700a582a: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700a582e: 3001         	adds	r0, #0x1
700a5830: f8ad 000e    	strh.w	r0, [sp, #0xe]
700a5834: e7d4         	b	0x700a57e0 <Sciclient_rmIrGetOutp+0xa0> @ imm = #-0x58
;     }
700a5836: e7ff         	b	0x700a5838 <Sciclient_rmIrGetOutp+0xf8> @ imm = #-0x2
;     return r;
700a5838: 9805         	ldr	r0, [sp, #0x14]
700a583a: b008         	add	sp, #0x20
700a583c: bd80         	pop	{r7, pc}
700a583e: 0000         	movs	r0, r0

700a5840 <eTaskGetState>:
; eTaskState eTaskGetState(TaskHandle_t xTask) {
700a5840: b580         	push	{r7, lr}
700a5842: b088         	sub	sp, #0x20
700a5844: 9007         	str	r0, [sp, #0x1c]
;   const TCB_t *const pxTCB = xTask;
700a5846: 9807         	ldr	r0, [sp, #0x1c]
700a5848: 9002         	str	r0, [sp, #0x8]
;   if (pxTCB == pxCurrentTCB) {
700a584a: 9802         	ldr	r0, [sp, #0x8]
700a584c: f642 11fc    	movw	r1, #0x29fc
700a5850: f2c7 010b    	movt	r1, #0x700b
700a5854: 6809         	ldr	r1, [r1]
700a5856: 4288         	cmp	r0, r1
700a5858: d104         	bne	0x700a5864 <eTaskGetState+0x24> @ imm = #0x8
700a585a: e7ff         	b	0x700a585c <eTaskGetState+0x1c> @ imm = #-0x2
700a585c: 2000         	movs	r0, #0x0
;     eReturn = eRunning;
700a585e: f88d 001b    	strb.w	r0, [sp, #0x1b]
;   } else {
700a5862: e063         	b	0x700a592c <eTaskGetState+0xec> @ imm = #0xc6
;     taskENTER_CRITICAL();
700a5864: f008 ff84    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x8f08
;       pxStateList = listLIST_ITEM_CONTAINER(&(pxTCB->xStateListItem));
700a5868: 9802         	ldr	r0, [sp, #0x8]
700a586a: 6940         	ldr	r0, [r0, #0x14]
700a586c: 9005         	str	r0, [sp, #0x14]
;       pxDelayedList = pxDelayedTaskList;
700a586e: f245 20a0    	movw	r0, #0x52a0
700a5872: f2c7 0008    	movt	r0, #0x7008
700a5876: 6800         	ldr	r0, [r0]
700a5878: 9004         	str	r0, [sp, #0x10]
;       pxOverflowedDelayedList = pxOverflowDelayedTaskList;
700a587a: f245 20a4    	movw	r0, #0x52a4
700a587e: f2c7 0008    	movt	r0, #0x7008
700a5882: 6800         	ldr	r0, [r0]
700a5884: 9003         	str	r0, [sp, #0xc]
;     taskEXIT_CRITICAL();
700a5886: f008 f833    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x8066
;     if ((pxStateList == pxDelayedList) ||
700a588a: 9805         	ldr	r0, [sp, #0x14]
700a588c: 9904         	ldr	r1, [sp, #0x10]
700a588e: 4288         	cmp	r0, r1
700a5890: d005         	beq	0x700a589e <eTaskGetState+0x5e> @ imm = #0xa
700a5892: e7ff         	b	0x700a5894 <eTaskGetState+0x54> @ imm = #-0x2
;         (pxStateList == pxOverflowedDelayedList)) {
700a5894: 9805         	ldr	r0, [sp, #0x14]
700a5896: 9903         	ldr	r1, [sp, #0xc]
;     if ((pxStateList == pxDelayedList) ||
700a5898: 4288         	cmp	r0, r1
700a589a: d104         	bne	0x700a58a6 <eTaskGetState+0x66> @ imm = #0x8
700a589c: e7ff         	b	0x700a589e <eTaskGetState+0x5e> @ imm = #-0x2
700a589e: 2002         	movs	r0, #0x2
;       eReturn = eBlocked;
700a58a0: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a58a4: e041         	b	0x700a592a <eTaskGetState+0xea> @ imm = #0x82
;     else if (pxStateList == &xSuspendedTaskList) {
700a58a6: 9805         	ldr	r0, [sp, #0x14]
700a58a8: f245 2174    	movw	r1, #0x5274
700a58ac: f2c7 0108    	movt	r1, #0x7008
700a58b0: 4288         	cmp	r0, r1
700a58b2: d125         	bne	0x700a5900 <eTaskGetState+0xc0> @ imm = #0x4a
700a58b4: e7ff         	b	0x700a58b6 <eTaskGetState+0x76> @ imm = #-0x2
;       if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL) {
700a58b6: 9802         	ldr	r0, [sp, #0x8]
700a58b8: 6a80         	ldr	r0, [r0, #0x28]
700a58ba: b9e0         	cbnz	r0, 0x700a58f6 <eTaskGetState+0xb6> @ imm = #0x38
700a58bc: e7ff         	b	0x700a58be <eTaskGetState+0x7e> @ imm = #-0x2
700a58be: 2003         	movs	r0, #0x3
;           eReturn = eSuspended;
700a58c0: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a58c4: 2000         	movs	r0, #0x0
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a58c6: 9001         	str	r0, [sp, #0x4]
700a58c8: e7ff         	b	0x700a58ca <eTaskGetState+0x8a> @ imm = #-0x2
700a58ca: 9801         	ldr	r0, [sp, #0x4]
700a58cc: 2800         	cmp	r0, #0x0
700a58ce: dc11         	bgt	0x700a58f4 <eTaskGetState+0xb4> @ imm = #0x22
700a58d0: e7ff         	b	0x700a58d2 <eTaskGetState+0x92> @ imm = #-0x2
;             if (pxTCB->ucNotifyState[x] == taskWAITING_NOTIFICATION) {
700a58d2: 9802         	ldr	r0, [sp, #0x8]
700a58d4: 9901         	ldr	r1, [sp, #0x4]
700a58d6: 4408         	add	r0, r1
700a58d8: f890 0080    	ldrb.w	r0, [r0, #0x80]
700a58dc: 2801         	cmp	r0, #0x1
700a58de: d104         	bne	0x700a58ea <eTaskGetState+0xaa> @ imm = #0x8
700a58e0: e7ff         	b	0x700a58e2 <eTaskGetState+0xa2> @ imm = #-0x2
700a58e2: 2002         	movs	r0, #0x2
;               eReturn = eBlocked;
700a58e4: f88d 001b    	strb.w	r0, [sp, #0x1b]
;               break;
700a58e8: e004         	b	0x700a58f4 <eTaskGetState+0xb4> @ imm = #0x8
;           }
700a58ea: e7ff         	b	0x700a58ec <eTaskGetState+0xac> @ imm = #-0x2
;           for (x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++) {
700a58ec: 9801         	ldr	r0, [sp, #0x4]
700a58ee: 3001         	adds	r0, #0x1
700a58f0: 9001         	str	r0, [sp, #0x4]
700a58f2: e7ea         	b	0x700a58ca <eTaskGetState+0x8a> @ imm = #-0x2c
;       } else {
700a58f4: e003         	b	0x700a58fe <eTaskGetState+0xbe> @ imm = #0x6
700a58f6: 2002         	movs	r0, #0x2
;         eReturn = eBlocked;
700a58f8: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a58fc: e7ff         	b	0x700a58fe <eTaskGetState+0xbe> @ imm = #-0x2
;     }
700a58fe: e013         	b	0x700a5928 <eTaskGetState+0xe8> @ imm = #0x26
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a5900: 9805         	ldr	r0, [sp, #0x14]
700a5902: f245 2188    	movw	r1, #0x5288
700a5906: f2c7 0108    	movt	r1, #0x7008
700a590a: 4288         	cmp	r0, r1
700a590c: d003         	beq	0x700a5916 <eTaskGetState+0xd6> @ imm = #0x6
700a590e: e7ff         	b	0x700a5910 <eTaskGetState+0xd0> @ imm = #-0x2
;              (pxStateList == NULL)) {
700a5910: 9805         	ldr	r0, [sp, #0x14]
;     else if ((pxStateList == &xTasksWaitingTermination) ||
700a5912: b920         	cbnz	r0, 0x700a591e <eTaskGetState+0xde> @ imm = #0x8
700a5914: e7ff         	b	0x700a5916 <eTaskGetState+0xd6> @ imm = #-0x2
700a5916: 2004         	movs	r0, #0x4
;       eReturn = eDeleted;
700a5918: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     }
700a591c: e003         	b	0x700a5926 <eTaskGetState+0xe6> @ imm = #0x6
700a591e: 2001         	movs	r0, #0x1
;       eReturn = eReady;
700a5920: f88d 001b    	strb.w	r0, [sp, #0x1b]
700a5924: e7ff         	b	0x700a5926 <eTaskGetState+0xe6> @ imm = #-0x2
700a5926: e7ff         	b	0x700a5928 <eTaskGetState+0xe8> @ imm = #-0x2
700a5928: e7ff         	b	0x700a592a <eTaskGetState+0xea> @ imm = #-0x2
700a592a: e7ff         	b	0x700a592c <eTaskGetState+0xec> @ imm = #-0x2
;   return eReturn;
700a592c: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a5930: b008         	add	sp, #0x20
700a5932: bd80         	pop	{r7, pc}
		...

700a5940 <PMU_profileEnd>:
; int32_t PMU_profileEnd(const char *name) {
700a5940: b580         	push	{r7, lr}
700a5942: b090         	sub	sp, #0x40
700a5944: 900e         	str	r0, [sp, #0x38]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a5946: f243 0080    	movw	r0, #0x3080
700a594a: f2c7 0008    	movt	r0, #0x7008
700a594e: 6800         	ldr	r0, [r0]
700a5950: 2840         	cmp	r0, #0x40
700a5952: d304         	blo	0x700a595e <PMU_profileEnd+0x1e> @ imm = #0x8
700a5954: e7ff         	b	0x700a5956 <PMU_profileEnd+0x16> @ imm = #-0x2
700a5956: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a595a: 900f         	str	r0, [sp, #0x3c]
700a595c: e065         	b	0x700a5a2a <PMU_profileEnd+0xea> @ imm = #0xca
700a595e: 2000         	movs	r0, #0x0
;   int32_t status = SystemP_SUCCESS;
700a5960: 9000         	str	r0, [sp]
700a5962: 900d         	str	r0, [sp, #0x34]
700a5964: 201f         	movs	r0, #0x1f
;   uint32_t ccount = CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a5966: f7fc ec52    	blx	0x700a220c <CSL_armR5PmuReadCntr> @ imm = #-0x375c
700a596a: 4601         	mov	r1, r0
700a596c: 9800         	ldr	r0, [sp]
700a596e: 910c         	str	r1, [sp, #0x30]
;   uint32_t count0 = CSL_armR5PmuReadCntr(0);
700a5970: f7fc ec4c    	blx	0x700a220c <CSL_armR5PmuReadCntr> @ imm = #-0x3768
700a5974: 900b         	str	r0, [sp, #0x2c]
700a5976: 2001         	movs	r0, #0x1
;   uint32_t count1 = CSL_armR5PmuReadCntr(1);
700a5978: f7fc ec48    	blx	0x700a220c <CSL_armR5PmuReadCntr> @ imm = #-0x3770
700a597c: 900a         	str	r0, [sp, #0x28]
700a597e: 2002         	movs	r0, #0x2
;   uint32_t count2 = CSL_armR5PmuReadCntr(2);
700a5980: f7fc ec44    	blx	0x700a220c <CSL_armR5PmuReadCntr> @ imm = #-0x3778
700a5984: 9009         	str	r0, [sp, #0x24]
;   uint32_t counts[3] = {count0, count1, count2};
700a5986: 980b         	ldr	r0, [sp, #0x2c]
700a5988: 9006         	str	r0, [sp, #0x18]
700a598a: 980a         	ldr	r0, [sp, #0x28]
700a598c: 9007         	str	r0, [sp, #0x1c]
700a598e: 9809         	ldr	r0, [sp, #0x24]
700a5990: 9008         	str	r0, [sp, #0x20]
;   uint32_t i = gProfileObject.logIndex;
700a5992: f243 0280    	movw	r2, #0x3080
700a5996: f2c7 0208    	movt	r2, #0x7008
700a599a: 6810         	ldr	r0, [r2]
700a599c: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a599e: 6890         	ldr	r0, [r2, #0x8]
700a59a0: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a59a2: 6850         	ldr	r0, [r2, #0x4]
700a59a4: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a59a6: 9805         	ldr	r0, [sp, #0x14]
700a59a8: 2134         	movs	r1, #0x34
700a59aa: fb00 2001    	mla	r0, r0, r1, r2
700a59ae: 300c         	adds	r0, #0xc
700a59b0: 9001         	str	r0, [sp, #0x4]
;   if (strcmp(name, p->name) != 0) {
700a59b2: 980e         	ldr	r0, [sp, #0x38]
700a59b4: 9901         	ldr	r1, [sp, #0x4]
700a59b6: 6b09         	ldr	r1, [r1, #0x30]
700a59b8: f7f6 ec72    	blx	0x7009c2a0 <strcmp>     @ imm = #-0x971c
700a59bc: b120         	cbz	r0, 0x700a59c8 <PMU_profileEnd+0x88> @ imm = #0x8
700a59be: e7ff         	b	0x700a59c0 <PMU_profileEnd+0x80> @ imm = #-0x2
700a59c0: f04f 30ff    	mov.w	r0, #0xffffffff
;     status = SystemP_FAILURE;
700a59c4: 900d         	str	r0, [sp, #0x34]
;   }
700a59c6: e7ff         	b	0x700a59c8 <PMU_profileEnd+0x88> @ imm = #-0x2
;   if (status == SystemP_SUCCESS) {
700a59c8: 980d         	ldr	r0, [sp, #0x34]
700a59ca: bb58         	cbnz	r0, 0x700a5a24 <PMU_profileEnd+0xe4> @ imm = #0x56
700a59cc: e7ff         	b	0x700a59ce <PMU_profileEnd+0x8e> @ imm = #-0x2
;     if (bCCnt == TRUE) {
700a59ce: 9802         	ldr	r0, [sp, #0x8]
700a59d0: 2801         	cmp	r0, #0x1
700a59d2: d106         	bne	0x700a59e2 <PMU_profileEnd+0xa2> @ imm = #0xc
700a59d4: e7ff         	b	0x700a59d6 <PMU_profileEnd+0x96> @ imm = #-0x2
;       p->cycleCount.value = ccount - p->cycleCount.value;
700a59d6: 980c         	ldr	r0, [sp, #0x30]
700a59d8: 9901         	ldr	r1, [sp, #0x4]
700a59da: 6aca         	ldr	r2, [r1, #0x2c]
700a59dc: 1a80         	subs	r0, r0, r2
700a59de: 62c8         	str	r0, [r1, #0x2c]
;     }
700a59e0: e7ff         	b	0x700a59e2 <PMU_profileEnd+0xa2> @ imm = #-0x2
700a59e2: 2000         	movs	r0, #0x0
;     for (j = 0; j < numEvents; j++) {
700a59e4: 9004         	str	r0, [sp, #0x10]
700a59e6: e7ff         	b	0x700a59e8 <PMU_profileEnd+0xa8> @ imm = #-0x2
700a59e8: 9804         	ldr	r0, [sp, #0x10]
700a59ea: 9903         	ldr	r1, [sp, #0xc]
700a59ec: 4288         	cmp	r0, r1
700a59ee: d211         	bhs	0x700a5a14 <PMU_profileEnd+0xd4> @ imm = #0x22
700a59f0: e7ff         	b	0x700a59f2 <PMU_profileEnd+0xb2> @ imm = #-0x2
;       p->events[j].value = counts[j] - p->events[j].value;
700a59f2: 9a04         	ldr	r2, [sp, #0x10]
700a59f4: a806         	add	r0, sp, #0x18
700a59f6: f850 0022    	ldr.w	r0, [r0, r2, lsl #2]
700a59fa: 9901         	ldr	r1, [sp, #0x4]
700a59fc: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a5a00: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a5a04: 688a         	ldr	r2, [r1, #0x8]
700a5a06: 1a80         	subs	r0, r0, r2
700a5a08: 6088         	str	r0, [r1, #0x8]
;     }
700a5a0a: e7ff         	b	0x700a5a0c <PMU_profileEnd+0xcc> @ imm = #-0x2
;     for (j = 0; j < numEvents; j++) {
700a5a0c: 9804         	ldr	r0, [sp, #0x10]
700a5a0e: 3001         	adds	r0, #0x1
700a5a10: 9004         	str	r0, [sp, #0x10]
700a5a12: e7e9         	b	0x700a59e8 <PMU_profileEnd+0xa8> @ imm = #-0x2e
;     gProfileObject.logIndex++;
700a5a14: f243 0180    	movw	r1, #0x3080
700a5a18: f2c7 0108    	movt	r1, #0x7008
700a5a1c: 6808         	ldr	r0, [r1]
700a5a1e: 3001         	adds	r0, #0x1
700a5a20: 6008         	str	r0, [r1]
;   }
700a5a22: e7ff         	b	0x700a5a24 <PMU_profileEnd+0xe4> @ imm = #-0x2
;   return status;
700a5a24: 980d         	ldr	r0, [sp, #0x34]
700a5a26: 900f         	str	r0, [sp, #0x3c]
700a5a28: e7ff         	b	0x700a5a2a <PMU_profileEnd+0xea> @ imm = #-0x2
; }
700a5a2a: 980f         	ldr	r0, [sp, #0x3c]
700a5a2c: b010         	add	sp, #0x40
700a5a2e: bd80         	pop	{r7, pc}

700a5a30 <Udma_eventIsrFxn>:
; {
700a5a30: b580         	push	{r7, lr}
700a5a32: b088         	sub	sp, #0x20
700a5a34: 9007         	str	r0, [sp, #0x1c]
;     Udma_EventHandleInt eventHandle = (Udma_EventHandleInt) args;
700a5a36: 9807         	ldr	r0, [sp, #0x1c]
700a5a38: 9003         	str	r0, [sp, #0xc]
700a5a3a: 2001         	movs	r0, #0x1
;     teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_NA;
700a5a3c: 9004         	str	r0, [sp, #0x10]
700a5a3e: 2000         	movs	r0, #0x0
;     ringHandle = NULL;
700a5a40: 9000         	str	r0, [sp]
;     drvHandle = eventHandle->drvHandle;
700a5a42: 9803         	ldr	r0, [sp, #0xc]
700a5a44: 6800         	ldr	r0, [r0]
700a5a46: 9002         	str	r0, [sp, #0x8]
;     vintrNum = eventHandle->vintrNum;
700a5a48: 9803         	ldr	r0, [sp, #0xc]
700a5a4a: 6cc0         	ldr	r0, [r0, #0x4c]
700a5a4c: 9005         	str	r0, [sp, #0x14]
;     while(eventHandle != NULL_PTR)
700a5a4e: e7ff         	b	0x700a5a50 <Udma_eventIsrFxn+0x20> @ imm = #-0x2
700a5a50: 9803         	ldr	r0, [sp, #0xc]
700a5a52: 2800         	cmp	r0, #0x0
700a5a54: d060         	beq	0x700a5b18 <Udma_eventIsrFxn+0xe8> @ imm = #0xc0
700a5a56: e7ff         	b	0x700a5a58 <Udma_eventIsrFxn+0x28> @ imm = #-0x2
;         if(UDMA_EVENT_TYPE_MASTER != eventHandle->eventPrms.eventType)
700a5a58: 9803         	ldr	r0, [sp, #0xc]
700a5a5a: 6880         	ldr	r0, [r0, #0x8]
700a5a5c: 2805         	cmp	r0, #0x5
700a5a5e: d057         	beq	0x700a5b10 <Udma_eventIsrFxn+0xe0> @ imm = #0xae
700a5a60: e7ff         	b	0x700a5a62 <Udma_eventIsrFxn+0x32> @ imm = #-0x2
;             vintrBitNum = vintrNum * UDMA_MAX_EVENTS_PER_VINTR;
700a5a62: 9805         	ldr	r0, [sp, #0x14]
700a5a64: 0180         	lsls	r0, r0, #0x6
700a5a66: 9006         	str	r0, [sp, #0x18]
;             vintrBitNum += eventHandle->vintrBitNum;
700a5a68: 9803         	ldr	r0, [sp, #0xc]
700a5a6a: 6d01         	ldr	r1, [r0, #0x50]
700a5a6c: 9806         	ldr	r0, [sp, #0x18]
700a5a6e: 4408         	add	r0, r1
700a5a70: 9006         	str	r0, [sp, #0x18]
;             if((bool)true == CSL_intaggrIsIntrPending(&drvHandle->iaRegs, vintrBitNum, (bool)true))
700a5a72: 9802         	ldr	r0, [sp, #0x8]
700a5a74: 309c         	adds	r0, #0x9c
700a5a76: 9906         	ldr	r1, [sp, #0x18]
700a5a78: 2201         	movs	r2, #0x1
700a5a7a: f002 fe29    	bl	0x700a86d0 <CSL_intaggrIsIntrPending> @ imm = #0x2c52
700a5a7e: 2800         	cmp	r0, #0x0
700a5a80: d045         	beq	0x700a5b0e <Udma_eventIsrFxn+0xde> @ imm = #0x8a
700a5a82: e7ff         	b	0x700a5a84 <Udma_eventIsrFxn+0x54> @ imm = #-0x2
;                 (void) CSL_intaggrClrIntr(&drvHandle->iaRegs, vintrBitNum);
700a5a84: 9802         	ldr	r0, [sp, #0x8]
700a5a86: 309c         	adds	r0, #0x9c
700a5a88: 9906         	ldr	r1, [sp, #0x18]
700a5a8a: f005 fcb9    	bl	0x700ab400 <CSL_intaggrClrIntr> @ imm = #0x5972
;                 eventPrms = &eventHandle->eventPrms;
700a5a8e: 9803         	ldr	r0, [sp, #0xc]
700a5a90: 3008         	adds	r0, #0x8
700a5a92: 9001         	str	r0, [sp, #0x4]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a5a94: 9801         	ldr	r0, [sp, #0x4]
700a5a96: 6800         	ldr	r0, [r0]
700a5a98: 2801         	cmp	r0, #0x1
700a5a9a: d005         	beq	0x700a5aa8 <Udma_eventIsrFxn+0x78> @ imm = #0xa
700a5a9c: e7ff         	b	0x700a5a9e <Udma_eventIsrFxn+0x6e> @ imm = #-0x2
;                    (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a5a9e: 9801         	ldr	r0, [sp, #0x4]
700a5aa0: 6800         	ldr	r0, [r0]
;                 if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a5aa2: 2806         	cmp	r0, #0x6
700a5aa4: d114         	bne	0x700a5ad0 <Udma_eventIsrFxn+0xa0> @ imm = #0x28
700a5aa6: e7ff         	b	0x700a5aa8 <Udma_eventIsrFxn+0x78> @ imm = #-0x2
;                     ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a5aa8: 9801         	ldr	r0, [sp, #0x4]
700a5aaa: 6880         	ldr	r0, [r0, #0x8]
700a5aac: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a5ab0: 9000         	str	r0, [sp]
;                     if( CSL_lcdma_ringaccIsTeardownComplete(&ringHandle->drvHandle->lcdmaRaRegs, ringHandle->ringNum) == TRUE )
700a5ab2: 9900         	ldr	r1, [sp]
700a5ab4: 6808         	ldr	r0, [r1]
700a5ab6: 308c         	adds	r0, #0x8c
700a5ab8: 8889         	ldrh	r1, [r1, #0x4]
700a5aba: f008 f881    	bl	0x700adbc0 <CSL_lcdma_ringaccIsTeardownComplete> @ imm = #0x8102
700a5abe: b118         	cbz	r0, 0x700a5ac8 <Udma_eventIsrFxn+0x98> @ imm = #0x6
700a5ac0: e7ff         	b	0x700a5ac2 <Udma_eventIsrFxn+0x92> @ imm = #-0x2
700a5ac2: 2002         	movs	r0, #0x2
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE;
700a5ac4: 9004         	str	r0, [sp, #0x10]
;                     }
700a5ac6: e002         	b	0x700a5ace <Udma_eventIsrFxn+0x9e> @ imm = #0x4
700a5ac8: 2003         	movs	r0, #0x3
;                         teardownStatus = UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE;
700a5aca: 9004         	str	r0, [sp, #0x10]
700a5acc: e7ff         	b	0x700a5ace <Udma_eventIsrFxn+0x9e> @ imm = #-0x2
;                 }
700a5ace: e7ff         	b	0x700a5ad0 <Udma_eventIsrFxn+0xa0> @ imm = #-0x2
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a5ad0: 9803         	ldr	r0, [sp, #0xc]
700a5ad2: 6880         	ldr	r0, [r0, #0x8]
700a5ad4: 2801         	cmp	r0, #0x1
700a5ad6: d104         	bne	0x700a5ae2 <Udma_eventIsrFxn+0xb2> @ imm = #0x8
700a5ad8: e7ff         	b	0x700a5ada <Udma_eventIsrFxn+0xaa> @ imm = #-0x2
700a5ada: 9804         	ldr	r0, [sp, #0x10]
700a5adc: 2802         	cmp	r0, #0x2
700a5ade: d015         	beq	0x700a5b0c <Udma_eventIsrFxn+0xdc> @ imm = #0x2a
700a5ae0: e7ff         	b	0x700a5ae2 <Udma_eventIsrFxn+0xb2> @ imm = #-0x2
;                  ((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_TEARDOWN_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_INCOMPLETE))))
700a5ae2: 9803         	ldr	r0, [sp, #0xc]
700a5ae4: 6880         	ldr	r0, [r0, #0x8]
700a5ae6: 2806         	cmp	r0, #0x6
700a5ae8: d104         	bne	0x700a5af4 <Udma_eventIsrFxn+0xc4> @ imm = #0x8
700a5aea: e7ff         	b	0x700a5aec <Udma_eventIsrFxn+0xbc> @ imm = #-0x2
700a5aec: 9804         	ldr	r0, [sp, #0x10]
;                 if(!(((eventHandle->eventPrms.eventType == UDMA_EVENT_TYPE_DMA_COMPLETION) && (teardownStatus == UDMA_EVENT_CH_TEARDOWN_STATUS_COMPLETE)) ||
700a5aee: 2803         	cmp	r0, #0x3
700a5af0: d00c         	beq	0x700a5b0c <Udma_eventIsrFxn+0xdc> @ imm = #0x18
700a5af2: e7ff         	b	0x700a5af4 <Udma_eventIsrFxn+0xc4> @ imm = #-0x2
;                     if((Udma_EventCallback) NULL_PTR != eventPrms->eventCb)
700a5af4: 9801         	ldr	r0, [sp, #0x4]
700a5af6: 6940         	ldr	r0, [r0, #0x14]
700a5af8: b138         	cbz	r0, 0x700a5b0a <Udma_eventIsrFxn+0xda> @ imm = #0xe
700a5afa: e7ff         	b	0x700a5afc <Udma_eventIsrFxn+0xcc> @ imm = #-0x2
;                         eventPrms->eventCb(
700a5afc: 9a01         	ldr	r2, [sp, #0x4]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a5afe: 9803         	ldr	r0, [sp, #0xc]
700a5b00: 6811         	ldr	r1, [r2]
;                         eventPrms->eventCb(
700a5b02: 6953         	ldr	r3, [r2, #0x14]
;                             eventHandle, eventPrms->eventType, eventPrms->appData);
700a5b04: 69d2         	ldr	r2, [r2, #0x1c]
;                         eventPrms->eventCb(
700a5b06: 4798         	blx	r3
;                     }
700a5b08: e7ff         	b	0x700a5b0a <Udma_eventIsrFxn+0xda> @ imm = #-0x2
;                 }
700a5b0a: e7ff         	b	0x700a5b0c <Udma_eventIsrFxn+0xdc> @ imm = #-0x2
;             }
700a5b0c: e7ff         	b	0x700a5b0e <Udma_eventIsrFxn+0xde> @ imm = #-0x2
;         }
700a5b0e: e7ff         	b	0x700a5b10 <Udma_eventIsrFxn+0xe0> @ imm = #-0x2
;         eventHandle = eventHandle->nextEvent;
700a5b10: 9803         	ldr	r0, [sp, #0xc]
700a5b12: 6dc0         	ldr	r0, [r0, #0x5c]
700a5b14: 9003         	str	r0, [sp, #0xc]
;     while(eventHandle != NULL_PTR)
700a5b16: e79b         	b	0x700a5a50 <Udma_eventIsrFxn+0x20> @ imm = #-0xca
;     return;
700a5b18: b008         	add	sp, #0x20
700a5b1a: bd80         	pop	{r7, pc}
700a5b1c: 0000         	movs	r0, r0
700a5b1e: 0000         	movs	r0, r0

700a5b20 <vTaskPriorityDisinheritAfterTimeout>:
;     UBaseType_t uxHighestPriorityWaitingTask) {
700a5b20: b580         	push	{r7, lr}
700a5b22: b086         	sub	sp, #0x18
700a5b24: 9005         	str	r0, [sp, #0x14]
700a5b26: 9104         	str	r1, [sp, #0x10]
;   TCB_t *const pxTCB = pxMutexHolder;
700a5b28: 9805         	ldr	r0, [sp, #0x14]
700a5b2a: 9003         	str	r0, [sp, #0xc]
700a5b2c: 2001         	movs	r0, #0x1
;   const UBaseType_t uxOnlyOneMutexHeld = (UBaseType_t)1;
700a5b2e: 9000         	str	r0, [sp]
;   if (pxMutexHolder != NULL) {
700a5b30: 9805         	ldr	r0, [sp, #0x14]
700a5b32: 2800         	cmp	r0, #0x0
700a5b34: d067         	beq	0x700a5c06 <vTaskPriorityDisinheritAfterTimeout+0xe6> @ imm = #0xce
700a5b36: e7ff         	b	0x700a5b38 <vTaskPriorityDisinheritAfterTimeout+0x18> @ imm = #-0x2
;     if (pxTCB->uxBasePriority < uxHighestPriorityWaitingTask) {
700a5b38: 9803         	ldr	r0, [sp, #0xc]
700a5b3a: 6e00         	ldr	r0, [r0, #0x60]
700a5b3c: 9904         	ldr	r1, [sp, #0x10]
700a5b3e: 4288         	cmp	r0, r1
700a5b40: d203         	bhs	0x700a5b4a <vTaskPriorityDisinheritAfterTimeout+0x2a> @ imm = #0x6
700a5b42: e7ff         	b	0x700a5b44 <vTaskPriorityDisinheritAfterTimeout+0x24> @ imm = #-0x2
;       uxPriorityToUse = uxHighestPriorityWaitingTask;
700a5b44: 9804         	ldr	r0, [sp, #0x10]
700a5b46: 9001         	str	r0, [sp, #0x4]
;     } else {
700a5b48: e003         	b	0x700a5b52 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #0x6
;       uxPriorityToUse = pxTCB->uxBasePriority;
700a5b4a: 9803         	ldr	r0, [sp, #0xc]
700a5b4c: 6e00         	ldr	r0, [r0, #0x60]
700a5b4e: 9001         	str	r0, [sp, #0x4]
700a5b50: e7ff         	b	0x700a5b52 <vTaskPriorityDisinheritAfterTimeout+0x32> @ imm = #-0x2
;     if (pxTCB->uxPriority != uxPriorityToUse) {
700a5b52: 9803         	ldr	r0, [sp, #0xc]
700a5b54: 6ac0         	ldr	r0, [r0, #0x2c]
700a5b56: 9901         	ldr	r1, [sp, #0x4]
700a5b58: 4288         	cmp	r0, r1
700a5b5a: d052         	beq	0x700a5c02 <vTaskPriorityDisinheritAfterTimeout+0xe2> @ imm = #0xa4
700a5b5c: e7ff         	b	0x700a5b5e <vTaskPriorityDisinheritAfterTimeout+0x3e> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld) {
700a5b5e: 9803         	ldr	r0, [sp, #0xc]
700a5b60: 6e40         	ldr	r0, [r0, #0x64]
700a5b62: 2801         	cmp	r0, #0x1
700a5b64: d14b         	bne	0x700a5bfe <vTaskPriorityDisinheritAfterTimeout+0xde> @ imm = #0x96
700a5b66: e7ff         	b	0x700a5b68 <vTaskPriorityDisinheritAfterTimeout+0x48> @ imm = #-0x2
;         uxPriorityUsedOnEntry = pxTCB->uxPriority;
700a5b68: 9803         	ldr	r0, [sp, #0xc]
700a5b6a: 6ac0         	ldr	r0, [r0, #0x2c]
700a5b6c: 9002         	str	r0, [sp, #0x8]
;         pxTCB->uxPriority = uxPriorityToUse;
700a5b6e: 9801         	ldr	r0, [sp, #0x4]
700a5b70: 9903         	ldr	r1, [sp, #0xc]
700a5b72: 62c8         	str	r0, [r1, #0x2c]
;         if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) &
700a5b74: 9803         	ldr	r0, [sp, #0xc]
700a5b76: 7ec0         	ldrb	r0, [r0, #0x1b]
700a5b78: 0600         	lsls	r0, r0, #0x18
700a5b7a: 2800         	cmp	r0, #0x0
700a5b7c: d406         	bmi	0x700a5b8c <vTaskPriorityDisinheritAfterTimeout+0x6c> @ imm = #0xc
700a5b7e: e7ff         	b	0x700a5b80 <vTaskPriorityDisinheritAfterTimeout+0x60> @ imm = #-0x2
;           listSET_LIST_ITEM_VALUE(
700a5b80: 9801         	ldr	r0, [sp, #0x4]
700a5b82: f1c0 0020    	rsb.w	r0, r0, #0x20
700a5b86: 9903         	ldr	r1, [sp, #0xc]
700a5b88: 6188         	str	r0, [r1, #0x18]
;         } else {
700a5b8a: e000         	b	0x700a5b8e <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #0x0
700a5b8c: e7ff         	b	0x700a5b8e <vTaskPriorityDisinheritAfterTimeout+0x6e> @ imm = #-0x2
;         if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]),
700a5b8e: 9803         	ldr	r0, [sp, #0xc]
700a5b90: 6940         	ldr	r0, [r0, #0x14]
700a5b92: 9902         	ldr	r1, [sp, #0x8]
700a5b94: eb01 0281    	add.w	r2, r1, r1, lsl #2
700a5b98: f244 41f8    	movw	r1, #0x44f8
700a5b9c: f2c7 0108    	movt	r1, #0x7008
700a5ba0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a5ba4: 4288         	cmp	r0, r1
700a5ba6: d128         	bne	0x700a5bfa <vTaskPriorityDisinheritAfterTimeout+0xda> @ imm = #0x50
700a5ba8: e7ff         	b	0x700a5baa <vTaskPriorityDisinheritAfterTimeout+0x8a> @ imm = #-0x2
;           if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a5baa: 9803         	ldr	r0, [sp, #0xc]
700a5bac: 3004         	adds	r0, #0x4
700a5bae: f007 fdaf    	bl	0x700ad710 <uxListRemove> @ imm = #0x7b5e
700a5bb2: b908         	cbnz	r0, 0x700a5bb8 <vTaskPriorityDisinheritAfterTimeout+0x98> @ imm = #0x2
700a5bb4: e7ff         	b	0x700a5bb6 <vTaskPriorityDisinheritAfterTimeout+0x96> @ imm = #-0x2
;           } else {
700a5bb6: e000         	b	0x700a5bba <vTaskPriorityDisinheritAfterTimeout+0x9a> @ imm = #0x0
700a5bb8: e7ff         	b	0x700a5bba <vTaskPriorityDisinheritAfterTimeout+0x9a> @ imm = #-0x2
;           prvAddTaskToReadyList(pxTCB);
700a5bba: 9803         	ldr	r0, [sp, #0xc]
700a5bbc: 6ac0         	ldr	r0, [r0, #0x2c]
700a5bbe: f642 212c    	movw	r1, #0x2a2c
700a5bc2: f2c7 010b    	movt	r1, #0x700b
700a5bc6: 6809         	ldr	r1, [r1]
700a5bc8: 4288         	cmp	r0, r1
700a5bca: d908         	bls	0x700a5bde <vTaskPriorityDisinheritAfterTimeout+0xbe> @ imm = #0x10
700a5bcc: e7ff         	b	0x700a5bce <vTaskPriorityDisinheritAfterTimeout+0xae> @ imm = #-0x2
700a5bce: 9803         	ldr	r0, [sp, #0xc]
700a5bd0: 6ac0         	ldr	r0, [r0, #0x2c]
700a5bd2: f642 212c    	movw	r1, #0x2a2c
700a5bd6: f2c7 010b    	movt	r1, #0x700b
700a5bda: 6008         	str	r0, [r1]
700a5bdc: e7ff         	b	0x700a5bde <vTaskPriorityDisinheritAfterTimeout+0xbe> @ imm = #-0x2
700a5bde: 9903         	ldr	r1, [sp, #0xc]
700a5be0: 6ac8         	ldr	r0, [r1, #0x2c]
700a5be2: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a5be6: f244 40f8    	movw	r0, #0x44f8
700a5bea: f2c7 0008    	movt	r0, #0x7008
700a5bee: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a5bf2: 3104         	adds	r1, #0x4
700a5bf4: f008 fb44    	bl	0x700ae280 <vListInsertEnd> @ imm = #0x8688
;         } else {
700a5bf8: e000         	b	0x700a5bfc <vTaskPriorityDisinheritAfterTimeout+0xdc> @ imm = #0x0
700a5bfa: e7ff         	b	0x700a5bfc <vTaskPriorityDisinheritAfterTimeout+0xdc> @ imm = #-0x2
;       } else {
700a5bfc: e000         	b	0x700a5c00 <vTaskPriorityDisinheritAfterTimeout+0xe0> @ imm = #0x0
700a5bfe: e7ff         	b	0x700a5c00 <vTaskPriorityDisinheritAfterTimeout+0xe0> @ imm = #-0x2
;     } else {
700a5c00: e000         	b	0x700a5c04 <vTaskPriorityDisinheritAfterTimeout+0xe4> @ imm = #0x0
700a5c02: e7ff         	b	0x700a5c04 <vTaskPriorityDisinheritAfterTimeout+0xe4> @ imm = #-0x2
;   } else {
700a5c04: e000         	b	0x700a5c08 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #0x0
700a5c06: e7ff         	b	0x700a5c08 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #-0x2
; }
700a5c08: b006         	add	sp, #0x18
700a5c0a: bd80         	pop	{r7, pc}
700a5c0c: 0000         	movs	r0, r0
700a5c0e: 0000         	movs	r0, r0

700a5c10 <AddrTranslateP_getLocalAddr>:
; {
700a5c10: b580         	push	{r7, lr}
700a5c12: b08e         	sub	sp, #0x38
700a5c14: 910d         	str	r1, [sp, #0x34]
700a5c16: 900c         	str	r0, [sp, #0x30]
;     DebugP_assertNoLog(gAddrTranslateConfig.numRegions<AddrTranslateP_MAX_REGIONS);
700a5c18: f642 1074    	movw	r0, #0x2974
700a5c1c: f2c7 000b    	movt	r0, #0x700b
700a5c20: 6801         	ldr	r1, [r0]
700a5c22: 2000         	movs	r0, #0x0
700a5c24: 9001         	str	r0, [sp, #0x4]
700a5c26: 2910         	cmp	r1, #0x10
700a5c28: bf38         	it	lo
700a5c2a: 2001         	movlo	r0, #0x1
700a5c2c: f00b fb58    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0xb6b0
700a5c30: 9801         	ldr	r0, [sp, #0x4]
;     found = 0;
700a5c32: 900b         	str	r0, [sp, #0x2c]
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a5c34: 900a         	str	r0, [sp, #0x28]
700a5c36: e7ff         	b	0x700a5c38 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x2
700a5c38: 980a         	ldr	r0, [sp, #0x28]
700a5c3a: f642 1174    	movw	r1, #0x2974
700a5c3e: f2c7 010b    	movt	r1, #0x700b
700a5c42: 6809         	ldr	r1, [r1]
700a5c44: 4288         	cmp	r0, r1
700a5c46: d23b         	bhs	0x700a5cc0 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x76
700a5c48: e7ff         	b	0x700a5c4a <AddrTranslateP_getLocalAddr+0x3a> @ imm = #-0x2
;         sizeMask = ( (uint32_t)( ((uint64_t)1U << gAddrTranslateConfig.regionConfig[regionId].size) - 1U) );
700a5c4a: f642 1074    	movw	r0, #0x2974
700a5c4e: f2c7 000b    	movt	r0, #0x700b
700a5c52: 6881         	ldr	r1, [r0, #0x8]
700a5c54: 9a0a         	ldr	r2, [sp, #0x28]
700a5c56: eb01 1102    	add.w	r1, r1, r2, lsl #4
700a5c5a: 68ca         	ldr	r2, [r1, #0xc]
700a5c5c: 2101         	movs	r1, #0x1
700a5c5e: 4091         	lsls	r1, r2
700a5c60: 3a20         	subs	r2, #0x20
700a5c62: 2a00         	cmp	r2, #0x0
700a5c64: bf58         	it	pl
700a5c66: 2100         	movpl	r1, #0x0
700a5c68: 3901         	subs	r1, #0x1
700a5c6a: 9103         	str	r1, [sp, #0xc]
;         startAddr = gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a5c6c: 6880         	ldr	r0, [r0, #0x8]
700a5c6e: 9a0a         	ldr	r2, [sp, #0x28]
700a5c70: eb00 1102    	add.w	r1, r0, r2, lsl #4
700a5c74: ea4f 1202    	lsl.w	r2, r2, #0x4
700a5c78: 5880         	ldr	r0, [r0, r2]
700a5c7a: 6849         	ldr	r1, [r1, #0x4]
700a5c7c: 9107         	str	r1, [sp, #0x1c]
700a5c7e: 9006         	str	r0, [sp, #0x18]
;         endAddr = startAddr + sizeMask;
700a5c80: 9906         	ldr	r1, [sp, #0x18]
700a5c82: 9807         	ldr	r0, [sp, #0x1c]
700a5c84: 9a03         	ldr	r2, [sp, #0xc]
700a5c86: 1889         	adds	r1, r1, r2
700a5c88: f140 0000    	adc	r0, r0, #0x0
700a5c8c: 9104         	str	r1, [sp, #0x10]
700a5c8e: 9005         	str	r0, [sp, #0x14]
;         if((systemAddr >= startAddr) && (systemAddr <= endAddr))
700a5c90: 9a0c         	ldr	r2, [sp, #0x30]
700a5c92: 980d         	ldr	r0, [sp, #0x34]
700a5c94: 9b06         	ldr	r3, [sp, #0x18]
700a5c96: 9907         	ldr	r1, [sp, #0x1c]
700a5c98: 1ad2         	subs	r2, r2, r3
700a5c9a: 4188         	sbcs	r0, r1
700a5c9c: d30b         	blo	0x700a5cb6 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x16
700a5c9e: e7ff         	b	0x700a5ca0 <AddrTranslateP_getLocalAddr+0x90> @ imm = #-0x2
700a5ca0: 9b0c         	ldr	r3, [sp, #0x30]
700a5ca2: 990d         	ldr	r1, [sp, #0x34]
700a5ca4: 9a04         	ldr	r2, [sp, #0x10]
700a5ca6: 9805         	ldr	r0, [sp, #0x14]
700a5ca8: 1ad2         	subs	r2, r2, r3
700a5caa: 4188         	sbcs	r0, r1
700a5cac: d303         	blo	0x700a5cb6 <AddrTranslateP_getLocalAddr+0xa6> @ imm = #0x6
700a5cae: e7ff         	b	0x700a5cb0 <AddrTranslateP_getLocalAddr+0xa0> @ imm = #-0x2
700a5cb0: 2001         	movs	r0, #0x1
;             found = 1;
700a5cb2: 900b         	str	r0, [sp, #0x2c]
;             break;
700a5cb4: e004         	b	0x700a5cc0 <AddrTranslateP_getLocalAddr+0xb0> @ imm = #0x8
;     }
700a5cb6: e7ff         	b	0x700a5cb8 <AddrTranslateP_getLocalAddr+0xa8> @ imm = #-0x2
;     for(regionId=0; regionId<gAddrTranslateConfig.numRegions; regionId++)
700a5cb8: 980a         	ldr	r0, [sp, #0x28]
700a5cba: 3001         	adds	r0, #0x1
700a5cbc: 900a         	str	r0, [sp, #0x28]
700a5cbe: e7bb         	b	0x700a5c38 <AddrTranslateP_getLocalAddr+0x28> @ imm = #-0x8a
;     if(found != 0U)
700a5cc0: 980b         	ldr	r0, [sp, #0x2c]
700a5cc2: b1a0         	cbz	r0, 0x700a5cee <AddrTranslateP_getLocalAddr+0xde> @ imm = #0x28
700a5cc4: e7ff         	b	0x700a5cc6 <AddrTranslateP_getLocalAddr+0xb6> @ imm = #-0x2
;         uint32_t offset = systemAddr - gAddrTranslateConfig.regionConfig[regionId].systemAddr;
700a5cc6: 990c         	ldr	r1, [sp, #0x30]
700a5cc8: f642 1074    	movw	r0, #0x2974
700a5ccc: f2c7 000b    	movt	r0, #0x700b
700a5cd0: 6882         	ldr	r2, [r0, #0x8]
700a5cd2: 9b0a         	ldr	r3, [sp, #0x28]
700a5cd4: 011b         	lsls	r3, r3, #0x4
700a5cd6: 58d2         	ldr	r2, [r2, r3]
700a5cd8: 1a89         	subs	r1, r1, r2
700a5cda: 9102         	str	r1, [sp, #0x8]
;         localAddr = (void *) (gAddrTranslateConfig.regionConfig[regionId].localAddr + offset);
700a5cdc: 6880         	ldr	r0, [r0, #0x8]
700a5cde: 990a         	ldr	r1, [sp, #0x28]
700a5ce0: eb00 1001    	add.w	r0, r0, r1, lsl #4
700a5ce4: 6880         	ldr	r0, [r0, #0x8]
700a5ce6: 9902         	ldr	r1, [sp, #0x8]
700a5ce8: 4408         	add	r0, r1
700a5cea: 9009         	str	r0, [sp, #0x24]
;     }
700a5cec: e002         	b	0x700a5cf4 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #0x4
;         localAddr = (void *) systemAddr;
700a5cee: 980c         	ldr	r0, [sp, #0x30]
700a5cf0: 9009         	str	r0, [sp, #0x24]
700a5cf2: e7ff         	b	0x700a5cf4 <AddrTranslateP_getLocalAddr+0xe4> @ imm = #-0x2
;     return localAddr;
700a5cf4: 9809         	ldr	r0, [sp, #0x24]
700a5cf6: b00e         	add	sp, #0x38
700a5cf8: bd80         	pop	{r7, pc}
700a5cfa: 0000         	movs	r0, r0
700a5cfc: 0000         	movs	r0, r0
700a5cfe: 0000         	movs	r0, r0

700a5d00 <Udma_eventFreeResource>:
; {
700a5d00: b580         	push	{r7, lr}
700a5d02: b084         	sub	sp, #0x10
700a5d04: 9003         	str	r0, [sp, #0xc]
700a5d06: 9102         	str	r1, [sp, #0x8]
;     cookie = HwiP_disable();
700a5d08: f00a ee2a    	blx	0x700b0960 <HwiP_disable> @ imm = #0xac54
700a5d0c: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventHandle->prevEvent)
700a5d0e: 9802         	ldr	r0, [sp, #0x8]
700a5d10: 6e00         	ldr	r0, [r0, #0x60]
700a5d12: b128         	cbz	r0, 0x700a5d20 <Udma_eventFreeResource+0x20> @ imm = #0xa
700a5d14: e7ff         	b	0x700a5d16 <Udma_eventFreeResource+0x16> @ imm = #-0x2
;         eventHandle->prevEvent->nextEvent = eventHandle->nextEvent;
700a5d16: 9902         	ldr	r1, [sp, #0x8]
700a5d18: 6dc8         	ldr	r0, [r1, #0x5c]
700a5d1a: 6e09         	ldr	r1, [r1, #0x60]
700a5d1c: 65c8         	str	r0, [r1, #0x5c]
;     }
700a5d1e: e7ff         	b	0x700a5d20 <Udma_eventFreeResource+0x20> @ imm = #-0x2
;     if(NULL_PTR != eventHandle->nextEvent)
700a5d20: 9802         	ldr	r0, [sp, #0x8]
700a5d22: 6dc0         	ldr	r0, [r0, #0x5c]
700a5d24: b128         	cbz	r0, 0x700a5d32 <Udma_eventFreeResource+0x32> @ imm = #0xa
700a5d26: e7ff         	b	0x700a5d28 <Udma_eventFreeResource+0x28> @ imm = #-0x2
;         eventHandle->nextEvent->prevEvent = eventHandle->prevEvent;
700a5d28: 9802         	ldr	r0, [sp, #0x8]
700a5d2a: 6dc1         	ldr	r1, [r0, #0x5c]
700a5d2c: 6e00         	ldr	r0, [r0, #0x60]
700a5d2e: 6608         	str	r0, [r1, #0x60]
;     }
700a5d30: e7ff         	b	0x700a5d32 <Udma_eventFreeResource+0x32> @ imm = #-0x2
;     HwiP_restore(cookie);
700a5d32: 9801         	ldr	r0, [sp, #0x4]
700a5d34: f00a ee34    	blx	0x700b09a0 <HwiP_restore> @ imm = #0xac68
;     if(NULL_PTR != eventHandle->hwiHandle)
700a5d38: 9802         	ldr	r0, [sp, #0x8]
700a5d3a: 6e40         	ldr	r0, [r0, #0x64]
700a5d3c: b140         	cbz	r0, 0x700a5d50 <Udma_eventFreeResource+0x50> @ imm = #0x10
700a5d3e: e7ff         	b	0x700a5d40 <Udma_eventFreeResource+0x40> @ imm = #-0x2
;         HwiP_destruct(&eventHandle->hwiObject);
700a5d40: 9802         	ldr	r0, [sp, #0x8]
700a5d42: 3068         	adds	r0, #0x68
700a5d44: f00a fa1c    	bl	0x700b0180 <HwiP_destruct> @ imm = #0xa438
;         eventHandle->hwiHandle = NULL_PTR;
700a5d48: 9902         	ldr	r1, [sp, #0x8]
700a5d4a: 2000         	movs	r0, #0x0
700a5d4c: 6648         	str	r0, [r1, #0x64]
;     }
700a5d4e: e7ff         	b	0x700a5d50 <Udma_eventFreeResource+0x50> @ imm = #-0x2
;     if(UDMA_INTR_INVALID != eventHandle->irIntrNum)
700a5d50: 9802         	ldr	r0, [sp, #0x8]
700a5d52: 6d40         	ldr	r0, [r0, #0x54]
700a5d54: f510 3f80    	cmn.w	r0, #0x10000
700a5d58: d00d         	beq	0x700a5d76 <Udma_eventFreeResource+0x76> @ imm = #0x1a
700a5d5a: e7ff         	b	0x700a5d5c <Udma_eventFreeResource+0x5c> @ imm = #-0x2
;         Udma_rmFreeIrIntr(eventHandle->irIntrNum, drvHandle);
700a5d5c: 9802         	ldr	r0, [sp, #0x8]
700a5d5e: 6d40         	ldr	r0, [r0, #0x54]
700a5d60: 9903         	ldr	r1, [sp, #0xc]
700a5d62: f005 ffe5    	bl	0x700abd30 <Udma_rmFreeIrIntr> @ imm = #0x5fca
;         eventHandle->irIntrNum = UDMA_INTR_INVALID;
700a5d66: 9902         	ldr	r1, [sp, #0x8]
700a5d68: 2000         	movs	r0, #0x0
700a5d6a: f6cf 70ff    	movt	r0, #0xffff
700a5d6e: 6548         	str	r0, [r1, #0x54]
;         eventHandle->coreIntrNum = UDMA_INTR_INVALID;
700a5d70: 9902         	ldr	r1, [sp, #0x8]
700a5d72: 6588         	str	r0, [r1, #0x58]
;     }
700a5d74: e7ff         	b	0x700a5d76 <Udma_eventFreeResource+0x76> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->globalEvent)
700a5d76: 9802         	ldr	r0, [sp, #0x8]
700a5d78: 6c80         	ldr	r0, [r0, #0x48]
700a5d7a: f64f 71ff    	movw	r1, #0xffff
700a5d7e: 4288         	cmp	r0, r1
700a5d80: d00e         	beq	0x700a5da0 <Udma_eventFreeResource+0xa0> @ imm = #0x1c
700a5d82: e7ff         	b	0x700a5d84 <Udma_eventFreeResource+0x84> @ imm = #-0x2
;         Udma_eventResetSteering(drvHandle, eventHandle);
700a5d84: 9803         	ldr	r0, [sp, #0xc]
700a5d86: 9902         	ldr	r1, [sp, #0x8]
700a5d88: f009 f87a    	bl	0x700aee80 <Udma_eventResetSteering> @ imm = #0x90f4
;         Udma_rmFreeEvent(eventHandle->globalEvent, drvHandle);
700a5d8c: 9802         	ldr	r0, [sp, #0x8]
700a5d8e: 6c80         	ldr	r0, [r0, #0x48]
700a5d90: 9903         	ldr	r1, [sp, #0xc]
700a5d92: f005 ff95    	bl	0x700abcc0 <Udma_rmFreeEvent> @ imm = #0x5f2a
;         eventHandle->globalEvent = UDMA_EVENT_INVALID;
700a5d96: 9902         	ldr	r1, [sp, #0x8]
700a5d98: f64f 70ff    	movw	r0, #0xffff
700a5d9c: 6488         	str	r0, [r1, #0x48]
;     }
700a5d9e: e7ff         	b	0x700a5da0 <Udma_eventFreeResource+0xa0> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrBitNum)
700a5da0: 9802         	ldr	r0, [sp, #0x8]
700a5da2: 6d00         	ldr	r0, [r0, #0x50]
700a5da4: f64f 71ff    	movw	r1, #0xffff
700a5da8: 4288         	cmp	r0, r1
700a5daa: d00a         	beq	0x700a5dc2 <Udma_eventFreeResource+0xc2> @ imm = #0x14
700a5dac: e7ff         	b	0x700a5dae <Udma_eventFreeResource+0xae> @ imm = #-0x2
;         Udma_rmFreeVintrBit(eventHandle->vintrBitNum, drvHandle, eventHandle);
700a5dae: 9a02         	ldr	r2, [sp, #0x8]
700a5db0: 6d10         	ldr	r0, [r2, #0x50]
700a5db2: 9903         	ldr	r1, [sp, #0xc]
700a5db4: f004 facc    	bl	0x700aa350 <Udma_rmFreeVintrBit> @ imm = #0x4598
;         eventHandle->vintrBitNum = UDMA_EVENT_INVALID;
700a5db8: 9902         	ldr	r1, [sp, #0x8]
700a5dba: f64f 70ff    	movw	r0, #0xffff
700a5dbe: 6508         	str	r0, [r1, #0x50]
;     }
700a5dc0: e7ff         	b	0x700a5dc2 <Udma_eventFreeResource+0xc2> @ imm = #-0x2
;     if(UDMA_EVENT_INVALID != eventHandle->vintrNum)
700a5dc2: 9802         	ldr	r0, [sp, #0x8]
700a5dc4: 6cc0         	ldr	r0, [r0, #0x4c]
700a5dc6: f64f 71ff    	movw	r1, #0xffff
700a5dca: 4288         	cmp	r0, r1
700a5dcc: d00a         	beq	0x700a5de4 <Udma_eventFreeResource+0xe4> @ imm = #0x14
700a5dce: e7ff         	b	0x700a5dd0 <Udma_eventFreeResource+0xd0> @ imm = #-0x2
;         Udma_rmFreeVintr(eventHandle->vintrNum, drvHandle);
700a5dd0: 9802         	ldr	r0, [sp, #0x8]
700a5dd2: 6cc0         	ldr	r0, [r0, #0x4c]
700a5dd4: 9903         	ldr	r1, [sp, #0xc]
700a5dd6: f005 ffe3    	bl	0x700abda0 <Udma_rmFreeVintr> @ imm = #0x5fc6
;         eventHandle->vintrNum = UDMA_EVENT_INVALID;
700a5dda: 9902         	ldr	r1, [sp, #0x8]
700a5ddc: f64f 70ff    	movw	r0, #0xffff
700a5de0: 64c8         	str	r0, [r1, #0x4c]
;     }
700a5de2: e7ff         	b	0x700a5de4 <Udma_eventFreeResource+0xe4> @ imm = #-0x2
;     return;
700a5de4: b004         	add	sp, #0x10
700a5de6: bd80         	pop	{r7, pc}
		...

700a5df0 <DebugP_memTraceLogWriterPutLine>:
; {
700a5df0: b580         	push	{r7, lr}
700a5df2: b08a         	sub	sp, #0x28
700a5df4: 9009         	str	r0, [sp, #0x24]
700a5df6: f8ad 1022    	strh.w	r1, [sp, #0x22]
700a5dfa: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a5dfc: 9007         	str	r0, [sp, #0x1c]
;     if (gDebugMemLogSize == 0U)
700a5dfe: f642 10d8    	movw	r0, #0x29d8
700a5e02: f2c7 000b    	movt	r0, #0x700b
700a5e06: 6800         	ldr	r0, [r0]
700a5e08: b920         	cbnz	r0, 0x700a5e14 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #0x8
700a5e0a: e7ff         	b	0x700a5e0c <DebugP_memTraceLogWriterPutLine+0x1c> @ imm = #-0x2
700a5e0c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700a5e10: 9007         	str	r0, [sp, #0x1c]
;     }
700a5e12: e7ff         	b	0x700a5e14 <DebugP_memTraceLogWriterPutLine+0x24> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a5e14: 9807         	ldr	r0, [sp, #0x1c]
700a5e16: 2800         	cmp	r0, #0x0
700a5e18: d15a         	bne	0x700a5ed0 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #0xb4
700a5e1a: e7ff         	b	0x700a5e1c <DebugP_memTraceLogWriterPutLine+0x2c> @ imm = #-0x2
;         wr_idx = gDebugMemLogWriteIndex;
700a5e1c: f642 10dc    	movw	r0, #0x29dc
700a5e20: f2c7 000b    	movt	r0, #0x700b
700a5e24: 6800         	ldr	r0, [r0]
700a5e26: 9006         	str	r0, [sp, #0x18]
;         dst = (uint8_t*)&gDebugMemLog[0];
700a5e28: f241 0080    	movw	r0, #0x1080
700a5e2c: f2c7 0008    	movt	r0, #0x7008
700a5e30: 9003         	str	r0, [sp, #0xc]
700a5e32: 2000         	movs	r0, #0x0
;         idx = 0;
700a5e34: 9004         	str	r0, [sp, #0x10]
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a5e36: 9005         	str	r0, [sp, #0x14]
700a5e38: e7ff         	b	0x700a5e3a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x2
700a5e3a: 9805         	ldr	r0, [sp, #0x14]
700a5e3c: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5e40: 4288         	cmp	r0, r1
700a5e42: d233         	bhs	0x700a5eac <DebugP_memTraceLogWriterPutLine+0xbc> @ imm = #0x66
700a5e44: e7ff         	b	0x700a5e46 <DebugP_memTraceLogWriterPutLine+0x56> @ imm = #-0x2
;             dst[wr_idx] = buf[idx];
700a5e46: 9809         	ldr	r0, [sp, #0x24]
700a5e48: 9904         	ldr	r1, [sp, #0x10]
700a5e4a: 5c40         	ldrb	r0, [r0, r1]
700a5e4c: 9903         	ldr	r1, [sp, #0xc]
700a5e4e: 9a06         	ldr	r2, [sp, #0x18]
700a5e50: 5488         	strb	r0, [r1, r2]
;             wr_idx = wr_idx + 1U;
700a5e52: 9806         	ldr	r0, [sp, #0x18]
700a5e54: 3001         	adds	r0, #0x1
700a5e56: 9006         	str	r0, [sp, #0x18]
;             if (wr_idx >= gDebugMemLogSize)
700a5e58: 9806         	ldr	r0, [sp, #0x18]
700a5e5a: f642 11d8    	movw	r1, #0x29d8
700a5e5e: f2c7 010b    	movt	r1, #0x700b
700a5e62: 6809         	ldr	r1, [r1]
700a5e64: 4288         	cmp	r0, r1
700a5e66: d319         	blo	0x700a5e9c <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #0x32
700a5e68: e7ff         	b	0x700a5e6a <DebugP_memTraceLogWriterPutLine+0x7a> @ imm = #-0x2
;                         &dst[gDebugMemLogWriteIndex],
700a5e6a: 9803         	ldr	r0, [sp, #0xc]
700a5e6c: f642 12dc    	movw	r2, #0x29dc
700a5e70: f2c7 020b    	movt	r2, #0x700b
700a5e74: 9202         	str	r2, [sp, #0x8]
700a5e76: 6811         	ldr	r1, [r2]
700a5e78: 4408         	add	r0, r1
;                         (wr_idx - gDebugMemLogWriteIndex),
700a5e7a: 9906         	ldr	r1, [sp, #0x18]
700a5e7c: 6812         	ldr	r2, [r2]
700a5e7e: 1a89         	subs	r1, r1, r2
700a5e80: 220f         	movs	r2, #0xf
;                 CacheP_wbInv(
700a5e82: f00a ee66    	blx	0x700b0b50 <CacheP_wbInv> @ imm = #0xaccc
700a5e86: 9902         	ldr	r1, [sp, #0x8]
700a5e88: 2000         	movs	r0, #0x0
;                 wr_idx = 0;
700a5e8a: 9006         	str	r0, [sp, #0x18]
;                 gDebugMemLogWriteIndex = 0;
700a5e8c: 6008         	str	r0, [r1]
;                 gDebugMemLogIsWrapAround = 1;
700a5e8e: f642 11d4    	movw	r1, #0x29d4
700a5e92: f2c7 010b    	movt	r1, #0x700b
700a5e96: 2001         	movs	r0, #0x1
700a5e98: 6008         	str	r0, [r1]
;             }
700a5e9a: e7ff         	b	0x700a5e9c <DebugP_memTraceLogWriterPutLine+0xac> @ imm = #-0x2
;             idx ++;
700a5e9c: 9804         	ldr	r0, [sp, #0x10]
700a5e9e: 3001         	adds	r0, #0x1
700a5ea0: 9004         	str	r0, [sp, #0x10]
;         }
700a5ea2: e7ff         	b	0x700a5ea4 <DebugP_memTraceLogWriterPutLine+0xb4> @ imm = #-0x2
;         for (copy_bytes = 0; copy_bytes < num_bytes; copy_bytes++)
700a5ea4: 9805         	ldr	r0, [sp, #0x14]
700a5ea6: 3001         	adds	r0, #0x1
700a5ea8: 9005         	str	r0, [sp, #0x14]
700a5eaa: e7c6         	b	0x700a5e3a <DebugP_memTraceLogWriterPutLine+0x4a> @ imm = #-0x74
;                 &dst[gDebugMemLogWriteIndex],
700a5eac: 9803         	ldr	r0, [sp, #0xc]
700a5eae: f642 12dc    	movw	r2, #0x29dc
700a5eb2: f2c7 020b    	movt	r2, #0x700b
700a5eb6: 9201         	str	r2, [sp, #0x4]
700a5eb8: 6811         	ldr	r1, [r2]
700a5eba: 4408         	add	r0, r1
;                 (wr_idx - gDebugMemLogWriteIndex),
700a5ebc: 9906         	ldr	r1, [sp, #0x18]
700a5ebe: 6812         	ldr	r2, [r2]
700a5ec0: 1a89         	subs	r1, r1, r2
700a5ec2: 220f         	movs	r2, #0xf
;         CacheP_wbInv(
700a5ec4: f00a ee44    	blx	0x700b0b50 <CacheP_wbInv> @ imm = #0xac88
700a5ec8: 9901         	ldr	r1, [sp, #0x4]
;         gDebugMemLogWriteIndex = wr_idx;
700a5eca: 9806         	ldr	r0, [sp, #0x18]
700a5ecc: 6008         	str	r0, [r1]
;     }
700a5ece: e7ff         	b	0x700a5ed0 <DebugP_memTraceLogWriterPutLine+0xe0> @ imm = #-0x2
; }
700a5ed0: b00a         	add	sp, #0x28
700a5ed2: bd80         	pop	{r7, pc}
		...

700a5ee0 <Sciclient_rmIrqGetNode>:
; {
700a5ee0: b089         	sub	sp, #0x24
700a5ee2: f8ad 0022    	strh.w	r0, [sp, #0x22]
700a5ee6: 9107         	str	r1, [sp, #0x1c]
700a5ee8: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700a5eec: 9006         	str	r0, [sp, #0x18]
700a5eee: 2000         	movs	r0, #0x0
;     lower = 0u;
700a5ef0: 9004         	str	r0, [sp, #0x10]
;     upper = gRmIrqTreeCount - 1u;
700a5ef2: f242 6130    	movw	r1, #0x2630
700a5ef6: f2c7 010b    	movt	r1, #0x700b
700a5efa: 680a         	ldr	r2, [r1]
700a5efc: 3a01         	subs	r2, #0x1
700a5efe: 9203         	str	r2, [sp, #0xc]
;     count = gRmIrqTreeCount;
700a5f00: 6809         	ldr	r1, [r1]
700a5f02: f8ad 1006    	strh.w	r1, [sp, #0x6]
;     *found_n = NULL;
700a5f06: 9907         	ldr	r1, [sp, #0x1c]
700a5f08: 6008         	str	r0, [r1]
;     while ((lower <= upper) &&
700a5f0a: e7ff         	b	0x700a5f0c <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0x2
700a5f0c: 9904         	ldr	r1, [sp, #0x10]
700a5f0e: 9a03         	ldr	r2, [sp, #0xc]
700a5f10: 2000         	movs	r0, #0x0
700a5f12: 4291         	cmp	r1, r2
700a5f14: 9000         	str	r0, [sp]
700a5f16: d81d         	bhi	0x700a5f54 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x3a
700a5f18: e7ff         	b	0x700a5f1a <Sciclient_rmIrqGetNode+0x3a> @ imm = #-0x2
;            (lower < gRmIrqTreeCount) &&
700a5f1a: 9904         	ldr	r1, [sp, #0x10]
700a5f1c: f242 6030    	movw	r0, #0x2630
700a5f20: f2c7 000b    	movt	r0, #0x700b
700a5f24: 6802         	ldr	r2, [r0]
700a5f26: 2000         	movs	r0, #0x0
700a5f28: 4291         	cmp	r1, r2
700a5f2a: 9000         	str	r0, [sp]
700a5f2c: d212         	bhs	0x700a5f54 <Sciclient_rmIrqGetNode+0x74> @ imm = #0x24
700a5f2e: e7ff         	b	0x700a5f30 <Sciclient_rmIrqGetNode+0x50> @ imm = #-0x2
;            (upper < gRmIrqTreeCount) &&
700a5f30: 9903         	ldr	r1, [sp, #0xc]
700a5f32: f242 6030    	movw	r0, #0x2630
700a5f36: f2c7 000b    	movt	r0, #0x700b
700a5f3a: 6802         	ldr	r2, [r0]
700a5f3c: 2000         	movs	r0, #0x0
700a5f3e: 4291         	cmp	r1, r2
700a5f40: 9000         	str	r0, [sp]
700a5f42: d207         	bhs	0x700a5f54 <Sciclient_rmIrqGetNode+0x74> @ imm = #0xe
700a5f44: e7ff         	b	0x700a5f46 <Sciclient_rmIrqGetNode+0x66> @ imm = #-0x2
;            (count > 0u)) {
700a5f46: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5f4a: 2800         	cmp	r0, #0x0
700a5f4c: bf18         	it	ne
700a5f4e: 2001         	movne	r0, #0x1
700a5f50: 9000         	str	r0, [sp]
700a5f52: e7ff         	b	0x700a5f54 <Sciclient_rmIrqGetNode+0x74> @ imm = #-0x2
700a5f54: 9800         	ldr	r0, [sp]
;     while ((lower <= upper) &&
700a5f56: 07c0         	lsls	r0, r0, #0x1f
700a5f58: b380         	cbz	r0, 0x700a5fbc <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x60
700a5f5a: e7ff         	b	0x700a5f5c <Sciclient_rmIrqGetNode+0x7c> @ imm = #-0x2
;         current = (lower + upper) / (2u);
700a5f5c: 9804         	ldr	r0, [sp, #0x10]
700a5f5e: 9903         	ldr	r1, [sp, #0xc]
700a5f60: 4408         	add	r0, r1
700a5f62: 0840         	lsrs	r0, r0, #0x1
700a5f64: 9002         	str	r0, [sp, #0x8]
;         cur_n = (const struct Sciclient_rmIrqNode *) gRmIrqTree[current];
700a5f66: 9902         	ldr	r1, [sp, #0x8]
700a5f68: f641 00c8    	movw	r0, #0x18c8
700a5f6c: f2c7 000b    	movt	r0, #0x700b
700a5f70: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a5f74: 9005         	str	r0, [sp, #0x14]
;         if (cur_n->id == id) {
700a5f76: 9805         	ldr	r0, [sp, #0x14]
700a5f78: 8800         	ldrh	r0, [r0]
700a5f7a: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5f7e: 4288         	cmp	r0, r1
700a5f80: d106         	bne	0x700a5f90 <Sciclient_rmIrqGetNode+0xb0> @ imm = #0xc
700a5f82: e7ff         	b	0x700a5f84 <Sciclient_rmIrqGetNode+0xa4> @ imm = #-0x2
;             *found_n = cur_n;
700a5f84: 9805         	ldr	r0, [sp, #0x14]
700a5f86: 9907         	ldr	r1, [sp, #0x1c]
700a5f88: 6008         	str	r0, [r1]
700a5f8a: 2000         	movs	r0, #0x0
;             r = SystemP_SUCCESS;
700a5f8c: 9006         	str	r0, [sp, #0x18]
;             break;
700a5f8e: e015         	b	0x700a5fbc <Sciclient_rmIrqGetNode+0xdc> @ imm = #0x2a
;             if (cur_n->id < id) {
700a5f90: 9805         	ldr	r0, [sp, #0x14]
700a5f92: 8800         	ldrh	r0, [r0]
700a5f94: f8bd 1022    	ldrh.w	r1, [sp, #0x22]
700a5f98: 4288         	cmp	r0, r1
700a5f9a: da04         	bge	0x700a5fa6 <Sciclient_rmIrqGetNode+0xc6> @ imm = #0x8
700a5f9c: e7ff         	b	0x700a5f9e <Sciclient_rmIrqGetNode+0xbe> @ imm = #-0x2
;                 lower = current + (1u);
700a5f9e: 9802         	ldr	r0, [sp, #0x8]
700a5fa0: 3001         	adds	r0, #0x1
700a5fa2: 9004         	str	r0, [sp, #0x10]
;             } else {
700a5fa4: e003         	b	0x700a5fae <Sciclient_rmIrqGetNode+0xce> @ imm = #0x6
;                 upper = current - (1u);
700a5fa6: 9802         	ldr	r0, [sp, #0x8]
700a5fa8: 3801         	subs	r0, #0x1
700a5faa: 9003         	str	r0, [sp, #0xc]
700a5fac: e7ff         	b	0x700a5fae <Sciclient_rmIrqGetNode+0xce> @ imm = #-0x2
700a5fae: e7ff         	b	0x700a5fb0 <Sciclient_rmIrqGetNode+0xd0> @ imm = #-0x2
;         count--;
700a5fb0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a5fb4: 3801         	subs	r0, #0x1
700a5fb6: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     while ((lower <= upper) &&
700a5fba: e7a7         	b	0x700a5f0c <Sciclient_rmIrqGetNode+0x2c> @ imm = #-0xb2
;     return r;
700a5fbc: 9806         	ldr	r0, [sp, #0x18]
700a5fbe: b009         	add	sp, #0x24
700a5fc0: 4770         	bx	lr
		...
700a5fce: 0000         	movs	r0, r0

700a5fd0 <vTaskGetInfo>:
;                   BaseType_t xGetFreeStackSpace, eTaskState eState) {
700a5fd0: b580         	push	{r7, lr}
700a5fd2: b086         	sub	sp, #0x18
700a5fd4: 9005         	str	r0, [sp, #0x14]
700a5fd6: 9104         	str	r1, [sp, #0x10]
700a5fd8: 9203         	str	r2, [sp, #0xc]
700a5fda: f88d 300b    	strb.w	r3, [sp, #0xb]
;   pxTCB = prvGetTCBFromHandle(xTask);
700a5fde: 9805         	ldr	r0, [sp, #0x14]
700a5fe0: b938         	cbnz	r0, 0x700a5ff2 <vTaskGetInfo+0x22> @ imm = #0xe
700a5fe2: e7ff         	b	0x700a5fe4 <vTaskGetInfo+0x14> @ imm = #-0x2
700a5fe4: f642 10fc    	movw	r0, #0x29fc
700a5fe8: f2c7 000b    	movt	r0, #0x700b
700a5fec: 6800         	ldr	r0, [r0]
700a5fee: 9000         	str	r0, [sp]
700a5ff0: e002         	b	0x700a5ff8 <vTaskGetInfo+0x28> @ imm = #0x4
700a5ff2: 9805         	ldr	r0, [sp, #0x14]
700a5ff4: 9000         	str	r0, [sp]
700a5ff6: e7ff         	b	0x700a5ff8 <vTaskGetInfo+0x28> @ imm = #-0x2
700a5ff8: 9800         	ldr	r0, [sp]
700a5ffa: 9001         	str	r0, [sp, #0x4]
;   pxTaskStatus->xHandle = (TaskHandle_t)pxTCB;
700a5ffc: 9801         	ldr	r0, [sp, #0x4]
700a5ffe: 9904         	ldr	r1, [sp, #0x10]
700a6000: 6008         	str	r0, [r1]
;   pxTaskStatus->pcTaskName = (const char *)&(pxTCB->pcTaskName[0]);
700a6002: 9801         	ldr	r0, [sp, #0x4]
700a6004: 3034         	adds	r0, #0x34
700a6006: 9904         	ldr	r1, [sp, #0x10]
700a6008: 6048         	str	r0, [r1, #0x4]
;   pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
700a600a: 9801         	ldr	r0, [sp, #0x4]
700a600c: 6ac0         	ldr	r0, [r0, #0x2c]
700a600e: 9904         	ldr	r1, [sp, #0x10]
700a6010: 6108         	str	r0, [r1, #0x10]
;   pxTaskStatus->pxStackBase = pxTCB->pxStack;
700a6012: 9801         	ldr	r0, [sp, #0x4]
700a6014: 6b00         	ldr	r0, [r0, #0x30]
700a6016: 9904         	ldr	r1, [sp, #0x10]
700a6018: 61c8         	str	r0, [r1, #0x1c]
;   pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
700a601a: 9801         	ldr	r0, [sp, #0x4]
700a601c: 6d80         	ldr	r0, [r0, #0x58]
700a601e: 9904         	ldr	r1, [sp, #0x10]
700a6020: 6088         	str	r0, [r1, #0x8]
;     pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
700a6022: 9801         	ldr	r0, [sp, #0x4]
700a6024: 6e00         	ldr	r0, [r0, #0x60]
700a6026: 9904         	ldr	r1, [sp, #0x10]
700a6028: 6148         	str	r0, [r1, #0x14]
;     pxTaskStatus->ulRunTimeCounter = 0;
700a602a: 9904         	ldr	r1, [sp, #0x10]
700a602c: 2000         	movs	r0, #0x0
700a602e: 6188         	str	r0, [r1, #0x18]
;   if (eState != eInvalid) {
700a6030: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a6034: 2805         	cmp	r0, #0x5
700a6036: d025         	beq	0x700a6084 <vTaskGetInfo+0xb4> @ imm = #0x4a
700a6038: e7ff         	b	0x700a603a <vTaskGetInfo+0x6a> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a603a: 9801         	ldr	r0, [sp, #0x4]
700a603c: f642 11fc    	movw	r1, #0x29fc
700a6040: f2c7 010b    	movt	r1, #0x700b
700a6044: 6809         	ldr	r1, [r1]
700a6046: 4288         	cmp	r0, r1
700a6048: d104         	bne	0x700a6054 <vTaskGetInfo+0x84> @ imm = #0x8
700a604a: e7ff         	b	0x700a604c <vTaskGetInfo+0x7c> @ imm = #-0x2
;       pxTaskStatus->eCurrentState = eRunning;
700a604c: 9904         	ldr	r1, [sp, #0x10]
700a604e: 2000         	movs	r0, #0x0
700a6050: 7308         	strb	r0, [r1, #0xc]
;     } else {
700a6052: e016         	b	0x700a6082 <vTaskGetInfo+0xb2> @ imm = #0x2c
;       pxTaskStatus->eCurrentState = eState;
700a6054: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a6058: 9904         	ldr	r1, [sp, #0x10]
700a605a: 7308         	strb	r0, [r1, #0xc]
;         if (eState == eSuspended) {
700a605c: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a6060: 2803         	cmp	r0, #0x3
700a6062: d10d         	bne	0x700a6080 <vTaskGetInfo+0xb0> @ imm = #0x1a
700a6064: e7ff         	b	0x700a6066 <vTaskGetInfo+0x96> @ imm = #-0x2
;           vTaskSuspendAll();
700a6066: f009 fdab    	bl	0x700afbc0 <vTaskSuspendAll> @ imm = #0x9b56
;             if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a606a: 9801         	ldr	r0, [sp, #0x4]
700a606c: 6a80         	ldr	r0, [r0, #0x28]
700a606e: b120         	cbz	r0, 0x700a607a <vTaskGetInfo+0xaa> @ imm = #0x8
700a6070: e7ff         	b	0x700a6072 <vTaskGetInfo+0xa2> @ imm = #-0x2
;               pxTaskStatus->eCurrentState = eBlocked;
700a6072: 9904         	ldr	r1, [sp, #0x10]
700a6074: 2002         	movs	r0, #0x2
700a6076: 7308         	strb	r0, [r1, #0xc]
;             }
700a6078: e7ff         	b	0x700a607a <vTaskGetInfo+0xaa> @ imm = #-0x2
;           (void)xTaskResumeAll();
700a607a: f7fc f909    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0x3dee
;         }
700a607e: e7ff         	b	0x700a6080 <vTaskGetInfo+0xb0> @ imm = #-0x2
700a6080: e7ff         	b	0x700a6082 <vTaskGetInfo+0xb2> @ imm = #-0x2
;   } else {
700a6082: e005         	b	0x700a6090 <vTaskGetInfo+0xc0> @ imm = #0xa
;     pxTaskStatus->eCurrentState = eTaskGetState(pxTCB);
700a6084: 9801         	ldr	r0, [sp, #0x4]
700a6086: f7ff fbdb    	bl	0x700a5840 <eTaskGetState> @ imm = #-0x84a
700a608a: 9904         	ldr	r1, [sp, #0x10]
700a608c: 7308         	strb	r0, [r1, #0xc]
700a608e: e7ff         	b	0x700a6090 <vTaskGetInfo+0xc0> @ imm = #-0x2
;   if (xGetFreeStackSpace != pdFALSE) {
700a6090: 9803         	ldr	r0, [sp, #0xc]
700a6092: b138         	cbz	r0, 0x700a60a4 <vTaskGetInfo+0xd4> @ imm = #0xe
700a6094: e7ff         	b	0x700a6096 <vTaskGetInfo+0xc6> @ imm = #-0x2
;           prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
700a6096: 9801         	ldr	r0, [sp, #0x4]
700a6098: 6b00         	ldr	r0, [r0, #0x30]
700a609a: f008 fcc9    	bl	0x700aea30 <prvTaskCheckFreeStackSpace> @ imm = #0x8992
;       pxTaskStatus->usStackHighWaterMark =
700a609e: 9904         	ldr	r1, [sp, #0x10]
700a60a0: 6208         	str	r0, [r1, #0x20]
;   } else {
700a60a2: e003         	b	0x700a60ac <vTaskGetInfo+0xdc> @ imm = #0x6
;     pxTaskStatus->usStackHighWaterMark = 0;
700a60a4: 9904         	ldr	r1, [sp, #0x10]
700a60a6: 2000         	movs	r0, #0x0
700a60a8: 6208         	str	r0, [r1, #0x20]
700a60aa: e7ff         	b	0x700a60ac <vTaskGetInfo+0xdc> @ imm = #-0x2
; }
700a60ac: b006         	add	sp, #0x18
700a60ae: bd80         	pop	{r7, pc}

700a60b0 <Sciclient_waitForMessage>:
; {
700a60b0: b580         	push	{r7, lr}
700a60b2: b088         	sub	sp, #0x20
700a60b4: 9007         	str	r0, [sp, #0x1c]
700a60b6: 9106         	str	r1, [sp, #0x18]
700a60b8: 9205         	str	r2, [sp, #0x14]
700a60ba: f88d 3013    	strb.w	r3, [sp, #0x13]
;     uint32_t timeToWait = timeout;
700a60be: 9806         	ldr	r0, [sp, #0x18]
700a60c0: 9002         	str	r0, [sp, #0x8]
700a60c2: 2200         	movs	r2, #0x0
;     int32_t status = SystemP_SUCCESS;
700a60c4: 9201         	str	r2, [sp, #0x4]
;                                         &gSciclientSecProxyCfg, rxThread, 0U)
700a60c6: 9907         	ldr	r1, [sp, #0x1c]
;         (struct tisci_header *)(CSL_secProxyGetDataAddr(
700a60c8: f642 00c0    	movw	r0, #0x28c0
700a60cc: f2c7 000b    	movt	r0, #0x700b
700a60d0: f009 fa46    	bl	0x700af560 <CSL_secProxyGetDataAddr> @ imm = #0x948c
;                                 + ((uintptr_t) gSecHeaderSizeWords * (uintptr_t) 4U));
700a60d4: f642 2154    	movw	r1, #0x2a54
700a60d8: f2c7 010b    	movt	r1, #0x700b
700a60dc: 7809         	ldrb	r1, [r1]
700a60de: eb00 0081    	add.w	r0, r0, r1, lsl #2
;     pLocalRespHdr =
700a60e2: 9003         	str	r0, [sp, #0xc]
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a60e4: e7ff         	b	0x700a60e6 <Sciclient_waitForMessage+0x36> @ imm = #-0x2
700a60e6: 9807         	ldr	r0, [sp, #0x1c]
700a60e8: f009 faea    	bl	0x700af6c0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x95d4
700a60ec: f009 fda0    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0x9b40
700a60f0: b2c0         	uxtb	r0, r0
;             CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount) <= 0U)
700a60f2: 9905         	ldr	r1, [sp, #0x14]
700a60f4: 1a40         	subs	r0, r0, r1
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a60f6: b960         	cbnz	r0, 0x700a6112 <Sciclient_waitForMessage+0x62> @ imm = #0x18
700a60f8: e7ff         	b	0x700a60fa <Sciclient_waitForMessage+0x4a> @ imm = #-0x2
;         if (timeToWait != 0U)
700a60fa: 9802         	ldr	r0, [sp, #0x8]
700a60fc: b120         	cbz	r0, 0x700a6108 <Sciclient_waitForMessage+0x58> @ imm = #0x8
700a60fe: e7ff         	b	0x700a6100 <Sciclient_waitForMessage+0x50> @ imm = #-0x2
;             timeToWait--;
700a6100: 9802         	ldr	r0, [sp, #0x8]
700a6102: 3801         	subs	r0, #0x1
700a6104: 9002         	str	r0, [sp, #0x8]
;         }
700a6106: e003         	b	0x700a6110 <Sciclient_waitForMessage+0x60> @ imm = #0x6
700a6108: f06f 0001    	mvn	r0, #0x1
;             status = SystemP_TIMEOUT;
700a610c: 9001         	str	r0, [sp, #0x4]
;             break;
700a610e: e000         	b	0x700a6112 <Sciclient_waitForMessage+0x62> @ imm = #0x0
;     while (((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a6110: e7e9         	b	0x700a60e6 <Sciclient_waitForMessage+0x36> @ imm = #-0x2e
;     if (status == SystemP_SUCCESS)
700a6112: 9801         	ldr	r0, [sp, #0x4]
700a6114: bbc0         	cbnz	r0, 0x700a6188 <Sciclient_waitForMessage+0xd8> @ imm = #0x70
700a6116: e7ff         	b	0x700a6118 <Sciclient_waitForMessage+0x68> @ imm = #-0x2
700a6118: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700a611c: 9001         	str	r0, [sp, #0x4]
;         timeToWait =  timeout;
700a611e: 9806         	ldr	r0, [sp, #0x18]
700a6120: 9002         	str	r0, [sp, #0x8]
;         while(1)
700a6122: e7ff         	b	0x700a6124 <Sciclient_waitForMessage+0x74> @ imm = #-0x2
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a6124: 9807         	ldr	r0, [sp, #0x1c]
700a6126: f009 facb    	bl	0x700af6c0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x9596
700a612a: f009 fd81    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0x9b02
700a612e: b2c0         	uxtb	r0, r0
;                     CSL_SEC_PROXY_RT_THREAD_STATUS_CUR_CNT_MASK) - initialCount;
700a6130: 9905         	ldr	r1, [sp, #0x14]
700a6132: 1a40         	subs	r0, r0, r1
;             uint32_t numCurrentMsgs = (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(rxThread)) &
700a6134: 9000         	str	r0, [sp]
;             if (pLocalRespHdr->seq == (uint32_t)localSeqId)
700a6136: 9803         	ldr	r0, [sp, #0xc]
700a6138: 78c0         	ldrb	r0, [r0, #0x3]
700a613a: f89d 1013    	ldrb.w	r1, [sp, #0x13]
700a613e: 4288         	cmp	r0, r1
700a6140: d103         	bne	0x700a614a <Sciclient_waitForMessage+0x9a> @ imm = #0x6
700a6142: e7ff         	b	0x700a6144 <Sciclient_waitForMessage+0x94> @ imm = #-0x2
700a6144: 2000         	movs	r0, #0x0
;                 status = SystemP_SUCCESS;
700a6146: 9001         	str	r0, [sp, #0x4]
;                 break;
700a6148: e01d         	b	0x700a6186 <Sciclient_waitForMessage+0xd6> @ imm = #0x3a
;             if (numCurrentMsgs > 1U)
700a614a: 9800         	ldr	r0, [sp]
700a614c: 2802         	cmp	r0, #0x2
700a614e: d30e         	blo	0x700a616e <Sciclient_waitForMessage+0xbe> @ imm = #0x1c
700a6150: e7ff         	b	0x700a6152 <Sciclient_waitForMessage+0xa2> @ imm = #-0x2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a6152: 9807         	ldr	r0, [sp, #0x1c]
;                                             (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U) - 1U));
700a6154: f642 1148    	movw	r1, #0x2948
700a6158: f2c7 010b    	movt	r1, #0x700b
700a615c: 694a         	ldr	r2, [r1, #0x14]
700a615e: f04f 31ff    	mov.w	r1, #0xffffffff
700a6162: eb01 0192    	add.w	r1, r1, r2, lsr #2
;                 (void) Sciclient_secProxyReadThread32(rxThread,
700a6166: b2c9         	uxtb	r1, r1
700a6168: f008 fc02    	bl	0x700ae970 <Sciclient_secProxyReadThread32> @ imm = #0x8804
;             }
700a616c: e7ff         	b	0x700a616e <Sciclient_waitForMessage+0xbe> @ imm = #-0x2
;             if (timeToWait != 0U)
700a616e: 9802         	ldr	r0, [sp, #0x8]
700a6170: b120         	cbz	r0, 0x700a617c <Sciclient_waitForMessage+0xcc> @ imm = #0x8
700a6172: e7ff         	b	0x700a6174 <Sciclient_waitForMessage+0xc4> @ imm = #-0x2
;                 timeToWait--;
700a6174: 9802         	ldr	r0, [sp, #0x8]
700a6176: 3801         	subs	r0, #0x1
700a6178: 9002         	str	r0, [sp, #0x8]
;             }
700a617a: e003         	b	0x700a6184 <Sciclient_waitForMessage+0xd4> @ imm = #0x6
700a617c: f06f 0001    	mvn	r0, #0x1
;                 status = SystemP_TIMEOUT;
700a6180: 9001         	str	r0, [sp, #0x4]
;                 break;
700a6182: e000         	b	0x700a6186 <Sciclient_waitForMessage+0xd6> @ imm = #0x0
;         while(1)
700a6184: e7ce         	b	0x700a6124 <Sciclient_waitForMessage+0x74> @ imm = #-0x64
;     }
700a6186: e7ff         	b	0x700a6188 <Sciclient_waitForMessage+0xd8> @ imm = #-0x2
;     return status;
700a6188: 9801         	ldr	r0, [sp, #0x4]
700a618a: b008         	add	sp, #0x20
700a618c: bd80         	pop	{r7, pc}
700a618e: 0000         	movs	r0, r0

700a6190 <UART_intrEnable>:
; {
700a6190: b580         	push	{r7, lr}
700a6192: b08a         	sub	sp, #0x28
700a6194: 9009         	str	r0, [sp, #0x24]
700a6196: 9108         	str	r1, [sp, #0x20]
700a6198: 2000         	movs	r0, #0x0
;     uint32_t enhanFnBitVal = 0U;
700a619a: 9007         	str	r0, [sp, #0x1c]
;     uint32_t lcrRegValue   = 0U;
700a619c: 9006         	str	r0, [sp, #0x18]
;     if ((intrFlag & 0xF0U) > 0U)
700a619e: f89d 0020    	ldrb.w	r0, [sp, #0x20]
700a61a2: f010 0ff0    	tst.w	r0, #0xf0
700a61a6: d053         	beq	0x700a6250 <UART_intrEnable+0xc0> @ imm = #0xa6
700a61a8: e7ff         	b	0x700a61aa <UART_intrEnable+0x1a> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a61aa: 9809         	ldr	r0, [sp, #0x24]
700a61ac: 300c         	adds	r0, #0xc
700a61ae: f009 fcdf    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x99be
700a61b2: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a61b4: 9809         	ldr	r0, [sp, #0x24]
700a61b6: 300c         	adds	r0, #0xc
700a61b8: 21bf         	movs	r1, #0xbf
700a61ba: 9103         	str	r1, [sp, #0xc]
700a61bc: f009 fce0    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x99c0
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a61c0: 9809         	ldr	r0, [sp, #0x24]
700a61c2: 3008         	adds	r0, #0x8
700a61c4: 2110         	movs	r1, #0x10
700a61c6: 9104         	str	r1, [sp, #0x10]
700a61c8: 2204         	movs	r2, #0x4
700a61ca: 9205         	str	r2, [sp, #0x14]
700a61cc: f009 f8b8    	bl	0x700af340 <HW_RD_FIELD32_RAW> @ imm = #0x9170
700a61d0: 9904         	ldr	r1, [sp, #0x10]
700a61d2: 9a05         	ldr	r2, [sp, #0x14]
700a61d4: 9007         	str	r0, [sp, #0x1c]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a61d6: 9809         	ldr	r0, [sp, #0x24]
700a61d8: 3008         	adds	r0, #0x8
700a61da: 2301         	movs	r3, #0x1
700a61dc: f008 fa68    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x84d0
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a61e0: 9809         	ldr	r0, [sp, #0x24]
700a61e2: 300c         	adds	r0, #0xc
700a61e4: 9906         	ldr	r1, [sp, #0x18]
700a61e6: f009 fccb    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x9996
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a61ea: 9809         	ldr	r0, [sp, #0x24]
700a61ec: 300c         	adds	r0, #0xc
700a61ee: f009 fcbf    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x997e
700a61f2: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a61f4: 9809         	ldr	r0, [sp, #0x24]
700a61f6: 300c         	adds	r0, #0xc
700a61f8: 9002         	str	r0, [sp, #0x8]
700a61fa: f009 fcb9    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x9972
700a61fe: 4601         	mov	r1, r0
700a6200: 9802         	ldr	r0, [sp, #0x8]
700a6202: f001 017f    	and	r1, r1, #0x7f
700a6206: f009 fcbb    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x9976
;         HW_WR_REG32(baseAddr + UART_IER, intrFlag & 0xF0U);
700a620a: 9809         	ldr	r0, [sp, #0x24]
700a620c: 3004         	adds	r0, #0x4
700a620e: 9908         	ldr	r1, [sp, #0x20]
700a6210: f001 01f0    	and	r1, r1, #0xf0
700a6214: f009 fcb4    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x9968
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a6218: 9809         	ldr	r0, [sp, #0x24]
700a621a: 300c         	adds	r0, #0xc
700a621c: 9906         	ldr	r1, [sp, #0x18]
700a621e: f009 fcaf    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x995e
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a6222: 9809         	ldr	r0, [sp, #0x24]
700a6224: 300c         	adds	r0, #0xc
700a6226: f009 fca3    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x9946
700a622a: 9903         	ldr	r1, [sp, #0xc]
700a622c: 9006         	str	r0, [sp, #0x18]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a622e: 9809         	ldr	r0, [sp, #0x24]
700a6230: 300c         	adds	r0, #0xc
700a6232: f009 fca5    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x994a
700a6236: 9904         	ldr	r1, [sp, #0x10]
700a6238: 9a05         	ldr	r2, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a623a: 9809         	ldr	r0, [sp, #0x24]
700a623c: 3008         	adds	r0, #0x8
700a623e: 9b07         	ldr	r3, [sp, #0x1c]
700a6240: f008 fa36    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x846c
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a6244: 9809         	ldr	r0, [sp, #0x24]
700a6246: 300c         	adds	r0, #0xc
700a6248: 9906         	ldr	r1, [sp, #0x18]
700a624a: f009 fc99    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x9932
;     }
700a624e: e7ff         	b	0x700a6250 <UART_intrEnable+0xc0> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) |
700a6250: 9809         	ldr	r0, [sp, #0x24]
700a6252: 3004         	adds	r0, #0x4
700a6254: 9001         	str	r0, [sp, #0x4]
700a6256: f009 fc8b    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x9916
700a625a: 4601         	mov	r1, r0
700a625c: 9801         	ldr	r0, [sp, #0x4]
700a625e: 9a08         	ldr	r2, [sp, #0x20]
700a6260: f002 020f    	and	r2, r2, #0xf
700a6264: 4311         	orrs	r1, r2
700a6266: f009 fc8b    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x9916
; }
700a626a: b00a         	add	sp, #0x28
700a626c: bd80         	pop	{r7, pc}
700a626e: 0000         	movs	r0, r0

700a6270 <Sciclient_rmIrInpIsFree>:
; {
700a6270: b580         	push	{r7, lr}
700a6272: b086         	sub	sp, #0x18
700a6274: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a6278: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a627c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a627e: 9004         	str	r0, [sp, #0x10]
;     const struct Sciclient_rmIrInst *inst = NULL;
700a6280: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a6282: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a6286: f005 fc73    	bl	0x700abb70 <Sciclient_rmIrGetInst> @ imm = #0x58e6
700a628a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a628c: 9803         	ldr	r0, [sp, #0xc]
700a628e: b920         	cbnz	r0, 0x700a629a <Sciclient_rmIrInpIsFree+0x2a> @ imm = #0x8
700a6290: e7ff         	b	0x700a6292 <Sciclient_rmIrInpIsFree+0x22> @ imm = #-0x2
700a6292: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a6296: 9004         	str	r0, [sp, #0x10]
;     } else {
700a6298: e00b         	b	0x700a62b2 <Sciclient_rmIrInpIsFree+0x42> @ imm = #0x16
;         if (inp >= inst->n_inp) {
700a629a: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a629e: 9903         	ldr	r1, [sp, #0xc]
700a62a0: 8909         	ldrh	r1, [r1, #0x8]
700a62a2: 4288         	cmp	r0, r1
700a62a4: db04         	blt	0x700a62b0 <Sciclient_rmIrInpIsFree+0x40> @ imm = #0x8
700a62a6: e7ff         	b	0x700a62a8 <Sciclient_rmIrInpIsFree+0x38> @ imm = #-0x2
700a62a8: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a62ac: 9004         	str	r0, [sp, #0x10]
;         }
700a62ae: e7ff         	b	0x700a62b0 <Sciclient_rmIrInpIsFree+0x40> @ imm = #-0x2
700a62b0: e7ff         	b	0x700a62b2 <Sciclient_rmIrInpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a62b2: 9804         	ldr	r0, [sp, #0x10]
700a62b4: 2800         	cmp	r0, #0x0
700a62b6: d145         	bne	0x700a6344 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #0x8a
700a62b8: e7ff         	b	0x700a62ba <Sciclient_rmIrInpIsFree+0x4a> @ imm = #-0x2
;         if (inp == 0u) {
700a62ba: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a62be: b960         	cbnz	r0, 0x700a62da <Sciclient_rmIrInpIsFree+0x6a> @ imm = #0x18
700a62c0: e7ff         	b	0x700a62c2 <Sciclient_rmIrInpIsFree+0x52> @ imm = #-0x2
;             if (inst->inp0_mapping != SCICLIENT_RM_IR_MAPPING_FREE) {
700a62c2: 9803         	ldr	r0, [sp, #0xc]
700a62c4: 8980         	ldrh	r0, [r0, #0xc]
700a62c6: f64f 71ff    	movw	r1, #0xffff
700a62ca: 4288         	cmp	r0, r1
700a62cc: d004         	beq	0x700a62d8 <Sciclient_rmIrInpIsFree+0x68> @ imm = #0x8
700a62ce: e7ff         	b	0x700a62d0 <Sciclient_rmIrInpIsFree+0x60> @ imm = #-0x2
700a62d0: f04f 30ff    	mov.w	r0, #0xffffffff
;                 r = SystemP_FAILURE;
700a62d4: 9004         	str	r0, [sp, #0x10]
;             }
700a62d6: e7ff         	b	0x700a62d8 <Sciclient_rmIrInpIsFree+0x68> @ imm = #-0x2
;         } else {
700a62d8: e033         	b	0x700a6342 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #0x66
700a62da: 2000         	movs	r0, #0x0
;             for (i = 0u; i < inst->n_outp; i++) {
700a62dc: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a62e0: e7ff         	b	0x700a62e2 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x2
700a62e2: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a62e6: 9903         	ldr	r1, [sp, #0xc]
700a62e8: 8949         	ldrh	r1, [r1, #0xa]
700a62ea: 4288         	cmp	r0, r1
700a62ec: da28         	bge	0x700a6340 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0x50
700a62ee: e7ff         	b	0x700a62f0 <Sciclient_rmIrInpIsFree+0x80> @ imm = #-0x2
;                 int_ctrl_reg = (volatile uint32_t *)Sciclient_getIrAddr(inst->cfg, i);
700a62f0: 9803         	ldr	r0, [sp, #0xc]
700a62f2: 6840         	ldr	r0, [r0, #0x4]
700a62f4: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700a62f8: f008 fc5a    	bl	0x700aebb0 <Sciclient_getIrAddr> @ imm = #0x88b4
700a62fc: 9001         	str	r0, [sp, #0x4]
;                 extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a62fe: 9801         	ldr	r0, [sp, #0x4]
700a6300: f240 31ff    	movw	r1, #0x3ff
700a6304: 2200         	movs	r2, #0x0
700a6306: f008 ff23    	bl	0x700af150 <CSL_REG32_FEXT_RAW> @ imm = #0x8e46
700a630a: f8ad 0002    	strh.w	r0, [sp, #0x2]
;                 if ((extracted_inp == inp) &&
700a630e: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a6312: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a6316: 4288         	cmp	r0, r1
700a6318: d10b         	bne	0x700a6332 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x16
700a631a: e7ff         	b	0x700a631c <Sciclient_rmIrInpIsFree+0xac> @ imm = #-0x2
;                     (Sciclient_rmIrInpRomMapped(inst, inp) == false)) {
700a631c: 9803         	ldr	r0, [sp, #0xc]
700a631e: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a6322: f002 f81d    	bl	0x700a8360 <Sciclient_rmIrInpRomMapped> @ imm = #0x203a
;                 if ((extracted_inp == inp) &&
700a6326: b920         	cbnz	r0, 0x700a6332 <Sciclient_rmIrInpIsFree+0xc2> @ imm = #0x8
700a6328: e7ff         	b	0x700a632a <Sciclient_rmIrInpIsFree+0xba> @ imm = #-0x2
700a632a: f04f 30ff    	mov.w	r0, #0xffffffff
;                     r = SystemP_FAILURE;
700a632e: 9004         	str	r0, [sp, #0x10]
;                     break;
700a6330: e006         	b	0x700a6340 <Sciclient_rmIrInpIsFree+0xd0> @ imm = #0xc
;             }
700a6332: e7ff         	b	0x700a6334 <Sciclient_rmIrInpIsFree+0xc4> @ imm = #-0x2
;             for (i = 0u; i < inst->n_outp; i++) {
700a6334: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700a6338: 3001         	adds	r0, #0x1
700a633a: f8ad 000a    	strh.w	r0, [sp, #0xa]
700a633e: e7d0         	b	0x700a62e2 <Sciclient_rmIrInpIsFree+0x72> @ imm = #-0x60
700a6340: e7ff         	b	0x700a6342 <Sciclient_rmIrInpIsFree+0xd2> @ imm = #-0x2
;     }
700a6342: e7ff         	b	0x700a6344 <Sciclient_rmIrInpIsFree+0xd4> @ imm = #-0x2
;     return r;
700a6344: 9804         	ldr	r0, [sp, #0x10]
700a6346: b006         	add	sp, #0x18
700a6348: bd80         	pop	{r7, pc}
700a634a: 0000         	movs	r0, r0
700a634c: 0000         	movs	r0, r0
700a634e: 0000         	movs	r0, r0

700a6350 <UART_intrDisable>:
; {
700a6350: b580         	push	{r7, lr}
700a6352: b088         	sub	sp, #0x20
700a6354: 9007         	str	r0, [sp, #0x1c]
700a6356: 9106         	str	r1, [sp, #0x18]
;     if((intrFlag & 0xF0U) > 0U)
700a6358: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a635c: f010 0ff0    	tst.w	r0, #0xf0
700a6360: d020         	beq	0x700a63a4 <UART_intrDisable+0x54> @ imm = #0x40
700a6362: e7ff         	b	0x700a6364 <UART_intrDisable+0x14> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a6364: 9807         	ldr	r0, [sp, #0x1c]
700a6366: 300c         	adds	r0, #0xc
700a6368: f009 fc02    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x9804
700a636c: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a636e: 9807         	ldr	r0, [sp, #0x1c]
700a6370: 300c         	adds	r0, #0xc
700a6372: 21bf         	movs	r1, #0xbf
700a6374: f009 fc04    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x9808
;         enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a6378: 9807         	ldr	r0, [sp, #0x1c]
700a637a: 3008         	adds	r0, #0x8
700a637c: 2110         	movs	r1, #0x10
700a637e: 9102         	str	r1, [sp, #0x8]
700a6380: 2204         	movs	r2, #0x4
700a6382: 9203         	str	r2, [sp, #0xc]
700a6384: f008 ffdc    	bl	0x700af340 <HW_RD_FIELD32_RAW> @ imm = #0x8fb8
700a6388: 9902         	ldr	r1, [sp, #0x8]
700a638a: 9a03         	ldr	r2, [sp, #0xc]
700a638c: 9005         	str	r0, [sp, #0x14]
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a638e: 9807         	ldr	r0, [sp, #0x1c]
700a6390: 3008         	adds	r0, #0x8
700a6392: 2301         	movs	r3, #0x1
700a6394: f008 f98c    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x8318
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a6398: 9807         	ldr	r0, [sp, #0x1c]
700a639a: 300c         	adds	r0, #0xc
700a639c: 9904         	ldr	r1, [sp, #0x10]
700a639e: f009 fbef    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x97de
;     }
700a63a2: e7ff         	b	0x700a63a4 <UART_intrDisable+0x54> @ imm = #-0x2
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a63a4: 9807         	ldr	r0, [sp, #0x1c]
700a63a6: 300c         	adds	r0, #0xc
700a63a8: f009 fbe2    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x97c4
700a63ac: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700a63ae: 9807         	ldr	r0, [sp, #0x1c]
700a63b0: 300c         	adds	r0, #0xc
700a63b2: 9000         	str	r0, [sp]
700a63b4: f009 fbdc    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x97b8
700a63b8: 4601         	mov	r1, r0
700a63ba: 9800         	ldr	r0, [sp]
700a63bc: f001 017f    	and	r1, r1, #0x7f
700a63c0: f009 fbde    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x97bc
;     HW_WR_REG32(baseAddr + UART_IER, HW_RD_REG32(baseAddr + UART_IER) &
700a63c4: 9807         	ldr	r0, [sp, #0x1c]
700a63c6: 3004         	adds	r0, #0x4
700a63c8: 9001         	str	r0, [sp, #0x4]
700a63ca: f009 fbd1    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x97a2
700a63ce: 4601         	mov	r1, r0
700a63d0: 9801         	ldr	r0, [sp, #0x4]
700a63d2: 9b06         	ldr	r3, [sp, #0x18]
700a63d4: f06f 02ff    	mvn	r2, #0xff
700a63d8: ea62 0203    	orn	r2, r2, r3
700a63dc: 4011         	ands	r1, r2
700a63de: f009 fbcf    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x979e
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a63e2: 9807         	ldr	r0, [sp, #0x1c]
700a63e4: 300c         	adds	r0, #0xc
700a63e6: 9904         	ldr	r1, [sp, #0x10]
700a63e8: f009 fbca    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x9794
;     if((intrFlag & 0xF0U) > 0U)
700a63ec: f89d 0018    	ldrb.w	r0, [sp, #0x18]
700a63f0: f010 0ff0    	tst.w	r0, #0xf0
700a63f4: d017         	beq	0x700a6426 <UART_intrDisable+0xd6> @ imm = #0x2e
700a63f6: e7ff         	b	0x700a63f8 <UART_intrDisable+0xa8> @ imm = #-0x2
;         lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700a63f8: 9807         	ldr	r0, [sp, #0x1c]
700a63fa: 300c         	adds	r0, #0xc
700a63fc: f009 fbb8    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x9770
700a6400: 9004         	str	r0, [sp, #0x10]
;         HW_WR_REG32(baseAddr + UART_LCR, UART_REG_CONFIG_MODE_B & 0xFFU);
700a6402: 9807         	ldr	r0, [sp, #0x1c]
700a6404: 300c         	adds	r0, #0xc
700a6406: 21bf         	movs	r1, #0xbf
700a6408: f009 fbba    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x9774
;         HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a640c: 9807         	ldr	r0, [sp, #0x1c]
700a640e: 3008         	adds	r0, #0x8
700a6410: 9b05         	ldr	r3, [sp, #0x14]
700a6412: 2110         	movs	r1, #0x10
700a6414: 2204         	movs	r2, #0x4
700a6416: f008 f94b    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x8296
;         HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a641a: 9807         	ldr	r0, [sp, #0x1c]
700a641c: 300c         	adds	r0, #0xc
700a641e: 9904         	ldr	r1, [sp, #0x10]
700a6420: f009 fbae    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x975c
;     }
700a6424: e7ff         	b	0x700a6426 <UART_intrDisable+0xd6> @ imm = #-0x2
; }
700a6426: b008         	add	sp, #0x20
700a6428: bd80         	pop	{r7, pc}
700a642a: 0000         	movs	r0, r0
700a642c: 0000         	movs	r0, r0
700a642e: 0000         	movs	r0, r0

700a6430 <UART_udmaConfigPdmaTx>:
; {
700a6430: b580         	push	{r7, lr}
700a6432: b090         	sub	sp, #0x40
700a6434: 900f         	str	r0, [sp, #0x3c]
700a6436: 910e         	str	r1, [sp, #0x38]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a6438: 980f         	ldr	r0, [sp, #0x3c]
700a643a: 6840         	ldr	r0, [r0, #0x4]
700a643c: 6cc0         	ldr	r0, [r0, #0x4c]
700a643e: 9008         	str	r0, [sp, #0x20]
;     txChHandle  = udmaChCfg->txChHandle;
700a6440: 9808         	ldr	r0, [sp, #0x20]
700a6442: 6840         	ldr	r0, [r0, #0x4]
700a6444: 9009         	str	r0, [sp, #0x24]
700a6446: a80a         	add	r0, sp, #0x28
;     UdmaChPdmaPrms_init(&pdmaPrms);
700a6448: 9002         	str	r0, [sp, #0x8]
700a644a: f009 f839    	bl	0x700af4c0 <UdmaChPdmaPrms_init> @ imm = #0x9072
700a644e: 9902         	ldr	r1, [sp, #0x8]
700a6450: 2000         	movs	r0, #0x0
;     pdmaPrms.elemSize = UDMA_PDMA_ES_8BITS;
700a6452: 9003         	str	r0, [sp, #0xc]
700a6454: 900a         	str	r0, [sp, #0x28]
700a6456: 2201         	movs	r2, #0x1
;     pdmaPrms.elemCnt  = 1U;
700a6458: 920b         	str	r2, [sp, #0x2c]
;     pdmaPrms.fifoCnt  = 0U;
700a645a: 900c         	str	r0, [sp, #0x30]
;     retVal = Udma_chConfigPdma(txChHandle, &pdmaPrms);
700a645c: 9809         	ldr	r0, [sp, #0x24]
700a645e: f7fa ff47    	bl	0x700a12f0 <Udma_chConfigPdma> @ imm = #-0x5172
700a6462: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a6464: 980d         	ldr	r0, [sp, #0x34]
700a6466: fab0 f080    	clz	r0, r0
700a646a: 0940         	lsrs	r0, r0, #0x5
700a646c: f641 716f    	movw	r1, #0x1f6f
700a6470: f2c7 010b    	movt	r1, #0x700b
700a6474: 9105         	str	r1, [sp, #0x14]
700a6476: 466a         	mov	r2, sp
700a6478: 6011         	str	r1, [r2]
700a647a: f641 316c    	movw	r1, #0x1b6c
700a647e: f2c7 010b    	movt	r1, #0x700b
700a6482: 9106         	str	r1, [sp, #0x18]
700a6484: f641 7232    	movw	r2, #0x1f32
700a6488: f2c7 020b    	movt	r2, #0x700b
700a648c: 9207         	str	r2, [sp, #0x1c]
700a648e: 23ee         	movs	r3, #0xee
700a6490: f004 fbf6    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x47ec
;     retVal = Udma_chEnable(txChHandle);
700a6494: 9809         	ldr	r0, [sp, #0x24]
700a6496: f004 feb3    	bl	0x700ab200 <Udma_chEnable> @ imm = #0x4d66
700a649a: 9b05         	ldr	r3, [sp, #0x14]
700a649c: 9906         	ldr	r1, [sp, #0x18]
700a649e: 9a07         	ldr	r2, [sp, #0x1c]
700a64a0: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a64a2: 980d         	ldr	r0, [sp, #0x34]
700a64a4: fab0 f080    	clz	r0, r0
700a64a8: 0940         	lsrs	r0, r0, #0x5
700a64aa: 46ec         	mov	r12, sp
700a64ac: f8cc 3000    	str.w	r3, [r12]
700a64b0: 23f1         	movs	r3, #0xf1
700a64b2: f004 fbe5    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x47ca
;     UART_udmaHpdInit(txChHandle, (uint8_t *) udmaChCfg->txHpdMem, hUart->writeBuf, transaction->count);
700a64b6: 9809         	ldr	r0, [sp, #0x24]
700a64b8: 9908         	ldr	r1, [sp, #0x20]
700a64ba: 6949         	ldr	r1, [r1, #0x14]
700a64bc: 9a0f         	ldr	r2, [sp, #0x3c]
700a64be: 6892         	ldr	r2, [r2, #0x8]
700a64c0: 9b0e         	ldr	r3, [sp, #0x38]
700a64c2: 685b         	ldr	r3, [r3, #0x4]
700a64c4: f000 fd3c    	bl	0x700a6f40 <UART_udmaHpdInit> @ imm = #0xa78
;                  Udma_chGetFqRingHandle(txChHandle),
700a64c8: 9809         	ldr	r0, [sp, #0x24]
700a64ca: f004 fdd9    	bl	0x700ab080 <Udma_chGetFqRingHandle> @ imm = #0x4bb2
700a64ce: 9a03         	ldr	r2, [sp, #0xc]
;                  (uint64_t) Udma_defaultVirtToPhyFxn(udmaChCfg->txHpdMem, 0U, NULL));
700a64d0: 9004         	str	r0, [sp, #0x10]
700a64d2: 9808         	ldr	r0, [sp, #0x20]
700a64d4: 6940         	ldr	r0, [r0, #0x14]
700a64d6: 4611         	mov	r1, r2
700a64d8: f009 fb5a    	bl	0x700afb90 <Udma_defaultVirtToPhyFxn> @ imm = #0x96b4
700a64dc: 4602         	mov	r2, r0
700a64de: 9804         	ldr	r0, [sp, #0x10]
700a64e0: 460b         	mov	r3, r1
;     retVal = Udma_ringQueueRaw(
700a64e2: f002 fe75    	bl	0x700a91d0 <Udma_ringQueueRaw> @ imm = #0x2cea
700a64e6: 9b05         	ldr	r3, [sp, #0x14]
700a64e8: 9906         	ldr	r1, [sp, #0x18]
700a64ea: 9a07         	ldr	r2, [sp, #0x1c]
700a64ec: 900d         	str	r0, [sp, #0x34]
;     DebugP_assert(UDMA_SOK == retVal);
700a64ee: 980d         	ldr	r0, [sp, #0x34]
700a64f0: fab0 f080    	clz	r0, r0
700a64f4: 0940         	lsrs	r0, r0, #0x5
700a64f6: 46ec         	mov	r12, sp
700a64f8: f8cc 3000    	str.w	r3, [r12]
700a64fc: 23f9         	movs	r3, #0xf9
700a64fe: f004 fbbf    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x477e
;     return (retVal);
700a6502: 980d         	ldr	r0, [sp, #0x34]
700a6504: b010         	add	sp, #0x40
700a6506: bd80         	pop	{r7, pc}
		...

700a6510 <vTaskDelete>:
; void vTaskDelete(TaskHandle_t xTaskToDelete) {
700a6510: b580         	push	{r7, lr}
700a6512: b084         	sub	sp, #0x10
700a6514: 9003         	str	r0, [sp, #0xc]
;   taskENTER_CRITICAL();
700a6516: f008 f92b    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x8256
;     pxTCB = prvGetTCBFromHandle(xTaskToDelete);
700a651a: 9803         	ldr	r0, [sp, #0xc]
700a651c: b938         	cbnz	r0, 0x700a652e <vTaskDelete+0x1e> @ imm = #0xe
700a651e: e7ff         	b	0x700a6520 <vTaskDelete+0x10> @ imm = #-0x2
700a6520: f642 10fc    	movw	r0, #0x29fc
700a6524: f2c7 000b    	movt	r0, #0x700b
700a6528: 6800         	ldr	r0, [r0]
700a652a: 9001         	str	r0, [sp, #0x4]
700a652c: e002         	b	0x700a6534 <vTaskDelete+0x24> @ imm = #0x4
700a652e: 9803         	ldr	r0, [sp, #0xc]
700a6530: 9001         	str	r0, [sp, #0x4]
700a6532: e7ff         	b	0x700a6534 <vTaskDelete+0x24> @ imm = #-0x2
700a6534: 9801         	ldr	r0, [sp, #0x4]
700a6536: 9002         	str	r0, [sp, #0x8]
;     if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a6538: 9802         	ldr	r0, [sp, #0x8]
700a653a: 3004         	adds	r0, #0x4
700a653c: f007 f8e8    	bl	0x700ad710 <uxListRemove> @ imm = #0x71d0
700a6540: b908         	cbnz	r0, 0x700a6546 <vTaskDelete+0x36> @ imm = #0x2
700a6542: e7ff         	b	0x700a6544 <vTaskDelete+0x34> @ imm = #-0x2
;     } else {
700a6544: e000         	b	0x700a6548 <vTaskDelete+0x38> @ imm = #0x0
700a6546: e7ff         	b	0x700a6548 <vTaskDelete+0x38> @ imm = #-0x2
;     if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
700a6548: 9802         	ldr	r0, [sp, #0x8]
700a654a: 6a80         	ldr	r0, [r0, #0x28]
700a654c: b128         	cbz	r0, 0x700a655a <vTaskDelete+0x4a> @ imm = #0xa
700a654e: e7ff         	b	0x700a6550 <vTaskDelete+0x40> @ imm = #-0x2
;       (void)uxListRemove(&(pxTCB->xEventListItem));
700a6550: 9802         	ldr	r0, [sp, #0x8]
700a6552: 3018         	adds	r0, #0x18
700a6554: f007 f8dc    	bl	0x700ad710 <uxListRemove> @ imm = #0x71b8
;     } else {
700a6558: e000         	b	0x700a655c <vTaskDelete+0x4c> @ imm = #0x0
700a655a: e7ff         	b	0x700a655c <vTaskDelete+0x4c> @ imm = #-0x2
;     uxTaskNumber++;
700a655c: f642 2128    	movw	r1, #0x2a28
700a6560: f2c7 010b    	movt	r1, #0x700b
700a6564: 6808         	ldr	r0, [r1]
700a6566: 3001         	adds	r0, #0x1
700a6568: 6008         	str	r0, [r1]
;     if (pxTCB == pxCurrentTCB) {
700a656a: 9802         	ldr	r0, [sp, #0x8]
700a656c: f642 11fc    	movw	r1, #0x29fc
700a6570: f2c7 010b    	movt	r1, #0x700b
700a6574: 6809         	ldr	r1, [r1]
700a6576: 4288         	cmp	r0, r1
700a6578: d110         	bne	0x700a659c <vTaskDelete+0x8c> @ imm = #0x20
700a657a: e7ff         	b	0x700a657c <vTaskDelete+0x6c> @ imm = #-0x2
;       vListInsertEnd(&xTasksWaitingTermination, &(pxTCB->xStateListItem));
700a657c: 9802         	ldr	r0, [sp, #0x8]
700a657e: 1d01         	adds	r1, r0, #0x4
700a6580: f245 2088    	movw	r0, #0x5288
700a6584: f2c7 0008    	movt	r0, #0x7008
700a6588: f007 fe7a    	bl	0x700ae280 <vListInsertEnd> @ imm = #0x7cf4
;       ++uxDeletedTasksWaitingCleanUp;
700a658c: f642 2120    	movw	r1, #0x2a20
700a6590: f2c7 010b    	movt	r1, #0x700b
700a6594: 6808         	ldr	r0, [r1]
700a6596: 3001         	adds	r0, #0x1
700a6598: 6008         	str	r0, [r1]
;     } else {
700a659a: e00c         	b	0x700a65b6 <vTaskDelete+0xa6> @ imm = #0x18
;       --uxCurrentNumberOfTasks;
700a659c: f642 211c    	movw	r1, #0x2a1c
700a65a0: f2c7 010b    	movt	r1, #0x700b
700a65a4: 6808         	ldr	r0, [r1]
700a65a6: 3801         	subs	r0, #0x1
700a65a8: 6008         	str	r0, [r1]
;       prvDeleteTCB(pxTCB);
700a65aa: 9802         	ldr	r0, [sp, #0x8]
700a65ac: f007 fdc8    	bl	0x700ae140 <prvDeleteTCB> @ imm = #0x7b90
;       prvResetNextTaskUnblockTime();
700a65b0: f007 fde6    	bl	0x700ae180 <prvResetNextTaskUnblockTime> @ imm = #0x7bcc
700a65b4: e7ff         	b	0x700a65b6 <vTaskDelete+0xa6> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a65b6: f007 f99b    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x7336
;   if (xSchedulerRunning != pdFALSE) {
700a65ba: f642 2040    	movw	r0, #0x2a40
700a65be: f2c7 000b    	movt	r0, #0x700b
700a65c2: 6800         	ldr	r0, [r0]
700a65c4: b168         	cbz	r0, 0x700a65e2 <vTaskDelete+0xd2> @ imm = #0x1a
700a65c6: e7ff         	b	0x700a65c8 <vTaskDelete+0xb8> @ imm = #-0x2
;     if (pxTCB == pxCurrentTCB) {
700a65c8: 9802         	ldr	r0, [sp, #0x8]
700a65ca: f642 11fc    	movw	r1, #0x29fc
700a65ce: f2c7 010b    	movt	r1, #0x700b
700a65d2: 6809         	ldr	r1, [r1]
700a65d4: 4288         	cmp	r0, r1
700a65d6: d102         	bne	0x700a65de <vTaskDelete+0xce> @ imm = #0x4
700a65d8: e7ff         	b	0x700a65da <vTaskDelete+0xca> @ imm = #-0x2
;       portYIELD_WITHIN_API();
700a65da: df00         	svc	#0x0
;     } else {
700a65dc: e000         	b	0x700a65e0 <vTaskDelete+0xd0> @ imm = #0x0
700a65de: e7ff         	b	0x700a65e0 <vTaskDelete+0xd0> @ imm = #-0x2
;   }
700a65e0: e7ff         	b	0x700a65e2 <vTaskDelete+0xd2> @ imm = #-0x2
; }
700a65e2: b004         	add	sp, #0x10
700a65e4: bd80         	pop	{r7, pc}
		...
700a65ee: 0000         	movs	r0, r0

700a65f0 <CSL_bcdmaChanOpGetChanRT>:
; {
700a65f0: b580         	push	{r7, lr}
700a65f2: b088         	sub	sp, #0x20
700a65f4: 9007         	str	r0, [sp, #0x1c]
700a65f6: 9106         	str	r1, [sp, #0x18]
700a65f8: 9205         	str	r2, [sp, #0x14]
700a65fa: 9304         	str	r3, [sp, #0x10]
700a65fc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a65fe: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a6600: 9804         	ldr	r0, [sp, #0x10]
700a6602: b920         	cbnz	r0, 0x700a660e <CSL_bcdmaChanOpGetChanRT+0x1e> @ imm = #0x8
700a6604: e7ff         	b	0x700a6606 <CSL_bcdmaChanOpGetChanRT+0x16> @ imm = #-0x2
700a6606: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a660a: 9003         	str	r0, [sp, #0xc]
;     }
700a660c: e057         	b	0x700a66be <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #0xae
;         switch( chanType )
700a660e: 9806         	ldr	r0, [sp, #0x18]
700a6610: 9000         	str	r0, [sp]
700a6612: b140         	cbz	r0, 0x700a6626 <CSL_bcdmaChanOpGetChanRT+0x36> @ imm = #0x10
700a6614: e7ff         	b	0x700a6616 <CSL_bcdmaChanOpGetChanRT+0x26> @ imm = #-0x2
700a6616: 9800         	ldr	r0, [sp]
700a6618: 2801         	cmp	r0, #0x1
700a661a: d00d         	beq	0x700a6638 <CSL_bcdmaChanOpGetChanRT+0x48> @ imm = #0x1a
700a661c: e7ff         	b	0x700a661e <CSL_bcdmaChanOpGetChanRT+0x2e> @ imm = #-0x2
700a661e: 9800         	ldr	r0, [sp]
700a6620: 2802         	cmp	r0, #0x2
700a6622: d012         	beq	0x700a664a <CSL_bcdmaChanOpGetChanRT+0x5a> @ imm = #0x24
700a6624: e01a         	b	0x700a665c <CSL_bcdmaChanOpGetChanRT+0x6c> @ imm = #0x34
;                 val = CSL_REG32_RD( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL );
700a6626: 9807         	ldr	r0, [sp, #0x1c]
700a6628: 6880         	ldr	r0, [r0, #0x8]
700a662a: 9905         	ldr	r1, [sp, #0x14]
700a662c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6630: f009 fae6    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0x95cc
700a6634: 9002         	str	r0, [sp, #0x8]
;                 break;
700a6636: e015         	b	0x700a6664 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x2a
;                 val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700a6638: 9807         	ldr	r0, [sp, #0x1c]
700a663a: 6900         	ldr	r0, [r0, #0x10]
700a663c: 9905         	ldr	r1, [sp, #0x14]
700a663e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6642: f009 fadd    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0x95ba
700a6646: 9002         	str	r0, [sp, #0x8]
;                 break;
700a6648: e00c         	b	0x700a6664 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x18
;                 val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700a664a: 9807         	ldr	r0, [sp, #0x1c]
700a664c: 6980         	ldr	r0, [r0, #0x18]
700a664e: 9905         	ldr	r1, [sp, #0x14]
700a6650: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a6654: f009 fad4    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0x95a8
700a6658: 9002         	str	r0, [sp, #0x8]
;                 break;
700a665a: e003         	b	0x700a6664 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #0x6
700a665c: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a6660: 9003         	str	r0, [sp, #0xc]
;                 break;
700a6662: e7ff         	b	0x700a6664 <CSL_bcdmaChanOpGetChanRT+0x74> @ imm = #-0x2
;         if( retVal == CSL_PASS )
700a6664: 9803         	ldr	r0, [sp, #0xc]
700a6666: bb48         	cbnz	r0, 0x700a66bc <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #0x52
700a6668: e7ff         	b	0x700a666a <CSL_bcdmaChanOpGetChanRT+0x7a> @ imm = #-0x2
;             CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a666a: 9804         	ldr	r0, [sp, #0x10]
700a666c: 9001         	str	r0, [sp, #0x4]
;             pRT->enable         = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_EN );
700a666e: 9802         	ldr	r0, [sp, #0x8]
700a6670: 0fc0         	lsrs	r0, r0, #0x1f
700a6672: 9901         	ldr	r1, [sp, #0x4]
700a6674: 6008         	str	r0, [r1]
;             pRT->teardown       = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_TDOWN );
700a6676: 9802         	ldr	r0, [sp, #0x8]
700a6678: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700a667c: 9901         	ldr	r1, [sp, #0x4]
700a667e: 6048         	str	r0, [r1, #0x4]
;             pRT->forcedTeardown = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_FTDOWN );
700a6680: 9802         	ldr	r0, [sp, #0x8]
700a6682: f3c0 7000    	ubfx	r0, r0, #0x1c, #0x1
700a6686: 9901         	ldr	r1, [sp, #0x4]
700a6688: 6108         	str	r0, [r1, #0x10]
;             pRT->pause          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_PAUSE );
700a668a: 9802         	ldr	r0, [sp, #0x8]
700a668c: f3c0 7040    	ubfx	r0, r0, #0x1d, #0x1
700a6690: 9901         	ldr	r1, [sp, #0x4]
700a6692: 6088         	str	r0, [r1, #0x8]
;             pRT->error          = CSL_FEXT( val, BCDMA_TXCRT_CHAN_CTL_ERROR );
700a6694: 9802         	ldr	r0, [sp, #0x8]
700a6696: f000 0001    	and	r0, r0, #0x1
700a669a: 9901         	ldr	r1, [sp, #0x4]
700a669c: 60c8         	str	r0, [r1, #0xc]
;             if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700a669e: 9806         	ldr	r0, [sp, #0x18]
700a66a0: 2802         	cmp	r0, #0x2
700a66a2: d106         	bne	0x700a66b2 <CSL_bcdmaChanOpGetChanRT+0xc2> @ imm = #0xc
700a66a4: e7ff         	b	0x700a66a6 <CSL_bcdmaChanOpGetChanRT+0xb6> @ imm = #-0x2
;                 pRT->starvation = CSL_FEXT( val, BCDMA_RXCRT_CHAN_CTL_STARVATION );
700a66a6: 9802         	ldr	r0, [sp, #0x8]
700a66a8: f3c0 0040    	ubfx	r0, r0, #0x1, #0x1
700a66ac: 9901         	ldr	r1, [sp, #0x4]
700a66ae: 6148         	str	r0, [r1, #0x14]
;             }
700a66b0: e003         	b	0x700a66ba <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #0x6
;                 pRT->starvation = (uint32_t)0U;
700a66b2: 9901         	ldr	r1, [sp, #0x4]
700a66b4: 2000         	movs	r0, #0x0
700a66b6: 6148         	str	r0, [r1, #0x14]
700a66b8: e7ff         	b	0x700a66ba <CSL_bcdmaChanOpGetChanRT+0xca> @ imm = #-0x2
;         }
700a66ba: e7ff         	b	0x700a66bc <CSL_bcdmaChanOpGetChanRT+0xcc> @ imm = #-0x2
700a66bc: e7ff         	b	0x700a66be <CSL_bcdmaChanOpGetChanRT+0xce> @ imm = #-0x2
;     return retVal;
700a66be: 9803         	ldr	r0, [sp, #0xc]
700a66c0: b008         	add	sp, #0x20
700a66c2: bd80         	pop	{r7, pc}
		...

700a66d0 <Pinmux_unlockMMR>:
; {
700a66d0: b580         	push	{r7, lr}
700a66d2: b088         	sub	sp, #0x20
700a66d4: 9007         	str	r0, [sp, #0x1c]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a66d6: 9807         	ldr	r0, [sp, #0x1c]
700a66d8: bb78         	cbnz	r0, 0x700a673a <Pinmux_unlockMMR+0x6a> @ imm = #0x5e
700a66da: e7ff         	b	0x700a66dc <Pinmux_unlockMMR+0xc> @ imm = #-0x2
700a66dc: f44f 2070    	mov.w	r0, #0xf0000
700a66e0: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_PADCFG_CTRL0_CFG0_BASE);
700a66e2: f7ff fa95    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0xad6
700a66e6: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK0_KICK0_OFFSET);
700a66e8: 9806         	ldr	r0, [sp, #0x18]
700a66ea: f241 0108    	movw	r1, #0x1008
700a66ee: 4408         	add	r0, r1
700a66f0: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a66f2: 9805         	ldr	r0, [sp, #0x14]
700a66f4: f243 4190    	movw	r1, #0x3490
700a66f8: f6c6 01ef    	movt	r1, #0x68ef
700a66fc: 9103         	str	r1, [sp, #0xc]
700a66fe: f009 f9ef    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x93de
;         kickAddr++;
700a6702: 9805         	ldr	r0, [sp, #0x14]
700a6704: 3004         	adds	r0, #0x4
700a6706: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6708: 9805         	ldr	r0, [sp, #0x14]
700a670a: f64b 415a    	movw	r1, #0xbc5a
700a670e: f2cd 1172    	movt	r1, #0xd172
700a6712: 9104         	str	r1, [sp, #0x10]
700a6714: f009 f9e4    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x93c8
700a6718: 9903         	ldr	r1, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_PADCONFIG_LOCK1_KICK0_OFFSET);
700a671a: 9806         	ldr	r0, [sp, #0x18]
700a671c: f245 0208    	movw	r2, #0x5008
700a6720: 4410         	add	r0, r2
700a6722: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6724: 9805         	ldr	r0, [sp, #0x14]
700a6726: f009 f9db    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x93b6
700a672a: 9904         	ldr	r1, [sp, #0x10]
;         kickAddr++;
700a672c: 9805         	ldr	r0, [sp, #0x14]
700a672e: 3004         	adds	r0, #0x4
700a6730: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6732: 9805         	ldr	r0, [sp, #0x14]
700a6734: f009 f9d4    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x93a8
;     }
700a6738: e7ff         	b	0x700a673a <Pinmux_unlockMMR+0x6a> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700a673a: 9807         	ldr	r0, [sp, #0x1c]
700a673c: 2801         	cmp	r0, #0x1
700a673e: d12f         	bne	0x700a67a0 <Pinmux_unlockMMR+0xd0> @ imm = #0x5e
700a6740: e7ff         	b	0x700a6742 <Pinmux_unlockMMR+0x72> @ imm = #-0x2
700a6742: f04f 6081    	mov.w	r0, #0x4080000
700a6746: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700a6748: f7ff fa62    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0xb3c
700a674c: 9006         	str	r0, [sp, #0x18]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700a674e: 9806         	ldr	r0, [sp, #0x18]
700a6750: f241 0108    	movw	r1, #0x1008
700a6754: 4408         	add	r0, r1
700a6756: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a6758: 9805         	ldr	r0, [sp, #0x14]
700a675a: f243 4190    	movw	r1, #0x3490
700a675e: f6c6 01ef    	movt	r1, #0x68ef
700a6762: 9101         	str	r1, [sp, #0x4]
700a6764: f009 f9bc    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x9378
;         kickAddr++;
700a6768: 9805         	ldr	r0, [sp, #0x14]
700a676a: 3004         	adds	r0, #0x4
700a676c: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a676e: 9805         	ldr	r0, [sp, #0x14]
700a6770: f64b 415a    	movw	r1, #0xbc5a
700a6774: f2cd 1172    	movt	r1, #0xd172
700a6778: 9102         	str	r1, [sp, #0x8]
700a677a: f009 f9b1    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x9362
700a677e: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700a6780: 9806         	ldr	r0, [sp, #0x18]
700a6782: f245 0208    	movw	r2, #0x5008
700a6786: 4410         	add	r0, r2
700a6788: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a678a: 9805         	ldr	r0, [sp, #0x14]
700a678c: f009 f9a8    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x9350
700a6790: 9902         	ldr	r1, [sp, #0x8]
;         kickAddr++;
700a6792: 9805         	ldr	r0, [sp, #0x14]
700a6794: 3004         	adds	r0, #0x4
700a6796: 9005         	str	r0, [sp, #0x14]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a6798: 9805         	ldr	r0, [sp, #0x14]
700a679a: f009 f9a1    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x9342
;     }
700a679e: e7ff         	b	0x700a67a0 <Pinmux_unlockMMR+0xd0> @ imm = #-0x2
;     return;
700a67a0: b008         	add	sp, #0x20
700a67a2: bd80         	pop	{r7, pc}
		...

700a67b0 <prvAddCurrentTaskToDelayedList>:
;                                const BaseType_t xCanBlockIndefinitely) {
700a67b0: b580         	push	{r7, lr}
700a67b2: b084         	sub	sp, #0x10
700a67b4: 9003         	str	r0, [sp, #0xc]
700a67b6: 9102         	str	r1, [sp, #0x8]
;   const TickType_t xConstTickCount = xTickCount;
700a67b8: f642 2044    	movw	r0, #0x2a44
700a67bc: f2c7 000b    	movt	r0, #0x700b
700a67c0: 6800         	ldr	r0, [r0]
700a67c2: 9000         	str	r0, [sp]
;   if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
700a67c4: f642 10fc    	movw	r0, #0x29fc
700a67c8: f2c7 000b    	movt	r0, #0x700b
700a67cc: 6800         	ldr	r0, [r0]
700a67ce: 3004         	adds	r0, #0x4
700a67d0: f006 ff9e    	bl	0x700ad710 <uxListRemove> @ imm = #0x6f3c
700a67d4: b908         	cbnz	r0, 0x700a67da <prvAddCurrentTaskToDelayedList+0x2a> @ imm = #0x2
700a67d6: e7ff         	b	0x700a67d8 <prvAddCurrentTaskToDelayedList+0x28> @ imm = #-0x2
;   } else {
700a67d8: e000         	b	0x700a67dc <prvAddCurrentTaskToDelayedList+0x2c> @ imm = #0x0
700a67da: e7ff         	b	0x700a67dc <prvAddCurrentTaskToDelayedList+0x2c> @ imm = #-0x2
;     if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
700a67dc: 9803         	ldr	r0, [sp, #0xc]
700a67de: 3001         	adds	r0, #0x1
700a67e0: b980         	cbnz	r0, 0x700a6804 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #0x20
700a67e2: e7ff         	b	0x700a67e4 <prvAddCurrentTaskToDelayedList+0x34> @ imm = #-0x2
700a67e4: 9802         	ldr	r0, [sp, #0x8]
700a67e6: b168         	cbz	r0, 0x700a6804 <prvAddCurrentTaskToDelayedList+0x54> @ imm = #0x1a
700a67e8: e7ff         	b	0x700a67ea <prvAddCurrentTaskToDelayedList+0x3a> @ imm = #-0x2
;       vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
700a67ea: f642 10fc    	movw	r0, #0x29fc
700a67ee: f2c7 000b    	movt	r0, #0x700b
700a67f2: 6800         	ldr	r0, [r0]
700a67f4: 1d01         	adds	r1, r0, #0x4
700a67f6: f245 2074    	movw	r0, #0x5274
700a67fa: f2c7 0008    	movt	r0, #0x7008
700a67fe: f007 fd3f    	bl	0x700ae280 <vListInsertEnd> @ imm = #0x7a7e
;     } else {
700a6802: e03d         	b	0x700a6880 <prvAddCurrentTaskToDelayedList+0xd0> @ imm = #0x7a
;       xTimeToWake = xConstTickCount + xTicksToWait;
700a6804: 9800         	ldr	r0, [sp]
700a6806: 9903         	ldr	r1, [sp, #0xc]
700a6808: 4408         	add	r0, r1
700a680a: 9001         	str	r0, [sp, #0x4]
;       listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
700a680c: 9801         	ldr	r0, [sp, #0x4]
700a680e: f642 11fc    	movw	r1, #0x29fc
700a6812: f2c7 010b    	movt	r1, #0x700b
700a6816: 6809         	ldr	r1, [r1]
700a6818: 6048         	str	r0, [r1, #0x4]
;       if (xTimeToWake < xConstTickCount) {
700a681a: 9801         	ldr	r0, [sp, #0x4]
700a681c: 9900         	ldr	r1, [sp]
700a681e: 4288         	cmp	r0, r1
700a6820: d20e         	bhs	0x700a6840 <prvAddCurrentTaskToDelayedList+0x90> @ imm = #0x1c
700a6822: e7ff         	b	0x700a6824 <prvAddCurrentTaskToDelayedList+0x74> @ imm = #-0x2
;         vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a6824: f245 20a4    	movw	r0, #0x52a4
700a6828: f2c7 0008    	movt	r0, #0x7008
700a682c: 6800         	ldr	r0, [r0]
700a682e: f642 11fc    	movw	r1, #0x29fc
700a6832: f2c7 010b    	movt	r1, #0x700b
700a6836: 6809         	ldr	r1, [r1]
700a6838: 3104         	adds	r1, #0x4
700a683a: f004 ffd9    	bl	0x700ab7f0 <vListInsert> @ imm = #0x4fb2
;       } else {
700a683e: e01e         	b	0x700a687e <prvAddCurrentTaskToDelayedList+0xce> @ imm = #0x3c
;         vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
700a6840: f245 20a0    	movw	r0, #0x52a0
700a6844: f2c7 0008    	movt	r0, #0x7008
700a6848: 6800         	ldr	r0, [r0]
700a684a: f642 11fc    	movw	r1, #0x29fc
700a684e: f2c7 010b    	movt	r1, #0x700b
700a6852: 6809         	ldr	r1, [r1]
700a6854: 3104         	adds	r1, #0x4
700a6856: f004 ffcb    	bl	0x700ab7f0 <vListInsert> @ imm = #0x4f96
;         if (xTimeToWake < xNextTaskUnblockTime) {
700a685a: 9801         	ldr	r0, [sp, #0x4]
700a685c: f642 2134    	movw	r1, #0x2a34
700a6860: f2c7 010b    	movt	r1, #0x700b
700a6864: 6809         	ldr	r1, [r1]
700a6866: 4288         	cmp	r0, r1
700a6868: d207         	bhs	0x700a687a <prvAddCurrentTaskToDelayedList+0xca> @ imm = #0xe
700a686a: e7ff         	b	0x700a686c <prvAddCurrentTaskToDelayedList+0xbc> @ imm = #-0x2
;           xNextTaskUnblockTime = xTimeToWake;
700a686c: 9801         	ldr	r0, [sp, #0x4]
700a686e: f642 2134    	movw	r1, #0x2a34
700a6872: f2c7 010b    	movt	r1, #0x700b
700a6876: 6008         	str	r0, [r1]
;         } else {
700a6878: e000         	b	0x700a687c <prvAddCurrentTaskToDelayedList+0xcc> @ imm = #0x0
700a687a: e7ff         	b	0x700a687c <prvAddCurrentTaskToDelayedList+0xcc> @ imm = #-0x2
700a687c: e7ff         	b	0x700a687e <prvAddCurrentTaskToDelayedList+0xce> @ imm = #-0x2
700a687e: e7ff         	b	0x700a6880 <prvAddCurrentTaskToDelayedList+0xd0> @ imm = #-0x2
; }
700a6880: b004         	add	sp, #0x10
700a6882: bd80         	pop	{r7, pc}
		...

700a6890 <UART_lld_write>:
; {
700a6890: b580         	push	{r7, lr}
700a6892: b086         	sub	sp, #0x18
700a6894: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a6898: 9005         	str	r0, [sp, #0x14]
700a689a: 9104         	str	r1, [sp, #0x10]
700a689c: 9203         	str	r2, [sp, #0xc]
700a689e: 9302         	str	r3, [sp, #0x8]
700a68a0: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a68a2: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a68a4: 9805         	ldr	r0, [sp, #0x14]
700a68a6: 2800         	cmp	r0, #0x0
700a68a8: d054         	beq	0x700a6954 <UART_lld_write+0xc4> @ imm = #0xa8
700a68aa: e7ff         	b	0x700a68ac <UART_lld_write+0x1c> @ imm = #-0x2
;          trans = &hUart->writeTrans;
700a68ac: 9805         	ldr	r0, [sp, #0x14]
700a68ae: 303c         	adds	r0, #0x3c
700a68b0: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a68b2: 9800         	ldr	r0, [sp]
700a68b4: 6800         	ldr	r0, [r0]
700a68b6: b138         	cbz	r0, 0x700a68c8 <UART_lld_write+0x38> @ imm = #0xe
700a68b8: e7ff         	b	0x700a68ba <UART_lld_write+0x2a> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a68ba: 9900         	ldr	r1, [sp]
700a68bc: 2009         	movs	r0, #0x9
700a68be: 60c8         	str	r0, [r1, #0xc]
700a68c0: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a68c4: 9001         	str	r0, [sp, #0x4]
;         }
700a68c6: e044         	b	0x700a6952 <UART_lld_write+0xc2> @ imm = #0x88
;             UART_lld_Transaction_init(trans);
700a68c8: 9800         	ldr	r0, [sp]
700a68ca: f008 fa79    	bl	0x700aedc0 <UART_lld_Transaction_init> @ imm = #0x84f2
;             if(extendedParams != NULL)
700a68ce: 9808         	ldr	r0, [sp, #0x20]
700a68d0: b128         	cbz	r0, 0x700a68de <UART_lld_write+0x4e> @ imm = #0xa
700a68d2: e7ff         	b	0x700a68d4 <UART_lld_write+0x44> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a68d4: 9808         	ldr	r0, [sp, #0x20]
700a68d6: 6800         	ldr	r0, [r0]
700a68d8: 9900         	ldr	r1, [sp]
700a68da: 6108         	str	r0, [r1, #0x10]
;             }
700a68dc: e003         	b	0x700a68e6 <UART_lld_write+0x56> @ imm = #0x6
;                 trans->args = NULL;
700a68de: 9900         	ldr	r1, [sp]
700a68e0: 2000         	movs	r0, #0x0
700a68e2: 6108         	str	r0, [r1, #0x10]
700a68e4: e7ff         	b	0x700a68e6 <UART_lld_write+0x56> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a68e6: 9804         	ldr	r0, [sp, #0x10]
700a68e8: 9900         	ldr	r1, [sp]
700a68ea: 6008         	str	r0, [r1]
;             trans->count = size;
700a68ec: 9803         	ldr	r0, [sp, #0xc]
700a68ee: 9900         	ldr	r1, [sp]
700a68f0: 6048         	str	r0, [r1, #0x4]
;             trans->timeout = timeout;
700a68f2: 9802         	ldr	r0, [sp, #0x8]
700a68f4: 9900         	ldr	r1, [sp]
700a68f6: 6088         	str	r0, [r1, #0x8]
;             if(hUart->state == UART_STATE_READY)
700a68f8: 9805         	ldr	r0, [sp, #0x14]
700a68fa: 6d40         	ldr	r0, [r0, #0x54]
700a68fc: 2801         	cmp	r0, #0x1
700a68fe: d105         	bne	0x700a690c <UART_lld_write+0x7c> @ imm = #0xa
700a6900: e7ff         	b	0x700a6902 <UART_lld_write+0x72> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a6902: 9800         	ldr	r0, [sp]
700a6904: f007 fe5c    	bl	0x700ae5c0 <UART_checkTransaction> @ imm = #0x7cb8
700a6908: 9001         	str	r0, [sp, #0x4]
;             }
700a690a: e003         	b	0x700a6914 <UART_lld_write+0x84> @ imm = #0x6
700a690c: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a6910: 9001         	str	r0, [sp, #0x4]
700a6912: e7ff         	b	0x700a6914 <UART_lld_write+0x84> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a6914: 9801         	ldr	r0, [sp, #0x4]
700a6916: b980         	cbnz	r0, 0x700a693a <UART_lld_write+0xaa> @ imm = #0x20
700a6918: e7ff         	b	0x700a691a <UART_lld_write+0x8a> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a691a: 9800         	ldr	r0, [sp]
700a691c: 6800         	ldr	r0, [r0]
700a691e: 9905         	ldr	r1, [sp, #0x14]
700a6920: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a6922: 9800         	ldr	r0, [sp]
700a6924: 6880         	ldr	r0, [r0, #0x8]
700a6926: 9905         	ldr	r1, [sp, #0x14]
700a6928: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a692a: 9905         	ldr	r1, [sp, #0x14]
700a692c: 2000         	movs	r0, #0x0
700a692e: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a6930: 9800         	ldr	r0, [sp]
700a6932: 6840         	ldr	r0, [r0, #0x4]
700a6934: 9905         	ldr	r1, [sp, #0x14]
700a6936: 6108         	str	r0, [r1, #0x10]
;             }
700a6938: e7ff         	b	0x700a693a <UART_lld_write+0xaa> @ imm = #-0x2
;             hUart->state = UART_STATE_BUSY;
700a693a: 9905         	ldr	r1, [sp, #0x14]
700a693c: 2002         	movs	r0, #0x2
700a693e: 6548         	str	r0, [r1, #0x54]
;             status = UART_writePolling(hUart, trans);
700a6940: 9805         	ldr	r0, [sp, #0x14]
700a6942: 9900         	ldr	r1, [sp]
700a6944: f7fc fb04    	bl	0x700a2f50 <UART_writePolling> @ imm = #-0x39f8
700a6948: 9001         	str	r0, [sp, #0x4]
;             hUart->state = UART_STATE_READY;
700a694a: 9905         	ldr	r1, [sp, #0x14]
700a694c: 2001         	movs	r0, #0x1
700a694e: 6548         	str	r0, [r1, #0x54]
700a6950: e7ff         	b	0x700a6952 <UART_lld_write+0xc2> @ imm = #-0x2
;     }
700a6952: e003         	b	0x700a695c <UART_lld_write+0xcc> @ imm = #0x6
700a6954: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a6958: 9001         	str	r0, [sp, #0x4]
700a695a: e7ff         	b	0x700a695c <UART_lld_write+0xcc> @ imm = #-0x2
;     return status;
700a695c: 9801         	ldr	r0, [sp, #0x4]
700a695e: b006         	add	sp, #0x18
700a6960: bd80         	pop	{r7, pc}
		...
700a696e: 0000         	movs	r0, r0

700a6970 <UART_udmaDeInitCh>:
; {
700a6970: b580         	push	{r7, lr}
700a6972: b08c         	sub	sp, #0x30
700a6974: 900b         	str	r0, [sp, #0x2c]
700a6976: 910a         	str	r1, [sp, #0x28]
700a6978: 2000         	movs	r0, #0x0
;     int32_t status = UDMA_SOK;
700a697a: 9009         	str	r0, [sp, #0x24]
700a697c: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a697e: 9008         	str	r0, [sp, #0x20]
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a6980: 980b         	ldr	r0, [sp, #0x2c]
700a6982: 2164         	movs	r1, #0x64
700a6984: f001 fbe4    	bl	0x700a8150 <Udma_chDisable> @ imm = #0x17c8
700a6988: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a698a: 9809         	ldr	r0, [sp, #0x24]
700a698c: fab0 f080    	clz	r0, r0
700a6990: 0940         	lsrs	r0, r0, #0x5
700a6992: f641 71bb    	movw	r1, #0x1fbb
700a6996: f2c7 010b    	movt	r1, #0x700b
700a699a: 9102         	str	r1, [sp, #0x8]
700a699c: 466a         	mov	r2, sp
700a699e: 6011         	str	r1, [r2]
700a69a0: f641 316c    	movw	r1, #0x1b6c
700a69a4: f2c7 010b    	movt	r1, #0x700b
700a69a8: 9103         	str	r1, [sp, #0xc]
700a69aa: f242 0205    	movw	r2, #0x2005
700a69ae: f2c7 020b    	movt	r2, #0x700b
700a69b2: 9204         	str	r2, [sp, #0x10]
700a69b4: f240 134b    	movw	r3, #0x14b
700a69b8: f004 f962    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x42c4
;     status = Udma_eventUnRegister(eventHandle);
700a69bc: 980a         	ldr	r0, [sp, #0x28]
700a69be: f000 fc5f    	bl	0x700a7280 <Udma_eventUnRegister> @ imm = #0x8be
700a69c2: 9b02         	ldr	r3, [sp, #0x8]
700a69c4: 9903         	ldr	r1, [sp, #0xc]
700a69c6: 9a04         	ldr	r2, [sp, #0x10]
700a69c8: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a69ca: 9809         	ldr	r0, [sp, #0x24]
700a69cc: fab0 f080    	clz	r0, r0
700a69d0: 0940         	lsrs	r0, r0, #0x5
700a69d2: 46ec         	mov	r12, sp
700a69d4: f8cc 3000    	str.w	r3, [r12]
700a69d8: f240 134f    	movw	r3, #0x14f
700a69dc: f004 f950    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x42a0
;     while(temp == TRUE)
700a69e0: e7ff         	b	0x700a69e2 <UART_udmaDeInitCh+0x72> @ imm = #-0x2
700a69e2: 9808         	ldr	r0, [sp, #0x20]
700a69e4: 2801         	cmp	r0, #0x1
700a69e6: d10f         	bne	0x700a6a08 <UART_udmaDeInitCh+0x98> @ imm = #0x1e
700a69e8: e7ff         	b	0x700a69ea <UART_udmaDeInitCh+0x7a> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a69ea: 980b         	ldr	r0, [sp, #0x2c]
700a69ec: f004 fb48    	bl	0x700ab080 <Udma_chGetFqRingHandle> @ imm = #0x4690
700a69f0: a906         	add	r1, sp, #0x18
;         tempRetVal = Udma_ringFlushRaw(
700a69f2: f003 fbd5    	bl	0x700aa1a0 <Udma_ringFlushRaw> @ imm = #0x37aa
700a69f6: 9005         	str	r0, [sp, #0x14]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a69f8: 9805         	ldr	r0, [sp, #0x14]
700a69fa: 3004         	adds	r0, #0x4
700a69fc: b918         	cbnz	r0, 0x700a6a06 <UART_udmaDeInitCh+0x96> @ imm = #0x6
700a69fe: e7ff         	b	0x700a6a00 <UART_udmaDeInitCh+0x90> @ imm = #-0x2
700a6a00: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a6a02: 9008         	str	r0, [sp, #0x20]
;         }
700a6a04: e7ff         	b	0x700a6a06 <UART_udmaDeInitCh+0x96> @ imm = #-0x2
;     while(temp == TRUE)
700a6a06: e7ec         	b	0x700a69e2 <UART_udmaDeInitCh+0x72> @ imm = #-0x28
;     status = Udma_chClose(chHandle);
700a6a08: 980b         	ldr	r0, [sp, #0x2c]
700a6a0a: f000 fd71    	bl	0x700a74f0 <Udma_chClose> @ imm = #0xae2
700a6a0e: 9009         	str	r0, [sp, #0x24]
;     DebugP_assert(UDMA_SOK == status);
700a6a10: 9809         	ldr	r0, [sp, #0x24]
700a6a12: fab0 f080    	clz	r0, r0
700a6a16: 0940         	lsrs	r0, r0, #0x5
700a6a18: f641 71bb    	movw	r1, #0x1fbb
700a6a1c: f2c7 010b    	movt	r1, #0x700b
700a6a20: 466a         	mov	r2, sp
700a6a22: 6011         	str	r1, [r2]
700a6a24: f641 316c    	movw	r1, #0x1b6c
700a6a28: f2c7 010b    	movt	r1, #0x700b
700a6a2c: f242 0205    	movw	r2, #0x2005
700a6a30: f2c7 020b    	movt	r2, #0x700b
700a6a34: f240 1361    	movw	r3, #0x161
700a6a38: f004 f922    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x4244
;     return status;
700a6a3c: 9809         	ldr	r0, [sp, #0x24]
700a6a3e: b00c         	add	sp, #0x30
700a6a40: bd80         	pop	{r7, pc}
		...
700a6a4e: 0000         	movs	r0, r0

700a6a50 <vTaskSwitchContext>:
; void vTaskSwitchContext(void) {
700a6a50: b082         	sub	sp, #0x8
;   if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
700a6a52: f642 2024    	movw	r0, #0x2a24
700a6a56: f2c7 000b    	movt	r0, #0x700b
700a6a5a: 6800         	ldr	r0, [r0]
700a6a5c: b138         	cbz	r0, 0x700a6a6e <vTaskSwitchContext+0x1e> @ imm = #0xe
700a6a5e: e7ff         	b	0x700a6a60 <vTaskSwitchContext+0x10> @ imm = #-0x2
;     xYieldPending = pdTRUE;
700a6a60: f642 2150    	movw	r1, #0x2a50
700a6a64: f2c7 010b    	movt	r1, #0x700b
700a6a68: 2001         	movs	r0, #0x1
700a6a6a: 6008         	str	r0, [r1]
;   } else {
700a6a6c: e057         	b	0x700a6b1e <vTaskSwitchContext+0xce> @ imm = #0xae
;     xYieldPending = pdFALSE;
700a6a6e: f642 2150    	movw	r1, #0x2a50
700a6a72: f2c7 010b    	movt	r1, #0x700b
700a6a76: 2000         	movs	r0, #0x0
700a6a78: 6008         	str	r0, [r1]
;       pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
700a6a7a: f642 10ac    	movw	r0, #0x29ac
700a6a7e: f2c7 000b    	movt	r0, #0x700b
700a6a82: 6800         	ldr	r0, [r0]
700a6a84: f642 11fc    	movw	r1, #0x29fc
700a6a88: f2c7 010b    	movt	r1, #0x700b
700a6a8c: 6809         	ldr	r1, [r1]
700a6a8e: f8c1 0084    	str.w	r0, [r1, #0x84]
;     taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this
700a6a92: f642 202c    	movw	r0, #0x2a2c
700a6a96: f2c7 000b    	movt	r0, #0x700b
700a6a9a: 6800         	ldr	r0, [r0]
700a6a9c: 9001         	str	r0, [sp, #0x4]
700a6a9e: e7ff         	b	0x700a6aa0 <vTaskSwitchContext+0x50> @ imm = #-0x2
700a6aa0: 9801         	ldr	r0, [sp, #0x4]
700a6aa2: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a6aa6: f244 40f8    	movw	r0, #0x44f8
700a6aaa: f2c7 0008    	movt	r0, #0x7008
700a6aae: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700a6ab2: b920         	cbnz	r0, 0x700a6abe <vTaskSwitchContext+0x6e> @ imm = #0x8
700a6ab4: e7ff         	b	0x700a6ab6 <vTaskSwitchContext+0x66> @ imm = #-0x2
700a6ab6: 9801         	ldr	r0, [sp, #0x4]
700a6ab8: 3801         	subs	r0, #0x1
700a6aba: 9001         	str	r0, [sp, #0x4]
700a6abc: e7f0         	b	0x700a6aa0 <vTaskSwitchContext+0x50> @ imm = #-0x20
700a6abe: 9801         	ldr	r0, [sp, #0x4]
700a6ac0: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a6ac4: f244 40f8    	movw	r0, #0x44f8
700a6ac8: f2c7 0008    	movt	r0, #0x7008
700a6acc: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a6ad0: 9000         	str	r0, [sp]
700a6ad2: 9900         	ldr	r1, [sp]
700a6ad4: 6848         	ldr	r0, [r1, #0x4]
700a6ad6: 6840         	ldr	r0, [r0, #0x4]
700a6ad8: 6048         	str	r0, [r1, #0x4]
700a6ada: 9900         	ldr	r1, [sp]
700a6adc: 6848         	ldr	r0, [r1, #0x4]
700a6ade: 3108         	adds	r1, #0x8
700a6ae0: 4288         	cmp	r0, r1
700a6ae2: d105         	bne	0x700a6af0 <vTaskSwitchContext+0xa0> @ imm = #0xa
700a6ae4: e7ff         	b	0x700a6ae6 <vTaskSwitchContext+0x96> @ imm = #-0x2
700a6ae6: 9900         	ldr	r1, [sp]
700a6ae8: 6848         	ldr	r0, [r1, #0x4]
700a6aea: 6840         	ldr	r0, [r0, #0x4]
700a6aec: 6048         	str	r0, [r1, #0x4]
700a6aee: e7ff         	b	0x700a6af0 <vTaskSwitchContext+0xa0> @ imm = #-0x2
700a6af0: 9800         	ldr	r0, [sp]
700a6af2: 6840         	ldr	r0, [r0, #0x4]
700a6af4: 68c1         	ldr	r1, [r0, #0xc]
700a6af6: f642 10fc    	movw	r0, #0x29fc
700a6afa: f2c7 000b    	movt	r0, #0x700b
700a6afe: 6001         	str	r1, [r0]
700a6b00: 9901         	ldr	r1, [sp, #0x4]
700a6b02: f642 222c    	movw	r2, #0x2a2c
700a6b06: f2c7 020b    	movt	r2, #0x700b
700a6b0a: 6011         	str	r1, [r2]
;       FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
700a6b0c: 6800         	ldr	r0, [r0]
700a6b0e: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a6b12: f642 11ac    	movw	r1, #0x29ac
700a6b16: f2c7 010b    	movt	r1, #0x700b
700a6b1a: 6008         	str	r0, [r1]
700a6b1c: e7ff         	b	0x700a6b1e <vTaskSwitchContext+0xce> @ imm = #-0x2
; }
700a6b1e: b002         	add	sp, #0x8
700a6b20: 4770         	bx	lr
		...
700a6b2e: 0000         	movs	r0, r0

700a6b30 <Udma_rmAllocVintrBit>:
; {
700a6b30: b580         	push	{r7, lr}
700a6b32: b08a         	sub	sp, #0x28
700a6b34: 9009         	str	r0, [sp, #0x24]
700a6b36: f64f 70ff    	movw	r0, #0xffff
;     uint32_t                vintrBitNum = UDMA_EVENT_INVALID;
700a6b3a: 9007         	str	r0, [sp, #0x1c]
;     Udma_DrvHandleInt       drvHandle = eventHandle->drvHandle;
700a6b3c: 9809         	ldr	r0, [sp, #0x24]
700a6b3e: 6800         	ldr	r0, [r0]
700a6b40: 9001         	str	r0, [sp, #0x4]
;     controllerEventHandle = eventHandle;
700a6b42: 9809         	ldr	r0, [sp, #0x24]
700a6b44: 9003         	str	r0, [sp, #0xc]
;     eventPrms = &eventHandle->eventPrms;
700a6b46: 9809         	ldr	r0, [sp, #0x24]
700a6b48: 3008         	adds	r0, #0x8
700a6b4a: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700a6b4c: 9802         	ldr	r0, [sp, #0x8]
700a6b4e: 6900         	ldr	r0, [r0, #0x10]
700a6b50: b120         	cbz	r0, 0x700a6b5c <Udma_rmAllocVintrBit+0x2c> @ imm = #0x8
700a6b52: e7ff         	b	0x700a6b54 <Udma_rmAllocVintrBit+0x24> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700a6b54: 9802         	ldr	r0, [sp, #0x8]
700a6b56: 6900         	ldr	r0, [r0, #0x10]
700a6b58: 9003         	str	r0, [sp, #0xc]
;     }
700a6b5a: e7ff         	b	0x700a6b5c <Udma_rmAllocVintrBit+0x2c> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a6b5c: 9801         	ldr	r0, [sp, #0x4]
700a6b5e: f500 609f    	add.w	r0, r0, #0x4f8
700a6b62: f04f 31ff    	mov.w	r1, #0xffffffff
700a6b66: f003 fe33    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x3c66
700a6b6a: 2000         	movs	r0, #0x0
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a6b6c: 9008         	str	r0, [sp, #0x20]
700a6b6e: e7ff         	b	0x700a6b70 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x2
700a6b70: 9808         	ldr	r0, [sp, #0x20]
700a6b72: 283f         	cmp	r0, #0x3f
700a6b74: d83a         	bhi	0x700a6bec <Udma_rmAllocVintrBit+0xbc> @ imm = #0x74
700a6b76: e7ff         	b	0x700a6b78 <Udma_rmAllocVintrBit+0x48> @ imm = #-0x2
;         bitMask = ((uint64_t) 1U << i);
700a6b78: 9b08         	ldr	r3, [sp, #0x20]
700a6b7a: f1a3 0220    	sub.w	r2, r3, #0x20
700a6b7e: 2101         	movs	r1, #0x1
700a6b80: fa01 fc02    	lsl.w	r12, r1, r2
700a6b84: f1c3 0020    	rsb.w	r0, r3, #0x20
700a6b88: fa21 f000    	lsr.w	r0, r1, r0
700a6b8c: 2a00         	cmp	r2, #0x0
700a6b8e: bf58         	it	pl
700a6b90: 4660         	movpl	r0, r12
700a6b92: fa01 f103    	lsl.w	r1, r1, r3
700a6b96: 2a00         	cmp	r2, #0x0
700a6b98: bf58         	it	pl
700a6b9a: 2100         	movpl	r1, #0x0
700a6b9c: 9104         	str	r1, [sp, #0x10]
700a6b9e: 9005         	str	r0, [sp, #0x14]
;         if((controllerEventHandle->vintrBitAllocFlag & bitMask) == 0U)
700a6ba0: 9903         	ldr	r1, [sp, #0xc]
700a6ba2: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a6ba6: f8d1 108c    	ldr.w	r1, [r1, #0x8c]
700a6baa: 9a04         	ldr	r2, [sp, #0x10]
700a6bac: 9b05         	ldr	r3, [sp, #0x14]
700a6bae: ea01 0103    	and.w	r1, r1, r3
700a6bb2: ea00 0002    	and.w	r0, r0, r2
700a6bb6: ea40 0001    	orr.w	r0, r0, r1
700a6bba: b990         	cbnz	r0, 0x700a6be2 <Udma_rmAllocVintrBit+0xb2> @ imm = #0x24
700a6bbc: e7ff         	b	0x700a6bbe <Udma_rmAllocVintrBit+0x8e> @ imm = #-0x2
;             controllerEventHandle->vintrBitAllocFlag |= bitMask;
700a6bbe: f8dd c010    	ldr.w	r12, [sp, #0x10]
700a6bc2: 9b05         	ldr	r3, [sp, #0x14]
700a6bc4: 9903         	ldr	r1, [sp, #0xc]
700a6bc6: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700a6bca: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700a6bce: ea40 000c    	orr.w	r0, r0, r12
700a6bd2: 431a         	orrs	r2, r3
700a6bd4: f8c1 208c    	str.w	r2, [r1, #0x8c]
700a6bd8: f8c1 0088    	str.w	r0, [r1, #0x88]
;             vintrBitNum = i;
700a6bdc: 9808         	ldr	r0, [sp, #0x20]
700a6bde: 9007         	str	r0, [sp, #0x1c]
;             break;
700a6be0: e004         	b	0x700a6bec <Udma_rmAllocVintrBit+0xbc> @ imm = #0x8
;     }
700a6be2: e7ff         	b	0x700a6be4 <Udma_rmAllocVintrBit+0xb4> @ imm = #-0x2
;     for(i = 0U; i < UDMA_MAX_EVENTS_PER_VINTR; i++)
700a6be4: 9808         	ldr	r0, [sp, #0x20]
700a6be6: 3001         	adds	r0, #0x1
700a6be8: 9008         	str	r0, [sp, #0x20]
700a6bea: e7c1         	b	0x700a6b70 <Udma_rmAllocVintrBit+0x40> @ imm = #-0x7e
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a6bec: 9801         	ldr	r0, [sp, #0x4]
700a6bee: f500 609f    	add.w	r0, r0, #0x4f8
700a6bf2: f005 f97d    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x52fa
;     return (vintrBitNum);
700a6bf6: 9807         	ldr	r0, [sp, #0x1c]
700a6bf8: b00a         	add	sp, #0x28
700a6bfa: bd80         	pop	{r7, pc}
700a6bfc: 0000         	movs	r0, r0
700a6bfe: 0000         	movs	r0, r0

700a6c00 <prvCopyDataToQueue>:
; {
700a6c00: b580         	push	{r7, lr}
700a6c02: b086         	sub	sp, #0x18
700a6c04: 9005         	str	r0, [sp, #0x14]
700a6c06: 9104         	str	r1, [sp, #0x10]
700a6c08: 9203         	str	r2, [sp, #0xc]
700a6c0a: 2000         	movs	r0, #0x0
;     BaseType_t xReturn = pdFALSE;
700a6c0c: 9002         	str	r0, [sp, #0x8]
;     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a6c0e: 9805         	ldr	r0, [sp, #0x14]
700a6c10: 6b80         	ldr	r0, [r0, #0x38]
700a6c12: 9001         	str	r0, [sp, #0x4]
;     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
700a6c14: 9805         	ldr	r0, [sp, #0x14]
700a6c16: 6c00         	ldr	r0, [r0, #0x40]
700a6c18: b978         	cbnz	r0, 0x700a6c3a <prvCopyDataToQueue+0x3a> @ imm = #0x1e
700a6c1a: e7ff         	b	0x700a6c1c <prvCopyDataToQueue+0x1c> @ imm = #-0x2
;                 if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
700a6c1c: 9805         	ldr	r0, [sp, #0x14]
700a6c1e: 6800         	ldr	r0, [r0]
700a6c20: b948         	cbnz	r0, 0x700a6c36 <prvCopyDataToQueue+0x36> @ imm = #0x12
700a6c22: e7ff         	b	0x700a6c24 <prvCopyDataToQueue+0x24> @ imm = #-0x2
;                     xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
700a6c24: 9805         	ldr	r0, [sp, #0x14]
700a6c26: 6880         	ldr	r0, [r0, #0x8]
700a6c28: f001 fcfa    	bl	0x700a8620 <xTaskPriorityDisinherit> @ imm = #0x19f4
700a6c2c: 9002         	str	r0, [sp, #0x8]
;                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
700a6c2e: 9905         	ldr	r1, [sp, #0x14]
700a6c30: 2000         	movs	r0, #0x0
700a6c32: 6088         	str	r0, [r1, #0x8]
;                 }
700a6c34: e000         	b	0x700a6c38 <prvCopyDataToQueue+0x38> @ imm = #0x0
700a6c36: e7ff         	b	0x700a6c38 <prvCopyDataToQueue+0x38> @ imm = #-0x2
;     }
700a6c38: e041         	b	0x700a6cbe <prvCopyDataToQueue+0xbe> @ imm = #0x82
;     else if( xPosition == queueSEND_TO_BACK )
700a6c3a: 9803         	ldr	r0, [sp, #0xc]
700a6c3c: b9b8         	cbnz	r0, 0x700a6c6e <prvCopyDataToQueue+0x6e> @ imm = #0x2e
700a6c3e: e7ff         	b	0x700a6c40 <prvCopyDataToQueue+0x40> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700a6c40: 9a05         	ldr	r2, [sp, #0x14]
700a6c42: 9904         	ldr	r1, [sp, #0x10]
700a6c44: 6850         	ldr	r0, [r2, #0x4]
700a6c46: 6c12         	ldr	r2, [r2, #0x40]
700a6c48: f7f3 ea48    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0xcb70
;         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700a6c4c: 9905         	ldr	r1, [sp, #0x14]
700a6c4e: 6848         	ldr	r0, [r1, #0x4]
700a6c50: 6c0a         	ldr	r2, [r1, #0x40]
700a6c52: 4410         	add	r0, r2
700a6c54: 6048         	str	r0, [r1, #0x4]
;         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a6c56: 9905         	ldr	r1, [sp, #0x14]
700a6c58: 6848         	ldr	r0, [r1, #0x4]
700a6c5a: 6889         	ldr	r1, [r1, #0x8]
700a6c5c: 4288         	cmp	r0, r1
700a6c5e: d304         	blo	0x700a6c6a <prvCopyDataToQueue+0x6a> @ imm = #0x8
700a6c60: e7ff         	b	0x700a6c62 <prvCopyDataToQueue+0x62> @ imm = #-0x2
;             pxQueue->pcWriteTo = pxQueue->pcHead;
700a6c62: 9905         	ldr	r1, [sp, #0x14]
700a6c64: 6808         	ldr	r0, [r1]
700a6c66: 6048         	str	r0, [r1, #0x4]
;         }
700a6c68: e000         	b	0x700a6c6c <prvCopyDataToQueue+0x6c> @ imm = #0x0
700a6c6a: e7ff         	b	0x700a6c6c <prvCopyDataToQueue+0x6c> @ imm = #-0x2
;     }
700a6c6c: e026         	b	0x700a6cbc <prvCopyDataToQueue+0xbc> @ imm = #0x4c
;         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
700a6c6e: 9a05         	ldr	r2, [sp, #0x14]
700a6c70: 9904         	ldr	r1, [sp, #0x10]
700a6c72: 68d0         	ldr	r0, [r2, #0xc]
700a6c74: 6c12         	ldr	r2, [r2, #0x40]
700a6c76: f7f3 ea32    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0xcb9c
;         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
700a6c7a: 9905         	ldr	r1, [sp, #0x14]
700a6c7c: 68c8         	ldr	r0, [r1, #0xc]
700a6c7e: 6c0a         	ldr	r2, [r1, #0x40]
700a6c80: 1a80         	subs	r0, r0, r2
700a6c82: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
700a6c84: 9805         	ldr	r0, [sp, #0x14]
700a6c86: 6801         	ldr	r1, [r0]
700a6c88: 68c0         	ldr	r0, [r0, #0xc]
700a6c8a: 4288         	cmp	r0, r1
700a6c8c: d206         	bhs	0x700a6c9c <prvCopyDataToQueue+0x9c> @ imm = #0xc
700a6c8e: e7ff         	b	0x700a6c90 <prvCopyDataToQueue+0x90> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
700a6c90: 9905         	ldr	r1, [sp, #0x14]
700a6c92: 6888         	ldr	r0, [r1, #0x8]
700a6c94: 6c0a         	ldr	r2, [r1, #0x40]
700a6c96: 1a80         	subs	r0, r0, r2
700a6c98: 60c8         	str	r0, [r1, #0xc]
;         }
700a6c9a: e000         	b	0x700a6c9e <prvCopyDataToQueue+0x9e> @ imm = #0x0
700a6c9c: e7ff         	b	0x700a6c9e <prvCopyDataToQueue+0x9e> @ imm = #-0x2
;         if( xPosition == queueOVERWRITE )
700a6c9e: 9803         	ldr	r0, [sp, #0xc]
700a6ca0: 2802         	cmp	r0, #0x2
700a6ca2: d109         	bne	0x700a6cb8 <prvCopyDataToQueue+0xb8> @ imm = #0x12
700a6ca4: e7ff         	b	0x700a6ca6 <prvCopyDataToQueue+0xa6> @ imm = #-0x2
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a6ca6: 9801         	ldr	r0, [sp, #0x4]
700a6ca8: b120         	cbz	r0, 0x700a6cb4 <prvCopyDataToQueue+0xb4> @ imm = #0x8
700a6caa: e7ff         	b	0x700a6cac <prvCopyDataToQueue+0xac> @ imm = #-0x2
;                 --uxMessagesWaiting;
700a6cac: 9801         	ldr	r0, [sp, #0x4]
700a6cae: 3801         	subs	r0, #0x1
700a6cb0: 9001         	str	r0, [sp, #0x4]
;             }
700a6cb2: e000         	b	0x700a6cb6 <prvCopyDataToQueue+0xb6> @ imm = #0x0
700a6cb4: e7ff         	b	0x700a6cb6 <prvCopyDataToQueue+0xb6> @ imm = #-0x2
;         }
700a6cb6: e000         	b	0x700a6cba <prvCopyDataToQueue+0xba> @ imm = #0x0
700a6cb8: e7ff         	b	0x700a6cba <prvCopyDataToQueue+0xba> @ imm = #-0x2
700a6cba: e7ff         	b	0x700a6cbc <prvCopyDataToQueue+0xbc> @ imm = #-0x2
700a6cbc: e7ff         	b	0x700a6cbe <prvCopyDataToQueue+0xbe> @ imm = #-0x2
;     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a6cbe: 9801         	ldr	r0, [sp, #0x4]
700a6cc0: 3001         	adds	r0, #0x1
700a6cc2: 9905         	ldr	r1, [sp, #0x14]
700a6cc4: 6388         	str	r0, [r1, #0x38]
;     return xReturn;
700a6cc6: 9802         	ldr	r0, [sp, #0x8]
700a6cc8: b006         	add	sp, #0x18
700a6cca: bd80         	pop	{r7, pc}
700a6ccc: 0000         	movs	r0, r0
700a6cce: 0000         	movs	r0, r0

700a6cd0 <CSL_bcdmaChanOpSetBurstSize>:
; {
700a6cd0: b580         	push	{r7, lr}
700a6cd2: b088         	sub	sp, #0x20
700a6cd4: 9007         	str	r0, [sp, #0x1c]
700a6cd6: 9106         	str	r1, [sp, #0x18]
700a6cd8: 9205         	str	r2, [sp, #0x14]
700a6cda: 9304         	str	r3, [sp, #0x10]
700a6cdc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a6cde: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a6ce0: 9804         	ldr	r0, [sp, #0x10]
700a6ce2: b920         	cbnz	r0, 0x700a6cee <CSL_bcdmaChanOpSetBurstSize+0x1e> @ imm = #0x8
700a6ce4: e7ff         	b	0x700a6ce6 <CSL_bcdmaChanOpSetBurstSize+0x16> @ imm = #-0x2
700a6ce6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a6cea: 9003         	str	r0, [sp, #0xc]
;     }
700a6cec: e052         	b	0x700a6d94 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #0xa4
;         CSL_BcdmaChanBurstSize burstSize = *(CSL_BcdmaChanBurstSize *)pOpData;
700a6cee: 9804         	ldr	r0, [sp, #0x10]
700a6cf0: 6800         	ldr	r0, [r0]
700a6cf2: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a6cf4: 9806         	ldr	r0, [sp, #0x18]
700a6cf6: 9001         	str	r0, [sp, #0x4]
700a6cf8: b140         	cbz	r0, 0x700a6d0c <CSL_bcdmaChanOpSetBurstSize+0x3c> @ imm = #0x10
700a6cfa: e7ff         	b	0x700a6cfc <CSL_bcdmaChanOpSetBurstSize+0x2c> @ imm = #-0x2
700a6cfc: 9801         	ldr	r0, [sp, #0x4]
700a6cfe: 2801         	cmp	r0, #0x1
700a6d00: d019         	beq	0x700a6d36 <CSL_bcdmaChanOpSetBurstSize+0x66> @ imm = #0x32
700a6d02: e7ff         	b	0x700a6d04 <CSL_bcdmaChanOpSetBurstSize+0x34> @ imm = #-0x2
700a6d04: 9801         	ldr	r0, [sp, #0x4]
700a6d06: 2802         	cmp	r0, #0x2
700a6d08: d02a         	beq	0x700a6d60 <CSL_bcdmaChanOpSetBurstSize+0x90> @ imm = #0x54
700a6d0a: e03e         	b	0x700a6d8a <CSL_bcdmaChanOpSetBurstSize+0xba> @ imm = #0x7c
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_128_BYTES )   /* Block-copy supports 32, 64, and 128-byte bursts */
700a6d0c: 9802         	ldr	r0, [sp, #0x8]
700a6d0e: 2803         	cmp	r0, #0x3
700a6d10: d304         	blo	0x700a6d1c <CSL_bcdmaChanOpSetBurstSize+0x4c> @ imm = #0x8
700a6d12: e7ff         	b	0x700a6d14 <CSL_bcdmaChanOpSetBurstSize+0x44> @ imm = #-0x2
700a6d14: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6d18: 9003         	str	r0, [sp, #0xc]
;                 }
700a6d1a: e00b         	b	0x700a6d34 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pBcChanCfgRegs->CHAN[chanIdx].CFG, BCDMA_BCCFG_CHAN_CFG_BURST_SIZE, burstSize );
700a6d1c: 9807         	ldr	r0, [sp, #0x1c]
700a6d1e: 6840         	ldr	r0, [r0, #0x4]
700a6d20: 9905         	ldr	r1, [sp, #0x14]
700a6d22: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6d26: 9b02         	ldr	r3, [sp, #0x8]
700a6d28: f44f 6140    	mov.w	r1, #0xc00
700a6d2c: 220a         	movs	r2, #0xa
700a6d2e: f007 fac7    	bl	0x700ae2c0 <CSL_REG32_FINS_RAW> @ imm = #0x758e
700a6d32: e7ff         	b	0x700a6d34 <CSL_bcdmaChanOpSetBurstSize+0x64> @ imm = #-0x2
;                 break;
700a6d34: e02d         	b	0x700a6d92 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x5a
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-tx supports 32, and 64-byte bursts */
700a6d36: 9802         	ldr	r0, [sp, #0x8]
700a6d38: 2802         	cmp	r0, #0x2
700a6d3a: d304         	blo	0x700a6d46 <CSL_bcdmaChanOpSetBurstSize+0x76> @ imm = #0x8
700a6d3c: e7ff         	b	0x700a6d3e <CSL_bcdmaChanOpSetBurstSize+0x6e> @ imm = #-0x2
700a6d3e: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6d42: 9003         	str	r0, [sp, #0xc]
;                 }
700a6d44: e00b         	b	0x700a6d5e <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pTxChanCfgRegs->CHAN[chanIdx].TCFG, BCDMA_TXCCFG_CHAN_TCFG_BURST_SIZE, burstSize );
700a6d46: 9807         	ldr	r0, [sp, #0x1c]
700a6d48: 68c0         	ldr	r0, [r0, #0xc]
700a6d4a: 9905         	ldr	r1, [sp, #0x14]
700a6d4c: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6d50: 9b02         	ldr	r3, [sp, #0x8]
700a6d52: f44f 6140    	mov.w	r1, #0xc00
700a6d56: 220a         	movs	r2, #0xa
700a6d58: f007 fab2    	bl	0x700ae2c0 <CSL_REG32_FINS_RAW> @ imm = #0x7564
700a6d5c: e7ff         	b	0x700a6d5e <CSL_bcdmaChanOpSetBurstSize+0x8e> @ imm = #-0x2
;                 break;
700a6d5e: e018         	b	0x700a6d92 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x30
;                 if( burstSize > CSL_BCDMA_CHAN_BURST_SIZE_64_BYTES )    /* Split-rx supports 32, and 64-byte bursts */
700a6d60: 9802         	ldr	r0, [sp, #0x8]
700a6d62: 2802         	cmp	r0, #0x2
700a6d64: d304         	blo	0x700a6d70 <CSL_bcdmaChanOpSetBurstSize+0xa0> @ imm = #0x8
700a6d66: e7ff         	b	0x700a6d68 <CSL_bcdmaChanOpSetBurstSize+0x98> @ imm = #-0x2
700a6d68: f06f 0002    	mvn	r0, #0x2
;                     retVal = CSL_EINVALID_PARAMS;
700a6d6c: 9003         	str	r0, [sp, #0xc]
;                 }
700a6d6e: e00b         	b	0x700a6d88 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #0x16
;                     CSL_REG32_FINS( &pCfg->pRxChanCfgRegs->CHAN[chanIdx].RCFG, BCDMA_RXCCFG_CHAN_RCFG_BURST_SIZE, burstSize );
700a6d70: 9807         	ldr	r0, [sp, #0x1c]
700a6d72: 6940         	ldr	r0, [r0, #0x14]
700a6d74: 9905         	ldr	r1, [sp, #0x14]
700a6d76: eb00 2001    	add.w	r0, r0, r1, lsl #8
700a6d7a: 9b02         	ldr	r3, [sp, #0x8]
700a6d7c: f44f 6140    	mov.w	r1, #0xc00
700a6d80: 220a         	movs	r2, #0xa
700a6d82: f007 fa9d    	bl	0x700ae2c0 <CSL_REG32_FINS_RAW> @ imm = #0x753a
700a6d86: e7ff         	b	0x700a6d88 <CSL_bcdmaChanOpSetBurstSize+0xb8> @ imm = #-0x2
;                 break;
700a6d88: e003         	b	0x700a6d92 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #0x6
700a6d8a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a6d8e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a6d90: e7ff         	b	0x700a6d92 <CSL_bcdmaChanOpSetBurstSize+0xc2> @ imm = #-0x2
700a6d92: e7ff         	b	0x700a6d94 <CSL_bcdmaChanOpSetBurstSize+0xc4> @ imm = #-0x2
;     return retVal;
700a6d94: 9803         	ldr	r0, [sp, #0xc]
700a6d96: b008         	add	sp, #0x20
700a6d98: bd80         	pop	{r7, pc}
700a6d9a: 0000         	movs	r0, r0
700a6d9c: 0000         	movs	r0, r0
700a6d9e: 0000         	movs	r0, r0

700a6da0 <Udma_ringCheckParams>:
; {
700a6da0: b580         	push	{r7, lr}
700a6da2: b084         	sub	sp, #0x10
700a6da4: 9003         	str	r0, [sp, #0xc]
700a6da6: 9102         	str	r1, [sp, #0x8]
700a6da8: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a6daa: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR == ringPrms->ringMem)
700a6dac: 9802         	ldr	r0, [sp, #0x8]
700a6dae: 6800         	ldr	r0, [r0]
700a6db0: b920         	cbnz	r0, 0x700a6dbc <Udma_ringCheckParams+0x1c> @ imm = #0x8
700a6db2: e7ff         	b	0x700a6db4 <Udma_ringCheckParams+0x14> @ imm = #-0x2
700a6db4: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6db8: 9001         	str	r0, [sp, #0x4]
;     }
700a6dba: e009         	b	0x700a6dd0 <Udma_ringCheckParams+0x30> @ imm = #0x12
;         if(((uintptr_t)ringPrms->ringMem & (UDMA_CACHELINE_ALIGNMENT - 1U)) != 0U)
700a6dbc: 9802         	ldr	r0, [sp, #0x8]
700a6dbe: 7800         	ldrb	r0, [r0]
700a6dc0: 0640         	lsls	r0, r0, #0x19
700a6dc2: b120         	cbz	r0, 0x700a6dce <Udma_ringCheckParams+0x2e> @ imm = #0x8
700a6dc4: e7ff         	b	0x700a6dc6 <Udma_ringCheckParams+0x26> @ imm = #-0x2
700a6dc6: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a6dca: 9001         	str	r0, [sp, #0x4]
;         }
700a6dcc: e7ff         	b	0x700a6dce <Udma_ringCheckParams+0x2e> @ imm = #-0x2
700a6dce: e7ff         	b	0x700a6dd0 <Udma_ringCheckParams+0x30> @ imm = #-0x2
;     if(0U == ringPrms->elemCnt)
700a6dd0: 9802         	ldr	r0, [sp, #0x8]
700a6dd2: 68c0         	ldr	r0, [r0, #0xc]
700a6dd4: b920         	cbnz	r0, 0x700a6de0 <Udma_ringCheckParams+0x40> @ imm = #0x8
700a6dd6: e7ff         	b	0x700a6dd8 <Udma_ringCheckParams+0x38> @ imm = #-0x2
700a6dd8: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6ddc: 9001         	str	r0, [sp, #0x4]
;     }
700a6dde: e7ff         	b	0x700a6de0 <Udma_ringCheckParams+0x40> @ imm = #-0x2
;     if(UDMA_INST_TYPE_NORMAL != drvHandle->instType)
700a6de0: 9803         	ldr	r0, [sp, #0xc]
700a6de2: 6800         	ldr	r0, [r0]
700a6de4: b148         	cbz	r0, 0x700a6dfa <Udma_ringCheckParams+0x5a> @ imm = #0x12
700a6de6: e7ff         	b	0x700a6de8 <Udma_ringCheckParams+0x48> @ imm = #-0x2
;         if(TISCI_MSG_VALUE_RM_RING_MODE_RING != ringPrms->mode)
700a6de8: 9802         	ldr	r0, [sp, #0x8]
700a6dea: 7a00         	ldrb	r0, [r0, #0x8]
700a6dec: b120         	cbz	r0, 0x700a6df8 <Udma_ringCheckParams+0x58> @ imm = #0x8
700a6dee: e7ff         	b	0x700a6df0 <Udma_ringCheckParams+0x50> @ imm = #-0x2
700a6df0: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a6df4: 9001         	str	r0, [sp, #0x4]
;         }
700a6df6: e7ff         	b	0x700a6df8 <Udma_ringCheckParams+0x58> @ imm = #-0x2
;     }
700a6df8: e7ff         	b	0x700a6dfa <Udma_ringCheckParams+0x5a> @ imm = #-0x2
;     if(UDMA_RING_SIZE_CHECK_SKIP != ringPrms->ringMemSize)
700a6dfa: 9802         	ldr	r0, [sp, #0x8]
700a6dfc: 6840         	ldr	r0, [r0, #0x4]
700a6dfe: f64a 31cd    	movw	r1, #0xabcd
700a6e02: f6ca 31dc    	movt	r1, #0xabdc
700a6e06: 4288         	cmp	r0, r1
700a6e08: d012         	beq	0x700a6e30 <Udma_ringCheckParams+0x90> @ imm = #0x24
700a6e0a: e7ff         	b	0x700a6e0c <Udma_ringCheckParams+0x6c> @ imm = #-0x2
;                           ringPrms->mode,
700a6e0c: 9a02         	ldr	r2, [sp, #0x8]
700a6e0e: 7a10         	ldrb	r0, [r2, #0x8]
;                           ringPrms->elemCnt,
700a6e10: 68d1         	ldr	r1, [r2, #0xc]
;                           ringPrms->elemSize);
700a6e12: 7c12         	ldrb	r2, [r2, #0x10]
;         ringMemSize = UdmaUtils_getRingMemSize(
700a6e14: f006 fe84    	bl	0x700adb20 <UdmaUtils_getRingMemSize> @ imm = #0x6d08
700a6e18: 9000         	str	r0, [sp]
;         if(ringPrms->ringMemSize < ringMemSize)
700a6e1a: 9802         	ldr	r0, [sp, #0x8]
700a6e1c: 6840         	ldr	r0, [r0, #0x4]
700a6e1e: 9900         	ldr	r1, [sp]
700a6e20: 4288         	cmp	r0, r1
700a6e22: d204         	bhs	0x700a6e2e <Udma_ringCheckParams+0x8e> @ imm = #0x8
700a6e24: e7ff         	b	0x700a6e26 <Udma_ringCheckParams+0x86> @ imm = #-0x2
700a6e26: f06f 0004    	mvn	r0, #0x4
;             retVal = UDMA_EALLOC;
700a6e2a: 9001         	str	r0, [sp, #0x4]
;         }
700a6e2c: e7ff         	b	0x700a6e2e <Udma_ringCheckParams+0x8e> @ imm = #-0x2
;     }
700a6e2e: e7ff         	b	0x700a6e30 <Udma_ringCheckParams+0x90> @ imm = #-0x2
;     if (UDMA_RING_ORDERID_MAX < ringPrms->orderId)
700a6e30: 9802         	ldr	r0, [sp, #0x8]
700a6e32: 7c40         	ldrb	r0, [r0, #0x11]
700a6e34: 2810         	cmp	r0, #0x10
700a6e36: d304         	blo	0x700a6e42 <Udma_ringCheckParams+0xa2> @ imm = #0x8
700a6e38: e7ff         	b	0x700a6e3a <Udma_ringCheckParams+0x9a> @ imm = #-0x2
700a6e3a: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6e3e: 9001         	str	r0, [sp, #0x4]
;     }
700a6e40: e7ff         	b	0x700a6e42 <Udma_ringCheckParams+0xa2> @ imm = #-0x2
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a6e42: 9802         	ldr	r0, [sp, #0x8]
700a6e44: 6940         	ldr	r0, [r0, #0x14]
700a6e46: 2104         	movs	r1, #0x4
700a6e48: f6cf 71ff    	movt	r1, #0xffff
700a6e4c: 4288         	cmp	r0, r1
700a6e4e: d009         	beq	0x700a6e64 <Udma_ringCheckParams+0xc4> @ imm = #0x12
700a6e50: e7ff         	b	0x700a6e52 <Udma_ringCheckParams+0xb2> @ imm = #-0x2
;        (ringPrms->mappedRingGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a6e52: 9802         	ldr	r0, [sp, #0x8]
700a6e54: 6940         	ldr	r0, [r0, #0x14]
;     if((UDMA_MAPPED_GROUP_INVALID != ringPrms->mappedRingGrp) &&
700a6e56: 2808         	cmp	r0, #0x8
700a6e58: d304         	blo	0x700a6e64 <Udma_ringCheckParams+0xc4> @ imm = #0x8
700a6e5a: e7ff         	b	0x700a6e5c <Udma_ringCheckParams+0xbc> @ imm = #-0x2
700a6e5c: f06f 0002    	mvn	r0, #0x2
;         retVal = UDMA_EINVALID_PARAMS;
700a6e60: 9001         	str	r0, [sp, #0x4]
;     }
700a6e62: e7ff         	b	0x700a6e64 <Udma_ringCheckParams+0xc4> @ imm = #-0x2
;     return (retVal);
700a6e64: 9801         	ldr	r0, [sp, #0x4]
700a6e66: b004         	add	sp, #0x10
700a6e68: bd80         	pop	{r7, pc}
700a6e6a: 0000         	movs	r0, r0
700a6e6c: 0000         	movs	r0, r0
700a6e6e: 0000         	movs	r0, r0

700a6e70 <UART_lld_writeDma>:
; {
700a6e70: b580         	push	{r7, lr}
700a6e72: b086         	sub	sp, #0x18
700a6e74: 9005         	str	r0, [sp, #0x14]
700a6e76: 9104         	str	r1, [sp, #0x10]
700a6e78: 9203         	str	r2, [sp, #0xc]
700a6e7a: 9302         	str	r3, [sp, #0x8]
700a6e7c: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a6e7e: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a6e80: 9805         	ldr	r0, [sp, #0x14]
700a6e82: 2800         	cmp	r0, #0x0
700a6e84: d051         	beq	0x700a6f2a <UART_lld_writeDma+0xba> @ imm = #0xa2
700a6e86: e7ff         	b	0x700a6e88 <UART_lld_writeDma+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a6e88: 9805         	ldr	r0, [sp, #0x14]
700a6e8a: 303c         	adds	r0, #0x3c
700a6e8c: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a6e8e: 9800         	ldr	r0, [sp]
700a6e90: 6800         	ldr	r0, [r0]
700a6e92: b138         	cbz	r0, 0x700a6ea4 <UART_lld_writeDma+0x34> @ imm = #0xe
700a6e94: e7ff         	b	0x700a6e96 <UART_lld_writeDma+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a6e96: 9900         	ldr	r1, [sp]
700a6e98: 2009         	movs	r0, #0x9
700a6e9a: 60c8         	str	r0, [r1, #0xc]
700a6e9c: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a6ea0: 9001         	str	r0, [sp, #0x4]
;         }
700a6ea2: e041         	b	0x700a6f28 <UART_lld_writeDma+0xb8> @ imm = #0x82
;             UART_lld_Transaction_init(trans);
700a6ea4: 9800         	ldr	r0, [sp]
700a6ea6: f007 ff8b    	bl	0x700aedc0 <UART_lld_Transaction_init> @ imm = #0x7f16
;             if(extendedParams != NULL)
700a6eaa: 9802         	ldr	r0, [sp, #0x8]
700a6eac: b128         	cbz	r0, 0x700a6eba <UART_lld_writeDma+0x4a> @ imm = #0xa
700a6eae: e7ff         	b	0x700a6eb0 <UART_lld_writeDma+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a6eb0: 9802         	ldr	r0, [sp, #0x8]
700a6eb2: 6800         	ldr	r0, [r0]
700a6eb4: 9900         	ldr	r1, [sp]
700a6eb6: 6108         	str	r0, [r1, #0x10]
;             }
700a6eb8: e003         	b	0x700a6ec2 <UART_lld_writeDma+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a6eba: 9900         	ldr	r1, [sp]
700a6ebc: 2000         	movs	r0, #0x0
700a6ebe: 6108         	str	r0, [r1, #0x10]
700a6ec0: e7ff         	b	0x700a6ec2 <UART_lld_writeDma+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a6ec2: 9804         	ldr	r0, [sp, #0x10]
700a6ec4: 9900         	ldr	r1, [sp]
700a6ec6: 6008         	str	r0, [r1]
;             trans->count = size;
700a6ec8: 9803         	ldr	r0, [sp, #0xc]
700a6eca: 9900         	ldr	r1, [sp]
700a6ecc: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a6ece: 9805         	ldr	r0, [sp, #0x14]
700a6ed0: 6d40         	ldr	r0, [r0, #0x54]
700a6ed2: 2801         	cmp	r0, #0x1
700a6ed4: d105         	bne	0x700a6ee2 <UART_lld_writeDma+0x72> @ imm = #0xa
700a6ed6: e7ff         	b	0x700a6ed8 <UART_lld_writeDma+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a6ed8: 9800         	ldr	r0, [sp]
700a6eda: f007 fb71    	bl	0x700ae5c0 <UART_checkTransaction> @ imm = #0x76e2
700a6ede: 9001         	str	r0, [sp, #0x4]
;             }
700a6ee0: e003         	b	0x700a6eea <UART_lld_writeDma+0x7a> @ imm = #0x6
700a6ee2: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a6ee6: 9001         	str	r0, [sp, #0x4]
700a6ee8: e7ff         	b	0x700a6eea <UART_lld_writeDma+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a6eea: 9801         	ldr	r0, [sp, #0x4]
700a6eec: b9d8         	cbnz	r0, 0x700a6f26 <UART_lld_writeDma+0xb6> @ imm = #0x36
700a6eee: e7ff         	b	0x700a6ef0 <UART_lld_writeDma+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a6ef0: 9800         	ldr	r0, [sp]
700a6ef2: 6800         	ldr	r0, [r0]
700a6ef4: 9905         	ldr	r1, [sp, #0x14]
700a6ef6: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a6ef8: 9800         	ldr	r0, [sp]
700a6efa: 6880         	ldr	r0, [r0, #0x8]
700a6efc: 9905         	ldr	r1, [sp, #0x14]
700a6efe: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a6f00: 9905         	ldr	r1, [sp, #0x14]
700a6f02: 2000         	movs	r0, #0x0
700a6f04: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a6f06: 9800         	ldr	r0, [sp]
700a6f08: 6840         	ldr	r0, [r0, #0x4]
700a6f0a: 9905         	ldr	r1, [sp, #0x14]
700a6f0c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a6f0e: 9905         	ldr	r1, [sp, #0x14]
700a6f10: 2002         	movs	r0, #0x2
700a6f12: 6548         	str	r0, [r1, #0x54]
;                 status = UART_lld_dmaWrite(hUart, trans);
700a6f14: 9805         	ldr	r0, [sp, #0x14]
700a6f16: 9900         	ldr	r1, [sp]
700a6f18: f007 ff6a    	bl	0x700aedf0 <UART_lld_dmaWrite> @ imm = #0x7ed4
700a6f1c: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a6f1e: 9905         	ldr	r1, [sp, #0x14]
700a6f20: 2001         	movs	r0, #0x1
700a6f22: 6548         	str	r0, [r1, #0x54]
;             }
700a6f24: e7ff         	b	0x700a6f26 <UART_lld_writeDma+0xb6> @ imm = #-0x2
700a6f26: e7ff         	b	0x700a6f28 <UART_lld_writeDma+0xb8> @ imm = #-0x2
;     }
700a6f28: e003         	b	0x700a6f32 <UART_lld_writeDma+0xc2> @ imm = #0x6
700a6f2a: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a6f2e: 9001         	str	r0, [sp, #0x4]
700a6f30: e7ff         	b	0x700a6f32 <UART_lld_writeDma+0xc2> @ imm = #-0x2
;     return status;
700a6f32: 9801         	ldr	r0, [sp, #0x4]
700a6f34: b006         	add	sp, #0x18
700a6f36: bd80         	pop	{r7, pc}
		...

700a6f40 <UART_udmaHpdInit>:
; {
700a6f40: b580         	push	{r7, lr}
700a6f42: b08a         	sub	sp, #0x28
700a6f44: 9009         	str	r0, [sp, #0x24]
700a6f46: 9108         	str	r1, [sp, #0x20]
700a6f48: 9207         	str	r2, [sp, #0x1c]
700a6f4a: 9306         	str	r3, [sp, #0x18]
;     CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700a6f4c: 9808         	ldr	r0, [sp, #0x20]
700a6f4e: 9005         	str	r0, [sp, #0x14]
700a6f50: 2001         	movs	r0, #0x1
;     uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700a6f52: 9004         	str	r0, [sp, #0x10]
;     CSL_udmapCppi5SetDescType(pHpd, descType);
700a6f54: 9805         	ldr	r0, [sp, #0x14]
700a6f56: 9904         	ldr	r1, [sp, #0x10]
700a6f58: f008 fb62    	bl	0x700af620 <CSL_udmapCppi5SetDescType> @ imm = #0x86c4
;     CSL_udmapCppi5SetEpiDataPresent(pHpd, FALSE);
700a6f5c: 9805         	ldr	r0, [sp, #0x14]
700a6f5e: 2100         	movs	r1, #0x0
700a6f60: 9102         	str	r1, [sp, #0x8]
700a6f62: f008 fa3d    	bl	0x700af3e0 <CSL_udmapCppi5SetEpiDataPresent> @ imm = #0x847a
700a6f66: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLoc(pHpd, 0U);
700a6f68: 9805         	ldr	r0, [sp, #0x14]
700a6f6a: f008 fc61    	bl	0x700af830 <CSL_udmapCppi5SetPsDataLoc> @ imm = #0x88c2
700a6f6e: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsDataLen(pHpd, 0U);
700a6f70: 9805         	ldr	r0, [sp, #0x14]
700a6f72: f008 fb85    	bl	0x700af680 <CSL_udmapCppi5SetPsDataLen> @ imm = #0x870a
;     CSL_udmapCppi5SetPktLen(pHpd, descType, length);
700a6f76: 9805         	ldr	r0, [sp, #0x14]
700a6f78: 9904         	ldr	r1, [sp, #0x10]
700a6f7a: 9a06         	ldr	r2, [sp, #0x18]
700a6f7c: f006 fd58    	bl	0x700ada30 <CSL_udmapCppi5SetPktLen> @ imm = #0x6ab0
700a6f80: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetPsFlags(pHpd, 0U);
700a6f82: 9805         	ldr	r0, [sp, #0x14]
700a6f84: f008 fc64    	bl	0x700af850 <CSL_udmapCppi5SetPsFlags> @ imm = #0x88c8
;     CSL_udmapCppi5SetIds(pHpd, descType, 0x321, UDMA_DEFAULT_FLOW_ID);
700a6f88: 9805         	ldr	r0, [sp, #0x14]
700a6f8a: 9904         	ldr	r1, [sp, #0x10]
700a6f8c: f240 3221    	movw	r2, #0x321
700a6f90: f643 73ff    	movw	r3, #0x3fff
700a6f94: f004 fdb4    	bl	0x700abb00 <CSL_udmapCppi5SetIds> @ imm = #0x4b68
700a6f98: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetSrcTag(pHpd, 0x0000);     /* Not used */
700a6f9a: 9805         	ldr	r0, [sp, #0x14]
700a6f9c: f008 fd18    	bl	0x700af9d0 <CSL_udmapCppi5SetSrcTag> @ imm = #0x8a30
700a6fa0: 9902         	ldr	r1, [sp, #0x8]
;     CSL_udmapCppi5SetDstTag(pHpd, 0x0000);     /* Not used */
700a6fa2: 9805         	ldr	r0, [sp, #0x14]
700a6fa4: f008 fdbc    	bl	0x700afb20 <CSL_udmapCppi5SetDstTag> @ imm = #0x8b78
;     UART_udmapSetReturnPolicy(chHandle, pHpdMem);
700a6fa8: 9809         	ldr	r0, [sp, #0x24]
700a6faa: 9908         	ldr	r1, [sp, #0x20]
700a6fac: f007 ffe0    	bl	0x700aef70 <UART_udmapSetReturnPolicy> @ imm = #0x7fc0
700a6fb0: 9b02         	ldr	r3, [sp, #0x8]
;     CSL_udmapCppi5LinkDesc(pHpd, 0U);
700a6fb2: 9805         	ldr	r0, [sp, #0x14]
700a6fb4: 461a         	mov	r2, r3
700a6fb6: f008 fbfb    	bl	0x700af7b0 <CSL_udmapCppi5LinkDesc> @ imm = #0x87f6
700a6fba: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a6fbc: 9805         	ldr	r0, [sp, #0x14]
700a6fbe: 9001         	str	r0, [sp, #0x4]
700a6fc0: 9807         	ldr	r0, [sp, #0x1c]
700a6fc2: 4611         	mov	r1, r2
700a6fc4: f008 fde4    	bl	0x700afb90 <Udma_defaultVirtToPhyFxn> @ imm = #0x8bc8
700a6fc8: 4602         	mov	r2, r0
700a6fca: 9801         	ldr	r0, [sp, #0x4]
700a6fcc: 460b         	mov	r3, r1
700a6fce: f008 fbff    	bl	0x700af7d0 <CSL_udmapCppi5SetBufferAddr> @ imm = #0x87fe
;     CSL_udmapCppi5SetBufferLen(pHpd, length);
700a6fd2: 9805         	ldr	r0, [sp, #0x14]
700a6fd4: 9906         	ldr	r1, [sp, #0x18]
700a6fd6: f008 fc0b    	bl	0x700af7f0 <CSL_udmapCppi5SetBufferLen> @ imm = #0x8816
700a6fda: 9a02         	ldr	r2, [sp, #0x8]
;     CSL_udmapCppi5SetOrgBufferAddr(pHpd, (uint64_t) Udma_defaultVirtToPhyFxn(destBuf, 0U, NULL));
700a6fdc: 9805         	ldr	r0, [sp, #0x14]
700a6fde: 9003         	str	r0, [sp, #0xc]
700a6fe0: 9807         	ldr	r0, [sp, #0x1c]
700a6fe2: 4611         	mov	r1, r2
700a6fe4: f008 fdd4    	bl	0x700afb90 <Udma_defaultVirtToPhyFxn> @ imm = #0x8ba8
700a6fe8: 4602         	mov	r2, r0
700a6fea: 9803         	ldr	r0, [sp, #0xc]
700a6fec: 460b         	mov	r3, r1
700a6fee: f008 fc0f    	bl	0x700af810 <CSL_udmapCppi5SetOrgBufferAddr> @ imm = #0x881e
;     CSL_udmapCppi5SetOrgBufferLen(pHpd, length);
700a6ff2: 9805         	ldr	r0, [sp, #0x14]
700a6ff4: 9906         	ldr	r1, [sp, #0x18]
700a6ff6: f008 fd9b    	bl	0x700afb30 <CSL_udmapCppi5SetOrgBufferLen> @ imm = #0x8b36
;     CacheP_wb(pHpdMem, sizeof(CSL_UdmapCppi5HMPD), CacheP_TYPE_ALLD);
700a6ffa: 9808         	ldr	r0, [sp, #0x20]
700a6ffc: 2130         	movs	r1, #0x30
700a6ffe: 220a         	movs	r2, #0xa
700a7000: f009 ed88    	blx	0x700b0b14 <CacheP_wb>  @ imm = #0x9b10
;     return;
700a7004: b00a         	add	sp, #0x28
700a7006: bd80         	pop	{r7, pc}
		...

700a7010 <Udma_eventCheckUnRegister>:
; {
700a7010: b580         	push	{r7, lr}
700a7012: b088         	sub	sp, #0x20
700a7014: 9007         	str	r0, [sp, #0x1c]
700a7016: 9106         	str	r1, [sp, #0x18]
700a7018: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a701a: 9005         	str	r0, [sp, #0x14]
;     eventPrms = &eventHandle->eventPrms;
700a701c: 9806         	ldr	r0, [sp, #0x18]
700a701e: 3008         	adds	r0, #0x8
700a7020: 9004         	str	r0, [sp, #0x10]
;     if(eventHandle->eventInitDone != UDMA_INIT_DONE)
700a7022: 9806         	ldr	r0, [sp, #0x18]
700a7024: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700a7028: f64a 31cd    	movw	r1, #0xabcd
700a702c: f6ca 31dc    	movt	r1, #0xabdc
700a7030: 4288         	cmp	r0, r1
700a7032: d004         	beq	0x700a703e <Udma_eventCheckUnRegister+0x2e> @ imm = #0x8
700a7034: e7ff         	b	0x700a7036 <Udma_eventCheckUnRegister+0x26> @ imm = #-0x2
700a7036: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = UDMA_EFAIL;
700a703a: 9005         	str	r0, [sp, #0x14]
;     }
700a703c: e7ff         	b	0x700a703e <Udma_eventCheckUnRegister+0x2e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a703e: 9805         	ldr	r0, [sp, #0x14]
700a7040: b968         	cbnz	r0, 0x700a705e <Udma_eventCheckUnRegister+0x4e> @ imm = #0x1a
700a7042: e7ff         	b	0x700a7044 <Udma_eventCheckUnRegister+0x34> @ imm = #-0x2
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a7044: 9804         	ldr	r0, [sp, #0x10]
700a7046: 6900         	ldr	r0, [r0, #0x10]
700a7048: b940         	cbnz	r0, 0x700a705c <Udma_eventCheckUnRegister+0x4c> @ imm = #0x10
700a704a: e7ff         	b	0x700a704c <Udma_eventCheckUnRegister+0x3c> @ imm = #-0x2
;            (NULL_PTR != eventHandle->nextEvent))
700a704c: 9806         	ldr	r0, [sp, #0x18]
700a704e: 6dc0         	ldr	r0, [r0, #0x5c]
;         if((NULL_PTR == eventPrms->controllerEventHandle) &&
700a7050: b120         	cbz	r0, 0x700a705c <Udma_eventCheckUnRegister+0x4c> @ imm = #0x8
700a7052: e7ff         	b	0x700a7054 <Udma_eventCheckUnRegister+0x44> @ imm = #-0x2
700a7054: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7058: 9005         	str	r0, [sp, #0x14]
;         }
700a705a: e7ff         	b	0x700a705c <Udma_eventCheckUnRegister+0x4c> @ imm = #-0x2
;     }
700a705c: e7ff         	b	0x700a705e <Udma_eventCheckUnRegister+0x4e> @ imm = #-0x2
;      if(UDMA_SOK == retVal)
700a705e: 9805         	ldr	r0, [sp, #0x14]
700a7060: bbb8         	cbnz	r0, 0x700a70d2 <Udma_eventCheckUnRegister+0xc2> @ imm = #0x6e
700a7062: e7ff         	b	0x700a7064 <Udma_eventCheckUnRegister+0x54> @ imm = #-0x2
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a7064: 9804         	ldr	r0, [sp, #0x10]
700a7066: 6800         	ldr	r0, [r0]
700a7068: 2801         	cmp	r0, #0x1
700a706a: d00a         	beq	0x700a7082 <Udma_eventCheckUnRegister+0x72> @ imm = #0x14
700a706c: e7ff         	b	0x700a706e <Udma_eventCheckUnRegister+0x5e> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType) ||
700a706e: 9804         	ldr	r0, [sp, #0x10]
700a7070: 6800         	ldr	r0, [r0]
700a7072: 2806         	cmp	r0, #0x6
700a7074: d005         	beq	0x700a7082 <Udma_eventCheckUnRegister+0x72> @ imm = #0xa
700a7076: e7ff         	b	0x700a7078 <Udma_eventCheckUnRegister+0x68> @ imm = #-0x2
;            (UDMA_EVENT_TYPE_RING == eventPrms->eventType))
700a7078: 9804         	ldr	r0, [sp, #0x10]
700a707a: 6800         	ldr	r0, [r0]
;         if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) ||
700a707c: 2804         	cmp	r0, #0x4
700a707e: d127         	bne	0x700a70d0 <Udma_eventCheckUnRegister+0xc0> @ imm = #0x4e
700a7080: e7ff         	b	0x700a7082 <Udma_eventCheckUnRegister+0x72> @ imm = #-0x2
;             if((UDMA_EVENT_TYPE_DMA_COMPLETION == eventPrms->eventType) || (UDMA_EVENT_TYPE_TEARDOWN_COMPLETION == eventPrms->eventType))
700a7082: 9804         	ldr	r0, [sp, #0x10]
700a7084: 6800         	ldr	r0, [r0]
700a7086: 2801         	cmp	r0, #0x1
700a7088: d005         	beq	0x700a7096 <Udma_eventCheckUnRegister+0x86> @ imm = #0xa
700a708a: e7ff         	b	0x700a708c <Udma_eventCheckUnRegister+0x7c> @ imm = #-0x2
700a708c: 9804         	ldr	r0, [sp, #0x10]
700a708e: 6800         	ldr	r0, [r0]
700a7090: 2806         	cmp	r0, #0x6
700a7092: d106         	bne	0x700a70a2 <Udma_eventCheckUnRegister+0x92> @ imm = #0xc
700a7094: e7ff         	b	0x700a7096 <Udma_eventCheckUnRegister+0x86> @ imm = #-0x2
;                 ringHandle = ((Udma_ChHandleInt) (eventPrms->chHandle))->cqRing;
700a7096: 9804         	ldr	r0, [sp, #0x10]
700a7098: 6880         	ldr	r0, [r0, #0x8]
700a709a: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700a709e: 9003         	str	r0, [sp, #0xc]
;             }
700a70a0: e003         	b	0x700a70aa <Udma_eventCheckUnRegister+0x9a> @ imm = #0x6
;                 ringHandle = eventPrms->ringHandle;
700a70a2: 9804         	ldr	r0, [sp, #0x10]
700a70a4: 68c0         	ldr	r0, [r0, #0xc]
700a70a6: 9003         	str	r0, [sp, #0xc]
700a70a8: e7ff         	b	0x700a70aa <Udma_eventCheckUnRegister+0x9a> @ imm = #-0x2
;             fOcc = Udma_ringGetForwardRingOcc(ringHandle);
700a70aa: 9803         	ldr	r0, [sp, #0xc]
700a70ac: f007 ff78    	bl	0x700aefa0 <Udma_ringGetForwardRingOcc> @ imm = #0x7ef0
700a70b0: 9002         	str	r0, [sp, #0x8]
;             rOcc = Udma_ringGetReverseRingOcc(ringHandle);
700a70b2: 9803         	ldr	r0, [sp, #0xc]
700a70b4: f007 ff8c    	bl	0x700aefd0 <Udma_ringGetReverseRingOcc> @ imm = #0x7f18
700a70b8: 9001         	str	r0, [sp, #0x4]
;             if((0U != fOcc) || (0U != rOcc))
700a70ba: 9802         	ldr	r0, [sp, #0x8]
700a70bc: b918         	cbnz	r0, 0x700a70c6 <Udma_eventCheckUnRegister+0xb6> @ imm = #0x6
700a70be: e7ff         	b	0x700a70c0 <Udma_eventCheckUnRegister+0xb0> @ imm = #-0x2
700a70c0: 9801         	ldr	r0, [sp, #0x4]
700a70c2: b120         	cbz	r0, 0x700a70ce <Udma_eventCheckUnRegister+0xbe> @ imm = #0x8
700a70c4: e7ff         	b	0x700a70c6 <Udma_eventCheckUnRegister+0xb6> @ imm = #-0x2
700a70c6: f04f 30ff    	mov.w	r0, #0xffffffff
;                 retVal = UDMA_EFAIL;
700a70ca: 9005         	str	r0, [sp, #0x14]
;             }
700a70cc: e7ff         	b	0x700a70ce <Udma_eventCheckUnRegister+0xbe> @ imm = #-0x2
;         }
700a70ce: e7ff         	b	0x700a70d0 <Udma_eventCheckUnRegister+0xc0> @ imm = #-0x2
;     }
700a70d0: e7ff         	b	0x700a70d2 <Udma_eventCheckUnRegister+0xc2> @ imm = #-0x2
;     return (retVal);
700a70d2: 9805         	ldr	r0, [sp, #0x14]
700a70d4: b008         	add	sp, #0x20
700a70d6: bd80         	pop	{r7, pc}
		...

700a70e0 <Udma_ringFree>:
; {
700a70e0: b580         	push	{r7, lr}
700a70e2: b086         	sub	sp, #0x18
700a70e4: 9005         	str	r0, [sp, #0x14]
700a70e6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a70e8: 9004         	str	r0, [sp, #0x10]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a70ea: 9805         	ldr	r0, [sp, #0x14]
700a70ec: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == ringHandleInt)
700a70ee: 9802         	ldr	r0, [sp, #0x8]
700a70f0: b920         	cbnz	r0, 0x700a70fc <Udma_ringFree+0x1c> @ imm = #0x8
700a70f2: e7ff         	b	0x700a70f4 <Udma_ringFree+0x14> @ imm = #-0x2
700a70f4: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a70f8: 9004         	str	r0, [sp, #0x10]
;     }
700a70fa: e7ff         	b	0x700a70fc <Udma_ringFree+0x1c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a70fc: 9804         	ldr	r0, [sp, #0x10]
700a70fe: b970         	cbnz	r0, 0x700a711e <Udma_ringFree+0x3e> @ imm = #0x1c
700a7100: e7ff         	b	0x700a7102 <Udma_ringFree+0x22> @ imm = #-0x2
;         if(ringHandleInt->ringInitDone != UDMA_INIT_DONE)
700a7102: 9802         	ldr	r0, [sp, #0x8]
700a7104: 6d80         	ldr	r0, [r0, #0x58]
700a7106: f64a 31cd    	movw	r1, #0xabcd
700a710a: f6ca 31dc    	movt	r1, #0xabdc
700a710e: 4288         	cmp	r0, r1
700a7110: d004         	beq	0x700a711c <Udma_ringFree+0x3c> @ imm = #0x8
700a7112: e7ff         	b	0x700a7114 <Udma_ringFree+0x34> @ imm = #-0x2
700a7114: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7118: 9004         	str	r0, [sp, #0x10]
;         }
700a711a: e7ff         	b	0x700a711c <Udma_ringFree+0x3c> @ imm = #-0x2
;     }
700a711c: e7ff         	b	0x700a711e <Udma_ringFree+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a711e: 9804         	ldr	r0, [sp, #0x10]
700a7120: b9a8         	cbnz	r0, 0x700a714e <Udma_ringFree+0x6e> @ imm = #0x2a
700a7122: e7ff         	b	0x700a7124 <Udma_ringFree+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a7124: 9802         	ldr	r0, [sp, #0x8]
700a7126: 6800         	ldr	r0, [r0]
700a7128: 9003         	str	r0, [sp, #0xc]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a712a: 9803         	ldr	r0, [sp, #0xc]
700a712c: b150         	cbz	r0, 0x700a7144 <Udma_ringFree+0x64> @ imm = #0x14
700a712e: e7ff         	b	0x700a7130 <Udma_ringFree+0x50> @ imm = #-0x2
700a7130: 9803         	ldr	r0, [sp, #0xc]
700a7132: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7136: f64a 31cd    	movw	r1, #0xabcd
700a713a: f6ca 31dc    	movt	r1, #0xabdc
700a713e: 4288         	cmp	r0, r1
700a7140: d004         	beq	0x700a714c <Udma_ringFree+0x6c> @ imm = #0x8
700a7142: e7ff         	b	0x700a7144 <Udma_ringFree+0x64> @ imm = #-0x2
700a7144: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7148: 9004         	str	r0, [sp, #0x10]
;         }
700a714a: e7ff         	b	0x700a714c <Udma_ringFree+0x6c> @ imm = #-0x2
;     }
700a714c: e7ff         	b	0x700a714e <Udma_ringFree+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a714e: 9804         	ldr	r0, [sp, #0x10]
700a7150: bb38         	cbnz	r0, 0x700a71a2 <Udma_ringFree+0xc2> @ imm = #0x4e
700a7152: e7ff         	b	0x700a7154 <Udma_ringFree+0x74> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == ringHandleInt->mappedRingGrp)
700a7154: 9802         	ldr	r0, [sp, #0x8]
700a7156: 6dc0         	ldr	r0, [r0, #0x5c]
700a7158: 2104         	movs	r1, #0x4
700a715a: f6cf 71ff    	movt	r1, #0xffff
700a715e: 4288         	cmp	r0, r1
700a7160: d106         	bne	0x700a7170 <Udma_ringFree+0x90> @ imm = #0xc
700a7162: e7ff         	b	0x700a7164 <Udma_ringFree+0x84> @ imm = #-0x2
;             Udma_rmFreeFreeRing(ringHandleInt->ringNum, drvHandle);
700a7164: 9802         	ldr	r0, [sp, #0x8]
700a7166: 8880         	ldrh	r0, [r0, #0x4]
700a7168: 9903         	ldr	r1, [sp, #0xc]
700a716a: f008 fd91    	bl	0x700afc90 <Udma_rmFreeFreeRing> @ imm = #0x8b22
;         }
700a716e: e007         	b	0x700a7180 <Udma_ringFree+0xa0> @ imm = #0xe
;                 ringHandleInt->ringNum,
700a7170: 9b02         	ldr	r3, [sp, #0x8]
700a7172: 8898         	ldrh	r0, [r3, #0x4]
;                 drvHandle,
700a7174: 9903         	ldr	r1, [sp, #0xc]
;                 ringHandleInt->mappedRingGrp,
700a7176: 6dda         	ldr	r2, [r3, #0x5c]
;                 ringHandleInt->mappedChNum);
700a7178: 6e1b         	ldr	r3, [r3, #0x60]
;             Udma_rmFreeMappedRing(
700a717a: f002 fe19    	bl	0x700a9db0 <Udma_rmFreeMappedRing> @ imm = #0x2c32
700a717e: e7ff         	b	0x700a7180 <Udma_ringFree+0xa0> @ imm = #-0x2
;         ringHandleInt->ringNum         = UDMA_RING_INVALID;
700a7180: 9902         	ldr	r1, [sp, #0x8]
700a7182: f64f 70ff    	movw	r0, #0xffff
700a7186: 8088         	strh	r0, [r1, #0x4]
;         ringHandleInt->ringInitDone    = UDMA_DEINIT_DONE;
700a7188: 9902         	ldr	r1, [sp, #0x8]
700a718a: 2000         	movs	r0, #0x0
700a718c: 9001         	str	r0, [sp, #0x4]
700a718e: 6588         	str	r0, [r1, #0x58]
;         drvHandle->ringHandleClearRegs(ringHandleInt);
700a7190: 9803         	ldr	r0, [sp, #0xc]
700a7192: f8d0 15c8    	ldr.w	r1, [r0, #0x5c8]
700a7196: 9802         	ldr	r0, [sp, #0x8]
700a7198: 4788         	blx	r1
700a719a: 9801         	ldr	r0, [sp, #0x4]
;         ringHandleInt->drvHandle       = (Udma_DrvHandleInt) NULL_PTR;
700a719c: 9902         	ldr	r1, [sp, #0x8]
700a719e: 6008         	str	r0, [r1]
;     }
700a71a0: e7ff         	b	0x700a71a2 <Udma_ringFree+0xc2> @ imm = #-0x2
;     return (retVal);
700a71a2: 9804         	ldr	r0, [sp, #0x10]
700a71a4: b006         	add	sp, #0x18
700a71a6: bd80         	pop	{r7, pc}
		...

700a71b0 <UART_lld_writeIntr>:
; {
700a71b0: b580         	push	{r7, lr}
700a71b2: b086         	sub	sp, #0x18
700a71b4: 9005         	str	r0, [sp, #0x14]
700a71b6: 9104         	str	r1, [sp, #0x10]
700a71b8: 9203         	str	r2, [sp, #0xc]
700a71ba: 9302         	str	r3, [sp, #0x8]
700a71bc: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a71be: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != hUart)
700a71c0: 9805         	ldr	r0, [sp, #0x14]
700a71c2: 2800         	cmp	r0, #0x0
700a71c4: d050         	beq	0x700a7268 <UART_lld_writeIntr+0xb8> @ imm = #0xa0
700a71c6: e7ff         	b	0x700a71c8 <UART_lld_writeIntr+0x18> @ imm = #-0x2
;         trans = &hUart->writeTrans;
700a71c8: 9805         	ldr	r0, [sp, #0x14]
700a71ca: 303c         	adds	r0, #0x3c
700a71cc: 9000         	str	r0, [sp]
;         if(NULL_PTR != trans->buf)
700a71ce: 9800         	ldr	r0, [sp]
700a71d0: 6800         	ldr	r0, [r0]
700a71d2: b138         	cbz	r0, 0x700a71e4 <UART_lld_writeIntr+0x34> @ imm = #0xe
700a71d4: e7ff         	b	0x700a71d6 <UART_lld_writeIntr+0x26> @ imm = #-0x2
;             trans->status = UART_TRANSFER_STATUS_ERROR_INUSE;
700a71d6: 9900         	ldr	r1, [sp]
700a71d8: 2009         	movs	r0, #0x9
700a71da: 60c8         	str	r0, [r1, #0xc]
700a71dc: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = UART_TRANSFER_STATUS_FAILURE;
700a71e0: 9001         	str	r0, [sp, #0x4]
;         }
700a71e2: e040         	b	0x700a7266 <UART_lld_writeIntr+0xb6> @ imm = #0x80
;             UART_lld_Transaction_init(trans);
700a71e4: 9800         	ldr	r0, [sp]
700a71e6: f007 fdeb    	bl	0x700aedc0 <UART_lld_Transaction_init> @ imm = #0x7bd6
;             if(extendedParams != NULL)
700a71ea: 9802         	ldr	r0, [sp, #0x8]
700a71ec: b128         	cbz	r0, 0x700a71fa <UART_lld_writeIntr+0x4a> @ imm = #0xa
700a71ee: e7ff         	b	0x700a71f0 <UART_lld_writeIntr+0x40> @ imm = #-0x2
;                 trans->args   = extendedParams->args;
700a71f0: 9802         	ldr	r0, [sp, #0x8]
700a71f2: 6800         	ldr	r0, [r0]
700a71f4: 9900         	ldr	r1, [sp]
700a71f6: 6108         	str	r0, [r1, #0x10]
;             }
700a71f8: e003         	b	0x700a7202 <UART_lld_writeIntr+0x52> @ imm = #0x6
;                 trans->args = NULL;
700a71fa: 9900         	ldr	r1, [sp]
700a71fc: 2000         	movs	r0, #0x0
700a71fe: 6108         	str	r0, [r1, #0x10]
700a7200: e7ff         	b	0x700a7202 <UART_lld_writeIntr+0x52> @ imm = #-0x2
;             trans->buf = (void *) txBuf;
700a7202: 9804         	ldr	r0, [sp, #0x10]
700a7204: 9900         	ldr	r1, [sp]
700a7206: 6008         	str	r0, [r1]
;             trans->count = size;
700a7208: 9803         	ldr	r0, [sp, #0xc]
700a720a: 9900         	ldr	r1, [sp]
700a720c: 6048         	str	r0, [r1, #0x4]
;             if(hUart->state == UART_STATE_READY)
700a720e: 9805         	ldr	r0, [sp, #0x14]
700a7210: 6d40         	ldr	r0, [r0, #0x54]
700a7212: 2801         	cmp	r0, #0x1
700a7214: d105         	bne	0x700a7222 <UART_lld_writeIntr+0x72> @ imm = #0xa
700a7216: e7ff         	b	0x700a7218 <UART_lld_writeIntr+0x68> @ imm = #-0x2
;                 status = UART_checkTransaction(trans);
700a7218: 9800         	ldr	r0, [sp]
700a721a: f007 f9d1    	bl	0x700ae5c0 <UART_checkTransaction> @ imm = #0x73a2
700a721e: 9001         	str	r0, [sp, #0x4]
;             }
700a7220: e003         	b	0x700a722a <UART_lld_writeIntr+0x7a> @ imm = #0x6
700a7222: f06f 0003    	mvn	r0, #0x3
;                 status = UART_TRANSFER_BUSY;
700a7226: 9001         	str	r0, [sp, #0x4]
700a7228: e7ff         	b	0x700a722a <UART_lld_writeIntr+0x7a> @ imm = #-0x2
;             if(UART_TRANSFER_STATUS_SUCCESS == status)
700a722a: 9801         	ldr	r0, [sp, #0x4]
700a722c: b9d0         	cbnz	r0, 0x700a7264 <UART_lld_writeIntr+0xb4> @ imm = #0x34
700a722e: e7ff         	b	0x700a7230 <UART_lld_writeIntr+0x80> @ imm = #-0x2
;                 hUart->writeBuf                = trans->buf;
700a7230: 9800         	ldr	r0, [sp]
700a7232: 6800         	ldr	r0, [r0]
700a7234: 9905         	ldr	r1, [sp, #0x14]
700a7236: 6088         	str	r0, [r1, #0x8]
;                 hUart->writeTrans.timeout      = trans->timeout;
700a7238: 9800         	ldr	r0, [sp]
700a723a: 6880         	ldr	r0, [r0, #0x8]
700a723c: 9905         	ldr	r1, [sp, #0x14]
700a723e: 6448         	str	r0, [r1, #0x44]
;                 hUart->writeCount              = 0U;
700a7240: 9905         	ldr	r1, [sp, #0x14]
700a7242: 2000         	movs	r0, #0x0
700a7244: 60c8         	str	r0, [r1, #0xc]
;                 hUart->writeSizeRemaining      = trans->count;
700a7246: 9800         	ldr	r0, [sp]
700a7248: 6840         	ldr	r0, [r0, #0x4]
700a724a: 9905         	ldr	r1, [sp, #0x14]
700a724c: 6108         	str	r0, [r1, #0x10]
;                 hUart->state = UART_STATE_BUSY;
700a724e: 9905         	ldr	r1, [sp, #0x14]
700a7250: 2002         	movs	r0, #0x2
700a7252: 6548         	str	r0, [r1, #0x54]
;                 status = UART_writeInterrupt(hUart);
700a7254: 9805         	ldr	r0, [sp, #0x14]
700a7256: f008 f923    	bl	0x700af4a0 <UART_writeInterrupt> @ imm = #0x8246
700a725a: 9001         	str	r0, [sp, #0x4]
;                 hUart->state = UART_STATE_READY;
700a725c: 9905         	ldr	r1, [sp, #0x14]
700a725e: 2001         	movs	r0, #0x1
700a7260: 6548         	str	r0, [r1, #0x54]
;             }
700a7262: e7ff         	b	0x700a7264 <UART_lld_writeIntr+0xb4> @ imm = #-0x2
700a7264: e7ff         	b	0x700a7266 <UART_lld_writeIntr+0xb6> @ imm = #-0x2
;     }
700a7266: e003         	b	0x700a7270 <UART_lld_writeIntr+0xc0> @ imm = #0x6
700a7268: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700a726c: 9001         	str	r0, [sp, #0x4]
700a726e: e7ff         	b	0x700a7270 <UART_lld_writeIntr+0xc0> @ imm = #-0x2
;     return status;
700a7270: 9801         	ldr	r0, [sp, #0x4]
700a7272: b006         	add	sp, #0x18
700a7274: bd80         	pop	{r7, pc}
		...
700a727e: 0000         	movs	r0, r0

700a7280 <Udma_eventUnRegister>:
; {
700a7280: b580         	push	{r7, lr}
700a7282: b084         	sub	sp, #0x10
700a7284: 9003         	str	r0, [sp, #0xc]
700a7286: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a7288: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR == eventHandle)
700a728a: 9803         	ldr	r0, [sp, #0xc]
700a728c: b920         	cbnz	r0, 0x700a7298 <Udma_eventUnRegister+0x18> @ imm = #0x8
700a728e: e7ff         	b	0x700a7290 <Udma_eventUnRegister+0x10> @ imm = #-0x2
700a7290: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a7294: 9002         	str	r0, [sp, #0x8]
;     }
700a7296: e7ff         	b	0x700a7298 <Udma_eventUnRegister+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7298: 9802         	ldr	r0, [sp, #0x8]
700a729a: b9b8         	cbnz	r0, 0x700a72cc <Udma_eventUnRegister+0x4c> @ imm = #0x2e
700a729c: e7ff         	b	0x700a729e <Udma_eventUnRegister+0x1e> @ imm = #-0x2
;         eventHandleInt = (Udma_EventHandleInt) eventHandle;
700a729e: 9803         	ldr	r0, [sp, #0xc]
700a72a0: 9000         	str	r0, [sp]
;         drvHandle = eventHandleInt->drvHandle;
700a72a2: 9800         	ldr	r0, [sp]
700a72a4: 6800         	ldr	r0, [r0]
700a72a6: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a72a8: 9801         	ldr	r0, [sp, #0x4]
700a72aa: b150         	cbz	r0, 0x700a72c2 <Udma_eventUnRegister+0x42> @ imm = #0x14
700a72ac: e7ff         	b	0x700a72ae <Udma_eventUnRegister+0x2e> @ imm = #-0x2
700a72ae: 9801         	ldr	r0, [sp, #0x4]
700a72b0: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a72b4: f64a 31cd    	movw	r1, #0xabcd
700a72b8: f6ca 31dc    	movt	r1, #0xabdc
700a72bc: 4288         	cmp	r0, r1
700a72be: d004         	beq	0x700a72ca <Udma_eventUnRegister+0x4a> @ imm = #0x8
700a72c0: e7ff         	b	0x700a72c2 <Udma_eventUnRegister+0x42> @ imm = #-0x2
700a72c2: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a72c6: 9002         	str	r0, [sp, #0x8]
;         }
700a72c8: e7ff         	b	0x700a72ca <Udma_eventUnRegister+0x4a> @ imm = #-0x2
;     }
700a72ca: e7ff         	b	0x700a72cc <Udma_eventUnRegister+0x4c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a72cc: 9802         	ldr	r0, [sp, #0x8]
700a72ce: bbb8         	cbnz	r0, 0x700a7340 <Udma_eventUnRegister+0xc0> @ imm = #0x6e
700a72d0: e7ff         	b	0x700a72d2 <Udma_eventUnRegister+0x52> @ imm = #-0x2
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a72d2: 9801         	ldr	r0, [sp, #0x4]
700a72d4: 6800         	ldr	r0, [r0]
700a72d6: b130         	cbz	r0, 0x700a72e6 <Udma_eventUnRegister+0x66> @ imm = #0xc
700a72d8: e7ff         	b	0x700a72da <Udma_eventUnRegister+0x5a> @ imm = #-0x2
;             (UDMA_EVENT_TYPE_TEARDOWN_PACKET == eventHandleInt->eventPrms.eventType))
700a72da: 9800         	ldr	r0, [sp]
700a72dc: 6880         	ldr	r0, [r0, #0x8]
;         if ((UDMA_INST_TYPE_NORMAL           != drvHandle->instType) &&
700a72de: 2802         	cmp	r0, #0x2
700a72e0: d101         	bne	0x700a72e6 <Udma_eventUnRegister+0x66> @ imm = #0x2
700a72e2: e7ff         	b	0x700a72e4 <Udma_eventUnRegister+0x64> @ imm = #-0x2
;         }
700a72e4: e02b         	b	0x700a733e <Udma_eventUnRegister+0xbe> @ imm = #0x56
;             retVal = Udma_eventCheckUnRegister(drvHandle, eventHandleInt);
700a72e6: 9801         	ldr	r0, [sp, #0x4]
700a72e8: 9900         	ldr	r1, [sp]
700a72ea: f7ff fe91    	bl	0x700a7010 <Udma_eventCheckUnRegister> @ imm = #-0x2de
700a72ee: 9002         	str	r0, [sp, #0x8]
;             if(UDMA_SOK == retVal)
700a72f0: 9802         	ldr	r0, [sp, #0x8]
700a72f2: bb18         	cbnz	r0, 0x700a733c <Udma_eventUnRegister+0xbc> @ imm = #0x46
700a72f4: e7ff         	b	0x700a72f6 <Udma_eventUnRegister+0x76> @ imm = #-0x2
;                 if(NULL_PTR != eventHandleInt->hwiHandle)
700a72f6: 9800         	ldr	r0, [sp]
700a72f8: 6e40         	ldr	r0, [r0, #0x64]
700a72fa: b128         	cbz	r0, 0x700a7308 <Udma_eventUnRegister+0x88> @ imm = #0xa
700a72fc: e7ff         	b	0x700a72fe <Udma_eventUnRegister+0x7e> @ imm = #-0x2
;                     HwiP_disableInt(eventHandleInt->coreIntrNum);
700a72fe: 9800         	ldr	r0, [sp]
700a7300: 6d80         	ldr	r0, [r0, #0x58]
700a7302: f008 fd9d    	bl	0x700afe40 <HwiP_disableInt> @ imm = #0x8b3a
;                 }
700a7306: e7ff         	b	0x700a7308 <Udma_eventUnRegister+0x88> @ imm = #-0x2
;                 retVal = Udma_eventReset(drvHandle, eventHandleInt);
700a7308: 9801         	ldr	r0, [sp, #0x4]
700a730a: 9900         	ldr	r1, [sp]
700a730c: f7f5 fe78    	bl	0x7009d000 <Udma_eventReset> @ imm = #-0xa310
700a7310: 9002         	str	r0, [sp, #0x8]
;                 if(UDMA_SOK != retVal)
700a7312: 9802         	ldr	r0, [sp, #0x8]
700a7314: b108         	cbz	r0, 0x700a731a <Udma_eventUnRegister+0x9a> @ imm = #0x2
700a7316: e7ff         	b	0x700a7318 <Udma_eventUnRegister+0x98> @ imm = #-0x2
;                 }
700a7318: e7ff         	b	0x700a731a <Udma_eventUnRegister+0x9a> @ imm = #-0x2
;                 Udma_eventFreeResource(drvHandle, eventHandleInt);
700a731a: 9801         	ldr	r0, [sp, #0x4]
700a731c: 9900         	ldr	r1, [sp]
700a731e: f7fe fcef    	bl	0x700a5d00 <Udma_eventFreeResource> @ imm = #-0x1622
;                 eventHandleInt->eventInitDone  = UDMA_DEINIT_DONE;
700a7322: 9900         	ldr	r1, [sp]
700a7324: 2000         	movs	r0, #0x0
700a7326: f8c1 0098    	str.w	r0, [r1, #0x98]
;                 eventHandleInt->pIaGeviRegs    = (volatile CSL_intaggr_imapRegs_gevi *) NULL_PTR;
700a732a: 9900         	ldr	r1, [sp]
700a732c: f8c1 0090    	str.w	r0, [r1, #0x90]
;                 eventHandleInt->pIaVintrRegs   = (volatile CSL_intaggr_intrRegs_vint *) NULL_PTR;
700a7330: 9900         	ldr	r1, [sp]
700a7332: f8c1 0094    	str.w	r0, [r1, #0x94]
;                 eventHandleInt->drvHandle      = (Udma_DrvHandleInt) NULL_PTR;
700a7336: 9900         	ldr	r1, [sp]
700a7338: 6008         	str	r0, [r1]
;             }
700a733a: e7ff         	b	0x700a733c <Udma_eventUnRegister+0xbc> @ imm = #-0x2
700a733c: e7ff         	b	0x700a733e <Udma_eventUnRegister+0xbe> @ imm = #-0x2
;     }
700a733e: e7ff         	b	0x700a7340 <Udma_eventUnRegister+0xc0> @ imm = #-0x2
;     return (retVal);
700a7340: 9802         	ldr	r0, [sp, #0x8]
700a7342: b004         	add	sp, #0x10
700a7344: bd80         	pop	{r7, pc}
		...
700a734e: 0000         	movs	r0, r0

700a7350 <Sciclient_rmIrqIsVintRouteSet>:
; {
700a7350: b580         	push	{r7, lr}
700a7352: b088         	sub	sp, #0x20
700a7354: 9007         	str	r0, [sp, #0x1c]
700a7356: 9106         	str	r1, [sp, #0x18]
700a7358: 2000         	movs	r0, #0x0
;     bool found_iface = false;
700a735a: f88d 0007    	strb.w	r0, [sp, #0x7]
;     *vint_used = false;
700a735e: 9906         	ldr	r1, [sp, #0x18]
700a7360: 7008         	strb	r0, [r1]
;     r = Sciclient_rmIrqGetNode(cfg->s_ia, &ia_node);
700a7362: 9807         	ldr	r0, [sp, #0x1c]
700a7364: 8a00         	ldrh	r0, [r0, #0x10]
700a7366: a903         	add	r1, sp, #0xc
700a7368: f7fe fdba    	bl	0x700a5ee0 <Sciclient_rmIrqGetNode> @ imm = #-0x148c
700a736c: 9005         	str	r0, [sp, #0x14]
;     if (r == SystemP_SUCCESS) {
700a736e: 9805         	ldr	r0, [sp, #0x14]
700a7370: bb90         	cbnz	r0, 0x700a73d8 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #0x64
700a7372: e7ff         	b	0x700a7374 <Sciclient_rmIrqIsVintRouteSet+0x24> @ imm = #-0x2
700a7374: 2000         	movs	r0, #0x0
;         for (i = 0U; i < ia_node->n_if; i++) {
700a7376: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a737a: e7ff         	b	0x700a737c <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x2
700a737c: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a7380: 9903         	ldr	r1, [sp, #0xc]
700a7382: 8849         	ldrh	r1, [r1, #0x2]
700a7384: 4288         	cmp	r0, r1
700a7386: da26         	bge	0x700a73d6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x4c
700a7388: e7ff         	b	0x700a738a <Sciclient_rmIrqIsVintRouteSet+0x3a> @ imm = #-0x2
;             r = Sciclient_rmIrqGetNodeItf(ia_node, i, &iface);
700a738a: 9803         	ldr	r0, [sp, #0xc]
700a738c: f8bd 1012    	ldrh.w	r1, [sp, #0x12]
700a7390: aa02         	add	r2, sp, #0x8
700a7392: f006 fb75    	bl	0x700ada80 <Sciclient_rmIrqGetNodeItf> @ imm = #0x66ea
700a7396: 9005         	str	r0, [sp, #0x14]
;             if (r != SystemP_SUCCESS) {
700a7398: 9805         	ldr	r0, [sp, #0x14]
700a739a: b108         	cbz	r0, 0x700a73a0 <Sciclient_rmIrqIsVintRouteSet+0x50> @ imm = #0x2
700a739c: e7ff         	b	0x700a739e <Sciclient_rmIrqIsVintRouteSet+0x4e> @ imm = #-0x2
;                 break;
700a739e: e01a         	b	0x700a73d6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0x34
;             if ((cfg->vint >= iface->lbase) &&
700a73a0: 9807         	ldr	r0, [sp, #0x1c]
700a73a2: 8a40         	ldrh	r0, [r0, #0x12]
700a73a4: 9902         	ldr	r1, [sp, #0x8]
700a73a6: 8809         	ldrh	r1, [r1]
700a73a8: 4288         	cmp	r0, r1
700a73aa: db0d         	blt	0x700a73c8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x1a
700a73ac: e7ff         	b	0x700a73ae <Sciclient_rmIrqIsVintRouteSet+0x5e> @ imm = #-0x2
;                 (cfg->vint < (iface->lbase + iface->len))) {
700a73ae: 9807         	ldr	r0, [sp, #0x1c]
700a73b0: 8a40         	ldrh	r0, [r0, #0x12]
700a73b2: 9a02         	ldr	r2, [sp, #0x8]
700a73b4: 8811         	ldrh	r1, [r2]
700a73b6: 8892         	ldrh	r2, [r2, #0x4]
700a73b8: 4411         	add	r1, r2
;             if ((cfg->vint >= iface->lbase) &&
700a73ba: 4288         	cmp	r0, r1
700a73bc: da04         	bge	0x700a73c8 <Sciclient_rmIrqIsVintRouteSet+0x78> @ imm = #0x8
700a73be: e7ff         	b	0x700a73c0 <Sciclient_rmIrqIsVintRouteSet+0x70> @ imm = #-0x2
700a73c0: 2001         	movs	r0, #0x1
;                 found_iface = true;
700a73c2: f88d 0007    	strb.w	r0, [sp, #0x7]
;                 break;
700a73c6: e006         	b	0x700a73d6 <Sciclient_rmIrqIsVintRouteSet+0x86> @ imm = #0xc
;         }
700a73c8: e7ff         	b	0x700a73ca <Sciclient_rmIrqIsVintRouteSet+0x7a> @ imm = #-0x2
;         for (i = 0U; i < ia_node->n_if; i++) {
700a73ca: f8bd 0012    	ldrh.w	r0, [sp, #0x12]
700a73ce: 3001         	adds	r0, #0x1
700a73d0: f8ad 0012    	strh.w	r0, [sp, #0x12]
700a73d4: e7d2         	b	0x700a737c <Sciclient_rmIrqIsVintRouteSet+0x2c> @ imm = #-0x5c
;     }
700a73d6: e7ff         	b	0x700a73d8 <Sciclient_rmIrqIsVintRouteSet+0x88> @ imm = #-0x2
;     if (found_iface) {
700a73d8: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a73dc: 07c0         	lsls	r0, r0, #0x1f
700a73de: b1b0         	cbz	r0, 0x700a740e <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #0x2c
700a73e0: e7ff         	b	0x700a73e2 <Sciclient_rmIrqIsVintRouteSet+0x92> @ imm = #-0x2
;         ir_inp = SCICLIENT_OUTP_TO_INP(cfg->vint, iface->lbase, iface->rbase);
700a73e2: 9a02         	ldr	r2, [sp, #0x8]
700a73e4: 8850         	ldrh	r0, [r2, #0x2]
700a73e6: 9907         	ldr	r1, [sp, #0x1c]
700a73e8: 8a49         	ldrh	r1, [r1, #0x12]
700a73ea: 8812         	ldrh	r2, [r2]
700a73ec: 1a89         	subs	r1, r1, r2
700a73ee: 4408         	add	r0, r1
700a73f0: f8ad 0004    	strh.w	r0, [sp, #0x4]
;         if (Sciclient_rmIrInpIsFree(iface->rid, ir_inp) != SystemP_SUCCESS) {
700a73f4: 9802         	ldr	r0, [sp, #0x8]
700a73f6: 88c0         	ldrh	r0, [r0, #0x6]
700a73f8: f8bd 1004    	ldrh.w	r1, [sp, #0x4]
700a73fc: f7fe ff38    	bl	0x700a6270 <Sciclient_rmIrInpIsFree> @ imm = #-0x1190
700a7400: b120         	cbz	r0, 0x700a740c <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #0x8
700a7402: e7ff         	b	0x700a7404 <Sciclient_rmIrqIsVintRouteSet+0xb4> @ imm = #-0x2
;             *vint_used = true;
700a7404: 9906         	ldr	r1, [sp, #0x18]
700a7406: 2001         	movs	r0, #0x1
700a7408: 7008         	strb	r0, [r1]
;         }
700a740a: e7ff         	b	0x700a740c <Sciclient_rmIrqIsVintRouteSet+0xbc> @ imm = #-0x2
;     }
700a740c: e7ff         	b	0x700a740e <Sciclient_rmIrqIsVintRouteSet+0xbe> @ imm = #-0x2
;     return r;
700a740e: 9805         	ldr	r0, [sp, #0x14]
700a7410: b008         	add	sp, #0x20
700a7412: bd80         	pop	{r7, pc}
		...

700a7420 <UART_flushTxFifo>:
; {
700a7420: b580         	push	{r7, lr}
700a7422: b08a         	sub	sp, #0x28
700a7424: 9009         	str	r0, [sp, #0x24]
700a7426: f640 30b8    	movw	r0, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700a742a: 9003         	str	r0, [sp, #0xc]
700a742c: 2000         	movs	r0, #0x0
;     uint32_t            timeoutElapsed  = FALSE;
700a742e: 9002         	str	r0, [sp, #0x8]
;     config = (UART_Config *) handle;
700a7430: 9809         	ldr	r0, [sp, #0x24]
700a7432: 9008         	str	r0, [sp, #0x20]
;     if (NULL != config)
700a7434: 9808         	ldr	r0, [sp, #0x20]
700a7436: 2800         	cmp	r0, #0x0
700a7438: d052         	beq	0x700a74e0 <UART_flushTxFifo+0xc0> @ imm = #0xa4
700a743a: e7ff         	b	0x700a743c <UART_flushTxFifo+0x1c> @ imm = #-0x2
;         attrs = config->attrs;
700a743c: 9808         	ldr	r0, [sp, #0x20]
700a743e: 6800         	ldr	r0, [r0]
700a7440: 9007         	str	r0, [sp, #0x1c]
;         DebugP_assert(NULL_PTR != attrs);
700a7442: 9807         	ldr	r0, [sp, #0x1c]
700a7444: 2800         	cmp	r0, #0x0
700a7446: bf18         	it	ne
700a7448: 2001         	movne	r0, #0x1
700a744a: f242 0117    	movw	r1, #0x2017
700a744e: f2c7 010b    	movt	r1, #0x700b
700a7452: 466a         	mov	r2, sp
700a7454: 6011         	str	r1, [r2]
700a7456: f641 71e1    	movw	r1, #0x1fe1
700a745a: f2c7 010b    	movt	r1, #0x700b
700a745e: f242 026e    	movw	r2, #0x206e
700a7462: f2c7 020b    	movt	r2, #0x700b
700a7466: f240 3355    	movw	r3, #0x355
700a746a: f003 fc09    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x3812
;         startTicks = ClockP_getTicks();
700a746e: f008 fc37    	bl	0x700afce0 <ClockP_getTicks> @ imm = #0x886e
700a7472: 9005         	str	r0, [sp, #0x14]
;         while (FALSE == timeoutElapsed)
700a7474: e7ff         	b	0x700a7476 <UART_flushTxFifo+0x56> @ imm = #-0x2
700a7476: 9802         	ldr	r0, [sp, #0x8]
700a7478: b9d8         	cbnz	r0, 0x700a74b2 <UART_flushTxFifo+0x92> @ imm = #0x36
700a747a: e7ff         	b	0x700a747c <UART_flushTxFifo+0x5c> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(attrs->baseAddr);
700a747c: 9807         	ldr	r0, [sp, #0x1c]
700a747e: 6800         	ldr	r0, [r0]
700a7480: f006 fd1e    	bl	0x700adec0 <UART_spaceAvail> @ imm = #0x6a3c
700a7484: 9006         	str	r0, [sp, #0x18]
;             if (TRUE == isTxFifoEmpty)
700a7486: 9806         	ldr	r0, [sp, #0x18]
700a7488: 2801         	cmp	r0, #0x1
700a748a: d101         	bne	0x700a7490 <UART_flushTxFifo+0x70> @ imm = #0x2
700a748c: e7ff         	b	0x700a748e <UART_flushTxFifo+0x6e> @ imm = #-0x2
;                 break;
700a748e: e010         	b	0x700a74b2 <UART_flushTxFifo+0x92> @ imm = #0x20
;             elapsedTicks = ClockP_getTicks() - startTicks;
700a7490: f008 fc26    	bl	0x700afce0 <ClockP_getTicks> @ imm = #0x884c
700a7494: 9905         	ldr	r1, [sp, #0x14]
700a7496: 1a40         	subs	r0, r0, r1
700a7498: 9004         	str	r0, [sp, #0x10]
;             if (elapsedTicks >= timeout)
700a749a: 9804         	ldr	r0, [sp, #0x10]
700a749c: 9903         	ldr	r1, [sp, #0xc]
700a749e: 4288         	cmp	r0, r1
700a74a0: d303         	blo	0x700a74aa <UART_flushTxFifo+0x8a> @ imm = #0x6
700a74a2: e7ff         	b	0x700a74a4 <UART_flushTxFifo+0x84> @ imm = #-0x2
700a74a4: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700a74a6: 9002         	str	r0, [sp, #0x8]
;             }
700a74a8: e002         	b	0x700a74b0 <UART_flushTxFifo+0x90> @ imm = #0x4
;                 TaskP_yield();
700a74aa: f008 fc51    	bl	0x700afd50 <TaskP_yield> @ imm = #0x88a2
700a74ae: e7ff         	b	0x700a74b0 <UART_flushTxFifo+0x90> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700a74b0: e7e1         	b	0x700a7476 <UART_flushTxFifo+0x56> @ imm = #-0x3e
;         DebugP_assert(FALSE == timeoutElapsed);
700a74b2: 9802         	ldr	r0, [sp, #0x8]
700a74b4: fab0 f080    	clz	r0, r0
700a74b8: 0940         	lsrs	r0, r0, #0x5
700a74ba: f641 61d3    	movw	r1, #0x1ed3
700a74be: f2c7 010b    	movt	r1, #0x700b
700a74c2: 466a         	mov	r2, sp
700a74c4: 6011         	str	r1, [r2]
700a74c6: f641 71e1    	movw	r1, #0x1fe1
700a74ca: f2c7 010b    	movt	r1, #0x700b
700a74ce: f242 026e    	movw	r2, #0x206e
700a74d2: f2c7 020b    	movt	r2, #0x700b
700a74d6: f240 336f    	movw	r3, #0x36f
700a74da: f003 fbd1    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x37a2
;     }
700a74de: e7ff         	b	0x700a74e0 <UART_flushTxFifo+0xc0> @ imm = #-0x2
;     return;
700a74e0: b00a         	add	sp, #0x28
700a74e2: bd80         	pop	{r7, pc}
		...

700a74f0 <Udma_chClose>:
; {
700a74f0: b580         	push	{r7, lr}
700a74f2: b084         	sub	sp, #0x10
700a74f4: 9003         	str	r0, [sp, #0xc]
700a74f6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a74f8: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a74fa: 9803         	ldr	r0, [sp, #0xc]
700a74fc: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a74fe: 9800         	ldr	r0, [sp]
700a7500: b150         	cbz	r0, 0x700a7518 <Udma_chClose+0x28> @ imm = #0x14
700a7502: e7ff         	b	0x700a7504 <Udma_chClose+0x14> @ imm = #-0x2
700a7504: 9800         	ldr	r0, [sp]
700a7506: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a750a: f64a 31cd    	movw	r1, #0xabcd
700a750e: f6ca 31dc    	movt	r1, #0xabdc
700a7512: 4288         	cmp	r0, r1
700a7514: d004         	beq	0x700a7520 <Udma_chClose+0x30> @ imm = #0x8
700a7516: e7ff         	b	0x700a7518 <Udma_chClose+0x28> @ imm = #-0x2
700a7518: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a751c: 9002         	str	r0, [sp, #0x8]
;     }
700a751e: e7ff         	b	0x700a7520 <Udma_chClose+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7520: 9802         	ldr	r0, [sp, #0x8]
700a7522: b9a8         	cbnz	r0, 0x700a7550 <Udma_chClose+0x60> @ imm = #0x2a
700a7524: e7ff         	b	0x700a7526 <Udma_chClose+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a7526: 9800         	ldr	r0, [sp]
700a7528: 6e80         	ldr	r0, [r0, #0x68]
700a752a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a752c: 9801         	ldr	r0, [sp, #0x4]
700a752e: b150         	cbz	r0, 0x700a7546 <Udma_chClose+0x56> @ imm = #0x14
700a7530: e7ff         	b	0x700a7532 <Udma_chClose+0x42> @ imm = #-0x2
700a7532: 9801         	ldr	r0, [sp, #0x4]
700a7534: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a7538: f64a 31cd    	movw	r1, #0xabcd
700a753c: f6ca 31dc    	movt	r1, #0xabdc
700a7540: 4288         	cmp	r0, r1
700a7542: d004         	beq	0x700a754e <Udma_chClose+0x5e> @ imm = #0x8
700a7544: e7ff         	b	0x700a7546 <Udma_chClose+0x56> @ imm = #-0x2
700a7546: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a754a: 9002         	str	r0, [sp, #0x8]
;         }
700a754c: e7ff         	b	0x700a754e <Udma_chClose+0x5e> @ imm = #-0x2
;     }
700a754e: e7ff         	b	0x700a7550 <Udma_chClose+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7550: 9802         	ldr	r0, [sp, #0x8]
700a7552: b958         	cbnz	r0, 0x700a756c <Udma_chClose+0x7c> @ imm = #0x16
700a7554: e7ff         	b	0x700a7556 <Udma_chClose+0x66> @ imm = #-0x2
;         if(TRUE == chHandleInt->chOesAllocDone)
700a7556: 9800         	ldr	r0, [sp]
700a7558: f8d0 0248    	ldr.w	r0, [r0, #0x248]
700a755c: 2801         	cmp	r0, #0x1
700a755e: d104         	bne	0x700a756a <Udma_chClose+0x7a> @ imm = #0x8
700a7560: e7ff         	b	0x700a7562 <Udma_chClose+0x72> @ imm = #-0x2
700a7562: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a7566: 9002         	str	r0, [sp, #0x8]
;         }
700a7568: e7ff         	b	0x700a756a <Udma_chClose+0x7a> @ imm = #-0x2
;     }
700a756a: e7ff         	b	0x700a756c <Udma_chClose+0x7c> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a756c: 9802         	ldr	r0, [sp, #0x8]
700a756e: b9e8         	cbnz	r0, 0x700a75ac <Udma_chClose+0xbc> @ imm = #0x3a
700a7570: e7ff         	b	0x700a7572 <Udma_chClose+0x82> @ imm = #-0x2
;         retVal = Udma_chUnpair(chHandleInt);
700a7572: 9800         	ldr	r0, [sp]
700a7574: f003 f9bc    	bl	0x700aa8f0 <Udma_chUnpair> @ imm = #0x3378
700a7578: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a757a: 9802         	ldr	r0, [sp, #0x8]
700a757c: b108         	cbz	r0, 0x700a7582 <Udma_chClose+0x92> @ imm = #0x2
700a757e: e7ff         	b	0x700a7580 <Udma_chClose+0x90> @ imm = #-0x2
;         }
700a7580: e7ff         	b	0x700a7582 <Udma_chClose+0x92> @ imm = #-0x2
;         retVal += Udma_chFreeResource(chHandleInt);
700a7582: 9800         	ldr	r0, [sp]
700a7584: f7f7 fd84    	bl	0x7009f090 <Udma_chFreeResource> @ imm = #-0x84f8
700a7588: 4601         	mov	r1, r0
700a758a: 9802         	ldr	r0, [sp, #0x8]
700a758c: 4408         	add	r0, r1
700a758e: 9002         	str	r0, [sp, #0x8]
;         if(UDMA_SOK != retVal)
700a7590: 9802         	ldr	r0, [sp, #0x8]
700a7592: b108         	cbz	r0, 0x700a7598 <Udma_chClose+0xa8> @ imm = #0x2
700a7594: e7ff         	b	0x700a7596 <Udma_chClose+0xa6> @ imm = #-0x2
;         }
700a7596: e7ff         	b	0x700a7598 <Udma_chClose+0xa8> @ imm = #-0x2
;         (void) memset(chHandleInt, 0, sizeof(*chHandleInt));
700a7598: 9800         	ldr	r0, [sp]
700a759a: f44f 7114    	mov.w	r1, #0x250
700a759e: f7f3 edba    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0xc48c
;         chHandleInt->chInitDone = UDMA_DEINIT_DONE;
700a75a2: 9900         	ldr	r1, [sp]
700a75a4: 2000         	movs	r0, #0x0
700a75a6: f8c1 0244    	str.w	r0, [r1, #0x244]
;     }
700a75aa: e7ff         	b	0x700a75ac <Udma_chClose+0xbc> @ imm = #-0x2
;     return (retVal);
700a75ac: 9802         	ldr	r0, [sp, #0x8]
700a75ae: b004         	add	sp, #0x10
700a75b0: bd80         	pop	{r7, pc}
		...
700a75be: 0000         	movs	r0, r0

700a75c0 <CSL_bcdmaChanOpAccessRemotePeerReg>:
; {
700a75c0: b580         	push	{r7, lr}
700a75c2: b08a         	sub	sp, #0x28
700a75c4: 4684         	mov	r12, r0
700a75c6: 980c         	ldr	r0, [sp, #0x30]
700a75c8: f8cd c024    	str.w	r12, [sp, #0x24]
700a75cc: 9108         	str	r1, [sp, #0x20]
700a75ce: 9207         	str	r2, [sp, #0x1c]
700a75d0: 9306         	str	r3, [sp, #0x18]
700a75d2: f88d 0017    	strb.w	r0, [sp, #0x17]
700a75d6: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a75d8: 9004         	str	r0, [sp, #0x10]
;     if( pOpData == NULL )
700a75da: 9806         	ldr	r0, [sp, #0x18]
700a75dc: b920         	cbnz	r0, 0x700a75e8 <CSL_bcdmaChanOpAccessRemotePeerReg+0x28> @ imm = #0x8
700a75de: e7ff         	b	0x700a75e0 <CSL_bcdmaChanOpAccessRemotePeerReg+0x20> @ imm = #-0x2
700a75e0: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a75e4: 9004         	str	r0, [sp, #0x10]
;     }
700a75e6: e048         	b	0x700a767a <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #0x90
700a75e8: 2000         	movs	r0, #0x0
;         uint32_t *pRemotePeerReg = NULL;
700a75ea: 9003         	str	r0, [sp, #0xc]
;         switch( chanType )
700a75ec: 9808         	ldr	r0, [sp, #0x20]
700a75ee: 9001         	str	r0, [sp, #0x4]
700a75f0: 2801         	cmp	r0, #0x1
700a75f2: d004         	beq	0x700a75fe <CSL_bcdmaChanOpAccessRemotePeerReg+0x3e> @ imm = #0x8
700a75f4: e7ff         	b	0x700a75f6 <CSL_bcdmaChanOpAccessRemotePeerReg+0x36> @ imm = #-0x2
700a75f6: 9801         	ldr	r0, [sp, #0x4]
700a75f8: 2802         	cmp	r0, #0x2
700a75fa: d009         	beq	0x700a7610 <CSL_bcdmaChanOpAccessRemotePeerReg+0x50> @ imm = #0x12
700a75fc: e011         	b	0x700a7622 <CSL_bcdmaChanOpAccessRemotePeerReg+0x62> @ imm = #0x22
;                 pRemotePeerReg = (uint32_t *)&pCfg->pTxChanRtRegs->CHAN[chanIdx].PEER0;
700a75fe: 9809         	ldr	r0, [sp, #0x24]
700a7600: 6900         	ldr	r0, [r0, #0x10]
700a7602: 9907         	ldr	r1, [sp, #0x1c]
700a7604: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a7608: f500 7000    	add.w	r0, r0, #0x200
700a760c: 9003         	str	r0, [sp, #0xc]
;                 break;
700a760e: e00c         	b	0x700a762a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x18
;                 pRemotePeerReg = (uint32_t *)&pCfg->pRxChanRtRegs->CHAN[chanIdx].PEER0;
700a7610: 9809         	ldr	r0, [sp, #0x24]
700a7612: 6980         	ldr	r0, [r0, #0x18]
700a7614: 9907         	ldr	r1, [sp, #0x1c]
700a7616: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a761a: f500 7000    	add.w	r0, r0, #0x200
700a761e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a7620: e003         	b	0x700a762a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #0x6
700a7622: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a7626: 9004         	str	r0, [sp, #0x10]
;                 break;
700a7628: e7ff         	b	0x700a762a <CSL_bcdmaChanOpAccessRemotePeerReg+0x6a> @ imm = #-0x2
;         if( pRemotePeerReg != NULL )
700a762a: 9803         	ldr	r0, [sp, #0xc]
700a762c: b320         	cbz	r0, 0x700a7678 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #0x48
700a762e: e7ff         	b	0x700a7630 <CSL_bcdmaChanOpAccessRemotePeerReg+0x70> @ imm = #-0x2
;             CSL_BcdmaRemotePeerOpts *pPeerOpts = (CSL_BcdmaRemotePeerOpts *)pOpData;
700a7630: 9806         	ldr	r0, [sp, #0x18]
700a7632: 9002         	str	r0, [sp, #0x8]
;             if( pPeerOpts->regIdx >= (uint32_t)16u )
700a7634: 9802         	ldr	r0, [sp, #0x8]
700a7636: 6800         	ldr	r0, [r0]
700a7638: 2810         	cmp	r0, #0x10
700a763a: d304         	blo	0x700a7646 <CSL_bcdmaChanOpAccessRemotePeerReg+0x86> @ imm = #0x8
700a763c: e7ff         	b	0x700a763e <CSL_bcdmaChanOpAccessRemotePeerReg+0x7e> @ imm = #-0x2
700a763e: f06f 0002    	mvn	r0, #0x2
;                 retVal = CSL_EINVALID_PARAMS;
700a7642: 9004         	str	r0, [sp, #0x10]
;             }
700a7644: e017         	b	0x700a7676 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #0x2e
;                 pRemotePeerReg += pPeerOpts->regIdx;    /* Increment to specified peer register */
700a7646: 9802         	ldr	r0, [sp, #0x8]
700a7648: 6801         	ldr	r1, [r0]
700a764a: 9803         	ldr	r0, [sp, #0xc]
700a764c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7650: 9003         	str	r0, [sp, #0xc]
;                 if( bRead == (bool)true )
700a7652: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a7656: 07c0         	lsls	r0, r0, #0x1f
700a7658: b130         	cbz	r0, 0x700a7668 <CSL_bcdmaChanOpAccessRemotePeerReg+0xa8> @ imm = #0xc
700a765a: e7ff         	b	0x700a765c <CSL_bcdmaChanOpAccessRemotePeerReg+0x9c> @ imm = #-0x2
;                     pPeerOpts->regVal = CSL_REG32_RD( pRemotePeerReg );
700a765c: 9803         	ldr	r0, [sp, #0xc]
700a765e: f008 facf    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0x859e
700a7662: 9902         	ldr	r1, [sp, #0x8]
700a7664: 6048         	str	r0, [r1, #0x4]
;                 }
700a7666: e005         	b	0x700a7674 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #0xa
;                     CSL_REG32_WR( pRemotePeerReg, pPeerOpts->regVal );
700a7668: 9803         	ldr	r0, [sp, #0xc]
700a766a: 9902         	ldr	r1, [sp, #0x8]
700a766c: 6849         	ldr	r1, [r1, #0x4]
700a766e: f7f4 fe0f    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xb3e2
700a7672: e7ff         	b	0x700a7674 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb4> @ imm = #-0x2
700a7674: e7ff         	b	0x700a7676 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb6> @ imm = #-0x2
;         }
700a7676: e7ff         	b	0x700a7678 <CSL_bcdmaChanOpAccessRemotePeerReg+0xb8> @ imm = #-0x2
700a7678: e7ff         	b	0x700a767a <CSL_bcdmaChanOpAccessRemotePeerReg+0xba> @ imm = #-0x2
;     return retVal;
700a767a: 9804         	ldr	r0, [sp, #0x10]
700a767c: b00a         	add	sp, #0x28
700a767e: bd80         	pop	{r7, pc}

700a7680 <_out_rev>:
; {
700a7680: b580         	push	{r7, lr}
700a7682: b086         	sub	sp, #0x18
700a7684: f8dd c02c    	ldr.w	r12, [sp, #0x2c]
700a7688: f8dd c028    	ldr.w	r12, [sp, #0x28]
700a768c: f8dd c024    	ldr.w	r12, [sp, #0x24]
700a7690: f8dd c020    	ldr.w	r12, [sp, #0x20]
700a7694: 9005         	str	r0, [sp, #0x14]
700a7696: 9104         	str	r1, [sp, #0x10]
700a7698: 9203         	str	r2, [sp, #0xc]
700a769a: 9302         	str	r3, [sp, #0x8]
;   const size_t start_idx = idx;
700a769c: 9803         	ldr	r0, [sp, #0xc]
700a769e: 9001         	str	r0, [sp, #0x4]
;   if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
700a76a0: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a76a4: 0780         	lsls	r0, r0, #0x1e
700a76a6: 2800         	cmp	r0, #0x0
700a76a8: d41c         	bmi	0x700a76e4 <_out_rev+0x64> @ imm = #0x38
700a76aa: e7ff         	b	0x700a76ac <_out_rev+0x2c> @ imm = #-0x2
700a76ac: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a76b0: 07c0         	lsls	r0, r0, #0x1f
700a76b2: b9b8         	cbnz	r0, 0x700a76e4 <_out_rev+0x64> @ imm = #0x2e
700a76b4: e7ff         	b	0x700a76b6 <_out_rev+0x36> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a76b6: 9809         	ldr	r0, [sp, #0x24]
700a76b8: 9000         	str	r0, [sp]
700a76ba: e7ff         	b	0x700a76bc <_out_rev+0x3c> @ imm = #-0x2
700a76bc: 9800         	ldr	r0, [sp]
700a76be: 990a         	ldr	r1, [sp, #0x28]
700a76c0: 4288         	cmp	r0, r1
700a76c2: d20e         	bhs	0x700a76e2 <_out_rev+0x62> @ imm = #0x1c
700a76c4: e7ff         	b	0x700a76c6 <_out_rev+0x46> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a76c6: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a76ca: 9904         	ldr	r1, [sp, #0x10]
700a76cc: 9a03         	ldr	r2, [sp, #0xc]
700a76ce: 1c50         	adds	r0, r2, #0x1
700a76d0: 9003         	str	r0, [sp, #0xc]
700a76d2: 9b02         	ldr	r3, [sp, #0x8]
700a76d4: 2020         	movs	r0, #0x20
700a76d6: 47e0         	blx	r12
;     }
700a76d8: e7ff         	b	0x700a76da <_out_rev+0x5a> @ imm = #-0x2
;     for (i = len; i < width; i++) {
700a76da: 9800         	ldr	r0, [sp]
700a76dc: 3001         	adds	r0, #0x1
700a76de: 9000         	str	r0, [sp]
700a76e0: e7ec         	b	0x700a76bc <_out_rev+0x3c> @ imm = #-0x28
;   }
700a76e2: e7ff         	b	0x700a76e4 <_out_rev+0x64> @ imm = #-0x2
;   while (len) {
700a76e4: e7ff         	b	0x700a76e6 <_out_rev+0x66> @ imm = #-0x2
700a76e6: 9809         	ldr	r0, [sp, #0x24]
700a76e8: b170         	cbz	r0, 0x700a7708 <_out_rev+0x88> @ imm = #0x1c
700a76ea: e7ff         	b	0x700a76ec <_out_rev+0x6c> @ imm = #-0x2
;     out(buf[--len], buffer, idx++, maxlen);
700a76ec: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a76f0: 9808         	ldr	r0, [sp, #0x20]
700a76f2: 9909         	ldr	r1, [sp, #0x24]
700a76f4: 3901         	subs	r1, #0x1
700a76f6: 9109         	str	r1, [sp, #0x24]
700a76f8: 5c40         	ldrb	r0, [r0, r1]
700a76fa: 9904         	ldr	r1, [sp, #0x10]
700a76fc: 9a03         	ldr	r2, [sp, #0xc]
700a76fe: 1c53         	adds	r3, r2, #0x1
700a7700: 9303         	str	r3, [sp, #0xc]
700a7702: 9b02         	ldr	r3, [sp, #0x8]
700a7704: 47e0         	blx	r12
;   while (len) {
700a7706: e7ee         	b	0x700a76e6 <_out_rev+0x66> @ imm = #-0x24
;   if (flags & FLAGS_LEFT) {
700a7708: f89d 002c    	ldrb.w	r0, [sp, #0x2c]
700a770c: 0780         	lsls	r0, r0, #0x1e
700a770e: 2800         	cmp	r0, #0x0
700a7710: d513         	bpl	0x700a773a <_out_rev+0xba> @ imm = #0x26
700a7712: e7ff         	b	0x700a7714 <_out_rev+0x94> @ imm = #-0x2
;     while (idx - start_idx < width) {
700a7714: e7ff         	b	0x700a7716 <_out_rev+0x96> @ imm = #-0x2
700a7716: 9803         	ldr	r0, [sp, #0xc]
700a7718: 9901         	ldr	r1, [sp, #0x4]
700a771a: 1a40         	subs	r0, r0, r1
700a771c: 990a         	ldr	r1, [sp, #0x28]
700a771e: 4288         	cmp	r0, r1
700a7720: d20a         	bhs	0x700a7738 <_out_rev+0xb8> @ imm = #0x14
700a7722: e7ff         	b	0x700a7724 <_out_rev+0xa4> @ imm = #-0x2
;       out(' ', buffer, idx++, maxlen);
700a7724: f8dd c014    	ldr.w	r12, [sp, #0x14]
700a7728: 9904         	ldr	r1, [sp, #0x10]
700a772a: 9a03         	ldr	r2, [sp, #0xc]
700a772c: 1c50         	adds	r0, r2, #0x1
700a772e: 9003         	str	r0, [sp, #0xc]
700a7730: 9b02         	ldr	r3, [sp, #0x8]
700a7732: 2020         	movs	r0, #0x20
700a7734: 47e0         	blx	r12
;     while (idx - start_idx < width) {
700a7736: e7ee         	b	0x700a7716 <_out_rev+0x96> @ imm = #-0x24
;   }
700a7738: e7ff         	b	0x700a773a <_out_rev+0xba> @ imm = #-0x2
;   return idx;
700a773a: 9803         	ldr	r0, [sp, #0xc]
700a773c: b006         	add	sp, #0x18
700a773e: bd80         	pop	{r7, pc}

700a7740 <vTaskStartScheduler>:
; void vTaskStartScheduler(void) {
700a7740: b580         	push	{r7, lr}
700a7742: b088         	sub	sp, #0x20
700a7744: 2000         	movs	r0, #0x0
;     StaticTask_t *pxIdleTaskTCBBuffer = NULL;
700a7746: 9003         	str	r0, [sp, #0xc]
700a7748: 9006         	str	r0, [sp, #0x18]
;     StackType_t *pxIdleTaskStackBuffer = NULL;
700a774a: 9005         	str	r0, [sp, #0x14]
700a774c: a806         	add	r0, sp, #0x18
700a774e: a905         	add	r1, sp, #0x14
700a7750: aa04         	add	r2, sp, #0x10
;     vApplicationGetIdleTaskMemory(&pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer,
700a7752: f007 faa5    	bl	0x700aeca0 <vApplicationGetIdleTaskMemory> @ imm = #0x754a
700a7756: 9b03         	ldr	r3, [sp, #0xc]
;         prvIdleTask, configIDLE_TASK_NAME, ulIdleTaskStackSize,
700a7758: 9a04         	ldr	r2, [sp, #0x10]
;         pxIdleTaskStackBuffer,
700a775a: 9905         	ldr	r1, [sp, #0x14]
;         pxIdleTaskTCBBuffer); /*lint !e961 MISRA exception, justified as it is
700a775c: f8dd c018    	ldr.w	r12, [sp, #0x18]
;     xIdleTaskHandle = xTaskCreateStatic(
700a7760: 4668         	mov	r0, sp
700a7762: f8c0 c008    	str.w	r12, [r0, #0x8]
700a7766: 6041         	str	r1, [r0, #0x4]
700a7768: 6003         	str	r3, [r0]
700a776a: f64c 7041    	movw	r0, #0xcf41
700a776e: f2c7 000a    	movt	r0, #0x700a
700a7772: f242 6120    	movw	r1, #0x2620
700a7776: f2c7 010b    	movt	r1, #0x700b
700a777a: f003 fe01    	bl	0x700ab380 <xTaskCreateStatic> @ imm = #0x3c02
700a777e: 4601         	mov	r1, r0
700a7780: f642 2030    	movw	r0, #0x2a30
700a7784: f2c7 000b    	movt	r0, #0x700b
700a7788: 6001         	str	r1, [r0]
;     if (xIdleTaskHandle != NULL) {
700a778a: 6800         	ldr	r0, [r0]
700a778c: b118         	cbz	r0, 0x700a7796 <vTaskStartScheduler+0x56> @ imm = #0x6
700a778e: e7ff         	b	0x700a7790 <vTaskStartScheduler+0x50> @ imm = #-0x2
700a7790: 2001         	movs	r0, #0x1
;       xReturn = pdPASS;
700a7792: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a7794: e002         	b	0x700a779c <vTaskStartScheduler+0x5c> @ imm = #0x4
700a7796: 2000         	movs	r0, #0x0
;       xReturn = pdFAIL;
700a7798: 9007         	str	r0, [sp, #0x1c]
700a779a: e7ff         	b	0x700a779c <vTaskStartScheduler+0x5c> @ imm = #-0x2
;     if (xReturn == pdPASS) {
700a779c: 9807         	ldr	r0, [sp, #0x1c]
700a779e: 2801         	cmp	r0, #0x1
700a77a0: d104         	bne	0x700a77ac <vTaskStartScheduler+0x6c> @ imm = #0x8
700a77a2: e7ff         	b	0x700a77a4 <vTaskStartScheduler+0x64> @ imm = #-0x2
;       xReturn = xTimerCreateTimerTask();
700a77a4: f003 fb6c    	bl	0x700aae80 <xTimerCreateTimerTask> @ imm = #0x36d8
700a77a8: 9007         	str	r0, [sp, #0x1c]
;     } else {
700a77aa: e000         	b	0x700a77ae <vTaskStartScheduler+0x6e> @ imm = #0x0
700a77ac: e7ff         	b	0x700a77ae <vTaskStartScheduler+0x6e> @ imm = #-0x2
;   if (xReturn == pdPASS) {
700a77ae: 9807         	ldr	r0, [sp, #0x1c]
700a77b0: 2801         	cmp	r0, #0x1
700a77b2: d11d         	bne	0x700a77f0 <vTaskStartScheduler+0xb0> @ imm = #0x3a
700a77b4: e7ff         	b	0x700a77b6 <vTaskStartScheduler+0x76> @ imm = #-0x2
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700a77b6: b672         	cpsid i
;     xNextTaskUnblockTime = portMAX_DELAY;
700a77b8: f642 2134    	movw	r1, #0x2a34
700a77bc: f2c7 010b    	movt	r1, #0x700b
700a77c0: f04f 30ff    	mov.w	r0, #0xffffffff
700a77c4: 6008         	str	r0, [r1]
;     xSchedulerRunning = pdTRUE;
700a77c6: f642 2140    	movw	r1, #0x2a40
700a77ca: f2c7 010b    	movt	r1, #0x700b
700a77ce: 2001         	movs	r0, #0x1
700a77d0: 6008         	str	r0, [r1]
;     xTickCount = (TickType_t)configINITIAL_TICK_COUNT;
700a77d2: f642 2144    	movw	r1, #0x2a44
700a77d6: f2c7 010b    	movt	r1, #0x700b
700a77da: 2000         	movs	r0, #0x0
700a77dc: 6008         	str	r0, [r1]
;     portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
700a77de: f008 faff    	bl	0x700afde0 <vPortConfigTimerForRunTimeStats> @ imm = #0x85fe
;     if (xPortStartScheduler() != pdFALSE) {
700a77e2: f007 fe9d    	bl	0x700af520 <xPortStartScheduler> @ imm = #0x7d3a
700a77e6: b108         	cbz	r0, 0x700a77ec <vTaskStartScheduler+0xac> @ imm = #0x2
700a77e8: e7ff         	b	0x700a77ea <vTaskStartScheduler+0xaa> @ imm = #-0x2
;     } else {
700a77ea: e000         	b	0x700a77ee <vTaskStartScheduler+0xae> @ imm = #0x0
700a77ec: e7ff         	b	0x700a77ee <vTaskStartScheduler+0xae> @ imm = #-0x2
;   } else {
700a77ee: e000         	b	0x700a77f2 <vTaskStartScheduler+0xb2> @ imm = #0x0
700a77f0: e7ff         	b	0x700a77f2 <vTaskStartScheduler+0xb2> @ imm = #-0x2
;   (void)uxTopUsedPriority;
700a77f2: f242 6060    	movw	r0, #0x2660
700a77f6: f2c7 000b    	movt	r0, #0x700b
700a77fa: 6800         	ldr	r0, [r0]
; }
700a77fc: b008         	add	sp, #0x20
700a77fe: bd80         	pop	{r7, pc}

700a7800 <PMU_profilePrintEntry>:
; void PMU_profilePrintEntry(const char *name) {
700a7800: b580         	push	{r7, lr}
700a7802: b086         	sub	sp, #0x18
700a7804: 9005         	str	r0, [sp, #0x14]
700a7806: 2000         	movs	r0, #0x0
;   for (i = 0; i < gProfileObject.logIndex; i++) {
700a7808: 9004         	str	r0, [sp, #0x10]
700a780a: e7ff         	b	0x700a780c <PMU_profilePrintEntry+0xc> @ imm = #-0x2
700a780c: 9804         	ldr	r0, [sp, #0x10]
700a780e: f243 0180    	movw	r1, #0x3080
700a7812: f2c7 0108    	movt	r1, #0x7008
700a7816: 6809         	ldr	r1, [r1]
700a7818: 4288         	cmp	r0, r1
700a781a: d24d         	bhs	0x700a78b8 <PMU_profilePrintEntry+0xb8> @ imm = #0x9a
700a781c: e7ff         	b	0x700a781e <PMU_profilePrintEntry+0x1e> @ imm = #-0x2
;     PMU_ProfilePoint *p = &gProfileObject.point[i];
700a781e: 9804         	ldr	r0, [sp, #0x10]
700a7820: f243 0280    	movw	r2, #0x3080
700a7824: f2c7 0208    	movt	r2, #0x7008
700a7828: 2134         	movs	r1, #0x34
700a782a: fb00 2001    	mla	r0, r0, r1, r2
700a782e: 300c         	adds	r0, #0xc
700a7830: 9002         	str	r0, [sp, #0x8]
;     if (strcmp(name, p->name) == 0) {
700a7832: 9805         	ldr	r0, [sp, #0x14]
700a7834: 9902         	ldr	r1, [sp, #0x8]
700a7836: 6b09         	ldr	r1, [r1, #0x30]
700a7838: f7f4 ed32    	blx	0x7009c2a0 <strcmp>     @ imm = #-0xb59c
700a783c: bbb8         	cbnz	r0, 0x700a78ae <PMU_profilePrintEntry+0xae> @ imm = #0x6e
700a783e: e7ff         	b	0x700a7840 <PMU_profilePrintEntry+0x40> @ imm = #-0x2
;       DebugP_log("Profile Point: %-32s\r\n", p->name);
700a7840: 9802         	ldr	r0, [sp, #0x8]
700a7842: 6b02         	ldr	r2, [r0, #0x30]
700a7844: f641 711b    	movw	r1, #0x1f1b
700a7848: f2c7 010b    	movt	r1, #0x700b
700a784c: 2001         	movs	r0, #0x1
700a784e: 9001         	str	r0, [sp, #0x4]
700a7850: f002 fa5e    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0x24bc
700a7854: 9801         	ldr	r0, [sp, #0x4]
;       DebugP_log("Cycle Count: %lu\r\n", p->cycleCount.value);
700a7856: 9902         	ldr	r1, [sp, #0x8]
700a7858: 6aca         	ldr	r2, [r1, #0x2c]
700a785a: f641 7195    	movw	r1, #0x1f95
700a785e: f2c7 010b    	movt	r1, #0x700b
700a7862: f002 fa55    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0x24aa
700a7866: 2000         	movs	r0, #0x0
;       for (j = 0; j < PMU_MAX_EVENT_COUNTERS; j++) {
700a7868: 9003         	str	r0, [sp, #0xc]
700a786a: e7ff         	b	0x700a786c <PMU_profilePrintEntry+0x6c> @ imm = #-0x2
700a786c: 9803         	ldr	r0, [sp, #0xc]
700a786e: 2802         	cmp	r0, #0x2
700a7870: d815         	bhi	0x700a789e <PMU_profilePrintEntry+0x9e> @ imm = #0x2a
700a7872: e7ff         	b	0x700a7874 <PMU_profilePrintEntry+0x74> @ imm = #-0x2
;         DebugP_log("%s Count: %lu\r\n", p->events[j].name, p->events[j].value);
700a7874: 9902         	ldr	r1, [sp, #0x8]
700a7876: 9803         	ldr	r0, [sp, #0xc]
700a7878: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a787c: eb01 0082    	add.w	r0, r1, r2, lsl #2
700a7880: f851 2022    	ldr.w	r2, [r1, r2, lsl #2]
700a7884: 6883         	ldr	r3, [r0, #0x8]
700a7886: f242 01a1    	movw	r1, #0x20a1
700a788a: f2c7 010b    	movt	r1, #0x700b
700a788e: 2001         	movs	r0, #0x1
700a7890: f002 fa3e    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0x247c
;       }
700a7894: e7ff         	b	0x700a7896 <PMU_profilePrintEntry+0x96> @ imm = #-0x2
;       for (j = 0; j < PMU_MAX_EVENT_COUNTERS; j++) {
700a7896: 9803         	ldr	r0, [sp, #0xc]
700a7898: 3001         	adds	r0, #0x1
700a789a: 9003         	str	r0, [sp, #0xc]
700a789c: e7e6         	b	0x700a786c <PMU_profilePrintEntry+0x6c> @ imm = #-0x34
;       DebugP_log("\r\n");
700a789e: f241 7101    	movw	r1, #0x1701
700a78a2: f2c7 010b    	movt	r1, #0x700b
700a78a6: 2001         	movs	r0, #0x1
700a78a8: f002 fa32    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0x2464
;       break;
700a78ac: e004         	b	0x700a78b8 <PMU_profilePrintEntry+0xb8> @ imm = #0x8
;   }
700a78ae: e7ff         	b	0x700a78b0 <PMU_profilePrintEntry+0xb0> @ imm = #-0x2
;   for (i = 0; i < gProfileObject.logIndex; i++) {
700a78b0: 9804         	ldr	r0, [sp, #0x10]
700a78b2: 3001         	adds	r0, #0x1
700a78b4: 9004         	str	r0, [sp, #0x10]
700a78b6: e7a9         	b	0x700a780c <PMU_profilePrintEntry+0xc> @ imm = #-0xae
; }
700a78b8: b006         	add	sp, #0x18
700a78ba: bd80         	pop	{r7, pc}
700a78bc: 0000         	movs	r0, r0
700a78be: 0000         	movs	r0, r0

700a78c0 <prvSwitchTimerLists>:
;     {
700a78c0: b580         	push	{r7, lr}
700a78c2: b086         	sub	sp, #0x18
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a78c4: e7ff         	b	0x700a78c6 <prvSwitchTimerLists+0x6> @ imm = #-0x2
700a78c6: f245 209c    	movw	r0, #0x529c
700a78ca: f2c7 0008    	movt	r0, #0x7008
700a78ce: 6800         	ldr	r0, [r0]
700a78d0: 6800         	ldr	r0, [r0]
700a78d2: 2800         	cmp	r0, #0x0
700a78d4: d040         	beq	0x700a7958 <prvSwitchTimerLists+0x98> @ imm = #0x80
700a78d6: e7ff         	b	0x700a78d8 <prvSwitchTimerLists+0x18> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700a78d8: f245 209c    	movw	r0, #0x529c
700a78dc: f2c7 0008    	movt	r0, #0x7008
700a78e0: 6801         	ldr	r1, [r0]
700a78e2: 68c9         	ldr	r1, [r1, #0xc]
700a78e4: 6809         	ldr	r1, [r1]
700a78e6: 9105         	str	r1, [sp, #0x14]
;             pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700a78e8: 6800         	ldr	r0, [r0]
700a78ea: 68c0         	ldr	r0, [r0, #0xc]
700a78ec: 68c0         	ldr	r0, [r0, #0xc]
700a78ee: 9002         	str	r0, [sp, #0x8]
;             ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700a78f0: 9802         	ldr	r0, [sp, #0x8]
700a78f2: 3004         	adds	r0, #0x4
700a78f4: f005 ff0c    	bl	0x700ad710 <uxListRemove> @ imm = #0x5e18
;             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700a78f8: 9802         	ldr	r0, [sp, #0x8]
700a78fa: 6a01         	ldr	r1, [r0, #0x20]
700a78fc: 4788         	blx	r1
;             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700a78fe: 9802         	ldr	r0, [sp, #0x8]
700a7900: f890 0028    	ldrb.w	r0, [r0, #0x28]
700a7904: 0740         	lsls	r0, r0, #0x1d
700a7906: 2800         	cmp	r0, #0x0
700a7908: d524         	bpl	0x700a7954 <prvSwitchTimerLists+0x94> @ imm = #0x48
700a790a: e7ff         	b	0x700a790c <prvSwitchTimerLists+0x4c> @ imm = #-0x2
;                 xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
700a790c: 9805         	ldr	r0, [sp, #0x14]
700a790e: 9902         	ldr	r1, [sp, #0x8]
700a7910: 6989         	ldr	r1, [r1, #0x18]
700a7912: 4408         	add	r0, r1
700a7914: 9004         	str	r0, [sp, #0x10]
;                 if( xReloadTime > xNextExpireTime )
700a7916: 9804         	ldr	r0, [sp, #0x10]
700a7918: 9905         	ldr	r1, [sp, #0x14]
700a791a: 4288         	cmp	r0, r1
700a791c: d90f         	bls	0x700a793e <prvSwitchTimerLists+0x7e> @ imm = #0x1e
700a791e: e7ff         	b	0x700a7920 <prvSwitchTimerLists+0x60> @ imm = #-0x2
;                     listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
700a7920: 9804         	ldr	r0, [sp, #0x10]
700a7922: 9902         	ldr	r1, [sp, #0x8]
700a7924: 6048         	str	r0, [r1, #0x4]
;                     listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700a7926: 9802         	ldr	r0, [sp, #0x8]
700a7928: 6100         	str	r0, [r0, #0x10]
;                     vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700a792a: f245 209c    	movw	r0, #0x529c
700a792e: f2c7 0008    	movt	r0, #0x7008
700a7932: 6800         	ldr	r0, [r0]
700a7934: 9902         	ldr	r1, [sp, #0x8]
700a7936: 3104         	adds	r1, #0x4
700a7938: f003 ff5a    	bl	0x700ab7f0 <vListInsert> @ imm = #0x3eb4
;                 }
700a793c: e009         	b	0x700a7952 <prvSwitchTimerLists+0x92> @ imm = #0x12
;                     xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700a793e: 9802         	ldr	r0, [sp, #0x8]
700a7940: 9a05         	ldr	r2, [sp, #0x14]
700a7942: 4669         	mov	r1, sp
700a7944: 2300         	movs	r3, #0x0
700a7946: 600b         	str	r3, [r1]
700a7948: 4619         	mov	r1, r3
700a794a: f002 f8f1    	bl	0x700a9b30 <xTimerGenericCommand> @ imm = #0x21e2
700a794e: 9001         	str	r0, [sp, #0x4]
700a7950: e7ff         	b	0x700a7952 <prvSwitchTimerLists+0x92> @ imm = #-0x2
;             }
700a7952: e000         	b	0x700a7956 <prvSwitchTimerLists+0x96> @ imm = #0x0
700a7954: e7ff         	b	0x700a7956 <prvSwitchTimerLists+0x96> @ imm = #-0x2
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
700a7956: e7b6         	b	0x700a78c6 <prvSwitchTimerLists+0x6> @ imm = #-0x94
;         pxTemp = pxCurrentTimerList;
700a7958: f245 229c    	movw	r2, #0x529c
700a795c: f2c7 0208    	movt	r2, #0x7008
700a7960: 6810         	ldr	r0, [r2]
700a7962: 9003         	str	r0, [sp, #0xc]
;         pxCurrentTimerList = pxOverflowTimerList;
700a7964: f245 21a8    	movw	r1, #0x52a8
700a7968: f2c7 0108    	movt	r1, #0x7008
700a796c: 6808         	ldr	r0, [r1]
700a796e: 6010         	str	r0, [r2]
;         pxOverflowTimerList = pxTemp;
700a7970: 9803         	ldr	r0, [sp, #0xc]
700a7972: 6008         	str	r0, [r1]
;     }
700a7974: b006         	add	sp, #0x18
700a7976: bd80         	pop	{r7, pc}
		...

700a7980 <CSL_pktdmaAccessChanPeerReg>:
; {
700a7980: b580         	push	{r7, lr}
700a7982: b088         	sub	sp, #0x20
700a7984: 4684         	mov	r12, r0
700a7986: 980b         	ldr	r0, [sp, #0x2c]
700a7988: f8dd e028    	ldr.w	lr, [sp, #0x28]
700a798c: f8cd c01c    	str.w	r12, [sp, #0x1c]
700a7990: 9106         	str	r1, [sp, #0x18]
700a7992: 9205         	str	r2, [sp, #0x14]
700a7994: 9304         	str	r3, [sp, #0x10]
700a7996: f88d 000f    	strb.w	r0, [sp, #0xf]
700a799a: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a799c: 9002         	str	r0, [sp, #0x8]
;     if( (pCfg == NULL) || (pVal == NULL) || (CSL_pktdmaIsValidChanIdx( pCfg, chanIdx, chanDir) == (bool)false) )
700a799e: 9807         	ldr	r0, [sp, #0x1c]
700a79a0: b150         	cbz	r0, 0x700a79b8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0x14
700a79a2: e7ff         	b	0x700a79a4 <CSL_pktdmaAccessChanPeerReg+0x24> @ imm = #-0x2
700a79a4: 9804         	ldr	r0, [sp, #0x10]
700a79a6: b138         	cbz	r0, 0x700a79b8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #0xe
700a79a8: e7ff         	b	0x700a79aa <CSL_pktdmaAccessChanPeerReg+0x2a> @ imm = #-0x2
700a79aa: 9807         	ldr	r0, [sp, #0x1c]
700a79ac: 9906         	ldr	r1, [sp, #0x18]
700a79ae: 9a0a         	ldr	r2, [sp, #0x28]
700a79b0: f005 fa06    	bl	0x700acdc0 <CSL_pktdmaIsValidChanIdx> @ imm = #0x540c
700a79b4: b920         	cbnz	r0, 0x700a79c0 <CSL_pktdmaAccessChanPeerReg+0x40> @ imm = #0x8
700a79b6: e7ff         	b	0x700a79b8 <CSL_pktdmaAccessChanPeerReg+0x38> @ imm = #-0x2
700a79b8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a79bc: 9002         	str	r0, [sp, #0x8]
;     }
700a79be: e037         	b	0x700a7a30 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #0x6e
;         if( regIdx < CSL_PKTDMA_NUM_PEER_REGS )
700a79c0: 9805         	ldr	r0, [sp, #0x14]
700a79c2: 280f         	cmp	r0, #0xf
700a79c4: d82f         	bhi	0x700a7a26 <CSL_pktdmaAccessChanPeerReg+0xa6> @ imm = #0x5e
700a79c6: e7ff         	b	0x700a79c8 <CSL_pktdmaAccessChanPeerReg+0x48> @ imm = #-0x2
;             if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700a79c8: 980a         	ldr	r0, [sp, #0x28]
700a79ca: b960         	cbnz	r0, 0x700a79e6 <CSL_pktdmaAccessChanPeerReg+0x66> @ imm = #0x18
700a79cc: e7ff         	b	0x700a79ce <CSL_pktdmaAccessChanPeerReg+0x4e> @ imm = #-0x2
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pTxChanRtRegs) + (uintptr_t)CSL_PKTDMA_TXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a79ce: 9807         	ldr	r0, [sp, #0x1c]
700a79d0: 6900         	ldr	r0, [r0, #0x10]
700a79d2: 9906         	ldr	r1, [sp, #0x18]
700a79d4: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a79d8: 9905         	ldr	r1, [sp, #0x14]
700a79da: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a79de: f500 7000    	add.w	r0, r0, #0x200
700a79e2: 9001         	str	r0, [sp, #0x4]
;             }
700a79e4: e00b         	b	0x700a79fe <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #0x16
;                 pPeerReg = (uint32_t *)(((uintptr_t)pCfg->pRxChanRtRegs) + (uintptr_t)CSL_PKTDMA_RXCRT_CHAN_PEER0(chanIdx) + ((uintptr_t)regIdx * 0x4U));
700a79e6: 9807         	ldr	r0, [sp, #0x1c]
700a79e8: 6940         	ldr	r0, [r0, #0x14]
700a79ea: 9906         	ldr	r1, [sp, #0x18]
700a79ec: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a79f0: 9905         	ldr	r1, [sp, #0x14]
700a79f2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a79f6: f500 7000    	add.w	r0, r0, #0x200
700a79fa: 9001         	str	r0, [sp, #0x4]
700a79fc: e7ff         	b	0x700a79fe <CSL_pktdmaAccessChanPeerReg+0x7e> @ imm = #-0x2
;             if( bRdAccess == (bool)true )
700a79fe: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700a7a02: 07c0         	lsls	r0, r0, #0x1f
700a7a04: b130         	cbz	r0, 0x700a7a14 <CSL_pktdmaAccessChanPeerReg+0x94> @ imm = #0xc
700a7a06: e7ff         	b	0x700a7a08 <CSL_pktdmaAccessChanPeerReg+0x88> @ imm = #-0x2
;                 *pVal = CSL_REG32_RD( pPeerReg );
700a7a08: 9801         	ldr	r0, [sp, #0x4]
700a7a0a: f008 f909    	bl	0x700afc20 <CSL_REG32_RD_RAW> @ imm = #0x8212
700a7a0e: 9904         	ldr	r1, [sp, #0x10]
700a7a10: 6008         	str	r0, [r1]
;             }
700a7a12: e005         	b	0x700a7a20 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #0xa
;                 CSL_REG32_WR( pPeerReg, *pVal );
700a7a14: 9801         	ldr	r0, [sp, #0x4]
700a7a16: 9904         	ldr	r1, [sp, #0x10]
700a7a18: 6809         	ldr	r1, [r1]
700a7a1a: f008 f859    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0x80b2
700a7a1e: e7ff         	b	0x700a7a20 <CSL_pktdmaAccessChanPeerReg+0xa0> @ imm = #-0x2
700a7a20: 2000         	movs	r0, #0x0
;             retVal = CSL_PASS;
700a7a22: 9002         	str	r0, [sp, #0x8]
;         }
700a7a24: e003         	b	0x700a7a2e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #0x6
700a7a26: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = CSL_EFAIL;
700a7a2a: 9002         	str	r0, [sp, #0x8]
700a7a2c: e7ff         	b	0x700a7a2e <CSL_pktdmaAccessChanPeerReg+0xae> @ imm = #-0x2
700a7a2e: e7ff         	b	0x700a7a30 <CSL_pktdmaAccessChanPeerReg+0xb0> @ imm = #-0x2
;     return retVal;
700a7a30: 9802         	ldr	r0, [sp, #0x8]
700a7a32: b008         	add	sp, #0x20
700a7a34: bd80         	pop	{r7, pc}
		...
700a7a3e: 0000         	movs	r0, r0

700a7a40 <UART_fifoWrite>:
; {
700a7a40: b580         	push	{r7, lr}
700a7a42: b08c         	sub	sp, #0x30
700a7a44: 900b         	str	r0, [sp, #0x2c]
700a7a46: 910a         	str	r1, [sp, #0x28]
700a7a48: 9209         	str	r2, [sp, #0x24]
;     uint32_t tempWriteSizeRemaining = writeSizeRemaining;
700a7a4a: 9809         	ldr	r0, [sp, #0x24]
700a7a4c: 9008         	str	r0, [sp, #0x20]
;     uint32_t size                  = tempWriteSizeRemaining;
700a7a4e: 9808         	ldr	r0, [sp, #0x20]
700a7a50: 9007         	str	r0, [sp, #0x1c]
;     const uint8_t *tempBuffer = buffer;
700a7a52: 980a         	ldr	r0, [sp, #0x28]
700a7a54: 9006         	str	r0, [sp, #0x18]
700a7a56: 2000         	movs	r0, #0x0
;     uint32_t lineStatus            = 0U;
700a7a58: 9005         	str	r0, [sp, #0x14]
;     uint32_t tempChunksize         = 0U;
700a7a5a: 9004         	str	r0, [sp, #0x10]
700a7a5c: f640 30b8    	movw	r0, #0xbb8
;     int32_t  maxTrialCount         = (int32_t) UART_TRANSMITEMPTY_TRIALCOUNT;
700a7a60: 9003         	str	r0, [sp, #0xc]
700a7a62: 2040         	movs	r0, #0x40
;     tempChunksize = UART_FIFO_SIZE;
700a7a64: 9004         	str	r0, [sp, #0x10]
;     do
700a7a66: e7ff         	b	0x700a7a68 <UART_fifoWrite+0x28> @ imm = #-0x2
;         lineStatus = (uint32_t) UART_readLineStatus(hUart->baseAddr);
700a7a68: 980b         	ldr	r0, [sp, #0x2c]
700a7a6a: 6800         	ldr	r0, [r0]
700a7a6c: f005 ff18    	bl	0x700ad8a0 <UART_readLineStatus> @ imm = #0x5e30
700a7a70: 9005         	str	r0, [sp, #0x14]
;         maxTrialCount--;
700a7a72: 9803         	ldr	r0, [sp, #0xc]
700a7a74: 3801         	subs	r0, #0x1
700a7a76: 9003         	str	r0, [sp, #0xc]
;     }
700a7a78: e7ff         	b	0x700a7a7a <UART_fifoWrite+0x3a> @ imm = #-0x2
;                        UART_LSR_TX_FIFO_E_MASK) & lineStatus))
700a7a7a: 9805         	ldr	r0, [sp, #0x14]
700a7a7c: f000 0160    	and	r1, r0, #0x60
700a7a80: 2000         	movs	r0, #0x0
;            && (0 < maxTrialCount));
700a7a82: 2960         	cmp	r1, #0x60
700a7a84: 9002         	str	r0, [sp, #0x8]
700a7a86: d007         	beq	0x700a7a98 <UART_fifoWrite+0x58> @ imm = #0xe
700a7a88: e7ff         	b	0x700a7a8a <UART_fifoWrite+0x4a> @ imm = #-0x2
700a7a8a: 9903         	ldr	r1, [sp, #0xc]
700a7a8c: 2000         	movs	r0, #0x0
700a7a8e: 2900         	cmp	r1, #0x0
700a7a90: bfc8         	it	gt
700a7a92: 2001         	movgt	r0, #0x1
700a7a94: 9002         	str	r0, [sp, #0x8]
700a7a96: e7ff         	b	0x700a7a98 <UART_fifoWrite+0x58> @ imm = #-0x2
700a7a98: 9802         	ldr	r0, [sp, #0x8]
;     }
700a7a9a: 07c0         	lsls	r0, r0, #0x1f
700a7a9c: 2800         	cmp	r0, #0x0
700a7a9e: d1e3         	bne	0x700a7a68 <UART_fifoWrite+0x28> @ imm = #-0x3a
700a7aa0: e7ff         	b	0x700a7aa2 <UART_fifoWrite+0x62> @ imm = #-0x2
;     if (maxTrialCount > 0)
700a7aa2: 9803         	ldr	r0, [sp, #0xc]
700a7aa4: 2801         	cmp	r0, #0x1
700a7aa6: db21         	blt	0x700a7aec <UART_fifoWrite+0xac> @ imm = #0x42
700a7aa8: e7ff         	b	0x700a7aaa <UART_fifoWrite+0x6a> @ imm = #-0x2
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a7aaa: e7ff         	b	0x700a7aac <UART_fifoWrite+0x6c> @ imm = #-0x2
700a7aac: 9904         	ldr	r1, [sp, #0x10]
700a7aae: 2000         	movs	r0, #0x0
700a7ab0: 9001         	str	r0, [sp, #0x4]
700a7ab2: b131         	cbz	r1, 0x700a7ac2 <UART_fifoWrite+0x82> @ imm = #0xc
700a7ab4: e7ff         	b	0x700a7ab6 <UART_fifoWrite+0x76> @ imm = #-0x2
700a7ab6: 9808         	ldr	r0, [sp, #0x20]
700a7ab8: 2800         	cmp	r0, #0x0
700a7aba: bf18         	it	ne
700a7abc: 2001         	movne	r0, #0x1
700a7abe: 9001         	str	r0, [sp, #0x4]
700a7ac0: e7ff         	b	0x700a7ac2 <UART_fifoWrite+0x82> @ imm = #-0x2
700a7ac2: 9801         	ldr	r0, [sp, #0x4]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a7ac4: 07c0         	lsls	r0, r0, #0x1f
700a7ac6: b180         	cbz	r0, 0x700a7aea <UART_fifoWrite+0xaa> @ imm = #0x20
700a7ac8: e7ff         	b	0x700a7aca <UART_fifoWrite+0x8a> @ imm = #-0x2
;             UART_putChar(hUart->baseAddr, (*tempBuffer));
700a7aca: 980b         	ldr	r0, [sp, #0x2c]
700a7acc: 6800         	ldr	r0, [r0]
700a7ace: 9906         	ldr	r1, [sp, #0x18]
700a7ad0: 7809         	ldrb	r1, [r1]
700a7ad2: f007 fe45    	bl	0x700af760 <UART_putChar> @ imm = #0x7c8a
;             tempBuffer++;
700a7ad6: 9806         	ldr	r0, [sp, #0x18]
700a7ad8: 3001         	adds	r0, #0x1
700a7ada: 9006         	str	r0, [sp, #0x18]
;             tempWriteSizeRemaining--;
700a7adc: 9808         	ldr	r0, [sp, #0x20]
700a7ade: 3801         	subs	r0, #0x1
700a7ae0: 9008         	str	r0, [sp, #0x20]
;             tempChunksize--;
700a7ae2: 9804         	ldr	r0, [sp, #0x10]
700a7ae4: 3801         	subs	r0, #0x1
700a7ae6: 9004         	str	r0, [sp, #0x10]
;         while ((tempChunksize > 0U) && (tempWriteSizeRemaining > 0U))
700a7ae8: e7e0         	b	0x700a7aac <UART_fifoWrite+0x6c> @ imm = #-0x40
;     }
700a7aea: e7ff         	b	0x700a7aec <UART_fifoWrite+0xac> @ imm = #-0x2
;     return (size - tempWriteSizeRemaining);
700a7aec: 9807         	ldr	r0, [sp, #0x1c]
700a7aee: 9908         	ldr	r1, [sp, #0x20]
700a7af0: 1a40         	subs	r0, r0, r1
700a7af2: b00c         	add	sp, #0x30
700a7af4: bd80         	pop	{r7, pc}
		...
700a7afe: 0000         	movs	r0, r0

700a7b00 <xTaskRemoveFromEventList>:
; BaseType_t xTaskRemoveFromEventList(const List_t *const pxEventList) {
700a7b00: b580         	push	{r7, lr}
700a7b02: b084         	sub	sp, #0x10
700a7b04: 9003         	str	r0, [sp, #0xc]
;   pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700a7b06: 9803         	ldr	r0, [sp, #0xc]
700a7b08: 68c0         	ldr	r0, [r0, #0xc]
700a7b0a: 68c0         	ldr	r0, [r0, #0xc]
700a7b0c: 9002         	str	r0, [sp, #0x8]
;   (void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
700a7b0e: 9802         	ldr	r0, [sp, #0x8]
700a7b10: 3018         	adds	r0, #0x18
700a7b12: f005 fdfd    	bl	0x700ad710 <uxListRemove> @ imm = #0x5bfa
;   if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700a7b16: f642 2024    	movw	r0, #0x2a24
700a7b1a: f2c7 000b    	movt	r0, #0x700b
700a7b1e: 6800         	ldr	r0, [r0]
700a7b20: bb30         	cbnz	r0, 0x700a7b70 <xTaskRemoveFromEventList+0x70> @ imm = #0x4c
700a7b22: e7ff         	b	0x700a7b24 <xTaskRemoveFromEventList+0x24> @ imm = #-0x2
;     (void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
700a7b24: 9802         	ldr	r0, [sp, #0x8]
700a7b26: 3004         	adds	r0, #0x4
700a7b28: f005 fdf2    	bl	0x700ad710 <uxListRemove> @ imm = #0x5be4
;     prvAddTaskToReadyList(pxUnblockedTCB);
700a7b2c: 9802         	ldr	r0, [sp, #0x8]
700a7b2e: 6ac0         	ldr	r0, [r0, #0x2c]
700a7b30: f642 212c    	movw	r1, #0x2a2c
700a7b34: f2c7 010b    	movt	r1, #0x700b
700a7b38: 6809         	ldr	r1, [r1]
700a7b3a: 4288         	cmp	r0, r1
700a7b3c: d908         	bls	0x700a7b50 <xTaskRemoveFromEventList+0x50> @ imm = #0x10
700a7b3e: e7ff         	b	0x700a7b40 <xTaskRemoveFromEventList+0x40> @ imm = #-0x2
700a7b40: 9802         	ldr	r0, [sp, #0x8]
700a7b42: 6ac0         	ldr	r0, [r0, #0x2c]
700a7b44: f642 212c    	movw	r1, #0x2a2c
700a7b48: f2c7 010b    	movt	r1, #0x700b
700a7b4c: 6008         	str	r0, [r1]
700a7b4e: e7ff         	b	0x700a7b50 <xTaskRemoveFromEventList+0x50> @ imm = #-0x2
700a7b50: 9902         	ldr	r1, [sp, #0x8]
700a7b52: 6ac8         	ldr	r0, [r1, #0x2c]
700a7b54: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a7b58: f244 40f8    	movw	r0, #0x44f8
700a7b5c: f2c7 0008    	movt	r0, #0x7008
700a7b60: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a7b64: 3104         	adds	r1, #0x4
700a7b66: f006 fb8b    	bl	0x700ae280 <vListInsertEnd> @ imm = #0x6716
;       prvResetNextTaskUnblockTime();
700a7b6a: f006 fb09    	bl	0x700ae180 <prvResetNextTaskUnblockTime> @ imm = #0x6612
;   } else {
700a7b6e: e009         	b	0x700a7b84 <xTaskRemoveFromEventList+0x84> @ imm = #0x12
;     vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
700a7b70: 9802         	ldr	r0, [sp, #0x8]
700a7b72: f100 0118    	add.w	r1, r0, #0x18
700a7b76: f245 2060    	movw	r0, #0x5260
700a7b7a: f2c7 0008    	movt	r0, #0x7008
700a7b7e: f006 fb7f    	bl	0x700ae280 <vListInsertEnd> @ imm = #0x66fe
700a7b82: e7ff         	b	0x700a7b84 <xTaskRemoveFromEventList+0x84> @ imm = #-0x2
;   if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
700a7b84: 9802         	ldr	r0, [sp, #0x8]
700a7b86: 6ac0         	ldr	r0, [r0, #0x2c]
700a7b88: f642 11fc    	movw	r1, #0x29fc
700a7b8c: f2c7 010b    	movt	r1, #0x700b
700a7b90: 6809         	ldr	r1, [r1]
700a7b92: 6ac9         	ldr	r1, [r1, #0x2c]
700a7b94: 4288         	cmp	r0, r1
700a7b96: d908         	bls	0x700a7baa <xTaskRemoveFromEventList+0xaa> @ imm = #0x10
700a7b98: e7ff         	b	0x700a7b9a <xTaskRemoveFromEventList+0x9a> @ imm = #-0x2
700a7b9a: 2001         	movs	r0, #0x1
;     xReturn = pdTRUE;
700a7b9c: 9001         	str	r0, [sp, #0x4]
;     xYieldPending = pdTRUE;
700a7b9e: f642 2150    	movw	r1, #0x2a50
700a7ba2: f2c7 010b    	movt	r1, #0x700b
700a7ba6: 6008         	str	r0, [r1]
;   } else {
700a7ba8: e002         	b	0x700a7bb0 <xTaskRemoveFromEventList+0xb0> @ imm = #0x4
700a7baa: 2000         	movs	r0, #0x0
;     xReturn = pdFALSE;
700a7bac: 9001         	str	r0, [sp, #0x4]
700a7bae: e7ff         	b	0x700a7bb0 <xTaskRemoveFromEventList+0xb0> @ imm = #-0x2
;   return xReturn;
700a7bb0: 9801         	ldr	r0, [sp, #0x4]
700a7bb2: b004         	add	sp, #0x10
700a7bb4: bd80         	pop	{r7, pc}
		...
700a7bbe: 0000         	movs	r0, r0

700a7bc0 <Sciclient_getCurrentContext>:
; {
700a7bc0: b082         	sub	sp, #0x8
700a7bc2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700a7bc6: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a7bc8: 9000         	str	r0, [sp]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a7bca: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7bce: 280a         	cmp	r0, #0xa
700a7bd0: d03e         	beq	0x700a7c50 <Sciclient_getCurrentContext+0x90> @ imm = #0x7c
700a7bd2: e7ff         	b	0x700a7bd4 <Sciclient_getCurrentContext+0x14> @ imm = #-0x2
;        (TISCI_MSG_SEC_HANDOVER == messageType) ||
700a7bd4: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7bd8: f249 0130    	movw	r1, #0x9030
700a7bdc: 4288         	cmp	r0, r1
700a7bde: d037         	beq	0x700a7c50 <Sciclient_getCurrentContext+0x90> @ imm = #0x6e
700a7be0: e7ff         	b	0x700a7be2 <Sciclient_getCurrentContext+0x22> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG == messageType) ||
700a7be2: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7be6: 280b         	cmp	r0, #0xb
700a7be8: d032         	beq	0x700a7c50 <Sciclient_getCurrentContext+0x90> @ imm = #0x64
700a7bea: e7ff         	b	0x700a7bec <Sciclient_getCurrentContext+0x2c> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_RM == messageType) ||
700a7bec: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7bf0: 280c         	cmp	r0, #0xc
700a7bf2: d02d         	beq	0x700a7c50 <Sciclient_getCurrentContext+0x90> @ imm = #0x5a
700a7bf4: e7ff         	b	0x700a7bf6 <Sciclient_getCurrentContext+0x36> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_SECURITY == messageType) ||
700a7bf6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7bfa: 280d         	cmp	r0, #0xd
700a7bfc: d028         	beq	0x700a7c50 <Sciclient_getCurrentContext+0x90> @ imm = #0x50
700a7bfe: e7ff         	b	0x700a7c00 <Sciclient_getCurrentContext+0x40> @ imm = #-0x2
;        (TISCI_MSG_KEY_WRITER == messageType) ||
700a7c00: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c04: f249 0131    	movw	r1, #0x9031
700a7c08: 4288         	cmp	r0, r1
700a7c0a: d021         	beq	0x700a7c50 <Sciclient_getCurrentContext+0x90> @ imm = #0x42
700a7c0c: e7ff         	b	0x700a7c0e <Sciclient_getCurrentContext+0x4e> @ imm = #-0x2
;        (TISCI_MSG_READ_OTP_MMR == messageType) ||
700a7c0e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c12: f249 0122    	movw	r1, #0x9022
700a7c16: 4288         	cmp	r0, r1
700a7c18: d01a         	beq	0x700a7c50 <Sciclient_getCurrentContext+0x90> @ imm = #0x34
700a7c1a: e7ff         	b	0x700a7c1c <Sciclient_getCurrentContext+0x5c> @ imm = #-0x2
;        (TISCI_MSG_WRITE_OTP_ROW == messageType) ||
700a7c1c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c20: f249 0123    	movw	r1, #0x9023
700a7c24: 4288         	cmp	r0, r1
700a7c26: d013         	beq	0x700a7c50 <Sciclient_getCurrentContext+0x90> @ imm = #0x26
700a7c28: e7ff         	b	0x700a7c2a <Sciclient_getCurrentContext+0x6a> @ imm = #-0x2
;        (TISCI_MSG_READ_SWREV == messageType) ||
700a7c2a: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c2e: f249 0133    	movw	r1, #0x9033
700a7c32: 4288         	cmp	r0, r1
700a7c34: d00c         	beq	0x700a7c50 <Sciclient_getCurrentContext+0x90> @ imm = #0x18
700a7c36: e7ff         	b	0x700a7c38 <Sciclient_getCurrentContext+0x78> @ imm = #-0x2
;        (TISCI_MSG_WRITE_SWREV == messageType) ||
700a7c38: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a7c3c: f249 0132    	movw	r1, #0x9032
700a7c40: 4288         	cmp	r0, r1
700a7c42: d005         	beq	0x700a7c50 <Sciclient_getCurrentContext+0x90> @ imm = #0xa
700a7c44: e7ff         	b	0x700a7c46 <Sciclient_getCurrentContext+0x86> @ imm = #-0x2
;        (TISCI_MSG_BOARD_CONFIG_PM == messageType))
700a7c46: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
;     if((TISCI_MSG_BOOT_NOTIFICATION == messageType) ||
700a7c4a: 280e         	cmp	r0, #0xe
700a7c4c: d107         	bne	0x700a7c5e <Sciclient_getCurrentContext+0x9e> @ imm = #0xe
700a7c4e: e7ff         	b	0x700a7c50 <Sciclient_getCurrentContext+0x90> @ imm = #-0x2
;         retVal = gSciclientHandle.secureContextId;
700a7c50: f642 1048    	movw	r0, #0x2948
700a7c54: f2c7 000b    	movt	r0, #0x700b
700a7c58: 68c0         	ldr	r0, [r0, #0xc]
700a7c5a: 9000         	str	r0, [sp]
;     }
700a7c5c: e006         	b	0x700a7c6c <Sciclient_getCurrentContext+0xac> @ imm = #0xc
;         retVal = gSciclientHandle.nonSecureContextId;
700a7c5e: f642 1048    	movw	r0, #0x2948
700a7c62: f2c7 000b    	movt	r0, #0x700b
700a7c66: 6900         	ldr	r0, [r0, #0x10]
700a7c68: 9000         	str	r0, [sp]
700a7c6a: e7ff         	b	0x700a7c6c <Sciclient_getCurrentContext+0xac> @ imm = #-0x2
;     return retVal;
700a7c6c: 9800         	ldr	r0, [sp]
700a7c6e: b002         	add	sp, #0x8
700a7c70: 4770         	bx	lr
		...
700a7c7e: 0000         	movs	r0, r0

700a7c80 <UART_init>:
; {
700a7c80: b580         	push	{r7, lr}
700a7c82: b086         	sub	sp, #0x18
700a7c84: 2000         	movs	r0, #0x0
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a7c86: 9004         	str	r0, [sp, #0x10]
700a7c88: e7ff         	b	0x700a7c8a <UART_init+0xa> @ imm = #-0x2
700a7c8a: 9804         	ldr	r0, [sp, #0x10]
700a7c8c: f642 11ec    	movw	r1, #0x29ec
700a7c90: f2c7 010b    	movt	r1, #0x700b
700a7c94: 6809         	ldr	r1, [r1]
700a7c96: 4288         	cmp	r0, r1
700a7c98: d236         	bhs	0x700a7d08 <UART_init+0x88> @ imm = #0x6c
700a7c9a: e7ff         	b	0x700a7c9c <UART_init+0x1c> @ imm = #-0x2
;         object = gUartConfig[cnt].object;
700a7c9c: 9904         	ldr	r1, [sp, #0x10]
700a7c9e: f642 10a4    	movw	r0, #0x29a4
700a7ca2: f2c7 000b    	movt	r0, #0x700b
700a7ca6: 9002         	str	r0, [sp, #0x8]
700a7ca8: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a7cac: 6840         	ldr	r0, [r0, #0x4]
700a7cae: 9003         	str	r0, [sp, #0xc]
;         DebugP_assert(NULL_PTR != object);
700a7cb0: 9803         	ldr	r0, [sp, #0xc]
700a7cb2: 2800         	cmp	r0, #0x0
700a7cb4: bf18         	it	ne
700a7cb6: 2001         	movne	r0, #0x1
700a7cb8: f641 71ce    	movw	r1, #0x1fce
700a7cbc: f2c7 010b    	movt	r1, #0x700b
700a7cc0: 466a         	mov	r2, sp
700a7cc2: 6011         	str	r1, [r2]
700a7cc4: f641 71e1    	movw	r1, #0x1fe1
700a7cc8: f2c7 010b    	movt	r1, #0x700b
700a7ccc: f242 1241    	movw	r2, #0x2141
700a7cd0: f2c7 020b    	movt	r2, #0x700b
700a7cd4: 23bf         	movs	r3, #0xbf
700a7cd6: f002 ffd3    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x2fa6
;         (void)memset(object, 0, sizeof(UART_Object));
700a7cda: 9803         	ldr	r0, [sp, #0xc]
700a7cdc: f44f 715a    	mov.w	r1, #0x368
700a7ce0: f7f3 ea18    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0xcbd0
700a7ce4: 9802         	ldr	r0, [sp, #0x8]
;         gUartConfig[cnt].attrs->baseAddr = (uint32_t) AddrTranslateP_getLocalAddr((uint64_t)gUartConfig[cnt].attrs->baseAddr);
700a7ce6: 9904         	ldr	r1, [sp, #0x10]
700a7ce8: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700a7cec: 6800         	ldr	r0, [r0]
700a7cee: 2100         	movs	r1, #0x0
700a7cf0: f7fd ff8e    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x20e4
700a7cf4: 9902         	ldr	r1, [sp, #0x8]
700a7cf6: 9a04         	ldr	r2, [sp, #0x10]
700a7cf8: f851 1032    	ldr.w	r1, [r1, r2, lsl #3]
700a7cfc: 6008         	str	r0, [r1]
;     }
700a7cfe: e7ff         	b	0x700a7d00 <UART_init+0x80> @ imm = #-0x2
;     for (cnt = 0U; cnt < gUartConfigNum; cnt++)
700a7d00: 9804         	ldr	r0, [sp, #0x10]
700a7d02: 3001         	adds	r0, #0x1
700a7d04: 9004         	str	r0, [sp, #0x10]
700a7d06: e7c0         	b	0x700a7c8a <UART_init+0xa> @ imm = #-0x80
;     status = SemaphoreP_constructMutex(&gUartDrvObj.lockObj);
700a7d08: f242 7028    	movw	r0, #0x2728
700a7d0c: f2c7 000b    	movt	r0, #0x700b
700a7d10: 3004         	adds	r0, #0x4
700a7d12: f003 fc8d    	bl	0x700ab630 <SemaphoreP_constructMutex> @ imm = #0x391a
700a7d16: 9005         	str	r0, [sp, #0x14]
;     if(SystemP_SUCCESS == status)
700a7d18: 9805         	ldr	r0, [sp, #0x14]
700a7d1a: b938         	cbnz	r0, 0x700a7d2c <UART_init+0xac> @ imm = #0xe
700a7d1c: e7ff         	b	0x700a7d1e <UART_init+0x9e> @ imm = #-0x2
;         gUartDrvObj.lock = &gUartDrvObj.lockObj;
700a7d1e: f242 7128    	movw	r1, #0x2728
700a7d22: f2c7 010b    	movt	r1, #0x700b
700a7d26: 1d08         	adds	r0, r1, #0x4
700a7d28: 6008         	str	r0, [r1]
;     }
700a7d2a: e7ff         	b	0x700a7d2c <UART_init+0xac> @ imm = #-0x2
;     return;
700a7d2c: b006         	add	sp, #0x18
700a7d2e: bd80         	pop	{r7, pc}

700a7d30 <Udma_chCheckParams>:
; {
700a7d30: b084         	sub	sp, #0x10
700a7d32: 9003         	str	r0, [sp, #0xc]
700a7d34: 9102         	str	r1, [sp, #0x8]
700a7d36: 9201         	str	r2, [sp, #0x4]
700a7d38: 2000         	movs	r0, #0x0
;     int32_t     retVal = UDMA_SOK;
700a7d3a: 9000         	str	r0, [sp]
;     if((chType & UDMA_CH_FLAG_PDMA) == UDMA_CH_FLAG_PDMA)
700a7d3c: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7d40: 0700         	lsls	r0, r0, #0x1c
700a7d42: 2800         	cmp	r0, #0x0
700a7d44: d513         	bpl	0x700a7d6e <Udma_chCheckParams+0x3e> @ imm = #0x26
700a7d46: e7ff         	b	0x700a7d48 <Udma_chCheckParams+0x18> @ imm = #-0x2
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a7d48: 9801         	ldr	r0, [sp, #0x4]
700a7d4a: 6840         	ldr	r0, [r0, #0x4]
700a7d4c: f510 3f80    	cmn.w	r0, #0x10000
700a7d50: d008         	beq	0x700a7d64 <Udma_chCheckParams+0x34> @ imm = #0x10
700a7d52: e7ff         	b	0x700a7d54 <Udma_chCheckParams+0x24> @ imm = #-0x2
;            (UDMA_DMA_CH_NA == chPrms->peerChNum))
700a7d54: 9801         	ldr	r0, [sp, #0x4]
700a7d56: 6840         	ldr	r0, [r0, #0x4]
700a7d58: 2102         	movs	r1, #0x2
700a7d5a: f6cf 71ff    	movt	r1, #0xffff
;         if((UDMA_DMA_CH_INVALID == chPrms->peerChNum) ||
700a7d5e: 4288         	cmp	r0, r1
700a7d60: d104         	bne	0x700a7d6c <Udma_chCheckParams+0x3c> @ imm = #0x8
700a7d62: e7ff         	b	0x700a7d64 <Udma_chCheckParams+0x34> @ imm = #-0x2
700a7d64: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7d68: 9000         	str	r0, [sp]
;         }
700a7d6a: e7ff         	b	0x700a7d6c <Udma_chCheckParams+0x3c> @ imm = #-0x2
;     }
700a7d6c: e7ff         	b	0x700a7d6e <Udma_chCheckParams+0x3e> @ imm = #-0x2
;     if((chType & UDMA_CH_FLAG_MAPPED) == UDMA_CH_FLAG_MAPPED)
700a7d6e: f89d 0009    	ldrb.w	r0, [sp, #0x9]
700a7d72: 07c0         	lsls	r0, r0, #0x1f
700a7d74: b388         	cbz	r0, 0x700a7dda <Udma_chCheckParams+0xaa> @ imm = #0x62
700a7d76: e7ff         	b	0x700a7d78 <Udma_chCheckParams+0x48> @ imm = #-0x2
;         if(UDMA_MAPPED_GROUP_INVALID == chPrms->mappedChGrp)
700a7d78: 9801         	ldr	r0, [sp, #0x4]
700a7d7a: 6880         	ldr	r0, [r0, #0x8]
700a7d7c: 2104         	movs	r1, #0x4
700a7d7e: f6cf 71ff    	movt	r1, #0xffff
700a7d82: 4288         	cmp	r0, r1
700a7d84: d104         	bne	0x700a7d90 <Udma_chCheckParams+0x60> @ imm = #0x8
700a7d86: e7ff         	b	0x700a7d88 <Udma_chCheckParams+0x58> @ imm = #-0x2
700a7d88: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7d8c: 9000         	str	r0, [sp]
;         }
700a7d8e: e7ff         	b	0x700a7d90 <Udma_chCheckParams+0x60> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a7d90: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7d94: 07c0         	lsls	r0, r0, #0x1f
700a7d96: b150         	cbz	r0, 0x700a7dae <Udma_chCheckParams+0x7e> @ imm = #0x14
700a7d98: e7ff         	b	0x700a7d9a <Udma_chCheckParams+0x6a> @ imm = #-0x2
;             if(chPrms->mappedChGrp >= UDMA_NUM_MAPPED_TX_GROUP)
700a7d9a: 9801         	ldr	r0, [sp, #0x4]
700a7d9c: 6880         	ldr	r0, [r0, #0x8]
700a7d9e: 2804         	cmp	r0, #0x4
700a7da0: d304         	blo	0x700a7dac <Udma_chCheckParams+0x7c> @ imm = #0x8
700a7da2: e7ff         	b	0x700a7da4 <Udma_chCheckParams+0x74> @ imm = #-0x2
700a7da4: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a7da8: 9000         	str	r0, [sp]
;             }
700a7daa: e7ff         	b	0x700a7dac <Udma_chCheckParams+0x7c> @ imm = #-0x2
;         }
700a7dac: e7ff         	b	0x700a7dae <Udma_chCheckParams+0x7e> @ imm = #-0x2
;         if((chType & UDMA_CH_FLAG_RX) == UDMA_CH_FLAG_RX)
700a7dae: f89d 0008    	ldrb.w	r0, [sp, #0x8]
700a7db2: 0780         	lsls	r0, r0, #0x1e
700a7db4: 2800         	cmp	r0, #0x0
700a7db6: d50f         	bpl	0x700a7dd8 <Udma_chCheckParams+0xa8> @ imm = #0x1e
700a7db8: e7ff         	b	0x700a7dba <Udma_chCheckParams+0x8a> @ imm = #-0x2
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a7dba: 9801         	ldr	r0, [sp, #0x4]
700a7dbc: 6880         	ldr	r0, [r0, #0x8]
700a7dbe: 2804         	cmp	r0, #0x4
700a7dc0: d305         	blo	0x700a7dce <Udma_chCheckParams+0x9e> @ imm = #0xa
700a7dc2: e7ff         	b	0x700a7dc4 <Udma_chCheckParams+0x94> @ imm = #-0x2
;                (chPrms->mappedChGrp >= (UDMA_NUM_MAPPED_TX_GROUP + UDMA_NUM_MAPPED_RX_GROUP)))
700a7dc4: 9801         	ldr	r0, [sp, #0x4]
700a7dc6: 6880         	ldr	r0, [r0, #0x8]
;             if((chPrms->mappedChGrp < UDMA_NUM_MAPPED_TX_GROUP) ||
700a7dc8: 2808         	cmp	r0, #0x8
700a7dca: d304         	blo	0x700a7dd6 <Udma_chCheckParams+0xa6> @ imm = #0x8
700a7dcc: e7ff         	b	0x700a7dce <Udma_chCheckParams+0x9e> @ imm = #-0x2
700a7dce: f06f 0002    	mvn	r0, #0x2
;                 retVal = UDMA_EINVALID_PARAMS;
700a7dd2: 9000         	str	r0, [sp]
;             }
700a7dd4: e7ff         	b	0x700a7dd6 <Udma_chCheckParams+0xa6> @ imm = #-0x2
;         }
700a7dd6: e7ff         	b	0x700a7dd8 <Udma_chCheckParams+0xa8> @ imm = #-0x2
;     }
700a7dd8: e7ff         	b	0x700a7dda <Udma_chCheckParams+0xaa> @ imm = #-0x2
;     return (retVal);
700a7dda: 9800         	ldr	r0, [sp]
700a7ddc: b004         	add	sp, #0x10
700a7dde: 4770         	bx	lr

700a7de0 <Udma_getMappedChRingAttributes>:
; {
700a7de0: b087         	sub	sp, #0x1c
700a7de2: 9006         	str	r0, [sp, #0x18]
700a7de4: 9105         	str	r1, [sp, #0x14]
700a7de6: 9204         	str	r2, [sp, #0x10]
700a7de8: 9303         	str	r3, [sp, #0xc]
700a7dea: 2000         	movs	r0, #0x0
;     uint32_t index = 0U;
700a7dec: 9001         	str	r0, [sp, #0x4]
;     int32_t retVal = UDMA_SOK;
700a7dee: 9000         	str	r0, [sp]
;     if(mappedGrp < UDMA_NUM_MAPPED_TX_GROUP) /* Mapped TX Channel */
700a7df0: 9805         	ldr	r0, [sp, #0x14]
700a7df2: 2803         	cmp	r0, #0x3
700a7df4: d81e         	bhi	0x700a7e34 <Udma_getMappedChRingAttributes+0x54> @ imm = #0x3c
700a7df6: e7ff         	b	0x700a7df8 <Udma_getMappedChRingAttributes+0x18> @ imm = #-0x2
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a7df8: 9804         	ldr	r0, [sp, #0x10]
700a7dfa: 2810         	cmp	r0, #0x10
700a7dfc: d304         	blo	0x700a7e08 <Udma_getMappedChRingAttributes+0x28> @ imm = #0x8
700a7dfe: e7ff         	b	0x700a7e00 <Udma_getMappedChRingAttributes+0x20> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_TX_CHANS))
700a7e00: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START) ||
700a7e02: 282a         	cmp	r0, #0x2a
700a7e04: d304         	blo	0x700a7e10 <Udma_getMappedChRingAttributes+0x30> @ imm = #0x8
700a7e06: e7ff         	b	0x700a7e08 <Udma_getMappedChRingAttributes+0x28> @ imm = #-0x2
700a7e08: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7e0c: 9000         	str	r0, [sp]
;         }
700a7e0e: e7ff         	b	0x700a7e10 <Udma_getMappedChRingAttributes+0x30> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a7e10: 9800         	ldr	r0, [sp]
700a7e12: b970         	cbnz	r0, 0x700a7e32 <Udma_getMappedChRingAttributes+0x52> @ imm = #0x1c
700a7e14: e7ff         	b	0x700a7e16 <Udma_getMappedChRingAttributes+0x36> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_TX_CHANS_CPSW_START;
700a7e16: 9804         	ldr	r0, [sp, #0x10]
700a7e18: 3810         	subs	r0, #0x10
700a7e1a: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaTxMappedChRingAttributes[index];
700a7e1c: 9801         	ldr	r0, [sp, #0x4]
700a7e1e: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a7e22: f241 40c8    	movw	r0, #0x14c8
700a7e26: f2c7 000b    	movt	r0, #0x700b
700a7e2a: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7e2e: 9002         	str	r0, [sp, #0x8]
;         }
700a7e30: e7ff         	b	0x700a7e32 <Udma_getMappedChRingAttributes+0x52> @ imm = #-0x2
;     }
700a7e32: e01d         	b	0x700a7e70 <Udma_getMappedChRingAttributes+0x90> @ imm = #0x3a
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a7e34: 9804         	ldr	r0, [sp, #0x10]
700a7e36: 2810         	cmp	r0, #0x10
700a7e38: d304         	blo	0x700a7e44 <Udma_getMappedChRingAttributes+0x64> @ imm = #0x8
700a7e3a: e7ff         	b	0x700a7e3c <Udma_getMappedChRingAttributes+0x5c> @ imm = #-0x2
;            (chNum >= CSL_DMSS_PKTDMA_NUM_RX_CHANS))
700a7e3c: 9804         	ldr	r0, [sp, #0x10]
;         if((chNum < CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START) ||
700a7e3e: 281d         	cmp	r0, #0x1d
700a7e40: d304         	blo	0x700a7e4c <Udma_getMappedChRingAttributes+0x6c> @ imm = #0x8
700a7e42: e7ff         	b	0x700a7e44 <Udma_getMappedChRingAttributes+0x64> @ imm = #-0x2
700a7e44: f06f 0002    	mvn	r0, #0x2
;             retVal = UDMA_EINVALID_PARAMS;
700a7e48: 9000         	str	r0, [sp]
;         }
700a7e4a: e7ff         	b	0x700a7e4c <Udma_getMappedChRingAttributes+0x6c> @ imm = #-0x2
;         if(UDMA_SOK == retVal)
700a7e4c: 9800         	ldr	r0, [sp]
700a7e4e: b970         	cbnz	r0, 0x700a7e6e <Udma_getMappedChRingAttributes+0x8e> @ imm = #0x1c
700a7e50: e7ff         	b	0x700a7e52 <Udma_getMappedChRingAttributes+0x72> @ imm = #-0x2
;             index = chNum - CSL_DMSS_PKTDMA_RX_CHANS_CPSW_START;
700a7e52: 9804         	ldr	r0, [sp, #0x10]
700a7e54: 3810         	subs	r0, #0x10
700a7e56: 9001         	str	r0, [sp, #0x4]
;             mappedChRingAttributes = &gUdmaRxMappedChRingAttributes[index];
700a7e58: 9801         	ldr	r0, [sp, #0x4]
700a7e5a: eb00 0140    	add.w	r1, r0, r0, lsl #1
700a7e5e: f241 7004    	movw	r0, #0x1704
700a7e62: f2c7 000b    	movt	r0, #0x700b
700a7e66: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a7e6a: 9002         	str	r0, [sp, #0x8]
;         }
700a7e6c: e7ff         	b	0x700a7e6e <Udma_getMappedChRingAttributes+0x8e> @ imm = #-0x2
700a7e6e: e7ff         	b	0x700a7e70 <Udma_getMappedChRingAttributes+0x90> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a7e70: 9800         	ldr	r0, [sp]
700a7e72: b948         	cbnz	r0, 0x700a7e88 <Udma_getMappedChRingAttributes+0xa8> @ imm = #0x12
700a7e74: e7ff         	b	0x700a7e76 <Udma_getMappedChRingAttributes+0x96> @ imm = #-0x2
;         (void) memcpy(chAttr, mappedChRingAttributes, sizeof (Udma_MappedChRingAttributes));
700a7e76: 9903         	ldr	r1, [sp, #0xc]
700a7e78: 9b02         	ldr	r3, [sp, #0x8]
700a7e7a: 6818         	ldr	r0, [r3]
700a7e7c: 685a         	ldr	r2, [r3, #0x4]
700a7e7e: 689b         	ldr	r3, [r3, #0x8]
700a7e80: 608b         	str	r3, [r1, #0x8]
700a7e82: 604a         	str	r2, [r1, #0x4]
700a7e84: 6008         	str	r0, [r1]
;     }
700a7e86: e7ff         	b	0x700a7e88 <Udma_getMappedChRingAttributes+0xa8> @ imm = #-0x2
;     return(retVal);
700a7e88: 9800         	ldr	r0, [sp]
700a7e8a: b007         	add	sp, #0x1c
700a7e8c: 4770         	bx	lr
700a7e8e: 0000         	movs	r0, r0

700a7e90 <prvUnlockQueue>:
; {
700a7e90: b580         	push	{r7, lr}
700a7e92: b082         	sub	sp, #0x8
700a7e94: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700a7e96: f006 fc6b    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x68d6
;         int8_t cTxLock = pxQueue->cTxLock;
700a7e9a: 9801         	ldr	r0, [sp, #0x4]
700a7e9c: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a7ea0: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a7ea4: e7ff         	b	0x700a7ea6 <prvUnlockQueue+0x16> @ imm = #-0x2
700a7ea6: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a7eaa: 2801         	cmp	r0, #0x1
700a7eac: db16         	blt	0x700a7edc <prvUnlockQueue+0x4c> @ imm = #0x2c
700a7eae: e7ff         	b	0x700a7eb0 <prvUnlockQueue+0x20> @ imm = #-0x2
;                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a7eb0: 9801         	ldr	r0, [sp, #0x4]
700a7eb2: 6a40         	ldr	r0, [r0, #0x24]
700a7eb4: b158         	cbz	r0, 0x700a7ece <prvUnlockQueue+0x3e> @ imm = #0x16
700a7eb6: e7ff         	b	0x700a7eb8 <prvUnlockQueue+0x28> @ imm = #-0x2
;                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a7eb8: 9801         	ldr	r0, [sp, #0x4]
700a7eba: 3024         	adds	r0, #0x24
700a7ebc: f7ff fe20    	bl	0x700a7b00 <xTaskRemoveFromEventList> @ imm = #-0x3c0
700a7ec0: b118         	cbz	r0, 0x700a7eca <prvUnlockQueue+0x3a> @ imm = #0x6
700a7ec2: e7ff         	b	0x700a7ec4 <prvUnlockQueue+0x34> @ imm = #-0x2
;                             vTaskMissedYield();
700a7ec4: f007 fe94    	bl	0x700afbf0 <vTaskMissedYield> @ imm = #0x7d28
;                         }
700a7ec8: e000         	b	0x700a7ecc <prvUnlockQueue+0x3c> @ imm = #0x0
700a7eca: e7ff         	b	0x700a7ecc <prvUnlockQueue+0x3c> @ imm = #-0x2
;                     }
700a7ecc: e000         	b	0x700a7ed0 <prvUnlockQueue+0x40> @ imm = #0x0
;                         break;
700a7ece: e005         	b	0x700a7edc <prvUnlockQueue+0x4c> @ imm = #0xa
;             --cTxLock;
700a7ed0: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a7ed4: 3801         	subs	r0, #0x1
700a7ed6: f88d 0003    	strb.w	r0, [sp, #0x3]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
700a7eda: e7e4         	b	0x700a7ea6 <prvUnlockQueue+0x16> @ imm = #-0x38
;         pxQueue->cTxLock = queueUNLOCKED;
700a7edc: 9901         	ldr	r1, [sp, #0x4]
700a7ede: 20ff         	movs	r0, #0xff
700a7ee0: f881 0045    	strb.w	r0, [r1, #0x45]
;     taskEXIT_CRITICAL();
700a7ee4: f005 fd04    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x5a08
;     taskENTER_CRITICAL();
700a7ee8: f006 fc42    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x6884
;         int8_t cRxLock = pxQueue->cRxLock;
700a7eec: 9801         	ldr	r0, [sp, #0x4]
700a7eee: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a7ef2: f88d 0002    	strb.w	r0, [sp, #0x2]
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a7ef6: e7ff         	b	0x700a7ef8 <prvUnlockQueue+0x68> @ imm = #-0x2
700a7ef8: f99d 0002    	ldrsb.w	r0, [sp, #0x2]
700a7efc: 2801         	cmp	r0, #0x1
700a7efe: db16         	blt	0x700a7f2e <prvUnlockQueue+0x9e> @ imm = #0x2c
700a7f00: e7ff         	b	0x700a7f02 <prvUnlockQueue+0x72> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a7f02: 9801         	ldr	r0, [sp, #0x4]
700a7f04: 6900         	ldr	r0, [r0, #0x10]
700a7f06: b180         	cbz	r0, 0x700a7f2a <prvUnlockQueue+0x9a> @ imm = #0x20
700a7f08: e7ff         	b	0x700a7f0a <prvUnlockQueue+0x7a> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a7f0a: 9801         	ldr	r0, [sp, #0x4]
700a7f0c: 3010         	adds	r0, #0x10
700a7f0e: f7ff fdf7    	bl	0x700a7b00 <xTaskRemoveFromEventList> @ imm = #-0x412
700a7f12: b118         	cbz	r0, 0x700a7f1c <prvUnlockQueue+0x8c> @ imm = #0x6
700a7f14: e7ff         	b	0x700a7f16 <prvUnlockQueue+0x86> @ imm = #-0x2
;                     vTaskMissedYield();
700a7f16: f007 fe6b    	bl	0x700afbf0 <vTaskMissedYield> @ imm = #0x7cd6
;                 }
700a7f1a: e000         	b	0x700a7f1e <prvUnlockQueue+0x8e> @ imm = #0x0
700a7f1c: e7ff         	b	0x700a7f1e <prvUnlockQueue+0x8e> @ imm = #-0x2
;                 --cRxLock;
700a7f1e: f89d 0002    	ldrb.w	r0, [sp, #0x2]
700a7f22: 3801         	subs	r0, #0x1
700a7f24: f88d 0002    	strb.w	r0, [sp, #0x2]
;             }
700a7f28: e000         	b	0x700a7f2c <prvUnlockQueue+0x9c> @ imm = #0x0
;                 break;
700a7f2a: e000         	b	0x700a7f2e <prvUnlockQueue+0x9e> @ imm = #0x0
;         while( cRxLock > queueLOCKED_UNMODIFIED )
700a7f2c: e7e4         	b	0x700a7ef8 <prvUnlockQueue+0x68> @ imm = #-0x38
;         pxQueue->cRxLock = queueUNLOCKED;
700a7f2e: 9901         	ldr	r1, [sp, #0x4]
700a7f30: 20ff         	movs	r0, #0xff
700a7f32: f881 0044    	strb.w	r0, [r1, #0x44]
;     taskEXIT_CRITICAL();
700a7f36: f005 fcdb    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x59b6
; }
700a7f3a: b002         	add	sp, #0x8
700a7f3c: bd80         	pop	{r7, pc}
700a7f3e: 0000         	movs	r0, r0

700a7f40 <SemaphoreP_constructBinary>:
; {
700a7f40: b580         	push	{r7, lr}
700a7f42: b086         	sub	sp, #0x18
700a7f44: 9005         	str	r0, [sp, #0x14]
700a7f46: 9104         	str	r1, [sp, #0x10]
700a7f48: 2000         	movs	r0, #0x0
;     SemaphoreP_Struct *pSemaphore = NULL;
700a7f4a: 9003         	str	r0, [sp, #0xc]
700a7f4c: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t status = SystemP_FAILURE;
700a7f50: 9002         	str	r0, [sp, #0x8]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700a7f52: f641 10eb    	movw	r0, #0x19eb
700a7f56: f2c7 000b    	movt	r0, #0x700b
700a7f5a: 4669         	mov	r1, sp
700a7f5c: 6008         	str	r0, [r1]
700a7f5e: f641 41a6    	movw	r1, #0x1ca6
700a7f62: f2c7 010b    	movt	r1, #0x700b
700a7f66: f641 6250    	movw	r2, #0x1e50
700a7f6a: f2c7 020b    	movt	r2, #0x700b
700a7f6e: 2001         	movs	r0, #0x1
700a7f70: 2332         	movs	r3, #0x32
700a7f72: f002 fe85    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x2d0a
;     if(obj != NULL)
700a7f76: 9805         	ldr	r0, [sp, #0x14]
700a7f78: b128         	cbz	r0, 0x700a7f86 <SemaphoreP_constructBinary+0x46> @ imm = #0xa
700a7f7a: e7ff         	b	0x700a7f7c <SemaphoreP_constructBinary+0x3c> @ imm = #-0x2
;         pSemaphore = (SemaphoreP_Struct *)obj;
700a7f7c: 9805         	ldr	r0, [sp, #0x14]
700a7f7e: 9003         	str	r0, [sp, #0xc]
700a7f80: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700a7f82: 9002         	str	r0, [sp, #0x8]
;     }
700a7f84: e7ff         	b	0x700a7f86 <SemaphoreP_constructBinary+0x46> @ imm = #-0x2
;     if (SystemP_SUCCESS == status)
700a7f86: 9802         	ldr	r0, [sp, #0x8]
700a7f88: bb68         	cbnz	r0, 0x700a7fe6 <SemaphoreP_constructBinary+0xa6> @ imm = #0x5a
700a7f8a: e7ff         	b	0x700a7f8c <SemaphoreP_constructBinary+0x4c> @ imm = #-0x2
;         pSemaphore->isRecursiveMutex = 0;
700a7f8c: 9803         	ldr	r0, [sp, #0xc]
700a7f8e: 2200         	movs	r2, #0x0
700a7f90: 6542         	str	r2, [r0, #0x54]
;         pSemaphore->semHndl = xSemaphoreCreateBinaryStatic(&pSemaphore->semObj);
700a7f92: 9b03         	ldr	r3, [sp, #0xc]
700a7f94: 4669         	mov	r1, sp
700a7f96: 2003         	movs	r0, #0x3
700a7f98: 6008         	str	r0, [r1]
700a7f9a: 2001         	movs	r0, #0x1
700a7f9c: 4611         	mov	r1, r2
700a7f9e: f005 fb1f    	bl	0x700ad5e0 <xQueueGenericCreateStatic> @ imm = #0x563e
700a7fa2: 9903         	ldr	r1, [sp, #0xc]
700a7fa4: 6508         	str	r0, [r1, #0x50]
;         if( pSemaphore->semHndl == NULL )
700a7fa6: 9803         	ldr	r0, [sp, #0xc]
700a7fa8: 6d00         	ldr	r0, [r0, #0x50]
700a7faa: b920         	cbnz	r0, 0x700a7fb6 <SemaphoreP_constructBinary+0x76> @ imm = #0x8
700a7fac: e7ff         	b	0x700a7fae <SemaphoreP_constructBinary+0x6e> @ imm = #-0x2
700a7fae: f04f 30ff    	mov.w	r0, #0xffffffff
;             status = SystemP_FAILURE;
700a7fb2: 9002         	str	r0, [sp, #0x8]
;         }
700a7fb4: e016         	b	0x700a7fe4 <SemaphoreP_constructBinary+0xa4> @ imm = #0x2c
;             vQueueAddToRegistry(pSemaphore->semHndl, "Binary Sem (DPL)");
700a7fb6: 9803         	ldr	r0, [sp, #0xc]
700a7fb8: 6d00         	ldr	r0, [r0, #0x50]
700a7fba: f242 0190    	movw	r1, #0x2090
700a7fbe: f2c7 010b    	movt	r1, #0x700b
700a7fc2: f005 f87d    	bl	0x700ad0c0 <vQueueAddToRegistry> @ imm = #0x50fa
;             if(initCount == 1U)
700a7fc6: 9804         	ldr	r0, [sp, #0x10]
700a7fc8: 2801         	cmp	r0, #0x1
700a7fca: d108         	bne	0x700a7fde <SemaphoreP_constructBinary+0x9e> @ imm = #0x10
700a7fcc: e7ff         	b	0x700a7fce <SemaphoreP_constructBinary+0x8e> @ imm = #-0x2
;                 (void)xSemaphoreGive(pSemaphore->semHndl);
700a7fce: 9803         	ldr	r0, [sp, #0xc]
700a7fd0: 6d00         	ldr	r0, [r0, #0x50]
700a7fd2: 2300         	movs	r3, #0x0
700a7fd4: 4619         	mov	r1, r3
700a7fd6: 461a         	mov	r2, r3
700a7fd8: f7fb f98a    	bl	0x700a32f0 <xQueueGenericSend> @ imm = #-0x4cec
;             }
700a7fdc: e7ff         	b	0x700a7fde <SemaphoreP_constructBinary+0x9e> @ imm = #-0x2
700a7fde: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700a7fe0: 9002         	str	r0, [sp, #0x8]
700a7fe2: e7ff         	b	0x700a7fe4 <SemaphoreP_constructBinary+0xa4> @ imm = #-0x2
;     }
700a7fe4: e7ff         	b	0x700a7fe6 <SemaphoreP_constructBinary+0xa6> @ imm = #-0x2
;     return status;
700a7fe6: 9802         	ldr	r0, [sp, #0x8]
700a7fe8: b006         	add	sp, #0x18
700a7fea: bd80         	pop	{r7, pc}
700a7fec: 0000         	movs	r0, r0
700a7fee: 0000         	movs	r0, r0

700a7ff0 <UdmaChRxPrms_init>:
; {
700a7ff0: b083         	sub	sp, #0xc
700a7ff2: 9002         	str	r0, [sp, #0x8]
700a7ff4: 9101         	str	r1, [sp, #0x4]
;     if(NULL_PTR != rxPrms)
700a7ff6: 9802         	ldr	r0, [sp, #0x8]
700a7ff8: 2800         	cmp	r0, #0x0
700a7ffa: d04d         	beq	0x700a8098 <UdmaChRxPrms_init+0xa8> @ imm = #0x9a
700a7ffc: e7ff         	b	0x700a7ffe <UdmaChRxPrms_init+0xe> @ imm = #-0x2
;         rxPrms->pauseOnError        = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a7ffe: 9902         	ldr	r1, [sp, #0x8]
700a8000: 2000         	movs	r0, #0x0
700a8002: 7008         	strb	r0, [r1]
;         rxPrms->addrType            = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a8004: 9902         	ldr	r1, [sp, #0x8]
700a8006: 7048         	strb	r0, [r1, #0x1]
;         rxPrms->chanType            = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a8008: 9902         	ldr	r1, [sp, #0x8]
700a800a: 2002         	movs	r0, #0x2
700a800c: 7088         	strb	r0, [r1, #0x2]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a800e: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a8012: 0740         	lsls	r0, r0, #0x1d
700a8014: 2800         	cmp	r0, #0x0
700a8016: d504         	bpl	0x700a8022 <UdmaChRxPrms_init+0x32> @ imm = #0x8
700a8018: e7ff         	b	0x700a801a <UdmaChRxPrms_init+0x2a> @ imm = #-0x2
;             rxPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a801a: 9902         	ldr	r1, [sp, #0x8]
700a801c: 200c         	movs	r0, #0xc
700a801e: 7088         	strb	r0, [r1, #0x2]
;         }
700a8020: e7ff         	b	0x700a8022 <UdmaChRxPrms_init+0x32> @ imm = #-0x2
;         rxPrms->fetchWordSize       = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a8022: 9902         	ldr	r1, [sp, #0x8]
700a8024: 2010         	movs	r0, #0x10
700a8026: 8088         	strh	r0, [r1, #0x4]
;         rxPrms->busPriority         = UDMA_DEFAULT_RX_CH_BUS_PRIORITY;
700a8028: 9902         	ldr	r1, [sp, #0x8]
700a802a: 2004         	movs	r0, #0x4
700a802c: 7188         	strb	r0, [r1, #0x6]
;         rxPrms->busQos              = UDMA_DEFAULT_RX_CH_BUS_QOS;
700a802e: 9902         	ldr	r1, [sp, #0x8]
700a8030: 71c8         	strb	r0, [r1, #0x7]
;         rxPrms->busOrderId          = UDMA_DEFAULT_RX_CH_BUS_ORDERID;
700a8032: 9802         	ldr	r0, [sp, #0x8]
700a8034: 2100         	movs	r1, #0x0
700a8036: 9100         	str	r1, [sp]
700a8038: 7201         	strb	r1, [r0, #0x8]
;         rxPrms->dmaPriority         = UDMA_DEFAULT_RX_CH_DMA_PRIORITY;
700a803a: 9a02         	ldr	r2, [sp, #0x8]
700a803c: 2001         	movs	r0, #0x1
700a803e: 7250         	strb	r0, [r2, #0x9]
;         rxPrms->flowIdFwRangeStart  = 0U;       /* Reset value - to use default flow */
700a8040: 9a02         	ldr	r2, [sp, #0x8]
700a8042: 8151         	strh	r1, [r2, #0xa]
;         rxPrms->flowIdFwRangeCnt    = 0U;       /* Reset value - to use default flow */
700a8044: 9a02         	ldr	r2, [sp, #0x8]
700a8046: 8191         	strh	r1, [r2, #0xc]
;         rxPrms->flowEInfoPresent    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;       /* Default no EINFO */
700a8048: 9a02         	ldr	r2, [sp, #0x8]
700a804a: 7391         	strb	r1, [r2, #0xe]
;         rxPrms->flowPsInfoPresent   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;      /* Default no PSINFO */
700a804c: 9a02         	ldr	r2, [sp, #0x8]
700a804e: 73d1         	strb	r1, [r2, #0xf]
;         rxPrms->flowErrorHandling   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;       /* Default Re-try descriptor allocation operation on starvation error */
700a8050: 9a02         	ldr	r2, [sp, #0x8]
700a8052: 7410         	strb	r0, [r2, #0x10]
;         rxPrms->flowSopOffset       = 0U;      /* Default SOP offset is 0 */
700a8054: 9a02         	ldr	r2, [sp, #0x8]
700a8056: 7451         	strb	r1, [r2, #0x11]
;         rxPrms->ignoreShortPkts     = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a8058: 9a02         	ldr	r2, [sp, #0x8]
700a805a: 7491         	strb	r1, [r2, #0x12]
;         rxPrms->ignoreLongPkts      = TISCI_MSG_VALUE_RM_UDMAP_RX_CH_PACKET_EXCEPTION;
700a805c: 9a02         	ldr	r2, [sp, #0x8]
700a805e: 74d1         	strb	r1, [r2, #0x13]
;         rxPrms->configDefaultFlow   = TRUE;
700a8060: 9902         	ldr	r1, [sp, #0x8]
700a8062: 6148         	str	r0, [r1, #0x14]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a8064: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a8068: 0600         	lsls	r0, r0, #0x18
700a806a: 2800         	cmp	r0, #0x0
700a806c: d504         	bpl	0x700a8078 <UdmaChRxPrms_init+0x88> @ imm = #0x8
700a806e: e7ff         	b	0x700a8070 <UdmaChRxPrms_init+0x80> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a8070: 9902         	ldr	r1, [sp, #0x8]
700a8072: 2003         	movs	r0, #0x3
700a8074: 7608         	strb	r0, [r1, #0x18]
;         }
700a8076: e00e         	b	0x700a8096 <UdmaChRxPrms_init+0xa6> @ imm = #0x1c
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a8078: f89d 0004    	ldrb.w	r0, [sp, #0x4]
700a807c: 0640         	lsls	r0, r0, #0x19
700a807e: 2800         	cmp	r0, #0x0
700a8080: d504         	bpl	0x700a808c <UdmaChRxPrms_init+0x9c> @ imm = #0x8
700a8082: e7ff         	b	0x700a8084 <UdmaChRxPrms_init+0x94> @ imm = #-0x2
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a8084: 9902         	ldr	r1, [sp, #0x8]
700a8086: 2003         	movs	r0, #0x3
700a8088: 7608         	strb	r0, [r1, #0x18]
;         }
700a808a: e003         	b	0x700a8094 <UdmaChRxPrms_init+0xa4> @ imm = #0x6
;             rxPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a808c: 9902         	ldr	r1, [sp, #0x8]
700a808e: 2001         	movs	r0, #0x1
700a8090: 7608         	strb	r0, [r1, #0x18]
700a8092: e7ff         	b	0x700a8094 <UdmaChRxPrms_init+0xa4> @ imm = #-0x2
700a8094: e7ff         	b	0x700a8096 <UdmaChRxPrms_init+0xa6> @ imm = #-0x2
;     }
700a8096: e7ff         	b	0x700a8098 <UdmaChRxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a8098: b003         	add	sp, #0xc
700a809a: 4770         	bx	lr
700a809c: 0000         	movs	r0, r0
700a809e: 0000         	movs	r0, r0

700a80a0 <UdmaChTxPrms_init>:
; {
700a80a0: b082         	sub	sp, #0x8
700a80a2: 9001         	str	r0, [sp, #0x4]
700a80a4: 9100         	str	r1, [sp]
;     if(NULL_PTR != txPrms)
700a80a6: 9801         	ldr	r0, [sp, #0x4]
700a80a8: 2800         	cmp	r0, #0x0
700a80aa: d04d         	beq	0x700a8148 <UdmaChTxPrms_init+0xa8> @ imm = #0x9a
700a80ac: e7ff         	b	0x700a80ae <UdmaChTxPrms_init+0xe> @ imm = #-0x2
;         txPrms->pauseOnError    = TISCI_MSG_VALUE_RM_UDMAP_CH_PAUSE_ON_ERROR_DISABLED;
700a80ae: 9901         	ldr	r1, [sp, #0x4]
700a80b0: 2000         	movs	r0, #0x0
700a80b2: 7008         	strb	r0, [r1]
;         txPrms->filterEinfo     = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_EINFO_DISABLED;
700a80b4: 9901         	ldr	r1, [sp, #0x4]
700a80b6: 7048         	strb	r0, [r1, #0x1]
;         txPrms->filterPsWords   = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_FILT_PSWORDS_DISABLED;
700a80b8: 9901         	ldr	r1, [sp, #0x4]
700a80ba: 7088         	strb	r0, [r1, #0x2]
;         txPrms->addrType        = TISCI_MSG_VALUE_RM_UDMAP_CH_ATYPE_PHYS;
700a80bc: 9901         	ldr	r1, [sp, #0x4]
700a80be: 70c8         	strb	r0, [r1, #0x3]
;         txPrms->chanType        = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_PACKET;
700a80c0: 9901         	ldr	r1, [sp, #0x4]
700a80c2: 2002         	movs	r0, #0x2
700a80c4: 7108         	strb	r0, [r1, #0x4]
;         if((chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a80c6: f89d 0000    	ldrb.w	r0, [sp]
700a80ca: 0740         	lsls	r0, r0, #0x1d
700a80cc: 2800         	cmp	r0, #0x0
700a80ce: d504         	bpl	0x700a80da <UdmaChTxPrms_init+0x3a> @ imm = #0x8
700a80d0: e7ff         	b	0x700a80d2 <UdmaChTxPrms_init+0x32> @ imm = #-0x2
;             txPrms->chanType    = TISCI_MSG_VALUE_RM_UDMAP_CH_TYPE_3P_BLOCK_REF;
700a80d2: 9901         	ldr	r1, [sp, #0x4]
700a80d4: 200c         	movs	r0, #0xc
700a80d6: 7108         	strb	r0, [r1, #0x4]
;         }
700a80d8: e7ff         	b	0x700a80da <UdmaChTxPrms_init+0x3a> @ imm = #-0x2
;         txPrms->fetchWordSize   = 16U;  /* sizeof(CSL_UdmapTR15) / sizeof(uint32_t) */
700a80da: 9901         	ldr	r1, [sp, #0x4]
700a80dc: 2010         	movs	r0, #0x10
700a80de: 80c8         	strh	r0, [r1, #0x6]
;         txPrms->busPriority     = UDMA_DEFAULT_TX_CH_BUS_PRIORITY;
700a80e0: 9901         	ldr	r1, [sp, #0x4]
700a80e2: 2004         	movs	r0, #0x4
700a80e4: 7208         	strb	r0, [r1, #0x8]
;         txPrms->busQos          = UDMA_DEFAULT_TX_CH_BUS_QOS;
700a80e6: 9901         	ldr	r1, [sp, #0x4]
700a80e8: 7248         	strb	r0, [r1, #0x9]
;         txPrms->busOrderId      = UDMA_DEFAULT_TX_CH_BUS_ORDERID;
700a80ea: 9901         	ldr	r1, [sp, #0x4]
700a80ec: 2000         	movs	r0, #0x0
700a80ee: 7288         	strb	r0, [r1, #0xa]
;         txPrms->dmaPriority     = UDMA_DEFAULT_TX_CH_DMA_PRIORITY;
700a80f0: 9a01         	ldr	r2, [sp, #0x4]
700a80f2: 2101         	movs	r1, #0x1
700a80f4: 72d1         	strb	r1, [r2, #0xb]
;         txPrms->txCredit        = 0U;
700a80f6: 9901         	ldr	r1, [sp, #0x4]
700a80f8: 7308         	strb	r0, [r1, #0xc]
;         if((chType & UDMA_CH_FLAG_UHC) == UDMA_CH_FLAG_UHC)
700a80fa: f89d 0000    	ldrb.w	r0, [sp]
700a80fe: ea4f 6000    	lsl.w	r0, r0, #0x18
700a8102: 2800         	cmp	r0, #0x0
700a8104: d507         	bpl	0x700a8116 <UdmaChTxPrms_init+0x76> @ imm = #0xe
700a8106: e7ff         	b	0x700a8108 <UdmaChTxPrms_init+0x68> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_UHC_CHANS_FDEPTH;
700a8108: 9901         	ldr	r1, [sp, #0x4]
700a810a: 2000         	movs	r0, #0x0
700a810c: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a810e: 9901         	ldr	r1, [sp, #0x4]
700a8110: 2003         	movs	r0, #0x3
700a8112: 7408         	strb	r0, [r1, #0x10]
;         }
700a8114: e014         	b	0x700a8140 <UdmaChTxPrms_init+0xa0> @ imm = #0x28
;         else if((chType & UDMA_CH_FLAG_HC) == UDMA_CH_FLAG_HC)
700a8116: f89d 0000    	ldrb.w	r0, [sp]
700a811a: 0640         	lsls	r0, r0, #0x19
700a811c: 2800         	cmp	r0, #0x0
700a811e: d507         	bpl	0x700a8130 <UdmaChTxPrms_init+0x90> @ imm = #0xe
700a8120: e7ff         	b	0x700a8122 <UdmaChTxPrms_init+0x82> @ imm = #-0x2
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_HC_CHANS_FDEPTH;
700a8122: 9901         	ldr	r1, [sp, #0x4]
700a8124: 2000         	movs	r0, #0x0
700a8126: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_256_BYTES;
700a8128: 9901         	ldr	r1, [sp, #0x4]
700a812a: 2003         	movs	r0, #0x3
700a812c: 7408         	strb	r0, [r1, #0x10]
;         }
700a812e: e006         	b	0x700a813e <UdmaChTxPrms_init+0x9e> @ imm = #0xc
;             txPrms->fifoDepth   = (uint16_t)UDMA_TX_CHANS_FDEPTH;
700a8130: 9901         	ldr	r1, [sp, #0x4]
700a8132: 20c0         	movs	r0, #0xc0
700a8134: 81c8         	strh	r0, [r1, #0xe]
;             txPrms->burstSize   = TISCI_MSG_VALUE_RM_UDMAP_CH_BURST_SIZE_64_BYTES;
700a8136: 9901         	ldr	r1, [sp, #0x4]
700a8138: 2001         	movs	r0, #0x1
700a813a: 7408         	strb	r0, [r1, #0x10]
700a813c: e7ff         	b	0x700a813e <UdmaChTxPrms_init+0x9e> @ imm = #-0x2
700a813e: e7ff         	b	0x700a8140 <UdmaChTxPrms_init+0xa0> @ imm = #-0x2
;         txPrms->supressTdCqPkt  = TISCI_MSG_VALUE_RM_UDMAP_TX_CH_SUPPRESS_TD_DISABLED;
700a8140: 9901         	ldr	r1, [sp, #0x4]
700a8142: 2000         	movs	r0, #0x0
700a8144: 7448         	strb	r0, [r1, #0x11]
;     }
700a8146: e7ff         	b	0x700a8148 <UdmaChTxPrms_init+0xa8> @ imm = #-0x2
;     return;
700a8148: b002         	add	sp, #0x8
700a814a: 4770         	bx	lr
700a814c: 0000         	movs	r0, r0
700a814e: 0000         	movs	r0, r0

700a8150 <Udma_chDisable>:
; {
700a8150: b580         	push	{r7, lr}
700a8152: b086         	sub	sp, #0x18
700a8154: 9005         	str	r0, [sp, #0x14]
700a8156: 9104         	str	r1, [sp, #0x10]
700a8158: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a815a: 9003         	str	r0, [sp, #0xc]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700a815c: 9805         	ldr	r0, [sp, #0x14]
700a815e: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700a8160: 9801         	ldr	r0, [sp, #0x4]
700a8162: b150         	cbz	r0, 0x700a817a <Udma_chDisable+0x2a> @ imm = #0x14
700a8164: e7ff         	b	0x700a8166 <Udma_chDisable+0x16> @ imm = #-0x2
700a8166: 9801         	ldr	r0, [sp, #0x4]
700a8168: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700a816c: f64a 31cd    	movw	r1, #0xabcd
700a8170: f6ca 31dc    	movt	r1, #0xabdc
700a8174: 4288         	cmp	r0, r1
700a8176: d004         	beq	0x700a8182 <Udma_chDisable+0x32> @ imm = #0x8
700a8178: e7ff         	b	0x700a817a <Udma_chDisable+0x2a> @ imm = #-0x2
700a817a: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a817e: 9003         	str	r0, [sp, #0xc]
;     }
700a8180: e7ff         	b	0x700a8182 <Udma_chDisable+0x32> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a8182: 9803         	ldr	r0, [sp, #0xc]
700a8184: b9a8         	cbnz	r0, 0x700a81b2 <Udma_chDisable+0x62> @ imm = #0x2a
700a8186: e7ff         	b	0x700a8188 <Udma_chDisable+0x38> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700a8188: 9801         	ldr	r0, [sp, #0x4]
700a818a: 6e80         	ldr	r0, [r0, #0x68]
700a818c: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a818e: 9802         	ldr	r0, [sp, #0x8]
700a8190: b150         	cbz	r0, 0x700a81a8 <Udma_chDisable+0x58> @ imm = #0x14
700a8192: e7ff         	b	0x700a8194 <Udma_chDisable+0x44> @ imm = #-0x2
700a8194: 9802         	ldr	r0, [sp, #0x8]
700a8196: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a819a: f64a 31cd    	movw	r1, #0xabcd
700a819e: f6ca 31dc    	movt	r1, #0xabdc
700a81a2: 4288         	cmp	r0, r1
700a81a4: d004         	beq	0x700a81b0 <Udma_chDisable+0x60> @ imm = #0x8
700a81a6: e7ff         	b	0x700a81a8 <Udma_chDisable+0x58> @ imm = #-0x2
700a81a8: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a81ac: 9003         	str	r0, [sp, #0xc]
;         }
700a81ae: e7ff         	b	0x700a81b0 <Udma_chDisable+0x60> @ imm = #-0x2
;     }
700a81b0: e7ff         	b	0x700a81b2 <Udma_chDisable+0x62> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a81b2: 9803         	ldr	r0, [sp, #0xc]
700a81b4: b9f8         	cbnz	r0, 0x700a81f6 <Udma_chDisable+0xa6> @ imm = #0x3e
700a81b6: e7ff         	b	0x700a81b8 <Udma_chDisable+0x68> @ imm = #-0x2
;         if((chHandleInt->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY)
700a81b8: 9801         	ldr	r0, [sp, #0x4]
700a81ba: 7800         	ldrb	r0, [r0]
700a81bc: 0740         	lsls	r0, r0, #0x1d
700a81be: 2800         	cmp	r0, #0x0
700a81c0: d506         	bpl	0x700a81d0 <Udma_chDisable+0x80> @ imm = #0xc
700a81c2: e7ff         	b	0x700a81c4 <Udma_chDisable+0x74> @ imm = #-0x2
;             retVal = Udma_chDisableBlkCpyChan(chHandleInt, timeout);
700a81c4: 9801         	ldr	r0, [sp, #0x4]
700a81c6: 9904         	ldr	r1, [sp, #0x10]
700a81c8: f7f7 f972    	bl	0x7009f4b0 <Udma_chDisableBlkCpyChan> @ imm = #-0x8d1c
700a81cc: 9003         	str	r0, [sp, #0xc]
;         }
700a81ce: e011         	b	0x700a81f4 <Udma_chDisable+0xa4> @ imm = #0x22
;             if((chHandleInt->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700a81d0: 9801         	ldr	r0, [sp, #0x4]
700a81d2: 7800         	ldrb	r0, [r0]
700a81d4: 07c0         	lsls	r0, r0, #0x1f
700a81d6: b130         	cbz	r0, 0x700a81e6 <Udma_chDisable+0x96> @ imm = #0xc
700a81d8: e7ff         	b	0x700a81da <Udma_chDisable+0x8a> @ imm = #-0x2
;                 retVal = Udma_chDisableTxChan(chHandleInt, timeout);
700a81da: 9801         	ldr	r0, [sp, #0x4]
700a81dc: 9904         	ldr	r1, [sp, #0x10]
700a81de: f7f4 fa27    	bl	0x7009c630 <Udma_chDisableTxChan> @ imm = #-0xbbb2
700a81e2: 9003         	str	r0, [sp, #0xc]
;             }
700a81e4: e005         	b	0x700a81f2 <Udma_chDisable+0xa2> @ imm = #0xa
;                 retVal = Udma_chDisableRxChan(chHandleInt, timeout);
700a81e6: 9801         	ldr	r0, [sp, #0x4]
700a81e8: 9904         	ldr	r1, [sp, #0x10]
700a81ea: f7f5 fb61    	bl	0x7009d8b0 <Udma_chDisableRxChan> @ imm = #-0xa93e
700a81ee: 9003         	str	r0, [sp, #0xc]
700a81f0: e7ff         	b	0x700a81f2 <Udma_chDisable+0xa2> @ imm = #-0x2
700a81f2: e7ff         	b	0x700a81f4 <Udma_chDisable+0xa4> @ imm = #-0x2
;     }
700a81f4: e7ff         	b	0x700a81f6 <Udma_chDisable+0xa6> @ imm = #-0x2
;     return (retVal);
700a81f6: 9803         	ldr	r0, [sp, #0xc]
700a81f8: b006         	add	sp, #0x18
700a81fa: bd80         	pop	{r7, pc}
700a81fc: 0000         	movs	r0, r0
700a81fe: 0000         	movs	r0, r0

700a8200 <CSL_bcdmaChanOpSetChanPause>:
; {
700a8200: b580         	push	{r7, lr}
700a8202: b086         	sub	sp, #0x18
700a8204: 9005         	str	r0, [sp, #0x14]
700a8206: 9104         	str	r1, [sp, #0x10]
700a8208: 9203         	str	r2, [sp, #0xc]
700a820a: f88d 300b    	strb.w	r3, [sp, #0xb]
700a820e: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a8210: 9001         	str	r0, [sp, #0x4]
;     if( CSL_bcdmaChanOpIsChanEnabled( pCfg, chanType, chanIdx ) == (bool)false )
700a8212: 9805         	ldr	r0, [sp, #0x14]
700a8214: 9904         	ldr	r1, [sp, #0x10]
700a8216: 9a03         	ldr	r2, [sp, #0xc]
700a8218: f002 fbf2    	bl	0x700aaa00 <CSL_bcdmaChanOpIsChanEnabled> @ imm = #0x27e4
700a821c: b920         	cbnz	r0, 0x700a8228 <CSL_bcdmaChanOpSetChanPause+0x28> @ imm = #0x8
700a821e: e7ff         	b	0x700a8220 <CSL_bcdmaChanOpSetChanPause+0x20> @ imm = #-0x2
700a8220: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700a8224: 9001         	str	r0, [sp, #0x4]
;     }
700a8226: e03d         	b	0x700a82a4 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #0x7a
;         switch( chanType )
700a8228: 9804         	ldr	r0, [sp, #0x10]
700a822a: 9000         	str	r0, [sp]
700a822c: b140         	cbz	r0, 0x700a8240 <CSL_bcdmaChanOpSetChanPause+0x40> @ imm = #0x10
700a822e: e7ff         	b	0x700a8230 <CSL_bcdmaChanOpSetChanPause+0x30> @ imm = #-0x2
700a8230: 9800         	ldr	r0, [sp]
700a8232: 2801         	cmp	r0, #0x1
700a8234: d013         	beq	0x700a825e <CSL_bcdmaChanOpSetChanPause+0x5e> @ imm = #0x26
700a8236: e7ff         	b	0x700a8238 <CSL_bcdmaChanOpSetChanPause+0x38> @ imm = #-0x2
700a8238: 9800         	ldr	r0, [sp]
700a823a: 2802         	cmp	r0, #0x2
700a823c: d01e         	beq	0x700a827c <CSL_bcdmaChanOpSetChanPause+0x7c> @ imm = #0x3c
700a823e: e02c         	b	0x700a829a <CSL_bcdmaChanOpSetChanPause+0x9a> @ imm = #0x58
;                 CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a8240: 9805         	ldr	r0, [sp, #0x14]
700a8242: 6880         	ldr	r0, [r0, #0x8]
700a8244: 9903         	ldr	r1, [sp, #0xc]
700a8246: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a824a: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a824e: f001 0301    	and	r3, r1, #0x1
700a8252: f04f 5100    	mov.w	r1, #0x20000000
700a8256: 221d         	movs	r2, #0x1d
700a8258: f006 f832    	bl	0x700ae2c0 <CSL_REG32_FINS_RAW> @ imm = #0x6064
;                 break;
700a825c: e021         	b	0x700a82a2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x42
;                 CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a825e: 9805         	ldr	r0, [sp, #0x14]
700a8260: 6900         	ldr	r0, [r0, #0x10]
700a8262: 9903         	ldr	r1, [sp, #0xc]
700a8264: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8268: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a826c: f001 0301    	and	r3, r1, #0x1
700a8270: f04f 5100    	mov.w	r1, #0x20000000
700a8274: 221d         	movs	r2, #0x1d
700a8276: f006 f823    	bl	0x700ae2c0 <CSL_REG32_FINS_RAW> @ imm = #0x6046
;                 break;
700a827a: e012         	b	0x700a82a2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x24
;                 CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_PAUSE, (bPause==(bool)false) ? (uint32_t)0U : (uint32_t)1U );
700a827c: 9805         	ldr	r0, [sp, #0x14]
700a827e: 6980         	ldr	r0, [r0, #0x18]
700a8280: 9903         	ldr	r1, [sp, #0xc]
700a8282: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8286: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a828a: f001 0301    	and	r3, r1, #0x1
700a828e: f04f 5100    	mov.w	r1, #0x20000000
700a8292: 221d         	movs	r2, #0x1d
700a8294: f006 f814    	bl	0x700ae2c0 <CSL_REG32_FINS_RAW> @ imm = #0x6028
;                 break;
700a8298: e003         	b	0x700a82a2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #0x6
700a829a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a829e: 9001         	str	r0, [sp, #0x4]
;                 break;
700a82a0: e7ff         	b	0x700a82a2 <CSL_bcdmaChanOpSetChanPause+0xa2> @ imm = #-0x2
700a82a2: e7ff         	b	0x700a82a4 <CSL_bcdmaChanOpSetChanPause+0xa4> @ imm = #-0x2
;     return retVal;
700a82a4: 9801         	ldr	r0, [sp, #0x4]
700a82a6: b006         	add	sp, #0x18
700a82a8: bd80         	pop	{r7, pc}
700a82aa: 0000         	movs	r0, r0
700a82ac: 0000         	movs	r0, r0
700a82ae: 0000         	movs	r0, r0

700a82b0 <CSL_bcdmaChanOpSetChanRT>:
; {
700a82b0: b580         	push	{r7, lr}
700a82b2: b088         	sub	sp, #0x20
700a82b4: 9007         	str	r0, [sp, #0x1c]
700a82b6: 9106         	str	r1, [sp, #0x18]
700a82b8: 9205         	str	r2, [sp, #0x14]
700a82ba: 9304         	str	r3, [sp, #0x10]
700a82bc: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a82be: 9003         	str	r0, [sp, #0xc]
;     if( pOpData == NULL )
700a82c0: 9804         	ldr	r0, [sp, #0x10]
700a82c2: b920         	cbnz	r0, 0x700a82ce <CSL_bcdmaChanOpSetChanRT+0x1e> @ imm = #0x8
700a82c4: e7ff         	b	0x700a82c6 <CSL_bcdmaChanOpSetChanRT+0x16> @ imm = #-0x2
700a82c6: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700a82ca: 9003         	str	r0, [sp, #0xc]
;     }
700a82cc: e042         	b	0x700a8354 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #0x84
;         CSL_BcdmaRT *pRT = (CSL_BcdmaRT *)pOpData;
700a82ce: 9804         	ldr	r0, [sp, #0x10]
700a82d0: 9001         	str	r0, [sp, #0x4]
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a82d2: 9801         	ldr	r0, [sp, #0x4]
700a82d4: 6803         	ldr	r3, [r0]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a82d6: f8d0 c004    	ldr.w	r12, [r0, #0x4]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a82da: 6881         	ldr	r1, [r0, #0x8]
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a82dc: 6902         	ldr	r2, [r0, #0x10]
700a82de: f04f 4080    	mov.w	r0, #0x40000000
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a82e2: ea00 708c    	and.w	r0, r0, r12, lsl #30
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a82e6: ea40 70c3    	orr.w	r0, r0, r3, lsl #31
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a82ea: f002 0201    	and	r2, r2, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_TDOWN,        pRT->teardown)       |
700a82ee: ea40 7002    	orr.w	r0, r0, r2, lsl #28
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_PAUSE,        pRT->pause);
700a82f2: f001 0101    	and	r1, r1, #0x1
;                 CSL_FMK(BCDMA_TXCRT_CHAN_CTL_FTDOWN,       pRT->forcedTeardown) |
700a82f6: ea40 7041    	orr.w	r0, r0, r1, lsl #29
;         val =   CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,           pRT->enable)         |
700a82fa: 9002         	str	r0, [sp, #0x8]
;         switch( chanType )
700a82fc: 9806         	ldr	r0, [sp, #0x18]
700a82fe: 9000         	str	r0, [sp]
700a8300: b140         	cbz	r0, 0x700a8314 <CSL_bcdmaChanOpSetChanRT+0x64> @ imm = #0x10
700a8302: e7ff         	b	0x700a8304 <CSL_bcdmaChanOpSetChanRT+0x54> @ imm = #-0x2
700a8304: 9800         	ldr	r0, [sp]
700a8306: 2801         	cmp	r0, #0x1
700a8308: d00d         	beq	0x700a8326 <CSL_bcdmaChanOpSetChanRT+0x76> @ imm = #0x1a
700a830a: e7ff         	b	0x700a830c <CSL_bcdmaChanOpSetChanRT+0x5c> @ imm = #-0x2
700a830c: 9800         	ldr	r0, [sp]
700a830e: 2802         	cmp	r0, #0x2
700a8310: d012         	beq	0x700a8338 <CSL_bcdmaChanOpSetChanRT+0x88> @ imm = #0x24
700a8312: e01a         	b	0x700a834a <CSL_bcdmaChanOpSetChanRT+0x9a> @ imm = #0x34
;                 CSL_REG32_WR( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, val );
700a8314: 9807         	ldr	r0, [sp, #0x1c]
700a8316: 6880         	ldr	r0, [r0, #0x8]
700a8318: 9905         	ldr	r1, [sp, #0x14]
700a831a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a831e: 9902         	ldr	r1, [sp, #0x8]
700a8320: f7f3 ffb6    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xc094
;                 break;
700a8324: e015         	b	0x700a8352 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x2a
;                 CSL_REG32_WR( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, val );
700a8326: 9807         	ldr	r0, [sp, #0x1c]
700a8328: 6900         	ldr	r0, [r0, #0x10]
700a832a: 9905         	ldr	r1, [sp, #0x14]
700a832c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8330: 9902         	ldr	r1, [sp, #0x8]
700a8332: f7f3 ffad    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xc0a6
;                 break;
700a8336: e00c         	b	0x700a8352 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x18
;                 CSL_REG32_WR( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, val );
700a8338: 9807         	ldr	r0, [sp, #0x1c]
700a833a: 6980         	ldr	r0, [r0, #0x18]
700a833c: 9905         	ldr	r1, [sp, #0x14]
700a833e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8342: 9902         	ldr	r1, [sp, #0x8]
700a8344: f7f3 ffa4    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xc0b8
;                 break;
700a8348: e003         	b	0x700a8352 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #0x6
700a834a: f06f 0001    	mvn	r0, #0x1
;                 retVal = CSL_EBADARGS;
700a834e: 9003         	str	r0, [sp, #0xc]
;                 break;
700a8350: e7ff         	b	0x700a8352 <CSL_bcdmaChanOpSetChanRT+0xa2> @ imm = #-0x2
700a8352: e7ff         	b	0x700a8354 <CSL_bcdmaChanOpSetChanRT+0xa4> @ imm = #-0x2
;     return retVal;
700a8354: 9803         	ldr	r0, [sp, #0xc]
700a8356: b008         	add	sp, #0x20
700a8358: bd80         	pop	{r7, pc}
700a835a: 0000         	movs	r0, r0
700a835c: 0000         	movs	r0, r0
700a835e: 0000         	movs	r0, r0

700a8360 <Sciclient_rmIrInpRomMapped>:
; {
700a8360: b082         	sub	sp, #0x8
700a8362: 9001         	str	r0, [sp, #0x4]
700a8364: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a8368: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a836a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a836e: 9801         	ldr	r0, [sp, #0x4]
700a8370: 6900         	ldr	r0, [r0, #0x10]
700a8372: 2800         	cmp	r0, #0x0
700a8374: d042         	beq	0x700a83fc <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #0x84
700a8376: e7ff         	b	0x700a8378 <Sciclient_rmIrInpRomMapped+0x18> @ imm = #-0x2
700a8378: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a837a: f88d 0000    	strb.w	r0, [sp]
700a837e: e7ff         	b	0x700a8380 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x2
700a8380: f89d 0000    	ldrb.w	r0, [sp]
700a8384: 9901         	ldr	r1, [sp, #0x4]
700a8386: 7d09         	ldrb	r1, [r1, #0x14]
700a8388: 4288         	cmp	r0, r1
700a838a: da36         	bge	0x700a83fa <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0x6c
700a838c: e7ff         	b	0x700a838e <Sciclient_rmIrInpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a838e: 9801         	ldr	r0, [sp, #0x4]
700a8390: 6900         	ldr	r0, [r0, #0x10]
700a8392: f89d 1000    	ldrb.w	r1, [sp]
700a8396: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a839a: 7980         	ldrb	r0, [r0, #0x6]
700a839c: 07c0         	lsls	r0, r0, #0x1f
700a839e: bb28         	cbnz	r0, 0x700a83ec <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x4a
700a83a0: e7ff         	b	0x700a83a2 <Sciclient_rmIrInpRomMapped+0x42> @ imm = #-0x2
;                 (inp >= inst->rom_usage[i].inp_start) &&
700a83a2: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a83a6: 9901         	ldr	r1, [sp, #0x4]
700a83a8: 6909         	ldr	r1, [r1, #0x10]
700a83aa: f89d 2000    	ldrb.w	r2, [sp]
700a83ae: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700a83b2: 4288         	cmp	r0, r1
700a83b4: db1a         	blt	0x700a83ec <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x34
700a83b6: e7ff         	b	0x700a83b8 <Sciclient_rmIrInpRomMapped+0x58> @ imm = #-0x2
;                 (inp < (inst->rom_usage[i].inp_start +
700a83b8: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a83bc: 9901         	ldr	r1, [sp, #0x4]
700a83be: 6909         	ldr	r1, [r1, #0x10]
700a83c0: f89d 3000    	ldrb.w	r3, [sp]
700a83c4: eb01 02c3    	add.w	r2, r1, r3, lsl #3
700a83c8: f831 1033    	ldrh.w	r1, [r1, r3, lsl #3]
;                         inst->rom_usage[i].length))) {
700a83cc: 8892         	ldrh	r2, [r2, #0x4]
;                 (inp < (inst->rom_usage[i].inp_start +
700a83ce: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a83d0: 4288         	cmp	r0, r1
700a83d2: da0b         	bge	0x700a83ec <Sciclient_rmIrInpRomMapped+0x8c> @ imm = #0x16
700a83d4: e7ff         	b	0x700a83d6 <Sciclient_rmIrInpRomMapped+0x76> @ imm = #-0x2
700a83d6: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a83d8: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a83dc: 9901         	ldr	r1, [sp, #0x4]
700a83de: 6909         	ldr	r1, [r1, #0x10]
700a83e0: f89d 2000    	ldrb.w	r2, [sp]
700a83e4: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a83e8: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a83ea: e006         	b	0x700a83fa <Sciclient_rmIrInpRomMapped+0x9a> @ imm = #0xc
;         }
700a83ec: e7ff         	b	0x700a83ee <Sciclient_rmIrInpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a83ee: f89d 0000    	ldrb.w	r0, [sp]
700a83f2: 3001         	adds	r0, #0x1
700a83f4: f88d 0000    	strb.w	r0, [sp]
700a83f8: e7c2         	b	0x700a8380 <Sciclient_rmIrInpRomMapped+0x20> @ imm = #-0x7c
;     }
700a83fa: e7ff         	b	0x700a83fc <Sciclient_rmIrInpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a83fc: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a8400: f000 0001    	and	r0, r0, #0x1
700a8404: b002         	add	sp, #0x8
700a8406: 4770         	bx	lr
		...

700a8410 <Sciclient_rmIrOutpRomMapped>:
; {
700a8410: b082         	sub	sp, #0x8
700a8412: 9001         	str	r0, [sp, #0x4]
700a8414: f8ad 1002    	strh.w	r1, [sp, #0x2]
700a8418: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700a841a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700a841e: 9801         	ldr	r0, [sp, #0x4]
700a8420: 6900         	ldr	r0, [r0, #0x10]
700a8422: 2800         	cmp	r0, #0x0
700a8424: d042         	beq	0x700a84ac <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #0x84
700a8426: e7ff         	b	0x700a8428 <Sciclient_rmIrOutpRomMapped+0x18> @ imm = #-0x2
700a8428: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a842a: f88d 0000    	strb.w	r0, [sp]
700a842e: e7ff         	b	0x700a8430 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x2
700a8430: f89d 0000    	ldrb.w	r0, [sp]
700a8434: 9901         	ldr	r1, [sp, #0x4]
700a8436: 7d09         	ldrb	r1, [r1, #0x14]
700a8438: 4288         	cmp	r0, r1
700a843a: da36         	bge	0x700a84aa <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0x6c
700a843c: e7ff         	b	0x700a843e <Sciclient_rmIrOutpRomMapped+0x2e> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700a843e: 9801         	ldr	r0, [sp, #0x4]
700a8440: 6900         	ldr	r0, [r0, #0x10]
700a8442: f89d 1000    	ldrb.w	r1, [sp]
700a8446: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a844a: 7980         	ldrb	r0, [r0, #0x6]
700a844c: 07c0         	lsls	r0, r0, #0x1f
700a844e: bb28         	cbnz	r0, 0x700a849c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x4a
700a8450: e7ff         	b	0x700a8452 <Sciclient_rmIrOutpRomMapped+0x42> @ imm = #-0x2
;                 (outp >= inst->rom_usage[i].outp_start) &&
700a8452: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a8456: 9901         	ldr	r1, [sp, #0x4]
700a8458: 6909         	ldr	r1, [r1, #0x10]
700a845a: f89d 2000    	ldrb.w	r2, [sp]
700a845e: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a8462: 8849         	ldrh	r1, [r1, #0x2]
700a8464: 4288         	cmp	r0, r1
700a8466: db19         	blt	0x700a849c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x32
700a8468: e7ff         	b	0x700a846a <Sciclient_rmIrOutpRomMapped+0x5a> @ imm = #-0x2
;                 (outp < (inst->rom_usage[i].outp_start +
700a846a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700a846e: 9901         	ldr	r1, [sp, #0x4]
700a8470: 6909         	ldr	r1, [r1, #0x10]
700a8472: f89d 2000    	ldrb.w	r2, [sp]
700a8476: eb01 02c2    	add.w	r2, r1, r2, lsl #3
700a847a: 8851         	ldrh	r1, [r2, #0x2]
;                         inst->rom_usage[i].length))) {
700a847c: 8892         	ldrh	r2, [r2, #0x4]
;                 (outp < (inst->rom_usage[i].outp_start +
700a847e: 4411         	add	r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700a8480: 4288         	cmp	r0, r1
700a8482: da0b         	bge	0x700a849c <Sciclient_rmIrOutpRomMapped+0x8c> @ imm = #0x16
700a8484: e7ff         	b	0x700a8486 <Sciclient_rmIrOutpRomMapped+0x76> @ imm = #-0x2
700a8486: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700a8488: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700a848c: 9901         	ldr	r1, [sp, #0x4]
700a848e: 6909         	ldr	r1, [r1, #0x10]
700a8490: f89d 2000    	ldrb.w	r2, [sp]
700a8494: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700a8498: 7188         	strb	r0, [r1, #0x6]
;                 break;
700a849a: e006         	b	0x700a84aa <Sciclient_rmIrOutpRomMapped+0x9a> @ imm = #0xc
;         }
700a849c: e7ff         	b	0x700a849e <Sciclient_rmIrOutpRomMapped+0x8e> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700a849e: f89d 0000    	ldrb.w	r0, [sp]
700a84a2: 3001         	adds	r0, #0x1
700a84a4: f88d 0000    	strb.w	r0, [sp]
700a84a8: e7c2         	b	0x700a8430 <Sciclient_rmIrOutpRomMapped+0x20> @ imm = #-0x7c
;     }
700a84aa: e7ff         	b	0x700a84ac <Sciclient_rmIrOutpRomMapped+0x9c> @ imm = #-0x2
;     return rom_mapped;
700a84ac: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700a84b0: f000 0001    	and	r0, r0, #0x1
700a84b4: b002         	add	sp, #0x8
700a84b6: 4770         	bx	lr
		...

700a84c0 <CycleCounterP_init>:
; {
700a84c0: b580         	push	{r7, lr}
700a84c2: b082         	sub	sp, #0x8
700a84c4: 9101         	str	r1, [sp, #0x4]
700a84c6: 9000         	str	r0, [sp]
;     gCounterFreqHz = cpuFreqHz/PmuP_SETUP_COUNTER_DIVIDER_VAL;
700a84c8: 9800         	ldr	r0, [sp]
700a84ca: 9a01         	ldr	r2, [sp, #0x4]
700a84cc: f642 11b0    	movw	r1, #0x29b0
700a84d0: f2c7 010b    	movt	r1, #0x700b
700a84d4: 604a         	str	r2, [r1, #0x4]
700a84d6: 6008         	str	r0, [r1]
;     CycleCounterP_reset();
700a84d8: f000 f802    	bl	0x700a84e0 <CycleCounterP_reset> @ imm = #0x4
; }
700a84dc: b002         	add	sp, #0x8
700a84de: bd80         	pop	{r7, pc}

700a84e0 <CycleCounterP_reset>:
; {
700a84e0: b580         	push	{r7, lr}
700a84e2: b082         	sub	sp, #0x8
700a84e4: 2000         	movs	r0, #0x0
;     uint32_t setupFlags = 0;
700a84e6: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_CYCLE_COUNTER_RESET;
700a84e8: 9801         	ldr	r0, [sp, #0x4]
700a84ea: f040 0004    	orr	r0, r0, #0x4
700a84ee: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_EVENT_COUNTER_RESET;
700a84f0: 9801         	ldr	r0, [sp, #0x4]
700a84f2: f040 0002    	orr	r0, r0, #0x2
700a84f6: 9001         	str	r0, [sp, #0x4]
;     setupFlags |= PmuP_SETUP_FLAG_ENABLE_ALL_COUNTERS;
700a84f8: 9801         	ldr	r0, [sp, #0x4]
700a84fa: f040 0001    	orr	r0, r0, #0x1
700a84fe: 9001         	str	r0, [sp, #0x4]
700a8500: f04f 30ff    	mov.w	r0, #0xffffffff
;     PmuP_disableCounters(PmuP_COUNTER_MASK_ALL_COUNTERS); /* disable all counters */
700a8504: 9000         	str	r0, [sp]
700a8506: f006 e9e0    	blx	0x700ae8c8 <PmuP_disableCounters> @ imm = #0x63c0
700a850a: 9800         	ldr	r0, [sp]
;     PmuP_clearOverflowStatus(PmuP_COUNTER_MASK_ALL_COUNTERS); /* clear all overflow flags */
700a850c: f006 e9e4    	blx	0x700ae8d8 <PmuP_clearOverflowStatus> @ imm = #0x63c8
;     PmuP_setup(setupFlags); /* setup counters */
700a8510: 9801         	ldr	r0, [sp, #0x4]
700a8512: f006 e9d2    	blx	0x700ae8b8 <PmuP_setup> @ imm = #0x63a4
700a8516: f04f 4000    	mov.w	r0, #0x80000000
;     PmuP_enableCounters(PmuP_COUNTER_MASK_CYCLE_COUNTER); /* enable cycle counter only */
700a851a: f006 e9d2    	blx	0x700ae8c0 <PmuP_enableCounters> @ imm = #0x63a4
; }
700a851e: b002         	add	sp, #0x8
700a8520: bd80         	pop	{r7, pc}
700a8522: bf00         	nop
700a8524: bf00         	nop
700a8526: bf00         	nop
700a8528: bf00         	nop
700a852a: bf00         	nop
700a852c: bf00         	nop
700a852e: bf00         	nop

700a8530 <CycleCounterP_nsToTicks>:
; {
700a8530: b580         	push	{r7, lr}
700a8532: b082         	sub	sp, #0x8
700a8534: 9101         	str	r1, [sp, #0x4]
700a8536: 9000         	str	r0, [sp]
;     return (((uint64_t)nanosecs*gCounterFreqHz)/PmuP_SEC_TO_NANOSEC);
700a8538: 9b00         	ldr	r3, [sp]
700a853a: 9901         	ldr	r1, [sp, #0x4]
700a853c: f642 10b0    	movw	r0, #0x29b0
700a8540: f2c7 000b    	movt	r0, #0x700b
700a8544: 6802         	ldr	r2, [r0]
700a8546: f8d0 c004    	ldr.w	r12, [r0, #0x4]
700a854a: fba3 0e02    	umull	r0, lr, r3, r2
700a854e: fb03 e30c    	mla	r3, r3, r12, lr
700a8552: fb01 3102    	mla	r1, r1, r2, r3
700a8556: f64c 2200    	movw	r2, #0xca00
700a855a: f6c3 329a    	movt	r2, #0x3b9a
700a855e: 2300         	movs	r3, #0x0
700a8560: f006 ee38    	blx	0x700af1d4 <__aeabi_uldivmod> @ imm = #0x6c70
700a8564: b002         	add	sp, #0x8
700a8566: bd80         	pop	{r7, pc}
		...

700a8570 <Sciclient_pmGetModuleClkNumParent>:
; {
700a8570: b580         	push	{r7, lr}
700a8572: b096         	sub	sp, #0x58
700a8574: 9015         	str	r0, [sp, #0x54]
700a8576: 9114         	str	r1, [sp, #0x50]
700a8578: 9213         	str	r2, [sp, #0x4c]
700a857a: 9312         	str	r3, [sp, #0x48]
700a857c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a857e: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_num_clock_parents_req request = {{0}};
700a8580: f88d 0040    	strb.w	r0, [sp, #0x40]
700a8584: 900f         	str	r0, [sp, #0x3c]
700a8586: 900e         	str	r0, [sp, #0x38]
700a8588: 900d         	str	r0, [sp, #0x34]
700a858a: 900c         	str	r0, [sp, #0x30]
;     request.device = (uint32_t) moduleId;
700a858c: 9815         	ldr	r0, [sp, #0x54]
700a858e: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a8590: 9814         	ldr	r0, [sp, #0x50]
700a8592: 28ff         	cmp	r0, #0xff
700a8594: d307         	blo	0x700a85a6 <Sciclient_pmGetModuleClkNumParent+0x36> @ imm = #0xe
700a8596: e7ff         	b	0x700a8598 <Sciclient_pmGetModuleClkNumParent+0x28> @ imm = #-0x2
;         request.clk32 = clockId;
700a8598: 9814         	ldr	r0, [sp, #0x50]
700a859a: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a859e: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a85a0: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a85a4: e003         	b	0x700a85ae <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a85a6: 9814         	ldr	r0, [sp, #0x50]
700a85a8: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a85ac: e7ff         	b	0x700a85ae <Sciclient_pmGetModuleClkNumParent+0x3e> @ imm = #-0x2
700a85ae: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_num_clock_parents_resp response = {{0}};
700a85b0: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a85b4: 900a         	str	r0, [sp, #0x28]
700a85b6: 9009         	str	r0, [sp, #0x24]
700a85b8: 9008         	str	r0, [sp, #0x20]
700a85ba: f44f 7182    	mov.w	r1, #0x104
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_NUM_CLOCK_PARENTS;
700a85be: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a85c2: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a85c4: 9104         	str	r1, [sp, #0x10]
700a85c6: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a85c8: 9105         	str	r1, [sp, #0x14]
700a85ca: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a85cc: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a85ce: 9912         	ldr	r1, [sp, #0x48]
700a85d0: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a85d2: 9000         	str	r0, [sp]
700a85d4: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a85d6: 9001         	str	r0, [sp, #0x4]
700a85d8: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a85da: 9002         	str	r0, [sp, #0x8]
700a85dc: a803         	add	r0, sp, #0xc
700a85de: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a85e0: f7f4 fffe    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xb004
700a85e4: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a85e6: 9811         	ldr	r0, [sp, #0x44]
700a85e8: b930         	cbnz	r0, 0x700a85f8 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #0xc
700a85ea: e7ff         	b	0x700a85ec <Sciclient_pmGetModuleClkNumParent+0x7c> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a85ec: 9800         	ldr	r0, [sp]
700a85ee: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a85f2: 2802         	cmp	r0, #0x2
700a85f4: d004         	beq	0x700a8600 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #0x8
700a85f6: e7ff         	b	0x700a85f8 <Sciclient_pmGetModuleClkNumParent+0x88> @ imm = #-0x2
700a85f8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a85fc: 9011         	str	r0, [sp, #0x44]
;     }
700a85fe: e7ff         	b	0x700a8600 <Sciclient_pmGetModuleClkNumParent+0x90> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a8600: 9811         	ldr	r0, [sp, #0x44]
700a8602: b928         	cbnz	r0, 0x700a8610 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #0xa
700a8604: e7ff         	b	0x700a8606 <Sciclient_pmGetModuleClkNumParent+0x96> @ imm = #-0x2
;         *numParent = (uint32_t) response.num_parents;
700a8606: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a860a: 9913         	ldr	r1, [sp, #0x4c]
700a860c: 6008         	str	r0, [r1]
;     }
700a860e: e7ff         	b	0x700a8610 <Sciclient_pmGetModuleClkNumParent+0xa0> @ imm = #-0x2
;     return retVal;
700a8610: 9811         	ldr	r0, [sp, #0x44]
700a8612: b016         	add	sp, #0x58
700a8614: bd80         	pop	{r7, pc}
		...
700a861e: 0000         	movs	r0, r0

700a8620 <xTaskPriorityDisinherit>:
; BaseType_t xTaskPriorityDisinherit(TaskHandle_t const pxMutexHolder) {
700a8620: b580         	push	{r7, lr}
700a8622: b084         	sub	sp, #0x10
700a8624: 9003         	str	r0, [sp, #0xc]
;   TCB_t *const pxTCB = pxMutexHolder;
700a8626: 9803         	ldr	r0, [sp, #0xc]
700a8628: 9002         	str	r0, [sp, #0x8]
700a862a: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700a862c: 9001         	str	r0, [sp, #0x4]
;   if (pxMutexHolder != NULL) {
700a862e: 9803         	ldr	r0, [sp, #0xc]
700a8630: 2800         	cmp	r0, #0x0
700a8632: d044         	beq	0x700a86be <xTaskPriorityDisinherit+0x9e> @ imm = #0x88
700a8634: e7ff         	b	0x700a8636 <xTaskPriorityDisinherit+0x16> @ imm = #-0x2
;     (pxTCB->uxMutexesHeld)--;
700a8636: 9902         	ldr	r1, [sp, #0x8]
700a8638: 6e48         	ldr	r0, [r1, #0x64]
700a863a: 3801         	subs	r0, #0x1
700a863c: 6648         	str	r0, [r1, #0x64]
;     if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
700a863e: 9902         	ldr	r1, [sp, #0x8]
700a8640: 6ac8         	ldr	r0, [r1, #0x2c]
700a8642: 6e09         	ldr	r1, [r1, #0x60]
700a8644: 4288         	cmp	r0, r1
700a8646: d038         	beq	0x700a86ba <xTaskPriorityDisinherit+0x9a> @ imm = #0x70
700a8648: e7ff         	b	0x700a864a <xTaskPriorityDisinherit+0x2a> @ imm = #-0x2
;       if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
700a864a: 9802         	ldr	r0, [sp, #0x8]
700a864c: 6e40         	ldr	r0, [r0, #0x64]
700a864e: bb90         	cbnz	r0, 0x700a86b6 <xTaskPriorityDisinherit+0x96> @ imm = #0x64
700a8650: e7ff         	b	0x700a8652 <xTaskPriorityDisinherit+0x32> @ imm = #-0x2
;         if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
700a8652: 9802         	ldr	r0, [sp, #0x8]
700a8654: 3004         	adds	r0, #0x4
700a8656: f005 f85b    	bl	0x700ad710 <uxListRemove> @ imm = #0x50b6
700a865a: b908         	cbnz	r0, 0x700a8660 <xTaskPriorityDisinherit+0x40> @ imm = #0x2
700a865c: e7ff         	b	0x700a865e <xTaskPriorityDisinherit+0x3e> @ imm = #-0x2
;         } else {
700a865e: e000         	b	0x700a8662 <xTaskPriorityDisinherit+0x42> @ imm = #0x0
700a8660: e7ff         	b	0x700a8662 <xTaskPriorityDisinherit+0x42> @ imm = #-0x2
;         pxTCB->uxPriority = pxTCB->uxBasePriority;
700a8662: 9902         	ldr	r1, [sp, #0x8]
700a8664: 6e08         	ldr	r0, [r1, #0x60]
700a8666: 62c8         	str	r0, [r1, #0x2c]
;         listSET_LIST_ITEM_VALUE(
700a8668: 9902         	ldr	r1, [sp, #0x8]
700a866a: 6ac8         	ldr	r0, [r1, #0x2c]
700a866c: f1c0 0020    	rsb.w	r0, r0, #0x20
700a8670: 6188         	str	r0, [r1, #0x18]
;         prvAddTaskToReadyList(pxTCB);
700a8672: 9802         	ldr	r0, [sp, #0x8]
700a8674: 6ac0         	ldr	r0, [r0, #0x2c]
700a8676: f642 212c    	movw	r1, #0x2a2c
700a867a: f2c7 010b    	movt	r1, #0x700b
700a867e: 6809         	ldr	r1, [r1]
700a8680: 4288         	cmp	r0, r1
700a8682: d908         	bls	0x700a8696 <xTaskPriorityDisinherit+0x76> @ imm = #0x10
700a8684: e7ff         	b	0x700a8686 <xTaskPriorityDisinherit+0x66> @ imm = #-0x2
700a8686: 9802         	ldr	r0, [sp, #0x8]
700a8688: 6ac0         	ldr	r0, [r0, #0x2c]
700a868a: f642 212c    	movw	r1, #0x2a2c
700a868e: f2c7 010b    	movt	r1, #0x700b
700a8692: 6008         	str	r0, [r1]
700a8694: e7ff         	b	0x700a8696 <xTaskPriorityDisinherit+0x76> @ imm = #-0x2
700a8696: 9902         	ldr	r1, [sp, #0x8]
700a8698: 6ac8         	ldr	r0, [r1, #0x2c]
700a869a: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a869e: f244 40f8    	movw	r0, #0x44f8
700a86a2: f2c7 0008    	movt	r0, #0x7008
700a86a6: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a86aa: 3104         	adds	r1, #0x4
700a86ac: f005 fde8    	bl	0x700ae280 <vListInsertEnd> @ imm = #0x5bd0
700a86b0: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700a86b2: 9001         	str	r0, [sp, #0x4]
;       } else {
700a86b4: e000         	b	0x700a86b8 <xTaskPriorityDisinherit+0x98> @ imm = #0x0
700a86b6: e7ff         	b	0x700a86b8 <xTaskPriorityDisinherit+0x98> @ imm = #-0x2
;     } else {
700a86b8: e000         	b	0x700a86bc <xTaskPriorityDisinherit+0x9c> @ imm = #0x0
700a86ba: e7ff         	b	0x700a86bc <xTaskPriorityDisinherit+0x9c> @ imm = #-0x2
;   } else {
700a86bc: e000         	b	0x700a86c0 <xTaskPriorityDisinherit+0xa0> @ imm = #0x0
700a86be: e7ff         	b	0x700a86c0 <xTaskPriorityDisinherit+0xa0> @ imm = #-0x2
;   return xReturn;
700a86c0: 9801         	ldr	r0, [sp, #0x4]
700a86c2: b004         	add	sp, #0x10
700a86c4: bd80         	pop	{r7, pc}
		...
700a86ce: 0000         	movs	r0, r0

700a86d0 <CSL_intaggrIsIntrPending>:
; {
700a86d0: b580         	push	{r7, lr}
700a86d2: b088         	sub	sp, #0x20
700a86d4: 9007         	str	r0, [sp, #0x1c]
700a86d6: 9106         	str	r1, [sp, #0x18]
700a86d8: f88d 2017    	strb.w	r2, [sp, #0x17]
700a86dc: 2000         	movs	r0, #0x0
;     bool     retVal = (bool)false;
700a86de: f88d 0016    	strb.w	r0, [sp, #0x16]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700a86e2: 9807         	ldr	r0, [sp, #0x1c]
700a86e4: 9906         	ldr	r1, [sp, #0x18]
700a86e6: f005 fc2b    	bl	0x700adf40 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x5856
700a86ea: b3e8         	cbz	r0, 0x700a8768 <CSL_intaggrIsIntrPending+0x98> @ imm = #0x7a
700a86ec: e7ff         	b	0x700a86ee <CSL_intaggrIsIntrPending+0x1e> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700a86ee: 9806         	ldr	r0, [sp, #0x18]
700a86f0: 0980         	lsrs	r0, r0, #0x6
700a86f2: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700a86f4: 9806         	ldr	r0, [sp, #0x18]
700a86f6: f000 003f    	and	r0, r0, #0x3f
700a86fa: 9000         	str	r0, [sp]
;         if( bMaskedStatus == (bool)true )
700a86fc: f89d 0017    	ldrb.w	r0, [sp, #0x17]
700a8700: 07c0         	lsls	r0, r0, #0x1f
700a8702: b158         	cbz	r0, 0x700a871c <CSL_intaggrIsIntrPending+0x4c> @ imm = #0x16
700a8704: e7ff         	b	0x700a8706 <CSL_intaggrIsIntrPending+0x36> @ imm = #-0x2
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUSM );
700a8706: 9807         	ldr	r0, [sp, #0x1c]
700a8708: 6880         	ldr	r0, [r0, #0x8]
700a870a: 9901         	ldr	r1, [sp, #0x4]
700a870c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8710: 3020         	adds	r0, #0x20
700a8712: f007 fa5d    	bl	0x700afbd0 <CSL_REG64_RD_RAW> @ imm = #0x74ba
700a8716: 9103         	str	r1, [sp, #0xc]
700a8718: 9002         	str	r0, [sp, #0x8]
;         }
700a871a: e00a         	b	0x700a8732 <CSL_intaggrIsIntrPending+0x62> @ imm = #0x14
;             regVal = CSL_REG64_RD( &pCfg->pIntrRegs->VINT[regNum].STATUS_SET );
700a871c: 9807         	ldr	r0, [sp, #0x1c]
700a871e: 6880         	ldr	r0, [r0, #0x8]
700a8720: 9901         	ldr	r1, [sp, #0x4]
700a8722: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a8726: 3010         	adds	r0, #0x10
700a8728: f007 fa52    	bl	0x700afbd0 <CSL_REG64_RD_RAW> @ imm = #0x74a4
700a872c: 9103         	str	r1, [sp, #0xc]
700a872e: 9002         	str	r0, [sp, #0x8]
700a8730: e7ff         	b	0x700a8732 <CSL_intaggrIsIntrPending+0x62> @ imm = #-0x2
;         if( (regVal & (((uint64_t)1U) << bitNum)) == 0U )
700a8732: 9802         	ldr	r0, [sp, #0x8]
700a8734: 9903         	ldr	r1, [sp, #0xc]
700a8736: 9a00         	ldr	r2, [sp]
700a8738: 40d0         	lsrs	r0, r2
700a873a: f1c2 0320    	rsb.w	r3, r2, #0x20
700a873e: fa01 f303    	lsl.w	r3, r1, r3
700a8742: 4318         	orrs	r0, r3
700a8744: 3a20         	subs	r2, #0x20
700a8746: 40d1         	lsrs	r1, r2
700a8748: 2a00         	cmp	r2, #0x0
700a874a: bf58         	it	pl
700a874c: 4608         	movpl	r0, r1
700a874e: ea4f 70c0    	lsl.w	r0, r0, #0x1f
700a8752: b920         	cbnz	r0, 0x700a875e <CSL_intaggrIsIntrPending+0x8e> @ imm = #0x8
700a8754: e7ff         	b	0x700a8756 <CSL_intaggrIsIntrPending+0x86> @ imm = #-0x2
700a8756: 2000         	movs	r0, #0x0
;             retVal = (bool)false; /* Interrupt is not pending */
700a8758: f88d 0016    	strb.w	r0, [sp, #0x16]
;         }
700a875c: e003         	b	0x700a8766 <CSL_intaggrIsIntrPending+0x96> @ imm = #0x6
700a875e: 2001         	movs	r0, #0x1
;             retVal = (bool)true;  /* Interrupt is pending */
700a8760: f88d 0016    	strb.w	r0, [sp, #0x16]
700a8764: e7ff         	b	0x700a8766 <CSL_intaggrIsIntrPending+0x96> @ imm = #-0x2
;     }
700a8766: e7ff         	b	0x700a8768 <CSL_intaggrIsIntrPending+0x98> @ imm = #-0x2
;     return retVal;
700a8768: f89d 0016    	ldrb.w	r0, [sp, #0x16]
700a876c: f000 0001    	and	r0, r0, #0x1
700a8770: b008         	add	sp, #0x20
700a8772: bd80         	pop	{r7, pc}
		...

700a8780 <Sciclient_rmIrqCheckLoop>:
; {
700a8780: b580         	push	{r7, lr}
700a8782: b088         	sub	sp, #0x20
700a8784: 9007         	str	r0, [sp, #0x1c]
700a8786: 2000         	movs	r0, #0x0
;     bool loop = false;
700a8788: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a878c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a8790: e7ff         	b	0x700a8792 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x2
700a8792: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a8796: 9002         	str	r0, [sp, #0x8]
700a8798: f007 fa72    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0x74e4
700a879c: 4601         	mov	r1, r0
700a879e: 9802         	ldr	r0, [sp, #0x8]
700a87a0: 4288         	cmp	r0, r1
700a87a2: da39         	bge	0x700a8818 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0x72
700a87a4: e7ff         	b	0x700a87a6 <Sciclient_rmIrqCheckLoop+0x26> @ imm = #-0x2
;         cur_n = Sciclient_rmPsGetIrqNode(i);
700a87a6: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a87aa: f006 fe39    	bl	0x700af420 <Sciclient_rmPsGetIrqNode> @ imm = #0x6c72
700a87ae: 9004         	str	r0, [sp, #0x10]
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a87b0: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a87b4: 3001         	adds	r0, #0x1
700a87b6: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a87ba: e7ff         	b	0x700a87bc <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x2
700a87bc: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a87c0: 9001         	str	r0, [sp, #0x4]
700a87c2: f007 fa5d    	bl	0x700afc80 <Sciclient_rmPsGetPsp> @ imm = #0x74ba
700a87c6: 4601         	mov	r1, r0
700a87c8: 9801         	ldr	r0, [sp, #0x4]
700a87ca: 4288         	cmp	r0, r1
700a87cc: da17         	bge	0x700a87fe <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0x2e
700a87ce: e7ff         	b	0x700a87d0 <Sciclient_rmIrqCheckLoop+0x50> @ imm = #-0x2
;             future_n = Sciclient_rmPsGetIrqNode(j);
700a87d0: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a87d4: f006 fe24    	bl	0x700af420 <Sciclient_rmPsGetIrqNode> @ imm = #0x6c48
700a87d8: 9003         	str	r0, [sp, #0xc]
;             if (cur_n->id == future_n->id) {
700a87da: 9804         	ldr	r0, [sp, #0x10]
700a87dc: 8800         	ldrh	r0, [r0]
700a87de: 9903         	ldr	r1, [sp, #0xc]
700a87e0: 8809         	ldrh	r1, [r1]
700a87e2: 4288         	cmp	r0, r1
700a87e4: d104         	bne	0x700a87f0 <Sciclient_rmIrqCheckLoop+0x70> @ imm = #0x8
700a87e6: e7ff         	b	0x700a87e8 <Sciclient_rmIrqCheckLoop+0x68> @ imm = #-0x2
700a87e8: 2001         	movs	r0, #0x1
;                 loop = true;
700a87ea: f88d 001b    	strb.w	r0, [sp, #0x1b]
;                 break;
700a87ee: e006         	b	0x700a87fe <Sciclient_rmIrqCheckLoop+0x7e> @ imm = #0xc
;         }
700a87f0: e7ff         	b	0x700a87f2 <Sciclient_rmIrqCheckLoop+0x72> @ imm = #-0x2
;         for (j = i + 1u; j < Sciclient_rmPsGetPsp(); j++) {
700a87f2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a87f6: 3001         	adds	r0, #0x1
700a87f8: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a87fc: e7de         	b	0x700a87bc <Sciclient_rmIrqCheckLoop+0x3c> @ imm = #-0x44
;         if (loop == true) {
700a87fe: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a8802: 07c0         	lsls	r0, r0, #0x1f
700a8804: b108         	cbz	r0, 0x700a880a <Sciclient_rmIrqCheckLoop+0x8a> @ imm = #0x2
700a8806: e7ff         	b	0x700a8808 <Sciclient_rmIrqCheckLoop+0x88> @ imm = #-0x2
;             break;
700a8808: e006         	b	0x700a8818 <Sciclient_rmIrqCheckLoop+0x98> @ imm = #0xc
;     }
700a880a: e7ff         	b	0x700a880c <Sciclient_rmIrqCheckLoop+0x8c> @ imm = #-0x2
;     for (i = 0u; i < Sciclient_rmPsGetPsp(); i++) {
700a880c: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
700a8810: 3001         	adds	r0, #0x1
700a8812: f8ad 0018    	strh.w	r0, [sp, #0x18]
700a8816: e7bc         	b	0x700a8792 <Sciclient_rmIrqCheckLoop+0x12> @ imm = #-0x88
;     return loop;
700a8818: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
700a881c: f000 0001    	and	r0, r0, #0x1
700a8820: b008         	add	sp, #0x20
700a8822: bd80         	pop	{r7, pc}
		...

700a8830 <UART_IsBaseAddrValid>:
; {
700a8830: b082         	sub	sp, #0x8
700a8832: 9001         	str	r0, [sp, #0x4]
700a8834: f06f 0002    	mvn	r0, #0x2
;     int32_t status = (int32_t)-3;
700a8838: 9000         	str	r0, [sp]
;     if ((baseAddr == CSL_UART0_BASE) ||
700a883a: 9801         	ldr	r0, [sp, #0x4]
700a883c: f1b0 7f20    	cmp.w	r0, #0x2800000
700a8840: d042         	beq	0x700a88c8 <UART_IsBaseAddrValid+0x98> @ imm = #0x84
700a8842: e7ff         	b	0x700a8844 <UART_IsBaseAddrValid+0x14> @ imm = #-0x2
;         (baseAddr == CSL_UART1_BASE) ||
700a8844: 9801         	ldr	r0, [sp, #0x4]
700a8846: 2100         	movs	r1, #0x0
700a8848: f2c0 2181    	movt	r1, #0x281
700a884c: 4288         	cmp	r0, r1
700a884e: d03b         	beq	0x700a88c8 <UART_IsBaseAddrValid+0x98> @ imm = #0x76
700a8850: e7ff         	b	0x700a8852 <UART_IsBaseAddrValid+0x22> @ imm = #-0x2
;         (baseAddr == CSL_UART2_BASE) ||
700a8852: 9801         	ldr	r0, [sp, #0x4]
700a8854: 2100         	movs	r1, #0x0
700a8856: f2c0 2182    	movt	r1, #0x282
700a885a: 4288         	cmp	r0, r1
700a885c: d034         	beq	0x700a88c8 <UART_IsBaseAddrValid+0x98> @ imm = #0x68
700a885e: e7ff         	b	0x700a8860 <UART_IsBaseAddrValid+0x30> @ imm = #-0x2
;         (baseAddr == CSL_UART3_BASE) ||
700a8860: 9801         	ldr	r0, [sp, #0x4]
700a8862: 2100         	movs	r1, #0x0
700a8864: f2c0 2183    	movt	r1, #0x283
700a8868: 4288         	cmp	r0, r1
700a886a: d02d         	beq	0x700a88c8 <UART_IsBaseAddrValid+0x98> @ imm = #0x5a
700a886c: e7ff         	b	0x700a886e <UART_IsBaseAddrValid+0x3e> @ imm = #-0x2
;         (baseAddr == CSL_UART4_BASE) ||
700a886e: 9801         	ldr	r0, [sp, #0x4]
700a8870: f1b0 7f21    	cmp.w	r0, #0x2840000
700a8874: d028         	beq	0x700a88c8 <UART_IsBaseAddrValid+0x98> @ imm = #0x50
700a8876: e7ff         	b	0x700a8878 <UART_IsBaseAddrValid+0x48> @ imm = #-0x2
;         (baseAddr == CSL_UART5_BASE) ||
700a8878: 9801         	ldr	r0, [sp, #0x4]
700a887a: 2100         	movs	r1, #0x0
700a887c: f2c0 2185    	movt	r1, #0x285
700a8880: 4288         	cmp	r0, r1
700a8882: d021         	beq	0x700a88c8 <UART_IsBaseAddrValid+0x98> @ imm = #0x42
700a8884: e7ff         	b	0x700a8886 <UART_IsBaseAddrValid+0x56> @ imm = #-0x2
;         (baseAddr == CSL_UART6_BASE) ||
700a8886: 9801         	ldr	r0, [sp, #0x4]
700a8888: 2100         	movs	r1, #0x0
700a888a: f2c0 2186    	movt	r1, #0x286
700a888e: 4288         	cmp	r0, r1
700a8890: d01a         	beq	0x700a88c8 <UART_IsBaseAddrValid+0x98> @ imm = #0x34
700a8892: e7ff         	b	0x700a8894 <UART_IsBaseAddrValid+0x64> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART0_BASE) ||
700a8894: 9801         	ldr	r0, [sp, #0x4]
700a8896: f1b0 6f94    	cmp.w	r0, #0x4a00000
700a889a: d015         	beq	0x700a88c8 <UART_IsBaseAddrValid+0x98> @ imm = #0x2a
700a889c: e7ff         	b	0x700a889e <UART_IsBaseAddrValid+0x6e> @ imm = #-0x2
;         (baseAddr == CSL_MCU_UART1_BASE) ||
700a889e: 9801         	ldr	r0, [sp, #0x4]
700a88a0: 2100         	movs	r1, #0x0
700a88a2: f2c0 41a1    	movt	r1, #0x4a1
700a88a6: 4288         	cmp	r0, r1
700a88a8: d00e         	beq	0x700a88c8 <UART_IsBaseAddrValid+0x98> @ imm = #0x1c
700a88aa: e7ff         	b	0x700a88ac <UART_IsBaseAddrValid+0x7c> @ imm = #-0x2
;         (baseAddr == MCU_UART0_BASE_AFTER_ADDR_TRANSLATE) ||
700a88ac: 9801         	ldr	r0, [sp, #0x4]
700a88ae: 2100         	movs	r1, #0x0
700a88b0: f2c8 41a0    	movt	r1, #0x84a0
700a88b4: 4288         	cmp	r0, r1
700a88b6: d007         	beq	0x700a88c8 <UART_IsBaseAddrValid+0x98> @ imm = #0xe
700a88b8: e7ff         	b	0x700a88ba <UART_IsBaseAddrValid+0x8a> @ imm = #-0x2
;         (baseAddr == MCU_UART1_BASE_AFTER_ADDR_TRANSLATE))
700a88ba: 9801         	ldr	r0, [sp, #0x4]
700a88bc: 2100         	movs	r1, #0x0
700a88be: f2c8 41a1    	movt	r1, #0x84a1
;     if ((baseAddr == CSL_UART0_BASE) ||
700a88c2: 4288         	cmp	r0, r1
700a88c4: d103         	bne	0x700a88ce <UART_IsBaseAddrValid+0x9e> @ imm = #0x6
700a88c6: e7ff         	b	0x700a88c8 <UART_IsBaseAddrValid+0x98> @ imm = #-0x2
700a88c8: 2000         	movs	r0, #0x0
;         status = 0;
700a88ca: 9000         	str	r0, [sp]
;     }
700a88cc: e7ff         	b	0x700a88ce <UART_IsBaseAddrValid+0x9e> @ imm = #-0x2
;     return status;
700a88ce: 9800         	ldr	r0, [sp]
700a88d0: b002         	add	sp, #0x8
700a88d2: 4770         	bx	lr

700a88d4 <split>:
700a88d4: e92d48f0     	push	{r4, r5, r6, r7, r11, lr}
700a88d8: e1a04000     	mov	r4, r0
700a88dc: e5900000     	ldr	r0, [r0]
700a88e0: e1a05001     	mov	r5, r1
700a88e4: e3c01001     	bic	r1, r0, #1
700a88e8: e0411005     	sub	r1, r1, r5
700a88ec: e3510010     	cmp	r1, #16
700a88f0: 3a00001b     	blo	0x700a8964 <split+0x90> @ imm = #0x6c
700a88f4: e2410008     	sub	r0, r1, #8
700a88f8: e0846005     	add	r6, r4, r5
700a88fc: e59f106c     	ldr	r1, [pc, #0x6c]         @ 0x700a8970 <split+0x9c>
700a8900: e59f206c     	ldr	r2, [pc, #0x6c]         @ 0x700a8974 <split+0xa0>
700a8904: e5a60008     	str	r0, [r6, #0x8]!
700a8908: e3c00001     	bic	r0, r0, #1
700a890c: e3520007     	cmp	r2, #7
700a8910: e0860000     	add	r0, r6, r0
700a8914: e2807008     	add	r7, r0, #8
700a8918: e0820001     	add	r0, r2, r1
700a891c: 82401008     	subhi	r1, r0, #8
700a8920: e1570001     	cmp	r7, r1
700a8924: 2a00000b     	bhs	0x700a8958 <split+0x84> @ imm = #0x2c
700a8928: e5d70000     	ldrb	r0, [r7]
700a892c: e3100001     	tst	r0, #1
700a8930: 1a000008     	bne	0x700a8958 <split+0x84> @ imm = #0x20
700a8934: e1a00007     	mov	r0, r7
700a8938: eb00172d     	bl	0x700ae5f4 <free_list_remove> @ imm = #0x5cb4
700a893c: e5960000     	ldr	r0, [r6]
700a8940: e5971000     	ldr	r1, [r7]
700a8944: e2800008     	add	r0, r0, #8
700a8948: e3c11001     	bic	r1, r1, #1
700a894c: e3c00001     	bic	r0, r0, #1
700a8950: e0800001     	add	r0, r0, r1
700a8954: e5860000     	str	r0, [r6]
700a8958: e1a00006     	mov	r0, r6
700a895c: eb0014e7     	bl	0x700add00 <free_list_insert> @ imm = #0x539c
700a8960: e1a00005     	mov	r0, r5
700a8964: e3800001     	orr	r0, r0, #1
700a8968: e5840000     	str	r0, [r4]
700a896c: e8bd88f0     	pop	{r4, r5, r6, r7, r11, pc}
700a8970: 00 53 08 70  	.word	0x70085300
700a8974: 00 00 01 00  	.word	0x00010000
700a8978: 00 00 00 00  	.word	0x00000000
700a897c: 00 00 00 00  	.word	0x00000000

700a8980 <vTaskResume>:
; void vTaskResume(TaskHandle_t xTaskToResume) {
700a8980: b580         	push	{r7, lr}
700a8982: b082         	sub	sp, #0x8
700a8984: 9001         	str	r0, [sp, #0x4]
;   TCB_t *const pxTCB = xTaskToResume;
700a8986: 9801         	ldr	r0, [sp, #0x4]
700a8988: 9000         	str	r0, [sp]
;   if ((pxTCB != pxCurrentTCB) && (pxTCB != NULL)) {
700a898a: 9800         	ldr	r0, [sp]
700a898c: f642 11fc    	movw	r1, #0x29fc
700a8990: f2c7 010b    	movt	r1, #0x700b
700a8994: 6809         	ldr	r1, [r1]
700a8996: 4288         	cmp	r0, r1
700a8998: d041         	beq	0x700a8a1e <vTaskResume+0x9e> @ imm = #0x82
700a899a: e7ff         	b	0x700a899c <vTaskResume+0x1c> @ imm = #-0x2
700a899c: 9800         	ldr	r0, [sp]
700a899e: 2800         	cmp	r0, #0x0
700a89a0: d03d         	beq	0x700a8a1e <vTaskResume+0x9e> @ imm = #0x7a
700a89a2: e7ff         	b	0x700a89a4 <vTaskResume+0x24> @ imm = #-0x2
;     taskENTER_CRITICAL();
700a89a4: f005 fee4    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x5dc8
;       if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE) {
700a89a8: 9800         	ldr	r0, [sp]
700a89aa: f004 fc89    	bl	0x700ad2c0 <prvTaskIsTaskSuspended> @ imm = #0x4912
700a89ae: b390         	cbz	r0, 0x700a8a16 <vTaskResume+0x96> @ imm = #0x64
700a89b0: e7ff         	b	0x700a89b2 <vTaskResume+0x32> @ imm = #-0x2
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700a89b2: 9800         	ldr	r0, [sp]
700a89b4: 3004         	adds	r0, #0x4
700a89b6: f004 feab    	bl	0x700ad710 <uxListRemove> @ imm = #0x4d56
;         prvAddTaskToReadyList(pxTCB);
700a89ba: 9800         	ldr	r0, [sp]
700a89bc: 6ac0         	ldr	r0, [r0, #0x2c]
700a89be: f642 212c    	movw	r1, #0x2a2c
700a89c2: f2c7 010b    	movt	r1, #0x700b
700a89c6: 6809         	ldr	r1, [r1]
700a89c8: 4288         	cmp	r0, r1
700a89ca: d908         	bls	0x700a89de <vTaskResume+0x5e> @ imm = #0x10
700a89cc: e7ff         	b	0x700a89ce <vTaskResume+0x4e> @ imm = #-0x2
700a89ce: 9800         	ldr	r0, [sp]
700a89d0: 6ac0         	ldr	r0, [r0, #0x2c]
700a89d2: f642 212c    	movw	r1, #0x2a2c
700a89d6: f2c7 010b    	movt	r1, #0x700b
700a89da: 6008         	str	r0, [r1]
700a89dc: e7ff         	b	0x700a89de <vTaskResume+0x5e> @ imm = #-0x2
700a89de: 9900         	ldr	r1, [sp]
700a89e0: 6ac8         	ldr	r0, [r1, #0x2c]
700a89e2: eb00 0280    	add.w	r2, r0, r0, lsl #2
700a89e6: f244 40f8    	movw	r0, #0x44f8
700a89ea: f2c7 0008    	movt	r0, #0x7008
700a89ee: eb00 0082    	add.w	r0, r0, r2, lsl #2
700a89f2: 3104         	adds	r1, #0x4
700a89f4: f005 fc44    	bl	0x700ae280 <vListInsertEnd> @ imm = #0x5888
;         if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
700a89f8: 9800         	ldr	r0, [sp]
700a89fa: 6ac0         	ldr	r0, [r0, #0x2c]
700a89fc: f642 11fc    	movw	r1, #0x29fc
700a8a00: f2c7 010b    	movt	r1, #0x700b
700a8a04: 6809         	ldr	r1, [r1]
700a8a06: 6ac9         	ldr	r1, [r1, #0x2c]
700a8a08: 4288         	cmp	r0, r1
700a8a0a: d302         	blo	0x700a8a12 <vTaskResume+0x92> @ imm = #0x4
700a8a0c: e7ff         	b	0x700a8a0e <vTaskResume+0x8e> @ imm = #-0x2
;           taskYIELD_IF_USING_PREEMPTION();
700a8a0e: df00         	svc	#0x0
;         } else {
700a8a10: e000         	b	0x700a8a14 <vTaskResume+0x94> @ imm = #0x0
700a8a12: e7ff         	b	0x700a8a14 <vTaskResume+0x94> @ imm = #-0x2
;       } else {
700a8a14: e000         	b	0x700a8a18 <vTaskResume+0x98> @ imm = #0x0
700a8a16: e7ff         	b	0x700a8a18 <vTaskResume+0x98> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700a8a18: f004 ff6a    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x4ed4
;   } else {
700a8a1c: e000         	b	0x700a8a20 <vTaskResume+0xa0> @ imm = #0x0
700a8a1e: e7ff         	b	0x700a8a20 <vTaskResume+0xa0> @ imm = #-0x2
; }
700a8a20: b002         	add	sp, #0x8
700a8a22: bd80         	pop	{r7, pc}
		...

700a8a30 <xQueueGenericSendFromISR>:
; {
700a8a30: b580         	push	{r7, lr}
700a8a32: b08a         	sub	sp, #0x28
700a8a34: 9009         	str	r0, [sp, #0x24]
700a8a36: 9108         	str	r1, [sp, #0x20]
700a8a38: 9207         	str	r2, [sp, #0x1c]
700a8a3a: 9306         	str	r3, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a8a3c: 9809         	ldr	r0, [sp, #0x24]
700a8a3e: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a8a40: f007 ef8e    	blx	0x700b0960 <HwiP_disable> @ imm = #0x7f1c
700a8a44: 9004         	str	r0, [sp, #0x10]
;         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
700a8a46: 9803         	ldr	r0, [sp, #0xc]
700a8a48: 6b80         	ldr	r0, [r0, #0x38]
700a8a4a: 9903         	ldr	r1, [sp, #0xc]
700a8a4c: 6bc9         	ldr	r1, [r1, #0x3c]
700a8a4e: 4288         	cmp	r0, r1
700a8a50: d304         	blo	0x700a8a5c <xQueueGenericSendFromISR+0x2c> @ imm = #0x8
700a8a52: e7ff         	b	0x700a8a54 <xQueueGenericSendFromISR+0x24> @ imm = #-0x2
700a8a54: 9806         	ldr	r0, [sp, #0x18]
700a8a56: 2802         	cmp	r0, #0x2
700a8a58: d133         	bne	0x700a8ac2 <xQueueGenericSendFromISR+0x92> @ imm = #0x66
700a8a5a: e7ff         	b	0x700a8a5c <xQueueGenericSendFromISR+0x2c> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a8a5c: 9803         	ldr	r0, [sp, #0xc]
700a8a5e: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a8a62: f88d 000b    	strb.w	r0, [sp, #0xb]
;             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
700a8a66: 9803         	ldr	r0, [sp, #0xc]
700a8a68: 6b80         	ldr	r0, [r0, #0x38]
700a8a6a: 9001         	str	r0, [sp, #0x4]
;             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
700a8a6c: 9803         	ldr	r0, [sp, #0xc]
700a8a6e: 9908         	ldr	r1, [sp, #0x20]
700a8a70: 9a06         	ldr	r2, [sp, #0x18]
700a8a72: f7fe f8c5    	bl	0x700a6c00 <prvCopyDataToQueue> @ imm = #-0x1e76
;             if( cTxLock == queueUNLOCKED )
700a8a76: f99d 000b    	ldrsb.w	r0, [sp, #0xb]
700a8a7a: 3001         	adds	r0, #0x1
700a8a7c: b9b8         	cbnz	r0, 0x700a8aae <xQueueGenericSendFromISR+0x7e> @ imm = #0x2e
700a8a7e: e7ff         	b	0x700a8a80 <xQueueGenericSendFromISR+0x50> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a8a80: 9803         	ldr	r0, [sp, #0xc]
700a8a82: 6a40         	ldr	r0, [r0, #0x24]
700a8a84: b188         	cbz	r0, 0x700a8aaa <xQueueGenericSendFromISR+0x7a> @ imm = #0x22
700a8a86: e7ff         	b	0x700a8a88 <xQueueGenericSendFromISR+0x58> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a8a88: 9803         	ldr	r0, [sp, #0xc]
700a8a8a: 3024         	adds	r0, #0x24
700a8a8c: f7ff f838    	bl	0x700a7b00 <xTaskRemoveFromEventList> @ imm = #-0xf90
700a8a90: b148         	cbz	r0, 0x700a8aa6 <xQueueGenericSendFromISR+0x76> @ imm = #0x12
700a8a92: e7ff         	b	0x700a8a94 <xQueueGenericSendFromISR+0x64> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a8a94: 9807         	ldr	r0, [sp, #0x1c]
700a8a96: b120         	cbz	r0, 0x700a8aa2 <xQueueGenericSendFromISR+0x72> @ imm = #0x8
700a8a98: e7ff         	b	0x700a8a9a <xQueueGenericSendFromISR+0x6a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a8a9a: 9907         	ldr	r1, [sp, #0x1c]
700a8a9c: 2001         	movs	r0, #0x1
700a8a9e: 6008         	str	r0, [r1]
;                                 }
700a8aa0: e000         	b	0x700a8aa4 <xQueueGenericSendFromISR+0x74> @ imm = #0x0
700a8aa2: e7ff         	b	0x700a8aa4 <xQueueGenericSendFromISR+0x74> @ imm = #-0x2
;                             }
700a8aa4: e000         	b	0x700a8aa8 <xQueueGenericSendFromISR+0x78> @ imm = #0x0
700a8aa6: e7ff         	b	0x700a8aa8 <xQueueGenericSendFromISR+0x78> @ imm = #-0x2
;                         }
700a8aa8: e000         	b	0x700a8aac <xQueueGenericSendFromISR+0x7c> @ imm = #0x0
700a8aaa: e7ff         	b	0x700a8aac <xQueueGenericSendFromISR+0x7c> @ imm = #-0x2
;             }
700a8aac: e006         	b	0x700a8abc <xQueueGenericSendFromISR+0x8c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a8aae: f89d 000b    	ldrb.w	r0, [sp, #0xb]
700a8ab2: 3001         	adds	r0, #0x1
700a8ab4: 9903         	ldr	r1, [sp, #0xc]
700a8ab6: f881 0045    	strb.w	r0, [r1, #0x45]
700a8aba: e7ff         	b	0x700a8abc <xQueueGenericSendFromISR+0x8c> @ imm = #-0x2
700a8abc: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a8abe: 9005         	str	r0, [sp, #0x14]
;         }
700a8ac0: e002         	b	0x700a8ac8 <xQueueGenericSendFromISR+0x98> @ imm = #0x4
700a8ac2: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a8ac4: 9005         	str	r0, [sp, #0x14]
700a8ac6: e7ff         	b	0x700a8ac8 <xQueueGenericSendFromISR+0x98> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a8ac8: 9804         	ldr	r0, [sp, #0x10]
700a8aca: f007 ef6a    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x7ed4
;     return xReturn;
700a8ace: 9805         	ldr	r0, [sp, #0x14]
700a8ad0: b00a         	add	sp, #0x28
700a8ad2: bd80         	pop	{r7, pc}
		...

700a8ae0 <prvCheckForValidListAndQueue>:
;     {
700a8ae0: b580         	push	{r7, lr}
700a8ae2: b084         	sub	sp, #0x10
;         taskENTER_CRITICAL();
700a8ae4: f005 fe44    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x5c88
;             if( xTimerQueue == NULL )
700a8ae8: f642 2048    	movw	r0, #0x2a48
700a8aec: f2c7 000b    	movt	r0, #0x700b
700a8af0: 6800         	ldr	r0, [r0]
700a8af2: 2800         	cmp	r0, #0x0
700a8af4: d140         	bne	0x700a8b78 <prvCheckForValidListAndQueue+0x98> @ imm = #0x80
700a8af6: e7ff         	b	0x700a8af8 <prvCheckForValidListAndQueue+0x18> @ imm = #-0x2
;                 vListInitialise( &xActiveTimerList1 );
700a8af8: f245 2010    	movw	r0, #0x5210
700a8afc: f2c7 0008    	movt	r0, #0x7008
700a8b00: 9002         	str	r0, [sp, #0x8]
700a8b02: f005 ffc5    	bl	0x700aea90 <vListInitialise> @ imm = #0x5f8a
;                 vListInitialise( &xActiveTimerList2 );
700a8b06: f245 2024    	movw	r0, #0x5224
700a8b0a: f2c7 0008    	movt	r0, #0x7008
700a8b0e: 9003         	str	r0, [sp, #0xc]
700a8b10: f005 ffbe    	bl	0x700aea90 <vListInitialise> @ imm = #0x5f7c
700a8b14: 9902         	ldr	r1, [sp, #0x8]
700a8b16: 9803         	ldr	r0, [sp, #0xc]
;                 pxCurrentTimerList = &xActiveTimerList1;
700a8b18: f245 229c    	movw	r2, #0x529c
700a8b1c: f2c7 0208    	movt	r2, #0x7008
700a8b20: 6011         	str	r1, [r2]
;                 pxOverflowTimerList = &xActiveTimerList2;
700a8b22: f245 21a8    	movw	r1, #0x52a8
700a8b26: f2c7 0108    	movt	r1, #0x7008
700a8b2a: 6008         	str	r0, [r1]
;                         xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
700a8b2c: 4669         	mov	r1, sp
700a8b2e: 2000         	movs	r0, #0x0
700a8b30: 6008         	str	r0, [r1]
700a8b32: f644 3278    	movw	r2, #0x4b78
700a8b36: f2c7 0208    	movt	r2, #0x7008
700a8b3a: f241 0308    	movw	r3, #0x1008
700a8b3e: f2c7 0308    	movt	r3, #0x7008
700a8b42: 2110         	movs	r1, #0x10
700a8b44: 4608         	mov	r0, r1
700a8b46: f004 fd4b    	bl	0x700ad5e0 <xQueueGenericCreateStatic> @ imm = #0x4a96
700a8b4a: 4601         	mov	r1, r0
700a8b4c: f642 2048    	movw	r0, #0x2a48
700a8b50: f2c7 000b    	movt	r0, #0x700b
700a8b54: 6001         	str	r1, [r0]
;                         if( xTimerQueue != NULL )
700a8b56: 6800         	ldr	r0, [r0]
700a8b58: b160         	cbz	r0, 0x700a8b74 <prvCheckForValidListAndQueue+0x94> @ imm = #0x18
700a8b5a: e7ff         	b	0x700a8b5c <prvCheckForValidListAndQueue+0x7c> @ imm = #-0x2
;                             vQueueAddToRegistry( xTimerQueue, "TmrQ" );
700a8b5c: f642 2048    	movw	r0, #0x2a48
700a8b60: f2c7 000b    	movt	r0, #0x700b
700a8b64: 6800         	ldr	r0, [r0]
700a8b66: f242 6116    	movw	r1, #0x2616
700a8b6a: f2c7 010b    	movt	r1, #0x700b
700a8b6e: f004 faa7    	bl	0x700ad0c0 <vQueueAddToRegistry> @ imm = #0x454e
;                         }
700a8b72: e000         	b	0x700a8b76 <prvCheckForValidListAndQueue+0x96> @ imm = #0x0
700a8b74: e7ff         	b	0x700a8b76 <prvCheckForValidListAndQueue+0x96> @ imm = #-0x2
;             }
700a8b76: e000         	b	0x700a8b7a <prvCheckForValidListAndQueue+0x9a> @ imm = #0x0
700a8b78: e7ff         	b	0x700a8b7a <prvCheckForValidListAndQueue+0x9a> @ imm = #-0x2
;         taskEXIT_CRITICAL();
700a8b7a: f004 feb9    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x4d72
;     }
700a8b7e: b004         	add	sp, #0x10
700a8b80: bd80         	pop	{r7, pc}
		...
700a8b8e: 0000         	movs	r0, r0

700a8b90 <Udma_rmAllocEvent>:
; {
700a8b90: b580         	push	{r7, lr}
700a8b92: b088         	sub	sp, #0x20
700a8b94: 9007         	str	r0, [sp, #0x1c]
700a8b96: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            globalEvent = UDMA_EVENT_INVALID;
700a8b9a: 9006         	str	r0, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a8b9c: 9807         	ldr	r0, [sp, #0x1c]
700a8b9e: f500 70ea    	add.w	r0, r0, #0x1d4
700a8ba2: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a8ba4: 9807         	ldr	r0, [sp, #0x1c]
700a8ba6: f500 609f    	add.w	r0, r0, #0x4f8
700a8baa: f04f 31ff    	mov.w	r1, #0xffffffff
700a8bae: f001 fe0f    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x1c1e
700a8bb2: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a8bb4: 9005         	str	r0, [sp, #0x14]
700a8bb6: e7ff         	b	0x700a8bb8 <Udma_rmAllocEvent+0x28> @ imm = #-0x2
700a8bb8: 9805         	ldr	r0, [sp, #0x14]
700a8bba: 9901         	ldr	r1, [sp, #0x4]
700a8bbc: f8d1 10dc    	ldr.w	r1, [r1, #0xdc]
700a8bc0: 4288         	cmp	r0, r1
700a8bc2: d22d         	bhs	0x700a8c20 <Udma_rmAllocEvent+0x90> @ imm = #0x5a
700a8bc4: e7ff         	b	0x700a8bc6 <Udma_rmAllocEvent+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a8bc6: 9805         	ldr	r0, [sp, #0x14]
700a8bc8: 0940         	lsrs	r0, r0, #0x5
700a8bca: 9004         	str	r0, [sp, #0x10]
;         bitPos = i - (offset << 5U);
700a8bcc: 9805         	ldr	r0, [sp, #0x14]
700a8bce: 9904         	ldr	r1, [sp, #0x10]
700a8bd0: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a8bd4: 9003         	str	r0, [sp, #0xc]
;         bitMask = (uint32_t) 1U << bitPos;
700a8bd6: 9903         	ldr	r1, [sp, #0xc]
700a8bd8: 2001         	movs	r0, #0x1
700a8bda: 4088         	lsls	r0, r1
700a8bdc: 9002         	str	r0, [sp, #0x8]
;         if((drvHandle->globalEventFlag[offset] & bitMask) == bitMask)
700a8bde: 9807         	ldr	r0, [sp, #0x1c]
700a8be0: 9904         	ldr	r1, [sp, #0x10]
700a8be2: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a8be6: f8d0 0424    	ldr.w	r0, [r0, #0x424]
700a8bea: 9902         	ldr	r1, [sp, #0x8]
700a8bec: 4008         	ands	r0, r1
700a8bee: 4288         	cmp	r0, r1
700a8bf0: d111         	bne	0x700a8c16 <Udma_rmAllocEvent+0x86> @ imm = #0x22
700a8bf2: e7ff         	b	0x700a8bf4 <Udma_rmAllocEvent+0x64> @ imm = #-0x2
;             drvHandle->globalEventFlag[offset] &= ~bitMask;
700a8bf4: 9a02         	ldr	r2, [sp, #0x8]
700a8bf6: 9807         	ldr	r0, [sp, #0x1c]
700a8bf8: 9904         	ldr	r1, [sp, #0x10]
700a8bfa: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a8bfe: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700a8c02: 4390         	bics	r0, r2
700a8c04: f8c1 0424    	str.w	r0, [r1, #0x424]
;             globalEvent = i + rmInitPrms->startGlobalEvent;  /* Add start offset */
700a8c08: 9805         	ldr	r0, [sp, #0x14]
700a8c0a: 9901         	ldr	r1, [sp, #0x4]
700a8c0c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700a8c10: 4408         	add	r0, r1
700a8c12: 9006         	str	r0, [sp, #0x18]
;             break;
700a8c14: e004         	b	0x700a8c20 <Udma_rmAllocEvent+0x90> @ imm = #0x8
;     }
700a8c16: e7ff         	b	0x700a8c18 <Udma_rmAllocEvent+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numGlobalEvent; i++)
700a8c18: 9805         	ldr	r0, [sp, #0x14]
700a8c1a: 3001         	adds	r0, #0x1
700a8c1c: 9005         	str	r0, [sp, #0x14]
700a8c1e: e7cb         	b	0x700a8bb8 <Udma_rmAllocEvent+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a8c20: 9807         	ldr	r0, [sp, #0x1c]
700a8c22: f500 609f    	add.w	r0, r0, #0x4f8
700a8c26: f003 f963    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x32c6
;     return (globalEvent);
700a8c2a: 9806         	ldr	r0, [sp, #0x18]
700a8c2c: b008         	add	sp, #0x20
700a8c2e: bd80         	pop	{r7, pc}

700a8c30 <Udma_rmAllocVintr>:
; {
700a8c30: b580         	push	{r7, lr}
700a8c32: b088         	sub	sp, #0x20
700a8c34: 9007         	str	r0, [sp, #0x1c]
700a8c36: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            vintrNum = UDMA_EVENT_INVALID;
700a8c3a: 9002         	str	r0, [sp, #0x8]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a8c3c: 9807         	ldr	r0, [sp, #0x1c]
700a8c3e: f500 70ea    	add.w	r0, r0, #0x1d4
700a8c42: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a8c44: 9807         	ldr	r0, [sp, #0x1c]
700a8c46: f500 609f    	add.w	r0, r0, #0x4f8
700a8c4a: f04f 31ff    	mov.w	r1, #0xffffffff
700a8c4e: f001 fdbf    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x1b7e
700a8c52: 2000         	movs	r0, #0x0
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a8c54: 9006         	str	r0, [sp, #0x18]
700a8c56: e7ff         	b	0x700a8c58 <Udma_rmAllocVintr+0x28> @ imm = #-0x2
700a8c58: 9806         	ldr	r0, [sp, #0x18]
700a8c5a: 9901         	ldr	r1, [sp, #0x4]
700a8c5c: f8d1 10e4    	ldr.w	r1, [r1, #0xe4]
700a8c60: 4288         	cmp	r0, r1
700a8c62: d22d         	bhs	0x700a8cc0 <Udma_rmAllocVintr+0x90> @ imm = #0x5a
700a8c64: e7ff         	b	0x700a8c66 <Udma_rmAllocVintr+0x36> @ imm = #-0x2
;         offset = i >> 5U;
700a8c66: 9806         	ldr	r0, [sp, #0x18]
700a8c68: 0940         	lsrs	r0, r0, #0x5
700a8c6a: 9005         	str	r0, [sp, #0x14]
;         bitPos = i - (offset << 5U);
700a8c6c: 9806         	ldr	r0, [sp, #0x18]
700a8c6e: 9905         	ldr	r1, [sp, #0x14]
700a8c70: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a8c74: 9004         	str	r0, [sp, #0x10]
;         bitMask = (uint32_t) 1U << bitPos;
700a8c76: 9904         	ldr	r1, [sp, #0x10]
700a8c78: 2001         	movs	r0, #0x1
700a8c7a: 4088         	lsls	r0, r1
700a8c7c: 9003         	str	r0, [sp, #0xc]
;         if((drvHandle->vintrFlag[offset] & bitMask) == bitMask)
700a8c7e: 9807         	ldr	r0, [sp, #0x1c]
700a8c80: 9905         	ldr	r1, [sp, #0x14]
700a8c82: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a8c86: f8d0 04a4    	ldr.w	r0, [r0, #0x4a4]
700a8c8a: 9903         	ldr	r1, [sp, #0xc]
700a8c8c: 4008         	ands	r0, r1
700a8c8e: 4288         	cmp	r0, r1
700a8c90: d111         	bne	0x700a8cb6 <Udma_rmAllocVintr+0x86> @ imm = #0x22
700a8c92: e7ff         	b	0x700a8c94 <Udma_rmAllocVintr+0x64> @ imm = #-0x2
;             drvHandle->vintrFlag[offset] &= ~bitMask;
700a8c94: 9a03         	ldr	r2, [sp, #0xc]
700a8c96: 9807         	ldr	r0, [sp, #0x1c]
700a8c98: 9905         	ldr	r1, [sp, #0x14]
700a8c9a: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a8c9e: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700a8ca2: 4390         	bics	r0, r2
700a8ca4: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;             vintrNum = i + rmInitPrms->startVintr;  /* Add start offset */
700a8ca8: 9806         	ldr	r0, [sp, #0x18]
700a8caa: 9901         	ldr	r1, [sp, #0x4]
700a8cac: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700a8cb0: 4408         	add	r0, r1
700a8cb2: 9002         	str	r0, [sp, #0x8]
;             break;
700a8cb4: e004         	b	0x700a8cc0 <Udma_rmAllocVintr+0x90> @ imm = #0x8
;     }
700a8cb6: e7ff         	b	0x700a8cb8 <Udma_rmAllocVintr+0x88> @ imm = #-0x2
;     for(i = 0U; i < rmInitPrms->numVintr; i++)
700a8cb8: 9806         	ldr	r0, [sp, #0x18]
700a8cba: 3001         	adds	r0, #0x1
700a8cbc: 9006         	str	r0, [sp, #0x18]
700a8cbe: e7cb         	b	0x700a8c58 <Udma_rmAllocVintr+0x28> @ imm = #-0x6a
;     SemaphoreP_post(&drvHandle->rmLockObj);
700a8cc0: 9807         	ldr	r0, [sp, #0x1c]
700a8cc2: f500 609f    	add.w	r0, r0, #0x4f8
700a8cc6: f003 f913    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x3226
;     return (vintrNum);
700a8cca: 9802         	ldr	r0, [sp, #0x8]
700a8ccc: b008         	add	sp, #0x20
700a8cce: bd80         	pop	{r7, pc}

700a8cd0 <Sciclient_getContext>:
; {
700a8cd0: b084         	sub	sp, #0x10
700a8cd2: 9003         	str	r0, [sp, #0xc]
700a8cd4: 9102         	str	r1, [sp, #0x8]
700a8cd6: 200f         	movs	r0, #0xf
;     uint32_t retVal = SCICLIENT_CONTEXT_MAX_NUM;
700a8cd8: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700a8cda: 9802         	ldr	r0, [sp, #0x8]
700a8cdc: 9000         	str	r0, [sp]
700a8cde: 2805         	cmp	r0, #0x5
700a8ce0: d841         	bhi	0x700a8d66 <Sciclient_getContext+0x96> @ imm = #0x82
700a8ce2: 9900         	ldr	r1, [sp]
700a8ce4: e8df f001    	tbb	[pc, r1]
700a8ce8: 03 0d 17 21  	.word	0x21170d03
700a8cec: 2b 35        	.short	0x352b
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8cee: 9803         	ldr	r0, [sp, #0xc]
700a8cf0: b918         	cbnz	r0, 0x700a8cfa <Sciclient_getContext+0x2a> @ imm = #0x6
700a8cf2: e7ff         	b	0x700a8cf4 <Sciclient_getContext+0x24> @ imm = #-0x2
700a8cf4: 200e         	movs	r0, #0xe
;             retVal = SCICLIENT_CONTEXT_M4_SEC_0;
700a8cf6: 9001         	str	r0, [sp, #0x4]
;         }
700a8cf8: e002         	b	0x700a8d00 <Sciclient_getContext+0x30> @ imm = #0x4
700a8cfa: 2008         	movs	r0, #0x8
;             retVal = SCICLIENT_CONTEXT_M4_NONSEC_0;
700a8cfc: 9001         	str	r0, [sp, #0x4]
700a8cfe: e7ff         	b	0x700a8d00 <Sciclient_getContext+0x30> @ imm = #-0x2
;         break;
700a8d00: e032         	b	0x700a8d68 <Sciclient_getContext+0x98> @ imm = #0x64
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8d02: 9803         	ldr	r0, [sp, #0xc]
700a8d04: b918         	cbnz	r0, 0x700a8d0e <Sciclient_getContext+0x3e> @ imm = #0x6
700a8d06: e7ff         	b	0x700a8d08 <Sciclient_getContext+0x38> @ imm = #-0x2
700a8d08: 2000         	movs	r0, #0x0
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_0;
700a8d0a: 9001         	str	r0, [sp, #0x4]
;         }
700a8d0c: e002         	b	0x700a8d14 <Sciclient_getContext+0x44> @ imm = #0x4
700a8d0e: 2001         	movs	r0, #0x1
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_0;
700a8d10: 9001         	str	r0, [sp, #0x4]
700a8d12: e7ff         	b	0x700a8d14 <Sciclient_getContext+0x44> @ imm = #-0x2
;         break;
700a8d14: e028         	b	0x700a8d68 <Sciclient_getContext+0x98> @ imm = #0x50
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8d16: 9803         	ldr	r0, [sp, #0xc]
700a8d18: b918         	cbnz	r0, 0x700a8d22 <Sciclient_getContext+0x52> @ imm = #0x6
700a8d1a: e7ff         	b	0x700a8d1c <Sciclient_getContext+0x4c> @ imm = #-0x2
700a8d1c: 2002         	movs	r0, #0x2
;             retVal = SCICLIENT_CONTEXT_R5_0_SEC_1;
700a8d1e: 9001         	str	r0, [sp, #0x4]
;         }
700a8d20: e002         	b	0x700a8d28 <Sciclient_getContext+0x58> @ imm = #0x4
700a8d22: 2003         	movs	r0, #0x3
;             retVal = SCICLIENT_CONTEXT_R5_0_NONSEC_1;
700a8d24: 9001         	str	r0, [sp, #0x4]
700a8d26: e7ff         	b	0x700a8d28 <Sciclient_getContext+0x58> @ imm = #-0x2
;         break;
700a8d28: e01e         	b	0x700a8d68 <Sciclient_getContext+0x98> @ imm = #0x3c
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8d2a: 9803         	ldr	r0, [sp, #0xc]
700a8d2c: b918         	cbnz	r0, 0x700a8d36 <Sciclient_getContext+0x66> @ imm = #0x6
700a8d2e: e7ff         	b	0x700a8d30 <Sciclient_getContext+0x60> @ imm = #-0x2
700a8d30: 2009         	movs	r0, #0x9
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_0;
700a8d32: 9001         	str	r0, [sp, #0x4]
;         }
700a8d34: e002         	b	0x700a8d3c <Sciclient_getContext+0x6c> @ imm = #0x4
700a8d36: 200a         	movs	r0, #0xa
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_0;
700a8d38: 9001         	str	r0, [sp, #0x4]
700a8d3a: e7ff         	b	0x700a8d3c <Sciclient_getContext+0x6c> @ imm = #-0x2
;         break;
700a8d3c: e014         	b	0x700a8d68 <Sciclient_getContext+0x98> @ imm = #0x28
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8d3e: 9803         	ldr	r0, [sp, #0xc]
700a8d40: b918         	cbnz	r0, 0x700a8d4a <Sciclient_getContext+0x7a> @ imm = #0x6
700a8d42: e7ff         	b	0x700a8d44 <Sciclient_getContext+0x74> @ imm = #-0x2
700a8d44: 200b         	movs	r0, #0xb
;             retVal = SCICLIENT_CONTEXT_R5_1_SEC_1;
700a8d46: 9001         	str	r0, [sp, #0x4]
;         }
700a8d48: e002         	b	0x700a8d50 <Sciclient_getContext+0x80> @ imm = #0x4
700a8d4a: 200c         	movs	r0, #0xc
;             retVal = SCICLIENT_CONTEXT_R5_1_NONSEC_1;
700a8d4c: 9001         	str	r0, [sp, #0x4]
700a8d4e: e7ff         	b	0x700a8d50 <Sciclient_getContext+0x80> @ imm = #-0x2
;         break;
700a8d50: e00a         	b	0x700a8d68 <Sciclient_getContext+0x98> @ imm = #0x14
;         if(contextType == SCICLIENT_SECURE_CONTEXT)
700a8d52: 9803         	ldr	r0, [sp, #0xc]
700a8d54: b918         	cbnz	r0, 0x700a8d5e <Sciclient_getContext+0x8e> @ imm = #0x6
700a8d56: e7ff         	b	0x700a8d58 <Sciclient_getContext+0x88> @ imm = #-0x2
700a8d58: 2004         	movs	r0, #0x4
;             retVal = SCICLIENT_CONTEXT_A53_SEC_0;
700a8d5a: 9001         	str	r0, [sp, #0x4]
;         }
700a8d5c: e002         	b	0x700a8d64 <Sciclient_getContext+0x94> @ imm = #0x4
700a8d5e: 2006         	movs	r0, #0x6
;             retVal = SCICLIENT_CONTEXT_A53_NONSEC_1;
700a8d60: 9001         	str	r0, [sp, #0x4]
700a8d62: e7ff         	b	0x700a8d64 <Sciclient_getContext+0x94> @ imm = #-0x2
;         break;
700a8d64: e000         	b	0x700a8d68 <Sciclient_getContext+0x98> @ imm = #0x0
;         break;
700a8d66: e7ff         	b	0x700a8d68 <Sciclient_getContext+0x98> @ imm = #-0x2
;     return retVal;
700a8d68: 9801         	ldr	r0, [sp, #0x4]
700a8d6a: b004         	add	sp, #0x10
700a8d6c: 4770         	bx	lr
700a8d6e: 0000         	movs	r0, r0

700a8d70 <Pinmux_config>:
; {
700a8d70: b580         	push	{r7, lr}
700a8d72: b086         	sub	sp, #0x18
700a8d74: 9005         	str	r0, [sp, #0x14]
700a8d76: 9104         	str	r1, [sp, #0x10]
700a8d78: 2000         	movs	r0, #0x0
;     uint32_t            isUnlocked = 0;
700a8d7a: 9001         	str	r0, [sp, #0x4]
;     if((NULL != pinmuxCfg) && (pinmuxCfg->offset != PINMUX_END))
700a8d7c: 9805         	ldr	r0, [sp, #0x14]
700a8d7e: 2800         	cmp	r0, #0x0
700a8d80: d042         	beq	0x700a8e08 <Pinmux_config+0x98> @ imm = #0x84
700a8d82: e7ff         	b	0x700a8d84 <Pinmux_config+0x14> @ imm = #-0x2
700a8d84: 9805         	ldr	r0, [sp, #0x14]
700a8d86: f9b0 0000    	ldrsh.w	r0, [r0]
700a8d8a: 3001         	adds	r0, #0x1
700a8d8c: b3e0         	cbz	r0, 0x700a8e08 <Pinmux_config+0x98> @ imm = #0x78
700a8d8e: e7ff         	b	0x700a8d90 <Pinmux_config+0x20> @ imm = #-0x2
;         if(PINMUX_DOMAIN_ID_MAIN == domainId)
700a8d90: 9804         	ldr	r0, [sp, #0x10]
700a8d92: b920         	cbnz	r0, 0x700a8d9e <Pinmux_config+0x2e> @ imm = #0x8
700a8d94: e7ff         	b	0x700a8d96 <Pinmux_config+0x26> @ imm = #-0x2
700a8d96: f44f 2074    	mov.w	r0, #0xf4000
;             baseAddr = CSL_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a8d9a: 9003         	str	r0, [sp, #0xc]
;         }
700a8d9c: e005         	b	0x700a8daa <Pinmux_config+0x3a> @ imm = #0xa
700a8d9e: f244 0000    	movw	r0, #0x4000
700a8da2: f2c0 4008    	movt	r0, #0x408
;             baseAddr = CSL_MCU_PADCFG_CTRL0_CFG0_BASE + PADCFG_PMUX_OFFSET;
700a8da6: 9003         	str	r0, [sp, #0xc]
700a8da8: e7ff         	b	0x700a8daa <Pinmux_config+0x3a> @ imm = #-0x2
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(baseAddr);
700a8daa: 9803         	ldr	r0, [sp, #0xc]
700a8dac: 2100         	movs	r1, #0x0
700a8dae: f7fc ff2f    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x31a2
700a8db2: 9003         	str	r0, [sp, #0xc]
;         if (pinmuxCfg->offset != PINMUX_END)
700a8db4: 9805         	ldr	r0, [sp, #0x14]
700a8db6: f9b0 0000    	ldrsh.w	r0, [r0]
700a8dba: 3001         	adds	r0, #0x1
700a8dbc: b130         	cbz	r0, 0x700a8dcc <Pinmux_config+0x5c> @ imm = #0xc
700a8dbe: e7ff         	b	0x700a8dc0 <Pinmux_config+0x50> @ imm = #-0x2
700a8dc0: 2001         	movs	r0, #0x1
;             isUnlocked = 1;
700a8dc2: 9001         	str	r0, [sp, #0x4]
;             Pinmux_unlockMMR(domainId);
700a8dc4: 9804         	ldr	r0, [sp, #0x10]
700a8dc6: f7fd fc83    	bl	0x700a66d0 <Pinmux_unlockMMR> @ imm = #-0x26fa
;         }
700a8dca: e7ff         	b	0x700a8dcc <Pinmux_config+0x5c> @ imm = #-0x2
;         while( pinmuxCfg->offset != PINMUX_END )
700a8dcc: e7ff         	b	0x700a8dce <Pinmux_config+0x5e> @ imm = #-0x2
700a8dce: 9805         	ldr	r0, [sp, #0x14]
700a8dd0: f9b0 0000    	ldrsh.w	r0, [r0]
700a8dd4: 3001         	adds	r0, #0x1
700a8dd6: b178         	cbz	r0, 0x700a8df8 <Pinmux_config+0x88> @ imm = #0x1e
700a8dd8: e7ff         	b	0x700a8dda <Pinmux_config+0x6a> @ imm = #-0x2
;             regAddr = (volatile uint32_t *)(baseAddr + pinmuxCfg->offset);
700a8dda: 9803         	ldr	r0, [sp, #0xc]
700a8ddc: 9905         	ldr	r1, [sp, #0x14]
700a8dde: f9b1 1000    	ldrsh.w	r1, [r1]
700a8de2: 4408         	add	r0, r1
700a8de4: 9002         	str	r0, [sp, #0x8]
;             CSL_REG32_WR(regAddr, pinmuxCfg->settings);
700a8de6: 9802         	ldr	r0, [sp, #0x8]
700a8de8: 9905         	ldr	r1, [sp, #0x14]
700a8dea: 6849         	ldr	r1, [r1, #0x4]
700a8dec: f006 fe78    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x6cf0
;             pinmuxCfg++;
700a8df0: 9805         	ldr	r0, [sp, #0x14]
700a8df2: 3008         	adds	r0, #0x8
700a8df4: 9005         	str	r0, [sp, #0x14]
;         while( pinmuxCfg->offset != PINMUX_END )
700a8df6: e7ea         	b	0x700a8dce <Pinmux_config+0x5e> @ imm = #-0x2c
;         if (isUnlocked)
700a8df8: 9801         	ldr	r0, [sp, #0x4]
700a8dfa: b120         	cbz	r0, 0x700a8e06 <Pinmux_config+0x96> @ imm = #0x8
700a8dfc: e7ff         	b	0x700a8dfe <Pinmux_config+0x8e> @ imm = #-0x2
;             Pinmux_lockMMR(domainId);
700a8dfe: 9804         	ldr	r0, [sp, #0x10]
700a8e00: f002 fcbe    	bl	0x700ab780 <Pinmux_lockMMR> @ imm = #0x297c
;         }
700a8e04: e7ff         	b	0x700a8e06 <Pinmux_config+0x96> @ imm = #-0x2
;     }
700a8e06: e7ff         	b	0x700a8e08 <Pinmux_config+0x98> @ imm = #-0x2
;     return;
700a8e08: b006         	add	sp, #0x18
700a8e0a: bd80         	pop	{r7, pc}
700a8e0c: 0000         	movs	r0, r0
700a8e0e: 0000         	movs	r0, r0

700a8e10 <rtos_main_freertos>:
; {
700a8e10: b082         	sub	sp, #0x8
;    System_init();
700a8e12: f005 fdc5    	bl	0x700ae9a0 <System_init> @ imm = #0x5b8a
;    Board_init();
700a8e16: f006 ffd3    	bl	0x700afdc0 <Board_init> @ imm = #0x6fa6
;    Drivers_open();
700a8e1a: f004 f8f1    	bl	0x700ad000 <Drivers_open> @ imm = #0x41e2
;    Board_driversOpen();
700a8e1e: f006 ff87    	bl	0x700afd30 <Board_driversOpen> @ imm = #0x6f0e
;    printf("Initializing FreeRTOS system...\r\n");
700a8e22: f641 4163    	movw	r1, #0x1c63
700a8e26: 2001         	movs	r0, #0x1
700a8e28: f2c7 010b    	movt	r1, #0x700b
700a8e2c: f000 ff70    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xee0
;    BaseType_t status = xTaskCreate(main_task, "MainTask", MAIN_TASK_STACK_SIZE, NULL, MAIN_TASK_PRI, NULL);
700a8e30: f64a 5081    	movw	r0, #0xad81
700a8e34: f242 1168    	movw	r1, #0x2168
700a8e38: f2c7 000a    	movt	r0, #0x700a
700a8e3c: f2c7 010b    	movt	r1, #0x700b
700a8e40: 241e         	movs	r4, #0x1e
700a8e42: f44f 5200    	mov.w	r2, #0x2000
700a8e46: 2300         	movs	r3, #0x0
700a8e48: f04f 0c00    	mov.w	r12, #0x0
700a8e4c: e9cd 4c00    	strd	r4, r12, [sp]
700a8e50: f000 fb4e    	bl	0x700a94f0 <xTaskCreate> @ imm = #0x69c
;    if (status != pdPASS)
700a8e54: 2801         	cmp	r0, #0x1
700a8e56: d010         	beq	0x700a8e7a <rtos_main_freertos+0x6a> @ imm = #0x20
;       DebugP_assert(status == pdPASS);
700a8e58: f641 7104    	movw	r1, #0x1f04
700a8e5c: f641 725c    	movw	r2, #0x1f5c
700a8e60: f242 045d    	movw	r4, #0x205d
700a8e64: f2c7 010b    	movt	r1, #0x700b
700a8e68: f2c7 020b    	movt	r2, #0x700b
700a8e6c: f2c7 040b    	movt	r4, #0x700b
700a8e70: 2000         	movs	r0, #0x0
700a8e72: 2381         	movs	r3, #0x81
700a8e74: 9400         	str	r4, [sp]
700a8e76: f001 ff03    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x1e06
;    vTaskStartScheduler();
700a8e7a: f7fe fc61    	bl	0x700a7740 <vTaskStartScheduler> @ imm = #-0x173e
700a8e7e: f641 34fd    	movw	r4, #0x1bfd
700a8e82: f2c7 040b    	movt	r4, #0x700b
700a8e86: bf00         	nop
700a8e88: bf00         	nop
700a8e8a: bf00         	nop
700a8e8c: bf00         	nop
700a8e8e: bf00         	nop
;       printf("Scheduler returned unexpectedly\r\n");
700a8e90: 4621         	mov	r1, r4
700a8e92: f04f 0001    	mov.w	r0, #0x1
700a8e96: f000 ff3b    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xe76
700a8e9a: 4621         	mov	r1, r4
700a8e9c: 2001         	movs	r0, #0x1
700a8e9e: f000 ff37    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xe6e
700a8ea2: 4621         	mov	r1, r4
700a8ea4: 2001         	movs	r0, #0x1
700a8ea6: f000 ff33    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #0xe66
;    for (;;)
700a8eaa: e7f1         	b	0x700a8e90 <rtos_main_freertos+0x80> @ imm = #-0x1e
700a8eac: 0000         	movs	r0, r0
700a8eae: 0000         	movs	r0, r0

700a8eb0 <SOC_controlModuleUnlockMMR>:
; {
700a8eb0: b580         	push	{r7, lr}
700a8eb2: b084         	sub	sp, #0x10
700a8eb4: 9003         	str	r0, [sp, #0xc]
700a8eb6: 9102         	str	r1, [sp, #0x8]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700a8eb8: 9803         	ldr	r0, [sp, #0xc]
700a8eba: bb00         	cbnz	r0, 0x700a8efe <SOC_controlModuleUnlockMMR+0x4e> @ imm = #0x40
700a8ebc: e7ff         	b	0x700a8ebe <SOC_controlModuleUnlockMMR+0xe> @ imm = #-0x2
700a8ebe: f04f 4086    	mov.w	r0, #0x43000000
700a8ec2: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700a8ec4: f7fc fea4    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x32b8
700a8ec8: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a8eca: 9801         	ldr	r0, [sp, #0x4]
700a8ecc: 9902         	ldr	r1, [sp, #0x8]
700a8ece: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a8ed2: f241 0108    	movw	r1, #0x1008
700a8ed6: 4408         	add	r0, r1
700a8ed8: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a8eda: 9800         	ldr	r0, [sp]
700a8edc: f243 4190    	movw	r1, #0x3490
700a8ee0: f6c6 01ef    	movt	r1, #0x68ef
700a8ee4: f006 fe0c    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0x6c18
;         kickAddr++;
700a8ee8: 9800         	ldr	r0, [sp]
700a8eea: 3004         	adds	r0, #0x4
700a8eec: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a8eee: 9800         	ldr	r0, [sp]
700a8ef0: f64b 415a    	movw	r1, #0xbc5a
700a8ef4: f2cd 1172    	movt	r1, #0xd172
700a8ef8: f006 fe02    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0x6c04
;     }
700a8efc: e7ff         	b	0x700a8efe <SOC_controlModuleUnlockMMR+0x4e> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700a8efe: 9803         	ldr	r0, [sp, #0xc]
700a8f00: 2801         	cmp	r0, #0x1
700a8f02: d120         	bne	0x700a8f46 <SOC_controlModuleUnlockMMR+0x96> @ imm = #0x40
700a8f04: e7ff         	b	0x700a8f06 <SOC_controlModuleUnlockMMR+0x56> @ imm = #-0x2
700a8f06: f04f 608a    	mov.w	r0, #0x4500000
700a8f0a: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700a8f0c: f7fc fe80    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x3300
700a8f10: 9001         	str	r0, [sp, #0x4]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700a8f12: 9801         	ldr	r0, [sp, #0x4]
700a8f14: 9902         	ldr	r1, [sp, #0x8]
700a8f16: eb00 3081    	add.w	r0, r0, r1, lsl #14
700a8f1a: f241 0108    	movw	r1, #0x1008
700a8f1e: 4408         	add	r0, r1
700a8f20: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK0_UNLOCK_VAL);   /* KICK 0 */
700a8f22: 9800         	ldr	r0, [sp]
700a8f24: f243 4190    	movw	r1, #0x3490
700a8f28: f6c6 01ef    	movt	r1, #0x68ef
700a8f2c: f006 fde8    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0x6bd0
;         kickAddr++;
700a8f30: 9800         	ldr	r0, [sp]
700a8f32: 3004         	adds	r0, #0x4
700a8f34: 9000         	str	r0, [sp]
;         CSL_REG32_WR(kickAddr, KICK1_UNLOCK_VAL);   /* KICK 1 */
700a8f36: 9800         	ldr	r0, [sp]
700a8f38: f64b 415a    	movw	r1, #0xbc5a
700a8f3c: f2cd 1172    	movt	r1, #0xd172
700a8f40: f006 fdde    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0x6bbc
;     }
700a8f44: e7ff         	b	0x700a8f46 <SOC_controlModuleUnlockMMR+0x96> @ imm = #-0x2
;     return;
700a8f46: b004         	add	sp, #0x10
700a8f48: bd80         	pop	{r7, pc}
700a8f4a: 0000         	movs	r0, r0
700a8f4c: 0000         	movs	r0, r0
700a8f4e: 0000         	movs	r0, r0

700a8f50 <Sciclient_pmGetModuleClkFreq>:
; {
700a8f50: b580         	push	{r7, lr}
700a8f52: b096         	sub	sp, #0x58
700a8f54: 9015         	str	r0, [sp, #0x54]
700a8f56: 9114         	str	r1, [sp, #0x50]
700a8f58: 9213         	str	r2, [sp, #0x4c]
700a8f5a: 9312         	str	r3, [sp, #0x48]
700a8f5c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a8f5e: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a8f60: 9815         	ldr	r0, [sp, #0x54]
700a8f62: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a8f64: 9814         	ldr	r0, [sp, #0x50]
700a8f66: 28ff         	cmp	r0, #0xff
700a8f68: d307         	blo	0x700a8f7a <Sciclient_pmGetModuleClkFreq+0x2a> @ imm = #0xe
700a8f6a: e7ff         	b	0x700a8f6c <Sciclient_pmGetModuleClkFreq+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a8f6c: 9814         	ldr	r0, [sp, #0x50]
700a8f6e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a8f72: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a8f74: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a8f78: e003         	b	0x700a8f82 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a8f7a: 9814         	ldr	r0, [sp, #0x50]
700a8f7c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a8f80: e7ff         	b	0x700a8f82 <Sciclient_pmGetModuleClkFreq+0x32> @ imm = #-0x2
700a8f82: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_freq_resp response = {{0}};
700a8f84: 900b         	str	r0, [sp, #0x2c]
700a8f86: 900a         	str	r0, [sp, #0x28]
700a8f88: 9009         	str	r0, [sp, #0x24]
700a8f8a: 9008         	str	r0, [sp, #0x20]
700a8f8c: f44f 7187    	mov.w	r1, #0x10e
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_FREQ;
700a8f90: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a8f94: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a8f96: 9104         	str	r1, [sp, #0x10]
700a8f98: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a8f9a: 9105         	str	r1, [sp, #0x14]
700a8f9c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a8f9e: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a8fa0: 9912         	ldr	r1, [sp, #0x48]
700a8fa2: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a8fa4: 9000         	str	r0, [sp]
700a8fa6: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a8fa8: 9001         	str	r0, [sp, #0x4]
700a8faa: 2010         	movs	r0, #0x10
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a8fac: 9002         	str	r0, [sp, #0x8]
700a8fae: a803         	add	r0, sp, #0xc
700a8fb0: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a8fb2: f7f4 fb15    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xb9d6
700a8fb6: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a8fb8: 9811         	ldr	r0, [sp, #0x44]
700a8fba: b930         	cbnz	r0, 0x700a8fca <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #0xc
700a8fbc: e7ff         	b	0x700a8fbe <Sciclient_pmGetModuleClkFreq+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a8fbe: 9800         	ldr	r0, [sp]
700a8fc0: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a8fc4: 2802         	cmp	r0, #0x2
700a8fc6: d004         	beq	0x700a8fd2 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #0x8
700a8fc8: e7ff         	b	0x700a8fca <Sciclient_pmGetModuleClkFreq+0x7a> @ imm = #-0x2
700a8fca: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a8fce: 9011         	str	r0, [sp, #0x44]
;     }
700a8fd0: e7ff         	b	0x700a8fd2 <Sciclient_pmGetModuleClkFreq+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a8fd2: 9811         	ldr	r0, [sp, #0x44]
700a8fd4: b930         	cbnz	r0, 0x700a8fe4 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #0xc
700a8fd6: e7ff         	b	0x700a8fd8 <Sciclient_pmGetModuleClkFreq+0x88> @ imm = #-0x2
;         *freqHz = (uint64_t) response.freq_hz;
700a8fd8: 980a         	ldr	r0, [sp, #0x28]
700a8fda: 9a0b         	ldr	r2, [sp, #0x2c]
700a8fdc: 9913         	ldr	r1, [sp, #0x4c]
700a8fde: 604a         	str	r2, [r1, #0x4]
700a8fe0: 6008         	str	r0, [r1]
;     }
700a8fe2: e7ff         	b	0x700a8fe4 <Sciclient_pmGetModuleClkFreq+0x94> @ imm = #-0x2
;     return retVal;
700a8fe4: 9811         	ldr	r0, [sp, #0x44]
700a8fe6: b016         	add	sp, #0x58
700a8fe8: bd80         	pop	{r7, pc}
700a8fea: 0000         	movs	r0, r0
700a8fec: 0000         	movs	r0, r0
700a8fee: 0000         	movs	r0, r0

700a8ff0 <Sciclient_pmGetModuleClkParent>:
; {
700a8ff0: b580         	push	{r7, lr}
700a8ff2: b096         	sub	sp, #0x58
700a8ff4: 9015         	str	r0, [sp, #0x54]
700a8ff6: 9114         	str	r1, [sp, #0x50]
700a8ff8: 9213         	str	r2, [sp, #0x4c]
700a8ffa: 9312         	str	r3, [sp, #0x48]
700a8ffc: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a8ffe: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a9000: 9815         	ldr	r0, [sp, #0x54]
700a9002: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a9004: 9814         	ldr	r0, [sp, #0x50]
700a9006: 28ff         	cmp	r0, #0xff
700a9008: d307         	blo	0x700a901a <Sciclient_pmGetModuleClkParent+0x2a> @ imm = #0xe
700a900a: e7ff         	b	0x700a900c <Sciclient_pmGetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a900c: 9814         	ldr	r0, [sp, #0x50]
700a900e: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a9012: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a9014: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a9018: e003         	b	0x700a9022 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a901a: 9814         	ldr	r0, [sp, #0x50]
700a901c: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a9020: e7ff         	b	0x700a9022 <Sciclient_pmGetModuleClkParent+0x32> @ imm = #-0x2
700a9022: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_parent_resp response = {{0}};
700a9024: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a9028: 900a         	str	r0, [sp, #0x28]
700a902a: 9009         	str	r0, [sp, #0x24]
700a902c: 9008         	str	r0, [sp, #0x20]
700a902e: f240 1103    	movw	r1, #0x103
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK_PARENT;
700a9032: f8ad 100c    	strh.w	r1, [sp, #0xc]
700a9036: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a9038: 9104         	str	r1, [sp, #0x10]
700a903a: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a903c: 9105         	str	r1, [sp, #0x14]
700a903e: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9040: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a9042: 9912         	ldr	r1, [sp, #0x48]
700a9044: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9046: 9000         	str	r0, [sp]
700a9048: a808         	add	r0, sp, #0x20
;     respParam.pRespPayload    = (uint8_t *) &response;
700a904a: 9001         	str	r0, [sp, #0x4]
700a904c: 200d         	movs	r0, #0xd
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a904e: 9002         	str	r0, [sp, #0x8]
700a9050: a803         	add	r0, sp, #0xc
700a9052: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9054: f7f4 fac4    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xba78
700a9058: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a905a: 9811         	ldr	r0, [sp, #0x44]
700a905c: b930         	cbnz	r0, 0x700a906c <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #0xc
700a905e: e7ff         	b	0x700a9060 <Sciclient_pmGetModuleClkParent+0x70> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9060: 9800         	ldr	r0, [sp]
700a9062: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9066: 2802         	cmp	r0, #0x2
700a9068: d004         	beq	0x700a9074 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #0x8
700a906a: e7ff         	b	0x700a906c <Sciclient_pmGetModuleClkParent+0x7c> @ imm = #-0x2
700a906c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9070: 9011         	str	r0, [sp, #0x44]
;     }
700a9072: e7ff         	b	0x700a9074 <Sciclient_pmGetModuleClkParent+0x84> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a9074: 9811         	ldr	r0, [sp, #0x44]
700a9076: b928         	cbnz	r0, 0x700a9084 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #0xa
700a9078: e7ff         	b	0x700a907a <Sciclient_pmGetModuleClkParent+0x8a> @ imm = #-0x2
;         *parent = (uint32_t) response.parent;
700a907a: f89d 0028    	ldrb.w	r0, [sp, #0x28]
700a907e: 9913         	ldr	r1, [sp, #0x4c]
700a9080: 6008         	str	r0, [r1]
;     }
700a9082: e7ff         	b	0x700a9084 <Sciclient_pmGetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a9084: 9811         	ldr	r0, [sp, #0x44]
700a9086: b016         	add	sp, #0x58
700a9088: bd80         	pop	{r7, pc}
700a908a: 0000         	movs	r0, r0
700a908c: 0000         	movs	r0, r0
700a908e: 0000         	movs	r0, r0

700a9090 <Sciclient_pmSetModuleClkParent>:
; {
700a9090: b580         	push	{r7, lr}
700a9092: b094         	sub	sp, #0x50
700a9094: 9013         	str	r0, [sp, #0x4c]
700a9096: 9112         	str	r1, [sp, #0x48]
700a9098: 9211         	str	r2, [sp, #0x44]
700a909a: 9310         	str	r3, [sp, #0x40]
700a909c: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a909e: 900f         	str	r0, [sp, #0x3c]
;     request.device = (uint32_t) moduleId;
700a90a0: 9813         	ldr	r0, [sp, #0x4c]
700a90a2: 900b         	str	r0, [sp, #0x2c]
;     if (clockId >= 255U)
700a90a4: 9812         	ldr	r0, [sp, #0x48]
700a90a6: 28ff         	cmp	r0, #0xff
700a90a8: d307         	blo	0x700a90ba <Sciclient_pmSetModuleClkParent+0x2a> @ imm = #0xe
700a90aa: e7ff         	b	0x700a90ac <Sciclient_pmSetModuleClkParent+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a90ac: 9812         	ldr	r0, [sp, #0x48]
700a90ae: f8cd 0032    	str.w	r0, [sp, #0x32]
700a90b2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a90b4: f88d 0030    	strb.w	r0, [sp, #0x30]
;     }
700a90b8: e003         	b	0x700a90c2 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a90ba: 9812         	ldr	r0, [sp, #0x48]
700a90bc: f88d 0030    	strb.w	r0, [sp, #0x30]
700a90c0: e7ff         	b	0x700a90c2 <Sciclient_pmSetModuleClkParent+0x32> @ imm = #-0x2
;     if (parent >= 255U)
700a90c2: 9811         	ldr	r0, [sp, #0x44]
700a90c4: 28ff         	cmp	r0, #0xff
700a90c6: d307         	blo	0x700a90d8 <Sciclient_pmSetModuleClkParent+0x48> @ imm = #0xe
700a90c8: e7ff         	b	0x700a90ca <Sciclient_pmSetModuleClkParent+0x3a> @ imm = #-0x2
;         request.parent32 = parent;
700a90ca: 9811         	ldr	r0, [sp, #0x44]
700a90cc: f8cd 0036    	str.w	r0, [sp, #0x36]
700a90d0: 20ff         	movs	r0, #0xff
;         request.parent   = (uint8_t) 255U;
700a90d2: f88d 0031    	strb.w	r0, [sp, #0x31]
;     }
700a90d6: e003         	b	0x700a90e0 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #0x6
;         request.parent = (uint8_t) parent;
700a90d8: 9811         	ldr	r0, [sp, #0x44]
700a90da: f88d 0031    	strb.w	r0, [sp, #0x31]
700a90de: e7ff         	b	0x700a90e0 <Sciclient_pmSetModuleClkParent+0x50> @ imm = #-0x2
700a90e0: f44f 7081    	mov.w	r0, #0x102
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK_PARENT;
700a90e4: f8ad 0010    	strh.w	r0, [sp, #0x10]
700a90e8: 2002         	movs	r0, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a90ea: 9005         	str	r0, [sp, #0x14]
700a90ec: a809         	add	r0, sp, #0x24
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a90ee: 9006         	str	r0, [sp, #0x18]
700a90f0: 2016         	movs	r0, #0x16
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a90f2: 9007         	str	r0, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a90f4: 9810         	ldr	r0, [sp, #0x40]
700a90f6: 9008         	str	r0, [sp, #0x20]
700a90f8: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a90fa: 9001         	str	r0, [sp, #0x4]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a90fc: 9002         	str	r0, [sp, #0x8]
;     respParam.respPayloadSize = (uint32_t) 0;
700a90fe: 9003         	str	r0, [sp, #0xc]
700a9100: a804         	add	r0, sp, #0x10
700a9102: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9104: f7f4 fa6c    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xbb28
700a9108: 900f         	str	r0, [sp, #0x3c]
;     if((retVal != SystemP_SUCCESS) ||
700a910a: 980f         	ldr	r0, [sp, #0x3c]
700a910c: b930         	cbnz	r0, 0x700a911c <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #0xc
700a910e: e7ff         	b	0x700a9110 <Sciclient_pmSetModuleClkParent+0x80> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9110: 9801         	ldr	r0, [sp, #0x4]
700a9112: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9116: 2802         	cmp	r0, #0x2
700a9118: d004         	beq	0x700a9124 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #0x8
700a911a: e7ff         	b	0x700a911c <Sciclient_pmSetModuleClkParent+0x8c> @ imm = #-0x2
700a911c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9120: 900f         	str	r0, [sp, #0x3c]
;     }
700a9122: e7ff         	b	0x700a9124 <Sciclient_pmSetModuleClkParent+0x94> @ imm = #-0x2
;     return retVal;
700a9124: 980f         	ldr	r0, [sp, #0x3c]
700a9126: b014         	add	sp, #0x50
700a9128: bd80         	pop	{r7, pc}
700a912a: 0000         	movs	r0, r0
700a912c: 0000         	movs	r0, r0
700a912e: 0000         	movs	r0, r0

700a9130 <Sciclient_rmIrOutpIsFree>:
; {
700a9130: b580         	push	{r7, lr}
700a9132: b086         	sub	sp, #0x18
700a9134: f8ad 0016    	strh.w	r0, [sp, #0x16]
700a9138: f8ad 1014    	strh.w	r1, [sp, #0x14]
700a913c: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a913e: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIrInst *inst = NULL;
700a9140: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIrGetInst(id);
700a9142: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700a9146: f002 fd13    	bl	0x700abb70 <Sciclient_rmIrGetInst> @ imm = #0x2a26
700a914a: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700a914c: 9803         	ldr	r0, [sp, #0xc]
700a914e: b920         	cbnz	r0, 0x700a915a <Sciclient_rmIrOutpIsFree+0x2a> @ imm = #0x8
700a9150: e7ff         	b	0x700a9152 <Sciclient_rmIrOutpIsFree+0x22> @ imm = #-0x2
700a9152: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700a9156: 9004         	str	r0, [sp, #0x10]
;     } else {
700a9158: e00b         	b	0x700a9172 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #0x16
;         if (outp >= inst->n_outp) {
700a915a: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a915e: 9903         	ldr	r1, [sp, #0xc]
700a9160: 8949         	ldrh	r1, [r1, #0xa]
700a9162: 4288         	cmp	r0, r1
700a9164: db04         	blt	0x700a9170 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #0x8
700a9166: e7ff         	b	0x700a9168 <Sciclient_rmIrOutpIsFree+0x38> @ imm = #-0x2
700a9168: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700a916c: 9004         	str	r0, [sp, #0x10]
;         }
700a916e: e7ff         	b	0x700a9170 <Sciclient_rmIrOutpIsFree+0x40> @ imm = #-0x2
700a9170: e7ff         	b	0x700a9172 <Sciclient_rmIrOutpIsFree+0x42> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700a9172: 9804         	ldr	r0, [sp, #0x10]
700a9174: bb30         	cbnz	r0, 0x700a91c4 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #0x4c
700a9176: e7ff         	b	0x700a9178 <Sciclient_rmIrOutpIsFree+0x48> @ imm = #-0x2
;         int_ctrl_reg = (volatile uint32_t *) Sciclient_getIrAddr (inst->cfg, outp);
700a9178: 9803         	ldr	r0, [sp, #0xc]
700a917a: 6840         	ldr	r0, [r0, #0x4]
700a917c: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a9180: f005 fd16    	bl	0x700aebb0 <Sciclient_getIrAddr> @ imm = #0x5a2c
700a9184: 9002         	str	r0, [sp, #0x8]
;         extracted_inp = CSL_REG32_FEXT(int_ctrl_reg,
700a9186: 9802         	ldr	r0, [sp, #0x8]
700a9188: f240 31ff    	movw	r1, #0x3ff
700a918c: 2200         	movs	r2, #0x0
700a918e: f005 ffdf    	bl	0x700af150 <CSL_REG32_FEXT_RAW> @ imm = #0x5fbe
700a9192: f8ad 0006    	strh.w	r0, [sp, #0x6]
;         if (((extracted_inp != 0u) &&
700a9196: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700a919a: b138         	cbz	r0, 0x700a91ac <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #0xe
700a919c: e7ff         	b	0x700a919e <Sciclient_rmIrOutpIsFree+0x6e> @ imm = #-0x2
;              (Sciclient_rmIrOutpRomMapped(inst, outp) == false)) ||
700a919e: 9803         	ldr	r0, [sp, #0xc]
700a91a0: f8bd 1014    	ldrh.w	r1, [sp, #0x14]
700a91a4: f7ff f934    	bl	0x700a8410 <Sciclient_rmIrOutpRomMapped> @ imm = #-0xd98
700a91a8: b138         	cbz	r0, 0x700a91ba <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #0xe
700a91aa: e7ff         	b	0x700a91ac <Sciclient_rmIrOutpIsFree+0x7c> @ imm = #-0x2
;             (outp == inst->inp0_mapping)) {
700a91ac: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700a91b0: 9903         	ldr	r1, [sp, #0xc]
700a91b2: 8989         	ldrh	r1, [r1, #0xc]
;         if (((extracted_inp != 0u) &&
700a91b4: 4288         	cmp	r0, r1
700a91b6: d104         	bne	0x700a91c2 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #0x8
700a91b8: e7ff         	b	0x700a91ba <Sciclient_rmIrOutpIsFree+0x8a> @ imm = #-0x2
700a91ba: f04f 30ff    	mov.w	r0, #0xffffffff
;             r = SystemP_FAILURE;
700a91be: 9004         	str	r0, [sp, #0x10]
;         }
700a91c0: e7ff         	b	0x700a91c2 <Sciclient_rmIrOutpIsFree+0x92> @ imm = #-0x2
;     }
700a91c2: e7ff         	b	0x700a91c4 <Sciclient_rmIrOutpIsFree+0x94> @ imm = #-0x2
;     return r;
700a91c4: 9804         	ldr	r0, [sp, #0x10]
700a91c6: b006         	add	sp, #0x18
700a91c8: bd80         	pop	{r7, pc}
700a91ca: 0000         	movs	r0, r0
700a91cc: 0000         	movs	r0, r0
700a91ce: 0000         	movs	r0, r0

700a91d0 <Udma_ringQueueRaw>:
; {
700a91d0: b580         	push	{r7, lr}
700a91d2: b088         	sub	sp, #0x20
700a91d4: 9007         	str	r0, [sp, #0x1c]
700a91d6: 9305         	str	r3, [sp, #0x14]
700a91d8: 9204         	str	r2, [sp, #0x10]
700a91da: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a91dc: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a91de: 9807         	ldr	r0, [sp, #0x1c]
700a91e0: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a91e2: 9800         	ldr	r0, [sp]
700a91e4: b180         	cbz	r0, 0x700a9208 <Udma_ringQueueRaw+0x38> @ imm = #0x20
700a91e6: e7ff         	b	0x700a91e8 <Udma_ringQueueRaw+0x18> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a91e8: 9800         	ldr	r0, [sp]
700a91ea: 6d80         	ldr	r0, [r0, #0x58]
700a91ec: f64a 31cd    	movw	r1, #0xabcd
700a91f0: f6ca 31dc    	movt	r1, #0xabdc
700a91f4: 4288         	cmp	r0, r1
700a91f6: d107         	bne	0x700a9208 <Udma_ringQueueRaw+0x38> @ imm = #0xe
700a91f8: e7ff         	b	0x700a91fa <Udma_ringQueueRaw+0x2a> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a91fa: 9800         	ldr	r0, [sp]
700a91fc: 8880         	ldrh	r0, [r0, #0x4]
700a91fe: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a9202: 4288         	cmp	r0, r1
700a9204: d104         	bne	0x700a9210 <Udma_ringQueueRaw+0x40> @ imm = #0x8
700a9206: e7ff         	b	0x700a9208 <Udma_ringQueueRaw+0x38> @ imm = #-0x2
700a9208: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a920c: 9003         	str	r0, [sp, #0xc]
;     }
700a920e: e7ff         	b	0x700a9210 <Udma_ringQueueRaw+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9210: 9803         	ldr	r0, [sp, #0xc]
700a9212: b9a8         	cbnz	r0, 0x700a9240 <Udma_ringQueueRaw+0x70> @ imm = #0x2a
700a9214: e7ff         	b	0x700a9216 <Udma_ringQueueRaw+0x46> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a9216: 9800         	ldr	r0, [sp]
700a9218: 6800         	ldr	r0, [r0]
700a921a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a921c: 9801         	ldr	r0, [sp, #0x4]
700a921e: b150         	cbz	r0, 0x700a9236 <Udma_ringQueueRaw+0x66> @ imm = #0x14
700a9220: e7ff         	b	0x700a9222 <Udma_ringQueueRaw+0x52> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a9222: 9801         	ldr	r0, [sp, #0x4]
700a9224: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a9228: f64a 31cd    	movw	r1, #0xabcd
700a922c: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a9230: 4288         	cmp	r0, r1
700a9232: d004         	beq	0x700a923e <Udma_ringQueueRaw+0x6e> @ imm = #0x8
700a9234: e7ff         	b	0x700a9236 <Udma_ringQueueRaw+0x66> @ imm = #-0x2
700a9236: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a923a: 9003         	str	r0, [sp, #0xc]
;         }
700a923c: e7ff         	b	0x700a923e <Udma_ringQueueRaw+0x6e> @ imm = #-0x2
;     }
700a923e: e7ff         	b	0x700a9240 <Udma_ringQueueRaw+0x70> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a9240: 9803         	ldr	r0, [sp, #0xc]
700a9242: b978         	cbnz	r0, 0x700a9264 <Udma_ringQueueRaw+0x94> @ imm = #0x1e
700a9244: e7ff         	b	0x700a9246 <Udma_ringQueueRaw+0x76> @ imm = #-0x2
;         cookie = HwiP_disable();
700a9246: f007 eb8c    	blx	0x700b0960 <HwiP_disable> @ imm = #0x7718
700a924a: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringQueueRaw(drvHandle, ringHandleInt, phyDescMem);
700a924c: 9801         	ldr	r0, [sp, #0x4]
700a924e: f8d0 c594    	ldr.w	r12, [r0, #0x594]
700a9252: 9900         	ldr	r1, [sp]
700a9254: 9a04         	ldr	r2, [sp, #0x10]
700a9256: 9b05         	ldr	r3, [sp, #0x14]
700a9258: 47e0         	blx	r12
700a925a: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a925c: 9802         	ldr	r0, [sp, #0x8]
700a925e: f007 eba0    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x7740
;     }
700a9262: e7ff         	b	0x700a9264 <Udma_ringQueueRaw+0x94> @ imm = #-0x2
;     return (retVal);
700a9264: 9803         	ldr	r0, [sp, #0xc]
700a9266: b008         	add	sp, #0x20
700a9268: bd80         	pop	{r7, pc}
700a926a: 0000         	movs	r0, r0
700a926c: 0000         	movs	r0, r0
700a926e: 0000         	movs	r0, r0

700a9270 <xTaskCheckForTimeOut>:
;                                 TickType_t *const pxTicksToWait) {
700a9270: b580         	push	{r7, lr}
700a9272: b086         	sub	sp, #0x18
700a9274: 9005         	str	r0, [sp, #0x14]
700a9276: 9104         	str	r1, [sp, #0x10]
;   taskENTER_CRITICAL();
700a9278: f005 fa7a    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x54f4
;     const TickType_t xConstTickCount = xTickCount;
700a927c: f642 2044    	movw	r0, #0x2a44
700a9280: f2c7 000b    	movt	r0, #0x700b
700a9284: 6800         	ldr	r0, [r0]
700a9286: 9002         	str	r0, [sp, #0x8]
;         xConstTickCount - pxTimeOut->xTimeOnEntering;
700a9288: 9802         	ldr	r0, [sp, #0x8]
700a928a: 9905         	ldr	r1, [sp, #0x14]
700a928c: 6849         	ldr	r1, [r1, #0x4]
700a928e: 1a40         	subs	r0, r0, r1
;     const TickType_t xElapsedTime =
700a9290: 9001         	str	r0, [sp, #0x4]
;         if (*pxTicksToWait == portMAX_DELAY) {
700a9292: 9804         	ldr	r0, [sp, #0x10]
700a9294: 6800         	ldr	r0, [r0]
700a9296: 3001         	adds	r0, #0x1
700a9298: b918         	cbnz	r0, 0x700a92a2 <xTaskCheckForTimeOut+0x32> @ imm = #0x6
700a929a: e7ff         	b	0x700a929c <xTaskCheckForTimeOut+0x2c> @ imm = #-0x2
700a929c: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a929e: 9003         	str	r0, [sp, #0xc]
;     } else
700a92a0: e02e         	b	0x700a9300 <xTaskCheckForTimeOut+0x90> @ imm = #0x5c
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a92a2: f642 2038    	movw	r0, #0x2a38
700a92a6: f2c7 000b    	movt	r0, #0x700b
700a92aa: 6800         	ldr	r0, [r0]
700a92ac: 9905         	ldr	r1, [sp, #0x14]
700a92ae: 6809         	ldr	r1, [r1]
700a92b0: 4288         	cmp	r0, r1
700a92b2: d00c         	beq	0x700a92ce <xTaskCheckForTimeOut+0x5e> @ imm = #0x18
700a92b4: e7ff         	b	0x700a92b6 <xTaskCheckForTimeOut+0x46> @ imm = #-0x2
;             (xConstTickCount >=
700a92b6: 9802         	ldr	r0, [sp, #0x8]
;              pxTimeOut
700a92b8: 9905         	ldr	r1, [sp, #0x14]
;                  ->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to
700a92ba: 6849         	ldr	r1, [r1, #0x4]
;         if ((xNumOfOverflows != pxTimeOut->xOverflowCount) &&
700a92bc: 4288         	cmp	r0, r1
700a92be: d306         	blo	0x700a92ce <xTaskCheckForTimeOut+0x5e> @ imm = #0xc
700a92c0: e7ff         	b	0x700a92c2 <xTaskCheckForTimeOut+0x52> @ imm = #-0x2
700a92c2: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a92c4: 9003         	str	r0, [sp, #0xc]
;       *pxTicksToWait = (TickType_t)0;
700a92c6: 9904         	ldr	r1, [sp, #0x10]
700a92c8: 2000         	movs	r0, #0x0
700a92ca: 6008         	str	r0, [r1]
;     } else if (xElapsedTime <
700a92cc: e017         	b	0x700a92fe <xTaskCheckForTimeOut+0x8e> @ imm = #0x2e
700a92ce: 9801         	ldr	r0, [sp, #0x4]
;                *pxTicksToWait) /*lint !e961 Explicit casting is only redundant
700a92d0: 9904         	ldr	r1, [sp, #0x10]
700a92d2: 6809         	ldr	r1, [r1]
;     } else if (xElapsedTime <
700a92d4: 4288         	cmp	r0, r1
700a92d6: d20b         	bhs	0x700a92f0 <xTaskCheckForTimeOut+0x80> @ imm = #0x16
700a92d8: e7ff         	b	0x700a92da <xTaskCheckForTimeOut+0x6a> @ imm = #-0x2
;       *pxTicksToWait -= xElapsedTime;
700a92da: 9a01         	ldr	r2, [sp, #0x4]
700a92dc: 9904         	ldr	r1, [sp, #0x10]
700a92de: 6808         	ldr	r0, [r1]
700a92e0: 1a80         	subs	r0, r0, r2
700a92e2: 6008         	str	r0, [r1]
;       vTaskInternalSetTimeOutState(pxTimeOut);
700a92e4: 9805         	ldr	r0, [sp, #0x14]
700a92e6: f005 ffbb    	bl	0x700af260 <vTaskInternalSetTimeOutState> @ imm = #0x5f76
700a92ea: 2000         	movs	r0, #0x0
;       xReturn = pdFALSE;
700a92ec: 9003         	str	r0, [sp, #0xc]
;     } else {
700a92ee: e005         	b	0x700a92fc <xTaskCheckForTimeOut+0x8c> @ imm = #0xa
;       *pxTicksToWait = (TickType_t)0;
700a92f0: 9904         	ldr	r1, [sp, #0x10]
700a92f2: 2000         	movs	r0, #0x0
700a92f4: 6008         	str	r0, [r1]
700a92f6: 2001         	movs	r0, #0x1
;       xReturn = pdTRUE;
700a92f8: 9003         	str	r0, [sp, #0xc]
700a92fa: e7ff         	b	0x700a92fc <xTaskCheckForTimeOut+0x8c> @ imm = #-0x2
700a92fc: e7ff         	b	0x700a92fe <xTaskCheckForTimeOut+0x8e> @ imm = #-0x2
700a92fe: e7ff         	b	0x700a9300 <xTaskCheckForTimeOut+0x90> @ imm = #-0x2
;   taskEXIT_CRITICAL();
700a9300: f004 faf6    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x45ec
;   return xReturn;
700a9304: 9803         	ldr	r0, [sp, #0xc]
700a9306: b006         	add	sp, #0x18
700a9308: bd80         	pop	{r7, pc}
700a930a: 0000         	movs	r0, r0
700a930c: 0000         	movs	r0, r0
700a930e: 0000         	movs	r0, r0

700a9310 <CSL_bcdmaChanOpSetChanEnable>:
; {
700a9310: b580         	push	{r7, lr}
700a9312: b086         	sub	sp, #0x18
700a9314: 9005         	str	r0, [sp, #0x14]
700a9316: 9104         	str	r1, [sp, #0x10]
700a9318: 9203         	str	r2, [sp, #0xc]
700a931a: f88d 300b    	strb.w	r3, [sp, #0xb]
700a931e: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700a9320: 9001         	str	r0, [sp, #0x4]
;     switch( chanType )
700a9322: 9804         	ldr	r0, [sp, #0x10]
700a9324: 9000         	str	r0, [sp]
700a9326: b140         	cbz	r0, 0x700a933a <CSL_bcdmaChanOpSetChanEnable+0x2a> @ imm = #0x10
700a9328: e7ff         	b	0x700a932a <CSL_bcdmaChanOpSetChanEnable+0x1a> @ imm = #-0x2
700a932a: 9800         	ldr	r0, [sp]
700a932c: 2801         	cmp	r0, #0x1
700a932e: d014         	beq	0x700a935a <CSL_bcdmaChanOpSetChanEnable+0x4a> @ imm = #0x28
700a9330: e7ff         	b	0x700a9332 <CSL_bcdmaChanOpSetChanEnable+0x22> @ imm = #-0x2
700a9332: 9800         	ldr	r0, [sp]
700a9334: 2802         	cmp	r0, #0x2
700a9336: d020         	beq	0x700a937a <CSL_bcdmaChanOpSetChanEnable+0x6a> @ imm = #0x40
700a9338: e02f         	b	0x700a939a <CSL_bcdmaChanOpSetChanEnable+0x8a> @ imm = #0x5e
;             CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_BCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a933a: 9805         	ldr	r0, [sp, #0x14]
700a933c: 6880         	ldr	r0, [r0, #0x8]
700a933e: 9903         	ldr	r1, [sp, #0xc]
700a9340: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a9344: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a9348: f001 0101    	and	r1, r1, #0x1
700a934c: 2900         	cmp	r1, #0x0
700a934e: bf18         	it	ne
700a9350: f04f 4100    	movne.w	r1, #0x80000000
700a9354: f7f2 ff9c    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xd0c8
;             break;
700a9358: e023         	b	0x700a93a2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x46
;             CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_TXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a935a: 9805         	ldr	r0, [sp, #0x14]
700a935c: 6900         	ldr	r0, [r0, #0x10]
700a935e: 9903         	ldr	r1, [sp, #0xc]
700a9360: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a9364: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a9368: f001 0101    	and	r1, r1, #0x1
700a936c: 2900         	cmp	r1, #0x0
700a936e: bf18         	it	ne
700a9370: f04f 4100    	movne.w	r1, #0x80000000
700a9374: f7f2 ff8c    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xd0e8
;             break;
700a9378: e013         	b	0x700a93a2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x26
;             CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, CSL_FMK(BCDMA_RXCRT_CHAN_CTL_EN,(bEnable ? (uint32_t)1U : (uint32_t)0U)) );
700a937a: 9805         	ldr	r0, [sp, #0x14]
700a937c: 6980         	ldr	r0, [r0, #0x18]
700a937e: 9903         	ldr	r1, [sp, #0xc]
700a9380: eb00 3001    	add.w	r0, r0, r1, lsl #12
700a9384: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700a9388: f001 0101    	and	r1, r1, #0x1
700a938c: 2900         	cmp	r1, #0x0
700a938e: bf18         	it	ne
700a9390: f04f 4100    	movne.w	r1, #0x80000000
700a9394: f7f2 ff7c    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xd108
;             break;
700a9398: e003         	b	0x700a93a2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #0x6
700a939a: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700a939e: 9001         	str	r0, [sp, #0x4]
;             break;
700a93a0: e7ff         	b	0x700a93a2 <CSL_bcdmaChanOpSetChanEnable+0x92> @ imm = #-0x2
;     return retVal;
700a93a2: 9801         	ldr	r0, [sp, #0x4]
700a93a4: b006         	add	sp, #0x18
700a93a6: bd80         	pop	{r7, pc}
		...

700a93b0 <Sciclient_pmModuleGetClkStatus>:
; {
700a93b0: b580         	push	{r7, lr}
700a93b2: b096         	sub	sp, #0x58
700a93b4: 9015         	str	r0, [sp, #0x54]
700a93b6: 9114         	str	r1, [sp, #0x50]
700a93b8: 9213         	str	r2, [sp, #0x4c]
700a93ba: 9312         	str	r3, [sp, #0x48]
700a93bc: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a93be: 9011         	str	r0, [sp, #0x44]
;     request.device = (uint32_t) moduleId;
700a93c0: 9815         	ldr	r0, [sp, #0x54]
700a93c2: 900e         	str	r0, [sp, #0x38]
;     if (clockId >= 255U)
700a93c4: 9814         	ldr	r0, [sp, #0x50]
700a93c6: 28ff         	cmp	r0, #0xff
700a93c8: d307         	blo	0x700a93da <Sciclient_pmModuleGetClkStatus+0x2a> @ imm = #0xe
700a93ca: e7ff         	b	0x700a93cc <Sciclient_pmModuleGetClkStatus+0x1c> @ imm = #-0x2
;         request.clk32 = clockId;
700a93cc: 9814         	ldr	r0, [sp, #0x50]
700a93ce: f8cd 003d    	str.w	r0, [sp, #0x3d]
700a93d2: 20ff         	movs	r0, #0xff
;         request.clk   = (uint8_t) 255U;
700a93d4: f88d 003c    	strb.w	r0, [sp, #0x3c]
;     }
700a93d8: e003         	b	0x700a93e2 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #0x6
;         request.clk    = (uint8_t) clockId;
700a93da: 9814         	ldr	r0, [sp, #0x50]
700a93dc: f88d 003c    	strb.w	r0, [sp, #0x3c]
700a93e0: e7ff         	b	0x700a93e2 <Sciclient_pmModuleGetClkStatus+0x32> @ imm = #-0x2
700a93e2: 2000         	movs	r0, #0x0
;     struct tisci_msg_get_clock_resp response = {{0}};
700a93e4: f8ad 002c    	strh.w	r0, [sp, #0x2c]
700a93e8: 900a         	str	r0, [sp, #0x28]
700a93ea: 9009         	str	r0, [sp, #0x24]
700a93ec: f240 1101    	movw	r1, #0x101
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_CLOCK;
700a93f0: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a93f4: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a93f6: 9105         	str	r1, [sp, #0x14]
700a93f8: a90c         	add	r1, sp, #0x30
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a93fa: 9106         	str	r1, [sp, #0x18]
700a93fc: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a93fe: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a9400: 9912         	ldr	r1, [sp, #0x48]
700a9402: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9404: 9001         	str	r0, [sp, #0x4]
700a9406: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a9408: 9002         	str	r0, [sp, #0x8]
700a940a: 200a         	movs	r0, #0xa
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a940c: 9003         	str	r0, [sp, #0xc]
700a940e: a804         	add	r0, sp, #0x10
700a9410: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9412: f7f4 f8e5    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xbe36
700a9416: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a9418: 9811         	ldr	r0, [sp, #0x44]
700a941a: b930         	cbnz	r0, 0x700a942a <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #0xc
700a941c: e7ff         	b	0x700a941e <Sciclient_pmModuleGetClkStatus+0x6e> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a941e: 9801         	ldr	r0, [sp, #0x4]
700a9420: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9424: 2802         	cmp	r0, #0x2
700a9426: d004         	beq	0x700a9432 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #0x8
700a9428: e7ff         	b	0x700a942a <Sciclient_pmModuleGetClkStatus+0x7a> @ imm = #-0x2
700a942a: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a942e: 9011         	str	r0, [sp, #0x44]
;     }
700a9430: e7ff         	b	0x700a9432 <Sciclient_pmModuleGetClkStatus+0x82> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a9432: 9811         	ldr	r0, [sp, #0x44]
700a9434: b928         	cbnz	r0, 0x700a9442 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #0xa
700a9436: e7ff         	b	0x700a9438 <Sciclient_pmModuleGetClkStatus+0x88> @ imm = #-0x2
;         *state = (uint32_t) response.current_state;
700a9438: f89d 002d    	ldrb.w	r0, [sp, #0x2d]
700a943c: 9913         	ldr	r1, [sp, #0x4c]
700a943e: 6008         	str	r0, [r1]
;     }
700a9440: e7ff         	b	0x700a9442 <Sciclient_pmModuleGetClkStatus+0x92> @ imm = #-0x2
;     return retVal;
700a9442: 9811         	ldr	r0, [sp, #0x44]
700a9444: b016         	add	sp, #0x58
700a9446: bd80         	pop	{r7, pc}
		...

700a9450 <xQueueReceiveFromISR>:
; {
700a9450: b580         	push	{r7, lr}
700a9452: b088         	sub	sp, #0x20
700a9454: 9007         	str	r0, [sp, #0x1c]
700a9456: 9106         	str	r1, [sp, #0x18]
700a9458: 9205         	str	r2, [sp, #0x14]
;     Queue_t * const pxQueue = xQueue;
700a945a: 9807         	ldr	r0, [sp, #0x1c]
700a945c: 9002         	str	r0, [sp, #0x8]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a945e: f007 ea80    	blx	0x700b0960 <HwiP_disable> @ imm = #0x7500
700a9462: 9003         	str	r0, [sp, #0xc]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a9464: 9802         	ldr	r0, [sp, #0x8]
700a9466: 6b80         	ldr	r0, [r0, #0x38]
700a9468: 9001         	str	r0, [sp, #0x4]
;         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
700a946a: 9801         	ldr	r0, [sp, #0x4]
700a946c: b398         	cbz	r0, 0x700a94d6 <xQueueReceiveFromISR+0x86> @ imm = #0x66
700a946e: e7ff         	b	0x700a9470 <xQueueReceiveFromISR+0x20> @ imm = #-0x2
;             const int8_t cRxLock = pxQueue->cRxLock;
700a9470: 9802         	ldr	r0, [sp, #0x8]
700a9472: f890 0044    	ldrb.w	r0, [r0, #0x44]
700a9476: f88d 0003    	strb.w	r0, [sp, #0x3]
;             prvCopyDataFromQueue( pxQueue, pvBuffer );
700a947a: 9802         	ldr	r0, [sp, #0x8]
700a947c: 9906         	ldr	r1, [sp, #0x18]
700a947e: f004 fb77    	bl	0x700adb70 <prvCopyDataFromQueue> @ imm = #0x46ee
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
700a9482: 9801         	ldr	r0, [sp, #0x4]
700a9484: 3801         	subs	r0, #0x1
700a9486: 9902         	ldr	r1, [sp, #0x8]
700a9488: 6388         	str	r0, [r1, #0x38]
;             if( cRxLock == queueUNLOCKED )
700a948a: f99d 0003    	ldrsb.w	r0, [sp, #0x3]
700a948e: 3001         	adds	r0, #0x1
700a9490: b9b8         	cbnz	r0, 0x700a94c2 <xQueueReceiveFromISR+0x72> @ imm = #0x2e
700a9492: e7ff         	b	0x700a9494 <xQueueReceiveFromISR+0x44> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700a9494: 9802         	ldr	r0, [sp, #0x8]
700a9496: 6900         	ldr	r0, [r0, #0x10]
700a9498: b188         	cbz	r0, 0x700a94be <xQueueReceiveFromISR+0x6e> @ imm = #0x22
700a949a: e7ff         	b	0x700a949c <xQueueReceiveFromISR+0x4c> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700a949c: 9802         	ldr	r0, [sp, #0x8]
700a949e: 3010         	adds	r0, #0x10
700a94a0: f7fe fb2e    	bl	0x700a7b00 <xTaskRemoveFromEventList> @ imm = #-0x19a4
700a94a4: b148         	cbz	r0, 0x700a94ba <xQueueReceiveFromISR+0x6a> @ imm = #0x12
700a94a6: e7ff         	b	0x700a94a8 <xQueueReceiveFromISR+0x58> @ imm = #-0x2
;                         if( pxHigherPriorityTaskWoken != NULL )
700a94a8: 9805         	ldr	r0, [sp, #0x14]
700a94aa: b120         	cbz	r0, 0x700a94b6 <xQueueReceiveFromISR+0x66> @ imm = #0x8
700a94ac: e7ff         	b	0x700a94ae <xQueueReceiveFromISR+0x5e> @ imm = #-0x2
;                             *pxHigherPriorityTaskWoken = pdTRUE;
700a94ae: 9905         	ldr	r1, [sp, #0x14]
700a94b0: 2001         	movs	r0, #0x1
700a94b2: 6008         	str	r0, [r1]
;                         }
700a94b4: e000         	b	0x700a94b8 <xQueueReceiveFromISR+0x68> @ imm = #0x0
700a94b6: e7ff         	b	0x700a94b8 <xQueueReceiveFromISR+0x68> @ imm = #-0x2
;                     }
700a94b8: e000         	b	0x700a94bc <xQueueReceiveFromISR+0x6c> @ imm = #0x0
700a94ba: e7ff         	b	0x700a94bc <xQueueReceiveFromISR+0x6c> @ imm = #-0x2
;                 }
700a94bc: e000         	b	0x700a94c0 <xQueueReceiveFromISR+0x70> @ imm = #0x0
700a94be: e7ff         	b	0x700a94c0 <xQueueReceiveFromISR+0x70> @ imm = #-0x2
;             }
700a94c0: e006         	b	0x700a94d0 <xQueueReceiveFromISR+0x80> @ imm = #0xc
;                 pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
700a94c2: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700a94c6: 3001         	adds	r0, #0x1
700a94c8: 9902         	ldr	r1, [sp, #0x8]
700a94ca: f881 0044    	strb.w	r0, [r1, #0x44]
700a94ce: e7ff         	b	0x700a94d0 <xQueueReceiveFromISR+0x80> @ imm = #-0x2
700a94d0: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a94d2: 9004         	str	r0, [sp, #0x10]
;         }
700a94d4: e002         	b	0x700a94dc <xQueueReceiveFromISR+0x8c> @ imm = #0x4
700a94d6: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700a94d8: 9004         	str	r0, [sp, #0x10]
700a94da: e7ff         	b	0x700a94dc <xQueueReceiveFromISR+0x8c> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a94dc: 9803         	ldr	r0, [sp, #0xc]
700a94de: f007 ea60    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x74c0
;     return xReturn;
700a94e2: 9804         	ldr	r0, [sp, #0x10]
700a94e4: b008         	add	sp, #0x20
700a94e6: bd80         	pop	{r7, pc}
		...

700a94f0 <xTaskCreate>:
;     UBaseType_t uxPriority, TaskHandle_t *const pxCreatedTask) {
700a94f0: b570         	push	{r4, r5, r6, lr}
700a94f2: b08c         	sub	sp, #0x30
700a94f4: f8dd c044    	ldr.w	r12, [sp, #0x44]
700a94f8: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a94fc: 900b         	str	r0, [sp, #0x2c]
700a94fe: 910a         	str	r1, [sp, #0x28]
700a9500: 9209         	str	r2, [sp, #0x24]
700a9502: 9308         	str	r3, [sp, #0x20]
;         (((size_t)usStackDepth) *
700a9504: 9809         	ldr	r0, [sp, #0x24]
700a9506: 0080         	lsls	r0, r0, #0x2
;     pxStack = (StackType_t *)pvPortMalloc(
700a9508: f006 f84a    	bl	0x700af5a0 <pvPortMalloc> @ imm = #0x6094
700a950c: 9005         	str	r0, [sp, #0x14]
;     if (pxStack != NULL) {
700a950e: 9805         	ldr	r0, [sp, #0x14]
700a9510: b180         	cbz	r0, 0x700a9534 <xTaskCreate+0x44> @ imm = #0x20
700a9512: e7ff         	b	0x700a9514 <xTaskCreate+0x24> @ imm = #-0x2
700a9514: 2088         	movs	r0, #0x88
;       pxNewTCB = (TCB_t *)pvPortMalloc(
700a9516: f006 f843    	bl	0x700af5a0 <pvPortMalloc> @ imm = #0x6086
700a951a: 9007         	str	r0, [sp, #0x1c]
;       if (pxNewTCB != NULL) {
700a951c: 9807         	ldr	r0, [sp, #0x1c]
700a951e: b120         	cbz	r0, 0x700a952a <xTaskCreate+0x3a> @ imm = #0x8
700a9520: e7ff         	b	0x700a9522 <xTaskCreate+0x32> @ imm = #-0x2
;         pxNewTCB->pxStack = pxStack;
700a9522: 9805         	ldr	r0, [sp, #0x14]
700a9524: 9907         	ldr	r1, [sp, #0x1c]
700a9526: 6308         	str	r0, [r1, #0x30]
;       } else {
700a9528: e003         	b	0x700a9532 <xTaskCreate+0x42> @ imm = #0x6
;         vPortFree(pxStack);
700a952a: 9805         	ldr	r0, [sp, #0x14]
700a952c: f005 ff38    	bl	0x700af3a0 <vPortFree>  @ imm = #0x5e70
700a9530: e7ff         	b	0x700a9532 <xTaskCreate+0x42> @ imm = #-0x2
;     } else {
700a9532: e002         	b	0x700a953a <xTaskCreate+0x4a> @ imm = #0x4
700a9534: 2000         	movs	r0, #0x0
;       pxNewTCB = NULL;
700a9536: 9007         	str	r0, [sp, #0x1c]
700a9538: e7ff         	b	0x700a953a <xTaskCreate+0x4a> @ imm = #-0x2
;   if (pxNewTCB != NULL) {
700a953a: 9807         	ldr	r0, [sp, #0x1c]
700a953c: b1e8         	cbz	r0, 0x700a957a <xTaskCreate+0x8a> @ imm = #0x3a
700a953e: e7ff         	b	0x700a9540 <xTaskCreate+0x50> @ imm = #-0x2
;       pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
700a9540: 9807         	ldr	r0, [sp, #0x1c]
700a9542: 2600         	movs	r6, #0x0
700a9544: f880 6081    	strb.w	r6, [r0, #0x81]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a9548: 980b         	ldr	r0, [sp, #0x2c]
700a954a: 990a         	ldr	r1, [sp, #0x28]
700a954c: 9a09         	ldr	r2, [sp, #0x24]
;                          pvParameters, uxPriority, pxCreatedTask, pxNewTCB,
700a954e: 9b08         	ldr	r3, [sp, #0x20]
700a9550: f8dd c040    	ldr.w	r12, [sp, #0x40]
700a9554: 9c11         	ldr	r4, [sp, #0x44]
700a9556: 9d07         	ldr	r5, [sp, #0x1c]
;     prvInitialiseNewTask(pxTaskCode, pcName, (uint32_t)usStackDepth,
700a9558: 46ee         	mov	lr, sp
700a955a: f8ce 600c    	str.w	r6, [lr, #0xc]
700a955e: f8ce 5008    	str.w	r5, [lr, #0x8]
700a9562: f8ce 4004    	str.w	r4, [lr, #0x4]
700a9566: f8ce c000    	str.w	r12, [lr]
700a956a: f7fb fc19    	bl	0x700a4da0 <prvInitialiseNewTask> @ imm = #-0x47ce
;     prvAddNewTaskToReadyList(pxNewTCB);
700a956e: 9807         	ldr	r0, [sp, #0x1c]
700a9570: f7fb fdb6    	bl	0x700a50e0 <prvAddNewTaskToReadyList> @ imm = #-0x4494
700a9574: 2001         	movs	r0, #0x1
;     xReturn = pdPASS;
700a9576: 9006         	str	r0, [sp, #0x18]
;   } else {
700a9578: e003         	b	0x700a9582 <xTaskCreate+0x92> @ imm = #0x6
700a957a: f04f 30ff    	mov.w	r0, #0xffffffff
;     xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
700a957e: 9006         	str	r0, [sp, #0x18]
700a9580: e7ff         	b	0x700a9582 <xTaskCreate+0x92> @ imm = #-0x2
;   return xReturn;
700a9582: 9806         	ldr	r0, [sp, #0x18]
700a9584: b00c         	add	sp, #0x30
700a9586: bd70         	pop	{r4, r5, r6, pc}
		...

700a9590 <PMU_profileStart>:
; int32_t PMU_profileStart(const char *name) {
700a9590: b580         	push	{r7, lr}
700a9592: b088         	sub	sp, #0x20
700a9594: 9006         	str	r0, [sp, #0x18]
;   if (gProfileObject.logIndex >= PMU_MAX_LOG_ENTRIES) {
700a9596: f243 0080    	movw	r0, #0x3080
700a959a: f2c7 0008    	movt	r0, #0x7008
700a959e: 6800         	ldr	r0, [r0]
700a95a0: 2840         	cmp	r0, #0x40
700a95a2: d304         	blo	0x700a95ae <PMU_profileStart+0x1e> @ imm = #0x8
700a95a4: e7ff         	b	0x700a95a6 <PMU_profileStart+0x16> @ imm = #-0x2
700a95a6: f04f 30ff    	mov.w	r0, #0xffffffff
;     return SystemP_FAILURE; /* Log is full */
700a95aa: 9007         	str	r0, [sp, #0x1c]
700a95ac: e038         	b	0x700a9620 <PMU_profileStart+0x90> @ imm = #0x70
;   uint32_t i = gProfileObject.logIndex;
700a95ae: f243 0280    	movw	r2, #0x3080
700a95b2: f2c7 0208    	movt	r2, #0x7008
700a95b6: 6810         	ldr	r0, [r2]
700a95b8: 9005         	str	r0, [sp, #0x14]
;   uint32_t numEvents = gProfileObject.numEvents;
700a95ba: 6890         	ldr	r0, [r2, #0x8]
700a95bc: 9003         	str	r0, [sp, #0xc]
;   uint32_t bCCnt = gProfileObject.bCycleCounter;
700a95be: 6850         	ldr	r0, [r2, #0x4]
700a95c0: 9002         	str	r0, [sp, #0x8]
;   PMU_ProfilePoint *p = &gProfileObject.point[i];
700a95c2: 9805         	ldr	r0, [sp, #0x14]
700a95c4: 2134         	movs	r1, #0x34
700a95c6: fb00 2001    	mla	r0, r0, r1, r2
700a95ca: 300c         	adds	r0, #0xc
700a95cc: 9001         	str	r0, [sp, #0x4]
;   p->name = name;
700a95ce: 9806         	ldr	r0, [sp, #0x18]
700a95d0: 9901         	ldr	r1, [sp, #0x4]
700a95d2: 6308         	str	r0, [r1, #0x30]
;   PMU_resetCounters();
700a95d4: f006 fb44    	bl	0x700afc60 <PMU_resetCounters> @ imm = #0x6688
;   if (bCCnt == TRUE) {
700a95d8: 9802         	ldr	r0, [sp, #0x8]
700a95da: 2801         	cmp	r0, #0x1
700a95dc: d106         	bne	0x700a95ec <PMU_profileStart+0x5c> @ imm = #0xc
700a95de: e7ff         	b	0x700a95e0 <PMU_profileStart+0x50> @ imm = #-0x2
700a95e0: 201f         	movs	r0, #0x1f
;         CSL_armR5PmuReadCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM);
700a95e2: f7f8 ee14    	blx	0x700a220c <CSL_armR5PmuReadCntr> @ imm = #-0x73d8
;     p->cycleCount.value =
700a95e6: 9901         	ldr	r1, [sp, #0x4]
700a95e8: 62c8         	str	r0, [r1, #0x2c]
;   }
700a95ea: e7ff         	b	0x700a95ec <PMU_profileStart+0x5c> @ imm = #-0x2
700a95ec: 2000         	movs	r0, #0x0
;   for (j = 0; j < numEvents; j++) {
700a95ee: 9004         	str	r0, [sp, #0x10]
700a95f0: e7ff         	b	0x700a95f2 <PMU_profileStart+0x62> @ imm = #-0x2
700a95f2: 9804         	ldr	r0, [sp, #0x10]
700a95f4: 9903         	ldr	r1, [sp, #0xc]
700a95f6: 4288         	cmp	r0, r1
700a95f8: d20f         	bhs	0x700a961a <PMU_profileStart+0x8a> @ imm = #0x1e
700a95fa: e7ff         	b	0x700a95fc <PMU_profileStart+0x6c> @ imm = #-0x2
;     p->events[j].value = CSL_armR5PmuReadCntr(j);
700a95fc: 9804         	ldr	r0, [sp, #0x10]
700a95fe: f7f8 ee06    	blx	0x700a220c <CSL_armR5PmuReadCntr> @ imm = #-0x73f4
700a9602: 9901         	ldr	r1, [sp, #0x4]
700a9604: 9a04         	ldr	r2, [sp, #0x10]
700a9606: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a960a: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a960e: 6088         	str	r0, [r1, #0x8]
;   }
700a9610: e7ff         	b	0x700a9612 <PMU_profileStart+0x82> @ imm = #-0x2
;   for (j = 0; j < numEvents; j++) {
700a9612: 9804         	ldr	r0, [sp, #0x10]
700a9614: 3001         	adds	r0, #0x1
700a9616: 9004         	str	r0, [sp, #0x10]
700a9618: e7eb         	b	0x700a95f2 <PMU_profileStart+0x62> @ imm = #-0x2a
700a961a: 2000         	movs	r0, #0x0
;   return SystemP_SUCCESS;
700a961c: 9007         	str	r0, [sp, #0x1c]
700a961e: e7ff         	b	0x700a9620 <PMU_profileStart+0x90> @ imm = #-0x2
; }
700a9620: 9807         	ldr	r0, [sp, #0x1c]
700a9622: b008         	add	sp, #0x20
700a9624: bd80         	pop	{r7, pc}
		...
700a962e: 0000         	movs	r0, r0

700a9630 <Sciclient_init>:
; {
700a9630: b580         	push	{r7, lr}
700a9632: b086         	sub	sp, #0x18
700a9634: 9005         	str	r0, [sp, #0x14]
700a9636: 2100         	movs	r1, #0x0
;     int32_t   status = SystemP_SUCCESS;
700a9638: 9101         	str	r1, [sp, #0x4]
700a963a: 9104         	str	r1, [sp, #0x10]
;         = (CSL_sec_proxyRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRegs);
700a963c: f642 00c0    	movw	r0, #0x28c0
700a9640: f2c7 000b    	movt	r0, #0x700b
700a9644: 9002         	str	r0, [sp, #0x8]
700a9646: 6800         	ldr	r0, [r0]
700a9648: f7fc fae2    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a3c
700a964c: 9901         	ldr	r1, [sp, #0x4]
700a964e: 4602         	mov	r2, r0
700a9650: 9802         	ldr	r0, [sp, #0x8]
700a9652: 6002         	str	r2, [r0]
;         = (CSL_sec_proxy_scfgRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyScfgRegs);
700a9654: 6840         	ldr	r0, [r0, #0x4]
700a9656: f7fc fadb    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a4a
700a965a: 9901         	ldr	r1, [sp, #0x4]
700a965c: 4602         	mov	r2, r0
700a965e: 9802         	ldr	r0, [sp, #0x8]
700a9660: 6042         	str	r2, [r0, #0x4]
;         = (CSL_sec_proxy_rtRegs*)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.pSecProxyRtRegs);
700a9662: 6880         	ldr	r0, [r0, #0x8]
700a9664: f7fc fad4    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a58
700a9668: 9902         	ldr	r1, [sp, #0x8]
700a966a: 6088         	str	r0, [r1, #0x8]
;         = (uint64_t)AddrTranslateP_getLocalAddr( (uint64_t)gSciclientSecProxyCfg.proxyTargetAddr);
700a966c: 6908         	ldr	r0, [r1, #0x10]
700a966e: 6949         	ldr	r1, [r1, #0x14]
700a9670: f7fc face    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x3a64
700a9674: 9a02         	ldr	r2, [sp, #0x8]
700a9676: 4601         	mov	r1, r0
700a9678: 9801         	ldr	r0, [sp, #0x4]
700a967a: 6150         	str	r0, [r2, #0x14]
700a967c: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.currSeqId = 0;
700a967e: f642 1148    	movw	r1, #0x2948
700a9682: f2c7 010b    	movt	r1, #0x700b
700a9686: 9103         	str	r1, [sp, #0xc]
700a9688: 6008         	str	r0, [r1]
;     gSciclientHandle.coreId = coreId;
700a968a: 9805         	ldr	r0, [sp, #0x14]
700a968c: 6048         	str	r0, [r1, #0x4]
;     gSciclientHandle.devIdCore = Sciclient_getDevId(coreId);
700a968e: 9805         	ldr	r0, [sp, #0x14]
700a9690: f003 ff06    	bl	0x700ad4a0 <Sciclient_getDevId> @ imm = #0x3e0c
700a9694: 9a03         	ldr	r2, [sp, #0xc]
700a9696: 4601         	mov	r1, r0
700a9698: 9801         	ldr	r0, [sp, #0x4]
700a969a: 6091         	str	r1, [r2, #0x8]
;     gSciclientHandle.secureContextId = Sciclient_getContext(SCICLIENT_SECURE_CONTEXT, coreId);
700a969c: 9905         	ldr	r1, [sp, #0x14]
700a969e: f7ff fb17    	bl	0x700a8cd0 <Sciclient_getContext> @ imm = #-0x9d2
700a96a2: 9903         	ldr	r1, [sp, #0xc]
700a96a4: 60c8         	str	r0, [r1, #0xc]
;     gSciclientHandle.nonSecureContextId = Sciclient_getContext(SCICLIENT_NON_SECURE_CONTEXT, coreId);
700a96a6: 9905         	ldr	r1, [sp, #0x14]
700a96a8: 2001         	movs	r0, #0x1
700a96aa: f7ff fb11    	bl	0x700a8cd0 <Sciclient_getContext> @ imm = #-0x9de
700a96ae: 9a03         	ldr	r2, [sp, #0xc]
700a96b0: 4601         	mov	r1, r0
700a96b2: 9802         	ldr	r0, [sp, #0x8]
700a96b4: 6111         	str	r1, [r2, #0x10]
;     gSciclientHandle.maxMsgSizeBytes = CSL_secProxyGetMaxMsgSize(&gSciclientSecProxyCfg) -
700a96b6: f005 f913    	bl	0x700ae8e0 <CSL_secProxyGetMaxMsgSize> @ imm = #0x5226
700a96ba: 9903         	ldr	r1, [sp, #0xc]
700a96bc: 3804         	subs	r0, #0x4
700a96be: 6148         	str	r0, [r1, #0x14]
;     return status;
700a96c0: 9804         	ldr	r0, [sp, #0x10]
700a96c2: b006         	add	sp, #0x18
700a96c4: bd80         	pop	{r7, pc}
		...
700a96ce: 0000         	movs	r0, r0

700a96d0 <UART_subConfigTCRTLRModeEn>:
; {
700a96d0: b580         	push	{r7, lr}
700a96d2: b088         	sub	sp, #0x20
700a96d4: 9007         	str	r0, [sp, #0x1c]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a96d6: 9807         	ldr	r0, [sp, #0x1c]
700a96d8: 21bf         	movs	r1, #0xbf
700a96da: 9101         	str	r1, [sp, #0x4]
700a96dc: f003 f850    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x30a0
700a96e0: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700a96e2: 9807         	ldr	r0, [sp, #0x1c]
700a96e4: 3008         	adds	r0, #0x8
700a96e6: 2110         	movs	r1, #0x10
700a96e8: 9102         	str	r1, [sp, #0x8]
700a96ea: 2204         	movs	r2, #0x4
700a96ec: 9203         	str	r2, [sp, #0xc]
700a96ee: f005 fe27    	bl	0x700af340 <HW_RD_FIELD32_RAW> @ imm = #0x5c4e
700a96f2: 9902         	ldr	r1, [sp, #0x8]
700a96f4: 9a03         	ldr	r2, [sp, #0xc]
700a96f6: 9006         	str	r0, [sp, #0x18]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700a96f8: 9807         	ldr	r0, [sp, #0x1c]
700a96fa: 3008         	adds	r0, #0x8
700a96fc: 2301         	movs	r3, #0x1
700a96fe: 9300         	str	r3, [sp]
700a9700: f004 ffd6    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x4fac
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9704: 9807         	ldr	r0, [sp, #0x1c]
700a9706: 300c         	adds	r0, #0xc
700a9708: 9904         	ldr	r1, [sp, #0x10]
700a970a: f006 fa39    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x6472
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700a970e: 9807         	ldr	r0, [sp, #0x1c]
700a9710: 2180         	movs	r1, #0x80
700a9712: f003 f835    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x306a
700a9716: 9004         	str	r0, [sp, #0x10]
;     tcrTlrValue = HW_RD_REG32(baseAddr + UART_MCR) & UART_MCR_TCR_TLR_MASK;
700a9718: 9807         	ldr	r0, [sp, #0x1c]
700a971a: 3010         	adds	r0, #0x10
700a971c: f006 fa28    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x6450
700a9720: 9b00         	ldr	r3, [sp]
700a9722: f000 0040    	and	r0, r0, #0x40
700a9726: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR,
700a9728: 9807         	ldr	r0, [sp, #0x1c]
700a972a: 3010         	adds	r0, #0x10
700a972c: 2140         	movs	r1, #0x40
700a972e: 2206         	movs	r2, #0x6
700a9730: f004 ffbe    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x4f7c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9734: 9807         	ldr	r0, [sp, #0x1c]
700a9736: 300c         	adds	r0, #0xc
700a9738: 9904         	ldr	r1, [sp, #0x10]
700a973a: f006 fa21    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x6442
700a973e: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700a9740: 9807         	ldr	r0, [sp, #0x1c]
700a9742: f003 f81d    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x303a
700a9746: 9902         	ldr	r1, [sp, #0x8]
700a9748: 9a03         	ldr	r2, [sp, #0xc]
700a974a: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700a974c: 9807         	ldr	r0, [sp, #0x1c]
700a974e: 3008         	adds	r0, #0x8
700a9750: 9b06         	ldr	r3, [sp, #0x18]
700a9752: f004 ffad    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x4f5a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700a9756: 9807         	ldr	r0, [sp, #0x1c]
700a9758: 300c         	adds	r0, #0xc
700a975a: 9904         	ldr	r1, [sp, #0x10]
700a975c: f006 fa10    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x6420
;     return tcrTlrValue;
700a9760: 9805         	ldr	r0, [sp, #0x14]
700a9762: b008         	add	sp, #0x20
700a9764: bd80         	pop	{r7, pc}
		...
700a976e: 0000         	movs	r0, r0

700a9770 <UART_udmaIsrRx>:
; {
700a9770: b580         	push	{r7, lr}
700a9772: b08a         	sub	sp, #0x28
700a9774: 9009         	str	r0, [sp, #0x24]
700a9776: 9108         	str	r1, [sp, #0x20]
700a9778: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a977a: 9807         	ldr	r0, [sp, #0x1c]
700a977c: 2800         	cmp	r0, #0x0
700a977e: d040         	beq	0x700a9802 <UART_udmaIsrRx+0x92> @ imm = #0x80
700a9780: e7ff         	b	0x700a9782 <UART_udmaIsrRx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a9782: 9807         	ldr	r0, [sp, #0x1c]
700a9784: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a9786: 9800         	ldr	r0, [sp]
700a9788: 6840         	ldr	r0, [r0, #0x4]
700a978a: 6cc0         	ldr	r0, [r0, #0x4c]
700a978c: 9001         	str	r0, [sp, #0x4]
;         rxChHandle  = udmaChCfg->rxChHandle;
700a978e: 9801         	ldr	r0, [sp, #0x4]
700a9790: 6880         	ldr	r0, [r0, #0x8]
700a9792: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a9794: 9808         	ldr	r0, [sp, #0x20]
700a9796: 2801         	cmp	r0, #0x1
700a9798: d12e         	bne	0x700a97f8 <UART_udmaIsrRx+0x88> @ imm = #0x5c
700a979a: e7ff         	b	0x700a979c <UART_udmaIsrRx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->rxHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a979c: 9901         	ldr	r1, [sp, #0x4]
700a979e: 6988         	ldr	r0, [r1, #0x18]
700a97a0: 69c9         	ldr	r1, [r1, #0x1c]
700a97a2: 220a         	movs	r2, #0xa
700a97a4: f007 fb6c    	bl	0x700b0e80 <CacheP_inv> @ imm = #0x76d8
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a97a8: 9802         	ldr	r0, [sp, #0x8]
700a97aa: f001 fc29    	bl	0x700ab000 <Udma_chGetCqRingHandle> @ imm = #0x1852
700a97ae: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(rxChHandle), &pDesc);
700a97b0: f000 f8ce    	bl	0x700a9950 <Udma_ringDequeueRaw> @ imm = #0x19c
700a97b4: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a97b6: 9806         	ldr	r0, [sp, #0x18]
700a97b8: b988         	cbnz	r0, 0x700a97de <UART_udmaIsrRx+0x6e> @ imm = #0x22
700a97ba: e7ff         	b	0x700a97bc <UART_udmaIsrRx+0x4c> @ imm = #-0x2
700a97bc: 9804         	ldr	r0, [sp, #0x10]
700a97be: 9905         	ldr	r1, [sp, #0x14]
700a97c0: 4308         	orrs	r0, r1
700a97c2: b160         	cbz	r0, 0x700a97de <UART_udmaIsrRx+0x6e> @ imm = #0x18
700a97c4: e7ff         	b	0x700a97c6 <UART_udmaIsrRx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a97c6: 9804         	ldr	r0, [sp, #0x10]
700a97c8: 9003         	str	r0, [sp, #0xc]
;                 hUart->readTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a97ca: 9803         	ldr	r0, [sp, #0xc]
700a97cc: 6800         	ldr	r0, [r0]
700a97ce: f36f 509f    	bfc	r0, #22, #10
700a97d2: 9900         	ldr	r1, [sp]
700a97d4: 62c8         	str	r0, [r1, #0x2c]
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a97d6: 9900         	ldr	r1, [sp]
700a97d8: 2000         	movs	r0, #0x0
700a97da: 6348         	str	r0, [r1, #0x34]
;             }
700a97dc: e003         	b	0x700a97e6 <UART_udmaIsrRx+0x76> @ imm = #0x6
;                 hUart->readTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a97de: 9900         	ldr	r1, [sp]
700a97e0: 200a         	movs	r0, #0xa
700a97e2: 6348         	str	r0, [r1, #0x34]
700a97e4: e7ff         	b	0x700a97e6 <UART_udmaIsrRx+0x76> @ imm = #-0x2
;             hUart->hUartInit->readCompleteCallbackFxn(hUart);
700a97e6: 9800         	ldr	r0, [sp]
700a97e8: 6841         	ldr	r1, [r0, #0x4]
700a97ea: 6dc9         	ldr	r1, [r1, #0x5c]
700a97ec: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->readTrans);
700a97ee: 9800         	ldr	r0, [sp]
700a97f0: 3028         	adds	r0, #0x28
700a97f2: f005 fe45    	bl	0x700af480 <UART_lld_Transaction_deInit> @ imm = #0x5c8a
;         }
700a97f6: e003         	b	0x700a9800 <UART_udmaIsrRx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a97f8: 9900         	ldr	r1, [sp]
700a97fa: 200a         	movs	r0, #0xa
700a97fc: 6488         	str	r0, [r1, #0x48]
700a97fe: e7ff         	b	0x700a9800 <UART_udmaIsrRx+0x90> @ imm = #-0x2
;     }
700a9800: e7ff         	b	0x700a9802 <UART_udmaIsrRx+0x92> @ imm = #-0x2
;     return;
700a9802: b00a         	add	sp, #0x28
700a9804: bd80         	pop	{r7, pc}
		...
700a980e: 0000         	movs	r0, r0

700a9810 <UART_udmaIsrTx>:
; {
700a9810: b580         	push	{r7, lr}
700a9812: b08a         	sub	sp, #0x28
700a9814: 9009         	str	r0, [sp, #0x24]
700a9816: 9108         	str	r1, [sp, #0x20]
700a9818: 9207         	str	r2, [sp, #0x1c]
;     if(NULL != args)
700a981a: 9807         	ldr	r0, [sp, #0x1c]
700a981c: 2800         	cmp	r0, #0x0
700a981e: d040         	beq	0x700a98a2 <UART_udmaIsrTx+0x92> @ imm = #0x80
700a9820: e7ff         	b	0x700a9822 <UART_udmaIsrTx+0x12> @ imm = #-0x2
;         hUart = (UARTLLD_Handle)args;
700a9822: 9807         	ldr	r0, [sp, #0x1c]
700a9824: 9000         	str	r0, [sp]
;         udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a9826: 9800         	ldr	r0, [sp]
700a9828: 6840         	ldr	r0, [r0, #0x4]
700a982a: 6cc0         	ldr	r0, [r0, #0x4c]
700a982c: 9001         	str	r0, [sp, #0x4]
;         txChHandle  = udmaChCfg->txChHandle;
700a982e: 9801         	ldr	r0, [sp, #0x4]
700a9830: 6840         	ldr	r0, [r0, #0x4]
700a9832: 9002         	str	r0, [sp, #0x8]
;         if (eventType == UDMA_EVENT_TYPE_DMA_COMPLETION)
700a9834: 9808         	ldr	r0, [sp, #0x20]
700a9836: 2801         	cmp	r0, #0x1
700a9838: d12e         	bne	0x700a9898 <UART_udmaIsrTx+0x88> @ imm = #0x5c
700a983a: e7ff         	b	0x700a983c <UART_udmaIsrTx+0x2c> @ imm = #-0x2
;             CacheP_inv(udmaChCfg->txHpdMem, udmaChCfg->hpdMemSize, CacheP_TYPE_ALLD);
700a983c: 9901         	ldr	r1, [sp, #0x4]
700a983e: 6948         	ldr	r0, [r1, #0x14]
700a9840: 69c9         	ldr	r1, [r1, #0x1c]
700a9842: 220a         	movs	r2, #0xa
700a9844: f007 fb1c    	bl	0x700b0e80 <CacheP_inv> @ imm = #0x7638
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a9848: 9802         	ldr	r0, [sp, #0x8]
700a984a: f001 fbd9    	bl	0x700ab000 <Udma_chGetCqRingHandle> @ imm = #0x17b2
700a984e: a904         	add	r1, sp, #0x10
;             retVal = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(txChHandle), &pDesc);
700a9850: f000 f87e    	bl	0x700a9950 <Udma_ringDequeueRaw> @ imm = #0xfc
700a9854: 9006         	str	r0, [sp, #0x18]
;             if ((retVal == UDMA_SOK) && (pDesc != 0UL))
700a9856: 9806         	ldr	r0, [sp, #0x18]
700a9858: b988         	cbnz	r0, 0x700a987e <UART_udmaIsrTx+0x6e> @ imm = #0x22
700a985a: e7ff         	b	0x700a985c <UART_udmaIsrTx+0x4c> @ imm = #-0x2
700a985c: 9804         	ldr	r0, [sp, #0x10]
700a985e: 9905         	ldr	r1, [sp, #0x14]
700a9860: 4308         	orrs	r0, r1
700a9862: b160         	cbz	r0, 0x700a987e <UART_udmaIsrTx+0x6e> @ imm = #0x18
700a9864: e7ff         	b	0x700a9866 <UART_udmaIsrTx+0x56> @ imm = #-0x2
;                 pHpd = (CSL_UdmapCppi5HMPD *)(uintptr_t)pDesc;
700a9866: 9804         	ldr	r0, [sp, #0x10]
700a9868: 9003         	str	r0, [sp, #0xc]
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_SUCCESS;
700a986a: 9900         	ldr	r1, [sp]
700a986c: 2000         	movs	r0, #0x0
700a986e: 6488         	str	r0, [r1, #0x48]
;                 hUart->writeTrans.count = (pHpd->descInfo & CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_MASK) >> CSL_UDMAP_CPPI5_PD_DESCINFO_PKTLEN_SHIFT;
700a9870: 9803         	ldr	r0, [sp, #0xc]
700a9872: 6800         	ldr	r0, [r0]
700a9874: f36f 509f    	bfc	r0, #22, #10
700a9878: 9900         	ldr	r1, [sp]
700a987a: 6408         	str	r0, [r1, #0x40]
;             }
700a987c: e003         	b	0x700a9886 <UART_udmaIsrTx+0x76> @ imm = #0x6
;                 hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a987e: 9900         	ldr	r1, [sp]
700a9880: 200a         	movs	r0, #0xa
700a9882: 6488         	str	r0, [r1, #0x48]
700a9884: e7ff         	b	0x700a9886 <UART_udmaIsrTx+0x76> @ imm = #-0x2
;             hUart->hUartInit->writeCompleteCallbackFxn(hUart);
700a9886: 9800         	ldr	r0, [sp]
700a9888: 6841         	ldr	r1, [r0, #0x4]
700a988a: 6e09         	ldr	r1, [r1, #0x60]
700a988c: 4788         	blx	r1
;             UART_lld_Transaction_deInit(&hUart->writeTrans);
700a988e: 9800         	ldr	r0, [sp]
700a9890: 303c         	adds	r0, #0x3c
700a9892: f005 fdf5    	bl	0x700af480 <UART_lld_Transaction_deInit> @ imm = #0x5bea
;         }
700a9896: e003         	b	0x700a98a0 <UART_udmaIsrTx+0x90> @ imm = #0x6
;             hUart->writeTrans.status = UART_TRANSFER_STATUS_ERROR_OTH;
700a9898: 9900         	ldr	r1, [sp]
700a989a: 200a         	movs	r0, #0xa
700a989c: 6488         	str	r0, [r1, #0x48]
700a989e: e7ff         	b	0x700a98a0 <UART_udmaIsrTx+0x90> @ imm = #-0x2
;     }
700a98a0: e7ff         	b	0x700a98a2 <UART_udmaIsrTx+0x92> @ imm = #-0x2
;     return;
700a98a2: b00a         	add	sp, #0x28
700a98a4: bd80         	pop	{r7, pc}
		...
700a98ae: 0000         	movs	r0, r0

700a98b0 <UdmaFlowPrms_init>:
; {
700a98b0: b084         	sub	sp, #0x10
700a98b2: 9003         	str	r0, [sp, #0xc]
700a98b4: 9102         	str	r1, [sp, #0x8]
;     if(NULL_PTR != flowPrms)
700a98b6: 9803         	ldr	r0, [sp, #0xc]
700a98b8: 2800         	cmp	r0, #0x0
700a98ba: d042         	beq	0x700a9942 <UdmaFlowPrms_init+0x92> @ imm = #0x84
700a98bc: e7ff         	b	0x700a98be <UdmaFlowPrms_init+0xe> @ imm = #-0x2
;         flowPrms->rxChHandle    = (Udma_ChHandle) NULL_PTR;
700a98be: 9803         	ldr	r0, [sp, #0xc]
700a98c0: 2100         	movs	r1, #0x0
700a98c2: 9100         	str	r1, [sp]
700a98c4: 6001         	str	r1, [r0]
;         flowPrms->einfoPresent  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_EINFO_NOT_PRESENT;
700a98c6: 9803         	ldr	r0, [sp, #0xc]
700a98c8: 7101         	strb	r1, [r0, #0x4]
;         flowPrms->psInfoPresent = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PSINFO_NOT_PRESENT;
700a98ca: 9803         	ldr	r0, [sp, #0xc]
700a98cc: 7141         	strb	r1, [r0, #0x5]
;         flowPrms->errorHandling = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_ERR_RETRY;
700a98ce: 9a03         	ldr	r2, [sp, #0xc]
700a98d0: 2001         	movs	r0, #0x1
700a98d2: 7190         	strb	r0, [r2, #0x6]
;         flowPrms->descType      = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DESC_HOST;
700a98d4: 9803         	ldr	r0, [sp, #0xc]
700a98d6: 71c1         	strb	r1, [r0, #0x7]
;         flowPrms->psLocation    = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_PS_END_PD;
700a98d8: 9803         	ldr	r0, [sp, #0xc]
700a98da: 7201         	strb	r1, [r0, #0x8]
;         flowPrms->sopOffset     = 0U;
700a98dc: 9803         	ldr	r0, [sp, #0xc]
700a98de: 8141         	strh	r1, [r0, #0xa]
;         flowPrms->defaultRxCQ   = UDMA_RING_INVALID;
700a98e0: 9a03         	ldr	r2, [sp, #0xc]
700a98e2: f64f 70ff    	movw	r0, #0xffff
700a98e6: 9001         	str	r0, [sp, #0x4]
700a98e8: 8190         	strh	r0, [r2, #0xc]
;         flowPrms->srcTagLo      = 0U;
700a98ea: 9a03         	ldr	r2, [sp, #0xc]
700a98ec: 73d1         	strb	r1, [r2, #0xf]
;         flowPrms->srcTagLoSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_SRC_TAG;
700a98ee: 9b03         	ldr	r3, [sp, #0xc]
700a98f0: 2204         	movs	r2, #0x4
700a98f2: 745a         	strb	r2, [r3, #0x11]
;         flowPrms->srcTagHi      = 0U;
700a98f4: 9b03         	ldr	r3, [sp, #0xc]
700a98f6: 7399         	strb	r1, [r3, #0xe]
;         flowPrms->srcTagHiSel   = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_SRC_SELECT_FLOW_ID;
700a98f8: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700a98fc: 2302         	movs	r3, #0x2
700a98fe: f88c 3010    	strb.w	r3, [r12, #0x10]
;         flowPrms->destTagLo     = 0U;
700a9902: 9b03         	ldr	r3, [sp, #0xc]
700a9904: 74d9         	strb	r1, [r3, #0x13]
;         flowPrms->destTagLoSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_LO;
700a9906: 9b03         	ldr	r3, [sp, #0xc]
700a9908: 755a         	strb	r2, [r3, #0x15]
;         flowPrms->destTagHi     = 0U;
700a990a: 9a03         	ldr	r2, [sp, #0xc]
700a990c: 7491         	strb	r1, [r2, #0x12]
;         flowPrms->destTagHiSel  = TISCI_MSG_VALUE_RM_UDMAP_RX_FLOW_DEST_SELECT_DEST_TAG_HI;
700a990e: 9b03         	ldr	r3, [sp, #0xc]
700a9910: 2205         	movs	r2, #0x5
700a9912: 751a         	strb	r2, [r3, #0x14]
;         flowPrms->sizeThreshEn  = 0U;
700a9914: 9a03         	ldr	r2, [sp, #0xc]
700a9916: 7591         	strb	r1, [r2, #0x16]
;         flowPrms->fdq0Sz0Qnum   = UDMA_RING_INVALID;
700a9918: 9a03         	ldr	r2, [sp, #0xc]
700a991a: 8310         	strh	r0, [r2, #0x18]
;         flowPrms->fdq1Qnum      = UDMA_RING_INVALID;
700a991c: 9a03         	ldr	r2, [sp, #0xc]
700a991e: 8350         	strh	r0, [r2, #0x1a]
;         flowPrms->fdq2Qnum      = UDMA_RING_INVALID;
700a9920: 9a03         	ldr	r2, [sp, #0xc]
700a9922: 8390         	strh	r0, [r2, #0x1c]
;         flowPrms->fdq3Qnum      = UDMA_RING_INVALID;
700a9924: 9a03         	ldr	r2, [sp, #0xc]
700a9926: 83d0         	strh	r0, [r2, #0x1e]
;         flowPrms->sizeThresh0   = 0U;
700a9928: 9a03         	ldr	r2, [sp, #0xc]
700a992a: 8411         	strh	r1, [r2, #0x20]
;         flowPrms->sizeThresh1   = 0U;
700a992c: 9a03         	ldr	r2, [sp, #0xc]
700a992e: 8451         	strh	r1, [r2, #0x22]
;         flowPrms->sizeThresh2   = 0U;
700a9930: 9a03         	ldr	r2, [sp, #0xc]
700a9932: 8491         	strh	r1, [r2, #0x24]
;         flowPrms->fdq0Sz1Qnum   = UDMA_RING_INVALID;
700a9934: 9903         	ldr	r1, [sp, #0xc]
700a9936: 84c8         	strh	r0, [r1, #0x26]
;         flowPrms->fdq0Sz2Qnum   = UDMA_RING_INVALID;
700a9938: 9903         	ldr	r1, [sp, #0xc]
700a993a: 8508         	strh	r0, [r1, #0x28]
;         flowPrms->fdq0Sz3Qnum   = UDMA_RING_INVALID;
700a993c: 9903         	ldr	r1, [sp, #0xc]
700a993e: 8548         	strh	r0, [r1, #0x2a]
;     }
700a9940: e7ff         	b	0x700a9942 <UdmaFlowPrms_init+0x92> @ imm = #-0x2
;     return;
700a9942: b004         	add	sp, #0x10
700a9944: 4770         	bx	lr
		...
700a994e: 0000         	movs	r0, r0

700a9950 <Udma_ringDequeueRaw>:
; {
700a9950: b580         	push	{r7, lr}
700a9952: b086         	sub	sp, #0x18
700a9954: 9005         	str	r0, [sp, #0x14]
700a9956: 9104         	str	r1, [sp, #0x10]
700a9958: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700a995a: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700a995c: 9805         	ldr	r0, [sp, #0x14]
700a995e: 9000         	str	r0, [sp]
;     if((NULL_PTR == ringHandleInt) ||
700a9960: 9800         	ldr	r0, [sp]
700a9962: b180         	cbz	r0, 0x700a9986 <Udma_ringDequeueRaw+0x36> @ imm = #0x20
700a9964: e7ff         	b	0x700a9966 <Udma_ringDequeueRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700a9966: 9800         	ldr	r0, [sp]
700a9968: 6d80         	ldr	r0, [r0, #0x58]
700a996a: f64a 31cd    	movw	r1, #0xabcd
700a996e: f6ca 31dc    	movt	r1, #0xabdc
700a9972: 4288         	cmp	r0, r1
700a9974: d107         	bne	0x700a9986 <Udma_ringDequeueRaw+0x36> @ imm = #0xe
700a9976: e7ff         	b	0x700a9978 <Udma_ringDequeueRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700a9978: 9800         	ldr	r0, [sp]
700a997a: 8880         	ldrh	r0, [r0, #0x4]
700a997c: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700a9980: 4288         	cmp	r0, r1
700a9982: d104         	bne	0x700a998e <Udma_ringDequeueRaw+0x3e> @ imm = #0x8
700a9984: e7ff         	b	0x700a9986 <Udma_ringDequeueRaw+0x36> @ imm = #-0x2
700a9986: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700a998a: 9003         	str	r0, [sp, #0xc]
;     }
700a998c: e7ff         	b	0x700a998e <Udma_ringDequeueRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a998e: 9803         	ldr	r0, [sp, #0xc]
700a9990: b9a8         	cbnz	r0, 0x700a99be <Udma_ringDequeueRaw+0x6e> @ imm = #0x2a
700a9992: e7ff         	b	0x700a9994 <Udma_ringDequeueRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700a9994: 9800         	ldr	r0, [sp]
700a9996: 6800         	ldr	r0, [r0]
700a9998: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) ||
700a999a: 9801         	ldr	r0, [sp, #0x4]
700a999c: b150         	cbz	r0, 0x700a99b4 <Udma_ringDequeueRaw+0x64> @ imm = #0x14
700a999e: e7ff         	b	0x700a99a0 <Udma_ringDequeueRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700a99a0: 9801         	ldr	r0, [sp, #0x4]
700a99a2: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700a99a6: f64a 31cd    	movw	r1, #0xabcd
700a99aa: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700a99ae: 4288         	cmp	r0, r1
700a99b0: d004         	beq	0x700a99bc <Udma_ringDequeueRaw+0x6c> @ imm = #0x8
700a99b2: e7ff         	b	0x700a99b4 <Udma_ringDequeueRaw+0x64> @ imm = #-0x2
700a99b4: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700a99b8: 9003         	str	r0, [sp, #0xc]
;         }
700a99ba: e7ff         	b	0x700a99bc <Udma_ringDequeueRaw+0x6c> @ imm = #-0x2
;     }
700a99bc: e7ff         	b	0x700a99be <Udma_ringDequeueRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700a99be: 9803         	ldr	r0, [sp, #0xc]
700a99c0: b970         	cbnz	r0, 0x700a99e0 <Udma_ringDequeueRaw+0x90> @ imm = #0x1c
700a99c2: e7ff         	b	0x700a99c4 <Udma_ringDequeueRaw+0x74> @ imm = #-0x2
;         cookie = HwiP_disable();
700a99c4: f006 efcc    	blx	0x700b0960 <HwiP_disable> @ imm = #0x6f98
700a99c8: 9002         	str	r0, [sp, #0x8]
;         retVal = drvHandle->ringDequeueRaw(drvHandle, ringHandleInt, phyDescMem);
700a99ca: 9801         	ldr	r0, [sp, #0x4]
700a99cc: f8d0 3590    	ldr.w	r3, [r0, #0x590]
700a99d0: 9900         	ldr	r1, [sp]
700a99d2: 9a04         	ldr	r2, [sp, #0x10]
700a99d4: 4798         	blx	r3
700a99d6: 9003         	str	r0, [sp, #0xc]
;         HwiP_restore(cookie);
700a99d8: 9802         	ldr	r0, [sp, #0x8]
700a99da: f006 efe2    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x6fc4
;     }
700a99de: e7ff         	b	0x700a99e0 <Udma_ringDequeueRaw+0x90> @ imm = #-0x2
;     return (retVal);
700a99e0: 9803         	ldr	r0, [sp, #0xc]
700a99e2: b006         	add	sp, #0x18
700a99e4: bd80         	pop	{r7, pc}
		...
700a99ee: 0000         	movs	r0, r0

700a99f0 <UART_lld_dmaDisableChannel>:
; {
700a99f0: b580         	push	{r7, lr}
700a99f2: b08a         	sub	sp, #0x28
700a99f4: 9009         	str	r0, [sp, #0x24]
700a99f6: 9108         	str	r1, [sp, #0x20]
700a99f8: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700a99fa: 9007         	str	r0, [sp, #0x1c]
700a99fc: 2001         	movs	r0, #0x1
;     uint32_t temp = TRUE;
700a99fe: 9006         	str	r0, [sp, #0x18]
;     udmaChCfg   = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700a9a00: 9809         	ldr	r0, [sp, #0x24]
700a9a02: 6840         	ldr	r0, [r0, #0x4]
700a9a04: 6cc0         	ldr	r0, [r0, #0x4c]
700a9a06: 9005         	str	r0, [sp, #0x14]
;     if (isChannelTx == TRUE)
700a9a08: 9808         	ldr	r0, [sp, #0x20]
700a9a0a: 2801         	cmp	r0, #0x1
700a9a0c: d104         	bne	0x700a9a18 <UART_lld_dmaDisableChannel+0x28> @ imm = #0x8
700a9a0e: e7ff         	b	0x700a9a10 <UART_lld_dmaDisableChannel+0x20> @ imm = #-0x2
;         chHandle = udmaChCfg->txChHandle;
700a9a10: 9805         	ldr	r0, [sp, #0x14]
700a9a12: 6840         	ldr	r0, [r0, #0x4]
700a9a14: 9004         	str	r0, [sp, #0x10]
;     }
700a9a16: e003         	b	0x700a9a20 <UART_lld_dmaDisableChannel+0x30> @ imm = #0x6
;         chHandle = udmaChCfg->rxChHandle;
700a9a18: 9805         	ldr	r0, [sp, #0x14]
700a9a1a: 6880         	ldr	r0, [r0, #0x8]
700a9a1c: 9004         	str	r0, [sp, #0x10]
700a9a1e: e7ff         	b	0x700a9a20 <UART_lld_dmaDisableChannel+0x30> @ imm = #-0x2
;     status = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
700a9a20: 9804         	ldr	r0, [sp, #0x10]
700a9a22: 2164         	movs	r1, #0x64
700a9a24: f7fe fb94    	bl	0x700a8150 <Udma_chDisable> @ imm = #-0x18d8
700a9a28: 9007         	str	r0, [sp, #0x1c]
;     DebugP_assert(UDMA_SOK == status);
700a9a2a: 9807         	ldr	r0, [sp, #0x1c]
700a9a2c: fab0 f080    	clz	r0, r0
700a9a30: 0940         	lsrs	r0, r0, #0x5
700a9a32: f641 71bb    	movw	r1, #0x1fbb
700a9a36: f2c7 010b    	movt	r1, #0x700b
700a9a3a: 466a         	mov	r2, sp
700a9a3c: 6011         	str	r1, [r2]
700a9a3e: f641 316c    	movw	r1, #0x1b6c
700a9a42: f2c7 010b    	movt	r1, #0x700b
700a9a46: f641 626b    	movw	r2, #0x1e6b
700a9a4a: f2c7 020b    	movt	r2, #0x700b
700a9a4e: f240 137b    	movw	r3, #0x17b
700a9a52: f001 f915    	bl	0x700aac80 <_DebugP_assert> @ imm = #0x122a
;     while(temp == TRUE)
700a9a56: e7ff         	b	0x700a9a58 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x2
700a9a58: 9806         	ldr	r0, [sp, #0x18]
700a9a5a: 2801         	cmp	r0, #0x1
700a9a5c: d10f         	bne	0x700a9a7e <UART_lld_dmaDisableChannel+0x8e> @ imm = #0x1e
700a9a5e: e7ff         	b	0x700a9a60 <UART_lld_dmaDisableChannel+0x70> @ imm = #-0x2
;                          Udma_chGetFqRingHandle(chHandle), &pDesc);
700a9a60: 9804         	ldr	r0, [sp, #0x10]
700a9a62: f001 fb0d    	bl	0x700ab080 <Udma_chGetFqRingHandle> @ imm = #0x161a
700a9a66: a902         	add	r1, sp, #0x8
;         tempRetVal = Udma_ringFlushRaw(
700a9a68: f000 fb9a    	bl	0x700aa1a0 <Udma_ringFlushRaw> @ imm = #0x734
700a9a6c: 9001         	str	r0, [sp, #0x4]
;         if(UDMA_ETIMEOUT == tempRetVal)
700a9a6e: 9801         	ldr	r0, [sp, #0x4]
700a9a70: 3004         	adds	r0, #0x4
700a9a72: b918         	cbnz	r0, 0x700a9a7c <UART_lld_dmaDisableChannel+0x8c> @ imm = #0x6
700a9a74: e7ff         	b	0x700a9a76 <UART_lld_dmaDisableChannel+0x86> @ imm = #-0x2
700a9a76: 2000         	movs	r0, #0x0
;             temp = FALSE;
700a9a78: 9006         	str	r0, [sp, #0x18]
;         }
700a9a7a: e7ff         	b	0x700a9a7c <UART_lld_dmaDisableChannel+0x8c> @ imm = #-0x2
;     while(temp == TRUE)
700a9a7c: e7ec         	b	0x700a9a58 <UART_lld_dmaDisableChannel+0x68> @ imm = #-0x28
;     return status;
700a9a7e: 9807         	ldr	r0, [sp, #0x1c]
700a9a80: b00a         	add	sp, #0x28
700a9a82: bd80         	pop	{r7, pc}
		...

700a9a90 <xQueueGiveFromISR>:
; {
700a9a90: b580         	push	{r7, lr}
700a9a92: b088         	sub	sp, #0x20
700a9a94: 9007         	str	r0, [sp, #0x1c]
700a9a96: 9106         	str	r1, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
700a9a98: 9807         	ldr	r0, [sp, #0x1c]
700a9a9a: 9003         	str	r0, [sp, #0xc]
;     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
700a9a9c: f006 ef60    	blx	0x700b0960 <HwiP_disable> @ imm = #0x6ec0
700a9aa0: 9004         	str	r0, [sp, #0x10]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
700a9aa2: 9803         	ldr	r0, [sp, #0xc]
700a9aa4: 6b80         	ldr	r0, [r0, #0x38]
700a9aa6: 9002         	str	r0, [sp, #0x8]
;         if( uxMessagesWaiting < pxQueue->uxLength )
700a9aa8: 9802         	ldr	r0, [sp, #0x8]
700a9aaa: 9903         	ldr	r1, [sp, #0xc]
700a9aac: 6bc9         	ldr	r1, [r1, #0x3c]
700a9aae: 4288         	cmp	r0, r1
700a9ab0: d22f         	bhs	0x700a9b12 <xQueueGiveFromISR+0x82> @ imm = #0x5e
700a9ab2: e7ff         	b	0x700a9ab4 <xQueueGiveFromISR+0x24> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
700a9ab4: 9803         	ldr	r0, [sp, #0xc]
700a9ab6: f890 0045    	ldrb.w	r0, [r0, #0x45]
700a9aba: f88d 0007    	strb.w	r0, [sp, #0x7]
;             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
700a9abe: 9802         	ldr	r0, [sp, #0x8]
700a9ac0: 3001         	adds	r0, #0x1
700a9ac2: 9903         	ldr	r1, [sp, #0xc]
700a9ac4: 6388         	str	r0, [r1, #0x38]
;             if( cTxLock == queueUNLOCKED )
700a9ac6: f99d 0007    	ldrsb.w	r0, [sp, #0x7]
700a9aca: 3001         	adds	r0, #0x1
700a9acc: b9b8         	cbnz	r0, 0x700a9afe <xQueueGiveFromISR+0x6e> @ imm = #0x2e
700a9ace: e7ff         	b	0x700a9ad0 <xQueueGiveFromISR+0x40> @ imm = #-0x2
;                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
700a9ad0: 9803         	ldr	r0, [sp, #0xc]
700a9ad2: 6a40         	ldr	r0, [r0, #0x24]
700a9ad4: b188         	cbz	r0, 0x700a9afa <xQueueGiveFromISR+0x6a> @ imm = #0x22
700a9ad6: e7ff         	b	0x700a9ad8 <xQueueGiveFromISR+0x48> @ imm = #-0x2
;                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
700a9ad8: 9803         	ldr	r0, [sp, #0xc]
700a9ada: 3024         	adds	r0, #0x24
700a9adc: f7fe f810    	bl	0x700a7b00 <xTaskRemoveFromEventList> @ imm = #-0x1fe0
700a9ae0: b148         	cbz	r0, 0x700a9af6 <xQueueGiveFromISR+0x66> @ imm = #0x12
700a9ae2: e7ff         	b	0x700a9ae4 <xQueueGiveFromISR+0x54> @ imm = #-0x2
;                                 if( pxHigherPriorityTaskWoken != NULL )
700a9ae4: 9806         	ldr	r0, [sp, #0x18]
700a9ae6: b120         	cbz	r0, 0x700a9af2 <xQueueGiveFromISR+0x62> @ imm = #0x8
700a9ae8: e7ff         	b	0x700a9aea <xQueueGiveFromISR+0x5a> @ imm = #-0x2
;                                     *pxHigherPriorityTaskWoken = pdTRUE;
700a9aea: 9906         	ldr	r1, [sp, #0x18]
700a9aec: 2001         	movs	r0, #0x1
700a9aee: 6008         	str	r0, [r1]
;                                 }
700a9af0: e000         	b	0x700a9af4 <xQueueGiveFromISR+0x64> @ imm = #0x0
700a9af2: e7ff         	b	0x700a9af4 <xQueueGiveFromISR+0x64> @ imm = #-0x2
;                             }
700a9af4: e000         	b	0x700a9af8 <xQueueGiveFromISR+0x68> @ imm = #0x0
700a9af6: e7ff         	b	0x700a9af8 <xQueueGiveFromISR+0x68> @ imm = #-0x2
;                         }
700a9af8: e000         	b	0x700a9afc <xQueueGiveFromISR+0x6c> @ imm = #0x0
700a9afa: e7ff         	b	0x700a9afc <xQueueGiveFromISR+0x6c> @ imm = #-0x2
;             }
700a9afc: e006         	b	0x700a9b0c <xQueueGiveFromISR+0x7c> @ imm = #0xc
;                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
700a9afe: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700a9b02: 3001         	adds	r0, #0x1
700a9b04: 9903         	ldr	r1, [sp, #0xc]
700a9b06: f881 0045    	strb.w	r0, [r1, #0x45]
700a9b0a: e7ff         	b	0x700a9b0c <xQueueGiveFromISR+0x7c> @ imm = #-0x2
700a9b0c: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700a9b0e: 9005         	str	r0, [sp, #0x14]
;         }
700a9b10: e002         	b	0x700a9b18 <xQueueGiveFromISR+0x88> @ imm = #0x4
700a9b12: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
700a9b14: 9005         	str	r0, [sp, #0x14]
700a9b16: e7ff         	b	0x700a9b18 <xQueueGiveFromISR+0x88> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
700a9b18: 9804         	ldr	r0, [sp, #0x10]
700a9b1a: f006 ef42    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x6e84
;     return xReturn;
700a9b1e: 9805         	ldr	r0, [sp, #0x14]
700a9b20: b008         	add	sp, #0x20
700a9b22: bd80         	pop	{r7, pc}
		...

700a9b30 <xTimerGenericCommand>:
;     {
700a9b30: b580         	push	{r7, lr}
700a9b32: b08a         	sub	sp, #0x28
700a9b34: f8dd c030    	ldr.w	r12, [sp, #0x30]
700a9b38: 9009         	str	r0, [sp, #0x24]
700a9b3a: 9108         	str	r1, [sp, #0x20]
700a9b3c: 9207         	str	r2, [sp, #0x1c]
700a9b3e: 9306         	str	r3, [sp, #0x18]
700a9b40: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700a9b42: 9005         	str	r0, [sp, #0x14]
;         if( xTimerQueue != NULL )
700a9b44: f642 2048    	movw	r0, #0x2a48
700a9b48: f2c7 000b    	movt	r0, #0x700b
700a9b4c: 6800         	ldr	r0, [r0]
700a9b4e: b3a8         	cbz	r0, 0x700a9bbc <xTimerGenericCommand+0x8c> @ imm = #0x6a
700a9b50: e7ff         	b	0x700a9b52 <xTimerGenericCommand+0x22> @ imm = #-0x2
;             xMessage.xMessageID = xCommandID;
700a9b52: 9808         	ldr	r0, [sp, #0x20]
700a9b54: 9001         	str	r0, [sp, #0x4]
;             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
700a9b56: 9807         	ldr	r0, [sp, #0x1c]
700a9b58: 9002         	str	r0, [sp, #0x8]
;             xMessage.u.xTimerParameters.pxTimer = xTimer;
700a9b5a: 9809         	ldr	r0, [sp, #0x24]
700a9b5c: 9003         	str	r0, [sp, #0xc]
;             if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
700a9b5e: 9808         	ldr	r0, [sp, #0x20]
700a9b60: 2805         	cmp	r0, #0x5
700a9b62: dc1e         	bgt	0x700a9ba2 <xTimerGenericCommand+0x72> @ imm = #0x3c
700a9b64: e7ff         	b	0x700a9b66 <xTimerGenericCommand+0x36> @ imm = #-0x2
;                 if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
700a9b66: f004 fc2b    	bl	0x700ae3c0 <xTaskGetSchedulerState> @ imm = #0x4856
700a9b6a: 2802         	cmp	r0, #0x2
700a9b6c: d10c         	bne	0x700a9b88 <xTimerGenericCommand+0x58> @ imm = #0x18
700a9b6e: e7ff         	b	0x700a9b70 <xTimerGenericCommand+0x40> @ imm = #-0x2
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
700a9b70: f642 2048    	movw	r0, #0x2a48
700a9b74: f2c7 000b    	movt	r0, #0x700b
700a9b78: 6800         	ldr	r0, [r0]
700a9b7a: 9a0c         	ldr	r2, [sp, #0x30]
700a9b7c: a901         	add	r1, sp, #0x4
700a9b7e: 2300         	movs	r3, #0x0
700a9b80: f7f9 fbb6    	bl	0x700a32f0 <xQueueGenericSend> @ imm = #-0x6894
700a9b84: 9005         	str	r0, [sp, #0x14]
;                 }
700a9b86: e00b         	b	0x700a9ba0 <xTimerGenericCommand+0x70> @ imm = #0x16
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
700a9b88: f642 2048    	movw	r0, #0x2a48
700a9b8c: f2c7 000b    	movt	r0, #0x700b
700a9b90: 6800         	ldr	r0, [r0]
700a9b92: a901         	add	r1, sp, #0x4
700a9b94: 2300         	movs	r3, #0x0
700a9b96: 461a         	mov	r2, r3
700a9b98: f7f9 fbaa    	bl	0x700a32f0 <xQueueGenericSend> @ imm = #-0x68ac
700a9b9c: 9005         	str	r0, [sp, #0x14]
700a9b9e: e7ff         	b	0x700a9ba0 <xTimerGenericCommand+0x70> @ imm = #-0x2
;             }
700a9ba0: e00b         	b	0x700a9bba <xTimerGenericCommand+0x8a> @ imm = #0x16
;                 xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
700a9ba2: f642 2048    	movw	r0, #0x2a48
700a9ba6: f2c7 000b    	movt	r0, #0x700b
700a9baa: 6800         	ldr	r0, [r0]
700a9bac: 9a06         	ldr	r2, [sp, #0x18]
700a9bae: a901         	add	r1, sp, #0x4
700a9bb0: 2300         	movs	r3, #0x0
700a9bb2: f7fe ff3d    	bl	0x700a8a30 <xQueueGenericSendFromISR> @ imm = #-0x1186
700a9bb6: 9005         	str	r0, [sp, #0x14]
700a9bb8: e7ff         	b	0x700a9bba <xTimerGenericCommand+0x8a> @ imm = #-0x2
;         }
700a9bba: e000         	b	0x700a9bbe <xTimerGenericCommand+0x8e> @ imm = #0x0
700a9bbc: e7ff         	b	0x700a9bbe <xTimerGenericCommand+0x8e> @ imm = #-0x2
;         return xReturn;
700a9bbe: 9805         	ldr	r0, [sp, #0x14]
700a9bc0: b00a         	add	sp, #0x28
700a9bc2: bd80         	pop	{r7, pc}
		...

700a9bd0 <SOC_moduleClockEnable>:
; {
700a9bd0: b580         	push	{r7, lr}
700a9bd2: b088         	sub	sp, #0x20
700a9bd4: 9007         	str	r0, [sp, #0x1c]
700a9bd6: 9106         	str	r1, [sp, #0x18]
700a9bd8: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700a9bda: 9005         	str	r0, [sp, #0x14]
700a9bdc: 2102         	movs	r1, #0x2
;     uint32_t moduleState = TISCI_MSG_VALUE_DEVICE_HW_STATE_TRANS;
700a9bde: 9104         	str	r1, [sp, #0x10]
;     uint32_t resetState = 0U;
700a9be0: 9003         	str	r0, [sp, #0xc]
;     uint32_t contextLossState = 0U;
700a9be2: 9002         	str	r0, [sp, #0x8]
;     status = Sciclient_pmGetModuleState(moduleId,
700a9be4: 9807         	ldr	r0, [sp, #0x1c]
700a9be6: 466a         	mov	r2, sp
700a9be8: f04f 31ff    	mov.w	r1, #0xffffffff
700a9bec: 6011         	str	r1, [r2]
700a9bee: a904         	add	r1, sp, #0x10
700a9bf0: aa03         	add	r2, sp, #0xc
700a9bf2: ab02         	add	r3, sp, #0x8
700a9bf4: f000 f96c    	bl	0x700a9ed0 <Sciclient_pmGetModuleState> @ imm = #0x2d8
700a9bf8: 9005         	str	r0, [sp, #0x14]
;     if(status == SystemP_SUCCESS)
700a9bfa: 9805         	ldr	r0, [sp, #0x14]
700a9bfc: bb70         	cbnz	r0, 0x700a9c5c <SOC_moduleClockEnable+0x8c> @ imm = #0x5c
700a9bfe: e7ff         	b	0x700a9c00 <SOC_moduleClockEnable+0x30> @ imm = #-0x2
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_OFF && (enable == 1))
700a9c00: 9804         	ldr	r0, [sp, #0x10]
700a9c02: b9c8         	cbnz	r0, 0x700a9c38 <SOC_moduleClockEnable+0x68> @ imm = #0x32
700a9c04: e7ff         	b	0x700a9c06 <SOC_moduleClockEnable+0x36> @ imm = #-0x2
700a9c06: 9806         	ldr	r0, [sp, #0x18]
700a9c08: 2801         	cmp	r0, #0x1
700a9c0a: d115         	bne	0x700a9c38 <SOC_moduleClockEnable+0x68> @ imm = #0x2a
700a9c0c: e7ff         	b	0x700a9c0e <SOC_moduleClockEnable+0x3e> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a9c0e: 9807         	ldr	r0, [sp, #0x1c]
700a9c10: 2102         	movs	r1, #0x2
700a9c12: f240 2202    	movw	r2, #0x202
700a9c16: f04f 33ff    	mov.w	r3, #0xffffffff
700a9c1a: f000 f9e9    	bl	0x700a9ff0 <Sciclient_pmSetModuleState> @ imm = #0x3d2
700a9c1e: 9005         	str	r0, [sp, #0x14]
;             if (status == SystemP_SUCCESS)
700a9c20: 9805         	ldr	r0, [sp, #0x14]
700a9c22: b940         	cbnz	r0, 0x700a9c36 <SOC_moduleClockEnable+0x66> @ imm = #0x10
700a9c24: e7ff         	b	0x700a9c26 <SOC_moduleClockEnable+0x56> @ imm = #-0x2
;                 status = Sciclient_pmSetModuleRst(moduleId,
700a9c26: 9807         	ldr	r0, [sp, #0x1c]
700a9c28: 2100         	movs	r1, #0x0
700a9c2a: f04f 32ff    	mov.w	r2, #0xffffffff
700a9c2e: f002 fc57    	bl	0x700ac4e0 <Sciclient_pmSetModuleRst> @ imm = #0x28ae
700a9c32: 9005         	str	r0, [sp, #0x14]
;             }
700a9c34: e7ff         	b	0x700a9c36 <SOC_moduleClockEnable+0x66> @ imm = #-0x2
;         }
700a9c36: e010         	b	0x700a9c5a <SOC_moduleClockEnable+0x8a> @ imm = #0x20
;         if(moduleState == TISCI_MSG_VALUE_DEVICE_HW_STATE_ON && (enable == 0))
700a9c38: 9804         	ldr	r0, [sp, #0x10]
700a9c3a: 2801         	cmp	r0, #0x1
700a9c3c: d10c         	bne	0x700a9c58 <SOC_moduleClockEnable+0x88> @ imm = #0x18
700a9c3e: e7ff         	b	0x700a9c40 <SOC_moduleClockEnable+0x70> @ imm = #-0x2
700a9c40: 9806         	ldr	r0, [sp, #0x18]
700a9c42: b948         	cbnz	r0, 0x700a9c58 <SOC_moduleClockEnable+0x88> @ imm = #0x12
700a9c44: e7ff         	b	0x700a9c46 <SOC_moduleClockEnable+0x76> @ imm = #-0x2
;             status = Sciclient_pmSetModuleState(moduleId,
700a9c46: 9807         	ldr	r0, [sp, #0x1c]
700a9c48: 2100         	movs	r1, #0x0
700a9c4a: 2202         	movs	r2, #0x2
700a9c4c: f04f 33ff    	mov.w	r3, #0xffffffff
700a9c50: f000 f9ce    	bl	0x700a9ff0 <Sciclient_pmSetModuleState> @ imm = #0x39c
700a9c54: 9005         	str	r0, [sp, #0x14]
;         }
700a9c56: e7ff         	b	0x700a9c58 <SOC_moduleClockEnable+0x88> @ imm = #-0x2
700a9c58: e7ff         	b	0x700a9c5a <SOC_moduleClockEnable+0x8a> @ imm = #-0x2
;     }
700a9c5a: e7ff         	b	0x700a9c5c <SOC_moduleClockEnable+0x8c> @ imm = #-0x2
;     return status;
700a9c5c: 9805         	ldr	r0, [sp, #0x14]
700a9c5e: b008         	add	sp, #0x20
700a9c60: bd80         	pop	{r7, pc}
		...
700a9c6e: 0000         	movs	r0, r0

700a9c70 <Sciclient_rmPsPop>:
; {
700a9c70: b084         	sub	sp, #0x10
700a9c72: 9003         	str	r0, [sp, #0xc]
700a9c74: 9102         	str	r1, [sp, #0x8]
700a9c76: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700a9c78: 9001         	str	r0, [sp, #0x4]
;     if ((gPstack.psp > (0u)) && (n != NULL) && (if_idx != NULL)) {
700a9c7a: f241 0058    	movw	r0, #0x1058
700a9c7e: f2c7 0008    	movt	r0, #0x7008
700a9c82: 8c80         	ldrh	r0, [r0, #0x24]
700a9c84: b3b0         	cbz	r0, 0x700a9cf4 <Sciclient_rmPsPop+0x84> @ imm = #0x6c
700a9c86: e7ff         	b	0x700a9c88 <Sciclient_rmPsPop+0x18> @ imm = #-0x2
700a9c88: 9803         	ldr	r0, [sp, #0xc]
700a9c8a: b398         	cbz	r0, 0x700a9cf4 <Sciclient_rmPsPop+0x84> @ imm = #0x66
700a9c8c: e7ff         	b	0x700a9c8e <Sciclient_rmPsPop+0x1e> @ imm = #-0x2
700a9c8e: 9802         	ldr	r0, [sp, #0x8]
700a9c90: b380         	cbz	r0, 0x700a9cf4 <Sciclient_rmPsPop+0x84> @ imm = #0x60
700a9c92: e7ff         	b	0x700a9c94 <Sciclient_rmPsPop+0x24> @ imm = #-0x2
;         gPstack.psp--;
700a9c94: f241 0158    	movw	r1, #0x1058
700a9c98: f2c7 0108    	movt	r1, #0x7008
700a9c9c: 9100         	str	r1, [sp]
700a9c9e: 8c88         	ldrh	r0, [r1, #0x24]
700a9ca0: 3801         	subs	r0, #0x1
700a9ca2: 8488         	strh	r0, [r1, #0x24]
;         *n = gPstack.ps[gPstack.psp].p_n;
700a9ca4: 8c88         	ldrh	r0, [r1, #0x24]
700a9ca6: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a9caa: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700a9cae: 9a03         	ldr	r2, [sp, #0xc]
700a9cb0: 6010         	str	r0, [r2]
;         *if_idx = gPstack.ps[gPstack.psp].if_idx;
700a9cb2: 8c88         	ldrh	r0, [r1, #0x24]
700a9cb4: eb00 0040    	add.w	r0, r0, r0, lsl #1
700a9cb8: eb01 0080    	add.w	r0, r1, r0, lsl #2
700a9cbc: 8880         	ldrh	r0, [r0, #0x4]
700a9cbe: 9a02         	ldr	r2, [sp, #0x8]
700a9cc0: 8010         	strh	r0, [r2]
;         gPstack.ps[gPstack.psp].p_n = NULL;
700a9cc2: 8c88         	ldrh	r0, [r1, #0x24]
700a9cc4: eb00 0240    	add.w	r2, r0, r0, lsl #1
700a9cc8: 2000         	movs	r0, #0x0
700a9cca: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = 0;
700a9cce: 8c8a         	ldrh	r2, [r1, #0x24]
700a9cd0: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9cd4: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a9cd8: 8090         	strh	r0, [r2, #0x4]
;         gPstack.ps[gPstack.psp].inp = 0;
700a9cda: 8c8a         	ldrh	r2, [r1, #0x24]
700a9cdc: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9ce0: eb01 0282    	add.w	r2, r1, r2, lsl #2
700a9ce4: 80d0         	strh	r0, [r2, #0x6]
;         gPstack.ps[gPstack.psp].outp = 0;
700a9ce6: 8c8a         	ldrh	r2, [r1, #0x24]
700a9ce8: eb02 0242    	add.w	r2, r2, r2, lsl #1
700a9cec: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a9cf0: 8108         	strh	r0, [r1, #0x8]
;     } else {
700a9cf2: e003         	b	0x700a9cfc <Sciclient_rmPsPop+0x8c> @ imm = #0x6
700a9cf4: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700a9cf8: 9001         	str	r0, [sp, #0x4]
700a9cfa: e7ff         	b	0x700a9cfc <Sciclient_rmPsPop+0x8c> @ imm = #-0x2
;     return r;
700a9cfc: 9801         	ldr	r0, [sp, #0x4]
700a9cfe: b004         	add	sp, #0x10
700a9d00: 4770         	bx	lr
		...
700a9d0e: 0000         	movs	r0, r0

700a9d10 <_DebugP_logZone>:
; {
700a9d10: b082         	sub	sp, #0x8
700a9d12: b580         	push	{r7, lr}
700a9d14: b086         	sub	sp, #0x18
700a9d16: 9309         	str	r3, [sp, #0x24]
700a9d18: 9208         	str	r2, [sp, #0x20]
700a9d1a: 9005         	str	r0, [sp, #0x14]
700a9d1c: 9104         	str	r1, [sp, #0x10]
;     if((HwiP_inISR()) == 0U )
700a9d1e: f006 fb3f    	bl	0x700b03a0 <HwiP_inISR> @ imm = #0x667e
700a9d22: bbc8         	cbnz	r0, 0x700a9d98 <_DebugP_logZone+0x88> @ imm = #0x72
700a9d24: e7ff         	b	0x700a9d26 <_DebugP_logZone+0x16> @ imm = #-0x2
;         if(gDebugLogIsInitDone == 0U)
700a9d26: f642 10cc    	movw	r0, #0x29cc
700a9d2a: f2c7 000b    	movt	r0, #0x700b
700a9d2e: 6800         	ldr	r0, [r0]
700a9d30: b9a0         	cbnz	r0, 0x700a9d5c <_DebugP_logZone+0x4c> @ imm = #0x28
700a9d32: e7ff         	b	0x700a9d34 <_DebugP_logZone+0x24> @ imm = #-0x2
;             status = SemaphoreP_constructMutex(&gDebugLogLockObj);
700a9d34: f644 6018    	movw	r0, #0x4e18
700a9d38: f2c7 0008    	movt	r0, #0x7008
700a9d3c: f001 fc78    	bl	0x700ab630 <SemaphoreP_constructMutex> @ imm = #0x18f0
700a9d40: 9003         	str	r0, [sp, #0xc]
;             DebugP_assertNoLog(status == SystemP_SUCCESS);
700a9d42: 9803         	ldr	r0, [sp, #0xc]
700a9d44: fab0 f080    	clz	r0, r0
700a9d48: 0940         	lsrs	r0, r0, #0x5
700a9d4a: f007 fac9    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x7592
;             gDebugLogIsInitDone = 1;
700a9d4e: f642 11cc    	movw	r1, #0x29cc
700a9d52: f2c7 010b    	movt	r1, #0x700b
700a9d56: 2001         	movs	r0, #0x1
700a9d58: 6008         	str	r0, [r1]
;         }
700a9d5a: e7ff         	b	0x700a9d5c <_DebugP_logZone+0x4c> @ imm = #-0x2
;         if( ( gDebugLogZone & logZone ) == logZone )
700a9d5c: f642 10d0    	movw	r0, #0x29d0
700a9d60: f2c7 000b    	movt	r0, #0x700b
700a9d64: 6800         	ldr	r0, [r0]
700a9d66: 9905         	ldr	r1, [sp, #0x14]
700a9d68: 4008         	ands	r0, r1
700a9d6a: 4288         	cmp	r0, r1
700a9d6c: d113         	bne	0x700a9d96 <_DebugP_logZone+0x86> @ imm = #0x26
700a9d6e: e7ff         	b	0x700a9d70 <_DebugP_logZone+0x60> @ imm = #-0x2
;             SemaphoreP_pend(&gDebugLogLockObj, SystemP_WAIT_FOREVER);
700a9d70: f644 6018    	movw	r0, #0x4e18
700a9d74: f2c7 0008    	movt	r0, #0x7008
700a9d78: 9001         	str	r0, [sp, #0x4]
700a9d7a: f04f 31ff    	mov.w	r1, #0xffffffff
700a9d7e: f000 fd27    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0xa4e
700a9d82: a808         	add	r0, sp, #0x20
;             va_start(va, format);
700a9d84: 9002         	str	r0, [sp, #0x8]
;             vprintf_(format, va);
700a9d86: 9804         	ldr	r0, [sp, #0x10]
700a9d88: 9902         	ldr	r1, [sp, #0x8]
700a9d8a: f005 f8d9    	bl	0x700aef40 <vprintf_>   @ imm = #0x51b2
;             SemaphoreP_post(&gDebugLogLockObj);
700a9d8e: 9801         	ldr	r0, [sp, #0x4]
700a9d90: f002 f8ae    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x215c
;         }
700a9d94: e7ff         	b	0x700a9d96 <_DebugP_logZone+0x86> @ imm = #-0x2
;     }
700a9d96: e7ff         	b	0x700a9d98 <_DebugP_logZone+0x88> @ imm = #-0x2
; }
700a9d98: b006         	add	sp, #0x18
700a9d9a: e8bd 4080    	pop.w	{r7, lr}
700a9d9e: b002         	add	sp, #0x8
700a9da0: 4770         	bx	lr
		...
700a9dae: 0000         	movs	r0, r0

700a9db0 <Udma_rmFreeMappedRing>:
; {
700a9db0: b580         	push	{r7, lr}
700a9db2: b08e         	sub	sp, #0x38
700a9db4: 900d         	str	r0, [sp, #0x34]
700a9db6: 910c         	str	r1, [sp, #0x30]
700a9db8: 920b         	str	r2, [sp, #0x2c]
700a9dba: 930a         	str	r3, [sp, #0x28]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700a9dbc: 980c         	ldr	r0, [sp, #0x30]
700a9dbe: f500 70ea    	add.w	r0, r0, #0x1d4
700a9dc2: 9005         	str	r0, [sp, #0x14]
;     retVal = Udma_getMappedChRingAttributes(drvHandle, mappedRingGrp, mappedChNum, &chAttr);
700a9dc4: 980c         	ldr	r0, [sp, #0x30]
700a9dc6: 990b         	ldr	r1, [sp, #0x2c]
700a9dc8: 9a0a         	ldr	r2, [sp, #0x28]
700a9dca: ab02         	add	r3, sp, #0x8
700a9dcc: f7fe f808    	bl	0x700a7de0 <Udma_getMappedChRingAttributes> @ imm = #-0x1ff0
700a9dd0: 9001         	str	r0, [sp, #0x4]
;     if(ringNum != chAttr.defaultRing)
700a9dd2: 980d         	ldr	r0, [sp, #0x34]
700a9dd4: 9902         	ldr	r1, [sp, #0x8]
700a9dd6: 4288         	cmp	r0, r1
700a9dd8: d02f         	beq	0x700a9e3a <Udma_rmFreeMappedRing+0x8a> @ imm = #0x5e
700a9dda: e7ff         	b	0x700a9ddc <Udma_rmFreeMappedRing+0x2c> @ imm = #-0x2
;         SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700a9ddc: 980c         	ldr	r0, [sp, #0x30]
700a9dde: f500 609f    	add.w	r0, r0, #0x4f8
700a9de2: f04f 31ff    	mov.w	r1, #0xffffffff
700a9de6: f000 fcf3    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x9e6
;         i = ringNum - rmInitPrms->startMappedRing[mappedRingGrp];
700a9dea: 980d         	ldr	r0, [sp, #0x34]
700a9dec: 9905         	ldr	r1, [sp, #0x14]
700a9dee: 9a0b         	ldr	r2, [sp, #0x2c]
700a9df0: eb01 0182    	add.w	r1, r1, r2, lsl #2
700a9df4: f8d1 1088    	ldr.w	r1, [r1, #0x88]
700a9df8: 1a40         	subs	r0, r0, r1
700a9dfa: 9009         	str	r0, [sp, #0x24]
;         offset = i >> 5U;
700a9dfc: 9809         	ldr	r0, [sp, #0x24]
700a9dfe: 0940         	lsrs	r0, r0, #0x5
700a9e00: 9008         	str	r0, [sp, #0x20]
;         bitPos = i - (offset << 5U);
700a9e02: 9809         	ldr	r0, [sp, #0x24]
700a9e04: 9908         	ldr	r1, [sp, #0x20]
700a9e06: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700a9e0a: 9007         	str	r0, [sp, #0x1c]
;         bitMask = (uint32_t) 1U << bitPos;
700a9e0c: 9907         	ldr	r1, [sp, #0x1c]
700a9e0e: 2001         	movs	r0, #0x1
700a9e10: 4088         	lsls	r0, r1
700a9e12: 9006         	str	r0, [sp, #0x18]
;         drvHandle->mappedRingFlag[mappedRingGrp][offset] |= bitMask;
700a9e14: 9a06         	ldr	r2, [sp, #0x18]
700a9e16: 980c         	ldr	r0, [sp, #0x30]
700a9e18: 990b         	ldr	r1, [sp, #0x2c]
700a9e1a: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700a9e1e: 9908         	ldr	r1, [sp, #0x20]
700a9e20: eb00 0181    	add.w	r1, r0, r1, lsl #2
700a9e24: f8d1 0344    	ldr.w	r0, [r1, #0x344]
700a9e28: 4310         	orrs	r0, r2
700a9e2a: f8c1 0344    	str.w	r0, [r1, #0x344]
;         SemaphoreP_post(&drvHandle->rmLockObj);
700a9e2e: 980c         	ldr	r0, [sp, #0x30]
700a9e30: f500 609f    	add.w	r0, r0, #0x4f8
700a9e34: f002 f85c    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x20b8
;     }
700a9e38: e7ff         	b	0x700a9e3a <Udma_rmFreeMappedRing+0x8a> @ imm = #-0x2
;     return;
700a9e3a: b00e         	add	sp, #0x38
700a9e3c: bd80         	pop	{r7, pc}
700a9e3e: 0000         	movs	r0, r0

700a9e40 <prvInitialiseTaskLists>:
; static void prvInitialiseTaskLists(void) {
700a9e40: b580         	push	{r7, lr}
700a9e42: b084         	sub	sp, #0x10
700a9e44: 2000         	movs	r0, #0x0
;   for (uxPriority = (UBaseType_t)0U;
700a9e46: 9003         	str	r0, [sp, #0xc]
700a9e48: e7ff         	b	0x700a9e4a <prvInitialiseTaskLists+0xa> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a9e4a: 9803         	ldr	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a9e4c: 281f         	cmp	r0, #0x1f
700a9e4e: d810         	bhi	0x700a9e72 <prvInitialiseTaskLists+0x32> @ imm = #0x20
700a9e50: e7ff         	b	0x700a9e52 <prvInitialiseTaskLists+0x12> @ imm = #-0x2
;     vListInitialise(&(pxReadyTasksLists[uxPriority]));
700a9e52: 9803         	ldr	r0, [sp, #0xc]
700a9e54: eb00 0180    	add.w	r1, r0, r0, lsl #2
700a9e58: f244 40f8    	movw	r0, #0x44f8
700a9e5c: f2c7 0008    	movt	r0, #0x7008
700a9e60: eb00 0081    	add.w	r0, r0, r1, lsl #2
700a9e64: f004 fe14    	bl	0x700aea90 <vListInitialise> @ imm = #0x4c28
;   }
700a9e68: e7ff         	b	0x700a9e6a <prvInitialiseTaskLists+0x2a> @ imm = #-0x2
;        uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
700a9e6a: 9803         	ldr	r0, [sp, #0xc]
700a9e6c: 3001         	adds	r0, #0x1
700a9e6e: 9003         	str	r0, [sp, #0xc]
;   for (uxPriority = (UBaseType_t)0U;
700a9e70: e7eb         	b	0x700a9e4a <prvInitialiseTaskLists+0xa> @ imm = #-0x2a
;   vListInitialise(&xDelayedTaskList1);
700a9e72: f245 2038    	movw	r0, #0x5238
700a9e76: f2c7 0008    	movt	r0, #0x7008
700a9e7a: 9001         	str	r0, [sp, #0x4]
700a9e7c: f004 fe08    	bl	0x700aea90 <vListInitialise> @ imm = #0x4c10
;   vListInitialise(&xDelayedTaskList2);
700a9e80: f245 204c    	movw	r0, #0x524c
700a9e84: f2c7 0008    	movt	r0, #0x7008
700a9e88: 9002         	str	r0, [sp, #0x8]
700a9e8a: f004 fe01    	bl	0x700aea90 <vListInitialise> @ imm = #0x4c02
;   vListInitialise(&xPendingReadyList);
700a9e8e: f245 2060    	movw	r0, #0x5260
700a9e92: f2c7 0008    	movt	r0, #0x7008
700a9e96: f004 fdfb    	bl	0x700aea90 <vListInitialise> @ imm = #0x4bf6
;     vListInitialise(&xTasksWaitingTermination);
700a9e9a: f245 2088    	movw	r0, #0x5288
700a9e9e: f2c7 0008    	movt	r0, #0x7008
700a9ea2: f004 fdf5    	bl	0x700aea90 <vListInitialise> @ imm = #0x4bea
;     vListInitialise(&xSuspendedTaskList);
700a9ea6: f245 2074    	movw	r0, #0x5274
700a9eaa: f2c7 0008    	movt	r0, #0x7008
700a9eae: f004 fdef    	bl	0x700aea90 <vListInitialise> @ imm = #0x4bde
700a9eb2: 9901         	ldr	r1, [sp, #0x4]
700a9eb4: 9802         	ldr	r0, [sp, #0x8]
;   pxDelayedTaskList = &xDelayedTaskList1;
700a9eb6: f245 22a0    	movw	r2, #0x52a0
700a9eba: f2c7 0208    	movt	r2, #0x7008
700a9ebe: 6011         	str	r1, [r2]
;   pxOverflowDelayedTaskList = &xDelayedTaskList2;
700a9ec0: f245 21a4    	movw	r1, #0x52a4
700a9ec4: f2c7 0108    	movt	r1, #0x7008
700a9ec8: 6008         	str	r0, [r1]
; }
700a9eca: b004         	add	sp, #0x10
700a9ecc: bd80         	pop	{r7, pc}
700a9ece: 0000         	movs	r0, r0

700a9ed0 <Sciclient_pmGetModuleState>:
; {
700a9ed0: b580         	push	{r7, lr}
700a9ed2: b096         	sub	sp, #0x58
700a9ed4: f8dd c060    	ldr.w	r12, [sp, #0x60]
700a9ed8: 9015         	str	r0, [sp, #0x54]
700a9eda: 9114         	str	r1, [sp, #0x50]
700a9edc: 9213         	str	r2, [sp, #0x4c]
700a9ede: 9312         	str	r3, [sp, #0x48]
700a9ee0: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a9ee2: 9011         	str	r0, [sp, #0x44]
;     struct tisci_msg_get_device_resp response = {{0}};
700a9ee4: f8ad 0034    	strh.w	r0, [sp, #0x34]
700a9ee8: 900c         	str	r0, [sp, #0x30]
700a9eea: 900b         	str	r0, [sp, #0x2c]
700a9eec: 900a         	str	r0, [sp, #0x28]
700a9eee: 9009         	str	r0, [sp, #0x24]
;     request.id = (uint32_t) moduleId;
700a9ef0: 9915         	ldr	r1, [sp, #0x54]
700a9ef2: 9110         	str	r1, [sp, #0x40]
700a9ef4: f240 2101    	movw	r1, #0x201
;     reqParam.messageType    = (uint16_t) TISCI_MSG_GET_DEVICE;
700a9ef8: f8ad 1010    	strh.w	r1, [sp, #0x10]
700a9efc: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700a9efe: 9105         	str	r1, [sp, #0x14]
700a9f00: a90e         	add	r1, sp, #0x38
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a9f02: 9106         	str	r1, [sp, #0x18]
700a9f04: 210c         	movs	r1, #0xc
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9f06: 9107         	str	r1, [sp, #0x1c]
;     reqParam.timeout        = (uint32_t) timeout;
700a9f08: 9918         	ldr	r1, [sp, #0x60]
700a9f0a: 9108         	str	r1, [sp, #0x20]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9f0c: 9001         	str	r0, [sp, #0x4]
700a9f0e: a809         	add	r0, sp, #0x24
;     respParam.pRespPayload    = (uint8_t *) &response;
700a9f10: 9002         	str	r0, [sp, #0x8]
700a9f12: 2012         	movs	r0, #0x12
;     respParam.respPayloadSize = (uint32_t) sizeof (response);
700a9f14: 9003         	str	r0, [sp, #0xc]
700a9f16: a804         	add	r0, sp, #0x10
700a9f18: a901         	add	r1, sp, #0x4
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9f1a: f7f3 fb61    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xc93e
700a9f1e: 9011         	str	r0, [sp, #0x44]
;     if((retVal != SystemP_SUCCESS) ||
700a9f20: 9811         	ldr	r0, [sp, #0x44]
700a9f22: b930         	cbnz	r0, 0x700a9f32 <Sciclient_pmGetModuleState+0x62> @ imm = #0xc
700a9f24: e7ff         	b	0x700a9f26 <Sciclient_pmGetModuleState+0x56> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9f26: 9801         	ldr	r0, [sp, #0x4]
700a9f28: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9f2c: 2802         	cmp	r0, #0x2
700a9f2e: d004         	beq	0x700a9f3a <Sciclient_pmGetModuleState+0x6a> @ imm = #0x8
700a9f30: e7ff         	b	0x700a9f32 <Sciclient_pmGetModuleState+0x62> @ imm = #-0x2
700a9f32: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9f36: 9011         	str	r0, [sp, #0x44]
;     }
700a9f38: e7ff         	b	0x700a9f3a <Sciclient_pmGetModuleState+0x6a> @ imm = #-0x2
;     if (retVal == SystemP_SUCCESS)
700a9f3a: 9811         	ldr	r0, [sp, #0x44]
700a9f3c: b958         	cbnz	r0, 0x700a9f56 <Sciclient_pmGetModuleState+0x86> @ imm = #0x16
700a9f3e: e7ff         	b	0x700a9f40 <Sciclient_pmGetModuleState+0x70> @ imm = #-0x2
;         *moduleState = (uint32_t) response.current_state;
700a9f40: f89d 0035    	ldrb.w	r0, [sp, #0x35]
700a9f44: 9914         	ldr	r1, [sp, #0x50]
700a9f46: 6008         	str	r0, [r1]
;         *resetState = (uint32_t) response.resets;
700a9f48: 980c         	ldr	r0, [sp, #0x30]
700a9f4a: 9913         	ldr	r1, [sp, #0x4c]
700a9f4c: 6008         	str	r0, [r1]
;         *contextLossState = (uint32_t) response.context_loss_count;
700a9f4e: 980b         	ldr	r0, [sp, #0x2c]
700a9f50: 9912         	ldr	r1, [sp, #0x48]
700a9f52: 6008         	str	r0, [r1]
;     }
700a9f54: e7ff         	b	0x700a9f56 <Sciclient_pmGetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700a9f56: 9811         	ldr	r0, [sp, #0x44]
700a9f58: b016         	add	sp, #0x58
700a9f5a: bd80         	pop	{r7, pc}
700a9f5c: 0000         	movs	r0, r0
700a9f5e: 0000         	movs	r0, r0

700a9f60 <Sciclient_pmModuleClkRequest>:
; {
700a9f60: b580         	push	{r7, lr}
700a9f62: b092         	sub	sp, #0x48
700a9f64: f8dd c050    	ldr.w	r12, [sp, #0x50]
700a9f68: 9011         	str	r0, [sp, #0x44]
700a9f6a: 9110         	str	r1, [sp, #0x40]
700a9f6c: 920f         	str	r2, [sp, #0x3c]
700a9f6e: 930e         	str	r3, [sp, #0x38]
700a9f70: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a9f72: 900d         	str	r0, [sp, #0x34]
;     request.device = (uint32_t) moduleId;
700a9f74: 9811         	ldr	r0, [sp, #0x44]
700a9f76: 900a         	str	r0, [sp, #0x28]
;     if(clockId > (uint32_t)(255U))
700a9f78: 9810         	ldr	r0, [sp, #0x40]
700a9f7a: f5b0 7f80    	cmp.w	r0, #0x100
700a9f7e: d307         	blo	0x700a9f90 <Sciclient_pmModuleClkRequest+0x30> @ imm = #0xe
700a9f80: e7ff         	b	0x700a9f82 <Sciclient_pmModuleClkRequest+0x22> @ imm = #-0x2
700a9f82: 20ff         	movs	r0, #0xff
;         request.clk = (uint8_t)(255U);
700a9f84: f88d 002c    	strb.w	r0, [sp, #0x2c]
;         request.clk32 = clockId;
700a9f88: 9810         	ldr	r0, [sp, #0x40]
700a9f8a: f8cd 002e    	str.w	r0, [sp, #0x2e]
;     }
700a9f8e: e003         	b	0x700a9f98 <Sciclient_pmModuleClkRequest+0x38> @ imm = #0x6
;         request.clk    = (uint8_t)clockId;
700a9f90: 9810         	ldr	r0, [sp, #0x40]
700a9f92: f88d 002c    	strb.w	r0, [sp, #0x2c]
700a9f96: e7ff         	b	0x700a9f98 <Sciclient_pmModuleClkRequest+0x38> @ imm = #-0x2
;     request.state  = (uint8_t) state;
700a9f98: 980f         	ldr	r0, [sp, #0x3c]
700a9f9a: f88d 002d    	strb.w	r0, [sp, #0x2d]
700a9f9e: f44f 7080    	mov.w	r0, #0x100
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_CLOCK;
700a9fa2: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP | additionalFlag;
700a9fa6: 980e         	ldr	r0, [sp, #0x38]
700a9fa8: f040 0002    	orr	r0, r0, #0x2
700a9fac: 9004         	str	r0, [sp, #0x10]
700a9fae: a808         	add	r0, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700a9fb0: 9005         	str	r0, [sp, #0x14]
700a9fb2: 2012         	movs	r0, #0x12
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700a9fb4: 9006         	str	r0, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700a9fb6: 9814         	ldr	r0, [sp, #0x50]
700a9fb8: 9007         	str	r0, [sp, #0x1c]
700a9fba: 2000         	movs	r0, #0x0
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700a9fbc: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700a9fbe: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700a9fc0: 9002         	str	r0, [sp, #0x8]
700a9fc2: a803         	add	r0, sp, #0xc
700a9fc4: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700a9fc6: f7f3 fb0b    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xc9ea
700a9fca: 900d         	str	r0, [sp, #0x34]
;     if((retVal != SystemP_SUCCESS) ||
700a9fcc: 980d         	ldr	r0, [sp, #0x34]
700a9fce: b930         	cbnz	r0, 0x700a9fde <Sciclient_pmModuleClkRequest+0x7e> @ imm = #0xc
700a9fd0: e7ff         	b	0x700a9fd2 <Sciclient_pmModuleClkRequest+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700a9fd2: 9800         	ldr	r0, [sp]
700a9fd4: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700a9fd8: 2802         	cmp	r0, #0x2
700a9fda: d004         	beq	0x700a9fe6 <Sciclient_pmModuleClkRequest+0x86> @ imm = #0x8
700a9fdc: e7ff         	b	0x700a9fde <Sciclient_pmModuleClkRequest+0x7e> @ imm = #-0x2
700a9fde: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700a9fe2: 900d         	str	r0, [sp, #0x34]
;     }
700a9fe4: e7ff         	b	0x700a9fe6 <Sciclient_pmModuleClkRequest+0x86> @ imm = #-0x2
;     return retVal;
700a9fe6: 980d         	ldr	r0, [sp, #0x34]
700a9fe8: b012         	add	sp, #0x48
700a9fea: bd80         	pop	{r7, pc}
700a9fec: 0000         	movs	r0, r0
700a9fee: 0000         	movs	r0, r0

700a9ff0 <Sciclient_pmSetModuleState>:
; {
700a9ff0: b580         	push	{r7, lr}
700a9ff2: b092         	sub	sp, #0x48
700a9ff4: 9011         	str	r0, [sp, #0x44]
700a9ff6: 9110         	str	r1, [sp, #0x40]
700a9ff8: 920f         	str	r2, [sp, #0x3c]
700a9ffa: 930e         	str	r3, [sp, #0x38]
700a9ffc: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700a9ffe: 900d         	str	r0, [sp, #0x34]
;     request.id       = (uint32_t) moduleId;
700aa000: 9911         	ldr	r1, [sp, #0x44]
700aa002: 910a         	str	r1, [sp, #0x28]
;     request.reserved = (uint32_t) 0;
700aa004: 900b         	str	r0, [sp, #0x2c]
;     request.state    = (uint8_t) state;
700aa006: 9910         	ldr	r1, [sp, #0x40]
700aa008: f88d 1030    	strb.w	r1, [sp, #0x30]
700aa00c: f44f 7100    	mov.w	r1, #0x200
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE;
700aa010: f8ad 100c    	strh.w	r1, [sp, #0xc]
;     reqParam.flags          = (uint32_t) reqFlag;
700aa014: 990f         	ldr	r1, [sp, #0x3c]
700aa016: 9104         	str	r1, [sp, #0x10]
700aa018: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700aa01a: 9105         	str	r1, [sp, #0x14]
700aa01c: 2111         	movs	r1, #0x11
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700aa01e: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700aa020: 990e         	ldr	r1, [sp, #0x38]
700aa022: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700aa024: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700aa026: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700aa028: 9002         	str	r0, [sp, #0x8]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700aa02a: 980f         	ldr	r0, [sp, #0x3c]
700aa02c: f000 0002    	and	r0, r0, #0x2
700aa030: 2802         	cmp	r0, #0x2
700aa032: d007         	beq	0x700aa044 <Sciclient_pmSetModuleState+0x54> @ imm = #0xe
700aa034: e7ff         	b	0x700aa036 <Sciclient_pmSetModuleState+0x46> @ imm = #-0x2
;         (reqFlag != 0U))
700aa036: 980f         	ldr	r0, [sp, #0x3c]
;     if (((reqFlag & TISCI_MSG_FLAG_AOP) != TISCI_MSG_FLAG_AOP)&&
700aa038: b120         	cbz	r0, 0x700aa044 <Sciclient_pmSetModuleState+0x54> @ imm = #0x8
700aa03a: e7ff         	b	0x700aa03c <Sciclient_pmSetModuleState+0x4c> @ imm = #-0x2
700aa03c: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700aa040: 900d         	str	r0, [sp, #0x34]
;     }
700aa042: e7ff         	b	0x700aa044 <Sciclient_pmSetModuleState+0x54> @ imm = #-0x2
;     if(retVal == SystemP_SUCCESS)
700aa044: 980d         	ldr	r0, [sp, #0x34]
700aa046: b930         	cbnz	r0, 0x700aa056 <Sciclient_pmSetModuleState+0x66> @ imm = #0xc
700aa048: e7ff         	b	0x700aa04a <Sciclient_pmSetModuleState+0x5a> @ imm = #-0x2
700aa04a: a803         	add	r0, sp, #0xc
700aa04c: 4669         	mov	r1, sp
;         retVal = Sciclient_service(&reqParam, &respParam);
700aa04e: f7f3 fac7    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xca72
700aa052: 900d         	str	r0, [sp, #0x34]
;     }
700aa054: e7ff         	b	0x700aa056 <Sciclient_pmSetModuleState+0x66> @ imm = #-0x2
;     if((retVal != SystemP_SUCCESS) ||
700aa056: 980d         	ldr	r0, [sp, #0x34]
700aa058: b948         	cbnz	r0, 0x700aa06e <Sciclient_pmSetModuleState+0x7e> @ imm = #0x12
700aa05a: e7ff         	b	0x700aa05c <Sciclient_pmSetModuleState+0x6c> @ imm = #-0x2
;         ((reqFlag != 0U) &&
700aa05c: 980f         	ldr	r0, [sp, #0x3c]
700aa05e: b150         	cbz	r0, 0x700aa076 <Sciclient_pmSetModuleState+0x86> @ imm = #0x14
700aa060: e7ff         	b	0x700aa062 <Sciclient_pmSetModuleState+0x72> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)))
700aa062: 9800         	ldr	r0, [sp]
700aa064: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700aa068: 2802         	cmp	r0, #0x2
700aa06a: d004         	beq	0x700aa076 <Sciclient_pmSetModuleState+0x86> @ imm = #0x8
700aa06c: e7ff         	b	0x700aa06e <Sciclient_pmSetModuleState+0x7e> @ imm = #-0x2
700aa06e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700aa072: 900d         	str	r0, [sp, #0x34]
;     }
700aa074: e7ff         	b	0x700aa076 <Sciclient_pmSetModuleState+0x86> @ imm = #-0x2
;     return retVal;
700aa076: 980d         	ldr	r0, [sp, #0x34]
700aa078: b012         	add	sp, #0x48
700aa07a: bd80         	pop	{r7, pc}
700aa07c: 0000         	movs	r0, r0
700aa07e: 0000         	movs	r0, r0

700aa080 <Sciclient_rmIaEvtRomMapped>:
; {
700aa080: b082         	sub	sp, #0x8
700aa082: 9001         	str	r0, [sp, #0x4]
700aa084: f8ad 1002    	strh.w	r1, [sp, #0x2]
700aa088: 2000         	movs	r0, #0x0
;     bool rom_mapped = false;
700aa08a: f88d 0001    	strb.w	r0, [sp, #0x1]
;     if (inst->rom_usage != NULL) {
700aa08e: 9801         	ldr	r0, [sp, #0x4]
700aa090: 6980         	ldr	r0, [r0, #0x18]
700aa092: b3a8         	cbz	r0, 0x700aa100 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #0x6a
700aa094: e7ff         	b	0x700aa096 <Sciclient_rmIaEvtRomMapped+0x16> @ imm = #-0x2
700aa096: 2000         	movs	r0, #0x0
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700aa098: f88d 0000    	strb.w	r0, [sp]
700aa09c: e7ff         	b	0x700aa09e <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x2
700aa09e: f89d 0000    	ldrb.w	r0, [sp]
700aa0a2: 9901         	ldr	r1, [sp, #0x4]
700aa0a4: 7f09         	ldrb	r1, [r1, #0x1c]
700aa0a6: 4288         	cmp	r0, r1
700aa0a8: da29         	bge	0x700aa0fe <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0x52
700aa0aa: e7ff         	b	0x700aa0ac <Sciclient_rmIaEvtRomMapped+0x2c> @ imm = #-0x2
;             if ((inst->rom_usage[i].cleared == false) &&
700aa0ac: 9801         	ldr	r0, [sp, #0x4]
700aa0ae: 6980         	ldr	r0, [r0, #0x18]
700aa0b0: f89d 1000    	ldrb.w	r1, [sp]
700aa0b4: eb00 0081    	add.w	r0, r0, r1, lsl #2
700aa0b8: 7880         	ldrb	r0, [r0, #0x2]
700aa0ba: 07c0         	lsls	r0, r0, #0x1f
700aa0bc: b9c0         	cbnz	r0, 0x700aa0f0 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x30
700aa0be: e7ff         	b	0x700aa0c0 <Sciclient_rmIaEvtRomMapped+0x40> @ imm = #-0x2
;                 (evt == (inst->rom_usage[i].event - inst->sevt_offset))) {
700aa0c0: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700aa0c4: 9a01         	ldr	r2, [sp, #0x4]
700aa0c6: 6991         	ldr	r1, [r2, #0x18]
700aa0c8: f89d 3000    	ldrb.w	r3, [sp]
700aa0cc: f831 1023    	ldrh.w	r1, [r1, r3, lsl #2]
700aa0d0: 8912         	ldrh	r2, [r2, #0x8]
700aa0d2: 1a89         	subs	r1, r1, r2
;             if ((inst->rom_usage[i].cleared == false) &&
700aa0d4: 4288         	cmp	r0, r1
700aa0d6: d10b         	bne	0x700aa0f0 <Sciclient_rmIaEvtRomMapped+0x70> @ imm = #0x16
700aa0d8: e7ff         	b	0x700aa0da <Sciclient_rmIaEvtRomMapped+0x5a> @ imm = #-0x2
700aa0da: 2001         	movs	r0, #0x1
;                 rom_mapped = true;
700aa0dc: f88d 0001    	strb.w	r0, [sp, #0x1]
;                 inst->rom_usage[i].cleared = true;
700aa0e0: 9901         	ldr	r1, [sp, #0x4]
700aa0e2: 6989         	ldr	r1, [r1, #0x18]
700aa0e4: f89d 2000    	ldrb.w	r2, [sp]
700aa0e8: eb01 0182    	add.w	r1, r1, r2, lsl #2
700aa0ec: 7088         	strb	r0, [r1, #0x2]
;                 break;
700aa0ee: e006         	b	0x700aa0fe <Sciclient_rmIaEvtRomMapped+0x7e> @ imm = #0xc
;         }
700aa0f0: e7ff         	b	0x700aa0f2 <Sciclient_rmIaEvtRomMapped+0x72> @ imm = #-0x2
;         for (i = 0u; i < inst->n_rom_usage; i++) {
700aa0f2: f89d 0000    	ldrb.w	r0, [sp]
700aa0f6: 3001         	adds	r0, #0x1
700aa0f8: f88d 0000    	strb.w	r0, [sp]
700aa0fc: e7cf         	b	0x700aa09e <Sciclient_rmIaEvtRomMapped+0x1e> @ imm = #-0x62
;     }
700aa0fe: e7ff         	b	0x700aa100 <Sciclient_rmIaEvtRomMapped+0x80> @ imm = #-0x2
;     return rom_mapped;
700aa100: f89d 0001    	ldrb.w	r0, [sp, #0x1]
700aa104: f000 0001    	and	r0, r0, #0x1
700aa108: b002         	add	sp, #0x8
700aa10a: 4770         	bx	lr
700aa10c: 0000         	movs	r0, r0
700aa10e: 0000         	movs	r0, r0

700aa110 <UART_writeCancelNoCB>:
; {
700aa110: b580         	push	{r7, lr}
700aa112: b084         	sub	sp, #0x10
700aa114: 9003         	str	r0, [sp, #0xc]
700aa116: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700aa118: 9001         	str	r0, [sp, #0x4]
;     hUartInit = hUart->hUartInit;
700aa11a: 9803         	ldr	r0, [sp, #0xc]
700aa11c: 6840         	ldr	r0, [r0, #0x4]
700aa11e: 9000         	str	r0, [sp]
;     UART_intrDisable(hUart->baseAddr, UART_INTR_THR);
700aa120: 9803         	ldr	r0, [sp, #0xc]
700aa122: 6800         	ldr	r0, [r0]
700aa124: 2102         	movs	r1, #0x2
700aa126: f7fc f913    	bl	0x700a6350 <UART_intrDisable> @ imm = #-0x3dda
;     key = HwiP_disable();
700aa12a: f006 ec1a    	blx	0x700b0960 <HwiP_disable> @ imm = #0x6834
700aa12e: 9002         	str	r0, [sp, #0x8]
;     if ((hUart->writeSizeRemaining) == 0U)
700aa130: 9803         	ldr	r0, [sp, #0xc]
700aa132: 6900         	ldr	r0, [r0, #0x10]
700aa134: b920         	cbnz	r0, 0x700aa140 <UART_writeCancelNoCB+0x30> @ imm = #0x8
700aa136: e7ff         	b	0x700aa138 <UART_writeCancelNoCB+0x28> @ imm = #-0x2
700aa138: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700aa13c: 9001         	str	r0, [sp, #0x4]
;     }
700aa13e: e027         	b	0x700aa190 <UART_writeCancelNoCB+0x80> @ imm = #0x4e
;         if (hUartInit->transferMode == UART_CONFIG_MODE_DMA)
700aa140: 9800         	ldr	r0, [sp]
700aa142: 6a00         	ldr	r0, [r0, #0x20]
700aa144: 2803         	cmp	r0, #0x3
700aa146: d111         	bne	0x700aa16c <UART_writeCancelNoCB+0x5c> @ imm = #0x22
700aa148: e7ff         	b	0x700aa14a <UART_writeCancelNoCB+0x3a> @ imm = #-0x2
;             UART_lld_dmaDisableChannel(hUart, (Bool)TRUE);
700aa14a: 9803         	ldr	r0, [sp, #0xc]
700aa14c: 2101         	movs	r1, #0x1
700aa14e: f7ff fc4f    	bl	0x700a99f0 <UART_lld_dmaDisableChannel> @ imm = #-0x762
;             if (hUart->writeTrans.buf != NULL)
700aa152: 9803         	ldr	r0, [sp, #0xc]
700aa154: 6bc0         	ldr	r0, [r0, #0x3c]
700aa156: b120         	cbz	r0, 0x700aa162 <UART_writeCancelNoCB+0x52> @ imm = #0x8
700aa158: e7ff         	b	0x700aa15a <UART_writeCancelNoCB+0x4a> @ imm = #-0x2
;                 hUart->writeTrans.count = 0;
700aa15a: 9903         	ldr	r1, [sp, #0xc]
700aa15c: 2000         	movs	r0, #0x0
700aa15e: 6408         	str	r0, [r1, #0x40]
;             }
700aa160: e003         	b	0x700aa16a <UART_writeCancelNoCB+0x5a> @ imm = #0x6
;                 hUart->writeCount = 0;
700aa162: 9903         	ldr	r1, [sp, #0xc]
700aa164: 2000         	movs	r0, #0x0
700aa166: 60c8         	str	r0, [r1, #0xc]
700aa168: e7ff         	b	0x700aa16a <UART_writeCancelNoCB+0x5a> @ imm = #-0x2
;         }
700aa16a: e010         	b	0x700aa18e <UART_writeCancelNoCB+0x7e> @ imm = #0x20
;             hUart->writeBuf = (const uint8_t *)hUart->writeBuf - hUart->writeCount;
700aa16c: 9903         	ldr	r1, [sp, #0xc]
700aa16e: 6888         	ldr	r0, [r1, #0x8]
700aa170: 68ca         	ldr	r2, [r1, #0xc]
700aa172: 1a80         	subs	r0, r0, r2
700aa174: 6088         	str	r0, [r1, #0x8]
;             if (hUart->writeTrans.buf != NULL)
700aa176: 9803         	ldr	r0, [sp, #0xc]
700aa178: 6bc0         	ldr	r0, [r0, #0x3c]
700aa17a: b120         	cbz	r0, 0x700aa186 <UART_writeCancelNoCB+0x76> @ imm = #0x8
700aa17c: e7ff         	b	0x700aa17e <UART_writeCancelNoCB+0x6e> @ imm = #-0x2
;                 hUart->writeTrans.count = (uint32_t)(hUart->writeCount);
700aa17e: 9903         	ldr	r1, [sp, #0xc]
700aa180: 68c8         	ldr	r0, [r1, #0xc]
700aa182: 6408         	str	r0, [r1, #0x40]
;             }
700aa184: e7ff         	b	0x700aa186 <UART_writeCancelNoCB+0x76> @ imm = #-0x2
;             hUart->writeSizeRemaining = 0;
700aa186: 9903         	ldr	r1, [sp, #0xc]
700aa188: 2000         	movs	r0, #0x0
700aa18a: 6108         	str	r0, [r1, #0x10]
700aa18c: e7ff         	b	0x700aa18e <UART_writeCancelNoCB+0x7e> @ imm = #-0x2
700aa18e: e7ff         	b	0x700aa190 <UART_writeCancelNoCB+0x80> @ imm = #-0x2
;     HwiP_restore(key);
700aa190: 9802         	ldr	r0, [sp, #0x8]
700aa192: f006 ec06    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x680c
;     return (status);
700aa196: 9801         	ldr	r0, [sp, #0x4]
700aa198: b004         	add	sp, #0x10
700aa19a: bd80         	pop	{r7, pc}
700aa19c: 0000         	movs	r0, r0
700aa19e: 0000         	movs	r0, r0

700aa1a0 <Udma_ringFlushRaw>:
; {
700aa1a0: b580         	push	{r7, lr}
700aa1a2: b086         	sub	sp, #0x18
700aa1a4: 9005         	str	r0, [sp, #0x14]
700aa1a6: 9104         	str	r1, [sp, #0x10]
700aa1a8: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aa1aa: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700aa1ac: 9805         	ldr	r0, [sp, #0x14]
700aa1ae: 9001         	str	r0, [sp, #0x4]
;     if((NULL_PTR == ringHandleInt) ||
700aa1b0: 9801         	ldr	r0, [sp, #0x4]
700aa1b2: b180         	cbz	r0, 0x700aa1d6 <Udma_ringFlushRaw+0x36> @ imm = #0x20
700aa1b4: e7ff         	b	0x700aa1b6 <Udma_ringFlushRaw+0x16> @ imm = #-0x2
;        (ringHandleInt->ringInitDone != UDMA_INIT_DONE) ||
700aa1b6: 9801         	ldr	r0, [sp, #0x4]
700aa1b8: 6d80         	ldr	r0, [r0, #0x58]
700aa1ba: f64a 31cd    	movw	r1, #0xabcd
700aa1be: f6ca 31dc    	movt	r1, #0xabdc
700aa1c2: 4288         	cmp	r0, r1
700aa1c4: d107         	bne	0x700aa1d6 <Udma_ringFlushRaw+0x36> @ imm = #0xe
700aa1c6: e7ff         	b	0x700aa1c8 <Udma_ringFlushRaw+0x28> @ imm = #-0x2
;        (ringHandleInt->ringNum == UDMA_RING_INVALID))
700aa1c8: 9801         	ldr	r0, [sp, #0x4]
700aa1ca: 8880         	ldrh	r0, [r0, #0x4]
700aa1cc: f64f 71ff    	movw	r1, #0xffff
;     if((NULL_PTR == ringHandleInt) ||
700aa1d0: 4288         	cmp	r0, r1
700aa1d2: d104         	bne	0x700aa1de <Udma_ringFlushRaw+0x3e> @ imm = #0x8
700aa1d4: e7ff         	b	0x700aa1d6 <Udma_ringFlushRaw+0x36> @ imm = #-0x2
700aa1d6: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700aa1da: 9003         	str	r0, [sp, #0xc]
;     }
700aa1dc: e7ff         	b	0x700aa1de <Udma_ringFlushRaw+0x3e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aa1de: 9803         	ldr	r0, [sp, #0xc]
700aa1e0: b9a8         	cbnz	r0, 0x700aa20e <Udma_ringFlushRaw+0x6e> @ imm = #0x2a
700aa1e2: e7ff         	b	0x700aa1e4 <Udma_ringFlushRaw+0x44> @ imm = #-0x2
;         drvHandle = ringHandleInt->drvHandle;
700aa1e4: 9801         	ldr	r0, [sp, #0x4]
700aa1e6: 6800         	ldr	r0, [r0]
700aa1e8: 9002         	str	r0, [sp, #0x8]
;         if((NULL_PTR == drvHandle) ||
700aa1ea: 9802         	ldr	r0, [sp, #0x8]
700aa1ec: b150         	cbz	r0, 0x700aa204 <Udma_ringFlushRaw+0x64> @ imm = #0x14
700aa1ee: e7ff         	b	0x700aa1f0 <Udma_ringFlushRaw+0x50> @ imm = #-0x2
;            (drvHandle->drvInitDone != UDMA_INIT_DONE))
700aa1f0: 9802         	ldr	r0, [sp, #0x8]
700aa1f2: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700aa1f6: f64a 31cd    	movw	r1, #0xabcd
700aa1fa: f6ca 31dc    	movt	r1, #0xabdc
;         if((NULL_PTR == drvHandle) ||
700aa1fe: 4288         	cmp	r0, r1
700aa200: d004         	beq	0x700aa20c <Udma_ringFlushRaw+0x6c> @ imm = #0x8
700aa202: e7ff         	b	0x700aa204 <Udma_ringFlushRaw+0x64> @ imm = #-0x2
700aa204: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700aa208: 9003         	str	r0, [sp, #0xc]
;         }
700aa20a: e7ff         	b	0x700aa20c <Udma_ringFlushRaw+0x6c> @ imm = #-0x2
;     }
700aa20c: e7ff         	b	0x700aa20e <Udma_ringFlushRaw+0x6e> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700aa20e: 9803         	ldr	r0, [sp, #0xc]
700aa210: b940         	cbnz	r0, 0x700aa224 <Udma_ringFlushRaw+0x84> @ imm = #0x10
700aa212: e7ff         	b	0x700aa214 <Udma_ringFlushRaw+0x74> @ imm = #-0x2
;         retVal = drvHandle->ringFlushRaw(drvHandle, ringHandleInt, phyDescMem);
700aa214: 9802         	ldr	r0, [sp, #0x8]
700aa216: f8d0 3598    	ldr.w	r3, [r0, #0x598]
700aa21a: 9901         	ldr	r1, [sp, #0x4]
700aa21c: 9a04         	ldr	r2, [sp, #0x10]
700aa21e: 4798         	blx	r3
700aa220: 9003         	str	r0, [sp, #0xc]
;     }
700aa222: e7ff         	b	0x700aa224 <Udma_ringFlushRaw+0x84> @ imm = #-0x2
;     return (retVal);
700aa224: 9803         	ldr	r0, [sp, #0xc]
700aa226: b006         	add	sp, #0x18
700aa228: bd80         	pop	{r7, pc}
700aa22a: 0000         	movs	r0, r0
700aa22c: 0000         	movs	r0, r0
700aa22e: 0000         	movs	r0, r0

700aa230 <xQueueGenericReset>:
; {
700aa230: b580         	push	{r7, lr}
700aa232: b084         	sub	sp, #0x10
700aa234: 9003         	str	r0, [sp, #0xc]
700aa236: 9102         	str	r1, [sp, #0x8]
;     Queue_t * const pxQueue = xQueue;
700aa238: 9803         	ldr	r0, [sp, #0xc]
700aa23a: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700aa23c: f004 fa98    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x4530
;         pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700aa240: 9901         	ldr	r1, [sp, #0x4]
700aa242: 680b         	ldr	r3, [r1]
700aa244: 6bc8         	ldr	r0, [r1, #0x3c]
700aa246: 6c0a         	ldr	r2, [r1, #0x40]
700aa248: fb00 3002    	mla	r0, r0, r2, r3
700aa24c: 6088         	str	r0, [r1, #0x8]
;         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
700aa24e: 9901         	ldr	r1, [sp, #0x4]
700aa250: 2000         	movs	r0, #0x0
700aa252: 6388         	str	r0, [r1, #0x38]
;         pxQueue->pcWriteTo = pxQueue->pcHead;
700aa254: 9901         	ldr	r1, [sp, #0x4]
700aa256: 6808         	ldr	r0, [r1]
700aa258: 6048         	str	r0, [r1, #0x4]
;         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700aa25a: 9901         	ldr	r1, [sp, #0x4]
700aa25c: 680b         	ldr	r3, [r1]
700aa25e: 6bc8         	ldr	r0, [r1, #0x3c]
700aa260: 6c0a         	ldr	r2, [r1, #0x40]
700aa262: 3801         	subs	r0, #0x1
700aa264: fb00 3002    	mla	r0, r0, r2, r3
700aa268: 60c8         	str	r0, [r1, #0xc]
;         pxQueue->cRxLock = queueUNLOCKED;
700aa26a: 9901         	ldr	r1, [sp, #0x4]
700aa26c: 20ff         	movs	r0, #0xff
700aa26e: f881 0044    	strb.w	r0, [r1, #0x44]
;         pxQueue->cTxLock = queueUNLOCKED;
700aa272: 9901         	ldr	r1, [sp, #0x4]
700aa274: f881 0045    	strb.w	r0, [r1, #0x45]
;         if( xNewQueue == pdFALSE )
700aa278: 9802         	ldr	r0, [sp, #0x8]
700aa27a: b980         	cbnz	r0, 0x700aa29e <xQueueGenericReset+0x6e> @ imm = #0x20
700aa27c: e7ff         	b	0x700aa27e <xQueueGenericReset+0x4e> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
700aa27e: 9801         	ldr	r0, [sp, #0x4]
700aa280: 6900         	ldr	r0, [r0, #0x10]
700aa282: b150         	cbz	r0, 0x700aa29a <xQueueGenericReset+0x6a> @ imm = #0x14
700aa284: e7ff         	b	0x700aa286 <xQueueGenericReset+0x56> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
700aa286: 9801         	ldr	r0, [sp, #0x4]
700aa288: 3010         	adds	r0, #0x10
700aa28a: f7fd fc39    	bl	0x700a7b00 <xTaskRemoveFromEventList> @ imm = #-0x278e
700aa28e: b110         	cbz	r0, 0x700aa296 <xQueueGenericReset+0x66> @ imm = #0x4
700aa290: e7ff         	b	0x700aa292 <xQueueGenericReset+0x62> @ imm = #-0x2
;                     queueYIELD_IF_USING_PREEMPTION();
700aa292: df00         	svc	#0x0
;                 }
700aa294: e000         	b	0x700aa298 <xQueueGenericReset+0x68> @ imm = #0x0
700aa296: e7ff         	b	0x700aa298 <xQueueGenericReset+0x68> @ imm = #-0x2
;             }
700aa298: e000         	b	0x700aa29c <xQueueGenericReset+0x6c> @ imm = #0x0
700aa29a: e7ff         	b	0x700aa29c <xQueueGenericReset+0x6c> @ imm = #-0x2
;         }
700aa29c: e008         	b	0x700aa2b0 <xQueueGenericReset+0x80> @ imm = #0x10
;             vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
700aa29e: 9801         	ldr	r0, [sp, #0x4]
700aa2a0: 3010         	adds	r0, #0x10
700aa2a2: f004 fbf5    	bl	0x700aea90 <vListInitialise> @ imm = #0x47ea
;             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
700aa2a6: 9801         	ldr	r0, [sp, #0x4]
700aa2a8: 3024         	adds	r0, #0x24
700aa2aa: f004 fbf1    	bl	0x700aea90 <vListInitialise> @ imm = #0x47e2
700aa2ae: e7ff         	b	0x700aa2b0 <xQueueGenericReset+0x80> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700aa2b0: f003 fb1e    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x363c
700aa2b4: 2001         	movs	r0, #0x1
;     return pdPASS;
700aa2b6: b004         	add	sp, #0x10
700aa2b8: bd80         	pop	{r7, pc}
700aa2ba: 0000         	movs	r0, r0
700aa2bc: 0000         	movs	r0, r0
700aa2be: 0000         	movs	r0, r0

700aa2c0 <CSL_bcdmaGetCfg>:
; {
700aa2c0: b580         	push	{r7, lr}
700aa2c2: b082         	sub	sp, #0x8
700aa2c4: 9001         	str	r0, [sp, #0x4]
;     if( ! ((pCfg == NULL) || (pCfg->pGenCfgRegs == NULL)) )
700aa2c6: 9801         	ldr	r0, [sp, #0x4]
700aa2c8: b3e0         	cbz	r0, 0x700aa344 <CSL_bcdmaGetCfg+0x84> @ imm = #0x78
700aa2ca: e7ff         	b	0x700aa2cc <CSL_bcdmaGetCfg+0xc> @ imm = #-0x2
700aa2cc: 9801         	ldr	r0, [sp, #0x4]
700aa2ce: 6800         	ldr	r0, [r0]
700aa2d0: b3c0         	cbz	r0, 0x700aa344 <CSL_bcdmaGetCfg+0x84> @ imm = #0x70
700aa2d2: e7ff         	b	0x700aa2d4 <CSL_bcdmaGetCfg+0x14> @ imm = #-0x2
;         pCfg->cap0 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP0 );
700aa2d4: 9801         	ldr	r0, [sp, #0x4]
700aa2d6: 6800         	ldr	r0, [r0]
700aa2d8: 3020         	adds	r0, #0x20
700aa2da: f005 fc91    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0x5922
700aa2de: 9901         	ldr	r1, [sp, #0x4]
700aa2e0: 61c8         	str	r0, [r1, #0x1c]
;         pCfg->cap1 = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP1 );
700aa2e2: 9801         	ldr	r0, [sp, #0x4]
700aa2e4: 6800         	ldr	r0, [r0]
700aa2e6: 3024         	adds	r0, #0x24
700aa2e8: f005 fc8a    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0x5914
700aa2ec: 9901         	ldr	r1, [sp, #0x4]
700aa2ee: 6208         	str	r0, [r1, #0x20]
;         regVal = CSL_REG32_RD( &pCfg->pGenCfgRegs->CAP2 );
700aa2f0: 9801         	ldr	r0, [sp, #0x4]
700aa2f2: 6800         	ldr	r0, [r0]
700aa2f4: 3028         	adds	r0, #0x28
700aa2f6: f005 fc83    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0x5906
700aa2fa: 9000         	str	r0, [sp]
;         pCfg->bcChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_CHAN_CNT );
700aa2fc: 9800         	ldr	r0, [sp]
700aa2fe: f36f 205f    	bfc	r0, #9, #23
700aa302: 9901         	ldr	r1, [sp, #0x4]
700aa304: 6248         	str	r0, [r1, #0x24]
;         pCfg->splitTxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_TCHAN_CNT );
700aa306: 9800         	ldr	r0, [sp]
700aa308: f3c0 2048    	ubfx	r0, r0, #0x9, #0x9
700aa30c: 9901         	ldr	r1, [sp, #0x4]
700aa30e: 62c8         	str	r0, [r1, #0x2c]
;         pCfg->splitRxChanCnt = CSL_FEXT( regVal, BCDMA_GCFG_CAP2_RCHAN_CNT );
700aa310: 9800         	ldr	r0, [sp]
700aa312: f3c0 4088    	ubfx	r0, r0, #0x12, #0x9
700aa316: 9901         	ldr	r1, [sp, #0x4]
700aa318: 6288         	str	r0, [r1, #0x28]
;         pCfg->flowCnt = (uint32_t)0U;
700aa31a: 9901         	ldr	r1, [sp, #0x4]
700aa31c: 2000         	movs	r0, #0x0
700aa31e: 6308         	str	r0, [r1, #0x30]
;         pCfg->txChanCnt                     = pCfg->bcChanCnt + pCfg->splitTxChanCnt;
700aa320: 9a01         	ldr	r2, [sp, #0x4]
700aa322: 6a51         	ldr	r1, [r2, #0x24]
700aa324: 6ad3         	ldr	r3, [r2, #0x2c]
700aa326: 4419         	add	r1, r3
700aa328: 6351         	str	r1, [r2, #0x34]
;         pCfg->rxChanCnt                     = pCfg->splitRxChanCnt;
700aa32a: 9a01         	ldr	r2, [sp, #0x4]
700aa32c: 6a91         	ldr	r1, [r2, #0x28]
700aa32e: 6391         	str	r1, [r2, #0x38]
;         pCfg->rxFlowCnt                     = pCfg->flowCnt;
700aa330: 9a01         	ldr	r2, [sp, #0x4]
700aa332: 6b11         	ldr	r1, [r2, #0x30]
700aa334: 63d1         	str	r1, [r2, #0x3c]
;         pCfg->txExtUtcChanCnt               = (uint32_t)0U;
700aa336: 9901         	ldr	r1, [sp, #0x4]
700aa338: 6408         	str	r0, [r1, #0x40]
;         pCfg->txHighCapacityChanCnt         = (uint32_t)0U;
700aa33a: 9901         	ldr	r1, [sp, #0x4]
700aa33c: 6448         	str	r0, [r1, #0x44]
;         pCfg->txUltraHighCapacityChanCnt    = (uint32_t)0U;
700aa33e: 9901         	ldr	r1, [sp, #0x4]
700aa340: 6488         	str	r0, [r1, #0x48]
;     }
700aa342: e7ff         	b	0x700aa344 <CSL_bcdmaGetCfg+0x84> @ imm = #-0x2
; }
700aa344: b002         	add	sp, #0x8
700aa346: bd80         	pop	{r7, pc}
		...

700aa350 <Udma_rmFreeVintrBit>:
; {
700aa350: b580         	push	{r7, lr}
700aa352: b088         	sub	sp, #0x20
700aa354: 9007         	str	r0, [sp, #0x1c]
700aa356: 9106         	str	r1, [sp, #0x18]
700aa358: 9205         	str	r2, [sp, #0x14]
;     controllerEventHandle = eventHandle;
700aa35a: 9805         	ldr	r0, [sp, #0x14]
700aa35c: 9001         	str	r0, [sp, #0x4]
;     eventPrms = &eventHandle->eventPrms;
700aa35e: 9805         	ldr	r0, [sp, #0x14]
700aa360: 3008         	adds	r0, #0x8
700aa362: 9000         	str	r0, [sp]
;     if(NULL_PTR != eventPrms->controllerEventHandle)
700aa364: 9800         	ldr	r0, [sp]
700aa366: 6900         	ldr	r0, [r0, #0x10]
700aa368: b120         	cbz	r0, 0x700aa374 <Udma_rmFreeVintrBit+0x24> @ imm = #0x8
700aa36a: e7ff         	b	0x700aa36c <Udma_rmFreeVintrBit+0x1c> @ imm = #-0x2
;         controllerEventHandle = (Udma_EventHandleInt) eventPrms->controllerEventHandle;
700aa36c: 9800         	ldr	r0, [sp]
700aa36e: 6900         	ldr	r0, [r0, #0x10]
700aa370: 9001         	str	r0, [sp, #0x4]
;     }
700aa372: e7ff         	b	0x700aa374 <Udma_rmFreeVintrBit+0x24> @ imm = #-0x2
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700aa374: 9806         	ldr	r0, [sp, #0x18]
700aa376: f500 609f    	add.w	r0, r0, #0x4f8
700aa37a: f04f 31ff    	mov.w	r1, #0xffffffff
700aa37e: f000 fa27    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #0x44e
;     bitMask = ((uint64_t) 1U << vintrBitNum);
700aa382: 9b07         	ldr	r3, [sp, #0x1c]
700aa384: f1a3 0220    	sub.w	r2, r3, #0x20
700aa388: 2101         	movs	r1, #0x1
700aa38a: fa01 fc02    	lsl.w	r12, r1, r2
700aa38e: f1c3 0020    	rsb.w	r0, r3, #0x20
700aa392: fa21 f000    	lsr.w	r0, r1, r0
700aa396: 2a00         	cmp	r2, #0x0
700aa398: bf58         	it	pl
700aa39a: 4660         	movpl	r0, r12
700aa39c: fa01 f103    	lsl.w	r1, r1, r3
700aa3a0: 2a00         	cmp	r2, #0x0
700aa3a2: bf58         	it	pl
700aa3a4: 2100         	movpl	r1, #0x0
700aa3a6: 9102         	str	r1, [sp, #0x8]
700aa3a8: 9003         	str	r0, [sp, #0xc]
;     controllerEventHandle->vintrBitAllocFlag &= ~bitMask;
700aa3aa: f8dd c008    	ldr.w	r12, [sp, #0x8]
700aa3ae: 9b03         	ldr	r3, [sp, #0xc]
700aa3b0: 9901         	ldr	r1, [sp, #0x4]
700aa3b2: f8d1 0088    	ldr.w	r0, [r1, #0x88]
700aa3b6: f8d1 208c    	ldr.w	r2, [r1, #0x8c]
700aa3ba: ea20 000c    	bic.w	r0, r0, r12
700aa3be: ea22 0203    	bic.w	r2, r2, r3
700aa3c2: f8c1 208c    	str.w	r2, [r1, #0x8c]
700aa3c6: f8c1 0088    	str.w	r0, [r1, #0x88]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700aa3ca: 9806         	ldr	r0, [sp, #0x18]
700aa3cc: f500 609f    	add.w	r0, r0, #0x4f8
700aa3d0: f001 fd8e    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x1b1c
;     return;
700aa3d4: b008         	add	sp, #0x20
700aa3d6: bd80         	pop	{r7, pc}
		...

700aa3e0 <SOC_controlModuleLockMMR>:
; {
700aa3e0: b580         	push	{r7, lr}
700aa3e2: b086         	sub	sp, #0x18
700aa3e4: 9005         	str	r0, [sp, #0x14]
700aa3e6: 9104         	str	r1, [sp, #0x10]
;     if(SOC_DOMAIN_ID_MAIN == domainId)
700aa3e8: 9805         	ldr	r0, [sp, #0x14]
700aa3ea: b9d8         	cbnz	r0, 0x700aa424 <SOC_controlModuleLockMMR+0x44> @ imm = #0x36
700aa3ec: e7ff         	b	0x700aa3ee <SOC_controlModuleLockMMR+0xe> @ imm = #-0x2
700aa3ee: f04f 4086    	mov.w	r0, #0x43000000
700aa3f2: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_CTRL_MMR0_CFG0_BASE);
700aa3f4: 9101         	str	r1, [sp, #0x4]
700aa3f6: f7fb fc0b    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x47ea
700aa3fa: 9901         	ldr	r1, [sp, #0x4]
700aa3fc: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MAIN_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700aa3fe: 9803         	ldr	r0, [sp, #0xc]
700aa400: 9a04         	ldr	r2, [sp, #0x10]
700aa402: eb00 3082    	add.w	r0, r0, r2, lsl #14
700aa406: f241 0208    	movw	r2, #0x1008
700aa40a: 4410         	add	r0, r2
700aa40c: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700aa40e: 9802         	ldr	r0, [sp, #0x8]
700aa410: f005 fb76    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0x56ec
700aa414: 9901         	ldr	r1, [sp, #0x4]
;         kickAddr++;
700aa416: 9802         	ldr	r0, [sp, #0x8]
700aa418: 3004         	adds	r0, #0x4
700aa41a: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700aa41c: 9802         	ldr	r0, [sp, #0x8]
700aa41e: f005 fb6f    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0x56de
;     }
700aa422: e7ff         	b	0x700aa424 <SOC_controlModuleLockMMR+0x44> @ imm = #-0x2
;     if(SOC_DOMAIN_ID_MCU == domainId)
700aa424: 9805         	ldr	r0, [sp, #0x14]
700aa426: 2801         	cmp	r0, #0x1
700aa428: d11b         	bne	0x700aa462 <SOC_controlModuleLockMMR+0x82> @ imm = #0x36
700aa42a: e7ff         	b	0x700aa42c <SOC_controlModuleLockMMR+0x4c> @ imm = #-0x2
700aa42c: f04f 608a    	mov.w	r0, #0x4500000
700aa430: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_CTRL_MMR0_CFG0_BASE);
700aa432: 9100         	str	r1, [sp]
700aa434: f7fb fbec    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x4828
700aa438: 9900         	ldr	r1, [sp]
700aa43a: 9003         	str	r0, [sp, #0xc]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_CTRL_MMR_LOCKn_KICK0_OFFSET(partition));
700aa43c: 9803         	ldr	r0, [sp, #0xc]
700aa43e: 9a04         	ldr	r2, [sp, #0x10]
700aa440: eb00 3082    	add.w	r0, r0, r2, lsl #14
700aa444: f241 0208    	movw	r2, #0x1008
700aa448: 4410         	add	r0, r2
700aa44a: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700aa44c: 9802         	ldr	r0, [sp, #0x8]
700aa44e: f005 fb57    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0x56ae
700aa452: 9900         	ldr	r1, [sp]
;         kickAddr++;
700aa454: 9802         	ldr	r0, [sp, #0x8]
700aa456: 3004         	adds	r0, #0x4
700aa458: 9002         	str	r0, [sp, #0x8]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700aa45a: 9802         	ldr	r0, [sp, #0x8]
700aa45c: f005 fb50    	bl	0x700afb00 <CSL_REG32_WR_RAW> @ imm = #0x56a0
;     }
700aa460: e7ff         	b	0x700aa462 <SOC_controlModuleLockMMR+0x82> @ imm = #-0x2
;     return;
700aa462: b006         	add	sp, #0x18
700aa464: bd80         	pop	{r7, pc}
		...
700aa46e: 0000         	movs	r0, r0

700aa470 <UART_lld_flushTxFifo>:
; {
700aa470: b580         	push	{r7, lr}
700aa472: b088         	sub	sp, #0x20
700aa474: 9007         	str	r0, [sp, #0x1c]
700aa476: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700aa478: 9006         	str	r0, [sp, #0x18]
700aa47a: f640 31b8    	movw	r1, #0xbb8
;     uint32_t            timeout = UART_TRANSMITEMPTY_TRIALCOUNT;
700aa47e: 9102         	str	r1, [sp, #0x8]
;     uint32_t            timeoutElapsed  = FALSE;
700aa480: 9001         	str	r0, [sp, #0x4]
;     if (NULL_PTR != hUart)
700aa482: 9807         	ldr	r0, [sp, #0x1c]
700aa484: b380         	cbz	r0, 0x700aa4e8 <UART_lld_flushTxFifo+0x78> @ imm = #0x60
700aa486: e7ff         	b	0x700aa488 <UART_lld_flushTxFifo+0x18> @ imm = #-0x2
;         hUartInit = hUart->hUartInit;
700aa488: 9807         	ldr	r0, [sp, #0x1c]
700aa48a: 6840         	ldr	r0, [r0, #0x4]
700aa48c: 9000         	str	r0, [sp]
;         startTicks = hUartInit->clockP_get();
700aa48e: 9800         	ldr	r0, [sp]
700aa490: 6d40         	ldr	r0, [r0, #0x54]
700aa492: 4780         	blx	r0
700aa494: 9004         	str	r0, [sp, #0x10]
;         while (FALSE == timeoutElapsed)
700aa496: e7ff         	b	0x700aa498 <UART_lld_flushTxFifo+0x28> @ imm = #-0x2
700aa498: 9801         	ldr	r0, [sp, #0x4]
700aa49a: b9e0         	cbnz	r0, 0x700aa4d6 <UART_lld_flushTxFifo+0x66> @ imm = #0x38
700aa49c: e7ff         	b	0x700aa49e <UART_lld_flushTxFifo+0x2e> @ imm = #-0x2
;             isTxFifoEmpty = UART_spaceAvail(hUart->baseAddr);
700aa49e: 9807         	ldr	r0, [sp, #0x1c]
700aa4a0: 6800         	ldr	r0, [r0]
700aa4a2: f003 fd0d    	bl	0x700adec0 <UART_spaceAvail> @ imm = #0x3a1a
700aa4a6: 9005         	str	r0, [sp, #0x14]
;             if ((uint32_t) TRUE == isTxFifoEmpty)
700aa4a8: 9805         	ldr	r0, [sp, #0x14]
700aa4aa: 2801         	cmp	r0, #0x1
700aa4ac: d101         	bne	0x700aa4b2 <UART_lld_flushTxFifo+0x42> @ imm = #0x2
700aa4ae: e7ff         	b	0x700aa4b0 <UART_lld_flushTxFifo+0x40> @ imm = #-0x2
;                 break;
700aa4b0: e011         	b	0x700aa4d6 <UART_lld_flushTxFifo+0x66> @ imm = #0x22
;             elapsedTicks = hUartInit->clockP_get() - startTicks;
700aa4b2: 9800         	ldr	r0, [sp]
700aa4b4: 6d40         	ldr	r0, [r0, #0x54]
700aa4b6: 4780         	blx	r0
700aa4b8: 9904         	ldr	r1, [sp, #0x10]
700aa4ba: 1a40         	subs	r0, r0, r1
700aa4bc: 9003         	str	r0, [sp, #0xc]
;             if (elapsedTicks >= timeout)
700aa4be: 9803         	ldr	r0, [sp, #0xc]
700aa4c0: 9902         	ldr	r1, [sp, #0x8]
700aa4c2: 4288         	cmp	r0, r1
700aa4c4: d303         	blo	0x700aa4ce <UART_lld_flushTxFifo+0x5e> @ imm = #0x6
700aa4c6: e7ff         	b	0x700aa4c8 <UART_lld_flushTxFifo+0x58> @ imm = #-0x2
700aa4c8: 2001         	movs	r0, #0x1
;                 timeoutElapsed = TRUE;
700aa4ca: 9001         	str	r0, [sp, #0x4]
;             }
700aa4cc: e002         	b	0x700aa4d4 <UART_lld_flushTxFifo+0x64> @ imm = #0x4
;                 TaskP_yield();
700aa4ce: f005 fc3f    	bl	0x700afd50 <TaskP_yield> @ imm = #0x587e
700aa4d2: e7ff         	b	0x700aa4d4 <UART_lld_flushTxFifo+0x64> @ imm = #-0x2
;         while (FALSE == timeoutElapsed)
700aa4d4: e7e0         	b	0x700aa498 <UART_lld_flushTxFifo+0x28> @ imm = #-0x40
;         if(TRUE == timeoutElapsed)
700aa4d6: 9801         	ldr	r0, [sp, #0x4]
700aa4d8: 2801         	cmp	r0, #0x1
700aa4da: d104         	bne	0x700aa4e6 <UART_lld_flushTxFifo+0x76> @ imm = #0x8
700aa4dc: e7ff         	b	0x700aa4de <UART_lld_flushTxFifo+0x6e> @ imm = #-0x2
700aa4de: f06f 0001    	mvn	r0, #0x1
;             status = UART_TRANSFER_TIMEOUT;
700aa4e2: 9006         	str	r0, [sp, #0x18]
;         }
700aa4e4: e7ff         	b	0x700aa4e6 <UART_lld_flushTxFifo+0x76> @ imm = #-0x2
;     }
700aa4e6: e003         	b	0x700aa4f0 <UART_lld_flushTxFifo+0x80> @ imm = #0x6
700aa4e8: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700aa4ec: 9006         	str	r0, [sp, #0x18]
700aa4ee: e7ff         	b	0x700aa4f0 <UART_lld_flushTxFifo+0x80> @ imm = #-0x2
;     return status;
700aa4f0: 9806         	ldr	r0, [sp, #0x18]
700aa4f2: b008         	add	sp, #0x20
700aa4f4: bd80         	pop	{r7, pc}
		...
700aa4fe: 0000         	movs	r0, r0

700aa500 <UART_tcrTlrBitValRestore>:
; {
700aa500: b580         	push	{r7, lr}
700aa502: b088         	sub	sp, #0x20
700aa504: 9007         	str	r0, [sp, #0x1c]
700aa506: 9106         	str	r1, [sp, #0x18]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700aa508: 9807         	ldr	r0, [sp, #0x1c]
700aa50a: 21bf         	movs	r1, #0xbf
700aa50c: 9101         	str	r1, [sp, #0x4]
700aa50e: f002 f937    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x226e
700aa512: 9004         	str	r0, [sp, #0x10]
;     enhanFnBitVal = HW_RD_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN);
700aa514: 9807         	ldr	r0, [sp, #0x1c]
700aa516: 3008         	adds	r0, #0x8
700aa518: 2110         	movs	r1, #0x10
700aa51a: 9102         	str	r1, [sp, #0x8]
700aa51c: 2204         	movs	r2, #0x4
700aa51e: 9203         	str	r2, [sp, #0xc]
700aa520: f004 ff0e    	bl	0x700af340 <HW_RD_FIELD32_RAW> @ imm = #0x4e1c
700aa524: 9902         	ldr	r1, [sp, #0x8]
700aa526: 9a03         	ldr	r2, [sp, #0xc]
700aa528: 9005         	str	r0, [sp, #0x14]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700aa52a: 9807         	ldr	r0, [sp, #0x1c]
700aa52c: 3008         	adds	r0, #0x8
700aa52e: 2301         	movs	r3, #0x1
700aa530: f004 f8be    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x417c
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa534: 9807         	ldr	r0, [sp, #0x1c]
700aa536: 300c         	adds	r0, #0xc
700aa538: 9904         	ldr	r1, [sp, #0x10]
700aa53a: f005 fb21    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x5642
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700aa53e: 9807         	ldr	r0, [sp, #0x1c]
700aa540: 2180         	movs	r1, #0x80
700aa542: f002 f91d    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x223a
700aa546: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_MCR, UART_MCR_TCR_TLR, tcrTlrBitVal);
700aa548: 9807         	ldr	r0, [sp, #0x1c]
700aa54a: 3010         	adds	r0, #0x10
700aa54c: 9b06         	ldr	r3, [sp, #0x18]
700aa54e: 2140         	movs	r1, #0x40
700aa550: 2206         	movs	r2, #0x6
700aa552: f004 f8ad    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x415a
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa556: 9807         	ldr	r0, [sp, #0x1c]
700aa558: 300c         	adds	r0, #0xc
700aa55a: 9904         	ldr	r1, [sp, #0x10]
700aa55c: f005 fb10    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x5620
700aa560: 9901         	ldr	r1, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700aa562: 9807         	ldr	r0, [sp, #0x1c]
700aa564: f002 f90c    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0x2218
700aa568: 9902         	ldr	r1, [sp, #0x8]
700aa56a: 9a03         	ldr	r2, [sp, #0xc]
700aa56c: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN, enhanFnBitVal);
700aa56e: 9807         	ldr	r0, [sp, #0x1c]
700aa570: 3008         	adds	r0, #0x8
700aa572: 9b05         	ldr	r3, [sp, #0x14]
700aa574: f004 f89c    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x4138
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700aa578: 9807         	ldr	r0, [sp, #0x1c]
700aa57a: 300c         	adds	r0, #0xc
700aa57c: 9904         	ldr	r1, [sp, #0x10]
700aa57e: f005 faff    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x55fe
; }
700aa582: b008         	add	sp, #0x20
700aa584: bd80         	pop	{r7, pc}
		...
700aa58e: 0000         	movs	r0, r0

700aa590 <prvInsertTimerInActiveList>:
;     {
700aa590: b580         	push	{r7, lr}
700aa592: b086         	sub	sp, #0x18
700aa594: 9005         	str	r0, [sp, #0x14]
700aa596: 9104         	str	r1, [sp, #0x10]
700aa598: 9203         	str	r2, [sp, #0xc]
700aa59a: 9302         	str	r3, [sp, #0x8]
700aa59c: 2000         	movs	r0, #0x0
;         BaseType_t xProcessTimerNow = pdFALSE;
700aa59e: 9001         	str	r0, [sp, #0x4]
;         listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
700aa5a0: 9804         	ldr	r0, [sp, #0x10]
700aa5a2: 9905         	ldr	r1, [sp, #0x14]
700aa5a4: 6048         	str	r0, [r1, #0x4]
;         listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
700aa5a6: 9805         	ldr	r0, [sp, #0x14]
700aa5a8: 6100         	str	r0, [r0, #0x10]
;         if( xNextExpiryTime <= xTimeNow )
700aa5aa: 9804         	ldr	r0, [sp, #0x10]
700aa5ac: 9903         	ldr	r1, [sp, #0xc]
700aa5ae: 4288         	cmp	r0, r1
700aa5b0: d816         	bhi	0x700aa5e0 <prvInsertTimerInActiveList+0x50> @ imm = #0x2c
700aa5b2: e7ff         	b	0x700aa5b4 <prvInsertTimerInActiveList+0x24> @ imm = #-0x2
;             if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
700aa5b4: 9803         	ldr	r0, [sp, #0xc]
700aa5b6: 9902         	ldr	r1, [sp, #0x8]
700aa5b8: 1a40         	subs	r0, r0, r1
700aa5ba: 9905         	ldr	r1, [sp, #0x14]
700aa5bc: 6989         	ldr	r1, [r1, #0x18]
700aa5be: 4288         	cmp	r0, r1
700aa5c0: d303         	blo	0x700aa5ca <prvInsertTimerInActiveList+0x3a> @ imm = #0x6
700aa5c2: e7ff         	b	0x700aa5c4 <prvInsertTimerInActiveList+0x34> @ imm = #-0x2
700aa5c4: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700aa5c6: 9001         	str	r0, [sp, #0x4]
;             }
700aa5c8: e009         	b	0x700aa5de <prvInsertTimerInActiveList+0x4e> @ imm = #0x12
;                 vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
700aa5ca: f245 20a8    	movw	r0, #0x52a8
700aa5ce: f2c7 0008    	movt	r0, #0x7008
700aa5d2: 6800         	ldr	r0, [r0]
700aa5d4: 9905         	ldr	r1, [sp, #0x14]
700aa5d6: 3104         	adds	r1, #0x4
700aa5d8: f001 f90a    	bl	0x700ab7f0 <vListInsert> @ imm = #0x1214
700aa5dc: e7ff         	b	0x700aa5de <prvInsertTimerInActiveList+0x4e> @ imm = #-0x2
;         }
700aa5de: e017         	b	0x700aa610 <prvInsertTimerInActiveList+0x80> @ imm = #0x2e
;             if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
700aa5e0: 9803         	ldr	r0, [sp, #0xc]
700aa5e2: 9902         	ldr	r1, [sp, #0x8]
700aa5e4: 4288         	cmp	r0, r1
700aa5e6: d208         	bhs	0x700aa5fa <prvInsertTimerInActiveList+0x6a> @ imm = #0x10
700aa5e8: e7ff         	b	0x700aa5ea <prvInsertTimerInActiveList+0x5a> @ imm = #-0x2
700aa5ea: 9804         	ldr	r0, [sp, #0x10]
700aa5ec: 9902         	ldr	r1, [sp, #0x8]
700aa5ee: 4288         	cmp	r0, r1
700aa5f0: d303         	blo	0x700aa5fa <prvInsertTimerInActiveList+0x6a> @ imm = #0x6
700aa5f2: e7ff         	b	0x700aa5f4 <prvInsertTimerInActiveList+0x64> @ imm = #-0x2
700aa5f4: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
700aa5f6: 9001         	str	r0, [sp, #0x4]
;             }
700aa5f8: e009         	b	0x700aa60e <prvInsertTimerInActiveList+0x7e> @ imm = #0x12
;                 vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
700aa5fa: f245 209c    	movw	r0, #0x529c
700aa5fe: f2c7 0008    	movt	r0, #0x7008
700aa602: 6800         	ldr	r0, [r0]
700aa604: 9905         	ldr	r1, [sp, #0x14]
700aa606: 3104         	adds	r1, #0x4
700aa608: f001 f8f2    	bl	0x700ab7f0 <vListInsert> @ imm = #0x11e4
700aa60c: e7ff         	b	0x700aa60e <prvInsertTimerInActiveList+0x7e> @ imm = #-0x2
700aa60e: e7ff         	b	0x700aa610 <prvInsertTimerInActiveList+0x80> @ imm = #-0x2
;         return xProcessTimerNow;
700aa610: 9801         	ldr	r0, [sp, #0x4]
700aa612: b006         	add	sp, #0x18
700aa614: bd80         	pop	{r7, pc}
		...
700aa61e: 0000         	movs	r0, r0

700aa620 <prvProcessTimerOrBlockTask>:
;     {
700aa620: b580         	push	{r7, lr}
700aa622: b084         	sub	sp, #0x10
700aa624: 9003         	str	r0, [sp, #0xc]
700aa626: 9102         	str	r1, [sp, #0x8]
;         vTaskSuspendAll();
700aa628: f005 faca    	bl	0x700afbc0 <vTaskSuspendAll> @ imm = #0x5594
700aa62c: 4668         	mov	r0, sp
;             xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
700aa62e: f003 f9d7    	bl	0x700ad9e0 <prvSampleTimeNow> @ imm = #0x33ae
700aa632: 9001         	str	r0, [sp, #0x4]
;             if( xTimerListsWereSwitched == pdFALSE )
700aa634: 9800         	ldr	r0, [sp]
700aa636: bb88         	cbnz	r0, 0x700aa69c <prvProcessTimerOrBlockTask+0x7c> @ imm = #0x62
700aa638: e7ff         	b	0x700aa63a <prvProcessTimerOrBlockTask+0x1a> @ imm = #-0x2
;                 if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
700aa63a: 9802         	ldr	r0, [sp, #0x8]
700aa63c: b960         	cbnz	r0, 0x700aa658 <prvProcessTimerOrBlockTask+0x38> @ imm = #0x18
700aa63e: e7ff         	b	0x700aa640 <prvProcessTimerOrBlockTask+0x20> @ imm = #-0x2
700aa640: 9803         	ldr	r0, [sp, #0xc]
700aa642: 9901         	ldr	r1, [sp, #0x4]
700aa644: 4288         	cmp	r0, r1
700aa646: d807         	bhi	0x700aa658 <prvProcessTimerOrBlockTask+0x38> @ imm = #0xe
700aa648: e7ff         	b	0x700aa64a <prvProcessTimerOrBlockTask+0x2a> @ imm = #-0x2
;                     ( void ) xTaskResumeAll();
700aa64a: f7f7 fe21    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0x83be
;                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
700aa64e: 9803         	ldr	r0, [sp, #0xc]
700aa650: 9901         	ldr	r1, [sp, #0x4]
700aa652: f000 fe55    	bl	0x700ab300 <prvProcessExpiredTimer> @ imm = #0xcaa
;                 }
700aa656: e020         	b	0x700aa69a <prvProcessTimerOrBlockTask+0x7a> @ imm = #0x40
;                     if( xListWasEmpty != pdFALSE )
700aa658: 9802         	ldr	r0, [sp, #0x8]
700aa65a: b158         	cbz	r0, 0x700aa674 <prvProcessTimerOrBlockTask+0x54> @ imm = #0x16
700aa65c: e7ff         	b	0x700aa65e <prvProcessTimerOrBlockTask+0x3e> @ imm = #-0x2
;                         xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
700aa65e: f245 20a8    	movw	r0, #0x52a8
700aa662: f2c7 0008    	movt	r0, #0x7008
700aa666: 6800         	ldr	r0, [r0]
700aa668: 6800         	ldr	r0, [r0]
700aa66a: fab0 f080    	clz	r0, r0
700aa66e: 0940         	lsrs	r0, r0, #0x5
700aa670: 9002         	str	r0, [sp, #0x8]
;                     }
700aa672: e7ff         	b	0x700aa674 <prvProcessTimerOrBlockTask+0x54> @ imm = #-0x2
;                     vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
700aa674: f642 2048    	movw	r0, #0x2a48
700aa678: f2c7 000b    	movt	r0, #0x700b
700aa67c: 6800         	ldr	r0, [r0]
700aa67e: 9903         	ldr	r1, [sp, #0xc]
700aa680: 9a01         	ldr	r2, [sp, #0x4]
700aa682: 1a89         	subs	r1, r1, r2
700aa684: 9a02         	ldr	r2, [sp, #0x8]
700aa686: f001 fbfb    	bl	0x700abe80 <vQueueWaitForMessageRestricted> @ imm = #0x17f6
;                     if( xTaskResumeAll() == pdFALSE )
700aa68a: f7f7 fe01    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0x83fe
700aa68e: b910         	cbnz	r0, 0x700aa696 <prvProcessTimerOrBlockTask+0x76> @ imm = #0x4
700aa690: e7ff         	b	0x700aa692 <prvProcessTimerOrBlockTask+0x72> @ imm = #-0x2
;                         portYIELD_WITHIN_API();
700aa692: df00         	svc	#0x0
;                     }
700aa694: e000         	b	0x700aa698 <prvProcessTimerOrBlockTask+0x78> @ imm = #0x0
700aa696: e7ff         	b	0x700aa698 <prvProcessTimerOrBlockTask+0x78> @ imm = #-0x2
700aa698: e7ff         	b	0x700aa69a <prvProcessTimerOrBlockTask+0x7a> @ imm = #-0x2
;             }
700aa69a: e002         	b	0x700aa6a2 <prvProcessTimerOrBlockTask+0x82> @ imm = #0x4
;                 ( void ) xTaskResumeAll();
700aa69c: f7f7 fdf8    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0x8410
700aa6a0: e7ff         	b	0x700aa6a2 <prvProcessTimerOrBlockTask+0x82> @ imm = #-0x2
;     }
700aa6a2: b004         	add	sp, #0x10
700aa6a4: bd80         	pop	{r7, pc}
		...
700aa6ae: 0000         	movs	r0, r0

700aa6b0 <PowerClock_init>:
; {
700aa6b0: b570         	push	{r4, r5, r6, lr}
700aa6b2: b082         	sub	sp, #0x8
;     while(gSocModules[i]!=SOC_MODULES_END)
700aa6b4: f642 1194    	movw	r1, #0x2994
700aa6b8: f2c7 010b    	movt	r1, #0x700b
700aa6bc: 6808         	ldr	r0, [r1]
700aa6be: 1c42         	adds	r2, r0, #0x1
700aa6c0: d013         	beq	0x700aa6ea <PowerClock_init+0x3a> @ imm = #0x26
700aa6c2: 1d0c         	adds	r4, r1, #0x4
700aa6c4: bf00         	nop
700aa6c6: bf00         	nop
700aa6c8: bf00         	nop
700aa6ca: bf00         	nop
700aa6cc: bf00         	nop
700aa6ce: bf00         	nop
;         status = SOC_moduleClockEnable(gSocModules[i], 1);
700aa6d0: f04f 0101    	mov.w	r1, #0x1
700aa6d4: f7ff fa7c    	bl	0x700a9bd0 <SOC_moduleClockEnable> @ imm = #-0xb08
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700aa6d8: fab0 f080    	clz	r0, r0
700aa6dc: 0940         	lsrs	r0, r0, #0x5
700aa6de: f006 fdff    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x6bfe
;     while(gSocModules[i]!=SOC_MODULES_END)
700aa6e2: f854 0b04    	ldr	r0, [r4], #4
700aa6e6: 1c41         	adds	r1, r0, #0x1
700aa6e8: d1f2         	bne	0x700aa6d0 <PowerClock_init+0x20> @ imm = #-0x1c
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700aa6ea: f642 01e0    	movw	r1, #0x28e0
700aa6ee: f2c7 010b    	movt	r1, #0x700b
700aa6f2: 6808         	ldr	r0, [r1]
700aa6f4: 1c42         	adds	r2, r0, #0x1
700aa6f6: d01b         	beq	0x700aa730 <PowerClock_init+0x80> @ imm = #0x36
700aa6f8: f101 0408    	add.w	r4, r1, #0x8
700aa6fc: 2600         	movs	r6, #0x0
700aa6fe: e00c         	b	0x700aa71a <PowerClock_init+0x6a> @ imm = #0x18
;             status = SOC_moduleSetClockFrequency(
700aa700: 461a         	mov	r2, r3
700aa702: 2300         	movs	r3, #0x0
700aa704: f7f5 f9a4    	bl	0x7009fa50 <SOC_moduleSetClockFrequency> @ imm = #-0xacb8
;         DebugP_assertNoLog(status == SystemP_SUCCESS);
700aa708: fab0 f080    	clz	r0, r0
700aa70c: 0940         	lsrs	r0, r0, #0x5
700aa70e: f006 fde7    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x6bce
;     while(gSocModulesClockFrequency[i].moduleId!=SOC_MODULES_END)
700aa712: 68a0         	ldr	r0, [r4, #0x8]
700aa714: 3410         	adds	r4, #0x10
700aa716: 1c41         	adds	r1, r0, #0x1
700aa718: d00a         	beq	0x700aa730 <PowerClock_init+0x80> @ imm = #0x14
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700aa71a: 6862         	ldr	r2, [r4, #0x4]
700aa71c: f854 1c04    	ldr	r1, [r4, #-4]
700aa720: 6823         	ldr	r3, [r4]
;         if (gSocModulesClockFrequency[i].clkParentId != -1)
700aa722: 1c55         	adds	r5, r2, #0x1
700aa724: d0ec         	beq	0x700aa700 <PowerClock_init+0x50> @ imm = #-0x28
;             status = SOC_moduleSetClockFrequencyWithParent(
700aa726: e9cd 3600    	strd	r3, r6, [sp]
700aa72a: f7f5 fa71    	bl	0x7009fc10 <SOC_moduleSetClockFrequencyWithParent> @ imm = #-0xab1e
700aa72e: e7eb         	b	0x700aa708 <PowerClock_init+0x58> @ imm = #-0x2a
; }
700aa730: b002         	add	sp, #0x8
700aa732: bd70         	pop	{r4, r5, r6, pc}
		...

700aa740 <CSL_udmapCppi5SetReturnPolicy>:
; {
700aa740: b085         	sub	sp, #0x14
700aa742: f8dd c018    	ldr.w	r12, [sp, #0x18]
700aa746: f8dd c014    	ldr.w	r12, [sp, #0x14]
700aa74a: 9004         	str	r0, [sp, #0x10]
700aa74c: 9103         	str	r1, [sp, #0xc]
700aa74e: 9202         	str	r2, [sp, #0x8]
700aa750: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700aa752: 9803         	ldr	r0, [sp, #0xc]
700aa754: 2803         	cmp	r0, #0x3
700aa756: d108         	bne	0x700aa76a <CSL_udmapCppi5SetReturnPolicy+0x2a> @ imm = #0x10
700aa758: e7ff         	b	0x700aa75a <CSL_udmapCppi5SetReturnPolicy+0x1a> @ imm = #-0x2
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700aa75a: 9905         	ldr	r1, [sp, #0x14]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETQ, retQnum ) ;
700aa75c: f8bd 0018    	ldrh.w	r0, [sp, #0x18]
;             CSL_FMK( UDMAP_CPPI5_TRPD_RETINFO_RETPOLICY, retPushPolicy )    |
700aa760: f361 4010    	bfi	r0, r1, #16, #1
;         ((CSL_UdmapCppi5TRPD *)pDesc)->retInfo =
700aa764: 9904         	ldr	r1, [sp, #0x10]
700aa766: 6088         	str	r0, [r1, #0x8]
;     }
700aa768: e029         	b	0x700aa7be <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #0x52
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2;
700aa76a: 9804         	ldr	r0, [sp, #0x10]
700aa76c: 6880         	ldr	r0, [r0, #0x8]
700aa76e: 9000         	str	r0, [sp]
;         if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO )
700aa770: 9803         	ldr	r0, [sp, #0xc]
700aa772: 2802         	cmp	r0, #0x2
700aa774: d105         	bne	0x700aa782 <CSL_udmapCppi5SetReturnPolicy+0x42> @ imm = #0xa
700aa776: e7ff         	b	0x700aa778 <CSL_udmapCppi5SetReturnPolicy+0x38> @ imm = #-0x2
;             v &= (CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO2_DATA_OFFSET_MASK);
700aa778: 9800         	ldr	r0, [sp]
700aa77a: f36f 0011    	bfc	r0, #0, #18
700aa77e: 9000         	str	r0, [sp]
;         }
700aa780: e00b         	b	0x700aa79a <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #0x16
;             v &= CSL_UDMAP_CPPI5_PD_PKTINFO2_PKTTYPE_MASK;
700aa782: 9800         	ldr	r0, [sp]
700aa784: f000 4078    	and	r0, r0, #0xf8000000
700aa788: 9000         	str	r0, [sp]
;             v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPOLICY, retPolicy );
700aa78a: 9802         	ldr	r0, [sp, #0x8]
700aa78c: f000 0101    	and	r1, r0, #0x1
700aa790: 9800         	ldr	r0, [sp]
700aa792: ea40 4081    	orr.w	r0, r0, r1, lsl #18
700aa796: 9000         	str	r0, [sp]
700aa798: e7ff         	b	0x700aa79a <CSL_udmapCppi5SetReturnPolicy+0x5a> @ imm = #-0x2
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa79a: 9901         	ldr	r1, [sp, #0x4]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700aa79c: 9a05         	ldr	r2, [sp, #0x14]
700aa79e: f44f 3080    	mov.w	r0, #0x10000
700aa7a2: ea00 4002    	and.w	r0, r0, r2, lsl #16
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa7a6: f361 4051    	bfi	r0, r1, #17, #1
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETQ, retQnum );
700aa7aa: f8bd 1018    	ldrh.w	r1, [sp, #0x18]
;                 CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_RETPUSHPOLICY, retPushPolicy ) |
700aa7ae: 4401         	add	r1, r0
;         v |=    CSL_FMK( UDMAP_CPPI5_PD_PKTINFO2_EARLYRET, earlyReturn)         |
700aa7b0: 9800         	ldr	r0, [sp]
700aa7b2: 4308         	orrs	r0, r1
700aa7b4: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo2 = v;
700aa7b6: 9800         	ldr	r0, [sp]
700aa7b8: 9904         	ldr	r1, [sp, #0x10]
700aa7ba: 6088         	str	r0, [r1, #0x8]
700aa7bc: e7ff         	b	0x700aa7be <CSL_udmapCppi5SetReturnPolicy+0x7e> @ imm = #-0x2
; }
700aa7be: b005         	add	sp, #0x14
700aa7c0: 4770         	bx	lr
		...
700aa7ce: 0000         	movs	r0, r0

700aa7d0 <SemaphoreP_pend>:
; {
700aa7d0: b580         	push	{r7, lr}
700aa7d2: b086         	sub	sp, #0x18
700aa7d4: 9005         	str	r0, [sp, #0x14]
700aa7d6: 9104         	str	r1, [sp, #0x10]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700aa7d8: 9805         	ldr	r0, [sp, #0x14]
700aa7da: 9003         	str	r0, [sp, #0xc]
700aa7dc: 2000         	movs	r0, #0x0
;     uint32_t isSemTaken = 0U;
700aa7de: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700aa7e0: 9803         	ldr	r0, [sp, #0xc]
700aa7e2: 6d40         	ldr	r0, [r0, #0x54]
700aa7e4: b180         	cbz	r0, 0x700aa808 <SemaphoreP_pend+0x38> @ imm = #0x20
700aa7e6: e7ff         	b	0x700aa7e8 <SemaphoreP_pend+0x18> @ imm = #-0x2
;         if(HwiP_inISR() == 0U )
700aa7e8: f005 fdda    	bl	0x700b03a0 <HwiP_inISR> @ imm = #0x5bb4
700aa7ec: b938         	cbnz	r0, 0x700aa7fe <SemaphoreP_pend+0x2e> @ imm = #0xe
700aa7ee: e7ff         	b	0x700aa7f0 <SemaphoreP_pend+0x20> @ imm = #-0x2
;             isSemTaken =(uint32_t) xSemaphoreTakeRecursive(pSemaphore->semHndl, timeout);
700aa7f0: 9803         	ldr	r0, [sp, #0xc]
700aa7f2: 6d00         	ldr	r0, [r0, #0x50]
700aa7f4: 9904         	ldr	r1, [sp, #0x10]
700aa7f6: f002 fc93    	bl	0x700ad120 <xQueueTakeMutexRecursive> @ imm = #0x2926
700aa7fa: 9002         	str	r0, [sp, #0x8]
;         }
700aa7fc: e003         	b	0x700aa806 <SemaphoreP_pend+0x36> @ imm = #0x6
700aa7fe: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700aa800: f006 fd6e    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x6adc
700aa804: e7ff         	b	0x700aa806 <SemaphoreP_pend+0x36> @ imm = #-0x2
;     }
700aa806: e017         	b	0x700aa838 <SemaphoreP_pend+0x68> @ imm = #0x2e
;         if( HwiP_inISR() != 0U )
700aa808: f005 fdca    	bl	0x700b03a0 <HwiP_inISR> @ imm = #0x5b94
700aa80c: b160         	cbz	r0, 0x700aa828 <SemaphoreP_pend+0x58> @ imm = #0x18
700aa80e: e7ff         	b	0x700aa810 <SemaphoreP_pend+0x40> @ imm = #-0x2
700aa810: 2100         	movs	r1, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700aa812: 9100         	str	r1, [sp]
;             isSemTaken = (uint32_t) xSemaphoreTakeFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700aa814: 9803         	ldr	r0, [sp, #0xc]
700aa816: 6d00         	ldr	r0, [r0, #0x50]
700aa818: 466a         	mov	r2, sp
700aa81a: f7fe fe19    	bl	0x700a9450 <xQueueReceiveFromISR> @ imm = #-0x13ce
700aa81e: 9002         	str	r0, [sp, #0x8]
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700aa820: 9800         	ldr	r0, [sp]
700aa822: f004 fedd    	bl	0x700af5e0 <vPortYeildFromISR> @ imm = #0x4dba
;         }
700aa826: e006         	b	0x700aa836 <SemaphoreP_pend+0x66> @ imm = #0xc
;             isSemTaken = (uint32_t) xSemaphoreTake(pSemaphore->semHndl, timeout);
700aa828: 9803         	ldr	r0, [sp, #0xc]
700aa82a: 6d00         	ldr	r0, [r0, #0x50]
700aa82c: 9904         	ldr	r1, [sp, #0x10]
700aa82e: f7f6 fe1f    	bl	0x700a1470 <xQueueSemaphoreTake> @ imm = #-0x93c2
700aa832: 9002         	str	r0, [sp, #0x8]
700aa834: e7ff         	b	0x700aa836 <SemaphoreP_pend+0x66> @ imm = #-0x2
700aa836: e7ff         	b	0x700aa838 <SemaphoreP_pend+0x68> @ imm = #-0x2
;     if(isSemTaken != 0U)
700aa838: 9802         	ldr	r0, [sp, #0x8]
700aa83a: b118         	cbz	r0, 0x700aa844 <SemaphoreP_pend+0x74> @ imm = #0x6
700aa83c: e7ff         	b	0x700aa83e <SemaphoreP_pend+0x6e> @ imm = #-0x2
700aa83e: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700aa840: 9001         	str	r0, [sp, #0x4]
;     }
700aa842: e003         	b	0x700aa84c <SemaphoreP_pend+0x7c> @ imm = #0x6
700aa844: f06f 0001    	mvn	r0, #0x1
;         status = SystemP_TIMEOUT;
700aa848: 9001         	str	r0, [sp, #0x4]
700aa84a: e7ff         	b	0x700aa84c <SemaphoreP_pend+0x7c> @ imm = #-0x2
;     return status;
700aa84c: 9801         	ldr	r0, [sp, #0x4]
700aa84e: b006         	add	sp, #0x18
700aa850: bd80         	pop	{r7, pc}
		...
700aa85e: 0000         	movs	r0, r0

700aa860 <Udma_chPair>:
; {
700aa860: b580         	push	{r7, lr}
700aa862: b088         	sub	sp, #0x20
700aa864: 9007         	str	r0, [sp, #0x1c]
700aa866: 2000         	movs	r0, #0x0
;     int32_t                 retVal = UDMA_SOK;
700aa868: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700aa86a: 9807         	ldr	r0, [sp, #0x1c]
700aa86c: 6e80         	ldr	r0, [r0, #0x68]
700aa86e: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa870: 9805         	ldr	r0, [sp, #0x14]
700aa872: 6800         	ldr	r0, [r0]
700aa874: 2801         	cmp	r0, #0x1
700aa876: d107         	bne	0x700aa888 <Udma_chPair+0x28> @ imm = #0xe
700aa878: e7ff         	b	0x700aa87a <Udma_chPair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700aa87a: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa87c: 7800         	ldrb	r0, [r0]
700aa87e: 0740         	lsls	r0, r0, #0x1d
700aa880: 2800         	cmp	r0, #0x0
700aa882: d501         	bpl	0x700aa888 <Udma_chPair+0x28> @ imm = #0x2
700aa884: e7ff         	b	0x700aa886 <Udma_chPair+0x26> @ imm = #-0x2
;     }
700aa886: e029         	b	0x700aa8dc <Udma_chPair+0x7c> @ imm = #0x52
;         rmPairReq.nav_id = drvHandle->devIdPsil;
700aa888: 9805         	ldr	r0, [sp, #0x14]
700aa88a: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700aa88e: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700aa890: 9807         	ldr	r0, [sp, #0x1c]
700aa892: 7800         	ldrb	r0, [r0]
700aa894: 07c0         	lsls	r0, r0, #0x1f
700aa896: b158         	cbz	r0, 0x700aa8b0 <Udma_chPair+0x50> @ imm = #0x16
700aa898: e7ff         	b	0x700aa89a <Udma_chPair+0x3a> @ imm = #-0x2
;             rmPairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700aa89a: 9807         	ldr	r0, [sp, #0x1c]
700aa89c: 6ec0         	ldr	r0, [r0, #0x6c]
700aa89e: 9905         	ldr	r1, [sp, #0x14]
700aa8a0: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700aa8a4: 4408         	add	r0, r1
700aa8a6: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->peerThreadId;
700aa8a8: 9807         	ldr	r0, [sp, #0x1c]
700aa8aa: 6fc0         	ldr	r0, [r0, #0x7c]
700aa8ac: 9004         	str	r0, [sp, #0x10]
;         }
700aa8ae: e00a         	b	0x700aa8c6 <Udma_chPair+0x66> @ imm = #0x14
;             rmPairReq.src_thread = chHandle->peerThreadId;
700aa8b0: 9807         	ldr	r0, [sp, #0x1c]
700aa8b2: 6fc0         	ldr	r0, [r0, #0x7c]
700aa8b4: 9003         	str	r0, [sp, #0xc]
;             rmPairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700aa8b6: 9807         	ldr	r0, [sp, #0x1c]
700aa8b8: 6f00         	ldr	r0, [r0, #0x70]
700aa8ba: 9905         	ldr	r1, [sp, #0x14]
700aa8bc: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700aa8c0: 4408         	add	r0, r1
700aa8c2: 9004         	str	r0, [sp, #0x10]
700aa8c4: e7ff         	b	0x700aa8c6 <Udma_chPair+0x66> @ imm = #-0x2
700aa8c6: 4668         	mov	r0, sp
700aa8c8: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilPair(&rmPairReq, UDMA_SCICLIENT_TIMEOUT);
700aa8cc: f002 f9b8    	bl	0x700acc40 <Sciclient_rmPsilPair> @ imm = #0x2370
700aa8d0: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700aa8d2: 9806         	ldr	r0, [sp, #0x18]
700aa8d4: b108         	cbz	r0, 0x700aa8da <Udma_chPair+0x7a> @ imm = #0x2
700aa8d6: e7ff         	b	0x700aa8d8 <Udma_chPair+0x78> @ imm = #-0x2
;         }
700aa8d8: e7ff         	b	0x700aa8da <Udma_chPair+0x7a> @ imm = #-0x2
700aa8da: e7ff         	b	0x700aa8dc <Udma_chPair+0x7c> @ imm = #-0x2
;     return (retVal);
700aa8dc: 9806         	ldr	r0, [sp, #0x18]
700aa8de: b008         	add	sp, #0x20
700aa8e0: bd80         	pop	{r7, pc}
		...
700aa8ee: 0000         	movs	r0, r0

700aa8f0 <Udma_chUnpair>:
; {
700aa8f0: b580         	push	{r7, lr}
700aa8f2: b088         	sub	sp, #0x20
700aa8f4: 9007         	str	r0, [sp, #0x1c]
700aa8f6: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700aa8f8: 9006         	str	r0, [sp, #0x18]
;     drvHandle = chHandle->drvHandle;
700aa8fa: 9807         	ldr	r0, [sp, #0x1c]
700aa8fc: 6e80         	ldr	r0, [r0, #0x68]
700aa8fe: 9005         	str	r0, [sp, #0x14]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa900: 9805         	ldr	r0, [sp, #0x14]
700aa902: 6800         	ldr	r0, [r0]
700aa904: 2801         	cmp	r0, #0x1
700aa906: d107         	bne	0x700aa918 <Udma_chUnpair+0x28> @ imm = #0xe
700aa908: e7ff         	b	0x700aa90a <Udma_chUnpair+0x1a> @ imm = #-0x2
;        ((chHandle->chType & UDMA_CH_FLAG_BLK_COPY) == UDMA_CH_FLAG_BLK_COPY))
700aa90a: 9807         	ldr	r0, [sp, #0x1c]
;     if((UDMA_INST_TYPE_LCDMA_BCDMA                 == drvHandle->instType) &&
700aa90c: 7800         	ldrb	r0, [r0]
700aa90e: 0740         	lsls	r0, r0, #0x1d
700aa910: 2800         	cmp	r0, #0x0
700aa912: d501         	bpl	0x700aa918 <Udma_chUnpair+0x28> @ imm = #0x2
700aa914: e7ff         	b	0x700aa916 <Udma_chUnpair+0x26> @ imm = #-0x2
;     }
700aa916: e029         	b	0x700aa96c <Udma_chUnpair+0x7c> @ imm = #0x52
;         rmUnpairReq.nav_id = drvHandle->devIdPsil;
700aa918: 9805         	ldr	r0, [sp, #0x14]
700aa91a: f8b0 00e4    	ldrh.w	r0, [r0, #0xe4]
700aa91e: 9002         	str	r0, [sp, #0x8]
;         if((chHandle->chType & UDMA_CH_FLAG_TX) == UDMA_CH_FLAG_TX)
700aa920: 9807         	ldr	r0, [sp, #0x1c]
700aa922: 7800         	ldrb	r0, [r0]
700aa924: 07c0         	lsls	r0, r0, #0x1f
700aa926: b158         	cbz	r0, 0x700aa940 <Udma_chUnpair+0x50> @ imm = #0x16
700aa928: e7ff         	b	0x700aa92a <Udma_chUnpair+0x3a> @ imm = #-0x2
;             rmUnpairReq.src_thread = chHandle->txChNum + drvHandle->udmapSrcThreadOffset;
700aa92a: 9807         	ldr	r0, [sp, #0x1c]
700aa92c: 6ec0         	ldr	r0, [r0, #0x6c]
700aa92e: 9905         	ldr	r1, [sp, #0x14]
700aa930: f8d1 10d4    	ldr.w	r1, [r1, #0xd4]
700aa934: 4408         	add	r0, r1
700aa936: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->peerThreadId;
700aa938: 9807         	ldr	r0, [sp, #0x1c]
700aa93a: 6fc0         	ldr	r0, [r0, #0x7c]
700aa93c: 9004         	str	r0, [sp, #0x10]
;         }
700aa93e: e00a         	b	0x700aa956 <Udma_chUnpair+0x66> @ imm = #0x14
;             rmUnpairReq.src_thread = chHandle->peerThreadId;
700aa940: 9807         	ldr	r0, [sp, #0x1c]
700aa942: 6fc0         	ldr	r0, [r0, #0x7c]
700aa944: 9003         	str	r0, [sp, #0xc]
;             rmUnpairReq.dst_thread = chHandle->rxChNum + drvHandle->udmapDestThreadOffset;
700aa946: 9807         	ldr	r0, [sp, #0x1c]
700aa948: 6f00         	ldr	r0, [r0, #0x70]
700aa94a: 9905         	ldr	r1, [sp, #0x14]
700aa94c: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700aa950: 4408         	add	r0, r1
700aa952: 9004         	str	r0, [sp, #0x10]
700aa954: e7ff         	b	0x700aa956 <Udma_chUnpair+0x66> @ imm = #-0x2
700aa956: 4668         	mov	r0, sp
700aa958: f04f 31ff    	mov.w	r1, #0xffffffff
;         retVal = Sciclient_rmPsilUnpair(&rmUnpairReq, UDMA_SCICLIENT_TIMEOUT);
700aa95c: f002 f9a0    	bl	0x700acca0 <Sciclient_rmPsilUnpair> @ imm = #0x2340
700aa960: 9006         	str	r0, [sp, #0x18]
;         if(CSL_PASS != retVal)
700aa962: 9806         	ldr	r0, [sp, #0x18]
700aa964: b108         	cbz	r0, 0x700aa96a <Udma_chUnpair+0x7a> @ imm = #0x2
700aa966: e7ff         	b	0x700aa968 <Udma_chUnpair+0x78> @ imm = #-0x2
;         }
700aa968: e7ff         	b	0x700aa96a <Udma_chUnpair+0x7a> @ imm = #-0x2
700aa96a: e7ff         	b	0x700aa96c <Udma_chUnpair+0x7c> @ imm = #-0x2
;     return (retVal);
700aa96c: 9806         	ldr	r0, [sp, #0x18]
700aa96e: b008         	add	sp, #0x20
700aa970: bd80         	pop	{r7, pc}
		...
700aa97e: 0000         	movs	r0, r0

700aa980 <UART_moduleReset>:
; {
700aa980: b580         	push	{r7, lr}
700aa982: b088         	sub	sp, #0x20
700aa984: 9007         	str	r0, [sp, #0x1c]
700aa986: 2000         	movs	r0, #0x0
;     uint32_t startTicks, elapsedTicks = 0;
700aa988: 9005         	str	r0, [sp, #0x14]
;     hUartInit = hUart->hUartInit;
700aa98a: 9807         	ldr	r0, [sp, #0x1c]
700aa98c: 6840         	ldr	r0, [r0, #0x4]
700aa98e: 9004         	str	r0, [sp, #0x10]
;     HW_WR_FIELD32(hUart->baseAddr + UART_SYSC, UART_SYSC_SOFTRESET,
700aa990: 9807         	ldr	r0, [sp, #0x1c]
700aa992: 6800         	ldr	r0, [r0]
700aa994: 3054         	adds	r0, #0x54
700aa996: 2102         	movs	r1, #0x2
700aa998: 2301         	movs	r3, #0x1
700aa99a: 461a         	mov	r2, r3
700aa99c: f003 fe88    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x3d10
;     startTicks = hUartInit->clockP_get();
700aa9a0: 9804         	ldr	r0, [sp, #0x10]
700aa9a2: 6d40         	ldr	r0, [r0, #0x54]
700aa9a4: 4780         	blx	r0
700aa9a6: 9006         	str	r0, [sp, #0x18]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aa9a8: e7ff         	b	0x700aa9aa <UART_moduleReset+0x2a> @ imm = #-0x2
700aa9aa: 9807         	ldr	r0, [sp, #0x1c]
700aa9ac: 6800         	ldr	r0, [r0]
700aa9ae: 3058         	adds	r0, #0x58
700aa9b0: 2101         	movs	r1, #0x1
700aa9b2: 2200         	movs	r2, #0x0
700aa9b4: 9202         	str	r2, [sp, #0x8]
700aa9b6: f004 fcc3    	bl	0x700af340 <HW_RD_FIELD32_RAW> @ imm = #0x4986
700aa9ba: 4601         	mov	r1, r0
700aa9bc: 9802         	ldr	r0, [sp, #0x8]
700aa9be: 9003         	str	r0, [sp, #0xc]
700aa9c0: b989         	cbnz	r1, 0x700aa9e6 <UART_moduleReset+0x66> @ imm = #0x22
700aa9c2: e7ff         	b	0x700aa9c4 <UART_moduleReset+0x44> @ imm = #-0x2
700aa9c4: 9805         	ldr	r0, [sp, #0x14]
700aa9c6: 9000         	str	r0, [sp]
700aa9c8: 9804         	ldr	r0, [sp, #0x10]
700aa9ca: 6d82         	ldr	r2, [r0, #0x58]
700aa9cc: f44f 70fa    	mov.w	r0, #0x1f4
700aa9d0: 2100         	movs	r1, #0x0
700aa9d2: 9101         	str	r1, [sp, #0x4]
700aa9d4: 4790         	blx	r2
700aa9d6: 9900         	ldr	r1, [sp]
700aa9d8: 4602         	mov	r2, r0
700aa9da: 9801         	ldr	r0, [sp, #0x4]
700aa9dc: 4291         	cmp	r1, r2
700aa9de: bf38         	it	lo
700aa9e0: 2001         	movlo	r0, #0x1
700aa9e2: 9003         	str	r0, [sp, #0xc]
700aa9e4: e7ff         	b	0x700aa9e6 <UART_moduleReset+0x66> @ imm = #-0x2
700aa9e6: 9803         	ldr	r0, [sp, #0xc]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aa9e8: 07c0         	lsls	r0, r0, #0x1f
700aa9ea: b138         	cbz	r0, 0x700aa9fc <UART_moduleReset+0x7c> @ imm = #0xe
700aa9ec: e7ff         	b	0x700aa9ee <UART_moduleReset+0x6e> @ imm = #-0x2
;         elapsedTicks = hUartInit->clockP_get() - startTicks;
700aa9ee: 9804         	ldr	r0, [sp, #0x10]
700aa9f0: 6d40         	ldr	r0, [r0, #0x54]
700aa9f2: 4780         	blx	r0
700aa9f4: 9906         	ldr	r1, [sp, #0x18]
700aa9f6: 1a40         	subs	r0, r0, r1
700aa9f8: 9005         	str	r0, [sp, #0x14]
;     while ((0U == HW_RD_FIELD32(hUart->baseAddr + UART_SYSS, UART_SYSS_RESETDONE)) && (elapsedTicks < hUartInit->clockP_usecToTick(UART_MODULE_RESET_TIMEOUT_IN_US)))
700aa9fa: e7d6         	b	0x700aa9aa <UART_moduleReset+0x2a> @ imm = #-0x54
; }
700aa9fc: b008         	add	sp, #0x20
700aa9fe: bd80         	pop	{r7, pc}

700aaa00 <CSL_bcdmaChanOpIsChanEnabled>:
; {
700aaa00: b580         	push	{r7, lr}
700aaa02: b086         	sub	sp, #0x18
700aaa04: 9005         	str	r0, [sp, #0x14]
700aaa06: 9104         	str	r1, [sp, #0x10]
700aaa08: 9203         	str	r2, [sp, #0xc]
;     switch( chanType )
700aaa0a: 9804         	ldr	r0, [sp, #0x10]
700aaa0c: 9001         	str	r0, [sp, #0x4]
700aaa0e: b140         	cbz	r0, 0x700aaa22 <CSL_bcdmaChanOpIsChanEnabled+0x22> @ imm = #0x10
700aaa10: e7ff         	b	0x700aaa12 <CSL_bcdmaChanOpIsChanEnabled+0x12> @ imm = #-0x2
700aaa12: 9801         	ldr	r0, [sp, #0x4]
700aaa14: 2801         	cmp	r0, #0x1
700aaa16: d010         	beq	0x700aaa3a <CSL_bcdmaChanOpIsChanEnabled+0x3a> @ imm = #0x20
700aaa18: e7ff         	b	0x700aaa1a <CSL_bcdmaChanOpIsChanEnabled+0x1a> @ imm = #-0x2
700aaa1a: 9801         	ldr	r0, [sp, #0x4]
700aaa1c: 2802         	cmp	r0, #0x2
700aaa1e: d018         	beq	0x700aaa52 <CSL_bcdmaChanOpIsChanEnabled+0x52> @ imm = #0x30
700aaa20: e023         	b	0x700aaa6a <CSL_bcdmaChanOpIsChanEnabled+0x6a> @ imm = #0x46
;             regVal = CSL_REG32_FEXT( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_EN );
700aaa22: 9805         	ldr	r0, [sp, #0x14]
700aaa24: 6880         	ldr	r0, [r0, #0x8]
700aaa26: 9903         	ldr	r1, [sp, #0xc]
700aaa28: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaa2c: f04f 4100    	mov.w	r1, #0x80000000
700aaa30: 221f         	movs	r2, #0x1f
700aaa32: f004 fb2d    	bl	0x700af090 <CSL_REG32_FEXT_RAW> @ imm = #0x465a
700aaa36: 9002         	str	r0, [sp, #0x8]
;             break;
700aaa38: e01a         	b	0x700aaa70 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x34
;             regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_EN );
700aaa3a: 9805         	ldr	r0, [sp, #0x14]
700aaa3c: 6900         	ldr	r0, [r0, #0x10]
700aaa3e: 9903         	ldr	r1, [sp, #0xc]
700aaa40: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaa44: f04f 4100    	mov.w	r1, #0x80000000
700aaa48: 221f         	movs	r2, #0x1f
700aaa4a: f004 fb21    	bl	0x700af090 <CSL_REG32_FEXT_RAW> @ imm = #0x4642
700aaa4e: 9002         	str	r0, [sp, #0x8]
;             break;
700aaa50: e00e         	b	0x700aaa70 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x1c
;             regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_EN );
700aaa52: 9805         	ldr	r0, [sp, #0x14]
700aaa54: 6980         	ldr	r0, [r0, #0x18]
700aaa56: 9903         	ldr	r1, [sp, #0xc]
700aaa58: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaa5c: f04f 4100    	mov.w	r1, #0x80000000
700aaa60: 221f         	movs	r2, #0x1f
700aaa62: f004 fb15    	bl	0x700af090 <CSL_REG32_FEXT_RAW> @ imm = #0x462a
700aaa66: 9002         	str	r0, [sp, #0x8]
;             break;
700aaa68: e002         	b	0x700aaa70 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #0x4
700aaa6a: 2000         	movs	r0, #0x0
;             regVal = 0U;
700aaa6c: 9002         	str	r0, [sp, #0x8]
;             break;
700aaa6e: e7ff         	b	0x700aaa70 <CSL_bcdmaChanOpIsChanEnabled+0x70> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700aaa70: 9802         	ldr	r0, [sp, #0x8]
700aaa72: 3801         	subs	r0, #0x1
700aaa74: fab0 f080    	clz	r0, r0
700aaa78: 0940         	lsrs	r0, r0, #0x5
700aaa7a: b006         	add	sp, #0x18
700aaa7c: bd80         	pop	{r7, pc}
700aaa7e: 0000         	movs	r0, r0

700aaa80 <CSL_bcdmaChanOpIsValidChanIdx>:
; {
700aaa80: b084         	sub	sp, #0x10
700aaa82: 9003         	str	r0, [sp, #0xc]
700aaa84: 9102         	str	r1, [sp, #0x8]
700aaa86: 9201         	str	r2, [sp, #0x4]
700aaa88: 2001         	movs	r0, #0x1
;     bool retVal = (bool)true;
700aaa8a: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700aaa8e: 9802         	ldr	r0, [sp, #0x8]
700aaa90: b958         	cbnz	r0, 0x700aaaaa <CSL_bcdmaChanOpIsValidChanIdx+0x2a> @ imm = #0x16
700aaa92: e7ff         	b	0x700aaa94 <CSL_bcdmaChanOpIsValidChanIdx+0x14> @ imm = #-0x2
;         if( chanIdx > pCfg->bcChanCnt )
700aaa94: 9801         	ldr	r0, [sp, #0x4]
700aaa96: 9903         	ldr	r1, [sp, #0xc]
700aaa98: 6a49         	ldr	r1, [r1, #0x24]
700aaa9a: 4288         	cmp	r0, r1
700aaa9c: d904         	bls	0x700aaaa8 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #0x8
700aaa9e: e7ff         	b	0x700aaaa0 <CSL_bcdmaChanOpIsValidChanIdx+0x20> @ imm = #-0x2
700aaaa0: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aaaa2: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aaaa6: e7ff         	b	0x700aaaa8 <CSL_bcdmaChanOpIsValidChanIdx+0x28> @ imm = #-0x2
;     }
700aaaa8: e023         	b	0x700aaaf2 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #0x46
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700aaaaa: 9802         	ldr	r0, [sp, #0x8]
700aaaac: 2802         	cmp	r0, #0x2
700aaaae: d10b         	bne	0x700aaac8 <CSL_bcdmaChanOpIsValidChanIdx+0x48> @ imm = #0x16
700aaab0: e7ff         	b	0x700aaab2 <CSL_bcdmaChanOpIsValidChanIdx+0x32> @ imm = #-0x2
;         if( chanIdx > pCfg->splitRxChanCnt )
700aaab2: 9801         	ldr	r0, [sp, #0x4]
700aaab4: 9903         	ldr	r1, [sp, #0xc]
700aaab6: 6a89         	ldr	r1, [r1, #0x28]
700aaab8: 4288         	cmp	r0, r1
700aaaba: d904         	bls	0x700aaac6 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #0x8
700aaabc: e7ff         	b	0x700aaabe <CSL_bcdmaChanOpIsValidChanIdx+0x3e> @ imm = #-0x2
700aaabe: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aaac0: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aaac4: e7ff         	b	0x700aaac6 <CSL_bcdmaChanOpIsValidChanIdx+0x46> @ imm = #-0x2
;     }
700aaac6: e013         	b	0x700aaaf0 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #0x26
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700aaac8: 9802         	ldr	r0, [sp, #0x8]
700aaaca: 2801         	cmp	r0, #0x1
700aaacc: d10b         	bne	0x700aaae6 <CSL_bcdmaChanOpIsValidChanIdx+0x66> @ imm = #0x16
700aaace: e7ff         	b	0x700aaad0 <CSL_bcdmaChanOpIsValidChanIdx+0x50> @ imm = #-0x2
;         if( chanIdx > pCfg->splitTxChanCnt )
700aaad0: 9801         	ldr	r0, [sp, #0x4]
700aaad2: 9903         	ldr	r1, [sp, #0xc]
700aaad4: 6ac9         	ldr	r1, [r1, #0x2c]
700aaad6: 4288         	cmp	r0, r1
700aaad8: d904         	bls	0x700aaae4 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #0x8
700aaada: e7ff         	b	0x700aaadc <CSL_bcdmaChanOpIsValidChanIdx+0x5c> @ imm = #-0x2
700aaadc: 2000         	movs	r0, #0x0
;             retVal = (bool)false;
700aaade: f88d 0003    	strb.w	r0, [sp, #0x3]
;         }
700aaae2: e7ff         	b	0x700aaae4 <CSL_bcdmaChanOpIsValidChanIdx+0x64> @ imm = #-0x2
;     }
700aaae4: e003         	b	0x700aaaee <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #0x6
700aaae6: 2000         	movs	r0, #0x0
;         retVal = (bool)false;
700aaae8: f88d 0003    	strb.w	r0, [sp, #0x3]
700aaaec: e7ff         	b	0x700aaaee <CSL_bcdmaChanOpIsValidChanIdx+0x6e> @ imm = #-0x2
700aaaee: e7ff         	b	0x700aaaf0 <CSL_bcdmaChanOpIsValidChanIdx+0x70> @ imm = #-0x2
700aaaf0: e7ff         	b	0x700aaaf2 <CSL_bcdmaChanOpIsValidChanIdx+0x72> @ imm = #-0x2
;     return retVal;
700aaaf2: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aaaf6: f000 0001    	and	r0, r0, #0x1
700aaafa: b004         	add	sp, #0x10
700aaafc: 4770         	bx	lr
700aaafe: 0000         	movs	r0, r0

700aab00 <CSL_bcdmaMapChanIdx>:
; {
700aab00: b084         	sub	sp, #0x10
700aab02: 9003         	str	r0, [sp, #0xc]
700aab04: 9102         	str	r1, [sp, #0x8]
700aab06: 9201         	str	r2, [sp, #0x4]
;     if( chanIdx < pCfg->bcChanCnt )
700aab08: 9802         	ldr	r0, [sp, #0x8]
700aab0a: 9903         	ldr	r1, [sp, #0xc]
700aab0c: 6a49         	ldr	r1, [r1, #0x24]
700aab0e: 4288         	cmp	r0, r1
700aab10: d206         	bhs	0x700aab20 <CSL_bcdmaMapChanIdx+0x20> @ imm = #0xc
700aab12: e7ff         	b	0x700aab14 <CSL_bcdmaMapChanIdx+0x14> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_BLOCK_COPY;
700aab14: 9901         	ldr	r1, [sp, #0x4]
700aab16: 2000         	movs	r0, #0x0
700aab18: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx;
700aab1a: 9802         	ldr	r0, [sp, #0x8]
700aab1c: 9000         	str	r0, [sp]
;     }
700aab1e: e02b         	b	0x700aab78 <CSL_bcdmaMapChanIdx+0x78> @ imm = #0x56
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt) )
700aab20: 9802         	ldr	r0, [sp, #0x8]
700aab22: 9a03         	ldr	r2, [sp, #0xc]
700aab24: 6a51         	ldr	r1, [r2, #0x24]
700aab26: 6ad2         	ldr	r2, [r2, #0x2c]
700aab28: 4411         	add	r1, r2
700aab2a: 4288         	cmp	r0, r1
700aab2c: d209         	bhs	0x700aab42 <CSL_bcdmaMapChanIdx+0x42> @ imm = #0x12
700aab2e: e7ff         	b	0x700aab30 <CSL_bcdmaMapChanIdx+0x30> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_TX;
700aab30: 9901         	ldr	r1, [sp, #0x4]
700aab32: 2001         	movs	r0, #0x1
700aab34: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt;
700aab36: 9802         	ldr	r0, [sp, #0x8]
700aab38: 9903         	ldr	r1, [sp, #0xc]
700aab3a: 6a49         	ldr	r1, [r1, #0x24]
700aab3c: 1a40         	subs	r0, r0, r1
700aab3e: 9000         	str	r0, [sp]
;     }
700aab40: e019         	b	0x700aab76 <CSL_bcdmaMapChanIdx+0x76> @ imm = #0x32
;     else if( chanIdx < (pCfg->bcChanCnt + pCfg->splitTxChanCnt + pCfg->splitRxChanCnt) )
700aab42: 9802         	ldr	r0, [sp, #0x8]
700aab44: 9b03         	ldr	r3, [sp, #0xc]
700aab46: 6a59         	ldr	r1, [r3, #0x24]
700aab48: 6a9a         	ldr	r2, [r3, #0x28]
700aab4a: 6adb         	ldr	r3, [r3, #0x2c]
700aab4c: 4419         	add	r1, r3
700aab4e: 4411         	add	r1, r2
700aab50: 4288         	cmp	r0, r1
700aab52: d20b         	bhs	0x700aab6c <CSL_bcdmaMapChanIdx+0x6c> @ imm = #0x16
700aab54: e7ff         	b	0x700aab56 <CSL_bcdmaMapChanIdx+0x56> @ imm = #-0x2
;         *chanType = CSL_BCDMA_CHAN_TYPE_SPLIT_RX;
700aab56: 9901         	ldr	r1, [sp, #0x4]
700aab58: 2002         	movs	r0, #0x2
700aab5a: 6008         	str	r0, [r1]
;         base0chanIdx = chanIdx - pCfg->bcChanCnt - pCfg->splitTxChanCnt;
700aab5c: 9802         	ldr	r0, [sp, #0x8]
700aab5e: 9903         	ldr	r1, [sp, #0xc]
700aab60: 6a4a         	ldr	r2, [r1, #0x24]
700aab62: 6ac9         	ldr	r1, [r1, #0x2c]
700aab64: 1a80         	subs	r0, r0, r2
700aab66: 1a40         	subs	r0, r0, r1
700aab68: 9000         	str	r0, [sp]
;     }
700aab6a: e003         	b	0x700aab74 <CSL_bcdmaMapChanIdx+0x74> @ imm = #0x6
700aab6c: f04f 30ff    	mov.w	r0, #0xffffffff
;         base0chanIdx = CSL_BCDMA_INVALID_CHANNEL_INDEX;
700aab70: 9000         	str	r0, [sp]
700aab72: e7ff         	b	0x700aab74 <CSL_bcdmaMapChanIdx+0x74> @ imm = #-0x2
700aab74: e7ff         	b	0x700aab76 <CSL_bcdmaMapChanIdx+0x76> @ imm = #-0x2
700aab76: e7ff         	b	0x700aab78 <CSL_bcdmaMapChanIdx+0x78> @ imm = #-0x2
;     return base0chanIdx;
700aab78: 9800         	ldr	r0, [sp]
700aab7a: b004         	add	sp, #0x10
700aab7c: 4770         	bx	lr
700aab7e: 0000         	movs	r0, r0

700aab80 <ClockP_getTimeUsec>:
; {
700aab80: b580         	push	{r7, lr}
700aab82: b08a         	sub	sp, #0x28
700aab84: 2000         	movs	r0, #0x0
;     uint64_t ts = 0U;
700aab86: 9009         	str	r0, [sp, #0x24]
700aab88: 9008         	str	r0, [sp, #0x20]
;     do {
700aab8a: e7ff         	b	0x700aab8c <ClockP_getTimeUsec+0xc> @ imm = #-0x2
;         ticks1 = gClockCtrl.ticks;
700aab8c: f245 1090    	movw	r0, #0x5190
700aab90: f2c7 0008    	movt	r0, #0x7008
700aab94: 9001         	str	r0, [sp, #0x4]
700aab96: 6801         	ldr	r1, [r0]
700aab98: 6842         	ldr	r2, [r0, #0x4]
700aab9a: 9205         	str	r2, [sp, #0x14]
700aab9c: 9104         	str	r1, [sp, #0x10]
;         timerCount = ClockP_getTimerCount(gClockCtrl.timerBaseAddr);
700aab9e: 6ac0         	ldr	r0, [r0, #0x2c]
700aaba0: f004 ffce    	bl	0x700afb40 <ClockP_getTimerCount> @ imm = #0x4f9c
700aaba4: 9901         	ldr	r1, [sp, #0x4]
700aaba6: 9007         	str	r0, [sp, #0x1c]
;         ticks2 = gClockCtrl.ticks;
700aaba8: 6808         	ldr	r0, [r1]
700aabaa: 6849         	ldr	r1, [r1, #0x4]
700aabac: 9103         	str	r1, [sp, #0xc]
700aabae: 9002         	str	r0, [sp, #0x8]
;     } while (ticks1 != ticks2);
700aabb0: e7ff         	b	0x700aabb2 <ClockP_getTimeUsec+0x32> @ imm = #-0x2
700aabb2: 9804         	ldr	r0, [sp, #0x10]
700aabb4: 9905         	ldr	r1, [sp, #0x14]
700aabb6: 9a02         	ldr	r2, [sp, #0x8]
700aabb8: 9b03         	ldr	r3, [sp, #0xc]
700aabba: 4059         	eors	r1, r3
700aabbc: ea80 0002    	eor.w	r0, r0, r2
700aabc0: 4308         	orrs	r0, r1
700aabc2: 2800         	cmp	r0, #0x0
700aabc4: d1e2         	bne	0x700aab8c <ClockP_getTimeUsec+0xc> @ imm = #-0x3c
700aabc6: e7ff         	b	0x700aabc8 <ClockP_getTimeUsec+0x48> @ imm = #-0x2
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aabc8: 9a02         	ldr	r2, [sp, #0x8]
700aabca: 9803         	ldr	r0, [sp, #0xc]
700aabcc: f245 1190    	movw	r1, #0x5190
700aabd0: f2c7 0108    	movt	r1, #0x7008
700aabd4: 688b         	ldr	r3, [r1, #0x8]
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700aabd6: f8d1 c030    	ldr.w	r12, [r1, #0x30]
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aabda: fb00 f103    	mul	r1, r0, r3
;                 (uint64_t)(((timerCount - gClockCtrl.timerReloadCount)*gClockCtrl.usecPerTick)/(MAX_TIMER_COUNT_VALUE - gClockCtrl.timerReloadCount))
700aabde: 9807         	ldr	r0, [sp, #0x1c]
700aabe0: eba0 000c    	sub.w	r0, r0, r12
700aabe4: 4358         	muls	r0, r3, r0
700aabe6: ea6f 0c0c    	mvn.w	r12, r12
700aabea: fbb0 f0fc    	udiv	r0, r0, r12
;              + (uint64_t) ( /* convert timer count to usecs */
700aabee: fbe2 0103    	umlal	r0, r1, r2, r3
;     ts = (ticks2 * (uint64_t)gClockCtrl.usecPerTick)
700aabf2: 9109         	str	r1, [sp, #0x24]
700aabf4: 9008         	str	r0, [sp, #0x20]
;     return (ts);
700aabf6: 9808         	ldr	r0, [sp, #0x20]
700aabf8: 9909         	ldr	r1, [sp, #0x24]
700aabfa: b00a         	add	sp, #0x28
700aabfc: bd80         	pop	{r7, pc}
700aabfe: 0000         	movs	r0, r0

700aac00 <UART_readData>:
; {
700aac00: b580         	push	{r7, lr}
700aac02: b086         	sub	sp, #0x18
700aac04: 9005         	str	r0, [sp, #0x14]
700aac06: 9104         	str	r1, [sp, #0x10]
700aac08: 2000         	movs	r0, #0x0
;     uint8_t             readIn = 0;
700aac0a: f88d 000f    	strb.w	r0, [sp, #0xf]
;     uint32_t             rdSize = size;
700aac0e: 9804         	ldr	r0, [sp, #0x10]
700aac10: 9001         	str	r0, [sp, #0x4]
;     readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700aac12: 9805         	ldr	r0, [sp, #0x14]
700aac14: 6800         	ldr	r0, [r0]
700aac16: f10d 010f    	add.w	r1, sp, #0xf
700aac1a: f001 fbd1    	bl	0x700ac3c0 <UART_getChar> @ imm = #0x17a2
700aac1e: 9002         	str	r0, [sp, #0x8]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aac20: e7ff         	b	0x700aac22 <UART_readData+0x22> @ imm = #-0x2
700aac22: 9901         	ldr	r1, [sp, #0x4]
700aac24: 2000         	movs	r0, #0x0
700aac26: 9000         	str	r0, [sp]
700aac28: b131         	cbz	r1, 0x700aac38 <UART_readData+0x38> @ imm = #0xc
700aac2a: e7ff         	b	0x700aac2c <UART_readData+0x2c> @ imm = #-0x2
700aac2c: 9802         	ldr	r0, [sp, #0x8]
700aac2e: 2800         	cmp	r0, #0x0
700aac30: bf18         	it	ne
700aac32: 2001         	movne	r0, #0x1
700aac34: 9000         	str	r0, [sp]
700aac36: e7ff         	b	0x700aac38 <UART_readData+0x38> @ imm = #-0x2
700aac38: 9800         	ldr	r0, [sp]
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aac3a: 07c0         	lsls	r0, r0, #0x1f
700aac3c: b1e0         	cbz	r0, 0x700aac78 <UART_readData+0x78> @ imm = #0x38
700aac3e: e7ff         	b	0x700aac40 <UART_readData+0x40> @ imm = #-0x2
;         *(uint8_t *)hUart->readBuf = readIn;
700aac40: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700aac44: 9905         	ldr	r1, [sp, #0x14]
700aac46: 6949         	ldr	r1, [r1, #0x14]
700aac48: 7008         	strb	r0, [r1]
;         hUart->readBuf = (uint8_t *)hUart->readBuf + 1U;
700aac4a: 9905         	ldr	r1, [sp, #0x14]
700aac4c: 6948         	ldr	r0, [r1, #0x14]
700aac4e: 3001         	adds	r0, #0x1
700aac50: 6148         	str	r0, [r1, #0x14]
;         hUart->readCount++;
700aac52: 9905         	ldr	r1, [sp, #0x14]
700aac54: 6988         	ldr	r0, [r1, #0x18]
700aac56: 3001         	adds	r0, #0x1
700aac58: 6188         	str	r0, [r1, #0x18]
;         rdSize--;
700aac5a: 9801         	ldr	r0, [sp, #0x4]
700aac5c: 3801         	subs	r0, #0x1
700aac5e: 9001         	str	r0, [sp, #0x4]
;         if (rdSize != 0U)
700aac60: 9801         	ldr	r0, [sp, #0x4]
700aac62: b140         	cbz	r0, 0x700aac76 <UART_readData+0x76> @ imm = #0x10
700aac64: e7ff         	b	0x700aac66 <UART_readData+0x66> @ imm = #-0x2
;             readSuccess = UART_getChar(hUart->baseAddr, &readIn);
700aac66: 9805         	ldr	r0, [sp, #0x14]
700aac68: 6800         	ldr	r0, [r0]
700aac6a: f10d 010f    	add.w	r1, sp, #0xf
700aac6e: f001 fba7    	bl	0x700ac3c0 <UART_getChar> @ imm = #0x174e
700aac72: 9002         	str	r0, [sp, #0x8]
;         }
700aac74: e7ff         	b	0x700aac76 <UART_readData+0x76> @ imm = #-0x2
;     while ((rdSize != 0U) && (readSuccess != 0U))
700aac76: e7d4         	b	0x700aac22 <UART_readData+0x22> @ imm = #-0x58
;     return (rdSize);
700aac78: 9801         	ldr	r0, [sp, #0x4]
700aac7a: b006         	add	sp, #0x18
700aac7c: bd80         	pop	{r7, pc}
700aac7e: 0000         	movs	r0, r0

700aac80 <_DebugP_assert>:
; {
700aac80: b5b0         	push	{r4, r5, r7, lr}
700aac82: b08e         	sub	sp, #0x38
700aac84: f8dd c048    	ldr.w	r12, [sp, #0x48]
700aac88: 900d         	str	r0, [sp, #0x34]
700aac8a: 910c         	str	r1, [sp, #0x30]
700aac8c: 920b         	str	r2, [sp, #0x2c]
700aac8e: 930a         	str	r3, [sp, #0x28]
;     if(expression==0)
700aac90: 980d         	ldr	r0, [sp, #0x34]
700aac92: bb88         	cbnz	r0, 0x700aacf8 <_DebugP_assert+0x78> @ imm = #0x62
700aac94: e7ff         	b	0x700aac96 <_DebugP_assert+0x16> @ imm = #-0x2
700aac96: 2001         	movs	r0, #0x1
;         volatile uint32_t assert_loop = 1;
700aac98: 9004         	str	r0, [sp, #0x10]
700aac9a: 9009         	str	r0, [sp, #0x24]
;         uint64_t curTime = ClockP_getTimeUsec();
700aac9c: f7ff ff70    	bl	0x700aab80 <ClockP_getTimeUsec> @ imm = #-0x120
700aaca0: 9107         	str	r1, [sp, #0x1c]
700aaca2: 9006         	str	r0, [sp, #0x18]
;         DebugP_log("ASSERT: %d.%ds: %s:%s:%d: %s failed !!!\r\n",
700aaca4: 9806         	ldr	r0, [sp, #0x18]
700aaca6: 9907         	ldr	r1, [sp, #0x1c]
700aaca8: f244 2240    	movw	r2, #0x4240
700aacac: f2c0 020f    	movt	r2, #0xf
700aacb0: 2300         	movs	r3, #0x0
700aacb2: f004 ea90    	blx	0x700af1d4 <__aeabi_uldivmod> @ imm = #0x4520
700aacb6: 4603         	mov	r3, r0
700aacb8: 9804         	ldr	r0, [sp, #0x10]
700aacba: 9305         	str	r3, [sp, #0x14]
700aacbc: 4613         	mov	r3, r2
700aacbe: 9a05         	ldr	r2, [sp, #0x14]
700aacc0: 990c         	ldr	r1, [sp, #0x30]
700aacc2: f8dd e02c    	ldr.w	lr, [sp, #0x2c]
700aacc6: 9c0a         	ldr	r4, [sp, #0x28]
700aacc8: 9d12         	ldr	r5, [sp, #0x48]
700aacca: 46ec         	mov	r12, sp
700aaccc: f8cc 500c    	str.w	r5, [r12, #0xc]
700aacd0: f8cc 4008    	str.w	r4, [r12, #0x8]
700aacd4: f8cc e004    	str.w	lr, [r12, #0x4]
700aacd8: f8cc 1000    	str.w	r1, [r12]
700aacdc: f641 311b    	movw	r1, #0x1b1b
700aace0: f2c7 010b    	movt	r1, #0x700b
700aace4: f7ff f814    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #-0xfd8
;         (void) HwiP_disable();
700aace8: f005 ee3a    	blx	0x700b0960 <HwiP_disable> @ imm = #0x5c74
;         while(assert_loop!= 0U)
700aacec: e7ff         	b	0x700aacee <_DebugP_assert+0x6e> @ imm = #-0x2
700aacee: 9809         	ldr	r0, [sp, #0x24]
700aacf0: b108         	cbz	r0, 0x700aacf6 <_DebugP_assert+0x76> @ imm = #0x2
700aacf2: e7ff         	b	0x700aacf4 <_DebugP_assert+0x74> @ imm = #-0x2
700aacf4: e7fb         	b	0x700aacee <_DebugP_assert+0x6e> @ imm = #-0xa
;     }
700aacf6: e7ff         	b	0x700aacf8 <_DebugP_assert+0x78> @ imm = #-0x2
; }
700aacf8: b00e         	add	sp, #0x38
700aacfa: bdb0         	pop	{r4, r5, r7, pc}
700aacfc: 0000         	movs	r0, r0
700aacfe: 0000         	movs	r0, r0

700aad00 <UART_Params_init>:
; {
700aad00: b082         	sub	sp, #0x8
700aad02: 9001         	str	r0, [sp, #0x4]
;     if(prms != NULL)
700aad04: 9801         	ldr	r0, [sp, #0x4]
700aad06: b3b0         	cbz	r0, 0x700aad76 <UART_Params_init+0x76> @ imm = #0x6c
700aad08: e7ff         	b	0x700aad0a <UART_Params_init+0xa> @ imm = #-0x2
;         prms->baudRate           = 115200U;
700aad0a: 9901         	ldr	r1, [sp, #0x4]
700aad0c: f44f 30e1    	mov.w	r0, #0x1c200
700aad10: 6008         	str	r0, [r1]
;         prms->dataLength         = UART_LEN_8;
700aad12: 9901         	ldr	r1, [sp, #0x4]
700aad14: 2003         	movs	r0, #0x3
700aad16: 6048         	str	r0, [r1, #0x4]
;         prms->stopBits           = UART_STOPBITS_1;
700aad18: 9901         	ldr	r1, [sp, #0x4]
700aad1a: 2000         	movs	r0, #0x0
700aad1c: 9000         	str	r0, [sp]
700aad1e: 6088         	str	r0, [r1, #0x8]
;         prms->parityType         = UART_PARITY_NONE;
700aad20: 9901         	ldr	r1, [sp, #0x4]
700aad22: 60c8         	str	r0, [r1, #0xc]
;         prms->readMode           = UART_TRANSFER_MODE_BLOCKING;
700aad24: 9901         	ldr	r1, [sp, #0x4]
700aad26: 6108         	str	r0, [r1, #0x10]
;         prms->readReturnMode     = UART_READ_RETURN_MODE_FULL;
700aad28: 9901         	ldr	r1, [sp, #0x4]
700aad2a: 6148         	str	r0, [r1, #0x14]
;         prms->writeMode          = UART_TRANSFER_MODE_BLOCKING;
700aad2c: 9901         	ldr	r1, [sp, #0x4]
700aad2e: 6188         	str	r0, [r1, #0x18]
;         prms->readCallbackFxn    = NULL;
700aad30: 9901         	ldr	r1, [sp, #0x4]
700aad32: 61c8         	str	r0, [r1, #0x1c]
;         prms->writeCallbackFxn   = NULL;
700aad34: 9901         	ldr	r1, [sp, #0x4]
700aad36: 6208         	str	r0, [r1, #0x20]
;         prms->hwFlowControl      = FALSE;
700aad38: 9901         	ldr	r1, [sp, #0x4]
700aad3a: 6248         	str	r0, [r1, #0x24]
;         prms->hwFlowControlThr   = UART_RXTRIGLVL_16;
700aad3c: 9a01         	ldr	r2, [sp, #0x4]
700aad3e: 2110         	movs	r1, #0x10
700aad40: 6291         	str	r1, [r2, #0x28]
;         prms->intrNum            = 0xFFFF;
700aad42: 9a01         	ldr	r2, [sp, #0x4]
700aad44: f64f 71ff    	movw	r1, #0xffff
700aad48: 6311         	str	r1, [r2, #0x30]
;         prms->transferMode       = UART_CONFIG_MODE_INTERRUPT;
700aad4a: 9a01         	ldr	r2, [sp, #0x4]
700aad4c: 2101         	movs	r1, #0x1
700aad4e: 62d1         	str	r1, [r2, #0x2c]
;         prms->intrPriority       = 4U;
700aad50: 9a01         	ldr	r2, [sp, #0x4]
700aad52: 2104         	movs	r1, #0x4
700aad54: f882 1034    	strb.w	r1, [r2, #0x34]
;         prms->skipIntrReg        = FALSE;
700aad58: 9901         	ldr	r1, [sp, #0x4]
700aad5a: 6388         	str	r0, [r1, #0x38]
;         prms->uartDmaIndex       = -1;
700aad5c: 9a01         	ldr	r2, [sp, #0x4]
700aad5e: f04f 31ff    	mov.w	r1, #0xffffffff
700aad62: 63d1         	str	r1, [r2, #0x3c]
;         prms->operMode           = UART_OPER_MODE_16X;
700aad64: 9901         	ldr	r1, [sp, #0x4]
700aad66: 6408         	str	r0, [r1, #0x40]
;         prms->rxTrigLvl          = UART_RXTRIGLVL_8;
700aad68: 9901         	ldr	r1, [sp, #0x4]
700aad6a: 2008         	movs	r0, #0x8
700aad6c: 6448         	str	r0, [r1, #0x44]
;         prms->txTrigLvl          = UART_TXTRIGLVL_32;
700aad6e: 9901         	ldr	r1, [sp, #0x4]
700aad70: 2020         	movs	r0, #0x20
700aad72: 6488         	str	r0, [r1, #0x48]
;     }
700aad74: e7ff         	b	0x700aad76 <UART_Params_init+0x76> @ imm = #-0x2
; }
700aad76: b002         	add	sp, #0x8
700aad78: 4770         	bx	lr
700aad7a: 0000         	movs	r0, r0
700aad7c: 0000         	movs	r0, r0
700aad7e: 0000         	movs	r0, r0

700aad80 <main_task>:
; {
700aad80: b5b0         	push	{r4, r5, r7, lr}
700aad82: b086         	sub	sp, #0x18
;    printf("Starting Thread-Metric tests...\r\n");
700aad84: f641 4141    	movw	r1, #0x1c41
700aad88: 2001         	movs	r0, #0x1
700aad8a: f2c7 010b    	movt	r1, #0x700b
700aad8e: 2501         	movs	r5, #0x1
700aad90: f7fe ffbe    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #-0x1084
;    test_interrupt_handler = tm_isr_message_handler;
700aad94: f245 3001    	movw	r0, #0x5301
700aad98: f642 2100    	movw	r1, #0x2a00
700aad9c: f2c7 000a    	movt	r0, #0x700a
700aada0: ac01         	add	r4, sp, #0x4
700aada2: f2c7 010b    	movt	r1, #0x700b
700aada6: 6008         	str	r0, [r1]
;    HwiP_Params_init(&hwiParams);
700aada8: 4620         	mov	r0, r4
700aadaa: f005 f8d1    	bl	0x700aff50 <HwiP_Params_init> @ imm = #0x51a2
;    hwiParams.callback = tm_interrupt_handler; /* Interrupt handler */
700aadae: f64f 2171    	movw	r1, #0xfa71
700aadb2: 200a         	movs	r0, #0xa
700aadb4: f2c7 010a    	movt	r1, #0x700a
;    hwiParams.priority = 1;                    /* Set a valid priority (lower is higher priority) */
700aadb8: f8ad 5012    	strh.w	r5, [sp, #0x12]
;    hwiParams.intNum = SOFTWARE_INTERRUPT_ID;  /* Chosen interrupt ID */
700aadbc: e9cd 0101    	strd	r0, r1, [sp, #4]
;    if (HwiP_construct(&hwiObj, &hwiParams) != SystemP_SUCCESS)
700aadc0: f245 10f0    	movw	r0, #0x51f0
700aadc4: f2c7 0008    	movt	r0, #0x7008
700aadc8: 4621         	mov	r1, r4
700aadca: f005 f8d9    	bl	0x700aff80 <HwiP_construct> @ imm = #0x51b2
700aadce: b140         	cbz	r0, 0x700aade2 <main_task+0x62> @ imm = #0x10
;       printf("Failed to register interrupt\r\n");
700aadd0: f641 5166    	movw	r1, #0x1d66
700aadd4: 2001         	movs	r0, #0x1
700aadd6: f2c7 010b    	movt	r1, #0x700b
700aadda: f7fe ff99    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #-0x10ce
700aadde: bf00         	nop
;       while (1)
700aade0: e7fe         	b	0x700aade0 <main_task+0x60> @ imm = #-0x4
;    HwiP_enableInt(SOFTWARE_INTERRUPT_ID);
700aade2: 200a         	movs	r0, #0xa
700aade4: f005 f80c    	bl	0x700afe00 <HwiP_enableInt> @ imm = #0x5018
;    HwiP_enable();
700aade8: f005 edca    	blx	0x700b0980 <HwiP_enable> @ imm = #0x5b94
;    main_message_isr_test();
700aadec: f004 fe20    	bl	0x700afa30 <main_message_isr_test> @ imm = #0x4c40
;    vTaskDelete(NULL);
700aadf0: 2000         	movs	r0, #0x0
700aadf2: f7fb fb8d    	bl	0x700a6510 <vTaskDelete> @ imm = #-0x48e6
; }
700aadf6: b006         	add	sp, #0x18
700aadf8: bdb0         	pop	{r4, r5, r7, pc}
700aadfa: 0000         	movs	r0, r0

700aadfc <snprintf>:
700aadfc: e24dd004     	sub	sp, sp, #4
700aae00: e92d4070     	push	{r4, r5, r6, lr}
700aae04: e24dd01c     	sub	sp, sp, #28
700aae08: e1a04001     	mov	r4, r1
700aae0c: e3510000     	cmp	r1, #0
700aae10: 12411001     	subne	r1, r1, #1
700aae14: e58d302c     	str	r3, [sp, #0x2c]
700aae18: e59f3050     	ldr	r3, [pc, #0x50]         @ 0x700aae70 <snprintf+0x74>
700aae1c: e3a06000     	mov	r6, #0
700aae20: e59f5044     	ldr	r5, [pc, #0x44]         @ 0x700aae6c <snprintf+0x70>
700aae24: e58d2014     	str	r2, [sp, #0x14]
700aae28: e28d2008     	add	r2, sp, #8
700aae2c: e58d100c     	str	r1, [sp, #0xc]
700aae30: e28d102c     	add	r1, sp, #44
700aae34: e58d0008     	str	r0, [sp, #0x8]
700aae38: e28d0014     	add	r0, sp, #20
700aae3c: e58d6010     	str	r6, [sp, #0x10]
700aae40: e58d1018     	str	r1, [sp, #0x18]
700aae44: e58d5000     	str	r5, [sp]
700aae48: ebffb92c     	bl	0x70099300 <__TI_printfi_nofloat> @ imm = #-0x11b50
700aae4c: e3540000     	cmp	r4, #0
700aae50: 0a000001     	beq	0x700aae5c <snprintf+0x60> @ imm = #0x4
700aae54: e59d1008     	ldr	r1, [sp, #0x8]
700aae58: e5c16000     	strb	r6, [r1]
700aae5c: e28dd01c     	add	sp, sp, #28
700aae60: e8bd4070     	pop	{r4, r5, r6, lr}
700aae64: e28dd004     	add	sp, sp, #4
700aae68: e12fff1e     	bx	lr
700aae6c: d8 ca 0a 70  	.word	0x700acad8
700aae70: 80 e8 0a 70  	.word	0x700ae880
700aae74: 00 00 00 00  	.word	0x00000000
700aae78: 00 00 00 00  	.word	0x00000000
700aae7c: 00 00 00 00  	.word	0x00000000

700aae80 <xTimerCreateTimerTask>:
;     {
700aae80: b580         	push	{r7, lr}
700aae82: b088         	sub	sp, #0x20
700aae84: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
700aae86: 9007         	str	r0, [sp, #0x1c]
;         prvCheckForValidListAndQueue();
700aae88: f7fd fe2a    	bl	0x700a8ae0 <prvCheckForValidListAndQueue> @ imm = #-0x23ac
;         if( xTimerQueue != NULL )
700aae8c: f642 2048    	movw	r0, #0x2a48
700aae90: f2c7 000b    	movt	r0, #0x700b
700aae94: 6800         	ldr	r0, [r0]
700aae96: b358         	cbz	r0, 0x700aaef0 <xTimerCreateTimerTask+0x70> @ imm = #0x56
700aae98: e7ff         	b	0x700aae9a <xTimerCreateTimerTask+0x1a> @ imm = #-0x2
700aae9a: 2000         	movs	r0, #0x0
;                     StaticTask_t * pxTimerTaskTCBBuffer = NULL;
700aae9c: 9003         	str	r0, [sp, #0xc]
700aae9e: 9006         	str	r0, [sp, #0x18]
;                     StackType_t * pxTimerTaskStackBuffer = NULL;
700aaea0: 9005         	str	r0, [sp, #0x14]
700aaea2: a806         	add	r0, sp, #0x18
700aaea4: a905         	add	r1, sp, #0x14
700aaea6: aa04         	add	r2, sp, #0x10
;                     vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
700aaea8: f003 ff12    	bl	0x700aecd0 <vApplicationGetTimerTaskMemory> @ imm = #0x3e24
700aaeac: 9b03         	ldr	r3, [sp, #0xc]
;                                                           ulTimerTaskStackSize,
700aaeae: 9a04         	ldr	r2, [sp, #0x10]
;                                                           pxTimerTaskStackBuffer,
700aaeb0: 9805         	ldr	r0, [sp, #0x14]
;                                                           pxTimerTaskTCBBuffer );
700aaeb2: f8dd c018    	ldr.w	r12, [sp, #0x18]
;                     xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
700aaeb6: 4669         	mov	r1, sp
700aaeb8: f8c1 c008    	str.w	r12, [r1, #0x8]
700aaebc: 6048         	str	r0, [r1, #0x4]
700aaebe: 201f         	movs	r0, #0x1f
700aaec0: 6008         	str	r0, [r1]
700aaec2: f24f 40e1    	movw	r0, #0xf4e1
700aaec6: f2c7 000a    	movt	r0, #0x700a
700aaeca: f242 41fa    	movw	r1, #0x24fa
700aaece: f2c7 010b    	movt	r1, #0x700b
700aaed2: f000 fa55    	bl	0x700ab380 <xTaskCreateStatic> @ imm = #0x4aa
700aaed6: 4601         	mov	r1, r0
700aaed8: f642 204c    	movw	r0, #0x2a4c
700aaedc: f2c7 000b    	movt	r0, #0x700b
700aaee0: 6001         	str	r1, [r0]
;                     if( xTimerTaskHandle != NULL )
700aaee2: 6800         	ldr	r0, [r0]
700aaee4: b118         	cbz	r0, 0x700aaeee <xTimerCreateTimerTask+0x6e> @ imm = #0x6
700aaee6: e7ff         	b	0x700aaee8 <xTimerCreateTimerTask+0x68> @ imm = #-0x2
700aaee8: 2001         	movs	r0, #0x1
;                         xReturn = pdPASS;
700aaeea: 9007         	str	r0, [sp, #0x1c]
;                     }
700aaeec: e7ff         	b	0x700aaeee <xTimerCreateTimerTask+0x6e> @ imm = #-0x2
;         }
700aaeee: e000         	b	0x700aaef2 <xTimerCreateTimerTask+0x72> @ imm = #0x0
700aaef0: e7ff         	b	0x700aaef2 <xTimerCreateTimerTask+0x72> @ imm = #-0x2
;         return xReturn;
700aaef2: 9807         	ldr	r0, [sp, #0x1c]
700aaef4: b008         	add	sp, #0x20
700aaef6: bd80         	pop	{r7, pc}
		...

700aaf00 <CSL_bcdmaChanOpClearError>:
; {
700aaf00: b580         	push	{r7, lr}
700aaf02: b086         	sub	sp, #0x18
700aaf04: 9005         	str	r0, [sp, #0x14]
700aaf06: 9104         	str	r1, [sp, #0x10]
700aaf08: 9203         	str	r2, [sp, #0xc]
700aaf0a: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700aaf0c: 9002         	str	r0, [sp, #0x8]
;     switch( chanType )
700aaf0e: 9804         	ldr	r0, [sp, #0x10]
700aaf10: 9001         	str	r0, [sp, #0x4]
700aaf12: b140         	cbz	r0, 0x700aaf26 <CSL_bcdmaChanOpClearError+0x26> @ imm = #0x10
700aaf14: e7ff         	b	0x700aaf16 <CSL_bcdmaChanOpClearError+0x16> @ imm = #-0x2
700aaf16: 9801         	ldr	r0, [sp, #0x4]
700aaf18: 2801         	cmp	r0, #0x1
700aaf1a: d00f         	beq	0x700aaf3c <CSL_bcdmaChanOpClearError+0x3c> @ imm = #0x1e
700aaf1c: e7ff         	b	0x700aaf1e <CSL_bcdmaChanOpClearError+0x1e> @ imm = #-0x2
700aaf1e: 9801         	ldr	r0, [sp, #0x4]
700aaf20: 2802         	cmp	r0, #0x2
700aaf22: d016         	beq	0x700aaf52 <CSL_bcdmaChanOpClearError+0x52> @ imm = #0x2c
700aaf24: e020         	b	0x700aaf68 <CSL_bcdmaChanOpClearError+0x68> @ imm = #0x40
;             CSL_REG32_FINS( &pCfg->pBcChanRtRegs->CHAN[chanIdx].CTL, BCDMA_BCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aaf26: 9805         	ldr	r0, [sp, #0x14]
700aaf28: 6880         	ldr	r0, [r0, #0x8]
700aaf2a: 9903         	ldr	r1, [sp, #0xc]
700aaf2c: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaf30: 2101         	movs	r1, #0x1
700aaf32: 2300         	movs	r3, #0x0
700aaf34: 461a         	mov	r2, r3
700aaf36: f003 f9c3    	bl	0x700ae2c0 <CSL_REG32_FINS_RAW> @ imm = #0x3386
;             break;
700aaf3a: e019         	b	0x700aaf70 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x32
;             CSL_REG32_FINS( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_TXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aaf3c: 9805         	ldr	r0, [sp, #0x14]
700aaf3e: 6900         	ldr	r0, [r0, #0x10]
700aaf40: 9903         	ldr	r1, [sp, #0xc]
700aaf42: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaf46: 2101         	movs	r1, #0x1
700aaf48: 2300         	movs	r3, #0x0
700aaf4a: 461a         	mov	r2, r3
700aaf4c: f003 f9b8    	bl	0x700ae2c0 <CSL_REG32_FINS_RAW> @ imm = #0x3370
;             break;
700aaf50: e00e         	b	0x700aaf70 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x1c
;             CSL_REG32_FINS( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, BCDMA_RXCRT_CHAN_CTL_ERROR, (uint32_t)0U );
700aaf52: 9805         	ldr	r0, [sp, #0x14]
700aaf54: 6980         	ldr	r0, [r0, #0x18]
700aaf56: 9903         	ldr	r1, [sp, #0xc]
700aaf58: eb00 3001    	add.w	r0, r0, r1, lsl #12
700aaf5c: 2101         	movs	r1, #0x1
700aaf5e: 2300         	movs	r3, #0x0
700aaf60: 461a         	mov	r2, r3
700aaf62: f003 f9ad    	bl	0x700ae2c0 <CSL_REG32_FINS_RAW> @ imm = #0x335a
;             break;
700aaf66: e003         	b	0x700aaf70 <CSL_bcdmaChanOpClearError+0x70> @ imm = #0x6
700aaf68: f06f 0001    	mvn	r0, #0x1
;             retVal = CSL_EBADARGS;
700aaf6c: 9002         	str	r0, [sp, #0x8]
;             break;
700aaf6e: e7ff         	b	0x700aaf70 <CSL_bcdmaChanOpClearError+0x70> @ imm = #-0x2
;     return retVal;
700aaf70: 9802         	ldr	r0, [sp, #0x8]
700aaf72: b006         	add	sp, #0x18
700aaf74: bd80         	pop	{r7, pc}
		...
700aaf7e: 0000         	movs	r0, r0

700aaf80 <CSL_bcdmaDoChanOp>:
; {
700aaf80: b580         	push	{r7, lr}
700aaf82: b088         	sub	sp, #0x20
700aaf84: 9007         	str	r0, [sp, #0x1c]
700aaf86: 9106         	str	r1, [sp, #0x18]
700aaf88: 9205         	str	r2, [sp, #0x14]
700aaf8a: 9304         	str	r3, [sp, #0x10]
700aaf8c: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t retVal = CSL_EFAIL;
700aaf90: 9003         	str	r0, [sp, #0xc]
;     if( pCfg == NULL )
700aaf92: 9807         	ldr	r0, [sp, #0x1c]
700aaf94: b920         	cbnz	r0, 0x700aafa0 <CSL_bcdmaDoChanOp+0x20> @ imm = #0x8
700aaf96: e7ff         	b	0x700aaf98 <CSL_bcdmaDoChanOp+0x18> @ imm = #-0x2
700aaf98: f06f 0001    	mvn	r0, #0x1
;         retVal = CSL_EBADARGS;
700aaf9c: 9003         	str	r0, [sp, #0xc]
;     }
700aaf9e: e027         	b	0x700aaff0 <CSL_bcdmaDoChanOp+0x70> @ imm = #0x4e
;         if( (pCfg->bcChanCnt == (uint32_t)0U) || (pCfg->splitTxChanCnt == (uint32_t)0U) || (pCfg->splitRxChanCnt == (uint32_t)0U) ) {
700aafa0: 9807         	ldr	r0, [sp, #0x1c]
700aafa2: 6a40         	ldr	r0, [r0, #0x24]
700aafa4: b140         	cbz	r0, 0x700aafb8 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x10
700aafa6: e7ff         	b	0x700aafa8 <CSL_bcdmaDoChanOp+0x28> @ imm = #-0x2
700aafa8: 9807         	ldr	r0, [sp, #0x1c]
700aafaa: 6ac0         	ldr	r0, [r0, #0x2c]
700aafac: b120         	cbz	r0, 0x700aafb8 <CSL_bcdmaDoChanOp+0x38> @ imm = #0x8
700aafae: e7ff         	b	0x700aafb0 <CSL_bcdmaDoChanOp+0x30> @ imm = #-0x2
700aafb0: 9807         	ldr	r0, [sp, #0x1c]
700aafb2: 6a80         	ldr	r0, [r0, #0x28]
700aafb4: b920         	cbnz	r0, 0x700aafc0 <CSL_bcdmaDoChanOp+0x40> @ imm = #0x8
700aafb6: e7ff         	b	0x700aafb8 <CSL_bcdmaDoChanOp+0x38> @ imm = #-0x2
;             CSL_bcdmaGetCfg( pCfg );
700aafb8: 9807         	ldr	r0, [sp, #0x1c]
700aafba: f7ff f981    	bl	0x700aa2c0 <CSL_bcdmaGetCfg> @ imm = #-0xcfe
;         }
700aafbe: e7ff         	b	0x700aafc0 <CSL_bcdmaDoChanOp+0x40> @ imm = #-0x2
;         base0chanIdx = CSL_bcdmaMapChanIdx( pCfg, chanIdx, &chanType );
700aafc0: 9807         	ldr	r0, [sp, #0x1c]
700aafc2: 9905         	ldr	r1, [sp, #0x14]
700aafc4: aa01         	add	r2, sp, #0x4
700aafc6: f7ff fd9b    	bl	0x700aab00 <CSL_bcdmaMapChanIdx> @ imm = #-0x4ca
700aafca: 9002         	str	r0, [sp, #0x8]
;         if( base0chanIdx != CSL_BCDMA_INVALID_CHANNEL_INDEX )
700aafcc: 9802         	ldr	r0, [sp, #0x8]
700aafce: 3001         	adds	r0, #0x1
700aafd0: b168         	cbz	r0, 0x700aafee <CSL_bcdmaDoChanOp+0x6e> @ imm = #0x1a
700aafd2: e7ff         	b	0x700aafd4 <CSL_bcdmaDoChanOp+0x54> @ imm = #-0x2
;             retVal = CSL_bcdmaChanOp( pCfg, chanOp, chanType, base0chanIdx, pOpData );
700aafd4: 9807         	ldr	r0, [sp, #0x1c]
700aafd6: 9906         	ldr	r1, [sp, #0x18]
700aafd8: 9a01         	ldr	r2, [sp, #0x4]
700aafda: 9b02         	ldr	r3, [sp, #0x8]
700aafdc: f8dd c010    	ldr.w	r12, [sp, #0x10]
700aafe0: 46ee         	mov	lr, sp
700aafe2: f8ce c000    	str.w	r12, [lr]
700aafe6: f7f6 fc7b    	bl	0x700a18e0 <CSL_bcdmaChanOp> @ imm = #-0x970a
700aafea: 9003         	str	r0, [sp, #0xc]
;         }
700aafec: e7ff         	b	0x700aafee <CSL_bcdmaDoChanOp+0x6e> @ imm = #-0x2
700aafee: e7ff         	b	0x700aaff0 <CSL_bcdmaDoChanOp+0x70> @ imm = #-0x2
;     return retVal;
700aaff0: 9803         	ldr	r0, [sp, #0xc]
700aaff2: b008         	add	sp, #0x20
700aaff4: bd80         	pop	{r7, pc}
		...
700aaffe: 0000         	movs	r0, r0

700ab000 <Udma_chGetCqRingHandle>:
; {
700ab000: b085         	sub	sp, #0x14
700ab002: 9004         	str	r0, [sp, #0x10]
700ab004: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700ab006: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     cqRing = (Udma_RingHandle) NULL_PTR;
700ab008: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700ab00a: 9804         	ldr	r0, [sp, #0x10]
700ab00c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700ab00e: 9800         	ldr	r0, [sp]
700ab010: b150         	cbz	r0, 0x700ab028 <Udma_chGetCqRingHandle+0x28> @ imm = #0x14
700ab012: e7ff         	b	0x700ab014 <Udma_chGetCqRingHandle+0x14> @ imm = #-0x2
700ab014: 9800         	ldr	r0, [sp]
700ab016: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700ab01a: f64a 31cd    	movw	r1, #0xabcd
700ab01e: f6ca 31dc    	movt	r1, #0xabdc
700ab022: 4288         	cmp	r0, r1
700ab024: d004         	beq	0x700ab030 <Udma_chGetCqRingHandle+0x30> @ imm = #0x8
700ab026: e7ff         	b	0x700ab028 <Udma_chGetCqRingHandle+0x28> @ imm = #-0x2
700ab028: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700ab02c: 9003         	str	r0, [sp, #0xc]
;     }
700ab02e: e7ff         	b	0x700ab030 <Udma_chGetCqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab030: 9803         	ldr	r0, [sp, #0xc]
700ab032: b9a8         	cbnz	r0, 0x700ab060 <Udma_chGetCqRingHandle+0x60> @ imm = #0x2a
700ab034: e7ff         	b	0x700ab036 <Udma_chGetCqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700ab036: 9800         	ldr	r0, [sp]
700ab038: 6e80         	ldr	r0, [r0, #0x68]
700ab03a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700ab03c: 9801         	ldr	r0, [sp, #0x4]
700ab03e: b150         	cbz	r0, 0x700ab056 <Udma_chGetCqRingHandle+0x56> @ imm = #0x14
700ab040: e7ff         	b	0x700ab042 <Udma_chGetCqRingHandle+0x42> @ imm = #-0x2
700ab042: 9801         	ldr	r0, [sp, #0x4]
700ab044: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700ab048: f64a 31cd    	movw	r1, #0xabcd
700ab04c: f6ca 31dc    	movt	r1, #0xabdc
700ab050: 4288         	cmp	r0, r1
700ab052: d004         	beq	0x700ab05e <Udma_chGetCqRingHandle+0x5e> @ imm = #0x8
700ab054: e7ff         	b	0x700ab056 <Udma_chGetCqRingHandle+0x56> @ imm = #-0x2
700ab056: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700ab05a: 9003         	str	r0, [sp, #0xc]
;         }
700ab05c: e7ff         	b	0x700ab05e <Udma_chGetCqRingHandle+0x5e> @ imm = #-0x2
;     }
700ab05e: e7ff         	b	0x700ab060 <Udma_chGetCqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab060: 9803         	ldr	r0, [sp, #0xc]
700ab062: b928         	cbnz	r0, 0x700ab070 <Udma_chGetCqRingHandle+0x70> @ imm = #0xa
700ab064: e7ff         	b	0x700ab066 <Udma_chGetCqRingHandle+0x66> @ imm = #-0x2
;         cqRing = (Udma_RingHandle) chHandleInt->cqRing;
700ab066: 9800         	ldr	r0, [sp]
700ab068: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700ab06c: 9002         	str	r0, [sp, #0x8]
;     }
700ab06e: e7ff         	b	0x700ab070 <Udma_chGetCqRingHandle+0x70> @ imm = #-0x2
;     return (cqRing);
700ab070: 9802         	ldr	r0, [sp, #0x8]
700ab072: b005         	add	sp, #0x14
700ab074: 4770         	bx	lr
		...
700ab07e: 0000         	movs	r0, r0

700ab080 <Udma_chGetFqRingHandle>:
; {
700ab080: b085         	sub	sp, #0x14
700ab082: 9004         	str	r0, [sp, #0x10]
700ab084: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700ab086: 9003         	str	r0, [sp, #0xc]
;     Udma_RingHandle     fqRing = (Udma_RingHandle) NULL_PTR;
700ab088: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700ab08a: 9804         	ldr	r0, [sp, #0x10]
700ab08c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700ab08e: 9800         	ldr	r0, [sp]
700ab090: b150         	cbz	r0, 0x700ab0a8 <Udma_chGetFqRingHandle+0x28> @ imm = #0x14
700ab092: e7ff         	b	0x700ab094 <Udma_chGetFqRingHandle+0x14> @ imm = #-0x2
700ab094: 9800         	ldr	r0, [sp]
700ab096: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700ab09a: f64a 31cd    	movw	r1, #0xabcd
700ab09e: f6ca 31dc    	movt	r1, #0xabdc
700ab0a2: 4288         	cmp	r0, r1
700ab0a4: d004         	beq	0x700ab0b0 <Udma_chGetFqRingHandle+0x30> @ imm = #0x8
700ab0a6: e7ff         	b	0x700ab0a8 <Udma_chGetFqRingHandle+0x28> @ imm = #-0x2
700ab0a8: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700ab0ac: 9003         	str	r0, [sp, #0xc]
;     }
700ab0ae: e7ff         	b	0x700ab0b0 <Udma_chGetFqRingHandle+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab0b0: 9803         	ldr	r0, [sp, #0xc]
700ab0b2: b9a8         	cbnz	r0, 0x700ab0e0 <Udma_chGetFqRingHandle+0x60> @ imm = #0x2a
700ab0b4: e7ff         	b	0x700ab0b6 <Udma_chGetFqRingHandle+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700ab0b6: 9800         	ldr	r0, [sp]
700ab0b8: 6e80         	ldr	r0, [r0, #0x68]
700ab0ba: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700ab0bc: 9801         	ldr	r0, [sp, #0x4]
700ab0be: b150         	cbz	r0, 0x700ab0d6 <Udma_chGetFqRingHandle+0x56> @ imm = #0x14
700ab0c0: e7ff         	b	0x700ab0c2 <Udma_chGetFqRingHandle+0x42> @ imm = #-0x2
700ab0c2: 9801         	ldr	r0, [sp, #0x4]
700ab0c4: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700ab0c8: f64a 31cd    	movw	r1, #0xabcd
700ab0cc: f6ca 31dc    	movt	r1, #0xabdc
700ab0d0: 4288         	cmp	r0, r1
700ab0d2: d004         	beq	0x700ab0de <Udma_chGetFqRingHandle+0x5e> @ imm = #0x8
700ab0d4: e7ff         	b	0x700ab0d6 <Udma_chGetFqRingHandle+0x56> @ imm = #-0x2
700ab0d6: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700ab0da: 9003         	str	r0, [sp, #0xc]
;         }
700ab0dc: e7ff         	b	0x700ab0de <Udma_chGetFqRingHandle+0x5e> @ imm = #-0x2
;     }
700ab0de: e7ff         	b	0x700ab0e0 <Udma_chGetFqRingHandle+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab0e0: 9803         	ldr	r0, [sp, #0xc]
700ab0e2: b928         	cbnz	r0, 0x700ab0f0 <Udma_chGetFqRingHandle+0x70> @ imm = #0xa
700ab0e4: e7ff         	b	0x700ab0e6 <Udma_chGetFqRingHandle+0x66> @ imm = #-0x2
;         fqRing = (Udma_RingHandle) chHandleInt->fqRing;
700ab0e6: 9800         	ldr	r0, [sp]
700ab0e8: f8d0 0080    	ldr.w	r0, [r0, #0x80]
700ab0ec: 9002         	str	r0, [sp, #0x8]
;     }
700ab0ee: e7ff         	b	0x700ab0f0 <Udma_chGetFqRingHandle+0x70> @ imm = #-0x2
;     return (fqRing);
700ab0f0: 9802         	ldr	r0, [sp, #0x8]
700ab0f2: b005         	add	sp, #0x14
700ab0f4: 4770         	bx	lr
		...
700ab0fe: 0000         	movs	r0, r0

700ab100 <prvGetExpectedIdleTime>:
; static TickType_t prvGetExpectedIdleTime(void) {
700ab100: b082         	sub	sp, #0x8
700ab102: 2000         	movs	r0, #0x0
;   UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
700ab104: 9000         	str	r0, [sp]
;     if (uxTopReadyPriority > tskIDLE_PRIORITY) {
700ab106: f642 202c    	movw	r0, #0x2a2c
700ab10a: f2c7 000b    	movt	r0, #0x700b
700ab10e: 6800         	ldr	r0, [r0]
700ab110: b118         	cbz	r0, 0x700ab11a <prvGetExpectedIdleTime+0x1a> @ imm = #0x6
700ab112: e7ff         	b	0x700ab114 <prvGetExpectedIdleTime+0x14> @ imm = #-0x2
700ab114: 2001         	movs	r0, #0x1
;       uxHigherPriorityReadyTasks = pdTRUE;
700ab116: 9000         	str	r0, [sp]
;     }
700ab118: e7ff         	b	0x700ab11a <prvGetExpectedIdleTime+0x1a> @ imm = #-0x2
;   if (pxCurrentTCB->uxPriority > tskIDLE_PRIORITY) {
700ab11a: f642 10fc    	movw	r0, #0x29fc
700ab11e: f2c7 000b    	movt	r0, #0x700b
700ab122: 6800         	ldr	r0, [r0]
700ab124: 6ac0         	ldr	r0, [r0, #0x2c]
700ab126: b118         	cbz	r0, 0x700ab130 <prvGetExpectedIdleTime+0x30> @ imm = #0x6
700ab128: e7ff         	b	0x700ab12a <prvGetExpectedIdleTime+0x2a> @ imm = #-0x2
700ab12a: 2000         	movs	r0, #0x0
;     xReturn = 0;
700ab12c: 9001         	str	r0, [sp, #0x4]
;   } else if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700ab12e: e01f         	b	0x700ab170 <prvGetExpectedIdleTime+0x70> @ imm = #0x3e
700ab130: f244 40f8    	movw	r0, #0x44f8
700ab134: f2c7 0008    	movt	r0, #0x7008
700ab138: 6800         	ldr	r0, [r0]
700ab13a: 2802         	cmp	r0, #0x2
700ab13c: d303         	blo	0x700ab146 <prvGetExpectedIdleTime+0x46> @ imm = #0x6
700ab13e: e7ff         	b	0x700ab140 <prvGetExpectedIdleTime+0x40> @ imm = #-0x2
700ab140: 2000         	movs	r0, #0x0
;     xReturn = 0;
700ab142: 9001         	str	r0, [sp, #0x4]
;   } else if (uxHigherPriorityReadyTasks != pdFALSE) {
700ab144: e013         	b	0x700ab16e <prvGetExpectedIdleTime+0x6e> @ imm = #0x26
700ab146: 9800         	ldr	r0, [sp]
700ab148: b118         	cbz	r0, 0x700ab152 <prvGetExpectedIdleTime+0x52> @ imm = #0x6
700ab14a: e7ff         	b	0x700ab14c <prvGetExpectedIdleTime+0x4c> @ imm = #-0x2
700ab14c: 2000         	movs	r0, #0x0
;     xReturn = 0;
700ab14e: 9001         	str	r0, [sp, #0x4]
;   } else {
700ab150: e00c         	b	0x700ab16c <prvGetExpectedIdleTime+0x6c> @ imm = #0x18
;     xReturn = xNextTaskUnblockTime - xTickCount;
700ab152: f642 2034    	movw	r0, #0x2a34
700ab156: f2c7 000b    	movt	r0, #0x700b
700ab15a: 6800         	ldr	r0, [r0]
700ab15c: f642 2144    	movw	r1, #0x2a44
700ab160: f2c7 010b    	movt	r1, #0x700b
700ab164: 6809         	ldr	r1, [r1]
700ab166: 1a40         	subs	r0, r0, r1
700ab168: 9001         	str	r0, [sp, #0x4]
700ab16a: e7ff         	b	0x700ab16c <prvGetExpectedIdleTime+0x6c> @ imm = #-0x2
700ab16c: e7ff         	b	0x700ab16e <prvGetExpectedIdleTime+0x6e> @ imm = #-0x2
700ab16e: e7ff         	b	0x700ab170 <prvGetExpectedIdleTime+0x70> @ imm = #-0x2
;   return xReturn;
700ab170: 9801         	ldr	r0, [sp, #0x4]
700ab172: b002         	add	sp, #0x8
700ab174: 4770         	bx	lr
		...
700ab17e: 0000         	movs	r0, r0

700ab180 <ClockP_usleep>:
; {
700ab180: b580         	push	{r7, lr}
700ab182: b088         	sub	sp, #0x20
700ab184: 9007         	str	r0, [sp, #0x1c]
;     curTime = ClockP_getTimeUsec();
700ab186: f7ff fcfb    	bl	0x700aab80 <ClockP_getTimeUsec> @ imm = #-0x60a
700ab18a: 9105         	str	r1, [sp, #0x14]
700ab18c: 9004         	str	r0, [sp, #0x10]
;     endTime = curTime + usec;
700ab18e: 9904         	ldr	r1, [sp, #0x10]
700ab190: 9805         	ldr	r0, [sp, #0x14]
700ab192: 9a07         	ldr	r2, [sp, #0x1c]
700ab194: 1889         	adds	r1, r1, r2
700ab196: f140 0000    	adc	r0, r0, #0x0
700ab19a: 9102         	str	r1, [sp, #0x8]
700ab19c: 9003         	str	r0, [sp, #0xc]
;     if (usec >= gClockCtrl.usecPerTick) {
700ab19e: 9807         	ldr	r0, [sp, #0x1c]
700ab1a0: f245 1190    	movw	r1, #0x5190
700ab1a4: f2c7 0108    	movt	r1, #0x7008
700ab1a8: 6889         	ldr	r1, [r1, #0x8]
700ab1aa: 4288         	cmp	r0, r1
700ab1ac: d30d         	blo	0x700ab1ca <ClockP_usleep+0x4a> @ imm = #0x1a
700ab1ae: e7ff         	b	0x700ab1b0 <ClockP_usleep+0x30> @ imm = #-0x2
;         ticksToSleep = usec / gClockCtrl.usecPerTick;
700ab1b0: 9807         	ldr	r0, [sp, #0x1c]
700ab1b2: f245 1190    	movw	r1, #0x5190
700ab1b6: f2c7 0108    	movt	r1, #0x7008
700ab1ba: 6889         	ldr	r1, [r1, #0x8]
700ab1bc: fbb0 f0f1    	udiv	r0, r0, r1
700ab1c0: 9001         	str	r0, [sp, #0x4]
;         ClockP_sleepTicks(ticksToSleep);
700ab1c2: 9801         	ldr	r0, [sp, #0x4]
700ab1c4: f004 fcc4    	bl	0x700afb50 <ClockP_sleepTicks> @ imm = #0x4988
;     }
700ab1c8: e012         	b	0x700ab1f0 <ClockP_usleep+0x70> @ imm = #0x24
;         curTime = ClockP_getTimeUsec();
700ab1ca: f7ff fcd9    	bl	0x700aab80 <ClockP_getTimeUsec> @ imm = #-0x64e
700ab1ce: 9105         	str	r1, [sp, #0x14]
700ab1d0: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700ab1d2: e7ff         	b	0x700ab1d4 <ClockP_usleep+0x54> @ imm = #-0x2
700ab1d4: 9a04         	ldr	r2, [sp, #0x10]
700ab1d6: 9805         	ldr	r0, [sp, #0x14]
700ab1d8: 9b02         	ldr	r3, [sp, #0x8]
700ab1da: 9903         	ldr	r1, [sp, #0xc]
700ab1dc: 1ad2         	subs	r2, r2, r3
700ab1de: 4188         	sbcs	r0, r1
700ab1e0: d205         	bhs	0x700ab1ee <ClockP_usleep+0x6e> @ imm = #0xa
700ab1e2: e7ff         	b	0x700ab1e4 <ClockP_usleep+0x64> @ imm = #-0x2
;             curTime = ClockP_getTimeUsec();
700ab1e4: f7ff fccc    	bl	0x700aab80 <ClockP_getTimeUsec> @ imm = #-0x668
700ab1e8: 9105         	str	r1, [sp, #0x14]
700ab1ea: 9004         	str	r0, [sp, #0x10]
;         while (curTime < endTime) {
700ab1ec: e7f2         	b	0x700ab1d4 <ClockP_usleep+0x54> @ imm = #-0x1c
700ab1ee: e7ff         	b	0x700ab1f0 <ClockP_usleep+0x70> @ imm = #-0x2
; }
700ab1f0: b008         	add	sp, #0x20
700ab1f2: bd80         	pop	{r7, pc}
		...

700ab200 <Udma_chEnable>:
; {
700ab200: b580         	push	{r7, lr}
700ab202: b084         	sub	sp, #0x10
700ab204: 9003         	str	r0, [sp, #0xc]
700ab206: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700ab208: 9002         	str	r0, [sp, #0x8]
;     Udma_ChHandleInt    chHandleInt = (Udma_ChHandleInt) chHandle;
700ab20a: 9803         	ldr	r0, [sp, #0xc]
700ab20c: 9000         	str	r0, [sp]
;     if((NULL_PTR == chHandleInt) || (chHandleInt->chInitDone != UDMA_INIT_DONE))
700ab20e: 9800         	ldr	r0, [sp]
700ab210: b150         	cbz	r0, 0x700ab228 <Udma_chEnable+0x28> @ imm = #0x14
700ab212: e7ff         	b	0x700ab214 <Udma_chEnable+0x14> @ imm = #-0x2
700ab214: 9800         	ldr	r0, [sp]
700ab216: f8d0 0244    	ldr.w	r0, [r0, #0x244]
700ab21a: f64a 31cd    	movw	r1, #0xabcd
700ab21e: f6ca 31dc    	movt	r1, #0xabdc
700ab222: 4288         	cmp	r0, r1
700ab224: d004         	beq	0x700ab230 <Udma_chEnable+0x30> @ imm = #0x8
700ab226: e7ff         	b	0x700ab228 <Udma_chEnable+0x28> @ imm = #-0x2
700ab228: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700ab22c: 9002         	str	r0, [sp, #0x8]
;     }
700ab22e: e7ff         	b	0x700ab230 <Udma_chEnable+0x30> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab230: 9802         	ldr	r0, [sp, #0x8]
700ab232: b9a8         	cbnz	r0, 0x700ab260 <Udma_chEnable+0x60> @ imm = #0x2a
700ab234: e7ff         	b	0x700ab236 <Udma_chEnable+0x36> @ imm = #-0x2
;         drvHandle = chHandleInt->drvHandle;
700ab236: 9800         	ldr	r0, [sp]
700ab238: 6e80         	ldr	r0, [r0, #0x68]
700ab23a: 9001         	str	r0, [sp, #0x4]
;         if((NULL_PTR == drvHandle) || (drvHandle->drvInitDone != UDMA_INIT_DONE))
700ab23c: 9801         	ldr	r0, [sp, #0x4]
700ab23e: b150         	cbz	r0, 0x700ab256 <Udma_chEnable+0x56> @ imm = #0x14
700ab240: e7ff         	b	0x700ab242 <Udma_chEnable+0x42> @ imm = #-0x2
700ab242: 9801         	ldr	r0, [sp, #0x4]
700ab244: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700ab248: f64a 31cd    	movw	r1, #0xabcd
700ab24c: f6ca 31dc    	movt	r1, #0xabdc
700ab250: 4288         	cmp	r0, r1
700ab252: d004         	beq	0x700ab25e <Udma_chEnable+0x5e> @ imm = #0x8
700ab254: e7ff         	b	0x700ab256 <Udma_chEnable+0x56> @ imm = #-0x2
700ab256: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700ab25a: 9002         	str	r0, [sp, #0x8]
;         }
700ab25c: e7ff         	b	0x700ab25e <Udma_chEnable+0x5e> @ imm = #-0x2
;     }
700ab25e: e7ff         	b	0x700ab260 <Udma_chEnable+0x60> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700ab260: 9802         	ldr	r0, [sp, #0x8]
700ab262: b920         	cbnz	r0, 0x700ab26e <Udma_chEnable+0x6e> @ imm = #0x8
700ab264: e7ff         	b	0x700ab266 <Udma_chEnable+0x66> @ imm = #-0x2
;         Udma_chEnableLocal(chHandleInt);
700ab266: 9800         	ldr	r0, [sp]
700ab268: f7f5 ff7a    	bl	0x700a1160 <Udma_chEnableLocal> @ imm = #-0xa10c
;     }
700ab26c: e7ff         	b	0x700ab26e <Udma_chEnable+0x6e> @ imm = #-0x2
;     return (retVal);
700ab26e: 9802         	ldr	r0, [sp, #0x8]
700ab270: b004         	add	sp, #0x10
700ab272: bd80         	pop	{r7, pc}
		...

700ab280 <CSL_bcdmaChanOpTriggerChan>:
; {
700ab280: b580         	push	{r7, lr}
700ab282: b084         	sub	sp, #0x10
700ab284: 9003         	str	r0, [sp, #0xc]
700ab286: 9102         	str	r1, [sp, #0x8]
700ab288: 9201         	str	r2, [sp, #0x4]
700ab28a: 2000         	movs	r0, #0x0
;     int32_t retVal = CSL_PASS;
700ab28c: 9000         	str	r0, [sp]
;     if( chanType == CSL_BCDMA_CHAN_TYPE_BLOCK_COPY )
700ab28e: 9802         	ldr	r0, [sp, #0x8]
700ab290: b950         	cbnz	r0, 0x700ab2a8 <CSL_bcdmaChanOpTriggerChan+0x28> @ imm = #0x14
700ab292: e7ff         	b	0x700ab294 <CSL_bcdmaChanOpTriggerChan+0x14> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pBcChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_BCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab294: 9803         	ldr	r0, [sp, #0xc]
700ab296: 6880         	ldr	r0, [r0, #0x8]
700ab298: 9901         	ldr	r1, [sp, #0x4]
700ab29a: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab29e: 3008         	adds	r0, #0x8
700ab2a0: 2101         	movs	r1, #0x1
700ab2a2: f7f0 fff5    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xf016
;     }
700ab2a6: e021         	b	0x700ab2ec <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #0x42
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_TX )
700ab2a8: 9802         	ldr	r0, [sp, #0x8]
700ab2aa: 2801         	cmp	r0, #0x1
700ab2ac: d10a         	bne	0x700ab2c4 <CSL_bcdmaChanOpTriggerChan+0x44> @ imm = #0x14
700ab2ae: e7ff         	b	0x700ab2b0 <CSL_bcdmaChanOpTriggerChan+0x30> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_TXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab2b0: 9803         	ldr	r0, [sp, #0xc]
700ab2b2: 6900         	ldr	r0, [r0, #0x10]
700ab2b4: 9901         	ldr	r1, [sp, #0x4]
700ab2b6: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab2ba: 3008         	adds	r0, #0x8
700ab2bc: 2101         	movs	r1, #0x1
700ab2be: f7f0 ffe7    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xf032
;     }
700ab2c2: e012         	b	0x700ab2ea <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #0x24
;     else if( chanType == CSL_BCDMA_CHAN_TYPE_SPLIT_RX )
700ab2c4: 9802         	ldr	r0, [sp, #0x8]
700ab2c6: 2802         	cmp	r0, #0x2
700ab2c8: d10a         	bne	0x700ab2e0 <CSL_bcdmaChanOpTriggerChan+0x60> @ imm = #0x14
700ab2ca: e7ff         	b	0x700ab2cc <CSL_bcdmaChanOpTriggerChan+0x4c> @ imm = #-0x2
;         CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].SWTRIG, CSL_FMK(BCDMA_RXCRT_CHAN_SWTRIG_TRIGGER, (uint32_t)1U));
700ab2cc: 9803         	ldr	r0, [sp, #0xc]
700ab2ce: 6980         	ldr	r0, [r0, #0x18]
700ab2d0: 9901         	ldr	r1, [sp, #0x4]
700ab2d2: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab2d6: 3008         	adds	r0, #0x8
700ab2d8: 2101         	movs	r1, #0x1
700ab2da: f7f0 ffd9    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0xf04e
;     }
700ab2de: e003         	b	0x700ab2e8 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #0x6
700ab2e0: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;
700ab2e4: 9000         	str	r0, [sp]
700ab2e6: e7ff         	b	0x700ab2e8 <CSL_bcdmaChanOpTriggerChan+0x68> @ imm = #-0x2
700ab2e8: e7ff         	b	0x700ab2ea <CSL_bcdmaChanOpTriggerChan+0x6a> @ imm = #-0x2
700ab2ea: e7ff         	b	0x700ab2ec <CSL_bcdmaChanOpTriggerChan+0x6c> @ imm = #-0x2
;     return retVal;
700ab2ec: 9800         	ldr	r0, [sp]
700ab2ee: b004         	add	sp, #0x10
700ab2f0: bd80         	pop	{r7, pc}
		...
700ab2fe: 0000         	movs	r0, r0

700ab300 <prvProcessExpiredTimer>:
;     {
700ab300: b580         	push	{r7, lr}
700ab302: b086         	sub	sp, #0x18
700ab304: 9005         	str	r0, [sp, #0x14]
700ab306: 9104         	str	r1, [sp, #0x10]
;         Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
700ab308: f245 209c    	movw	r0, #0x529c
700ab30c: f2c7 0008    	movt	r0, #0x7008
700ab310: 6800         	ldr	r0, [r0]
700ab312: 68c0         	ldr	r0, [r0, #0xc]
700ab314: 68c0         	ldr	r0, [r0, #0xc]
700ab316: 9002         	str	r0, [sp, #0x8]
;         ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
700ab318: 9802         	ldr	r0, [sp, #0x8]
700ab31a: 3004         	adds	r0, #0x4
700ab31c: f002 f9f8    	bl	0x700ad710 <uxListRemove> @ imm = #0x23f0
;         if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
700ab320: 9802         	ldr	r0, [sp, #0x8]
700ab322: f890 0028    	ldrb.w	r0, [r0, #0x28]
700ab326: 0740         	lsls	r0, r0, #0x1d
700ab328: 2800         	cmp	r0, #0x0
700ab32a: d515         	bpl	0x700ab358 <prvProcessExpiredTimer+0x58> @ imm = #0x2a
700ab32c: e7ff         	b	0x700ab32e <prvProcessExpiredTimer+0x2e> @ imm = #-0x2
;             if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
700ab32e: 9802         	ldr	r0, [sp, #0x8]
700ab330: 9b05         	ldr	r3, [sp, #0x14]
700ab332: 6981         	ldr	r1, [r0, #0x18]
700ab334: 4419         	add	r1, r3
700ab336: 9a04         	ldr	r2, [sp, #0x10]
700ab338: f7ff f92a    	bl	0x700aa590 <prvInsertTimerInActiveList> @ imm = #-0xdac
700ab33c: b150         	cbz	r0, 0x700ab354 <prvProcessExpiredTimer+0x54> @ imm = #0x14
700ab33e: e7ff         	b	0x700ab340 <prvProcessExpiredTimer+0x40> @ imm = #-0x2
;                 xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
700ab340: 9802         	ldr	r0, [sp, #0x8]
700ab342: 9a05         	ldr	r2, [sp, #0x14]
700ab344: 4669         	mov	r1, sp
700ab346: 2300         	movs	r3, #0x0
700ab348: 600b         	str	r3, [r1]
700ab34a: 4619         	mov	r1, r3
700ab34c: f7fe fbf0    	bl	0x700a9b30 <xTimerGenericCommand> @ imm = #-0x1820
700ab350: 9003         	str	r0, [sp, #0xc]
;             }
700ab352: e000         	b	0x700ab356 <prvProcessExpiredTimer+0x56> @ imm = #0x0
700ab354: e7ff         	b	0x700ab356 <prvProcessExpiredTimer+0x56> @ imm = #-0x2
;         }
700ab356: e007         	b	0x700ab368 <prvProcessExpiredTimer+0x68> @ imm = #0xe
;             pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
700ab358: 9902         	ldr	r1, [sp, #0x8]
700ab35a: f891 0028    	ldrb.w	r0, [r1, #0x28]
700ab35e: f000 00fe    	and	r0, r0, #0xfe
700ab362: f881 0028    	strb.w	r0, [r1, #0x28]
700ab366: e7ff         	b	0x700ab368 <prvProcessExpiredTimer+0x68> @ imm = #-0x2
;         pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
700ab368: 9802         	ldr	r0, [sp, #0x8]
700ab36a: 6a01         	ldr	r1, [r0, #0x20]
700ab36c: 4788         	blx	r1
;     }
700ab36e: b006         	add	sp, #0x18
700ab370: bd80         	pop	{r7, pc}
		...
700ab37e: 0000         	movs	r0, r0

700ab380 <xTaskCreateStatic>:
;     StaticTask_t *const pxTaskBuffer) {
700ab380: b5b0         	push	{r4, r5, r7, lr}
700ab382: b08a         	sub	sp, #0x28
700ab384: f8dd c040    	ldr.w	r12, [sp, #0x40]
700ab388: f8dd c03c    	ldr.w	r12, [sp, #0x3c]
700ab38c: f8dd c038    	ldr.w	r12, [sp, #0x38]
700ab390: 9009         	str	r0, [sp, #0x24]
700ab392: 9108         	str	r1, [sp, #0x20]
700ab394: 9207         	str	r2, [sp, #0x1c]
700ab396: 9306         	str	r3, [sp, #0x18]
;   if ((pxTaskBuffer != NULL) && (puxStackBuffer != NULL)) {
700ab398: 9810         	ldr	r0, [sp, #0x40]
700ab39a: b320         	cbz	r0, 0x700ab3e6 <xTaskCreateStatic+0x66> @ imm = #0x48
700ab39c: e7ff         	b	0x700ab39e <xTaskCreateStatic+0x1e> @ imm = #-0x2
700ab39e: 980f         	ldr	r0, [sp, #0x3c]
700ab3a0: b308         	cbz	r0, 0x700ab3e6 <xTaskCreateStatic+0x66> @ imm = #0x42
700ab3a2: e7ff         	b	0x700ab3a4 <xTaskCreateStatic+0x24> @ imm = #-0x2
;         pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures
700ab3a4: 9810         	ldr	r0, [sp, #0x40]
;     pxNewTCB = (TCB_t *)
700ab3a6: 9005         	str	r0, [sp, #0x14]
;     pxNewTCB->pxStack = (StackType_t *)puxStackBuffer;
700ab3a8: 980f         	ldr	r0, [sp, #0x3c]
700ab3aa: 9905         	ldr	r1, [sp, #0x14]
700ab3ac: 6308         	str	r0, [r1, #0x30]
;       pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
700ab3ae: 9905         	ldr	r1, [sp, #0x14]
700ab3b0: 2002         	movs	r0, #0x2
700ab3b2: f881 0081    	strb.w	r0, [r1, #0x81]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700ab3b6: 9809         	ldr	r0, [sp, #0x24]
700ab3b8: 9908         	ldr	r1, [sp, #0x20]
700ab3ba: 9a07         	ldr	r2, [sp, #0x1c]
700ab3bc: 9b06         	ldr	r3, [sp, #0x18]
;                          uxPriority, &xReturn, pxNewTCB, NULL);
700ab3be: f8dd c038    	ldr.w	r12, [sp, #0x38]
700ab3c2: 9c05         	ldr	r4, [sp, #0x14]
;     prvInitialiseNewTask(pxTaskCode, pcName, ulStackDepth, pvParameters,
700ab3c4: 46ee         	mov	lr, sp
700ab3c6: 2500         	movs	r5, #0x0
700ab3c8: f8ce 500c    	str.w	r5, [lr, #0xc]
700ab3cc: f8ce 4008    	str.w	r4, [lr, #0x8]
700ab3d0: ac04         	add	r4, sp, #0x10
700ab3d2: f8ce 4004    	str.w	r4, [lr, #0x4]
700ab3d6: f8ce c000    	str.w	r12, [lr]
700ab3da: f7f9 fce1    	bl	0x700a4da0 <prvInitialiseNewTask> @ imm = #-0x663e
;     prvAddNewTaskToReadyList(pxNewTCB);
700ab3de: 9805         	ldr	r0, [sp, #0x14]
700ab3e0: f7f9 fe7e    	bl	0x700a50e0 <prvAddNewTaskToReadyList> @ imm = #-0x6304
;   } else {
700ab3e4: e002         	b	0x700ab3ec <xTaskCreateStatic+0x6c> @ imm = #0x4
700ab3e6: 2000         	movs	r0, #0x0
;     xReturn = NULL;
700ab3e8: 9004         	str	r0, [sp, #0x10]
700ab3ea: e7ff         	b	0x700ab3ec <xTaskCreateStatic+0x6c> @ imm = #-0x2
;   return xReturn;
700ab3ec: 9804         	ldr	r0, [sp, #0x10]
700ab3ee: b00a         	add	sp, #0x28
700ab3f0: bdb0         	pop	{r4, r5, r7, pc}
		...
700ab3fe: 0000         	movs	r0, r0

700ab400 <CSL_intaggrClrIntr>:
; {
700ab400: b580         	push	{r7, lr}
700ab402: b088         	sub	sp, #0x20
700ab404: 9007         	str	r0, [sp, #0x1c]
700ab406: 9106         	str	r1, [sp, #0x18]
700ab408: f04f 30ff    	mov.w	r0, #0xffffffff
;     int32_t  retVal = CSL_EFAIL;
700ab40c: 9005         	str	r0, [sp, #0x14]
;     if( CSL_intaggrIsValidStatusBitNum(pCfg, statusBitNum) )
700ab40e: 9807         	ldr	r0, [sp, #0x1c]
700ab410: 9906         	ldr	r1, [sp, #0x18]
700ab412: f002 fd95    	bl	0x700adf40 <CSL_intaggrIsValidStatusBitNum> @ imm = #0x2b2a
700ab416: b340         	cbz	r0, 0x700ab46a <CSL_intaggrClrIntr+0x6a> @ imm = #0x50
700ab418: e7ff         	b	0x700ab41a <CSL_intaggrClrIntr+0x1a> @ imm = #-0x2
;         regNum = statusBitNum >> 6U;
700ab41a: 9806         	ldr	r0, [sp, #0x18]
700ab41c: 0980         	lsrs	r0, r0, #0x6
700ab41e: 9001         	str	r0, [sp, #0x4]
;         bitNum = statusBitNum & (uint32_t)0x003FU;
700ab420: 9806         	ldr	r0, [sp, #0x18]
700ab422: f000 003f    	and	r0, r0, #0x3f
700ab426: 9000         	str	r0, [sp]
;         regVal = (((uint64_t)1U) << bitNum);
700ab428: 9b00         	ldr	r3, [sp]
700ab42a: f1a3 0220    	sub.w	r2, r3, #0x20
700ab42e: 2101         	movs	r1, #0x1
700ab430: fa01 fc02    	lsl.w	r12, r1, r2
700ab434: f1c3 0020    	rsb.w	r0, r3, #0x20
700ab438: fa21 f000    	lsr.w	r0, r1, r0
700ab43c: 2a00         	cmp	r2, #0x0
700ab43e: bf58         	it	pl
700ab440: 4660         	movpl	r0, r12
700ab442: fa01 f103    	lsl.w	r1, r1, r3
700ab446: 2a00         	cmp	r2, #0x0
700ab448: bf58         	it	pl
700ab44a: 2100         	movpl	r1, #0x0
700ab44c: 9102         	str	r1, [sp, #0x8]
700ab44e: 9003         	str	r0, [sp, #0xc]
;         CSL_REG64_WR( &pCfg->pIntrRegs->VINT[regNum].STATUS_CLEAR, regVal );
700ab450: 9807         	ldr	r0, [sp, #0x1c]
700ab452: 6880         	ldr	r0, [r0, #0x8]
700ab454: 9901         	ldr	r1, [sp, #0x4]
700ab456: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ab45a: 3018         	adds	r0, #0x18
700ab45c: 9a02         	ldr	r2, [sp, #0x8]
700ab45e: 9b03         	ldr	r3, [sp, #0xc]
700ab460: f004 f996    	bl	0x700af790 <CSL_REG64_WR_RAW> @ imm = #0x432c
700ab464: 2000         	movs	r0, #0x0
;         retVal = CSL_PASS;
700ab466: 9005         	str	r0, [sp, #0x14]
;     }
700ab468: e7ff         	b	0x700ab46a <CSL_intaggrClrIntr+0x6a> @ imm = #-0x2
;     return retVal;
700ab46a: 9805         	ldr	r0, [sp, #0x14]
700ab46c: b008         	add	sp, #0x20
700ab46e: bd80         	pop	{r7, pc}

700ab470 <Sciclient_rmGetResourceRange>:
; {
700ab470: b580         	push	{r7, lr}
700ab472: b090         	sub	sp, #0x40
700ab474: 900f         	str	r0, [sp, #0x3c]
700ab476: 910e         	str	r1, [sp, #0x38]
700ab478: 920d         	str	r2, [sp, #0x34]
700ab47a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab47c: 900c         	str	r0, [sp, #0x30]
700ab47e: f44f 51a8    	mov.w	r1, #0x1500
;     sciReq.messageType    = TISCI_MSG_RM_GET_RESOURCE_RANGE;
700ab482: f8ad 101c    	strh.w	r1, [sp, #0x1c]
700ab486: 2102         	movs	r1, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ab488: 9108         	str	r1, [sp, #0x20]
700ab48a: a904         	add	r1, sp, #0x10
;     sciReq.pReqPayload    = (const uint8_t *) &req_copy;
700ab48c: 9109         	str	r1, [sp, #0x24]
700ab48e: 210c         	movs	r1, #0xc
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ab490: 910a         	str	r1, [sp, #0x28]
;     sciReq.timeout        = timeout;
700ab492: 990d         	ldr	r1, [sp, #0x34]
700ab494: 910b         	str	r1, [sp, #0x2c]
;     sciResp.flags           = 0;
700ab496: 9001         	str	r0, [sp, #0x4]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ab498: 980e         	ldr	r0, [sp, #0x38]
700ab49a: 9002         	str	r0, [sp, #0x8]
700ab49c: 2010         	movs	r0, #0x10
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ab49e: 9003         	str	r0, [sp, #0xc]
;     memcpy(&req_copy, req, sizeof(struct tisci_msg_rm_get_resource_range_req));
700ab4a0: 9a0f         	ldr	r2, [sp, #0x3c]
700ab4a2: 6810         	ldr	r0, [r2]
700ab4a4: 6851         	ldr	r1, [r2, #0x4]
700ab4a6: 6892         	ldr	r2, [r2, #0x8]
700ab4a8: 9206         	str	r2, [sp, #0x18]
700ab4aa: 9105         	str	r1, [sp, #0x14]
700ab4ac: 9004         	str	r0, [sp, #0x10]
;     if (SystemP_SUCCESS == r)
700ab4ae: 980c         	ldr	r0, [sp, #0x30]
700ab4b0: b930         	cbnz	r0, 0x700ab4c0 <Sciclient_rmGetResourceRange+0x50> @ imm = #0xc
700ab4b2: e7ff         	b	0x700ab4b4 <Sciclient_rmGetResourceRange+0x44> @ imm = #-0x2
700ab4b4: a807         	add	r0, sp, #0x1c
700ab4b6: a901         	add	r1, sp, #0x4
;         r = Sciclient_service(&sciReq, &sciResp);
700ab4b8: f7f2 f892    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xdedc
700ab4bc: 900c         	str	r0, [sp, #0x30]
;     }
700ab4be: e7ff         	b	0x700ab4c0 <Sciclient_rmGetResourceRange+0x50> @ imm = #-0x2
;     if ((r != SystemP_SUCCESS) ||
700ab4c0: 980c         	ldr	r0, [sp, #0x30]
700ab4c2: b930         	cbnz	r0, 0x700ab4d2 <Sciclient_rmGetResourceRange+0x62> @ imm = #0xc
700ab4c4: e7ff         	b	0x700ab4c6 <Sciclient_rmGetResourceRange+0x56> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ab4c6: 9801         	ldr	r0, [sp, #0x4]
700ab4c8: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ab4cc: 2802         	cmp	r0, #0x2
700ab4ce: d004         	beq	0x700ab4da <Sciclient_rmGetResourceRange+0x6a> @ imm = #0x8
700ab4d0: e7ff         	b	0x700ab4d2 <Sciclient_rmGetResourceRange+0x62> @ imm = #-0x2
700ab4d2: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ab4d6: 900c         	str	r0, [sp, #0x30]
;     }
700ab4d8: e7ff         	b	0x700ab4da <Sciclient_rmGetResourceRange+0x6a> @ imm = #-0x2
;     return r;
700ab4da: 980c         	ldr	r0, [sp, #0x30]
700ab4dc: b010         	add	sp, #0x40
700ab4de: bd80         	pop	{r7, pc}

700ab4e0 <Udma_rmFreeMappedRxCh>:
; {
700ab4e0: b580         	push	{r7, lr}
700ab4e2: b088         	sub	sp, #0x20
700ab4e4: 9007         	str	r0, [sp, #0x1c]
700ab4e6: 9106         	str	r1, [sp, #0x18]
700ab4e8: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ab4ea: 9806         	ldr	r0, [sp, #0x18]
700ab4ec: f500 70ea    	add.w	r0, r0, #0x1d4
700ab4f0: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ab4f2: 9806         	ldr	r0, [sp, #0x18]
700ab4f4: f500 609f    	add.w	r0, r0, #0x4f8
700ab4f8: f04f 31ff    	mov.w	r1, #0xffffffff
700ab4fc: f7ff f968    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0xd30
;     i = chNum - rmInitPrms->startMappedRxCh[mappedChGrp];
700ab500: 9807         	ldr	r0, [sp, #0x1c]
700ab502: 9900         	ldr	r1, [sp]
700ab504: 9a05         	ldr	r2, [sp, #0x14]
700ab506: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab50a: 6e89         	ldr	r1, [r1, #0x68]
700ab50c: 1a40         	subs	r0, r0, r1
700ab50e: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700ab510: 9804         	ldr	r0, [sp, #0x10]
700ab512: 0940         	lsrs	r0, r0, #0x5
700ab514: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700ab516: 9804         	ldr	r0, [sp, #0x10]
700ab518: 9903         	ldr	r1, [sp, #0xc]
700ab51a: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ab51e: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700ab520: 9902         	ldr	r1, [sp, #0x8]
700ab522: 2001         	movs	r0, #0x1
700ab524: 4088         	lsls	r0, r1
700ab526: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedRxChFlag[mappedChGrp][offset] |= bitMask;
700ab528: 9a01         	ldr	r2, [sp, #0x4]
700ab52a: 9806         	ldr	r0, [sp, #0x18]
700ab52c: 9905         	ldr	r1, [sp, #0x14]
700ab52e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ab532: 9903         	ldr	r1, [sp, #0xc]
700ab534: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ab538: f8d1 0334    	ldr.w	r0, [r1, #0x334]
700ab53c: 4310         	orrs	r0, r2
700ab53e: f8c1 0334    	str.w	r0, [r1, #0x334]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ab542: 9806         	ldr	r0, [sp, #0x18]
700ab544: f500 609f    	add.w	r0, r0, #0x4f8
700ab548: f000 fcd2    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x9a4
;     return;
700ab54c: b008         	add	sp, #0x20
700ab54e: bd80         	pop	{r7, pc}

700ab550 <Udma_rmFreeMappedTxCh>:
; {
700ab550: b580         	push	{r7, lr}
700ab552: b088         	sub	sp, #0x20
700ab554: 9007         	str	r0, [sp, #0x1c]
700ab556: 9106         	str	r1, [sp, #0x18]
700ab558: 9205         	str	r2, [sp, #0x14]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ab55a: 9806         	ldr	r0, [sp, #0x18]
700ab55c: f500 70ea    	add.w	r0, r0, #0x1d4
700ab560: 9000         	str	r0, [sp]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ab562: 9806         	ldr	r0, [sp, #0x18]
700ab564: f500 609f    	add.w	r0, r0, #0x4f8
700ab568: f04f 31ff    	mov.w	r1, #0xffffffff
700ab56c: f7ff f930    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0xda0
;     i = chNum - rmInitPrms->startMappedTxCh[mappedChGrp];
700ab570: 9807         	ldr	r0, [sp, #0x1c]
700ab572: 9900         	ldr	r1, [sp]
700ab574: 9a05         	ldr	r2, [sp, #0x14]
700ab576: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ab57a: 6c89         	ldr	r1, [r1, #0x48]
700ab57c: 1a40         	subs	r0, r0, r1
700ab57e: 9004         	str	r0, [sp, #0x10]
;     offset = i >> 5U;
700ab580: 9804         	ldr	r0, [sp, #0x10]
700ab582: 0940         	lsrs	r0, r0, #0x5
700ab584: 9003         	str	r0, [sp, #0xc]
;     bitPos = i - (offset << 5U);
700ab586: 9804         	ldr	r0, [sp, #0x10]
700ab588: 9903         	ldr	r1, [sp, #0xc]
700ab58a: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ab58e: 9002         	str	r0, [sp, #0x8]
;     bitMask = (uint32_t) 1U << bitPos;
700ab590: 9902         	ldr	r1, [sp, #0x8]
700ab592: 2001         	movs	r0, #0x1
700ab594: 4088         	lsls	r0, r1
700ab596: 9001         	str	r0, [sp, #0x4]
;     drvHandle->mappedTxChFlag[mappedChGrp][offset] |= bitMask;
700ab598: 9a01         	ldr	r2, [sp, #0x4]
700ab59a: 9806         	ldr	r0, [sp, #0x18]
700ab59c: 9905         	ldr	r1, [sp, #0x14]
700ab59e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ab5a2: 9903         	ldr	r1, [sp, #0xc]
700ab5a4: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ab5a8: f8d1 0324    	ldr.w	r0, [r1, #0x324]
700ab5ac: 4310         	orrs	r0, r2
700ab5ae: f8c1 0324    	str.w	r0, [r1, #0x324]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ab5b2: 9806         	ldr	r0, [sp, #0x18]
700ab5b4: f500 609f    	add.w	r0, r0, #0x4f8
700ab5b8: f000 fc9a    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x934
;     return;
700ab5bc: b008         	add	sp, #0x20
700ab5be: bd80         	pop	{r7, pc}

700ab5c0 <Sciclient_rmIaVintGetInfo>:
; {
700ab5c0: b580         	push	{r7, lr}
700ab5c2: b084         	sub	sp, #0x10
700ab5c4: f8ad 000e    	strh.w	r0, [sp, #0xe]
700ab5c8: f8ad 100c    	strh.w	r1, [sp, #0xc]
700ab5cc: 9202         	str	r2, [sp, #0x8]
700ab5ce: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ab5d0: 9001         	str	r0, [sp, #0x4]
;     if (n_evts == NULL) {
700ab5d2: 9802         	ldr	r0, [sp, #0x8]
700ab5d4: b920         	cbnz	r0, 0x700ab5e0 <Sciclient_rmIaVintGetInfo+0x20> @ imm = #0x8
700ab5d6: e7ff         	b	0x700ab5d8 <Sciclient_rmIaVintGetInfo+0x18> @ imm = #-0x2
700ab5d8: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ab5dc: 9001         	str	r0, [sp, #0x4]
;     } else {
700ab5de: e018         	b	0x700ab612 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #0x30
;         inst = Sciclient_rmIaGetInst(id);
700ab5e0: f8bd 000e    	ldrh.w	r0, [sp, #0xe]
700ab5e4: f000 ffac    	bl	0x700ac540 <Sciclient_rmIaGetInst> @ imm = #0xf58
700ab5e8: 9000         	str	r0, [sp]
;         if (inst == NULL) {
700ab5ea: 9800         	ldr	r0, [sp]
700ab5ec: b920         	cbnz	r0, 0x700ab5f8 <Sciclient_rmIaVintGetInfo+0x38> @ imm = #0x8
700ab5ee: e7ff         	b	0x700ab5f0 <Sciclient_rmIaVintGetInfo+0x30> @ imm = #-0x2
700ab5f0: f06f 0001    	mvn	r0, #0x1
;             r = CSL_EBADARGS;
700ab5f4: 9001         	str	r0, [sp, #0x4]
;         } else {
700ab5f6: e00b         	b	0x700ab610 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #0x16
;             if (vint >= inst->n_vint) {
700ab5f8: f8bd 000c    	ldrh.w	r0, [sp, #0xc]
700ab5fc: 9900         	ldr	r1, [sp]
700ab5fe: 8989         	ldrh	r1, [r1, #0xc]
700ab600: 4288         	cmp	r0, r1
700ab602: db04         	blt	0x700ab60e <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #0x8
700ab604: e7ff         	b	0x700ab606 <Sciclient_rmIaVintGetInfo+0x46> @ imm = #-0x2
700ab606: f06f 0001    	mvn	r0, #0x1
;                 r = CSL_EBADARGS;
700ab60a: 9001         	str	r0, [sp, #0x4]
;             }
700ab60c: e7ff         	b	0x700ab60e <Sciclient_rmIaVintGetInfo+0x4e> @ imm = #-0x2
700ab60e: e7ff         	b	0x700ab610 <Sciclient_rmIaVintGetInfo+0x50> @ imm = #-0x2
700ab610: e7ff         	b	0x700ab612 <Sciclient_rmIaVintGetInfo+0x52> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ab612: 9801         	ldr	r0, [sp, #0x4]
700ab614: b940         	cbnz	r0, 0x700ab628 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #0x10
700ab616: e7ff         	b	0x700ab618 <Sciclient_rmIaVintGetInfo+0x58> @ imm = #-0x2
;         *n_evts = inst->vint_usage_count[vint];
700ab618: 9800         	ldr	r0, [sp]
700ab61a: 6900         	ldr	r0, [r0, #0x10]
700ab61c: f8bd 100c    	ldrh.w	r1, [sp, #0xc]
700ab620: 5c40         	ldrb	r0, [r0, r1]
700ab622: 9902         	ldr	r1, [sp, #0x8]
700ab624: 7008         	strb	r0, [r1]
;     }
700ab626: e7ff         	b	0x700ab628 <Sciclient_rmIaVintGetInfo+0x68> @ imm = #-0x2
;     return r;
700ab628: 9801         	ldr	r0, [sp, #0x4]
700ab62a: b004         	add	sp, #0x10
700ab62c: bd80         	pop	{r7, pc}
700ab62e: 0000         	movs	r0, r0

700ab630 <SemaphoreP_constructMutex>:
; {
700ab630: b580         	push	{r7, lr}
700ab632: b086         	sub	sp, #0x18
700ab634: 9005         	str	r0, [sp, #0x14]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700ab636: 9805         	ldr	r0, [sp, #0x14]
700ab638: 9004         	str	r0, [sp, #0x10]
;     DebugP_assert(sizeof(SemaphoreP_Struct) <= sizeof(SemaphoreP_Object) );
700ab63a: f641 10eb    	movw	r0, #0x19eb
700ab63e: f2c7 000b    	movt	r0, #0x700b
700ab642: 4669         	mov	r1, sp
700ab644: 6008         	str	r0, [r1]
700ab646: f641 41a6    	movw	r1, #0x1ca6
700ab64a: f2c7 010b    	movt	r1, #0x700b
700ab64e: f641 6286    	movw	r2, #0x1e86
700ab652: f2c7 020b    	movt	r2, #0x700b
700ab656: 2001         	movs	r0, #0x1
700ab658: 9002         	str	r0, [sp, #0x8]
700ab65a: 2370         	movs	r3, #0x70
700ab65c: f7ff fb10    	bl	0x700aac80 <_DebugP_assert> @ imm = #-0x9e0
700ab660: 9802         	ldr	r0, [sp, #0x8]
;     pSemaphore->isRecursiveMutex = 1;
700ab662: 9904         	ldr	r1, [sp, #0x10]
700ab664: 6548         	str	r0, [r1, #0x54]
;     pSemaphore->semHndl = xSemaphoreCreateRecursiveMutexStatic(&pSemaphore->semObj);
700ab666: 9904         	ldr	r1, [sp, #0x10]
700ab668: 2004         	movs	r0, #0x4
700ab66a: f003 f8a1    	bl	0x700ae7b0 <xQueueCreateMutexStatic> @ imm = #0x3142
700ab66e: 9904         	ldr	r1, [sp, #0x10]
700ab670: 6508         	str	r0, [r1, #0x50]
;     if( pSemaphore->semHndl == NULL )
700ab672: 9804         	ldr	r0, [sp, #0x10]
700ab674: 6d00         	ldr	r0, [r0, #0x50]
700ab676: b920         	cbnz	r0, 0x700ab682 <SemaphoreP_constructMutex+0x52> @ imm = #0x8
700ab678: e7ff         	b	0x700ab67a <SemaphoreP_constructMutex+0x4a> @ imm = #-0x2
700ab67a: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700ab67e: 9003         	str	r0, [sp, #0xc]
;     }
700ab680: e00a         	b	0x700ab698 <SemaphoreP_constructMutex+0x68> @ imm = #0x14
;         vQueueAddToRegistry(pSemaphore->semHndl, "Mutex (DPL)");
700ab682: 9804         	ldr	r0, [sp, #0x10]
700ab684: 6d00         	ldr	r0, [r0, #0x50]
700ab686: f242 111f    	movw	r1, #0x211f
700ab68a: f2c7 010b    	movt	r1, #0x700b
700ab68e: f001 fd17    	bl	0x700ad0c0 <vQueueAddToRegistry> @ imm = #0x1a2e
700ab692: 2000         	movs	r0, #0x0
;         status = SystemP_SUCCESS;
700ab694: 9003         	str	r0, [sp, #0xc]
700ab696: e7ff         	b	0x700ab698 <SemaphoreP_constructMutex+0x68> @ imm = #-0x2
;     return status;
700ab698: 9803         	ldr	r0, [sp, #0xc]
700ab69a: b006         	add	sp, #0x18
700ab69c: bd80         	pop	{r7, pc}
700ab69e: 0000         	movs	r0, r0

700ab6a0 <UdmaChPrms_init>:
; {
700ab6a0: b580         	push	{r7, lr}
700ab6a2: b082         	sub	sp, #0x8
700ab6a4: 9001         	str	r0, [sp, #0x4]
700ab6a6: 9100         	str	r1, [sp]
;     if(NULL_PTR != chPrms)
700ab6a8: 9801         	ldr	r0, [sp, #0x4]
700ab6aa: b368         	cbz	r0, 0x700ab708 <UdmaChPrms_init+0x68> @ imm = #0x5a
700ab6ac: e7ff         	b	0x700ab6ae <UdmaChPrms_init+0xe> @ imm = #-0x2
;         chPrms->chNum       = UDMA_DMA_CH_ANY;
700ab6ae: 9901         	ldr	r1, [sp, #0x4]
700ab6b0: 2001         	movs	r0, #0x1
700ab6b2: f6cf 70ff    	movt	r0, #0xffff
700ab6b6: 6008         	str	r0, [r1]
;         chPrms->peerChNum   = UDMA_DMA_CH_INVALID;
700ab6b8: 9901         	ldr	r1, [sp, #0x4]
700ab6ba: 2000         	movs	r0, #0x0
700ab6bc: f6cf 70ff    	movt	r0, #0xffff
700ab6c0: 6048         	str	r0, [r1, #0x4]
;         if(UDMA_CH_TYPE_TR_BLK_COPY == chType)
700ab6c2: 9800         	ldr	r0, [sp]
700ab6c4: 2807         	cmp	r0, #0x7
700ab6c6: d106         	bne	0x700ab6d6 <UdmaChPrms_init+0x36> @ imm = #0xc
700ab6c8: e7ff         	b	0x700ab6ca <UdmaChPrms_init+0x2a> @ imm = #-0x2
;             chPrms->peerChNum   = UDMA_DMA_CH_NA;
700ab6ca: 9901         	ldr	r1, [sp, #0x4]
700ab6cc: 2002         	movs	r0, #0x2
700ab6ce: f6cf 70ff    	movt	r0, #0xffff
700ab6d2: 6048         	str	r0, [r1, #0x4]
;         }
700ab6d4: e7ff         	b	0x700ab6d6 <UdmaChPrms_init+0x36> @ imm = #-0x2
;         chPrms->mappedChGrp = UDMA_MAPPED_GROUP_INVALID;
700ab6d6: 9901         	ldr	r1, [sp, #0x4]
700ab6d8: 2004         	movs	r0, #0x4
700ab6da: f6cf 70ff    	movt	r0, #0xffff
700ab6de: 6088         	str	r0, [r1, #0x8]
;         chPrms->appData     = NULL_PTR;
700ab6e0: 9901         	ldr	r1, [sp, #0x4]
700ab6e2: 2000         	movs	r0, #0x0
700ab6e4: 60c8         	str	r0, [r1, #0xc]
;         UdmaRingPrms_init(&chPrms->fqRingPrms);
700ab6e6: 9801         	ldr	r0, [sp, #0x4]
700ab6e8: 3010         	adds	r0, #0x10
700ab6ea: f001 fbf9    	bl	0x700acee0 <UdmaRingPrms_init> @ imm = #0x17f2
;         UdmaRingPrms_init(&chPrms->cqRingPrms);
700ab6ee: 9801         	ldr	r0, [sp, #0x4]
700ab6f0: 302c         	adds	r0, #0x2c
700ab6f2: f001 fbf5    	bl	0x700acee0 <UdmaRingPrms_init> @ imm = #0x17ea
;         UdmaRingPrms_init(&chPrms->tdCqRingPrms);
700ab6f6: 9801         	ldr	r0, [sp, #0x4]
700ab6f8: 3048         	adds	r0, #0x48
700ab6fa: f001 fbf1    	bl	0x700acee0 <UdmaRingPrms_init> @ imm = #0x17e2
;         chPrms->tdCqRingPrms.elemSize = UDMA_RING_ES_8BYTES;
700ab6fe: 9901         	ldr	r1, [sp, #0x4]
700ab700: 2001         	movs	r0, #0x1
700ab702: f881 0058    	strb.w	r0, [r1, #0x58]
;     }
700ab706: e7ff         	b	0x700ab708 <UdmaChPrms_init+0x68> @ imm = #-0x2
;     return;
700ab708: b002         	add	sp, #0x8
700ab70a: bd80         	pop	{r7, pc}

700ab70c <atoi>:
700ab70c: e59f1060     	ldr	r1, [pc, #0x60]         @ 0x700ab774 <atoi+0x68>
700ab710: e4d02001     	ldrb	r2, [r0], #1
700ab714: e0813002     	add	r3, r1, r2
700ab718: e5d33001     	ldrb	r3, [r3, #0x1]
700ab71c: e3130010     	tst	r3, #16
700ab720: 1afffffa     	bne	0x700ab710 <atoi+0x4>   @ imm = #-0x18
700ab724: e3a01000     	mov	r1, #0
700ab728: e352002b     	cmp	r2, #43
700ab72c: 1352002d     	cmpne	r2, #45
700ab730: 0a000003     	beq	0x700ab744 <atoi+0x38>  @ imm = #0xc
700ab734: e2400001     	sub	r0, r0, #1
700ab738: e3a01000     	mov	r1, #0
700ab73c: e1a03002     	mov	r3, r2
700ab740: ea000000     	b	0x700ab748 <atoi+0x3c>  @ imm = #0x0
700ab744: e5d03000     	ldrb	r3, [r0]
700ab748: e2433030     	sub	r3, r3, #48
700ab74c: e3530009     	cmp	r3, #9
700ab750: 8a000003     	bhi	0x700ab764 <atoi+0x58>  @ imm = #0xc
700ab754: e0811101     	add	r1, r1, r1, lsl #2
700ab758: e2800001     	add	r0, r0, #1
700ab75c: e0831081     	add	r1, r3, r1, lsl #1
700ab760: eafffff7     	b	0x700ab744 <atoi+0x38>  @ imm = #-0x24
700ab764: e352002d     	cmp	r2, #45
700ab768: 02611000     	rsbeq	r1, r1, #0
700ab76c: e1a00001     	mov	r0, r1
700ab770: e12fff1e     	bx	lr
700ab774: 00 16 0b 70  	.word	0x700b1600
700ab778: 00 00 00 00  	.word	0x00000000
700ab77c: 00 00 00 00  	.word	0x00000000

700ab780 <Pinmux_lockMMR>:
; {
700ab780: b580         	push	{r7, lr}
700ab782: b084         	sub	sp, #0x10
700ab784: 9003         	str	r0, [sp, #0xc]
;     if(PINMUX_DOMAIN_ID_MAIN == domainId)
700ab786: 9803         	ldr	r0, [sp, #0xc]
700ab788: b908         	cbnz	r0, 0x700ab78e <Pinmux_lockMMR+0xe> @ imm = #0x2
700ab78a: e7ff         	b	0x700ab78c <Pinmux_lockMMR+0xc> @ imm = #-0x2
;     }
700ab78c: e7ff         	b	0x700ab78e <Pinmux_lockMMR+0xe> @ imm = #-0x2
;     if(PINMUX_DOMAIN_ID_MCU == domainId)
700ab78e: 9803         	ldr	r0, [sp, #0xc]
700ab790: 2801         	cmp	r0, #0x1
700ab792: d128         	bne	0x700ab7e6 <Pinmux_lockMMR+0x66> @ imm = #0x50
700ab794: e7ff         	b	0x700ab796 <Pinmux_lockMMR+0x16> @ imm = #-0x2
700ab796: f04f 6081    	mov.w	r0, #0x4080000
700ab79a: 2100         	movs	r1, #0x0
;         baseAddr = (uint32_t) AddrTranslateP_getLocalAddr(CSL_MCU_PADCFG_CTRL0_CFG0_BASE);
700ab79c: 9100         	str	r1, [sp]
700ab79e: f7fa fa37    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x5b92
700ab7a2: 9900         	ldr	r1, [sp]
700ab7a4: 9002         	str	r0, [sp, #0x8]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK0_KICK0_OFFSET);
700ab7a6: 9802         	ldr	r0, [sp, #0x8]
700ab7a8: f241 0208    	movw	r2, #0x1008
700ab7ac: 4410         	add	r0, r2
700ab7ae: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700ab7b0: 9801         	ldr	r0, [sp, #0x4]
700ab7b2: f004 f995    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x432a
700ab7b6: 9900         	ldr	r1, [sp]
;         kickAddr++;
700ab7b8: 9801         	ldr	r0, [sp, #0x4]
700ab7ba: 3004         	adds	r0, #0x4
700ab7bc: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700ab7be: 9801         	ldr	r0, [sp, #0x4]
700ab7c0: f004 f98e    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x431c
700ab7c4: 9900         	ldr	r1, [sp]
;         kickAddr = (volatile uint32_t *) (baseAddr + CSL_MCU_PADCONFIG_LOCK1_KICK0_OFFSET);
700ab7c6: 9802         	ldr	r0, [sp, #0x8]
700ab7c8: f245 0208    	movw	r2, #0x5008
700ab7cc: 4410         	add	r0, r2
700ab7ce: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 0 */
700ab7d0: 9801         	ldr	r0, [sp, #0x4]
700ab7d2: f004 f985    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x430a
700ab7d6: 9900         	ldr	r1, [sp]
;         kickAddr++;
700ab7d8: 9801         	ldr	r0, [sp, #0x4]
700ab7da: 3004         	adds	r0, #0x4
700ab7dc: 9001         	str	r0, [sp, #0x4]
;         CSL_REG32_WR(kickAddr, KICK_LOCK_VAL);      /* KICK 1 */
700ab7de: 9801         	ldr	r0, [sp, #0x4]
700ab7e0: f004 f97e    	bl	0x700afae0 <CSL_REG32_WR_RAW> @ imm = #0x42fc
;     }
700ab7e4: e7ff         	b	0x700ab7e6 <Pinmux_lockMMR+0x66> @ imm = #-0x2
;     return;
700ab7e6: b004         	add	sp, #0x10
700ab7e8: bd80         	pop	{r7, pc}
700ab7ea: 0000         	movs	r0, r0
700ab7ec: 0000         	movs	r0, r0
700ab7ee: 0000         	movs	r0, r0

700ab7f0 <vListInsert>:
; {
700ab7f0: b084         	sub	sp, #0x10
700ab7f2: 9003         	str	r0, [sp, #0xc]
700ab7f4: 9102         	str	r1, [sp, #0x8]
;     const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
700ab7f6: 9802         	ldr	r0, [sp, #0x8]
700ab7f8: 6800         	ldr	r0, [r0]
700ab7fa: 9000         	str	r0, [sp]
;     if( xValueOfInsertion == portMAX_DELAY )
700ab7fc: 9800         	ldr	r0, [sp]
700ab7fe: 3001         	adds	r0, #0x1
700ab800: b920         	cbnz	r0, 0x700ab80c <vListInsert+0x1c> @ imm = #0x8
700ab802: e7ff         	b	0x700ab804 <vListInsert+0x14> @ imm = #-0x2
;         pxIterator = pxList->xListEnd.pxPrevious;
700ab804: 9803         	ldr	r0, [sp, #0xc]
700ab806: 6900         	ldr	r0, [r0, #0x10]
700ab808: 9001         	str	r0, [sp, #0x4]
;     }
700ab80a: e010         	b	0x700ab82e <vListInsert+0x3e> @ imm = #0x20
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700ab80c: 9803         	ldr	r0, [sp, #0xc]
700ab80e: 3008         	adds	r0, #0x8
700ab810: 9001         	str	r0, [sp, #0x4]
700ab812: e7ff         	b	0x700ab814 <vListInsert+0x24> @ imm = #-0x2
700ab814: 9801         	ldr	r0, [sp, #0x4]
700ab816: 6840         	ldr	r0, [r0, #0x4]
700ab818: 6800         	ldr	r0, [r0]
700ab81a: 9900         	ldr	r1, [sp]
700ab81c: 4288         	cmp	r0, r1
700ab81e: d805         	bhi	0x700ab82c <vListInsert+0x3c> @ imm = #0xa
700ab820: e7ff         	b	0x700ab822 <vListInsert+0x32> @ imm = #-0x2
;         }
700ab822: e7ff         	b	0x700ab824 <vListInsert+0x34> @ imm = #-0x2
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
700ab824: 9801         	ldr	r0, [sp, #0x4]
700ab826: 6840         	ldr	r0, [r0, #0x4]
700ab828: 9001         	str	r0, [sp, #0x4]
700ab82a: e7f3         	b	0x700ab814 <vListInsert+0x24> @ imm = #-0x1a
700ab82c: e7ff         	b	0x700ab82e <vListInsert+0x3e> @ imm = #-0x2
;     pxNewListItem->pxNext = pxIterator->pxNext;
700ab82e: 9801         	ldr	r0, [sp, #0x4]
700ab830: 6840         	ldr	r0, [r0, #0x4]
700ab832: 9902         	ldr	r1, [sp, #0x8]
700ab834: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxNext->pxPrevious = pxNewListItem;
700ab836: 9802         	ldr	r0, [sp, #0x8]
700ab838: 6841         	ldr	r1, [r0, #0x4]
700ab83a: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxPrevious = pxIterator;
700ab83c: 9801         	ldr	r0, [sp, #0x4]
700ab83e: 9902         	ldr	r1, [sp, #0x8]
700ab840: 6088         	str	r0, [r1, #0x8]
;     pxIterator->pxNext = pxNewListItem;
700ab842: 9802         	ldr	r0, [sp, #0x8]
700ab844: 9901         	ldr	r1, [sp, #0x4]
700ab846: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxContainer = pxList;
700ab848: 9803         	ldr	r0, [sp, #0xc]
700ab84a: 9902         	ldr	r1, [sp, #0x8]
700ab84c: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700ab84e: 9903         	ldr	r1, [sp, #0xc]
700ab850: 6808         	ldr	r0, [r1]
700ab852: 3001         	adds	r0, #0x1
700ab854: 6008         	str	r0, [r1]
; }
700ab856: b004         	add	sp, #0x10
700ab858: 4770         	bx	lr
700ab85a: 0000         	movs	r0, r0
700ab85c: 0000         	movs	r0, r0
700ab85e: 0000         	movs	r0, r0

700ab860 <Sciclient_rmIrqCfgIsDirectEvent>:
; {
700ab860: b580         	push	{r7, lr}
700ab862: b082         	sub	sp, #0x8
700ab864: 9001         	str	r0, [sp, #0x4]
700ab866: 2000         	movs	r0, #0x0
;     bool r = false;
700ab868: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab86c: 9801         	ldr	r0, [sp, #0x4]
700ab86e: 2101         	movs	r1, #0x1
700ab870: f003 fa46    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x348c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700ab874: b310         	cbz	r0, 0x700ab8bc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x44
700ab876: e7ff         	b	0x700ab878 <Sciclient_rmIrqCfgIsDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab878: 9801         	ldr	r0, [sp, #0x4]
700ab87a: 2102         	movs	r1, #0x2
700ab87c: f003 fa40    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3480
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700ab880: b1e0         	cbz	r0, 0x700ab8bc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x38
700ab882: e7ff         	b	0x700ab884 <Sciclient_rmIrqCfgIsDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab884: 9801         	ldr	r0, [sp, #0x4]
700ab886: 2104         	movs	r1, #0x4
700ab888: f003 fa3a    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3474
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700ab88c: b1b0         	cbz	r0, 0x700ab8bc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x2c
700ab88e: e7ff         	b	0x700ab890 <Sciclient_rmIrqCfgIsDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab890: 9801         	ldr	r0, [sp, #0x4]
700ab892: 2108         	movs	r1, #0x8
700ab894: f003 fa34    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3468
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700ab898: b180         	cbz	r0, 0x700ab8bc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x20
700ab89a: e7ff         	b	0x700ab89c <Sciclient_rmIrqCfgIsDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab89c: 9801         	ldr	r0, [sp, #0x4]
700ab89e: 2110         	movs	r1, #0x10
700ab8a0: f003 fa2e    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x345c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700ab8a4: b150         	cbz	r0, 0x700ab8bc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x14
700ab8a6: e7ff         	b	0x700ab8a8 <Sciclient_rmIrqCfgIsDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab8a8: 9801         	ldr	r0, [sp, #0x4]
700ab8aa: 2120         	movs	r1, #0x20
700ab8ac: f003 fa28    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3450
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab8b0: b120         	cbz	r0, 0x700ab8bc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #0x8
700ab8b2: e7ff         	b	0x700ab8b4 <Sciclient_rmIrqCfgIsDirectEvent+0x54> @ imm = #-0x2
700ab8b4: 2001         	movs	r0, #0x1
;         r = true;
700ab8b6: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab8ba: e7ff         	b	0x700ab8bc <Sciclient_rmIrqCfgIsDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700ab8bc: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab8c0: f000 0001    	and	r0, r0, #0x1
700ab8c4: b002         	add	sp, #0x8
700ab8c6: bd80         	pop	{r7, pc}
		...

700ab8d0 <Sciclient_rmIrqCfgIsDirectNonEvent>:
; {
700ab8d0: b580         	push	{r7, lr}
700ab8d2: b082         	sub	sp, #0x8
700ab8d4: 9001         	str	r0, [sp, #0x4]
700ab8d6: 2000         	movs	r0, #0x0
;     bool r = false;
700ab8d8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab8dc: 9801         	ldr	r0, [sp, #0x4]
700ab8de: 2101         	movs	r1, #0x1
700ab8e0: f003 fa0e    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x341c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700ab8e4: b310         	cbz	r0, 0x700ab92c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x44
700ab8e6: e7ff         	b	0x700ab8e8 <Sciclient_rmIrqCfgIsDirectNonEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab8e8: 9801         	ldr	r0, [sp, #0x4]
700ab8ea: 2102         	movs	r1, #0x2
700ab8ec: f003 fa08    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3410
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700ab8f0: b1e0         	cbz	r0, 0x700ab92c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x38
700ab8f2: e7ff         	b	0x700ab8f4 <Sciclient_rmIrqCfgIsDirectNonEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab8f4: 9801         	ldr	r0, [sp, #0x4]
700ab8f6: 2104         	movs	r1, #0x4
700ab8f8: f003 fa02    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3404
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700ab8fc: b9b0         	cbnz	r0, 0x700ab92c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x2c
700ab8fe: e7ff         	b	0x700ab900 <Sciclient_rmIrqCfgIsDirectNonEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab900: 9801         	ldr	r0, [sp, #0x4]
700ab902: 2108         	movs	r1, #0x8
700ab904: f003 f9fc    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x33f8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700ab908: b980         	cbnz	r0, 0x700ab92c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x20
700ab90a: e7ff         	b	0x700ab90c <Sciclient_rmIrqCfgIsDirectNonEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab90c: 9801         	ldr	r0, [sp, #0x4]
700ab90e: 2110         	movs	r1, #0x10
700ab910: f003 f9f6    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x33ec
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700ab914: b950         	cbnz	r0, 0x700ab92c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x14
700ab916: e7ff         	b	0x700ab918 <Sciclient_rmIrqCfgIsDirectNonEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab918: 9801         	ldr	r0, [sp, #0x4]
700ab91a: 2120         	movs	r1, #0x20
700ab91c: f003 f9f0    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x33e0
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab920: b920         	cbnz	r0, 0x700ab92c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #0x8
700ab922: e7ff         	b	0x700ab924 <Sciclient_rmIrqCfgIsDirectNonEvent+0x54> @ imm = #-0x2
700ab924: 2001         	movs	r0, #0x1
;         r = true;
700ab926: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab92a: e7ff         	b	0x700ab92c <Sciclient_rmIrqCfgIsDirectNonEvent+0x5c> @ imm = #-0x2
;     return r;
700ab92c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab930: f000 0001    	and	r0, r0, #0x1
700ab934: b002         	add	sp, #0x8
700ab936: bd80         	pop	{r7, pc}
		...

700ab940 <Sciclient_rmIrqCfgIsEventToVintMappingOnly>:
; {
700ab940: b580         	push	{r7, lr}
700ab942: b082         	sub	sp, #0x8
700ab944: 9001         	str	r0, [sp, #0x4]
700ab946: 2000         	movs	r0, #0x0
;     bool r = false;
700ab948: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab94c: 9801         	ldr	r0, [sp, #0x4]
700ab94e: 2101         	movs	r1, #0x1
700ab950: f003 f9d6    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x33ac
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700ab954: bb10         	cbnz	r0, 0x700ab99c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x44
700ab956: e7ff         	b	0x700ab958 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab958: 9801         	ldr	r0, [sp, #0x4]
700ab95a: 2102         	movs	r1, #0x2
700ab95c: f003 f9d0    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x33a0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700ab960: b9e0         	cbnz	r0, 0x700ab99c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x38
700ab962: e7ff         	b	0x700ab964 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab964: 9801         	ldr	r0, [sp, #0x4]
700ab966: 2104         	movs	r1, #0x4
700ab968: f003 f9ca    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3394
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700ab96c: b1b0         	cbz	r0, 0x700ab99c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x2c
700ab96e: e7ff         	b	0x700ab970 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab970: 9801         	ldr	r0, [sp, #0x4]
700ab972: 2108         	movs	r1, #0x8
700ab974: f003 f9c4    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3388
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700ab978: b180         	cbz	r0, 0x700ab99c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x20
700ab97a: e7ff         	b	0x700ab97c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab97c: 9801         	ldr	r0, [sp, #0x4]
700ab97e: 2110         	movs	r1, #0x10
700ab980: f003 f9be    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x337c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700ab984: b150         	cbz	r0, 0x700ab99c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x14
700ab986: e7ff         	b	0x700ab988 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab988: 9801         	ldr	r0, [sp, #0x4]
700ab98a: 2120         	movs	r1, #0x20
700ab98c: f003 f9b8    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3370
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab990: b120         	cbz	r0, 0x700ab99c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #0x8
700ab992: e7ff         	b	0x700ab994 <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x54> @ imm = #-0x2
700ab994: 2001         	movs	r0, #0x1
;         r = true;
700ab996: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700ab99a: e7ff         	b	0x700ab99c <Sciclient_rmIrqCfgIsEventToVintMappingOnly+0x5c> @ imm = #-0x2
;     return r;
700ab99c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ab9a0: f000 0001    	and	r0, r0, #0x1
700ab9a4: b002         	add	sp, #0x8
700ab9a6: bd80         	pop	{r7, pc}
		...

700ab9b0 <Sciclient_rmIrqCfgIsOesOnly>:
; {
700ab9b0: b580         	push	{r7, lr}
700ab9b2: b082         	sub	sp, #0x8
700ab9b4: 9001         	str	r0, [sp, #0x4]
700ab9b6: 2000         	movs	r0, #0x0
;     bool r = false;
700ab9b8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700ab9bc: 9801         	ldr	r0, [sp, #0x4]
700ab9be: 2101         	movs	r1, #0x1
700ab9c0: f003 f99e    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x333c
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == false) &&
700ab9c4: bb10         	cbnz	r0, 0x700aba0c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x44
700ab9c6: e7ff         	b	0x700ab9c8 <Sciclient_rmIrqCfgIsOesOnly+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab9c8: 9801         	ldr	r0, [sp, #0x4]
700ab9ca: 2102         	movs	r1, #0x2
700ab9cc: f003 f998    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3330
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == false) &&
700ab9d0: b9e0         	cbnz	r0, 0x700aba0c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x38
700ab9d2: e7ff         	b	0x700ab9d4 <Sciclient_rmIrqCfgIsOesOnly+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab9d4: 9801         	ldr	r0, [sp, #0x4]
700ab9d6: 2104         	movs	r1, #0x4
700ab9d8: f003 f992    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3324
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == false) &&
700ab9dc: b9b0         	cbnz	r0, 0x700aba0c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x2c
700ab9de: e7ff         	b	0x700ab9e0 <Sciclient_rmIrqCfgIsOesOnly+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab9e0: 9801         	ldr	r0, [sp, #0x4]
700ab9e2: 2108         	movs	r1, #0x8
700ab9e4: f003 f98c    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3318
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == false) &&
700ab9e8: b980         	cbnz	r0, 0x700aba0c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x20
700ab9ea: e7ff         	b	0x700ab9ec <Sciclient_rmIrqCfgIsOesOnly+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab9ec: 9801         	ldr	r0, [sp, #0x4]
700ab9ee: 2110         	movs	r1, #0x10
700ab9f0: f003 f986    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x330c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == true) &&
700ab9f4: b150         	cbz	r0, 0x700aba0c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x14
700ab9f6: e7ff         	b	0x700ab9f8 <Sciclient_rmIrqCfgIsOesOnly+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700ab9f8: 9801         	ldr	r0, [sp, #0x4]
700ab9fa: 2120         	movs	r1, #0x20
700ab9fc: f003 f980    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3300
;     if ((Sciclient_rmParamIsValid(valid_params,
700aba00: b920         	cbnz	r0, 0x700aba0c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #0x8
700aba02: e7ff         	b	0x700aba04 <Sciclient_rmIrqCfgIsOesOnly+0x54> @ imm = #-0x2
700aba04: 2001         	movs	r0, #0x1
;         r = true;
700aba06: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aba0a: e7ff         	b	0x700aba0c <Sciclient_rmIrqCfgIsOesOnly+0x5c> @ imm = #-0x2
;     return r;
700aba0c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aba10: f000 0001    	and	r0, r0, #0x1
700aba14: b002         	add	sp, #0x8
700aba16: bd80         	pop	{r7, pc}
		...

700aba20 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent>:
; {
700aba20: b580         	push	{r7, lr}
700aba22: b082         	sub	sp, #0x8
700aba24: 9001         	str	r0, [sp, #0x4]
700aba26: 2000         	movs	r0, #0x0
;     bool r = false;
700aba28: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((Sciclient_rmParamIsValid(valid_params,
700aba2c: 9801         	ldr	r0, [sp, #0x4]
700aba2e: 2101         	movs	r1, #0x1
700aba30: f003 f966    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x32cc
;                     TISCI_MSG_VALUE_RM_DST_ID_VALID) == true) &&
700aba34: b310         	cbz	r0, 0x700aba7c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x44
700aba36: e7ff         	b	0x700aba38 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x18> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700aba38: 9801         	ldr	r0, [sp, #0x4]
700aba3a: 2102         	movs	r1, #0x2
700aba3c: f003 f960    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x32c0
;                     TISCI_MSG_VALUE_RM_DST_HOST_IRQ_VALID) == true) &&
700aba40: b1e0         	cbz	r0, 0x700aba7c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x38
700aba42: e7ff         	b	0x700aba44 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x24> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700aba44: 9801         	ldr	r0, [sp, #0x4]
700aba46: 2104         	movs	r1, #0x4
700aba48: f003 f95a    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x32b4
;                     TISCI_MSG_VALUE_RM_IA_ID_VALID) == true) &&
700aba4c: b1b0         	cbz	r0, 0x700aba7c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x2c
700aba4e: e7ff         	b	0x700aba50 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x30> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700aba50: 9801         	ldr	r0, [sp, #0x4]
700aba52: 2108         	movs	r1, #0x8
700aba54: f003 f954    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x32a8
;                     TISCI_MSG_VALUE_RM_VINT_VALID) == true) &&
700aba58: b180         	cbz	r0, 0x700aba7c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x20
700aba5a: e7ff         	b	0x700aba5c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x3c> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700aba5c: 9801         	ldr	r0, [sp, #0x4]
700aba5e: 2110         	movs	r1, #0x10
700aba60: f003 f94e    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x329c
;                     TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID) == false) &&
700aba64: b950         	cbnz	r0, 0x700aba7c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x14
700aba66: e7ff         	b	0x700aba68 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x48> @ imm = #-0x2
;         (Sciclient_rmParamIsValid(valid_params,
700aba68: 9801         	ldr	r0, [sp, #0x4]
700aba6a: 2120         	movs	r1, #0x20
700aba6c: f003 f948    	bl	0x700aed00 <Sciclient_rmParamIsValid> @ imm = #0x3290
;     if ((Sciclient_rmParamIsValid(valid_params,
700aba70: b920         	cbnz	r0, 0x700aba7c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #0x8
700aba72: e7ff         	b	0x700aba74 <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x54> @ imm = #-0x2
700aba74: 2001         	movs	r0, #0x1
;         r = true;
700aba76: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aba7a: e7ff         	b	0x700aba7c <Sciclient_rmIrqCfgIsUnmappedVintDirectEvent+0x5c> @ imm = #-0x2
;     return r;
700aba7c: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aba80: f000 0001    	and	r0, r0, #0x1
700aba84: b002         	add	sp, #0x8
700aba86: bd80         	pop	{r7, pc}
		...

700aba90 <UART_divisorValCompute>:
; {
700aba90: b580         	push	{r7, lr}
700aba92: b088         	sub	sp, #0x20
700aba94: 9007         	str	r0, [sp, #0x1c]
700aba96: 9106         	str	r1, [sp, #0x18]
700aba98: 9205         	str	r2, [sp, #0x14]
700aba9a: 9304         	str	r3, [sp, #0x10]
700aba9c: 2000         	movs	r0, #0x0
;     uint32_t divisorValue = 0U;
700aba9e: 9003         	str	r0, [sp, #0xc]
;     uint32_t tempModeFlag = modeFlag & UART_MDR1_MODE_SELECT_MASK;
700abaa0: 9805         	ldr	r0, [sp, #0x14]
700abaa2: f000 0007    	and	r0, r0, #0x7
700abaa6: 9002         	str	r0, [sp, #0x8]
;     switch (tempModeFlag)
700abaa8: 9802         	ldr	r0, [sp, #0x8]
700abaaa: 9001         	str	r0, [sp, #0x4]
700abaac: 2805         	cmp	r0, #0x5
700abaae: d81f         	bhi	0x700abaf0 <UART_divisorValCompute+0x60> @ imm = #0x3e
700abab0: 9901         	ldr	r1, [sp, #0x4]
700abab2: e8df f001    	tbb	[pc, r1]
700abab6: 03 03 1d 0a  	.word	0x0a1d0303
700ababa: 12 1a        	.short	0x1a12
;             divisorValue = UART_divideRoundCloset(moduleClk, 16U * baudRate);
700ababc: 9807         	ldr	r0, [sp, #0x1c]
700ababe: 9906         	ldr	r1, [sp, #0x18]
700abac0: 0109         	lsls	r1, r1, #0x4
700abac2: f003 ff05    	bl	0x700af8d0 <UART_divideRoundCloset> @ imm = #0x3e0a
700abac6: 9003         	str	r0, [sp, #0xc]
;             break;
700abac8: e013         	b	0x700abaf2 <UART_divisorValCompute+0x62> @ imm = #0x26
;             divisorValue = UART_divideRoundCloset(moduleClk, 13U * baudRate);
700abaca: 9807         	ldr	r0, [sp, #0x1c]
700abacc: 9906         	ldr	r1, [sp, #0x18]
700abace: 220d         	movs	r2, #0xd
700abad0: 4351         	muls	r1, r2, r1
700abad2: f003 fefd    	bl	0x700af8d0 <UART_divideRoundCloset> @ imm = #0x3dfa
700abad6: 9003         	str	r0, [sp, #0xc]
;             break;
700abad8: e00b         	b	0x700abaf2 <UART_divisorValCompute+0x62> @ imm = #0x16
;             divisorValue = UART_divideRoundCloset(moduleClk, mirOverSampRate * baudRate);
700abada: 9807         	ldr	r0, [sp, #0x1c]
700abadc: 9904         	ldr	r1, [sp, #0x10]
700abade: 9a06         	ldr	r2, [sp, #0x18]
700abae0: 4351         	muls	r1, r2, r1
700abae2: f003 fef5    	bl	0x700af8d0 <UART_divideRoundCloset> @ imm = #0x3dea
700abae6: 9003         	str	r0, [sp, #0xc]
;             break;
700abae8: e003         	b	0x700abaf2 <UART_divisorValCompute+0x62> @ imm = #0x6
700abaea: 2000         	movs	r0, #0x0
;             divisorValue = 0U;
700abaec: 9003         	str	r0, [sp, #0xc]
;             break;
700abaee: e000         	b	0x700abaf2 <UART_divisorValCompute+0x62> @ imm = #0x0
;             break;
700abaf0: e7ff         	b	0x700abaf2 <UART_divisorValCompute+0x62> @ imm = #-0x2
;     return divisorValue;
700abaf2: 9803         	ldr	r0, [sp, #0xc]
700abaf4: b008         	add	sp, #0x20
700abaf6: bd80         	pop	{r7, pc}
		...

700abb00 <CSL_udmapCppi5SetIds>:
; {
700abb00: b085         	sub	sp, #0x14
700abb02: 9004         	str	r0, [sp, #0x10]
700abb04: 9103         	str	r1, [sp, #0xc]
700abb06: 9202         	str	r2, [sp, #0x8]
700abb08: 9301         	str	r3, [sp, #0x4]
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700abb0a: 9803         	ldr	r0, [sp, #0xc]
700abb0c: 2803         	cmp	r0, #0x3
700abb0e: d114         	bne	0x700abb3a <CSL_udmapCppi5SetIds+0x3a> @ imm = #0x28
700abb10: e7ff         	b	0x700abb12 <CSL_udmapCppi5SetIds+0x12> @ imm = #-0x2
;         v = ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo;
700abb12: 9804         	ldr	r0, [sp, #0x10]
700abb14: 6840         	ldr	r0, [r0, #0x4]
700abb16: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_TRPD_PKTINFO_PKTID_MASK | CSL_UDMAP_CPPI5_TRPD_PKTINFO_FLOWID_MASK);
700abb18: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700abb1c: 0600         	lsls	r0, r0, #0x18
700abb1e: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700abb20: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_FLOWID, flowId );
700abb22: 9901         	ldr	r1, [sp, #0x4]
700abb24: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_TRPD_PKTINFO_PKTID, pktId )   |
700abb28: f360 3197    	bfi	r1, r0, #14, #10
700abb2c: 9800         	ldr	r0, [sp]
700abb2e: 4308         	orrs	r0, r1
700abb30: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5TRPD *)pDesc)->pktInfo = v;
700abb32: 9800         	ldr	r0, [sp]
700abb34: 9904         	ldr	r1, [sp, #0x10]
700abb36: 6048         	str	r0, [r1, #0x4]
;     }
700abb38: e013         	b	0x700abb62 <CSL_udmapCppi5SetIds+0x62> @ imm = #0x26
;         v = ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1;
700abb3a: 9804         	ldr	r0, [sp, #0x10]
700abb3c: 6840         	ldr	r0, [r0, #0x4]
700abb3e: 9000         	str	r0, [sp]
;         v &= ~(CSL_UDMAP_CPPI5_PD_PKTINFO1_PKTID_MASK | CSL_UDMAP_CPPI5_PD_PKTINFO1_FLOWID_MASK);
700abb40: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700abb44: 0600         	lsls	r0, r0, #0x18
700abb46: 9000         	str	r0, [sp]
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700abb48: 9802         	ldr	r0, [sp, #0x8]
;              CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_FLOWID, flowId );
700abb4a: 9901         	ldr	r1, [sp, #0x4]
700abb4c: f36f 319f    	bfc	r1, #14, #18
;         v |= CSL_FMK( UDMAP_CPPI5_PD_PKTINFO1_PKTID, pktId )   |
700abb50: f360 3197    	bfi	r1, r0, #14, #10
700abb54: 9800         	ldr	r0, [sp]
700abb56: 4308         	orrs	r0, r1
700abb58: 9000         	str	r0, [sp]
;         ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1 = v;
700abb5a: 9800         	ldr	r0, [sp]
700abb5c: 9904         	ldr	r1, [sp, #0x10]
700abb5e: 6048         	str	r0, [r1, #0x4]
700abb60: e7ff         	b	0x700abb62 <CSL_udmapCppi5SetIds+0x62> @ imm = #-0x2
; }
700abb62: b005         	add	sp, #0x14
700abb64: 4770         	bx	lr
		...
700abb6e: 0000         	movs	r0, r0

700abb70 <Sciclient_rmIrGetInst>:
; {
700abb70: b083         	sub	sp, #0xc
700abb72: f8ad 000a    	strh.w	r0, [sp, #0xa]
700abb76: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIrInst *inst = NULL;
700abb78: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700abb7a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700abb7e: e7ff         	b	0x700abb80 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x2
700abb80: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700abb84: 2803         	cmp	r0, #0x3
700abb86: dc22         	bgt	0x700abbce <Sciclient_rmIrGetInst+0x5e> @ imm = #0x44
700abb88: e7ff         	b	0x700abb8a <Sciclient_rmIrGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIrInstances[i].dev_id) {
700abb8a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700abb8e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700abb92: eb01 0241    	add.w	r2, r1, r1, lsl #1
700abb96: f242 71c4    	movw	r1, #0x27c4
700abb9a: f2c7 010b    	movt	r1, #0x700b
700abb9e: f831 1032    	ldrh.w	r1, [r1, r2, lsl #3]
700abba2: 4288         	cmp	r0, r1
700abba4: d10c         	bne	0x700abbc0 <Sciclient_rmIrGetInst+0x50> @ imm = #0x18
700abba6: e7ff         	b	0x700abba8 <Sciclient_rmIrGetInst+0x38> @ imm = #-0x2
;             inst = &gRmIrInstances[i];
700abba8: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700abbac: eb00 0140    	add.w	r1, r0, r0, lsl #1
700abbb0: f242 70c4    	movw	r0, #0x27c4
700abbb4: f2c7 000b    	movt	r0, #0x700b
700abbb8: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700abbbc: 9001         	str	r0, [sp, #0x4]
;             break;
700abbbe: e006         	b	0x700abbce <Sciclient_rmIrGetInst+0x5e> @ imm = #0xc
;     }
700abbc0: e7ff         	b	0x700abbc2 <Sciclient_rmIrGetInst+0x52> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IR_NUM_INST; i++) {
700abbc2: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700abbc6: 3001         	adds	r0, #0x1
700abbc8: f8ad 0002    	strh.w	r0, [sp, #0x2]
700abbcc: e7d8         	b	0x700abb80 <Sciclient_rmIrGetInst+0x10> @ imm = #-0x50
;     return inst;
700abbce: 9801         	ldr	r0, [sp, #0x4]
700abbd0: b003         	add	sp, #0xc
700abbd2: 4770         	bx	lr
		...

700abbe0 <UART_fifoRegisterWrite>:
; {
700abbe0: b580         	push	{r7, lr}
700abbe2: b088         	sub	sp, #0x20
700abbe4: 9007         	str	r0, [sp, #0x1c]
700abbe6: 9106         	str	r1, [sp, #0x18]
700abbe8: 2000         	movs	r0, #0x0
;     uint32_t isTxRxFifoEmpty = FALSE;
700abbea: 9001         	str	r0, [sp, #0x4]
700abbec: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_A);
700abbee: 9807         	ldr	r0, [sp, #0x1c]
700abbf0: 2180         	movs	r1, #0x80
700abbf2: f000 fdc5    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #0xb8a
700abbf6: 9901         	ldr	r1, [sp, #0x4]
700abbf8: 9003         	str	r0, [sp, #0xc]
;     divLatchRegVal = UART_divisorLatchWrite(baseAddr, 0x0000U);
700abbfa: 9807         	ldr	r0, [sp, #0x1c]
700abbfc: f7f8 ffb0    	bl	0x700a4b60 <UART_divisorLatchWrite> @ imm = #-0x70a0
700abc00: 9005         	str	r0, [sp, #0x14]
;     enhanFnBitVal = UART_enhanFuncEnable(baseAddr);
700abc02: 9807         	ldr	r0, [sp, #0x1c]
700abc04: f002 fa5c    	bl	0x700ae0c0 <UART_enhanFuncEnable> @ imm = #0x24b8
700abc08: 9004         	str	r0, [sp, #0x10]
;     HW_WR_REG32(baseAddr + UART_FCR, fcrValue);
700abc0a: 9807         	ldr	r0, [sp, #0x1c]
700abc0c: 3008         	adds	r0, #0x8
700abc0e: 9906         	ldr	r1, [sp, #0x18]
700abc10: f003 ffb6    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x3f6c
;     while(isTxRxFifoEmpty == FALSE)
700abc14: e7ff         	b	0x700abc16 <UART_fifoRegisterWrite+0x36> @ imm = #-0x2
700abc16: 9802         	ldr	r0, [sp, #0x8]
700abc18: b928         	cbnz	r0, 0x700abc26 <UART_fifoRegisterWrite+0x46> @ imm = #0xa
700abc1a: e7ff         	b	0x700abc1c <UART_fifoRegisterWrite+0x3c> @ imm = #-0x2
;         isTxRxFifoEmpty = UART_IsTxRxFifoEmpty(baseAddr);
700abc1c: 9807         	ldr	r0, [sp, #0x1c]
700abc1e: f002 fa2f    	bl	0x700ae080 <UART_IsTxRxFifoEmpty> @ imm = #0x245e
700abc22: 9002         	str	r0, [sp, #0x8]
;     while(isTxRxFifoEmpty == FALSE)
700abc24: e7f7         	b	0x700abc16 <UART_fifoRegisterWrite+0x36> @ imm = #-0x12
;     UART_enhanFuncBitValRestore(baseAddr, enhanFnBitVal);
700abc26: 9807         	ldr	r0, [sp, #0x1c]
700abc28: 9904         	ldr	r1, [sp, #0x10]
700abc2a: f002 fd61    	bl	0x700ae6f0 <UART_enhanFuncBitValRestore> @ imm = #0x2ac2
;     (void) UART_divisorLatchWrite(baseAddr, divLatchRegVal);
700abc2e: 9807         	ldr	r0, [sp, #0x1c]
700abc30: 9905         	ldr	r1, [sp, #0x14]
700abc32: f7f8 ff95    	bl	0x700a4b60 <UART_divisorLatchWrite> @ imm = #-0x70d6
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700abc36: 9807         	ldr	r0, [sp, #0x1c]
700abc38: 300c         	adds	r0, #0xc
700abc3a: 9903         	ldr	r1, [sp, #0xc]
700abc3c: f003 ffa0    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x3f40
; }
700abc40: b008         	add	sp, #0x20
700abc42: bd80         	pop	{r7, pc}
		...

700abc50 <UART_lld_deInitDma>:
; {
700abc50: b580         	push	{r7, lr}
700abc52: b084         	sub	sp, #0x10
700abc54: 9003         	str	r0, [sp, #0xc]
700abc56: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700abc58: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700abc5a: 9803         	ldr	r0, [sp, #0xc]
700abc5c: b318         	cbz	r0, 0x700abca6 <UART_lld_deInitDma+0x56> @ imm = #0x46
700abc5e: e7ff         	b	0x700abc60 <UART_lld_deInitDma+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700abc60: 9903         	ldr	r1, [sp, #0xc]
700abc62: 2002         	movs	r0, #0x2
700abc64: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700abc66: 9803         	ldr	r0, [sp, #0xc]
700abc68: f7fe fc02    	bl	0x700aa470 <UART_lld_flushTxFifo> @ imm = #-0x17fc
700abc6c: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700abc6e: 9802         	ldr	r0, [sp, #0x8]
700abc70: b9a0         	cbnz	r0, 0x700abc9c <UART_lld_deInitDma+0x4c> @ imm = #0x28
700abc72: e7ff         	b	0x700abc74 <UART_lld_deInitDma+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700abc74: 9803         	ldr	r0, [sp, #0xc]
700abc76: 6800         	ldr	r0, [r0]
700abc78: 2107         	movs	r1, #0x7
700abc7a: 9101         	str	r1, [sp, #0x4]
700abc7c: f7fa fb68    	bl	0x700a6350 <UART_intrDisable> @ imm = #-0x5930
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700abc80: 9803         	ldr	r0, [sp, #0xc]
700abc82: 6800         	ldr	r0, [r0]
700abc84: 2102         	movs	r1, #0x2
700abc86: f003 f883    	bl	0x700aed90 <UART_intr2Disable> @ imm = #0x3106
700abc8a: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700abc8c: 9803         	ldr	r0, [sp, #0xc]
700abc8e: 6800         	ldr	r0, [r0]
700abc90: f003 f8c6    	bl	0x700aee20 <UART_operatingModeSelect> @ imm = #0x318c
;             hUart->state = UART_STATE_RESET;
700abc94: 9903         	ldr	r1, [sp, #0xc]
700abc96: 2000         	movs	r0, #0x0
700abc98: 6548         	str	r0, [r1, #0x54]
;         }
700abc9a: e7ff         	b	0x700abc9c <UART_lld_deInitDma+0x4c> @ imm = #-0x2
;         status = UART_lld_dmaDeInit(hUart);
700abc9c: 9803         	ldr	r0, [sp, #0xc]
700abc9e: f002 fa2f    	bl	0x700ae100 <UART_lld_dmaDeInit> @ imm = #0x245e
700abca2: 9002         	str	r0, [sp, #0x8]
;     }
700abca4: e003         	b	0x700abcae <UART_lld_deInitDma+0x5e> @ imm = #0x6
700abca6: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700abcaa: 9002         	str	r0, [sp, #0x8]
700abcac: e7ff         	b	0x700abcae <UART_lld_deInitDma+0x5e> @ imm = #-0x2
;     return status;
700abcae: 9802         	ldr	r0, [sp, #0x8]
700abcb0: b004         	add	sp, #0x10
700abcb2: bd80         	pop	{r7, pc}
		...

700abcc0 <Udma_rmFreeEvent>:
; {
700abcc0: b580         	push	{r7, lr}
700abcc2: b088         	sub	sp, #0x20
700abcc4: 9007         	str	r0, [sp, #0x1c]
700abcc6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abcc8: 9806         	ldr	r0, [sp, #0x18]
700abcca: f500 70ea    	add.w	r0, r0, #0x1d4
700abcce: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abcd0: 9806         	ldr	r0, [sp, #0x18]
700abcd2: f500 609f    	add.w	r0, r0, #0x4f8
700abcd6: f04f 31ff    	mov.w	r1, #0xffffffff
700abcda: f7fe fd79    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x150e
;     i = globalEvent - rmInitPrms->startGlobalEvent;
700abcde: 9807         	ldr	r0, [sp, #0x1c]
700abce0: 9901         	ldr	r1, [sp, #0x4]
700abce2: f8d1 10d8    	ldr.w	r1, [r1, #0xd8]
700abce6: 1a40         	subs	r0, r0, r1
700abce8: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abcea: 9805         	ldr	r0, [sp, #0x14]
700abcec: 0940         	lsrs	r0, r0, #0x5
700abcee: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abcf0: 9805         	ldr	r0, [sp, #0x14]
700abcf2: 9904         	ldr	r1, [sp, #0x10]
700abcf4: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abcf8: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abcfa: 9903         	ldr	r1, [sp, #0xc]
700abcfc: 2001         	movs	r0, #0x1
700abcfe: 4088         	lsls	r0, r1
700abd00: 9002         	str	r0, [sp, #0x8]
;     drvHandle->globalEventFlag[offset] |= bitMask;
700abd02: 9a02         	ldr	r2, [sp, #0x8]
700abd04: 9806         	ldr	r0, [sp, #0x18]
700abd06: 9904         	ldr	r1, [sp, #0x10]
700abd08: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abd0c: f8d1 0424    	ldr.w	r0, [r1, #0x424]
700abd10: 4310         	orrs	r0, r2
700abd12: f8c1 0424    	str.w	r0, [r1, #0x424]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abd16: 9806         	ldr	r0, [sp, #0x18]
700abd18: f500 609f    	add.w	r0, r0, #0x4f8
700abd1c: f000 f8e8    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x1d0
;     return;
700abd20: b008         	add	sp, #0x20
700abd22: bd80         	pop	{r7, pc}
		...

700abd30 <Udma_rmFreeIrIntr>:
; {
700abd30: b580         	push	{r7, lr}
700abd32: b088         	sub	sp, #0x20
700abd34: 9007         	str	r0, [sp, #0x1c]
700abd36: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abd38: 9806         	ldr	r0, [sp, #0x18]
700abd3a: f500 70ea    	add.w	r0, r0, #0x1d4
700abd3e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abd40: 9806         	ldr	r0, [sp, #0x18]
700abd42: f500 609f    	add.w	r0, r0, #0x4f8
700abd46: f04f 31ff    	mov.w	r1, #0xffffffff
700abd4a: f7fe fd41    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x157e
;     i = irIntrNum - rmInitPrms->startIrIntr;
700abd4e: 9807         	ldr	r0, [sp, #0x1c]
700abd50: 9901         	ldr	r1, [sp, #0x4]
700abd52: f8d1 10e8    	ldr.w	r1, [r1, #0xe8]
700abd56: 1a40         	subs	r0, r0, r1
700abd58: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abd5a: 9805         	ldr	r0, [sp, #0x14]
700abd5c: 0940         	lsrs	r0, r0, #0x5
700abd5e: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abd60: 9805         	ldr	r0, [sp, #0x14]
700abd62: 9904         	ldr	r1, [sp, #0x10]
700abd64: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abd68: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abd6a: 9903         	ldr	r1, [sp, #0xc]
700abd6c: 2001         	movs	r0, #0x1
700abd6e: 4088         	lsls	r0, r1
700abd70: 9002         	str	r0, [sp, #0x8]
;     drvHandle->irIntrFlag[offset] |= bitMask;
700abd72: 9a02         	ldr	r2, [sp, #0x8]
700abd74: 9806         	ldr	r0, [sp, #0x18]
700abd76: 9904         	ldr	r1, [sp, #0x10]
700abd78: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abd7c: f8d1 04e4    	ldr.w	r0, [r1, #0x4e4]
700abd80: 4310         	orrs	r0, r2
700abd82: f8c1 04e4    	str.w	r0, [r1, #0x4e4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abd86: 9806         	ldr	r0, [sp, #0x18]
700abd88: f500 609f    	add.w	r0, r0, #0x4f8
700abd8c: f000 f8b0    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0x160
;     return;
700abd90: b008         	add	sp, #0x20
700abd92: bd80         	pop	{r7, pc}
		...

700abda0 <Udma_rmFreeVintr>:
; {
700abda0: b580         	push	{r7, lr}
700abda2: b088         	sub	sp, #0x20
700abda4: 9007         	str	r0, [sp, #0x1c]
700abda6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abda8: 9806         	ldr	r0, [sp, #0x18]
700abdaa: f500 70ea    	add.w	r0, r0, #0x1d4
700abdae: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abdb0: 9806         	ldr	r0, [sp, #0x18]
700abdb2: f500 609f    	add.w	r0, r0, #0x4f8
700abdb6: f04f 31ff    	mov.w	r1, #0xffffffff
700abdba: f7fe fd09    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x15ee
;     i = vintrNum - rmInitPrms->startVintr;
700abdbe: 9807         	ldr	r0, [sp, #0x1c]
700abdc0: 9901         	ldr	r1, [sp, #0x4]
700abdc2: f8d1 10e0    	ldr.w	r1, [r1, #0xe0]
700abdc6: 1a40         	subs	r0, r0, r1
700abdc8: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abdca: 9805         	ldr	r0, [sp, #0x14]
700abdcc: 0940         	lsrs	r0, r0, #0x5
700abdce: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abdd0: 9805         	ldr	r0, [sp, #0x14]
700abdd2: 9904         	ldr	r1, [sp, #0x10]
700abdd4: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700abdd8: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700abdda: 9903         	ldr	r1, [sp, #0xc]
700abddc: 2001         	movs	r0, #0x1
700abdde: 4088         	lsls	r0, r1
700abde0: 9002         	str	r0, [sp, #0x8]
;     drvHandle->vintrFlag[offset] |= bitMask;
700abde2: 9a02         	ldr	r2, [sp, #0x8]
700abde4: 9806         	ldr	r0, [sp, #0x18]
700abde6: 9904         	ldr	r1, [sp, #0x10]
700abde8: eb00 0181    	add.w	r1, r0, r1, lsl #2
700abdec: f8d1 04a4    	ldr.w	r0, [r1, #0x4a4]
700abdf0: 4310         	orrs	r0, r2
700abdf2: f8c1 04a4    	str.w	r0, [r1, #0x4a4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700abdf6: 9806         	ldr	r0, [sp, #0x18]
700abdf8: f500 609f    	add.w	r0, r0, #0x4f8
700abdfc: f000 f878    	bl	0x700abef0 <SemaphoreP_post> @ imm = #0xf0
;     return;
700abe00: b008         	add	sp, #0x20
700abe02: bd80         	pop	{r7, pc}
		...

700abe10 <vApplicationLoadHook>:
; {
700abe10: b580         	push	{r7, lr}
700abe12: b082         	sub	sp, #0x8
;     uint64_t curUpdateTime = ClockP_getTimeUsec();
700abe14: f7fe feb4    	bl	0x700aab80 <ClockP_getTimeUsec> @ imm = #-0x1298
700abe18: 9101         	str	r1, [sp, #0x4]
700abe1a: 9000         	str	r0, [sp]
;     if( (curUpdateTime > lastUpdateTime) && ((curUpdateTime - lastUpdateTime) > (TaskP_LOAD_UPDATE_WINDOW_MSEC*1000u )) )
700abe1c: 9b00         	ldr	r3, [sp]
700abe1e: 9901         	ldr	r1, [sp, #0x4]
700abe20: f642 10b8    	movw	r0, #0x29b8
700abe24: f2c7 000b    	movt	r0, #0x700b
700abe28: 6802         	ldr	r2, [r0]
700abe2a: 6840         	ldr	r0, [r0, #0x4]
700abe2c: 1ad2         	subs	r2, r2, r3
700abe2e: 4188         	sbcs	r0, r1
700abe30: d21e         	bhs	0x700abe70 <vApplicationLoadHook+0x60> @ imm = #0x3c
700abe32: e7ff         	b	0x700abe34 <vApplicationLoadHook+0x24> @ imm = #-0x2
700abe34: 9900         	ldr	r1, [sp]
700abe36: 9801         	ldr	r0, [sp, #0x4]
700abe38: f642 12b8    	movw	r2, #0x29b8
700abe3c: f2c7 020b    	movt	r2, #0x700b
700abe40: 6813         	ldr	r3, [r2]
700abe42: 6852         	ldr	r2, [r2, #0x4]
700abe44: 1ac9         	subs	r1, r1, r3
700abe46: 4190         	sbcs	r0, r2
700abe48: f24a 1221    	movw	r2, #0xa121
700abe4c: f2c0 0207    	movt	r2, #0x7
700abe50: 1a89         	subs	r1, r1, r2
700abe52: f170 0000    	sbcs	r0, r0, #0x0
700abe56: d30b         	blo	0x700abe70 <vApplicationLoadHook+0x60> @ imm = #0x16
700abe58: e7ff         	b	0x700abe5a <vApplicationLoadHook+0x4a> @ imm = #-0x2
;         TaskP_loadUpdateAll();
700abe5a: f7f8 fcd9    	bl	0x700a4810 <TaskP_loadUpdateAll> @ imm = #-0x764e
;         lastUpdateTime = curUpdateTime;
700abe5e: 9800         	ldr	r0, [sp]
700abe60: 9a01         	ldr	r2, [sp, #0x4]
700abe62: f642 11b8    	movw	r1, #0x29b8
700abe66: f2c7 010b    	movt	r1, #0x700b
700abe6a: 604a         	str	r2, [r1, #0x4]
700abe6c: 6008         	str	r0, [r1]
;     }
700abe6e: e7ff         	b	0x700abe70 <vApplicationLoadHook+0x60> @ imm = #-0x2
; }
700abe70: b002         	add	sp, #0x8
700abe72: bd80         	pop	{r7, pc}
		...

700abe80 <vQueueWaitForMessageRestricted>:
;     {
700abe80: b580         	push	{r7, lr}
700abe82: b084         	sub	sp, #0x10
700abe84: 9003         	str	r0, [sp, #0xc]
700abe86: 9102         	str	r1, [sp, #0x8]
700abe88: 9201         	str	r2, [sp, #0x4]
;         Queue_t * const pxQueue = xQueue;
700abe8a: 9803         	ldr	r0, [sp, #0xc]
700abe8c: 9000         	str	r0, [sp]
;         prvLockQueue( pxQueue );
700abe8e: f002 fc6f    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x28de
700abe92: 9800         	ldr	r0, [sp]
700abe94: f990 0044    	ldrsb.w	r0, [r0, #0x44]
700abe98: 3001         	adds	r0, #0x1
700abe9a: b928         	cbnz	r0, 0x700abea8 <vQueueWaitForMessageRestricted+0x28> @ imm = #0xa
700abe9c: e7ff         	b	0x700abe9e <vQueueWaitForMessageRestricted+0x1e> @ imm = #-0x2
700abe9e: 9900         	ldr	r1, [sp]
700abea0: 2000         	movs	r0, #0x0
700abea2: f881 0044    	strb.w	r0, [r1, #0x44]
700abea6: e7ff         	b	0x700abea8 <vQueueWaitForMessageRestricted+0x28> @ imm = #-0x2
700abea8: 9800         	ldr	r0, [sp]
700abeaa: f990 0045    	ldrsb.w	r0, [r0, #0x45]
700abeae: 3001         	adds	r0, #0x1
700abeb0: b928         	cbnz	r0, 0x700abebe <vQueueWaitForMessageRestricted+0x3e> @ imm = #0xa
700abeb2: e7ff         	b	0x700abeb4 <vQueueWaitForMessageRestricted+0x34> @ imm = #-0x2
700abeb4: 9900         	ldr	r1, [sp]
700abeb6: 2000         	movs	r0, #0x0
700abeb8: f881 0045    	strb.w	r0, [r1, #0x45]
700abebc: e7ff         	b	0x700abebe <vQueueWaitForMessageRestricted+0x3e> @ imm = #-0x2
700abebe: f001 fd17    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x1a2e
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
700abec2: 9800         	ldr	r0, [sp]
700abec4: 6b80         	ldr	r0, [r0, #0x38]
700abec6: b938         	cbnz	r0, 0x700abed8 <vQueueWaitForMessageRestricted+0x58> @ imm = #0xe
700abec8: e7ff         	b	0x700abeca <vQueueWaitForMessageRestricted+0x4a> @ imm = #-0x2
;             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
700abeca: 9800         	ldr	r0, [sp]
700abecc: 3024         	adds	r0, #0x24
700abece: 9902         	ldr	r1, [sp, #0x8]
700abed0: 9a01         	ldr	r2, [sp, #0x4]
700abed2: f002 fad5    	bl	0x700ae480 <vTaskPlaceOnEventListRestricted> @ imm = #0x25aa
;         }
700abed6: e000         	b	0x700abeda <vQueueWaitForMessageRestricted+0x5a> @ imm = #0x0
700abed8: e7ff         	b	0x700abeda <vQueueWaitForMessageRestricted+0x5a> @ imm = #-0x2
;         prvUnlockQueue( pxQueue );
700abeda: 9800         	ldr	r0, [sp]
700abedc: f7fb ffd8    	bl	0x700a7e90 <prvUnlockQueue> @ imm = #-0x4050
;     }
700abee0: b004         	add	sp, #0x10
700abee2: bd80         	pop	{r7, pc}
		...

700abef0 <SemaphoreP_post>:
; {
700abef0: b580         	push	{r7, lr}
700abef2: b084         	sub	sp, #0x10
700abef4: 9003         	str	r0, [sp, #0xc]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700abef6: 9803         	ldr	r0, [sp, #0xc]
700abef8: 9002         	str	r0, [sp, #0x8]
;     if(pSemaphore->isRecursiveMutex != 0U)
700abefa: 9802         	ldr	r0, [sp, #0x8]
700abefc: 6d40         	ldr	r0, [r0, #0x54]
700abefe: b170         	cbz	r0, 0x700abf1e <SemaphoreP_post+0x2e> @ imm = #0x1c
700abf00: e7ff         	b	0x700abf02 <SemaphoreP_post+0x12> @ imm = #-0x2
;         if( HwiP_inISR() == 0U)
700abf02: f004 fa4d    	bl	0x700b03a0 <HwiP_inISR> @ imm = #0x449a
700abf06: b928         	cbnz	r0, 0x700abf14 <SemaphoreP_post+0x24> @ imm = #0xa
700abf08: e7ff         	b	0x700abf0a <SemaphoreP_post+0x1a> @ imm = #-0x2
;             (void)xSemaphoreGiveRecursive(pSemaphore->semHndl);
700abf0a: 9802         	ldr	r0, [sp, #0x8]
700abf0c: 6d00         	ldr	r0, [r0, #0x50]
700abf0e: f001 f95f    	bl	0x700ad1d0 <xQueueGiveMutexRecursive> @ imm = #0x12be
;         }
700abf12: e003         	b	0x700abf1c <SemaphoreP_post+0x2c> @ imm = #0x6
700abf14: 2000         	movs	r0, #0x0
;             DebugP_assertNoLog(0);
700abf16: f005 f9e3    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x53c6
700abf1a: e7ff         	b	0x700abf1c <SemaphoreP_post+0x2c> @ imm = #-0x2
;     }
700abf1c: e017         	b	0x700abf4e <SemaphoreP_post+0x5e> @ imm = #0x2e
;         if( HwiP_inISR() != 0U)
700abf1e: f004 fa3f    	bl	0x700b03a0 <HwiP_inISR> @ imm = #0x447e
700abf22: b158         	cbz	r0, 0x700abf3c <SemaphoreP_post+0x4c> @ imm = #0x16
700abf24: e7ff         	b	0x700abf26 <SemaphoreP_post+0x36> @ imm = #-0x2
700abf26: 2000         	movs	r0, #0x0
;             BaseType_t xHigherPriorityTaskWoken = 0;
700abf28: 9001         	str	r0, [sp, #0x4]
;             (void)xSemaphoreGiveFromISR(pSemaphore->semHndl, &xHigherPriorityTaskWoken);
700abf2a: 9802         	ldr	r0, [sp, #0x8]
700abf2c: 6d00         	ldr	r0, [r0, #0x50]
700abf2e: a901         	add	r1, sp, #0x4
700abf30: f7fd fdae    	bl	0x700a9a90 <xQueueGiveFromISR> @ imm = #-0x24a4
;             portYIELD_FROM_ISR((uint32_t)xHigherPriorityTaskWoken);
700abf34: 9801         	ldr	r0, [sp, #0x4]
700abf36: f003 fb53    	bl	0x700af5e0 <vPortYeildFromISR> @ imm = #0x36a6
;         }
700abf3a: e007         	b	0x700abf4c <SemaphoreP_post+0x5c> @ imm = #0xe
;             (void)xSemaphoreGive(pSemaphore->semHndl);
700abf3c: 9802         	ldr	r0, [sp, #0x8]
700abf3e: 6d00         	ldr	r0, [r0, #0x50]
700abf40: 2300         	movs	r3, #0x0
700abf42: 4619         	mov	r1, r3
700abf44: 461a         	mov	r2, r3
700abf46: f7f7 f9d3    	bl	0x700a32f0 <xQueueGenericSend> @ imm = #-0x8c5a
700abf4a: e7ff         	b	0x700abf4c <SemaphoreP_post+0x5c> @ imm = #-0x2
700abf4c: e7ff         	b	0x700abf4e <SemaphoreP_post+0x5e> @ imm = #-0x2
; }
700abf4e: b004         	add	sp, #0x10
700abf50: bd80         	pop	{r7, pc}
		...
700abf5e: 0000         	movs	r0, r0

700abf60 <UdmaEventPrms_init>:
; {
700abf60: b082         	sub	sp, #0x8
700abf62: 9001         	str	r0, [sp, #0x4]
;     if(NULL_PTR != eventPrms)
700abf64: 9801         	ldr	r0, [sp, #0x4]
700abf66: b350         	cbz	r0, 0x700abfbe <UdmaEventPrms_init+0x5e> @ imm = #0x54
700abf68: e7ff         	b	0x700abf6a <UdmaEventPrms_init+0xa> @ imm = #-0x2
;         eventPrms->eventType            = UDMA_EVENT_TYPE_DMA_COMPLETION;
700abf6a: 9801         	ldr	r0, [sp, #0x4]
700abf6c: 2101         	movs	r1, #0x1
700abf6e: 6001         	str	r1, [r0]
;         eventPrms->eventMode            = UDMA_EVENT_MODE_SHARED;
700abf70: 9a01         	ldr	r2, [sp, #0x4]
700abf72: 2002         	movs	r0, #0x2
700abf74: 6050         	str	r0, [r2, #0x4]
;         eventPrms->chHandle             = (Udma_ChHandle) NULL_PTR;
700abf76: 9a01         	ldr	r2, [sp, #0x4]
700abf78: 2000         	movs	r0, #0x0
700abf7a: 9000         	str	r0, [sp]
700abf7c: 6090         	str	r0, [r2, #0x8]
;         eventPrms->ringHandle           = (Udma_RingHandle) NULL_PTR;
700abf7e: 9a01         	ldr	r2, [sp, #0x4]
700abf80: 60d0         	str	r0, [r2, #0xc]
;         eventPrms->controllerEventHandle    = (Udma_EventHandle) NULL_PTR;
700abf82: 9a01         	ldr	r2, [sp, #0x4]
700abf84: 6110         	str	r0, [r2, #0x10]
;         eventPrms->eventCb              = (Udma_EventCallback) NULL_PTR;
700abf86: 9a01         	ldr	r2, [sp, #0x4]
700abf88: 6150         	str	r0, [r2, #0x14]
;         eventPrms->intrPriority         = 1U;
700abf8a: 9a01         	ldr	r2, [sp, #0x4]
700abf8c: 6191         	str	r1, [r2, #0x18]
;         eventPrms->appData              = NULL_PTR;
700abf8e: 9901         	ldr	r1, [sp, #0x4]
700abf90: 61c8         	str	r0, [r1, #0x1c]
;         eventPrms->preferredCoreIntrNum = UDMA_CORE_INTR_ANY;
700abf92: 9a01         	ldr	r2, [sp, #0x4]
700abf94: 2101         	movs	r1, #0x1
700abf96: f6cf 71ff    	movt	r1, #0xffff
700abf9a: 6211         	str	r1, [r2, #0x20]
;         eventPrms->intrStatusReg        = (volatile uint64_t *) NULL_PTR;
700abf9c: 9901         	ldr	r1, [sp, #0x4]
700abf9e: 6248         	str	r0, [r1, #0x24]
;         eventPrms->intrClearReg         = (volatile uint64_t *) NULL_PTR;
700abfa0: 9901         	ldr	r1, [sp, #0x4]
700abfa2: 6288         	str	r0, [r1, #0x28]
;         eventPrms->intrMask             = 0U;
700abfa4: 9901         	ldr	r1, [sp, #0x4]
700abfa6: 6348         	str	r0, [r1, #0x34]
700abfa8: 6308         	str	r0, [r1, #0x30]
;         eventPrms->vintrNum             = UDMA_EVENT_INVALID;
700abfaa: 9901         	ldr	r1, [sp, #0x4]
700abfac: f64f 70ff    	movw	r0, #0xffff
700abfb0: 6388         	str	r0, [r1, #0x38]
;         eventPrms->coreIntrNum          = UDMA_INTR_INVALID;
700abfb2: 9901         	ldr	r1, [sp, #0x4]
700abfb4: 2000         	movs	r0, #0x0
700abfb6: f6cf 70ff    	movt	r0, #0xffff
700abfba: 63c8         	str	r0, [r1, #0x3c]
;     }
700abfbc: e7ff         	b	0x700abfbe <UdmaEventPrms_init+0x5e> @ imm = #-0x2
;     return;
700abfbe: b002         	add	sp, #0x8
700abfc0: 4770         	bx	lr
		...
700abfce: 0000         	movs	r0, r0

700abfd0 <Udma_rmFreeBlkCopyCh>:
; {
700abfd0: b580         	push	{r7, lr}
700abfd2: b088         	sub	sp, #0x20
700abfd4: 9007         	str	r0, [sp, #0x1c]
700abfd6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700abfd8: 9806         	ldr	r0, [sp, #0x18]
700abfda: f500 70ea    	add.w	r0, r0, #0x1d4
700abfde: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700abfe0: 9806         	ldr	r0, [sp, #0x18]
700abfe2: f500 609f    	add.w	r0, r0, #0x4f8
700abfe6: f04f 31ff    	mov.w	r1, #0xffffffff
700abfea: f7fe fbf1    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x181e
;     i = chNum - rmInitPrms->startBlkCopyCh;
700abfee: 9807         	ldr	r0, [sp, #0x1c]
700abff0: 9901         	ldr	r1, [sp, #0x4]
700abff2: 6909         	ldr	r1, [r1, #0x10]
700abff4: 1a40         	subs	r0, r0, r1
700abff6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700abff8: 9805         	ldr	r0, [sp, #0x14]
700abffa: 0940         	lsrs	r0, r0, #0x5
700abffc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700abffe: 9805         	ldr	r0, [sp, #0x14]
700ac000: 9904         	ldr	r1, [sp, #0x10]
700ac002: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac006: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac008: 9903         	ldr	r1, [sp, #0xc]
700ac00a: 2001         	movs	r0, #0x1
700ac00c: 4088         	lsls	r0, r1
700ac00e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyChFlag[offset] |= bitMask;
700ac010: 9a02         	ldr	r2, [sp, #0x8]
700ac012: 9806         	ldr	r0, [sp, #0x18]
700ac014: 9904         	ldr	r1, [sp, #0x10]
700ac016: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac01a: f8d1 02c8    	ldr.w	r0, [r1, #0x2c8]
700ac01e: 4310         	orrs	r0, r2
700ac020: f8c1 02c8    	str.w	r0, [r1, #0x2c8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac024: 9806         	ldr	r0, [sp, #0x18]
700ac026: f500 609f    	add.w	r0, r0, #0x4f8
700ac02a: f7ff ff61    	bl	0x700abef0 <SemaphoreP_post> @ imm = #-0x13e
;     return;
700ac02e: b008         	add	sp, #0x20
700ac030: bd80         	pop	{r7, pc}
		...
700ac03e: 0000         	movs	r0, r0

700ac040 <Udma_rmFreeBlkCopyHcCh>:
; {
700ac040: b580         	push	{r7, lr}
700ac042: b088         	sub	sp, #0x20
700ac044: 9007         	str	r0, [sp, #0x1c]
700ac046: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac048: 9806         	ldr	r0, [sp, #0x18]
700ac04a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac04e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac050: 9806         	ldr	r0, [sp, #0x18]
700ac052: f500 609f    	add.w	r0, r0, #0x4f8
700ac056: f04f 31ff    	mov.w	r1, #0xffffffff
700ac05a: f7fe fbb9    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x188e
;     i = chNum - rmInitPrms->startBlkCopyHcCh;
700ac05e: 9807         	ldr	r0, [sp, #0x1c]
700ac060: 9901         	ldr	r1, [sp, #0x4]
700ac062: 6889         	ldr	r1, [r1, #0x8]
700ac064: 1a40         	subs	r0, r0, r1
700ac066: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac068: 9805         	ldr	r0, [sp, #0x14]
700ac06a: 0940         	lsrs	r0, r0, #0x5
700ac06c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac06e: 9805         	ldr	r0, [sp, #0x14]
700ac070: 9904         	ldr	r1, [sp, #0x10]
700ac072: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac076: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac078: 9903         	ldr	r1, [sp, #0xc]
700ac07a: 2001         	movs	r0, #0x1
700ac07c: 4088         	lsls	r0, r1
700ac07e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyHcChFlag[offset] |= bitMask;
700ac080: 9a02         	ldr	r2, [sp, #0x8]
700ac082: 9806         	ldr	r0, [sp, #0x18]
700ac084: 9904         	ldr	r1, [sp, #0x10]
700ac086: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac08a: f8d1 02cc    	ldr.w	r0, [r1, #0x2cc]
700ac08e: 4310         	orrs	r0, r2
700ac090: f8c1 02cc    	str.w	r0, [r1, #0x2cc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac094: 9806         	ldr	r0, [sp, #0x18]
700ac096: f500 609f    	add.w	r0, r0, #0x4f8
700ac09a: f7ff ff29    	bl	0x700abef0 <SemaphoreP_post> @ imm = #-0x1ae
;     return;
700ac09e: b008         	add	sp, #0x20
700ac0a0: bd80         	pop	{r7, pc}
		...
700ac0ae: 0000         	movs	r0, r0

700ac0b0 <Udma_rmFreeBlkCopyUhcCh>:
; {
700ac0b0: b580         	push	{r7, lr}
700ac0b2: b088         	sub	sp, #0x20
700ac0b4: 9007         	str	r0, [sp, #0x1c]
700ac0b6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac0b8: 9806         	ldr	r0, [sp, #0x18]
700ac0ba: f500 70ea    	add.w	r0, r0, #0x1d4
700ac0be: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac0c0: 9806         	ldr	r0, [sp, #0x18]
700ac0c2: f500 609f    	add.w	r0, r0, #0x4f8
700ac0c6: f04f 31ff    	mov.w	r1, #0xffffffff
700ac0ca: f7fe fb81    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x18fe
;     i = chNum - rmInitPrms->startBlkCopyUhcCh;
700ac0ce: 9807         	ldr	r0, [sp, #0x1c]
700ac0d0: 9901         	ldr	r1, [sp, #0x4]
700ac0d2: 6809         	ldr	r1, [r1]
700ac0d4: 1a40         	subs	r0, r0, r1
700ac0d6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac0d8: 9805         	ldr	r0, [sp, #0x14]
700ac0da: 0940         	lsrs	r0, r0, #0x5
700ac0dc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac0de: 9805         	ldr	r0, [sp, #0x14]
700ac0e0: 9904         	ldr	r1, [sp, #0x10]
700ac0e2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac0e6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac0e8: 9903         	ldr	r1, [sp, #0xc]
700ac0ea: 2001         	movs	r0, #0x1
700ac0ec: 4088         	lsls	r0, r1
700ac0ee: 9002         	str	r0, [sp, #0x8]
;     drvHandle->blkCopyUhcChFlag[offset] |= bitMask;
700ac0f0: 9a02         	ldr	r2, [sp, #0x8]
700ac0f2: 9806         	ldr	r0, [sp, #0x18]
700ac0f4: 9904         	ldr	r1, [sp, #0x10]
700ac0f6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac0fa: f8d1 02d0    	ldr.w	r0, [r1, #0x2d0]
700ac0fe: 4310         	orrs	r0, r2
700ac100: f8c1 02d0    	str.w	r0, [r1, #0x2d0]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac104: 9806         	ldr	r0, [sp, #0x18]
700ac106: f500 609f    	add.w	r0, r0, #0x4f8
700ac10a: f7ff fef1    	bl	0x700abef0 <SemaphoreP_post> @ imm = #-0x21e
;     return;
700ac10e: b008         	add	sp, #0x20
700ac110: bd80         	pop	{r7, pc}
		...
700ac11e: 0000         	movs	r0, r0

700ac120 <Udma_rmFreeRxCh>:
; {
700ac120: b580         	push	{r7, lr}
700ac122: b088         	sub	sp, #0x20
700ac124: 9007         	str	r0, [sp, #0x1c]
700ac126: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac128: 9806         	ldr	r0, [sp, #0x18]
700ac12a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac12e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac130: 9806         	ldr	r0, [sp, #0x18]
700ac132: f500 609f    	add.w	r0, r0, #0x4f8
700ac136: f04f 31ff    	mov.w	r1, #0xffffffff
700ac13a: f7fe fb49    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x196e
;     i = chNum - rmInitPrms->startRxCh;
700ac13e: 9807         	ldr	r0, [sp, #0x1c]
700ac140: 9901         	ldr	r1, [sp, #0x4]
700ac142: 6c09         	ldr	r1, [r1, #0x40]
700ac144: 1a40         	subs	r0, r0, r1
700ac146: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac148: 9805         	ldr	r0, [sp, #0x14]
700ac14a: 0940         	lsrs	r0, r0, #0x5
700ac14c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac14e: 9805         	ldr	r0, [sp, #0x14]
700ac150: 9904         	ldr	r1, [sp, #0x10]
700ac152: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac156: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac158: 9903         	ldr	r1, [sp, #0xc]
700ac15a: 2001         	movs	r0, #0x1
700ac15c: 4088         	lsls	r0, r1
700ac15e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxChFlag[offset] |= bitMask;
700ac160: 9a02         	ldr	r2, [sp, #0x8]
700ac162: 9806         	ldr	r0, [sp, #0x18]
700ac164: 9904         	ldr	r1, [sp, #0x10]
700ac166: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac16a: f8d1 02fc    	ldr.w	r0, [r1, #0x2fc]
700ac16e: 4310         	orrs	r0, r2
700ac170: f8c1 02fc    	str.w	r0, [r1, #0x2fc]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac174: 9806         	ldr	r0, [sp, #0x18]
700ac176: f500 609f    	add.w	r0, r0, #0x4f8
700ac17a: f7ff feb9    	bl	0x700abef0 <SemaphoreP_post> @ imm = #-0x28e
;     return;
700ac17e: b008         	add	sp, #0x20
700ac180: bd80         	pop	{r7, pc}
		...
700ac18e: 0000         	movs	r0, r0

700ac190 <Udma_rmFreeRxHcCh>:
; {
700ac190: b580         	push	{r7, lr}
700ac192: b088         	sub	sp, #0x20
700ac194: 9007         	str	r0, [sp, #0x1c]
700ac196: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac198: 9806         	ldr	r0, [sp, #0x18]
700ac19a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac19e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac1a0: 9806         	ldr	r0, [sp, #0x18]
700ac1a2: f500 609f    	add.w	r0, r0, #0x4f8
700ac1a6: f04f 31ff    	mov.w	r1, #0xffffffff
700ac1aa: f7fe fb11    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x19de
;     i = chNum - rmInitPrms->startRxHcCh;
700ac1ae: 9807         	ldr	r0, [sp, #0x1c]
700ac1b0: 9901         	ldr	r1, [sp, #0x4]
700ac1b2: 6b89         	ldr	r1, [r1, #0x38]
700ac1b4: 1a40         	subs	r0, r0, r1
700ac1b6: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac1b8: 9805         	ldr	r0, [sp, #0x14]
700ac1ba: 0940         	lsrs	r0, r0, #0x5
700ac1bc: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac1be: 9805         	ldr	r0, [sp, #0x14]
700ac1c0: 9904         	ldr	r1, [sp, #0x10]
700ac1c2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac1c6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac1c8: 9903         	ldr	r1, [sp, #0xc]
700ac1ca: 2001         	movs	r0, #0x1
700ac1cc: 4088         	lsls	r0, r1
700ac1ce: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxHcChFlag[offset] |= bitMask;
700ac1d0: 9a02         	ldr	r2, [sp, #0x8]
700ac1d2: 9806         	ldr	r0, [sp, #0x18]
700ac1d4: 9904         	ldr	r1, [sp, #0x10]
700ac1d6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac1da: f8d1 031c    	ldr.w	r0, [r1, #0x31c]
700ac1de: 4310         	orrs	r0, r2
700ac1e0: f8c1 031c    	str.w	r0, [r1, #0x31c]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac1e4: 9806         	ldr	r0, [sp, #0x18]
700ac1e6: f500 609f    	add.w	r0, r0, #0x4f8
700ac1ea: f7ff fe81    	bl	0x700abef0 <SemaphoreP_post> @ imm = #-0x2fe
;     return;
700ac1ee: b008         	add	sp, #0x20
700ac1f0: bd80         	pop	{r7, pc}
		...
700ac1fe: 0000         	movs	r0, r0

700ac200 <Udma_rmFreeRxUhcCh>:
; {
700ac200: b580         	push	{r7, lr}
700ac202: b088         	sub	sp, #0x20
700ac204: 9007         	str	r0, [sp, #0x1c]
700ac206: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac208: 9806         	ldr	r0, [sp, #0x18]
700ac20a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac20e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac210: 9806         	ldr	r0, [sp, #0x18]
700ac212: f500 609f    	add.w	r0, r0, #0x4f8
700ac216: f04f 31ff    	mov.w	r1, #0xffffffff
700ac21a: f7fe fad9    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x1a4e
;     i = chNum - rmInitPrms->startRxUhcCh;
700ac21e: 9807         	ldr	r0, [sp, #0x1c]
700ac220: 9901         	ldr	r1, [sp, #0x4]
700ac222: 6b09         	ldr	r1, [r1, #0x30]
700ac224: 1a40         	subs	r0, r0, r1
700ac226: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac228: 9805         	ldr	r0, [sp, #0x14]
700ac22a: 0940         	lsrs	r0, r0, #0x5
700ac22c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac22e: 9805         	ldr	r0, [sp, #0x14]
700ac230: 9904         	ldr	r1, [sp, #0x10]
700ac232: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac236: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac238: 9903         	ldr	r1, [sp, #0xc]
700ac23a: 2001         	movs	r0, #0x1
700ac23c: 4088         	lsls	r0, r1
700ac23e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->rxUhcChFlag[offset] |= bitMask;
700ac240: 9a02         	ldr	r2, [sp, #0x8]
700ac242: 9806         	ldr	r0, [sp, #0x18]
700ac244: 9904         	ldr	r1, [sp, #0x10]
700ac246: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac24a: f8d1 0320    	ldr.w	r0, [r1, #0x320]
700ac24e: 4310         	orrs	r0, r2
700ac250: f8c1 0320    	str.w	r0, [r1, #0x320]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac254: 9806         	ldr	r0, [sp, #0x18]
700ac256: f500 609f    	add.w	r0, r0, #0x4f8
700ac25a: f7ff fe49    	bl	0x700abef0 <SemaphoreP_post> @ imm = #-0x36e
;     return;
700ac25e: b008         	add	sp, #0x20
700ac260: bd80         	pop	{r7, pc}
		...
700ac26e: 0000         	movs	r0, r0

700ac270 <Udma_rmFreeTxCh>:
; {
700ac270: b580         	push	{r7, lr}
700ac272: b088         	sub	sp, #0x20
700ac274: 9007         	str	r0, [sp, #0x1c]
700ac276: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac278: 9806         	ldr	r0, [sp, #0x18]
700ac27a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac27e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac280: 9806         	ldr	r0, [sp, #0x18]
700ac282: f500 609f    	add.w	r0, r0, #0x4f8
700ac286: f04f 31ff    	mov.w	r1, #0xffffffff
700ac28a: f7fe faa1    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x1abe
;     i = chNum - rmInitPrms->startTxCh;
700ac28e: 9807         	ldr	r0, [sp, #0x1c]
700ac290: 9901         	ldr	r1, [sp, #0x4]
700ac292: 6a89         	ldr	r1, [r1, #0x28]
700ac294: 1a40         	subs	r0, r0, r1
700ac296: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac298: 9805         	ldr	r0, [sp, #0x14]
700ac29a: 0940         	lsrs	r0, r0, #0x5
700ac29c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac29e: 9805         	ldr	r0, [sp, #0x14]
700ac2a0: 9904         	ldr	r1, [sp, #0x10]
700ac2a2: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac2a6: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac2a8: 9903         	ldr	r1, [sp, #0xc]
700ac2aa: 2001         	movs	r0, #0x1
700ac2ac: 4088         	lsls	r0, r1
700ac2ae: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txChFlag[offset] |= bitMask;
700ac2b0: 9a02         	ldr	r2, [sp, #0x8]
700ac2b2: 9806         	ldr	r0, [sp, #0x18]
700ac2b4: 9904         	ldr	r1, [sp, #0x10]
700ac2b6: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac2ba: f8d1 02d4    	ldr.w	r0, [r1, #0x2d4]
700ac2be: 4310         	orrs	r0, r2
700ac2c0: f8c1 02d4    	str.w	r0, [r1, #0x2d4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac2c4: 9806         	ldr	r0, [sp, #0x18]
700ac2c6: f500 609f    	add.w	r0, r0, #0x4f8
700ac2ca: f7ff fe11    	bl	0x700abef0 <SemaphoreP_post> @ imm = #-0x3de
;     return;
700ac2ce: b008         	add	sp, #0x20
700ac2d0: bd80         	pop	{r7, pc}
		...
700ac2de: 0000         	movs	r0, r0

700ac2e0 <Udma_rmFreeTxHcCh>:
; {
700ac2e0: b580         	push	{r7, lr}
700ac2e2: b088         	sub	sp, #0x20
700ac2e4: 9007         	str	r0, [sp, #0x1c]
700ac2e6: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac2e8: 9806         	ldr	r0, [sp, #0x18]
700ac2ea: f500 70ea    	add.w	r0, r0, #0x1d4
700ac2ee: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac2f0: 9806         	ldr	r0, [sp, #0x18]
700ac2f2: f500 609f    	add.w	r0, r0, #0x4f8
700ac2f6: f04f 31ff    	mov.w	r1, #0xffffffff
700ac2fa: f7fe fa69    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x1b2e
;     i = chNum - rmInitPrms->startTxHcCh;
700ac2fe: 9807         	ldr	r0, [sp, #0x1c]
700ac300: 9901         	ldr	r1, [sp, #0x4]
700ac302: 6a09         	ldr	r1, [r1, #0x20]
700ac304: 1a40         	subs	r0, r0, r1
700ac306: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac308: 9805         	ldr	r0, [sp, #0x14]
700ac30a: 0940         	lsrs	r0, r0, #0x5
700ac30c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac30e: 9805         	ldr	r0, [sp, #0x14]
700ac310: 9904         	ldr	r1, [sp, #0x10]
700ac312: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac316: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac318: 9903         	ldr	r1, [sp, #0xc]
700ac31a: 2001         	movs	r0, #0x1
700ac31c: 4088         	lsls	r0, r1
700ac31e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txHcChFlag[offset] |= bitMask;
700ac320: 9a02         	ldr	r2, [sp, #0x8]
700ac322: 9806         	ldr	r0, [sp, #0x18]
700ac324: 9904         	ldr	r1, [sp, #0x10]
700ac326: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac32a: f8d1 02f4    	ldr.w	r0, [r1, #0x2f4]
700ac32e: 4310         	orrs	r0, r2
700ac330: f8c1 02f4    	str.w	r0, [r1, #0x2f4]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac334: 9806         	ldr	r0, [sp, #0x18]
700ac336: f500 609f    	add.w	r0, r0, #0x4f8
700ac33a: f7ff fdd9    	bl	0x700abef0 <SemaphoreP_post> @ imm = #-0x44e
;     return;
700ac33e: b008         	add	sp, #0x20
700ac340: bd80         	pop	{r7, pc}
		...
700ac34e: 0000         	movs	r0, r0

700ac350 <Udma_rmFreeTxUhcCh>:
; {
700ac350: b580         	push	{r7, lr}
700ac352: b088         	sub	sp, #0x20
700ac354: 9007         	str	r0, [sp, #0x1c]
700ac356: 9106         	str	r1, [sp, #0x18]
;     Udma_RmInitPrms    *rmInitPrms = &drvHandle->rmInitPrms;
700ac358: 9806         	ldr	r0, [sp, #0x18]
700ac35a: f500 70ea    	add.w	r0, r0, #0x1d4
700ac35e: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_pend(&drvHandle->rmLockObj, SystemP_WAIT_FOREVER);
700ac360: 9806         	ldr	r0, [sp, #0x18]
700ac362: f500 609f    	add.w	r0, r0, #0x4f8
700ac366: f04f 31ff    	mov.w	r1, #0xffffffff
700ac36a: f7fe fa31    	bl	0x700aa7d0 <SemaphoreP_pend> @ imm = #-0x1b9e
;     i = chNum - rmInitPrms->startTxUhcCh;
700ac36e: 9807         	ldr	r0, [sp, #0x1c]
700ac370: 9901         	ldr	r1, [sp, #0x4]
700ac372: 6989         	ldr	r1, [r1, #0x18]
700ac374: 1a40         	subs	r0, r0, r1
700ac376: 9005         	str	r0, [sp, #0x14]
;     offset = i >> 5U;
700ac378: 9805         	ldr	r0, [sp, #0x14]
700ac37a: 0940         	lsrs	r0, r0, #0x5
700ac37c: 9004         	str	r0, [sp, #0x10]
;     bitPos = i - (offset << 5U);
700ac37e: 9805         	ldr	r0, [sp, #0x14]
700ac380: 9904         	ldr	r1, [sp, #0x10]
700ac382: eba0 1041    	sub.w	r0, r0, r1, lsl #5
700ac386: 9003         	str	r0, [sp, #0xc]
;     bitMask = (uint32_t) 1U << bitPos;
700ac388: 9903         	ldr	r1, [sp, #0xc]
700ac38a: 2001         	movs	r0, #0x1
700ac38c: 4088         	lsls	r0, r1
700ac38e: 9002         	str	r0, [sp, #0x8]
;     drvHandle->txUhcChFlag[offset] |= bitMask;
700ac390: 9a02         	ldr	r2, [sp, #0x8]
700ac392: 9806         	ldr	r0, [sp, #0x18]
700ac394: 9904         	ldr	r1, [sp, #0x10]
700ac396: eb00 0181    	add.w	r1, r0, r1, lsl #2
700ac39a: f8d1 02f8    	ldr.w	r0, [r1, #0x2f8]
700ac39e: 4310         	orrs	r0, r2
700ac3a0: f8c1 02f8    	str.w	r0, [r1, #0x2f8]
;     SemaphoreP_post(&drvHandle->rmLockObj);
700ac3a4: 9806         	ldr	r0, [sp, #0x18]
700ac3a6: f500 609f    	add.w	r0, r0, #0x4f8
700ac3aa: f7ff fda1    	bl	0x700abef0 <SemaphoreP_post> @ imm = #-0x4be
;     return;
700ac3ae: b008         	add	sp, #0x20
700ac3b0: bd80         	pop	{r7, pc}
		...
700ac3be: 0000         	movs	r0, r0

700ac3c0 <UART_getChar>:
; {
700ac3c0: b580         	push	{r7, lr}
700ac3c2: b086         	sub	sp, #0x18
700ac3c4: 9005         	str	r0, [sp, #0x14]
700ac3c6: 9104         	str	r1, [sp, #0x10]
700ac3c8: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ac3ca: 9003         	str	r0, [sp, #0xc]
;     uint32_t retVal      = FALSE;
700ac3cc: 9002         	str	r0, [sp, #0x8]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ac3ce: 9805         	ldr	r0, [sp, #0x14]
700ac3d0: 300c         	adds	r0, #0xc
700ac3d2: f003 fbcd    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x379a
700ac3d6: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ac3d8: 9805         	ldr	r0, [sp, #0x14]
700ac3da: 300c         	adds	r0, #0xc
700ac3dc: 9000         	str	r0, [sp]
700ac3de: f003 fbc7    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x378e
700ac3e2: 4601         	mov	r1, r0
700ac3e4: 9800         	ldr	r0, [sp]
700ac3e6: f001 017f    	and	r1, r1, #0x7f
700ac3ea: f003 fbc9    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x3792
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ac3ee: 9805         	ldr	r0, [sp, #0x14]
700ac3f0: 3014         	adds	r0, #0x14
700ac3f2: f003 fbbd    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x377a
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700ac3f6: 07c0         	lsls	r0, r0, #0x1f
700ac3f8: b150         	cbz	r0, 0x700ac410 <UART_getChar+0x50> @ imm = #0x14
700ac3fa: e7ff         	b	0x700ac3fc <UART_getChar+0x3c> @ imm = #-0x2
;         uint32_t tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700ac3fc: 9805         	ldr	r0, [sp, #0x14]
700ac3fe: f003 fbb7    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x376e
700ac402: 9001         	str	r0, [sp, #0x4]
;         *pChar = (uint8_t)tempRetVal;
700ac404: 9801         	ldr	r0, [sp, #0x4]
700ac406: 9904         	ldr	r1, [sp, #0x10]
700ac408: 7008         	strb	r0, [r1]
700ac40a: 2001         	movs	r0, #0x1
;         retVal = TRUE;
700ac40c: 9002         	str	r0, [sp, #0x8]
;     }
700ac40e: e7ff         	b	0x700ac410 <UART_getChar+0x50> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ac410: 9805         	ldr	r0, [sp, #0x14]
700ac412: 300c         	adds	r0, #0xc
700ac414: 9903         	ldr	r1, [sp, #0xc]
700ac416: f003 fbb3    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x3766
;     return retVal;
700ac41a: 9802         	ldr	r0, [sp, #0x8]
700ac41c: b006         	add	sp, #0x18
700ac41e: bd80         	pop	{r7, pc}

700ac420 <UART_writeData>:
; {
700ac420: b580         	push	{r7, lr}
700ac422: b086         	sub	sp, #0x18
700ac424: 9005         	str	r0, [sp, #0x14]
700ac426: 9104         	str	r1, [sp, #0x10]
;     UARTLLD_InitHandle hUartInit = hUart->hUartInit;
700ac428: 9805         	ldr	r0, [sp, #0x14]
700ac42a: 6840         	ldr	r0, [r0, #0x4]
700ac42c: 9001         	str	r0, [sp, #0x4]
;     numBytesToTransfer = writeSizeRemaining;
700ac42e: 9804         	ldr	r0, [sp, #0x10]
700ac430: 9003         	str	r0, [sp, #0xc]
;     if (numBytesToTransfer >= hUartInit->txTrigLvl)
700ac432: 9803         	ldr	r0, [sp, #0xc]
700ac434: 9901         	ldr	r1, [sp, #0x4]
700ac436: 6bc9         	ldr	r1, [r1, #0x3c]
700ac438: 4288         	cmp	r0, r1
700ac43a: d304         	blo	0x700ac446 <UART_writeData+0x26> @ imm = #0x8
700ac43c: e7ff         	b	0x700ac43e <UART_writeData+0x1e> @ imm = #-0x2
;         numBytesToTransfer = hUartInit->txTrigLvl;
700ac43e: 9801         	ldr	r0, [sp, #0x4]
700ac440: 6bc0         	ldr	r0, [r0, #0x3c]
700ac442: 9003         	str	r0, [sp, #0xc]
;     }
700ac444: e7ff         	b	0x700ac446 <UART_writeData+0x26> @ imm = #-0x2
;     numBytesToTransferred = numBytesToTransfer;
700ac446: 9803         	ldr	r0, [sp, #0xc]
700ac448: 9002         	str	r0, [sp, #0x8]
;     while (numBytesToTransfer != 0U)
700ac44a: e7ff         	b	0x700ac44c <UART_writeData+0x2c> @ imm = #-0x2
700ac44c: 9803         	ldr	r0, [sp, #0xc]
700ac44e: b190         	cbz	r0, 0x700ac476 <UART_writeData+0x56> @ imm = #0x24
700ac450: e7ff         	b	0x700ac452 <UART_writeData+0x32> @ imm = #-0x2
;         UART_putChar(hUart->baseAddr, *(const uint8_t *)hUart->writeBuf);
700ac452: 9905         	ldr	r1, [sp, #0x14]
700ac454: 6808         	ldr	r0, [r1]
700ac456: 6889         	ldr	r1, [r1, #0x8]
700ac458: 7809         	ldrb	r1, [r1]
700ac45a: f003 f981    	bl	0x700af760 <UART_putChar> @ imm = #0x3302
;         hUart->writeBuf = (const uint8_t *)hUart->writeBuf + 1U;
700ac45e: 9905         	ldr	r1, [sp, #0x14]
700ac460: 6888         	ldr	r0, [r1, #0x8]
700ac462: 3001         	adds	r0, #0x1
700ac464: 6088         	str	r0, [r1, #0x8]
;         numBytesToTransfer--;
700ac466: 9803         	ldr	r0, [sp, #0xc]
700ac468: 3801         	subs	r0, #0x1
700ac46a: 9003         	str	r0, [sp, #0xc]
;         hUart->writeCount++;
700ac46c: 9905         	ldr	r1, [sp, #0x14]
700ac46e: 68c8         	ldr	r0, [r1, #0xc]
700ac470: 3001         	adds	r0, #0x1
700ac472: 60c8         	str	r0, [r1, #0xc]
;     while (numBytesToTransfer != 0U)
700ac474: e7ea         	b	0x700ac44c <UART_writeData+0x2c> @ imm = #-0x2c
;     return (writeSizeRemaining - numBytesToTransferred);
700ac476: 9804         	ldr	r0, [sp, #0x10]
700ac478: 9902         	ldr	r1, [sp, #0x8]
700ac47a: 1a40         	subs	r0, r0, r1
700ac47c: b006         	add	sp, #0x18
700ac47e: bd80         	pop	{r7, pc}

700ac480 <Udma_virtToPhyFxn>:
; {
700ac480: b580         	push	{r7, lr}
700ac482: b088         	sub	sp, #0x20
700ac484: 9007         	str	r0, [sp, #0x1c]
700ac486: 9106         	str	r1, [sp, #0x18]
700ac488: 9205         	str	r2, [sp, #0x14]
700ac48a: 2000         	movs	r0, #0x0
700ac48c: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t            chNum = UDMA_DMA_CH_INVALID;
700ac490: 9004         	str	r0, [sp, #0x10]
700ac492: 2000         	movs	r0, #0x0
;     void               *appData = NULL_PTR;
700ac494: 9003         	str	r0, [sp, #0xc]
;     if(NULL_PTR != chHandle)
700ac496: 9805         	ldr	r0, [sp, #0x14]
700ac498: b138         	cbz	r0, 0x700ac4aa <Udma_virtToPhyFxn+0x2a> @ imm = #0xe
700ac49a: e7ff         	b	0x700ac49c <Udma_virtToPhyFxn+0x1c> @ imm = #-0x2
;         chNum   = chHandle->chPrms.chNum;
700ac49c: 9805         	ldr	r0, [sp, #0x14]
700ac49e: 6840         	ldr	r0, [r0, #0x4]
700ac4a0: 9004         	str	r0, [sp, #0x10]
;         appData = chHandle->chPrms.appData;
700ac4a2: 9805         	ldr	r0, [sp, #0x14]
700ac4a4: 6900         	ldr	r0, [r0, #0x10]
700ac4a6: 9003         	str	r0, [sp, #0xc]
;     }
700ac4a8: e7ff         	b	0x700ac4aa <Udma_virtToPhyFxn+0x2a> @ imm = #-0x2
;     if((Udma_VirtToPhyFxn) NULL_PTR != drvHandle->initPrms.virtToPhyFxn)
700ac4aa: 9806         	ldr	r0, [sp, #0x18]
700ac4ac: f8d0 01cc    	ldr.w	r0, [r0, #0x1cc]
700ac4b0: b150         	cbz	r0, 0x700ac4c8 <Udma_virtToPhyFxn+0x48> @ imm = #0x14
700ac4b2: e7ff         	b	0x700ac4b4 <Udma_virtToPhyFxn+0x34> @ imm = #-0x2
;         phyAddr = drvHandle->initPrms.virtToPhyFxn(virtAddr, chNum, appData);
700ac4b4: 9806         	ldr	r0, [sp, #0x18]
700ac4b6: f8d0 31cc    	ldr.w	r3, [r0, #0x1cc]
700ac4ba: 9807         	ldr	r0, [sp, #0x1c]
700ac4bc: 9904         	ldr	r1, [sp, #0x10]
700ac4be: 9a03         	ldr	r2, [sp, #0xc]
700ac4c0: 4798         	blx	r3
700ac4c2: 9101         	str	r1, [sp, #0x4]
700ac4c4: 9000         	str	r0, [sp]
;     }
700ac4c6: e007         	b	0x700ac4d8 <Udma_virtToPhyFxn+0x58> @ imm = #0xe
;         phyAddr = Udma_defaultVirtToPhyFxn(virtAddr, chNum, appData);
700ac4c8: 9807         	ldr	r0, [sp, #0x1c]
700ac4ca: 9904         	ldr	r1, [sp, #0x10]
700ac4cc: 9a03         	ldr	r2, [sp, #0xc]
700ac4ce: f003 fb5f    	bl	0x700afb90 <Udma_defaultVirtToPhyFxn> @ imm = #0x36be
700ac4d2: 9101         	str	r1, [sp, #0x4]
700ac4d4: 9000         	str	r0, [sp]
700ac4d6: e7ff         	b	0x700ac4d8 <Udma_virtToPhyFxn+0x58> @ imm = #-0x2
;     return (phyAddr);
700ac4d8: 9800         	ldr	r0, [sp]
700ac4da: 9901         	ldr	r1, [sp, #0x4]
700ac4dc: b008         	add	sp, #0x20
700ac4de: bd80         	pop	{r7, pc}

700ac4e0 <Sciclient_pmSetModuleRst>:
; {
700ac4e0: b580         	push	{r7, lr}
700ac4e2: b090         	sub	sp, #0x40
700ac4e4: 900f         	str	r0, [sp, #0x3c]
700ac4e6: 910e         	str	r1, [sp, #0x38]
700ac4e8: 920d         	str	r2, [sp, #0x34]
700ac4ea: 2000         	movs	r0, #0x0
;     int32_t retVal = SystemP_SUCCESS;
700ac4ec: 900c         	str	r0, [sp, #0x30]
;     request.id     = (uint32_t) moduleId;
700ac4ee: 990f         	ldr	r1, [sp, #0x3c]
700ac4f0: 910a         	str	r1, [sp, #0x28]
;     request.resets = (uint32_t) resetBit;
700ac4f2: 990e         	ldr	r1, [sp, #0x38]
700ac4f4: 910b         	str	r1, [sp, #0x2c]
700ac4f6: f240 2102    	movw	r1, #0x202
;     reqParam.messageType    = (uint16_t) TISCI_MSG_SET_DEVICE_RESETS;
700ac4fa: f8ad 100c    	strh.w	r1, [sp, #0xc]
700ac4fe: 2102         	movs	r1, #0x2
;     reqParam.flags          = (uint32_t) TISCI_MSG_FLAG_AOP;
700ac500: 9104         	str	r1, [sp, #0x10]
700ac502: a908         	add	r1, sp, #0x20
;     reqParam.pReqPayload    = (const uint8_t *) &request;
700ac504: 9105         	str	r1, [sp, #0x14]
700ac506: 2110         	movs	r1, #0x10
;     reqParam.reqPayloadSize = (uint32_t) sizeof (request);
700ac508: 9106         	str	r1, [sp, #0x18]
;     reqParam.timeout        = (uint32_t) timeout;
700ac50a: 990d         	ldr	r1, [sp, #0x34]
700ac50c: 9107         	str	r1, [sp, #0x1c]
;     respParam.flags           = (uint32_t) 0;   /* Populated by the API */
700ac50e: 9000         	str	r0, [sp]
;     respParam.pRespPayload    = (uint8_t *) 0;
700ac510: 9001         	str	r0, [sp, #0x4]
;     respParam.respPayloadSize = (uint32_t) 0;
700ac512: 9002         	str	r0, [sp, #0x8]
700ac514: a803         	add	r0, sp, #0xc
700ac516: 4669         	mov	r1, sp
;     retVal = Sciclient_service(&reqParam, &respParam);
700ac518: f7f1 f862    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xef3c
700ac51c: 900c         	str	r0, [sp, #0x30]
;     if((retVal != SystemP_SUCCESS) ||
700ac51e: 980c         	ldr	r0, [sp, #0x30]
700ac520: b930         	cbnz	r0, 0x700ac530 <Sciclient_pmSetModuleRst+0x50> @ imm = #0xc
700ac522: e7ff         	b	0x700ac524 <Sciclient_pmSetModuleRst+0x44> @ imm = #-0x2
;         ((respParam.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK))
700ac524: 9800         	ldr	r0, [sp]
700ac526: f000 0002    	and	r0, r0, #0x2
;     if((retVal != SystemP_SUCCESS) ||
700ac52a: 2802         	cmp	r0, #0x2
700ac52c: d004         	beq	0x700ac538 <Sciclient_pmSetModuleRst+0x58> @ imm = #0x8
700ac52e: e7ff         	b	0x700ac530 <Sciclient_pmSetModuleRst+0x50> @ imm = #-0x2
700ac530: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = SystemP_FAILURE;
700ac534: 900c         	str	r0, [sp, #0x30]
;     }
700ac536: e7ff         	b	0x700ac538 <Sciclient_pmSetModuleRst+0x58> @ imm = #-0x2
;     return retVal;
700ac538: 980c         	ldr	r0, [sp, #0x30]
700ac53a: b010         	add	sp, #0x40
700ac53c: bd80         	pop	{r7, pc}
700ac53e: 0000         	movs	r0, r0

700ac540 <Sciclient_rmIaGetInst>:
; {
700ac540: b083         	sub	sp, #0xc
700ac542: f8ad 000a    	strh.w	r0, [sp, #0xa]
700ac546: 2000         	movs	r0, #0x0
;     struct Sciclient_rmIaInst *inst = NULL;
700ac548: 9001         	str	r0, [sp, #0x4]
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700ac54a: f8ad 0002    	strh.w	r0, [sp, #0x2]
700ac54e: e7ff         	b	0x700ac550 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x2
700ac550: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ac554: 2800         	cmp	r0, #0x0
700ac556: dc1e         	bgt	0x700ac596 <Sciclient_rmIaGetInst+0x56> @ imm = #0x3c
700ac558: e7ff         	b	0x700ac55a <Sciclient_rmIaGetInst+0x1a> @ imm = #-0x2
;         if (id == gRmIaInstances[i].dev_id) {
700ac55a: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700ac55e: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700ac562: 014a         	lsls	r2, r1, #0x5
700ac564: f642 019c    	movw	r1, #0x289c
700ac568: f2c7 010b    	movt	r1, #0x700b
700ac56c: 5a89         	ldrh	r1, [r1, r2]
700ac56e: 4288         	cmp	r0, r1
700ac570: d10a         	bne	0x700ac588 <Sciclient_rmIaGetInst+0x48> @ imm = #0x14
700ac572: e7ff         	b	0x700ac574 <Sciclient_rmIaGetInst+0x34> @ imm = #-0x2
;             inst = &gRmIaInstances[i];
700ac574: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700ac578: f642 009c    	movw	r0, #0x289c
700ac57c: f2c7 000b    	movt	r0, #0x700b
700ac580: eb00 1041    	add.w	r0, r0, r1, lsl #5
700ac584: 9001         	str	r0, [sp, #0x4]
;             break;
700ac586: e006         	b	0x700ac596 <Sciclient_rmIaGetInst+0x56> @ imm = #0xc
;     }
700ac588: e7ff         	b	0x700ac58a <Sciclient_rmIaGetInst+0x4a> @ imm = #-0x2
;     for (i = 0; i < SCICLIENT_RM_IA_NUM_INST; i++) {
700ac58a: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700ac58e: 3001         	adds	r0, #0x1
700ac590: f8ad 0002    	strh.w	r0, [sp, #0x2]
700ac594: e7dc         	b	0x700ac550 <Sciclient_rmIaGetInst+0x10> @ imm = #-0x48
;     return inst;
700ac596: 9801         	ldr	r0, [sp, #0x4]
700ac598: b003         	add	sp, #0xc
700ac59a: 4770         	bx	lr
700ac59c: 0000         	movs	r0, r0
700ac59e: 0000         	movs	r0, r0

700ac5a0 <Sciclient_rmPsPush>:
; {
700ac5a0: b083         	sub	sp, #0xc
700ac5a2: 9002         	str	r0, [sp, #0x8]
700ac5a4: f8ad 1006    	strh.w	r1, [sp, #0x6]
700ac5a8: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac5aa: 9000         	str	r0, [sp]
;     if ((gPstack.psp < SCICLIENT_PS_MAX_DEPTH) && (n != NULL)) {
700ac5ac: f241 0058    	movw	r0, #0x1058
700ac5b0: f2c7 0008    	movt	r0, #0x7008
700ac5b4: 8c80         	ldrh	r0, [r0, #0x24]
700ac5b6: 2802         	cmp	r0, #0x2
700ac5b8: dc19         	bgt	0x700ac5ee <Sciclient_rmPsPush+0x4e> @ imm = #0x32
700ac5ba: e7ff         	b	0x700ac5bc <Sciclient_rmPsPush+0x1c> @ imm = #-0x2
700ac5bc: 9802         	ldr	r0, [sp, #0x8]
700ac5be: b1b0         	cbz	r0, 0x700ac5ee <Sciclient_rmPsPush+0x4e> @ imm = #0x2c
700ac5c0: e7ff         	b	0x700ac5c2 <Sciclient_rmPsPush+0x22> @ imm = #-0x2
;         gPstack.ps[gPstack.psp].p_n = n;
700ac5c2: 9802         	ldr	r0, [sp, #0x8]
700ac5c4: f241 0158    	movw	r1, #0x1058
700ac5c8: f2c7 0108    	movt	r1, #0x7008
700ac5cc: 8c8a         	ldrh	r2, [r1, #0x24]
700ac5ce: eb02 0242    	add.w	r2, r2, r2, lsl #1
700ac5d2: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;         gPstack.ps[gPstack.psp].if_idx = if_idx;
700ac5d6: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ac5da: 8c8a         	ldrh	r2, [r1, #0x24]
700ac5dc: eb02 0242    	add.w	r2, r2, r2, lsl #1
700ac5e0: eb01 0282    	add.w	r2, r1, r2, lsl #2
700ac5e4: 8090         	strh	r0, [r2, #0x4]
;         gPstack.psp++;
700ac5e6: 8c88         	ldrh	r0, [r1, #0x24]
700ac5e8: 3001         	adds	r0, #0x1
700ac5ea: 8488         	strh	r0, [r1, #0x24]
;     } else {
700ac5ec: e003         	b	0x700ac5f6 <Sciclient_rmPsPush+0x56> @ imm = #0x6
700ac5ee: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac5f2: 9000         	str	r0, [sp]
700ac5f4: e7ff         	b	0x700ac5f6 <Sciclient_rmPsPush+0x56> @ imm = #-0x2
;     return r;
700ac5f6: 9800         	ldr	r0, [sp]
700ac5f8: b003         	add	sp, #0xc
700ac5fa: 4770         	bx	lr
700ac5fc: 0000         	movs	r0, r0
700ac5fe: 0000         	movs	r0, r0

700ac600 <UART_lld_deInit>:
; {
700ac600: b580         	push	{r7, lr}
700ac602: b084         	sub	sp, #0x10
700ac604: 9003         	str	r0, [sp, #0xc]
700ac606: 2000         	movs	r0, #0x0
;     int32_t             status = UART_STATUS_SUCCESS;
700ac608: 9002         	str	r0, [sp, #0x8]
;     if (NULL_PTR != hUart)
700ac60a: 9803         	ldr	r0, [sp, #0xc]
700ac60c: b1f8         	cbz	r0, 0x700ac64e <UART_lld_deInit+0x4e> @ imm = #0x3e
700ac60e: e7ff         	b	0x700ac610 <UART_lld_deInit+0x10> @ imm = #-0x2
;         hUart->state = UART_STATE_BUSY;
700ac610: 9903         	ldr	r1, [sp, #0xc]
700ac612: 2002         	movs	r0, #0x2
700ac614: 6548         	str	r0, [r1, #0x54]
;        status = UART_lld_flushTxFifo(hUart);
700ac616: 9803         	ldr	r0, [sp, #0xc]
700ac618: f7fd ff2a    	bl	0x700aa470 <UART_lld_flushTxFifo> @ imm = #-0x21ac
700ac61c: 9002         	str	r0, [sp, #0x8]
;         if(status == UART_STATUS_SUCCESS)
700ac61e: 9802         	ldr	r0, [sp, #0x8]
700ac620: b988         	cbnz	r0, 0x700ac646 <UART_lld_deInit+0x46> @ imm = #0x22
700ac622: e7ff         	b	0x700ac624 <UART_lld_deInit+0x24> @ imm = #-0x2
;             UART_intrDisable(hUart->baseAddr,
700ac624: 9803         	ldr	r0, [sp, #0xc]
700ac626: 6800         	ldr	r0, [r0]
700ac628: 2107         	movs	r1, #0x7
700ac62a: 9101         	str	r1, [sp, #0x4]
700ac62c: f7f9 fe90    	bl	0x700a6350 <UART_intrDisable> @ imm = #-0x62e0
;             UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700ac630: 9803         	ldr	r0, [sp, #0xc]
700ac632: 6800         	ldr	r0, [r0]
700ac634: 2102         	movs	r1, #0x2
700ac636: f002 fbab    	bl	0x700aed90 <UART_intr2Disable> @ imm = #0x2756
700ac63a: 9901         	ldr	r1, [sp, #0x4]
;             (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700ac63c: 9803         	ldr	r0, [sp, #0xc]
700ac63e: 6800         	ldr	r0, [r0]
700ac640: f002 fbee    	bl	0x700aee20 <UART_operatingModeSelect> @ imm = #0x27dc
;         }
700ac644: e7ff         	b	0x700ac646 <UART_lld_deInit+0x46> @ imm = #-0x2
;         hUart->state = UART_STATE_RESET;
700ac646: 9903         	ldr	r1, [sp, #0xc]
700ac648: 2000         	movs	r0, #0x0
700ac64a: 6548         	str	r0, [r1, #0x54]
;     }
700ac64c: e003         	b	0x700ac656 <UART_lld_deInit+0x56> @ imm = #0x6
700ac64e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700ac652: 9002         	str	r0, [sp, #0x8]
700ac654: e7ff         	b	0x700ac656 <UART_lld_deInit+0x56> @ imm = #-0x2
;     return status;
700ac656: 9802         	ldr	r0, [sp, #0x8]
700ac658: b004         	add	sp, #0x10
700ac65a: bd80         	pop	{r7, pc}
700ac65c: 0000         	movs	r0, r0
700ac65e: 0000         	movs	r0, r0

700ac660 <UART_lld_writeCompleteCallback>:
; {
700ac660: b580         	push	{r7, lr}
700ac662: b086         	sub	sp, #0x18
700ac664: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700ac666: 9805         	ldr	r0, [sp, #0x14]
700ac668: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700ac66a: 9802         	ldr	r0, [sp, #0x8]
700ac66c: b320         	cbz	r0, 0x700ac6b8 <UART_lld_writeCompleteCallback+0x58> @ imm = #0x48
700ac66e: e7ff         	b	0x700ac670 <UART_lld_writeCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700ac670: 9802         	ldr	r0, [sp, #0x8]
700ac672: 6e00         	ldr	r0, [r0, #0x60]
700ac674: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700ac676: 9801         	ldr	r0, [sp, #0x4]
700ac678: b1e8         	cbz	r0, 0x700ac6b6 <UART_lld_writeCompleteCallback+0x56> @ imm = #0x3a
700ac67a: e7ff         	b	0x700ac67c <UART_lld_writeCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700ac67c: 9801         	ldr	r0, [sp, #0x4]
700ac67e: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700ac680: 9804         	ldr	r0, [sp, #0x10]
700ac682: 6840         	ldr	r0, [r0, #0x4]
700ac684: 9003         	str	r0, [sp, #0xc]
;             obj->writeTrans->count = hUart->writeTrans.count;
700ac686: 9802         	ldr	r0, [sp, #0x8]
700ac688: 6c00         	ldr	r0, [r0, #0x40]
700ac68a: 9903         	ldr	r1, [sp, #0xc]
700ac68c: f8d1 1080    	ldr.w	r1, [r1, #0x80]
700ac690: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.writeMode == UART_TRANSFER_MODE_CALLBACK)
700ac692: 9803         	ldr	r0, [sp, #0xc]
700ac694: 69c0         	ldr	r0, [r0, #0x1c]
700ac696: 2801         	cmp	r0, #0x1
700ac698: d107         	bne	0x700ac6aa <UART_lld_writeCompleteCallback+0x4a> @ imm = #0xe
700ac69a: e7ff         	b	0x700ac69c <UART_lld_writeCompleteCallback+0x3c> @ imm = #-0x2
;                 obj->prms.writeCallbackFxn(hUart, &hUart->writeTrans);
700ac69c: 9803         	ldr	r0, [sp, #0xc]
700ac69e: 6a42         	ldr	r2, [r0, #0x24]
700ac6a0: 9802         	ldr	r0, [sp, #0x8]
700ac6a2: f100 013c    	add.w	r1, r0, #0x3c
700ac6a6: 4790         	blx	r2
;             }
700ac6a8: e004         	b	0x700ac6b4 <UART_lld_writeCompleteCallback+0x54> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->writeTransferMutex);
700ac6aa: 9802         	ldr	r0, [sp, #0x8]
700ac6ac: 6dc0         	ldr	r0, [r0, #0x5c]
700ac6ae: f7ff fc1f    	bl	0x700abef0 <SemaphoreP_post> @ imm = #-0x7c2
700ac6b2: e7ff         	b	0x700ac6b4 <UART_lld_writeCompleteCallback+0x54> @ imm = #-0x2
;         }
700ac6b4: e7ff         	b	0x700ac6b6 <UART_lld_writeCompleteCallback+0x56> @ imm = #-0x2
;     }
700ac6b6: e7ff         	b	0x700ac6b8 <UART_lld_writeCompleteCallback+0x58> @ imm = #-0x2
; }
700ac6b8: b006         	add	sp, #0x18
700ac6ba: bd80         	pop	{r7, pc}
700ac6bc: 0000         	movs	r0, r0
700ac6be: 0000         	movs	r0, r0

700ac6c0 <Sciclient_rmIaValidateGlobalEvt>:
; {
700ac6c0: b580         	push	{r7, lr}
700ac6c2: b086         	sub	sp, #0x18
700ac6c4: f8ad 0016    	strh.w	r0, [sp, #0x16]
700ac6c8: f8ad 1014    	strh.w	r1, [sp, #0x14]
700ac6cc: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac6ce: 9004         	str	r0, [sp, #0x10]
;     struct Sciclient_rmIaInst *inst = NULL;
700ac6d0: 9003         	str	r0, [sp, #0xc]
;     inst = Sciclient_rmIaGetInst(id);
700ac6d2: f8bd 0016    	ldrh.w	r0, [sp, #0x16]
700ac6d6: f7ff ff33    	bl	0x700ac540 <Sciclient_rmIaGetInst> @ imm = #-0x19a
700ac6da: 9003         	str	r0, [sp, #0xc]
;     if (inst == NULL) {
700ac6dc: 9803         	ldr	r0, [sp, #0xc]
700ac6de: b920         	cbnz	r0, 0x700ac6ea <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #0x8
700ac6e0: e7ff         	b	0x700ac6e2 <Sciclient_rmIaValidateGlobalEvt+0x22> @ imm = #-0x2
700ac6e2: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ac6e6: 9004         	str	r0, [sp, #0x10]
;     }
700ac6e8: e7ff         	b	0x700ac6ea <Sciclient_rmIaValidateGlobalEvt+0x2a> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ac6ea: 9804         	ldr	r0, [sp, #0x10]
700ac6ec: b990         	cbnz	r0, 0x700ac714 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #0x24
700ac6ee: e7ff         	b	0x700ac6f0 <Sciclient_rmIaValidateGlobalEvt+0x30> @ imm = #-0x2
;         evt = global_evt - inst->sevt_offset;
700ac6f0: f8bd 0014    	ldrh.w	r0, [sp, #0x14]
700ac6f4: 9903         	ldr	r1, [sp, #0xc]
700ac6f6: 8909         	ldrh	r1, [r1, #0x8]
700ac6f8: 1a40         	subs	r0, r0, r1
700ac6fa: f8ad 000a    	strh.w	r0, [sp, #0xa]
;         r = Sciclient_rmIaValidateEvt(inst, evt, 0u, 0u, false);
700ac6fe: 9803         	ldr	r0, [sp, #0xc]
700ac700: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700ac704: 466a         	mov	r2, sp
700ac706: 2300         	movs	r3, #0x0
700ac708: 6013         	str	r3, [r2]
700ac70a: 461a         	mov	r2, r3
700ac70c: f7f7 ff60    	bl	0x700a45d0 <Sciclient_rmIaValidateEvt> @ imm = #-0x8140
700ac710: 9004         	str	r0, [sp, #0x10]
;     }
700ac712: e7ff         	b	0x700ac714 <Sciclient_rmIaValidateGlobalEvt+0x54> @ imm = #-0x2
;     return r;
700ac714: 9804         	ldr	r0, [sp, #0x10]
700ac716: b006         	add	sp, #0x18
700ac718: bd80         	pop	{r7, pc}
700ac71a: 0000         	movs	r0, r0
700ac71c: 0000         	movs	r0, r0
700ac71e: 0000         	movs	r0, r0

700ac720 <UART_lld_readCompleteCallback>:
; {
700ac720: b580         	push	{r7, lr}
700ac722: b086         	sub	sp, #0x18
700ac724: 9005         	str	r0, [sp, #0x14]
;     UARTLLD_Handle hUart = (UARTLLD_Handle)args;
700ac726: 9805         	ldr	r0, [sp, #0x14]
700ac728: 9002         	str	r0, [sp, #0x8]
;     if(NULL_PTR != hUart)
700ac72a: 9802         	ldr	r0, [sp, #0x8]
700ac72c: b318         	cbz	r0, 0x700ac776 <UART_lld_readCompleteCallback+0x56> @ imm = #0x46
700ac72e: e7ff         	b	0x700ac730 <UART_lld_readCompleteCallback+0x10> @ imm = #-0x2
;         UART_Handle handle = (UART_Handle)hUart->args;
700ac730: 9802         	ldr	r0, [sp, #0x8]
700ac732: 6e00         	ldr	r0, [r0, #0x60]
700ac734: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != handle)
700ac736: 9801         	ldr	r0, [sp, #0x4]
700ac738: b1e0         	cbz	r0, 0x700ac774 <UART_lld_readCompleteCallback+0x54> @ imm = #0x38
700ac73a: e7ff         	b	0x700ac73c <UART_lld_readCompleteCallback+0x1c> @ imm = #-0x2
;             config = (UART_Config *) handle;
700ac73c: 9801         	ldr	r0, [sp, #0x4]
700ac73e: 9004         	str	r0, [sp, #0x10]
;             obj = config->object;
700ac740: 9804         	ldr	r0, [sp, #0x10]
700ac742: 6840         	ldr	r0, [r0, #0x4]
700ac744: 9003         	str	r0, [sp, #0xc]
;             obj->readTrans->count = hUart->readTrans.count;
700ac746: 9802         	ldr	r0, [sp, #0x8]
700ac748: 6ac0         	ldr	r0, [r0, #0x2c]
700ac74a: 9903         	ldr	r1, [sp, #0xc]
700ac74c: 6fc9         	ldr	r1, [r1, #0x7c]
700ac74e: 6048         	str	r0, [r1, #0x4]
;             if (obj->prms.readMode == UART_TRANSFER_MODE_CALLBACK)
700ac750: 9803         	ldr	r0, [sp, #0xc]
700ac752: 6940         	ldr	r0, [r0, #0x14]
700ac754: 2801         	cmp	r0, #0x1
700ac756: d107         	bne	0x700ac768 <UART_lld_readCompleteCallback+0x48> @ imm = #0xe
700ac758: e7ff         	b	0x700ac75a <UART_lld_readCompleteCallback+0x3a> @ imm = #-0x2
;                 obj->prms.readCallbackFxn(hUart, &hUart->readTrans);
700ac75a: 9803         	ldr	r0, [sp, #0xc]
700ac75c: 6a02         	ldr	r2, [r0, #0x20]
700ac75e: 9802         	ldr	r0, [sp, #0x8]
700ac760: f100 0128    	add.w	r1, r0, #0x28
700ac764: 4790         	blx	r2
;             }
700ac766: e004         	b	0x700ac772 <UART_lld_readCompleteCallback+0x52> @ imm = #0x8
;                 SemaphoreP_post((SemaphoreP_Object *)hUart->readTransferMutex);
700ac768: 9802         	ldr	r0, [sp, #0x8]
700ac76a: 6d80         	ldr	r0, [r0, #0x58]
700ac76c: f7ff fbc0    	bl	0x700abef0 <SemaphoreP_post> @ imm = #-0x880
700ac770: e7ff         	b	0x700ac772 <UART_lld_readCompleteCallback+0x52> @ imm = #-0x2
;         }
700ac772: e7ff         	b	0x700ac774 <UART_lld_readCompleteCallback+0x54> @ imm = #-0x2
;     }
700ac774: e7ff         	b	0x700ac776 <UART_lld_readCompleteCallback+0x56> @ imm = #-0x2
; }
700ac776: b006         	add	sp, #0x18
700ac778: bd80         	pop	{r7, pc}
700ac77a: 0000         	movs	r0, r0
700ac77c: 0000         	movs	r0, r0
700ac77e: 0000         	movs	r0, r0

700ac780 <UART_regConfigModeEnable>:
; {
700ac780: b580         	push	{r7, lr}
700ac782: b086         	sub	sp, #0x18
700ac784: 9005         	str	r0, [sp, #0x14]
700ac786: 9104         	str	r1, [sp, #0x10]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ac788: 9805         	ldr	r0, [sp, #0x14]
700ac78a: 300c         	adds	r0, #0xc
700ac78c: f003 f9f0    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x33e0
700ac790: 9003         	str	r0, [sp, #0xc]
;     switch (modeFlag)
700ac792: 9804         	ldr	r0, [sp, #0x10]
700ac794: 9002         	str	r0, [sp, #0x8]
700ac796: 287f         	cmp	r0, #0x7f
700ac798: d00f         	beq	0x700ac7ba <UART_regConfigModeEnable+0x3a> @ imm = #0x1e
700ac79a: e7ff         	b	0x700ac79c <UART_regConfigModeEnable+0x1c> @ imm = #-0x2
700ac79c: 9802         	ldr	r0, [sp, #0x8]
700ac79e: 2880         	cmp	r0, #0x80
700ac7a0: d004         	beq	0x700ac7ac <UART_regConfigModeEnable+0x2c> @ imm = #0x8
700ac7a2: e7ff         	b	0x700ac7a4 <UART_regConfigModeEnable+0x24> @ imm = #-0x2
700ac7a4: 9802         	ldr	r0, [sp, #0x8]
700ac7a6: 28bf         	cmp	r0, #0xbf
700ac7a8: d113         	bne	0x700ac7d2 <UART_regConfigModeEnable+0x52> @ imm = #0x26
700ac7aa: e7ff         	b	0x700ac7ac <UART_regConfigModeEnable+0x2c> @ imm = #-0x2
;             HW_WR_REG32(baseAddr + UART_LCR, modeFlag & 0xFFU);
700ac7ac: 9805         	ldr	r0, [sp, #0x14]
700ac7ae: 300c         	adds	r0, #0xc
700ac7b0: f89d 1010    	ldrb.w	r1, [sp, #0x10]
700ac7b4: f003 f9e4    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x33c8
;             break;
700ac7b8: e00c         	b	0x700ac7d4 <UART_regConfigModeEnable+0x54> @ imm = #0x18
;             HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ac7ba: 9805         	ldr	r0, [sp, #0x14]
700ac7bc: 300c         	adds	r0, #0xc
700ac7be: 9001         	str	r0, [sp, #0x4]
700ac7c0: f003 f9d6    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x33ac
700ac7c4: 4601         	mov	r1, r0
700ac7c6: 9801         	ldr	r0, [sp, #0x4]
700ac7c8: f001 017f    	and	r1, r1, #0x7f
700ac7cc: f003 f9d8    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x33b0
;             break;
700ac7d0: e000         	b	0x700ac7d4 <UART_regConfigModeEnable+0x54> @ imm = #0x0
;             break;
700ac7d2: e7ff         	b	0x700ac7d4 <UART_regConfigModeEnable+0x54> @ imm = #-0x2
;     return lcrRegValue;
700ac7d4: 9803         	ldr	r0, [sp, #0xc]
700ac7d6: b006         	add	sp, #0x18
700ac7d8: bd80         	pop	{r7, pc}
700ac7da: 0000         	movs	r0, r0
700ac7dc: 0000         	movs	r0, r0
700ac7de: 0000         	movs	r0, r0

700ac7e0 <prvCheckTasksWaitingTermination>:
; static void prvCheckTasksWaitingTermination(void) {
700ac7e0: b580         	push	{r7, lr}
700ac7e2: b082         	sub	sp, #0x8
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700ac7e4: e7ff         	b	0x700ac7e6 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x2
700ac7e6: f642 2020    	movw	r0, #0x2a20
700ac7ea: f2c7 000b    	movt	r0, #0x700b
700ac7ee: 6800         	ldr	r0, [r0]
700ac7f0: b308         	cbz	r0, 0x700ac836 <prvCheckTasksWaitingTermination+0x56> @ imm = #0x42
700ac7f2: e7ff         	b	0x700ac7f4 <prvCheckTasksWaitingTermination+0x14> @ imm = #-0x2
;       taskENTER_CRITICAL();
700ac7f4: f001 ffbc    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x1f78
;         pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(
700ac7f8: f245 2088    	movw	r0, #0x5288
700ac7fc: f2c7 0008    	movt	r0, #0x7008
700ac800: 68c0         	ldr	r0, [r0, #0xc]
700ac802: 68c0         	ldr	r0, [r0, #0xc]
700ac804: 9001         	str	r0, [sp, #0x4]
;         (void)uxListRemove(&(pxTCB->xStateListItem));
700ac806: 9801         	ldr	r0, [sp, #0x4]
700ac808: 3004         	adds	r0, #0x4
700ac80a: f000 ff81    	bl	0x700ad710 <uxListRemove> @ imm = #0xf02
;         --uxCurrentNumberOfTasks;
700ac80e: f642 211c    	movw	r1, #0x2a1c
700ac812: f2c7 010b    	movt	r1, #0x700b
700ac816: 6808         	ldr	r0, [r1]
700ac818: 3801         	subs	r0, #0x1
700ac81a: 6008         	str	r0, [r1]
;         --uxDeletedTasksWaitingCleanUp;
700ac81c: f642 2120    	movw	r1, #0x2a20
700ac820: f2c7 010b    	movt	r1, #0x700b
700ac824: 6808         	ldr	r0, [r1]
700ac826: 3801         	subs	r0, #0x1
700ac828: 6008         	str	r0, [r1]
;       taskEXIT_CRITICAL();
700ac82a: f001 f861    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #0x10c2
;       prvDeleteTCB(pxTCB);
700ac82e: 9801         	ldr	r0, [sp, #0x4]
700ac830: f001 fc86    	bl	0x700ae140 <prvDeleteTCB> @ imm = #0x190c
;     while (uxDeletedTasksWaitingCleanUp > (UBaseType_t)0U) {
700ac834: e7d7         	b	0x700ac7e6 <prvCheckTasksWaitingTermination+0x6> @ imm = #-0x52
; }
700ac836: b002         	add	sp, #0x8
700ac838: bd80         	pop	{r7, pc}
700ac83a: 0000         	movs	r0, r0
700ac83c: 0000         	movs	r0, r0
700ac83e: 0000         	movs	r0, r0

700ac840 <Sciclient_rmIrqSetRaw>:
; {
700ac840: b580         	push	{r7, lr}
700ac842: b08c         	sub	sp, #0x30
700ac844: 900b         	str	r0, [sp, #0x2c]
700ac846: 910a         	str	r1, [sp, #0x28]
700ac848: 9209         	str	r2, [sp, #0x24]
700ac84a: f44f 5080    	mov.w	r0, #0x1000
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_SET;
700ac84e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac852: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac854: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac856: 980b         	ldr	r0, [sp, #0x2c]
700ac858: 9005         	str	r0, [sp, #0x14]
700ac85a: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac85c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac85e: 9809         	ldr	r0, [sp, #0x24]
700ac860: 9007         	str	r0, [sp, #0x1c]
700ac862: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac864: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac866: 980a         	ldr	r0, [sp, #0x28]
700ac868: 9001         	str	r0, [sp, #0x4]
700ac86a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac86c: 9002         	str	r0, [sp, #0x8]
700ac86e: a803         	add	r0, sp, #0xc
700ac870: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac872: f7f0 feb5    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xf296
700ac876: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac878: 9808         	ldr	r0, [sp, #0x20]
700ac87a: b930         	cbnz	r0, 0x700ac88a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #0xc
700ac87c: e7ff         	b	0x700ac87e <Sciclient_rmIrqSetRaw+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac87e: 9800         	ldr	r0, [sp]
700ac880: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac884: 2802         	cmp	r0, #0x2
700ac886: d004         	beq	0x700ac892 <Sciclient_rmIrqSetRaw+0x52> @ imm = #0x8
700ac888: e7ff         	b	0x700ac88a <Sciclient_rmIrqSetRaw+0x4a> @ imm = #-0x2
700ac88a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac88e: 9008         	str	r0, [sp, #0x20]
;     }
700ac890: e7ff         	b	0x700ac892 <Sciclient_rmIrqSetRaw+0x52> @ imm = #-0x2
;     return r;
700ac892: 9808         	ldr	r0, [sp, #0x20]
700ac894: b00c         	add	sp, #0x30
700ac896: bd80         	pop	{r7, pc}
		...

700ac8a0 <Sciclient_rmIrqUnmappedVintRouteDelete>:
; {
700ac8a0: b580         	push	{r7, lr}
700ac8a2: b084         	sub	sp, #0x10
700ac8a4: 9003         	str	r0, [sp, #0xc]
700ac8a6: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ac8a8: 9002         	str	r0, [sp, #0x8]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700ac8aa: 9903         	ldr	r1, [sp, #0xc]
700ac8ac: 8a08         	ldrh	r0, [r1, #0x10]
700ac8ae: 8a49         	ldrh	r1, [r1, #0x12]
700ac8b0: f10d 0207    	add.w	r2, sp, #0x7
700ac8b4: f7fe fe84    	bl	0x700ab5c0 <Sciclient_rmIaVintGetInfo> @ imm = #-0x12f8
700ac8b8: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700ac8ba: 9802         	ldr	r0, [sp, #0x8]
700ac8bc: b940         	cbnz	r0, 0x700ac8d0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x10
700ac8be: e7ff         	b	0x700ac8c0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x20> @ imm = #-0x2
700ac8c0: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ac8c4: b120         	cbz	r0, 0x700ac8d0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #0x8
700ac8c6: e7ff         	b	0x700ac8c8 <Sciclient_rmIrqUnmappedVintRouteDelete+0x28> @ imm = #-0x2
700ac8c8: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ac8cc: 9002         	str	r0, [sp, #0x8]
;     }
700ac8ce: e7ff         	b	0x700ac8d0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x30> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ac8d0: 9802         	ldr	r0, [sp, #0x8]
700ac8d2: b970         	cbnz	r0, 0x700ac8f2 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #0x1c
700ac8d4: e7ff         	b	0x700ac8d6 <Sciclient_rmIrqUnmappedVintRouteDelete+0x36> @ imm = #-0x2
;         r = Sciclient_rmIrqGetRoute(cfg);
700ac8d6: 9803         	ldr	r0, [sp, #0xc]
700ac8d8: f7f0 fa0a    	bl	0x7009ccf0 <Sciclient_rmIrqGetRoute> @ imm = #-0xfbec
700ac8dc: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700ac8de: 9802         	ldr	r0, [sp, #0x8]
700ac8e0: b930         	cbnz	r0, 0x700ac8f0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #0xc
700ac8e2: e7ff         	b	0x700ac8e4 <Sciclient_rmIrqUnmappedVintRouteDelete+0x44> @ imm = #-0x2
;             r = Sciclient_rmIrqDeleteRoute(cfg, false);
700ac8e4: 9803         	ldr	r0, [sp, #0xc]
700ac8e6: 2100         	movs	r1, #0x0
700ac8e8: f7f4 f91a    	bl	0x700a0b20 <Sciclient_rmIrqDeleteRoute> @ imm = #-0xbdcc
700ac8ec: 9002         	str	r0, [sp, #0x8]
;         }
700ac8ee: e7ff         	b	0x700ac8f0 <Sciclient_rmIrqUnmappedVintRouteDelete+0x50> @ imm = #-0x2
;     }
700ac8f0: e7ff         	b	0x700ac8f2 <Sciclient_rmIrqUnmappedVintRouteDelete+0x52> @ imm = #-0x2
;     return r;
700ac8f2: 9802         	ldr	r0, [sp, #0x8]
700ac8f4: b004         	add	sp, #0x10
700ac8f6: bd80         	pop	{r7, pc}
		...

700ac900 <Sciclient_rmRingCfg>:
; {
700ac900: b580         	push	{r7, lr}
700ac902: b08c         	sub	sp, #0x30
700ac904: 900b         	str	r0, [sp, #0x2c]
700ac906: 910a         	str	r1, [sp, #0x28]
700ac908: 9209         	str	r2, [sp, #0x24]
700ac90a: f241 1010    	movw	r0, #0x1110
;     sciReq.messageType    = TISCI_MSG_RM_RING_CFG;
700ac90e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac912: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac914: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac916: 980b         	ldr	r0, [sp, #0x2c]
700ac918: 9005         	str	r0, [sp, #0x14]
700ac91a: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac91c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac91e: 9809         	ldr	r0, [sp, #0x24]
700ac920: 9007         	str	r0, [sp, #0x1c]
700ac922: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac924: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac926: 980a         	ldr	r0, [sp, #0x28]
700ac928: 9001         	str	r0, [sp, #0x4]
700ac92a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac92c: 9002         	str	r0, [sp, #0x8]
700ac92e: a803         	add	r0, sp, #0xc
700ac930: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac932: f7f0 fe55    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xf356
700ac936: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac938: 9808         	ldr	r0, [sp, #0x20]
700ac93a: b930         	cbnz	r0, 0x700ac94a <Sciclient_rmRingCfg+0x4a> @ imm = #0xc
700ac93c: e7ff         	b	0x700ac93e <Sciclient_rmRingCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac93e: 9800         	ldr	r0, [sp]
700ac940: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac944: 2802         	cmp	r0, #0x2
700ac946: d004         	beq	0x700ac952 <Sciclient_rmRingCfg+0x52> @ imm = #0x8
700ac948: e7ff         	b	0x700ac94a <Sciclient_rmRingCfg+0x4a> @ imm = #-0x2
700ac94a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac94e: 9008         	str	r0, [sp, #0x20]
;     }
700ac950: e7ff         	b	0x700ac952 <Sciclient_rmRingCfg+0x52> @ imm = #-0x2
;     return r;
700ac952: 9808         	ldr	r0, [sp, #0x20]
700ac954: b00c         	add	sp, #0x30
700ac956: bd80         	pop	{r7, pc}
		...

700ac960 <Sciclient_rmUdmapFlowCfg>:
; {
700ac960: b580         	push	{r7, lr}
700ac962: b08c         	sub	sp, #0x30
700ac964: 900b         	str	r0, [sp, #0x2c]
700ac966: 910a         	str	r1, [sp, #0x28]
700ac968: 9209         	str	r2, [sp, #0x24]
700ac96a: f241 2030    	movw	r0, #0x1230
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_CFG;
700ac96e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac972: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac974: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac976: 980b         	ldr	r0, [sp, #0x2c]
700ac978: 9005         	str	r0, [sp, #0x14]
700ac97a: 2029         	movs	r0, #0x29
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac97c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac97e: 9809         	ldr	r0, [sp, #0x24]
700ac980: 9007         	str	r0, [sp, #0x1c]
700ac982: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac984: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac986: 980a         	ldr	r0, [sp, #0x28]
700ac988: 9001         	str	r0, [sp, #0x4]
700ac98a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac98c: 9002         	str	r0, [sp, #0x8]
700ac98e: a803         	add	r0, sp, #0xc
700ac990: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac992: f7f0 fe25    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xf3b6
700ac996: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac998: 9808         	ldr	r0, [sp, #0x20]
700ac99a: b930         	cbnz	r0, 0x700ac9aa <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #0xc
700ac99c: e7ff         	b	0x700ac99e <Sciclient_rmUdmapFlowCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac99e: 9800         	ldr	r0, [sp]
700ac9a0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700ac9a4: 2802         	cmp	r0, #0x2
700ac9a6: d004         	beq	0x700ac9b2 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #0x8
700ac9a8: e7ff         	b	0x700ac9aa <Sciclient_rmUdmapFlowCfg+0x4a> @ imm = #-0x2
700ac9aa: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700ac9ae: 9008         	str	r0, [sp, #0x20]
;     }
700ac9b0: e7ff         	b	0x700ac9b2 <Sciclient_rmUdmapFlowCfg+0x52> @ imm = #-0x2
;     return r;
700ac9b2: 9808         	ldr	r0, [sp, #0x20]
700ac9b4: b00c         	add	sp, #0x30
700ac9b6: bd80         	pop	{r7, pc}
		...

700ac9c0 <Sciclient_rmUdmapFlowSizeThreshCfg>:
; {
700ac9c0: b580         	push	{r7, lr}
700ac9c2: b08c         	sub	sp, #0x30
700ac9c4: 900b         	str	r0, [sp, #0x2c]
700ac9c6: 910a         	str	r1, [sp, #0x28]
700ac9c8: 9209         	str	r2, [sp, #0x24]
700ac9ca: f241 2031    	movw	r0, #0x1231
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_FLOW_SIZE_THRESH_CFG;
700ac9ce: f8ad 000c    	strh.w	r0, [sp, #0xc]
700ac9d2: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700ac9d4: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700ac9d6: 980b         	ldr	r0, [sp, #0x2c]
700ac9d8: 9005         	str	r0, [sp, #0x14]
700ac9da: 201d         	movs	r0, #0x1d
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700ac9dc: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700ac9de: 9809         	ldr	r0, [sp, #0x24]
700ac9e0: 9007         	str	r0, [sp, #0x1c]
700ac9e2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700ac9e4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700ac9e6: 980a         	ldr	r0, [sp, #0x28]
700ac9e8: 9001         	str	r0, [sp, #0x4]
700ac9ea: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700ac9ec: 9002         	str	r0, [sp, #0x8]
700ac9ee: a803         	add	r0, sp, #0xc
700ac9f0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700ac9f2: f7f0 fdf5    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xf416
700ac9f6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700ac9f8: 9808         	ldr	r0, [sp, #0x20]
700ac9fa: b930         	cbnz	r0, 0x700aca0a <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #0xc
700ac9fc: e7ff         	b	0x700ac9fe <Sciclient_rmUdmapFlowSizeThreshCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700ac9fe: 9800         	ldr	r0, [sp]
700aca00: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aca04: 2802         	cmp	r0, #0x2
700aca06: d004         	beq	0x700aca12 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #0x8
700aca08: e7ff         	b	0x700aca0a <Sciclient_rmUdmapFlowSizeThreshCfg+0x4a> @ imm = #-0x2
700aca0a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aca0e: 9008         	str	r0, [sp, #0x20]
;     }
700aca10: e7ff         	b	0x700aca12 <Sciclient_rmUdmapFlowSizeThreshCfg+0x52> @ imm = #-0x2
;     return r;
700aca12: 9808         	ldr	r0, [sp, #0x20]
700aca14: b00c         	add	sp, #0x30
700aca16: bd80         	pop	{r7, pc}
		...

700aca20 <Sciclient_rmUdmapRxChCfg>:
; {
700aca20: b580         	push	{r7, lr}
700aca22: b08c         	sub	sp, #0x30
700aca24: 900b         	str	r0, [sp, #0x2c]
700aca26: 910a         	str	r1, [sp, #0x28]
700aca28: 9209         	str	r2, [sp, #0x24]
700aca2a: f241 2015    	movw	r0, #0x1215
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_RX_CH_CFG;
700aca2e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aca32: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aca34: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aca36: 980b         	ldr	r0, [sp, #0x2c]
700aca38: 9005         	str	r0, [sp, #0x14]
700aca3a: 2022         	movs	r0, #0x22
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aca3c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aca3e: 9809         	ldr	r0, [sp, #0x24]
700aca40: 9007         	str	r0, [sp, #0x1c]
700aca42: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700aca44: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700aca46: 980a         	ldr	r0, [sp, #0x28]
700aca48: 9001         	str	r0, [sp, #0x4]
700aca4a: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700aca4c: 9002         	str	r0, [sp, #0x8]
700aca4e: a803         	add	r0, sp, #0xc
700aca50: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700aca52: f7f0 fdc5    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xf476
700aca56: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700aca58: 9808         	ldr	r0, [sp, #0x20]
700aca5a: b930         	cbnz	r0, 0x700aca6a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #0xc
700aca5c: e7ff         	b	0x700aca5e <Sciclient_rmUdmapRxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700aca5e: 9800         	ldr	r0, [sp]
700aca60: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700aca64: 2802         	cmp	r0, #0x2
700aca66: d004         	beq	0x700aca72 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #0x8
700aca68: e7ff         	b	0x700aca6a <Sciclient_rmUdmapRxChCfg+0x4a> @ imm = #-0x2
700aca6a: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700aca6e: 9008         	str	r0, [sp, #0x20]
;     }
700aca70: e7ff         	b	0x700aca72 <Sciclient_rmUdmapRxChCfg+0x52> @ imm = #-0x2
;     return r;
700aca72: 9808         	ldr	r0, [sp, #0x20]
700aca74: b00c         	add	sp, #0x30
700aca76: bd80         	pop	{r7, pc}
		...

700aca80 <Sciclient_rmUdmapTxChCfg>:
; {
700aca80: b580         	push	{r7, lr}
700aca82: b08c         	sub	sp, #0x30
700aca84: 900b         	str	r0, [sp, #0x2c]
700aca86: 910a         	str	r1, [sp, #0x28]
700aca88: 9209         	str	r2, [sp, #0x24]
700aca8a: f241 2005    	movw	r0, #0x1205
;     sciReq.messageType    = TISCI_MSG_RM_UDMAP_TX_CH_CFG;
700aca8e: f8ad 000c    	strh.w	r0, [sp, #0xc]
700aca92: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700aca94: 9004         	str	r0, [sp, #0x10]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700aca96: 980b         	ldr	r0, [sp, #0x2c]
700aca98: 9005         	str	r0, [sp, #0x14]
700aca9a: 2024         	movs	r0, #0x24
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700aca9c: 9006         	str	r0, [sp, #0x18]
;     sciReq.timeout        = timeout;
700aca9e: 9809         	ldr	r0, [sp, #0x24]
700acaa0: 9007         	str	r0, [sp, #0x1c]
700acaa2: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700acaa4: 9000         	str	r0, [sp]
;     sciResp.pRespPayload    = (uint8_t *) resp;
700acaa6: 980a         	ldr	r0, [sp, #0x28]
700acaa8: 9001         	str	r0, [sp, #0x4]
700acaaa: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = (uint32_t) sizeof(*resp);
700acaac: 9002         	str	r0, [sp, #0x8]
700acaae: a803         	add	r0, sp, #0xc
700acab0: 4669         	mov	r1, sp
;     r = Sciclient_service(&sciReq, &sciResp);
700acab2: f7f0 fd95    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xf4d6
700acab6: 9008         	str	r0, [sp, #0x20]
;     if ((r != SystemP_SUCCESS) ||
700acab8: 9808         	ldr	r0, [sp, #0x20]
700acaba: b930         	cbnz	r0, 0x700acaca <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #0xc
700acabc: e7ff         	b	0x700acabe <Sciclient_rmUdmapTxChCfg+0x3e> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700acabe: 9800         	ldr	r0, [sp]
700acac0: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700acac4: 2802         	cmp	r0, #0x2
700acac6: d004         	beq	0x700acad2 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #0x8
700acac8: e7ff         	b	0x700acaca <Sciclient_rmUdmapTxChCfg+0x4a> @ imm = #-0x2
700acaca: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700acace: 9008         	str	r0, [sp, #0x20]
;     }
700acad0: e7ff         	b	0x700acad2 <Sciclient_rmUdmapTxChCfg+0x52> @ imm = #-0x2
;     return r;
700acad2: 9808         	ldr	r0, [sp, #0x20]
700acad4: b00c         	add	sp, #0x30
700acad6: bd80         	pop	{r7, pc}

700acad8 <_outs>:
700acad8: e92d4070     	push	{r4, r5, r6, lr}
700acadc: e5916004     	ldr	r6, [r1, #0x4]
700acae0: e1a04001     	mov	r4, r1
700acae4: e5913008     	ldr	r3, [r1, #0x8]
700acae8: e1a05002     	mov	r5, r2
700acaec: e1560003     	cmp	r6, r3
700acaf0: 9a00000a     	bls	0x700acb20 <_outs+0x48> @ imm = #0x28
700acaf4: e0466003     	sub	r6, r6, r3
700acaf8: e1a01000     	mov	r1, r0
700acafc: e5940000     	ldr	r0, [r4]
700acb00: e1560005     	cmp	r6, r5
700acb04: 21a06005     	movhs	r6, r5
700acb08: e1a02006     	mov	r2, r6
700acb0c: ebffb572     	bl	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0x12a38
700acb10: e5940000     	ldr	r0, [r4]
700acb14: e5943008     	ldr	r3, [r4, #0x8]
700acb18: e0800006     	add	r0, r0, r6
700acb1c: e5840000     	str	r0, [r4]
700acb20: e0831005     	add	r1, r3, r5
700acb24: e1a00005     	mov	r0, r5
700acb28: e5841008     	str	r1, [r4, #0x8]
700acb2c: e8bd8070     	pop	{r4, r5, r6, pc}

700acb30 <xQueueGenericCreate>:
;     {
700acb30: b580         	push	{r7, lr}
700acb32: b088         	sub	sp, #0x20
700acb34: 9007         	str	r0, [sp, #0x1c]
700acb36: 9106         	str	r1, [sp, #0x18]
700acb38: f88d 2017    	strb.w	r2, [sp, #0x17]
;         xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
700acb3c: 9807         	ldr	r0, [sp, #0x1c]
700acb3e: 9906         	ldr	r1, [sp, #0x18]
700acb40: 4348         	muls	r0, r1, r0
700acb42: 9003         	str	r0, [sp, #0xc]
;         pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
700acb44: 9803         	ldr	r0, [sp, #0xc]
700acb46: 3050         	adds	r0, #0x50
700acb48: f002 fd2a    	bl	0x700af5a0 <pvPortMalloc> @ imm = #0x2a54
700acb4c: 9004         	str	r0, [sp, #0x10]
;         if( pxNewQueue != NULL )
700acb4e: 9804         	ldr	r0, [sp, #0x10]
700acb50: b1b0         	cbz	r0, 0x700acb80 <xQueueGenericCreate+0x50> @ imm = #0x2c
700acb52: e7ff         	b	0x700acb54 <xQueueGenericCreate+0x24> @ imm = #-0x2
;             pucQueueStorage = ( uint8_t * ) pxNewQueue;
700acb54: 9804         	ldr	r0, [sp, #0x10]
700acb56: 9002         	str	r0, [sp, #0x8]
;             pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
700acb58: 9802         	ldr	r0, [sp, #0x8]
700acb5a: 3050         	adds	r0, #0x50
700acb5c: 9002         	str	r0, [sp, #0x8]
;                     pxNewQueue->ucStaticallyAllocated = pdFALSE;
700acb5e: 9904         	ldr	r1, [sp, #0x10]
700acb60: 2000         	movs	r0, #0x0
700acb62: f881 0046    	strb.w	r0, [r1, #0x46]
;             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
700acb66: 9807         	ldr	r0, [sp, #0x1c]
700acb68: 9906         	ldr	r1, [sp, #0x18]
700acb6a: 9a02         	ldr	r2, [sp, #0x8]
700acb6c: f89d 3017    	ldrb.w	r3, [sp, #0x17]
700acb70: f8dd c010    	ldr.w	r12, [sp, #0x10]
700acb74: 46ee         	mov	lr, sp
700acb76: f8ce c000    	str.w	r12, [lr]
700acb7a: f000 fda1    	bl	0x700ad6c0 <prvInitialiseNewQueue> @ imm = #0xb42
;         }
700acb7e: e000         	b	0x700acb82 <xQueueGenericCreate+0x52> @ imm = #0x0
700acb80: e7ff         	b	0x700acb82 <xQueueGenericCreate+0x52> @ imm = #-0x2
;         return pxNewQueue;
700acb82: 9804         	ldr	r0, [sp, #0x10]
700acb84: b008         	add	sp, #0x20
700acb86: bd80         	pop	{r7, pc}

700acb88 <__TI_auto_init_nobinit_nopinit>:
700acb88: e92d4070     	push	{r4, r5, r6, lr}
700acb8c: e59f4040     	ldr	r4, [pc, #0x40]         @ 0x700acbd4 <__TI_auto_init_nobinit_nopinit+0x4c>
700acb90: e59f0038     	ldr	r0, [pc, #0x38]         @ 0x700acbd0 <__TI_auto_init_nobinit_nopinit+0x48>
700acb94: e1540000     	cmp	r4, r0
700acb98: 0a00000a     	beq	0x700acbc8 <__TI_auto_init_nobinit_nopinit+0x40> @ imm = #0x28
700acb9c: e59f5034     	ldr	r5, [pc, #0x34]         @ 0x700acbd8 <__TI_auto_init_nobinit_nopinit+0x50>
700acba0: e59f6034     	ldr	r6, [pc, #0x34]         @ 0x700acbdc <__TI_auto_init_nobinit_nopinit+0x54>
700acba4: e1550006     	cmp	r5, r6
700acba8: 0a000006     	beq	0x700acbc8 <__TI_auto_init_nobinit_nopinit+0x40> @ imm = #0x18
700acbac: e5950000     	ldr	r0, [r5]
700acbb0: e5951004     	ldr	r1, [r5, #0x4]
700acbb4: e4d02001     	ldrb	r2, [r0], #1
700acbb8: e7942102     	ldr	r2, [r4, r2, lsl #2]
700acbbc: e12fff32     	blx	r2
700acbc0: e2855008     	add	r5, r5, #8
700acbc4: eafffff6     	b	0x700acba4 <__TI_auto_init_nobinit_nopinit+0x1c> @ imm = #-0x28
700acbc8: e1a00000     	mov	r0, r0
700acbcc: e8bd8070     	pop	{r4, r5, r6, pc}
700acbd0: 00 00 00 00  	.word	0x00000000
700acbd4: 00 00 00 00  	.word	0x00000000
700acbd8: 00 00 00 00  	.word	0x00000000
700acbdc: 00 00 00 00  	.word	0x00000000

700acbe0 <Sciclient_rmIrqReleaseRaw>:
; {
700acbe0: b580         	push	{r7, lr}
700acbe2: b08e         	sub	sp, #0x38
700acbe4: 900d         	str	r0, [sp, #0x34]
700acbe6: 910c         	str	r1, [sp, #0x30]
700acbe8: f241 0001    	movw	r0, #0x1001
;     sciReq.messageType    = TISCI_MSG_RM_IRQ_RELEASE;
700acbec: f8ad 0018    	strh.w	r0, [sp, #0x18]
700acbf0: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700acbf2: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700acbf4: 980d         	ldr	r0, [sp, #0x34]
700acbf6: 9008         	str	r0, [sp, #0x20]
700acbf8: 201c         	movs	r0, #0x1c
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700acbfa: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700acbfc: 980c         	ldr	r0, [sp, #0x30]
700acbfe: 900a         	str	r0, [sp, #0x28]
700acc00: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700acc02: 9003         	str	r0, [sp, #0xc]
700acc04: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700acc06: 9004         	str	r0, [sp, #0x10]
700acc08: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700acc0a: 9005         	str	r0, [sp, #0x14]
700acc0c: a806         	add	r0, sp, #0x18
700acc0e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700acc10: f7f0 fce6    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xf634
700acc14: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700acc16: 980b         	ldr	r0, [sp, #0x2c]
700acc18: b930         	cbnz	r0, 0x700acc28 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #0xc
700acc1a: e7ff         	b	0x700acc1c <Sciclient_rmIrqReleaseRaw+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700acc1c: 9803         	ldr	r0, [sp, #0xc]
700acc1e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700acc22: 2802         	cmp	r0, #0x2
700acc24: d004         	beq	0x700acc30 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #0x8
700acc26: e7ff         	b	0x700acc28 <Sciclient_rmIrqReleaseRaw+0x48> @ imm = #-0x2
700acc28: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700acc2c: 900b         	str	r0, [sp, #0x2c]
;     }
700acc2e: e7ff         	b	0x700acc30 <Sciclient_rmIrqReleaseRaw+0x50> @ imm = #-0x2
;     return r;
700acc30: 980b         	ldr	r0, [sp, #0x2c]
700acc32: b00e         	add	sp, #0x38
700acc34: bd80         	pop	{r7, pc}
		...
700acc3e: 0000         	movs	r0, r0

700acc40 <Sciclient_rmPsilPair>:
; {
700acc40: b580         	push	{r7, lr}
700acc42: b08e         	sub	sp, #0x38
700acc44: 900d         	str	r0, [sp, #0x34]
700acc46: 910c         	str	r1, [sp, #0x30]
700acc48: f44f 5094    	mov.w	r0, #0x1280
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_PAIR;
700acc4c: f8ad 0018    	strh.w	r0, [sp, #0x18]
700acc50: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700acc52: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700acc54: 980d         	ldr	r0, [sp, #0x34]
700acc56: 9008         	str	r0, [sp, #0x20]
700acc58: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700acc5a: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700acc5c: 980c         	ldr	r0, [sp, #0x30]
700acc5e: 900a         	str	r0, [sp, #0x28]
700acc60: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700acc62: 9003         	str	r0, [sp, #0xc]
700acc64: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t*)&resp;
700acc66: 9004         	str	r0, [sp, #0x10]
700acc68: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700acc6a: 9005         	str	r0, [sp, #0x14]
700acc6c: a806         	add	r0, sp, #0x18
700acc6e: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700acc70: f7f0 fcb6    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xf694
700acc74: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700acc76: 980b         	ldr	r0, [sp, #0x2c]
700acc78: b930         	cbnz	r0, 0x700acc88 <Sciclient_rmPsilPair+0x48> @ imm = #0xc
700acc7a: e7ff         	b	0x700acc7c <Sciclient_rmPsilPair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700acc7c: 9803         	ldr	r0, [sp, #0xc]
700acc7e: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700acc82: 2802         	cmp	r0, #0x2
700acc84: d004         	beq	0x700acc90 <Sciclient_rmPsilPair+0x50> @ imm = #0x8
700acc86: e7ff         	b	0x700acc88 <Sciclient_rmPsilPair+0x48> @ imm = #-0x2
700acc88: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700acc8c: 900b         	str	r0, [sp, #0x2c]
;     }
700acc8e: e7ff         	b	0x700acc90 <Sciclient_rmPsilPair+0x50> @ imm = #-0x2
;     return r;
700acc90: 980b         	ldr	r0, [sp, #0x2c]
700acc92: b00e         	add	sp, #0x38
700acc94: bd80         	pop	{r7, pc}
		...
700acc9e: 0000         	movs	r0, r0

700acca0 <Sciclient_rmPsilUnpair>:
; {
700acca0: b580         	push	{r7, lr}
700acca2: b08e         	sub	sp, #0x38
700acca4: 900d         	str	r0, [sp, #0x34]
700acca6: 910c         	str	r1, [sp, #0x30]
700acca8: f241 2081    	movw	r0, #0x1281
;     sciReq.messageType    = TISCI_MSG_RM_PSIL_UNPAIR;
700accac: f8ad 0018    	strh.w	r0, [sp, #0x18]
700accb0: 2002         	movs	r0, #0x2
;     sciReq.flags          = TISCI_MSG_FLAG_AOP;
700accb2: 9007         	str	r0, [sp, #0x1c]
;     sciReq.pReqPayload    = (const uint8_t *) req;
700accb4: 980d         	ldr	r0, [sp, #0x34]
700accb6: 9008         	str	r0, [sp, #0x20]
700accb8: 2014         	movs	r0, #0x14
;     sciReq.reqPayloadSize = (uint32_t) sizeof(*req);
700accba: 9009         	str	r0, [sp, #0x24]
;     sciReq.timeout        = timeout;
700accbc: 980c         	ldr	r0, [sp, #0x30]
700accbe: 900a         	str	r0, [sp, #0x28]
700accc0: 2000         	movs	r0, #0x0
;     sciResp.flags           = 0;
700accc2: 9003         	str	r0, [sp, #0xc]
700accc4: a801         	add	r0, sp, #0x4
;     sciResp.pRespPayload    = (uint8_t *)&resp;
700accc6: 9004         	str	r0, [sp, #0x10]
700accc8: 2008         	movs	r0, #0x8
;     sciResp.respPayloadSize = sizeof(resp);
700accca: 9005         	str	r0, [sp, #0x14]
700acccc: a806         	add	r0, sp, #0x18
700accce: a903         	add	r1, sp, #0xc
;     r = Sciclient_service(&sciReq, &sciResp);
700accd0: f7f0 fc86    	bl	0x7009d5e0 <Sciclient_service> @ imm = #-0xf6f4
700accd4: 900b         	str	r0, [sp, #0x2c]
;     if ((r != SystemP_SUCCESS) ||
700accd6: 980b         	ldr	r0, [sp, #0x2c]
700accd8: b930         	cbnz	r0, 0x700acce8 <Sciclient_rmPsilUnpair+0x48> @ imm = #0xc
700accda: e7ff         	b	0x700accdc <Sciclient_rmPsilUnpair+0x3c> @ imm = #-0x2
;         ((sciResp.flags & TISCI_MSG_FLAG_ACK) != TISCI_MSG_FLAG_ACK)) {
700accdc: 9803         	ldr	r0, [sp, #0xc]
700accde: f000 0002    	and	r0, r0, #0x2
;     if ((r != SystemP_SUCCESS) ||
700acce2: 2802         	cmp	r0, #0x2
700acce4: d004         	beq	0x700accf0 <Sciclient_rmPsilUnpair+0x50> @ imm = #0x8
700acce6: e7ff         	b	0x700acce8 <Sciclient_rmPsilUnpair+0x48> @ imm = #-0x2
700acce8: f04f 30ff    	mov.w	r0, #0xffffffff
;         r = SystemP_FAILURE;
700accec: 900b         	str	r0, [sp, #0x2c]
;     }
700accee: e7ff         	b	0x700accf0 <Sciclient_rmPsilUnpair+0x50> @ imm = #-0x2
;     return r;
700accf0: 980b         	ldr	r0, [sp, #0x2c]
700accf2: b00e         	add	sp, #0x38
700accf4: bd80         	pop	{r7, pc}
		...
700accfe: 0000         	movs	r0, r0

700acd00 <Udma_chSetPeerReg>:
; {
700acd00: b580         	push	{r7, lr}
700acd02: b086         	sub	sp, #0x18
700acd04: f8dd c020    	ldr.w	r12, [sp, #0x20]
700acd08: 9005         	str	r0, [sp, #0x14]
700acd0a: 9104         	str	r1, [sp, #0x10]
700acd0c: 9203         	str	r2, [sp, #0xc]
700acd0e: 9302         	str	r3, [sp, #0x8]
;     regVal = CSL_REG32_RD(PEER8);
700acd10: 9803         	ldr	r0, [sp, #0xc]
700acd12: f002 ff9d    	bl	0x700afc50 <CSL_REG32_RD_RAW> @ imm = #0x2f3a
700acd16: 9001         	str	r0, [sp, #0x4]
;     CSL_FINS(regVal, PSILCFG_REG_RT_ENABLE_ENABLE, (uint32_t) 0U);
700acd18: 9801         	ldr	r0, [sp, #0x4]
700acd1a: f020 4000    	bic	r0, r0, #0x80000000
700acd1e: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER8, regVal);
700acd20: 9803         	ldr	r0, [sp, #0xc]
700acd22: 9901         	ldr	r1, [sp, #0x4]
700acd24: f002 fef4    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x2de8
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700acd28: 9804         	ldr	r0, [sp, #0x10]
700acd2a: 6801         	ldr	r1, [r0]
;                 CSL_FMK(PSILCFG_REG_STATIC_TR_Y, pdmaPrms->elemCnt);
700acd2c: 6840         	ldr	r0, [r0, #0x4]
700acd2e: f36f 301f    	bfc	r0, #12, #20
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_X, pdmaPrms->elemSize) |
700acd32: f361 601a    	bfi	r0, r1, #24, #3
700acd36: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER0, regVal);
700acd38: 9808         	ldr	r0, [sp, #0x20]
700acd3a: 9901         	ldr	r1, [sp, #0x4]
700acd3c: f002 fee8    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x2dd0
;     regVal = CSL_FMK(PSILCFG_REG_STATIC_TR_Z, pdmaPrms->fifoCnt);
700acd40: 9804         	ldr	r0, [sp, #0x10]
700acd42: 6880         	ldr	r0, [r0, #0x8]
700acd44: f36f 301f    	bfc	r0, #12, #20
700acd48: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR(PEER1, regVal);
700acd4a: 9802         	ldr	r0, [sp, #0x8]
700acd4c: 9901         	ldr	r1, [sp, #0x4]
700acd4e: f002 fedf    	bl	0x700afb10 <CSL_REG32_WR_RAW> @ imm = #0x2dbe
; }
700acd52: b006         	add	sp, #0x18
700acd54: bd80         	pop	{r7, pc}
		...
700acd5e: 0000         	movs	r0, r0

700acd60 <Udma_eventGetGlobalHandle>:
; {
700acd60: b084         	sub	sp, #0x10
700acd62: 9003         	str	r0, [sp, #0xc]
700acd64: 2000         	movs	r0, #0x0
;     int32_t             retVal = UDMA_SOK;
700acd66: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandle    eventHandle = (Udma_EventHandle) NULL_PTR;
700acd68: 9000         	str	r0, [sp]
;     if(NULL_PTR == drvHandle)
700acd6a: 9803         	ldr	r0, [sp, #0xc]
700acd6c: b920         	cbnz	r0, 0x700acd78 <Udma_eventGetGlobalHandle+0x18> @ imm = #0x8
700acd6e: e7ff         	b	0x700acd70 <Udma_eventGetGlobalHandle+0x10> @ imm = #-0x2
700acd70: f06f 0001    	mvn	r0, #0x1
;         retVal = UDMA_EBADARGS;
700acd74: 9002         	str	r0, [sp, #0x8]
;     }
700acd76: e7ff         	b	0x700acd78 <Udma_eventGetGlobalHandle+0x18> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700acd78: 9802         	ldr	r0, [sp, #0x8]
700acd7a: b988         	cbnz	r0, 0x700acda0 <Udma_eventGetGlobalHandle+0x40> @ imm = #0x22
700acd7c: e7ff         	b	0x700acd7e <Udma_eventGetGlobalHandle+0x1e> @ imm = #-0x2
;         drvHandleInt = (Udma_DrvHandleInt) drvHandle;
700acd7e: 9803         	ldr	r0, [sp, #0xc]
700acd80: 9001         	str	r0, [sp, #0x4]
;         if(drvHandleInt->drvInitDone != UDMA_INIT_DONE)
700acd82: 9801         	ldr	r0, [sp, #0x4]
700acd84: f8d0 02c4    	ldr.w	r0, [r0, #0x2c4]
700acd88: f64a 31cd    	movw	r1, #0xabcd
700acd8c: f6ca 31dc    	movt	r1, #0xabdc
700acd90: 4288         	cmp	r0, r1
700acd92: d004         	beq	0x700acd9e <Udma_eventGetGlobalHandle+0x3e> @ imm = #0x8
700acd94: e7ff         	b	0x700acd96 <Udma_eventGetGlobalHandle+0x36> @ imm = #-0x2
700acd96: f04f 30ff    	mov.w	r0, #0xffffffff
;             retVal = UDMA_EFAIL;
700acd9a: 9002         	str	r0, [sp, #0x8]
;         }
700acd9c: e7ff         	b	0x700acd9e <Udma_eventGetGlobalHandle+0x3e> @ imm = #-0x2
;     }
700acd9e: e7ff         	b	0x700acda0 <Udma_eventGetGlobalHandle+0x40> @ imm = #-0x2
;     if(UDMA_SOK == retVal)
700acda0: 9802         	ldr	r0, [sp, #0x8]
700acda2: b928         	cbnz	r0, 0x700acdb0 <Udma_eventGetGlobalHandle+0x50> @ imm = #0xa
700acda4: e7ff         	b	0x700acda6 <Udma_eventGetGlobalHandle+0x46> @ imm = #-0x2
;         eventHandle = (Udma_EventHandle) drvHandleInt->globalEventHandle;
700acda6: 9801         	ldr	r0, [sp, #0x4]
700acda8: f8d0 01c0    	ldr.w	r0, [r0, #0x1c0]
700acdac: 9000         	str	r0, [sp]
;     }
700acdae: e7ff         	b	0x700acdb0 <Udma_eventGetGlobalHandle+0x50> @ imm = #-0x2
;     return (eventHandle);
700acdb0: 9800         	ldr	r0, [sp]
700acdb2: b004         	add	sp, #0x10
700acdb4: 4770         	bx	lr
		...
700acdbe: 0000         	movs	r0, r0

700acdc0 <CSL_pktdmaIsValidChanIdx>:
; {
700acdc0: b084         	sub	sp, #0x10
700acdc2: 9003         	str	r0, [sp, #0xc]
700acdc4: 9102         	str	r1, [sp, #0x8]
700acdc6: 9201         	str	r2, [sp, #0x4]
;     if( (chanDir == CSL_PKTDMA_CHAN_DIR_TX) && (chanIdx < pCfg->txChanCnt) )
700acdc8: 9801         	ldr	r0, [sp, #0x4]
700acdca: b950         	cbnz	r0, 0x700acde2 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x14
700acdcc: e7ff         	b	0x700acdce <CSL_pktdmaIsValidChanIdx+0xe> @ imm = #-0x2
700acdce: 9802         	ldr	r0, [sp, #0x8]
700acdd0: 9903         	ldr	r1, [sp, #0xc]
700acdd2: 6a09         	ldr	r1, [r1, #0x20]
700acdd4: 4288         	cmp	r0, r1
700acdd6: d204         	bhs	0x700acde2 <CSL_pktdmaIsValidChanIdx+0x22> @ imm = #0x8
700acdd8: e7ff         	b	0x700acdda <CSL_pktdmaIsValidChanIdx+0x1a> @ imm = #-0x2
700acdda: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700acddc: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700acde0: e012         	b	0x700ace08 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #0x24
;     else if( (chanDir == CSL_PKTDMA_CHAN_DIR_RX) && (chanIdx < pCfg->rxChanCnt) )
700acde2: 9801         	ldr	r0, [sp, #0x4]
700acde4: 2801         	cmp	r0, #0x1
700acde6: d10a         	bne	0x700acdfe <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x14
700acde8: e7ff         	b	0x700acdea <CSL_pktdmaIsValidChanIdx+0x2a> @ imm = #-0x2
700acdea: 9802         	ldr	r0, [sp, #0x8]
700acdec: 9903         	ldr	r1, [sp, #0xc]
700acdee: 6a49         	ldr	r1, [r1, #0x24]
700acdf0: 4288         	cmp	r0, r1
700acdf2: d204         	bhs	0x700acdfe <CSL_pktdmaIsValidChanIdx+0x3e> @ imm = #0x8
700acdf4: e7ff         	b	0x700acdf6 <CSL_pktdmaIsValidChanIdx+0x36> @ imm = #-0x2
700acdf6: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700acdf8: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700acdfc: e003         	b	0x700ace06 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #0x6
700acdfe: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700ace00: f88d 0003    	strb.w	r0, [sp, #0x3]
700ace04: e7ff         	b	0x700ace06 <CSL_pktdmaIsValidChanIdx+0x46> @ imm = #-0x2
700ace06: e7ff         	b	0x700ace08 <CSL_pktdmaIsValidChanIdx+0x48> @ imm = #-0x2
;     return bRetVal;
700ace08: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ace0c: f000 0001    	and	r0, r0, #0x1
700ace10: b004         	add	sp, #0x10
700ace12: 4770         	bx	lr
		...

700ace20 <Sciclient_rmUnmappedVintRouteCreate>:
; {
700ace20: b580         	push	{r7, lr}
700ace22: b084         	sub	sp, #0x10
700ace24: 9003         	str	r0, [sp, #0xc]
;     r = Sciclient_rmIaVintGetInfo(cfg->s_ia, cfg->vint, &num_evts);
700ace26: 9903         	ldr	r1, [sp, #0xc]
700ace28: 8a08         	ldrh	r0, [r1, #0x10]
700ace2a: 8a49         	ldrh	r1, [r1, #0x12]
700ace2c: f10d 0207    	add.w	r2, sp, #0x7
700ace30: f7fe fbc6    	bl	0x700ab5c0 <Sciclient_rmIaVintGetInfo> @ imm = #-0x1874
700ace34: 9002         	str	r0, [sp, #0x8]
;     if ((r == SystemP_SUCCESS) && (num_evts > 0U)) {
700ace36: 9802         	ldr	r0, [sp, #0x8]
700ace38: b940         	cbnz	r0, 0x700ace4c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x10
700ace3a: e7ff         	b	0x700ace3c <Sciclient_rmUnmappedVintRouteCreate+0x1c> @ imm = #-0x2
700ace3c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700ace40: b120         	cbz	r0, 0x700ace4c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #0x8
700ace42: e7ff         	b	0x700ace44 <Sciclient_rmUnmappedVintRouteCreate+0x24> @ imm = #-0x2
700ace44: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ace48: 9002         	str	r0, [sp, #0x8]
;     }
700ace4a: e7ff         	b	0x700ace4c <Sciclient_rmUnmappedVintRouteCreate+0x2c> @ imm = #-0x2
;     if (r == SystemP_SUCCESS) {
700ace4c: 9802         	ldr	r0, [sp, #0x8]
700ace4e: b970         	cbnz	r0, 0x700ace6e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #0x1c
700ace50: e7ff         	b	0x700ace52 <Sciclient_rmUnmappedVintRouteCreate+0x32> @ imm = #-0x2
;         r = Sciclient_rmIrqFindRoute(cfg);
700ace52: 9803         	ldr	r0, [sp, #0xc]
700ace54: f7f1 fb84    	bl	0x7009e560 <Sciclient_rmIrqFindRoute> @ imm = #-0xe8f8
700ace58: 9002         	str	r0, [sp, #0x8]
;         if (r == SystemP_SUCCESS) {
700ace5a: 9802         	ldr	r0, [sp, #0x8]
700ace5c: b930         	cbnz	r0, 0x700ace6c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #0xc
700ace5e: e7ff         	b	0x700ace60 <Sciclient_rmUnmappedVintRouteCreate+0x40> @ imm = #-0x2
;             r = Sciclient_rmIrqProgramRoute(cfg, false);
700ace60: 9803         	ldr	r0, [sp, #0xc]
700ace62: 2100         	movs	r1, #0x0
700ace64: f7f4 f8b4    	bl	0x700a0fd0 <Sciclient_rmIrqProgramRoute> @ imm = #-0xbe98
700ace68: 9002         	str	r0, [sp, #0x8]
;         }
700ace6a: e7ff         	b	0x700ace6c <Sciclient_rmUnmappedVintRouteCreate+0x4c> @ imm = #-0x2
;     }
700ace6c: e7ff         	b	0x700ace6e <Sciclient_rmUnmappedVintRouteCreate+0x4e> @ imm = #-0x2
;     return r;
700ace6e: 9802         	ldr	r0, [sp, #0x8]
700ace70: b004         	add	sp, #0x10
700ace72: bd80         	pop	{r7, pc}
		...

700ace80 <UART_OperModeValid>:
; {
700ace80: b082         	sub	sp, #0x8
700ace82: 9001         	str	r0, [sp, #0x4]
700ace84: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ace88: 9000         	str	r0, [sp]
;     if(((operMode == UART_OPER_MODE_16X) ||
700ace8a: 9801         	ldr	r0, [sp, #0x4]
700ace8c: b1e0         	cbz	r0, 0x700acec8 <UART_OperModeValid+0x48> @ imm = #0x38
700ace8e: e7ff         	b	0x700ace90 <UART_OperModeValid+0x10> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_SIR) ||
700ace90: 9801         	ldr	r0, [sp, #0x4]
700ace92: 2801         	cmp	r0, #0x1
700ace94: d018         	beq	0x700acec8 <UART_OperModeValid+0x48> @ imm = #0x30
700ace96: e7ff         	b	0x700ace98 <UART_OperModeValid+0x18> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_16X_AUTO_BAUD) ||
700ace98: 9801         	ldr	r0, [sp, #0x4]
700ace9a: 2802         	cmp	r0, #0x2
700ace9c: d014         	beq	0x700acec8 <UART_OperModeValid+0x48> @ imm = #0x28
700ace9e: e7ff         	b	0x700acea0 <UART_OperModeValid+0x20> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_13X) ||
700acea0: 9801         	ldr	r0, [sp, #0x4]
700acea2: 2803         	cmp	r0, #0x3
700acea4: d010         	beq	0x700acec8 <UART_OperModeValid+0x48> @ imm = #0x20
700acea6: e7ff         	b	0x700acea8 <UART_OperModeValid+0x28> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_MIR) ||
700acea8: 9801         	ldr	r0, [sp, #0x4]
700aceaa: 2804         	cmp	r0, #0x4
700aceac: d00c         	beq	0x700acec8 <UART_OperModeValid+0x48> @ imm = #0x18
700aceae: e7ff         	b	0x700aceb0 <UART_OperModeValid+0x30> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_FIR) ||
700aceb0: 9801         	ldr	r0, [sp, #0x4]
700aceb2: 2805         	cmp	r0, #0x5
700aceb4: d008         	beq	0x700acec8 <UART_OperModeValid+0x48> @ imm = #0x10
700aceb6: e7ff         	b	0x700aceb8 <UART_OperModeValid+0x38> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_CIR) ||
700aceb8: 9801         	ldr	r0, [sp, #0x4]
700aceba: 2806         	cmp	r0, #0x6
700acebc: d004         	beq	0x700acec8 <UART_OperModeValid+0x48> @ imm = #0x8
700acebe: e7ff         	b	0x700acec0 <UART_OperModeValid+0x40> @ imm = #-0x2
;         (operMode == UART_OPER_MODE_DISABLED)))
700acec0: 9801         	ldr	r0, [sp, #0x4]
;     if(((operMode == UART_OPER_MODE_16X) ||
700acec2: 2807         	cmp	r0, #0x7
700acec4: d103         	bne	0x700acece <UART_OperModeValid+0x4e> @ imm = #0x6
700acec6: e7ff         	b	0x700acec8 <UART_OperModeValid+0x48> @ imm = #-0x2
700acec8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700aceca: 9000         	str	r0, [sp]
;     }
700acecc: e7ff         	b	0x700acece <UART_OperModeValid+0x4e> @ imm = #-0x2
;     return status;
700acece: 9800         	ldr	r0, [sp]
700aced0: b002         	add	sp, #0x8
700aced2: 4770         	bx	lr
		...

700acee0 <UdmaRingPrms_init>:
; {
700acee0: b081         	sub	sp, #0x4
700acee2: 9000         	str	r0, [sp]
;     if(NULL_PTR != ringPrms)
700acee4: 9800         	ldr	r0, [sp]
700acee6: b318         	cbz	r0, 0x700acf30 <UdmaRingPrms_init+0x50> @ imm = #0x46
700acee8: e7ff         	b	0x700aceea <UdmaRingPrms_init+0xa> @ imm = #-0x2
;         ringPrms->ringMem       = NULL_PTR;
700aceea: 9900         	ldr	r1, [sp]
700aceec: 2000         	movs	r0, #0x0
700aceee: 6008         	str	r0, [r1]
;         ringPrms->ringMemSize   = UDMA_RING_SIZE_CHECK_SKIP;
700acef0: 9a00         	ldr	r2, [sp]
700acef2: f64a 31cd    	movw	r1, #0xabcd
700acef6: f6ca 31dc    	movt	r1, #0xabdc
700acefa: 6051         	str	r1, [r2, #0x4]
;         ringPrms->mode          = TISCI_MSG_VALUE_RM_RING_MODE_RING;
700acefc: 9900         	ldr	r1, [sp]
700acefe: 7208         	strb	r0, [r1, #0x8]
;         ringPrms->virtId        = UDMA_RING_VIRTID_INVALID;
700acf00: 9a00         	ldr	r2, [sp]
700acf02: f64f 71ff    	movw	r1, #0xffff
700acf06: 8151         	strh	r1, [r2, #0xa]
;         ringPrms->elemCnt       = 0U;
700acf08: 9900         	ldr	r1, [sp]
700acf0a: 60c8         	str	r0, [r1, #0xc]
;         ringPrms->elemSize      = UDMA_RING_ES_8BYTES;
700acf0c: 9a00         	ldr	r2, [sp]
700acf0e: 2101         	movs	r1, #0x1
700acf10: 7411         	strb	r1, [r2, #0x10]
;         ringPrms->orderId       = UDMA_DEFAULT_RING_ORDER_ID;
700acf12: 9900         	ldr	r1, [sp]
700acf14: 7448         	strb	r0, [r1, #0x11]
;         ringPrms->asel          = UDMA_RINGACC_ASEL_ENDPOINT_PHYSADDR;
700acf16: 9900         	ldr	r1, [sp]
700acf18: 7488         	strb	r0, [r1, #0x12]
;         ringPrms->mappedRingGrp = UDMA_MAPPED_GROUP_INVALID;
700acf1a: 9900         	ldr	r1, [sp]
700acf1c: 2004         	movs	r0, #0x4
700acf1e: f6cf 70ff    	movt	r0, #0xffff
700acf22: 6148         	str	r0, [r1, #0x14]
;         ringPrms->mappedChNum   = UDMA_DMA_CH_INVALID;
700acf24: 9900         	ldr	r1, [sp]
700acf26: 2000         	movs	r0, #0x0
700acf28: f6cf 70ff    	movt	r0, #0xffff
700acf2c: 6188         	str	r0, [r1, #0x18]
;     }
700acf2e: e7ff         	b	0x700acf30 <UdmaRingPrms_init+0x50> @ imm = #-0x2
;     return;
700acf30: b001         	add	sp, #0x4
700acf32: 4770         	bx	lr
		...

700acf40 <prvIdleTask>:
; static portTASK_FUNCTION(prvIdleTask, pvParameters) {
700acf40: b580         	push	{r7, lr}
700acf42: b082         	sub	sp, #0x8
700acf44: 9001         	str	r0, [sp, #0x4]
;   for (;;) {
700acf46: e7ff         	b	0x700acf48 <prvIdleTask+0x8> @ imm = #-0x2
;     prvCheckTasksWaitingTermination();
700acf48: f7ff fc4a    	bl	0x700ac7e0 <prvCheckTasksWaitingTermination> @ imm = #-0x76c
;       if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) >
700acf4c: f244 40f8    	movw	r0, #0x44f8
700acf50: f2c7 0008    	movt	r0, #0x7008
700acf54: 6800         	ldr	r0, [r0]
700acf56: 2802         	cmp	r0, #0x2
700acf58: d302         	blo	0x700acf60 <prvIdleTask+0x20> @ imm = #0x4
700acf5a: e7ff         	b	0x700acf5c <prvIdleTask+0x1c> @ imm = #-0x2
;         taskYIELD();
700acf5c: df00         	svc	#0x0
;       } else {
700acf5e: e000         	b	0x700acf62 <prvIdleTask+0x22> @ imm = #0x0
700acf60: e7ff         	b	0x700acf62 <prvIdleTask+0x22> @ imm = #-0x2
;       vApplicationIdleHook();
700acf62: f002 fed5    	bl	0x700afd10 <vApplicationIdleHook> @ imm = #0x2daa
;       xExpectedIdleTime = prvGetExpectedIdleTime();
700acf66: f7fe f8cb    	bl	0x700ab100 <prvGetExpectedIdleTime> @ imm = #-0x1e6a
700acf6a: 9000         	str	r0, [sp]
;       if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700acf6c: 9800         	ldr	r0, [sp]
700acf6e: 2802         	cmp	r0, #0x2
700acf70: d30e         	blo	0x700acf90 <prvIdleTask+0x50> @ imm = #0x1c
700acf72: e7ff         	b	0x700acf74 <prvIdleTask+0x34> @ imm = #-0x2
;         vTaskSuspendAll();
700acf74: f002 fe24    	bl	0x700afbc0 <vTaskSuspendAll> @ imm = #0x2c48
;           xExpectedIdleTime = prvGetExpectedIdleTime();
700acf78: f7fe f8c2    	bl	0x700ab100 <prvGetExpectedIdleTime> @ imm = #-0x1e7c
700acf7c: 9000         	str	r0, [sp]
;           if (xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP) {
700acf7e: 9800         	ldr	r0, [sp]
700acf80: 2802         	cmp	r0, #0x2
700acf82: d301         	blo	0x700acf88 <prvIdleTask+0x48> @ imm = #0x2
700acf84: e7ff         	b	0x700acf86 <prvIdleTask+0x46> @ imm = #-0x2
;           } else {
700acf86: e000         	b	0x700acf8a <prvIdleTask+0x4a> @ imm = #0x0
700acf88: e7ff         	b	0x700acf8a <prvIdleTask+0x4a> @ imm = #-0x2
;         (void)xTaskResumeAll();
700acf8a: f7f5 f981    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0xacfe
;       } else {
700acf8e: e000         	b	0x700acf92 <prvIdleTask+0x52> @ imm = #0x0
700acf90: e7ff         	b	0x700acf92 <prvIdleTask+0x52> @ imm = #-0x2
;   for (;;) {
700acf92: e7d9         	b	0x700acf48 <prvIdleTask+0x8> @ imm = #-0x4e
		...

700acfa0 <vQueueUnregisterQueue>:
;     {
700acfa0: b082         	sub	sp, #0x8
700acfa2: 9001         	str	r0, [sp, #0x4]
700acfa4: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700acfa6: 9000         	str	r0, [sp]
700acfa8: e7ff         	b	0x700acfaa <vQueueUnregisterQueue+0xa> @ imm = #-0x2
700acfaa: 9800         	ldr	r0, [sp]
700acfac: 281f         	cmp	r0, #0x1f
700acfae: d81f         	bhi	0x700acff0 <vQueueUnregisterQueue+0x50> @ imm = #0x3e
700acfb0: e7ff         	b	0x700acfb2 <vQueueUnregisterQueue+0x12> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].xHandle == xQueue )
700acfb2: 9900         	ldr	r1, [sp]
700acfb4: f644 4078    	movw	r0, #0x4c78
700acfb8: f2c7 0008    	movt	r0, #0x7008
700acfbc: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700acfc0: 6840         	ldr	r0, [r0, #0x4]
700acfc2: 9901         	ldr	r1, [sp, #0x4]
700acfc4: 4288         	cmp	r0, r1
700acfc6: d10d         	bne	0x700acfe4 <vQueueUnregisterQueue+0x44> @ imm = #0x1a
700acfc8: e7ff         	b	0x700acfca <vQueueUnregisterQueue+0x2a> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = NULL;
700acfca: 9a00         	ldr	r2, [sp]
700acfcc: f644 4178    	movw	r1, #0x4c78
700acfd0: f2c7 0108    	movt	r1, #0x7008
700acfd4: 2000         	movs	r0, #0x0
700acfd6: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
700acfda: 9a00         	ldr	r2, [sp]
700acfdc: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700acfe0: 6048         	str	r0, [r1, #0x4]
;                 break;
700acfe2: e005         	b	0x700acff0 <vQueueUnregisterQueue+0x50> @ imm = #0xa
700acfe4: e7ff         	b	0x700acfe6 <vQueueUnregisterQueue+0x46> @ imm = #-0x2
;         }
700acfe6: e7ff         	b	0x700acfe8 <vQueueUnregisterQueue+0x48> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700acfe8: 9800         	ldr	r0, [sp]
700acfea: 3001         	adds	r0, #0x1
700acfec: 9000         	str	r0, [sp]
700acfee: e7dc         	b	0x700acfaa <vQueueUnregisterQueue+0xa> @ imm = #-0x48
;     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
700acff0: b002         	add	sp, #0x8
700acff2: 4770         	bx	lr
		...

700ad000 <Drivers_open>:
; {
700ad000: b5b0         	push	{r4, r5, r7, lr}
700ad002: b082         	sub	sp, #0x8
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ad004: f642 0124    	movw	r1, #0x2824
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700ad008: f245 24b0    	movw	r4, #0x52b0
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ad00c: f2c7 010b    	movt	r1, #0x700b
700ad010: 2500         	movs	r5, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700ad012: f2c7 0408    	movt	r4, #0x7008
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ad016: 2000         	movs	r0, #0x0
;         gUartHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
700ad018: 6025         	str	r5, [r4]
;         gUartHandle[instCnt] = UART_open(instCnt, &gUartParams[instCnt]);
700ad01a: f7ee fd51    	bl	0x7009bac0 <UART_open>  @ imm = #-0x1155e
700ad01e: 6020         	str	r0, [r4]
;         if(NULL == gUartHandle[instCnt])
700ad020: b108         	cbz	r0, 0x700ad026 <Drivers_open+0x26> @ imm = #0x2
; }
700ad022: b002         	add	sp, #0x8
700ad024: bdb0         	pop	{r4, r5, r7, pc}
;             DebugP_logError("UART open failed for instance %d !!!\r\n", instCnt);
700ad026: f641 2122    	movw	r1, #0x1a22
700ad02a: f242 027f    	movw	r2, #0x207f
700ad02e: f2c7 010b    	movt	r1, #0x700b
700ad032: f2c7 020b    	movt	r2, #0x700b
700ad036: 2002         	movs	r0, #0x2
700ad038: 236e         	movs	r3, #0x6e
700ad03a: 9500         	str	r5, [sp]
700ad03c: f7fc fe68    	bl	0x700a9d10 <_DebugP_logZone> @ imm = #-0x3330
;         if(gUartHandle[instCnt] != NULL)
700ad040: 6820         	ldr	r0, [r4]
700ad042: 2800         	cmp	r0, #0x0
700ad044: d0ed         	beq	0x700ad022 <Drivers_open+0x22> @ imm = #-0x26
;             UART_close(gUartHandle[instCnt]);
700ad046: f7f2 ff9b    	bl	0x7009ff80 <UART_close> @ imm = #-0xd0ca
700ad04a: 2000         	movs	r0, #0x0
;             gUartHandle[instCnt] = NULL;
700ad04c: 6020         	str	r0, [r4]
; }
700ad04e: b002         	add	sp, #0x8
700ad050: bdb0         	pop	{r4, r5, r7, pc}
		...
700ad05e: 0000         	movs	r0, r0

700ad060 <Udma_chInitRegs>:
; {
700ad060: b081         	sub	sp, #0x4
700ad062: 9000         	str	r0, [sp]
;     chHandle->pBcdmaBcCfgRegs    = (volatile CSL_bcdma_bccfgRegs_chan *) NULL_PTR;
700ad064: 9900         	ldr	r1, [sp]
700ad066: 2000         	movs	r0, #0x0
700ad068: f8c1 0214    	str.w	r0, [r1, #0x214]
;     chHandle->pBcdmaBcRtRegs     = (volatile CSL_bcdma_bcrtRegs_chan *) NULL_PTR;
700ad06c: 9900         	ldr	r1, [sp]
700ad06e: f8c1 0218    	str.w	r0, [r1, #0x218]
;     chHandle->pBcdmaTxCfgRegs   = (volatile CSL_bcdma_txccfgRegs_chan *) NULL_PTR;
700ad072: 9900         	ldr	r1, [sp]
700ad074: f8c1 021c    	str.w	r0, [r1, #0x21c]
;     chHandle->pBcdmaTxRtRegs    = (volatile CSL_bcdma_txcrtRegs_chan *) NULL_PTR;
700ad078: 9900         	ldr	r1, [sp]
700ad07a: f8c1 0220    	str.w	r0, [r1, #0x220]
;     chHandle->pBcdmaRxCfgRegs   = (volatile CSL_bcdma_rxccfgRegs_chan *) NULL_PTR;
700ad07e: 9900         	ldr	r1, [sp]
700ad080: f8c1 0224    	str.w	r0, [r1, #0x224]
;     chHandle->pBcdmaRxRtRegs    = (volatile CSL_bcdma_rxcrtRegs_chan *) NULL_PTR;
700ad084: 9900         	ldr	r1, [sp]
700ad086: f8c1 0228    	str.w	r0, [r1, #0x228]
;     chHandle->pPktdmaTxCfgRegs  = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700ad08a: 9900         	ldr	r1, [sp]
700ad08c: f8c1 022c    	str.w	r0, [r1, #0x22c]
;     chHandle->pPktdmaTxRtRegs   = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700ad090: 9900         	ldr	r1, [sp]
700ad092: f8c1 0230    	str.w	r0, [r1, #0x230]
;     chHandle->pPktdmaRxCfgRegs  = (volatile CSL_pktdma_rxccfgRegs_chan *) NULL_PTR;
700ad096: 9900         	ldr	r1, [sp]
700ad098: f8c1 0234    	str.w	r0, [r1, #0x234]
;     chHandle->pPktdmaRxRtRegs   = (volatile CSL_pktdma_rxcrtRegs_chan *) NULL_PTR;
700ad09c: 9900         	ldr	r1, [sp]
700ad09e: f8c1 0238    	str.w	r0, [r1, #0x238]
;     chHandle->pPktdmaExtCfgRegs = (volatile CSL_pktdma_txccfgRegs_chan *) NULL_PTR;
700ad0a2: 9900         	ldr	r1, [sp]
700ad0a4: f8c1 023c    	str.w	r0, [r1, #0x23c]
;     chHandle->pPktdmaExtRtRegs  = (volatile CSL_pktdma_txcrtRegs_chan *) NULL_PTR;
700ad0a8: 9900         	ldr	r1, [sp]
700ad0aa: f8c1 0240    	str.w	r0, [r1, #0x240]
; }
700ad0ae: b001         	add	sp, #0x4
700ad0b0: 4770         	bx	lr
		...
700ad0be: 0000         	movs	r0, r0

700ad0c0 <vQueueAddToRegistry>:
;     {
700ad0c0: b083         	sub	sp, #0xc
700ad0c2: 9002         	str	r0, [sp, #0x8]
700ad0c4: 9101         	str	r1, [sp, #0x4]
700ad0c6: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700ad0c8: 9000         	str	r0, [sp]
700ad0ca: e7ff         	b	0x700ad0cc <vQueueAddToRegistry+0xc> @ imm = #-0x2
700ad0cc: 9800         	ldr	r0, [sp]
700ad0ce: 281f         	cmp	r0, #0x1f
700ad0d0: d81d         	bhi	0x700ad10e <vQueueAddToRegistry+0x4e> @ imm = #0x3a
700ad0d2: e7ff         	b	0x700ad0d4 <vQueueAddToRegistry+0x14> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].pcQueueName == NULL )
700ad0d4: 9900         	ldr	r1, [sp]
700ad0d6: f644 4078    	movw	r0, #0x4c78
700ad0da: f2c7 0008    	movt	r0, #0x7008
700ad0de: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
700ad0e2: b970         	cbnz	r0, 0x700ad102 <vQueueAddToRegistry+0x42> @ imm = #0x1c
700ad0e4: e7ff         	b	0x700ad0e6 <vQueueAddToRegistry+0x26> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = pcQueueName;
700ad0e6: 9801         	ldr	r0, [sp, #0x4]
700ad0e8: 9a00         	ldr	r2, [sp]
700ad0ea: f644 4178    	movw	r1, #0x4c78
700ad0ee: f2c7 0108    	movt	r1, #0x7008
700ad0f2: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = xQueue;
700ad0f6: 9802         	ldr	r0, [sp, #0x8]
700ad0f8: 9a00         	ldr	r2, [sp]
700ad0fa: eb01 01c2    	add.w	r1, r1, r2, lsl #3
700ad0fe: 6048         	str	r0, [r1, #0x4]
;                 break;
700ad100: e005         	b	0x700ad10e <vQueueAddToRegistry+0x4e> @ imm = #0xa
700ad102: e7ff         	b	0x700ad104 <vQueueAddToRegistry+0x44> @ imm = #-0x2
;         }
700ad104: e7ff         	b	0x700ad106 <vQueueAddToRegistry+0x46> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
700ad106: 9800         	ldr	r0, [sp]
700ad108: 3001         	adds	r0, #0x1
700ad10a: 9000         	str	r0, [sp]
700ad10c: e7de         	b	0x700ad0cc <vQueueAddToRegistry+0xc> @ imm = #-0x44
;     }
700ad10e: b003         	add	sp, #0xc
700ad110: 4770         	bx	lr
		...
700ad11e: 0000         	movs	r0, r0

700ad120 <xQueueTakeMutexRecursive>:
;     {
700ad120: b580         	push	{r7, lr}
700ad122: b086         	sub	sp, #0x18
700ad124: 9005         	str	r0, [sp, #0x14]
700ad126: 9104         	str	r1, [sp, #0x10]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700ad128: 9805         	ldr	r0, [sp, #0x14]
700ad12a: 9002         	str	r0, [sp, #0x8]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700ad12c: 9802         	ldr	r0, [sp, #0x8]
700ad12e: 6880         	ldr	r0, [r0, #0x8]
700ad130: 9001         	str	r0, [sp, #0x4]
700ad132: f002 fc3d    	bl	0x700af9b0 <xTaskGetCurrentTaskHandle> @ imm = #0x287a
700ad136: 4601         	mov	r1, r0
700ad138: 9801         	ldr	r0, [sp, #0x4]
700ad13a: 4288         	cmp	r0, r1
700ad13c: d107         	bne	0x700ad14e <xQueueTakeMutexRecursive+0x2e> @ imm = #0xe
700ad13e: e7ff         	b	0x700ad140 <xQueueTakeMutexRecursive+0x20> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700ad140: 9902         	ldr	r1, [sp, #0x8]
700ad142: 68c8         	ldr	r0, [r1, #0xc]
700ad144: 3001         	adds	r0, #0x1
700ad146: 60c8         	str	r0, [r1, #0xc]
700ad148: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700ad14a: 9003         	str	r0, [sp, #0xc]
;         }
700ad14c: e00e         	b	0x700ad16c <xQueueTakeMutexRecursive+0x4c> @ imm = #0x1c
;             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
700ad14e: 9802         	ldr	r0, [sp, #0x8]
700ad150: 9904         	ldr	r1, [sp, #0x10]
700ad152: f7f4 f98d    	bl	0x700a1470 <xQueueSemaphoreTake> @ imm = #-0xbce6
700ad156: 9003         	str	r0, [sp, #0xc]
;             if( xReturn != pdFAIL )
700ad158: 9803         	ldr	r0, [sp, #0xc]
700ad15a: b128         	cbz	r0, 0x700ad168 <xQueueTakeMutexRecursive+0x48> @ imm = #0xa
700ad15c: e7ff         	b	0x700ad15e <xQueueTakeMutexRecursive+0x3e> @ imm = #-0x2
;                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
700ad15e: 9902         	ldr	r1, [sp, #0x8]
700ad160: 68c8         	ldr	r0, [r1, #0xc]
700ad162: 3001         	adds	r0, #0x1
700ad164: 60c8         	str	r0, [r1, #0xc]
;             }
700ad166: e000         	b	0x700ad16a <xQueueTakeMutexRecursive+0x4a> @ imm = #0x0
700ad168: e7ff         	b	0x700ad16a <xQueueTakeMutexRecursive+0x4a> @ imm = #-0x2
700ad16a: e7ff         	b	0x700ad16c <xQueueTakeMutexRecursive+0x4c> @ imm = #-0x2
;         return xReturn;
700ad16c: 9803         	ldr	r0, [sp, #0xc]
700ad16e: b006         	add	sp, #0x18
700ad170: bd80         	pop	{r7, pc}
		...
700ad17e: 0000         	movs	r0, r0

700ad180 <UART_checkCharsAvailInFifo>:
; {
700ad180: b580         	push	{r7, lr}
700ad182: b084         	sub	sp, #0x10
700ad184: 9003         	str	r0, [sp, #0xc]
700ad186: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ad188: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700ad18a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad18c: 9803         	ldr	r0, [sp, #0xc]
700ad18e: 300c         	adds	r0, #0xc
700ad190: f002 fcee    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x29dc
700ad194: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ad196: 9803         	ldr	r0, [sp, #0xc]
700ad198: 300c         	adds	r0, #0xc
700ad19a: 9000         	str	r0, [sp]
700ad19c: f002 fce8    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x29d0
700ad1a0: 4601         	mov	r1, r0
700ad1a2: 9800         	ldr	r0, [sp]
700ad1a4: f001 017f    	and	r1, r1, #0x7f
700ad1a8: f002 fcea    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x29d4
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ad1ac: 9803         	ldr	r0, [sp, #0xc]
700ad1ae: 3014         	adds	r0, #0x14
700ad1b0: f002 fcde    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x29bc
;     if ((uint32_t) UART_LSR_RX_FIFO_E_RX_FIFO_E_VALUE_0 !=
700ad1b4: 07c0         	lsls	r0, r0, #0x1f
700ad1b6: b118         	cbz	r0, 0x700ad1c0 <UART_checkCharsAvailInFifo+0x40> @ imm = #0x6
700ad1b8: e7ff         	b	0x700ad1ba <UART_checkCharsAvailInFifo+0x3a> @ imm = #-0x2
700ad1ba: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700ad1bc: 9001         	str	r0, [sp, #0x4]
;     }
700ad1be: e7ff         	b	0x700ad1c0 <UART_checkCharsAvailInFifo+0x40> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad1c0: 9803         	ldr	r0, [sp, #0xc]
700ad1c2: 300c         	adds	r0, #0xc
700ad1c4: 9902         	ldr	r1, [sp, #0x8]
700ad1c6: f002 fcdb    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x29b6
;     return retVal;
700ad1ca: 9801         	ldr	r0, [sp, #0x4]
700ad1cc: b004         	add	sp, #0x10
700ad1ce: bd80         	pop	{r7, pc}

700ad1d0 <xQueueGiveMutexRecursive>:
;     {
700ad1d0: b580         	push	{r7, lr}
700ad1d2: b084         	sub	sp, #0x10
700ad1d4: 9003         	str	r0, [sp, #0xc]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
700ad1d6: 9803         	ldr	r0, [sp, #0xc]
700ad1d8: 9001         	str	r0, [sp, #0x4]
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
700ad1da: 9801         	ldr	r0, [sp, #0x4]
700ad1dc: 6880         	ldr	r0, [r0, #0x8]
700ad1de: 9000         	str	r0, [sp]
700ad1e0: f002 fbe6    	bl	0x700af9b0 <xTaskGetCurrentTaskHandle> @ imm = #0x27cc
700ad1e4: 4601         	mov	r1, r0
700ad1e6: 9800         	ldr	r0, [sp]
700ad1e8: 4288         	cmp	r0, r1
700ad1ea: d113         	bne	0x700ad214 <xQueueGiveMutexRecursive+0x44> @ imm = #0x26
700ad1ec: e7ff         	b	0x700ad1ee <xQueueGiveMutexRecursive+0x1e> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
700ad1ee: 9901         	ldr	r1, [sp, #0x4]
700ad1f0: 68c8         	ldr	r0, [r1, #0xc]
700ad1f2: 3801         	subs	r0, #0x1
700ad1f4: 60c8         	str	r0, [r1, #0xc]
;             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
700ad1f6: 9801         	ldr	r0, [sp, #0x4]
700ad1f8: 68c0         	ldr	r0, [r0, #0xc]
700ad1fa: b938         	cbnz	r0, 0x700ad20c <xQueueGiveMutexRecursive+0x3c> @ imm = #0xe
700ad1fc: e7ff         	b	0x700ad1fe <xQueueGiveMutexRecursive+0x2e> @ imm = #-0x2
;                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
700ad1fe: 9801         	ldr	r0, [sp, #0x4]
700ad200: 2300         	movs	r3, #0x0
700ad202: 4619         	mov	r1, r3
700ad204: 461a         	mov	r2, r3
700ad206: f7f6 f873    	bl	0x700a32f0 <xQueueGenericSend> @ imm = #-0x9f1a
;             }
700ad20a: e000         	b	0x700ad20e <xQueueGiveMutexRecursive+0x3e> @ imm = #0x0
700ad20c: e7ff         	b	0x700ad20e <xQueueGiveMutexRecursive+0x3e> @ imm = #-0x2
700ad20e: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
700ad210: 9002         	str	r0, [sp, #0x8]
;         }
700ad212: e002         	b	0x700ad21a <xQueueGiveMutexRecursive+0x4a> @ imm = #0x4
700ad214: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
700ad216: 9002         	str	r0, [sp, #0x8]
700ad218: e7ff         	b	0x700ad21a <xQueueGiveMutexRecursive+0x4a> @ imm = #-0x2
;         return xReturn;
700ad21a: 9802         	ldr	r0, [sp, #0x8]
700ad21c: b004         	add	sp, #0x10
700ad21e: bd80         	pop	{r7, pc}

700ad220 <CSL_pktdmaIsChanEnabled>:
; {
700ad220: b580         	push	{r7, lr}
700ad222: b084         	sub	sp, #0x10
700ad224: 9003         	str	r0, [sp, #0xc]
700ad226: 9102         	str	r1, [sp, #0x8]
700ad228: 9201         	str	r2, [sp, #0x4]
;     if( chanDir == CSL_PKTDMA_CHAN_DIR_TX )
700ad22a: 9801         	ldr	r0, [sp, #0x4]
700ad22c: b960         	cbnz	r0, 0x700ad248 <CSL_pktdmaIsChanEnabled+0x28> @ imm = #0x18
700ad22e: e7ff         	b	0x700ad230 <CSL_pktdmaIsChanEnabled+0x10> @ imm = #-0x2
;         regVal = CSL_REG32_FEXT( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_TXCRT_CHAN_CTL_EN );
700ad230: 9803         	ldr	r0, [sp, #0xc]
700ad232: 6900         	ldr	r0, [r0, #0x10]
700ad234: 9902         	ldr	r1, [sp, #0x8]
700ad236: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad23a: f04f 4100    	mov.w	r1, #0x80000000
700ad23e: 221f         	movs	r2, #0x1f
700ad240: f001 ff56    	bl	0x700af0f0 <CSL_REG32_FEXT_RAW> @ imm = #0x1eac
700ad244: 9000         	str	r0, [sp]
;     }
700ad246: e00b         	b	0x700ad260 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #0x16
;         regVal = CSL_REG32_FEXT( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL, PKTDMA_RXCRT_CHAN_CTL_EN );
700ad248: 9803         	ldr	r0, [sp, #0xc]
700ad24a: 6940         	ldr	r0, [r0, #0x14]
700ad24c: 9902         	ldr	r1, [sp, #0x8]
700ad24e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad252: f04f 4100    	mov.w	r1, #0x80000000
700ad256: 221f         	movs	r2, #0x1f
700ad258: f001 ff4a    	bl	0x700af0f0 <CSL_REG32_FEXT_RAW> @ imm = #0x1e94
700ad25c: 9000         	str	r0, [sp]
700ad25e: e7ff         	b	0x700ad260 <CSL_pktdmaIsChanEnabled+0x40> @ imm = #-0x2
;     return ((regVal == 1U) ? (bool)true : (bool)false);
700ad260: 9800         	ldr	r0, [sp]
700ad262: 3801         	subs	r0, #0x1
700ad264: fab0 f080    	clz	r0, r0
700ad268: 0940         	lsrs	r0, r0, #0x5
700ad26a: b004         	add	sp, #0x10
700ad26c: bd80         	pop	{r7, pc}
700ad26e: 0000         	movs	r0, r0

700ad270 <UART_getHandle>:
; {
700ad270: b083         	sub	sp, #0xc
700ad272: 9002         	str	r0, [sp, #0x8]
700ad274: 2000         	movs	r0, #0x0
;     UART_Handle         handle = NULL;
700ad276: 9001         	str	r0, [sp, #0x4]
;     if(index < gUartConfigNum)
700ad278: 9802         	ldr	r0, [sp, #0x8]
700ad27a: f642 11ec    	movw	r1, #0x29ec
700ad27e: f2c7 010b    	movt	r1, #0x700b
700ad282: 6809         	ldr	r1, [r1]
700ad284: 4288         	cmp	r0, r1
700ad286: d217         	bhs	0x700ad2b8 <UART_getHandle+0x48> @ imm = #0x2e
700ad288: e7ff         	b	0x700ad28a <UART_getHandle+0x1a> @ imm = #-0x2
;         object = gUartConfig[index].object;
700ad28a: 9902         	ldr	r1, [sp, #0x8]
700ad28c: f642 10a4    	movw	r0, #0x29a4
700ad290: f2c7 000b    	movt	r0, #0x700b
700ad294: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700ad298: 6840         	ldr	r0, [r0, #0x4]
700ad29a: 9000         	str	r0, [sp]
;         if(object && (TRUE == object->isOpen))
700ad29c: 9800         	ldr	r0, [sp]
700ad29e: b150         	cbz	r0, 0x700ad2b6 <UART_getHandle+0x46> @ imm = #0x14
700ad2a0: e7ff         	b	0x700ad2a2 <UART_getHandle+0x32> @ imm = #-0x2
700ad2a2: 9800         	ldr	r0, [sp]
700ad2a4: f8d0 0084    	ldr.w	r0, [r0, #0x84]
700ad2a8: 2801         	cmp	r0, #0x1
700ad2aa: d104         	bne	0x700ad2b6 <UART_getHandle+0x46> @ imm = #0x8
700ad2ac: e7ff         	b	0x700ad2ae <UART_getHandle+0x3e> @ imm = #-0x2
;             handle = object->handle;
700ad2ae: 9800         	ldr	r0, [sp]
700ad2b0: 6800         	ldr	r0, [r0]
700ad2b2: 9001         	str	r0, [sp, #0x4]
;         }
700ad2b4: e7ff         	b	0x700ad2b6 <UART_getHandle+0x46> @ imm = #-0x2
;     }
700ad2b6: e7ff         	b	0x700ad2b8 <UART_getHandle+0x48> @ imm = #-0x2
;     return handle;
700ad2b8: 9801         	ldr	r0, [sp, #0x4]
700ad2ba: b003         	add	sp, #0xc
700ad2bc: 4770         	bx	lr
700ad2be: 0000         	movs	r0, r0

700ad2c0 <prvTaskIsTaskSuspended>:
; static BaseType_t prvTaskIsTaskSuspended(const TaskHandle_t xTask) {
700ad2c0: b083         	sub	sp, #0xc
700ad2c2: 9002         	str	r0, [sp, #0x8]
700ad2c4: 2000         	movs	r0, #0x0
;   BaseType_t xReturn = pdFALSE;
700ad2c6: 9001         	str	r0, [sp, #0x4]
;   const TCB_t *const pxTCB = xTask;
700ad2c8: 9802         	ldr	r0, [sp, #0x8]
700ad2ca: 9000         	str	r0, [sp]
;   if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) !=
700ad2cc: 9800         	ldr	r0, [sp]
700ad2ce: 6940         	ldr	r0, [r0, #0x14]
700ad2d0: f245 2174    	movw	r1, #0x5274
700ad2d4: f2c7 0108    	movt	r1, #0x7008
700ad2d8: 4288         	cmp	r0, r1
700ad2da: d114         	bne	0x700ad306 <prvTaskIsTaskSuspended+0x46> @ imm = #0x28
700ad2dc: e7ff         	b	0x700ad2de <prvTaskIsTaskSuspended+0x1e> @ imm = #-0x2
;     if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) ==
700ad2de: 9800         	ldr	r0, [sp]
700ad2e0: 6a80         	ldr	r0, [r0, #0x28]
700ad2e2: f245 2160    	movw	r1, #0x5260
700ad2e6: f2c7 0108    	movt	r1, #0x7008
700ad2ea: 4288         	cmp	r0, r1
700ad2ec: d009         	beq	0x700ad302 <prvTaskIsTaskSuspended+0x42> @ imm = #0x12
700ad2ee: e7ff         	b	0x700ad2f0 <prvTaskIsTaskSuspended+0x30> @ imm = #-0x2
;       if (listIS_CONTAINED_WITHIN(NULL, &(pxTCB->xEventListItem)) !=
700ad2f0: 9800         	ldr	r0, [sp]
700ad2f2: 6a80         	ldr	r0, [r0, #0x28]
700ad2f4: b918         	cbnz	r0, 0x700ad2fe <prvTaskIsTaskSuspended+0x3e> @ imm = #0x6
700ad2f6: e7ff         	b	0x700ad2f8 <prvTaskIsTaskSuspended+0x38> @ imm = #-0x2
700ad2f8: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
700ad2fa: 9001         	str	r0, [sp, #0x4]
;       } else {
700ad2fc: e000         	b	0x700ad300 <prvTaskIsTaskSuspended+0x40> @ imm = #0x0
700ad2fe: e7ff         	b	0x700ad300 <prvTaskIsTaskSuspended+0x40> @ imm = #-0x2
;     } else {
700ad300: e000         	b	0x700ad304 <prvTaskIsTaskSuspended+0x44> @ imm = #0x0
700ad302: e7ff         	b	0x700ad304 <prvTaskIsTaskSuspended+0x44> @ imm = #-0x2
;   } else {
700ad304: e000         	b	0x700ad308 <prvTaskIsTaskSuspended+0x48> @ imm = #0x0
700ad306: e7ff         	b	0x700ad308 <prvTaskIsTaskSuspended+0x48> @ imm = #-0x2
;   return xReturn;
700ad308: 9801         	ldr	r0, [sp, #0x4]
700ad30a: b003         	add	sp, #0xc
700ad30c: 4770         	bx	lr
700ad30e: 0000         	movs	r0, r0

700ad310 <Sciclient_rmPsSetInp>:
; {
700ad310: b082         	sub	sp, #0x8
700ad312: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad316: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ad31a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ad31c: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ad31e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad322: f241 0158    	movw	r1, #0x1058
700ad326: f2c7 0108    	movt	r1, #0x7008
700ad32a: 8c89         	ldrh	r1, [r1, #0x24]
700ad32c: 4288         	cmp	r0, r1
700ad32e: da0e         	bge	0x700ad34e <Sciclient_rmPsSetInp+0x3e> @ imm = #0x1c
700ad330: e7ff         	b	0x700ad332 <Sciclient_rmPsSetInp+0x22> @ imm = #-0x2
;         gPstack.ps[index].inp = inp;
700ad332: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ad336: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ad33a: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ad33e: f241 0158    	movw	r1, #0x1058
700ad342: f2c7 0108    	movt	r1, #0x7008
700ad346: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ad34a: 80c8         	strh	r0, [r1, #0x6]
;     } else {
700ad34c: e003         	b	0x700ad356 <Sciclient_rmPsSetInp+0x46> @ imm = #0x6
700ad34e: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ad352: 9000         	str	r0, [sp]
700ad354: e7ff         	b	0x700ad356 <Sciclient_rmPsSetInp+0x46> @ imm = #-0x2
;     return r;
700ad356: 9800         	ldr	r0, [sp]
700ad358: b002         	add	sp, #0x8
700ad35a: 4770         	bx	lr
700ad35c: 0000         	movs	r0, r0
700ad35e: 0000         	movs	r0, r0

700ad360 <Sciclient_rmPsSetOutp>:
; {
700ad360: b082         	sub	sp, #0x8
700ad362: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ad366: f8ad 1004    	strh.w	r1, [sp, #0x4]
700ad36a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ad36c: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700ad36e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ad372: f241 0158    	movw	r1, #0x1058
700ad376: f2c7 0108    	movt	r1, #0x7008
700ad37a: 8c89         	ldrh	r1, [r1, #0x24]
700ad37c: 4288         	cmp	r0, r1
700ad37e: da0e         	bge	0x700ad39e <Sciclient_rmPsSetOutp+0x3e> @ imm = #0x1c
700ad380: e7ff         	b	0x700ad382 <Sciclient_rmPsSetOutp+0x22> @ imm = #-0x2
;         gPstack.ps[index].outp = outp;
700ad382: f8bd 0004    	ldrh.w	r0, [sp, #0x4]
700ad386: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ad38a: eb01 0241    	add.w	r2, r1, r1, lsl #1
700ad38e: f241 0158    	movw	r1, #0x1058
700ad392: f2c7 0108    	movt	r1, #0x7008
700ad396: eb01 0182    	add.w	r1, r1, r2, lsl #2
700ad39a: 8108         	strh	r0, [r1, #0x8]
;     } else {
700ad39c: e003         	b	0x700ad3a6 <Sciclient_rmPsSetOutp+0x46> @ imm = #0x6
700ad39e: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700ad3a2: 9000         	str	r0, [sp]
700ad3a4: e7ff         	b	0x700ad3a6 <Sciclient_rmPsSetOutp+0x46> @ imm = #-0x2
;     return r;
700ad3a6: 9800         	ldr	r0, [sp]
700ad3a8: b002         	add	sp, #0x8
700ad3aa: 4770         	bx	lr
700ad3ac: 0000         	movs	r0, r0
700ad3ae: 0000         	movs	r0, r0

700ad3b0 <Udma_eventGetId>:
; {
700ad3b0: b084         	sub	sp, #0x10
700ad3b2: 9003         	str	r0, [sp, #0xc]
700ad3b4: f64f 70ff    	movw	r0, #0xffff
;     uint32_t            evtNum = UDMA_EVENT_INVALID;
700ad3b8: 9002         	str	r0, [sp, #0x8]
;     Udma_EventHandleInt eventHandleInt = (Udma_EventHandleInt) eventHandle;
700ad3ba: 9803         	ldr	r0, [sp, #0xc]
700ad3bc: 9000         	str	r0, [sp]
;     if((NULL_PTR != eventHandleInt) &&
700ad3be: 9800         	ldr	r0, [sp]
700ad3c0: b1c8         	cbz	r0, 0x700ad3f6 <Udma_eventGetId+0x46> @ imm = #0x32
700ad3c2: e7ff         	b	0x700ad3c4 <Udma_eventGetId+0x14> @ imm = #-0x2
;        (UDMA_INIT_DONE == eventHandleInt->eventInitDone))
700ad3c4: 9800         	ldr	r0, [sp]
700ad3c6: f8d0 0098    	ldr.w	r0, [r0, #0x98]
700ad3ca: f64a 31cd    	movw	r1, #0xabcd
700ad3ce: f6ca 31dc    	movt	r1, #0xabdc
;     if((NULL_PTR != eventHandleInt) &&
700ad3d2: 4288         	cmp	r0, r1
700ad3d4: d10f         	bne	0x700ad3f6 <Udma_eventGetId+0x46> @ imm = #0x1e
700ad3d6: e7ff         	b	0x700ad3d8 <Udma_eventGetId+0x28> @ imm = #-0x2
;         drvHandle = eventHandleInt->drvHandle;
700ad3d8: 9800         	ldr	r0, [sp]
700ad3da: 6800         	ldr	r0, [r0]
700ad3dc: 9001         	str	r0, [sp, #0x4]
;         if(NULL_PTR != drvHandle)
700ad3de: 9801         	ldr	r0, [sp, #0x4]
700ad3e0: b140         	cbz	r0, 0x700ad3f4 <Udma_eventGetId+0x44> @ imm = #0x10
700ad3e2: e7ff         	b	0x700ad3e4 <Udma_eventGetId+0x34> @ imm = #-0x2
;             evtNum = drvHandle->iaGemOffset + eventHandleInt->globalEvent;
700ad3e4: 9801         	ldr	r0, [sp, #0x4]
700ad3e6: f8d0 0118    	ldr.w	r0, [r0, #0x118]
700ad3ea: 9900         	ldr	r1, [sp]
700ad3ec: 6c89         	ldr	r1, [r1, #0x48]
700ad3ee: 4408         	add	r0, r1
700ad3f0: 9002         	str	r0, [sp, #0x8]
;         }
700ad3f2: e7ff         	b	0x700ad3f4 <Udma_eventGetId+0x44> @ imm = #-0x2
;     }
700ad3f4: e7ff         	b	0x700ad3f6 <Udma_eventGetId+0x46> @ imm = #-0x2
;     return (evtNum);
700ad3f6: 9802         	ldr	r0, [sp, #0x8]
700ad3f8: b004         	add	sp, #0x10
700ad3fa: 4770         	bx	lr
700ad3fc: 0000         	movs	r0, r0
700ad3fe: 0000         	movs	r0, r0

700ad400 <CSL_pktdmaGetRxRT>:
; {
700ad400: b580         	push	{r7, lr}
700ad402: b084         	sub	sp, #0x10
700ad404: 9003         	str	r0, [sp, #0xc]
700ad406: 9102         	str	r1, [sp, #0x8]
700ad408: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL );
700ad40a: 9803         	ldr	r0, [sp, #0xc]
700ad40c: 6940         	ldr	r0, [r0, #0x14]
700ad40e: 9902         	ldr	r1, [sp, #0x8]
700ad410: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad414: f002 fc04    	bl	0x700afc20 <CSL_REG32_RD_RAW> @ imm = #0x2808
700ad418: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_EN );
700ad41a: 9800         	ldr	r0, [sp]
700ad41c: 0fc0         	lsrs	r0, r0, #0x1f
700ad41e: 9901         	ldr	r1, [sp, #0x4]
700ad420: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_TDOWN );
700ad422: 9800         	ldr	r0, [sp]
700ad424: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ad428: 9901         	ldr	r1, [sp, #0x4]
700ad42a: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ad42c: 9901         	ldr	r1, [sp, #0x4]
700ad42e: 2000         	movs	r0, #0x0
700ad430: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_PAUSE );
700ad432: 9900         	ldr	r1, [sp]
700ad434: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ad438: 9a01         	ldr	r2, [sp, #0x4]
700ad43a: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_RXCRT_CHAN_CTL_ERROR );
700ad43c: 9900         	ldr	r1, [sp]
700ad43e: f001 0101    	and	r1, r1, #0x1
700ad442: 9a01         	ldr	r2, [sp, #0x4]
700ad444: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ad446: b004         	add	sp, #0x10
700ad448: bd80         	pop	{r7, pc}
700ad44a: 0000         	movs	r0, r0
700ad44c: 0000         	movs	r0, r0
700ad44e: 0000         	movs	r0, r0

700ad450 <CSL_pktdmaGetTxRT>:
; {
700ad450: b580         	push	{r7, lr}
700ad452: b084         	sub	sp, #0x10
700ad454: 9003         	str	r0, [sp, #0xc]
700ad456: 9102         	str	r1, [sp, #0x8]
700ad458: 9201         	str	r2, [sp, #0x4]
;     val = CSL_REG32_RD( &pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL );
700ad45a: 9803         	ldr	r0, [sp, #0xc]
700ad45c: 6900         	ldr	r0, [r0, #0x10]
700ad45e: 9902         	ldr	r1, [sp, #0x8]
700ad460: eb00 3001    	add.w	r0, r0, r1, lsl #12
700ad464: f002 fbdc    	bl	0x700afc20 <CSL_REG32_RD_RAW> @ imm = #0x27b8
700ad468: 9000         	str	r0, [sp]
;     pRT->enable         = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_EN );
700ad46a: 9800         	ldr	r0, [sp]
700ad46c: 0fc0         	lsrs	r0, r0, #0x1f
700ad46e: 9901         	ldr	r1, [sp, #0x4]
700ad470: 6008         	str	r0, [r1]
;     pRT->teardown       = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_TDOWN );
700ad472: 9800         	ldr	r0, [sp]
700ad474: f3c0 7080    	ubfx	r0, r0, #0x1e, #0x1
700ad478: 9901         	ldr	r1, [sp, #0x4]
700ad47a: 6048         	str	r0, [r1, #0x4]
;     pRT->forcedTeardown = (uint32_t)0U;
700ad47c: 9901         	ldr	r1, [sp, #0x4]
700ad47e: 2000         	movs	r0, #0x0
700ad480: 6108         	str	r0, [r1, #0x10]
;     pRT->pause          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_PAUSE );
700ad482: 9900         	ldr	r1, [sp]
700ad484: f3c1 7140    	ubfx	r1, r1, #0x1d, #0x1
700ad488: 9a01         	ldr	r2, [sp, #0x4]
700ad48a: 6091         	str	r1, [r2, #0x8]
;     pRT->error          = CSL_FEXT( val, PKTDMA_TXCRT_CHAN_CTL_ERROR );
700ad48c: 9900         	ldr	r1, [sp]
700ad48e: f001 0101    	and	r1, r1, #0x1
700ad492: 9a01         	ldr	r2, [sp, #0x4]
700ad494: 60d1         	str	r1, [r2, #0xc]
;     return CSL_PASS;
700ad496: b004         	add	sp, #0x10
700ad498: bd80         	pop	{r7, pc}
700ad49a: 0000         	movs	r0, r0
700ad49c: 0000         	movs	r0, r0
700ad49e: 0000         	movs	r0, r0

700ad4a0 <Sciclient_getDevId>:
; {
700ad4a0: b083         	sub	sp, #0xc
700ad4a2: 9002         	str	r0, [sp, #0x8]
700ad4a4: f04f 30ff    	mov.w	r0, #0xffffffff
;     uint32_t retVal = UINT32_MAX;
700ad4a8: 9001         	str	r0, [sp, #0x4]
;     switch (coreId)
700ad4aa: 9802         	ldr	r0, [sp, #0x8]
700ad4ac: 9000         	str	r0, [sp]
700ad4ae: 2805         	cmp	r0, #0x5
700ad4b0: d817         	bhi	0x700ad4e2 <Sciclient_getDevId+0x42> @ imm = #0x2e
700ad4b2: 9900         	ldr	r1, [sp]
700ad4b4: e8df f001    	tbb	[pc, r1]
700ad4b8: 03 06 09 0c  	.word	0x0c090603
700ad4bc: 0f 12        	.short	0x120f
700ad4be: 2009         	movs	r0, #0x9
;         retVal = TISCI_DEV_MCU_M4FSS0_CORE0;
700ad4c0: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4c2: e00f         	b	0x700ad4e4 <Sciclient_getDevId+0x44> @ imm = #0x1e
700ad4c4: 2079         	movs	r0, #0x79
;         retVal = TISCI_DEV_R5FSS0_CORE0;
700ad4c6: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4c8: e00c         	b	0x700ad4e4 <Sciclient_getDevId+0x44> @ imm = #0x18
700ad4ca: 207a         	movs	r0, #0x7a
;         retVal = TISCI_DEV_R5FSS0_CORE1;
700ad4cc: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4ce: e009         	b	0x700ad4e4 <Sciclient_getDevId+0x44> @ imm = #0x12
700ad4d0: 207b         	movs	r0, #0x7b
;         retVal = TISCI_DEV_R5FSS1_CORE0;
700ad4d2: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4d4: e006         	b	0x700ad4e4 <Sciclient_getDevId+0x44> @ imm = #0xc
700ad4d6: 207c         	movs	r0, #0x7c
;         retVal = TISCI_DEV_R5FSS1_CORE1;
700ad4d8: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4da: e003         	b	0x700ad4e4 <Sciclient_getDevId+0x44> @ imm = #0x6
700ad4dc: 2087         	movs	r0, #0x87
;         retVal = TISCI_DEV_A53SS0_CORE_0;
700ad4de: 9001         	str	r0, [sp, #0x4]
;         break;
700ad4e0: e000         	b	0x700ad4e4 <Sciclient_getDevId+0x44> @ imm = #0x0
;         break;
700ad4e2: e7ff         	b	0x700ad4e4 <Sciclient_getDevId+0x44> @ imm = #-0x2
;     return retVal;
700ad4e4: 9801         	ldr	r0, [sp, #0x4]
700ad4e6: b003         	add	sp, #0xc
700ad4e8: 4770         	bx	lr
700ad4ea: 0000         	movs	r0, r0
700ad4ec: 0000         	movs	r0, r0
700ad4ee: 0000         	movs	r0, r0

700ad4f0 <UART_getIntrIdentityStatus>:
; {
700ad4f0: b580         	push	{r7, lr}
700ad4f2: b084         	sub	sp, #0x10
700ad4f4: 9003         	str	r0, [sp, #0xc]
700ad4f6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ad4f8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ad4fa: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad4fc: 9803         	ldr	r0, [sp, #0xc]
700ad4fe: 300c         	adds	r0, #0xc
700ad500: f002 fb36    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x266c
700ad504: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ad506: 9803         	ldr	r0, [sp, #0xc]
700ad508: 300c         	adds	r0, #0xc
700ad50a: 9000         	str	r0, [sp]
700ad50c: f002 fb30    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x2660
700ad510: 4601         	mov	r1, r0
700ad512: 9800         	ldr	r0, [sp]
700ad514: f001 017f    	and	r1, r1, #0x7f
700ad518: f002 fb32    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x2664
;     retVal = HW_RD_REG32(baseAddr + UART_IIR) & UART_IIR_IT_TYPE_MASK;
700ad51c: 9803         	ldr	r0, [sp, #0xc]
700ad51e: 3008         	adds	r0, #0x8
700ad520: f002 fb26    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x264c
700ad524: f000 003e    	and	r0, r0, #0x3e
700ad528: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad52a: 9803         	ldr	r0, [sp, #0xc]
700ad52c: 300c         	adds	r0, #0xc
700ad52e: 9902         	ldr	r1, [sp, #0x8]
700ad530: f002 fb26    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x264c
;     return retVal;
700ad534: 9801         	ldr	r0, [sp, #0x4]
700ad536: b004         	add	sp, #0x10
700ad538: bd80         	pop	{r7, pc}
700ad53a: 0000         	movs	r0, r0
700ad53c: 0000         	movs	r0, r0
700ad53e: 0000         	movs	r0, r0

700ad540 <UART_lineCharConfig>:
; {
700ad540: b580         	push	{r7, lr}
700ad542: b084         	sub	sp, #0x10
700ad544: 9003         	str	r0, [sp, #0xc]
700ad546: 9102         	str	r1, [sp, #0x8]
700ad548: 9201         	str	r2, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad54a: 9803         	ldr	r0, [sp, #0xc]
700ad54c: 300c         	adds	r0, #0xc
700ad54e: f002 fb0f    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x261e
700ad552: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_NB_STOP_MASK | (uint32_t) UART_LCR_CHAR_LENGTH_MASK);
700ad554: 9800         	ldr	r0, [sp]
700ad556: f020 0007    	bic	r0, r0, #0x7
700ad55a: 9000         	str	r0, [sp]
;     lcrRegValue |= wLenStbFlag & (UART_LCR_NB_STOP_MASK |
700ad55c: 9802         	ldr	r0, [sp, #0x8]
700ad55e: f000 0107    	and	r1, r0, #0x7
700ad562: 9800         	ldr	r0, [sp]
700ad564: 4308         	orrs	r0, r1
700ad566: 9000         	str	r0, [sp]
;     lcrRegValue &= ~((uint32_t) UART_LCR_PARITY_TYPE2_MASK |
700ad568: 9800         	ldr	r0, [sp]
700ad56a: f020 0038    	bic	r0, r0, #0x38
700ad56e: 9000         	str	r0, [sp]
;     lcrRegValue |= parityFlag & (UART_LCR_PARITY_TYPE2_MASK |
700ad570: 9801         	ldr	r0, [sp, #0x4]
700ad572: f000 0138    	and	r1, r0, #0x38
700ad576: 9800         	ldr	r0, [sp]
700ad578: 4308         	orrs	r0, r1
700ad57a: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad57c: 9803         	ldr	r0, [sp, #0xc]
700ad57e: 300c         	adds	r0, #0xc
700ad580: 9900         	ldr	r1, [sp]
700ad582: f002 fafd    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x25fa
; }
700ad586: b004         	add	sp, #0x10
700ad588: bd80         	pop	{r7, pc}
700ad58a: 0000         	movs	r0, r0
700ad58c: 0000         	movs	r0, r0
700ad58e: 0000         	movs	r0, r0

700ad590 <UART_lld_dmaInit>:
; {
700ad590: b580         	push	{r7, lr}
700ad592: b084         	sub	sp, #0x10
700ad594: 9003         	str	r0, [sp, #0xc]
700ad596: 9102         	str	r1, [sp, #0x8]
700ad598: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ad59a: 9001         	str	r0, [sp, #0x4]
;     UART_UdmaChConfig *udmaChCfg = (UART_UdmaChConfig *)dmaChCfg;
700ad59c: 9802         	ldr	r0, [sp, #0x8]
700ad59e: 9000         	str	r0, [sp]
;     status  = UART_udmaInitRxCh(hUart, udmaChCfg);
700ad5a0: 9803         	ldr	r0, [sp, #0xc]
700ad5a2: 9900         	ldr	r1, [sp]
700ad5a4: f7f6 fef4    	bl	0x700a4390 <UART_udmaInitRxCh> @ imm = #-0x9218
700ad5a8: 9001         	str	r0, [sp, #0x4]
;     status += UART_udmaInitTxCh(hUart, udmaChCfg);
700ad5aa: 9803         	ldr	r0, [sp, #0xc]
700ad5ac: 9900         	ldr	r1, [sp]
700ad5ae: f7f6 ff7f    	bl	0x700a44b0 <UART_udmaInitTxCh> @ imm = #-0x9102
700ad5b2: 4601         	mov	r1, r0
700ad5b4: 9801         	ldr	r0, [sp, #0x4]
700ad5b6: 4408         	add	r0, r1
700ad5b8: 9001         	str	r0, [sp, #0x4]
;     if (status == UDMA_SOK)
700ad5ba: 9801         	ldr	r0, [sp, #0x4]
700ad5bc: b930         	cbnz	r0, 0x700ad5cc <UART_lld_dmaInit+0x3c> @ imm = #0xc
700ad5be: e7ff         	b	0x700ad5c0 <UART_lld_dmaInit+0x30> @ imm = #-0x2
;         udmaChCfg->isOpen = TRUE;
700ad5c0: 9900         	ldr	r1, [sp]
700ad5c2: 2001         	movs	r0, #0x1
700ad5c4: 6388         	str	r0, [r1, #0x38]
700ad5c6: 2000         	movs	r0, #0x0
;         status = UART_TRANSFER_STATUS_SUCCESS;
700ad5c8: 9001         	str	r0, [sp, #0x4]
;     }
700ad5ca: e003         	b	0x700ad5d4 <UART_lld_dmaInit+0x44> @ imm = #0x6
700ad5cc: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ad5d0: 9001         	str	r0, [sp, #0x4]
700ad5d2: e7ff         	b	0x700ad5d4 <UART_lld_dmaInit+0x44> @ imm = #-0x2
;     return status;
700ad5d4: 9801         	ldr	r0, [sp, #0x4]
700ad5d6: b004         	add	sp, #0x10
700ad5d8: bd80         	pop	{r7, pc}
700ad5da: 0000         	movs	r0, r0
700ad5dc: 0000         	movs	r0, r0
700ad5de: 0000         	movs	r0, r0

700ad5e0 <xQueueGenericCreateStatic>:
;     {
700ad5e0: b580         	push	{r7, lr}
700ad5e2: b088         	sub	sp, #0x20
700ad5e4: 4684         	mov	r12, r0
700ad5e6: 980a         	ldr	r0, [sp, #0x28]
700ad5e8: f8cd c01c    	str.w	r12, [sp, #0x1c]
700ad5ec: 9106         	str	r1, [sp, #0x18]
700ad5ee: 9205         	str	r2, [sp, #0x14]
700ad5f0: 9304         	str	r3, [sp, #0x10]
700ad5f2: f88d 000f    	strb.w	r0, [sp, #0xf]
;         pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
700ad5f6: 9804         	ldr	r0, [sp, #0x10]
700ad5f8: 9002         	str	r0, [sp, #0x8]
;         if( pxNewQueue != NULL )
700ad5fa: 9802         	ldr	r0, [sp, #0x8]
700ad5fc: b188         	cbz	r0, 0x700ad622 <xQueueGenericCreateStatic+0x42> @ imm = #0x22
700ad5fe: e7ff         	b	0x700ad600 <xQueueGenericCreateStatic+0x20> @ imm = #-0x2
;                     pxNewQueue->ucStaticallyAllocated = pdTRUE;
700ad600: 9902         	ldr	r1, [sp, #0x8]
700ad602: 2001         	movs	r0, #0x1
700ad604: f881 0046    	strb.w	r0, [r1, #0x46]
;             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
700ad608: 9807         	ldr	r0, [sp, #0x1c]
700ad60a: 9906         	ldr	r1, [sp, #0x18]
700ad60c: 9a05         	ldr	r2, [sp, #0x14]
700ad60e: f89d 300f    	ldrb.w	r3, [sp, #0xf]
700ad612: f8dd c008    	ldr.w	r12, [sp, #0x8]
700ad616: 46ee         	mov	lr, sp
700ad618: f8ce c000    	str.w	r12, [lr]
700ad61c: f000 f850    	bl	0x700ad6c0 <prvInitialiseNewQueue> @ imm = #0xa0
;         }
700ad620: e000         	b	0x700ad624 <xQueueGenericCreateStatic+0x44> @ imm = #0x0
700ad622: e7ff         	b	0x700ad624 <xQueueGenericCreateStatic+0x44> @ imm = #-0x2
;         return pxNewQueue;
700ad624: 9802         	ldr	r0, [sp, #0x8]
700ad626: b008         	add	sp, #0x20
700ad628: bd80         	pop	{r7, pc}
700ad62a: 0000         	movs	r0, r0
700ad62c: 0000         	movs	r0, r0
700ad62e: 0000         	movs	r0, r0

700ad630 <UART_resetModule>:
; {
700ad630: b580         	push	{r7, lr}
700ad632: b082         	sub	sp, #0x8
700ad634: 9001         	str	r0, [sp, #0x4]
;     (void)UART_enhanFuncEnable(hUart->baseAddr);
700ad636: 9801         	ldr	r0, [sp, #0x4]
700ad638: 6800         	ldr	r0, [r0]
700ad63a: f000 fd41    	bl	0x700ae0c0 <UART_enhanFuncEnable> @ imm = #0xa82
;     UART_regConfModeRestore(hUart->baseAddr, 0x00U);
700ad63e: 9801         	ldr	r0, [sp, #0x4]
700ad640: 6800         	ldr	r0, [r0]
700ad642: 2100         	movs	r1, #0x0
700ad644: f002 f954    	bl	0x700af8f0 <UART_regConfModeRestore> @ imm = #0x22a8
;     UART_modemControlReset(hUart->baseAddr);
700ad648: 9801         	ldr	r0, [sp, #0x4]
700ad64a: 6800         	ldr	r0, [r0]
700ad64c: f002 f878    	bl	0x700af740 <UART_modemControlReset> @ imm = #0x20f0
;     UART_intrDisable(hUart->baseAddr, 0xFFU);
700ad650: 9801         	ldr	r0, [sp, #0x4]
700ad652: 6800         	ldr	r0, [r0]
700ad654: 21ff         	movs	r1, #0xff
700ad656: f7f8 fe7b    	bl	0x700a6350 <UART_intrDisable> @ imm = #-0x730a
;     UART_intr2Disable(hUart->baseAddr, UART_INT2_TX_EMPTY);
700ad65a: 9801         	ldr	r0, [sp, #0x4]
700ad65c: 6800         	ldr	r0, [r0]
700ad65e: 2102         	movs	r1, #0x2
700ad660: f001 fb96    	bl	0x700aed90 <UART_intr2Disable> @ imm = #0x172c
;     (void)UART_operatingModeSelect(hUart->baseAddr, UART_OPER_MODE_DISABLED);
700ad664: 9801         	ldr	r0, [sp, #0x4]
700ad666: 6800         	ldr	r0, [r0]
700ad668: 2107         	movs	r1, #0x7
700ad66a: f001 fbd9    	bl	0x700aee20 <UART_operatingModeSelect> @ imm = #0x17b2
;     UART_moduleReset(hUart);
700ad66e: 9801         	ldr	r0, [sp, #0x4]
700ad670: f7fd f986    	bl	0x700aa980 <UART_moduleReset> @ imm = #-0x2cf4
;     return;
700ad674: b002         	add	sp, #0x8
700ad676: bd80         	pop	{r7, pc}

700ad678 <memccpy>:
700ad678: e92d4800     	push	{r11, lr}
700ad67c: e1a0c000     	mov	r12, r0
700ad680: e3a00000     	mov	r0, #0
700ad684: e3530000     	cmp	r3, #0
700ad688: 0a000009     	beq	0x700ad6b4 <memccpy+0x3c> @ imm = #0x24
700ad68c: e28cc001     	add	r12, r12, #1
700ad690: e6efe072     	uxtb	lr, r2
700ad694: e5d12000     	ldrb	r2, [r1]
700ad698: e152000e     	cmp	r2, lr
700ad69c: e54c2001     	strb	r2, [r12, #-0x1]
700ad6a0: 0a000004     	beq	0x700ad6b8 <memccpy+0x40> @ imm = #0x10
700ad6a4: e2811001     	add	r1, r1, #1
700ad6a8: e2533001     	subs	r3, r3, #1
700ad6ac: e28cc001     	add	r12, r12, #1
700ad6b0: 1afffff7     	bne	0x700ad694 <memccpy+0x1c> @ imm = #-0x24
700ad6b4: e8bd8800     	pop	{r11, pc}
700ad6b8: e1a0000c     	mov	r0, r12
700ad6bc: e8bd8800     	pop	{r11, pc}

700ad6c0 <prvInitialiseNewQueue>:
; {
700ad6c0: b580         	push	{r7, lr}
700ad6c2: b084         	sub	sp, #0x10
700ad6c4: f8dd c018    	ldr.w	r12, [sp, #0x18]
700ad6c8: 9003         	str	r0, [sp, #0xc]
700ad6ca: 9102         	str	r1, [sp, #0x8]
700ad6cc: 9201         	str	r2, [sp, #0x4]
700ad6ce: f88d 3003    	strb.w	r3, [sp, #0x3]
;     if( uxItemSize == ( UBaseType_t ) 0 )
700ad6d2: 9802         	ldr	r0, [sp, #0x8]
700ad6d4: b918         	cbnz	r0, 0x700ad6de <prvInitialiseNewQueue+0x1e> @ imm = #0x6
700ad6d6: e7ff         	b	0x700ad6d8 <prvInitialiseNewQueue+0x18> @ imm = #-0x2
;         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
700ad6d8: 9806         	ldr	r0, [sp, #0x18]
700ad6da: 6000         	str	r0, [r0]
;     }
700ad6dc: e003         	b	0x700ad6e6 <prvInitialiseNewQueue+0x26> @ imm = #0x6
;         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
700ad6de: 9801         	ldr	r0, [sp, #0x4]
700ad6e0: 9906         	ldr	r1, [sp, #0x18]
700ad6e2: 6008         	str	r0, [r1]
700ad6e4: e7ff         	b	0x700ad6e6 <prvInitialiseNewQueue+0x26> @ imm = #-0x2
;     pxNewQueue->uxLength = uxQueueLength;
700ad6e6: 9803         	ldr	r0, [sp, #0xc]
700ad6e8: 9906         	ldr	r1, [sp, #0x18]
700ad6ea: 63c8         	str	r0, [r1, #0x3c]
;     pxNewQueue->uxItemSize = uxItemSize;
700ad6ec: 9802         	ldr	r0, [sp, #0x8]
700ad6ee: 9906         	ldr	r1, [sp, #0x18]
700ad6f0: 6408         	str	r0, [r1, #0x40]
;     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
700ad6f2: 9806         	ldr	r0, [sp, #0x18]
700ad6f4: 2101         	movs	r1, #0x1
700ad6f6: f7fc fd9b    	bl	0x700aa230 <xQueueGenericReset> @ imm = #-0x34ca
;             pxNewQueue->ucQueueType = ucQueueType;
700ad6fa: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700ad6fe: 9906         	ldr	r1, [sp, #0x18]
700ad700: f881 004c    	strb.w	r0, [r1, #0x4c]
; }
700ad704: b004         	add	sp, #0x10
700ad706: bd80         	pop	{r7, pc}
		...

700ad710 <uxListRemove>:
; {
700ad710: b082         	sub	sp, #0x8
700ad712: 9001         	str	r0, [sp, #0x4]
;     List_t * const pxList = pxItemToRemove->pxContainer;
700ad714: 9801         	ldr	r0, [sp, #0x4]
700ad716: 6900         	ldr	r0, [r0, #0x10]
700ad718: 9000         	str	r0, [sp]
;     pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
700ad71a: 9801         	ldr	r0, [sp, #0x4]
700ad71c: 6841         	ldr	r1, [r0, #0x4]
700ad71e: 6880         	ldr	r0, [r0, #0x8]
700ad720: 6088         	str	r0, [r1, #0x8]
;     pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
700ad722: 9901         	ldr	r1, [sp, #0x4]
700ad724: 6848         	ldr	r0, [r1, #0x4]
700ad726: 6889         	ldr	r1, [r1, #0x8]
700ad728: 6048         	str	r0, [r1, #0x4]
;     if( pxList->pxIndex == pxItemToRemove )
700ad72a: 9800         	ldr	r0, [sp]
700ad72c: 6840         	ldr	r0, [r0, #0x4]
700ad72e: 9901         	ldr	r1, [sp, #0x4]
700ad730: 4288         	cmp	r0, r1
700ad732: d105         	bne	0x700ad740 <uxListRemove+0x30> @ imm = #0xa
700ad734: e7ff         	b	0x700ad736 <uxListRemove+0x26> @ imm = #-0x2
;         pxList->pxIndex = pxItemToRemove->pxPrevious;
700ad736: 9801         	ldr	r0, [sp, #0x4]
700ad738: 6880         	ldr	r0, [r0, #0x8]
700ad73a: 9900         	ldr	r1, [sp]
700ad73c: 6048         	str	r0, [r1, #0x4]
;     }
700ad73e: e000         	b	0x700ad742 <uxListRemove+0x32> @ imm = #0x0
700ad740: e7ff         	b	0x700ad742 <uxListRemove+0x32> @ imm = #-0x2
;     pxItemToRemove->pxContainer = NULL;
700ad742: 9901         	ldr	r1, [sp, #0x4]
700ad744: 2000         	movs	r0, #0x0
700ad746: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )--;
700ad748: 9900         	ldr	r1, [sp]
700ad74a: 6808         	ldr	r0, [r1]
700ad74c: 3801         	subs	r0, #0x1
700ad74e: 6008         	str	r0, [r1]
;     return pxList->uxNumberOfItems;
700ad750: 9800         	ldr	r0, [sp]
700ad752: 6800         	ldr	r0, [r0]
700ad754: b002         	add	sp, #0x8
700ad756: 4770         	bx	lr
		...

700ad760 <CSL_bcdmaTeardownRxChan>:
; {
700ad760: b580         	push	{r7, lr}
700ad762: b086         	sub	sp, #0x18
700ad764: 9005         	str	r0, [sp, #0x14]
700ad766: 9104         	str	r1, [sp, #0x10]
700ad768: f88d 200f    	strb.w	r2, [sp, #0xf]
700ad76c: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad770: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad774: f000 0001    	and	r0, r0, #0x1
700ad778: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad77a: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ad77e: f000 0001    	and	r0, r0, #0x1
700ad782: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ad784: 9805         	ldr	r0, [sp, #0x14]
700ad786: 9a04         	ldr	r2, [sp, #0x10]
700ad788: 2105         	movs	r1, #0x5
700ad78a: 466b         	mov	r3, sp
700ad78c: f7fd fbf8    	bl	0x700aaf80 <CSL_bcdmaDoChanOp> @ imm = #-0x2810
700ad790: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ad792: 9802         	ldr	r0, [sp, #0x8]
700ad794: b120         	cbz	r0, 0x700ad7a0 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #0x8
700ad796: e7ff         	b	0x700ad798 <CSL_bcdmaTeardownRxChan+0x38> @ imm = #-0x2
700ad798: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad79c: 9002         	str	r0, [sp, #0x8]
;     }
700ad79e: e7ff         	b	0x700ad7a0 <CSL_bcdmaTeardownRxChan+0x40> @ imm = #-0x2
;     return retVal;
700ad7a0: 9802         	ldr	r0, [sp, #0x8]
700ad7a2: b006         	add	sp, #0x18
700ad7a4: bd80         	pop	{r7, pc}
		...
700ad7ae: 0000         	movs	r0, r0

700ad7b0 <CSL_bcdmaTeardownTxChan>:
; {
700ad7b0: b580         	push	{r7, lr}
700ad7b2: b086         	sub	sp, #0x18
700ad7b4: 9005         	str	r0, [sp, #0x14]
700ad7b6: 9104         	str	r1, [sp, #0x10]
700ad7b8: f88d 200f    	strb.w	r2, [sp, #0xf]
700ad7bc: f88d 300e    	strb.w	r3, [sp, #0xe]
;     teardownOpts.force  = (bForce == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad7c0: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700ad7c4: f000 0001    	and	r0, r0, #0x1
700ad7c8: 9000         	str	r0, [sp]
;     teardownOpts.wait   = (bWait  == (bool)false) ? (uint32_t)0U : (uint32_t)1U;
700ad7ca: f89d 000e    	ldrb.w	r0, [sp, #0xe]
700ad7ce: f000 0001    	and	r0, r0, #0x1
700ad7d2: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_TEARDOWN, chanIdx, (void *)&teardownOpts );
700ad7d4: 9805         	ldr	r0, [sp, #0x14]
700ad7d6: 9a04         	ldr	r2, [sp, #0x10]
700ad7d8: 2105         	movs	r1, #0x5
700ad7da: 466b         	mov	r3, sp
700ad7dc: f7fd fbd0    	bl	0x700aaf80 <CSL_bcdmaDoChanOp> @ imm = #-0x2860
700ad7e0: 9002         	str	r0, [sp, #0x8]
;     if( retVal != CSL_PASS )
700ad7e2: 9802         	ldr	r0, [sp, #0x8]
700ad7e4: b120         	cbz	r0, 0x700ad7f0 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #0x8
700ad7e6: e7ff         	b	0x700ad7e8 <CSL_bcdmaTeardownTxChan+0x38> @ imm = #-0x2
700ad7e8: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad7ec: 9002         	str	r0, [sp, #0x8]
;     }
700ad7ee: e7ff         	b	0x700ad7f0 <CSL_bcdmaTeardownTxChan+0x40> @ imm = #-0x2
;     return retVal;
700ad7f0: 9802         	ldr	r0, [sp, #0x8]
700ad7f2: b006         	add	sp, #0x18
700ad7f4: bd80         	pop	{r7, pc}
		...
700ad7fe: 0000         	movs	r0, r0

700ad800 <DebugP_uartLogWriterPutChar>:
; {
700ad800: b580         	push	{r7, lr}
700ad802: b088         	sub	sp, #0x20
700ad804: f88d 001f    	strb.w	r0, [sp, #0x1f]
;     char value = character;
700ad808: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
700ad80c: f88d 001e    	strb.w	r0, [sp, #0x1e]
;     UART_Handle uartHandle = UART_getHandle(gDebugP_uartDrvIndex);
700ad810: f642 10e4    	movw	r0, #0x29e4
700ad814: f2c7 000b    	movt	r0, #0x700b
700ad818: 6800         	ldr	r0, [r0]
700ad81a: f7ff fd29    	bl	0x700ad270 <UART_getHandle> @ imm = #-0x5ae
700ad81e: 9006         	str	r0, [sp, #0x18]
;     if(uartHandle!=NULL)
700ad820: 9806         	ldr	r0, [sp, #0x18]
700ad822: b170         	cbz	r0, 0x700ad842 <DebugP_uartLogWriterPutChar+0x42> @ imm = #0x1c
700ad824: e7ff         	b	0x700ad826 <DebugP_uartLogWriterPutChar+0x26> @ imm = #-0x2
700ad826: a801         	add	r0, sp, #0x4
;         UART_Transaction_init(&trans);
700ad828: 9000         	str	r0, [sp]
700ad82a: f001 fa99    	bl	0x700aed60 <UART_Transaction_init> @ imm = #0x1532
700ad82e: 9900         	ldr	r1, [sp]
700ad830: f10d 001e    	add.w	r0, sp, #0x1e
;         trans.buf   = &value;
700ad834: 9001         	str	r0, [sp, #0x4]
700ad836: 2001         	movs	r0, #0x1
;         trans.count = 1;
700ad838: 9002         	str	r0, [sp, #0x8]
;         (void) UART_write(uartHandle, &trans);
700ad83a: 9806         	ldr	r0, [sp, #0x18]
700ad83c: f7f2 fe30    	bl	0x700a04a0 <UART_write> @ imm = #-0xd3a0
;     }
700ad840: e7ff         	b	0x700ad842 <DebugP_uartLogWriterPutChar+0x42> @ imm = #-0x2
; }
700ad842: b008         	add	sp, #0x20
700ad844: bd80         	pop	{r7, pc}
		...
700ad84e: 0000         	movs	r0, r0

700ad850 <Dpl_init>:
; {
700ad850: b510         	push	{r4, lr}
;     HwiP_init();
700ad852: f002 fccd    	bl	0x700b01f0 <HwiP_init>  @ imm = #0x299a
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_ERROR);
700ad856: 2002         	movs	r0, #0x2
700ad858: f001 f992    	bl	0x700aeb80 <DebugP_logZoneEnable> @ imm = #0x1324
;     DebugP_logZoneEnable(DebugP_LOG_ZONE_WARN);
700ad85c: 2004         	movs	r0, #0x4
700ad85e: f001 f98f    	bl	0x700aeb80 <DebugP_logZoneEnable> @ imm = #0x131e
;     DebugP_memLogWriterInit(CSL_CORE_ID_R5FSS0_0);
700ad862: 2001         	movs	r0, #0x1
700ad864: f001 fdcc    	bl	0x700af400 <DebugP_memLogWriterInit> @ imm = #0x1b98
;     DebugP_uartSetDrvIndex(CONFIG_UART_CONSOLE);
700ad868: 2000         	movs	r0, #0x0
700ad86a: 2400         	movs	r4, #0x0
700ad86c: f002 f870    	bl	0x700af950 <DebugP_uartSetDrvIndex> @ imm = #0x20e0
;     SOC_controlModuleUnlockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad870: 2000         	movs	r0, #0x0
700ad872: 2102         	movs	r1, #0x2
700ad874: f7fb fb1c    	bl	0x700a8eb0 <SOC_controlModuleUnlockMMR> @ imm = #-0x49c8
700ad878: f248 10d0    	movw	r0, #0x81d0
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad87c: 2102         	movs	r1, #0x2
700ad87e: f2c4 3000    	movt	r0, #0x4300
;     *(volatile uint32_t*)(TIMER8_CLOCK_SRC_MUX_ADDR) = TIMER8_CLOCK_SRC_MCU_HFOSC0;
700ad882: 6004         	str	r4, [r0]
;     SOC_controlModuleLockMMR(SOC_DOMAIN_ID_MAIN, 2);
700ad884: 2000         	movs	r0, #0x0
700ad886: f7fc fdab    	bl	0x700aa3e0 <SOC_controlModuleLockMMR> @ imm = #-0x34aa
;     ClockP_init();
700ad88a: f7f3 f881    	bl	0x700a0990 <ClockP_init> @ imm = #-0xcefe
;     HwiP_enable();
700ad88e: e8bd 4010    	pop.w	{r4, lr}
700ad892: f7ef bbb1    	b.w	0x7009cff8 <$Ven$TA$L$PI$$HwiP_enable> @ imm = #-0x1089e
		...
700ad89e: 0000         	movs	r0, r0

700ad8a0 <UART_readLineStatus>:
; {
700ad8a0: b580         	push	{r7, lr}
700ad8a2: b084         	sub	sp, #0x10
700ad8a4: 9003         	str	r0, [sp, #0xc]
700ad8a6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0U;
700ad8a8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = 0U;
700ad8aa: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = HW_RD_REG32(baseAddr + UART_LCR);
700ad8ac: 9803         	ldr	r0, [sp, #0xc]
700ad8ae: 300c         	adds	r0, #0xc
700ad8b0: f002 f95e    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x22bc
700ad8b4: 9002         	str	r0, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_LCR, HW_RD_REG32(baseAddr + UART_LCR)
700ad8b6: 9803         	ldr	r0, [sp, #0xc]
700ad8b8: 300c         	adds	r0, #0xc
700ad8ba: 9000         	str	r0, [sp]
700ad8bc: f002 f958    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x22b0
700ad8c0: 4601         	mov	r1, r0
700ad8c2: 9800         	ldr	r0, [sp]
700ad8c4: f001 017f    	and	r1, r1, #0x7f
700ad8c8: f002 f95a    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x22b4
;     retVal = HW_RD_REG32(baseAddr + UART_LSR);
700ad8cc: 9803         	ldr	r0, [sp, #0xc]
700ad8ce: 3014         	adds	r0, #0x14
700ad8d0: f002 f94e    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x229c
700ad8d4: 9001         	str	r0, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ad8d6: 9803         	ldr	r0, [sp, #0xc]
700ad8d8: 300c         	adds	r0, #0xc
700ad8da: 9902         	ldr	r1, [sp, #0x8]
700ad8dc: f002 f950    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x22a0
;     return retVal;
700ad8e0: 9801         	ldr	r0, [sp, #0x4]
700ad8e2: b004         	add	sp, #0x10
700ad8e4: bd80         	pop	{r7, pc}
		...
700ad8ee: 0000         	movs	r0, r0

700ad8f0 <vTaskExitCritical>:
;   if (xSchedulerRunning != pdFALSE) {
700ad8f0: f642 2040    	movw	r0, #0x2a40
700ad8f4: f2c7 000b    	movt	r0, #0x700b
700ad8f8: 6800         	ldr	r0, [r0]
700ad8fa: b1d0         	cbz	r0, 0x700ad932 <vTaskExitCritical+0x42> @ imm = #0x34
700ad8fc: e7ff         	b	0x700ad8fe <vTaskExitCritical+0xe> @ imm = #-0x2
;     if (pxCurrentTCB->uxCriticalNesting > 0U) {
700ad8fe: f642 10fc    	movw	r0, #0x29fc
700ad902: f2c7 000b    	movt	r0, #0x700b
700ad906: 6800         	ldr	r0, [r0]
700ad908: 6d40         	ldr	r0, [r0, #0x54]
700ad90a: b180         	cbz	r0, 0x700ad92e <vTaskExitCritical+0x3e> @ imm = #0x20
700ad90c: e7ff         	b	0x700ad90e <vTaskExitCritical+0x1e> @ imm = #-0x2
;       (pxCurrentTCB->uxCriticalNesting)--;
700ad90e: f642 10fc    	movw	r0, #0x29fc
700ad912: f2c7 000b    	movt	r0, #0x700b
700ad916: 6802         	ldr	r2, [r0]
700ad918: 6d51         	ldr	r1, [r2, #0x54]
700ad91a: 3901         	subs	r1, #0x1
700ad91c: 6551         	str	r1, [r2, #0x54]
;       if (pxCurrentTCB->uxCriticalNesting == 0U) {
700ad91e: 6800         	ldr	r0, [r0]
700ad920: 6d40         	ldr	r0, [r0, #0x54]
700ad922: b910         	cbnz	r0, 0x700ad92a <vTaskExitCritical+0x3a> @ imm = #0x4
700ad924: e7ff         	b	0x700ad926 <vTaskExitCritical+0x36> @ imm = #-0x2
;     __asm__ volatile ( "CPSIE	i" ::: "cc" );
700ad926: b662         	cpsie i
;       } else {
700ad928: e000         	b	0x700ad92c <vTaskExitCritical+0x3c> @ imm = #0x0
700ad92a: e7ff         	b	0x700ad92c <vTaskExitCritical+0x3c> @ imm = #-0x2
;     } else {
700ad92c: e000         	b	0x700ad930 <vTaskExitCritical+0x40> @ imm = #0x0
700ad92e: e7ff         	b	0x700ad930 <vTaskExitCritical+0x40> @ imm = #-0x2
;   } else {
700ad930: e000         	b	0x700ad934 <vTaskExitCritical+0x44> @ imm = #0x0
700ad932: e7ff         	b	0x700ad934 <vTaskExitCritical+0x44> @ imm = #-0x2
; }
700ad934: 4770         	bx	lr
		...
700ad93e: 0000         	movs	r0, r0

700ad940 <CSL_bcdmaGetChanPeerReg>:
; {
700ad940: b580         	push	{r7, lr}
700ad942: b088         	sub	sp, #0x20
700ad944: f8dd c028    	ldr.w	r12, [sp, #0x28]
700ad948: 9007         	str	r0, [sp, #0x1c]
700ad94a: 9106         	str	r1, [sp, #0x18]
700ad94c: 9205         	str	r2, [sp, #0x14]
700ad94e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700ad950: 9804         	ldr	r0, [sp, #0x10]
700ad952: 9001         	str	r0, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700ad954: 9807         	ldr	r0, [sp, #0x1c]
700ad956: 9a06         	ldr	r2, [sp, #0x18]
700ad958: 210b         	movs	r1, #0xb
700ad95a: ab01         	add	r3, sp, #0x4
700ad95c: f7fd fb10    	bl	0x700aaf80 <CSL_bcdmaDoChanOp> @ imm = #-0x29e0
700ad960: 9003         	str	r0, [sp, #0xc]
;     if( retVal == CSL_PASS )
700ad962: 9803         	ldr	r0, [sp, #0xc]
700ad964: b920         	cbnz	r0, 0x700ad970 <CSL_bcdmaGetChanPeerReg+0x30> @ imm = #0x8
700ad966: e7ff         	b	0x700ad968 <CSL_bcdmaGetChanPeerReg+0x28> @ imm = #-0x2
;         *pVal = remotePeerOpts.regVal;
700ad968: 9802         	ldr	r0, [sp, #0x8]
700ad96a: 990a         	ldr	r1, [sp, #0x28]
700ad96c: 6008         	str	r0, [r1]
;     }
700ad96e: e006         	b	0x700ad97e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #0xc
;         *pVal = (uint32_t)0U;
700ad970: 990a         	ldr	r1, [sp, #0x28]
700ad972: 2000         	movs	r0, #0x0
700ad974: 6008         	str	r0, [r1]
700ad976: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700ad97a: 9003         	str	r0, [sp, #0xc]
700ad97c: e7ff         	b	0x700ad97e <CSL_bcdmaGetChanPeerReg+0x3e> @ imm = #-0x2
;     return retVal;
700ad97e: 9803         	ldr	r0, [sp, #0xc]
700ad980: b008         	add	sp, #0x20
700ad982: bd80         	pop	{r7, pc}
		...

700ad990 <_strnlen_s>:
; {
700ad990: b084         	sub	sp, #0x10
700ad992: 9003         	str	r0, [sp, #0xc]
700ad994: 9102         	str	r1, [sp, #0x8]
;   for (s = str; *s && maxsize--; ++s);
700ad996: 9803         	ldr	r0, [sp, #0xc]
700ad998: 9001         	str	r0, [sp, #0x4]
700ad99a: e7ff         	b	0x700ad99c <_strnlen_s+0xc> @ imm = #-0x2
700ad99c: 9801         	ldr	r0, [sp, #0x4]
700ad99e: 7801         	ldrb	r1, [r0]
700ad9a0: 2000         	movs	r0, #0x0
700ad9a2: 9000         	str	r0, [sp]
700ad9a4: b141         	cbz	r1, 0x700ad9b8 <_strnlen_s+0x28> @ imm = #0x10
700ad9a6: e7ff         	b	0x700ad9a8 <_strnlen_s+0x18> @ imm = #-0x2
700ad9a8: 9802         	ldr	r0, [sp, #0x8]
700ad9aa: 1e41         	subs	r1, r0, #0x1
700ad9ac: 9102         	str	r1, [sp, #0x8]
700ad9ae: 2800         	cmp	r0, #0x0
700ad9b0: bf18         	it	ne
700ad9b2: 2001         	movne	r0, #0x1
700ad9b4: 9000         	str	r0, [sp]
700ad9b6: e7ff         	b	0x700ad9b8 <_strnlen_s+0x28> @ imm = #-0x2
700ad9b8: 9800         	ldr	r0, [sp]
;   for (s = str; *s && maxsize--; ++s);
700ad9ba: 07c0         	lsls	r0, r0, #0x1f
700ad9bc: b128         	cbz	r0, 0x700ad9ca <_strnlen_s+0x3a> @ imm = #0xa
700ad9be: e7ff         	b	0x700ad9c0 <_strnlen_s+0x30> @ imm = #-0x2
700ad9c0: e7ff         	b	0x700ad9c2 <_strnlen_s+0x32> @ imm = #-0x2
700ad9c2: 9801         	ldr	r0, [sp, #0x4]
700ad9c4: 3001         	adds	r0, #0x1
700ad9c6: 9001         	str	r0, [sp, #0x4]
700ad9c8: e7e8         	b	0x700ad99c <_strnlen_s+0xc> @ imm = #-0x30
;   return (unsigned int)(s - str);
700ad9ca: 9801         	ldr	r0, [sp, #0x4]
700ad9cc: 9903         	ldr	r1, [sp, #0xc]
700ad9ce: 1a40         	subs	r0, r0, r1
700ad9d0: b004         	add	sp, #0x10
700ad9d2: 4770         	bx	lr
		...

700ad9e0 <prvSampleTimeNow>:
;     {
700ad9e0: b580         	push	{r7, lr}
700ad9e2: b082         	sub	sp, #0x8
700ad9e4: 9001         	str	r0, [sp, #0x4]
;         xTimeNow = xTaskGetTickCount();
700ad9e6: f001 fdab    	bl	0x700af540 <xTaskGetTickCount> @ imm = #0x1b56
700ad9ea: 9000         	str	r0, [sp]
;         if( xTimeNow < xLastTime )
700ad9ec: 9800         	ldr	r0, [sp]
700ad9ee: f642 11f8    	movw	r1, #0x29f8
700ad9f2: f2c7 010b    	movt	r1, #0x700b
700ad9f6: 6809         	ldr	r1, [r1]
700ad9f8: 4288         	cmp	r0, r1
700ad9fa: d206         	bhs	0x700ada0a <prvSampleTimeNow+0x2a> @ imm = #0xc
700ad9fc: e7ff         	b	0x700ad9fe <prvSampleTimeNow+0x1e> @ imm = #-0x2
;             prvSwitchTimerLists();
700ad9fe: f7f9 ff5f    	bl	0x700a78c0 <prvSwitchTimerLists> @ imm = #-0x6142
;             *pxTimerListsWereSwitched = pdTRUE;
700ada02: 9901         	ldr	r1, [sp, #0x4]
700ada04: 2001         	movs	r0, #0x1
700ada06: 6008         	str	r0, [r1]
;         }
700ada08: e003         	b	0x700ada12 <prvSampleTimeNow+0x32> @ imm = #0x6
;             *pxTimerListsWereSwitched = pdFALSE;
700ada0a: 9901         	ldr	r1, [sp, #0x4]
700ada0c: 2000         	movs	r0, #0x0
700ada0e: 6008         	str	r0, [r1]
700ada10: e7ff         	b	0x700ada12 <prvSampleTimeNow+0x32> @ imm = #-0x2
;         xLastTime = xTimeNow;
700ada12: 9800         	ldr	r0, [sp]
700ada14: f642 11f8    	movw	r1, #0x29f8
700ada18: f2c7 010b    	movt	r1, #0x700b
700ada1c: 6008         	str	r0, [r1]
;         return xTimeNow;
700ada1e: 9800         	ldr	r0, [sp]
700ada20: b002         	add	sp, #0x8
700ada22: bd80         	pop	{r7, pc}
		...

700ada30 <CSL_udmapCppi5SetPktLen>:
; {
700ada30: b083         	sub	sp, #0xc
700ada32: 9002         	str	r0, [sp, #0x8]
700ada34: 9101         	str	r1, [sp, #0x4]
700ada36: 9200         	str	r2, [sp]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ada38: 9801         	ldr	r0, [sp, #0x4]
700ada3a: 2801         	cmp	r0, #0x1
700ada3c: d004         	beq	0x700ada48 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #0x8
700ada3e: e7ff         	b	0x700ada40 <CSL_udmapCppi5SetPktLen+0x10> @ imm = #-0x2
;         (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_MONO) )
700ada40: 9801         	ldr	r0, [sp, #0x4]
;     if( (descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST) ||
700ada42: 2802         	cmp	r0, #0x2
700ada44: d107         	bne	0x700ada56 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #0xe
700ada46: e7ff         	b	0x700ada48 <CSL_udmapCppi5SetPktLen+0x18> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PKTLEN, pktLen );
700ada48: 9902         	ldr	r1, [sp, #0x8]
700ada4a: 6808         	ldr	r0, [r1]
700ada4c: 9a00         	ldr	r2, [sp]
700ada4e: f362 0015    	bfi	r0, r2, #0, #22
700ada52: 6008         	str	r0, [r1]
;     }
700ada54: e7ff         	b	0x700ada56 <CSL_udmapCppi5SetPktLen+0x26> @ imm = #-0x2
;     if( descType == CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_TR )
700ada56: 9801         	ldr	r0, [sp, #0x4]
700ada58: 2803         	cmp	r0, #0x3
700ada5a: d108         	bne	0x700ada6e <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #0x10
700ada5c: e7ff         	b	0x700ada5e <CSL_udmapCppi5SetPktLen+0x2e> @ imm = #-0x2
;         CSL_FINS( ((CSL_UdmapCppi5TRPD *)pDesc)->descInfo, UDMAP_CPPI5_TRPD_DESCINFO_LASTIDX, pktLen-1U );
700ada5e: 9902         	ldr	r1, [sp, #0x8]
700ada60: 6808         	ldr	r0, [r1]
700ada62: 9a00         	ldr	r2, [sp]
700ada64: 3a01         	subs	r2, #0x1
700ada66: f362 000d    	bfi	r0, r2, #0, #14
700ada6a: 6008         	str	r0, [r1]
;     }
700ada6c: e7ff         	b	0x700ada6e <CSL_udmapCppi5SetPktLen+0x3e> @ imm = #-0x2
; }
700ada6e: b003         	add	sp, #0xc
700ada70: 4770         	bx	lr
		...
700ada7e: 0000         	movs	r0, r0

700ada80 <Sciclient_rmIrqGetNodeItf>:
; {
700ada80: b084         	sub	sp, #0x10
700ada82: 9003         	str	r0, [sp, #0xc]
700ada84: f8ad 100a    	strh.w	r1, [sp, #0xa]
700ada88: 9201         	str	r2, [sp, #0x4]
700ada8a: 2000         	movs	r0, #0x0
;     int32_t r = SystemP_SUCCESS;
700ada8c: 9000         	str	r0, [sp]
;     if (n_itf < n->n_if) {
700ada8e: f8bd 000a    	ldrh.w	r0, [sp, #0xa]
700ada92: 9903         	ldr	r1, [sp, #0xc]
700ada94: 8849         	ldrh	r1, [r1, #0x2]
700ada96: 4288         	cmp	r0, r1
700ada98: da09         	bge	0x700adaae <Sciclient_rmIrqGetNodeItf+0x2e> @ imm = #0x12
700ada9a: e7ff         	b	0x700ada9c <Sciclient_rmIrqGetNodeItf+0x1c> @ imm = #-0x2
;         *itf = n->p_if[n_itf];
700ada9c: 9803         	ldr	r0, [sp, #0xc]
700ada9e: 6840         	ldr	r0, [r0, #0x4]
700adaa0: f8bd 100a    	ldrh.w	r1, [sp, #0xa]
700adaa4: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700adaa8: 9901         	ldr	r1, [sp, #0x4]
700adaaa: 6008         	str	r0, [r1]
;     } else {
700adaac: e006         	b	0x700adabc <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #0xc
;         *itf = NULL;
700adaae: 9901         	ldr	r1, [sp, #0x4]
700adab0: 2000         	movs	r0, #0x0
700adab2: 6008         	str	r0, [r1]
700adab4: f06f 0001    	mvn	r0, #0x1
;         r = CSL_EBADARGS;
700adab8: 9000         	str	r0, [sp]
700adaba: e7ff         	b	0x700adabc <Sciclient_rmIrqGetNodeItf+0x3c> @ imm = #-0x2
;     return r;
700adabc: 9800         	ldr	r0, [sp]
700adabe: b004         	add	sp, #0x10
700adac0: 4770         	bx	lr
		...
700adace: 0000         	movs	r0, r0

700adad0 <UART_checkOpenParams>:
; {
700adad0: b082         	sub	sp, #0x8
700adad2: 9001         	str	r0, [sp, #0x4]
700adad4: 2000         	movs	r0, #0x0
;     int32_t     status = SystemP_SUCCESS;
700adad6: 9000         	str	r0, [sp]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700adad8: 9801         	ldr	r0, [sp, #0x4]
700adada: 6900         	ldr	r0, [r0, #0x10]
700adadc: 2801         	cmp	r0, #0x1
700adade: d108         	bne	0x700adaf2 <UART_checkOpenParams+0x22> @ imm = #0x10
700adae0: e7ff         	b	0x700adae2 <UART_checkOpenParams+0x12> @ imm = #-0x2
;        (NULL_PTR == prms->readCallbackFxn))
700adae2: 9801         	ldr	r0, [sp, #0x4]
700adae4: 69c0         	ldr	r0, [r0, #0x1c]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->readMode) &&
700adae6: b920         	cbnz	r0, 0x700adaf2 <UART_checkOpenParams+0x22> @ imm = #0x8
700adae8: e7ff         	b	0x700adaea <UART_checkOpenParams+0x1a> @ imm = #-0x2
700adaea: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700adaee: 9000         	str	r0, [sp]
;     }
700adaf0: e7ff         	b	0x700adaf2 <UART_checkOpenParams+0x22> @ imm = #-0x2
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700adaf2: 9801         	ldr	r0, [sp, #0x4]
700adaf4: 6980         	ldr	r0, [r0, #0x18]
700adaf6: 2801         	cmp	r0, #0x1
700adaf8: d108         	bne	0x700adb0c <UART_checkOpenParams+0x3c> @ imm = #0x10
700adafa: e7ff         	b	0x700adafc <UART_checkOpenParams+0x2c> @ imm = #-0x2
;        (NULL_PTR == prms->writeCallbackFxn))
700adafc: 9801         	ldr	r0, [sp, #0x4]
700adafe: 6a00         	ldr	r0, [r0, #0x20]
;     if((UART_TRANSFER_MODE_CALLBACK == prms->writeMode) &&
700adb00: b920         	cbnz	r0, 0x700adb0c <UART_checkOpenParams+0x3c> @ imm = #0x8
700adb02: e7ff         	b	0x700adb04 <UART_checkOpenParams+0x34> @ imm = #-0x2
700adb04: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700adb08: 9000         	str	r0, [sp]
;     }
700adb0a: e7ff         	b	0x700adb0c <UART_checkOpenParams+0x3c> @ imm = #-0x2
;     return (status);
700adb0c: 9800         	ldr	r0, [sp]
700adb0e: b002         	add	sp, #0x8
700adb10: 4770         	bx	lr
		...
700adb1e: 0000         	movs	r0, r0

700adb20 <UdmaUtils_getRingMemSize>:
; {
700adb20: b084         	sub	sp, #0x10
700adb22: f88d 000f    	strb.w	r0, [sp, #0xf]
700adb26: 9102         	str	r1, [sp, #0x8]
700adb28: f88d 2007    	strb.w	r2, [sp, #0x7]
;     ringMemSize = ((uint32_t) 1U << (elemSize + 2U));   /* Element size in bytes */
700adb2c: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700adb30: 1c81         	adds	r1, r0, #0x2
700adb32: 2001         	movs	r0, #0x1
700adb34: 4088         	lsls	r0, r1
700adb36: 9000         	str	r0, [sp]
;     ringMemSize *= elemCnt;
700adb38: 9902         	ldr	r1, [sp, #0x8]
700adb3a: 9800         	ldr	r0, [sp]
700adb3c: 4348         	muls	r0, r1, r0
700adb3e: 9000         	str	r0, [sp]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700adb40: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700adb44: 2802         	cmp	r0, #0x2
700adb46: d005         	beq	0x700adb54 <UdmaUtils_getRingMemSize+0x34> @ imm = #0xa
700adb48: e7ff         	b	0x700adb4a <UdmaUtils_getRingMemSize+0x2a> @ imm = #-0x2
;        (TISCI_MSG_VALUE_RM_RING_MODE_QM == mode))
700adb4a: f89d 000f    	ldrb.w	r0, [sp, #0xf]
;     if((TISCI_MSG_VALUE_RM_RING_MODE_CREDENTIALS == mode) ||
700adb4e: 2803         	cmp	r0, #0x3
700adb50: d104         	bne	0x700adb5c <UdmaUtils_getRingMemSize+0x3c> @ imm = #0x8
700adb52: e7ff         	b	0x700adb54 <UdmaUtils_getRingMemSize+0x34> @ imm = #-0x2
;         ringMemSize <<= 1U;
700adb54: 9800         	ldr	r0, [sp]
700adb56: 0040         	lsls	r0, r0, #0x1
700adb58: 9000         	str	r0, [sp]
;     }
700adb5a: e7ff         	b	0x700adb5c <UdmaUtils_getRingMemSize+0x3c> @ imm = #-0x2
;     return (ringMemSize);
700adb5c: 9800         	ldr	r0, [sp]
700adb5e: b004         	add	sp, #0x10
700adb60: 4770         	bx	lr
		...
700adb6e: 0000         	movs	r0, r0

700adb70 <prvCopyDataFromQueue>:
; {
700adb70: b580         	push	{r7, lr}
700adb72: b082         	sub	sp, #0x8
700adb74: 9001         	str	r0, [sp, #0x4]
700adb76: 9100         	str	r1, [sp]
;     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
700adb78: 9801         	ldr	r0, [sp, #0x4]
700adb7a: 6c00         	ldr	r0, [r0, #0x40]
700adb7c: b1b8         	cbz	r0, 0x700adbae <prvCopyDataFromQueue+0x3e> @ imm = #0x2e
700adb7e: e7ff         	b	0x700adb80 <prvCopyDataFromQueue+0x10> @ imm = #-0x2
;         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
700adb80: 9901         	ldr	r1, [sp, #0x4]
700adb82: 68c8         	ldr	r0, [r1, #0xc]
700adb84: 6c0a         	ldr	r2, [r1, #0x40]
700adb86: 4410         	add	r0, r2
700adb88: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
700adb8a: 9801         	ldr	r0, [sp, #0x4]
700adb8c: 6881         	ldr	r1, [r0, #0x8]
700adb8e: 68c0         	ldr	r0, [r0, #0xc]
700adb90: 4288         	cmp	r0, r1
700adb92: d304         	blo	0x700adb9e <prvCopyDataFromQueue+0x2e> @ imm = #0x8
700adb94: e7ff         	b	0x700adb96 <prvCopyDataFromQueue+0x26> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
700adb96: 9901         	ldr	r1, [sp, #0x4]
700adb98: 6808         	ldr	r0, [r1]
700adb9a: 60c8         	str	r0, [r1, #0xc]
;         }
700adb9c: e000         	b	0x700adba0 <prvCopyDataFromQueue+0x30> @ imm = #0x0
700adb9e: e7ff         	b	0x700adba0 <prvCopyDataFromQueue+0x30> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
700adba0: 9800         	ldr	r0, [sp]
700adba2: 9a01         	ldr	r2, [sp, #0x4]
700adba4: 68d1         	ldr	r1, [r2, #0xc]
700adba6: 6c12         	ldr	r2, [r2, #0x40]
700adba8: f7ec ea98    	blx	0x7009a0dc <__aeabi_memcpy8> @ imm = #-0x13ad0
;     }
700adbac: e7ff         	b	0x700adbae <prvCopyDataFromQueue+0x3e> @ imm = #-0x2
; }
700adbae: b002         	add	sp, #0x8
700adbb0: bd80         	pop	{r7, pc}
		...
700adbbe: 0000         	movs	r0, r0

700adbc0 <CSL_lcdma_ringaccIsTeardownComplete>:
; {
700adbc0: b580         	push	{r7, lr}
700adbc2: b084         	sub	sp, #0x10
700adbc4: 9003         	str	r0, [sp, #0xc]
700adbc6: 9102         	str	r1, [sp, #0x8]
700adbc8: 2000         	movs	r0, #0x0
;     bool bRetVal = (bool)false;
700adbca: f88d 0007    	strb.w	r0, [sp, #0x7]
;     if( CSL_REG32_FEXT( &pCfg->pRingRtRegs->RING[ringNum].ROCC, LCDMA_RINGACC_RINGRT_RING_ROCC_COMP ) != (uint32_t)0U )
700adbce: 9803         	ldr	r0, [sp, #0xc]
700adbd0: 6840         	ldr	r0, [r0, #0x4]
700adbd2: 9902         	ldr	r1, [sp, #0x8]
700adbd4: eb00 3041    	add.w	r0, r0, r1, lsl #13
700adbd8: f241 0118    	movw	r1, #0x1018
700adbdc: 4408         	add	r0, r1
700adbde: f04f 4100    	mov.w	r1, #0x80000000
700adbe2: 221f         	movs	r2, #0x1f
700adbe4: f001 fa6c    	bl	0x700af0c0 <CSL_REG32_FEXT_RAW> @ imm = #0x14d8
700adbe8: b120         	cbz	r0, 0x700adbf4 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #0x8
700adbea: e7ff         	b	0x700adbec <CSL_lcdma_ringaccIsTeardownComplete+0x2c> @ imm = #-0x2
700adbec: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700adbee: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700adbf2: e7ff         	b	0x700adbf4 <CSL_lcdma_ringaccIsTeardownComplete+0x34> @ imm = #-0x2
;     return bRetVal;
700adbf4: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700adbf8: f000 0001    	and	r0, r0, #0x1
700adbfc: b004         	add	sp, #0x10
700adbfe: bd80         	pop	{r7, pc}

700adc00 <Sciclient_rmIrqProgramOesRegister>:
; {
700adc00: b580         	push	{r7, lr}
700adc02: b088         	sub	sp, #0x20
700adc04: 9007         	str	r0, [sp, #0x1c]
700adc06: 2010         	movs	r0, #0x10
700adc08: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700adc0c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700adc0e: 9807         	ldr	r0, [sp, #0x1c]
700adc10: 7900         	ldrb	r0, [r0, #0x4]
700adc12: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700adc16: 9807         	ldr	r0, [sp, #0x1c]
700adc18: 88c0         	ldrh	r0, [r0, #0x6]
700adc1a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700adc1e: 9807         	ldr	r0, [sp, #0x1c]
700adc20: 8900         	ldrh	r0, [r0, #0x8]
700adc22: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700adc26: 9807         	ldr	r0, [sp, #0x1c]
700adc28: 89c0         	ldrh	r0, [r0, #0xe]
700adc2a: f8ad 0018    	strh.w	r0, [sp, #0x18]
;                                  cfg->set_resp,
700adc2e: 9807         	ldr	r0, [sp, #0x1c]
700adc30: 6981         	ldr	r1, [r0, #0x18]
700adc32: 4668         	mov	r0, sp
700adc34: f04f 32ff    	mov.w	r2, #0xffffffff
;     return Sciclient_rmIrqSetRaw(&req,
700adc38: f7fe fe02    	bl	0x700ac840 <Sciclient_rmIrqSetRaw> @ imm = #-0x13fc
700adc3c: b008         	add	sp, #0x20
700adc3e: bd80         	pop	{r7, pc}

700adc40 <Sciclient_rmPsGetIfIdx>:
; {
700adc40: b082         	sub	sp, #0x8
700adc42: f8ad 0006    	strh.w	r0, [sp, #0x6]
700adc46: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700adc4a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700adc4c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adc50: f241 0158    	movw	r1, #0x1058
700adc54: f2c7 0108    	movt	r1, #0x7008
700adc58: 8c89         	ldrh	r1, [r1, #0x24]
700adc5a: 4288         	cmp	r0, r1
700adc5c: da0d         	bge	0x700adc7a <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #0x1a
700adc5e: e7ff         	b	0x700adc60 <Sciclient_rmPsGetIfIdx+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].if_idx;
700adc60: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adc64: eb00 0140    	add.w	r1, r0, r0, lsl #1
700adc68: f241 0058    	movw	r0, #0x1058
700adc6c: f2c7 0008    	movt	r0, #0x7008
700adc70: eb00 0081    	add.w	r0, r0, r1, lsl #2
700adc74: 8880         	ldrh	r0, [r0, #0x4]
700adc76: 9000         	str	r0, [sp]
;     }
700adc78: e7ff         	b	0x700adc7a <Sciclient_rmPsGetIfIdx+0x3a> @ imm = #-0x2
;     return r;
700adc7a: 9800         	ldr	r0, [sp]
700adc7c: b002         	add	sp, #0x8
700adc7e: 4770         	bx	lr

700adc80 <Sciclient_rmPsGetInp>:
; {
700adc80: b082         	sub	sp, #0x8
700adc82: f8ad 0006    	strh.w	r0, [sp, #0x6]
700adc86: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700adc8a: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700adc8c: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adc90: f241 0158    	movw	r1, #0x1058
700adc94: f2c7 0108    	movt	r1, #0x7008
700adc98: 8c89         	ldrh	r1, [r1, #0x24]
700adc9a: 4288         	cmp	r0, r1
700adc9c: da0d         	bge	0x700adcba <Sciclient_rmPsGetInp+0x3a> @ imm = #0x1a
700adc9e: e7ff         	b	0x700adca0 <Sciclient_rmPsGetInp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].inp;
700adca0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adca4: eb00 0140    	add.w	r1, r0, r0, lsl #1
700adca8: f241 0058    	movw	r0, #0x1058
700adcac: f2c7 0008    	movt	r0, #0x7008
700adcb0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700adcb4: 88c0         	ldrh	r0, [r0, #0x6]
700adcb6: 9000         	str	r0, [sp]
;     }
700adcb8: e7ff         	b	0x700adcba <Sciclient_rmPsGetInp+0x3a> @ imm = #-0x2
;     return r;
700adcba: 9800         	ldr	r0, [sp]
700adcbc: b002         	add	sp, #0x8
700adcbe: 4770         	bx	lr

700adcc0 <Sciclient_rmPsGetOutp>:
; {
700adcc0: b082         	sub	sp, #0x8
700adcc2: f8ad 0006    	strh.w	r0, [sp, #0x6]
700adcc6: f06f 0001    	mvn	r0, #0x1
;     int32_t r = CSL_EBADARGS;
700adcca: 9000         	str	r0, [sp]
;     if (index < gPstack.psp) {
700adccc: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adcd0: f241 0158    	movw	r1, #0x1058
700adcd4: f2c7 0108    	movt	r1, #0x7008
700adcd8: 8c89         	ldrh	r1, [r1, #0x24]
700adcda: 4288         	cmp	r0, r1
700adcdc: da0d         	bge	0x700adcfa <Sciclient_rmPsGetOutp+0x3a> @ imm = #0x1a
700adcde: e7ff         	b	0x700adce0 <Sciclient_rmPsGetOutp+0x20> @ imm = #-0x2
;         r = gPstack.ps[index].outp;
700adce0: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700adce4: eb00 0140    	add.w	r1, r0, r0, lsl #1
700adce8: f241 0058    	movw	r0, #0x1058
700adcec: f2c7 0008    	movt	r0, #0x7008
700adcf0: eb00 0081    	add.w	r0, r0, r1, lsl #2
700adcf4: 8900         	ldrh	r0, [r0, #0x8]
700adcf6: 9000         	str	r0, [sp]
;     }
700adcf8: e7ff         	b	0x700adcfa <Sciclient_rmPsGetOutp+0x3a> @ imm = #-0x2
;     return r;
700adcfa: 9800         	ldr	r0, [sp]
700adcfc: b002         	add	sp, #0x8
700adcfe: 4770         	bx	lr

700add00 <free_list_insert>:
700add00: e5902000     	ldr	r2, [r0]
700add04: e59f1030     	ldr	r1, [pc, #0x30]         @ 0x700add3c <free_list_insert+0x3c>
700add08: e3c2c001     	bic	r12, r2, #1
700add0c: e5913000     	ldr	r3, [r1]
700add10: e3530000     	cmp	r3, #0
700add14: 0a000005     	beq	0x700add30 <free_list_insert+0x30> @ imm = #0x14
700add18: e5932000     	ldr	r2, [r3]
700add1c: e3c22001     	bic	r2, r2, #1
700add20: e152000c     	cmp	r2, r12
700add24: 2a000001     	bhs	0x700add30 <free_list_insert+0x30> @ imm = #0x4
700add28: e2831008     	add	r1, r3, #8
700add2c: eafffff6     	b	0x700add0c <free_list_insert+0xc> @ imm = #-0x28
700add30: e5803008     	str	r3, [r0, #0x8]
700add34: e5810000     	str	r0, [r1]
700add38: e12fff1e     	bx	lr
700add3c: ac 52 08 70  	.word	0x700852ac

700add40 <prvGetNextExpireTime>:
;     {
700add40: b082         	sub	sp, #0x8
700add42: 9001         	str	r0, [sp, #0x4]
;         *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
700add44: f245 209c    	movw	r0, #0x529c
700add48: f2c7 0008    	movt	r0, #0x7008
700add4c: 6800         	ldr	r0, [r0]
700add4e: 6800         	ldr	r0, [r0]
700add50: fab0 f080    	clz	r0, r0
700add54: 0940         	lsrs	r0, r0, #0x5
700add56: 9901         	ldr	r1, [sp, #0x4]
700add58: 6008         	str	r0, [r1]
;         if( *pxListWasEmpty == pdFALSE )
700add5a: 9801         	ldr	r0, [sp, #0x4]
700add5c: 6800         	ldr	r0, [r0]
700add5e: b948         	cbnz	r0, 0x700add74 <prvGetNextExpireTime+0x34> @ imm = #0x12
700add60: e7ff         	b	0x700add62 <prvGetNextExpireTime+0x22> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
700add62: f245 209c    	movw	r0, #0x529c
700add66: f2c7 0008    	movt	r0, #0x7008
700add6a: 6800         	ldr	r0, [r0]
700add6c: 68c0         	ldr	r0, [r0, #0xc]
700add6e: 6800         	ldr	r0, [r0]
700add70: 9000         	str	r0, [sp]
;         }
700add72: e002         	b	0x700add7a <prvGetNextExpireTime+0x3a> @ imm = #0x4
700add74: 2000         	movs	r0, #0x0
;             xNextExpireTime = ( TickType_t ) 0U;
700add76: 9000         	str	r0, [sp]
700add78: e7ff         	b	0x700add7a <prvGetNextExpireTime+0x3a> @ imm = #-0x2
;         return xNextExpireTime;
700add7a: 9800         	ldr	r0, [sp]
700add7c: b002         	add	sp, #0x8
700add7e: 4770         	bx	lr

700add80 <Sciclient_secProxyWaitThread>:
; {
700add80: b580         	push	{r7, lr}
700add82: b084         	sub	sp, #0x10
700add84: 9003         	str	r0, [sp, #0xc]
700add86: 9102         	str	r1, [sp, #0x8]
700add88: f06f 0003    	mvn	r0, #0x3
;     int32_t  status     = CSL_ETIMEOUT;
700add8c: 9001         	str	r0, [sp, #0x4]
;     uint32_t timeToWait = timeout;
700add8e: 9802         	ldr	r0, [sp, #0x8]
700add90: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700add92: e7ff         	b	0x700add94 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x2
700add94: 9800         	ldr	r0, [sp]
700add96: b178         	cbz	r0, 0x700addb8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x1e
700add98: e7ff         	b	0x700add9a <Sciclient_secProxyWaitThread+0x1a> @ imm = #-0x2
;         if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700add9a: 9803         	ldr	r0, [sp, #0xc]
700add9c: f001 fc90    	bl	0x700af6c0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x1920
700adda0: f001 ff46    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0x1e8c
700adda4: 0600         	lsls	r0, r0, #0x18
700adda6: b118         	cbz	r0, 0x700addb0 <Sciclient_secProxyWaitThread+0x30> @ imm = #0x6
700adda8: e7ff         	b	0x700addaa <Sciclient_secProxyWaitThread+0x2a> @ imm = #-0x2
700addaa: 2000         	movs	r0, #0x0
;             status = SystemP_SUCCESS;
700addac: 9001         	str	r0, [sp, #0x4]
;             break;
700addae: e003         	b	0x700addb8 <Sciclient_secProxyWaitThread+0x38> @ imm = #0x6
;         timeToWait--;
700addb0: 9800         	ldr	r0, [sp]
700addb2: 3801         	subs	r0, #0x1
700addb4: 9000         	str	r0, [sp]
;     while (timeToWait > 0U)
700addb6: e7ed         	b	0x700add94 <Sciclient_secProxyWaitThread+0x14> @ imm = #-0x26
;     return status;
700addb8: 9801         	ldr	r0, [sp, #0x4]
700addba: b004         	add	sp, #0x10
700addbc: bd80         	pop	{r7, pc}
700addbe: 0000         	movs	r0, r0

700addc0 <UART_IsHWFlowCtrlValid>:
; {
700addc0: b082         	sub	sp, #0x8
700addc2: 9001         	str	r0, [sp, #0x4]
700addc4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700addc8: 9000         	str	r0, [sp]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700addca: 9801         	ldr	r0, [sp, #0x4]
700addcc: 2801         	cmp	r0, #0x1
700addce: d010         	beq	0x700addf2 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x20
700addd0: e7ff         	b	0x700addd2 <UART_IsHWFlowCtrlValid+0x12> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_8)  ||
700addd2: 9801         	ldr	r0, [sp, #0x4]
700addd4: 2808         	cmp	r0, #0x8
700addd6: d00c         	beq	0x700addf2 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x18
700addd8: e7ff         	b	0x700addda <UART_IsHWFlowCtrlValid+0x1a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_16) ||
700addda: 9801         	ldr	r0, [sp, #0x4]
700adddc: 2810         	cmp	r0, #0x10
700addde: d008         	beq	0x700addf2 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x10
700adde0: e7ff         	b	0x700adde2 <UART_IsHWFlowCtrlValid+0x22> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_56) ||
700adde2: 9801         	ldr	r0, [sp, #0x4]
700adde4: 2838         	cmp	r0, #0x38
700adde6: d004         	beq	0x700addf2 <UART_IsHWFlowCtrlValid+0x32> @ imm = #0x8
700adde8: e7ff         	b	0x700addea <UART_IsHWFlowCtrlValid+0x2a> @ imm = #-0x2
;         (hwFlowControlThr == UART_RXTRIGLVL_60)))
700addea: 9801         	ldr	r0, [sp, #0x4]
;     if(((hwFlowControlThr == UART_RXTRIGLVL_1)  ||
700addec: 283c         	cmp	r0, #0x3c
700addee: d103         	bne	0x700addf8 <UART_IsHWFlowCtrlValid+0x38> @ imm = #0x6
700addf0: e7ff         	b	0x700addf2 <UART_IsHWFlowCtrlValid+0x32> @ imm = #-0x2
700addf2: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700addf4: 9000         	str	r0, [sp]
;     }
700addf6: e7ff         	b	0x700addf8 <UART_IsHWFlowCtrlValid+0x38> @ imm = #-0x2
;     return status;
700addf8: 9800         	ldr	r0, [sp]
700addfa: b002         	add	sp, #0x8
700addfc: 4770         	bx	lr
700addfe: 0000         	movs	r0, r0

700ade00 <UART_IsRxTrigLvlValid>:
; {
700ade00: b082         	sub	sp, #0x8
700ade02: 9001         	str	r0, [sp, #0x4]
700ade04: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ade08: 9000         	str	r0, [sp]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700ade0a: 9801         	ldr	r0, [sp, #0x4]
700ade0c: 2801         	cmp	r0, #0x1
700ade0e: d010         	beq	0x700ade32 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x20
700ade10: e7ff         	b	0x700ade12 <UART_IsRxTrigLvlValid+0x12> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_8)  ||
700ade12: 9801         	ldr	r0, [sp, #0x4]
700ade14: 2808         	cmp	r0, #0x8
700ade16: d00c         	beq	0x700ade32 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x18
700ade18: e7ff         	b	0x700ade1a <UART_IsRxTrigLvlValid+0x1a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_16) ||
700ade1a: 9801         	ldr	r0, [sp, #0x4]
700ade1c: 2810         	cmp	r0, #0x10
700ade1e: d008         	beq	0x700ade32 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x10
700ade20: e7ff         	b	0x700ade22 <UART_IsRxTrigLvlValid+0x22> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_56) ||
700ade22: 9801         	ldr	r0, [sp, #0x4]
700ade24: 2838         	cmp	r0, #0x38
700ade26: d004         	beq	0x700ade32 <UART_IsRxTrigLvlValid+0x32> @ imm = #0x8
700ade28: e7ff         	b	0x700ade2a <UART_IsRxTrigLvlValid+0x2a> @ imm = #-0x2
;         (rxTrigLvl == UART_RXTRIGLVL_60)))
700ade2a: 9801         	ldr	r0, [sp, #0x4]
;     if(((rxTrigLvl == UART_RXTRIGLVL_1)  ||
700ade2c: 283c         	cmp	r0, #0x3c
700ade2e: d103         	bne	0x700ade38 <UART_IsRxTrigLvlValid+0x38> @ imm = #0x6
700ade30: e7ff         	b	0x700ade32 <UART_IsRxTrigLvlValid+0x32> @ imm = #-0x2
700ade32: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ade34: 9000         	str	r0, [sp]
;     }
700ade36: e7ff         	b	0x700ade38 <UART_IsRxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700ade38: 9800         	ldr	r0, [sp]
700ade3a: b002         	add	sp, #0x8
700ade3c: 4770         	bx	lr
700ade3e: 0000         	movs	r0, r0

700ade40 <UART_IsTxTrigLvlValid>:
; {
700ade40: b082         	sub	sp, #0x8
700ade42: 9001         	str	r0, [sp, #0x4]
700ade44: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ade48: 9000         	str	r0, [sp]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700ade4a: 9801         	ldr	r0, [sp, #0x4]
700ade4c: 2801         	cmp	r0, #0x1
700ade4e: d010         	beq	0x700ade72 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x20
700ade50: e7ff         	b	0x700ade52 <UART_IsTxTrigLvlValid+0x12> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_8)  ||
700ade52: 9801         	ldr	r0, [sp, #0x4]
700ade54: 2808         	cmp	r0, #0x8
700ade56: d00c         	beq	0x700ade72 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x18
700ade58: e7ff         	b	0x700ade5a <UART_IsTxTrigLvlValid+0x1a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_16) ||
700ade5a: 9801         	ldr	r0, [sp, #0x4]
700ade5c: 2810         	cmp	r0, #0x10
700ade5e: d008         	beq	0x700ade72 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x10
700ade60: e7ff         	b	0x700ade62 <UART_IsTxTrigLvlValid+0x22> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_32) ||
700ade62: 9801         	ldr	r0, [sp, #0x4]
700ade64: 2820         	cmp	r0, #0x20
700ade66: d004         	beq	0x700ade72 <UART_IsTxTrigLvlValid+0x32> @ imm = #0x8
700ade68: e7ff         	b	0x700ade6a <UART_IsTxTrigLvlValid+0x2a> @ imm = #-0x2
;         (txTrigLvl == UART_TXTRIGLVL_56)))
700ade6a: 9801         	ldr	r0, [sp, #0x4]
;     if(((txTrigLvl == UART_TXTRIGLVL_1)  ||
700ade6c: 2838         	cmp	r0, #0x38
700ade6e: d103         	bne	0x700ade78 <UART_IsTxTrigLvlValid+0x38> @ imm = #0x6
700ade70: e7ff         	b	0x700ade72 <UART_IsTxTrigLvlValid+0x32> @ imm = #-0x2
700ade72: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ade74: 9000         	str	r0, [sp]
;     }
700ade76: e7ff         	b	0x700ade78 <UART_IsTxTrigLvlValid+0x38> @ imm = #-0x2
;     return status;
700ade78: 9800         	ldr	r0, [sp]
700ade7a: b002         	add	sp, #0x8
700ade7c: 4770         	bx	lr
700ade7e: 0000         	movs	r0, r0

700ade80 <UART_i2310WA>:
; {
700ade80: b580         	push	{r7, lr}
700ade82: b084         	sub	sp, #0x10
700ade84: 9003         	str	r0, [sp, #0xc]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTL, 0xFF);
700ade86: 9803         	ldr	r0, [sp, #0xc]
700ade88: 3098         	adds	r0, #0x98
700ade8a: 21ff         	movs	r1, #0xff
700ade8c: 9101         	str	r1, [sp, #0x4]
700ade8e: f001 fe77    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x1cee
700ade92: 9901         	ldr	r1, [sp, #0x4]
;     HW_WR_REG32(baseAddr + UART_TIMEOUTH, 0xFF);
700ade94: 9803         	ldr	r0, [sp, #0xc]
700ade96: 309c         	adds	r0, #0x9c
700ade98: f001 fe72    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x1ce4
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 1);
700ade9c: 9803         	ldr	r0, [sp, #0xc]
700ade9e: 308c         	adds	r0, #0x8c
700adea0: 2206         	movs	r2, #0x6
700adea2: 9202         	str	r2, [sp, #0x8]
700adea4: 2301         	movs	r3, #0x1
700adea6: 4611         	mov	r1, r2
700adea8: f000 fc02    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x804
700adeac: 9a02         	ldr	r2, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR2, UART_EFR2_TIMEOUT_BEHAVE, 0);
700adeae: 9803         	ldr	r0, [sp, #0xc]
700adeb0: 308c         	adds	r0, #0x8c
700adeb2: 2300         	movs	r3, #0x0
700adeb4: 4611         	mov	r1, r2
700adeb6: f000 fbfb    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x7f6
; }
700adeba: b004         	add	sp, #0x10
700adebc: bd80         	pop	{r7, pc}
700adebe: 0000         	movs	r0, r0

700adec0 <UART_spaceAvail>:
; {
700adec0: b580         	push	{r7, lr}
700adec2: b084         	sub	sp, #0x10
700adec4: 9003         	str	r0, [sp, #0xc]
700adec6: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700adec8: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700adeca: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700adecc: 9803         	ldr	r0, [sp, #0xc]
700adece: 217f         	movs	r1, #0x7f
700aded0: f7fe fc56    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #-0x1754
700aded4: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700aded6: 9803         	ldr	r0, [sp, #0xc]
700aded8: 3014         	adds	r0, #0x14
700adeda: f001 fe49    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x1c92
700adede: f000 0060    	and	r0, r0, #0x60
;     if ((UART_LSR_TX_SR_E_MASK | UART_LSR_TX_FIFO_E_MASK) ==
700adee2: 2860         	cmp	r0, #0x60
700adee4: d103         	bne	0x700adeee <UART_spaceAvail+0x2e> @ imm = #0x6
700adee6: e7ff         	b	0x700adee8 <UART_spaceAvail+0x28> @ imm = #-0x2
700adee8: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700adeea: 9001         	str	r0, [sp, #0x4]
;     }
700adeec: e7ff         	b	0x700adeee <UART_spaceAvail+0x2e> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700adeee: 9803         	ldr	r0, [sp, #0xc]
700adef0: 300c         	adds	r0, #0xc
700adef2: 9902         	ldr	r1, [sp, #0x8]
700adef4: f001 fe44    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x1c88
;     return retVal;
700adef8: 9801         	ldr	r0, [sp, #0x4]
700adefa: b004         	add	sp, #0x10
700adefc: bd80         	pop	{r7, pc}
700adefe: 0000         	movs	r0, r0

700adf00 <CSL_bcdmaSetChanPeerReg>:
; {
700adf00: b580         	push	{r7, lr}
700adf02: b088         	sub	sp, #0x20
700adf04: f8dd c028    	ldr.w	r12, [sp, #0x28]
700adf08: 9007         	str	r0, [sp, #0x1c]
700adf0a: 9106         	str	r1, [sp, #0x18]
700adf0c: 9205         	str	r2, [sp, #0x14]
700adf0e: 9304         	str	r3, [sp, #0x10]
;     remotePeerOpts.regIdx = regIdx;
700adf10: 9804         	ldr	r0, [sp, #0x10]
700adf12: 9001         	str	r0, [sp, #0x4]
;     remotePeerOpts.regVal = *pVal;
700adf14: 980a         	ldr	r0, [sp, #0x28]
700adf16: 6800         	ldr	r0, [r0]
700adf18: 9002         	str	r0, [sp, #0x8]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_REMOTE_PEER_REG, chanIdx, (void *)&remotePeerOpts );
700adf1a: 9807         	ldr	r0, [sp, #0x1c]
700adf1c: 9a06         	ldr	r2, [sp, #0x18]
700adf1e: 210c         	movs	r1, #0xc
700adf20: ab01         	add	r3, sp, #0x4
700adf22: f7fd f82d    	bl	0x700aaf80 <CSL_bcdmaDoChanOp> @ imm = #-0x2fa6
700adf26: 9003         	str	r0, [sp, #0xc]
;     if( retVal != CSL_PASS )
700adf28: 9803         	ldr	r0, [sp, #0xc]
700adf2a: b120         	cbz	r0, 0x700adf36 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #0x8
700adf2c: e7ff         	b	0x700adf2e <CSL_bcdmaSetChanPeerReg+0x2e> @ imm = #-0x2
700adf2e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700adf32: 9003         	str	r0, [sp, #0xc]
;     }
700adf34: e7ff         	b	0x700adf36 <CSL_bcdmaSetChanPeerReg+0x36> @ imm = #-0x2
;     return retVal;
700adf36: 9803         	ldr	r0, [sp, #0xc]
700adf38: b008         	add	sp, #0x20
700adf3a: bd80         	pop	{r7, pc}
700adf3c: 0000         	movs	r0, r0
700adf3e: 0000         	movs	r0, r0

700adf40 <CSL_intaggrIsValidStatusBitNum>:
; {
700adf40: b084         	sub	sp, #0x10
700adf42: 9003         	str	r0, [sp, #0xc]
700adf44: 9102         	str	r1, [sp, #0x8]
;     uint32_t localStatusBitNum = statusBitNum;
700adf46: 9802         	ldr	r0, [sp, #0x8]
700adf48: 9000         	str	r0, [sp]
;     localStatusBitNum &= ~CSL_INTAGGR_INTR_MODE_FLAG;   /* Remove intr mode flag */
700adf4a: 9800         	ldr	r0, [sp]
700adf4c: f020 4000    	bic	r0, r0, #0x80000000
700adf50: 9000         	str	r0, [sp]
;     if( localStatusBitNum < (pCfg->virtIntrCnt << 6U) )
700adf52: 9800         	ldr	r0, [sp]
700adf54: 9903         	ldr	r1, [sp, #0xc]
700adf56: 6a49         	ldr	r1, [r1, #0x24]
700adf58: ebb0 1f81    	cmp.w	r0, r1, lsl #6
700adf5c: d204         	bhs	0x700adf68 <CSL_intaggrIsValidStatusBitNum+0x28> @ imm = #0x8
700adf5e: e7ff         	b	0x700adf60 <CSL_intaggrIsValidStatusBitNum+0x20> @ imm = #-0x2
700adf60: 2001         	movs	r0, #0x1
;         bRetVal = (bool)true;
700adf62: f88d 0007    	strb.w	r0, [sp, #0x7]
;     }
700adf66: e003         	b	0x700adf70 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #0x6
700adf68: 2000         	movs	r0, #0x0
;         bRetVal = (bool)false;
700adf6a: f88d 0007    	strb.w	r0, [sp, #0x7]
700adf6e: e7ff         	b	0x700adf70 <CSL_intaggrIsValidStatusBitNum+0x30> @ imm = #-0x2
;     return bRetVal;
700adf70: f89d 0007    	ldrb.w	r0, [sp, #0x7]
700adf74: f000 0001    	and	r0, r0, #0x1
700adf78: b004         	add	sp, #0x10
700adf7a: 4770         	bx	lr
700adf7c: 0000         	movs	r0, r0
700adf7e: 0000         	movs	r0, r0

700adf80 <CSL_pktdmaSetRxRT>:
; {
700adf80: b580         	push	{r7, lr}
700adf82: b084         	sub	sp, #0x10
700adf84: 9003         	str	r0, [sp, #0xc]
700adf86: 9102         	str	r1, [sp, #0x8]
700adf88: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pRxChanRtRegs->CHAN[chanIdx].CTL,
700adf8a: 9803         	ldr	r0, [sp, #0xc]
700adf8c: 6940         	ldr	r0, [r0, #0x14]
700adf8e: 9902         	ldr	r1, [sp, #0x8]
700adf90: eb00 3001    	add.w	r0, r0, r1, lsl #12
700adf94: 9901         	ldr	r1, [sp, #0x4]
700adf96: 680b         	ldr	r3, [r1]
700adf98: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700adf9c: 688a         	ldr	r2, [r1, #0x8]
700adf9e: f04f 4180    	mov.w	r1, #0x40000000
700adfa2: ea01 718c    	and.w	r1, r1, r12, lsl #30
700adfa6: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700adfaa: f002 0201    	and	r2, r2, #0x1
700adfae: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700adfb2: f001 fd8d    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0x1b1a
700adfb6: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700adfb8: b004         	add	sp, #0x10
700adfba: bd80         	pop	{r7, pc}
700adfbc: 0000         	movs	r0, r0
700adfbe: 0000         	movs	r0, r0

700adfc0 <CSL_pktdmaSetTxRT>:
; {
700adfc0: b580         	push	{r7, lr}
700adfc2: b084         	sub	sp, #0x10
700adfc4: 9003         	str	r0, [sp, #0xc]
700adfc6: 9102         	str	r1, [sp, #0x8]
700adfc8: 9201         	str	r2, [sp, #0x4]
;     CSL_REG32_WR(&pCfg->pTxChanRtRegs->CHAN[chanIdx].CTL,
700adfca: 9803         	ldr	r0, [sp, #0xc]
700adfcc: 6900         	ldr	r0, [r0, #0x10]
700adfce: 9902         	ldr	r1, [sp, #0x8]
700adfd0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700adfd4: 9901         	ldr	r1, [sp, #0x4]
700adfd6: 680b         	ldr	r3, [r1]
700adfd8: f8d1 c004    	ldr.w	r12, [r1, #0x4]
700adfdc: 688a         	ldr	r2, [r1, #0x8]
700adfde: f04f 4180    	mov.w	r1, #0x40000000
700adfe2: ea01 718c    	and.w	r1, r1, r12, lsl #30
700adfe6: ea41 71c3    	orr.w	r1, r1, r3, lsl #31
700adfea: f002 0201    	and	r2, r2, #0x1
700adfee: ea41 7142    	orr.w	r1, r1, r2, lsl #29
700adff2: f001 fd6d    	bl	0x700afad0 <CSL_REG32_WR_RAW> @ imm = #0x1ada
700adff6: 2000         	movs	r0, #0x0
;     return CSL_PASS;
700adff8: b004         	add	sp, #0x10
700adffa: bd80         	pop	{r7, pc}
700adffc: 0000         	movs	r0, r0
700adffe: 0000         	movs	r0, r0

700ae000 <Sciclient_rmIrqClearOesRegister>:
; {
700ae000: b580         	push	{r7, lr}
700ae002: b088         	sub	sp, #0x20
700ae004: 9007         	str	r0, [sp, #0x1c]
700ae006: 2010         	movs	r0, #0x10
700ae008: f2c8 0000    	movt	r0, #0x8000
;     req.valid_params = (TISCI_MSG_VALUE_RM_GLOBAL_EVENT_VALID |
700ae00c: 9002         	str	r0, [sp, #0x8]
;     req.secondary_host = cfg->host;
700ae00e: 9807         	ldr	r0, [sp, #0x1c]
700ae010: 7900         	ldrb	r0, [r0, #0x4]
700ae012: f88d 001b    	strb.w	r0, [sp, #0x1b]
;     req.src_id = cfg->s_id;
700ae016: 9807         	ldr	r0, [sp, #0x1c]
700ae018: 88c0         	ldrh	r0, [r0, #0x6]
700ae01a: f8ad 000c    	strh.w	r0, [sp, #0xc]
;     req.src_index = cfg->s_idx;
700ae01e: 9807         	ldr	r0, [sp, #0x1c]
700ae020: 8900         	ldrh	r0, [r0, #0x8]
700ae022: f8ad 000e    	strh.w	r0, [sp, #0xe]
;     req.global_event = cfg->global_evt;
700ae026: 9807         	ldr	r0, [sp, #0x1c]
700ae028: 89c0         	ldrh	r0, [r0, #0xe]
700ae02a: f8ad 0018    	strh.w	r0, [sp, #0x18]
700ae02e: 4668         	mov	r0, sp
700ae030: f04f 31ff    	mov.w	r1, #0xffffffff
;     return Sciclient_rmIrqReleaseRaw(&req,
700ae034: f7fe fdd4    	bl	0x700acbe0 <Sciclient_rmIrqReleaseRaw> @ imm = #-0x1458
700ae038: b008         	add	sp, #0x20
700ae03a: bd80         	pop	{r7, pc}
700ae03c: 0000         	movs	r0, r0
700ae03e: 0000         	movs	r0, r0

700ae040 <UART_IsParityTypeValid>:
; {
700ae040: b082         	sub	sp, #0x8
700ae042: 9001         	str	r0, [sp, #0x4]
700ae044: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ae048: 9000         	str	r0, [sp]
;     if(((parityType == UART_PARITY_NONE)    ||
700ae04a: 9801         	ldr	r0, [sp, #0x4]
700ae04c: b180         	cbz	r0, 0x700ae070 <UART_IsParityTypeValid+0x30> @ imm = #0x20
700ae04e: e7ff         	b	0x700ae050 <UART_IsParityTypeValid+0x10> @ imm = #-0x2
;         (parityType == UART_PARITY_ODD)     ||
700ae050: 9801         	ldr	r0, [sp, #0x4]
700ae052: 2801         	cmp	r0, #0x1
700ae054: d00c         	beq	0x700ae070 <UART_IsParityTypeValid+0x30> @ imm = #0x18
700ae056: e7ff         	b	0x700ae058 <UART_IsParityTypeValid+0x18> @ imm = #-0x2
;         (parityType == UART_PARITY_EVEN)    ||
700ae058: 9801         	ldr	r0, [sp, #0x4]
700ae05a: 2803         	cmp	r0, #0x3
700ae05c: d008         	beq	0x700ae070 <UART_IsParityTypeValid+0x30> @ imm = #0x10
700ae05e: e7ff         	b	0x700ae060 <UART_IsParityTypeValid+0x20> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED0) ||
700ae060: 9801         	ldr	r0, [sp, #0x4]
700ae062: 2807         	cmp	r0, #0x7
700ae064: d004         	beq	0x700ae070 <UART_IsParityTypeValid+0x30> @ imm = #0x8
700ae066: e7ff         	b	0x700ae068 <UART_IsParityTypeValid+0x28> @ imm = #-0x2
;         (parityType == UART_PARITY_FORCED1)))
700ae068: 9801         	ldr	r0, [sp, #0x4]
;     if(((parityType == UART_PARITY_NONE)    ||
700ae06a: 2805         	cmp	r0, #0x5
700ae06c: d103         	bne	0x700ae076 <UART_IsParityTypeValid+0x36> @ imm = #0x6
700ae06e: e7ff         	b	0x700ae070 <UART_IsParityTypeValid+0x30> @ imm = #-0x2
700ae070: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ae072: 9000         	str	r0, [sp]
;     }
700ae074: e7ff         	b	0x700ae076 <UART_IsParityTypeValid+0x36> @ imm = #-0x2
;     return status;
700ae076: 9800         	ldr	r0, [sp]
700ae078: b002         	add	sp, #0x8
700ae07a: 4770         	bx	lr
700ae07c: 0000         	movs	r0, r0
700ae07e: 0000         	movs	r0, r0

700ae080 <UART_IsTxRxFifoEmpty>:
; {
700ae080: b580         	push	{r7, lr}
700ae082: b084         	sub	sp, #0x10
700ae084: 9003         	str	r0, [sp, #0xc]
700ae086: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ae088: 9002         	str	r0, [sp, #0x8]
;     uint32_t retVal      = FALSE;
700ae08a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_OPERATIONAL_MODE);
700ae08c: 9803         	ldr	r0, [sp, #0xc]
700ae08e: 217f         	movs	r1, #0x7f
700ae090: f7fe fb76    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #-0x1914
700ae094: 9002         	str	r0, [sp, #0x8]
;         (HW_RD_REG32(baseAddr + UART_LSR) &
700ae096: 9803         	ldr	r0, [sp, #0xc]
700ae098: 3014         	adds	r0, #0x14
700ae09a: f001 fd69    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x1ad2
;     if (((UART_LSR_TX_FIFO_E_TX_FIFO_E_VALUE_1 << UART_LSR_TX_FIFO_E_SHIFT) |
700ae09e: 0680         	lsls	r0, r0, #0x1a
700ae0a0: 2800         	cmp	r0, #0x0
700ae0a2: d503         	bpl	0x700ae0ac <UART_IsTxRxFifoEmpty+0x2c> @ imm = #0x6
700ae0a4: e7ff         	b	0x700ae0a6 <UART_IsTxRxFifoEmpty+0x26> @ imm = #-0x2
700ae0a6: 2001         	movs	r0, #0x1
;         retVal = (uint32_t) TRUE;
700ae0a8: 9001         	str	r0, [sp, #0x4]
;     }
700ae0aa: e7ff         	b	0x700ae0ac <UART_IsTxRxFifoEmpty+0x2c> @ imm = #-0x2
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae0ac: 9803         	ldr	r0, [sp, #0xc]
700ae0ae: 300c         	adds	r0, #0xc
700ae0b0: 9902         	ldr	r1, [sp, #0x8]
700ae0b2: f001 fd65    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x1aca
;     return retVal;
700ae0b6: 9801         	ldr	r0, [sp, #0x4]
700ae0b8: b004         	add	sp, #0x10
700ae0ba: bd80         	pop	{r7, pc}
700ae0bc: 0000         	movs	r0, r0
700ae0be: 0000         	movs	r0, r0

700ae0c0 <UART_enhanFuncEnable>:
; {
700ae0c0: b580         	push	{r7, lr}
700ae0c2: b084         	sub	sp, #0x10
700ae0c4: 9003         	str	r0, [sp, #0xc]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ae0c6: 9803         	ldr	r0, [sp, #0xc]
700ae0c8: 21bf         	movs	r1, #0xbf
700ae0ca: f7fe fb59    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #-0x194e
700ae0ce: 9001         	str	r0, [sp, #0x4]
;     enhanFnBitVal = HW_RD_REG32(baseAddr + UART_EFR) & UART_EFR_ENHANCED_EN_MASK;
700ae0d0: 9803         	ldr	r0, [sp, #0xc]
700ae0d2: 3008         	adds	r0, #0x8
700ae0d4: f001 fd4c    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x1a98
700ae0d8: f000 0010    	and	r0, r0, #0x10
700ae0dc: 9002         	str	r0, [sp, #0x8]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700ae0de: 9803         	ldr	r0, [sp, #0xc]
700ae0e0: 3008         	adds	r0, #0x8
700ae0e2: 2110         	movs	r1, #0x10
700ae0e4: 2204         	movs	r2, #0x4
700ae0e6: 2301         	movs	r3, #0x1
700ae0e8: f000 fae2    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #0x5c4
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae0ec: 9803         	ldr	r0, [sp, #0xc]
700ae0ee: 300c         	adds	r0, #0xc
700ae0f0: 9901         	ldr	r1, [sp, #0x4]
700ae0f2: f001 fd45    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x1a8a
;     return enhanFnBitVal;
700ae0f6: 9802         	ldr	r0, [sp, #0x8]
700ae0f8: b004         	add	sp, #0x10
700ae0fa: bd80         	pop	{r7, pc}
700ae0fc: 0000         	movs	r0, r0
700ae0fe: 0000         	movs	r0, r0

700ae100 <UART_lld_dmaDeInit>:
; {
700ae100: b580         	push	{r7, lr}
700ae102: b084         	sub	sp, #0x10
700ae104: 9003         	str	r0, [sp, #0xc]
700ae106: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700ae108: 9002         	str	r0, [sp, #0x8]
;     udmaChCfg    = (UART_UdmaChConfig *)hUart->hUartInit->dmaChCfg;
700ae10a: 9803         	ldr	r0, [sp, #0xc]
700ae10c: 6840         	ldr	r0, [r0, #0x4]
700ae10e: 6cc0         	ldr	r0, [r0, #0x4c]
700ae110: 9001         	str	r0, [sp, #0x4]
;     if (udmaChCfg->isOpen != FALSE)
700ae112: 9801         	ldr	r0, [sp, #0x4]
700ae114: 6b80         	ldr	r0, [r0, #0x38]
700ae116: b170         	cbz	r0, 0x700ae136 <UART_lld_dmaDeInit+0x36> @ imm = #0x1c
700ae118: e7ff         	b	0x700ae11a <UART_lld_dmaDeInit+0x1a> @ imm = #-0x2
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700ae11a: 9901         	ldr	r1, [sp, #0x4]
700ae11c: 6888         	ldr	r0, [r1, #0x8]
;                           udmaChCfg->cqRxEvtHandle);
700ae11e: 6909         	ldr	r1, [r1, #0x10]
;         (void)UART_udmaDeInitCh(udmaChCfg->rxChHandle,
700ae120: f7f8 fc26    	bl	0x700a6970 <UART_udmaDeInitCh> @ imm = #-0x77b4
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700ae124: 9901         	ldr	r1, [sp, #0x4]
700ae126: 6848         	ldr	r0, [r1, #0x4]
;                           udmaChCfg->cqTxEvtHandle);
700ae128: 68c9         	ldr	r1, [r1, #0xc]
;         (void)UART_udmaDeInitCh(udmaChCfg->txChHandle,
700ae12a: f7f8 fc21    	bl	0x700a6970 <UART_udmaDeInitCh> @ imm = #-0x77be
;         udmaChCfg->isOpen = FALSE;
700ae12e: 9901         	ldr	r1, [sp, #0x4]
700ae130: 2000         	movs	r0, #0x0
700ae132: 6388         	str	r0, [r1, #0x38]
;     }
700ae134: e7ff         	b	0x700ae136 <UART_lld_dmaDeInit+0x36> @ imm = #-0x2
;     return status;
700ae136: 9802         	ldr	r0, [sp, #0x8]
700ae138: b004         	add	sp, #0x10
700ae13a: bd80         	pop	{r7, pc}
700ae13c: 0000         	movs	r0, r0
700ae13e: 0000         	movs	r0, r0

700ae140 <prvDeleteTCB>:
; static void prvDeleteTCB(TCB_t *pxTCB) {
700ae140: b580         	push	{r7, lr}
700ae142: b082         	sub	sp, #0x8
700ae144: 9001         	str	r0, [sp, #0x4]
;   portCLEAN_UP_TCB(pxTCB);
700ae146: 9801         	ldr	r0, [sp, #0x4]
;     if (pxTCB->ucStaticallyAllocated ==
700ae148: f890 0081    	ldrb.w	r0, [r0, #0x81]
700ae14c: b940         	cbnz	r0, 0x700ae160 <prvDeleteTCB+0x20> @ imm = #0x10
700ae14e: e7ff         	b	0x700ae150 <prvDeleteTCB+0x10> @ imm = #-0x2
;       vPortFree(pxTCB->pxStack);
700ae150: 9801         	ldr	r0, [sp, #0x4]
700ae152: 6b00         	ldr	r0, [r0, #0x30]
700ae154: f001 f924    	bl	0x700af3a0 <vPortFree>  @ imm = #0x1248
;       vPortFree(pxTCB);
700ae158: 9801         	ldr	r0, [sp, #0x4]
700ae15a: f001 f921    	bl	0x700af3a0 <vPortFree>  @ imm = #0x1242
;     } else if (pxTCB->ucStaticallyAllocated ==
700ae15e: e00b         	b	0x700ae178 <prvDeleteTCB+0x38> @ imm = #0x16
700ae160: 9801         	ldr	r0, [sp, #0x4]
700ae162: f890 0081    	ldrb.w	r0, [r0, #0x81]
700ae166: 2801         	cmp	r0, #0x1
700ae168: d104         	bne	0x700ae174 <prvDeleteTCB+0x34> @ imm = #0x8
700ae16a: e7ff         	b	0x700ae16c <prvDeleteTCB+0x2c> @ imm = #-0x2
;       vPortFree(pxTCB);
700ae16c: 9801         	ldr	r0, [sp, #0x4]
700ae16e: f001 f917    	bl	0x700af3a0 <vPortFree>  @ imm = #0x122e
;     } else {
700ae172: e000         	b	0x700ae176 <prvDeleteTCB+0x36> @ imm = #0x0
700ae174: e7ff         	b	0x700ae176 <prvDeleteTCB+0x36> @ imm = #-0x2
700ae176: e7ff         	b	0x700ae178 <prvDeleteTCB+0x38> @ imm = #-0x2
; }
700ae178: b002         	add	sp, #0x8
700ae17a: bd80         	pop	{r7, pc}
700ae17c: 0000         	movs	r0, r0
700ae17e: 0000         	movs	r0, r0

700ae180 <prvResetNextTaskUnblockTime>:
;   if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
700ae180: f245 20a0    	movw	r0, #0x52a0
700ae184: f2c7 0008    	movt	r0, #0x7008
700ae188: 6800         	ldr	r0, [r0]
700ae18a: 6800         	ldr	r0, [r0]
700ae18c: b940         	cbnz	r0, 0x700ae1a0 <prvResetNextTaskUnblockTime+0x20> @ imm = #0x10
700ae18e: e7ff         	b	0x700ae190 <prvResetNextTaskUnblockTime+0x10> @ imm = #-0x2
;     xNextTaskUnblockTime = portMAX_DELAY;
700ae190: f642 2134    	movw	r1, #0x2a34
700ae194: f2c7 010b    	movt	r1, #0x700b
700ae198: f04f 30ff    	mov.w	r0, #0xffffffff
700ae19c: 6008         	str	r0, [r1]
;   } else {
700ae19e: e00c         	b	0x700ae1ba <prvResetNextTaskUnblockTime+0x3a> @ imm = #0x18
;     xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxDelayedTaskList);
700ae1a0: f245 20a0    	movw	r0, #0x52a0
700ae1a4: f2c7 0008    	movt	r0, #0x7008
700ae1a8: 6800         	ldr	r0, [r0]
700ae1aa: 68c0         	ldr	r0, [r0, #0xc]
700ae1ac: 6800         	ldr	r0, [r0]
700ae1ae: f642 2134    	movw	r1, #0x2a34
700ae1b2: f2c7 010b    	movt	r1, #0x700b
700ae1b6: 6008         	str	r0, [r1]
700ae1b8: e7ff         	b	0x700ae1ba <prvResetNextTaskUnblockTime+0x3a> @ imm = #-0x2
; }
700ae1ba: 4770         	bx	lr
700ae1bc: 0000         	movs	r0, r0
700ae1be: 0000         	movs	r0, r0

700ae1c0 <PMU_enableAllCounters>:
; static void PMU_enableAllCounters(uint32_t numCounters) {
700ae1c0: b580         	push	{r7, lr}
700ae1c2: b082         	sub	sp, #0x8
700ae1c4: 9001         	str	r0, [sp, #0x4]
700ae1c6: 2001         	movs	r0, #0x1
;   CSL_armR5PmuEnableAllCntrs(1);
700ae1c8: f7f3 efd8    	blx	0x700a217c <CSL_armR5PmuEnableAllCntrs> @ imm = #-0xc050
700ae1cc: 2000         	movs	r0, #0x0
;   for (i = 0; i < numCounters; i++) {
700ae1ce: 9000         	str	r0, [sp]
700ae1d0: e7ff         	b	0x700ae1d2 <PMU_enableAllCounters+0x12> @ imm = #-0x2
700ae1d2: 9800         	ldr	r0, [sp]
700ae1d4: 9901         	ldr	r1, [sp, #0x4]
700ae1d6: 4288         	cmp	r0, r1
700ae1d8: d209         	bhs	0x700ae1ee <PMU_enableAllCounters+0x2e> @ imm = #0x12
700ae1da: e7ff         	b	0x700ae1dc <PMU_enableAllCounters+0x1c> @ imm = #-0x2
;     CSL_armR5PmuEnableCntr(i, 1);
700ae1dc: 9800         	ldr	r0, [sp]
700ae1de: 2101         	movs	r1, #0x1
700ae1e0: f7f4 e802    	blx	0x700a21e8 <CSL_armR5PmuEnableCntr> @ imm = #-0xbffc
;   }
700ae1e4: e7ff         	b	0x700ae1e6 <PMU_enableAllCounters+0x26> @ imm = #-0x2
;   for (i = 0; i < numCounters; i++) {
700ae1e6: 9800         	ldr	r0, [sp]
700ae1e8: 3001         	adds	r0, #0x1
700ae1ea: 9000         	str	r0, [sp]
700ae1ec: e7f1         	b	0x700ae1d2 <PMU_enableAllCounters+0x12> @ imm = #-0x1e
700ae1ee: 201f         	movs	r0, #0x1f
700ae1f0: 2101         	movs	r1, #0x1
;   CSL_armR5PmuEnableCntr(CSL_ARM_R5_PMU_CYCLE_COUNTER_NUM, 1);
700ae1f2: f7f3 effa    	blx	0x700a21e8 <CSL_armR5PmuEnableCntr> @ imm = #-0xc00c
; }
700ae1f6: b002         	add	sp, #0x8
700ae1f8: bd80         	pop	{r7, pc}
700ae1fa: 0000         	movs	r0, r0
700ae1fc: 0000         	movs	r0, r0
700ae1fe: 0000         	movs	r0, r0

700ae200 <_atoi>:
; {
700ae200: b580         	push	{r7, lr}
700ae202: b082         	sub	sp, #0x8
700ae204: 9001         	str	r0, [sp, #0x4]
700ae206: 2000         	movs	r0, #0x0
;   unsigned int i = 0U;
700ae208: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700ae20a: e7ff         	b	0x700ae20c <_atoi+0xc>  @ imm = #-0x2
700ae20c: 9801         	ldr	r0, [sp, #0x4]
700ae20e: 6800         	ldr	r0, [r0]
700ae210: 7800         	ldrb	r0, [r0]
700ae212: f000 fbdd    	bl	0x700ae9d0 <_is_digit>  @ imm = #0x7ba
700ae216: b168         	cbz	r0, 0x700ae234 <_atoi+0x34> @ imm = #0x1a
700ae218: e7ff         	b	0x700ae21a <_atoi+0x1a> @ imm = #-0x2
;     i = i * 10U + (unsigned int)(*((*str)++) - '0');
700ae21a: 9800         	ldr	r0, [sp]
700ae21c: eb00 0180    	add.w	r1, r0, r0, lsl #2
700ae220: 9b01         	ldr	r3, [sp, #0x4]
700ae222: 6818         	ldr	r0, [r3]
700ae224: 1c42         	adds	r2, r0, #0x1
700ae226: 601a         	str	r2, [r3]
700ae228: 7800         	ldrb	r0, [r0]
700ae22a: eb00 0041    	add.w	r0, r0, r1, lsl #1
700ae22e: 3830         	subs	r0, #0x30
700ae230: 9000         	str	r0, [sp]
;   while (_is_digit(**str)) {
700ae232: e7eb         	b	0x700ae20c <_atoi+0xc>  @ imm = #-0x2a
;   return i;
700ae234: 9800         	ldr	r0, [sp]
700ae236: b002         	add	sp, #0x8
700ae238: bd80         	pop	{r7, pc}
700ae23a: 0000         	movs	r0, r0
700ae23c: 0000         	movs	r0, r0
700ae23e: 0000         	movs	r0, r0

700ae240 <snprintf_>:
; {
700ae240: b081         	sub	sp, #0x4
700ae242: b580         	push	{r7, lr}
700ae244: b087         	sub	sp, #0x1c
700ae246: 9309         	str	r3, [sp, #0x24]
700ae248: 9006         	str	r0, [sp, #0x18]
700ae24a: 9105         	str	r1, [sp, #0x14]
700ae24c: 9204         	str	r2, [sp, #0x10]
700ae24e: a809         	add	r0, sp, #0x24
;   va_start(va, format);
700ae250: 9003         	str	r0, [sp, #0xc]
;   const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
700ae252: 9906         	ldr	r1, [sp, #0x18]
700ae254: 9a05         	ldr	r2, [sp, #0x14]
700ae256: 9b04         	ldr	r3, [sp, #0x10]
700ae258: 9803         	ldr	r0, [sp, #0xc]
700ae25a: 46ec         	mov	r12, sp
700ae25c: f8cc 0000    	str.w	r0, [r12]
700ae260: f24f 0001    	movw	r0, #0xf001
700ae264: f2c7 000a    	movt	r0, #0x700a
700ae268: f7eb ff3a    	bl	0x7009a0e0 <_vsnprintf> @ imm = #-0x1418c
700ae26c: 9002         	str	r0, [sp, #0x8]
;   return ret;
700ae26e: 9802         	ldr	r0, [sp, #0x8]
700ae270: b007         	add	sp, #0x1c
700ae272: e8bd 4080    	pop.w	{r7, lr}
700ae276: b001         	add	sp, #0x4
700ae278: 4770         	bx	lr
700ae27a: 0000         	movs	r0, r0
700ae27c: 0000         	movs	r0, r0
700ae27e: 0000         	movs	r0, r0

700ae280 <vListInsertEnd>:
; {
700ae280: b083         	sub	sp, #0xc
700ae282: 9002         	str	r0, [sp, #0x8]
700ae284: 9101         	str	r1, [sp, #0x4]
;     ListItem_t * const pxIndex = pxList->pxIndex;
700ae286: 9802         	ldr	r0, [sp, #0x8]
700ae288: 6840         	ldr	r0, [r0, #0x4]
700ae28a: 9000         	str	r0, [sp]
;     pxNewListItem->pxNext = pxIndex;
700ae28c: 9800         	ldr	r0, [sp]
700ae28e: 9901         	ldr	r1, [sp, #0x4]
700ae290: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxPrevious = pxIndex->pxPrevious;
700ae292: 9800         	ldr	r0, [sp]
700ae294: 6880         	ldr	r0, [r0, #0x8]
700ae296: 9901         	ldr	r1, [sp, #0x4]
700ae298: 6088         	str	r0, [r1, #0x8]
;     pxIndex->pxPrevious->pxNext = pxNewListItem;
700ae29a: 9801         	ldr	r0, [sp, #0x4]
700ae29c: 9900         	ldr	r1, [sp]
700ae29e: 6889         	ldr	r1, [r1, #0x8]
700ae2a0: 6048         	str	r0, [r1, #0x4]
;     pxIndex->pxPrevious = pxNewListItem;
700ae2a2: 9801         	ldr	r0, [sp, #0x4]
700ae2a4: 9900         	ldr	r1, [sp]
700ae2a6: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxContainer = pxList;
700ae2a8: 9802         	ldr	r0, [sp, #0x8]
700ae2aa: 9901         	ldr	r1, [sp, #0x4]
700ae2ac: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
700ae2ae: 9902         	ldr	r1, [sp, #0x8]
700ae2b0: 6808         	ldr	r0, [r1]
700ae2b2: 3001         	adds	r0, #0x1
700ae2b4: 6008         	str	r0, [r1]
; }
700ae2b6: b003         	add	sp, #0xc
700ae2b8: 4770         	bx	lr
700ae2ba: 0000         	movs	r0, r0
700ae2bc: 0000         	movs	r0, r0
700ae2be: 0000         	movs	r0, r0

700ae2c0 <CSL_REG32_FINS_RAW>:
; {
700ae2c0: b580         	push	{r7, lr}
700ae2c2: b086         	sub	sp, #0x18
700ae2c4: 9005         	str	r0, [sp, #0x14]
700ae2c6: 9104         	str	r1, [sp, #0x10]
700ae2c8: 9203         	str	r2, [sp, #0xc]
700ae2ca: 9302         	str	r3, [sp, #0x8]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700ae2cc: 9805         	ldr	r0, [sp, #0x14]
700ae2ce: f001 fc97    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0x192e
700ae2d2: 9001         	str	r0, [sp, #0x4]
;     regVal = (regVal & ~(mask));
700ae2d4: 9801         	ldr	r0, [sp, #0x4]
700ae2d6: 9904         	ldr	r1, [sp, #0x10]
700ae2d8: 4388         	bics	r0, r1
700ae2da: 9001         	str	r0, [sp, #0x4]
;     regVal |= (v << shift) & mask;
700ae2dc: 9802         	ldr	r0, [sp, #0x8]
700ae2de: 9903         	ldr	r1, [sp, #0xc]
700ae2e0: 4088         	lsls	r0, r1
700ae2e2: 9904         	ldr	r1, [sp, #0x10]
700ae2e4: 4001         	ands	r1, r0
700ae2e6: 9801         	ldr	r0, [sp, #0x4]
700ae2e8: 4308         	orrs	r0, r1
700ae2ea: 9001         	str	r0, [sp, #0x4]
;     CSL_REG32_WR_RAW(p, regVal);
700ae2ec: 9805         	ldr	r0, [sp, #0x14]
700ae2ee: 9901         	ldr	r1, [sp, #0x4]
700ae2f0: f7ed ffce    	bl	0x7009c290 <CSL_REG32_WR_RAW> @ imm = #-0x12064
;     return;
700ae2f4: b006         	add	sp, #0x18
700ae2f6: bd80         	pop	{r7, pc}
		...

700ae300 <SOC_getCoreName>:
; {
700ae300: b082         	sub	sp, #0x8
700ae302: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     if(coreId < CSL_CORE_ID_MAX)
700ae306: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae30a: 2806         	cmp	r0, #0x6
700ae30c: d80a         	bhi	0x700ae324 <SOC_getCoreName+0x24> @ imm = #0x14
700ae30e: e7ff         	b	0x700ae310 <SOC_getCoreName+0x10> @ imm = #-0x2
;         name = coreIdNames[coreId];
700ae310: f8bd 1006    	ldrh.w	r1, [sp, #0x6]
700ae314: f642 007c    	movw	r0, #0x287c
700ae318: f2c7 000b    	movt	r0, #0x700b
700ae31c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700ae320: 9000         	str	r0, [sp]
;     }
700ae322: e006         	b	0x700ae332 <SOC_getCoreName+0x32> @ imm = #0xc
;         name = coreIdNames[CSL_CORE_ID_MAX];
700ae324: f642 007c    	movw	r0, #0x287c
700ae328: f2c7 000b    	movt	r0, #0x700b
700ae32c: 69c0         	ldr	r0, [r0, #0x1c]
700ae32e: 9000         	str	r0, [sp]
700ae330: e7ff         	b	0x700ae332 <SOC_getCoreName+0x32> @ imm = #-0x2
;     return name;
700ae332: 9800         	ldr	r0, [sp]
700ae334: b002         	add	sp, #0x8
700ae336: 4770         	bx	lr
		...

700ae340 <Sciclient_secProxyFlush>:
; {
700ae340: b580         	push	{r7, lr}
700ae342: b082         	sub	sp, #0x8
700ae344: 9001         	str	r0, [sp, #0x4]
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ae346: e7ff         	b	0x700ae348 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2
700ae348: 9801         	ldr	r0, [sp, #0x4]
700ae34a: f001 f9b9    	bl	0x700af6c0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x1372
700ae34e: f001 fc6f    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0x18de
700ae352: 0600         	lsls	r0, r0, #0x18
700ae354: b170         	cbz	r0, 0x700ae374 <Sciclient_secProxyFlush+0x34> @ imm = #0x1c
700ae356: e7ff         	b	0x700ae358 <Sciclient_secProxyFlush+0x18> @ imm = #-0x2
;         (void) Sciclient_secProxyReadThread32(thread,
700ae358: 9801         	ldr	r0, [sp, #0x4]
;                         (uint8_t)((gSciclientHandle.maxMsgSizeBytes/4U)-1U));
700ae35a: f642 1148    	movw	r1, #0x2948
700ae35e: f2c7 010b    	movt	r1, #0x700b
700ae362: 694a         	ldr	r2, [r1, #0x14]
700ae364: f04f 31ff    	mov.w	r1, #0xffffffff
700ae368: eb01 0192    	add.w	r1, r1, r2, lsr #2
;         (void) Sciclient_secProxyReadThread32(thread,
700ae36c: b2c9         	uxtb	r1, r1
700ae36e: f000 faff    	bl	0x700ae970 <Sciclient_secProxyReadThread32> @ imm = #0x5fe
;     while ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700ae372: e7e9         	b	0x700ae348 <Sciclient_secProxyFlush+0x8> @ imm = #-0x2e
;     return ;
700ae374: b002         	add	sp, #0x8
700ae376: bd80         	pop	{r7, pc}
		...

700ae380 <UART_writeDataPolling>:
; {
700ae380: b580         	push	{r7, lr}
700ae382: b082         	sub	sp, #0x8
700ae384: 9001         	str	r0, [sp, #0x4]
700ae386: 2000         	movs	r0, #0x0
;     uint32_t numBytesWritten = 0U;
700ae388: 9000         	str	r0, [sp]
;     numBytesWritten = UART_fifoWrite(hUart,
700ae38a: 9801         	ldr	r0, [sp, #0x4]
;                                      (const uint8_t *) hUart->writeBuf,
700ae38c: 6881         	ldr	r1, [r0, #0x8]
;                                      hUart->writeSizeRemaining);
700ae38e: 6902         	ldr	r2, [r0, #0x10]
;     numBytesWritten = UART_fifoWrite(hUart,
700ae390: f7f9 fb56    	bl	0x700a7a40 <UART_fifoWrite> @ imm = #-0x6954
700ae394: 9000         	str	r0, [sp]
;     hUart->writeSizeRemaining -= numBytesWritten;
700ae396: 9a00         	ldr	r2, [sp]
700ae398: 9901         	ldr	r1, [sp, #0x4]
700ae39a: 6908         	ldr	r0, [r1, #0x10]
700ae39c: 1a80         	subs	r0, r0, r2
700ae39e: 6108         	str	r0, [r1, #0x10]
;     hUart->writeBuf           = (const void *)((uint8_t *)hUart->writeBuf + numBytesWritten);
700ae3a0: 9901         	ldr	r1, [sp, #0x4]
700ae3a2: 6888         	ldr	r0, [r1, #0x8]
700ae3a4: 9a00         	ldr	r2, [sp]
700ae3a6: 4410         	add	r0, r2
700ae3a8: 6088         	str	r0, [r1, #0x8]
;     hUart->writeCount         += numBytesWritten;
700ae3aa: 9a00         	ldr	r2, [sp]
700ae3ac: 9901         	ldr	r1, [sp, #0x4]
700ae3ae: 68c8         	ldr	r0, [r1, #0xc]
700ae3b0: 4410         	add	r0, r2
700ae3b2: 60c8         	str	r0, [r1, #0xc]
;     return;
700ae3b4: b002         	add	sp, #0x8
700ae3b6: bd80         	pop	{r7, pc}
		...

700ae3c0 <xTaskGetSchedulerState>:
; BaseType_t xTaskGetSchedulerState(void) {
700ae3c0: b081         	sub	sp, #0x4
;   if (xSchedulerRunning == pdFALSE) {
700ae3c2: f642 2040    	movw	r0, #0x2a40
700ae3c6: f2c7 000b    	movt	r0, #0x700b
700ae3ca: 6800         	ldr	r0, [r0]
700ae3cc: b918         	cbnz	r0, 0x700ae3d6 <xTaskGetSchedulerState+0x16> @ imm = #0x6
700ae3ce: e7ff         	b	0x700ae3d0 <xTaskGetSchedulerState+0x10> @ imm = #-0x2
700ae3d0: 2001         	movs	r0, #0x1
;     xReturn = taskSCHEDULER_NOT_STARTED;
700ae3d2: 9000         	str	r0, [sp]
;   } else {
700ae3d4: e00d         	b	0x700ae3f2 <xTaskGetSchedulerState+0x32> @ imm = #0x1a
;     if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
700ae3d6: f642 2024    	movw	r0, #0x2a24
700ae3da: f2c7 000b    	movt	r0, #0x700b
700ae3de: 6800         	ldr	r0, [r0]
700ae3e0: b918         	cbnz	r0, 0x700ae3ea <xTaskGetSchedulerState+0x2a> @ imm = #0x6
700ae3e2: e7ff         	b	0x700ae3e4 <xTaskGetSchedulerState+0x24> @ imm = #-0x2
700ae3e4: 2002         	movs	r0, #0x2
;       xReturn = taskSCHEDULER_RUNNING;
700ae3e6: 9000         	str	r0, [sp]
;     } else {
700ae3e8: e002         	b	0x700ae3f0 <xTaskGetSchedulerState+0x30> @ imm = #0x4
700ae3ea: 2000         	movs	r0, #0x0
;       xReturn = taskSCHEDULER_SUSPENDED;
700ae3ec: 9000         	str	r0, [sp]
700ae3ee: e7ff         	b	0x700ae3f0 <xTaskGetSchedulerState+0x30> @ imm = #-0x2
700ae3f0: e7ff         	b	0x700ae3f2 <xTaskGetSchedulerState+0x32> @ imm = #-0x2
;   return xReturn;
700ae3f2: 9800         	ldr	r0, [sp]
700ae3f4: b001         	add	sp, #0x4
700ae3f6: 4770         	bx	lr
		...

700ae400 <tm_thread_create>:
; {
700ae400: b580         	push	{r7, lr}
700ae402: b082         	sub	sp, #0x8
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae404: f245 13c8    	movw	r3, #0x51c8
;    int new_priority = configMAX_PRIORITIES - priority + 1;
700ae408: f1c1 0c21    	rsb.w	r12, r1, #0x21
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae40c: f2c7 0308    	movt	r3, #0x7008
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ae410: f641 7182    	movw	r1, #0x1f82
700ae414: f2c7 010b    	movt	r1, #0x700b
;                         /*priority*/ new_priority, &tm_thread_array[thread_id]);
700ae418: eb03 0e80    	add.w	lr, r3, r0, lsl #2
;    status = xTaskCreate((TaskFunction_t) entry_function, "Thread-Metric test", configMINIMAL_STACK_SIZE, NULL,
700ae41c: 4610         	mov	r0, r2
700ae41e: f44f 6280    	mov.w	r2, #0x400
700ae422: 2300         	movs	r3, #0x0
700ae424: e9cd ce00    	strd	r12, lr, [sp]
700ae428: f7fb f862    	bl	0x700a94f0 <xTaskCreate> @ imm = #-0x4f3c
;    if (status != pdPASS)
700ae42c: 3801         	subs	r0, #0x1
700ae42e: bf18         	it	ne
700ae430: 2001         	movne	r0, #0x1
; }
700ae432: b002         	add	sp, #0x8
700ae434: bd80         	pop	{r7, pc}
		...
700ae43e: 0000         	movs	r0, r0

700ae440 <vTaskDelay>:
; void vTaskDelay(const TickType_t xTicksToDelay) {
700ae440: b580         	push	{r7, lr}
700ae442: b082         	sub	sp, #0x8
700ae444: 9001         	str	r0, [sp, #0x4]
700ae446: 2000         	movs	r0, #0x0
;   BaseType_t xAlreadyYielded = pdFALSE;
700ae448: 9000         	str	r0, [sp]
;   if (xTicksToDelay > (TickType_t)0U) {
700ae44a: 9801         	ldr	r0, [sp, #0x4]
700ae44c: b150         	cbz	r0, 0x700ae464 <vTaskDelay+0x24> @ imm = #0x14
700ae44e: e7ff         	b	0x700ae450 <vTaskDelay+0x10> @ imm = #-0x2
;     vTaskSuspendAll();
700ae450: f001 fbb6    	bl	0x700afbc0 <vTaskSuspendAll> @ imm = #0x176c
;       prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
700ae454: 9801         	ldr	r0, [sp, #0x4]
700ae456: 2100         	movs	r1, #0x0
700ae458: f7f8 f9aa    	bl	0x700a67b0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x7cac
;     xAlreadyYielded = xTaskResumeAll();
700ae45c: f7f3 ff18    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0xc1d0
700ae460: 9000         	str	r0, [sp]
;   } else {
700ae462: e000         	b	0x700ae466 <vTaskDelay+0x26> @ imm = #0x0
700ae464: e7ff         	b	0x700ae466 <vTaskDelay+0x26> @ imm = #-0x2
;   if (xAlreadyYielded == pdFALSE) {
700ae466: 9800         	ldr	r0, [sp]
700ae468: b910         	cbnz	r0, 0x700ae470 <vTaskDelay+0x30> @ imm = #0x4
700ae46a: e7ff         	b	0x700ae46c <vTaskDelay+0x2c> @ imm = #-0x2
;     portYIELD_WITHIN_API();
700ae46c: df00         	svc	#0x0
;   } else {
700ae46e: e000         	b	0x700ae472 <vTaskDelay+0x32> @ imm = #0x0
700ae470: e7ff         	b	0x700ae472 <vTaskDelay+0x32> @ imm = #-0x2
; }
700ae472: b002         	add	sp, #0x8
700ae474: bd80         	pop	{r7, pc}
		...
700ae47e: 0000         	movs	r0, r0

700ae480 <vTaskPlaceOnEventListRestricted>:
;                                      const BaseType_t xWaitIndefinitely) {
700ae480: b580         	push	{r7, lr}
700ae482: b084         	sub	sp, #0x10
700ae484: 9003         	str	r0, [sp, #0xc]
700ae486: 9102         	str	r1, [sp, #0x8]
700ae488: 9201         	str	r2, [sp, #0x4]
;   vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
700ae48a: 9803         	ldr	r0, [sp, #0xc]
700ae48c: f642 11fc    	movw	r1, #0x29fc
700ae490: f2c7 010b    	movt	r1, #0x700b
700ae494: 6809         	ldr	r1, [r1]
700ae496: 3118         	adds	r1, #0x18
700ae498: f7ff fef2    	bl	0x700ae280 <vListInsertEnd> @ imm = #-0x21c
;   if (xWaitIndefinitely != pdFALSE) {
700ae49c: 9801         	ldr	r0, [sp, #0x4]
700ae49e: b120         	cbz	r0, 0x700ae4aa <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #0x8
700ae4a0: e7ff         	b	0x700ae4a2 <vTaskPlaceOnEventListRestricted+0x22> @ imm = #-0x2
700ae4a2: f04f 30ff    	mov.w	r0, #0xffffffff
;     xTicksToWait = portMAX_DELAY;
700ae4a6: 9002         	str	r0, [sp, #0x8]
;   }
700ae4a8: e7ff         	b	0x700ae4aa <vTaskPlaceOnEventListRestricted+0x2a> @ imm = #-0x2
;   prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
700ae4aa: 9802         	ldr	r0, [sp, #0x8]
700ae4ac: 9901         	ldr	r1, [sp, #0x4]
700ae4ae: f7f8 f97f    	bl	0x700a67b0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x7d02
; }
700ae4b2: b004         	add	sp, #0x10
700ae4b4: bd80         	pop	{r7, pc}
		...
700ae4be: 0000         	movs	r0, r0

700ae4c0 <CSL_pktdmaTeardownRxChan>:
; {
700ae4c0: b580         	push	{r7, lr}
700ae4c2: b084         	sub	sp, #0x10
700ae4c4: 9003         	str	r0, [sp, #0xc]
700ae4c6: 9102         	str	r1, [sp, #0x8]
700ae4c8: f88d 2007    	strb.w	r2, [sp, #0x7]
700ae4cc: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_RX, bForce, bWait );
700ae4d0: 9803         	ldr	r0, [sp, #0xc]
700ae4d2: 9902         	ldr	r1, [sp, #0x8]
700ae4d4: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ae4d8: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ae4dc: f003 0301    	and	r3, r3, #0x1
700ae4e0: 46ec         	mov	r12, sp
700ae4e2: f8cc 3000    	str.w	r3, [r12]
700ae4e6: f002 0301    	and	r3, r2, #0x1
700ae4ea: 2201         	movs	r2, #0x1
700ae4ec: f7f7 f818    	bl	0x700a5520 <CSL_pktdmaTeardownChan> @ imm = #-0x8fd0
700ae4f0: b004         	add	sp, #0x10
700ae4f2: bd80         	pop	{r7, pc}
		...

700ae500 <CSL_pktdmaTeardownTxChan>:
; {
700ae500: b580         	push	{r7, lr}
700ae502: b084         	sub	sp, #0x10
700ae504: 9003         	str	r0, [sp, #0xc]
700ae506: 9102         	str	r1, [sp, #0x8]
700ae508: f88d 2007    	strb.w	r2, [sp, #0x7]
700ae50c: f88d 3006    	strb.w	r3, [sp, #0x6]
;     return CSL_pktdmaTeardownChan( pCfg, chanIdx, CSL_PKTDMA_CHAN_DIR_TX, bForce, bWait );
700ae510: 9803         	ldr	r0, [sp, #0xc]
700ae512: 9902         	ldr	r1, [sp, #0x8]
700ae514: f89d 2007    	ldrb.w	r2, [sp, #0x7]
700ae518: f89d 3006    	ldrb.w	r3, [sp, #0x6]
700ae51c: f003 0301    	and	r3, r3, #0x1
700ae520: 46ec         	mov	r12, sp
700ae522: f8cc 3000    	str.w	r3, [r12]
700ae526: f002 0301    	and	r3, r2, #0x1
700ae52a: 2200         	movs	r2, #0x0
700ae52c: f7f6 fff8    	bl	0x700a5520 <CSL_pktdmaTeardownChan> @ imm = #-0x9010
700ae530: b004         	add	sp, #0x10
700ae532: bd80         	pop	{r7, pc}
		...

700ae540 <TimerP_Params_init>:
; {
700ae540: b081         	sub	sp, #0x4
700ae542: 9000         	str	r0, [sp]
;     params->inputPreScaler = 1;
700ae544: 9800         	ldr	r0, [sp]
700ae546: 2101         	movs	r1, #0x1
700ae548: 6001         	str	r1, [r0]
;     params->inputClkHz = 25*1000000;
700ae54a: 9a00         	ldr	r2, [sp]
700ae54c: f647 0040    	movw	r0, #0x7840
700ae550: f2c0 107d    	movt	r0, #0x17d
700ae554: 6050         	str	r0, [r2, #0x4]
;     params->periodInUsec = 1000;
700ae556: 9a00         	ldr	r2, [sp]
700ae558: f44f 707a    	mov.w	r0, #0x3e8
700ae55c: 6090         	str	r0, [r2, #0x8]
;     params->periodInNsec = 0; /* periodInUsec is used when periodInNsec is 0 */
700ae55e: 9a00         	ldr	r2, [sp]
700ae560: 2000         	movs	r0, #0x0
700ae562: 60d0         	str	r0, [r2, #0xc]
;     params->oneshotMode = 0;
700ae564: 9a00         	ldr	r2, [sp]
700ae566: 6110         	str	r0, [r2, #0x10]
;     params->enableOverflowInt = 1;
700ae568: 9a00         	ldr	r2, [sp]
700ae56a: 6151         	str	r1, [r2, #0x14]
;     params->enableDmaTrigger = 0; /* NOT USED */
700ae56c: 9900         	ldr	r1, [sp]
700ae56e: 6188         	str	r0, [r1, #0x18]
; }
700ae570: b001         	add	sp, #0x4
700ae572: 4770         	bx	lr
		...

700ae580 <UART_IsDataLengthValid>:
; {
700ae580: b082         	sub	sp, #0x8
700ae582: 9001         	str	r0, [sp, #0x4]
700ae584: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700ae588: 9000         	str	r0, [sp]
;     if(((dataLength == UART_LEN_5) ||
700ae58a: 9801         	ldr	r0, [sp, #0x4]
700ae58c: b160         	cbz	r0, 0x700ae5a8 <UART_IsDataLengthValid+0x28> @ imm = #0x18
700ae58e: e7ff         	b	0x700ae590 <UART_IsDataLengthValid+0x10> @ imm = #-0x2
;         (dataLength == UART_LEN_6) ||
700ae590: 9801         	ldr	r0, [sp, #0x4]
700ae592: 2801         	cmp	r0, #0x1
700ae594: d008         	beq	0x700ae5a8 <UART_IsDataLengthValid+0x28> @ imm = #0x10
700ae596: e7ff         	b	0x700ae598 <UART_IsDataLengthValid+0x18> @ imm = #-0x2
;         (dataLength == UART_LEN_7) ||
700ae598: 9801         	ldr	r0, [sp, #0x4]
700ae59a: 2802         	cmp	r0, #0x2
700ae59c: d004         	beq	0x700ae5a8 <UART_IsDataLengthValid+0x28> @ imm = #0x8
700ae59e: e7ff         	b	0x700ae5a0 <UART_IsDataLengthValid+0x20> @ imm = #-0x2
;         (dataLength == UART_LEN_8)))
700ae5a0: 9801         	ldr	r0, [sp, #0x4]
;     if(((dataLength == UART_LEN_5) ||
700ae5a2: 2803         	cmp	r0, #0x3
700ae5a4: d103         	bne	0x700ae5ae <UART_IsDataLengthValid+0x2e> @ imm = #0x6
700ae5a6: e7ff         	b	0x700ae5a8 <UART_IsDataLengthValid+0x28> @ imm = #-0x2
700ae5a8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700ae5aa: 9000         	str	r0, [sp]
;     }
700ae5ac: e7ff         	b	0x700ae5ae <UART_IsDataLengthValid+0x2e> @ imm = #-0x2
;     return status;
700ae5ae: 9800         	ldr	r0, [sp]
700ae5b0: b002         	add	sp, #0x8
700ae5b2: 4770         	bx	lr
		...

700ae5c0 <UART_checkTransaction>:
; {
700ae5c0: b082         	sub	sp, #0x8
700ae5c2: 9001         	str	r0, [sp, #0x4]
700ae5c4: 2000         	movs	r0, #0x0
;     int32_t     status = UART_TRANSFER_STATUS_SUCCESS;
700ae5c6: 9000         	str	r0, [sp]
;     if(0U == trans->count)
700ae5c8: 9801         	ldr	r0, [sp, #0x4]
700ae5ca: 6840         	ldr	r0, [r0, #0x4]
700ae5cc: b938         	cbnz	r0, 0x700ae5de <UART_checkTransaction+0x1e> @ imm = #0xe
700ae5ce: e7ff         	b	0x700ae5d0 <UART_checkTransaction+0x10> @ imm = #-0x2
;         trans->status = UART_TRANSFER_STATUS_ERROR_OTH;
700ae5d0: 9901         	ldr	r1, [sp, #0x4]
700ae5d2: 200a         	movs	r0, #0xa
700ae5d4: 60c8         	str	r0, [r1, #0xc]
700ae5d6: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ae5da: 9000         	str	r0, [sp]
;     }
700ae5dc: e7ff         	b	0x700ae5de <UART_checkTransaction+0x1e> @ imm = #-0x2
;     if(NULL == trans->buf)
700ae5de: 9801         	ldr	r0, [sp, #0x4]
700ae5e0: 6800         	ldr	r0, [r0]
700ae5e2: b920         	cbnz	r0, 0x700ae5ee <UART_checkTransaction+0x2e> @ imm = #0x8
700ae5e4: e7ff         	b	0x700ae5e6 <UART_checkTransaction+0x26> @ imm = #-0x2
700ae5e6: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700ae5ea: 9000         	str	r0, [sp]
;     }
700ae5ec: e7ff         	b	0x700ae5ee <UART_checkTransaction+0x2e> @ imm = #-0x2
;     return (status);
700ae5ee: 9800         	ldr	r0, [sp]
700ae5f0: b002         	add	sp, #0x8
700ae5f2: 4770         	bx	lr

700ae5f4 <free_list_remove>:
700ae5f4: e59f3028     	ldr	r3, [pc, #0x28]         @ 0x700ae624 <free_list_remove+0x30>
700ae5f8: e5932000     	ldr	r2, [r3]
700ae5fc: e1a01003     	mov	r1, r3
700ae600: e3520000     	cmp	r2, #0
700ae604: 12823008     	addne	r3, r2, #8
700ae608: 11520000     	cmpne	r2, r0
700ae60c: 1afffff9     	bne	0x700ae5f8 <free_list_remove+0x4> @ imm = #-0x1c
700ae610: e3520000     	cmp	r2, #0
700ae614: 012fff1e     	bxeq	lr
700ae618: e5900008     	ldr	r0, [r0, #0x8]
700ae61c: e5810000     	str	r0, [r1]
700ae620: e12fff1e     	bx	lr
700ae624: ac 52 08 70  	.word	0x700852ac
700ae628: 00 00 00 00  	.word	0x00000000
700ae62c: 00 00 00 00  	.word	0x00000000

700ae630 <vPortTimerTickHandler>:
; void vPortTimerTickHandler() {
700ae630: b580         	push	{r7, lr}
;   portENTER_CRITICAL();
700ae632: f000 f89d    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #0x13a
;   if (ulPortSchedularRunning == pdTRUE) {
700ae636: f642 2010    	movw	r0, #0x2a10
700ae63a: f2c7 000b    	movt	r0, #0x700b
700ae63e: 6800         	ldr	r0, [r0]
700ae640: 2801         	cmp	r0, #0x1
700ae642: d10c         	bne	0x700ae65e <vPortTimerTickHandler+0x2e> @ imm = #0x18
700ae644: e7ff         	b	0x700ae646 <vPortTimerTickHandler+0x16> @ imm = #-0x2
;     if (xTaskIncrementTick() != pdFALSE) {
700ae646: f7f2 ffd3    	bl	0x700a15f0 <xTaskIncrementTick> @ imm = #-0xd05a
700ae64a: b138         	cbz	r0, 0x700ae65c <vPortTimerTickHandler+0x2c> @ imm = #0xe
700ae64c: e7ff         	b	0x700ae64e <vPortTimerTickHandler+0x1e> @ imm = #-0x2
;       ulPortYieldRequired = pdTRUE;
700ae64e: f642 2118    	movw	r1, #0x2a18
700ae652: f2c7 010b    	movt	r1, #0x700b
700ae656: 2001         	movs	r0, #0x1
700ae658: 6008         	str	r0, [r1]
;     }
700ae65a: e7ff         	b	0x700ae65c <vPortTimerTickHandler+0x2c> @ imm = #-0x2
;   }
700ae65c: e7ff         	b	0x700ae65e <vPortTimerTickHandler+0x2e> @ imm = #-0x2
;   portEXIT_CRITICAL();
700ae65e: f7ff f947    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #-0xd72
; }
700ae662: bd80         	pop	{r7, pc}
		...

700ae670 <ClockP_timerTickIsr>:
; {
700ae670: b580         	push	{r7, lr}
700ae672: b082         	sub	sp, #0x8
700ae674: 9001         	str	r0, [sp, #0x4]
;     gClockCtrl.ticks++;
700ae676: f245 1190    	movw	r1, #0x5190
700ae67a: f2c7 0108    	movt	r1, #0x7008
700ae67e: 680a         	ldr	r2, [r1]
700ae680: 6848         	ldr	r0, [r1, #0x4]
700ae682: 3201         	adds	r2, #0x1
700ae684: f140 0000    	adc	r0, r0, #0x0
700ae688: 600a         	str	r2, [r1]
700ae68a: 6048         	str	r0, [r1, #0x4]
;     vPortTimerTickHandler();
700ae68c: f7ff ffd0    	bl	0x700ae630 <vPortTimerTickHandler> @ imm = #-0x60
;     ClockP_timerClearOverflowInt(gClockConfig.timerBaseAddr);
700ae690: f642 1000    	movw	r0, #0x2900
700ae694: f2c7 000b    	movt	r0, #0x700b
700ae698: 6800         	ldr	r0, [r0]
700ae69a: f001 fa61    	bl	0x700afb60 <ClockP_timerClearOverflowInt> @ imm = #0x14c2
; }
700ae69e: b002         	add	sp, #0x8
700ae6a0: bd80         	pop	{r7, pc}
		...
700ae6ae: 0000         	movs	r0, r0

700ae6b0 <HW_WR_FIELD32_RAW>:
; {
700ae6b0: b085         	sub	sp, #0x14
700ae6b2: 9004         	str	r0, [sp, #0x10]
700ae6b4: 9103         	str	r1, [sp, #0xc]
700ae6b6: 9202         	str	r2, [sp, #0x8]
700ae6b8: 9301         	str	r3, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700ae6ba: 9804         	ldr	r0, [sp, #0x10]
700ae6bc: 6800         	ldr	r0, [r0]
700ae6be: 9000         	str	r0, [sp]
;     regVal &= (~mask);
700ae6c0: 9903         	ldr	r1, [sp, #0xc]
700ae6c2: 9800         	ldr	r0, [sp]
700ae6c4: 4388         	bics	r0, r1
700ae6c6: 9000         	str	r0, [sp]
;     regVal |= (value << shift) & mask;
700ae6c8: 9801         	ldr	r0, [sp, #0x4]
700ae6ca: 9902         	ldr	r1, [sp, #0x8]
700ae6cc: 4088         	lsls	r0, r1
700ae6ce: 9903         	ldr	r1, [sp, #0xc]
700ae6d0: 4001         	ands	r1, r0
700ae6d2: 9800         	ldr	r0, [sp]
700ae6d4: 4308         	orrs	r0, r1
700ae6d6: 9000         	str	r0, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = regVal;
700ae6d8: 9800         	ldr	r0, [sp]
700ae6da: 9904         	ldr	r1, [sp, #0x10]
700ae6dc: 6008         	str	r0, [r1]
;     return;
700ae6de: b005         	add	sp, #0x14
700ae6e0: 4770         	bx	lr
		...
700ae6ee: 0000         	movs	r0, r0

700ae6f0 <UART_enhanFuncBitValRestore>:
; {
700ae6f0: b580         	push	{r7, lr}
700ae6f2: b084         	sub	sp, #0x10
700ae6f4: 9003         	str	r0, [sp, #0xc]
700ae6f6: 9102         	str	r1, [sp, #0x8]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ae6f8: 9803         	ldr	r0, [sp, #0xc]
700ae6fa: 21bf         	movs	r1, #0xbf
700ae6fc: f7fe f840    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #-0x1f80
700ae700: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_ENHANCED_EN,
700ae702: 9803         	ldr	r0, [sp, #0xc]
700ae704: 3008         	adds	r0, #0x8
700ae706: 9902         	ldr	r1, [sp, #0x8]
700ae708: ea4f 1311    	lsr.w	r3, r1, #0x4
700ae70c: 2110         	movs	r1, #0x10
700ae70e: 2204         	movs	r2, #0x4
700ae710: f7ff ffce    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #-0x64
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae714: 9803         	ldr	r0, [sp, #0xc]
700ae716: 300c         	adds	r0, #0xc
700ae718: 9901         	ldr	r1, [sp, #0x4]
700ae71a: f001 fa31    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x1462
; }
700ae71e: b004         	add	sp, #0x10
700ae720: bd80         	pop	{r7, pc}
		...
700ae72e: 0000         	movs	r0, r0

700ae730 <UART_hardwareFlowCtrlOptSet>:
; {
700ae730: b580         	push	{r7, lr}
700ae732: b084         	sub	sp, #0x10
700ae734: 9003         	str	r0, [sp, #0xc]
700ae736: 9102         	str	r1, [sp, #0x8]
700ae738: 2000         	movs	r0, #0x0
;     uint32_t lcrRegValue = 0;
700ae73a: 9001         	str	r0, [sp, #0x4]
;     lcrRegValue = UART_regConfigModeEnable(baseAddr, UART_REG_CONFIG_MODE_B);
700ae73c: 9803         	ldr	r0, [sp, #0xc]
700ae73e: 21bf         	movs	r1, #0xbf
700ae740: f7fe f81e    	bl	0x700ac780 <UART_regConfigModeEnable> @ imm = #-0x1fc4
700ae744: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_EFR, UART_EFR_HW_FLOW_CONTROL, hwFlowCtrl);
700ae746: 9803         	ldr	r0, [sp, #0xc]
700ae748: 3008         	adds	r0, #0x8
700ae74a: 9b02         	ldr	r3, [sp, #0x8]
700ae74c: 21c0         	movs	r1, #0xc0
700ae74e: 2206         	movs	r2, #0x6
700ae750: f7ff ffae    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #-0xa4
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700ae754: 9803         	ldr	r0, [sp, #0xc]
700ae756: 300c         	adds	r0, #0xc
700ae758: 9901         	ldr	r1, [sp, #0x4]
700ae75a: f001 fa11    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x1422
; }
700ae75e: b004         	add	sp, #0x10
700ae760: bd80         	pop	{r7, pc}
		...
700ae76e: 0000         	movs	r0, r0

700ae770 <vTaskEnterCritical>:
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700ae770: b672         	cpsid i
;   if (xSchedulerRunning != pdFALSE) {
700ae772: f642 2040    	movw	r0, #0x2a40
700ae776: f2c7 000b    	movt	r0, #0x700b
700ae77a: 6800         	ldr	r0, [r0]
700ae77c: b178         	cbz	r0, 0x700ae79e <vTaskEnterCritical+0x2e> @ imm = #0x1e
700ae77e: e7ff         	b	0x700ae780 <vTaskEnterCritical+0x10> @ imm = #-0x2
;     (pxCurrentTCB->uxCriticalNesting)++;
700ae780: f642 10fc    	movw	r0, #0x29fc
700ae784: f2c7 000b    	movt	r0, #0x700b
700ae788: 6802         	ldr	r2, [r0]
700ae78a: 6d51         	ldr	r1, [r2, #0x54]
700ae78c: 3101         	adds	r1, #0x1
700ae78e: 6551         	str	r1, [r2, #0x54]
;     if (pxCurrentTCB->uxCriticalNesting == 1) {
700ae790: 6800         	ldr	r0, [r0]
700ae792: 6d40         	ldr	r0, [r0, #0x54]
700ae794: 2801         	cmp	r0, #0x1
700ae796: d101         	bne	0x700ae79c <vTaskEnterCritical+0x2c> @ imm = #0x2
700ae798: e7ff         	b	0x700ae79a <vTaskEnterCritical+0x2a> @ imm = #-0x2
;     }
700ae79a: e7ff         	b	0x700ae79c <vTaskEnterCritical+0x2c> @ imm = #-0x2
;   } else {
700ae79c: e000         	b	0x700ae7a0 <vTaskEnterCritical+0x30> @ imm = #0x0
700ae79e: e7ff         	b	0x700ae7a0 <vTaskEnterCritical+0x30> @ imm = #-0x2
; }
700ae7a0: 4770         	bx	lr
		...
700ae7ae: 0000         	movs	r0, r0

700ae7b0 <xQueueCreateMutexStatic>:
;     {
700ae7b0: b580         	push	{r7, lr}
700ae7b2: b086         	sub	sp, #0x18
700ae7b4: f88d 0017    	strb.w	r0, [sp, #0x17]
700ae7b8: 9104         	str	r1, [sp, #0x10]
700ae7ba: 2001         	movs	r0, #0x1
;         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
700ae7bc: 9002         	str	r0, [sp, #0x8]
700ae7be: 2200         	movs	r2, #0x0
700ae7c0: 9201         	str	r2, [sp, #0x4]
;         ( void ) ucQueueType;
700ae7c2: f89d 1017    	ldrb.w	r1, [sp, #0x17]
;         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
700ae7c6: 9b04         	ldr	r3, [sp, #0x10]
700ae7c8: 46ec         	mov	r12, sp
700ae7ca: f8cc 1000    	str.w	r1, [r12]
700ae7ce: 4611         	mov	r1, r2
700ae7d0: f7fe ff06    	bl	0x700ad5e0 <xQueueGenericCreateStatic> @ imm = #-0x11f4
700ae7d4: 9003         	str	r0, [sp, #0xc]
;         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
700ae7d6: 9803         	ldr	r0, [sp, #0xc]
700ae7d8: f000 fa32    	bl	0x700aec40 <prvInitialiseMutex> @ imm = #0x464
;         return xNewQueue;
700ae7dc: 9803         	ldr	r0, [sp, #0xc]
700ae7de: b006         	add	sp, #0x18
700ae7e0: bd80         	pop	{r7, pc}
		...
700ae7ee: 0000         	movs	r0, r0

700ae7f0 <CSL_pktdmaGetChanPeerReg>:
; {
700ae7f0: b510         	push	{r4, lr}
700ae7f2: b086         	sub	sp, #0x18
700ae7f4: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ae7f8: 9005         	str	r0, [sp, #0x14]
700ae7fa: 9104         	str	r1, [sp, #0x10]
700ae7fc: 9203         	str	r2, [sp, #0xc]
700ae7fe: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)true );
700ae800: 9805         	ldr	r0, [sp, #0x14]
700ae802: 9904         	ldr	r1, [sp, #0x10]
700ae804: 9a02         	ldr	r2, [sp, #0x8]
700ae806: 9b08         	ldr	r3, [sp, #0x20]
700ae808: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ae80c: 46ee         	mov	lr, sp
700ae80e: 2401         	movs	r4, #0x1
700ae810: f8ce 4004    	str.w	r4, [lr, #0x4]
700ae814: f8ce c000    	str.w	r12, [lr]
700ae818: f7f9 f8b2    	bl	0x700a7980 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6e9c
700ae81c: b006         	add	sp, #0x18
700ae81e: bd10         	pop	{r4, pc}

700ae820 <CSL_pktdmaSetChanPeerReg>:
; {
700ae820: b510         	push	{r4, lr}
700ae822: b086         	sub	sp, #0x18
700ae824: f8dd c020    	ldr.w	r12, [sp, #0x20]
700ae828: 9005         	str	r0, [sp, #0x14]
700ae82a: 9104         	str	r1, [sp, #0x10]
700ae82c: 9203         	str	r2, [sp, #0xc]
700ae82e: 9302         	str	r3, [sp, #0x8]
;     return CSL_pktdmaAccessChanPeerReg( pCfg, chanIdx, regIdx, pVal, chanDir, (bool)false );
700ae830: 9805         	ldr	r0, [sp, #0x14]
700ae832: 9904         	ldr	r1, [sp, #0x10]
700ae834: 9a02         	ldr	r2, [sp, #0x8]
700ae836: 9b08         	ldr	r3, [sp, #0x20]
700ae838: f8dd c00c    	ldr.w	r12, [sp, #0xc]
700ae83c: 46ee         	mov	lr, sp
700ae83e: 2400         	movs	r4, #0x0
700ae840: f8ce 4004    	str.w	r4, [lr, #0x4]
700ae844: f8ce c000    	str.w	r12, [lr]
700ae848: f7f9 f89a    	bl	0x700a7980 <CSL_pktdmaAccessChanPeerReg> @ imm = #-0x6ecc
700ae84c: b006         	add	sp, #0x18
700ae84e: bd10         	pop	{r4, pc}

700ae850 <UART_flowCtrlTrigLvlConfig>:
; {
700ae850: b580         	push	{r7, lr}
700ae852: b084         	sub	sp, #0x10
700ae854: 9003         	str	r0, [sp, #0xc]
700ae856: 9102         	str	r1, [sp, #0x8]
700ae858: 9201         	str	r2, [sp, #0x4]
700ae85a: 2000         	movs	r0, #0x0
;     uint32_t tcrValue = 0;
700ae85c: 9000         	str	r0, [sp]
;     tcrValue = rtsHaltFlag & UART_TCR_RX_FIFO_TRIG_HALT_MASK;
700ae85e: 9802         	ldr	r0, [sp, #0x8]
700ae860: f000 000f    	and	r0, r0, #0xf
700ae864: 9000         	str	r0, [sp]
;     tcrValue |= (rtsStartFlag <<
700ae866: 9801         	ldr	r0, [sp, #0x4]
700ae868: 0100         	lsls	r0, r0, #0x4
;                  UART_TCR_RX_FIFO_TRIG_START_SHIFT) &
700ae86a: b2c1         	uxtb	r1, r0
;     tcrValue |= (rtsStartFlag <<
700ae86c: 9800         	ldr	r0, [sp]
700ae86e: 4308         	orrs	r0, r1
700ae870: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_TCR, tcrValue);
700ae872: 9803         	ldr	r0, [sp, #0xc]
700ae874: 3018         	adds	r0, #0x18
700ae876: 9900         	ldr	r1, [sp]
700ae878: f001 f982    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x1304
; }
700ae87c: b004         	add	sp, #0x10
700ae87e: bd80         	pop	{r7, pc}

700ae880 <_outc>:
700ae880: e5912008     	ldr	r2, [r1, #0x8]
700ae884: e5913004     	ldr	r3, [r1, #0x4]
700ae888: e1520003     	cmp	r2, r3
700ae88c: 2a000004     	bhs	0x700ae8a4 <_outc+0x24> @ imm = #0x10
700ae890: e5912000     	ldr	r2, [r1]
700ae894: e2823001     	add	r3, r2, #1
700ae898: e5813000     	str	r3, [r1]
700ae89c: e5c20000     	strb	r0, [r2]
700ae8a0: e5912008     	ldr	r2, [r1, #0x8]
700ae8a4: e2822001     	add	r2, r2, #1
700ae8a8: e5812008     	str	r2, [r1, #0x8]
700ae8ac: e12fff1e     	bx	lr

700ae8b0 <CycleCounterP_getCount32>:
;         MRC     p15, #0, r0, c9, c13, 0  // read PMCCNTR
700ae8b0: ee190f1d     	mrc	p15, #0x0, r0, c9, c13, #0x0
;         bx      LR
700ae8b4: e12fff1e     	bx	lr

700ae8b8 <PmuP_setup>:
;         MCR     p15, #0, r0, c9, c12, 0 // write PMCR
700ae8b8: ee090f1c     	mcr	p15, #0x0, r0, c9, c12, #0x0
;         bx      LR
700ae8bc: e12fff1e     	bx	lr

700ae8c0 <PmuP_enableCounters>:
;         MCR     p15, #0, r0, c9, c12, 1  // write PMCNTENSET
700ae8c0: ee090f3c     	mcr	p15, #0x0, r0, c9, c12, #0x1
;         bx      LR
700ae8c4: e12fff1e     	bx	lr

700ae8c8 <PmuP_disableCounters>:
;         MCR     p15, #0, r0, c9, c12, 2  // write PMCNTENCLR
700ae8c8: ee090f5c     	mcr	p15, #0x0, r0, c9, c12, #0x2
;         bx      LR
700ae8cc: e12fff1e     	bx	lr

700ae8d0 <PmuP_getOverflowStatus>:
;         MRC     p15, 0, r0, c9, c12, 3  // read PMOVSR
700ae8d0: ee190f7c     	mrc	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ae8d4: e12fff1e     	bx	lr

700ae8d8 <PmuP_clearOverflowStatus>:
;         MCR     p15, 0, r0, c9, c12, 3  // write PMOVSR
700ae8d8: ee090f7c     	mcr	p15, #0x0, r0, c9, c12, #0x3
;         bx      LR
700ae8dc: e12fff1e     	bx	lr

700ae8e0 <CSL_secProxyGetMaxMsgSize>:
; {
700ae8e0: b580         	push	{r7, lr}
700ae8e2: b082         	sub	sp, #0x8
700ae8e4: 9001         	str	r0, [sp, #0x4]
;     if( pSecProxyCfg->maxMsgSize == (uint32_t)0U )
700ae8e6: 9801         	ldr	r0, [sp, #0x4]
700ae8e8: 6980         	ldr	r0, [r0, #0x18]
700ae8ea: b960         	cbnz	r0, 0x700ae906 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #0x18
700ae8ec: e7ff         	b	0x700ae8ee <CSL_secProxyGetMaxMsgSize+0xe> @ imm = #-0x2
;         pSecProxyCfg->maxMsgSize = (uint32_t)CSL_REG32_FEXT( &pSecProxyCfg->pSecProxyRegs->CONFIG, SEC_PROXY_CONFIG_MSG_SIZE );
700ae8ee: 9801         	ldr	r0, [sp, #0x4]
700ae8f0: 6800         	ldr	r0, [r0]
700ae8f2: 3004         	adds	r0, #0x4
700ae8f4: 2100         	movs	r1, #0x0
700ae8f6: f6cf 71ff    	movt	r1, #0xffff
700ae8fa: 2210         	movs	r2, #0x10
700ae8fc: f000 fc10    	bl	0x700af120 <CSL_REG32_FEXT_RAW> @ imm = #0x820
700ae900: 9901         	ldr	r1, [sp, #0x4]
700ae902: 6188         	str	r0, [r1, #0x18]
;     }
700ae904: e7ff         	b	0x700ae906 <CSL_secProxyGetMaxMsgSize+0x26> @ imm = #-0x2
;     return pSecProxyCfg->maxMsgSize;
700ae906: 9801         	ldr	r0, [sp, #0x4]
700ae908: 6980         	ldr	r0, [r0, #0x18]
700ae90a: b002         	add	sp, #0x8
700ae90c: bd80         	pop	{r7, pc}
700ae90e: 0000         	movs	r0, r0

700ae910 <Sciclient_rmIaIsIa>:
; {
700ae910: b580         	push	{r7, lr}
700ae912: b082         	sub	sp, #0x8
700ae914: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ae918: 2000         	movs	r0, #0x0
;     bool r = false;
700ae91a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIaGetInst(id) != NULL) {
700ae91e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae922: f7fd fe0d    	bl	0x700ac540 <Sciclient_rmIaGetInst> @ imm = #-0x23e6
700ae926: b120         	cbz	r0, 0x700ae932 <Sciclient_rmIaIsIa+0x22> @ imm = #0x8
700ae928: e7ff         	b	0x700ae92a <Sciclient_rmIaIsIa+0x1a> @ imm = #-0x2
700ae92a: 2001         	movs	r0, #0x1
;         r = true;
700ae92c: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ae930: e7ff         	b	0x700ae932 <Sciclient_rmIaIsIa+0x22> @ imm = #-0x2
;     return r;
700ae932: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ae936: f000 0001    	and	r0, r0, #0x1
700ae93a: b002         	add	sp, #0x8
700ae93c: bd80         	pop	{r7, pc}
700ae93e: 0000         	movs	r0, r0

700ae940 <Sciclient_rmIrIsIr>:
; {
700ae940: b580         	push	{r7, lr}
700ae942: b082         	sub	sp, #0x8
700ae944: f8ad 0006    	strh.w	r0, [sp, #0x6]
700ae948: 2000         	movs	r0, #0x0
;     bool r = false;
700ae94a: f88d 0005    	strb.w	r0, [sp, #0x5]
;     if (Sciclient_rmIrGetInst(id) != NULL) {
700ae94e: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700ae952: f7fd f90d    	bl	0x700abb70 <Sciclient_rmIrGetInst> @ imm = #-0x2de6
700ae956: b120         	cbz	r0, 0x700ae962 <Sciclient_rmIrIsIr+0x22> @ imm = #0x8
700ae958: e7ff         	b	0x700ae95a <Sciclient_rmIrIsIr+0x1a> @ imm = #-0x2
700ae95a: 2001         	movs	r0, #0x1
;         r = true;
700ae95c: f88d 0005    	strb.w	r0, [sp, #0x5]
;     }
700ae960: e7ff         	b	0x700ae962 <Sciclient_rmIrIsIr+0x22> @ imm = #-0x2
;     return r;
700ae962: f89d 0005    	ldrb.w	r0, [sp, #0x5]
700ae966: f000 0001    	and	r0, r0, #0x1
700ae96a: b002         	add	sp, #0x8
700ae96c: bd80         	pop	{r7, pc}
700ae96e: 0000         	movs	r0, r0

700ae970 <Sciclient_secProxyReadThread32>:
; {
700ae970: b580         	push	{r7, lr}
700ae972: b084         	sub	sp, #0x10
700ae974: 9003         	str	r0, [sp, #0xc]
700ae976: f88d 100b    	strb.w	r1, [sp, #0xb]
;     ret = CSL_REG32_RD(CSL_secProxyGetDataAddr(&gSciclientSecProxyCfg,thread,0U) +
700ae97a: 9903         	ldr	r1, [sp, #0xc]
700ae97c: f642 00c0    	movw	r0, #0x28c0
700ae980: f2c7 000b    	movt	r0, #0x700b
700ae984: 2200         	movs	r2, #0x0
700ae986: f000 fdeb    	bl	0x700af560 <CSL_secProxyGetDataAddr> @ imm = #0xbd6
700ae98a: f89d 100b    	ldrb.w	r1, [sp, #0xb]
700ae98e: eb00 0081    	add.w	r0, r0, r1, lsl #2
700ae992: f001 f94d    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0x129a
700ae996: 9001         	str	r0, [sp, #0x4]
;     return ret;
700ae998: 9801         	ldr	r0, [sp, #0x4]
700ae99a: b004         	add	sp, #0x10
700ae99c: bd80         	pop	{r7, pc}
700ae99e: 0000         	movs	r0, r0

700ae9a0 <System_init>:
; {
700ae9a0: b580         	push	{r7, lr}
;     Dpl_init();
700ae9a2: f7fe ff55    	bl	0x700ad850 <Dpl_init>   @ imm = #-0x1156
;         retVal = Sciclient_init(CSL_CORE_ID_R5FSS0_0);
700ae9a6: 2001         	movs	r0, #0x1
700ae9a8: f7fa fe42    	bl	0x700a9630 <Sciclient_init> @ imm = #-0x537c
;         DebugP_assertNoLog(SystemP_SUCCESS == retVal);
700ae9ac: fab0 f080    	clz	r0, r0
700ae9b0: 0940         	lsrs	r0, r0, #0x5
700ae9b2: f002 fc95    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x292a
;     CycleCounterP_init(SOC_getSelfCpuClk());
700ae9b6: f000 fbe3    	bl	0x700af180 <SOC_getSelfCpuClk> @ imm = #0x7c6
700ae9ba: f7f9 fd81    	bl	0x700a84c0 <CycleCounterP_init> @ imm = #-0x64fe
;     PowerClock_init();
700ae9be: f7fb fe77    	bl	0x700aa6b0 <PowerClock_init> @ imm = #-0x4312
;     Pinmux_init();
700ae9c2: f000 fc65    	bl	0x700af290 <Pinmux_init> @ imm = #0x8ca
;     UART_init();
700ae9c6: e8bd 4080    	pop.w	{r7, lr}
700ae9ca: f7f9 b959    	b.w	0x700a7c80 <UART_init>  @ imm = #-0x6d4e
700ae9ce: 0000         	movs	r0, r0

700ae9d0 <_is_digit>:
; {
700ae9d0: b082         	sub	sp, #0x8
700ae9d2: f88d 0007    	strb.w	r0, [sp, #0x7]
;   return (ch >= '0') && (ch <= '9');
700ae9d6: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ae9da: 2000         	movs	r0, #0x0
700ae9dc: 2930         	cmp	r1, #0x30
700ae9de: 9000         	str	r0, [sp]
700ae9e0: db08         	blt	0x700ae9f4 <_is_digit+0x24> @ imm = #0x10
700ae9e2: e7ff         	b	0x700ae9e4 <_is_digit+0x14> @ imm = #-0x2
700ae9e4: f89d 1007    	ldrb.w	r1, [sp, #0x7]
700ae9e8: 2000         	movs	r0, #0x0
700ae9ea: 293a         	cmp	r1, #0x3a
700ae9ec: bfb8         	it	lt
700ae9ee: 2001         	movlt	r0, #0x1
700ae9f0: 9000         	str	r0, [sp]
700ae9f2: e7ff         	b	0x700ae9f4 <_is_digit+0x24> @ imm = #-0x2
700ae9f4: 9800         	ldr	r0, [sp]
;   return (ch >= '0') && (ch <= '9');
700ae9f6: f000 0001    	and	r0, r0, #0x1
700ae9fa: b002         	add	sp, #0x8
700ae9fc: 4770         	bx	lr
700ae9fe: 0000         	movs	r0, r0

700aea00 <prvIsQueueFull>:
; {
700aea00: b580         	push	{r7, lr}
700aea02: b082         	sub	sp, #0x8
700aea04: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700aea06: f7ff feb3    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #-0x29a
;         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
700aea0a: 9801         	ldr	r0, [sp, #0x4]
700aea0c: 6b80         	ldr	r0, [r0, #0x38]
700aea0e: 9901         	ldr	r1, [sp, #0x4]
700aea10: 6bc9         	ldr	r1, [r1, #0x3c]
700aea12: 4288         	cmp	r0, r1
700aea14: d103         	bne	0x700aea1e <prvIsQueueFull+0x1e> @ imm = #0x6
700aea16: e7ff         	b	0x700aea18 <prvIsQueueFull+0x18> @ imm = #-0x2
700aea18: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700aea1a: 9000         	str	r0, [sp]
;         }
700aea1c: e002         	b	0x700aea24 <prvIsQueueFull+0x24> @ imm = #0x4
700aea1e: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700aea20: 9000         	str	r0, [sp]
700aea22: e7ff         	b	0x700aea24 <prvIsQueueFull+0x24> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700aea24: f7fe ff64    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #-0x1138
;     return xReturn;
700aea28: 9800         	ldr	r0, [sp]
700aea2a: b002         	add	sp, #0x8
700aea2c: bd80         	pop	{r7, pc}
700aea2e: 0000         	movs	r0, r0

700aea30 <prvTaskCheckFreeStackSpace>:
; prvTaskCheckFreeStackSpace(const uint8_t *pucStackByte) {
700aea30: b082         	sub	sp, #0x8
700aea32: 9001         	str	r0, [sp, #0x4]
700aea34: 2000         	movs	r0, #0x0
;   uint32_t ulCount = 0U;
700aea36: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700aea38: e7ff         	b	0x700aea3a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x2
700aea3a: 9801         	ldr	r0, [sp, #0x4]
700aea3c: 7800         	ldrb	r0, [r0]
700aea3e: 28a5         	cmp	r0, #0xa5
700aea40: d107         	bne	0x700aea52 <prvTaskCheckFreeStackSpace+0x22> @ imm = #0xe
700aea42: e7ff         	b	0x700aea44 <prvTaskCheckFreeStackSpace+0x14> @ imm = #-0x2
;     pucStackByte -= portSTACK_GROWTH;
700aea44: 9801         	ldr	r0, [sp, #0x4]
700aea46: 3001         	adds	r0, #0x1
700aea48: 9001         	str	r0, [sp, #0x4]
;     ulCount++;
700aea4a: 9800         	ldr	r0, [sp]
700aea4c: 3001         	adds	r0, #0x1
700aea4e: 9000         	str	r0, [sp]
;   while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
700aea50: e7f3         	b	0x700aea3a <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x1a
;   ulCount /=
700aea52: 9800         	ldr	r0, [sp]
700aea54: 0880         	lsrs	r0, r0, #0x2
700aea56: 9000         	str	r0, [sp]
;   return (configSTACK_DEPTH_TYPE)ulCount;
700aea58: 9800         	ldr	r0, [sp]
700aea5a: b002         	add	sp, #0x8
700aea5c: 4770         	bx	lr
700aea5e: 0000         	movs	r0, r0

700aea60 <tm_queue_send_from_isr>:
; {
700aea60: b580         	push	{r7, lr}
700aea62: b082         	sub	sp, #0x8
;    status = xQueueSendToBackFromISR(tm_queue_array[queue_id], (const void*) message_ptr, &xHigherPriorityTaskWoken);
700aea64: f245 22b4    	movw	r2, #0x52b4
700aea68: 2300         	movs	r3, #0x0
700aea6a: f2c7 0208    	movt	r2, #0x7008
700aea6e: f852 0020    	ldr.w	r0, [r2, r0, lsl #2]
700aea72: aa01         	add	r2, sp, #0x4
;    status = xQueueSendToBackFromISR(tm_queue_array[queue_id], (const void*) message_ptr, &xHigherPriorityTaskWoken);
700aea74: f7f9 ffdc    	bl	0x700a8a30 <xQueueGenericSendFromISR> @ imm = #-0x6048
;    if (status != pdTRUE)
700aea78: 2801         	cmp	r0, #0x1
700aea7a: d105         	bne	0x700aea88 <tm_queue_send_from_isr+0x28> @ imm = #0xa
;    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
700aea7c: 9801         	ldr	r0, [sp, #0x4]
700aea7e: f000 fdaf    	bl	0x700af5e0 <vPortYeildFromISR> @ imm = #0xb5e
700aea82: 2000         	movs	r0, #0x0
; }
700aea84: b002         	add	sp, #0x8
700aea86: bd80         	pop	{r7, pc}
700aea88: 2001         	movs	r0, #0x1
; }
700aea8a: b002         	add	sp, #0x8
700aea8c: bd80         	pop	{r7, pc}
700aea8e: 0000         	movs	r0, r0

700aea90 <vListInitialise>:
; {
700aea90: b081         	sub	sp, #0x4
700aea92: 9000         	str	r0, [sp]
;     pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700aea94: 9900         	ldr	r1, [sp]
700aea96: f101 0008    	add.w	r0, r1, #0x8
700aea9a: 6048         	str	r0, [r1, #0x4]
;     pxList->xListEnd.xItemValue = portMAX_DELAY;
700aea9c: 9900         	ldr	r1, [sp]
700aea9e: f04f 30ff    	mov.w	r0, #0xffffffff
700aeaa2: 6088         	str	r0, [r1, #0x8]
;     pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700aeaa4: 9900         	ldr	r1, [sp]
700aeaa6: f101 0008    	add.w	r0, r1, #0x8
700aeaaa: 60c8         	str	r0, [r1, #0xc]
;     pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
700aeaac: 9900         	ldr	r1, [sp]
700aeaae: f101 0008    	add.w	r0, r1, #0x8
700aeab2: 6108         	str	r0, [r1, #0x10]
;     pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
700aeab4: 9900         	ldr	r1, [sp]
700aeab6: 2000         	movs	r0, #0x0
700aeab8: 6008         	str	r0, [r1]
; }
700aeaba: b001         	add	sp, #0x4
700aeabc: 4770         	bx	lr
700aeabe: 0000         	movs	r0, r0

700aeac0 <CSL_bcdmaGetRxRT>:
; {
700aeac0: b580         	push	{r7, lr}
700aeac2: b084         	sub	sp, #0x10
700aeac4: 9003         	str	r0, [sp, #0xc]
700aeac6: 9102         	str	r1, [sp, #0x8]
700aeac8: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700aeaca: 9803         	ldr	r0, [sp, #0xc]
700aeacc: 9a02         	ldr	r2, [sp, #0x8]
700aeace: 9b01         	ldr	r3, [sp, #0x4]
700aead0: 2107         	movs	r1, #0x7
700aead2: f7fc fa55    	bl	0x700aaf80 <CSL_bcdmaDoChanOp> @ imm = #-0x3b56
700aead6: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aead8: 9800         	ldr	r0, [sp]
700aeada: b120         	cbz	r0, 0x700aeae6 <CSL_bcdmaGetRxRT+0x26> @ imm = #0x8
700aeadc: e7ff         	b	0x700aeade <CSL_bcdmaGetRxRT+0x1e> @ imm = #-0x2
700aeade: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aeae2: 9000         	str	r0, [sp]
;     }
700aeae4: e7ff         	b	0x700aeae6 <CSL_bcdmaGetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700aeae6: 9800         	ldr	r0, [sp]
700aeae8: b004         	add	sp, #0x10
700aeaea: bd80         	pop	{r7, pc}
700aeaec: 0000         	movs	r0, r0
700aeaee: 0000         	movs	r0, r0

700aeaf0 <CSL_bcdmaGetTxRT>:
; {
700aeaf0: b580         	push	{r7, lr}
700aeaf2: b084         	sub	sp, #0x10
700aeaf4: 9003         	str	r0, [sp, #0xc]
700aeaf6: 9102         	str	r1, [sp, #0x8]
700aeaf8: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_GET_RT, chanIdx, (void *)pRT );
700aeafa: 9803         	ldr	r0, [sp, #0xc]
700aeafc: 9a02         	ldr	r2, [sp, #0x8]
700aeafe: 9b01         	ldr	r3, [sp, #0x4]
700aeb00: 2107         	movs	r1, #0x7
700aeb02: f7fc fa3d    	bl	0x700aaf80 <CSL_bcdmaDoChanOp> @ imm = #-0x3b86
700aeb06: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aeb08: 9800         	ldr	r0, [sp]
700aeb0a: b120         	cbz	r0, 0x700aeb16 <CSL_bcdmaGetTxRT+0x26> @ imm = #0x8
700aeb0c: e7ff         	b	0x700aeb0e <CSL_bcdmaGetTxRT+0x1e> @ imm = #-0x2
700aeb0e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aeb12: 9000         	str	r0, [sp]
;     }
700aeb14: e7ff         	b	0x700aeb16 <CSL_bcdmaGetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700aeb16: 9800         	ldr	r0, [sp]
700aeb18: b004         	add	sp, #0x10
700aeb1a: bd80         	pop	{r7, pc}
700aeb1c: 0000         	movs	r0, r0
700aeb1e: 0000         	movs	r0, r0

700aeb20 <CSL_bcdmaSetRxRT>:
; {
700aeb20: b580         	push	{r7, lr}
700aeb22: b084         	sub	sp, #0x10
700aeb24: 9003         	str	r0, [sp, #0xc]
700aeb26: 9102         	str	r1, [sp, #0x8]
700aeb28: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700aeb2a: 9803         	ldr	r0, [sp, #0xc]
700aeb2c: 9a02         	ldr	r2, [sp, #0x8]
700aeb2e: 9b01         	ldr	r3, [sp, #0x4]
700aeb30: 2108         	movs	r1, #0x8
700aeb32: f7fc fa25    	bl	0x700aaf80 <CSL_bcdmaDoChanOp> @ imm = #-0x3bb6
700aeb36: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aeb38: 9800         	ldr	r0, [sp]
700aeb3a: b120         	cbz	r0, 0x700aeb46 <CSL_bcdmaSetRxRT+0x26> @ imm = #0x8
700aeb3c: e7ff         	b	0x700aeb3e <CSL_bcdmaSetRxRT+0x1e> @ imm = #-0x2
700aeb3e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aeb42: 9000         	str	r0, [sp]
;     }
700aeb44: e7ff         	b	0x700aeb46 <CSL_bcdmaSetRxRT+0x26> @ imm = #-0x2
;     return retVal;
700aeb46: 9800         	ldr	r0, [sp]
700aeb48: b004         	add	sp, #0x10
700aeb4a: bd80         	pop	{r7, pc}
700aeb4c: 0000         	movs	r0, r0
700aeb4e: 0000         	movs	r0, r0

700aeb50 <CSL_bcdmaSetTxRT>:
; {
700aeb50: b580         	push	{r7, lr}
700aeb52: b084         	sub	sp, #0x10
700aeb54: 9003         	str	r0, [sp, #0xc]
700aeb56: 9102         	str	r1, [sp, #0x8]
700aeb58: 9201         	str	r2, [sp, #0x4]
;     retVal = CSL_bcdmaDoChanOp( pCfg, CSL_BCDMA_CHAN_OP_SET_RT, chanIdx, (void *)pRT );
700aeb5a: 9803         	ldr	r0, [sp, #0xc]
700aeb5c: 9a02         	ldr	r2, [sp, #0x8]
700aeb5e: 9b01         	ldr	r3, [sp, #0x4]
700aeb60: 2108         	movs	r1, #0x8
700aeb62: f7fc fa0d    	bl	0x700aaf80 <CSL_bcdmaDoChanOp> @ imm = #-0x3be6
700aeb66: 9000         	str	r0, [sp]
;     if( retVal != CSL_PASS )
700aeb68: 9800         	ldr	r0, [sp]
700aeb6a: b120         	cbz	r0, 0x700aeb76 <CSL_bcdmaSetTxRT+0x26> @ imm = #0x8
700aeb6c: e7ff         	b	0x700aeb6e <CSL_bcdmaSetTxRT+0x1e> @ imm = #-0x2
700aeb6e: f04f 30ff    	mov.w	r0, #0xffffffff
;         retVal = CSL_EFAIL;     /* API returns CSL_EFAIL on failure for backwards compatibility with udmap API */
700aeb72: 9000         	str	r0, [sp]
;     }
700aeb74: e7ff         	b	0x700aeb76 <CSL_bcdmaSetTxRT+0x26> @ imm = #-0x2
;     return retVal;
700aeb76: 9800         	ldr	r0, [sp]
700aeb78: b004         	add	sp, #0x10
700aeb7a: bd80         	pop	{r7, pc}
700aeb7c: 0000         	movs	r0, r0
700aeb7e: 0000         	movs	r0, r0

700aeb80 <DebugP_logZoneEnable>:
; {
700aeb80: b580         	push	{r7, lr}
700aeb82: b084         	sub	sp, #0x10
700aeb84: 9003         	str	r0, [sp, #0xc]
;     oldIntState = HwiP_disable();
700aeb86: f001 eeec    	blx	0x700b0960 <HwiP_disable> @ imm = #0x1dd8
700aeb8a: 9001         	str	r0, [sp, #0x4]
;     oldZoneMask = gDebugLogZone;
700aeb8c: f642 11d0    	movw	r1, #0x29d0
700aeb90: f2c7 010b    	movt	r1, #0x700b
700aeb94: 6808         	ldr	r0, [r1]
700aeb96: 9002         	str	r0, [sp, #0x8]
;     gDebugLogZone = gDebugLogZone | (logZoneMask);
700aeb98: 6808         	ldr	r0, [r1]
700aeb9a: 9a03         	ldr	r2, [sp, #0xc]
700aeb9c: 4310         	orrs	r0, r2
700aeb9e: 6008         	str	r0, [r1]
;     HwiP_restore(oldIntState);
700aeba0: 9801         	ldr	r0, [sp, #0x4]
700aeba2: f001 eefe    	blx	0x700b09a0 <HwiP_restore> @ imm = #0x1dfc
;     return oldZoneMask;
700aeba6: 9802         	ldr	r0, [sp, #0x8]
700aeba8: b004         	add	sp, #0x10
700aebaa: bd80         	pop	{r7, pc}
700aebac: 0000         	movs	r0, r0
700aebae: 0000         	movs	r0, r0

700aebb0 <Sciclient_getIrAddr>:
; {
700aebb0: b580         	push	{r7, lr}
700aebb2: b084         	sub	sp, #0x10
700aebb4: 9003         	str	r0, [sp, #0xc]
700aebb6: 9102         	str	r1, [sp, #0x8]
;     int_ctrl_reg = (uint32_t *)(addr + Sciclient_rmIrIntControlReg(i));
700aebb8: 9803         	ldr	r0, [sp, #0xc]
700aebba: 9000         	str	r0, [sp]
700aebbc: f8bd 0008    	ldrh.w	r0, [sp, #0x8]
700aebc0: f000 fed6    	bl	0x700af970 <Sciclient_rmIrIntControlReg> @ imm = #0xdac
700aebc4: 4601         	mov	r1, r0
700aebc6: 9800         	ldr	r0, [sp]
700aebc8: 4408         	add	r0, r1
700aebca: 9001         	str	r0, [sp, #0x4]
;     int_ctrl_reg = (uint32_t *)AddrTranslateP_getLocalAddr( (uint64_t)int_ctrl_reg);
700aebcc: 9801         	ldr	r0, [sp, #0x4]
700aebce: 2100         	movs	r1, #0x0
700aebd0: f7f7 f81e    	bl	0x700a5c10 <AddrTranslateP_getLocalAddr> @ imm = #-0x8fc4
700aebd4: 9001         	str	r0, [sp, #0x4]
;     return int_ctrl_reg;
700aebd6: 9801         	ldr	r0, [sp, #0x4]
700aebd8: b004         	add	sp, #0x10
700aebda: bd80         	pop	{r7, pc}
700aebdc: 0000         	movs	r0, r0
700aebde: 0000         	movs	r0, r0

700aebe0 <TaskP_calcCounterDiff>:
; {
700aebe0: b083         	sub	sp, #0xc
700aebe2: 9002         	str	r0, [sp, #0x8]
700aebe4: 9101         	str	r1, [sp, #0x4]
;     if(cur >= last)
700aebe6: 9802         	ldr	r0, [sp, #0x8]
700aebe8: 9901         	ldr	r1, [sp, #0x4]
700aebea: 4288         	cmp	r0, r1
700aebec: d305         	blo	0x700aebfa <TaskP_calcCounterDiff+0x1a> @ imm = #0xa
700aebee: e7ff         	b	0x700aebf0 <TaskP_calcCounterDiff+0x10> @ imm = #-0x2
;         delta = cur - last;
700aebf0: 9802         	ldr	r0, [sp, #0x8]
700aebf2: 9901         	ldr	r1, [sp, #0x4]
700aebf4: 1a40         	subs	r0, r0, r1
700aebf6: 9000         	str	r0, [sp]
;     }
700aebf8: e005         	b	0x700aec06 <TaskP_calcCounterDiff+0x26> @ imm = #0xa
;         delta = (  0xFFFFFFFFU - last ) + cur;
700aebfa: 9801         	ldr	r0, [sp, #0x4]
700aebfc: 9902         	ldr	r1, [sp, #0x8]
700aebfe: 43c0         	mvns	r0, r0
700aec00: 4408         	add	r0, r1
700aec02: 9000         	str	r0, [sp]
700aec04: e7ff         	b	0x700aec06 <TaskP_calcCounterDiff+0x26> @ imm = #-0x2
;     return delta;
700aec06: 9800         	ldr	r0, [sp]
700aec08: b003         	add	sp, #0xc
700aec0a: 4770         	bx	lr
700aec0c: 0000         	movs	r0, r0
700aec0e: 0000         	movs	r0, r0

700aec10 <TimerP_clearOverflowInt>:
; {
700aec10: b083         	sub	sp, #0xc
700aec12: 9002         	str	r0, [sp, #0x8]
700aec14: 2002         	movs	r0, #0x2
;     uint32_t value = (0x1U << TIMER_OVF_INT_SHIFT);
700aec16: 9000         	str	r0, [sp]
;     addr = (volatile uint32_t *)(baseAddr + TIMER_IRQ_STATUS);
700aec18: 9802         	ldr	r0, [sp, #0x8]
700aec1a: 3028         	adds	r0, #0x28
700aec1c: 9001         	str	r0, [sp, #0x4]
;     *addr = value;
700aec1e: 9800         	ldr	r0, [sp]
700aec20: 9901         	ldr	r1, [sp, #0x4]
700aec22: 6008         	str	r0, [r1]
;     if((*addr & value) != 0U)
700aec24: 9801         	ldr	r0, [sp, #0x4]
700aec26: 6800         	ldr	r0, [r0]
700aec28: 9900         	ldr	r1, [sp]
700aec2a: 4208         	tst	r0, r1
700aec2c: d004         	beq	0x700aec38 <TimerP_clearOverflowInt+0x28> @ imm = #0x8
700aec2e: e7ff         	b	0x700aec30 <TimerP_clearOverflowInt+0x20> @ imm = #-0x2
;         *addr = value;
700aec30: 9800         	ldr	r0, [sp]
700aec32: 9901         	ldr	r1, [sp, #0x4]
700aec34: 6008         	str	r0, [r1]
;     }
700aec36: e7ff         	b	0x700aec38 <TimerP_clearOverflowInt+0x28> @ imm = #-0x2
; }
700aec38: b003         	add	sp, #0xc
700aec3a: 4770         	bx	lr
700aec3c: 0000         	movs	r0, r0
700aec3e: 0000         	movs	r0, r0

700aec40 <prvInitialiseMutex>:
;     {
700aec40: b580         	push	{r7, lr}
700aec42: b082         	sub	sp, #0x8
700aec44: 9001         	str	r0, [sp, #0x4]
;         if( pxNewQueue != NULL )
700aec46: 9801         	ldr	r0, [sp, #0x4]
700aec48: b168         	cbz	r0, 0x700aec66 <prvInitialiseMutex+0x26> @ imm = #0x1a
700aec4a: e7ff         	b	0x700aec4c <prvInitialiseMutex+0xc> @ imm = #-0x2
;             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
700aec4c: 9801         	ldr	r0, [sp, #0x4]
700aec4e: 2300         	movs	r3, #0x0
700aec50: 6083         	str	r3, [r0, #0x8]
;             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
700aec52: 9801         	ldr	r0, [sp, #0x4]
700aec54: 6003         	str	r3, [r0]
;             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
700aec56: 9801         	ldr	r0, [sp, #0x4]
700aec58: 60c3         	str	r3, [r0, #0xc]
;             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
700aec5a: 9801         	ldr	r0, [sp, #0x4]
700aec5c: 4619         	mov	r1, r3
700aec5e: 461a         	mov	r2, r3
700aec60: f7f4 fb46    	bl	0x700a32f0 <xQueueGenericSend> @ imm = #-0xb974
;         }
700aec64: e000         	b	0x700aec68 <prvInitialiseMutex+0x28> @ imm = #0x0
700aec66: e7ff         	b	0x700aec68 <prvInitialiseMutex+0x28> @ imm = #-0x2
;     }
700aec68: b002         	add	sp, #0x8
700aec6a: bd80         	pop	{r7, pc}
700aec6c: 0000         	movs	r0, r0
700aec6e: 0000         	movs	r0, r0

700aec70 <pvTaskIncrementMutexHeldCount>:
;   if (pxCurrentTCB != NULL) {
700aec70: f642 10fc    	movw	r0, #0x29fc
700aec74: f2c7 000b    	movt	r0, #0x700b
700aec78: 6800         	ldr	r0, [r0]
700aec7a: b148         	cbz	r0, 0x700aec90 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #0x12
700aec7c: e7ff         	b	0x700aec7e <pvTaskIncrementMutexHeldCount+0xe> @ imm = #-0x2
;     (pxCurrentTCB->uxMutexesHeld)++;
700aec7e: f642 10fc    	movw	r0, #0x29fc
700aec82: f2c7 000b    	movt	r0, #0x700b
700aec86: 6801         	ldr	r1, [r0]
700aec88: 6e48         	ldr	r0, [r1, #0x64]
700aec8a: 3001         	adds	r0, #0x1
700aec8c: 6648         	str	r0, [r1, #0x64]
;   }
700aec8e: e7ff         	b	0x700aec90 <pvTaskIncrementMutexHeldCount+0x20> @ imm = #-0x2
;   return pxCurrentTCB;
700aec90: f642 10fc    	movw	r0, #0x29fc
700aec94: f2c7 000b    	movt	r0, #0x700b
700aec98: 6800         	ldr	r0, [r0]
700aec9a: 4770         	bx	lr
700aec9c: 0000         	movs	r0, r0
700aec9e: 0000         	movs	r0, r0

700aeca0 <vApplicationGetIdleTaskMemory>:
;                                    uint32_t *pulIdleTaskStackSize) {
700aeca0: b083         	sub	sp, #0xc
700aeca2: 9002         	str	r0, [sp, #0x8]
700aeca4: 9101         	str	r1, [sp, #0x4]
700aeca6: 9200         	str	r2, [sp]
;   *ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
700aeca8: 9902         	ldr	r1, [sp, #0x8]
700aecaa: f644 60b0    	movw	r0, #0x4eb0
700aecae: f2c7 0008    	movt	r0, #0x7008
700aecb2: 6008         	str	r0, [r1]
;   *ppxIdleTaskStackBuffer = uxIdleTaskStack;
700aecb4: 9901         	ldr	r1, [sp, #0x4]
700aecb6: f242 0080    	movw	r0, #0x2080
700aecba: f2c7 0008    	movt	r0, #0x7008
700aecbe: 6008         	str	r0, [r1]
;   *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
700aecc0: 9900         	ldr	r1, [sp]
700aecc2: f44f 6080    	mov.w	r0, #0x400
700aecc6: 6008         	str	r0, [r1]
; }
700aecc8: b003         	add	sp, #0xc
700aecca: 4770         	bx	lr
700aeccc: 0000         	movs	r0, r0
700aecce: 0000         	movs	r0, r0

700aecd0 <vApplicationGetTimerTaskMemory>:
;                                     uint32_t *pulTimerTaskStackSize) {
700aecd0: b083         	sub	sp, #0xc
700aecd2: 9002         	str	r0, [sp, #0x8]
700aecd4: 9101         	str	r1, [sp, #0x4]
700aecd6: 9200         	str	r2, [sp]
;   *ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
700aecd8: 9902         	ldr	r1, [sp, #0x8]
700aecda: f644 7038    	movw	r0, #0x4f38
700aecde: f2c7 0008    	movt	r0, #0x7008
700aece2: 6008         	str	r0, [r1]
;   *ppxTimerTaskStackBuffer = uxTimerTaskStack;
700aece4: 9901         	ldr	r1, [sp, #0x4]
700aece6: f643 508c    	movw	r0, #0x3d8c
700aecea: f2c7 0008    	movt	r0, #0x7008
700aecee: 6008         	str	r0, [r1]
;   *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
700aecf0: 9900         	ldr	r1, [sp]
700aecf2: f44f 7080    	mov.w	r0, #0x100
700aecf6: 6008         	str	r0, [r1]
; }
700aecf8: b003         	add	sp, #0xc
700aecfa: 4770         	bx	lr
700aecfc: 0000         	movs	r0, r0
700aecfe: 0000         	movs	r0, r0

700aed00 <Sciclient_rmParamIsValid>:
; {
700aed00: b083         	sub	sp, #0xc
700aed02: 9002         	str	r0, [sp, #0x8]
700aed04: 9101         	str	r1, [sp, #0x4]
700aed06: 2000         	movs	r0, #0x0
;     bool r = false;
700aed08: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if ((valid_params & param_mask) != 0) {
700aed0c: 9802         	ldr	r0, [sp, #0x8]
700aed0e: 9901         	ldr	r1, [sp, #0x4]
700aed10: 4208         	tst	r0, r1
700aed12: d004         	beq	0x700aed1e <Sciclient_rmParamIsValid+0x1e> @ imm = #0x8
700aed14: e7ff         	b	0x700aed16 <Sciclient_rmParamIsValid+0x16> @ imm = #-0x2
700aed16: 2001         	movs	r0, #0x1
;         r = true;
700aed18: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aed1c: e7ff         	b	0x700aed1e <Sciclient_rmParamIsValid+0x1e> @ imm = #-0x2
;     return r;
700aed1e: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aed22: f000 0001    	and	r0, r0, #0x1
700aed26: b003         	add	sp, #0xc
700aed28: 4770         	bx	lr
700aed2a: 0000         	movs	r0, r0
700aed2c: 0000         	movs	r0, r0
700aed2e: 0000         	movs	r0, r0

700aed30 <Sciclient_rmPsIsEmpty>:
; {
700aed30: b081         	sub	sp, #0x4
700aed32: 2001         	movs	r0, #0x1
;     bool e = true;
700aed34: f88d 0003    	strb.w	r0, [sp, #0x3]
;     if (gPstack.psp != 0) {
700aed38: f241 0058    	movw	r0, #0x1058
700aed3c: f2c7 0008    	movt	r0, #0x7008
700aed40: 8c80         	ldrh	r0, [r0, #0x24]
700aed42: b120         	cbz	r0, 0x700aed4e <Sciclient_rmPsIsEmpty+0x1e> @ imm = #0x8
700aed44: e7ff         	b	0x700aed46 <Sciclient_rmPsIsEmpty+0x16> @ imm = #-0x2
700aed46: 2000         	movs	r0, #0x0
;         e = false;
700aed48: f88d 0003    	strb.w	r0, [sp, #0x3]
;     }
700aed4c: e7ff         	b	0x700aed4e <Sciclient_rmPsIsEmpty+0x1e> @ imm = #-0x2
;     return e;
700aed4e: f89d 0003    	ldrb.w	r0, [sp, #0x3]
700aed52: f000 0001    	and	r0, r0, #0x1
700aed56: b001         	add	sp, #0x4
700aed58: 4770         	bx	lr
700aed5a: 0000         	movs	r0, r0
700aed5c: 0000         	movs	r0, r0
700aed5e: 0000         	movs	r0, r0

700aed60 <UART_Transaction_init>:
; {
700aed60: b081         	sub	sp, #0x4
700aed62: 9000         	str	r0, [sp]
;     if(trans != NULL)
700aed64: 9800         	ldr	r0, [sp]
700aed66: b170         	cbz	r0, 0x700aed86 <UART_Transaction_init+0x26> @ imm = #0x1c
700aed68: e7ff         	b	0x700aed6a <UART_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700aed6a: 9900         	ldr	r1, [sp]
700aed6c: 2000         	movs	r0, #0x0
700aed6e: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700aed70: 9900         	ldr	r1, [sp]
700aed72: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = SystemP_WAIT_FOREVER;
700aed74: 9a00         	ldr	r2, [sp]
700aed76: f04f 31ff    	mov.w	r1, #0xffffffff
700aed7a: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700aed7c: 9900         	ldr	r1, [sp]
700aed7e: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700aed80: 9900         	ldr	r1, [sp]
700aed82: 6108         	str	r0, [r1, #0x10]
;     }
700aed84: e7ff         	b	0x700aed86 <UART_Transaction_init+0x26> @ imm = #-0x2
; }
700aed86: b001         	add	sp, #0x4
700aed88: 4770         	bx	lr
700aed8a: 0000         	movs	r0, r0
700aed8c: 0000         	movs	r0, r0
700aed8e: 0000         	movs	r0, r0

700aed90 <UART_intr2Disable>:
; {
700aed90: b580         	push	{r7, lr}
700aed92: b084         	sub	sp, #0x10
700aed94: 9003         	str	r0, [sp, #0xc]
700aed96: 9102         	str	r1, [sp, #0x8]
;     HW_WR_REG32(baseAddr + UART_IER2, HW_RD_REG32(baseAddr + UART_IER2) &
700aed98: 9803         	ldr	r0, [sp, #0xc]
700aed9a: 306c         	adds	r0, #0x6c
700aed9c: 9001         	str	r0, [sp, #0x4]
700aed9e: f000 fee7    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0xdce
700aeda2: 4601         	mov	r1, r0
700aeda4: 9801         	ldr	r0, [sp, #0x4]
700aeda6: 9b02         	ldr	r3, [sp, #0x8]
700aeda8: f06f 0203    	mvn	r2, #0x3
700aedac: ea62 0203    	orn	r2, r2, r3
700aedb0: 4011         	ands	r1, r2
700aedb2: f000 fee5    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0xdca
; }
700aedb6: b004         	add	sp, #0x10
700aedb8: bd80         	pop	{r7, pc}
700aedba: 0000         	movs	r0, r0
700aedbc: 0000         	movs	r0, r0
700aedbe: 0000         	movs	r0, r0

700aedc0 <UART_lld_Transaction_init>:
; {
700aedc0: b081         	sub	sp, #0x4
700aedc2: 9000         	str	r0, [sp]
;     if(trans != NULL)
700aedc4: 9800         	ldr	r0, [sp]
700aedc6: b170         	cbz	r0, 0x700aede6 <UART_lld_Transaction_init+0x26> @ imm = #0x1c
700aedc8: e7ff         	b	0x700aedca <UART_lld_Transaction_init+0xa> @ imm = #-0x2
;         trans->buf              = NULL;
700aedca: 9900         	ldr	r1, [sp]
700aedcc: 2000         	movs	r0, #0x0
700aedce: 6008         	str	r0, [r1]
;         trans->count            = 0U;
700aedd0: 9900         	ldr	r1, [sp]
700aedd2: 6048         	str	r0, [r1, #0x4]
;         trans->timeout          = UART_WAIT_FOREVER;
700aedd4: 9a00         	ldr	r2, [sp]
700aedd6: f04f 31ff    	mov.w	r1, #0xffffffff
700aedda: 6091         	str	r1, [r2, #0x8]
;         trans->status           = UART_STATUS_SUCCESS;
700aeddc: 9900         	ldr	r1, [sp]
700aedde: 60c8         	str	r0, [r1, #0xc]
;         trans->args             = NULL;
700aede0: 9900         	ldr	r1, [sp]
700aede2: 6108         	str	r0, [r1, #0x10]
;     }
700aede4: e7ff         	b	0x700aede6 <UART_lld_Transaction_init+0x26> @ imm = #-0x2
; }
700aede6: b001         	add	sp, #0x4
700aede8: 4770         	bx	lr
700aedea: 0000         	movs	r0, r0
700aedec: 0000         	movs	r0, r0
700aedee: 0000         	movs	r0, r0

700aedf0 <UART_lld_dmaWrite>:
; {
700aedf0: b580         	push	{r7, lr}
700aedf2: b084         	sub	sp, #0x10
700aedf4: 9003         	str	r0, [sp, #0xc]
700aedf6: 9102         	str	r1, [sp, #0x8]
700aedf8: 2000         	movs	r0, #0x0
;     int32_t status = UART_TRANSFER_STATUS_SUCCESS;
700aedfa: 9001         	str	r0, [sp, #0x4]
;     status = UART_udmaConfigPdmaTx(hUart, transaction);
700aedfc: 9803         	ldr	r0, [sp, #0xc]
700aedfe: 9902         	ldr	r1, [sp, #0x8]
700aee00: f7f7 fb16    	bl	0x700a6430 <UART_udmaConfigPdmaTx> @ imm = #-0x89d4
700aee04: 9001         	str	r0, [sp, #0x4]
;     if (status != UDMA_SOK)
700aee06: 9801         	ldr	r0, [sp, #0x4]
700aee08: b120         	cbz	r0, 0x700aee14 <UART_lld_dmaWrite+0x24> @ imm = #0x8
700aee0a: e7ff         	b	0x700aee0c <UART_lld_dmaWrite+0x1c> @ imm = #-0x2
700aee0c: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = UART_TRANSFER_STATUS_FAILURE;
700aee10: 9001         	str	r0, [sp, #0x4]
;     }
700aee12: e7ff         	b	0x700aee14 <UART_lld_dmaWrite+0x24> @ imm = #-0x2
;     return status;
700aee14: 9801         	ldr	r0, [sp, #0x4]
700aee16: b004         	add	sp, #0x10
700aee18: bd80         	pop	{r7, pc}
700aee1a: 0000         	movs	r0, r0
700aee1c: 0000         	movs	r0, r0
700aee1e: 0000         	movs	r0, r0

700aee20 <UART_operatingModeSelect>:
; {
700aee20: b580         	push	{r7, lr}
700aee22: b084         	sub	sp, #0x10
700aee24: 9003         	str	r0, [sp, #0xc]
700aee26: 9102         	str	r1, [sp, #0x8]
;     operMode = HW_RD_REG32(baseAddr + UART_MDR1) & UART_MDR1_MODE_SELECT_MASK;
700aee28: 9803         	ldr	r0, [sp, #0xc]
700aee2a: 3020         	adds	r0, #0x20
700aee2c: f000 fea0    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0xd40
700aee30: f000 0007    	and	r0, r0, #0x7
700aee34: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_MDR1, UART_MDR1_MODE_SELECT,
700aee36: 9803         	ldr	r0, [sp, #0xc]
700aee38: 3020         	adds	r0, #0x20
700aee3a: 9b02         	ldr	r3, [sp, #0x8]
700aee3c: 2107         	movs	r1, #0x7
700aee3e: 2200         	movs	r2, #0x0
700aee40: f7ff fc36    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #-0x794
;     return operMode;
700aee44: 9801         	ldr	r0, [sp, #0x4]
700aee46: b004         	add	sp, #0x10
700aee48: bd80         	pop	{r7, pc}
700aee4a: 0000         	movs	r0, r0
700aee4c: 0000         	movs	r0, r0
700aee4e: 0000         	movs	r0, r0

700aee50 <Udma_eventProgramSteering>:
; {
700aee50: b084         	sub	sp, #0x10
700aee52: 9003         	str	r0, [sp, #0xc]
700aee54: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700aee56: 9802         	ldr	r0, [sp, #0x8]
700aee58: 3008         	adds	r0, #0x8
700aee5a: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700aee5c: 9800         	ldr	r0, [sp]
700aee5e: 6800         	ldr	r0, [r0]
700aee60: 2803         	cmp	r0, #0x3
700aee62: d108         	bne	0x700aee76 <Udma_eventProgramSteering+0x26> @ imm = #0x10
700aee64: e7ff         	b	0x700aee66 <Udma_eventProgramSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700aee66: 9800         	ldr	r0, [sp]
700aee68: 6880         	ldr	r0, [r0, #0x8]
700aee6a: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = TRUE;
700aee6c: 9901         	ldr	r1, [sp, #0x4]
700aee6e: 2001         	movs	r0, #0x1
700aee70: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700aee74: e7ff         	b	0x700aee76 <Udma_eventProgramSteering+0x26> @ imm = #-0x2
;     return;
700aee76: b004         	add	sp, #0x10
700aee78: 4770         	bx	lr
700aee7a: 0000         	movs	r0, r0
700aee7c: 0000         	movs	r0, r0
700aee7e: 0000         	movs	r0, r0

700aee80 <Udma_eventResetSteering>:
; {
700aee80: b084         	sub	sp, #0x10
700aee82: 9003         	str	r0, [sp, #0xc]
700aee84: 9102         	str	r1, [sp, #0x8]
;     eventPrms = &eventHandle->eventPrms;
700aee86: 9802         	ldr	r0, [sp, #0x8]
700aee88: 3008         	adds	r0, #0x8
700aee8a: 9000         	str	r0, [sp]
;     if(UDMA_EVENT_TYPE_TR == eventPrms->eventType)
700aee8c: 9800         	ldr	r0, [sp]
700aee8e: 6800         	ldr	r0, [r0]
700aee90: 2803         	cmp	r0, #0x3
700aee92: d108         	bne	0x700aeea6 <Udma_eventResetSteering+0x26> @ imm = #0x10
700aee94: e7ff         	b	0x700aee96 <Udma_eventResetSteering+0x16> @ imm = #-0x2
;         chHandle = (Udma_ChHandleInt) eventPrms->chHandle;
700aee96: 9800         	ldr	r0, [sp]
700aee98: 6880         	ldr	r0, [r0, #0x8]
700aee9a: 9001         	str	r0, [sp, #0x4]
;         chHandle->chOesAllocDone = FALSE;
700aee9c: 9901         	ldr	r1, [sp, #0x4]
700aee9e: 2000         	movs	r0, #0x0
700aeea0: f8c1 0248    	str.w	r0, [r1, #0x248]
;     }
700aeea4: e7ff         	b	0x700aeea6 <Udma_eventResetSteering+0x26> @ imm = #-0x2
;     return;
700aeea6: b004         	add	sp, #0x10
700aeea8: 4770         	bx	lr
700aeeaa: 0000         	movs	r0, r0
700aeeac: 0000         	movs	r0, r0
700aeeae: 0000         	movs	r0, r0

700aeeb0 <Sciclient_secProxyVerifyThread>:
; {
700aeeb0: b580         	push	{r7, lr}
700aeeb2: b082         	sub	sp, #0x8
700aeeb4: 9001         	str	r0, [sp, #0x4]
700aeeb6: 2000         	movs	r0, #0x0
;     int32_t status = SystemP_SUCCESS;
700aeeb8: 9000         	str	r0, [sp]
;     if ((CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700aeeba: 9801         	ldr	r0, [sp, #0x4]
700aeebc: f000 fc00    	bl	0x700af6c0 <Sciclient_secProxyThreadStatusReg> @ imm = #0x800
700aeec0: f000 feb6    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0xd6c
700aeec4: 0fc0         	lsrs	r0, r0, #0x1f
700aeec6: b120         	cbz	r0, 0x700aeed2 <Sciclient_secProxyVerifyThread+0x22> @ imm = #0x8
700aeec8: e7ff         	b	0x700aeeca <Sciclient_secProxyVerifyThread+0x1a> @ imm = #-0x2
700aeeca: f04f 30ff    	mov.w	r0, #0xffffffff
;         status = SystemP_FAILURE;
700aeece: 9000         	str	r0, [sp]
;     }
700aeed0: e7ff         	b	0x700aeed2 <Sciclient_secProxyVerifyThread+0x22> @ imm = #-0x2
;     return status;
700aeed2: 9800         	ldr	r0, [sp]
700aeed4: b002         	add	sp, #0x8
700aeed6: bd80         	pop	{r7, pc}
		...

700aeee0 <prvIsQueueEmpty>:
; {
700aeee0: b580         	push	{r7, lr}
700aeee2: b082         	sub	sp, #0x8
700aeee4: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
700aeee6: f7ff fc43    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #-0x77a
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
700aeeea: 9801         	ldr	r0, [sp, #0x4]
700aeeec: 6b80         	ldr	r0, [r0, #0x38]
700aeeee: b918         	cbnz	r0, 0x700aeef8 <prvIsQueueEmpty+0x18> @ imm = #0x6
700aeef0: e7ff         	b	0x700aeef2 <prvIsQueueEmpty+0x12> @ imm = #-0x2
700aeef2: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
700aeef4: 9000         	str	r0, [sp]
;         }
700aeef6: e002         	b	0x700aeefe <prvIsQueueEmpty+0x1e> @ imm = #0x4
700aeef8: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
700aeefa: 9000         	str	r0, [sp]
700aeefc: e7ff         	b	0x700aeefe <prvIsQueueEmpty+0x1e> @ imm = #-0x2
;     taskEXIT_CRITICAL();
700aeefe: f7fe fcf7    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #-0x1612
;     return xReturn;
700aef02: 9800         	ldr	r0, [sp]
700aef04: b002         	add	sp, #0x8
700aef06: bd80         	pop	{r7, pc}
		...

700aef10 <vQueueDelete>:
; {
700aef10: b580         	push	{r7, lr}
700aef12: b082         	sub	sp, #0x8
700aef14: 9001         	str	r0, [sp, #0x4]
;     Queue_t * const pxQueue = xQueue;
700aef16: 9801         	ldr	r0, [sp, #0x4]
700aef18: 9000         	str	r0, [sp]
;             vQueueUnregisterQueue( pxQueue );
700aef1a: 9800         	ldr	r0, [sp]
700aef1c: f7fe f840    	bl	0x700acfa0 <vQueueUnregisterQueue> @ imm = #-0x1f80
;             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
700aef20: 9800         	ldr	r0, [sp]
700aef22: f890 0046    	ldrb.w	r0, [r0, #0x46]
700aef26: b920         	cbnz	r0, 0x700aef32 <vQueueDelete+0x22> @ imm = #0x8
700aef28: e7ff         	b	0x700aef2a <vQueueDelete+0x1a> @ imm = #-0x2
;                 vPortFree( pxQueue );
700aef2a: 9800         	ldr	r0, [sp]
700aef2c: f000 fa38    	bl	0x700af3a0 <vPortFree>  @ imm = #0x470
;             }
700aef30: e000         	b	0x700aef34 <vQueueDelete+0x24> @ imm = #0x0
700aef32: e7ff         	b	0x700aef34 <vQueueDelete+0x24> @ imm = #-0x2
; }
700aef34: b002         	add	sp, #0x8
700aef36: bd80         	pop	{r7, pc}
		...

700aef40 <vprintf_>:
; {
700aef40: b580         	push	{r7, lr}
700aef42: b084         	sub	sp, #0x10
700aef44: 9103         	str	r1, [sp, #0xc]
700aef46: 9002         	str	r0, [sp, #0x8]
;   return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
700aef48: 9b02         	ldr	r3, [sp, #0x8]
700aef4a: 9803         	ldr	r0, [sp, #0xc]
700aef4c: 4669         	mov	r1, sp
700aef4e: 6008         	str	r0, [r1]
700aef50: f24f 2001    	movw	r0, #0xf201
700aef54: f2c7 000a    	movt	r0, #0x700a
700aef58: f10d 0107    	add.w	r1, sp, #0x7
700aef5c: f04f 32ff    	mov.w	r2, #0xffffffff
700aef60: f7eb f8be    	bl	0x7009a0e0 <_vsnprintf> @ imm = #-0x14e84
700aef64: b004         	add	sp, #0x10
700aef66: bd80         	pop	{r7, pc}
		...

700aef70 <UART_udmapSetReturnPolicy>:
; {
700aef70: b580         	push	{r7, lr}
700aef72: b086         	sub	sp, #0x18
700aef74: 9005         	str	r0, [sp, #0x14]
700aef76: 9104         	str	r1, [sp, #0x10]
700aef78: 2001         	movs	r0, #0x1
;         uint32_t descType = (uint32_t)CSL_UDMAP_CPPI5_PD_DESCINFO_DTYPE_VAL_HOST;
700aef7a: 9003         	str	r0, [sp, #0xc]
;         CSL_UdmapCppi5HMPD *pHpd = (CSL_UdmapCppi5HMPD *) pHpdMem;
700aef7c: 9804         	ldr	r0, [sp, #0x10]
700aef7e: 9002         	str	r0, [sp, #0x8]
;         pHpd,
700aef80: 9802         	ldr	r0, [sp, #0x8]
;         descType,
700aef82: 9903         	ldr	r1, [sp, #0xc]
;         CSL_udmapCppi5SetReturnPolicy(
700aef84: 466a         	mov	r2, sp
700aef86: 2300         	movs	r3, #0x0
700aef88: 6053         	str	r3, [r2, #0x4]
700aef8a: 6013         	str	r3, [r2]
700aef8c: 461a         	mov	r2, r3
700aef8e: f7fb fbd7    	bl	0x700aa740 <CSL_udmapCppi5SetReturnPolicy> @ imm = #-0x4852
;         return;
700aef92: b006         	add	sp, #0x18
700aef94: bd80         	pop	{r7, pc}
		...
700aef9e: 0000         	movs	r0, r0

700aefa0 <Udma_ringGetForwardRingOcc>:
; {
700aefa0: b580         	push	{r7, lr}
700aefa2: b084         	sub	sp, #0x10
700aefa4: 9003         	str	r0, [sp, #0xc]
700aefa6: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700aefa8: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700aefaa: 9803         	ldr	r0, [sp, #0xc]
700aefac: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700aefae: 9801         	ldr	r0, [sp, #0x4]
700aefb0: 6800         	ldr	r0, [r0]
700aefb2: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetForwardRingOcc(ringHandleInt);
700aefb4: 9800         	ldr	r0, [sp]
700aefb6: f8d0 15a8    	ldr.w	r1, [r0, #0x5a8]
700aefba: 9801         	ldr	r0, [sp, #0x4]
700aefbc: 4788         	blx	r1
700aefbe: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700aefc0: 9802         	ldr	r0, [sp, #0x8]
700aefc2: b004         	add	sp, #0x10
700aefc4: bd80         	pop	{r7, pc}
		...
700aefce: 0000         	movs	r0, r0

700aefd0 <Udma_ringGetReverseRingOcc>:
; {
700aefd0: b580         	push	{r7, lr}
700aefd2: b084         	sub	sp, #0x10
700aefd4: 9003         	str	r0, [sp, #0xc]
700aefd6: 2000         	movs	r0, #0x0
;     uint32_t            occ = 0U;
700aefd8: 9002         	str	r0, [sp, #0x8]
;     Udma_RingHandleInt  ringHandleInt = (Udma_RingHandleInt) ringHandle;
700aefda: 9803         	ldr	r0, [sp, #0xc]
700aefdc: 9001         	str	r0, [sp, #0x4]
;     Udma_DrvHandleInt   drvHandle = ringHandleInt->drvHandle;
700aefde: 9801         	ldr	r0, [sp, #0x4]
700aefe0: 6800         	ldr	r0, [r0]
700aefe2: 9000         	str	r0, [sp]
;     occ = drvHandle->ringGetReverseRingOcc(ringHandleInt);
700aefe4: 9800         	ldr	r0, [sp]
700aefe6: f8d0 15ac    	ldr.w	r1, [r0, #0x5ac]
700aefea: 9801         	ldr	r0, [sp, #0x4]
700aefec: 4788         	blx	r1
700aefee: 9002         	str	r0, [sp, #0x8]
;     return (occ);
700aeff0: 9802         	ldr	r0, [sp, #0x8]
700aeff2: b004         	add	sp, #0x10
700aeff4: bd80         	pop	{r7, pc}
		...
700aeffe: 0000         	movs	r0, r0

700af000 <_out_buffer>:
; {
700af000: b084         	sub	sp, #0x10
700af002: f88d 000f    	strb.w	r0, [sp, #0xf]
700af006: 9102         	str	r1, [sp, #0x8]
700af008: 9201         	str	r2, [sp, #0x4]
700af00a: 9300         	str	r3, [sp]
;   if (idx < maxlen) {
700af00c: 9801         	ldr	r0, [sp, #0x4]
700af00e: 9900         	ldr	r1, [sp]
700af010: 4288         	cmp	r0, r1
700af012: d206         	bhs	0x700af022 <_out_buffer+0x22> @ imm = #0xc
700af014: e7ff         	b	0x700af016 <_out_buffer+0x16> @ imm = #-0x2
;     ((char*)buffer)[idx] = character;
700af016: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700af01a: 9902         	ldr	r1, [sp, #0x8]
700af01c: 9a01         	ldr	r2, [sp, #0x4]
700af01e: 5488         	strb	r0, [r1, r2]
;   }
700af020: e7ff         	b	0x700af022 <_out_buffer+0x22> @ imm = #-0x2
; }
700af022: b004         	add	sp, #0x10
700af024: 4770         	bx	lr
		...
700af02e: 0000         	movs	r0, r0

700af030 <prvGetDisinheritPriorityAfterTimeout>:
;     {
700af030: b082         	sub	sp, #0x8
700af032: 9001         	str	r0, [sp, #0x4]
;         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
700af034: 9801         	ldr	r0, [sp, #0x4]
700af036: 6a40         	ldr	r0, [r0, #0x24]
700af038: b138         	cbz	r0, 0x700af04a <prvGetDisinheritPriorityAfterTimeout+0x1a> @ imm = #0xe
700af03a: e7ff         	b	0x700af03c <prvGetDisinheritPriorityAfterTimeout+0xc> @ imm = #-0x2
;             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
700af03c: 9801         	ldr	r0, [sp, #0x4]
700af03e: 6b00         	ldr	r0, [r0, #0x30]
700af040: 6800         	ldr	r0, [r0]
700af042: f1c0 0020    	rsb.w	r0, r0, #0x20
700af046: 9000         	str	r0, [sp]
;         }
700af048: e002         	b	0x700af050 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #0x4
700af04a: 2000         	movs	r0, #0x0
;             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
700af04c: 9000         	str	r0, [sp]
700af04e: e7ff         	b	0x700af050 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #-0x2
;         return uxHighestPriorityOfWaitingTasks;
700af050: 9800         	ldr	r0, [sp]
700af052: b002         	add	sp, #0x8
700af054: 4770         	bx	lr
		...
700af05e: 0000         	movs	r0, r0

700af060 <vTaskPlaceOnEventList>:
;                            const TickType_t xTicksToWait) {
700af060: b580         	push	{r7, lr}
700af062: b082         	sub	sp, #0x8
700af064: 9001         	str	r0, [sp, #0x4]
700af066: 9100         	str	r1, [sp]
;   vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
700af068: 9801         	ldr	r0, [sp, #0x4]
700af06a: f642 11fc    	movw	r1, #0x29fc
700af06e: f2c7 010b    	movt	r1, #0x700b
700af072: 6809         	ldr	r1, [r1]
700af074: 3118         	adds	r1, #0x18
700af076: f7fc fbbb    	bl	0x700ab7f0 <vListInsert> @ imm = #-0x388a
;   prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
700af07a: 9800         	ldr	r0, [sp]
700af07c: 2101         	movs	r1, #0x1
700af07e: f7f7 fb97    	bl	0x700a67b0 <prvAddCurrentTaskToDelayedList> @ imm = #-0x88d2
; }
700af082: b002         	add	sp, #0x8
700af084: bd80         	pop	{r7, pc}
		...
700af08e: 0000         	movs	r0, r0

700af090 <CSL_REG32_FEXT_RAW>:
; {
700af090: b580         	push	{r7, lr}
700af092: b084         	sub	sp, #0x10
700af094: 9003         	str	r0, [sp, #0xc]
700af096: 9102         	str	r1, [sp, #0x8]
700af098: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af09a: 9803         	ldr	r0, [sp, #0xc]
700af09c: f000 fdb0    	bl	0x700afc00 <CSL_REG32_RD_RAW> @ imm = #0xb60
700af0a0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af0a2: 9800         	ldr	r0, [sp]
700af0a4: 9902         	ldr	r1, [sp, #0x8]
700af0a6: 4008         	ands	r0, r1
700af0a8: 9901         	ldr	r1, [sp, #0x4]
700af0aa: 40c8         	lsrs	r0, r1
700af0ac: 9000         	str	r0, [sp]
;     return (regVal);
700af0ae: 9800         	ldr	r0, [sp]
700af0b0: b004         	add	sp, #0x10
700af0b2: bd80         	pop	{r7, pc}
		...

700af0c0 <CSL_REG32_FEXT_RAW>:
; {
700af0c0: b580         	push	{r7, lr}
700af0c2: b084         	sub	sp, #0x10
700af0c4: 9003         	str	r0, [sp, #0xc]
700af0c6: 9102         	str	r1, [sp, #0x8]
700af0c8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af0ca: 9803         	ldr	r0, [sp, #0xc]
700af0cc: f000 fda0    	bl	0x700afc10 <CSL_REG32_RD_RAW> @ imm = #0xb40
700af0d0: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af0d2: 9800         	ldr	r0, [sp]
700af0d4: 9902         	ldr	r1, [sp, #0x8]
700af0d6: 4008         	ands	r0, r1
700af0d8: 9901         	ldr	r1, [sp, #0x4]
700af0da: 40c8         	lsrs	r0, r1
700af0dc: 9000         	str	r0, [sp]
;     return (regVal);
700af0de: 9800         	ldr	r0, [sp]
700af0e0: b004         	add	sp, #0x10
700af0e2: bd80         	pop	{r7, pc}
		...

700af0f0 <CSL_REG32_FEXT_RAW>:
; {
700af0f0: b580         	push	{r7, lr}
700af0f2: b084         	sub	sp, #0x10
700af0f4: 9003         	str	r0, [sp, #0xc]
700af0f6: 9102         	str	r1, [sp, #0x8]
700af0f8: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af0fa: 9803         	ldr	r0, [sp, #0xc]
700af0fc: f000 fd90    	bl	0x700afc20 <CSL_REG32_RD_RAW> @ imm = #0xb20
700af100: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af102: 9800         	ldr	r0, [sp]
700af104: 9902         	ldr	r1, [sp, #0x8]
700af106: 4008         	ands	r0, r1
700af108: 9901         	ldr	r1, [sp, #0x4]
700af10a: 40c8         	lsrs	r0, r1
700af10c: 9000         	str	r0, [sp]
;     return (regVal);
700af10e: 9800         	ldr	r0, [sp]
700af110: b004         	add	sp, #0x10
700af112: bd80         	pop	{r7, pc}
		...

700af120 <CSL_REG32_FEXT_RAW>:
; {
700af120: b580         	push	{r7, lr}
700af122: b084         	sub	sp, #0x10
700af124: 9003         	str	r0, [sp, #0xc]
700af126: 9102         	str	r1, [sp, #0x8]
700af128: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af12a: 9803         	ldr	r0, [sp, #0xc]
700af12c: f000 fd80    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0xb00
700af130: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af132: 9800         	ldr	r0, [sp]
700af134: 9902         	ldr	r1, [sp, #0x8]
700af136: 4008         	ands	r0, r1
700af138: 9901         	ldr	r1, [sp, #0x4]
700af13a: 40c8         	lsrs	r0, r1
700af13c: 9000         	str	r0, [sp]
;     return (regVal);
700af13e: 9800         	ldr	r0, [sp]
700af140: b004         	add	sp, #0x10
700af142: bd80         	pop	{r7, pc}
		...

700af150 <CSL_REG32_FEXT_RAW>:
; {
700af150: b580         	push	{r7, lr}
700af152: b084         	sub	sp, #0x10
700af154: 9003         	str	r0, [sp, #0xc]
700af156: 9102         	str	r1, [sp, #0x8]
700af158: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = CSL_REG32_RD_RAW(p);
700af15a: 9803         	ldr	r0, [sp, #0xc]
700af15c: f000 fd70    	bl	0x700afc40 <CSL_REG32_RD_RAW> @ imm = #0xae0
700af160: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af162: 9800         	ldr	r0, [sp]
700af164: 9902         	ldr	r1, [sp, #0x8]
700af166: 4008         	ands	r0, r1
700af168: 9901         	ldr	r1, [sp, #0x4]
700af16a: 40c8         	lsrs	r0, r1
700af16c: 9000         	str	r0, [sp]
;     return (regVal);
700af16e: 9800         	ldr	r0, [sp]
700af170: b004         	add	sp, #0x10
700af172: bd80         	pop	{r7, pc}
		...

700af180 <SOC_getSelfCpuClk>:
; {
700af180: b580         	push	{r7, lr}
700af182: b084         	sub	sp, #0x10
700af184: 2000         	movs	r0, #0x0
;     uint64_t cpuClockRate = 0U;
700af186: 9001         	str	r0, [sp, #0x4]
700af188: 9003         	str	r0, [sp, #0xc]
700af18a: 9002         	str	r0, [sp, #0x8]
;                     Sciclient_getSelfDevIdCore(),
700af18c: f000 fd70    	bl	0x700afc70 <Sciclient_getSelfDevIdCore> @ imm = #0xae0
700af190: 9901         	ldr	r1, [sp, #0x4]
700af192: aa02         	add	r2, sp, #0x8
700af194: f04f 33ff    	mov.w	r3, #0xffffffff
;     Sciclient_pmGetModuleClkFreq(
700af198: f7f9 feda    	bl	0x700a8f50 <Sciclient_pmGetModuleClkFreq> @ imm = #-0x624c
;     return cpuClockRate;
700af19c: 9802         	ldr	r0, [sp, #0x8]
700af19e: 9903         	ldr	r1, [sp, #0xc]
700af1a0: b004         	add	sp, #0x10
700af1a2: bd80         	pop	{r7, pc}
		...

700af1b0 <UART_IsStopBitsValid>:
; {
700af1b0: b082         	sub	sp, #0x8
700af1b2: 9001         	str	r0, [sp, #0x4]
700af1b4: f06f 0002    	mvn	r0, #0x2
;     int32_t status = UART_INVALID_PARAM;
700af1b8: 9000         	str	r0, [sp]
;     if((stopBits == UART_STOPBITS_1) ||
700af1ba: 9801         	ldr	r0, [sp, #0x4]
700af1bc: b120         	cbz	r0, 0x700af1c8 <UART_IsStopBitsValid+0x18> @ imm = #0x8
700af1be: e7ff         	b	0x700af1c0 <UART_IsStopBitsValid+0x10> @ imm = #-0x2
;         (stopBits == UART_STOPBITS_2))
700af1c0: 9801         	ldr	r0, [sp, #0x4]
;     if((stopBits == UART_STOPBITS_1) ||
700af1c2: 2801         	cmp	r0, #0x1
700af1c4: d103         	bne	0x700af1ce <UART_IsStopBitsValid+0x1e> @ imm = #0x6
700af1c6: e7ff         	b	0x700af1c8 <UART_IsStopBitsValid+0x18> @ imm = #-0x2
700af1c8: 2000         	movs	r0, #0x0
;         status = UART_STATUS_SUCCESS;
700af1ca: 9000         	str	r0, [sp]
;     }
700af1cc: e7ff         	b	0x700af1ce <UART_IsStopBitsValid+0x1e> @ imm = #-0x2
;     return status;
700af1ce: 9800         	ldr	r0, [sp]
700af1d0: b002         	add	sp, #0x8
700af1d2: 4770         	bx	lr

700af1d4 <__aeabi_uldivmod>:
700af1d4: e92d4040     	push	{r6, lr}
700af1d8: e24dd010     	sub	sp, sp, #16
700af1dc: e28d6008     	add	r6, sp, #8
700af1e0: e58d6000     	str	r6, [sp]
700af1e4: ebffd5cf     	bl	0x700a4928 <__udivmoddi4> @ imm = #-0xa8c4
700af1e8: e59d2008     	ldr	r2, [sp, #0x8]
700af1ec: e59d300c     	ldr	r3, [sp, #0xc]
700af1f0: e28dd010     	add	sp, sp, #16
700af1f4: e8bd8040     	pop	{r6, pc}
		...

700af200 <_out_char>:
; {
700af200: b580         	push	{r7, lr}
700af202: b084         	sub	sp, #0x10
700af204: f88d 000f    	strb.w	r0, [sp, #0xf]
700af208: 9102         	str	r1, [sp, #0x8]
700af20a: 9201         	str	r2, [sp, #0x4]
700af20c: 9300         	str	r3, [sp]
;   if (character) {
700af20e: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700af212: b128         	cbz	r0, 0x700af220 <_out_char+0x20> @ imm = #0xa
700af214: e7ff         	b	0x700af216 <_out_char+0x16> @ imm = #-0x2
;     putchar_(character);
700af216: f89d 000f    	ldrb.w	r0, [sp, #0xf]
700af21a: f000 fc19    	bl	0x700afa50 <putchar_>   @ imm = #0x832
;   }
700af21e: e7ff         	b	0x700af220 <_out_char+0x20> @ imm = #-0x2
; }
700af220: b004         	add	sp, #0x10
700af222: bd80         	pop	{r7, pc}
		...

700af230 <tm_queue_create>:
; {
700af230: b510         	push	{r4, lr}
700af232: 4604         	mov	r4, r0
;    tm_queue_array[queue_id] = xQueueCreate(10, MESSAGE_SIZE * sizeof(int32_t));
700af234: 200a         	movs	r0, #0xa
700af236: 2180         	movs	r1, #0x80
700af238: 2200         	movs	r2, #0x0
700af23a: f7fd fc79    	bl	0x700acb30 <xQueueGenericCreate> @ imm = #-0x270e
700af23e: 4601         	mov	r1, r0
;    if (tm_queue_array[queue_id] == NULL)
700af240: fab0 f080    	clz	r0, r0
;    tm_queue_array[queue_id] = xQueueCreate(10, MESSAGE_SIZE * sizeof(int32_t));
700af244: f245 22b4    	movw	r2, #0x52b4
700af248: f2c7 0208    	movt	r2, #0x7008
;    if (tm_queue_array[queue_id] == NULL)
700af24c: 0940         	lsrs	r0, r0, #0x5
;    tm_queue_array[queue_id] = xQueueCreate(10, MESSAGE_SIZE * sizeof(int32_t));
700af24e: f842 1024    	str.w	r1, [r2, r4, lsl #2]
; }
700af252: bd10         	pop	{r4, pc}
		...

700af260 <vTaskInternalSetTimeOutState>:
; void vTaskInternalSetTimeOutState(TimeOut_t *const pxTimeOut) {
700af260: b081         	sub	sp, #0x4
700af262: 9000         	str	r0, [sp]
;   pxTimeOut->xOverflowCount = xNumOfOverflows;
700af264: f642 2038    	movw	r0, #0x2a38
700af268: f2c7 000b    	movt	r0, #0x700b
700af26c: 6800         	ldr	r0, [r0]
700af26e: 9900         	ldr	r1, [sp]
700af270: 6008         	str	r0, [r1]
;   pxTimeOut->xTimeOnEntering = xTickCount;
700af272: f642 2044    	movw	r0, #0x2a44
700af276: f2c7 000b    	movt	r0, #0x700b
700af27a: 6800         	ldr	r0, [r0]
700af27c: 9900         	ldr	r1, [sp]
700af27e: 6048         	str	r0, [r1, #0x4]
; }
700af280: b001         	add	sp, #0x4
700af282: 4770         	bx	lr
		...

700af290 <Pinmux_init>:
; {
700af290: b580         	push	{r7, lr}
;     Pinmux_config(gPinMuxMainDomainCfg, PINMUX_DOMAIN_ID_MAIN);
700af292: f642 1018    	movw	r0, #0x2918
700af296: 2100         	movs	r1, #0x0
700af298: f2c7 000b    	movt	r0, #0x700b
700af29c: f7f9 fd68    	bl	0x700a8d70 <Pinmux_config> @ imm = #-0x6530
;     Pinmux_config(gPinMuxMcuDomainCfg, PINMUX_DOMAIN_ID_MCU);
700af2a0: f642 108c    	movw	r0, #0x298c
700af2a4: 2101         	movs	r1, #0x1
700af2a6: f2c7 000b    	movt	r0, #0x700b
700af2aa: e8bd 4080    	pop.w	{r7, lr}
700af2ae: f7f9 bd5f    	b.w	0x700a8d70 <Pinmux_config> @ imm = #-0x6542
		...
700af2be: 0000         	movs	r0, r0

700af2c0 <Udma_rmTranslateCoreIntrInput>:
; {
700af2c0: b083         	sub	sp, #0xc
700af2c2: 9002         	str	r0, [sp, #0x8]
700af2c4: 9101         	str	r1, [sp, #0x4]
700af2c6: 2000         	movs	r0, #0x0
700af2c8: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    irIntrNum = UDMA_INTR_INVALID;
700af2cc: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700af2ce: 9802         	ldr	r0, [sp, #0x8]
700af2d0: 6800         	ldr	r0, [r0]
700af2d2: b118         	cbz	r0, 0x700af2dc <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #0x6
700af2d4: e7ff         	b	0x700af2d6 <Udma_rmTranslateCoreIntrInput+0x16> @ imm = #-0x2
;         irIntrNum = coreIntrNum;
700af2d6: 9801         	ldr	r0, [sp, #0x4]
700af2d8: 9000         	str	r0, [sp]
;     }
700af2da: e7ff         	b	0x700af2dc <Udma_rmTranslateCoreIntrInput+0x1c> @ imm = #-0x2
;     return (irIntrNum);
700af2dc: 9800         	ldr	r0, [sp]
700af2de: b003         	add	sp, #0xc
700af2e0: 4770         	bx	lr
		...
700af2ee: 0000         	movs	r0, r0

700af2f0 <Udma_rmTranslateIrOutput>:
; {
700af2f0: b083         	sub	sp, #0xc
700af2f2: 9002         	str	r0, [sp, #0x8]
700af2f4: 9101         	str	r1, [sp, #0x4]
700af2f6: 2000         	movs	r0, #0x0
700af2f8: f6cf 70ff    	movt	r0, #0xffff
;     uint32_t    coreIntrNum = UDMA_INTR_INVALID;
700af2fc: 9000         	str	r0, [sp]
;     if(drvHandle->instType != UDMA_INST_TYPE_NORMAL)
700af2fe: 9802         	ldr	r0, [sp, #0x8]
700af300: 6800         	ldr	r0, [r0]
700af302: b118         	cbz	r0, 0x700af30c <Udma_rmTranslateIrOutput+0x1c> @ imm = #0x6
700af304: e7ff         	b	0x700af306 <Udma_rmTranslateIrOutput+0x16> @ imm = #-0x2
;         coreIntrNum = irIntrNum;
700af306: 9801         	ldr	r0, [sp, #0x4]
700af308: 9000         	str	r0, [sp]
;     }
700af30a: e7ff         	b	0x700af30c <Udma_rmTranslateIrOutput+0x1c> @ imm = #-0x2
;     return (coreIntrNum);
700af30c: 9800         	ldr	r0, [sp]
700af30e: b003         	add	sp, #0xc
700af310: 4770         	bx	lr
		...
700af31e: 0000         	movs	r0, r0

700af320 <ClockP_usecToTicks>:
; {
700af320: b580         	push	{r7, lr}
700af322: b082         	sub	sp, #0x8
700af324: 9101         	str	r1, [sp, #0x4]
700af326: 9000         	str	r0, [sp]
;     return (uint32_t)(usecs / gClockCtrl.usecPerTick);
700af328: 9800         	ldr	r0, [sp]
700af32a: 9901         	ldr	r1, [sp, #0x4]
700af32c: f245 1290    	movw	r2, #0x5190
700af330: f2c7 0208    	movt	r2, #0x7008
700af334: 6892         	ldr	r2, [r2, #0x8]
700af336: 2300         	movs	r3, #0x0
700af338: f7ff ef4c    	blx	0x700af1d4 <__aeabi_uldivmod> @ imm = #-0x168
700af33c: b002         	add	sp, #0x8
700af33e: bd80         	pop	{r7, pc}

700af340 <HW_RD_FIELD32_RAW>:
; {
700af340: b084         	sub	sp, #0x10
700af342: 9003         	str	r0, [sp, #0xc]
700af344: 9102         	str	r1, [sp, #0x8]
700af346: 9201         	str	r2, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700af348: 9803         	ldr	r0, [sp, #0xc]
700af34a: 6800         	ldr	r0, [r0]
700af34c: 9000         	str	r0, [sp]
;     regVal = (regVal & mask) >> shift;
700af34e: 9800         	ldr	r0, [sp]
700af350: 9902         	ldr	r1, [sp, #0x8]
700af352: 4008         	ands	r0, r1
700af354: 9901         	ldr	r1, [sp, #0x4]
700af356: 40c8         	lsrs	r0, r1
700af358: 9000         	str	r0, [sp]
;     return (regVal);
700af35a: 9800         	ldr	r0, [sp]
700af35c: b004         	add	sp, #0x10
700af35e: 4770         	bx	lr

700af360 <Sciclient_getRxThreadId>:
; {
700af360: b082         	sub	sp, #0x8
700af362: 9001         	str	r0, [sp, #0x4]
;     rxThread = gSciclientMap[contextId].respThreadId;
700af364: 9801         	ldr	r0, [sp, #0x4]
700af366: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af36a: f241 3060    	movw	r0, #0x1360
700af36e: f2c7 000b    	movt	r0, #0x700b
700af372: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700af376: 68c0         	ldr	r0, [r0, #0xc]
700af378: 9000         	str	r0, [sp]
;     return rxThread;
700af37a: 9800         	ldr	r0, [sp]
700af37c: b002         	add	sp, #0x8
700af37e: 4770         	bx	lr

700af380 <Sciclient_getTxThreadId>:
; {
700af380: b082         	sub	sp, #0x8
700af382: 9001         	str	r0, [sp, #0x4]
;     txThread = gSciclientMap[contextId].reqLowPrioThreadId;
700af384: 9801         	ldr	r0, [sp, #0x4]
700af386: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af38a: f241 3060    	movw	r0, #0x1360
700af38e: f2c7 000b    	movt	r0, #0x700b
700af392: eb00 00c1    	add.w	r0, r0, r1, lsl #3
700af396: 6880         	ldr	r0, [r0, #0x8]
700af398: 9000         	str	r0, [sp]
;     return txThread;
700af39a: 9800         	ldr	r0, [sp]
700af39c: b002         	add	sp, #0x8
700af39e: 4770         	bx	lr

700af3a0 <vPortFree>:
; {
700af3a0: b580         	push	{r7, lr}
700af3a2: b082         	sub	sp, #0x8
700af3a4: 9001         	str	r0, [sp, #0x4]
;     if( pv )
700af3a6: 9801         	ldr	r0, [sp, #0x4]
700af3a8: b140         	cbz	r0, 0x700af3bc <vPortFree+0x1c> @ imm = #0x10
700af3aa: e7ff         	b	0x700af3ac <vPortFree+0xc> @ imm = #-0x2
;         vTaskSuspendAll();
700af3ac: f000 fc08    	bl	0x700afbc0 <vTaskSuspendAll> @ imm = #0x810
;             free( pv );
700af3b0: 9801         	ldr	r0, [sp, #0x4]
700af3b2: f7f0 eec0    	blx	0x700a0134 <free>       @ imm = #-0xf280
;         ( void ) xTaskResumeAll();
700af3b6: f7f2 ff6b    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0xd12a
;     }
700af3ba: e7ff         	b	0x700af3bc <vPortFree+0x1c> @ imm = #-0x2
; }
700af3bc: b002         	add	sp, #0x8
700af3be: bd80         	pop	{r7, pc}

700af3c0 <wcslen>:
700af3c0: e3a01000     	mov	r1, #0
700af3c4: e7902001     	ldr	r2, [r0, r1]
700af3c8: e2811004     	add	r1, r1, #4
700af3cc: e3520000     	cmp	r2, #0
700af3d0: 1afffffb     	bne	0x700af3c4 <wcslen+0x4> @ imm = #-0x14
700af3d4: e2410004     	sub	r0, r1, #4
700af3d8: e1a00140     	asr	r0, r0, #2
700af3dc: e12fff1e     	bx	lr

700af3e0 <CSL_udmapCppi5SetEpiDataPresent>:
; {
700af3e0: b082         	sub	sp, #0x8
700af3e2: 9001         	str	r0, [sp, #0x4]
700af3e4: f88d 1003    	strb.w	r1, [sp, #0x3]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_EINFO, (bEpiDataPresent==(bool)true) ? (uint32_t)1U : (uint32_t)0U );
700af3e8: 9901         	ldr	r1, [sp, #0x4]
700af3ea: 6808         	ldr	r0, [r1]
700af3ec: f020 5000    	bic	r0, r0, #0x20000000
700af3f0: f89d 2003    	ldrb.w	r2, [sp, #0x3]
700af3f4: f362 705d    	bfi	r0, r2, #29, #1
700af3f8: 6008         	str	r0, [r1]
; }
700af3fa: b002         	add	sp, #0x8
700af3fc: 4770         	bx	lr
700af3fe: 0000         	movs	r0, r0

700af400 <DebugP_memLogWriterInit>:
; {
700af400: b580         	push	{r7, lr}
700af402: b082         	sub	sp, #0x8
700af404: f8ad 0006    	strh.w	r0, [sp, #0x6]
;     gDebugP_memTraceLogWriterSelfCoreName = SOC_getCoreName(selfCoreId);
700af408: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
700af40c: f7fe ff78    	bl	0x700ae300 <SOC_getCoreName> @ imm = #-0x1110
700af410: f642 11e0    	movw	r1, #0x29e0
700af414: f2c7 010b    	movt	r1, #0x700b
700af418: 6008         	str	r0, [r1]
; }
700af41a: b002         	add	sp, #0x8
700af41c: bd80         	pop	{r7, pc}
700af41e: 0000         	movs	r0, r0

700af420 <Sciclient_rmPsGetIrqNode>:
; {
700af420: b081         	sub	sp, #0x4
700af422: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return gPstack.ps[index].p_n;
700af426: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700af42a: eb00 0140    	add.w	r1, r0, r0, lsl #1
700af42e: f241 0058    	movw	r0, #0x1058
700af432: f2c7 0008    	movt	r0, #0x7008
700af436: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
700af43a: b001         	add	sp, #0x4
700af43c: 4770         	bx	lr
700af43e: 0000         	movs	r0, r0

700af440 <Sciclient_rmPsInit>:
; {
700af440: b580         	push	{r7, lr}
700af442: b082         	sub	sp, #0x8
;     memset(&gPstack.ps[0], 0, sizeof(gPstack.ps));
700af444: f241 0058    	movw	r0, #0x1058
700af448: f2c7 0008    	movt	r0, #0x7008
700af44c: 9001         	str	r0, [sp, #0x4]
700af44e: 2124         	movs	r1, #0x24
700af450: f7eb ee60    	blx	0x7009b114 <__aeabi_memclr8> @ imm = #-0x14340
700af454: 9901         	ldr	r1, [sp, #0x4]
700af456: 2000         	movs	r0, #0x0
;     gPstack.psp = 0;
700af458: 8488         	strh	r0, [r1, #0x24]
; }
700af45a: b002         	add	sp, #0x8
700af45c: bd80         	pop	{r7, pc}
700af45e: 0000         	movs	r0, r0

700af460 <UART_breakCtl>:
; {
700af460: b580         	push	{r7, lr}
700af462: b082         	sub	sp, #0x8
700af464: 9001         	str	r0, [sp, #0x4]
700af466: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_BREAK_EN,
700af468: 9801         	ldr	r0, [sp, #0x4]
700af46a: 300c         	adds	r0, #0xc
700af46c: 9900         	ldr	r1, [sp]
700af46e: ea4f 1391    	lsr.w	r3, r1, #0x6
700af472: 2140         	movs	r1, #0x40
700af474: 2206         	movs	r2, #0x6
700af476: f7ff f91b    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #-0xdca
; }
700af47a: b002         	add	sp, #0x8
700af47c: bd80         	pop	{r7, pc}
700af47e: 0000         	movs	r0, r0

700af480 <UART_lld_Transaction_deInit>:
; {
700af480: b081         	sub	sp, #0x4
700af482: 9000         	str	r0, [sp]
;     trans->buf              = NULL;
700af484: 9900         	ldr	r1, [sp]
700af486: 2000         	movs	r0, #0x0
700af488: 6008         	str	r0, [r1]
;     trans->count            = 0U;
700af48a: 9900         	ldr	r1, [sp]
700af48c: 6048         	str	r0, [r1, #0x4]
;     trans->timeout          = 0U;
700af48e: 9900         	ldr	r1, [sp]
700af490: 6088         	str	r0, [r1, #0x8]
;     trans->status           = UART_STATUS_SUCCESS;
700af492: 9900         	ldr	r1, [sp]
700af494: 60c8         	str	r0, [r1, #0xc]
;     trans->args             = NULL;
700af496: 9900         	ldr	r1, [sp]
700af498: 6108         	str	r0, [r1, #0x10]
; }
700af49a: b001         	add	sp, #0x4
700af49c: 4770         	bx	lr
700af49e: 0000         	movs	r0, r0

700af4a0 <UART_writeInterrupt>:
; {
700af4a0: b580         	push	{r7, lr}
700af4a2: b084         	sub	sp, #0x10
700af4a4: 9003         	str	r0, [sp, #0xc]
700af4a6: 2000         	movs	r0, #0x0
;     int32_t     status = UART_STATUS_SUCCESS;
700af4a8: 9002         	str	r0, [sp, #0x8]
;     baseAddr = hUart->baseAddr;
700af4aa: 9803         	ldr	r0, [sp, #0xc]
700af4ac: 6800         	ldr	r0, [r0]
700af4ae: 9001         	str	r0, [sp, #0x4]
;     UART_intrEnable(baseAddr, UART_INTR_THR);
700af4b0: 9801         	ldr	r0, [sp, #0x4]
700af4b2: 2102         	movs	r1, #0x2
700af4b4: f7f6 fe6c    	bl	0x700a6190 <UART_intrEnable> @ imm = #-0x9328
;     return status;
700af4b8: 9802         	ldr	r0, [sp, #0x8]
700af4ba: b004         	add	sp, #0x10
700af4bc: bd80         	pop	{r7, pc}
700af4be: 0000         	movs	r0, r0

700af4c0 <UdmaChPdmaPrms_init>:
; {
700af4c0: b081         	sub	sp, #0x4
700af4c2: 9000         	str	r0, [sp]
;     if(NULL_PTR != pdmaPrms)
700af4c4: 9800         	ldr	r0, [sp]
700af4c6: b140         	cbz	r0, 0x700af4da <UdmaChPdmaPrms_init+0x1a> @ imm = #0x10
700af4c8: e7ff         	b	0x700af4ca <UdmaChPdmaPrms_init+0xa> @ imm = #-0x2
;         pdmaPrms->elemSize  = UDMA_PDMA_ES_8BITS;
700af4ca: 9900         	ldr	r1, [sp]
700af4cc: 2000         	movs	r0, #0x0
700af4ce: 6008         	str	r0, [r1]
;         pdmaPrms->elemCnt   = 0U;
700af4d0: 9900         	ldr	r1, [sp]
700af4d2: 6048         	str	r0, [r1, #0x4]
;         pdmaPrms->fifoCnt   = 0U;
700af4d4: 9900         	ldr	r1, [sp]
700af4d6: 6088         	str	r0, [r1, #0x8]
;     }
700af4d8: e7ff         	b	0x700af4da <UdmaChPdmaPrms_init+0x1a> @ imm = #-0x2
;     return;
700af4da: b001         	add	sp, #0x4
700af4dc: 4770         	bx	lr
700af4de: 0000         	movs	r0, r0

700af4e0 <prvTimerTask>:
;     {
700af4e0: b580         	push	{r7, lr}
700af4e2: b084         	sub	sp, #0x10
700af4e4: 9003         	str	r0, [sp, #0xc]
;         for( ; ; )
700af4e6: e7ff         	b	0x700af4e8 <prvTimerTask+0x8> @ imm = #-0x2
700af4e8: a801         	add	r0, sp, #0x4
;             xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
700af4ea: f7fe fc29    	bl	0x700add40 <prvGetNextExpireTime> @ imm = #-0x17ae
700af4ee: 9002         	str	r0, [sp, #0x8]
;             prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
700af4f0: 9802         	ldr	r0, [sp, #0x8]
700af4f2: 9901         	ldr	r1, [sp, #0x4]
700af4f4: f7fb f894    	bl	0x700aa620 <prvProcessTimerOrBlockTask> @ imm = #-0x4ed8
;             prvProcessReceivedCommands();
700af4f8: f7f3 fb4a    	bl	0x700a2b90 <prvProcessReceivedCommands> @ imm = #-0xc96c
;         for( ; ; )
700af4fc: e7f4         	b	0x700af4e8 <prvTimerTask+0x8> @ imm = #-0x18
700af4fe: 0000         	movs	r0, r0

700af500 <tm_queue_receive>:
; {
700af500: b580         	push	{r7, lr}
;    status = xQueueReceive(tm_queue_array[queue_id], (void* const) message_ptr, portMAX_DELAY);
700af502: f245 22b4    	movw	r2, #0x52b4
700af506: f2c7 0208    	movt	r2, #0x7008
700af50a: f852 0020    	ldr.w	r0, [r2, r0, lsl #2]
700af50e: f04f 32ff    	mov.w	r2, #0xffffffff
700af512: f7f4 f8b5    	bl	0x700a3680 <xQueueReceive> @ imm = #-0xbe96
;    if (status != pdTRUE)
700af516: 3801         	subs	r0, #0x1
700af518: bf18         	it	ne
700af51a: 2001         	movne	r0, #0x1
; }
700af51c: bd80         	pop	{r7, pc}
700af51e: 0000         	movs	r0, r0

700af520 <xPortStartScheduler>:
; BaseType_t xPortStartScheduler(void) {
700af520: b580         	push	{r7, lr}
700af522: b082         	sub	sp, #0x8
;     __asm__ volatile ( "CPSID	i" ::: "cc" );
700af524: b672         	cpsid i
;   ulPortSchedularRunning = pdTRUE;
700af526: f642 2110    	movw	r1, #0x2a10
700af52a: f2c7 010b    	movt	r1, #0x700b
700af52e: 2001         	movs	r0, #0x1
700af530: 9001         	str	r0, [sp, #0x4]
700af532: 6008         	str	r0, [r1]
;   vPortRestoreTaskContext();
700af534: f001 e91e    	blx	0x700b0774 <vPortRestoreTaskContext> @ imm = #0x123c
700af538: 9801         	ldr	r0, [sp, #0x4]
;   return pdTRUE;
700af53a: b002         	add	sp, #0x8
700af53c: bd80         	pop	{r7, pc}
700af53e: 0000         	movs	r0, r0

700af540 <xTaskGetTickCount>:
; TickType_t xTaskGetTickCount(void) {
700af540: b580         	push	{r7, lr}
700af542: b082         	sub	sp, #0x8
;   portTICK_TYPE_ENTER_CRITICAL();
700af544: f7ff f914    	bl	0x700ae770 <vTaskEnterCritical> @ imm = #-0xdd8
;     xTicks = xTickCount;
700af548: f642 2044    	movw	r0, #0x2a44
700af54c: f2c7 000b    	movt	r0, #0x700b
700af550: 6800         	ldr	r0, [r0]
700af552: 9001         	str	r0, [sp, #0x4]
;   portTICK_TYPE_EXIT_CRITICAL();
700af554: f7fe f9cc    	bl	0x700ad8f0 <vTaskExitCritical> @ imm = #-0x1c68
;   return xTicks;
700af558: 9801         	ldr	r0, [sp, #0x4]
700af55a: b002         	add	sp, #0x8
700af55c: bd80         	pop	{r7, pc}
700af55e: 0000         	movs	r0, r0

700af560 <CSL_secProxyGetDataAddr>:
; {
700af560: b084         	sub	sp, #0x10
700af562: 9003         	str	r0, [sp, #0xc]
700af564: 9102         	str	r1, [sp, #0x8]
700af566: 9201         	str	r2, [sp, #0x4]
;     dataAddr = (uintptr_t)pSecProxyCfg->proxyTargetAddr + ((uintptr_t)threadNum * CSL_SEC_PROXY_TARGET_CHAN_SIZE) + (uintptr_t)CSL_SEC_PROXY_RSVD_MSG_BYTES;
700af568: 9803         	ldr	r0, [sp, #0xc]
700af56a: 6900         	ldr	r0, [r0, #0x10]
700af56c: 9902         	ldr	r1, [sp, #0x8]
700af56e: eb00 3001    	add.w	r0, r0, r1, lsl #12
700af572: 3004         	adds	r0, #0x4
700af574: 9000         	str	r0, [sp]
;     return dataAddr;
700af576: 9800         	ldr	r0, [sp]
700af578: b004         	add	sp, #0x10
700af57a: 4770         	bx	lr
700af57c: 0000         	movs	r0, r0
700af57e: 0000         	movs	r0, r0

700af580 <UART_IsParameter>:
; {
700af580: b082         	sub	sp, #0x8
700af582: 9001         	str	r0, [sp, #0x4]
700af584: 2000         	movs	r0, #0x0
;     int32_t status = UART_STATUS_SUCCESS;
700af586: 9000         	str	r0, [sp]
;     if(InuptParameter == 0U)
700af588: 9801         	ldr	r0, [sp, #0x4]
700af58a: b920         	cbnz	r0, 0x700af596 <UART_IsParameter+0x16> @ imm = #0x8
700af58c: e7ff         	b	0x700af58e <UART_IsParameter+0xe> @ imm = #-0x2
700af58e: f06f 0002    	mvn	r0, #0x2
;         status = UART_INVALID_PARAM;
700af592: 9000         	str	r0, [sp]
;     }
700af594: e7ff         	b	0x700af596 <UART_IsParameter+0x16> @ imm = #-0x2
;     return status;
700af596: 9800         	ldr	r0, [sp]
700af598: b002         	add	sp, #0x8
700af59a: 4770         	bx	lr
700af59c: 0000         	movs	r0, r0
700af59e: 0000         	movs	r0, r0

700af5a0 <pvPortMalloc>:
; {
700af5a0: b580         	push	{r7, lr}
700af5a2: b082         	sub	sp, #0x8
700af5a4: 9001         	str	r0, [sp, #0x4]
;     vTaskSuspendAll();
700af5a6: f000 fb0b    	bl	0x700afbc0 <vTaskSuspendAll> @ imm = #0x616
;         pvReturn = malloc( xWantedSize );
700af5aa: 9801         	ldr	r0, [sp, #0x4]
700af5ac: f7ed eea2    	blx	0x7009d2f4 <malloc>     @ imm = #-0x122bc
700af5b0: 9000         	str	r0, [sp]
;     ( void ) xTaskResumeAll();
700af5b2: f7f2 fe6d    	bl	0x700a2290 <xTaskResumeAll> @ imm = #-0xd326
;     return pvReturn;
700af5b6: 9800         	ldr	r0, [sp]
700af5b8: b002         	add	sp, #0x8
700af5ba: bd80         	pop	{r7, pc}

700af5bc <strlen>:
700af5bc: e3a01000     	mov	r1, #0
700af5c0: e7d02001     	ldrb	r2, [r0, r1]
700af5c4: e2811001     	add	r1, r1, #1
700af5c8: e3520000     	cmp	r2, #0
700af5cc: 1afffffb     	bne	0x700af5c0 <strlen+0x4> @ imm = #-0x14
700af5d0: e2410001     	sub	r0, r1, #1
700af5d4: e12fff1e     	bx	lr
		...

700af5e0 <vPortYeildFromISR>:
; void vPortYeildFromISR(uint32_t xSwitchRequired) {
700af5e0: b081         	sub	sp, #0x4
700af5e2: 9000         	str	r0, [sp]
;   if (xSwitchRequired != pdFALSE) {
700af5e4: 9800         	ldr	r0, [sp]
700af5e6: b138         	cbz	r0, 0x700af5f8 <vPortYeildFromISR+0x18> @ imm = #0xe
700af5e8: e7ff         	b	0x700af5ea <vPortYeildFromISR+0xa> @ imm = #-0x2
;     ulPortYieldRequired = pdTRUE;
700af5ea: f642 2118    	movw	r1, #0x2a18
700af5ee: f2c7 010b    	movt	r1, #0x700b
700af5f2: 2001         	movs	r0, #0x1
700af5f4: 6008         	str	r0, [r1]
;   }
700af5f6: e7ff         	b	0x700af5f8 <vPortYeildFromISR+0x18> @ imm = #-0x2
; }
700af5f8: b001         	add	sp, #0x4
700af5fa: 4770         	bx	lr

700af5fc <TI_memcpy_small>:
700af5fc: e3a0c000     	mov	r12, #0

700af600 <_loop>:
700af600: e152000c     	cmp	r2, r12
700af604: 012fff1e     	bxeq	lr
700af608: e7d1300c     	ldrb	r3, [r1, r12]
700af60c: e7c0300c     	strb	r3, [r0, r12]
700af610: e28cc001     	add	r12, r12, #1
700af614: eafffff9     	b	0x700af600 <_loop>      @ imm = #-0x1c
		...

700af620 <CSL_udmapCppi5SetDescType>:
; {
700af620: b082         	sub	sp, #0x8
700af622: 9001         	str	r0, [sp, #0x4]
700af624: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_DTYPE, descType );
700af626: 9901         	ldr	r1, [sp, #0x4]
700af628: 6808         	ldr	r0, [r1]
700af62a: f020 4040    	bic	r0, r0, #0xc0000000
700af62e: 9a00         	ldr	r2, [sp]
700af630: ea40 7082    	orr.w	r0, r0, r2, lsl #30
700af634: 6008         	str	r0, [r1]
; }
700af636: b002         	add	sp, #0x8
700af638: 4770         	bx	lr
700af63a: 0000         	movs	r0, r0
700af63c: 0000         	movs	r0, r0
700af63e: 0000         	movs	r0, r0

700af640 <UART_fifoCharGet>:
; {
700af640: b580         	push	{r7, lr}
700af642: b082         	sub	sp, #0x8
700af644: 9001         	str	r0, [sp, #0x4]
700af646: 2000         	movs	r0, #0x0
;     uint32_t tempRetVal = 0U;
700af648: 9000         	str	r0, [sp]
;     tempRetVal = HW_RD_REG32(baseAddr + UART_RHR);
700af64a: 9801         	ldr	r0, [sp, #0x4]
700af64c: f000 fa90    	bl	0x700afb70 <HW_RD_REG32_RAW> @ imm = #0x520
700af650: 9000         	str	r0, [sp]
;     return ((uint8_t) tempRetVal);
700af652: f89d 0000    	ldrb.w	r0, [sp]
700af656: b002         	add	sp, #0x8
700af658: bd80         	pop	{r7, pc}
700af65a: 0000         	movs	r0, r0
700af65c: 0000         	movs	r0, r0
700af65e: 0000         	movs	r0, r0

700af660 <UART_timeGuardConfig>:
; {
700af660: b580         	push	{r7, lr}
700af662: b082         	sub	sp, #0x8
700af664: 9001         	str	r0, [sp, #0x4]
700af666: 9100         	str	r1, [sp]
;     HW_WR_FIELD32(baseAddr + UART_TIMEGUARD, UART_TIMEGUARD_TIMEGUARD,
700af668: 9801         	ldr	r0, [sp, #0x4]
700af66a: 3094         	adds	r0, #0x94
700af66c: 9b00         	ldr	r3, [sp]
700af66e: 21ff         	movs	r1, #0xff
700af670: 2200         	movs	r2, #0x0
700af672: f7ff f81d    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #-0xfc6
; }
700af676: b002         	add	sp, #0x8
700af678: bd80         	pop	{r7, pc}
700af67a: 0000         	movs	r0, r0
700af67c: 0000         	movs	r0, r0
700af67e: 0000         	movs	r0, r0

700af680 <CSL_udmapCppi5SetPsDataLen>:
; {
700af680: b082         	sub	sp, #0x8
700af682: 9001         	str	r0, [sp, #0x4]
700af684: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSWCNT, (psDataLen/4U) );
700af686: 9901         	ldr	r1, [sp, #0x4]
700af688: 6808         	ldr	r0, [r1]
700af68a: 9a00         	ldr	r2, [sp]
700af68c: 0892         	lsrs	r2, r2, #0x2
700af68e: f362 509b    	bfi	r0, r2, #22, #6
700af692: 6008         	str	r0, [r1]
; }
700af694: b002         	add	sp, #0x8
700af696: 4770         	bx	lr
		...

700af6a0 <Sciclient_rmIrqSet>:
; {
700af6a0: b580         	push	{r7, lr}
700af6a2: b084         	sub	sp, #0x10
700af6a4: 9003         	str	r0, [sp, #0xc]
700af6a6: 9102         	str	r1, [sp, #0x8]
700af6a8: 9201         	str	r2, [sp, #0x4]
;     return Sciclient_rmProgramInterruptRoute(req, resp, timeout);
700af6aa: 9803         	ldr	r0, [sp, #0xc]
700af6ac: 9902         	ldr	r1, [sp, #0x8]
700af6ae: 9a01         	ldr	r2, [sp, #0x4]
700af6b0: f7f1 fafe    	bl	0x700a0cb0 <Sciclient_rmProgramInterruptRoute> @ imm = #-0xea04
700af6b4: b004         	add	sp, #0x10
700af6b6: bd80         	pop	{r7, pc}
		...

700af6c0 <Sciclient_secProxyThreadStatusReg>:
; {
700af6c0: b081         	sub	sp, #0x4
700af6c2: 9000         	str	r0, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700af6c4: f642 00c0    	movw	r0, #0x28c0
700af6c8: f2c7 000b    	movt	r0, #0x700b
700af6cc: 6880         	ldr	r0, [r0, #0x8]
;         CSL_SEC_PROXY_RT_THREAD_STATUS(thread));
700af6ce: 9900         	ldr	r1, [sp]
;     return ((uint32_t)(uintptr_t)(gSciclientSecProxyCfg.pSecProxyRtRegs) +
700af6d0: eb00 3001    	add.w	r0, r0, r1, lsl #12
700af6d4: b001         	add	sp, #0x4
700af6d6: 4770         	bx	lr
		...

700af6e0 <TimerP_start>:
; {
700af6e0: b082         	sub	sp, #0x8
700af6e2: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (uint32_t *)(baseAddr + TIMER_TCLR);
700af6e4: 9801         	ldr	r0, [sp, #0x4]
700af6e6: 3038         	adds	r0, #0x38
700af6e8: 9000         	str	r0, [sp]
;     *addr |= (0x1U << 0);
700af6ea: 9900         	ldr	r1, [sp]
700af6ec: 6808         	ldr	r0, [r1]
700af6ee: f040 0001    	orr	r0, r0, #0x1
700af6f2: 6008         	str	r0, [r1]
; }
700af6f4: b002         	add	sp, #0x8
700af6f6: 4770         	bx	lr
		...

700af700 <TimerP_stop>:
; {
700af700: b082         	sub	sp, #0x8
700af702: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCLR);
700af704: 9801         	ldr	r0, [sp, #0x4]
700af706: 3038         	adds	r0, #0x38
700af708: 9000         	str	r0, [sp]
;     *addr &= ~(0x1U << 0);
700af70a: 9900         	ldr	r1, [sp]
700af70c: 6808         	ldr	r0, [r1]
700af70e: f020 0001    	bic	r0, r0, #0x1
700af712: 6008         	str	r0, [r1]
; }
700af714: b002         	add	sp, #0x8
700af716: 4770         	bx	lr
		...

700af720 <UART_divisorLatchDisable>:
; {
700af720: b580         	push	{r7, lr}
700af722: b082         	sub	sp, #0x8
700af724: 9001         	str	r0, [sp, #0x4]
;     HW_WR_FIELD32(baseAddr + UART_LCR, UART_LCR_DIV_EN,
700af726: 9801         	ldr	r0, [sp, #0x4]
700af728: 300c         	adds	r0, #0xc
700af72a: 2180         	movs	r1, #0x80
700af72c: 2207         	movs	r2, #0x7
700af72e: 2300         	movs	r3, #0x0
700af730: f7fe ffbe    	bl	0x700ae6b0 <HW_WR_FIELD32_RAW> @ imm = #-0x1084
; }
700af734: b002         	add	sp, #0x8
700af736: bd80         	pop	{r7, pc}
		...

700af740 <UART_modemControlReset>:
; {
700af740: b580         	push	{r7, lr}
700af742: b082         	sub	sp, #0x8
700af744: 9001         	str	r0, [sp, #0x4]
700af746: 2000         	movs	r0, #0x0
;     uint32_t mcrResetVal = 0U;
700af748: 9000         	str	r0, [sp]
;     HW_WR_REG32(baseAddr + UART_MCR, mcrResetVal);
700af74a: 9801         	ldr	r0, [sp, #0x4]
700af74c: 3010         	adds	r0, #0x10
700af74e: 9900         	ldr	r1, [sp]
700af750: f000 fa16    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x42c
; }
700af754: b002         	add	sp, #0x8
700af756: bd80         	pop	{r7, pc}
		...

700af760 <UART_putChar>:
; {
700af760: b580         	push	{r7, lr}
700af762: b082         	sub	sp, #0x8
700af764: 9001         	str	r0, [sp, #0x4]
700af766: f88d 1003    	strb.w	r1, [sp, #0x3]
;     HW_WR_REG32(baseAddr + UART_THR, (uint32_t) byteTx);
700af76a: 9801         	ldr	r0, [sp, #0x4]
700af76c: f89d 1003    	ldrb.w	r1, [sp, #0x3]
700af770: f000 fa06    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x40c
; }
700af774: b002         	add	sp, #0x8
700af776: bd80         	pop	{r7, pc}

700af778 <TI_memset_small>:
700af778: e3a03000     	mov	r3, #0

700af77c <_loop>:
700af77c: e1520003     	cmp	r2, r3
700af780: 012fff1e     	bxeq	lr
700af784: e7c01003     	strb	r1, [r0, r3]
700af788: e2833001     	add	r3, r3, #1
700af78c: eafffffa     	b	0x700af77c <_loop>      @ imm = #-0x18

700af790 <CSL_REG64_WR_RAW>:
; {
700af790: b084         	sub	sp, #0x10
700af792: 9003         	str	r0, [sp, #0xc]
700af794: 9301         	str	r3, [sp, #0x4]
700af796: 9200         	str	r2, [sp]
;     *p = v;
700af798: 9800         	ldr	r0, [sp]
700af79a: 9901         	ldr	r1, [sp, #0x4]
700af79c: 9a03         	ldr	r2, [sp, #0xc]
700af79e: e9c2 0100    	strd	r0, r1, [r2]
;     return;
700af7a2: b004         	add	sp, #0x10
700af7a4: 4770         	bx	lr
		...
700af7ae: 0000         	movs	r0, r0

700af7b0 <CSL_udmapCppi5LinkDesc>:
; {
700af7b0: b084         	sub	sp, #0x10
700af7b2: 9003         	str	r0, [sp, #0xc]
700af7b4: 9301         	str	r3, [sp, #0x4]
700af7b6: 9200         	str	r2, [sp]
;     pDesc->nextDescPtr = physBufferDescAddr;
700af7b8: 9800         	ldr	r0, [sp]
700af7ba: 9a01         	ldr	r2, [sp, #0x4]
700af7bc: 9903         	ldr	r1, [sp, #0xc]
700af7be: 614a         	str	r2, [r1, #0x14]
700af7c0: 6108         	str	r0, [r1, #0x10]
; }
700af7c2: b004         	add	sp, #0x10
700af7c4: 4770         	bx	lr
		...
700af7ce: 0000         	movs	r0, r0

700af7d0 <CSL_udmapCppi5SetBufferAddr>:
; {
700af7d0: b084         	sub	sp, #0x10
700af7d2: 9003         	str	r0, [sp, #0xc]
700af7d4: 9301         	str	r3, [sp, #0x4]
700af7d6: 9200         	str	r2, [sp]
;     pDesc->bufPtr    = physBufferAddr;
700af7d8: 9800         	ldr	r0, [sp]
700af7da: 9a01         	ldr	r2, [sp, #0x4]
700af7dc: 9903         	ldr	r1, [sp, #0xc]
700af7de: 61ca         	str	r2, [r1, #0x1c]
700af7e0: 6188         	str	r0, [r1, #0x18]
; }
700af7e2: b004         	add	sp, #0x10
700af7e4: 4770         	bx	lr
		...
700af7ee: 0000         	movs	r0, r0

700af7f0 <CSL_udmapCppi5SetBufferLen>:
; {
700af7f0: b082         	sub	sp, #0x8
700af7f2: 9001         	str	r0, [sp, #0x4]
700af7f4: 9100         	str	r1, [sp]
;     CSL_FINS( pDesc->bufInfo1, UDMAP_CPPI5_PD_BUFINFO1_LEN, bufferLenBytes );
700af7f6: 9901         	ldr	r1, [sp, #0x4]
700af7f8: 6a08         	ldr	r0, [r1, #0x20]
700af7fa: 9a00         	ldr	r2, [sp]
700af7fc: f362 0015    	bfi	r0, r2, #0, #22
700af800: 6208         	str	r0, [r1, #0x20]
; }
700af802: b002         	add	sp, #0x8
700af804: 4770         	bx	lr
		...
700af80e: 0000         	movs	r0, r0

700af810 <CSL_udmapCppi5SetOrgBufferAddr>:
; {
700af810: b084         	sub	sp, #0x10
700af812: 9003         	str	r0, [sp, #0xc]
700af814: 9301         	str	r3, [sp, #0x4]
700af816: 9200         	str	r2, [sp]
;     pDesc->orgBufPtr = physBufferAddr;
700af818: 9800         	ldr	r0, [sp]
700af81a: 9a01         	ldr	r2, [sp, #0x4]
700af81c: 9903         	ldr	r1, [sp, #0xc]
700af81e: 62ca         	str	r2, [r1, #0x2c]
700af820: 6288         	str	r0, [r1, #0x28]
; }
700af822: b004         	add	sp, #0x10
700af824: 4770         	bx	lr
		...
700af82e: 0000         	movs	r0, r0

700af830 <CSL_udmapCppi5SetPsDataLoc>:
; {
700af830: b082         	sub	sp, #0x8
700af832: 9001         	str	r0, [sp, #0x4]
700af834: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->descInfo, UDMAP_CPPI5_PD_DESCINFO_PSINFO, psLoc );
700af836: 9901         	ldr	r1, [sp, #0x4]
700af838: 6808         	ldr	r0, [r1]
700af83a: 9a00         	ldr	r2, [sp]
700af83c: f362 701c    	bfi	r0, r2, #28, #1
700af840: 6008         	str	r0, [r1]
; }
700af842: b002         	add	sp, #0x8
700af844: 4770         	bx	lr
		...
700af84e: 0000         	movs	r0, r0

700af850 <CSL_udmapCppi5SetPsFlags>:
; {
700af850: b082         	sub	sp, #0x8
700af852: 9001         	str	r0, [sp, #0x4]
700af854: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->pktInfo1, UDMAP_CPPI5_PD_PKTINFO1_PSFLGS, psFlags );
700af856: 9901         	ldr	r1, [sp, #0x4]
700af858: 6848         	ldr	r0, [r1, #0x4]
700af85a: 9a00         	ldr	r2, [sp]
700af85c: f362 601b    	bfi	r0, r2, #24, #4
700af860: 6048         	str	r0, [r1, #0x4]
; }
700af862: b002         	add	sp, #0x8
700af864: 4770         	bx	lr
		...
700af86e: 0000         	movs	r0, r0

700af870 <Sciclient_rmIrqRelease>:
; {
700af870: b580         	push	{r7, lr}
700af872: b084         	sub	sp, #0x10
700af874: 9003         	str	r0, [sp, #0xc]
700af876: 9102         	str	r1, [sp, #0x8]
;     return Sciclient_rmClearInterruptRoute(req, &resp, timeout);
700af878: 9803         	ldr	r0, [sp, #0xc]
700af87a: 9a02         	ldr	r2, [sp, #0x8]
700af87c: 4669         	mov	r1, sp
700af87e: f7f0 fee7    	bl	0x700a0650 <Sciclient_rmClearInterruptRoute> @ imm = #-0xf232
700af882: b004         	add	sp, #0x10
700af884: bd80         	pop	{r7, pc}
		...
700af88e: 0000         	movs	r0, r0

700af890 <Sciclient_secProxyReadThreadCount>:
; {
700af890: b580         	push	{r7, lr}
700af892: b082         	sub	sp, #0x8
700af894: 9001         	str	r0, [sp, #0x4]
;     return (CSL_REG32_RD(Sciclient_secProxyThreadStatusReg(thread)) &
700af896: 9801         	ldr	r0, [sp, #0x4]
700af898: f7ff ff12    	bl	0x700af6c0 <Sciclient_secProxyThreadStatusReg> @ imm = #-0x1dc
700af89c: f000 f9c8    	bl	0x700afc30 <CSL_REG32_RD_RAW> @ imm = #0x390
700af8a0: b2c0         	uxtb	r0, r0
700af8a2: b002         	add	sp, #0x8
700af8a4: bd80         	pop	{r7, pc}
		...
700af8ae: 0000         	movs	r0, r0

700af8b0 <SemaphoreP_destruct>:
; {
700af8b0: b580         	push	{r7, lr}
700af8b2: b082         	sub	sp, #0x8
700af8b4: 9001         	str	r0, [sp, #0x4]
;     SemaphoreP_Struct *pSemaphore = (SemaphoreP_Struct *)obj;
700af8b6: 9801         	ldr	r0, [sp, #0x4]
700af8b8: 9000         	str	r0, [sp]
;     vSemaphoreDelete(pSemaphore->semHndl);
700af8ba: 9800         	ldr	r0, [sp]
700af8bc: 6d00         	ldr	r0, [r0, #0x50]
700af8be: f7ff fb27    	bl	0x700aef10 <vQueueDelete> @ imm = #-0x9b2
; }
700af8c2: b002         	add	sp, #0x8
700af8c4: bd80         	pop	{r7, pc}
		...
700af8ce: 0000         	movs	r0, r0

700af8d0 <UART_divideRoundCloset>:
; {
700af8d0: b082         	sub	sp, #0x8
700af8d2: 9001         	str	r0, [sp, #0x4]
700af8d4: 9100         	str	r1, [sp]
;     return ((divident + (divisor/2U))/divisor);
700af8d6: 9801         	ldr	r0, [sp, #0x4]
700af8d8: 9900         	ldr	r1, [sp]
700af8da: eb00 0051    	add.w	r0, r0, r1, lsr #1
700af8de: fbb0 f0f1    	udiv	r0, r0, r1
700af8e2: b002         	add	sp, #0x8
700af8e4: 4770         	bx	lr
		...
700af8ee: 0000         	movs	r0, r0

700af8f0 <UART_regConfModeRestore>:
; {
700af8f0: b580         	push	{r7, lr}
700af8f2: b082         	sub	sp, #0x8
700af8f4: 9001         	str	r0, [sp, #0x4]
700af8f6: 9100         	str	r1, [sp]
;     HW_WR_REG32(baseAddr + UART_LCR, lcrRegValue);
700af8f8: 9801         	ldr	r0, [sp, #0x4]
700af8fa: 300c         	adds	r0, #0xc
700af8fc: 9900         	ldr	r1, [sp]
700af8fe: f000 f93f    	bl	0x700afb80 <HW_WR_REG32_RAW> @ imm = #0x27e
; }
700af902: b002         	add	sp, #0x8
700af904: bd80         	pop	{r7, pc}
		...
700af90e: 0000         	movs	r0, r0

700af910 <tm_thread_resume>:
; {
700af910: b580         	push	{r7, lr}
;    vTaskResume(tm_thread_array[thread_id]);
700af912: f245 11c8    	movw	r1, #0x51c8
700af916: f2c7 0108    	movt	r1, #0x7008
700af91a: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700af91e: f7f9 f82f    	bl	0x700a8980 <vTaskResume> @ imm = #-0x6fa2
;    return TM_SUCCESS;
700af922: 2000         	movs	r0, #0x0
700af924: bd80         	pop	{r7, pc}
		...
700af92e: 0000         	movs	r0, r0

700af930 <tm_thread_suspend>:
; {
700af930: b580         	push	{r7, lr}
;    vTaskSuspend(tm_thread_array[thread_id]);
700af932: f245 11c8    	movw	r1, #0x51c8
700af936: f2c7 0108    	movt	r1, #0x7008
700af93a: f851 0020    	ldr.w	r0, [r1, r0, lsl #2]
700af93e: f7f5 fb47    	bl	0x700a4fd0 <vTaskSuspend> @ imm = #-0xa972
;    return TM_SUCCESS;
700af942: 2000         	movs	r0, #0x0
700af944: bd80         	pop	{r7, pc}
		...
700af94e: 0000         	movs	r0, r0

700af950 <DebugP_uartSetDrvIndex>:
; {
700af950: b081         	sub	sp, #0x4
700af952: 9000         	str	r0, [sp]
;     gDebugP_uartDrvIndex = uartDrvIndex;
700af954: 9800         	ldr	r0, [sp]
700af956: f642 11e4    	movw	r1, #0x29e4
700af95a: f2c7 010b    	movt	r1, #0x700b
700af95e: 6008         	str	r0, [r1]
; }
700af960: b001         	add	sp, #0x4
700af962: 4770         	bx	lr
		...

700af970 <Sciclient_rmIrIntControlReg>:
; {
700af970: b081         	sub	sp, #0x4
700af972: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (outp * SCICLIENT_IR_INT_CONTROL_REG_STEP) +
700af976: f8bd 1002    	ldrh.w	r1, [sp, #0x2]
700af97a: 2004         	movs	r0, #0x4
700af97c: eb00 0081    	add.w	r0, r0, r1, lsl #2
700af980: b001         	add	sp, #0x4
700af982: 4770         	bx	lr
		...

700af990 <Udma_rmAllocFreeRing>:
; {
700af990: b082         	sub	sp, #0x8
700af992: 9001         	str	r0, [sp, #0x4]
700af994: f64f 70ff    	movw	r0, #0xffff
;     uint16_t            ringNum = UDMA_RING_INVALID;
700af998: f8ad 0002    	strh.w	r0, [sp, #0x2]
;     return (ringNum);
700af99c: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
700af9a0: b002         	add	sp, #0x8
700af9a2: 4770         	bx	lr
		...

700af9b0 <xTaskGetCurrentTaskHandle>:
; TaskHandle_t xTaskGetCurrentTaskHandle(void) {
700af9b0: b081         	sub	sp, #0x4
;   xReturn = pxCurrentTCB;
700af9b2: f642 10fc    	movw	r0, #0x29fc
700af9b6: f2c7 000b    	movt	r0, #0x700b
700af9ba: 6800         	ldr	r0, [r0]
700af9bc: 9000         	str	r0, [sp]
;   return xReturn;
700af9be: 9800         	ldr	r0, [sp]
700af9c0: b001         	add	sp, #0x4
700af9c2: 4770         	bx	lr
		...

700af9d0 <CSL_udmapCppi5SetSrcTag>:
; {
700af9d0: b082         	sub	sp, #0x8
700af9d2: 9001         	str	r0, [sp, #0x4]
700af9d4: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_SRCTAG, srcTag );
700af9d6: 9901         	ldr	r1, [sp, #0x4]
700af9d8: f8bd 0000    	ldrh.w	r0, [sp]
700af9dc: 81c8         	strh	r0, [r1, #0xe]
; }
700af9de: b002         	add	sp, #0x8
700af9e0: 4770         	bx	lr
		...
700af9ee: 0000         	movs	r0, r0

700af9f0 <TimerP_getCount>:
; {
700af9f0: b082         	sub	sp, #0x8
700af9f2: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TCRR);
700af9f4: 9801         	ldr	r0, [sp, #0x4]
700af9f6: 303c         	adds	r0, #0x3c
700af9f8: 9000         	str	r0, [sp]
;     return *addr;
700af9fa: 9800         	ldr	r0, [sp]
700af9fc: 6800         	ldr	r0, [r0]
700af9fe: b002         	add	sp, #0x8
700afa00: 4770         	bx	lr
		...
700afa0e: 0000         	movs	r0, r0

700afa10 <TimerP_getReloadCount>:
; {
700afa10: b082         	sub	sp, #0x8
700afa12: 9001         	str	r0, [sp, #0x4]
;     volatile uint32_t *addr = (volatile uint32_t *)(baseAddr + TIMER_TLDR);
700afa14: 9801         	ldr	r0, [sp, #0x4]
700afa16: 3040         	adds	r0, #0x40
700afa18: 9000         	str	r0, [sp]
;     return *addr;
700afa1a: 9800         	ldr	r0, [sp]
700afa1c: 6800         	ldr	r0, [r0]
700afa1e: b002         	add	sp, #0x8
700afa20: 4770         	bx	lr
		...
700afa2e: 0000         	movs	r0, r0

700afa30 <main_message_isr_test>:
; {
700afa30: b580         	push	{r7, lr}
;    tm_initialize(tm_message_isr_to_task_initialize);
700afa32: f24e 3001    	movw	r0, #0xe301
700afa36: f2c7 0009    	movt	r0, #0x7009
700afa3a: f000 f9c9    	bl	0x700afdd0 <tm_initialize> @ imm = #0x392
;    return 0;
700afa3e: 2000         	movs	r0, #0x0
700afa40: bd80         	pop	{r7, pc}
		...
700afa4e: 0000         	movs	r0, r0

700afa50 <putchar_>:
; {
700afa50: b510         	push	{r4, lr}
700afa52: 4604         	mov	r4, r0
;     DebugP_memLogWriterPutChar(character);
700afa54: f7f2 fd6c    	bl	0x700a2530 <DebugP_memLogWriterPutChar> @ imm = #-0xd528
;     DebugP_uartLogWriterPutChar(character);
700afa58: 4620         	mov	r0, r4
700afa5a: e8bd 4010    	pop.w	{r4, lr}
700afa5e: f7fd becf    	b.w	0x700ad800 <DebugP_uartLogWriterPutChar> @ imm = #-0x2262
		...
700afa6e: 0000         	movs	r0, r0

700afa70 <tm_interrupt_handler>:
;    if (test_interrupt_handler != NULL)
700afa70: f642 2000    	movw	r0, #0x2a00
700afa74: f2c7 000b    	movt	r0, #0x700b
700afa78: 6800         	ldr	r0, [r0]
700afa7a: 2800         	cmp	r0, #0x0
; }
700afa7c: bf08         	it	eq
700afa7e: 4770         	bxeq	lr
;       ((void (*)(void)) test_interrupt_handler)();
700afa80: 4700         	bx	r0
		...
700afa8e: 0000         	movs	r0, r0

700afa90 <tm_setup_pmu>:
; {
700afa90: b580         	push	{r7, lr}
;    PMU_init(&gPmuConfig);
700afa92: f642 1080    	movw	r0, #0x2980
700afa96: f2c7 000b    	movt	r0, #0x700b
700afa9a: f7f1 f9d1    	bl	0x700a0e40 <PMU_init>   @ imm = #-0xec5e
;    return 1;
700afa9e: 2001         	movs	r0, #0x1
700afaa0: bd80         	pop	{r7, pc}
		...
700afaae: 0000         	movs	r0, r0

700afab0 <uiPortGetRunTimeCounterValue>:
; uint32_t uiPortGetRunTimeCounterValue() {
700afab0: b580         	push	{r7, lr}
700afab2: b082         	sub	sp, #0x8
;   uint64_t timeInUsecs = ClockP_getTimeUsec();
700afab4: f7fb f864    	bl	0x700aab80 <ClockP_getTimeUsec> @ imm = #-0x4f38
700afab8: 9101         	str	r1, [sp, #0x4]
700afaba: 9000         	str	r0, [sp]
;   return (uint32_t)(timeInUsecs);
700afabc: 9800         	ldr	r0, [sp]
700afabe: b002         	add	sp, #0x8
700afac0: bd80         	pop	{r7, pc}
		...
700aface: 0000         	movs	r0, r0

700afad0 <CSL_REG32_WR_RAW>:
; {
700afad0: b082         	sub	sp, #0x8
700afad2: 9001         	str	r0, [sp, #0x4]
700afad4: 9100         	str	r1, [sp]
;     *p = v;
700afad6: 9800         	ldr	r0, [sp]
700afad8: 9901         	ldr	r1, [sp, #0x4]
700afada: 6008         	str	r0, [r1]
;     return;
700afadc: b002         	add	sp, #0x8
700afade: 4770         	bx	lr

700afae0 <CSL_REG32_WR_RAW>:
; {
700afae0: b082         	sub	sp, #0x8
700afae2: 9001         	str	r0, [sp, #0x4]
700afae4: 9100         	str	r1, [sp]
;     *p = v;
700afae6: 9800         	ldr	r0, [sp]
700afae8: 9901         	ldr	r1, [sp, #0x4]
700afaea: 6008         	str	r0, [r1]
;     return;
700afaec: b002         	add	sp, #0x8
700afaee: 4770         	bx	lr

700afaf0 <CSL_REG32_WR_RAW>:
; {
700afaf0: b082         	sub	sp, #0x8
700afaf2: 9001         	str	r0, [sp, #0x4]
700afaf4: 9100         	str	r1, [sp]
;     *p = v;
700afaf6: 9800         	ldr	r0, [sp]
700afaf8: 9901         	ldr	r1, [sp, #0x4]
700afafa: 6008         	str	r0, [r1]
;     return;
700afafc: b002         	add	sp, #0x8
700afafe: 4770         	bx	lr

700afb00 <CSL_REG32_WR_RAW>:
; {
700afb00: b082         	sub	sp, #0x8
700afb02: 9001         	str	r0, [sp, #0x4]
700afb04: 9100         	str	r1, [sp]
;     *p = v;
700afb06: 9800         	ldr	r0, [sp]
700afb08: 9901         	ldr	r1, [sp, #0x4]
700afb0a: 6008         	str	r0, [r1]
;     return;
700afb0c: b002         	add	sp, #0x8
700afb0e: 4770         	bx	lr

700afb10 <CSL_REG32_WR_RAW>:
; {
700afb10: b082         	sub	sp, #0x8
700afb12: 9001         	str	r0, [sp, #0x4]
700afb14: 9100         	str	r1, [sp]
;     *p = v;
700afb16: 9800         	ldr	r0, [sp]
700afb18: 9901         	ldr	r1, [sp, #0x4]
700afb1a: 6008         	str	r0, [r1]
;     return;
700afb1c: b002         	add	sp, #0x8
700afb1e: 4770         	bx	lr

700afb20 <CSL_udmapCppi5SetDstTag>:
; {
700afb20: b082         	sub	sp, #0x8
700afb22: 9001         	str	r0, [sp, #0x4]
700afb24: 9100         	str	r1, [sp]
;     CSL_FINS( ((CSL_UdmapCppi5HMPD *)pDesc)->srcDstTag, UDMAP_CPPI5_PD_SRCDSTTAG_DSTTAG, dstTag );
700afb26: 9901         	ldr	r1, [sp, #0x4]
700afb28: 9800         	ldr	r0, [sp]
700afb2a: 8188         	strh	r0, [r1, #0xc]
; }
700afb2c: b002         	add	sp, #0x8
700afb2e: 4770         	bx	lr

700afb30 <CSL_udmapCppi5SetOrgBufferLen>:
; {
700afb30: b082         	sub	sp, #0x8
700afb32: 9001         	str	r0, [sp, #0x4]
700afb34: 9100         	str	r1, [sp]
;     pDesc->orgBufLen = bufferLenBytes;
700afb36: 9800         	ldr	r0, [sp]
700afb38: 9901         	ldr	r1, [sp, #0x4]
700afb3a: 6248         	str	r0, [r1, #0x24]
; }
700afb3c: b002         	add	sp, #0x8
700afb3e: 4770         	bx	lr

700afb40 <ClockP_getTimerCount>:
; {
700afb40: b580         	push	{r7, lr}
700afb42: b082         	sub	sp, #0x8
700afb44: 9001         	str	r0, [sp, #0x4]
;     return TimerP_getCount(timerBaseAddr);
700afb46: 9801         	ldr	r0, [sp, #0x4]
700afb48: f7ff ff52    	bl	0x700af9f0 <TimerP_getCount> @ imm = #-0x15c
700afb4c: b002         	add	sp, #0x8
700afb4e: bd80         	pop	{r7, pc}

700afb50 <ClockP_sleepTicks>:
; {
700afb50: b580         	push	{r7, lr}
700afb52: b082         	sub	sp, #0x8
700afb54: 9001         	str	r0, [sp, #0x4]
;     vTaskDelay(ticks);
700afb56: 9801         	ldr	r0, [sp, #0x4]
700afb58: f7fe fc72    	bl	0x700ae440 <vTaskDelay> @ imm = #-0x171c
; }
700afb5c: b002         	add	sp, #0x8
700afb5e: bd80         	pop	{r7, pc}

700afb60 <ClockP_timerClearOverflowInt>:
; {
700afb60: b580         	push	{r7, lr}
700afb62: b082         	sub	sp, #0x8
700afb64: 9001         	str	r0, [sp, #0x4]
;     TimerP_clearOverflowInt(timerBaseAddr);
700afb66: 9801         	ldr	r0, [sp, #0x4]
700afb68: f7ff f852    	bl	0x700aec10 <TimerP_clearOverflowInt> @ imm = #-0xf5c
; }
700afb6c: b002         	add	sp, #0x8
700afb6e: bd80         	pop	{r7, pc}

700afb70 <HW_RD_REG32_RAW>:
; {
700afb70: b082         	sub	sp, #0x8
700afb72: 9001         	str	r0, [sp, #0x4]
;     uint32_t regVal = *(volatile uint32_t *) ((uintptr_t) addr);
700afb74: 9801         	ldr	r0, [sp, #0x4]
700afb76: 6800         	ldr	r0, [r0]
700afb78: 9000         	str	r0, [sp]
;     return (regVal);
700afb7a: 9800         	ldr	r0, [sp]
700afb7c: b002         	add	sp, #0x8
700afb7e: 4770         	bx	lr

700afb80 <HW_WR_REG32_RAW>:
; {
700afb80: b082         	sub	sp, #0x8
700afb82: 9001         	str	r0, [sp, #0x4]
700afb84: 9100         	str	r1, [sp]
;     *(volatile uint32_t *) ((uintptr_t) addr) = value;
700afb86: 9800         	ldr	r0, [sp]
700afb88: 9901         	ldr	r1, [sp, #0x4]
700afb8a: 6008         	str	r0, [r1]
;     return;
700afb8c: b002         	add	sp, #0x8
700afb8e: 4770         	bx	lr

700afb90 <Udma_defaultVirtToPhyFxn>:
; {
700afb90: b083         	sub	sp, #0xc
700afb92: 9002         	str	r0, [sp, #0x8]
700afb94: 9101         	str	r1, [sp, #0x4]
700afb96: 9200         	str	r2, [sp]
;     return ((uint64_t) virtAddr);
700afb98: 9802         	ldr	r0, [sp, #0x8]
700afb9a: 2100         	movs	r1, #0x0
700afb9c: b003         	add	sp, #0xc
700afb9e: 4770         	bx	lr

700afba0 <__aeabi_memset8>:
700afba0: e1a03001     	mov	r3, r1
700afba4: e1a01002     	mov	r1, r2
700afba8: e1a02003     	mov	r2, r3
700afbac: eafffef1     	b	0x700af778 <TI_memset_small> @ imm = #-0x43c

700afbb0 <_out_null>:
; {
700afbb0: b084         	sub	sp, #0x10
700afbb2: f88d 000f    	strb.w	r0, [sp, #0xf]
700afbb6: 9102         	str	r1, [sp, #0x8]
700afbb8: 9201         	str	r2, [sp, #0x4]
700afbba: 9300         	str	r3, [sp]
; }
700afbbc: b004         	add	sp, #0x10
700afbbe: 4770         	bx	lr

700afbc0 <vTaskSuspendAll>:
;   ++uxSchedulerSuspended;
700afbc0: f642 2124    	movw	r1, #0x2a24
700afbc4: f2c7 010b    	movt	r1, #0x700b
700afbc8: 6808         	ldr	r0, [r1]
700afbca: 3001         	adds	r0, #0x1
700afbcc: 6008         	str	r0, [r1]
; }
700afbce: 4770         	bx	lr

700afbd0 <CSL_REG64_RD_RAW>:
; {
700afbd0: b081         	sub	sp, #0x4
700afbd2: 9000         	str	r0, [sp]
;     return (*p);
700afbd4: 9800         	ldr	r0, [sp]
700afbd6: e9d0 0100    	ldrd	r0, r1, [r0]
700afbda: b001         	add	sp, #0x4
700afbdc: 4770         	bx	lr
700afbde: 0000         	movs	r0, r0

700afbe0 <vListInitialiseItem>:
; {
700afbe0: b081         	sub	sp, #0x4
700afbe2: 9000         	str	r0, [sp]
;     pxItem->pxContainer = NULL;
700afbe4: 9900         	ldr	r1, [sp]
700afbe6: 2000         	movs	r0, #0x0
700afbe8: 6108         	str	r0, [r1, #0x10]
; }
700afbea: b001         	add	sp, #0x4
700afbec: 4770         	bx	lr
700afbee: 0000         	movs	r0, r0

700afbf0 <vTaskMissedYield>:
; void vTaskMissedYield(void) { xYieldPending = pdTRUE; }
700afbf0: f642 2150    	movw	r1, #0x2a50
700afbf4: f2c7 010b    	movt	r1, #0x700b
700afbf8: 2001         	movs	r0, #0x1
700afbfa: 6008         	str	r0, [r1]
700afbfc: 4770         	bx	lr
700afbfe: 0000         	movs	r0, r0

700afc00 <CSL_REG32_RD_RAW>:
; {
700afc00: b081         	sub	sp, #0x4
700afc02: 9000         	str	r0, [sp]
;     return (*p);
700afc04: 9800         	ldr	r0, [sp]
700afc06: 6800         	ldr	r0, [r0]
700afc08: b001         	add	sp, #0x4
700afc0a: 4770         	bx	lr
700afc0c: 0000         	movs	r0, r0
700afc0e: 0000         	movs	r0, r0

700afc10 <CSL_REG32_RD_RAW>:
; {
700afc10: b081         	sub	sp, #0x4
700afc12: 9000         	str	r0, [sp]
;     return (*p);
700afc14: 9800         	ldr	r0, [sp]
700afc16: 6800         	ldr	r0, [r0]
700afc18: b001         	add	sp, #0x4
700afc1a: 4770         	bx	lr
700afc1c: 0000         	movs	r0, r0
700afc1e: 0000         	movs	r0, r0

700afc20 <CSL_REG32_RD_RAW>:
; {
700afc20: b081         	sub	sp, #0x4
700afc22: 9000         	str	r0, [sp]
;     return (*p);
700afc24: 9800         	ldr	r0, [sp]
700afc26: 6800         	ldr	r0, [r0]
700afc28: b001         	add	sp, #0x4
700afc2a: 4770         	bx	lr
700afc2c: 0000         	movs	r0, r0
700afc2e: 0000         	movs	r0, r0

700afc30 <CSL_REG32_RD_RAW>:
; {
700afc30: b081         	sub	sp, #0x4
700afc32: 9000         	str	r0, [sp]
;     return (*p);
700afc34: 9800         	ldr	r0, [sp]
700afc36: 6800         	ldr	r0, [r0]
700afc38: b001         	add	sp, #0x4
700afc3a: 4770         	bx	lr
700afc3c: 0000         	movs	r0, r0
700afc3e: 0000         	movs	r0, r0

700afc40 <CSL_REG32_RD_RAW>:
; {
700afc40: b081         	sub	sp, #0x4
700afc42: 9000         	str	r0, [sp]
;     return (*p);
700afc44: 9800         	ldr	r0, [sp]
700afc46: 6800         	ldr	r0, [r0]
700afc48: b001         	add	sp, #0x4
700afc4a: 4770         	bx	lr
700afc4c: 0000         	movs	r0, r0
700afc4e: 0000         	movs	r0, r0

700afc50 <CSL_REG32_RD_RAW>:
; {
700afc50: b081         	sub	sp, #0x4
700afc52: 9000         	str	r0, [sp]
;     return (*p);
700afc54: 9800         	ldr	r0, [sp]
700afc56: 6800         	ldr	r0, [r0]
700afc58: b001         	add	sp, #0x4
700afc5a: 4770         	bx	lr
700afc5c: 0000         	movs	r0, r0
700afc5e: 0000         	movs	r0, r0

700afc60 <PMU_resetCounters>:
; static void PMU_resetCounters(void) {
700afc60: b580         	push	{r7, lr}
;   CSL_armR5PmuResetCycleCnt();
700afc62: f7f2 eb00    	blx	0x700a2264 <CSL_armR5PmuResetCycleCnt> @ imm = #-0xda00
;   CSL_armR5PmuResetCntrs();
700afc66: f7f2 eb06    	blx	0x700a2274 <CSL_armR5PmuResetCntrs> @ imm = #-0xd9f4
; }
700afc6a: bd80         	pop	{r7, pc}
700afc6c: 0000         	movs	r0, r0
700afc6e: 0000         	movs	r0, r0

700afc70 <Sciclient_getSelfDevIdCore>:
;     return gSciclientHandle.devIdCore;
700afc70: f642 1048    	movw	r0, #0x2948
700afc74: f2c7 000b    	movt	r0, #0x700b
700afc78: 6880         	ldr	r0, [r0, #0x8]
700afc7a: 4770         	bx	lr
700afc7c: 0000         	movs	r0, r0
700afc7e: 0000         	movs	r0, r0

700afc80 <Sciclient_rmPsGetPsp>:
;     return gPstack.psp;
700afc80: f241 0058    	movw	r0, #0x1058
700afc84: f2c7 0008    	movt	r0, #0x7008
700afc88: 8c80         	ldrh	r0, [r0, #0x24]
700afc8a: 4770         	bx	lr
700afc8c: 0000         	movs	r0, r0
700afc8e: 0000         	movs	r0, r0

700afc90 <Udma_rmFreeFreeRing>:
; {
700afc90: b082         	sub	sp, #0x8
700afc92: f8ad 0006    	strh.w	r0, [sp, #0x6]
700afc96: 9100         	str	r1, [sp]
;     return;
700afc98: b002         	add	sp, #0x8
700afc9a: 4770         	bx	lr
700afc9c: 0000         	movs	r0, r0
700afc9e: 0000         	movs	r0, r0

700afca0 <xTaskGetIdleTaskHandle>:
;   return xIdleTaskHandle;
700afca0: f642 2030    	movw	r0, #0x2a30
700afca4: f2c7 000b    	movt	r0, #0x700b
700afca8: 6800         	ldr	r0, [r0]
700afcaa: 4770         	bx	lr
700afcac: 0000         	movs	r0, r0
700afcae: 0000         	movs	r0, r0

700afcb0 <Hwip_dataAndInstructionBarrier>:
;     __asm__ __volatile__ (" isb"   "\n\t": : : "memory");
700afcb0: f3bf 8f6f    	isb	sy
;     __asm__ __volatile__ (" dsb"   "\n\t": : : "memory");
700afcb4: f3bf 8f4f    	dsb	sy
; }
700afcb8: 4770         	bx	lr
700afcba: 0000         	movs	r0, r0
700afcbc: 0000         	movs	r0, r0
700afcbe: 0000         	movs	r0, r0

700afcc0 <.Lfastpath_exit>:
700afcc0: e0420003     	sub	r0, r2, r3
700afcc4: e12fff1e     	bx	lr
700afcc8: e320f000     	nop
700afccc: 00000000     	andeq	r0, r0, r0

700afcd0 <prvTaskExitError>:
; static void prvTaskExitError(void) {
700afcd0: b580         	push	{r7, lr}
700afcd2: 2000         	movs	r0, #0x0
;   DebugP_assertNoLog(0);
700afcd4: f001 fb04    	bl	0x700b12e0 <_DebugP_assertNoLog> @ imm = #0x1608
; }
700afcd8: bd80         	pop	{r7, pc}
700afcda: 0000         	movs	r0, r0
700afcdc: 0000         	movs	r0, r0
700afcde: 0000         	movs	r0, r0

700afce0 <ClockP_getTicks>:
; {
700afce0: b580         	push	{r7, lr}
;     return ((uint32_t)xTaskGetTickCount());
700afce2: f7ff fc2d    	bl	0x700af540 <xTaskGetTickCount> @ imm = #-0x7a6
700afce6: bd80         	pop	{r7, pc}
		...

700afcf0 <UART_lld_errorCallback>:
; {
700afcf0: b081         	sub	sp, #0x4
700afcf2: 9000         	str	r0, [sp]
; }
700afcf4: b001         	add	sp, #0x4
700afcf6: 4770         	bx	lr
		...

700afd00 <Udma_ringAssertFnPointers>:
; {
700afd00: b081         	sub	sp, #0x4
700afd02: 9000         	str	r0, [sp]
;     return;
700afd04: b001         	add	sp, #0x4
700afd06: 4770         	bx	lr
		...

700afd10 <vApplicationIdleHook>:
; void vApplicationIdleHook(void) {
700afd10: b580         	push	{r7, lr}
;   vApplicationLoadHook();
700afd12: f7fc f87d    	bl	0x700abe10 <vApplicationLoadHook> @ imm = #-0x3f06
; }
700afd16: bd80         	pop	{r7, pc}
		...

700afd20 <tm_interrupt_raise>:
;    HwiP_post(SOFTWARE_INTERRUPT_ID);
700afd20: 200a         	movs	r0, #0xa
700afd22: f000 b8f5    	b.w	0x700aff10 <HwiP_post>  @ imm = #0x1ea
		...
700afd2e: 0000         	movs	r0, r0

700afd30 <Board_driversOpen>:
;     return status;
700afd30: 2000         	movs	r0, #0x0
700afd32: 4770         	bx	lr
		...

700afd40 <Sciclient_rmPsGetMaxPsp>:
; {
700afd40: 2003         	movs	r0, #0x3
;     return SCICLIENT_PS_MAX_DEPTH;
700afd42: 4770         	bx	lr
		...

700afd50 <TaskP_yield>:
;     taskYIELD();
700afd50: df00         	svc	#0x0
; }
700afd52: 4770         	bx	lr
		...

700afd60 <__aeabi_idiv0>:
700afd60: e12fff1e     	bx	lr
		...

700afd70 <__aeabi_ldiv0>:
700afd70: e12fff1e     	bx	lr
		...

700afd80 <main>:
;    return rtos_main_freertos();
700afd80: f7f9 b846    	b.w	0x700a8e10 <rtos_main_freertos> @ imm = #-0x6f74
		...

700afd90 <tm_pmu_profile_end>:
;    PMU_profileEnd(name);
700afd90: f7f5 bdd6    	b.w	0x700a5940 <PMU_profileEnd> @ imm = #-0xa454
		...

700afda0 <tm_pmu_profile_print>:
;    PMU_profilePrintEntry(name);
700afda0: f7f7 bd2e    	b.w	0x700a7800 <PMU_profilePrintEntry> @ imm = #-0x85a4
		...

700afdb0 <tm_pmu_profile_start>:
;    PMU_profileStart(name);
700afdb0: f7f9 bbee    	b.w	0x700a9590 <PMU_profileStart> @ imm = #-0x6824
		...

700afdc0 <Board_init>:
; }
700afdc0: 4770         	bx	lr
		...
700afdce: 0000         	movs	r0, r0

700afdd0 <tm_initialize>:
;    test_initialization_function();
700afdd0: 4700         	bx	r0
		...
700afdde: 0000         	movs	r0, r0

700afde0 <vPortConfigTimerForRunTimeStats>:
; }
700afde0: 4770         	bx	lr
		...
700afdfe: 0000         	movs	r0, r0
